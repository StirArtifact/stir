extern	O
char	O
*	O
program_name	pointer
;	O
void	O
fatal	function
(	O
char	O
*	O
s	pointer
)	O
{	O
(	O
void	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
program_name	pointer
,	O
s	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
FILE	struct
*	O
file_open	function
(	O
char	O
*	O
file_name	pointer
,	O
int	O
write_flag	int
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
NULL	O
;	O
if	O
(	O
file_name	pointer
==	O
NULL	O
)	O
fatal	function
(	O
"file_open: FILE_NAME is NULL"	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
file_name	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
return	O
write_flag	pointer
?	O
stdout	pointer
:	O
stdin	pointer
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
file_name	pointer
,	O
write_flag	pointer
?	O
"wb"	pointer
:	O
"rb"	function
)	O
)	O
==	O
NULL	O
)	O
{	O
char	O
*	O
tmp	pointer
=	O
(	O
char	O
*	O
)	O
alloca	O
(	O
sizeof	O
(	O
char	O
)	O
*	O
(	O
strlen	function
(	O
file_name	pointer
)	O
+	O
30	int
)	O
)	O
;	O
(	O
void	O
)	O
sprintf	function
(	O
tmp	array
,	O
"couldn't open file '%s'"	pointer
,	O
file_name	pointer
)	O
;	O
perror	function
(	O
tmp	pointer
)	O
;	O
}	O
return	O
fp	pointer
;	O
}	O
void	O
print_wtmp_file_location	function
(	O
void	O
)	O
{	O
(	O
void	O
)	O
printf	function
(	O
"\nThe system's default login accounting file is %s.\n"	pointer
,	O
WTMP_FILE_LOC	pointer
)	O
;	O
}	O
void	O
print_acct_file_location	function
(	O
void	O
)	O
{	O
(	O
void	O
)	O
printf	function
(	O
"\nThe system's default process accounting file is %s.\n"	pointer
,	O
ACCT_FILE_LOC	pointer
)	O
;	O
}	O
void	O
print_acct_file_locations	function
(	O
void	O
)	O
{	O
(	O
void	O
)	O
printf	function
(	O
"The system's default process accounting files are:\n\n"	pointer
)	O
;	O
(	O
void	O
)	O
printf	function
(	O
"  raw process accounting data: %s\n"	pointer
,	O
ACCT_FILE_LOC	pointer
)	O
;	O
(	O
void	O
)	O
printf	function
(	O
"      summary by command name: %s\n"	pointer
,	O
SAVACCT_FILE_LOC	pointer
)	O
;	O
(	O
void	O
)	O
printf	function
(	O
"          summary by username: %s\n\n"	pointer
,	O
USRACCT_FILE_LOC	pointer
)	O
;	O
}	O
struct	O
hashtab	struct
*	O
dev_table	pointer
=	O
NULL	O
;	O
struct	O
dev_data	struct
{	O
char	O
*	O
name	pointer
;	O
}	O
;	O
static	O
void	O
setup_pts_devices	function
(	O
)	O
{	O
struct	O
utsname	struct
uts	pointer
;	O
struct	O
dev_data	struct
dd	pointer
;	O
int	O
i	int
;	O
struct	O
pts_params	struct
*	O
pts_ent	pointer
,	O
pts_table	array
[	O
]	O
=	O
{	O
{	O
"Linux"	pointer
,	O
136	int
,	O
2048	int
,	O
256	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
uname	function
(	O
&	O
uts	struct
)	O
)	O
{	O
return	O
;	O
}	O
for	O
(	O
pts_ent	int
=	O
&	O
(	O
pts_table	array
[	O
0	int
]	O
)	O
;	O
pts_ent	pointer
!=	O
NULL	O
;	O
++	O
pts_ent	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
uts	struct
.	O
sysname	pointer
,	O
pts_ent	pointer
->	O
utsname	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
pts_ent	pointer
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pts_ent	pointer
->	O
max	int
;	O
++	O
i	int
)	O
{	O
long	O
dev_num	long
;	O
struct	O
hashtab_elem	struct
*	O
he	pointer
;	O
int	O
major	int
,	O
minor	int
;	O
major	int
=	O
pts_ent	pointer
->	O
base	pointer
+	O
(	O
i	long
/	O
pts_ent	pointer
->	O
mod	int
)	O
;	O
minor	int
=	O
i	int
%	O
pts_ent	pointer
->	O
mod	int
;	O
dev_num	int
=	O
(	O
(	O
major	int
<<	O
8	int
)	O
+	O
minor	int
)	O
;	O
dd	struct
.	O
name	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
(	O
strlen	function
(	O
"pts/xxxx"	pointer
)	O
+	O
1	int
)	O
)	O
;	O
sprintf	function
(	O
dd	pointer
.	O
name	pointer
,	O
"pts/%d"	pointer
,	O
i	long
)	O
;	O
he	pointer
=	O
hashtab_create	function
(	O
dev_table	pointer
,	O
(	O
void	O
*	O
)	O
&	O
dev_num	pointer
,	O
sizeof	O
(	O
dev_num	pointer
)	O
)	O
;	O
hashtab_set_value	function
(	O
he	pointer
,	O
&	O
dd	pointer
,	O
sizeof	O
(	O
dd	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
setup_devices	function
(	O
char	O
*	O
dirname	pointer
)	O
{	O
DIR	struct
*	O
dirp	pointer
;	O
struct	O
dirent	struct
*	O
dp	pointer
;	O
struct	O
stat	struct
sp	pointer
;	O
extern	O
int	O
debugging_enabled	int
;	O
if	O
(	O
debugging_enabled	int
)	O
(	O
void	O
)	O
fprintf	function
(	O
stddebug	O
,	O
"device     devnum\n-----------------\n"	pointer
)	O
;	O
if	O
(	O
(	O
dirp	pointer
=	O
opendir	function
(	O
dirname	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
dirname	pointer
,	O
"/dev/pts"	pointer
)	O
)	O
{	O
closedir	function
(	O
dirp	pointer
)	O
;	O
setup_pts_devices	function
(	O
)	O
;	O
return	O
;	O
}	O
for	O
(	O
dp	pointer
=	O
readdir	function
(	O
dirp	pointer
)	O
;	O
dp	pointer
!=	O
NULL	O
;	O
dp	pointer
=	O
readdir	function
(	O
dirp	pointer
)	O
)	O
{	O
char	O
*	O
fullname	pointer
=	O
(	O
char	O
*	O
)	O
alloca	function
(	O
(	O
strlen	function
(	O
dirname	pointer
)	O
+	O
NAMLEN	function
(	O
dp	pointer
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
(	O
void	O
)	O
sprintf	function
(	O
fullname	pointer
,	O
"%s/%s"	pointer
,	O
dirname	pointer
,	O
dp	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
stat	struct
(	O
fullname	pointer
,	O
&	O
sp	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
sp	struct
.	O
st_mode	int
&	O
S_IFMT	O
)	O
!=	O
S_IFCHR	O
)	O
continue	O
;	O
if	O
(	O
debugging_enabled	int
)	O
fprintf	function
(	O
stddebug	O
,	O
"%-8.8d %s\n"	pointer
,	O
(	O
int	O
)	O
sp	struct
.	O
st_rdev	long
,	O
dp	pointer
->	O
d_name	array
)	O
;	O
{	O
struct	O
hashtab_elem	struct
*	O
he	pointer
;	O
struct	O
dev_data	struct
dd	pointer
;	O
long	O
dev_num	long
;	O
dev_num	pointer
=	O
sp	pointer
.	O
st_rdev	pointer
;	O
dd	struct
.	O
name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
(	O
NAMLEN	function
(	O
dp	pointer
)	O
+	O
1	int
)	O
)	O
;	O
(	O
void	O
)	O
strcpy	function
(	O
dd	pointer
.	O
name	pointer
,	O
dp	pointer
->	O
d_name	array
)	O
;	O
he	pointer
=	O
hashtab_create	function
(	O
dev_table	pointer
,	O
(	O
void	O
*	O
)	O
&	O
dev_num	O
,	O
sizeof	O
(	O
dev_num	pointer
)	O
)	O
;	O
hashtab_set_value	function
(	O
he	pointer
,	O
&	O
dd	pointer
,	O
sizeof	O
(	O
dd	pointer
)	O
)	O
;	O
}	O
}	O
(	O
void	O
)	O
closedir	function
(	O
dirp	pointer
)	O
;	O
}	O
char	O
*	O
dev_gnu_name	function
(	O
long	O
dev_num	long
)	O
{	O
struct	O
hashtab_elem	struct
*	O
he	pointer
;	O
static	O
char	O
devstr	array
[	O
20	int
]	O
;	O
if	O
(	O
dev_num	int
==	O
NULLDEV	pointer
)	O
return	O
"__"	pointer
;	O
if	O
(	O
dev_table	pointer
==	O
NULL	O
)	O
{	O
dev_table	pointer
=	O
hashtab_init	function
(	O
sizeof	O
(	O
long	O
)	O
)	O
;	O
setup_devices	function
(	O
"/dev"	pointer
)	O
;	O
setup_devices	function
(	O
"/dev/pty"	pointer
)	O
;	O
setup_devices	function
(	O
"/dev/ptym"	pointer
)	O
;	O
setup_devices	function
(	O
"/dev/pts"	pointer
)	O
;	O
}	O
he	pointer
=	O
hashtab_find	function
(	O
dev_table	pointer
,	O
(	O
void	O
*	O
)	O
&	O
dev_num	O
,	O
(	O
unsigned	O
int	O
)	O
sizeof	O
(	O
dev_num	struct
)	O
)	O
;	O
if	O
(	O
he	pointer
!=	O
NULL	O
)	O
{	O
struct	O
dev_data	struct
*	O
dd	pointer
=	O
hashtab_get_value	function
(	O
he	pointer
)	O
;	O
return	O
dd	pointer
->	O
name	pointer
;	O
}	O
sprintf	function
(	O
devstr	pointer
,	O
"[%d,%d]"	pointer
,	O
(	O
int	O
)	O
(	O
(	O
dev_num	int
&	O
0xFF00	int
)	O
>>	O
8	int
)	O
,	O
(	O
int	O
)	O
(	O
dev_num	int
&	O
0x00FF	int
)	O
)	O
;	O
return	O
devstr	int
;	O
}	O
char	O
*	O
extract_trimmed_name	function
(	O
const	O
STRUCT_UTMP	struct
*	O
ut	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
trimmed_name	pointer
;	O
trimmed_name	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
UT_USER	O
(	O
ut	pointer
)	O
)	O
+	O
1	int
)	O
;	O
strncpy	function
(	O
trimmed_name	pointer
,	O
UT_USER	O
(	O
ut	pointer
)	O
,	O
sizeof	O
(	O
UT_USER	O
(	O
ut	pointer
)	O
)	O
)	O
;	O
trimmed_name	pointer
[	O
sizeof	O
(	O
UT_USER	O
(	O
ut	pointer
)	O
)	O
]	O
=	O
'\0'	O
;	O
for	O
(	O
p	pointer
=	O
trimmed_name	pointer
+	O
strlen	function
(	O
trimmed_name	pointer
)	O
;	O
trimmed_name	pointer
<	O
p	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
' '	O
;	O
*	O
--	O
p	pointer
=	O
'\0'	O
)	O
continue	O
;	O
return	O
trimmed_name	function
;	O
}	O
static	O
bool	bool
desirable_utmp_entry	function
(	O
STRUCT_UTMP	struct
const	O
*	O
u	pointer
,	O
int	O
options	int
)	O
{	O
bool	bool
user_proc	bool
=	O
IS_USER_PROCESS	O
(	O
u	pointer
)	O
;	O
if	O
(	O
(	O
options	int
&	O
READ_UTMP_USER_PROCESS	int
)	O
&&	O
!	O
user_proc	bool
)	O
return	O
false	int
;	O
if	O
(	O
(	O
options	int
&	O
READ_UTMP_CHECK_PIDS	int
)	O
&&	O
user_proc	bool
&&	O
0	int
<	O
UT_PID	O
(	O
u	pointer
)	O
&&	O
(	O
kill	function
(	O
UT_PID	O
(	O
u	pointer
)	O
,	O
0	int
)	O
<	O
0	int
&&	O
errno	O
==	O
ESRCH	int
)	O
)	O
return	O
false	int
;	O
return	O
true	int
;	O
}	O
int	O
read_utmp	function
(	O
char	O
const	O
*	O
file	pointer
,	O
size_t	long
*	O
n_entries	pointer
,	O
STRUCT_UTMP	struct
*	O
*	O
utmp_buf	pointer
,	O
int	O
options	int
)	O
{	O
size_t	long
n_read	long
=	O
0	int
;	O
size_t	long
n_alloc	long
=	O
0	int
;	O
STRUCT_UTMP	struct
*	O
utmp	struct
=	O
NULL	O
;	O
STRUCT_UTMP	struct
*	O
u	pointer
;	O
UTMP_NAME_FUNCTION	O
(	O
file	pointer
)	O
;	O
SET_UTMP_ENT	O
(	O
)	O
;	O
while	O
(	O
(	O
u	pointer
=	O
GET_UTMP_ENT	function
(	O
)	O
)	O
!=	O
NULL	O
)	O
if	O
(	O
desirable_utmp_entry	function
(	O
u	pointer
,	O
options	int
)	O
)	O
{	O
if	O
(	O
n_read	long
==	O
n_alloc	long
)	O
utmp	struct
=	O
x2nrealloc	function
(	O
utmp	struct
,	O
&	O
n_alloc	long
,	O
sizeof	O
*	O
utmp	struct
)	O
;	O
utmp	struct
[	O
n_read	long
++	O
]	O
=	O
*	O
u	pointer
;	O
}	O
END_UTMP_ENT	O
(	O
)	O
;	O
*	O
n_entries	pointer
=	O
n_read	long
;	O
*	O
utmp_buf	pointer
=	O
utmp	struct
;	O
return	O
0	int
;	O
}	O
static	O
char	O
rcsid	array
[	O
]	O
=	O
"$Id: rpc_clntout.c,v 1.1.1.1 2005/10/28 14:46:46 k0ro Exp $"	pointer
;	O
static	O
int	O
write_program	function
(	O
)	O
,	O
printbody	function
(	O
)	O
;	O
void	O
write_stubs	function
(	O
)	O
{	O
list	pointer
*	O
l	pointer
;	O
definition	struct
*	O
def	pointer
;	O
f_print	function
(	O
fout	pointer
,	O
"\n/* Default timeout can be changed using clnt_control() */\n"	pointer
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"static struct timeval TIMEOUT = { %d, 0 };\n"	pointer
,	O
DEFAULT_TIMEOUT	pointer
)	O
;	O
for	O
(	O
l	pointer
=	O
defined	pointer
;	O
l	pointer
!=	O
NULL	O
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
{	O
def	pointer
=	O
(	O
definition	enum
*	O
)	O
l	pointer
->	O
val	int
;	O
if	O
(	O
def	pointer
->	O
def_kind	int
==	O
DEF_PROGRAM	int
)	O
{	O
write_program	function
(	O
def	pointer
)	O
;	O
}	O
}	O
}	O
static	O
write_program	function
(	O
def	pointer
)	O
definition	struct
*	O
def	pointer
;	O
{	O
version_list	struct
*	O
vp	pointer
;	O
proc_list	struct
*	O
proc	int
;	O
for	O
(	O
vp	pointer
=	O
def	pointer
->	O
def	pointer
.	O
pr	struct
.	O
versions	pointer
;	O
vp	pointer
!=	O
NULL	O
;	O
vp	pointer
=	O
vp	pointer
->	O
next	pointer
)	O
{	O
for	O
(	O
proc	int
=	O
vp	pointer
->	O
procs	O
;	O
proc	O
!=	O
NULL	O
;	O
proc	int
=	O
proc	O
->	O
next	pointer
)	O
{	O
f_print	function
(	O
fout	pointer
,	O
"\n"	pointer
)	O
;	O
ptype	function
(	O
proc	O
->	O
res_prefix	pointer
,	O
proc	O
->	O
res_type	pointer
,	O
1	int
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"*\n"	pointer
)	O
;	O
pvname	function
(	O
proc	O
->	O
proc_name	pointer
,	O
vp	pointer
->	O
vers_num	pointer
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"(argp, clnt)\n"	pointer
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"\t"	pointer
)	O
;	O
ptype	function
(	O
proc	O
->	O
arg_prefix	pointer
,	O
proc	O
->	O
arg_type	pointer
,	O
1	int
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"*argp;\n"	pointer
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"\tCLIENT *clnt;\n"	pointer
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"{\n"	pointer
)	O
;	O
printbody	function
(	O
proc	int
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"}\n\n"	pointer
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
ampr	function
(	O
type	pointer
)	O
char	O
*	O
type	pointer
;	O
{	O
if	O
(	O
isvectordef	function
(	O
type	pointer
,	O
REL_ALIAS	pointer
)	O
)	O
{	O
return	O
(	O
""	pointer
)	O
;	O
}	O
else	O
{	O
return	O
(	O
"&"	pointer
)	O
;	O
}	O
}	O
static	O
printbody	function
(	O
proc	int
)	O
proc_list	enum
*	O
proc	int
;	O
{	O
f_print	function
(	O
fout	pointer
,	O
"\tstatic "	pointer
)	O
;	O
if	O
(	O
streq	function
(	O
proc	O
->	O
res_type	pointer
,	O
"void"	pointer
)	O
)	O
{	O
f_print	function
(	O
fout	pointer
,	O
"char "	pointer
)	O
;	O
}	O
else	O
{	O
ptype	function
(	O
proc	int
->	O
res_prefix	pointer
,	O
proc	int
->	O
res_type	pointer
,	O
0	int
)	O
;	O
}	O
f_print	function
(	O
fout	pointer
,	O
"res;\n"	pointer
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"\n"	pointer
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"\tbzero((char *)%sres, sizeof(res));\n"	pointer
,	O
ampr	function
(	O
proc	int
->	O
res_type	pointer
)	O
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"\tif (clnt_call(clnt, %s, xdr_%s, argp, xdr_%s, %sres, TIMEOUT) != RPC_SUCCESS) {\n"	pointer
,	O
proc	int
->	O
proc_name	pointer
,	O
stringfix	function
(	O
proc	O
->	O
arg_type	pointer
)	O
,	O
stringfix	function
(	O
proc	O
->	O
res_type	pointer
)	O
,	O
ampr	function
(	O
proc	int
->	O
res_type	pointer
)	O
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"\t\treturn (NULL);\n"	pointer
)	O
;	O
f_print	function
(	O
fout	pointer
,	O
"\t}\n"	pointer
)	O
;	O
if	O
(	O
streq	function
(	O
proc	O
->	O
res_type	pointer
,	O
"void"	pointer
)	O
)	O
{	O
f_print	function
(	O
fout	pointer
,	O
"\treturn ((void *)%sres);\n"	pointer
,	O
ampr	function
(	O
proc	int
->	O
res_type	pointer
)	O
)	O
;	O
}	O
else	O
{	O
f_print	function
(	O
fout	pointer
,	O
"\treturn (%sres);\n"	pointer
,	O
ampr	function
(	O
proc	int
->	O
res_type	pointer
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
{	O
dis_datum_type	enum
id	enum
;	O
char	O
*	O
name	pointer
;	O
}	O
dis_datum_info	struct
;	O
char	O
*	O
DISLookupDatumIDName	function
(	O
dis_datum_type	enum
id	enum
)	O
{	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
lookup	pointer
[	O
i	int
]	O
.	O
id	int
!=	O
0	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
lookup	pointer
[	O
i	int
]	O
.	O
id	int
==	O
id	int
)	O
{	O
return	O
lookup	pointer
[	O
i	int
]	O
.	O
name	pointer
;	O
}	O
}	O
return	O
(	O
char	O
*	O
)	O
0	int
;	O
}	O
static	O
unsigned	O
char	O
pdu_family	array
[	O
256	int
]	O
=	O
{	O
0	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
3	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
5	int
,	O
6	int
,	O
6	int
,	O
4	int
,	O
4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
}	O
;	O
static	O
int	O
protocol_version	int
=	O
DISProtocolVersionIEEE1278_95	pointer
;	O
int	O
DISxSetProtocolVersion	function
(	O
int	O
version	int
)	O
{	O
int	O
result	int
=	O
protocol_version	int
;	O
protocol_version	int
=	O
version	int
;	O
return	O
result	int
;	O
}	O
int	O
DISxSetPDUProtocolFamily	function
(	O
int	O
pdu_type	int
,	O
int	O
protocol_family	int
)	O
{	O
int	O
result	int
;	O
if	O
(	O
pdu_type	char
<	O
0	int
||	O
pdu_type	char
>	O
255	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
result	int
=	O
pdu_family	array
[	O
pdu_type	int
]	O
;	O
pdu_family	array
[	O
pdu_type	int
]	O
=	O
protocol_family	int
;	O
return	O
result	int
;	O
}	O
int	O
DISxPortNumber	int
=	O
-	O
1	int
;	O
DISxApplicationInfo	struct
*	O
DISxInitializeApplication	function
(	O
unsigned	O
int	O
exercise_id	int
,	O
unsigned	O
int	O
site_id	int
,	O
unsigned	O
int	O
application_id	int
)	O
{	O
char	O
name	array
[	O
64	int
]	O
;	O
int	O
result	int
;	O
DISxApplicationInfo	struct
*	O
p	pointer
=	O
(	O
DISxApplicationInfo	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
DISxApplicationInfo	struct
)	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
return	O
p	pointer
;	O
}	O
p	pointer
->	O
hdr	struct
.	O
protocol_version	int
=	O
protocol_version	int
;	O
p	pointer
->	O
hdr	struct
.	O
exercise_id	pointer
=	O
exercise_id	pointer
;	O
p	pointer
->	O
hdr	struct
.	O
padding	char
=	O
0	int
;	O
p	pointer
->	O
last_event	short
=	O
0	int
;	O
p	pointer
->	O
last_entity	int
=	O
0	int
;	O
p	pointer
->	O
last_request	int
=	O
0	int
;	O
p	pointer
->	O
xcvr	pointer
=	O
DISOpenTransceiver	function
(	O
DISxPortNumber	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
->	O
xcvr	pointer
)	O
{	O
free	function
(	O
p	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
DISSetNBIOState	function
(	O
p	pointer
->	O
xcvr	pointer
,	O
1	int
)	O
!=	O
0	int
)	O
{	O
free	function
(	O
p	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
site_id	int
!=	O
0	int
&&	O
application_id	int
!=	O
0	int
)	O
{	O
p	pointer
->	O
id	O
.	O
site_id	int
=	O
site_id	short
;	O
p	pointer
->	O
id	union
.	O
application_id	short
=	O
application_id	short
;	O
result	pointer
=	O
SIMx_SUCCESS	int
;	O
}	O
else	O
{	O
if	O
(	O
site_id	short
==	O
0	int
)	O
{	O
SIMxGetSiteName	function
(	O
name	pointer
,	O
sizeof	O
(	O
name	pointer
)	O
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
name	pointer
,	O
"0x%x"	pointer
,	O
site_id	double
)	O
;	O
}	O
result	pointer
=	O
SIMxRegisterApplication	function
(	O
(	O
char	O
*	O
)	O
NULL	O
,	O
name	pointer
,	O
application_id	short
,	O
&	O
p	pointer
->	O
id	enum
)	O
;	O
}	O
return	O
(	O
result	pointer
==	O
SIMx_SUCCESS	int
)	O
?	O
p	pointer
:	O
NULL	O
;	O
}	O
void	O
DISxGetSimulationAddress	function
(	O
DISxApplicationInfo	struct
*	O
info	pointer
,	O
dis_simulation_addr	struct
*	O
p	pointer
)	O
{	O
*	O
p	pointer
=	O
info	pointer
->	O
id	enum
;	O
}	O
void	O
DISxSetExerciseID	function
(	O
DISxApplicationInfo	struct
*	O
info	pointer
,	O
int	O
id	int
)	O
{	O
info	pointer
->	O
hdr	struct
.	O
exercise_id	int
=	O
id	int
;	O
}	O
int	O
DISxWritePDU	function
(	O
DISxApplicationInfo	struct
*	O
info	pointer
,	O
dis_pdu	struct
*	O
p	pointer
)	O
{	O
p	pointer
->	O
hdr	struct
.	O
protocol_version	int
=	O
info	pointer
->	O
hdr	struct
.	O
protocol_version	int
;	O
p	pointer
->	O
hdr	struct
.	O
exercise_id	double
=	O
info	pointer
->	O
hdr	struct
.	O
exercise_id	array
;	O
p	pointer
->	O
hdr	struct
.	O
protocol_family	pointer
=	O
pdu_family	array
[	O
p	pointer
->	O
hdr	struct
.	O
pdu_type	char
]	O
;	O
return	O
DISWritePDU	function
(	O
info	pointer
->	O
xcvr	pointer
,	O
p	pointer
)	O
;	O
}	O
int	O
DISxReadPDU	function
(	O
DISxApplicationInfo	struct
*	O
info	pointer
,	O
dis_pdu	struct
*	O
p	pointer
)	O
{	O
return	O
DISReadPDU	function
(	O
info	pointer
->	O
xcvr	pointer
,	O
p	pointer
)	O
;	O
}	O
void	O
DISxCloseApplication	function
(	O
DISxApplicationInfo	struct
*	O
info	pointer
)	O
{	O
DISCloseTransceiver	function
(	O
info	pointer
->	O
xcvr	pointer
)	O
;	O
free	function
(	O
info	pointer
)	O
;	O
}	O
dis_request_id	O
DISxIssueRequestID	function
(	O
DISxApplicationInfo	struct
*	O
info	pointer
)	O
{	O
dis_request_id	enum
result	enum
;	O
result	pointer
=	O
++	O
info	pointer
->	O
last_request	enum
;	O
if	O
(	O
info	pointer
->	O
last_request	enum
==	O
0xfffffff	int
)	O
{	O
info	pointer
->	O
last_request	int
=	O
0	int
;	O
}	O
return	O
result	pointer
;	O
}	O
bool_t	int
xdr_byte_opaque	function
(	O
XDR	struct
*	O
xdrs	pointer
,	O
caddr_t	pointer
cp	pointer
,	O
u_int	int
cnt	int
)	O
;	O
bool_t	int
xdr_byte_long	function
(	O
XDR	struct
*	O
xdrs	pointer
,	O
void	O
*	O
vcp	pointer
)	O
{	O
long	O
u	pointer
;	O
long	O
int	O
*	O
cp	pointer
=	O
(	O
long	O
int	O
*	O
)	O
vcp	pointer
;	O
u	pointer
=	O
htonl	function
(	O
*	O
cp	pointer
)	O
;	O
if	O
(	O
!	O
xdr_byte_opaque	function
(	O
xdrs	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
u	pointer
,	O
4	int
)	O
)	O
{	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
*	O
cp	pointer
=	O
ntohl	function
(	O
u	int
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
bool_t	int
xdr_byte_u_long	function
(	O
XDR	struct
*	O
xdrs	pointer
,	O
void	O
*	O
vcp	pointer
)	O
{	O
u_long	long
u	pointer
,	O
*	O
cp	pointer
=	O
(	O
u_long	long
*	O
)	O
vcp	pointer
;	O
u	pointer
=	O
htonl	function
(	O
*	O
cp	pointer
)	O
;	O
if	O
(	O
!	O
xdr_byte_opaque	function
(	O
xdrs	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
u	pointer
,	O
4	int
)	O
)	O
{	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
*	O
cp	pointer
=	O
ntohl	function
(	O
u	pointer
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
bool_t	int
xdr_byte_short	function
(	O
XDR	struct
*	O
xdrs	pointer
,	O
void	O
*	O
vcp	pointer
)	O
{	O
short	O
u	pointer
;	O
short	O
*	O
cp	pointer
=	O
(	O
short	O
*	O
)	O
vcp	pointer
;	O
u	pointer
=	O
htons	function
(	O
*	O
cp	pointer
)	O
;	O
if	O
(	O
!	O
xdr_byte_opaque	function
(	O
xdrs	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
u	struct
,	O
2	int
)	O
)	O
{	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
*	O
cp	pointer
=	O
ntohs	function
(	O
u	array
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
bool_t	int
xdr_byte_u_short	function
(	O
XDR	struct
*	O
xdrs	pointer
,	O
void	O
*	O
vcp	pointer
)	O
{	O
u_short	char
u	pointer
;	O
u_short	struct
*	O
cp	pointer
=	O
(	O
u_short	bool
*	O
)	O
vcp	pointer
;	O
u	pointer
=	O
htons	function
(	O
*	O
cp	pointer
)	O
;	O
if	O
(	O
!	O
xdr_byte_opaque	function
(	O
xdrs	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
u	struct
,	O
2	int
)	O
)	O
{	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
*	O
cp	pointer
=	O
ntohs	function
(	O
u	array
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
bool_t	int
xdr_byte_char	function
(	O
XDR	struct
*	O
xdrs	pointer
,	O
void	O
*	O
vcp	pointer
)	O
{	O
char	O
i	int
,	O
*	O
cp	pointer
=	O
(	O
char	O
*	O
)	O
vcp	pointer
;	O
i	int
=	O
(	O
*	O
cp	pointer
)	O
;	O
if	O
(	O
!	O
xdr_byte_opaque	function
(	O
xdrs	pointer
,	O
&	O
i	int
,	O
1	int
)	O
)	O
{	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
*	O
cp	pointer
=	O
i	int
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
bool_t	int
xdr_byte_u_char	function
(	O
XDR	struct
*	O
xdrs	pointer
,	O
void	O
*	O
vcp	pointer
)	O
{	O
u_char	char
u	pointer
,	O
*	O
cp	pointer
=	O
(	O
u_char	char
*	O
)	O
vcp	pointer
;	O
u	pointer
=	O
(	O
*	O
cp	pointer
)	O
;	O
if	O
(	O
!	O
xdr_byte_opaque	function
(	O
xdrs	pointer
,	O
&	O
u	pointer
,	O
1	int
)	O
)	O
{	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
*	O
cp	pointer
=	O
u	pointer
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
bool_t	int
xdr_byte_opaque	function
(	O
register	O
XDR	struct
*	O
xdrs	pointer
,	O
caddr_t	pointer
cp	pointer
,	O
register	O
u_int	int
cnt	int
)	O
{	O
if	O
(	O
cnt	int
==	O
0	int
)	O
return	O
(	O
TRUE	O
)	O
;	O
if	O
(	O
xdrs	pointer
->	O
x_op	enum
==	O
XDR_DECODE	int
)	O
{	O
if	O
(	O
!	O
XDR_GETBYTES	function
(	O
xdrs	pointer
,	O
cp	pointer
,	O
cnt	int
)	O
)	O
{	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
if	O
(	O
xdrs	pointer
->	O
x_op	enum
==	O
XDR_ENCODE	int
)	O
{	O
if	O
(	O
!	O
XDR_PUTBYTES	function
(	O
xdrs	pointer
,	O
cp	pointer
,	O
cnt	int
)	O
)	O
{	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
if	O
(	O
xdrs	pointer
->	O
x_op	enum
==	O
XDR_FREE	int
)	O
{	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
extern	O
int	O
MakeET	function
(	O
AWindow	struct
*	O
w	pointer
,	O
Point	struct
*	O
pts	pointer
,	O
int	O
npts	int
,	O
ZInfo	struct
*	O
zinfo	pointer
)	O
;	O
void	O
FillPolygon	function
(	O
AWindow	struct
*	O
w	pointer
,	O
Point	struct
*	O
pts	pointer
,	O
int	O
npts	int
,	O
ZInfo	struct
*	O
zinfo	pointer
)	O
{	O
MakeET	function
(	O
w	pointer
,	O
pts	pointer
,	O
npts	int
,	O
zinfo	pointer
)	O
;	O
}	O
void	O
VComputeClipNormals	function
(	O
Viewport	struct
*	O
v	struct
)	O
{	O
VPoint	struct
*	O
p	pointer
,	O
*	O
q	pointer
;	O
int	O
i	int
,	O
max	int
;	O
double	O
mag	double
;	O
p	pointer
=	O
v	struct
->	O
clipPoly	pointer
->	O
vertex	pointer
;	O
q	double
=	O
v	struct
->	O
clipNormals	double
;	O
max	double
=	O
(	O
v	struct
->	O
clipPoly	pointer
->	O
numVtces	double
>	O
4	int
)	O
?	O
4	int
:	O
v	struct
->	O
clipPoly	pointer
->	O
numVtces	bool
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
max	int
;	O
++	O
i	int
)	O
{	O
mag	double
=	O
sqrt	function
(	O
p	pointer
->	O
x	double
*	O
p	pointer
->	O
x	double
+	O
p	pointer
->	O
y	double
*	O
p	pointer
->	O
y	double
+	O
p	pointer
->	O
z	double
*	O
p	pointer
->	O
z	double
)	O
;	O
q	pointer
->	O
x	double
=	O
p	pointer
->	O
x	double
/	O
mag	double
;	O
q	pointer
->	O
y	double
=	O
p	pointer
->	O
y	double
/	O
mag	double
;	O
q	pointer
->	O
z	double
=	O
p	pointer
->	O
z	double
/	O
mag	int
;	O
q	pointer
++	O
;	O
p	pointer
++	O
;	O
}	O
}	O
VPoint	struct
*	O
VCreatePoints	function
(	O
int	O
numPts	int
)	O
{	O
return	O
(	O
VPoint	struct
*	O
)	O
Vmalloc	function
(	O
sizeof	O
(	O
VPoint	struct
)	O
*	O
numPts	int
)	O
;	O
}	O
int	O
VEyeToScreen	function
(	O
Viewport	struct
*	O
v	struct
,	O
VPoint	struct
*	O
p	pointer
,	O
int	O
*	O
x	double
,	O
int	O
*	O
y	double
)	O
{	O
register	O
int	O
valid	int
;	O
if	O
(	O
p	pointer
->	O
z	double
>	O
0.0	int
)	O
{	O
*	O
x	double
=	O
(	O
v	struct
->	O
Middl	struct
.	O
x	double
+	O
(	O
int	O
)	O
(	O
v	struct
->	O
Scale	struct
.	O
x	double
*	O
p	pointer
->	O
x	double
/	O
p	pointer
->	O
z	double
)	O
)	O
>>	O
2	int
;	O
*	O
y	double
=	O
(	O
v	struct
->	O
Middl	struct
.	O
y	double
-	O
(	O
int	O
)	O
(	O
v	struct
->	O
Scale	struct
.	O
y	double
*	O
p	pointer
->	O
y	double
/	O
p	pointer
->	O
z	double
)	O
)	O
>>	O
2	int
;	O
valid	enum
=	O
1	int
;	O
}	O
else	O
valid	enum
=	O
0	int
;	O
return	O
valid	enum
;	O
}	O
VPolygon	struct
*	O
VGetPlanes	function
(	O
VPolygon	struct
*	O
poly	pointer
)	O
{	O
VPoint	struct
tmp	pointer
[	O
64	int
]	O
,	O
*	O
p	pointer
;	O
int	O
i	int
,	O
lasti	int
;	O
lasti	int
=	O
poly	pointer
->	O
numVtces	short
-	O
1	int
;	O
p	pointer
=	O
poly	pointer
->	O
vertex	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
poly	pointer
->	O
numVtces	short
;	O
++	O
i	int
)	O
{	O
tmp	pointer
[	O
i	int
]	O
.	O
x	double
=	O
p	pointer
->	O
y	double
*	O
poly	pointer
->	O
vertex	pointer
[	O
lasti	int
]	O
.	O
z	double
-	O
p	pointer
->	O
z	double
*	O
poly	pointer
->	O
vertex	pointer
[	O
lasti	int
]	O
.	O
y	double
;	O
tmp	pointer
[	O
i	int
]	O
.	O
y	double
=	O
p	pointer
->	O
z	double
*	O
poly	pointer
->	O
vertex	pointer
[	O
lasti	int
]	O
.	O
x	double
-	O
p	pointer
->	O
x	double
*	O
poly	pointer
->	O
vertex	pointer
[	O
lasti	int
]	O
.	O
z	double
;	O
tmp	pointer
[	O
i	int
]	O
.	O
z	double
=	O
p	pointer
->	O
x	double
*	O
poly	pointer
->	O
vertex	pointer
[	O
lasti	int
]	O
.	O
y	double
-	O
p	pointer
->	O
y	double
*	O
poly	pointer
->	O
vertex	pointer
[	O
lasti	int
]	O
.	O
x	double
;	O
lasti	int
=	O
i	int
;	O
p	pointer
++	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
poly	pointer
->	O
numVtces	short
;	O
++	O
i	int
)	O
poly	pointer
->	O
vertex	pointer
[	O
i	int
]	O
=	O
tmp	array
[	O
i	int
]	O
;	O
return	O
poly	pointer
;	O
}	O
static	O
VMatrix	struct
ident	array
=	O
{	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
1.0	int
}	O
;	O
void	O
VIdentMatrix	function
(	O
VMatrix	struct
*	O
Mtx	pointer
)	O
{	O
*	O
Mtx	pointer
=	O
ident	int
;	O
}	O
extern	O
void	O
VComputeClipNormals	function
(	O
Viewport	struct
*	O
v	struct
)	O
;	O
extern	O
void	O
ResizeAWindow	function
(	O
AWindow	struct
*	O
w	pointer
,	O
int	O
height	int
,	O
int	O
width	int
)	O
;	O
void	O
VResizeViewport	function
(	O
Viewport	struct
*	O
v	struct
,	O
double	O
unit	double
,	O
double	O
dist	double
,	O
double	O
scale	double
,	O
int	O
width	int
,	O
int	O
height	int
)	O
{	O
VPoint	struct
clip	struct
[	O
4	int
]	O
;	O
v	struct
->	O
width	int
=	O
width	int
;	O
v	struct
->	O
height	int
=	O
height	int
;	O
if	O
(	O
v	struct
->	O
flags	short
&	O
VPPixmap	int
)	O
{	O
XFreePixmap	function
(	O
v	struct
->	O
dpy	pointer
,	O
v	struct
->	O
monoPixmap	pointer
)	O
;	O
v	struct
->	O
monoPixmap	pointer
=	O
XCreatePixmap	function
(	O
v	struct
->	O
dpy	pointer
,	O
RootWindow	function
(	O
v	struct
->	O
dpy	pointer
,	O
v	struct
->	O
screen	pointer
)	O
,	O
v	struct
->	O
width	pointer
,	O
v	struct
->	O
height	pointer
,	O
DisplayPlanes	function
(	O
v	struct
->	O
dpy	pointer
,	O
v	struct
->	O
screen	pointer
)	O
)	O
;	O
}	O
v	struct
->	O
dist	enum
=	O
dist	enum
;	O
v	struct
->	O
units	pointer
=	O
unit	double
;	O
v	struct
->	O
Scale	struct
.	O
x	double
=	O
v	struct
->	O
xres	double
*	O
dist	enum
*	O
scale	double
*	O
4	int
;	O
v	struct
->	O
Scale	struct
.	O
y	double
=	O
v	struct
->	O
yres	double
*	O
dist	enum
*	O
scale	double
*	O
4	int
;	O
v	struct
->	O
Scale	struct
.	O
z	double
=	O
1.0	int
;	O
v	struct
->	O
Middl	struct
.	O
x	double
=	O
width	int
*	O
2	int
;	O
v	struct
->	O
Middl	struct
.	O
y	double
=	O
height	int
*	O
2	int
;	O
clip	pointer
[	O
0	int
]	O
.	O
x	double
=	O
-	O
width	int
/	O
v	struct
->	O
xres	double
/	O
2.0	int
/	O
scale	double
;	O
clip	pointer
[	O
0	int
]	O
.	O
y	double
=	O
-	O
height	int
/	O
v	struct
->	O
yres	double
/	O
2.0	int
/	O
scale	double
;	O
clip	pointer
[	O
0	int
]	O
.	O
z	enum
=	O
dist	int
;	O
clip	struct
[	O
1	int
]	O
.	O
x	double
=	O
-	O
width	int
/	O
v	struct
->	O
xres	double
/	O
2.0	int
/	O
scale	double
;	O
clip	struct
[	O
1	int
]	O
.	O
y	double
=	O
height	int
/	O
v	struct
->	O
yres	double
/	O
2.0	int
/	O
scale	double
;	O
clip	pointer
[	O
1	int
]	O
.	O
z	enum
=	O
dist	int
;	O
clip	struct
[	O
2	int
]	O
.	O
x	double
=	O
width	int
/	O
v	struct
->	O
xres	double
/	O
2.0	int
/	O
scale	int
;	O
clip	struct
[	O
2	int
]	O
.	O
y	double
=	O
height	int
/	O
v	struct
->	O
yres	double
/	O
2.0	int
/	O
scale	int
;	O
clip	pointer
[	O
2	int
]	O
.	O
z	enum
=	O
dist	int
;	O
clip	struct
[	O
3	int
]	O
.	O
x	double
=	O
width	int
/	O
v	struct
->	O
xres	double
/	O
2.0	int
/	O
scale	double
;	O
clip	pointer
[	O
3	int
]	O
.	O
y	double
=	O
-	O
height	int
/	O
v	struct
->	O
yres	double
/	O
2.0	int
/	O
scale	int
;	O
clip	pointer
[	O
3	int
]	O
.	O
z	enum
=	O
dist	int
;	O
VDestroyPolygon	O
(	O
v	struct
->	O
clipPoly	pointer
)	O
;	O
v	struct
->	O
clipPoly	pointer
=	O
VCreatePolygon	function
(	O
4	int
,	O
clip	O
,	O
(	O
VColor	struct
*	O
)	O
0	int
)	O
;	O
VGetPlanes	function
(	O
v	struct
->	O
clipPoly	pointer
)	O
;	O
VComputeClipNormals	function
(	O
v	pointer
)	O
;	O
}	O
int	O
commandline_errormsg	function
(	O
FILE	struct
*	O
f	pointer
,	O
struct	O
commandline	struct
*	O
args	pointer
,	O
char	O
*	O
prgname	pointer
,	O
char	O
*	O
messagehead	pointer
)	O
{	O
char	O
*	O
buffer	pointer
;	O
char	O
*	O
buffer2	pointer
;	O
int	O
len	int
;	O
struct	O
commandline	struct
*	O
ptr	pointer
;	O
if	O
(	O
!	O
messagehead	pointer
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
_	O
(	O
"%s: Error in cmdline\nPossible options:\n"	pointer
)	O
,	O
prgname	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
f	pointer
,	O
"%s: %s"	pointer
,	O
prgname	pointer
,	O
messagehead	pointer
)	O
;	O
}	O
for	O
(	O
ptr	pointer
=	O
args	pointer
;	O
ptr	pointer
->	O
option	struct
;	O
ptr	pointer
++	O
)	O
{	O
if	O
(	O
_	O
(	O
ptr	pointer
->	O
descrip	pointer
)	O
)	O
{	O
len	int
=	O
strlen	function
(	O
_	O
(	O
ptr	pointer
->	O
descrip	pointer
)	O
)	O
;	O
len	int
+=	O
ptr	pointer
->	O
default_v	int
?	O
strlen	function
(	O
ptr	pointer
->	O
default_v	pointer
)	O
:	O
6	int
;	O
len	int
+=	O
ptr	pointer
->	O
env	pointer
?	O
strlen	function
(	O
ptr	pointer
->	O
env	pointer
)	O
:	O
6	int
;	O
buffer2	pointer
=	O
malloc	function
(	O
len	int
+	O
3	int
)	O
;	O
len	int
+=	O
32	int
;	O
if	O
(	O
buffer2	pointer
)	O
{	O
buffer	pointer
=	O
malloc	function
(	O
len	int
)	O
;	O
if	O
(	O
buffer	pointer
)	O
{	O
sprintf	function
(	O
buffer2	pointer
,	O
_	O
(	O
ptr	pointer
->	O
descrip	pointer
)	O
,	O
ptr	pointer
->	O
default_v	pointer
?	O
ptr	pointer
->	O
default_v	pointer
:	O
"(none)"	pointer
,	O
ptr	pointer
->	O
env	pointer
?	O
ptr	pointer
->	O
env	pointer
:	O
"(none)"	pointer
)	O
;	O
sprintf	function
(	O
buffer	pointer
,	O
"   -%c %s     %s"	pointer
,	O
ptr	pointer
->	O
option	struct
,	O
ptr	pointer
->	O
type	int
?	O
"<arg>"	int
:	O
"     "	pointer
,	O
buffer2	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"%s\n"	pointer
,	O
buffer	pointer
)	O
;	O
free	function
(	O
buffer	pointer
)	O
;	O
}	O
free	function
(	O
buffer2	pointer
)	O
;	O
}	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
struct	O
type_fmt	struct
{	O
enum	O
option_type	enum
type	enum
;	O
char	O
*	O
fmt	pointer
;	O
}	O
;	O
static	O
struct	O
type_fmt	struct
formats	array
[	O
]	O
=	O
{	O
{	O
CMDLINE_I	pointer
,	O
"%i%s"	int
}	O
,	O
{	O
CMDLINE_D	pointer
,	O
"%d%s"	int
}	O
,	O
{	O
CMDLINE_X	pointer
,	O
"%x%s"	int
}	O
,	O
{	O
CMDLINE_O	pointer
,	O
"%o%s"	int
}	O
,	O
{	O
CMDLINE_F	pointer
,	O
"%lf%s"	int
}	O
,	O
{	O
CMDLINE_P	pointer
,	O
"%p%s"	int
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
}	O
;	O
static	O
int	O
commandline_oneopt	function
(	O
struct	O
commandline	struct
*	O
ptr	pointer
,	O
char	O
*	O
value	pointer
)	O
{	O
struct	O
type_fmt	struct
*	O
tptr	pointer
;	O
char	O
*	O
trash	pointer
=	O
value	pointer
?	O
strdup	function
(	O
value	int
)	O
:	O
NULL	O
;	O
if	O
(	O
(	O
ptr	pointer
->	O
type	int
!=	O
CMDLINE_NONE	int
)	O
&&	O
ptr	pointer
->	O
result	pointer
)	O
{	O
for	O
(	O
tptr	int
=	O
formats	int
;	O
tptr	pointer
->	O
type	int
;	O
tptr	int
++	O
)	O
if	O
(	O
tptr	pointer
->	O
type	enum
==	O
ptr	pointer
->	O
type	pointer
)	O
break	O
;	O
if	O
(	O
!	O
tptr	pointer
->	O
type	int
)	O
*	O
(	O
char	O
*	O
*	O
)	O
(	O
ptr	pointer
->	O
result	pointer
)	O
=	O
value	pointer
;	O
else	O
if	O
(	O
sscanf	function
(	O
value	pointer
,	O
tptr	pointer
->	O
fmt	pointer
,	O
ptr	pointer
->	O
result	pointer
,	O
trash	pointer
)	O
!=	O
1	int
)	O
{	O
free	function
(	O
trash	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
trash	pointer
)	O
free	function
(	O
trash	pointer
)	O
;	O
if	O
(	O
(	O
ptr	pointer
->	O
type	enum
==	O
CMDLINE_NONE	int
)	O
&&	O
ptr	pointer
->	O
result	pointer
)	O
(	O
*	O
(	O
int	O
*	O
)	O
(	O
ptr	pointer
->	O
result	pointer
)	O
)	O
++	O
;	O
if	O
(	O
ptr	pointer
->	O
fun	pointer
)	O
{	O
if	O
(	O
ptr	pointer
->	O
type	int
)	O
{	O
if	O
(	O
ptr	pointer
->	O
result	pointer
)	O
return	O
ptr	pointer
->	O
fun	pointer
(	O
ptr	pointer
->	O
result	pointer
)	O
;	O
return	O
ptr	pointer
->	O
fun	pointer
(	O
value	pointer
)	O
;	O
}	O
return	O
ptr	pointer
->	O
fun	pointer
(	O
NULL	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
commandline	function
(	O
struct	O
commandline	struct
*	O
args	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
char	O
*	O
errorhead	pointer
)	O
{	O
struct	O
commandline	struct
*	O
ptr	pointer
;	O
char	O
*	O
getopt_desc	pointer
=	O
(	O
char	O
*	O
)	O
calloc	function
(	O
512	int
,	O
1	int
)	O
;	O
int	O
desc_offset	int
=	O
0	int
;	O
int	O
opt	int
,	O
retval	int
;	O
char	O
*	O
value	pointer
;	O
for	O
(	O
ptr	pointer
=	O
args	pointer
;	O
ptr	pointer
->	O
option	struct
;	O
ptr	pointer
++	O
)	O
{	O
getopt_desc	array
[	O
desc_offset	int
++	O
]	O
=	O
ptr	pointer
->	O
option	struct
;	O
if	O
(	O
ptr	pointer
->	O
type	int
)	O
getopt_desc	array
[	O
desc_offset	int
++	O
]	O
=	O
':'	O
;	O
value	pointer
=	O
NULL	O
;	O
if	O
(	O
ptr	pointer
->	O
env	pointer
)	O
value	pointer
=	O
getenv	function
(	O
ptr	pointer
->	O
env	pointer
)	O
;	O
if	O
(	O
!	O
value	pointer
)	O
value	int
=	O
ptr	pointer
->	O
default_v	pointer
;	O
if	O
(	O
value	int
&&	O
(	O
retval	int
=	O
commandline_oneopt	function
(	O
ptr	pointer
,	O
value	pointer
)	O
)	O
)	O
{	O
if	O
(	O
retval	int
==	O
-	O
1	int
)	O
commandline_errormsg	function
(	O
stderr	pointer
,	O
args	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
errorhead	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
}	O
while	O
(	O
(	O
opt	int
=	O
getopt	function
(	O
argc	int
,	O
argv	pointer
,	O
getopt_desc	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
for	O
(	O
ptr	pointer
=	O
args	pointer
;	O
ptr	pointer
->	O
option	struct
;	O
ptr	pointer
++	O
)	O
if	O
(	O
opt	pointer
==	O
ptr	pointer
->	O
option	struct
)	O
break	O
;	O
if	O
(	O
!	O
ptr	pointer
->	O
option	struct
)	O
return	O
commandline_errormsg	function
(	O
stderr	pointer
,	O
args	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
errorhead	pointer
)	O
;	O
if	O
(	O
(	O
retval	int
=	O
commandline_oneopt	function
(	O
ptr	pointer
,	O
optarg	pointer
)	O
)	O
)	O
{	O
if	O
(	O
retval	int
==	O
-	O
1	int
)	O
commandline_errormsg	function
(	O
stderr	pointer
,	O
args	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
errorhead	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
alphabet	array
[	O
]	O
=	O
"0123456789-"	pointer
;	O
static	O
char	O
*	O
codeset	array
[	O
]	O
=	O
{	O
"111121"	pointer
,	O
"211121"	pointer
,	O
"121121"	pointer
,	O
"221111"	pointer
,	O
"112121"	pointer
,	O
"212111"	pointer
,	O
"122111"	pointer
,	O
"111221"	pointer
,	O
"211211"	pointer
,	O
"211111"	pointer
,	O
"112111"	pointer
,	O
"112211"	pointer
}	O
;	O
int	O
Barcode_11_verify	function
(	O
unsigned	O
char	O
*	O
text	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
chr	pointer
=	O
NULL	O
;	O
if	O
(	O
text	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
text	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
(	O
chr	pointer
=	O
strchr	function
(	O
alphabet	array
,	O
text	pointer
[	O
i	int
]	O
)	O
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
Barcode_11_encode	function
(	O
struct	O
Barcode_Item	struct
*	O
bc	pointer
)	O
{	O
static	O
char	O
*	O
text	pointer
;	O
static	O
char	O
*	O
partial	pointer
;	O
static	O
char	O
*	O
textinfo	pointer
;	O
char	O
*	O
c	pointer
=	O
NULL	O
,	O
*	O
textptr	pointer
=	O
NULL	O
;	O
int	O
i	int
,	O
code	int
,	O
textpos	int
,	O
len	int
=	O
0	int
;	O
int	O
weight	int
=	O
0	int
;	O
int	O
c_checksum	int
=	O
0	int
,	O
k_checksum	int
=	O
0	int
;	O
if	O
(	O
bc	pointer
->	O
partial	pointer
)	O
free	function
(	O
bc	pointer
->	O
partial	pointer
)	O
;	O
if	O
(	O
bc	pointer
->	O
textinfo	pointer
)	O
free	function
(	O
bc	pointer
->	O
textinfo	pointer
)	O
;	O
bc	pointer
->	O
partial	pointer
=	O
bc	pointer
->	O
textinfo	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
bc	pointer
->	O
encoding	pointer
==	O
NULL	O
)	O
)	O
bc	pointer
->	O
encoding	pointer
=	O
strdup	function
(	O
"code 11"	pointer
)	O
;	O
if	O
(	O
(	O
text	pointer
=	O
bc	pointer
->	O
ascii	pointer
)	O
==	O
NULL	O
)	O
{	O
bc	pointer
->	O
error	int
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
len	int
=	O
strlen	function
(	O
text	pointer
)	O
)	O
==	O
0	int
)	O
{	O
bc	pointer
->	O
error	int
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
partial	pointer
=	O
(	O
char	O
*	O
)	O
calloc	function
(	O
1	int
,	O
(	O
len	int
>=	O
10	int
)	O
?	O
(	O
(	O
len	int
+	O
4	int
)	O
*	O
7	int
)	O
+	O
1	int
:	O
(	O
(	O
len	int
+	O
3	int
)	O
*	O
7	int
)	O
+	O
1	int
)	O
)	O
==	O
NULL	O
)	O
{	O
bc	pointer
->	O
error	int
=	O
errno	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
textinfo	pointer
=	O
(	O
char	O
*	O
)	O
calloc	function
(	O
1	int
,	O
10	int
*	O
(	O
len	int
+	O
2	int
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
bc	pointer
->	O
error	int
=	O
errno	O
;	O
free	function
(	O
partial	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	function
(	O
partial	pointer
,	O
"0"	pointer
)	O
;	O
strcat	function
(	O
partial	pointer
,	O
codeset	array
[	O
START_STOP	int
]	O
)	O
;	O
textptr	pointer
=	O
textinfo	pointer
;	O
textpos	int
=	O
7	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
text	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
c	pointer
=	O
strchr	function
(	O
alphabet	array
,	O
text	pointer
[	O
i	int
]	O
)	O
)	O
==	O
NULL	O
)	O
{	O
bc	pointer
->	O
error	int
=	O
EINVAL	int
;	O
free	function
(	O
partial	pointer
)	O
;	O
free	function
(	O
textinfo	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
code	int
=	O
c	pointer
-	O
alphabet	array
;	O
strcat	function
(	O
partial	pointer
,	O
codeset	array
[	O
code	int
]	O
)	O
;	O
sprintf	function
(	O
textptr	pointer
,	O
"%i:7:%c "	pointer
,	O
textpos	int
,	O
text	pointer
[	O
i	int
]	O
)	O
;	O
textpos	int
+=	O
7	int
;	O
textptr	pointer
+=	O
strlen	function
(	O
textptr	pointer
)	O
;	O
}	O
if	O
(	O
(	O
bc	pointer
->	O
flags	int
&	O
BARCODE_NO_CHECKSUM	int
)	O
==	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
len	int
;	O
i	int
++	O
)	O
{	O
weight	int
=	O
(	O
(	O
i	int
-	O
1	int
)	O
%	O
10	int
)	O
+	O
1	int
;	O
if	O
(	O
text	pointer
[	O
len	int
-	O
i	int
]	O
==	O
HYPHEN	int
)	O
c_checksum	int
+=	O
(	O
10	int
*	O
weight	int
)	O
;	O
else	O
c_checksum	int
+=	O
(	O
(	O
text	pointer
[	O
len	int
-	O
i	int
]	O
-	O
48	int
)	O
*	O
weight	int
)	O
;	O
}	O
strcat	function
(	O
partial	pointer
,	O
codeset	array
[	O
c_checksum	int
%	O
11	int
]	O
)	O
;	O
if	O
(	O
len	int
>=	O
10	int
)	O
{	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
len	int
;	O
i	int
++	O
)	O
{	O
weight	int
=	O
(	O
(	O
i	int
-	O
1	int
)	O
%	O
9	int
)	O
+	O
(	O
i	int
<	O
9	int
?	O
2	int
:	O
1	int
)	O
;	O
if	O
(	O
text	pointer
[	O
len	int
-	O
i	int
]	O
==	O
HYPHEN	int
)	O
k_checksum	int
+=	O
(	O
10	int
*	O
weight	int
)	O
;	O
else	O
k_checksum	int
+=	O
(	O
(	O
text	pointer
[	O
len	int
-	O
i	int
]	O
-	O
48	int
)	O
*	O
weight	int
)	O
;	O
}	O
k_checksum	int
+=	O
(	O
c_checksum	int
%	O
11	int
)	O
;	O
strcat	function
(	O
partial	pointer
,	O
codeset	array
[	O
k_checksum	int
%	O
9	int
]	O
)	O
;	O
}	O
}	O
strcat	function
(	O
partial	pointer
,	O
codeset	array
[	O
START_STOP	int
]	O
)	O
;	O
bc	pointer
->	O
partial	pointer
=	O
partial	pointer
;	O
bc	pointer
->	O
textinfo	pointer
=	O
textinfo	pointer
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
patterns	array
[	O
]	O
=	O
{	O
"13"	pointer
,	O
"31"	pointer
}	O
;	O
static	O
char	O
*	O
fillers	array
[	O
]	O
=	O
{	O
"031"	pointer
,	O
"131"	pointer
}	O
;	O
static	O
int	O
width	int
=	O
16	int
,	O
startpos	int
=	O
6	int
;	O
int	O
Barcode_msi_verify	function
(	O
char	O
*	O
text	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
strlen	function
(	O
text	pointer
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
text	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
isdigit	function
(	O
text	pointer
[	O
i	int
]	O
)	O
)	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
add_one	function
(	O
char	O
*	O
ptr	pointer
,	O
int	O
code	int
)	O
{	O
sprintf	function
(	O
ptr	pointer
,	O
"%s%s%s%s"	pointer
,	O
patterns	array
[	O
(	O
code	int
>>	O
3	int
)	O
&	O
1	int
]	O
,	O
patterns	array
[	O
(	O
code	int
>>	O
2	int
)	O
&	O
1	int
]	O
,	O
patterns	array
[	O
(	O
code	int
>>	O
1	int
)	O
&	O
1	int
]	O
,	O
patterns	array
[	O
code	int
&	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
Barcode_msi_encode	function
(	O
struct	O
Barcode_Item	struct
*	O
bc	pointer
)	O
{	O
static	O
char	O
*	O
text	pointer
;	O
static	O
char	O
*	O
partial	pointer
;	O
static	O
char	O
*	O
textinfo	pointer
;	O
char	O
*	O
ptr	pointer
,	O
*	O
textptr	pointer
;	O
int	O
i	int
,	O
code	int
,	O
textpos	int
,	O
usesum	int
,	O
checksum	int
=	O
0	int
;	O
if	O
(	O
bc	pointer
->	O
partial	pointer
)	O
free	function
(	O
bc	pointer
->	O
partial	pointer
)	O
;	O
if	O
(	O
bc	pointer
->	O
textinfo	pointer
)	O
free	function
(	O
bc	pointer
->	O
textinfo	pointer
)	O
;	O
bc	pointer
->	O
partial	pointer
=	O
bc	pointer
->	O
textinfo	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
bc	pointer
->	O
encoding	pointer
)	O
bc	pointer
->	O
encoding	pointer
=	O
strdup	function
(	O
"msi"	pointer
)	O
;	O
if	O
(	O
(	O
bc	pointer
->	O
flags	int
&	O
BARCODE_NO_CHECKSUM	int
)	O
)	O
usesum	int
=	O
0	int
;	O
else	O
usesum	int
=	O
1	int
;	O
text	pointer
=	O
bc	pointer
->	O
ascii	pointer
;	O
partial	pointer
=	O
malloc	function
(	O
3	int
+	O
8	int
*	O
(	O
strlen	function
(	O
text	pointer
)	O
+	O
1	int
)	O
+	O
3	int
+	O
2	int
)	O
;	O
if	O
(	O
!	O
partial	pointer
)	O
{	O
bc	pointer
->	O
error	int
=	O
errno	O
;	O
return	O
-	O
1	int
;	O
}	O
textinfo	pointer
=	O
malloc	function
(	O
10	int
*	O
strlen	function
(	O
text	pointer
)	O
+	O
2	int
)	O
;	O
if	O
(	O
!	O
textinfo	pointer
)	O
{	O
bc	pointer
->	O
error	int
=	O
errno	O
;	O
free	function
(	O
partial	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	function
(	O
partial	pointer
,	O
fillers	array
[	O
0	int
]	O
)	O
;	O
ptr	pointer
=	O
partial	pointer
+	O
strlen	function
(	O
partial	pointer
)	O
;	O
textptr	pointer
=	O
textinfo	pointer
;	O
textpos	int
=	O
startpos	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
strlen	function
(	O
text	pointer
)	O
;	O
i	int
++	O
)	O
{	O
code	int
=	O
text	pointer
[	O
i	int
]	O
-	O
'0'	O
;	O
add_one	function
(	O
ptr	pointer
,	O
code	int
)	O
;	O
sprintf	function
(	O
textptr	pointer
,	O
"%i:12:%c "	pointer
,	O
textpos	int
,	O
text	pointer
[	O
i	int
]	O
)	O
;	O
textpos	int
+=	O
width	int
;	O
textptr	pointer
+=	O
strlen	function
(	O
textptr	pointer
)	O
;	O
ptr	pointer
+=	O
strlen	function
(	O
ptr	pointer
)	O
;	O
if	O
(	O
usesum	int
)	O
{	O
if	O
(	O
(	O
i	int
^	O
strlen	function
(	O
text	pointer
)	O
)	O
&	O
1	int
)	O
{	O
checksum	int
+=	O
2	int
*	O
code	int
+	O
(	O
2	int
*	O
code	int
)	O
/	O
10	int
;	O
}	O
else	O
{	O
checksum	int
+=	O
code	int
;	O
}	O
}	O
}	O
if	O
(	O
usesum	int
)	O
{	O
checksum	int
=	O
(	O
checksum	int
+	O
9	int
)	O
/	O
10	int
*	O
10	int
-	O
checksum	int
;	O
add_one	function
(	O
ptr	pointer
,	O
checksum	int
)	O
;	O
ptr	pointer
+=	O
strlen	function
(	O
ptr	pointer
)	O
;	O
}	O
strcpy	function
(	O
ptr	pointer
,	O
fillers	array
[	O
1	int
]	O
)	O
;	O
bc	pointer
->	O
partial	pointer
=	O
partial	pointer
;	O
bc	pointer
->	O
textinfo	pointer
=	O
textinfo	pointer
;	O
return	O
0	int
;	O
}	O
extern	O
void	O
*	O
bfd_arch_i386_short_nop_fill	function
(	O
bfd_size_type	long
,	O
bfd_boolean	int
,	O
bfd_boolean	int
)	O
;	O
static	O
const	O
bfd_arch_info_type	struct
*	O
bfd_i386_compatible	function
(	O
const	O
bfd_arch_info_type	struct
*	O
a	struct
,	O
const	O
bfd_arch_info_type	struct
*	O
b	struct
)	O
{	O
const	O
bfd_arch_info_type	struct
*	O
compat	struct
=	O
bfd_default_compatible	function
(	O
a	pointer
,	O
b	pointer
)	O
;	O
if	O
(	O
compat	struct
&&	O
(	O
a	pointer
->	O
mach	pointer
&	O
bfd_mach_x64_32	pointer
)	O
!=	O
(	O
b	pointer
->	O
mach	pointer
&	O
bfd_mach_x64_32	pointer
)	O
)	O
compat	pointer
=	O
NULL	O
;	O
return	O
compat	O
;	O
}	O
static	O
void	O
*	O
bfd_arch_i386_fill	function
(	O
bfd_size_type	long
count	int
,	O
bfd_boolean	int
code	int
,	O
bfd_boolean	int
long_nop	int
)	O
{	O
static	O
const	O
char	O
nop_1	array
[	O
]	O
=	O
{	O
0x90	int
}	O
;	O
static	O
const	O
char	O
nop_2	array
[	O
]	O
=	O
{	O
0x66	pointer
,	O
0x90	int
}	O
;	O
static	O
const	O
char	O
nop_3	array
[	O
]	O
=	O
{	O
0x0f	int
,	O
0x1f	int
,	O
0x00	int
}	O
;	O
static	O
const	O
char	O
nop_4	array
[	O
]	O
=	O
{	O
0x0f	int
,	O
0x1f	int
,	O
0x40	int
,	O
0x00	int
}	O
;	O
static	O
const	O
char	O
nop_5	array
[	O
]	O
=	O
{	O
0x0f	int
,	O
0x1f	int
,	O
0x44	int
,	O
0x00	int
,	O
0x00	int
}	O
;	O
static	O
const	O
char	O
nop_6	array
[	O
]	O
=	O
{	O
0x66	pointer
,	O
0x0f	int
,	O
0x1f	int
,	O
0x44	int
,	O
0x00	int
,	O
0x00	int
}	O
;	O
static	O
const	O
char	O
nop_7	array
[	O
]	O
=	O
{	O
0x0f	int
,	O
0x1f	int
,	O
0x80	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
}	O
;	O
static	O
const	O
char	O
nop_8	array
[	O
]	O
=	O
{	O
0x0f	int
,	O
0x1f	int
,	O
0x84	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
}	O
;	O
static	O
const	O
char	O
nop_9	array
[	O
]	O
=	O
{	O
0x66	pointer
,	O
0x0f	int
,	O
0x1f	int
,	O
0x84	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
}	O
;	O
static	O
const	O
char	O
nop_10	array
[	O
]	O
=	O
{	O
0x66	pointer
,	O
0x2e	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x84	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
nops	array
[	O
]	O
=	O
{	O
nop_1	pointer
,	O
nop_2	pointer
,	O
nop_3	pointer
,	O
nop_4	pointer
,	O
nop_5	pointer
,	O
nop_6	pointer
,	O
nop_7	pointer
,	O
nop_8	pointer
,	O
nop_9	pointer
,	O
nop_10	pointer
}	O
;	O
bfd_size_type	long
nop_size	int
=	O
long_nop	int
?	O
ARRAY_SIZE	function
(	O
nops	pointer
)	O
:	O
2	int
;	O
void	O
*	O
fill	enum
=	O
bfd_malloc	function
(	O
count	int
)	O
;	O
if	O
(	O
fill	pointer
==	O
NULL	O
)	O
return	O
fill	int
;	O
if	O
(	O
code	int
)	O
{	O
bfd_byte	char
*	O
p	pointer
=	O
fill	enum
;	O
while	O
(	O
count	int
>=	O
nop_size	int
)	O
{	O
memcpy	function
(	O
p	pointer
,	O
nops	array
[	O
nop_size	int
-	O
1	int
]	O
,	O
nop_size	pointer
)	O
;	O
p	pointer
+=	O
nop_size	int
;	O
count	long
-=	O
nop_size	int
;	O
}	O
if	O
(	O
count	long
!=	O
0	int
)	O
memcpy	function
(	O
p	pointer
,	O
nops	pointer
[	O
count	long
-	O
1	int
]	O
,	O
count	long
)	O
;	O
}	O
else	O
memset	function
(	O
fill	int
,	O
0	int
,	O
count	int
)	O
;	O
return	O
fill	int
;	O
}	O
void	O
*	O
bfd_arch_i386_short_nop_fill	function
(	O
bfd_size_type	long
count	long
,	O
bfd_boolean	int
is_bigendian	int
ATTRIBUTE_UNUSED	O
,	O
bfd_boolean	int
code	int
)	O
{	O
return	O
bfd_arch_i386_fill	function
(	O
count	long
,	O
code	int
,	O
FALSE	O
)	O
;	O
}	O
static	O
void	O
*	O
bfd_arch_i386_long_nop_fill	function
(	O
bfd_size_type	long
count	long
,	O
bfd_boolean	int
is_bigendian	int
ATTRIBUTE_UNUSED	O
,	O
bfd_boolean	int
code	int
)	O
{	O
return	O
bfd_arch_i386_fill	function
(	O
count	long
,	O
code	int
,	O
TRUE	O
)	O
;	O
}	O
static	O
void	O
*	O
bfd_arch_i386_onebyte_nop_fill	function
(	O
bfd_size_type	long
count	long
,	O
bfd_boolean	int
is_bigendian	int
ATTRIBUTE_UNUSED	O
,	O
bfd_boolean	int
code	int
)	O
{	O
void	O
*	O
fill	pointer
=	O
bfd_malloc	function
(	O
count	long
)	O
;	O
if	O
(	O
fill	int
!=	O
NULL	O
)	O
memset	function
(	O
fill	int
,	O
code	int
?	O
0x90	int
:	O
0	int
,	O
count	int
)	O
;	O
return	O
fill	int
;	O
}	O
static	O
const	O
bfd_arch_info_type	struct
bfd_x64_32_nacl_arch	struct
=	O
N	O
(	O
64	int
,	O
bfd_mach_x64_32_nacl	pointer
,	O
"i386"	pointer
,	O
"i386:x64-32:nacl"	pointer
,	O
FALSE	O
,	O
bfd_arch_i386_onebyte_nop_fill	O
,	O
NULL	O
)	O
;	O
static	O
const	O
bfd_arch_info_type	struct
bfd_x86_64_nacl_arch	struct
=	O
N	O
(	O
64	int
,	O
bfd_mach_x86_64_nacl	pointer
,	O
"i386"	pointer
,	O
"i386:x86-64:nacl"	pointer
,	O
FALSE	O
,	O
bfd_arch_i386_onebyte_nop_fill	O
,	O
&	O
bfd_x64_32_nacl_arch	O
)	O
;	O
const	O
bfd_arch_info_type	struct
bfd_i386_nacl_arch	struct
=	O
N	O
(	O
32	int
,	O
bfd_mach_i386_i386_nacl	pointer
,	O
"i386"	pointer
,	O
"i386:nacl"	int
,	O
TRUE	O
,	O
bfd_arch_i386_onebyte_nop_fill	pointer
,	O
&	O
bfd_x86_64_nacl_arch	O
)	O
;	O
static	O
const	O
bfd_arch_info_type	struct
bfd_x64_32_arch_intel_syntax	struct
=	O
N	O
(	O
64	int
,	O
bfd_mach_x64_32_intel_syntax	pointer
,	O
"i386:intel"	pointer
,	O
"i386:x64-32:intel"	pointer
,	O
FALSE	O
,	O
bfd_arch_i386_long_nop_fill	int
,	O
&	O
bfd_i386_nacl_arch	O
)	O
;	O
static	O
const	O
bfd_arch_info_type	struct
bfd_x86_64_arch_intel_syntax	struct
=	O
N	O
(	O
64	int
,	O
bfd_mach_x86_64_intel_syntax	pointer
,	O
"i386:intel"	pointer
,	O
"i386:x86-64:intel"	pointer
,	O
FALSE	O
,	O
bfd_arch_i386_long_nop_fill	O
,	O
&	O
bfd_x64_32_arch_intel_syntax	O
)	O
;	O
static	O
const	O
bfd_arch_info_type	struct
bfd_i386_arch_intel_syntax	struct
=	O
N	O
(	O
32	int
,	O
bfd_mach_i386_i386_intel_syntax	pointer
,	O
"i386:intel"	pointer
,	O
"i386:intel"	int
,	O
TRUE	O
,	O
bfd_arch_i386_short_nop_fill	pointer
,	O
&	O
bfd_x86_64_arch_intel_syntax	O
)	O
;	O
static	O
const	O
bfd_arch_info_type	struct
i8086_arch	struct
=	O
N	O
(	O
32	int
,	O
bfd_mach_i386_i8086	pointer
,	O
"i8086"	pointer
,	O
"i8086"	pointer
,	O
FALSE	O
,	O
bfd_arch_i386_short_nop_fill	int
,	O
&	O
bfd_i386_arch_intel_syntax	struct
)	O
;	O
static	O
const	O
bfd_arch_info_type	struct
bfd_x64_32_arch	struct
=	O
N	O
(	O
64	int
,	O
bfd_mach_x64_32	pointer
,	O
"i386"	pointer
,	O
"i386:x64-32"	pointer
,	O
FALSE	O
,	O
bfd_arch_i386_long_nop_fill	O
,	O
&	O
i8086_arch	O
)	O
;	O
static	O
const	O
bfd_arch_info_type	struct
bfd_x86_64_arch	struct
=	O
N	O
(	O
64	int
,	O
bfd_mach_x86_64	pointer
,	O
"i386"	pointer
,	O
"i386:x86-64"	pointer
,	O
FALSE	O
,	O
bfd_arch_i386_long_nop_fill	O
,	O
&	O
bfd_x64_32_arch	O
)	O
;	O
const	O
bfd_arch_info_type	struct
bfd_i386_arch	struct
=	O
N	O
(	O
32	int
,	O
bfd_mach_i386_i386	pointer
,	O
"i386"	pointer
,	O
"i386"	int
,	O
TRUE	O
,	O
bfd_arch_i386_short_nop_fill	pointer
,	O
&	O
bfd_x86_64_arch	O
)	O
;	O
const	O
char	O
*	O
bfd_get_stab_name	function
(	O
int	O
code	int
)	O
{	O
switch	O
(	O
code	int
)	O
{	O
EXTRA_SYMBOLS	pointer
}	O
return	O
(	O
const	O
char	O
*	O
)	O
0	int
;	O
}	O
static	O
int	O
flags	int
=	O
DMGL_PARAMS	O
|	O
DMGL_ANSI	int
|	O
DMGL_VERBOSE	int
;	O
static	O
int	O
strip_underscore	int
=	O
TARGET_PREPENDS_UNDERSCORE	int
;	O
static	O
const	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"strip-underscore"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'_'	O
}	O
,	O
{	O
"format"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"no-params"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"no-strip-underscores"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"no-verbose"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"types"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"recurse-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"recursion-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"no-recurse-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"no-recursion-limit"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
demangle_it	function
(	O
char	O
*	O
mangled_name	pointer
)	O
{	O
char	O
*	O
result	pointer
;	O
unsigned	O
int	O
skip_first	int
=	O
0	int
;	O
if	O
(	O
mangled_name	array
[	O
0	int
]	O
==	O
'.'	O
||	O
mangled_name	array
[	O
0	int
]	O
==	O
'$'	O
)	O
++	O
skip_first	int
;	O
if	O
(	O
strip_underscore	int
&&	O
mangled_name	array
[	O
skip_first	int
]	O
==	O
'_'	O
)	O
++	O
skip_first	int
;	O
result	pointer
=	O
cplus_demangle	function
(	O
mangled_name	int
+	O
skip_first	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
result	pointer
==	O
NULL	O
)	O
printf	function
(	O
"%s"	pointer
,	O
mangled_name	pointer
)	O
;	O
else	O
{	O
if	O
(	O
mangled_name	array
[	O
0	int
]	O
==	O
'.'	O
)	O
putchar	function
(	O
'.'	O
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
result	pointer
)	O
;	O
free	function
(	O
result	pointer
)	O
;	O
}	O
}	O
static	O
void	O
print_demangler_list	function
(	O
FILE	struct
*	O
stream	pointer
)	O
{	O
const	O
struct	O
demangler_engine	struct
*	O
demangler	pointer
;	O
fprintf	function
(	O
stream	pointer
,	O
"{%s"	pointer
,	O
libiberty_demanglers	pointer
->	O
demangling_style_name	pointer
)	O
;	O
for	O
(	O
demangler	int
=	O
libiberty_demanglers	pointer
+	O
1	int
;	O
demangler	pointer
->	O
demangling_style	int
!=	O
unknown_demangling	int
;	O
++	O
demangler	int
)	O
fprintf	function
(	O
stream	pointer
,	O
",%s"	pointer
,	O
demangler	pointer
->	O
demangling_style_name	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"}"	pointer
)	O
;	O
}	O
ATTRIBUTE_NORETURN	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
stream	pointer
,	O
int	O
status	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"Usage: %s [options] [mangled names]\n"	pointer
,	O
program_name	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"Options are:\n  [-_|--strip-underscore]     Ignore first leading underscore%s\n"	pointer
,	O
TARGET_PREPENDS_UNDERSCORE	int
?	O
" (default)"	int
:	O
""	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  [-n|--no-strip-underscore]  Do not ignore a leading underscore%s\n"	pointer
,	O
TARGET_PREPENDS_UNDERSCORE	pointer
?	O
""	pointer
:	O
" (default)"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  [-p|--no-params]            Do not display function arguments\n  [-i|--no-verbose]           Do not show implementation details (if any)\n  [-R|--recurse-limit]        Enable a limit on recursion whilst demangling.  [Default]\n  ]-r|--no-recurse-limit]     Disable a limit on recursion whilst demangling\n  [-t|--types]                Also attempt to demangle type encodings\n  [-s|--format "	pointer
)	O
;	O
print_demangler_list	function
(	O
stream	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"]\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  [@<file>]                   Read extra options from <file>\n  [-h|--help]                 Display this information\n  [-v|--version]              Show the version information\nDemangled names are displayed to stdout.\nIf a name cannot be demangled it is just echoed to stdout.\nIf no names are provided on the command line, stdin is read.\n"	pointer
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	array
[	O
0	int
]	O
&&	O
status	int
==	O
0	int
)	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Report bugs to %s.\n"	pointer
)	O
,	O
REPORT_BUGS_TO	pointer
)	O
;	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
standard_symbol_characters	function
(	O
void	O
)	O
{	O
return	O
"_$."	int
;	O
}	O
extern	O
int	O
main	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
c	int
;	O
const	O
char	O
*	O
valid_symbols	pointer
;	O
enum	O
demangling_styles	enum
style	enum
=	O
auto_demangling	int
;	O
program_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
xmalloc_set_program_name	function
(	O
program_name	pointer
)	O
;	O
bfd_set_error_program_name	function
(	O
program_name	pointer
)	O
;	O
expandargv	function
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	array
,	O
"_hinprRs:tv"	pointer
,	O
long_options	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'?'	O
:	O
usage	function
(	O
stderr	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	function
(	O
stdout	pointer
,	O
0	int
)	O
;	O
case	O
'n'	O
:	O
strip_underscore	int
=	O
0	int
;	O
break	O
;	O
case	O
'p'	O
:	O
flags	int
&=	O
~	O
DMGL_PARAMS	O
;	O
break	O
;	O
case	O
'r'	O
:	O
flags	int
|=	O
DMGL_NO_RECURSE_LIMIT	int
;	O
break	O
;	O
case	O
'R'	O
:	O
flags	int
&=	O
~	O
DMGL_NO_RECURSE_LIMIT	int
;	O
break	O
;	O
case	O
't'	O
:	O
flags	int
|=	O
DMGL_TYPES	int
;	O
break	O
;	O
case	O
'i'	O
:	O
flags	int
&=	O
~	O
DMGL_VERBOSE	int
;	O
break	O
;	O
case	O
'v'	O
:	O
print_version	function
(	O
"c++filt"	pointer
)	O
;	O
return	O
0	int
;	O
case	O
'_'	O
:	O
strip_underscore	int
=	O
1	int
;	O
break	O
;	O
case	O
's'	O
:	O
style	pointer
=	O
cplus_demangle_name_to_style	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
style	int
==	O
unknown_demangling	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: unknown demangling style `%s'\n"	pointer
,	O
program_name	pointer
,	O
optarg	pointer
)	O
;	O
return	O
1	int
;	O
}	O
cplus_demangle_set_style	O
(	O
style	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
for	O
(	O
;	O
optind	int
<	O
argc	int
;	O
optind	int
++	O
)	O
{	O
demangle_it	function
(	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
switch	O
(	O
current_demangling_style	int
)	O
{	O
case	O
auto_demangling	int
:	O
case	O
gnu_v3_demangling	int
:	O
case	O
java_demangling	int
:	O
case	O
gnat_demangling	int
:	O
case	O
dlang_demangling	int
:	O
case	O
rust_demangling	int
:	O
valid_symbols	pointer
=	O
standard_symbol_characters	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
fatal	function
(	O
"Internal error: no symbol alphabet for current style"	int
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
static	O
char	O
mbuffer	array
[	O
32767	int
]	O
;	O
unsigned	O
i	int
=	O
0	int
;	O
c	int
=	O
getchar	function
(	O
)	O
;	O
while	O
(	O
c	int
!=	O
EOF	O
&&	O
(	O
ISALNUM	function
(	O
c	int
)	O
||	O
strchr	function
(	O
valid_symbols	pointer
,	O
c	int
)	O
)	O
)	O
{	O
if	O
(	O
i	int
>=	O
sizeof	O
(	O
mbuffer	int
)	O
-	O
1	int
)	O
break	O
;	O
mbuffer	array
[	O
i	int
++	O
]	O
=	O
c	int
;	O
c	int
=	O
getchar	function
(	O
)	O
;	O
}	O
if	O
(	O
i	int
>	O
0	int
)	O
{	O
mbuffer	array
[	O
i	int
]	O
=	O
0	int
;	O
demangle_it	function
(	O
mbuffer	pointer
)	O
;	O
}	O
if	O
(	O
c	int
==	O
EOF	O
)	O
break	O
;	O
putchar	function
(	O
c	int
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
z_stream_s	struct
*	O
compress_init	function
(	O
void	O
)	O
{	O
static	O
struct	O
z_stream_s	struct
strm	pointer
;	O
strm	struct
.	O
zalloc	pointer
=	O
NULL	O
;	O
strm	struct
.	O
zfree	pointer
=	O
NULL	O
;	O
strm	struct
.	O
opaque	pointer
=	O
NULL	O
;	O
deflateInit	O
(	O
&	O
strm	struct
,	O
Z_DEFAULT_COMPRESSION	O
)	O
;	O
return	O
&	O
strm	pointer
;	O
}	O
int	O
compress_data	function
(	O
struct	O
z_stream_s	struct
*	O
strm	pointer
,	O
const	O
char	O
*	O
*	O
next_in	pointer
,	O
int	O
*	O
avail_in	int
,	O
char	O
*	O
*	O
next_out	pointer
,	O
int	O
*	O
avail_out	int
)	O
{	O
int	O
out_size	int
=	O
0	int
;	O
int	O
x	int
;	O
strm	pointer
->	O
next_in	pointer
=	O
(	O
Bytef	char
*	O
)	O
(	O
*	O
next_in	pointer
)	O
;	O
strm	pointer
->	O
avail_in	int
=	O
*	O
avail_in	int
;	O
strm	pointer
->	O
next_out	pointer
=	O
(	O
Bytef	char
*	O
)	O
(	O
*	O
next_out	pointer
)	O
;	O
strm	pointer
->	O
avail_out	int
=	O
*	O
avail_out	int
;	O
x	int
=	O
deflate	function
(	O
strm	pointer
,	O
Z_NO_FLUSH	int
)	O
;	O
if	O
(	O
x	int
!=	O
Z_OK	int
)	O
return	O
-	O
1	int
;	O
out_size	int
=	O
*	O
avail_out	int
-	O
strm	pointer
->	O
avail_out	int
;	O
*	O
next_in	pointer
=	O
(	O
char	O
*	O
)	O
(	O
strm	pointer
->	O
next_in	pointer
)	O
;	O
*	O
avail_in	int
=	O
strm	pointer
->	O
avail_in	int
;	O
*	O
next_out	pointer
=	O
(	O
char	O
*	O
)	O
(	O
strm	pointer
->	O
next_out	pointer
)	O
;	O
*	O
avail_out	int
=	O
strm	pointer
->	O
avail_out	int
;	O
return	O
out_size	int
;	O
}	O
int	O
compress_finish	function
(	O
struct	O
z_stream_s	struct
*	O
strm	pointer
,	O
char	O
*	O
*	O
next_out	pointer
,	O
int	O
*	O
avail_out	int
,	O
int	O
*	O
out_size	pointer
)	O
{	O
int	O
x	int
;	O
strm	pointer
->	O
avail_in	int
=	O
0	int
;	O
strm	pointer
->	O
next_out	pointer
=	O
(	O
Bytef	char
*	O
)	O
(	O
*	O
next_out	pointer
)	O
;	O
strm	pointer
->	O
avail_out	int
=	O
*	O
avail_out	int
;	O
x	int
=	O
deflate	function
(	O
strm	pointer
,	O
Z_FINISH	int
)	O
;	O
*	O
out_size	pointer
=	O
*	O
avail_out	int
-	O
strm	pointer
->	O
avail_out	int
;	O
*	O
next_out	pointer
=	O
(	O
char	O
*	O
)	O
(	O
strm	pointer
->	O
next_out	pointer
)	O
;	O
*	O
avail_out	int
=	O
strm	pointer
->	O
avail_out	int
;	O
if	O
(	O
x	int
==	O
Z_STREAM_END	int
)	O
{	O
deflateEnd	function
(	O
strm	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
strm	pointer
->	O
avail_out	int
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
1	int
;	O
}	O
static	O
char	O
*	O
dep_file	pointer
=	O
NULL	O
;	O
struct	O
dependency	struct
{	O
char	O
*	O
file	pointer
;	O
struct	O
dependency	struct
*	O
next	pointer
;	O
}	O
;	O
static	O
struct	O
dependency	struct
*	O
dep_chain	pointer
=	O
NULL	O
;	O
static	O
int	O
column	int
=	O
0	int
;	O
static	O
int	O
quote_string_for_make	function
(	O
FILE	struct
*	O
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
wrap_output	function
(	O
FILE	struct
*	O
,	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
void	O
start_dependencies	function
(	O
char	O
*	O
filename	pointer
)	O
{	O
dep_file	pointer
=	O
filename	pointer
;	O
}	O
void	O
register_dependency	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
struct	O
dependency	struct
*	O
dep	pointer
;	O
if	O
(	O
dep_file	pointer
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
dep	pointer
=	O
dep_chain	pointer
;	O
dep	pointer
!=	O
NULL	O
;	O
dep	pointer
=	O
dep	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
filename_cmp	function
(	O
filename	pointer
,	O
dep	pointer
->	O
file	pointer
)	O
)	O
return	O
;	O
}	O
dep	pointer
=	O
XNEW	O
(	O
struct	O
dependency	struct
)	O
;	O
dep	pointer
->	O
file	pointer
=	O
xstrdup	function
(	O
filename	pointer
)	O
;	O
dep	pointer
->	O
next	pointer
=	O
dep_chain	pointer
;	O
dep_chain	pointer
=	O
dep	pointer
;	O
}	O
static	O
int	O
quote_string_for_make	function
(	O
FILE	struct
*	O
file	pointer
,	O
const	O
char	O
*	O
src	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
src	pointer
;	O
int	O
i	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
c	int
=	O
*	O
p	pointer
++	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\0'	O
:	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
{	O
const	O
char	O
*	O
q	pointer
;	O
for	O
(	O
q	pointer
=	O
p	pointer
-	O
1	int
;	O
src	pointer
<	O
q	pointer
&&	O
q	pointer
[	O
-	O
1	int
]	O
==	O
'\\'	O
;	O
q	pointer
--	O
)	O
{	O
if	O
(	O
file	pointer
)	O
putc	function
(	O
'\\'	O
,	O
file	pointer
)	O
;	O
i	int
++	O
;	O
}	O
}	O
if	O
(	O
!	O
c	int
)	O
return	O
i	int
;	O
if	O
(	O
file	pointer
)	O
putc	function
(	O
'\\'	O
,	O
file	pointer
)	O
;	O
i	int
++	O
;	O
goto	O
ordinary_char	O
;	O
case	O
'$'	O
:	O
if	O
(	O
file	pointer
)	O
putc	function
(	O
c	int
,	O
file	pointer
)	O
;	O
i	int
++	O
;	O
default	O
:	O
ordinary_char	function
:	O
if	O
(	O
file	pointer
)	O
putc	function
(	O
c	int
,	O
file	pointer
)	O
;	O
i	int
++	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
wrap_output	function
(	O
FILE	struct
*	O
f	pointer
,	O
const	O
char	O
*	O
string	pointer
,	O
int	O
spacer	int
)	O
{	O
int	O
len	int
=	O
quote_string_for_make	function
(	O
NULL	O
,	O
string	pointer
)	O
;	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
column	int
&&	O
(	O
MAX_COLUMNS	int
-	O
1	int
-	O
2	int
<	O
column	int
+	O
len	int
)	O
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
" \\\n "	pointer
)	O
;	O
column	int
=	O
0	int
;	O
if	O
(	O
spacer	int
==	O
' '	O
)	O
spacer	int
=	O
'\0'	O
;	O
}	O
if	O
(	O
spacer	int
==	O
' '	O
)	O
{	O
putc	function
(	O
spacer	int
,	O
f	pointer
)	O
;	O
++	O
column	int
;	O
}	O
quote_string_for_make	function
(	O
f	pointer
,	O
string	pointer
)	O
;	O
column	int
+=	O
len	int
;	O
if	O
(	O
spacer	int
==	O
':'	O
)	O
{	O
putc	function
(	O
spacer	int
,	O
f	pointer
)	O
;	O
++	O
column	int
;	O
}	O
}	O
void	O
print_dependencies	function
(	O
void	O
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
struct	O
dependency	struct
*	O
dep	pointer
;	O
if	O
(	O
dep_file	pointer
==	O
NULL	O
)	O
return	O
;	O
f	pointer
=	O
fopen	function
(	O
dep_file	pointer
,	O
FOPEN_WT	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
"can't open `%s' for writing"	pointer
)	O
,	O
dep_file	pointer
)	O
;	O
return	O
;	O
}	O
column	int
=	O
0	int
;	O
wrap_output	function
(	O
f	pointer
,	O
out_file_name	pointer
,	O
':'	O
)	O
;	O
for	O
(	O
dep	pointer
=	O
dep_chain	pointer
;	O
dep	pointer
!=	O
NULL	O
;	O
dep	pointer
=	O
dep	pointer
->	O
next	pointer
)	O
wrap_output	function
(	O
f	pointer
,	O
dep	pointer
->	O
file	pointer
,	O
' '	O
)	O
;	O
putc	function
(	O
'\n'	O
,	O
f	pointer
)	O
;	O
if	O
(	O
fclose	function
(	O
f	pointer
)	O
)	O
as_warn	function
(	O
_	O
(	O
"can't close `%s'"	pointer
)	O
,	O
dep_file	pointer
)	O
;	O
}	O
void	O
cg_tally	function
(	O
bfd_vma	long
from_pc	long
,	O
bfd_vma	long
self_pc	O
,	O
unsigned	O
long	O
count	long
)	O
{	O
Sym	struct
*	O
parent	pointer
;	O
Sym	struct
*	O
child	double
;	O
parent	pointer
=	O
sym_lookup	function
(	O
&	O
symtab	struct
,	O
from_pc	pointer
)	O
;	O
child	double
=	O
sym_lookup	function
(	O
&	O
symtab	struct
,	O
self_pc	pointer
)	O
;	O
if	O
(	O
child	pointer
==	O
NULL	O
||	O
parent	pointer
==	O
NULL	O
)	O
return	O
;	O
while	O
(	O
child	double
>=	O
symtab	pointer
.	O
base	int
&&	O
!	O
child	int
->	O
is_func	int
)	O
--	O
child	int
;	O
if	O
(	O
child	double
<	O
symtab	pointer
.	O
base	int
)	O
return	O
;	O
if	O
(	O
sym_id_arc_is_present	function
(	O
&	O
syms	array
[	O
INCL_ARCS	int
]	O
,	O
parent	pointer
,	O
child	double
)	O
||	O
(	O
syms	array
[	O
INCL_ARCS	int
]	O
.	O
len	long
==	O
0	int
&&	O
!	O
sym_id_arc_is_present	function
(	O
&	O
syms	array
[	O
EXCL_ARCS	int
]	O
,	O
parent	pointer
,	O
child	pointer
)	O
)	O
)	O
{	O
child	pointer
->	O
ncalls	int
+=	O
count	int
;	O
DBG	O
(	O
TALLYDEBUG	int
,	O
printf	function
(	O
_	O
(	O
"[cg_tally] arc from %s to %s traversed %lu times\n"	pointer
)	O
,	O
parent	pointer
->	O
name	pointer
,	O
child	pointer
->	O
name	pointer
,	O
count	int
)	O
)	O
;	O
arc_add	function
(	O
parent	pointer
,	O
child	double
,	O
count	int
)	O
;	O
}	O
}	O
void	O
cg_read_rec	function
(	O
FILE	struct
*	O
ifp	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
bfd_vma	long
from_pc	long
,	O
self_pc	pointer
;	O
unsigned	O
int	O
count	int
;	O
if	O
(	O
gmon_io_read_vma	function
(	O
ifp	pointer
,	O
&	O
from_pc	pointer
)	O
||	O
gmon_io_read_vma	function
(	O
ifp	pointer
,	O
&	O
self_pc	pointer
)	O
||	O
gmon_io_read_32	function
(	O
ifp	pointer
,	O
&	O
count	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: %s: unexpected end of file\n"	pointer
)	O
,	O
whoami	pointer
,	O
filename	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
DBG	O
(	O
SAMPLEDEBUG	pointer
,	O
printf	function
(	O
"[cg_read_rec] frompc 0x%lx selfpc 0x%lx count %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
from_pc	int
,	O
(	O
unsigned	O
long	O
)	O
self_pc	pointer
,	O
(	O
unsigned	O
long	O
)	O
count	long
)	O
)	O
;	O
cg_tally	function
(	O
from_pc	pointer
,	O
self_pc	pointer
,	O
count	long
)	O
;	O
}	O
void	O
cg_write_arcs	function
(	O
FILE	struct
*	O
ofp	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
Arc	struct
*	O
arc	struct
;	O
Sym	struct
*	O
sym	pointer
;	O
for	O
(	O
sym	pointer
=	O
symtab	pointer
.	O
base	pointer
;	O
sym	pointer
<	O
symtab	struct
.	O
limit	long
;	O
sym	int
++	O
)	O
{	O
for	O
(	O
arc	struct
=	O
sym	pointer
->	O
cg	struct
.	O
children	pointer
;	O
arc	struct
;	O
arc	struct
=	O
arc	struct
->	O
next_child	pointer
)	O
{	O
if	O
(	O
gmon_io_write_8	function
(	O
ofp	pointer
,	O
GMON_TAG_CG_ARC	pointer
)	O
||	O
gmon_io_write_vma	function
(	O
ofp	pointer
,	O
arc	struct
->	O
parent	pointer
->	O
addr	pointer
)	O
||	O
gmon_io_write_vma	function
(	O
ofp	pointer
,	O
arc	pointer
->	O
child	double
->	O
addr	pointer
)	O
||	O
gmon_io_write_32	function
(	O
ofp	pointer
,	O
arc	pointer
->	O
count	long
)	O
)	O
{	O
perror	function
(	O
filename	pointer
)	O
;	O
done	function
(	O
1	int
)	O
;	O
}	O
DBG	O
(	O
SAMPLEDEBUG	int
,	O
printf	function
(	O
"[cg_write_arcs] frompc 0x%lx selfpc 0x%lx count %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
arc	struct
->	O
parent	pointer
->	O
addr	pointer
,	O
(	O
unsigned	O
long	O
)	O
arc	struct
->	O
child	double
->	O
addr	pointer
,	O
arc	pointer
->	O
count	long
)	O
)	O
;	O
}	O
}	O
}	O
void	O
flat_blurb	function
(	O
FILE	struct
*	O
)	O
;	O
void	O
flat_blurb	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" %         the percentage of the total running time of the\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"time       program used by this function.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"cumulative a running sum of the number of seconds accounted\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" seconds   for by this function and those listed above it.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" self      the number of seconds accounted for by this\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"seconds    function alone.  This is the major sort for this\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"           listing.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"calls      the number of times this function was invoked, if\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"           this function is profiled, else blank.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" self      the average number of milliseconds spent in this\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"ms/call    function per call, if this function is profiled,\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"	   else blank.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" total     the average number of milliseconds spent in this\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"ms/call    function and its descendents per call, if this\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"	   function is profiled, else blank.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"name       the name of the function.  This is the minor sort\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"           for this listing. The index shows the location of\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"	   the function in the gprof listing. If the index is\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"	   in parenthesis it shows where it would appear in\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"	   the gprof listing if it were to be printed.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"Copyright (C) 2012-2020 Free Software Foundation, Inc.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"Copying and distribution of this file, with or without modification,\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"are permitted in any medium without royalty provided the copyright\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"notice and this notice are preserved.\n"	pointer
,	O
file	pointer
)	O
;	O
}	O
void	O
fsf_callg_blurb	function
(	O
FILE	struct
*	O
)	O
;	O
void	O
fsf_callg_blurb	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" This table describes the call tree of the program, and was sorted by\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" the total amount of time spent in each function and its children.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" Each entry in this table consists of several lines.  The line with the\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" index number at the left hand margin lists the current function.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" The lines above it list the functions that called this function,\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" and the lines below it list the functions this one called.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" This line lists:\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     index	A unique number given to each element of the table.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		Index numbers are sorted numerically.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		The index number is printed next to every function name so\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		it is easier to look up where the function is in the table.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     % time	This is the percentage of the `total' time that was spent\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		in this function and its children.  Note that due to\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		different viewpoints, functions excluded by options, etc,\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		these numbers will NOT add up to 100%.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     self	This is the total amount of time spent in this function.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     children	This is the total amount of time propagated into this\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		function by its children.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     called	This is the number of times the function was called.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		If the function called itself recursively, the number\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		only includes non-recursive calls, and is followed by\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		a `+' and the number of recursive calls.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     name	The name of the current function.  The index number is\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		printed after it.  If the function is a member of a\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		cycle, the cycle number is printed between the\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		function's name and the index number.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" For the function's parents, the fields have the following meanings:\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     self	This is the amount of time that was propagated directly\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		from the function into this parent.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     children	This is the amount of time that was propagated from\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		the function's children into this parent.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     called	This is the number of times this parent called the\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		function `/' the total number of times the function\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		was called.  Recursive calls to the function are not\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		included in the number after the `/'.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     name	This is the name of the parent.  The parent's index\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		number is printed after it.  If the parent is a\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		member of a cycle, the cycle number is printed between\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		the name and the index number.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" If the parents of the function cannot be determined, the word\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" `<spontaneous>' is printed in the `name' field, and all the other\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" fields are blank.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" For the function's children, the fields have the following meanings:\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     self	This is the amount of time that was propagated directly\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		from the child into the function.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     children	This is the amount of time that was propagated from the\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		child's children to the function.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     called	This is the number of times the function called\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		this child `/' the total number of times the child\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		was called.  Recursive calls by the child are not\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		listed in the number after the `/'.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"     name	This is the name of the child.  The child's index\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		number is printed after it.  If the child is a\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		member of a cycle, the cycle number is printed\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"		between the name and the index number.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" If there are any cycles (circles) in the call graph, there is an\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" entry for the cycle-as-a-whole.  This entry shows who called the\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" cycle (as parents) and the members of the cycle (as children.)\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" The `+' recursive calls entry shows the number of function calls that\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" were internal to the cycle, and the calls entry for each member shows,\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" for that member, how many times it was called from other members of\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
" the cycle.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"Copyright (C) 2012-2020 Free Software Foundation, Inc.\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"Copying and distribution of this file, with or without modification,\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"are permitted in any medium without royalty provided the copyright\n"	pointer
,	O
file	pointer
)	O
;	O
fputs	function
(	O
"notice and this notice are preserved.\n"	pointer
,	O
file	pointer
)	O
;	O
}	O
void	O
search_list_append	function
(	O
Search_List	struct
*	O
list	pointer
,	O
const	O
char	O
*	O
paths	pointer
)	O
{	O
Search_List_Elem	struct
*	O
new_el	pointer
;	O
const	O
char	O
*	O
beg	pointer
,	O
*	O
colon	pointer
;	O
unsigned	O
int	O
len	int
;	O
colon	pointer
=	O
paths	array
-	O
1	int
;	O
do	O
{	O
beg	pointer
=	O
colon	pointer
+	O
1	int
;	O
colon	pointer
=	O
strchr	function
(	O
beg	pointer
,	O
PATH_SEP_CHAR	pointer
)	O
;	O
if	O
(	O
colon	pointer
)	O
len	int
=	O
colon	pointer
-	O
beg	pointer
;	O
else	O
len	int
=	O
strlen	function
(	O
beg	pointer
)	O
;	O
new_el	pointer
=	O
(	O
Search_List_Elem	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
new_el	pointer
)	O
+	O
len	int
)	O
;	O
memcpy	function
(	O
new_el	pointer
->	O
path	pointer
,	O
beg	pointer
,	O
len	int
)	O
;	O
new_el	pointer
->	O
path	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
new_el	pointer
->	O
next	pointer
=	O
0	int
;	O
if	O
(	O
list	pointer
->	O
tail	pointer
)	O
list	pointer
->	O
tail	pointer
->	O
next	pointer
=	O
new_el	pointer
;	O
else	O
list	pointer
->	O
head	pointer
=	O
new_el	pointer
;	O
list	pointer
->	O
tail	pointer
=	O
new_el	pointer
;	O
}	O
while	O
(	O
colon	pointer
)	O
;	O
}	O
void	O
ldelf_map_segments	function
(	O
bfd_boolean	int
need_layout	int
)	O
{	O
int	O
tries	int
=	O
10	int
;	O
do	O
{	O
lang_relax_sections	function
(	O
need_layout	pointer
)	O
;	O
need_layout	int
=	O
FALSE	O
;	O
if	O
(	O
link_info	pointer
.	O
output_bfd	pointer
->	O
xvec	pointer
->	O
flavour	enum
==	O
bfd_target_elf_flavour	int
&&	O
!	O
bfd_link_relocatable	function
(	O
&	O
link_info	pointer
)	O
)	O
{	O
bfd_size_type	long
phdr_size	int
;	O
phdr_size	int
=	O
elf_program_header_size	function
(	O
link_info	pointer
.	O
output_bfd	int
)	O
;	O
if	O
(	O
lang_phdr_list	pointer
==	O
NULL	O
)	O
elf_seg_map	function
(	O
link_info	pointer
.	O
output_bfd	pointer
)	O
=	O
NULL	O
;	O
if	O
(	O
!	O
_bfd_elf_map_sections_to_segments	function
(	O
link_info	pointer
.	O
output_bfd	pointer
,	O
&	O
link_info	pointer
)	O
)	O
einfo	function
(	O
_	O
(	O
"%F%P: map sections to segments failed: %E\n"	pointer
)	O
)	O
;	O
if	O
(	O
phdr_size	int
!=	O
elf_program_header_size	function
(	O
link_info	pointer
.	O
output_bfd	int
)	O
)	O
{	O
if	O
(	O
tries	int
>	O
6	int
)	O
need_layout	int
=	O
TRUE	O
;	O
else	O
if	O
(	O
phdr_size	int
<	O
elf_program_header_size	function
(	O
link_info	pointer
.	O
output_bfd	int
)	O
)	O
need_layout	int
=	O
TRUE	O
;	O
else	O
elf_program_header_size	function
(	O
link_info	pointer
.	O
output_bfd	int
)	O
=	O
phdr_size	int
;	O
}	O
}	O
}	O
while	O
(	O
need_layout	int
&&	O
--	O
tries	int
)	O
;	O
if	O
(	O
tries	int
==	O
0	int
)	O
einfo	function
(	O
_	O
(	O
"%F%P: looping in map_segments"	pointer
)	O
)	O
;	O
}	O
int	O
ldelf_emit_ctf_early	function
(	O
void	O
)	O
{	O
if	O
(	O
bfd_get_flavour	function
(	O
link_info	pointer
.	O
output_bfd	int
)	O
==	O
bfd_target_elf_flavour	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
struct	O
ctf_strsym_iter_cb_arg	struct
{	O
struct	O
elf_sym_strtab	struct
*	O
syms	pointer
;	O
bfd_size_type	long
symcount	int
;	O
struct	O
elf_strtab_hash	struct
*	O
symstrtab	pointer
;	O
size_t	long
next_i	long
;	O
size_t	long
next_idx	long
;	O
}	O
;	O
static	O
const	O
char	O
*	O
ldelf_ctf_strtab_iter_cb	function
(	O
uint32_t	int
*	O
offset	pointer
,	O
void	O
*	O
arg_	pointer
)	O
{	O
bfd_size_type	long
off	long
;	O
const	O
char	O
*	O
ret	pointer
;	O
struct	O
ctf_strsym_iter_cb_arg	struct
*	O
arg	pointer
=	O
(	O
struct	O
ctf_strsym_iter_cb_arg	struct
*	O
)	O
arg_	pointer
;	O
if	O
(	O
arg	pointer
->	O
next_i	int
==	O
0	int
)	O
arg	pointer
->	O
next_i	int
=	O
1	int
;	O
if	O
(	O
arg	pointer
->	O
next_i	int
>=	O
_bfd_elf_strtab_len	function
(	O
arg	pointer
->	O
symstrtab	int
)	O
)	O
{	O
arg	pointer
->	O
next_i	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
ret	int
=	O
_bfd_elf_strtab_str	function
(	O
arg	pointer
->	O
symstrtab	pointer
,	O
arg	pointer
->	O
next_i	pointer
++	O
,	O
&	O
off	long
)	O
;	O
*	O
offset	pointer
=	O
off	long
;	O
if	O
(	O
*	O
offset	pointer
!=	O
off	long
)	O
return	O
NULL	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
struct	O
ctf_link_sym	struct
*	O
ldelf_ctf_symbols_iter_cb	function
(	O
struct	O
ctf_link_sym	struct
*	O
dest	pointer
,	O
void	O
*	O
arg_	pointer
)	O
{	O
struct	O
ctf_strsym_iter_cb_arg	struct
*	O
arg	pointer
=	O
(	O
struct	O
ctf_strsym_iter_cb_arg	struct
*	O
)	O
arg_	pointer
;	O
if	O
(	O
arg	pointer
->	O
next_i	int
>	O
arg	pointer
->	O
symcount	int
)	O
{	O
arg	pointer
->	O
next_i	int
=	O
0	int
;	O
arg	pointer
->	O
next_idx	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
ASSERT	O
(	O
arg	pointer
->	O
syms	pointer
[	O
arg	pointer
->	O
next_i	int
]	O
.	O
dest_index	pointer
==	O
arg	pointer
->	O
next_idx	int
)	O
;	O
dest	pointer
->	O
st_name	pointer
=	O
_bfd_elf_strtab_str	function
(	O
arg	pointer
->	O
symstrtab	pointer
,	O
arg	pointer
->	O
next_i	pointer
,	O
NULL	O
)	O
;	O
dest	pointer
->	O
st_shndx	pointer
=	O
arg	pointer
->	O
syms	pointer
[	O
arg	pointer
->	O
next_i	int
]	O
.	O
sym	pointer
.	O
st_shndx	int
;	O
dest	pointer
->	O
st_type	pointer
=	O
ELF_ST_TYPE	function
(	O
arg	pointer
->	O
syms	pointer
[	O
arg	pointer
->	O
next_i	int
]	O
.	O
sym	pointer
.	O
st_info	int
)	O
;	O
dest	pointer
->	O
st_value	pointer
=	O
arg	pointer
->	O
syms	pointer
[	O
arg	pointer
->	O
next_i	int
]	O
.	O
sym	struct
.	O
st_value	int
;	O
arg	pointer
->	O
next_i	int
++	O
;	O
return	O
dest	pointer
;	O
}	O
void	O
ldelf_examine_strtab_for_ctf	function
(	O
struct	O
ctf_file	struct
*	O
ctf_output	pointer
,	O
struct	O
elf_sym_strtab	struct
*	O
syms	pointer
,	O
bfd_size_type	long
symcount	int
,	O
struct	O
elf_strtab_hash	struct
*	O
symstrtab	pointer
)	O
{	O
struct	O
ctf_strsym_iter_cb_arg	struct
args	pointer
=	O
{	O
syms	pointer
,	O
symcount	pointer
,	O
symstrtab	function
,	O
0	int
,	O
0	int
}	O
;	O
if	O
(	O
!	O
ctf_output	pointer
)	O
return	O
;	O
if	O
(	O
bfd_get_flavour	function
(	O
link_info	pointer
.	O
output_bfd	int
)	O
==	O
bfd_target_elf_flavour	int
&&	O
!	O
bfd_link_relocatable	function
(	O
&	O
link_info	pointer
)	O
)	O
{	O
if	O
(	O
ctf_link_add_strtab	function
(	O
ctf_output	pointer
,	O
ldelf_ctf_strtab_iter_cb	pointer
,	O
&	O
args	pointer
)	O
<	O
0	int
)	O
einfo	function
(	O
_	O
(	O
"%F%P: warning: CTF strtab association failed; strings will "	pointer
"not be shared: %s\n"	pointer
)	O
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
ctf_output	pointer
)	O
)	O
)	O
;	O
if	O
(	O
ctf_link_shuffle_syms	function
(	O
ctf_output	pointer
,	O
ldelf_ctf_symbols_iter_cb	int
,	O
&	O
args	pointer
)	O
<	O
0	int
)	O
einfo	function
(	O
_	O
(	O
"%F%P: warning: CTF symbol shuffling failed; slight space "	pointer
"cost: %s\n"	pointer
)	O
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
ctf_output	pointer
)	O
)	O
)	O
;	O
}	O
}	O
void	O
ctf_decl_init	function
(	O
ctf_decl_t	struct
*	O
cd	pointer
)	O
{	O
int	O
i	int
;	O
memset	function
(	O
cd	pointer
,	O
0	int
,	O
sizeof	O
(	O
ctf_decl_t	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
CTF_PREC_BASE	int
;	O
i	int
<	O
CTF_PREC_MAX	int
;	O
i	int
++	O
)	O
cd	pointer
->	O
cd_order	array
[	O
i	int
]	O
=	O
CTF_PREC_BASE	int
-	O
1	int
;	O
cd	pointer
->	O
cd_qualp	pointer
=	O
CTF_PREC_BASE	int
;	O
cd	pointer
->	O
cd_ordp	int
=	O
CTF_PREC_BASE	int
;	O
}	O
void	O
ctf_decl_fini	function
(	O
ctf_decl_t	struct
*	O
cd	pointer
)	O
{	O
ctf_decl_node_t	struct
*	O
cdp	pointer
,	O
*	O
ndp	pointer
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
CTF_PREC_BASE	int
;	O
i	int
<	O
CTF_PREC_MAX	int
;	O
i	int
++	O
)	O
{	O
for	O
(	O
cdp	int
=	O
ctf_list_next	function
(	O
&	O
cd	pointer
->	O
cd_nodes	array
[	O
i	int
]	O
)	O
;	O
cdp	pointer
!=	O
NULL	O
;	O
cdp	int
=	O
ndp	int
)	O
{	O
ndp	pointer
=	O
ctf_list_next	function
(	O
cdp	pointer
)	O
;	O
free	function
(	O
cdp	pointer
)	O
;	O
}	O
}	O
}	O
void	O
ctf_decl_push	function
(	O
ctf_decl_t	struct
*	O
cd	pointer
,	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_id_t	enum
type	enum
)	O
{	O
ctf_decl_node_t	struct
*	O
cdp	pointer
;	O
ctf_decl_prec_t	enum
prec	enum
;	O
uint32_t	int
kind	int
,	O
n	int
=	O
1	int
;	O
int	O
is_qual	int
=	O
0	int
;	O
const	O
ctf_type_t	struct
*	O
tp	pointer
;	O
ctf_arinfo_t	struct
ar	double
;	O
if	O
(	O
(	O
tp	pointer
=	O
ctf_lookup_by_id	function
(	O
&	O
fp	pointer
,	O
type	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
cd	pointer
->	O
cd_err	pointer
=	O
fp	pointer
->	O
ctf_errno	function
;	O
return	O
;	O
}	O
switch	O
(	O
kind	int
=	O
LCTF_INFO_KIND	function
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_info	int
)	O
)	O
{	O
case	O
CTF_K_ARRAY	int
:	O
(	O
void	O
)	O
ctf_array_info	function
(	O
fp	pointer
,	O
type	pointer
,	O
&	O
ar	struct
)	O
;	O
ctf_decl_push	function
(	O
cd	pointer
,	O
fp	pointer
,	O
ar	struct
.	O
ctr_contents	int
)	O
;	O
n	int
=	O
ar	struct
.	O
ctr_nelems	int
;	O
prec	int
=	O
CTF_PREC_ARRAY	int
;	O
break	O
;	O
case	O
CTF_K_TYPEDEF	int
:	O
if	O
(	O
ctf_strptr	function
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_name	pointer
)	O
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
ctf_decl_push	function
(	O
cd	pointer
,	O
fp	pointer
,	O
tp	pointer
->	O
ctt_type	pointer
)	O
;	O
return	O
;	O
}	O
prec	int
=	O
CTF_PREC_BASE	int
;	O
break	O
;	O
case	O
CTF_K_FUNCTION	int
:	O
ctf_decl_push	function
(	O
cd	pointer
,	O
fp	pointer
,	O
tp	pointer
->	O
ctt_type	int
)	O
;	O
prec	int
=	O
CTF_PREC_FUNCTION	int
;	O
break	O
;	O
case	O
CTF_K_POINTER	int
:	O
ctf_decl_push	function
(	O
cd	pointer
,	O
fp	pointer
,	O
tp	pointer
->	O
ctt_type	int
)	O
;	O
prec	int
=	O
CTF_PREC_POINTER	int
;	O
break	O
;	O
case	O
CTF_K_SLICE	int
:	O
ctf_decl_push	function
(	O
cd	pointer
,	O
fp	pointer
,	O
ctf_type_reference	function
(	O
fp	pointer
,	O
type	int
)	O
)	O
;	O
prec	int
=	O
CTF_PREC_BASE	int
;	O
break	O
;	O
case	O
CTF_K_VOLATILE	int
:	O
case	O
CTF_K_CONST	int
:	O
case	O
CTF_K_RESTRICT	int
:	O
ctf_decl_push	function
(	O
cd	pointer
,	O
fp	pointer
,	O
tp	pointer
->	O
ctt_type	int
)	O
;	O
prec	int
=	O
cd	pointer
->	O
cd_qualp	int
;	O
is_qual	int
++	O
;	O
break	O
;	O
default	O
:	O
prec	int
=	O
CTF_PREC_BASE	int
;	O
}	O
if	O
(	O
(	O
cdp	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
ctf_decl_node_t	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
cd	pointer
->	O
cd_err	int
=	O
EAGAIN	int
;	O
return	O
;	O
}	O
cdp	pointer
->	O
cd_type	int
=	O
type	int
;	O
cdp	pointer
->	O
cd_kind	enum
=	O
kind	int
;	O
cdp	pointer
->	O
cd_n	long
=	O
n	int
;	O
if	O
(	O
ctf_list_next	function
(	O
&	O
cd	pointer
->	O
cd_nodes	array
[	O
prec	int
]	O
)	O
==	O
NULL	O
)	O
cd	pointer
->	O
cd_order	array
[	O
prec	int
]	O
=	O
cd	pointer
->	O
cd_ordp	int
++	O
;	O
if	O
(	O
prec	int
>	O
cd	pointer
->	O
cd_qualp	int
&&	O
prec	int
<	O
CTF_PREC_ARRAY	int
)	O
cd	pointer
->	O
cd_qualp	enum
=	O
prec	int
;	O
if	O
(	O
kind	enum
==	O
CTF_K_ARRAY	int
||	O
(	O
is_qual	int
&&	O
prec	int
==	O
CTF_PREC_BASE	int
)	O
)	O
ctf_list_prepend	function
(	O
&	O
cd	pointer
->	O
cd_nodes	array
[	O
prec	int
]	O
,	O
cdp	pointer
)	O
;	O
else	O
ctf_list_append	function
(	O
&	O
cd	pointer
->	O
cd_nodes	array
[	O
prec	int
]	O
,	O
cdp	pointer
)	O
;	O
}	O
_libctf_printflike_	O
(	O
2	int
,	O
3	int
)	O
void	O
ctf_decl_sprintf	function
(	O
ctf_decl_t	struct
*	O
cd	pointer
,	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
char	O
*	O
str	pointer
;	O
int	O
n	int
;	O
if	O
(	O
cd	pointer
->	O
cd_enomem	pointer
)	O
return	O
;	O
va_start	O
(	O
ap	pointer
,	O
format	pointer
)	O
;	O
n	int
=	O
vasprintf	function
(	O
&	O
str	pointer
,	O
format	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
char	O
*	O
newbuf	pointer
;	O
if	O
(	O
(	O
newbuf	pointer
=	O
ctf_str_append	function
(	O
cd	pointer
->	O
cd_buf	pointer
,	O
str	pointer
)	O
)	O
!=	O
NULL	O
)	O
cd	pointer
->	O
cd_buf	pointer
=	O
newbuf	pointer
;	O
}	O
if	O
(	O
n	int
<	O
0	int
||	O
cd	pointer
->	O
cd_buf	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
cd	pointer
->	O
cd_buf	pointer
)	O
;	O
cd	pointer
->	O
cd_buf	pointer
=	O
NULL	O
;	O
cd	pointer
->	O
cd_enomem	int
=	O
1	int
;	O
}	O
free	function
(	O
str	pointer
)	O
;	O
}	O
char	O
*	O
ctf_decl_buf	function
(	O
ctf_decl_t	struct
*	O
cd	pointer
)	O
{	O
return	O
cd	pointer
->	O
cd_buf	pointer
;	O
}	O
void	O
ctf_list_append	function
(	O
ctf_list_t	struct
*	O
lp	pointer
,	O
void	O
*	O
newp	pointer
)	O
{	O
ctf_list_t	struct
*	O
p	pointer
=	O
lp	pointer
->	O
l_prev	pointer
;	O
ctf_list_t	struct
*	O
q	pointer
=	O
newp	pointer
;	O
lp	pointer
->	O
l_prev	pointer
=	O
q	pointer
;	O
q	pointer
->	O
l_prev	pointer
=	O
p	pointer
;	O
q	pointer
->	O
l_next	pointer
=	O
NULL	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
p	pointer
->	O
l_next	int
=	O
q	pointer
;	O
else	O
lp	pointer
->	O
l_next	enum
=	O
q	pointer
;	O
}	O
void	O
ctf_list_prepend	function
(	O
ctf_list_t	struct
*	O
lp	pointer
,	O
void	O
*	O
newp	pointer
)	O
{	O
ctf_list_t	struct
*	O
p	pointer
=	O
newp	pointer
;	O
ctf_list_t	struct
*	O
q	pointer
=	O
lp	pointer
->	O
l_next	pointer
;	O
lp	pointer
->	O
l_next	pointer
=	O
p	pointer
;	O
p	pointer
->	O
l_prev	pointer
=	O
NULL	O
;	O
p	pointer
->	O
l_next	pointer
=	O
q	pointer
;	O
if	O
(	O
q	pointer
!=	O
NULL	O
)	O
q	pointer
->	O
l_prev	pointer
=	O
p	pointer
;	O
else	O
lp	pointer
->	O
l_prev	pointer
=	O
p	pointer
;	O
}	O
void	O
ctf_list_delete	function
(	O
ctf_list_t	struct
*	O
lp	pointer
,	O
void	O
*	O
existing	pointer
)	O
{	O
ctf_list_t	struct
*	O
p	pointer
=	O
existing	pointer
;	O
if	O
(	O
p	pointer
->	O
l_prev	pointer
!=	O
NULL	O
)	O
p	pointer
->	O
l_prev	pointer
->	O
l_next	pointer
=	O
p	pointer
->	O
l_next	int
;	O
else	O
lp	pointer
->	O
l_next	enum
=	O
p	pointer
->	O
l_next	int
;	O
if	O
(	O
p	pointer
->	O
l_next	pointer
!=	O
NULL	O
)	O
p	pointer
->	O
l_next	pointer
->	O
l_prev	pointer
=	O
p	pointer
->	O
l_prev	int
;	O
else	O
lp	pointer
->	O
l_prev	pointer
=	O
p	pointer
->	O
l_prev	int
;	O
}	O
int	O
ctf_list_empty_p	function
(	O
ctf_list_t	struct
*	O
lp	pointer
)	O
{	O
return	O
(	O
lp	pointer
->	O
l_next	pointer
==	O
NULL	O
&&	O
lp	pointer
->	O
l_prev	pointer
==	O
NULL	O
)	O
;	O
}	O
Elf64_Sym	struct
*	O
ctf_sym_to_elf64	function
(	O
const	O
Elf32_Sym	struct
*	O
src	pointer
,	O
Elf64_Sym	struct
*	O
dst	pointer
)	O
{	O
dst	pointer
->	O
st_name	int
=	O
src	pointer
->	O
st_name	pointer
;	O
dst	pointer
->	O
st_value	int
=	O
src	pointer
->	O
st_value	pointer
;	O
dst	pointer
->	O
st_size	long
=	O
src	pointer
->	O
st_size	long
;	O
dst	pointer
->	O
st_info	int
=	O
src	pointer
->	O
st_info	pointer
;	O
dst	pointer
->	O
st_other	int
=	O
src	pointer
->	O
st_other	pointer
;	O
dst	pointer
->	O
st_shndx	pointer
=	O
src	pointer
->	O
st_shndx	pointer
;	O
return	O
dst	pointer
;	O
}	O
char	O
*	O
ctf_str_append	function
(	O
char	O
*	O
s	pointer
,	O
const	O
char	O
*	O
append	pointer
)	O
{	O
size_t	long
s_len	long
=	O
0	int
;	O
if	O
(	O
append	pointer
==	O
NULL	O
)	O
return	O
s	pointer
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
s_len	long
=	O
strlen	function
(	O
s	pointer
)	O
;	O
size_t	long
append_len	long
=	O
strlen	function
(	O
append	pointer
)	O
;	O
if	O
(	O
(	O
s	pointer
=	O
realloc	function
(	O
s	pointer
,	O
s_len	long
+	O
append_len	int
+	O
1	int
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
s	pointer
+	O
s_len	int
,	O
append	pointer
,	O
append_len	int
)	O
;	O
s	pointer
[	O
s_len	long
+	O
append_len	int
]	O
=	O
'\0'	O
;	O
return	O
s	pointer
;	O
}	O
char	O
*	O
ctf_str_append_noerr	function
(	O
char	O
*	O
s	pointer
,	O
const	O
char	O
*	O
append	pointer
)	O
{	O
char	O
*	O
new_s	pointer
;	O
new_s	pointer
=	O
ctf_str_append	function
(	O
s	pointer
,	O
append	pointer
)	O
;	O
if	O
(	O
!	O
new_s	pointer
)	O
return	O
s	pointer
;	O
return	O
new_s	pointer
;	O
}	O
void	O
*	O
ctf_realloc	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
fp	pointer
->	O
ctf_str_num_refs	long
>	O
0	int
)	O
{	O
ctf_dprintf	function
(	O
"%p: attempt to realloc() string table with %lu active refs\n"	pointer
,	O
(	O
void	O
*	O
)	O
fp	pointer
,	O
(	O
unsigned	O
long	O
)	O
fp	pointer
->	O
ctf_str_num_refs	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
realloc	function
(	O
ptr	pointer
,	O
size	long
)	O
;	O
}	O
void	O
*	O
ctf_set_open_errno	function
(	O
int	O
*	O
errp	pointer
,	O
int	O
error	int
)	O
{	O
if	O
(	O
errp	pointer
!=	O
NULL	O
)	O
*	O
errp	pointer
=	O
error	pointer
;	O
return	O
NULL	O
;	O
}	O
unsigned	O
long	O
ctf_set_errno	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
int	O
err	int
)	O
{	O
fp	pointer
->	O
ctf_errno	function
=	O
err	long
;	O
return	O
CTF_ERR	pointer
;	O
}	O
const	O
char	O
*	O
argp_program_bug_address	pointer
;	O
typedef	O
int	O
dummy	int
;	O
const	O
char	O
*	O
argp_program_version	pointer
;	O
void	O
(	O
*	O
argp_program_version_hook	pointer
)	O
(	O
FILE	struct
*	O
stream	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
=	O
NULL	O
;	O
static	O
void	O
print_symbol_type	function
(	O
FILE	struct
*	O
outfile	pointer
,	O
Symbol	struct
*	O
sym	pointer
)	O
{	O
if	O
(	O
sym	pointer
->	O
decl	pointer
)	O
fprintf	function
(	O
outfile	pointer
,	O
"%s, <%s %d>"	pointer
,	O
sym	pointer
->	O
decl	pointer
,	O
sym	pointer
->	O
source	pointer
,	O
sym	pointer
->	O
def_line	int
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"<>"	pointer
)	O
;	O
}	O
static	O
int	O
print_symbol	function
(	O
FILE	struct
*	O
outfile	pointer
,	O
int	O
line	int
,	O
struct	O
output_symbol	struct
*	O
s	long
)	O
{	O
print_level	function
(	O
s	long
->	O
level	int
,	O
s	long
->	O
last	long
)	O
;	O
fprintf	function
(	O
outfile	pointer
,	O
"%s: "	pointer
,	O
s	pointer
->	O
sym	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
brief_listing	int
)	O
{	O
if	O
(	O
s	pointer
->	O
sym	pointer
->	O
expand_line	int
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
"%d"	pointer
,	O
s	int
->	O
sym	pointer
->	O
expand_line	int
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
s	long
->	O
sym	pointer
->	O
callee	pointer
)	O
s	long
->	O
sym	pointer
->	O
expand_line	int
=	O
line	int
;	O
}	O
print_symbol_type	function
(	O
outfile	pointer
,	O
s	pointer
->	O
sym	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
posix_output_handler	function
(	O
cflow_output_command	enum
cmd	pointer
,	O
FILE	struct
*	O
outfile	pointer
,	O
int	O
line	int
,	O
void	O
*	O
data	pointer
,	O
void	O
*	O
handler_data	pointer
)	O
{	O
switch	O
(	O
cmd	int
)	O
{	O
case	O
cflow_output_init	int
:	O
if	O
(	O
emacs_option	int
)	O
error	function
(	O
EX_USAGE	int
,	O
0	int
,	O
_	O
(	O
"--format=posix is not compatible with --emacs"	pointer
)	O
)	O
;	O
brief_listing	int
=	O
print_line_numbers	int
=	O
omit_symbol_names_option	int
=	O
1	int
;	O
break	O
;	O
case	O
cflow_output_begin	int
:	O
case	O
cflow_output_end	int
:	O
case	O
cflow_output_separator	int
:	O
break	O
;	O
case	O
cflow_output_newline	int
:	O
fprintf	function
(	O
outfile	pointer
,	O
"\n"	pointer
)	O
;	O
break	O
;	O
case	O
cflow_output_text	int
:	O
fprintf	function
(	O
outfile	pointer
,	O
"%s"	pointer
,	O
(	O
char	O
*	O
)	O
data	pointer
)	O
;	O
break	O
;	O
case	O
cflow_output_symbol	int
:	O
return	O
print_symbol	function
(	O
outfile	pointer
,	O
line	int
,	O
data	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
STRINGTYPE	O
df_name_data_field	struct
=	O
{	O
10	int
,	O
DStr_constant	int
,	O
"data-field"	int
}	O
;	O
STRINGTYPE	O
df_name_reference_field	struct
=	O
{	O
15	int
,	O
DStr_constant	int
,	O
"reference-field"	int
}	O
;	O
STRINGTYPE	O
df_name_hierarchy_field	struct
=	O
{	O
21	int
,	O
DStr_constant	int
,	O
"prior-reference-field"	int
}	O
;	O
STRINGTYPE	O
df_name_sum_field	struct
=	O
{	O
9	int
,	O
DStr_constant	int
,	O
"sum-field"	int
}	O
;	O
STRINGTYPE	O
df_name_input_field	struct
=	O
{	O
11	int
,	O
DStr_constant	int
,	O
"input-field"	int
}	O
;	O
STRINGTYPE	O
df_name_input_record	struct
=	O
{	O
12	int
,	O
DStr_constant	int
,	O
"input-record"	int
}	O
;	O
int	O
create_scheme_string_variable	function
(	O
name	pointer
,	O
number	int
,	O
value	int
)	O
STRINGTYPE	O
*	O
name	pointer
;	O
int	O
number	int
;	O
STRINGTYPE	O
*	O
value	pointer
;	O
{	O
char	O
*	O
command	pointer
;	O
char	O
*	O
var_name	pointer
;	O
return	O
EXIT_SUCCESS	int
;	O
}	O
int	O
eval_scheme_boolean_function	function
(	O
command	pointer
)	O
char	O
*	O
command	pointer
;	O
{	O
}	O
STRINGTYPE	O
*	O
eval_scheme_string_function	function
(	O
command	pointer
)	O
char	O
*	O
command	pointer
;	O
{	O
}	O
STRINGTYPE	O
*	O
df_get_next_record	function
(	O
stream	pointer
,	O
buffer	pointer
,	O
bufferpos	pointer
,	O
buffersiz	pointer
,	O
record_delimiter	pointer
,	O
record_length	bool
)	O
FILE	struct
*	O
stream	pointer
;	O
unsigned	O
char	O
*	O
*	O
buffer	pointer
;	O
size_t	long
*	O
bufferpos	pointer
;	O
size_t	long
*	O
buffersiz	pointer
;	O
STRINGTYPE	O
*	O
record_delimiter	pointer
;	O
size_t	long
record_length	long
;	O
{	O
STRINGTYPE	O
buffer_desc	struct
;	O
int	O
need_more_data	int
;	O
int	O
next_record_pos	int
;	O
int	O
return_code	int
;	O
STRINGTYPE	O
*	O
return_string	pointer
;	O
buffer_desc	struct
.	O
string	pointer
=	O
*	O
buffer	pointer
+	O
*	O
bufferpos	pointer
;	O
buffer_desc	struct
.	O
length	long
=	O
*	O
buffersiz	pointer
-	O
*	O
bufferpos	pointer
;	O
need_more_data	long
=	O
0	int
;	O
if	O
(	O
*	O
buffersiz	pointer
==	O
0	int
)	O
need_more_data	long
=	O
1	int
;	O
else	O
if	O
(	O
record_length	long
!=	O
0	int
)	O
{	O
if	O
(	O
*	O
buffersiz	pointer
-	O
*	O
bufferpos	pointer
<	O
record_length	long
)	O
need_more_data	int
=	O
1	int
;	O
}	O
else	O
{	O
next_record_pos	int
=	O
dstrstr	function
(	O
&	O
buffer_desc	struct
,	O
record_delimiter	pointer
)	O
;	O
if	O
(	O
next_record_pos	int
==	O
0	int
)	O
need_more_data	int
=	O
1	int
;	O
}	O
while	O
(	O
need_more_data	pointer
&&	O
!	O
feof	function
(	O
stream	pointer
)	O
)	O
{	O
if	O
(	O
*	O
bufferpos	pointer
==	O
0	int
)	O
{	O
if	O
(	O
*	O
buffer	pointer
==	O
NULL	O
)	O
*	O
buffer	pointer
=	O
malloc	function
(	O
DF_BUFFER_INCREMENT	int
)	O
;	O
else	O
*	O
buffer	pointer
=	O
realloc	function
(	O
*	O
buffer	pointer
,	O
*	O
buffersiz	pointer
+	O
DF_BUFFER_INCREMENT	int
)	O
;	O
if	O
(	O
*	O
buffer	pointer
==	O
NULL	O
)	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
return_code	int
=	O
fread	function
(	O
*	O
buffer	pointer
+	O
*	O
buffersiz	pointer
,	O
1	int
,	O
DF_BUFFER_INCREMENT	int
,	O
stream	pointer
)	O
;	O
if	O
(	O
return_code	int
<	O
DF_BUFFER_INCREMENT	int
&&	O
ferror	function
(	O
stream	pointer
)	O
)	O
FATAL_PERROR	O
(	O
_	O
(	O
"File"	pointer
)	O
)	O
;	O
*	O
buffersiz	pointer
+=	O
return_code	int
;	O
}	O
else	O
{	O
memmove	function
(	O
*	O
buffer	pointer
,	O
*	O
buffer	pointer
+	O
*	O
bufferpos	pointer
,	O
*	O
buffersiz	pointer
-	O
*	O
bufferpos	pointer
)	O
;	O
*	O
bufferpos	pointer
=	O
*	O
buffersiz	pointer
-	O
*	O
bufferpos	pointer
;	O
return_code	int
=	O
fread	function
(	O
*	O
buffer	pointer
+	O
*	O
bufferpos	pointer
,	O
1	int
,	O
*	O
buffersiz	pointer
-	O
*	O
bufferpos	pointer
,	O
stream	pointer
)	O
;	O
if	O
(	O
return_code	int
<	O
*	O
buffersiz	pointer
-	O
*	O
bufferpos	pointer
&&	O
ferror	function
(	O
stream	pointer
)	O
)	O
FATAL_PERROR	O
(	O
_	O
(	O
"File"	pointer
)	O
)	O
;	O
if	O
(	O
return_code	int
<	O
*	O
buffersiz	pointer
-	O
*	O
bufferpos	pointer
)	O
*	O
buffersiz	pointer
=	O
*	O
bufferpos	pointer
+	O
return_code	int
;	O
*	O
bufferpos	pointer
=	O
0	int
;	O
}	O
buffer_desc	struct
.	O
string	pointer
=	O
*	O
buffer	pointer
+	O
*	O
bufferpos	pointer
;	O
buffer_desc	struct
.	O
length	long
=	O
*	O
buffersiz	pointer
-	O
*	O
bufferpos	pointer
;	O
need_more_data	long
=	O
0	int
;	O
if	O
(	O
record_length	bool
!=	O
0	int
)	O
{	O
if	O
(	O
*	O
buffersiz	pointer
-	O
*	O
bufferpos	pointer
<	O
record_length	long
)	O
need_more_data	int
=	O
1	int
;	O
}	O
else	O
{	O
next_record_pos	int
=	O
dstrstr	function
(	O
&	O
buffer_desc	struct
,	O
record_delimiter	pointer
)	O
;	O
if	O
(	O
next_record_pos	int
==	O
0	int
)	O
need_more_data	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
*	O
bufferpos	pointer
<	O
*	O
buffersiz	pointer
)	O
{	O
if	O
(	O
record_length	long
!=	O
0	int
)	O
{	O
return_string	pointer
=	O
dstrsubstr	function
(	O
&	O
buffer_desc	struct
,	O
1	int
,	O
0	int
,	O
MIN	O
(	O
record_length	long
,	O
buffer_desc	struct
.	O
length	long
)	O
,	O
DStr_not_own	int
)	O
;	O
*	O
bufferpos	pointer
+=	O
return_string	pointer
->	O
length	long
;	O
}	O
else	O
{	O
if	O
(	O
next_record_pos	int
==	O
0	int
)	O
next_record_pos	int
=	O
buffer_desc	struct
.	O
length	long
+	O
1	int
;	O
return_string	pointer
=	O
dstrsubstr	function
(	O
&	O
buffer_desc	struct
,	O
1	int
,	O
next_record_pos	int
-	O
1	int
,	O
0	int
,	O
DStr_not_own	int
)	O
;	O
*	O
bufferpos	pointer
=	O
*	O
bufferpos	pointer
+	O
next_record_pos	int
-	O
1	int
+	O
record_delimiter	pointer
->	O
length	long
;	O
}	O
if	O
(	O
return_string	pointer
==	O
NULL	O
)	O
{	O
FATAL_ERROR	O
(	O
_	O
(	O
"unable to allocate memory"	pointer
)	O
)	O
;	O
}	O
return	O
return_string	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
__argmatch_die	function
(	O
void	O
)	O
{	O
ARGMATCH_DIE	int
;	O
}	O
argmatch_exit_fn	pointer
argmatch_die	pointer
=	O
__argmatch_die	pointer
;	O
ptrdiff_t	bool
argmatch	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
size_t	long
arglen	long
;	O
ptrdiff_t	long
matchind	long
=	O
-	O
1	int
;	O
bool	bool
ambiguous	bool
=	O
false	int
;	O
arglen	long
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
arglist	array
[	O
i	pointer
]	O
,	O
arg	pointer
,	O
arglen	pointer
)	O
)	O
{	O
if	O
(	O
strlen	function
(	O
arglist	array
[	O
i	long
]	O
)	O
==	O
arglen	pointer
)	O
return	O
i	long
;	O
else	O
if	O
(	O
matchind	int
==	O
-	O
1	int
)	O
matchind	long
=	O
i	long
;	O
else	O
{	O
if	O
(	O
vallist	pointer
==	O
NULL	O
||	O
memcmp	function
(	O
vallist	pointer
+	O
valsize	struct
*	O
matchind	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
{	O
ambiguous	bool
=	O
true	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
ambiguous	pointer
)	O
return	O
-	O
2	int
;	O
else	O
return	O
matchind	pointer
;	O
}	O
void	O
argmatch_invalid	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
ptrdiff_t	long
problem	long
)	O
{	O
char	O
const	O
*	O
format	pointer
=	O
(	O
problem	int
==	O
-	O
1	int
?	O
_	O
(	O
"invalid argument %s for %s"	pointer
)	O
:	O
_	O
(	O
"ambiguous argument %s for %s"	pointer
)	O
)	O
;	O
error	function
(	O
0	int
,	O
0	int
,	O
format	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
ARGMATCH_QUOTING_STYLE	pointer
,	O
value	pointer
)	O
,	O
quote_n	function
(	O
1	int
,	O
context	pointer
)	O
)	O
;	O
}	O
void	O
argmatch_valid	function
(	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
const	O
char	O
*	O
last_val	pointer
=	O
NULL	O
;	O
fputs	function
(	O
_	O
(	O
"Valid arguments are:"	pointer
)	O
,	O
stderr	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
(	O
i	long
==	O
0	int
)	O
||	O
memcmp	function
(	O
last_val	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\n  - %s"	pointer
,	O
quote	function
(	O
arglist	array
[	O
i	long
]	O
)	O
)	O
;	O
last_val	pointer
=	O
vallist	pointer
+	O
valsize	O
*	O
i	long
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
", %s"	pointer
,	O
quote	function
(	O
arglist	array
[	O
i	long
]	O
)	O
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
}	O
ptrdiff_t	bool
__xargmatch_internal	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
,	O
argmatch_exit_fn	pointer
exit_fn	pointer
)	O
{	O
ptrdiff_t	long
res	long
=	O
argmatch	function
(	O
arg	pointer
,	O
arglist	int
,	O
vallist	pointer
,	O
valsize	pointer
)	O
;	O
if	O
(	O
res	int
>=	O
0	int
)	O
return	O
res	pointer
;	O
argmatch_invalid	function
(	O
context	pointer
,	O
arg	pointer
,	O
res	pointer
)	O
;	O
argmatch_valid	function
(	O
arglist	int
,	O
vallist	pointer
,	O
valsize	int
)	O
;	O
(	O
*	O
exit_fn	pointer
)	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
const	O
char	O
*	O
argmatch_to_argument	function
(	O
const	O
char	O
*	O
value	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
!	O
memcmp	function
(	O
value	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	int
,	O
valsize	int
)	O
)	O
return	O
arglist	array
[	O
i	long
]	O
;	O
return	O
NULL	O
;	O
}	O
error_t	int
argp_err_exit_status	int
=	O
EX_USAGE	int
;	O
const	O
char	O
*	O
argp_program_version	pointer
;	O
void	O
(	O
*	O
argp_program_version_hook	pointer
)	O
(	O
FILE	struct
*	O
stream	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
=	O
NULL	O
;	O
void	O
gettime	function
(	O
struct	O
timespec	struct
*	O
ts	pointer
)	O
{	O
if	O
(	O
clock_gettime	function
(	O
CLOCK_REALTIME	int
,	O
ts	pointer
)	O
==	O
0	int
)	O
return	O
;	O
{	O
struct	O
timeval	struct
tv	struct
;	O
gettimeofday	function
(	O
&	O
tv	struct
,	O
NULL	O
)	O
;	O
ts	pointer
->	O
tv_sec	long
=	O
tv	struct
.	O
tv_sec	long
;	O
ts	pointer
->	O
tv_nsec	long
=	O
tv	struct
.	O
tv_usec	long
*	O
1000	int
;	O
}	O
}	O
int	O
exit_status	int
=	O
PAXEXIT_SUCCESS	int
;	O
void	O
fatal_exit	function
(	O
)	O
{	O
exit	function
(	O
PAXEXIT_FAILURE	int
)	O
;	O
}	O
enum	O
{	O
HAVE_GNU_CALLOC	int
=	O
1	int
}	O
;	O
static	O
inline	O
void	O
*	O
xnmalloc_inline	function
(	O
size_t	long
n	long
,	O
size_t	long
s	long
)	O
{	O
void	O
*	O
p	pointer
;	O
if	O
(	O
xalloc_oversized	O
(	O
n	long
,	O
s	long
)	O
||	O
(	O
!	O
(	O
p	pointer
=	O
malloc	function
(	O
n	long
*	O
s	long
)	O
)	O
&&	O
n	long
!=	O
0	int
)	O
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xnmalloc	function
(	O
size_t	long
n	long
,	O
size_t	long
s	long
)	O
{	O
return	O
xnmalloc_inline	function
(	O
n	long
,	O
s	long
)	O
;	O
}	O
void	O
*	O
xmalloc	function
(	O
size_t	long
n	long
)	O
{	O
return	O
xnmalloc_inline	function
(	O
n	long
,	O
1	int
)	O
;	O
}	O
static	O
inline	O
void	O
*	O
xnrealloc_inline	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
n	long
,	O
size_t	long
s	long
)	O
{	O
if	O
(	O
xalloc_oversized	O
(	O
n	long
,	O
s	long
)	O
||	O
(	O
!	O
(	O
p	pointer
=	O
realloc	function
(	O
p	pointer
,	O
n	long
*	O
s	pointer
)	O
)	O
&&	O
n	long
!=	O
0	int
)	O
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xnrealloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
n	long
,	O
size_t	long
s	long
)	O
{	O
return	O
xnrealloc_inline	function
(	O
p	pointer
,	O
n	long
,	O
s	long
)	O
;	O
}	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
n	long
)	O
{	O
return	O
xnrealloc_inline	function
(	O
p	pointer
,	O
n	long
,	O
1	int
)	O
;	O
}	O
static	O
inline	O
void	O
*	O
x2nrealloc_inline	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
*	O
pn	pointer
,	O
size_t	long
s	long
)	O
{	O
size_t	long
n	long
=	O
*	O
pn	pointer
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
if	O
(	O
!	O
n	long
)	O
{	O
enum	O
{	O
DEFAULT_MXFAST	int
=	O
64	int
}	O
;	O
n	int
=	O
DEFAULT_MXFAST	int
/	O
s	long
;	O
n	long
+=	O
!	O
n	long
;	O
}	O
}	O
else	O
{	O
if	O
(	O
SIZE_MAX	O
/	O
2	int
/	O
s	int
<	O
n	long
)	O
xalloc_die	function
(	O
)	O
;	O
n	long
*=	O
2	int
;	O
}	O
*	O
pn	pointer
=	O
n	long
;	O
return	O
xrealloc	function
(	O
p	pointer
,	O
n	long
*	O
s	pointer
)	O
;	O
}	O
void	O
*	O
x2nrealloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
*	O
pn	pointer
,	O
size_t	long
s	long
)	O
{	O
return	O
x2nrealloc_inline	function
(	O
p	pointer
,	O
pn	pointer
,	O
s	long
)	O
;	O
}	O
void	O
*	O
x2realloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
*	O
pn	pointer
)	O
{	O
return	O
x2nrealloc_inline	function
(	O
p	pointer
,	O
pn	pointer
,	O
1	int
)	O
;	O
}	O
void	O
*	O
xzalloc	function
(	O
size_t	long
s	long
)	O
{	O
return	O
memset	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
0	int
,	O
s	long
)	O
;	O
}	O
void	O
*	O
xcalloc	function
(	O
size_t	long
n	long
,	O
size_t	long
s	long
)	O
{	O
void	O
*	O
p	pointer
;	O
if	O
(	O
(	O
!	O
HAVE_GNU_CALLOC	int
&&	O
xalloc_oversized	O
(	O
n	long
,	O
s	long
)	O
)	O
||	O
(	O
!	O
(	O
p	pointer
=	O
calloc	function
(	O
n	long
,	O
s	long
)	O
)	O
&&	O
(	O
HAVE_GNU_CALLOC	int
||	O
n	long
!=	O
0	int
)	O
)	O
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xmemdup	function
(	O
void	O
const	O
*	O
p	pointer
,	O
size_t	long
s	long
)	O
{	O
return	O
memcpy	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
p	pointer
,	O
s	long
)	O
;	O
}	O
char	O
*	O
xstrdup	function
(	O
char	O
const	O
*	O
string	pointer
)	O
{	O
return	O
xmemdup	function
(	O
string	pointer
,	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
)	O
;	O
}	O
int	O
rpl_fcntl	function
(	O
int	O
fd	int
,	O
int	O
action	int
,	O
...	O
)	O
{	O
va_list	array
arg	array
;	O
int	O
result	int
=	O
-	O
1	int
;	O
va_start	O
(	O
arg	array
,	O
action	int
)	O
;	O
switch	O
(	O
action	int
)	O
{	O
case	O
F_DUPFD	int
:	O
{	O
int	O
target	int
=	O
va_arg	O
(	O
arg	array
,	O
int	O
)	O
;	O
if	O
(	O
target	int
<	O
0	int
||	O
getdtablesize	function
(	O
)	O
<=	O
target	int
)	O
errno	O
=	O
EINVAL	int
;	O
else	O
{	O
int	O
flags	int
=	O
fcntl	function
(	O
fd	int
,	O
F_GETFD	int
)	O
;	O
if	O
(	O
flags	int
<	O
0	int
)	O
{	O
result	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
result	int
=	O
fcntl	function
(	O
fd	int
,	O
action	int
,	O
target	int
)	O
;	O
if	O
(	O
0	int
<=	O
result	int
&&	O
fcntl	function
(	O
fd	int
,	O
F_SETFD	int
,	O
flags	int
)	O
==	O
-	O
1	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
close	function
(	O
result	int
)	O
;	O
result	int
=	O
-	O
1	int
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
}	O
break	O
;	O
}	O
case	O
F_DUPFD_CLOEXEC	int
:	O
{	O
int	O
target	int
=	O
va_arg	O
(	O
arg	array
,	O
int	O
)	O
;	O
static	O
int	O
have_dupfd_cloexec	int
=	O
GNULIB_defined_F_DUPFD_CLOEXEC	int
?	O
-	O
1	int
:	O
0	int
;	O
if	O
(	O
0	int
<=	O
have_dupfd_cloexec	int
)	O
{	O
result	int
=	O
fcntl	function
(	O
fd	int
,	O
action	int
,	O
target	int
)	O
;	O
if	O
(	O
0	int
<=	O
result	int
||	O
errno	O
!=	O
EINVAL	int
)	O
{	O
have_dupfd_cloexec	int
=	O
1	int
;	O
}	O
else	O
{	O
result	int
=	O
rpl_fcntl	function
(	O
fd	int
,	O
F_DUPFD	int
,	O
target	int
)	O
;	O
if	O
(	O
result	int
<	O
0	int
)	O
break	O
;	O
have_dupfd_cloexec	int
=	O
-	O
1	int
;	O
}	O
}	O
else	O
result	int
=	O
rpl_fcntl	function
(	O
fd	int
,	O
F_DUPFD	int
,	O
target	int
)	O
;	O
if	O
(	O
0	int
<=	O
result	int
&&	O
have_dupfd_cloexec	int
==	O
-	O
1	int
)	O
{	O
int	O
flags	int
=	O
fcntl	function
(	O
result	int
,	O
F_GETFD	int
)	O
;	O
if	O
(	O
flags	int
<	O
0	int
||	O
fcntl	function
(	O
result	int
,	O
F_SETFD	int
,	O
flags	int
|	O
FD_CLOEXEC	int
)	O
==	O
-	O
1	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
close	function
(	O
result	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
result	int
=	O
-	O
1	int
;	O
}	O
}	O
break	O
;	O
}	O
default	O
:	O
{	O
void	O
*	O
p	pointer
=	O
va_arg	O
(	O
arg	array
,	O
void	O
*	O
)	O
;	O
result	int
=	O
fcntl	function
(	O
fd	int
,	O
action	int
,	O
p	pointer
)	O
;	O
break	O
;	O
}	O
}	O
va_end	O
(	O
arg	array
)	O
;	O
return	O
result	int
;	O
}	O
enum	O
echo_mode	enum
{	O
ECHO_ECHO	int
,	O
ECHO_NULL	int
}	O
;	O
struct	O
dico_handle_struct	struct
{	O
enum	O
echo_mode	enum
mode	enum
;	O
char	O
*	O
prefix	pointer
;	O
size_t	long
prefix_len	long
;	O
}	O
;	O
static	O
int	O
echo_init	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
return	O
0	int
;	O
}	O
static	O
dico_handle_t	function
echo_init_db	function
(	O
const	O
char	O
*	O
dbname	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
null_mode	int
=	O
0	int
;	O
dico_handle_t	pointer
hp	pointer
;	O
char	O
*	O
prefix	pointer
=	O
NULL	O
;	O
struct	O
dico_option	struct
init_db_option	array
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
null	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
null_mode	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
prefix	pointer
)	O
,	O
dico_opt_string	int
,	O
&	O
prefix	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
dico_parseopt	function
(	O
init_db_option	pointer
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
NULL	O
;	O
hp	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
hp	pointer
)	O
)	O
;	O
if	O
(	O
hp	pointer
)	O
{	O
hp	pointer
->	O
mode	enum
=	O
null_mode	int
?	O
ECHO_NULL	int
:	O
ECHO_ECHO	int
;	O
if	O
(	O
prefix	pointer
)	O
{	O
hp	pointer
->	O
prefix	pointer
=	O
strdup	function
(	O
prefix	pointer
)	O
;	O
if	O
(	O
!	O
hp	pointer
->	O
prefix	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	pointer
)	O
;	O
free	function
(	O
hp	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
hp	pointer
->	O
prefix_len	long
=	O
strlen	function
(	O
prefix	pointer
)	O
;	O
}	O
else	O
{	O
hp	pointer
->	O
prefix	pointer
=	O
NULL	O
;	O
hp	pointer
->	O
prefix_len	int
=	O
0	int
;	O
}	O
}	O
else	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	pointer
)	O
;	O
return	O
hp	pointer
;	O
}	O
static	O
int	O
echo_free_db	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
free	function
(	O
hp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
echo_open	function
(	O
dico_handle_t	pointer
dp	pointer
)	O
{	O
return	O
0	int
;	O
}	O
static	O
int	O
echo_close	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
echo_info	function
(	O
dico_handle_t	pointer
ep	pointer
)	O
{	O
static	O
char	O
*	O
echo_info_str	array
[	O
2	int
]	O
=	O
{	O
"ECHO database.\n\nThis database echoes each query.\n"	pointer
,	O
"NULL database.\n\nThis database returns NULL (no result) to any match and define\nrequests.\n"	pointer
}	O
;	O
return	O
strdup	function
(	O
echo_info_str	array
[	O
ep	pointer
->	O
mode	pointer
]	O
)	O
;	O
}	O
static	O
char	O
*	O
echo_descr	function
(	O
dico_handle_t	pointer
ep	pointer
)	O
{	O
static	O
char	O
*	O
echo_descr_str	array
[	O
2	int
]	O
=	O
{	O
"GNU Dico ECHO database"	pointer
,	O
"GNU Dico NULL database"	pointer
}	O
;	O
char	O
*	O
res	pointer
;	O
if	O
(	O
ep	pointer
->	O
mode	enum
==	O
ECHO_ECHO	int
&&	O
ep	pointer
->	O
prefix	pointer
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
echo_descr_str	pointer
[	O
ep	pointer
->	O
mode	int
]	O
)	O
+	O
ep	pointer
->	O
prefix_len	long
+	O
11	int
;	O
res	pointer
=	O
malloc	function
(	O
len	long
)	O
;	O
if	O
(	O
res	O
)	O
snprintf	function
(	O
res	pointer
,	O
len	long
,	O
"%s (prefix %s)"	pointer
,	O
echo_descr_str	array
[	O
ep	pointer
->	O
mode	int
]	O
,	O
ep	pointer
->	O
prefix	array
)	O
;	O
}	O
else	O
res	pointer
=	O
strdup	function
(	O
echo_descr_str	array
[	O
ep	pointer
->	O
mode	int
]	O
)	O
;	O
return	O
res	pointer
;	O
}	O
static	O
dico_result_t	O
new_result	function
(	O
dico_handle_t	pointer
ep	pointer
,	O
char	O
const	O
*	O
word	pointer
)	O
{	O
char	O
*	O
res	pointer
=	O
malloc	function
(	O
strlen	function
(	O
word	pointer
)	O
+	O
ep	pointer
->	O
prefix_len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"not enough memory"	pointer
)	O
;	O
else	O
{	O
if	O
(	O
ep	pointer
->	O
prefix	pointer
)	O
memcpy	function
(	O
res	pointer
,	O
ep	pointer
->	O
prefix	pointer
,	O
ep	pointer
->	O
prefix_len	long
)	O
;	O
strcpy	function
(	O
res	pointer
+	O
ep	pointer
->	O
prefix_len	long
,	O
word	pointer
)	O
;	O
}	O
return	O
(	O
dico_result_t	pointer
)	O
res	pointer
;	O
}	O
static	O
dico_result_t	pointer
echo_match	function
(	O
dico_handle_t	pointer
ep	pointer
,	O
const	O
dico_strategy_t	pointer
strat	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
if	O
(	O
ep	pointer
->	O
mode	enum
==	O
ECHO_NULL	int
)	O
return	O
NULL	O
;	O
return	O
new_result	function
(	O
ep	pointer
,	O
word	pointer
)	O
;	O
}	O
static	O
dico_result_t	O
echo_define	function
(	O
dico_handle_t	pointer
ep	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
if	O
(	O
ep	pointer
->	O
mode	enum
==	O
ECHO_NULL	int
)	O
return	O
NULL	O
;	O
return	O
new_result	function
(	O
ep	pointer
,	O
word	pointer
)	O
;	O
}	O
static	O
int	O
echo_output_result	function
(	O
dico_result_t	pointer
rp	pointer
,	O
size_t	long
n	long
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
char	O
*	O
word	pointer
=	O
(	O
char	O
*	O
)	O
rp	pointer
;	O
dico_stream_write	function
(	O
str	pointer
,	O
word	pointer
,	O
strlen	function
(	O
word	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
size_t	long
echo_result_count	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
return	O
1	int
;	O
}	O
static	O
size_t	long
echo_compare_count	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
return	O
1	int
;	O
}	O
static	O
void	O
echo_free_result	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
free	function
(	O
rp	pointer
)	O
;	O
}	O
static	O
char	O
*	O
echo_mime_header	function
(	O
dico_handle_t	pointer
ep	pointer
)	O
{	O
return	O
strdup	function
(	O
"Content-Type: text/plain; charset=utf-8\nContent-Transfer-Encoding: 8bit\n"	pointer
)	O
;	O
}	O
struct	O
dico_database_module	struct
DICO_EXPORT	O
(	O
echo	pointer
,	O
module	O
)	O
=	O
{	O
.	O
dico_version	int
=	O
DICO_MODULE_VERSION	int
,	O
.	O
dico_capabilities	int
=	O
DICO_CAPA_NONE	pointer
,	O
.	O
dico_init	pointer
=	O
echo_init	pointer
,	O
.	O
dico_init_db	pointer
=	O
echo_init_db	pointer
,	O
.	O
dico_free_db	pointer
=	O
echo_free_db	pointer
,	O
.	O
dico_open	pointer
=	O
echo_open	pointer
,	O
.	O
dico_close	pointer
=	O
echo_close	pointer
,	O
.	O
dico_db_info	pointer
=	O
echo_info	pointer
,	O
.	O
dico_db_descr	pointer
=	O
echo_descr	pointer
,	O
.	O
dico_match	pointer
=	O
echo_match	pointer
,	O
.	O
dico_define	pointer
=	O
echo_define	pointer
,	O
.	O
dico_output_result	pointer
=	O
echo_output_result	pointer
,	O
.	O
dico_result_count	pointer
=	O
echo_result_count	pointer
,	O
.	O
dico_compare_count	pointer
=	O
echo_compare_count	pointer
,	O
.	O
dico_free_result	int
=	O
echo_free_result	pointer
,	O
.	O
dico_db_mime_header	pointer
=	O
echo_mime_header	int
}	O
;	O
static	O
char	O
*	O
pager	struct
;	O
static	O
char	O
*	O
get_pager_name	function
(	O
void	O
)	O
{	O
if	O
(	O
pager	struct
)	O
{	O
if	O
(	O
strcmp	function
(	O
pager	struct
,	O
"-"	pointer
)	O
==	O
0	int
)	O
return	O
NULL	O
;	O
return	O
pager	pointer
;	O
}	O
return	O
getenv	function
(	O
"PAGER"	pointer
)	O
;	O
}	O
void	O
ds_pager	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
char	O
*	O
p	pointer
=	O
get_pager_name	function
(	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
printf	function
(	O
"%s\n"	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
!	O
pager	pointer
)	O
printf	function
(	O
"%s\n"	pointer
,	O
_	O
(	O
"(Pager set from environment)"	pointer
)	O
)	O
;	O
}	O
}	O
else	O
xdico_assign_string	function
(	O
&	O
pager	struct
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
}	O
dico_stream_t	pointer
create_output_stream	function
(	O
void	O
)	O
{	O
return	O
dico_fd_stream_create	function
(	O
fileno	function
(	O
stdout	pointer
)	O
,	O
DICO_STREAM_WRITE	int
,	O
1	int
)	O
;	O
}	O
static	O
int	O
get_screen_lines	function
(	O
void	O
)	O
{	O
struct	O
winsize	struct
ws	pointer
;	O
ws	struct
.	O
ws_col	short
=	O
ws	struct
.	O
ws_row	short
=	O
0	int
;	O
if	O
(	O
(	O
ioctl	function
(	O
1	int
,	O
TIOCGWINSZ	int
,	O
(	O
char	O
*	O
)	O
&	O
ws	struct
)	O
<	O
0	int
)	O
||	O
ws	struct
.	O
ws_row	short
==	O
0	int
)	O
{	O
const	O
char	O
*	O
lines	pointer
=	O
getenv	function
(	O
"LINES"	pointer
)	O
;	O
if	O
(	O
lines	int
)	O
ws	struct
.	O
ws_row	enum
=	O
strtol	function
(	O
lines	O
,	O
NULL	O
,	O
10	int
)	O
;	O
}	O
return	O
ws	struct
.	O
ws_row	short
;	O
}	O
struct	O
pfile_stream	struct
{	O
FILE	struct
*	O
fp	pointer
;	O
}	O
;	O
static	O
int	O
fp_write	function
(	O
void	O
*	O
data	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
size_t	long
*	O
pret	pointer
)	O
{	O
struct	O
pfile_stream	struct
*	O
p	pointer
=	O
data	pointer
;	O
*	O
pret	pointer
=	O
fwrite	function
(	O
buf	pointer
,	O
1	int
,	O
size	long
,	O
p	pointer
->	O
fp	pointer
)	O
;	O
return	O
ferror	function
(	O
p	pointer
->	O
fp	pointer
)	O
;	O
}	O
static	O
int	O
fp_close	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
pfile_stream	struct
*	O
p	pointer
=	O
data	pointer
;	O
pclose	function
(	O
p	pointer
->	O
fp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
dico_stream_t	pointer
create_pfile_stream	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
dico_stream_t	pointer
str	pointer
;	O
struct	O
pfile_stream	struct
*	O
s	pointer
;	O
s	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
s	pointer
)	O
)	O
;	O
s	pointer
->	O
fp	pointer
=	O
fp	pointer
;	O
if	O
(	O
dico_stream_create	function
(	O
&	O
str	pointer
,	O
DICO_STREAM_WRITE	int
,	O
s	pointer
)	O
)	O
xalloc_die	function
(	O
)	O
;	O
dico_stream_set_write	function
(	O
str	pointer
,	O
fp_write	function
)	O
;	O
dico_stream_set_close	function
(	O
str	pointer
,	O
fp_close	function
)	O
;	O
return	O
str	pointer
;	O
}	O
dico_stream_t	pointer
create_pager_stream	function
(	O
size_t	long
nlines	long
)	O
{	O
char	O
*	O
pager	pointer
=	O
get_pager_name	function
(	O
)	O
;	O
FILE	struct
*	O
fp	pointer
;	O
if	O
(	O
!	O
pager	struct
||	O
!	O
pager	pointer
[	O
0	int
]	O
||	O
!	O
isatty	function
(	O
fileno	function
(	O
stdout	pointer
)	O
)	O
||	O
nlines	int
<	O
get_screen_lines	function
(	O
)	O
)	O
return	O
create_output_stream	function
(	O
)	O
;	O
fp	pointer
=	O
popen	function
(	O
pager	struct
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
return	O
create_output_stream	function
(	O
)	O
;	O
return	O
create_pfile_stream	function
(	O
fp	pointer
)	O
;	O
}	O
static	O
struct	O
parser_tab	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
grecs_parser_t	pointer
parser	pointer
;	O
}	O
parser_tab	struct
[	O
]	O
=	O
{	O
{	O
"GRECS"	pointer
,	O
grecs_grecs_parser	function
}	O
,	O
{	O
"PATH"	pointer
,	O
grecs_path_parser	function
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
grecs_enumerate_parsers	function
(	O
int	O
(	O
*	O
fun	pointer
)	O
(	O
const	O
char	O
*	O
,	O
grecs_parser_t	pointer
,	O
void	O
*	O
)	O
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
parser_tab	struct
*	O
pt	pointer
;	O
int	O
rc	int
=	O
0	int
;	O
for	O
(	O
pt	pointer
=	O
parser_tab	struct
;	O
rc	int
==	O
0	int
&&	O
pt	pointer
->	O
name	pointer
;	O
pt	pointer
++	O
)	O
rc	int
=	O
fun	pointer
(	O
pt	pointer
->	O
name	pointer
,	O
pt	pointer
->	O
parser	pointer
,	O
data	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
grecs_parser_t	pointer
grecs_get_parser_by_type	function
(	O
const	O
char	O
*	O
type	int
)	O
{	O
struct	O
parser_tab	struct
*	O
pt	pointer
;	O
for	O
(	O
pt	pointer
=	O
parser_tab	struct
;	O
pt	pointer
->	O
name	pointer
;	O
pt	pointer
++	O
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
pt	pointer
->	O
name	pointer
,	O
type	int
)	O
==	O
0	int
)	O
return	O
pt	pointer
->	O
parser	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
node_list	struct
{	O
struct	O
grecs_node	struct
*	O
head	pointer
,	O
*	O
tail	pointer
;	O
}	O
;	O
static	O
void	O
node_list_init	function
(	O
struct	O
node_list	struct
*	O
list	pointer
,	O
struct	O
grecs_node	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
node	pointer
)	O
{	O
list	pointer
->	O
head	pointer
=	O
node	pointer
;	O
while	O
(	O
node	pointer
->	O
next	pointer
)	O
node	pointer
=	O
node	pointer
->	O
next	pointer
;	O
list	pointer
->	O
tail	pointer
=	O
node	pointer
;	O
}	O
else	O
list	pointer
->	O
head	pointer
=	O
list	pointer
->	O
tail	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
node_list_add	function
(	O
struct	O
node_list	struct
*	O
list	pointer
,	O
struct	O
grecs_node	struct
*	O
node	pointer
)	O
{	O
node	pointer
->	O
next	pointer
=	O
NULL	O
;	O
node	pointer
->	O
prev	pointer
=	O
list	pointer
->	O
tail	pointer
;	O
if	O
(	O
list	pointer
->	O
tail	pointer
)	O
list	pointer
->	O
tail	pointer
->	O
next	pointer
=	O
node	pointer
;	O
else	O
list	pointer
->	O
head	pointer
=	O
node	pointer
;	O
list	pointer
->	O
tail	pointer
=	O
node	pointer
;	O
}	O
static	O
void	O
node_list_join	function
(	O
struct	O
node_list	struct
*	O
a	pointer
,	O
struct	O
node_list	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
!	O
b	pointer
->	O
head	pointer
)	O
return	O
;	O
b	pointer
->	O
head	pointer
->	O
prev	pointer
=	O
a	pointer
->	O
tail	pointer
;	O
if	O
(	O
a	pointer
->	O
tail	pointer
)	O
a	pointer
->	O
tail	pointer
->	O
next	pointer
=	O
b	pointer
->	O
head	pointer
;	O
else	O
a	pointer
->	O
head	pointer
=	O
b	pointer
->	O
head	pointer
;	O
a	pointer
->	O
tail	pointer
=	O
b	pointer
->	O
tail	pointer
;	O
}	O
static	O
void	O
_qsort_nodelist	function
(	O
struct	O
node_list	struct
*	O
list	pointer
,	O
int	O
(	O
*	O
compare	pointer
)	O
(	O
struct	O
grecs_node	struct
const	O
*	O
,	O
struct	O
grecs_node	struct
const	O
*	O
)	O
)	O
{	O
struct	O
grecs_node	struct
*	O
cur	pointer
,	O
*	O
middle	pointer
;	O
struct	O
node_list	struct
high_list	struct
,	O
low_list	struct
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
list	pointer
->	O
head	pointer
)	O
return	O
;	O
cur	pointer
=	O
list	pointer
->	O
head	pointer
;	O
do	O
{	O
cur	pointer
=	O
cur	pointer
->	O
next	pointer
;	O
if	O
(	O
!	O
cur	pointer
)	O
return	O
;	O
}	O
while	O
(	O
(	O
rc	int
=	O
compare	pointer
(	O
list	pointer
->	O
head	pointer
,	O
cur	pointer
)	O
)	O
==	O
0	int
)	O
;	O
middle	pointer
=	O
(	O
rc	int
>	O
0	int
)	O
?	O
cur	pointer
:	O
list	pointer
->	O
head	pointer
;	O
node_list_init	function
(	O
&	O
low_list	struct
,	O
NULL	O
)	O
;	O
node_list_init	function
(	O
&	O
high_list	struct
,	O
NULL	O
)	O
;	O
for	O
(	O
cur	pointer
=	O
list	pointer
->	O
head	pointer
;	O
cur	pointer
;	O
)	O
{	O
struct	O
grecs_node	struct
*	O
next	pointer
=	O
cur	pointer
->	O
next	pointer
;	O
cur	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
compare	pointer
(	O
middle	pointer
,	O
cur	pointer
)	O
<	O
0	int
)	O
node_list_add	function
(	O
&	O
high_list	struct
,	O
cur	pointer
)	O
;	O
else	O
node_list_add	function
(	O
&	O
low_list	struct
,	O
cur	pointer
)	O
;	O
cur	pointer
=	O
next	pointer
;	O
}	O
if	O
(	O
!	O
low_list	struct
.	O
head	pointer
)	O
low_list	struct
=	O
high_list	struct
;	O
else	O
if	O
(	O
high_list	struct
.	O
head	pointer
)	O
{	O
_qsort_nodelist	function
(	O
&	O
low_list	struct
,	O
compare	pointer
)	O
;	O
_qsort_nodelist	function
(	O
&	O
high_list	struct
,	O
compare	pointer
)	O
;	O
node_list_join	function
(	O
&	O
low_list	struct
,	O
&	O
high_list	struct
)	O
;	O
}	O
list	pointer
->	O
head	pointer
=	O
low_list	struct
.	O
head	pointer
;	O
list	pointer
->	O
tail	pointer
=	O
low_list	struct
.	O
tail	pointer
;	O
}	O
struct	O
grecs_node	struct
*	O
grecs_nodelist_sort	function
(	O
struct	O
grecs_node	struct
*	O
node	pointer
,	O
int	O
(	O
*	O
compare	pointer
)	O
(	O
struct	O
grecs_node	struct
const	O
*	O
,	O
struct	O
grecs_node	struct
const	O
*	O
)	O
)	O
{	O
struct	O
node_list	struct
list	pointer
;	O
node_list_init	function
(	O
&	O
list	pointer
,	O
node	pointer
)	O
;	O
_qsort_nodelist	function
(	O
&	O
list	pointer
,	O
compare	pointer
)	O
;	O
return	O
list	pointer
.	O
head	pointer
;	O
}	O
void	O
grecs_tree_sort	function
(	O
struct	O
grecs_node	struct
*	O
node	pointer
,	O
int	O
(	O
*	O
compare	pointer
)	O
(	O
struct	O
grecs_node	struct
const	O
*	O
,	O
struct	O
grecs_node	struct
const	O
*	O
)	O
)	O
{	O
if	O
(	O
node	pointer
&&	O
node	pointer
->	O
down	pointer
)	O
{	O
node	pointer
->	O
down	pointer
=	O
grecs_nodelist_sort	function
(	O
node	pointer
->	O
down	pointer
,	O
compare	pointer
)	O
;	O
for	O
(	O
node	pointer
=	O
node	pointer
->	O
down	pointer
;	O
node	pointer
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
grecs_tree_sort	function
(	O
node	pointer
,	O
compare	pointer
)	O
;	O
}	O
}	O
static	O
struct	O
grecs_symtab	O
*	O
text_table	pointer
;	O
char	O
*	O
grecs_install_text	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
struct	O
grecs_syment	struct
key	pointer
;	O
struct	O
grecs_syment	struct
*	O
ent	pointer
;	O
int	O
install	pointer
=	O
1	int
;	O
if	O
(	O
!	O
text_table	pointer
)	O
{	O
text_table	pointer
=	O
grecs_symtab_create_default	function
(	O
sizeof	O
(	O
struct	O
grecs_syment	struct
)	O
)	O
;	O
if	O
(	O
!	O
text_table	pointer
)	O
grecs_alloc_die	function
(	O
)	O
;	O
}	O
key	pointer
.	O
name	pointer
=	O
(	O
char	O
*	O
)	O
str	pointer
;	O
ent	pointer
=	O
grecs_symtab_lookup_or_install	function
(	O
text_table	pointer
,	O
&	O
key	pointer
,	O
&	O
install	pointer
)	O
;	O
if	O
(	O
!	O
ent	pointer
)	O
grecs_alloc_die	function
(	O
)	O
;	O
return	O
ent	pointer
->	O
name	pointer
;	O
}	O
void	O
grecs_destroy_text	function
(	O
)	O
{	O
grecs_symtab_free	function
(	O
text_table	pointer
)	O
;	O
}	O
struct	O
grecs_symtab	O
*	O
grecs_text_table	function
(	O
)	O
{	O
struct	O
grecs_symtab	O
*	O
tmp	pointer
=	O
text_table	pointer
;	O
text_table	pointer
=	O
NULL	O
;	O
return	O
tmp	pointer
;	O
}	O
struct	O
list_helper	struct
{	O
FILE	struct
*	O
file	pointer
;	O
int	O
delim	int
;	O
}	O
;	O
static	O
int	O
list_parser_types	function
(	O
const	O
char	O
*	O
name	pointer
,	O
grecs_parser_t	pointer
parser	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
list_helper	struct
*	O
p	pointer
=	O
data	pointer
;	O
fprintf	function
(	O
p	pointer
->	O
file	pointer
,	O
"%c%s"	pointer
,	O
p	pointer
->	O
delim	int
,	O
name	pointer
)	O
;	O
p	pointer
->	O
delim	int
=	O
'|'	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
usage	function
(	O
const	O
char	O
*	O
arg	struct
,	O
FILE	struct
*	O
fp	pointer
,	O
int	O
code	int
)	O
{	O
struct	O
list_helper	struct
lh	struct
;	O
fprintf	function
(	O
fp	pointer
,	O
"usage: %s [-h] [-list[=type]] [-locus] [-delim=char] [-reduce] [-sort]\n"	pointer
,	O
arg	struct
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"    [-nopath] [-novalue] [-type"	pointer
)	O
;	O
lh	struct
.	O
file	pointer
=	O
fp	pointer
;	O
lh	struct
.	O
delim	int
=	O
'='	O
;	O
grecs_enumerate_parsers	function
(	O
list_parser_types	function
,	O
&	O
lh	struct
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"] [-Idir] [-include=dir] file [file...]\n"	pointer
)	O
;	O
exit	function
(	O
code	int
)	O
;	O
}	O
static	O
int	O
node_ident_cmp	function
(	O
struct	O
grecs_node	struct
const	O
*	O
a	pointer
,	O
struct	O
grecs_node	struct
const	O
*	O
b	pointer
)	O
{	O
return	O
strcmp	function
(	O
a	pointer
->	O
ident	pointer
,	O
b	pointer
->	O
ident	pointer
)	O
;	O
}	O
int	O
list_parser	function
(	O
const	O
char	O
*	O
name	pointer
,	O
grecs_parser_t	pointer
parser	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
printf	function
(	O
"%s\n"	pointer
,	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
find_parser	function
(	O
const	O
char	O
*	O
name	pointer
,	O
grecs_parser_t	pointer
parser	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
name	pointer
,	O
(	O
char	O
*	O
)	O
data	pointer
)	O
==	O
0	int
)	O
exit	function
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
set_parser	function
(	O
const	O
char	O
*	O
arg	struct
)	O
{	O
grecs_parser_t	pointer
p	pointer
=	O
grecs_get_parser_by_type	function
(	O
arg	struct
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
grecs_parser_fun	pointer
=	O
p	pointer
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
progname	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
char	O
*	O
file	pointer
=	O
NULL	O
;	O
struct	O
grecs_node	struct
*	O
tree	pointer
;	O
int	O
flags	int
=	O
GRECS_NODE_FLAG_DEFAULT	O
;	O
int	O
reduce	int
=	O
0	int
;	O
int	O
sort	int
=	O
0	int
;	O
grecs_parser_options	int
=	O
0	int
;	O
while	O
(	O
--	O
argc	int
)	O
{	O
char	O
*	O
arg	struct
=	O
*	O
++	O
argv	pointer
;	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-locus"	pointer
)	O
==	O
0	int
)	O
flags	int
|=	O
GRECS_NODE_FLAG_LOCUS	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-nopath"	pointer
)	O
==	O
0	int
)	O
flags	int
&=	O
~	O
GRECS_NODE_FLAG_PATH	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-novalue"	pointer
)	O
==	O
0	int
)	O
flags	int
&=	O
~	O
GRECS_NODE_FLAG_VALUE	int
;	O
else	O
if	O
(	O
strncmp	function
(	O
arg	struct
,	O
"-delim="	pointer
,	O
7	int
)	O
==	O
0	int
)	O
flags	int
|=	O
arg	struct
[	O
7	int
]	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-reduce"	pointer
)	O
==	O
0	int
)	O
reduce	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-sort"	pointer
)	O
==	O
0	int
)	O
sort	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-h"	pointer
)	O
==	O
0	int
)	O
usage	function
(	O
progname	pointer
,	O
stdout	pointer
,	O
0	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-list"	pointer
)	O
==	O
0	int
)	O
{	O
grecs_enumerate_parsers	function
(	O
list_parser	function
,	O
NULL	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
arg	struct
,	O
"-list="	pointer
,	O
6	int
)	O
==	O
0	int
)	O
{	O
grecs_enumerate_parsers	function
(	O
find_parser	function
,	O
arg	struct
+	O
6	int
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
arg	struct
,	O
"-type="	pointer
,	O
6	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
set_parser	function
(	O
arg	struct
+	O
6	int
)	O
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
arg	struct
,	O
"-I"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
grecs_preproc_add_include_dir	function
(	O
arg	struct
+	O
2	int
)	O
;	O
else	O
if	O
(	O
strncmp	function
(	O
arg	struct
,	O
"-include="	pointer
,	O
9	int
)	O
==	O
0	int
)	O
grecs_preproc_add_include_dir	function
(	O
arg	struct
+	O
9	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-x"	pointer
)	O
==	O
0	int
)	O
grecs_gram_trace	function
(	O
1	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-X"	pointer
)	O
==	O
0	int
)	O
grecs_lex_trace	function
(	O
1	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-strcat"	pointer
)	O
==	O
0	int
)	O
grecs_parser_options	int
|=	O
GRECS_OPTION_QUOTED_STRING_CONCAT	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-stradj"	pointer
)	O
==	O
0	int
)	O
grecs_parser_options	int
|=	O
GRECS_OPTION_ADJUST_STRING_LOCATIONS	int
;	O
else	O
if	O
(	O
arg	struct
[	O
0	int
]	O
==	O
'-'	O
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
,	O
1	int
)	O
;	O
else	O
{	O
file	pointer
=	O
arg	struct
;	O
--	O
argc	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
grecs_parser_fun	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: requested type not supported"	pointer
,	O
progname	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
if	O
(	O
!	O
file	pointer
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
,	O
1	int
)	O
;	O
tree	pointer
=	O
grecs_parse	function
(	O
file	pointer
)	O
;	O
if	O
(	O
!	O
tree	pointer
)	O
exit	function
(	O
1	int
)	O
;	O
for	O
(	O
;	O
argc	int
;	O
argc	int
--	O
)	O
{	O
char	O
*	O
arg	struct
=	O
*	O
++	O
argv	pointer
;	O
struct	O
grecs_node	struct
*	O
node	pointer
=	O
grecs_parse	function
(	O
arg	struct
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
exit	function
(	O
1	int
)	O
;	O
if	O
(	O
grecs_tree_join	function
(	O
tree	pointer
,	O
node	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"join failed\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
grecs_tree_free	function
(	O
node	pointer
)	O
;	O
}	O
if	O
(	O
reduce	int
)	O
grecs_tree_reduce	function
(	O
tree	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
sort	int
)	O
grecs_tree_sort	function
(	O
tree	pointer
,	O
node_ident_cmp	function
)	O
;	O
grecs_print_node	function
(	O
tree	pointer
,	O
flags	int
,	O
stdout	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
grecs_tree_free	function
(	O
tree	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
void	O
*	O
dico_bsearch	function
(	O
void	O
*	O
key	pointer
,	O
const	O
void	O
*	O
base	pointer
,	O
size_t	long
nelem	long
,	O
size_t	long
elsize	int
,	O
int	O
(	O
*	O
comp	pointer
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
closure	pointer
)	O
{	O
char	O
const	O
*	O
l	pointer
=	O
(	O
char	O
const	O
*	O
)	O
base	pointer
;	O
char	O
const	O
*	O
r	pointer
=	O
l	long
+	O
nelem	long
*	O
elsize	pointer
;	O
char	O
const	O
*	O
s	pointer
;	O
void	O
*	O
found	pointer
=	O
NULL	O
;	O
while	O
(	O
l	int
<	O
r	pointer
)	O
{	O
s	pointer
=	O
l	long
+	O
(	O
(	O
(	O
r	int
-	O
l	long
)	O
/	O
elsize	int
)	O
>>	O
1	int
)	O
*	O
elsize	O
;	O
int	O
rc	int
=	O
comp	function
(	O
key	pointer
,	O
s	pointer
,	O
closure	pointer
)	O
;	O
if	O
(	O
rc	int
>	O
0	int
)	O
l	pointer
=	O
s	pointer
+	O
elsize	int
;	O
else	O
{	O
if	O
(	O
rc	int
==	O
0	int
)	O
found	pointer
=	O
(	O
void	O
*	O
)	O
s	pointer
;	O
r	pointer
=	O
s	pointer
;	O
}	O
}	O
return	O
found	pointer
;	O
}	O
struct	O
log_stream	struct
{	O
int	O
level	int
;	O
}	O
;	O
static	O
int	O
log_write	function
(	O
void	O
*	O
data	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
size_t	long
*	O
pret	pointer
)	O
{	O
struct	O
log_stream	struct
*	O
p	pointer
=	O
data	pointer
;	O
if	O
(	O
pret	pointer
)	O
*	O
pret	pointer
=	O
size	long
;	O
while	O
(	O
size	long
>	O
0	int
&&	O
(	O
buf	pointer
[	O
size	long
-	O
1	int
]	O
==	O
'\n'	O
||	O
buf	pointer
[	O
size	long
-	O
1	int
]	O
==	O
'\r'	O
)	O
)	O
size	long
--	O
;	O
if	O
(	O
size	long
)	O
dico_log	function
(	O
p	pointer
->	O
level	int
,	O
0	int
,	O
"%.*s"	pointer
,	O
(	O
int	O
)	O
size	long
,	O
buf	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
log_destroy	function
(	O
void	O
*	O
data	pointer
)	O
{	O
free	function
(	O
data	pointer
)	O
;	O
return	O
0	int
;	O
}	O
dico_stream_t	pointer
dico_log_stream_create	function
(	O
int	O
level	int
)	O
{	O
struct	O
log_stream	struct
*	O
p	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
dico_stream_t	pointer
stream	pointer
;	O
if	O
(	O
!	O
p	pointer
||	O
dico_stream_create	function
(	O
&	O
stream	pointer
,	O
DICO_STREAM_WRITE	int
,	O
p	pointer
)	O
)	O
return	O
NULL	O
;	O
dico_stream_set_write	function
(	O
stream	pointer
,	O
log_write	function
)	O
;	O
dico_stream_set_destroy	function
(	O
stream	pointer
,	O
log_destroy	function
)	O
;	O
dico_stream_set_buffer	function
(	O
stream	pointer
,	O
dico_buffer_line	int
,	O
1024	int
)	O
;	O
p	pointer
->	O
level	int
=	O
level	int
;	O
return	O
stream	pointer
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
filename	pointer
=	O
NULL	O
;	O
size_t	long
sz	long
;	O
dico_stream_t	pointer
in	pointer
,	O
out	pointer
,	O
s	pointer
;	O
char	O
buf	pointer
[	O
512	int
]	O
;	O
int	O
flags	int
=	O
0	int
;	O
size_t	long
in_bufsize	long
=	O
1024	int
,	O
out_bufsize	int
=	O
1024	int
;	O
int	O
buffered	int
;	O
dico_set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
while	O
(	O
--	O
argc	int
)	O
{	O
char	O
*	O
arg	pointer
=	O
*	O
++	O
argv	pointer
;	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"-file="	pointer
,	O
6	int
)	O
==	O
0	int
)	O
filename	pointer
=	O
arg	pointer
+	O
6	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"-in"	pointer
)	O
==	O
0	int
)	O
flags	int
|=	O
CRLF_IN	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"-out"	pointer
)	O
==	O
0	int
)	O
flags	int
|=	O
CRLF_OUT	int
;	O
else	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"-bufsize="	pointer
,	O
9	int
)	O
==	O
0	int
)	O
{	O
in_bufsize	int
=	O
out_bufsize	int
=	O
atoi	function
(	O
arg	pointer
+	O
9	int
)	O
;	O
buffered	int
=	O
CRLF_IN	int
|	O
CRLF_OUT	int
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"-outbufsize="	pointer
,	O
12	int
)	O
==	O
0	int
)	O
{	O
out_bufsize	int
=	O
atoi	function
(	O
arg	pointer
+	O
12	int
)	O
;	O
buffered	int
|=	O
CRLF_OUT	int
;	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"-inbufsize="	pointer
,	O
11	int
)	O
==	O
0	int
)	O
in_bufsize	int
|=	O
atoi	function
(	O
arg	pointer
+	O
11	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"--"	pointer
)	O
==	O
0	int
)	O
{	O
--	O
argc	int
;	O
++	O
argv	pointer
;	O
}	O
else	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"unknown option '%s'"	pointer
,	O
arg	pointer
)	O
;	O
return	O
1	int
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
argc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Usage: %s [-file=S]\n"	pointer
,	O
dico_program_name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
filename	pointer
)	O
{	O
in	pointer
=	O
dico_mapfile_stream_create	function
(	O
filename	pointer
,	O
DICO_STREAM_READ	int
)	O
;	O
if	O
(	O
!	O
in	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
"cannot create stream `%s'"	pointer
,	O
filename	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
in	pointer
=	O
dico_fd_stream_create	function
(	O
0	int
,	O
DICO_STREAM_READ	int
,	O
1	int
)	O
;	O
if	O
(	O
!	O
in	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
"cannot create stdin stream"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
rc	int
=	O
dico_stream_open	function
(	O
in	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"cannot open stream `%s': %s"	pointer
,	O
filename	pointer
?	O
filename	pointer
:	O
"<stdin>"	pointer
,	O
dico_stream_strerror	function
(	O
in	pointer
,	O
rc	int
)	O
)	O
;	O
return	O
2	int
;	O
}	O
if	O
(	O
flags	int
&	O
CRLF_IN	int
)	O
{	O
s	pointer
=	O
dico_crlf_stream	function
(	O
in	pointer
,	O
DICO_STREAM_READ	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
"cannot create filter stream"	pointer
)	O
;	O
return	O
2	int
;	O
}	O
if	O
(	O
filename	pointer
||	O
(	O
buffered	int
&	O
CRLF_IN	int
)	O
)	O
dico_stream_set_buffer	function
(	O
s	pointer
,	O
dico_buffer_full	pointer
,	O
in_bufsize	pointer
)	O
;	O
in	pointer
=	O
s	pointer
;	O
}	O
out	pointer
=	O
dico_fd_stream_create	function
(	O
1	int
,	O
DICO_STREAM_WRITE	int
,	O
1	int
)	O
;	O
if	O
(	O
!	O
out	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
"cannot create stdout stream"	pointer
)	O
;	O
return	O
2	int
;	O
}	O
rc	int
=	O
dico_stream_open	function
(	O
out	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"cannot open stream `%s': %s"	pointer
,	O
"<stdout>"	pointer
,	O
dico_stream_strerror	function
(	O
out	pointer
,	O
rc	int
)	O
)	O
;	O
return	O
2	int
;	O
}	O
if	O
(	O
flags	int
&	O
CRLF_OUT	int
)	O
{	O
s	pointer
=	O
dico_crlf_stream	function
(	O
out	pointer
,	O
DICO_STREAM_WRITE	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
"cannot create filter stream"	pointer
)	O
;	O
return	O
2	int
;	O
}	O
if	O
(	O
filename	pointer
||	O
(	O
buffered	int
&	O
CRLF_OUT	int
)	O
)	O
dico_stream_set_buffer	function
(	O
s	pointer
,	O
dico_buffer_full	pointer
,	O
out_bufsize	pointer
)	O
;	O
out	pointer
=	O
s	pointer
;	O
}	O
while	O
(	O
(	O
rc	int
=	O
dico_stream_read	function
(	O
in	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
&	O
sz	long
)	O
)	O
==	O
0	int
&&	O
sz	long
)	O
{	O
rc	int
=	O
dico_stream_write	function
(	O
out	pointer
,	O
buf	pointer
,	O
sz	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"write error: %s"	pointer
,	O
dico_stream_strerror	function
(	O
out	pointer
,	O
rc	int
)	O
)	O
;	O
return	O
2	int
;	O
}	O
}	O
dico_stream_close	function
(	O
out	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
c_strncasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
,	O
size_t	long
n	long
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
||	O
n	long
==	O
0	int
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
--	O
n	long
==	O
0	int
||	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
int	O
fpurge	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
__fpurge	function
(	O
fp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
fseeko	function
(	O
FILE	struct
*	O
fp	pointer
,	O
off_t	long
offset	long
,	O
int	O
whence	int
)	O
{	O
if	O
(	O
fp	pointer
->	O
_IO_read_end	pointer
==	O
fp	pointer
->	O
_IO_read_ptr	pointer
&&	O
fp	pointer
->	O
_IO_write_ptr	pointer
==	O
fp	pointer
->	O
_IO_write_base	pointer
&&	O
fp	pointer
->	O
_IO_save_base	pointer
==	O
NULL	O
)	O
{	O
off_t	long
pos	long
=	O
lseek	function
(	O
fileno	function
(	O
fp	pointer
)	O
,	O
offset	long
,	O
whence	int
)	O
;	O
if	O
(	O
pos	long
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
fp	pointer
->	O
_flags	int
&=	O
~	O
_IO_EOF_SEEN	int
;	O
fp	pointer
->	O
_offset	long
=	O
pos	long
;	O
return	O
0	int
;	O
}	O
return	O
fseeko	function
(	O
fp	pointer
,	O
offset	long
,	O
whence	int
)	O
;	O
}	O
size_t	long
rpl_mbrtowc	function
(	O
wchar_t	int
*	O
pwc	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
size_t	long
n	long
,	O
mbstate_t	struct
*	O
ps	pointer
)	O
{	O
size_t	long
ret	long
;	O
wchar_t	int
wc	int
;	O
if	O
(	O
!	O
pwc	pointer
)	O
pwc	pointer
=	O
&	O
wc	int
;	O
ret	long
=	O
mbrtowc	function
(	O
pwc	pointer
,	O
s	pointer
,	O
n	long
,	O
ps	pointer
)	O
;	O
if	O
(	O
(	O
size_t	long
)	O
-	O
2	int
<=	O
ret	long
&&	O
n	long
!=	O
0	int
&&	O
!	O
hard_locale	function
(	O
LC_CTYPE	O
)	O
)	O
{	O
unsigned	O
char	O
uc	char
=	O
*	O
s	pointer
;	O
*	O
pwc	pointer
=	O
uc	char
;	O
return	O
1	int
;	O
}	O
return	O
ret	long
;	O
}	O

int	O
PRINTF_FETCHARGS	O
(	O
va_list	array
args	array
,	O
arguments	struct
*	O
a	union
)	O
{	O
size_t	long
i	long
;	O
argument	struct
*	O
ap	pointer
;	O
for	O
(	O
i	long
=	O
0	int
,	O
ap	pointer
=	O
&	O
a	union
->	O
arg	pointer
[	O
0	int
]	O
;	O
i	long
<	O
a	union
->	O
count	long
;	O
i	long
++	O
,	O
ap	pointer
++	O
)	O
switch	O
(	O
ap	pointer
->	O
type	enum
)	O
{	O
case	O
TYPE_SCHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_schar	char
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_UCHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_uchar	char
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_SHORT	int
:	O
ap	pointer
->	O
a	union
.	O
a_short	short
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_USHORT	int
:	O
ap	pointer
->	O
a	union
.	O
a_ushort	short
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_INT	int
:	O
ap	pointer
->	O
a	union
.	O
a_int	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_UINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_uint	int
=	O
va_arg	O
(	O
args	array
,	O
unsigned	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_LONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_longint	long
=	O
va_arg	O
(	O
args	array
,	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_ULONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_ulongint	long
=	O
va_arg	O
(	O
args	array
,	O
unsigned	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_LONGLONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_longlongint	long long
=	O
va_arg	O
(	O
args	array
,	O
long	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_ULONGLONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_ulonglongint	long long
=	O
va_arg	O
(	O
args	array
,	O
unsigned	O
long	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_DOUBLE	int
:	O
ap	pointer
->	O
a	union
.	O
a_double	double
=	O
va_arg	O
(	O
args	array
,	O
double	O
)	O
;	O
break	O
;	O
case	O
TYPE_LONGDOUBLE	int
:	O
ap	pointer
->	O
a	union
.	O
a_longdouble	bool
=	O
va_arg	O
(	O
args	array
,	O
long	O
double	O
)	O
;	O
break	O
;	O
case	O
TYPE_CHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_char	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_WIDE_CHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_wide_char	int
=	O
(	O
sizeof	O
(	O
wint_t	int
)	O
<	O
sizeof	O
(	O
int	O
)	O
?	O
(	O
wint_t	int
)	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
:	O
va_arg	O
(	O
args	array
,	O
wint_t	int
)	O
)	O
;	O
break	O
;	O
case	O
TYPE_STRING	int
:	O
ap	pointer
->	O
a	union
.	O
a_string	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
char	O
*	O
)	O
;	O
if	O
(	O
ap	pointer
->	O
a	union
.	O
a_string	pointer
==	O
NULL	O
)	O
ap	pointer
->	O
a	union
.	O
a_string	pointer
=	O
"(NULL)"	pointer
;	O
break	O
;	O
case	O
TYPE_WIDE_STRING	int
:	O
ap	pointer
->	O
a	union
.	O
a_wide_string	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
wchar_t	int
*	O
)	O
;	O
if	O
(	O
ap	pointer
->	O
a	union
.	O
a_wide_string	pointer
==	O
NULL	O
)	O
{	O
static	O
const	O
wchar_t	int
wide_null_string	array
[	O
]	O
=	O
{	O
(	O
wchar_t	int
)	O
'('	O
,	O
(	O
wchar_t	int
)	O
'N'	O
,	O
(	O
wchar_t	int
)	O
'U'	O
,	O
(	O
wchar_t	int
)	O
'L'	O
,	O
(	O
wchar_t	int
)	O
'L'	O
,	O
(	O
wchar_t	int
)	O
')'	O
,	O
(	O
wchar_t	int
)	O
0	int
}	O
;	O
ap	pointer
->	O
a	union
.	O
a_wide_string	pointer
=	O
wide_null_string	array
;	O
}	O
break	O
;	O
case	O
TYPE_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
void	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_SCHAR_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_schar_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
signed	O
char	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_SHORT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_short_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
short	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_INT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_int_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
int	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_LONGINT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_longint_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
long	O
int	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_LONGLONGINT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_longlongint_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
long	O
long	O
int	O
*	O
)	O
;	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
typedef	O
int	O
dummy	int
;	O
enum	O
{	O
HAVE_GNU_CALLOC	int
=	O
1	int
}	O
;	O
void	O
*	O
xmalloc	function
(	O
size_t	long
n	long
)	O
{	O
void	O
*	O
p	pointer
=	O
malloc	function
(	O
n	long
)	O
;	O
if	O
(	O
!	O
p	pointer
&&	O
n	long
!=	O
0	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
n	long
)	O
{	O
if	O
(	O
!	O
n	long
&&	O
p	pointer
)	O
{	O
free	function
(	O
p	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
p	pointer
=	O
realloc	function
(	O
p	pointer
,	O
n	long
)	O
;	O
if	O
(	O
!	O
p	pointer
&&	O
n	long
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
x2realloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
*	O
pn	pointer
)	O
{	O
return	O
x2nrealloc	function
(	O
p	pointer
,	O
pn	pointer
,	O
1	int
)	O
;	O
}	O
void	O
*	O
xzalloc	function
(	O
size_t	long
s	long
)	O
{	O
return	O
memset	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
0	int
,	O
s	long
)	O
;	O
}	O
void	O
*	O
xcalloc	function
(	O
size_t	long
n	long
,	O
size_t	long
s	long
)	O
{	O
void	O
*	O
p	pointer
;	O
if	O
(	O
xalloc_oversized	O
(	O
n	long
,	O
s	long
)	O
||	O
(	O
!	O
(	O
p	pointer
=	O
calloc	function
(	O
n	long
,	O
s	long
)	O
)	O
&&	O
(	O
HAVE_GNU_CALLOC	int
||	O
n	long
!=	O
0	int
)	O
)	O
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xmemdup	function
(	O
void	O
const	O
*	O
p	pointer
,	O
size_t	long
s	long
)	O
{	O
return	O
memcpy	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
p	pointer
,	O
s	long
)	O
;	O
}	O
char	O
*	O
xstrdup	function
(	O
char	O
const	O
*	O
string	pointer
)	O
{	O
return	O
xmemdup	function
(	O
string	pointer
,	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
)	O
;	O
}	O
char	O
*	O
xdico_local_hostname	function
(	O
void	O
)	O
{	O
struct	O
hostent	struct
*	O
hp	pointer
;	O
char	O
*	O
hostpart	pointer
=	O
xgethostname	function
(	O
)	O
;	O
char	O
*	O
ret	pointer
;	O
hp	pointer
=	O
gethostbyname	function
(	O
hostpart	pointer
)	O
;	O
if	O
(	O
hp	pointer
)	O
ret	pointer
=	O
xstrdup	function
(	O
hp	pointer
->	O
h_name	pointer
)	O
;	O
else	O
{	O
char	O
*	O
domainpart	pointer
=	O
xgetdomainname	function
(	O
)	O
;	O
if	O
(	O
domainpart	O
&&	O
domainpart	pointer
[	O
0	int
]	O
&&	O
strcmp	function
(	O
domainpart	pointer
,	O
"(none)"	pointer
)	O
)	O
{	O
ret	int
=	O
xmalloc	function
(	O
strlen	function
(	O
hostpart	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
domainpart	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
ret	int
,	O
hostpart	pointer
)	O
;	O
strcat	function
(	O
ret	pointer
,	O
"."	pointer
)	O
;	O
strcat	function
(	O
ret	pointer
,	O
domainpart	pointer
)	O
;	O
free	function
(	O
hostpart	pointer
)	O
;	O
}	O
else	O
ret	pointer
=	O
hostpart	pointer
;	O
free	function
(	O
domainpart	pointer
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
struct	O
transcript_stream	struct
{	O
int	O
flags	int
;	O
dico_stream_t	pointer
transport	pointer
;	O
dico_stream_t	pointer
logstr	pointer
;	O
char	O
*	O
prefix	array
[	O
2	int
]	O
;	O
}	O
;	O
static	O
void	O
print_transcript	function
(	O
struct	O
transcript_stream	struct
*	O
str	pointer
,	O
int	O
flag	int
,	O
const	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
)	O
{	O
while	O
(	O
size	long
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
size_t	long
len	long
;	O
if	O
(	O
str	pointer
->	O
flags	int
&	O
flag	int
)	O
{	O
dico_stream_write	function
(	O
str	pointer
->	O
logstr	pointer
,	O
str	pointer
->	O
prefix	array
[	O
FLAG_TO_PFX	function
(	O
flag	int
)	O
]	O
,	O
strlen	function
(	O
str	pointer
->	O
prefix	array
[	O
FLAG_TO_PFX	function
(	O
flag	int
)	O
]	O
)	O
)	O
;	O
str	pointer
->	O
flags	int
&=	O
~	O
flag	int
;	O
}	O
p	pointer
=	O
memchr	function
(	O
buf	pointer
,	O
'\n'	O
,	O
size	long
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
len	long
=	O
p	pointer
-	O
buf	pointer
;	O
if	O
(	O
p	pointer
>	O
buf	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
'\r'	O
)	O
len	long
--	O
;	O
dico_stream_write	function
(	O
str	pointer
->	O
logstr	pointer
,	O
buf	pointer
,	O
len	long
)	O
;	O
dico_stream_write	function
(	O
str	pointer
->	O
logstr	pointer
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
str	pointer
->	O
flags	int
|=	O
flag	int
;	O
len	int
=	O
p	pointer
-	O
buf	pointer
+	O
1	int
;	O
buf	pointer
=	O
p	pointer
+	O
1	int
;	O
size	long
-=	O
len	long
;	O
}	O
else	O
{	O
dico_stream_write	function
(	O
str	pointer
->	O
logstr	pointer
,	O
buf	pointer
,	O
size	long
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
int	O
transcript_read	function
(	O
void	O
*	O
data	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
size_t	long
*	O
pret	pointer
)	O
{	O
struct	O
transcript_stream	struct
*	O
p	pointer
=	O
data	pointer
;	O
size_t	long
nbytes	long
;	O
if	O
(	O
dico_stream_read	function
(	O
p	pointer
->	O
transport	pointer
,	O
buf	pointer
,	O
size	long
,	O
&	O
nbytes	long
)	O
==	O
0	int
)	O
{	O
print_transcript	function
(	O
p	pointer
,	O
TRANS_READ	pointer
,	O
buf	pointer
,	O
nbytes	long
)	O
;	O
if	O
(	O
pret	pointer
)	O
*	O
pret	pointer
=	O
nbytes	long
;	O
}	O
else	O
return	O
dico_stream_last_error	function
(	O
p	pointer
->	O
transport	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
transcript_write	function
(	O
void	O
*	O
data	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
size_t	long
*	O
pret	pointer
)	O
{	O
struct	O
transcript_stream	struct
*	O
p	pointer
=	O
data	pointer
;	O
if	O
(	O
dico_stream_write	function
(	O
p	pointer
->	O
transport	pointer
,	O
buf	pointer
,	O
size	long
)	O
==	O
0	int
)	O
{	O
print_transcript	function
(	O
p	pointer
,	O
TRANS_WRITE	pointer
,	O
buf	pointer
,	O
size	long
)	O
;	O
if	O
(	O
pret	pointer
)	O
*	O
pret	pointer
=	O
size	long
;	O
}	O
else	O
return	O
dico_stream_last_error	function
(	O
p	pointer
->	O
transport	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
transcript_flush	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
transcript_stream	struct
*	O
p	pointer
=	O
data	pointer
;	O
if	O
(	O
!	O
p	pointer
->	O
transport	pointer
)	O
return	O
0	int
;	O
return	O
dico_stream_flush	function
(	O
p	pointer
->	O
transport	pointer
)	O
;	O
}	O
static	O
int	O
transcript_close	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
transcript_stream	struct
*	O
p	pointer
=	O
data	pointer
;	O
dico_stream_close	function
(	O
p	pointer
->	O
logstr	pointer
)	O
;	O
dico_stream_close	function
(	O
p	pointer
->	O
transport	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
transcript_destroy	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
transcript_stream	struct
*	O
p	pointer
=	O
data	pointer
;	O
free	function
(	O
p	pointer
->	O
prefix	array
[	O
0	int
]	O
)	O
;	O
free	function
(	O
p	pointer
->	O
prefix	array
[	O
1	int
]	O
)	O
;	O
dico_stream_destroy	function
(	O
&	O
p	pointer
->	O
transport	pointer
)	O
;	O
dico_stream_destroy	function
(	O
&	O
p	pointer
->	O
logstr	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
transcript_strerror	function
(	O
void	O
*	O
data	pointer
,	O
int	O
rc	int
)	O
{	O
struct	O
transcript_stream	struct
*	O
p	pointer
=	O
data	pointer
;	O
return	O
dico_stream_strerror	function
(	O
p	pointer
->	O
transport	pointer
,	O
rc	int
)	O
;	O
}	O
static	O
int	O
transcript_ioctl	function
(	O
void	O
*	O
data	pointer
,	O
int	O
code	int
,	O
void	O
*	O
call_data	pointer
)	O
{	O
struct	O
transcript_stream	struct
*	O
p	pointer
=	O
data	pointer
;	O
switch	O
(	O
code	int
)	O
{	O
case	O
DICO_IOCTL_GET_TRANSPORT	int
:	O
*	O
(	O
dico_stream_t	pointer
*	O
)	O
call_data	pointer
=	O
p	pointer
->	O
transport	pointer
;	O
break	O
;	O
case	O
DICO_IOCTL_SET_TRANSPORT	int
:	O
p	pointer
->	O
transport	pointer
=	O
call_data	pointer
;	O
break	O
;	O
case	O
DICO_IOCTL_BYTES_IN	int
:	O
*	O
(	O
off_t	long
*	O
)	O
call_data	pointer
=	O
dico_stream_bytes_in	function
(	O
p	pointer
->	O
transport	pointer
)	O
;	O
break	O
;	O
case	O
DICO_IOCTL_BYTES_OUT	int
:	O
*	O
(	O
off_t	long
*	O
)	O
call_data	pointer
=	O
dico_stream_bytes_out	function
(	O
p	pointer
->	O
transport	pointer
)	O
;	O
break	O
;	O
default	O
:	O
errno	O
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
default_prefix	array
[	O
2	int
]	O
=	O
{	O
"C: "	pointer
,	O
"S: "	pointer
}	O
;	O
dico_stream_t	pointer
xdico_transcript_stream_create	function
(	O
dico_stream_t	pointer
transport	pointer
,	O
dico_stream_t	pointer
logstr	pointer
,	O
const	O
char	O
*	O
prefix	array
[	O
]	O
)	O
{	O
struct	O
transcript_stream	struct
*	O
p	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
dico_stream_t	pointer
stream	pointer
;	O
int	O
rc	int
=	O
dico_stream_create	function
(	O
&	O
stream	pointer
,	O
DICO_STREAM_READ	int
|	O
DICO_STREAM_WRITE	int
,	O
p	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
xalloc_die	function
(	O
)	O
;	O
p	pointer
->	O
flags	int
=	O
TRANS_READ	int
|	O
TRANS_WRITE	int
;	O
if	O
(	O
prefix	pointer
)	O
{	O
p	pointer
->	O
prefix	array
[	O
0	int
]	O
=	O
xstrdup	function
(	O
prefix	array
[	O
0	int
]	O
?	O
prefix	array
[	O
0	int
]	O
:	O
default_prefix	array
[	O
0	int
]	O
)	O
;	O
p	pointer
->	O
prefix	array
[	O
1	int
]	O
=	O
xstrdup	function
(	O
prefix	array
[	O
1	int
]	O
?	O
prefix	array
[	O
1	int
]	O
:	O
default_prefix	array
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
p	pointer
->	O
prefix	array
[	O
0	int
]	O
=	O
xstrdup	function
(	O
default_prefix	array
[	O
0	int
]	O
)	O
;	O
p	pointer
->	O
prefix	array
[	O
1	int
]	O
=	O
xstrdup	function
(	O
default_prefix	array
[	O
1	int
]	O
)	O
;	O
}	O
p	pointer
->	O
transport	pointer
=	O
transport	pointer
;	O
p	pointer
->	O
logstr	pointer
=	O
logstr	pointer
;	O
dico_stream_set_read	function
(	O
stream	pointer
,	O
transcript_read	pointer
)	O
;	O
dico_stream_set_write	function
(	O
stream	pointer
,	O
transcript_write	function
)	O
;	O
dico_stream_set_flush	function
(	O
stream	pointer
,	O
transcript_flush	function
)	O
;	O
dico_stream_set_close	function
(	O
stream	pointer
,	O
transcript_close	function
)	O
;	O
dico_stream_set_destroy	function
(	O
stream	pointer
,	O
transcript_destroy	function
)	O
;	O
dico_stream_set_ioctl	function
(	O
stream	pointer
,	O
transcript_ioctl	O
)	O
;	O
dico_stream_set_error_string	function
(	O
stream	O
,	O
transcript_strerror	function
)	O
;	O
dico_stream_set_buffer	function
(	O
stream	pointer
,	O
dico_buffer_line	int
,	O
1024	int
)	O
;	O
return	O
stream	int
;	O
}	O
void	O
xdico_tokenize_string	function
(	O
struct	O
dico_tokbuf	struct
*	O
tb	pointer
,	O
char	O
*	O
str	pointer
)	O
{	O
dico_tokenize_clear	function
(	O
tb	pointer
)	O
;	O
if	O
(	O
dico_tokenize_string	function
(	O
tb	pointer
,	O
str	pointer
)	O
)	O
xalloc_die	function
(	O
)	O
;	O
}	O
void	O
trimnl	function
(	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
len	long
>	O
1	int
&&	O
buf	pointer
[	O
--	O
len	long
]	O
==	O
'\n'	O
)	O
{	O
buf	pointer
[	O
len	long
]	O
=	O
0	int
;	O
if	O
(	O
len	long
>	O
1	int
&&	O
buf	pointer
[	O
--	O
len	long
]	O
==	O
'\r'	O
)	O
buf	pointer
[	O
len	long
]	O
=	O
0	int
;	O
}	O
}	O
char	O
*	O
make_full_file_name	function
(	O
const	O
char	O
*	O
dir	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
s	pointer
=	O
dico_full_file_name	function
(	O
dir	pointer
,	O
file	pointer
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
s	pointer
;	O
}	O
dico_list_t	pointer
xdico_list_create	function
(	O
void	O
)	O
{	O
dico_list_t	pointer
p	pointer
=	O
dico_list_create	function
(	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
dico_iterator_t	pointer
xdico_list_iterator	function
(	O
dico_list_t	pointer
list	pointer
)	O
{	O
dico_iterator_t	pointer
p	pointer
=	O
dico_list_iterator	function
(	O
list	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
&&	O
errno	O
==	O
ENOMEM	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
xdico_list_append	function
(	O
struct	O
dico_list	struct
*	O
list	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
if	O
(	O
dico_list_append	function
(	O
list	pointer
,	O
data	pointer
)	O
&&	O
errno	O
==	O
ENOMEM	int
)	O
xalloc_die	function
(	O
)	O
;	O
}	O
void	O
xdico_list_prepend	function
(	O
struct	O
dico_list	struct
*	O
list	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
if	O
(	O
dico_list_prepend	function
(	O
list	pointer
,	O
data	pointer
)	O
&&	O
errno	O
==	O
ENOMEM	int
)	O
xalloc_die	function
(	O
)	O
;	O
}	O
dico_assoc_list_t	pointer
xdico_assoc_create	function
(	O
int	O
flags	int
)	O
{	O
dico_assoc_list_t	pointer
p	pointer
=	O
dico_assoc_create	function
(	O
flags	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
xdico_assoc_append	function
(	O
dico_assoc_list_t	pointer
assoc	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
value	pointer
)	O
{	O
if	O
(	O
dico_assoc_append	function
(	O
assoc	pointer
,	O
key	pointer
,	O
value	pointer
)	O
&&	O
errno	O
==	O
ENOMEM	int
)	O
xalloc_die	function
(	O
)	O
;	O
}	O
int	O
xdico_assoc_add	function
(	O
dico_assoc_list_t	pointer
assoc	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
size_t	long
count	long
,	O
int	O
replace	int
)	O
{	O
int	O
rc	int
=	O
dico_assoc_add	function
(	O
assoc	pointer
,	O
key	pointer
,	O
value	pointer
,	O
count	long
,	O
replace	int
)	O
;	O
if	O
(	O
rc	int
&&	O
errno	O
==	O
ENOMEM	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
rc	int
;	O
}	O
char	O
*	O
xdico_assign_string	function
(	O
char	O
*	O
*	O
dest	pointer
,	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
*	O
dest	pointer
)	O
free	function
(	O
*	O
dest	pointer
)	O
;	O
return	O
*	O
dest	pointer
=	O
str	pointer
?	O
xstrdup	function
(	O
str	pointer
)	O
:	O
NULL	O
;	O
}	O
static	O
char	O
*	O
mech_to_capa_table	array
[	O
]	O
[	O
2	int
]	O
=	O
{	O
{	O
"EXTERNAL"	pointer
,	O
"external"	pointer
}	O
,	O
{	O
"SKEY"	pointer
,	O
"skey"	pointer
}	O
,	O
{	O
"GSSAPI"	pointer
,	O
"gssapi"	pointer
}	O
,	O
{	O
"KERBEROS_V4"	pointer
,	O
"kerberos_v4"	pointer
}	O
}	O
;	O
char	O
*	O
xdico_sasl_mech_to_capa	function
(	O
char	O
*	O
mech	pointer
)	O
{	O
int	O
i	int
;	O
size_t	long
len	long
;	O
char	O
*	O
rets	pointer
,	O
*	O
p	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DICO_ARRAY_SIZE	O
(	O
mech_to_capa_table	pointer
)	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
mech_to_capa_table	pointer
[	O
i	int
]	O
[	O
0	int
]	O
,	O
mech	pointer
)	O
==	O
0	int
)	O
return	O
xstrdup	function
(	O
mech_to_capa_table	array
[	O
i	int
]	O
[	O
1	int
]	O
)	O
;	O
len	long
=	O
strlen	function
(	O
mech	pointer
)	O
+	O
1	int
;	O
rets	pointer
=	O
p	pointer
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
*	O
p	pointer
++	O
=	O
'x'	O
;	O
for	O
(	O
;	O
*	O
mech	pointer
;	O
mech	pointer
++	O
)	O
*	O
p	pointer
++	O
=	O
tolower	function
(	O
*	O
mech	pointer
)	O
;	O
*	O
p	pointer
=	O
0	int
;	O
return	O
rets	pointer
;	O
}	O
int	O
xdico_sasl_capa_match_p	function
(	O
const	O
char	O
*	O
mech	pointer
,	O
const	O
char	O
*	O
capa	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DICO_ARRAY_SIZE	O
(	O
mech_to_capa_table	pointer
)	O
;	O
i	int
++	O
)	O
if	O
(	O
c_strcasecmp	function
(	O
mech_to_capa_table	pointer
[	O
i	int
]	O
[	O
0	int
]	O
,	O
mech	pointer
)	O
==	O
0	int
)	O
return	O
c_strcasecmp	function
(	O
mech_to_capa_table	array
[	O
i	int
]	O
[	O
1	int
]	O
,	O
capa	pointer
)	O
==	O
0	int
;	O
if	O
(	O
*	O
capa	pointer
==	O
'x'	O
)	O
return	O
c_strcasecmp	function
(	O
mech	pointer
,	O
capa	pointer
+	O
1	int
)	O
==	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
dicod_free_item	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
DICO_ARG_UNUSED	pointer
)	O
{	O
free	function
(	O
item	pointer
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
last_component	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
const	O
*	O
base	pointer
=	O
name	pointer
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
char	O
const	O
*	O
p	pointer
;	O
bool	bool
saw_slash	bool
=	O
false	int
;	O
while	O
(	O
ISSLASH	O
(	O
*	O
base	pointer
)	O
)	O
base	pointer
++	O
;	O
for	O
(	O
p	pointer
=	O
base	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
ISSLASH	O
(	O
*	O
p	pointer
)	O
)	O
saw_slash	bool
=	O
true	int
;	O
else	O
if	O
(	O
saw_slash	bool
)	O
{	O
base	pointer
=	O
p	pointer
;	O
saw_slash	bool
=	O
false	int
;	O
}	O
}	O
return	O
(	O
char	O
*	O
)	O
base	pointer
;	O
}	O
size_t	long
base_len	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
size_t	long
len	long
;	O
size_t	long
prefix_len	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
for	O
(	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
1	int
<	O
len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
len	long
-	O
1	int
]	O
)	O
;	O
len	long
--	O
)	O
continue	O
;	O
if	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
len	long
==	O
1	int
&&	O
ISSLASH	O
(	O
name	pointer
[	O
0	int
]	O
)	O
&&	O
ISSLASH	O
(	O
name	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
name	pointer
[	O
2	int
]	O
)	O
return	O
2	int
;	O
if	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
prefix_len	long
&&	O
len	long
==	O
prefix_len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
prefix_len	long
]	O
)	O
)	O
return	O
prefix_len	long
+	O
1	int
;	O
return	O
len	long
;	O
}	O
bool	bool
c_isascii	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
0x00	int
&&	O
c	int
<=	O
0x7f	int
)	O
;	O
}	O
bool	bool
c_isalnum	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'Z'	O
)	O
)	O
;	O
}	O
bool	bool
c_isalpha	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'Z'	O
)	O
;	O
}	O
bool	bool
c_isblank	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
==	O
' '	O
||	O
c	int
==	O
'\t'	O
)	O
;	O
}	O
bool	bool
c_iscntrl	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
&	O
~	O
0x1f	int
)	O
==	O
0	int
||	O
c	int
==	O
0x7f	int
)	O
;	O
}	O
bool	bool
c_isdigit	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
;	O
}	O
bool	bool
c_islower	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'a'	O
&&	O
c	int
<=	O
'z'	O
)	O
;	O
}	O
bool	bool
c_isgraph	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'!'	O
&&	O
c	int
<=	O
'~'	O
)	O
;	O
}	O
bool	bool
c_isprint	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
' '	O
&&	O
c	int
<=	O
'~'	O
)	O
;	O
}	O
bool	bool
c_ispunct	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
>=	O
'!'	O
&&	O
c	int
<=	O
'~'	O
)	O
&&	O
!	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'Z'	O
)	O
)	O
)	O
;	O
}	O
bool	bool
c_isspace	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
==	O
' '	O
||	O
c	int
==	O
'\t'	O
||	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
'\v'	O
||	O
c	int
==	O
'\f'	O
||	O
c	int
==	O
'\r'	O
)	O
;	O
}	O
bool	bool
c_isupper	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'A'	O
&&	O
c	int
<=	O
'Z'	O
)	O
;	O
}	O
bool	bool
c_isxdigit	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'F'	O
)	O
)	O
;	O
}	O
int	O
c_tolower	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'A'	O
&&	O
c	int
<=	O
'Z'	O
?	O
c	int
-	O
'A'	O
+	O
'a'	O
:	O
c	int
)	O
;	O
}	O
int	O
c_toupper	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'a'	O
&&	O
c	int
<=	O
'z'	O
?	O
c	int
-	O
'a'	O
+	O
'A'	O
:	O
c	int
)	O
;	O
}	O
int	O
c_strncasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
,	O
size_t	long
n	long
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
||	O
n	long
==	O
0	int
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
--	O
n	long
==	O
0	int
||	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
size_t	long
block_read	function
(	O
int	O
fd	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
nbytes	long
)	O
{	O
char	O
*	O
bp	pointer
=	O
buf	pointer
;	O
char	O
const	O
*	O
buflim	pointer
=	O
buf	pointer
+	O
nbytes	long
;	O
size_t	long
readlim	long
=	O
MIN	O
(	O
SSIZE_MAX	O
,	O
SIZE_MAX	O
)	O
;	O
do	O
{	O
size_t	long
bytes_remaining	long
=	O
buflim	pointer
-	O
bp	pointer
;	O
size_t	long
bytes_to_read	long
=	O
MIN	O
(	O
bytes_remaining	pointer
,	O
readlim	int
)	O
;	O
ssize_t	long
nread	long
=	O
read	function
(	O
fd	int
,	O
bp	pointer
,	O
bytes_to_read	int
)	O
;	O
if	O
(	O
nread	long
<=	O
0	int
)	O
{	O
if	O
(	O
nread	long
==	O
0	int
)	O
break	O
;	O
if	O
(	O
errno	O
==	O
EINVAL	int
&&	O
INT_MAX	O
<	O
bytes_to_read	int
)	O
{	O
readlim	long
=	O
INT_MAX	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
SA_RESTART	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
return	O
SIZE_MAX	O
;	O
}	O
bp	pointer
+=	O
nread	long
;	O
}	O
while	O
(	O
bp	pointer
<	O
buflim	int
)	O
;	O
return	O
bp	pointer
-	O
buf	pointer
;	O
}	O
size_t	long
buffer_lcm	function
(	O
size_t	long
a	long
,	O
size_t	long
b	long
,	O
size_t	long
lcm_max	long
)	O
{	O
size_t	long
lcm	long
,	O
m	pointer
,	O
n	long
,	O
q	int
,	O
r	pointer
;	O
if	O
(	O
!	O
a	long
)	O
return	O
b	long
?	O
b	long
:	O
8	int
*	O
1024	int
;	O
if	O
(	O
!	O
b	int
)	O
return	O
a	long
;	O
for	O
(	O
m	long
=	O
a	long
,	O
n	long
=	O
b	int
;	O
(	O
r	pointer
=	O
m	long
%	O
n	long
)	O
!=	O
0	int
;	O
m	long
=	O
n	long
,	O
n	long
=	O
r	int
)	O
continue	O
;	O
q	int
=	O
a	int
/	O
n	long
;	O
lcm	int
=	O
q	int
*	O
b	int
;	O
return	O
lcm	int
<=	O
lcm_max	int
&&	O
lcm	int
/	O
b	int
==	O
q	int
?	O
lcm	int
:	O
a	long
;	O
}	O
size_t	long
dir_len	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
prefix_length	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
;	O
size_t	long
length	long
;	O
prefix_length	long
+=	O
(	O
prefix_length	long
!=	O
0	int
?	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
prefix_length	long
]	O
)	O
)	O
:	O
(	O
ISSLASH	O
(	O
file	pointer
[	O
0	int
]	O
)	O
?	O
(	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
?	O
2	int
:	O
1	int
)	O
)	O
:	O
0	int
)	O
)	O
;	O
for	O
(	O
length	long
=	O
last_component	function
(	O
file	pointer
)	O
-	O
file	pointer
;	O
prefix_length	long
<	O
length	long
;	O
length	long
--	O
)	O
if	O
(	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
length	long
-	O
1	int
]	O
)	O
)	O
break	O
;	O
return	O
length	long
;	O
}	O
char	O
*	O
mdir_name	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
length	long
=	O
dir_len	function
(	O
file	pointer
)	O
;	O
bool	bool
append_dot	bool
=	O
(	O
length	long
==	O
0	int
||	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
length	long
==	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
&&	O
file	pointer
[	O
2	int
]	O
!=	O
'\0'	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
)	O
)	O
;	O
char	O
*	O
dir	pointer
=	O
malloc	function
(	O
length	long
+	O
append_dot	bool
+	O
1	int
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
dir	pointer
,	O
file	pointer
,	O
length	long
)	O
;	O
if	O
(	O
append_dot	bool
)	O
dir	pointer
[	O
length	long
++	O
]	O
=	O
'.'	O
;	O
dir	pointer
[	O
length	long
]	O
=	O
'\0'	O
;	O
return	O
dir	pointer
;	O
}	O
static	O
bool	bool
mbsstr_trimmed_wordbounded	bool
(	O
const	O
char	O
*	O
string	pointer
,	O
const	O
char	O
*	O
sub	pointer
)	O
{	O
char	O
*	O
tsub	pointer
=	O
trim	O
(	O
sub	pointer
)	O
;	O
bool	bool
found	bool
=	O
false	int
;	O
for	O
(	O
;	O
*	O
string	pointer
!=	O
'\0'	O
;	O
)	O
{	O
const	O
char	O
*	O
tsub_in_string	pointer
=	O
mbsstr	function
(	O
string	pointer
,	O
tsub	pointer
)	O
;	O
if	O
(	O
tsub_in_string	pointer
==	O
NULL	O
)	O
break	O
;	O
else	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
mbui_iterator_t	struct
string_iter	struct
;	O
bool	bool
word_boundary_before	bool
;	O
bool	bool
word_boundary_after	bool
;	O
mbui_init	O
(	O
string_iter	struct
,	O
string	pointer
)	O
;	O
word_boundary_before	bool
=	O
true	int
;	O
if	O
(	O
mbui_cur_ptr	O
(	O
string_iter	struct
)	O
<	O
tsub_in_string	pointer
)	O
{	O
mbchar_t	struct
last_char_before_tsub	struct
;	O
do	O
{	O
if	O
(	O
!	O
mbui_avail	O
(	O
string_iter	struct
)	O
)	O
abort	function
(	O
)	O
;	O
last_char_before_tsub	struct
=	O
mbui_cur	O
(	O
string_iter	struct
)	O
;	O
mbui_advance	O
(	O
string_iter	struct
)	O
;	O
}	O
while	O
(	O
mbui_cur_ptr	O
(	O
string_iter	struct
)	O
<	O
tsub_in_string	pointer
)	O
;	O
if	O
(	O
mb_isalnum	O
(	O
last_char_before_tsub	struct
)	O
)	O
word_boundary_before	bool
=	O
false	int
;	O
}	O
mbui_init	O
(	O
string_iter	struct
,	O
tsub_in_string	pointer
)	O
;	O
{	O
mbui_iterator_t	struct
tsub_iter	struct
;	O
for	O
(	O
mbui_init	O
(	O
tsub_iter	struct
,	O
tsub	pointer
)	O
;	O
mbui_avail	O
(	O
tsub_iter	struct
)	O
;	O
mbui_advance	O
(	O
tsub_iter	struct
)	O
)	O
{	O
if	O
(	O
!	O
mbui_avail	O
(	O
string_iter	struct
)	O
)	O
abort	function
(	O
)	O
;	O
mbui_advance	O
(	O
string_iter	struct
)	O
;	O
}	O
}	O
word_boundary_after	bool
=	O
true	int
;	O
if	O
(	O
mbui_avail	O
(	O
string_iter	struct
)	O
)	O
{	O
mbchar_t	struct
first_char_after_tsub	struct
=	O
mbui_cur	O
(	O
string_iter	struct
)	O
;	O
if	O
(	O
mb_isalnum	O
(	O
first_char_after_tsub	struct
)	O
)	O
word_boundary_after	bool
=	O
false	int
;	O
}	O
if	O
(	O
word_boundary_before	bool
&&	O
word_boundary_after	bool
)	O
{	O
found	bool
=	O
true	int
;	O
break	O
;	O
}	O
mbui_init	O
(	O
string_iter	struct
,	O
tsub_in_string	pointer
)	O
;	O
if	O
(	O
!	O
mbui_avail	O
(	O
string_iter	struct
)	O
)	O
break	O
;	O
string	pointer
=	O
tsub_in_string	pointer
+	O
mb_len	O
(	O
mbui_cur	O
(	O
string_iter	struct
)	O
)	O
;	O
}	O
else	O
{	O
bool	bool
word_boundary_before	bool
;	O
const	O
char	O
*	O
p	pointer
;	O
bool	bool
word_boundary_after	bool
;	O
word_boundary_before	bool
=	O
true	int
;	O
if	O
(	O
string	pointer
<	O
tsub_in_string	pointer
)	O
if	O
(	O
isalnum	function
(	O
(	O
unsigned	O
char	O
)	O
tsub_in_string	pointer
[	O
-	O
1	int
]	O
)	O
)	O
word_boundary_before	bool
=	O
false	int
;	O
p	pointer
=	O
tsub_in_string	pointer
+	O
strlen	function
(	O
tsub	pointer
)	O
;	O
word_boundary_after	bool
=	O
true	int
;	O
if	O
(	O
*	O
p	pointer
!=	O
'\0'	O
)	O
if	O
(	O
isalnum	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
)	O
word_boundary_after	bool
=	O
false	int
;	O
if	O
(	O
word_boundary_before	bool
&&	O
word_boundary_after	bool
)	O
{	O
found	bool
=	O
true	int
;	O
break	O
;	O
}	O
if	O
(	O
*	O
tsub_in_string	pointer
==	O
'\0'	O
)	O
break	O
;	O
string	pointer
=	O
tsub_in_string	pointer
+	O
1	int
;	O
}	O
}	O
}	O
free	function
(	O
tsub	pointer
)	O
;	O
return	O
found	enum
;	O
}	O
const	O
char	O
*	O
proper_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
const	O
char	O
*	O
translation	pointer
=	O
gettext	function
(	O
name	pointer
)	O
;	O
if	O
(	O
translation	pointer
!=	O
name	pointer
)	O
{	O
if	O
(	O
mbsstr_trimmed_wordbounded	function
(	O
translation	pointer
,	O
name	pointer
)	O
)	O
return	O
translation	pointer
;	O
else	O
{	O
char	O
*	O
result	pointer
=	O
XNMALLOC	O
(	O
strlen	function
(	O
translation	pointer
)	O
+	O
2	int
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
+	O
1	int
,	O
char	O
)	O
;	O
sprintf	function
(	O
result	pointer
,	O
"%s (%s)"	pointer
,	O
translation	pointer
,	O
name	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
}	O
else	O
return	O
name	pointer
;	O
}	O
const	O
char	O
*	O
proper_name_utf8	function
(	O
const	O
char	O
*	O
name_ascii	pointer
,	O
const	O
char	O
*	O
name_utf8	pointer
)	O
{	O
const	O
char	O
*	O
translation	pointer
=	O
gettext	function
(	O
name_ascii	pointer
)	O
;	O
const	O
char	O
*	O
locale_code	pointer
=	O
locale_charset	function
(	O
)	O
;	O
char	O
*	O
alloc_name_converted	pointer
=	O
NULL	O
;	O
char	O
*	O
alloc_name_converted_translit	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
name_converted	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
name_converted_translit	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
c_strcasecmp	function
(	O
locale_code	pointer
,	O
"UTF-8"	pointer
)	O
!=	O
0	int
)	O
{	O
name_converted	pointer
=	O
alloc_name_converted	pointer
=	O
xstr_iconv	function
(	O
name_utf8	pointer
,	O
"UTF-8"	pointer
,	O
locale_code	pointer
)	O
;	O
{	O
char	O
*	O
converted_translit	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
locale_code	pointer
)	O
;	O
char	O
*	O
locale_code_translit	pointer
=	O
XNMALLOC	O
(	O
len	long
+	O
10	int
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
locale_code_translit	pointer
,	O
locale_code	pointer
,	O
len	long
)	O
;	O
memcpy	function
(	O
locale_code_translit	pointer
+	O
len	long
,	O
"//TRANSLIT"	pointer
,	O
10	int
+	O
1	int
)	O
;	O
converted_translit	pointer
=	O
xstr_iconv	function
(	O
name_utf8	pointer
,	O
"UTF-8"	pointer
,	O
locale_code_translit	pointer
)	O
;	O
free	function
(	O
locale_code_translit	pointer
)	O
;	O
if	O
(	O
converted_translit	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strchr	function
(	O
converted_translit	pointer
,	O
'?'	O
)	O
!=	O
NULL	O
)	O
free	function
(	O
converted_translit	pointer
)	O
;	O
else	O
name_converted_translit	pointer
=	O
alloc_name_converted_translit	pointer
=	O
converted_translit	pointer
;	O
}	O
}	O
}	O
else	O
{	O
name_converted	pointer
=	O
name_utf8	pointer
;	O
name_converted_translit	pointer
=	O
name_utf8	pointer
;	O
}	O
name	pointer
=	O
(	O
name_converted	pointer
!=	O
NULL	O
?	O
name_converted	pointer
:	O
name_converted_translit	pointer
!=	O
NULL	O
?	O
name_converted_translit	pointer
:	O
name_ascii	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
translation	pointer
,	O
name_ascii	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
mbsstr_trimmed_wordbounded	function
(	O
translation	pointer
,	O
name_ascii	pointer
)	O
||	O
(	O
name_converted	pointer
!=	O
NULL	O
&&	O
mbsstr_trimmed_wordbounded	function
(	O
translation	pointer
,	O
name_converted	pointer
)	O
)	O
||	O
(	O
name_converted_translit	pointer
!=	O
NULL	O
&&	O
mbsstr_trimmed_wordbounded	function
(	O
translation	pointer
,	O
name_converted_translit	pointer
)	O
)	O
)	O
{	O
if	O
(	O
alloc_name_converted	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc_name_converted	pointer
)	O
;	O
if	O
(	O
alloc_name_converted_translit	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc_name_converted_translit	pointer
)	O
;	O
return	O
translation	pointer
;	O
}	O
else	O
{	O
char	O
*	O
result	pointer
=	O
XNMALLOC	O
(	O
strlen	function
(	O
translation	pointer
)	O
+	O
2	int
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
+	O
1	int
,	O
char	O
)	O
;	O
sprintf	function
(	O
result	pointer
,	O
"%s (%s)"	pointer
,	O
translation	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
alloc_name_converted	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc_name_converted	pointer
)	O
;	O
if	O
(	O
alloc_name_converted_translit	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc_name_converted_translit	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
}	O
else	O
{	O
if	O
(	O
alloc_name_converted	pointer
!=	O
NULL	O
&&	O
alloc_name_converted	pointer
!=	O
name	pointer
)	O
free	function
(	O
alloc_name_converted	pointer
)	O
;	O
if	O
(	O
alloc_name_converted_translit	pointer
!=	O
NULL	O
&&	O
alloc_name_converted_translit	pointer
!=	O
name	pointer
)	O
free	function
(	O
alloc_name_converted_translit	pointer
)	O
;	O
return	O
name	pointer
;	O
}	O
}	O
char	O
*	O
trim2	function
(	O
const	O
char	O
*	O
s	O
,	O
int	O
how	int
)	O
{	O
char	O
*	O
d	pointer
;	O
d	pointer
=	O
strdup	function
(	O
s	long
)	O
;	O
if	O
(	O
!	O
d	pointer
)	O
xalloc_die	function
(	O
)	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
mbi_iterator_t	struct
i	struct
;	O
if	O
(	O
how	int
!=	O
TRIM_TRAILING	int
)	O
{	O
mbi_init	O
(	O
i	struct
,	O
d	pointer
,	O
strlen	function
(	O
d	pointer
)	O
)	O
;	O
for	O
(	O
;	O
mbi_avail	O
(	O
i	struct
)	O
&&	O
mb_isspace	O
(	O
mbi_cur	O
(	O
i	struct
)	O
)	O
;	O
mbi_advance	O
(	O
i	struct
)	O
)	O
;	O
memmove	function
(	O
d	pointer
,	O
mbi_cur_ptr	O
(	O
i	struct
)	O
,	O
strlen	function
(	O
mbi_cur_ptr	O
(	O
i	struct
)	O
)	O
+	O
1	int
)	O
;	O
}	O
if	O
(	O
how	int
!=	O
TRIM_LEADING	int
)	O
{	O
unsigned	O
int	O
state	pointer
=	O
0	int
;	O
char	O
*	O
r	pointer
IF_LINT	O
(	O
=	O
NULL	O
)	O
;	O
mbi_init	O
(	O
i	struct
,	O
d	pointer
,	O
strlen	function
(	O
d	pointer
)	O
)	O
;	O
for	O
(	O
;	O
mbi_avail	O
(	O
i	struct
)	O
;	O
mbi_advance	O
(	O
i	struct
)	O
)	O
{	O
if	O
(	O
state	pointer
==	O
0	int
&&	O
mb_isspace	O
(	O
mbi_cur	O
(	O
i	struct
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
state	pointer
==	O
0	int
&&	O
!	O
mb_isspace	O
(	O
mbi_cur	O
(	O
i	struct
)	O
)	O
)	O
{	O
state	pointer
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
state	pointer
==	O
1	int
&&	O
!	O
mb_isspace	O
(	O
mbi_cur	O
(	O
i	struct
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
state	pointer
==	O
1	int
&&	O
mb_isspace	O
(	O
mbi_cur	O
(	O
i	struct
)	O
)	O
)	O
{	O
state	pointer
=	O
2	int
;	O
r	pointer
=	O
(	O
char	O
*	O
)	O
mbi_cur_ptr	O
(	O
i	struct
)	O
;	O
}	O
else	O
if	O
(	O
state	pointer
==	O
2	int
&&	O
mb_isspace	O
(	O
mbi_cur	O
(	O
i	struct
)	O
)	O
)	O
{	O
}	O
else	O
{	O
state	pointer
=	O
1	int
;	O
}	O
}	O
if	O
(	O
state	pointer
==	O
2	int
)	O
*	O
r	pointer
=	O
'\0'	O
;	O
}	O
}	O
else	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
how	int
!=	O
TRIM_TRAILING	int
)	O
{	O
for	O
(	O
p	pointer
=	O
d	pointer
;	O
*	O
p	pointer
&&	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
)	O
;	O
memmove	function
(	O
d	pointer
,	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
)	O
;	O
}	O
if	O
(	O
how	int
!=	O
TRIM_LEADING	int
)	O
{	O
for	O
(	O
p	pointer
=	O
d	pointer
+	O
strlen	function
(	O
d	pointer
)	O
-	O
1	int
;	O
p	pointer
>=	O
d	pointer
&&	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
;	O
p	pointer
--	O
)	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
}	O
return	O
d	pointer
;	O
}	O
enum	O
{	O
HAVE_GNU_CALLOC	int
=	O
1	int
}	O
;	O
void	O
*	O
xmalloc	function
(	O
size_t	long
n	long
)	O
{	O
void	O
*	O
p	pointer
=	O
malloc	function
(	O
n	long
)	O
;	O
if	O
(	O
!	O
p	pointer
&&	O
n	long
!=	O
0	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
n	long
)	O
{	O
if	O
(	O
!	O
n	long
&&	O
p	pointer
)	O
{	O
free	function
(	O
p	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
p	pointer
=	O
realloc	function
(	O
p	pointer
,	O
n	long
)	O
;	O
if	O
(	O
!	O
p	pointer
&&	O
n	long
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
x2realloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
*	O
pn	pointer
)	O
{	O
return	O
x2nrealloc	function
(	O
p	pointer
,	O
pn	pointer
,	O
1	int
)	O
;	O
}	O
void	O
*	O
xzalloc	function
(	O
size_t	long
s	long
)	O
{	O
return	O
memset	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
0	int
,	O
s	long
)	O
;	O
}	O
void	O
*	O
xcalloc	function
(	O
size_t	long
n	long
,	O
size_t	long
s	long
)	O
{	O
void	O
*	O
p	pointer
;	O
if	O
(	O
(	O
!	O
HAVE_GNU_CALLOC	int
&&	O
xalloc_oversized	O
(	O
n	long
,	O
s	long
)	O
)	O
||	O
(	O
!	O
(	O
p	pointer
=	O
calloc	function
(	O
n	long
,	O
s	long
)	O
)	O
&&	O
(	O
HAVE_GNU_CALLOC	int
||	O
n	long
!=	O
0	int
)	O
)	O
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xmemdup	function
(	O
void	O
const	O
*	O
p	pointer
,	O
size_t	long
s	long
)	O
{	O
return	O
memcpy	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
p	pointer
,	O
s	long
)	O
;	O
}	O
char	O
*	O
xstrdup	function
(	O
char	O
const	O
*	O
string	pointer
)	O
{	O
return	O
xmemdup	function
(	O
string	pointer
,	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
)	O
;	O
}	O
char	O
*	O
xstrndup	function
(	O
const	O
char	O
*	O
string	pointer
,	O
size_t	long
n	long
)	O
{	O
char	O
*	O
s	long
=	O
strndup	function
(	O
string	pointer
,	O
n	long
)	O
;	O
if	O
(	O
!	O
s	long
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
s	long
;	O
}	O
static	O
void	O
print_normal_hunk	function
(	O
struct	O
change	struct
*	O
)	O
;	O
void	O
print_normal_script	function
(	O
struct	O
change	struct
*	O
script	pointer
)	O
{	O
print_script	function
(	O
script	pointer
,	O
find_change	function
,	O
print_normal_hunk	function
)	O
;	O
}	O
static	O
void	O
print_normal_hunk	function
(	O
struct	O
change	struct
*	O
hunk	pointer
)	O
{	O
lin	long
first0	long
,	O
last0	pointer
,	O
first1	pointer
,	O
last1	int
;	O
register	O
lin	long
i	long
;	O
enum	O
changes	enum
changes	enum
=	O
analyze_hunk	function
(	O
hunk	pointer
,	O
&	O
first0	int
,	O
&	O
last0	int
,	O
&	O
first1	int
,	O
&	O
last1	pointer
)	O
;	O
if	O
(	O
!	O
changes	enum
)	O
return	O
;	O
begin_output	function
(	O
)	O
;	O
print_number_range	function
(	O
','	O
,	O
&	O
files	array
[	O
0	int
]	O
,	O
first0	pointer
,	O
last0	int
)	O
;	O
fputc	function
(	O
change_letter	array
[	O
changes	enum
]	O
,	O
outfile	pointer
)	O
;	O
print_number_range	function
(	O
','	O
,	O
&	O
files	array
[	O
1	int
]	O
,	O
first1	pointer
,	O
last1	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
outfile	pointer
)	O
;	O
if	O
(	O
changes	enum
&	O
OLD	int
)	O
for	O
(	O
i	long
=	O
first0	int
;	O
i	long
<=	O
last0	int
;	O
i	int
++	O
)	O
print_1_line	function
(	O
"<"	pointer
,	O
&	O
files	array
[	O
0	int
]	O
.	O
linbuf	pointer
[	O
i	long
]	O
)	O
;	O
if	O
(	O
changes	enum
==	O
CHANGED	int
)	O
fputs	function
(	O
"---\n"	pointer
,	O
outfile	pointer
)	O
;	O
if	O
(	O
changes	enum
&	O
NEW	int
)	O
for	O
(	O
i	int
=	O
first1	int
;	O
i	int
<=	O
last1	int
;	O
i	int
++	O
)	O
print_1_line	function
(	O
">"	pointer
,	O
&	O
files	array
[	O
1	int
]	O
.	O
linbuf	pointer
[	O
i	long
]	O
)	O
;	O
}	O
int	O
grecs_vasprintf	function
(	O
char	O
*	O
*	O
pbuf	pointer
,	O
size_t	long
*	O
psize	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
char	O
*	O
buf	pointer
=	O
*	O
pbuf	pointer
;	O
size_t	long
buflen	long
=	O
*	O
psize	pointer
;	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
!	O
buf	pointer
)	O
{	O
if	O
(	O
buflen	long
==	O
0	int
)	O
buflen	long
=	O
512	int
;	O
buf	pointer
=	O
calloc	function
(	O
1	int
,	O
buflen	long
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
va_list	array
aq	array
;	O
ssize_t	long
n	long
;	O
va_copy	O
(	O
aq	array
,	O
ap	array
)	O
;	O
n	long
=	O
vsnprintf	function
(	O
buf	pointer
,	O
buflen	long
,	O
fmt	pointer
,	O
aq	array
)	O
;	O
va_end	O
(	O
aq	array
)	O
;	O
if	O
(	O
n	long
<	O
0	int
||	O
n	long
>=	O
buflen	long
||	O
!	O
memchr	function
(	O
buf	pointer
,	O
'\0'	O
,	O
n	long
+	O
1	int
)	O
)	O
{	O
char	O
*	O
newbuf	pointer
;	O
size_t	long
newlen	long
=	O
buflen	long
*	O
2	int
;	O
if	O
(	O
newlen	long
<	O
buflen	long
)	O
{	O
rc	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
newbuf	pointer
=	O
realloc	function
(	O
buf	pointer
,	O
newlen	long
)	O
;	O
if	O
(	O
newbuf	pointer
==	O
NULL	O
)	O
{	O
rc	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
buflen	long
=	O
newlen	long
;	O
buf	pointer
=	O
newbuf	pointer
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
!	O
*	O
pbuf	pointer
)	O
{	O
free	function
(	O
buf	pointer
)	O
;	O
buf	pointer
=	O
NULL	O
;	O
buflen	long
=	O
0	int
;	O
}	O
}	O
*	O
pbuf	pointer
=	O
buf	pointer
;	O
*	O
psize	pointer
=	O
buflen	long
;	O
return	O
rc	int
;	O
}	O
int	O
grecs_asprintf	function
(	O
char	O
*	O
*	O
pbuf	pointer
,	O
size_t	long
*	O
psize	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
int	O
rc	int
;	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
rc	int
=	O
grecs_vasprintf	function
(	O
pbuf	pointer
,	O
psize	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
void	O
uint32_to_bytes	function
(	O
unsigned	O
char	O
*	O
bytes	pointer
,	O
uint32_t	int
u	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
bytes	pointer
[	O
i	int
]	O
=	O
u	int
&	O
0xff	int
;	O
u	int
>>=	O
8	int
;	O
}	O
}	O
int	O
grecs_inaddr_to_bytes	function
(	O
int	O
af	int
,	O
void	O
*	O
buf	pointer
,	O
unsigned	O
char	O
*	O
bytes	pointer
)	O
{	O
uint32_t	int
u	int
;	O
switch	O
(	O
af	int
)	O
{	O
case	O
AF_INET	O
:	O
memcpy	function
(	O
&	O
u	int
,	O
buf	pointer
,	O
sizeof	O
u	int
)	O
;	O
uint32_to_bytes	function
(	O
bytes	pointer
,	O
u	int
)	O
;	O
return	O
4	int
;	O
case	O
AF_INET6	O
:	O
memcpy	function
(	O
bytes	pointer
,	O
buf	pointer
,	O
16	int
)	O
;	O
return	O
16	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
grecs_sockaddr_to_bytes	function
(	O
unsigned	O
char	O
*	O
bytes	pointer
,	O
struct	O
sockaddr	struct
const	O
*	O
sa	pointer
)	O
{	O
switch	O
(	O
sa	pointer
->	O
sa_family	short
)	O
{	O
case	O
AF_INET	O
:	O
uint32_to_bytes	function
(	O
bytes	pointer
,	O
(	O
(	O
struct	O
sockaddr_in	struct
*	O
)	O
sa	pointer
)	O
->	O
sin_addr	struct
.	O
s_addr	int
)	O
;	O
return	O
4	int
;	O
case	O
AF_INET6	O
:	O
memcpy	function
(	O
bytes	pointer
,	O
&	O
(	O
(	O
struct	O
sockaddr_in6	struct
*	O
)	O
sa	pointer
)	O
->	O
sin6_addr	struct
,	O
16	int
)	O
;	O
return	O
16	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
grecs_sockaddr_to_cidr	function
(	O
struct	O
grecs_cidr	struct
*	O
cidr	pointer
,	O
const	O
struct	O
sockaddr	struct
*	O
sa	pointer
)	O
{	O
unsigned	O
char	O
address	array
[	O
GRECS_INADDR_BYTES	int
]	O
;	O
int	O
len	long
;	O
int	O
i	int
;	O
len	long
=	O
grecs_sockaddr_to_bytes	function
(	O
address	array
,	O
sa	pointer
)	O
;	O
if	O
(	O
len	long
==	O
0	int
)	O
return	O
-	O
1	int
;	O
cidr	pointer
->	O
family	int
=	O
sa	pointer
->	O
sa_family	short
;	O
cidr	pointer
->	O
len	long
=	O
len	int
;	O
memcpy	function
(	O
cidr	pointer
->	O
address	array
,	O
address	array
,	O
sizeof	O
(	O
cidr	pointer
->	O
address	array
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
GRECS_INADDR_BYTES	int
;	O
i	int
++	O
)	O
cidr	pointer
->	O
netmask	array
[	O
i	int
]	O
=	O
0xff	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
masklen_to_netmask	function
(	O
unsigned	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	long
,	O
size_t	long
masklen	long
)	O
{	O
int	O
i	int
,	O
cnt	int
;	O
cnt	int
=	O
masklen	long
/	O
8	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
cnt	int
;	O
i	int
++	O
)	O
buf	pointer
[	O
i	int
]	O
=	O
0xff	int
;	O
if	O
(	O
i	int
==	O
GRECS_INADDR_BYTES	int
)	O
return	O
;	O
cnt	int
=	O
8	int
-	O
masklen	long
%	O
8	int
;	O
buf	pointer
[	O
i	int
++	O
]	O
=	O
(	O
0xff	int
>>	O
cnt	int
)	O
<<	O
cnt	int
;	O
for	O
(	O
;	O
i	int
<	O
GRECS_INADDR_BYTES	int
;	O
i	int
++	O
)	O
buf	pointer
[	O
i	int
]	O
=	O
0	int
;	O
}	O
int	O
grecs_str_to_cidr	function
(	O
struct	O
grecs_cidr	struct
*	O
pcidr	pointer
,	O
const	O
char	O
*	O
str	pointer
,	O
grecs_locus_t	struct
const	O
*	O
locus	struct
)	O
{	O
int	O
rc	int
;	O
char	O
ipbuf	array
[	O
41	int
]	O
;	O
struct	O
grecs_cidr	struct
cidr	pointer
;	O
char	O
*	O
p	pointer
;	O
size_t	long
len	long
;	O
union	O
{	O
struct	O
in_addr	struct
in	struct
;	O
struct	O
in6_addr	struct
in6	struct
;	O
}	O
inaddr	union
;	O
p	pointer
=	O
strchr	function
(	O
str	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
len	long
=	O
p	pointer
-	O
str	pointer
;	O
else	O
len	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
len	long
>	O
sizeof	O
(	O
ipbuf	array
)	O
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"invalid network mask: %s"	pointer
)	O
,	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
memcpy	function
(	O
ipbuf	array
,	O
str	pointer
,	O
len	long
)	O
;	O
ipbuf	array
[	O
len	long
]	O
=	O
0	int
;	O
if	O
(	O
grecs_str_is_ipv4	function
(	O
ipbuf	array
)	O
)	O
cidr	pointer
.	O
family	int
=	O
AF_INET	O
;	O
else	O
if	O
(	O
grecs_str_is_ipv6	function
(	O
ipbuf	array
)	O
)	O
cidr	pointer
.	O
family	int
=	O
AF_INET6	O
;	O
else	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"unrecognized address family: %s"	pointer
)	O
,	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
inet_pton	function
(	O
cidr	pointer
.	O
family	int
,	O
ipbuf	array
,	O
&	O
inaddr	union
)	O
;	O
if	O
(	O
rc	int
==	O
-	O
1	int
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"unrecognized address family: %s"	pointer
)	O
,	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
rc	int
!=	O
1	int
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"invalid network address: %s"	pointer
)	O
,	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
cidr	pointer
.	O
len	long
=	O
grecs_inaddr_to_bytes	function
(	O
cidr	pointer
.	O
family	int
,	O
&	O
inaddr	union
,	O
cidr	pointer
.	O
address	array
)	O
;	O
if	O
(	O
cidr	pointer
.	O
len	long
==	O
0	int
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"unrecognized address family: %s"	pointer
)	O
,	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
p	pointer
)	O
{	O
char	O
*	O
end	pointer
;	O
unsigned	O
long	O
masklen	long
;	O
p	pointer
++	O
;	O
masklen	long
=	O
strtoul	function
(	O
p	pointer
,	O
&	O
end	struct
,	O
10	int
)	O
;	O
if	O
(	O
*	O
end	struct
==	O
0	int
)	O
masklen_to_netmask	function
(	O
cidr	pointer
.	O
netmask	array
,	O
cidr	pointer
.	O
len	long
,	O
masklen	long
)	O
;	O
else	O
if	O
(	O
(	O
cidr	pointer
.	O
family	int
==	O
AF_INET	O
&&	O
grecs_str_is_ipv4	function
(	O
p	pointer
)	O
)	O
||	O
(	O
cidr	pointer
.	O
family	int
==	O
AF_INET6	O
&&	O
grecs_str_is_ipv6	function
(	O
ipbuf	array
)	O
)	O
)	O
{	O
rc	int
=	O
inet_pton	function
(	O
cidr	pointer
.	O
family	int
,	O
p	pointer
,	O
&	O
inaddr	union
)	O
;	O
if	O
(	O
rc	int
!=	O
1	int
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"invalid network mask: %s"	pointer
)	O
,	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
grecs_inaddr_to_bytes	function
(	O
cidr	pointer
.	O
family	int
,	O
&	O
inaddr	union
,	O
cidr	pointer
.	O
netmask	array
)	O
;	O
}	O
else	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"invalid network mask: %s"	pointer
)	O
,	O
str	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
masklen_to_netmask	function
(	O
cidr	pointer
.	O
netmask	array
,	O
cidr	pointer
.	O
len	long
,	O
cidr	pointer
.	O
len	long
*	O
8	int
)	O
;	O
memcpy	function
(	O
pcidr	pointer
,	O
&	O
cidr	pointer
,	O
sizeof	O
(	O
*	O
pcidr	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
grecs_cidr_match	function
(	O
struct	O
grecs_cidr	struct
*	O
a	pointer
,	O
struct	O
grecs_cidr	struct
*	O
b	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
a	pointer
->	O
family	int
!=	O
b	pointer
->	O
family	int
)	O
return	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
a	pointer
->	O
len	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
a	pointer
->	O
address	array
[	O
i	int
]	O
!=	O
(	O
b	pointer
->	O
address	array
[	O
i	int
]	O
&	O
a	pointer
->	O
netmask	array
[	O
i	int
]	O
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
grecs_sockadd_cidr_match	function
(	O
struct	O
sockaddr	struct
*	O
sa	pointer
,	O
struct	O
grecs_cidr	struct
*	O
cidr	pointer
)	O
{	O
struct	O
grecs_cidr	struct
t	int
;	O
if	O
(	O
grecs_sockaddr_to_cidr	function
(	O
&	O
t	int
,	O
sa	pointer
)	O
)	O
return	O
1	int
;	O
return	O
grecs_cidr_match	function
(	O
cidr	pointer
,	O
&	O
t	int
)	O
;	O
}	O
int	O
grecs_str_is_ipv4	function
(	O
const	O
char	O
*	O
addr	pointer
)	O
{	O
int	O
dot_count	int
=	O
0	int
;	O
int	O
digit_count	int
=	O
0	int
;	O
for	O
(	O
;	O
*	O
addr	pointer
;	O
addr	pointer
++	O
)	O
{	O
if	O
(	O
!	O
isascii	function
(	O
*	O
addr	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
*	O
addr	pointer
==	O
'.'	O
)	O
{	O
if	O
(	O
++	O
dot_count	int
>	O
3	int
)	O
break	O
;	O
digit_count	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
isdigit	function
(	O
*	O
addr	pointer
)	O
&&	O
++	O
digit_count	int
<=	O
3	int
)	O
)	O
return	O
0	int
;	O
}	O
return	O
(	O
dot_count	int
==	O
3	int
)	O
;	O
}	O
int	O
grecs_str_is_ipv6	function
(	O
const	O
char	O
*	O
addr	pointer
)	O
{	O
int	O
col_count	int
=	O
0	int
;	O
int	O
dcol	int
=	O
0	int
;	O
int	O
dig_count	int
=	O
0	int
;	O
for	O
(	O
;	O
*	O
addr	pointer
;	O
addr	pointer
++	O
)	O
{	O
if	O
(	O
!	O
isascii	function
(	O
*	O
addr	pointer
)	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
isxdigit	function
(	O
*	O
addr	pointer
)	O
)	O
{	O
if	O
(	O
++	O
dig_count	int
>	O
4	int
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
*	O
addr	pointer
==	O
':'	O
)	O
{	O
if	O
(	O
col_count	int
&&	O
dig_count	int
==	O
0	int
&&	O
++	O
dcol	int
>	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
++	O
col_count	int
>	O
7	int
)	O
return	O
0	int
;	O
dig_count	int
=	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
return	O
(	O
col_count	int
==	O
7	int
||	O
dcol	int
)	O
;	O
}	O
int	O
grecs_str_is_num	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
for	O
(	O
;	O
*	O
s	pointer
;	O
++	O
s	pointer
)	O
if	O
(	O
!	O
isdigit	function
(	O
*	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
grecs_str_is_ipaddr	function
(	O
const	O
char	O
*	O
addr	pointer
)	O
{	O
if	O
(	O
strchr	function
(	O
addr	pointer
,	O
'.'	O
)	O
)	O
return	O
grecs_str_is_ipv4	function
(	O
addr	pointer
)	O
;	O
else	O
if	O
(	O
strchr	function
(	O
addr	pointer
,	O
':'	O
)	O
)	O
return	O
grecs_str_is_ipv6	function
(	O
addr	pointer
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
handler	struct
*	O
handler_alloc	function
(	O
event_mask	O
ev_mask	pointer
)	O
{	O
struct	O
handler	struct
*	O
hp	pointer
=	O
ecalloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
hp	pointer
)	O
)	O
;	O
hp	pointer
->	O
refcnt	int
=	O
0	int
;	O
hp	pointer
->	O
ev_mask	pointer
=	O
ev_mask	pointer
;	O
return	O
hp	pointer
;	O
}	O
void	O
watchpoint_run_handlers	function
(	O
struct	O
watchpoint	struct
*	O
wp	pointer
,	O
int	O
evflags	int
,	O
const	O
char	O
*	O
dirname	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
handler_iterator_t	pointer
itr	pointer
;	O
struct	O
handler	pointer
*	O
hp	pointer
;	O
event_mask	struct
m	pointer
;	O
for_each_handler	function
(	O
wp	pointer
,	O
itr	pointer
,	O
hp	pointer
)	O
{	O
if	O
(	O
handler_matches_event	function
(	O
hp	pointer
,	O
sys	pointer
,	O
evflags	pointer
,	O
filename	pointer
)	O
)	O
hp	pointer
->	O
run	pointer
(	O
wp	pointer
,	O
event_mask_init	function
(	O
&	O
m	pointer
,	O
evflags	pointer
,	O
&	O
hp	pointer
->	O
ev_mask	pointer
)	O
,	O
dirname	pointer
,	O
filename	pointer
,	O
hp	pointer
->	O
data	pointer
)	O
;	O
}	O
}	O
static	O
void	O
handler_ref	function
(	O
struct	O
handler	pointer
*	O
hp	pointer
)	O
{	O
++	O
hp	pointer
->	O
refcnt	int
;	O
}	O
void	O
handler_free	function
(	O
struct	O
handler	struct
*	O
hp	pointer
)	O
{	O
filpatlist_destroy	function
(	O
&	O
hp	pointer
->	O
fnames	array
)	O
;	O
if	O
(	O
hp	pointer
->	O
free	function
)	O
hp	pointer
->	O
free	function
(	O
hp	pointer
->	O
data	pointer
)	O
;	O
}	O
static	O
void	O
handler_unref	function
(	O
struct	O
handler	struct
*	O
hp	pointer
)	O
{	O
if	O
(	O
hp	pointer
&&	O
--	O
hp	pointer
->	O
refcnt	int
)	O
{	O
handler_free	function
(	O
hp	pointer
)	O
;	O
free	function
(	O
hp	pointer
)	O
;	O
}	O
}	O
static	O
void	O
handler_listent_free	function
(	O
void	O
*	O
p	pointer
)	O
{	O
struct	O
handler	struct
*	O
hp	pointer
=	O
p	pointer
;	O
handler_unref	function
(	O
hp	pointer
)	O
;	O
}	O
struct	O
handler_list	struct
{	O
size_t	long
refcnt	int
;	O
grecs_list_ptr_t	pointer
list	pointer
;	O
struct	O
handler_iterator	struct
*	O
itr_chain	pointer
;	O
}	O
;	O
struct	O
handler_iterator	struct
{	O
struct	O
handler_iterator	struct
*	O
prev	pointer
,	O
*	O
next	pointer
;	O
handler_list_t	struct
hlist	pointer
;	O
struct	O
grecs_list_entry	struct
*	O
ent	pointer
;	O
int	O
advanced	int
;	O
}	O
;	O
static	O
struct	O
handler_iterator	struct
*	O
itr_avail	pointer
;	O
struct	O
handler	struct
*	O
handler_itr_first	function
(	O
struct	O
watchpoint	struct
*	O
wpt	pointer
,	O
handler_iterator_t	struct
*	O
ret_itr	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	pointer
;	O
if	O
(	O
!	O
wpt	pointer
->	O
handler_list	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
itr_avail	pointer
)	O
{	O
itr	pointer
=	O
itr_avail	pointer
;	O
itr_avail	pointer
=	O
itr	pointer
->	O
next	pointer
;	O
if	O
(	O
itr_avail	pointer
)	O
itr_avail	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
}	O
else	O
itr	pointer
=	O
emalloc	function
(	O
sizeof	O
*	O
itr	pointer
)	O
;	O
itr	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
itr	pointer
->	O
next	pointer
=	O
wpt	pointer
->	O
handler_list	pointer
->	O
itr_chain	pointer
;	O
itr	pointer
->	O
hlist	pointer
=	O
wpt	pointer
->	O
handler_list	pointer
;	O
if	O
(	O
wpt	pointer
->	O
handler_list	pointer
->	O
itr_chain	pointer
)	O
wpt	pointer
->	O
handler_list	pointer
->	O
itr_chain	pointer
->	O
prev	pointer
=	O
itr	pointer
;	O
wpt	pointer
->	O
handler_list	pointer
->	O
itr_chain	pointer
=	O
itr	pointer
;	O
itr	pointer
->	O
ent	pointer
=	O
wpt	pointer
->	O
handler_list	pointer
->	O
list	pointer
->	O
head	pointer
;	O
itr	pointer
->	O
advanced	int
=	O
0	int
;	O
*	O
ret_itr	pointer
=	O
itr	pointer
;	O
return	O
handler_itr_current	function
(	O
itr	pointer
)	O
;	O
}	O
struct	O
handler	pointer
*	O
handler_itr_next	function
(	O
handler_iterator_t	struct
*	O
pitr	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	pointer
;	O
if	O
(	O
!	O
pitr	pointer
||	O
(	O
itr	pointer
=	O
*	O
pitr	pointer
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
itr	pointer
->	O
advanced	pointer
)	O
itr	pointer
->	O
advanced	int
=	O
0	int
;	O
else	O
itr	pointer
->	O
ent	pointer
=	O
itr	pointer
->	O
ent	pointer
->	O
next	pointer
;	O
if	O
(	O
!	O
itr	pointer
->	O
ent	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
p	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
itr	pointer
->	O
prev	pointer
)	O
!=	O
NULL	O
)	O
p	pointer
->	O
next	pointer
=	O
itr	pointer
->	O
next	pointer
;	O
else	O
itr	pointer
->	O
hlist	pointer
->	O
itr_chain	pointer
=	O
itr	pointer
->	O
next	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
itr	pointer
->	O
next	pointer
)	O
!=	O
NULL	O
)	O
p	pointer
->	O
prev	pointer
=	O
itr	pointer
->	O
prev	pointer
;	O
if	O
(	O
itr_avail	pointer
)	O
itr_avail	pointer
->	O
prev	pointer
=	O
itr	pointer
;	O
itr	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
itr	pointer
->	O
next	pointer
=	O
itr_avail	pointer
;	O
itr	pointer
->	O
hlist	pointer
=	O
NULL	O
;	O
itr_avail	pointer
=	O
itr	pointer
;	O
*	O
pitr	pointer
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
return	O
handler_itr_current	function
(	O
itr	pointer
)	O
;	O
}	O
struct	O
handler	pointer
*	O
handler_itr_current	function
(	O
handler_iterator_t	pointer
itr	pointer
)	O
{	O
if	O
(	O
!	O
itr	pointer
)	O
return	O
NULL	O
;	O
return	O
itr	pointer
->	O
ent	pointer
?	O
itr	pointer
->	O
ent	pointer
->	O
data	pointer
:	O
NULL	O
;	O
}	O
handler_list_t	O
handler_list_create	function
(	O
void	O
)	O
{	O
handler_list_t	pointer
hlist	pointer
=	O
emalloc	function
(	O
sizeof	O
(	O
*	O
hlist	pointer
)	O
)	O
;	O
hlist	pointer
->	O
list	pointer
=	O
grecs_list_create	function
(	O
)	O
;	O
hlist	pointer
->	O
list	pointer
->	O
free_entry	pointer
=	O
handler_listent_free	pointer
;	O
hlist	pointer
->	O
refcnt	int
=	O
1	int
;	O
hlist	pointer
->	O
itr_chain	pointer
=	O
NULL	O
;	O
return	O
hlist	int
;	O
}	O
size_t	long
handler_list_size	function
(	O
handler_list_t	pointer
hlist	pointer
)	O
{	O
return	O
grecs_list_size	function
(	O
hlist	pointer
->	O
list	pointer
)	O
;	O
}	O
handler_list_t	pointer
handler_list_copy	function
(	O
handler_list_t	pointer
orig	pointer
)	O
{	O
if	O
(	O
!	O
orig	pointer
)	O
return	O
handler_list_create	function
(	O
)	O
;	O
++	O
orig	pointer
->	O
refcnt	int
;	O
return	O
orig	pointer
;	O
}	O
void	O
handler_list_unref	function
(	O
handler_list_t	pointer
hlist	pointer
)	O
{	O
if	O
(	O
hlist	pointer
)	O
{	O
if	O
(	O
--	O
hlist	pointer
->	O
refcnt	int
==	O
0	int
)	O
{	O
grecs_list_free	function
(	O
hlist	pointer
->	O
list	pointer
)	O
;	O
free	function
(	O
hlist	pointer
)	O
;	O
}	O
}	O
}	O
void	O
handler_list_append	function
(	O
handler_list_t	pointer
hlist	pointer
,	O
struct	O
handler	pointer
*	O
hp	pointer
)	O
{	O
handler_ref	function
(	O
hp	pointer
)	O
;	O
grecs_list_append	function
(	O
hlist	pointer
->	O
list	pointer
,	O
hp	pointer
)	O
;	O
}	O
size_t	long
handler_list_remove	function
(	O
handler_list_t	pointer
hlist	pointer
,	O
struct	O
handler	pointer
*	O
hp	pointer
)	O
{	O
struct	O
grecs_list_entry	struct
*	O
ep	pointer
;	O
for	O
(	O
ep	pointer
=	O
hlist	pointer
->	O
list	pointer
->	O
head	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
if	O
(	O
ep	pointer
->	O
data	pointer
==	O
hp	pointer
)	O
break	O
;	O
if	O
(	O
!	O
ep	pointer
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
hlist	pointer
->	O
itr_chain	pointer
)	O
{	O
struct	O
handler_iterator	struct
*	O
itr	pointer
;	O
for	O
(	O
itr	pointer
=	O
hlist	pointer
->	O
itr_chain	pointer
;	O
itr	pointer
;	O
itr	pointer
=	O
itr	pointer
->	O
next	pointer
)	O
if	O
(	O
itr	pointer
->	O
ent	pointer
==	O
ep	pointer
)	O
{	O
itr	pointer
->	O
ent	pointer
=	O
ep	pointer
->	O
next	pointer
;	O
itr	pointer
->	O
advanced	int
=	O
1	int
;	O
}	O
}	O
grecs_list_remove_entry	function
(	O
hlist	pointer
->	O
list	pointer
,	O
ep	pointer
)	O
;	O
return	O
grecs_list_size	function
(	O
hlist	pointer
->	O
list	pointer
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
)	O
;	O
static	O
char	O
*	O
program	pointer
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
AFMHandle	pointer
afm	pointer
;	O
AFMFont	pointer
font	pointer
;	O
AFMError	int
error	int
;	O
AFMNumber	pointer
width	pointer
,	O
height	int
;	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
program	pointer
=	O
strrchr	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
program	pointer
)	O
program	pointer
++	O
;	O
else	O
program	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
error	int
=	O
afm_create	function
(	O
NULL	O
,	O
0	int
,	O
&	O
afm	pointer
)	O
;	O
HANDLE_ERROR	O
(	O
"couldn't create library"	pointer
)	O
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
usage	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"dump"	pointer
)	O
==	O
0	int
&&	O
argc	int
==	O
3	int
)	O
{	O
error	int
=	O
afm_open_file	function
(	O
afm	pointer
,	O
AFM_I_ALL	pointer
,	O
argv	pointer
[	O
2	int
]	O
,	O
&	O
font	pointer
)	O
;	O
if	O
(	O
error	int
!=	O
AFM_SUCCESS	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: couldn't open font \"%s\", using default\n"	pointer
,	O
program	pointer
,	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
error	int
=	O
afm_open_default_font	function
(	O
afm	pointer
,	O
&	O
font	pointer
)	O
;	O
HANDLE_ERROR	O
(	O
"couldn't open default font"	pointer
)	O
;	O
}	O
afm_font_dump	function
(	O
stdout	pointer
,	O
font	pointer
)	O
;	O
error	int
=	O
afm_close_font	function
(	O
font	pointer
)	O
;	O
HANDLE_ERROR	O
(	O
"couldn't close font"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"stringwidth"	pointer
)	O
==	O
0	int
&&	O
argc	int
==	O
5	int
)	O
{	O
error	int
=	O
afm_open_file	function
(	O
afm	pointer
,	O
AFM_I_ALL	pointer
,	O
argv	pointer
[	O
2	int
]	O
,	O
&	O
font	pointer
)	O
;	O
HANDLE_ERROR	O
(	O
"couldn't open font"	pointer
)	O
;	O
error	int
=	O
afm_font_encoding	function
(	O
font	pointer
,	O
AFM_ENCODING_ISO_8859_1	pointer
,	O
0	int
)	O
;	O
HANDLE_ERROR	O
(	O
"couldn't encode font"	pointer
)	O
;	O
error	int
=	O
afm_font_stringwidth	function
(	O
font	pointer
,	O
atof	function
(	O
argv	pointer
[	O
3	int
]	O
)	O
,	O
argv	pointer
[	O
4	int
]	O
,	O
strlen	function
(	O
argv	pointer
[	O
4	int
]	O
)	O
,	O
&	O
width	int
,	O
&	O
height	int
)	O
;	O
printf	function
(	O
"stringwidth is [%g %g]\n"	pointer
,	O
width	int
,	O
height	int
)	O
;	O
error	int
=	O
afm_close_font	function
(	O
font	pointer
)	O
;	O
HANDLE_ERROR	O
(	O
"couldn't close font"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"chardump"	pointer
)	O
==	O
0	int
&&	O
argc	int
>	O
2	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
error	int
=	O
afm_open_file	function
(	O
afm	pointer
,	O
AFM_I_COMPOSITES	pointer
,	O
argv	pointer
[	O
i	int
]	O
,	O
&	O
font	pointer
)	O
;	O
if	O
(	O
error	int
!=	O
AFM_SUCCESS	int
)	O
{	O
afm_error_to_string	function
(	O
error	int
,	O
buf	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: couldn't open AFM file \"%s\": %s\n"	pointer
,	O
program	pointer
,	O
argv	pointer
[	O
i	int
]	O
,	O
buf	pointer
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
font	pointer
->	O
num_character_metrics	int
;	O
j	int
++	O
)	O
{	O
AFMIndividualCharacterMetrics	struct
*	O
cm	pointer
;	O
cm	pointer
=	O
&	O
font	pointer
->	O
character_metrics	array
[	O
j	int
]	O
;	O
printf	function
(	O
"/%-30s %3ld glyph %s\n"	pointer
,	O
cm	pointer
->	O
name	pointer
,	O
cm	pointer
->	O
character_code	pointer
,	O
font	pointer
->	O
global_info	struct
.	O
FontName	pointer
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
font	pointer
->	O
num_composites	int
;	O
j	int
++	O
)	O
{	O
AFMComposite	struct
*	O
cc	pointer
;	O
cc	int
=	O
&	O
font	pointer
->	O
composites	pointer
[	O
j	int
]	O
;	O
printf	function
(	O
"/%-30s -1 composite %s\n"	pointer
,	O
cc	pointer
->	O
name	pointer
,	O
font	pointer
->	O
global_info	struct
.	O
FontName	pointer
)	O
;	O
}	O
(	O
void	O
)	O
afm_close_font	function
(	O
font	pointer
)	O
;	O
}	O
}	O
else	O
{	O
usage	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
usage	function
(	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Usage: %s dump file\n"	pointer
"       %s stringwidth file ptsize string\n"	pointer
"       %s chardump file [file ...]\n"	pointer
,	O
program	pointer
,	O
program	pointer
,	O
program	pointer
)	O
;	O
}	O
static	O
char	O
*	O
file_system_type_uncached	function
(	O
const	O
struct	O
stat	struct
*	O
statp	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
;	O
static	O
void	O
free_file_system_list	function
(	O
struct	O
mount_entry	struct
*	O
p	pointer
)	O
{	O
while	O
(	O
p	pointer
)	O
{	O
struct	O
mount_entry	struct
*	O
pnext	pointer
=	O
p	pointer
->	O
me_next	pointer
;	O
free	function
(	O
p	pointer
->	O
me_devname	pointer
)	O
;	O
free	function
(	O
p	pointer
->	O
me_mountdir	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
me_type_malloced	int
)	O
free	function
(	O
p	pointer
->	O
me_type	pointer
)	O
;	O
p	pointer
->	O
me_next	pointer
=	O
NULL	O
;	O
free	function
(	O
p	pointer
)	O
;	O
p	pointer
=	O
pnext	pointer
;	O
}	O
}	O
static	O
int	O
fstype_known	int
=	O
0	int
;	O
char	O
*	O
filesystem_type	function
(	O
const	O
struct	O
stat	struct
*	O
statp	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
static	O
char	O
*	O
current_fstype	pointer
=	O
NULL	O
;	O
static	O
dev_t	long
current_dev	long
;	O
if	O
(	O
current_fstype	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
fstype_known	O
&&	O
statp	pointer
->	O
st_dev	long
==	O
current_dev	int
)	O
return	O
current_fstype	O
;	O
free	function
(	O
current_fstype	pointer
)	O
;	O
}	O
current_dev	long
=	O
statp	pointer
->	O
st_dev	long
;	O
current_fstype	int
=	O
file_system_type_uncached	function
(	O
statp	pointer
,	O
path	pointer
)	O
;	O
return	O
current_fstype	int
;	O
}	O
static	O
int	O
set_fstype_devno	function
(	O
struct	O
mount_entry	struct
*	O
p	pointer
)	O
{	O
struct	O
stat	struct
stbuf	struct
;	O
if	O
(	O
p	pointer
->	O
me_dev	long
==	O
(	O
dev_t	long
)	O
-	O
1	int
)	O
{	O
set_stat_placeholders	function
(	O
&	O
stbuf	pointer
)	O
;	O
if	O
(	O
0	int
==	O
(	O
options	struct
.	O
xstat	pointer
)	O
(	O
p	pointer
->	O
me_mountdir	pointer
,	O
&	O
stbuf	pointer
)	O
)	O
{	O
p	pointer
->	O
me_dev	long
=	O
stbuf	struct
.	O
st_dev	long
;	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
mount_entry	struct
*	O
must_read_fs_list	function
(	O
bool	bool
need_fs_type	bool
)	O
{	O
struct	O
mount_entry	struct
*	O
entries	pointer
=	O
read_file_system_list	function
(	O
need_fs_type	bool
)	O
;	O
if	O
(	O
NULL	O
==	O
entries	pointer
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"Cannot read mounted file system list"	pointer
)	O
)	O
;	O
}	O
return	O
entries	pointer
;	O
}	O
static	O
char	O
*	O
file_system_type_uncached	function
(	O
const	O
struct	O
stat	struct
*	O
statp	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
struct	O
mount_entry	struct
*	O
entries	pointer
,	O
*	O
entry	pointer
,	O
*	O
best	pointer
;	O
char	O
*	O
type	pointer
;	O
(	O
void	O
)	O
path	pointer
;	O
best	pointer
=	O
NULL	O
;	O
entries	pointer
=	O
must_read_fs_list	function
(	O
true	int
)	O
;	O
for	O
(	O
type	pointer
=	O
NULL	O
,	O
entry	pointer
=	O
entries	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
me_next	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
entry	pointer
->	O
me_type	pointer
,	O
MNTTYPE_IGNORE	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
0	int
==	O
set_fstype_devno	function
(	O
entry	pointer
)	O
)	O
{	O
if	O
(	O
entry	pointer
->	O
me_dev	long
==	O
statp	pointer
->	O
st_dev	long
)	O
{	O
best	int
=	O
entry	int
;	O
}	O
}	O
}	O
if	O
(	O
best	int
)	O
{	O
type	pointer
=	O
xstrdup	function
(	O
best	pointer
->	O
me_type	pointer
)	O
;	O
}	O
free_file_system_list	function
(	O
entries	pointer
)	O
;	O
fstype_known	pointer
=	O
(	O
type	pointer
!=	O
NULL	O
)	O
;	O
return	O
type	O
?	O
type	pointer
:	O
xstrdup	function
(	O
_	O
(	O
"unknown"	pointer
)	O
)	O
;	O
}	O
char	O
*	O
get_mounted_filesystems	function
(	O
void	O
)	O
{	O
char	O
*	O
result	pointer
=	O
NULL	O
;	O
size_t	long
alloc_size	long
=	O
0u	int
;	O
size_t	long
used	long
=	O
0u	int
;	O
struct	O
mount_entry	struct
*	O
entries	pointer
,	O
*	O
entry	pointer
;	O
void	O
*	O
p	pointer
;	O
entries	pointer
=	O
must_read_fs_list	function
(	O
false	int
)	O
;	O
for	O
(	O
entry	pointer
=	O
entries	pointer
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
me_next	pointer
)	O
{	O
size_t	long
len	long
;	O
if	O
(	O
!	O
strcmp	function
(	O
entry	pointer
->	O
me_type	pointer
,	O
MNTTYPE_IGNORE	pointer
)	O
)	O
continue	O
;	O
len	long
=	O
strlen	function
(	O
entry	pointer
->	O
me_mountdir	pointer
)	O
+	O
1	int
;	O
p	pointer
=	O
extendbuf	function
(	O
result	pointer
,	O
used	long
+	O
len	long
,	O
&	O
alloc_size	long
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
result	pointer
=	O
p	pointer
;	O
strcpy	function
(	O
&	O
result	pointer
[	O
used	int
]	O
,	O
entry	pointer
->	O
me_mountdir	pointer
)	O
;	O
used	long
+=	O
len	long
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
free_file_system_list	function
(	O
entries	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
dev_t	long
*	O
get_mounted_devices	function
(	O
size_t	long
*	O
n	long
)	O
{	O
size_t	long
alloc_size	long
=	O
0u	int
;	O
size_t	long
used	long
=	O
0u	int
;	O
struct	O
mount_entry	struct
*	O
entries	pointer
,	O
*	O
entry	pointer
;	O
dev_t	long
*	O
result	pointer
=	O
NULL	O
;	O
for	O
(	O
entry	pointer
=	O
entries	pointer
=	O
read_file_system_list	function
(	O
false	int
)	O
;	O
entry	pointer
;	O
entry	pointer
=	O
entry	pointer
->	O
me_next	pointer
)	O
{	O
void	O
*	O
p	pointer
=	O
extendbuf	function
(	O
result	pointer
,	O
sizeof	O
(	O
dev_t	long
)	O
*	O
(	O
used	long
+	O
1	int
)	O
,	O
&	O
alloc_size	long
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
result	pointer
=	O
p	pointer
;	O
if	O
(	O
0	int
==	O
set_fstype_devno	function
(	O
entry	pointer
)	O
)	O
{	O
result	pointer
[	O
used	int
]	O
=	O
entry	pointer
->	O
me_dev	long
;	O
++	O
used	long
;	O
}	O
}	O
else	O
{	O
free	function
(	O
result	pointer
)	O
;	O
result	pointer
=	O
NULL	O
;	O
}	O
}	O
free_file_system_list	function
(	O
entries	pointer
)	O
;	O
if	O
(	O
result	pointer
)	O
{	O
*	O
n	long
=	O
used	long
;	O
}	O
return	O
result	pointer
;	O
}	O
struct	O
allocator	struct
const	O
stdlib_allocator	struct
=	O
{	O
malloc	function
,	O
realloc	function
,	O
free	function
,	O
NULL	O
}	O
;	O
char	O
*	O
areadlink_with_size	function
(	O
char	O
const	O
*	O
file	pointer
,	O
size_t	long
size	long
)	O
{	O
size_t	long
symlink_max	long
=	O
SYMLINK_MAX	int
;	O
size_t	long
INITIAL_LIMIT_BOUND	long
=	O
8	int
*	O
1024	int
;	O
size_t	long
initial_limit	long
=	O
(	O
symlink_max	long
<	O
INITIAL_LIMIT_BOUND	int
?	O
symlink_max	int
+	O
1	int
:	O
INITIAL_LIMIT_BOUND	pointer
)	O
;	O
size_t	long
buf_size	long
=	O
size	long
<	O
initial_limit	int
?	O
size	long
+	O
1	int
:	O
initial_limit	int
;	O
while	O
(	O
1	int
)	O
{	O
ssize_t	long
r	long
;	O
size_t	long
link_length	long
;	O
char	O
*	O
buffer	pointer
=	O
malloc	function
(	O
buf_size	long
)	O
;	O
if	O
(	O
buffer	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
r	pointer
=	O
readlink	function
(	O
file	pointer
,	O
buffer	pointer
,	O
buf_size	long
)	O
;	O
link_length	int
=	O
r	int
;	O
if	O
(	O
r	long
<	O
0	int
&&	O
errno	O
!=	O
ERANGE	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
free	function
(	O
buffer	pointer
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
link_length	long
<	O
buf_size	long
)	O
{	O
buffer	pointer
[	O
link_length	int
]	O
=	O
0	int
;	O
return	O
buffer	pointer
;	O
}	O
free	function
(	O
buffer	pointer
)	O
;	O
if	O
(	O
buf_size	long
<=	O
MAXSIZE	long
/	O
2	int
)	O
buf_size	long
*=	O
2	int
;	O
else	O
if	O
(	O
buf_size	long
<	O
MAXSIZE	int
)	O
buf_size	long
=	O
MAXSIZE	int
;	O
else	O
{	O
errno	O
=	O
ENOMEM	int
;	O
return	O
NULL	O
;	O
}	O
}	O
}	O
static	O
ssize_t	long
careadlinkatcwd	function
(	O
int	O
fd	int
,	O
char	O
const	O
*	O
filename	pointer
,	O
char	O
*	O
buffer	pointer
,	O
size_t	long
buffer_size	long
)	O
{	O
if	O
(	O
fd	int
!=	O
AT_FDCWD	O
)	O
abort	function
(	O
)	O
;	O
return	O
readlink	function
(	O
filename	pointer
,	O
buffer	pointer
,	O
buffer_size	long
)	O
;	O
}	O
char	O
*	O
areadlink	function
(	O
char	O
const	O
*	O
filename	pointer
)	O
{	O
return	O
careadlinkat	function
(	O
AT_FDCWD	O
,	O
filename	pointer
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
careadlinkatcwd	function
)	O
;	O
}	O
static	O
void	O
__argmatch_die	function
(	O
void	O
)	O
{	O
ARGMATCH_DIE	int
;	O
}	O
argmatch_exit_fn	pointer
argmatch_die	pointer
=	O
__argmatch_die	pointer
;	O
ptrdiff_t	bool
argmatch	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
size_t	long
arglen	long
;	O
ptrdiff_t	long
matchind	long
=	O
-	O
1	int
;	O
bool	bool
ambiguous	bool
=	O
false	int
;	O
arglen	long
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
arglist	array
[	O
i	pointer
]	O
,	O
arg	pointer
,	O
arglen	pointer
)	O
)	O
{	O
if	O
(	O
strlen	function
(	O
arglist	array
[	O
i	long
]	O
)	O
==	O
arglen	pointer
)	O
return	O
i	long
;	O
else	O
if	O
(	O
matchind	int
==	O
-	O
1	int
)	O
matchind	long
=	O
i	long
;	O
else	O
{	O
if	O
(	O
vallist	pointer
==	O
NULL	O
||	O
memcmp	function
(	O
vallist	pointer
+	O
valsize	struct
*	O
matchind	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
{	O
ambiguous	bool
=	O
true	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
ambiguous	pointer
)	O
return	O
-	O
2	int
;	O
else	O
return	O
matchind	pointer
;	O
}	O
void	O
argmatch_invalid	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
ptrdiff_t	long
problem	long
)	O
{	O
char	O
const	O
*	O
format	pointer
=	O
(	O
problem	int
==	O
-	O
1	int
?	O
_	O
(	O
"invalid argument %s for %s"	pointer
)	O
:	O
_	O
(	O
"ambiguous argument %s for %s"	pointer
)	O
)	O
;	O
error	function
(	O
0	int
,	O
0	int
,	O
format	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
ARGMATCH_QUOTING_STYLE	pointer
,	O
value	pointer
)	O
,	O
quote_n	function
(	O
1	int
,	O
context	pointer
)	O
)	O
;	O
}	O
void	O
argmatch_valid	function
(	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
const	O
char	O
*	O
last_val	pointer
=	O
NULL	O
;	O
fputs	function
(	O
_	O
(	O
"Valid arguments are:"	pointer
)	O
,	O
stderr	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
(	O
i	long
==	O
0	int
)	O
||	O
memcmp	function
(	O
last_val	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\n  - %s"	pointer
,	O
quote	function
(	O
arglist	array
[	O
i	long
]	O
)	O
)	O
;	O
last_val	pointer
=	O
vallist	pointer
+	O
valsize	O
*	O
i	long
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
", %s"	pointer
,	O
quote	function
(	O
arglist	array
[	O
i	long
]	O
)	O
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
}	O
ptrdiff_t	bool
__xargmatch_internal	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
,	O
argmatch_exit_fn	pointer
exit_fn	pointer
)	O
{	O
ptrdiff_t	long
res	long
=	O
argmatch	function
(	O
arg	pointer
,	O
arglist	int
,	O
vallist	pointer
,	O
valsize	pointer
)	O
;	O
if	O
(	O
res	int
>=	O
0	int
)	O
return	O
res	pointer
;	O
argmatch_invalid	function
(	O
context	pointer
,	O
arg	pointer
,	O
res	pointer
)	O
;	O
argmatch_valid	function
(	O
arglist	int
,	O
vallist	pointer
,	O
valsize	int
)	O
;	O
(	O
*	O
exit_fn	pointer
)	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
const	O
char	O
*	O
argmatch_to_argument	function
(	O
const	O
char	O
*	O
value	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
!	O
memcmp	function
(	O
value	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	int
,	O
valsize	int
)	O
)	O
return	O
arglist	array
[	O
i	long
]	O
;	O
return	O
NULL	O
;	O
}	O
static	O
bool	bool
is_zero_or_power_of_two	bool
(	O
uintmax_t	long
i	int
)	O
{	O
return	O
(	O
i	int
&	O
(	O
i	int
-	O
1	int
)	O
)	O
==	O
0	int
;	O
}	O
void	O
cycle_check_init	function
(	O
struct	O
cycle_check_state	struct
*	O
state	pointer
)	O
{	O
state	pointer
->	O
chdir_counter	int
=	O
0	int
;	O
state	pointer
->	O
magic	int
=	O
CC_MAGIC	int
;	O
}	O
bool	bool
cycle_check	function
(	O
struct	O
cycle_check_state	struct
*	O
state	pointer
,	O
struct	O
stat	struct
const	O
*	O
sb	pointer
)	O
{	O
assure	O
(	O
state	pointer
->	O
magic	int
==	O
CC_MAGIC	int
)	O
;	O
if	O
(	O
state	pointer
->	O
chdir_counter	int
&&	O
SAME_INODE	O
(	O
*	O
sb	pointer
,	O
state	pointer
->	O
dev_ino	pointer
)	O
)	O
return	O
true	int
;	O
if	O
(	O
is_zero_or_power_of_two	function
(	O
++	O
(	O
state	pointer
->	O
chdir_counter	pointer
)	O
)	O
)	O
{	O
if	O
(	O
state	pointer
->	O
chdir_counter	int
==	O
0	int
)	O
return	O
true	int
;	O
state	pointer
->	O
dev_ino	struct
.	O
st_dev	long
=	O
sb	pointer
->	O
st_dev	long
;	O
state	pointer
->	O
dev_ino	struct
.	O
st_ino	long
=	O
sb	pointer
->	O
st_ino	long
;	O
}	O
return	O
false	int
;	O
}	O
int	O
fseek	function
(	O
FILE	struct
*	O
fp	pointer
,	O
long	O
offset	long
,	O
int	O
whence	int
)	O
{	O
return	O
fseeko	function
(	O
fp	pointer
,	O
(	O
off_t	long
)	O
offset	long
,	O
whence	int
)	O
;	O
}	O
int	O
fseeko	function
(	O
FILE	struct
*	O
fp	pointer
,	O
off_t	long
offset	long
,	O
int	O
whence	int
)	O
{	O
if	O
(	O
fp	pointer
->	O
_IO_read_end	pointer
==	O
fp	pointer
->	O
_IO_read_ptr	pointer
&&	O
fp	pointer
->	O
_IO_write_ptr	pointer
==	O
fp	pointer
->	O
_IO_write_base	pointer
&&	O
fp	pointer
->	O
_IO_save_base	pointer
==	O
NULL	O
)	O
{	O
off_t	long
pos	long
=	O
lseek	function
(	O
fileno	function
(	O
fp	pointer
)	O
,	O
offset	long
,	O
whence	int
)	O
;	O
if	O
(	O
pos	long
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
fp	pointer
->	O
_flags	int
&=	O
~	O
_IO_EOF_SEEN	int
;	O
fp	pointer
->	O
_offset	long
=	O
pos	long
;	O
return	O
0	int
;	O
}	O
return	O
fseeko	function
(	O
fp	pointer
,	O
offset	long
,	O
whence	int
)	O
;	O
}	O
struct	O
preliminary_header	struct
{	O
void	O
*	O
next	pointer
;	O
int	O
magic	int
;	O
}	O
;	O
union	O
header	union
{	O
void	O
*	O
next	pointer
;	O
struct	O
{	O
char	O
room	array
[	O
HEADER_SIZE	O
-	O
MAGIC_SIZE	O
]	O
;	O
int	O
word	int
;	O
}	O
magic	int
;	O
}	O
;	O
verify	O
(	O
HEADER_SIZE	O
==	O
sizeof	O
(	O
union	O
header	union
)	O
)	O
;	O
static	O
void	O
*	O
mmalloca_results	array
[	O
HASH_TABLE_SIZE	int
]	O
;	O
void	O
*	O
mmalloca	function
(	O
size_t	long
n	long
)	O
{	O
size_t	long
nplus	long
=	O
n	long
+	O
HEADER_SIZE	O
;	O
if	O
(	O
nplus	long
>=	O
n	long
)	O
{	O
void	O
*	O
p	pointer
=	O
malloc	function
(	O
nplus	long
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
slot	long
;	O
union	O
header	union
*	O
h	pointer
=	O
p	pointer
;	O
p	pointer
=	O
h	pointer
+	O
1	int
;	O
h	pointer
->	O
magic	int
.	O
word	int
=	O
MAGIC_NUMBER	int
;	O
slot	long
=	O
(	O
uintptr_t	long
)	O
p	pointer
%	O
HASH_TABLE_SIZE	int
;	O
h	pointer
->	O
next	pointer
=	O
mmalloca_results	array
[	O
slot	long
]	O
;	O
mmalloca_results	array
[	O
slot	long
]	O
=	O
p	pointer
;	O
return	O
p	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
void	O
freea	function
(	O
void	O
*	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
(	O
int	O
*	O
)	O
p	pointer
)	O
[	O
-	O
1	int
]	O
==	O
MAGIC_NUMBER	int
)	O
{	O
size_t	long
slot	long
=	O
(	O
uintptr_t	long
)	O
p	pointer
%	O
HASH_TABLE_SIZE	int
;	O
void	O
*	O
*	O
chain	pointer
=	O
&	O
mmalloca_results	array
[	O
slot	long
]	O
;	O
for	O
(	O
;	O
*	O
chain	pointer
!=	O
NULL	O
;	O
)	O
{	O
union	O
header	union
*	O
h	pointer
=	O
p	pointer
;	O
if	O
(	O
*	O
chain	pointer
==	O
p	pointer
)	O
{	O
union	O
header	union
*	O
p_begin	pointer
=	O
h	pointer
-	O
1	int
;	O
*	O
chain	pointer
=	O
p_begin	pointer
->	O
next	pointer
;	O
free	function
(	O
p_begin	pointer
)	O
;	O
return	O
;	O
}	O
h	pointer
=	O
*	O
chain	pointer
;	O
chain	pointer
=	O
&	O
h	pointer
[	O
-	O
1	int
]	O
.	O
next	pointer
;	O
}	O
}	O
}	O
}	O
int	O
save_cwd	function
(	O
struct	O
saved_cwd	struct
*	O
cwd	pointer
)	O
{	O
cwd	pointer
->	O
name	pointer
=	O
NULL	O
;	O
cwd	pointer
->	O
desc	int
=	O
open	function
(	O
"."	pointer
,	O
O_SEARCH	O
)	O
;	O
if	O
(	O
!	O
GNULIB_FCNTL_SAFER	int
)	O
cwd	pointer
->	O
desc	int
=	O
fd_safer	function
(	O
cwd	pointer
->	O
desc	int
)	O
;	O
if	O
(	O
cwd	pointer
->	O
desc	int
<	O
0	int
)	O
{	O
cwd	pointer
->	O
name	pointer
=	O
getcwd	function
(	O
NULL	O
,	O
0	int
)	O
;	O
return	O
cwd	pointer
->	O
name	pointer
?	O
0	int
:	O
-	O
1	int
;	O
}	O
set_cloexec_flag	function
(	O
cwd	pointer
->	O
desc	int
,	O
true	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
restore_cwd	function
(	O
const	O
struct	O
saved_cwd	struct
*	O
cwd	pointer
)	O
{	O
if	O
(	O
0	int
<=	O
cwd	pointer
->	O
desc	int
)	O
return	O
fchdir	function
(	O
cwd	pointer
->	O
desc	int
)	O
;	O
else	O
return	O
chdir_long	function
(	O
cwd	pointer
->	O
name	pointer
)	O
;	O
}	O
void	O
free_cwd	function
(	O
struct	O
saved_cwd	struct
*	O
cwd	pointer
)	O
{	O
if	O
(	O
cwd	pointer
->	O
desc	int
>=	O
0	int
)	O
close	pointer
(	O
cwd	pointer
->	O
desc	int
)	O
;	O
free	function
(	O
cwd	pointer
->	O
name	pointer
)	O
;	O
}	O
extern	O
int	O
__xpg_strerror_r	function
(	O
int	O
errnum	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
buflen	long
)	O
;	O
static	O
int	O
safe_copy	function
(	O
char	O
*	O
buf	pointer
,	O
size_t	long
buflen	long
,	O
const	O
char	O
*	O
msg	pointer
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
msg	pointer
)	O
;	O
int	O
ret	int
;	O
if	O
(	O
len	long
<	O
buflen	long
)	O
{	O
memcpy	function
(	O
buf	pointer
,	O
msg	pointer
,	O
len	long
+	O
1	int
)	O
;	O
ret	int
=	O
0	int
;	O
}	O
else	O
{	O
memcpy	function
(	O
buf	pointer
,	O
msg	pointer
,	O
buflen	long
-	O
1	int
)	O
;	O
buf	pointer
[	O
buflen	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
ret	int
=	O
ERANGE	int
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
strerror_r	function
(	O
int	O
errnum	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
buflen	long
)	O
{	O
if	O
(	O
buflen	long
<=	O
1	int
)	O
{	O
if	O
(	O
buflen	long
)	O
*	O
buf	pointer
=	O
'\0'	O
;	O
return	O
ERANGE	int
;	O
}	O
*	O
buf	pointer
=	O
'\0'	O
;	O
{	O
char	O
const	O
*	O
msg	pointer
=	O
strerror_override	O
(	O
errnum	int
)	O
;	O
if	O
(	O
msg	pointer
)	O
return	O
safe_copy	function
(	O
buf	pointer
,	O
buflen	long
,	O
msg	pointer
)	O
;	O
}	O
{	O
int	O
ret	int
;	O
int	O
saved_errno	int
=	O
errno	O
;	O
{	O
ret	int
=	O
__xpg_strerror_r	function
(	O
errnum	int
,	O
buf	pointer
,	O
buflen	long
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
ret	int
=	O
errno	O
;	O
if	O
(	O
!	O
*	O
buf	pointer
)	O
{	O
safe_copy	function
(	O
buf	pointer
,	O
buflen	long
,	O
strerror_r	function
(	O
errnum	int
,	O
buf	pointer
,	O
buflen	long
)	O
)	O
;	O
}	O
}	O
if	O
(	O
ret	int
==	O
EINVAL	int
&&	O
!	O
*	O
buf	pointer
)	O
snprintf	function
(	O
buf	pointer
,	O
buflen	long
,	O
"Unknown error %d"	pointer
,	O
errnum	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
ret	int
;	O
}	O
}	O
size_t	long
strnlen1	function
(	O
const	O
char	O
*	O
string	pointer
,	O
size_t	long
maxlen	long
)	O
{	O
const	O
char	O
*	O
end	pointer
=	O
(	O
const	O
char	O
*	O
)	O
memchr	function
(	O
string	pointer
,	O
'\0'	O
,	O
maxlen	long
)	O
;	O
if	O
(	O
end	pointer
!=	O
NULL	O
)	O
return	O
end	pointer
-	O
string	pointer
+	O
1	int
;	O
else	O
return	O
maxlen	long
;	O
}	O
typedef	O
int	O
dummy	int
;	O
static	O
strtol_error	enum
bkm_scale	function
(	O
__strtol_t	O
*	O
x	pointer
,	O
int	O
scale_factor	int
)	O
{	O
if	O
(	O
TYPE_SIGNED	O
(	O
__strtol_t	O
)	O
&&	O
*	O
x	pointer
<	O
STRTOL_T_MINIMUM	O
/	O
scale_factor	int
)	O
{	O
*	O
x	pointer
=	O
STRTOL_T_MINIMUM	O
;	O
return	O
LONGINT_OVERFLOW	int
;	O
}	O
if	O
(	O
STRTOL_T_MAXIMUM	O
/	O
scale_factor	int
<	O
*	O
x	pointer
)	O
{	O
*	O
x	pointer
=	O
STRTOL_T_MAXIMUM	O
;	O
return	O
LONGINT_OVERFLOW	int
;	O
}	O
*	O
x	pointer
*=	O
scale_factor	int
;	O
return	O
LONGINT_OK	int
;	O
}	O
static	O
strtol_error	enum
bkm_scale_by_power	function
(	O
__strtol_t	O
*	O
x	pointer
,	O
int	O
base	int
,	O
int	O
power	int
)	O
{	O
strtol_error	enum
err	enum
=	O
LONGINT_OK	int
;	O
while	O
(	O
power	int
--	O
)	O
err	enum
|=	O
bkm_scale	function
(	O
x	pointer
,	O
base	int
)	O
;	O
return	O
err	enum
;	O
}	O
strtol_error	enum
__xstrtol	O
(	O
const	O
char	O
*	O
s	pointer
,	O
char	O
*	O
*	O
ptr	pointer
,	O
int	O
strtol_base	int
,	O
__strtol_t	O
*	O
val	int
,	O
const	O
char	O
*	O
valid_suffixes	pointer
)	O
{	O
char	O
*	O
t_ptr	pointer
;	O
char	O
*	O
*	O
p	pointer
;	O
__strtol_t	O
tmp	long
;	O
strtol_error	enum
err	enum
=	O
LONGINT_OK	int
;	O
assure	O
(	O
0	int
<=	O
strtol_base	int
&&	O
strtol_base	int
<=	O
36	int
)	O
;	O
p	pointer
=	O
(	O
ptr	pointer
?	O
ptr	pointer
:	O
&	O
t_ptr	pointer
)	O
;	O
errno	O
=	O
0	int
;	O
if	O
(	O
!	O
TYPE_SIGNED	O
(	O
__strtol_t	O
)	O
)	O
{	O
const	O
char	O
*	O
q	pointer
=	O
s	pointer
;	O
unsigned	O
char	O
ch	char
=	O
*	O
q	pointer
;	O
while	O
(	O
isspace	function
(	O
ch	char
)	O
)	O
ch	char
=	O
*	O
++	O
q	pointer
;	O
if	O
(	O
ch	char
==	O
'-'	O
)	O
return	O
LONGINT_INVALID	int
;	O
}	O
tmp	long
=	O
__strtol	O
(	O
s	pointer
,	O
p	pointer
,	O
strtol_base	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
s	pointer
)	O
{	O
if	O
(	O
valid_suffixes	pointer
&&	O
*	O
*	O
p	pointer
&&	O
strchr	function
(	O
valid_suffixes	pointer
,	O
*	O
*	O
p	pointer
)	O
)	O
tmp	long
=	O
1	int
;	O
else	O
return	O
LONGINT_INVALID	int
;	O
}	O
else	O
if	O
(	O
errno	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
ERANGE	int
)	O
return	O
LONGINT_INVALID	int
;	O
err	enum
=	O
LONGINT_OVERFLOW	int
;	O
}	O
if	O
(	O
!	O
valid_suffixes	pointer
)	O
{	O
*	O
val	int
=	O
tmp	long
;	O
return	O
err	enum
;	O
}	O
if	O
(	O
*	O
*	O
p	pointer
!=	O
'\0'	O
)	O
{	O
int	O
base	int
=	O
1024	int
;	O
int	O
suffixes	int
=	O
1	int
;	O
strtol_error	enum
overflow	enum
;	O
if	O
(	O
!	O
strchr	function
(	O
valid_suffixes	pointer
,	O
*	O
*	O
p	pointer
)	O
)	O
{	O
*	O
val	int
=	O
tmp	long
;	O
return	O
err	enum
|	O
LONGINT_INVALID_SUFFIX_CHAR	int
;	O
}	O
if	O
(	O
strchr	function
(	O
valid_suffixes	pointer
,	O
'0'	O
)	O
)	O
{	O
switch	O
(	O
p	pointer
[	O
0	int
]	O
[	O
1	int
]	O
)	O
{	O
case	O
'i'	O
:	O
if	O
(	O
p	pointer
[	O
0	int
]	O
[	O
2	int
]	O
==	O
'B'	O
)	O
suffixes	int
+=	O
2	int
;	O
break	O
;	O
case	O
'B'	O
:	O
case	O
'D'	O
:	O
base	int
=	O
1000	int
;	O
suffixes	int
++	O
;	O
break	O
;	O
}	O
}	O
switch	O
(	O
*	O
*	O
p	pointer
)	O
{	O
case	O
'b'	O
:	O
overflow	enum
=	O
bkm_scale	function
(	O
&	O
tmp	long
,	O
512	int
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
overflow	enum
=	O
bkm_scale	function
(	O
&	O
tmp	long
,	O
1024	int
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
overflow	enum
=	O
LONGINT_OK	int
;	O
break	O
;	O
case	O
'E'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
6	int
)	O
;	O
break	O
;	O
case	O
'G'	O
:	O
case	O
'g'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
3	int
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
case	O
'K'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
case	O
'm'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
2	int
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
5	int
)	O
;	O
break	O
;	O
case	O
'T'	O
:	O
case	O
't'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
4	int
)	O
;	O
break	O
;	O
case	O
'w'	O
:	O
overflow	enum
=	O
bkm_scale	function
(	O
&	O
tmp	long
,	O
2	int
)	O
;	O
break	O
;	O
case	O
'Y'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
8	int
)	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
7	int
)	O
;	O
break	O
;	O
default	O
:	O
*	O
val	int
=	O
tmp	long
;	O
return	O
err	enum
|	O
LONGINT_INVALID_SUFFIX_CHAR	int
;	O
}	O
err	enum
|=	O
overflow	enum
;	O
*	O
p	pointer
+=	O
suffixes	int
;	O
if	O
(	O
*	O
*	O
p	pointer
)	O
err	enum
|=	O
LONGINT_INVALID_SUFFIX_CHAR	int
;	O
}	O
*	O
val	int
=	O
tmp	long
;	O
return	O
err	enum
;	O
}	O
bool	bool
yesno	function
(	O
void	O
)	O
{	O
bool	bool
yes	bool
;	O
char	O
*	O
response	pointer
=	O
NULL	O
;	O
size_t	long
response_size	long
=	O
0	int
;	O
ssize_t	long
response_len	long
=	O
getline	function
(	O
&	O
response	pointer
,	O
&	O
response_size	pointer
,	O
stdin	pointer
)	O
;	O
if	O
(	O
response_len	int
<=	O
0	int
)	O
yes	bool
=	O
false	int
;	O
else	O
{	O
if	O
(	O
response	pointer
[	O
response_len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
response	pointer
[	O
response_len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
yes	long
=	O
(	O
0	int
<	O
rpmatch	function
(	O
response	pointer
)	O
)	O
;	O
}	O
free	function
(	O
response	pointer
)	O
;	O
return	O
yes	function
;	O
}	O
static	O
size_t	long
decide_size	function
(	O
size_t	long
current	long
,	O
size_t	long
wanted	long
)	O
{	O
size_t	long
newsize	long
;	O
if	O
(	O
0	int
==	O
current	long
)	O
newsize	long
=	O
SIZE_DEFAULT	long
;	O
else	O
newsize	long
=	O
current	long
;	O
while	O
(	O
newsize	long
<	O
wanted	long
)	O
{	O
if	O
(	O
2	int
*	O
newsize	long
<	O
newsize	long
)	O
return	O
wanted	long
;	O
newsize	long
*=	O
2	int
;	O
}	O
return	O
newsize	long
;	O
}	O
void	O
*	O
extendbuf	function
(	O
void	O
*	O
existing	pointer
,	O
size_t	long
wanted	long
,	O
size_t	long
*	O
allocated	pointer
)	O
{	O
int	O
saved_errno	int
;	O
size_t	long
newsize	long
;	O
void	O
*	O
result	pointer
;	O
saved_errno	int
=	O
errno	O
;	O
assert	O
(	O
wanted	int
>	O
0u	int
)	O
;	O
newsize	long
=	O
decide_size	function
(	O
*	O
allocated	pointer
,	O
wanted	pointer
)	O
;	O
if	O
(	O
(	O
*	O
allocated	pointer
)	O
==	O
0	int
)	O
{	O
assert	O
(	O
NULL	O
==	O
existing	pointer
)	O
;	O
(	O
*	O
allocated	pointer
)	O
=	O
newsize	long
;	O
result	pointer
=	O
malloc	function
(	O
newsize	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
newsize	long
!=	O
(	O
*	O
allocated	pointer
)	O
)	O
{	O
(	O
*	O
allocated	pointer
)	O
=	O
newsize	long
;	O
result	pointer
=	O
realloc	function
(	O
existing	pointer
,	O
newsize	long
)	O
;	O
if	O
(	O
NULL	O
==	O
result	pointer
)	O
{	O
saved_errno	int
=	O
errno	O
;	O
}	O
}	O
else	O
{	O
result	pointer
=	O
existing	pointer
;	O
}	O
}	O
if	O
(	O
result	pointer
)	O
{	O
errno	O
=	O
saved_errno	int
;	O
}	O
return	O
result	pointer
;	O
}	O
void	O
*	O
xextendbuf	function
(	O
void	O
*	O
existing	pointer
,	O
size_t	long
wanted	long
,	O
size_t	long
*	O
allocated	pointer
)	O
{	O
void	O
*	O
p	pointer
=	O
extendbuf	function
(	O
existing	pointer
,	O
wanted	pointer
,	O
allocated	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
p	pointer
)	O
{	O
free	function
(	O
existing	pointer
)	O
;	O
xalloc_die	function
(	O
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
int	O
set_cloexec_flag	function
(	O
int	O
desc	int
,	O
bool	bool
value	bool
)	O
{	O
int	O
flags	int
=	O
fcntl	function
(	O
desc	int
,	O
F_GETFD	int
,	O
0	int
)	O
;	O
if	O
(	O
0	int
<=	O
flags	int
)	O
{	O
int	O
newflags	int
=	O
(	O
value	bool
?	O
flags	int
|	O
FD_CLOEXEC	int
:	O
flags	int
&	O
~	O
FD_CLOEXEC	int
)	O
;	O
if	O
(	O
flags	int
==	O
newflags	int
||	O
fcntl	function
(	O
desc	int
,	O
F_SETFD	int
,	O
newflags	int
)	O
!=	O
-	O
1	int
)	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
dup_cloexec	function
(	O
int	O
fd	int
)	O
{	O
return	O
fcntl	function
(	O
fd	int
,	O
F_DUPFD_CLOEXEC	int
,	O
0	int
)	O
;	O
}	O
int	O
dup_safer	function
(	O
int	O
fd	int
)	O
{	O
return	O
fcntl	function
(	O
fd	int
,	O
F_DUPFD	int
,	O
STDERR_FILENO	int
+	O
1	int
)	O
;	O
}	O
int	O
rpl_fclose	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
int	O
saved_errno	int
=	O
0	int
;	O
int	O
fd	int
;	O
int	O
result	int
=	O
0	int
;	O
fd	array
=	O
fileno	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
fd	array
<	O
0	int
)	O
return	O
fclose_nothrow	O
(	O
fp	pointer
)	O
;	O
if	O
(	O
(	O
!	O
freading	O
(	O
fp	pointer
)	O
||	O
lseek	function
(	O
fileno	function
(	O
fp	pointer
)	O
,	O
0	int
,	O
SEEK_CUR	int
)	O
!=	O
-	O
1	int
)	O
&&	O
fflush	function
(	O
fp	pointer
)	O
)	O
saved_errno	int
=	O
errno	O
;	O
result	int
=	O
fclose_nothrow	O
(	O
fp	pointer
)	O
;	O
if	O
(	O
saved_errno	int
!=	O
0	int
)	O
{	O
errno	O
=	O
saved_errno	int
;	O
result	pointer
=	O
EOF	O
;	O
}	O
return	O
result	int
;	O
}	O
int	O
rpl_fcntl	function
(	O
int	O
fd	int
,	O
int	O
action	int
,	O
...	O
)	O
{	O
va_list	array
arg	array
;	O
int	O
result	int
=	O
-	O
1	int
;	O
va_start	O
(	O
arg	array
,	O
action	int
)	O
;	O
switch	O
(	O
action	int
)	O
{	O
case	O
F_DUPFD	int
:	O
{	O
int	O
target	int
=	O
va_arg	O
(	O
arg	array
,	O
int	O
)	O
;	O
if	O
(	O
target	int
<	O
0	int
||	O
getdtablesize	function
(	O
)	O
<=	O
target	int
)	O
errno	O
=	O
EINVAL	int
;	O
else	O
{	O
int	O
flags	int
=	O
fcntl	function
(	O
fd	int
,	O
F_GETFD	int
)	O
;	O
if	O
(	O
flags	int
<	O
0	int
)	O
{	O
result	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
result	int
=	O
fcntl	function
(	O
fd	int
,	O
action	int
,	O
target	int
)	O
;	O
if	O
(	O
0	int
<=	O
result	int
&&	O
fcntl	function
(	O
fd	int
,	O
F_SETFD	int
,	O
flags	int
)	O
==	O
-	O
1	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
close	function
(	O
result	int
)	O
;	O
result	int
=	O
-	O
1	int
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
}	O
break	O
;	O
}	O
case	O
F_DUPFD_CLOEXEC	int
:	O
{	O
int	O
target	int
=	O
va_arg	O
(	O
arg	array
,	O
int	O
)	O
;	O
static	O
int	O
have_dupfd_cloexec	int
=	O
GNULIB_defined_F_DUPFD_CLOEXEC	int
?	O
-	O
1	int
:	O
0	int
;	O
if	O
(	O
0	int
<=	O
have_dupfd_cloexec	int
)	O
{	O
result	int
=	O
fcntl	function
(	O
fd	int
,	O
action	int
,	O
target	int
)	O
;	O
if	O
(	O
0	int
<=	O
result	int
||	O
errno	O
!=	O
EINVAL	int
)	O
{	O
have_dupfd_cloexec	int
=	O
1	int
;	O
}	O
else	O
{	O
result	int
=	O
rpl_fcntl	function
(	O
fd	int
,	O
F_DUPFD	int
,	O
target	int
)	O
;	O
if	O
(	O
result	int
<	O
0	int
)	O
break	O
;	O
have_dupfd_cloexec	int
=	O
-	O
1	int
;	O
}	O
}	O
else	O
result	int
=	O
rpl_fcntl	function
(	O
fd	int
,	O
F_DUPFD	int
,	O
target	int
)	O
;	O
if	O
(	O
0	int
<=	O
result	int
&&	O
have_dupfd_cloexec	int
==	O
-	O
1	int
)	O
{	O
int	O
flags	int
=	O
fcntl	function
(	O
result	int
,	O
F_GETFD	int
)	O
;	O
if	O
(	O
flags	int
<	O
0	int
||	O
fcntl	function
(	O
result	int
,	O
F_SETFD	int
,	O
flags	int
|	O
FD_CLOEXEC	int
)	O
==	O
-	O
1	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
close	function
(	O
result	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
result	int
=	O
-	O
1	int
;	O
}	O
}	O
break	O
;	O
}	O
default	O
:	O
{	O
void	O
*	O
p	pointer
=	O
va_arg	O
(	O
arg	array
,	O
void	O
*	O
)	O
;	O
result	int
=	O
fcntl	function
(	O
fd	int
,	O
action	int
,	O
p	pointer
)	O
;	O
break	O
;	O
}	O
}	O
va_end	O
(	O
arg	array
)	O
;	O
return	O
result	int
;	O
}	O
int	O
fd_safer_flag	function
(	O
int	O
fd	array
,	O
int	O
flag	int
)	O
{	O
if	O
(	O
STDIN_FILENO	int
<=	O
fd	array
&&	O
fd	array
<=	O
STDERR_FILENO	int
)	O
{	O
int	O
f	int
=	O
dup_safer_flag	function
(	O
fd	array
,	O
flag	int
)	O
;	O
int	O
e	int
=	O
errno	O
;	O
close	function
(	O
fd	array
)	O
;	O
errno	O
=	O
e	int
;	O
fd	array
=	O
f	int
;	O
}	O
return	O
fd	array
;	O
}	O
typedef	O
struct	O
{	O
volatile	O
sig_atomic_t	int
used	int
;	O
volatile	O
pid_t	int
child	int
;	O
}	O
slaves_entry_t	struct
;	O
static	O
slaves_entry_t	struct
static_slaves	array
[	O
32	int
]	O
;	O
static	O
slaves_entry_t	struct
*	O
volatile	O
slaves	pointer
=	O
static_slaves	array
;	O
static	O
sig_atomic_t	int
volatile	O
slaves_count	int
=	O
0	int
;	O
static	O
size_t	long
slaves_allocated	long
=	O
SIZEOF	O
(	O
static_slaves	array
)	O
;	O
static	O
void	O
cleanup_slaves	function
(	O
void	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
n	long
=	O
slaves_count	int
;	O
if	O
(	O
n	long
==	O
0	int
)	O
break	O
;	O
n	long
--	O
;	O
slaves_count	int
=	O
n	long
;	O
if	O
(	O
slaves	pointer
[	O
n	long
]	O
.	O
used	int
)	O
{	O
pid_t	int
slave	int
=	O
slaves	pointer
[	O
n	long
]	O
.	O
child	int
;	O
kill	function
(	O
slave	int
,	O
TERMINATOR	O
)	O
;	O
}	O
}	O
}	O
void	O
register_slave_subprocess	function
(	O
pid_t	int
child	int
)	O
{	O
static	O
bool	bool
cleanup_slaves_registered	bool
=	O
false	int
;	O
if	O
(	O
!	O
cleanup_slaves_registered	bool
)	O
{	O
atexit	function
(	O
cleanup_slaves	function
)	O
;	O
at_fatal_signal	function
(	O
cleanup_slaves	function
)	O
;	O
cleanup_slaves_registered	bool
=	O
true	int
;	O
}	O
{	O
slaves_entry_t	struct
*	O
s	long
=	O
slaves	pointer
;	O
slaves_entry_t	struct
*	O
s_end	pointer
=	O
s	long
+	O
slaves_count	int
;	O
for	O
(	O
;	O
s	long
<	O
s_end	pointer
;	O
s	long
++	O
)	O
if	O
(	O
!	O
s	long
->	O
used	int
)	O
{	O
s	long
->	O
child	int
=	O
child	int
;	O
s	long
->	O
used	int
=	O
1	int
;	O
return	O
;	O
}	O
}	O
if	O
(	O
slaves_count	int
==	O
slaves_allocated	long
)	O
{	O
slaves_entry_t	struct
*	O
old_slaves	pointer
=	O
slaves	pointer
;	O
size_t	long
new_slaves_allocated	long
=	O
2	int
*	O
slaves_allocated	long
;	O
slaves_entry_t	struct
*	O
new_slaves	pointer
=	O
(	O
slaves_entry_t	struct
*	O
)	O
malloc	function
(	O
new_slaves_allocated	long
*	O
sizeof	O
(	O
slaves_entry_t	struct
)	O
)	O
;	O
if	O
(	O
new_slaves	pointer
==	O
NULL	O
)	O
{	O
kill	function
(	O
child	int
,	O
TERMINATOR	O
)	O
;	O
xalloc_die	function
(	O
)	O
;	O
}	O
memcpy	function
(	O
new_slaves	pointer
,	O
old_slaves	pointer
,	O
slaves_allocated	long
*	O
sizeof	O
(	O
slaves_entry_t	struct
)	O
)	O
;	O
slaves	pointer
=	O
new_slaves	pointer
;	O
slaves_allocated	long
=	O
new_slaves_allocated	long
;	O
if	O
(	O
old_slaves	pointer
!=	O
static_slaves	array
)	O
free	function
(	O
old_slaves	pointer
)	O
;	O
}	O
slaves	pointer
[	O
slaves_count	int
]	O
.	O
child	int
=	O
child	int
;	O
slaves	pointer
[	O
slaves_count	int
]	O
.	O
used	int
=	O
1	int
;	O
slaves_count	int
++	O
;	O
}	O
static	O
void	O
unregister_slave_subprocess	function
(	O
pid_t	int
child	int
)	O
{	O
slaves_entry_t	struct
*	O
s	long
=	O
slaves	pointer
;	O
slaves_entry_t	struct
*	O
s_end	pointer
=	O
s	long
+	O
slaves_count	int
;	O
for	O
(	O
;	O
s	long
<	O
s_end	pointer
;	O
s	long
++	O
)	O
if	O
(	O
s	long
->	O
used	int
&&	O
s	long
->	O
child	int
==	O
child	int
)	O
s	long
->	O
used	int
=	O
0	int
;	O
}	O
int	O
wait_subprocess	function
(	O
pid_t	int
child	int
,	O
const	O
char	O
*	O
progname	pointer
,	O
bool	bool
ignore_sigpipe	bool
,	O
bool	bool
null_stderr	bool
,	O
bool	bool
slave_process	bool
,	O
bool	bool
exit_on_error	bool
,	O
int	O
*	O
termsigp	pointer
)	O
{	O
int	O
status	int
;	O
if	O
(	O
termsigp	pointer
!=	O
NULL	O
)	O
*	O
termsigp	pointer
=	O
0	int
;	O
status	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
result	int
=	O
waitpid	function
(	O
child	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
result	int
!=	O
child	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
if	O
(	O
exit_on_error	bool
||	O
!	O
null_stderr	bool
)	O
error	function
(	O
exit_on_error	bool
?	O
EXIT_FAILURE	int
:	O
0	int
,	O
errno	O
,	O
_	O
(	O
"%s subprocess"	pointer
)	O
,	O
progname	pointer
)	O
;	O
return	O
127	int
;	O
}	O
if	O
(	O
!	O
WIFSTOPPED	O
(	O
status	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
slave_process	bool
)	O
unregister_slave_subprocess	function
(	O
child	int
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
if	O
(	O
termsigp	pointer
!=	O
NULL	O
)	O
*	O
termsigp	pointer
=	O
WTERMSIG	O
(	O
status	int
)	O
;	O
if	O
(	O
WTERMSIG	O
(	O
status	int
)	O
==	O
SIGPIPE	int
&&	O
ignore_sigpipe	bool
)	O
return	O
0	int
;	O
if	O
(	O
exit_on_error	bool
||	O
(	O
!	O
null_stderr	bool
&&	O
termsigp	pointer
==	O
NULL	O
)	O
)	O
error	function
(	O
exit_on_error	bool
?	O
EXIT_FAILURE	int
:	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess got fatal signal %d"	pointer
)	O
,	O
progname	pointer
,	O
(	O
int	O
)	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
return	O
127	int
;	O
}	O
if	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
==	O
127	int
)	O
{	O
if	O
(	O
exit_on_error	bool
||	O
!	O
null_stderr	bool
)	O
error	function
(	O
exit_on_error	bool
?	O
EXIT_FAILURE	int
:	O
0	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed"	pointer
)	O
,	O
progname	pointer
)	O
;	O
return	O
127	int
;	O
}	O
return	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
i	int
;	O
FILE	struct
*	O
out	pointer
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
return	O
0	int
;	O
out	pointer
=	O
fopen	function
(	O
argv	pointer
[	O
argc	int
-	O
1	int
]	O
,	O
"a+b"	pointer
)	O
;	O
if	O
(	O
out	pointer
==	O
0	int
)	O
{	O
perror	function
(	O
"cant open"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
fopen	function
(	O
argv	array
[	O
i	int
]	O
,	O
"rb"	pointer
)	O
;	O
int	O
ch	int
;	O
if	O
(	O
fp	pointer
==	O
0	int
)	O
{	O
perror	function
(	O
"cant open"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
while	O
(	O
1	int
)	O
{	O
ch	int
=	O
getc	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
ch	int
==	O
EOF	O
&&	O
feof	function
(	O
fp	pointer
)	O
)	O
{	O
fclose	function
(	O
fp	pointer
)	O
;	O
break	O
;	O
}	O
else	O
putc	function
(	O
ch	int
,	O
out	pointer
)	O
;	O
}	O
}	O
fclose	function
(	O
out	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
bfffo	function
(	O
x	double
)	O
unsigned	O
plong	int
x	int
;	O
{	O
int	O
sc	int
;	O
static	O
int	O
tabshi	array
[	O
16	int
]	O
=	O
{	O
4	int
,	O
3	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
if	O
(	O
x	int
&	O
(	O
0xffff0000	O
)	O
)	O
sc	int
=	O
0	int
;	O
else	O
{	O
sc	int
=	O
16	int
;	O
x	array
<<=	O
16	int
;	O
}	O
if	O
(	O
!	O
(	O
x	int
&	O
(	O
0xff000000	O
)	O
)	O
)	O
{	O
sc	int
+=	O
8	int
;	O
x	int
<<=	O
8	int
;	O
}	O
if	O
(	O
x	int
&	O
(	O
0xf0000000	int
)	O
)	O
x	array
>>=	O
28	int
;	O
else	O
{	O
sc	pointer
+=	O
4	int
;	O
x	int
>>=	O
24	int
;	O
}	O
sc	pointer
+=	O
tabshi	array
[	O
x	int
]	O
;	O
return	O
sc	int
;	O
}	O
ulong	O
mulul3	function
(	O
a	O
,	O
b	O
,	O
h	int
)	O
unsigned	O
int	O
a	int
,	O
b	int
,	O
*	O
h	pointer
;	O
{	O
unsigned	O
int	O
temph	int
,	O
templ	int
,	O
ah	long
,	O
al	int
,	O
i	int
;	O
ah	int
=	O
0	int
;	O
al	int
=	O
0	int
;	O
{	O
if	O
(	O
b	int
&	O
1	int
)	O
{	O
temph	int
=	O
0	int
;	O
templ	int
=	O
a	int
;	O
lladd	function
(	O
temph	pointer
,	O
templ	pointer
,	O
ah	long
,	O
al	int
)	O
;	O
}	O
b	int
=	O
b	int
>>	O
1	int
;	O
}	O
i	int
=	O
1	int
;	O
while	O
(	O
b	int
)	O
{	O
if	O
(	O
b	int
&	O
1	int
)	O
{	O
llshift	function
(	O
a	int
,	O
i	int
,	O
temph	int
,	O
templ	pointer
)	O
;	O
lladd	function
(	O
temph	pointer
,	O
templ	pointer
,	O
ah	long
,	O
al	long
)	O
;	O
}	O
i	int
++	O
;	O
b	int
=	O
b	int
>>	O
1	int
;	O
}	O
*	O
h	int
=	O
ah	long
;	O
return	O
al	long
;	O
}	O
void	O
bds_unwind	function
(	O
bds_ptr	pointer
new_bds_top	pointer
)	O
{	O
for	O
(	O
;	O
bds_top	int
>	O
new_bds_top	int
;	O
bds_top	int
--	O
)	O
(	O
bds_top	pointer
->	O
bds_sym	pointer
)	O
->	O
s	pointer
.	O
s_dbind	O
=	O
bds_top	pointer
->	O
bds_val	pointer
;	O
}	O
object	O
sLotherwise	int
;	O
static	O
void	O
FFN	function
(	O
Fif	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
||	O
endp	function
(	O
MMcdr	function
(	O
form	int
)	O
)	O
)	O
FEtoo_few_argumentsF	function
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	function
(	O
MMcddr	function
(	O
form	int
)	O
)	O
&&	O
!	O
endp	function
(	O
MMcdddr	function
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	function
(	O
form	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
form	int
)	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
==	O
Cnil	O
)	O
if	O
(	O
endp	function
(	O
MMcddr	function
(	O
form	int
)	O
)	O
)	O
{	O
vs_top	O
=	O
vs_base	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcaddr	function
(	O
form	O
)	O
)	O
;	O
}	O
else	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcadr	function
(	O
form	int
)	O
)	O
;	O
}	O
}	O
static	O
void	O
FFN	function
(	O
Fcond	int
)	O
(	O
object	int
args	int
)	O
{	O
object	int
*	O
top	O
=	O
vs_top	O
;	O
object	O
clause	int
;	O
object	O
conseq	O
;	O
while	O
(	O
!	O
endp	function
(	O
args	int
)	O
)	O
{	O
clause	int
=	O
MMcar	function
(	O
args	int
)	O
;	O
if	O
(	O
type_of	function
(	O
clause	int
)	O
!=	O
t_cons	O
)	O
FEerror	function
(	O
"~S is an illegal COND clause."	pointer
,	O
1	int
,	O
clause	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
clause	int
)	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
!=	O
Cnil	O
)	O
{	O
conseq	int
=	O
MMcdr	function
(	O
clause	int
)	O
;	O
if	O
(	O
endp	function
(	O
conseq	int
)	O
)	O
{	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
return	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
conseq	int
)	O
)	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcar	function
(	O
conseq	int
)	O
)	O
;	O
conseq	int
=	O
MMcdr	function
(	O
conseq	int
)	O
;	O
}	O
return	O
;	O
}	O
vs_top	O
=	O
top	O
;	O
args	O
=	O
MMcdr	function
(	O
args	int
)	O
;	O
}	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fcase	int
)	O
(	O
object	O
arg	int
)	O
{	O
object	int
*	O
top	O
=	O
vs_top	O
;	O
object	O
clause	int
;	O
object	O
key	O
;	O
object	O
conseq	O
;	O
if	O
(	O
endp	function
(	O
arg	O
)	O
)	O
FEtoo_few_argumentsF	function
(	O
arg	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
arg	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
arg	O
=	O
MMcdr	function
(	O
arg	int
)	O
;	O
while	O
(	O
!	O
endp	function
(	O
arg	int
)	O
)	O
{	O
clause	int
=	O
MMcar	function
(	O
arg	int
)	O
;	O
if	O
(	O
type_of	function
(	O
clause	int
)	O
!=	O
t_cons	O
)	O
FEerror	function
(	O
"~S is an illegal CASE clause."	pointer
,	O
1	int
,	O
clause	int
)	O
;	O
key	O
=	O
MMcar	function
(	O
clause	int
)	O
;	O
conseq	int
=	O
MMcdr	function
(	O
clause	int
)	O
;	O
if	O
(	O
type_of	function
(	O
key	int
)	O
==	O
t_cons	O
)	O
do	O
{	O
if	O
(	O
eql	function
(	O
MMcar	function
(	O
key	O
)	O
,	O
top	O
[	O
0	int
]	O
)	O
)	O
goto	O
FOUND	O
;	O
key	O
=	O
MMcdr	function
(	O
key	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
key	int
)	O
)	O
;	O
else	O
if	O
(	O
key	int
==	O
Cnil	O
)	O
;	O
else	O
if	O
(	O
key	int
==	O
Ct	O
||	O
key	int
==	O
sLotherwise	int
||	O
eql	function
(	O
key	pointer
,	O
top	O
[	O
0	int
]	O
)	O
)	O
goto	O
FOUND	O
;	O
arg	int
=	O
MMcdr	function
(	O
arg	int
)	O
;	O
}	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
return	O
;	O
FOUND	O
:	O
if	O
(	O
endp	function
(	O
conseq	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcar	function
(	O
conseq	int
)	O
)	O
;	O
conseq	int
=	O
MMcdr	function
(	O
conseq	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
conseq	int
)	O
)	O
;	O
return	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fwhen	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
form	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
form	int
)	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
==	O
Cnil	O
)	O
{	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
form	int
=	O
MMcdr	function
(	O
form	int
)	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcar	function
(	O
form	int
)	O
)	O
;	O
form	int
=	O
MMcdr	function
(	O
form	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
form	int
)	O
)	O
;	O
}	O
}	O
static	O
void	O
FFN	function
(	O
Funless	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
form	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
form	int
)	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
==	O
Cnil	O
)	O
{	O
vs_top	O
=	O
top	O
;	O
form	int
=	O
MMcdr	function
(	O
form	int
)	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcar	function
(	O
form	int
)	O
)	O
;	O
form	int
=	O
MMcdr	function
(	O
form	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
form	int
)	O
)	O
;	O
}	O
else	O
{	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
}	O
void	O
gcl_init_conditional	function
(	O
void	O
)	O
{	O
make_special_form	function
(	O
"IF"	pointer
,	O
Fif	int
)	O
;	O
make_special_form	function
(	O
"COND"	pointer
,	O
Fcond	int
)	O
;	O
make_special_form	function
(	O
"CASE"	pointer
,	O
Fcase	int
)	O
;	O
make_special_form	function
(	O
"WHEN"	pointer
,	O
Fwhen	int
)	O
;	O
make_special_form	function
(	O
"UNLESS"	pointer
,	O
Funless	int
)	O
;	O
sLotherwise	int
=	O
make_ordinary	function
(	O
"OTHERWISE"	pointer
)	O
;	O
enter_mark_origin	function
(	O
&	O
sLotherwise	O
)	O
;	O
}	O
static	O
object	O
rando	function
(	O
object	O
x	int
,	O
object	O
rs	O
)	O
{	O
enum	O
type	enum
tx	enum
;	O
object	int
base	int
,	O
out	pointer
,	O
z	int
;	O
fixnum	O
fbase	int
;	O
double	O
d	int
;	O
tx	double
=	O
type_of	function
(	O
x	int
)	O
;	O
if	O
(	O
number_compare	function
(	O
x	double
,	O
small_fixnum	function
(	O
0	int
)	O
)	O
!=	O
1	int
)	O
FEwrong_type_argument	function
(	O
TSpositive_number	int
,	O
x	int
)	O
;	O
if	O
(	O
tx	int
==	O
t_bignum	O
)	O
{	O
out	pointer
=	O
new_bignum	function
(	O
)	O
;	O
base	int
=	O
x	int
;	O
fbase	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
out	pointer
=	O
big_fixnum1	int
;	O
fbase	int
=	O
tx	int
==	O
t_fixnum	O
?	O
fix	function
(	O
x	int
)	O
:	O
MOST_POSITIVE_FIX	int
;	O
mpz_set_si	O
(	O
MP	function
(	O
big_fixnum2	int
)	O
,	O
fbase	int
)	O
;	O
base	int
=	O
big_fixnum2	int
;	O
}	O
mpz_urandomm	O
(	O
MP	function
(	O
out	pointer
)	O
,	O
&	O
rs	struct
->	O
rnd	struct
.	O
rnd_state	pointer
,	O
MP	function
(	O
base	int
)	O
)	O
;	O
switch	O
(	O
tx	int
)	O
{	O
case	O
t_fixnum	O
:	O
return	O
make_fixnum	function
(	O
mpz_get_si	function
(	O
MP	function
(	O
out	O
)	O
)	O
)	O
;	O
case	O
t_bignum	O
:	O
return	O
normalize_big	function
(	O
out	pointer
)	O
;	O
case	O
t_shortfloat	O
:	O
case	O
t_longfloat	O
:	O
d	pointer
=	O
mpz_get_d	O
(	O
MP	function
(	O
out	pointer
)	O
)	O
;	O
d	int
/=	O
(	O
double	O
)	O
fbase	int
;	O
z	pointer
=	O
alloc_object	O
(	O
tx	int
)	O
;	O
if	O
(	O
tx	int
==	O
t_shortfloat	O
)	O
sf	function
(	O
z	int
)	O
=	O
sf	function
(	O
x	double
)	O
*	O
d	pointer
;	O
else	O
lf	function
(	O
z	double
)	O
=	O
lf	function
(	O
x	double
)	O
*	O
d	pointer
;	O
return	O
z	pointer
;	O
default	O
:	O
FEerror	function
(	O
"~S is not an integer nor a floating-point number."	pointer
,	O
1	int
,	O
x	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
}	O
void	O
reinit_gmp	function
(	O
)	O
{	O
}	O
void	O
init_gmp_rnd_state	function
(	O
__gmp_randstate_struct	struct
*	O
x	pointer
)	O
{	O
static	O
int	O
n	int
;	O
bzero	function
(	O
x	double
,	O
sizeof	O
(	O
*	O
x	pointer
)	O
)	O
;	O
gmp_randinit_default	O
(	O
x	pointer
)	O
;	O
}	O
static	O
object	O
make_random_state	function
(	O
object	O
rs	int
)	O
{	O
object	O
z	int
;	O
if	O
(	O
rs	int
==	O
Cnil	O
)	O
rs	int
=	O
symbol_value	function
(	O
Vrandom_state	int
)	O
;	O
if	O
(	O
rs	O
!=	O
Ct	O
&&	O
type_of	function
(	O
rs	int
)	O
!=	O
t_random	int
)	O
{	O
FEwrong_type_argument	function
(	O
sLrandom_state	int
,	O
rs	int
)	O
;	O
return	O
(	O
Cnil	O
)	O
;	O
}	O
z	int
=	O
alloc_object	function
(	O
t_random	int
)	O
;	O
init_gmp_rnd_state	function
(	O
&	O
z	pointer
->	O
rnd	struct
.	O
rnd_state	int
)	O
;	O
if	O
(	O
rs	char
==	O
Ct	O
)	O
gmp_randseed_ui	O
(	O
&	O
z	struct
->	O
rnd	struct
.	O
rnd_state	int
,	O
RS_DEF_INIT	pointer
)	O
;	O
else	O
memcpy	function
(	O
z	pointer
->	O
rnd	struct
.	O
rnd_state	struct
.	O
_mp_seed	pointer
->	O
_mp_d	pointer
,	O
rs	pointer
->	O
rnd	struct
.	O
rnd_state	struct
.	O
_mp_seed	pointer
->	O
_mp_d	pointer
,	O
rs	pointer
->	O
rnd	struct
.	O
rnd_state	struct
.	O
_mp_seed	pointer
->	O
_mp_alloc	short
*	O
sizeof	O
(	O
*	O
z	pointer
->	O
rnd	struct
.	O
rnd_state	struct
.	O
_mp_seed	pointer
->	O
_mp_d	pointer
)	O
)	O
;	O
return	O
(	O
z	pointer
)	O
;	O
}	O
LFD	function
(	O
Lrandom	int
)	O
(	O
void	O
)	O
{	O
int	O
j	int
;	O
object	O
x	int
;	O
j	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
j	int
==	O
1	int
)	O
vs_push	function
(	O
symbol_value	function
(	O
Vrandom_state	int
)	O
)	O
;	O
check_arg	function
(	O
2	int
)	O
;	O
check_type_random_state	function
(	O
&	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
x	int
=	O
rando	function
(	O
vs_base	O
[	O
0	int
]	O
,	O
vs_base	O
[	O
1	int
]	O
)	O
;	O
vs_top	O
=	O
vs_base	O
;	O
vs_push	function
(	O
x	O
)	O
;	O
}	O
LFD	function
(	O
Lmake_random_state	int
)	O
(	O
void	O
)	O
{	O
int	O
j	int
;	O
object	O
x	int
;	O
j	int
=	O
vs_top	O
-	O
vs_base	O
;	O
if	O
(	O
j	int
==	O
0	int
)	O
vs_push	function
(	O
Cnil	O
)	O
;	O
check_arg	function
(	O
1	int
)	O
;	O
x	int
=	O
make_random_state	function
(	O
vs_head	int
)	O
;	O
vs_top	O
=	O
vs_base	O
;	O
vs_push	function
(	O
x	O
)	O
;	O
}	O
LFD	function
(	O
Lrandom_state_p	int
)	O
(	O
void	O
)	O
{	O
check_arg	function
(	O
1	int
)	O
;	O
if	O
(	O
type_of	function
(	O
vs_pop	int
)	O
==	O
t_random	int
)	O
vs_push	function
(	O
Ct	O
)	O
;	O
else	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
void	O
gcl_init_num_rand	function
(	O
void	O
)	O
{	O
Vrandom_state	int
=	O
make_special	function
(	O
"*RANDOM-STATE*"	pointer
,	O
make_random_state	function
(	O
Ct	O
)	O
)	O
;	O
make_function	function
(	O
"RANDOM"	pointer
,	O
Lrandom	int
)	O
;	O
make_function	function
(	O
"MAKE-RANDOM-STATE"	pointer
,	O
Lmake_random_state	int
)	O
;	O
make_function	function
(	O
"RANDOM-STATE-P"	pointer
,	O
Lrandom_state_p	int
)	O
;	O
}	O
local	O
uLong	long
adler32_combine_	function
OF	O
(	O
(	O
uLong	long
adler1	long
,	O
uLong	long
adler2	long
,	O
z_off64_t	O
len2	long
)	O
)	O
;	O
uLong	long
ZEXPORT	O
adler32_z	function
(	O
adler	long
,	O
buf	pointer
,	O
len	int
)	O
uLong	long
adler	long
;	O
const	O
Bytef	char
*	O
buf	pointer
;	O
z_size_t	long
len	int
;	O
{	O
unsigned	O
long	O
sum2	long
;	O
unsigned	O
n	int
;	O
sum2	long
=	O
(	O
adler	long
>>	O
16	int
)	O
&	O
0xffff	int
;	O
adler	long
&=	O
0xffff	int
;	O
if	O
(	O
len	int
==	O
1	int
)	O
{	O
adler	long
+=	O
buf	pointer
[	O
0	int
]	O
;	O
if	O
(	O
adler	long
>=	O
BASE	int
)	O
adler	long
-=	O
BASE	int
;	O
sum2	long
+=	O
adler	long
;	O
if	O
(	O
sum2	long
>=	O
BASE	int
)	O
sum2	long
-=	O
BASE	int
;	O
return	O
adler	long
|	O
(	O
sum2	long
<<	O
16	int
)	O
;	O
}	O
if	O
(	O
buf	pointer
==	O
Z_NULL	int
)	O
return	O
1L	int
;	O
if	O
(	O
len	int
<	O
16	int
)	O
{	O
while	O
(	O
len	int
--	O
)	O
{	O
adler	long
+=	O
*	O
buf	pointer
++	O
;	O
sum2	long
+=	O
adler	long
;	O
}	O
if	O
(	O
adler	long
>=	O
BASE	int
)	O
adler	long
-=	O
BASE	int
;	O
MOD28	O
(	O
sum2	long
)	O
;	O
return	O
adler	long
|	O
(	O
sum2	long
<<	O
16	int
)	O
;	O
}	O
while	O
(	O
len	int
>=	O
NMAX	int
)	O
{	O
len	int
-=	O
NMAX	int
;	O
n	int
=	O
NMAX	int
/	O
16	int
;	O
do	O
{	O
DO16	O
(	O
buf	pointer
)	O
;	O
buf	pointer
+=	O
16	int
;	O
}	O
while	O
(	O
--	O
n	int
)	O
;	O
MOD	O
(	O
adler	long
)	O
;	O
MOD	O
(	O
sum2	long
)	O
;	O
}	O
if	O
(	O
len	int
)	O
{	O
while	O
(	O
len	int
>=	O
16	int
)	O
{	O
len	int
-=	O
16	int
;	O
DO16	O
(	O
buf	pointer
)	O
;	O
buf	pointer
+=	O
16	int
;	O
}	O
while	O
(	O
len	int
--	O
)	O
{	O
adler	long
+=	O
*	O
buf	pointer
++	O
;	O
sum2	long
+=	O
adler	long
;	O
}	O
MOD	O
(	O
adler	long
)	O
;	O
MOD	O
(	O
sum2	long
)	O
;	O
}	O
return	O
adler	long
|	O
(	O
sum2	long
<<	O
16	int
)	O
;	O
}	O
uLong	long
ZEXPORT	O
adler32	function
(	O
adler	long
,	O
buf	pointer
,	O
len	int
)	O
uLong	long
adler	long
;	O
const	O
Bytef	char
*	O
buf	pointer
;	O
uInt	int
len	int
;	O
{	O
return	O
adler32_z	function
(	O
adler	long
,	O
buf	pointer
,	O
len	int
)	O
;	O
}	O
local	O
uLong	long
adler32_combine_	function
(	O
adler1	long
,	O
adler2	long
,	O
len2	long
)	O
uLong	long
adler1	long
;	O
uLong	long
adler2	long
;	O
z_off64_t	O
len2	long
;	O
{	O
unsigned	O
long	O
sum1	long
;	O
unsigned	O
long	O
sum2	long
;	O
unsigned	O
rem	int
;	O
if	O
(	O
len2	long
<	O
0	int
)	O
return	O
0xffffffffUL	int
;	O
MOD63	O
(	O
len2	long
)	O
;	O
rem	int
=	O
(	O
unsigned	O
)	O
len2	long
;	O
sum1	long
=	O
adler1	long
&	O
0xffff	int
;	O
sum2	long
=	O
rem	int
*	O
sum1	long
;	O
MOD	O
(	O
sum2	long
)	O
;	O
sum1	long
+=	O
(	O
adler2	long
&	O
0xffff	int
)	O
+	O
BASE	int
-	O
1	int
;	O
sum2	long
+=	O
(	O
(	O
adler1	long
>>	O
16	int
)	O
&	O
0xffff	int
)	O
+	O
(	O
(	O
adler2	long
>>	O
16	int
)	O
&	O
0xffff	int
)	O
+	O
BASE	int
-	O
rem	int
;	O
if	O
(	O
sum1	long
>=	O
BASE	int
)	O
sum1	long
-=	O
BASE	int
;	O
if	O
(	O
sum1	long
>=	O
BASE	int
)	O
sum1	long
-=	O
BASE	int
;	O
if	O
(	O
sum2	long
>=	O
(	O
(	O
unsigned	O
long	O
)	O
BASE	int
<<	O
1	int
)	O
)	O
sum2	long
-=	O
(	O
(	O
unsigned	O
long	O
)	O
BASE	int
<<	O
1	int
)	O
;	O
if	O
(	O
sum2	long
>=	O
BASE	int
)	O
sum2	long
-=	O
BASE	int
;	O
return	O
sum1	long
|	O
(	O
sum2	long
<<	O
16	int
)	O
;	O
}	O
uLong	long
ZEXPORT	O
adler32_combine	function
(	O
adler1	long
,	O
adler2	long
,	O
len2	long
)	O
uLong	long
adler1	long
;	O
uLong	long
adler2	long
;	O
z_off_t	O
len2	long
;	O
{	O
return	O
adler32_combine_	function
(	O
adler1	long
,	O
adler2	long
,	O
len2	long
)	O
;	O
}	O
uLong	long
ZEXPORT	O
adler32_combine64	function
(	O
adler1	long
,	O
adler2	long
,	O
len2	long
)	O
uLong	long
adler1	long
;	O
uLong	long
adler2	long
;	O
z_off64_t	O
len2	long
;	O
{	O
return	O
adler32_combine_	function
(	O
adler1	long
,	O
adler2	long
,	O
len2	long
)	O
;	O
}	O
int	O
ZEXPORT	O
compress2	function
(	O
dest	pointer
,	O
destLen	pointer
,	O
source	pointer
,	O
sourceLen	long
,	O
level	int
)	O
Bytef	char
*	O
dest	pointer
;	O
uLongf	long
*	O
destLen	pointer
;	O
const	O
Bytef	char
*	O
source	pointer
;	O
uLong	long
sourceLen	long
;	O
int	O
level	int
;	O
{	O
z_stream	struct
stream	struct
;	O
int	O
err	int
;	O
const	O
uInt	int
max	int
=	O
(	O
uInt	int
)	O
-	O
1	int
;	O
uLong	long
left	int
;	O
left	long
=	O
*	O
destLen	pointer
;	O
*	O
destLen	pointer
=	O
0	int
;	O
stream	struct
.	O
zalloc	pointer
=	O
(	O
alloc_func	pointer
)	O
0	int
;	O
stream	struct
.	O
zfree	pointer
=	O
(	O
free_func	pointer
)	O
0	int
;	O
stream	struct
.	O
opaque	pointer
=	O
(	O
voidpf	pointer
)	O
0	int
;	O
err	int
=	O
deflateInit	O
(	O
&	O
stream	struct
,	O
level	int
)	O
;	O
if	O
(	O
err	int
!=	O
Z_OK	int
)	O
return	O
err	int
;	O
stream	struct
.	O
next_out	pointer
=	O
dest	pointer
;	O
stream	struct
.	O
avail_out	int
=	O
0	int
;	O
stream	struct
.	O
next_in	pointer
=	O
(	O
z_const	O
Bytef	char
*	O
)	O
source	pointer
;	O
stream	struct
.	O
avail_in	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
stream	struct
.	O
avail_out	int
==	O
0	int
)	O
{	O
stream	struct
.	O
avail_out	int
=	O
left	long
>	O
(	O
uLong	long
)	O
max	int
?	O
max	int
:	O
(	O
uInt	int
)	O
left	long
;	O
left	long
-=	O
stream	struct
.	O
avail_out	int
;	O
}	O
if	O
(	O
stream	struct
.	O
avail_in	int
==	O
0	int
)	O
{	O
stream	struct
.	O
avail_in	int
=	O
sourceLen	long
>	O
(	O
uLong	long
)	O
max	int
?	O
max	int
:	O
(	O
uInt	int
)	O
sourceLen	long
;	O
sourceLen	long
-=	O
stream	struct
.	O
avail_in	int
;	O
}	O
err	int
=	O
deflate	function
(	O
&	O
stream	struct
,	O
sourceLen	long
?	O
Z_NO_FLUSH	int
:	O
Z_FINISH	int
)	O
;	O
}	O
while	O
(	O
err	int
==	O
Z_OK	int
)	O
;	O
*	O
destLen	pointer
=	O
stream	struct
.	O
total_out	long
;	O
deflateEnd	function
(	O
&	O
stream	struct
)	O
;	O
return	O
err	int
==	O
Z_STREAM_END	int
?	O
Z_OK	int
:	O
err	int
;	O
}	O
int	O
ZEXPORT	O
compress	function
(	O
dest	pointer
,	O
destLen	pointer
,	O
source	pointer
,	O
sourceLen	long
)	O
Bytef	char
*	O
dest	pointer
;	O
uLongf	long
*	O
destLen	pointer
;	O
const	O
Bytef	char
*	O
source	pointer
;	O
uLong	long
sourceLen	long
;	O
{	O
return	O
compress2	function
(	O
dest	pointer
,	O
destLen	pointer
,	O
source	pointer
,	O
sourceLen	long
,	O
Z_DEFAULT_COMPRESSION	O
)	O
;	O
}	O
uLong	long
ZEXPORT	O
compressBound	function
(	O
sourceLen	long
)	O
uLong	long
sourceLen	long
;	O
{	O
return	O
sourceLen	long
+	O
(	O
sourceLen	long
>>	O
12	int
)	O
+	O
(	O
sourceLen	long
>>	O
14	int
)	O
+	O
(	O
sourceLen	long
>>	O
25	int
)	O
+	O
13	int
;	O
}	O
int	O
ZEXPORT	O
gzclose	function
(	O
file	pointer
)	O
gzFile	pointer
file	pointer
;	O
{	O
gz_statep	pointer
state	pointer
;	O
if	O
(	O
file	pointer
==	O
NULL	O
)	O
return	O
Z_STREAM_ERROR	O
;	O
state	pointer
=	O
(	O
gz_statep	pointer
)	O
file	pointer
;	O
return	O
state	pointer
->	O
mode	int
==	O
GZ_READ	int
?	O
gzclose_r	function
(	O
file	pointer
)	O
:	O
gzclose_w	function
(	O
file	pointer
)	O
;	O
}	O
z_const	O
char	O
*	O
const	O
z_errmsg	array
[	O
10	int
]	O
=	O
{	O
(	O
z_const	O
char	O
*	O
)	O
"need dictionary"	pointer
,	O
(	O
z_const	O
char	O
*	O
)	O
"stream end"	pointer
,	O
(	O
z_const	O
char	O
*	O
)	O
""	pointer
,	O
(	O
z_const	O
char	O
*	O
)	O
"file error"	pointer
,	O
(	O
z_const	O
char	O
*	O
)	O
"stream error"	pointer
,	O
(	O
z_const	O
char	O
*	O
)	O
"data error"	pointer
,	O
(	O
z_const	O
char	O
*	O
)	O
"insufficient memory"	pointer
,	O
(	O
z_const	O
char	O
*	O
)	O
"buffer error"	pointer
,	O
(	O
z_const	O
char	O
*	O
)	O
"incompatible version"	pointer
,	O
(	O
z_const	O
char	O
*	O
)	O
""	pointer
}	O
;	O
const	O
char	O
*	O
ZEXPORT	O
zlibVersion	function
(	O
)	O
{	O
return	O
ZLIB_VERSION	pointer
;	O
}	O
uLong	long
ZEXPORT	O
zlibCompileFlags	function
(	O
)	O
{	O
uLong	long
flags	long
;	O
flags	int
=	O
0	int
;	O
switch	O
(	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
uInt	int
)	O
)	O
)	O
{	O
case	O
2	int
:	O
break	O
;	O
case	O
4	int
:	O
flags	long
+=	O
1	int
;	O
break	O
;	O
case	O
8	int
:	O
flags	long
+=	O
2	int
;	O
break	O
;	O
default	O
:	O
flags	long
+=	O
3	int
;	O
}	O
switch	O
(	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
uLong	long
)	O
)	O
)	O
{	O
case	O
2	int
:	O
break	O
;	O
case	O
4	int
:	O
flags	long
+=	O
1	int
<<	O
2	int
;	O
break	O
;	O
case	O
8	int
:	O
flags	long
+=	O
2	int
<<	O
2	int
;	O
break	O
;	O
default	O
:	O
flags	long
+=	O
3	int
<<	O
2	int
;	O
}	O
switch	O
(	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
voidpf	pointer
)	O
)	O
)	O
{	O
case	O
2	int
:	O
break	O
;	O
case	O
4	int
:	O
flags	long
+=	O
1	int
<<	O
4	int
;	O
break	O
;	O
case	O
8	int
:	O
flags	long
+=	O
2	int
<<	O
4	int
;	O
break	O
;	O
default	O
:	O
flags	long
+=	O
3	int
<<	O
4	int
;	O
}	O
switch	O
(	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
z_off_t	O
)	O
)	O
)	O
{	O
case	O
2	int
:	O
break	O
;	O
case	O
4	int
:	O
flags	long
+=	O
1	int
<<	O
6	int
;	O
break	O
;	O
case	O
8	int
:	O
flags	long
+=	O
2	int
<<	O
6	int
;	O
break	O
;	O
default	O
:	O
flags	long
+=	O
3	int
<<	O
6	int
;	O
}	O
return	O
flags	int
;	O
}	O
const	O
char	O
*	O
ZEXPORT	O
zError	function
(	O
err	int
)	O
int	O
err	int
;	O
{	O
return	O
ERR_MSG	O
(	O
err	int
)	O
;	O
}	O
voidpf	pointer
ZLIB_INTERNAL	O
zcalloc	function
(	O
opaque	pointer
,	O
items	int
,	O
size	int
)	O
voidpf	pointer
opaque	pointer
;	O
unsigned	O
items	int
;	O
unsigned	O
size	int
;	O
{	O
(	O
void	O
)	O
opaque	pointer
;	O
return	O
sizeof	O
(	O
uInt	int
)	O
>	O
2	int
?	O
(	O
voidpf	pointer
)	O
malloc	function
(	O
items	int
*	O
size	int
)	O
:	O
(	O
voidpf	pointer
)	O
calloc	function
(	O
items	int
,	O
size	int
)	O
;	O
}	O
void	O
ZLIB_INTERNAL	O
zcfree	function
(	O
opaque	pointer
,	O
ptr	pointer
)	O
voidpf	pointer
opaque	pointer
;	O
voidpf	pointer
ptr	pointer
;	O
{	O
(	O
void	O
)	O
opaque	pointer
;	O
free	function
(	O
ptr	pointer
)	O
;	O
}	O
int	O
dbmclose	function
(	O
)	O
{	O
if	O
(	O
_gdbm_file	pointer
!=	O
NULL	O
)	O
{	O
dbm_close	function
(	O
_gdbm_file	pointer
)	O
;	O
_gdbm_file	pointer
=	O
NULL	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
dbm_delete	function
(	O
DBM	struct
*	O
dbm	pointer
,	O
datum	struct
key	struct
)	O
{	O
int	O
rc	int
=	O
gdbm_delete	function
(	O
dbm	pointer
->	O
file	pointer
,	O
key	struct
)	O
;	O
if	O
(	O
rc	int
)	O
__gdbm_error_to_ndbm	O
(	O
dbm	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
datum	struct
dbm_fetch	function
(	O
DBM	struct
*	O
dbm	pointer
,	O
datum	struct
key	struct
)	O
{	O
datum	struct
ret_val	struct
;	O
ret_val	pointer
=	O
gdbm_fetch	function
(	O
dbm	pointer
->	O
file	pointer
,	O
key	O
)	O
;	O
if	O
(	O
dbm	pointer
->	O
_dbm_fetch_val	pointer
!=	O
NULL	O
)	O
free	function
(	O
dbm	pointer
->	O
_dbm_fetch_val	pointer
)	O
;	O
dbm	pointer
->	O
_dbm_fetch_val	pointer
=	O
ret_val	struct
.	O
dptr	pointer
;	O
__gdbm_error_to_ndbm	O
(	O
dbm	pointer
)	O
;	O
return	O
ret_val	struct
;	O
}	O
static	O
unsigned	O
getint	function
(	O
const	O
unsigned	O
char	O
*	O
cp	pointer
)	O
{	O
return	O
(	O
cp	pointer
[	O
0	int
]	O
<<	O
24	int
)	O
+	O
(	O
cp	pointer
[	O
1	int
]	O
<<	O
16	int
)	O
+	O
(	O
cp	pointer
[	O
2	int
]	O
<<	O
8	int
)	O
+	O
cp	pointer
[	O
3	int
]	O
;	O
}	O
static	O
void	O
putint	function
(	O
unsigned	O
char	O
*	O
cp	pointer
,	O
unsigned	O
n	int
)	O
{	O
cp	pointer
[	O
0	int
]	O
=	O
(	O
n	int
>>	O
24	int
)	O
&	O
0xff	int
;	O
cp	pointer
[	O
1	int
]	O
=	O
(	O
n	int
>>	O
16	int
)	O
&	O
0xff	int
;	O
cp	pointer
[	O
2	int
]	O
=	O
(	O
n	int
>>	O
8	int
)	O
&	O
0xff	int
;	O
cp	pointer
[	O
3	int
]	O
=	O
n	int
&	O
0xff	int
;	O
}	O
static	O
int	O
ndbm_open_dir_file0	function
(	O
const	O
char	O
*	O
file_name	pointer
,	O
int	O
pagfd	int
,	O
int	O
mode	int
)	O
{	O
int	O
fd	int
=	O
-	O
1	int
;	O
struct	O
stat	struct
st	struct
,	O
pagst	int
;	O
unsigned	O
char	O
dirbuf	array
[	O
DEF_DIR_SIZE	int
]	O
;	O
int	O
flags	int
=	O
(	O
mode	int
&	O
GDBM_OPENMASK	int
)	O
==	O
GDBM_READER	int
?	O
O_RDONLY	int
:	O
O_RDWR	int
;	O
if	O
(	O
mode	int
&	O
GDBM_CLOEXEC	int
)	O
flags	int
|=	O
O_CLOEXEC	O
;	O
if	O
(	O
fstat	function
(	O
pagfd	int
,	O
&	O
pagst	struct
)	O
)	O
{	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_FILE_OPEN_ERROR	int
,	O
TRUE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
stat	struct
(	O
file_name	pointer
,	O
&	O
st	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
st	struct
.	O
st_nlink	long
>=	O
2	int
)	O
{	O
if	O
(	O
st	struct
.	O
st_dev	long
==	O
pagst	struct
.	O
st_dev	long
&&	O
st	struct
.	O
st_ino	long
==	O
pagst	struct
.	O
st_ino	long
)	O
{	O
if	O
(	O
unlink	function
(	O
file_name	pointer
)	O
)	O
{	O
if	O
(	O
(	O
mode	int
&	O
GDBM_OPENMASK	int
)	O
==	O
GDBM_READER	int
)	O
return	O
pagfd	int
;	O
else	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
{	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_FILE_OPEN_ERROR	int
,	O
TRUE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_FILE_OPEN_ERROR	int
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
st	struct
.	O
st_size	long
==	O
0	int
)	O
;	O
else	O
if	O
(	O
st	struct
.	O
st_size	long
!=	O
DEF_DIR_SIZE	int
)	O
{	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_BAD_MAGIC_NUMBER	pointer
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
fd	int
=	O
open	function
(	O
file_name	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_FILE_OPEN_ERROR	int
,	O
FALSE	int
)	O
;	O
return	O
fd	int
;	O
}	O
if	O
(	O
read	function
(	O
fd	int
,	O
dirbuf	pointer
,	O
sizeof	O
(	O
dirbuf	pointer
)	O
)	O
!=	O
sizeof	O
(	O
dirbuf	pointer
)	O
)	O
{	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_FILE_OPEN_ERROR	int
,	O
FALSE	int
)	O
;	O
close	function
(	O
fd	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
getint	function
(	O
dirbuf	pointer
)	O
==	O
GDBM_DIR_MAGIC	int
)	O
{	O
int	O
v	pointer
[	O
3	int
]	O
;	O
v	pointer
[	O
0	int
]	O
=	O
getint	function
(	O
dirbuf	pointer
+	O
4	int
)	O
;	O
v	pointer
[	O
1	int
]	O
=	O
getint	function
(	O
dirbuf	int
+	O
8	int
)	O
;	O
v	pointer
[	O
2	int
]	O
=	O
getint	function
(	O
dirbuf	int
+	O
12	int
)	O
;	O
if	O
(	O
gdbm_version_cmp	function
(	O
v	pointer
,	O
gdbm_version_number	int
)	O
<=	O
0	int
)	O
return	O
fd	int
;	O
}	O
close	function
(	O
fd	int
)	O
;	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_BAD_MAGIC_NUMBER	int
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
fd	int
=	O
open	function
(	O
file_name	pointer
,	O
flags	int
|	O
O_CREAT	int
,	O
pagst	struct
.	O
st_mode	int
&	O
0777	int
)	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
putint	function
(	O
dirbuf	pointer
,	O
GDBM_DIR_MAGIC	pointer
)	O
;	O
putint	function
(	O
dirbuf	int
+	O
4	int
,	O
gdbm_version_number	array
[	O
0	int
]	O
)	O
;	O
putint	function
(	O
dirbuf	pointer
+	O
8	int
,	O
gdbm_version_number	array
[	O
1	int
]	O
)	O
;	O
putint	function
(	O
dirbuf	pointer
+	O
12	int
,	O
gdbm_version_number	array
[	O
2	int
]	O
)	O
;	O
if	O
(	O
write	function
(	O
fd	int
,	O
dirbuf	pointer
,	O
sizeof	O
(	O
dirbuf	pointer
)	O
)	O
!=	O
sizeof	O
(	O
dirbuf	O
)	O
)	O
{	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_FILE_WRITE_ERROR	int
,	O
FALSE	O
)	O
;	O
close	function
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
}	O
return	O
fd	int
;	O
}	O
static	O
int	O
ndbm_open_dir_file	function
(	O
const	O
char	O
*	O
base	pointer
,	O
int	O
pagfd	int
,	O
int	O
mode	int
)	O
{	O
char	O
*	O
file_name	pointer
=	O
malloc	function
(	O
strlen	function
(	O
base	int
)	O
+	O
sizeof	O
(	O
DIRSUF	pointer
)	O
)	O
;	O
int	O
fd	int
;	O
if	O
(	O
!	O
file_name	pointer
)	O
{	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_MALLOC_ERROR	int
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
fd	int
=	O
ndbm_open_dir_file0	function
(	O
strcat	function
(	O
strcpy	function
(	O
file_name	pointer
,	O
base	pointer
)	O
,	O
DIRSUF	pointer
)	O
,	O
pagfd	int
,	O
mode	int
)	O
;	O
free	function
(	O
file_name	pointer
)	O
;	O
return	O
fd	int
;	O
}	O
DBM	struct
*	O
dbm_open	function
(	O
char	O
*	O
file	pointer
,	O
int	O
flags	int
,	O
int	O
mode	int
)	O
{	O
char	O
*	O
pag_file	pointer
;	O
DBM	struct
*	O
dbm	pointer
=	O
NULL	O
;	O
int	O
open_flags	int
;	O
int	O
f	int
;	O
pag_file	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
file	pointer
)	O
+	O
5	int
)	O
;	O
if	O
(	O
!	O
pag_file	pointer
)	O
{	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_MALLOC_ERROR	int
,	O
FALSE	int
)	O
;	O
return	O
NULL	O
;	O
}	O
strcpy	function
(	O
pag_file	pointer
,	O
file	pointer
)	O
;	O
strcat	function
(	O
pag_file	pointer
,	O
".pag"	pointer
)	O
;	O
f	pointer
=	O
flags	int
&	O
(	O
O_RDONLY	int
|	O
O_RDWR	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
)	O
;	O
if	O
(	O
f	int
==	O
O_RDONLY	int
)	O
{	O
open_flags	int
=	O
GDBM_READER	int
;	O
mode	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
f	int
==	O
(	O
O_RDWR	int
|	O
O_CREAT	int
)	O
)	O
{	O
open_flags	int
=	O
GDBM_WRCREAT	int
;	O
}	O
else	O
if	O
(	O
(	O
f	pointer
&	O
O_TRUNC	int
)	O
==	O
O_TRUNC	int
)	O
{	O
open_flags	int
=	O
GDBM_NEWDB	int
;	O
}	O
else	O
{	O
open_flags	int
=	O
GDBM_WRITER	int
;	O
mode	int
=	O
0	int
;	O
}	O
if	O
(	O
flags	int
&	O
O_CLOEXEC	O
)	O
open_flags	int
|=	O
GDBM_CLOEXEC	int
;	O
open_flags	int
|=	O
GDBM_NOLOCK	int
;	O
dbm	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
dbm	pointer
)	O
)	O
;	O
if	O
(	O
!	O
dbm	pointer
)	O
{	O
free	function
(	O
pag_file	pointer
)	O
;	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_MALLOC_ERROR	int
,	O
FALSE	O
)	O
;	O
return	O
NULL	O
;	O
}	O
dbm	pointer
->	O
file	pointer
=	O
gdbm_open	function
(	O
pag_file	int
,	O
0	int
,	O
open_flags	int
,	O
mode	int
,	O
NULL	O
)	O
;	O
if	O
(	O
dbm	pointer
->	O
file	pointer
==	O
NULL	O
)	O
{	O
gdbm_set_errno	function
(	O
NULL	O
,	O
GDBM_FILE_OPEN_ERROR	int
,	O
FALSE	O
)	O
;	O
free	function
(	O
dbm	pointer
)	O
;	O
dbm	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
dbm	pointer
->	O
dirfd	int
=	O
ndbm_open_dir_file	function
(	O
file	pointer
,	O
dbm	pointer
->	O
file	pointer
->	O
desc	int
,	O
open_flags	int
)	O
;	O
if	O
(	O
dbm	pointer
->	O
dirfd	int
==	O
-	O
1	int
)	O
{	O
gdbm_close	function
(	O
dbm	pointer
->	O
file	pointer
)	O
;	O
free	function
(	O
dbm	pointer
)	O
;	O
dbm	pointer
=	O
NULL	O
;	O
}	O
}	O
free	function
(	O
pag_file	pointer
)	O
;	O
return	O
dbm	pointer
;	O
}	O
int	O
gdbm_exists	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
datum	struct
key	pointer
)	O
{	O
GDBM_ASSERT_CONSISTENCY	O
(	O
dbf	pointer
,	O
0	int
)	O
;	O
if	O
(	O
_gdbm_findkey	function
(	O
dbf	pointer
,	O
key	struct
,	O
NULL	O
,	O
NULL	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
gdbm_errno	O
==	O
GDBM_ITEM_NOT_FOUND	int
)	O
gdbm_set_errno	function
(	O
dbf	pointer
,	O
GDBM_NO_ERROR	int
,	O
FALSE	int
)	O
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
_gdbm_hash	function
(	O
datum	struct
key	pointer
)	O
{	O
unsigned	O
int	O
value	int
;	O
int	O
index	function
;	O
value	int
=	O
0x238F13AF	int
*	O
key	struct
.	O
dsize	int
;	O
for	O
(	O
index	function
=	O
0	int
;	O
index	function
<	O
key	struct
.	O
dsize	int
;	O
index	O
++	O
)	O
value	int
=	O
(	O
value	int
+	O
(	O
key	struct
.	O
dptr	pointer
[	O
index	int
]	O
<<	O
(	O
index	int
*	O
5	int
%	O
24	int
)	O
)	O
)	O
&	O
0x7FFFFFFF	int
;	O
value	int
=	O
(	O
1103515243	O
*	O
value	int
+	O
12345	int
)	O
&	O
0x7FFFFFFF	int
;	O
return	O
(	O
(	O
int	O
)	O
value	int
)	O
;	O
}	O
int	O
_gdbm_bucket_dir	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
int	O
hash	int
)	O
{	O
return	O
hash	int
>>	O
(	O
GDBM_HASH_BITS	int
-	O
dbf	pointer
->	O
header	pointer
->	O
dir_bits	int
)	O
;	O
}	O
void	O
_gdbm_hash_key	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
datum	struct
key	pointer
,	O
int	O
*	O
hash	pointer
,	O
int	O
*	O
bucket	pointer
,	O
int	O
*	O
offset	pointer
)	O
{	O
int	O
hashval	int
=	O
_gdbm_hash	function
(	O
key	pointer
)	O
;	O
*	O
hash	pointer
=	O
hashval	pointer
;	O
*	O
bucket	pointer
=	O
_gdbm_bucket_dir	function
(	O
dbf	pointer
,	O
hashval	int
)	O
;	O
*	O
offset	int
=	O
hashval	int
%	O
dbf	pointer
->	O
header	pointer
->	O
bucket_elems	int
;	O
}	O
void	O
_gdbm_unlock_file	function
(	O
GDBM_FILE	pointer
dbf	pointer
)	O
{	O
struct	O
flock	struct
fl	struct
;	O
switch	O
(	O
dbf	pointer
->	O
lock_type	int
)	O
{	O
case	O
LOCKING_FLOCK	int
:	O
flock	O
(	O
dbf	pointer
->	O
desc	int
,	O
LOCK_UN	int
)	O
;	O
break	O
;	O
case	O
LOCKING_LOCKF	int
:	O
lockf	function
(	O
dbf	pointer
->	O
desc	int
,	O
F_ULOCK	int
,	O
(	O
off_t	long
)	O
0L	int
)	O
;	O
break	O
;	O
case	O
LOCKING_FCNTL	int
:	O
fl	struct
.	O
l_type	int
=	O
F_UNLCK	int
;	O
fl	struct
.	O
l_whence	int
=	O
SEEK_SET	int
;	O
fl	struct
.	O
l_start	long
=	O
fl	struct
.	O
l_len	long
=	O
(	O
off_t	long
)	O
0L	int
;	O
fcntl	function
(	O
dbf	pointer
->	O
desc	int
,	O
F_SETLK	int
,	O
&	O
fl	double
)	O
;	O
break	O
;	O
case	O
LOCKING_NONE	int
:	O
break	O
;	O
}	O
dbf	pointer
->	O
lock_type	int
=	O
LOCKING_NONE	int
;	O
}	O
int	O
_gdbm_lock_file	function
(	O
GDBM_FILE	pointer
dbf	pointer
)	O
{	O
struct	O
flock	struct
fl	struct
;	O
int	O
lock_val	int
=	O
-	O
1	int
;	O
if	O
(	O
dbf	pointer
->	O
read_write	int
==	O
GDBM_READER	int
)	O
lock_val	int
=	O
flock	O
(	O
dbf	pointer
->	O
desc	int
,	O
LOCK_SH	int
+	O
LOCK_NB	int
)	O
;	O
else	O
lock_val	int
=	O
flock	O
(	O
dbf	pointer
->	O
desc	int
,	O
LOCK_EX	int
+	O
LOCK_NB	int
)	O
;	O
if	O
(	O
(	O
lock_val	int
==	O
-	O
1	int
)	O
&&	O
(	O
errno	O
==	O
EWOULDBLOCK	O
)	O
)	O
{	O
dbf	pointer
->	O
lock_type	int
=	O
LOCKING_NONE	int
;	O
return	O
lock_val	int
;	O
}	O
else	O
if	O
(	O
lock_val	int
!=	O
-	O
1	int
)	O
{	O
dbf	pointer
->	O
lock_type	int
=	O
LOCKING_FLOCK	int
;	O
return	O
lock_val	int
;	O
}	O
lock_val	int
=	O
lockf	function
(	O
dbf	pointer
->	O
desc	int
,	O
F_LOCK	int
,	O
(	O
off_t	long
)	O
0L	int
)	O
;	O
if	O
(	O
(	O
lock_val	int
==	O
-	O
1	int
)	O
&&	O
(	O
errno	O
==	O
EDEADLK	int
)	O
)	O
{	O
dbf	pointer
->	O
lock_type	int
=	O
LOCKING_NONE	int
;	O
return	O
lock_val	int
;	O
}	O
else	O
if	O
(	O
lock_val	int
!=	O
-	O
1	int
)	O
{	O
dbf	pointer
->	O
lock_type	int
=	O
LOCKING_LOCKF	int
;	O
return	O
lock_val	int
;	O
}	O
if	O
(	O
dbf	pointer
->	O
read_write	int
==	O
GDBM_READER	int
)	O
fl	struct
.	O
l_type	int
=	O
F_RDLCK	int
;	O
else	O
fl	struct
.	O
l_type	int
=	O
F_WRLCK	int
;	O
fl	struct
.	O
l_whence	int
=	O
SEEK_SET	int
;	O
fl	struct
.	O
l_start	int
=	O
fl	struct
.	O
l_len	long
=	O
(	O
off_t	long
)	O
0L	int
;	O
lock_val	int
=	O
fcntl	function
(	O
dbf	pointer
->	O
desc	int
,	O
F_SETLK	int
,	O
&	O
fl	int
)	O
;	O
if	O
(	O
lock_val	int
!=	O
-	O
1	int
)	O
dbf	pointer
->	O
lock_type	int
=	O
LOCKING_FCNTL	int
;	O
if	O
(	O
lock_val	int
==	O
-	O
1	int
)	O
dbf	pointer
->	O
lock_type	int
=	O
LOCKING_NONE	int
;	O
return	O
lock_val	int
;	O
}	O
char	O
*	O
last_component	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
const	O
*	O
base	pointer
=	O
name	pointer
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
char	O
const	O
*	O
p	pointer
;	O
bool	bool
saw_slash	bool
=	O
false	int
;	O
while	O
(	O
ISSLASH	O
(	O
*	O
base	pointer
)	O
)	O
base	pointer
++	O
;	O
for	O
(	O
p	pointer
=	O
base	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
ISSLASH	O
(	O
*	O
p	pointer
)	O
)	O
saw_slash	bool
=	O
true	int
;	O
else	O
if	O
(	O
saw_slash	bool
)	O
{	O
base	pointer
=	O
p	pointer
;	O
saw_slash	bool
=	O
false	int
;	O
}	O
}	O
return	O
(	O
char	O
*	O
)	O
base	pointer
;	O
}	O
size_t	long
base_len	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
size_t	long
len	long
;	O
size_t	long
prefix_len	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
for	O
(	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
1	int
<	O
len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
len	long
-	O
1	int
]	O
)	O
;	O
len	long
--	O
)	O
continue	O
;	O
if	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
len	long
==	O
1	int
&&	O
ISSLASH	O
(	O
name	pointer
[	O
0	int
]	O
)	O
&&	O
ISSLASH	O
(	O
name	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
name	pointer
[	O
2	int
]	O
)	O
return	O
2	int
;	O
if	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
prefix_len	long
&&	O
len	long
==	O
prefix_len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
prefix_len	long
]	O
)	O
)	O
return	O
prefix_len	long
+	O
1	int
;	O
return	O
len	long
;	O
}	O
int	O
c_strcasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
size_t	long
dir_len	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
prefix_length	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
;	O
size_t	long
length	long
;	O
prefix_length	long
+=	O
(	O
prefix_length	long
!=	O
0	int
?	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
prefix_length	long
]	O
)	O
)	O
:	O
(	O
ISSLASH	O
(	O
file	pointer
[	O
0	int
]	O
)	O
?	O
(	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
?	O
2	int
:	O
1	int
)	O
)	O
:	O
0	int
)	O
)	O
;	O
for	O
(	O
length	long
=	O
last_component	function
(	O
file	pointer
)	O
-	O
file	pointer
;	O
prefix_length	long
<	O
length	long
;	O
length	long
--	O
)	O
if	O
(	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
length	long
-	O
1	int
]	O
)	O
)	O
break	O
;	O
return	O
length	long
;	O
}	O
char	O
*	O
mdir_name	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
length	long
=	O
dir_len	function
(	O
file	pointer
)	O
;	O
bool	bool
append_dot	bool
=	O
(	O
length	long
==	O
0	int
||	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
length	long
==	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
&&	O
file	pointer
[	O
2	int
]	O
!=	O
'\0'	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
)	O
)	O
;	O
char	O
*	O
dir	pointer
=	O
malloc	function
(	O
length	long
+	O
append_dot	bool
+	O
1	int
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
dir	pointer
,	O
file	pointer
,	O
length	long
)	O
;	O
if	O
(	O
append_dot	bool
)	O
dir	pointer
[	O
length	long
++	O
]	O
=	O
'.'	O
;	O
dir	pointer
[	O
length	long
]	O
=	O
'\0'	O
;	O
return	O
dir	pointer
;	O
}	O
static	O
int	O
do_fwriteerror	function
(	O
FILE	struct
*	O
fp	pointer
,	O
bool	bool
ignore_ebadf	bool
)	O
{	O
static	O
bool	bool
stdout_closed	bool
=	O
false	int
;	O
if	O
(	O
fp	pointer
==	O
stdout	pointer
)	O
{	O
if	O
(	O
stdout_closed	bool
)	O
return	O
0	int
;	O
stdout_closed	bool
=	O
true	int
;	O
}	O
errno	O
=	O
0	int
;	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
{	O
if	O
(	O
fflush	function
(	O
fp	pointer
)	O
)	O
goto	O
close_preserving_errno	O
;	O
if	O
(	O
fputc	function
(	O
'\0'	O
,	O
fp	pointer
)	O
==	O
EOF	O
)	O
goto	O
close_preserving_errno	O
;	O
if	O
(	O
fflush	function
(	O
fp	pointer
)	O
)	O
goto	O
close_preserving_errno	O
;	O
errno	O
=	O
0	int
;	O
goto	O
close_preserving_errno	O
;	O
}	O
if	O
(	O
ignore_ebadf	bool
)	O
{	O
if	O
(	O
fflush	function
(	O
fp	pointer
)	O
)	O
goto	O
close_preserving_errno	O
;	O
if	O
(	O
fclose	function
(	O
fp	pointer
)	O
&&	O
errno	O
!=	O
EBADF	int
)	O
goto	O
got_errno	O
;	O
}	O
else	O
{	O
if	O
(	O
fclose	function
(	O
fp	pointer
)	O
)	O
goto	O
got_errno	O
;	O
}	O
return	O
0	int
;	O
close_preserving_errno	O
:	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
got_errno	O
:	O
if	O
(	O
errno	O
==	O
EPIPE	int
)	O
return	O
0	int
;	O
else	O
return	O
-	O
1	int
;	O
}	O
int	O
fwriteerror	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
return	O
do_fwriteerror	function
(	O
fp	pointer
,	O
false	int
)	O
;	O
}	O
int	O
fwriteerror_no_ebadf	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
return	O
do_fwriteerror	function
(	O
fp	pointer
,	O
true	int
)	O
;	O
}	O
char	O
const	O
*	O
getprogname	function
(	O
void	O
)	O
{	O
return	O
program_invocation_short_name	pointer
;	O
}	O
static	O
size_t	long
_GL_ATTRIBUTE_PURE	O
string_hash	function
(	O
const	O
void	O
*	O
x	pointer
)	O
{	O
const	O
char	O
*	O
s	pointer
=	O
(	O
const	O
char	O
*	O
)	O
x	pointer
;	O
size_t	long
h	long
=	O
0	int
;	O
for	O
(	O
;	O
*	O
s	pointer
;	O
s	pointer
++	O
)	O
h	long
=	O
*	O
s	pointer
+	O
(	O
(	O
h	long
<<	O
9	int
)	O
|	O
(	O
h	long
>>	O
(	O
SIZE_BITS	O
-	O
9	int
)	O
)	O
)	O
;	O
return	O
h	long
;	O
}	O
struct	O
struniq_hash_node	struct
{	O
struct	O
struniq_hash_node	struct
*	O
volatile	O
next	pointer
;	O
char	O
contents	array
[	O
FLEXIBLE_ARRAY_MEMBER	O
]	O
;	O
}	O
;	O
static	O
struct	O
struniq_hash_node	struct
*	O
volatile	O
struniq_hash_table	array
[	O
STRUNIQ_HASH_TABLE_SIZE	int
]	O
;	O
gl_lock_define_initialized	O
(	O
static	O
,	O
struniq_lock	O
)	O
static	O
const	O
char	O
*	O
struniq	function
(	O
const	O
char	O
*	O
string	pointer
)	O
{	O
size_t	long
hashcode	long
=	O
string_hash	function
(	O
string	pointer
)	O
;	O
size_t	long
slot	long
=	O
hashcode	long
%	O
STRUNIQ_HASH_TABLE_SIZE	int
;	O
size_t	long
size	long
;	O
struct	O
struniq_hash_node	struct
*	O
new_node	pointer
;	O
struct	O
struniq_hash_node	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
struniq_hash_table	array
[	O
slot	long
]	O
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
p	pointer
->	O
contents	array
,	O
string	pointer
)	O
==	O
0	int
)	O
return	O
p	pointer
->	O
contents	array
;	O
size	long
=	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
;	O
new_node	pointer
=	O
(	O
struct	O
struniq_hash_node	struct
*	O
)	O
malloc	function
(	O
FLEXSIZEOF	O
(	O
struct	O
struniq_hash_node	struct
,	O
contents	array
,	O
size	long
)	O
)	O
;	O
if	O
(	O
new_node	pointer
==	O
NULL	O
)	O
return	O
"C"	pointer
;	O
memcpy	function
(	O
new_node	pointer
->	O
contents	array
,	O
string	pointer
,	O
size	long
)	O
;	O
gl_lock_lock	O
(	O
struniq_lock	enum
)	O
;	O
for	O
(	O
p	pointer
=	O
struniq_hash_table	array
[	O
slot	long
]	O
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
p	pointer
->	O
contents	array
,	O
string	pointer
)	O
==	O
0	int
)	O
{	O
free	function
(	O
new_node	pointer
)	O
;	O
new_node	pointer
=	O
p	pointer
;	O
goto	O
done	O
;	O
}	O
new_node	pointer
->	O
next	pointer
=	O
struniq_hash_table	array
[	O
slot	long
]	O
;	O
struniq_hash_table	array
[	O
slot	long
]	O
=	O
new_node	pointer
;	O
done	O
:	O
gl_lock_unlock	O
(	O
struniq_lock	enum
)	O
;	O
return	O
new_node	pointer
->	O
contents	array
;	O
}	O
static	O
const	O
char	O
*	O
gl_locale_name_thread_unsafe	function
(	O
int	O
category	int
,	O
const	O
char	O
*	O
categoryname	pointer
)	O
{	O
{	O
locale_t	pointer
thread_locale	pointer
=	O
uselocale	function
(	O
NULL	O
)	O
;	O
if	O
(	O
thread_locale	pointer
!=	O
LC_GLOBAL_LOCALE	O
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
nl_langinfo	function
(	O
_NL_ITEM	O
(	O
(	O
category	int
)	O
,	O
_NL_ITEM_INDEX	O
(	O
-	O
1	int
)	O
)	O
)	O
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
name	pointer
=	O
thread_locale	pointer
->	O
__names	array
[	O
category	int
]	O
;	O
return	O
name	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
gl_locale_name_thread	function
(	O
int	O
category	int
,	O
const	O
char	O
*	O
categoryname	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
gl_locale_name_thread_unsafe	function
(	O
category	int
,	O
categoryname	pointer
)	O
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
return	O
struniq	function
(	O
name	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
gl_locale_name_posix	function
(	O
int	O
category	int
,	O
const	O
char	O
*	O
categoryname	pointer
)	O
{	O
{	O
const	O
char	O
*	O
locname	pointer
;	O
locname	pointer
=	O
setlocale	function
(	O
category	int
,	O
NULL	O
)	O
;	O
return	O
locname	pointer
;	O
}	O
}	O
const	O
char	O
*	O
gl_locale_name_environ	function
(	O
int	O
category	int
,	O
const	O
char	O
*	O
categoryname	pointer
)	O
{	O
const	O
char	O
*	O
retval	pointer
;	O
retval	pointer
=	O
getenv	function
(	O
"LC_ALL"	pointer
)	O
;	O
if	O
(	O
retval	pointer
!=	O
NULL	O
&&	O
retval	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
return	O
retval	pointer
;	O
retval	pointer
=	O
getenv	function
(	O
categoryname	pointer
)	O
;	O
if	O
(	O
retval	pointer
!=	O
NULL	O
&&	O
retval	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
return	O
retval	pointer
;	O
retval	pointer
=	O
getenv	function
(	O
"LANG"	pointer
)	O
;	O
if	O
(	O
retval	pointer
!=	O
NULL	O
&&	O
retval	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
return	O
retval	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
gl_locale_name_default	function
(	O
void	O
)	O
{	O
return	O
"C"	pointer
;	O
}	O
const	O
char	O
*	O
gl_locale_name	function
(	O
int	O
category	int
,	O
const	O
char	O
*	O
categoryname	pointer
)	O
{	O
const	O
char	O
*	O
retval	pointer
;	O
retval	pointer
=	O
gl_locale_name_thread	function
(	O
category	int
,	O
categoryname	pointer
)	O
;	O
if	O
(	O
retval	pointer
!=	O
NULL	O
)	O
return	O
retval	pointer
;	O
retval	pointer
=	O
gl_locale_name_posix	function
(	O
category	int
,	O
categoryname	pointer
)	O
;	O
if	O
(	O
retval	pointer
!=	O
NULL	O
)	O
return	O
retval	pointer
;	O
return	O
gl_locale_name_default	function
(	O
)	O
;	O
}	O
const	O
unsigned	O
int	O
is_basic_table	array
[	O
UCHAR_MAX	O
/	O
32	int
+	O
1	int
]	O
=	O
{	O
0x00001a00	int
,	O
0xffffffef	int
,	O
0xfffffffe	int
,	O
0x7ffffffe	int
}	O
;	O
size_t	long
mbslen	function
(	O
const	O
char	O
*	O
string	pointer
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
size_t	long
count	long
;	O
mbui_iterator_t	struct
iter	pointer
;	O
count	long
=	O
0	int
;	O
for	O
(	O
mbui_init	O
(	O
iter	pointer
,	O
string	pointer
)	O
;	O
mbui_avail	O
(	O
iter	pointer
)	O
;	O
mbui_advance	O
(	O
iter	pointer
)	O
)	O
count	long
++	O
;	O
return	O
count	long
;	O
}	O
else	O
return	O
strlen	function
(	O
string	pointer
)	O
;	O
}	O
size_t	long
strnlen1	function
(	O
const	O
char	O
*	O
string	pointer
,	O
size_t	long
maxlen	long
)	O
{	O
const	O
char	O
*	O
end	pointer
=	O
(	O
const	O
char	O
*	O
)	O
memchr	function
(	O
string	pointer
,	O
'\0'	O
,	O
maxlen	long
)	O
;	O
if	O
(	O
end	pointer
!=	O
NULL	O
)	O
return	O
end	pointer
-	O
string	pointer
+	O
1	int
;	O
else	O
return	O
maxlen	long
;	O
}	O
char	O
*	O
xreadlink	function
(	O
char	O
const	O
*	O
filename	pointer
)	O
{	O
char	O
*	O
result	pointer
=	O
areadlink	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
result	pointer
==	O
NULL	O
&&	O
errno	O
==	O
ENOMEM	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
result	pointer
;	O
}	O
bool	bool
acl_errno_valid	function
(	O
int	O
errnum	int
)	O
{	O
switch	O
(	O
errnum	int
)	O
{	O
case	O
EBUSY	int
:	O
return	O
false	int
;	O
case	O
EINVAL	int
:	O
return	O
false	int
;	O
case	O
ENOSYS	int
:	O
return	O
false	int
;	O
case	O
EOPNOTSUPP	int
:	O
return	O
false	int
;	O
default	O
:	O
return	O
true	int
;	O
}	O
}	O
void	O
addext	function
(	O
char	O
*	O
filename	pointer
,	O
char	O
const	O
*	O
ext	array
,	O
char	O
e	pointer
)	O
{	O
char	O
*	O
s	pointer
=	O
basename	function
(	O
filename	pointer
)	O
;	O
size_t	long
slen	long
=	O
strlen	function
(	O
s	pointer
)	O
,	O
extlen	array
=	O
strlen	function
(	O
ext	array
)	O
;	O
long	O
slen_max	long
=	O
-	O
1	int
;	O
if	O
(	O
slen	long
+	O
extlen	int
<=	O
_POSIX_NAME_MAX	int
&&	O
!	O
HAVE_DOS_FILE_NAMES	int
)	O
slen_max	pointer
=	O
_POSIX_NAME_MAX	pointer
;	O
else	O
if	O
(	O
s	pointer
==	O
filename	pointer
)	O
slen_max	pointer
=	O
pathconf	function
(	O
"."	pointer
,	O
_PC_NAME_MAX	pointer
)	O
;	O
else	O
{	O
char	O
c	int
=	O
*	O
s	pointer
;	O
*	O
s	pointer
=	O
0	int
;	O
slen_max	pointer
=	O
pathconf	function
(	O
filename	pointer
,	O
_PC_NAME_MAX	pointer
)	O
;	O
*	O
s	pointer
=	O
c	int
;	O
}	O
if	O
(	O
slen_max	long
<	O
0	int
)	O
slen_max	int
=	O
HAVE_LONG_FILE_NAMES	int
?	O
255	int
:	O
14	int
;	O
if	O
(	O
HAVE_DOS_FILE_NAMES	int
&&	O
slen_max	int
<=	O
12	int
)	O
{	O
char	O
*	O
dot	pointer
=	O
strchr	function
(	O
s	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
dot	pointer
)	O
{	O
slen	long
-=	O
dot	long
+	O
1	int
-	O
s	array
;	O
s	array
=	O
dot	long
+	O
1	int
;	O
slen_max	int
=	O
3	int
;	O
}	O
else	O
slen_max	int
=	O
8	int
;	O
extlen	int
=	O
9	int
;	O
}	O
if	O
(	O
slen	long
+	O
extlen	int
<=	O
slen_max	int
)	O
strcpy	function
(	O
s	array
+	O
slen	long
,	O
ext	array
)	O
;	O
else	O
{	O
if	O
(	O
slen_max	long
<=	O
slen	long
)	O
slen	long
=	O
slen_max	int
-	O
1	int
;	O
s	array
[	O
slen	long
]	O
=	O
e	int
;	O
s	array
[	O
slen	long
+	O
1	int
]	O
=	O
0	int
;	O
}	O
}	O
struct	O
allocator	struct
const	O
stdlib_allocator	struct
=	O
{	O
malloc	function
,	O
realloc	function
,	O
free	function
,	O
NULL	O
}	O
;	O
static	O
void	O
__argmatch_die	function
(	O
void	O
)	O
{	O
ARGMATCH_DIE	int
;	O
}	O
argmatch_exit_fn	pointer
argmatch_die	pointer
=	O
__argmatch_die	pointer
;	O
ptrdiff_t	bool
argmatch	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
void	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
size_t	long
arglen	long
;	O
ptrdiff_t	long
matchind	long
=	O
-	O
1	int
;	O
bool	bool
ambiguous	bool
=	O
false	int
;	O
arglen	long
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
arglist	array
[	O
i	pointer
]	O
,	O
arg	pointer
,	O
arglen	pointer
)	O
)	O
{	O
if	O
(	O
strlen	function
(	O
arglist	array
[	O
i	long
]	O
)	O
==	O
arglen	pointer
)	O
return	O
i	long
;	O
else	O
if	O
(	O
matchind	int
==	O
-	O
1	int
)	O
matchind	long
=	O
i	long
;	O
else	O
{	O
if	O
(	O
vallist	pointer
==	O
NULL	O
||	O
memcmp	function
(	O
(	O
char	O
const	O
*	O
)	O
vallist	pointer
+	O
valsize	O
*	O
matchind	pointer
,	O
(	O
char	O
const	O
*	O
)	O
vallist	pointer
+	O
valsize	O
*	O
i	pointer
,	O
valsize	int
)	O
)	O
{	O
ambiguous	bool
=	O
true	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
ambiguous	pointer
)	O
return	O
-	O
2	int
;	O
else	O
return	O
matchind	pointer
;	O
}	O
void	O
argmatch_invalid	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
ptrdiff_t	long
problem	long
)	O
{	O
char	O
const	O
*	O
format	pointer
=	O
(	O
problem	int
==	O
-	O
1	int
?	O
_	O
(	O
"invalid argument %s for %s"	pointer
)	O
:	O
_	O
(	O
"ambiguous argument %s for %s"	pointer
)	O
)	O
;	O
error	function
(	O
0	int
,	O
0	int
,	O
format	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
ARGMATCH_QUOTING_STYLE	pointer
,	O
value	pointer
)	O
,	O
quote_n	function
(	O
1	int
,	O
context	pointer
)	O
)	O
;	O
}	O
void	O
argmatch_valid	function
(	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
void	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
const	O
char	O
*	O
last_val	pointer
=	O
NULL	O
;	O
fputs	function
(	O
_	O
(	O
"Valid arguments are:"	pointer
)	O
,	O
stderr	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
(	O
i	long
==	O
0	int
)	O
||	O
memcmp	function
(	O
last_val	pointer
,	O
(	O
char	O
const	O
*	O
)	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\n  - %s"	pointer
,	O
quote	function
(	O
arglist	array
[	O
i	long
]	O
)	O
)	O
;	O
last_val	pointer
=	O
(	O
char	O
const	O
*	O
)	O
vallist	pointer
+	O
valsize	O
*	O
i	long
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
", %s"	pointer
,	O
quote	function
(	O
arglist	array
[	O
i	long
]	O
)	O
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
}	O
ptrdiff_t	bool
__xargmatch_internal	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
void	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
,	O
argmatch_exit_fn	pointer
exit_fn	pointer
)	O
{	O
ptrdiff_t	long
res	long
=	O
argmatch	function
(	O
arg	pointer
,	O
arglist	int
,	O
vallist	pointer
,	O
valsize	int
)	O
;	O
if	O
(	O
res	int
>=	O
0	int
)	O
return	O
res	pointer
;	O
argmatch_invalid	function
(	O
context	pointer
,	O
arg	pointer
,	O
res	pointer
)	O
;	O
argmatch_valid	function
(	O
arglist	int
,	O
vallist	pointer
,	O
valsize	int
)	O
;	O
(	O
*	O
exit_fn	pointer
)	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
const	O
char	O
*	O
argmatch_to_argument	function
(	O
const	O
void	O
*	O
value	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
void	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
!	O
memcmp	function
(	O
value	pointer
,	O
(	O
char	O
const	O
*	O
)	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
return	O
arglist	array
[	O
i	long
]	O
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
asnprintf	function
(	O
char	O
*	O
resultbuf	pointer
,	O
size_t	long
*	O
lengthp	pointer
,	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
char	O
*	O
result	pointer
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
result	pointer
=	O
vasnprintf	function
(	O
resultbuf	pointer
,	O
lengthp	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
return	O
result	pointer
;	O
}	O
int	O
c_strcasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
char	O
*	O
c_strstr	function
(	O
const	O
char	O
*	O
haystack	pointer
,	O
const	O
char	O
*	O
needle	pointer
)	O
{	O
return	O
strstr	function
(	O
haystack	pointer
,	O
needle	pointer
)	O
;	O
}	O
char	O
*	O
careadlinkat	function
(	O
int	O
fd	int
,	O
char	O
const	O
*	O
filename	pointer
,	O
char	O
*	O
buffer	pointer
,	O
size_t	long
buffer_size	long
,	O
struct	O
allocator	struct
const	O
*	O
alloc	pointer
,	O
ssize_t	long
(	O
*	O
preadlinkat	pointer
)	O
(	O
int	O
,	O
char	O
const	O
*	O
,	O
char	O
*	O
,	O
size_t	long
)	O
)	O
{	O
char	O
*	O
buf	pointer
;	O
size_t	long
buf_size	long
;	O
size_t	long
buf_size_max	long
=	O
SSIZE_MAX	O
<	O
SIZE_MAX	O
?	O
(	O
size_t	long
)	O
SSIZE_MAX	O
+	O
1	int
:	O
SIZE_MAX	O
;	O
char	O
stack_buf	array
[	O
1024	int
]	O
;	O
if	O
(	O
!	O
alloc	pointer
)	O
alloc	pointer
=	O
&	O
stdlib_allocator	struct
;	O
if	O
(	O
!	O
buffer_size	long
)	O
{	O
buffer	pointer
=	O
stack_buf	array
;	O
buffer_size	long
=	O
sizeof	O
stack_buf	array
;	O
}	O
buf	pointer
=	O
buffer	pointer
;	O
buf_size	long
=	O
buffer_size	long
;	O
do	O
{	O
ssize_t	long
link_length	long
=	O
preadlinkat	pointer
(	O
fd	int
,	O
filename	pointer
,	O
buf	pointer
,	O
buf_size	long
)	O
;	O
size_t	long
link_size	long
;	O
if	O
(	O
link_length	long
<	O
0	int
)	O
{	O
int	O
readlinkat_errno	int
=	O
errno	O
;	O
if	O
(	O
readlinkat_errno	int
!=	O
ERANGE	int
)	O
{	O
if	O
(	O
buf	pointer
!=	O
buffer	pointer
)	O
{	O
alloc	pointer
->	O
free	pointer
(	O
buf	pointer
)	O
;	O
errno	O
=	O
readlinkat_errno	int
;	O
}	O
return	O
NULL	O
;	O
}	O
}	O
link_size	long
=	O
link_length	long
;	O
if	O
(	O
link_size	long
<	O
buf_size	long
)	O
{	O
buf	pointer
[	O
link_size	long
++	O
]	O
=	O
'\0'	O
;	O
if	O
(	O
buf	pointer
==	O
stack_buf	array
)	O
{	O
char	O
*	O
b	pointer
=	O
(	O
char	O
*	O
)	O
alloc	pointer
->	O
allocate	pointer
(	O
link_size	long
)	O
;	O
buf_size	long
=	O
link_size	long
;	O
if	O
(	O
!	O
b	pointer
)	O
break	O
;	O
memcpy	function
(	O
b	pointer
,	O
buf	pointer
,	O
link_size	long
)	O
;	O
buf	pointer
=	O
b	pointer
;	O
}	O
else	O
if	O
(	O
link_size	long
<	O
buf_size	long
&&	O
buf	pointer
!=	O
buffer	pointer
&&	O
alloc	pointer
->	O
reallocate	pointer
)	O
{	O
char	O
*	O
b	pointer
=	O
(	O
char	O
*	O
)	O
alloc	pointer
->	O
reallocate	pointer
(	O
buf	pointer
,	O
link_size	long
)	O
;	O
if	O
(	O
b	pointer
)	O
buf	pointer
=	O
b	pointer
;	O
}	O
return	O
buf	pointer
;	O
}	O
if	O
(	O
buf	pointer
!=	O
buffer	pointer
)	O
alloc	pointer
->	O
free	pointer
(	O
buf	pointer
)	O
;	O
if	O
(	O
buf_size	long
<=	O
buf_size_max	long
/	O
2	int
)	O
buf_size	long
*=	O
2	int
;	O
else	O
if	O
(	O
buf_size	long
<	O
buf_size_max	long
)	O
buf_size	long
=	O
buf_size_max	long
;	O
else	O
if	O
(	O
buf_size_max	long
<	O
SIZE_MAX	O
)	O
{	O
errno	O
=	O
ENAMETOOLONG	int
;	O
return	O
NULL	O
;	O
}	O
else	O
break	O
;	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
alloc	pointer
->	O
allocate	pointer
(	O
buf_size	long
)	O
;	O
}	O
while	O
(	O
buf	pointer
)	O
;	O
if	O
(	O
alloc	pointer
->	O
die	pointer
)	O
alloc	pointer
->	O
die	pointer
(	O
buf_size	long
)	O
;	O
errno	O
=	O
ENOMEM	int
;	O
return	O
NULL	O
;	O
}	O
void	O
close_stdout	function
(	O
void	O
)	O
{	O
if	O
(	O
fwriteerror_no_ebadf	function
(	O
stdout	pointer
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"%s"	pointer
,	O
_	O
(	O
"write error"	pointer
)	O
)	O
;	O
errno	O
=	O
0	int
;	O
if	O
(	O
ferror	function
(	O
stderr	pointer
)	O
||	O
fflush	function
(	O
stderr	pointer
)	O
)	O
{	O
fclose	function
(	O
stderr	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
fclose	function
(	O
stderr	pointer
)	O
&&	O
errno	O
!=	O
EBADF	int
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
size_t	long
dir_len	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
prefix_length	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
;	O
size_t	long
length	long
;	O
prefix_length	long
+=	O
(	O
prefix_length	long
!=	O
0	int
?	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
prefix_length	long
]	O
)	O
)	O
:	O
(	O
ISSLASH	O
(	O
file	pointer
[	O
0	int
]	O
)	O
?	O
(	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
?	O
2	int
:	O
1	int
)	O
)	O
:	O
0	int
)	O
)	O
;	O
for	O
(	O
length	long
=	O
last_component	function
(	O
file	pointer
)	O
-	O
file	pointer
;	O
prefix_length	long
<	O
length	long
;	O
length	long
--	O
)	O
if	O
(	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
length	long
-	O
1	int
]	O
)	O
)	O
break	O
;	O
return	O
length	long
;	O
}	O
char	O
*	O
mdir_name	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
length	long
=	O
dir_len	function
(	O
file	pointer
)	O
;	O
bool	bool
append_dot	bool
=	O
(	O
length	long
==	O
0	int
||	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
length	long
==	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
&&	O
file	pointer
[	O
2	int
]	O
!=	O
'\0'	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
)	O
)	O
;	O
char	O
*	O
dir	pointer
=	O
malloc	function
(	O
length	long
+	O
append_dot	bool
+	O
1	int
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
dir	pointer
,	O
file	pointer
,	O
length	long
)	O
;	O
if	O
(	O
append_dot	bool
)	O
dir	pointer
[	O
length	long
++	O
]	O
=	O
'.'	O
;	O
dir	pointer
[	O
length	long
]	O
=	O
'\0'	O
;	O
return	O
dir	pointer
;	O
}	O
int	O
dup_safer	function
(	O
int	O
fd	int
)	O
{	O
return	O
fcntl	function
(	O
fd	int
,	O
F_DUPFD	int
,	O
STDERR_FILENO	int
+	O
1	int
)	O
;	O
}	O
bool	enum
error_with_progname	O
=	O
true	int
;	O
void	O
maybe_print_progname	function
(	O
)	O
{	O
if	O
(	O
error_with_progname	O
)	O
fprintf	function
(	O
stderr	O
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
;	O
}	O
char	O
const	O
*	O
getprogname	function
(	O
void	O
)	O
{	O
return	O
program_invocation_short_name	pointer
;	O
}	O
void	O
gettime	function
(	O
struct	O
timespec	struct
*	O
ts	pointer
)	O
{	O
clock_gettime	function
(	O
CLOCK_REALTIME	int
,	O
ts	pointer
)	O
;	O
}	O
struct	O
timespec	struct
current_timespec	function
(	O
void	O
)	O
{	O
struct	O
timespec	struct
ts	pointer
;	O
gettime	function
(	O
&	O
ts	pointer
)	O
;	O
return	O
ts	pointer
;	O
}	O
typedef	O
unsigned	O
char	O
small_t	char
;	O
verify	O
(	O
2	int
*	O
sa_alignment_max	int
-	O
1	int
<=	O
(	O
small_t	char
)	O
-	O
1	int
)	O
;	O
void	O
*	O
mmalloca	function
(	O
size_t	long
n	long
)	O
{	O
size_t	long
nplus	long
=	O
n	long
+	O
sizeof	O
(	O
small_t	char
)	O
+	O
2	int
*	O
sa_alignment_max	int
-	O
1	int
;	O
if	O
(	O
nplus	long
>=	O
n	long
)	O
{	O
char	O
*	O
mem	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
nplus	long
)	O
;	O
if	O
(	O
mem	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
p	pointer
=	O
(	O
char	O
*	O
)	O
(	O
(	O
(	O
(	O
uintptr_t	long
)	O
mem	pointer
+	O
sizeof	O
(	O
small_t	char
)	O
+	O
sa_alignment_max	int
-	O
1	int
)	O
&	O
~	O
(	O
uintptr_t	long
)	O
(	O
2	int
*	O
sa_alignment_max	int
-	O
1	int
)	O
)	O
+	O
sa_alignment_max	int
)	O
;	O
(	O
(	O
small_t	char
*	O
)	O
p	pointer
)	O
[	O
-	O
1	int
]	O
=	O
p	pointer
-	O
mem	pointer
;	O
return	O
p	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
void	O
freea	function
(	O
void	O
*	O
p	pointer
)	O
{	O
if	O
(	O
(	O
uintptr_t	long
)	O
p	pointer
&	O
(	O
sa_alignment_max	int
-	O
1	int
)	O
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
(	O
uintptr_t	long
)	O
p	pointer
&	O
sa_alignment_max	int
)	O
{	O
void	O
*	O
mem	pointer
=	O
(	O
char	O
*	O
)	O
p	pointer
-	O
(	O
(	O
small_t	char
*	O
)	O
p	pointer
)	O
[	O
-	O
1	int
]	O
;	O
free	function
(	O
mem	pointer
)	O
;	O
}	O
}	O
const	O
unsigned	O
int	O
is_basic_table	array
[	O
UCHAR_MAX	O
/	O
32	int
+	O
1	int
]	O
=	O
{	O
0x00001a00	int
,	O
0xffffffef	int
,	O
0xfffffffe	int
,	O
0x7ffffffe	int
}	O
;	O
int	O
pipe_safer	function
(	O
int	O
fd	array
[	O
2	int
]	O
)	O
{	O
if	O
(	O
pipe	function
(	O
fd	array
)	O
==	O
0	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
fd	array
[	O
i	int
]	O
=	O
fd_safer	function
(	O
fd	array
[	O
i	int
]	O
)	O
;	O
if	O
(	O
fd	array
[	O
i	int
]	O
<	O
0	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
close	function
(	O
fd	array
[	O
1	int
-	O
i	int
]	O
)	O
;	O
errno	O
=	O
e	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
char	O
*	O
xasprintf	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
char	O
*	O
result	pointer
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
result	pointer
=	O
xvasprintf	function
(	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
return	O
result	pointer
;	O
}	O
char	O
*	O
xreadlink	function
(	O
char	O
const	O
*	O
filename	pointer
)	O
{	O
char	O
*	O
result	pointer
=	O
areadlink	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
result	pointer
==	O
NULL	O
&&	O
errno	O
==	O
ENOMEM	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
result	pointer
;	O
}	O
enum	O
{	O
BILLION	int
=	O
1000	int
*	O
1000	int
*	O
1000	int
}	O
;	O
int	O
nanosleep	function
(	O
const	O
struct	O
timespec	struct
*	O
requested_delay	pointer
,	O
struct	O
timespec	struct
*	O
remaining_delay	pointer
)	O
{	O
if	O
(	O
requested_delay	pointer
->	O
tv_nsec	long
<	O
0	int
||	O
BILLION	int
<=	O
requested_delay	pointer
->	O
tv_nsec	long
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
{	O
verify	O
(	O
TYPE_MAXIMUM	O
(	O
time_t	long
)	O
/	O
24	int
/	O
24	int
/	O
60	int
/	O
60	int
)	O
;	O
const	O
time_t	long
limit	long
=	O
24	int
*	O
24	int
*	O
60	int
*	O
60	int
;	O
time_t	long
seconds	long
=	O
requested_delay	pointer
->	O
tv_sec	long
;	O
struct	O
timespec	struct
intermediate	struct
;	O
intermediate	struct
.	O
tv_nsec	long
=	O
requested_delay	pointer
->	O
tv_nsec	long
;	O
while	O
(	O
limit	long
<	O
seconds	long
)	O
{	O
int	O
result	int
;	O
intermediate	struct
.	O
tv_sec	long
=	O
limit	long
;	O
result	int
=	O
nanosleep	function
(	O
&	O
intermediate	struct
,	O
remaining_delay	pointer
)	O
;	O
seconds	long
-=	O
limit	long
;	O
if	O
(	O
result	int
)	O
{	O
if	O
(	O
remaining_delay	pointer
)	O
remaining_delay	pointer
->	O
tv_sec	long
+=	O
seconds	long
;	O
return	O
result	int
;	O
}	O
intermediate	struct
.	O
tv_nsec	long
=	O
0	int
;	O
}	O
intermediate	struct
.	O
tv_sec	long
=	O
seconds	long
;	O
return	O
nanosleep	function
(	O
&	O
intermediate	struct
,	O
remaining_delay	pointer
)	O
;	O
}	O
}	O
extern	O
int	O
__xpg_strerror_r	function
(	O
int	O
errnum	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
buflen	long
)	O
;	O
static	O
int	O
safe_copy	function
(	O
char	O
*	O
buf	pointer
,	O
size_t	long
buflen	long
,	O
const	O
char	O
*	O
msg	pointer
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
msg	pointer
)	O
;	O
size_t	long
moved	long
=	O
len	long
<	O
buflen	long
?	O
len	long
:	O
buflen	long
-	O
1	int
;	O
memmove	function
(	O
buf	pointer
,	O
msg	pointer
,	O
moved	long
)	O
;	O
buf	pointer
[	O
moved	long
]	O
=	O
'\0'	O
;	O
return	O
len	long
<	O
buflen	long
?	O
0	int
:	O
ERANGE	int
;	O
}	O
int	O
strerror_r	function
(	O
int	O
errnum	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
buflen	long
)	O
{	O
if	O
(	O
buflen	long
<=	O
1	int
)	O
{	O
if	O
(	O
buflen	long
)	O
*	O
buf	pointer
=	O
'\0'	O
;	O
return	O
ERANGE	int
;	O
}	O
*	O
buf	pointer
=	O
'\0'	O
;	O
{	O
char	O
const	O
*	O
msg	pointer
=	O
strerror_override	O
(	O
errnum	int
)	O
;	O
if	O
(	O
msg	pointer
)	O
return	O
safe_copy	function
(	O
buf	pointer
,	O
buflen	long
,	O
msg	pointer
)	O
;	O
}	O
{	O
int	O
ret	int
;	O
int	O
saved_errno	int
=	O
errno	O
;	O
{	O
ret	int
=	O
__xpg_strerror_r	function
(	O
errnum	int
,	O
buf	pointer
,	O
buflen	long
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
ret	int
=	O
errno	O
;	O
if	O
(	O
!	O
*	O
buf	pointer
)	O
{	O
safe_copy	function
(	O
buf	pointer
,	O
buflen	long
,	O
strerror_r	function
(	O
errnum	int
,	O
buf	pointer
,	O
buflen	long
)	O
)	O
;	O
}	O
}	O
if	O
(	O
ret	int
==	O
EINVAL	int
&&	O
!	O
*	O
buf	pointer
)	O
{	O
snprintf	function
(	O
buf	pointer
,	O
buflen	long
,	O
"Unknown error %d"	pointer
,	O
errnum	int
)	O
;	O
}	O
errno	O
=	O
saved_errno	int
;	O
return	O
ret	int
;	O
}	O
}	O
static	O
int	O
rpl_fcntl_DUPFD	function
(	O
int	O
fd	int
,	O
int	O
target	int
)	O
;	O
static	O
int	O
rpl_fcntl_DUPFD_CLOEXEC	function
(	O
int	O
fd	int
,	O
int	O
target	int
)	O
;	O
int	O
fcntl	function
(	O
int	O
fd	int
,	O
int	O
action	int
,	O
...	O
)	O
{	O
va_list	array
arg	array
;	O
int	O
result	int
=	O
-	O
1	int
;	O
va_start	O
(	O
arg	array
,	O
action	int
)	O
;	O
switch	O
(	O
action	int
)	O
{	O
case	O
F_DUPFD	int
:	O
{	O
int	O
target	int
=	O
va_arg	O
(	O
arg	array
,	O
int	O
)	O
;	O
result	int
=	O
rpl_fcntl_DUPFD	function
(	O
fd	int
,	O
target	int
)	O
;	O
break	O
;	O
}	O
case	O
F_DUPFD_CLOEXEC	int
:	O
{	O
int	O
target	int
=	O
va_arg	O
(	O
arg	array
,	O
int	O
)	O
;	O
result	int
=	O
rpl_fcntl_DUPFD_CLOEXEC	function
(	O
fd	int
,	O
target	int
)	O
;	O
break	O
;	O
}	O
default	O
:	O
{	O
switch	O
(	O
action	int
)	O
{	O
result	int
=	O
fcntl	function
(	O
fd	int
,	O
action	int
)	O
;	O
break	O
;	O
{	O
int	O
x	int
=	O
va_arg	O
(	O
arg	array
,	O
int	O
)	O
;	O
result	int
=	O
fcntl	function
(	O
fd	int
,	O
action	int
,	O
x	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
{	O
void	O
*	O
p	pointer
=	O
va_arg	O
(	O
arg	array
,	O
void	O
*	O
)	O
;	O
result	int
=	O
fcntl	function
(	O
fd	int
,	O
action	int
,	O
p	pointer
)	O
;	O
}	O
break	O
;	O
}	O
break	O
;	O
}	O
}	O
va_end	O
(	O
arg	array
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
rpl_fcntl_DUPFD	function
(	O
int	O
fd	int
,	O
int	O
target	int
)	O
{	O
int	O
result	int
;	O
if	O
(	O
target	int
<	O
0	int
||	O
getdtablesize	function
(	O
)	O
<=	O
target	int
)	O
{	O
result	int
=	O
-	O
1	int
;	O
errno	O
=	O
EINVAL	int
;	O
}	O
else	O
{	O
int	O
flags	int
=	O
fcntl	function
(	O
fd	int
,	O
F_GETFD	int
)	O
;	O
if	O
(	O
flags	int
<	O
0	int
)	O
result	int
=	O
-	O
1	int
;	O
else	O
{	O
result	int
=	O
fcntl	function
(	O
fd	int
,	O
F_DUPFD	int
,	O
target	int
)	O
;	O
if	O
(	O
0	int
<=	O
result	int
&&	O
fcntl	function
(	O
fd	int
,	O
F_SETFD	int
,	O
flags	int
)	O
==	O
-	O
1	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
close	function
(	O
result	int
)	O
;	O
result	int
=	O
-	O
1	int
;	O
errno	O
=	O
saved_errno	int
;	O
}	O
}	O
}	O
return	O
result	int
;	O
}	O
static	O
int	O
rpl_fcntl_DUPFD_CLOEXEC	function
(	O
int	O
fd	int
,	O
int	O
target	int
)	O
{	O
int	O
result	int
;	O
static	O
int	O
have_dupfd_cloexec	int
=	O
GNULIB_defined_F_DUPFD_CLOEXEC	int
?	O
-	O
1	int
:	O
0	int
;	O
if	O
(	O
0	int
<=	O
have_dupfd_cloexec	int
)	O
{	O
result	int
=	O
fcntl	function
(	O
fd	int
,	O
F_DUPFD_CLOEXEC	int
,	O
target	int
)	O
;	O
if	O
(	O
0	int
<=	O
result	int
||	O
errno	O
!=	O
EINVAL	int
)	O
{	O
have_dupfd_cloexec	int
=	O
1	int
;	O
}	O
else	O
{	O
result	int
=	O
rpl_fcntl_DUPFD	function
(	O
fd	int
,	O
target	int
)	O
;	O
if	O
(	O
result	int
>=	O
0	int
)	O
have_dupfd_cloexec	int
=	O
-	O
1	int
;	O
}	O
}	O
else	O
result	int
=	O
rpl_fcntl_DUPFD	function
(	O
fd	int
,	O
target	int
)	O
;	O
if	O
(	O
0	int
<=	O
result	int
&&	O
have_dupfd_cloexec	int
==	O
-	O
1	int
)	O
{	O
int	O
flags	int
=	O
fcntl	function
(	O
result	int
,	O
F_GETFD	int
)	O
;	O
if	O
(	O
flags	int
<	O
0	int
||	O
fcntl	function
(	O
result	int
,	O
F_SETFD	int
,	O
flags	int
|	O
FD_CLOEXEC	int
)	O
==	O
-	O
1	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
close	function
(	O
result	int
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
result	int
=	O
-	O
1	int
;	O
}	O
}	O
return	O
result	int
;	O
}	O
char	O
*	O
xasprintf	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
char	O
*	O
result	pointer
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
result	pointer
=	O
xvasprintf	function
(	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
return	O
result	pointer
;	O
}	O
void	O
*	O
xmmalloca	function
(	O
size_t	long
n	long
)	O
{	O
void	O
*	O
p	pointer
;	O
p	pointer
=	O
mmalloca	function
(	O
n	long
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
string_list_ty	struct
*	O
read_names_from_file	function
(	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
size_t	long
line_len	long
=	O
0	int
;	O
char	O
*	O
line_buf	pointer
=	O
NULL	O
;	O
FILE	struct
*	O
fp	pointer
;	O
string_list_ty	struct
*	O
result	pointer
;	O
if	O
(	O
strcmp	function
(	O
file_name	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
fp	pointer
=	O
stdin	pointer
;	O
else	O
{	O
fp	pointer
=	O
fopen	function
(	O
file_name	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"error while opening \"%s\" for reading"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
}	O
result	pointer
=	O
string_list_alloc	function
(	O
)	O
;	O
while	O
(	O
!	O
feof	function
(	O
fp	pointer
)	O
)	O
{	O
int	O
len	int
=	O
getline	function
(	O
&	O
line_buf	pointer
,	O
&	O
line_len	long
,	O
fp	pointer
)	O
;	O
if	O
(	O
len	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
len	int
>	O
0	int
&&	O
line_buf	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
line_buf	pointer
[	O
--	O
len	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
len	int
>	O
0	int
&&	O
(	O
line_buf	pointer
[	O
len	int
-	O
1	int
]	O
==	O
' '	O
||	O
line_buf	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\t'	O
||	O
line_buf	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\r'	O
)	O
)	O
line_buf	pointer
[	O
--	O
len	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
line_buf	pointer
==	O
'\0'	O
||	O
*	O
line_buf	pointer
==	O
'#'	O
)	O
continue	O
;	O
string_list_append_unique	function
(	O
result	pointer
,	O
line_buf	pointer
)	O
;	O
}	O
if	O
(	O
line_buf	pointer
!=	O
NULL	O
)	O
free	function
(	O
line_buf	pointer
)	O
;	O
if	O
(	O
fp	pointer
!=	O
stdin	pointer
)	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
struct	O
plural_table_entry	struct
plural_table	array
[	O
]	O
=	O
{	O
{	O
"ja"	pointer
,	O
"Japanese"	pointer
,	O
"nplurals=1; plural=0;"	int
}	O
,	O
{	O
"vi"	pointer
,	O
"Vietnamese"	pointer
,	O
"nplurals=1; plural=0;"	int
}	O
,	O
{	O
"ko"	pointer
,	O
"Korean"	pointer
,	O
"nplurals=1; plural=0;"	int
}	O
,	O
{	O
"en"	pointer
,	O
"English"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"de"	pointer
,	O
"German"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"nl"	pointer
,	O
"Dutch"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"sv"	pointer
,	O
"Swedish"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"da"	pointer
,	O
"Danish"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"no"	pointer
,	O
"Norwegian"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"nb"	pointer
,	O
"Norwegian Bokmal"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"nn"	pointer
,	O
"Norwegian Nynorsk"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"fo"	pointer
,	O
"Faroese"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"es"	pointer
,	O
"Spanish"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"pt"	pointer
,	O
"Portuguese"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"it"	pointer
,	O
"Italian"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"bg"	pointer
,	O
"Bulgarian"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"el"	pointer
,	O
"Greek"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"fi"	pointer
,	O
"Finnish"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"et"	pointer
,	O
"Estonian"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"he"	pointer
,	O
"Hebrew"	int
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"eo"	pointer
,	O
"Esperanto"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"hu"	pointer
,	O
"Hungarian"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"tr"	pointer
,	O
"Turkish"	pointer
,	O
"nplurals=2; plural=(n != 1);"	int
}	O
,	O
{	O
"pt_BR"	pointer
,	O
"Brazilian"	pointer
,	O
"nplurals=2; plural=(n > 1);"	int
}	O
,	O
{	O
"fr"	pointer
,	O
"French"	pointer
,	O
"nplurals=2; plural=(n > 1);"	int
}	O
,	O
{	O
"lv"	pointer
,	O
"Latvian"	pointer
,	O
"nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n != 0 ? 1 : 2);"	int
}	O
,	O
{	O
"ga"	pointer
,	O
"Irish"	pointer
,	O
"nplurals=3; plural=n==1 ? 0 : n==2 ? 1 : 2;"	int
}	O
,	O
{	O
"ro"	pointer
,	O
"Romanian"	pointer
,	O
"nplurals=3; plural=n==1 ? 0 : (n==0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2;"	int
}	O
,	O
{	O
"lt"	pointer
,	O
"Lithuanian"	pointer
,	O
"nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2);"	int
}	O
,	O
{	O
"ru"	pointer
,	O
"Russian"	pointer
,	O
"nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);"	int
}	O
,	O
{	O
"uk"	pointer
,	O
"Ukrainian"	pointer
,	O
"nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);"	int
}	O
,	O
{	O
"be"	pointer
,	O
"Belarusian"	pointer
,	O
"nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);"	int
}	O
,	O
{	O
"sr"	pointer
,	O
"Serbian"	pointer
,	O
"nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);"	int
}	O
,	O
{	O
"hr"	pointer
,	O
"Croatian"	pointer
,	O
"nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);"	int
}	O
,	O
{	O
"cs"	pointer
,	O
"Czech"	pointer
,	O
"nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;"	int
}	O
,	O
{	O
"sk"	pointer
,	O
"Slovak"	pointer
,	O
"nplurals=3; plural=(n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2;"	int
}	O
,	O
{	O
"pl"	pointer
,	O
"Polish"	pointer
,	O
"nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);"	int
}	O
,	O
{	O
"sl"	int
,	O
"Slovenian"	int
,	O
"nplurals=4; plural=(n%100==1 ? 0 : n%100==2 ? 1 : n%100==3 || n%100==4 ? 2 : 3);"	int
}	O
}	O
;	O
const	O
size_t	long
plural_table_size	long
=	O
sizeof	O
(	O
plural_table	array
)	O
/	O
sizeof	O
(	O
plural_table	array
[	O
0	int
]	O
)	O
;	O
static	O
void	O
xerror	function
(	O
int	O
severity	int
,	O
const	O
char	O
*	O
prefix_tail	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
size_t	long
lineno	long
,	O
size_t	long
column	int
,	O
int	O
multiline_p	int
,	O
const	O
char	O
*	O
message_text	pointer
)	O
{	O
if	O
(	O
multiline_p	pointer
)	O
{	O
bool	bool
old_error_with_progname	bool
=	O
error_with_progname	O
;	O
char	O
*	O
prefix	pointer
;	O
if	O
(	O
filename	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
lineno	int
!=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
column	int
!=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
prefix	pointer
=	O
xasprintf	function
(	O
"%s:%ld:%ld: %s"	pointer
,	O
filename	pointer
,	O
(	O
long	O
)	O
lineno	int
,	O
(	O
long	O
)	O
column	pointer
,	O
prefix_tail	pointer
)	O
;	O
else	O
prefix	pointer
=	O
xasprintf	function
(	O
"%s:%ld: %s"	pointer
,	O
filename	pointer
,	O
(	O
long	O
)	O
lineno	int
,	O
prefix_tail	pointer
)	O
;	O
}	O
else	O
prefix	pointer
=	O
xasprintf	function
(	O
"%s: %s"	pointer
,	O
filename	pointer
,	O
prefix_tail	pointer
)	O
;	O
error_with_progname	O
=	O
false	int
;	O
}	O
else	O
prefix	pointer
=	O
xasprintf	function
(	O
"%s: %s"	pointer
,	O
program_name	pointer
,	O
prefix_tail	pointer
)	O
;	O
if	O
(	O
severity	int
>=	O
PO_SEVERITY_ERROR	int
)	O
po_multiline_error	function
(	O
prefix	pointer
,	O
xstrdup	function
(	O
message_text	pointer
)	O
)	O
;	O
else	O
po_multiline_warning	function
(	O
prefix	pointer
,	O
xstrdup	function
(	O
message_text	pointer
)	O
)	O
;	O
error_with_progname	O
=	O
old_error_with_progname	int
;	O
if	O
(	O
severity	int
==	O
PO_SEVERITY_FATAL_ERROR	int
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
int	O
exit_status	int
=	O
(	O
severity	int
==	O
PO_SEVERITY_FATAL_ERROR	int
?	O
EXIT_FAILURE	int
:	O
0	int
)	O
;	O
if	O
(	O
filename	pointer
!=	O
NULL	O
)	O
{	O
error_with_progname	O
=	O
false	int
;	O
if	O
(	O
lineno	int
!=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
column	int
!=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
po_error	function
(	O
exit_status	int
,	O
0	int
,	O
"%s:%ld:%ld: %s%s"	pointer
,	O
filename	pointer
,	O
(	O
long	O
)	O
lineno	int
,	O
(	O
long	O
)	O
column	O
,	O
prefix_tail	pointer
,	O
message_text	int
)	O
;	O
else	O
po_error_at_line	function
(	O
exit_status	int
,	O
0	int
,	O
filename	pointer
,	O
lineno	int
,	O
"%s%s"	pointer
,	O
prefix_tail	pointer
,	O
message_text	pointer
)	O
;	O
}	O
else	O
po_error	function
(	O
exit_status	int
,	O
0	int
,	O
"%s: %s%s"	pointer
,	O
filename	pointer
,	O
prefix_tail	pointer
,	O
message_text	pointer
)	O
;	O
error_with_progname	O
=	O
true	int
;	O
}	O
else	O
po_error	function
(	O
exit_status	int
,	O
0	int
,	O
"%s%s"	pointer
,	O
prefix_tail	pointer
,	O
message_text	pointer
)	O
;	O
if	O
(	O
severity	int
<	O
PO_SEVERITY_ERROR	int
)	O
--	O
error_message_count	int
;	O
}	O
}	O
void	O
textmode_xerror	function
(	O
int	O
severity	int
,	O
const	O
struct	O
message_ty	struct
*	O
message	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
size_t	long
lineno	long
,	O
size_t	long
column	int
,	O
int	O
multiline_p	int
,	O
const	O
char	O
*	O
message_text	pointer
)	O
{	O
const	O
char	O
*	O
prefix_tail	pointer
=	O
(	O
severity	int
==	O
PO_SEVERITY_WARNING	int
?	O
_	O
(	O
"warning: "	pointer
)	O
:	O
""	pointer
)	O
;	O
if	O
(	O
message	pointer
!=	O
NULL	O
&&	O
(	O
filename	pointer
==	O
NULL	O
||	O
lineno	int
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
)	O
{	O
filename	pointer
=	O
message	pointer
->	O
pos	struct
.	O
file_name	pointer
;	O
lineno	int
=	O
message	pointer
->	O
pos	struct
.	O
line_number	long
;	O
column	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
}	O
xerror	function
(	O
severity	int
,	O
prefix_tail	pointer
,	O
filename	pointer
,	O
lineno	int
,	O
column	pointer
,	O
multiline_p	pointer
,	O
message_text	pointer
)	O
;	O
}	O
void	O
textmode_xerror2	function
(	O
int	O
severity	int
,	O
const	O
struct	O
message_ty	struct
*	O
message1	pointer
,	O
const	O
char	O
*	O
filename1	pointer
,	O
size_t	long
lineno1	long
,	O
size_t	long
column1	int
,	O
int	O
multiline_p1	int
,	O
const	O
char	O
*	O
message_text1	pointer
,	O
const	O
struct	O
message_ty	struct
*	O
message2	pointer
,	O
const	O
char	O
*	O
filename2	pointer
,	O
size_t	long
lineno2	long
,	O
size_t	long
column2	int
,	O
int	O
multiline_p2	int
,	O
const	O
char	O
*	O
message_text2	pointer
)	O
{	O
int	O
severity1	int
=	O
(	O
severity	int
==	O
PO_SEVERITY_FATAL_ERROR	int
?	O
PO_SEVERITY_ERROR	int
:	O
severity	int
)	O
;	O
const	O
char	O
*	O
prefix_tail	pointer
=	O
(	O
severity	int
==	O
PO_SEVERITY_WARNING	int
?	O
_	O
(	O
"warning: "	pointer
)	O
:	O
""	pointer
)	O
;	O
if	O
(	O
message1	pointer
!=	O
NULL	O
&&	O
(	O
filename1	pointer
==	O
NULL	O
||	O
lineno1	int
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
)	O
{	O
filename1	int
=	O
message1	pointer
->	O
pos	struct
.	O
file_name	pointer
;	O
lineno1	long
=	O
message1	pointer
->	O
pos	struct
.	O
line_number	long
;	O
column1	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
message2	pointer
!=	O
NULL	O
&&	O
(	O
filename2	pointer
==	O
NULL	O
||	O
lineno2	int
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
)	O
{	O
filename2	int
=	O
message2	pointer
->	O
pos	struct
.	O
file_name	pointer
;	O
lineno2	long
=	O
message2	pointer
->	O
pos	struct
.	O
line_number	long
;	O
column2	long
=	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
multiline_p1	pointer
)	O
xerror	function
(	O
severity1	pointer
,	O
prefix_tail	pointer
,	O
filename1	pointer
,	O
lineno1	pointer
,	O
column1	pointer
,	O
multiline_p1	pointer
,	O
message_text1	pointer
)	O
;	O
else	O
{	O
char	O
*	O
message_text1_extended	pointer
=	O
xasprintf	function
(	O
"%s..."	pointer
,	O
message_text1	pointer
)	O
;	O
xerror	function
(	O
severity1	pointer
,	O
prefix_tail	pointer
,	O
filename1	pointer
,	O
lineno1	pointer
,	O
column1	pointer
,	O
multiline_p1	pointer
,	O
message_text1_extended	pointer
)	O
;	O
free	function
(	O
message_text1_extended	pointer
)	O
;	O
}	O
{	O
char	O
*	O
message_text2_extended	pointer
=	O
xasprintf	function
(	O
"...%s"	pointer
,	O
message_text2	pointer
)	O
;	O
xerror	function
(	O
severity	int
,	O
prefix_tail	pointer
,	O
filename2	pointer
,	O
lineno2	pointer
,	O
column2	pointer
,	O
multiline_p2	pointer
,	O
message_text2_extended	pointer
)	O
;	O
free	function
(	O
message_text2_extended	pointer
)	O
;	O
}	O
if	O
(	O
severity	int
>=	O
PO_SEVERITY_ERROR	int
)	O
--	O
error_message_count	int
;	O
}	O
void	O
(	O
*	O
po_xerror	pointer
)	O
(	O
int	O
severity	int
,	O
const	O
struct	O
message_ty	struct
*	O
message	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
size_t	long
lineno	int
,	O
size_t	long
column	int
,	O
int	O
multiline_p	int
,	O
const	O
char	O
*	O
message_text	pointer
)	O
=	O
textmode_xerror	pointer
;	O
void	O
(	O
*	O
po_xerror2	pointer
)	O
(	O
int	O
severity	int
,	O
const	O
struct	O
message_ty	struct
*	O
message1	pointer
,	O
const	O
char	O
*	O
filename1	pointer
,	O
size_t	long
lineno1	long
,	O
size_t	long
column1	int
,	O
int	O
multiline_p1	int
,	O
const	O
char	O
*	O
message_text1	pointer
,	O
const	O
struct	O
message_ty	struct
*	O
message2	pointer
,	O
const	O
char	O
*	O
filename2	pointer
,	O
size_t	long
lineno2	long
,	O
size_t	long
column2	int
,	O
int	O
multiline_p2	int
,	O
const	O
char	O
*	O
message_text2	pointer
)	O
=	O
textmode_xerror2	pointer
;	O
struct	O
locals	struct
{	O
msgdomain_list_ty	struct
*	O
mdlp	pointer
;	O
}	O
;	O
static	O
bool	bool
execute_and_read_po_output	function
(	O
const	O
char	O
*	O
progname	pointer
,	O
const	O
char	O
*	O
prog_path	pointer
,	O
char	O
*	O
*	O
prog_argv	pointer
,	O
void	O
*	O
private_data	pointer
)	O
{	O
struct	O
locals	struct
*	O
l	pointer
=	O
(	O
struct	O
locals	struct
*	O
)	O
private_data	pointer
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
int	O
exitstatus	int
;	O
child	int
=	O
create_pipe_in	function
(	O
progname	pointer
,	O
prog_path	pointer
,	O
prog_argv	pointer
,	O
DEV_NULL	pointer
,	O
false	int
,	O
true	int
,	O
true	int
,	O
fd	int
)	O
;	O
fp	pointer
=	O
fdopen	function
(	O
fd	array
[	O
0	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	pointer
)	O
)	O
;	O
l	pointer
->	O
mdlp	pointer
=	O
read_catalog_stream	function
(	O
fp	pointer
,	O
"(pipe)"	pointer
,	O
"(pipe)"	pointer
,	O
&	O
input_format_po	struct
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
exitstatus	int
=	O
wait_subprocess	function
(	O
child	int
,	O
progname	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
true	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	pointer
)	O
,	O
progname	pointer
,	O
exitstatus	int
)	O
;	O
return	O
false	int
;	O
}	O
msgdomain_list_ty	struct
*	O
msgdomain_read_csharp	function
(	O
const	O
char	O
*	O
resource_name	pointer
,	O
const	O
char	O
*	O
locale_name	pointer
,	O
const	O
char	O
*	O
directory	pointer
)	O
{	O
char	O
*	O
culture_name	pointer
;	O
const	O
char	O
*	O
args	pointer
[	O
4	int
]	O
;	O
const	O
char	O
*	O
gettextexedir	pointer
;	O
const	O
char	O
*	O
gettextlibdir	pointer
;	O
char	O
*	O
assembly_path	pointer
;	O
const	O
char	O
*	O
libdirs	pointer
[	O
1	int
]	O
;	O
struct	O
locals	struct
locals	struct
;	O
if	O
(	O
resource_name	pointer
==	O
NULL	O
)	O
resource_name	pointer
=	O
"Messages"	pointer
;	O
culture_name	pointer
=	O
xstrdup	function
(	O
locale_name	pointer
)	O
;	O
{	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
culture_name	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
==	O
'_'	O
)	O
*	O
p	pointer
=	O
'-'	O
;	O
if	O
(	O
strncmp	function
(	O
culture_name	pointer
,	O
"sr-CS"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
memcpy	function
(	O
culture_name	pointer
,	O
"sr-SP"	pointer
,	O
5	int
)	O
;	O
p	pointer
=	O
strchr	function
(	O
culture_name	pointer
,	O
'@'	O
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"@latin"	pointer
)	O
==	O
0	int
)	O
strcpy	function
(	O
p	pointer
,	O
"-Latn"	pointer
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"@cyrillic"	pointer
)	O
==	O
0	int
)	O
strcpy	function
(	O
p	pointer
,	O
"-Cyrl"	pointer
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
culture_name	pointer
,	O
"sr-SP"	pointer
)	O
==	O
0	int
)	O
{	O
free	function
(	O
culture_name	pointer
)	O
;	O
culture_name	pointer
=	O
xstrdup	function
(	O
"sr-SP-Latn"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
culture_name	pointer
,	O
"uz-UZ"	pointer
)	O
==	O
0	int
)	O
{	O
free	function
(	O
culture_name	pointer
)	O
;	O
culture_name	pointer
=	O
xstrdup	function
(	O
"uz-UZ-Latn"	pointer
)	O
;	O
}	O
}	O
args	pointer
[	O
0	int
]	O
=	O
directory	pointer
;	O
args	pointer
[	O
1	int
]	O
=	O
resource_name	pointer
;	O
args	pointer
[	O
2	int
]	O
=	O
culture_name	pointer
;	O
args	pointer
[	O
3	int
]	O
=	O
NULL	O
;	O
gettextexedir	pointer
=	O
getenv	function
(	O
"GETTEXTCSHARPEXEDIR"	pointer
)	O
;	O
if	O
(	O
gettextexedir	pointer
==	O
NULL	O
||	O
gettextexedir	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
gettextexedir	pointer
=	O
relocate	O
(	O
LIBDIR	pointer
"/gettext"	pointer
)	O
;	O
gettextlibdir	pointer
=	O
getenv	function
(	O
"GETTEXTCSHARPLIBDIR"	pointer
)	O
;	O
if	O
(	O
gettextlibdir	pointer
==	O
NULL	O
||	O
gettextlibdir	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
gettextlibdir	pointer
=	O
relocate	O
(	O
LIBDIR	pointer
)	O
;	O
assembly_path	pointer
=	O
xconcatenated_filename	function
(	O
gettextexedir	pointer
,	O
"msgunfmt.net"	pointer
,	O
".exe"	pointer
)	O
;	O
libdirs	pointer
[	O
0	int
]	O
=	O
gettextlibdir	pointer
;	O
if	O
(	O
execute_csharp_program	function
(	O
assembly_path	pointer
,	O
libdirs	pointer
,	O
1	int
,	O
args	pointer
,	O
verbose	bool
,	O
false	int
,	O
execute_and_read_po_output	function
,	O
&	O
locals	struct
)	O
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
free	function
(	O
assembly_path	pointer
)	O
;	O
free	function
(	O
culture_name	pointer
)	O
;	O
return	O
locals	struct
.	O
mdlp	pointer
;	O
}	O
msgdomain_list_ty	struct
*	O
msgdomain_read_tcl	function
(	O
const	O
char	O
*	O
locale_name	pointer
,	O
const	O
char	O
*	O
directory	pointer
)	O
{	O
const	O
char	O
*	O
gettextdatadir	pointer
;	O
char	O
*	O
tclscript	pointer
;	O
size_t	long
len	long
;	O
char	O
*	O
frobbed_locale_name	pointer
;	O
char	O
*	O
p	pointer
;	O
char	O
*	O
file_name	pointer
;	O
char	O
*	O
argv	pointer
[	O
4	int
]	O
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
msgdomain_list_ty	struct
*	O
mdlp	pointer
;	O
int	O
exitstatus	int
;	O
size_t	long
k	long
;	O
gettextdatadir	pointer
=	O
getenv	function
(	O
"GETTEXTTCLDIR"	pointer
)	O
;	O
if	O
(	O
gettextdatadir	pointer
==	O
NULL	O
||	O
gettextdatadir	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
gettextdatadir	pointer
=	O
relocate	O
(	O
GETTEXTDATADIR	O
)	O
;	O
tclscript	pointer
=	O
xconcatenated_filename	function
(	O
gettextdatadir	pointer
,	O
"msgunfmt.tcl"	pointer
,	O
NULL	O
)	O
;	O
len	long
=	O
strlen	function
(	O
locale_name	pointer
)	O
;	O
frobbed_locale_name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
frobbed_locale_name	pointer
,	O
locale_name	pointer
,	O
len	long
+	O
1	int
)	O
;	O
for	O
(	O
p	pointer
=	O
frobbed_locale_name	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
>=	O
'A'	O
&&	O
*	O
p	pointer
<=	O
'Z'	O
)	O
*	O
p	pointer
=	O
*	O
p	pointer
-	O
'A'	O
+	O
'a'	O
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'.'	O
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
break	O
;	O
}	O
file_name	pointer
=	O
xconcatenated_filename	function
(	O
directory	pointer
,	O
frobbed_locale_name	pointer
,	O
".msg"	pointer
)	O
;	O
freea	function
(	O
frobbed_locale_name	pointer
)	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
"tclsh"	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
tclscript	pointer
;	O
argv	pointer
[	O
2	int
]	O
=	O
file_name	pointer
;	O
argv	pointer
[	O
3	int
]	O
=	O
NULL	O
;	O
if	O
(	O
verbose	function
)	O
{	O
char	O
*	O
command	pointer
=	O
shell_quote_argv	function
(	O
argv	pointer
)	O
;	O
printf	function
(	O
"%s\n"	pointer
,	O
command	pointer
)	O
;	O
free	function
(	O
command	pointer
)	O
;	O
}	O
child	int
=	O
create_pipe_in	function
(	O
"tclsh"	pointer
,	O
"tclsh"	pointer
,	O
argv	pointer
,	O
DEV_NULL	pointer
,	O
false	int
,	O
true	int
,	O
true	int
,	O
fd	int
)	O
;	O
fp	pointer
=	O
fdopen	function
(	O
fd	int
[	O
0	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	pointer
)	O
)	O
;	O
mdlp	pointer
=	O
read_catalog_stream	function
(	O
fp	pointer
,	O
"(pipe)"	pointer
,	O
"(pipe)"	pointer
,	O
&	O
input_format_po	struct
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
exitstatus	int
=	O
wait_subprocess	function
(	O
child	int
,	O
"tclsh"	pointer
,	O
false	int
,	O
false	int
,	O
true	int
,	O
true	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
{	O
if	O
(	O
exitstatus	int
==	O
2	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
ENOENT	int
,	O
_	O
(	O
"error while opening \"%s\" for reading"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
else	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	pointer
)	O
,	O
"tclsh"	int
,	O
exitstatus	int
)	O
;	O
}	O
free	function
(	O
tclscript	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
mdlp	pointer
->	O
nitems	long
;	O
k	int
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
mdlp	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
is_header	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
)	O
{	O
if	O
(	O
j	long
>	O
0	int
)	O
{	O
message_ty	struct
*	O
header	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
j	long
;	O
i	long
>	O
0	int
;	O
i	long
--	O
)	O
mlp	pointer
->	O
item	pointer
[	O
i	long
]	O
=	O
mlp	pointer
->	O
item	pointer
[	O
i	long
-	O
1	int
]	O
;	O
mlp	pointer
->	O
item	pointer
[	O
0	int
]	O
=	O
header	pointer
;	O
}	O
break	O
;	O
}	O
}	O
return	O
mdlp	pointer
;	O
}	O
struct	O
locals	struct
{	O
message_list_ty	struct
*	O
mlp	pointer
;	O
}	O
;	O
static	O
bool	bool
execute_writing_input	function
(	O
const	O
char	O
*	O
progname	pointer
,	O
const	O
char	O
*	O
prog_path	pointer
,	O
char	O
*	O
*	O
prog_argv	pointer
,	O
void	O
*	O
private_data	pointer
)	O
{	O
struct	O
locals	struct
*	O
l	pointer
=	O
(	O
struct	O
locals	struct
*	O
)	O
private_data	pointer
;	O
pid_t	int
child	int
;	O
int	O
fd	int
[	O
1	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
int	O
exitstatus	int
;	O
child	int
=	O
create_pipe_out	function
(	O
progname	pointer
,	O
prog_path	pointer
,	O
prog_argv	pointer
,	O
NULL	O
,	O
false	int
,	O
true	int
,	O
true	int
,	O
fd	int
)	O
;	O
fp	pointer
=	O
fdopen	function
(	O
fd	int
[	O
0	int
]	O
,	O
"wb"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"fdopen() failed"	pointer
)	O
)	O
;	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
l	pointer
->	O
mlp	pointer
;	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
fwrite	function
(	O
mp	pointer
->	O
msgid	pointer
,	O
1	int
,	O
strlen	function
(	O
mp	pointer
->	O
msgid	pointer
)	O
+	O
1	int
,	O
fp	pointer
)	O
;	O
fwrite	function
(	O
mp	pointer
->	O
msgstr	pointer
,	O
1	int
,	O
strlen	function
(	O
mp	pointer
->	O
msgstr	pointer
)	O
+	O
1	int
,	O
fp	pointer
)	O
;	O
}	O
}	O
if	O
(	O
fwriteerror	function
(	O
fp	pointer
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"error while writing to %s subprocess"	pointer
)	O
,	O
progname	pointer
)	O
;	O
exitstatus	int
=	O
wait_subprocess	function
(	O
child	int
,	O
progname	pointer
,	O
true	int
,	O
false	int
,	O
true	int
,	O
true	int
,	O
NULL	O
)	O
;	O
if	O
(	O
exitstatus	int
!=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s subprocess failed with exit code %d"	pointer
)	O
,	O
progname	pointer
,	O
exitstatus	int
)	O
;	O
return	O
false	int
;	O
}	O
int	O
msgdomain_write_csharp_resources	function
(	O
message_list_ty	struct
*	O
mlp	pointer
,	O
const	O
char	O
*	O
canon_encoding	pointer
,	O
const	O
char	O
*	O
domain_name	pointer
,	O
const	O
char	O
*	O
file_name	pointer
)	O
{	O
if	O
(	O
mlp	pointer
->	O
nitems	long
!=	O
0	int
)	O
{	O
{	O
bool	bool
has_context	bool
;	O
size_t	long
j	long
;	O
has_context	bool
=	O
false	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgctxt	pointer
!=	O
NULL	O
)	O
has_context	bool
=	O
true	int
;	O
if	O
(	O
has_context	bool
)	O
{	O
multiline_error	function
(	O
xstrdup	function
(	O
""	pointer
)	O
,	O
xstrdup	function
(	O
_	O
(	O
"message catalog has context dependent translations\nbut the C# .resources format doesn't support contexts\n"	pointer
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
{	O
bool	bool
has_plural	bool
;	O
size_t	long
j	long
;	O
has_plural	bool
=	O
false	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
has_plural	bool
=	O
true	int
;	O
if	O
(	O
has_plural	bool
)	O
{	O
multiline_error	function
(	O
xstrdup	function
(	O
""	pointer
)	O
,	O
xstrdup	function
(	O
_	O
(	O
"message catalog has plural form translations\nbut the C# .resources format doesn't support plural handling\n"	pointer
)	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
iconv_message_list	function
(	O
mlp	pointer
,	O
canon_encoding	pointer
,	O
po_charset_utf8	pointer
,	O
NULL	O
)	O
;	O
message_list_delete_header_field	function
(	O
mlp	pointer
,	O
"POT-Creation-Date:"	pointer
)	O
;	O
{	O
const	O
char	O
*	O
args	pointer
[	O
2	int
]	O
;	O
const	O
char	O
*	O
gettextexedir	pointer
;	O
char	O
*	O
assembly_path	pointer
;	O
struct	O
locals	struct
locals	struct
;	O
args	pointer
[	O
0	int
]	O
=	O
file_name	pointer
;	O
args	pointer
[	O
1	int
]	O
=	O
NULL	O
;	O
gettextexedir	pointer
=	O
getenv	function
(	O
"GETTEXTCSHARPEXEDIR"	pointer
)	O
;	O
if	O
(	O
gettextexedir	pointer
==	O
NULL	O
||	O
gettextexedir	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
gettextexedir	pointer
=	O
relocate	O
(	O
LIBDIR	pointer
"/gettext"	pointer
)	O
;	O
assembly_path	pointer
=	O
xconcatenated_filename	function
(	O
gettextexedir	pointer
,	O
"msgfmt.net"	pointer
,	O
".exe"	pointer
)	O
;	O
locals	struct
.	O
mlp	pointer
=	O
mlp	pointer
;	O
if	O
(	O
execute_csharp_program	function
(	O
assembly_path	pointer
,	O
NULL	O
,	O
0	int
,	O
args	pointer
,	O
verbose	int
>	O
0	int
,	O
false	int
,	O
execute_writing_input	pointer
,	O
&	O
locals	struct
)	O
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
free	function
(	O
assembly_path	pointer
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
last_component	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
const	O
*	O
base	pointer
=	O
name	pointer
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
char	O
const	O
*	O
p	pointer
;	O
bool	bool
saw_slash	bool
=	O
false	int
;	O
while	O
(	O
ISSLASH	O
(	O
*	O
base	pointer
)	O
)	O
base	pointer
++	O
;	O
for	O
(	O
p	pointer
=	O
base	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
ISSLASH	O
(	O
*	O
p	pointer
)	O
)	O
saw_slash	bool
=	O
true	int
;	O
else	O
if	O
(	O
saw_slash	bool
)	O
{	O
base	pointer
=	O
p	pointer
;	O
saw_slash	bool
=	O
false	int
;	O
}	O
}	O
return	O
(	O
char	O
*	O
)	O
base	pointer
;	O
}	O
size_t	long
base_len	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
size_t	long
len	long
;	O
size_t	long
prefix_len	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
for	O
(	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
1	int
<	O
len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
len	long
-	O
1	int
]	O
)	O
;	O
len	long
--	O
)	O
continue	O
;	O
if	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
len	long
==	O
1	int
&&	O
ISSLASH	O
(	O
name	pointer
[	O
0	int
]	O
)	O
&&	O
ISSLASH	O
(	O
name	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
name	pointer
[	O
2	int
]	O
)	O
return	O
2	int
;	O
if	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
prefix_len	long
&&	O
len	long
==	O
prefix_len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
prefix_len	long
]	O
)	O
)	O
return	O
prefix_len	long
+	O
1	int
;	O
return	O
len	long
;	O
}	O
char	O
const	O
*	O
getprogname	function
(	O
void	O
)	O
{	O
return	O
program_invocation_short_name	pointer
;	O
}	O
const	O
typeinfo_t	O
iconv_ostream_typeinfo	O
=	O
{	O
"iconv_ostream"	pointer
}	O
;	O
static	O
const	O
typeinfo_t	O
*	O
const	O
iconv_ostream_superclasses	array
[	O
]	O
=	O
{	O
iconv_ostream_SUPERCLASSES	pointer
}	O
;	O
static	O
void	O
iconv_ostream__write_mem	function
(	O
iconv_ostream_t	pointer
stream	pointer
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
char	O
inbuffer	array
[	O
BUFFERSIZE	int
]	O
;	O
size_t	long
inbufcount	long
;	O
inbufcount	int
=	O
stream	int
->	O
buflen	long
;	O
if	O
(	O
inbufcount	int
>	O
0	int
)	O
memcpy	function
(	O
inbuffer	pointer
,	O
stream	pointer
->	O
buf	pointer
,	O
inbufcount	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
{	O
size_t	long
n	long
=	O
(	O
len	long
<=	O
BUFFERSIZE	int
-	O
inbufcount	int
?	O
len	long
:	O
BUFFERSIZE	int
-	O
inbufcount	pointer
)	O
;	O
if	O
(	O
n	long
>	O
0	int
)	O
{	O
memcpy	function
(	O
inbuffer	pointer
+	O
inbufcount	O
,	O
data	pointer
,	O
n	long
)	O
;	O
data	pointer
=	O
(	O
char	O
*	O
)	O
data	pointer
+	O
n	long
;	O
inbufcount	pointer
+=	O
n	long
;	O
len	long
-=	O
n	int
;	O
}	O
}	O
{	O
char	O
outbuffer	array
[	O
8	int
*	O
BUFFERSIZE	pointer
]	O
;	O
const	O
char	O
*	O
inptr	int
=	O
inbuffer	int
;	O
size_t	long
insize	int
=	O
inbufcount	int
;	O
char	O
*	O
outptr	O
=	O
outbuffer	int
;	O
size_t	long
outsize	long
=	O
sizeof	O
(	O
outbuffer	O
)	O
;	O
size_t	long
res	int
=	O
iconv	function
(	O
stream	int
->	O
cd	O
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	O
,	O
&	O
insize	O
,	O
&	O
outptr	O
,	O
&	O
outsize	O
)	O
;	O
if	O
(	O
res	O
>	O
0	int
)	O
{	O
errno	O
=	O
EILSEQ	int
;	O
res	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
res	int
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
&&	O
errno	O
!=	O
EINVAL	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s: cannot convert from %s to %s"	pointer
)	O
,	O
"iconv_ostream"	O
,	O
stream	int
->	O
from_encoding	O
,	O
stream	int
->	O
to_encoding	pointer
)	O
;	O
if	O
(	O
sizeof	O
(	O
outbuffer	O
)	O
-	O
outsize	long
>	O
0	int
)	O
ostream_write_mem	function
(	O
stream	int
->	O
destination	int
,	O
outbuffer	pointer
,	O
sizeof	O
(	O
outbuffer	O
)	O
-	O
outsize	int
)	O
;	O
if	O
(	O
insize	int
>	O
BUFSIZE	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s: shift sequence too long"	pointer
)	O
,	O
"iconv_ostream"	O
)	O
;	O
if	O
(	O
len	int
==	O
0	int
)	O
{	O
if	O
(	O
insize	int
>	O
0	int
)	O
memcpy	function
(	O
stream	int
->	O
buf	pointer
,	O
inptr	O
,	O
insize	int
)	O
;	O
stream	int
->	O
buflen	O
=	O
insize	int
;	O
break	O
;	O
}	O
if	O
(	O
insize	int
>	O
0	int
)	O
memmove	function
(	O
inbuffer	pointer
,	O
inptr	O
,	O
insize	O
)	O
;	O
inbufcount	O
=	O
insize	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
iconv_ostream__flush	function
(	O
iconv_ostream_t	pointer
stream	pointer
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
if	O
(	O
scope	int
!=	O
FLUSH_THIS_STREAM	O
)	O
ostream_flush	function
(	O
stream	int
->	O
destination	int
,	O
scope	int
)	O
;	O
}	O
static	O
void	O
iconv_ostream__free	function
(	O
iconv_ostream_t	pointer
stream	pointer
)	O
{	O
{	O
char	O
outbuffer	array
[	O
2048	int
]	O
;	O
char	O
*	O
outptr	int
=	O
outbuffer	int
;	O
size_t	long
outsize	long
=	O
sizeof	O
(	O
outbuffer	O
)	O
;	O
size_t	long
res	int
=	O
iconv	function
(	O
stream	int
->	O
cd	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
outptr	O
,	O
&	O
outsize	O
)	O
;	O
if	O
(	O
res	O
==	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s: cannot convert from %s to %s"	pointer
)	O
,	O
"iconv_ostream"	O
,	O
stream	int
->	O
from_encoding	O
,	O
stream	int
->	O
to_encoding	O
)	O
;	O
if	O
(	O
sizeof	O
(	O
outbuffer	O
)	O
-	O
outsize	int
>	O
0	int
)	O
ostream_write_mem	function
(	O
stream	int
->	O
destination	int
,	O
outbuffer	pointer
,	O
sizeof	O
(	O
outbuffer	O
)	O
-	O
outsize	int
)	O
;	O
}	O
iconv_close	function
(	O
stream	O
->	O
cd	O
)	O
;	O
free	function
(	O
stream	int
->	O
from_encoding	O
)	O
;	O
free	function
(	O
stream	int
->	O
to_encoding	O
)	O
;	O
free	function
(	O
stream	pointer
)	O
;	O
}	O
iconv_ostream_t	O
iconv_ostream_create	function
(	O
const	O
char	O
*	O
from_encoding	pointer
,	O
const	O
char	O
*	O
to_encoding	pointer
,	O
ostream_t	O
destination	int
)	O
{	O
iconv_ostream_t	pointer
stream	pointer
=	O
XMALLOC	O
(	O
struct	O
iconv_ostream_representation	O
)	O
;	O
stream	int
->	O
base	O
.	O
vtable	pointer
=	O
&	O
iconv_ostream_vtable	function
;	O
stream	int
->	O
destination	int
=	O
destination	int
;	O
stream	int
->	O
from_encoding	pointer
=	O
xstrdup	function
(	O
from_encoding	pointer
)	O
;	O
stream	int
->	O
to_encoding	pointer
=	O
xstrdup	function
(	O
to_encoding	pointer
)	O
;	O
stream	int
->	O
cd	pointer
=	O
iconv_open	function
(	O
to_encoding	pointer
,	O
from_encoding	pointer
)	O
;	O
if	O
(	O
stream	int
->	O
cd	O
==	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
iconv_open	function
(	O
"UTF-8"	int
,	O
from_encoding	int
)	O
==	O
(	O
iconv_t	O
)	O
(	O
-	O
1	int
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s does not support conversion from %s"	pointer
)	O
,	O
"iconv"	int
,	O
from_encoding	int
)	O
;	O
else	O
if	O
(	O
iconv_open	function
(	O
to_encoding	int
,	O
"UTF-8"	int
)	O
==	O
(	O
iconv_t	pointer
)	O
(	O
-	O
1	int
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s does not support conversion to %s"	pointer
)	O
,	O
"iconv"	pointer
,	O
to_encoding	int
)	O
;	O
else	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s does not support conversion from %s to %s"	pointer
)	O
,	O
"iconv"	pointer
,	O
from_encoding	int
,	O
to_encoding	int
)	O
;	O
}	O
stream	int
->	O
buflen	long
=	O
0	int
;	O
return	O
stream	int
;	O
}	O
const	O
struct	O
iconv_ostream_implementation	struct
iconv_ostream_vtable	struct
=	O
{	O
iconv_ostream_superclasses	pointer
,	O
sizeof	O
(	O
iconv_ostream_superclasses	O
)	O
/	O
sizeof	O
(	O
iconv_ostream_superclasses	array
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
struct	O
iconv_ostream_representation	struct
)	O
,	O
iconv_ostream__write_mem	O
,	O
iconv_ostream__flush	function
,	O
iconv_ostream__free	function
,	O
}	O
;	O
void	O
iconv_ostream_write_mem	function
(	O
iconv_ostream_t	int
first_arg	int
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	long
len	long
)	O
{	O
const	O
struct	O
iconv_ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
iconv_ostream_representation_header	struct
*	O
)	O
(	O
struct	O
iconv_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
write_mem	O
(	O
first_arg	int
,	O
data	pointer
,	O
len	int
)	O
;	O
}	O
void	O
iconv_ostream_flush	function
(	O
iconv_ostream_t	int
first_arg	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
const	O
struct	O
iconv_ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
iconv_ostream_representation_header	struct
*	O
)	O
(	O
struct	O
iconv_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
flush	O
(	O
first_arg	int
,	O
scope	int
)	O
;	O
}	O
void	O
iconv_ostream_free	function
(	O
iconv_ostream_t	int
first_arg	int
)	O
{	O
const	O
struct	O
iconv_ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
iconv_ostream_representation_header	struct
*	O
)	O
(	O
struct	O
iconv_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
free	function
(	O
first_arg	int
)	O
;	O
}	O
typedef	O
int	O
dummy	int
;	O
const	O
typeinfo_t	O
ostream_typeinfo	O
=	O
{	O
"ostream"	pointer
}	O
;	O
static	O
const	O
typeinfo_t	O
*	O
const	O
ostream_superclasses	array
[	O
]	O
=	O
{	O
ostream_SUPERCLASSES	pointer
}	O
;	O
void	O
ostream_write_str	function
(	O
ostream_t	O
stream	int
,	O
const	O
char	O
*	O
string	pointer
)	O
{	O
ostream_write_mem	function
(	O
stream	int
,	O
string	pointer
,	O
strlen	function
(	O
string	pointer
)	O
)	O
;	O
}	O
void	O
ostream__write_mem	function
(	O
ostream_t	O
first_arg	int
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	long
len	int
)	O
;	O
void	O
ostream__write_mem	function
(	O
ostream_t	O
first_arg	int
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	long
len	int
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
void	O
ostream__flush	function
(	O
ostream_t	O
first_arg	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
;	O
void	O
ostream__flush	function
(	O
ostream_t	O
first_arg	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
void	O
ostream__free	function
(	O
ostream_t	O
first_arg	int
)	O
;	O
void	O
ostream__free	function
(	O
ostream_t	O
first_arg	int
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
const	O
struct	O
ostream_implementation	struct
ostream_vtable	struct
=	O
{	O
ostream_superclasses	pointer
,	O
sizeof	O
(	O
ostream_superclasses	O
)	O
/	O
sizeof	O
(	O
ostream_superclasses	array
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
struct	O
ostream_representation	struct
)	O
,	O
ostream__write_mem	O
,	O
ostream__flush	function
,	O
ostream__free	function
,	O
}	O
;	O
void	O
ostream_write_mem	function
(	O
ostream_t	O
first_arg	int
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	O
len	int
)	O
{	O
const	O
struct	O
ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
ostream_representation_header	struct
*	O
)	O
(	O
struct	O
any_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
write_mem	O
(	O
first_arg	int
,	O
data	pointer
,	O
len	int
)	O
;	O
}	O
void	O
ostream_flush	function
(	O
ostream_t	O
first_arg	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
const	O
struct	O
ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
ostream_representation_header	struct
*	O
)	O
(	O
struct	O
any_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
flush	O
(	O
first_arg	int
,	O
scope	int
)	O
;	O
}	O
void	O
ostream_free	function
(	O
ostream_t	O
first_arg	int
)	O
{	O
const	O
struct	O
ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
ostream_representation_header	struct
*	O
)	O
(	O
struct	O
any_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
free	function
(	O
first_arg	int
)	O
;	O
}	O
size_t	long
safe_rw	O
(	O
int	O
fd	int
,	O
void	O
const	O
*	O
buf	pointer
,	O
size_t	long
count	long
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
ssize_t	long
result	long
=	O
rw	O
(	O
fd	int
,	O
buf	pointer
,	O
count	long
)	O
;	O
if	O
(	O
0	int
<=	O
result	long
)	O
return	O
result	long
;	O
else	O
if	O
(	O
IS_EINTR	O
(	O
errno	O
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
errno	O
==	O
EINVAL	int
&&	O
SYS_BUFSIZE_MAX	int
<	O
count	long
)	O
count	long
=	O
SYS_BUFSIZE_MAX	int
;	O
else	O
return	O
result	long
;	O
}	O
}	O
const	O
typeinfo_t	O
styled_ostream_typeinfo	O
=	O
{	O
"styled_ostream"	pointer
}	O
;	O
static	O
const	O
typeinfo_t	O
*	O
const	O
styled_ostream_superclasses	array
[	O
]	O
=	O
{	O
styled_ostream_SUPERCLASSES	pointer
}	O
;	O
void	O
styled_ostream__write_mem	function
(	O
styled_ostream_t	O
first_arg	int
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	long
len	int
)	O
;	O
void	O
styled_ostream__write_mem	function
(	O
styled_ostream_t	O
first_arg	int
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	long
len	int
)	O
{	O
super	struct
.	O
write_mem	O
(	O
first_arg	int
,	O
data	pointer
,	O
len	long
)	O
;	O
}	O
void	O
styled_ostream__flush	function
(	O
styled_ostream_t	O
first_arg	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
;	O
void	O
styled_ostream__flush	function
(	O
styled_ostream_t	int
first_arg	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
super	struct
.	O
flush	O
(	O
first_arg	int
,	O
scope	int
)	O
;	O
}	O
void	O
styled_ostream__free	function
(	O
styled_ostream_t	O
first_arg	int
)	O
;	O
void	O
styled_ostream__free	function
(	O
styled_ostream_t	int
first_arg	int
)	O
{	O
super	struct
.	O
free	function
(	O
first_arg	int
)	O
;	O
}	O
void	O
styled_ostream__begin_use_class	function
(	O
styled_ostream_t	int
first_arg	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
;	O
void	O
styled_ostream__begin_use_class	function
(	O
styled_ostream_t	int
first_arg	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
void	O
styled_ostream__end_use_class	function
(	O
styled_ostream_t	int
first_arg	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
;	O
void	O
styled_ostream__end_use_class	function
(	O
styled_ostream_t	O
first_arg	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
void	O
styled_ostream__flush_to_current_style	function
(	O
styled_ostream_t	O
first_arg	int
)	O
;	O
void	O
styled_ostream__flush_to_current_style	function
(	O
styled_ostream_t	O
first_arg	int
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
const	O
struct	O
styled_ostream_implementation	struct
styled_ostream_vtable	struct
=	O
{	O
styled_ostream_superclasses	pointer
,	O
sizeof	O
(	O
styled_ostream_superclasses	O
)	O
/	O
sizeof	O
(	O
styled_ostream_superclasses	array
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
struct	O
styled_ostream_representation	struct
)	O
,	O
styled_ostream__write_mem	O
,	O
styled_ostream__flush	O
,	O
styled_ostream__free	function
,	O
styled_ostream__begin_use_class	function
,	O
styled_ostream__end_use_class	function
,	O
styled_ostream__flush_to_current_style	function
,	O
}	O
;	O
void	O
styled_ostream_write_mem	function
(	O
styled_ostream_t	O
first_arg	int
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	O
len	int
)	O
{	O
const	O
struct	O
styled_ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
styled_ostream_representation_header	struct
*	O
)	O
(	O
struct	O
styled_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
write_mem	O
(	O
first_arg	int
,	O
data	pointer
,	O
len	int
)	O
;	O
}	O
void	O
styled_ostream_flush	function
(	O
styled_ostream_t	int
first_arg	int
,	O
ostream_flush_scope_t	O
scope	int
)	O
{	O
const	O
struct	O
styled_ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
styled_ostream_representation_header	struct
*	O
)	O
(	O
struct	O
styled_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
flush	O
(	O
first_arg	int
,	O
scope	int
)	O
;	O
}	O
void	O
styled_ostream_free	function
(	O
styled_ostream_t	int
first_arg	int
)	O
{	O
const	O
struct	O
styled_ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
styled_ostream_representation_header	struct
*	O
)	O
(	O
struct	O
styled_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
free	function
(	O
first_arg	int
)	O
;	O
}	O
void	O
styled_ostream_begin_use_class	function
(	O
styled_ostream_t	int
first_arg	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
const	O
struct	O
styled_ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
styled_ostream_representation_header	struct
*	O
)	O
(	O
struct	O
styled_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
begin_use_class	O
(	O
first_arg	int
,	O
classname	pointer
)	O
;	O
}	O
void	O
styled_ostream_end_use_class	function
(	O
styled_ostream_t	int
first_arg	int
,	O
const	O
char	O
*	O
classname	pointer
)	O
{	O
const	O
struct	O
styled_ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
styled_ostream_representation_header	struct
*	O
)	O
(	O
struct	O
styled_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
end_use_class	O
(	O
first_arg	int
,	O
classname	pointer
)	O
;	O
}	O
void	O
styled_ostream_flush_to_current_style	function
(	O
styled_ostream_t	int
first_arg	int
)	O
{	O
const	O
struct	O
styled_ostream_implementation	struct
*	O
vtable	pointer
=	O
(	O
(	O
struct	O
styled_ostream_representation_header	struct
*	O
)	O
(	O
struct	O
styled_ostream_representation	struct
*	O
)	O
first_arg	int
)	O
->	O
vtable	pointer
;	O
vtable	pointer
->	O
flush_to_current_style	O
(	O
first_arg	int
)	O
;	O
}	O
int	O
gmp_errno	O
=	O
0	int
;	O
void	O
__gmp_exception	function
(	O
int	O
error_bit	int
)	O
{	O
gmp_errno	O
|=	O
error_bit	int
;	O
__gmp_junk	int
=	O
10	int
/	O
__gmp_0	int
;	O
abort	function
(	O
)	O
;	O
}	O
void	O
__gmp_sqrt_of_negative	function
(	O
void	O
)	O
{	O
__gmp_exception	function
(	O
GMP_ERROR_SQRT_OF_NEGATIVE	pointer
)	O
;	O
}	O
void	O
__gmp_divide_by_zero	function
(	O
void	O
)	O
{	O
__gmp_exception	function
(	O
GMP_ERROR_DIVISION_BY_ZERO	pointer
)	O
;	O
}	O
int	O
__gmp_extract_double	function
(	O
mp_ptr	pointer
rp	pointer
,	O
double	O
d	double
)	O
{	O
long	O
exp	int
;	O
unsigned	O
sc	int
;	O
unsigned	O
long	O
int	O
manh	O
,	O
manl	O
;	O
ASSERT	O
(	O
d	long
>=	O
0.0	int
)	O
;	O
if	O
(	O
d	long
==	O
0.0	int
)	O
{	O
MPN_ZERO	O
(	O
rp	pointer
,	O
LIMBS_PER_DOUBLE	O
)	O
;	O
return	O
0	int
;	O
}	O
{	O
union	O
ieee_double_extract	union
x	union
;	O
x	double
.	O
d	long
=	O
d	double
;	O
exp	int
=	O
x	double
.	O
s	struct
.	O
exp	int
;	O
manl	O
=	O
(	O
(	O
(	O
mp_limb_t	long
)	O
1	int
<<	O
63	int
)	O
|	O
(	O
(	O
mp_limb_t	long
)	O
x	double
.	O
s	array
.	O
manh	O
<<	O
43	int
)	O
|	O
(	O
(	O
mp_limb_t	long
)	O
x	double
.	O
s	array
.	O
manl	O
<<	O
11	int
)	O
)	O
;	O
if	O
(	O
exp	int
==	O
0	int
)	O
{	O
exp	int
=	O
1	int
;	O
do	O
{	O
manl	O
=	O
manl	O
<<	O
1	int
;	O
exp	int
--	O
;	O
}	O
while	O
(	O
(	O
manl	O
&	O
GMP_LIMB_HIGHBIT	O
)	O
==	O
0	int
)	O
;	O
}	O
exp	int
-=	O
1022	int
;	O
}	O
sc	double
=	O
(	O
unsigned	O
)	O
(	O
exp	int
+	O
64	int
*	O
GMP_NUMB_BITS	O
)	O
%	O
GMP_NUMB_BITS	O
;	O
exp	int
=	O
(	O
exp	int
+	O
64	int
*	O
GMP_NUMB_BITS	O
)	O
/	O
GMP_NUMB_BITS	O
-	O
64	int
*	O
GMP_NUMB_BITS	O
/	O
GMP_NUMB_BITS	O
+	O
1	int
;	O
if	O
(	O
sc	int
!=	O
0	int
)	O
{	O
rp	pointer
[	O
1	int
]	O
=	O
manl	O
>>	O
(	O
GMP_LIMB_BITS	int
-	O
sc	int
)	O
;	O
rp	pointer
[	O
0	int
]	O
=	O
manl	O
<<	O
sc	int
;	O
}	O
else	O
{	O
rp	pointer
[	O
1	int
]	O
=	O
manl	O
;	O
rp	pointer
[	O
0	int
]	O
=	O
0	int
;	O
exp	int
--	O
;	O
}	O
return	O
exp	int
;	O
}	O
void	O
mpf_add	O
(	O
mpf_ptr	pointer
r	pointer
,	O
mpf_srcptr	pointer
u	array
,	O
mpf_srcptr	pointer
v	pointer
)	O
{	O
mp_srcptr	pointer
up	pointer
,	O
vp	pointer
;	O
mp_ptr	pointer
rp	pointer
,	O
tp	pointer
;	O
mp_size_t	long
usize	pointer
,	O
vsize	long
,	O
rsize	long
;	O
mp_size_t	long
prec	int
;	O
mp_exp_t	long
uexp	long
;	O
mp_size_t	long
ediff	long
;	O
mp_limb_t	long
cy	long
;	O
int	O
negate	long
;	O
TMP_DECL	O
;	O
usize	pointer
=	O
u	array
->	O
_mp_size	int
;	O
vsize	long
=	O
v	pointer
->	O
_mp_size	int
;	O
if	O
(	O
usize	pointer
==	O
0	int
)	O
{	O
set_r_v_maybe	O
:	O
if	O
(	O
r	pointer
!=	O
v	pointer
)	O
mpf_set	O
(	O
r	pointer
,	O
v	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
vsize	long
==	O
0	int
)	O
{	O
v	pointer
=	O
u	pointer
;	O
goto	O
set_r_v_maybe	O
;	O
}	O
if	O
(	O
(	O
usize	pointer
^	O
vsize	long
)	O
<	O
0	int
)	O
{	O
__mpf_struct	O
v_negated	pointer
;	O
v_negated	struct
.	O
_mp_size	int
=	O
-	O
vsize	long
;	O
v_negated	struct
.	O
_mp_exp	long
=	O
v	pointer
->	O
_mp_exp	long
;	O
v_negated	struct
.	O
_mp_d	pointer
=	O
v	pointer
->	O
_mp_d	pointer
;	O
mpf_sub	O
(	O
r	pointer
,	O
u	array
,	O
&	O
v_negated	O
)	O
;	O
return	O
;	O
}	O
TMP_MARK	O
;	O
negate	long
=	O
usize	pointer
<	O
0	int
;	O
if	O
(	O
u	pointer
->	O
_mp_exp	long
<	O
v	pointer
->	O
_mp_exp	long
)	O
{	O
mpf_srcptr	pointer
t	pointer
;	O
t	pointer
=	O
u	array
;	O
u	array
=	O
v	pointer
;	O
v	pointer
=	O
t	long
;	O
usize	pointer
=	O
u	array
->	O
_mp_size	int
;	O
vsize	long
=	O
v	pointer
->	O
_mp_size	int
;	O
}	O
usize	pointer
=	O
ABS	O
(	O
usize	pointer
)	O
;	O
vsize	long
=	O
ABS	O
(	O
vsize	long
)	O
;	O
up	pointer
=	O
u	array
->	O
_mp_d	pointer
;	O
vp	pointer
=	O
v	pointer
->	O
_mp_d	pointer
;	O
rp	pointer
=	O
r	pointer
->	O
_mp_d	pointer
;	O
prec	int
=	O
r	pointer
->	O
_mp_prec	int
;	O
uexp	long
=	O
u	array
->	O
_mp_exp	long
;	O
ediff	long
=	O
u	array
->	O
_mp_exp	long
-	O
v	pointer
->	O
_mp_exp	long
;	O
if	O
(	O
usize	pointer
>	O
prec	int
)	O
{	O
up	pointer
+=	O
usize	pointer
-	O
prec	int
;	O
usize	pointer
=	O
prec	int
;	O
}	O
if	O
(	O
vsize	long
+	O
ediff	int
>	O
prec	int
)	O
{	O
vp	pointer
+=	O
vsize	long
+	O
ediff	int
-	O
prec	int
;	O
vsize	long
=	O
prec	int
-	O
ediff	int
;	O
}	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
prec	int
)	O
;	O
if	O
(	O
ediff	enum
>=	O
prec	int
)	O
{	O
if	O
(	O
rp	pointer
!=	O
up	pointer
)	O
MPN_COPY_INCR	O
(	O
rp	pointer
,	O
up	pointer
,	O
usize	pointer
)	O
;	O
rsize	long
=	O
usize	pointer
;	O
}	O
else	O
{	O
if	O
(	O
usize	pointer
>	O
ediff	int
)	O
{	O
if	O
(	O
vsize	long
+	O
ediff	long
<=	O
usize	pointer
)	O
{	O
mp_size_t	long
size	long
;	O
size	long
=	O
usize	pointer
-	O
ediff	long
-	O
vsize	long
;	O
MPN_COPY	O
(	O
tp	pointer
,	O
up	pointer
,	O
size	long
)	O
;	O
cy	long
=	O
mpn_add	O
(	O
tp	pointer
+	O
size	long
,	O
up	pointer
+	O
size	long
,	O
usize	pointer
-	O
size	long
,	O
vp	pointer
,	O
vsize	long
)	O
;	O
rsize	long
=	O
usize	pointer
;	O
}	O
else	O
{	O
mp_size_t	long
size	long
;	O
size	long
=	O
vsize	long
+	O
ediff	int
-	O
usize	pointer
;	O
MPN_COPY	O
(	O
tp	pointer
,	O
vp	pointer
,	O
size	long
)	O
;	O
cy	long
=	O
mpn_add	O
(	O
tp	pointer
+	O
size	long
,	O
up	pointer
,	O
usize	pointer
,	O
vp	pointer
+	O
size	long
,	O
usize	pointer
-	O
ediff	long
)	O
;	O
rsize	long
=	O
vsize	long
+	O
ediff	int
;	O
}	O
}	O
else	O
{	O
mp_size_t	long
size	long
;	O
size	long
=	O
vsize	long
+	O
ediff	int
-	O
usize	pointer
;	O
MPN_COPY	O
(	O
tp	pointer
,	O
vp	pointer
,	O
vsize	long
)	O
;	O
MPN_ZERO	O
(	O
tp	pointer
+	O
vsize	long
,	O
ediff	pointer
-	O
usize	pointer
)	O
;	O
MPN_COPY	O
(	O
tp	pointer
+	O
size	long
,	O
up	pointer
,	O
usize	pointer
)	O
;	O
cy	long
=	O
0	int
;	O
rsize	long
=	O
size	long
+	O
usize	pointer
;	O
}	O
MPN_COPY	O
(	O
rp	pointer
,	O
tp	pointer
,	O
rsize	long
)	O
;	O
rp	pointer
[	O
rsize	long
]	O
=	O
cy	long
;	O
rsize	long
+=	O
cy	long
;	O
uexp	long
+=	O
cy	long
;	O
}	O
r	pointer
->	O
_mp_size	int
=	O
negate	long
?	O
-	O
rsize	long
:	O
rsize	long
;	O
r	pointer
->	O
_mp_exp	long
=	O
uexp	long
;	O
TMP_FREE	O
;	O
}	O
void	O
mpf_add_ui	O
(	O
mpf_ptr	pointer
sum	pointer
,	O
mpf_srcptr	pointer
u	pointer
,	O
unsigned	O
long	O
int	O
v	long
)	O
{	O
mp_srcptr	pointer
up	pointer
=	O
u	array
->	O
_mp_d	pointer
;	O
mp_ptr	pointer
sump	pointer
=	O
sum	pointer
->	O
_mp_d	pointer
;	O
mp_size_t	long
usize	pointer
,	O
sumsize	long
;	O
mp_size_t	long
prec	int
=	O
sum	pointer
->	O
_mp_prec	int
;	O
mp_exp_t	long
uexp	long
=	O
u	array
->	O
_mp_exp	long
;	O
usize	pointer
=	O
u	array
->	O
_mp_size	int
;	O
if	O
(	O
usize	pointer
<=	O
0	int
)	O
{	O
if	O
(	O
usize	pointer
==	O
0	int
)	O
{	O
mpf_set_ui	O
(	O
sum	pointer
,	O
v	pointer
)	O
;	O
return	O
;	O
}	O
else	O
{	O
__mpf_struct	struct
u_negated	pointer
;	O
u_negated	struct
.	O
_mp_size	int
=	O
-	O
usize	pointer
;	O
u_negated	struct
.	O
_mp_exp	long
=	O
u	array
->	O
_mp_exp	long
;	O
u_negated	struct
.	O
_mp_d	pointer
=	O
u	array
->	O
_mp_d	pointer
;	O
mpf_sub_ui	function
(	O
sum	pointer
,	O
&	O
u_negated	pointer
,	O
v	pointer
)	O
;	O
sum	pointer
->	O
_mp_size	int
=	O
-	O
(	O
sum	pointer
->	O
_mp_size	int
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
v	pointer
==	O
0	int
)	O
{	O
sum_is_u	function
:	O
if	O
(	O
u	pointer
!=	O
sum	long
)	O
{	O
sumsize	int
=	O
MIN	O
(	O
usize	pointer
,	O
prec	int
+	O
1	int
)	O
;	O
MPN_COPY	O
(	O
sum	pointer
->	O
_mp_d	pointer
,	O
up	pointer
+	O
usize	pointer
-	O
sumsize	pointer
,	O
sumsize	int
)	O
;	O
sum	pointer
->	O
_mp_size	int
=	O
sumsize	long
;	O
sum	pointer
->	O
_mp_exp	long
=	O
u	array
->	O
_mp_exp	long
;	O
}	O
return	O
;	O
}	O
if	O
(	O
uexp	long
>	O
0	int
)	O
{	O
if	O
(	O
uexp	long
>	O
prec	int
)	O
{	O
goto	O
sum_is_u	O
;	O
}	O
else	O
{	O
if	O
(	O
uexp	long
>	O
usize	pointer
)	O
{	O
MPN_COPY_DECR	O
(	O
sump	int
+	O
uexp	long
-	O
usize	pointer
,	O
up	pointer
,	O
usize	pointer
)	O
;	O
sump	array
[	O
0	int
]	O
=	O
v	pointer
;	O
MPN_ZERO	O
(	O
sump	long
+	O
1	int
,	O
uexp	long
-	O
usize	pointer
-	O
1	int
)	O
;	O
sum	pointer
->	O
_mp_size	int
=	O
uexp	long
;	O
sum	pointer
->	O
_mp_exp	long
=	O
uexp	long
;	O
}	O
else	O
{	O
mp_limb_t	long
cy_limb	long
;	O
if	O
(	O
usize	pointer
>	O
prec	int
)	O
{	O
up	pointer
+=	O
usize	pointer
-	O
prec	int
;	O
usize	pointer
-=	O
usize	pointer
-	O
prec	int
;	O
}	O
if	O
(	O
sump	pointer
!=	O
up	pointer
)	O
MPN_COPY_INCR	O
(	O
sump	pointer
,	O
up	pointer
,	O
usize	pointer
-	O
uexp	long
)	O
;	O
cy_limb	long
=	O
mpn_add_1	O
(	O
sump	pointer
+	O
usize	pointer
-	O
uexp	long
,	O
up	pointer
+	O
usize	pointer
-	O
uexp	long
,	O
uexp	long
,	O
(	O
mp_limb_t	long
)	O
v	long
)	O
;	O
sump	array
[	O
usize	pointer
]	O
=	O
cy_limb	long
;	O
sum	pointer
->	O
_mp_size	int
=	O
usize	pointer
+	O
cy_limb	long
;	O
sum	pointer
->	O
_mp_exp	long
=	O
uexp	long
+	O
cy_limb	long
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
-	O
uexp	long
)	O
>=	O
prec	int
)	O
{	O
sump	array
[	O
0	int
]	O
=	O
v	long
;	O
sum	pointer
->	O
_mp_size	int
=	O
1	int
;	O
sum	pointer
->	O
_mp_exp	long
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
usize	pointer
+	O
(	O
-	O
uexp	long
)	O
+	O
1	int
>	O
prec	int
)	O
{	O
up	pointer
+=	O
usize	pointer
+	O
(	O
-	O
uexp	long
)	O
+	O
1	int
-	O
prec	int
;	O
usize	pointer
-=	O
usize	pointer
+	O
(	O
-	O
uexp	long
)	O
+	O
1	int
-	O
prec	int
;	O
}	O
if	O
(	O
sump	pointer
!=	O
up	pointer
)	O
MPN_COPY_INCR	O
(	O
sump	pointer
,	O
up	pointer
,	O
usize	pointer
)	O
;	O
MPN_ZERO	O
(	O
sump	pointer
+	O
usize	pointer
,	O
-	O
uexp	long
)	O
;	O
sump	array
[	O
usize	pointer
+	O
(	O
-	O
uexp	long
)	O
]	O
=	O
v	long
;	O
sum	pointer
->	O
_mp_size	int
=	O
usize	pointer
+	O
(	O
-	O
uexp	long
)	O
+	O
1	int
;	O
sum	pointer
->	O
_mp_exp	long
=	O
1	int
;	O
}	O
}	O
}	O
static	O
void	O
__gmpf_ceil_or_floor	function
(	O
REGPARM_2_1	function
(	O
mpf_ptr	pointer
,	O
mpf_srcptr	pointer
,	O
int	O
)	O
)	O
REGPARM_ATTR	O
(	O
1	int
)	O
;	O
REGPARM_ATTR	O
(	O
1	int
)	O
static	O
void	O
mpf_ceil_or_floor	O
(	O
mpf_ptr	pointer
r	pointer
,	O
mpf_srcptr	pointer
u	pointer
,	O
int	O
dir	int
)	O
{	O
mp_ptr	pointer
rp	pointer
,	O
up	pointer
,	O
p	pointer
;	O
mp_size_t	long
size	long
,	O
asize	long
,	O
prec	int
;	O
mp_exp_t	long
exp	int
;	O
size	long
=	O
SIZ	O
(	O
u	array
)	O
;	O
if	O
(	O
size	long
==	O
0	int
)	O
{	O
zero	O
:	O
SIZ	O
(	O
r	pointer
)	O
=	O
0	int
;	O
EXP	O
(	O
r	pointer
)	O
=	O
0	int
;	O
return	O
;	O
}	O
rp	pointer
=	O
PTR	O
(	O
r	pointer
)	O
;	O
exp	int
=	O
EXP	O
(	O
u	array
)	O
;	O
if	O
(	O
exp	int
<=	O
0	int
)	O
{	O
if	O
(	O
(	O
size	long
^	O
dir	int
)	O
<	O
0	int
)	O
goto	O
zero	O
;	O
rp	pointer
[	O
0	int
]	O
=	O
1	int
;	O
EXP	O
(	O
r	array
)	O
=	O
1	int
;	O
SIZ	O
(	O
r	pointer
)	O
=	O
dir	int
;	O
return	O
;	O
}	O
EXP	O
(	O
r	pointer
)	O
=	O
exp	int
;	O
up	pointer
=	O
PTR	O
(	O
u	array
)	O
;	O
asize	long
=	O
ABS	O
(	O
size	long
)	O
;	O
up	pointer
+=	O
asize	long
;	O
asize	long
=	O
MIN	O
(	O
asize	long
,	O
exp	int
)	O
;	O
prec	int
=	O
PREC	O
(	O
r	pointer
)	O
+	O
1	int
;	O
asize	long
=	O
MIN	O
(	O
asize	long
,	O
prec	int
)	O
;	O
up	pointer
-=	O
asize	long
;	O
if	O
(	O
(	O
size	long
^	O
dir	int
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
p	pointer
=	O
PTR	O
(	O
u	array
)	O
;	O
p	pointer
!=	O
up	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
mpn_add_1	O
(	O
rp	pointer
,	O
up	pointer
,	O
asize	long
,	O
CNST_LIMB	O
(	O
1	int
)	O
)	O
)	O
{	O
rp	pointer
[	O
0	int
]	O
=	O
1	int
;	O
asize	long
=	O
1	int
;	O
EXP	O
(	O
r	array
)	O
++	O
;	O
}	O
SIZ	O
(	O
r	pointer
)	O
=	O
(	O
size	long
>=	O
0	int
?	O
asize	long
:	O
-	O
asize	long
)	O
;	O
return	O
;	O
}	O
}	O
}	O
SIZ	O
(	O
r	pointer
)	O
=	O
(	O
size	long
>=	O
0	int
?	O
asize	long
:	O
-	O
asize	long
)	O
;	O
if	O
(	O
rp	pointer
!=	O
up	pointer
)	O
MPN_COPY_INCR	O
(	O
rp	pointer
,	O
up	pointer
,	O
asize	long
)	O
;	O
}	O
void	O
mpf_ceil	O
(	O
mpf_ptr	pointer
r	pointer
,	O
mpf_srcptr	pointer
u	array
)	O
{	O
mpf_ceil_or_floor	function
(	O
r	pointer
,	O
u	array
,	O
1	int
)	O
;	O
}	O
void	O
mpf_floor	O
(	O
mpf_ptr	pointer
r	pointer
,	O
mpf_srcptr	pointer
u	array
)	O
{	O
mpf_ceil_or_floor	function
(	O
r	pointer
,	O
u	array
,	O
-	O
1	int
)	O
;	O
}	O
int	O
mpf_cmp_d	function
(	O
mpf_srcptr	pointer
f	pointer
,	O
double	O
d	long
)	O
{	O
mp_limb_t	long
darray	array
[	O
LIMBS_PER_DOUBLE	O
]	O
;	O
mpf_t	pointer
df	pointer
;	O
DOUBLE_NAN_INF_ACTION	O
(	O
d	long
,	O
__gmp_invalid_operation	function
(	O
)	O
,	O
return	O
(	O
d	long
<	O
0.0	int
?	O
1	int
:	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
d	long
==	O
0.0	int
)	O
return	O
SIZ	O
(	O
f	pointer
)	O
;	O
PTR	O
(	O
df	pointer
)	O
=	O
darray	array
;	O
SIZ	O
(	O
df	pointer
)	O
=	O
(	O
d	long
>=	O
0.0	int
?	O
LIMBS_PER_DOUBLE	O
:	O
-	O
LIMBS_PER_DOUBLE	O
)	O
;	O
EXP	O
(	O
df	pointer
)	O
=	O
__gmp_extract_double	function
(	O
darray	array
,	O
ABS	O
(	O
d	long
)	O
)	O
;	O
return	O
mpf_cmp	function
(	O
f	pointer
,	O
df	pointer
)	O
;	O
}	O
int	O
mpf_cmp_ui	O
(	O
mpf_srcptr	pointer
u	pointer
,	O
unsigned	O
long	O
int	O
vval	long
)	O
__GMP_NOTHROW	O
{	O
mp_srcptr	pointer
up	pointer
;	O
mp_size_t	long
usize	pointer
;	O
mp_exp_t	long
uexp	long
;	O
mp_limb_t	long
ulimb	long
;	O
uexp	long
=	O
u	array
->	O
_mp_exp	long
;	O
usize	pointer
=	O
u	array
->	O
_mp_size	int
;	O
if	O
(	O
usize	pointer
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
vval	long
==	O
0	int
)	O
return	O
usize	pointer
!=	O
0	int
;	O
if	O
(	O
uexp	long
>	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
uexp	long
<	O
1	int
)	O
return	O
-	O
1	int
;	O
up	pointer
=	O
u	array
->	O
_mp_d	pointer
;	O
ulimb	long
=	O
up	pointer
[	O
usize	pointer
-	O
1	int
]	O
;	O
usize	pointer
--	O
;	O
if	O
(	O
ulimb	long
>	O
vval	long
)	O
return	O
1	int
;	O
else	O
if	O
(	O
ulimb	long
<	O
vval	long
)	O
return	O
-	O
1	int
;	O
while	O
(	O
*	O
up	pointer
==	O
0	int
)	O
{	O
up	pointer
++	O
;	O
usize	pointer
--	O
;	O
}	O
if	O
(	O
usize	pointer
>	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
mpf_div_2exp	O
(	O
mpf_ptr	pointer
r	pointer
,	O
mpf_srcptr	pointer
u	array
,	O
mp_bitcnt_t	long
exp	int
)	O
{	O
mp_srcptr	pointer
up	pointer
;	O
mp_ptr	pointer
rp	pointer
=	O
r	pointer
->	O
_mp_d	pointer
;	O
mp_size_t	long
usize	pointer
;	O
mp_size_t	long
abs_usize	long
;	O
mp_size_t	long
prec	int
=	O
r	pointer
->	O
_mp_prec	int
;	O
mp_exp_t	long
uexp	long
=	O
u	array
->	O
_mp_exp	long
;	O
usize	pointer
=	O
u	array
->	O
_mp_size	int
;	O
if	O
(	O
UNLIKELY	O
(	O
usize	pointer
==	O
0	int
)	O
)	O
{	O
r	pointer
->	O
_mp_size	int
=	O
0	int
;	O
r	pointer
->	O
_mp_exp	long
=	O
0	int
;	O
return	O
;	O
}	O
abs_usize	int
=	O
ABS	O
(	O
usize	pointer
)	O
;	O
up	pointer
=	O
u	array
->	O
_mp_d	pointer
;	O
if	O
(	O
exp	int
%	O
GMP_NUMB_BITS	O
==	O
0	int
)	O
{	O
prec	int
++	O
;	O
if	O
(	O
abs_usize	int
>	O
prec	int
)	O
{	O
up	pointer
+=	O
abs_usize	int
-	O
prec	int
;	O
abs_usize	int
=	O
prec	int
;	O
}	O
if	O
(	O
rp	pointer
!=	O
up	pointer
)	O
MPN_COPY_INCR	O
(	O
rp	pointer
,	O
up	pointer
,	O
abs_usize	int
)	O
;	O
r	pointer
->	O
_mp_exp	long
=	O
uexp	long
-	O
exp	int
/	O
GMP_NUMB_BITS	O
;	O
}	O
else	O
{	O
mp_limb_t	long
cy_limb	long
;	O
mp_size_t	long
adj	long
;	O
if	O
(	O
abs_usize	int
>	O
prec	int
)	O
{	O
up	pointer
+=	O
abs_usize	int
-	O
prec	int
;	O
abs_usize	int
=	O
prec	int
;	O
cy_limb	long
=	O
mpn_rshift	O
(	O
rp	pointer
+	O
1	int
,	O
up	pointer
,	O
abs_usize	int
,	O
exp	int
%	O
GMP_NUMB_BITS	O
)	O
;	O
rp	pointer
[	O
0	int
]	O
=	O
cy_limb	long
;	O
adj	long
=	O
rp	pointer
[	O
abs_usize	int
]	O
!=	O
0	int
;	O
}	O
else	O
{	O
cy_limb	long
=	O
mpn_lshift	O
(	O
rp	pointer
,	O
up	pointer
,	O
abs_usize	pointer
,	O
GMP_NUMB_BITS	O
-	O
exp	int
%	O
GMP_NUMB_BITS	O
)	O
;	O
rp	pointer
[	O
abs_usize	int
]	O
=	O
cy_limb	long
;	O
adj	long
=	O
cy_limb	long
!=	O
0	int
;	O
}	O
abs_usize	long
+=	O
adj	long
;	O
r	pointer
->	O
_mp_exp	long
=	O
uexp	long
-	O
exp	int
/	O
GMP_NUMB_BITS	O
-	O
1	int
+	O
adj	long
;	O
}	O
r	pointer
->	O
_mp_size	int
=	O
usize	pointer
>=	O
0	int
?	O
abs_usize	int
:	O
-	O
abs_usize	int
;	O
}	O
int	O
mpf_eq	O
(	O
mpf_srcptr	pointer
u	array
,	O
mpf_srcptr	pointer
v	pointer
,	O
mp_bitcnt_t	long
n_bits	long
)	O
{	O
mp_srcptr	pointer
up	pointer
,	O
vp	pointer
,	O
p	pointer
;	O
mp_size_t	long
usize	pointer
,	O
vsize	long
,	O
minsize	int
,	O
maxsize	pointer
,	O
n_limbs	pointer
,	O
i	long
,	O
size	long
;	O
mp_exp_t	long
uexp	long
,	O
vexp	long
;	O
mp_limb_t	long
diff	O
;	O
int	O
cnt	int
;	O
uexp	long
=	O
u	array
->	O
_mp_exp	long
;	O
vexp	long
=	O
v	pointer
->	O
_mp_exp	long
;	O
usize	pointer
=	O
u	array
->	O
_mp_size	int
;	O
vsize	long
=	O
v	pointer
->	O
_mp_size	int
;	O
if	O
(	O
(	O
usize	pointer
^	O
vsize	long
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
usize	pointer
==	O
0	int
)	O
return	O
vsize	long
==	O
0	int
;	O
if	O
(	O
vsize	long
==	O
0	int
)	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
uexp	long
!=	O
vexp	long
)	O
return	O
0	int
;	O
usize	pointer
=	O
ABS	O
(	O
usize	pointer
)	O
;	O
vsize	long
=	O
ABS	O
(	O
vsize	long
)	O
;	O
up	pointer
=	O
u	array
->	O
_mp_d	pointer
;	O
vp	pointer
=	O
v	pointer
->	O
_mp_d	pointer
;	O
up	pointer
+=	O
usize	pointer
;	O
vp	pointer
+=	O
vsize	long
;	O
count_leading_zeros	O
(	O
cnt	int
,	O
up	pointer
[	O
-	O
1	int
]	O
)	O
;	O
if	O
(	O
(	O
vp	pointer
[	O
-	O
1	int
]	O
>>	O
(	O
GMP_LIMB_BITS	int
-	O
1	int
-	O
cnt	int
)	O
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
n_bits	long
+=	O
cnt	int
-	O
GMP_NAIL_BITS	int
;	O
n_limbs	long
=	O
(	O
n_bits	long
+	O
GMP_NUMB_BITS	O
-	O
1	int
)	O
/	O
GMP_NUMB_BITS	O
;	O
usize	pointer
=	O
MIN	O
(	O
usize	pointer
,	O
n_limbs	int
)	O
;	O
vsize	long
=	O
MIN	O
(	O
vsize	long
,	O
n_limbs	int
)	O
;	O
minsize	long
=	O
MIN	O
(	O
usize	pointer
,	O
vsize	long
)	O
;	O
maxsize	long
=	O
usize	pointer
+	O
vsize	long
-	O
minsize	long
;	O
up	pointer
-=	O
minsize	long
;	O
vp	pointer
-=	O
minsize	int
;	O
for	O
(	O
i	long
=	O
minsize	int
-	O
1	int
;	O
i	long
>	O
0	int
;	O
i	long
--	O
)	O
{	O
if	O
(	O
up	pointer
[	O
i	long
]	O
!=	O
vp	pointer
[	O
i	long
]	O
)	O
return	O
0	int
;	O
}	O
n_bits	long
-=	O
(	O
maxsize	long
-	O
1	int
)	O
*	O
GMP_NUMB_BITS	O
;	O
size	long
=	O
maxsize	int
-	O
minsize	int
;	O
if	O
(	O
size	long
!=	O
0	int
)	O
{	O
if	O
(	O
up	pointer
[	O
0	int
]	O
!=	O
vp	pointer
[	O
0	int
]	O
)	O
return	O
0	int
;	O
if	O
(	O
usize	pointer
>	O
vsize	long
)	O
p	pointer
=	O
up	pointer
-	O
size	long
;	O
else	O
p	pointer
=	O
vp	pointer
-	O
size	long
;	O
for	O
(	O
i	long
=	O
size	long
-	O
1	int
;	O
i	long
>	O
0	int
;	O
i	long
--	O
)	O
{	O
if	O
(	O
p	pointer
[	O
i	long
]	O
!=	O
0	int
)	O
return	O
0	int
;	O
}	O
diff	char
=	O
p	pointer
[	O
0	int
]	O
;	O
}	O
else	O
{	O
diff	char
=	O
up	pointer
[	O
0	int
]	O
^	O
vp	pointer
[	O
0	int
]	O
;	O
}	O
if	O
(	O
n_bits	long
<	O
GMP_NUMB_BITS	O
)	O
diff	O
>>=	O
GMP_NUMB_BITS	O
-	O
n_bits	int
;	O
return	O
diff	char
==	O
0	int
;	O
}	O
double	O
mpf_get_d_2exp	function
(	O
signed	O
long	O
int	O
*	O
exp2	pointer
,	O
mpf_srcptr	pointer
src	pointer
)	O
{	O
mp_size_t	long
size	long
,	O
abs_size	long
;	O
mp_srcptr	pointer
ptr	pointer
;	O
int	O
cnt	int
;	O
long	O
exp	int
;	O
size	long
=	O
SIZ	O
(	O
src	pointer
)	O
;	O
if	O
(	O
UNLIKELY	O
(	O
size	long
==	O
0	int
)	O
)	O
{	O
*	O
exp2	pointer
=	O
0	int
;	O
return	O
0.0	int
;	O
}	O
ptr	pointer
=	O
PTR	O
(	O
src	pointer
)	O
;	O
abs_size	int
=	O
ABS	O
(	O
size	long
)	O
;	O
count_leading_zeros	O
(	O
cnt	int
,	O
ptr	pointer
[	O
abs_size	long
-	O
1	int
]	O
)	O
;	O
cnt	int
-=	O
GMP_NAIL_BITS	int
;	O
exp	int
=	O
EXP	O
(	O
src	pointer
)	O
*	O
GMP_NUMB_BITS	O
-	O
cnt	int
;	O
*	O
exp2	pointer
=	O
exp	int
;	O
return	O
mpn_get_d	O
(	O
ptr	pointer
,	O
abs_size	long
,	O
(	O
mp_size_t	long
)	O
0	int
,	O
(	O
long	O
)	O
-	O
(	O
abs_size	long
*	O
GMP_NUMB_BITS	O
-	O
cnt	int
)	O
)	O
;	O
}	O
unsigned	O
long	O
mpf_get_ui	function
(	O
mpf_srcptr	pointer
f	pointer
)	O
__GMP_NOTHROW	O
{	O
mp_size_t	long
size	long
;	O
mp_exp_t	long
exp	int
;	O
mp_srcptr	pointer
fp	pointer
;	O
mp_limb_t	long
fl	long
;	O
exp	int
=	O
EXP	O
(	O
f	pointer
)	O
;	O
size	long
=	O
SIZ	O
(	O
f	pointer
)	O
;	O
fp	pointer
=	O
PTR	O
(	O
f	pointer
)	O
;	O
fl	long
=	O
0	int
;	O
if	O
(	O
exp	int
>	O
0	int
)	O
{	O
size	long
=	O
ABS	O
(	O
size	long
)	O
;	O
if	O
(	O
size	long
>=	O
exp	int
)	O
fl	long
=	O
fp	pointer
[	O
size	long
-	O
exp	int
]	O
;	O
}	O
return	O
(	O
unsigned	O
long	O
)	O
fl	double
;	O
}	O
int	O
mpf_integer_p	function
(	O
mpf_srcptr	pointer
f	pointer
)	O
__GMP_NOTHROW	O
{	O
mp_srcptr	pointer
ptr	pointer
;	O
mp_exp_t	long
exp	int
;	O
mp_size_t	long
size	long
,	O
frac	double
,	O
i	long
;	O
size	long
=	O
SIZ	O
(	O
f	pointer
)	O
;	O
if	O
(	O
size	long
==	O
0	int
)	O
return	O
1	int
;	O
exp	int
=	O
EXP	O
(	O
f	pointer
)	O
;	O
if	O
(	O
exp	int
<=	O
0	int
)	O
return	O
0	int
;	O
frac	long
=	O
ABS	O
(	O
size	long
)	O
-	O
exp	int
;	O
ptr	pointer
=	O
PTR	O
(	O
f	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
frac	long
;	O
i	long
++	O
)	O
if	O
(	O
ptr	pointer
[	O
i	long
]	O
!=	O
0	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
void	O
mpf_init_set	O
(	O
mpf_ptr	pointer
r	pointer
,	O
mpf_srcptr	pointer
s	pointer
)	O
{	O
mp_ptr	pointer
rp	pointer
,	O
sp	pointer
;	O
mp_size_t	long
ssize	long
,	O
size	long
;	O
mp_size_t	long
prec	int
;	O
prec	int
=	O
__gmp_default_fp_limb_precision	long
;	O
r	pointer
->	O
_mp_d	pointer
=	O
(	O
mp_ptr	pointer
)	O
(	O
*	O
__gmp_allocate_func	pointer
)	O
(	O
(	O
prec	int
+	O
1	int
)	O
*	O
BYTES_PER_MP_LIMB	int
)	O
;	O
r	pointer
->	O
_mp_prec	int
=	O
prec	int
;	O
prec	int
++	O
;	O
ssize	long
=	O
s	array
->	O
_mp_size	int
;	O
size	long
=	O
ABS	O
(	O
ssize	long
)	O
;	O
rp	pointer
=	O
r	pointer
->	O
_mp_d	pointer
;	O
sp	pointer
=	O
s	pointer
->	O
_mp_d	pointer
;	O
if	O
(	O
size	long
>	O
prec	int
)	O
{	O
sp	pointer
+=	O
size	long
-	O
prec	int
;	O
size	long
=	O
prec	int
;	O
}	O
r	pointer
->	O
_mp_exp	long
=	O
s	pointer
->	O
_mp_exp	long
;	O
r	pointer
->	O
_mp_size	int
=	O
ssize	long
>=	O
0	int
?	O
size	long
:	O
-	O
size	long
;	O
MPN_COPY	O
(	O
rp	pointer
,	O
sp	pointer
,	O
size	long
)	O
;	O
}	O
void	O
mpf_init_set_si	O
(	O
mpf_ptr	pointer
r	pointer
,	O
long	O
int	O
val	long
)	O
{	O
mp_size_t	long
prec	int
=	O
__gmp_default_fp_limb_precision	long
;	O
mp_size_t	long
size	long
;	O
mp_limb_t	long
vl	long
;	O
r	pointer
->	O
_mp_prec	int
=	O
prec	int
;	O
r	pointer
->	O
_mp_d	pointer
=	O
(	O
mp_ptr	pointer
)	O
(	O
*	O
__gmp_allocate_func	pointer
)	O
(	O
(	O
prec	int
+	O
1	int
)	O
*	O
BYTES_PER_MP_LIMB	int
)	O
;	O
vl	long
=	O
(	O
mp_limb_t	long
)	O
ABS_CAST	function
(	O
unsigned	O
long	O
int	O
,	O
val	long
)	O
;	O
r	pointer
->	O
_mp_d	pointer
[	O
0	int
]	O
=	O
vl	long
&	O
GMP_NUMB_MASK	O
;	O
size	long
=	O
vl	long
!=	O
0	int
;	O
r	pointer
->	O
_mp_exp	long
=	O
size	long
;	O
r	pointer
->	O
_mp_size	int
=	O
val	double
>=	O
0	int
?	O
size	long
:	O
-	O
size	long
;	O
}	O
int	O
mpf_init_set_str	function
(	O
mpf_ptr	pointer
r	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
int	O
base	int
)	O
{	O
mp_size_t	long
prec	int
=	O
__gmp_default_fp_limb_precision	long
;	O
r	pointer
->	O
_mp_size	int
=	O
0	int
;	O
r	pointer
->	O
_mp_exp	long
=	O
0	int
;	O
r	pointer
->	O
_mp_prec	int
=	O
prec	int
;	O
r	pointer
->	O
_mp_d	pointer
=	O
(	O
mp_ptr	pointer
)	O
(	O
*	O
__gmp_allocate_func	pointer
)	O
(	O
(	O
prec	int
+	O
1	int
)	O
*	O
BYTES_PER_MP_LIMB	int
)	O
;	O
return	O
mpf_set_str	function
(	O
r	pointer
,	O
s	int
,	O
base	int
)	O
;	O
}	O
void	O
mpf_mul	O
(	O
mpf_ptr	pointer
r	pointer
,	O
mpf_srcptr	pointer
u	array
,	O
mpf_srcptr	pointer
v	pointer
)	O
{	O
mp_srcptr	pointer
up	pointer
,	O
vp	pointer
;	O
mp_size_t	long
usize	pointer
,	O
vsize	long
;	O
mp_size_t	long
sign_product	long
;	O
mp_size_t	long
prec	int
=	O
r	pointer
->	O
_mp_prec	int
;	O
TMP_DECL	O
;	O
TMP_MARK	O
;	O
usize	pointer
=	O
u	array
->	O
_mp_size	int
;	O
vsize	long
=	O
v	pointer
->	O
_mp_size	int
;	O
sign_product	long
=	O
usize	pointer
^	O
vsize	long
;	O
usize	pointer
=	O
ABS	O
(	O
usize	pointer
)	O
;	O
vsize	long
=	O
ABS	O
(	O
vsize	long
)	O
;	O
up	pointer
=	O
u	array
->	O
_mp_d	pointer
;	O
vp	pointer
=	O
v	pointer
->	O
_mp_d	pointer
;	O
if	O
(	O
usize	pointer
>	O
prec	int
)	O
{	O
up	pointer
+=	O
usize	pointer
-	O
prec	int
;	O
usize	pointer
=	O
prec	int
;	O
}	O
if	O
(	O
vsize	long
>	O
prec	int
)	O
{	O
vp	pointer
+=	O
vsize	long
-	O
prec	int
;	O
vsize	long
=	O
prec	int
;	O
}	O
if	O
(	O
usize	pointer
==	O
0	int
||	O
vsize	long
==	O
0	int
)	O
{	O
r	pointer
->	O
_mp_size	int
=	O
0	int
;	O
r	pointer
->	O
_mp_exp	long
=	O
0	int
;	O
}	O
else	O
{	O
mp_size_t	long
rsize	long
;	O
mp_limb_t	long
cy_limb	long
;	O
mp_ptr	pointer
rp	pointer
,	O
tp	pointer
;	O
mp_size_t	long
adj	long
;	O
rsize	long
=	O
usize	pointer
+	O
vsize	long
;	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
rsize	long
)	O
;	O
cy_limb	long
=	O
(	O
usize	pointer
>=	O
vsize	long
?	O
mpn_mul	O
(	O
tp	pointer
,	O
up	pointer
,	O
usize	pointer
,	O
vp	pointer
,	O
vsize	long
)	O
:	O
mpn_mul	O
(	O
tp	pointer
,	O
vp	pointer
,	O
vsize	long
,	O
up	pointer
,	O
usize	pointer
)	O
)	O
;	O
adj	long
=	O
cy_limb	long
==	O
0	int
;	O
rsize	long
-=	O
adj	long
;	O
prec	int
++	O
;	O
if	O
(	O
rsize	long
>	O
prec	int
)	O
{	O
tp	pointer
+=	O
rsize	long
-	O
prec	int
;	O
rsize	long
=	O
prec	int
;	O
}	O
rp	pointer
=	O
r	pointer
->	O
_mp_d	pointer
;	O
MPN_COPY	O
(	O
rp	pointer
,	O
tp	pointer
,	O
rsize	long
)	O
;	O
r	pointer
->	O
_mp_exp	long
=	O
u	array
->	O
_mp_exp	long
+	O
v	pointer
->	O
_mp_exp	long
-	O
adj	long
;	O
r	pointer
->	O
_mp_size	int
=	O
sign_product	long
>=	O
0	int
?	O
rsize	long
:	O
-	O
rsize	long
;	O
}	O
TMP_FREE	O
;	O
}	O
void	O
mpf_mul_2exp	O
(	O
mpf_ptr	pointer
r	pointer
,	O
mpf_srcptr	pointer
u	array
,	O
mp_bitcnt_t	long
exp	int
)	O
{	O
mp_srcptr	pointer
up	pointer
;	O
mp_ptr	pointer
rp	pointer
=	O
r	pointer
->	O
_mp_d	pointer
;	O
mp_size_t	long
usize	pointer
;	O
mp_size_t	long
abs_usize	long
;	O
mp_size_t	long
prec	int
=	O
r	pointer
->	O
_mp_prec	int
;	O
mp_exp_t	long
uexp	long
=	O
u	array
->	O
_mp_exp	long
;	O
usize	pointer
=	O
u	array
->	O
_mp_size	int
;	O
if	O
(	O
UNLIKELY	O
(	O
usize	pointer
==	O
0	int
)	O
)	O
{	O
r	pointer
->	O
_mp_size	int
=	O
0	int
;	O
r	pointer
->	O
_mp_exp	long
=	O
0	int
;	O
return	O
;	O
}	O
abs_usize	int
=	O
ABS	O
(	O
usize	pointer
)	O
;	O
up	pointer
=	O
u	array
->	O
_mp_d	pointer
;	O
if	O
(	O
exp	int
%	O
GMP_NUMB_BITS	O
==	O
0	int
)	O
{	O
prec	int
++	O
;	O
if	O
(	O
abs_usize	int
>	O
prec	int
)	O
{	O
up	pointer
+=	O
abs_usize	int
-	O
prec	int
;	O
abs_usize	int
=	O
prec	int
;	O
}	O
if	O
(	O
rp	pointer
!=	O
up	pointer
)	O
MPN_COPY_INCR	O
(	O
rp	pointer
,	O
up	pointer
,	O
abs_usize	long
)	O
;	O
r	pointer
->	O
_mp_exp	long
=	O
uexp	long
+	O
exp	int
/	O
GMP_NUMB_BITS	O
;	O
}	O
else	O
{	O
mp_limb_t	long
cy_limb	long
;	O
mp_size_t	long
adj	long
;	O
if	O
(	O
abs_usize	int
>	O
prec	int
)	O
{	O
up	pointer
+=	O
abs_usize	int
-	O
prec	int
;	O
abs_usize	int
=	O
prec	int
;	O
cy_limb	long
=	O
mpn_rshift	O
(	O
rp	pointer
+	O
1	int
,	O
up	pointer
,	O
abs_usize	pointer
,	O
GMP_NUMB_BITS	O
-	O
exp	int
%	O
GMP_NUMB_BITS	O
)	O
;	O
rp	pointer
[	O
0	int
]	O
=	O
cy_limb	long
;	O
adj	long
=	O
rp	pointer
[	O
abs_usize	int
]	O
!=	O
0	int
;	O
}	O
else	O
{	O
cy_limb	long
=	O
mpn_lshift	O
(	O
rp	pointer
,	O
up	pointer
,	O
abs_usize	array
,	O
exp	int
%	O
GMP_NUMB_BITS	O
)	O
;	O
rp	pointer
[	O
abs_usize	int
]	O
=	O
cy_limb	long
;	O
adj	long
=	O
cy_limb	long
!=	O
0	int
;	O
}	O
abs_usize	long
+=	O
adj	long
;	O
r	pointer
->	O
_mp_exp	long
=	O
uexp	long
+	O
exp	int
/	O
GMP_NUMB_BITS	O
+	O
adj	long
;	O
}	O
r	pointer
->	O
_mp_size	int
=	O
usize	pointer
>=	O
0	int
?	O
abs_usize	int
:	O
-	O
abs_usize	int
;	O
}	O
size_t	long
mpf_out_str	function
(	O
FILE	struct
*	O
stream	pointer
,	O
int	O
base	int
,	O
size_t	long
n_digits	long
,	O
mpf_srcptr	pointer
op	pointer
)	O
{	O
char	O
*	O
str	pointer
;	O
mp_exp_t	long
exp	int
;	O
size_t	long
written	long
;	O
TMP_DECL	O
;	O
TMP_MARK	O
;	O
if	O
(	O
base	int
==	O
0	int
)	O
base	int
=	O
10	int
;	O
if	O
(	O
n_digits	int
==	O
0	int
)	O
MPF_SIGNIFICANT_DIGITS	function
(	O
n_digits	pointer
,	O
base	int
,	O
op	pointer
->	O
_mp_prec	int
)	O
;	O
if	O
(	O
stream	pointer
==	O
0	int
)	O
stream	pointer
=	O
stdout	pointer
;	O
str	pointer
=	O
(	O
char	O
*	O
)	O
TMP_ALLOC	O
(	O
n_digits	pointer
+	O
2	int
)	O
;	O
mpf_get_str	O
(	O
str	pointer
,	O
&	O
exp	int
,	O
base	int
,	O
n_digits	int
,	O
op	int
)	O
;	O
n_digits	int
=	O
strlen	function
(	O
str	pointer
)	O
;	O
written	int
=	O
0	int
;	O
if	O
(	O
str	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
str	pointer
++	O
;	O
fputc	function
(	O
'-'	O
,	O
stream	pointer
)	O
;	O
written	long
=	O
1	int
;	O
n_digits	int
--	O
;	O
}	O
{	O
const	O
char	O
*	O
point	pointer
=	O
GMP_DECIMAL_POINT	pointer
;	O
size_t	long
pointlen	long
=	O
strlen	function
(	O
point	pointer
)	O
;	O
putc	function
(	O
'0'	O
,	O
stream	pointer
)	O
;	O
fwrite	function
(	O
point	O
,	O
1	int
,	O
pointlen	pointer
,	O
stream	pointer
)	O
;	O
written	long
+=	O
pointlen	long
+	O
1	int
;	O
}	O
{	O
size_t	long
fwret	long
;	O
fwret	long
=	O
fwrite	function
(	O
str	pointer
,	O
1	int
,	O
n_digits	int
,	O
stream	pointer
)	O
;	O
written	long
+=	O
fwret	long
;	O
}	O
{	O
int	O
fpret	int
;	O
fpret	int
=	O
fprintf	function
(	O
stream	pointer
,	O
(	O
base	int
<=	O
10	int
?	O
"e%ld"	int
:	O
"@%ld"	int
)	O
,	O
exp	int
)	O
;	O
written	long
+=	O
fpret	int
;	O
}	O
TMP_FREE	O
;	O
return	O
ferror	function
(	O
stream	pointer
)	O
?	O
0	int
:	O
written	long
;	O
}	O
void	O
mpf_reldiff	function
(	O
mpf_t	array
rdiff	array
,	O
mpf_srcptr	pointer
x	pointer
,	O
mpf_srcptr	pointer
y	array
)	O
{	O
if	O
(	O
UNLIKELY	O
(	O
SIZ	O
(	O
x	int
)	O
==	O
0	int
)	O
)	O
{	O
mpf_set_ui	O
(	O
rdiff	pointer
,	O
(	O
unsigned	O
long	O
int	O
)	O
(	O
mpf_sgn	function
(	O
y	long
)	O
!=	O
0	int
)	O
)	O
;	O
}	O
else	O
{	O
mp_size_t	long
dprec	long
;	O
mpf_t	array
d	array
;	O
TMP_DECL	O
;	O
TMP_MARK	O
;	O
dprec	int
=	O
PREC	O
(	O
rdiff	pointer
)	O
+	O
ABSIZ	O
(	O
x	pointer
)	O
;	O
ASSERT	O
(	O
PREC	O
(	O
rdiff	pointer
)	O
+	O
1	int
==	O
dprec	int
-	O
ABSIZ	O
(	O
x	pointer
)	O
+	O
1	int
)	O
;	O
PREC	O
(	O
d	pointer
)	O
=	O
dprec	pointer
;	O
PTR	O
(	O
d	pointer
)	O
=	O
TMP_ALLOC_LIMBS	O
(	O
dprec	int
+	O
1	int
)	O
;	O
mpf_sub	O
(	O
d	pointer
,	O
x	array
,	O
y	array
)	O
;	O
SIZ	O
(	O
d	pointer
)	O
=	O
ABSIZ	O
(	O
d	pointer
)	O
;	O
mpf_div	function
(	O
rdiff	pointer
,	O
d	pointer
,	O
x	pointer
)	O
;	O
TMP_FREE	O
;	O
}	O
}	O
void	O
mpf_set	O
(	O
mpf_ptr	pointer
r	pointer
,	O
mpf_srcptr	pointer
u	array
)	O
{	O
mp_ptr	pointer
rp	pointer
,	O
up	pointer
;	O
mp_size_t	long
size	long
,	O
asize	long
;	O
mp_size_t	long
prec	int
;	O
prec	int
=	O
r	pointer
->	O
_mp_prec	int
+	O
1	int
;	O
size	long
=	O
u	array
->	O
_mp_size	int
;	O
asize	long
=	O
ABS	O
(	O
size	long
)	O
;	O
rp	pointer
=	O
r	pointer
->	O
_mp_d	pointer
;	O
up	pointer
=	O
u	array
->	O
_mp_d	pointer
;	O
if	O
(	O
asize	long
>	O
prec	int
)	O
{	O
up	pointer
+=	O
asize	long
-	O
prec	int
;	O
asize	long
=	O
prec	int
;	O
}	O
r	pointer
->	O
_mp_exp	long
=	O
u	array
->	O
_mp_exp	long
;	O
r	pointer
->	O
_mp_size	int
=	O
size	long
>=	O
0	int
?	O
asize	long
:	O
-	O
asize	long
;	O
MPN_COPY_INCR	O
(	O
rp	pointer
,	O
up	pointer
,	O
asize	long
)	O
;	O
}	O
void	O
mpf_set_prec_raw	O
(	O
mpf_ptr	pointer
x	pointer
,	O
mp_bitcnt_t	long
prec_in_bits	long
)	O
__GMP_NOTHROW	O
{	O
x	pointer
->	O
_mp_prec	int
=	O
__GMPF_BITS_TO_PREC	O
(	O
prec_in_bits	long
)	O
;	O
}	O
size_t	long
mpf_size	function
(	O
mpf_srcptr	pointer
f	pointer
)	O
__GMP_NOTHROW	O
{	O
return	O
__GMP_ABS	function
(	O
f	pointer
->	O
_mp_size	O
)	O
;	O
}	O
void	O
mpf_sqrt_ui	O
(	O
mpf_ptr	pointer
r	pointer
,	O
unsigned	O
long	O
int	O
u	long
)	O
{	O
mp_size_t	long
rsize	long
,	O
zeros	int
;	O
mp_ptr	pointer
tp	pointer
;	O
mp_size_t	long
prec	int
;	O
TMP_DECL	O
;	O
if	O
(	O
UNLIKELY	O
(	O
u	array
==	O
0	int
)	O
)	O
{	O
r	pointer
->	O
_mp_size	int
=	O
0	int
;	O
r	pointer
->	O
_mp_exp	long
=	O
0	int
;	O
return	O
;	O
}	O
TMP_MARK	O
;	O
prec	int
=	O
r	pointer
->	O
_mp_prec	int
;	O
zeros	int
=	O
2	int
*	O
prec	int
-	O
2	int
;	O
rsize	long
=	O
zeros	int
+	O
1	int
+	O
U2	long
;	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
rsize	long
)	O
;	O
MPN_ZERO	O
(	O
tp	pointer
,	O
zeros	long
)	O
;	O
tp	pointer
[	O
zeros	int
]	O
=	O
u	array
&	O
GMP_NUMB_MASK	O
;	O
mpn_sqrtrem	O
(	O
r	pointer
->	O
_mp_d	pointer
,	O
NULL	O
,	O
tp	pointer
,	O
rsize	long
)	O
;	O
r	pointer
->	O
_mp_size	int
=	O
prec	int
;	O
r	pointer
->	O
_mp_exp	long
=	O
1	int
;	O
TMP_FREE	O
;	O
}	O
void	O
mpn_bsqrt	O
(	O
mp_ptr	pointer
rp	pointer
,	O
mp_srcptr	pointer
ap	pointer
,	O
mp_bitcnt_t	pointer
nb	pointer
,	O
mp_ptr	pointer
tp	pointer
)	O
{	O
mp_ptr	pointer
sp	pointer
;	O
mp_size_t	long
n	long
;	O
ASSERT	O
(	O
nb	int
>	O
0	int
)	O
;	O
n	long
=	O
nb	int
/	O
GMP_NUMB_BITS	O
;	O
sp	pointer
=	O
tp	pointer
+	O
n	long
;	O
mpn_bsqrtinv	function
(	O
sp	pointer
,	O
ap	pointer
,	O
nb	pointer
,	O
tp	pointer
)	O
;	O
mpn_mullo_n	O
(	O
rp	pointer
,	O
sp	pointer
,	O
ap	pointer
,	O
n	long
)	O
;	O
}	O
int	O
mpn_bsqrtinv	O
(	O
mp_ptr	pointer
rp	pointer
,	O
mp_srcptr	pointer
yp	pointer
,	O
mp_bitcnt_t	long
bnb	pointer
,	O
mp_ptr	pointer
tp	pointer
)	O
{	O
mp_ptr	pointer
tp2	pointer
,	O
tp3	pointer
;	O
mp_limb_t	long
k	long
;	O
mp_size_t	long
bn	long
,	O
order	array
[	O
GMP_LIMB_BITS	int
+	O
1	int
]	O
;	O
int	O
i	long
,	O
d	long
;	O
ASSERT	O
(	O
bnb	long
>	O
0	int
)	O
;	O
bn	long
=	O
1	int
+	O
bnb	int
/	O
GMP_LIMB_BITS	int
;	O
tp2	pointer
=	O
tp	pointer
+	O
bn	long
;	O
tp3	pointer
=	O
tp	pointer
+	O
2	int
*	O
bn	long
;	O
k	long
=	O
3	int
;	O
rp	pointer
[	O
0	int
]	O
=	O
1	int
;	O
if	O
(	O
bnb	int
==	O
1	int
)	O
{	O
if	O
(	O
(	O
yp	pointer
[	O
0	int
]	O
&	O
3	int
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
yp	pointer
[	O
0	int
]	O
&	O
7	int
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
d	long
=	O
0	int
;	O
for	O
(	O
;	O
bnb	long
!=	O
2	int
;	O
bnb	long
=	O
(	O
bnb	long
+	O
2	int
)	O
>>	O
1	int
)	O
order	array
[	O
d	long
++	O
]	O
=	O
bnb	int
;	O
for	O
(	O
i	long
=	O
d	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
{	O
bnb	long
=	O
order	pointer
[	O
i	long
]	O
;	O
bn	long
=	O
1	int
+	O
bnb	int
/	O
GMP_LIMB_BITS	int
;	O
mpn_mul_1	O
(	O
tp	pointer
,	O
rp	pointer
,	O
bn	long
,	O
k	long
)	O
;	O
mpn_powlo	O
(	O
tp2	pointer
,	O
rp	pointer
,	O
&	O
k	long
,	O
1	int
,	O
bn	long
,	O
tp3	pointer
)	O
;	O
mpn_mullo_n	O
(	O
rp	pointer
,	O
yp	pointer
,	O
tp2	pointer
,	O
bn	long
)	O
;	O
mpn_rsh1sub_n	O
(	O
rp	pointer
,	O
tp	pointer
,	O
rp	pointer
,	O
bn	long
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
mp_size_t	long
mpn_dcpi1_bdiv_qr_n_itch	O
(	O
mp_size_t	long
n	long
)	O
{	O
return	O
n	long
;	O
}	O
mp_limb_t	long
mpn_dcpi1_bdiv_qr_n	O
(	O
mp_ptr	pointer
qp	pointer
,	O
mp_ptr	pointer
np	pointer
,	O
mp_srcptr	pointer
dp	pointer
,	O
mp_size_t	long
n	long
,	O
mp_limb_t	long
dinv	long
,	O
mp_ptr	pointer
tp	pointer
)	O
{	O
mp_size_t	long
lo	long
,	O
hi	long
;	O
mp_limb_t	long
cy	long
;	O
mp_limb_t	long
rh	long
;	O
lo	long
=	O
n	long
>>	O
1	int
;	O
hi	long
=	O
n	long
-	O
lo	long
;	O
if	O
(	O
BELOW_THRESHOLD	O
(	O
lo	long
,	O
DC_BDIV_QR_THRESHOLD	int
)	O
)	O
cy	long
=	O
mpn_sbpi1_bdiv_qr	O
(	O
qp	pointer
,	O
np	pointer
,	O
2	int
*	O
lo	pointer
,	O
dp	pointer
,	O
lo	long
,	O
dinv	long
)	O
;	O
else	O
cy	long
=	O
mpn_dcpi1_bdiv_qr_n	O
(	O
qp	pointer
,	O
np	pointer
,	O
dp	pointer
,	O
lo	long
,	O
dinv	long
,	O
tp	pointer
)	O
;	O
mpn_mul	O
(	O
tp	pointer
,	O
dp	pointer
+	O
lo	long
,	O
hi	long
,	O
qp	pointer
,	O
lo	long
)	O
;	O
mpn_incr_u	O
(	O
tp	pointer
+	O
lo	long
,	O
cy	long
)	O
;	O
rh	long
=	O
mpn_sub	O
(	O
np	pointer
+	O
lo	long
,	O
np	pointer
+	O
lo	long
,	O
n	long
+	O
hi	long
,	O
tp	pointer
,	O
n	long
)	O
;	O
if	O
(	O
BELOW_THRESHOLD	O
(	O
hi	long
,	O
DC_BDIV_QR_THRESHOLD	int
)	O
)	O
cy	long
=	O
mpn_sbpi1_bdiv_qr	O
(	O
qp	pointer
+	O
lo	long
,	O
np	pointer
+	O
lo	long
,	O
2	int
*	O
hi	pointer
,	O
dp	pointer
,	O
hi	long
,	O
dinv	long
)	O
;	O
else	O
cy	long
=	O
mpn_dcpi1_bdiv_qr_n	O
(	O
qp	pointer
+	O
lo	long
,	O
np	pointer
+	O
lo	long
,	O
dp	pointer
,	O
hi	long
,	O
dinv	long
,	O
tp	pointer
)	O
;	O
mpn_mul	O
(	O
tp	pointer
,	O
qp	pointer
+	O
lo	long
,	O
hi	long
,	O
dp	pointer
+	O
hi	long
,	O
lo	long
)	O
;	O
mpn_incr_u	O
(	O
tp	pointer
+	O
hi	long
,	O
cy	long
)	O
;	O
rh	long
+=	O
mpn_sub_n	O
(	O
np	pointer
+	O
n	long
,	O
np	pointer
+	O
n	long
,	O
tp	pointer
,	O
n	long
)	O
;	O
return	O
rh	long
;	O
}	O
mp_limb_t	long
mpn_dcpi1_bdiv_qr	O
(	O
mp_ptr	pointer
qp	pointer
,	O
mp_ptr	pointer
np	pointer
,	O
mp_size_t	long
nn	long
,	O
mp_srcptr	pointer
dp	pointer
,	O
mp_size_t	long
dn	long
,	O
mp_limb_t	long
dinv	long
)	O
{	O
mp_size_t	long
qn	long
;	O
mp_limb_t	long
rr	long
,	O
cy	long
;	O
mp_ptr	pointer
tp	pointer
;	O
TMP_DECL	O
;	O
TMP_MARK	O
;	O
ASSERT	O
(	O
dn	long
>=	O
2	int
)	O
;	O
ASSERT	O
(	O
nn	long
-	O
dn	long
>=	O
1	int
)	O
;	O
ASSERT	O
(	O
dp	pointer
[	O
0	int
]	O
&	O
1	int
)	O
;	O
tp	pointer
=	O
TMP_SALLOC_LIMBS	O
(	O
dn	long
)	O
;	O
qn	long
=	O
nn	long
-	O
dn	long
;	O
if	O
(	O
qn	long
>	O
dn	long
)	O
{	O
do	O
qn	long
-=	O
dn	long
;	O
while	O
(	O
qn	long
>	O
dn	long
)	O
;	O
if	O
(	O
BELOW_THRESHOLD	O
(	O
qn	long
,	O
DC_BDIV_QR_THRESHOLD	int
)	O
)	O
cy	long
=	O
mpn_sbpi1_bdiv_qr	O
(	O
qp	pointer
,	O
np	pointer
,	O
2	int
*	O
qn	long
,	O
dp	pointer
,	O
qn	long
,	O
dinv	long
)	O
;	O
else	O
cy	long
=	O
mpn_dcpi1_bdiv_qr_n	O
(	O
qp	pointer
,	O
np	pointer
,	O
dp	pointer
,	O
qn	long
,	O
dinv	long
,	O
tp	pointer
)	O
;	O
rr	long
=	O
0	int
;	O
if	O
(	O
qn	long
!=	O
dn	long
)	O
{	O
if	O
(	O
qn	long
>	O
dn	long
-	O
qn	long
)	O
mpn_mul	O
(	O
tp	pointer
,	O
qp	pointer
,	O
qn	long
,	O
dp	pointer
+	O
qn	long
,	O
dn	long
-	O
qn	long
)	O
;	O
else	O
mpn_mul	O
(	O
tp	pointer
,	O
dp	pointer
+	O
qn	long
,	O
dn	long
-	O
qn	long
,	O
qp	pointer
,	O
qn	long
)	O
;	O
mpn_incr_u	O
(	O
tp	pointer
+	O
qn	long
,	O
cy	long
)	O
;	O
rr	long
=	O
mpn_sub	O
(	O
np	pointer
+	O
qn	long
,	O
np	pointer
+	O
qn	long
,	O
nn	long
-	O
qn	long
,	O
tp	pointer
,	O
dn	long
)	O
;	O
cy	long
=	O
0	int
;	O
}	O
np	pointer
+=	O
qn	long
;	O
qp	pointer
+=	O
qn	long
;	O
qn	long
=	O
nn	long
-	O
dn	long
-	O
qn	long
;	O
do	O
{	O
rr	int
+=	O
mpn_sub_1	O
(	O
np	pointer
+	O
dn	long
,	O
np	pointer
+	O
dn	long
,	O
qn	long
,	O
cy	long
)	O
;	O
cy	long
=	O
mpn_dcpi1_bdiv_qr_n	O
(	O
qp	pointer
,	O
np	pointer
,	O
dp	pointer
,	O
dn	long
,	O
dinv	long
,	O
tp	pointer
)	O
;	O
qp	pointer
+=	O
dn	long
;	O
np	pointer
+=	O
dn	long
;	O
qn	long
-=	O
dn	long
;	O
}	O
while	O
(	O
qn	long
>	O
0	int
)	O
;	O
TMP_FREE	O
;	O
return	O
rr	long
+	O
cy	long
;	O
}	O
if	O
(	O
BELOW_THRESHOLD	O
(	O
qn	long
,	O
DC_BDIV_QR_THRESHOLD	int
)	O
)	O
cy	long
=	O
mpn_sbpi1_bdiv_qr	O
(	O
qp	pointer
,	O
np	pointer
,	O
2	int
*	O
qn	long
,	O
dp	pointer
,	O
qn	long
,	O
dinv	long
)	O
;	O
else	O
cy	long
=	O
mpn_dcpi1_bdiv_qr_n	O
(	O
qp	pointer
,	O
np	pointer
,	O
dp	pointer
,	O
qn	long
,	O
dinv	long
,	O
tp	pointer
)	O
;	O
rr	long
=	O
0	int
;	O
if	O
(	O
qn	long
!=	O
dn	long
)	O
{	O
if	O
(	O
qn	long
>	O
dn	long
-	O
qn	long
)	O
mpn_mul	O
(	O
tp	pointer
,	O
qp	pointer
,	O
qn	long
,	O
dp	pointer
+	O
qn	long
,	O
dn	long
-	O
qn	long
)	O
;	O
else	O
mpn_mul	O
(	O
tp	pointer
,	O
dp	pointer
+	O
qn	long
,	O
dn	long
-	O
qn	long
,	O
qp	pointer
,	O
qn	long
)	O
;	O
mpn_incr_u	O
(	O
tp	pointer
+	O
qn	long
,	O
cy	long
)	O
;	O
rr	long
=	O
mpn_sub	O
(	O
np	pointer
+	O
qn	long
,	O
np	pointer
+	O
qn	long
,	O
nn	long
-	O
qn	long
,	O
tp	pointer
,	O
dn	long
)	O
;	O
cy	long
=	O
0	int
;	O
}	O
TMP_FREE	O
;	O
return	O
rr	int
+	O
cy	long
;	O
}	O
mp_limb_t	long
mpn_divrem	O
(	O
mp_ptr	pointer
qp	pointer
,	O
mp_size_t	long
qxn	long
,	O
mp_ptr	pointer
np	pointer
,	O
mp_size_t	long
nn	long
,	O
mp_srcptr	pointer
dp	pointer
,	O
mp_size_t	long
dn	long
)	O
{	O
ASSERT	O
(	O
qxn	int
>=	O
0	int
)	O
;	O
ASSERT	O
(	O
nn	long
>=	O
dn	long
)	O
;	O
ASSERT	O
(	O
dn	long
>=	O
1	int
)	O
;	O
ASSERT	O
(	O
dp	pointer
[	O
dn	long
-	O
1	int
]	O
&	O
GMP_NUMB_HIGHBIT	O
)	O
;	O
ASSERT	O
(	O
!	O
MPN_OVERLAP_P	O
(	O
np	pointer
,	O
nn	long
,	O
dp	pointer
,	O
dn	long
)	O
)	O
;	O
ASSERT	O
(	O
!	O
MPN_OVERLAP_P	O
(	O
qp	pointer
,	O
nn	long
-	O
dn	long
+	O
qxn	int
,	O
np	pointer
,	O
nn	long
)	O
||	O
qp	pointer
==	O
np	pointer
+	O
dn	long
+	O
qxn	int
)	O
;	O
ASSERT	O
(	O
!	O
MPN_OVERLAP_P	O
(	O
qp	pointer
,	O
nn	long
-	O
dn	long
+	O
qxn	int
,	O
dp	pointer
,	O
dn	long
)	O
)	O
;	O
ASSERT_MPN	O
(	O
np	pointer
,	O
nn	long
)	O
;	O
ASSERT_MPN	O
(	O
dp	pointer
,	O
dn	long
)	O
;	O
if	O
(	O
dn	long
==	O
1	int
)	O
{	O
mp_limb_t	long
ret	long
;	O
mp_ptr	pointer
q2p	pointer
;	O
mp_size_t	long
qn	long
;	O
TMP_DECL	O
;	O
TMP_MARK	O
;	O
q2p	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
nn	long
+	O
qxn	int
)	O
;	O
np	pointer
[	O
0	int
]	O
=	O
mpn_divrem_1	O
(	O
q2p	pointer
,	O
qxn	pointer
,	O
np	pointer
,	O
nn	long
,	O
dp	pointer
[	O
0	int
]	O
)	O
;	O
qn	long
=	O
nn	long
+	O
qxn	long
-	O
1	int
;	O
MPN_COPY	O
(	O
qp	pointer
,	O
q2p	int
,	O
qn	long
)	O
;	O
ret	int
=	O
q2p	pointer
[	O
qn	long
]	O
;	O
TMP_FREE	O
;	O
return	O
ret	int
;	O
}	O
else	O
if	O
(	O
dn	long
==	O
2	int
)	O
{	O
return	O
mpn_divrem_2	O
(	O
qp	pointer
,	O
qxn	int
,	O
np	pointer
,	O
nn	long
,	O
dp	pointer
)	O
;	O
}	O
else	O
{	O
mp_ptr	pointer
rp	pointer
,	O
q2p	pointer
;	O
mp_limb_t	long
qhl	long
;	O
mp_size_t	long
qn	long
;	O
TMP_DECL	O
;	O
TMP_MARK	O
;	O
if	O
(	O
UNLIKELY	O
(	O
qxn	long
!=	O
0	int
)	O
)	O
{	O
mp_ptr	pointer
n2p	pointer
;	O
n2p	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
nn	long
+	O
qxn	long
)	O
;	O
MPN_ZERO	O
(	O
n2p	pointer
,	O
qxn	pointer
)	O
;	O
MPN_COPY	O
(	O
n2p	pointer
+	O
qxn	pointer
,	O
np	pointer
,	O
nn	long
)	O
;	O
q2p	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
nn	long
-	O
dn	long
+	O
qxn	int
+	O
1	int
)	O
;	O
rp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
dn	long
)	O
;	O
mpn_tdiv_qr	O
(	O
q2p	pointer
,	O
rp	pointer
,	O
0L	int
,	O
n2p	pointer
,	O
nn	long
+	O
qxn	pointer
,	O
dp	pointer
,	O
dn	long
)	O
;	O
MPN_COPY	O
(	O
np	pointer
,	O
rp	pointer
,	O
dn	long
)	O
;	O
qn	long
=	O
nn	long
-	O
dn	long
+	O
qxn	long
;	O
MPN_COPY	O
(	O
qp	pointer
,	O
q2p	int
,	O
qn	long
)	O
;	O
qhl	long
=	O
q2p	pointer
[	O
qn	long
]	O
;	O
}	O
else	O
{	O
q2p	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
nn	long
-	O
dn	long
+	O
1	int
)	O
;	O
rp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
dn	long
)	O
;	O
mpn_tdiv_qr	O
(	O
q2p	pointer
,	O
rp	pointer
,	O
0L	int
,	O
np	pointer
,	O
nn	long
,	O
dp	pointer
,	O
dn	long
)	O
;	O
MPN_COPY	O
(	O
np	pointer
,	O
rp	pointer
,	O
dn	long
)	O
;	O
qn	long
=	O
nn	long
-	O
dn	long
;	O
MPN_COPY	O
(	O
qp	pointer
,	O
q2p	int
,	O
qn	long
)	O
;	O
qhl	long
=	O
q2p	pointer
[	O
qn	long
]	O
;	O
}	O
TMP_FREE	O
;	O
return	O
qhl	int
;	O
}	O
}	O
static	O
void	O
invert_4by2	O
(	O
mp_ptr	pointer
di	long
,	O
mp_limb_t	long
d1	long
,	O
mp_limb_t	long
d0	long
)	O
{	O
mp_limb_t	long
v1	int
,	O
v0	O
,	O
p1	long
,	O
t1	long
,	O
t0	long
,	O
p0	pointer
,	O
mask	long
;	O
invert_limb	O
(	O
v1	pointer
,	O
d1	double
)	O
;	O
p1	pointer
=	O
d1	double
*	O
v1	pointer
;	O
p1	pointer
+=	O
d0	long
;	O
if	O
(	O
p1	long
<	O
d0	long
)	O
{	O
v1	int
--	O
;	O
mask	long
=	O
-	O
(	O
mp_limb_t	long
)	O
(	O
p1	long
>=	O
d1	long
)	O
;	O
p1	long
-=	O
d1	long
;	O
v1	int
+=	O
mask	long
;	O
p1	long
-=	O
mask	long
&	O
d1	long
;	O
}	O
umul_ppmm	O
(	O
t1	long
,	O
p0	long
,	O
d0	long
,	O
v1	int
)	O
;	O
p1	long
+=	O
t1	long
;	O
if	O
(	O
p1	long
<	O
t1	long
)	O
{	O
if	O
(	O
UNLIKELY	O
(	O
p1	long
>=	O
d1	long
)	O
)	O
{	O
if	O
(	O
p1	long
>	O
d1	long
||	O
p0	long
>=	O
d0	long
)	O
{	O
sub_ddmmss	O
(	O
p1	pointer
,	O
p0	pointer
,	O
p1	pointer
,	O
p0	pointer
,	O
d1	long
,	O
d0	long
)	O
;	O
v1	O
--	O
;	O
}	O
}	O
sub_ddmmss	O
(	O
p1	pointer
,	O
p0	pointer
,	O
p1	pointer
,	O
p0	pointer
,	O
d1	long
,	O
d0	pointer
)	O
;	O
v1	O
--	O
;	O
}	O
udiv_qr_3by2	O
(	O
v0	O
,	O
t1	long
,	O
t0	long
,	O
~	O
p1	pointer
,	O
~	O
p0	pointer
,	O
MP_LIMB_T_MAX	O
,	O
d1	pointer
,	O
d0	pointer
,	O
v1	pointer
)	O
;	O
di	pointer
[	O
0	int
]	O
=	O
v0	O
;	O
di	array
[	O
1	int
]	O
=	O
v1	O
;	O
}	O
static	O
mp_limb_t	long
mpn_div_qr_2n_pi2	O
(	O
mp_ptr	pointer
qp	pointer
,	O
mp_ptr	pointer
rp	pointer
,	O
mp_srcptr	pointer
np	pointer
,	O
mp_size_t	long
nn	long
,	O
mp_limb_t	long
d1	long
,	O
mp_limb_t	long
d0	long
,	O
mp_limb_t	long
di1	long
,	O
mp_limb_t	long
di0	long
)	O
{	O
mp_limb_t	long
qh	long
;	O
mp_size_t	long
i	long
;	O
mp_limb_t	long
r1	O
,	O
r0	long
;	O
ASSERT	O
(	O
nn	long
>=	O
2	int
)	O
;	O
ASSERT	O
(	O
d1	long
&	O
GMP_NUMB_HIGHBIT	O
)	O
;	O
r1	pointer
=	O
np	pointer
[	O
nn	long
-	O
1	int
]	O
;	O
r0	long
=	O
np	pointer
[	O
nn	long
-	O
2	int
]	O
;	O
qh	long
=	O
0	int
;	O
if	O
(	O
r1	double
>=	O
d1	long
&&	O
(	O
r1	double
>	O
d1	long
||	O
r0	long
>=	O
d0	long
)	O
)	O
{	O
sub_ddmmss	function
(	O
r1	pointer
,	O
r0	double
,	O
r1	double
,	O
r0	double
,	O
d1	long
,	O
d0	long
)	O
;	O
qh	long
=	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
nn	long
-	O
2	int
;	O
i	int
>=	O
2	int
;	O
i	long
-=	O
2	int
)	O
{	O
mp_limb_t	long
n1	long
,	O
n0	long
,	O
q1	long
,	O
q0	int
;	O
n1	long
=	O
np	pointer
[	O
i	long
-	O
1	int
]	O
;	O
n0	long
=	O
np	pointer
[	O
i	long
-	O
2	int
]	O
;	O
udiv_qr_4by2	function
(	O
q1	pointer
,	O
q0	pointer
,	O
r1	long
,	O
r0	long
,	O
r1	long
,	O
r0	long
,	O
n1	long
,	O
n0	long
,	O
d1	long
,	O
d0	long
,	O
di1	pointer
,	O
di0	pointer
)	O
;	O
qp	pointer
[	O
i	int
-	O
1	int
]	O
=	O
q1	int
;	O
qp	pointer
[	O
i	long
-	O
2	int
]	O
=	O
q0	int
;	O
}	O
if	O
(	O
i	long
>	O
0	int
)	O
{	O
mp_limb_t	long
q	long
;	O
udiv_qr_3by2	O
(	O
q	int
,	O
r1	int
,	O
r0	long
,	O
r1	int
,	O
r0	long
,	O
np	pointer
[	O
0	int
]	O
,	O
d1	long
,	O
d0	long
,	O
di1	int
)	O
;	O
qp	pointer
[	O
0	int
]	O
=	O
q	int
;	O
}	O
rp	pointer
[	O
1	int
]	O
=	O
r1	double
;	O
rp	pointer
[	O
0	int
]	O
=	O
r0	long
;	O
return	O
qh	long
;	O
}	O
mp_limb_t	long
mpn_div_qr_2	O
(	O
mp_ptr	pointer
qp	pointer
,	O
mp_ptr	pointer
rp	pointer
,	O
mp_srcptr	pointer
np	pointer
,	O
mp_size_t	long
nn	long
,	O
mp_srcptr	pointer
dp	pointer
)	O
{	O
mp_limb_t	long
d1	long
;	O
mp_limb_t	long
d0	long
;	O
gmp_pi1_t	struct
dinv	struct
;	O
ASSERT	O
(	O
nn	long
>=	O
2	int
)	O
;	O
ASSERT	O
(	O
!	O
MPN_OVERLAP_P	O
(	O
qp	pointer
,	O
nn	long
-	O
2	int
,	O
np	pointer
,	O
nn	long
)	O
||	O
qp	pointer
>=	O
np	pointer
+	O
2	int
)	O
;	O
ASSERT_MPN	O
(	O
np	pointer
,	O
nn	long
)	O
;	O
ASSERT_MPN	O
(	O
dp	pointer
,	O
2	int
)	O
;	O
d1	long
=	O
dp	pointer
[	O
1	int
]	O
;	O
d0	long
=	O
dp	pointer
[	O
0	int
]	O
;	O
ASSERT	O
(	O
d1	long
>	O
0	int
)	O
;	O
if	O
(	O
UNLIKELY	O
(	O
d1	long
&	O
GMP_NUMB_HIGHBIT	O
)	O
)	O
{	O
if	O
(	O
BELOW_THRESHOLD	O
(	O
nn	long
,	O
DIV_QR_2_PI2_THRESHOLD	int
)	O
)	O
{	O
gmp_pi1_t	struct
dinv	struct
;	O
invert_pi1	O
(	O
dinv	struct
,	O
d1	long
,	O
d0	long
)	O
;	O
return	O
mpn_div_qr_2n_pi1	O
(	O
qp	pointer
,	O
rp	pointer
,	O
np	pointer
,	O
nn	long
,	O
d1	long
,	O
d0	long
,	O
dinv	struct
.	O
inv32	long
)	O
;	O
}	O
else	O
{	O
mp_limb_t	long
di	array
[	O
2	int
]	O
;	O
invert_4by2	function
(	O
di	long
,	O
d1	long
,	O
d0	long
)	O
;	O
return	O
mpn_div_qr_2n_pi2	O
(	O
qp	pointer
,	O
rp	pointer
,	O
np	pointer
,	O
nn	long
,	O
d1	long
,	O
d0	long
,	O
di	array
[	O
1	int
]	O
,	O
di	array
[	O
0	int
]	O
)	O
;	O
}	O
}	O
else	O
{	O
int	O
shift	long
;	O
count_leading_zeros	O
(	O
shift	long
,	O
d1	long
)	O
;	O
d1	long
=	O
(	O
d1	long
<<	O
shift	long
)	O
|	O
(	O
d0	long
>>	O
(	O
GMP_LIMB_BITS	int
-	O
shift	int
)	O
)	O
;	O
d0	long
<<=	O
shift	long
;	O
invert_pi1	O
(	O
dinv	long
,	O
d1	long
,	O
d0	long
)	O
;	O
return	O
mpn_div_qr_2u_pi1	O
(	O
qp	pointer
,	O
rp	pointer
,	O
np	pointer
,	O
nn	long
,	O
d1	long
,	O
d0	long
,	O
shift	long
,	O
dinv	struct
.	O
inv32	long
)	O
;	O
}	O
}	O
mp_size_t	long
mpn_gcd_subdiv_step	O
(	O
mp_ptr	pointer
ap	pointer
,	O
mp_ptr	pointer
bp	pointer
,	O
mp_size_t	long
n	long
,	O
mp_size_t	long
s	array
,	O
gcd_subdiv_step_hook	struct
*	O
hook	pointer
,	O
void	O
*	O
ctx	pointer
,	O
mp_ptr	pointer
tp	pointer
)	O
{	O
static	O
const	O
mp_limb_t	long
one	long
=	O
CNST_LIMB	O
(	O
1	int
)	O
;	O
mp_size_t	long
an	long
,	O
bn	long
,	O
qn	long
;	O
int	O
swapped	int
;	O
ASSERT	O
(	O
n	long
>	O
0	int
)	O
;	O
ASSERT	O
(	O
ap	pointer
[	O
n	long
-	O
1	int
]	O
>	O
0	int
||	O
bp	pointer
[	O
n	long
-	O
1	int
]	O
>	O
0	int
)	O
;	O
an	long
=	O
bn	long
=	O
n	long
;	O
MPN_NORMALIZE	O
(	O
ap	pointer
,	O
an	long
)	O
;	O
MPN_NORMALIZE	O
(	O
bp	pointer
,	O
bn	long
)	O
;	O
swapped	int
=	O
0	int
;	O
if	O
(	O
an	long
==	O
bn	long
)	O
{	O
int	O
c	int
;	O
MPN_CMP	O
(	O
c	int
,	O
ap	pointer
,	O
bp	pointer
,	O
an	long
)	O
;	O
if	O
(	O
UNLIKELY	O
(	O
c	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
s	long
==	O
0	int
)	O
hook	pointer
(	O
ctx	pointer
,	O
ap	pointer
,	O
an	long
,	O
NULL	O
,	O
0	int
,	O
-	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
>	O
0	int
)	O
{	O
MP_PTR_SWAP	O
(	O
ap	pointer
,	O
bp	pointer
)	O
;	O
swapped	int
^=	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
an	long
>	O
bn	long
)	O
{	O
MPN_PTR_SWAP	O
(	O
ap	pointer
,	O
an	long
,	O
bp	pointer
,	O
bn	long
)	O
;	O
swapped	int
^=	O
1	int
;	O
}	O
}	O
if	O
(	O
an	long
<=	O
s	array
)	O
{	O
if	O
(	O
s	long
==	O
0	int
)	O
hook	pointer
(	O
ctx	pointer
,	O
bp	pointer
,	O
bn	long
,	O
NULL	O
,	O
0	int
,	O
swapped	int
^	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
ASSERT_NOCARRY	O
(	O
mpn_sub	O
(	O
bp	pointer
,	O
bp	pointer
,	O
bn	long
,	O
ap	pointer
,	O
an	long
)	O
)	O
;	O
MPN_NORMALIZE	O
(	O
bp	pointer
,	O
bn	long
)	O
;	O
ASSERT	O
(	O
bn	long
>	O
0	int
)	O
;	O
if	O
(	O
bn	long
<=	O
s	array
)	O
{	O
mp_limb_t	long
cy	long
=	O
mpn_add	O
(	O
bp	pointer
,	O
ap	pointer
,	O
an	long
,	O
bp	pointer
,	O
bn	long
)	O
;	O
if	O
(	O
cy	long
>	O
0	int
)	O
bp	pointer
[	O
an	long
]	O
=	O
cy	long
;	O
return	O
0	int
;	O
}	O
if	O
(	O
an	long
==	O
bn	long
)	O
{	O
int	O
c	int
;	O
MPN_CMP	O
(	O
c	int
,	O
ap	pointer
,	O
bp	pointer
,	O
an	long
)	O
;	O
if	O
(	O
UNLIKELY	O
(	O
c	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
s	long
>	O
0	int
)	O
hook	pointer
(	O
ctx	pointer
,	O
NULL	O
,	O
0	int
,	O
&	O
one	function
,	O
1	int
,	O
swapped	int
)	O
;	O
else	O
hook	pointer
(	O
ctx	pointer
,	O
bp	pointer
,	O
bn	long
,	O
NULL	O
,	O
0	int
,	O
swapped	int
)	O
;	O
return	O
0	int
;	O
}	O
hook	pointer
(	O
ctx	pointer
,	O
NULL	O
,	O
0	int
,	O
&	O
one	function
,	O
1	int
,	O
swapped	int
)	O
;	O
if	O
(	O
c	int
>	O
0	int
)	O
{	O
MP_PTR_SWAP	O
(	O
ap	pointer
,	O
bp	pointer
)	O
;	O
swapped	int
^=	O
1	int
;	O
}	O
}	O
else	O
{	O
hook	pointer
(	O
ctx	pointer
,	O
NULL	O
,	O
0	int
,	O
&	O
one	function
,	O
1	int
,	O
swapped	int
)	O
;	O
if	O
(	O
an	long
>	O
bn	long
)	O
{	O
MPN_PTR_SWAP	O
(	O
ap	pointer
,	O
an	long
,	O
bp	pointer
,	O
bn	long
)	O
;	O
swapped	int
^=	O
1	int
;	O
}	O
}	O
mpn_tdiv_qr	O
(	O
tp	pointer
,	O
bp	pointer
,	O
0	int
,	O
bp	pointer
,	O
bn	long
,	O
ap	pointer
,	O
an	long
)	O
;	O
qn	long
=	O
bn	long
-	O
an	long
+	O
1	int
;	O
bn	long
=	O
an	long
;	O
MPN_NORMALIZE	O
(	O
bp	pointer
,	O
bn	long
)	O
;	O
if	O
(	O
UNLIKELY	O
(	O
bn	long
<=	O
s	array
)	O
)	O
{	O
if	O
(	O
s	long
==	O
0	int
)	O
{	O
hook	pointer
(	O
ctx	pointer
,	O
ap	pointer
,	O
an	long
,	O
tp	pointer
,	O
qn	long
,	O
swapped	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
bn	long
>	O
0	int
)	O
{	O
mp_limb_t	long
cy	long
=	O
mpn_add	O
(	O
bp	pointer
,	O
ap	pointer
,	O
an	long
,	O
bp	pointer
,	O
bn	long
)	O
;	O
if	O
(	O
cy	long
)	O
bp	pointer
[	O
an	long
++	O
]	O
=	O
cy	long
;	O
}	O
else	O
MPN_COPY	O
(	O
bp	pointer
,	O
ap	pointer
,	O
an	long
)	O
;	O
MPN_DECR_U	O
(	O
tp	pointer
,	O
qn	long
,	O
1	int
)	O
;	O
}	O
hook	pointer
(	O
ctx	pointer
,	O
NULL	O
,	O
0	int
,	O
tp	pointer
,	O
qn	long
,	O
swapped	int
)	O
;	O
return	O
an	long
;	O
}	O
mp_size_t	long
mpn_matrix22_mul1_inverse_vector	O
(	O
const	O
struct	O
hgcd_matrix1	struct
*	O
M	pointer
,	O
mp_ptr	pointer
rp	pointer
,	O
mp_srcptr	pointer
ap	pointer
,	O
mp_ptr	pointer
bp	pointer
,	O
mp_size_t	long
n	long
)	O
{	O
mp_limb_t	long
h0	long
,	O
h1	int
;	O
h0	long
=	O
mpn_mul_1	O
(	O
rp	pointer
,	O
ap	pointer
,	O
n	long
,	O
M	pointer
->	O
u	array
[	O
1	int
]	O
[	O
1	int
]	O
)	O
;	O
h1	long
=	O
mpn_submul_1	O
(	O
rp	pointer
,	O
bp	pointer
,	O
n	long
,	O
M	pointer
->	O
u	array
[	O
0	int
]	O
[	O
1	int
]	O
)	O
;	O
ASSERT	O
(	O
h0	long
==	O
h1	long
)	O
;	O
h0	long
=	O
mpn_mul_1	O
(	O
bp	pointer
,	O
bp	pointer
,	O
n	long
,	O
M	pointer
->	O
u	array
[	O
0	int
]	O
[	O
0	int
]	O
)	O
;	O
h1	long
=	O
mpn_submul_1	O
(	O
bp	pointer
,	O
ap	pointer
,	O
n	long
,	O
M	pointer
->	O
u	array
[	O
1	int
]	O
[	O
0	int
]	O
)	O
;	O
ASSERT	O
(	O
h0	long
==	O
h1	long
)	O
;	O
n	long
-=	O
(	O
rp	pointer
[	O
n	long
-	O
1	int
]	O
|	O
bp	pointer
[	O
n	long
-	O
1	int
]	O
)	O
==	O
0	int
;	O
return	O
n	long
;	O
}	O
void	O
mpn_mu_bdiv_q	O
(	O
mp_ptr	pointer
qp	pointer
,	O
mp_srcptr	pointer
np	pointer
,	O
mp_size_t	long
nn	long
,	O
mp_srcptr	pointer
dp	pointer
,	O
mp_size_t	long
dn	long
,	O
mp_ptr	pointer
scratch	pointer
)	O
{	O
mp_size_t	long
qn	long
;	O
mp_size_t	long
in	long
;	O
int	O
cy	long
,	O
c0	long
;	O
mp_size_t	long
tn	long
,	O
wn	long
;	O
qn	long
=	O
nn	long
;	O
ASSERT	O
(	O
dn	long
>=	O
2	int
)	O
;	O
ASSERT	O
(	O
qn	long
>=	O
2	int
)	O
;	O
if	O
(	O
qn	long
>	O
dn	long
)	O
{	O
mp_size_t	long
b	long
;	O
b	long
=	O
(	O
qn	long
-	O
1	int
)	O
/	O
dn	long
+	O
1	int
;	O
in	long
=	O
(	O
qn	long
-	O
1	int
)	O
/	O
b	long
+	O
1	int
;	O
mpn_binvert	O
(	O
ip	pointer
,	O
dp	pointer
,	O
in	pointer
,	O
rp	pointer
)	O
;	O
cy	long
=	O
0	int
;	O
MPN_COPY	O
(	O
rp	pointer
,	O
np	pointer
,	O
dn	long
)	O
;	O
np	pointer
+=	O
dn	long
;	O
mpn_mullo_n	O
(	O
qp	pointer
,	O
rp	pointer
,	O
ip	pointer
,	O
in	pointer
)	O
;	O
qn	long
-=	O
in	long
;	O
while	O
(	O
qn	long
>	O
in	long
)	O
{	O
if	O
(	O
BELOW_THRESHOLD	O
(	O
in	pointer
,	O
MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD	long
)	O
)	O
mpn_mul	O
(	O
tp	pointer
,	O
dp	pointer
,	O
dn	long
,	O
qp	pointer
,	O
in	long
)	O
;	O
else	O
{	O
tn	long
=	O
mpn_mulmod_bnm1_next_size	O
(	O
dn	long
)	O
;	O
mpn_mulmod_bnm1	O
(	O
tp	pointer
,	O
tn	pointer
,	O
dp	pointer
,	O
dn	long
,	O
qp	pointer
,	O
in	int
,	O
scratch_out	O
)	O
;	O
wn	long
=	O
dn	long
+	O
in	int
-	O
tn	long
;	O
if	O
(	O
wn	long
>	O
0	int
)	O
{	O
c0	bool
=	O
mpn_sub_n	O
(	O
tp	pointer
+	O
tn	long
,	O
tp	pointer
,	O
rp	pointer
,	O
wn	long
)	O
;	O
mpn_decr_u	O
(	O
tp	pointer
+	O
wn	long
,	O
c0	O
)	O
;	O
}	O
}	O
qp	pointer
+=	O
in	int
;	O
if	O
(	O
dn	long
!=	O
in	int
)	O
{	O
cy	long
+=	O
mpn_sub_n	O
(	O
rp	pointer
,	O
rp	pointer
+	O
in	pointer
,	O
tp	pointer
+	O
in	long
,	O
dn	long
-	O
in	long
)	O
;	O
if	O
(	O
cy	long
==	O
2	int
)	O
{	O
mpn_incr_u	O
(	O
tp	pointer
+	O
dn	long
,	O
1	int
)	O
;	O
cy	long
=	O
1	int
;	O
}	O
}	O
cy	long
=	O
mpn_sub_nc	O
(	O
rp	pointer
+	O
dn	long
-	O
in	int
,	O
np	pointer
,	O
tp	pointer
+	O
dn	long
,	O
in	pointer
,	O
cy	long
)	O
;	O
np	pointer
+=	O
in	pointer
;	O
mpn_mullo_n	O
(	O
qp	pointer
,	O
rp	pointer
,	O
ip	pointer
,	O
in	pointer
)	O
;	O
qn	long
-=	O
in	long
;	O
}	O
if	O
(	O
BELOW_THRESHOLD	O
(	O
in	pointer
,	O
MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD	int
)	O
)	O
mpn_mul	O
(	O
tp	pointer
,	O
dp	pointer
,	O
dn	long
,	O
qp	pointer
,	O
in	long
)	O
;	O
else	O
{	O
tn	long
=	O
mpn_mulmod_bnm1_next_size	O
(	O
dn	long
)	O
;	O
mpn_mulmod_bnm1	O
(	O
tp	pointer
,	O
tn	pointer
,	O
dp	pointer
,	O
dn	long
,	O
qp	pointer
,	O
in	int
,	O
scratch_out	O
)	O
;	O
wn	long
=	O
dn	long
+	O
in	int
-	O
tn	long
;	O
if	O
(	O
wn	long
>	O
0	int
)	O
{	O
c0	bool
=	O
mpn_sub_n	O
(	O
tp	pointer
+	O
tn	long
,	O
tp	pointer
,	O
rp	pointer
,	O
wn	long
)	O
;	O
mpn_decr_u	O
(	O
tp	pointer
+	O
wn	long
,	O
c0	O
)	O
;	O
}	O
}	O
qp	pointer
+=	O
in	int
;	O
if	O
(	O
dn	long
!=	O
in	int
)	O
{	O
cy	long
+=	O
mpn_sub_n	O
(	O
rp	pointer
,	O
rp	pointer
+	O
in	pointer
,	O
tp	pointer
+	O
in	long
,	O
dn	long
-	O
in	long
)	O
;	O
if	O
(	O
cy	long
==	O
2	int
)	O
{	O
mpn_incr_u	O
(	O
tp	pointer
+	O
dn	long
,	O
1	int
)	O
;	O
cy	long
=	O
1	int
;	O
}	O
}	O
mpn_sub_nc	O
(	O
rp	pointer
+	O
dn	long
-	O
in	int
,	O
np	pointer
,	O
tp	pointer
+	O
dn	long
,	O
qn	long
-	O
(	O
dn	long
-	O
in	long
)	O
,	O
cy	long
)	O
;	O
mpn_mullo_n	O
(	O
qp	pointer
,	O
rp	pointer
,	O
ip	pointer
,	O
qn	long
)	O
;	O
}	O
else	O
{	O
in	pointer
=	O
qn	long
-	O
(	O
qn	long
>>	O
1	int
)	O
;	O
mpn_binvert	O
(	O
ip	pointer
,	O
dp	pointer
,	O
in	pointer
,	O
tp	pointer
)	O
;	O
mpn_mullo_n	O
(	O
qp	pointer
,	O
np	pointer
,	O
ip	pointer
,	O
in	long
)	O
;	O
if	O
(	O
BELOW_THRESHOLD	O
(	O
in	pointer
,	O
MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD	long
)	O
)	O
mpn_mul	O
(	O
tp	pointer
,	O
dp	pointer
,	O
qn	long
,	O
qp	pointer
,	O
in	long
)	O
;	O
else	O
{	O
tn	long
=	O
mpn_mulmod_bnm1_next_size	O
(	O
qn	long
)	O
;	O
mpn_mulmod_bnm1	O
(	O
tp	pointer
,	O
tn	pointer
,	O
dp	pointer
,	O
qn	long
,	O
qp	pointer
,	O
in	pointer
,	O
scratch_out	O
)	O
;	O
wn	long
=	O
qn	long
+	O
in	long
-	O
tn	long
;	O
if	O
(	O
wn	long
>	O
0	int
)	O
{	O
c0	bool
=	O
mpn_cmp	O
(	O
tp	pointer
,	O
np	pointer
,	O
wn	long
)	O
<	O
0	int
;	O
mpn_decr_u	O
(	O
tp	pointer
+	O
wn	long
,	O
c0	O
)	O
;	O
}	O
}	O
mpn_sub_n	O
(	O
tp	pointer
,	O
np	pointer
+	O
in	long
,	O
tp	pointer
+	O
in	long
,	O
qn	long
-	O
in	long
)	O
;	O
mpn_mullo_n	O
(	O
qp	pointer
+	O
in	long
,	O
tp	pointer
,	O
ip	pointer
,	O
qn	long
-	O
in	long
)	O
;	O
}	O
}	O
mp_size_t	long
mpn_mu_bdiv_q_itch	O
(	O
mp_size_t	long
nn	long
,	O
mp_size_t	long
dn	long
)	O
{	O
mp_size_t	long
qn	long
,	O
in	pointer
,	O
tn	long
,	O
itch_binvert	long
,	O
itch_out	long
,	O
itches	long
;	O
mp_size_t	long
b	long
;	O
qn	long
=	O
nn	long
;	O
if	O
(	O
qn	long
>	O
dn	long
)	O
{	O
b	long
=	O
(	O
qn	long
-	O
1	int
)	O
/	O
dn	long
+	O
1	int
;	O
in	long
=	O
(	O
qn	long
-	O
1	int
)	O
/	O
b	long
+	O
1	int
;	O
if	O
(	O
BELOW_THRESHOLD	O
(	O
in	pointer
,	O
MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD	int
)	O
)	O
{	O
tn	long
=	O
dn	long
+	O
in	int
;	O
itch_out	long
=	O
0	int
;	O
}	O
else	O
{	O
tn	long
=	O
mpn_mulmod_bnm1_next_size	O
(	O
dn	long
)	O
;	O
itch_out	long
=	O
mpn_mulmod_bnm1_itch	function
(	O
tn	pointer
,	O
dn	long
,	O
in	int
)	O
;	O
}	O
itch_binvert	pointer
=	O
mpn_binvert_itch	O
(	O
in	pointer
)	O
;	O
itches	long
=	O
dn	long
+	O
tn	long
+	O
itch_out	long
;	O
return	O
in	long
+	O
MAX	O
(	O
itches	int
,	O
itch_binvert	int
)	O
;	O
}	O
else	O
{	O
in	pointer
=	O
qn	long
-	O
(	O
qn	long
>>	O
1	int
)	O
;	O
if	O
(	O
BELOW_THRESHOLD	O
(	O
in	pointer
,	O
MUL_TO_MULMOD_BNM1_FOR_2NXN_THRESHOLD	int
)	O
)	O
{	O
tn	long
=	O
qn	long
+	O
in	long
;	O
itch_out	long
=	O
0	int
;	O
}	O
else	O
{	O
tn	long
=	O
mpn_mulmod_bnm1_next_size	O
(	O
qn	long
)	O
;	O
itch_out	long
=	O
mpn_mulmod_bnm1_itch	function
(	O
tn	pointer
,	O
qn	long
,	O
in	pointer
)	O
;	O
}	O
itch_binvert	pointer
=	O
mpn_binvert_itch	O
(	O
in	pointer
)	O
;	O
itches	pointer
=	O
tn	pointer
+	O
itch_out	long
;	O
return	O
in	pointer
+	O
MAX	O
(	O
itches	pointer
,	O
itch_binvert	pointer
)	O
;	O
}	O
}	O
mp_limb_t	long
mpn_redc_2	O
(	O
mp_ptr	pointer
rp	pointer
,	O
mp_ptr	pointer
up	pointer
,	O
mp_srcptr	pointer
mp	pointer
,	O
mp_size_t	long
n	long
,	O
mp_srcptr	pointer
mip	pointer
)	O
{	O
mp_limb_t	long
q	array
[	O
2	int
]	O
;	O
mp_size_t	long
j	long
;	O
mp_limb_t	long
upn	long
;	O
mp_limb_t	long
cy	long
;	O
ASSERT	O
(	O
n	long
>	O
0	int
)	O
;	O
ASSERT_MPN	O
(	O
up	pointer
,	O
2	int
*	O
n	long
)	O
;	O
if	O
(	O
(	O
n	long
&	O
1	int
)	O
!=	O
0	int
)	O
{	O
up	pointer
[	O
0	int
]	O
=	O
mpn_addmul_1	O
(	O
up	pointer
,	O
mp	pointer
,	O
n	long
,	O
(	O
up	pointer
[	O
0	int
]	O
*	O
mip	pointer
[	O
0	int
]	O
)	O
&	O
GMP_NUMB_MASK	O
)	O
;	O
up	pointer
++	O
;	O
}	O
for	O
(	O
j	long
=	O
n	long
-	O
2	int
;	O
j	long
>=	O
0	int
;	O
j	long
-=	O
2	int
)	O
{	O
umul2low	function
(	O
q	pointer
[	O
1	int
]	O
,	O
q	pointer
[	O
0	int
]	O
,	O
mip	pointer
[	O
1	int
]	O
,	O
mip	pointer
[	O
0	int
]	O
,	O
up	pointer
[	O
1	int
]	O
,	O
up	pointer
[	O
0	int
]	O
)	O
;	O
upn	long
=	O
up	pointer
[	O
n	long
]	O
;	O
up	pointer
[	O
1	int
]	O
=	O
mpn_addmul_2	function
(	O
up	pointer
,	O
mp	pointer
,	O
n	long
,	O
q	pointer
)	O
;	O
up	pointer
[	O
0	int
]	O
=	O
up	pointer
[	O
n	long
]	O
;	O
up	pointer
[	O
n	long
]	O
=	O
upn	long
;	O
up	pointer
+=	O
2	int
;	O
}	O
cy	long
=	O
mpn_add_n	O
(	O
rp	pointer
,	O
up	pointer
,	O
up	pointer
-	O
n	long
,	O
n	long
)	O
;	O
return	O
cy	long
;	O
}	O
static	O
void	O
mpn_bdiv_qr_wrap	O
(	O
mp_ptr	pointer
qp	pointer
,	O
mp_ptr	pointer
rp	pointer
,	O
mp_srcptr	pointer
np	pointer
,	O
mp_size_t	long
nn	long
,	O
mp_srcptr	pointer
dp	pointer
,	O
mp_size_t	long
dn	long
)	O
{	O
mp_ptr	pointer
scratch_out	O
;	O
TMP_DECL	O
;	O
TMP_MARK	O
;	O
scratch_out	O
=	O
TMP_ALLOC_LIMBS	O
(	O
mpn_bdiv_qr_itch	O
(	O
nn	long
,	O
dn	long
)	O
)	O
;	O
mpn_bdiv_qr	O
(	O
qp	pointer
,	O
rp	pointer
,	O
np	pointer
,	O
nn	long
,	O
dp	pointer
,	O
dn	long
,	O
scratch_out	O
)	O
;	O
TMP_FREE	O
;	O
}	O
mp_bitcnt_t	long
mpn_remove	O
(	O
mp_ptr	pointer
wp	pointer
,	O
mp_size_t	long
*	O
wn	long
,	O
mp_ptr	pointer
up	pointer
,	O
mp_size_t	long
un	long
,	O
mp_ptr	pointer
vp	pointer
,	O
mp_size_t	long
vn	long
,	O
mp_bitcnt_t	long
cap	long
)	O
{	O
mp_ptr	pointer
pwpsp	pointer
[	O
LOG	int
]	O
;	O
mp_size_t	long
pwpsn	array
[	O
LOG	int
]	O
;	O
mp_size_t	long
npowers	long
;	O
mp_ptr	pointer
tp	pointer
,	O
qp	pointer
,	O
np	pointer
,	O
pp	pointer
,	O
qp2	pointer
;	O
mp_size_t	long
pn	long
,	O
nn	long
,	O
qn	long
,	O
i	long
;	O
mp_bitcnt_t	long
pwr	long
;	O
TMP_DECL	O
;	O
ASSERT	O
(	O
un	long
>	O
0	int
)	O
;	O
ASSERT	O
(	O
vn	long
>	O
0	int
)	O
;	O
ASSERT	O
(	O
vp	pointer
[	O
0	int
]	O
%	O
2	int
!=	O
0	int
)	O
;	O
ASSERT	O
(	O
vn	long
>	O
1	int
||	O
vp	pointer
[	O
0	int
]	O
>	O
1	int
)	O
;	O
TMP_MARK	O
;	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
(	O
un	long
+	O
1	int
+	O
vn	long
)	O
/	O
2	int
)	O
;	O
qp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
un	long
+	O
1	int
)	O
;	O
qp2	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
un	long
+	O
1	int
)	O
;	O
np	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
un	long
+	O
LOG	long
)	O
;	O
pp	pointer
=	O
vp	pointer
;	O
pn	pointer
=	O
vn	long
;	O
MPN_COPY	O
(	O
qp	pointer
,	O
up	pointer
,	O
un	long
)	O
;	O
qn	long
=	O
un	long
;	O
npowers	long
=	O
0	int
;	O
while	O
(	O
qn	long
>=	O
pn	long
)	O
{	O
qp	pointer
[	O
qn	long
]	O
=	O
0	int
;	O
mpn_bdiv_qr_wrap	function
(	O
qp2	pointer
,	O
tp	pointer
,	O
qp	pointer
,	O
qn	long
+	O
1	int
,	O
pp	pointer
,	O
pn	pointer
)	O
;	O
if	O
(	O
!	O
mpn_zero_p	function
(	O
tp	pointer
,	O
pn	pointer
)	O
)	O
break	O
;	O
MP_PTR_SWAP	O
(	O
qp	pointer
,	O
qp2	int
)	O
;	O
qn	long
=	O
qn	long
-	O
pn	pointer
;	O
qn	long
+=	O
qp	pointer
[	O
qn	long
]	O
!=	O
0	int
;	O
pwpsp	array
[	O
npowers	int
]	O
=	O
pp	pointer
;	O
pwpsn	array
[	O
npowers	int
]	O
=	O
pn	pointer
;	O
npowers	int
++	O
;	O
if	O
(	O
(	O
(	O
mp_bitcnt_t	long
)	O
2	int
<<	O
npowers	int
)	O
-	O
1	int
>	O
cap	int
)	O
break	O
;	O
nn	long
=	O
2	int
*	O
pn	pointer
-	O
1	int
;	O
if	O
(	O
nn	long
>	O
qn	long
)	O
break	O
;	O
mpn_sqr	O
(	O
np	pointer
,	O
pp	pointer
,	O
pn	pointer
)	O
;	O
nn	long
+=	O
np	pointer
[	O
nn	long
]	O
!=	O
0	int
;	O
pp	pointer
=	O
np	pointer
;	O
pn	pointer
=	O
nn	long
;	O
np	pointer
+=	O
nn	long
;	O
}	O
pwr	long
=	O
(	O
(	O
mp_bitcnt_t	long
)	O
1	int
<<	O
npowers	int
)	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
npowers	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
{	O
pp	pointer
=	O
pwpsp	array
[	O
i	long
]	O
;	O
pn	pointer
=	O
pwpsn	array
[	O
i	long
]	O
;	O
if	O
(	O
qn	long
<	O
pn	long
)	O
continue	O
;	O
if	O
(	O
pwr	long
+	O
(	O
(	O
mp_bitcnt_t	long
)	O
1	int
<<	O
i	long
)	O
>	O
cap	int
)	O
continue	O
;	O
qp	pointer
[	O
qn	long
]	O
=	O
0	int
;	O
mpn_bdiv_qr_wrap	function
(	O
qp2	pointer
,	O
tp	pointer
,	O
qp	pointer
,	O
qn	long
+	O
1	int
,	O
pp	pointer
,	O
pn	pointer
)	O
;	O
if	O
(	O
!	O
mpn_zero_p	function
(	O
tp	pointer
,	O
pn	pointer
)	O
)	O
continue	O
;	O
MP_PTR_SWAP	O
(	O
qp	pointer
,	O
qp2	int
)	O
;	O
qn	long
=	O
qn	long
-	O
pn	pointer
;	O
qn	long
+=	O
qp	pointer
[	O
qn	long
]	O
!=	O
0	int
;	O
pwr	long
+=	O
(	O
mp_bitcnt_t	long
)	O
1	int
<<	O
i	long
;	O
}	O
MPN_COPY	O
(	O
wp	pointer
,	O
qp	pointer
,	O
qn	long
)	O
;	O
*	O
wn	pointer
=	O
qn	long
;	O
TMP_FREE	O
;	O
return	O
pwr	long
;	O
}	O
mp_limb_t	long
mpn_sbpi1_bdiv_qr	O
(	O
mp_ptr	pointer
qp	pointer
,	O
mp_ptr	pointer
np	pointer
,	O
mp_size_t	long
nn	long
,	O
mp_srcptr	pointer
dp	pointer
,	O
mp_size_t	long
dn	long
,	O
mp_limb_t	long
dinv	long
)	O
{	O
mp_size_t	long
qn	long
;	O
mp_size_t	long
i	long
;	O
mp_limb_t	long
rh	long
;	O
mp_limb_t	long
ql	long
;	O
ASSERT	O
(	O
dn	long
>	O
0	int
)	O
;	O
ASSERT	O
(	O
nn	long
>	O
dn	long
)	O
;	O
ASSERT	O
(	O
(	O
dp	pointer
[	O
0	int
]	O
&	O
1	int
)	O
!=	O
0	int
)	O
;	O
qn	long
=	O
nn	long
-	O
dn	long
;	O
rh	long
=	O
0	int
;	O
ql	long
=	O
1	int
;	O
while	O
(	O
qn	long
>	O
dn	long
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dn	long
;	O
i	long
++	O
)	O
{	O
mp_limb_t	long
q	long
;	O
q	int
=	O
dinv	long
*	O
np	pointer
[	O
i	long
]	O
;	O
np	pointer
[	O
i	long
]	O
=	O
mpn_addmul_1	O
(	O
np	pointer
+	O
i	long
,	O
dp	pointer
,	O
dn	long
,	O
q	int
)	O
;	O
qp	pointer
[	O
i	long
]	O
=	O
~	O
q	int
;	O
}	O
rh	long
+=	O
mpn_add	O
(	O
np	pointer
+	O
dn	long
,	O
np	pointer
+	O
dn	long
,	O
qn	long
,	O
np	pointer
,	O
dn	long
)	O
;	O
ql	long
=	O
mpn_add_1	O
(	O
qp	pointer
,	O
qp	pointer
,	O
dn	long
,	O
ql	long
)	O
;	O
qp	pointer
+=	O
dn	long
;	O
qn	long
-=	O
dn	long
;	O
np	pointer
+=	O
dn	long
;	O
nn	long
-=	O
dn	long
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
qn	long
;	O
i	long
++	O
)	O
{	O
mp_limb_t	long
q	long
;	O
q	int
=	O
dinv	long
*	O
np	pointer
[	O
i	long
]	O
;	O
np	pointer
[	O
i	long
]	O
=	O
mpn_addmul_1	O
(	O
np	pointer
+	O
i	long
,	O
dp	pointer
,	O
dn	long
,	O
q	int
)	O
;	O
qp	pointer
[	O
i	long
]	O
=	O
~	O
q	int
;	O
}	O
rh	long
+=	O
mpn_add_n	O
(	O
np	pointer
+	O
dn	long
,	O
np	pointer
+	O
dn	long
,	O
np	pointer
,	O
qn	long
)	O
;	O
ql	long
=	O
mpn_add_1	O
(	O
qp	pointer
,	O
qp	pointer
,	O
qn	long
,	O
ql	long
)	O
;	O
if	O
(	O
UNLIKELY	O
(	O
ql	long
>	O
0	int
)	O
)	O
{	O
ASSERT	O
(	O
rh	long
==	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
mp_limb_t	long
cy	long
;	O
cy	long
=	O
mpn_sub_n	O
(	O
np	pointer
+	O
qn	long
,	O
np	pointer
+	O
qn	long
,	O
dp	pointer
,	O
dn	long
)	O
;	O
ASSERT	O
(	O
cy	long
>=	O
rh	long
)	O
;	O
return	O
cy	long
-	O
rh	long
;	O
}	O
}	O
void	O
mpn_toom22_mul	O
(	O
mp_ptr	pointer
pp	pointer
,	O
mp_srcptr	pointer
ap	pointer
,	O
mp_size_t	long
an	long
,	O
mp_srcptr	pointer
bp	pointer
,	O
mp_size_t	long
bn	long
,	O
mp_ptr	pointer
scratch	pointer
)	O
{	O
const	O
int	O
__gmpn_cpuvec_initialized	int
=	O
1	int
;	O
mp_size_t	long
n	long
,	O
s	array
,	O
t	long
;	O
int	O
vm1_neg	int
;	O
mp_limb_t	long
cy	long
,	O
cy2	long
;	O
mp_ptr	pointer
asm1	pointer
;	O
mp_ptr	pointer
bsm1	pointer
;	O
s	array
=	O
an	long
>>	O
1	int
;	O
n	long
=	O
an	long
-	O
s	array
;	O
t	long
=	O
bn	long
-	O
n	long
;	O
ASSERT	O
(	O
an	long
>=	O
bn	long
)	O
;	O
ASSERT	O
(	O
0	int
<	O
s	array
&&	O
s	array
<=	O
n	long
)	O
;	O
ASSERT	O
(	O
0	int
<	O
t	long
&&	O
t	long
<=	O
s	array
)	O
;	O
asm1	pointer
=	O
pp	pointer
;	O
bsm1	pointer
=	O
pp	pointer
+	O
n	long
;	O
vm1_neg	int
=	O
0	int
;	O
if	O
(	O
s	array
==	O
n	long
)	O
{	O
if	O
(	O
mpn_cmp	O
(	O
a0	O
,	O
a1	O
,	O
n	long
)	O
<	O
0	int
)	O
{	O
mpn_sub_n	O
(	O
asm1	pointer
,	O
a1	O
,	O
a0	O
,	O
n	long
)	O
;	O
vm1_neg	int
=	O
1	int
;	O
}	O
else	O
{	O
mpn_sub_n	O
(	O
asm1	pointer
,	O
a0	O
,	O
a1	O
,	O
n	long
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mpn_zero_p	function
(	O
a0	O
+	O
s	array
,	O
n	long
-	O
s	array
)	O
&&	O
mpn_cmp	O
(	O
a0	O
,	O
a1	O
,	O
s	array
)	O
<	O
0	int
)	O
{	O
mpn_sub_n	O
(	O
asm1	pointer
,	O
a1	O
,	O
a0	O
,	O
s	array
)	O
;	O
MPN_ZERO	O
(	O
asm1	pointer
+	O
s	array
,	O
n	long
-	O
s	array
)	O
;	O
vm1_neg	int
=	O
1	int
;	O
}	O
else	O
{	O
mpn_sub	O
(	O
asm1	pointer
,	O
a0	O
,	O
n	long
,	O
a1	O
,	O
s	array
)	O
;	O
}	O
}	O
if	O
(	O
t	long
==	O
n	long
)	O
{	O
if	O
(	O
mpn_cmp	O
(	O
b0	O
,	O
b1	O
,	O
n	long
)	O
<	O
0	int
)	O
{	O
mpn_sub_n	O
(	O
bsm1	pointer
,	O
b1	O
,	O
b0	O
,	O
n	long
)	O
;	O
vm1_neg	int
^=	O
1	int
;	O
}	O
else	O
{	O
mpn_sub_n	O
(	O
bsm1	pointer
,	O
b0	O
,	O
b1	O
,	O
n	long
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mpn_zero_p	function
(	O
b0	O
+	O
t	long
,	O
n	long
-	O
t	long
)	O
&&	O
mpn_cmp	O
(	O
b0	O
,	O
b1	O
,	O
t	long
)	O
<	O
0	int
)	O
{	O
mpn_sub_n	O
(	O
bsm1	pointer
,	O
b1	O
,	O
b0	O
,	O
t	long
)	O
;	O
MPN_ZERO	O
(	O
bsm1	pointer
+	O
t	long
,	O
n	long
-	O
t	long
)	O
;	O
vm1_neg	int
^=	O
1	int
;	O
}	O
else	O
{	O
mpn_sub	O
(	O
bsm1	pointer
,	O
b0	O
,	O
n	long
,	O
b1	O
,	O
t	long
)	O
;	O
}	O
}	O
TOOM22_MUL_N_REC	O
(	O
vm1	O
,	O
asm1	pointer
,	O
bsm1	pointer
,	O
n	long
,	O
scratch_out	O
)	O
;	O
if	O
(	O
s	array
>	O
t	long
)	O
TOOM22_MUL_REC	function
(	O
vinf	O
,	O
a1	O
,	O
s	array
,	O
b1	O
,	O
t	long
,	O
scratch_out	O
)	O
;	O
else	O
TOOM22_MUL_N_REC	function
(	O
vinf	O
,	O
a1	O
,	O
b1	O
,	O
s	long
,	O
scratch_out	O
)	O
;	O
TOOM22_MUL_N_REC	O
(	O
v0	O
,	O
ap	pointer
,	O
bp	pointer
,	O
n	long
,	O
scratch_out	O
)	O
;	O
cy	long
=	O
mpn_add_n	O
(	O
pp	pointer
+	O
2	int
*	O
n	long
,	O
v0	O
+	O
n	long
,	O
vinf	O
,	O
n	long
)	O
;	O
cy2	long
=	O
cy	long
+	O
mpn_add_n	O
(	O
pp	pointer
+	O
n	long
,	O
pp	pointer
+	O
2	int
*	O
n	long
,	O
v0	O
,	O
n	long
)	O
;	O
cy	long
+=	O
mpn_add	O
(	O
pp	pointer
+	O
2	int
*	O
n	long
,	O
pp	pointer
+	O
2	int
*	O
n	long
,	O
n	long
,	O
vinf	O
+	O
n	long
,	O
s	array
+	O
t	long
-	O
n	long
)	O
;	O
if	O
(	O
vm1_neg	int
)	O
cy	long
+=	O
mpn_add_n	O
(	O
pp	pointer
+	O
n	long
,	O
pp	pointer
+	O
n	long
,	O
vm1	O
,	O
2	int
*	O
n	long
)	O
;	O
else	O
cy	long
-=	O
mpn_sub_n	O
(	O
pp	pointer
+	O
n	long
,	O
pp	pointer
+	O
n	long
,	O
vm1	O
,	O
2	int
*	O
n	long
)	O
;	O
ASSERT	O
(	O
cy	long
+	O
1	int
<=	O
3	int
)	O
;	O
ASSERT	O
(	O
cy2	long
<=	O
2	int
)	O
;	O
mpn_incr_u	O
(	O
pp	pointer
+	O
2	int
*	O
n	long
,	O
cy2	long
)	O
;	O
if	O
(	O
LIKELY	O
(	O
cy	long
<=	O
2	int
)	O
)	O
mpn_incr_u	O
(	O
pp	pointer
+	O
3	int
*	O
n	long
,	O
cy	long
)	O
;	O
else	O
mpn_decr_u	O
(	O
pp	pointer
+	O
3	int
*	O
n	long
,	O
1	int
)	O
;	O
}	O
static	O
int	O
abs_sub_n	function
(	O
mp_ptr	pointer
rp	pointer
,	O
mp_srcptr	pointer
ap	pointer
,	O
mp_srcptr	pointer
bp	pointer
,	O
mp_size_t	long
n	long
)	O
{	O
mp_limb_t	long
x	long
,	O
y	long
;	O
while	O
(	O
--	O
n	long
>=	O
0	int
)	O
{	O
x	long
=	O
ap	pointer
[	O
n	long
]	O
;	O
y	long
=	O
bp	pointer
[	O
n	long
]	O
;	O
if	O
(	O
x	long
!=	O
y	long
)	O
{	O
n	long
++	O
;	O
if	O
(	O
x	long
>	O
y	long
)	O
{	O
mpn_sub_n	O
(	O
rp	pointer
,	O
ap	pointer
,	O
bp	pointer
,	O
n	long
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
mpn_sub_n	O
(	O
rp	pointer
,	O
bp	pointer
,	O
ap	pointer
,	O
n	long
)	O
;	O
return	O
~	O
0	int
;	O
}	O
}	O
rp	pointer
[	O
n	long
]	O
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
abs_sub_add_n	function
(	O
mp_ptr	pointer
rm	pointer
,	O
mp_ptr	pointer
rp	pointer
,	O
mp_srcptr	pointer
rs	pointer
,	O
mp_size_t	long
n	long
)	O
{	O
int	O
result	int
;	O
result	pointer
=	O
abs_sub_n	function
(	O
rm	O
,	O
rp	pointer
,	O
rs	pointer
,	O
n	long
)	O
;	O
ASSERT_NOCARRY	O
(	O
mpn_add_n	O
(	O
rp	pointer
,	O
rp	pointer
,	O
rs	pointer
,	O
n	long
)	O
)	O
;	O
return	O
result	pointer
;	O
}	O
void	O
mpn_toom63_mul	O
(	O
mp_ptr	pointer
pp	pointer
,	O
mp_srcptr	pointer
ap	pointer
,	O
mp_size_t	long
an	long
,	O
mp_srcptr	pointer
bp	pointer
,	O
mp_size_t	long
bn	long
,	O
mp_ptr	pointer
scratch	pointer
)	O
{	O
mp_size_t	long
n	long
,	O
s	array
,	O
t	long
;	O
mp_limb_t	long
cy	long
;	O
int	O
sign	int
;	O
ASSERT	O
(	O
an	long
>=	O
bn	long
)	O
;	O
n	long
=	O
1	int
+	O
(	O
an	long
>=	O
2	int
*	O
bn	long
?	O
(	O
an	long
-	O
1	int
)	O
/	O
(	O
size_t	long
)	O
6	int
:	O
(	O
bn	long
-	O
1	int
)	O
/	O
(	O
size_t	long
)	O
3	int
)	O
;	O
s	array
=	O
an	long
-	O
5	int
*	O
n	long
;	O
t	long
=	O
bn	long
-	O
2	int
*	O
n	long
;	O
ASSERT	O
(	O
0	int
<	O
s	array
&&	O
s	array
<=	O
n	long
)	O
;	O
ASSERT	O
(	O
0	int
<	O
t	long
&&	O
t	long
<=	O
n	long
)	O
;	O
ASSERT	O
(	O
s	array
+	O
t	long
>=	O
n	long
)	O
;	O
ASSERT	O
(	O
s	array
+	O
t	long
>	O
4	int
)	O
;	O
ASSERT	O
(	O
n	long
>	O
2	int
)	O
;	O
sign	char
=	O
mpn_toom_eval_pm2exp	O
(	O
v2	O
,	O
v0	O
,	O
5	int
,	O
ap	pointer
,	O
n	long
,	O
s	array
,	O
2	int
,	O
pp	pointer
)	O
;	O
pp	pointer
[	O
n	long
]	O
=	O
mpn_lshift	O
(	O
pp	pointer
,	O
b1	O
,	O
n	long
,	O
2	int
)	O
;	O
v3	array
[	O
t	long
]	O
=	O
mpn_lshift	O
(	O
v3	O
,	O
b2	O
,	O
t	long
,	O
4	int
)	O
;	O
if	O
(	O
n	long
==	O
t	long
)	O
v3	O
[	O
n	long
]	O
+=	O
mpn_add_n	O
(	O
v3	O
,	O
v3	O
,	O
b0	O
,	O
n	long
)	O
;	O
else	O
v3	O
[	O
n	long
]	O
=	O
mpn_add	O
(	O
v3	O
,	O
b0	O
,	O
n	long
,	O
v3	O
,	O
t	long
+	O
1	int
)	O
;	O
sign	int
^=	O
abs_sub_add_n	function
(	O
v1	O
,	O
v3	O
,	O
pp	pointer
,	O
n	long
+	O
1	int
)	O
;	O
TOOM_63_MUL_N_REC	function
(	O
pp	pointer
,	O
v0	O
,	O
v1	O
,	O
n	long
+	O
1	int
,	O
ws	O
)	O
;	O
TOOM_63_MUL_N_REC	O
(	O
r3	O
,	O
v2	O
,	O
v3	O
,	O
n	long
+	O
1	int
,	O
ws	O
)	O
;	O
mpn_toom_couple_handling	O
(	O
r3	O
,	O
2	int
*	O
n	long
+	O
1	int
,	O
pp	pointer
,	O
sign	int
,	O
n	long
,	O
2	int
,	O
4	int
)	O
;	O
sign	char
=	O
mpn_toom_eval_pm1	O
(	O
v2	O
,	O
v0	O
,	O
5	int
,	O
ap	pointer
,	O
n	long
,	O
s	array
,	O
pp	pointer
)	O
;	O
cy	long
=	O
mpn_add	O
(	O
ws	O
,	O
b0	O
,	O
n	long
,	O
b2	O
,	O
t	long
)	O
;	O
v3	O
[	O
n	long
]	O
=	O
cy	long
+	O
mpn_add_n	O
(	O
v3	O
,	O
ws	O
,	O
b1	O
,	O
n	long
)	O
;	O
if	O
(	O
cy	long
==	O
0	int
&&	O
mpn_cmp	O
(	O
ws	O
,	O
b1	O
,	O
n	long
)	O
<	O
0	int
)	O
{	O
mpn_sub_n	O
(	O
v1	O
,	O
b1	O
,	O
ws	O
,	O
n	long
)	O
;	O
v1	O
[	O
n	long
]	O
=	O
0	int
;	O
sign	int
=	O
~	O
sign	int
;	O
}	O
else	O
{	O
cy	long
-=	O
mpn_sub_n	O
(	O
v1	O
,	O
ws	O
,	O
b1	O
,	O
n	long
)	O
;	O
v1	O
[	O
n	long
]	O
=	O
cy	long
;	O
}	O
TOOM_63_MUL_N_REC	function
(	O
pp	pointer
,	O
v0	O
,	O
v1	O
,	O
n	long
+	O
1	int
,	O
ws	O
)	O
;	O
TOOM_63_MUL_N_REC	O
(	O
r7	O
,	O
v2	O
,	O
v3	O
,	O
n	long
+	O
1	int
,	O
ws	O
)	O
;	O
mpn_toom_couple_handling	O
(	O
r7	O
,	O
2	int
*	O
n	long
+	O
1	int
,	O
pp	pointer
,	O
sign	int
,	O
n	long
,	O
0	int
,	O
0	int
)	O
;	O
sign	char
=	O
mpn_toom_eval_pm2	O
(	O
v2	O
,	O
v0	O
,	O
5	int
,	O
ap	pointer
,	O
n	long
,	O
s	array
,	O
pp	pointer
)	O
;	O
pp	pointer
[	O
n	long
]	O
=	O
mpn_lshift	O
(	O
pp	pointer
,	O
b1	O
,	O
n	long
,	O
1	int
)	O
;	O
v3	array
[	O
t	long
]	O
=	O
mpn_lshift	O
(	O
v3	O
,	O
b2	O
,	O
t	long
,	O
2	int
)	O
;	O
if	O
(	O
n	long
==	O
t	long
)	O
v3	O
[	O
n	long
]	O
+=	O
mpn_add_n	O
(	O
v3	O
,	O
v3	O
,	O
b0	O
,	O
n	long
)	O
;	O
else	O
v3	O
[	O
n	long
]	O
=	O
mpn_add	O
(	O
v3	O
,	O
b0	O
,	O
n	long
,	O
v3	O
,	O
t	long
+	O
1	int
)	O
;	O
sign	int
^=	O
abs_sub_add_n	function
(	O
v1	O
,	O
v3	O
,	O
pp	pointer
,	O
n	long
+	O
1	int
)	O
;	O
TOOM_63_MUL_N_REC	function
(	O
pp	pointer
,	O
v0	O
,	O
v1	O
,	O
n	long
+	O
1	int
,	O
ws	O
)	O
;	O
TOOM_63_MUL_N_REC	O
(	O
r5	O
,	O
v2	O
,	O
v3	O
,	O
n	long
+	O
1	int
,	O
ws	O
)	O
;	O
mpn_toom_couple_handling	O
(	O
r5	O
,	O
2	int
*	O
n	long
+	O
1	int
,	O
pp	pointer
,	O
sign	int
,	O
n	long
,	O
1	int
,	O
2	int
)	O
;	O
TOOM_63_MUL_N_REC	O
(	O
pp	pointer
,	O
ap	pointer
,	O
bp	pointer
,	O
n	long
,	O
ws	O
)	O
;	O
if	O
(	O
s	array
>	O
t	long
)	O
{	O
TOOM_63_MUL_REC	function
(	O
r1	O
,	O
a5	O
,	O
s	array
,	O
b2	O
,	O
t	long
,	O
ws	O
)	O
;	O
}	O
else	O
{	O
TOOM_63_MUL_REC	function
(	O
r1	O
,	O
b2	O
,	O
t	long
,	O
a5	O
,	O
s	array
,	O
ws	pointer
)	O
;	O
}	O
;	O
mpn_toom_interpolate_8pts	O
(	O
pp	pointer
,	O
n	long
,	O
r3	O
,	O
r7	O
,	O
s	array
+	O
t	long
,	O
ws	O
)	O
;	O
}	O
int	O
mpn_toom_eval_dgr3_pm2	O
(	O
mp_ptr	pointer
xp2	pointer
,	O
mp_ptr	pointer
xm2	pointer
,	O
mp_srcptr	pointer
xp	pointer
,	O
mp_size_t	long
n	long
,	O
mp_size_t	long
x3n	long
,	O
mp_ptr	pointer
tp	pointer
)	O
{	O
mp_limb_t	long
cy	long
;	O
int	O
neg	int
;	O
ASSERT	O
(	O
x3n	long
>	O
0	int
)	O
;	O
ASSERT	O
(	O
x3n	long
<=	O
n	long
)	O
;	O
xp2	pointer
[	O
n	long
]	O
=	O
mpn_addlsh2_n	O
(	O
xp2	pointer
,	O
xp	pointer
,	O
xp	pointer
+	O
2	int
*	O
n	long
,	O
n	long
)	O
;	O
cy	long
=	O
mpn_addlsh2_n	O
(	O
tp	pointer
,	O
xp	pointer
+	O
n	long
,	O
xp	pointer
+	O
3	int
*	O
n	long
,	O
x3n	long
)	O
;	O
if	O
(	O
x3n	long
<	O
n	long
)	O
cy	long
=	O
mpn_add_1	O
(	O
tp	pointer
+	O
x3n	long
,	O
xp	pointer
+	O
n	long
+	O
x3n	long
,	O
n	long
-	O
x3n	long
,	O
cy	long
)	O
;	O
tp	pointer
[	O
n	long
]	O
=	O
cy	long
;	O
mpn_lshift	O
(	O
tp	pointer
,	O
tp	pointer
,	O
n	long
+	O
1	int
,	O
1	int
)	O
;	O
neg	int
=	O
(	O
mpn_cmp	O
(	O
xp2	pointer
,	O
tp	pointer
,	O
n	long
+	O
1	int
)	O
<	O
0	int
)	O
?	O
~	O
0	int
:	O
0	int
;	O
if	O
(	O
neg	int
)	O
mpn_sub_n	O
(	O
xm2	pointer
,	O
tp	pointer
,	O
xp2	pointer
,	O
n	long
+	O
1	int
)	O
;	O
else	O
mpn_sub_n	O
(	O
xm2	pointer
,	O
xp2	pointer
,	O
tp	pointer
,	O
n	long
+	O
1	int
)	O
;	O
mpn_add_n	O
(	O
xp2	pointer
,	O
xp2	pointer
,	O
tp	pointer
,	O
n	long
+	O
1	int
)	O
;	O
ASSERT	O
(	O
xp2	pointer
[	O
n	long
]	O
<	O
15	int
)	O
;	O
ASSERT	O
(	O
xm2	pointer
[	O
n	long
]	O
<	O
10	int
)	O
;	O
return	O
neg	int
;	O
}	O
int	O
mpn_toom_eval_pm2rexp	O
(	O
mp_ptr	pointer
rp	pointer
,	O
mp_ptr	pointer
rm	struct
,	O
unsigned	O
int	O
q	pointer
,	O
mp_srcptr	pointer
ap	pointer
,	O
mp_size_t	long
n	int
,	O
mp_size_t	long
t	long
,	O
unsigned	O
int	O
s	array
,	O
mp_ptr	pointer
ws	pointer
)	O
{	O
unsigned	O
int	O
i	int
;	O
int	O
neg	int
;	O
ASSERT	O
(	O
n	int
>=	O
t	int
)	O
;	O
ASSERT	O
(	O
s	int
!=	O
0	int
)	O
;	O
ASSERT	O
(	O
q	int
>	O
1	int
)	O
;	O
ASSERT	O
(	O
s	int
*	O
q	pointer
<	O
GMP_NUMB_BITS	O
)	O
;	O
rp	pointer
[	O
n	int
]	O
=	O
mpn_lshift	O
(	O
rp	pointer
,	O
ap	pointer
,	O
n	int
,	O
s	array
*	O
q	pointer
)	O
;	O
ws	pointer
[	O
n	long
]	O
=	O
mpn_lshift	O
(	O
ws	pointer
,	O
ap	pointer
+	O
n	long
,	O
n	int
,	O
s	array
*	O
(	O
q	pointer
-	O
1	int
)	O
)	O
;	O
if	O
(	O
(	O
q	int
&	O
1	int
)	O
!=	O
0	int
)	O
{	O
ASSERT_NOCARRY	O
(	O
mpn_add	O
(	O
ws	pointer
,	O
ws	pointer
,	O
n	long
+	O
1	int
,	O
ap	pointer
+	O
n	long
*	O
q	pointer
,	O
t	int
)	O
)	O
;	O
rp	pointer
[	O
n	long
]	O
+=	O
DO_mpn_addlsh_n	function
(	O
rp	pointer
,	O
ap	pointer
+	O
n	long
*	O
(	O
q	pointer
-	O
1	int
)	O
,	O
n	long
,	O
s	array
,	O
rm	O
)	O
;	O
}	O
else	O
{	O
ASSERT_NOCARRY	O
(	O
mpn_add	O
(	O
rp	pointer
,	O
rp	pointer
,	O
n	long
+	O
1	int
,	O
ap	pointer
+	O
n	long
*	O
q	pointer
,	O
t	pointer
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
q	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
rp	pointer
[	O
n	int
]	O
+=	O
DO_mpn_addlsh_n	function
(	O
rp	pointer
,	O
ap	pointer
+	O
n	long
*	O
i	int
,	O
n	int
,	O
s	array
*	O
(	O
q	pointer
-	O
i	int
)	O
,	O
rm	struct
)	O
;	O
i	int
++	O
;	O
ws	pointer
[	O
n	long
]	O
+=	O
DO_mpn_addlsh_n	function
(	O
ws	pointer
,	O
ap	pointer
+	O
n	long
*	O
i	int
,	O
n	long
,	O
s	array
*	O
(	O
q	pointer
-	O
i	int
)	O
,	O
rm	struct
)	O
;	O
}	O
;	O
neg	int
=	O
(	O
mpn_cmp	O
(	O
rp	pointer
,	O
ws	pointer
,	O
n	long
+	O
1	int
)	O
<	O
0	int
)	O
?	O
~	O
0	int
:	O
0	int
;	O
if	O
(	O
neg	int
)	O
mpn_sub_n	O
(	O
rm	O
,	O
ws	pointer
,	O
rp	pointer
,	O
n	long
+	O
1	int
)	O
;	O
else	O
mpn_sub_n	O
(	O
rm	struct
,	O
rp	pointer
,	O
ws	pointer
,	O
n	int
+	O
1	int
)	O
;	O
ASSERT_NOCARRY	O
(	O
mpn_add_n	O
(	O
rp	pointer
,	O
rp	pointer
,	O
ws	pointer
,	O
n	long
+	O
1	int
)	O
)	O
;	O
return	O
neg	int
;	O
}	O
void	O
mpq_clear	O
(	O
MP_RAT	struct
*	O
m	pointer
)	O
{	O
(	O
*	O
__gmp_free_func	pointer
)	O
(	O
PTR	O
(	O
NUM	O
(	O
m	pointer
)	O
)	O
,	O
ALLOC	O
(	O
NUM	O
(	O
m	pointer
)	O
)	O
*	O
BYTES_PER_MP_LIMB	int
)	O
;	O
(	O
*	O
__gmp_free_func	pointer
)	O
(	O
PTR	O
(	O
DEN	O
(	O
m	pointer
)	O
)	O
,	O
ALLOC	O
(	O
DEN	O
(	O
m	pointer
)	O
)	O
*	O
BYTES_PER_MP_LIMB	int
)	O
;	O
}	O
void	O
mpq_set_d	function
(	O
mpq_ptr	pointer
dest	pointer
,	O
double	O
d	pointer
)	O
{	O
int	O
negative	int
;	O
mp_exp_t	long
exp	int
;	O
mp_limb_t	long
tp	pointer
[	O
LIMBS_PER_DOUBLE	O
]	O
;	O
mp_ptr	pointer
np	pointer
,	O
dp	pointer
;	O
mp_size_t	long
nn	long
,	O
dn	long
;	O
int	O
c	int
;	O
DOUBLE_NAN_INF_ACTION	O
(	O
d	long
,	O
__gmp_invalid_operation	function
(	O
)	O
,	O
__gmp_invalid_operation	function
(	O
)	O
)	O
;	O
negative	int
=	O
d	long
<	O
0	int
;	O
d	long
=	O
ABS	O
(	O
d	long
)	O
;	O
exp	int
=	O
__gmp_extract_double	function
(	O
tp	pointer
,	O
d	long
)	O
;	O
if	O
(	O
exp	int
<=	O
1	int
)	O
{	O
if	O
(	O
d	long
==	O
0.0	int
)	O
{	O
SIZ	O
(	O
NUM	O
(	O
dest	pointer
)	O
)	O
=	O
0	int
;	O
SIZ	O
(	O
DEN	O
(	O
dest	pointer
)	O
)	O
=	O
1	int
;	O
PTR	O
(	O
DEN	O
(	O
dest	pointer
)	O
)	O
[	O
0	int
]	O
=	O
1	int
;	O
return	O
;	O
}	O
dn	long
=	O
-	O
exp	int
;	O
np	pointer
=	O
MPZ_NEWALLOC	O
(	O
NUM	O
(	O
dest	pointer
)	O
,	O
3	int
)	O
;	O
if	O
(	O
tp	pointer
[	O
0	int
]	O
==	O
0	int
)	O
np	pointer
[	O
0	int
]	O
=	O
tp	pointer
[	O
1	int
]	O
,	O
nn	long
=	O
1	int
;	O
else	O
np	pointer
[	O
1	int
]	O
=	O
tp	pointer
[	O
1	int
]	O
,	O
np	pointer
[	O
0	int
]	O
=	O
tp	pointer
[	O
0	int
]	O
,	O
nn	long
=	O
2	int
;	O
dn	long
+=	O
nn	long
+	O
1	int
;	O
ASSERT_ALWAYS	O
(	O
dn	long
>	O
0	int
)	O
;	O
dp	pointer
=	O
MPZ_NEWALLOC	O
(	O
DEN	O
(	O
dest	pointer
)	O
,	O
dn	long
)	O
;	O
MPN_ZERO	O
(	O
dp	pointer
,	O
dn	long
-	O
1	int
)	O
;	O
dp	pointer
[	O
dn	long
-	O
1	int
]	O
=	O
1	int
;	O
count_trailing_zeros	O
(	O
c	int
,	O
np	pointer
[	O
0	int
]	O
|	O
dp	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
c	long
!=	O
0	int
)	O
{	O
mpn_rshift	O
(	O
np	pointer
,	O
np	pointer
,	O
nn	long
,	O
c	pointer
)	O
;	O
nn	long
-=	O
np	pointer
[	O
nn	long
-	O
1	int
]	O
==	O
0	int
;	O
mpn_rshift	O
(	O
dp	pointer
,	O
dp	pointer
,	O
dn	long
,	O
c	int
)	O
;	O
dn	long
-=	O
dp	pointer
[	O
dn	long
-	O
1	int
]	O
==	O
0	int
;	O
}	O
SIZ	O
(	O
DEN	O
(	O
dest	pointer
)	O
)	O
=	O
dn	long
;	O
SIZ	O
(	O
NUM	O
(	O
dest	pointer
)	O
)	O
=	O
negative	int
?	O
-	O
nn	long
:	O
nn	long
;	O
}	O
else	O
{	O
nn	long
=	O
exp	int
;	O
np	pointer
=	O
MPZ_NEWALLOC	O
(	O
NUM	O
(	O
dest	pointer
)	O
,	O
nn	long
)	O
;	O
switch	O
(	O
nn	long
)	O
{	O
default	O
:	O
MPN_ZERO	O
(	O
np	pointer
,	O
nn	long
-	O
LIMBS_PER_DOUBLE	O
)	O
;	O
np	pointer
+=	O
nn	long
-	O
LIMBS_PER_DOUBLE	O
;	O
case	O
2	int
:	O
np	pointer
[	O
1	int
]	O
=	O
tp	pointer
[	O
1	int
]	O
,	O
np	pointer
[	O
0	int
]	O
=	O
tp	pointer
[	O
0	int
]	O
;	O
break	O
;	O
}	O
dp	pointer
=	O
PTR	O
(	O
DEN	O
(	O
dest	pointer
)	O
)	O
;	O
dp	pointer
[	O
0	int
]	O
=	O
1	int
;	O
SIZ	O
(	O
DEN	O
(	O
dest	pointer
)	O
)	O
=	O
1	int
;	O
SIZ	O
(	O
NUM	O
(	O
dest	pointer
)	O
)	O
=	O
negative	int
?	O
-	O
nn	long
:	O
nn	long
;	O
}	O
}	O
static	O
void	O
__gmpz_aorsmul	function
(	O
REGPARM_3_1	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
x	pointer
,	O
mpz_srcptr	pointer
y	long
,	O
mp_size_t	long
sub	long
)	O
)	O
REGPARM_ATTR	O
(	O
1	int
)	O
;	O
REGPARM_ATTR	O
(	O
1	int
)	O
static	O
void	O
mpz_aorsmul	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
x	pointer
,	O
mpz_srcptr	pointer
y	long
,	O
mp_size_t	long
sub	long
)	O
{	O
mp_size_t	long
xsize	long
,	O
ysize	long
,	O
tsize	long
,	O
wsize	long
,	O
wsize_signed	long
;	O
mp_ptr	pointer
wp	pointer
,	O
tp	pointer
;	O
mp_limb_t	long
c	long
,	O
high	long
;	O
TMP_DECL	O
;	O
xsize	long
=	O
SIZ	O
(	O
x	pointer
)	O
;	O
ysize	long
=	O
SIZ	O
(	O
y	pointer
)	O
;	O
if	O
(	O
xsize	long
==	O
0	int
||	O
ysize	long
==	O
0	int
)	O
return	O
;	O
if	O
(	O
ABS	O
(	O
ysize	long
)	O
>	O
ABS	O
(	O
xsize	long
)	O
)	O
{	O
MPZ_SRCPTR_SWAP	O
(	O
x	double
,	O
y	long
)	O
;	O
MP_SIZE_T_SWAP	O
(	O
xsize	long
,	O
ysize	long
)	O
;	O
}	O
sub	long
^=	O
ysize	long
;	O
ysize	long
=	O
ABS	O
(	O
ysize	long
)	O
;	O
if	O
(	O
ysize	long
==	O
1	int
)	O
{	O
mpz_aorsmul_1	O
(	O
w	pointer
,	O
x	pointer
,	O
PTR	O
(	O
y	pointer
)	O
[	O
0	int
]	O
,	O
sub	pointer
)	O
;	O
return	O
;	O
}	O
sub	long
^=	O
xsize	long
;	O
xsize	long
=	O
ABS	O
(	O
xsize	long
)	O
;	O
wsize_signed	long
=	O
SIZ	O
(	O
w	pointer
)	O
;	O
sub	long
^=	O
wsize_signed	long
;	O
wsize	long
=	O
ABS	O
(	O
wsize_signed	long
)	O
;	O
tsize	long
=	O
xsize	long
+	O
ysize	long
;	O
wp	pointer
=	O
MPZ_REALLOC	O
(	O
w	pointer
,	O
MAX	O
(	O
wsize	long
,	O
tsize	long
)	O
+	O
1	int
)	O
;	O
if	O
(	O
wsize_signed	long
==	O
0	int
)	O
{	O
high	long
=	O
mpn_mul	O
(	O
wp	pointer
,	O
PTR	O
(	O
x	pointer
)	O
,	O
xsize	long
,	O
PTR	O
(	O
y	pointer
)	O
,	O
ysize	long
)	O
;	O
tsize	long
-=	O
(	O
high	long
==	O
0	int
)	O
;	O
SIZ	O
(	O
w	pointer
)	O
=	O
(	O
sub	long
>=	O
0	int
?	O
tsize	long
:	O
-	O
tsize	long
)	O
;	O
return	O
;	O
}	O
TMP_MARK	O
;	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
tsize	long
)	O
;	O
high	long
=	O
mpn_mul	O
(	O
tp	pointer
,	O
PTR	O
(	O
x	pointer
)	O
,	O
xsize	long
,	O
PTR	O
(	O
y	pointer
)	O
,	O
ysize	long
)	O
;	O
tsize	long
-=	O
(	O
high	long
==	O
0	int
)	O
;	O
ASSERT	O
(	O
tp	pointer
[	O
tsize	long
-	O
1	int
]	O
!=	O
0	int
)	O
;	O
if	O
(	O
sub	long
>=	O
0	int
)	O
{	O
mp_srcptr	pointer
up	pointer
=	O
wp	pointer
;	O
mp_size_t	long
usize	pointer
=	O
wsize	long
;	O
if	O
(	O
usize	pointer
<	O
tsize	long
)	O
{	O
up	pointer
=	O
tp	pointer
;	O
usize	pointer
=	O
tsize	long
;	O
tp	pointer
=	O
wp	pointer
;	O
tsize	long
=	O
wsize	long
;	O
wsize	long
=	O
usize	pointer
;	O
}	O
c	long
=	O
mpn_add	O
(	O
wp	pointer
,	O
up	pointer
,	O
usize	pointer
,	O
tp	pointer
,	O
tsize	long
)	O
;	O
wp	pointer
[	O
wsize	long
]	O
=	O
c	int
;	O
wsize	long
+=	O
(	O
c	int
!=	O
0	int
)	O
;	O
}	O
else	O
{	O
mp_srcptr	pointer
up	pointer
=	O
wp	pointer
;	O
mp_size_t	long
usize	pointer
=	O
wsize	long
;	O
if	O
(	O
mpn_cmp_twosizes_lt	function
(	O
up	pointer
,	O
usize	pointer
,	O
tp	pointer
,	O
tsize	long
)	O
)	O
{	O
up	pointer
=	O
tp	pointer
;	O
usize	pointer
=	O
tsize	long
;	O
tp	pointer
=	O
wp	pointer
;	O
tsize	long
=	O
wsize	long
;	O
wsize	long
=	O
usize	pointer
;	O
wsize_signed	long
=	O
-	O
wsize_signed	long
;	O
}	O
ASSERT_NOCARRY	O
(	O
mpn_sub	O
(	O
wp	pointer
,	O
up	pointer
,	O
usize	pointer
,	O
tp	pointer
,	O
tsize	long
)	O
)	O
;	O
wsize	long
=	O
usize	pointer
;	O
MPN_NORMALIZE	O
(	O
wp	pointer
,	O
wsize	long
)	O
;	O
}	O
SIZ	O
(	O
w	pointer
)	O
=	O
(	O
wsize_signed	long
>=	O
0	int
?	O
wsize	long
:	O
-	O
wsize	long
)	O
;	O
TMP_FREE	O
;	O
}	O
void	O
mpz_addmul	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
u	array
,	O
mpz_srcptr	pointer
v	pointer
)	O
{	O
mpz_aorsmul	function
(	O
w	pointer
,	O
u	pointer
,	O
v	pointer
,	O
(	O
mp_size_t	long
)	O
0	int
)	O
;	O
}	O
void	O
mpz_submul	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
u	array
,	O
mpz_srcptr	pointer
v	pointer
)	O
{	O
mpz_aorsmul	function
(	O
w	pointer
,	O
u	pointer
,	O
v	pointer
,	O
(	O
mp_size_t	long
)	O
-	O
1	int
)	O
;	O
}	O
unsigned	O
long	O
int	O
mpz_cdiv_qr_ui	function
(	O
mpz_ptr	pointer
quot	long
,	O
mpz_ptr	pointer
rem	long
,	O
mpz_srcptr	pointer
dividend	pointer
,	O
unsigned	O
long	O
int	O
divisor	long
)	O
{	O
mp_size_t	long
ns	long
,	O
nn	long
,	O
qn	long
;	O
mp_ptr	pointer
np	pointer
,	O
qp	pointer
;	O
mp_limb_t	long
rl	long
;	O
if	O
(	O
UNLIKELY	O
(	O
divisor	long
==	O
0	int
)	O
)	O
DIVIDE_BY_ZERO	O
;	O
ns	long
=	O
SIZ	O
(	O
dividend	pointer
)	O
;	O
if	O
(	O
ns	long
==	O
0	int
)	O
{	O
SIZ	O
(	O
quot	long
)	O
=	O
0	int
;	O
SIZ	O
(	O
rem	long
)	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
nn	long
=	O
ABS	O
(	O
ns	long
)	O
;	O
qp	pointer
=	O
MPZ_REALLOC	O
(	O
quot	long
,	O
nn	long
)	O
;	O
np	pointer
=	O
PTR	O
(	O
dividend	pointer
)	O
;	O
{	O
rl	long
=	O
mpn_divrem_1	O
(	O
qp	pointer
,	O
(	O
mp_size_t	long
)	O
0	int
,	O
np	pointer
,	O
nn	long
,	O
(	O
mp_limb_t	long
)	O
divisor	long
)	O
;	O
if	O
(	O
rl	long
==	O
0	int
)	O
SIZ	O
(	O
rem	long
)	O
=	O
0	int
;	O
else	O
{	O
if	O
(	O
ns	long
>=	O
0	int
)	O
{	O
mpn_incr_u	O
(	O
qp	pointer
,	O
(	O
mp_limb_t	long
)	O
1	int
)	O
;	O
rl	long
=	O
divisor	long
-	O
rl	long
;	O
}	O
PTR	O
(	O
rem	long
)	O
[	O
0	int
]	O
=	O
rl	long
;	O
SIZ	O
(	O
rem	long
)	O
=	O
-	O
(	O
rl	long
!=	O
0	int
)	O
;	O
}	O
qn	long
=	O
nn	long
-	O
(	O
qp	pointer
[	O
nn	long
-	O
1	int
]	O
==	O
0	int
)	O
;	O
}	O
SIZ	O
(	O
quot	long
)	O
=	O
ns	long
>=	O
0	int
?	O
qn	long
:	O
-	O
qn	long
;	O
return	O
rl	long
;	O
}	O
static	O
void	O
__gmpz_cfdiv_q_2exp	function
(	O
REGPARM_3_1	O
(	O
mpz_ptr	pointer
,	O
mpz_srcptr	pointer
,	O
mp_bitcnt_t	long
,	O
int	O
)	O
)	O
REGPARM_ATTR	O
(	O
1	int
)	O
;	O
REGPARM_ATTR	O
(	O
1	int
)	O
static	O
void	O
cfdiv_q_2exp	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
u	array
,	O
mp_bitcnt_t	long
cnt	int
,	O
int	O
dir	int
)	O
{	O
mp_size_t	long
wsize	long
,	O
usize	pointer
,	O
abs_usize	int
,	O
limb_cnt	long
,	O
i	long
;	O
mp_srcptr	pointer
up	pointer
;	O
mp_ptr	pointer
wp	pointer
;	O
mp_limb_t	long
round	function
,	O
rmask	long
;	O
usize	pointer
=	O
SIZ	O
(	O
u	array
)	O
;	O
abs_usize	long
=	O
ABS	O
(	O
usize	pointer
)	O
;	O
limb_cnt	long
=	O
cnt	long
/	O
GMP_NUMB_BITS	O
;	O
wsize	long
=	O
abs_usize	long
-	O
limb_cnt	long
;	O
if	O
(	O
wsize	long
<=	O
0	int
)	O
{	O
PTR	O
(	O
w	pointer
)	O
[	O
0	int
]	O
=	O
1	int
;	O
SIZ	O
(	O
w	pointer
)	O
=	O
(	O
usize	pointer
==	O
0	int
||	O
(	O
usize	pointer
^	O
dir	long
)	O
<	O
0	int
?	O
0	int
:	O
dir	long
)	O
;	O
return	O
;	O
}	O
MPZ_REALLOC	O
(	O
w	pointer
,	O
wsize	long
+	O
1	int
)	O
;	O
up	pointer
=	O
PTR	O
(	O
u	array
)	O
;	O
round	function
=	O
0	int
;	O
rmask	long
=	O
(	O
(	O
usize	pointer
^	O
dir	int
)	O
>=	O
0	int
?	O
MP_LIMB_T_MAX	O
:	O
0	int
)	O
;	O
if	O
(	O
rmask	long
!=	O
0	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
limb_cnt	long
&&	O
round	function
==	O
0	int
;	O
i	long
++	O
)	O
round	function
=	O
up	pointer
[	O
i	long
]	O
;	O
wp	pointer
=	O
PTR	O
(	O
w	pointer
)	O
;	O
cnt	long
%=	O
GMP_NUMB_BITS	O
;	O
if	O
(	O
cnt	int
!=	O
0	int
)	O
{	O
round	function
|=	O
rmask	int
&	O
mpn_rshift	O
(	O
wp	pointer
,	O
up	pointer
+	O
limb_cnt	long
,	O
wsize	long
,	O
cnt	int
)	O
;	O
wsize	long
-=	O
(	O
wp	pointer
[	O
wsize	long
-	O
1	int
]	O
==	O
0	int
)	O
;	O
}	O
else	O
MPN_COPY_INCR	O
(	O
wp	pointer
,	O
up	pointer
+	O
limb_cnt	long
,	O
wsize	long
)	O
;	O
if	O
(	O
round	function
!=	O
0	int
)	O
{	O
if	O
(	O
wsize	long
!=	O
0	int
)	O
{	O
mp_limb_t	long
cy	long
;	O
cy	long
=	O
mpn_add_1	O
(	O
wp	pointer
,	O
wp	pointer
,	O
wsize	long
,	O
CNST_LIMB	O
(	O
1	int
)	O
)	O
;	O
wp	pointer
[	O
wsize	int
]	O
=	O
cy	long
;	O
wsize	long
+=	O
cy	long
;	O
}	O
else	O
{	O
wp	pointer
[	O
0	int
]	O
=	O
1	int
;	O
wsize	long
=	O
1	int
;	O
}	O
}	O
SIZ	O
(	O
w	pointer
)	O
=	O
(	O
usize	pointer
>=	O
0	int
?	O
wsize	int
:	O
-	O
wsize	long
)	O
;	O
}	O
void	O
mpz_cdiv_q_2exp	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
u	array
,	O
mp_bitcnt_t	long
cnt	long
)	O
{	O
cfdiv_q_2exp	function
(	O
w	pointer
,	O
u	pointer
,	O
cnt	int
,	O
1	int
)	O
;	O
}	O
void	O
mpz_fdiv_q_2exp	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
u	array
,	O
mp_bitcnt_t	long
cnt	long
)	O
{	O
cfdiv_q_2exp	function
(	O
w	pointer
,	O
u	pointer
,	O
cnt	int
,	O
-	O
1	int
)	O
;	O
}	O
static	O
void	O
__gmpz_cfdiv_r_2exp	function
(	O
REGPARM_3_1	O
(	O
mpz_ptr	pointer
,	O
mpz_srcptr	pointer
,	O
mp_bitcnt_t	long
,	O
int	O
)	O
)	O
REGPARM_ATTR	O
(	O
1	int
)	O
;	O
REGPARM_ATTR	O
(	O
1	int
)	O
static	O
void	O
cfdiv_r_2exp	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
u	array
,	O
mp_bitcnt_t	long
cnt	long
,	O
int	O
dir	int
)	O
{	O
mp_size_t	long
usize	pointer
,	O
abs_usize	long
,	O
limb_cnt	long
,	O
i	long
;	O
mp_srcptr	pointer
up	pointer
;	O
mp_ptr	pointer
wp	pointer
;	O
mp_limb_t	long
high	long
;	O
usize	pointer
=	O
SIZ	O
(	O
u	array
)	O
;	O
if	O
(	O
usize	pointer
==	O
0	int
)	O
{	O
SIZ	O
(	O
w	pointer
)	O
=	O
0	int
;	O
return	O
;	O
}	O
limb_cnt	long
=	O
cnt	long
/	O
GMP_NUMB_BITS	O
;	O
cnt	int
%=	O
GMP_NUMB_BITS	O
;	O
abs_usize	long
=	O
ABS	O
(	O
usize	pointer
)	O
;	O
up	pointer
=	O
PTR	O
(	O
u	array
)	O
;	O
if	O
(	O
(	O
usize	pointer
^	O
dir	long
)	O
<	O
0	int
)	O
{	O
if	O
(	O
w	array
==	O
u	long
)	O
{	O
if	O
(	O
abs_usize	long
<=	O
limb_cnt	long
)	O
return	O
;	O
wp	pointer
=	O
PTR	O
(	O
w	pointer
)	O
;	O
}	O
else	O
{	O
i	long
=	O
MIN	O
(	O
abs_usize	int
,	O
limb_cnt	long
+	O
1	int
)	O
;	O
wp	pointer
=	O
MPZ_REALLOC	O
(	O
w	pointer
,	O
i	long
)	O
;	O
MPN_COPY	O
(	O
wp	pointer
,	O
up	pointer
,	O
i	long
)	O
;	O
if	O
(	O
abs_usize	long
<=	O
limb_cnt	long
)	O
{	O
SIZ	O
(	O
w	pointer
)	O
=	O
usize	pointer
;	O
return	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
abs_usize	long
<=	O
limb_cnt	long
)	O
goto	O
negate	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
limb_cnt	long
;	O
i	long
++	O
)	O
if	O
(	O
up	pointer
[	O
i	long
]	O
!=	O
0	int
)	O
goto	O
negate	long
;	O
if	O
(	O
(	O
up	pointer
[	O
limb_cnt	long
]	O
&	O
LOW_MASK	function
(	O
cnt	int
)	O
)	O
!=	O
0	int
)	O
goto	O
negate	long
;	O
SIZ	O
(	O
w	pointer
)	O
=	O
0	int
;	O
return	O
;	O
negate	long
:	O
wp	pointer
=	O
MPZ_REALLOC	O
(	O
w	pointer
,	O
limb_cnt	long
+	O
1	int
)	O
;	O
up	pointer
=	O
PTR	O
(	O
u	array
)	O
;	O
i	long
=	O
MIN	O
(	O
abs_usize	pointer
,	O
limb_cnt	long
+	O
1	int
)	O
;	O
mpn_com	O
(	O
wp	pointer
,	O
up	pointer
,	O
i	long
)	O
;	O
for	O
(	O
;	O
i	long
<=	O
limb_cnt	long
;	O
i	long
++	O
)	O
wp	pointer
[	O
i	long
]	O
=	O
GMP_NUMB_MAX	O
;	O
MPN_INCR_U	O
(	O
wp	pointer
,	O
limb_cnt	long
+	O
1	int
,	O
CNST_LIMB	O
(	O
1	int
)	O
)	O
;	O
usize	pointer
=	O
-	O
usize	pointer
;	O
}	O
high	long
=	O
wp	pointer
[	O
limb_cnt	long
]	O
;	O
high	long
&=	O
LOW_MASK	function
(	O
cnt	int
)	O
;	O
wp	pointer
[	O
limb_cnt	long
]	O
=	O
high	long
;	O
while	O
(	O
high	long
==	O
0	int
)	O
{	O
limb_cnt	long
--	O
;	O
if	O
(	O
limb_cnt	long
<	O
0	int
)	O
{	O
SIZ	O
(	O
w	pointer
)	O
=	O
0	int
;	O
return	O
;	O
}	O
high	long
=	O
wp	pointer
[	O
limb_cnt	long
]	O
;	O
}	O
limb_cnt	long
++	O
;	O
SIZ	O
(	O
w	pointer
)	O
=	O
(	O
usize	pointer
>=	O
0	int
?	O
limb_cnt	long
:	O
-	O
limb_cnt	long
)	O
;	O
}	O
void	O
mpz_cdiv_r_2exp	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
u	array
,	O
mp_bitcnt_t	long
cnt	long
)	O
{	O
cfdiv_r_2exp	function
(	O
w	pointer
,	O
u	pointer
,	O
cnt	int
,	O
1	int
)	O
;	O
}	O
void	O
mpz_fdiv_r_2exp	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
u	array
,	O
mp_bitcnt_t	long
cnt	long
)	O
{	O
cfdiv_r_2exp	function
(	O
w	pointer
,	O
u	pointer
,	O
cnt	int
,	O
-	O
1	int
)	O
;	O
}	O
int	O
mpz_cmp	O
(	O
mpz_srcptr	pointer
u	array
,	O
mpz_srcptr	pointer
v	pointer
)	O
__GMP_NOTHROW	O
{	O
mp_size_t	long
usize	pointer
,	O
vsize	long
,	O
dsize	long
,	O
asize	long
;	O
mp_srcptr	pointer
up	pointer
,	O
vp	pointer
;	O
int	O
cmp	int
;	O
usize	pointer
=	O
SIZ	O
(	O
u	array
)	O
;	O
vsize	long
=	O
SIZ	O
(	O
v	pointer
)	O
;	O
dsize	long
=	O
usize	pointer
-	O
vsize	long
;	O
if	O
(	O
dsize	long
!=	O
0	int
)	O
return	O
dsize	long
;	O
asize	long
=	O
ABS	O
(	O
usize	pointer
)	O
;	O
up	pointer
=	O
PTR	O
(	O
u	array
)	O
;	O
vp	pointer
=	O
PTR	O
(	O
v	pointer
)	O
;	O
MPN_CMP	O
(	O
cmp	int
,	O
up	pointer
,	O
vp	pointer
,	O
asize	long
)	O
;	O
return	O
(	O
usize	pointer
>=	O
0	int
?	O
cmp	int
:	O
-	O
cmp	int
)	O
;	O
}	O
int	O
mpz_cmp_d	O
(	O
mpz_srcptr	pointer
z	pointer
,	O
double	O
d	long
)	O
{	O
mp_limb_t	long
darray	array
[	O
LIMBS_PER_DOUBLE	O
]	O
,	O
zlimb	long
,	O
dlimb	long
;	O
mp_srcptr	pointer
zp	pointer
;	O
mp_size_t	long
zsize	long
;	O
int	O
dexp	int
,	O
ret	int
;	O
DOUBLE_NAN_INF_ACTION	O
(	O
d	long
,	O
__gmp_invalid_operation	function
(	O
)	O
,	O
goto	O
z_zero	O
)	O
;	O
zsize	long
=	O
SIZ	O
(	O
z	pointer
)	O
;	O
if	O
(	O
d	long
==	O
0.0	int
)	O
return	O
zsize	long
;	O
if	O
(	O
zsize	long
==	O
0	int
)	O
{	O
z_zero	function
:	O
return	O
(	O
d	long
<	O
0.0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
zsize	long
>=	O
0	int
)	O
{	O
if	O
(	O
d	long
<	O
0.0	int
)	O
return	O
1	int
;	O
ret	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
d	long
>=	O
0.0	int
)	O
return	O
-	O
1	int
;	O
ret	int
=	O
-	O
1	int
;	O
d	long
=	O
-	O
d	long
;	O
zsize	long
=	O
-	O
zsize	long
;	O
}	O
if	O
(	O
d	long
<	O
1.0	int
)	O
return	O
ret	int
;	O
dexp	int
=	O
__gmp_extract_double	function
(	O
darray	array
,	O
d	long
)	O
;	O
ASSERT	O
(	O
dexp	int
>=	O
1	int
)	O
;	O
if	O
(	O
zsize	long
!=	O
dexp	int
)	O
return	O
(	O
zsize	long
>=	O
dexp	int
?	O
ret	int
:	O
-	O
ret	int
)	O
;	O
zp	pointer
=	O
PTR	O
(	O
z	pointer
)	O
;	O
RETURN_CMP	O
(	O
zp	pointer
[	O
zsize	long
-	O
1	int
]	O
,	O
darray	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
zsize	long
==	O
1	int
)	O
return	O
(	O
darray	array
[	O
0	int
]	O
!=	O
0	int
?	O
-	O
ret	int
:	O
0	int
)	O
;	O
RETURN_CMP	O
(	O
zp	pointer
[	O
zsize	long
-	O
2	int
]	O
,	O
darray	array
[	O
0	int
]	O
)	O
;	O
RETURN_NONZERO	O
(	O
zp	pointer
,	O
zsize	long
-	O
2	int
,	O
ret	int
)	O
;	O
}	O
int	O
_mpz_cmp_si	O
(	O
mpz_srcptr	pointer
u	array
,	O
signed	O
long	O
int	O
v_digit	long
)	O
__GMP_NOTHROW	O
{	O
mp_size_t	long
usize	pointer
=	O
SIZ	O
(	O
u	array
)	O
;	O
mp_size_t	long
vsize	long
;	O
mp_limb_t	long
u_digit	long
;	O
unsigned	O
long	O
int	O
absv_digit	int
;	O
vsize	long
=	O
0	int
;	O
if	O
(	O
v_digit	long
>	O
0	int
)	O
vsize	long
=	O
1	int
;	O
else	O
if	O
(	O
v_digit	long
<	O
0	int
)	O
{	O
vsize	long
=	O
-	O
1	int
;	O
}	O
absv_digit	long
=	O
ABS_CAST	O
(	O
unsigned	O
long	O
int	O
,	O
v_digit	long
)	O
;	O
if	O
(	O
usize	pointer
!=	O
vsize	long
)	O
return	O
usize	pointer
-	O
vsize	long
;	O
if	O
(	O
usize	pointer
==	O
0	int
)	O
return	O
0	int
;	O
u_digit	pointer
=	O
PTR	O
(	O
u	array
)	O
[	O
0	int
]	O
;	O
if	O
(	O
u_digit	long
==	O
(	O
mp_limb_t	long
)	O
absv_digit	int
)	O
return	O
0	int
;	O
if	O
(	O
u_digit	long
>	O
(	O
mp_limb_t	long
)	O
absv_digit	int
)	O
return	O
usize	pointer
;	O
else	O
return	O
-	O
usize	pointer
;	O
}	O
void	O
mpz_com	O
(	O
mpz_ptr	pointer
dst	pointer
,	O
mpz_srcptr	pointer
src	pointer
)	O
{	O
mp_size_t	long
size	long
=	O
SIZ	O
(	O
src	pointer
)	O
;	O
mp_srcptr	pointer
src_ptr	pointer
;	O
mp_ptr	pointer
dst_ptr	pointer
;	O
if	O
(	O
size	long
>=	O
0	int
)	O
{	O
if	O
(	O
UNLIKELY	O
(	O
size	long
==	O
0	int
)	O
)	O
{	O
PTR	O
(	O
dst	pointer
)	O
[	O
0	int
]	O
=	O
1	int
;	O
SIZ	O
(	O
dst	pointer
)	O
=	O
-	O
1	int
;	O
}	O
else	O
{	O
mp_limb_t	long
cy	long
;	O
dst_ptr	pointer
=	O
MPZ_REALLOC	O
(	O
dst	pointer
,	O
size	long
+	O
1	int
)	O
;	O
src_ptr	pointer
=	O
PTR	O
(	O
src	pointer
)	O
;	O
cy	long
=	O
mpn_add_1	O
(	O
dst_ptr	pointer
,	O
src_ptr	pointer
,	O
size	long
,	O
(	O
mp_limb_t	long
)	O
1	int
)	O
;	O
dst_ptr	pointer
[	O
size	long
]	O
=	O
cy	long
;	O
size	long
+=	O
(	O
cy	long
!=	O
0	int
)	O
;	O
SIZ	O
(	O
dst	pointer
)	O
=	O
-	O
size	long
;	O
}	O
}	O
else	O
{	O
size	long
=	O
-	O
size	long
;	O
dst_ptr	pointer
=	O
MPZ_REALLOC	O
(	O
dst	pointer
,	O
size	long
)	O
;	O
src_ptr	pointer
=	O
PTR	O
(	O
src	pointer
)	O
;	O
mpn_sub_1	O
(	O
dst_ptr	pointer
,	O
src_ptr	pointer
,	O
size	long
,	O
(	O
mp_limb_t	long
)	O
1	int
)	O
;	O
size	long
-=	O
dst_ptr	pointer
[	O
size	long
-	O
1	int
]	O
==	O
0	int
;	O
SIZ	O
(	O
dst	pointer
)	O
=	O
size	long
;	O
}	O
}	O
static	O
void	O
mpz_divexact_by3	O
(	O
mpz_ptr	pointer
q	pointer
,	O
mpz_srcptr	pointer
a	pointer
)	O
{	O
mp_size_t	long
size	long
=	O
SIZ	O
(	O
a	pointer
)	O
;	O
mp_size_t	long
abs_size	long
=	O
ABS	O
(	O
size	long
)	O
;	O
mp_ptr	pointer
qp	pointer
;	O
qp	pointer
=	O
MPZ_REALLOC	O
(	O
q	pointer
,	O
abs_size	long
)	O
;	O
mpn_bdiv_dbm1	O
(	O
qp	pointer
,	O
PTR	O
(	O
a	int
)	O
,	O
abs_size	long
,	O
GMP_NUMB_MASK	O
/	O
3	int
)	O
;	O
abs_size	long
-=	O
(	O
qp	pointer
[	O
abs_size	long
-	O
1	int
]	O
==	O
0	int
)	O
;	O
SIZ	O
(	O
q	pointer
)	O
=	O
(	O
size	long
>	O
0	int
?	O
abs_size	long
:	O
-	O
abs_size	long
)	O
;	O
}	O
static	O
void	O
mpz_divexact_by5	O
(	O
mpz_ptr	pointer
q	pointer
,	O
mpz_srcptr	pointer
a	pointer
)	O
{	O
mp_size_t	long
size	long
=	O
SIZ	O
(	O
a	pointer
)	O
;	O
mp_size_t	long
abs_size	long
=	O
ABS	O
(	O
size	long
)	O
;	O
mp_ptr	pointer
qp	pointer
;	O
qp	pointer
=	O
MPZ_REALLOC	O
(	O
q	pointer
,	O
abs_size	long
)	O
;	O
mpn_bdiv_dbm1	O
(	O
qp	pointer
,	O
PTR	O
(	O
a	int
)	O
,	O
abs_size	long
,	O
GMP_NUMB_MASK	O
/	O
5	int
)	O
;	O
abs_size	long
-=	O
(	O
qp	pointer
[	O
abs_size	long
-	O
1	int
]	O
==	O
0	int
)	O
;	O
SIZ	O
(	O
q	pointer
)	O
=	O
(	O
size	long
>	O
0	int
?	O
abs_size	long
:	O
-	O
abs_size	long
)	O
;	O
}	O
static	O
void	O
mpz_divexact_limb	O
(	O
mpz_ptr	pointer
q	pointer
,	O
mpz_srcptr	pointer
a	int
,	O
mp_limb_t	long
d	long
)	O
{	O
mp_size_t	long
size	long
=	O
SIZ	O
(	O
a	pointer
)	O
;	O
mp_size_t	long
abs_size	long
=	O
ABS	O
(	O
size	long
)	O
;	O
mp_ptr	pointer
qp	pointer
;	O
qp	pointer
=	O
MPZ_REALLOC	O
(	O
q	pointer
,	O
abs_size	long
)	O
;	O
mpn_divexact_1	O
(	O
qp	pointer
,	O
PTR	O
(	O
a	int
)	O
,	O
abs_size	long
,	O
d	long
)	O
;	O
abs_size	long
-=	O
(	O
qp	pointer
[	O
abs_size	long
-	O
1	int
]	O
==	O
0	int
)	O
;	O
SIZ	O
(	O
q	pointer
)	O
=	O
(	O
size	long
>	O
0	int
?	O
abs_size	long
:	O
-	O
abs_size	long
)	O
;	O
}	O
void	O
mpz_divexact_gcd	O
(	O
mpz_ptr	pointer
q	pointer
,	O
mpz_srcptr	pointer
a	pointer
,	O
mpz_srcptr	pointer
d	pointer
)	O
{	O
ASSERT	O
(	O
mpz_sgn	function
(	O
d	long
)	O
>	O
0	int
)	O
;	O
if	O
(	O
SIZ	O
(	O
a	pointer
)	O
==	O
0	int
)	O
{	O
SIZ	O
(	O
q	pointer
)	O
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
SIZ	O
(	O
d	long
)	O
==	O
1	int
)	O
{	O
mp_limb_t	long
dl	long
=	O
PTR	O
(	O
d	pointer
)	O
[	O
0	int
]	O
;	O
int	O
twos	int
;	O
if	O
(	O
(	O
dl	long
&	O
1	int
)	O
==	O
0	int
)	O
{	O
count_trailing_zeros	O
(	O
twos	int
,	O
dl	long
)	O
;	O
dl	long
>>=	O
twos	int
;	O
mpz_tdiv_q_2exp	O
(	O
q	int
,	O
a	int
,	O
twos	int
)	O
;	O
a	int
=	O
q	int
;	O
}	O
if	O
(	O
dl	long
==	O
1	int
)	O
{	O
if	O
(	O
q	int
!=	O
a	pointer
)	O
mpz_set	O
(	O
q	pointer
,	O
a	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
dl	long
==	O
3	int
)	O
{	O
mpz_divexact_by3	function
(	O
q	pointer
,	O
a	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
dl	long
==	O
5	int
)	O
{	O
mpz_divexact_by5	function
(	O
q	pointer
,	O
a	pointer
)	O
;	O
return	O
;	O
}	O
mpz_divexact_limb	function
(	O
q	pointer
,	O
a	int
,	O
dl	long
)	O
;	O
return	O
;	O
}	O
mpz_divexact	O
(	O
q	pointer
,	O
a	pointer
,	O
d	pointer
)	O
;	O
}	O
int	O
mpz_divisible_p	O
(	O
mpz_srcptr	pointer
a	int
,	O
mpz_srcptr	pointer
d	int
)	O
{	O
mp_size_t	long
dsize	long
=	O
SIZ	O
(	O
d	long
)	O
;	O
mp_size_t	long
asize	long
=	O
SIZ	O
(	O
a	int
)	O
;	O
if	O
(	O
UNLIKELY	O
(	O
dsize	long
==	O
0	int
)	O
)	O
return	O
(	O
asize	long
==	O
0	int
)	O
;	O
return	O
mpn_divisible_p	O
(	O
PTR	O
(	O
a	int
)	O
,	O
ABS	O
(	O
asize	long
)	O
,	O
PTR	O
(	O
d	long
)	O
,	O
ABS	O
(	O
dsize	long
)	O
)	O
;	O
}	O
void	O
mpz_dump	O
(	O
mpz_srcptr	pointer
u	pointer
)	O
{	O
char	O
*	O
str	pointer
;	O
str	pointer
=	O
mpz_get_str	O
(	O
0	int
,	O
10	int
,	O
u	int
)	O
;	O
printf	function
(	O
"%s\n"	pointer
,	O
str	pointer
)	O
;	O
(	O
*	O
__gmp_free_func	pointer
)	O
(	O
str	pointer
,	O
strlen	function
(	O
str	pointer
)	O
+	O
1	int
)	O
;	O
}	O
void	O
mpz_fdiv_q	O
(	O
mpz_ptr	pointer
quot	long
,	O
mpz_srcptr	pointer
dividend	pointer
,	O
mpz_srcptr	pointer
divisor	pointer
)	O
{	O
mp_size_t	long
dividend_size	long
=	O
SIZ	O
(	O
dividend	pointer
)	O
;	O
mp_size_t	long
divisor_size	long
=	O
SIZ	O
(	O
divisor	pointer
)	O
;	O
mpz_t	array
rem	long
;	O
TMP_DECL	O
;	O
TMP_MARK	O
;	O
MPZ_TMP_INIT	O
(	O
rem	long
,	O
ABS	O
(	O
divisor_size	long
)	O
)	O
;	O
mpz_tdiv_qr	O
(	O
quot	long
,	O
rem	long
,	O
dividend	pointer
,	O
divisor	pointer
)	O
;	O
if	O
(	O
(	O
divisor_size	long
^	O
dividend_size	long
)	O
<	O
0	int
&&	O
SIZ	O
(	O
rem	long
)	O
!=	O
0	int
)	O
mpz_sub_ui	O
(	O
quot	long
,	O
quot	long
,	O
1L	int
)	O
;	O
TMP_FREE	O
;	O
}	O
void	O
mpz_fib_ui	O
(	O
mpz_ptr	pointer
fn	pointer
,	O
unsigned	O
long	O
n	long
)	O
{	O
mp_ptr	pointer
fp	pointer
,	O
xp	pointer
,	O
yp	pointer
;	O
mp_size_t	long
size	long
,	O
xalloc	long
;	O
unsigned	O
long	O
n2	long
;	O
mp_limb_t	long
c	long
,	O
c2	int
;	O
TMP_DECL	O
;	O
if	O
(	O
n	long
<=	O
FIB_TABLE_LIMIT	int
)	O
{	O
PTR	O
(	O
fn	pointer
)	O
[	O
0	int
]	O
=	O
FIB_TABLE	O
(	O
n	long
)	O
;	O
SIZ	O
(	O
fn	pointer
)	O
=	O
(	O
n	long
!=	O
0	int
)	O
;	O
return	O
;	O
}	O
n2	long
=	O
n	long
/	O
2	int
;	O
xalloc	long
=	O
MPN_FIB2_SIZE	O
(	O
n2	long
)	O
+	O
1	int
;	O
fp	pointer
=	O
MPZ_REALLOC	O
(	O
fn	pointer
,	O
2	int
*	O
xalloc	long
+	O
1	int
)	O
;	O
TMP_MARK	O
;	O
TMP_ALLOC_LIMBS_2	O
(	O
xp	pointer
,	O
xalloc	long
,	O
yp	pointer
,	O
xalloc	long
)	O
;	O
size	long
=	O
mpn_fib2_ui	O
(	O
xp	pointer
,	O
yp	pointer
,	O
n2	long
)	O
;	O
TRACE	O
(	O
printf	function
(	O
"mpz_fib_ui last step n=%lu size=%ld bit=%lu\n"	pointer
,	O
n	long
>>	O
1	int
,	O
size	long
,	O
n	long
&	O
1	int
)	O
;	O
mpn_trace	O
(	O
"xp"	pointer
,	O
xp	pointer
,	O
size	long
)	O
;	O
mpn_trace	O
(	O
"yp"	pointer
,	O
yp	pointer
,	O
size	long
)	O
)	O
;	O
if	O
(	O
n	long
&	O
1	int
)	O
{	O
mp_size_t	long
xsize	long
,	O
ysize	long
;	O
c2	int
=	O
mpn_lshift	O
(	O
fp	pointer
,	O
xp	pointer
,	O
size	long
,	O
1	int
)	O
;	O
c	int
=	O
c2	int
+	O
mpn_add_n	O
(	O
xp	pointer
,	O
fp	pointer
,	O
yp	pointer
,	O
size	long
)	O
;	O
xp	pointer
[	O
size	long
]	O
=	O
c	int
;	O
xsize	long
=	O
size	long
+	O
(	O
c	int
!=	O
0	int
)	O
;	O
c2	int
-=	O
mpn_sub_n	O
(	O
yp	pointer
,	O
fp	pointer
,	O
yp	pointer
,	O
size	long
)	O
;	O
yp	pointer
[	O
size	long
]	O
=	O
c2	int
;	O
ASSERT	O
(	O
c2	int
<=	O
1	int
)	O
;	O
ysize	long
=	O
size	long
+	O
c2	int
;	O
size	long
=	O
xsize	long
+	O
ysize	long
;	O
c	long
=	O
mpn_mul	O
(	O
fp	pointer
,	O
xp	pointer
,	O
xsize	long
,	O
yp	pointer
,	O
ysize	long
)	O
;	O
ASSERT	O
(	O
n	long
&	O
2	int
?	O
fp	pointer
[	O
0	int
]	O
>=	O
2	int
:	O
fp	pointer
[	O
0	int
]	O
<=	O
GMP_NUMB_MAX	O
-	O
2	int
)	O
;	O
fp	pointer
[	O
0	int
]	O
+=	O
(	O
n	long
&	O
2	int
?	O
-	O
CNST_LIMB	O
(	O
2	int
)	O
:	O
CNST_LIMB	O
(	O
2	int
)	O
)	O
;	O
}	O
else	O
{	O
mp_size_t	long
xsize	long
,	O
ysize	long
;	O
c	long
=	O
mpn_lshift	O
(	O
yp	pointer
,	O
yp	pointer
,	O
size	long
,	O
1	int
)	O
;	O
c	long
+=	O
mpn_add_n	O
(	O
yp	pointer
,	O
yp	pointer
,	O
xp	pointer
,	O
size	long
)	O
;	O
yp	pointer
[	O
size	long
]	O
=	O
c	long
;	O
xsize	long
=	O
size	long
;	O
ysize	long
=	O
size	long
+	O
(	O
c	int
!=	O
0	int
)	O
;	O
size	long
+=	O
ysize	long
;	O
c	long
=	O
mpn_mul	O
(	O
fp	pointer
,	O
yp	pointer
,	O
ysize	long
,	O
xp	pointer
,	O
xsize	long
)	O
;	O
}	O
size	long
-=	O
(	O
c	int
==	O
0	int
)	O
;	O
size	long
-=	O
(	O
fp	pointer
[	O
size	long
-	O
1	int
]	O
==	O
0	int
)	O
;	O
SIZ	O
(	O
fn	pointer
)	O
=	O
size	long
;	O
TRACE	O
(	O
printf	function
(	O
"done special, size=%ld\n"	pointer
,	O
size	long
)	O
;	O
mpn_trace	O
(	O
"fp "	pointer
,	O
fp	pointer
,	O
size	long
)	O
)	O
;	O
TMP_FREE	O
;	O
}	O
signed	O
long	O
int	O
mpz_get_si	O
(	O
mpz_srcptr	pointer
z	pointer
)	O
__GMP_NOTHROW	O
{	O
mp_ptr	pointer
zp	pointer
=	O
PTR	O
(	O
z	pointer
)	O
;	O
mp_size_t	long
size	long
=	O
SIZ	O
(	O
z	pointer
)	O
;	O
mp_limb_t	long
zl	long
=	O
zp	pointer
[	O
0	int
]	O
;	O
if	O
(	O
size	long
>	O
0	int
)	O
return	O
zl	int
&	O
LONG_MAX	O
;	O
else	O
if	O
(	O
size	long
<	O
0	int
)	O
return	O
-	O
1	int
-	O
(	O
long	O
)	O
(	O
(	O
zl	long
-	O
1	int
)	O
&	O
LONG_MAX	O
)	O
;	O
else	O
return	O
0	int
;	O
}	O
size_t	long
mpz_inp_raw	O
(	O
mpz_ptr	pointer
x	pointer
,	O
FILE	struct
*	O
fp	pointer
)	O
{	O
unsigned	O
char	O
csize_bytes	array
[	O
4	int
]	O
;	O
mp_size_t	long
csize	long
,	O
abs_xsize	long
,	O
i	long
;	O
size_t	long
abs_csize	long
;	O
char	O
*	O
cp	pointer
;	O
mp_ptr	pointer
xp	pointer
,	O
sp	pointer
,	O
ep	pointer
;	O
mp_limb_t	long
slimb	long
,	O
elimb	long
;	O
if	O
(	O
fp	pointer
==	O
0	int
)	O
fp	pointer
=	O
stdin	pointer
;	O
if	O
(	O
fread	function
(	O
csize_bytes	pointer
,	O
sizeof	O
(	O
csize_bytes	int
)	O
,	O
1	int
,	O
fp	pointer
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
csize	long
=	O
(	O
(	O
mp_size_t	long
)	O
csize_bytes	array
[	O
0	int
]	O
<<	O
24	int
)	O
+	O
(	O
(	O
mp_size_t	long
)	O
csize_bytes	array
[	O
1	int
]	O
<<	O
16	int
)	O
+	O
(	O
(	O
mp_size_t	long
)	O
csize_bytes	array
[	O
2	int
]	O
<<	O
8	int
)	O
+	O
(	O
(	O
mp_size_t	long
)	O
csize_bytes	array
[	O
3	int
]	O
)	O
;	O
if	O
(	O
sizeof	O
(	O
csize	long
)	O
>	O
4	int
&&	O
csize	long
&	O
0x80000000L	long
)	O
csize	long
-=	O
0x80000000L	int
<<	O
1	int
;	O
abs_csize	int
=	O
ABS	O
(	O
csize	long
)	O
;	O
abs_xsize	long
=	O
(	O
abs_csize	long
*	O
8	int
+	O
GMP_NUMB_BITS	O
-	O
1	int
)	O
/	O
GMP_NUMB_BITS	O
;	O
if	O
(	O
abs_xsize	long
!=	O
0	int
)	O
{	O
xp	pointer
=	O
MPZ_REALLOC	O
(	O
x	pointer
,	O
abs_xsize	long
)	O
;	O
xp	pointer
[	O
0	int
]	O
=	O
0	int
;	O
cp	pointer
=	O
(	O
char	O
*	O
)	O
(	O
xp	pointer
+	O
abs_xsize	long
)	O
-	O
abs_csize	int
;	O
if	O
(	O
fread	function
(	O
cp	pointer
,	O
abs_csize	int
,	O
1	int
,	O
fp	pointer
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
GMP_NAIL_BITS	int
==	O
0	int
)	O
{	O
sp	pointer
=	O
xp	pointer
;	O
ep	pointer
=	O
xp	pointer
+	O
abs_xsize	long
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
(	O
abs_xsize	long
+	O
1	int
)	O
/	O
2	int
;	O
i	long
++	O
)	O
{	O
NTOH_LIMB_FETCH	function
(	O
elimb	long
,	O
ep	pointer
)	O
;	O
NTOH_LIMB_FETCH	function
(	O
slimb	pointer
,	O
sp	pointer
)	O
;	O
*	O
sp	pointer
++	O
=	O
elimb	long
;	O
*	O
ep	pointer
--	O
=	O
slimb	int
;	O
}	O
}	O
else	O
{	O
mp_limb_t	long
byte	long
,	O
limb	long
;	O
int	O
bits	int
;	O
mp_size_t	long
tpos	long
;	O
mp_ptr	pointer
tp	pointer
;	O
TMP_DECL	O
;	O
TMP_MARK	O
;	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
abs_xsize	long
)	O
;	O
limb	long
=	O
0	int
;	O
bits	int
=	O
0	int
;	O
tpos	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
abs_csize	int
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
{	O
byte	int
=	O
(	O
unsigned	O
char	O
)	O
cp	pointer
[	O
i	long
]	O
;	O
limb	long
|=	O
(	O
byte	int
<<	O
bits	int
)	O
;	O
bits	long
+=	O
8	int
;	O
if	O
(	O
bits	long
>=	O
GMP_NUMB_BITS	O
)	O
{	O
ASSERT	O
(	O
tpos	long
<	O
abs_xsize	long
)	O
;	O
tp	pointer
[	O
tpos	long
++	O
]	O
=	O
limb	long
&	O
GMP_NUMB_MASK	O
;	O
bits	long
-=	O
GMP_NUMB_BITS	O
;	O
ASSERT	O
(	O
bits	int
<	O
8	int
)	O
;	O
limb	long
=	O
byte	long
>>	O
(	O
8	int
-	O
bits	int
)	O
;	O
}	O
}	O
if	O
(	O
bits	int
!=	O
0	int
)	O
{	O
ASSERT	O
(	O
tpos	long
<	O
abs_xsize	long
)	O
;	O
tp	pointer
[	O
tpos	long
++	O
]	O
=	O
limb	long
;	O
}	O
ASSERT	O
(	O
tpos	long
==	O
abs_xsize	long
)	O
;	O
MPN_COPY	O
(	O
xp	pointer
,	O
tp	pointer
,	O
abs_xsize	long
)	O
;	O
TMP_FREE	O
;	O
}	O
MPN_NORMALIZE	O
(	O
xp	pointer
,	O
abs_xsize	long
)	O
;	O
}	O
SIZ	O
(	O
x	pointer
)	O
=	O
(	O
csize	long
>=	O
0	int
?	O
abs_xsize	long
:	O
-	O
abs_xsize	long
)	O
;	O
return	O
abs_csize	int
+	O
4	int
;	O
}	O
size_t	long
mpz_inp_str	O
(	O
mpz_ptr	pointer
x	pointer
,	O
FILE	struct
*	O
stream	pointer
,	O
int	O
base	int
)	O
{	O
int	O
c	int
;	O
size_t	long
nread	long
;	O
if	O
(	O
stream	int
==	O
0	int
)	O
stream	pointer
=	O
stdin	pointer
;	O
nread	long
=	O
0	int
;	O
do	O
{	O
c	int
=	O
getc	function
(	O
stream	pointer
)	O
;	O
nread	long
++	O
;	O
}	O
while	O
(	O
isspace	function
(	O
c	int
)	O
)	O
;	O
return	O
mpz_inp_str_nowhite	O
(	O
x	int
,	O
stream	int
,	O
base	int
,	O
c	int
,	O
nread	long
)	O
;	O
}	O
size_t	long
mpz_inp_str_nowhite	O
(	O
mpz_ptr	pointer
x	pointer
,	O
FILE	struct
*	O
stream	pointer
,	O
int	O
base	int
,	O
int	O
c	int
,	O
size_t	long
nread	long
)	O
{	O
char	O
*	O
str	pointer
;	O
size_t	long
alloc_size	long
,	O
str_size	long
;	O
int	O
negative	int
;	O
mp_size_t	long
xsize	long
;	O
const	O
unsigned	O
char	O
*	O
digit_value	pointer
;	O
ASSERT_ALWAYS	O
(	O
EOF	O
==	O
-	O
1	int
)	O
;	O
digit_value	int
=	O
digit_value_tab	int
;	O
if	O
(	O
base	int
>	O
36	int
)	O
{	O
digit_value	int
+=	O
224	int
;	O
if	O
(	O
base	int
>	O
62	int
)	O
return	O
0	int
;	O
}	O
negative	int
=	O
0	int
;	O
if	O
(	O
c	int
==	O
'-'	O
)	O
{	O
negative	int
=	O
1	int
;	O
c	int
=	O
getc	function
(	O
stream	pointer
)	O
;	O
nread	O
++	O
;	O
}	O
if	O
(	O
c	int
==	O
EOF	O
||	O
digit_value	array
[	O
c	int
]	O
>=	O
(	O
base	int
==	O
0	int
?	O
10	int
:	O
base	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
base	int
==	O
0	int
)	O
{	O
base	int
=	O
10	int
;	O
if	O
(	O
c	int
==	O
'0'	O
)	O
{	O
base	int
=	O
8	int
;	O
c	int
=	O
getc	function
(	O
stream	pointer
)	O
;	O
nread	O
++	O
;	O
if	O
(	O
c	int
==	O
'x'	O
||	O
c	int
==	O
'X'	O
)	O
{	O
base	int
=	O
16	int
;	O
c	int
=	O
getc	function
(	O
stream	pointer
)	O
;	O
nread	O
++	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'b'	O
||	O
c	int
==	O
'B'	O
)	O
{	O
base	int
=	O
2	int
;	O
c	int
=	O
getc	function
(	O
stream	pointer
)	O
;	O
nread	O
++	O
;	O
}	O
}	O
}	O
while	O
(	O
c	int
==	O
'0'	O
)	O
{	O
c	int
=	O
getc	function
(	O
stream	pointer
)	O
;	O
nread	O
++	O
;	O
}	O
alloc_size	long
=	O
100	int
;	O
str	pointer
=	O
(	O
char	O
*	O
)	O
(	O
*	O
__gmp_allocate_func	pointer
)	O
(	O
alloc_size	long
)	O
;	O
str_size	int
=	O
0	int
;	O
while	O
(	O
c	int
!=	O
EOF	O
)	O
{	O
int	O
dig	int
;	O
dig	int
=	O
digit_value	array
[	O
c	int
]	O
;	O
if	O
(	O
dig	int
>=	O
base	int
)	O
break	O
;	O
if	O
(	O
str_size	long
>=	O
alloc_size	long
)	O
{	O
size_t	long
old_alloc_size	long
=	O
alloc_size	long
;	O
alloc_size	long
=	O
alloc_size	long
*	O
3	int
/	O
2	int
;	O
str	pointer
=	O
(	O
char	O
*	O
)	O
(	O
*	O
__gmp_reallocate_func	pointer
)	O
(	O
str	pointer
,	O
old_alloc_size	long
,	O
alloc_size	long
)	O
;	O
}	O
str	pointer
[	O
str_size	int
++	O
]	O
=	O
dig	int
;	O
c	int
=	O
getc	function
(	O
stream	pointer
)	O
;	O
}	O
nread	long
+=	O
str_size	int
;	O
ungetc	function
(	O
c	int
,	O
stream	pointer
)	O
;	O
nread	long
--	O
;	O
if	O
(	O
str_size	int
==	O
0	int
)	O
{	O
SIZ	O
(	O
x	pointer
)	O
=	O
0	int
;	O
}	O
else	O
{	O
LIMBS_PER_DIGIT_IN_BASE	function
(	O
xsize	long
,	O
str_size	long
,	O
base	pointer
)	O
;	O
MPZ_REALLOC	O
(	O
x	pointer
,	O
xsize	long
)	O
;	O
xsize	long
=	O
mpn_set_str	function
(	O
PTR	O
(	O
x	pointer
)	O
,	O
(	O
unsigned	O
char	O
*	O
)	O
str	pointer
,	O
str_size	int
,	O
base	int
)	O
;	O
SIZ	O
(	O
x	pointer
)	O
=	O
negative	int
?	O
-	O
xsize	long
:	O
xsize	long
;	O
}	O
(	O
*	O
__gmp_free_func	pointer
)	O
(	O
str	pointer
,	O
alloc_size	long
)	O
;	O
return	O
nread	long
;	O
}	O
int	O
mpz_kronecker_si	function
(	O
mpz_srcptr	pointer
a	pointer
,	O
long	O
b	long
)	O
{	O
mp_srcptr	pointer
a_ptr	pointer
;	O
mp_size_t	long
a_size	long
;	O
mp_limb_t	long
a_rem	long
,	O
b_limb	long
;	O
int	O
result_bit1	int
;	O
a_size	long
=	O
SIZ	O
(	O
a	int
)	O
;	O
if	O
(	O
a_size	long
==	O
0	int
)	O
return	O
JACOBI_0S	function
(	O
b	int
)	O
;	O
result_bit1	int
=	O
JACOBI_BSGN_SS_BIT1	O
(	O
a_size	long
,	O
b	int
)	O
;	O
b_limb	long
=	O
ABS_CAST	O
(	O
unsigned	O
long	O
,	O
b	long
)	O
;	O
a_ptr	pointer
=	O
PTR	O
(	O
a	int
)	O
;	O
if	O
(	O
(	O
b_limb	int
&	O
1	int
)	O
==	O
0	int
)	O
{	O
mp_limb_t	long
a_low	long
=	O
a_ptr	pointer
[	O
0	int
]	O
;	O
int	O
twos	int
;	O
if	O
(	O
b_limb	int
==	O
0	int
)	O
return	O
JACOBI_LS0	O
(	O
a_low	long
,	O
a_size	long
)	O
;	O
if	O
(	O
!	O
(	O
a_low	long
&	O
1	int
)	O
)	O
return	O
0	int
;	O
count_trailing_zeros	O
(	O
twos	int
,	O
b_limb	int
)	O
;	O
b_limb	O
>>=	O
twos	int
;	O
result_bit1	int
^=	O
JACOBI_TWOS_U_BIT1	O
(	O
twos	int
,	O
a_low	long
)	O
;	O
}	O
if	O
(	O
b_limb	int
==	O
1	int
)	O
return	O
JACOBI_BIT1_TO_PN	O
(	O
result_bit1	int
)	O
;	O
result_bit1	int
^=	O
JACOBI_ASGN_SU_BIT1	O
(	O
a_size	long
,	O
b_limb	int
)	O
;	O
a_size	long
=	O
ABS	O
(	O
a_size	long
)	O
;	O
JACOBI_MOD_OR_MODEXACT_1_ODD	O
(	O
result_bit1	int
,	O
a_rem	long
,	O
a_ptr	pointer
,	O
a_size	long
,	O
b_limb	int
)	O
;	O
return	O
mpn_jacobi_base	function
(	O
a_rem	long
,	O
b_limb	int
,	O
result_bit1	int
)	O
;	O
}	O
void	O
mpz_lcm	O
(	O
mpz_ptr	pointer
r	pointer
,	O
mpz_srcptr	pointer
u	array
,	O
mpz_srcptr	pointer
v	pointer
)	O
{	O
mpz_t	array
g	array
;	O
mp_size_t	long
usize	pointer
,	O
vsize	long
;	O
TMP_DECL	O
;	O
usize	pointer
=	O
SIZ	O
(	O
u	array
)	O
;	O
vsize	long
=	O
SIZ	O
(	O
v	pointer
)	O
;	O
if	O
(	O
usize	pointer
==	O
0	int
||	O
vsize	long
==	O
0	int
)	O
{	O
SIZ	O
(	O
r	pointer
)	O
=	O
0	int
;	O
return	O
;	O
}	O
usize	pointer
=	O
ABS	O
(	O
usize	pointer
)	O
;	O
vsize	long
=	O
ABS	O
(	O
vsize	long
)	O
;	O
if	O
(	O
vsize	long
==	O
1	int
||	O
usize	pointer
==	O
1	int
)	O
{	O
mp_limb_t	long
vl	long
,	O
gl	long
,	O
c	long
;	O
mp_srcptr	pointer
up	pointer
;	O
mp_ptr	pointer
rp	pointer
;	O
if	O
(	O
usize	pointer
==	O
1	int
)	O
{	O
usize	pointer
=	O
vsize	long
;	O
MPZ_SRCPTR_SWAP	O
(	O
u	array
,	O
v	pointer
)	O
;	O
}	O
MPZ_REALLOC	O
(	O
r	pointer
,	O
usize	pointer
+	O
1	int
)	O
;	O
up	pointer
=	O
PTR	O
(	O
u	array
)	O
;	O
vl	long
=	O
PTR	O
(	O
v	pointer
)	O
[	O
0	int
]	O
;	O
gl	long
=	O
mpn_gcd_1	O
(	O
up	pointer
,	O
usize	pointer
,	O
vl	long
)	O
;	O
vl	long
/=	O
gl	long
;	O
rp	pointer
=	O
PTR	O
(	O
r	pointer
)	O
;	O
c	long
=	O
mpn_mul_1	O
(	O
rp	pointer
,	O
up	pointer
,	O
usize	pointer
,	O
vl	long
)	O
;	O
rp	pointer
[	O
usize	pointer
]	O
=	O
c	long
;	O
usize	pointer
+=	O
(	O
c	long
!=	O
0	int
)	O
;	O
SIZ	O
(	O
r	pointer
)	O
=	O
usize	pointer
;	O
return	O
;	O
}	O
TMP_MARK	O
;	O
MPZ_TMP_INIT	O
(	O
g	pointer
,	O
usize	pointer
)	O
;	O
mpz_gcd	O
(	O
g	pointer
,	O
u	array
,	O
v	pointer
)	O
;	O
mpz_divexact	O
(	O
g	pointer
,	O
u	array
,	O
g	long
)	O
;	O
mpz_mul	O
(	O
r	pointer
,	O
g	pointer
,	O
v	pointer
)	O
;	O
SIZ	O
(	O
r	pointer
)	O
=	O
ABS	O
(	O
SIZ	O
(	O
r	pointer
)	O
)	O
;	O
TMP_FREE	O
;	O
}	O
void	O
mpz_lucnum2_ui	O
(	O
mpz_ptr	pointer
ln	pointer
,	O
mpz_ptr	pointer
lnsub1	pointer
,	O
unsigned	O
long	O
n	long
)	O
{	O
mp_ptr	pointer
lp	pointer
,	O
l1p	pointer
,	O
f1p	pointer
;	O
mp_size_t	long
size	long
;	O
mp_limb_t	long
c	long
;	O
TMP_DECL	O
;	O
ASSERT	O
(	O
ln	pointer
!=	O
lnsub1	pointer
)	O
;	O
if	O
(	O
n	long
<=	O
FIB_TABLE_LUCNUM_LIMIT	int
)	O
{	O
mp_limb_t	long
f	long
=	O
FIB_TABLE	O
(	O
n	long
)	O
;	O
mp_limb_t	long
f1	long
=	O
FIB_TABLE	O
(	O
(	O
int	O
)	O
n	long
-	O
1	int
)	O
;	O
PTR	O
(	O
ln	pointer
)	O
[	O
0	int
]	O
=	O
f	pointer
+	O
2	int
*	O
f1	long
;	O
SIZ	O
(	O
ln	pointer
)	O
=	O
1	int
;	O
PTR	O
(	O
lnsub1	pointer
)	O
[	O
0	int
]	O
=	O
(	O
n	long
==	O
0	int
?	O
1	int
:	O
2	int
*	O
f	pointer
-	O
f1	long
)	O
;	O
SIZ	O
(	O
lnsub1	pointer
)	O
=	O
(	O
n	long
==	O
0	int
?	O
-	O
1	int
:	O
1	int
)	O
;	O
return	O
;	O
}	O
TMP_MARK	O
;	O
size	long
=	O
MPN_FIB2_SIZE	O
(	O
n	long
)	O
;	O
f1p	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
size	long
)	O
;	O
lp	pointer
=	O
MPZ_REALLOC	O
(	O
ln	pointer
,	O
size	long
+	O
1	int
)	O
;	O
l1p	pointer
=	O
MPZ_REALLOC	O
(	O
lnsub1	pointer
,	O
size	long
+	O
1	int
)	O
;	O
size	long
=	O
mpn_fib2_ui	O
(	O
l1p	pointer
,	O
f1p	pointer
,	O
n	long
)	O
;	O
c	long
=	O
mpn_addlsh1_n	O
(	O
lp	pointer
,	O
l1p	pointer
,	O
f1p	pointer
,	O
size	long
)	O
;	O
lp	pointer
[	O
size	long
]	O
=	O
c	int
;	O
SIZ	O
(	O
ln	pointer
)	O
=	O
size	long
+	O
(	O
c	int
!=	O
0	int
)	O
;	O
c	long
=	O
mpn_lshift	O
(	O
l1p	pointer
,	O
l1p	pointer
,	O
size	long
,	O
1	int
)	O
;	O
c	int
-=	O
mpn_sub_n	O
(	O
l1p	pointer
,	O
l1p	pointer
,	O
f1p	pointer
,	O
size	long
)	O
;	O
ASSERT	O
(	O
(	O
mp_limb_signed_t	long
)	O
c	int
>=	O
0	int
)	O
;	O
l1p	array
[	O
size	long
]	O
=	O
c	int
;	O
SIZ	O
(	O
lnsub1	pointer
)	O
=	O
size	long
+	O
(	O
c	int
!=	O
0	int
)	O
;	O
TMP_FREE	O
;	O
}	O
void	O
mpz_neg	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
u	array
)	O
{	O
mp_ptr	pointer
wp	pointer
;	O
mp_srcptr	pointer
up	pointer
;	O
mp_size_t	long
usize	pointer
,	O
size	long
;	O
usize	pointer
=	O
SIZ	O
(	O
u	array
)	O
;	O
if	O
(	O
u	array
!=	O
w	pointer
)	O
{	O
size	long
=	O
ABS	O
(	O
usize	pointer
)	O
;	O
wp	pointer
=	O
MPZ_NEWALLOC	O
(	O
w	pointer
,	O
size	long
)	O
;	O
up	pointer
=	O
PTR	O
(	O
u	array
)	O
;	O
MPN_COPY	O
(	O
wp	pointer
,	O
up	pointer
,	O
size	long
)	O
;	O
}	O
SIZ	O
(	O
w	pointer
)	O
=	O
-	O
usize	pointer
;	O
}	O
void	O
mpz_powm_sec	O
(	O
mpz_ptr	pointer
r	pointer
,	O
mpz_srcptr	pointer
b	pointer
,	O
mpz_srcptr	pointer
e	int
,	O
mpz_srcptr	pointer
m	pointer
)	O
{	O
mp_size_t	long
n	long
;	O
mp_ptr	pointer
rp	pointer
,	O
tp	pointer
;	O
mp_srcptr	pointer
bp	pointer
,	O
ep	pointer
,	O
mp	pointer
;	O
mp_size_t	long
rn	long
,	O
bn	long
,	O
es	pointer
,	O
en	long
;	O
TMP_DECL	O
;	O
n	long
=	O
ABSIZ	O
(	O
m	pointer
)	O
;	O
mp	pointer
=	O
PTR	O
(	O
m	pointer
)	O
;	O
if	O
(	O
UNLIKELY	O
(	O
(	O
n	long
==	O
0	int
)	O
||	O
(	O
mp	pointer
[	O
0	int
]	O
%	O
2	int
==	O
0	int
)	O
)	O
)	O
DIVIDE_BY_ZERO	O
;	O
es	int
=	O
SIZ	O
(	O
e	pointer
)	O
;	O
if	O
(	O
UNLIKELY	O
(	O
es	struct
<=	O
0	int
)	O
)	O
{	O
if	O
(	O
es	struct
==	O
0	int
)	O
{	O
SIZ	O
(	O
r	pointer
)	O
=	O
n	long
!=	O
1	int
||	O
mp	pointer
[	O
0	int
]	O
!=	O
1	int
;	O
PTR	O
(	O
r	pointer
)	O
[	O
0	int
]	O
=	O
1	int
;	O
return	O
;	O
}	O
DIVIDE_BY_ZERO	O
;	O
}	O
en	long
=	O
es	O
;	O
bn	long
=	O
ABSIZ	O
(	O
b	pointer
)	O
;	O
TMP_MARK	O
;	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
n	long
+	O
mpn_powm_sec_itch	O
(	O
bn	long
,	O
en	long
,	O
n	long
)	O
)	O
;	O
rp	pointer
=	O
tp	pointer
;	O
tp	pointer
+=	O
n	long
;	O
bp	pointer
=	O
PTR	O
(	O
b	pointer
)	O
;	O
ep	pointer
=	O
PTR	O
(	O
e	pointer
)	O
;	O
mpn_powm_sec	O
(	O
rp	pointer
,	O
bp	pointer
,	O
bn	long
,	O
ep	pointer
,	O
en	long
,	O
mp	pointer
,	O
n	long
,	O
tp	pointer
)	O
;	O
rn	long
=	O
n	long
;	O
MPN_NORMALIZE	O
(	O
rp	pointer
,	O
rn	long
)	O
;	O
if	O
(	O
(	O
ep	pointer
[	O
0	int
]	O
&	O
1	int
)	O
&&	O
SIZ	O
(	O
b	pointer
)	O
<	O
0	int
&&	O
rn	long
!=	O
0	int
)	O
{	O
mpn_sub	O
(	O
rp	pointer
,	O
PTR	O
(	O
m	pointer
)	O
,	O
n	long
,	O
rp	pointer
,	O
rn	long
)	O
;	O
rn	long
=	O
n	long
;	O
MPN_NORMALIZE	O
(	O
rp	pointer
,	O
rn	long
)	O
;	O
}	O
MPZ_REALLOC	O
(	O
r	pointer
,	O
rn	long
)	O
;	O
SIZ	O
(	O
r	pointer
)	O
=	O
rn	long
;	O
MPN_COPY	O
(	O
PTR	O
(	O
r	pointer
)	O
,	O
rp	pointer
,	O
rn	long
)	O
;	O
TMP_FREE	O
;	O
}	O
static	O
mp_limb_t	long
id_to_n	function
(	O
mp_limb_t	long
id	int
)	O
{	O
return	O
id	int
*	O
3	int
+	O
1	int
+	O
(	O
id	int
&	O
1	int
)	O
;	O
}	O
static	O
mp_limb_t	long
n_to_bit	O
(	O
mp_limb_t	long
n	long
)	O
{	O
return	O
(	O
(	O
n	long
-	O
5	int
)	O
|	O
1	int
)	O
/	O
3U	int
;	O
}	O
void	O
mpz_primorial_ui	O
(	O
mpz_ptr	pointer
x	pointer
,	O
unsigned	O
long	O
n	long
)	O
{	O
static	O
const	O
mp_limb_t	long
table	array
[	O
]	O
=	O
{	O
1	int
,	O
1	int
,	O
2	int
,	O
6	int
,	O
6	int
}	O
;	O
ASSERT	O
(	O
n	long
<=	O
GMP_NUMB_MAX	O
)	O
;	O
if	O
(	O
n	long
<	O
numberof	O
(	O
table	array
)	O
)	O
{	O
PTR	O
(	O
x	array
)	O
[	O
0	int
]	O
=	O
table	array
[	O
n	long
]	O
;	O
SIZ	O
(	O
x	pointer
)	O
=	O
1	int
;	O
}	O
else	O
{	O
mp_limb_t	long
*	O
sieve	pointer
,	O
*	O
factors	pointer
;	O
mp_size_t	long
size	long
;	O
mp_limb_t	long
prod	long
;	O
mp_limb_t	long
j	long
;	O
TMP_DECL	O
;	O
size	long
=	O
1	int
+	O
n	long
/	O
GMP_NUMB_BITS	O
+	O
n	long
/	O
(	O
2	int
*	O
GMP_NUMB_BITS	O
)	O
;	O
ASSERT	O
(	O
size	long
>=	O
primesieve_size	O
(	O
n	long
)	O
)	O
;	O
sieve	pointer
=	O
MPZ_REALLOC	O
(	O
x	pointer
,	O
size	long
)	O
;	O
size	long
=	O
(	O
gmp_primesieve	function
(	O
sieve	pointer
,	O
n	long
)	O
+	O
1	int
)	O
/	O
log_n_max	function
(	O
n	long
)	O
+	O
1	int
;	O
TMP_MARK	O
;	O
factors	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
size	long
)	O
;	O
j	long
=	O
0	int
;	O
prod	pointer
=	O
table	array
[	O
numberof	O
(	O
table	array
)	O
-	O
1	int
]	O
;	O
{	O
mp_limb_t	long
prime	long
,	O
max_prod	long
;	O
max_prod	long
=	O
GMP_NUMB_MAX	O
/	O
n	long
;	O
LOOP_ON_SIEVE_BEGIN	function
(	O
prime	long
,	O
n_to_bit	function
(	O
numberof	O
(	O
table	array
)	O
)	O
,	O
n_to_bit	O
(	O
n	long
)	O
,	O
0	int
,	O
sieve	pointer
)	O
;	O
FACTOR_LIST_STORE	O
(	O
prime	long
,	O
prod	long
,	O
max_prod	long
,	O
factors	pointer
,	O
j	long
)	O
;	O
LOOP_ON_SIEVE_END	int
;	O
}	O
if	O
(	O
j	long
!=	O
0	int
)	O
{	O
factors	pointer
[	O
j	long
++	O
]	O
=	O
prod	long
;	O
mpz_prodlimbs	O
(	O
x	pointer
,	O
factors	pointer
,	O
j	long
)	O
;	O
}	O
else	O
{	O
PTR	O
(	O
x	pointer
)	O
[	O
0	int
]	O
=	O
prod	long
;	O
SIZ	O
(	O
x	pointer
)	O
=	O
1	int
;	O
}	O
TMP_FREE	O
;	O
}	O
}	O
mp_bitcnt_t	long
mpz_scan1	O
(	O
mpz_srcptr	pointer
u	array
,	O
mp_bitcnt_t	long
starting_bit	long
)	O
__GMP_NOTHROW	O
{	O
mp_srcptr	pointer
u_ptr	pointer
=	O
PTR	O
(	O
u	array
)	O
;	O
mp_size_t	long
size	long
=	O
SIZ	O
(	O
u	array
)	O
;	O
mp_size_t	long
abs_size	long
=	O
ABS	O
(	O
size	long
)	O
;	O
mp_srcptr	pointer
u_end	pointer
=	O
u_ptr	pointer
+	O
abs_size	long
-	O
1	int
;	O
mp_size_t	long
starting_limb	long
=	O
starting_bit	long
/	O
GMP_NUMB_BITS	O
;	O
mp_srcptr	pointer
p	pointer
=	O
u_ptr	pointer
+	O
starting_limb	long
;	O
mp_limb_t	long
limb	long
;	O
int	O
cnt	int
;	O
if	O
(	O
starting_limb	long
>=	O
abs_size	long
)	O
return	O
(	O
size	long
>=	O
0	int
?	O
~	O
(	O
mp_bitcnt_t	long
)	O
0	int
:	O
starting_bit	long
)	O
;	O
if	O
(	O
starting_bit	long
==	O
0	int
)	O
goto	O
short_cut	O
;	O
limb	long
=	O
*	O
p	pointer
;	O
if	O
(	O
size	long
>=	O
0	int
)	O
{	O
limb	long
&=	O
(	O
MP_LIMB_T_MAX	O
<<	O
(	O
starting_bit	long
%	O
GMP_NUMB_BITS	O
)	O
)	O
;	O
if	O
(	O
limb	long
==	O
0	int
)	O
{	O
if	O
(	O
p	pointer
==	O
u_end	pointer
)	O
return	O
~	O
(	O
mp_bitcnt_t	long
)	O
0	int
;	O
search_nonzero	O
:	O
do	O
{	O
ASSERT	O
(	O
p	pointer
!=	O
u_end	pointer
)	O
;	O
p	pointer
++	O
;	O
short_cut	function
:	O
limb	long
=	O
*	O
p	pointer
;	O
}	O
while	O
(	O
limb	long
==	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mpn_zero_p	function
(	O
u_ptr	pointer
,	O
starting_limb	pointer
)	O
)	O
{	O
if	O
(	O
limb	long
==	O
0	int
)	O
goto	O
search_nonzero	O
;	O
limb	long
--	O
;	O
}	O
limb	long
|=	O
(	O
CNST_LIMB	O
(	O
1	int
)	O
<<	O
(	O
starting_bit	long
%	O
GMP_NUMB_BITS	O
)	O
)	O
-	O
1	int
;	O
while	O
(	O
limb	long
==	O
GMP_NUMB_MAX	O
)	O
{	O
if	O
(	O
p	pointer
==	O
u_end	pointer
)	O
return	O
(	O
mp_bitcnt_t	long
)	O
abs_size	long
*	O
GMP_NUMB_BITS	O
;	O
p	pointer
++	O
;	O
limb	long
=	O
*	O
p	pointer
;	O
}	O
limb	long
=	O
~	O
limb	long
;	O
}	O
ASSERT	O
(	O
limb	long
!=	O
0	int
)	O
;	O
count_trailing_zeros	O
(	O
cnt	int
,	O
limb	long
)	O
;	O
return	O
(	O
mp_bitcnt_t	long
)	O
(	O
p	pointer
-	O
u_ptr	pointer
)	O
*	O
GMP_NUMB_BITS	O
+	O
cnt	int
;	O
}	O
void	O
mpz_set	O
(	O
mpz_ptr	pointer
w	pointer
,	O
mpz_srcptr	pointer
u	array
)	O
{	O
mp_ptr	pointer
wp	pointer
,	O
up	pointer
;	O
mp_size_t	long
usize	pointer
,	O
size	long
;	O
usize	pointer
=	O
SIZ	O
(	O
u	array
)	O
;	O
size	long
=	O
ABS	O
(	O
usize	pointer
)	O
;	O
wp	pointer
=	O
MPZ_REALLOC	O
(	O
w	pointer
,	O
size	long
)	O
;	O
up	pointer
=	O
PTR	O
(	O
u	array
)	O
;	O
MPN_COPY	O
(	O
wp	pointer
,	O
up	pointer
,	O
size	long
)	O
;	O
SIZ	O
(	O
w	pointer
)	O
=	O
usize	pointer
;	O
}	O
void	O
mpz_set_si	O
(	O
mpz_ptr	pointer
dest	pointer
,	O
signed	O
long	O
int	O
val	long
)	O
{	O
mp_size_t	long
size	long
;	O
mp_limb_t	long
vl	long
;	O
vl	long
=	O
(	O
mp_limb_t	long
)	O
ABS_CAST	function
(	O
unsigned	O
long	O
int	O
,	O
val	long
)	O
;	O
PTR	O
(	O
dest	pointer
)	O
[	O
0	int
]	O
=	O
vl	long
&	O
GMP_NUMB_MASK	O
;	O
size	long
=	O
vl	long
!=	O
0	int
;	O
SIZ	O
(	O
dest	pointer
)	O
=	O
val	long
>=	O
0	int
?	O
size	long
:	O
-	O
size	long
;	O
}	O
int	O
mpz_set_str	O
(	O
mpz_ptr	pointer
x	pointer
,	O
const	O
char	O
*	O
str	pointer
,	O
int	O
base	int
)	O
{	O
size_t	long
str_size	long
;	O
char	O
*	O
s	pointer
,	O
*	O
begs	pointer
;	O
size_t	long
i	long
;	O
mp_size_t	long
xsize	long
;	O
int	O
c	int
;	O
int	O
negative	int
;	O
const	O
unsigned	O
char	O
*	O
digit_value	pointer
;	O
TMP_DECL	O
;	O
digit_value	pointer
=	O
digit_value_tab	int
;	O
if	O
(	O
base	int
>	O
36	int
)	O
{	O
digit_value	int
+=	O
224	int
;	O
if	O
(	O
base	int
>	O
62	int
)	O
return	O
-	O
1	int
;	O
}	O
do	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
str	pointer
++	O
;	O
while	O
(	O
isspace	function
(	O
c	int
)	O
)	O
;	O
negative	int
=	O
0	int
;	O
if	O
(	O
c	int
==	O
'-'	O
)	O
{	O
negative	int
=	O
1	int
;	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
str	pointer
++	O
;	O
}	O
if	O
(	O
digit_value	array
[	O
c	int
]	O
>=	O
(	O
base	int
==	O
0	int
?	O
10	int
:	O
base	int
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
base	int
==	O
0	int
)	O
{	O
base	int
=	O
10	int
;	O
if	O
(	O
c	int
==	O
'0'	O
)	O
{	O
base	int
=	O
8	int
;	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
str	pointer
++	O
;	O
if	O
(	O
c	int
==	O
'x'	O
||	O
c	int
==	O
'X'	O
)	O
{	O
base	int
=	O
16	int
;	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
str	pointer
++	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'b'	O
||	O
c	int
==	O
'B'	O
)	O
{	O
base	int
=	O
2	int
;	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
str	pointer
++	O
;	O
}	O
}	O
}	O
while	O
(	O
c	int
==	O
'0'	O
||	O
isspace	function
(	O
c	int
)	O
)	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
str	pointer
++	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
SIZ	O
(	O
x	pointer
)	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
TMP_MARK	O
;	O
str_size	int
=	O
strlen	function
(	O
str	pointer
-	O
1	int
)	O
;	O
s	pointer
=	O
begs	pointer
=	O
(	O
char	O
*	O
)	O
TMP_ALLOC	O
(	O
str_size	int
+	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
str_size	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
isspace	function
(	O
c	int
)	O
)	O
{	O
int	O
dig	int
=	O
digit_value	array
[	O
c	int
]	O
;	O
if	O
(	O
dig	int
>=	O
base	int
)	O
{	O
TMP_FREE	O
;	O
return	O
-	O
1	int
;	O
}	O
*	O
s	pointer
++	O
=	O
dig	int
;	O
}	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
str	pointer
++	O
;	O
}	O
str_size	int
=	O
s	pointer
-	O
begs	int
;	O
LIMBS_PER_DIGIT_IN_BASE	function
(	O
xsize	long
,	O
str_size	int
,	O
base	pointer
)	O
;	O
MPZ_REALLOC	O
(	O
x	pointer
,	O
xsize	long
)	O
;	O
xsize	long
=	O
mpn_set_str	function
(	O
PTR	O
(	O
x	pointer
)	O
,	O
(	O
unsigned	O
char	O
*	O
)	O
begs	pointer
,	O
str_size	int
,	O
base	int
)	O
;	O
SIZ	O
(	O
x	pointer
)	O
=	O
negative	int
?	O
-	O
xsize	long
:	O
xsize	long
;	O
TMP_FREE	O
;	O
return	O
0	int
;	O
}	O
void	O
mpz_sqrtrem	O
(	O
mpz_ptr	pointer
root	pointer
,	O
mpz_ptr	pointer
rem	long
,	O
mpz_srcptr	pointer
op	pointer
)	O
{	O
mp_size_t	long
op_size	long
,	O
root_size	long
,	O
rem_size	long
;	O
mp_ptr	pointer
root_ptr	pointer
,	O
op_ptr	pointer
,	O
rem_ptr	int
;	O
op_size	long
=	O
SIZ	O
(	O
op	pointer
)	O
;	O
if	O
(	O
UNLIKELY	O
(	O
op_size	long
<=	O
0	int
)	O
)	O
{	O
if	O
(	O
op_size	long
<	O
0	int
)	O
SQRT_OF_NEGATIVE	O
;	O
SIZ	O
(	O
root	pointer
)	O
=	O
0	int
;	O
SIZ	O
(	O
rem	long
)	O
=	O
0	int
;	O
return	O
;	O
}	O
rem_ptr	pointer
=	O
MPZ_REALLOC	O
(	O
rem	long
,	O
op_size	long
)	O
;	O
root_size	long
=	O
(	O
op_size	long
+	O
1	int
)	O
/	O
2	int
;	O
SIZ	O
(	O
root	pointer
)	O
=	O
root_size	long
;	O
op_ptr	pointer
=	O
PTR	O
(	O
op	pointer
)	O
;	O
if	O
(	O
root	pointer
==	O
op	pointer
)	O
{	O
TMP_DECL	O
;	O
TMP_MARK	O
;	O
root_ptr	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
root_size	long
)	O
;	O
rem_size	long
=	O
mpn_sqrtrem	O
(	O
root_ptr	pointer
,	O
rem_ptr	pointer
,	O
op_ptr	pointer
,	O
op_size	long
)	O
;	O
if	O
(	O
rem	long
!=	O
root	pointer
)	O
MPN_COPY	O
(	O
op_ptr	pointer
,	O
root_ptr	pointer
,	O
root_size	long
)	O
;	O
TMP_FREE	O
;	O
}	O
else	O
{	O
root_ptr	pointer
=	O
MPZ_REALLOC	O
(	O
root	pointer
,	O
root_size	long
)	O
;	O
rem_size	long
=	O
mpn_sqrtrem	O
(	O
root_ptr	pointer
,	O
rem_ptr	pointer
,	O
op_ptr	pointer
,	O
op_size	long
)	O
;	O
}	O
SIZ	O
(	O
rem	long
)	O
=	O
rem_size	pointer
;	O
}	O
void	O
mpz_swap	O
(	O
mpz_ptr	pointer
u	pointer
,	O
mpz_ptr	pointer
v	pointer
)	O
__GMP_NOTHROW	O
{	O
mp_ptr	pointer
up	pointer
,	O
vp	pointer
;	O
mp_size_t	long
usize	pointer
,	O
vsize	long
;	O
mp_size_t	long
ualloc	long
,	O
valloc	long
;	O
ualloc	long
=	O
ALLOC	O
(	O
u	array
)	O
;	O
valloc	long
=	O
ALLOC	O
(	O
v	pointer
)	O
;	O
ALLOC	O
(	O
v	pointer
)	O
=	O
ualloc	long
;	O
ALLOC	O
(	O
u	array
)	O
=	O
valloc	long
;	O
usize	pointer
=	O
SIZ	O
(	O
u	array
)	O
;	O
vsize	long
=	O
SIZ	O
(	O
v	pointer
)	O
;	O
SIZ	O
(	O
v	pointer
)	O
=	O
usize	pointer
;	O
SIZ	O
(	O
u	array
)	O
=	O
vsize	long
;	O
up	pointer
=	O
PTR	O
(	O
u	array
)	O
;	O
vp	pointer
=	O
PTR	O
(	O
v	pointer
)	O
;	O
PTR	O
(	O
v	pointer
)	O
=	O
up	pointer
;	O
PTR	O
(	O
u	array
)	O
=	O
vp	pointer
;	O
}	O
void	O
mpz_tdiv_qr	O
(	O
mpz_ptr	pointer
quot	long
,	O
mpz_ptr	pointer
rem	long
,	O
mpz_srcptr	pointer
num	pointer
,	O
mpz_srcptr	pointer
den	pointer
)	O
{	O
mp_size_t	long
ql	long
;	O
mp_size_t	long
ns	long
,	O
ds	long
,	O
nl	long
,	O
dl	long
;	O
mp_ptr	pointer
np	pointer
,	O
dp	pointer
,	O
qp	pointer
,	O
rp	pointer
;	O
TMP_DECL	O
;	O
ns	long
=	O
SIZ	O
(	O
num	pointer
)	O
;	O
ds	long
=	O
SIZ	O
(	O
den	pointer
)	O
;	O
nl	long
=	O
ABS	O
(	O
ns	long
)	O
;	O
dl	long
=	O
ABS	O
(	O
ds	long
)	O
;	O
ql	long
=	O
nl	long
-	O
dl	long
+	O
1	int
;	O
if	O
(	O
UNLIKELY	O
(	O
dl	long
==	O
0	int
)	O
)	O
DIVIDE_BY_ZERO	O
;	O
rp	pointer
=	O
MPZ_REALLOC	O
(	O
rem	long
,	O
dl	long
)	O
;	O
if	O
(	O
ql	long
<=	O
0	int
)	O
{	O
if	O
(	O
num	pointer
!=	O
rem	long
)	O
{	O
np	pointer
=	O
PTR	O
(	O
num	pointer
)	O
;	O
MPN_COPY	O
(	O
rp	pointer
,	O
np	pointer
,	O
nl	long
)	O
;	O
SIZ	O
(	O
rem	long
)	O
=	O
SIZ	O
(	O
num	pointer
)	O
;	O
}	O
SIZ	O
(	O
quot	long
)	O
=	O
0	int
;	O
return	O
;	O
}	O
qp	pointer
=	O
MPZ_REALLOC	O
(	O
quot	long
,	O
ql	long
)	O
;	O
TMP_MARK	O
;	O
np	pointer
=	O
PTR	O
(	O
num	pointer
)	O
;	O
dp	pointer
=	O
PTR	O
(	O
den	pointer
)	O
;	O
if	O
(	O
dp	pointer
==	O
rp	pointer
||	O
dp	pointer
==	O
qp	pointer
)	O
{	O
mp_ptr	pointer
tp	pointer
;	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
dl	long
)	O
;	O
MPN_COPY	O
(	O
tp	pointer
,	O
dp	pointer
,	O
dl	long
)	O
;	O
dp	pointer
=	O
tp	pointer
;	O
}	O
if	O
(	O
np	pointer
==	O
rp	pointer
||	O
np	pointer
==	O
qp	pointer
)	O
{	O
mp_ptr	pointer
tp	pointer
;	O
tp	pointer
=	O
TMP_ALLOC_LIMBS	O
(	O
nl	long
)	O
;	O
MPN_COPY	O
(	O
tp	pointer
,	O
np	pointer
,	O
nl	long
)	O
;	O
np	pointer
=	O
tp	pointer
;	O
}	O
mpn_tdiv_qr	O
(	O
qp	pointer
,	O
rp	pointer
,	O
0L	int
,	O
np	pointer
,	O
nl	long
,	O
dp	pointer
,	O
dl	long
)	O
;	O
ql	long
-=	O
qp	pointer
[	O
ql	long
-	O
1	int
]	O
==	O
0	int
;	O
MPN_NORMALIZE	O
(	O
rp	pointer
,	O
dl	long
)	O
;	O
SIZ	O
(	O
quot	long
)	O
=	O
(	O
ns	long
^	O
ds	long
)	O
>=	O
0	int
?	O
ql	long
:	O
-	O
ql	long
;	O
SIZ	O
(	O
rem	long
)	O
=	O
ns	long
>=	O
0	int
?	O
dl	long
:	O
-	O
dl	long
;	O
TMP_FREE	O
;	O
}	O
void	O
mpz_tdiv_q_2exp	O
(	O
mpz_ptr	pointer
r	pointer
,	O
mpz_srcptr	pointer
u	array
,	O
mp_bitcnt_t	long
cnt	long
)	O
{	O
mp_size_t	long
un	long
,	O
rn	long
;	O
mp_size_t	long
limb_cnt	long
;	O
mp_ptr	pointer
rp	pointer
;	O
mp_srcptr	pointer
up	pointer
;	O
un	long
=	O
SIZ	O
(	O
u	array
)	O
;	O
limb_cnt	long
=	O
cnt	long
/	O
GMP_NUMB_BITS	O
;	O
rn	long
=	O
ABS	O
(	O
un	long
)	O
-	O
limb_cnt	long
;	O
if	O
(	O
rn	long
<=	O
0	int
)	O
rn	long
=	O
0	int
;	O
else	O
{	O
rp	pointer
=	O
MPZ_REALLOC	O
(	O
r	pointer
,	O
rn	long
)	O
;	O
up	pointer
=	O
PTR	O
(	O
u	array
)	O
+	O
limb_cnt	long
;	O
cnt	long
%=	O
GMP_NUMB_BITS	O
;	O
if	O
(	O
cnt	int
!=	O
0	int
)	O
{	O
mpn_rshift	O
(	O
rp	pointer
,	O
up	pointer
,	O
rn	long
,	O
cnt	int
)	O
;	O
rn	long
-=	O
rp	pointer
[	O
rn	long
-	O
1	int
]	O
==	O
0	int
;	O
}	O
else	O
{	O
MPN_COPY_INCR	O
(	O
rp	pointer
,	O
up	pointer
,	O
rn	long
)	O
;	O
}	O
}	O
SIZ	O
(	O
r	pointer
)	O
=	O
un	long
>=	O
0	int
?	O
rn	long
:	O
-	O
rn	long
;	O
}	O
void	O
mpz_urandomb	O
(	O
mpz_ptr	pointer
rop	pointer
,	O
gmp_randstate_t	array
rstate	array
,	O
mp_bitcnt_t	long
nbits	long
)	O
{	O
mp_ptr	pointer
rp	pointer
;	O
mp_size_t	long
size	long
;	O
size	long
=	O
BITS_TO_LIMBS	O
(	O
nbits	long
)	O
;	O
rp	pointer
=	O
MPZ_REALLOC	O
(	O
rop	pointer
,	O
size	long
)	O
;	O
_gmp_rand	O
(	O
rp	pointer
,	O
rstate	array
,	O
nbits	long
)	O
;	O
MPN_NORMALIZE	O
(	O
rp	pointer
,	O
size	long
)	O
;	O
SIZ	O
(	O
rop	pointer
)	O
=	O
size	long
;	O
}	O
static	O
mp_limb_t	long
id_to_n	function
(	O
mp_limb_t	long
id	int
)	O
{	O
return	O
id	int
*	O
3	int
+	O
1	int
+	O
(	O
id	int
&	O
1	int
)	O
;	O
}	O
static	O
mp_limb_t	long
n_to_bit	O
(	O
mp_limb_t	long
n	long
)	O
{	O
return	O
(	O
(	O
n	long
-	O
5	int
)	O
|	O
1	int
)	O
/	O
3U	int
;	O
}	O
static	O
void	O
first_block_primesieve	O
(	O
mp_ptr	pointer
bit_array	pointer
,	O
mp_limb_t	long
n	long
)	O
{	O
mp_size_t	long
bits	long
,	O
limbs	long
;	O
ASSERT	O
(	O
n	long
>	O
4	int
)	O
;	O
bits	int
=	O
n_to_bit	function
(	O
n	long
)	O
;	O
limbs	int
=	O
bits	int
/	O
GMP_LIMB_BITS	int
+	O
1	int
;	O
MPN_ZERO	O
(	O
bit_array	pointer
,	O
limbs	pointer
)	O
;	O
bit_array	array
[	O
0	int
]	O
=	O
SIEVE_SEED	long
;	O
if	O
(	O
(	O
bits	int
+	O
1	int
)	O
%	O
GMP_LIMB_BITS	int
!=	O
0	int
)	O
bit_array	array
[	O
limbs	long
-	O
1	int
]	O
|=	O
MP_LIMB_T_MAX	O
<<	O
(	O
(	O
bits	int
+	O
1	int
)	O
%	O
GMP_LIMB_BITS	int
)	O
;	O
if	O
(	O
n	long
>	O
SEED_LIMIT	int
)	O
{	O
mp_limb_t	long
mask	long
,	O
index	function
,	O
i	long
;	O
ASSERT	O
(	O
n	long
>	O
49	int
)	O
;	O
mask	long
=	O
1	int
;	O
index	function
=	O
0	int
;	O
i	long
=	O
1	int
;	O
do	O
{	O
if	O
(	O
(	O
bit_array	pointer
[	O
index	function
]	O
&	O
mask	long
)	O
==	O
0	int
)	O
{	O
mp_size_t	long
step	pointer
,	O
lindex	int
;	O
mp_limb_t	long
lmask	long
;	O
unsigned	O
maskrot	int
;	O
step	pointer
=	O
id_to_n	function
(	O
i	long
)	O
;	O
lindex	long
=	O
i	long
*	O
(	O
step	pointer
+	O
1	int
)	O
-	O
1	int
+	O
(	O
-	O
(	O
i	long
&	O
1	int
)	O
&	O
(	O
i	long
+	O
1	int
)	O
)	O
;	O
if	O
(	O
lindex	long
>	O
bits	int
)	O
break	O
;	O
step	pointer
<<=	O
1	int
;	O
maskrot	long
=	O
step	pointer
%	O
GMP_LIMB_BITS	int
;	O
lmask	int
=	O
CNST_LIMB	O
(	O
1	int
)	O
<<	O
(	O
lindex	int
%	O
GMP_LIMB_BITS	int
)	O
;	O
do	O
{	O
bit_array	array
[	O
lindex	int
/	O
GMP_LIMB_BITS	int
]	O
|=	O
lmask	int
;	O
lmask	int
=	O
lmask	int
<<	O
maskrot	int
|	O
lmask	int
>>	O
(	O
GMP_LIMB_BITS	int
-	O
maskrot	int
)	O
;	O
lindex	long
+=	O
step	pointer
;	O
}	O
while	O
(	O
lindex	long
<=	O
bits	int
)	O
;	O
lindex	long
=	O
i	long
*	O
(	O
i	long
*	O
3	int
+	O
6	int
)	O
+	O
(	O
i	int
&	O
1	int
)	O
;	O
lmask	long
=	O
CNST_LIMB	O
(	O
1	int
)	O
<<	O
(	O
lindex	int
%	O
GMP_LIMB_BITS	int
)	O
;	O
for	O
(	O
;	O
lindex	long
<=	O
bits	int
;	O
lindex	long
+=	O
step	pointer
)	O
{	O
bit_array	array
[	O
lindex	int
/	O
GMP_LIMB_BITS	int
]	O
|=	O
lmask	int
;	O
lmask	int
=	O
lmask	int
<<	O
maskrot	int
|	O
lmask	int
>>	O
(	O
GMP_LIMB_BITS	int
-	O
maskrot	int
)	O
;	O
}	O
;	O
}	O
mask	long
=	O
mask	long
<<	O
1	int
|	O
mask	int
>>	O
(	O
GMP_LIMB_BITS	int
-	O
1	int
)	O
;	O
index	function
+=	O
mask	long
&	O
1	int
;	O
i	int
++	O
;	O
}	O
while	O
(	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
block_resieve	function
(	O
mp_ptr	pointer
bit_array	pointer
,	O
mp_size_t	long
limbs	long
,	O
mp_limb_t	long
offset	long
,	O
mp_srcptr	pointer
sieve	int
,	O
mp_limb_t	long
sieve_bits	long
)	O
{	O
mp_size_t	long
bits	long
,	O
step	pointer
;	O
ASSERT	O
(	O
limbs	long
>	O
0	int
)	O
;	O
bits	int
=	O
limbs	long
*	O
GMP_LIMB_BITS	int
-	O
1	int
;	O
MPN_ZERO	O
(	O
bit_array	pointer
,	O
limbs	int
)	O
;	O
LOOP_ON_SIEVE_BEGIN	function
(	O
step	pointer
,	O
0	int
,	O
sieve_bits	pointer
,	O
0	int
,	O
sieve	pointer
)	O
;	O
{	O
mp_size_t	long
lindex	long
;	O
mp_limb_t	long
lmask	long
;	O
unsigned	O
maskrot	int
;	O
lindex	long
=	O
__i	long
*	O
(	O
step	pointer
+	O
1	int
)	O
-	O
1	int
+	O
(	O
-	O
(	O
__i	int
&	O
1	int
)	O
&	O
(	O
__i	int
+	O
1	int
)	O
)	O
;	O
if	O
(	O
lindex	long
>	O
bits	int
+	O
offset	long
)	O
break	O
;	O
step	pointer
<<=	O
1	int
;	O
maskrot	int
=	O
step	pointer
%	O
GMP_LIMB_BITS	int
;	O
if	O
(	O
lindex	long
<	O
offset	long
)	O
lindex	long
+=	O
step	long
*	O
(	O
(	O
offset	long
-	O
lindex	int
-	O
1	int
)	O
/	O
step	pointer
+	O
1	int
)	O
;	O
lindex	long
-=	O
offset	long
;	O
lmask	long
=	O
CNST_LIMB	O
(	O
1	int
)	O
<<	O
(	O
lindex	int
%	O
GMP_LIMB_BITS	int
)	O
;	O
for	O
(	O
;	O
lindex	long
<=	O
bits	int
;	O
lindex	long
+=	O
step	pointer
)	O
{	O
bit_array	array
[	O
lindex	int
/	O
GMP_LIMB_BITS	int
]	O
|=	O
lmask	int
;	O
lmask	int
=	O
lmask	int
<<	O
maskrot	int
|	O
lmask	int
>>	O
(	O
GMP_LIMB_BITS	int
-	O
maskrot	int
)	O
;	O
}	O
;	O
lindex	long
=	O
__i	long
*	O
(	O
__i	int
*	O
3	int
+	O
6	int
)	O
+	O
(	O
__i	int
&	O
1	int
)	O
;	O
if	O
(	O
lindex	long
>	O
bits	int
+	O
offset	long
)	O
continue	O
;	O
if	O
(	O
lindex	long
<	O
offset	long
)	O
lindex	long
+=	O
step	long
*	O
(	O
(	O
offset	long
-	O
lindex	int
-	O
1	int
)	O
/	O
step	pointer
+	O
1	int
)	O
;	O
lindex	long
-=	O
offset	long
;	O
lmask	long
=	O
CNST_LIMB	O
(	O
1	int
)	O
<<	O
(	O
lindex	int
%	O
GMP_LIMB_BITS	int
)	O
;	O
for	O
(	O
;	O
lindex	long
<=	O
bits	int
;	O
lindex	long
+=	O
step	pointer
)	O
{	O
bit_array	array
[	O
lindex	int
/	O
GMP_LIMB_BITS	int
]	O
|=	O
lmask	int
;	O
lmask	int
=	O
lmask	int
<<	O
maskrot	int
|	O
lmask	int
>>	O
(	O
GMP_LIMB_BITS	int
-	O
maskrot	int
)	O
;	O
}	O
;	O
}	O
LOOP_ON_SIEVE_END	int
;	O
}	O
mp_limb_t	long
gmp_primesieve	O
(	O
mp_ptr	pointer
bit_array	pointer
,	O
mp_limb_t	long
n	long
)	O
{	O
mp_size_t	long
size	long
;	O
mp_limb_t	long
bits	long
;	O
ASSERT	O
(	O
n	long
>	O
4	int
)	O
;	O
bits	int
=	O
n_to_bit	O
(	O
n	long
)	O
;	O
size	long
=	O
bits	int
/	O
GMP_LIMB_BITS	int
+	O
1	int
;	O
if	O
(	O
size	long
>	O
BLOCK_SIZE	long
*	O
2	int
)	O
{	O
mp_size_t	long
off	long
;	O
off	long
=	O
BLOCK_SIZE	int
+	O
(	O
size	long
%	O
BLOCK_SIZE	int
)	O
;	O
first_block_primesieve	function
(	O
bit_array	pointer
,	O
id_to_n	function
(	O
off	long
*	O
GMP_LIMB_BITS	int
)	O
)	O
;	O
for	O
(	O
;	O
off	long
<	O
size	long
;	O
off	long
+=	O
BLOCK_SIZE	int
)	O
block_resieve	function
(	O
bit_array	pointer
+	O
off	long
,	O
BLOCK_SIZE	pointer
,	O
off	long
*	O
GMP_LIMB_BITS	int
,	O
bit_array	int
,	O
off	long
*	O
GMP_LIMB_BITS	int
-	O
1	int
)	O
;	O
}	O
else	O
{	O
first_block_primesieve	function
(	O
bit_array	pointer
,	O
n	long
)	O
;	O
}	O
if	O
(	O
(	O
bits	int
+	O
1	int
)	O
%	O
GMP_LIMB_BITS	int
!=	O
0	int
)	O
bit_array	pointer
[	O
size	long
-	O
1	int
]	O
|=	O
MP_LIMB_T_MAX	O
<<	O
(	O
(	O
bits	int
+	O
1	int
)	O
%	O
GMP_LIMB_BITS	int
)	O
;	O
return	O
size	long
*	O
GMP_LIMB_BITS	int
-	O
mpn_popcount	O
(	O
bit_array	pointer
,	O
size	long
)	O
;	O
}	O
int	O
__gmp_asprintf_memory	function
(	O
struct	O
gmp_asprintf_t	struct
*	O
d	pointer
,	O
const	O
char	O
*	O
str	pointer
,	O
size_t	long
len	long
)	O
{	O
GMP_ASPRINTF_T_NEED	O
(	O
d	pointer
,	O
len	long
)	O
;	O
memcpy	function
(	O
d	pointer
->	O
buf	pointer
+	O
d	long
->	O
size	long
,	O
str	pointer
,	O
len	long
)	O
;	O
d	long
->	O
size	long
+=	O
len	long
;	O
return	O
len	int
;	O
}	O
int	O
__gmp_asprintf_reps	function
(	O
struct	O
gmp_asprintf_t	struct
*	O
d	pointer
,	O
int	O
c	int
,	O
int	O
reps	pointer
)	O
{	O
GMP_ASPRINTF_T_NEED	O
(	O
d	long
,	O
reps	pointer
)	O
;	O
memset	function
(	O
d	long
->	O
buf	pointer
+	O
d	long
->	O
size	long
,	O
c	int
,	O
reps	pointer
)	O
;	O
d	long
->	O
size	long
+=	O
reps	pointer
;	O
return	O
reps	pointer
;	O
}	O
int	O
__gmp_asprintf_final	function
(	O
struct	O
gmp_asprintf_t	struct
*	O
d	pointer
)	O
{	O
char	O
*	O
buf	pointer
=	O
d	long
->	O
buf	pointer
;	O
ASSERT	O
(	O
d	long
->	O
alloc	long
>=	O
d	long
->	O
size	long
+	O
1	int
)	O
;	O
buf	pointer
[	O
d	long
->	O
size	long
]	O
=	O
'\0'	O
;	O
__GMP_REALLOCATE_FUNC_MAYBE_TYPE	O
(	O
buf	pointer
,	O
d	long
->	O
alloc	long
,	O
d	long
->	O
size	long
+	O
1	int
,	O
char	O
)	O
;	O
*	O
d	pointer
->	O
result	pointer
=	O
buf	pointer
;	O
return	O
0	int
;	O
}	O
static	O
void	O
mangle_seed	O
(	O
mpz_ptr	pointer
r	pointer
,	O
mpz_srcptr	pointer
b_orig	pointer
)	O
{	O
mpz_t	array
t	array
,	O
b	array
;	O
unsigned	O
long	O
e	long
=	O
0x40118124	int
;	O
unsigned	O
long	O
bit	long
=	O
0x20000000	int
;	O
mpz_init	O
(	O
t	array
)	O
;	O
mpz_init_set	O
(	O
b	array
,	O
b_orig	pointer
)	O
;	O
mpz_set	O
(	O
r	pointer
,	O
b	int
)	O
;	O
do	O
{	O
mpz_mul	O
(	O
r	pointer
,	O
r	pointer
,	O
r	pointer
)	O
;	O
reduce	int
:	O
for	O
(	O
;	O
;	O
)	O
{	O
mpz_tdiv_q_2exp	function
(	O
t	int
,	O
r	pointer
,	O
19937L	int
)	O
;	O
if	O
(	O
mpz_sgn	function
(	O
t	pointer
)	O
==	O
0	int
)	O
break	O
;	O
mpz_tdiv_r_2exp	O
(	O
r	pointer
,	O
r	pointer
,	O
19937L	int
)	O
;	O
mpz_addmul_ui	O
(	O
r	pointer
,	O
t	pointer
,	O
20023L	pointer
)	O
;	O
}	O
if	O
(	O
(	O
e	int
&	O
bit	int
)	O
!=	O
0	int
)	O
{	O
e	int
&=	O
~	O
bit	int
;	O
mpz_mul	O
(	O
r	pointer
,	O
r	pointer
,	O
b	int
)	O
;	O
goto	O
reduce	int
;	O
}	O
bit	int
>>=	O
1	int
;	O
}	O
while	O
(	O
bit	int
!=	O
0	int
)	O
;	O
mpz_clear	O
(	O
t	int
)	O
;	O
mpz_clear	O
(	O
b	int
)	O
;	O
}	O
static	O
void	O
randseed_mt	O
(	O
gmp_randstate_t	array
rstate	array
,	O
mpz_srcptr	pointer
seed	pointer
)	O
{	O
int	O
i	int
;	O
size_t	long
cnt	int
;	O
gmp_rand_mt_struct	struct
*	O
p	pointer
;	O
mpz_t	array
mod	array
;	O
mpz_t	array
seed1	array
;	O
p	pointer
=	O
(	O
gmp_rand_mt_struct	struct
*	O
)	O
RNG_STATE	function
(	O
rstate	array
)	O
;	O
mpz_init	O
(	O
mod	pointer
)	O
;	O
mpz_init	O
(	O
seed1	pointer
)	O
;	O
mpz_set_ui	O
(	O
mod	pointer
,	O
0L	int
)	O
;	O
mpz_setbit	O
(	O
mod	pointer
,	O
19937L	pointer
)	O
;	O
mpz_sub_ui	O
(	O
mod	pointer
,	O
mod	pointer
,	O
20027L	pointer
)	O
;	O
mpz_mod	function
(	O
seed1	pointer
,	O
seed	long
,	O
mod	int
)	O
;	O
mpz_add_ui	O
(	O
seed1	pointer
,	O
seed1	pointer
,	O
2L	int
)	O
;	O
mangle_seed	function
(	O
seed1	pointer
,	O
seed1	pointer
)	O
;	O
p	pointer
->	O
mt	array
[	O
0	int
]	O
=	O
(	O
mpz_tstbit	O
(	O
seed1	pointer
,	O
19936L	pointer
)	O
!=	O
0	int
)	O
?	O
0x80000000	int
:	O
0	int
;	O
mpz_clrbit	function
(	O
seed1	pointer
,	O
19936L	int
)	O
;	O
mpz_export	O
(	O
&	O
p	pointer
->	O
mt	array
[	O
1	int
]	O
,	O
&	O
cnt	int
,	O
-	O
1	int
,	O
sizeof	O
(	O
p	pointer
->	O
mt	array
[	O
1	int
]	O
)	O
,	O
0	int
,	O
8	int
*	O
sizeof	O
(	O
p	pointer
->	O
mt	array
[	O
1	int
]	O
)	O
-	O
32	int
,	O
seed1	pointer
)	O
;	O
cnt	int
++	O
;	O
ASSERT	O
(	O
cnt	int
<=	O
N	int
)	O
;	O
while	O
(	O
cnt	int
<	O
N	int
)	O
p	pointer
->	O
mt	array
[	O
cnt	int
++	O
]	O
=	O
0	int
;	O
mpz_clear	O
(	O
mod	int
)	O
;	O
mpz_clear	O
(	O
seed1	pointer
)	O
;	O
if	O
(	O
WARM_UP	int
!=	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
WARM_UP	long
/	O
N	int
;	O
i	int
++	O
)	O
__gmp_mt_recalc_buffer	function
(	O
p	pointer
->	O
mt	array
)	O
;	O
p	pointer
->	O
mti	int
=	O
WARM_UP	long
%	O
N	int
;	O
}	O
static	O
const	O
gmp_randfnptr_t	struct
Mersenne_Twister_Generator	struct
=	O
{	O
randseed_mt	pointer
,	O
__gmp_randget_mt	function
,	O
__gmp_randclear_mt	function
,	O
__gmp_randiset_mt	function
}	O
;	O
void	O
gmp_randinit_mt	O
(	O
gmp_randstate_t	array
rstate	array
)	O
{	O
__gmp_randinit_mt_noseed	function
(	O
rstate	array
)	O
;	O
RNG_FNPTR	O
(	O
rstate	array
)	O
=	O
(	O
void	O
*	O
)	O
&	O
Mersenne_Twister_Generator	pointer
;	O
}	O
char	O
__gmp_rands_initialized	int
=	O
0	int
;	O
gmp_randstate_t	array
__gmp_rands	array
;	O
int	O
gmp_fscanf	function
(	O
FILE	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
ret	int
;	O
va_start	O
(	O
ap	pointer
,	O
fmt	pointer
)	O
;	O
ret	int
=	O
__gmp_doscan	function
(	O
&	O
__gmp_fscanf_funs	struct
,	O
fp	pointer
,	O
fmt	pointer
,	O
ap	pointer
)	O
;	O
va_end	O
(	O
ap	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
gmp_vfscanf	function
(	O
FILE	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
return	O
__gmp_doscan	function
(	O
&	O
__gmp_fscanf_funs	struct
,	O
fp	pointer
,	O
fmt	pointer
,	O
ap	pointer
)	O
;	O
}	O
static	O
char	O
const	O
ao_ver_string	array
[	O
]	O
=	O
"42:1:17\n"	pointer
;	O
static	O
void	O
clear_ungetc_buffer_preserving_position	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
if	O
(	O
fp	pointer
->	O
_flags	int
&	O
_IO_IN_BACKUP	int
)	O
fseeko	function
(	O
fp	pointer
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
}	O
int	O
rpl_fflush	function
(	O
FILE	struct
*	O
stream	pointer
)	O
{	O
if	O
(	O
stream	pointer
==	O
NULL	O
||	O
!	O
freading	O
(	O
stream	pointer
)	O
)	O
return	O
fflush	function
(	O
stream	pointer
)	O
;	O
clear_ungetc_buffer_preserving_position	function
(	O
stream	pointer
)	O
;	O
return	O
fflush	function
(	O
stream	pointer
)	O
;	O
}	O
int	O
FG_COLOR	array
[	O
color_components	int
]	O
;	O
int	O
BG_COLOR	array
[	O
color_components	int
]	O
;	O
void	O
setScreenColors	function
(	O
int	O
FG	int
,	O
int	O
BG	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"\x1b[%d;%dm"	pointer
,	O
FG	int
,	O
BG	int
)	O
;	O
}	O
void	O
setScreenColorsI	function
(	O
int	O
colorIndex	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"\x1b[%d;%dm"	pointer
,	O
FG_COLOR	array
[	O
colorIndex	int
]	O
,	O
BG_COLOR	array
[	O
colorIndex	int
]	O
)	O
;	O
}	O
void	O
getScreenSize	function
(	O
)	O
{	O
struct	O
winsize	struct
w	int
;	O
ioctl	function
(	O
0	int
,	O
TIOCGWINSZ	int
,	O
&	O
w	int
)	O
;	O
SCREEN_H	int
=	O
w	O
.	O
ws_row	short
;	O
SCREEN_W	int
=	O
w	int
.	O
ws_col	short
;	O
}	O
void	O
clearScreenC	function
(	O
int	O
FG	int
,	O
int	O
BG	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[2J"	pointer
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[%d;%dm"	pointer
,	O
FG	int
,	O
BG	int
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[3J\e[1;1H"	pointer
)	O
;	O
}	O
void	O
clearScreen	function
(	O
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[2J"	pointer
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"\x1b[37;4m"	pointer
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[3J\e[1;1H"	pointer
)	O
;	O
}	O
void	O
locate	function
(	O
int	O
row	int
,	O
int	O
col	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"\e[%d;%dH"	pointer
,	O
row	int
,	O
col	int
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
void	O
getScreenColors	function
(	O
)	O
{	O
screen_colors	array
[	O
0	int
]	O
=	O
"BLACK"	pointer
;	O
screen_colors	array
[	O
1	int
]	O
=	O
"RED"	pointer
;	O
screen_colors	array
[	O
2	int
]	O
=	O
"GREEN"	pointer
;	O
screen_colors	array
[	O
3	int
]	O
=	O
"BROWN"	pointer
;	O
screen_colors	array
[	O
4	int
]	O
=	O
"BLUE"	pointer
;	O
screen_colors	array
[	O
5	int
]	O
=	O
"MAGENTA"	pointer
;	O
screen_colors	array
[	O
6	int
]	O
=	O
"CYAN"	pointer
;	O
screen_colors	array
[	O
7	int
]	O
=	O
"WHITE"	pointer
;	O
screen_colors	array
[	O
8	int
]	O
=	O
"BGBLACK"	pointer
;	O
screen_colors	array
[	O
9	int
]	O
=	O
"BGRED"	pointer
;	O
screen_colors	array
[	O
10	int
]	O
=	O
"BGGREEN"	pointer
;	O
screen_colors	array
[	O
11	int
]	O
=	O
"BGBROWN"	pointer
;	O
screen_colors	array
[	O
12	int
]	O
=	O
"BGBLUE"	pointer
;	O
screen_colors	array
[	O
13	int
]	O
=	O
"BGMAGENTA"	pointer
;	O
screen_colors	array
[	O
14	int
]	O
=	O
"BGCYAN"	pointer
;	O
screen_colors	array
[	O
15	int
]	O
=	O
"BGWHITE"	pointer
;	O
}	O
void	O
loadDefaultColors	function
(	O
)	O
{	O
FG_COLOR	array
[	O
COLOR_WINDOW	int
]	O
=	O
37	int
;	O
FG_COLOR	array
[	O
COLOR_HIGHLIGHT_TEXT	int
]	O
=	O
34	int
;	O
FG_COLOR	array
[	O
COLOR_MENU_BAR	int
]	O
=	O
34	int
;	O
FG_COLOR	array
[	O
COLOR_STATUS_BAR	int
]	O
=	O
34	int
;	O
FG_COLOR	array
[	O
COLOR_BUTTONS	int
]	O
=	O
37	int
;	O
FG_COLOR	array
[	O
COLOR_HBUTTONS	int
]	O
=	O
32	int
;	O
BG_COLOR	array
[	O
COLOR_WINDOW	int
]	O
=	O
49	int
;	O
BG_COLOR	array
[	O
COLOR_HIGHLIGHT_TEXT	int
]	O
=	O
47	int
;	O
BG_COLOR	array
[	O
COLOR_MENU_BAR	int
]	O
=	O
47	int
;	O
BG_COLOR	array
[	O
COLOR_STATUS_BAR	int
]	O
=	O
47	int
;	O
BG_COLOR	array
[	O
COLOR_BUTTONS	int
]	O
=	O
41	int
;	O
BG_COLOR	array
[	O
COLOR_HBUTTONS	int
]	O
=	O
41	int
;	O
}	O
void	O
showCursor	function
(	O
)	O
{	O
printf	function
(	O
"\e[?25h"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
void	O
hideCursor	function
(	O
)	O
{	O
printf	function
(	O
"\e[?25l"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
void	O
reset_attribs	function
(	O
)	O
{	O
printf	function
(	O
"\x1b[0m"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
int	O
checkCutOrCopyDir	function
(	O
int	O
i	int
)	O
{	O
if	O
(	O
numCutDirs	int
==	O
0	int
&&	O
numCopyDirs	int
==	O
0	int
)	O
return	O
0	int
;	O
int	O
j	int
;	O
char	O
str	pointer
[	O
dirs	array
[	O
i	int
]	O
->	O
namelen	long
+	O
cwdlen	int
+	O
2	int
]	O
;	O
strcpy	function
(	O
str	pointer
,	O
cwd	pointer
)	O
;	O
strcat	function
(	O
str	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
str	pointer
,	O
dirs	array
[	O
i	int
]	O
->	O
name	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numCutDirs	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
cutDirs	array
[	O
j	int
]	O
,	O
str	pointer
)	O
==	O
0	int
)	O
return	O
1	int
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numCopyDirs	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
copyDirs	array
[	O
j	int
]	O
,	O
str	pointer
)	O
==	O
0	int
)	O
return	O
2	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
checkCutOrCopyFile	function
(	O
int	O
i	int
)	O
{	O
if	O
(	O
numCutFiles	int
==	O
0	int
&&	O
numCopyFiles	int
==	O
0	int
)	O
return	O
0	int
;	O
int	O
j	int
;	O
char	O
str	pointer
[	O
files	array
[	O
i	int
]	O
->	O
namelen	long
+	O
cwdlen	int
+	O
2	int
]	O
;	O
strcpy	function
(	O
str	pointer
,	O
cwd	pointer
)	O
;	O
strcat	function
(	O
str	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
str	pointer
,	O
files	array
[	O
i	int
]	O
->	O
name	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numCutFiles	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
cutFiles	array
[	O
j	int
]	O
,	O
str	pointer
)	O
==	O
0	int
)	O
return	O
1	int
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numCopyFiles	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
copyFiles	array
[	O
j	int
]	O
,	O
str	pointer
)	O
==	O
0	int
)	O
return	O
2	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
__removeCutCopyItem	function
(	O
struct	O
dirstruct	struct
*	O
*	O
fileDirItems	pointer
,	O
int	O
fileDirIndex	int
,	O
char	O
*	O
*	O
cutCopyItems	pointer
,	O
int	O
*	O
cutCopyItemCount	pointer
)	O
{	O
if	O
(	O
*	O
cutCopyItemCount	pointer
==	O
0	int
)	O
return	O
;	O
int	O
j	int
,	O
k	int
;	O
char	O
*	O
str	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
fileDirItems	array
[	O
fileDirIndex	int
]	O
->	O
namelen	long
+	O
cwdlen	int
+	O
2	int
)	O
;	O
if	O
(	O
!	O
str	pointer
)	O
{	O
msgBoxH	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
strcpy	function
(	O
str	pointer
,	O
cwd	pointer
)	O
;	O
strcat	function
(	O
str	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
str	pointer
,	O
fileDirItems	array
[	O
fileDirIndex	int
]	O
->	O
name	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
*	O
cutCopyItemCount	pointer
;	O
j	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
str	pointer
,	O
cutCopyItems	array
[	O
j	int
]	O
)	O
==	O
0	int
)	O
{	O
free	function
(	O
cutCopyItems	array
[	O
j	int
]	O
)	O
;	O
for	O
(	O
k	int
=	O
j	int
;	O
k	int
<	O
(	O
*	O
cutCopyItemCount	pointer
)	O
-	O
1	int
;	O
k	int
++	O
)	O
{	O
cutCopyItems	array
[	O
k	int
]	O
=	O
cutCopyItems	array
[	O
k	int
+	O
1	int
]	O
;	O
}	O
(	O
*	O
cutCopyItemCount	pointer
)	O
--	O
;	O
cutCopyItems	array
[	O
k	int
]	O
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
free	function
(	O
str	pointer
)	O
;	O
}	O
void	O
removeCutFile	function
(	O
int	O
i	int
)	O
{	O
__removeCutCopyItem	function
(	O
files	array
,	O
i	int
,	O
cutFiles	int
,	O
&	O
numCutFiles	O
)	O
;	O
}	O
void	O
removeCopyFile	function
(	O
int	O
i	int
)	O
{	O
__removeCutCopyItem	function
(	O
files	array
,	O
i	int
,	O
copyFiles	int
,	O
&	O
numCopyFiles	int
)	O
;	O
}	O
void	O
removeCutDir	function
(	O
int	O
i	int
)	O
{	O
__removeCutCopyItem	function
(	O
dirs	pointer
,	O
i	int
,	O
cutDirs	int
,	O
&	O
numCutDirs	int
)	O
;	O
}	O
void	O
removeCopyDir	function
(	O
int	O
i	int
)	O
{	O
__removeCutCopyItem	function
(	O
dirs	pointer
,	O
i	int
,	O
copyDirs	int
,	O
&	O
numCopyDirs	int
)	O
;	O
}	O
void	O
__saveCutCopyItem	function
(	O
struct	O
dirstruct	struct
*	O
*	O
fileDirItems	pointer
,	O
int	O
fileDirIndex	int
,	O
char	O
*	O
*	O
cutCopyItems	pointer
,	O
int	O
*	O
cutCopyItemCount	pointer
)	O
{	O
int	O
k	int
=	O
*	O
cutCopyItemCount	pointer
;	O
if	O
(	O
k	int
>=	O
MAX_CUT_COPY	int
)	O
{	O
msgBoxH	function
(	O
"Unable to perform operation.\nClipboard is full."	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
cutCopyItems	pointer
[	O
k	int
]	O
)	O
free	function
(	O
cutCopyItems	array
[	O
k	int
]	O
)	O
;	O
char	O
*	O
s	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
fileDirItems	array
[	O
fileDirIndex	int
]	O
->	O
namelen	long
+	O
cwdlen	int
+	O
2	int
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
{	O
msgBoxH	function
(	O
"Insufficient memory"	pointer
,	O
OK	int
,	O
ERROR	int
)	O
;	O
return	O
;	O
}	O
strcpy	function
(	O
s	pointer
,	O
cwd	pointer
)	O
;	O
strcat	function
(	O
s	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
s	pointer
,	O
fileDirItems	array
[	O
fileDirIndex	int
]	O
->	O
name	pointer
)	O
;	O
cutCopyItems	array
[	O
k	int
]	O
=	O
s	pointer
;	O
(	O
*	O
cutCopyItemCount	pointer
)	O
++	O
;	O
}	O
void	O
saveCutFile	function
(	O
int	O
i	int
)	O
{	O
__saveCutCopyItem	function
(	O
files	array
,	O
i	int
,	O
cutFiles	int
,	O
&	O
numCutFiles	int
)	O
;	O
}	O
void	O
saveCopyFile	function
(	O
int	O
i	int
)	O
{	O
__saveCutCopyItem	function
(	O
files	array
,	O
i	int
,	O
copyFiles	int
,	O
&	O
numCopyFiles	int
)	O
;	O
}	O
void	O
saveCutDir	function
(	O
int	O
i	int
)	O
{	O
__saveCutCopyItem	function
(	O
dirs	pointer
,	O
i	int
,	O
cutDirs	int
,	O
&	O
numCutDirs	int
)	O
;	O
}	O
void	O
saveCopyDir	function
(	O
int	O
i	int
)	O
{	O
__saveCutCopyItem	function
(	O
dirs	pointer
,	O
i	int
,	O
copyDirs	int
,	O
&	O
numCopyDirs	int
)	O
;	O
}	O
ESint32	int
EDMAPROC	O
EDMA_CIDFParseU32	function
(	O
OBJID	int
obj	int
,	O
CLASSID	long
idc	int
)	O
{	O
CIF_CLASS	struct
*	O
the_class	pointer
;	O
EChar	char
fn	pointer
[	O
2048	int
]	O
;	O
EChar	char
namespace	array
[	O
1024	int
]	O
;	O
EPChar	pointer
path	pointer
;	O
EChar	char
aux	array
[	O
1024	int
]	O
,	O
sig	pointer
[	O
1024	int
]	O
,	O
*	O
asig	pointer
;	O
ESint32	int
i	int
,	O
j	int
,	O
repo_type	int
;	O
path	pointer
=	O
edma_get_class_repo_dir	function
(	O
idc	int
)	O
;	O
edma_get_class_name	function
(	O
idc	int
,	O
aux	array
)	O
;	O
if	O
(	O
(	O
repo_type	int
=	O
edma_get_class_repo_type	function
(	O
idc	int
)	O
)	O
==	O
0	int
)	O
{	O
edma_get_class_namespace	function
(	O
idc	int
,	O
namespace	pointer
)	O
;	O
sprintf	function
(	O
fn	pointer
,	O
"%s/share/edma/idf/%s/%s.cidf"	pointer
,	O
path	pointer
,	O
namespace	pointer
,	O
aux	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
rn	pointer
=	O
edma_get_class_repo_name	function
(	O
idc	long
)	O
;	O
edma_get_class_namespace	function
(	O
idc	long
,	O
namespace	pointer
)	O
;	O
sprintf	function
(	O
fn	pointer
,	O
"%s/%s/idf/%s/%s.cidf"	pointer
,	O
path	pointer
,	O
rn	long
,	O
namespace	pointer
,	O
aux	pointer
)	O
;	O
}	O
edma_printf_obj	function
(	O
obj	pointer
,	O
"Parsing Class %d:'%s': Repo: %d. Parser Object: %d"	pointer
,	O
idc	int
,	O
aux	pointer
,	O
repo_type	pointer
,	O
obj	pointer
)	O
;	O
edma_printf_obj	function
(	O
obj	pointer
,	O
"Using IDF file : %s"	pointer
,	O
fn	pointer
)	O
;	O
the_class	pointer
=	O
cidf_parse	function
(	O
fn	pointer
)	O
;	O
edma_idf_set_def	function
(	O
idc	int
,	O
the_class	pointer
->	O
n_prop	pointer
,	O
the_class	pointer
->	O
n_met	pointer
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	pointer
->	O
n_prop	int
;	O
i	int
++	O
)	O
{	O
edma_idf_set_prop	function
(	O
idc	int
,	O
i	int
,	O
the_class	pointer
->	O
prop	pointer
[	O
i	int
]	O
->	O
name	pointer
,	O
the_class	pointer
->	O
prop	pointer
[	O
i	int
]	O
->	O
type	int
,	O
the_class	pointer
->	O
prop	pointer
[	O
i	int
]	O
->	O
access	int
,	O
0	int
,	O
NULL	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	pointer
->	O
n_met	int
;	O
i	int
++	O
)	O
{	O
memset	function
(	O
sig	int
,	O
0	int
,	O
1024	int
)	O
;	O
asig	pointer
=	O
sig	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
the_class	pointer
->	O
met	array
[	O
i	int
]	O
->	O
n_param	int
;	O
j	int
++	O
)	O
{	O
EUint32	long
type_id	long
;	O
EChar	char
type_sig	array
[	O
256	int
]	O
;	O
type_id	int
=	O
edma_get_type_id	function
(	O
the_class	pointer
->	O
met	array
[	O
i	int
]	O
->	O
param	pointer
[	O
j	int
]	O
->	O
type	pointer
)	O
;	O
memset	function
(	O
type_sig	pointer
,	O
0	int
,	O
256	int
)	O
;	O
edma_get_type_sig	function
(	O
type_id	pointer
,	O
type_sig	pointer
)	O
;	O
asig	int
+=	O
sprintf	function
(	O
asig	pointer
,	O
"%s"	pointer
,	O
type_sig	pointer
)	O
;	O
}	O
{	O
EUint32	long
type_id	long
;	O
EChar	char
type_sig	array
[	O
256	int
]	O
;	O
type_id	int
=	O
edma_get_type_id	function
(	O
the_class	pointer
->	O
met	array
[	O
i	int
]	O
->	O
rtype	pointer
)	O
;	O
memset	function
(	O
type_sig	pointer
,	O
0	int
,	O
256	int
)	O
;	O
edma_get_type_sig	function
(	O
type_id	pointer
,	O
type_sig	pointer
)	O
;	O
asig	int
+=	O
sprintf	function
(	O
asig	pointer
,	O
"r%s"	pointer
,	O
type_sig	pointer
)	O
;	O
}	O
printf	function
(	O
"Generated signature is: '%s'\n"	pointer
,	O
sig	int
)	O
;	O
if	O
(	O
!	O
repo_type	pointer
)	O
edma_idf_set_met	function
(	O
idc	int
,	O
i	int
,	O
the_class	pointer
->	O
met	array
[	O
i	int
]	O
->	O
name	pointer
,	O
sig	int
,	O
the_class	pointer
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
1	int
]	O
,	O
the_class	pointer
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
0	int
]	O
,	O
the_class	pointer
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
2	int
]	O
)	O
;	O
else	O
edma_idf_set_met	function
(	O
idc	long
,	O
i	long
,	O
the_class	pointer
->	O
met	array
[	O
i	int
]	O
->	O
name	pointer
,	O
""	pointer
,	O
the_class	pointer
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
1	int
]	O
,	O
the_class	pointer
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
0	int
]	O
,	O
the_class	pointer
->	O
met	array
[	O
i	int
]	O
->	O
flags	array
[	O
2	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
the_class	pointer
->	O
n_sc	int
;	O
i	int
++	O
)	O
{	O
edma_add_local_class_superclass_by_name	function
(	O
idc	long
,	O
the_class	pointer
->	O
sc	pointer
[	O
i	int
]	O
->	O
name	pointer
,	O
the_class	pointer
->	O
sc	pointer
[	O
i	int
]	O
->	O
ap	pointer
,	O
the_class	pointer
->	O
sc	pointer
[	O
i	int
]	O
->	O
ap1	O
)	O
;	O
}	O
edma_printf_obj	function
(	O
obj	int
,	O
"Registering class %d:%s:%s"	pointer
,	O
idc	int
,	O
the_class	pointer
->	O
name	pointer
,	O
aux	int
)	O
;	O
if	O
(	O
repo_type	int
)	O
edma_idf_set_class_id1	function
(	O
idc	int
)	O
;	O
else	O
edma_idf_set_class_id	function
(	O
idc	long
)	O
;	O
cidf_free_data	function
(	O
the_class	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMA_CIDF_class_factory	function
(	O
)	O
{	O
CLASSID	int
cid	int
;	O
cid	int
=	O
edma_idf_get_free_class_id	function
(	O
EDMA_LOCAL_CLASS	int
)	O
;	O
edma_idf_set_class_name	function
(	O
cid	int
,	O
"EDMA_CIDF"	pointer
)	O
;	O
edma_idf_set_class_namespace	function
(	O
cid	int
,	O
""	pointer
)	O
;	O
edma_idf_set_class_version	function
(	O
cid	int
,	O
0	int
,	O
0	int
)	O
;	O
edma_add_local_class_method	function
(	O
cid	int
,	O
"Parse"	pointer
,	O
"U32"	pointer
,	O
(	O
PPROC	pointer
)	O
EDMA_CIDFParseU32	function
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edma_idf_set_class_id	function
(	O
cid	int
)	O
;	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
{	O
EPChar	pointer
script_code	pointer
;	O
OBJID	int
interpreter	int
;	O
EDMAT_BUFFER	struct
private	struct
;	O
}	O
DtEDMA_SCRIPT	struct
;	O
ESint32	int
EDMAPROC	O
EDMA_SCRIPTset_scriptZrS32	function
(	O
OBJID	int
IdObj	int
,	O
EPChar	pointer
script_name	pointer
)	O
{	O
DtEDMA_SCRIPT	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtEDMA_SCRIPT	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
if	O
(	O
strstr	function
(	O
script_name	int
,	O
".py"	pointer
)	O
)	O
{	O
edma_met3	function
(	O
IdObj	int
,	O
"ANNA_PYTHON_INTERP@INTERPRETER<Initialize"	pointer
)	O
;	O
edma_met3	function
(	O
IdObj	int
,	O
"Run_Script"	pointer
,	O
script_name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
EDMA_SCRIPTupdate_objectOOrS32	function
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
newid	int
,	O
OBJID	int
oldid	int
)	O
{	O
DtEDMA_SCRIPT	struct
*	O
m	pointer
;	O
EChar	char
cmd	array
[	O
1024	int
]	O
;	O
m	pointer
=	O
(	O
DtEDMA_SCRIPT	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
sprintf	function
(	O
cmd	int
,	O
"update (%ld,%ld);"	pointer
,	O
newid	pointer
,	O
oldid	pointer
)	O
;	O
edma_met3	function
(	O
IdObj	int
,	O
"Run_SimpleString"	pointer
,	O
cmd	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
EDMA_SCRIPTrunrS32	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtEDMA_SCRIPT	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtEDMA_SCRIPT	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
EDMA_SCRIPTborn	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtEDMA_SCRIPT	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtEDMA_SCRIPT	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
m	pointer
->	O
script_code	pointer
=	O
NULL	O
;	O
m	pointer
->	O
interpreter	int
=	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
EDMA_SCRIPTrip	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtEDMA_SCRIPT	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtEDMA_SCRIPT	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Ddestroying Object..."	pointer
)	O
;	O
edma_met3	function
(	O
IdObj	int
,	O
"Finalize"	pointer
)	O
;	O
if	O
(	O
m	pointer
->	O
interpreter	int
!=	O
-	O
1	int
)	O
edma_free_obj	function
(	O
m	pointer
->	O
interpreter	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMA_SCRIPT_class_factory	function
(	O
)	O
{	O
CLASSID	int
cid	int
;	O
cid	int
=	O
edma_idf_get_free_class_id	function
(	O
EDMA_LOCAL_CLASS	int
)	O
;	O
edma_idf_set_class_name	function
(	O
cid	int
,	O
"EDMA_SCRIPT"	pointer
)	O
;	O
edma_idf_set_class_namespace	function
(	O
cid	int
,	O
"system"	pointer
)	O
;	O
edma_idf_set_class_version	function
(	O
cid	int
,	O
0	int
,	O
0	int
)	O
;	O
edma_add_local_class_property	function
(	O
cid	int
,	O
"script_code"	pointer
,	O
DT_EZSTRING	int
,	O
E_L	int
,	O
0	int
)	O
;	O
edma_add_local_class_property	function
(	O
cid	int
,	O
"interpreter"	pointer
,	O
DT_EOBJECT	int
,	O
E_L	int
,	O
0	int
)	O
;	O
edma_add_local_class_property	function
(	O
cid	int
,	O
"private"	pointer
,	O
DT_EBUFFER	int
,	O
E_L	int
,	O
0	int
)	O
;	O
edma_add_local_class_method	function
(	O
cid	int
,	O
"set_script"	pointer
,	O
"ZrS32"	pointer
,	O
(	O
PPROC	pointer
)	O
EDMA_SCRIPTset_scriptZrS32	function
,	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
edma_add_local_class_method	function
(	O
cid	int
,	O
"update_object"	pointer
,	O
"OOrS32"	pointer
,	O
(	O
PPROC	pointer
)	O
EDMA_SCRIPTupdate_objectOOrS32	function
,	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
edma_add_local_class_method	function
(	O
cid	int
,	O
"run"	pointer
,	O
"rS32"	pointer
,	O
(	O
PPROC	pointer
)	O
EDMA_SCRIPTrunrS32	function
,	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
edma_add_local_class_method	function
(	O
cid	int
,	O
"born"	pointer
,	O
""	pointer
,	O
(	O
PPROC	pointer
)	O
EDMA_SCRIPTborn	function
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edma_add_local_class_method	function
(	O
cid	int
,	O
"rip"	pointer
,	O
""	pointer
,	O
(	O
PPROC	pointer
)	O
EDMA_SCRIPTrip	function
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edma_idf_set_class_id	function
(	O
cid	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
EDMA_MAKE_BUILDERbuildU32Z	function
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
,	O
EPChar	pointer
fname	pointer
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
EChar	char
temp	array
[	O
1024	int
]	O
;	O
EChar	char
ns	array
[	O
1024	int
]	O
;	O
f	pointer
=	O
fopen	function
(	O
fname	pointer
,	O
"wt"	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Can't Open file %s for writting"	pointer
,	O
fname	pointer
)	O
;	O
return	O
1	int
;	O
}	O
edma_rprop3	function
(	O
id	int
,	O
"ClassName"	pointer
,	O
temp	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"#\n"	pointer
"#   Copyright (C) YEAR\n"	<padding>
"#             by Author\n"	<padding>
"#\n"	<padding>
"#   This program is free software: you can redistribute it and/or modify\n"	<padding>
"#   it under the terms of the GNU General Public License as published by\n"	<padding>
"#   the Free Software Foundation, either version 3 of the License, or\n"	<padding>
"#   (at your option) any later version.\n"	<padding>
"#\n"	<padding>
"#   This program is distributed in the hope that it will be useful,\n"	<padding>
"#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n"	<padding>
"#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"	<padding>
"#   GNU General Public License for more details.\n"	<padding>
"#\n"	<padding>
"#   You should have received a copy of the GNU General Public License\n"	<padding>
"#   along with this program.  If not, see <http://www.gnu.org/licenses/>.\n"	<padding>
"#\n"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"#"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n# Makefile for EDMA class %s"	pointer
,	O
temp	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n# Generated by EDMA_MAKE_BUILDER 0.1"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n#"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\nCC=gcc"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\nCCFLAGS=`edma-config --cflags-class`"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\nLIBS=`edma-config --libs-class` "	pointer
)	O
;	O
edma_rprop3	function
(	O
id	int
,	O
"NameSpace"	pointer
,	O
ns	int
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\nNAMESPACE = %s"	pointer
,	O
ns	long
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\nTARGET_DIR = `edma-config --dir-impl`/edma/${NAMESPACE}"	pointer
"\bIDF_DIR = `edma-config --dir-int`/${NAMESPACE}"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\nlib%s.so: temp.o "	pointer
,	O
temp	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n\t$(CC) -nostartfiles -shared -Wl,-soname,lib%s.so.1 -o $@ temp.o $(LIBS) "	pointer
,	O
temp	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\ntemp.o: %s_imp.c "	pointer
,	O
temp	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n	$(CC)  $(CCFLAGS) $< -o $@ "	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n.PHONY: install"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\ninstall:"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n\tcp lib%s.so `edma-config --dir-impl`"	pointer
,	O
temp	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n\tcp %s.idf `edma-config --dir-int`"	pointer
,	O
temp	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n\tln -s ${TARGET_DIR}/lib%s.so.0.0.0 ${TARGET_DIR}/lib%s.so.0"	pointer
,	O
temp	array
,	O
temp	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n\tln -s ${TARGET_DIR}/lib%s.so.0.0.0 ${TARGET_DIR}/lib%s.so"	pointer
,	O
temp	array
,	O
temp	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n.PHONY: clean"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\nclean:"	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n\trm -f lib%s.so *~ *.o core\n"	pointer
,	O
temp	array
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
fclose	function
(	O
f	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
DATALOGGER_SERVICEserviceOrS23	function
(	O
OBJID	int
IdObj	int
,	O
OBJID	int
id	int
)	O
{	O
EDMAT_BUFFER	struct
rbuf	struct
;	O
ESint32	int
len	int
;	O
edma_buffer_alloc	function
(	O
&	O
rbuf	struct
,	O
1024	int
)	O
;	O
if	O
(	O
(	O
(	O
ESint32	int
)	O
edma_met3	function
(	O
id	int
,	O
"recv"	pointer
,	O
&	O
rbuf	struct
,	O
&	O
len	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"%s"	pointer
,	O
"[ERROR] receviving data"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
printf	function
(	O
"%s"	pointer
,	O
"--------------------------------\n"	pointer
)	O
;	O
printf	function
(	O
"[%ld bytes received]\n"	pointer
,	O
len	int
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
(	O
char	O
*	O
)	O
rbuf	struct
.	O
dat	pointer
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
"--------------------------------\n"	pointer
)	O
;	O
edma_buffer_free	function
(	O
&	O
rbuf	struct
)	O
;	O
return	O
0	int
;	O
}	O
CLASSID	int
EDMAPROC	O
edma_class_register	function
(	O
EDMA_REPO	pointer
repo	int
)	O
{	O
CLASSID	long
class_id	int
;	O
SClass	array
[	O
class_id	int
]	O
->	O
Status	long
=	O
CLASS_DEF	int
;	O
return	O
-	O
1	int
;	O
}	O
ESint32	int
EDMAPROC	O
edma_class_unregister	function
(	O
CLASSID	long
class_id	int
)	O
{	O
if	O
(	O
SClass	array
[	O
class_id	int
]	O
->	O
Status	long
<	O
CLASS_DEF	int
)	O
return	O
-	O
1	int
;	O
SClass	array
[	O
class_id	int
]	O
->	O
Status	int
=	O
CLASS_FREE	int
;	O
return	O
-	O
1	int
;	O
}	O
ESint32	int
EDMAPROC	O
edma_class_load_interface	function
(	O
CLASSID	long
class_id	int
)	O
{	O
if	O
(	O
SClass	array
[	O
class_id	int
]	O
->	O
Status	int
!=	O
CLASS_DEF	int
)	O
return	O
-	O
1	int
;	O
SClass	array
[	O
class_id	int
]	O
->	O
Status	int
=	O
CLASS_ILOADED	int
;	O
ProcMapTable	pointer
[	O
class_id	int
]	O
=	O
CLASS_IMAPPED	int
;	O
return	O
-	O
1	int
;	O
}	O
ESint32	int
EDMAPROC	O
edma_class_unload_interface	function
(	O
CLASSID	long
class_id	int
)	O
{	O
SClass	array
[	O
class_id	int
]	O
->	O
Status	int
=	O
CLASS_DEF	int
;	O
ProcMapTable	pointer
[	O
class_id	int
]	O
=	O
CLASS_DEF	int
;	O
return	O
-	O
1	int
;	O
}	O
ESint32	int
EDMAPROC	O
edma_class_load_implementation	function
(	O
CLASSID	int
class_id	int
)	O
{	O
ProcMapTable	pointer
[	O
class_id	int
]	O
=	O
CLASS_LOADED	int
;	O
return	O
-	O
1	int
;	O
}	O
ESint32	int
EDMAPROC	O
edma_class_unload_implementation	function
(	O
CLASSID	int
class_id	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
ESint32	int
EDMAPROC	O
edma_class_set_int	function
(	O
CLASSID	int
class_id	int
,	O
EDMA_CLASS_INTERFACE	pointer
class_int	pointer
)	O
{	O
return	O
-	O
1	int
;	O
}	O
ESint32	int
EDMAPROC	O
edma_class_set_impl	function
(	O
CLASSID	int
class_id	int
,	O
EDMA_CLASS_IMPLEMENTATION	pointer
class_int	pointer
)	O
{	O
return	O
-	O
1	int
;	O
}	O
typedef	O
struct	O
{	O
FILE	struct
*	O
f	pointer
;	O
EPChar	pointer
p	pointer
;	O
EUint32	long
tam	long
;	O
EChar	char
Name	array
[	O
500	int
]	O
;	O
}	O
INIFILE	pointer
,	O
*	O
PINIFILE	pointer
;	O
PINIFILE	pointer
EDMAPROC	O
edma_open_ini	function
(	O
EPChar	pointer
Name	pointer
)	O
{	O
PINIFILE	long
pini	long
;	O
EUint32	long
tam	long
;	O
if	O
(	O
Name	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_open_ini] Invalid file name"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
pini	long
=	O
(	O
PINIFILE	pointer
)	O
edma_palloc	function
(	O
sizeof	O
(	O
INIFILE	struct
)	O
)	O
;	O
if	O
(	O
pini	pointer
==	O
NULL	O
)	O
{	O
printf	function
(	O
"\nCan't alloc INIFILE struct"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
strncpy	function
(	O
pini	pointer
->	O
Name	pointer
,	O
Name	pointer
,	O
500	int
)	O
;	O
pini	pointer
->	O
f	pointer
=	O
fopen	function
(	O
Name	pointer
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
pini	pointer
->	O
f	pointer
==	O
NULL	O
)	O
{	O
printf	function
(	O
"\n[%s] Can't Open file %s"	pointer
,	O
__FUNCTION__	O
,	O
Name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
fseek	function
(	O
pini	pointer
->	O
f	pointer
,	O
0	int
,	O
SEEK_END	int
)	O
;	O
pini	pointer
->	O
tam	int
=	O
ftell	function
(	O
pini	pointer
->	O
f	pointer
)	O
;	O
pini	pointer
->	O
p	pointer
=	O
(	O
EPChar	pointer
)	O
edma_palloc	function
(	O
pini	pointer
->	O
tam	pointer
)	O
;	O
if	O
(	O
pini	pointer
->	O
p	pointer
==	O
NULL	O
)	O
{	O
printf	function
(	O
"\nCan't alloc %ld bytes for file %s"	pointer
,	O
pini	pointer
->	O
tam	pointer
,	O
Name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
memset	function
(	O
pini	pointer
->	O
p	pointer
,	O
0	int
,	O
pini	pointer
->	O
tam	pointer
)	O
;	O
fseek	function
(	O
pini	pointer
->	O
f	pointer
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
tam	int
=	O
fread	function
(	O
pini	pointer
->	O
p	int
,	O
sizeof	O
(	O
char	O
)	O
,	O
pini	pointer
->	O
tam	pointer
,	O
pini	pointer
->	O
f	pointer
)	O
;	O
fclose	function
(	O
pini	pointer
->	O
f	pointer
)	O
;	O
return	O
pini	int
;	O
}	O
ESint32	int
EDMAPROC	O
edma_close_ini	function
(	O
PINIFILE	pointer
pini	int
)	O
{	O
if	O
(	O
pini	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_close_ini] Invalid file handler"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
edma_pfree	function
(	O
(	O
HMEM	long
)	O
pini	pointer
->	O
p	pointer
,	O
pini	pointer
->	O
p	pointer
)	O
;	O
edma_pfree	function
(	O
(	O
HMEM	long
)	O
pini	pointer
,	O
pini	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_get_ini_int	function
(	O
PINIFILE	pointer
pini	pointer
,	O
EPChar	pointer
Section	pointer
,	O
EPChar	pointer
Val	pointer
,	O
ESint32	int
def	int
)	O
{	O
EPChar	pointer
pi	pointer
;	O
EPChar	pointer
pe	pointer
;	O
EUint32	long
i	long
;	O
if	O
(	O
pini	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_get_ini_int] Invalid file handler"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
Section	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_get_ini_int] Invalid Section"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
Val	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_get_ini_int] Invalid Field"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pi	pointer
=	O
strstr	function
(	O
pini	pointer
->	O
p	pointer
,	O
Section	pointer
)	O
;	O
if	O
(	O
pi	pointer
==	O
NULL	O
)	O
return	O
def	pointer
;	O
pe	pointer
=	O
strchr	function
(	O
pi	pointer
,	O
'['	O
)	O
;	O
if	O
(	O
pe	pointer
!=	O
NULL	O
)	O
*	O
pe	pointer
=	O
0	int
;	O
pi	pointer
=	O
strstr	function
(	O
pi	pointer
,	O
Val	pointer
)	O
;	O
if	O
(	O
pi	pointer
==	O
NULL	O
)	O
{	O
*	O
pe	pointer
=	O
'['	O
;	O
return	O
def	pointer
;	O
}	O
pi	pointer
=	O
strchr	function
(	O
pi	pointer
,	O
'='	O
)	O
;	O
pi	pointer
++	O
;	O
i	long
=	O
atoi	function
(	O
pi	pointer
)	O
;	O
*	O
pe	pointer
=	O
'['	O
;	O
return	O
i	long
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_ini_string	function
(	O
PINIFILE	pointer
pini	pointer
,	O
EPChar	pointer
Section	pointer
,	O
EPChar	pointer
Val	pointer
,	O
EPChar	pointer
def	pointer
,	O
EPChar	pointer
Buffer	pointer
,	O
EUint32	long
size	long
)	O
{	O
EPChar	pointer
pi	pointer
;	O
EPChar	pointer
pe	pointer
,	O
pe1	pointer
;	O
EChar	char
sec	array
[	O
80	int
]	O
;	O
EUint32	long
n	long
;	O
if	O
(	O
pini	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_get_ini_string] Invalid file handler"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
Section	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_get_ini_string] Invalid Section"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
Val	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_get_ini_string] Invalid Field"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
Buffer	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_get_ini_string] Invalid Target buffer"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
memset	function
(	O
Buffer	pointer
,	O
0	int
,	O
size	int
)	O
;	O
snprintf	function
(	O
sec	pointer
,	O
80	int
,	O
"[%s]"	pointer
,	O
Section	pointer
)	O
;	O
pi	pointer
=	O
strstr	function
(	O
pini	pointer
->	O
p	pointer
,	O
sec	pointer
)	O
;	O
if	O
(	O
pi	pointer
==	O
NULL	O
)	O
{	O
return	O
0	int
;	O
}	O
pi	pointer
++	O
;	O
pe	pointer
=	O
strchr	function
(	O
pi	pointer
,	O
'['	O
)	O
;	O
if	O
(	O
pe	pointer
!=	O
NULL	O
)	O
*	O
pe	pointer
=	O
0	int
;	O
pi	pointer
=	O
strstr	function
(	O
pi	pointer
,	O
Val	pointer
)	O
;	O
if	O
(	O
(	O
pi	pointer
==	O
NULL	O
)	O
)	O
{	O
*	O
pe	pointer
=	O
'['	O
;	O
return	O
0	int
;	O
}	O
pi	pointer
=	O
strchr	function
(	O
pi	pointer
,	O
'='	O
)	O
;	O
pe1	pointer
=	O
strchr	function
(	O
pi	pointer
,	O
13	int
)	O
;	O
if	O
(	O
pe1	pointer
==	O
NULL	O
)	O
{	O
pe1	pointer
=	O
strchr	function
(	O
pi	pointer
,	O
10	int
)	O
;	O
if	O
(	O
pe1	pointer
==	O
NULL	O
)	O
{	O
printf	function
(	O
"%s"	pointer
,	O
"[edma_get_ini_string] Can't locate end of line"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
n	int
=	O
pe1	pointer
-	O
pi	pointer
;	O
n	int
--	O
;	O
pi	pointer
++	O
;	O
strncpy	function
(	O
Buffer	pointer
,	O
pi	pointer
,	O
n	int
)	O
;	O
Buffer	pointer
[	O
n	int
]	O
=	O
0	int
;	O
*	O
pe	pointer
=	O
'['	O
;	O
n	int
=	O
strlen	function
(	O
Buffer	pointer
)	O
;	O
return	O
n	int
;	O
}	O
ESint32	int
EDMAPROC	O
edma_clean_ini_string	function
(	O
EPChar	pointer
Buffer	pointer
)	O
{	O
EUint32	long
i	long
;	O
if	O
(	O
Buffer	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_clean_ini_string] Invalid buffer"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
strlen	function
(	O
Buffer	pointer
)	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
Buffer	pointer
[	O
i	long
]	O
==	O
'\\'	O
)	O
Buffer	pointer
[	O
i	long
]	O
=	O
'/'	O
;	O
}	O
return	O
0	int
;	O
}	O
EChar	char
Buffer	array
[	O
1024	int
]	O
;	O
EUint32	long
n_palloc	int
=	O
0	int
;	O
EUint32	long
n_pget	long
=	O
0	int
;	O
EUint32	long
n_pfree	long
=	O
0	int
;	O
EUint32	long
n_prealloc	long
=	O
0	int
;	O
static	O
int	O
_sally	int
=	O
-	O
1	int
;	O
static	O
int	O
initialised	int
=	O
0	int
;	O
int	O
sally_offset	int
=	O
0	int
;	O
int	O
sally_len	int
=	O
0	int
;	O
int	O
_edma_sally_init	function
(	O
)	O
{	O
int	O
len	long
;	O
struct	O
sockaddr_un	struct
remote	struct
;	O
initialised	int
=	O
1	int
;	O
if	O
(	O
_sally	int
>=	O
0	int
)	O
return	O
_sally	int
;	O
if	O
(	O
(	O
_sally	int
=	O
socket	function
(	O
AF_UNIX	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"socket"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
printf	function
(	O
"Trying to connect to EDMA Shared Allocator Agent ..."	pointer
)	O
;	O
remote	struct
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strcpy	function
(	O
remote	struct
.	O
sun_path	array
,	O
SOCK_PATH	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
remote	struct
.	O
sun_path	array
)	O
+	O
sizeof	O
(	O
remote	struct
.	O
sun_family	short
)	O
;	O
if	O
(	O
connect	function
(	O
_sally	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
remote	struct
,	O
len	long
)	O
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"connect"	pointer
)	O
;	O
close	function
(	O
_sally	int
)	O
;	O
_sally	int
=	O
-	O
1	int
;	O
printf	function
(	O
"\n-- Connection failed. Falling back to local shared memory "	pointer
"allocator...\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
printf	function
(	O
" CONNECTED\n"	pointer
)	O
;	O
printf	function
(	O
"++ Using Sally Shared Allocator\n"	pointer
)	O
;	O
return	O
_sally	int
;	O
}	O
key_t	function
_sally_shm_alloc	function
(	O
char	O
*	O
n	long
,	O
int	O
size	int
)	O
{	O
char	O
buffer	array
[	O
1024	int
]	O
;	O
key_t	struct
_the_key	pointer
;	O
int	O
len	int
;	O
len	int
=	O
snprintf	function
(	O
buffer	pointer
,	O
1024	int
,	O
"SALLOC %d %s\n"	int
,	O
size	int
,	O
n	int
)	O
;	O
write	function
(	O
_sally	pointer
,	O
buffer	pointer
,	O
len	int
)	O
;	O
memset	function
(	O
buffer	pointer
,	O
0	int
,	O
1024	int
)	O
;	O
len	int
=	O
read	function
(	O
_sally	pointer
,	O
buffer	pointer
,	O
1024	int
)	O
;	O
sscanf	function
(	O
buffer	pointer
,	O
"+SALLOC %d\n"	pointer
,	O
&	O
_the_key	int
)	O
;	O
return	O
_the_key	int
;	O
}	O
HMEM	long
EDMAPROC	O
edma_salloc	function
(	O
EUint32	long
size	long
,	O
EPChar	pointer
n	long
)	O
{	O
EUint32	long
a	long
,	O
shmflg	long
,	O
f	pointer
;	O
EChar	char
name	array
[	O
EDMA_PATH_LEN	int
]	O
;	O
key_t	O
k	long
;	O
if	O
(	O
!	O
initialised	int
&&	O
_sally	int
<	O
0	int
)	O
{	O
_edma_sally_init	function
(	O
)	O
;	O
}	O
if	O
(	O
_sally	long
>	O
0	int
)	O
{	O
k	long
=	O
_sally_shm_alloc	function
(	O
n	long
,	O
size	long
)	O
;	O
}	O
else	O
{	O
snprintf	function
(	O
name	pointer
,	O
EDMA_PATH_LEN	pointer
,	O
"%s/%s"	pointer
,	O
TMPDIR	pointer
,	O
n	long
)	O
;	O
f	pointer
=	O
open	function
(	O
name	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
)	O
;	O
if	O
(	O
f	pointer
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EEXIST	int
)	O
{	O
perror	function
(	O
"Create File"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
chmod	function
(	O
name	pointer
,	O
S_IRWXU	O
|	O
S_IRWXG	O
|	O
S_IRWXO	O
)	O
;	O
if	O
(	O
(	O
k	int
=	O
ftok	function
(	O
name	pointer
,	O
0	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"[edma_salloc] (ftok)"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
shmflg	int
=	O
0	int
;	O
a	pointer
=	O
shmget	function
(	O
k	pointer
,	O
size	long
,	O
IPC_CREAT	int
|	O
0777	int
)	O
;	O
if	O
(	O
(	O
a	int
==	O
-	O
1	int
)	O
&&	O
(	O
errno	O
!=	O
EEXIST	int
)	O
)	O
{	O
printf	function
(	O
"\n[edma_salloc] ERROR in shared block : %s (key:%d|size:%ld)"	pointer
,	O
name	pointer
,	O
k	int
,	O
size	long
)	O
;	O
printf	function
(	O
"\n "	pointer
)	O
;	O
perror	function
(	O
"[edma_salloc] (shmget):"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
_sally	int
<=	O
0	int
)	O
close	pointer
(	O
f	int
)	O
;	O
return	O
(	O
(	O
HMEM	long
)	O
a	pointer
)	O
;	O
}	O
EPVoid	pointer
EDMAPROC	O
edma_sget	function
(	O
HMEM	long
a	pointer
)	O
{	O
EPVoid	pointer
p	pointer
;	O
p	pointer
=	O
shmat	function
(	O
(	O
EUint32	long
)	O
a	int
,	O
0	int
,	O
SHM_RND	pointer
)	O
;	O
if	O
(	O
(	O
int	O
)	O
p	int
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"[edma_sget] :"	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
}	O
return	O
p	pointer
;	O
}	O
EPVoid	pointer
EDMAPROC	O
edma_sunget	function
(	O
EPVoid	pointer
p	pointer
)	O
{	O
EUint32	long
i	long
;	O
i	int
=	O
shmdt	function
(	O
p	pointer
)	O
;	O
if	O
(	O
i	int
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"[edma_sunget] :"	pointer
)	O
;	O
return	O
(	O
EPVoid	pointer
)	O
-	O
1	int
;	O
}	O
return	O
p	pointer
;	O
}	O
void	O
EDMAPROC	O
edma_sfree	function
(	O
HMEM	long
i	long
,	O
EPVoid	pointer
p	pointer
)	O
{	O
ESint32	long
a	long
;	O
struct	O
shmid_ds	struct
buf	pointer
;	O
if	O
(	O
_sally	int
<	O
0	int
)	O
{	O
a	pointer
=	O
shmctl	function
(	O
i	pointer
,	O
IPC_RMID	pointer
,	O
&	O
buf	pointer
)	O
;	O
if	O
(	O
a	int
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"[edma_sfree] (IPC_RMID):"	pointer
)	O
;	O
return	O
;	O
}	O
}	O
}	O
HMEM	long
EDMAPROC	O
edma_palloc	function
(	O
EUint32	long
size	long
)	O
{	O
EPVoid	pointer
p	pointer
;	O
EPChar	pointer
t	pointer
;	O
EUint32	long
i	long
;	O
p	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
t	pointer
=	O
(	O
EPChar	pointer
)	O
p	pointer
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
size	long
;	O
i	long
++	O
)	O
*	O
(	O
t	pointer
+	O
i	long
)	O
=	O
0	int
;	O
n_palloc	int
++	O
;	O
return	O
(	O
(	O
HMEM	long
)	O
p	pointer
)	O
;	O
}	O
HMEM	long
EDMAPROC	O
edma_prealloc	function
(	O
HMEM	long
a	long
,	O
EUint32	long
new_size	long
)	O
{	O
if	O
(	O
a	int
==	O
0	int
)	O
n_palloc	long
++	O
;	O
else	O
n_prealloc	pointer
++	O
;	O
a	pointer
=	O
(	O
HMEM	long
)	O
realloc	function
(	O
(	O
EPVoid	pointer
)	O
a	pointer
,	O
new_size	long
)	O
;	O
return	O
a	pointer
;	O
}	O
EPVoid	pointer
EDMAPROC	O
edma_pget	function
(	O
HMEM	long
a	pointer
)	O
{	O
n_pget	pointer
++	O
;	O
return	O
(	O
EPVoid	pointer
)	O
a	pointer
;	O
}	O
void	O
EDMAPROC	O
edma_pfree	function
(	O
HMEM	long
a	pointer
,	O
EPVoid	pointer
p	pointer
)	O
{	O
n_pfree	pointer
++	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
void	O
EDMAPROC	O
edma_show_pmem	function
(	O
)	O
{	O
printf	function
(	O
"palloc   : %ld times\n"	pointer
,	O
n_palloc	pointer
)	O
;	O
printf	function
(	O
"pget     : %ld times\n"	pointer
,	O
n_pget	pointer
)	O
;	O
printf	function
(	O
"prealloc : %ld times\n"	pointer
,	O
n_prealloc	pointer
)	O
;	O
printf	function
(	O
"pfree    : %ld times\n"	pointer
,	O
n_pfree	pointer
)	O
;	O
}	O
ESint32	int
edma_register_system_classes	function
(	O
)	O
{	O
CLASSID	int
cid	int
;	O
edma_log	function
(	O
"Registering System Classes..."	pointer
)	O
;	O
edma_log	function
(	O
"  Adding EDMA_EXCEPTION class..."	pointer
)	O
;	O
cid	long
=	O
EDMA_EXCEPTION_class_factory	function
(	O
)	O
;	O
gClass	O
[	O
cid	long
]	O
->	O
repo_id	long
=	O
-	O
1	int
;	O
gClass	O
[	O
cid	long
]	O
->	O
repo_type	double
=	O
EDMA_LOCAL_REPO	int
;	O
edma_log	function
(	O
"System Classes Registerd"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
_edma_ini_sys_table	function
(	O
EPChar	pointer
EdmaPath	pointer
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
EUint16	long
n	long
,	O
i	int
;	O
static	O
EUint32	long
Maqid	long
;	O
char	O
nom	array
[	O
32	int
]	O
;	O
EChar	char
SysFile	array
[	O
256	int
]	O
;	O
strncpy	function
(	O
SysFile	O
,	O
EdmaPath	pointer
,	O
256	int
)	O
;	O
strncat	function
(	O
SysFile	pointer
,	O
"/etc/sysdat32.cfg"	pointer
,	O
256	int
)	O
;	O
f	pointer
=	O
fopen	function
(	O
SysFile	pointer
,	O
"rt"	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
edma_print	function
(	O
"(ERROR)System File not found"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
fscanf	function
(	O
f	pointer
,	O
"%s"	pointer
,	O
nom	pointer
)	O
;	O
n	long
=	O
atol	function
(	O
nom	pointer
)	O
;	O
n	int
--	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
fscanf	function
(	O
f	pointer
,	O
"%s"	pointer
,	O
nom	pointer
)	O
;	O
fscanf	function
(	O
f	pointer
,	O
"%ld"	pointer
,	O
&	O
Maqid	int
)	O
;	O
GVar	pointer
->	O
SysMaq	array
[	O
i	int
]	O
.	O
Id	int
=	O
Maqid	int
;	O
memcpy	function
(	O
GVar	pointer
->	O
SysMaq	array
[	O
i	long
]	O
.	O
Nombre	pointer
,	O
nom	pointer
,	O
strlen	function
(	O
nom	pointer
)	O
)	O
;	O
}	O
GVar	pointer
->	O
nMaqNum	long
=	O
n	long
;	O
fscanf	function
(	O
f	pointer
,	O
"%ld"	pointer
,	O
&	O
GVar	pointer
->	O
nSONum	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
GVar	pointer
->	O
nSONum	long
;	O
i	long
++	O
)	O
{	O
fscanf	function
(	O
f	pointer
,	O
"%s"	pointer
,	O
GVar	pointer
->	O
SysSO	array
[	O
i	long
]	O
.	O
Nombre	pointer
)	O
;	O
fscanf	function
(	O
f	pointer
,	O
"%ld"	pointer
,	O
&	O
GVar	pointer
->	O
SysSO	array
[	O
i	long
]	O
.	O
Id	long
)	O
;	O
}	O
fclose	function
(	O
f	pointer
)	O
;	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_so_id	function
(	O
EPChar	pointer
name	pointer
)	O
{	O
EUint32	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
GVar	pointer
->	O
nSONum	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
GVar	pointer
->	O
SysSO	array
[	O
i	long
]	O
.	O
Nombre	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
GVar	pointer
->	O
nSONum	pointer
)	O
edma_print	function
(	O
"(ERROR)Operating System not found"	pointer
)	O
;	O
return	O
i	long
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_arch_id	function
(	O
EPChar	pointer
name	pointer
)	O
{	O
EUint32	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
GVar	pointer
->	O
nMaqNum	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
GVar	pointer
->	O
SysMaq	array
[	O
i	long
]	O
.	O
Nombre	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
GVar	pointer
->	O
nMaqNum	pointer
)	O
edma_print	function
(	O
"(ERROR)Machine not found"	pointer
)	O
;	O
return	O
i	long
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_so_name	function
(	O
EUint32	long
id	long
,	O
EPChar	pointer
*	O
name	pointer
)	O
{	O
if	O
(	O
id	int
>=	O
GVar	pointer
->	O
nSONum	pointer
)	O
{	O
edma_print	function
(	O
"(ERROR)Operating System not found"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
*	O
name	pointer
=	O
GVar	pointer
->	O
SysSO	array
[	O
id	int
]	O
.	O
Nombre	int
;	O
return	O
1	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_arch_name	function
(	O
EUint32	long
id	long
,	O
EPChar	pointer
*	O
name	pointer
)	O
{	O
if	O
(	O
id	int
>=	O
GVar	pointer
->	O
nMaqNum	pointer
)	O
{	O
edma_print	function
(	O
"(ERROR)Machine not found"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
*	O
name	pointer
=	O
GVar	pointer
->	O
SysMaq	array
[	O
id	int
]	O
.	O
Nombre	int
;	O
return	O
1	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_so_num	function
(	O
void	O
)	O
{	O
return	O
GVar	pointer
->	O
nSONum	long
;	O
}	O
EUint32	long
EDMAPROC	O
edma_get_arch_num	function
(	O
void	O
)	O
{	O
return	O
GVar	pointer
->	O
nMaqNum	pointer
;	O
}	O
typedef	O
struct	O
{	O
EPChar	pointer
Id	pointer
;	O
}	O
DtAP_TEST	struct
;	O
ESint32	int
EDMAPROC	O
AP_TESTdisplay	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtAP_TEST	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtAP_TEST	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Id: %s"	pointer
,	O
m	pointer
->	O
Id	int
)	O
;	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
{	O
EUint32	long
Prop1	long
;	O
EUint32	long
Prop2	long
;	O
}	O
DtSUBCLASS1	struct
;	O
ESint32	int
EDMAPROC	O
SUBCLASS1Met1	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtSUBCLASS1	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtSUBCLASS1	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Running method Met1"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
SUBCLASS1Met4	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtSUBCLASS1	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtSUBCLASS1	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Running method Met4"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
{	O
EUint32	long
eui32	long
;	O
ESint32	int
esi32	int
;	O
EUint16	long
eui16	long
;	O
ESint16	double
esi16	double
;	O
EUint8	O
eui8	pointer
;	O
ESint8	enum
esi8	enum
;	O
EByte	pointer
eb	long
;	O
EWord	pointer
ew	pointer
;	O
EDWord	O
edw	pointer
;	O
EReal32	O
er32	pointer
;	O
EReal64	pointer
er64	pointer
;	O
EPChar	pointer
string	pointer
;	O
}	O
DtETYPES_TEST	struct
;	O
ESint32	int
EDMAPROC	O
ETYPES_TESTborn	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtETYPES_TEST	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtETYPES_TEST	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
ETYPES_TESTrip	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtETYPES_TEST	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtETYPES_TEST	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
{	O
EPChar	pointer
degree	pointer
;	O
}	O
DtGRADUATE	struct
;	O
ESint32	int
EDMAPROC	O
GRADUATEdisplay	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtGRADUATE	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtGRADUATE	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
if	O
(	O
m	pointer
->	O
degree	pointer
==	O
NULL	O
)	O
edma_wprop3	function
(	O
IdObj	int
,	O
"degree"	pointer
,	O
""	pointer
)	O
;	O
edma_met3	function
(	O
IdObj	int
,	O
"PERSON>display"	pointer
)	O
;	O
printf	function
(	O
" %s"	pointer
,	O
m	pointer
->	O
degree	pointer
)	O
;	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
{	O
EPChar	pointer
degree	pointer
;	O
}	O
DtGRADUATE_INNER	struct
;	O
ESint32	int
EDMAPROC	O
GRADUATE_INNER1side_display	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtGRADUATE_INNER	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtGRADUATE_INNER	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Side Display: %s"	pointer
,	O
m	pointer
->	O
degree	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
GRADUATE_INNER1display	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtGRADUATE_INNER	struct
*	O
m	pointer
;	O
OBJID	int
e	int
;	O
m	pointer
=	O
(	O
DtGRADUATE_INNER	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
if	O
(	O
m	pointer
->	O
degree	pointer
==	O
NULL	O
)	O
edma_wprop3	function
(	O
IdObj	int
,	O
"degree"	pointer
,	O
"Mr"	pointer
)	O
;	O
EDMA_TRY	O
{	O
edma_met3	function
(	O
IdObj	int
,	O
"INNER<.display"	pointer
)	O
;	O
}	O
EDMA_CATCH	O
(	O
e	int
)	O
{	O
}	O
EDMA_TRY_END	O
;	O
printf	function
(	O
"%s "	pointer
,	O
m	pointer
->	O
degree	pointer
)	O
;	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
{	O
EPChar	pointer
degree	pointer
;	O
}	O
DtGRADUATE_INNER	struct
;	O
ESint32	int
EDMAPROC	O
GRADUATE_INNERside_display	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtGRADUATE_INNER	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtGRADUATE_INNER	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
edma_printf_obj	function
(	O
IdObj	int
,	O
"Side Display: %s"	pointer
,	O
m	pointer
->	O
degree	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
GRADUATE_INNERdisplay	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtGRADUATE_INNER	struct
*	O
m	pointer
;	O
OBJID	int
e	int
;	O
m	pointer
=	O
(	O
DtGRADUATE_INNER	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
if	O
(	O
m	pointer
->	O
degree	pointer
==	O
NULL	O
)	O
edma_wprop3	function
(	O
IdObj	int
,	O
"degree"	pointer
,	O
"Mr"	pointer
)	O
;	O
EDMA_TRY	O
{	O
edma_met3	function
(	O
IdObj	int
,	O
"INNER<.display"	pointer
)	O
;	O
}	O
EDMA_CATCH	O
(	O
e	int
)	O
{	O
}	O
EDMA_TRY_END	O
;	O
printf	function
(	O
"%s "	pointer
,	O
m	pointer
->	O
degree	pointer
)	O
;	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
{	O
EPChar	pointer
name	pointer
;	O
EPChar	pointer
sc_level1_priv	pointer
;	O
}	O
DtSC1_LEVEL1	struct
;	O
ESint32	int
EDMAPROC	O
SC1_LEVEL1sc1_level1_display	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtSC1_LEVEL1	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtSC1_LEVEL1	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
m	pointer
->	O
sc_level1_priv	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	int
EDMAPROC	O
SC1_LEVEL1display	function
(	O
OBJID	int
IdObj	int
)	O
{	O
DtSC1_LEVEL1	struct
*	O
m	pointer
;	O
m	pointer
=	O
(	O
DtSC1_LEVEL1	struct
*	O
)	O
edma_get_data_ref	function
(	O
IdObj	int
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
m	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
gnufdisk_stack	struct
{	O
void	O
*	O
data	pointer
;	O
int	O
size	int
;	O
int	O
index	function
;	O
}	O
;	O
struct	O
gnufdisk_stack	struct
*	O
gnufdisk_stack_new	function
(	O
void	O
)	O
{	O
struct	O
gnufdisk_stack	struct
*	O
ret	pointer
;	O
int	O
err	int
;	O
if	O
(	O
(	O
ret	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
gnufdisk_stack	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
err	int
=	O
ENOMEM	int
;	O
goto	O
lb_out	O
;	O
}	O
memset	function
(	O
ret	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
gnufdisk_stack	struct
)	O
)	O
;	O
lb_out	O
:	O
errno	O
=	O
err	int
;	O
return	O
ret	int
;	O
}	O
int	O
gnufdisk_stack_delete	function
(	O
struct	O
gnufdisk_stack	struct
*	O
_s	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
err	int
;	O
if	O
(	O
gnufdisk_check_memory	function
(	O
_s	pointer
,	O
sizeof	O
(	O
struct	O
gnufdisk_stack	struct
)	O
,	O
0	int
)	O
!=	O
0	int
)	O
{	O
err	int
=	O
errno	O
;	O
ret	int
=	O
-	O
1	int
;	O
goto	O
lb_out	O
;	O
}	O
if	O
(	O
_s	pointer
->	O
data	pointer
)	O
{	O
if	O
(	O
gnufdisk_check_memory	function
(	O
_s	pointer
->	O
data	pointer
,	O
_s	pointer
->	O
size	long
,	O
0	int
)	O
!=	O
0	int
)	O
{	O
err	int
=	O
errno	O
;	O
ret	int
=	O
-	O
1	int
;	O
goto	O
lb_out	O
;	O
}	O
free	function
(	O
_s	pointer
->	O
data	pointer
)	O
;	O
_s	pointer
->	O
data	pointer
=	O
NULL	O
;	O
}	O
free	function
(	O
_s	pointer
)	O
;	O
err	int
=	O
0	int
;	O
ret	int
=	O
0	int
;	O
lb_out	O
:	O
errno	O
=	O
err	int
;	O
return	O
ret	int
;	O
}	O
int	O
gnufdisk_stack_push	function
(	O
struct	O
gnufdisk_stack	struct
*	O
_s	pointer
,	O
void	O
*	O
_data	pointer
,	O
size_t	long
_size	long
)	O
{	O
int	O
ret	int
;	O
int	O
err	int
;	O
if	O
(	O
gnufdisk_check_memory	function
(	O
_s	pointer
,	O
sizeof	O
(	O
struct	O
gnufdisk_stack	struct
)	O
,	O
0	int
)	O
!=	O
0	int
)	O
{	O
err	int
=	O
errno	O
;	O
ret	int
=	O
-	O
1	int
;	O
goto	O
lb_out	O
;	O
}	O
else	O
if	O
(	O
gnufdisk_check_memory	function
(	O
_data	pointer
,	O
_size	pointer
,	O
1	int
)	O
!=	O
0	int
)	O
{	O
err	int
=	O
EFAULT	int
;	O
ret	int
=	O
-	O
1	int
;	O
goto	O
lb_out	O
;	O
}	O
if	O
(	O
_size	long
>	O
_s	pointer
->	O
size	long
-	O
_s	pointer
->	O
index	function
)	O
{	O
void	O
*	O
data	pointer
;	O
int	O
size	int
;	O
size	int
=	O
_s	pointer
->	O
size	long
+	O
32	int
;	O
if	O
(	O
(	O
data	pointer
=	O
malloc	function
(	O
size	long
)	O
)	O
==	O
NULL	O
)	O
{	O
err	int
=	O
ENOMEM	int
;	O
ret	int
=	O
-	O
1	int
;	O
goto	O
lb_out	O
;	O
}	O
if	O
(	O
_s	pointer
->	O
data	pointer
)	O
{	O
memcpy	function
(	O
data	pointer
,	O
_s	pointer
->	O
data	pointer
,	O
_s	pointer
->	O
index	function
)	O
;	O
free	function
(	O
_s	pointer
->	O
data	pointer
)	O
;	O
}	O
_s	pointer
->	O
data	pointer
=	O
data	pointer
;	O
_s	pointer
->	O
size	long
=	O
size	long
;	O
return	O
gnufdisk_stack_push	function
(	O
_s	pointer
,	O
_data	pointer
,	O
_size	pointer
)	O
;	O
}	O
memcpy	function
(	O
_s	pointer
->	O
data	pointer
+	O
_s	pointer
->	O
index	function
,	O
_data	pointer
,	O
_size	long
)	O
;	O
_s	pointer
->	O
index	function
+=	O
_size	pointer
;	O
err	int
=	O
0	int
;	O
ret	int
=	O
0	int
;	O
lb_out	O
:	O
errno	O
=	O
err	int
;	O
return	O
ret	int
;	O
}	O
int	O
gnufdisk_stack_pop	function
(	O
struct	O
gnufdisk_stack	struct
*	O
_s	pointer
,	O
void	O
*	O
_dest	pointer
,	O
size_t	long
_size	long
)	O
{	O
int	O
ret	int
;	O
int	O
err	int
;	O
if	O
(	O
gnufdisk_check_memory	function
(	O
_s	pointer
,	O
sizeof	O
(	O
struct	O
gnufdisk_stack	struct
)	O
,	O
0	int
)	O
!=	O
0	int
||	O
(	O
_s	pointer
->	O
data	pointer
&&	O
gnufdisk_check_memory	function
(	O
_s	pointer
->	O
data	pointer
,	O
_s	pointer
->	O
size	long
,	O
0	int
)	O
!=	O
0	int
)	O
||	O
gnufdisk_check_memory	function
(	O
_dest	pointer
,	O
_size	pointer
,	O
0	int
)	O
!=	O
0	int
)	O
{	O
err	O
=	O
errno	O
;	O
ret	int
=	O
-	O
1	int
;	O
goto	O
lb_out	O
;	O
}	O
else	O
if	O
(	O
_size	pointer
>	O
_s	pointer
->	O
index	function
)	O
{	O
err	int
=	O
ENOBUFS	int
;	O
ret	int
=	O
-	O
1	int
;	O
goto	O
lb_out	O
;	O
}	O
memcpy	function
(	O
_dest	pointer
,	O
_s	pointer
->	O
data	pointer
+	O
(	O
_s	pointer
->	O
index	function
-	O
_size	pointer
)	O
,	O
_size	pointer
)	O
;	O
_s	pointer
->	O
index	function
-=	O
_size	pointer
;	O
ret	int
=	O
0	int
;	O
err	int
=	O
0	int
;	O
lb_out	O
:	O
errno	O
=	O
err	int
;	O
return	O
ret	int
;	O
}	O
int	O
board_size	int
=	O
DEFAULT_BOARD_SIZE	int
;	O
Intersection	struct
board	pointer
[	O
BOARDSIZE	int
]	O
;	O
int	O
board_ko_pos	int
;	O
int	O
white_captured	int
;	O
int	O
black_captured	int
;	O
Intersection	struct
initial_board	array
[	O
BOARDSIZE	int
]	O
;	O
int	O
initial_board_ko_pos	int
;	O
int	O
initial_white_captured	int
;	O
int	O
initial_black_captured	int
;	O
int	O
move_history_color	array
[	O
MAX_MOVE_HISTORY	int
]	O
;	O
int	O
move_history_pos	array
[	O
MAX_MOVE_HISTORY	int
]	O
;	O
Hash_data	pointer
move_history_hash	array
[	O
MAX_MOVE_HISTORY	int
]	O
;	O
int	O
move_history_pointer	int
;	O
float	O
komi	enum
=	O
0.0	int
;	O
int	O
handicap	int
=	O
0	int
;	O
int	O
movenum	int
;	O
enum	O
suicide_rules	enum
suicide_rule	enum
=	O
FORBIDDEN	int
;	O
enum	O
ko_rules	enum
ko_rule	enum
=	O
SIMPLE	int
;	O
signed	O
char	O
shadow	array
[	O
BOARDMAX	O
]	O
;	O
Hash_data	pointer
board_hash	pointer
;	O
int	O
stackp	int
;	O
int	O
position_number	int
;	O
struct	O
stats_data	struct
stats	pointer
;	O
int	O
count_variations	int
=	O
0	int
;	O
SGFTree	struct
*	O
sgf_dumptree	pointer
=	O
NULL	O
;	O
int	O
thrashing_dragon	int
=	O
NO_MOVE	O
;	O
signed	O
char	O
thrashing_stone	array
[	O
BOARDMAX	int
]	O
;	O
float	O
potential_moves	array
[	O
BOARDMAX	O
]	O
;	O
int	O
depth	int
;	O
int	O
backfill_depth	int
;	O
int	O
backfill2_depth	int
;	O
int	O
break_chain_depth	int
;	O
int	O
superstring_depth	int
;	O
int	O
fourlib_depth	int
;	O
int	O
ko_depth	int
;	O
int	O
branch_depth	int
;	O
int	O
aa_depth	int
;	O
int	O
depth_offset	int
;	O
int	O
owl_distrust_depth	int
;	O
int	O
owl_branch_depth	int
;	O
int	O
owl_reading_depth	int
;	O
int	O
owl_node_limit	int
;	O
int	O
semeai_branch_depth	int
;	O
int	O
semeai_branch_depth2	int
;	O
int	O
semeai_node_limit	int
;	O
int	O
connect_depth	int
;	O
int	O
connect_depth2	int
;	O
int	O
connection_node_limit	int
;	O
int	O
breakin_node_limit	int
;	O
int	O
breakin_depth	int
;	O
int	O
mandated_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_backfill_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_backfill2_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_break_chain_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_superstring_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_fourlib_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_ko_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_branch_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_aa_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_owl_distrust_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_owl_branch_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_owl_reading_depth	int
=	O
-	O
1	int
;	O
int	O
mandated_owl_node_limit	int
=	O
-	O
1	int
;	O
int	O
mandated_semeai_node_limit	int
=	O
-	O
1	int
;	O
int	O
quiet	int
=	O
0	int
;	O
int	O
showstatistics	int
=	O
0	int
;	O
int	O
profile_patterns	int
=	O
0	int
;	O
int	O
allpats	int
=	O
0	int
;	O
int	O
printworms	int
=	O
0	int
;	O
int	O
printmoyo	int
=	O
0	int
;	O
int	O
printboard	int
=	O
0	int
;	O
int	O
fusekidb	int
=	O
1	int
;	O
int	O
disable_fuseki	int
=	O
0	int
;	O
int	O
josekidb	int
=	O
1	int
;	O
int	O
showtime	int
=	O
0	int
;	O
int	O
showscore	int
=	O
0	int
;	O
int	O
debug	int
=	O
0	int
;	O
int	O
verbose	int
=	O
0	int
;	O
char	O
outfilename	array
[	O
128	int
]	O
=	O
""	pointer
;	O
int	O
output_flags	int
=	O
OUTPUT_DEFAULT	int
;	O
int	O
metamachine	int
=	O
0	int
;	O
int	O
oracle_exists	int
=	O
0	int
;	O
int	O
autolevel_on	int
=	O
0	int
;	O
int	O
disable_threat_computation	int
=	O
0	int
;	O
int	O
disable_endgame_patterns	int
=	O
0	int
;	O
int	O
doing_scoring	int
=	O
0	int
;	O
int	O
chinese_rules	int
=	O
CHINESE_RULES	int
;	O
int	O
experimental_connections	int
=	O
EXPERIMENTAL_CONNECTIONS	int
;	O
int	O
alternate_connections	int
=	O
ALTERNATE_CONNECTIONS	int
;	O
int	O
owl_threats	int
=	O
OWL_THREATS	int
;	O
int	O
experimental_owl_ext	int
=	O
EXPERIMENTAL_OWL_EXT	int
;	O
int	O
experimental_break_in	int
=	O
USE_BREAK_IN	int
;	O
int	O
cosmic_gnugo	int
=	O
COSMIC_GNUGO	int
;	O
int	O
large_scale	int
=	O
LARGE_SCALE	int
;	O
int	O
capture_all_dead	int
=	O
0	int
;	O
int	O
play_out_aftermath	int
=	O
0	int
;	O
int	O
resign_allowed	int
=	O
RESIGNATION_ALLOWED	int
;	O
int	O
play_mirror_go	int
=	O
0	int
;	O
int	O
mirror_stones_limit	int
=	O
-	O
1	int
;	O
int	O
gtp_version	int
=	O
2	int
;	O
int	O
use_monte_carlo_genmove	int
=	O
0	int
;	O
int	O
mc_games_per_level	int
=	O
8000	int
;	O
float	O
best_move_values	array
[	O
10	int
]	O
;	O
int	O
best_moves	array
[	O
10	int
]	O
;	O
float	O
white_score	int
;	O
float	O
black_score	O
;	O
int	O
close_worms	array
[	O
BOARDMAX	int
]	O
[	O
4	int
]	O
;	O
int	O
number_close_worms	array
[	O
BOARDMAX	int
]	O
;	O
int	O
close_black_worms	array
[	O
BOARDMAX	int
]	O
[	O
4	int
]	O
;	O
int	O
number_close_black_worms	array
[	O
BOARDMAX	int
]	O
;	O
int	O
close_white_worms	array
[	O
BOARDMAX	int
]	O
[	O
4	int
]	O
;	O
int	O
number_close_white_worms	array
[	O
BOARDMAX	int
]	O
;	O
int	O
false_eye_territory	array
[	O
BOARDMAX	int
]	O
;	O
int	O
forced_backfilling_moves	array
[	O
BOARDMAX	int
]	O
;	O
struct	O
worm_data	struct
worm	array
[	O
BOARDMAX	int
]	O
;	O
struct	O
dragon_data	O
dragon	array
[	O
BOARDMAX	O
]	O
;	O
int	O
number_of_dragons	int
;	O
struct	O
dragon_data2	struct
*	O
dragon2	pointer
=	O
NULL	O
;	O
struct	O
half_eye_data	struct
half_eye	array
[	O
BOARDMAX	O
]	O
;	O
struct	O
eye_data	struct
black_eye	array
[	O
BOARDMAX	O
]	O
;	O
struct	O
eye_data	struct
white_eye	array
[	O
BOARDMAX	O
]	O
;	O
struct	O
vital_eye_points	struct
black_vital_points	array
[	O
BOARDMAX	int
]	O
;	O
struct	O
vital_eye_points	struct
white_vital_points	array
[	O
BOARDMAX	int
]	O
;	O
struct	O
surround_data	struct
surroundings	array
[	O
MAX_SURROUND	int
]	O
;	O
int	O
surround_pointer	int
;	O
int	O
cutting_points	array
[	O
BOARDMAX	int
]	O
;	O
double	O
slowest_time	double
=	O
0.0	int
;	O
int	O
slowest_move	int
=	O
NO_MOVE	O
;	O
int	O
slowest_movenum	int
=	O
0	int
;	O
double	O
total_time	double
=	O
0.0	int
;	O
float	O
minimum_value_weight	double
=	O
1.0	int
;	O
float	O
maximum_value_weight	double
=	O
1.0	int
;	O
float	O
invasion_malus_weight	double
=	O
1.0	int
;	O
float	O
territorial_weight	double
=	O
1.0	int
;	O
float	O
strategical_weight	double
=	O
1.0	int
;	O
float	O
attack_dragon_weight	double
=	O
1.0	int
;	O
float	O
followup_weight	double
=	O
1.0	int
;	O
static	O
Hash_data	struct
white_hash	array
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	struct
black_hash	array
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	struct
ko_hash	array
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	struct
komaster_hash	array
[	O
NUM_KOMASTER_STATES	int
]	O
;	O
static	O
Hash_data	struct
kom_pos_hash	array
[	O
BOARDMAX	int
]	O
;	O
static	O
Hash_data	struct
goal_hash	array
[	O
BOARDMAX	O
]	O
;	O
static	O
Hashvalue	O
hash_rand	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
Hashvalue	O
h	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
32	int
*	O
i	int
<	O
(	O
int	O
)	O
(	O
CHAR_BIT	O
*	O
sizeof	O
(	O
Hashvalue	pointer
)	O
)	O
;	O
i	int
++	O
)	O
h	int
|=	O
(	O
Hashvalue	int
)	O
gg_urand	function
(	O
)	O
<<	O
32	int
*	O
i	int
;	O
return	O
h	int
;	O
}	O
void	O
hash_init_zobrist_array	function
(	O
Hash_data	struct
*	O
array	pointer
,	O
int	O
size	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
NUM_HASHVALUES	int
;	O
j	int
++	O
)	O
array	array
[	O
i	int
]	O
.	O
hashval	array
[	O
j	int
]	O
=	O
hash_rand	function
(	O
)	O
;	O
}	O
void	O
hash_init	function
(	O
void	O
)	O
{	O
static	O
int	O
is_initialized	int
=	O
0	int
;	O
if	O
(	O
is_initialized	int
)	O
return	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
black_hash	pointer
)	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
white_hash	pointer
)	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
ko_hash	pointer
)	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
komaster_hash	pointer
)	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
kom_pos_hash	pointer
)	O
;	O
INIT_ZOBRIST_ARRAY	function
(	O
goal_hash	pointer
)	O
;	O
is_initialized	int
=	O
1	int
;	O
}	O
void	O
hashdata_recalc	function
(	O
Hash_data	struct
*	O
hd	pointer
,	O
Intersection	struct
*	O
p	pointer
,	O
int	O
ko_pos	int
)	O
{	O
int	O
pos	int
;	O
hashdata_clear	function
(	O
hd	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
p	pointer
[	O
pos	int
]	O
==	O
WHITE	int
)	O
hashdata_xor	function
(	O
*	O
hd	pointer
,	O
white_hash	pointer
[	O
pos	int
]	O
)	O
;	O
else	O
if	O
(	O
p	pointer
[	O
pos	int
]	O
==	O
BLACK	int
)	O
hashdata_xor	function
(	O
*	O
hd	pointer
,	O
black_hash	pointer
[	O
pos	int
]	O
)	O
;	O
}	O
if	O
(	O
ko_pos	int
!=	O
0	int
)	O
hashdata_xor	function
(	O
*	O
hd	pointer
,	O
ko_hash	array
[	O
ko_pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_clear	function
(	O
Hash_data	struct
*	O
hd	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_HASHVALUES	int
;	O
i	int
++	O
)	O
hd	pointer
->	O
hashval	array
[	O
i	int
]	O
=	O
0	int
;	O
}	O
void	O
hashdata_invert_ko	function
(	O
Hash_data	struct
*	O
hd	pointer
,	O
int	O
pos	int
)	O
{	O
hashdata_xor	function
(	O
*	O
hd	pointer
,	O
ko_hash	pointer
[	O
pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_stone	function
(	O
Hash_data	struct
*	O
hd	pointer
,	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
if	O
(	O
color	enum
==	O
BLACK	int
)	O
hashdata_xor	function
(	O
*	O
hd	pointer
,	O
black_hash	pointer
[	O
pos	int
]	O
)	O
;	O
else	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
hashdata_xor	function
(	O
*	O
hd	pointer
,	O
white_hash	pointer
[	O
pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_komaster	function
(	O
Hash_data	struct
*	O
hd	pointer
,	O
int	O
komaster	int
)	O
{	O
hashdata_xor	function
(	O
*	O
hd	pointer
,	O
komaster_hash	array
[	O
komaster	int
]	O
)	O
;	O
}	O
void	O
hashdata_invert_kom_pos	function
(	O
Hash_data	struct
*	O
hd	pointer
,	O
int	O
kom_pos	int
)	O
{	O
hashdata_xor	function
(	O
*	O
hd	pointer
,	O
kom_pos_hash	array
[	O
kom_pos	int
]	O
)	O
;	O
}	O
void	O
hashdata_calc_orientation_invariant	function
(	O
Hash_data	struct
*	O
hd	pointer
,	O
Intersection	struct
*	O
p	pointer
,	O
int	O
ko_pos	int
)	O
{	O
int	O
pos	int
;	O
int	O
rot	int
;	O
Hash_data	O
hd_rot	int
;	O
for	O
(	O
rot	int
=	O
0	int
;	O
rot	int
<	O
8	int
;	O
rot	int
++	O
)	O
{	O
hashdata_clear	function
(	O
&	O
hd_rot	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
p	pointer
[	O
pos	int
]	O
==	O
WHITE	int
)	O
hashdata_xor	function
(	O
hd_rot	pointer
,	O
white_hash	array
[	O
rotate1	function
(	O
pos	int
,	O
rot	pointer
)	O
]	O
)	O
;	O
else	O
if	O
(	O
p	pointer
[	O
pos	int
]	O
==	O
BLACK	int
)	O
hashdata_xor	function
(	O
hd_rot	pointer
,	O
black_hash	array
[	O
rotate1	function
(	O
pos	int
,	O
rot	pointer
)	O
]	O
)	O
;	O
}	O
if	O
(	O
ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_xor	function
(	O
hd_rot	pointer
,	O
ko_hash	array
[	O
rotate1	function
(	O
ko_pos	pointer
,	O
rot	pointer
)	O
]	O
)	O
;	O
if	O
(	O
rot	int
==	O
0	int
||	O
hashdata_is_smaller	function
(	O
hd_rot	pointer
,	O
*	O
hd	pointer
)	O
)	O
*	O
hd	pointer
=	O
hd_rot	int
;	O
}	O
}	O
Hash_data	O
goal_to_hashvalue	function
(	O
const	O
signed	O
char	O
*	O
goal	pointer
)	O
{	O
int	O
pos	int
;	O
Hash_data	struct
return_value	pointer
;	O
hashdata_clear	function
(	O
&	O
return_value	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
goal	pointer
[	O
pos	int
]	O
)	O
hashdata_xor	function
(	O
return_value	pointer
,	O
goal_hash	pointer
[	O
pos	int
]	O
)	O
;	O
return	O
return_value	pointer
;	O
}	O
char	O
*	O
hashdata_to_string	function
(	O
Hash_data	struct
*	O
hashdata	pointer
)	O
{	O
static	O
char	O
buffer	array
[	O
BUFFER_SIZE	int
]	O
;	O
int	O
n	int
=	O
0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
NUM_HASHVALUES	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
n	int
+=	O
sprintf	function
(	O
buffer	pointer
+	O
n	int
,	O
HASHVALUE_PRINT_FORMAT	pointer
,	O
HASHVALUE_NUM_DIGITS	pointer
,	O
hashdata	pointer
->	O
hashval	array
[	O
k	int
]	O
)	O
;	O
gg_assert	O
(	O
n	int
<	O
BUFFER_SIZE	O
)	O
;	O
}	O
return	O
buffer	pointer
;	O
}	O
static	O
void	O
replay_node	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
color_to_test	int
,	O
float	O
*	O
replay_score	pointer
,	O
float	O
*	O
total_score	pointer
)	O
;	O
void	O
play_replay	function
(	O
SGFTree	struct
*	O
tree	pointer
,	O
int	O
color_to_replay	int
)	O
{	O
char	O
*	O
tmpc	pointer
=	O
NULL	O
;	O
float	O
replay_score	pointer
=	O
0.0	int
;	O
float	O
total_score	double
=	O
0.0	int
;	O
SGFNode	struct
*	O
node	pointer
=	O
tree	pointer
->	O
root	pointer
;	O
clear_board	function
(	O
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
printf	function
(	O
"Board Size:   %d\n"	pointer
,	O
board_size	int
)	O
;	O
if	O
(	O
sgfGetCharProperty	function
(	O
node	pointer
,	O
"HA"	pointer
,	O
&	O
tmpc	int
)	O
)	O
printf	function
(	O
"Handicap:     %s\n"	pointer
,	O
tmpc	int
)	O
;	O
printf	function
(	O
"Komi:         %.1f\n"	pointer
,	O
komi	int
)	O
;	O
if	O
(	O
sgfGetCharProperty	function
(	O
node	pointer
,	O
"RU"	pointer
,	O
&	O
tmpc	int
)	O
)	O
printf	function
(	O
"Ruleset:      %s\n"	pointer
,	O
tmpc	pointer
)	O
;	O
if	O
(	O
sgfGetCharProperty	function
(	O
node	pointer
,	O
"GN"	pointer
,	O
&	O
tmpc	int
)	O
)	O
printf	function
(	O
"Game Name:    %s\n"	pointer
,	O
tmpc	pointer
)	O
;	O
if	O
(	O
sgfGetCharProperty	function
(	O
node	pointer
,	O
"DT"	pointer
,	O
&	O
tmpc	int
)	O
)	O
printf	function
(	O
"Game Date:    %s\n"	pointer
,	O
tmpc	pointer
)	O
;	O
if	O
(	O
sgfGetCharProperty	function
(	O
node	pointer
,	O
"GC"	pointer
,	O
&	O
tmpc	int
)	O
)	O
printf	function
(	O
"Game Comment: %s\n"	pointer
,	O
tmpc	pointer
)	O
;	O
if	O
(	O
sgfGetCharProperty	function
(	O
node	pointer
,	O
"US"	pointer
,	O
&	O
tmpc	int
)	O
)	O
printf	function
(	O
"Game User:    %s\n"	pointer
,	O
tmpc	pointer
)	O
;	O
if	O
(	O
sgfGetCharProperty	function
(	O
node	pointer
,	O
"PB"	pointer
,	O
&	O
tmpc	int
)	O
)	O
printf	function
(	O
"Black Player: %s\n"	pointer
,	O
tmpc	pointer
)	O
;	O
if	O
(	O
sgfGetCharProperty	function
(	O
node	pointer
,	O
"PW"	pointer
,	O
&	O
tmpc	int
)	O
)	O
printf	function
(	O
"White Player: %s\n"	pointer
,	O
tmpc	pointer
)	O
;	O
if	O
(	O
sgfGetCharProperty	function
(	O
node	pointer
,	O
"RE"	pointer
,	O
&	O
tmpc	int
)	O
)	O
printf	function
(	O
"Result:       %s\n"	pointer
,	O
tmpc	pointer
)	O
;	O
}	O
while	O
(	O
node	pointer
)	O
{	O
replay_node	function
(	O
node	pointer
,	O
color_to_replay	pointer
,	O
&	O
replay_score	int
,	O
&	O
total_score	pointer
)	O
;	O
sgffile_output	function
(	O
tree	pointer
)	O
;	O
node	pointer
=	O
node	pointer
->	O
child	int
;	O
}	O
if	O
(	O
!	O
quiet	int
)	O
printf	function
(	O
"Global score: %.2f / %.2f\n"	pointer
,	O
replay_score	pointer
,	O
total_score	pointer
)	O
;	O
if	O
(	O
showtime	int
)	O
{	O
gprintf	function
(	O
"SLOWEST MOVE: %d at %1m "	pointer
,	O
slowest_movenum	int
,	O
slowest_move	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"(%.2f seconds)\n"	pointer
,	O
slowest_time	double
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"AVERAGE TIME: %.2f seconds per move\n"	pointer
,	O
total_time	double
/	O
movenum	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"TOTAL TIME: %.2f seconds\n"	pointer
,	O
total_time	double
)	O
;	O
}	O
}	O
static	O
void	O
replay_node	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
color_to_replay	int
,	O
float	O
*	O
replay_score	pointer
,	O
float	O
*	O
total_score	pointer
)	O
{	O
SGFProperty	struct
*	O
sgf_prop	pointer
;	O
SGFProperty	struct
*	O
move_prop	pointer
=	O
NULL	O
;	O
int	O
color	int
;	O
int	O
old_move	int
;	O
int	O
new_move	int
;	O
char	O
buf	pointer
[	O
BUFSIZE	int
]	O
;	O
for	O
(	O
sgf_prop	pointer
=	O
node	pointer
->	O
props	pointer
;	O
sgf_prop	pointer
;	O
sgf_prop	pointer
=	O
sgf_prop	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
sgf_prop	pointer
->	O
name	int
)	O
{	O
case	O
SGFAB	int
:	O
add_stone	function
(	O
get_sgfmove	function
(	O
sgf_prop	pointer
)	O
,	O
BLACK	int
)	O
;	O
break	O
;	O
case	O
SGFAW	int
:	O
add_stone	function
(	O
get_sgfmove	function
(	O
sgf_prop	pointer
)	O
,	O
WHITE	int
)	O
;	O
break	O
;	O
case	O
SGFB	int
:	O
case	O
SGFW	int
:	O
move_prop	pointer
=	O
sgf_prop	pointer
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
move_prop	pointer
)	O
return	O
;	O
old_move	int
=	O
get_sgfmove	function
(	O
move_prop	pointer
)	O
;	O
color	pointer
=	O
(	O
move_prop	pointer
->	O
name	pointer
==	O
SGFW	int
)	O
?	O
WHITE	int
:	O
BLACK	int
;	O
if	O
(	O
color	int
==	O
color_to_replay	int
||	O
color_to_replay	int
==	O
GRAY	int
)	O
{	O
float	O
new_move_value	enum
=	O
0.0	int
;	O
float	O
old_move_value	double
=	O
0.0	int
;	O
int	O
resign	int
;	O
new_move	int
=	O
genmove	function
(	O
color	pointer
,	O
NULL	O
,	O
&	O
resign	struct
)	O
;	O
if	O
(	O
new_move	int
!=	O
PASS_MOVE	int
)	O
new_move_value	int
=	O
potential_moves	array
[	O
new_move	int
]	O
;	O
if	O
(	O
old_move	int
!=	O
PASS_MOVE	int
)	O
old_move_value	int
=	O
potential_moves	array
[	O
old_move	int
]	O
;	O
if	O
(	O
new_move	int
!=	O
old_move	int
||	O
!	O
quiet	int
)	O
{	O
mprintf	function
(	O
"Move %d (%C): "	pointer
,	O
movenum	int
+	O
1	int
,	O
color	int
)	O
;	O
if	O
(	O
resign	int
)	O
printf	function
(	O
"GNU Go resigns "	pointer
)	O
;	O
else	O
{	O
mprintf	function
(	O
"GNU Go plays %1m "	pointer
,	O
new_move	pointer
)	O
;	O
if	O
(	O
new_move	int
!=	O
PASS_MOVE	int
)	O
printf	function
(	O
"(%.2f) "	pointer
,	O
new_move_value	pointer
)	O
;	O
}	O
mprintf	function
(	O
"- Game move %1m "	pointer
,	O
old_move	pointer
)	O
;	O
if	O
(	O
new_move	int
!=	O
PASS_MOVE	int
&&	O
old_move_value	int
>	O
0.0	int
)	O
printf	function
(	O
"(%.2f) "	pointer
,	O
old_move_value	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
*	O
replay_score	pointer
+=	O
new_move_value	int
-	O
old_move_value	int
;	O
*	O
total_score	pointer
+=	O
new_move_value	int
;	O
}	O
if	O
(	O
new_move	int
!=	O
old_move	int
)	O
{	O
if	O
(	O
resign	int
)	O
gg_snprintf	function
(	O
buf	pointer
,	O
BUFSIZE	int
,	O
"GNU Go resigns - Game move %s (%.2f)"	int
,	O
location_to_string	function
(	O
old_move	pointer
)	O
,	O
old_move_value	int
)	O
;	O
else	O
{	O
gg_snprintf	function
(	O
buf	pointer
,	O
BUFSIZE	int
,	O
"GNU Go plays %s (%.2f) - Game move %s (%.2f)"	int
,	O
location_to_string	function
(	O
new_move	pointer
)	O
,	O
new_move_value	int
,	O
location_to_string	function
(	O
old_move	pointer
)	O
,	O
old_move_value	int
)	O
;	O
if	O
(	O
new_move	int
!=	O
PASS_MOVE	int
)	O
sgfCircle	function
(	O
node	pointer
,	O
I	O
(	O
new_move	pointer
)	O
,	O
J	O
(	O
new_move	pointer
)	O
)	O
;	O
}	O
}	O
else	O
gg_snprintf	function
(	O
buf	pointer
,	O
BUFSIZE	int
,	O
"GNU Go plays the same move %s (%.2f)"	int
,	O
location_to_string	function
(	O
new_move	pointer
)	O
,	O
new_move_value	int
)	O
;	O
sgfAddComment	function
(	O
node	pointer
,	O
buf	pointer
)	O
;	O
sgffile_add_debuginfo	function
(	O
node	pointer
,	O
0.0	int
)	O
;	O
}	O
play_move	function
(	O
old_move	pointer
,	O
color	int
)	O
;	O
}	O
static	O
short	O
str2short	function
(	O
char	O
*	O
str	pointer
)	O
;	O
static	O
short	O
str2short	function
(	O
char	O
*	O
str	pointer
)	O
{	O
return	O
(	O
str	pointer
[	O
0	int
]	O
|	O
str	pointer
[	O
1	int
]	O
<<	O
8	int
)	O
;	O
}	O
int	O
main	function
(	O
void	O
)	O
{	O
char	O
instring	array
[	O
MAX_LINE	int
]	O
;	O
char	O
sgf_tag	array
[	O
MAX_LINE	int
]	O
;	O
char	O
comment	pointer
[	O
MAX_LINE	int
]	O
;	O
int	O
i	int
;	O
while	O
(	O
fgets	function
(	O
instring	pointer
,	O
MAX_LINE	pointer
,	O
stdin	pointer
)	O
)	O
{	O
i	int
=	O
strlen	function
(	O
instring	pointer
)	O
-	O
1	int
;	O
while	O
(	O
i	int
>=	O
0	int
&&	O
(	O
instring	array
[	O
i	int
]	O
==	O
' '	O
||	O
instring	array
[	O
i	int
]	O
==	O
10	int
)	O
)	O
instring	array
[	O
i	int
--	O
]	O
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
instring	pointer
,	O
""	pointer
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"\n"	pointer
)	O
;	O
continue	O
;	O
}	O
sscanf	function
(	O
instring	pointer
,	O
"%4s %75s"	pointer
,	O
sgf_tag	pointer
,	O
comment	pointer
)	O
;	O
strncpy	function
(	O
sgf_tag	array
,	O
instring	pointer
,	O
4	int
)	O
;	O
if	O
(	O
strlen	function
(	O
instring	pointer
)	O
>	O
4	int
)	O
strncpy	function
(	O
comment	pointer
,	O
instring	pointer
+	O
4	int
,	O
MAX_LINE	int
-	O
4	int
)	O
;	O
else	O
strcpy	function
(	O
comment	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
sgf_tag	array
[	O
0	int
]	O
==	O
'*'	O
||	O
sgf_tag	array
[	O
0	int
]	O
==	O
'!'	O
)	O
{	O
sgf_tag	array
[	O
0	int
]	O
=	O
sgf_tag	array
[	O
1	int
]	O
;	O
sgf_tag	array
[	O
1	int
]	O
=	O
sgf_tag	array
[	O
2	int
]	O
;	O
sgf_tag	array
[	O
2	int
]	O
=	O
sgf_tag	array
[	O
3	int
]	O
;	O
}	O
if	O
(	O
sgf_tag	array
[	O
0	int
]	O
<	O
'A'	O
||	O
sgf_tag	array
[	O
0	int
]	O
>	O
'Z'	O
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"/* %s */\n"	pointer
,	O
instring	pointer
)	O
;	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
strlen	function
(	O
comment	pointer
)	O
)	O
fprintf	function
(	O
stdout	pointer
,	O
"     /* %s */\n"	pointer
,	O
comment	pointer
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"#define SGF%s %5d\n"	pointer
,	O
sgf_tag	pointer
,	O
str2short	function
(	O
sgf_tag	pointer
)	O
)	O
;	O
}	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
static	O
void	O
__argmatch_die	function
(	O
void	O
)	O
{	O
ARGMATCH_DIE	int
;	O
}	O
argmatch_exit_fn	pointer
argmatch_die	pointer
=	O
__argmatch_die	pointer
;	O
ptrdiff_t	bool
argmatch	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
size_t	long
arglen	long
;	O
ptrdiff_t	long
matchind	long
=	O
-	O
1	int
;	O
bool	bool
ambiguous	bool
=	O
false	int
;	O
arglen	long
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
arglist	array
[	O
i	pointer
]	O
,	O
arg	pointer
,	O
arglen	pointer
)	O
)	O
{	O
if	O
(	O
strlen	function
(	O
arglist	array
[	O
i	long
]	O
)	O
==	O
arglen	pointer
)	O
return	O
i	long
;	O
else	O
if	O
(	O
matchind	int
==	O
-	O
1	int
)	O
matchind	long
=	O
i	long
;	O
else	O
{	O
if	O
(	O
vallist	pointer
==	O
NULL	O
||	O
memcmp	function
(	O
vallist	pointer
+	O
valsize	struct
*	O
matchind	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
{	O
ambiguous	bool
=	O
true	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
ambiguous	pointer
)	O
return	O
-	O
2	int
;	O
else	O
return	O
matchind	pointer
;	O
}	O
void	O
argmatch_invalid	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
ptrdiff_t	long
problem	long
)	O
{	O
char	O
const	O
*	O
format	pointer
=	O
(	O
problem	int
==	O
-	O
1	int
?	O
_	O
(	O
"invalid argument %s for %s"	pointer
)	O
:	O
_	O
(	O
"ambiguous argument %s for %s"	pointer
)	O
)	O
;	O
error	function
(	O
0	int
,	O
0	int
,	O
format	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
ARGMATCH_QUOTING_STYLE	pointer
,	O
value	pointer
)	O
,	O
quote_n	function
(	O
1	int
,	O
context	pointer
)	O
)	O
;	O
}	O
void	O
argmatch_valid	function
(	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
const	O
char	O
*	O
last_val	pointer
=	O
NULL	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Valid arguments are:"	pointer
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
(	O
i	long
==	O
0	int
)	O
||	O
memcmp	function
(	O
last_val	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\n  - `%s'"	pointer
,	O
arglist	array
[	O
i	long
]	O
)	O
;	O
last_val	pointer
=	O
vallist	pointer
+	O
valsize	O
*	O
i	long
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
", `%s'"	pointer
,	O
arglist	array
[	O
i	long
]	O
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
}	O
ptrdiff_t	bool
__xargmatch_internal	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
,	O
argmatch_exit_fn	pointer
exit_fn	pointer
)	O
{	O
ptrdiff_t	long
res	long
=	O
argmatch	function
(	O
arg	pointer
,	O
arglist	int
,	O
vallist	pointer
,	O
valsize	pointer
)	O
;	O
if	O
(	O
res	int
>=	O
0	int
)	O
return	O
res	pointer
;	O
argmatch_invalid	function
(	O
context	pointer
,	O
arg	pointer
,	O
res	pointer
)	O
;	O
argmatch_valid	function
(	O
arglist	int
,	O
vallist	pointer
,	O
valsize	int
)	O
;	O
(	O
*	O
exit_fn	pointer
)	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
const	O
char	O
*	O
argmatch_to_argument	function
(	O
const	O
char	O
*	O
value	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
!	O
memcmp	function
(	O
value	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	int
,	O
valsize	int
)	O
)	O
return	O
arglist	array
[	O
i	long
]	O
;	O
return	O
NULL	O
;	O
}	O
size_t	long
dir_len	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
prefix_length	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
;	O
size_t	long
length	long
;	O
prefix_length	long
+=	O
(	O
prefix_length	long
!=	O
0	int
?	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
prefix_length	long
]	O
)	O
)	O
:	O
(	O
ISSLASH	O
(	O
file	pointer
[	O
0	int
]	O
)	O
?	O
(	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
?	O
2	int
:	O
1	int
)	O
)	O
:	O
0	int
)	O
)	O
;	O
for	O
(	O
length	long
=	O
last_component	function
(	O
file	pointer
)	O
-	O
file	pointer
;	O
prefix_length	long
<	O
length	long
;	O
length	long
--	O
)	O
if	O
(	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
length	long
-	O
1	int
]	O
)	O
)	O
break	O
;	O
return	O
length	long
;	O
}	O
char	O
*	O
dir_name	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
length	long
=	O
dir_len	function
(	O
file	pointer
)	O
;	O
bool	bool
append_dot	bool
=	O
(	O
length	long
==	O
0	int
||	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
length	long
==	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
&&	O
file	pointer
[	O
2	int
]	O
!=	O
'\0'	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
)	O
)	O
;	O
char	O
*	O
dir	pointer
=	O
xmalloc	function
(	O
length	long
+	O
append_dot	bool
+	O
1	int
)	O
;	O
memcpy	function
(	O
dir	pointer
,	O
file	pointer
,	O
length	long
)	O
;	O
if	O
(	O
append_dot	bool
)	O
dir	pointer
[	O
length	long
++	O
]	O
=	O
'.'	O
;	O
dir	pointer
[	O
length	long
]	O
=	O
'\0'	O
;	O
return	O
dir	pointer
;	O
}	O
size_t	long
full_rw	O
(	O
int	O
fd	int
,	O
const	O
void	O
*	O
buf	pointer
,	O
size_t	long
count	long
)	O
{	O
size_t	long
total	long
=	O
0	int
;	O
const	O
char	O
*	O
ptr	pointer
=	O
(	O
const	O
char	O
*	O
)	O
buf	pointer
;	O
while	O
(	O
count	long
>	O
0	int
)	O
{	O
size_t	long
n_rw	long
=	O
safe_rw	O
(	O
fd	int
,	O
ptr	pointer
,	O
count	long
)	O
;	O
if	O
(	O
n_rw	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
break	O
;	O
if	O
(	O
n_rw	long
==	O
0	int
)	O
{	O
errno	O
=	O
ZERO_BYTE_TRANSFER_ERRNO	O
;	O
break	O
;	O
}	O
total	long
+=	O
n_rw	long
;	O
ptr	pointer
+=	O
n_rw	long
;	O
count	long
-=	O
n_rw	long
;	O
}	O
return	O
total	long
;	O
}	O
void	O
gettime	function
(	O
struct	O
timespec	struct
*	O
ts	pointer
)	O
{	O
if	O
(	O
clock_gettime	function
(	O
CLOCK_REALTIME	int
,	O
ts	pointer
)	O
==	O
0	int
)	O
return	O
;	O
{	O
struct	O
timeval	struct
tv	struct
;	O
gettimeofday	function
(	O
&	O
tv	struct
,	O
NULL	O
)	O
;	O
ts	pointer
->	O
tv_sec	long
=	O
tv	struct
.	O
tv_sec	long
;	O
ts	pointer
->	O
tv_nsec	long
=	O
tv	struct
.	O
tv_usec	long
*	O
1000	int
;	O
}	O
}	O
enum	O
{	O
HAVE_GNU_CALLOC	int
=	O
1	int
}	O
;	O
void	O
*	O
xmalloc	function
(	O
size_t	long
n	long
)	O
{	O
void	O
*	O
p	pointer
=	O
malloc	function
(	O
n	long
)	O
;	O
if	O
(	O
!	O
p	pointer
&&	O
n	long
!=	O
0	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
n	long
)	O
{	O
p	pointer
=	O
realloc	function
(	O
p	pointer
,	O
n	long
)	O
;	O
if	O
(	O
!	O
p	pointer
&&	O
n	long
!=	O
0	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
x2realloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
*	O
pn	pointer
)	O
{	O
return	O
x2nrealloc	function
(	O
p	pointer
,	O
pn	pointer
,	O
1	int
)	O
;	O
}	O
void	O
*	O
xzalloc	function
(	O
size_t	long
s	long
)	O
{	O
return	O
memset	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
0	int
,	O
s	long
)	O
;	O
}	O
void	O
*	O
xcalloc	function
(	O
size_t	long
n	long
,	O
size_t	long
s	long
)	O
{	O
void	O
*	O
p	pointer
;	O
if	O
(	O
(	O
!	O
HAVE_GNU_CALLOC	int
&&	O
xalloc_oversized	O
(	O
n	long
,	O
s	long
)	O
)	O
||	O
(	O
!	O
(	O
p	pointer
=	O
calloc	function
(	O
n	long
,	O
s	long
)	O
)	O
&&	O
(	O
HAVE_GNU_CALLOC	int
||	O
n	long
!=	O
0	int
)	O
)	O
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xmemdup	function
(	O
void	O
const	O
*	O
p	pointer
,	O
size_t	long
s	long
)	O
{	O
return	O
memcpy	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
p	pointer
,	O
s	long
)	O
;	O
}	O
char	O
*	O
xstrdup	function
(	O
char	O
const	O
*	O
string	pointer
)	O
{	O
return	O
xmemdup	function
(	O
string	pointer
,	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
)	O
;	O
}	O
speed_t	struct
ospeed	short
;	O
static	O
struct	O
termios	struct
old_term	struct
;	O
static	O
struct	O
termios	struct
new_term	struct
;	O
char	O
*	O
copyright	pointer
=	O
"%s %s - Display key sequence utility\nGIT is free software; you can redistribute it and/or modify it under the\nterms of the GNU General Public License as published by the Free Software\nFoundation; either version 2, or (at your option) any later version.\nCopyright (C) 1993-1998 Free Software Foundation, Inc.\nWritten by Tudor Hulubei and Andrei Pitis, students at PUB, Romania\n\nPress SPACE when done.\n\n"	pointer
;	O
extern	O
RETSIGTYPE	struct
do_exit	function
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
void	O
tty_init	function
(	O
)	O
{	O
{	O
tcgetattr	function
(	O
TTY_OUTPUT	pointer
,	O
&	O
old_term	struct
)	O
;	O
new_term	int
=	O
old_term	int
;	O
new_term	struct
.	O
c_iflag	int
&=	O
~	O
(	O
IXON	int
|	O
ICRNL	int
|	O
IGNCR	int
|	O
INLCR	int
|	O
IGNBRK	int
|	O
BRKINT	int
)	O
;	O
new_term	struct
.	O
c_oflag	int
&=	O
~	O
OPOST	int
;	O
new_term	struct
.	O
c_lflag	int
|=	O
ISIG	int
|	O
NOFLSH	int
;	O
new_term	struct
.	O
c_lflag	int
&=	O
~	O
(	O
ICANON	int
|	O
ECHO	int
)	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VQUIT	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VSTART	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VSTOP	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
1	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
0	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VERASE	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VKILL	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VEOL	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VEOL2	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VSUSP	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VREPRINT	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VDISCARD	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VWERASE	int
]	O
=	O
CDISABLE	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VLNEXT	int
]	O
=	O
CDISABLE	int
;	O
tcsetattr	function
(	O
TTY_OUTPUT	int
,	O
TCSADRAIN	int
,	O
&	O
new_term	O
)	O
;	O
ospeed	short
=	O
cfgetospeed	function
(	O
&	O
new_term	O
)	O
;	O
ioctl	function
(	O
TTY_OUTPUT	int
,	O
TCXONC	int
,	O
1	int
)	O
;	O
tcflow	function
(	O
TTY_OUTPUT	pointer
,	O
TCOON	pointer
)	O
;	O
}	O
}	O
void	O
tty_end	function
(	O
)	O
{	O
tcsetattr	function
(	O
TTY_OUTPUT	pointer
,	O
TCSADRAIN	int
,	O
&	O
old_term	O
)	O
;	O
}	O
RETSIGTYPE	void
do_exit	function
(	O
signum	pointer
)	O
int	O
signum	int
;	O
{	O
signal	function
(	O
signum	pointer
,	O
do_exit	int
)	O
;	O
tty_end	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
int	O
main	function
(	O
)	O
{	O
char	O
c	int
;	O
printf	function
(	O
copyright	pointer
,	O
PRODUCT	pointer
,	O
VERSION	pointer
)	O
;	O
signal	function
(	O
SIGTERM	int
,	O
do_exit	int
)	O
;	O
tty_init	function
(	O
)	O
;	O
signal	function
(	O
SIGTSTP	int
,	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGCONT	int
,	O
SIG_IGN	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
read	function
(	O
0	int
,	O
&	O
c	int
,	O
1	int
)	O
;	O
if	O
(	O
c	int
==	O
' '	O
)	O
break	O
;	O
printf	function
(	O
"%x "	pointer
,	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
tty_end	function
(	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
user_heart_attack	int
;	O
static	O
int	O
suspend_requested	int
;	O
static	O
int	O
refresh_requested	int
;	O
static	O
int	O
alarm_requested	int
;	O
static	O
int	O
refresh_at_SIGCONT	int
;	O
static	O
int	O
signals_allowed	int
=	O
OFF	int
;	O
static	O
int	O
job_control	int
=	O
ON	int
;	O
static	O
void	O
install_handler	function
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
extern	O
void	O
hide	function
PROTO	O
(	O
(	O
)	O
)	O
;	O
extern	O
void	O
refresh	function
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
extern	O
void	O
clock_refresh	function
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
void	O
service_pending_signals	function
(	O
)	O
{	O
if	O
(	O
suspend_requested	int
)	O
{	O
hide	function
(	O
)	O
;	O
kill	function
(	O
getpid	function
(	O
)	O
,	O
SIGSTOP	int
)	O
;	O
suspend_requested	int
=	O
0	int
;	O
refresh_requested	int
=	O
0	int
;	O
alarm_requested	int
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
refresh_requested	int
)	O
{	O
tty_defaults	function
(	O
)	O
;	O
tty_io_clear	function
(	O
)	O
;	O
refresh	function
(	O
SIGWINCH	int
)	O
;	O
refresh_requested	int
=	O
0	int
;	O
alarm_requested	int
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
alarm_requested	int
)	O
{	O
alarm_requested	int
=	O
0	int
;	O
return	O
;	O
}	O
}	O
void	O
signals	function
(	O
mode	int
)	O
int	O
mode	int
;	O
{	O
signals_allowed	O
=	O
mode	int
;	O
if	O
(	O
signals_allowed	O
)	O
service_pending_signals	function
(	O
)	O
;	O
}	O
static	O
RETSIGTYPE	function
suspend	O
(	O
signum	pointer
)	O
int	O
signum	int
;	O
{	O
if	O
(	O
signals_allowed	O
)	O
{	O
refresh_at_SIGCONT	int
=	O
(	O
tty_get_mode	function
(	O
)	O
==	O
TTY_NONCANONIC	int
)	O
;	O
hide	function
(	O
)	O
;	O
kill	function
(	O
getpid	function
(	O
)	O
,	O
SIGSTOP	int
)	O
;	O
suspend_requested	int
=	O
0	int
;	O
}	O
else	O
suspend_requested	int
=	O
1	int
;	O
install_handler	function
(	O
signum	pointer
)	O
;	O
}	O
static	O
RETSIGTYPE	bool
window_change	function
(	O
signum	pointer
)	O
int	O
signum	int
;	O
{	O
if	O
(	O
signals_allowed	O
)	O
{	O
tty_defaults	function
(	O
)	O
;	O
tty_io_clear	function
(	O
)	O
;	O
refresh	function
(	O
signum	pointer
)	O
;	O
refresh_requested	int
=	O
0	int
;	O
}	O
else	O
refresh_requested	int
=	O
1	int
;	O
install_handler	function
(	O
signum	pointer
)	O
;	O
}	O
static	O
RETSIGTYPE	bool
resume	function
(	O
signum	pointer
)	O
int	O
signum	int
;	O
{	O
if	O
(	O
refresh_at_SIGCONT	int
)	O
{	O
refresh	function
(	O
signum	pointer
)	O
;	O
refresh_requested	int
=	O
0	int
;	O
}	O
install_handler	function
(	O
signum	pointer
)	O
;	O
}	O
static	O
RETSIGTYPE	bool
time_change	function
(	O
signum	pointer
)	O
int	O
signum	int
;	O
{	O
if	O
(	O
signals_allowed	O
)	O
{	O
if	O
(	O
get_local_time	function
(	O
)	O
->	O
tm_sec	int
==	O
0	int
)	O
clock_refresh	function
(	O
signum	pointer
)	O
;	O
tty_key_print_async	function
(	O
)	O
;	O
alarm_requested	int
=	O
0	int
;	O
}	O
else	O
alarm_requested	int
=	O
1	int
;	O
install_handler	function
(	O
signum	pointer
)	O
;	O
alarm	function
(	O
60	int
-	O
get_local_time	function
(	O
)	O
->	O
tm_sec	int
)	O
;	O
}	O
static	O
RETSIGTYPE	function
panic	function
(	O
signum	pointer
)	O
int	O
signum	int
;	O
{	O
signal	function
(	O
signum	pointer
,	O
panic	function
)	O
;	O
user_heart_attack	int
=	O
1	int
;	O
}	O
static	O
void	O
install_handler	function
(	O
signum	pointer
)	O
int	O
signum	pointer
;	O
{	O
switch	O
(	O
signum	pointer
)	O
{	O
case	O
SIGTSTP	int
:	O
signal	function
(	O
SIGTSTP	int
,	O
suspend	struct
)	O
;	O
break	O
;	O
case	O
SIGCONT	int
:	O
signal	function
(	O
SIGCONT	int
,	O
resume	pointer
)	O
;	O
break	O
;	O
case	O
SIGWINCH	int
:	O
signal	function
(	O
SIGWINCH	int
,	O
window_change	function
)	O
;	O
break	O
;	O
case	O
SIGALRM	int
:	O
signal	function
(	O
SIGALRM	int
,	O
time_change	O
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
void	O
signal_handlers	function
(	O
status	int
)	O
int	O
status	int
;	O
{	O
if	O
(	O
status	int
==	O
ON	int
)	O
{	O
if	O
(	O
job_control	int
)	O
{	O
install_handler	function
(	O
SIGTSTP	int
)	O
;	O
install_handler	function
(	O
SIGCONT	int
)	O
;	O
}	O
install_handler	function
(	O
SIGWINCH	int
)	O
;	O
install_handler	function
(	O
SIGALRM	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
job_control	int
)	O
{	O
signal	function
(	O
SIGTSTP	int
,	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGCONT	int
,	O
SIG_IGN	O
)	O
;	O
}	O
signal	function
(	O
SIGWINCH	int
,	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGALRM	int
,	O
SIG_IGN	O
)	O
;	O
}	O
}	O
void	O
signals_init	function
(	O
)	O
{	O
job_control	pointer
=	O
(	O
signal	function
(	O
SIGTSTP	int
,	O
SIG_IGN	O
)	O
!=	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGCONT	int
,	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGWINCH	int
,	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGSEGV	int
,	O
fatal_signal	pointer
)	O
;	O
signal	function
(	O
SIGHUP	int
,	O
fatal_signal	pointer
)	O
;	O
signal	function
(	O
SIGTERM	int
,	O
fatal_signal	O
)	O
;	O
signal	function
(	O
SIGQUIT	int
,	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGINT	int
,	O
panic	long
)	O
;	O
}	O
window_t	struct
*	O
window_init	function
(	O
)	O
{	O
window_t	struct
*	O
window	pointer
=	O
(	O
window_t	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
window_t	struct
)	O
)	O
;	O
window_resize	function
(	O
window	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
return	O
window	pointer
;	O
}	O
void	O
window_end	function
(	O
window	pointer
)	O
window_t	struct
*	O
window	pointer
;	O
{	O
if	O
(	O
window	pointer
)	O
xfree	function
(	O
window	pointer
)	O
;	O
}	O
void	O
window_resize	function
(	O
window	pointer
,	O
x	double
,	O
y	int
,	O
lines	int
,	O
columns	int
)	O
window_t	struct
*	O
window	pointer
;	O
int	O
x	double
,	O
y	double
,	O
lines	int
,	O
columns	int
;	O
{	O
window	pointer
->	O
x	double
=	O
x	double
;	O
window	pointer
->	O
y	double
=	O
y	double
;	O
window	pointer
->	O
lines	int
=	O
lines	int
;	O
window	pointer
->	O
columns	int
=	O
columns	int
;	O
}	O
int	O
window_puts	function
(	O
window	pointer
,	O
str	pointer
,	O
length	int
)	O
window_t	struct
*	O
window	pointer
;	O
char	O
*	O
str	pointer
;	O
int	O
length	int
;	O
{	O
int	O
x	int
=	O
window	pointer
->	O
cursor_x	int
;	O
window	pointer
->	O
cursor_x	int
+=	O
length	int
;	O
if	O
(	O
x	int
>=	O
window	pointer
->	O
columns	int
)	O
return	O
0	int
;	O
if	O
(	O
window	pointer
->	O
cursor_y	int
>=	O
window	pointer
->	O
lines	int
)	O
return	O
0	int
;	O
if	O
(	O
x	double
+	O
length	int
<=	O
window	pointer
->	O
columns	int
)	O
return	O
tty_puts	function
(	O
str	pointer
,	O
length	int
)	O
;	O
return	O
tty_puts	function
(	O
str	pointer
,	O
window	pointer
->	O
columns	int
-	O
x	int
)	O
;	O
}	O
int	O
window_putc	function
(	O
window	pointer
,	O
c	pointer
)	O
window_t	struct
*	O
window	pointer
;	O
int	O
c	int
;	O
{	O
if	O
(	O
++	O
window	pointer
->	O
cursor_x	int
>	O
window	pointer
->	O
columns	int
)	O
return	O
0	int
;	O
if	O
(	O
window	pointer
->	O
cursor_y	int
>=	O
window	pointer
->	O
lines	int
)	O
return	O
0	int
;	O
return	O
tty_putc	function
(	O
c	int
)	O
;	O
}	O
void	O
window_goto	function
(	O
window	pointer
,	O
y	int
,	O
x	double
)	O
window_t	struct
*	O
window	pointer
;	O
int	O
y	int
,	O
x	double
;	O
{	O
window	pointer
->	O
cursor_x	double
=	O
x	double
;	O
window	pointer
->	O
cursor_y	int
=	O
y	double
;	O
tty_goto	function
(	O
y	double
+	O
window	pointer
->	O
y	double
,	O
x	double
+	O
window	pointer
->	O
x	double
)	O
;	O
}	O
int	O
window_x	function
(	O
window	pointer
)	O
window_t	struct
*	O
window	pointer
;	O
{	O
return	O
window	pointer
->	O
x	double
;	O
}	O
int	O
window_y	function
(	O
window	pointer
)	O
window_t	struct
*	O
window	pointer
;	O
{	O
return	O
window	pointer
->	O
y	int
;	O
}	O
int	O
window_lines	function
(	O
window	pointer
)	O
window_t	struct
*	O
window	pointer
;	O
{	O
return	O
window	pointer
->	O
lines	int
;	O
}	O
int	O
window_columns	function
(	O
window	pointer
)	O
window_t	struct
*	O
window	pointer
;	O
{	O
return	O
window	pointer
->	O
columns	int
;	O
}	O
ARGMATCH_DIE_DECL	struct
;	O
static	O
void	O
__argmatch_die	function
(	O
void	O
)	O
{	O
ARGMATCH_DIE	int
;	O
}	O
argmatch_exit_fn	pointer
argmatch_die	pointer
=	O
__argmatch_die	pointer
;	O
ptrdiff_t	bool
argmatch	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
size_t	long
arglen	long
;	O
ptrdiff_t	long
matchind	long
=	O
-	O
1	int
;	O
bool	bool
ambiguous	bool
=	O
false	int
;	O
arglen	long
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
arglist	array
[	O
i	pointer
]	O
,	O
arg	pointer
,	O
arglen	pointer
)	O
)	O
{	O
if	O
(	O
strlen	function
(	O
arglist	array
[	O
i	long
]	O
)	O
==	O
arglen	pointer
)	O
return	O
i	long
;	O
else	O
if	O
(	O
matchind	int
==	O
-	O
1	int
)	O
matchind	long
=	O
i	long
;	O
else	O
{	O
if	O
(	O
vallist	pointer
==	O
NULL	O
||	O
memcmp	function
(	O
vallist	pointer
+	O
valsize	struct
*	O
matchind	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
{	O
ambiguous	bool
=	O
true	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
ambiguous	pointer
)	O
return	O
-	O
2	int
;	O
else	O
return	O
matchind	pointer
;	O
}	O
void	O
argmatch_invalid	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
ptrdiff_t	long
problem	long
)	O
{	O
char	O
const	O
*	O
format	pointer
=	O
(	O
problem	int
==	O
-	O
1	int
?	O
_	O
(	O
"invalid argument %s for %s"	pointer
)	O
:	O
_	O
(	O
"ambiguous argument %s for %s"	pointer
)	O
)	O
;	O
error	function
(	O
0	int
,	O
0	int
,	O
format	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
ARGMATCH_QUOTING_STYLE	pointer
,	O
value	pointer
)	O
,	O
quote_n	function
(	O
1	int
,	O
context	pointer
)	O
)	O
;	O
}	O
void	O
argmatch_valid	function
(	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
const	O
char	O
*	O
last_val	pointer
=	O
NULL	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Valid arguments are:"	pointer
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
(	O
i	long
==	O
0	int
)	O
||	O
memcmp	function
(	O
last_val	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\n  - `%s'"	pointer
,	O
arglist	array
[	O
i	long
]	O
)	O
;	O
last_val	pointer
=	O
vallist	pointer
+	O
valsize	O
*	O
i	long
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
", `%s'"	pointer
,	O
arglist	array
[	O
i	long
]	O
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
}	O
ptrdiff_t	bool
__xargmatch_internal	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
,	O
argmatch_exit_fn	pointer
exit_fn	pointer
)	O
{	O
ptrdiff_t	long
res	long
=	O
argmatch	function
(	O
arg	pointer
,	O
arglist	int
,	O
vallist	pointer
,	O
valsize	pointer
)	O
;	O
if	O
(	O
res	int
>=	O
0	int
)	O
return	O
res	pointer
;	O
argmatch_invalid	function
(	O
context	pointer
,	O
arg	pointer
,	O
res	pointer
)	O
;	O
argmatch_valid	function
(	O
arglist	int
,	O
vallist	pointer
,	O
valsize	int
)	O
;	O
(	O
*	O
exit_fn	pointer
)	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
const	O
char	O
*	O
argmatch_to_argument	function
(	O
const	O
char	O
*	O
value	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
!	O
memcmp	function
(	O
value	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	int
,	O
valsize	int
)	O
)	O
return	O
arglist	array
[	O
i	long
]	O
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
base_name	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
const	O
*	O
base	pointer
=	O
last_component	function
(	O
name	pointer
)	O
;	O
size_t	long
length	long
;	O
if	O
(	O
!	O
*	O
base	pointer
)	O
return	O
xstrndup	function
(	O
name	pointer
,	O
base_len	function
(	O
name	pointer
)	O
)	O
;	O
length	long
=	O
base_len	function
(	O
base	pointer
)	O
;	O
if	O
(	O
ISSLASH	O
(	O
base	pointer
[	O
length	long
]	O
)	O
)	O
length	long
++	O
;	O
if	O
(	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
base	pointer
)	O
)	O
{	O
char	O
*	O
p	pointer
=	O
xmalloc	function
(	O
length	long
+	O
3	int
)	O
;	O
p	pointer
[	O
0	int
]	O
=	O
'.'	O
;	O
p	pointer
[	O
1	int
]	O
=	O
'/'	O
;	O
memcpy	function
(	O
p	pointer
+	O
2	int
,	O
base	pointer
,	O
length	long
)	O
;	O
p	pointer
[	O
length	long
+	O
2	int
]	O
=	O
'\0'	O
;	O
return	O
p	pointer
;	O
}	O
return	O
xstrndup	function
(	O
base	pointer
,	O
length	long
)	O
;	O
}	O
int	O
c_strncasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
,	O
size_t	long
n	long
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
||	O
n	long
==	O
0	int
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
--	O
n	long
==	O
0	int
||	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
int	O
close_stream	function
(	O
FILE	struct
*	O
stream	pointer
)	O
{	O
const	O
bool	bool
some_pending	bool
=	O
(	O
__fpending	function
(	O
stream	pointer
)	O
!=	O
0	int
)	O
;	O
const	O
bool	bool
prev_fail	bool
=	O
(	O
ferror	function
(	O
stream	pointer
)	O
!=	O
0	int
)	O
;	O
const	O
bool	bool
fclose_fail	bool
=	O
(	O
fclose	function
(	O
stream	pointer
)	O
!=	O
0	int
)	O
;	O
if	O
(	O
prev_fail	bool
||	O
(	O
fclose_fail	bool
&&	O
(	O
some_pending	bool
||	O
errno	O
!=	O
EBADF	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
fclose_fail	bool
)	O
errno	O
=	O
0	int
;	O
return	O
EOF	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
file_name	pointer
;	O
void	O
close_stdout_set_file_name	function
(	O
const	O
char	O
*	O
file	pointer
)	O
{	O
file_name	pointer
=	O
file	pointer
;	O
}	O
static	O
bool	bool
ignore_EPIPE	bool
;	O
void	O
close_stdout_set_ignore_EPIPE	function
(	O
bool	bool
ignore	bool
)	O
{	O
ignore_EPIPE	bool
=	O
ignore	bool
;	O
}	O
void	O
close_stdout	function
(	O
void	O
)	O
{	O
if	O
(	O
close_stream	function
(	O
stdout	pointer
)	O
!=	O
0	int
&&	O
!	O
(	O
ignore_EPIPE	bool
&&	O
errno	O
==	O
EPIPE	int
)	O
)	O
{	O
char	O
const	O
*	O
write_error	pointer
=	O
_	O
(	O
"write error"	pointer
)	O
;	O
if	O
(	O
file_name	pointer
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s: %s"	pointer
,	O
quotearg_colon	function
(	O
file_name	pointer
)	O
,	O
write_error	pointer
)	O
;	O
else	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
write_error	pointer
)	O
;	O
_exit	function
(	O
exit_failure	int
)	O
;	O
}	O
if	O
(	O
close_stream	function
(	O
stderr	pointer
)	O
!=	O
0	int
)	O
_exit	function
(	O
exit_failure	int
)	O
;	O
}	O
static	O
bool	bool
mbsstr_trimmed_wordbounded	bool
(	O
const	O
char	O
*	O
string	pointer
,	O
const	O
char	O
*	O
sub	pointer
)	O
{	O
char	O
*	O
tsub	pointer
=	O
trim	O
(	O
sub	pointer
)	O
;	O
bool	bool
found	bool
=	O
false	int
;	O
for	O
(	O
;	O
*	O
string	pointer
!=	O
'\0'	O
;	O
)	O
{	O
const	O
char	O
*	O
tsub_in_string	pointer
=	O
mbsstr	function
(	O
string	pointer
,	O
tsub	pointer
)	O
;	O
if	O
(	O
tsub_in_string	pointer
==	O
NULL	O
)	O
break	O
;	O
else	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
)	O
{	O
mbui_iterator_t	struct
string_iter	struct
;	O
bool	bool
word_boundary_before	bool
;	O
bool	bool
word_boundary_after	bool
;	O
mbui_init	O
(	O
string_iter	struct
,	O
string	pointer
)	O
;	O
word_boundary_before	bool
=	O
true	int
;	O
if	O
(	O
mbui_cur_ptr	O
(	O
string_iter	struct
)	O
<	O
tsub_in_string	pointer
)	O
{	O
mbchar_t	struct
last_char_before_tsub	struct
;	O
do	O
{	O
if	O
(	O
!	O
mbui_avail	O
(	O
string_iter	struct
)	O
)	O
abort	function
(	O
)	O
;	O
last_char_before_tsub	struct
=	O
mbui_cur	O
(	O
string_iter	struct
)	O
;	O
mbui_advance	O
(	O
string_iter	struct
)	O
;	O
}	O
while	O
(	O
mbui_cur_ptr	O
(	O
string_iter	struct
)	O
<	O
tsub_in_string	pointer
)	O
;	O
if	O
(	O
mb_isalnum	O
(	O
last_char_before_tsub	struct
)	O
)	O
word_boundary_before	bool
=	O
false	int
;	O
}	O
mbui_init	O
(	O
string_iter	struct
,	O
tsub_in_string	pointer
)	O
;	O
{	O
mbui_iterator_t	struct
tsub_iter	struct
;	O
for	O
(	O
mbui_init	O
(	O
tsub_iter	struct
,	O
tsub	pointer
)	O
;	O
mbui_avail	O
(	O
tsub_iter	struct
)	O
;	O
mbui_advance	O
(	O
tsub_iter	struct
)	O
)	O
{	O
if	O
(	O
!	O
mbui_avail	O
(	O
string_iter	struct
)	O
)	O
abort	function
(	O
)	O
;	O
mbui_advance	O
(	O
string_iter	struct
)	O
;	O
}	O
}	O
word_boundary_after	bool
=	O
true	int
;	O
if	O
(	O
mbui_avail	O
(	O
string_iter	struct
)	O
)	O
{	O
mbchar_t	struct
first_char_after_tsub	struct
=	O
mbui_cur	O
(	O
string_iter	struct
)	O
;	O
if	O
(	O
mb_isalnum	O
(	O
first_char_after_tsub	struct
)	O
)	O
word_boundary_after	bool
=	O
false	int
;	O
}	O
if	O
(	O
word_boundary_before	bool
&&	O
word_boundary_after	bool
)	O
{	O
found	bool
=	O
true	int
;	O
break	O
;	O
}	O
mbui_init	O
(	O
string_iter	struct
,	O
tsub_in_string	pointer
)	O
;	O
if	O
(	O
!	O
mbui_avail	O
(	O
string_iter	struct
)	O
)	O
break	O
;	O
string	pointer
=	O
tsub_in_string	pointer
+	O
mb_len	O
(	O
mbui_cur	O
(	O
string_iter	struct
)	O
)	O
;	O
}	O
else	O
{	O
bool	bool
word_boundary_before	bool
;	O
const	O
char	O
*	O
p	pointer
;	O
bool	bool
word_boundary_after	bool
;	O
word_boundary_before	bool
=	O
true	int
;	O
if	O
(	O
string	pointer
<	O
tsub_in_string	pointer
)	O
if	O
(	O
isalnum	function
(	O
(	O
unsigned	O
char	O
)	O
tsub_in_string	pointer
[	O
-	O
1	int
]	O
)	O
)	O
word_boundary_before	bool
=	O
false	int
;	O
p	pointer
=	O
tsub_in_string	pointer
+	O
strlen	function
(	O
tsub	pointer
)	O
;	O
word_boundary_after	bool
=	O
true	int
;	O
if	O
(	O
*	O
p	pointer
!=	O
'\0'	O
)	O
if	O
(	O
isalnum	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
)	O
word_boundary_after	bool
=	O
false	int
;	O
if	O
(	O
word_boundary_before	bool
&&	O
word_boundary_after	bool
)	O
{	O
found	bool
=	O
true	int
;	O
break	O
;	O
}	O
if	O
(	O
*	O
tsub_in_string	pointer
==	O
'\0'	O
)	O
break	O
;	O
string	pointer
=	O
tsub_in_string	pointer
+	O
1	int
;	O
}	O
}	O
}	O
free	function
(	O
tsub	pointer
)	O
;	O
return	O
found	enum
;	O
}	O
const	O
char	O
*	O
proper_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
const	O
char	O
*	O
translation	pointer
=	O
gettext	function
(	O
name	pointer
)	O
;	O
if	O
(	O
translation	pointer
!=	O
name	pointer
)	O
{	O
if	O
(	O
mbsstr_trimmed_wordbounded	function
(	O
translation	pointer
,	O
name	pointer
)	O
)	O
return	O
translation	pointer
;	O
else	O
{	O
char	O
*	O
result	pointer
=	O
XNMALLOC	O
(	O
strlen	function
(	O
translation	pointer
)	O
+	O
2	int
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
+	O
1	int
,	O
char	O
)	O
;	O
sprintf	function
(	O
result	pointer
,	O
"%s (%s)"	pointer
,	O
translation	pointer
,	O
name	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
}	O
else	O
return	O
name	pointer
;	O
}	O
const	O
char	O
*	O
proper_name_utf8	function
(	O
const	O
char	O
*	O
name_ascii	pointer
,	O
const	O
char	O
*	O
name_utf8	pointer
)	O
{	O
const	O
char	O
*	O
translation	pointer
=	O
gettext	function
(	O
name_ascii	pointer
)	O
;	O
const	O
char	O
*	O
locale_code	pointer
=	O
locale_charset	function
(	O
)	O
;	O
char	O
*	O
alloc_name_converted	pointer
=	O
NULL	O
;	O
char	O
*	O
alloc_name_converted_translit	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
name_converted	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
name_converted_translit	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
c_strcasecmp	function
(	O
locale_code	pointer
,	O
"UTF-8"	pointer
)	O
!=	O
0	int
)	O
{	O
name_converted	pointer
=	O
alloc_name_converted	pointer
=	O
xstr_iconv	function
(	O
name_utf8	pointer
,	O
"UTF-8"	pointer
,	O
locale_code	pointer
)	O
;	O
{	O
char	O
*	O
converted_translit	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
locale_code	pointer
)	O
;	O
char	O
*	O
locale_code_translit	pointer
=	O
XNMALLOC	O
(	O
len	long
+	O
10	int
+	O
1	int
,	O
char	O
)	O
;	O
memcpy	function
(	O
locale_code_translit	pointer
,	O
locale_code	pointer
,	O
len	long
)	O
;	O
memcpy	function
(	O
locale_code_translit	pointer
+	O
len	long
,	O
"//TRANSLIT"	pointer
,	O
10	int
+	O
1	int
)	O
;	O
converted_translit	pointer
=	O
xstr_iconv	function
(	O
name_utf8	pointer
,	O
"UTF-8"	pointer
,	O
locale_code_translit	pointer
)	O
;	O
free	function
(	O
locale_code_translit	pointer
)	O
;	O
if	O
(	O
converted_translit	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strchr	function
(	O
converted_translit	pointer
,	O
'?'	O
)	O
!=	O
NULL	O
)	O
free	function
(	O
converted_translit	pointer
)	O
;	O
else	O
name_converted_translit	pointer
=	O
alloc_name_converted_translit	pointer
=	O
converted_translit	pointer
;	O
}	O
}	O
}	O
else	O
{	O
name_converted	pointer
=	O
name_utf8	pointer
;	O
name_converted_translit	pointer
=	O
name_utf8	pointer
;	O
}	O
name	pointer
=	O
(	O
name_converted	pointer
!=	O
NULL	O
?	O
name_converted	pointer
:	O
name_converted_translit	pointer
!=	O
NULL	O
?	O
name_converted_translit	pointer
:	O
name_ascii	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
translation	pointer
,	O
name_ascii	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
mbsstr_trimmed_wordbounded	function
(	O
translation	pointer
,	O
name_ascii	pointer
)	O
||	O
(	O
name_converted	pointer
!=	O
NULL	O
&&	O
mbsstr_trimmed_wordbounded	function
(	O
translation	pointer
,	O
name_converted	pointer
)	O
)	O
||	O
(	O
name_converted_translit	pointer
!=	O
NULL	O
&&	O
mbsstr_trimmed_wordbounded	function
(	O
translation	pointer
,	O
name_converted_translit	pointer
)	O
)	O
)	O
{	O
if	O
(	O
alloc_name_converted	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc_name_converted	pointer
)	O
;	O
if	O
(	O
alloc_name_converted_translit	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc_name_converted_translit	pointer
)	O
;	O
return	O
translation	pointer
;	O
}	O
else	O
{	O
char	O
*	O
result	pointer
=	O
XNMALLOC	O
(	O
strlen	function
(	O
translation	pointer
)	O
+	O
2	int
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
+	O
1	int
,	O
char	O
)	O
;	O
sprintf	function
(	O
result	pointer
,	O
"%s (%s)"	pointer
,	O
translation	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
alloc_name_converted	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc_name_converted	pointer
)	O
;	O
if	O
(	O
alloc_name_converted_translit	pointer
!=	O
NULL	O
)	O
free	function
(	O
alloc_name_converted_translit	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
}	O
else	O
{	O
if	O
(	O
alloc_name_converted	pointer
!=	O
NULL	O
&&	O
alloc_name_converted	pointer
!=	O
name	pointer
)	O
free	function
(	O
alloc_name_converted	pointer
)	O
;	O
if	O
(	O
alloc_name_converted_translit	pointer
!=	O
NULL	O
&&	O
alloc_name_converted_translit	pointer
!=	O
name	pointer
)	O
free	function
(	O
alloc_name_converted_translit	pointer
)	O
;	O
return	O
name	pointer
;	O
}	O
}	O
size_t	long
strnlen1	function
(	O
const	O
char	O
*	O
string	pointer
,	O
size_t	long
maxlen	long
)	O
{	O
const	O
char	O
*	O
end	pointer
=	O
(	O
const	O
char	O
*	O
)	O
memchr	function
(	O
string	pointer
,	O
'\0'	O
,	O
maxlen	long
)	O
;	O
if	O
(	O
end	pointer
!=	O
NULL	O
)	O
return	O
end	pointer
-	O
string	pointer
+	O
1	int
;	O
else	O
return	O
maxlen	long
;	O
}	O
static	O
strtol_error	enum
bkm_scale	function
(	O
__strtol_t	O
*	O
x	pointer
,	O
int	O
scale_factor	int
)	O
{	O
if	O
(	O
TYPE_SIGNED	O
(	O
__strtol_t	O
)	O
&&	O
*	O
x	pointer
<	O
STRTOL_T_MINIMUM	O
/	O
scale_factor	int
)	O
{	O
*	O
x	pointer
=	O
STRTOL_T_MINIMUM	O
;	O
return	O
LONGINT_OVERFLOW	int
;	O
}	O
if	O
(	O
STRTOL_T_MAXIMUM	O
/	O
scale_factor	int
<	O
*	O
x	pointer
)	O
{	O
*	O
x	pointer
=	O
STRTOL_T_MAXIMUM	O
;	O
return	O
LONGINT_OVERFLOW	int
;	O
}	O
*	O
x	pointer
*=	O
scale_factor	int
;	O
return	O
LONGINT_OK	int
;	O
}	O
static	O
strtol_error	enum
bkm_scale_by_power	function
(	O
__strtol_t	O
*	O
x	pointer
,	O
int	O
base	int
,	O
int	O
power	int
)	O
{	O
strtol_error	enum
err	enum
=	O
LONGINT_OK	int
;	O
while	O
(	O
power	int
--	O
)	O
err	enum
|=	O
bkm_scale	function
(	O
x	pointer
,	O
base	int
)	O
;	O
return	O
err	enum
;	O
}	O
strtol_error	enum
__xstrtol	O
(	O
const	O
char	O
*	O
s	pointer
,	O
char	O
*	O
*	O
ptr	pointer
,	O
int	O
strtol_base	int
,	O
__strtol_t	O
*	O
val	int
,	O
const	O
char	O
*	O
valid_suffixes	pointer
)	O
{	O
char	O
*	O
t_ptr	pointer
;	O
char	O
*	O
*	O
p	pointer
;	O
__strtol_t	O
tmp	long
;	O
strtol_error	enum
err	enum
=	O
LONGINT_OK	int
;	O
assert	O
(	O
0	int
<=	O
strtol_base	int
&&	O
strtol_base	int
<=	O
36	int
)	O
;	O
p	pointer
=	O
(	O
ptr	pointer
?	O
ptr	pointer
:	O
&	O
t_ptr	pointer
)	O
;	O
if	O
(	O
!	O
TYPE_SIGNED	O
(	O
__strtol_t	O
)	O
)	O
{	O
const	O
char	O
*	O
q	pointer
=	O
s	pointer
;	O
unsigned	O
char	O
ch	char
=	O
*	O
q	pointer
;	O
while	O
(	O
isspace	function
(	O
ch	char
)	O
)	O
ch	char
=	O
*	O
++	O
q	pointer
;	O
if	O
(	O
ch	char
==	O
'-'	O
)	O
return	O
LONGINT_INVALID	int
;	O
}	O
errno	O
=	O
0	int
;	O
tmp	long
=	O
__strtol	O
(	O
s	pointer
,	O
p	pointer
,	O
strtol_base	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
s	pointer
)	O
{	O
if	O
(	O
valid_suffixes	pointer
&&	O
*	O
*	O
p	pointer
&&	O
strchr	function
(	O
valid_suffixes	pointer
,	O
*	O
*	O
p	pointer
)	O
)	O
tmp	long
=	O
1	int
;	O
else	O
return	O
LONGINT_INVALID	int
;	O
}	O
else	O
if	O
(	O
errno	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
ERANGE	int
)	O
return	O
LONGINT_INVALID	int
;	O
err	enum
=	O
LONGINT_OVERFLOW	int
;	O
}	O
if	O
(	O
!	O
valid_suffixes	pointer
)	O
{	O
*	O
val	int
=	O
tmp	long
;	O
return	O
err	enum
;	O
}	O
if	O
(	O
*	O
*	O
p	pointer
!=	O
'\0'	O
)	O
{	O
int	O
base	int
=	O
1024	int
;	O
int	O
suffixes	int
=	O
1	int
;	O
strtol_error	enum
overflow	enum
;	O
if	O
(	O
!	O
strchr	function
(	O
valid_suffixes	pointer
,	O
*	O
*	O
p	pointer
)	O
)	O
{	O
*	O
val	int
=	O
tmp	long
;	O
return	O
err	enum
|	O
LONGINT_INVALID_SUFFIX_CHAR	int
;	O
}	O
if	O
(	O
strchr	function
(	O
valid_suffixes	pointer
,	O
'0'	O
)	O
)	O
{	O
switch	O
(	O
p	pointer
[	O
0	int
]	O
[	O
1	int
]	O
)	O
{	O
case	O
'i'	O
:	O
if	O
(	O
p	pointer
[	O
0	int
]	O
[	O
2	int
]	O
==	O
'B'	O
)	O
suffixes	int
+=	O
2	int
;	O
break	O
;	O
case	O
'B'	O
:	O
case	O
'D'	O
:	O
base	int
=	O
1000	int
;	O
suffixes	int
++	O
;	O
break	O
;	O
}	O
}	O
switch	O
(	O
*	O
*	O
p	pointer
)	O
{	O
case	O
'b'	O
:	O
overflow	enum
=	O
bkm_scale	function
(	O
&	O
tmp	long
,	O
512	int
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
overflow	enum
=	O
bkm_scale	function
(	O
&	O
tmp	long
,	O
1024	int
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
overflow	enum
=	O
0	int
;	O
break	O
;	O
case	O
'E'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
6	int
)	O
;	O
break	O
;	O
case	O
'G'	O
:	O
case	O
'g'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
3	int
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
case	O
'K'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
case	O
'm'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
2	int
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
5	int
)	O
;	O
break	O
;	O
case	O
'T'	O
:	O
case	O
't'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
4	int
)	O
;	O
break	O
;	O
case	O
'w'	O
:	O
overflow	enum
=	O
bkm_scale	function
(	O
&	O
tmp	long
,	O
2	int
)	O
;	O
break	O
;	O
case	O
'Y'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
8	int
)	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
overflow	enum
=	O
bkm_scale_by_power	function
(	O
&	O
tmp	long
,	O
base	int
,	O
7	int
)	O
;	O
break	O
;	O
default	O
:	O
*	O
val	int
=	O
tmp	long
;	O
return	O
err	enum
|	O
LONGINT_INVALID_SUFFIX_CHAR	int
;	O
}	O
err	enum
|=	O
overflow	enum
;	O
*	O
p	pointer
+=	O
suffixes	int
;	O
if	O
(	O
*	O
*	O
p	pointer
)	O
err	enum
|=	O
LONGINT_INVALID_SUFFIX_CHAR	int
;	O
}	O
*	O
val	int
=	O
tmp	long
;	O
return	O
err	enum
;	O
}	O
typedef	O
struct	O
{	O
double	O
*	O
k	pointer
;	O
double	O
*	O
y0	function
;	O
double	O
*	O
y0_orig	pointer
;	O
double	O
*	O
y_onestep	pointer
;	O
}	O
gear1_state_t	struct
;	O
static	O
void	O
*	O
gear1_alloc	function
(	O
size_t	long
dim	long
)	O
{	O
gear1_state_t	struct
*	O
state	pointer
=	O
(	O
gear1_state_t	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gear1_state_t	struct
)	O
)	O
;	O
if	O
(	O
state	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for gear1_state"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
k	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
k	pointer
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for k"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
y0	function
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
y0	function
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
->	O
k	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for y0"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
y0_orig	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
y0_orig	pointer
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
->	O
y0	function
)	O
;	O
free	function
(	O
state	pointer
->	O
k	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for y0_orig"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
y_onestep	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
y_onestep	pointer
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
->	O
y0_orig	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
y0	function
)	O
;	O
free	function
(	O
state	pointer
->	O
k	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for y_onestep"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
state	pointer
;	O
}	O
static	O
int	O
gear1_step	function
(	O
double	O
*	O
y	double
,	O
gear1_state_t	struct
*	O
state	pointer
,	O
const	O
double	O
h	double
,	O
const	O
double	O
t	double
,	O
const	O
size_t	long
dim	long
,	O
const	O
gsl_odeiv_system	struct
*	O
sys	pointer
)	O
{	O
const	O
int	O
iter_steps	int
=	O
3	int
;	O
int	O
nu	int
;	O
size_t	long
i	long
;	O
double	O
*	O
y0	function
=	O
state	pointer
->	O
y0	function
;	O
double	O
*	O
k	pointer
=	O
state	pointer
->	O
k	int
;	O
for	O
(	O
nu	int
=	O
0	int
;	O
nu	int
<	O
iter_steps	int
;	O
nu	int
++	O
)	O
{	O
int	O
s	pointer
=	O
GSL_ODEIV_FN_EVAL	O
(	O
sys	pointer
,	O
t	double
+	O
h	double
,	O
y	double
,	O
k	int
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
return	O
s	pointer
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
y	double
[	O
i	long
]	O
=	O
y0	function
[	O
i	long
]	O
+	O
h	double
*	O
k	pointer
[	O
i	long
]	O
;	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
gear1_apply	function
(	O
void	O
*	O
vstate	pointer
,	O
size_t	long
dim	long
,	O
double	O
t	double
,	O
double	O
h	double
,	O
double	O
y	array
[	O
]	O
,	O
double	O
yerr	array
[	O
]	O
,	O
const	O
double	O
dydt_in	array
[	O
]	O
,	O
double	O
dydt_out	array
[	O
]	O
,	O
const	O
gsl_odeiv_system	struct
*	O
sys	pointer
)	O
{	O
gear1_state_t	struct
*	O
state	pointer
=	O
(	O
gear1_state_t	struct
*	O
)	O
vstate	pointer
;	O
size_t	long
i	long
;	O
double	O
*	O
y0	function
=	O
state	pointer
->	O
y0	function
;	O
double	O
*	O
y0_orig	pointer
=	O
state	pointer
->	O
y0_orig	pointer
;	O
double	O
*	O
y_onestep	pointer
=	O
state	pointer
->	O
y_onestep	pointer
;	O
DBL_MEMCPY	O
(	O
y0	function
,	O
y	double
,	O
dim	long
)	O
;	O
DBL_MEMCPY	O
(	O
y0_orig	pointer
,	O
y	double
,	O
dim	long
)	O
;	O
DBL_MEMCPY	O
(	O
y_onestep	pointer
,	O
y	double
,	O
dim	long
)	O
;	O
{	O
int	O
s	pointer
=	O
gear1_step	function
(	O
y_onestep	pointer
,	O
state	pointer
,	O
h	double
,	O
t	double
,	O
dim	long
,	O
sys	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
return	O
s	pointer
;	O
}	O
}	O
{	O
int	O
s	pointer
=	O
gear1_step	function
(	O
y	double
,	O
state	pointer
,	O
h	double
/	O
2.0	int
,	O
t	double
,	O
dim	long
,	O
sys	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
DBL_MEMCPY	O
(	O
y	double
,	O
y0_orig	pointer
,	O
dim	long
)	O
;	O
return	O
s	pointer
;	O
}	O
}	O
DBL_MEMCPY	O
(	O
y0	function
,	O
y	double
,	O
dim	long
)	O
;	O
{	O
int	O
s	pointer
=	O
gear1_step	function
(	O
y	double
,	O
state	pointer
,	O
h	double
/	O
2.0	int
,	O
t	double
+	O
h	double
/	O
2.0	int
,	O
dim	long
,	O
sys	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
DBL_MEMCPY	O
(	O
y	double
,	O
y0_orig	pointer
,	O
dim	long
)	O
;	O
return	O
s	pointer
;	O
}	O
}	O
if	O
(	O
dydt_out	array
!=	O
NULL	O
)	O
{	O
int	O
s	pointer
=	O
GSL_ODEIV_FN_EVAL	O
(	O
sys	pointer
,	O
t	double
+	O
h	double
,	O
y	double
,	O
dydt_out	array
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
DBL_MEMCPY	O
(	O
y	double
,	O
y0_orig	pointer
,	O
dim	long
)	O
;	O
return	O
s	pointer
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
yerr	array
[	O
i	long
]	O
=	O
4.0	int
*	O
(	O
y	double
[	O
i	long
]	O
-	O
y_onestep	pointer
[	O
i	long
]	O
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
gear1_reset	function
(	O
void	O
*	O
vstate	pointer
,	O
size_t	long
dim	long
)	O
{	O
gear1_state_t	struct
*	O
state	pointer
=	O
(	O
gear1_state_t	struct
*	O
)	O
vstate	pointer
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
y_onestep	pointer
,	O
dim	long
)	O
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
y0_orig	pointer
,	O
dim	long
)	O
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
y0	function
,	O
dim	long
)	O
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
k	pointer
,	O
dim	long
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
unsigned	O
int	O
gear1_order	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
gear1_state_t	struct
*	O
state	pointer
=	O
(	O
gear1_state_t	struct
*	O
)	O
vstate	pointer
;	O
state	pointer
=	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
gear1_free	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
gear1_state_t	struct
*	O
state	pointer
=	O
(	O
gear1_state_t	struct
*	O
)	O
vstate	pointer
;	O
free	function
(	O
state	pointer
->	O
y_onestep	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
y0_orig	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
y0	function
)	O
;	O
free	function
(	O
state	pointer
->	O
k	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
}	O
static	O
const	O
gsl_odeiv_step_type	struct
gear1_type	struct
=	O
{	O
"gear1"	pointer
,	O
0	int
,	O
1	int
,	O
&	O
gear1_alloc	function
,	O
&	O
gear1_apply	function
,	O
&	O
gear1_reset	function
,	O
&	O
gear1_order	function
,	O
&	O
gear1_free	function
}	O
;	O
const	O
gsl_odeiv_step_type	struct
*	O
gsl_odeiv_step_gear1	pointer
=	O
&	O
gear1_type	struct
;	O
typedef	O
struct	O
{	O
double	O
*	O
k1	pointer
;	O
double	O
*	O
k2	pointer
;	O
double	O
*	O
k3	pointer
;	O
double	O
*	O
ytmp	pointer
;	O
}	O
rk2_state_t	struct
;	O
static	O
void	O
*	O
rk2_alloc	function
(	O
size_t	long
dim	long
)	O
{	O
rk2_state_t	struct
*	O
state	pointer
=	O
(	O
rk2_state_t	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
rk2_state_t	struct
)	O
)	O
;	O
if	O
(	O
state	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for rk2_state"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
k1	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
k1	pointer
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for k1"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
k2	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
k2	pointer
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
->	O
k1	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for k2"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
k3	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
k3	pointer
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
->	O
k2	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
k1	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for k3"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
ytmp	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
ytmp	pointer
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
->	O
k3	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
k2	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
k1	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for ytmp"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
state	pointer
;	O
}	O
static	O
int	O
rk2_apply	function
(	O
void	O
*	O
vstate	pointer
,	O
size_t	long
dim	long
,	O
double	O
t	double
,	O
double	O
h	double
,	O
double	O
y	array
[	O
]	O
,	O
double	O
yerr	array
[	O
]	O
,	O
const	O
double	O
dydt_in	array
[	O
]	O
,	O
double	O
dydt_out	array
[	O
]	O
,	O
const	O
gsl_odeiv_system	struct
*	O
sys	pointer
)	O
{	O
rk2_state_t	struct
*	O
state	pointer
=	O
(	O
rk2_state_t	struct
*	O
)	O
vstate	pointer
;	O
size_t	long
i	long
;	O
double	O
*	O
const	O
k1	pointer
=	O
state	pointer
->	O
k1	pointer
;	O
double	O
*	O
const	O
k2	pointer
=	O
state	pointer
->	O
k2	pointer
;	O
double	O
*	O
const	O
k3	pointer
=	O
state	pointer
->	O
k3	pointer
;	O
double	O
*	O
const	O
ytmp	pointer
=	O
state	pointer
->	O
ytmp	pointer
;	O
if	O
(	O
dydt_in	array
!=	O
NULL	O
)	O
{	O
DBL_MEMCPY	O
(	O
k1	pointer
,	O
dydt_in	array
,	O
dim	long
)	O
;	O
}	O
else	O
{	O
int	O
s	pointer
=	O
GSL_ODEIV_FN_EVAL	O
(	O
sys	pointer
,	O
t	double
,	O
y	double
,	O
k1	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
return	O
s	pointer
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
ytmp	pointer
[	O
i	long
]	O
=	O
y	array
[	O
i	long
]	O
+	O
0.5	int
*	O
h	double
*	O
k1	pointer
[	O
i	long
]	O
;	O
}	O
{	O
int	O
s	pointer
=	O
GSL_ODEIV_FN_EVAL	O
(	O
sys	pointer
,	O
t	double
+	O
0.5	int
*	O
h	double
,	O
ytmp	pointer
,	O
k2	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
return	O
s	pointer
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
ytmp	pointer
[	O
i	long
]	O
=	O
y	array
[	O
i	long
]	O
+	O
h	double
*	O
(	O
-	O
k1	pointer
[	O
i	long
]	O
+	O
2.0	int
*	O
k2	pointer
[	O
i	long
]	O
)	O
;	O
}	O
{	O
int	O
s	pointer
=	O
GSL_ODEIV_FN_EVAL	O
(	O
sys	pointer
,	O
t	double
+	O
h	double
,	O
ytmp	pointer
,	O
k3	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
return	O
s	pointer
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
ytmp	pointer
[	O
i	long
]	O
=	O
y	array
[	O
i	long
]	O
;	O
{	O
const	O
double	O
ksum3	double
=	O
(	O
k1	pointer
[	O
i	long
]	O
+	O
4.0	int
*	O
k2	pointer
[	O
i	long
]	O
+	O
k3	pointer
[	O
i	long
]	O
)	O
/	O
6.0	int
;	O
y	array
[	O
i	long
]	O
+=	O
h	double
*	O
ksum3	double
;	O
}	O
}	O
if	O
(	O
dydt_out	array
!=	O
NULL	O
)	O
{	O
int	O
s	pointer
=	O
GSL_ODEIV_FN_EVAL	O
(	O
sys	pointer
,	O
t	double
+	O
h	double
,	O
y	double
,	O
dydt_out	array
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
DBL_MEMCPY	O
(	O
y	double
,	O
ytmp	pointer
,	O
dim	long
)	O
;	O
return	O
s	pointer
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
const	O
double	O
ksum3	double
=	O
(	O
k1	pointer
[	O
i	long
]	O
+	O
4.0	int
*	O
k2	pointer
[	O
i	long
]	O
+	O
k3	pointer
[	O
i	long
]	O
)	O
/	O
6.0	int
;	O
yerr	array
[	O
i	long
]	O
=	O
h	double
*	O
(	O
k2	pointer
[	O
i	long
]	O
-	O
ksum3	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
rk2_reset	function
(	O
void	O
*	O
vstate	pointer
,	O
size_t	long
dim	long
)	O
{	O
rk2_state_t	struct
*	O
state	pointer
=	O
(	O
rk2_state_t	struct
*	O
)	O
vstate	pointer
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
k1	pointer
,	O
dim	long
)	O
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
k2	pointer
,	O
dim	long
)	O
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
k3	pointer
,	O
dim	long
)	O
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
ytmp	pointer
,	O
dim	long
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
unsigned	O
int	O
rk2_order	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
rk2_state_t	struct
*	O
state	pointer
=	O
(	O
rk2_state_t	struct
*	O
)	O
vstate	pointer
;	O
state	pointer
=	O
0	int
;	O
return	O
2	int
;	O
}	O
static	O
void	O
rk2_free	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
rk2_state_t	struct
*	O
state	pointer
=	O
(	O
rk2_state_t	struct
*	O
)	O
vstate	pointer
;	O
free	function
(	O
state	pointer
->	O
k1	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
k2	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
k3	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
ytmp	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
}	O
static	O
const	O
gsl_odeiv_step_type	struct
rk2_type	struct
=	O
{	O
"rk2"	pointer
,	O
1	int
,	O
1	int
,	O
&	O
rk2_alloc	function
,	O
&	O
rk2_apply	function
,	O
&	O
rk2_reset	function
,	O
&	O
rk2_order	function
,	O
&	O
rk2_free	function
}	O
;	O
const	O
gsl_odeiv_step_type	struct
*	O
gsl_odeiv_step_rk2	pointer
=	O
&	O
rk2_type	struct
;	O
void	O
cblas_cgbmv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
TransA	enum
,	O
const	O
int	O
M	int
,	O
const	O
int	O
N	int
,	O
const	O
int	O
KL	int
,	O
const	O
int	O
KU	int
,	O
const	O
void	O
*	O
alpha	enum
,	O
const	O
void	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
const	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
const	O
void	O
*	O
beta	enum
,	O
void	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
)	O
{	O
}	O
void	O
cblas_cgeru	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
int	O
M	int
,	O
const	O
int	O
N	int
,	O
const	O
void	O
*	O
alpha	enum
,	O
const	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
const	O
void	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
,	O
void	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
)	O
{	O
}	O
void	O
cblas_cher	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
int	O
N	int
,	O
const	O
float	O
alpha	enum
,	O
const	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
void	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
)	O
{	O
}	O
void	O
cblas_cherk	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
Order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
Trans	enum
,	O
const	O
int	O
N	int
,	O
const	O
int	O
K	int
,	O
const	O
float	O
alpha	enum
,	O
const	O
void	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
const	O
float	O
beta	enum
,	O
void	O
*	O
C	pointer
,	O
const	O
int	O
ldc	int
)	O
{	O
}	O
void	O
cblas_chpr	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
int	O
N	int
,	O
const	O
float	O
alpha	enum
,	O
const	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
void	O
*	O
Ap	pointer
)	O
{	O
}	O
void	O
cblas_chpr2	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
int	O
N	int
,	O
const	O
void	O
*	O
alpha	enum
,	O
const	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
const	O
void	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
,	O
void	O
*	O
Ap	pointer
)	O
{	O
}	O
void	O
cblas_cscal	function
(	O
const	O
int	O
N	int
,	O
const	O
void	O
*	O
alpha	enum
,	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
void	O
cblas_csyr2k	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
Order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
Trans	enum
,	O
const	O
int	O
N	int
,	O
const	O
int	O
K	int
,	O
const	O
void	O
*	O
alpha	enum
,	O
const	O
void	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
const	O
void	O
*	O
B	pointer
,	O
const	O
int	O
ldb	int
,	O
const	O
void	O
*	O
beta	enum
,	O
void	O
*	O
C	pointer
,	O
const	O
int	O
ldc	int
)	O
{	O
}	O
void	O
cblas_csyrk	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
Order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
Trans	enum
,	O
const	O
int	O
N	int
,	O
const	O
int	O
K	int
,	O
const	O
void	O
*	O
alpha	enum
,	O
const	O
void	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
const	O
void	O
*	O
beta	enum
,	O
void	O
*	O
C	pointer
,	O
const	O
int	O
ldc	int
)	O
{	O
}	O
void	O
cblas_ctbmv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
TransA	enum
,	O
const	O
enum	O
CBLAS_DIAG	enum
Diag	enum
,	O
const	O
int	O
N	int
,	O
const	O
int	O
K	int
,	O
const	O
void	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
void	O
cblas_ctrsv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
TransA	enum
,	O
const	O
enum	O
CBLAS_DIAG	enum
Diag	enum
,	O
const	O
int	O
N	int
,	O
const	O
void	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
double	O
cblas_dnrm2	function
(	O
const	O
int	O
N	int
,	O
const	O
double	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
void	O
cblas_drotg	function
(	O
double	O
*	O
a	pointer
,	O
double	O
*	O
b	pointer
,	O
double	O
*	O
c	pointer
,	O
double	O
*	O
s	pointer
)	O
{	O
}	O
void	O
cblas_drotm	function
(	O
const	O
int	O
N	int
,	O
double	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
double	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
,	O
const	O
double	O
*	O
P	pointer
)	O
{	O
}	O
void	O
cblas_dscal	function
(	O
const	O
int	O
N	int
,	O
const	O
double	O
alpha	enum
,	O
double	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
void	O
cblas_dspmv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
int	O
N	int
,	O
const	O
double	O
alpha	enum
,	O
const	O
double	O
*	O
Ap	pointer
,	O
const	O
double	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
const	O
double	O
beta	enum
,	O
double	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
)	O
{	O
}	O
void	O
cblas_dspr2	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
int	O
N	int
,	O
const	O
double	O
alpha	enum
,	O
const	O
double	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
const	O
double	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
,	O
double	O
*	O
Ap	pointer
)	O
{	O
}	O
void	O
cblas_dsymv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
int	O
N	int
,	O
const	O
double	O
alpha	enum
,	O
const	O
double	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
const	O
double	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
const	O
double	O
beta	enum
,	O
double	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
)	O
{	O
}	O
void	O
cblas_dsyr	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
int	O
N	int
,	O
const	O
double	O
alpha	enum
,	O
const	O
double	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
double	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
)	O
{	O
}	O
void	O
cblas_dsyr2k	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
Order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
Trans	enum
,	O
const	O
int	O
N	int
,	O
const	O
int	O
K	int
,	O
const	O
double	O
alpha	enum
,	O
const	O
double	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
const	O
double	O
*	O
B	pointer
,	O
const	O
int	O
ldb	int
,	O
const	O
double	O
beta	enum
,	O
double	O
*	O
C	pointer
,	O
const	O
int	O
ldc	int
)	O
{	O
}	O
void	O
cblas_dtpsv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
TransA	enum
,	O
const	O
enum	O
CBLAS_DIAG	enum
Diag	enum
,	O
const	O
int	O
N	int
,	O
const	O
double	O
*	O
Ap	pointer
,	O
double	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
void	O
cblas_dtrsv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
TransA	enum
,	O
const	O
enum	O
CBLAS_DIAG	enum
Diag	enum
,	O
const	O
int	O
N	int
,	O
const	O
double	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
double	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
double	O
cblas_dznrm2	function
(	O
const	O
int	O
N	int
,	O
const	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
CBLAS_INDEX	O
cblas_icamax	function
(	O
const	O
int	O
N	int
,	O
const	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
CBLAS_INDEX	O
cblas_idamax	function
(	O
const	O
int	O
N	int
,	O
const	O
double	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
void	O
cblas_scopy	function
(	O
const	O
int	O
N	int
,	O
const	O
float	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
float	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
)	O
{	O
}	O
void	O
cblas_sgbmv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
TransA	enum
,	O
const	O
int	O
M	int
,	O
const	O
int	O
N	int
,	O
const	O
int	O
KL	int
,	O
const	O
int	O
KU	int
,	O
const	O
float	O
alpha	enum
,	O
const	O
float	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
const	O
float	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
const	O
float	O
beta	enum
,	O
float	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
)	O
{	O
}	O
void	O
cblas_sgemv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
TransA	enum
,	O
const	O
int	O
M	int
,	O
const	O
int	O
N	int
,	O
const	O
float	O
alpha	enum
,	O
const	O
float	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
const	O
float	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
const	O
float	O
beta	enum
,	O
float	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
)	O
{	O
}	O
void	O
cblas_srotm	function
(	O
const	O
int	O
N	int
,	O
float	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
float	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
,	O
const	O
float	O
*	O
P	pointer
)	O
{	O
}	O
void	O
cblas_sscal	function
(	O
const	O
int	O
N	int
,	O
const	O
float	O
alpha	enum
,	O
float	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
void	O
cblas_sswap	function
(	O
const	O
int	O
N	int
,	O
float	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
float	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
)	O
{	O
}	O
void	O
cblas_ssymv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
int	O
N	int
,	O
const	O
float	O
alpha	enum
,	O
const	O
float	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
const	O
float	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
const	O
float	O
beta	enum
,	O
float	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
)	O
{	O
}	O
void	O
cblas_ssyr2k	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
Order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
Trans	enum
,	O
const	O
int	O
N	int
,	O
const	O
int	O
K	int
,	O
const	O
float	O
alpha	enum
,	O
const	O
float	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
const	O
float	O
*	O
B	pointer
,	O
const	O
int	O
ldb	int
,	O
const	O
float	O
beta	enum
,	O
float	O
*	O
C	pointer
,	O
const	O
int	O
ldc	int
)	O
{	O
}	O
void	O
cblas_stpmv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
TransA	enum
,	O
const	O
enum	O
CBLAS_DIAG	enum
Diag	enum
,	O
const	O
int	O
N	int
,	O
const	O
float	O
*	O
Ap	pointer
,	O
float	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
void	O
cblas_zhemm	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
Order	enum
,	O
const	O
enum	O
CBLAS_SIDE	enum
Side	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
int	O
M	int
,	O
const	O
int	O
N	int
,	O
const	O
void	O
*	O
alpha	enum
,	O
const	O
void	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
const	O
void	O
*	O
B	pointer
,	O
const	O
int	O
ldb	int
,	O
const	O
void	O
*	O
beta	enum
,	O
void	O
*	O
C	pointer
,	O
const	O
int	O
ldc	int
)	O
{	O
}	O
void	O
cblas_zher2	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
int	O
N	int
,	O
const	O
void	O
*	O
alpha	enum
,	O
const	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
const	O
void	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
,	O
void	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
)	O
{	O
}	O
void	O
cblas_zhpr2	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
int	O
N	int
,	O
const	O
void	O
*	O
alpha	enum
,	O
const	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
,	O
const	O
void	O
*	O
Y	pointer
,	O
const	O
int	O
incY	int
,	O
void	O
*	O
Ap	pointer
)	O
{	O
}	O
void	O
cblas_ztbmv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
TransA	enum
,	O
const	O
enum	O
CBLAS_DIAG	enum
Diag	enum
,	O
const	O
int	O
N	int
,	O
const	O
int	O
K	int
,	O
const	O
void	O
*	O
A	pointer
,	O
const	O
int	O
lda	int
,	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
void	O
cblas_ztpmv	function
(	O
const	O
enum	O
CBLAS_ORDER	enum
order	enum
,	O
const	O
enum	O
CBLAS_UPLO	enum
Uplo	enum
,	O
const	O
enum	O
CBLAS_TRANSPOSE	enum
TransA	enum
,	O
const	O
enum	O
CBLAS_DIAG	enum
Diag	enum
,	O
const	O
int	O
N	int
,	O
const	O
void	O
*	O
Ap	pointer
,	O
void	O
*	O
X	pointer
,	O
const	O
int	O
incX	int
)	O
{	O
}	O
static	O
double	O
bisect	function
(	O
double	O
x	double
,	O
double	O
P	double
,	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
xtol	double
,	O
double	O
Ptol	double
)	O
{	O
double	O
x0	double
=	O
0	int
,	O
x1	double
=	O
1	int
,	O
Px	double
;	O
while	O
(	O
fabs	function
(	O
x1	double
-	O
x0	double
)	O
>	O
xtol	double
)	O
{	O
Px	double
=	O
gsl_cdf_beta_P	function
(	O
x	double
,	O
a	double
,	O
b	double
)	O
;	O
if	O
(	O
fabs	function
(	O
Px	double
-	O
P	double
)	O
<	O
Ptol	double
)	O
{	O
return	O
x	double
;	O
}	O
else	O
if	O
(	O
Px	double
<	O
P	double
)	O
{	O
x0	double
=	O
x	double
;	O
}	O
else	O
if	O
(	O
Px	double
>	O
P	double
)	O
{	O
x1	double
=	O
x	double
;	O
}	O
x	double
=	O
0.5	int
*	O
(	O
x0	double
+	O
x1	double
)	O
;	O
}	O
return	O
x	double
;	O
}	O
double	O
gsl_cdf_beta_Pinv	function
(	O
const	O
double	O
P	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
double	O
x	double
,	O
mean	double
;	O
if	O
(	O
P	double
<	O
0.0	int
||	O
P	double
>	O
1.0	int
)	O
{	O
CDF_ERROR	O
(	O
"P must be in range 0 < P < 1"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
if	O
(	O
a	double
<	O
0.0	int
)	O
{	O
CDF_ERROR	O
(	O
"a < 0"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
if	O
(	O
b	double
<	O
0.0	int
)	O
{	O
CDF_ERROR	O
(	O
"b < 0"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
if	O
(	O
P	double
==	O
0.0	int
)	O
{	O
return	O
0.0	int
;	O
}	O
if	O
(	O
P	double
==	O
1.0	int
)	O
{	O
return	O
1.0	int
;	O
}	O
if	O
(	O
P	double
>	O
0.5	int
)	O
{	O
return	O
gsl_cdf_beta_Qinv	function
(	O
1	int
-	O
P	double
,	O
a	double
,	O
b	double
)	O
;	O
}	O
mean	double
=	O
a	double
/	O
(	O
a	double
+	O
b	double
)	O
;	O
if	O
(	O
P	double
<	O
0.1	int
)	O
{	O
double	O
lg_ab	double
=	O
gsl_sf_lngamma	function
(	O
a	double
+	O
b	double
)	O
;	O
double	O
lg_a	double
=	O
gsl_sf_lngamma	function
(	O
a	double
)	O
;	O
double	O
lg_b	double
=	O
gsl_sf_lngamma	function
(	O
b	double
)	O
;	O
double	O
lx	double
=	O
(	O
log	function
(	O
a	double
)	O
+	O
lg_a	double
+	O
lg_b	int
-	O
lg_ab	double
+	O
log	function
(	O
P	double
)	O
)	O
/	O
a	double
;	O
if	O
(	O
lx	double
<=	O
0	int
)	O
{	O
x	double
=	O
exp	function
(	O
lx	double
)	O
;	O
x	double
*=	O
pow	function
(	O
1	int
-	O
x	double
,	O
-	O
(	O
b	double
-	O
1	int
)	O
/	O
a	double
)	O
;	O
}	O
else	O
{	O
x	double
=	O
mean	double
;	O
}	O
if	O
(	O
x	double
>	O
mean	double
)	O
x	double
=	O
mean	double
;	O
}	O
else	O
{	O
x	double
=	O
mean	double
;	O
}	O
x	double
=	O
bisect	function
(	O
x	double
,	O
P	pointer
,	O
a	pointer
,	O
b	double
,	O
0.01	int
,	O
0.01	int
)	O
;	O
{	O
double	O
lambda	double
,	O
dP	double
,	O
phi	double
;	O
unsigned	O
int	O
n	int
=	O
0	int
;	O
start	function
:	O
dP	double
=	O
P	double
-	O
gsl_cdf_beta_P	function
(	O
x	double
,	O
a	double
,	O
b	double
)	O
;	O
phi	double
=	O
gsl_ran_beta_pdf	function
(	O
x	double
,	O
a	double
,	O
b	double
)	O
;	O
if	O
(	O
dP	double
==	O
0.0	int
||	O
n	int
++	O
>	O
64	int
)	O
goto	O
end	double
;	O
lambda	double
=	O
dP	double
/	O
GSL_MAX	O
(	O
2	int
*	O
fabs	function
(	O
dP	double
/	O
x	double
)	O
,	O
phi	double
)	O
;	O
{	O
double	O
step0	double
=	O
lambda	double
;	O
double	O
step1	double
=	O
-	O
(	O
(	O
a	double
-	O
1	int
)	O
/	O
x	double
-	O
(	O
b	double
-	O
1	int
)	O
/	O
(	O
1	int
-	O
x	double
)	O
)	O
*	O
lambda	double
*	O
lambda	double
/	O
2	int
;	O
double	O
step	double
=	O
step0	double
;	O
if	O
(	O
fabs	function
(	O
step1	double
)	O
<	O
fabs	function
(	O
step0	double
)	O
)	O
{	O
step	double
+=	O
step1	int
;	O
}	O
else	O
{	O
step	double
*=	O
2	int
*	O
fabs	function
(	O
step0	double
/	O
step1	double
)	O
;	O
}	O
;	O
if	O
(	O
x	double
+	O
step	double
>	O
0	int
&&	O
x	double
+	O
step	double
<	O
1	int
)	O
{	O
x	double
+=	O
step	double
;	O
}	O
else	O
{	O
x	double
=	O
sqrt	function
(	O
x	double
)	O
*	O
sqrt	function
(	O
mean	double
)	O
;	O
}	O
if	O
(	O
fabs	function
(	O
step0	int
)	O
>	O
1e-10	double
*	O
x	double
)	O
goto	O
start	O
;	O
}	O
end	O
:	O
if	O
(	O
fabs	function
(	O
dP	double
)	O
>	O
GSL_SQRT_DBL_EPSILON	int
*	O
P	double
)	O
{	O
GSL_ERROR_VAL	O
(	O
"inverse failed to converge"	pointer
,	O
GSL_EFAILED	int
,	O
GSL_NAN	pointer
)	O
;	O
}	O
return	O
x	double
;	O
}	O
}	O
double	O
gsl_cdf_beta_Qinv	function
(	O
const	O
double	O
Q	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
if	O
(	O
Q	double
<	O
0.0	int
||	O
Q	double
>	O
1.0	int
)	O
{	O
CDF_ERROR	O
(	O
"Q must be inside range 0 < Q < 1"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
if	O
(	O
a	double
<	O
0.0	int
)	O
{	O
CDF_ERROR	O
(	O
"a < 0"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
if	O
(	O
b	double
<	O
0.0	int
)	O
{	O
CDF_ERROR	O
(	O
"b < 0"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
if	O
(	O
Q	double
==	O
0.0	int
)	O
{	O
return	O
1.0	int
;	O
}	O
if	O
(	O
Q	double
==	O
1.0	int
)	O
{	O
return	O
0.0	int
;	O
}	O
if	O
(	O
Q	double
>	O
0.5	int
)	O
{	O
return	O
gsl_cdf_beta_Pinv	function
(	O
1	int
-	O
Q	double
,	O
a	double
,	O
b	double
)	O
;	O
}	O
else	O
{	O
return	O
1	int
-	O
gsl_cdf_beta_Pinv	function
(	O
Q	double
,	O
b	double
,	O
a	double
)	O
;	O
}	O
;	O
}	O
double	O
gsl_cdf_chisq_P	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
nu	double
)	O
{	O
return	O
gsl_cdf_gamma_P	function
(	O
x	double
,	O
nu	double
/	O
2	int
,	O
2.0	int
)	O
;	O
}	O
double	O
gsl_cdf_chisq_Q	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
nu	double
)	O
{	O
return	O
gsl_cdf_gamma_Q	function
(	O
x	double
,	O
nu	double
/	O
2	int
,	O
2.0	int
)	O
;	O
}	O
double	O
gsl_cdf_exponential_Pinv	function
(	O
const	O
double	O
P	double
,	O
const	O
double	O
mu	double
)	O
{	O
double	O
x	double
=	O
-	O
mu	double
*	O
log1p	function
(	O
-	O
P	double
)	O
;	O
return	O
x	double
;	O
}	O
double	O
gsl_cdf_exponential_Qinv	function
(	O
const	O
double	O
Q	double
,	O
const	O
double	O
mu	double
)	O
{	O
double	O
x	double
=	O
-	O
mu	double
*	O
log	function
(	O
Q	double
)	O
;	O
return	O
x	double
;	O
}	O
double	O
gsl_cdf_gamma_Pinv	function
(	O
const	O
double	O
P	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
double	O
x	double
;	O
if	O
(	O
P	double
==	O
1.0	int
)	O
{	O
return	O
GSL_POSINF	O
;	O
}	O
else	O
if	O
(	O
P	double
==	O
0.0	int
)	O
{	O
return	O
0.0	int
;	O
}	O
if	O
(	O
P	double
<	O
0.05	int
)	O
{	O
double	O
x0	double
=	O
exp	function
(	O
(	O
gsl_sf_lngamma	function
(	O
a	double
)	O
+	O
log	function
(	O
P	double
)	O
)	O
/	O
a	double
)	O
;	O
x	double
=	O
x0	double
;	O
}	O
else	O
if	O
(	O
P	double
>	O
0.95	int
)	O
{	O
double	O
x0	double
=	O
-	O
log1p	function
(	O
-	O
P	double
)	O
+	O
gsl_sf_lngamma	function
(	O
a	double
)	O
;	O
x	double
=	O
x0	double
;	O
}	O
else	O
{	O
double	O
xg	double
=	O
gsl_cdf_ugaussian_Pinv	function
(	O
P	double
)	O
;	O
double	O
x0	double
=	O
(	O
xg	double
<	O
-	O
0.5	int
*	O
sqrt	function
(	O
a	double
)	O
)	O
?	O
a	double
:	O
sqrt	function
(	O
a	double
)	O
*	O
xg	double
+	O
a	double
;	O
x	double
=	O
x0	double
;	O
}	O
{	O
double	O
lambda	double
,	O
dP	double
,	O
phi	double
;	O
unsigned	O
int	O
n	int
=	O
0	int
;	O
start	function
:	O
dP	double
=	O
P	double
-	O
gsl_cdf_gamma_P	function
(	O
x	double
,	O
a	double
,	O
1.0	int
)	O
;	O
phi	double
=	O
gsl_ran_gamma_pdf	function
(	O
x	double
,	O
a	double
,	O
1.0	int
)	O
;	O
if	O
(	O
dP	double
==	O
0.0	int
||	O
n	int
++	O
>	O
32	int
)	O
goto	O
end	double
;	O
lambda	double
=	O
dP	double
/	O
GSL_MAX	O
(	O
2	int
*	O
fabs	function
(	O
dP	double
/	O
x	double
)	O
,	O
phi	double
)	O
;	O
{	O
double	O
step0	double
=	O
lambda	double
;	O
double	O
step1	double
=	O
-	O
(	O
(	O
a	double
-	O
1	int
)	O
/	O
x	double
-	O
1	int
)	O
*	O
lambda	double
*	O
lambda	double
/	O
4.0	int
;	O
double	O
step	double
=	O
step0	double
;	O
if	O
(	O
fabs	function
(	O
step1	double
)	O
<	O
0.5	int
*	O
fabs	function
(	O
step0	double
)	O
)	O
step	double
+=	O
step1	double
;	O
if	O
(	O
x	double
+	O
step	double
>	O
0	int
)	O
x	double
+=	O
step	double
;	O
else	O
{	O
x	double
/=	O
2.0	int
;	O
}	O
if	O
(	O
fabs	function
(	O
step0	int
)	O
>	O
1e-10	double
*	O
x	double
||	O
fabs	function
(	O
step0	double
*	O
phi	double
)	O
>	O
1e-10	struct
*	O
P	double
)	O
goto	O
start	O
;	O
}	O
end	O
:	O
if	O
(	O
fabs	function
(	O
dP	double
)	O
>	O
GSL_SQRT_DBL_EPSILON	int
*	O
P	double
)	O
{	O
GSL_ERROR_VAL	O
(	O
"inverse failed to converge"	pointer
,	O
GSL_EFAILED	int
,	O
GSL_NAN	pointer
)	O
;	O
}	O
return	O
b	double
*	O
x	double
;	O
}	O
}	O
double	O
gsl_cdf_gamma_Qinv	function
(	O
const	O
double	O
Q	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
double	O
x	double
;	O
if	O
(	O
Q	double
==	O
1.0	int
)	O
{	O
return	O
0.0	int
;	O
}	O
else	O
if	O
(	O
Q	double
==	O
0.0	int
)	O
{	O
return	O
GSL_POSINF	O
;	O
}	O
if	O
(	O
Q	double
<	O
0.05	double
)	O
{	O
double	O
x0	double
=	O
-	O
log	function
(	O
Q	double
)	O
+	O
gsl_sf_lngamma	function
(	O
a	double
)	O
;	O
x	double
=	O
x0	double
;	O
}	O
else	O
if	O
(	O
Q	double
>	O
0.95	int
)	O
{	O
double	O
x0	double
=	O
exp	function
(	O
(	O
gsl_sf_lngamma	function
(	O
a	double
)	O
+	O
log1p	function
(	O
-	O
Q	double
)	O
)	O
/	O
a	double
)	O
;	O
x	double
=	O
x0	double
;	O
}	O
else	O
{	O
double	O
xg	double
=	O
gsl_cdf_ugaussian_Qinv	function
(	O
Q	double
)	O
;	O
double	O
x0	double
=	O
(	O
xg	double
<	O
-	O
0.5	int
*	O
sqrt	function
(	O
a	double
)	O
)	O
?	O
a	double
:	O
sqrt	function
(	O
a	double
)	O
*	O
xg	double
+	O
a	double
;	O
x	double
=	O
x0	double
;	O
}	O
{	O
double	O
lambda	double
,	O
dQ	double
,	O
phi	double
;	O
unsigned	O
int	O
n	int
=	O
0	int
;	O
start	function
:	O
dQ	double
=	O
Q	double
-	O
gsl_cdf_gamma_Q	function
(	O
x	double
,	O
a	double
,	O
1.0	int
)	O
;	O
phi	double
=	O
gsl_ran_gamma_pdf	function
(	O
x	double
,	O
a	double
,	O
1.0	int
)	O
;	O
if	O
(	O
dQ	double
==	O
0.0	int
||	O
n	int
++	O
>	O
32	int
)	O
goto	O
end	double
;	O
lambda	double
=	O
-	O
dQ	double
/	O
GSL_MAX	O
(	O
2	int
*	O
fabs	function
(	O
dQ	double
/	O
x	double
)	O
,	O
phi	double
)	O
;	O
{	O
double	O
step0	double
=	O
lambda	double
;	O
double	O
step1	double
=	O
-	O
(	O
(	O
a	double
-	O
1	int
)	O
/	O
x	double
-	O
1	int
)	O
*	O
lambda	double
*	O
lambda	double
/	O
4.0	int
;	O
double	O
step	double
=	O
step0	double
;	O
if	O
(	O
fabs	function
(	O
step1	double
)	O
<	O
0.5	int
*	O
fabs	function
(	O
step0	double
)	O
)	O
step	double
+=	O
step1	double
;	O
if	O
(	O
x	double
+	O
step	double
>	O
0	int
)	O
x	double
+=	O
step	double
;	O
else	O
{	O
x	double
/=	O
2.0	int
;	O
}	O
if	O
(	O
fabs	function
(	O
step0	int
)	O
>	O
1e-10	double
*	O
x	double
)	O
goto	O
start	O
;	O
}	O
}	O
end	double
:	O
return	O
b	double
*	O
x	double
;	O
}	O
double	O
gsl_cdf_gumbel2_P	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
double	O
P	double
;	O
if	O
(	O
x	double
==	O
0	int
)	O
{	O
P	double
=	O
0	int
;	O
}	O
else	O
{	O
double	O
u	double
=	O
pow	function
(	O
x	double
,	O
a	double
)	O
;	O
P	double
=	O
exp	function
(	O
-	O
b	double
/	O
u	double
)	O
;	O
}	O
return	O
P	double
;	O
}	O
double	O
gsl_cdf_gumbel2_Q	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
double	O
Q	double
;	O
if	O
(	O
x	double
==	O
0	int
)	O
{	O
Q	double
=	O
1	int
;	O
}	O
else	O
{	O
double	O
u	double
=	O
pow	function
(	O
x	double
,	O
a	double
)	O
;	O
Q	double
=	O
-	O
expm1	function
(	O
-	O
b	double
/	O
u	double
)	O
;	O
}	O
return	O
Q	double
;	O
}	O
double	O
gsl_cdf_laplace_P	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
a	double
)	O
{	O
double	O
P	double
;	O
double	O
u	double
=	O
x	double
/	O
a	double
;	O
if	O
(	O
u	double
>	O
0	int
)	O
{	O
P	double
=	O
0.5	int
+	O
0.5	int
*	O
(	O
1	int
-	O
exp	function
(	O
-	O
u	double
)	O
)	O
;	O
}	O
else	O
{	O
P	double
=	O
0.5	int
*	O
exp	function
(	O
u	double
)	O
;	O
}	O
return	O
P	double
;	O
}	O
double	O
gsl_cdf_laplace_Q	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
a	double
)	O
{	O
double	O
Q	double
;	O
double	O
u	double
=	O
x	double
/	O
a	double
;	O
if	O
(	O
u	double
>	O
0	int
)	O
{	O
Q	double
=	O
0.5	int
*	O
exp	function
(	O
-	O
u	double
)	O
;	O
}	O
else	O
{	O
Q	double
=	O
1	int
-	O
0.5	int
*	O
exp	function
(	O
u	double
)	O
;	O
}	O
return	O
Q	double
;	O
}	O
double	O
gsl_cdf_negative_binomial_P	function
(	O
const	O
unsigned	O
int	O
k	int
,	O
const	O
double	O
p	int
,	O
const	O
double	O
n	int
)	O
{	O
double	O
P	double
;	O
double	O
a	double
;	O
double	O
b	double
;	O
if	O
(	O
p	double
>	O
1.0	int
||	O
p	double
<	O
0.0	int
)	O
{	O
CDF_ERROR	O
(	O
"p < 0 or p > 1"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
CDF_ERROR	O
(	O
"n < 0"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
a	double
=	O
(	O
double	O
)	O
n	int
;	O
b	double
=	O
(	O
double	O
)	O
k	int
+	O
1.0	int
;	O
P	double
=	O
gsl_cdf_beta_P	function
(	O
p	double
,	O
a	double
,	O
b	double
)	O
;	O
return	O
P	double
;	O
}	O
double	O
gsl_cdf_negative_binomial_Q	function
(	O
const	O
unsigned	O
int	O
k	int
,	O
const	O
double	O
p	int
,	O
const	O
double	O
n	int
)	O
{	O
double	O
Q	double
;	O
double	O
a	double
;	O
double	O
b	double
;	O
if	O
(	O
p	double
>	O
1.0	int
||	O
p	double
<	O
0.0	int
)	O
{	O
CDF_ERROR	O
(	O
"p < 0 or p > 1"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
CDF_ERROR	O
(	O
"n < 0"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
a	double
=	O
(	O
double	O
)	O
n	int
;	O
b	double
=	O
(	O
double	O
)	O
k	int
+	O
1.0	int
;	O
Q	double
=	O
gsl_cdf_beta_Q	function
(	O
p	double
,	O
a	double
,	O
b	double
)	O
;	O
return	O
Q	double
;	O
}	O
double	O
gsl_cdf_pascal_P	function
(	O
const	O
unsigned	O
int	O
k	int
,	O
const	O
double	O
p	int
,	O
const	O
unsigned	O
int	O
n	int
)	O
{	O
double	O
P	pointer
=	O
gsl_cdf_negative_binomial_P	function
(	O
k	int
,	O
p	int
,	O
(	O
double	O
)	O
n	int
)	O
;	O
return	O
P	double
;	O
}	O
double	O
gsl_cdf_pascal_Q	function
(	O
const	O
unsigned	O
int	O
k	int
,	O
const	O
double	O
p	int
,	O
const	O
unsigned	O
int	O
n	int
)	O
{	O
double	O
Q	double
=	O
gsl_cdf_negative_binomial_Q	function
(	O
k	int
,	O
p	int
,	O
(	O
double	O
)	O
n	int
)	O
;	O
return	O
Q	double
;	O
}	O
static	O
double	O
inv_cornish_fisher	function
(	O
double	O
z	double
,	O
double	O
nu	double
)	O
{	O
double	O
a	double
=	O
1	int
/	O
(	O
nu	double
-	O
0.5	int
)	O
;	O
double	O
b	double
=	O
48.0	int
/	O
(	O
a	double
*	O
a	double
)	O
;	O
double	O
cf1	double
=	O
z	double
*	O
(	O
3	int
+	O
z	double
*	O
z	double
)	O
;	O
double	O
cf2	double
=	O
z	double
*	O
(	O
945	double
+	O
z	double
*	O
z	double
*	O
(	O
360	int
+	O
z	double
*	O
z	double
*	O
(	O
63	int
+	O
z	double
*	O
z	double
*	O
4	int
)	O
)	O
)	O
;	O
double	O
y	double
=	O
z	double
-	O
cf1	double
/	O
b	double
+	O
cf2	double
/	O
(	O
10	int
*	O
b	double
*	O
b	double
)	O
;	O
double	O
t	double
=	O
GSL_SIGN	O
(	O
z	double
)	O
*	O
sqrt	function
(	O
nu	double
*	O
expm1	function
(	O
a	double
*	O
y	double
*	O
y	double
)	O
)	O
;	O
return	O
t	double
;	O
}	O
double	O
gsl_cdf_tdist_Pinv	function
(	O
const	O
double	O
P	double
,	O
const	O
double	O
nu	double
)	O
{	O
double	O
x	double
,	O
ptail	double
;	O
if	O
(	O
P	double
==	O
1.0	int
)	O
{	O
return	O
GSL_POSINF	O
;	O
}	O
else	O
if	O
(	O
P	double
==	O
0.0	int
)	O
{	O
return	O
GSL_NEGINF	O
;	O
}	O
if	O
(	O
nu	double
==	O
1.0	int
)	O
{	O
x	double
=	O
tan	function
(	O
M_PI	int
*	O
(	O
P	double
-	O
0.5	int
)	O
)	O
;	O
return	O
x	double
;	O
}	O
else	O
if	O
(	O
nu	double
==	O
2.0	int
)	O
{	O
x	double
=	O
(	O
2	int
*	O
P	double
-	O
1	int
)	O
/	O
sqrt	function
(	O
2	int
*	O
P	double
*	O
(	O
1	int
-	O
P	double
)	O
)	O
;	O
return	O
x	double
;	O
}	O
ptail	double
=	O
(	O
P	double
<	O
0.5	int
)	O
?	O
P	double
:	O
1	int
-	O
P	double
;	O
if	O
(	O
sqrt	function
(	O
M_PI	int
*	O
nu	double
/	O
2	int
)	O
*	O
ptail	double
>	O
pow	function
(	O
0.05	double
,	O
nu	double
/	O
2	int
)	O
)	O
{	O
double	O
xg	double
=	O
gsl_cdf_ugaussian_Pinv	function
(	O
P	double
)	O
;	O
x	double
=	O
inv_cornish_fisher	function
(	O
xg	double
,	O
nu	double
)	O
;	O
}	O
else	O
{	O
double	O
beta	double
=	O
gsl_sf_beta	function
(	O
0.5	int
,	O
nu	double
/	O
2	int
)	O
;	O
if	O
(	O
P	double
<	O
0.5	int
)	O
{	O
x	double
=	O
-	O
sqrt	function
(	O
nu	double
)	O
*	O
pow	function
(	O
beta	double
*	O
nu	double
*	O
P	double
,	O
-	O
1.0	int
/	O
nu	double
)	O
;	O
}	O
else	O
{	O
x	double
=	O
sqrt	function
(	O
nu	double
)	O
*	O
pow	function
(	O
beta	double
*	O
nu	double
*	O
(	O
1	int
-	O
P	double
)	O
,	O
-	O
1.0	int
/	O
nu	double
)	O
;	O
}	O
x	double
/=	O
sqrt	function
(	O
1	int
+	O
nu	double
/	O
(	O
x	double
*	O
x	double
)	O
)	O
;	O
}	O
{	O
double	O
dP	double
,	O
phi	double
;	O
unsigned	O
int	O
n	int
=	O
0	int
;	O
start	function
:	O
dP	double
=	O
P	double
-	O
gsl_cdf_tdist_P	function
(	O
x	double
,	O
nu	double
)	O
;	O
phi	double
=	O
gsl_ran_tdist_pdf	function
(	O
x	double
,	O
nu	double
)	O
;	O
if	O
(	O
dP	double
==	O
0.0	int
||	O
n	int
++	O
>	O
32	int
)	O
goto	O
end	double
;	O
{	O
double	O
lambda	double
=	O
dP	double
/	O
phi	double
;	O
double	O
step0	double
=	O
lambda	double
;	O
double	O
step1	double
=	O
(	O
(	O
nu	double
+	O
1	int
)	O
*	O
x	double
/	O
(	O
x	double
*	O
x	double
+	O
nu	double
)	O
)	O
*	O
(	O
lambda	double
*	O
lambda	double
/	O
4.0	int
)	O
;	O
double	O
step	double
=	O
step0	double
;	O
if	O
(	O
fabs	function
(	O
step1	double
)	O
<	O
fabs	function
(	O
step0	double
)	O
)	O
{	O
step	double
+=	O
step1	double
;	O
}	O
if	O
(	O
P	double
>	O
0.5	int
&&	O
x	double
+	O
step	double
<	O
0	int
)	O
x	double
/=	O
2	int
;	O
else	O
if	O
(	O
P	double
<	O
0.5	int
&&	O
x	double
+	O
step	double
>	O
0	int
)	O
x	double
/=	O
2	int
;	O
else	O
x	double
+=	O
step	double
;	O
if	O
(	O
fabs	function
(	O
step	double
)	O
>	O
1e-10	double
*	O
fabs	function
(	O
x	double
)	O
)	O
goto	O
start	O
;	O
}	O
end	O
:	O
if	O
(	O
fabs	function
(	O
dP	double
)	O
>	O
GSL_SQRT_DBL_EPSILON	int
*	O
P	double
)	O
{	O
GSL_ERROR_VAL	O
(	O
"inverse failed to converge"	pointer
,	O
GSL_EFAILED	int
,	O
GSL_NAN	pointer
)	O
;	O
}	O
return	O
x	double
;	O
}	O
}	O
double	O
gsl_cdf_tdist_Qinv	function
(	O
const	O
double	O
Q	double
,	O
const	O
double	O
nu	double
)	O
{	O
double	O
x	double
,	O
qtail	double
;	O
if	O
(	O
Q	double
==	O
0.0	int
)	O
{	O
return	O
GSL_POSINF	O
;	O
}	O
else	O
if	O
(	O
Q	double
==	O
1.0	int
)	O
{	O
return	O
GSL_NEGINF	O
;	O
}	O
if	O
(	O
nu	double
==	O
1.0	int
)	O
{	O
x	double
=	O
tan	function
(	O
M_PI	int
*	O
(	O
0.5	int
-	O
Q	double
)	O
)	O
;	O
return	O
x	double
;	O
}	O
else	O
if	O
(	O
nu	double
==	O
2.0	int
)	O
{	O
x	double
=	O
(	O
1	int
-	O
2	int
*	O
Q	double
)	O
/	O
sqrt	function
(	O
2	int
*	O
Q	double
*	O
(	O
1	int
-	O
Q	double
)	O
)	O
;	O
return	O
x	double
;	O
}	O
qtail	double
=	O
(	O
Q	double
<	O
0.5	int
)	O
?	O
Q	double
:	O
1	int
-	O
Q	double
;	O
if	O
(	O
sqrt	function
(	O
M_PI	int
*	O
nu	double
/	O
2	int
)	O
*	O
qtail	double
>	O
pow	function
(	O
0.05	double
,	O
nu	double
/	O
2	int
)	O
)	O
{	O
double	O
xg	double
=	O
gsl_cdf_ugaussian_Qinv	function
(	O
Q	double
)	O
;	O
x	double
=	O
inv_cornish_fisher	function
(	O
xg	double
,	O
nu	double
)	O
;	O
}	O
else	O
{	O
double	O
beta	double
=	O
gsl_sf_beta	function
(	O
0.5	int
,	O
nu	double
/	O
2	int
)	O
;	O
if	O
(	O
Q	double
<	O
0.5	int
)	O
{	O
x	double
=	O
sqrt	function
(	O
nu	double
)	O
*	O
pow	function
(	O
beta	double
*	O
nu	double
*	O
Q	double
,	O
-	O
1.0	int
/	O
nu	double
)	O
;	O
}	O
else	O
{	O
x	double
=	O
-	O
sqrt	function
(	O
nu	double
)	O
*	O
pow	function
(	O
beta	double
*	O
nu	double
*	O
(	O
1	int
-	O
Q	double
)	O
,	O
-	O
1.0	int
/	O
nu	double
)	O
;	O
}	O
x	double
/=	O
sqrt	function
(	O
1	int
+	O
nu	double
/	O
(	O
x	double
*	O
x	double
)	O
)	O
;	O
}	O
{	O
double	O
dQ	double
,	O
phi	double
;	O
unsigned	O
int	O
n	int
=	O
0	int
;	O
start	function
:	O
dQ	double
=	O
Q	double
-	O
gsl_cdf_tdist_Q	function
(	O
x	double
,	O
nu	double
)	O
;	O
phi	double
=	O
gsl_ran_tdist_pdf	function
(	O
x	double
,	O
nu	double
)	O
;	O
if	O
(	O
dQ	double
==	O
0.0	int
||	O
n	int
++	O
>	O
32	int
)	O
goto	O
end	double
;	O
{	O
double	O
lambda	double
=	O
-	O
dQ	double
/	O
phi	double
;	O
double	O
step0	double
=	O
lambda	double
;	O
double	O
step1	double
=	O
(	O
(	O
nu	double
+	O
1	int
)	O
*	O
x	double
/	O
(	O
x	double
*	O
x	double
+	O
nu	double
)	O
)	O
*	O
(	O
lambda	double
*	O
lambda	double
/	O
4.0	int
)	O
;	O
double	O
step	double
=	O
step0	double
;	O
if	O
(	O
fabs	function
(	O
step1	double
)	O
<	O
fabs	function
(	O
step0	double
)	O
)	O
{	O
step	double
+=	O
step1	double
;	O
}	O
if	O
(	O
Q	double
<	O
0.5	int
&&	O
x	double
+	O
step	double
<	O
0	int
)	O
x	double
/=	O
2	int
;	O
else	O
if	O
(	O
Q	double
>	O
0.5	int
&&	O
x	double
+	O
step	double
>	O
0	int
)	O
x	double
/=	O
2	int
;	O
else	O
x	double
+=	O
step	double
;	O
if	O
(	O
fabs	function
(	O
step	double
)	O
>	O
1e-10	double
*	O
fabs	function
(	O
x	double
)	O
)	O
goto	O
start	O
;	O
}	O
}	O
end	double
:	O
return	O
x	double
;	O
}	O
double	O
gsl_cdf_weibull_Pinv	function
(	O
const	O
double	O
P	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
double	O
x	double
;	O
if	O
(	O
P	double
==	O
1.0	int
)	O
{	O
return	O
GSL_POSINF	O
;	O
}	O
else	O
if	O
(	O
P	double
==	O
0.0	int
)	O
{	O
return	O
0.0	int
;	O
}	O
x	double
=	O
a	double
*	O
pow	function
(	O
-	O
log1p	function
(	O
-	O
P	double
)	O
,	O
1	int
/	O
b	double
)	O
;	O
return	O
x	double
;	O
}	O
double	O
gsl_cdf_weibull_Qinv	function
(	O
const	O
double	O
Q	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
double	O
x	double
;	O
if	O
(	O
Q	double
==	O
0.0	int
)	O
{	O
return	O
GSL_POSINF	O
;	O
}	O
else	O
if	O
(	O
Q	double
==	O
1.0	int
)	O
{	O
return	O
0.0	int
;	O
}	O
x	double
=	O
a	double
*	O
pow	function
(	O
-	O
log	function
(	O
Q	double
)	O
,	O
1	int
/	O
b	double
)	O
;	O
return	O
x	double
;	O
}	O
gsl_histogram	struct
*	O
gsl_histogram_alloc	function
(	O
size_t	long
n	long
)	O
{	O
gsl_histogram	struct
*	O
h	pointer
;	O
if	O
(	O
n	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"histogram length n must be positive integer"	pointer
,	O
GSL_EDOM	int
,	O
0	int
)	O
;	O
}	O
h	pointer
=	O
(	O
gsl_histogram	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_histogram	struct
)	O
)	O
;	O
if	O
(	O
h	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for histogram struct"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
h	pointer
->	O
range	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
(	O
n	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
h	pointer
->	O
range	pointer
==	O
0	int
)	O
{	O
free	function
(	O
h	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for histogram ranges"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
h	pointer
->	O
bin	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
n	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
h	pointer
->	O
bin	pointer
==	O
0	int
)	O
{	O
free	function
(	O
h	pointer
->	O
range	pointer
)	O
;	O
free	function
(	O
h	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for histogram bins"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
h	pointer
->	O
n	long
=	O
n	long
;	O
return	O
h	pointer
;	O
}	O
static	O
void	O
make_uniform	function
(	O
double	O
range	pointer
[	O
]	O
,	O
size_t	long
n	long
,	O
double	O
xmin	double
,	O
double	O
xmax	double
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
n	int
;	O
i	int
++	O
)	O
{	O
double	O
f1	double
=	O
(	O
(	O
double	O
)	O
(	O
n	int
-	O
i	int
)	O
/	O
(	O
double	O
)	O
n	int
)	O
;	O
double	O
f2	double
=	O
(	O
(	O
double	O
)	O
i	int
/	O
(	O
double	O
)	O
n	int
)	O
;	O
range	pointer
[	O
i	int
]	O
=	O
f1	double
*	O
xmin	double
+	O
f2	double
*	O
xmax	double
;	O
}	O
}	O
gsl_histogram	struct
*	O
gsl_histogram_calloc_uniform	function
(	O
const	O
size_t	long
n	int
,	O
const	O
double	O
xmin	double
,	O
const	O
double	O
xmax	double
)	O
{	O
gsl_histogram	struct
*	O
h	pointer
;	O
if	O
(	O
xmin	double
>=	O
xmax	double
)	O
{	O
GSL_ERROR_VAL	O
(	O
"xmin must be less than xmax"	pointer
,	O
GSL_EINVAL	int
,	O
0	int
)	O
;	O
}	O
h	pointer
=	O
gsl_histogram_calloc	function
(	O
n	long
)	O
;	O
if	O
(	O
h	pointer
==	O
0	int
)	O
{	O
return	O
h	pointer
;	O
}	O
make_uniform	function
(	O
h	pointer
->	O
range	pointer
,	O
n	int
,	O
xmin	double
,	O
xmax	double
)	O
;	O
return	O
h	pointer
;	O
}	O
gsl_histogram	struct
*	O
gsl_histogram_calloc	function
(	O
size_t	long
n	pointer
)	O
{	O
gsl_histogram	struct
*	O
h	pointer
=	O
gsl_histogram_alloc	function
(	O
n	long
)	O
;	O
if	O
(	O
h	pointer
==	O
0	int
)	O
{	O
return	O
h	pointer
;	O
}	O
{	O
size_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
n	long
+	O
1	int
;	O
i	pointer
++	O
)	O
{	O
h	pointer
->	O
range	pointer
[	O
i	pointer
]	O
=	O
i	pointer
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
n	long
;	O
i	pointer
++	O
)	O
{	O
h	pointer
->	O
bin	pointer
[	O
i	pointer
]	O
=	O
0	int
;	O
}	O
}	O
h	pointer
->	O
n	long
=	O
n	long
;	O
return	O
h	pointer
;	O
}	O
void	O
gsl_histogram_free	function
(	O
gsl_histogram	struct
*	O
h	pointer
)	O
{	O
RETURN_IF_NULL	O
(	O
h	pointer
)	O
;	O
free	function
(	O
h	pointer
->	O
range	pointer
)	O
;	O
free	function
(	O
h	pointer
->	O
bin	pointer
)	O
;	O
free	function
(	O
h	pointer
)	O
;	O
}	O
int	O
gsl_histogram_set_ranges_uniform	function
(	O
gsl_histogram	struct
*	O
h	pointer
,	O
double	O
xmin	double
,	O
double	O
xmax	double
)	O
{	O
size_t	long
i	long
;	O
const	O
size_t	long
n	int
=	O
h	pointer
->	O
n	long
;	O
if	O
(	O
xmin	double
>=	O
xmax	double
)	O
{	O
GSL_ERROR	O
(	O
"xmin must be less than xmax"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
make_uniform	function
(	O
h	pointer
->	O
range	pointer
,	O
n	long
,	O
xmin	double
,	O
xmax	double
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	int
<	O
n	long
;	O
i	int
++	O
)	O
{	O
h	pointer
->	O
bin	pointer
[	O
i	pointer
]	O
=	O
0	int
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_histogram_set_ranges	function
(	O
gsl_histogram	struct
*	O
h	pointer
,	O
const	O
double	O
range	pointer
[	O
]	O
,	O
size_t	long
size	pointer
)	O
{	O
size_t	long
i	pointer
;	O
const	O
size_t	long
n	long
=	O
h	pointer
->	O
n	long
;	O
if	O
(	O
size	pointer
!=	O
(	O
n	long
+	O
1	int
)	O
)	O
{	O
GSL_ERROR	O
(	O
"size of range must match size of histogram"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<=	O
n	long
;	O
i	pointer
++	O
)	O
{	O
h	pointer
->	O
range	pointer
[	O
i	pointer
]	O
=	O
range	pointer
[	O
i	pointer
]	O
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
n	long
;	O
i	pointer
++	O
)	O
{	O
h	pointer
->	O
bin	pointer
[	O
i	pointer
]	O
=	O
0	int
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
double	O
gsl_histogram_max	function
(	O
const	O
gsl_histogram	struct
*	O
h	pointer
)	O
{	O
const	O
int	O
n	long
=	O
h	pointer
->	O
n	long
;	O
return	O
h	pointer
->	O
range	pointer
[	O
n	pointer
]	O
;	O
}	O
double	O
gsl_histogram_min	function
(	O
const	O
gsl_histogram	struct
*	O
h	pointer
)	O
{	O
return	O
h	pointer
->	O
range	pointer
[	O
0	int
]	O
;	O
}	O
size_t	long
gsl_histogram_bins	function
(	O
const	O
gsl_histogram	struct
*	O
h	pointer
)	O
{	O
return	O
h	pointer
->	O
n	long
;	O
}	O
double	O
gsl_histogram_pdf_sample	function
(	O
const	O
gsl_histogram_pdf	struct
*	O
p	pointer
,	O
double	O
r	double
)	O
{	O
size_t	long
i	long
;	O
int	O
status	int
;	O
if	O
(	O
r	double
==	O
1.0	int
)	O
{	O
r	pointer
=	O
0.0	int
;	O
}	O
status	int
=	O
find	function
(	O
p	pointer
->	O
n	long
,	O
p	pointer
->	O
sum	pointer
,	O
r	pointer
,	O
&	O
i	long
)	O
;	O
if	O
(	O
status	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"cannot find r in cumulative pdf"	pointer
,	O
GSL_EDOM	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
double	O
delta	double
=	O
(	O
r	pointer
-	O
p	pointer
->	O
sum	array
[	O
i	long
]	O
)	O
/	O
(	O
p	pointer
->	O
sum	pointer
[	O
i	long
+	O
1	int
]	O
-	O
p	pointer
->	O
sum	pointer
[	O
i	long
]	O
)	O
;	O
double	O
x	double
=	O
p	pointer
->	O
range	pointer
[	O
i	long
]	O
+	O
delta	double
*	O
(	O
p	pointer
->	O
range	pointer
[	O
i	pointer
+	O
1	int
]	O
-	O
p	pointer
->	O
range	pointer
[	O
i	pointer
]	O
)	O
;	O
return	O
x	double
;	O
}	O
}	O
gsl_histogram_pdf	struct
*	O
gsl_histogram_pdf_alloc	function
(	O
const	O
size_t	long
n	int
)	O
{	O
gsl_histogram_pdf	struct
*	O
p	pointer
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"histogram pdf length n must be positive integer"	pointer
,	O
GSL_EDOM	int
,	O
0	int
)	O
;	O
}	O
p	pointer
=	O
(	O
gsl_histogram_pdf	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_histogram_pdf	struct
)	O
)	O
;	O
if	O
(	O
p	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for histogram pdf struct"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
p	pointer
->	O
range	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
(	O
n	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
p	pointer
->	O
range	pointer
==	O
0	int
)	O
{	O
free	function
(	O
p	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for histogram pdf ranges"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
p	pointer
->	O
sum	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
(	O
n	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
p	pointer
->	O
sum	pointer
==	O
0	int
)	O
{	O
free	function
(	O
p	pointer
->	O
range	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for histogram pdf sums"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
p	pointer
->	O
n	long
=	O
n	long
;	O
return	O
p	pointer
;	O
}	O
int	O
gsl_histogram_pdf_init	function
(	O
gsl_histogram_pdf	struct
*	O
p	pointer
,	O
const	O
gsl_histogram	struct
*	O
h	pointer
)	O
{	O
size_t	long
i	pointer
;	O
size_t	long
n	long
=	O
p	pointer
->	O
n	long
;	O
if	O
(	O
n	long
!=	O
h	pointer
->	O
n	long
)	O
{	O
GSL_ERROR	O
(	O
"histogram length must match pdf length"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
n	long
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
h	pointer
->	O
bin	pointer
[	O
i	pointer
]	O
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"histogram bins must be non-negative to compute"	pointer
"a probability distribution"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
n	long
+	O
1	int
;	O
i	pointer
++	O
)	O
{	O
p	pointer
->	O
range	pointer
[	O
i	pointer
]	O
=	O
h	pointer
->	O
range	pointer
[	O
i	pointer
]	O
;	O
}	O
{	O
double	O
mean	double
=	O
0	int
,	O
sum	pointer
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
n	long
;	O
i	pointer
++	O
)	O
{	O
mean	double
+=	O
(	O
h	pointer
->	O
bin	pointer
[	O
i	pointer
]	O
-	O
mean	double
)	O
/	O
(	O
(	O
double	O
)	O
(	O
i	pointer
+	O
1	int
)	O
)	O
;	O
}	O
p	pointer
->	O
sum	pointer
[	O
0	int
]	O
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
n	long
;	O
i	pointer
++	O
)	O
{	O
sum	pointer
+=	O
(	O
h	pointer
->	O
bin	pointer
[	O
i	pointer
]	O
/	O
mean	double
)	O
/	O
n	long
;	O
p	pointer
->	O
sum	pointer
[	O
i	long
+	O
1	int
]	O
=	O
sum	pointer
;	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
void	O
gsl_histogram_pdf_free	function
(	O
gsl_histogram_pdf	struct
*	O
p	pointer
)	O
{	O
RETURN_IF_NULL	O
(	O
p	pointer
)	O
;	O
free	function
(	O
p	pointer
->	O
range	pointer
)	O
;	O
free	function
(	O
p	pointer
->	O
sum	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
static	O
int	O
lookup_string	function
(	O
const	O
char	O
*	O
p	pointer
,	O
int	O
*	O
precision	pointer
,	O
int	O
*	O
rounding	pointer
,	O
int	O
*	O
exception_mask	pointer
)	O
;	O
int	O
gsl_ieee_read_mode_string	function
(	O
const	O
char	O
*	O
description	pointer
,	O
int	O
*	O
precision	pointer
,	O
int	O
*	O
rounding	pointer
,	O
int	O
*	O
exception_mask	pointer
)	O
{	O
char	O
*	O
start	pointer
;	O
char	O
*	O
end	pointer
;	O
char	O
*	O
p	pointer
;	O
int	O
precision_count	int
=	O
0	int
;	O
int	O
rounding_count	int
=	O
0	int
;	O
int	O
exception_count	int
=	O
0	int
;	O
start	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
description	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
start	int
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"no memory to parse mode string"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
strcpy	function
(	O
start	pointer
,	O
description	pointer
)	O
;	O
p	pointer
=	O
start	pointer
;	O
*	O
precision	pointer
=	O
0	int
;	O
*	O
rounding	pointer
=	O
0	int
;	O
*	O
exception_mask	pointer
=	O
0	int
;	O
do	O
{	O
int	O
status	int
;	O
int	O
new_precision	int
,	O
new_rounding	int
,	O
new_exception	int
;	O
end	pointer
=	O
strchr	function
(	O
p	pointer
,	O
','	O
)	O
;	O
if	O
(	O
end	int
)	O
{	O
*	O
end	pointer
=	O
'\0'	O
;	O
do	O
{	O
end	pointer
++	O
;	O
}	O
while	O
(	O
*	O
end	pointer
==	O
' '	O
||	O
*	O
end	pointer
==	O
','	O
)	O
;	O
}	O
new_precision	int
=	O
0	int
;	O
new_rounding	int
=	O
0	int
;	O
new_exception	int
=	O
0	int
;	O
status	int
=	O
lookup_string	function
(	O
p	pointer
,	O
&	O
new_precision	pointer
,	O
&	O
new_rounding	int
,	O
&	O
new_exception	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
start	pointer
)	O
;	O
GSL_ERROR	O
(	O
"unrecognized GSL_IEEE_MODE string.\nValid settings are:\n\n"	pointer
"  single-precision double-precision extended-precision\n"	pointer
"  round-to-nearest round-down round-up round-to-zero\n"	pointer
"  mask-invalid mask-denormalized mask-division-by-zero\n"	pointer
"  mask-overflow mask-underflow mask-all\n"	pointer
"  trap-common trap-inexact\n"	pointer
"\n"	pointer
"separated by commas. "	pointer
"(e.g. GSL_IEEE_MODE=\"round-down,mask-underflow\")"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
new_precision	int
)	O
{	O
*	O
precision	pointer
=	O
new_precision	int
;	O
precision_count	int
++	O
;	O
if	O
(	O
precision_count	int
>	O
1	int
)	O
{	O
free	function
(	O
start	pointer
)	O
;	O
GSL_ERROR	O
(	O
"attempted to set IEEE precision twice"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
}	O
if	O
(	O
new_rounding	int
)	O
{	O
*	O
rounding	pointer
=	O
new_rounding	int
;	O
rounding_count	int
++	O
;	O
if	O
(	O
rounding_count	int
>	O
1	int
)	O
{	O
free	function
(	O
start	pointer
)	O
;	O
GSL_ERROR	O
(	O
"attempted to set IEEE rounding mode twice"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
}	O
if	O
(	O
new_exception	int
)	O
{	O
*	O
exception_mask	pointer
|=	O
new_exception	int
;	O
exception_count	int
++	O
;	O
}	O
p	pointer
=	O
end	pointer
;	O
}	O
while	O
(	O
end	pointer
&&	O
*	O
p	pointer
!=	O
'\0'	O
)	O
;	O
free	function
(	O
start	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
lookup_string	function
(	O
const	O
char	O
*	O
p	pointer
,	O
int	O
*	O
precision	pointer
,	O
int	O
*	O
rounding	pointer
,	O
int	O
*	O
exception_mask	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"single-precision"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
precision	pointer
=	O
GSL_IEEE_SINGLE_PRECISION	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"double-precision"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
precision	pointer
=	O
GSL_IEEE_DOUBLE_PRECISION	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"extended-precision"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
precision	pointer
=	O
GSL_IEEE_EXTENDED_PRECISION	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"round-to-nearest"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
rounding	pointer
=	O
GSL_IEEE_ROUND_TO_NEAREST	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"round-down"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
rounding	pointer
=	O
GSL_IEEE_ROUND_DOWN	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"round-up"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
rounding	pointer
=	O
GSL_IEEE_ROUND_UP	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"round-to-zero"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
rounding	pointer
=	O
GSL_IEEE_ROUND_TO_ZERO	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-all"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_ALL	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-invalid"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_INVALID	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-denormalized"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_DENORMALIZED	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-division-by-zero"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_DIVISION_BY_ZERO	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-overflow"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_OVERFLOW	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"mask-underflow"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_MASK_UNDERFLOW	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"trap-inexact"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
exception_mask	pointer
=	O
GSL_IEEE_TRAP_INEXACT	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"trap-common"	pointer
)	O
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
exponential_check	function
(	O
const	O
size_t	long
n	int
,	O
const	O
gsl_integration_fixed_params	struct
*	O
params	pointer
)	O
{	O
(	O
void	O
)	O
n	int
;	O
if	O
(	O
fabs	function
(	O
params	pointer
->	O
b	double
-	O
params	pointer
->	O
a	double
)	O
<=	O
GSL_DBL_EPSILON	int
)	O
{	O
GSL_ERROR	O
(	O
"|b - a| too small"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
params	pointer
->	O
a	double
>=	O
params	pointer
->	O
b	double
)	O
{	O
GSL_ERROR	O
(	O
"lower integration limit must be smaller than upper limit"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
params	pointer
->	O
alpha	double
<=	O
-	O
1.0	int
)	O
{	O
GSL_ERROR	O
(	O
"alpha must be > -1"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
{	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
exponential_init	function
(	O
const	O
size_t	long
n	int
,	O
double	O
*	O
diag	pointer
,	O
double	O
*	O
subdiag	pointer
,	O
gsl_integration_fixed_params	struct
*	O
params	pointer
)	O
{	O
size_t	long
i	long
;	O
double	O
a2i	double
=	O
params	pointer
->	O
alpha	double
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<=	O
n	int
;	O
i	long
++	O
)	O
{	O
diag	pointer
[	O
i	long
-	O
1	int
]	O
=	O
0.0	int
;	O
a2i	double
+=	O
2.0	int
;	O
subdiag	pointer
[	O
i	long
-	O
1	int
]	O
=	O
(	O
i	long
+	O
params	pointer
->	O
alpha	double
*	O
(	O
i	long
%	O
2	int
)	O
)	O
/	O
sqrt	function
(	O
a2i	double
*	O
a2i	double
-	O
1.0	int
)	O
;	O
}	O
params	pointer
->	O
zemu	double
=	O
2.0	int
/	O
(	O
params	pointer
->	O
alpha	double
+	O
1.0	int
)	O
;	O
params	pointer
->	O
shft	double
=	O
0.5	int
*	O
(	O
params	pointer
->	O
b	double
+	O
params	pointer
->	O
a	double
)	O
;	O
params	pointer
->	O
slp	double
=	O
0.5	int
*	O
(	O
params	pointer
->	O
b	double
-	O
params	pointer
->	O
a	double
)	O
;	O
params	pointer
->	O
al	double
=	O
params	pointer
->	O
alpha	double
;	O
params	pointer
->	O
be	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_integration_fixed_type	struct
exponential_type	struct
=	O
{	O
exponential_check	pointer
,	O
exponential_init	function
}	O
;	O
const	O
gsl_integration_fixed_type	struct
*	O
gsl_integration_fixed_exponential	pointer
=	O
&	O
exponential_type	struct
;	O
static	O
int	O
gegenbauer_check	function
(	O
const	O
size_t	long
n	int
,	O
const	O
gsl_integration_fixed_params	struct
*	O
params	pointer
)	O
{	O
(	O
void	O
)	O
n	int
;	O
if	O
(	O
fabs	function
(	O
params	pointer
->	O
b	double
-	O
params	pointer
->	O
a	double
)	O
<=	O
GSL_DBL_EPSILON	int
)	O
{	O
GSL_ERROR	O
(	O
"|b - a| too small"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
params	pointer
->	O
a	double
>=	O
params	pointer
->	O
b	double
)	O
{	O
GSL_ERROR	O
(	O
"lower integration limit must be smaller than upper limit"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
params	pointer
->	O
alpha	double
<=	O
-	O
1.0	int
)	O
{	O
GSL_ERROR	O
(	O
"alpha must be > -1"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
{	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
gegenbauer_init	function
(	O
const	O
size_t	long
n	int
,	O
double	O
*	O
diag	pointer
,	O
double	O
*	O
subdiag	pointer
,	O
gsl_integration_fixed_params	struct
*	O
params	pointer
)	O
{	O
size_t	long
i	long
;	O
diag	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
subdiag	pointer
[	O
0	int
]	O
=	O
sqrt	function
(	O
1.0	int
/	O
(	O
2.0	int
*	O
params	pointer
->	O
alpha	double
+	O
3.0	int
)	O
)	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
diag	pointer
[	O
i	long
]	O
=	O
0.0	int
;	O
subdiag	pointer
[	O
i	long
]	O
=	O
sqrt	function
(	O
(	O
i	long
+	O
1.0	int
)	O
*	O
(	O
2.0	int
*	O
params	pointer
->	O
alpha	double
+	O
i	long
+	O
1.0	int
)	O
/	O
(	O
4.0	int
*	O
(	O
params	pointer
->	O
alpha	double
+	O
i	long
+	O
1.0	int
)	O
*	O
(	O
params	pointer
->	O
alpha	double
+	O
i	long
+	O
1.0	int
)	O
-	O
1.0	int
)	O
)	O
;	O
}	O
params	pointer
->	O
zemu	double
=	O
M_SQRTPI	int
*	O
gsl_sf_gamma	function
(	O
params	pointer
->	O
alpha	double
+	O
1.0	int
)	O
/	O
gsl_sf_gamma	function
(	O
params	pointer
->	O
alpha	double
+	O
1.5	int
)	O
;	O
params	pointer
->	O
shft	double
=	O
0.5	int
*	O
(	O
params	pointer
->	O
b	double
+	O
params	pointer
->	O
a	double
)	O
;	O
params	pointer
->	O
slp	double
=	O
0.5	int
*	O
(	O
params	pointer
->	O
b	double
-	O
params	pointer
->	O
a	double
)	O
;	O
params	pointer
->	O
al	double
=	O
params	pointer
->	O
alpha	double
;	O
params	pointer
->	O
be	double
=	O
params	pointer
->	O
alpha	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_integration_fixed_type	struct
gegenbauer_type	struct
=	O
{	O
gegenbauer_check	pointer
,	O
gegenbauer_init	function
}	O
;	O
const	O
gsl_integration_fixed_type	struct
*	O
gsl_integration_fixed_gegenbauer	pointer
=	O
&	O
gegenbauer_type	struct
;	O
static	O
int	O
jacobi_check	function
(	O
const	O
size_t	long
n	int
,	O
const	O
gsl_integration_fixed_params	struct
*	O
params	pointer
)	O
{	O
(	O
void	O
)	O
n	int
;	O
if	O
(	O
fabs	function
(	O
params	pointer
->	O
b	double
-	O
params	pointer
->	O
a	double
)	O
<=	O
GSL_DBL_EPSILON	int
)	O
{	O
GSL_ERROR	O
(	O
"|b - a| too small"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
params	pointer
->	O
a	double
>=	O
params	pointer
->	O
b	double
)	O
{	O
GSL_ERROR	O
(	O
"lower integration limit must be smaller than upper limit"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
params	pointer
->	O
alpha	double
<=	O
-	O
1.0	int
||	O
params	pointer
->	O
beta	double
<=	O
-	O
1.0	int
)	O
{	O
GSL_ERROR	O
(	O
"alpha and beta must be > -1"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
{	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
jacobi_init	function
(	O
const	O
size_t	long
n	int
,	O
double	O
*	O
diag	pointer
,	O
double	O
*	O
subdiag	pointer
,	O
gsl_integration_fixed_params	struct
*	O
params	pointer
)	O
{	O
const	O
double	O
absum	double
=	O
params	pointer
->	O
beta	double
+	O
params	pointer
->	O
alpha	double
;	O
const	O
double	O
abdiff	double
=	O
params	pointer
->	O
beta	double
-	O
params	pointer
->	O
alpha	double
;	O
const	O
double	O
a2b2	double
=	O
absum	struct
*	O
abdiff	pointer
;	O
size_t	long
i	long
;	O
diag	pointer
[	O
0	int
]	O
=	O
abdiff	double
/	O
(	O
absum	pointer
+	O
2.0	int
)	O
;	O
subdiag	pointer
[	O
0	int
]	O
=	O
2.0	int
*	O
sqrt	function
(	O
(	O
params	pointer
->	O
alpha	double
+	O
1.0	int
)	O
*	O
(	O
params	pointer
->	O
beta	double
+	O
1.0	int
)	O
/	O
(	O
absum	int
+	O
3.0	int
)	O
)	O
/	O
(	O
absum	double
+	O
2.0	int
)	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
diag	pointer
[	O
i	long
]	O
=	O
a2b2	double
/	O
(	O
(	O
absum	double
+	O
2.0	int
*	O
i	long
)	O
*	O
(	O
absum	double
+	O
2.0	int
*	O
i	long
+	O
2.0	int
)	O
)	O
;	O
subdiag	pointer
[	O
i	long
]	O
=	O
sqrt	function
(	O
4.0	int
*	O
(	O
i	long
+	O
1.0	int
)	O
*	O
(	O
params	pointer
->	O
alpha	double
+	O
i	long
+	O
1.0	int
)	O
*	O
(	O
params	pointer
->	O
beta	double
+	O
i	long
+	O
1.0	int
)	O
*	O
(	O
absum	int
+	O
i	long
+	O
1.0	int
)	O
/	O
(	O
pow	function
(	O
(	O
absum	double
+	O
2.0	int
*	O
i	long
+	O
2.0	int
)	O
,	O
2.0	int
)	O
-	O
1.0	int
)	O
)	O
/	O
(	O
absum	double
+	O
2.0	int
*	O
i	long
+	O
2.0	int
)	O
;	O
}	O
params	pointer
->	O
zemu	double
=	O
pow	function
(	O
2.0	int
,	O
absum	double
+	O
1.0	int
)	O
*	O
gsl_sf_gamma	function
(	O
params	pointer
->	O
alpha	double
+	O
1.0	int
)	O
*	O
gsl_sf_gamma	function
(	O
params	pointer
->	O
beta	double
+	O
1.0	int
)	O
/	O
gsl_sf_gamma	function
(	O
absum	double
+	O
2.0	int
)	O
;	O
params	pointer
->	O
shft	double
=	O
0.5	int
*	O
(	O
params	pointer
->	O
b	double
+	O
params	pointer
->	O
a	double
)	O
;	O
params	pointer
->	O
slp	double
=	O
0.5	int
*	O
(	O
params	pointer
->	O
b	double
-	O
params	pointer
->	O
a	double
)	O
;	O
params	pointer
->	O
al	double
=	O
params	pointer
->	O
alpha	double
;	O
params	pointer
->	O
be	double
=	O
params	pointer
->	O
beta	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_integration_fixed_type	struct
jacobi_type	struct
=	O
{	O
jacobi_check	pointer
,	O
jacobi_init	function
}	O
;	O
const	O
gsl_integration_fixed_type	struct
*	O
gsl_integration_fixed_jacobi	pointer
=	O
&	O
jacobi_type	struct
;	O
static	O
int	O
legendre_check	function
(	O
const	O
size_t	long
n	int
,	O
const	O
gsl_integration_fixed_params	struct
*	O
params	pointer
)	O
{	O
(	O
void	O
)	O
n	int
;	O
if	O
(	O
fabs	function
(	O
params	pointer
->	O
b	double
-	O
params	pointer
->	O
a	double
)	O
<=	O
GSL_DBL_EPSILON	int
)	O
{	O
GSL_ERROR	O
(	O
"|b - a| too small"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
{	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
legendre_init	function
(	O
const	O
size_t	long
n	int
,	O
double	O
*	O
diag	pointer
,	O
double	O
*	O
subdiag	pointer
,	O
gsl_integration_fixed_params	struct
*	O
params	pointer
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<=	O
n	int
;	O
i	long
++	O
)	O
{	O
diag	pointer
[	O
i	long
-	O
1	int
]	O
=	O
0.0	int
;	O
subdiag	pointer
[	O
i	long
-	O
1	int
]	O
=	O
(	O
double	O
)	O
i	long
/	O
sqrt	function
(	O
4.0	int
*	O
i	long
*	O
i	long
-	O
1.0	int
)	O
;	O
}	O
params	pointer
->	O
zemu	double
=	O
2.0	int
;	O
params	pointer
->	O
shft	double
=	O
0.5	int
*	O
(	O
params	pointer
->	O
b	double
+	O
params	pointer
->	O
a	double
)	O
;	O
params	pointer
->	O
slp	double
=	O
0.5	int
*	O
(	O
params	pointer
->	O
b	double
-	O
params	pointer
->	O
a	double
)	O
;	O
params	pointer
->	O
al	double
=	O
0.0	int
;	O
params	pointer
->	O
be	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_integration_fixed_type	struct
legendre_type	struct
=	O
{	O
legendre_check	pointer
,	O
legendre_init	function
}	O
;	O
const	O
gsl_integration_fixed_type	struct
*	O
gsl_integration_fixed_legendre	pointer
=	O
&	O
legendre_type	struct
;	O
static	O
const	O
double	O
xgk	array
[	O
8	int
]	O
=	O
{	O
0.991455371120812639206854697526329	int
,	O
0.949107912342758524526189684047851	int
,	O
0.864864423359769072789712788640926	int
,	O
0.741531185599394439863864773280788	int
,	O
0.586087235467691130294144838258730	int
,	O
0.405845151377397166906606412076961	int
,	O
0.207784955007898467600689403773245	int
,	O
0.000000000000000000000000000000000	int
}	O
;	O
static	O
const	O
double	O
wg	array
[	O
4	int
]	O
=	O
{	O
0.129484966168869693270611432679082	int
,	O
0.279705391489276667901467771423780	int
,	O
0.381830050505118944950369775488975	int
,	O
0.417959183673469387755102040816327	int
}	O
;	O
static	O
const	O
double	O
wgk	array
[	O
8	int
]	O
=	O
{	O
0.022935322010529224963732008058970	int
,	O
0.063092092629978553290700663189204	int
,	O
0.104790010322250183839876322541518	int
,	O
0.140653259715525918745189590510238	int
,	O
0.169004726639267902826583426598550	int
,	O
0.190350578064785409913256402421014	int
,	O
0.204432940075298892414161999234649	int
,	O
0.209482141084727828012999174891714	int
}	O
;	O
void	O
gsl_integration_qk15	function
(	O
const	O
gsl_function	struct
*	O
f	pointer
,	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
*	O
result	pointer
,	O
double	O
*	O
abserr	pointer
,	O
double	O
*	O
resabs	pointer
,	O
double	O
*	O
resasc	pointer
)	O
{	O
double	O
fv1	array
[	O
8	int
]	O
,	O
fv2	array
[	O
8	int
]	O
;	O
gsl_integration_qk	function
(	O
8	int
,	O
xgk	array
,	O
wg	array
,	O
wgk	array
,	O
fv1	array
,	O
fv2	array
,	O
f	pointer
,	O
a	double
,	O
b	double
,	O
result	pointer
,	O
abserr	pointer
,	O
resabs	pointer
,	O
resasc	pointer
)	O
;	O
}	O
static	O
int	O
rational_check	function
(	O
const	O
size_t	long
n	int
,	O
const	O
gsl_integration_fixed_params	struct
*	O
params	pointer
)	O
{	O
if	O
(	O
fabs	function
(	O
params	pointer
->	O
b	double
-	O
params	pointer
->	O
a	double
)	O
<=	O
GSL_DBL_EPSILON	int
)	O
{	O
GSL_ERROR	O
(	O
"|b - a| too small"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
params	pointer
->	O
alpha	double
<=	O
-	O
1.0	int
)	O
{	O
GSL_ERROR	O
(	O
"alpha must be > -1"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
params	pointer
->	O
beta	double
>=	O
0.0	int
||	O
params	pointer
->	O
alpha	double
+	O
params	pointer
->	O
beta	double
+	O
2	int
*	O
n	int
>=	O
0.0	int
||	O
0.0	int
>=	O
params	pointer
->	O
alpha	double
+	O
2	int
*	O
n	int
)	O
{	O
GSL_ERROR	O
(	O
"beta < alpha + beta + 2n < 0 is required"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
params	pointer
->	O
a	double
+	O
params	pointer
->	O
b	double
<=	O
0.0	int
)	O
{	O
GSL_ERROR	O
(	O
"a + b <= 0 is not allowed"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
{	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
rational_init	function
(	O
const	O
size_t	long
n	int
,	O
double	O
*	O
diag	pointer
,	O
double	O
*	O
subdiag	pointer
,	O
gsl_integration_fixed_params	struct
*	O
params	pointer
)	O
{	O
const	O
double	O
absum	double
=	O
params	pointer
->	O
beta	double
+	O
params	pointer
->	O
alpha	double
;	O
const	O
double	O
a1	double
=	O
params	pointer
->	O
alpha	double
+	O
1.0	int
;	O
const	O
double	O
aba1	double
=	O
absum	double
*	O
a1	double
;	O
double	O
ab2i	double
=	O
absum	double
+	O
2.0	int
;	O
size_t	long
i	long
;	O
diag	pointer
[	O
0	int
]	O
=	O
-	O
a1	double
/	O
(	O
absum	pointer
+	O
2.0	int
)	O
;	O
subdiag	pointer
[	O
0	int
]	O
=	O
sqrt	function
(	O
-	O
diag	pointer
[	O
0	int
]	O
*	O
(	O
params	pointer
->	O
beta	double
+	O
1.0	int
)	O
/	O
(	O
(	O
absum	double
+	O
2.0	int
)	O
*	O
(	O
absum	int
+	O
3.0	int
)	O
)	O
)	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
n	int
-	O
1	int
;	O
i	long
++	O
)	O
{	O
ab2i	double
+=	O
2.0	int
;	O
diag	pointer
[	O
i	long
]	O
=	O
(	O
-	O
aba1	double
-	O
2.0	int
*	O
i	long
*	O
(	O
absum	double
+	O
i	long
+	O
1.0	int
)	O
)	O
/	O
(	O
ab2i	double
*	O
(	O
ab2i	double
-	O
2.0	int
)	O
)	O
;	O
subdiag	pointer
[	O
i	long
]	O
=	O
sqrt	function
(	O
(	O
i	long
+	O
1.0	int
)	O
*	O
(	O
params	pointer
->	O
alpha	double
+	O
i	long
+	O
1.0	int
)	O
/	O
(	O
ab2i	double
-	O
1.0	int
)	O
*	O
(	O
params	pointer
->	O
beta	double
+	O
i	long
+	O
1.0	int
)	O
/	O
(	O
ab2i	struct
*	O
ab2i	pointer
)	O
*	O
(	O
absum	pointer
+	O
i	long
+	O
1.0	int
)	O
/	O
(	O
ab2i	double
+	O
1.0	int
)	O
)	O
;	O
}	O
diag	pointer
[	O
n	long
-	O
1	int
]	O
=	O
(	O
-	O
aba1	double
-	O
2.0	int
*	O
(	O
n	long
-	O
1.0	int
)	O
*	O
(	O
absum	pointer
+	O
n	long
)	O
)	O
/	O
(	O
(	O
absum	pointer
+	O
2.0	int
*	O
n	long
)	O
*	O
(	O
absum	pointer
+	O
2.0	int
*	O
n	long
-	O
2.0	int
)	O
)	O
;	O
subdiag	pointer
[	O
n	long
-	O
1	int
]	O
=	O
0.0	int
;	O
params	pointer
->	O
zemu	double
=	O
gsl_sf_gamma	function
(	O
params	pointer
->	O
alpha	double
+	O
1.0	int
)	O
*	O
gsl_sf_gamma	function
(	O
-	O
absum	double
-	O
1.0	int
)	O
/	O
gsl_sf_gamma	function
(	O
-	O
params	pointer
->	O
beta	double
)	O
;	O
params	pointer
->	O
shft	double
=	O
params	pointer
->	O
a	double
;	O
params	pointer
->	O
slp	double
=	O
params	pointer
->	O
b	double
+	O
params	pointer
->	O
a	double
;	O
params	pointer
->	O
al	double
=	O
params	pointer
->	O
alpha	double
;	O
params	pointer
->	O
be	double
=	O
params	pointer
->	O
beta	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_integration_fixed_type	struct
rational_type	struct
=	O
{	O
rational_check	pointer
,	O
rational_init	function
}	O
;	O
const	O
gsl_integration_fixed_type	struct
*	O
gsl_integration_fixed_rational	pointer
=	O
&	O
rational_type	struct
;	O
static	O
int	O
linear_init	function
(	O
void	O
*	O
vstate	pointer
,	O
const	O
double	O
x_array	array
[	O
]	O
,	O
const	O
double	O
y_array	array
[	O
]	O
,	O
size_t	long
size	long
)	O
{	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
linear_eval	function
(	O
const	O
void	O
*	O
vstate	pointer
,	O
const	O
double	O
x_array	array
[	O
]	O
,	O
const	O
double	O
y_array	array
[	O
]	O
,	O
size_t	long
size	long
,	O
double	O
x	double
,	O
gsl_interp_accel	struct
*	O
a	double
,	O
double	O
*	O
y	double
)	O
{	O
double	O
x_lo	double
,	O
x_hi	int
;	O
double	O
y_lo	double
,	O
y_hi	int
;	O
double	O
dx	pointer
;	O
size_t	long
index	int
;	O
if	O
(	O
a	double
!=	O
0	int
)	O
{	O
index	function
=	O
gsl_interp_accel_find	function
(	O
a	double
,	O
x_array	array
,	O
size	long
,	O
x	double
)	O
;	O
}	O
else	O
{	O
index	function
=	O
gsl_interp_bsearch	function
(	O
x_array	array
,	O
x	double
,	O
0	int
,	O
size	long
-	O
1	int
)	O
;	O
}	O
x_lo	pointer
=	O
x_array	array
[	O
index	function
]	O
;	O
x_hi	pointer
=	O
x_array	array
[	O
index	function
+	O
1	int
]	O
;	O
y_lo	pointer
=	O
y_array	array
[	O
index	function
]	O
;	O
y_hi	pointer
=	O
y_array	array
[	O
index	function
+	O
1	int
]	O
;	O
dx	pointer
=	O
x_hi	int
-	O
x_lo	double
;	O
if	O
(	O
dx	pointer
>	O
0.0	int
)	O
{	O
*	O
y	double
=	O
y_lo	double
+	O
(	O
x	double
-	O
x_lo	int
)	O
/	O
dx	pointer
*	O
(	O
y_hi	int
-	O
y_lo	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
*	O
y	double
=	O
0.0	int
;	O
return	O
GSL_EINVAL	int
;	O
}	O
}	O
static	O
int	O
linear_eval_deriv	function
(	O
const	O
void	O
*	O
vstate	pointer
,	O
const	O
double	O
x_array	array
[	O
]	O
,	O
const	O
double	O
y_array	array
[	O
]	O
,	O
size_t	long
size	long
,	O
double	O
x	double
,	O
gsl_interp_accel	struct
*	O
a	double
,	O
double	O
*	O
dydx	pointer
)	O
{	O
double	O
x_lo	double
,	O
x_hi	int
;	O
double	O
y_lo	double
,	O
y_hi	int
;	O
double	O
dx	pointer
;	O
double	O
dy	double
;	O
size_t	long
index	function
;	O
if	O
(	O
a	double
!=	O
0	int
)	O
{	O
index	function
=	O
gsl_interp_accel_find	function
(	O
a	double
,	O
x_array	double
,	O
size	long
,	O
x	double
)	O
;	O
}	O
else	O
{	O
index	function
=	O
gsl_interp_bsearch	function
(	O
x_array	double
,	O
x	double
,	O
0	int
,	O
size	long
-	O
1	int
)	O
;	O
}	O
x_lo	double
=	O
x_array	array
[	O
index	function
]	O
;	O
x_hi	pointer
=	O
x_array	array
[	O
index	function
+	O
1	int
]	O
;	O
y_lo	pointer
=	O
y_array	array
[	O
index	function
]	O
;	O
y_hi	pointer
=	O
y_array	array
[	O
index	function
+	O
1	int
]	O
;	O
dx	pointer
=	O
x_hi	int
-	O
x_lo	double
;	O
dy	double
=	O
y_hi	double
-	O
y_lo	double
;	O
if	O
(	O
dx	pointer
>	O
0.0	int
)	O
{	O
*	O
dydx	pointer
=	O
dy	double
/	O
dx	double
;	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
*	O
dydx	pointer
=	O
0.0	int
;	O
return	O
GSL_EINVAL	int
;	O
}	O
}	O
static	O
int	O
linear_eval_deriv2	function
(	O
const	O
void	O
*	O
vstate	pointer
,	O
const	O
double	O
x_array	array
[	O
]	O
,	O
const	O
double	O
y_array	array
[	O
]	O
,	O
size_t	long
size	long
,	O
double	O
x	double
,	O
gsl_interp_accel	struct
*	O
a	double
,	O
double	O
*	O
y_pp	pointer
)	O
{	O
*	O
y_pp	pointer
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
linear_eval_integ	function
(	O
const	O
void	O
*	O
vstate	pointer
,	O
const	O
double	O
x_array	array
[	O
]	O
,	O
const	O
double	O
y_array	array
[	O
]	O
,	O
size_t	long
size	long
,	O
gsl_interp_accel	struct
*	O
acc	pointer
,	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
*	O
result	pointer
)	O
{	O
size_t	long
i	int
,	O
index_a	int
,	O
index_b	int
;	O
if	O
(	O
acc	int
!=	O
0	int
)	O
{	O
index_a	int
=	O
gsl_interp_accel_find	function
(	O
acc	pointer
,	O
x_array	pointer
,	O
size	int
,	O
a	pointer
)	O
;	O
index_b	pointer
=	O
gsl_interp_accel_find	function
(	O
acc	pointer
,	O
x_array	pointer
,	O
size	int
,	O
b	double
)	O
;	O
}	O
else	O
{	O
index_a	double
=	O
gsl_interp_bsearch	function
(	O
x_array	array
,	O
a	double
,	O
0	int
,	O
size	long
-	O
1	int
)	O
;	O
index_b	int
=	O
gsl_interp_bsearch	function
(	O
x_array	array
,	O
b	double
,	O
0	int
,	O
size	long
-	O
1	int
)	O
;	O
}	O
*	O
result	pointer
=	O
0.0	int
;	O
for	O
(	O
i	int
=	O
index_a	int
;	O
i	long
<=	O
index_b	int
;	O
i	long
++	O
)	O
{	O
const	O
double	O
x_hi	double
=	O
x_array	array
[	O
i	long
+	O
1	int
]	O
;	O
const	O
double	O
x_lo	double
=	O
x_array	array
[	O
i	long
]	O
;	O
const	O
double	O
y_lo	double
=	O
y_array	array
[	O
i	int
]	O
;	O
const	O
double	O
y_hi	double
=	O
y_array	array
[	O
i	int
+	O
1	int
]	O
;	O
const	O
double	O
dx	double
=	O
x_hi	int
-	O
x_lo	double
;	O
if	O
(	O
dx	pointer
!=	O
0.0	int
)	O
{	O
if	O
(	O
i	int
==	O
index_a	int
||	O
i	int
==	O
index_b	int
)	O
{	O
double	O
x1	double
=	O
(	O
i	int
==	O
index_a	int
)	O
?	O
a	double
:	O
x_lo	int
;	O
double	O
x2	double
=	O
(	O
i	int
==	O
index_b	int
)	O
?	O
b	double
:	O
x_hi	int
;	O
const	O
double	O
D	int
=	O
(	O
y_hi	double
-	O
y_lo	double
)	O
/	O
dx	double
;	O
*	O
result	pointer
+=	O
(	O
x2	double
-	O
x1	double
)	O
*	O
(	O
y_lo	double
+	O
0.5	int
*	O
D	double
*	O
(	O
(	O
x2	double
-	O
x_lo	double
)	O
+	O
(	O
x1	double
-	O
x_lo	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
*	O
result	pointer
+=	O
0.5	int
*	O
dx	pointer
*	O
(	O
y_lo	double
+	O
y_hi	double
)	O
;	O
}	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_interp_type	struct
linear_type	struct
=	O
{	O
"linear"	pointer
,	O
2	int
,	O
NULL	O
,	O
&	O
linear_init	function
,	O
&	O
linear_eval	function
,	O
&	O
linear_eval_deriv	function
,	O
&	O
linear_eval_deriv2	function
,	O
&	O
linear_eval_integ	function
,	O
NULL	O
,	O
}	O
;	O
const	O
gsl_interp_type	struct
*	O
gsl_interp_linear	pointer
=	O
&	O
linear_type	struct
;	O
typedef	O
struct	O
{	O
double	O
d	double
,	O
e	int
,	O
v	pointer
,	O
w	pointer
;	O
double	O
f_v	double
,	O
f_w	int
;	O
}	O
brent_state_t	struct
;	O
static	O
int	O
brent_init	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_function	struct
*	O
f	pointer
,	O
double	O
x_minimum	double
,	O
double	O
f_minimum	double
,	O
double	O
x_lower	double
,	O
double	O
f_lower	double
,	O
double	O
x_upper	double
,	O
double	O
f_upper	double
)	O
;	O
static	O
int	O
brent_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_function	struct
*	O
f	pointer
,	O
double	O
*	O
x_minimum	double
,	O
double	O
*	O
f_minimum	double
,	O
double	O
*	O
x_lower	double
,	O
double	O
*	O
f_lower	double
,	O
double	O
*	O
x_upper	double
,	O
double	O
*	O
f_upper	double
)	O
;	O
static	O
int	O
brent_init	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_function	struct
*	O
f	pointer
,	O
double	O
x_minimum	double
,	O
double	O
f_minimum	double
,	O
double	O
x_lower	double
,	O
double	O
f_lower	double
,	O
double	O
x_upper	double
,	O
double	O
f_upper	double
)	O
{	O
brent_state_t	struct
*	O
state	pointer
=	O
(	O
brent_state_t	struct
*	O
)	O
vstate	pointer
;	O
const	O
double	O
golden	double
=	O
0.3819660	int
;	O
double	O
v	double
=	O
x_lower	double
+	O
golden	double
*	O
(	O
x_upper	double
-	O
x_lower	double
)	O
;	O
double	O
w	pointer
=	O
v	pointer
;	O
double	O
f_vw	double
;	O
x_minimum	double
=	O
0	int
;	O
f_minimum	double
=	O
0	int
;	O
f_lower	double
=	O
0	int
;	O
f_upper	double
=	O
0	int
;	O
state	pointer
->	O
v	pointer
=	O
v	pointer
;	O
state	pointer
->	O
w	int
=	O
w	int
;	O
state	pointer
->	O
d	int
=	O
0	int
;	O
state	pointer
->	O
e	int
=	O
0	int
;	O
SAFE_FUNC_CALL	O
(	O
f	pointer
,	O
v	pointer
,	O
&	O
f_vw	int
)	O
;	O
state	pointer
->	O
f_v	double
=	O
f_vw	int
;	O
state	pointer
->	O
f_w	int
=	O
f_vw	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
brent_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_function	struct
*	O
f	pointer
,	O
double	O
*	O
x_minimum	double
,	O
double	O
*	O
f_minimum	double
,	O
double	O
*	O
x_lower	double
,	O
double	O
*	O
f_lower	double
,	O
double	O
*	O
x_upper	double
,	O
double	O
*	O
f_upper	double
)	O
{	O
brent_state_t	struct
*	O
state	pointer
=	O
(	O
brent_state_t	struct
*	O
)	O
vstate	pointer
;	O
const	O
double	O
x_left	double
=	O
*	O
x_lower	double
;	O
const	O
double	O
x_right	double
=	O
*	O
x_upper	double
;	O
const	O
double	O
z	double
=	O
*	O
x_minimum	double
;	O
double	O
d	double
=	O
state	pointer
->	O
e	int
;	O
double	O
e	int
=	O
state	pointer
->	O
d	int
;	O
double	O
u	double
,	O
f_u	double
;	O
const	O
double	O
v	double
=	O
state	pointer
->	O
v	pointer
;	O
const	O
double	O
w	int
=	O
state	pointer
->	O
w	pointer
;	O
const	O
double	O
f_v	double
=	O
state	pointer
->	O
f_v	int
;	O
const	O
double	O
f_w	double
=	O
state	pointer
->	O
f_w	double
;	O
const	O
double	O
f_z	double
=	O
*	O
f_minimum	double
;	O
const	O
double	O
golden	double
=	O
0.3819660	int
;	O
const	O
double	O
w_lower	double
=	O
(	O
z	double
-	O
x_left	double
)	O
;	O
const	O
double	O
w_upper	double
=	O
(	O
x_right	double
-	O
z	double
)	O
;	O
const	O
double	O
tolerance	double
=	O
GSL_SQRT_DBL_EPSILON	int
*	O
fabs	function
(	O
z	double
)	O
;	O
double	O
p	int
=	O
0	int
,	O
q	int
=	O
0	int
,	O
r	double
=	O
0	int
;	O
const	O
double	O
midpoint	double
=	O
0.5	int
*	O
(	O
x_left	double
+	O
x_right	double
)	O
;	O
if	O
(	O
fabs	function
(	O
e	int
)	O
>	O
tolerance	double
)	O
{	O
r	double
=	O
(	O
z	double
-	O
w	double
)	O
*	O
(	O
f_z	double
-	O
f_v	int
)	O
;	O
q	double
=	O
(	O
z	double
-	O
v	double
)	O
*	O
(	O
f_z	double
-	O
f_w	double
)	O
;	O
p	pointer
=	O
(	O
z	double
-	O
v	double
)	O
*	O
q	pointer
-	O
(	O
z	double
-	O
w	double
)	O
*	O
r	pointer
;	O
q	double
=	O
2	int
*	O
(	O
q	double
-	O
r	double
)	O
;	O
if	O
(	O
q	double
>	O
0	int
)	O
{	O
p	pointer
=	O
-	O
p	double
;	O
}	O
else	O
{	O
q	double
=	O
-	O
q	double
;	O
}	O
r	double
=	O
e	int
;	O
e	int
=	O
d	double
;	O
}	O
if	O
(	O
fabs	function
(	O
p	double
)	O
<	O
fabs	function
(	O
0.5	int
*	O
q	double
*	O
r	double
)	O
&&	O
p	double
<	O
q	double
*	O
w_lower	double
&&	O
p	double
<	O
q	double
*	O
w_upper	double
)	O
{	O
double	O
t2	double
=	O
2	int
*	O
tolerance	double
;	O
d	double
=	O
p	double
/	O
q	double
;	O
u	double
=	O
z	double
+	O
d	long
;	O
if	O
(	O
(	O
u	double
-	O
x_left	double
)	O
<	O
t2	double
||	O
(	O
x_right	double
-	O
u	double
)	O
<	O
t2	double
)	O
{	O
d	double
=	O
(	O
z	double
<	O
midpoint	double
)	O
?	O
tolerance	double
:	O
-	O
tolerance	double
;	O
}	O
}	O
else	O
{	O
e	int
=	O
(	O
z	double
<	O
midpoint	double
)	O
?	O
x_right	double
-	O
z	double
:	O
-	O
(	O
z	double
-	O
x_left	double
)	O
;	O
d	double
=	O
golden	double
*	O
e	int
;	O
}	O
if	O
(	O
fabs	function
(	O
d	double
)	O
>=	O
tolerance	double
)	O
{	O
u	double
=	O
z	double
+	O
d	long
;	O
}	O
else	O
{	O
u	double
=	O
z	double
+	O
(	O
(	O
d	int
>	O
0	int
)	O
?	O
tolerance	double
:	O
-	O
tolerance	double
)	O
;	O
}	O
state	pointer
->	O
e	int
=	O
e	int
;	O
state	pointer
->	O
d	double
=	O
d	double
;	O
SAFE_FUNC_CALL	O
(	O
f	pointer
,	O
u	double
,	O
&	O
f_u	struct
)	O
;	O
if	O
(	O
f_u	int
<=	O
f_z	int
)	O
{	O
if	O
(	O
u	double
<	O
z	double
)	O
{	O
*	O
x_upper	double
=	O
z	double
;	O
*	O
f_upper	double
=	O
f_z	int
;	O
}	O
else	O
{	O
*	O
x_lower	double
=	O
z	double
;	O
*	O
f_lower	double
=	O
f_z	int
;	O
}	O
state	pointer
->	O
v	pointer
=	O
w	pointer
;	O
state	pointer
->	O
f_v	double
=	O
f_w	int
;	O
state	pointer
->	O
w	int
=	O
z	double
;	O
state	pointer
->	O
f_w	int
=	O
f_z	int
;	O
*	O
x_minimum	pointer
=	O
u	pointer
;	O
*	O
f_minimum	double
=	O
f_u	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
if	O
(	O
u	pointer
<	O
z	double
)	O
{	O
*	O
x_lower	double
=	O
u	double
;	O
*	O
f_lower	double
=	O
f_u	int
;	O
}	O
else	O
{	O
*	O
x_upper	double
=	O
u	double
;	O
*	O
f_upper	double
=	O
f_u	int
;	O
}	O
if	O
(	O
f_u	double
<=	O
f_w	int
||	O
w	double
==	O
z	double
)	O
{	O
state	pointer
->	O
v	pointer
=	O
w	int
;	O
state	pointer
->	O
f_v	double
=	O
f_w	int
;	O
state	pointer
->	O
w	array
=	O
u	int
;	O
state	pointer
->	O
f_w	double
=	O
f_u	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
f_u	double
<=	O
f_v	int
||	O
v	double
==	O
z	double
||	O
v	pointer
==	O
w	pointer
)	O
{	O
state	pointer
->	O
v	pointer
=	O
u	pointer
;	O
state	pointer
->	O
f_v	double
=	O
f_u	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_min_fminimizer_type	struct
brent_type	struct
=	O
{	O
"brent"	pointer
,	O
sizeof	O
(	O
brent_state_t	struct
)	O
,	O
&	O
brent_init	function
,	O
&	O
brent_iterate	function
}	O
;	O
const	O
gsl_min_fminimizer_type	struct
*	O
gsl_min_fminimizer_brent	pointer
=	O
&	O
brent_type	struct
;	O
int	O
gsl_min_test_interval	function
(	O
double	O
x_lower	double
,	O
double	O
x_upper	double
,	O
double	O
epsabs	double
,	O
double	O
epsrel	double
)	O
{	O
const	O
double	O
lower	double
=	O
x_lower	double
;	O
const	O
double	O
upper	double
=	O
x_upper	double
;	O
const	O
double	O
abs_lower	double
=	O
fabs	function
(	O
lower	double
)	O
;	O
const	O
double	O
abs_upper	double
=	O
fabs	function
(	O
upper	int
)	O
;	O
double	O
min_abs	double
,	O
tolerance	double
;	O
if	O
(	O
epsrel	double
<	O
0.0	int
)	O
GSL_ERROR	O
(	O
"relative tolerance is negative"	pointer
,	O
GSL_EBADTOL	int
)	O
;	O
if	O
(	O
epsabs	double
<	O
0.0	int
)	O
GSL_ERROR	O
(	O
"absolute tolerance is negative"	pointer
,	O
GSL_EBADTOL	int
)	O
;	O
if	O
(	O
lower	double
>	O
upper	int
)	O
GSL_ERROR	O
(	O
"lower bound larger than upper_bound"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
if	O
(	O
(	O
lower	int
>	O
0	int
&&	O
upper	int
>	O
0	int
)	O
||	O
(	O
lower	int
<	O
0	int
&&	O
upper	int
<	O
0	int
)	O
)	O
{	O
min_abs	double
=	O
GSL_MIN_DBL	function
(	O
abs_lower	pointer
,	O
abs_upper	double
)	O
;	O
}	O
else	O
{	O
min_abs	double
=	O
0	int
;	O
}	O
tolerance	double
=	O
epsabs	double
+	O
epsrel	double
*	O
min_abs	double
;	O
if	O
(	O
fabs	function
(	O
upper	int
-	O
lower	double
)	O
<	O
tolerance	double
)	O
return	O
GSL_SUCCESS	int
;	O
return	O
GSL_CONTINUE	int
;	O
}	O
size_t	long
gsl_movstat_fill	function
(	O
const	O
gsl_movstat_end_t	enum
endtype	enum
,	O
const	O
gsl_vector	struct
*	O
x	double
,	O
const	O
size_t	long
idx	int
,	O
const	O
size_t	long
H	long
,	O
const	O
size_t	long
J	long
,	O
double	O
*	O
window	pointer
)	O
{	O
if	O
(	O
idx	int
>=	O
x	double
->	O
size	long
)	O
{	O
GSL_ERROR_VAL	O
(	O
"window center index must be between 0 and n - 1"	pointer
,	O
GSL_EDOM	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
const	O
int	O
n	long
=	O
(	O
int	O
)	O
x	double
->	O
size	long
;	O
const	O
int	O
iidx	int
=	O
(	O
int	O
)	O
idx	int
;	O
const	O
int	O
iH	int
=	O
(	O
int	O
)	O
H	long
;	O
const	O
int	O
iJ	int
=	O
(	O
int	O
)	O
J	int
;	O
int	O
idx1	int
,	O
idx2	int
,	O
j	int
;	O
size_t	long
window_size	int
;	O
if	O
(	O
endtype	enum
==	O
GSL_MOVSTAT_END_TRUNCATE	int
)	O
{	O
idx1	int
=	O
GSL_MAX	O
(	O
iidx	int
-	O
iH	int
,	O
0	int
)	O
;	O
idx2	int
=	O
GSL_MIN	O
(	O
iidx	int
+	O
iJ	int
,	O
n	long
-	O
1	int
)	O
;	O
}	O
else	O
{	O
idx1	int
=	O
iidx	int
-	O
iH	int
;	O
idx2	int
=	O
iidx	int
+	O
iJ	int
;	O
}	O
window_size	long
=	O
(	O
size_t	long
)	O
(	O
idx2	int
-	O
idx1	int
+	O
1	int
)	O
;	O
for	O
(	O
j	long
=	O
idx1	int
;	O
j	long
<=	O
idx2	int
;	O
++	O
j	long
)	O
{	O
int	O
widx	int
=	O
j	long
-	O
idx1	int
;	O
if	O
(	O
j	long
<	O
0	int
)	O
{	O
if	O
(	O
endtype	enum
==	O
GSL_MOVSTAT_END_PADZERO	int
)	O
window	pointer
[	O
widx	int
]	O
=	O
0.0	int
;	O
else	O
if	O
(	O
endtype	enum
==	O
GSL_MOVSTAT_END_PADVALUE	int
)	O
window	pointer
[	O
widx	int
]	O
=	O
gsl_vector_get	function
(	O
x	double
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
j	long
>=	O
n	int
)	O
{	O
if	O
(	O
endtype	enum
==	O
GSL_MOVSTAT_END_PADZERO	int
)	O
window	pointer
[	O
widx	int
]	O
=	O
0.0	int
;	O
else	O
if	O
(	O
endtype	enum
==	O
GSL_MOVSTAT_END_PADVALUE	int
)	O
window	pointer
[	O
widx	int
]	O
=	O
gsl_vector_get	function
(	O
x	double
,	O
n	long
-	O
1	int
)	O
;	O
}	O
else	O
{	O
window	pointer
[	O
widx	int
]	O
=	O
gsl_vector_get	function
(	O
x	double
,	O
j	long
)	O
;	O
}	O
}	O
return	O
window_size	int
;	O
}	O
}	O
static	O
int	O
fdjac	function
(	O
const	O
gsl_vector	struct
*	O
x	double
,	O
const	O
gsl_vector	struct
*	O
wts	pointer
,	O
gsl_multifit_function_fdf	struct
*	O
fdf	pointer
,	O
const	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_matrix	struct
*	O
J	pointer
)	O
;	O
static	O
int	O
fdjac	function
(	O
const	O
gsl_vector	struct
*	O
x	double
,	O
const	O
gsl_vector	struct
*	O
wts	pointer
,	O
gsl_multifit_function_fdf	struct
*	O
fdf	pointer
,	O
const	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_matrix	struct
*	O
J	pointer
)	O
{	O
int	O
status	int
=	O
0	int
;	O
size_t	long
i	long
,	O
j	int
;	O
double	O
h	double
;	O
const	O
double	O
epsfcn	double
=	O
0.0	int
;	O
double	O
eps	double
=	O
sqrt	function
(	O
GSL_MAX	O
(	O
epsfcn	double
,	O
GSL_DBL_EPSILON	int
)	O
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
fdf	pointer
->	O
p	int
;	O
++	O
j	long
)	O
{	O
double	O
xj	double
=	O
gsl_vector_get	function
(	O
x	double
,	O
j	long
)	O
;	O
gsl_vector_view	struct
v	pointer
=	O
gsl_matrix_column	function
(	O
J	pointer
,	O
j	long
)	O
;	O
h	double
=	O
eps	double
*	O
fabs	function
(	O
xj	double
)	O
;	O
if	O
(	O
h	double
==	O
0.0	int
)	O
h	double
=	O
eps	double
;	O
gsl_vector_set	function
(	O
(	O
gsl_vector	struct
*	O
)	O
x	double
,	O
j	long
,	O
xj	double
+	O
h	double
)	O
;	O
status	int
+=	O
gsl_multifit_eval_wf	function
(	O
fdf	pointer
,	O
x	double
,	O
wts	pointer
,	O
&	O
v	pointer
.	O
vector	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
gsl_vector_set	function
(	O
(	O
gsl_vector	struct
*	O
)	O
x	double
,	O
j	long
,	O
xj	double
)	O
;	O
h	double
=	O
1.0	int
/	O
h	double
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
fdf	pointer
->	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
fnext	double
=	O
gsl_vector_get	function
(	O
&	O
v	pointer
.	O
vector	struct
,	O
i	long
)	O
;	O
double	O
fi	double
=	O
gsl_vector_get	function
(	O
f	pointer
,	O
i	long
)	O
;	O
gsl_matrix_set	function
(	O
J	pointer
,	O
i	long
,	O
j	long
,	O
(	O
fnext	double
-	O
fi	double
)	O
*	O
h	double
)	O
;	O
}	O
}	O
return	O
status	int
;	O
}	O
int	O
gsl_multifit_fdfsolver_dif_df	function
(	O
const	O
gsl_vector	struct
*	O
x	double
,	O
const	O
gsl_vector	struct
*	O
wts	pointer
,	O
gsl_multifit_function_fdf	struct
*	O
fdf	pointer
,	O
const	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_matrix	struct
*	O
J	pointer
)	O
{	O
return	O
fdjac	function
(	O
x	double
,	O
wts	pointer
,	O
fdf	pointer
,	O
f	pointer
,	O
J	pointer
)	O
;	O
}	O
int	O
gsl_multifit_fdfsolver_dif_fdf	function
(	O
const	O
gsl_vector	struct
*	O
x	double
,	O
gsl_multifit_function_fdf	struct
*	O
fdf	pointer
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_matrix	struct
*	O
J	pointer
)	O
{	O
int	O
status	int
=	O
0	int
;	O
status	int
=	O
gsl_multifit_eval_wf	function
(	O
fdf	pointer
,	O
x	double
,	O
NULL	O
,	O
f	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
fdjac	function
(	O
x	double
,	O
NULL	O
,	O
fdf	pointer
,	O
f	pointer
,	O
J	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
return	O
status	int
;	O
}	O
int	O
gsl_multifit_wlinear	function
(	O
const	O
gsl_matrix	struct
*	O
X	pointer
,	O
const	O
gsl_vector	struct
*	O
w	pointer
,	O
const	O
gsl_vector	struct
*	O
y	double
,	O
gsl_vector	struct
*	O
c	int
,	O
gsl_matrix	struct
*	O
cov	pointer
,	O
double	O
*	O
chisq	pointer
,	O
gsl_multifit_linear_workspace	struct
*	O
work	pointer
)	O
{	O
size_t	long
rank	long
;	O
int	O
status	int
=	O
gsl_multifit_wlinear_tsvd	function
(	O
X	pointer
,	O
w	pointer
,	O
y	double
,	O
GSL_DBL_EPSILON	int
,	O
c	int
,	O
cov	pointer
,	O
chisq	pointer
,	O
&	O
rank	double
,	O
work	pointer
)	O
;	O
return	O
status	int
;	O
}	O
int	O
gsl_multifit_wlinear_tsvd	function
(	O
const	O
gsl_matrix	struct
*	O
X	pointer
,	O
const	O
gsl_vector	struct
*	O
w	pointer
,	O
const	O
gsl_vector	struct
*	O
y	double
,	O
const	O
double	O
tol	double
,	O
gsl_vector	struct
*	O
c	int
,	O
gsl_matrix	struct
*	O
cov	pointer
,	O
double	O
*	O
chisq	pointer
,	O
size_t	long
*	O
rank	pointer
,	O
gsl_multifit_linear_workspace	struct
*	O
work	pointer
)	O
{	O
const	O
size_t	long
n	int
=	O
X	pointer
->	O
size1	long
;	O
const	O
size_t	long
p	int
=	O
X	pointer
->	O
size2	long
;	O
if	O
(	O
y	double
->	O
size	long
!=	O
n	int
)	O
{	O
GSL_ERROR	O
(	O
"number of observations in y does not match matrix"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
w	pointer
->	O
size	long
!=	O
n	int
)	O
{	O
GSL_ERROR	O
(	O
"number of weights in w does not match matrix"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
p	pointer
!=	O
c	pointer
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"number of parameters c does not match matrix"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
tol	double
<=	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"tolerance must be positive"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
else	O
{	O
int	O
status	int
;	O
double	O
rnorm	double
,	O
snorm	double
;	O
gsl_matrix_view	struct
A	pointer
=	O
gsl_matrix_submatrix	function
(	O
work	pointer
->	O
A	pointer
,	O
0	int
,	O
0	int
,	O
n	long
,	O
p	pointer
)	O
;	O
gsl_vector_view	struct
b	pointer
=	O
gsl_vector_subvector	function
(	O
work	pointer
->	O
t	double
,	O
0	int
,	O
n	long
)	O
;	O
status	int
=	O
gsl_multifit_linear_applyW	function
(	O
X	pointer
,	O
w	pointer
,	O
y	double
,	O
&	O
A	pointer
.	O
matrix	struct
,	O
&	O
b	double
.	O
vector	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
gsl_multifit_linear_bsvd	function
(	O
&	O
A	pointer
.	O
matrix	struct
,	O
work	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
multifit_linear_solve	function
(	O
X	pointer
,	O
&	O
b	pointer
.	O
vector	struct
,	O
tol	double
,	O
0.0	int
,	O
rank	double
,	O
c	double
,	O
&	O
rnorm	pointer
,	O
&	O
snorm	struct
,	O
work	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
*	O
chisq	pointer
=	O
rnorm	struct
*	O
rnorm	pointer
;	O
{	O
const	O
size_t	long
p	int
=	O
X	pointer
->	O
size2	long
;	O
size_t	long
i	long
,	O
j	long
;	O
gsl_matrix_view	struct
QSI	struct
=	O
gsl_matrix_submatrix	function
(	O
work	pointer
->	O
QSI	pointer
,	O
0	int
,	O
0	int
,	O
p	pointer
,	O
p	pointer
)	O
;	O
gsl_vector_view	struct
D	pointer
=	O
gsl_vector_subvector	function
(	O
work	pointer
->	O
D	pointer
,	O
0	int
,	O
p	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
p	int
;	O
i	long
++	O
)	O
{	O
gsl_vector_view	struct
row_i	pointer
=	O
gsl_matrix_row	function
(	O
&	O
QSI	struct
.	O
matrix	pointer
,	O
i	long
)	O
;	O
double	O
d_i	double
=	O
gsl_vector_get	function
(	O
&	O
D	struct
.	O
vector	struct
,	O
i	long
)	O
;	O
for	O
(	O
j	long
=	O
i	long
;	O
j	long
<	O
p	int
;	O
j	long
++	O
)	O
{	O
gsl_vector_view	struct
row_j	pointer
=	O
gsl_matrix_row	function
(	O
&	O
QSI	struct
.	O
matrix	struct
,	O
j	long
)	O
;	O
double	O
d_j	double
=	O
gsl_vector_get	function
(	O
&	O
D	struct
.	O
vector	struct
,	O
j	long
)	O
;	O
double	O
s	pointer
;	O
gsl_blas_ddot	function
(	O
&	O
row_i	struct
.	O
vector	struct
,	O
&	O
row_j	struct
.	O
vector	struct
,	O
&	O
s	pointer
)	O
;	O
gsl_matrix_set	function
(	O
cov	pointer
,	O
i	long
,	O
j	long
,	O
s	long
/	O
(	O
d_i	struct
*	O
d_j	pointer
)	O
)	O
;	O
gsl_matrix_set	function
(	O
cov	pointer
,	O
j	long
,	O
i	long
,	O
s	pointer
/	O
(	O
d_i	struct
*	O
d_j	pointer
)	O
)	O
;	O
}	O
}	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_multifit_wlinear_svd	function
(	O
const	O
gsl_matrix	struct
*	O
X	pointer
,	O
const	O
gsl_vector	struct
*	O
w	pointer
,	O
const	O
gsl_vector	struct
*	O
y	double
,	O
double	O
tol	double
,	O
size_t	long
*	O
rank	pointer
,	O
gsl_vector	struct
*	O
c	int
,	O
gsl_matrix	struct
*	O
cov	pointer
,	O
double	O
*	O
chisq	pointer
,	O
gsl_multifit_linear_workspace	struct
*	O
work	pointer
)	O
{	O
int	O
status	int
=	O
gsl_multifit_wlinear_tsvd	function
(	O
X	pointer
,	O
w	pointer
,	O
y	double
,	O
tol	double
,	O
c	double
,	O
cov	pointer
,	O
chisq	pointer
,	O
rank	double
,	O
work	pointer
)	O
;	O
return	O
status	int
;	O
}	O
int	O
gsl_multifit_wlinear_usvd	function
(	O
const	O
gsl_matrix	struct
*	O
X	pointer
,	O
const	O
gsl_vector	struct
*	O
w	pointer
,	O
const	O
gsl_vector	struct
*	O
y	double
,	O
double	O
tol	double
,	O
size_t	long
*	O
rank	pointer
,	O
gsl_vector	struct
*	O
c	int
,	O
gsl_matrix	struct
*	O
cov	pointer
,	O
double	O
*	O
chisq	pointer
,	O
gsl_multifit_linear_workspace	struct
*	O
work	pointer
)	O
{	O
int	O
status	int
=	O
gsl_multifit_wlinear_tsvd	function
(	O
X	pointer
,	O
w	pointer
,	O
y	double
,	O
tol	double
,	O
c	double
,	O
cov	pointer
,	O
chisq	pointer
,	O
rank	double
,	O
work	pointer
)	O
;	O
return	O
status	int
;	O
}	O
typedef	O
struct	O
{	O
gsl_matrix	struct
*	O
JTJ	pointer
;	O
gsl_matrix	struct
*	O
work_JTJ	pointer
;	O
gsl_vector	struct
*	O
rhs	pointer
;	O
gsl_permutation	struct
*	O
perm	pointer
;	O
gsl_vector	struct
*	O
work3p	pointer
;	O
double	O
mu	double
;	O
}	O
mcholesky_state_t	struct
;	O
static	O
void	O
*	O
mcholesky_alloc	function
(	O
const	O
size_t	long
n	int
,	O
const	O
size_t	long
p	int
)	O
;	O
static	O
int	O
mcholesky_init	function
(	O
const	O
void	O
*	O
vtrust_state	pointer
,	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
int	O
mcholesky_presolve	function
(	O
const	O
double	O
mu	double
,	O
const	O
void	O
*	O
vtrust_state	pointer
,	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
int	O
mcholesky_solve	function
(	O
const	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
const	O
void	O
*	O
vtrust_state	pointer
,	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
int	O
mcholesky_solve_rhs	function
(	O
const	O
gsl_vector	struct
*	O
b	double
,	O
gsl_vector	struct
*	O
x	double
,	O
mcholesky_state_t	struct
*	O
state	pointer
)	O
;	O
static	O
int	O
mcholesky_regularize	function
(	O
const	O
double	O
mu	double
,	O
const	O
gsl_vector	struct
*	O
diag	pointer
,	O
gsl_matrix	struct
*	O
A	pointer
,	O
mcholesky_state_t	struct
*	O
state	pointer
)	O
;	O
static	O
void	O
*	O
mcholesky_alloc	function
(	O
const	O
size_t	long
n	int
,	O
const	O
size_t	long
p	int
)	O
{	O
mcholesky_state_t	struct
*	O
state	pointer
;	O
(	O
void	O
)	O
n	int
;	O
state	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
mcholesky_state_t	struct
)	O
)	O
;	O
if	O
(	O
state	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate mcholesky state"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
JTJ	pointer
=	O
gsl_matrix_alloc	function
(	O
p	int
,	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
JTJ	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for JTJ"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
work_JTJ	pointer
=	O
gsl_matrix_alloc	function
(	O
p	int
,	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
work_JTJ	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for JTJ workspace"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
rhs	pointer
=	O
gsl_vector_alloc	function
(	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
rhs	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for rhs"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
perm	pointer
=	O
gsl_permutation_alloc	function
(	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
perm	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for perm"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
work3p	pointer
=	O
gsl_vector_alloc	function
(	O
3	int
*	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
work3p	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for work3p"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
mu	double
=	O
-	O
1.0	int
;	O
return	O
state	pointer
;	O
}	O
static	O
void	O
mcholesky_free	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
mcholesky_state_t	struct
*	O
state	pointer
=	O
(	O
mcholesky_state_t	struct
*	O
)	O
vstate	pointer
;	O
if	O
(	O
state	pointer
->	O
JTJ	pointer
)	O
gsl_matrix_free	function
(	O
state	pointer
->	O
JTJ	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
work_JTJ	pointer
)	O
gsl_matrix_free	function
(	O
state	pointer
->	O
work_JTJ	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
rhs	pointer
)	O
gsl_vector_free	function
(	O
state	pointer
->	O
rhs	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
perm	pointer
)	O
gsl_permutation_free	function
(	O
state	pointer
->	O
perm	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
work3p	pointer
)	O
gsl_vector_free	function
(	O
state	pointer
->	O
work3p	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
}	O
static	O
int	O
mcholesky_init	function
(	O
const	O
void	O
*	O
vtrust_state	pointer
,	O
void	O
*	O
vstate	pointer
)	O
{	O
const	O
gsl_multifit_nlinear_trust_state	struct
*	O
trust_state	pointer
=	O
(	O
const	O
gsl_multifit_nlinear_trust_state	struct
*	O
)	O
vtrust_state	pointer
;	O
mcholesky_state_t	struct
*	O
state	pointer
=	O
(	O
mcholesky_state_t	struct
*	O
)	O
vstate	pointer
;	O
gsl_blas_dsyrk	function
(	O
CblasLower	int
,	O
CblasTrans	int
,	O
1.0	int
,	O
trust_state	pointer
->	O
J	pointer
,	O
0.0	int
,	O
state	pointer
->	O
JTJ	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
mcholesky_presolve	function
(	O
const	O
double	O
mu	double
,	O
const	O
void	O
*	O
vtrust_state	pointer
,	O
void	O
*	O
vstate	pointer
)	O
{	O
const	O
gsl_multifit_nlinear_trust_state	struct
*	O
trust_state	pointer
=	O
(	O
const	O
gsl_multifit_nlinear_trust_state	struct
*	O
)	O
vtrust_state	pointer
;	O
mcholesky_state_t	struct
*	O
state	pointer
=	O
(	O
mcholesky_state_t	struct
*	O
)	O
vstate	pointer
;	O
gsl_matrix	struct
*	O
JTJ	pointer
=	O
state	pointer
->	O
work_JTJ	pointer
;	O
const	O
gsl_vector	struct
*	O
diag	pointer
=	O
trust_state	pointer
->	O
diag	pointer
;	O
int	O
status	int
;	O
gsl_matrix_tricpy	function
(	O
CblasLower	int
,	O
CblasNonUnit	int
,	O
JTJ	pointer
,	O
state	pointer
->	O
JTJ	pointer
)	O
;	O
status	int
=	O
mcholesky_regularize	function
(	O
mu	double
,	O
diag	pointer
,	O
JTJ	pointer
,	O
state	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
gsl_linalg_mcholesky_decomp	function
(	O
JTJ	pointer
,	O
state	pointer
->	O
perm	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
state	pointer
->	O
mu	double
=	O
mu	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
mcholesky_solve	function
(	O
const	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
const	O
void	O
*	O
vtrust_state	pointer
,	O
void	O
*	O
vstate	pointer
)	O
{	O
const	O
gsl_multifit_nlinear_trust_state	struct
*	O
trust_state	pointer
=	O
(	O
const	O
gsl_multifit_nlinear_trust_state	struct
*	O
)	O
vtrust_state	pointer
;	O
mcholesky_state_t	struct
*	O
state	pointer
=	O
(	O
mcholesky_state_t	struct
*	O
)	O
vstate	pointer
;	O
int	O
status	int
;	O
gsl_blas_dgemv	function
(	O
CblasTrans	int
,	O
-	O
1.0	int
,	O
trust_state	pointer
->	O
J	pointer
,	O
f	pointer
,	O
0.0	int
,	O
state	pointer
->	O
rhs	pointer
)	O
;	O
status	int
=	O
mcholesky_solve_rhs	function
(	O
state	pointer
->	O
rhs	pointer
,	O
x	double
,	O
state	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
mcholesky_rcond	function
(	O
double	O
*	O
rcond	pointer
,	O
void	O
*	O
vstate	pointer
)	O
{	O
int	O
status	int
;	O
mcholesky_state_t	struct
*	O
state	pointer
=	O
(	O
mcholesky_state_t	struct
*	O
)	O
vstate	pointer
;	O
double	O
rcond_JTJ	double
;	O
if	O
(	O
state	pointer
->	O
mu	double
!=	O
0	int
)	O
{	O
gsl_matrix_tricpy	function
(	O
CblasLower	int
,	O
CblasNonUnit	int
,	O
state	pointer
->	O
work_JTJ	pointer
,	O
state	pointer
->	O
JTJ	pointer
)	O
;	O
status	int
=	O
gsl_linalg_mcholesky_decomp	function
(	O
state	pointer
->	O
work_JTJ	pointer
,	O
state	pointer
->	O
perm	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
}	O
status	int
=	O
gsl_linalg_mcholesky_rcond	function
(	O
state	pointer
->	O
work_JTJ	pointer
,	O
state	pointer
->	O
perm	pointer
,	O
&	O
rcond_JTJ	double
,	O
state	pointer
->	O
work3p	pointer
)	O
;	O
if	O
(	O
status	int
==	O
GSL_SUCCESS	int
)	O
*	O
rcond	pointer
=	O
sqrt	function
(	O
rcond_JTJ	double
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
mcholesky_solve_rhs	function
(	O
const	O
gsl_vector	struct
*	O
b	double
,	O
gsl_vector	struct
*	O
x	double
,	O
mcholesky_state_t	struct
*	O
state	pointer
)	O
{	O
int	O
status	int
;	O
gsl_matrix	struct
*	O
JTJ	pointer
=	O
state	pointer
->	O
work_JTJ	pointer
;	O
status	int
=	O
gsl_linalg_mcholesky_solve	function
(	O
JTJ	pointer
,	O
state	pointer
->	O
perm	pointer
,	O
b	double
,	O
x	double
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
mcholesky_regularize	function
(	O
const	O
double	O
mu	double
,	O
const	O
gsl_vector	struct
*	O
diag	pointer
,	O
gsl_matrix	struct
*	O
A	pointer
,	O
mcholesky_state_t	struct
*	O
state	pointer
)	O
{	O
(	O
void	O
)	O
state	pointer
;	O
if	O
(	O
mu	double
!=	O
0.0	int
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
diag	pointer
->	O
size	long
;	O
++	O
i	long
)	O
{	O
double	O
di	double
=	O
gsl_vector_get	function
(	O
diag	pointer
,	O
i	long
)	O
;	O
double	O
*	O
Aii	pointer
=	O
gsl_matrix_ptr	function
(	O
A	pointer
,	O
i	long
,	O
i	long
)	O
;	O
*	O
Aii	pointer
+=	O
mu	double
*	O
di	double
*	O
di	double
;	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_multifit_nlinear_solver	struct
mcholesky_type	struct
=	O
{	O
"mcholesky"	pointer
,	O
mcholesky_alloc	int
,	O
mcholesky_init	function
,	O
mcholesky_presolve	function
,	O
mcholesky_solve	function
,	O
mcholesky_rcond	function
,	O
mcholesky_free	function
}	O
;	O
const	O
gsl_multifit_nlinear_solver	struct
*	O
gsl_multifit_nlinear_solver_mcholesky	pointer
=	O
&	O
mcholesky_type	struct
;	O
static	O
int	O
init_diag_levenberg	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
;	O
static	O
int	O
update_diag_levenberg	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
;	O
static	O
int	O
init_diag_marquardt	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
;	O
static	O
int	O
update_diag_marquardt	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
;	O
static	O
int	O
init_diag_more	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
;	O
static	O
int	O
update_diag_more	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
;	O
static	O
int	O
init_diag_levenberg	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
{	O
(	O
void	O
)	O
J	pointer
;	O
gsl_vector_set_all	function
(	O
diag	pointer
,	O
1.0	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
update_diag_levenberg	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
{	O
(	O
void	O
)	O
J	pointer
;	O
(	O
void	O
)	O
diag	pointer
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
init_diag_marquardt	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
{	O
return	O
update_diag_marquardt	function
(	O
J	pointer
,	O
diag	pointer
)	O
;	O
}	O
static	O
int	O
update_diag_marquardt	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
{	O
const	O
size_t	long
p	int
=	O
J	pointer
->	O
size2	long
;	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
p	int
;	O
j	long
++	O
)	O
{	O
gsl_vector_const_view	struct
v	pointer
=	O
gsl_matrix_const_column	function
(	O
J	pointer
,	O
j	long
)	O
;	O
double	O
norm	double
=	O
gsl_blas_dnrm2	function
(	O
&	O
v	pointer
.	O
vector	struct
)	O
;	O
if	O
(	O
norm	double
==	O
0.0	int
)	O
norm	double
=	O
1.0	int
;	O
gsl_vector_set	function
(	O
diag	pointer
,	O
j	long
,	O
norm	pointer
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
init_diag_more	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
{	O
int	O
status	int
;	O
gsl_vector_set_zero	function
(	O
diag	pointer
)	O
;	O
status	int
=	O
update_diag_more	function
(	O
J	pointer
,	O
diag	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
update_diag_more	function
(	O
const	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
diag	pointer
)	O
{	O
const	O
size_t	long
p	int
=	O
J	pointer
->	O
size2	long
;	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
p	int
;	O
j	long
++	O
)	O
{	O
gsl_vector_const_view	struct
v	pointer
=	O
gsl_matrix_const_column	function
(	O
J	pointer
,	O
j	long
)	O
;	O
double	O
norm	double
=	O
gsl_blas_dnrm2	function
(	O
&	O
v	pointer
.	O
vector	struct
)	O
;	O
double	O
*	O
diagj	pointer
=	O
gsl_vector_ptr	function
(	O
diag	pointer
,	O
j	long
)	O
;	O
if	O
(	O
norm	pointer
==	O
0.0	int
)	O
norm	double
=	O
1.0	int
;	O
*	O
diagj	pointer
=	O
GSL_MAX	O
(	O
*	O
diagj	pointer
,	O
norm	pointer
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_multifit_nlinear_scale	struct
levenberg_type	struct
=	O
{	O
"levenberg"	pointer
,	O
init_diag_levenberg	function
,	O
update_diag_levenberg	function
}	O
;	O
static	O
const	O
gsl_multifit_nlinear_scale	struct
marquardt_type	struct
=	O
{	O
"marquardt"	pointer
,	O
init_diag_marquardt	function
,	O
update_diag_marquardt	function
}	O
;	O
static	O
const	O
gsl_multifit_nlinear_scale	struct
more_type	struct
=	O
{	O
"more"	pointer
,	O
init_diag_more	function
,	O
update_diag_more	function
}	O
;	O
const	O
gsl_multifit_nlinear_scale	struct
*	O
gsl_multifit_nlinear_scale_levenberg	pointer
=	O
&	O
levenberg_type	struct
;	O
const	O
gsl_multifit_nlinear_scale	struct
*	O
gsl_multifit_nlinear_scale_marquardt	pointer
=	O
&	O
marquardt_type	struct
;	O
const	O
gsl_multifit_nlinear_scale	struct
*	O
gsl_multifit_nlinear_scale_more	pointer
=	O
&	O
more_type	struct
;	O
typedef	O
struct	O
{	O
int	O
iter	int
;	O
double	O
step	double
;	O
double	O
max_step	double
;	O
double	O
tol	double
;	O
gsl_vector	struct
*	O
x1	double
;	O
gsl_vector	struct
*	O
dx1	pointer
;	O
gsl_vector	struct
*	O
x2	double
;	O
double	O
pnorm	double
;	O
gsl_vector	struct
*	O
p	int
;	O
double	O
g0norm	double
;	O
gsl_vector	struct
*	O
g0	pointer
;	O
}	O
conjugate_fr_state_t	struct
;	O
static	O
int	O
conjugate_fr_alloc	function
(	O
void	O
*	O
vstate	pointer
,	O
size_t	long
n	int
)	O
{	O
conjugate_fr_state_t	struct
*	O
state	pointer
=	O
(	O
conjugate_fr_state_t	struct
*	O
)	O
vstate	pointer
;	O
state	pointer
->	O
x1	double
=	O
gsl_vector_calloc	function
(	O
n	int
)	O
;	O
if	O
(	O
state	pointer
->	O
x1	double
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"failed to allocate space for x1"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
dx1	pointer
=	O
gsl_vector_calloc	function
(	O
n	int
)	O
;	O
if	O
(	O
state	pointer
->	O
dx1	pointer
==	O
0	int
)	O
{	O
gsl_vector_free	function
(	O
state	pointer
->	O
x1	double
)	O
;	O
GSL_ERROR	O
(	O
"failed to allocate space for dx1"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
x2	double
=	O
gsl_vector_calloc	function
(	O
n	int
)	O
;	O
if	O
(	O
state	pointer
->	O
x2	double
==	O
0	int
)	O
{	O
gsl_vector_free	function
(	O
state	pointer
->	O
dx1	pointer
)	O
;	O
gsl_vector_free	function
(	O
state	pointer
->	O
x1	double
)	O
;	O
GSL_ERROR	O
(	O
"failed to allocate space for x2"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
p	int
=	O
gsl_vector_calloc	function
(	O
n	int
)	O
;	O
if	O
(	O
state	pointer
->	O
p	int
==	O
0	int
)	O
{	O
gsl_vector_free	function
(	O
state	pointer
->	O
x2	double
)	O
;	O
gsl_vector_free	function
(	O
state	pointer
->	O
dx1	pointer
)	O
;	O
gsl_vector_free	function
(	O
state	pointer
->	O
x1	double
)	O
;	O
GSL_ERROR	O
(	O
"failed to allocate space for p"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
g0	pointer
=	O
gsl_vector_calloc	function
(	O
n	int
)	O
;	O
if	O
(	O
state	pointer
->	O
g0	pointer
==	O
0	int
)	O
{	O
gsl_vector_free	function
(	O
state	pointer
->	O
p	int
)	O
;	O
gsl_vector_free	function
(	O
state	pointer
->	O
x2	double
)	O
;	O
gsl_vector_free	function
(	O
state	pointer
->	O
dx1	pointer
)	O
;	O
gsl_vector_free	function
(	O
state	pointer
->	O
x1	double
)	O
;	O
GSL_ERROR	O
(	O
"failed to allocate space for g0"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
conjugate_fr_set	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_multimin_function_fdf	struct
*	O
fdf	pointer
,	O
const	O
gsl_vector	struct
*	O
x	double
,	O
double	O
*	O
f	pointer
,	O
gsl_vector	struct
*	O
gradient	pointer
,	O
double	O
step_size	pointer
,	O
double	O
tol	double
)	O
{	O
conjugate_fr_state_t	struct
*	O
state	pointer
=	O
(	O
conjugate_fr_state_t	struct
*	O
)	O
vstate	pointer
;	O
state	pointer
->	O
iter	int
=	O
0	int
;	O
state	pointer
->	O
step	double
=	O
step_size	pointer
;	O
state	pointer
->	O
max_step	double
=	O
step_size	pointer
;	O
state	pointer
->	O
tol	double
=	O
tol	double
;	O
GSL_MULTIMIN_FN_EVAL_F_DF	O
(	O
fdf	pointer
,	O
x	double
,	O
f	pointer
,	O
gradient	pointer
)	O
;	O
gsl_vector_memcpy	function
(	O
state	pointer
->	O
p	int
,	O
gradient	pointer
)	O
;	O
gsl_vector_memcpy	function
(	O
state	pointer
->	O
g0	pointer
,	O
gradient	pointer
)	O
;	O
{	O
double	O
gnorm	pointer
=	O
gsl_blas_dnrm2	function
(	O
gradient	pointer
)	O
;	O
state	pointer
->	O
pnorm	double
=	O
gnorm	pointer
;	O
state	pointer
->	O
g0norm	double
=	O
gnorm	pointer
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
void	O
conjugate_fr_free	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
conjugate_fr_state_t	struct
*	O
state	pointer
=	O
(	O
conjugate_fr_state_t	struct
*	O
)	O
vstate	pointer
;	O
gsl_vector_free	function
(	O
state	pointer
->	O
g0	pointer
)	O
;	O
gsl_vector_free	function
(	O
state	pointer
->	O
p	int
)	O
;	O
gsl_vector_free	function
(	O
state	pointer
->	O
x2	double
)	O
;	O
gsl_vector_free	function
(	O
state	pointer
->	O
dx1	pointer
)	O
;	O
gsl_vector_free	function
(	O
state	pointer
->	O
x1	double
)	O
;	O
}	O
static	O
int	O
conjugate_fr_restart	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
conjugate_fr_state_t	struct
*	O
state	pointer
=	O
(	O
conjugate_fr_state_t	struct
*	O
)	O
vstate	pointer
;	O
state	pointer
->	O
iter	int
=	O
0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
conjugate_fr_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_multimin_function_fdf	struct
*	O
fdf	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
double	O
*	O
f	pointer
,	O
gsl_vector	struct
*	O
gradient	pointer
,	O
gsl_vector	struct
*	O
dx	pointer
)	O
{	O
conjugate_fr_state_t	struct
*	O
state	pointer
=	O
(	O
conjugate_fr_state_t	struct
*	O
)	O
vstate	pointer
;	O
gsl_vector	struct
*	O
x1	double
=	O
state	pointer
->	O
x1	double
;	O
gsl_vector	struct
*	O
dx1	pointer
=	O
state	pointer
->	O
dx1	pointer
;	O
gsl_vector	struct
*	O
x2	double
=	O
state	pointer
->	O
x2	double
;	O
gsl_vector	struct
*	O
p	pointer
=	O
state	pointer
->	O
p	int
;	O
gsl_vector	struct
*	O
g0	pointer
=	O
state	pointer
->	O
g0	pointer
;	O
double	O
pnorm	double
=	O
state	pointer
->	O
pnorm	double
;	O
double	O
g0norm	double
=	O
state	pointer
->	O
g0norm	double
;	O
double	O
fa	double
=	O
*	O
f	pointer
,	O
fb	double
,	O
fc	double
;	O
double	O
dir	double
;	O
double	O
stepa	double
=	O
0.0	int
,	O
stepb	double
,	O
stepc	double
=	O
state	pointer
->	O
step	double
,	O
tol	double
=	O
state	pointer
->	O
tol	double
;	O
double	O
g1norm	double
;	O
double	O
pg	double
;	O
if	O
(	O
pnorm	double
==	O
0.0	int
||	O
g0norm	double
==	O
0.0	int
)	O
{	O
gsl_vector_set_zero	function
(	O
dx	pointer
)	O
;	O
return	O
GSL_ENOPROG	int
;	O
}	O
gsl_blas_ddot	function
(	O
p	int
,	O
gradient	pointer
,	O
&	O
pg	double
)	O
;	O
dir	double
=	O
(	O
pg	double
>=	O
0.0	int
)	O
?	O
+	O
1.0	int
:	O
-	O
1.0	int
;	O
take_step	function
(	O
x	double
,	O
p	int
,	O
stepc	double
,	O
dir	double
/	O
pnorm	double
,	O
x1	double
,	O
dx	pointer
)	O
;	O
fc	double
=	O
GSL_MULTIMIN_FN_EVAL_F	O
(	O
fdf	pointer
,	O
x1	double
)	O
;	O
if	O
(	O
fc	double
<	O
fa	double
)	O
{	O
state	pointer
->	O
step	double
=	O
stepc	double
*	O
2.0	int
;	O
*	O
f	pointer
=	O
fc	double
;	O
gsl_vector_memcpy	function
(	O
x	double
,	O
x1	double
)	O
;	O
GSL_MULTIMIN_FN_EVAL_DF	O
(	O
fdf	pointer
,	O
x1	double
,	O
gradient	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
intermediate_point	function
(	O
fdf	pointer
,	O
x	double
,	O
p	int
,	O
dir	double
/	O
pnorm	double
,	O
pg	double
,	O
stepa	double
,	O
stepc	double
,	O
fa	double
,	O
fc	double
,	O
x1	double
,	O
dx1	pointer
,	O
gradient	pointer
,	O
&	O
stepb	double
,	O
&	O
fb	double
)	O
;	O
if	O
(	O
stepb	double
==	O
0.0	int
)	O
{	O
return	O
GSL_ENOPROG	int
;	O
}	O
minimize	function
(	O
fdf	pointer
,	O
x	double
,	O
p	int
,	O
dir	double
/	O
pnorm	double
,	O
stepa	double
,	O
stepb	double
,	O
stepc	double
,	O
fa	double
,	O
fb	double
,	O
fc	double
,	O
tol	double
,	O
x1	double
,	O
dx1	pointer
,	O
x2	double
,	O
dx	pointer
,	O
gradient	pointer
,	O
&	O
(	O
state	pointer
->	O
step	double
)	O
,	O
f	pointer
,	O
&	O
g1norm	double
)	O
;	O
gsl_vector_memcpy	function
(	O
x	double
,	O
x2	double
)	O
;	O
state	pointer
->	O
iter	int
=	O
(	O
state	pointer
->	O
iter	int
+	O
1	int
)	O
%	O
x	double
->	O
size	long
;	O
if	O
(	O
state	pointer
->	O
iter	int
==	O
0	int
)	O
{	O
gsl_vector_memcpy	function
(	O
p	int
,	O
gradient	pointer
)	O
;	O
state	pointer
->	O
pnorm	double
=	O
g1norm	double
;	O
}	O
else	O
{	O
double	O
beta	double
=	O
-	O
pow	function
(	O
g1norm	double
/	O
g0norm	double
,	O
2.0	int
)	O
;	O
gsl_blas_dscal	function
(	O
-	O
beta	double
,	O
p	int
)	O
;	O
gsl_blas_daxpy	function
(	O
1.0	int
,	O
gradient	pointer
,	O
p	int
)	O
;	O
state	pointer
->	O
pnorm	double
=	O
gsl_blas_dnrm2	function
(	O
p	int
)	O
;	O
}	O
state	pointer
->	O
g0norm	double
=	O
g1norm	double
;	O
gsl_vector_memcpy	function
(	O
g0	pointer
,	O
gradient	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
const	O
gsl_multimin_fdfminimizer_type	struct
conjugate_fr_type	struct
=	O
{	O
"conjugate_fr"	pointer
,	O
sizeof	O
(	O
conjugate_fr_state_t	struct
)	O
,	O
&	O
conjugate_fr_alloc	function
,	O
&	O
conjugate_fr_set	function
,	O
&	O
conjugate_fr_iterate	function
,	O
&	O
conjugate_fr_restart	function
,	O
&	O
conjugate_fr_free	function
}	O
;	O
const	O
gsl_multimin_fdfminimizer_type	struct
*	O
gsl_multimin_fdfminimizer_conjugate_fr	pointer
=	O
&	O
conjugate_fr_type	struct
;	O
typedef	O
struct	O
{	O
gsl_matrix	struct
*	O
lu	pointer
;	O
gsl_permutation	struct
*	O
permutation	pointer
;	O
}	O
newton_state_t	struct
;	O
static	O
int	O
newton_alloc	function
(	O
void	O
*	O
vstate	pointer
,	O
size_t	long
n	long
)	O
;	O
static	O
int	O
newton_set	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_multiroot_function_fdf	struct
*	O
fdf	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
dx	pointer
)	O
;	O
static	O
int	O
newton_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_multiroot_function_fdf	struct
*	O
fdf	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
dx	pointer
)	O
;	O
static	O
void	O
newton_free	function
(	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
int	O
newton_alloc	function
(	O
void	O
*	O
vstate	pointer
,	O
size_t	long
n	int
)	O
{	O
newton_state_t	struct
*	O
state	pointer
=	O
(	O
newton_state_t	struct
*	O
)	O
vstate	pointer
;	O
gsl_permutation	struct
*	O
p	int
;	O
gsl_matrix	struct
*	O
m	pointer
;	O
m	pointer
=	O
gsl_matrix_calloc	function
(	O
n	int
,	O
n	int
)	O
;	O
if	O
(	O
m	pointer
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"failed to allocate space for lu"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
lu	pointer
=	O
m	pointer
;	O
p	int
=	O
gsl_permutation_calloc	function
(	O
n	int
)	O
;	O
if	O
(	O
p	int
==	O
0	int
)	O
{	O
gsl_matrix_free	function
(	O
m	pointer
)	O
;	O
GSL_ERROR	O
(	O
"failed to allocate space for permutation"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
permutation	pointer
=	O
p	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
newton_set	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_multiroot_function_fdf	struct
*	O
FDF	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
dx	pointer
)	O
{	O
newton_state_t	struct
*	O
state	pointer
=	O
(	O
newton_state_t	struct
*	O
)	O
vstate	pointer
;	O
size_t	long
i	long
,	O
n	int
=	O
FDF	pointer
->	O
n	int
;	O
state	pointer
=	O
0	int
;	O
GSL_MULTIROOT_FN_EVAL_F_DF	O
(	O
FDF	pointer
,	O
x	double
,	O
f	pointer
,	O
J	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
gsl_vector_set	function
(	O
dx	pointer
,	O
i	long
,	O
0.0	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
newton_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_multiroot_function_fdf	struct
*	O
fdf	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_matrix	struct
*	O
J	pointer
,	O
gsl_vector	struct
*	O
dx	pointer
)	O
{	O
newton_state_t	struct
*	O
state	pointer
=	O
(	O
newton_state_t	struct
*	O
)	O
vstate	pointer
;	O
int	O
signum	pointer
;	O
size_t	long
i	long
;	O
size_t	long
n	int
=	O
fdf	pointer
->	O
n	int
;	O
gsl_matrix_memcpy	function
(	O
state	pointer
->	O
lu	pointer
,	O
J	pointer
)	O
;	O
gsl_linalg_LU_decomp	function
(	O
state	pointer
->	O
lu	pointer
,	O
state	pointer
->	O
permutation	pointer
,	O
&	O
signum	pointer
)	O
;	O
{	O
int	O
status	int
=	O
gsl_linalg_LU_solve	function
(	O
state	pointer
->	O
lu	pointer
,	O
state	pointer
->	O
permutation	pointer
,	O
f	pointer
,	O
dx	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
double	O
e	int
=	O
gsl_vector_get	function
(	O
dx	pointer
,	O
i	long
)	O
;	O
double	O
y	double
=	O
gsl_vector_get	function
(	O
x	double
,	O
i	long
)	O
;	O
gsl_vector_set	function
(	O
dx	pointer
,	O
i	long
,	O
-	O
e	int
)	O
;	O
gsl_vector_set	function
(	O
x	double
,	O
i	long
,	O
y	double
-	O
e	int
)	O
;	O
}	O
{	O
int	O
status	int
=	O
GSL_MULTIROOT_FN_EVAL_F_DF	O
(	O
fdf	pointer
,	O
x	double
,	O
f	pointer
,	O
J	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
GSL_SUCCESS	int
)	O
{	O
return	O
GSL_EBADFUNC	int
;	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
void	O
newton_free	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
newton_state_t	struct
*	O
state	pointer
=	O
(	O
newton_state_t	struct
*	O
)	O
vstate	pointer
;	O
gsl_matrix_free	function
(	O
state	pointer
->	O
lu	pointer
)	O
;	O
gsl_permutation_free	function
(	O
state	pointer
->	O
permutation	pointer
)	O
;	O
}	O
static	O
const	O
gsl_multiroot_fdfsolver_type	struct
newton_type	pointer
=	O
{	O
"newton"	pointer
,	O
sizeof	O
(	O
newton_state_t	struct
)	O
,	O
&	O
newton_alloc	function
,	O
&	O
newton_set	function
,	O
&	O
newton_iterate	function
,	O
&	O
newton_free	function
}	O
;	O
const	O
gsl_multiroot_fdfsolver_type	struct
*	O
gsl_multiroot_fdfsolver_newton	pointer
=	O
&	O
newton_type	struct
;	O
gsl_multiset	struct
*	O
gsl_multiset_alloc	function
(	O
const	O
size_t	long
n	int
,	O
const	O
size_t	long
k	int
)	O
{	O
gsl_multiset	struct
*	O
c	pointer
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"multiset parameter n must be positive integer"	pointer
,	O
GSL_EDOM	int
,	O
0	int
)	O
;	O
}	O
c	pointer
=	O
(	O
gsl_multiset	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_multiset	struct
)	O
)	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for multiset struct"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
k	long
>	O
0	int
)	O
{	O
c	pointer
->	O
data	pointer
=	O
(	O
size_t	long
*	O
)	O
malloc	function
(	O
k	long
*	O
sizeof	O
(	O
size_t	long
)	O
)	O
;	O
if	O
(	O
c	pointer
->	O
data	pointer
==	O
0	int
)	O
{	O
free	function
(	O
c	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for multiset data"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
c	pointer
->	O
data	pointer
=	O
0	int
;	O
}	O
c	pointer
->	O
n	long
=	O
n	long
;	O
c	pointer
->	O
k	long
=	O
k	long
;	O
return	O
c	int
;	O
}	O
gsl_multiset	struct
*	O
gsl_multiset_calloc	function
(	O
const	O
size_t	long
n	long
,	O
const	O
size_t	long
k	long
)	O
{	O
size_t	long
i	long
;	O
gsl_multiset	struct
*	O
c	pointer
=	O
gsl_multiset_alloc	function
(	O
n	long
,	O
k	long
)	O
;	O
if	O
(	O
c	long
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
k	long
;	O
i	long
++	O
)	O
{	O
c	pointer
->	O
data	pointer
[	O
i	long
]	O
=	O
0	int
;	O
}	O
return	O
c	long
;	O
}	O
void	O
gsl_multiset_init_first	function
(	O
gsl_multiset	struct
*	O
c	pointer
)	O
{	O
const	O
size_t	long
k	long
=	O
c	pointer
->	O
k	long
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
k	long
;	O
i	long
++	O
)	O
{	O
c	pointer
->	O
data	pointer
[	O
i	long
]	O
=	O
0	int
;	O
}	O
}	O
void	O
gsl_multiset_init_last	function
(	O
gsl_multiset	struct
*	O
c	pointer
)	O
{	O
const	O
size_t	long
k	long
=	O
c	pointer
->	O
k	long
;	O
size_t	long
i	long
;	O
size_t	long
n	long
=	O
c	pointer
->	O
n	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
k	long
;	O
i	long
++	O
)	O
{	O
c	pointer
->	O
data	pointer
[	O
i	long
]	O
=	O
n	long
-	O
1	int
;	O
}	O
}	O
void	O
gsl_multiset_free	function
(	O
gsl_multiset	struct
*	O
c	pointer
)	O
{	O
RETURN_IF_NULL	O
(	O
c	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
k	long
>	O
0	int
)	O
free	function
(	O
c	pointer
->	O
data	pointer
)	O
;	O
free	function
(	O
c	pointer
)	O
;	O
}	O
gsl_ntuple	struct
*	O
gsl_ntuple_create	function
(	O
char	O
*	O
filename	pointer
,	O
void	O
*	O
ntuple_data	pointer
,	O
size_t	long
size	long
)	O
{	O
gsl_ntuple	struct
*	O
ntuple	pointer
=	O
(	O
gsl_ntuple	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_ntuple	struct
)	O
)	O
;	O
if	O
(	O
ntuple	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for ntuple struct"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
ntuple	pointer
->	O
ntuple_data	pointer
=	O
ntuple_data	pointer
;	O
ntuple	pointer
->	O
size	long
=	O
size	long
;	O
ntuple	pointer
->	O
file	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"wb"	pointer
)	O
;	O
if	O
(	O
ntuple	pointer
->	O
file	pointer
==	O
0	int
)	O
{	O
free	function
(	O
ntuple	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"unable to create ntuple file"	pointer
,	O
GSL_EFAILED	int
,	O
0	int
)	O
;	O
}	O
return	O
ntuple	pointer
;	O
}	O
gsl_ntuple	struct
*	O
gsl_ntuple_open	function
(	O
char	O
*	O
filename	pointer
,	O
void	O
*	O
ntuple_data	pointer
,	O
size_t	long
size	long
)	O
{	O
gsl_ntuple	struct
*	O
ntuple	pointer
=	O
(	O
gsl_ntuple	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_ntuple	struct
)	O
)	O
;	O
if	O
(	O
ntuple	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for ntuple struct"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
ntuple	pointer
->	O
ntuple_data	pointer
=	O
ntuple_data	pointer
;	O
ntuple	pointer
->	O
size	long
=	O
size	long
;	O
ntuple	pointer
->	O
file	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"rb"	pointer
)	O
;	O
if	O
(	O
ntuple	pointer
->	O
file	pointer
==	O
0	int
)	O
{	O
free	function
(	O
ntuple	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"unable to open ntuple file for reading"	pointer
,	O
GSL_EFAILED	int
,	O
0	int
)	O
;	O
}	O
return	O
ntuple	pointer
;	O
}	O
int	O
gsl_ntuple_write	function
(	O
gsl_ntuple	struct
*	O
ntuple	pointer
)	O
{	O
size_t	long
nwrite	long
;	O
nwrite	long
=	O
fwrite	function
(	O
ntuple	pointer
->	O
ntuple_data	pointer
,	O
ntuple	pointer
->	O
size	long
,	O
1	int
,	O
ntuple	pointer
->	O
file	pointer
)	O
;	O
if	O
(	O
nwrite	int
!=	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"failed to write ntuple entry to file"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_ntuple_bookdata	function
(	O
gsl_ntuple	struct
*	O
ntuple	pointer
)	O
{	O
return	O
gsl_ntuple_write	function
(	O
ntuple	pointer
)	O
;	O
}	O
int	O
gsl_ntuple_read	function
(	O
gsl_ntuple	struct
*	O
ntuple	pointer
)	O
{	O
size_t	long
nread	long
;	O
nread	long
=	O
fread	function
(	O
ntuple	pointer
->	O
ntuple_data	pointer
,	O
ntuple	pointer
->	O
size	long
,	O
1	int
,	O
ntuple	pointer
->	O
file	pointer
)	O
;	O
if	O
(	O
nread	long
==	O
0	int
&&	O
feof	function
(	O
ntuple	pointer
->	O
file	pointer
)	O
)	O
{	O
return	O
GSL_EOF	int
;	O
}	O
if	O
(	O
nread	long
!=	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"failed to read ntuple entry from file"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_ntuple_project	function
(	O
gsl_histogram	struct
*	O
h	pointer
,	O
gsl_ntuple	struct
*	O
ntuple	pointer
,	O
gsl_ntuple_value_fn	struct
*	O
value_func	pointer
,	O
gsl_ntuple_select_fn	struct
*	O
select_func	pointer
)	O
{	O
size_t	long
nread	long
;	O
do	O
{	O
nread	int
=	O
fread	function
(	O
ntuple	pointer
->	O
ntuple_data	pointer
,	O
ntuple	pointer
->	O
size	long
,	O
1	int
,	O
ntuple	pointer
->	O
file	pointer
)	O
;	O
if	O
(	O
nread	pointer
==	O
0	int
&&	O
feof	function
(	O
ntuple	pointer
->	O
file	pointer
)	O
)	O
{	O
break	O
;	O
}	O
if	O
(	O
nread	long
!=	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"failed to read ntuple for projection"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
if	O
(	O
EVAL	function
(	O
select_func	pointer
,	O
ntuple	pointer
->	O
ntuple_data	pointer
)	O
)	O
{	O
gsl_histogram_increment	function
(	O
h	pointer
,	O
EVAL	function
(	O
value_func	pointer
,	O
ntuple	pointer
->	O
ntuple_data	pointer
)	O
)	O
;	O
}	O
}	O
while	O
(	O
1	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_ntuple_close	function
(	O
gsl_ntuple	struct
*	O
ntuple	pointer
)	O
{	O
int	O
status	int
=	O
fclose	function
(	O
ntuple	pointer
->	O
file	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
GSL_ERROR	O
(	O
"failed to close ntuple file"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
free	function
(	O
ntuple	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
typedef	O
struct	O
{	O
double	O
eps_abs	double
;	O
double	O
eps_rel	double
;	O
double	O
a_y	double
;	O
double	O
a_dydt	double
;	O
}	O
std_control_state_t	struct
;	O
static	O
void	O
*	O
std_control_alloc	function
(	O
void	O
)	O
{	O
std_control_state_t	struct
*	O
s	pointer
=	O
(	O
std_control_state_t	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
std_control_state_t	struct
)	O
)	O
;	O
if	O
(	O
s	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for std_control_state"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
s	pointer
;	O
}	O
static	O
int	O
std_control_init	function
(	O
void	O
*	O
vstate	pointer
,	O
double	O
eps_abs	double
,	O
double	O
eps_rel	double
,	O
double	O
a_y	double
,	O
double	O
a_dydt	double
)	O
{	O
std_control_state_t	struct
*	O
s	pointer
=	O
(	O
std_control_state_t	struct
*	O
)	O
vstate	pointer
;	O
if	O
(	O
eps_abs	double
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"eps_abs is negative"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
else	O
if	O
(	O
eps_rel	double
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"eps_rel is negative"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
else	O
if	O
(	O
a_y	double
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"a_y is negative"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
else	O
if	O
(	O
a_dydt	double
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"a_dydt is negative"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
s	pointer
->	O
eps_rel	double
=	O
eps_rel	double
;	O
s	pointer
->	O
eps_abs	double
=	O
eps_abs	double
;	O
s	pointer
->	O
a_y	double
=	O
a_y	double
;	O
s	pointer
->	O
a_dydt	double
=	O
a_dydt	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
std_control_hadjust	function
(	O
void	O
*	O
vstate	pointer
,	O
size_t	long
dim	long
,	O
unsigned	O
int	O
ord	int
,	O
const	O
double	O
y	double
[	O
]	O
,	O
const	O
double	O
yerr	array
[	O
]	O
,	O
const	O
double	O
yp	array
[	O
]	O
,	O
double	O
*	O
h	double
)	O
{	O
std_control_state_t	struct
*	O
state	pointer
=	O
(	O
std_control_state_t	struct
*	O
)	O
vstate	pointer
;	O
const	O
double	O
eps_abs	double
=	O
state	pointer
->	O
eps_abs	double
;	O
const	O
double	O
eps_rel	double
=	O
state	pointer
->	O
eps_rel	double
;	O
const	O
double	O
a_y	double
=	O
state	pointer
->	O
a_y	double
;	O
const	O
double	O
a_dydt	double
=	O
state	pointer
->	O
a_dydt	double
;	O
const	O
double	O
S	double
=	O
0.9	int
;	O
const	O
double	O
h_old	double
=	O
*	O
h	double
;	O
double	O
rmax	double
=	O
DBL_MIN	O
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
const	O
double	O
D0	double
=	O
eps_rel	double
*	O
(	O
a_y	double
*	O
fabs	function
(	O
y	double
[	O
i	long
]	O
)	O
+	O
a_dydt	double
*	O
fabs	function
(	O
h_old	double
*	O
yp	array
[	O
i	long
]	O
)	O
)	O
+	O
eps_abs	double
;	O
const	O
double	O
r	double
=	O
fabs	function
(	O
yerr	array
[	O
i	long
]	O
)	O
/	O
fabs	function
(	O
D0	double
)	O
;	O
rmax	double
=	O
GSL_MAX_DBL	function
(	O
r	double
,	O
rmax	double
)	O
;	O
}	O
if	O
(	O
rmax	double
>	O
1.1	int
)	O
{	O
double	O
r	double
=	O
S	double
/	O
pow	function
(	O
rmax	double
,	O
1.0	int
/	O
ord	int
)	O
;	O
if	O
(	O
r	double
<	O
0.2	int
)	O
r	double
=	O
0.2	int
;	O
*	O
h	double
=	O
r	double
*	O
h_old	double
;	O
return	O
GSL_ODEIV_HADJ_DEC	O
;	O
}	O
else	O
if	O
(	O
rmax	double
<	O
0.5	int
)	O
{	O
double	O
r	double
=	O
S	double
/	O
pow	function
(	O
rmax	double
,	O
1.0	int
/	O
(	O
ord	int
+	O
1.0	int
)	O
)	O
;	O
if	O
(	O
r	double
>	O
5.0	int
)	O
r	double
=	O
5.0	int
;	O
if	O
(	O
r	double
<	O
1.0	int
)	O
r	double
=	O
1.0	int
;	O
*	O
h	double
=	O
r	double
*	O
h_old	double
;	O
return	O
GSL_ODEIV_HADJ_INC	int
;	O
}	O
else	O
{	O
return	O
GSL_ODEIV_HADJ_NIL	int
;	O
}	O
}	O
static	O
void	O
std_control_free	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
std_control_state_t	struct
*	O
state	pointer
=	O
(	O
std_control_state_t	struct
*	O
)	O
vstate	pointer
;	O
free	function
(	O
state	pointer
)	O
;	O
}	O
static	O
const	O
gsl_odeiv_control_type	struct
std_control_type	struct
=	O
{	O
"standard"	pointer
,	O
&	O
std_control_alloc	function
,	O
&	O
std_control_init	function
,	O
&	O
std_control_hadjust	function
,	O
&	O
std_control_free	function
}	O
;	O
const	O
gsl_odeiv_control_type	struct
*	O
gsl_odeiv_control_standard	pointer
=	O
&	O
std_control_type	struct
;	O
gsl_odeiv_control	struct
*	O
gsl_odeiv_control_standard_new	function
(	O
double	O
eps_abs	double
,	O
double	O
eps_rel	double
,	O
double	O
a_y	double
,	O
double	O
a_dydt	double
)	O
{	O
gsl_odeiv_control	struct
*	O
c	pointer
=	O
gsl_odeiv_control_alloc	function
(	O
gsl_odeiv_control_standard	pointer
)	O
;	O
int	O
status	int
=	O
gsl_odeiv_control_init	function
(	O
c	pointer
,	O
eps_abs	double
,	O
eps_rel	double
,	O
a_y	double
,	O
a_dydt	double
)	O
;	O
if	O
(	O
status	int
!=	O
GSL_SUCCESS	int
)	O
{	O
gsl_odeiv_control_free	function
(	O
c	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"error trying to initialize control"	pointer
,	O
status	int
)	O
;	O
}	O
return	O
c	pointer
;	O
}	O
gsl_odeiv_control	struct
*	O
gsl_odeiv_control_y_new	function
(	O
double	O
eps_abs	double
,	O
double	O
eps_rel	double
)	O
{	O
return	O
gsl_odeiv_control_standard_new	function
(	O
eps_abs	double
,	O
eps_rel	double
,	O
1.0	int
,	O
0.0	int
)	O
;	O
}	O
gsl_odeiv_control	struct
*	O
gsl_odeiv_control_yp_new	function
(	O
double	O
eps_abs	double
,	O
double	O
eps_rel	double
)	O
{	O
return	O
gsl_odeiv_control_standard_new	function
(	O
eps_abs	double
,	O
eps_rel	double
,	O
0.0	int
,	O
1.0	int
)	O
;	O
}	O
typedef	O
struct	O
{	O
double	O
*	O
k1	pointer
;	O
double	O
*	O
k2	pointer
;	O
double	O
*	O
k3	pointer
;	O
double	O
*	O
ytmp	pointer
;	O
}	O
rk2_state_t	struct
;	O
static	O
void	O
*	O
rk2_alloc	function
(	O
size_t	long
dim	long
)	O
{	O
rk2_state_t	struct
*	O
state	pointer
=	O
(	O
rk2_state_t	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
rk2_state_t	struct
)	O
)	O
;	O
if	O
(	O
state	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for rk2_state"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
k1	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
k1	pointer
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for k1"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
k2	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
k2	pointer
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
->	O
k1	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for k2"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
k3	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
k3	pointer
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
->	O
k2	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
k1	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for k3"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
ytmp	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
state	pointer
->	O
ytmp	pointer
==	O
0	int
)	O
{	O
free	function
(	O
state	pointer
->	O
k3	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
k2	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
k1	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for ytmp"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
state	pointer
;	O
}	O
static	O
int	O
rk2_apply	function
(	O
void	O
*	O
vstate	pointer
,	O
size_t	long
dim	long
,	O
double	O
t	double
,	O
double	O
h	double
,	O
double	O
y	array
[	O
]	O
,	O
double	O
yerr	array
[	O
]	O
,	O
const	O
double	O
dydt_in	array
[	O
]	O
,	O
double	O
dydt_out	array
[	O
]	O
,	O
const	O
gsl_odeiv_system	struct
*	O
sys	pointer
)	O
{	O
rk2_state_t	struct
*	O
state	pointer
=	O
(	O
rk2_state_t	struct
*	O
)	O
vstate	pointer
;	O
size_t	long
i	long
;	O
double	O
*	O
const	O
k1	pointer
=	O
state	pointer
->	O
k1	pointer
;	O
double	O
*	O
const	O
k2	pointer
=	O
state	pointer
->	O
k2	pointer
;	O
double	O
*	O
const	O
k3	pointer
=	O
state	pointer
->	O
k3	pointer
;	O
double	O
*	O
const	O
ytmp	pointer
=	O
state	pointer
->	O
ytmp	pointer
;	O
if	O
(	O
dydt_in	array
!=	O
NULL	O
)	O
{	O
DBL_MEMCPY	O
(	O
k1	pointer
,	O
dydt_in	array
,	O
dim	long
)	O
;	O
}	O
else	O
{	O
int	O
s	pointer
=	O
GSL_ODEIV_FN_EVAL	O
(	O
sys	pointer
,	O
t	double
,	O
y	double
,	O
k1	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
return	O
s	pointer
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
ytmp	pointer
[	O
i	long
]	O
=	O
y	array
[	O
i	long
]	O
+	O
0.5	int
*	O
h	double
*	O
k1	pointer
[	O
i	long
]	O
;	O
}	O
{	O
int	O
s	pointer
=	O
GSL_ODEIV_FN_EVAL	O
(	O
sys	pointer
,	O
t	double
+	O
0.5	int
*	O
h	double
,	O
ytmp	pointer
,	O
k2	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
return	O
s	pointer
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
ytmp	pointer
[	O
i	long
]	O
=	O
y	array
[	O
i	long
]	O
+	O
h	double
*	O
(	O
-	O
k1	pointer
[	O
i	long
]	O
+	O
2.0	int
*	O
k2	pointer
[	O
i	long
]	O
)	O
;	O
}	O
{	O
int	O
s	pointer
=	O
GSL_ODEIV_FN_EVAL	O
(	O
sys	pointer
,	O
t	double
+	O
h	double
,	O
ytmp	pointer
,	O
k3	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
return	O
s	pointer
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
ytmp	pointer
[	O
i	long
]	O
=	O
y	array
[	O
i	long
]	O
;	O
{	O
const	O
double	O
ksum3	double
=	O
(	O
k1	pointer
[	O
i	long
]	O
+	O
4.0	int
*	O
k2	pointer
[	O
i	long
]	O
+	O
k3	pointer
[	O
i	long
]	O
)	O
/	O
6.0	int
;	O
y	array
[	O
i	long
]	O
+=	O
h	double
*	O
ksum3	double
;	O
}	O
}	O
if	O
(	O
dydt_out	array
!=	O
NULL	O
)	O
{	O
int	O
s	pointer
=	O
GSL_ODEIV_FN_EVAL	O
(	O
sys	pointer
,	O
t	double
+	O
h	double
,	O
y	double
,	O
dydt_out	array
)	O
;	O
if	O
(	O
s	pointer
!=	O
GSL_SUCCESS	int
)	O
{	O
DBL_MEMCPY	O
(	O
y	double
,	O
ytmp	pointer
,	O
dim	long
)	O
;	O
return	O
s	pointer
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
const	O
double	O
ksum3	double
=	O
(	O
k1	pointer
[	O
i	long
]	O
+	O
4.0	int
*	O
k2	pointer
[	O
i	long
]	O
+	O
k3	pointer
[	O
i	long
]	O
)	O
/	O
6.0	int
;	O
yerr	array
[	O
i	long
]	O
=	O
h	double
*	O
(	O
k2	pointer
[	O
i	long
]	O
-	O
ksum3	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
rk2_reset	function
(	O
void	O
*	O
vstate	pointer
,	O
size_t	long
dim	long
)	O
{	O
rk2_state_t	struct
*	O
state	pointer
=	O
(	O
rk2_state_t	struct
*	O
)	O
vstate	pointer
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
k1	pointer
,	O
dim	long
)	O
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
k2	pointer
,	O
dim	long
)	O
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
k3	pointer
,	O
dim	long
)	O
;	O
DBL_ZERO_MEMSET	O
(	O
state	pointer
->	O
ytmp	pointer
,	O
dim	long
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
unsigned	O
int	O
rk2_order	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
rk2_state_t	struct
*	O
state	pointer
=	O
(	O
rk2_state_t	struct
*	O
)	O
vstate	pointer
;	O
state	pointer
=	O
0	int
;	O
return	O
2	int
;	O
}	O
static	O
void	O
rk2_free	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
rk2_state_t	struct
*	O
state	pointer
=	O
(	O
rk2_state_t	struct
*	O
)	O
vstate	pointer
;	O
free	function
(	O
state	pointer
->	O
k1	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
k2	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
k3	pointer
)	O
;	O
free	function
(	O
state	pointer
->	O
ytmp	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
}	O
static	O
const	O
gsl_odeiv_step_type	struct
rk2_type	struct
=	O
{	O
"rk2"	pointer
,	O
1	int
,	O
1	int
,	O
&	O
rk2_alloc	function
,	O
&	O
rk2_apply	function
,	O
&	O
rk2_reset	function
,	O
&	O
rk2_order	function
,	O
&	O
rk2_free	function
}	O
;	O
const	O
gsl_odeiv_step_type	struct
*	O
gsl_odeiv_step_rk2	pointer
=	O
&	O
rk2_type	struct
;	O
int	O
gsl_permutation_linear_to_canonical	function
(	O
gsl_permutation	struct
*	O
q	pointer
,	O
const	O
gsl_permutation	struct
*	O
p	pointer
)	O
{	O
const	O
size_t	long
n	int
=	O
p	pointer
->	O
size	long
;	O
size_t	long
i	long
,	O
k	long
,	O
s	array
;	O
size_t	long
t	long
=	O
n	long
;	O
const	O
size_t	long
*	O
const	O
pp	pointer
=	O
p	pointer
->	O
data	pointer
;	O
size_t	long
*	O
const	O
qq	pointer
=	O
q	pointer
->	O
data	pointer
;	O
if	O
(	O
q	pointer
->	O
size	long
!=	O
p	pointer
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"size of q does not match size of p"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
k	long
=	O
pp	pointer
[	O
i	long
]	O
;	O
s	long
=	O
1	int
;	O
while	O
(	O
k	long
>	O
i	long
)	O
{	O
k	long
=	O
pp	pointer
[	O
k	long
]	O
;	O
s	pointer
++	O
;	O
}	O
if	O
(	O
k	long
<	O
i	long
)	O
continue	O
;	O
t	long
-=	O
s	pointer
;	O
qq	array
[	O
t	long
]	O
=	O
i	long
;	O
k	long
=	O
pp	pointer
[	O
i	long
]	O
;	O
s	long
=	O
1	int
;	O
while	O
(	O
k	long
>	O
i	long
)	O
{	O
qq	array
[	O
t	long
+	O
s	long
]	O
=	O
k	long
;	O
k	long
=	O
pp	pointer
[	O
k	long
]	O
;	O
s	pointer
++	O
;	O
}	O
if	O
(	O
t	long
==	O
0	int
)	O
break	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_permutation_canonical_to_linear	function
(	O
gsl_permutation	struct
*	O
p	pointer
,	O
const	O
gsl_permutation	struct
*	O
q	pointer
)	O
{	O
size_t	long
i	long
,	O
k	long
,	O
kk	int
,	O
first	int
;	O
const	O
size_t	long
n	int
=	O
p	pointer
->	O
size	long
;	O
size_t	long
*	O
const	O
pp	pointer
=	O
p	pointer
->	O
data	pointer
;	O
const	O
size_t	long
*	O
const	O
qq	pointer
=	O
q	pointer
->	O
data	pointer
;	O
if	O
(	O
q	pointer
->	O
size	long
!=	O
p	pointer
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"size of q does not match size of p"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
pp	pointer
[	O
i	long
]	O
=	O
i	long
;	O
}	O
k	long
=	O
qq	array
[	O
0	int
]	O
;	O
first	double
=	O
pp	pointer
[	O
k	long
]	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
kk	int
=	O
qq	array
[	O
i	long
]	O
;	O
if	O
(	O
kk	int
>	O
first	int
)	O
{	O
pp	pointer
[	O
k	long
]	O
=	O
pp	pointer
[	O
kk	int
]	O
;	O
k	long
=	O
kk	int
;	O
}	O
else	O
{	O
pp	pointer
[	O
k	long
]	O
=	O
first	int
;	O
k	long
=	O
kk	int
;	O
first	int
=	O
pp	pointer
[	O
kk	int
]	O
;	O
}	O
}	O
pp	pointer
[	O
k	long
]	O
=	O
first	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
size_t	long
gsl_permutation_inversions	function
(	O
const	O
gsl_permutation	struct
*	O
p	pointer
)	O
{	O
size_t	long
count	long
=	O
0	int
;	O
size_t	long
i	long
,	O
j	long
;	O
const	O
size_t	long
size	long
=	O
p	pointer
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
size	long
-	O
1	int
;	O
i	long
++	O
)	O
{	O
for	O
(	O
j	long
=	O
i	long
+	O
1	int
;	O
j	long
<	O
size	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
p	pointer
->	O
data	pointer
[	O
i	long
]	O
>	O
p	pointer
->	O
data	pointer
[	O
j	long
]	O
)	O
{	O
count	long
++	O
;	O
}	O
}	O
}	O
return	O
count	long
;	O
}	O
size_t	long
gsl_permutation_linear_cycles	function
(	O
const	O
gsl_permutation	struct
*	O
p	pointer
)	O
{	O
size_t	long
i	long
,	O
k	long
;	O
size_t	long
count	long
=	O
0	int
;	O
const	O
size_t	long
size	long
=	O
p	pointer
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
size	long
;	O
i	long
++	O
)	O
{	O
k	long
=	O
p	pointer
->	O
data	pointer
[	O
i	long
]	O
;	O
while	O
(	O
k	long
>	O
i	long
)	O
{	O
k	long
=	O
p	pointer
->	O
data	pointer
[	O
k	long
]	O
;	O
}	O
if	O
(	O
k	long
<	O
i	long
)	O
continue	O
;	O
count	long
++	O
;	O
}	O
return	O
count	long
;	O
}	O
size_t	long
gsl_permutation_canonical_cycles	function
(	O
const	O
gsl_permutation	struct
*	O
p	pointer
)	O
{	O
size_t	long
i	long
;	O
size_t	long
count	long
=	O
1	int
;	O
size_t	long
min	long
=	O
p	pointer
->	O
data	pointer
[	O
0	int
]	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
p	pointer
->	O
size	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
p	pointer
->	O
data	pointer
[	O
i	long
]	O
<	O
min	double
)	O
{	O
min	double
=	O
p	pointer
->	O
data	pointer
[	O
i	long
]	O
;	O
count	long
++	O
;	O
}	O
}	O
return	O
count	long
;	O
}	O
int	O
gsl_poly_complex_solve	function
(	O
const	O
double	O
*	O
a	pointer
,	O
size_t	long
n	long
,	O
gsl_poly_complex_workspace	struct
*	O
w	pointer
,	O
gsl_complex_packed_ptr	double
z	double
)	O
{	O
int	O
status	int
;	O
double	O
*	O
m	pointer
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"number of terms must be a positive integer"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"cannot solve for only one term"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
a	pointer
[	O
n	int
-	O
1	int
]	O
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"leading term of polynomial must be non-zero"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
w	pointer
->	O
nc	int
!=	O
n	int
-	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"size of workspace does not match polynomial"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
m	pointer
=	O
w	pointer
->	O
matrix	pointer
;	O
set_companion_matrix	function
(	O
a	int
,	O
n	int
-	O
1	int
,	O
m	pointer
)	O
;	O
balance_companion_matrix	function
(	O
m	pointer
,	O
n	int
-	O
1	int
)	O
;	O
status	int
=	O
qr_companion	function
(	O
m	pointer
,	O
n	int
-	O
1	int
,	O
z	double
)	O
;	O
if	O
(	O
status	int
)	O
{	O
GSL_ERROR	O
(	O
"root solving qr method failed to converge"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_poly_complex_solve_quadratic	function
(	O
double	O
a	double
,	O
double	O
b	double
,	O
double	O
c	double
,	O
gsl_complex	struct
*	O
z0	pointer
,	O
gsl_complex	struct
*	O
z1	pointer
)	O
{	O
double	O
disc	double
=	O
b	double
*	O
b	double
-	O
4	int
*	O
a	double
*	O
c	double
;	O
if	O
(	O
a	double
==	O
0	int
)	O
{	O
if	O
(	O
b	double
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
-	O
c	double
/	O
b	double
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
0	int
;	O
return	O
1	int
;	O
}	O
;	O
}	O
if	O
(	O
disc	double
>	O
0	int
)	O
{	O
if	O
(	O
b	double
==	O
0	int
)	O
{	O
double	O
s	double
=	O
fabs	function
(	O
0.5	int
*	O
sqrt	function
(	O
disc	double
)	O
/	O
a	double
)	O
;	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
-	O
s	double
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z1	pointer
)	O
=	O
s	double
;	O
GSL_IMAG	O
(	O
*	O
z1	pointer
)	O
=	O
0	int
;	O
}	O
else	O
{	O
double	O
sgnb	double
=	O
(	O
b	double
>	O
0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
double	O
temp	double
=	O
-	O
0.5	int
*	O
(	O
b	double
+	O
sgnb	double
*	O
sqrt	function
(	O
disc	double
)	O
)	O
;	O
double	O
r1	double
=	O
temp	double
/	O
a	double
;	O
double	O
r2	double
=	O
c	int
/	O
temp	double
;	O
if	O
(	O
r1	double
<	O
r2	double
)	O
{	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
r1	double
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z1	pointer
)	O
=	O
r2	double
;	O
GSL_IMAG	O
(	O
*	O
z1	pointer
)	O
=	O
0	int
;	O
}	O
else	O
{	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
r2	double
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z1	pointer
)	O
=	O
r1	double
;	O
GSL_IMAG	O
(	O
*	O
z1	pointer
)	O
=	O
0	int
;	O
}	O
}	O
return	O
2	int
;	O
}	O
else	O
if	O
(	O
disc	double
==	O
0	int
)	O
{	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
-	O
0.5	int
*	O
b	double
/	O
a	double
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
0	int
;	O
GSL_REAL	O
(	O
*	O
z1	pointer
)	O
=	O
-	O
0.5	int
*	O
b	double
/	O
a	double
;	O
GSL_IMAG	O
(	O
*	O
z1	pointer
)	O
=	O
0	int
;	O
return	O
2	int
;	O
}	O
else	O
{	O
double	O
s	double
=	O
fabs	function
(	O
0.5	int
*	O
sqrt	function
(	O
-	O
disc	double
)	O
/	O
a	double
)	O
;	O
GSL_REAL	O
(	O
*	O
z0	pointer
)	O
=	O
-	O
0.5	int
*	O
b	double
/	O
a	double
;	O
GSL_IMAG	O
(	O
*	O
z0	pointer
)	O
=	O
-	O
s	double
;	O
GSL_REAL	O
(	O
*	O
z1	pointer
)	O
=	O
-	O
0.5	int
*	O
b	double
/	O
a	double
;	O
GSL_IMAG	O
(	O
*	O
z1	pointer
)	O
=	O
s	double
;	O
return	O
2	int
;	O
}	O
}	O
gsl_qrng	struct
*	O
gsl_qrng_alloc	function
(	O
const	O
gsl_qrng_type	struct
*	O
T	pointer
,	O
unsigned	O
int	O
dimension	int
)	O
{	O
gsl_qrng	struct
*	O
q	pointer
=	O
(	O
gsl_qrng	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_qrng	struct
)	O
)	O
;	O
if	O
(	O
q	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"allocation failed for qrng struct"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
;	O
q	pointer
->	O
dimension	long
=	O
dimension	long
;	O
q	pointer
->	O
state_size	long
=	O
T	pointer
->	O
state_size	function
(	O
dimension	long
)	O
;	O
q	pointer
->	O
state	pointer
=	O
malloc	function
(	O
q	pointer
->	O
state_size	long
)	O
;	O
if	O
(	O
q	pointer
->	O
state	pointer
==	O
0	int
)	O
{	O
free	function
(	O
q	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"allocation failed for qrng state"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
;	O
q	pointer
->	O
type	pointer
=	O
T	pointer
;	O
T	pointer
->	O
init_state	struct
(	O
q	pointer
->	O
state	pointer
,	O
q	pointer
->	O
dimension	long
)	O
;	O
return	O
q	int
;	O
}	O
void	O
gsl_qrng_init	function
(	O
gsl_qrng	struct
*	O
q	pointer
)	O
{	O
(	O
q	pointer
->	O
type	pointer
->	O
init_state	struct
)	O
(	O
q	pointer
->	O
state	pointer
,	O
q	pointer
->	O
dimension	long
)	O
;	O
}	O
int	O
gsl_qrng_memcpy	function
(	O
gsl_qrng	struct
*	O
dest	pointer
,	O
const	O
gsl_qrng	struct
*	O
src	pointer
)	O
{	O
if	O
(	O
dest	pointer
->	O
type	int
!=	O
src	pointer
->	O
type	int
)	O
{	O
GSL_ERROR	O
(	O
"generators must be of the same type"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
dest	pointer
->	O
dimension	long
=	O
src	pointer
->	O
dimension	long
;	O
dest	pointer
->	O
state_size	long
=	O
src	pointer
->	O
state_size	long
;	O
memcpy	function
(	O
dest	pointer
->	O
state	pointer
,	O
src	pointer
->	O
state	pointer
,	O
src	pointer
->	O
state_size	long
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
gsl_qrng	struct
*	O
gsl_qrng_clone	function
(	O
const	O
gsl_qrng	struct
*	O
q	pointer
)	O
{	O
gsl_qrng	struct
*	O
r	pointer
=	O
(	O
gsl_qrng	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_qrng	struct
)	O
)	O
;	O
if	O
(	O
r	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for rng struct"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
;	O
r	pointer
->	O
dimension	long
=	O
q	pointer
->	O
dimension	long
;	O
r	pointer
->	O
state_size	long
=	O
q	pointer
->	O
state_size	long
;	O
r	pointer
->	O
state	pointer
=	O
malloc	function
(	O
r	pointer
->	O
state_size	long
)	O
;	O
if	O
(	O
r	pointer
->	O
state	pointer
==	O
0	int
)	O
{	O
free	function
(	O
r	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for rng state"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
;	O
r	pointer
->	O
type	int
=	O
q	pointer
->	O
type	enum
;	O
memcpy	function
(	O
r	pointer
->	O
state	pointer
,	O
q	pointer
->	O
state	pointer
,	O
q	pointer
->	O
state_size	long
)	O
;	O
return	O
r	int
;	O
}	O
const	O
char	O
*	O
gsl_qrng_name	function
(	O
const	O
gsl_qrng	struct
*	O
q	pointer
)	O
{	O
return	O
q	pointer
->	O
type	pointer
->	O
name	pointer
;	O
}	O
size_t	long
gsl_qrng_size	function
(	O
const	O
gsl_qrng	struct
*	O
q	pointer
)	O
{	O
return	O
q	pointer
->	O
state_size	long
;	O
}	O
void	O
*	O
gsl_qrng_state	function
(	O
const	O
gsl_qrng	struct
*	O
q	pointer
)	O
{	O
return	O
q	pointer
->	O
state	pointer
;	O
}	O
void	O
gsl_qrng_free	function
(	O
gsl_qrng	struct
*	O
q	pointer
)	O
{	O
RETURN_IF_NULL	O
(	O
q	pointer
)	O
;	O
if	O
(	O
q	pointer
->	O
state	pointer
!=	O
0	int
)	O
free	function
(	O
q	pointer
->	O
state	pointer
)	O
;	O
free	function
(	O
q	pointer
)	O
;	O
}	O
double	O
gsl_ran_chisq	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
double	O
nu	double
)	O
{	O
double	O
chisq	int
=	O
2	int
*	O
gsl_ran_gamma	function
(	O
r	pointer
,	O
nu	double
/	O
2	int
,	O
1.0	int
)	O
;	O
return	O
chisq	int
;	O
}	O
double	O
gsl_ran_chisq_pdf	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
nu	double
)	O
{	O
if	O
(	O
x	double
<	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
nu	double
==	O
2.0	int
)	O
{	O
return	O
exp	function
(	O
-	O
x	double
/	O
2.0	int
)	O
/	O
2.0	int
;	O
}	O
else	O
{	O
double	O
p	int
;	O
double	O
lngamma	double
=	O
gsl_sf_lngamma	function
(	O
nu	double
/	O
2	int
)	O
;	O
p	int
=	O
exp	function
(	O
(	O
nu	double
/	O
2	int
-	O
1	int
)	O
*	O
log	function
(	O
x	double
/	O
2	int
)	O
-	O
x	double
/	O
2	int
-	O
lngamma	double
)	O
/	O
2	int
;	O
return	O
p	int
;	O
}	O
}	O
}	O
static	O
void	O
ran_dirichlet_small	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
size_t	long
K	long
,	O
const	O
double	O
alpha	enum
[	O
]	O
,	O
double	O
theta	array
[	O
]	O
)	O
;	O
void	O
gsl_ran_dirichlet	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
size_t	long
K	long
,	O
const	O
double	O
alpha	double
[	O
]	O
,	O
double	O
theta	array
[	O
]	O
)	O
{	O
size_t	long
i	long
;	O
double	O
norm	double
=	O
0.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
K	int
;	O
i	long
++	O
)	O
{	O
theta	array
[	O
i	long
]	O
=	O
gsl_ran_gamma	function
(	O
r	pointer
,	O
alpha	double
[	O
i	long
]	O
,	O
1.0	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
K	int
;	O
i	long
++	O
)	O
{	O
norm	pointer
+=	O
theta	array
[	O
i	long
]	O
;	O
}	O
if	O
(	O
norm	double
<	O
GSL_SQRT_DBL_MIN	int
)	O
{	O
ran_dirichlet_small	function
(	O
r	pointer
,	O
K	int
,	O
alpha	double
,	O
theta	double
)	O
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
K	int
;	O
i	long
++	O
)	O
{	O
theta	array
[	O
i	int
]	O
/=	O
norm	int
;	O
}	O
}	O
static	O
void	O
ran_dirichlet_small	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
size_t	long
K	long
,	O
const	O
double	O
alpha	double
[	O
]	O
,	O
double	O
theta	array
[	O
]	O
)	O
{	O
size_t	long
i	long
;	O
double	O
norm	double
=	O
0.0	int
,	O
umax	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
K	int
;	O
i	long
++	O
)	O
{	O
double	O
u	pointer
=	O
log	function
(	O
gsl_rng_uniform_pos	function
(	O
r	pointer
)	O
)	O
/	O
alpha	double
[	O
i	long
]	O
;	O
theta	array
[	O
i	int
]	O
=	O
u	double
;	O
if	O
(	O
u	pointer
>	O
umax	int
||	O
i	long
==	O
0	int
)	O
{	O
umax	pointer
=	O
u	pointer
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
K	int
;	O
i	long
++	O
)	O
{	O
theta	array
[	O
i	int
]	O
=	O
exp	function
(	O
theta	array
[	O
i	long
]	O
-	O
umax	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
K	int
;	O
i	long
++	O
)	O
{	O
theta	array
[	O
i	int
]	O
=	O
theta	array
[	O
i	long
]	O
*	O
gsl_ran_gamma	function
(	O
r	pointer
,	O
alpha	double
[	O
i	long
]	O
+	O
1.0	int
,	O
1.0	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
K	int
;	O
i	long
++	O
)	O
{	O
norm	pointer
+=	O
theta	array
[	O
i	long
]	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
K	int
;	O
i	long
++	O
)	O
{	O
theta	array
[	O
i	int
]	O
/=	O
norm	int
;	O
}	O
}	O
double	O
gsl_ran_dirichlet_pdf	function
(	O
const	O
size_t	long
K	long
,	O
const	O
double	O
alpha	double
[	O
]	O
,	O
const	O
double	O
theta	array
[	O
]	O
)	O
{	O
return	O
exp	function
(	O
gsl_ran_dirichlet_lnpdf	function
(	O
K	int
,	O
alpha	double
,	O
theta	double
)	O
)	O
;	O
}	O
double	O
gsl_ran_dirichlet_lnpdf	function
(	O
const	O
size_t	long
K	long
,	O
const	O
double	O
alpha	double
[	O
]	O
,	O
const	O
double	O
theta	array
[	O
]	O
)	O
{	O
size_t	long
i	long
;	O
double	O
log_p	double
=	O
0.0	int
;	O
double	O
sum_alpha	double
=	O
0.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
K	int
;	O
i	long
++	O
)	O
{	O
log_p	int
+=	O
(	O
alpha	double
[	O
i	long
]	O
-	O
1.0	int
)	O
*	O
log	function
(	O
theta	array
[	O
i	int
]	O
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
K	int
;	O
i	long
++	O
)	O
{	O
sum_alpha	int
+=	O
alpha	double
[	O
i	long
]	O
;	O
}	O
log_p	double
+=	O
gsl_sf_lngamma	function
(	O
sum_alpha	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
K	int
;	O
i	long
++	O
)	O
{	O
log_p	int
-=	O
gsl_sf_lngamma	function
(	O
alpha	double
[	O
i	long
]	O
)	O
;	O
}	O
return	O
log_p	double
;	O
}	O
static	O
double	O
gamma_large	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
double	O
a	double
)	O
;	O
static	O
double	O
gamma_frac	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
double	O
a	double
)	O
;	O
double	O
gsl_ran_gamma_knuth	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
unsigned	O
int	O
na	double
=	O
floor	function
(	O
a	double
)	O
;	O
if	O
(	O
a	pointer
>=	O
UINT_MAX	O
)	O
{	O
return	O
b	double
*	O
(	O
gamma_large	function
(	O
r	pointer
,	O
floor	function
(	O
a	double
)	O
)	O
+	O
gamma_frac	function
(	O
r	pointer
,	O
a	double
-	O
floor	function
(	O
a	double
)	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
a	double
==	O
na	int
)	O
{	O
return	O
b	double
*	O
gsl_ran_gamma_int	function
(	O
r	pointer
,	O
na	int
)	O
;	O
}	O
else	O
if	O
(	O
na	int
==	O
0	int
)	O
{	O
return	O
b	double
*	O
gamma_frac	function
(	O
r	pointer
,	O
a	double
)	O
;	O
}	O
else	O
{	O
return	O
b	double
*	O
(	O
gsl_ran_gamma_int	function
(	O
r	pointer
,	O
na	int
)	O
+	O
gamma_frac	function
(	O
r	pointer
,	O
a	double
-	O
na	double
)	O
)	O
;	O
}	O
}	O
double	O
gsl_ran_gamma_int	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
unsigned	O
int	O
a	int
)	O
{	O
if	O
(	O
a	int
<	O
12	int
)	O
{	O
unsigned	O
int	O
i	long
;	O
double	O
prod	double
=	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
a	int
;	O
i	long
++	O
)	O
{	O
prod	double
*=	O
gsl_rng_uniform_pos	function
(	O
r	pointer
)	O
;	O
}	O
return	O
-	O
log	function
(	O
prod	pointer
)	O
;	O
}	O
else	O
{	O
return	O
gamma_large	function
(	O
r	pointer
,	O
(	O
double	O
)	O
a	double
)	O
;	O
}	O
}	O
static	O
double	O
gamma_large	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
double	O
a	double
)	O
{	O
double	O
sqa	double
,	O
x	double
,	O
y	double
,	O
v	pointer
;	O
sqa	double
=	O
sqrt	function
(	O
2	int
*	O
a	double
-	O
1	int
)	O
;	O
do	O
{	O
do	O
{	O
y	double
=	O
tan	function
(	O
M_PI	int
*	O
gsl_rng_uniform	function
(	O
r	pointer
)	O
)	O
;	O
x	double
=	O
sqa	double
*	O
y	double
+	O
a	double
-	O
1	int
;	O
}	O
while	O
(	O
x	double
<=	O
0	int
)	O
;	O
v	pointer
=	O
gsl_rng_uniform	function
(	O
r	pointer
)	O
;	O
}	O
while	O
(	O
v	pointer
>	O
(	O
1	int
+	O
y	double
*	O
y	double
)	O
*	O
exp	function
(	O
(	O
a	double
-	O
1	int
)	O
*	O
log	function
(	O
x	double
/	O
(	O
a	pointer
-	O
1	int
)	O
)	O
-	O
sqa	double
*	O
y	double
)	O
)	O
;	O
return	O
x	double
;	O
}	O
static	O
double	O
gamma_frac	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
double	O
a	double
)	O
{	O
double	O
p	int
,	O
q	int
,	O
x	double
,	O
u	pointer
,	O
v	pointer
;	O
if	O
(	O
a	double
==	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
p	pointer
=	O
M_E	double
/	O
(	O
a	pointer
+	O
M_E	int
)	O
;	O
do	O
{	O
u	pointer
=	O
gsl_rng_uniform	function
(	O
r	pointer
)	O
;	O
v	pointer
=	O
gsl_rng_uniform_pos	function
(	O
r	pointer
)	O
;	O
if	O
(	O
u	pointer
<	O
p	int
)	O
{	O
x	double
=	O
exp	function
(	O
(	O
1	int
/	O
a	double
)	O
*	O
log	function
(	O
v	pointer
)	O
)	O
;	O
q	int
=	O
exp	function
(	O
-	O
x	double
)	O
;	O
}	O
else	O
{	O
x	double
=	O
1	int
-	O
log	function
(	O
v	pointer
)	O
;	O
q	int
=	O
exp	function
(	O
(	O
a	double
-	O
1	int
)	O
*	O
log	function
(	O
x	double
)	O
)	O
;	O
}	O
}	O
while	O
(	O
gsl_rng_uniform	function
(	O
r	pointer
)	O
>=	O
q	int
)	O
;	O
return	O
x	double
;	O
}	O
double	O
gsl_ran_gamma_pdf	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
if	O
(	O
x	double
<	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0	int
)	O
{	O
if	O
(	O
a	double
==	O
1	int
)	O
return	O
1	int
/	O
b	double
;	O
else	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
a	double
==	O
1	int
)	O
{	O
return	O
exp	function
(	O
-	O
x	double
/	O
b	double
)	O
/	O
b	double
;	O
}	O
else	O
{	O
double	O
p	int
;	O
double	O
lngamma	double
=	O
gsl_sf_lngamma	function
(	O
a	double
)	O
;	O
p	int
=	O
exp	function
(	O
(	O
a	double
-	O
1	int
)	O
*	O
log	function
(	O
x	double
/	O
b	double
)	O
-	O
x	double
/	O
b	double
-	O
lngamma	double
)	O
/	O
b	double
;	O
return	O
p	int
;	O
}	O
}	O
double	O
gsl_ran_gamma_mt	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
return	O
gsl_ran_gamma	function
(	O
r	pointer
,	O
a	double
,	O
b	double
)	O
;	O
}	O
double	O
gsl_ran_gamma	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
if	O
(	O
a	double
<	O
1	int
)	O
{	O
double	O
u	pointer
=	O
gsl_rng_uniform_pos	function
(	O
r	pointer
)	O
;	O
return	O
gsl_ran_gamma	function
(	O
r	pointer
,	O
1.0	int
+	O
a	double
,	O
b	double
)	O
*	O
pow	function
(	O
u	double
,	O
1.0	int
/	O
a	double
)	O
;	O
}	O
{	O
double	O
x	double
,	O
v	pointer
,	O
u	pointer
;	O
double	O
d	double
=	O
a	double
-	O
1.0	int
/	O
3.0	int
;	O
double	O
c	double
=	O
(	O
1.0	int
/	O
3.0	int
)	O
/	O
sqrt	function
(	O
d	double
)	O
;	O
while	O
(	O
1	int
)	O
{	O
do	O
{	O
x	double
=	O
gsl_ran_gaussian_ziggurat	function
(	O
r	double
,	O
1.0	int
)	O
;	O
v	double
=	O
1.0	int
+	O
c	double
*	O
x	double
;	O
}	O
while	O
(	O
v	pointer
<=	O
0	int
)	O
;	O
v	pointer
=	O
v	pointer
*	O
v	pointer
*	O
v	pointer
;	O
u	pointer
=	O
gsl_rng_uniform_pos	function
(	O
r	pointer
)	O
;	O
if	O
(	O
u	pointer
<	O
1	int
-	O
0.0331	double
*	O
x	double
*	O
x	double
*	O
x	double
*	O
x	double
)	O
break	O
;	O
if	O
(	O
log	function
(	O
u	double
)	O
<	O
0.5	int
*	O
x	double
*	O
x	double
+	O
d	long
*	O
(	O
1	int
-	O
v	double
+	O
log	function
(	O
v	pointer
)	O
)	O
)	O
break	O
;	O
}	O
return	O
b	double
*	O
d	pointer
*	O
v	pointer
;	O
}	O
}	O
double	O
gsl_ran_gumbel1	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
double	O
x	double
=	O
gsl_rng_uniform_pos	function
(	O
r	pointer
)	O
;	O
double	O
z	double
=	O
(	O
log	function
(	O
b	double
)	O
-	O
log	function
(	O
-	O
log	function
(	O
x	double
)	O
)	O
)	O
/	O
a	double
;	O
return	O
z	double
;	O
}	O
double	O
gsl_ran_gumbel1_pdf	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
double	O
p	int
=	O
a	double
*	O
b	double
*	O
exp	function
(	O
-	O
(	O
b	double
*	O
exp	function
(	O
-	O
a	double
*	O
x	double
)	O
+	O
a	double
*	O
x	double
)	O
)	O
;	O
return	O
p	int
;	O
}	O
double	O
gsl_ran_gumbel2	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
double	O
x	double
=	O
gsl_rng_uniform_pos	function
(	O
r	pointer
)	O
;	O
double	O
z	double
=	O
pow	function
(	O
-	O
b	double
/	O
log	function
(	O
x	double
)	O
,	O
1	int
/	O
a	double
)	O
;	O
return	O
z	double
;	O
}	O
double	O
gsl_ran_gumbel2_pdf	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
if	O
(	O
x	double
<=	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
double	O
p	int
=	O
b	double
*	O
a	double
*	O
pow	function
(	O
x	double
,	O
-	O
(	O
a	double
+	O
1	int
)	O
)	O
*	O
exp	function
(	O
-	O
b	double
*	O
pow	function
(	O
x	double
,	O
-	O
a	double
)	O
)	O
;	O
return	O
p	int
;	O
}	O
}	O
double	O
gsl_ran_lognormal	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
const	O
double	O
zeta	double
,	O
const	O
double	O
sigma	double
)	O
{	O
double	O
u	pointer
,	O
v	pointer
,	O
r2	double
,	O
normal	pointer
,	O
z	double
;	O
do	O
{	O
u	pointer
=	O
-	O
1	int
+	O
2	int
*	O
gsl_rng_uniform	function
(	O
r	pointer
)	O
;	O
v	pointer
=	O
-	O
1	int
+	O
2	int
*	O
gsl_rng_uniform	function
(	O
r	pointer
)	O
;	O
r2	double
=	O
u	pointer
*	O
u	pointer
+	O
v	pointer
*	O
v	pointer
;	O
}	O
while	O
(	O
r2	double
>	O
1.0	int
||	O
r2	double
==	O
0	int
)	O
;	O
normal	pointer
=	O
u	pointer
*	O
sqrt	function
(	O
-	O
2.0	int
*	O
log	function
(	O
r2	double
)	O
/	O
r2	double
)	O
;	O
z	double
=	O
exp	function
(	O
sigma	double
*	O
normal	double
+	O
zeta	double
)	O
;	O
return	O
z	double
;	O
}	O
double	O
gsl_ran_lognormal_pdf	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
zeta	double
,	O
const	O
double	O
sigma	double
)	O
{	O
if	O
(	O
x	double
<=	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
double	O
u	double
=	O
(	O
log	function
(	O
x	double
)	O
-	O
zeta	double
)	O
/	O
sigma	double
;	O
double	O
p	int
=	O
1	int
/	O
(	O
x	double
*	O
fabs	function
(	O
sigma	double
)	O
*	O
sqrt	function
(	O
2	int
*	O
M_PI	int
)	O
)	O
*	O
exp	function
(	O
-	O
(	O
u	pointer
*	O
u	pointer
)	O
/	O
2	int
)	O
;	O
return	O
p	int
;	O
}	O
}	O
double	O
gsl_ran_pareto	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
double	O
x	double
=	O
gsl_rng_uniform_pos	function
(	O
r	pointer
)	O
;	O
double	O
z	double
=	O
pow	function
(	O
x	double
,	O
-	O
1	int
/	O
a	double
)	O
;	O
return	O
b	double
*	O
z	double
;	O
}	O
double	O
gsl_ran_pareto_pdf	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
a	double
,	O
const	O
double	O
b	double
)	O
{	O
if	O
(	O
x	double
>=	O
b	double
)	O
{	O
double	O
p	int
=	O
(	O
a	double
/	O
b	double
)	O
/	O
pow	function
(	O
x	double
/	O
b	double
,	O
a	double
+	O
1	int
)	O
;	O
return	O
p	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
static	O
inline	O
unsigned	O
long	O
int	O
ran_get	function
(	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
double	O
ran_get_double	function
(	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
void	O
ran_set	function
(	O
void	O
*	O
state	pointer
,	O
unsigned	O
long	O
int	O
s	long
)	O
;	O
typedef	O
struct	O
{	O
unsigned	O
long	O
int	O
x	double
;	O
}	O
ran_state_t	struct
;	O
static	O
inline	O
unsigned	O
long	O
int	O
ran_get	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
ran_state_t	struct
*	O
state	pointer
=	O
(	O
ran_state_t	struct
*	O
)	O
vstate	pointer
;	O
state	pointer
->	O
x	double
=	O
(	O
state	pointer
->	O
x	double
*	O
(	O
state	pointer
->	O
x	double
+	O
1	int
)	O
)	O
&	O
MM	int
;	O
return	O
state	pointer
->	O
x	double
;	O
}	O
static	O
double	O
ran_get_double	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
ran_state_t	struct
*	O
state	pointer
=	O
(	O
ran_state_t	struct
*	O
)	O
vstate	pointer
;	O
return	O
ran_get	function
(	O
state	pointer
)	O
/	O
4294967296.0	int
;	O
}	O
static	O
void	O
ran_set	function
(	O
void	O
*	O
vstate	pointer
,	O
unsigned	O
long	O
int	O
s	long
)	O
{	O
ran_state_t	struct
*	O
state	pointer
=	O
(	O
ran_state_t	struct
*	O
)	O
vstate	pointer
;	O
unsigned	O
long	O
int	O
diff	double
=	O
(	O
(	O
s	long
%	O
4UL	int
)	O
-	O
2UL	int
)	O
%	O
MM	int
;	O
if	O
(	O
diff	int
)	O
state	pointer
->	O
x	double
=	O
(	O
s	long
-	O
diff	double
)	O
&	O
MM	int
;	O
else	O
state	pointer
->	O
x	double
=	O
s	long
&	O
MM	int
;	O
return	O
;	O
}	O
static	O
const	O
gsl_rng_type	struct
ran_type	struct
=	O
{	O
"coveyou"	pointer
,	O
MM	int
-	O
1	int
,	O
2	int
,	O
sizeof	O
(	O
ran_state_t	struct
)	O
,	O
&	O
ran_set	function
,	O
&	O
ran_get	function
,	O
&	O
ran_get_double	function
}	O
;	O
const	O
gsl_rng_type	struct
*	O
gsl_rng_coveyou	pointer
=	O
&	O
ran_type	struct
;	O
static	O
inline	O
unsigned	O
long	O
int	O
mrg_get	function
(	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
double	O
mrg_get_double	function
(	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
void	O
mrg_set	function
(	O
void	O
*	O
state	pointer
,	O
unsigned	O
long	O
int	O
s	long
)	O
;	O
static	O
const	O
long	O
int	O
m	long
=	O
2147483647	int
;	O
static	O
const	O
long	O
int	O
a1	long
=	O
107374182	int
,	O
q1	long
=	O
20	int
,	O
r1	long
=	O
7	int
;	O
static	O
const	O
long	O
int	O
a5	long
=	O
104480	int
,	O
q5	int
=	O
20554	int
,	O
r5	int
=	O
1727	int
;	O
typedef	O
struct	O
{	O
long	O
int	O
x1	long
,	O
x2	long
,	O
x3	long
,	O
x4	int
,	O
x5	int
;	O
}	O
mrg_state_t	struct
;	O
static	O
inline	O
unsigned	O
long	O
int	O
mrg_get	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
mrg_state_t	struct
*	O
state	pointer
=	O
(	O
mrg_state_t	struct
*	O
)	O
vstate	pointer
;	O
long	O
int	O
p1	long
,	O
h1	long
,	O
p5	pointer
,	O
h5	pointer
;	O
h5	pointer
=	O
state	pointer
->	O
x5	double
/	O
q5	long
;	O
p5	double
=	O
a5	long
*	O
(	O
state	pointer
->	O
x5	long
-	O
h5	double
*	O
q5	pointer
)	O
-	O
h5	double
*	O
r5	pointer
;	O
if	O
(	O
p5	double
>	O
0	int
)	O
p5	double
-=	O
m	long
;	O
h1	long
=	O
state	pointer
->	O
x1	double
/	O
q1	long
;	O
p1	long
=	O
a1	long
*	O
(	O
state	pointer
->	O
x1	double
-	O
h1	long
*	O
q1	pointer
)	O
-	O
h1	long
*	O
r1	long
;	O
if	O
(	O
p1	long
<	O
0	int
)	O
p1	long
+=	O
m	long
;	O
state	pointer
->	O
x5	long
=	O
state	pointer
->	O
x4	long
;	O
state	pointer
->	O
x4	long
=	O
state	pointer
->	O
x3	long
;	O
state	pointer
->	O
x3	long
=	O
state	pointer
->	O
x2	long
;	O
state	pointer
->	O
x2	long
=	O
state	pointer
->	O
x1	long
;	O
state	pointer
->	O
x1	long
=	O
p1	long
+	O
p5	long
;	O
if	O
(	O
state	pointer
->	O
x1	long
<	O
0	int
)	O
state	pointer
->	O
x1	long
+=	O
m	long
;	O
return	O
state	pointer
->	O
x1	long
;	O
}	O
static	O
double	O
mrg_get_double	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
return	O
mrg_get	function
(	O
vstate	pointer
)	O
/	O
2147483647.0	int
;	O
}	O
static	O
void	O
mrg_set	function
(	O
void	O
*	O
vstate	pointer
,	O
unsigned	O
long	O
int	O
s	long
)	O
{	O
mrg_state_t	struct
*	O
state	pointer
=	O
(	O
mrg_state_t	struct
*	O
)	O
vstate	pointer
;	O
if	O
(	O
s	long
==	O
0	int
)	O
s	long
=	O
1	int
;	O
s	long
=	O
LCG	O
(	O
s	long
)	O
;	O
state	pointer
->	O
x1	long
=	O
s	long
%	O
m	long
;	O
s	long
=	O
LCG	O
(	O
s	long
)	O
;	O
state	pointer
->	O
x2	long
=	O
s	long
%	O
m	long
;	O
s	long
=	O
LCG	O
(	O
s	long
)	O
;	O
state	pointer
->	O
x3	long
=	O
s	long
%	O
m	long
;	O
s	long
=	O
LCG	O
(	O
s	long
)	O
;	O
state	pointer
->	O
x4	long
=	O
s	long
%	O
m	long
;	O
s	long
=	O
LCG	O
(	O
s	long
)	O
;	O
state	pointer
->	O
x5	long
=	O
s	long
%	O
m	long
;	O
mrg_get	function
(	O
state	pointer
)	O
;	O
mrg_get	function
(	O
state	pointer
)	O
;	O
mrg_get	function
(	O
state	pointer
)	O
;	O
mrg_get	function
(	O
state	pointer
)	O
;	O
mrg_get	function
(	O
state	pointer
)	O
;	O
mrg_get	function
(	O
state	pointer
)	O
;	O
return	O
;	O
}	O
static	O
const	O
gsl_rng_type	struct
mrg_type	struct
=	O
{	O
"mrg"	pointer
,	O
2147483646	int
,	O
0	int
,	O
sizeof	O
(	O
mrg_state_t	struct
)	O
,	O
&	O
mrg_set	function
,	O
&	O
mrg_get	function
,	O
&	O
mrg_get_double	function
}	O
;	O
const	O
gsl_rng_type	struct
*	O
gsl_rng_mrg	pointer
=	O
&	O
mrg_type	struct
;	O
static	O
inline	O
unsigned	O
long	O
int	O
ranmar_get	function
(	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
double	O
ranmar_get_double	function
(	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
void	O
ranmar_set	function
(	O
void	O
*	O
state	pointer
,	O
unsigned	O
long	O
int	O
s	long
)	O
;	O
static	O
const	O
unsigned	O
long	O
int	O
two24	long
=	O
16777216	int
;	O
typedef	O
struct	O
{	O
unsigned	O
int	O
i	int
;	O
unsigned	O
int	O
j	int
;	O
long	O
int	O
carry	long
;	O
unsigned	O
long	O
int	O
u	array
[	O
97	int
]	O
;	O
}	O
ranmar_state_t	struct
;	O
static	O
inline	O
unsigned	O
long	O
int	O
ranmar_get	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
ranmar_state_t	struct
*	O
state	pointer
=	O
(	O
ranmar_state_t	struct
*	O
)	O
vstate	pointer
;	O
unsigned	O
int	O
i	int
=	O
state	pointer
->	O
i	int
;	O
unsigned	O
int	O
j	int
=	O
state	pointer
->	O
j	int
;	O
long	O
int	O
carry	long
=	O
state	pointer
->	O
carry	long
;	O
long	O
int	O
delta	long
=	O
state	pointer
->	O
u	array
[	O
i	int
]	O
-	O
state	pointer
->	O
u	array
[	O
j	int
]	O
;	O
if	O
(	O
delta	long
<	O
0	int
)	O
delta	long
+=	O
two24	long
;	O
state	pointer
->	O
u	array
[	O
i	int
]	O
=	O
delta	long
;	O
if	O
(	O
i	long
==	O
0	int
)	O
{	O
i	int
=	O
96	int
;	O
}	O
else	O
{	O
i	long
--	O
;	O
}	O
state	pointer
->	O
i	int
=	O
i	int
;	O
if	O
(	O
j	int
==	O
0	int
)	O
{	O
j	long
=	O
96	int
;	O
}	O
else	O
{	O
j	long
--	O
;	O
}	O
state	pointer
->	O
j	int
=	O
j	int
;	O
carry	long
+=	O
-	O
7654321	int
;	O
if	O
(	O
carry	int
<	O
0	int
)	O
carry	long
+=	O
two24	long
-	O
3	int
;	O
state	pointer
->	O
carry	int
=	O
carry	long
;	O
delta	long
+=	O
-	O
carry	int
;	O
if	O
(	O
delta	int
<	O
0	int
)	O
delta	long
+=	O
two24	long
;	O
return	O
delta	int
;	O
}	O
static	O
double	O
ranmar_get_double	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
return	O
ranmar_get	function
(	O
vstate	pointer
)	O
/	O
16777216.0	int
;	O
}	O
static	O
void	O
ranmar_set	function
(	O
void	O
*	O
vstate	pointer
,	O
unsigned	O
long	O
int	O
s	long
)	O
{	O
ranmar_state_t	struct
*	O
state	pointer
=	O
(	O
ranmar_state_t	struct
*	O
)	O
vstate	pointer
;	O
unsigned	O
long	O
int	O
ij	long
=	O
s	long
/	O
30082	int
;	O
unsigned	O
long	O
int	O
kl	long
=	O
s	long
%	O
30082	int
;	O
int	O
i	long
=	O
(	O
ij	long
/	O
177	int
)	O
%	O
177	int
+	O
2	int
;	O
int	O
j	long
=	O
(	O
ij	long
%	O
177	int
)	O
+	O
2	int
;	O
int	O
k	int
=	O
(	O
kl	long
/	O
169	int
)	O
%	O
178	int
+	O
1	int
;	O
int	O
l	long
=	O
(	O
kl	long
%	O
169	int
)	O
;	O
int	O
a	long
,	O
b	int
;	O
for	O
(	O
a	long
=	O
0	int
;	O
a	int
<	O
97	int
;	O
a	long
++	O
)	O
{	O
unsigned	O
long	O
int	O
sum	long
=	O
0	int
;	O
unsigned	O
long	O
int	O
t	long
=	O
two24	long
;	O
for	O
(	O
b	long
=	O
0	int
;	O
b	int
<	O
24	int
;	O
b	int
++	O
)	O
{	O
unsigned	O
long	O
int	O
m	long
=	O
(	O
(	O
(	O
i	long
*	O
j	long
)	O
%	O
179	int
)	O
*	O
k	long
)	O
%	O
179	int
;	O
i	long
=	O
j	long
;	O
j	long
=	O
k	long
;	O
k	long
=	O
m	long
;	O
l	long
=	O
(	O
53	int
*	O
l	long
+	O
1	int
)	O
%	O
169	int
;	O
t	long
>>=	O
1	int
;	O
if	O
(	O
(	O
l	long
*	O
m	int
)	O
%	O
64	int
>=	O
32	int
)	O
sum	long
+=	O
t	int
;	O
}	O
state	pointer
->	O
u	array
[	O
a	int
]	O
=	O
sum	long
;	O
}	O
state	pointer
->	O
i	int
=	O
96	int
;	O
state	pointer
->	O
j	long
=	O
32	int
;	O
state	pointer
->	O
carry	long
=	O
362436	int
;	O
}	O
static	O
const	O
gsl_rng_type	struct
ranmar_type	struct
=	O
{	O
"ranmar"	pointer
,	O
0x00ffffffUL	int
,	O
0	int
,	O
sizeof	O
(	O
ranmar_state_t	struct
)	O
,	O
&	O
ranmar_set	function
,	O
&	O
ranmar_get	function
,	O
&	O
ranmar_get_double	function
}	O
;	O
const	O
gsl_rng_type	struct
*	O
gsl_rng_ranmar	pointer
=	O
&	O
ranmar_type	struct
;	O
gsl_rng	struct
*	O
gsl_rng_alloc	function
(	O
const	O
gsl_rng_type	struct
*	O
T	pointer
)	O
{	O
gsl_rng	struct
*	O
r	pointer
=	O
(	O
gsl_rng	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_rng	pointer
)	O
)	O
;	O
if	O
(	O
r	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for rng struct"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
;	O
r	pointer
->	O
state	pointer
=	O
calloc	function
(	O
1	int
,	O
T	pointer
->	O
size	long
)	O
;	O
if	O
(	O
r	pointer
->	O
state	pointer
==	O
0	int
)	O
{	O
free	function
(	O
r	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for rng state"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
;	O
r	pointer
->	O
type	pointer
=	O
T	pointer
;	O
gsl_rng_set	function
(	O
r	pointer
,	O
gsl_rng_default_seed	long
)	O
;	O
return	O
r	int
;	O
}	O
int	O
gsl_rng_memcpy	function
(	O
gsl_rng	struct
*	O
dest	pointer
,	O
const	O
gsl_rng	struct
*	O
src	pointer
)	O
{	O
if	O
(	O
dest	pointer
->	O
type	pointer
!=	O
src	pointer
->	O
type	int
)	O
{	O
GSL_ERROR	O
(	O
"generators must be of the same type"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
memcpy	function
(	O
dest	pointer
->	O
state	pointer
,	O
src	pointer
->	O
state	pointer
,	O
src	pointer
->	O
type	pointer
->	O
size	long
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
gsl_rng	struct
*	O
gsl_rng_clone	function
(	O
const	O
gsl_rng	struct
*	O
q	pointer
)	O
{	O
gsl_rng	struct
*	O
r	pointer
=	O
(	O
gsl_rng	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_rng	pointer
)	O
)	O
;	O
if	O
(	O
r	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for rng struct"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
;	O
r	pointer
->	O
state	pointer
=	O
malloc	function
(	O
q	pointer
->	O
type	pointer
->	O
size	long
)	O
;	O
if	O
(	O
r	pointer
->	O
state	pointer
==	O
0	int
)	O
{	O
free	function
(	O
r	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for rng state"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
;	O
r	pointer
->	O
type	enum
=	O
q	pointer
->	O
type	enum
;	O
memcpy	function
(	O
r	pointer
->	O
state	pointer
,	O
q	pointer
->	O
state	pointer
,	O
q	pointer
->	O
type	pointer
->	O
size	long
)	O
;	O
return	O
r	int
;	O
}	O
void	O
gsl_rng_set	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
,	O
unsigned	O
long	O
int	O
seed	long
)	O
{	O
(	O
r	pointer
->	O
type	pointer
->	O
set	pointer
)	O
(	O
r	pointer
->	O
state	pointer
,	O
seed	long
)	O
;	O
}	O
unsigned	O
long	O
int	O
gsl_rng_max	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
)	O
{	O
return	O
r	pointer
->	O
type	pointer
->	O
max	int
;	O
}	O
unsigned	O
long	O
int	O
gsl_rng_min	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
)	O
{	O
return	O
r	pointer
->	O
type	pointer
->	O
min	pointer
;	O
}	O
const	O
char	O
*	O
gsl_rng_name	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
)	O
{	O
return	O
r	pointer
->	O
type	pointer
->	O
name	pointer
;	O
}	O
size_t	long
gsl_rng_size	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
)	O
{	O
return	O
r	pointer
->	O
type	pointer
->	O
size	long
;	O
}	O
void	O
*	O
gsl_rng_state	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
)	O
{	O
return	O
r	pointer
->	O
state	pointer
;	O
}	O
void	O
gsl_rng_print_state	function
(	O
const	O
gsl_rng	struct
*	O
r	pointer
)	O
{	O
size_t	long
i	long
;	O
unsigned	O
char	O
*	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
r	pointer
->	O
state	pointer
)	O
;	O
const	O
size_t	long
n	long
=	O
r	pointer
->	O
type	pointer
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
printf	function
(	O
"%.2x"	pointer
,	O
*	O
(	O
p	pointer
+	O
i	long
)	O
)	O
;	O
}	O
}	O
void	O
gsl_rng_free	function
(	O
gsl_rng	struct
*	O
r	pointer
)	O
{	O
RETURN_IF_NULL	O
(	O
r	pointer
)	O
;	O
free	function
(	O
r	pointer
->	O
state	pointer
)	O
;	O
free	function
(	O
r	pointer
)	O
;	O
}	O
const	O
gsl_rng_type	struct
*	O
gsl_rng_generator_types	array
[	O
N	int
]	O
;	O
const	O
gsl_rng_type	struct
*	O
*	O
gsl_rng_types_setup	function
(	O
void	O
)	O
{	O
int	O
i	int
=	O
0	int
;	O
ADD	function
(	O
gsl_rng_borosh13	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_cmrg	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_coveyou	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_fishman18	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_fishman20	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_fishman2x	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_gfsr4	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_knuthran	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_knuthran2	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_knuthran2002	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_lecuyer21	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_minstd	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_mrg	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_mt19937	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_mt19937_1999	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_mt19937_1998	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_r250	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ran0	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ran1	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ran2	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ran3	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_rand	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_rand48	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random128_bsd	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random128_glibc2	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random128_libc5	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random256_bsd	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random256_glibc2	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random256_libc5	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random32_bsd	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random32_glibc2	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random32_libc5	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random64_bsd	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random64_glibc2	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random64_libc5	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random8_bsd	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random8_glibc2	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random8_libc5	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random_bsd	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random_glibc2	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_random_libc5	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_randu	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ranf	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ranlux	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ranlux389	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ranlxd1	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ranlxd2	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ranlxs0	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ranlxs1	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ranlxs2	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_ranmar	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_slatec	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_taus	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_taus2	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_taus113	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_transputer	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_tt800	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_uni	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_uni32	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_vax	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_waterman14	pointer
)	O
;	O
ADD	function
(	O
gsl_rng_zuf	pointer
)	O
;	O
ADD	function
(	O
0	int
)	O
;	O
return	O
gsl_rng_generator_types	pointer
;	O
}	O
gsl_rstat_workspace	struct
*	O
gsl_rstat_alloc	function
(	O
void	O
)	O
{	O
gsl_rstat_workspace	struct
*	O
w	pointer
;	O
w	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
gsl_rstat_workspace	struct
)	O
)	O
;	O
if	O
(	O
w	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for workspace"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	pointer
->	O
median_workspace_p	pointer
=	O
gsl_rstat_quantile_alloc	function
(	O
0.5	int
)	O
;	O
if	O
(	O
w	pointer
->	O
median_workspace_p	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for median workspace"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
gsl_rstat_reset	function
(	O
w	pointer
)	O
;	O
return	O
w	pointer
;	O
}	O
void	O
gsl_rstat_free	function
(	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
if	O
(	O
w	pointer
->	O
median_workspace_p	pointer
)	O
gsl_rstat_quantile_free	function
(	O
w	pointer
->	O
median_workspace_p	pointer
)	O
;	O
free	function
(	O
w	pointer
)	O
;	O
}	O
size_t	long
gsl_rstat_n	function
(	O
const	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
return	O
w	pointer
->	O
n	int
;	O
}	O
int	O
gsl_rstat_add	function
(	O
const	O
double	O
x	double
,	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
double	O
delta	double
=	O
x	double
-	O
w	pointer
->	O
mean	double
;	O
double	O
delta_n	int
,	O
delta_nsq	pointer
,	O
term1	pointer
,	O
n	int
;	O
if	O
(	O
w	pointer
->	O
n	int
==	O
0	int
)	O
{	O
w	pointer
->	O
min	double
=	O
x	double
;	O
w	pointer
->	O
max	double
=	O
x	double
;	O
}	O
else	O
{	O
if	O
(	O
x	double
<	O
w	pointer
->	O
min	double
)	O
w	pointer
->	O
min	double
=	O
x	double
;	O
if	O
(	O
x	double
>	O
w	pointer
->	O
max	double
)	O
w	pointer
->	O
max	double
=	O
x	double
;	O
}	O
n	int
=	O
(	O
double	O
)	O
++	O
(	O
w	pointer
->	O
n	int
)	O
;	O
delta_n	int
=	O
delta	int
/	O
n	int
;	O
delta_nsq	int
=	O
delta_n	struct
*	O
delta_n	int
;	O
term1	double
=	O
delta	double
*	O
delta_n	double
*	O
(	O
n	int
-	O
1.0	int
)	O
;	O
w	pointer
->	O
mean	double
+=	O
delta_n	double
;	O
w	pointer
->	O
M4	double
+=	O
term1	double
*	O
delta_nsq	pointer
*	O
(	O
n	int
*	O
n	int
-	O
3.0	int
*	O
n	int
+	O
3.0	int
)	O
+	O
6.0	int
*	O
delta_nsq	double
*	O
w	pointer
->	O
M2	double
-	O
4.0	int
*	O
delta_n	double
*	O
w	pointer
->	O
M3	pointer
;	O
w	pointer
->	O
M3	double
+=	O
term1	double
*	O
delta_n	double
*	O
(	O
n	int
-	O
2.0	int
)	O
-	O
3.0	int
*	O
delta_n	double
*	O
w	pointer
->	O
M2	double
;	O
w	pointer
->	O
M2	double
+=	O
term1	double
;	O
gsl_rstat_quantile_add	function
(	O
x	double
,	O
w	pointer
->	O
median_workspace_p	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
double	O
gsl_rstat_min	function
(	O
const	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
return	O
w	pointer
->	O
min	double
;	O
}	O
double	O
gsl_rstat_max	function
(	O
const	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
return	O
w	pointer
->	O
max	double
;	O
}	O
double	O
gsl_rstat_mean	function
(	O
const	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
return	O
w	pointer
->	O
mean	double
;	O
}	O
double	O
gsl_rstat_variance	function
(	O
const	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
if	O
(	O
w	pointer
->	O
n	int
>	O
1	int
)	O
{	O
double	O
n	int
=	O
(	O
double	O
)	O
w	pointer
->	O
n	int
;	O
return	O
(	O
w	pointer
->	O
M2	double
/	O
(	O
n	int
-	O
1.0	int
)	O
)	O
;	O
}	O
else	O
return	O
0.0	int
;	O
}	O
double	O
gsl_rstat_sd	function
(	O
const	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
double	O
var	double
=	O
gsl_rstat_variance	function
(	O
w	pointer
)	O
;	O
return	O
(	O
sqrt	function
(	O
var	double
)	O
)	O
;	O
}	O
double	O
gsl_rstat_rms	function
(	O
const	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
double	O
rms	double
=	O
0.0	int
;	O
if	O
(	O
w	pointer
->	O
n	int
>	O
0	int
)	O
{	O
double	O
mean	double
=	O
gsl_rstat_mean	function
(	O
w	pointer
)	O
;	O
double	O
sigma	double
=	O
gsl_rstat_sd	function
(	O
w	pointer
)	O
;	O
double	O
n	int
=	O
(	O
double	O
)	O
w	pointer
->	O
n	int
;	O
double	O
a	double
=	O
sqrt	function
(	O
(	O
n	int
-	O
1.0	int
)	O
/	O
n	int
)	O
;	O
rms	double
=	O
gsl_hypot	function
(	O
mean	double
,	O
a	double
*	O
sigma	double
)	O
;	O
}	O
return	O
rms	int
;	O
}	O
double	O
gsl_rstat_sd_mean	function
(	O
const	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
if	O
(	O
w	pointer
->	O
n	int
>	O
0	int
)	O
{	O
double	O
sd	int
=	O
gsl_rstat_sd	function
(	O
w	double
)	O
;	O
return	O
(	O
sd	int
/	O
sqrt	function
(	O
(	O
double	O
)	O
w	array
->	O
n	int
)	O
)	O
;	O
}	O
else	O
return	O
0.0	int
;	O
}	O
double	O
gsl_rstat_median	function
(	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
return	O
gsl_rstat_quantile_get	function
(	O
w	pointer
->	O
median_workspace_p	pointer
)	O
;	O
}	O
double	O
gsl_rstat_skew	function
(	O
const	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
if	O
(	O
w	pointer
->	O
n	int
>	O
0	int
)	O
{	O
double	O
n	int
=	O
(	O
double	O
)	O
w	pointer
->	O
n	int
;	O
double	O
fac	double
=	O
pow	function
(	O
n	int
-	O
1.0	int
,	O
1.5	pointer
)	O
/	O
n	int
;	O
return	O
(	O
(	O
fac	double
*	O
w	pointer
->	O
M3	double
)	O
/	O
pow	function
(	O
w	pointer
->	O
M2	double
,	O
1.5	double
)	O
)	O
;	O
}	O
else	O
return	O
0.0	int
;	O
}	O
double	O
gsl_rstat_kurtosis	function
(	O
const	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
if	O
(	O
w	pointer
->	O
n	int
>	O
0	int
)	O
{	O
double	O
n	int
=	O
(	O
double	O
)	O
w	pointer
->	O
n	int
;	O
double	O
fac	double
=	O
(	O
(	O
n	int
-	O
1.0	int
)	O
/	O
n	int
)	O
*	O
(	O
n	int
-	O
1.0	int
)	O
;	O
return	O
(	O
(	O
fac	double
*	O
w	pointer
->	O
M4	double
)	O
/	O
(	O
w	pointer
->	O
M2	double
*	O
w	pointer
->	O
M2	double
)	O
-	O
3.0	int
)	O
;	O
}	O
else	O
return	O
0.0	int
;	O
}	O
int	O
gsl_rstat_reset	function
(	O
gsl_rstat_workspace	struct
*	O
w	pointer
)	O
{	O
int	O
status	int
;	O
w	pointer
->	O
min	double
=	O
0.0	int
;	O
w	pointer
->	O
max	double
=	O
0.0	int
;	O
w	pointer
->	O
mean	double
=	O
0.0	int
;	O
w	pointer
->	O
M2	double
=	O
0.0	int
;	O
w	pointer
->	O
M3	double
=	O
0.0	int
;	O
w	pointer
->	O
M4	double
=	O
0.0	int
;	O
w	pointer
->	O
n	int
=	O
0	int
;	O
status	int
=	O
gsl_rstat_quantile_reset	function
(	O
w	pointer
->	O
median_workspace_p	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
inline	O
void	O
downheap	function
(	O
size_t	long
*	O
p	pointer
,	O
const	O
void	O
*	O
data	pointer
,	O
const	O
size_t	long
size	long
,	O
const	O
size_t	long
N	long
,	O
size_t	long
k	long
,	O
gsl_comparison_fn_t	pointer
compare	pointer
)	O
;	O
static	O
inline	O
void	O
downheap	function
(	O
size_t	long
*	O
p	pointer
,	O
const	O
void	O
*	O
data	pointer
,	O
const	O
size_t	long
size	long
,	O
const	O
size_t	long
N	long
,	O
size_t	long
k	long
,	O
gsl_comparison_fn_t	pointer
compare	pointer
)	O
{	O
const	O
size_t	long
pki	long
=	O
p	pointer
[	O
k	long
]	O
;	O
while	O
(	O
k	long
<=	O
N	long
/	O
2	int
)	O
{	O
size_t	long
j	long
=	O
2	int
*	O
k	long
;	O
if	O
(	O
j	long
<	O
N	int
&&	O
CMP	O
(	O
data	pointer
,	O
size	long
,	O
p	pointer
[	O
j	long
]	O
,	O
p	pointer
[	O
j	long
+	O
1	int
]	O
)	O
<	O
0	int
)	O
{	O
j	long
++	O
;	O
}	O
if	O
(	O
CMP	O
(	O
data	pointer
,	O
size	long
,	O
pki	pointer
,	O
p	pointer
[	O
j	long
]	O
)	O
>=	O
0	int
)	O
{	O
break	O
;	O
}	O
p	pointer
[	O
k	long
]	O
=	O
p	pointer
[	O
j	long
]	O
;	O
k	long
=	O
j	long
;	O
}	O
p	pointer
[	O
k	long
]	O
=	O
pki	pointer
;	O
}	O
int	O
gsl_heapsort_index	function
(	O
size_t	long
*	O
p	pointer
,	O
const	O
void	O
*	O
data	pointer
,	O
size_t	long
count	long
,	O
size_t	long
size	long
,	O
gsl_comparison_fn_t	pointer
compare	pointer
)	O
{	O
size_t	long
i	long
,	O
k	long
,	O
N	int
;	O
if	O
(	O
count	long
==	O
0	int
)	O
{	O
return	O
GSL_SUCCESS	int
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
count	long
;	O
i	long
++	O
)	O
{	O
p	pointer
[	O
i	long
]	O
=	O
i	long
;	O
}	O
N	long
=	O
count	long
-	O
1	int
;	O
k	long
=	O
N	int
/	O
2	int
;	O
k	long
++	O
;	O
do	O
{	O
k	long
--	O
;	O
downheap	function
(	O
p	pointer
,	O
data	pointer
,	O
size	long
,	O
N	long
,	O
k	long
,	O
compare	pointer
)	O
;	O
}	O
while	O
(	O
k	long
>	O
0	int
)	O
;	O
while	O
(	O
N	long
>	O
0	int
)	O
{	O
size_t	long
tmp	long
=	O
p	pointer
[	O
0	int
]	O
;	O
p	pointer
[	O
0	int
]	O
=	O
p	pointer
[	O
N	int
]	O
;	O
p	pointer
[	O
N	int
]	O
=	O
tmp	pointer
;	O
N	long
--	O
;	O
downheap	function
(	O
p	pointer
,	O
data	pointer
,	O
size	long
,	O
N	int
,	O
0	int
,	O
compare	pointer
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_bessel_Inu_scaled_e	function
(	O
double	O
nu	double
,	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
x	double
<	O
0.0	int
||	O
nu	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
*	O
x	double
<	O
10.0	int
*	O
(	O
nu	double
+	O
1.0	int
)	O
)	O
{	O
gsl_sf_result	struct
b	pointer
;	O
double	O
ex	double
=	O
exp	function
(	O
-	O
x	double
)	O
;	O
int	O
stat	int
=	O
gsl_sf_bessel_IJ_taylor_e	function
(	O
nu	double
,	O
x	double
,	O
1	int
,	O
100	int
,	O
GSL_DBL_EPSILON	int
,	O
&	O
b	pointer
)	O
;	O
result	pointer
->	O
val	double
=	O
b	double
.	O
val	double
*	O
ex	double
;	O
result	pointer
->	O
err	double
=	O
b	double
.	O
err	double
*	O
ex	pointer
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat	double
;	O
}	O
else	O
if	O
(	O
0.5	int
/	O
(	O
nu	double
*	O
nu	double
+	O
x	double
*	O
x	double
)	O
<	O
GSL_ROOT3_DBL_EPSILON	int
)	O
{	O
return	O
gsl_sf_bessel_Inu_scaled_asymp_unif_e	function
(	O
nu	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
{	O
int	O
N	int
=	O
(	O
int	O
)	O
(	O
nu	double
+	O
0.5	int
)	O
;	O
double	O
mu	double
=	O
nu	double
-	O
N	int
;	O
double	O
K_mu	double
,	O
K_mup1	double
,	O
Kp_mu	double
;	O
double	O
K_nu	pointer
,	O
K_nup1	pointer
,	O
K_num1	double
;	O
double	O
I_nu_ratio	double
;	O
int	O
stat_Irat	int
;	O
int	O
stat_Kmu	int
;	O
int	O
n	int
;	O
if	O
(	O
x	double
<	O
2.0	int
)	O
{	O
stat_Kmu	int
=	O
gsl_sf_bessel_K_scaled_temme	function
(	O
mu	double
,	O
x	double
,	O
&	O
K_mu	double
,	O
&	O
K_mup1	double
,	O
&	O
Kp_mu	double
)	O
;	O
}	O
else	O
{	O
stat_Kmu	double
=	O
gsl_sf_bessel_K_scaled_steed_temme_CF2	function
(	O
mu	double
,	O
x	double
,	O
&	O
K_mu	double
,	O
&	O
K_mup1	double
,	O
&	O
Kp_mu	double
)	O
;	O
}	O
K_nu	pointer
=	O
K_mu	double
;	O
K_nup1	pointer
=	O
K_mup1	double
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
N	int
;	O
n	int
++	O
)	O
{	O
K_num1	double
=	O
K_nu	pointer
;	O
K_nu	pointer
=	O
K_nup1	pointer
;	O
K_nup1	pointer
=	O
2.0	int
*	O
(	O
mu	double
+	O
n	int
+	O
1	int
)	O
/	O
x	double
*	O
K_nu	pointer
+	O
K_num1	double
;	O
}	O
stat_Irat	double
=	O
gsl_sf_bessel_I_CF1_ser	function
(	O
nu	double
,	O
x	double
,	O
&	O
I_nu_ratio	pointer
)	O
;	O
result	pointer
->	O
val	double
=	O
1.0	int
/	O
(	O
x	double
*	O
(	O
K_nup1	pointer
+	O
I_nu_ratio	struct
*	O
K_nu	pointer
)	O
)	O
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
0.5	int
*	O
N	int
+	O
2.0	int
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_Kmu	int
,	O
stat_Irat	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_bessel_Inu_e	function
(	O
double	O
nu	double
,	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
gsl_sf_result	struct
b	pointer
;	O
int	O
stat_I	int
=	O
gsl_sf_bessel_Inu_scaled_e	function
(	O
nu	double
,	O
x	double
,	O
&	O
b	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	function
(	O
x	double
,	O
fabs	function
(	O
x	double
*	O
GSL_DBL_EPSILON	int
)	O
,	O
b	double
.	O
val	double
,	O
b	double
.	O
err	double
,	O
result	pointer
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_I	int
)	O
;	O
}	O
double	O
gsl_sf_bessel_Inu_scaled	function
(	O
double	O
nu	double
,	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_bessel_Inu_scaled_e	function
(	O
nu	double
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_bessel_Inu	function
(	O
double	O
nu	double
,	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_bessel_Inu_e	function
(	O
nu	double
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
static	O
int	O
R_norm	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
l	int
,	O
const	O
double	O
Z	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
double	O
A	pointer
=	O
2.0	int
*	O
Z	double
/	O
n	int
;	O
double	O
pre	double
=	O
sqrt	function
(	O
A	double
*	O
A	double
*	O
A	double
/	O
(	O
2.0	int
*	O
n	int
)	O
)	O
;	O
gsl_sf_result	struct
ln_a	struct
,	O
ln_b	struct
;	O
gsl_sf_result	struct
ex	pointer
;	O
int	O
stat_a	int
=	O
gsl_sf_lnfact_e	function
(	O
n	int
+	O
l	int
,	O
&	O
ln_a	int
)	O
;	O
int	O
stat_b	int
=	O
gsl_sf_lnfact_e	function
(	O
n	int
-	O
l	int
-	O
1	int
,	O
&	O
ln_b	int
)	O
;	O
double	O
diff_val	double
=	O
0.5	int
*	O
(	O
ln_b	struct
.	O
val	double
-	O
ln_a	struct
.	O
val	double
)	O
;	O
double	O
diff_err	double
=	O
0.5	int
*	O
(	O
ln_b	struct
.	O
err	double
+	O
ln_a	struct
.	O
err	double
)	O
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
diff_val	pointer
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_err_e	function
(	O
diff_val	pointer
,	O
diff_err	pointer
,	O
&	O
ex	double
)	O
;	O
result	pointer
->	O
val	double
=	O
pre	double
*	O
ex	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
pre	double
*	O
ex	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_a	int
,	O
stat_b	int
)	O
;	O
}	O
int	O
gsl_sf_hydrogenicR_1_e	function
(	O
const	O
double	O
Z	double
,	O
const	O
double	O
r	pointer
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
Z	double
>	O
0.0	int
&&	O
r	double
>=	O
0.0	int
)	O
{	O
double	O
A	double
=	O
2.0	int
*	O
Z	double
;	O
double	O
norm	double
=	O
A	double
*	O
sqrt	function
(	O
Z	double
)	O
;	O
double	O
ea	double
=	O
exp	function
(	O
-	O
Z	double
*	O
r	double
)	O
;	O
result	pointer
->	O
val	double
=	O
norm	double
*	O
ea	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
*	O
fabs	function
(	O
Z	struct
*	O
r	pointer
)	O
;	O
CHECK_UNDERFLOW	function
(	O
result	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
}	O
int	O
gsl_sf_hydrogenicR_e	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
l	int
,	O
const	O
double	O
Z	double
,	O
const	O
double	O
r	int
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
n	int
<	O
1	int
||	O
l	int
>	O
n	int
-	O
1	int
||	O
Z	double
<=	O
0.0	int
||	O
r	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
{	O
double	O
A	double
=	O
2.0	int
*	O
Z	double
/	O
n	int
;	O
gsl_sf_result	struct
norm	pointer
;	O
int	O
stat_norm	int
=	O
R_norm	function
(	O
n	int
,	O
l	double
,	O
Z	double
,	O
&	O
norm	pointer
)	O
;	O
double	O
rho	double
=	O
A	double
*	O
r	double
;	O
double	O
ea	double
=	O
exp	function
(	O
-	O
0.5	int
*	O
rho	double
)	O
;	O
double	O
pp	double
=	O
gsl_sf_pow_int	function
(	O
rho	double
,	O
l	long
)	O
;	O
gsl_sf_result	struct
lag	struct
;	O
int	O
stat_lag	int
=	O
gsl_sf_laguerre_n_e	function
(	O
n	int
-	O
l	long
-	O
1	int
,	O
2	int
*	O
l	int
+	O
1	int
,	O
rho	double
,	O
&	O
lag	int
)	O
;	O
double	O
W_val	double
=	O
norm	struct
.	O
val	double
*	O
ea	struct
*	O
pp	pointer
;	O
double	O
W_err	double
=	O
norm	struct
.	O
err	double
*	O
ea	struct
*	O
pp	pointer
;	O
W_err	double
+=	O
norm	pointer
.	O
val	double
*	O
(	O
(	O
0.5	int
*	O
rho	double
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
)	O
*	O
ea	struct
*	O
pp	pointer
;	O
W_err	double
+=	O
norm	pointer
.	O
val	double
*	O
ea	double
*	O
(	O
(	O
l	double
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
)	O
*	O
pp	pointer
;	O
result	pointer
->	O
val	double
=	O
W_val	double
*	O
lag	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
W_val	double
*	O
lag	struct
.	O
err	double
+	O
W_err	int
*	O
fabs	function
(	O
lag	struct
.	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
if	O
(	O
(	O
l	int
==	O
0	int
||	O
(	O
r	double
>	O
0	int
&&	O
l	long
>	O
0	int
)	O
)	O
&&	O
lag	struct
.	O
val	double
!=	O
0.0	int
&&	O
stat_lag	int
==	O
GSL_SUCCESS	int
&&	O
stat_norm	int
==	O
GSL_SUCCESS	int
)	O
{	O
CHECK_UNDERFLOW	function
(	O
result	pointer
)	O
;	O
}	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_lag	int
,	O
stat_norm	int
)	O
;	O
}	O
}	O
double	O
gsl_sf_hydrogenicR_1	function
(	O
const	O
double	O
Z	double
,	O
const	O
double	O
r	pointer
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hydrogenicR_1_e	function
(	O
Z	double
,	O
r	pointer
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_hydrogenicR	function
(	O
const	O
int	O
n	int
,	O
const	O
int	O
l	int
,	O
const	O
double	O
Z	double
,	O
const	O
double	O
r	int
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_hydrogenicR_e	function
(	O
n	int
,	O
l	int
,	O
Z	double
,	O
r	pointer
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
int	O
gsl_sf_multiply_e	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
y	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
double	O
ax	double
=	O
fabs	function
(	O
x	double
)	O
;	O
const	O
double	O
ay	double
=	O
fabs	function
(	O
y	double
)	O
;	O
if	O
(	O
x	double
==	O
0.0	int
||	O
y	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
(	O
ax	double
<=	O
1.0	int
&&	O
ay	double
>=	O
1.0	int
)	O
||	O
(	O
ay	double
<=	O
1.0	int
&&	O
ax	double
>=	O
1.0	int
)	O
)	O
{	O
result	pointer
->	O
val	double
=	O
x	double
*	O
y	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
f	double
=	O
1.0	int
-	O
2.0	int
*	O
GSL_DBL_EPSILON	int
;	O
const	O
double	O
min	double
=	O
GSL_MIN_DBL	function
(	O
fabs	function
(	O
x	double
)	O
,	O
fabs	function
(	O
y	double
)	O
)	O
;	O
const	O
double	O
max	double
=	O
GSL_MAX_DBL	function
(	O
fabs	function
(	O
x	double
)	O
,	O
fabs	function
(	O
y	double
)	O
)	O
;	O
if	O
(	O
max	double
<	O
0.9	int
*	O
GSL_SQRT_DBL_MAX	int
||	O
min	double
<	O
(	O
f	pointer
*	O
DBL_MAX	O
)	O
/	O
max	double
)	O
{	O
result	pointer
->	O
val	double
=	O
GSL_COERCE_DBL	O
(	O
x	double
*	O
y	double
)	O
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
CHECK_UNDERFLOW	function
(	O
result	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
OVERFLOW_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
}	O
}	O
int	O
gsl_sf_multiply_err_e	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
dx	pointer
,	O
const	O
double	O
y	double
,	O
const	O
double	O
dy	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
int	O
status	int
=	O
gsl_sf_multiply_e	function
(	O
x	double
,	O
y	double
,	O
result	pointer
)	O
;	O
result	pointer
->	O
err	double
+=	O
fabs	function
(	O
dx	pointer
*	O
y	double
)	O
+	O
fabs	function
(	O
dy	double
*	O
x	double
)	O
;	O
return	O
status	int
;	O
}	O
double	O
gsl_sf_multiply	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
y	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_multiply_e	function
(	O
x	double
,	O
y	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
static	O
int	O
halley_iteration	function
(	O
double	O
x	double
,	O
double	O
w_initial	int
,	O
unsigned	O
int	O
max_iters	int
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
double	O
w	pointer
=	O
w_initial	int
;	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
max_iters	int
;	O
i	int
++	O
)	O
{	O
double	O
tol	double
;	O
const	O
double	O
e	int
=	O
exp	function
(	O
w	double
)	O
;	O
const	O
double	O
p	int
=	O
w	double
+	O
1.0	int
;	O
double	O
t	double
=	O
w	double
*	O
e	int
-	O
x	double
;	O
if	O
(	O
w	int
>	O
0	int
)	O
{	O
t	int
=	O
(	O
t	double
/	O
p	int
)	O
/	O
e	int
;	O
}	O
else	O
{	O
t	double
/=	O
e	int
*	O
p	pointer
-	O
0.5	int
*	O
(	O
p	double
+	O
1.0	int
)	O
*	O
t	double
/	O
p	int
;	O
}	O
;	O
w	int
-=	O
t	int
;	O
tol	double
=	O
10	int
*	O
GSL_DBL_EPSILON	int
*	O
GSL_MAX_DBL	function
(	O
fabs	function
(	O
w	double
)	O
,	O
1.0	int
/	O
(	O
fabs	function
(	O
p	double
)	O
*	O
e	double
)	O
)	O
;	O
if	O
(	O
fabs	function
(	O
t	double
)	O
<	O
tol	double
)	O
{	O
result	pointer
->	O
val	double
=	O
w	int
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
tol	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
result	pointer
->	O
val	double
=	O
w	int
;	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
w	int
)	O
;	O
return	O
GSL_EMAXITER	int
;	O
}	O
static	O
double	O
series_eval	function
(	O
double	O
r	double
)	O
{	O
static	O
const	O
double	O
c	array
[	O
12	int
]	O
=	O
{	O
-	O
1.0	int
,	O
2.331643981597124203363536062168	int
,	O
-	O
1.812187885639363490240191647568	int
,	O
1.936631114492359755363277457668	int
,	O
-	O
2.353551201881614516821543561516	int
,	O
3.066858901050631912893148922704	int
,	O
-	O
4.175335600258177138854984177460	int
,	O
5.858023729874774148815053846119	int
,	O
-	O
8.401032217523977370984161688514	int
,	O
12.250753501314460424	int
,	O
-	O
18.100697012472442755	int
,	O
27.029044799010561650	int
}	O
;	O
const	O
double	O
t_8	int
=	O
c	array
[	O
8	int
]	O
+	O
r	int
*	O
(	O
c	array
[	O
9	int
]	O
+	O
r	double
*	O
(	O
c	array
[	O
10	int
]	O
+	O
r	double
*	O
c	array
[	O
11	int
]	O
)	O
)	O
;	O
const	O
double	O
t_5	double
=	O
c	array
[	O
5	int
]	O
+	O
r	double
*	O
(	O
c	array
[	O
6	int
]	O
+	O
r	double
*	O
(	O
c	array
[	O
7	int
]	O
+	O
r	double
*	O
t_8	pointer
)	O
)	O
;	O
const	O
double	O
t_1	int
=	O
c	array
[	O
1	int
]	O
+	O
r	double
*	O
(	O
c	array
[	O
2	int
]	O
+	O
r	double
*	O
(	O
c	array
[	O
3	int
]	O
+	O
r	double
*	O
(	O
c	array
[	O
4	int
]	O
+	O
r	double
*	O
t_5	pointer
)	O
)	O
)	O
;	O
return	O
c	pointer
[	O
0	int
]	O
+	O
r	double
*	O
t_1	pointer
;	O
}	O
int	O
gsl_sf_lambert_W0_e	function
(	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
double	O
one_over_E	double
=	O
1.0	int
/	O
M_E	double
;	O
const	O
double	O
q	double
=	O
x	double
+	O
one_over_E	double
;	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
q	double
<	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
-	O
1.0	int
;	O
result	pointer
->	O
err	double
=	O
sqrt	function
(	O
-	O
q	double
)	O
;	O
return	O
GSL_EDOM	int
;	O
}	O
else	O
if	O
(	O
q	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
-	O
1.0	int
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
q	double
<	O
1.0e-03	int
)	O
{	O
const	O
double	O
r	double
=	O
sqrt	function
(	O
q	double
)	O
;	O
result	pointer
->	O
val	double
=	O
series_eval	function
(	O
r	double
)	O
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
static	O
const	O
unsigned	O
int	O
MAX_ITERS	int
=	O
10	int
;	O
double	O
w	double
;	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
const	O
double	O
p	int
=	O
sqrt	function
(	O
2.0	int
*	O
M_E	double
*	O
q	double
)	O
;	O
w	array
=	O
-	O
1.0	int
+	O
p	double
*	O
(	O
1.0	int
+	O
p	double
*	O
(	O
-	O
1.0	int
/	O
3.0	int
+	O
p	int
*	O
11.0	int
/	O
72.0	int
)	O
)	O
;	O
}	O
else	O
{	O
w	double
=	O
log	function
(	O
x	double
)	O
;	O
if	O
(	O
x	double
>	O
3.0	int
)	O
w	double
-=	O
log	function
(	O
w	double
)	O
;	O
}	O
return	O
halley_iteration	function
(	O
x	double
,	O
w	pointer
,	O
MAX_ITERS	pointer
,	O
result	pointer
)	O
;	O
}	O
}	O
int	O
gsl_sf_lambert_Wm1_e	function
(	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
x	double
>	O
0.0	int
)	O
{	O
return	O
gsl_sf_lambert_W0_e	function
(	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
static	O
const	O
unsigned	O
int	O
MAX_ITERS	int
=	O
32	int
;	O
const	O
double	O
one_over_E	double
=	O
1.0	int
/	O
M_E	double
;	O
const	O
double	O
q	double
=	O
x	double
+	O
one_over_E	double
;	O
double	O
w	double
;	O
if	O
(	O
q	double
<	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
-	O
1.0	int
;	O
result	pointer
->	O
err	double
=	O
sqrt	function
(	O
-	O
q	double
)	O
;	O
return	O
GSL_EDOM	int
;	O
}	O
if	O
(	O
x	double
<	O
-	O
1.0e-6	int
)	O
{	O
const	O
double	O
r	double
=	O
-	O
sqrt	function
(	O
q	double
)	O
;	O
w	int
=	O
series_eval	function
(	O
r	pointer
)	O
;	O
if	O
(	O
q	double
<	O
3.0e-3	double
)	O
{	O
result	pointer
->	O
val	double
=	O
w	int
;	O
result	pointer
->	O
err	double
=	O
5.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
w	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
else	O
{	O
const	O
double	O
L_1	double
=	O
log	function
(	O
-	O
x	double
)	O
;	O
const	O
double	O
L_2	double
=	O
log	function
(	O
-	O
L_1	int
)	O
;	O
w	int
=	O
L_1	double
-	O
L_2	double
+	O
L_2	double
/	O
L_1	int
;	O
}	O
return	O
halley_iteration	function
(	O
x	double
,	O
w	pointer
,	O
MAX_ITERS	pointer
,	O
result	pointer
)	O
;	O
}	O
}	O
double	O
gsl_sf_lambert_W0	function
(	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_lambert_W0_e	function
(	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_lambert_Wm1	function
(	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_lambert_Wm1_e	function
(	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
static	O
void	O
legendre_sqrts	function
(	O
const	O
size_t	long
lmax	long
,	O
double	O
*	O
array	pointer
)	O
;	O
size_t	long
gsl_sf_legendre_nlm	function
(	O
const	O
size_t	long
lmax	long
)	O
{	O
return	O
(	O
(	O
lmax	long
+	O
1	int
)	O
*	O
(	O
lmax	long
+	O
2	int
)	O
/	O
2	int
)	O
;	O
}	O
size_t	long
gsl_sf_legendre_array_n	function
(	O
const	O
size_t	long
lmax	long
)	O
{	O
size_t	long
nlm	long
=	O
gsl_sf_legendre_nlm	function
(	O
lmax	pointer
)	O
;	O
size_t	long
nsqrt	long
=	O
2	int
*	O
lmax	pointer
+	O
2	int
;	O
return	O
(	O
nlm	pointer
+	O
nsqrt	double
)	O
;	O
}	O
size_t	long
gsl_sf_legendre_array_index	function
(	O
const	O
size_t	long
l	long
,	O
const	O
size_t	long
m	int
)	O
{	O
return	O
(	O
l	long
*	O
(	O
l	long
+	O
1	int
)	O
/	O
2	int
+	O
m	long
)	O
;	O
}	O
static	O
void	O
legendre_sqrts	function
(	O
const	O
size_t	long
lmax	long
,	O
double	O
*	O
array	pointer
)	O
{	O
size_t	long
l	long
;	O
for	O
(	O
l	long
=	O
0	int
;	O
l	long
<=	O
2	int
*	O
lmax	long
+	O
1	int
;	O
++	O
l	long
)	O
array	pointer
[	O
l	long
]	O
=	O
sqrt	function
(	O
(	O
double	O
)	O
l	long
)	O
;	O
}	O
gsl_sf_mathieu_workspace	struct
*	O
gsl_sf_mathieu_alloc	function
(	O
const	O
size_t	long
nn	long
,	O
const	O
double	O
qq	double
)	O
{	O
gsl_sf_mathieu_workspace	struct
*	O
workspace	pointer
;	O
unsigned	O
int	O
even_order	int
=	O
nn	long
/	O
2	int
+	O
1	int
,	O
odd_order	long
=	O
(	O
nn	long
+	O
1	int
)	O
/	O
2	int
,	O
extra_values	int
;	O
extra_values	double
=	O
(	O
int	O
)	O
(	O
2.1	struct
*	O
pow	function
(	O
fabs	function
(	O
qq	double
)	O
,	O
0.37	pointer
)	O
)	O
+	O
9	int
;	O
extra_values	long
+=	O
20	int
;	O
if	O
(	O
nn	long
+	O
1	int
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"matrix dimension must be positive integer"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
workspace	pointer
=	O
(	O
gsl_sf_mathieu_workspace	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_sf_mathieu_workspace	struct
)	O
)	O
;	O
if	O
(	O
workspace	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for workspace"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
even_order	double
+=	O
extra_values	double
;	O
odd_order	double
+=	O
extra_values	double
;	O
workspace	pointer
->	O
size	long
=	O
nn	long
;	O
workspace	pointer
->	O
even_order	long
=	O
even_order	long
;	O
workspace	pointer
->	O
odd_order	long
=	O
odd_order	long
;	O
workspace	pointer
->	O
extra_values	long
=	O
extra_values	long
;	O
workspace	pointer
->	O
aa	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
(	O
nn	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
workspace	pointer
->	O
aa	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
workspace	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"Error allocating memory for characteristic a values"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
workspace	pointer
->	O
bb	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
(	O
nn	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
workspace	pointer
->	O
bb	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
workspace	pointer
->	O
aa	array
)	O
;	O
free	function
(	O
workspace	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"Error allocating memory for characteristic b values"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
workspace	pointer
->	O
dd	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
even_order	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
workspace	pointer
->	O
dd	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
workspace	pointer
->	O
aa	array
)	O
;	O
free	function
(	O
workspace	pointer
->	O
bb	int
)	O
;	O
free	function
(	O
workspace	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for diagonal"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
workspace	pointer
->	O
ee	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
even_order	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
workspace	pointer
->	O
ee	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
workspace	pointer
->	O
dd	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
aa	array
)	O
;	O
free	function
(	O
workspace	pointer
->	O
bb	int
)	O
;	O
free	function
(	O
workspace	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for diagonal"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
workspace	pointer
->	O
tt	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
3	int
*	O
even_order	double
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
workspace	pointer
->	O
tt	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
workspace	pointer
->	O
ee	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
dd	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
aa	array
)	O
;	O
free	function
(	O
workspace	pointer
->	O
bb	int
)	O
;	O
free	function
(	O
workspace	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for diagonal"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
workspace	pointer
->	O
e2	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
even_order	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
workspace	pointer
->	O
e2	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
workspace	pointer
->	O
tt	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
ee	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
dd	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
aa	array
)	O
;	O
free	function
(	O
workspace	pointer
->	O
bb	int
)	O
;	O
free	function
(	O
workspace	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for diagonal"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
workspace	pointer
->	O
zz	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
even_order	double
*	O
even_order	double
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
workspace	pointer
->	O
zz	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
workspace	pointer
->	O
e2	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
tt	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
ee	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
dd	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
aa	array
)	O
;	O
free	function
(	O
workspace	pointer
->	O
bb	int
)	O
;	O
free	function
(	O
workspace	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for diagonal"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
workspace	pointer
->	O
eval	pointer
=	O
gsl_vector_alloc	function
(	O
even_order	int
)	O
;	O
if	O
(	O
workspace	pointer
->	O
eval	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
workspace	pointer
->	O
zz	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
e2	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
tt	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
ee	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
dd	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
aa	array
)	O
;	O
free	function
(	O
workspace	pointer
->	O
bb	int
)	O
;	O
free	function
(	O
workspace	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for eval"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
workspace	pointer
->	O
evec	pointer
=	O
gsl_matrix_alloc	function
(	O
even_order	int
,	O
even_order	int
)	O
;	O
if	O
(	O
workspace	pointer
->	O
evec	pointer
==	O
NULL	O
)	O
{	O
gsl_vector_free	function
(	O
workspace	pointer
->	O
eval	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
zz	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
e2	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
tt	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
ee	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
dd	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
aa	array
)	O
;	O
free	function
(	O
workspace	pointer
->	O
bb	int
)	O
;	O
free	function
(	O
workspace	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for evec"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
workspace	pointer
->	O
wmat	pointer
=	O
gsl_eigen_symmv_alloc	function
(	O
even_order	pointer
)	O
;	O
if	O
(	O
workspace	pointer
->	O
wmat	pointer
==	O
NULL	O
)	O
{	O
gsl_matrix_free	function
(	O
workspace	pointer
->	O
evec	pointer
)	O
;	O
gsl_vector_free	function
(	O
workspace	pointer
->	O
eval	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
zz	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
e2	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
tt	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
ee	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
dd	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
aa	array
)	O
;	O
free	function
(	O
workspace	pointer
->	O
bb	int
)	O
;	O
free	function
(	O
workspace	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for wmat"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
workspace	pointer
;	O
}	O
void	O
gsl_sf_mathieu_free	function
(	O
gsl_sf_mathieu_workspace	struct
*	O
workspace	pointer
)	O
{	O
RETURN_IF_NULL	O
(	O
workspace	pointer
)	O
;	O
gsl_vector_free	function
(	O
workspace	pointer
->	O
eval	pointer
)	O
;	O
gsl_matrix_free	function
(	O
workspace	pointer
->	O
evec	pointer
)	O
;	O
gsl_eigen_symmv_free	function
(	O
workspace	pointer
->	O
wmat	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
aa	array
)	O
;	O
free	function
(	O
workspace	pointer
->	O
bb	int
)	O
;	O
free	function
(	O
workspace	pointer
->	O
dd	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
ee	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
tt	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
e2	pointer
)	O
;	O
free	function
(	O
workspace	pointer
->	O
zz	pointer
)	O
;	O
free	function
(	O
workspace	pointer
)	O
;	O
}	O
gsl_splinalg_itersolve	struct
*	O
gsl_splinalg_itersolve_alloc	function
(	O
const	O
gsl_splinalg_itersolve_type	struct
*	O
T	pointer
,	O
const	O
size_t	long
n	int
,	O
const	O
size_t	long
m	long
)	O
{	O
gsl_splinalg_itersolve	struct
*	O
w	pointer
;	O
w	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
gsl_splinalg_itersolve	struct
)	O
)	O
;	O
if	O
(	O
w	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for itersolve struct"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	pointer
->	O
type	pointer
=	O
T	pointer
;	O
w	pointer
->	O
normr	double
=	O
0.0	int
;	O
w	pointer
->	O
state	pointer
=	O
w	pointer
->	O
type	pointer
->	O
alloc	function
(	O
n	long
,	O
m	int
)	O
;	O
if	O
(	O
w	pointer
->	O
state	pointer
==	O
NULL	O
)	O
{	O
gsl_splinalg_itersolve_free	function
(	O
w	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for itersolve state"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
w	pointer
;	O
}	O
void	O
gsl_splinalg_itersolve_free	function
(	O
gsl_splinalg_itersolve	struct
*	O
w	pointer
)	O
{	O
RETURN_IF_NULL	O
(	O
w	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
state	pointer
)	O
w	pointer
->	O
type	pointer
->	O
free	function
(	O
w	pointer
->	O
state	pointer
)	O
;	O
free	function
(	O
w	pointer
)	O
;	O
}	O
const	O
char	O
*	O
gsl_splinalg_itersolve_name	function
(	O
const	O
gsl_splinalg_itersolve	struct
*	O
w	pointer
)	O
{	O
return	O
w	pointer
->	O
type	pointer
->	O
name	pointer
;	O
}	O
int	O
gsl_splinalg_itersolve_iterate	function
(	O
const	O
gsl_spmatrix	struct
*	O
A	pointer
,	O
const	O
gsl_vector	struct
*	O
b	double
,	O
const	O
double	O
tol	double
,	O
gsl_vector	struct
*	O
x	double
,	O
gsl_splinalg_itersolve	struct
*	O
w	pointer
)	O
{	O
int	O
status	int
=	O
w	pointer
->	O
type	pointer
->	O
iterate	function
(	O
A	pointer
,	O
b	double
,	O
tol	double
,	O
x	double
,	O
w	pointer
->	O
state	pointer
)	O
;	O
w	pointer
->	O
normr	pointer
=	O
w	pointer
->	O
type	pointer
->	O
normr	pointer
(	O
w	pointer
->	O
state	pointer
)	O
;	O
return	O
status	int
;	O
}	O
double	O
gsl_splinalg_itersolve_normr	function
(	O
const	O
gsl_splinalg_itersolve	struct
*	O
w	pointer
)	O
{	O
return	O
w	pointer
->	O
normr	pointer
;	O
}	O
gsl_sum_levin_utrunc_workspace	struct
*	O
gsl_sum_levin_utrunc_alloc	function
(	O
size_t	long
n	long
)	O
{	O
gsl_sum_levin_utrunc_workspace	struct
*	O
w	pointer
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"length n must be positive integer"	pointer
,	O
GSL_EDOM	int
,	O
0	int
)	O
;	O
}	O
w	pointer
=	O
(	O
gsl_sum_levin_utrunc_workspace	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_sum_levin_utrunc_workspace	struct
)	O
)	O
;	O
if	O
(	O
w	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_VAL	O
(	O
"failed to allocate struct"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
w	pointer
->	O
q_num	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
n	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
w	pointer
->	O
q_num	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
w	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for q_num"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
w	pointer
->	O
q_den	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
n	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
w	pointer
->	O
q_den	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
w	pointer
->	O
q_num	pointer
)	O
;	O
free	function
(	O
w	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for q_den"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
w	pointer
->	O
dsum	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
n	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
w	pointer
->	O
dsum	pointer
==	O
NULL	O
)	O
{	O
free	function
(	O
w	pointer
->	O
q_den	pointer
)	O
;	O
free	function
(	O
w	pointer
->	O
q_num	pointer
)	O
;	O
free	function
(	O
w	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for dsum"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
w	pointer
->	O
size	long
=	O
n	int
;	O
w	pointer
->	O
terms_used	long
=	O
0	int
;	O
w	pointer
->	O
sum_plain	double
=	O
0	int
;	O
return	O
w	pointer
;	O
}	O
void	O
gsl_sum_levin_utrunc_free	function
(	O
gsl_sum_levin_utrunc_workspace	struct
*	O
w	pointer
)	O
{	O
RETURN_IF_NULL	O
(	O
w	pointer
)	O
;	O
free	function
(	O
w	pointer
->	O
dsum	pointer
)	O
;	O
free	function
(	O
w	pointer
->	O
q_den	pointer
)	O
;	O
free	function
(	O
w	pointer
->	O
q_num	pointer
)	O
;	O
free	function
(	O
w	pointer
)	O
;	O
}	O
double	O
gsl_hypot	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
y	double
)	O
{	O
double	O
xabs	double
=	O
fabs	function
(	O
x	double
)	O
;	O
double	O
yabs	double
=	O
fabs	function
(	O
y	double
)	O
;	O
double	O
min	double
,	O
max	double
;	O
if	O
(	O
gsl_isinf	function
(	O
x	double
)	O
||	O
gsl_isinf	function
(	O
y	double
)	O
)	O
{	O
return	O
GSL_POSINF	O
;	O
}	O
if	O
(	O
xabs	double
<	O
yabs	int
)	O
{	O
min	double
=	O
xabs	int
;	O
max	double
=	O
yabs	int
;	O
}	O
else	O
{	O
min	double
=	O
yabs	int
;	O
max	double
=	O
xabs	double
;	O
}	O
if	O
(	O
min	double
==	O
0	int
)	O
{	O
return	O
max	double
;	O
}	O
{	O
double	O
u	double
=	O
min	double
/	O
max	double
;	O
return	O
max	double
*	O
sqrt	function
(	O
1	int
+	O
u	double
*	O
u	double
)	O
;	O
}	O
}	O
double	O
gsl_hypot3	function
(	O
const	O
double	O
x	double
,	O
const	O
double	O
y	double
,	O
const	O
double	O
z	double
)	O
{	O
double	O
xabs	double
=	O
fabs	function
(	O
x	double
)	O
;	O
double	O
yabs	double
=	O
fabs	function
(	O
y	double
)	O
;	O
double	O
zabs	double
=	O
fabs	function
(	O
z	double
)	O
;	O
double	O
w	double
=	O
GSL_MAX	O
(	O
xabs	int
,	O
GSL_MAX	O
(	O
yabs	int
,	O
zabs	int
)	O
)	O
;	O
if	O
(	O
w	int
==	O
0.0	int
)	O
{	O
return	O
(	O
0.0	int
)	O
;	O
}	O
else	O
{	O
double	O
r	double
=	O
w	int
*	O
sqrt	function
(	O
(	O
xabs	double
/	O
w	double
)	O
*	O
(	O
xabs	double
/	O
w	double
)	O
+	O
(	O
yabs	double
/	O
w	double
)	O
*	O
(	O
yabs	double
/	O
w	double
)	O
+	O
(	O
zabs	double
/	O
w	double
)	O
*	O
(	O
zabs	double
/	O
w	double
)	O
)	O
;	O
return	O
r	int
;	O
}	O
}	O
double	O
gsl_acosh	function
(	O
const	O
double	O
x	double
)	O
{	O
if	O
(	O
x	double
>	O
1.0	int
/	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
return	O
log	function
(	O
x	double
)	O
+	O
M_LN2	int
;	O
}	O
else	O
if	O
(	O
x	double
>	O
2	int
)	O
{	O
return	O
log	function
(	O
2	int
*	O
x	double
-	O
1	int
/	O
(	O
sqrt	function
(	O
x	double
*	O
x	double
-	O
1	int
)	O
+	O
x	double
)	O
)	O
;	O
}	O
else	O
if	O
(	O
x	double
>	O
1	int
)	O
{	O
double	O
t	double
=	O
x	double
-	O
1	int
;	O
return	O
log1p	function
(	O
t	double
+	O
sqrt	function
(	O
2	int
*	O
t	double
+	O
t	double
*	O
t	double
)	O
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
1	int
)	O
{	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
GSL_NAN	double
;	O
}	O
}	O
double	O
gsl_asinh	function
(	O
const	O
double	O
x	double
)	O
{	O
double	O
a	double
=	O
fabs	function
(	O
x	double
)	O
;	O
double	O
s	pointer
=	O
(	O
x	double
<	O
0	int
)	O
?	O
-	O
1	int
:	O
1	int
;	O
if	O
(	O
a	double
>	O
1	int
/	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
return	O
s	pointer
*	O
(	O
log	function
(	O
a	double
)	O
+	O
M_LN2	int
)	O
;	O
}	O
else	O
if	O
(	O
a	double
>	O
2	int
)	O
{	O
return	O
s	pointer
*	O
log	function
(	O
2	int
*	O
a	double
+	O
1	int
/	O
(	O
a	double
+	O
sqrt	function
(	O
a	double
*	O
a	double
+	O
1	int
)	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
a	double
>	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
double	O
a2	double
=	O
a	double
*	O
a	double
;	O
return	O
s	double
*	O
log1p	function
(	O
a	double
+	O
a2	double
/	O
(	O
1	int
+	O
sqrt	function
(	O
1	int
+	O
a2	double
)	O
)	O
)	O
;	O
}	O
else	O
{	O
return	O
x	double
;	O
}	O
}	O
double	O
gsl_atanh	function
(	O
const	O
double	O
x	double
)	O
{	O
double	O
a	double
=	O
fabs	function
(	O
x	double
)	O
;	O
double	O
s	double
=	O
(	O
x	double
<	O
0	int
)	O
?	O
-	O
1	int
:	O
1	int
;	O
if	O
(	O
a	double
>	O
1	int
)	O
{	O
return	O
GSL_NAN	int
;	O
}	O
else	O
if	O
(	O
a	double
==	O
1	int
)	O
{	O
return	O
(	O
x	double
<	O
0	int
)	O
?	O
GSL_NEGINF	O
:	O
GSL_POSINF	O
;	O
}	O
else	O
if	O
(	O
a	double
>=	O
0.5	int
)	O
{	O
return	O
s	long
*	O
0.5	int
*	O
log1p	function
(	O
2	int
*	O
a	double
/	O
(	O
1	int
-	O
a	double
)	O
)	O
;	O
}	O
else	O
if	O
(	O
a	double
>	O
GSL_DBL_EPSILON	int
)	O
{	O
return	O
s	pointer
*	O
0.5	int
*	O
log1p	function
(	O
2	int
*	O
a	double
+	O
2	int
*	O
a	double
*	O
a	double
/	O
(	O
1	int
-	O
a	double
)	O
)	O
;	O
}	O
else	O
{	O
return	O
x	double
;	O
}	O
}	O
const	O
double	O
gsl_prec_eps	array
[	O
_GSL_PREC_T_NUM	int
]	O
=	O
{	O
GSL_DBL_EPSILON	int
,	O
GSL_FLT_EPSILON	int
,	O
GSL_SFLT_EPSILON	int
}	O
;	O
const	O
double	O
gsl_prec_sqrt_eps	array
[	O
_GSL_PREC_T_NUM	int
]	O
=	O
{	O
GSL_SQRT_DBL_EPSILON	int
,	O
GSL_SQRT_FLT_EPSILON	int
,	O
GSL_SQRT_SFLT_EPSILON	int
}	O
;	O
const	O
double	O
gsl_prec_root3_eps	array
[	O
_GSL_PREC_T_NUM	int
]	O
=	O
{	O
GSL_ROOT3_DBL_EPSILON	int
,	O
GSL_ROOT3_FLT_EPSILON	int
,	O
GSL_ROOT3_SFLT_EPSILON	int
}	O
;	O
const	O
double	O
gsl_prec_root4_eps	array
[	O
_GSL_PREC_T_NUM	int
]	O
=	O
{	O
GSL_ROOT4_DBL_EPSILON	int
,	O
GSL_ROOT4_FLT_EPSILON	int
,	O
GSL_ROOT4_SFLT_EPSILON	int
}	O
;	O
const	O
double	O
gsl_prec_root5_eps	array
[	O
_GSL_PREC_T_NUM	int
]	O
=	O
{	O
GSL_ROOT5_DBL_EPSILON	int
,	O
GSL_ROOT5_FLT_EPSILON	int
,	O
GSL_ROOT5_SFLT_EPSILON	int
}	O
;	O
const	O
double	O
gsl_prec_root6_eps	array
[	O
_GSL_PREC_T_NUM	int
]	O
=	O
{	O
GSL_ROOT6_DBL_EPSILON	int
,	O
GSL_ROOT6_FLT_EPSILON	int
,	O
GSL_ROOT6_SFLT_EPSILON	int
}	O
;	O
typedef	O
int	O
dummy	int
;	O
OM_uint32	int
gss_init_sec_context	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
const	O
gss_cred_id_t	pointer
initiator_cred_handle	pointer
,	O
gss_ctx_id_t	pointer
*	O
context_handle	pointer
,	O
const	O
gss_name_t	pointer
target_name	pointer
,	O
const	O
gss_OID	pointer
mech_type	pointer
,	O
OM_uint32	int
req_flags	int
,	O
OM_uint32	int
time_req	int
,	O
const	O
gss_channel_bindings_t	pointer
input_chan_bindings	pointer
,	O
const	O
gss_buffer_t	pointer
input_token	pointer
,	O
gss_OID	pointer
*	O
actual_mech_type	pointer
,	O
gss_buffer_t	pointer
output_token	pointer
,	O
OM_uint32	int
*	O
ret_flags	pointer
,	O
OM_uint32	int
*	O
time_rec	pointer
)	O
{	O
OM_uint32	int
maj_stat	int
;	O
_gss_mech_api_t	pointer
mech	pointer
;	O
int	O
freecontext	int
=	O
0	int
;	O
if	O
(	O
output_token	pointer
)	O
{	O
output_token	pointer
->	O
length	int
=	O
0	int
;	O
output_token	pointer
->	O
value	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
ret_flags	pointer
)	O
*	O
ret_flags	pointer
=	O
0	int
;	O
if	O
(	O
!	O
context_handle	pointer
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_NO_CONTEXT	O
|	O
GSS_S_CALL_INACCESSIBLE_READ	O
;	O
}	O
if	O
(	O
output_token	int
==	O
GSS_C_NO_BUFFER	O
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_FAILURE	O
|	O
GSS_S_CALL_BAD_STRUCTURE	O
;	O
}	O
if	O
(	O
*	O
context_handle	pointer
==	O
GSS_C_NO_CONTEXT	pointer
)	O
mech	pointer
=	O
_gss_find_mech	function
(	O
mech_type	pointer
)	O
;	O
else	O
mech	pointer
=	O
_gss_find_mech	function
(	O
(	O
*	O
context_handle	pointer
)	O
->	O
mech	pointer
)	O
;	O
if	O
(	O
mech	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_BAD_MECH	O
;	O
}	O
if	O
(	O
actual_mech_type	pointer
)	O
*	O
actual_mech_type	pointer
=	O
mech	pointer
->	O
mech	pointer
;	O
if	O
(	O
*	O
context_handle	pointer
==	O
GSS_C_NO_CONTEXT	int
)	O
{	O
*	O
context_handle	pointer
=	O
calloc	function
(	O
sizeof	O
(	O
*	O
*	O
context_handle	pointer
)	O
,	O
1	int
)	O
;	O
if	O
(	O
!	O
*	O
context_handle	pointer
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
ENOMEM	int
;	O
return	O
GSS_S_FAILURE	O
;	O
}	O
(	O
*	O
context_handle	pointer
)	O
->	O
mech	pointer
=	O
mech	pointer
->	O
mech	pointer
;	O
freecontext	int
=	O
1	int
;	O
}	O
maj_stat	int
=	O
mech	pointer
->	O
init_sec_context	pointer
(	O
minor_status	pointer
,	O
initiator_cred_handle	pointer
,	O
context_handle	pointer
,	O
target_name	pointer
,	O
mech_type	pointer
,	O
req_flags	pointer
,	O
time_req	int
,	O
input_chan_bindings	pointer
,	O
input_token	pointer
,	O
actual_mech_type	pointer
,	O
output_token	pointer
,	O
ret_flags	pointer
,	O
time_rec	pointer
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
&&	O
freecontext	pointer
)	O
{	O
free	function
(	O
*	O
context_handle	pointer
)	O
;	O
*	O
context_handle	pointer
=	O
GSS_C_NO_CONTEXT	int
;	O
}	O
return	O
maj_stat	int
;	O
}	O
OM_uint32	int
gss_accept_sec_context	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
gss_ctx_id_t	pointer
*	O
context_handle	pointer
,	O
const	O
gss_cred_id_t	pointer
acceptor_cred_handle	pointer
,	O
const	O
gss_buffer_t	pointer
input_token_buffer	pointer
,	O
const	O
gss_channel_bindings_t	pointer
input_chan_bindings	pointer
,	O
gss_name_t	pointer
*	O
src_name	pointer
,	O
gss_OID	pointer
*	O
mech_type	pointer
,	O
gss_buffer_t	pointer
output_token	pointer
,	O
OM_uint32	int
*	O
ret_flags	pointer
,	O
OM_uint32	int
*	O
time_rec	pointer
,	O
gss_cred_id_t	pointer
*	O
delegated_cred_handle	pointer
)	O
{	O
_gss_mech_api_t	pointer
mech	pointer
;	O
if	O
(	O
!	O
context_handle	pointer
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_NO_CONTEXT	O
|	O
GSS_S_CALL_INACCESSIBLE_READ	O
;	O
}	O
if	O
(	O
*	O
context_handle	pointer
==	O
GSS_C_NO_CONTEXT	int
)	O
{	O
char	O
*	O
oid	pointer
;	O
size_t	long
oidlen	int
;	O
gss_OID_desc	struct
oidbuf	struct
;	O
int	O
rc	int
;	O
rc	int
=	O
_gss_decapsulate_token	function
(	O
input_token_buffer	pointer
->	O
value	pointer
,	O
input_token_buffer	pointer
->	O
length	long
,	O
&	O
oid	pointer
,	O
&	O
oidlen	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_DEFECTIVE_TOKEN	O
;	O
}	O
oidbuf	struct
.	O
elements	pointer
=	O
oid	pointer
;	O
oidbuf	struct
.	O
length	long
=	O
oidlen	int
;	O
mech	pointer
=	O
_gss_find_mech_no_default	function
(	O
&	O
oidbuf	pointer
)	O
;	O
}	O
else	O
mech	pointer
=	O
_gss_find_mech_no_default	function
(	O
(	O
*	O
context_handle	pointer
)	O
->	O
mech	pointer
)	O
;	O
if	O
(	O
mech	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_BAD_MECH	O
;	O
}	O
if	O
(	O
mech_type	pointer
)	O
*	O
mech_type	pointer
=	O
mech	pointer
->	O
mech	pointer
;	O
return	O
mech	pointer
->	O
accept_sec_context	pointer
(	O
minor_status	pointer
,	O
context_handle	pointer
,	O
acceptor_cred_handle	pointer
,	O
input_token_buffer	pointer
,	O
input_chan_bindings	pointer
,	O
src_name	pointer
,	O
mech_type	pointer
,	O
output_token	pointer
,	O
ret_flags	pointer
,	O
time_rec	pointer
,	O
delegated_cred_handle	pointer
)	O
;	O
}	O
OM_uint32	int
gss_delete_sec_context	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
gss_ctx_id_t	pointer
*	O
context_handle	pointer
,	O
gss_buffer_t	pointer
output_token	pointer
)	O
{	O
_gss_mech_api_t	pointer
mech	pointer
;	O
OM_uint32	int
ret	int
;	O
if	O
(	O
!	O
context_handle	pointer
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_NO_CONTEXT	O
|	O
GSS_S_CALL_INACCESSIBLE_READ	O
;	O
}	O
if	O
(	O
*	O
context_handle	pointer
==	O
GSS_C_NO_CONTEXT	int
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_NO_CONTEXT	O
|	O
GSS_S_CALL_BAD_STRUCTURE	O
;	O
}	O
if	O
(	O
output_token	int
!=	O
GSS_C_NO_BUFFER	O
)	O
{	O
output_token	pointer
->	O
length	int
=	O
0	int
;	O
output_token	pointer
->	O
value	pointer
=	O
NULL	O
;	O
}	O
mech	pointer
=	O
_gss_find_mech	function
(	O
(	O
*	O
context_handle	pointer
)	O
->	O
mech	pointer
)	O
;	O
if	O
(	O
mech	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_BAD_MECH	O
;	O
}	O
ret	int
=	O
mech	pointer
->	O
delete_sec_context	function
(	O
NULL	O
,	O
context_handle	pointer
,	O
output_token	pointer
)	O
;	O
free	function
(	O
*	O
context_handle	pointer
)	O
;	O
*	O
context_handle	pointer
=	O
GSS_C_NO_CONTEXT	pointer
;	O
return	O
ret	int
;	O
}	O
OM_uint32	int
gss_process_context_token	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
const	O
gss_ctx_id_t	pointer
context_handle	pointer
,	O
const	O
gss_buffer_t	pointer
token_buffer	pointer
)	O
{	O
return	O
GSS_S_FAILURE	O
;	O
}	O
OM_uint32	int
gss_context_time	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
const	O
gss_ctx_id_t	pointer
context_handle	pointer
,	O
OM_uint32	int
*	O
time_rec	pointer
)	O
{	O
_gss_mech_api_t	pointer
mech	pointer
;	O
if	O
(	O
context_handle	pointer
==	O
GSS_C_NO_CONTEXT	int
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_NO_CONTEXT	O
|	O
GSS_S_CALL_BAD_STRUCTURE	O
;	O
}	O
mech	pointer
=	O
_gss_find_mech	function
(	O
context_handle	pointer
->	O
mech	pointer
)	O
;	O
if	O
(	O
mech	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_BAD_MECH	O
;	O
}	O
return	O
mech	pointer
->	O
context_time	pointer
(	O
minor_status	pointer
,	O
context_handle	pointer
,	O
time_rec	pointer
)	O
;	O
}	O
OM_uint32	int
gss_inquire_context	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
const	O
gss_ctx_id_t	pointer
context_handle	pointer
,	O
gss_name_t	pointer
*	O
src_name	pointer
,	O
gss_name_t	pointer
*	O
targ_name	pointer
,	O
OM_uint32	int
*	O
lifetime_rec	pointer
,	O
gss_OID	pointer
*	O
mech_type	pointer
,	O
OM_uint32	int
*	O
ctx_flags	pointer
,	O
int	O
*	O
locally_initiated	pointer
,	O
int	O
*	O
open	int
)	O
{	O
return	O
GSS_S_FAILURE	O
;	O
}	O
OM_uint32	int
gss_wrap_size_limit	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
const	O
gss_ctx_id_t	pointer
context_handle	pointer
,	O
int	O
conf_req_flag	int
,	O
gss_qop_t	int
qop_req	int
,	O
OM_uint32	int
req_output_size	pointer
,	O
OM_uint32	int
*	O
max_input_size	pointer
)	O
{	O
return	O
GSS_S_FAILURE	O
;	O
}	O
OM_uint32	int
gss_export_sec_context	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
gss_ctx_id_t	pointer
*	O
context_handle	pointer
,	O
gss_buffer_t	pointer
interprocess_token	pointer
)	O
{	O
return	O
GSS_S_UNAVAILABLE	O
;	O
}	O
OM_uint32	int
gss_import_sec_context	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
const	O
gss_buffer_t	pointer
interprocess_token	pointer
,	O
gss_ctx_id_t	pointer
*	O
context_handle	pointer
)	O
{	O
return	O
GSS_S_UNAVAILABLE	O
;	O
}	O
OM_uint32	int
gss_acquire_cred	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
const	O
gss_name_t	pointer
desired_name	pointer
,	O
OM_uint32	int
time_req	int
,	O
const	O
gss_OID_set	pointer
desired_mechs	pointer
,	O
gss_cred_usage_t	int
cred_usage	int
,	O
gss_cred_id_t	pointer
*	O
output_cred_handle	pointer
,	O
gss_OID_set	pointer
*	O
actual_mechs	pointer
,	O
OM_uint32	int
*	O
time_rec	pointer
)	O
{	O
_gss_mech_api_t	pointer
mech	pointer
=	O
NULL	O
;	O
OM_uint32	int
maj_stat	int
;	O
if	O
(	O
!	O
output_cred_handle	pointer
)	O
return	O
GSS_S_NO_CRED	O
|	O
GSS_S_CALL_INACCESSIBLE_WRITE	O
;	O
if	O
(	O
desired_mechs	pointer
!=	O
GSS_C_NO_OID_SET	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
mech	pointer
==	O
NULL	O
&&	O
i	long
<	O
desired_mechs	pointer
->	O
count	long
;	O
i	long
++	O
)	O
mech	pointer
=	O
_gss_find_mech	function
(	O
(	O
&	O
desired_mechs	pointer
->	O
elements	pointer
)	O
[	O
i	long
]	O
)	O
;	O
}	O
else	O
mech	pointer
=	O
_gss_find_mech	function
(	O
GSS_C_NO_OID	O
)	O
;	O
if	O
(	O
mech	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_BAD_MECH	O
;	O
}	O
*	O
output_cred_handle	pointer
=	O
calloc	function
(	O
sizeof	O
(	O
*	O
*	O
output_cred_handle	pointer
)	O
,	O
1	int
)	O
;	O
if	O
(	O
!	O
*	O
output_cred_handle	pointer
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
ENOMEM	int
;	O
return	O
GSS_S_FAILURE	O
;	O
}	O
(	O
*	O
output_cred_handle	pointer
)	O
->	O
mech	pointer
=	O
mech	pointer
->	O
mech	pointer
;	O
maj_stat	int
=	O
mech	pointer
->	O
acquire_cred	pointer
(	O
minor_status	pointer
,	O
desired_name	pointer
,	O
time_req	int
,	O
desired_mechs	pointer
,	O
cred_usage	int
,	O
output_cred_handle	pointer
,	O
actual_mechs	pointer
,	O
time_rec	pointer
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
{	O
free	function
(	O
*	O
output_cred_handle	pointer
)	O
;	O
*	O
output_cred_handle	pointer
=	O
GSS_C_NO_CREDENTIAL	O
;	O
return	O
maj_stat	int
;	O
}	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
OM_uint32	int
gss_add_cred	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
const	O
gss_cred_id_t	pointer
input_cred_handle	pointer
,	O
const	O
gss_name_t	pointer
desired_name	pointer
,	O
const	O
gss_OID	pointer
desired_mech	pointer
,	O
gss_cred_usage_t	int
cred_usage	int
,	O
OM_uint32	int
initiator_time_req	int
,	O
OM_uint32	int
acceptor_time_req	int
,	O
gss_cred_id_t	pointer
*	O
output_cred_handle	pointer
,	O
gss_OID_set	pointer
*	O
actual_mechs	pointer
,	O
OM_uint32	int
*	O
initiator_time_rec	pointer
,	O
OM_uint32	int
*	O
acceptor_time_rec	pointer
)	O
{	O
return	O
GSS_S_UNAVAILABLE	O
;	O
}	O
OM_uint32	int
gss_inquire_cred	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
const	O
gss_cred_id_t	pointer
cred_handle	pointer
,	O
gss_name_t	pointer
*	O
name	pointer
,	O
OM_uint32	int
*	O
lifetime	pointer
,	O
gss_cred_usage_t	int
*	O
cred_usage	int
,	O
gss_OID_set	pointer
*	O
mechanisms	pointer
)	O
{	O
gss_cred_id_t	pointer
credh	pointer
=	O
cred_handle	pointer
;	O
_gss_mech_api_t	pointer
mech	pointer
;	O
OM_uint32	int
maj_stat	int
;	O
if	O
(	O
cred_handle	pointer
==	O
GSS_C_NO_CREDENTIAL	O
)	O
{	O
maj_stat	int
=	O
gss_acquire_cred	function
(	O
minor_status	pointer
,	O
GSS_C_NO_NAME	O
,	O
GSS_C_INDEFINITE	int
,	O
GSS_C_NO_OID_SET	O
,	O
GSS_C_INITIATE	pointer
,	O
&	O
credh	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
}	O
mech	pointer
=	O
_gss_find_mech	function
(	O
credh	pointer
->	O
mech	pointer
)	O
;	O
if	O
(	O
mech	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_BAD_MECH	O
;	O
}	O
maj_stat	int
=	O
mech	pointer
->	O
inquire_cred	pointer
(	O
minor_status	pointer
,	O
credh	pointer
,	O
name	pointer
,	O
lifetime	pointer
,	O
cred_usage	int
,	O
mechanisms	pointer
)	O
;	O
if	O
(	O
cred_handle	pointer
==	O
GSS_C_NO_CREDENTIAL	O
)	O
gss_release_cred	function
(	O
NULL	O
,	O
&	O
credh	pointer
)	O
;	O
return	O
maj_stat	int
;	O
}	O
OM_uint32	int
gss_inquire_cred_by_mech	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
const	O
gss_cred_id_t	pointer
cred_handle	pointer
,	O
const	O
gss_OID	pointer
mech_type	pointer
,	O
gss_name_t	pointer
*	O
name	pointer
,	O
OM_uint32	int
*	O
initiator_lifetime	pointer
,	O
OM_uint32	int
*	O
acceptor_lifetime	pointer
,	O
gss_cred_usage_t	int
*	O
cred_usage	int
)	O
{	O
_gss_mech_api_t	pointer
mech	pointer
;	O
gss_cred_id_t	pointer
credh	pointer
=	O
cred_handle	pointer
;	O
OM_uint32	int
maj_stat	int
;	O
if	O
(	O
mech_type	pointer
==	O
GSS_C_NO_OID	O
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_BAD_MECH	O
;	O
}	O
mech	pointer
=	O
_gss_find_mech	function
(	O
mech_type	pointer
)	O
;	O
if	O
(	O
mech	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_BAD_MECH	O
;	O
}	O
if	O
(	O
cred_handle	pointer
==	O
GSS_C_NO_CREDENTIAL	O
)	O
{	O
maj_stat	int
=	O
gss_acquire_cred	function
(	O
minor_status	pointer
,	O
GSS_C_NO_NAME	O
,	O
GSS_C_INDEFINITE	int
,	O
GSS_C_NO_OID_SET	O
,	O
GSS_C_INITIATE	pointer
,	O
&	O
credh	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
}	O
maj_stat	int
=	O
mech	pointer
->	O
inquire_cred_by_mech	pointer
(	O
minor_status	pointer
,	O
credh	pointer
,	O
mech_type	pointer
,	O
name	pointer
,	O
initiator_lifetime	pointer
,	O
acceptor_lifetime	pointer
,	O
cred_usage	int
)	O
;	O
if	O
(	O
cred_handle	pointer
==	O
GSS_C_NO_CREDENTIAL	O
)	O
gss_release_cred	function
(	O
NULL	O
,	O
&	O
credh	pointer
)	O
;	O
return	O
maj_stat	int
;	O
}	O
OM_uint32	int
gss_release_cred	function
(	O
OM_uint32	int
*	O
minor_status	pointer
,	O
gss_cred_id_t	pointer
*	O
cred_handle	pointer
)	O
{	O
_gss_mech_api_t	pointer
mech	pointer
;	O
OM_uint32	int
maj_stat	int
;	O
if	O
(	O
!	O
cred_handle	pointer
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_NO_CRED	O
|	O
GSS_S_CALL_INACCESSIBLE_READ	O
;	O
}	O
if	O
(	O
*	O
cred_handle	pointer
==	O
GSS_C_NO_CREDENTIAL	O
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
mech	pointer
=	O
_gss_find_mech	function
(	O
(	O
*	O
cred_handle	pointer
)	O
->	O
mech	pointer
)	O
;	O
if	O
(	O
mech	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
minor_status	pointer
)	O
*	O
minor_status	pointer
=	O
0	int
;	O
return	O
GSS_S_DEFECTIVE_CREDENTIAL	O
;	O
}	O
maj_stat	int
=	O
mech	pointer
->	O
release_cred	pointer
(	O
minor_status	pointer
,	O
cred_handle	pointer
)	O
;	O
free	function
(	O
*	O
cred_handle	pointer
)	O
;	O
*	O
cred_handle	pointer
=	O
GSS_C_NO_CREDENTIAL	O
;	O
if	O
(	O
GSS_ERROR	O
(	O
maj_stat	int
)	O
)	O
return	O
maj_stat	int
;	O
return	O
GSS_S_COMPLETE	int
;	O
}	O
OM_uint32	int
gss_krb5_tktlifetime	function
(	O
Shishi_tkt	struct
*	O
tkt	pointer
)	O
{	O
time_t	long
now	long
,	O
end	pointer
;	O
if	O
(	O
!	O
tkt	pointer
)	O
return	O
GSS_C_INDEFINITE	int
;	O
if	O
(	O
!	O
shishi_tkt_valid_now_p	function
(	O
tkt	pointer
)	O
)	O
return	O
0	int
;	O
now	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
end	O
=	O
shishi_tkt_endctime	function
(	O
tkt	pointer
)	O
;	O
return	O
end	long
-	O
now	long
;	O
}	O
const	O
char	O
*	O
program_name	pointer
=	O
NULL	O
;	O
void	O
set_program_name	function
(	O
const	O
char	O
*	O
argv0	pointer
)	O
{	O
const	O
char	O
*	O
slash	pointer
;	O
const	O
char	O
*	O
base	pointer
;	O
if	O
(	O
argv0	pointer
==	O
NULL	O
)	O
{	O
fputs	function
(	O
"A NULL argv[0] was passed through an exec system call.\n"	pointer
,	O
stderr	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
slash	pointer
=	O
strrchr	function
(	O
argv0	pointer
,	O
'/'	O
)	O
;	O
base	pointer
=	O
(	O
slash	pointer
!=	O
NULL	O
?	O
slash	pointer
+	O
1	int
:	O
argv0	pointer
)	O
;	O
if	O
(	O
base	pointer
-	O
argv0	pointer
>=	O
7	int
&&	O
strncmp	function
(	O
base	pointer
-	O
7	int
,	O
"/.libs/"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
{	O
argv0	pointer
=	O
base	pointer
;	O
if	O
(	O
strncmp	function
(	O
base	pointer
,	O
"lt-"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
{	O
argv0	pointer
=	O
base	pointer
+	O
3	int
;	O
program_invocation_short_name	pointer
=	O
(	O
char	O
*	O
)	O
argv0	pointer
;	O
}	O
}	O
program_name	pointer
=	O
argv0	pointer
;	O
program_invocation_name	pointer
=	O
(	O
char	O
*	O
)	O
argv0	pointer
;	O
}	O
local	O
file_t	O
zfile	O
;	O
local	O
unsigned	O
short	O
bi_buf	int
;	O
local	O
int	O
bi_valid	int
;	O
int	O
(	O
*	O
read_buf	pointer
)	O
(	O
char	O
*	O
buf	pointer
,	O
unsigned	O
size	int
)	O
;	O
void	O
bi_init	function
(	O
zipfile	int
)	O
file_t	O
zipfile	int
;	O
{	O
zfile	pointer
=	O
zipfile	int
;	O
bi_buf	int
=	O
0	int
;	O
bi_valid	int
=	O
0	int
;	O
if	O
(	O
zfile	pointer
!=	O
NO_FILE	int
)	O
{	O
read_buf	int
=	O
file_read	int
;	O
}	O
}	O
void	O
send_bits	function
(	O
value	pointer
,	O
length	int
)	O
int	O
value	int
;	O
int	O
length	int
;	O
{	O
if	O
(	O
bi_valid	int
>	O
(	O
int	O
)	O
Buf_size	int
-	O
length	int
)	O
{	O
bi_buf	int
|=	O
(	O
value	int
<<	O
bi_valid	int
)	O
;	O
put_short	function
(	O
bi_buf	int
)	O
;	O
bi_buf	int
=	O
(	O
ush	int
)	O
value	int
>>	O
(	O
Buf_size	int
-	O
bi_valid	int
)	O
;	O
bi_valid	int
+=	O
length	int
-	O
Buf_size	int
;	O
}	O
else	O
{	O
bi_buf	int
|=	O
value	int
<<	O
bi_valid	int
;	O
bi_valid	int
+=	O
length	int
;	O
}	O
}	O
unsigned	O
bi_reverse	function
(	O
code	int
,	O
len	int
)	O
unsigned	O
code	int
;	O
int	O
len	int
;	O
{	O
register	O
unsigned	O
res	int
=	O
0	int
;	O
do	O
{	O
res	int
|=	O
code	int
&	O
1	int
;	O
code	int
>>=	O
1	int
,	O
res	int
<<=	O
1	int
;	O
}	O
while	O
(	O
--	O
len	int
>	O
0	int
)	O
;	O
return	O
res	int
>>	O
1	int
;	O
}	O
void	O
bi_windup	function
(	O
)	O
{	O
if	O
(	O
bi_valid	int
>	O
8	int
)	O
{	O
put_short	function
(	O
bi_buf	pointer
)	O
;	O
}	O
else	O
if	O
(	O
bi_valid	int
>	O
0	int
)	O
{	O
put_byte	O
(	O
bi_buf	pointer
)	O
;	O
}	O
bi_buf	int
=	O
0	int
;	O
bi_valid	int
=	O
0	int
;	O
}	O
void	O
copy_block	function
(	O
buf	pointer
,	O
len	int
,	O
header	pointer
)	O
char	O
*	O
buf	pointer
;	O
unsigned	O
len	int
;	O
int	O
header	pointer
;	O
{	O
bi_windup	function
(	O
)	O
;	O
if	O
(	O
header	pointer
)	O
{	O
put_short	function
(	O
(	O
ush	int
)	O
len	int
)	O
;	O
put_short	function
(	O
(	O
ush	int
)	O
~	O
len	int
)	O
;	O
}	O
while	O
(	O
len	int
--	O
)	O
{	O
put_byte	O
(	O
*	O
buf	pointer
++	O
)	O
;	O
}	O
}	O
char	O
*	O
last_component	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
const	O
*	O
base	pointer
=	O
name	pointer
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
char	O
const	O
*	O
p	pointer
;	O
bool	bool
saw_slash	bool
=	O
false	int
;	O
while	O
(	O
ISSLASH	O
(	O
*	O
base	pointer
)	O
)	O
base	pointer
++	O
;	O
for	O
(	O
p	pointer
=	O
base	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
ISSLASH	O
(	O
*	O
p	pointer
)	O
)	O
saw_slash	bool
=	O
true	int
;	O
else	O
if	O
(	O
saw_slash	bool
)	O
{	O
base	pointer
=	O
p	pointer
;	O
saw_slash	bool
=	O
false	int
;	O
}	O
}	O
return	O
(	O
char	O
*	O
)	O
base	pointer
;	O
}	O
size_t	long
base_len	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
size_t	long
len	long
;	O
size_t	long
prefix_len	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
for	O
(	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
1	int
<	O
len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
len	long
-	O
1	int
]	O
)	O
;	O
len	long
--	O
)	O
continue	O
;	O
if	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
len	long
==	O
1	int
&&	O
ISSLASH	O
(	O
name	pointer
[	O
0	int
]	O
)	O
&&	O
ISSLASH	O
(	O
name	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
name	pointer
[	O
2	int
]	O
)	O
return	O
2	int
;	O
if	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
prefix_len	long
&&	O
len	long
==	O
prefix_len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
prefix_len	long
]	O
)	O
)	O
return	O
prefix_len	long
+	O
1	int
;	O
return	O
len	long
;	O
}	O
int	O
set_cloexec_flag	function
(	O
int	O
desc	int
,	O
bool	bool
value	bool
)	O
{	O
int	O
flags	int
=	O
fcntl	function
(	O
desc	int
,	O
F_GETFD	int
,	O
0	int
)	O
;	O
if	O
(	O
0	int
<=	O
flags	int
)	O
{	O
int	O
newflags	int
=	O
(	O
value	bool
?	O
flags	int
|	O
FD_CLOEXEC	int
:	O
flags	int
&	O
~	O
FD_CLOEXEC	int
)	O
;	O
if	O
(	O
flags	int
==	O
newflags	int
||	O
fcntl	function
(	O
desc	int
,	O
F_SETFD	int
,	O
newflags	int
)	O
!=	O
-	O
1	int
)	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
dup_cloexec	function
(	O
int	O
fd	int
)	O
{	O
return	O
fcntl	function
(	O
fd	int
,	O
F_DUPFD_CLOEXEC	int
,	O
0	int
)	O
;	O
}	O
int	O
open_safer	function
(	O
char	O
const	O
*	O
file	pointer
,	O
int	O
flags	int
,	O
...	O
)	O
{	O
mode_t	int
mode	int
=	O
0	int
;	O
if	O
(	O
flags	int
&	O
O_CREAT	int
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
flags	int
)	O
;	O
mode	int
=	O
va_arg	O
(	O
ap	array
,	O
PROMOTED_MODE_T	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
return	O
fd_safer	function
(	O
open	function
(	O
file	pointer
,	O
flags	int
,	O
mode	int
)	O
)	O
;	O
}	O
int	O
printf	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
int	O
retval	int
;	O
va_list	array
args	array
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
retval	int
=	O
vfprintf	function
(	O
stdout	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
return	O
retval	int
;	O
}	O
typedef	O
int	O
dummy	int
;	O
static	O
int	O
msg_done	int
=	O
0	int
;	O
int	O
lzw	function
(	O
in	pointer
,	O
out	pointer
)	O
int	O
in	int
,	O
out	int
;	O
{	O
if	O
(	O
msg_done	int
)	O
return	O
ERROR	int
;	O
msg_done	int
=	O
1	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"output in compress .Z format not supported\n"	pointer
)	O
;	O
if	O
(	O
in	pointer
!=	O
out	pointer
)	O
{	O
exit_code	int
=	O
ERROR	int
;	O
}	O
return	O
ERROR	int
;	O
}	O
local	O
ulg	long
orig_len	long
;	O
local	O
int	O
max_len	int
;	O
local	O
uch	char
literal	array
[	O
LITERALS	int
]	O
;	O
local	O
int	O
lit_base	array
[	O
MAX_BITLEN	int
+	O
1	int
]	O
;	O
local	O
int	O
leaves	array
[	O
MAX_BITLEN	int
+	O
1	int
]	O
;	O
local	O
int	O
parents	array
[	O
MAX_BITLEN	int
+	O
1	int
]	O
;	O
local	O
int	O
peek_bits	int
;	O
local	O
ulg	long
bitbuf	long
;	O
local	O
int	O
valid	int
;	O
static	O
unsigned	O
char	O
read_byte	function
(	O
void	O
)	O
{	O
int	O
b	int
=	O
get_byte	O
(	O
)	O
;	O
if	O
(	O
b	int
<	O
0	int
)	O
gzip_error	function
(	O
"invalid compressed data -- unexpected end of file"	pointer
)	O
;	O
return	O
b	int
;	O
}	O
local	O
void	O
read_tree	function
(	O
void	O
)	O
;	O
local	O
void	O
build_tree	function
(	O
void	O
)	O
;	O
local	O
void	O
read_tree	function
(	O
)	O
{	O
int	O
len	int
;	O
int	O
base	int
;	O
int	O
n	int
;	O
int	O
max_leaves	int
=	O
1	int
;	O
orig_len	long
=	O
0	int
;	O
for	O
(	O
n	int
=	O
1	int
;	O
n	int
<=	O
4	int
;	O
n	int
++	O
)	O
orig_len	long
=	O
(	O
orig_len	long
<<	O
8	int
)	O
|	O
read_byte	function
(	O
)	O
;	O
max_len	int
=	O
read_byte	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
0	int
<	O
max_len	int
&&	O
max_len	int
<=	O
MAX_BITLEN	int
)	O
)	O
gzip_error	function
(	O
"invalid compressed data -- "	pointer
"Huffman code bit length out of range"	pointer
)	O
;	O
n	int
=	O
0	int
;	O
for	O
(	O
len	int
=	O
1	int
;	O
len	int
<=	O
max_len	int
;	O
len	int
++	O
)	O
{	O
leaves	array
[	O
len	int
]	O
=	O
read_byte	function
(	O
)	O
;	O
if	O
(	O
max_leaves	int
-	O
(	O
len	int
==	O
max_len	int
)	O
<	O
leaves	array
[	O
len	int
]	O
)	O
gzip_error	function
(	O
"too many leaves in Huffman tree"	pointer
)	O
;	O
max_leaves	int
=	O
(	O
max_leaves	pointer
-	O
leaves	array
[	O
len	int
]	O
+	O
1	int
)	O
*	O
2	int
-	O
1	int
;	O
n	int
+=	O
leaves	array
[	O
len	int
]	O
;	O
}	O
if	O
(	O
LITERALS	int
<=	O
n	int
)	O
{	O
gzip_error	function
(	O
"too many leaves in Huffman tree"	pointer
)	O
;	O
}	O
Trace	function
(	O
(	O
stderr	pointer
,	O
"orig_len %lu, max_len %d, leaves %d\n"	pointer
,	O
orig_len	long
,	O
max_len	pointer
,	O
n	int
)	O
)	O
;	O
leaves	array
[	O
max_len	int
]	O
++	O
;	O
base	int
=	O
0	int
;	O
for	O
(	O
len	int
=	O
1	int
;	O
len	int
<=	O
max_len	int
;	O
len	int
++	O
)	O
{	O
lit_base	array
[	O
len	int
]	O
=	O
base	pointer
;	O
for	O
(	O
n	int
=	O
leaves	array
[	O
len	int
]	O
;	O
n	int
>	O
0	int
;	O
n	int
--	O
)	O
{	O
literal	array
[	O
base	int
++	O
]	O
=	O
read_byte	function
(	O
)	O
;	O
}	O
}	O
leaves	array
[	O
max_len	int
]	O
++	O
;	O
}	O
local	O
void	O
build_tree	function
(	O
)	O
{	O
int	O
nodes	int
=	O
0	int
;	O
int	O
len	int
;	O
uch	char
*	O
prefixp	pointer
;	O
for	O
(	O
len	int
=	O
max_len	int
;	O
len	int
>=	O
1	int
;	O
len	int
--	O
)	O
{	O
nodes	int
>>=	O
1	int
;	O
parents	pointer
[	O
len	int
]	O
=	O
nodes	pointer
;	O
lit_base	array
[	O
len	int
]	O
-=	O
nodes	int
;	O
nodes	int
+=	O
leaves	array
[	O
len	int
]	O
;	O
}	O
if	O
(	O
(	O
nodes	int
>>	O
1	int
)	O
!=	O
1	int
)	O
gzip_error	function
(	O
"too few leaves in Huffman tree"	pointer
)	O
;	O
peek_bits	int
=	O
MIN	O
(	O
max_len	pointer
,	O
MAX_PEEK	int
)	O
;	O
prefixp	long
=	O
&	O
prefix_len	array
[	O
1	int
<<	O
peek_bits	int
]	O
;	O
for	O
(	O
len	int
=	O
1	int
;	O
len	int
<=	O
peek_bits	int
;	O
len	int
++	O
)	O
{	O
int	O
prefixes	int
=	O
leaves	array
[	O
len	int
]	O
<<	O
(	O
peek_bits	int
-	O
len	int
)	O
;	O
while	O
(	O
prefixes	int
--	O
)	O
*	O
--	O
prefixp	int
=	O
(	O
uch	char
)	O
len	int
;	O
}	O
while	O
(	O
prefixp	int
>	O
prefix_len	long
)	O
*	O
--	O
prefixp	int
=	O
0	int
;	O
}	O
int	O
unpack	function
(	O
in	pointer
,	O
out	pointer
)	O
int	O
in	int
,	O
out	pointer
;	O
{	O
int	O
len	int
;	O
unsigned	O
eob	int
;	O
register	O
unsigned	O
peek	int
;	O
unsigned	O
peek_mask	int
;	O
ifd	int
=	O
in	int
;	O
ofd	int
=	O
out	int
;	O
read_tree	function
(	O
)	O
;	O
build_tree	function
(	O
)	O
;	O
clear_bitbuf	function
(	O
)	O
;	O
peek_mask	int
=	O
(	O
1	int
<<	O
peek_bits	int
)	O
-	O
1	int
;	O
eob	int
=	O
leaves	array
[	O
max_len	int
]	O
-	O
1	int
;	O
Trace	function
(	O
(	O
stderr	pointer
,	O
"eob %d %x\n"	pointer
,	O
max_len	pointer
,	O
eob	pointer
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
look_bits	function
(	O
peek	pointer
,	O
peek_bits	pointer
,	O
peek_mask	int
)	O
;	O
len	int
=	O
prefix_len	array
[	O
peek	int
]	O
;	O
if	O
(	O
len	int
>	O
0	int
)	O
{	O
peek	O
>>=	O
peek_bits	int
-	O
len	int
;	O
}	O
else	O
{	O
ulg	long
mask	long
=	O
peek_mask	int
;	O
len	int
=	O
peek_bits	int
;	O
while	O
(	O
peek	int
<	O
parents	pointer
[	O
len	int
]	O
)	O
{	O
len	int
++	O
,	O
mask	int
=	O
(	O
mask	int
<<	O
1	int
)	O
+	O
1	int
;	O
look_bits	function
(	O
peek	pointer
,	O
len	int
,	O
mask	int
)	O
;	O
}	O
}	O
if	O
(	O
peek	int
==	O
eob	int
&&	O
len	int
==	O
max_len	int
)	O
break	O
;	O
put_ubyte	O
(	O
literal	array
[	O
peek	int
+	O
lit_base	array
[	O
len	int
]	O
]	O
)	O
;	O
Tracev	function
(	O
(	O
stderr	pointer
,	O
"%02d %04x %c\n"	pointer
,	O
len	int
,	O
peek	pointer
,	O
literal	array
[	O
peek	pointer
+	O
lit_base	pointer
[	O
len	int
]	O
]	O
)	O
)	O
;	O
skip_bits	function
(	O
len	int
)	O
;	O
}	O
flush_window	function
(	O
)	O
;	O
if	O
(	O
orig_len	long
!=	O
(	O
ulg	long
)	O
(	O
bytes_out	long
&	O
0xffffffff	int
)	O
)	O
{	O
gzip_error	function
(	O
"invalid compressed data--length error"	pointer
)	O
;	O
}	O
return	O
OK	int
;	O
}	O
static	O
struct	O
{	O
DevPt	struct
p_act	pointer
;	O
int	O
dx	int
,	O
dy	int
,	O
s1	int
,	O
s2	int
,	O
swapdir	int
,	O
err	int
,	O
count	int
;	O
}	O
bres	struct
;	O
DevPt	struct
*	O
bresenham_init	function
(	O
DevPt	struct
*	O
pp1	pointer
,	O
DevPt	struct
*	O
pp2	pointer
)	O
{	O
bres	struct
.	O
p_act	int
=	O
*	O
pp1	pointer
;	O
if	O
(	O
(	O
bres	struct
.	O
dx	pointer
=	O
pp2	pointer
->	O
x	double
-	O
pp1	pointer
->	O
x	double
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
bres	struct
.	O
dx	pointer
<	O
0	int
)	O
{	O
bres	struct
.	O
dx	pointer
=	O
-	O
bres	struct
.	O
dx	pointer
;	O
bres	struct
.	O
s1	long
=	O
-	O
1	int
;	O
}	O
else	O
bres	struct
.	O
s1	long
=	O
1	int
;	O
}	O
else	O
bres	struct
.	O
s1	long
=	O
0	int
;	O
if	O
(	O
(	O
bres	struct
.	O
dy	double
=	O
pp2	pointer
->	O
y	double
-	O
pp1	pointer
->	O
y	double
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
bres	struct
.	O
dy	double
<	O
0	int
)	O
{	O
bres	struct
.	O
dy	double
=	O
-	O
bres	struct
.	O
dy	double
;	O
bres	struct
.	O
s2	double
=	O
-	O
1	int
;	O
}	O
else	O
bres	struct
.	O
s2	double
=	O
1	int
;	O
}	O
else	O
bres	struct
.	O
s2	double
=	O
0	int
;	O
if	O
(	O
bres	struct
.	O
dy	double
>	O
bres	struct
.	O
dx	int
)	O
{	O
bres	struct
.	O
swapdir	double
=	O
bres	struct
.	O
dx	pointer
;	O
bres	struct
.	O
dx	pointer
=	O
bres	struct
.	O
dy	double
;	O
bres	struct
.	O
dy	double
=	O
bres	struct
.	O
swapdir	int
;	O
bres	struct
.	O
swapdir	int
=	O
1	int
;	O
}	O
else	O
bres	struct
.	O
swapdir	int
=	O
0	int
;	O
bres	struct
.	O
count	long
=	O
bres	struct
.	O
dx	pointer
;	O
bres	struct
.	O
dy	int
<<=	O
1	int
;	O
bres	struct
.	O
err	double
=	O
bres	struct
.	O
dy	double
-	O
bres	struct
.	O
dx	pointer
;	O
bres	struct
.	O
dx	int
<<=	O
1	int
;	O
return	O
&	O
bres	struct
.	O
p_act	int
;	O
}	O
int	O
bresenham_next	function
(	O
void	O
)	O
{	O
if	O
(	O
bres	struct
.	O
count	int
<=	O
0	int
)	O
return	O
(	O
BRESENHAM_ERR	int
)	O
;	O
while	O
(	O
bres	struct
.	O
err	double
>=	O
0	int
)	O
{	O
if	O
(	O
bres	struct
.	O
swapdir	int
)	O
bres	struct
.	O
p_act	struct
.	O
x	double
+=	O
bres	struct
.	O
s1	double
;	O
else	O
bres	struct
.	O
p_act	struct
.	O
y	double
+=	O
bres	struct
.	O
s2	double
;	O
bres	struct
.	O
err	double
-=	O
bres	struct
.	O
dx	pointer
;	O
}	O
if	O
(	O
bres	struct
.	O
swapdir	int
)	O
bres	struct
.	O
p_act	struct
.	O
y	double
+=	O
bres	struct
.	O
s2	double
;	O
else	O
bres	struct
.	O
p_act	struct
.	O
x	double
+=	O
bres	struct
.	O
s1	double
;	O
bres	struct
.	O
err	double
+=	O
bres	struct
.	O
dy	double
;	O
bres	struct
.	O
count	int
--	O
;	O
return	O
(	O
(	O
bres	struct
.	O
count	long
)	O
?	O
0	int
:	O
BRESENHAM_EOL	pointer
)	O
;	O
}	O
static	O
short	O
ClipAreaCode	function
(	O
double	O
x1	double
,	O
double	O
y1	double
,	O
double	O
x2	double
,	O
double	O
y2	double
,	O
double	O
px	double
,	O
double	O
py	double
)	O
{	O
short	O
code	int
=	O
CLIP_INSIDE	int
;	O
if	O
(	O
px	double
<	O
x1	double
-	O
1.e-3	int
)	O
code	int
|=	O
CLIP_LEFT	int
;	O
else	O
if	O
(	O
px	double
>	O
x2	double
+	O
1.e-3	int
)	O
code	int
|=	O
CLIP_RIGHT	int
;	O
if	O
(	O
py	double
<	O
y1	function
-	O
1.e-3	int
)	O
code	int
|=	O
CLIP_BELOW	int
;	O
else	O
if	O
(	O
py	double
>	O
y2	double
+	O
1.e-3	int
)	O
code	int
|=	O
CLIP_ABOVE	int
;	O
return	O
code	int
;	O
}	O
static	O
int	O
ClipWithBorder	function
(	O
double	O
delta	double
,	O
double	O
diff	double
,	O
double	O
*	O
tEnter	pointer
,	O
double	O
*	O
tLeave	pointer
)	O
{	O
double	O
t	double
;	O
t	double
=	O
diff	double
/	O
delta	double
;	O
if	O
(	O
fabs	function
(	O
t	double
)	O
<	O
1.e-5	double
)	O
return	O
0	int
;	O
if	O
(	O
delta	double
<	O
0.0	int
)	O
{	O
if	O
(	O
t	int
>	O
*	O
tLeave	pointer
)	O
return	O
0	int
;	O
else	O
if	O
(	O
t	int
>	O
*	O
tEnter	pointer
)	O
*	O
tEnter	pointer
=	O
t	double
;	O
}	O
else	O
{	O
if	O
(	O
t	double
<	O
*	O
tEnter	pointer
)	O
return	O
0	int
;	O
else	O
if	O
(	O
t	double
<	O
*	O
tLeave	pointer
)	O
*	O
tLeave	pointer
=	O
t	double
;	O
}	O
return	O
1	int
;	O
}	O
short	O
DtClipLine	function
(	O
double	O
xmin	double
,	O
double	O
ymin	double
,	O
double	O
xmax	double
,	O
double	O
ymax	double
,	O
double	O
*	O
x1	double
,	O
double	O
*	O
y1	double
,	O
double	O
*	O
x2	double
,	O
double	O
*	O
y2	double
)	O
{	O
short	O
area_code1	double
,	O
area_code2	double
;	O
double	O
eps	double
;	O
eps	double
=	O
1.e-10	double
;	O
area_code1	double
=	O
ClipAreaCode	function
(	O
xmin	double
,	O
ymin	double
,	O
xmax	double
,	O
ymax	double
,	O
*	O
x1	double
,	O
*	O
y1	double
)	O
;	O
area_code2	double
=	O
ClipAreaCode	function
(	O
xmin	double
,	O
ymin	double
,	O
xmax	double
,	O
ymax	double
,	O
*	O
x2	double
,	O
*	O
y2	double
)	O
;	O
if	O
(	O
ClipFullyInside	function
(	O
area_code1	pointer
,	O
area_code2	pointer
)	O
)	O
return	O
CLIP_DRAW	int
;	O
if	O
(	O
ClipSurelyOutside	function
(	O
area_code1	pointer
,	O
area_code2	int
)	O
)	O
{	O
return	O
CLIP_NODRAW	int
;	O
}	O
else	O
{	O
double	O
dx	pointer
,	O
dy	int
;	O
int	O
dx0	int
,	O
dy0	int
;	O
double	O
tEnter	double
,	O
tLeave	double
;	O
double	O
*	O
tE	pointer
=	O
&	O
tEnter	struct
;	O
double	O
*	O
tL	pointer
=	O
&	O
tLeave	struct
;	O
dx	double
=	O
*	O
x2	double
-	O
*	O
x1	double
;	O
dy	double
=	O
*	O
y2	double
-	O
*	O
y1	function
;	O
tEnter	double
=	O
0.0	int
;	O
tLeave	int
=	O
1.	int
;	O
dx0	double
=	O
(	O
-	O
eps	double
<	O
dx	double
&&	O
dx	double
<	O
eps	double
)	O
;	O
dy0	double
=	O
(	O
-	O
eps	double
<	O
dy	double
&&	O
dy	double
<	O
eps	double
)	O
;	O
if	O
(	O
dx0	double
||	O
ClipWithBorder	function
(	O
-	O
dx	pointer
,	O
-	O
(	O
xmin	double
-	O
*	O
x1	double
)	O
,	O
tE	int
,	O
tL	int
)	O
)	O
if	O
(	O
dy0	double
||	O
ClipWithBorder	function
(	O
dy	double
,	O
(	O
ymax	double
-	O
*	O
y1	double
)	O
,	O
tE	double
,	O
tL	int
)	O
)	O
if	O
(	O
dx0	int
||	O
ClipWithBorder	function
(	O
dx	pointer
,	O
(	O
xmax	double
-	O
*	O
x1	double
)	O
,	O
tE	int
,	O
tL	int
)	O
)	O
if	O
(	O
dy0	int
||	O
ClipWithBorder	function
(	O
-	O
dy	double
,	O
-	O
(	O
ymin	double
-	O
*	O
y1	function
)	O
,	O
tE	int
,	O
tL	int
)	O
)	O
{	O
*	O
x2	double
=	O
*	O
x1	double
+	O
(	O
tLeave	struct
*	O
dx	pointer
)	O
;	O
*	O
y2	double
=	O
*	O
y1	double
+	O
(	O
tLeave	struct
*	O
dy	pointer
)	O
;	O
*	O
x1	double
=	O
*	O
x1	double
+	O
(	O
tEnter	struct
*	O
dx	pointer
)	O
;	O
*	O
y1	struct
=	O
*	O
y1	function
+	O
(	O
tEnter	struct
*	O
dy	pointer
)	O
;	O
return	O
CLIP_DRAW	int
;	O
}	O
}	O
return	O
CLIP_NODRAW	pointer
;	O
}	O
void	O
enqueue_head	function
(	O
register	O
queue_t	pointer
que	pointer
,	O
register	O
queue_entry_t	pointer
elt	pointer
)	O
{	O
elt	pointer
->	O
next	pointer
=	O
que	pointer
->	O
next	pointer
;	O
elt	pointer
->	O
prev	pointer
=	O
que	pointer
;	O
elt	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
elt	pointer
;	O
que	pointer
->	O
next	pointer
=	O
elt	pointer
;	O
}	O
void	O
enqueue_tail	function
(	O
register	O
queue_t	pointer
que	int
,	O
register	O
queue_entry_t	pointer
elt	pointer
)	O
{	O
elt	pointer
->	O
next	pointer
=	O
que	pointer
;	O
elt	pointer
->	O
prev	pointer
=	O
que	pointer
->	O
prev	pointer
;	O
elt	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
elt	pointer
;	O
que	pointer
->	O
prev	pointer
=	O
elt	pointer
;	O
}	O
queue_entry_t	enum
dequeue_head	function
(	O
register	O
queue_t	pointer
que	int
)	O
{	O
register	O
queue_entry_t	pointer
elt	pointer
;	O
if	O
(	O
que	pointer
->	O
next	pointer
==	O
que	int
)	O
return	O
(	O
(	O
queue_entry_t	int
)	O
0	int
)	O
;	O
elt	pointer
=	O
que	pointer
->	O
next	pointer
;	O
elt	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
que	pointer
;	O
que	pointer
->	O
next	pointer
=	O
elt	pointer
->	O
next	pointer
;	O
return	O
(	O
elt	pointer
)	O
;	O
}	O
queue_entry_t	O
dequeue_tail	function
(	O
register	O
queue_t	pointer
que	int
)	O
{	O
register	O
queue_entry_t	pointer
elt	pointer
;	O
if	O
(	O
que	pointer
->	O
prev	pointer
==	O
que	int
)	O
return	O
(	O
(	O
queue_entry_t	int
)	O
0	int
)	O
;	O
elt	pointer
=	O
que	pointer
->	O
prev	pointer
;	O
elt	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
que	pointer
;	O
que	pointer
->	O
prev	pointer
=	O
elt	pointer
->	O
prev	pointer
;	O
return	O
(	O
elt	pointer
)	O
;	O
}	O
void	O
remqueue	function
(	O
queue_t	pointer
que	pointer
,	O
register	O
queue_entry_t	pointer
elt	pointer
)	O
{	O
elt	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
elt	pointer
->	O
prev	pointer
;	O
elt	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
elt	pointer
->	O
next	pointer
;	O
}	O
void	O
insque	function
(	O
register	O
struct	O
queue_entry	struct
*	O
entry	pointer
,	O
register	O
struct	O
queue_entry	struct
*	O
pred	pointer
)	O
{	O
entry	pointer
->	O
next	pointer
=	O
pred	pointer
->	O
next	pointer
;	O
entry	pointer
->	O
prev	pointer
=	O
pred	pointer
;	O
(	O
pred	pointer
->	O
next	pointer
)	O
->	O
prev	pointer
=	O
entry	pointer
;	O
pred	pointer
->	O
next	pointer
=	O
entry	pointer
;	O
}	O
struct	O
queue_entry	struct
*	O
remque	function
(	O
register	O
struct	O
queue_entry	struct
*	O
elt	pointer
)	O
{	O
(	O
elt	pointer
->	O
next	pointer
)	O
->	O
prev	pointer
=	O
elt	pointer
->	O
prev	pointer
;	O
(	O
elt	pointer
->	O
prev	pointer
)	O
->	O
next	pointer
=	O
elt	pointer
->	O
next	pointer
;	O
return	O
(	O
elt	pointer
)	O
;	O
}	O
error_t	O
cons_switch	function
(	O
vcons_t	pointer
vcons	pointer
,	O
int	O
id	int
,	O
int	O
delta	int
,	O
vcons_t	struct
*	O
r_vcons	pointer
)	O
{	O
error_t	O
err	int
=	O
0	int
;	O
cons_t	O
cons	int
=	O
vcons	pointer
->	O
cons	int
;	O
vcons_list_t	pointer
vcons_entry	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
id	int
&&	O
!	O
delta	int
)	O
return	O
0	int
;	O
pthread_mutex_lock	function
(	O
&	O
cons	int
->	O
lock	O
)	O
;	O
if	O
(	O
id	int
)	O
{	O
vcons_entry	pointer
=	O
cons	pointer
->	O
vcons_list	struct
;	O
while	O
(	O
vcons_entry	pointer
&&	O
vcons_entry	pointer
->	O
id	int
!=	O
id	int
)	O
vcons_entry	pointer
=	O
vcons_entry	pointer
->	O
next	O
;	O
}	O
else	O
if	O
(	O
delta	int
>	O
0	int
)	O
{	O
vcons_entry	pointer
=	O
vcons	pointer
->	O
vcons_entry	pointer
;	O
while	O
(	O
delta	int
--	O
>	O
0	int
)	O
{	O
vcons_entry	pointer
=	O
vcons_entry	pointer
->	O
next	O
;	O
if	O
(	O
!	O
vcons_entry	pointer
)	O
vcons_entry	pointer
=	O
cons	O
->	O
vcons_list	O
;	O
}	O
}	O
else	O
{	O
assert	O
(	O
delta	int
<	O
0	int
)	O
;	O
vcons_entry	pointer
=	O
vcons	pointer
->	O
vcons_entry	pointer
;	O
while	O
(	O
delta	int
++	O
<	O
0	int
)	O
{	O
vcons_entry	pointer
=	O
vcons_entry	pointer
->	O
prev	O
;	O
if	O
(	O
!	O
vcons_entry	pointer
)	O
vcons_entry	pointer
=	O
cons	int
->	O
vcons_last	O
;	O
}	O
}	O
if	O
(	O
!	O
vcons_entry	pointer
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
cons	int
->	O
lock	O
)	O
;	O
return	O
ESRCH	int
;	O
}	O
if	O
(	O
vcons_entry	pointer
->	O
vcons	int
)	O
{	O
*	O
r_vcons	pointer
=	O
vcons_entry	pointer
->	O
vcons	O
;	O
pthread_mutex_lock	function
(	O
&	O
vcons_entry	pointer
->	O
vcons	O
->	O
lock	O
)	O
;	O
}	O
else	O
{	O
err	int
=	O
cons_vcons_open	function
(	O
cons	int
,	O
vcons_entry	pointer
,	O
r_vcons	O
)	O
;	O
if	O
(	O
!	O
err	int
)	O
vcons_entry	pointer
->	O
vcons	int
=	O
*	O
r_vcons	pointer
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
cons	int
->	O
lock	O
)	O
;	O
return	O
err	int
;	O
}	O
int	O
cons_demuxer	function
(	O
mach_msg_header_t	O
*	O
inp	pointer
,	O
mach_msg_header_t	O
*	O
outp	pointer
)	O
{	O
int	O
cons_fs_notify_server	function
(	O
mach_msg_header_t	O
*	O
inp	pointer
,	O
mach_msg_header_t	O
*	O
outp	pointer
)	O
;	O
return	O
(	O
cons_fs_notify_server	function
(	O
inp	pointer
,	O
outp	pointer
)	O
)	O
;	O
}	O
struct	O
port_bucket	O
*	O
cons_port_bucket	pointer
;	O
struct	O
port_class	O
*	O
cons_port_class	pointer
;	O
error_t	O
cons_init	function
(	O
void	O
)	O
{	O
error_t	int
err	O
;	O
cons_t	pointer
cons	O
;	O
cons_notify_t	O
dir_notify_port	int
;	O
mach_port_t	O
dir_notify	int
;	O
cons_port_bucket	pointer
=	O
ports_create_bucket	function
(	O
)	O
;	O
if	O
(	O
!	O
cons_port_bucket	int
)	O
return	O
errno	O
;	O
cons_port_class	int
=	O
ports_create_class	function
(	O
cons_vcons_destroy	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
cons_port_class	pointer
)	O
return	O
errno	O
;	O
cons	int
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
cons	pointer
)	O
)	O
;	O
if	O
(	O
!	O
cons	int
)	O
return	O
errno	O
;	O
pthread_mutex_init	function
(	O
&	O
cons	int
->	O
lock	O
,	O
NULL	O
)	O
;	O
cons	pointer
->	O
vcons_list	struct
=	O
NULL	O
;	O
cons	pointer
->	O
vcons_last	pointer
=	O
NULL	O
;	O
cons	int
->	O
dir	pointer
=	O
opendir	function
(	O
cons_file	pointer
)	O
;	O
cons	pointer
->	O
slack	pointer
=	O
_cons_slack	int
;	O
if	O
(	O
!	O
cons	int
->	O
dir	pointer
)	O
{	O
free	function
(	O
cons	pointer
)	O
;	O
return	O
errno	O
;	O
}	O
cons	pointer
->	O
dirport	int
=	O
getdport	function
(	O
dirfd	function
(	O
cons	int
->	O
dir	pointer
)	O
)	O
;	O
if	O
(	O
cons	int
->	O
dirport	int
==	O
MACH_PORT_NULL	O
)	O
{	O
closedir	function
(	O
cons	int
->	O
dir	pointer
)	O
;	O
free	function
(	O
cons	int
)	O
;	O
return	O
errno	O
;	O
}	O
err	int
=	O
ports_create_port	function
(	O
cons_port_class	pointer
,	O
cons_port_bucket	pointer
,	O
sizeof	O
(	O
*	O
dir_notify_port	pointer
)	O
,	O
&	O
dir_notify_port	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
cons	O
->	O
dirport	O
)	O
;	O
closedir	function
(	O
cons	O
->	O
dir	O
)	O
;	O
free	function
(	O
cons	O
)	O
;	O
return	O
err	O
;	O
}	O
dir_notify_port	pointer
->	O
cons	int
=	O
cons	int
;	O
dir_notify	int
=	O
ports_get_right	function
(	O
dir_notify_port	int
)	O
;	O
err	int
=	O
dir_notice_changes	function
(	O
cons	int
->	O
dirport	pointer
,	O
dir_notify	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
cons	int
->	O
dirport	O
)	O
;	O
closedir	function
(	O
cons	O
->	O
dir	O
)	O
;	O
free	function
(	O
cons	O
)	O
;	O
return	O
err	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
iohelp_put_shared_data	function
(	O
void	O
*	O
arg	pointer
)	O
{	O
struct	O
protid	O
*	O
cred	pointer
=	O
arg	pointer
;	O
cred	pointer
->	O
mapped	O
->	O
append_mode	O
=	O
(	O
cred	pointer
->	O
po	pointer
->	O
openstat	pointer
&	O
O_APPEND	int
)	O
;	O
cred	pointer
->	O
mapped	O
->	O
eof_notify	int
=	O
0	int
;	O
cred	pointer
->	O
mapped	O
->	O
do_sigio	O
=	O
(	O
cred	pointer
->	O
po	pointer
->	O
openstat	pointer
&	O
O_FSYNC	O
)	O
;	O
cred	pointer
->	O
mapped	O
->	O
use_file_size	int
=	O
1	int
;	O
cred	pointer
->	O
mapped	O
->	O
use_read_size	O
=	O
0	int
;	O
cred	pointer
->	O
mapped	O
->	O
optimal_transfer_size	O
=	O
cred	pointer
->	O
po	O
->	O
np	pointer
->	O
dn_stat	O
.	O
st_blksize	O
;	O
cred	pointer
->	O
mapped	O
->	O
seekable	O
=	O
1	int
;	O
cred	pointer
->	O
mapped	O
->	O
use_prenotify_size	int
=	O
1	int
;	O
cred	pointer
->	O
mapped	O
->	O
use_postnotify_size	O
=	O
0	int
;	O
cred	pointer
->	O
mapped	O
->	O
use_readnotify_size	O
=	O
0	int
;	O
cred	pointer
->	O
mapped	O
->	O
prenotify_size	O
=	O
cred	pointer
->	O
po	O
->	O
np	pointer
->	O
allocsize	O
;	O
cred	pointer
->	O
mapped	O
->	O
xx_file_pointer	O
=	O
cred	pointer
->	O
po	O
->	O
filepointer	O
;	O
cred	pointer
->	O
mapped	O
->	O
rd_file_pointer	int
=	O
-	O
1	int
;	O
cred	pointer
->	O
mapped	O
->	O
wr_file_pointer	int
=	O
-	O
1	int
;	O
cred	pointer
->	O
mapped	O
->	O
file_size	O
=	O
cred	pointer
->	O
po	O
->	O
np	pointer
->	O
dn_stat	O
.	O
st_size	O
;	O
cred	pointer
->	O
mapped	O
->	O
written	O
=	O
0	int
;	O
cred	pointer
->	O
mapped	O
->	O
accessed	O
=	O
0	int
;	O
}	O
error_t	O
fshelp_acquire_lock	function
(	O
struct	O
lock_box	struct
*	O
box	pointer
,	O
int	O
*	O
user	pointer
,	O
pthread_mutex_t	pointer
*	O
mut	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
atomic	int
=	O
0	int
;	O
if	O
(	O
!	O
(	O
flags	enum
&	O
(	O
LOCK_UN	enum
|	O
LOCK_EX	int
|	O
LOCK_SH	int
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
(	O
flags	enum
&	O
LOCK_UN	enum
)	O
&&	O
(	O
flags	int
&	O
(	O
LOCK_SH	int
|	O
LOCK_EX	int
)	O
)	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
flags	int
&	O
__LOCK_ATOMIC	int
)	O
{	O
atomic	int
=	O
1	int
;	O
flags	int
&=	O
~	O
__LOCK_ATOMIC	int
;	O
}	O
if	O
(	O
flags	int
&	O
LOCK_EX	int
)	O
flags	int
&=	O
~	O
LOCK_SH	int
;	O
if	O
(	O
flags	enum
&	O
LOCK_UN	int
)	O
{	O
if	O
(	O
*	O
user	pointer
&	O
LOCK_UN	double
)	O
return	O
0	int
;	O
assert	O
(	O
*	O
user	pointer
==	O
box	pointer
->	O
type	int
||	O
(	O
*	O
user	pointer
==	O
LOCK_SH	int
&&	O
box	pointer
->	O
type	enum
==	O
(	O
LOCK_SH	int
|	O
LOCK_EX	int
)	O
)	O
)	O
;	O
assert	O
(	O
*	O
user	pointer
==	O
LOCK_SH	int
||	O
*	O
user	pointer
==	O
LOCK_EX	int
||	O
*	O
user	pointer
==	O
(	O
LOCK_SH	int
|	O
LOCK_EX	int
)	O
)	O
;	O
if	O
(	O
*	O
user	pointer
==	O
LOCK_SH	int
)	O
{	O
if	O
(	O
!	O
--	O
box	pointer
->	O
shcount	int
)	O
box	pointer
->	O
type	enum
=	O
LOCK_UN	int
;	O
}	O
else	O
if	O
(	O
*	O
user	pointer
==	O
LOCK_EX	int
)	O
box	pointer
->	O
type	enum
=	O
LOCK_UN	int
;	O
if	O
(	O
box	pointer
->	O
type	enum
==	O
LOCK_UN	int
&&	O
box	pointer
->	O
waiting	int
)	O
{	O
box	pointer
->	O
waiting	int
=	O
0	int
;	O
pthread_cond_broadcast	function
(	O
&	O
box	pointer
->	O
wait	int
)	O
;	O
}	O
if	O
(	O
box	pointer
->	O
type	enum
==	O
(	O
LOCK_SH	int
|	O
LOCK_EX	int
)	O
&&	O
box	pointer
->	O
shcount	int
==	O
1	int
&&	O
box	pointer
->	O
waiting	int
)	O
{	O
box	pointer
->	O
waiting	int
=	O
0	int
;	O
pthread_cond_broadcast	function
(	O
&	O
box	pointer
->	O
wait	int
)	O
;	O
}	O
*	O
user	pointer
=	O
LOCK_UN	double
;	O
}	O
else	O
{	O
if	O
(	O
atomic	int
&&	O
*	O
user	pointer
==	O
(	O
flags	int
&	O
(	O
LOCK_SH	int
|	O
LOCK_EX	int
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
atomic	pointer
&&	O
*	O
user	pointer
==	O
LOCK_EX	int
&&	O
flags	int
&	O
LOCK_SH	int
)	O
{	O
*	O
user	pointer
=	O
LOCK_SH	int
;	O
box	pointer
->	O
type	enum
=	O
LOCK_SH	int
;	O
box	pointer
->	O
shcount	int
=	O
1	int
;	O
if	O
(	O
box	pointer
->	O
waiting	int
)	O
{	O
box	pointer
->	O
waiting	int
=	O
0	int
;	O
pthread_cond_broadcast	function
(	O
&	O
box	pointer
->	O
wait	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
*	O
user	pointer
==	O
LOCK_SH	int
&&	O
atomic	int
&&	O
box	pointer
->	O
type	enum
==	O
(	O
LOCK_SH	int
|	O
LOCK_EX	int
)	O
)	O
return	O
EDEADLK	int
;	O
if	O
(	O
*	O
user	pointer
==	O
LOCK_EX	int
&&	O
!	O
atomic	int
)	O
{	O
*	O
user	pointer
=	O
LOCK_UN	double
;	O
box	pointer
->	O
type	enum
=	O
LOCK_UN	int
;	O
if	O
(	O
box	pointer
->	O
waiting	int
)	O
{	O
box	pointer
->	O
waiting	int
=	O
0	int
;	O
pthread_cond_broadcast	function
(	O
&	O
box	pointer
->	O
wait	int
)	O
;	O
}	O
}	O
if	O
(	O
*	O
user	pointer
==	O
LOCK_SH	int
&&	O
!	O
atomic	int
)	O
{	O
*	O
user	pointer
=	O
LOCK_UN	double
;	O
if	O
(	O
!	O
--	O
box	pointer
->	O
shcount	int
)	O
{	O
box	pointer
->	O
type	enum
=	O
LOCK_UN	int
;	O
if	O
(	O
box	pointer
->	O
waiting	int
)	O
{	O
box	pointer
->	O
waiting	int
=	O
0	int
;	O
pthread_cond_broadcast	function
(	O
&	O
box	pointer
->	O
wait	int
)	O
;	O
}	O
}	O
if	O
(	O
box	pointer
->	O
type	enum
==	O
(	O
LOCK_SH	int
|	O
LOCK_EX	int
)	O
&&	O
box	pointer
->	O
shcount	int
==	O
1	int
&&	O
box	pointer
->	O
waiting	int
)	O
{	O
box	pointer
->	O
waiting	int
=	O
0	int
;	O
pthread_cond_broadcast	function
(	O
&	O
box	pointer
->	O
wait	int
)	O
;	O
}	O
}	O
while	O
(	O
box	pointer
->	O
type	enum
&	O
LOCK_EX	int
)	O
{	O
if	O
(	O
flags	int
&	O
LOCK_NB	int
)	O
return	O
EWOULDBLOCK	O
;	O
box	pointer
->	O
waiting	int
=	O
1	int
;	O
if	O
(	O
pthread_hurd_cond_wait_np	function
(	O
&	O
box	pointer
->	O
wait	int
,	O
mut	pointer
)	O
)	O
return	O
EINTR	int
;	O
}	O
assert	O
(	O
(	O
flags	int
&	O
LOCK_SH	int
)	O
||	O
(	O
flags	int
&	O
LOCK_EX	int
)	O
)	O
;	O
if	O
(	O
flags	int
&	O
LOCK_SH	int
)	O
{	O
assert	O
(	O
!	O
(	O
box	pointer
->	O
type	int
&	O
LOCK_EX	int
)	O
)	O
;	O
*	O
user	pointer
=	O
LOCK_SH	int
;	O
box	pointer
->	O
type	enum
=	O
LOCK_SH	int
;	O
box	pointer
->	O
shcount	int
++	O
;	O
}	O
else	O
if	O
(	O
flags	int
&	O
LOCK_EX	int
)	O
{	O
while	O
(	O
(	O
*	O
user	pointer
==	O
LOCK_SH	int
&&	O
box	pointer
->	O
shcount	int
>	O
1	int
)	O
||	O
(	O
*	O
user	pointer
==	O
LOCK_UN	short
&&	O
box	pointer
->	O
type	enum
!=	O
LOCK_UN	int
)	O
)	O
{	O
if	O
(	O
flags	int
&	O
LOCK_NB	int
)	O
return	O
EWOULDBLOCK	O
;	O
else	O
{	O
if	O
(	O
*	O
user	pointer
==	O
LOCK_SH	int
&&	O
atomic	int
)	O
box	pointer
->	O
type	enum
=	O
LOCK_SH	int
|	O
LOCK_EX	int
;	O
box	pointer
->	O
waiting	int
=	O
1	int
;	O
if	O
(	O
pthread_hurd_cond_wait_np	function
(	O
&	O
box	pointer
->	O
wait	int
,	O
mut	pointer
)	O
)	O
return	O
EINTR	int
;	O
}	O
}	O
if	O
(	O
*	O
user	pointer
==	O
LOCK_SH	int
)	O
{	O
assert	O
(	O
box	pointer
->	O
shcount	int
==	O
1	int
)	O
;	O
box	pointer
->	O
shcount	int
=	O
0	int
;	O
}	O
box	pointer
->	O
type	int
=	O
LOCK_EX	int
;	O
*	O
user	pointer
=	O
LOCK_EX	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
error_t	O
fshelp_start_translator	function
(	O
fshelp_open_fn_t	pointer
underlying_open_fn	pointer
,	O
void	O
*	O
cookie	pointer
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
argz	pointer
,	O
int	O
argz_len	pointer
,	O
int	O
timeout	int
,	O
fsys_t	O
*	O
control	pointer
)	O
{	O
mach_port_t	O
ports	pointer
[	O
INIT_PORT_MAX	int
]	O
;	O
mach_port_t	O
fds	pointer
[	O
STDERR_FILENO	int
+	O
1	int
]	O
;	O
int	O
ints	pointer
[	O
INIT_INT_MAX	int
]	O
;	O
int	O
i	int
;	O
error_t	int
err	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
INIT_PORT_MAX	int
;	O
i	int
++	O
)	O
ports	pointer
[	O
i	int
]	O
=	O
MACH_PORT_NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
STDERR_FILENO	int
+	O
1	int
;	O
i	int
++	O
)	O
fds	pointer
[	O
i	int
]	O
=	O
MACH_PORT_NULL	O
;	O
memset	function
(	O
ints	pointer
,	O
0	int
,	O
INIT_INT_MAX	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
ports	pointer
[	O
INIT_PORT_CWDIR	O
]	O
=	O
getcwdir	function
(	O
)	O
;	O
ports	pointer
[	O
INIT_PORT_CRDIR	O
]	O
=	O
getcrdir	function
(	O
)	O
;	O
ports	pointer
[	O
INIT_PORT_AUTH	O
]	O
=	O
getauth	function
(	O
)	O
;	O
fds	pointer
[	O
STDERR_FILENO	int
]	O
=	O
getdport	function
(	O
STDERR_FILENO	int
)	O
;	O
err	int
=	O
fshelp_start_translator_long	function
(	O
underlying_open_fn	pointer
,	O
cookie	pointer
,	O
name	pointer
,	O
argz	pointer
,	O
argz_len	pointer
,	O
fds	pointer
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
STDERR_FILENO	int
+	O
1	int
,	O
ports	pointer
,	O
MACH_MSG_TYPE_COPY_SEND	O
,	O
INIT_PORT_MAX	int
,	O
ints	pointer
,	O
INIT_INT_MAX	int
,	O
geteuid	function
(	O
)	O
,	O
timeout	int
,	O
control	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
INIT_PORT_MAX	int
;	O
i	int
++	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
ports	pointer
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
STDERR_FILENO	int
;	O
i	int
++	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
fds	pointer
[	O
i	int
]	O
)	O
;	O
return	O
err	int
;	O
}	O
void	O
fshelp_transbox_init	function
(	O
struct	O
transbox	struct
*	O
transbox	pointer
,	O
pthread_mutex_t	pointer
*	O
lock	pointer
,	O
void	O
*	O
cookie	pointer
)	O
{	O
transbox	pointer
->	O
active	int
=	O
MACH_PORT_NULL	O
;	O
transbox	pointer
->	O
flags	int
=	O
0	int
;	O
transbox	pointer
->	O
lock	pointer
=	O
lock	pointer
;	O
pthread_cond_init	function
(	O
&	O
transbox	pointer
->	O
wakeup	int
,	O
NULL	O
)	O
;	O
transbox	pointer
->	O
cookie	pointer
=	O
cookie	pointer
;	O
}	O
struct	O
translator	struct
{	O
struct	O
port_info	struct
*	O
pi	pointer
;	O
char	O
*	O
name	pointer
;	O
mach_port_t	O
active	int
;	O
}	O
;	O
static	O
struct	O
hurd_ihash	O
translator_ihash	pointer
=	O
HURD_IHASH_INITIALIZER	function
(	O
HURD_IHASH_NO_LOCP	O
)	O
;	O
static	O
pthread_mutex_t	O
translator_ihash_lock	pointer
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
static	O
void	O
translator_ihash_cleanup	function
(	O
void	O
*	O
element	pointer
,	O
void	O
*	O
arg	pointer
)	O
{	O
struct	O
translator	struct
*	O
translator	pointer
=	O
element	pointer
;	O
if	O
(	O
translator	pointer
->	O
pi	pointer
)	O
ports_port_deref	function
(	O
translator	pointer
->	O
pi	pointer
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
translator	pointer
->	O
active	int
)	O
;	O
free	function
(	O
translator	pointer
->	O
name	pointer
)	O
;	O
free	function
(	O
translator	pointer
)	O
;	O
}	O
error_t	O
fshelp_set_active_translator	function
(	O
struct	O
port_info	O
*	O
pi	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
mach_port_t	O
active	int
)	O
{	O
error_t	O
err	int
=	O
0	int
;	O
pthread_mutex_lock	function
(	O
&	O
translator_ihash_lock	pointer
)	O
;	O
if	O
(	O
!	O
translator_ihash	struct
.	O
cleanup	pointer
)	O
hurd_ihash_set_cleanup	function
(	O
&	O
translator_ihash	struct
,	O
translator_ihash_cleanup	pointer
,	O
NULL	O
)	O
;	O
struct	O
translator	struct
*	O
t	pointer
=	O
NULL	O
;	O
HURD_IHASH_ITERATE	function
(	O
&	O
translator_ihash	O
,	O
value	pointer
)	O
{	O
t	int
=	O
value	O
;	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
t	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
goto	O
update	pointer
;	O
}	O
t	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
translator	struct
)	O
)	O
;	O
if	O
(	O
!	O
t	pointer
)	O
{	O
err	int
=	O
errno	O
;	O
goto	O
out	O
;	O
}	O
t	pointer
->	O
active	int
=	O
MACH_PORT_NULL	O
;	O
t	pointer
->	O
pi	pointer
=	O
NULL	O
;	O
t	pointer
->	O
name	pointer
=	O
strdup	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
t	pointer
->	O
name	pointer
)	O
{	O
err	int
=	O
errno	O
;	O
free	function
(	O
t	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
err	O
=	O
hurd_ihash_add	function
(	O
&	O
translator_ihash	O
,	O
(	O
hurd_ihash_key_t	long
)	O
t	pointer
,	O
t	pointer
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
update	pointer
:	O
if	O
(	O
active	int
)	O
{	O
if	O
(	O
t	pointer
->	O
pi	pointer
!=	O
pi	int
)	O
{	O
mach_port_t	O
old	int
;	O
err	O
=	O
mach_port_request_notification	function
(	O
mach_task_self	function
(	O
)	O
,	O
active	int
,	O
MACH_NOTIFY_DEAD_NAME	O
,	O
0	int
,	O
pi	pointer
->	O
port_right	int
,	O
MACH_MSG_TYPE_MAKE_SEND_ONCE	O
,	O
&	O
old	O
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
if	O
(	O
old	int
!=	O
MACH_PORT_NULL	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
old	O
)	O
;	O
if	O
(	O
t	pointer
->	O
pi	pointer
)	O
ports_port_deref	function
(	O
t	pointer
->	O
pi	pointer
)	O
;	O
ports_port_ref	function
(	O
pi	pointer
)	O
;	O
t	pointer
->	O
pi	pointer
=	O
pi	pointer
;	O
}	O
if	O
(	O
MACH_PORT_VALID	function
(	O
t	pointer
->	O
active	int
)	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
t	pointer
->	O
active	int
)	O
;	O
mach_port_mod_refs	function
(	O
mach_task_self	function
(	O
)	O
,	O
active	int
,	O
MACH_PORT_RIGHT_SEND	int
,	O
+	O
1	int
)	O
;	O
t	pointer
->	O
active	int
=	O
active	int
;	O
}	O
else	O
hurd_ihash_remove	function
(	O
&	O
translator_ihash	O
,	O
(	O
hurd_ihash_key_t	long
)	O
t	int
)	O
;	O
out	O
:	O
pthread_mutex_unlock	function
(	O
&	O
translator_ihash_lock	O
)	O
;	O
return	O
err	int
;	O
}	O
error_t	O
fshelp_remove_active_translator	function
(	O
mach_port_t	O
active	int
)	O
{	O
error_t	O
err	int
=	O
0	int
;	O
pthread_mutex_lock	function
(	O
&	O
translator_ihash_lock	O
)	O
;	O
struct	O
translator	O
*	O
t	pointer
=	O
NULL	O
;	O
HURD_IHASH_ITERATE	function
(	O
&	O
translator_ihash	O
,	O
value	O
)	O
{	O
struct	O
translator	struct
*	O
v	pointer
=	O
value	pointer
;	O
if	O
(	O
active	int
==	O
v	struct
->	O
active	int
)	O
{	O
t	int
=	O
v	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
t	int
)	O
hurd_ihash_remove	function
(	O
&	O
translator_ihash	O
,	O
(	O
hurd_ihash_key_t	long
)	O
t	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
translator_ihash_lock	struct
)	O
;	O
return	O
err	int
;	O
}	O
error_t	O
fshelp_get_active_translators	function
(	O
char	O
*	O
*	O
translators	pointer
,	O
size_t	long
*	O
translators_len	pointer
,	O
fshelp_filter	pointer
filter	pointer
,	O
const	O
char	O
*	O
prefix	pointer
)	O
{	O
error_t	O
err	int
=	O
0	int
;	O
pthread_mutex_lock	function
(	O
&	O
translator_ihash_lock	pointer
)	O
;	O
if	O
(	O
prefix	pointer
&&	O
strlen	function
(	O
prefix	pointer
)	O
==	O
0	int
)	O
prefix	pointer
=	O
NULL	O
;	O
HURD_IHASH_ITERATE	function
(	O
&	O
translator_ihash	O
,	O
value	pointer
)	O
{	O
struct	O
translator	struct
*	O
t	pointer
=	O
value	pointer
;	O
if	O
(	O
prefix	pointer
!=	O
NULL	O
&&	O
(	O
strncmp	function
(	O
t	pointer
->	O
name	pointer
,	O
prefix	pointer
,	O
strlen	function
(	O
prefix	pointer
)	O
)	O
!=	O
0	int
||	O
t	pointer
->	O
name	pointer
[	O
strlen	function
(	O
prefix	pointer
)	O
]	O
!=	O
'/'	O
)	O
)	O
continue	O
;	O
if	O
(	O
filter	pointer
)	O
{	O
char	O
*	O
dir	pointer
=	O
strdup	function
(	O
t	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
{	O
err	pointer
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
err	O
=	O
filter	function
(	O
dirname	function
(	O
dir	pointer
)	O
)	O
;	O
free	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
err	O
)	O
{	O
err	int
=	O
0	int
;	O
continue	O
;	O
}	O
}	O
err	int
=	O
argz_add	function
(	O
translators	pointer
,	O
translators_len	pointer
,	O
&	O
t	pointer
->	O
name	pointer
[	O
prefix	O
?	O
strlen	function
(	O
prefix	pointer
)	O
+	O
1	int
:	O
0	int
]	O
)	O
;	O
if	O
(	O
err	O
)	O
break	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
translator_ihash_lock	O
)	O
;	O
return	O
err	int
;	O
}	O
static	O
error_t	O
_write	function
(	O
int	O
fd	int
,	O
const	O
void	O
*	O
buf	pointer
,	O
size_t	long
len	long
)	O
{	O
while	O
(	O
len	int
>	O
0	int
)	O
{	O
ssize_t	long
wr	long
=	O
write	function
(	O
fd	int
,	O
buf	pointer
,	O
len	long
)	O
;	O
if	O
(	O
wr	long
<	O
0	int
)	O
return	O
errno	O
;	O
else	O
if	O
(	O
wr	pointer
==	O
0	int
)	O
return	O
EPIPE	int
;	O
buf	pointer
+=	O
wr	pointer
;	O
len	int
-=	O
wr	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
error_t	int
_skip_write	function
(	O
int	O
fd	int
,	O
const	O
void	O
*	O
buf	pointer
,	O
size_t	long
len	long
,	O
size_t	long
*	O
skip	pointer
)	O
{	O
size_t	long
sk	long
=	O
*	O
skip	pointer
;	O
error_t	int
err	O
=	O
0	int
;	O
if	O
(	O
len	long
>	O
sk	int
)	O
{	O
err	int
=	O
_write	function
(	O
fd	int
,	O
buf	pointer
+	O
sk	pointer
,	O
len	long
-	O
sk	pointer
)	O
;	O
*	O
skip	pointer
=	O
0	int
;	O
}	O
else	O
*	O
skip	pointer
=	O
sk	pointer
-	O
len	long
;	O
return	O
err	int
;	O
}	O
static	O
error_t	int
_long_cmd	function
(	O
int	O
fd	int
,	O
const	O
char	O
*	O
cmd	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
size_t	long
skip	int
)	O
{	O
error_t	int
err	int
=	O
_skip_write	function
(	O
fd	pointer
,	O
cmd	pointer
,	O
strlen	function
(	O
cmd	pointer
)	O
,	O
&	O
skip	int
)	O
;	O
if	O
(	O
!	O
err	pointer
&&	O
arg	pointer
)	O
{	O
err	int
=	O
_skip_write	function
(	O
fd	int
,	O
" "	pointer
,	O
1	int
,	O
&	O
skip	int
)	O
;	O
if	O
(	O
!	O
err	pointer
)	O
err	function
=	O
_skip_write	function
(	O
fd	int
,	O
arg	pointer
,	O
strlen	function
(	O
arg	pointer
)	O
,	O
&	O
skip	int
)	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
_skip_write	function
(	O
fd	int
,	O
"\r\n"	pointer
,	O
2	int
,	O
&	O
skip	int
)	O
;	O
return	O
err	int
;	O
}	O
error_t	function
ftp_conn_cmd	function
(	O
struct	O
ftp_conn	struct
*	O
conn	pointer
,	O
const	O
char	O
*	O
cmd	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
int	O
*	O
reply	pointer
,	O
const	O
char	O
*	O
*	O
reply_txt	pointer
)	O
{	O
error_t	int
err	int
=	O
0	int
;	O
if	O
(	O
conn	pointer
->	O
control	int
<	O
0	int
)	O
err	int
=	O
EPIPE	int
;	O
else	O
{	O
char	O
buf	pointer
[	O
200	int
]	O
;	O
size_t	long
out	pointer
=	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
arg	pointer
?	O
"%s %s\r\n"	pointer
:	O
"%s\r\n"	pointer
,	O
cmd	pointer
,	O
arg	pointer
)	O
;	O
err	int
=	O
_write	function
(	O
conn	pointer
->	O
control	int
,	O
buf	pointer
,	O
out	pointer
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
conn	pointer
->	O
hooks	pointer
&&	O
conn	pointer
->	O
hooks	pointer
->	O
cntl_debug	pointer
)	O
{	O
buf	pointer
[	O
out	pointer
-	O
2	int
]	O
=	O
'\0'	O
;	O
(	O
*	O
conn	pointer
->	O
hooks	pointer
->	O
cntl_debug	pointer
)	O
(	O
conn	pointer
,	O
FTP_CONN_CNTL_DEBUG_CMD	pointer
,	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
!	O
err	pointer
&&	O
out	pointer
==	O
sizeof	O
buf	pointer
)	O
err	int
=	O
_long_cmd	function
(	O
conn	pointer
->	O
control	pointer
,	O
cmd	int
,	O
arg	pointer
,	O
sizeof	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
!	O
err	int
&&	O
(	O
reply	pointer
||	O
reply_txt	pointer
)	O
)	O
err	function
=	O
ftp_conn_get_reply	function
(	O
conn	pointer
,	O
reply	pointer
,	O
reply_txt	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	function
ftp_conn_cmd_reopen	function
(	O
struct	O
ftp_conn	struct
*	O
conn	pointer
,	O
const	O
char	O
*	O
cmd	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
int	O
*	O
reply	pointer
,	O
const	O
char	O
*	O
*	O
reply_txt	pointer
)	O
{	O
int	O
_reply	int
;	O
error_t	int
err	int
;	O
err	function
=	O
ftp_conn_cmd	function
(	O
conn	pointer
,	O
cmd	pointer
,	O
arg	pointer
,	O
&	O
_reply	pointer
,	O
reply_txt	pointer
)	O
;	O
if	O
(	O
err	int
==	O
EPIPE	int
||	O
(	O
!	O
err	int
&&	O
_reply	int
==	O
REPLY_CLOSED	int
)	O
)	O
{	O
err	int
=	O
ftp_conn_open	function
(	O
conn	pointer
)	O
;	O
if	O
(	O
!	O
err	function
)	O
err	function
=	O
ftp_conn_cmd	function
(	O
conn	pointer
,	O
cmd	pointer
,	O
arg	pointer
,	O
reply	pointer
,	O
reply_txt	pointer
)	O
;	O
}	O
else	O
if	O
(	O
reply	pointer
)	O
*	O
reply	pointer
=	O
_reply	int
;	O
return	O
err	int
;	O
}	O
void	O
ftp_conn_abort	function
(	O
struct	O
ftp_conn	struct
*	O
conn	pointer
)	O
{	O
if	O
(	O
conn	pointer
->	O
control	int
>=	O
0	int
)	O
{	O
static	O
const	O
char	O
ip	pointer
[	O
]	O
=	O
{	O
IAC	pointer
,	O
IP	pointer
,	O
IAC	int
}	O
;	O
static	O
const	O
char	O
abor	array
[	O
]	O
=	O
{	O
DM	pointer
,	O
'a'	O
,	O
'b'	O
,	O
'o'	O
,	O
'r'	O
,	O
'\r'	O
,	O
'\n'	O
}	O
;	O
if	O
(	O
conn	pointer
->	O
hooks	pointer
&&	O
conn	pointer
->	O
hooks	pointer
->	O
cntl_debug	pointer
)	O
(	O
*	O
conn	pointer
->	O
hooks	pointer
->	O
cntl_debug	pointer
)	O
(	O
conn	pointer
,	O
FTP_CONN_CNTL_DEBUG_CMD	pointer
,	O
"abor"	pointer
)	O
;	O
if	O
(	O
send	function
(	O
conn	pointer
->	O
control	int
,	O
ip	pointer
,	O
sizeof	O
ip	pointer
,	O
MSG_OOB	int
)	O
==	O
sizeof	O
ip	pointer
&&	O
write	function
(	O
conn	pointer
->	O
control	int
,	O
abor	pointer
,	O
sizeof	O
abor	pointer
)	O
==	O
sizeof	O
abor	pointer
)	O
{	O
int	O
reply	pointer
;	O
do	O
ftp_conn_get_raw_reply	function
(	O
conn	pointer
,	O
&	O
reply	pointer
,	O
0	int
)	O
;	O
while	O
(	O
reply	pointer
==	O
REPLY_ABORTED	pointer
)	O
;	O
if	O
(	O
reply	pointer
!=	O
REPLY_TRANS_OK	int
&&	O
reply	pointer
!=	O
REPLY_ABORT_OK	int
)	O
ftp_conn_close	function
(	O
conn	pointer
)	O
;	O
}	O
else	O
ftp_conn_close	function
(	O
conn	pointer
)	O
;	O
}	O
}	O
struct	O
get_names_state	struct
{	O
char	O
*	O
name	pointer
;	O
size_t	long
name_len	long
;	O
size_t	long
name_alloced	long
;	O
int	O
name_partial	int
;	O
size_t	long
buf_len	long
;	O
char	O
buf	pointer
[	O
7000	O
]	O
;	O
}	O
;	O
error_t	int
ftp_conn_start_get_names	function
(	O
struct	O
ftp_conn	struct
*	O
conn	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
*	O
fd	pointer
,	O
void	O
*	O
*	O
state	pointer
)	O
{	O
error_t	function
err	O
;	O
struct	O
get_names_state	struct
*	O
s	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
get_names_state	struct
)	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
ENOMEM	int
;	O
err	int
=	O
ftp_conn_start_list	function
(	O
conn	pointer
,	O
name	pointer
,	O
fd	pointer
)	O
;	O
if	O
(	O
err	pointer
)	O
free	function
(	O
s	pointer
)	O
;	O
else	O
{	O
s	pointer
->	O
name	pointer
=	O
0	int
;	O
s	pointer
->	O
name_len	long
=	O
s	pointer
->	O
name_alloced	int
=	O
0	int
;	O
s	pointer
->	O
name_partial	int
=	O
0	int
;	O
s	pointer
->	O
buf_len	long
=	O
0	int
;	O
*	O
state	pointer
=	O
s	pointer
;	O
}	O
return	O
err	int
;	O
}	O
error_t	int
ftp_conn_cont_get_names	function
(	O
struct	O
ftp_conn	struct
*	O
conn	pointer
,	O
int	O
fd	int
,	O
void	O
*	O
state	pointer
,	O
ftp_conn_add_name_fun_t	pointer
add_name	pointer
,	O
void	O
*	O
hook	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
nl	pointer
;	O
ssize_t	long
rd	int
;	O
size_t	long
name_len	long
;	O
error_t	int
err	int
=	O
0	int
;	O
struct	O
get_names_state	struct
*	O
s	pointer
=	O
state	pointer
;	O
int	O
(	O
*	O
icheck	pointer
)	O
(	O
struct	O
ftp_conn	struct
*	O
conn	pointer
)	O
=	O
conn	pointer
->	O
hooks	pointer
->	O
interrupt_check	pointer
;	O
rd	int
=	O
read	pointer
(	O
fd	int
,	O
s	pointer
->	O
buf	pointer
+	O
s	pointer
->	O
buf_len	long
,	O
sizeof	O
(	O
s	pointer
->	O
buf	pointer
)	O
-	O
s	pointer
->	O
buf_len	long
)	O
;	O
if	O
(	O
rd	int
<	O
0	int
)	O
{	O
err	int
=	O
errno	O
;	O
goto	O
finished	O
;	O
}	O
if	O
(	O
icheck	pointer
&&	O
(	O
*	O
icheck	pointer
)	O
(	O
conn	pointer
)	O
)	O
{	O
err	int
=	O
EINTR	int
;	O
goto	O
finished	O
;	O
}	O
if	O
(	O
rd	int
==	O
0	int
)	O
if	O
(	O
s	pointer
->	O
buf_len	long
==	O
0	int
)	O
goto	O
finished	O
;	O
else	O
nl	pointer
=	O
s	pointer
->	O
buf	pointer
+	O
s	pointer
->	O
buf_len	long
;	O
else	O
{	O
nl	pointer
=	O
memchr	function
(	O
s	pointer
->	O
buf	pointer
+	O
s	pointer
->	O
buf_len	long
,	O
'\n'	O
,	O
rd	int
)	O
;	O
s	pointer
->	O
buf_len	long
+=	O
rd	int
;	O
}	O
if	O
(	O
!	O
nl	pointer
&&	O
s	pointer
->	O
buf_len	long
<	O
sizeof	O
(	O
s	pointer
->	O
buf	pointer
)	O
)	O
return	O
EAGAIN	int
;	O
p	pointer
=	O
s	pointer
->	O
buf	pointer
;	O
do	O
{	O
name_len	long
=	O
(	O
nl	pointer
?	O
nl	pointer
-	O
p	pointer
:	O
s	pointer
->	O
buf	pointer
+	O
s	pointer
->	O
buf_len	long
-	O
p	pointer
)	O
;	O
if	O
(	O
name_len	int
>	O
0	int
&&	O
p	pointer
[	O
name_len	int
-	O
1	int
]	O
==	O
'\r'	O
)	O
name_len	long
--	O
;	O
if	O
(	O
name_len	int
>	O
0	int
)	O
{	O
size_t	long
old_len	long
=	O
s	pointer
->	O
name_len	long
;	O
size_t	long
total_len	long
=	O
old_len	long
+	O
name_len	long
+	O
1	int
;	O
if	O
(	O
total_len	long
>	O
s	pointer
->	O
name_alloced	int
)	O
{	O
char	O
*	O
new_name	pointer
=	O
realloc	function
(	O
s	pointer
->	O
name	pointer
,	O
total_len	pointer
)	O
;	O
if	O
(	O
!	O
new_name	pointer
)	O
goto	O
enomem	O
;	O
s	pointer
->	O
name	pointer
=	O
new_name	pointer
;	O
s	pointer
->	O
name_alloced	int
=	O
total_len	int
;	O
}	O
strncpy	function
(	O
s	pointer
->	O
name	pointer
+	O
old_len	long
,	O
p	pointer
,	O
name_len	int
)	O
;	O
s	pointer
->	O
name	pointer
[	O
old_len	int
+	O
name_len	int
]	O
=	O
'\0'	O
;	O
s	pointer
->	O
name_len	long
=	O
total_len	int
-	O
1	int
;	O
}	O
if	O
(	O
nl	pointer
)	O
{	O
char	O
*	O
name	pointer
=	O
s	pointer
->	O
name	pointer
;	O
if	O
(	O
conn	pointer
->	O
syshooks	struct
.	O
basename	pointer
)	O
{	O
err	pointer
=	O
(	O
*	O
conn	pointer
->	O
syshooks	struct
.	O
basename	pointer
)	O
(	O
conn	pointer
,	O
&	O
name	pointer
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
finished	O
;	O
}	O
err	pointer
=	O
(	O
*	O
add_name	pointer
)	O
(	O
name	pointer
,	O
hook	pointer
)	O
;	O
if	O
(	O
name	pointer
<	O
s	pointer
->	O
name	pointer
||	O
name	pointer
>	O
s	pointer
->	O
name	pointer
+	O
s	pointer
->	O
name_len	long
)	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
err	O
)	O
goto	O
finished	O
;	O
s	pointer
->	O
name_len	long
=	O
0	int
;	O
s	pointer
->	O
name_partial	int
=	O
0	int
;	O
p	pointer
=	O
nl	pointer
+	O
1	int
;	O
nl	pointer
=	O
memchr	function
(	O
p	pointer
,	O
'\n'	O
,	O
s	pointer
->	O
buf	pointer
+	O
s	pointer
->	O
buf_len	long
-	O
p	pointer
)	O
;	O
}	O
else	O
{	O
s	pointer
->	O
name_partial	int
=	O
1	int
;	O
p	pointer
+=	O
name_len	int
;	O
}	O
}	O
while	O
(	O
nl	pointer
)	O
;	O
s	pointer
->	O
buf_len	long
-=	O
(	O
p	pointer
-	O
s	pointer
->	O
buf	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
buf_len	long
>	O
0	int
)	O
memmove	function
(	O
s	pointer
->	O
buf	pointer
,	O
p	pointer
,	O
s	pointer
->	O
buf_len	long
)	O
;	O
return	O
EAGAIN	int
;	O
enomem	O
:	O
err	pointer
=	O
ENOMEM	int
;	O
finished	O
:	O
if	O
(	O
s	pointer
->	O
name	pointer
)	O
free	function
(	O
s	pointer
->	O
name	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
close	function
(	O
fd	int
)	O
;	O
if	O
(	O
err	int
&&	O
rd	int
>	O
0	int
)	O
ftp_conn_abort	function
(	O
conn	pointer
)	O
;	O
else	O
if	O
(	O
err	int
)	O
ftp_conn_finish_transfer	function
(	O
conn	pointer
)	O
;	O
else	O
err	pointer
=	O
ftp_conn_finish_transfer	function
(	O
conn	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	int
ftp_conn_get_names	function
(	O
struct	O
ftp_conn	struct
*	O
conn	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
ftp_conn_add_name_fun_t	pointer
add_name	pointer
,	O
void	O
*	O
hook	pointer
)	O
{	O
int	O
fd	int
;	O
void	O
*	O
state	pointer
;	O
error_t	int
err	int
=	O
ftp_conn_start_get_names	function
(	O
conn	pointer
,	O
name	pointer
,	O
&	O
fd	pointer
,	O
&	O
state	pointer
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
do	O
err	int
=	O
ftp_conn_cont_get_names	function
(	O
conn	pointer
,	O
fd	int
,	O
state	pointer
,	O
add_name	pointer
,	O
hook	pointer
)	O
;	O
while	O
(	O
err	int
==	O
EAGAIN	int
)	O
;	O
return	O
err	pointer
;	O
}	O
void	O
iohelp_handle_io_release_conch	function
(	O
struct	O
conch	struct
*	O
c	pointer
,	O
void	O
*	O
user	pointer
)	O
{	O
struct	O
shared_io	O
*	O
user_sh	pointer
=	O
c	pointer
->	O
holder_shared_page	pointer
;	O
pthread_spin_lock	function
(	O
&	O
user_sh	pointer
->	O
lock	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
holder_shared_page	pointer
->	O
conch_status	O
!=	O
USER_HAS_NOT_CONCH	O
)	O
{	O
c	pointer
->	O
holder_shared_page	pointer
->	O
conch_status	O
=	O
USER_HAS_NOT_CONCH	O
;	O
iohelp_fetch_shared_data	function
(	O
c	pointer
->	O
holder	pointer
)	O
;	O
}	O
pthread_spin_unlock	function
(	O
&	O
user_sh	pointer
->	O
lock	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
holder	pointer
==	O
user	pointer
)	O
{	O
c	pointer
->	O
holder	pointer
=	O
0	int
;	O
c	pointer
->	O
holder_shared_page	pointer
=	O
0	int
;	O
}	O
pthread_cond_broadcast	function
(	O
&	O
c	pointer
->	O
wait	int
)	O
;	O
}	O
int	O
netfs_demuxer	function
(	O
mach_msg_header_t	O
*	O
inp	pointer
,	O
mach_msg_header_t	O
*	O
outp	pointer
)	O
{	O
mig_routine_t	O
routine	O
;	O
if	O
(	O
(	O
routine	O
=	O
netfs_io_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
netfs_fs_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
ports_notify_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
netfs_fsys_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
ports_interrupt_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
netfs_ifsock_server_routine	function
(	O
inp	pointer
)	O
)	O
)	O
{	O
(	O
*	O
routine	O
)	O
(	O
inp	pointer
,	O
outp	pointer
)	O
;	O
return	O
TRUE	O
;	O
}	O
else	O
return	O
FALSE	O
;	O
}	O
static	O
inline	O
int	O
page_aligned	function
(	O
vm_offset_t	O
num	int
)	O
{	O
return	O
trunc_page	function
(	O
num	pointer
)	O
==	O
num	int
;	O
}	O
static	O
error_t	int
stream_write	function
(	O
struct	O
pq	struct
*	O
pq	pointer
,	O
void	O
*	O
source	pointer
,	O
char	O
*	O
data	pointer
,	O
size_t	long
data_len	long
,	O
size_t	long
*	O
amount	pointer
)	O
{	O
struct	O
packet	struct
*	O
packet	struct
=	O
pq_tail	function
(	O
pq	struct
,	O
PACKET_TYPE_DATA	int
,	O
source	pointer
)	O
;	O
if	O
(	O
packet_readable	function
(	O
packet	struct
)	O
>	O
0	int
&&	O
data_len	int
>	O
PACKET_SIZE_LARGE	pointer
&&	O
(	O
!	O
page_aligned	function
(	O
data	pointer
-	O
packet	pointer
->	O
buf_end	pointer
)	O
||	O
!	O
packet_ensure_efficiently	function
(	O
packet	struct
,	O
data_len	long
)	O
)	O
)	O
packet	struct
=	O
pq_queue	function
(	O
pq	struct
,	O
PACKET_TYPE_DATA	int
,	O
source	pointer
)	O
;	O
if	O
(	O
!	O
packet	struct
)	O
return	O
ENOBUFS	int
;	O
else	O
return	O
packet_write	function
(	O
packet	struct
,	O
data	pointer
,	O
data_len	long
,	O
amount	pointer
)	O
;	O
}	O
static	O
error_t	int
stream_read	function
(	O
struct	O
packet	struct
*	O
packet	struct
,	O
int	O
*	O
dequeue	pointer
,	O
unsigned	O
*	O
flags	pointer
,	O
char	O
*	O
*	O
data	pointer
,	O
size_t	long
*	O
data_len	long
,	O
size_t	long
amount	pointer
)	O
{	O
error_t	O
err	int
;	O
if	O
(	O
flags	int
&&	O
*	O
flags	pointer
&	O
MSG_PEEK	int
)	O
{	O
err	int
=	O
packet_peek	function
(	O
packet	struct
,	O
data	pointer
,	O
data_len	long
,	O
amount	pointer
)	O
;	O
*	O
dequeue	pointer
=	O
0	int
;	O
}	O
else	O
{	O
err	int
=	O
packet_read	function
(	O
packet	struct
,	O
data	pointer
,	O
data_len	long
,	O
amount	pointer
)	O
;	O
*	O
dequeue	pointer
=	O
(	O
packet_readable	function
(	O
packet	struct
)	O
==	O
0	int
)	O
;	O
}	O
return	O
err	int
;	O
}	O
struct	O
pipe_class	struct
_stream_pipe_class	struct
=	O
{	O
SOCK_STREAM	int
,	O
0	int
,	O
stream_read	function
,	O
stream_write	function
}	O
;	O
struct	O
pipe_class	struct
*	O
stream_pipe_class	pointer
=	O
&	O
_stream_pipe_class	struct
;	O
error_t	O
store_std_leaf_decode	function
(	O
struct	O
store_enc	struct
*	O
enc	pointer
,	O
store_std_leaf_create_t	pointer
create	pointer
,	O
struct	O
store	struct
*	O
*	O
store	struct
)	O
{	O
char	O
*	O
misc	pointer
,	O
*	O
name	pointer
;	O
error_t	O
err	O
;	O
int	O
flags	int
;	O
mach_port_t	O
port	int
;	O
size_t	long
block_size	long
,	O
num_runs	long
,	O
name_len	long
,	O
misc_len	long
;	O
error_t	O
call_create	function
(	O
const	O
struct	O
store_run	struct
*	O
runs	pointer
,	O
size_t	long
num_runs	long
)	O
{	O
return	O
(	O
*	O
create	pointer
)	O
(	O
port	int
,	O
flags	int
,	O
block_size	long
,	O
runs	pointer
,	O
num_runs	long
,	O
store	struct
)	O
;	O
}	O
if	O
(	O
enc	pointer
->	O
cur_int	long
+	O
6	int
>	O
enc	pointer
->	O
num_ints	int
||	O
enc	pointer
->	O
cur_port	long
+	O
1	int
>	O
enc	pointer
->	O
num_ports	int
)	O
return	O
EINVAL	int
;	O
enc	pointer
->	O
cur_int	long
++	O
;	O
flags	int
=	O
enc	pointer
->	O
ints	pointer
[	O
enc	pointer
->	O
cur_int	long
++	O
]	O
;	O
block_size	long
=	O
enc	pointer
->	O
ints	pointer
[	O
enc	pointer
->	O
cur_int	long
++	O
]	O
;	O
num_runs	long
=	O
enc	pointer
->	O
ints	pointer
[	O
enc	pointer
->	O
cur_int	long
++	O
]	O
;	O
name_len	long
=	O
enc	pointer
->	O
ints	pointer
[	O
enc	pointer
->	O
cur_int	long
++	O
]	O
;	O
misc_len	long
=	O
enc	pointer
->	O
ints	pointer
[	O
enc	pointer
->	O
cur_int	long
++	O
]	O
;	O
if	O
(	O
enc	pointer
->	O
cur_offset	long
+	O
num_runs	long
*	O
2	int
>	O
enc	pointer
->	O
num_offsets	int
||	O
enc	pointer
->	O
cur_data	long
+	O
name_len	long
+	O
misc_len	long
>	O
enc	pointer
->	O
data_len	int
)	O
return	O
EINVAL	int
;	O
if	O
(	O
name_len	long
>	O
0	int
&&	O
enc	pointer
->	O
data	pointer
[	O
enc	pointer
->	O
cur_data	long
+	O
name_len	long
-	O
1	int
]	O
!=	O
'\0'	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
name_len	long
>	O
0	int
)	O
{	O
name	pointer
=	O
strdup	function
(	O
enc	pointer
->	O
data	pointer
+	O
enc	pointer
->	O
cur_data	long
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
ENOMEM	int
;	O
enc	pointer
->	O
cur_data	long
+=	O
name_len	long
;	O
}	O
else	O
name	pointer
=	O
0	int
;	O
if	O
(	O
misc_len	long
>	O
0	int
)	O
{	O
misc	pointer
=	O
malloc	function
(	O
misc_len	long
)	O
;	O
if	O
(	O
!	O
misc	pointer
)	O
{	O
if	O
(	O
name	pointer
)	O
free	function
(	O
name	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
memcpy	function
(	O
misc	pointer
,	O
enc	pointer
->	O
data	pointer
+	O
enc	pointer
->	O
cur_data	long
+	O
name_len	long
,	O
misc_len	long
)	O
;	O
enc	pointer
->	O
cur_data	long
+=	O
misc_len	long
;	O
}	O
else	O
misc	pointer
=	O
0	int
;	O
port	int
=	O
enc	pointer
->	O
ports	pointer
[	O
enc	pointer
->	O
cur_port	long
++	O
]	O
;	O
err	int
=	O
store_with_decoded_runs	function
(	O
enc	pointer
,	O
num_runs	long
,	O
call_create	pointer
)	O
;	O
if	O
(	O
err	function
)	O
{	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
port	O
)	O
;	O
if	O
(	O
misc	pointer
)	O
free	function
(	O
misc	pointer
)	O
;	O
if	O
(	O
name	pointer
)	O
free	function
(	O
name	pointer
)	O
;	O
}	O
else	O
{	O
(	O
*	O
store	struct
)	O
->	O
flags	int
=	O
flags	int
;	O
(	O
*	O
store	struct
)	O
->	O
name	pointer
=	O
name	pointer
;	O
(	O
*	O
store	struct
)	O
->	O
misc	pointer
=	O
misc	pointer
;	O
(	O
*	O
store	struct
)	O
->	O
misc_len	long
=	O
misc_len	long
;	O
}	O
return	O
err	int
;	O
}	O
error_t	O
store_with_decoded_runs	function
(	O
struct	O
store_enc	struct
*	O
enc	pointer
,	O
size_t	long
num_runs	long
,	O
error_t	function
(	O
*	O
fun	pointer
)	O
(	O
const	O
struct	O
store_run	struct
*	O
runs	pointer
,	O
size_t	long
num_runs	long
)	O
)	O
{	O
int	O
i	long
;	O
error_t	O
err	int
;	O
if	O
(	O
num_runs	long
<=	O
MAX_STACK_RUNS	int
)	O
{	O
struct	O
store_run	struct
runs	pointer
[	O
num_runs	long
]	O
;	O
off_t	long
*	O
e	pointer
=	O
enc	pointer
->	O
offsets	pointer
+	O
enc	pointer
->	O
cur_offset	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_runs	long
;	O
i	int
++	O
)	O
{	O
runs	pointer
[	O
i	int
]	O
.	O
start	long
=	O
*	O
e	pointer
++	O
;	O
runs	pointer
[	O
i	int
]	O
.	O
length	long
=	O
*	O
e	pointer
++	O
;	O
}	O
enc	pointer
->	O
cur_offset	long
=	O
e	int
-	O
enc	pointer
->	O
offsets	pointer
;	O
err	O
=	O
(	O
*	O
fun	pointer
)	O
(	O
runs	pointer
,	O
num_runs	long
)	O
;	O
}	O
else	O
{	O
struct	O
store_run	struct
*	O
runs	pointer
=	O
malloc	function
(	O
num_runs	long
*	O
sizeof	O
(	O
struct	O
store_run	struct
)	O
)	O
;	O
if	O
(	O
runs	pointer
)	O
{	O
off_t	long
*	O
e	pointer
=	O
enc	pointer
->	O
offsets	pointer
+	O
enc	pointer
->	O
cur_offset	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_runs	long
;	O
i	long
++	O
)	O
{	O
runs	pointer
[	O
i	int
]	O
.	O
start	long
=	O
*	O
e	pointer
++	O
;	O
runs	pointer
[	O
i	int
]	O
.	O
length	long
=	O
*	O
e	pointer
++	O
;	O
}	O
enc	pointer
->	O
cur_offset	long
=	O
e	int
-	O
enc	pointer
->	O
offsets	pointer
;	O
err	O
=	O
(	O
*	O
fun	pointer
)	O
(	O
runs	pointer
,	O
num_runs	long
)	O
;	O
free	function
(	O
runs	pointer
)	O
;	O
}	O
else	O
err	int
=	O
ENOMEM	int
;	O
}	O
return	O
err	function
;	O
}	O
error_t	function
store_decode	function
(	O
struct	O
store_enc	struct
*	O
enc	pointer
,	O
const	O
struct	O
store_class	struct
*	O
const	O
*	O
classes	pointer
,	O
struct	O
store	struct
*	O
*	O
store	struct
)	O
{	O
const	O
struct	O
store_class	struct
*	O
const	O
*	O
cl	pointer
;	O
if	O
(	O
enc	pointer
->	O
cur_int	long
>=	O
enc	pointer
->	O
num_ints	int
)	O
return	O
EINVAL	int
;	O
if	O
(	O
enc	pointer
->	O
ints	pointer
[	O
enc	pointer
->	O
cur_int	long
]	O
==	O
STORAGE_NETWORK	int
)	O
return	O
store_url_decode	function
(	O
enc	pointer
,	O
classes	pointer
,	O
store	struct
)	O
;	O
for	O
(	O
cl	O
=	O
classes	pointer
?	O
:	O
__start_store_std_classes	pointer
;	O
classes	pointer
?	O
*	O
cl	pointer
!=	O
0	int
:	O
cl	int
<	O
__stop_store_std_classes	int
;	O
++	O
cl	pointer
)	O
if	O
(	O
(	O
*	O
cl	pointer
)	O
->	O
id	int
==	O
enc	pointer
->	O
ints	pointer
[	O
enc	pointer
->	O
cur_int	long
]	O
)	O
{	O
if	O
(	O
(	O
*	O
cl	pointer
)	O
->	O
decode	pointer
)	O
return	O
(	O
*	O
(	O
*	O
cl	pointer
)	O
->	O
decode	pointer
)	O
(	O
enc	pointer
,	O
classes	pointer
,	O
store	struct
)	O
;	O
else	O
return	O
EOPNOTSUPP	O
;	O
}	O
if	O
(	O
!	O
classes	pointer
&&	O
store_module_decode	pointer
)	O
{	O
error_t	int
err	O
=	O
store_module_decode	function
(	O
enc	pointer
,	O
classes	pointer
,	O
store	struct
)	O
;	O
if	O
(	O
err	function
!=	O
ENOENT	int
)	O
return	O
err	O
;	O
}	O
return	O
EINVAL	int
;	O
}	O
void	O
store_enc_init	function
(	O
struct	O
store_enc	struct
*	O
enc	pointer
,	O
mach_port_t	O
*	O
ports	pointer
,	O
mach_msg_type_number_t	O
num_ports	int
,	O
int	O
*	O
ints	pointer
,	O
mach_msg_type_number_t	O
num_ints	int
,	O
off_t	long
*	O
offsets	pointer
,	O
mach_msg_type_number_t	O
num_offsets	int
,	O
char	O
*	O
data	pointer
,	O
mach_msg_type_number_t	O
data_len	int
)	O
{	O
memset	function
(	O
enc	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
enc	pointer
)	O
)	O
;	O
enc	pointer
->	O
ports	pointer
=	O
enc	pointer
->	O
init_ports	pointer
=	O
ports	pointer
;	O
enc	pointer
->	O
num_ports	int
=	O
num_ports	int
;	O
enc	pointer
->	O
ints	pointer
=	O
enc	pointer
->	O
init_ints	pointer
=	O
ints	pointer
;	O
enc	pointer
->	O
num_ints	int
=	O
num_ints	int
;	O
enc	pointer
->	O
offsets	pointer
=	O
enc	pointer
->	O
init_offsets	pointer
=	O
offsets	pointer
;	O
enc	pointer
->	O
num_offsets	int
=	O
num_offsets	int
;	O
enc	pointer
->	O
data	pointer
=	O
enc	pointer
->	O
init_data	pointer
=	O
data	pointer
;	O
enc	pointer
->	O
data_len	int
=	O
data_len	int
;	O
}	O
void	O
store_enc_dealloc	function
(	O
struct	O
store_enc	struct
*	O
enc	pointer
)	O
{	O
if	O
(	O
enc	pointer
->	O
ports	pointer
&&	O
enc	pointer
->	O
num_ports	int
>	O
0	int
)	O
{	O
while	O
(	O
enc	pointer
->	O
cur_port	long
<	O
enc	pointer
->	O
num_ports	int
)	O
{	O
mach_port_t	O
port	int
=	O
enc	pointer
->	O
ports	pointer
[	O
enc	pointer
->	O
cur_port	long
++	O
]	O
;	O
if	O
(	O
port	int
!=	O
MACH_PORT_NULL	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
port	O
)	O
;	O
}	O
if	O
(	O
enc	pointer
->	O
ports	pointer
!=	O
enc	pointer
->	O
init_ports	pointer
)	O
munmap	function
(	O
(	O
caddr_t	pointer
)	O
enc	pointer
->	O
ports	pointer
,	O
enc	pointer
->	O
num_ports	int
*	O
sizeof	O
(	O
*	O
enc	pointer
->	O
ports	pointer
)	O
)	O
;	O
}	O
if	O
(	O
enc	pointer
->	O
ints	pointer
&&	O
enc	pointer
->	O
num_ints	int
>	O
0	int
&&	O
enc	pointer
->	O
ints	pointer
!=	O
enc	pointer
->	O
init_ints	pointer
)	O
munmap	function
(	O
(	O
caddr_t	pointer
)	O
enc	pointer
->	O
ints	pointer
,	O
enc	pointer
->	O
num_ints	int
*	O
sizeof	O
(	O
*	O
enc	pointer
->	O
ints	pointer
)	O
)	O
;	O
if	O
(	O
enc	pointer
->	O
offsets	pointer
&&	O
enc	pointer
->	O
num_offsets	int
>	O
0	int
&&	O
enc	pointer
->	O
offsets	pointer
!=	O
enc	pointer
->	O
init_offsets	pointer
)	O
munmap	function
(	O
(	O
caddr_t	pointer
)	O
enc	pointer
->	O
offsets	pointer
,	O
enc	pointer
->	O
num_offsets	int
*	O
sizeof	O
(	O
*	O
enc	pointer
->	O
offsets	pointer
)	O
)	O
;	O
if	O
(	O
enc	pointer
->	O
data	pointer
&&	O
enc	pointer
->	O
data_len	int
>	O
0	int
&&	O
enc	pointer
->	O
data	pointer
!=	O
enc	pointer
->	O
init_data	pointer
)	O
munmap	function
(	O
enc	pointer
->	O
data	pointer
,	O
enc	pointer
->	O
data_len	long
)	O
;	O
memset	function
(	O
enc	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
enc	pointer
)	O
)	O
;	O
}	O
void	O
store_enc_return	function
(	O
struct	O
store_enc	struct
*	O
enc	pointer
,	O
mach_port_t	O
*	O
*	O
ports	pointer
,	O
mach_msg_type_number_t	O
*	O
num_ports	int
,	O
int	O
*	O
*	O
ints	pointer
,	O
mach_msg_type_number_t	O
*	O
num_ints	int
,	O
off_t	long
*	O
*	O
offsets	pointer
,	O
mach_msg_type_number_t	O
*	O
num_offsets	int
,	O
char	O
*	O
*	O
data	pointer
,	O
mach_msg_type_number_t	O
*	O
data_len	int
)	O
{	O
*	O
ports	pointer
=	O
enc	pointer
->	O
ports	pointer
;	O
*	O
num_ports	int
=	O
enc	pointer
->	O
num_ports	int
;	O
*	O
ints	pointer
=	O
enc	pointer
->	O
ints	pointer
;	O
*	O
num_ints	int
=	O
enc	pointer
->	O
num_ints	int
;	O
*	O
offsets	pointer
=	O
enc	pointer
->	O
offsets	pointer
;	O
*	O
num_offsets	int
=	O
enc	pointer
->	O
num_offsets	int
;	O
*	O
data	pointer
=	O
enc	pointer
->	O
data	pointer
;	O
*	O
data_len	int
=	O
enc	pointer
->	O
data_len	int
;	O
}	O
static	O
void	O
init_hook	function
(	O
void	O
)	O
;	O
static	O
void	O
*	O
malloc_hook	function
(	O
size_t	long
size	long
,	O
const	O
void	O
*	O
caller	pointer
)	O
;	O
static	O
void	O
*	O
realloc_hook	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
,	O
const	O
void	O
*	O
caller	pointer
)	O
;	O
static	O
void	O
*	O
memalign_hook	function
(	O
size_t	long
alignment	long
,	O
size_t	long
size	long
,	O
const	O
void	O
*	O
caller	pointer
)	O
;	O
static	O
void	O
free_hook	function
(	O
void	O
*	O
ptr	pointer
,	O
const	O
void	O
*	O
caller	pointer
)	O
;	O
void	O
(	O
*	O
__MALLOC_HOOK_VOLATILE	pointer
__malloc_initialize_hook	pointer
)	O
(	O
void	O
)	O
=	O
init_hook	pointer
;	O
vm_size_t	O
kalloc_max	pointer
;	O
struct	O
free_list	struct
{	O
pthread_spinlock_t	pointer
lock	pointer
;	O
vm_offset_t	enum
head	enum
;	O
}	O
;	O
struct	O
free_list	struct
kfree_list	array
[	O
KLIST_MAX	int
]	O
;	O
pthread_spinlock_t	int
kget_space_lock	int
;	O
vm_offset_t	O
kalloc_next_space	int
=	O
0	int
;	O
vm_offset_t	int
kalloc_end_of_space	int
=	O
0	int
;	O
vm_size_t	O
kalloc_wasted_space	int
=	O
0	int
;	O
boolean_t	O
kalloc_initialized	int
=	O
FALSE	O
;	O
void	O
kalloc_init	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
if	O
(	O
vm_page_size	O
>	O
(	O
MINSIZE	int
<<	O
(	O
KLIST_MAX	int
-	O
1	int
)	O
)	O
)	O
kalloc_max	int
=	O
(	O
MINSIZE	int
<<	O
(	O
KLIST_MAX	int
-	O
1	int
)	O
)	O
;	O
else	O
kalloc_max	pointer
=	O
vm_page_size	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
KLIST_MAX	int
;	O
i	int
++	O
)	O
{	O
pthread_spin_init	function
(	O
&	O
kfree_list	pointer
[	O
i	int
]	O
.	O
lock	pointer
,	O
PTHREAD_PROCESS_PRIVATE	pointer
)	O
;	O
kfree_list	pointer
[	O
i	int
]	O
.	O
head	pointer
=	O
0	int
;	O
}	O
pthread_spin_init	function
(	O
&	O
kget_space_lock	pointer
,	O
PTHREAD_PROCESS_PRIVATE	pointer
)	O
;	O
kalloc_next_space	pointer
=	O
vm_page_size	O
;	O
kalloc_end_of_space	O
=	O
vm_page_size	O
;	O
}	O
vm_offset_t	O
kget_space	function
(	O
vm_offset_t	O
size	int
)	O
{	O
vm_size_t	O
space_to_add	int
=	O
0	int
;	O
vm_offset_t	int
new_space	int
=	O
0	int
;	O
vm_offset_t	O
addr	int
;	O
pthread_spin_lock	function
(	O
&	O
kget_space_lock	int
)	O
;	O
while	O
(	O
kalloc_next_space	int
+	O
size	int
>	O
kalloc_end_of_space	int
)	O
{	O
space_to_add	pointer
=	O
round_page	function
(	O
size	int
)	O
;	O
if	O
(	O
new_space	int
==	O
0	int
)	O
{	O
pthread_spin_unlock	function
(	O
&	O
kget_space_lock	int
)	O
;	O
new_space	pointer
=	O
kalloc_end_of_space	int
;	O
if	O
(	O
vm_map	function
(	O
mach_task_self	function
(	O
)	O
,	O
&	O
new_space	O
,	O
space_to_add	pointer
,	O
(	O
vm_offset_t	O
)	O
0	int
,	O
TRUE	O
,	O
MEMORY_OBJECT_NULL	O
,	O
(	O
vm_offset_t	int
)	O
0	int
,	O
FALSE	O
,	O
VM_PROT_DEFAULT	O
,	O
VM_PROT_ALL	O
,	O
VM_INHERIT_DEFAULT	int
)	O
!=	O
KERN_SUCCESS	O
)	O
return	O
0	int
;	O
wire_memory	function
(	O
new_space	pointer
,	O
space_to_add	O
,	O
VM_PROT_READ	O
|	O
VM_PROT_WRITE	O
)	O
;	O
pthread_spin_lock	function
(	O
&	O
kget_space_lock	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
new_space	int
!=	O
kalloc_end_of_space	int
)	O
{	O
kalloc_wasted_space	int
+=	O
kalloc_end_of_space	int
-	O
kalloc_next_space	int
;	O
kalloc_next_space	int
=	O
new_space	int
;	O
}	O
kalloc_end_of_space	int
=	O
new_space	int
+	O
space_to_add	int
;	O
new_space	int
=	O
0	int
;	O
}	O
addr	pointer
=	O
kalloc_next_space	int
;	O
kalloc_next_space	int
+=	O
size	int
;	O
pthread_spin_unlock	function
(	O
&	O
kget_space_lock	int
)	O
;	O
if	O
(	O
new_space	int
!=	O
0	int
)	O
(	O
void	O
)	O
vm_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
new_space	O
,	O
space_to_add	O
)	O
;	O
return	O
addr	pointer
;	O
}	O
void	O
*	O
kalloc	function
(	O
vm_size_t	O
size	int
)	O
{	O
vm_size_t	O
allocsize	pointer
;	O
vm_offset_t	O
addr	pointer
;	O
struct	O
free_list	struct
*	O
fl	pointer
;	O
if	O
(	O
!	O
kalloc_initialized	pointer
)	O
{	O
kalloc_init	function
(	O
)	O
;	O
kalloc_initialized	int
=	O
TRUE	O
;	O
}	O
allocsize	pointer
=	O
size	long
;	O
if	O
(	O
size	int
<=	O
kalloc_max	int
)	O
{	O
allocsize	O
=	O
MINSIZE	int
;	O
fl	double
=	O
kfree_list	int
;	O
while	O
(	O
allocsize	O
<	O
size	long
)	O
{	O
allocsize	O
<<=	O
1	int
;	O
fl	int
++	O
;	O
}	O
}	O
if	O
(	O
allocsize	O
<=	O
kalloc_max	int
)	O
{	O
pthread_spin_lock	function
(	O
&	O
fl	pointer
->	O
lock	pointer
)	O
;	O
if	O
(	O
(	O
addr	pointer
=	O
fl	pointer
->	O
head	pointer
)	O
!=	O
0	int
)	O
{	O
fl	pointer
->	O
head	pointer
=	O
*	O
(	O
vm_offset_t	O
*	O
)	O
addr	pointer
;	O
pthread_spin_unlock	function
(	O
&	O
fl	pointer
->	O
lock	pointer
)	O
;	O
}	O
else	O
{	O
pthread_spin_unlock	function
(	O
&	O
fl	pointer
->	O
lock	pointer
)	O
;	O
addr	pointer
=	O
kget_space	function
(	O
allocsize	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
vm_allocate	O
(	O
mach_task_self	function
(	O
)	O
,	O
&	O
addr	pointer
,	O
allocsize	O
,	O
TRUE	O
)	O
!=	O
KERN_SUCCESS	O
)	O
addr	O
=	O
0	int
;	O
}	O
return	O
(	O
void	O
*	O
)	O
addr	pointer
;	O
}	O
void	O
kfree	function
(	O
void	O
*	O
data	pointer
,	O
vm_size_t	O
size	int
)	O
{	O
vm_size_t	O
freesize	pointer
;	O
struct	O
free_list	struct
*	O
fl	pointer
;	O
freesize	long
=	O
size	long
;	O
if	O
(	O
size	int
<=	O
kalloc_max	int
)	O
{	O
freesize	int
=	O
MINSIZE	int
;	O
fl	double
=	O
kfree_list	int
;	O
while	O
(	O
freesize	int
<	O
size	long
)	O
{	O
freesize	int
<<=	O
1	int
;	O
fl	int
++	O
;	O
}	O
}	O
if	O
(	O
freesize	int
<=	O
kalloc_max	int
)	O
{	O
pthread_spin_lock	function
(	O
&	O
fl	pointer
->	O
lock	pointer
)	O
;	O
*	O
(	O
vm_offset_t	O
*	O
)	O
data	pointer
=	O
fl	pointer
->	O
head	pointer
;	O
fl	pointer
->	O
head	pointer
=	O
(	O
vm_offset_t	O
)	O
data	pointer
;	O
pthread_spin_unlock	function
(	O
&	O
fl	pointer
->	O
lock	pointer
)	O
;	O
}	O
else	O
{	O
(	O
void	O
)	O
vm_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
(	O
vm_offset_t	O
)	O
data	O
,	O
freesize	int
)	O
;	O
}	O
}	O
static	O
void	O
init_hook	function
(	O
void	O
)	O
{	O
__malloc_hook	int
=	O
malloc_hook	int
;	O
__realloc_hook	O
=	O
realloc_hook	pointer
;	O
__memalign_hook	pointer
=	O
memalign_hook	pointer
;	O
__free_hook	pointer
=	O
free_hook	pointer
;	O
}	O
static	O
void	O
*	O
malloc_hook	function
(	O
size_t	long
size	long
,	O
const	O
void	O
*	O
caller	pointer
)	O
{	O
return	O
(	O
void	O
*	O
)	O
kalloc	function
(	O
(	O
vm_size_t	O
)	O
size	pointer
)	O
;	O
}	O
static	O
void	O
*	O
realloc_hook	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
,	O
const	O
void	O
*	O
caller	pointer
)	O
{	O
panic	function
(	O
"realloc_hook not implemented"	pointer
)	O
;	O
}	O
static	O
void	O
*	O
memalign_hook	function
(	O
size_t	long
alignment	long
,	O
size_t	long
size	long
,	O
const	O
void	O
*	O
caller	pointer
)	O
{	O
if	O
(	O
alignment	long
>	O
vm_page_size	O
)	O
panic	function
(	O
"memalign_hook not implemented"	pointer
)	O
;	O
return	O
malloc_hook	function
(	O
size	pointer
,	O
caller	pointer
)	O
;	O
}	O
static	O
void	O
free_hook	function
(	O
void	O
*	O
ptr	pointer
,	O
const	O
void	O
*	O
caller	pointer
)	O
{	O
}	O
void	O
malloc_fork_prepare	function
(	O
)	O
{	O
}	O
void	O
malloc_fork_parent	function
(	O
)	O
{	O
}	O
void	O
malloc_fork_child	function
(	O
)	O
{	O
}	O
int	O
main_udp_socket	int
,	O
pmap_udp_socket	int
;	O
struct	O
sockaddr_in	struct
main_address	struct
,	O
pmap_address	int
;	O
static	O
char	O
index_file	array
[	O
]	O
=	O
LOCALSTATEDIR	pointer
"/state/misc/nfsd.index"	pointer
;	O
char	O
*	O
index_file_name	O
=	O
index_file	pointer
;	O
static	O
void	O
create_server_thread	function
(	O
int	O
socket	int
)	O
{	O
pthread_t	long
thread	long
;	O
int	O
fail	int
;	O
fail	int
=	O
pthread_create	function
(	O
&	O
thread	long
,	O
NULL	O
,	O
server_loop	int
,	O
(	O
void	O
*	O
)	O
socket	int
)	O
;	O
if	O
(	O
fail	int
)	O
error	function
(	O
1	int
,	O
fail	int
,	O
"Creating main server thread"	pointer
)	O
;	O
fail	int
=	O
pthread_detach	function
(	O
thread	long
)	O
;	O
if	O
(	O
fail	int
)	O
error	function
(	O
1	int
,	O
fail	O
,	O
"Detaching main server thread"	O
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
nthreads	int
;	O
int	O
fail	int
;	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s [num-threads]\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
argc	int
==	O
1	int
)	O
nthreads	int
=	O
4	int
;	O
else	O
nthreads	int
=	O
atoi	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
nthreads	int
)	O
nthreads	int
=	O
4	int
;	O
authserver	int
=	O
getauth	function
(	O
)	O
;	O
maptime_map	function
(	O
0	int
,	O
0	int
,	O
&	O
mapped_time	pointer
)	O
;	O
main_address	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
main_address	struct
.	O
sin_port	short
=	O
htons	function
(	O
NFS_PORT	int
)	O
;	O
main_address	struct
.	O
sin_addr	struct
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
pmap_address	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
pmap_address	struct
.	O
sin_port	short
=	O
htons	function
(	O
PMAPPORT	O
)	O
;	O
pmap_address	struct
.	O
sin_addr	struct
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
main_udp_socket	int
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_DGRAM	int
,	O
0	int
)	O
;	O
pmap_udp_socket	int
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_DGRAM	int
,	O
0	int
)	O
;	O
fail	enum
=	O
bind	function
(	O
main_udp_socket	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
main_address	int
,	O
sizeof	O
(	O
struct	O
sockaddr_in	struct
)	O
)	O
;	O
if	O
(	O
fail	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
"Binding NFS socket"	int
)	O
;	O
fail	enum
=	O
bind	function
(	O
pmap_udp_socket	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
pmap_address	int
,	O
sizeof	O
(	O
struct	O
sockaddr_in	struct
)	O
)	O
;	O
if	O
(	O
fail	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
"Binding PMAP socket"	int
)	O
;	O
init_filesystems	function
(	O
)	O
;	O
create_server_thread	function
(	O
pmap_udp_socket	pointer
)	O
;	O
while	O
(	O
nthreads	int
--	O
)	O
create_server_thread	function
(	O
main_udp_socket	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
sleep	function
(	O
1	int
)	O
;	O
scan_fhs	function
(	O
)	O
;	O
scan_creds	function
(	O
)	O
;	O
scan_replies	function
(	O
)	O
;	O
}	O
}	O
int	O
netfs_maxsymlinks	int
=	O
8	int
;	O
error_t	O
S_dir_notice_changes	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
mach_port_t	O
notify	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_dir_link	function
(	O
struct	O
sock_user	O
*	O
dircred	pointer
,	O
struct	O
sock_user	struct
*	O
filecred	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
excl	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_dir_lookup	function
(	O
struct	O
sock_user	struct
*	O
dircred	pointer
,	O
char	O
*	O
path	pointer
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
,	O
enum	O
retry_type	enum
*	O
retry	pointer
,	O
char	O
*	O
retryname	pointer
,	O
file_t	O
*	O
returned_port	pointer
,	O
mach_msg_type_name_t	O
*	O
returned_port_poly	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_dir_mkdir	function
(	O
struct	O
sock_user	struct
*	O
dircred	pointer
,	O
char	O
*	O
name	pointer
,	O
mode_t	int
mode	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_dir_mkfile	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
,	O
mach_port_t	O
*	O
newnode	pointer
,	O
mach_msg_type_name_t	O
*	O
newnodetype	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_dir_readdir	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
char	O
*	O
*	O
data	pointer
,	O
size_t	long
*	O
datacnt	pointer
,	O
boolean_t	O
*	O
data_dealloc	pointer
,	O
int	O
entry	int
,	O
int	O
nentries	int
,	O
vm_size_t	O
bufsiz	pointer
,	O
int	O
*	O
amt	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_dir_rename	function
(	O
struct	O
sock_user	struct
*	O
fromcred	pointer
,	O
char	O
*	O
fromname	pointer
,	O
struct	O
sock_user	struct
*	O
tocred	pointer
,	O
char	O
*	O
toname	pointer
,	O
int	O
excl	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_dir_rmdir	function
(	O
struct	O
sock_user	struct
*	O
dircred	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_dir_unlink	function
(	O
struct	O
sock_user	struct
*	O
dircred	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_chauthor	function
(	O
struct	O
sock_user	struct
*	O
user	pointer
,	O
uid_t	int
author	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_check_access	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
int	O
*	O
type	pointer
)	O
{	O
if	O
(	O
!	O
cred	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
*	O
type	pointer
=	O
0	int
;	O
if	O
(	O
cred	pointer
->	O
sock	pointer
->	O
read_pipe	int
)	O
*	O
type	int
|=	O
O_READ	O
;	O
if	O
(	O
cred	pointer
->	O
sock	pointer
->	O
write_pipe	pointer
)	O
*	O
type	O
|=	O
O_WRITE	O
;	O
return	O
0	int
;	O
}	O
error_t	O
S_file_chflags	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
int	O
flags	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_notice_changes	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
mach_port_t	O
notify	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_chmod	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
mode_t	int
mode	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_chown	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
uid_t	int
uid	int
,	O
gid_t	int
gid	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_exec	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
task_t	O
task	O
,	O
int	O
flags	int
,	O
char	O
*	O
argv	pointer
,	O
size_t	long
argvlen	pointer
,	O
char	O
*	O
envp	pointer
,	O
size_t	long
envplen	long
,	O
mach_port_t	O
*	O
fds	pointer
,	O
size_t	long
fdslen	O
,	O
mach_port_t	O
*	O
portarray	pointer
,	O
size_t	long
portarraylen	O
,	O
int	O
*	O
intarray	pointer
,	O
size_t	long
intarraylen	O
,	O
mach_port_t	O
*	O
deallocnames	pointer
,	O
size_t	long
deallocnameslen	int
,	O
mach_port_t	O
*	O
destroynames	pointer
,	O
size_t	long
destroynameslen	O
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_get_children	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
char	O
*	O
*	O
children	pointer
,	O
mach_msg_type_number_t	O
*	O
children_len	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_getcontrol	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
mach_port_t	O
*	O
control	pointer
,	O
mach_msg_type_name_t	O
*	O
controltype	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_getfh	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
char	O
*	O
*	O
fh	pointer
,	O
size_t	long
*	O
fh_len	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_get_fs_options	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
char	O
*	O
*	O
data	pointer
,	O
size_t	long
*	O
data_len	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_getlinknode	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
file_t	O
*	O
port	O
,	O
mach_msg_type_name_t	O
*	O
portpoly	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_get_source	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
char	O
*	O
source	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_get_storage_info	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
mach_port_t	O
*	O
*	O
ports	pointer
,	O
mach_msg_type_name_t	O
*	O
ports_type	pointer
,	O
mach_msg_type_number_t	O
*	O
num_ports	int
,	O
int	O
*	O
*	O
ints	pointer
,	O
mach_msg_type_number_t	O
*	O
num_ints	int
,	O
off_t	long
*	O
*	O
offsets	pointer
,	O
mach_msg_type_number_t	O
*	O
num_offsets	int
,	O
char	O
*	O
*	O
data	pointer
,	O
mach_msg_type_number_t	O
*	O
data_len	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_get_translator	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
char	O
*	O
*	O
trans	pointer
,	O
size_t	long
*	O
translen	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_get_translator_cntl	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
mach_port_t	O
*	O
ctl	pointer
,	O
mach_msg_type_name_t	O
*	O
ctltype	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_lock	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
int	O
flags	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_lock_stat	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
int	O
*	O
mystatus	pointer
,	O
int	O
*	O
otherstatus	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_reparent	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
mach_port_t	O
parent	pointer
,	O
mach_port_t	O
*	O
new	pointer
,	O
mach_msg_type_name_t	O
*	O
new_type	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_set_size	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
off_t	long
size	long
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_set_translator	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
int	O
passive_flags	int
,	O
int	O
active_flags	int
,	O
int	O
killtrans_flags	int
,	O
char	O
*	O
passive	pointer
,	O
size_t	long
passivelen	long
,	O
fsys_t	O
active	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	int
S_file_statfs	function
(	O
struct	O
sock_user	struct
*	O
file	pointer
,	O
fsys_statfsbuf_t	struct
*	O
statbuf	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_sync	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
int	O
wait	int
,	O
int	O
omitmetadata	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_syncfs	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
int	O
wait	int
,	O
int	O
dochildren	int
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
S_file_utimes	function
(	O
struct	O
sock_user	struct
*	O
cred	pointer
,	O
time_value_t	pointer
atime	pointer
,	O
time_value_t	pointer
mtime	pointer
)	O
{	O
return	O
EOPNOTSUPP	O
;	O
}	O
struct	O
dircat_node	struct
{	O
int	O
num_dirs	int
;	O
struct	O
node	pointer
*	O
dirs	array
[	O
0	int
]	O
;	O
}	O
;	O
static	O
error_t	int
dircat_get_contents	function
(	O
void	O
*	O
hook	pointer
,	O
char	O
*	O
*	O
contents	pointer
,	O
ssize_t	long
*	O
contents_len	pointer
)	O
{	O
struct	O
dircat_node	struct
*	O
dcn	pointer
=	O
hook	pointer
;	O
int	O
i	int
,	O
sz	long
,	O
pos	int
;	O
error_t	int
err	O
;	O
pos	int
=	O
0	int
;	O
*	O
contents	pointer
=	O
malloc	function
(	O
sz	long
=	O
512	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dcn	pointer
->	O
num_dirs	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
subcon	pointer
;	O
ssize_t	long
sublen	int
;	O
procfs_refresh	function
(	O
dcn	pointer
->	O
dirs	array
[	O
i	int
]	O
)	O
;	O
err	int
=	O
procfs_get_contents	function
(	O
dcn	pointer
->	O
dirs	array
[	O
i	int
]	O
,	O
&	O
subcon	O
,	O
&	O
sublen	pointer
)	O
;	O
if	O
(	O
err	O
)	O
{	O
free	function
(	O
*	O
contents	pointer
)	O
;	O
*	O
contents	pointer
=	O
NULL	O
;	O
return	O
err	O
;	O
}	O
while	O
(	O
pos	int
+	O
sublen	O
>	O
sz	long
)	O
*	O
contents	pointer
=	O
realloc	function
(	O
*	O
contents	pointer
,	O
sz	long
*=	O
2	int
)	O
;	O
memcpy	function
(	O
*	O
contents	pointer
+	O
pos	long
,	O
subcon	pointer
,	O
sublen	pointer
)	O
;	O
pos	long
+=	O
sublen	O
;	O
}	O
*	O
contents_len	pointer
=	O
pos	int
;	O
return	O
0	int
;	O
}	O
static	O
error_t	int
dircat_lookup	function
(	O
void	O
*	O
hook	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
node	O
*	O
*	O
np	pointer
)	O
{	O
struct	O
dircat_node	struct
*	O
dcn	pointer
=	O
hook	pointer
;	O
error_t	O
err	O
;	O
int	O
i	int
;	O
err	O
=	O
ENOENT	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
err	pointer
&&	O
i	int
<	O
dcn	pointer
->	O
num_dirs	int
;	O
i	int
++	O
)	O
err	int
=	O
procfs_lookup	function
(	O
dcn	pointer
->	O
dirs	array
[	O
i	int
]	O
,	O
name	pointer
,	O
np	pointer
)	O
;	O
return	O
err	O
;	O
}	O
static	O
void	O
dircat_release_dirs	function
(	O
struct	O
node	struct
*	O
const	O
*	O
dirs	pointer
,	O
int	O
num_dirs	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dirs	int
;	O
i	int
++	O
)	O
if	O
(	O
dirs	array
[	O
i	int
]	O
)	O
netfs_nrele	function
(	O
dirs	array
[	O
i	int
]	O
)	O
;	O
}	O
static	O
void	O
dircat_cleanup	function
(	O
void	O
*	O
hook	pointer
)	O
{	O
struct	O
dircat_node	struct
*	O
dcn	pointer
=	O
hook	pointer
;	O
dircat_release_dirs	function
(	O
dcn	pointer
->	O
dirs	pointer
,	O
dcn	pointer
->	O
num_dirs	pointer
)	O
;	O
free	function
(	O
dcn	pointer
)	O
;	O
}	O
struct	O
node	pointer
*	O
dircat_make_node	function
(	O
struct	O
node	O
*	O
const	O
*	O
dirs	pointer
,	O
int	O
num_dirs	int
)	O
{	O
static	O
struct	O
procfs_node_ops	O
ops	pointer
=	O
{	O
.	O
get_contents	O
=	O
dircat_get_contents	O
,	O
.	O
cleanup_contents	O
=	O
procfs_cleanup_contents_with_free	function
,	O
.	O
lookup	pointer
=	O
dircat_lookup	O
,	O
.	O
cleanup	pointer
=	O
dircat_cleanup	pointer
,	O
}	O
;	O
struct	O
dircat_node	struct
*	O
dcn	pointer
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dirs	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
dirs	array
[	O
i	int
]	O
)	O
goto	O
fail	O
;	O
dcn	pointer
=	O
malloc	function
(	O
sizeof	O
*	O
dcn	pointer
+	O
num_dirs	int
*	O
sizeof	O
dcn	pointer
->	O
dirs	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
dcn	pointer
)	O
goto	O
fail	O
;	O
dcn	pointer
->	O
num_dirs	int
=	O
num_dirs	int
;	O
memcpy	function
(	O
dcn	pointer
->	O
dirs	pointer
,	O
dirs	pointer
,	O
num_dirs	char
*	O
sizeof	O
dcn	pointer
->	O
dirs	array
[	O
0	int
]	O
)	O
;	O
return	O
procfs_make_node	function
(	O
&	O
ops	pointer
,	O
dcn	O
)	O
;	O
fail	O
:	O
dircat_release_dirs	function
(	O
dirs	O
,	O
num_dirs	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
argp_program_version	pointer
=	O
STANDARD_HURD_VERSION	function
(	O
proc	int
)	O
;	O
int	O
message_demuxer	function
(	O
mach_msg_header_t	O
*	O
inp	pointer
,	O
mach_msg_header_t	O
*	O
outp	pointer
)	O
{	O
mig_routine_t	O
routine	O
;	O
if	O
(	O
(	O
routine	O
=	O
process_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
notify_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
ports_interrupt_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
proc_exc_server_routine	function
(	O
inp	pointer
)	O
)	O
||	O
(	O
routine	O
=	O
task_notify_server_routine	function
(	O
inp	pointer
)	O
)	O
)	O
{	O
pthread_mutex_lock	function
(	O
&	O
global_lock	pointer
)	O
;	O
(	O
*	O
routine	O
)	O
(	O
inp	pointer
,	O
outp	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
global_lock	O
)	O
;	O
return	O
TRUE	O
;	O
}	O
else	O
return	O
FALSE	O
;	O
}	O
pthread_mutex_t	enum
global_lock	enum
=	O
PTHREAD_MUTEX_INITIALIZER	O
;	O
int	O
startup_fallback	int
;	O
error_t	O
increase_priority	function
(	O
void	O
)	O
{	O
mach_port_t	O
pset	int
=	O
MACH_PORT_NULL	O
,	O
psetcntl	int
=	O
MACH_PORT_NULL	O
;	O
error_t	int
err	O
;	O
err	int
=	O
thread_get_assignment	function
(	O
mach_thread_self	function
(	O
)	O
,	O
&	O
pset	O
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
err	int
=	O
host_processor_set_priv	function
(	O
_hurd_host_priv	pointer
,	O
pset	pointer
,	O
&	O
psetcntl	O
)	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
err	int
=	O
thread_max_priority	function
(	O
mach_thread_self	function
(	O
)	O
,	O
psetcntl	pointer
,	O
0	int
)	O
;	O
if	O
(	O
err	O
==	O
KERN_INVALID_ARGUMENT	int
)	O
err	O
=	O
EPERM	O
;	O
if	O
(	O
err	int
)	O
goto	O
out	O
;	O
err	O
=	O
task_priority	function
(	O
mach_task_self	function
(	O
)	O
,	O
2	int
,	O
1	int
)	O
;	O
out	O
:	O
if	O
(	O
MACH_PORT_VALID	function
(	O
pset	int
)	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
pset	O
)	O
;	O
if	O
(	O
MACH_PORT_VALID	function
(	O
psetcntl	O
)	O
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
psetcntl	O
)	O
;	O
return	O
err	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
char	O
*	O
*	O
envp	pointer
)	O
{	O
mach_port_t	O
boot	O
;	O
error_t	O
err	O
;	O
void	O
*	O
genport	pointer
;	O
process_t	O
startup_port	pointer
;	O
mach_port_t	O
startup	int
;	O
struct	O
argp	struct
argp	struct
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
"Hurd process server"	int
}	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
initialize_version_info	function
(	O
)	O
;	O
err	function
=	O
task_get_bootstrap_port	function
(	O
mach_task_self	function
(	O
)	O
,	O
&	O
boot	struct
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
if	O
(	O
boot	O
==	O
MACH_PORT_NULL	O
)	O
error	function
(	O
2	int
,	O
0	int
,	O
"proc server can only be run by startup during boot"	pointer
)	O
;	O
proc_bucket	O
=	O
ports_create_bucket	function
(	O
)	O
;	O
proc_class	O
=	O
ports_create_class	function
(	O
0	int
,	O
0	int
)	O
;	O
generic_port_class	O
=	O
ports_create_class	function
(	O
0	int
,	O
0	int
)	O
;	O
exc_class	O
=	O
ports_create_class	function
(	O
exc_clean	pointer
,	O
0	int
)	O
;	O
ports_create_port	function
(	O
generic_port_class	pointer
,	O
proc_bucket	O
,	O
sizeof	O
(	O
struct	O
port_info	struct
)	O
,	O
&	O
genport	O
)	O
;	O
generic_port	O
=	O
ports_get_right	function
(	O
genport	pointer
)	O
;	O
init_proc	pointer
=	O
create_init_proc	function
(	O
)	O
;	O
startup_proc	int
=	O
allocate_proc	function
(	O
MACH_PORT_NULL	O
)	O
;	O
startup_proc	pointer
->	O
p_deadmsg	int
=	O
1	int
;	O
complete_proc	function
(	O
startup_proc	pointer
,	O
HURD_PID_STARTUP	int
)	O
;	O
self_proc	pointer
=	O
allocate_proc	function
(	O
mach_task_self	function
(	O
)	O
)	O
;	O
assert	O
(	O
self_proc	int
)	O
;	O
complete_proc	function
(	O
self_proc	pointer
,	O
HURD_PID_PROC	pointer
)	O
;	O
startup_port	int
=	O
ports_get_send_right	function
(	O
startup_proc	pointer
)	O
;	O
err	int
=	O
startup_procinit	function
(	O
boot	struct
,	O
startup_port	pointer
,	O
&	O
startup_proc	pointer
->	O
p_task	O
,	O
&	O
authserver	int
,	O
&	O
_hurd_host_priv	O
,	O
&	O
_hurd_device_master	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
startup_port	O
)	O
;	O
mach_port_mod_refs	function
(	O
mach_task_self	function
(	O
)	O
,	O
authserver	int
,	O
MACH_PORT_RIGHT_SEND	int
,	O
1	int
)	O
;	O
_hurd_port_set	function
(	O
&	O
_hurd_ports	array
[	O
INIT_PORT_AUTH	O
]	O
,	O
authserver	int
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
boot	O
)	O
;	O
proc_death_notify	function
(	O
startup_proc	pointer
)	O
;	O
add_proc_to_hash	function
(	O
startup_proc	pointer
)	O
;	O
self_proc	pointer
->	O
p_argv	pointer
=	O
(	O
vm_address_t	O
)	O
argv	pointer
;	O
self_proc	pointer
->	O
p_envp	int
=	O
(	O
vm_address_t	O
)	O
envp	pointer
;	O
err	int
=	O
increase_priority	function
(	O
)	O
;	O
if	O
(	O
err	O
&&	O
err	O
!=	O
EPERM	O
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"Increasing priority failed"	pointer
)	O
;	O
err	O
=	O
register_new_task_notification	function
(	O
_hurd_host_priv	pointer
,	O
generic_port	O
,	O
MACH_MSG_TYPE_MAKE_SEND	O
)	O
;	O
if	O
(	O
err	O
)	O
error	function
(	O
0	int
,	O
err	O
,	O
"Registering task notifications failed"	pointer
)	O
;	O
{	O
mach_port_t	O
cons	int
;	O
err	int
=	O
device_open	function
(	O
_hurd_device_master	O
,	O
D_READ	O
|	O
D_WRITE	O
,	O
"console"	pointer
,	O
&	O
cons	O
)	O
;	O
assert_perror	O
(	O
err	O
)	O
;	O
stdin	O
=	O
mach_open_devstream	function
(	O
cons	O
,	O
"r"	pointer
)	O
;	O
stdout	O
=	O
stderr	O
=	O
mach_open_devstream	function
(	O
cons	O
,	O
"w"	pointer
)	O
;	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
cons	O
)	O
;	O
}	O
startup	O
=	O
file_name_lookup	function
(	O
_SERVERS_STARTUP	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
MACH_PORT_VALID	function
(	O
startup	O
)	O
)	O
{	O
err	int
=	O
startup_essential_task	function
(	O
startup	int
,	O
mach_task_self	function
(	O
)	O
,	O
MACH_PORT_NULL	O
,	O
"proc"	pointer
,	O
_hurd_host_priv	pointer
)	O
;	O
if	O
(	O
err	int
)	O
startup_fallback	int
=	O
1	int
;	O
err	int
=	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
startup	O
)	O
;	O
assert_perror	function
(	O
err	O
)	O
;	O
}	O
else	O
startup_fallback	int
=	O
1	int
;	O
while	O
(	O
1	int
)	O
ports_manage_port_operations_multithread	function
(	O
proc_bucket	O
,	O
message_demuxer	pointer
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
void	O
netfs_node_norefs	function
(	O
struct	O
node	pointer
*	O
node	pointer
)	O
{	O
if	O
(	O
node	pointer
->	O
nn	pointer
->	O
name	pointer
)	O
node	pointer
->	O
nn	pointer
->	O
name	pointer
->	O
node	pointer
=	O
0	int
;	O
if	O
(	O
node	pointer
->	O
nn	pointer
->	O
trans_len	long
>	O
0	int
)	O
free	function
(	O
node	pointer
->	O
nn	pointer
->	O
trans	pointer
)	O
;	O
free	function
(	O
node	pointer
->	O
nn	pointer
)	O
;	O
free	function
(	O
node	pointer
)	O
;	O
}	O
error_t	O
netfs_attempt_create_file	function
(	O
struct	O
iouser	struct
*	O
user	pointer
,	O
struct	O
node	pointer
*	O
dir	pointer
,	O
char	O
*	O
name	pointer
,	O
mode_t	O
mode	int
,	O
struct	O
node	pointer
*	O
*	O
node	pointer
)	O
{	O
*	O
node	pointer
=	O
0	int
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
return	O
EOPNOTSUPP	O
;	O
}	O
error_t	O
netfs_check_open_permissions	function
(	O
struct	O
iouser	O
*	O
user	pointer
,	O
struct	O
node	pointer
*	O
node	pointer
,	O
int	O
flags	int
,	O
int	O
newnode	int
)	O
{	O
error_t	O
err	int
=	O
0	int
;	O
if	O
(	O
flags	int
&	O
O_READ	O
)	O
err	O
=	O
fshelp_access	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
S_IREAD	pointer
,	O
user	pointer
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
(	O
flags	int
&	O
O_WRITE	O
)	O
)	O
err	function
=	O
fshelp_access	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
S_IWRITE	pointer
,	O
user	pointer
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
(	O
flags	int
&	O
O_EXEC	O
)	O
)	O
err	function
=	O
fshelp_access	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
S_IEXEC	pointer
,	O
user	pointer
)	O
;	O
return	O
err	int
;	O
}	O
error_t	O
netfs_attempt_utimes	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	pointer
*	O
node	pointer
,	O
struct	O
timespec	struct
*	O
atime	pointer
,	O
struct	O
timespec	struct
*	O
mtime	pointer
)	O
{	O
error_t	int
err	int
=	O
fshelp_isowner	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
cred	pointer
)	O
;	O
int	O
flags	int
=	O
TOUCH_CTIME	O
;	O
if	O
(	O
!	O
err	int
)	O
{	O
if	O
(	O
mtime	pointer
)	O
node	pointer
->	O
nn_stat	O
.	O
st_mtim	O
=	O
*	O
mtime	pointer
;	O
else	O
flags	int
|=	O
TOUCH_MTIME	O
;	O
if	O
(	O
atime	pointer
)	O
node	pointer
->	O
nn_stat	O
.	O
st_atim	O
=	O
*	O
atime	pointer
;	O
else	O
flags	int
|=	O
TOUCH_ATIME	O
;	O
fshelp_touch	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
flags	int
,	O
usermux_maptime	pointer
)	O
;	O
}	O
return	O
err	int
;	O
}	O
error_t	O
netfs_report_access	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	pointer
*	O
node	pointer
,	O
int	O
*	O
types	pointer
)	O
{	O
*	O
types	pointer
=	O
0	int
;	O
if	O
(	O
fshelp_access	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
S_IREAD	pointer
,	O
cred	pointer
)	O
==	O
0	int
)	O
*	O
types	pointer
|=	O
O_READ	O
;	O
if	O
(	O
fshelp_access	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
S_IWRITE	pointer
,	O
cred	pointer
)	O
==	O
0	int
)	O
*	O
types	O
|=	O
O_WRITE	O
;	O
if	O
(	O
fshelp_access	function
(	O
&	O
node	pointer
->	O
nn_stat	O
,	O
S_IEXEC	pointer
,	O
cred	pointer
)	O
==	O
0	int
)	O
*	O
types	pointer
|=	O
O_EXEC	O
;	O
return	O
0	int
;	O
}	O
error_t	O
netfs_validate_stat	function
(	O
struct	O
node	O
*	O
node	pointer
,	O
struct	O
iouser	struct
*	O
cred	pointer
)	O
{	O
return	O
0	int
;	O
}	O
error_t	O
netfs_attempt_sync	function
(	O
struct	O
iouser	O
*	O
cred	pointer
,	O
struct	O
node	pointer
*	O
node	pointer
,	O
int	O
wait	int
)	O
{	O
return	O
0	int
;	O
}	O
error_t	O
_parse_strlist	function
(	O
char	O
*	O
arg	pointer
,	O
error_t	function
(	O
*	O
add_fn	pointer
)	O
(	O
const	O
char	O
*	O
str	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
,	O
error_t	function
(	O
*	O
default_add_fn	pointer
)	O
(	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
,	O
const	O
char	O
*	O
type_name	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
if	O
(	O
arg	pointer
)	O
while	O
(	O
isspace	function
(	O
*	O
arg	pointer
)	O
)	O
arg	pointer
++	O
;	O
if	O
(	O
arg	pointer
==	O
NULL	O
||	O
*	O
arg	pointer
==	O
'\0'	O
)	O
if	O
(	O
default_add_fn	pointer
)	O
return	O
(	O
*	O
default_add_fn	pointer
)	O
(	O
state	pointer
)	O
;	O
else	O
{	O
argp_error	function
(	O
state	pointer
,	O
"Empty %s list"	int
,	O
type_name	int
)	O
;	O
return	O
EINVAL	int
;	O
}	O
else	O
{	O
error_t	int
err	int
=	O
0	int
;	O
char	O
*	O
end	pointer
=	O
arg	pointer
;	O
void	O
mark_end	function
(	O
)	O
{	O
*	O
end	pointer
++	O
=	O
'\0'	O
;	O
while	O
(	O
isspace	function
(	O
*	O
end	pointer
)	O
)	O
end	pointer
++	O
;	O
}	O
error_t	O
parse_element	function
(	O
)	O
{	O
char	O
*	O
cur	pointer
=	O
arg	pointer
;	O
if	O
(	O
*	O
cur	pointer
==	O
'\0'	O
)	O
{	O
argp_error	function
(	O
state	pointer
,	O
"Empty element in %s list"	pointer
,	O
type_name	int
)	O
;	O
return	O
EINVAL	int
;	O
}	O
arg	pointer
=	O
end	pointer
;	O
return	O
(	O
*	O
add_fn	pointer
)	O
(	O
cur	pointer
,	O
state	pointer
)	O
;	O
}	O
while	O
(	O
*	O
end	pointer
!=	O
'\0'	O
&&	O
!	O
err	int
)	O
switch	O
(	O
*	O
end	pointer
)	O
{	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
mark_end	function
(	O
)	O
;	O
if	O
(	O
*	O
end	pointer
==	O
','	O
)	O
mark_end	function
(	O
)	O
;	O
err	int
=	O
parse_element	function
(	O
)	O
;	O
break	O
;	O
case	O
','	O
:	O
mark_end	function
(	O
)	O
;	O
err	int
=	O
parse_element	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
end	pointer
++	O
;	O
}	O
if	O
(	O
!	O
err	int
)	O
err	int
=	O
parse_element	function
(	O
)	O
;	O
return	O
err	int
;	O
}	O
}	O
error_t	O
parse_strlist	function
(	O
char	O
*	O
arg	pointer
,	O
error_t	function
(	O
*	O
add_fn	pointer
)	O
(	O
const	O
char	O
*	O
str	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
,	O
const	O
char	O
*	O
(	O
*	O
default_fn	pointer
)	O
(	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
,	O
const	O
char	O
*	O
type_name	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
error_t	int
default_str_add	function
(	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
return	O
(	O
*	O
add_fn	pointer
)	O
(	O
(	O
*	O
default_fn	pointer
)	O
(	O
state	pointer
)	O
,	O
state	pointer
)	O
;	O
}	O
return	O
_parse_strlist	function
(	O
arg	pointer
,	O
add_fn	int
,	O
default_str_add	int
,	O
type_name	int
,	O
state	pointer
)	O
;	O
}	O
error_t	function
parse_numlist	function
(	O
char	O
*	O
arg	pointer
,	O
error_t	function
(	O
*	O
add_fn	pointer
)	O
(	O
unsigned	O
num	int
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
,	O
int	O
(	O
*	O
default_fn	pointer
)	O
(	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
,	O
int	O
(	O
*	O
lookup_fn	pointer
)	O
(	O
const	O
char	O
*	O
str	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
,	O
const	O
char	O
*	O
type_name	int
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
error_t	O
default_num_add	function
(	O
)	O
{	O
return	O
(	O
*	O
add_fn	pointer
)	O
(	O
(	O
*	O
default_fn	pointer
)	O
(	O
state	pointer
)	O
,	O
state	pointer
)	O
;	O
}	O
error_t	O
add_num_str	function
(	O
const	O
char	O
*	O
str	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
str	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
p	pointer
++	O
)	O
if	O
(	O
!	O
isdigit	function
(	O
*	O
p	pointer
)	O
)	O
{	O
if	O
(	O
lookup_fn	pointer
)	O
return	O
(	O
*	O
add_fn	pointer
)	O
(	O
(	O
*	O
lookup_fn	pointer
)	O
(	O
str	pointer
,	O
state	pointer
)	O
,	O
state	pointer
)	O
;	O
else	O
{	O
argp_error	function
(	O
state	pointer
,	O
"%s: Invalid %s"	pointer
,	O
p	pointer
,	O
type_name	int
)	O
;	O
return	O
EINVAL	int
;	O
}	O
return	O
0	int
;	O
}	O
return	O
(	O
*	O
add_fn	pointer
)	O
(	O
atoi	function
(	O
str	pointer
)	O
,	O
state	pointer
)	O
;	O
}	O
return	O
_parse_strlist	function
(	O
arg	pointer
,	O
add_num_str	int
,	O
default_fn	int
?	O
default_num_add	int
:	O
0	int
,	O
type_name	int
,	O
state	pointer
)	O
;	O
}	O
int	O
parse_enum	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
(	O
*	O
choice_fn	pointer
)	O
(	O
unsigned	O
n	int
)	O
,	O
const	O
char	O
*	O
kind	pointer
,	O
int	O
allow_mismatches	int
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
const	O
char	O
*	O
choice	pointer
;	O
int	O
arglen	int
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
int	O
n	int
=	O
0	int
;	O
int	O
partial_match	int
=	O
-	O
1	int
;	O
while	O
(	O
(	O
choice	int
=	O
(	O
*	O
choice_fn	pointer
)	O
(	O
n	int
)	O
)	O
!=	O
NULL	O
)	O
if	O
(	O
strcasecmp	function
(	O
choice	pointer
,	O
arg	pointer
)	O
==	O
0	int
)	O
return	O
n	int
;	O
else	O
{	O
if	O
(	O
strncasecmp	function
(	O
choice	pointer
,	O
arg	pointer
,	O
arglen	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
partial_match	int
>=	O
0	int
)	O
{	O
argp_error	function
(	O
state	pointer
,	O
"%s: Ambiguous %s"	int
,	O
arg	pointer
,	O
kind	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
partial_match	int
=	O
n	int
;	O
}	O
n	int
++	O
;	O
}	O
if	O
(	O
partial_match	int
<	O
0	int
&&	O
!	O
allow_mismatches	int
)	O
argp_error	function
(	O
state	pointer
,	O
"%s: Invalid %s"	pointer
,	O
arg	pointer
,	O
kind	int
)	O
;	O
return	O
partial_match	int
;	O
}	O
void	O
psout	function
(	O
struct	O
proc_stat_list	struct
*	O
procs	pointer
,	O
char	O
*	O
fmt_string	pointer
,	O
int	O
posix_fmt	int
,	O
struct	O
ps_fmt_specs	struct
*	O
specs	pointer
,	O
char	O
*	O
sort_key_name	pointer
,	O
int	O
sort_reverse	int
,	O
int	O
output_width	int
,	O
int	O
print_heading	int
,	O
int	O
squash_bogus_fields	int
,	O
int	O
squash_nominal_fields	int
,	O
int	O
top	int
)	O
{	O
error_t	O
err	int
;	O
struct	O
ps_stream	struct
*	O
output	pointer
;	O
struct	O
ps_fmt	struct
*	O
fmt	pointer
;	O
err	int
=	O
ps_fmt_create	function
(	O
fmt_string	pointer
,	O
posix_fmt	pointer
,	O
specs	pointer
,	O
&	O
fmt	pointer
)	O
;	O
if	O
(	O
err	int
)	O
{	O
char	O
*	O
problem	pointer
;	O
ps_fmt_creation_error	function
(	O
fmt_string	pointer
,	O
posix_fmt	pointer
,	O
specs	pointer
,	O
&	O
problem	pointer
)	O
;	O
error	function
(	O
4	int
,	O
0	int
,	O
"%s"	pointer
,	O
problem	pointer
)	O
;	O
}	O
if	O
(	O
squash_bogus_fields	pointer
)	O
{	O
ps_flags_t	O
bogus_flags	int
=	O
ps_fmt_needs	function
(	O
fmt	pointer
)	O
;	O
err	int
=	O
proc_stat_list_find_bogus_flags	function
(	O
procs	O
,	O
&	O
bogus_flags	struct
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"Couldn't remove bogus fields"	pointer
)	O
;	O
else	O
ps_fmt_squash_flags	function
(	O
fmt	pointer
,	O
bogus_flags	pointer
)	O
;	O
}	O
if	O
(	O
squash_nominal_fields	int
)	O
{	O
int	O
nominal	function
(	O
struct	O
ps_fmt_field	struct
*	O
field	pointer
)	O
{	O
return	O
!	O
(	O
field	pointer
->	O
flags	int
&	O
PS_FMT_FIELD_KEEP	int
)	O
&&	O
proc_stat_list_spec_nominal	function
(	O
procs	O
,	O
field	pointer
->	O
spec	struct
)	O
;	O
}	O
ps_fmt_squash	function
(	O
fmt	pointer
,	O
nominal	pointer
)	O
;	O
}	O
if	O
(	O
sort_key_name	pointer
)	O
{	O
const	O
struct	O
ps_fmt_spec	struct
*	O
sort_key	pointer
;	O
if	O
(	O
*	O
sort_key_name	pointer
==	O
'-'	O
)	O
{	O
sort_reverse	int
=	O
1	int
;	O
sort_key_name	pointer
++	O
;	O
}	O
sort_key	pointer
=	O
ps_fmt_specs_find	function
(	O
specs	pointer
,	O
sort_key_name	pointer
)	O
;	O
if	O
(	O
sort_key	pointer
==	O
NULL	O
)	O
error	function
(	O
3	int
,	O
0	int
,	O
"%s: bad sort key"	pointer
,	O
sort_key_name	pointer
)	O
;	O
err	int
=	O
proc_stat_list_sort	function
(	O
procs	O
,	O
sort_key	pointer
,	O
sort_reverse	pointer
)	O
;	O
if	O
(	O
err	O
)	O
error	function
(	O
0	int
,	O
err	pointer
,	O
"Couldn't sort processes"	pointer
)	O
;	O
}	O
err	int
=	O
ps_stream_create	function
(	O
stdout	pointer
,	O
&	O
output	pointer
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
5	int
,	O
err	int
,	O
"Can't make output stream"	pointer
)	O
;	O
if	O
(	O
print_heading	pointer
)	O
{	O
if	O
(	O
procs	pointer
->	O
num_procs	int
>	O
0	int
)	O
{	O
err	int
=	O
ps_fmt_write_titles	function
(	O
fmt	pointer
,	O
output	pointer
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
0	int
,	O
err	int
,	O
"Can't print titles"	pointer
)	O
;	O
ps_stream_newline	function
(	O
output	pointer
)	O
;	O
}	O
else	O
error	function
(	O
1	int
,	O
0	int
,	O
"No applicable processes"	pointer
)	O
;	O
}	O
if	O
(	O
output_width	pointer
)	O
{	O
int	O
deduce_term_size	function
(	O
int	O
fd	int
,	O
char	O
*	O
type	pointer
,	O
int	O
*	O
width	pointer
,	O
int	O
*	O
height	pointer
)	O
;	O
if	O
(	O
output_width	int
<	O
0	int
)	O
if	O
(	O
!	O
deduce_term_size	function
(	O
1	int
,	O
getenv	function
(	O
"TERM"	pointer
)	O
,	O
&	O
output_width	pointer
,	O
0	int
)	O
)	O
output_width	int
=	O
80	int
;	O
ps_fmt_set_output_width	function
(	O
fmt	pointer
,	O
output_width	pointer
)	O
;	O
}	O
if	O
(	O
top	O
)	O
{	O
int	O
filter	function
(	O
struct	O
proc_stat	O
*	O
ps	pointer
)	O
{	O
return	O
--	O
top	int
>=	O
0	int
;	O
}	O
if	O
(	O
top	O
<	O
0	int
)	O
{	O
top	struct
+=	O
procs	O
->	O
num_procs	pointer
;	O
proc_stat_list_filter1	function
(	O
procs	O
,	O
filter	pointer
,	O
0	int
,	O
1	int
)	O
;	O
}	O
else	O
proc_stat_list_filter1	function
(	O
procs	O
,	O
filter	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
err	int
=	O
proc_stat_list_fmt	function
(	O
procs	O
,	O
fmt	pointer
,	O
output	pointer
)	O
;	O
if	O
(	O
err	int
)	O
error	function
(	O
5	int
,	O
err	pointer
,	O
"Couldn't output process status"	pointer
)	O
;	O
}	O
struct	O
dynvec	struct
*	O
make_dynvec	function
(	O
int	O
n	int
)	O
{	O
struct	O
dynvec	struct
*	O
dv	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
dynvec	struct
)	O
*	O
1	int
)	O
;	O
dv	struct
->	O
dv_vec	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
void	O
*	O
)	O
*	O
n	long
)	O
;	O
dv	struct
->	O
dv_capacity	int
=	O
n	int
;	O
dv	struct
->	O
dv_fill	int
=	O
0	int
;	O
return	O
dv	struct
;	O
}	O
void	O
dynvec_free	function
(	O
struct	O
dynvec	struct
*	O
dv	struct
)	O
{	O
free	function
(	O
dv	struct
->	O
dv_vec	pointer
)	O
;	O
free	function
(	O
dv	struct
)	O
;	O
}	O
void	O
dynvec_freeze	function
(	O
struct	O
dynvec	struct
*	O
dv	struct
)	O
{	O
if	O
(	O
dv	struct
->	O
dv_fill	int
==	O
dv	struct
->	O
dv_capacity	int
)	O
return	O
;	O
dv	struct
->	O
dv_capacity	int
=	O
dv	struct
->	O
dv_fill	int
;	O
dv	struct
->	O
dv_vec	pointer
=	O
xrealloc	function
(	O
dv	struct
->	O
dv_vec	pointer
,	O
sizeof	O
(	O
void	O
*	O
)	O
*	O
dv	struct
->	O
dv_capacity	pointer
)	O
;	O
}	O
void	O
dynvec_append	function
(	O
struct	O
dynvec	struct
*	O
dv	struct
,	O
void	O
*	O
element	pointer
)	O
{	O
if	O
(	O
dv	struct
->	O
dv_fill	int
==	O
dv	struct
->	O
dv_capacity	int
)	O
{	O
dv	struct
->	O
dv_capacity	char
*=	O
2	int
;	O
dv	struct
->	O
dv_vec	pointer
=	O
xrealloc	function
(	O
dv	struct
->	O
dv_vec	pointer
,	O
sizeof	O
(	O
void	O
*	O
)	O
*	O
dv	struct
->	O
dv_capacity	int
)	O
;	O
}	O
dv	struct
->	O
dv_vec	array
[	O
dv	struct
->	O
dv_fill	int
++	O
]	O
=	O
element	pointer
;	O
}	O
int	O
io_size	function
(	O
FILE	struct
*	O
,	O
void	O
*	O
,	O
unsigned	O
int	O
size	int
,	O
int	O
)	O
;	O
char	O
const	O
*	O
locate_id_file_name	function
(	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
static	O
char	O
file_name_buffer	array
[	O
BUFSIZ	int
]	O
;	O
char	O
*	O
buf	pointer
=	O
file_name_buffer	array
;	O
char	O
*	O
id_path	pointer
=	O
0	int
;	O
struct	O
stat	struct
rootb	struct
;	O
struct	O
stat	struct
statb	struct
;	O
if	O
(	O
arg	pointer
==	O
0	int
)	O
{	O
id_path	pointer
=	O
getenv	function
(	O
"IDPATH"	pointer
)	O
;	O
if	O
(	O
id_path	pointer
)	O
{	O
id_path	pointer
=	O
strdup	function
(	O
id_path	pointer
)	O
;	O
arg	pointer
=	O
strsep	function
(	O
&	O
id_path	O
,	O
":"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
arg	int
==	O
0	int
)	O
arg	pointer
=	O
DEFAULT_ID_FILE_NAME	int
;	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
return	O
arg	pointer
;	O
if	O
(	O
stat	struct
(	O
arg	pointer
,	O
&	O
statb	struct
)	O
==	O
0	int
)	O
return	O
arg	pointer
;	O
if	O
(	O
stat	O
(	O
"/"	pointer
,	O
&	O
rootb	struct
)	O
!=	O
0	int
)	O
return	O
NULL	O
;	O
do	O
{	O
strcpy	function
(	O
buf	pointer
,	O
"../"	pointer
)	O
;	O
buf	pointer
+=	O
3	int
;	O
strcpy	function
(	O
buf	pointer
,	O
arg	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
file_name_buffer	array
,	O
&	O
statb	struct
)	O
==	O
0	int
)	O
return	O
file_name_buffer	array
;	O
*	O
buf	pointer
=	O
'\0'	O
;	O
if	O
(	O
stat	struct
(	O
file_name_buffer	array
,	O
&	O
statb	struct
)	O
!=	O
0	int
)	O
return	O
NULL	O
;	O
}	O
while	O
(	O
statb	struct
.	O
st_ino	long
!=	O
rootb	struct
.	O
st_ino	long
||	O
statb	struct
.	O
st_dev	long
!=	O
rootb	struct
.	O
st_dev	long
)	O
;	O
return	O
NULL	O
;	O
}	O
int	O
sizeof_idhead	function
(	O
)	O
{	O
return	O
io_idhead	function
(	O
0	int
,	O
io_size	pointer
,	O
0	int
)	O
;	O
}	O
int	O
io_size	function
(	O
FILE	struct
*	O
ignore_FILE	pointer
,	O
void	O
*	O
ignore_addr	pointer
,	O
unsigned	O
int	O
size	int
,	O
int	O
io_type	int
)	O
{	O
if	O
(	O
io_type	int
==	O
IO_TYPE_STR	int
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"can't determine the io_size of a string!"	pointer
)	O
)	O
;	O
return	O
size	int
;	O
}	O
int	O
io_idhead	function
(	O
FILE	struct
*	O
fp	pointer
,	O
io_func_t	pointer
iof	pointer
,	O
struct	O
idhead	struct
*	O
idhp	pointer
)	O
{	O
unsigned	O
int	O
size	int
=	O
0	int
;	O
unsigned	O
char	O
pad	int
=	O
0	int
;	O
if	O
(	O
fp	pointer
)	O
fseek	function
(	O
fp	pointer
,	O
0L	int
,	O
0	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
idhp	pointer
->	O
idh_magic	int
,	O
2	int
,	O
IO_TYPE_FIX	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
pad	pointer
,	O
1	int
,	O
IO_TYPE_FIX	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_version	O
,	O
1	int
,	O
IO_TYPE_FIX	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_flags	O
,	O
2	int
,	O
IO_TYPE_INT	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_file_links	O
,	O
4	int
,	O
IO_TYPE_INT	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_files	int
,	O
4	int
,	O
IO_TYPE_INT	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_tokens	O
,	O
4	int
,	O
IO_TYPE_INT	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_buf_size	O
,	O
4	int
,	O
IO_TYPE_INT	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_vec_size	O
,	O
4	int
,	O
IO_TYPE_INT	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_tokens_offset	O
,	O
4	int
,	O
IO_TYPE_INT	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_flinks_offset	O
,	O
4	int
,	O
IO_TYPE_INT	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_end_offset	O
,	O
4	int
,	O
IO_TYPE_INT	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_max_link	char
,	O
2	int
,	O
IO_TYPE_INT	int
)	O
;	O
size	int
+=	O
iof	function
(	O
fp	pointer
,	O
&	O
idhp	pointer
->	O
idh_max_path	O
,	O
2	int
,	O
IO_TYPE_INT	int
)	O
;	O
return	O
size	int
;	O
}	O
void	O
scan_files	function
(	O
struct	O
idhead	struct
*	O
idhp	pointer
)	O
;	O
void	O
scan_member_file	function
(	O
struct	O
member_file	struct
const	O
*	O
member	pointer
)	O
;	O
void	O
usage	function
(	O
void	O
)	O
;	O
char	O
const	O
*	O
program_name	pointer
;	O
int	O
show_version	int
=	O
0	int
;	O
int	O
show_help	int
=	O
0	int
;	O
struct	O
idhead	struct
idh	struct
;	O
struct	O
file_link	struct
*	O
cw_dlink	pointer
;	O
int	O
no_id_flag	int
=	O
1	int
;	O
enum	O
separator_style	enum
separator_style	enum
=	O
ss_contextual	int
;	O
void	O
usage	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try `%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
static	O
struct	O
option	struct
const	O
long_options	array
[	O
]	O
=	O
{	O
{	O
"file"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"separator"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
&	O
show_help	int
,	O
1	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
&	O
show_version	int
,	O
1	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
void	O
help_me	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION]... [PATTERN]...\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Print constituent file names that match PATTERN,\nusing shell-style wildcards.\n  -f, --file=FILE        file name of ID database\n  -S, --separator=STYLE  STYLE is one of `braces', `space' or `newline'\n      --help             display this help and exit\n      --version          output version information and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"\nReport bugs to "	pointer
PACKAGE_BUGREPORT	pointer
"\n\n"	pointer
)	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
program_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
idh	struct
.	O
idh_file_name	int
=	O
0	int
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"f:S:"	pointer
,	O
long_options	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
'f'	O
:	O
idh	struct
.	O
idh_file_name	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'S'	O
:	O
separator_style	pointer
=	O
parse_separator_style	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
show_version	int
)	O
{	O
printf	function
(	O
"%s - %s\n"	pointer
,	O
program_name	pointer
,	O
PACKAGE_VERSION	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
show_help	int
)	O
help_me	function
(	O
)	O
;	O
if	O
(	O
separator_style	enum
==	O
ss_contextual	int
)	O
{	O
if	O
(	O
isatty	function
(	O
STDOUT_FILENO	int
)	O
)	O
separator_style	double
=	O
DEFAULT_SEPARATOR_STYLE	int
;	O
else	O
separator_style	enum
=	O
ss_newline	int
;	O
}	O
argc	int
-=	O
optind	int
;	O
argv	pointer
+=	O
optind	int
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
static	O
char	O
star	array
[	O
]	O
=	O
"*"	pointer
;	O
static	O
char	O
*	O
starp	pointer
=	O
star	char
;	O
argc	int
=	O
1	int
;	O
argv	pointer
=	O
&	O
starp	struct
;	O
}	O
idh	struct
.	O
idh_file_name	int
=	O
locate_id_file_name	function
(	O
idh	struct
.	O
idh_file_name	pointer
)	O
;	O
if	O
(	O
idh	struct
.	O
idh_file_name	int
==	O
0	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't locate `ID'"	pointer
)	O
)	O
;	O
init_idh_obstacks	function
(	O
&	O
idh	struct
)	O
;	O
init_idh_tables	function
(	O
&	O
idh	struct
)	O
;	O
cw_dlink	pointer
=	O
get_current_dir_link	function
(	O
)	O
;	O
{	O
struct	O
file_link	struct
*	O
*	O
members	pointer
=	O
read_id_file	function
(	O
idh	struct
.	O
idh_file_name	pointer
,	O
&	O
idh	struct
)	O
;	O
struct	O
file_link	struct
*	O
*	O
members_N	pointer
=	O
&	O
members	pointer
[	O
idh	struct
.	O
idh_files	int
]	O
;	O
struct	O
file_link	struct
*	O
*	O
flinkv_0	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
file_link	struct
*	O
)	O
*	O
(	O
idh	struct
.	O
idh_files	long
+	O
1	int
)	O
)	O
;	O
struct	O
file_link	struct
*	O
*	O
flinkv	pointer
=	O
flinkv_0	pointer
;	O
char	O
*	O
*	O
patv_0	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
argc	int
*	O
2	int
)	O
)	O
;	O
char	O
*	O
*	O
patv_N	pointer
;	O
char	O
*	O
*	O
patv	pointer
=	O
patv_0	pointer
;	O
char	O
*	O
file_name	pointer
=	O
alloca	function
(	O
PATH_MAX	int
)	O
;	O
for	O
(	O
;	O
argc	int
;	O
argc	int
--	O
,	O
argv	pointer
++	O
)	O
{	O
char	O
*	O
arg	pointer
=	O
*	O
argv	pointer
;	O
*	O
patv	pointer
++	O
=	O
arg	pointer
;	O
if	O
(	O
*	O
arg	pointer
!=	O
'*'	O
&&	O
*	O
arg	pointer
!=	O
'/'	O
)	O
{	O
char	O
*	O
pat	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
arg	pointer
)	O
+	O
2	int
)	O
;	O
sprintf	function
(	O
pat	pointer
,	O
"*/%s"	pointer
,	O
arg	pointer
)	O
;	O
*	O
patv	pointer
++	O
=	O
pat	pointer
;	O
}	O
}	O
patv_N	enum
=	O
patv	int
;	O
for	O
(	O
;	O
members	pointer
<	O
members_N	pointer
;	O
members	pointer
++	O
)	O
{	O
maybe_relative_file_name	function
(	O
file_name	pointer
,	O
*	O
members	pointer
,	O
cw_dlink	pointer
)	O
;	O
for	O
(	O
patv	pointer
=	O
patv_0	pointer
;	O
patv	int
<	O
patv_N	int
;	O
patv	int
++	O
)	O
{	O
if	O
(	O
fnmatch	function
(	O
*	O
patv	pointer
,	O
file_name	pointer
,	O
MAYBE_FNM_CASEFOLD	pointer
)	O
==	O
0	int
)	O
{	O
*	O
flinkv	pointer
++	O
=	O
*	O
members	pointer
;	O
break	O
;	O
}	O
}	O
}	O
*	O
flinkv	pointer
=	O
0	int
;	O
print_filenames	function
(	O
flinkv_0	pointer
,	O
separator_style	enum
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
display_file	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
code	int
)	O
{	O
char	O
*	O
cp	pointer
,	O
line	array
[	O
LINE_MAX	int
]	O
;	O
FILE	struct
*	O
fp	pointer
=	O
fopen	function
(	O
name	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
fgets	function
(	O
line	pointer
,	O
sizeof	O
(	O
line	pointer
)	O
,	O
fp	pointer
)	O
!=	O
NULL	O
)	O
{	O
cp	pointer
=	O
strchr	function
(	O
line	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
cp	pointer
!=	O
NULL	O
)	O
*	O
cp	pointer
=	O
'\0'	O
;	O
lreply	function
(	O
code	int
,	O
"%s"	pointer
,	O
line	pointer
)	O
;	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
errno	O
;	O
}	O
int	O
checkuser	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
int	O
found	int
=	O
0	int
;	O
char	O
*	O
p	pointer
,	O
line	array
[	O
BUFSIZ	int
]	O
;	O
fp	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
fgets	function
(	O
line	array
,	O
sizeof	O
(	O
line	array
)	O
,	O
fp	pointer
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
line	pointer
[	O
0	int
]	O
==	O
'#'	O
)	O
continue	O
;	O
p	pointer
=	O
strchr	function
(	O
line	array
,	O
'\n'	O
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
if	O
(	O
strcmp	function
(	O
line	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
return	O
(	O
found	int
)	O
;	O
}	O
struct	O
file_pid	struct
{	O
FILE	struct
*	O
file	pointer
;	O
pid_t	int
pid	int
;	O
struct	O
file_pid	struct
*	O
next	pointer
;	O
}	O
;	O
struct	O
file_pid	struct
*	O
file_pids	pointer
=	O
0	int
;	O
extern	O
int	O
ls_main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
;	O
FILE	struct
*	O
ftpd_popen	function
(	O
char	O
*	O
program	pointer
,	O
const	O
char	O
*	O
type	pointer
)	O
{	O
char	O
*	O
cp	pointer
;	O
FILE	struct
*	O
iop	pointer
;	O
struct	O
file_pid	struct
*	O
fpid	pointer
;	O
int	O
argc	int
,	O
gargc	pointer
,	O
pdes	array
[	O
2	int
]	O
,	O
pid	int
;	O
char	O
*	O
*	O
pop	pointer
,	O
*	O
argv	pointer
[	O
MAX_ARGC	int
]	O
,	O
*	O
gargv	array
[	O
MAX_GARGC	int
]	O
;	O
if	O
(	O
(	O
(	O
*	O
type	enum
!=	O
'r'	O
)	O
&&	O
(	O
*	O
type	enum
!=	O
'w'	O
)	O
)	O
||	O
type	pointer
[	O
1	int
]	O
)	O
return	O
(	O
NULL	O
)	O
;	O
if	O
(	O
pipe	function
(	O
pdes	pointer
)	O
<	O
0	int
)	O
return	O
(	O
NULL	O
)	O
;	O
for	O
(	O
argc	int
=	O
0	int
,	O
cp	pointer
=	O
program	pointer
;	O
argc	int
<	O
MAX_ARGC	int
-	O
1	int
;	O
cp	pointer
=	O
NULL	O
,	O
argc	int
++	O
)	O
if	O
(	O
!	O
(	O
argv	pointer
[	O
argc	int
]	O
=	O
strtok	function
(	O
cp	pointer
,	O
" \t\n"	pointer
)	O
)	O
)	O
break	O
;	O
argv	pointer
[	O
MAX_ARGC	int
-	O
1	int
]	O
=	O
NULL	O
;	O
gargv	array
[	O
0	int
]	O
=	O
argv	pointer
[	O
0	int
]	O
;	O
for	O
(	O
gargc	int
=	O
argc	int
=	O
1	int
;	O
argv	pointer
[	O
argc	int
]	O
;	O
argc	int
++	O
)	O
{	O
glob_t	pointer
gl	pointer
;	O
int	O
flags	int
=	O
GLOB_NOCHECK	int
;	O
flags	int
|=	O
GLOB_BRACE	int
;	O
flags	int
|=	O
GLOB_TILDE	int
;	O
memset	function
(	O
&	O
gl	struct
,	O
0	int
,	O
sizeof	O
(	O
gl	struct
)	O
)	O
;	O
if	O
(	O
glob	function
(	O
argv	pointer
[	O
argc	int
]	O
,	O
flags	int
,	O
NULL	O
,	O
&	O
gl	function
)	O
)	O
gargv	array
[	O
gargc	int
++	O
]	O
=	O
strdup	function
(	O
argv	pointer
[	O
argc	int
]	O
)	O
;	O
else	O
for	O
(	O
pop	pointer
=	O
gl	struct
.	O
gl_pathv	pointer
;	O
*	O
pop	pointer
;	O
pop	pointer
++	O
)	O
gargv	array
[	O
gargc	int
++	O
]	O
=	O
strdup	function
(	O
*	O
pop	pointer
)	O
;	O
globfree	function
(	O
&	O
gl	pointer
)	O
;	O
}	O
gargv	array
[	O
gargc	int
]	O
=	O
NULL	O
;	O
iop	pointer
=	O
NULL	O
;	O
pid	int
=	O
(	O
strcmp	function
(	O
gargv	array
[	O
0	int
]	O
,	O
"/bin/ls"	pointer
)	O
==	O
0	int
)	O
?	O
fork	function
(	O
)	O
:	O
vfork	function
(	O
)	O
;	O
switch	O
(	O
pid	int
)	O
{	O
case	O
-	O
1	int
:	O
close	pointer
(	O
pdes	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
pdes	array
[	O
1	int
]	O
)	O
;	O
goto	O
pfree	O
;	O
case	O
0	int
:	O
if	O
(	O
*	O
type	pointer
==	O
'r'	O
)	O
{	O
if	O
(	O
pdes	array
[	O
1	int
]	O
!=	O
STDOUT_FILENO	int
)	O
{	O
dup2	function
(	O
pdes	array
[	O
1	int
]	O
,	O
STDOUT_FILENO	int
)	O
;	O
close	pointer
(	O
pdes	array
[	O
1	int
]	O
)	O
;	O
}	O
dup2	function
(	O
STDOUT_FILENO	int
,	O
STDERR_FILENO	int
)	O
;	O
close	pointer
(	O
pdes	array
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pdes	array
[	O
0	int
]	O
!=	O
STDIN_FILENO	int
)	O
{	O
dup2	function
(	O
pdes	array
[	O
0	int
]	O
,	O
STDIN_FILENO	int
)	O
;	O
close	pointer
(	O
pdes	array
[	O
0	int
]	O
)	O
;	O
}	O
close	pointer
(	O
pdes	array
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
gargv	array
[	O
0	int
]	O
,	O
"/bin/ls"	pointer
)	O
==	O
0	int
)	O
{	O
optind	int
=	O
0	int
;	O
exit	function
(	O
ls_main	function
(	O
gargc	pointer
,	O
gargv	pointer
)	O
)	O
;	O
}	O
execv	function
(	O
gargv	array
[	O
0	int
]	O
,	O
gargv	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
*	O
type	enum
==	O
'r'	O
)	O
{	O
iop	pointer
=	O
fdopen	function
(	O
pdes	array
[	O
0	int
]	O
,	O
type	pointer
)	O
;	O
close	pointer
(	O
pdes	array
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
iop	pointer
=	O
fdopen	function
(	O
pdes	array
[	O
1	int
]	O
,	O
type	pointer
)	O
;	O
close	pointer
(	O
pdes	array
[	O
0	int
]	O
)	O
;	O
}	O
fpid	pointer
=	O
(	O
struct	O
file_pid	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
file_pid	struct
)	O
)	O
;	O
if	O
(	O
fpid	pointer
)	O
{	O
fpid	pointer
->	O
file	pointer
=	O
iop	int
;	O
fpid	pointer
->	O
pid	int
=	O
pid	int
;	O
fpid	pointer
->	O
next	pointer
=	O
file_pids	int
;	O
file_pids	int
=	O
fpid	int
;	O
}	O
pfree	O
:	O
for	O
(	O
argc	int
=	O
1	int
;	O
gargv	array
[	O
argc	int
]	O
!=	O
NULL	O
;	O
argc	int
++	O
)	O
free	function
(	O
gargv	pointer
[	O
argc	int
]	O
)	O
;	O
return	O
(	O
iop	pointer
)	O
;	O
}	O
int	O
ftpd_pclose	function
(	O
FILE	struct
*	O
iop	pointer
)	O
{	O
struct	O
file_pid	struct
*	O
fpid	pointer
=	O
file_pids	pointer
,	O
*	O
prev_fpid	pointer
=	O
0	int
;	O
int	O
status	int
;	O
sigset_t	O
sigs	pointer
,	O
osigs	int
;	O
pid_t	int
pid	int
;	O
while	O
(	O
fpid	pointer
&&	O
fpid	pointer
->	O
file	pointer
!=	O
iop	int
)	O
{	O
prev_fpid	pointer
=	O
fpid	pointer
;	O
fpid	pointer
=	O
fpid	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
!	O
fpid	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
prev_fpid	pointer
)	O
prev_fpid	pointer
->	O
next	pointer
=	O
fpid	pointer
->	O
next	pointer
;	O
else	O
file_pids	pointer
=	O
fpid	pointer
->	O
next	pointer
;	O
fclose	function
(	O
iop	pointer
)	O
;	O
sigemptyset	function
(	O
&	O
sigs	struct
)	O
;	O
sigaddset	function
(	O
&	O
sigs	O
,	O
SIGINT	int
)	O
;	O
sigaddset	function
(	O
&	O
sigs	O
,	O
SIGQUIT	int
)	O
;	O
sigaddset	function
(	O
&	O
sigs	O
,	O
SIGHUP	int
)	O
;	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
sigs	O
,	O
&	O
osigs	struct
)	O
;	O
while	O
(	O
(	O
pid	int
=	O
waitpid	function
(	O
fpid	pointer
->	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
)	O
<	O
0	int
&&	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
free	function
(	O
fpid	pointer
)	O
;	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
&	O
osigs	struct
,	O
0	int
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
return	O
(	O
pid	int
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
return	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
err	int
=	O
0	int
;	O
int	O
sfd	int
;	O
struct	O
ifconfig	struct
*	O
ifp	pointer
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
parse_cmdline	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
sfd	int
=	O
socket	function
(	O
AF_INET	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sfd	int
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"socket error"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
for	O
(	O
ifp	pointer
=	O
ifs	pointer
;	O
ifp	pointer
<	O
ifs	int
+	O
nifs	int
;	O
ifp	pointer
++	O
)	O
{	O
err	int
=	O
configure_if	function
(	O
sfd	int
,	O
ifp	pointer
)	O
;	O
if	O
(	O
err	int
)	O
break	O
;	O
}	O
close	pointer
(	O
sfd	int
)	O
;	O
return	O
err	int
;	O
}	O
void	O
cleanup_session	function
(	O
char	O
*	O
tty	pointer
,	O
int	O
pty_fd	int
)	O
{	O
char	O
*	O
line	pointer
;	O
if	O
(	O
strncmp	function
(	O
tty	pointer
,	O
PATH_TTY_PFX	pointer
,	O
sizeof	O
PATH_TTY_PFX	pointer
-	O
1	int
)	O
==	O
0	int
)	O
line	int
=	O
tty	int
+	O
sizeof	O
PATH_TTY_PFX	int
-	O
1	int
;	O
else	O
line	pointer
=	O
tty	pointer
;	O
if	O
(	O
logout	function
(	O
line	pointer
)	O
)	O
logwtmp	function
(	O
line	pointer
,	O
""	pointer
,	O
""	pointer
)	O
;	O
chmod	function
(	O
tty	pointer
,	O
0666	int
)	O
;	O
chown	function
(	O
tty	pointer
,	O
0	int
,	O
0	int
)	O
;	O
fchmod	function
(	O
pty_fd	pointer
,	O
0666	int
)	O
;	O
fchown	function
(	O
pty_fd	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
struct	O
bf	struct
{	O
int	O
counter	int
;	O
char	O
buf	array
[	O
PKTSIZE	int
]	O
;	O
}	O
bfs	array
[	O
2	int
]	O
;	O
static	O
int	O
nextone	int
;	O
static	O
int	O
current	int
;	O
int	O
newline	int
=	O
0	int
;	O
int	O
prevchar	int
=	O
-	O
1	int
;	O
static	O
struct	O
tftphdr	struct
*	O
rw_init	function
(	O
int	O
)	O
;	O
struct	O
tftphdr	struct
*	O
w_init	function
(	O
void	O
)	O
{	O
return	O
rw_init	function
(	O
0	int
)	O
;	O
}	O
struct	O
tftphdr	struct
*	O
r_init	function
(	O
void	O
)	O
{	O
return	O
rw_init	function
(	O
1	int
)	O
;	O
}	O
static	O
struct	O
tftphdr	struct
*	O
rw_init	function
(	O
int	O
x	int
)	O
{	O
newline	int
=	O
0	int
;	O
prevchar	int
=	O
-	O
1	int
;	O
bfs	array
[	O
0	int
]	O
.	O
counter	int
=	O
BF_ALLOC	int
;	O
current	int
=	O
0	int
;	O
bfs	array
[	O
1	int
]	O
.	O
counter	int
=	O
BF_FREE	int
;	O
nextone	int
=	O
x	double
;	O
return	O
(	O
struct	O
tftphdr	struct
*	O
)	O
bfs	array
[	O
0	int
]	O
.	O
buf	pointer
;	O
}	O
int	O
readit	function
(	O
FILE	struct
*	O
file	pointer
,	O
struct	O
tftphdr	struct
*	O
*	O
dpp	pointer
,	O
int	O
convert	pointer
)	O
{	O
struct	O
bf	struct
*	O
b	pointer
;	O
bfs	array
[	O
current	int
]	O
.	O
counter	int
=	O
BF_FREE	int
;	O
current	pointer
=	O
!	O
current	pointer
;	O
b	array
=	O
&	O
bfs	array
[	O
current	int
]	O
;	O
if	O
(	O
b	pointer
->	O
counter	int
==	O
BF_FREE	int
)	O
read_ahead	function
(	O
file	pointer
,	O
convert	pointer
)	O
;	O
*	O
dpp	pointer
=	O
(	O
struct	O
tftphdr	struct
*	O
)	O
b	pointer
->	O
buf	pointer
;	O
return	O
b	pointer
->	O
counter	int
;	O
}	O
void	O
read_ahead	function
(	O
FILE	struct
*	O
file	pointer
,	O
int	O
convert	pointer
)	O
{	O
register	O
int	O
i	int
;	O
register	O
char	O
*	O
p	pointer
;	O
register	O
int	O
c	int
;	O
struct	O
bf	struct
*	O
b	pointer
;	O
struct	O
tftphdr	struct
*	O
dp	pointer
;	O
b	int
=	O
&	O
bfs	array
[	O
nextone	int
]	O
;	O
if	O
(	O
b	pointer
->	O
counter	int
!=	O
BF_FREE	int
)	O
return	O
;	O
nextone	int
=	O
!	O
nextone	int
;	O
dp	pointer
=	O
(	O
struct	O
tftphdr	struct
*	O
)	O
b	pointer
->	O
buf	pointer
;	O
if	O
(	O
convert	pointer
==	O
0	int
)	O
{	O
b	pointer
->	O
counter	int
=	O
read	function
(	O
fileno	function
(	O
file	pointer
)	O
,	O
dp	pointer
->	O
th_data	pointer
,	O
SEGSIZE	int
)	O
;	O
return	O
;	O
}	O
p	pointer
=	O
dp	pointer
->	O
th_data	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SEGSIZE	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
newline	int
)	O
{	O
if	O
(	O
prevchar	int
==	O
'\n'	O
)	O
c	int
=	O
'\n'	O
;	O
else	O
c	int
=	O
'\0'	O
;	O
newline	int
=	O
0	int
;	O
}	O
else	O
{	O
c	int
=	O
getc	function
(	O
file	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
break	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
'\r'	O
)	O
{	O
prevchar	int
=	O
c	int
;	O
c	int
=	O
'\r'	O
;	O
newline	int
=	O
1	int
;	O
}	O
}	O
*	O
p	pointer
++	O
=	O
c	int
;	O
}	O
b	pointer
->	O
counter	int
=	O
(	O
int	O
)	O
(	O
p	pointer
-	O
dp	pointer
->	O
th_data	pointer
)	O
;	O
}	O
int	O
writeit	function
(	O
FILE	struct
*	O
file	pointer
,	O
struct	O
tftphdr	struct
*	O
*	O
dpp	pointer
,	O
int	O
ct	int
,	O
int	O
convert	int
)	O
{	O
bfs	array
[	O
current	int
]	O
.	O
counter	int
=	O
ct	int
;	O
current	int
=	O
!	O
current	pointer
;	O
if	O
(	O
bfs	array
[	O
current	int
]	O
.	O
counter	int
!=	O
BF_FREE	int
)	O
write_behind	function
(	O
file	pointer
,	O
convert	pointer
)	O
;	O
bfs	array
[	O
current	int
]	O
.	O
counter	int
=	O
BF_ALLOC	int
;	O
*	O
dpp	pointer
=	O
(	O
struct	O
tftphdr	struct
*	O
)	O
bfs	array
[	O
current	int
]	O
.	O
buf	pointer
;	O
return	O
ct	int
;	O
}	O
int	O
write_behind	function
(	O
FILE	struct
*	O
file	pointer
,	O
int	O
convert	pointer
)	O
{	O
char	O
*	O
buf	pointer
;	O
int	O
count	int
;	O
register	O
int	O
ct	int
;	O
register	O
char	O
*	O
p	pointer
;	O
register	O
int	O
c	int
;	O
struct	O
bf	struct
*	O
b	pointer
;	O
struct	O
tftphdr	struct
*	O
dp	pointer
;	O
b	int
=	O
&	O
bfs	array
[	O
nextone	int
]	O
;	O
if	O
(	O
b	pointer
->	O
counter	int
<	O
-	O
1	int
)	O
return	O
0	int
;	O
count	int
=	O
b	pointer
->	O
counter	int
;	O
b	pointer
->	O
counter	int
=	O
BF_FREE	int
;	O
dp	pointer
=	O
(	O
struct	O
tftphdr	struct
*	O
)	O
b	pointer
->	O
buf	pointer
;	O
nextone	int
=	O
!	O
nextone	pointer
;	O
buf	pointer
=	O
dp	pointer
->	O
th_data	int
;	O
if	O
(	O
count	int
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
convert	pointer
==	O
0	int
)	O
return	O
write	function
(	O
fileno	function
(	O
file	pointer
)	O
,	O
buf	pointer
,	O
count	int
)	O
;	O
p	pointer
=	O
buf	pointer
;	O
ct	pointer
=	O
count	int
;	O
while	O
(	O
ct	int
--	O
)	O
{	O
c	int
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
prevchar	int
==	O
'\r'	O
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
fseeko	function
(	O
file	pointer
,	O
-	O
1	int
,	O
1	int
)	O
;	O
else	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
goto	O
skipit	O
;	O
}	O
putc	function
(	O
c	int
,	O
file	pointer
)	O
;	O
skipit	O
:	O
prevchar	int
=	O
c	int
;	O
}	O
return	O
count	int
;	O
}	O
int	O
synchnet	function
(	O
int	O
f	int
)	O
{	O
int	O
i	int
,	O
j	int
=	O
0	int
;	O
char	O
rbuf	pointer
[	O
PKTSIZE	int
]	O
;	O
struct	O
sockaddr_storage	O
from	pointer
;	O
socklen_t	int
fromlen	int
;	O
while	O
(	O
1	int
)	O
{	O
ioctl	function
(	O
f	int
,	O
FIONREAD	int
,	O
&	O
i	int
)	O
;	O
if	O
(	O
i	int
)	O
{	O
j	int
++	O
;	O
fromlen	int
=	O
sizeof	O
from	pointer
;	O
recvfrom	function
(	O
f	pointer
,	O
rbuf	pointer
,	O
sizeof	O
(	O
rbuf	pointer
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	pointer
,	O
&	O
fromlen	O
)	O
;	O
}	O
else	O
{	O
return	O
(	O
j	int
)	O
;	O
}	O
}	O
}	O
void	O
utmp_init	function
(	O
char	O
*	O
line	pointer
,	O
char	O
*	O
user	pointer
,	O
char	O
*	O
id	pointer
)	O
{	O
struct	O
utmpx	struct
utx	struct
;	O
struct	O
timeval	struct
tv	struct
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
&	O
utx	struct
,	O
0	int
,	O
sizeof	O
(	O
utx	struct
)	O
)	O
;	O
strncpy	function
(	O
utx	struct
.	O
ut_id	pointer
,	O
id	int
,	O
sizeof	O
(	O
utx	struct
.	O
ut_id	pointer
)	O
)	O
;	O
strncpy	function
(	O
utx	struct
.	O
ut_user	pointer
,	O
user	pointer
,	O
sizeof	O
(	O
utx	struct
.	O
ut_user	pointer
)	O
)	O
;	O
strncpy	function
(	O
utx	struct
.	O
ut_host	array
,	O
user	pointer
,	O
sizeof	O
(	O
utx	struct
.	O
ut_host	array
)	O
)	O
;	O
strncpy	function
(	O
utx	struct
.	O
ut_line	array
,	O
line	pointer
,	O
sizeof	O
(	O
utx	struct
.	O
ut_line	array
)	O
)	O
;	O
utx	struct
.	O
ut_pid	int
=	O
getpid	function
(	O
)	O
;	O
utx	struct
.	O
ut_type	short
=	O
LOGIN_PROCESS	int
;	O
gettimeofday	function
(	O
&	O
tv	struct
,	O
0	int
)	O
;	O
utx	struct
.	O
ut_tv	struct
.	O
tv_sec	long
=	O
tv	struct
.	O
tv_sec	long
;	O
utx	struct
.	O
ut_tv	struct
.	O
tv_usec	long
=	O
tv	struct
.	O
tv_usec	long
;	O
pututxline	function
(	O
&	O
utx	struct
)	O
;	O
updwtmpx	function
(	O
PATH_WTMPX	pointer
,	O
&	O
utx	struct
)	O
;	O
endutxent	function
(	O
)	O
;	O
}	O
char	O
*	O
utmp_ptsid	function
(	O
char	O
*	O
line	pointer
,	O
char	O
*	O
tag	pointer
)	O
{	O
static	O
char	O
buf	pointer
[	O
5	int
]	O
;	O
strncpy	function
(	O
buf	pointer
,	O
tag	pointer
,	O
2	int
)	O
;	O
strncpy	function
(	O
buf	pointer
+	O
2	int
,	O
line	pointer
+	O
strlen	function
(	O
line	pointer
)	O
-	O
2	int
,	O
2	int
)	O
;	O
return	O
(	O
buf	pointer
)	O
;	O
}	O
int	O
namecmp	function
(	O
const	O
FTSENT	struct
*	O
a	pointer
,	O
const	O
FTSENT	struct
*	O
b	pointer
)	O
{	O
return	O
(	O
strcmp	function
(	O
a	pointer
->	O
fts_name	pointer
,	O
b	pointer
->	O
fts_name	pointer
)	O
)	O
;	O
}	O
int	O
revnamecmp	function
(	O
const	O
FTSENT	struct
*	O
a	pointer
,	O
const	O
FTSENT	struct
*	O
b	pointer
)	O
{	O
return	O
(	O
strcmp	function
(	O
b	pointer
->	O
fts_name	pointer
,	O
a	pointer
->	O
fts_name	pointer
)	O
)	O
;	O
}	O
int	O
modcmp	function
(	O
const	O
FTSENT	struct
*	O
a	pointer
,	O
const	O
FTSENT	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_mtime	O
>	O
a	pointer
->	O
fts_statp	pointer
->	O
st_mtime	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_mtime	O
<	O
a	pointer
->	O
fts_statp	pointer
->	O
st_mtime	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
return	O
(	O
namecmp	function
(	O
a	pointer
,	O
b	int
)	O
)	O
;	O
}	O
int	O
revmodcmp	function
(	O
const	O
FTSENT	struct
*	O
a	pointer
,	O
const	O
FTSENT	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_mtime	O
>	O
a	pointer
->	O
fts_statp	pointer
->	O
st_mtime	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_mtime	O
<	O
a	pointer
->	O
fts_statp	pointer
->	O
st_mtime	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
revnamecmp	function
(	O
a	pointer
,	O
b	int
)	O
)	O
;	O
}	O
int	O
acccmp	function
(	O
const	O
FTSENT	struct
*	O
a	pointer
,	O
const	O
FTSENT	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_atime	O
>	O
a	pointer
->	O
fts_statp	pointer
->	O
st_atime	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_atime	O
<	O
a	pointer
->	O
fts_statp	pointer
->	O
st_atime	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
return	O
(	O
namecmp	function
(	O
a	pointer
,	O
b	int
)	O
)	O
;	O
}	O
int	O
revacccmp	function
(	O
const	O
FTSENT	struct
*	O
a	pointer
,	O
const	O
FTSENT	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_atime	O
>	O
a	pointer
->	O
fts_statp	pointer
->	O
st_atime	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_atime	O
<	O
a	pointer
->	O
fts_statp	pointer
->	O
st_atime	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
revnamecmp	function
(	O
a	pointer
,	O
b	int
)	O
)	O
;	O
}	O
int	O
statcmp	function
(	O
const	O
FTSENT	struct
*	O
a	pointer
,	O
const	O
FTSENT	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_ctime	enum
>	O
a	pointer
->	O
fts_statp	pointer
->	O
st_ctime	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_ctime	O
<	O
a	pointer
->	O
fts_statp	pointer
->	O
st_ctime	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
return	O
(	O
namecmp	function
(	O
a	pointer
,	O
b	int
)	O
)	O
;	O
}	O
int	O
revstatcmp	function
(	O
const	O
FTSENT	struct
*	O
a	pointer
,	O
const	O
FTSENT	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_ctime	enum
>	O
a	pointer
->	O
fts_statp	pointer
->	O
st_ctime	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_ctime	O
<	O
a	pointer
->	O
fts_statp	pointer
->	O
st_ctime	O
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
revnamecmp	function
(	O
a	pointer
,	O
b	int
)	O
)	O
;	O
}	O
int	O
sizecmp	function
(	O
const	O
FTSENT	struct
*	O
a	pointer
,	O
const	O
FTSENT	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_size	long
>	O
a	pointer
->	O
fts_statp	pointer
->	O
st_size	long
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_size	long
<	O
a	pointer
->	O
fts_statp	pointer
->	O
st_size	long
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
return	O
(	O
namecmp	function
(	O
a	pointer
,	O
b	pointer
)	O
)	O
;	O
}	O
int	O
revsizecmp	function
(	O
const	O
FTSENT	struct
*	O
a	pointer
,	O
const	O
FTSENT	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_size	double
>	O
a	pointer
->	O
fts_statp	pointer
->	O
st_size	long
)	O
return	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
b	pointer
->	O
fts_statp	pointer
->	O
st_size	long
<	O
a	pointer
->	O
fts_statp	pointer
->	O
st_size	long
)	O
return	O
(	O
1	int
)	O
;	O
else	O
return	O
(	O
revnamecmp	function
(	O
a	pointer
,	O
b	pointer
)	O
)	O
;	O
}	O
char	O
*	O
flags_to_string	function
(	O
u_int	int
flags	int
,	O
char	O
*	O
def	pointer
)	O
{	O
static	O
char	O
string	pointer
[	O
128	int
]	O
;	O
char	O
*	O
prefix	pointer
;	O
string	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
prefix	pointer
=	O
NULL	O
;	O
return	O
(	O
prefix	pointer
==	O
NULL	O
&&	O
def	pointer
!=	O
NULL	O
?	O
def	pointer
:	O
string	pointer
)	O
;	O
}	O
int	O
string_to_flags	function
(	O
char	O
*	O
*	O
stringp	pointer
,	O
u_int	int
*	O
setp	pointer
,	O
u_int	int
*	O
clrp	pointer
)	O
{	O
if	O
(	O
setp	pointer
)	O
*	O
setp	pointer
=	O
0	int
;	O
if	O
(	O
clrp	pointer
)	O
*	O
clrp	pointer
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
set_cloexec_flag	function
(	O
int	O
desc	int
,	O
bool	bool
value	bool
)	O
{	O
int	O
flags	int
=	O
fcntl	function
(	O
desc	int
,	O
F_GETFD	int
,	O
0	int
)	O
;	O
if	O
(	O
0	int
<=	O
flags	int
)	O
{	O
int	O
newflags	int
=	O
(	O
value	bool
?	O
flags	int
|	O
FD_CLOEXEC	int
:	O
flags	int
&	O
~	O
FD_CLOEXEC	int
)	O
;	O
if	O
(	O
flags	int
==	O
newflags	int
||	O
fcntl	function
(	O
desc	int
,	O
F_SETFD	int
,	O
newflags	int
)	O
!=	O
-	O
1	int
)	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
dup_cloexec	function
(	O
int	O
fd	int
)	O
{	O
return	O
fcntl	function
(	O
fd	int
,	O
F_DUPFD_CLOEXEC	int
,	O
0	int
)	O
;	O
}	O
const	O
struct	O
gl_list_implementation	struct
gl_linked_list_implementation	struct
=	O
{	O
gl_linked_nx_create_empty	function
,	O
gl_linked_nx_create	function
,	O
gl_linked_size	function
,	O
gl_linked_node_value	function
,	O
gl_linked_node_nx_set_value	function
,	O
gl_linked_next_node	function
,	O
gl_linked_previous_node	function
,	O
gl_linked_get_at	function
,	O
gl_linked_nx_set_at	function
,	O
gl_linked_search_from_to	function
,	O
gl_linked_indexof_from_to	function
,	O
gl_linked_nx_add_first	function
,	O
gl_linked_nx_add_last	function
,	O
gl_linked_nx_add_before	function
,	O
gl_linked_nx_add_after	function
,	O
gl_linked_nx_add_at	function
,	O
gl_linked_remove_node	function
,	O
gl_linked_remove_at	function
,	O
gl_linked_remove	function
,	O
gl_linked_list_free	function
,	O
gl_linked_iterator	function
,	O
gl_linked_iterator_from_to	function
,	O
gl_linked_iterator_next	function
,	O
gl_linked_iterator_free	function
,	O
gl_linked_sortedlist_search	function
,	O
gl_linked_sortedlist_search_from_to	function
,	O
gl_linked_sortedlist_indexof	function
,	O
gl_linked_sortedlist_indexof_from_to	function
,	O
gl_linked_sortedlist_nx_add	function
,	O
gl_linked_sortedlist_remove	function
}	O
;	O
int	O
mkstemp	function
(	O
char	O
*	O
xtemplate	pointer
)	O
{	O
return	O
__gen_tempname	O
(	O
xtemplate	pointer
,	O
0	int
,	O
0	int
,	O
__GT_FILE	O
)	O
;	O
}	O
char	O
*	O
fread_file	function
(	O
FILE	struct
*	O
stream	pointer
,	O
size_t	long
*	O
length	pointer
)	O
{	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
alloc	long
=	O
BUFSIZ	int
;	O
{	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
fstat	function
(	O
fileno	function
(	O
stream	pointer
)	O
,	O
&	O
st	struct
)	O
>=	O
0	int
&&	O
S_ISREG	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
off_t	long
pos	long
=	O
ftello	function
(	O
stream	pointer
)	O
;	O
if	O
(	O
pos	long
>=	O
0	int
&&	O
pos	long
<	O
st	struct
.	O
st_size	long
)	O
{	O
off_t	long
alloc_off	long
=	O
st	struct
.	O
st_size	long
-	O
pos	long
;	O
if	O
(	O
SIZE_MAX	O
-	O
1	int
<	O
alloc_off	long
)	O
{	O
errno	O
=	O
ENOMEM	int
;	O
return	O
NULL	O
;	O
}	O
alloc	long
=	O
alloc_off	long
+	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
(	O
buf	pointer
=	O
malloc	function
(	O
alloc	long
)	O
)	O
)	O
return	O
NULL	O
;	O
{	O
size_t	long
size	long
=	O
0	int
;	O
int	O
save_errno	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
requested	long
=	O
alloc	long
-	O
size	long
;	O
size_t	long
count	long
=	O
fread	function
(	O
buf	pointer
+	O
size	long
,	O
1	int
,	O
requested	long
,	O
stream	pointer
)	O
;	O
size	long
+=	O
count	long
;	O
if	O
(	O
count	long
!=	O
requested	long
)	O
{	O
save_errno	int
=	O
errno	O
;	O
if	O
(	O
ferror	function
(	O
stream	pointer
)	O
)	O
break	O
;	O
if	O
(	O
size	long
<	O
alloc	long
-	O
1	int
)	O
{	O
char	O
*	O
smaller_buf	pointer
=	O
realloc	function
(	O
buf	pointer
,	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
smaller_buf	pointer
!=	O
NULL	O
)	O
buf	pointer
=	O
smaller_buf	pointer
;	O
}	O
buf	pointer
[	O
size	long
]	O
=	O
'\0'	O
;	O
*	O
length	pointer
=	O
size	long
;	O
return	O
buf	pointer
;	O
}	O
{	O
char	O
*	O
new_buf	pointer
;	O
if	O
(	O
alloc	long
==	O
SIZE_MAX	O
)	O
{	O
save_errno	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
if	O
(	O
alloc	long
<	O
SIZE_MAX	O
-	O
alloc	long
/	O
2	int
)	O
alloc	long
=	O
alloc	long
+	O
alloc	long
/	O
2	int
;	O
else	O
alloc	long
=	O
SIZE_MAX	O
;	O
if	O
(	O
!	O
(	O
new_buf	pointer
=	O
realloc	function
(	O
buf	pointer
,	O
alloc	long
)	O
)	O
)	O
{	O
save_errno	int
=	O
errno	O
;	O
break	O
;	O
}	O
buf	pointer
=	O
new_buf	pointer
;	O
}	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
errno	O
=	O
save_errno	int
;	O
return	O
NULL	O
;	O
}	O
}	O
static	O
char	O
*	O
internal_read_file	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
size_t	long
*	O
length	pointer
,	O
const	O
char	O
*	O
mode	pointer
)	O
{	O
FILE	struct
*	O
stream	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
mode	pointer
)	O
;	O
char	O
*	O
out	pointer
;	O
int	O
save_errno	int
;	O
if	O
(	O
!	O
stream	pointer
)	O
return	O
NULL	O
;	O
out	pointer
=	O
fread_file	function
(	O
stream	pointer
,	O
length	pointer
)	O
;	O
save_errno	int
=	O
errno	O
;	O
if	O
(	O
fclose	function
(	O
stream	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
out	pointer
)	O
{	O
save_errno	int
=	O
errno	O
;	O
free	function
(	O
out	pointer
)	O
;	O
}	O
errno	O
=	O
save_errno	int
;	O
return	O
NULL	O
;	O
}	O
return	O
out	pointer
;	O
}	O
char	O
*	O
read_file	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
size_t	long
*	O
length	pointer
)	O
{	O
return	O
internal_read_file	function
(	O
filename	pointer
,	O
length	pointer
,	O
"r"	pointer
)	O
;	O
}	O
char	O
*	O
read_binary_file	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
size_t	long
*	O
length	pointer
)	O
{	O
return	O
internal_read_file	function
(	O
filename	pointer
,	O
length	pointer
,	O
"rb"	pointer
)	O
;	O
}	O
enum	O
{	O
COPYRIGHT_YEAR	int
=	O
2011	int
}	O
;	O
void	O
version_etc_arn	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
char	O
*	O
command_name	pointer
,	O
const	O
char	O
*	O
package	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
const	O
char	O
*	O
const	O
*	O
authors	pointer
,	O
size_t	long
n_authors	long
)	O
{	O
if	O
(	O
command_name	pointer
)	O
fprintf	function
(	O
stream	pointer
,	O
"%s (%s) %s\n"	pointer
,	O
command_name	pointer
,	O
package	pointer
,	O
version	pointer
)	O
;	O
else	O
fprintf	function
(	O
stream	pointer
,	O
"%s %s\n"	pointer
,	O
package	pointer
,	O
version	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
version_etc_copyright	array
,	O
_	O
(	O
"(C)"	pointer
)	O
,	O
COPYRIGHT_YEAR	int
)	O
;	O
fputs	function
(	O
_	O
(	O
"\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n"	pointer
)	O
,	O
stream	pointer
)	O
;	O
switch	O
(	O
n_authors	long
)	O
{	O
case	O
0	int
:	O
abort	function
(	O
)	O
;	O
case	O
1	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\nand %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
)	O
;	O
break	O
;	O
case	O
5	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
)	O
;	O
break	O
;	O
case	O
6	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, %s, and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
,	O
authors	pointer
[	O
5	int
]	O
)	O
;	O
break	O
;	O
case	O
7	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, %s, %s, and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
,	O
authors	pointer
[	O
5	int
]	O
,	O
authors	pointer
[	O
6	int
]	O
)	O
;	O
break	O
;	O
case	O
8	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
,	O
authors	pointer
[	O
5	int
]	O
,	O
authors	pointer
[	O
6	int
]	O
,	O
authors	pointer
[	O
7	int
]	O
)	O
;	O
break	O
;	O
case	O
9	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
,	O
authors	pointer
[	O
5	int
]	O
,	O
authors	pointer
[	O
6	int
]	O
,	O
authors	pointer
[	O
7	int
]	O
,	O
authors	pointer
[	O
8	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
,	O
authors	pointer
[	O
5	int
]	O
,	O
authors	pointer
[	O
6	int
]	O
,	O
authors	pointer
[	O
7	int
]	O
,	O
authors	pointer
[	O
8	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
void	O
version_etc_ar	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
char	O
*	O
command_name	pointer
,	O
const	O
char	O
*	O
package	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
const	O
char	O
*	O
const	O
*	O
authors	pointer
)	O
{	O
size_t	long
n_authors	long
;	O
for	O
(	O
n_authors	long
=	O
0	int
;	O
authors	pointer
[	O
n_authors	long
]	O
;	O
n_authors	long
++	O
)	O
;	O
version_etc_arn	function
(	O
stream	pointer
,	O
command_name	pointer
,	O
package	pointer
,	O
version	pointer
,	O
authors	pointer
,	O
n_authors	long
)	O
;	O
}	O
void	O
version_etc_va	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
char	O
*	O
command_name	pointer
,	O
const	O
char	O
*	O
package	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
va_list	array
authors	pointer
)	O
{	O
size_t	long
n_authors	long
;	O
const	O
char	O
*	O
authtab	array
[	O
10	int
]	O
;	O
for	O
(	O
n_authors	long
=	O
0	int
;	O
n_authors	long
<	O
10	int
&&	O
(	O
authtab	array
[	O
n_authors	long
]	O
=	O
va_arg	O
(	O
authors	pointer
,	O
const	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
;	O
n_authors	long
++	O
)	O
;	O
version_etc_arn	function
(	O
stream	pointer
,	O
command_name	pointer
,	O
package	pointer
,	O
version	pointer
,	O
authtab	array
,	O
n_authors	long
)	O
;	O
}	O
void	O
version_etc	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
char	O
*	O
command_name	pointer
,	O
const	O
char	O
*	O
package	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
...	O
)	O
{	O
va_list	array
authors	pointer
;	O
va_start	O
(	O
authors	pointer
,	O
version	pointer
)	O
;	O
version_etc_va	function
(	O
stream	pointer
,	O
command_name	pointer
,	O
package	pointer
,	O
version	pointer
,	O
authors	pointer
)	O
;	O
va_end	O
(	O
authors	pointer
)	O
;	O
}	O
void	O
emit_bug_reporting_address	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"\nReport bugs to: %s\n"	pointer
)	O
,	O
PACKAGE_BUGREPORT	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"%s home page: <%s>\n"	pointer
)	O
,	O
PACKAGE_NAME	pointer
,	O
PACKAGE_URL	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"General help using GNU software: <http://www.gnu.org/gethelp/>\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
char	O
*	O
xgetcwd	function
(	O
void	O
)	O
{	O
char	O
*	O
cwd	pointer
=	O
getcwd	function
(	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
cwd	pointer
&&	O
errno	O
==	O
ENOMEM	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
cwd	pointer
;	O
}	O
char	O
*	O
xgethostname	function
(	O
void	O
)	O
{	O
char	O
*	O
hostname	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
INITIAL_HOSTNAME_LENGTH	int
;	O
while	O
(	O
1	int
)	O
{	O
size_t	long
size_1	long
;	O
hostname	pointer
=	O
x2realloc	function
(	O
hostname	pointer
,	O
&	O
size	long
)	O
;	O
size_1	long
=	O
size	long
-	O
1	int
;	O
hostname	pointer
[	O
size_1	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
errno	O
=	O
0	int
;	O
if	O
(	O
gethostname	function
(	O
hostname	pointer
,	O
size_1	long
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
hostname	pointer
[	O
size_1	long
-	O
1	int
]	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
errno	O
!=	O
0	int
&&	O
errno	O
!=	O
ENAMETOOLONG	int
&&	O
errno	O
!=	O
EINVAL	int
&&	O
errno	O
!=	O
ENOMEM	int
)	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
free	function
(	O
hostname	pointer
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
NULL	O
;	O
}	O
}	O
return	O
hostname	pointer
;	O
}	O
void	O
dologin	function
(	O
struct	O
passwd	struct
*	O
pw	pointer
,	O
struct	O
sockaddr_in	struct
*	O
sin	pointer
)	O
;	O
struct	O
sockaddr_in	struct
hisctladdr	struct
;	O
int	O
hisaddrlen	int
=	O
sizeof	O
hisctladdr	pointer
;	O
struct	O
sockaddr_in	struct
myctladdr	struct
;	O
int	O
mypid	int
;	O
char	O
Username	array
[	O
64	int
]	O
;	O
char	O
*	O
nenv	array
[	O
]	O
=	O
{	O
Username	pointer
,	O
NULL	O
,	O
}	O
;	O
extern	O
char	O
*	O
*	O
environ	pointer
;	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
"TCP/IP server for uucico"	function
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
register	O
int	O
s	pointer
;	O
struct	O
servent	struct
*	O
sp	pointer
;	O
void	O
dologout	function
(	O
void	O
)	O
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
iu_argp_init	O
(	O
"uucpd"	pointer
,	O
default_program_authors	array
)	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
environ	pointer
=	O
nenv	pointer
;	O
sp	pointer
=	O
getservbyname	function
(	O
"uucp"	pointer
,	O
"tcp"	pointer
)	O
;	O
if	O
(	O
sp	pointer
==	O
NULL	O
)	O
{	O
perror	function
(	O
"uucpd: getservbyname"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
fork	function
(	O
)	O
)	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
(	O
s	pointer
=	O
open	function
(	O
PATH_TTY	int
,	O
O_RDWR	int
)	O
)	O
>=	O
0	int
)	O
{	O
ioctl	function
(	O
s	int
,	O
TIOCNOTTY	int
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
close	function
(	O
s	int
)	O
;	O
}	O
memset	function
(	O
&	O
myctladdr	struct
,	O
0	int
,	O
sizeof	O
(	O
myctladdr	struct
)	O
)	O
;	O
myctladdr	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
myctladdr	struct
.	O
sin_port	short
=	O
sp	pointer
->	O
s_port	int
;	O
}	O
static	O
int	O
readline	function
(	O
register	O
char	O
*	O
p	pointer
,	O
register	O
int	O
n	int
)	O
{	O
char	O
c	int
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
{	O
if	O
(	O
read	pointer
(	O
0	int
,	O
&	O
c	int
,	O
1	int
)	O
<=	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
c	int
&=	O
0177	int
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
'\r'	O
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
*	O
p	pointer
++	O
=	O
c	int
;	O
}	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
void	O
doit	function
(	O
struct	O
sockaddr_in	struct
*	O
sinp	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pw	pointer
,	O
*	O
getpwnam	function
(	O
const	O
char	O
*	O
)	O
;	O
char	O
user	pointer
[	O
64	int
]	O
,	O
passwd	pointer
[	O
64	int
]	O
;	O
char	O
*	O
xpasswd	pointer
;	O
alarm	function
(	O
60	int
)	O
;	O
printf	function
(	O
"login: "	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
readline	function
(	O
user	pointer
,	O
sizeof	O
user	pointer
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"user read\n"	pointer
)	O
;	O
return	O
;	O
}	O
user	pointer
[	O
8	int
]	O
=	O
'\0'	O
;	O
pw	pointer
=	O
getpwnam	function
(	O
user	pointer
)	O
;	O
if	O
(	O
pw	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"user unknown\n"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
pw	pointer
->	O
pw_shell	pointer
,	O
PATH_UUCICO	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Login incorrect."	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
pw	pointer
->	O
pw_passwd	pointer
&&	O
*	O
pw	pointer
->	O
pw_passwd	pointer
!=	O
'\0'	O
)	O
{	O
printf	function
(	O
"Password: "	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
readline	function
(	O
passwd	struct
,	O
sizeof	O
passwd	pointer
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"passwd read\n"	pointer
)	O
;	O
return	O
;	O
}	O
xpasswd	pointer
=	O
crypt	function
(	O
passwd	struct
,	O
pw	pointer
->	O
pw_passwd	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
xpasswd	pointer
,	O
pw	pointer
->	O
pw_passwd	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Login incorrect."	pointer
)	O
;	O
return	O
;	O
}	O
}	O
alarm	function
(	O
0	int
)	O
;	O
sprintf	function
(	O
Username	pointer
,	O
"USER=%s"	pointer
,	O
user	pointer
)	O
;	O
dologin	function
(	O
pw	pointer
,	O
sinp	pointer
)	O
;	O
setgid	function
(	O
pw	pointer
->	O
pw_gid	int
)	O
;	O
chdir	function
(	O
pw	pointer
->	O
pw_dir	pointer
)	O
;	O
setuid	function
(	O
pw	pointer
->	O
pw_uid	int
)	O
;	O
perror	function
(	O
"uucico server: execl"	pointer
)	O
;	O
}	O
void	O
dologout	function
(	O
void	O
)	O
{	O
int	O
pid	int
;	O
while	O
(	O
(	O
pid	int
=	O
wait3	function
(	O
0	int
,	O
WNOHANG	int
,	O
0	int
)	O
)	O
>	O
0	int
)	O
{	O
char	O
line	array
[	O
100	int
]	O
;	O
sprintf	function
(	O
line	pointer
,	O
"uucp%.4d"	pointer
,	O
pid	int
)	O
;	O
logwtmp	function
(	O
line	array
,	O
""	pointer
,	O
""	pointer
)	O
;	O
}	O
}	O
void	O
dologin	function
(	O
struct	O
passwd	struct
*	O
pw	pointer
,	O
struct	O
sockaddr_in	struct
*	O
sin	pointer
)	O
{	O
char	O
line	array
[	O
32	int
]	O
;	O
char	O
remotehost	array
[	O
32	int
]	O
;	O
int	O
f	pointer
;	O
struct	O
hostent	struct
*	O
hp	pointer
=	O
gethostbyaddr	function
(	O
(	O
char	O
*	O
)	O
&	O
sin	struct
->	O
sin_addr	struct
,	O
sizeof	O
(	O
struct	O
in_addr	struct
)	O
,	O
AF_INET	O
)	O
;	O
if	O
(	O
hp	pointer
)	O
{	O
strncpy	function
(	O
remotehost	O
,	O
hp	pointer
->	O
h_name	pointer
,	O
sizeof	O
(	O
remotehost	pointer
)	O
)	O
;	O
endhostent	function
(	O
)	O
;	O
}	O
else	O
strncpy	function
(	O
remotehost	pointer
,	O
inet_ntoa	function
(	O
sin	pointer
->	O
sin_addr	struct
)	O
,	O
sizeof	O
(	O
remotehost	struct
)	O
)	O
;	O
sprintf	function
(	O
line	pointer
,	O
"uucp%.4d"	pointer
,	O
getpid	function
(	O
)	O
)	O
;	O
logwtmp	function
(	O
line	pointer
,	O
pw	pointer
->	O
pw_name	pointer
,	O
remotehost	int
)	O
;	O
f	pointer
=	O
open	function
(	O
PATH_LASTLOG	int
,	O
O_RDWR	int
)	O
;	O
if	O
(	O
f	int
>=	O
0	int
)	O
{	O
struct	O
lastlog	O
ll	int
;	O
time_t	long
t	long
;	O
time	function
(	O
&	O
t	long
)	O
;	O
ll	struct
.	O
ll_time	pointer
=	O
t	pointer
;	O
lseek	function
(	O
f	pointer
,	O
(	O
long	O
)	O
pw	pointer
->	O
pw_uid	int
*	O
sizeof	O
(	O
struct	O
lastlog	struct
)	O
,	O
0	int
)	O
;	O
strcpy	function
(	O
line	pointer
,	O
remotehost	pointer
)	O
;	O
SCPYN	function
(	O
ll	struct
.	O
ll_line	pointer
,	O
line	int
)	O
;	O
SCPYN	function
(	O
ll	struct
.	O
ll_host	int
,	O
remotehost	int
)	O
;	O
write	function
(	O
f	pointer
,	O
(	O
char	O
*	O
)	O
&	O
ll	int
,	O
sizeof	O
ll	pointer
)	O
;	O
close	pointer
(	O
f	int
)	O
;	O
}	O
}	O
extern	O
char	O
*	O
ttymsg	function
(	O
struct	O
iovec	struct
*	O
iov	pointer
,	O
int	O
iovcnt	int
,	O
char	O
*	O
line	pointer
,	O
int	O
tmout	int
)	O
;	O
typedef	O
struct	O
{	O
int	O
ind	int
;	O
int	O
max_size	int
;	O
char	O
line	array
[	O
N_LINES	int
]	O
[	O
N_CHARS	int
]	O
;	O
int	O
size	int
[	O
N_LINES	int
]	O
;	O
char	O
buf	pointer
[	O
N_LINES	int
*	O
N_CHARS	pointer
+	O
3	int
]	O
;	O
}	O
LINE	pointer
;	O
static	O
void	O
init_line	function
(	O
LINE	struct
*	O
lp	pointer
)	O
{	O
memset	function
(	O
lp	pointer
,	O
0	int
,	O
sizeof	O
*	O
lp	pointer
)	O
;	O
}	O
static	O
void	O
format_line	function
(	O
LINE	struct
*	O
lp	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
i	int
=	O
lp	pointer
->	O
ind	long
;	O
if	O
(	O
lp	pointer
->	O
ind	long
>=	O
N_LINES	int
)	O
return	O
;	O
lp	pointer
->	O
ind	long
++	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
lp	pointer
->	O
size	array
[	O
i	int
]	O
=	O
vsnprintf	function
(	O
lp	pointer
->	O
line	array
[	O
i	int
]	O
,	O
sizeof	O
lp	pointer
->	O
line	array
[	O
i	int
]	O
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
lp	pointer
->	O
max_size	int
=	O
MAX	O
(	O
lp	pointer
->	O
max_size	int
,	O
lp	pointer
->	O
size	array
[	O
i	int
]	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
static	O
char	O
*	O
finish_line	function
(	O
LINE	struct
*	O
lp	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
lp	pointer
->	O
buf	pointer
;	O
*	O
p	pointer
++	O
=	O
'\a'	O
;	O
*	O
p	pointer
++	O
=	O
'\r'	O
;	O
*	O
p	pointer
++	O
=	O
'\n'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
lp	pointer
->	O
ind	long
;	O
i	int
++	O
)	O
{	O
char	O
*	O
q	pointer
;	O
int	O
j	int
;	O
for	O
(	O
q	pointer
=	O
lp	pointer
->	O
line	array
[	O
i	int
]	O
;	O
*	O
q	pointer
;	O
q	pointer
++	O
)	O
*	O
p	pointer
++	O
=	O
*	O
q	pointer
;	O
for	O
(	O
j	int
=	O
lp	pointer
->	O
size	array
[	O
i	int
]	O
;	O
j	int
<	O
lp	pointer
->	O
max_size	int
+	O
2	int
;	O
j	int
++	O
)	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
*	O
p	pointer
++	O
=	O
'\r'	O
;	O
*	O
p	pointer
++	O
=	O
'\n'	O
;	O
}	O
*	O
p	pointer
=	O
0	int
;	O
return	O
lp	pointer
->	O
buf	pointer
;	O
}	O
static	O
int	O
print_mesg	function
(	O
char	O
*	O
tty	pointer
,	O
CTL_MSG	struct
*	O
request	pointer
,	O
char	O
*	O
remote_machine	pointer
)	O
{	O
time_t	long
t	long
;	O
LINE	struct
ln	pointer
;	O
char	O
*	O
buf	pointer
;	O
struct	O
tm	struct
*	O
tm	struct
;	O
struct	O
iovec	struct
iovec	struct
;	O
char	O
*	O
cp	pointer
;	O
time	function
(	O
&	O
t	long
)	O
;	O
tm	struct
=	O
localtime	function
(	O
&	O
t	long
)	O
;	O
init_line	function
(	O
&	O
ln	struct
)	O
;	O
format_line	function
(	O
&	O
ln	struct
,	O
""	pointer
)	O
;	O
format_line	function
(	O
&	O
ln	struct
,	O
"Message from Talk_Daemon@%s at %d:%02d ..."	pointer
,	O
hostname	pointer
,	O
tm	struct
->	O
tm_hour	int
,	O
tm	struct
->	O
tm_min	int
)	O
;	O
format_line	function
(	O
&	O
ln	pointer
,	O
"talk: connection requested by %s@%s"	pointer
,	O
request	pointer
->	O
l_name	array
,	O
remote_machine	int
)	O
;	O
format_line	function
(	O
&	O
ln	pointer
,	O
"talk: respond with:  talk %s@%s"	pointer
,	O
request	pointer
->	O
l_name	array
,	O
remote_machine	int
)	O
;	O
format_line	function
(	O
&	O
ln	pointer
,	O
""	pointer
)	O
;	O
format_line	function
(	O
&	O
ln	pointer
,	O
""	pointer
)	O
;	O
buf	pointer
=	O
finish_line	function
(	O
&	O
ln	pointer
)	O
;	O
iovec	struct
.	O
iov_base	pointer
=	O
buf	pointer
;	O
iovec	struct
.	O
iov_len	long
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
(	O
cp	pointer
=	O
ttymsg	function
(	O
&	O
iovec	int
,	O
1	int
,	O
tty	int
,	O
RING_WAIT	int
-	O
5	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
syslog	function
(	O
LOG_CRIT	int
,	O
"%s"	pointer
,	O
cp	pointer
)	O
;	O
return	O
FAILED	int
;	O
}	O
return	O
SUCCESS	int
;	O
}	O
int	O
announce	function
(	O
CTL_MSG	struct
*	O
request	pointer
,	O
char	O
*	O
remote_machine	pointer
)	O
{	O
char	O
*	O
ttypath	pointer
;	O
int	O
len	int
;	O
struct	O
stat	struct
st	struct
;	O
int	O
rc	int
;	O
len	int
=	O
sizeof	O
(	O
PATH_DEV	O
)	O
+	O
strlen	function
(	O
request	pointer
->	O
r_tty	array
)	O
+	O
2	int
;	O
ttypath	pointer
=	O
malloc	function
(	O
len	int
)	O
;	O
if	O
(	O
!	O
ttypath	pointer
)	O
{	O
syslog	function
(	O
LOG_CRIT	int
,	O
"out of memory"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
sprintf	function
(	O
ttypath	pointer
,	O
"%s/%s"	pointer
,	O
PATH_DEV	O
,	O
request	pointer
->	O
r_tty	array
)	O
;	O
rc	int
=	O
stat	struct
(	O
ttypath	pointer
,	O
&	O
st	struct
)	O
;	O
free	function
(	O
ttypath	pointer
)	O
;	O
if	O
(	O
rc	int
<	O
0	int
||	O
(	O
st	struct
.	O
st_mode	int
&	O
S_IWGRP	O
)	O
==	O
0	int
)	O
return	O
PERMISSION_DENIED	int
;	O
return	O
print_mesg	function
(	O
request	pointer
->	O
r_tty	array
,	O
request	int
,	O
remote_machine	pointer
)	O
;	O
}	O
struct	O
sockaddr_in	struct
daemon_addr	struct
=	O
{	O
AF_INET	O
}	O
;	O
struct	O
sockaddr_in	struct
ctl_addr	struct
=	O
{	O
AF_INET	O
}	O
;	O
struct	O
sockaddr_in	struct
my_addr	struct
=	O
{	O
AF_INET	O
}	O
;	O
struct	O
in_addr	struct
my_machine_addr	struct
;	O
struct	O
in_addr	struct
his_machine_addr	struct
;	O
unsigned	O
short	O
daemon_port	char
;	O
int	O
ctl_sockt	int
;	O
int	O
sockt	int
;	O
int	O
invitation_waiting	int
=	O
0	int
;	O
CTL_MSG	struct
msg	struct
;	O
int	O
open_sockt	function
(	O
void	O
)	O
{	O
socklen_t	int
length	int
;	O
my_addr	struct
.	O
sin_addr	struct
=	O
my_machine_addr	struct
;	O
my_addr	struct
.	O
sin_port	short
=	O
0	int
;	O
sockt	int
=	O
socket	function
(	O
AF_INET	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
sockt	int
<=	O
0	int
)	O
p_error	function
(	O
"Bad socket"	pointer
)	O
;	O
if	O
(	O
bind	function
(	O
sockt	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
my_addr	struct
,	O
sizeof	O
(	O
my_addr	struct
)	O
)	O
!=	O
0	int
)	O
p_error	function
(	O
"Binding local socket"	pointer
)	O
;	O
length	int
=	O
sizeof	O
(	O
my_addr	struct
)	O
;	O
if	O
(	O
getsockname	function
(	O
sockt	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
my_addr	struct
,	O
&	O
length	int
)	O
==	O
-	O
1	int
)	O
p_error	function
(	O
"Bad address for socket"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
open_ctl	function
(	O
void	O
)	O
{	O
socklen_t	int
length	int
;	O
ctl_addr	struct
.	O
sin_port	short
=	O
0	int
;	O
ctl_addr	struct
.	O
sin_addr	struct
=	O
my_machine_addr	struct
;	O
ctl_sockt	int
=	O
socket	function
(	O
AF_INET	O
,	O
SOCK_DGRAM	int
,	O
0	int
)	O
;	O
if	O
(	O
ctl_sockt	int
<=	O
0	int
)	O
p_error	function
(	O
"Bad socket"	pointer
)	O
;	O
if	O
(	O
bind	function
(	O
ctl_sockt	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
ctl_addr	struct
,	O
sizeof	O
(	O
ctl_addr	struct
)	O
)	O
!=	O
0	int
)	O
p_error	function
(	O
"Couldn't bind to control socket"	pointer
)	O
;	O
length	int
=	O
sizeof	O
(	O
ctl_addr	struct
)	O
;	O
if	O
(	O
getsockname	function
(	O
ctl_sockt	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
ctl_addr	struct
,	O
&	O
length	int
)	O
==	O
-	O
1	int
)	O
p_error	function
(	O
"Bad address for ctl socket"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
ctl_transact	function
(	O
struct	O
in_addr	struct
target	struct
,	O
CTL_MSG	struct
msg	struct
,	O
int	O
type	int
,	O
CTL_RESPONSE	struct
*	O
rp	pointer
)	O
{	O
int	O
nready	int
,	O
cc	int
;	O
fd_set	struct
read_mask	struct
,	O
ctl_mask	pointer
;	O
struct	O
timeval	struct
wait	struct
;	O
msg	struct
.	O
type	enum
=	O
type	int
;	O
daemon_addr	struct
.	O
sin_addr	struct
=	O
target	int
;	O
daemon_addr	struct
.	O
sin_port	short
=	O
daemon_port	short
;	O
FD_ZERO	O
(	O
&	O
ctl_mask	struct
)	O
;	O
FD_SET	O
(	O
ctl_sockt	int
,	O
&	O
ctl_mask	struct
)	O
;	O
do	O
{	O
wait	struct
.	O
tv_sec	long
=	O
CTL_WAIT	int
;	O
wait	struct
.	O
tv_usec	long
=	O
0	int
;	O
do	O
{	O
cc	enum
=	O
sendto	function
(	O
ctl_sockt	int
,	O
(	O
char	O
*	O
)	O
&	O
msg	struct
,	O
sizeof	O
(	O
msg	struct
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
daemon_addr	struct
,	O
sizeof	O
(	O
daemon_addr	struct
)	O
)	O
;	O
if	O
(	O
cc	int
!=	O
sizeof	O
(	O
msg	struct
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
p_error	function
(	O
"Error on write to talk daemon"	pointer
)	O
;	O
}	O
read_mask	int
=	O
ctl_mask	int
;	O
nready	int
=	O
select	function
(	O
32	int
,	O
&	O
read_mask	struct
,	O
0	int
,	O
0	int
,	O
&	O
wait	O
)	O
;	O
if	O
(	O
nready	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
p_error	function
(	O
"Error waiting for daemon response"	pointer
)	O
;	O
}	O
}	O
while	O
(	O
nready	int
==	O
0	int
)	O
;	O
do	O
{	O
cc	int
=	O
recv	function
(	O
ctl_sockt	int
,	O
(	O
char	O
*	O
)	O
rp	pointer
,	O
sizeof	O
(	O
*	O
rp	pointer
)	O
,	O
0	int
)	O
;	O
if	O
(	O
cc	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
p_error	function
(	O
"Error on read from talk daemon"	pointer
)	O
;	O
}	O
read_mask	int
=	O
ctl_mask	int
;	O
timerclear	O
(	O
&	O
wait	int
)	O
;	O
nready	int
=	O
select	function
(	O
32	int
,	O
&	O
read_mask	struct
,	O
0	int
,	O
0	int
,	O
&	O
wait	O
)	O
;	O
}	O
while	O
(	O
nready	int
>	O
0	int
&&	O
(	O
rp	pointer
->	O
vers	char
!=	O
TALK_VERSION	int
||	O
rp	pointer
->	O
type	char
!=	O
type	int
)	O
)	O
;	O
}	O
while	O
(	O
rp	pointer
->	O
vers	char
!=	O
TALK_VERSION	int
||	O
rp	pointer
->	O
type	char
!=	O
type	int
)	O
;	O
rp	pointer
->	O
id_num	int
=	O
ntohl	function
(	O
rp	pointer
->	O
id_num	int
)	O
;	O
rp	pointer
->	O
addr	struct
.	O
sa_family	short
=	O
ntohs	function
(	O
rp	pointer
->	O
addr	struct
.	O
sa_family	short
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
sig_sent	function
(	O
int	O
sig	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
message	function
(	O
"Connection closing. Exiting"	pointer
)	O
;	O
quit	function
(	O
)	O
;	O
}	O
int	O
init_display	function
(	O
void	O
)	O
{	O
struct	O
sigaction	struct
siga	struct
;	O
if	O
(	O
initscr	function
(	O
)	O
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"Terminal type unset or lacking necessary features."	int
)	O
;	O
sigaction	struct
(	O
SIGTSTP	int
,	O
(	O
struct	O
sigaction	struct
*	O
)	O
0	int
,	O
&	O
siga	struct
)	O
;	O
sigaddset	function
(	O
&	O
siga	struct
.	O
sa_mask	struct
,	O
SIGALRM	int
)	O
;	O
sigaction	struct
(	O
SIGTSTP	int
,	O
&	O
siga	struct
,	O
(	O
struct	O
sigaction	struct
*	O
)	O
0	int
)	O
;	O
curses_initialized	int
=	O
1	int
;	O
clear	function
(	O
)	O
;	O
refresh	function
(	O
)	O
;	O
noecho	function
(	O
)	O
;	O
crmode	function
(	O
)	O
;	O
signal	function
(	O
SIGINT	int
,	O
sig_sent	O
)	O
;	O
signal	function
(	O
SIGPIPE	int
,	O
sig_sent	O
)	O
;	O
my_win	struct
.	O
x_nlines	int
=	O
LINES	int
/	O
2	int
;	O
my_win	struct
.	O
x_ncols	enum
=	O
COLS	int
;	O
my_win	struct
.	O
x_win	pointer
=	O
newwin	function
(	O
my_win	struct
.	O
x_nlines	int
,	O
my_win	struct
.	O
x_ncols	pointer
,	O
0	int
,	O
0	int
)	O
;	O
scrollok	function
(	O
my_win	struct
.	O
x_win	pointer
,	O
FALSE	O
)	O
;	O
wclear	function
(	O
my_win	struct
.	O
x_win	pointer
)	O
;	O
his_win	struct
.	O
x_nlines	int
=	O
LINES	int
/	O
2	int
-	O
1	int
;	O
his_win	struct
.	O
x_ncols	enum
=	O
COLS	int
;	O
his_win	struct
.	O
x_win	pointer
=	O
newwin	function
(	O
his_win	struct
.	O
x_nlines	int
,	O
his_win	struct
.	O
x_ncols	int
,	O
my_win	struct
.	O
x_nlines	int
+	O
1	int
,	O
0	int
)	O
;	O
scrollok	function
(	O
his_win	struct
.	O
x_win	pointer
,	O
FALSE	O
)	O
;	O
wclear	function
(	O
his_win	struct
.	O
x_win	pointer
)	O
;	O
line_win	pointer
=	O
newwin	function
(	O
1	int
,	O
COLS	int
,	O
my_win	struct
.	O
x_nlines	int
,	O
0	int
)	O
;	O
box	function
(	O
line_win	pointer
,	O
'-'	O
,	O
'-'	O
)	O
;	O
wrefresh	function
(	O
line_win	pointer
)	O
;	O
current_state	pointer
=	O
"No connection yet"	pointer
;	O
return	O
0	int
;	O
}	O
int	O
set_edit_chars	function
(	O
void	O
)	O
{	O
int	O
cc	int
;	O
char	O
buf	pointer
[	O
3	int
]	O
;	O
struct	O
termios	O
tty	int
;	O
cc_t	struct
disable	int
=	O
(	O
cc_t	pointer
)	O
-	O
1	int
,	O
erase	int
,	O
werase	function
,	O
kill	int
;	O
erase	int
=	O
werase	function
=	O
kill	int
=	O
disable	int
;	O
if	O
(	O
tcgetattr	function
(	O
0	int
,	O
&	O
tty	int
)	O
>=	O
0	int
)	O
{	O
erase	int
=	O
tty	function
.	O
c_cc	array
[	O
VERASE	int
]	O
;	O
werase	int
=	O
tty	struct
.	O
c_cc	array
[	O
VWERASE	int
]	O
;	O
kill	int
=	O
tty	function
.	O
c_cc	array
[	O
VKILL	int
]	O
;	O
}	O
if	O
(	O
erase	int
==	O
disable	int
)	O
erase	int
=	O
'\177'	int
;	O
if	O
(	O
werase	function
==	O
disable	int
)	O
werase	function
=	O
'\027'	O
;	O
if	O
(	O
kill	int
==	O
disable	int
)	O
kill	int
=	O
'\025'	O
;	O
my_win	struct
.	O
cerase	char
=	O
erase	int
;	O
my_win	struct
.	O
werase	int
=	O
werase	function
;	O
my_win	struct
.	O
kill	enum
=	O
kill	int
;	O
buf	pointer
[	O
0	int
]	O
=	O
my_win	struct
.	O
cerase	char
;	O
buf	pointer
[	O
1	int
]	O
=	O
my_win	struct
.	O
kill	short
;	O
buf	pointer
[	O
2	int
]	O
=	O
my_win	struct
.	O
werase	int
;	O
cc	int
=	O
write	function
(	O
sockt	int
,	O
buf	array
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
if	O
(	O
cc	int
!=	O
sizeof	O
(	O
buf	pointer
)	O
)	O
p_error	function
(	O
"Lost the connection"	pointer
)	O
;	O
cc	O
=	O
read	function
(	O
sockt	int
,	O
buf	array
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
if	O
(	O
cc	int
!=	O
sizeof	O
(	O
buf	pointer
)	O
)	O
p_error	function
(	O
"Lost the connection"	pointer
)	O
;	O
his_win	struct
.	O
cerase	char
=	O
buf	pointer
[	O
0	int
]	O
;	O
his_win	struct
.	O
kill	short
=	O
buf	pointer
[	O
1	int
]	O
;	O
his_win	struct
.	O
werase	function
=	O
buf	pointer
[	O
2	int
]	O
;	O
return	O
0	int
;	O
}	O
int	O
quit	function
(	O
void	O
)	O
{	O
if	O
(	O
curses_initialized	int
)	O
{	O
wmove	function
(	O
his_win	struct
.	O
x_win	pointer
,	O
his_win	struct
.	O
x_nlines	int
-	O
1	int
,	O
0	int
)	O
;	O
wclrtoeol	function
(	O
his_win	struct
.	O
x_win	pointer
)	O
;	O
wrefresh	function
(	O
his_win	struct
.	O
x_win	pointer
)	O
;	O
endwin	function
(	O
)	O
;	O
}	O
if	O
(	O
invitation_waiting	int
)	O
send_delete	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
Ring	struct
ttyoring	struct
,	O
ttyiring	pointer
;	O
unsigned	O
char	O
ttyobuf	array
[	O
2	int
*	O
BUFSIZ	int
]	O
,	O
ttyibuf	array
[	O
BUFSIZ	int
]	O
;	O
int	O
termdata	int
;	O
cc_t	enum
termAytChar	enum
;	O
void	O
init_terminal	function
(	O
void	O
)	O
{	O
if	O
(	O
ring_init	function
(	O
&	O
ttyoring	struct
,	O
ttyobuf	pointer
,	O
sizeof	O
ttyobuf	pointer
)	O
!=	O
1	int
)	O
{	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
ring_init	function
(	O
&	O
ttyiring	struct
,	O
ttyibuf	pointer
,	O
sizeof	O
ttyibuf	pointer
)	O
!=	O
1	int
)	O
{	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
autoflush	pointer
=	O
TerminalAutoFlush	function
(	O
)	O
;	O
}	O
int	O
ttyflush	function
(	O
int	O
drop	int
)	O
{	O
register	O
int	O
n	int
,	O
n0	int
,	O
n1	int
;	O
n0	int
=	O
ring_full_count	function
(	O
&	O
ttyoring	int
)	O
;	O
if	O
(	O
(	O
n1	int
=	O
n	int
=	O
ring_full_consecutive	function
(	O
&	O
ttyoring	int
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
drop	int
)	O
{	O
TerminalFlushOutput	function
(	O
)	O
;	O
}	O
else	O
{	O
n	int
=	O
TerminalWrite	function
(	O
(	O
char	O
*	O
)	O
ttyoring	struct
.	O
consume	pointer
,	O
n	int
)	O
;	O
}	O
}	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
termdata	int
&&	O
n	int
)	O
{	O
Dump	function
(	O
'>'	O
,	O
ttyoring	struct
.	O
consume	pointer
,	O
n	int
)	O
;	O
}	O
if	O
(	O
n1	int
==	O
n	int
&&	O
n0	long
>	O
n	long
)	O
{	O
n1	long
=	O
n0	long
-	O
n	long
;	O
if	O
(	O
!	O
drop	int
)	O
n1	long
=	O
TerminalWrite	function
(	O
(	O
char	O
*	O
)	O
ttyoring	struct
.	O
bottom	pointer
,	O
n1	long
)	O
;	O
if	O
(	O
n1	long
>	O
0	int
)	O
n	long
+=	O
n1	long
;	O
}	O
ring_consumed	function
(	O
&	O
ttyoring	struct
,	O
n	long
)	O
;	O
}	O
if	O
(	O
n	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
n	long
==	O
n0	long
)	O
{	O
if	O
(	O
n0	long
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
return	O
n0	long
-	O
n	long
+	O
1	int
;	O
}	O
int	O
getconnmode	function
(	O
void	O
)	O
{	O
extern	O
int	O
linemode	int
;	O
int	O
mode	int
=	O
0	int
;	O
extern	O
int	O
kludgelinemode	int
;	O
if	O
(	O
In3270	int
)	O
return	O
(	O
MODE_FLOW	int
)	O
;	O
if	O
(	O
my_want_state_is_dont	function
(	O
TELOPT_ECHO	int
)	O
)	O
mode	int
|=	O
MODE_ECHO	int
;	O
if	O
(	O
localflow	int
)	O
mode	int
|=	O
MODE_FLOW	int
;	O
if	O
(	O
my_want_state_is_will	function
(	O
TELOPT_BINARY	int
)	O
)	O
mode	int
|=	O
MODE_INBIN	int
;	O
if	O
(	O
his_want_state_is_will	function
(	O
TELOPT_BINARY	int
)	O
)	O
mode	int
|=	O
MODE_OUTBIN	int
;	O
if	O
(	O
kludgelinemode	int
)	O
{	O
if	O
(	O
my_want_state_is_dont	function
(	O
TELOPT_SGA	int
)	O
)	O
{	O
mode	int
|=	O
(	O
MODE_TRAPSIG	int
|	O
MODE_EDIT	int
)	O
;	O
if	O
(	O
dontlecho	int
&&	O
(	O
clocks	struct
.	O
echotoggle	int
>	O
clocks	struct
.	O
modenegotiated	int
)	O
)	O
{	O
mode	int
&=	O
~	O
MODE_ECHO	int
;	O
}	O
}	O
return	O
(	O
mode	int
)	O
;	O
}	O
if	O
(	O
my_want_state_is_will	function
(	O
TELOPT_LINEMODE	int
)	O
)	O
mode	int
|=	O
linemode	int
;	O
return	O
(	O
mode	int
)	O
;	O
}	O
void	O
setconnmode	function
(	O
int	O
force	int
)	O
{	O
register	O
int	O
newmode	int
;	O
newmode	int
=	O
getconnmode	function
(	O
)	O
|	O
(	O
force	int
?	O
MODE_FORCE	int
:	O
0	int
)	O
;	O
TerminalNewMode	function
(	O
newmode	int
)	O
;	O
}	O
void	O
setcommandmode	function
(	O
void	O
)	O
{	O
TerminalNewMode	function
(	O
-	O
1	int
)	O
;	O
}	O
public	O
void	O
match_brac	function
(	O
obrac	pointer
,	O
cbrac	pointer
,	O
forwdir	pointer
,	O
n	int
)	O
int	O
obrac	int
;	O
int	O
cbrac	int
;	O
int	O
forwdir	int
;	O
int	O
n	int
;	O
{	O
int	O
c	int
;	O
int	O
nest	int
;	O
POSITION	long
pos	long
;	O
int	O
(	O
*	O
chget	pointer
)	O
(	O
)	O
;	O
extern	O
int	O
ch_forw_get	function
(	O
)	O
,	O
ch_back_get	function
(	O
)	O
;	O
pos	long
=	O
position	function
(	O
(	O
forwdir	int
)	O
?	O
TOP	O
:	O
BOTTOM	pointer
)	O
;	O
if	O
(	O
pos	long
==	O
NULL_POSITION	O
||	O
ch_seek	function
(	O
pos	long
)	O
)	O
{	O
if	O
(	O
forwdir	int
)	O
error	function
(	O
"Nothing in top line"	pointer
,	O
NULL_PARG	O
)	O
;	O
else	O
error	function
(	O
"Nothing in bottom line"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
do	O
{	O
if	O
(	O
(	O
c	int
=	O
ch_forw_get	function
(	O
)	O
)	O
==	O
'\n'	O
||	O
c	int
==	O
EOI	O
)	O
{	O
if	O
(	O
forwdir	int
)	O
error	function
(	O
"No bracket in top line"	pointer
,	O
NULL_PARG	O
)	O
;	O
else	O
error	function
(	O
"No bracket in bottom line"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
;	O
}	O
}	O
while	O
(	O
c	int
!=	O
obrac	int
||	O
--	O
n	int
>	O
0	int
)	O
;	O
if	O
(	O
!	O
forwdir	pointer
)	O
(	O
void	O
)	O
ch_back_get	function
(	O
)	O
;	O
chget	int
=	O
(	O
forwdir	pointer
)	O
?	O
ch_forw_get	int
:	O
ch_back_get	int
;	O
nest	int
=	O
0	int
;	O
while	O
(	O
(	O
c	int
=	O
(	O
*	O
chget	pointer
)	O
(	O
)	O
)	O
!=	O
EOI	O
)	O
{	O
if	O
(	O
c	int
==	O
obrac	int
)	O
nest	int
++	O
;	O
else	O
if	O
(	O
c	int
==	O
cbrac	int
&&	O
--	O
nest	int
<	O
0	int
)	O
{	O
jump_line_loc	function
(	O
ch_tell	function
(	O
)	O
,	O
forwdir	int
?	O
-	O
1	int
:	O
1	int
)	O
;	O
return	O
;	O
}	O
}	O
error	function
(	O
"No matching bracket"	pointer
,	O
NULL_PARG	O
)	O
;	O
}	O
extern	O
int	O
utf_mode	int
;	O
public	O
int	O
cvt_length	function
(	O
len	int
,	O
ops	pointer
)	O
int	O
len	int
;	O
int	O
ops	int
;	O
{	O
if	O
(	O
utf_mode	int
)	O
len	int
*=	O
4	int
;	O
return	O
(	O
len	int
+	O
1	int
)	O
;	O
}	O
public	O
int	O
*	O
cvt_alloc_chpos	function
(	O
len	int
)	O
int	O
len	int
;	O
{	O
int	O
i	int
;	O
int	O
*	O
chpos	pointer
=	O
(	O
int	O
*	O
)	O
ecalloc	function
(	O
sizeof	O
(	O
int	O
)	O
,	O
len	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
chpos	array
[	O
i	int
]	O
=	O
-	O
1	int
;	O
return	O
(	O
chpos	int
)	O
;	O
}	O
public	O
void	O
cvt_text	function
(	O
odst	pointer
,	O
osrc	pointer
,	O
chpos	pointer
,	O
lenp	pointer
,	O
ops	pointer
)	O
char	O
*	O
odst	pointer
;	O
char	O
*	O
osrc	pointer
;	O
int	O
*	O
chpos	pointer
;	O
int	O
*	O
lenp	pointer
;	O
int	O
ops	int
;	O
{	O
char	O
*	O
dst	pointer
;	O
char	O
*	O
edst	pointer
=	O
odst	pointer
;	O
char	O
*	O
src	pointer
;	O
char	O
*	O
src_end	pointer
;	O
LWCHAR	O
ch	int
;	O
if	O
(	O
lenp	pointer
!=	O
NULL	O
)	O
src_end	pointer
=	O
osrc	pointer
+	O
*	O
lenp	pointer
;	O
else	O
src_end	pointer
=	O
osrc	pointer
+	O
strlen	function
(	O
osrc	pointer
)	O
;	O
for	O
(	O
src	pointer
=	O
osrc	pointer
,	O
dst	pointer
=	O
odst	pointer
;	O
src	pointer
<	O
src_end	pointer
;	O
)	O
{	O
int	O
src_pos	int
=	O
(	O
int	O
)	O
(	O
src	pointer
-	O
osrc	pointer
)	O
;	O
int	O
dst_pos	int
=	O
(	O
int	O
)	O
(	O
dst	pointer
-	O
odst	pointer
)	O
;	O
ch	int
=	O
step_char	function
(	O
&	O
src	pointer
,	O
+	O
1	int
,	O
src_end	int
)	O
;	O
if	O
(	O
(	O
ops	int
&	O
CVT_BS	int
)	O
&&	O
ch	int
==	O
'\b'	O
&&	O
dst	pointer
>	O
odst	int
)	O
{	O
do	O
{	O
dst	pointer
--	O
;	O
}	O
while	O
(	O
dst	pointer
>	O
odst	int
&&	O
utf_mode	int
&&	O
!	O
IS_ASCII_OCTET	function
(	O
*	O
dst	pointer
)	O
&&	O
!	O
IS_UTF8_LEAD	function
(	O
*	O
dst	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
ops	pointer
&	O
CVT_ANSI	O
)	O
&&	O
IS_CSI_START	function
(	O
ch	int
)	O
)	O
{	O
src	pointer
++	O
;	O
while	O
(	O
src	pointer
<	O
src_end	int
)	O
if	O
(	O
!	O
is_ansi_middle	function
(	O
*	O
src	pointer
++	O
)	O
)	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
ops	pointer
&	O
CVT_TO_LC	O
)	O
&&	O
IS_UPPER	function
(	O
ch	int
)	O
)	O
ch	int
=	O
TO_LOWER	function
(	O
ch	int
)	O
;	O
put_wchar	function
(	O
&	O
dst	pointer
,	O
ch	int
)	O
;	O
if	O
(	O
chpos	pointer
!=	O
NULL	O
)	O
chpos	array
[	O
dst_pos	int
]	O
=	O
src_pos	int
;	O
}	O
if	O
(	O
dst	pointer
>	O
edst	int
)	O
edst	pointer
=	O
dst	pointer
;	O
}	O
if	O
(	O
(	O
ops	int
&	O
CVT_CRLF	int
)	O
&&	O
edst	int
>	O
odst	int
&&	O
edst	pointer
[	O
-	O
1	int
]	O
==	O
'\r'	O
)	O
edst	int
--	O
;	O
*	O
edst	pointer
=	O
'\0'	O
;	O
if	O
(	O
lenp	pointer
!=	O
NULL	O
)	O
*	O
lenp	pointer
=	O
(	O
int	O
)	O
(	O
edst	int
-	O
odst	pointer
)	O
;	O
}	O
extern	O
int	O
screen_trashed	int
;	O
extern	O
IFILE	O
curr_ifile	pointer
;	O
public	O
void	O
lsystem	function
(	O
cmd	int
,	O
donemsg	pointer
)	O
char	O
*	O
cmd	pointer
;	O
char	O
*	O
donemsg	pointer
;	O
{	O
int	O
inp	int
;	O
char	O
*	O
shell	pointer
;	O
char	O
*	O
p	pointer
;	O
IFILE	O
save_ifile	pointer
;	O
if	O
(	O
cmd	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
cmd	int
++	O
;	O
else	O
{	O
clear_bot	function
(	O
)	O
;	O
putstr	function
(	O
"!"	pointer
)	O
;	O
putstr	function
(	O
cmd	pointer
)	O
;	O
putstr	function
(	O
"\n"	pointer
)	O
;	O
}	O
save_ifile	pointer
=	O
save_curr_ifile	function
(	O
)	O
;	O
(	O
void	O
)	O
edit_ifile	function
(	O
NULL_IFILE	pointer
)	O
;	O
deinit	function
(	O
)	O
;	O
flush	function
(	O
)	O
;	O
raw_mode	function
(	O
0	int
)	O
;	O
init_signals	function
(	O
0	int
)	O
;	O
inp	pointer
=	O
dup	function
(	O
0	int
)	O
;	O
close	pointer
(	O
0	int
)	O
;	O
if	O
(	O
open	function
(	O
"/dev/tty"	pointer
,	O
OPEN_READ	O
)	O
<	O
0	int
)	O
dup	function
(	O
inp	pointer
)	O
;	O
p	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
shell	pointer
=	O
lgetenv	function
(	O
"SHELL"	pointer
)	O
)	O
!=	O
NULL	O
&&	O
*	O
shell	pointer
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
cmd	pointer
==	O
'\0'	O
)	O
p	pointer
=	O
save	O
(	O
shell	pointer
)	O
;	O
else	O
{	O
char	O
*	O
esccmd	pointer
=	O
shell_quote	function
(	O
cmd	pointer
)	O
;	O
if	O
(	O
esccmd	pointer
!=	O
NULL	O
)	O
{	O
int	O
len	int
=	O
(	O
int	O
)	O
(	O
strlen	function
(	O
shell	pointer
)	O
+	O
strlen	function
(	O
esccmd	pointer
)	O
+	O
5	int
)	O
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
ecalloc	function
(	O
len	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
SNPRINTF3	function
(	O
p	pointer
,	O
len	int
,	O
"%s %s %s"	pointer
,	O
shell	pointer
,	O
shell_coption	function
(	O
)	O
,	O
esccmd	pointer
)	O
;	O
free	function
(	O
esccmd	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
*	O
cmd	pointer
==	O
'\0'	O
)	O
p	pointer
=	O
save	function
(	O
"sh"	pointer
)	O
;	O
else	O
p	pointer
=	O
save	O
(	O
cmd	pointer
)	O
;	O
}	O
system	function
(	O
p	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
close	pointer
(	O
0	int
)	O
;	O
dup	function
(	O
inp	pointer
)	O
;	O
close	pointer
(	O
inp	pointer
)	O
;	O
init_signals	function
(	O
1	int
)	O
;	O
raw_mode	function
(	O
1	int
)	O
;	O
if	O
(	O
donemsg	pointer
!=	O
NULL	O
)	O
{	O
putstr	function
(	O
donemsg	pointer
)	O
;	O
putstr	function
(	O
"  (press RETURN)"	pointer
)	O
;	O
get_return	function
(	O
)	O
;	O
putchr	function
(	O
'\n'	O
)	O
;	O
flush	function
(	O
)	O
;	O
}	O
init	function
(	O
)	O
;	O
screen_trashed	int
=	O
1	int
;	O
reedit_ifile	function
(	O
save_ifile	pointer
)	O
;	O
winch	function
(	O
0	int
)	O
;	O
}	O
public	O
int	O
pipe_mark	function
(	O
c	int
,	O
cmd	int
)	O
int	O
c	int
;	O
char	O
*	O
cmd	pointer
;	O
{	O
POSITION	long
mpos	long
,	O
tpos	long
,	O
bpos	long
;	O
mpos	int
=	O
markpos	function
(	O
c	int
)	O
;	O
if	O
(	O
mpos	pointer
==	O
NULL_POSITION	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
tpos	long
=	O
position	function
(	O
TOP	O
)	O
;	O
if	O
(	O
tpos	long
==	O
NULL_POSITION	O
)	O
tpos	long
=	O
ch_zero	O
(	O
)	O
;	O
bpos	long
=	O
position	function
(	O
BOTTOM	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'.'	O
)	O
return	O
(	O
pipe_data	function
(	O
cmd	int
,	O
tpos	long
,	O
bpos	long
)	O
)	O
;	O
else	O
if	O
(	O
mpos	long
<=	O
tpos	long
)	O
return	O
(	O
pipe_data	function
(	O
cmd	int
,	O
mpos	pointer
,	O
bpos	long
)	O
)	O
;	O
else	O
if	O
(	O
bpos	long
==	O
NULL_POSITION	O
)	O
return	O
(	O
pipe_data	function
(	O
cmd	int
,	O
tpos	long
,	O
bpos	long
)	O
)	O
;	O
else	O
return	O
(	O
pipe_data	function
(	O
cmd	int
,	O
tpos	long
,	O
mpos	pointer
)	O
)	O
;	O
}	O
public	O
int	O
pipe_data	function
(	O
cmd	int
,	O
spos	pointer
,	O
epos	pointer
)	O
char	O
*	O
cmd	pointer
;	O
POSITION	long
spos	long
;	O
POSITION	long
epos	long
;	O
{	O
FILE	struct
*	O
f	pointer
;	O
int	O
c	int
;	O
extern	O
FILE	struct
*	O
popen	function
(	O
)	O
;	O
if	O
(	O
ch_seek	function
(	O
spos	pointer
)	O
!=	O
0	int
)	O
{	O
error	function
(	O
"Cannot seek to start position"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
f	pointer
=	O
popen	function
(	O
cmd	pointer
,	O
"w"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
error	function
(	O
"Cannot create pipe"	pointer
,	O
NULL_PARG	O
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
clear_bot	function
(	O
)	O
;	O
putstr	function
(	O
"!"	pointer
)	O
;	O
putstr	function
(	O
cmd	pointer
)	O
;	O
putstr	function
(	O
"\n"	pointer
)	O
;	O
deinit	function
(	O
)	O
;	O
flush	function
(	O
)	O
;	O
raw_mode	function
(	O
0	int
)	O
;	O
init_signals	function
(	O
0	int
)	O
;	O
LSIGNAL	O
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
c	int
=	O
EOI	O
;	O
while	O
(	O
epos	O
==	O
NULL_POSITION	O
||	O
spos	int
++	O
<=	O
epos	int
)	O
{	O
c	int
=	O
ch_forw_get	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
EOI	O
)	O
break	O
;	O
if	O
(	O
putc	function
(	O
c	int
,	O
f	pointer
)	O
==	O
EOF	O
)	O
break	O
;	O
}	O
while	O
(	O
c	int
!=	O
'\n'	O
&&	O
c	int
!=	O
EOI	O
)	O
{	O
c	int
=	O
ch_forw_get	function
(	O
)	O
;	O
if	O
(	O
c	int
==	O
EOI	O
)	O
break	O
;	O
if	O
(	O
putc	function
(	O
c	int
,	O
f	pointer
)	O
==	O
EOF	O
)	O
break	O
;	O
}	O
pclose	function
(	O
f	pointer
)	O
;	O
LSIGNAL	O
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
init_signals	function
(	O
1	int
)	O
;	O
raw_mode	function
(	O
1	int
)	O
;	O
init	function
(	O
)	O
;	O
screen_trashed	int
=	O
1	int
;	O
winch	function
(	O
0	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
public	O
int	O
errmsgs	int
;	O
public	O
int	O
need_clr	int
;	O
public	O
int	O
final_attr	int
;	O
public	O
int	O
at_prompt	int
;	O
extern	O
int	O
sigs	int
;	O
extern	O
int	O
sc_width	int
;	O
extern	O
int	O
so_s_width	int
,	O
so_e_width	int
;	O
extern	O
int	O
screen_trashed	int
;	O
extern	O
int	O
any_display	int
;	O
extern	O
int	O
is_tty	int
;	O
extern	O
int	O
oldbot	int
;	O
public	O
void	O
put_line	function
(	O
)	O
{	O
int	O
c	int
;	O
int	O
i	int
;	O
int	O
a	int
;	O
if	O
(	O
ABORT_SIGS	function
(	O
)	O
)	O
{	O
screen_trashed	int
=	O
1	int
;	O
return	O
;	O
}	O
final_attr	int
=	O
AT_NORMAL	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
c	int
=	O
gline	function
(	O
i	int
,	O
&	O
a	int
)	O
)	O
!=	O
'\0'	O
;	O
i	int
++	O
)	O
{	O
at_switch	function
(	O
a	int
)	O
;	O
final_attr	int
=	O
a	int
;	O
if	O
(	O
c	int
==	O
'\b'	O
)	O
putbs	function
(	O
)	O
;	O
else	O
putchr	function
(	O
c	int
)	O
;	O
}	O
at_exit	function
(	O
)	O
;	O
}	O
static	O
char	O
obuf	array
[	O
OUTBUF_SIZE	int
]	O
;	O
static	O
char	O
*	O
ob	pointer
=	O
obuf	int
;	O
public	O
void	O
flush	function
(	O
)	O
{	O
int	O
n	int
;	O
int	O
fd	int
;	O
n	int
=	O
(	O
int	O
)	O
(	O
ob	pointer
-	O
obuf	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
fd	int
=	O
(	O
any_display	int
)	O
?	O
1	int
:	O
2	int
;	O
if	O
(	O
write	function
(	O
fd	int
,	O
obuf	pointer
,	O
n	int
)	O
!=	O
n	int
)	O
screen_trashed	int
=	O
1	int
;	O
ob	pointer
=	O
obuf	int
;	O
}	O
public	O
int	O
putchr	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
need_clr	int
)	O
{	O
need_clr	int
=	O
0	int
;	O
clear_bot	function
(	O
)	O
;	O
}	O
if	O
(	O
ob	pointer
>=	O
&	O
obuf	array
[	O
sizeof	O
(	O
obuf	int
)	O
-	O
1	int
]	O
)	O
flush	function
(	O
)	O
;	O
*	O
ob	pointer
++	O
=	O
c	int
;	O
at_prompt	int
=	O
0	int
;	O
return	O
(	O
c	int
)	O
;	O
}	O
public	O
void	O
putstr	function
(	O
s	pointer
)	O
constant	function
char	O
*	O
s	pointer
;	O
{	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
)	O
putchr	function
(	O
*	O
s	pointer
++	O
)	O
;	O
}	O
TYPE_TO_A_FUNC	function
(	O
postoa	pointer
,	O
POSITION	int
)	O
TYPE_TO_A_FUNC	function
(	O
linenumtoa	pointer
,	O
LINENUM	int
)	O
TYPE_TO_A_FUNC	function
(	O
inttoa	pointer
,	O
int	O
)	O
static	O
int	O
iprint_int	function
(	O
num	pointer
)	O
int	O
num	int
;	O
{	O
char	O
buf	pointer
[	O
INT_STRLEN_BOUND	O
(	O
num	int
)	O
]	O
;	O
inttoa	function
(	O
num	pointer
,	O
buf	array
)	O
;	O
putstr	function
(	O
buf	pointer
)	O
;	O
return	O
(	O
(	O
int	O
)	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
static	O
int	O
iprint_linenum	function
(	O
num	int
)	O
LINENUM	int
num	int
;	O
{	O
char	O
buf	array
[	O
INT_STRLEN_BOUND	O
(	O
num	int
)	O
]	O
;	O
linenumtoa	function
(	O
num	pointer
,	O
buf	array
)	O
;	O
putstr	function
(	O
buf	array
)	O
;	O
return	O
(	O
(	O
int	O
)	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
static	O
int	O
less_printf	function
(	O
fmt	pointer
,	O
parg	double
)	O
char	O
*	O
fmt	pointer
;	O
PARG	struct
*	O
parg	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
int	O
col	int
;	O
col	int
=	O
0	int
;	O
while	O
(	O
*	O
fmt	pointer
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
fmt	pointer
!=	O
'%'	O
)	O
{	O
putchr	function
(	O
*	O
fmt	pointer
++	O
)	O
;	O
col	int
++	O
;	O
}	O
else	O
{	O
++	O
fmt	pointer
;	O
switch	O
(	O
*	O
fmt	pointer
++	O
)	O
{	O
case	O
's'	O
:	O
s	pointer
=	O
parg	pointer
->	O
p_string	int
;	O
parg	pointer
++	O
;	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
)	O
{	O
putchr	function
(	O
*	O
s	pointer
++	O
)	O
;	O
col	int
++	O
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
col	int
+=	O
iprint_int	function
(	O
parg	pointer
->	O
p_int	pointer
)	O
;	O
parg	pointer
++	O
;	O
break	O
;	O
case	O
'n'	O
:	O
col	int
+=	O
iprint_linenum	function
(	O
parg	pointer
->	O
p_linenum	long
)	O
;	O
parg	pointer
++	O
;	O
break	O
;	O
case	O
'%'	O
:	O
putchr	function
(	O
'%'	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
return	O
(	O
col	int
)	O
;	O
}	O
public	O
void	O
get_return	function
(	O
)	O
{	O
int	O
c	int
;	O
c	int
=	O
getchr	function
(	O
)	O
;	O
if	O
(	O
c	int
!=	O
'\n'	O
&&	O
c	int
!=	O
'\r'	O
&&	O
c	int
!=	O
' '	O
&&	O
c	int
!=	O
READ_INTR	O
)	O
ungetcc	function
(	O
c	int
)	O
;	O
}	O
public	O
void	O
error	function
(	O
fmt	pointer
,	O
parg	int
)	O
char	O
*	O
fmt	pointer
;	O
PARG	struct
*	O
parg	pointer
;	O
{	O
int	O
col	int
=	O
0	int
;	O
static	O
char	O
return_to_continue	array
[	O
]	O
=	O
"  (press RETURN)"	pointer
;	O
errmsgs	int
++	O
;	O
if	O
(	O
any_display	int
&&	O
is_tty	int
)	O
{	O
if	O
(	O
!	O
oldbot	pointer
)	O
squish_check	function
(	O
)	O
;	O
at_exit	function
(	O
)	O
;	O
clear_bot	function
(	O
)	O
;	O
at_enter	function
(	O
AT_STANDOUT	pointer
)	O
;	O
col	int
+=	O
so_s_width	int
;	O
}	O
col	int
+=	O
less_printf	function
(	O
fmt	pointer
,	O
parg	pointer
)	O
;	O
if	O
(	O
!	O
(	O
any_display	int
&&	O
is_tty	int
)	O
)	O
{	O
putchr	function
(	O
'\n'	O
)	O
;	O
return	O
;	O
}	O
putstr	function
(	O
return_to_continue	pointer
)	O
;	O
at_exit	function
(	O
)	O
;	O
col	int
+=	O
sizeof	O
(	O
return_to_continue	struct
)	O
+	O
so_e_width	int
;	O
get_return	function
(	O
)	O
;	O
lower_left	function
(	O
)	O
;	O
clear_eol	function
(	O
)	O
;	O
if	O
(	O
col	int
>=	O
sc_width	int
)	O
screen_trashed	int
=	O
1	int
;	O
flush	function
(	O
)	O
;	O
}	O
static	O
char	O
intr_to_abort	array
[	O
]	O
=	O
"... (interrupt to abort)"	pointer
;	O
public	O
void	O
ierror	function
(	O
fmt	pointer
,	O
parg	pointer
)	O
char	O
*	O
fmt	pointer
;	O
PARG	struct
*	O
parg	pointer
;	O
{	O
at_exit	function
(	O
)	O
;	O
clear_bot	function
(	O
)	O
;	O
at_enter	function
(	O
AT_STANDOUT	pointer
)	O
;	O
(	O
void	O
)	O
less_printf	function
(	O
fmt	pointer
,	O
parg	pointer
)	O
;	O
putstr	function
(	O
intr_to_abort	pointer
)	O
;	O
at_exit	function
(	O
)	O
;	O
flush	function
(	O
)	O
;	O
need_clr	int
=	O
1	int
;	O
}	O
public	O
int	O
query	function
(	O
fmt	pointer
,	O
parg	pointer
)	O
char	O
*	O
fmt	pointer
;	O
PARG	struct
*	O
parg	pointer
;	O
{	O
int	O
c	int
;	O
int	O
col	int
=	O
0	int
;	O
if	O
(	O
any_display	int
&&	O
is_tty	int
)	O
clear_bot	function
(	O
)	O
;	O
(	O
void	O
)	O
less_printf	function
(	O
fmt	pointer
,	O
parg	pointer
)	O
;	O
c	int
=	O
getchr	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
any_display	int
&&	O
is_tty	int
)	O
)	O
{	O
putchr	function
(	O
'\n'	O
)	O
;	O
return	O
(	O
c	int
)	O
;	O
}	O
lower_left	function
(	O
)	O
;	O
if	O
(	O
col	int
>=	O
sc_width	int
)	O
screen_trashed	int
=	O
1	int
;	O
flush	function
(	O
)	O
;	O
return	O
(	O
c	int
)	O
;	O
}	O
const	O
char	O
*	O
program_name	pointer
=	O
NULL	O
;	O
void	O
set_program_name	function
(	O
const	O
char	O
*	O
argv0	pointer
)	O
{	O
const	O
char	O
*	O
slash	pointer
;	O
const	O
char	O
*	O
base	pointer
;	O
if	O
(	O
argv0	pointer
==	O
NULL	O
)	O
{	O
fputs	function
(	O
"A NULL argv[0] was passed through an exec system call.\n"	pointer
,	O
stderr	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
slash	pointer
=	O
strrchr	function
(	O
argv0	pointer
,	O
'/'	O
)	O
;	O
base	pointer
=	O
(	O
slash	pointer
!=	O
NULL	O
?	O
slash	pointer
+	O
1	int
:	O
argv0	pointer
)	O
;	O
if	O
(	O
base	pointer
-	O
argv0	pointer
>=	O
7	int
&&	O
strncmp	function
(	O
base	pointer
-	O
7	int
,	O
"/.libs/"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
{	O
argv0	pointer
=	O
base	pointer
;	O
if	O
(	O
strncmp	function
(	O
base	pointer
,	O
"lt-"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
{	O
argv0	pointer
=	O
base	pointer
+	O
3	int
;	O
program_invocation_short_name	pointer
=	O
(	O
char	O
*	O
)	O
argv0	pointer
;	O
}	O
}	O
program_name	pointer
=	O
argv0	pointer
;	O
program_invocation_name	pointer
=	O
(	O
char	O
*	O
)	O
argv0	pointer
;	O
}	O
char	O
*	O
xreadlink	function
(	O
char	O
const	O
*	O
filename	pointer
)	O
{	O
char	O
*	O
result	pointer
=	O
areadlink	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
result	pointer
==	O
NULL	O
&&	O
errno	O
==	O
ENOMEM	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
result	pointer
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
rc	int
;	O
char	O
src	pointer
[	O
BUFSIZ	int
]	O
;	O
char	O
*	O
decoded	pointer
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
printf	function
(	O
"Enter (possibly non-ASCII) domain name to decode: "	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
!	O
fgets	function
(	O
src	pointer
,	O
sizeof	O
(	O
src	pointer
)	O
,	O
stdin	pointer
)	O
)	O
{	O
perror	function
(	O
"fgets"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
src	pointer
[	O
strlen	function
(	O
src	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
rc	int
=	O
idn2_to_unicode_lzlz	function
(	O
src	pointer
,	O
&	O
decoded	pointer
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
!=	O
IDN2_OK	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error: %s (%s, %d)\n"	pointer
,	O
idn2_strerror	function
(	O
rc	int
)	O
,	O
idn2_strerror_name	function
(	O
rc	int
)	O
,	O
rc	int
)	O
;	O
return	O
1	int
;	O
}	O
printf	function
(	O
"Decoded domain name: %s\n"	pointer
,	O
decoded	pointer
)	O
;	O
free	function
(	O
decoded	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
main	function
(	O
void	O
)	O
{	O
char	O
buf	array
[	O
BUFSIZ	int
]	O
;	O
char	O
*	O
p	pointer
;	O
int	O
rc	int
;	O
size_t	long
i	long
;	O
if	O
(	O
!	O
fgets	function
(	O
buf	array
,	O
BUFSIZ	int
,	O
stdin	pointer
)	O
)	O
perror	function
(	O
"fgets"	pointer
)	O
;	O
buf	array
[	O
strlen	function
(	O
buf	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
printf	function
(	O
"Read string (length %ld): "	pointer
,	O
(	O
long	O
int	O
)	O
strlen	function
(	O
buf	array
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
strlen	function
(	O
buf	array
)	O
;	O
i	long
++	O
)	O
printf	function
(	O
"%02x "	pointer
,	O
(	O
unsigned	O
)	O
buf	array
[	O
i	long
]	O
&	O
0xFF	int
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
rc	int
=	O
idn2_to_unicode_8z8z	function
(	O
buf	pointer
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
!=	O
IDNA_SUCCESS	int
)	O
{	O
printf	function
(	O
"ToUnicode() failed (%d): %s\n"	pointer
,	O
rc	int
,	O
idn2_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
printf	function
(	O
"ACE label (length %ld): '%s'\n"	pointer
,	O
(	O
long	O
int	O
)	O
strlen	function
(	O
p	pointer
)	O
,	O
p	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
return	O
0	int
;	O
}	O
char	O
const	O
*	O
getprogname	function
(	O
void	O
)	O
{	O
return	O
program_invocation_short_name	pointer
;	O
}	O
const	O
char	O
version_etc_copyright	array
[	O
]	O
=	O
"Copyright (C) 2011-2016  Simon Josefsson"	pointer
;	O
const	O
char	O
*	O
idn2_check_version	function
(	O
const	O
char	O
*	O
req_version	pointer
)	O
{	O
if	O
(	O
!	O
req_version	pointer
||	O
strverscmp	function
(	O
req_version	pointer
,	O
IDN2_VERSION	pointer
)	O
<=	O
0	int
)	O
return	O
IDN2_VERSION	pointer
;	O
return	O
NULL	O
;	O
}	O
int	O
c_strcasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
int	O
c_strncasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
,	O
size_t	long
n	long
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
||	O
n	long
==	O
0	int
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
--	O
n	long
==	O
0	int
||	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
static	O
int	O
answer_to_connection	function
(	O
void	O
*	O
cls	pointer
,	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
const	O
char	O
*	O
url	pointer
,	O
const	O
char	O
*	O
method	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
const	O
char	O
*	O
upload_data	pointer
,	O
size_t	long
*	O
upload_data_size	pointer
,	O
void	O
*	O
*	O
con_cls	pointer
)	O
{	O
char	O
*	O
user	pointer
;	O
char	O
*	O
pass	pointer
;	O
int	O
fail	int
;	O
int	O
ret	int
;	O
struct	O
MHD_Response	O
*	O
response	pointer
;	O
(	O
void	O
)	O
cls	pointer
;	O
(	O
void	O
)	O
url	pointer
;	O
(	O
void	O
)	O
version	pointer
;	O
(	O
void	O
)	O
upload_data	pointer
;	O
(	O
void	O
)	O
upload_data_size	pointer
;	O
if	O
(	O
0	int
!=	O
strcmp	function
(	O
method	pointer
,	O
"GET"	pointer
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
NULL	O
==	O
*	O
con_cls	pointer
)	O
{	O
*	O
con_cls	pointer
=	O
connection	pointer
;	O
return	O
MHD_YES	int
;	O
}	O
pass	pointer
=	O
NULL	O
;	O
user	pointer
=	O
MHD_basic_auth_get_username_password	function
(	O
connection	pointer
,	O
&	O
pass	pointer
)	O
;	O
fail	int
=	O
(	O
(	O
NULL	O
==	O
user	pointer
)	O
||	O
(	O
0	int
!=	O
strcmp	function
(	O
user	pointer
,	O
"root"	pointer
)	O
)	O
||	O
(	O
0	int
!=	O
strcmp	function
(	O
pass	pointer
,	O
"pa$$w0rd"	pointer
)	O
)	O
)	O
;	O
if	O
(	O
NULL	O
!=	O
user	pointer
)	O
MHD_free	function
(	O
user	pointer
)	O
;	O
if	O
(	O
NULL	O
!=	O
pass	pointer
)	O
MHD_free	function
(	O
pass	pointer
)	O
;	O
if	O
(	O
fail	int
)	O
{	O
const	O
char	O
*	O
page	pointer
=	O
"<html><body>Go away.</body></html>"	pointer
;	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
strlen	function
(	O
page	pointer
)	O
,	O
(	O
void	O
*	O
)	O
page	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_basic_auth_fail_response	function
(	O
connection	pointer
,	O
"my realm"	pointer
,	O
response	pointer
)	O
;	O
}	O
else	O
{	O
const	O
char	O
*	O
page	pointer
=	O
"<html><body>A secret.</body></html>"	pointer
;	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
strlen	function
(	O
page	pointer
)	O
,	O
(	O
void	O
*	O
)	O
page	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_OK	int
,	O
response	pointer
)	O
;	O
}	O
MHD_destroy_response	function
(	O
response	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
main	function
(	O
void	O
)	O
{	O
struct	O
MHD_Daemon	O
*	O
daemon	function
;	O
daemon	function
=	O
MHD_start_daemon	function
(	O
MHD_USE_INTERNAL_POLLING_THREAD	int
,	O
PORT	int
,	O
NULL	O
,	O
NULL	O
,	O
&	O
answer_to_connection	function
,	O
NULL	O
,	O
MHD_OPTION_END	int
)	O
;	O
if	O
(	O
NULL	O
==	O
daemon	function
)	O
return	O
1	int
;	O
(	O
void	O
)	O
getchar	function
(	O
)	O
;	O
MHD_stop_daemon	function
(	O
daemon	function
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
connection_info_struct	struct
{	O
int	O
connectiontype	int
;	O
char	O
*	O
answerstring	pointer
;	O
struct	O
MHD_PostProcessor	struct
*	O
postprocessor	pointer
;	O
}	O
;	O
const	O
char	O
*	O
askpage	pointer
=	O
"<html><body>                       What's your name, Sir?<br>                       <form action=\"/namepost\" method=\"post\">                       <input name=\"name\" type=\"text\">                       <input type=\"submit\" value=\" Send \"></form>                       </body></html>"	pointer
;	O
const	O
char	O
*	O
greetingpage	pointer
=	O
"<html><body><h1>Welcome, %s!</center></h1></body></html>"	pointer
;	O
const	O
char	O
*	O
errorpage	pointer
=	O
"<html><body>This doesn't seem to be right.</body></html>"	pointer
;	O
static	O
int	O
send_page	function
(	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
const	O
char	O
*	O
page	pointer
)	O
{	O
int	O
ret	int
;	O
struct	O
MHD_Response	O
*	O
response	pointer
;	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
strlen	function
(	O
page	pointer
)	O
,	O
(	O
void	O
*	O
)	O
page	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
if	O
(	O
!	O
response	pointer
)	O
return	O
MHD_NO	int
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_OK	int
,	O
response	pointer
)	O
;	O
MHD_destroy_response	function
(	O
response	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
iterate_post	function
(	O
void	O
*	O
coninfo_cls	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
content_type	pointer
,	O
const	O
char	O
*	O
transfer_encoding	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
uint64_t	long
off	long
,	O
size_t	long
size	long
)	O
{	O
struct	O
connection_info_struct	struct
*	O
con_info	pointer
=	O
coninfo_cls	pointer
;	O
(	O
void	O
)	O
kind	enum
;	O
(	O
void	O
)	O
filename	pointer
;	O
(	O
void	O
)	O
content_type	pointer
;	O
(	O
void	O
)	O
transfer_encoding	pointer
;	O
(	O
void	O
)	O
off	long
;	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
key	pointer
,	O
"name"	pointer
)	O
)	O
{	O
if	O
(	O
(	O
size	long
>	O
0	int
)	O
&&	O
(	O
size	pointer
<=	O
MAXNAMESIZE	pointer
)	O
)	O
{	O
char	O
*	O
answerstring	pointer
;	O
answerstring	pointer
=	O
malloc	function
(	O
MAXANSWERSIZE	pointer
)	O
;	O
if	O
(	O
!	O
answerstring	pointer
)	O
return	O
MHD_NO	int
;	O
snprintf	function
(	O
answerstring	pointer
,	O
MAXANSWERSIZE	pointer
,	O
greetingpage	pointer
,	O
data	pointer
)	O
;	O
con_info	pointer
->	O
answerstring	pointer
=	O
answerstring	pointer
;	O
}	O
else	O
con_info	pointer
->	O
answerstring	pointer
=	O
NULL	O
;	O
return	O
MHD_NO	int
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
request_completed	function
(	O
void	O
*	O
cls	pointer
,	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
void	O
*	O
*	O
con_cls	pointer
,	O
enum	O
MHD_RequestTerminationCode	enum
toe	enum
)	O
{	O
struct	O
connection_info_struct	struct
*	O
con_info	pointer
=	O
*	O
con_cls	pointer
;	O
(	O
void	O
)	O
cls	pointer
;	O
(	O
void	O
)	O
connection	pointer
;	O
(	O
void	O
)	O
toe	enum
;	O
if	O
(	O
NULL	O
==	O
con_info	pointer
)	O
return	O
;	O
if	O
(	O
con_info	pointer
->	O
connectiontype	int
==	O
POST	int
)	O
{	O
MHD_destroy_post_processor	function
(	O
con_info	pointer
->	O
postprocessor	pointer
)	O
;	O
if	O
(	O
con_info	pointer
->	O
answerstring	pointer
)	O
free	function
(	O
con_info	pointer
->	O
answerstring	pointer
)	O
;	O
}	O
free	function
(	O
con_info	pointer
)	O
;	O
*	O
con_cls	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
answer_to_connection	function
(	O
void	O
*	O
cls	pointer
,	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
const	O
char	O
*	O
url	pointer
,	O
const	O
char	O
*	O
method	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
const	O
char	O
*	O
upload_data	pointer
,	O
size_t	long
*	O
upload_data_size	pointer
,	O
void	O
*	O
*	O
con_cls	pointer
)	O
{	O
(	O
void	O
)	O
cls	pointer
;	O
(	O
void	O
)	O
url	pointer
;	O
(	O
void	O
)	O
version	pointer
;	O
if	O
(	O
NULL	O
==	O
*	O
con_cls	pointer
)	O
{	O
struct	O
connection_info_struct	struct
*	O
con_info	pointer
;	O
con_info	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
connection_info_struct	struct
)	O
)	O
;	O
if	O
(	O
NULL	O
==	O
con_info	pointer
)	O
return	O
MHD_NO	int
;	O
con_info	pointer
->	O
answerstring	pointer
=	O
NULL	O
;	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
method	pointer
,	O
"POST"	pointer
)	O
)	O
{	O
con_info	pointer
->	O
postprocessor	pointer
=	O
MHD_create_post_processor	function
(	O
connection	pointer
,	O
POSTBUFFERSIZE	pointer
,	O
iterate_post	pointer
,	O
(	O
void	O
*	O
)	O
con_info	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
con_info	pointer
->	O
postprocessor	pointer
)	O
{	O
free	function
(	O
con_info	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
con_info	pointer
->	O
connectiontype	int
=	O
POST	int
;	O
}	O
else	O
con_info	pointer
->	O
connectiontype	pointer
=	O
GET	pointer
;	O
*	O
con_cls	pointer
=	O
(	O
void	O
*	O
)	O
con_info	pointer
;	O
return	O
MHD_YES	int
;	O
}	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
method	pointer
,	O
"GET"	pointer
)	O
)	O
{	O
return	O
send_page	function
(	O
connection	pointer
,	O
askpage	pointer
)	O
;	O
}	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
method	pointer
,	O
"POST"	pointer
)	O
)	O
{	O
struct	O
connection_info_struct	struct
*	O
con_info	pointer
=	O
*	O
con_cls	pointer
;	O
if	O
(	O
*	O
upload_data_size	pointer
!=	O
0	int
)	O
{	O
MHD_post_process	function
(	O
con_info	pointer
->	O
postprocessor	pointer
,	O
upload_data	pointer
,	O
*	O
upload_data_size	pointer
)	O
;	O
*	O
upload_data_size	pointer
=	O
0	int
;	O
return	O
MHD_YES	int
;	O
}	O
else	O
if	O
(	O
NULL	O
!=	O
con_info	pointer
->	O
answerstring	pointer
)	O
return	O
send_page	function
(	O
connection	pointer
,	O
con_info	pointer
->	O
answerstring	pointer
)	O
;	O
}	O
return	O
send_page	function
(	O
connection	pointer
,	O
errorpage	pointer
)	O
;	O
}	O
int	O
main	function
(	O
)	O
{	O
struct	O
MHD_Daemon	O
*	O
daemon	function
;	O
daemon	function
=	O
MHD_start_daemon	function
(	O
MHD_USE_AUTO	int
|	O
MHD_USE_INTERNAL_POLLING_THREAD	int
,	O
PORT	int
,	O
NULL	O
,	O
NULL	O
,	O
&	O
answer_to_connection	function
,	O
NULL	O
,	O
MHD_OPTION_NOTIFY_COMPLETED	int
,	O
request_completed	int
,	O
NULL	O
,	O
MHD_OPTION_END	int
)	O
;	O
if	O
(	O
NULL	O
==	O
daemon	function
)	O
return	O
1	int
;	O
(	O
void	O
)	O
getchar	function
(	O
)	O
;	O
MHD_stop_daemon	function
(	O
daemon	function
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ahc_echo	function
(	O
void	O
*	O
cls	pointer
,	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
const	O
char	O
*	O
url	pointer
,	O
const	O
char	O
*	O
method	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
const	O
char	O
*	O
upload_data	pointer
,	O
size_t	long
*	O
upload_data_size	pointer
,	O
void	O
*	O
*	O
ptr	pointer
)	O
{	O
static	O
int	O
aptr	int
;	O
struct	O
MHD_Response	O
*	O
response	pointer
;	O
int	O
ret	int
;	O
int	O
fd	int
;	O
struct	O
stat	struct
buf	pointer
;	O
(	O
void	O
)	O
cls	pointer
;	O
(	O
void	O
)	O
version	pointer
;	O
(	O
void	O
)	O
upload_data	pointer
;	O
(	O
void	O
)	O
upload_data_size	pointer
;	O
if	O
(	O
(	O
0	int
!=	O
strcmp	function
(	O
method	pointer
,	O
MHD_HTTP_METHOD_GET	pointer
)	O
)	O
&&	O
(	O
0	int
!=	O
strcmp	function
(	O
method	pointer
,	O
MHD_HTTP_METHOD_HEAD	pointer
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
&	O
aptr	int
!=	O
*	O
ptr	pointer
)	O
{	O
*	O
ptr	pointer
=	O
&	O
aptr	int
;	O
return	O
MHD_YES	int
;	O
}	O
*	O
ptr	pointer
=	O
NULL	O
;	O
if	O
(	O
NULL	O
!=	O
strstr	function
(	O
url	pointer
,	O
"../"	pointer
)	O
)	O
fd	int
=	O
-	O
1	int
;	O
else	O
fd	int
=	O
open	function
(	O
url	pointer
+	O
1	int
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
-	O
1	int
!=	O
fd	int
)	O
{	O
if	O
(	O
(	O
0	int
!=	O
fstat	function
(	O
fd	int
,	O
&	O
buf	pointer
)	O
)	O
||	O
(	O
!	O
S_ISREG	O
(	O
buf	pointer
.	O
st_mode	int
)	O
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
close	function
(	O
fd	int
)	O
)	O
abort	function
(	O
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
-	O
1	int
==	O
fd	int
)	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
strlen	function
(	O
PAGE	pointer
)	O
,	O
(	O
void	O
*	O
)	O
PAGE	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_NOT_FOUND	int
,	O
response	pointer
)	O
;	O
MHD_destroy_response	function
(	O
response	pointer
)	O
;	O
}	O
else	O
{	O
response	pointer
=	O
MHD_create_response_from_fd64	function
(	O
buf	pointer
.	O
st_size	long
,	O
fd	int
)	O
;	O
if	O
(	O
NULL	O
==	O
response	pointer
)	O
{	O
if	O
(	O
0	int
!=	O
close	function
(	O
fd	int
)	O
)	O
abort	function
(	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_OK	int
,	O
response	pointer
)	O
;	O
MHD_destroy_response	function
(	O
response	pointer
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
const	O
*	O
argv	pointer
)	O
{	O
struct	O
MHD_Daemon	O
*	O
d	pointer
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
printf	function
(	O
"%s PORT\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
d	pointer
=	O
MHD_start_daemon	function
(	O
MHD_USE_THREAD_PER_CONNECTION	int
|	O
MHD_USE_INTERNAL_POLLING_THREAD	int
|	O
MHD_USE_ERROR_LOG	int
,	O
atoi	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
ahc_echo	function
,	O
PAGE	pointer
,	O
MHD_OPTION_END	int
)	O
;	O
if	O
(	O
d	pointer
==	O
NULL	O
)	O
return	O
1	int
;	O
(	O
void	O
)	O
getc	function
(	O
stdin	pointer
)	O
;	O
MHD_stop_daemon	function
(	O
d	pointer
)	O
;	O
return	O
0	int
;	O
}	O
enum	O
MHD_Bool	enum
MHD_connection_get_information_sz	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
enum	O
MHD_ConnectionInformationType	enum
info_type	enum
,	O
union	O
MHD_ConnectionInformation	union
*	O
return_value	pointer
,	O
size_t	long
return_value_size	long
)	O
{	O
switch	O
(	O
info_type	enum
)	O
{	O
case	O
MHD_CONNECTION_INFORMATION_CLIENT_ADDRESS	int
:	O
CHECK_SIZE	O
(	O
struct	O
sockaddr	struct
*	O
)	O
;	O
return_value	pointer
->	O
client_addr	pointer
=	O
(	O
const	O
struct	O
sockaddr	struct
*	O
)	O
&	O
connection	pointer
->	O
addr	double
;	O
return	O
MHD_YES	int
;	O
case	O
MHD_CONNECTION_INFORMATION_DAEMON	int
:	O
CHECK_SIZE	O
(	O
struct	O
MHD_Daemon	O
*	O
)	O
;	O
return_value	pointer
->	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
return	O
MHD_YES	int
;	O
case	O
MHD_CONNECTION_INFORMATION_CONNECTION_FD	int
:	O
CHECK_SIZE	O
(	O
MHD_socket	int
)	O
;	O
return_value	pointer
->	O
connect_fd	int
=	O
connection	pointer
->	O
socket_fd	int
;	O
return	O
MHD_YES	int
;	O
case	O
MHD_CONNECTION_INFORMATION_SOCKET_CONTEXT	int
:	O
CHECK_SIZE	O
(	O
void	O
*	O
*	O
)	O
;	O
return_value	pointer
->	O
socket_context	int
=	O
&	O
connection	pointer
->	O
socket_context	int
;	O
return	O
MHD_YES	int
;	O
case	O
MHD_CONNECTION_INFORMATION_CONNECTION_SUSPENDED	int
:	O
CHECK_SIZE	O
(	O
enum	O
MHD_Bool	enum
)	O
;	O
return_value	pointer
->	O
suspended	enum
=	O
connection	pointer
->	O
suspended	enum
?	O
MHD_YES	int
:	O
MHD_NO	int
;	O
return	O
MHD_YES	int
;	O
case	O
MHD_CONNECTION_INFORMATION_CONNECTION_TIMEOUT	int
:	O
CHECK_SIZE	O
(	O
unsigned	O
int	O
)	O
;	O
return_value	pointer
->	O
connection_timeout	int
=	O
(	O
unsigned	O
int	O
)	O
connection	pointer
->	O
connection_timeout	int
;	O
return	O
MHD_YES	int
;	O
default	O
:	O
return	O
MHD_NO	int
;	O
}	O
}	O
static	O
void	O
stop_workers	function
(	O
struct	O
MHD_Daemon	O
*	O
daemon	function
)	O
{	O
MHD_socket	int
fd	int
;	O
unsigned	O
int	O
i	int
;	O
mhd_assert	O
(	O
1	int
<	O
daemon	function
->	O
worker_pool_size	pointer
)	O
;	O
mhd_assert	O
(	O
1	int
<	O
daemon	function
->	O
threading_mode	enum
)	O
;	O
if	O
(	O
daemon	function
->	O
was_quiesced	int
)	O
fd	int
=	O
MHD_INVALID_SOCKET	O
;	O
else	O
fd	int
=	O
daemon	function
->	O
listen_socket	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	int
<	O
daemon	function
->	O
worker_pool_size	int
;	O
i	long
++	O
)	O
{	O
daemon	function
->	O
worker_pool	pointer
[	O
i	long
]	O
.	O
shutdown	int
=	O
true	int
;	O
if	O
(	O
MHD_ITC_IS_VALID_	function
(	O
daemon	function
->	O
worker_pool	pointer
[	O
i	long
]	O
.	O
itc	int
)	O
)	O
{	O
if	O
(	O
!	O
MHD_itc_activate_	function
(	O
daemon	function
->	O
worker_pool	pointer
[	O
i	long
]	O
.	O
itc	int
,	O
"e"	int
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to signal shutdown via inter-thread communication channel."	pointer
)	O
)	O
;	O
}	O
else	O
{	O
mhd_assert	O
(	O
MHD_INVALID_SOCKET	O
!=	O
fd	int
)	O
;	O
}	O
}	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
fd	int
)	O
{	O
(	O
void	O
)	O
shutdown	function
(	O
fd	int
,	O
SHUT_RDWR	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
daemon	function
->	O
worker_pool_size	int
;	O
++	O
i	long
)	O
{	O
MHD_daemon_destroy	function
(	O
&	O
daemon	function
->	O
worker_pool	pointer
[	O
i	long
]	O
)	O
;	O
}	O
free	function
(	O
daemon	function
->	O
worker_pool	pointer
)	O
;	O
daemon	function
->	O
worker_pool	pointer
=	O
NULL	O
;	O
mhd_assert	O
(	O
MHD_ITC_IS_INVALID_	function
(	O
daemon	function
->	O
itc	pointer
)	O
)	O
;	O
mhd_assert	O
(	O
-	O
1	int
==	O
daemon	function
->	O
epoll_fd	int
)	O
;	O
}	O
void	O
MHD_daemon_destroy	function
(	O
struct	O
MHD_Daemon	O
*	O
daemon	function
)	O
{	O
MHD_socket	int
fd	int
;	O
daemon	function
->	O
shutdown	function
=	O
true	int
;	O
if	O
(	O
daemon	function
->	O
was_quiesced	int
)	O
fd	int
=	O
MHD_INVALID_SOCKET	O
;	O
else	O
fd	int
=	O
daemon	function
->	O
listen_socket	int
;	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
worker_pool	pointer
)	O
{	O
stop_workers	function
(	O
daemon	function
)	O
;	O
}	O
else	O
{	O
mhd_assert	O
(	O
0	int
==	O
daemon	function
->	O
worker_pool_size	pointer
)	O
;	O
if	O
(	O
MHD_TM_EXTERNAL_EVENT_LOOP	int
!=	O
daemon	function
->	O
threading_mode	enum
)	O
{	O
if	O
(	O
MHD_ITC_IS_VALID_	function
(	O
daemon	function
->	O
itc	pointer
)	O
)	O
{	O
if	O
(	O
!	O
MHD_itc_activate_	function
(	O
daemon	function
->	O
itc	pointer
,	O
"e"	int
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to signal shutdown via inter-thread communication channel"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
fd	int
)	O
{	O
if	O
(	O
NULL	O
==	O
daemon	function
->	O
master	pointer
)	O
(	O
void	O
)	O
shutdown	function
(	O
fd	int
,	O
SHUT_RDWR	int
)	O
;	O
}	O
else	O
mhd_assert	O
(	O
false	int
)	O
;	O
}	O
if	O
(	O
!	O
MHD_join_thread_	O
(	O
daemon	function
->	O
pid	int
.	O
handle	long
)	O
)	O
{	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to join a thread\n"	pointer
)	O
)	O
;	O
}	O
}	O
else	O
{	O
MHD_daemon_close_all_connections_	function
(	O
daemon	function
)	O
;	O
}	O
if	O
(	O
MHD_ITC_IS_VALID_	function
(	O
daemon	function
->	O
itc	pointer
)	O
)	O
MHD_itc_destroy_chk_	function
(	O
daemon	function
->	O
itc	pointer
)	O
;	O
if	O
(	O
(	O
MHD_ELS_EPOLL	int
==	O
daemon	function
->	O
event_loop_syscall	enum
)	O
&&	O
(	O
-	O
1	int
!=	O
daemon	function
->	O
epoll_fd	int
)	O
)	O
MHD_socket_close_chk_	O
(	O
daemon	function
->	O
epoll_fd	int
)	O
;	O
MHD_mutex_destroy_chk_	function
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
}	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
master	pointer
)	O
return	O
;	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
fd	int
)	O
MHD_socket_close_chk_	O
(	O
fd	pointer
)	O
;	O
free	function
(	O
daemon	function
->	O
nnc	pointer
)	O
;	O
MHD_mutex_destroy_chk_	function
(	O
&	O
daemon	function
->	O
nnc_lock	union
)	O
;	O
MHD_mutex_destroy_chk_	function
(	O
&	O
daemon	function
->	O
per_ip_connection_mutex	union
)	O
;	O
free	function
(	O
daemon	function
)	O
;	O
}	O
enum	O
MHD_StatusCode	enum
MHD_daemon_get_timeout	function
(	O
struct	O
MHD_Daemon	O
*	O
daemon	function
,	O
MHD_UNSIGNED_LONG_LONG	function
*	O
timeout	O
)	O
{	O
time_t	long
earliest_deadline	long
;	O
time_t	long
now	long
;	O
struct	O
MHD_Connection	struct
*	O
pos	struct
;	O
bool	bool
have_timeout	bool
;	O
if	O
(	O
MHD_TM_EXTERNAL_EVENT_LOOP	int
!=	O
daemon	function
->	O
threading_mode	enum
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
MHD_SC_CONFIGURATION_MISMATCH_FOR_GET_TIMEOUT	pointer
,	O
_	O
(	O
"Illegal call to MHD_get_timeout\n"	pointer
)	O
)	O
;	O
return	O
MHD_SC_CONFIGURATION_MISSMATCH_FOR_GET_TIMEOUT	int
;	O
}	O
if	O
(	O
daemon	function
->	O
data_already_pending	pointer
)	O
{	O
*	O
timeout	int
=	O
0	int
;	O
return	O
MHD_SC_OK	int
;	O
}	O
if	O
(	O
(	O
MHD_ELS_EPOLL	int
==	O
daemon	function
->	O
event_loop_syscall	enum
)	O
&&	O
(	O
(	O
NULL	O
!=	O
daemon	function
->	O
eready_head	pointer
)	O
)	O
)	O
{	O
*	O
timeout	pointer
=	O
0	int
;	O
return	O
MHD_SC_OK	int
;	O
}	O
have_timeout	enum
=	O
false	int
;	O
earliest_deadline	int
=	O
0	int
;	O
for	O
(	O
pos	long
=	O
daemon	function
->	O
manual_timeout_tail	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
prevX	int
)	O
{	O
if	O
(	O
0	int
!=	O
pos	long
->	O
connection_timeout	int
)	O
{	O
if	O
(	O
(	O
!	O
have_timeout	pointer
)	O
||	O
(	O
earliest_deadline	int
-	O
pos	long
->	O
last_activity	long
>	O
pos	long
->	O
connection_timeout	int
)	O
)	O
earliest_deadline	long
=	O
pos	long
->	O
last_activity	long
+	O
pos	long
->	O
connection_timeout	int
;	O
have_timeout	enum
=	O
true	int
;	O
}	O
}	O
pos	long
=	O
daemon	function
->	O
normal_timeout_tail	pointer
;	O
if	O
(	O
(	O
NULL	O
!=	O
pos	long
)	O
&&	O
(	O
0	int
!=	O
pos	long
->	O
connection_timeout	int
)	O
)	O
{	O
if	O
(	O
(	O
!	O
have_timeout	pointer
)	O
||	O
(	O
earliest_deadline	int
-	O
pos	long
->	O
connection_timeout	int
>	O
pos	long
->	O
last_activity	long
)	O
)	O
earliest_deadline	long
=	O
pos	long
->	O
last_activity	long
+	O
pos	long
->	O
connection_timeout	int
;	O
have_timeout	enum
=	O
true	int
;	O
}	O
if	O
(	O
!	O
have_timeout	pointer
)	O
return	O
MHD_SC_NO_TIMEOUT	int
;	O
now	long
=	O
MHD_monotonic_sec_counter	function
(	O
)	O
;	O
if	O
(	O
earliest_deadline	long
<	O
now	long
)	O
*	O
timeout	int
=	O
0	int
;	O
else	O
{	O
const	O
time_t	long
second_left	long
=	O
earliest_deadline	long
-	O
now	long
;	O
if	O
(	O
second_left	long
>	O
ULLONG_MAX	int
/	O
1000	int
)	O
*	O
timeout	int
=	O
ULLONG_MAX	int
;	O
else	O
*	O
timeout	pointer
=	O
1000LL	int
*	O
second_left	pointer
;	O
}	O
return	O
MHD_SC_OK	int
;	O
}	O
static	O
void	O
pre_cork_setsockopt	function
(	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
bool	bool
want_cork	bool
)	O
{	O
}	O
static	O
void	O
post_cork_setsockopt	function
(	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
bool	bool
want_cork	bool
)	O
{	O
}	O
ssize_t	long
MHD_send_on_connection_	function
(	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
const	O
char	O
*	O
buffer	pointer
,	O
size_t	long
buffer_size	long
,	O
enum	O
MHD_SendSocketOptions	enum
options	enum
)	O
{	O
bool	bool
want_cork	bool
;	O
MHD_socket	int
s	int
=	O
connection	pointer
->	O
socket_fd	int
;	O
ssize_t	long
ret	long
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
==	O
s	pointer
)	O
||	O
(	O
MHD_CONNECTION_CLOSED	pointer
==	O
connection	pointer
->	O
state	pointer
)	O
)	O
{	O
return	O
MHD_ERR_NOTCONN_	int
;	O
}	O
if	O
(	O
buffer_size	long
>	O
MHD_SCKT_SEND_MAX_SIZE_	int
)	O
buffer_size	long
=	O
MHD_SCKT_SEND_MAX_SIZE_	int
;	O
switch	O
(	O
options	int
)	O
{	O
case	O
MHD_SSO_NO_CORK	int
:	O
want_cork	enum
=	O
false	int
;	O
break	O
;	O
case	O
MHD_SSO_MAY_CORK	int
:	O
want_cork	bool
=	O
true	int
;	O
break	O
;	O
case	O
MHD_SSO_HDR_CORK	int
:	O
want_cork	long
=	O
(	O
buffer_size	long
<=	O
1024	int
)	O
;	O
break	O
;	O
}	O
{	O
pre_cork_setsockopt	function
(	O
connection	pointer
,	O
want_cork	pointer
)	O
;	O
ret	int
=	O
send	function
(	O
s	pointer
,	O
buffer	pointer
,	O
buffer_size	long
,	O
MAYBE_MSG_NOSIGNAL	int
|	O
(	O
want_cork	int
?	O
MSG_MORE	int
:	O
0	int
)	O
)	O
;	O
if	O
(	O
0	int
>	O
ret	int
)	O
{	O
const	O
int	O
err	int
=	O
MHD_socket_get_error_	function
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EAGAIN_	function
(	O
err	int
)	O
)	O
{	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
return	O
MHD_ERR_AGAIN_	int
;	O
}	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	function
(	O
err	int
)	O
)	O
return	O
MHD_ERR_AGAIN_	int
;	O
if	O
(	O
MHD_SCKT_ERR_IS_	function
(	O
err	int
,	O
MHD_SCKT_ECONNRESET_	pointer
)	O
)	O
return	O
MHD_ERR_CONNRESET_	int
;	O
return	O
MHD_ERR_NOTCONN_	int
;	O
}	O
else	O
if	O
(	O
buffer_size	long
>	O
(	O
size_t	long
)	O
ret	int
)	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
if	O
(	O
ret	int
==	O
buffer_size	int
)	O
post_cork_setsockopt	function
(	O
connection	pointer
,	O
want_cork	pointer
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
ssize_t	long
MHD_send_on_connection2_	function
(	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
const	O
char	O
*	O
header	pointer
,	O
size_t	long
header_size	long
,	O
const	O
char	O
*	O
buffer	pointer
,	O
size_t	long
buffer_size	long
)	O
{	O
MHD_socket	int
s	int
=	O
connection	pointer
->	O
socket_fd	int
;	O
ssize_t	long
ret	long
;	O
struct	O
iovec	struct
vector	struct
[	O
2	int
]	O
;	O
pre_cork_setsockopt	function
(	O
connection	pointer
,	O
false	int
)	O
;	O
vector	struct
[	O
0	int
]	O
.	O
iov_base	pointer
=	O
(	O
void	O
*	O
)	O
header	pointer
;	O
vector	struct
[	O
0	int
]	O
.	O
iov_len	long
=	O
header_size	pointer
;	O
vector	struct
[	O
1	int
]	O
.	O
iov_base	pointer
=	O
(	O
void	O
*	O
)	O
buffer	pointer
;	O
vector	struct
[	O
1	int
]	O
.	O
iov_len	long
=	O
buffer_size	long
;	O
{	O
struct	O
msghdr	struct
msg	struct
;	O
memset	function
(	O
&	O
msg	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
msghdr	struct
)	O
)	O
;	O
msg	struct
.	O
msg_iov	pointer
=	O
vector	struct
;	O
msg	struct
.	O
msg_iovlen	long
=	O
2	int
;	O
ret	int
=	O
sendmsg	function
(	O
s	pointer
,	O
&	O
msg	pointer
,	O
MAYBE_MSG_NOSIGNAL	pointer
)	O
;	O
}	O
if	O
(	O
ret	int
==	O
header_size	int
+	O
buffer_size	int
)	O
post_cork_setsockopt	function
(	O
connection	pointer
,	O
false	int
)	O
;	O
return	O
ret	int
;	O
}	O
ssize_t	long
MHD_send_sendfile_	function
(	O
struct	O
MHD_Connection	O
*	O
connection	pointer
)	O
{	O
ssize_t	long
ret	long
;	O
const	O
int	O
file_fd	int
=	O
connection	pointer
->	O
response	pointer
->	O
fd	int
;	O
uint64_t	long
left	long
;	O
uint64_t	long
offsetu64	long
;	O
const	O
uint64_t	long
max_off_t	long
=	O
(	O
uint64_t	long
)	O
OFF64_T_MAX	long
;	O
off64_t	long
offset	long
;	O
const	O
bool	bool
used_thr_p_c	bool
=	O
(	O
0	int
!=	O
(	O
connection	pointer
->	O
daemon	function
->	O
options	pointer
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
;	O
const	O
size_t	long
chunk_size	long
=	O
used_thr_p_c	bool
?	O
MHD_SENFILE_CHUNK_THR_P_C_	int
:	O
MHD_SENFILE_CHUNK_	int
;	O
size_t	long
send_size	long
=	O
0	int
;	O
mhd_assert	O
(	O
MHD_resp_sender_sendfile	int
==	O
connection	pointer
->	O
resp_sender	enum
)	O
;	O
pre_cork_setsockopt	function
(	O
connection	pointer
,	O
false	int
)	O
;	O
offsetu64	pointer
=	O
connection	pointer
->	O
response_write_position	long
+	O
connection	pointer
->	O
response	pointer
->	O
fd_off	int
;	O
left	long
=	O
connection	pointer
->	O
response	pointer
->	O
total_size	long
-	O
connection	pointer
->	O
response_write_position	long
;	O
send_size	long
=	O
(	O
left	long
>	O
chunk_size	long
)	O
?	O
chunk_size	long
:	O
(	O
size_t	long
)	O
left	long
;	O
if	O
(	O
max_off_t	int
<	O
offsetu64	pointer
)	O
{	O
connection	pointer
->	O
resp_sender	enum
=	O
MHD_resp_sender_std	int
;	O
return	O
MHD_ERR_AGAIN_	int
;	O
}	O
offset	long
=	O
(	O
off64_t	long
)	O
offsetu64	int
;	O
ret	int
=	O
sendfile64	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
file_fd	int
,	O
&	O
offset	long
,	O
send_size	pointer
)	O
;	O
if	O
(	O
0	int
>	O
ret	int
)	O
{	O
const	O
int	O
err	int
=	O
MHD_socket_get_error_	function
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EAGAIN_	function
(	O
err	int
)	O
)	O
{	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
return	O
MHD_ERR_AGAIN_	int
;	O
}	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	function
(	O
err	int
)	O
)	O
return	O
MHD_ERR_AGAIN_	int
;	O
if	O
(	O
MHD_SCKT_ERR_IS_	function
(	O
err	int
,	O
MHD_SCKT_EBADF_	pointer
)	O
)	O
return	O
MHD_ERR_BADF_	int
;	O
connection	pointer
->	O
resp_sender	enum
=	O
MHD_resp_sender_std	int
;	O
return	O
MHD_ERR_AGAIN_	int
;	O
}	O
else	O
if	O
(	O
send_size	long
>	O
(	O
size_t	long
)	O
ret	int
)	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
if	O
(	O
ret	int
==	O
left	long
)	O
post_cork_setsockopt	function
(	O
connection	pointer
,	O
false	int
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
const	O
char	O
*	O
const	O
invalid_hundred	array
[	O
]	O
=	O
{	O
NULL	O
}	O
;	O
static	O
const	O
char	O
*	O
const	O
one_hundred	array
[	O
]	O
=	O
{	O
"Continue"	pointer
,	O
"Switching Protocols"	pointer
,	O
"Processing"	pointer
,	O
"Early Hints"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
const	O
two_hundred	array
[	O
]	O
=	O
{	O
"OK"	pointer
,	O
"Created"	pointer
,	O
"Accepted"	pointer
,	O
"Non-Authoritative Information"	pointer
,	O
"No Content"	pointer
,	O
"Reset Content"	pointer
,	O
"Partial Content"	pointer
,	O
"Multi-Status"	pointer
,	O
"Already Reported"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"IM Used"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
const	O
three_hundred	array
[	O
]	O
=	O
{	O
"Multiple Choices"	pointer
,	O
"Moved Permanently"	pointer
,	O
"Found"	pointer
,	O
"See Other"	pointer
,	O
"Not Modified"	pointer
,	O
"Use Proxy"	pointer
,	O
"Switch Proxy"	pointer
,	O
"Temporary Redirect"	pointer
,	O
"Permanent Redirect"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
const	O
four_hundred	array
[	O
]	O
=	O
{	O
"Bad Request"	pointer
,	O
"Unauthorized"	pointer
,	O
"Payment Required"	pointer
,	O
"Forbidden"	pointer
,	O
"Not Found"	pointer
,	O
"Method Not Allowed"	pointer
,	O
"Not Acceptable"	pointer
,	O
"Proxy Authentication Required"	pointer
,	O
"Request Timeout"	pointer
,	O
"Conflict"	pointer
,	O
"Gone"	pointer
,	O
"Length Required"	pointer
,	O
"Precondition Failed"	pointer
,	O
"Payload Too Large"	pointer
,	O
"URI Too Long"	pointer
,	O
"Unsupported Media Type"	pointer
,	O
"Range Not Satisfiable"	pointer
,	O
"Expectation Failed"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Misdirected Request"	pointer
,	O
"Unprocessable Entity"	pointer
,	O
"Locked"	pointer
,	O
"Failed Dependency"	pointer
,	O
"Too Early"	pointer
,	O
"Upgrade Required"	pointer
,	O
"Unknown"	pointer
,	O
"Precondition Required"	pointer
,	O
"Too Many Requests"	pointer
,	O
"Unknown"	pointer
,	O
"Request Header Fields Too Large"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Unknown"	pointer
,	O
"Reply With"	pointer
,	O
"Blocked by Windows Parental Controls"	pointer
,	O
"Unavailable For Legal Reasons"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
const	O
five_hundred	array
[	O
]	O
=	O
{	O
"Internal Server Error"	pointer
,	O
"Not Implemented"	pointer
,	O
"Bad Gateway"	pointer
,	O
"Service Unavailable"	pointer
,	O
"Gateway Timeout"	pointer
,	O
"HTTP Version Not Supported"	pointer
,	O
"Variant Also Negotiates"	pointer
,	O
"Insufficient Storage"	pointer
,	O
"Loop Detected"	pointer
,	O
"Bandwidth Limit Exceeded"	pointer
,	O
"Not Extended"	pointer
,	O
"Network Authentication Required"	pointer
}	O
;	O
struct	O
MHD_Reason_Block	struct
{	O
size_t	long
max	long
;	O
const	O
char	O
*	O
const	O
*	O
data	pointer
;	O
}	O
;	O
static	O
const	O
struct	O
MHD_Reason_Block	struct
reasons	array
[	O
]	O
=	O
{	O
BLOCK	O
(	O
invalid_hundred	pointer
)	O
,	O
BLOCK	O
(	O
one_hundred	pointer
)	O
,	O
BLOCK	O
(	O
two_hundred	int
)	O
,	O
BLOCK	O
(	O
three_hundred	int
)	O
,	O
BLOCK	O
(	O
four_hundred	int
)	O
,	O
BLOCK	O
(	O
five_hundred	pointer
)	O
,	O
}	O
;	O
const	O
char	O
*	O
MHD_get_reason_phrase_for	function
(	O
unsigned	O
int	O
code	int
)	O
{	O
if	O
(	O
(	O
code	int
>=	O
100	int
)	O
&&	O
(	O
code	int
<	O
600	int
)	O
&&	O
(	O
reasons	array
[	O
code	int
/	O
100	int
]	O
.	O
max	int
>	O
(	O
code	int
%	O
100	int
)	O
)	O
)	O
return	O
reasons	array
[	O
code	int
/	O
100	int
]	O
.	O
data	pointer
[	O
code	int
%	O
100	int
]	O
;	O
return	O
"Unknown"	pointer
;	O
}	O
static	O
transition_t	struct
*	O
fsm_findmethod	function
(	O
type_t	enum
type	enum
,	O
state_t	enum
state	pointer
,	O
osip_statemachine_t	struct
*	O
statemachine	pointer
)	O
;	O
static	O
transition_t	struct
*	O
fsm_findmethod	function
(	O
type_t	enum
type	enum
,	O
state_t	enum
state	pointer
,	O
osip_statemachine_t	struct
*	O
statemachine	pointer
)	O
{	O
transition_t	struct
*	O
transition	pointer
;	O
for	O
(	O
transition	pointer
=	O
statemachine	pointer
->	O
transitions	pointer
;	O
transition	pointer
!=	O
NULL	O
;	O
transition	pointer
=	O
transition	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
transition	pointer
->	O
type	enum
==	O
type	int
&&	O
transition	pointer
->	O
state	pointer
==	O
state	pointer
)	O
return	O
transition	int
;	O
}	O
return	O
NULL	O
;	O
}	O
int	O
fsm_callmethod	function
(	O
type_t	enum
type	enum
,	O
state_t	int
state	pointer
,	O
osip_statemachine_t	struct
*	O
statemachine	pointer
,	O
void	O
*	O
sipevent	pointer
,	O
void	O
*	O
transaction	pointer
)	O
{	O
transition_t	struct
*	O
transition	pointer
;	O
transition	pointer
=	O
fsm_findmethod	function
(	O
type	int
,	O
state	pointer
,	O
statemachine	int
)	O
;	O
if	O
(	O
transition	pointer
==	O
NULL	O
)	O
{	O
return	O
OSIP_UNDEFINED_ERROR	O
;	O
}	O
transition	pointer
->	O
method	pointer
(	O
transaction	pointer
,	O
sipevent	pointer
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
__osip_nict_init	function
(	O
osip_nict_t	struct
*	O
*	O
nict	pointer
,	O
osip_t	struct
*	O
osip	struct
,	O
osip_message_t	struct
*	O
request	pointer
)	O
{	O
osip_route_t	struct
*	O
route	pointer
;	O
int	O
i	int
;	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_INFO2	O
,	O
NULL	O
,	O
"allocating NICT context\n"	pointer
)	O
)	O
;	O
*	O
nict	pointer
=	O
(	O
osip_nict_t	struct
*	O
)	O
osip_malloc	O
(	O
sizeof	O
(	O
osip_nict_t	pointer
)	O
)	O
;	O
if	O
(	O
*	O
nict	pointer
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
memset	function
(	O
*	O
nict	pointer
,	O
0	int
,	O
sizeof	O
(	O
osip_nict_t	struct
)	O
)	O
;	O
{	O
osip_via_t	struct
*	O
via	pointer
;	O
char	O
*	O
proto	pointer
;	O
i	int
=	O
osip_message_get_via	function
(	O
request	pointer
,	O
0	int
,	O
&	O
via	pointer
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
osip_free	O
(	O
*	O
nict	pointer
)	O
;	O
*	O
nict	pointer
=	O
NULL	O
;	O
return	O
i	int
;	O
}	O
proto	pointer
=	O
via_get_protocol	function
(	O
via	pointer
)	O
;	O
if	O
(	O
proto	pointer
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
*	O
nict	pointer
)	O
;	O
*	O
nict	pointer
=	O
NULL	O
;	O
return	O
OSIP_UNDEFINED_ERROR	O
;	O
}	O
if	O
(	O
osip_strcasecmp	function
(	O
proto	pointer
,	O
"TCP"	pointer
)	O
!=	O
0	int
&&	O
osip_strcasecmp	function
(	O
proto	pointer
,	O
"TLS"	pointer
)	O
!=	O
0	int
&&	O
osip_strcasecmp	function
(	O
proto	pointer
,	O
"SCTP"	pointer
)	O
!=	O
0	int
)	O
{	O
(	O
*	O
nict	pointer
)	O
->	O
timer_e_length	int
=	O
DEFAULT_T1	int
;	O
(	O
*	O
nict	pointer
)	O
->	O
timer_k_length	int
=	O
DEFAULT_T4	int
;	O
(	O
*	O
nict	pointer
)	O
->	O
timer_e_start	struct
.	O
tv_sec	long
=	O
-	O
1	int
;	O
(	O
*	O
nict	pointer
)	O
->	O
timer_k_start	struct
.	O
tv_sec	long
=	O
-	O
1	int
;	O
}	O
else	O
{	O
(	O
*	O
nict	pointer
)	O
->	O
timer_e_length	int
=	O
DEFAULT_T1	int
;	O
(	O
*	O
nict	pointer
)	O
->	O
timer_k_length	int
=	O
0	int
;	O
(	O
*	O
nict	pointer
)	O
->	O
timer_e_start	struct
.	O
tv_sec	long
=	O
-	O
1	int
;	O
(	O
*	O
nict	pointer
)	O
->	O
timer_k_start	struct
.	O
tv_sec	long
=	O
-	O
1	int
;	O
}	O
}	O
osip_message_get_route	function
(	O
request	pointer
,	O
0	int
,	O
&	O
route	pointer
)	O
;	O
if	O
(	O
route	pointer
!=	O
NULL	O
&&	O
route	pointer
->	O
url	pointer
!=	O
NULL	O
)	O
{	O
osip_uri_param_t	struct
*	O
lr_param	pointer
;	O
osip_uri_uparam_get_byname	O
(	O
route	pointer
->	O
url	pointer
,	O
"lr"	pointer
,	O
&	O
lr_param	pointer
)	O
;	O
if	O
(	O
lr_param	pointer
==	O
NULL	O
)	O
{	O
route	pointer
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
route	pointer
!=	O
NULL	O
&&	O
route	pointer
->	O
url	pointer
!=	O
NULL	O
)	O
{	O
int	O
port	pointer
=	O
5060	int
;	O
if	O
(	O
route	pointer
->	O
url	pointer
->	O
port	pointer
!=	O
NULL	O
)	O
port	pointer
=	O
osip_atoi	function
(	O
route	pointer
->	O
url	pointer
->	O
port	pointer
)	O
;	O
osip_nict_set_destination	function
(	O
(	O
*	O
nict	pointer
)	O
,	O
osip_strdup	function
(	O
route	pointer
->	O
url	pointer
->	O
host	pointer
)	O
,	O
port	pointer
)	O
;	O
}	O
else	O
{	O
int	O
port	pointer
=	O
5060	int
;	O
osip_uri_param_t	struct
*	O
maddr_param	pointer
=	O
NULL	O
;	O
osip_uri_param_t	struct
*	O
obr_param	pointer
=	O
NULL	O
;	O
osip_uri_param_t	struct
*	O
obp_param	pointer
=	O
NULL	O
;	O
port	pointer
=	O
5060	int
;	O
if	O
(	O
request	pointer
->	O
req_uri	pointer
->	O
port	pointer
!=	O
NULL	O
)	O
port	pointer
=	O
osip_atoi	function
(	O
request	pointer
->	O
req_uri	pointer
->	O
port	pointer
)	O
;	O
osip_uri_uparam_get_byname	O
(	O
request	pointer
->	O
req_uri	pointer
,	O
"x-obr"	pointer
,	O
&	O
obr_param	pointer
)	O
;	O
osip_uri_uparam_get_byname	O
(	O
request	pointer
->	O
req_uri	pointer
,	O
"x-obp"	pointer
,	O
&	O
obp_param	pointer
)	O
;	O
osip_uri_uparam_get_byname	O
(	O
request	pointer
->	O
req_uri	pointer
,	O
"maddr"	pointer
,	O
&	O
maddr_param	pointer
)	O
;	O
if	O
(	O
maddr_param	pointer
!=	O
NULL	O
&&	O
maddr_param	pointer
->	O
gvalue	pointer
!=	O
NULL	O
)	O
osip_nict_set_destination	function
(	O
(	O
*	O
nict	pointer
)	O
,	O
osip_strdup	function
(	O
maddr_param	pointer
->	O
gvalue	pointer
)	O
,	O
port	pointer
)	O
;	O
else	O
if	O
(	O
obr_param	pointer
!=	O
NULL	O
&&	O
obr_param	pointer
->	O
gvalue	pointer
!=	O
NULL	O
&&	O
obp_param	pointer
!=	O
NULL	O
&&	O
obp_param	pointer
->	O
gvalue	pointer
!=	O
NULL	O
)	O
osip_nict_set_destination	function
(	O
(	O
*	O
nict	pointer
)	O
,	O
osip_strdup	function
(	O
obr_param	pointer
->	O
gvalue	pointer
)	O
,	O
osip_atoi	function
(	O
obp_param	pointer
->	O
gvalue	pointer
)	O
)	O
;	O
else	O
osip_nict_set_destination	function
(	O
(	O
*	O
nict	pointer
)	O
,	O
osip_strdup	function
(	O
request	pointer
->	O
req_uri	pointer
->	O
host	pointer
)	O
,	O
port	pointer
)	O
;	O
}	O
(	O
*	O
nict	pointer
)	O
->	O
timer_f_length	int
=	O
64	int
*	O
DEFAULT_T1	int
;	O
osip_gettimeofday	function
(	O
&	O
(	O
*	O
nict	pointer
)	O
->	O
timer_f_start	pointer
,	O
NULL	O
)	O
;	O
add_gettimeofday	function
(	O
&	O
(	O
*	O
nict	pointer
)	O
->	O
timer_f_start	pointer
,	O
(	O
*	O
nict	pointer
)	O
->	O
timer_f_length	pointer
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
__osip_nict_free	function
(	O
osip_nict_t	struct
*	O
nict	pointer
)	O
{	O
if	O
(	O
nict	pointer
==	O
NULL	O
)	O
return	O
OSIP_SUCCESS	int
;	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_INFO2	O
,	O
NULL	O
,	O
"free nict resource\n"	pointer
)	O
)	O
;	O
osip_free	O
(	O
nict	pointer
->	O
destination	pointer
)	O
;	O
osip_free	O
(	O
nict	pointer
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
osip_nict_set_destination	function
(	O
osip_nict_t	struct
*	O
nict	pointer
,	O
char	O
*	O
destination	pointer
,	O
int	O
port	int
)	O
{	O
if	O
(	O
nict	pointer
==	O
NULL	O
)	O
return	O
OSIP_BADPARAMETER	O
;	O
if	O
(	O
nict	pointer
->	O
destination	pointer
!=	O
NULL	O
)	O
osip_free	O
(	O
nict	pointer
->	O
destination	pointer
)	O
;	O
nict	pointer
->	O
destination	int
=	O
destination	int
;	O
nict	pointer
->	O
port	int
=	O
port	int
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
osip_event_t	struct
*	O
__osip_nict_need_timer_e_event	function
(	O
osip_nict_t	struct
*	O
nict	pointer
,	O
state_t	enum
state	pointer
,	O
int	O
transactionid	int
)	O
{	O
return	O
__osip_transaction_need_timer_x_event	function
(	O
nict	pointer
,	O
&	O
nict	pointer
->	O
timer_e_start	struct
,	O
state	pointer
==	O
NICT_PROCEEDING	int
||	O
state	pointer
==	O
NICT_TRYING	int
,	O
transactionid	int
,	O
TIMEOUT_E	int
)	O
;	O
}	O
osip_event_t	struct
*	O
__osip_nict_need_timer_f_event	function
(	O
osip_nict_t	struct
*	O
nict	pointer
,	O
state_t	enum
state	pointer
,	O
int	O
transactionid	int
)	O
{	O
return	O
__osip_transaction_need_timer_x_event	function
(	O
nict	pointer
,	O
&	O
nict	pointer
->	O
timer_f_start	struct
,	O
state	pointer
==	O
NICT_PROCEEDING	int
||	O
state	pointer
==	O
NICT_TRYING	int
,	O
transactionid	int
,	O
TIMEOUT_F	int
)	O
;	O
}	O
osip_event_t	struct
*	O
__osip_nict_need_timer_k_event	function
(	O
osip_nict_t	struct
*	O
nict	pointer
,	O
state_t	enum
state	pointer
,	O
int	O
transactionid	int
)	O
{	O
return	O
__osip_transaction_need_timer_x_event	function
(	O
nict	pointer
,	O
&	O
nict	pointer
->	O
timer_k_start	struct
,	O
state	pointer
==	O
NICT_COMPLETED	int
,	O
transactionid	int
,	O
TIMEOUT_K	int
)	O
;	O
}	O
int	O
__osip_nist_init	function
(	O
osip_nist_t	struct
*	O
*	O
nist	pointer
,	O
osip_t	struct
*	O
osip	struct
,	O
osip_message_t	struct
*	O
invite	pointer
)	O
{	O
int	O
i	int
;	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_INFO2	O
,	O
NULL	O
,	O
"allocating NIST context\n"	pointer
)	O
)	O
;	O
*	O
nist	pointer
=	O
(	O
osip_nist_t	struct
*	O
)	O
osip_malloc	O
(	O
sizeof	O
(	O
osip_nist_t	pointer
)	O
)	O
;	O
if	O
(	O
*	O
nist	pointer
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
memset	function
(	O
*	O
nist	pointer
,	O
0	int
,	O
sizeof	O
(	O
osip_nist_t	pointer
)	O
)	O
;	O
{	O
osip_via_t	struct
*	O
via	pointer
;	O
char	O
*	O
proto	pointer
;	O
i	int
=	O
osip_message_get_via	function
(	O
invite	pointer
,	O
0	int
,	O
&	O
via	pointer
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
osip_free	O
(	O
*	O
nist	pointer
)	O
;	O
*	O
nist	pointer
=	O
NULL	O
;	O
return	O
i	int
;	O
}	O
proto	pointer
=	O
via_get_protocol	function
(	O
via	pointer
)	O
;	O
if	O
(	O
proto	pointer
==	O
NULL	O
)	O
{	O
osip_free	O
(	O
*	O
nist	pointer
)	O
;	O
*	O
nist	pointer
=	O
NULL	O
;	O
return	O
OSIP_UNDEFINED_ERROR	O
;	O
}	O
if	O
(	O
osip_strcasecmp	function
(	O
proto	pointer
,	O
"TCP"	pointer
)	O
!=	O
0	int
&&	O
osip_strcasecmp	function
(	O
proto	pointer
,	O
"TLS"	pointer
)	O
!=	O
0	int
&&	O
osip_strcasecmp	function
(	O
proto	pointer
,	O
"SCTP"	pointer
)	O
!=	O
0	int
)	O
{	O
(	O
*	O
nist	pointer
)	O
->	O
timer_j_length	int
=	O
64	int
*	O
DEFAULT_T1	int
;	O
(	O
*	O
nist	pointer
)	O
->	O
timer_j_start	struct
.	O
tv_sec	long
=	O
-	O
1	int
;	O
}	O
else	O
{	O
(	O
*	O
nist	pointer
)	O
->	O
timer_j_length	int
=	O
0	int
;	O
(	O
*	O
nist	pointer
)	O
->	O
timer_j_start	struct
.	O
tv_sec	long
=	O
-	O
1	int
;	O
}	O
}	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
__osip_nist_free	function
(	O
osip_nist_t	struct
*	O
nist	pointer
)	O
{	O
if	O
(	O
nist	pointer
==	O
NULL	O
)	O
return	O
OSIP_SUCCESS	int
;	O
OSIP_TRACE	O
(	O
osip_trace	function
(	O
__FILE__	O
,	O
__LINE__	O
,	O
OSIP_INFO2	O
,	O
NULL	O
,	O
"free nist resource\n"	pointer
)	O
)	O
;	O
osip_free	O
(	O
nist	pointer
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
osip_event_t	struct
*	O
__osip_nist_need_timer_j_event	function
(	O
osip_nist_t	struct
*	O
nist	pointer
,	O
state_t	enum
state	pointer
,	O
int	O
transactionid	int
)	O
{	O
return	O
__osip_transaction_need_timer_x_event	function
(	O
nist	pointer
,	O
&	O
nist	pointer
->	O
timer_j_start	struct
,	O
state	pointer
==	O
NIST_COMPLETED	int
,	O
transactionid	int
,	O
TIMEOUT_J	int
)	O
;	O
}	O
int	O
osip_message_set_contact	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
hvalue	pointer
)	O
{	O
int	O
i	int
;	O
osip_contact_t	struct
*	O
contact	pointer
;	O
if	O
(	O
hvalue	pointer
==	O
NULL	O
||	O
hvalue	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
OSIP_SUCCESS	int
;	O
i	int
=	O
osip_contact_init	function
(	O
&	O
contact	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
i	int
=	O
osip_contact_parse	function
(	O
contact	pointer
,	O
hvalue	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_contact_free	function
(	O
contact	pointer
)	O
;	O
return	O
i	int
;	O
}	O
sip	pointer
->	O
message_property	int
=	O
2	int
;	O
osip_list_add	function
(	O
&	O
sip	pointer
->	O
contacts	struct
,	O
contact	pointer
,	O
-	O
1	int
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
osip_contact_parse	function
(	O
osip_contact_t	struct
*	O
contact	pointer
,	O
const	O
char	O
*	O
hvalue	pointer
)	O
{	O
if	O
(	O
contact	pointer
==	O
NULL	O
)	O
return	O
OSIP_BADPARAMETER	O
;	O
if	O
(	O
strncmp	function
(	O
hvalue	pointer
,	O
"*"	pointer
,	O
1	int
)	O
==	O
0	int
)	O
{	O
contact	pointer
->	O
displayname	pointer
=	O
osip_strdup	function
(	O
hvalue	pointer
)	O
;	O
if	O
(	O
contact	pointer
->	O
displayname	pointer
==	O
NULL	O
)	O
{	O
return	O
OSIP_NOMEM	O
;	O
}	O
return	O
OSIP_SUCCESS	int
;	O
}	O
return	O
osip_from_parse	function
(	O
(	O
osip_from_t	struct
*	O
)	O
contact	pointer
,	O
hvalue	pointer
)	O
;	O
}	O
int	O
osip_contact_init	function
(	O
osip_contact_t	struct
*	O
*	O
contact	pointer
)	O
{	O
return	O
osip_from_init	function
(	O
(	O
osip_from_t	struct
*	O
*	O
)	O
contact	pointer
)	O
;	O
}	O
int	O
osip_message_get_contact	function
(	O
const	O
osip_message_t	struct
*	O
sip	pointer
,	O
int	O
pos	int
,	O
osip_contact_t	struct
*	O
*	O
dest	pointer
)	O
{	O
*	O
dest	pointer
=	O
NULL	O
;	O
if	O
(	O
sip	pointer
==	O
NULL	O
)	O
return	O
OSIP_BADPARAMETER	O
;	O
if	O
(	O
osip_list_size	function
(	O
&	O
sip	pointer
->	O
contacts	struct
)	O
<=	O
pos	int
)	O
return	O
OSIP_UNDEFINED_ERROR	O
;	O
*	O
dest	pointer
=	O
(	O
osip_contact_t	struct
*	O
)	O
osip_list_get	function
(	O
&	O
sip	pointer
->	O
contacts	struct
,	O
pos	int
)	O
;	O
return	O
pos	int
;	O
}	O
int	O
osip_contact_to_str	function
(	O
const	O
osip_contact_t	struct
*	O
contact	pointer
,	O
char	O
*	O
*	O
dest	pointer
)	O
{	O
if	O
(	O
contact	pointer
==	O
NULL	O
)	O
return	O
OSIP_BADPARAMETER	O
;	O
if	O
(	O
contact	pointer
->	O
displayname	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
contact	pointer
->	O
displayname	pointer
,	O
"*"	pointer
,	O
1	int
)	O
==	O
0	int
)	O
{	O
*	O
dest	pointer
=	O
osip_strdup	function
(	O
"*"	pointer
)	O
;	O
if	O
(	O
*	O
dest	pointer
==	O
NULL	O
)	O
return	O
OSIP_NOMEM	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
}	O
return	O
osip_from_to_str	function
(	O
(	O
osip_from_t	struct
*	O
)	O
contact	pointer
,	O
dest	pointer
)	O
;	O
}	O
void	O
osip_contact_free	function
(	O
osip_contact_t	struct
*	O
contact	pointer
)	O
{	O
osip_from_free	function
(	O
(	O
osip_from_t	struct
*	O
)	O
contact	pointer
)	O
;	O
}	O
int	O
osip_contact_clone	function
(	O
const	O
osip_contact_t	struct
*	O
contact	pointer
,	O
osip_contact_t	struct
*	O
*	O
dest	pointer
)	O
{	O
return	O
osip_from_clone	function
(	O
(	O
osip_from_t	struct
*	O
)	O
contact	pointer
,	O
(	O
osip_from_t	struct
*	O
*	O
)	O
dest	pointer
)	O
;	O
}	O
int	O
osip_message_set_mime_version	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
hvalue	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
hvalue	pointer
==	O
NULL	O
||	O
hvalue	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
OSIP_SUCCESS	int
;	O
if	O
(	O
sip	pointer
->	O
mime_version	pointer
!=	O
NULL	O
)	O
return	O
OSIP_SYNTAXERROR	O
;	O
i	int
=	O
osip_mime_version_init	function
(	O
&	O
(	O
sip	pointer
->	O
mime_version	pointer
)	O
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
sip	pointer
->	O
message_property	int
=	O
2	int
;	O
i	int
=	O
osip_mime_version_parse	function
(	O
sip	pointer
->	O
mime_version	pointer
,	O
hvalue	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_mime_version_free	function
(	O
sip	pointer
->	O
mime_version	pointer
)	O
;	O
sip	pointer
->	O
mime_version	pointer
=	O
NULL	O
;	O
return	O
i	int
;	O
}	O
return	O
OSIP_SUCCESS	int
;	O
}	O
osip_mime_version_t	struct
*	O
osip_message_get_mime_version	function
(	O
const	O
osip_message_t	struct
*	O
sip	pointer
)	O
{	O
return	O
sip	pointer
->	O
mime_version	pointer
;	O
}	O
int	O
osip_route_init	function
(	O
osip_route_t	struct
*	O
*	O
route	pointer
)	O
{	O
return	O
osip_from_init	function
(	O
(	O
osip_from_t	struct
*	O
*	O
)	O
route	pointer
)	O
;	O
}	O
int	O
osip_message_set_route	function
(	O
osip_message_t	struct
*	O
sip	pointer
,	O
const	O
char	O
*	O
hvalue	pointer
)	O
{	O
osip_route_t	struct
*	O
route	pointer
;	O
int	O
i	int
;	O
if	O
(	O
hvalue	pointer
==	O
NULL	O
||	O
hvalue	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
OSIP_SUCCESS	int
;	O
i	int
=	O
osip_route_init	function
(	O
&	O
route	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
return	O
i	int
;	O
i	int
=	O
osip_route_parse	function
(	O
route	pointer
,	O
hvalue	pointer
)	O
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
osip_route_free	function
(	O
route	pointer
)	O
;	O
return	O
i	int
;	O
}	O
sip	pointer
->	O
message_property	int
=	O
2	int
;	O
osip_list_add	function
(	O
&	O
sip	pointer
->	O
routes	struct
,	O
route	pointer
,	O
-	O
1	int
)	O
;	O
return	O
OSIP_SUCCESS	int
;	O
}	O
int	O
osip_message_get_route	function
(	O
const	O
osip_message_t	struct
*	O
sip	pointer
,	O
int	O
pos	int
,	O
osip_route_t	struct
*	O
*	O
dest	pointer
)	O
{	O
osip_route_t	struct
*	O
route	pointer
;	O
*	O
dest	pointer
=	O
NULL	O
;	O
if	O
(	O
osip_list_size	function
(	O
&	O
sip	pointer
->	O
routes	struct
)	O
<=	O
pos	int
)	O
return	O
OSIP_UNDEFINED_ERROR	O
;	O
route	pointer
=	O
(	O
osip_route_t	struct
*	O
)	O
osip_list_get	function
(	O
&	O
sip	pointer
->	O
routes	struct
,	O
pos	int
)	O
;	O
*	O
dest	pointer
=	O
route	pointer
;	O
return	O
pos	int
;	O
}	O
int	O
osip_route_parse	function
(	O
osip_route_t	struct
*	O
route	pointer
,	O
const	O
char	O
*	O
hvalue	pointer
)	O
{	O
return	O
osip_from_parse	function
(	O
(	O
osip_from_t	struct
*	O
)	O
route	pointer
,	O
hvalue	pointer
)	O
;	O
}	O
int	O
osip_route_to_str	function
(	O
const	O
osip_route_t	struct
*	O
route	pointer
,	O
char	O
*	O
*	O
dest	pointer
)	O
{	O
return	O
osip_record_route_to_str	function
(	O
(	O
osip_record_route_t	struct
*	O
)	O
route	pointer
,	O
dest	pointer
)	O
;	O
}	O
void	O
osip_route_free	function
(	O
osip_route_t	struct
*	O
route	pointer
)	O
{	O
osip_from_free	function
(	O
(	O
osip_from_t	struct
*	O
)	O
route	pointer
)	O
;	O
}	O
jmp_buf	array
mainloop	array
;	O
sigset_t	struct
mainsigset	struct
;	O
volatile	O
int	O
pass	int
=	O
0	int
;	O
uintptr_t	long
page	long
;	O
static	O
void	O
stackoverflow_handler_continuation	function
(	O
void	O
*	O
arg1	pointer
,	O
void	O
*	O
arg2	pointer
,	O
void	O
*	O
arg3	pointer
)	O
{	O
int	O
arg	int
=	O
(	O
int	O
)	O
(	O
long	O
)	O
arg1	pointer
;	O
longjmp	function
(	O
mainloop	array
,	O
arg	int
)	O
;	O
}	O
void	O
stackoverflow_handler	function
(	O
int	O
emergency	int
,	O
stackoverflow_context_t	pointer
scp	pointer
)	O
{	O
pass	pointer
++	O
;	O
if	O
(	O
pass	enum
<=	O
2	int
)	O
printf	function
(	O
"Stack overflow %d caught.\n"	pointer
,	O
pass	int
)	O
;	O
else	O
{	O
printf	function
(	O
"Segmentation violation misdetected as stack overflow.\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
&	O
mainsigset	struct
,	O
NULL	O
)	O
;	O
sigsegv_leave_handler	function
(	O
stackoverflow_handler_continuation	function
,	O
(	O
void	O
*	O
)	O
(	O
long	O
)	O
(	O
emergency	int
?	O
-	O
1	int
:	O
pass	int
)	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
int	O
sigsegv_handler	function
(	O
void	O
*	O
address	int
,	O
int	O
emergency	int
)	O
{	O
if	O
(	O
!	O
emergency	int
)	O
return	O
0	int
;	O
pass	int
++	O
;	O
if	O
(	O
pass	int
<=	O
2	int
)	O
{	O
printf	function
(	O
"Stack overflow %d missed.\n"	pointer
,	O
pass	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
printf	function
(	O
"Segmentation violation correctly detected.\n"	pointer
)	O
;	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
&	O
mainsigset	struct
,	O
NULL	O
)	O
;	O
return	O
sigsegv_leave_handler	function
(	O
stackoverflow_handler_continuation	function
,	O
(	O
void	O
*	O
)	O
(	O
long	O
)	O
pass	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
volatile	O
int	O
*	O
recurse_1	function
(	O
int	O
n	int
,	O
volatile	O
int	O
*	O
p	pointer
)	O
{	O
if	O
(	O
n	int
<	O
INT_MAX	O
)	O
*	O
recurse_1	function
(	O
n	int
+	O
1	int
,	O
p	pointer
)	O
+=	O
n	int
;	O
return	O
p	pointer
;	O
}	O
int	O
recurse	function
(	O
volatile	O
int	O
n	int
)	O
{	O
return	O
*	O
recurse_1	function
(	O
n	int
,	O
&	O
n	int
)	O
;	O
}	O
int	O
main	function
(	O
)	O
{	O
int	O
prot_unwritable	int
;	O
void	O
*	O
p	pointer
;	O
sigset_t	struct
emptyset	struct
;	O
struct	O
rlimit	struct
rl	struct
;	O
rl	struct
.	O
rlim_cur	long
=	O
rl	struct
.	O
rlim_max	long
=	O
0x100000	int
;	O
setrlimit	function
(	O
RLIMIT_STACK	int
,	O
&	O
rl	struct
)	O
;	O
prepare_alternate_stack	function
(	O
)	O
;	O
if	O
(	O
stackoverflow_install_handler	function
(	O
&	O
stackoverflow_handler	function
,	O
mystack	pointer
,	O
SIGSTKSZ	int
)	O
<	O
0	int
)	O
exit	function
(	O
2	int
)	O
;	O
prot_unwritable	int
=	O
PROT_READ	int
;	O
p	O
=	O
mmap_zeromap	function
(	O
(	O
void	O
*	O
)	O
0x12340000	int
,	O
0x4000	int
)	O
;	O
if	O
(	O
p	pointer
==	O
(	O
void	O
*	O
)	O
(	O
-	O
1	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"mmap_zeromap failed.\n"	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
page	long
=	O
(	O
uintptr_t	long
)	O
p	long
;	O
if	O
(	O
mprotect	function
(	O
(	O
void	O
*	O
)	O
page	long
,	O
0x4000	int
,	O
prot_unwritable	int
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"mprotect failed.\n"	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
if	O
(	O
sigsegv_install_handler	function
(	O
&	O
sigsegv_handler	function
)	O
<	O
0	int
)	O
exit	function
(	O
2	int
)	O
;	O
sigemptyset	function
(	O
&	O
emptyset	struct
)	O
;	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
emptyset	struct
,	O
&	O
mainsigset	struct
)	O
;	O
switch	O
(	O
setjmp	function
(	O
mainloop	array
)	O
)	O
{	O
case	O
-	O
1	int
:	O
printf	function
(	O
"emergency exit\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
case	O
0	int
:	O
case	O
1	int
:	O
printf	function
(	O
"Starting recursion pass %d.\n"	pointer
,	O
pass	int
+	O
1	int
)	O
;	O
recurse	function
(	O
0	int
)	O
;	O
printf	function
(	O
"no endless recursion?!\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
case	O
2	int
:	O
*	O
(	O
volatile	O
int	O
*	O
)	O
(	O
page	int
+	O
0x678	int
)	O
=	O
42	int
;	O
break	O
;	O
case	O
3	int
:	O
*	O
(	O
volatile	O
int	O
*	O
)	O
0	int
=	O
42	int
;	O
break	O
;	O
case	O
4	int
:	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
check_alternate_stack_no_overflow	function
(	O
)	O
;	O
printf	function
(	O
"Test passed.\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
struct	O
fuzz_elem	struct
{	O
unsigned	O
int	O
type	int
;	O
char	O
name	pointer
[	O
20	int
]	O
;	O
char	O
value	pointer
[	O
20	int
]	O
;	O
}	O
;	O
static	O
char	O
*	O
escape	function
(	O
unsigned	O
char	O
*	O
s	pointer
)	O
{	O
static	O
char	O
out	pointer
[	O
19	int
*	O
6	int
+	O
1	int
]	O
;	O
char	O
*	O
p	pointer
=	O
out	pointer
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
>	O
127	int
)	O
{	O
if	O
(	O
isxdigit	function
(	O
s	pointer
[	O
1	int
]	O
)	O
)	O
{	O
sprintf	function
(	O
p	pointer
,	O
"\\u%04x"	pointer
,	O
*	O
s	pointer
++	O
)	O
;	O
p	pointer
+=	O
6	int
;	O
}	O
else	O
{	O
sprintf	function
(	O
p	pointer
,	O
"\\x%02x"	pointer
,	O
*	O
s	pointer
++	O
)	O
;	O
p	pointer
+=	O
4	int
;	O
}	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'\n'	O
)	O
{	O
sprintf	function
(	O
p	pointer
,	O
"\\n"	pointer
)	O
;	O
p	pointer
+=	O
2	int
;	O
s	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'\t'	O
)	O
{	O
sprintf	function
(	O
p	pointer
,	O
"\\t"	pointer
)	O
;	O
p	pointer
+=	O
2	int
;	O
s	pointer
++	O
;	O
}	O
else	O
*	O
p	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
}	O
*	O
p	pointer
=	O
0	int
;	O
return	O
out	pointer
;	O
}	O
static	O
const	O
char	O
*	O
typename	array
[	O
24	int
]	O
=	O
{	O
"CONST_UNIVERSAL"	pointer
,	O
"CONST_PRIVATE"	pointer
,	O
"CONST_APPLICATION"	pointer
,	O
"CONST_EXPLICIT"	pointer
,	O
"CONST_IMPLICIT"	pointer
,	O
"CONST_TAG"	pointer
,	O
"CONST_OPTION"	pointer
,	O
"CONST_DEFAULT"	pointer
,	O
"CONST_TRUE"	pointer
,	O
"CONST_FALSE"	pointer
,	O
"CONST_LIST"	pointer
,	O
"CONST_MIN_MAX"	pointer
,	O
"CONST_1_PARAM"	pointer
,	O
"CONST_SIZE"	pointer
,	O
"CONST_DEFINED_BY"	pointer
,	O
"CONST_GENERALIZED"	pointer
,	O
"CONST_UTC"	pointer
,	O
NULL	O
,	O
"CONST_NOT_USED"	pointer
,	O
"CONST_SET"	pointer
,	O
"CONST_ASSIGN"	pointer
,	O
"CONST_DOWN"	pointer
,	O
"CONST_RIGHT"	pointer
,	O
NULL	O
}	O
;	O
int	O
main	function
(	O
void	O
)	O
{	O
struct	O
fuzz_elem	struct
e	pointer
;	O
printf	function
(	O
"const asn1_static_node tab[] = {\n"	pointer
)	O
;	O
while	O
(	O
fread	function
(	O
&	O
e	pointer
,	O
sizeof	O
(	O
e	O
)	O
,	O
1	int
,	O
stdin	pointer
)	O
==	O
1	int
)	O
{	O
e	function
.	O
name	pointer
[	O
sizeof	O
(	O
e	pointer
.	O
name	pointer
)	O
-	O
1	int
]	O
=	O
0	int
;	O
e	pointer
.	O
value	pointer
[	O
sizeof	O
(	O
e	pointer
.	O
value	pointer
)	O
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
e	pointer
.	O
name	pointer
,	O
"NULL"	int
)	O
)	O
printf	function
(	O
"  { \"%s\""	pointer
,	O
escape	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
e	pointer
.	O
name	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
"  { NULL"	pointer
)	O
;	O
if	O
(	O
e	int
.	O
type	enum
)	O
{	O
int	O
add	int
=	O
0	int
;	O
if	O
(	O
(	O
e	int
.	O
type	int
&	O
0xFF	int
)	O
==	O
17	int
)	O
{	O
printf	function
(	O
", ASN1_ETYPE_TIME"	pointer
)	O
;	O
add	int
=	O
1	int
;	O
}	O
for	O
(	O
int	O
i	int
=	O
8	int
;	O
i	int
<	O
32	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
e	int
.	O
type	int
&	O
(	O
1U	O
<<	O
i	int
)	O
)	O
&&	O
typename	array
[	O
i	int
-	O
8	int
]	O
)	O
{	O
printf	function
(	O
add	int
?	O
"|%s"	int
:	O
", %s"	pointer
,	O
typename	array
[	O
i	int
-	O
8	int
]	O
)	O
;	O
add	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
add	int
)	O
printf	function
(	O
", %u"	pointer
,	O
e	pointer
.	O
type	int
)	O
;	O
}	O
else	O
printf	function
(	O
", 0"	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
e	pointer
.	O
value	pointer
,	O
"NULL"	int
)	O
)	O
printf	function
(	O
", \"%s\" },\n"	pointer
,	O
escape	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
e	pointer
.	O
value	pointer
)	O
)	O
;	O
else	O
printf	function
(	O
", NULL },"	pointer
)	O
;	O
}	O
printf	function
(	O
"  { NULL, 0, NULL }\n"	pointer
)	O
;	O
printf	function
(	O
"};\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
*	O
jit_default_alloc_func	function
(	O
size_t	long
)	O
;	O
static	O
void	O
*	O
jit_default_realloc_func	function
(	O
void	O
*	O
,	O
size_t	long
)	O
;	O
static	O
void	O
jit_default_free_func	function
(	O
void	O
*	O
)	O
;	O
static	O
jit_alloc_func_ptr	pointer
jit_alloc_ptr	pointer
=	O
jit_default_alloc_func	pointer
;	O
static	O
jit_realloc_func_ptr	pointer
jit_realloc_ptr	pointer
=	O
jit_default_realloc_func	pointer
;	O
static	O
jit_free_func_ptr	pointer
jit_free_ptr	pointer
=	O
jit_default_free_func	pointer
;	O
jit_pointer_t	O
jit_memcpy	function
(	O
jit_pointer_t	pointer
dst	pointer
,	O
const	O
void	O
*	O
src	pointer
,	O
jit_word_t	long
size	long
)	O
{	O
if	O
(	O
size	int
)	O
return	O
(	O
memcpy	function
(	O
dst	pointer
,	O
src	pointer
,	O
size	int
)	O
)	O
;	O
return	O
(	O
dst	pointer
)	O
;	O
}	O
jit_pointer_t	O
jit_memmove	function
(	O
jit_pointer_t	pointer
dst	pointer
,	O
const	O
void	O
*	O
src	pointer
,	O
jit_word_t	long
size	long
)	O
{	O
if	O
(	O
size	long
)	O
return	O
(	O
memmove	function
(	O
dst	pointer
,	O
src	pointer
,	O
size	int
)	O
)	O
;	O
return	O
(	O
dst	pointer
)	O
;	O
}	O
void	O
jit_set_memory_functions	function
(	O
jit_alloc_func_ptr	pointer
alloc_ptr	pointer
,	O
jit_realloc_func_ptr	pointer
realloc_ptr	pointer
,	O
jit_free_func_ptr	pointer
free_ptr	pointer
)	O
{	O
if	O
(	O
alloc_ptr	pointer
==	O
NULL	O
)	O
alloc_ptr	pointer
=	O
jit_default_alloc_func	pointer
;	O
if	O
(	O
realloc_ptr	pointer
==	O
NULL	O
)	O
realloc_ptr	pointer
=	O
jit_default_realloc_func	pointer
;	O
if	O
(	O
free_ptr	pointer
==	O
NULL	O
)	O
free_ptr	pointer
=	O
jit_default_free_func	pointer
;	O
jit_alloc_ptr	pointer
=	O
alloc_ptr	pointer
;	O
jit_realloc_ptr	pointer
=	O
realloc_ptr	pointer
;	O
jit_free_ptr	pointer
=	O
free_ptr	pointer
;	O
}	O
void	O
jit_get_memory_functions	function
(	O
jit_alloc_func_ptr	struct
*	O
alloc_ptr	pointer
,	O
jit_realloc_func_ptr	struct
*	O
realloc_ptr	pointer
,	O
jit_free_func_ptr	struct
*	O
free_ptr	pointer
)	O
{	O
*	O
alloc_ptr	pointer
=	O
jit_alloc_ptr	pointer
;	O
*	O
realloc_ptr	pointer
=	O
jit_realloc_ptr	pointer
;	O
*	O
free_ptr	pointer
=	O
jit_free_ptr	pointer
;	O
}	O
void	O
jit_alloc	function
(	O
jit_pointer_t	struct
*	O
ptr	pointer
,	O
jit_word_t	long
size	long
)	O
{	O
*	O
ptr	pointer
=	O
(	O
*	O
jit_alloc_ptr	pointer
)	O
(	O
size	long
)	O
;	O
memset	function
(	O
*	O
ptr	pointer
,	O
0	int
,	O
size	int
)	O
;	O
}	O
void	O
jit_realloc	function
(	O
jit_pointer_t	struct
*	O
ptr	pointer
,	O
jit_word_t	long
old_size	long
,	O
jit_word_t	long
new_size	long
)	O
{	O
*	O
ptr	pointer
=	O
(	O
*	O
jit_realloc_ptr	pointer
)	O
(	O
*	O
ptr	pointer
,	O
new_size	long
)	O
;	O
if	O
(	O
old_size	int
<	O
new_size	long
)	O
memset	function
(	O
(	O
jit_int8_t	struct
*	O
)	O
*	O
ptr	pointer
+	O
old_size	int
,	O
0	int
,	O
new_size	long
-	O
old_size	int
)	O
;	O
}	O
void	O
jit_free	function
(	O
jit_pointer_t	struct
*	O
ptr	pointer
)	O
{	O
if	O
(	O
*	O
ptr	pointer
)	O
{	O
(	O
*	O
jit_free_ptr	pointer
)	O
(	O
*	O
ptr	pointer
)	O
;	O
*	O
ptr	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
*	O
jit_default_alloc_func	function
(	O
size_t	long
size	long
)	O
{	O
return	O
(	O
malloc	function
(	O
size	long
)	O
)	O
;	O
}	O
static	O
void	O
*	O
jit_default_realloc_func	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
)	O
{	O
return	O
(	O
realloc	function
(	O
ptr	pointer
,	O
size	long
)	O
)	O
;	O
}	O
static	O
void	O
jit_default_free_func	function
(	O
void	O
*	O
ptr	pointer
)	O
{	O
free	function
(	O
ptr	pointer
)	O
;	O
}	O
char	O
*	O
asnprintf	function
(	O
char	O
*	O
resultbuf	pointer
,	O
size_t	long
*	O
lengthp	pointer
,	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
char	O
*	O
result	pointer
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
result	pointer
=	O
vasnprintf	function
(	O
resultbuf	pointer
,	O
lengthp	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
return	O
result	pointer
;	O
}	O
char	O
*	O
last_component	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
const	O
*	O
base	pointer
=	O
name	pointer
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
char	O
const	O
*	O
p	pointer
;	O
bool	bool
saw_slash	bool
=	O
false	int
;	O
while	O
(	O
ISSLASH	O
(	O
*	O
base	pointer
)	O
)	O
base	pointer
++	O
;	O
for	O
(	O
p	pointer
=	O
base	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
ISSLASH	O
(	O
*	O
p	pointer
)	O
)	O
saw_slash	bool
=	O
true	int
;	O
else	O
if	O
(	O
saw_slash	bool
)	O
{	O
base	pointer
=	O
p	pointer
;	O
saw_slash	bool
=	O
false	int
;	O
}	O
}	O
return	O
(	O
char	O
*	O
)	O
base	pointer
;	O
}	O
size_t	long
base_len	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
size_t	long
len	long
;	O
size_t	long
prefix_len	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
for	O
(	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
1	int
<	O
len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
len	long
-	O
1	int
]	O
)	O
;	O
len	long
--	O
)	O
continue	O
;	O
if	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
len	long
==	O
1	int
&&	O
ISSLASH	O
(	O
name	pointer
[	O
0	int
]	O
)	O
&&	O
ISSLASH	O
(	O
name	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
name	pointer
[	O
2	int
]	O
)	O
return	O
2	int
;	O
if	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
prefix_len	long
&&	O
len	long
==	O
prefix_len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
prefix_len	long
]	O
)	O
)	O
return	O
prefix_len	long
+	O
1	int
;	O
return	O
len	long
;	O
}	O
char	O
*	O
base_name	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
const	O
*	O
base	pointer
=	O
last_component	function
(	O
name	pointer
)	O
;	O
size_t	long
length	long
;	O
if	O
(	O
!	O
*	O
base	pointer
)	O
return	O
xstrndup	function
(	O
name	pointer
,	O
base_len	function
(	O
name	pointer
)	O
)	O
;	O
length	long
=	O
base_len	function
(	O
base	pointer
)	O
;	O
if	O
(	O
ISSLASH	O
(	O
base	pointer
[	O
length	long
]	O
)	O
)	O
length	long
++	O
;	O
if	O
(	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
base	pointer
)	O
)	O
{	O
char	O
*	O
p	pointer
=	O
xmalloc	function
(	O
length	long
+	O
3	int
)	O
;	O
p	pointer
[	O
0	int
]	O
=	O
'.'	O
;	O
p	pointer
[	O
1	int
]	O
=	O
'/'	O
;	O
memcpy	function
(	O
p	pointer
+	O
2	int
,	O
base	pointer
,	O
length	long
)	O
;	O
p	pointer
[	O
length	long
+	O
2	int
]	O
=	O
'\0'	O
;	O
return	O
p	pointer
;	O
}	O
return	O
xstrndup	function
(	O
base	pointer
,	O
length	long
)	O
;	O
}	O
bool	bool
c_isascii	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
0x00	int
&&	O
c	int
<=	O
0x7f	int
)	O
;	O
}	O
bool	bool
c_isalnum	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'Z'	O
)	O
)	O
;	O
}	O
bool	bool
c_isalpha	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'Z'	O
)	O
;	O
}	O
bool	bool
c_isblank	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
==	O
' '	O
||	O
c	int
==	O
'\t'	O
)	O
;	O
}	O
bool	bool
c_iscntrl	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
&	O
~	O
0x1f	int
)	O
==	O
0	int
||	O
c	int
==	O
0x7f	int
)	O
;	O
}	O
bool	bool
c_isdigit	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
;	O
}	O
bool	bool
c_islower	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'a'	O
&&	O
c	int
<=	O
'z'	O
)	O
;	O
}	O
bool	bool
c_isgraph	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'!'	O
&&	O
c	int
<=	O
'~'	O
)	O
;	O
}	O
bool	bool
c_isprint	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
' '	O
&&	O
c	int
<=	O
'~'	O
)	O
;	O
}	O
bool	bool
c_ispunct	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
>=	O
'!'	O
&&	O
c	int
<=	O
'~'	O
)	O
&&	O
!	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'Z'	O
)	O
)	O
)	O
;	O
}	O
bool	bool
c_isspace	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
==	O
' '	O
||	O
c	int
==	O
'\t'	O
||	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
'\v'	O
||	O
c	int
==	O
'\f'	O
||	O
c	int
==	O
'\r'	O
)	O
;	O
}	O
bool	bool
c_isupper	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'A'	O
&&	O
c	int
<=	O
'Z'	O
)	O
;	O
}	O
bool	bool
c_isxdigit	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'F'	O
)	O
)	O
;	O
}	O
int	O
c_tolower	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'A'	O
&&	O
c	int
<=	O
'Z'	O
?	O
c	int
-	O
'A'	O
+	O
'a'	O
:	O
c	int
)	O
;	O
}	O
int	O
c_toupper	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'a'	O
&&	O
c	int
<=	O
'z'	O
?	O
c	int
-	O
'a'	O
+	O
'A'	O
:	O
c	int
)	O
;	O
}	O
int	O
close_stream	function
(	O
FILE	struct
*	O
stream	pointer
)	O
{	O
const	O
bool	bool
some_pending	bool
=	O
(	O
__fpending	function
(	O
stream	pointer
)	O
!=	O
0	int
)	O
;	O
const	O
bool	bool
prev_fail	bool
=	O
(	O
ferror	function
(	O
stream	pointer
)	O
!=	O
0	int
)	O
;	O
const	O
bool	bool
fclose_fail	bool
=	O
(	O
fclose	function
(	O
stream	pointer
)	O
!=	O
0	int
)	O
;	O
if	O
(	O
prev_fail	bool
||	O
(	O
fclose_fail	bool
&&	O
(	O
some_pending	bool
||	O
errno	O
!=	O
EBADF	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
fclose_fail	bool
)	O
errno	O
=	O
0	int
;	O
return	O
EOF	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
file_name	pointer
;	O
void	O
close_stdin_set_file_name	function
(	O
const	O
char	O
*	O
file	pointer
)	O
{	O
file_name	pointer
=	O
file	pointer
;	O
}	O
void	O
close_stdin	function
(	O
void	O
)	O
{	O
bool	bool
fail	bool
=	O
false	int
;	O
if	O
(	O
freadahead	function
(	O
stdin	pointer
)	O
>	O
0	int
)	O
{	O
if	O
(	O
fseeko	function
(	O
stdin	pointer
,	O
0	int
,	O
SEEK_CUR	int
)	O
==	O
0	int
&&	O
fflush	function
(	O
stdin	pointer
)	O
!=	O
0	int
)	O
fail	bool
=	O
true	int
;	O
}	O
if	O
(	O
close_stream	function
(	O
stdin	pointer
)	O
!=	O
0	int
)	O
fail	bool
=	O
true	int
;	O
if	O
(	O
fail	bool
)	O
{	O
char	O
const	O
*	O
close_error	pointer
=	O
_	O
(	O
"error closing file"	pointer
)	O
;	O
if	O
(	O
file_name	pointer
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s: %s"	pointer
,	O
quotearg_colon	function
(	O
file_name	pointer
)	O
,	O
close_error	pointer
)	O
;	O
else	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
close_error	pointer
)	O
;	O
}	O
close_stdout	function
(	O
)	O
;	O
if	O
(	O
fail	bool
)	O
_exit	function
(	O
exit_failure	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
file_name	pointer
;	O
void	O
close_stdout_set_file_name	function
(	O
const	O
char	O
*	O
file	pointer
)	O
{	O
file_name	pointer
=	O
file	pointer
;	O
}	O
static	O
bool	bool
ignore_EPIPE	bool
;	O
void	O
close_stdout_set_ignore_EPIPE	function
(	O
bool	bool
ignore	bool
)	O
{	O
ignore_EPIPE	bool
=	O
ignore	bool
;	O
}	O
void	O
close_stdout	function
(	O
void	O
)	O
{	O
if	O
(	O
close_stream	function
(	O
stdout	pointer
)	O
!=	O
0	int
&&	O
!	O
(	O
ignore_EPIPE	bool
&&	O
errno	O
==	O
EPIPE	int
)	O
)	O
{	O
char	O
const	O
*	O
write_error	pointer
=	O
_	O
(	O
"write error"	pointer
)	O
;	O
if	O
(	O
file_name	pointer
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s: %s"	pointer
,	O
quotearg_colon	function
(	O
file_name	pointer
)	O
,	O
write_error	pointer
)	O
;	O
else	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
write_error	pointer
)	O
;	O
_exit	function
(	O
exit_failure	int
)	O
;	O
}	O
if	O
(	O
close_stream	function
(	O
stderr	pointer
)	O
!=	O
0	int
)	O
_exit	function
(	O
exit_failure	int
)	O
;	O
}	O
char	O
*	O
dir_name	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
char	O
*	O
result	pointer
=	O
mdir_name	function
(	O
file	pointer
)	O
;	O
if	O
(	O
!	O
result	pointer
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
result	pointer
;	O
}	O
int	O
fseek	function
(	O
FILE	struct
*	O
fp	pointer
,	O
long	O
offset	long
,	O
int	O
whence	int
)	O
{	O
return	O
fseeko	function
(	O
fp	pointer
,	O
(	O
off_t	long
)	O
offset	long
,	O
whence	int
)	O
;	O
}	O
int	O
pipe_safer	function
(	O
int	O
fd	array
[	O
2	int
]	O
)	O
{	O
if	O
(	O
pipe	function
(	O
fd	array
)	O
==	O
0	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
fd	array
[	O
i	int
]	O
=	O
fd_safer	function
(	O
fd	array
[	O
i	int
]	O
)	O
;	O
if	O
(	O
fd	array
[	O
i	int
]	O
<	O
0	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
close	function
(	O
fd	array
[	O
1	int
-	O
i	int
]	O
)	O
;	O
errno	O
=	O
e	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
pipe2	function
(	O
int	O
fd	array
[	O
2	int
]	O
,	O
int	O
flags	int
)	O
{	O
int	O
tmp	array
[	O
2	int
]	O
;	O
tmp	array
[	O
0	int
]	O
=	O
fd	array
[	O
0	int
]	O
;	O
tmp	array
[	O
1	int
]	O
=	O
fd	array
[	O
1	int
]	O
;	O
{	O
static	O
int	O
have_pipe2_really	int
;	O
if	O
(	O
have_pipe2_really	int
>=	O
0	int
)	O
{	O
int	O
result	int
=	O
pipe2	function
(	O
fd	array
,	O
flags	int
)	O
;	O
if	O
(	O
!	O
(	O
result	int
<	O
0	int
&&	O
errno	O
==	O
ENOSYS	int
)	O
)	O
{	O
have_pipe2_really	int
=	O
1	int
;	O
return	O
result	int
;	O
}	O
have_pipe2_really	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
flags	int
&	O
~	O
(	O
O_CLOEXEC	O
|	O
O_NONBLOCK	int
|	O
O_BINARY	int
|	O
O_TEXT	int
)	O
)	O
!=	O
0	int
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pipe	function
(	O
fd	array
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
flags	int
&	O
O_NONBLOCK	int
)	O
{	O
int	O
fcntl_flags	int
;	O
if	O
(	O
(	O
fcntl_flags	int
=	O
fcntl	function
(	O
fd	array
[	O
1	int
]	O
,	O
F_GETFL	int
,	O
0	int
)	O
)	O
<	O
0	int
||	O
fcntl	function
(	O
fd	array
[	O
1	int
]	O
,	O
F_SETFL	int
,	O
fcntl_flags	int
|	O
O_NONBLOCK	int
)	O
==	O
-	O
1	int
||	O
(	O
fcntl_flags	int
=	O
fcntl	function
(	O
fd	array
[	O
0	int
]	O
,	O
F_GETFL	int
,	O
0	int
)	O
)	O
<	O
0	int
||	O
fcntl	function
(	O
fd	array
[	O
0	int
]	O
,	O
F_SETFL	int
,	O
fcntl_flags	int
|	O
O_NONBLOCK	int
)	O
==	O
-	O
1	int
)	O
goto	O
fail	O
;	O
}	O
if	O
(	O
flags	int
&	O
O_CLOEXEC	O
)	O
{	O
int	O
fcntl_flags	int
;	O
if	O
(	O
(	O
fcntl_flags	int
=	O
fcntl	function
(	O
fd	array
[	O
1	int
]	O
,	O
F_GETFD	int
,	O
0	int
)	O
)	O
<	O
0	int
||	O
fcntl	function
(	O
fd	array
[	O
1	int
]	O
,	O
F_SETFD	int
,	O
fcntl_flags	int
|	O
FD_CLOEXEC	int
)	O
==	O
-	O
1	int
||	O
(	O
fcntl_flags	int
=	O
fcntl	function
(	O
fd	array
[	O
0	int
]	O
,	O
F_GETFD	int
,	O
0	int
)	O
)	O
<	O
0	int
||	O
fcntl	function
(	O
fd	array
[	O
0	int
]	O
,	O
F_SETFD	int
,	O
fcntl_flags	int
|	O
FD_CLOEXEC	int
)	O
==	O
-	O
1	int
)	O
goto	O
fail	O
;	O
}	O
return	O
0	int
;	O
fail	O
:	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
close	function
(	O
fd	array
[	O
0	int
]	O
)	O
;	O
close	function
(	O
fd	array
[	O
1	int
]	O
)	O
;	O
fd	array
[	O
0	int
]	O
=	O
tmp	array
[	O
0	int
]	O
;	O
fd	array
[	O
1	int
]	O
=	O
tmp	array
[	O
1	int
]	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
const	O
char	O
*	O
program_name	pointer
=	O
NULL	O
;	O
void	O
set_program_name	function
(	O
const	O
char	O
*	O
argv0	pointer
)	O
{	O
const	O
char	O
*	O
slash	pointer
;	O
const	O
char	O
*	O
base	pointer
;	O
if	O
(	O
argv0	pointer
==	O
NULL	O
)	O
{	O
fputs	function
(	O
"A NULL argv[0] was passed through an exec system call.\n"	pointer
,	O
stderr	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
slash	pointer
=	O
strrchr	function
(	O
argv0	pointer
,	O
'/'	O
)	O
;	O
base	pointer
=	O
(	O
slash	pointer
!=	O
NULL	O
?	O
slash	pointer
+	O
1	int
:	O
argv0	pointer
)	O
;	O
if	O
(	O
base	pointer
-	O
argv0	pointer
>=	O
7	int
&&	O
strncmp	function
(	O
base	pointer
-	O
7	int
,	O
"/.libs/"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
{	O
argv0	pointer
=	O
base	pointer
;	O
if	O
(	O
strncmp	function
(	O
base	pointer
,	O
"lt-"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
{	O
argv0	pointer
=	O
base	pointer
+	O
3	int
;	O
program_invocation_short_name	pointer
=	O
(	O
char	O
*	O
)	O
argv0	pointer
;	O
}	O
}	O
program_name	pointer
=	O
argv0	pointer
;	O
program_invocation_name	pointer
=	O
(	O
char	O
*	O
)	O
argv0	pointer
;	O
}	O
enum	O
{	O
COPYRIGHT_YEAR	int
=	O
2013	int
}	O
;	O
void	O
version_etc_arn	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
char	O
*	O
command_name	pointer
,	O
const	O
char	O
*	O
package	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
const	O
char	O
*	O
const	O
*	O
authors	pointer
,	O
size_t	long
n_authors	long
)	O
{	O
if	O
(	O
command_name	pointer
)	O
fprintf	function
(	O
stream	pointer
,	O
"%s (%s) %s\n"	pointer
,	O
command_name	pointer
,	O
package	pointer
,	O
version	pointer
)	O
;	O
else	O
fprintf	function
(	O
stream	pointer
,	O
"%s %s\n"	pointer
,	O
package	pointer
,	O
version	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
version_etc_copyright	array
,	O
_	O
(	O
"(C)"	pointer
)	O
,	O
COPYRIGHT_YEAR	int
)	O
;	O
fputs	function
(	O
_	O
(	O
"\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n"	pointer
)	O
,	O
stream	pointer
)	O
;	O
switch	O
(	O
n_authors	long
)	O
{	O
case	O
0	int
:	O
abort	function
(	O
)	O
;	O
case	O
1	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
2	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
case	O
3	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
)	O
;	O
break	O
;	O
case	O
4	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\nand %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
)	O
;	O
break	O
;	O
case	O
5	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
)	O
;	O
break	O
;	O
case	O
6	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, %s, and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
,	O
authors	pointer
[	O
5	int
]	O
)	O
;	O
break	O
;	O
case	O
7	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, %s, %s, and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
,	O
authors	pointer
[	O
5	int
]	O
,	O
authors	pointer
[	O
6	int
]	O
)	O
;	O
break	O
;	O
case	O
8	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
,	O
authors	pointer
[	O
5	int
]	O
,	O
authors	pointer
[	O
6	int
]	O
,	O
authors	pointer
[	O
7	int
]	O
)	O
;	O
break	O
;	O
case	O
9	int
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
,	O
authors	pointer
[	O
5	int
]	O
,	O
authors	pointer
[	O
6	int
]	O
,	O
authors	pointer
[	O
7	int
]	O
,	O
authors	pointer
[	O
8	int
]	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stream	pointer
,	O
_	O
(	O
"Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n"	pointer
)	O
,	O
authors	pointer
[	O
0	int
]	O
,	O
authors	pointer
[	O
1	int
]	O
,	O
authors	pointer
[	O
2	int
]	O
,	O
authors	pointer
[	O
3	int
]	O
,	O
authors	pointer
[	O
4	int
]	O
,	O
authors	pointer
[	O
5	int
]	O
,	O
authors	pointer
[	O
6	int
]	O
,	O
authors	pointer
[	O
7	int
]	O
,	O
authors	pointer
[	O
8	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
void	O
version_etc_ar	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
char	O
*	O
command_name	pointer
,	O
const	O
char	O
*	O
package	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
const	O
char	O
*	O
const	O
*	O
authors	pointer
)	O
{	O
size_t	long
n_authors	long
;	O
for	O
(	O
n_authors	long
=	O
0	int
;	O
authors	pointer
[	O
n_authors	long
]	O
;	O
n_authors	long
++	O
)	O
;	O
version_etc_arn	function
(	O
stream	pointer
,	O
command_name	pointer
,	O
package	pointer
,	O
version	pointer
,	O
authors	pointer
,	O
n_authors	long
)	O
;	O
}	O
void	O
version_etc_va	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
char	O
*	O
command_name	pointer
,	O
const	O
char	O
*	O
package	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
va_list	array
authors	pointer
)	O
{	O
size_t	long
n_authors	long
;	O
const	O
char	O
*	O
authtab	array
[	O
10	int
]	O
;	O
for	O
(	O
n_authors	long
=	O
0	int
;	O
n_authors	long
<	O
10	int
&&	O
(	O
authtab	array
[	O
n_authors	long
]	O
=	O
va_arg	O
(	O
authors	pointer
,	O
const	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
;	O
n_authors	long
++	O
)	O
;	O
version_etc_arn	function
(	O
stream	pointer
,	O
command_name	pointer
,	O
package	pointer
,	O
version	pointer
,	O
authtab	array
,	O
n_authors	long
)	O
;	O
}	O
void	O
version_etc	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
char	O
*	O
command_name	pointer
,	O
const	O
char	O
*	O
package	pointer
,	O
const	O
char	O
*	O
version	pointer
,	O
...	O
)	O
{	O
va_list	array
authors	pointer
;	O
va_start	O
(	O
authors	pointer
,	O
version	pointer
)	O
;	O
version_etc_va	function
(	O
stream	pointer
,	O
command_name	pointer
,	O
package	pointer
,	O
version	pointer
,	O
authors	pointer
)	O
;	O
va_end	O
(	O
authors	pointer
)	O
;	O
}	O
void	O
emit_bug_reporting_address	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"\nReport bugs to: %s\n"	pointer
)	O
,	O
PACKAGE_BUGREPORT	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"%s home page: <%s>\n"	pointer
)	O
,	O
PACKAGE_NAME	pointer
,	O
PACKAGE_URL	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"General help using GNU software: <http://www.gnu.org/gethelp/>\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
int	O
count_only	int
;	O
char	O
*	O
sender_option	pointer
;	O
char	O
*	O
mailbox_name	pointer
;	O
static	O
struct	O
mu_option	struct
from_options	array
[	O
]	O
=	O
{	O
{	O
"count"	pointer
,	O
'c'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"just print a count of messages and exit"	pointer
)	O
,	O
mu_c_bool	int
,	O
&	O
count_only	int
}	O
,	O
{	O
"sender"	pointer
,	O
's'	O
,	O
N_	O
(	O
"ADDRESS"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"print only mail from addresses containing the supplied string"	pointer
)	O
,	O
mu_c_string	int
,	O
&	O
sender_option	int
}	O
,	O
{	O
"file"	pointer
,	O
'f'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"read mail from FILE"	pointer
)	O
,	O
mu_c_string	int
,	O
&	O
mailbox_name	int
}	O
,	O
{	O
"debug"	pointer
,	O
'd'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"enable debugging output"	pointer
)	O
,	O
mu_c_incr	int
,	O
&	O
frm_debug	int
}	O
,	O
MU_OPTION_END	O
}	O
,	O
*	O
options	array
[	O
]	O
=	O
{	O
from_options	pointer
,	O
NULL	O
}	O
;	O
static	O
struct	O
mu_cli_setup	struct
cli	struct
=	O
{	O
options	array
,	O
NULL	O
,	O
N_	O
(	O
"GNU from -- display from and subject."	pointer
)	O
,	O
N_	O
(	O
"[OPTIONS] [USER]"	pointer
)	O
,	O
}	O
;	O
static	O
char	O
*	O
capa	pointer
[	O
]	O
=	O
{	O
"debug"	pointer
,	O
"mailbox"	pointer
,	O
"locking"	pointer
,	O
NULL	O
}	O
;	O
static	O
int	O
from_select	function
(	O
size_t	long
index	function
,	O
mu_message_t	pointer
msg	pointer
)	O
{	O
if	O
(	O
count_only	pointer
)	O
return	O
0	int
;	O
if	O
(	O
sender_option	pointer
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
mu_header_t	pointer
hdr	pointer
=	O
NULL	O
;	O
char	O
*	O
sender	pointer
;	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
hdr	pointer
)	O
;	O
if	O
(	O
mu_header_aget_value_unfold	function
(	O
hdr	pointer
,	O
MU_HEADER_FROM	pointer
,	O
&	O
sender	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strstr	function
(	O
sender	pointer
,	O
sender_option	pointer
)	O
)	O
rc	int
=	O
1	int
;	O
free	function
(	O
sender	pointer
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
return	O
1	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
size_t	long
total	long
;	O
MU_APP_INIT_NLS	O
(	O
)	O
;	O
mu_register_all_mbox_formats	O
(	O
)	O
;	O
mu_auth_register_module	function
(	O
&	O
mu_auth_tls_module	struct
)	O
;	O
mu_cli	function
(	O
argc	long
,	O
argv	pointer
,	O
&	O
cli	struct
,	O
capa	pointer
,	O
NULL	O
,	O
&	O
argc	long
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
argc	long
>	O
1	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"too many arguments"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
argc	long
>	O
0	int
)	O
{	O
if	O
(	O
mailbox_name	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"both --from option and user name are specified"	pointer
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
mailbox_name	pointer
=	O
mu_alloc	function
(	O
strlen	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
+	O
2	int
)	O
;	O
mailbox_name	pointer
[	O
0	int
]	O
=	O
'%'	O
;	O
strcpy	function
(	O
mailbox_name	pointer
+	O
1	int
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
}	O
init_output	function
(	O
0	int
)	O
;	O
frm_scan	function
(	O
mailbox_name	pointer
,	O
from_select	pointer
,	O
&	O
total	long
)	O
;	O
if	O
(	O
count_only	int
)	O
{	O
mu_printf	function
(	O
ngettext	function
(	O
"There is %lu message in your incoming mailbox.\n"	pointer
,	O
"There are %lu messages in your incoming mailbox.\n"	pointer
,	O
total	long
)	O
,	O
(	O
unsigned	O
long	O
)	O
total	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
imap4d_close0	function
(	O
struct	O
imap4d_command	struct
*	O
command	pointer
,	O
imap4d_tokbuf_t	pointer
tok	pointer
,	O
int	O
expunge	int
)	O
{	O
const	O
char	O
*	O
msg	pointer
=	O
NULL	O
;	O
int	O
status	int
,	O
flags	int
;	O
if	O
(	O
imap4d_tokbuf_argc	function
(	O
tok	pointer
)	O
!=	O
2	int
)	O
return	O
io_completion_response	function
(	O
command	pointer
,	O
RESP_BAD	int
,	O
"Invalid arguments"	pointer
)	O
;	O
mu_mailbox_get_flags	function
(	O
mbox	pointer
,	O
&	O
flags	int
)	O
;	O
if	O
(	O
flags	int
&	O
MU_STREAM_WRITE	int
)	O
{	O
silent_expunge	pointer
=	O
expunge	int
;	O
imap4d_enter_critical	function
(	O
)	O
;	O
status	int
=	O
mu_mailbox_flush	function
(	O
mbox	pointer
,	O
expunge	int
)	O
;	O
imap4d_leave_critical	function
(	O
)	O
;	O
silent_expunge	int
=	O
0	int
;	O
if	O
(	O
status	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_mailbox_flush"	pointer
,	O
NULL	O
,	O
status	int
)	O
;	O
msg	pointer
=	O
"flushing mailbox failed"	pointer
;	O
}	O
}	O
imap4d_enter_critical	function
(	O
)	O
;	O
status	int
=	O
mu_mailbox_close	function
(	O
mbox	pointer
)	O
;	O
imap4d_leave_critical	function
(	O
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_mailbox_close"	pointer
,	O
NULL	O
,	O
status	int
)	O
;	O
msg	pointer
=	O
"closing mailbox failed"	pointer
;	O
}	O
manlock_unlock	function
(	O
mbox	pointer
)	O
;	O
mu_mailbox_destroy	function
(	O
&	O
mbox	pointer
)	O
;	O
if	O
(	O
msg	pointer
)	O
return	O
io_completion_response	function
(	O
command	pointer
,	O
RESP_NO	int
,	O
"%s"	pointer
,	O
msg	pointer
)	O
;	O
return	O
io_completion_response	function
(	O
command	pointer
,	O
RESP_OK	int
,	O
"Completed"	pointer
)	O
;	O
}	O
int	O
imap4d_close	function
(	O
struct	O
imap4d_session	struct
*	O
session	pointer
,	O
struct	O
imap4d_command	struct
*	O
command	pointer
,	O
imap4d_tokbuf_t	pointer
tok	pointer
)	O
{	O
return	O
imap4d_close0	function
(	O
command	pointer
,	O
tok	pointer
,	O
1	int
)	O
;	O
}	O
int	O
imap4d_unselect	function
(	O
struct	O
imap4d_session	struct
*	O
session	pointer
,	O
struct	O
imap4d_command	struct
*	O
command	pointer
,	O
imap4d_tokbuf_t	pointer
tok	pointer
)	O
{	O
return	O
imap4d_close0	function
(	O
command	pointer
,	O
tok	pointer
,	O
0	int
)	O
;	O
}	O
static	O
mu_stream_t	pointer
base64stream	function
(	O
int	O
flg	int
)	O
{	O
mu_stream_t	pointer
flt	pointer
,	O
str	pointer
;	O
int	O
mode	int
;	O
switch	O
(	O
flg	int
)	O
{	O
case	O
MU_STREAM_READ	int
:	O
mode	int
=	O
MU_FILTER_DECODE	int
;	O
str	pointer
=	O
mu_strin	pointer
;	O
break	O
;	O
case	O
MU_STREAM_WRITE	int
:	O
mode	int
=	O
MU_FILTER_ENCODE	int
;	O
str	pointer
=	O
mu_strout	pointer
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
MU_ASSERT	O
(	O
mu_filter_create	function
(	O
&	O
flt	pointer
,	O
str	pointer
,	O
"base64"	pointer
,	O
mode	int
,	O
flg	pointer
)	O
)	O
;	O
return	O
flt	pointer
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_stream_t	pointer
flt	pointer
,	O
input	pointer
,	O
output	pointer
;	O
char	O
const	O
*	O
iargv	array
[	O
]	O
=	O
{	O
"iconv"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
assert	O
(	O
argc	int
==	O
3	int
)	O
;	O
iargv	array
[	O
1	int
]	O
=	O
argv	pointer
[	O
1	int
]	O
;	O
iargv	array
[	O
2	int
]	O
=	O
argv	pointer
[	O
2	int
]	O
;	O
mu_stdstream_setup	function
(	O
MU_STDSTREAM_RESET_NONE	int
)	O
;	O
input	pointer
=	O
base64stream	function
(	O
MU_STREAM_READ	int
)	O
;	O
output	pointer
=	O
base64stream	function
(	O
MU_STREAM_WRITE	int
)	O
;	O
MU_ASSERT	O
(	O
mu_filter_chain_create	function
(	O
&	O
flt	pointer
,	O
input	pointer
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_READ	int
,	O
MU_ARRAY_SIZE	O
(	O
iargv	pointer
)	O
-	O
1	int
,	O
(	O
char	O
*	O
*	O
)	O
iargv	pointer
)	O
)	O
;	O
mu_stream_unref	function
(	O
input	pointer
)	O
;	O
MU_ASSERT	O
(	O
mu_stream_copy	function
(	O
output	pointer
,	O
flt	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
flt	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
output	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_stream_format_address	function
(	O
mu_stream_t	pointer
str	pointer
,	O
mu_address_t	pointer
addr	int
)	O
{	O
int	O
comma	int
=	O
0	int
;	O
for	O
(	O
;	O
addr	int
;	O
addr	pointer
=	O
addr	pointer
->	O
next	pointer
)	O
{	O
mu_validate_email	function
(	O
addr	pointer
)	O
;	O
if	O
(	O
addr	pointer
->	O
email	pointer
)	O
{	O
int	O
space	int
=	O
0	int
;	O
if	O
(	O
comma	int
)	O
mu_stream_write	function
(	O
str	pointer
,	O
","	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
addr	pointer
->	O
personal	pointer
)	O
{	O
mu_stream_printf	function
(	O
str	pointer
,	O
"\"%s\""	pointer
,	O
addr	pointer
->	O
personal	pointer
)	O
;	O
space	int
++	O
;	O
}	O
if	O
(	O
addr	pointer
->	O
comments	pointer
)	O
{	O
if	O
(	O
space	int
)	O
mu_stream_write	function
(	O
str	pointer
,	O
" "	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
mu_stream_printf	function
(	O
str	pointer
,	O
"(%s)"	pointer
,	O
addr	pointer
->	O
comments	pointer
)	O
;	O
space	int
++	O
;	O
}	O
if	O
(	O
space	int
)	O
mu_stream_write	function
(	O
str	pointer
,	O
" "	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
mu_stream_printf	function
(	O
str	pointer
,	O
"<%s>"	pointer
,	O
addr	pointer
->	O
email	pointer
)	O
;	O
comma	int
++	O
;	O
}	O
}	O
return	O
mu_stream_err	function
(	O
str	pointer
)	O
?	O
mu_stream_last_error	function
(	O
str	pointer
)	O
:	O
0	int
;	O
}	O
int	O
mu_argcv_join	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
char	O
*	O
delim	pointer
,	O
enum	O
mu_argcv_escape	enum
esc	enum
,	O
char	O
*	O
*	O
pstring	pointer
)	O
{	O
size_t	long
i	long
,	O
j	int
,	O
len	int
;	O
char	O
*	O
buffer	pointer
;	O
size_t	long
delimlen	long
=	O
strlen	function
(	O
delim	pointer
)	O
;	O
int	O
quote_hex	int
=	O
0	int
;	O
if	O
(	O
pstring	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
buffer	pointer
=	O
malloc	function
(	O
1	int
)	O
;	O
if	O
(	O
buffer	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
*	O
buffer	pointer
=	O
'\0'	O
;	O
for	O
(	O
len	long
=	O
i	long
=	O
j	long
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
int	O
quote	int
;	O
int	O
toklen	int
;	O
switch	O
(	O
esc	int
)	O
{	O
case	O
mu_argcv_escape_no	int
:	O
toklen	int
=	O
strlen	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
quote	int
=	O
0	int
;	O
break	O
;	O
case	O
mu_argcv_escape_c	int
:	O
toklen	pointer
=	O
mu_wordsplit_c_quoted_length	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
quote_hex	pointer
,	O
&	O
quote	char
)	O
;	O
break	O
;	O
default	O
:	O
return	O
EINVAL	int
;	O
}	O
len	int
+=	O
toklen	int
+	O
delimlen	int
;	O
if	O
(	O
quote	pointer
)	O
len	long
+=	O
2	int
;	O
buffer	pointer
=	O
realloc	function
(	O
buffer	pointer
,	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
buffer	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
if	O
(	O
i	int
!=	O
0	int
)	O
{	O
memcpy	function
(	O
buffer	pointer
+	O
j	int
,	O
delim	int
,	O
delimlen	int
)	O
;	O
j	int
+=	O
delimlen	int
;	O
}	O
if	O
(	O
quote	pointer
)	O
buffer	pointer
[	O
j	int
++	O
]	O
=	O
'"'	O
;	O
switch	O
(	O
esc	int
)	O
{	O
case	O
mu_argcv_escape_no	int
:	O
memcpy	function
(	O
buffer	pointer
+	O
j	int
,	O
argv	pointer
[	O
i	int
]	O
,	O
toklen	pointer
)	O
;	O
break	O
;	O
case	O
mu_argcv_escape_c	int
:	O
mu_wordsplit_c_quote_copy	function
(	O
buffer	pointer
+	O
j	int
,	O
argv	pointer
[	O
i	int
]	O
,	O
quote_hex	pointer
)	O
;	O
break	O
;	O
}	O
j	int
+=	O
toklen	int
;	O
if	O
(	O
quote	pointer
)	O
buffer	pointer
[	O
j	int
++	O
]	O
=	O
'"'	O
;	O
}	O
buffer	pointer
[	O
j	int
]	O
=	O
0	int
;	O
*	O
pstring	pointer
=	O
buffer	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_argcv_string	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
char	O
*	O
*	O
pstring	pointer
)	O
{	O
return	O
mu_argcv_join	function
(	O
argc	int
,	O
argv	pointer
,	O
" "	pointer
,	O
mu_argcv_escape_c	pointer
,	O
pstring	pointer
)	O
;	O
}	O
static	O
int	O
content_type_parse	function
(	O
const	O
char	O
*	O
input	pointer
,	O
const	O
char	O
*	O
charset	pointer
,	O
mu_content_type_t	pointer
ct	pointer
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
value	pointer
,	O
*	O
p	pointer
;	O
rc	int
=	O
mu_mime_header_parse	function
(	O
input	pointer
,	O
charset	pointer
,	O
&	O
value	pointer
,	O
&	O
ct	pointer
->	O
param	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
p	pointer
=	O
strchr	function
(	O
value	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
size_t	long
len	int
=	O
p	pointer
-	O
value	pointer
;	O
ct	pointer
->	O
type	pointer
=	O
malloc	function
(	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
ct	pointer
->	O
type	int
)	O
{	O
rc	int
=	O
errno	O
;	O
free	function
(	O
value	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
memcpy	function
(	O
ct	pointer
->	O
type	pointer
,	O
value	pointer
,	O
len	int
)	O
;	O
ct	pointer
->	O
type	pointer
[	O
len	int
]	O
=	O
0	int
;	O
ct	pointer
->	O
subtype	pointer
=	O
strdup	function
(	O
p	pointer
+	O
1	int
)	O
;	O
if	O
(	O
!	O
ct	pointer
->	O
subtype	pointer
)	O
{	O
rc	int
=	O
errno	O
;	O
free	function
(	O
value	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
else	O
{	O
ct	pointer
->	O
type	int
=	O
value	int
;	O
ct	pointer
->	O
subtype	pointer
=	O
NULL	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_content_type_parse	function
(	O
const	O
char	O
*	O
input	pointer
,	O
const	O
char	O
*	O
charset	pointer
,	O
mu_content_type_t	pointer
*	O
retct	pointer
)	O
{	O
int	O
rc	int
;	O
mu_content_type_t	pointer
ct	pointer
;	O
if	O
(	O
!	O
input	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
retct	pointer
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
ct	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
ct	pointer
)	O
)	O
;	O
if	O
(	O
!	O
ct	pointer
)	O
return	O
errno	O
;	O
rc	int
=	O
content_type_parse	function
(	O
input	pointer
,	O
charset	pointer
,	O
ct	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_content_type_destroy	function
(	O
&	O
ct	pointer
)	O
;	O
else	O
*	O
retct	pointer
=	O
ct	pointer
;	O
return	O
rc	int
;	O
}	O
void	O
mu_content_type_destroy	function
(	O
mu_content_type_t	pointer
*	O
pptr	pointer
)	O
{	O
if	O
(	O
pptr	pointer
&&	O
*	O
pptr	pointer
)	O
{	O
mu_content_type_t	pointer
ct	pointer
=	O
*	O
pptr	pointer
;	O
free	function
(	O
ct	pointer
->	O
type	pointer
)	O
;	O
free	function
(	O
ct	pointer
->	O
subtype	pointer
)	O
;	O
free	function
(	O
ct	pointer
->	O
trailer	pointer
)	O
;	O
mu_assoc_destroy	function
(	O
&	O
ct	pointer
->	O
param	pointer
)	O
;	O
free	function
(	O
ct	pointer
)	O
;	O
*	O
pptr	pointer
=	O
NULL	O
;	O
}	O
}	O
char	O
*	O
mu_get_homedir	function
(	O
void	O
)	O
{	O
char	O
*	O
homedir	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
homedir	pointer
)	O
homedir	pointer
=	O
strdup	function
(	O
homedir	pointer
)	O
;	O
else	O
{	O
struct	O
mu_auth_data	struct
*	O
auth	pointer
=	O
mu_get_auth_by_uid	function
(	O
geteuid	function
(	O
)	O
)	O
;	O
if	O
(	O
!	O
auth	pointer
)	O
return	O
NULL	O
;	O
homedir	pointer
=	O
strdup	function
(	O
auth	pointer
->	O
dir	pointer
)	O
;	O
mu_auth_data_free	function
(	O
auth	pointer
)	O
;	O
}	O
return	O
homedir	pointer
;	O
}	O
char	O
*	O
mu_get_full_path	function
(	O
const	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
file	pointer
)	O
p	pointer
=	O
mu_getcwd	function
(	O
)	O
;	O
else	O
if	O
(	O
*	O
file	pointer
!=	O
'/'	O
)	O
{	O
char	O
*	O
cwd	pointer
=	O
mu_getcwd	function
(	O
)	O
;	O
if	O
(	O
cwd	pointer
)	O
{	O
p	pointer
=	O
mu_make_file_name	O
(	O
cwd	pointer
,	O
file	pointer
)	O
;	O
free	function
(	O
cwd	pointer
)	O
;	O
}	O
}	O
else	O
p	pointer
=	O
strdup	function
(	O
file	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
char	O
*	O
mu_normalize_path	function
(	O
char	O
*	O
path	pointer
)	O
{	O
int	O
len	int
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
!	O
path	pointer
)	O
return	O
path	pointer
;	O
len	int
=	O
strlen	function
(	O
path	pointer
)	O
;	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
path	pointer
;	O
if	O
(	O
len	int
&&	O
path	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'/'	O
)	O
path	pointer
[	O
len	int
-	O
1	int
]	O
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
strchr	function
(	O
path	pointer
,	O
'.'	O
)	O
;	O
p	pointer
;	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
'.'	O
)	O
)	O
{	O
if	O
(	O
p	pointer
>	O
path	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
'/'	O
)	O
{	O
if	O
(	O
p	pointer
[	O
1	int
]	O
==	O
'.'	O
&&	O
(	O
p	pointer
[	O
2	int
]	O
==	O
0	int
||	O
p	pointer
[	O
2	int
]	O
==	O
'/'	O
)	O
)	O
{	O
char	O
*	O
q	pointer
,	O
*	O
s	pointer
;	O
for	O
(	O
q	pointer
=	O
p	pointer
-	O
2	int
;	O
*	O
q	pointer
!=	O
'/'	O
&&	O
q	pointer
>=	O
path	pointer
;	O
q	int
--	O
)	O
;	O
if	O
(	O
q	pointer
<	O
path	pointer
)	O
break	O
;	O
s	pointer
=	O
p	pointer
+	O
2	int
;	O
p	pointer
=	O
q	pointer
;	O
while	O
(	O
(	O
*	O
q	pointer
++	O
=	O
*	O
s	pointer
++	O
)	O
)	O
;	O
continue	O
;	O
}	O
}	O
p	pointer
++	O
;	O
}	O
if	O
(	O
path	pointer
[	O
0	int
]	O
==	O
0	int
)	O
{	O
path	pointer
[	O
0	int
]	O
=	O
'/'	O
;	O
path	pointer
[	O
1	int
]	O
=	O
0	int
;	O
}	O
return	O
path	pointer
;	O
}	O
char	O
*	O
mu_expand_path_pattern	function
(	O
const	O
char	O
*	O
pattern	pointer
,	O
const	O
char	O
*	O
username	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
q	pointer
;	O
char	O
*	O
path	pointer
;	O
size_t	long
len	long
=	O
0	int
;	O
struct	O
mu_auth_data	struct
*	O
auth	pointer
=	O
NULL	O
;	O
for	O
(	O
p	pointer
=	O
pattern	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'~'	O
)	O
{	O
if	O
(	O
!	O
auth	pointer
)	O
{	O
auth	pointer
=	O
mu_get_auth_by_name	function
(	O
username	pointer
)	O
;	O
if	O
(	O
!	O
auth	pointer
)	O
return	O
NULL	O
;	O
}	O
len	long
+=	O
strlen	function
(	O
auth	pointer
->	O
dir	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'%'	O
)	O
switch	O
(	O
*	O
++	O
p	pointer
)	O
{	O
case	O
'u'	O
:	O
len	long
+=	O
strlen	function
(	O
username	pointer
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
if	O
(	O
!	O
auth	pointer
)	O
{	O
auth	pointer
=	O
mu_get_auth_by_name	function
(	O
username	pointer
)	O
;	O
if	O
(	O
!	O
auth	pointer
)	O
return	O
NULL	O
;	O
}	O
len	long
+=	O
strlen	function
(	O
auth	pointer
->	O
dir	pointer
)	O
;	O
break	O
;	O
case	O
'%'	O
:	O
len	long
++	O
;	O
break	O
;	O
default	O
:	O
len	long
+=	O
2	int
;	O
}	O
else	O
len	long
++	O
;	O
}	O
path	pointer
=	O
malloc	function
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
path	pointer
)	O
return	O
NULL	O
;	O
p	pointer
=	O
pattern	pointer
;	O
q	pointer
=	O
path	pointer
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
size_t	long
off	long
=	O
strcspn	function
(	O
p	pointer
,	O
"~%"	pointer
)	O
;	O
memcpy	function
(	O
q	pointer
,	O
p	pointer
,	O
off	long
)	O
;	O
q	pointer
+=	O
off	long
;	O
p	pointer
+=	O
off	long
;	O
if	O
(	O
*	O
p	pointer
==	O
'~'	O
)	O
{	O
strcpy	function
(	O
q	pointer
,	O
auth	pointer
->	O
dir	pointer
)	O
;	O
q	pointer
+=	O
strlen	function
(	O
auth	pointer
->	O
dir	pointer
)	O
;	O
p	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'%'	O
)	O
{	O
switch	O
(	O
*	O
++	O
p	pointer
)	O
{	O
case	O
'u'	O
:	O
strcpy	function
(	O
q	pointer
,	O
username	pointer
)	O
;	O
q	pointer
+=	O
strlen	function
(	O
username	pointer
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
strcpy	function
(	O
q	pointer
,	O
auth	pointer
->	O
dir	pointer
)	O
;	O
q	pointer
+=	O
strlen	function
(	O
auth	pointer
->	O
dir	pointer
)	O
;	O
break	O
;	O
case	O
'%'	O
:	O
*	O
q	pointer
++	O
=	O
'%'	O
;	O
break	O
;	O
default	O
:	O
*	O
q	pointer
++	O
=	O
'%'	O
;	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
;	O
}	O
p	pointer
++	O
;	O
}	O
}	O
*	O
q	pointer
=	O
0	int
;	O
if	O
(	O
auth	pointer
)	O
mu_auth_data_free	function
(	O
auth	pointer
)	O
;	O
return	O
path	pointer
;	O
}	O
int	O
mu_file_safety_compose	function
(	O
int	O
*	O
res	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
defval	int
)	O
{	O
int	O
negate	int
=	O
0	int
;	O
int	O
val	int
;	O
if	O
(	O
*	O
name	pointer
==	O
'-'	O
)	O
{	O
negate	long
=	O
1	int
;	O
name	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
name	pointer
==	O
'+'	O
)	O
name	pointer
++	O
;	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
"none"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
res	pointer
=	O
negate	long
?	O
MU_FILE_SAFETY_ALL	O
:	O
MU_FILE_SAFETY_NONE	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
"all"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
res	pointer
=	O
negate	long
?	O
MU_FILE_SAFETY_NONE	int
:	O
MU_FILE_SAFETY_ALL	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
"default"	pointer
)	O
==	O
0	int
)	O
val	pointer
=	O
defval	int
;	O
else	O
if	O
(	O
mu_file_safety_name_to_code	function
(	O
name	pointer
,	O
&	O
val	pointer
)	O
)	O
return	O
MU_ERR_NOENT	O
;	O
if	O
(	O
negate	long
)	O
*	O
res	pointer
&=	O
~	O
val	int
;	O
else	O
*	O
res	pointer
|=	O
val	double
;	O
return	O
0	int
;	O
}	O
int	O
mu_getmaxfd	function
(	O
)	O
{	O
return	O
__getmaxfd	function
(	O
)	O
;	O
}	O
int	O
mu_getpass	function
(	O
mu_stream_t	pointer
in	pointer
,	O
mu_stream_t	pointer
out	pointer
,	O
const	O
char	O
*	O
prompt	pointer
,	O
char	O
*	O
*	O
passptr	pointer
)	O
{	O
int	O
status	int
;	O
int	O
echo_state	int
=	O
0	int
;	O
size_t	long
size	long
=	O
0	int
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
status	int
=	O
mu_stream_write	function
(	O
out	pointer
,	O
prompt	pointer
,	O
strlen	function
(	O
prompt	pointer
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
mu_stream_flush	function
(	O
out	pointer
)	O
;	O
status	int
=	O
mu_stream_ioctl	function
(	O
in	pointer
,	O
MU_IOCTL_ECHO	int
,	O
MU_IOCTL_OP_SET	int
,	O
&	O
echo_state	struct
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
echo_state	int
=	O
1	int
;	O
status	int
=	O
mu_stream_getline	function
(	O
in	pointer
,	O
&	O
buf	pointer
,	O
&	O
size	long
,	O
NULL	O
)	O
;	O
if	O
(	O
echo_state	pointer
)	O
{	O
mu_stream_ioctl	function
(	O
in	pointer
,	O
MU_IOCTL_ECHO	int
,	O
MU_IOCTL_OP_SET	int
,	O
&	O
echo_state	struct
)	O
;	O
mu_stream_write	function
(	O
out	pointer
,	O
"\n"	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
mu_rtrim_cset	function
(	O
buf	pointer
,	O
"\n"	pointer
)	O
;	O
*	O
passptr	pointer
=	O
buf	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
parse_character_class	function
(	O
unsigned	O
char	O
const	O
*	O
str	pointer
,	O
mu_opool_t	pointer
pool	pointer
,	O
unsigned	O
char	O
const	O
*	O
*	O
endp	pointer
)	O
{	O
unsigned	O
char	O
const	O
*	O
cur	pointer
;	O
cur	pointer
=	O
str	pointer
+	O
1	int
;	O
if	O
(	O
*	O
cur	pointer
==	O
'!'	O
)	O
cur	pointer
++	O
;	O
if	O
(	O
*	O
cur	pointer
==	O
']'	O
)	O
cur	pointer
++	O
;	O
while	O
(	O
*	O
cur	pointer
&&	O
*	O
cur	pointer
!=	O
']'	O
)	O
{	O
int	O
c	int
=	O
*	O
cur	pointer
++	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
cur	pointer
++	O
;	O
else	O
if	O
(	O
c	int
>=	O
0xc2	int
)	O
{	O
size_t	long
len	long
;	O
if	O
(	O
c	int
<	O
0xe0	int
)	O
len	int
=	O
1	int
;	O
else	O
if	O
(	O
c	int
<	O
0xf0	int
)	O
len	int
=	O
2	int
;	O
else	O
if	O
(	O
c	int
<	O
0xf8	int
)	O
len	int
=	O
3	int
;	O
else	O
continue	O
;	O
while	O
(	O
len	long
--	O
&&	O
*	O
cur	pointer
)	O
cur	pointer
++	O
;	O
}	O
}	O
if	O
(	O
*	O
cur	pointer
==	O
']'	O
)	O
{	O
mu_opool_append_char	function
(	O
pool	array
,	O
*	O
str	pointer
)	O
;	O
str	pointer
++	O
;	O
if	O
(	O
*	O
str	pointer
==	O
'!'	O
)	O
{	O
mu_opool_append_char	function
(	O
pool	pointer
,	O
'^'	O
)	O
;	O
str	pointer
++	O
;	O
}	O
while	O
(	O
str	pointer
<	O
cur	pointer
)	O
{	O
if	O
(	O
*	O
str	pointer
==	O
'['	O
)	O
mu_opool_append_char	function
(	O
pool	pointer
,	O
'\\'	O
)	O
;	O
mu_opool_append_char	function
(	O
pool	pointer
,	O
*	O
str	pointer
)	O
;	O
str	pointer
++	O
;	O
}	O
mu_opool_append_char	function
(	O
pool	array
,	O
']'	O
)	O
;	O
*	O
endp	pointer
=	O
cur	pointer
+	O
1	int
;	O
}	O
else	O
{	O
mu_opool_append_char	function
(	O
pool	array
,	O
'\\'	O
)	O
;	O
mu_opool_append_char	function
(	O
pool	pointer
,	O
*	O
str	pointer
)	O
;	O
str	pointer
++	O
;	O
*	O
endp	pointer
=	O
str	pointer
;	O
}	O
}	O
int	O
mu_glob_to_regex_opool	function
(	O
char	O
const	O
*	O
pattern	pointer
,	O
mu_opool_t	pointer
pool	array
,	O
int	O
flags	int
)	O
{	O
unsigned	O
char	O
const	O
*	O
str	pointer
=	O
(	O
unsigned	O
char	O
const	O
*	O
)	O
pattern	pointer
;	O
mu_nonlocal_jmp_t	pointer
jmp	pointer
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
MU_GLOBF_SUB	int
)	O
)	O
flags	int
|=	O
MU_GLOBF_COLLAPSE	int
;	O
mu_opool_setup_nonlocal_jump	function
(	O
pool	array
,	O
jmp	pointer
)	O
;	O
while	O
(	O
*	O
str	pointer
)	O
{	O
int	O
c	int
=	O
*	O
str	pointer
++	O
;	O
if	O
(	O
c	int
<	O
0x80	int
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\\'	O
:	O
mu_opool_append_char	function
(	O
pool	array
,	O
'\\'	O
)	O
;	O
if	O
(	O
*	O
str	pointer
&&	O
strchr	function
(	O
"?*["	pointer
,	O
*	O
str	pointer
)	O
)	O
{	O
mu_opool_append_char	function
(	O
pool	pointer
,	O
*	O
str	pointer
)	O
;	O
str	pointer
++	O
;	O
}	O
else	O
mu_opool_append_char	function
(	O
pool	array
,	O
'\\'	O
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
if	O
(	O
flags	int
&	O
MU_GLOBF_SUB	int
)	O
mu_opool_append_char	function
(	O
pool	array
,	O
'('	O
)	O
;	O
mu_opool_append_char	function
(	O
pool	array
,	O
'.'	O
)	O
;	O
if	O
(	O
flags	int
&	O
MU_GLOBF_SUB	int
)	O
mu_opool_append_char	function
(	O
pool	array
,	O
')'	O
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
if	O
(	O
flags	int
&	O
MU_GLOBF_COLLAPSE	int
)	O
{	O
while	O
(	O
*	O
str	pointer
==	O
'*'	O
)	O
str	pointer
++	O
;	O
}	O
if	O
(	O
flags	int
&	O
MU_GLOBF_SUB	int
)	O
{	O
while	O
(	O
*	O
str	pointer
==	O
'*'	O
)	O
{	O
mu_opool_append	function
(	O
pool	array
,	O
"()"	int
,	O
2	int
)	O
;	O
str	pointer
++	O
;	O
}	O
mu_opool_append_char	function
(	O
pool	array
,	O
'('	O
)	O
;	O
mu_opool_append	function
(	O
pool	array
,	O
".*"	int
,	O
2	int
)	O
;	O
mu_opool_append_char	function
(	O
pool	array
,	O
')'	O
)	O
;	O
}	O
else	O
mu_opool_append	function
(	O
pool	array
,	O
".*"	pointer
,	O
2	int
)	O
;	O
break	O
;	O
case	O
'['	O
:	O
parse_character_class	function
(	O
str	pointer
-	O
1	int
,	O
pool	int
,	O
&	O
str	int
)	O
;	O
break	O
;	O
case	O
'('	O
:	O
case	O
')'	O
:	O
case	O
'{'	O
:	O
case	O
'}'	O
:	O
case	O
'^'	O
:	O
case	O
'$'	O
:	O
case	O
']'	O
:	O
case	O
'|'	O
:	O
case	O
'.'	O
:	O
mu_opool_append_char	function
(	O
pool	array
,	O
'\\'	O
)	O
;	O
mu_opool_append_char	function
(	O
pool	array
,	O
c	int
)	O
;	O
break	O
;	O
default	O
:	O
mu_opool_append_char	function
(	O
pool	array
,	O
c	int
)	O
;	O
}	O
}	O
else	O
{	O
mu_opool_append_char	function
(	O
pool	array
,	O
c	int
)	O
;	O
if	O
(	O
c	int
>=	O
0xc2	int
)	O
{	O
size_t	long
len	int
;	O
if	O
(	O
c	int
<	O
0xe0	int
)	O
len	int
=	O
1	int
;	O
else	O
if	O
(	O
c	int
<	O
0xf0	int
)	O
len	int
=	O
2	int
;	O
else	O
if	O
(	O
c	int
<	O
0xf8	int
)	O
len	int
=	O
3	int
;	O
else	O
continue	O
;	O
for	O
(	O
;	O
len	long
--	O
&&	O
*	O
str	pointer
;	O
str	pointer
++	O
)	O
mu_opool_append_char	function
(	O
pool	pointer
,	O
*	O
str	pointer
)	O
;	O
}	O
}	O
}	O
mu_opool_clrjmp	function
(	O
pool	array
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_glob_to_regex	function
(	O
char	O
*	O
*	O
rxstr	pointer
,	O
char	O
const	O
*	O
pattern	pointer
,	O
int	O
flags	int
)	O
{	O
mu_opool_t	pointer
pool	pointer
;	O
int	O
rc	int
;	O
mu_nonlocal_jmp_t	pointer
jmp	pointer
;	O
rc	int
=	O
mu_opool_create	function
(	O
&	O
pool	pointer
,	O
MU_OPOOL_DEFAULT	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_opool_setup_nonlocal_jump	function
(	O
pool	pointer
,	O
jmp	int
)	O
;	O
mu_opool_append_char	function
(	O
pool	pointer
,	O
'^'	O
)	O
;	O
rc	int
=	O
mu_glob_to_regex_opool	function
(	O
pattern	pointer
,	O
pool	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_opool_append_char	function
(	O
pool	array
,	O
'$'	O
)	O
;	O
mu_opool_append_char	function
(	O
pool	pointer
,	O
0	int
)	O
;	O
*	O
rxstr	pointer
=	O
mu_opool_detach	function
(	O
pool	pointer
,	O
NULL	O
)	O
;	O
}	O
mu_opool_clrjmp	function
(	O
pool	pointer
)	O
;	O
mu_opool_destroy	function
(	O
&	O
pool	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_glob_compile	function
(	O
regex_t	struct
*	O
rx	pointer
,	O
char	O
const	O
*	O
pattern	pointer
,	O
int	O
flags	int
)	O
{	O
char	O
*	O
str	pointer
;	O
int	O
rc	int
;	O
int	O
rxflags	int
;	O
rc	int
=	O
mu_glob_to_regex	function
(	O
&	O
str	pointer
,	O
pattern	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rxflags	int
=	O
REG_EXTENDED	int
;	O
if	O
(	O
flags	int
&	O
MU_GLOBF_ICASE	int
)	O
rxflags	int
|=	O
REG_ICASE	O
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
MU_GLOBF_SUB	int
)	O
)	O
rxflags	int
|=	O
REG_NOSUB	int
;	O
rc	int
=	O
regcomp	function
(	O
rx	struct
,	O
str	pointer
,	O
rxflags	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
size_t	long
size	long
=	O
regerror	function
(	O
rc	int
,	O
rx	struct
,	O
NULL	O
,	O
0	int
)	O
;	O
char	O
*	O
errbuf	pointer
=	O
malloc	function
(	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
errbuf	O
)	O
{	O
regerror	function
(	O
rc	int
,	O
rx	struct
,	O
errbuf	array
,	O
size	long
)	O
;	O
mu_error	function
(	O
"INTERNAL ERROR: can't compile regular expression \"%s\": %s"	pointer
,	O
str	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
else	O
mu_error	function
(	O
"INTERNAL ERROR: can't compile regular expression \"%s\""	pointer
,	O
str	pointer
)	O
;	O
mu_error	function
(	O
"INTERNAL ERROR: expression compiled from globbing pattern: %s"	pointer
,	O
pattern	pointer
)	O
;	O
free	function
(	O
errbuf	pointer
)	O
;	O
}	O
free	function
(	O
str	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_parse_lc_all	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
struct	O
mu_lc_all	struct
*	O
str	pointer
,	O
int	O
flags	int
)	O
{	O
char	O
*	O
s	pointer
;	O
size_t	long
n	long
;	O
str	pointer
->	O
flags	int
=	O
0	int
;	O
n	long
=	O
strcspn	function
(	O
arg	pointer
,	O
"_.@"	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
MU_LC_LANG	int
)	O
{	O
s	pointer
=	O
malloc	function
(	O
n	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
ENOMEM	int
;	O
memcpy	function
(	O
s	pointer
,	O
arg	pointer
,	O
n	long
)	O
;	O
s	pointer
[	O
n	long
]	O
=	O
0	int
;	O
str	pointer
->	O
language	pointer
=	O
s	pointer
;	O
str	pointer
->	O
flags	int
|=	O
MU_LC_LANG	int
;	O
}	O
else	O
str	pointer
->	O
language	pointer
=	O
NULL	O
;	O
arg	pointer
+=	O
n	long
;	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
==	O
'_'	O
)	O
{	O
arg	pointer
++	O
;	O
n	long
=	O
strcspn	function
(	O
arg	pointer
,	O
".@"	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
MU_LC_TERR	int
)	O
{	O
s	pointer
=	O
malloc	function
(	O
n	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
ENOMEM	int
;	O
memcpy	function
(	O
s	pointer
,	O
arg	pointer
,	O
n	long
)	O
;	O
s	pointer
[	O
n	long
]	O
=	O
0	int
;	O
str	pointer
->	O
territory	pointer
=	O
s	long
;	O
str	pointer
->	O
flags	int
|=	O
MU_LC_TERR	int
;	O
}	O
else	O
str	pointer
->	O
territory	pointer
=	O
NULL	O
;	O
arg	pointer
+=	O
n	long
;	O
}	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
arg	pointer
++	O
;	O
n	long
=	O
strcspn	function
(	O
arg	pointer
,	O
"@"	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
MU_LC_CSET	int
)	O
{	O
s	pointer
=	O
malloc	function
(	O
n	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
ENOMEM	int
;	O
memcpy	function
(	O
s	pointer
,	O
arg	pointer
,	O
n	long
)	O
;	O
s	pointer
[	O
n	long
]	O
=	O
0	int
;	O
str	pointer
->	O
charset	pointer
=	O
s	pointer
;	O
str	pointer
->	O
flags	int
|=	O
MU_LC_CSET	int
;	O
}	O
else	O
str	pointer
->	O
charset	pointer
=	O
NULL	O
;	O
arg	pointer
+=	O
n	long
;	O
}	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
)	O
{	O
arg	pointer
++	O
;	O
if	O
(	O
flags	int
&	O
MU_LC_MOD	int
)	O
{	O
str	pointer
->	O
modifier	pointer
=	O
strdup	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
!	O
str	pointer
->	O
modifier	pointer
)	O
return	O
ENOMEM	int
;	O
str	pointer
->	O
flags	int
|=	O
MU_LC_MOD	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
mu_lc_all_free	function
(	O
struct	O
mu_lc_all	struct
*	O
str	pointer
)	O
{	O
if	O
(	O
str	pointer
->	O
flags	int
&	O
MU_LC_LANG	int
)	O
free	function
(	O
str	pointer
->	O
language	pointer
)	O
;	O
if	O
(	O
str	pointer
->	O
flags	int
&	O
MU_LC_TERR	int
)	O
free	function
(	O
str	pointer
->	O
territory	pointer
)	O
;	O
if	O
(	O
str	pointer
->	O
flags	int
&	O
MU_LC_CSET	int
)	O
free	function
(	O
str	pointer
->	O
charset	pointer
)	O
;	O
if	O
(	O
str	pointer
->	O
flags	int
&	O
MU_LC_MOD	int
)	O
free	function
(	O
str	pointer
->	O
modifier	pointer
)	O
;	O
str	pointer
->	O
flags	int
=	O
0	int
;	O
}	O
int	O
mu_parse_lc_all	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
struct	O
mu_lc_all	struct
*	O
str	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
;	O
memset	function
(	O
str	pointer
,	O
0	int
,	O
sizeof	O
(	O
str	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
arg	pointer
)	O
{	O
if	O
(	O
flags	int
&	O
MU_LC_LANG	int
)	O
{	O
str	pointer
->	O
language	pointer
=	O
strdup	function
(	O
"C"	pointer
)	O
;	O
if	O
(	O
!	O
str	pointer
->	O
language	pointer
)	O
return	O
ENOMEM	int
;	O
}	O
return	O
0	int
;	O
}	O
rc	int
=	O
_parse_lc_all	function
(	O
arg	pointer
,	O
str	pointer
,	O
(	O
flags	int
&	O
MU_LC_CSET	int
)	O
?	O
(	O
flags	int
|	O
MU_LC_LANG	int
|	O
MU_LC_TERR	int
)	O
:	O
flags	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
&&	O
(	O
flags	int
&	O
MU_LC_CSET	int
)	O
)	O
{	O
if	O
(	O
!	O
str	pointer
->	O
charset	pointer
)	O
{	O
const	O
char	O
*	O
charset	pointer
=	O
mu_charset_lookup	function
(	O
str	pointer
->	O
language	pointer
,	O
str	pointer
->	O
territory	pointer
)	O
;	O
if	O
(	O
charset	pointer
)	O
{	O
str	pointer
->	O
charset	pointer
=	O
strdup	function
(	O
charset	pointer
)	O
;	O
if	O
(	O
!	O
str	pointer
->	O
charset	pointer
)	O
{	O
rc	int
=	O
ENOMEM	int
;	O
goto	O
err	pointer
;	O
}	O
str	pointer
->	O
flags	int
|=	O
MU_LC_CSET	int
;	O
}	O
}	O
flags	int
=	O
~	O
flags	int
&	O
str	pointer
->	O
flags	int
;	O
if	O
(	O
flags	int
&	O
MU_LC_LANG	int
)	O
{	O
free	function
(	O
str	pointer
->	O
language	pointer
)	O
;	O
str	pointer
->	O
language	pointer
=	O
NULL	O
;	O
str	pointer
->	O
flags	int
&=	O
~	O
MU_LC_LANG	int
;	O
}	O
if	O
(	O
flags	int
&	O
MU_LC_TERR	int
)	O
{	O
free	function
(	O
str	pointer
->	O
territory	pointer
)	O
;	O
str	pointer
->	O
territory	pointer
=	O
NULL	O
;	O
str	pointer
->	O
flags	int
&=	O
~	O
MU_LC_TERR	int
;	O
}	O
}	O
err	O
:	O
if	O
(	O
rc	int
)	O
mu_lc_all_free	function
(	O
str	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
mu_record_t	pointer
mu_nntp_record	pointer
=	O
NULL	O
;	O
mu_record_t	pointer
mu_smtps_record	pointer
=	O
NULL	O
;	O
struct	O
_mu_secret	struct
{	O
unsigned	O
int	O
refcnt	int
;	O
size_t	long
length	long
;	O
unsigned	O
char	O
*	O
obptr	pointer
;	O
unsigned	O
char	O
*	O
clptr	pointer
;	O
unsigned	O
int	O
clref	int
;	O
}	O
;	O
static	O
unsigned	O
char	O
xchar	array
;	O
static	O
void	O
obfuscate	function
(	O
const	O
unsigned	O
char	O
*	O
input	pointer
,	O
unsigned	O
char	O
*	O
output	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
!	O
xchar	pointer
)	O
xchar	array
=	O
random	function
(	O
)	O
%	O
255	int
;	O
while	O
(	O
len	long
--	O
)	O
*	O
output	pointer
++	O
=	O
*	O
input	pointer
++	O
^	O
xchar	pointer
;	O
}	O
int	O
mu_secret_create	function
(	O
mu_secret_t	pointer
*	O
psec	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
size_t	long
len	long
)	O
{	O
mu_secret_t	pointer
sec	pointer
;	O
sec	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
sec	array
[	O
0	int
]	O
)	O
+	O
2	int
*	O
(	O
len	long
+	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
sec	pointer
)	O
return	O
ENOMEM	int
;	O
sec	pointer
->	O
obptr	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
sec	long
+	O
1	int
)	O
;	O
sec	pointer
->	O
clptr	long
=	O
sec	pointer
->	O
obptr	long
+	O
len	long
+	O
1	int
;	O
obfuscate	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
value	pointer
,	O
sec	pointer
->	O
obptr	pointer
,	O
len	long
)	O
;	O
sec	pointer
->	O
length	long
=	O
len	int
;	O
*	O
psec	pointer
=	O
sec	pointer
;	O
mu_secret_ref	function
(	O
sec	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_secret_dup	function
(	O
mu_secret_t	pointer
sec	pointer
,	O
mu_secret_t	pointer
*	O
newsec	pointer
)	O
{	O
const	O
char	O
*	O
pass	pointer
=	O
mu_secret_password	function
(	O
sec	pointer
)	O
;	O
int	O
rc	int
=	O
mu_secret_create	function
(	O
newsec	pointer
,	O
pass	int
,	O
strlen	function
(	O
pass	pointer
)	O
)	O
;	O
mu_secret_password_unref	function
(	O
sec	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
mu_secret_ref	function
(	O
mu_secret_t	pointer
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
)	O
sec	pointer
->	O
refcnt	int
++	O
;	O
}	O
int	O
mu_secret_unref	function
(	O
mu_secret_t	pointer
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
refcnt	int
)	O
sec	pointer
->	O
refcnt	int
--	O
;	O
if	O
(	O
sec	pointer
->	O
refcnt	int
==	O
0	int
)	O
{	O
memset	function
(	O
sec	pointer
->	O
clptr	int
,	O
0	int
,	O
sec	pointer
->	O
length	long
)	O
;	O
memset	function
(	O
sec	pointer
->	O
obptr	int
,	O
0	int
,	O
sec	pointer
->	O
length	long
)	O
;	O
free	function
(	O
sec	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
MU_ERR_EXISTS	O
;	O
}	O
return	O
EINVAL	int
;	O
}	O
void	O
mu_secret_destroy	function
(	O
mu_secret_t	pointer
*	O
psec	pointer
)	O
{	O
if	O
(	O
psec	pointer
&&	O
*	O
psec	pointer
&&	O
mu_secret_unref	function
(	O
*	O
psec	pointer
)	O
==	O
0	int
)	O
*	O
psec	pointer
=	O
NULL	O
;	O
}	O
const	O
char	O
*	O
mu_secret_password	function
(	O
mu_secret_t	pointer
sec	pointer
)	O
{	O
if	O
(	O
!	O
sec	pointer
)	O
return	O
0	int
;	O
if	O
(	O
sec	pointer
->	O
clref	int
++	O
==	O
0	int
)	O
obfuscate	function
(	O
sec	pointer
->	O
obptr	pointer
,	O
sec	pointer
->	O
clptr	pointer
,	O
sec	pointer
->	O
length	long
)	O
;	O
return	O
(	O
const	O
char	O
*	O
)	O
sec	pointer
->	O
clptr	pointer
;	O
}	O
size_t	long
mu_secret_length	function
(	O
mu_secret_t	pointer
sec	pointer
)	O
{	O
if	O
(	O
!	O
sec	pointer
)	O
return	O
0	int
;	O
return	O
sec	pointer
->	O
length	long
;	O
}	O
void	O
mu_secret_password_unref	function
(	O
mu_secret_t	pointer
sec	pointer
)	O
{	O
if	O
(	O
--	O
sec	pointer
->	O
clref	int
==	O
0	int
)	O
memset	function
(	O
sec	pointer
->	O
clptr	pointer
,	O
0	int
,	O
sec	pointer
->	O
length	long
)	O
;	O
}	O
int	O
mu_create_temp_file	function
(	O
char	O
*	O
filename	pointer
,	O
size_t	long
suflen	long
,	O
int	O
*	O
pfd	pointer
,	O
int	O
isdir	int
)	O
{	O
int	O
rc	int
;	O
size_t	long
len	long
;	O
char	O
*	O
carrybuf	pointer
;	O
char	O
*	O
p	pointer
,	O
*	O
cp	pointer
,	O
*	O
start	pointer
,	O
*	O
end	pointer
;	O
struct	O
stat	struct
st	struct
;	O
static	O
int	O
first_call	int
;	O
static	O
char	O
randstate	array
[	O
256	int
]	O
;	O
static	O
const	O
unsigned	O
char	O
alphabet	array
[	O
]	O
=	O
"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"	pointer
;	O
if	O
(	O
!	O
first_call	pointer
)	O
{	O
struct	O
timeval	struct
tv	struct
;	O
gettimeofday	function
(	O
&	O
tv	struct
,	O
NULL	O
)	O
;	O
initstate	function
(	O
(	O
(	O
unsigned	O
long	O
)	O
tv	struct
.	O
tv_usec	long
<<	O
16	int
)	O
^	O
tv	struct
.	O
tv_sec	long
,	O
randstate	pointer
,	O
sizeof	O
(	O
randstate	struct
)	O
)	O
;	O
first_call	int
=	O
1	int
;	O
}	O
setstate	function
(	O
randstate	pointer
)	O
;	O
end	pointer
=	O
filename	pointer
+	O
strlen	function
(	O
filename	pointer
)	O
-	O
suflen	long
-	O
1	int
;	O
for	O
(	O
p	pointer
=	O
end	pointer
;	O
p	pointer
>=	O
filename	pointer
&&	O
*	O
p	pointer
==	O
'X'	O
;	O
p	pointer
--	O
)	O
*	O
p	pointer
=	O
alphabet	array
[	O
random	function
(	O
)	O
%	O
(	O
sizeof	O
(	O
alphabet	array
)	O
-	O
1	int
)	O
]	O
;	O
len	long
=	O
end	pointer
-	O
p	pointer
;	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
EINVAL	int
;	O
start	pointer
=	O
p	pointer
+	O
1	int
;	O
carrybuf	pointer
=	O
malloc	function
(	O
len	int
)	O
;	O
if	O
(	O
!	O
carrybuf	pointer
)	O
return	O
ENOMEM	int
;	O
memcpy	function
(	O
carrybuf	pointer
,	O
start	pointer
,	O
len	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
isdir	int
)	O
{	O
if	O
(	O
mkdir	function
(	O
filename	pointer
,	O
0700	int
)	O
==	O
0	int
)	O
{	O
rc	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
pfd	int
)	O
{	O
if	O
(	O
(	O
*	O
pfd	pointer
=	O
open	function
(	O
filename	pointer
,	O
O_CREAT	int
|	O
O_EXCL	int
|	O
O_RDWR	int
,	O
0600	int
)	O
)	O
>=	O
0	int
)	O
{	O
rc	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
lstat	function
(	O
filename	pointer
,	O
&	O
st	struct
)	O
&&	O
errno	O
==	O
ENOENT	int
)	O
{	O
rc	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
errno	O
!=	O
EEXIST	int
)	O
{	O
rc	int
=	O
errno	O
;	O
break	O
;	O
}	O
for	O
(	O
p	int
=	O
start	int
,	O
cp	int
=	O
carrybuf	int
;	O
;	O
p	pointer
++	O
,	O
cp	pointer
++	O
)	O
{	O
char	O
*	O
q	pointer
;	O
if	O
(	O
p	pointer
==	O
end	pointer
)	O
return	O
EEXIST	int
;	O
q	pointer
=	O
strchr	function
(	O
(	O
char	O
*	O
)	O
alphabet	pointer
,	O
*	O
p	pointer
)	O
;	O
if	O
(	O
!	O
q	pointer
)	O
abort	function
(	O
)	O
;	O
*	O
p	pointer
=	O
(	O
q	pointer
[	O
1	int
]	O
==	O
0	int
)	O
?	O
alphabet	array
[	O
0	int
]	O
:	O
q	pointer
[	O
1	int
]	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
*	O
cp	pointer
)	O
break	O
;	O
}	O
}	O
free	function
(	O
carrybuf	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_tempfile	function
(	O
struct	O
mu_tempfile_hints	struct
*	O
hints	pointer
,	O
int	O
flags	int
,	O
int	O
*	O
pfd	pointer
,	O
char	O
*	O
*	O
namep	pointer
)	O
{	O
char	O
*	O
filename	pointer
;	O
const	O
char	O
*	O
tmpdir	pointer
=	O
getenv	function
(	O
"TMPDIR"	pointer
)	O
;	O
const	O
char	O
*	O
suf	pointer
=	O
NULL	O
;	O
int	O
create_dir	int
=	O
0	int
;	O
int	O
rc	int
;	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
pfd	pointer
==	O
NULL	O
&&	O
namep	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
hints	pointer
)	O
{	O
if	O
(	O
flags	int
&	O
MU_TEMPFILE_TMPDIR	int
)	O
tmpdir	pointer
=	O
hints	pointer
->	O
tmpdir	pointer
;	O
if	O
(	O
flags	int
&	O
MU_TEMPFILE_SUFFIX	int
)	O
suf	pointer
=	O
hints	pointer
->	O
suffix	pointer
;	O
create_dir	pointer
=	O
flags	int
&	O
MU_TEMPFILE_MKDIR	int
;	O
}	O
if	O
(	O
!	O
tmpdir	pointer
)	O
tmpdir	pointer
=	O
P_tmpdir	pointer
;	O
if	O
(	O
stat	struct
(	O
tmpdir	pointer
,	O
&	O
st	struct
)	O
)	O
return	O
errno	O
;	O
filename	pointer
=	O
mu_make_file_name_suf	function
(	O
tmpdir	pointer
,	O
"muXXXXXX"	pointer
,	O
suf	pointer
)	O
;	O
rc	int
=	O
mu_create_temp_file	function
(	O
filename	pointer
,	O
suf	pointer
?	O
strlen	function
(	O
suf	pointer
)	O
:	O
0	int
,	O
pfd	int
,	O
create_dir	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
namep	pointer
)	O
*	O
namep	pointer
=	O
filename	pointer
;	O
else	O
{	O
unlink	function
(	O
filename	pointer
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
char	O
*	O
mu_tempname	function
(	O
const	O
char	O
*	O
tmpdir	pointer
)	O
{	O
struct	O
mu_tempfile_hints	struct
hints	pointer
;	O
char	O
*	O
filename	pointer
=	O
NULL	O
;	O
int	O
fd	int
;	O
hints	pointer
.	O
tmpdir	pointer
=	O
(	O
char	O
*	O
)	O
tmpdir	pointer
;	O
if	O
(	O
mu_tempfile	function
(	O
&	O
hints	pointer
,	O
MU_TEMPFILE_TMPDIR	int
,	O
&	O
fd	int
,	O
&	O
filename	pointer
)	O
)	O
return	O
NULL	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
filename	pointer
;	O
}	O
char	O
*	O
mu_tilde_expansion	function
(	O
const	O
char	O
*	O
ref	pointer
,	O
int	O
delim	int
,	O
const	O
char	O
*	O
homedir	pointer
)	O
{	O
char	O
*	O
base	pointer
=	O
strdup	function
(	O
ref	pointer
)	O
;	O
char	O
*	O
home	pointer
=	O
NULL	O
;	O
char	O
*	O
proto	pointer
=	O
NULL	O
;	O
size_t	long
proto_len	long
=	O
0	int
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
!	O
base	pointer
)	O
return	O
NULL	O
;	O
for	O
(	O
p	pointer
=	O
base	pointer
;	O
*	O
p	pointer
&&	O
mu_isascii	O
(	O
*	O
p	pointer
)	O
&&	O
mu_isalnum	function
(	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
':'	O
)	O
{	O
p	pointer
++	O
;	O
proto_len	pointer
=	O
p	pointer
-	O
base	pointer
;	O
proto	pointer
=	O
malloc	function
(	O
proto_len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
proto	pointer
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
proto	pointer
,	O
base	pointer
,	O
proto_len	int
)	O
;	O
proto	pointer
[	O
proto_len	int
]	O
=	O
0	int
;	O
if	O
(	O
*	O
p	pointer
==	O
delim	pointer
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
delim	pointer
)	O
p	pointer
++	O
;	O
}	O
else	O
p	pointer
=	O
base	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
'~'	O
)	O
{	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
delim	pointer
||	O
*	O
p	pointer
==	O
'\0'	O
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
!	O
homedir	pointer
)	O
{	O
home	pointer
=	O
mu_get_homedir	function
(	O
)	O
;	O
if	O
(	O
!	O
home	pointer
)	O
return	O
base	pointer
;	O
homedir	pointer
=	O
home	pointer
;	O
}	O
s	pointer
=	O
calloc	function
(	O
proto_len	pointer
+	O
strlen	function
(	O
homedir	pointer
)	O
+	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
proto_len	pointer
)	O
strcpy	function
(	O
s	pointer
,	O
proto	pointer
)	O
;	O
else	O
s	pointer
[	O
0	int
]	O
=	O
0	int
;	O
strcat	function
(	O
s	pointer
,	O
homedir	pointer
)	O
;	O
strcat	function
(	O
s	pointer
,	O
p	pointer
)	O
;	O
free	function
(	O
base	pointer
)	O
;	O
base	pointer
=	O
s	pointer
;	O
}	O
else	O
{	O
struct	O
mu_auth_data	struct
*	O
auth	pointer
;	O
char	O
*	O
s	pointer
=	O
p	pointer
;	O
char	O
*	O
name	pointer
;	O
while	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
!=	O
delim	pointer
)	O
s	pointer
++	O
;	O
name	pointer
=	O
calloc	function
(	O
s	pointer
-	O
p	pointer
+	O
1	int
,	O
1	int
)	O
;	O
memcpy	function
(	O
name	pointer
,	O
p	pointer
,	O
s	pointer
-	O
p	pointer
)	O
;	O
name	pointer
[	O
s	pointer
-	O
p	pointer
]	O
=	O
'\0'	O
;	O
auth	pointer
=	O
mu_get_auth_by_name	function
(	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
auth	pointer
)	O
{	O
char	O
*	O
buf	pointer
=	O
calloc	function
(	O
proto_len	pointer
+	O
strlen	function
(	O
auth	pointer
->	O
dir	pointer
)	O
+	O
strlen	function
(	O
s	pointer
)	O
+	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
proto_len	pointer
)	O
strcpy	function
(	O
buf	pointer
,	O
proto	pointer
)	O
;	O
else	O
buf	pointer
[	O
0	int
]	O
=	O
0	int
;	O
strcat	function
(	O
buf	pointer
,	O
auth	pointer
->	O
dir	pointer
)	O
;	O
strcat	function
(	O
buf	pointer
,	O
s	pointer
)	O
;	O
free	function
(	O
base	pointer
)	O
;	O
base	pointer
=	O
buf	pointer
;	O
mu_auth_data_free	function
(	O
auth	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
home	pointer
)	O
free	function
(	O
home	pointer
)	O
;	O
return	O
base	pointer
;	O
}	O
static	O
char	O
*	O
mu_user_email	pointer
=	O
0	int
;	O
int	O
mu_set_user_email	function
(	O
const	O
char	O
*	O
candidate	pointer
)	O
{	O
int	O
err	int
=	O
0	int
;	O
mu_address_t	pointer
addr	pointer
=	O
NULL	O
;	O
size_t	long
emailno	int
=	O
0	int
;	O
char	O
*	O
email	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
domain	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
candidate	pointer
)	O
{	O
free	function
(	O
mu_user_email	pointer
)	O
;	O
mu_user_email	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
err	int
=	O
mu_address_create	function
(	O
&	O
addr	int
,	O
candidate	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
err	O
;	O
if	O
(	O
(	O
err	int
=	O
mu_address_get_email_count	function
(	O
addr	pointer
,	O
&	O
emailno	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
cleanup	pointer
;	O
if	O
(	O
emailno	int
!=	O
1	int
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
goto	O
cleanup	pointer
;	O
}	O
if	O
(	O
(	O
err	int
=	O
mu_address_aget_email	function
(	O
addr	pointer
,	O
1	int
,	O
&	O
email	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
cleanup	pointer
;	O
else	O
if	O
(	O
email	pointer
==	O
NULL	O
)	O
{	O
err	int
=	O
MU_ERR_NOENT	O
;	O
goto	O
cleanup	pointer
;	O
}	O
free	function
(	O
mu_user_email	pointer
)	O
;	O
mu_user_email	pointer
=	O
email	pointer
;	O
if	O
(	O
(	O
err	O
=	O
mu_address_sget_domain	function
(	O
addr	pointer
,	O
1	int
,	O
&	O
domain	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
cleanup	O
;	O
else	O
if	O
(	O
domain	pointer
==	O
NULL	O
)	O
{	O
err	int
=	O
MU_ERR_NOENT	O
;	O
goto	O
cleanup	O
;	O
}	O
mu_set_user_email_domain	function
(	O
domain	pointer
)	O
;	O
cleanup	O
:	O
mu_address_destroy	function
(	O
&	O
addr	O
)	O
;	O
return	O
err	int
;	O
}	O
static	O
char	O
*	O
mu_user_email_domain	pointer
=	O
0	int
;	O
int	O
mu_set_user_email_domain	function
(	O
const	O
char	O
*	O
domain	pointer
)	O
{	O
char	O
*	O
d	pointer
;	O
if	O
(	O
domain	pointer
)	O
{	O
d	pointer
=	O
strdup	function
(	O
domain	pointer
)	O
;	O
if	O
(	O
!	O
d	pointer
)	O
return	O
ENOMEM	int
;	O
}	O
else	O
d	pointer
=	O
NULL	O
;	O
if	O
(	O
mu_user_email_domain	pointer
)	O
free	function
(	O
mu_user_email_domain	pointer
)	O
;	O
mu_user_email_domain	pointer
=	O
d	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_get_user_email_domain	function
(	O
const	O
char	O
*	O
*	O
domain	pointer
)	O
{	O
int	O
err	int
=	O
0	int
;	O
if	O
(	O
!	O
mu_user_email_domain	pointer
)	O
{	O
if	O
(	O
(	O
err	int
=	O
mu_get_host_name	function
(	O
&	O
mu_user_email_domain	struct
)	O
)	O
)	O
return	O
err	int
;	O
}	O
*	O
domain	pointer
=	O
mu_user_email_domain	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_aget_user_email_domain	function
(	O
char	O
*	O
*	O
pdomain	pointer
)	O
{	O
const	O
char	O
*	O
domain	pointer
;	O
int	O
status	int
=	O
mu_get_user_email_domain	function
(	O
&	O
domain	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
domain	pointer
==	O
NULL	O
)	O
*	O
pdomain	pointer
=	O
NULL	O
;	O
else	O
{	O
*	O
pdomain	pointer
=	O
strdup	function
(	O
domain	pointer
)	O
;	O
if	O
(	O
*	O
pdomain	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
}	O
return	O
0	int
;	O
}	O
char	O
*	O
mu_get_user_email	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
int	O
status	int
=	O
0	int
;	O
char	O
*	O
localpart	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
domainpart	pointer
=	O
NULL	O
;	O
char	O
*	O
email	pointer
=	O
NULL	O
;	O
char	O
*	O
tmpname	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
name	pointer
&&	O
mu_user_email	int
)	O
{	O
email	pointer
=	O
strdup	function
(	O
mu_user_email	pointer
)	O
;	O
if	O
(	O
!	O
email	pointer
)	O
errno	O
=	O
ENOMEM	int
;	O
return	O
email	pointer
;	O
}	O
if	O
(	O
!	O
name	pointer
)	O
{	O
struct	O
mu_auth_data	struct
*	O
auth	pointer
=	O
mu_get_auth_by_uid	function
(	O
geteuid	function
(	O
)	O
)	O
;	O
if	O
(	O
!	O
auth	pointer
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
NULL	O
;	O
}	O
name	pointer
=	O
tmpname	pointer
=	O
strdup	function
(	O
auth	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
auth	pointer
)	O
mu_auth_data_free	function
(	O
auth	pointer
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
{	O
errno	O
=	O
ENOMEM	int
;	O
return	O
NULL	O
;	O
}	O
}	O
status	int
=	O
mu_get_user_email_domain	function
(	O
&	O
domainpart	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
tmpname	pointer
)	O
;	O
errno	O
=	O
status	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
status	int
=	O
mu_parse822_quote_local_part	function
(	O
&	O
localpart	pointer
,	O
name	pointer
)	O
)	O
)	O
{	O
free	function
(	O
tmpname	pointer
)	O
;	O
errno	O
=	O
status	int
;	O
return	O
NULL	O
;	O
}	O
email	pointer
=	O
malloc	function
(	O
strlen	function
(	O
localpart	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
domainpart	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
email	pointer
)	O
errno	O
=	O
ENOMEM	int
;	O
else	O
sprintf	function
(	O
email	pointer
,	O
"%s@%s"	pointer
,	O
localpart	pointer
,	O
domainpart	pointer
)	O
;	O
free	function
(	O
tmpname	pointer
)	O
;	O
free	function
(	O
localpart	pointer
)	O
;	O
return	O
email	pointer
;	O
}	O
static	O
int	O
to_xdig	function
(	O
unsigned	O
char	O
b	int
)	O
{	O
if	O
(	O
b	int
>=	O
0xa	int
)	O
return	O
'A'	O
+	O
b	int
-	O
0xa	int
;	O
else	O
return	O
'0'	O
+	O
b	int
;	O
}	O
static	O
size_t	long
format_ipv6_bytes	function
(	O
const	O
unsigned	O
char	O
*	O
bytes	pointer
,	O
int	O
len	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
int	O
simplify	int
)	O
{	O
size_t	long
total	long
=	O
0	int
;	O
int	O
i	int
;	O
int	O
run_count	int
=	O
0	int
;	O
char	O
*	O
p	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
len	long
;	O
i	long
+=	O
2	int
)	O
{	O
if	O
(	O
bytes	pointer
[	O
0	int
]	O
==	O
0	int
&&	O
bytes	pointer
[	O
1	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
simplify	int
)	O
run_count	long
++	O
;	O
else	O
{	O
if	O
(	O
i	long
&&	O
total	long
++	O
<	O
size	long
)	O
*	O
buf	pointer
++	O
=	O
':'	O
;	O
if	O
(	O
total	long
++	O
<	O
size	long
)	O
*	O
buf	pointer
++	O
=	O
'0'	O
;	O
}	O
bytes	long
+=	O
2	int
;	O
}	O
else	O
{	O
if	O
(	O
run_count	int
)	O
{	O
if	O
(	O
run_count	int
==	O
1	int
)	O
{	O
if	O
(	O
i	long
&&	O
total	long
++	O
<	O
size	long
)	O
*	O
buf	pointer
++	O
=	O
':'	O
;	O
if	O
(	O
total	long
++	O
<	O
size	long
)	O
*	O
buf	pointer
++	O
=	O
'0'	O
;	O
}	O
else	O
{	O
if	O
(	O
total	long
++	O
<	O
size	int
)	O
*	O
buf	pointer
++	O
=	O
':'	O
;	O
simplify	int
=	O
0	int
;	O
}	O
run_count	int
=	O
0	int
;	O
}	O
if	O
(	O
i	int
&&	O
total	long
++	O
<	O
size	int
)	O
*	O
buf	pointer
++	O
=	O
':'	O
;	O
p	pointer
=	O
buf	pointer
;	O
if	O
(	O
(	O
*	O
bytes	pointer
&	O
0xf0	int
)	O
&&	O
total	long
++	O
<	O
size	int
)	O
*	O
buf	pointer
++	O
=	O
to_xdig	function
(	O
*	O
bytes	pointer
>>	O
4	int
)	O
;	O
if	O
(	O
(	O
buf	pointer
>	O
p	pointer
||	O
(	O
*	O
bytes	pointer
&	O
0xf	int
)	O
)	O
&&	O
total	long
++	O
<	O
size	long
)	O
*	O
buf	pointer
++	O
=	O
to_xdig	function
(	O
*	O
bytes	pointer
&	O
0xf	int
)	O
;	O
bytes	long
++	O
;	O
if	O
(	O
(	O
buf	pointer
>	O
p	pointer
||	O
(	O
*	O
bytes	pointer
&	O
0xf0	int
)	O
)	O
&&	O
total	long
++	O
<	O
size	long
)	O
*	O
buf	pointer
++	O
=	O
to_xdig	function
(	O
*	O
bytes	pointer
>>	O
4	int
)	O
;	O
if	O
(	O
(	O
buf	pointer
>	O
p	pointer
||	O
(	O
*	O
bytes	pointer
&	O
0xf	int
)	O
)	O
&&	O
total	long
++	O
<	O
size	long
)	O
*	O
buf	pointer
++	O
=	O
to_xdig	function
(	O
*	O
bytes	pointer
&	O
0xf	int
)	O
;	O
bytes	long
++	O
;	O
}	O
}	O
if	O
(	O
run_count	int
)	O
{	O
if	O
(	O
run_count	int
==	O
1	int
)	O
{	O
if	O
(	O
i	int
&&	O
total	long
++	O
<	O
size	int
)	O
*	O
buf	pointer
++	O
=	O
':'	O
;	O
if	O
(	O
total	long
++	O
<	O
size	int
)	O
*	O
buf	pointer
++	O
=	O
'0'	O
;	O
}	O
else	O
{	O
if	O
(	O
total	long
++	O
<	O
size	int
)	O
*	O
buf	pointer
++	O
=	O
':'	O
;	O
if	O
(	O
total	long
++	O
<	O
size	int
)	O
*	O
buf	pointer
++	O
=	O
':'	O
;	O
}	O
}	O
return	O
total	long
;	O
}	O
static	O
size_t	long
format_ipv6_bytes_normal	function
(	O
const	O
unsigned	O
char	O
*	O
bytes	pointer
,	O
int	O
len	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	pointer
)	O
{	O
return	O
format_ipv6_bytes	function
(	O
bytes	pointer
,	O
len	long
,	O
buf	pointer
,	O
size	pointer
,	O
0	int
)	O
;	O
}	O
static	O
size_t	long
format_ipv6_bytes_simplified	function
(	O
const	O
unsigned	O
char	O
*	O
bytes	pointer
,	O
int	O
len	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
)	O
{	O
return	O
format_ipv6_bytes	function
(	O
bytes	pointer
,	O
len	long
,	O
buf	pointer
,	O
size	pointer
,	O
1	int
)	O
;	O
}	O
static	O
size_t	long
format_ipv4_bytes	function
(	O
const	O
unsigned	O
char	O
*	O
bytes	pointer
,	O
int	O
len	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
)	O
{	O
int	O
i	int
;	O
size_t	long
total	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	long
<	O
len	int
;	O
i	int
++	O
)	O
{	O
unsigned	O
char	O
b	int
=	O
*	O
bytes	pointer
++	O
;	O
char	O
nbuf	array
[	O
3	int
]	O
;	O
int	O
j	int
;	O
if	O
(	O
i	long
)	O
{	O
if	O
(	O
total	long
++	O
<	O
size	long
)	O
*	O
buf	pointer
++	O
=	O
'.'	O
;	O
}	O
j	int
=	O
0	int
;	O
do	O
{	O
nbuf	array
[	O
j	int
++	O
]	O
=	O
b	int
%	O
10	int
+	O
'0'	O
;	O
b	int
/=	O
10	int
;	O
}	O
while	O
(	O
b	int
)	O
;	O
for	O
(	O
;	O
j	long
;	O
j	long
--	O
)	O
{	O
if	O
(	O
total	long
++	O
<	O
size	long
)	O
*	O
buf	pointer
++	O
=	O
nbuf	array
[	O
j	int
-	O
1	int
]	O
;	O
}	O
}	O
return	O
total	long
;	O
}	O
int	O
mu_cidr_to_string	function
(	O
struct	O
mu_cidr	struct
*	O
cidr	pointer
,	O
int	O
flags	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
size_t	long
*	O
pret	pointer
)	O
{	O
size_t	long
(	O
*	O
fmt	pointer
)	O
(	O
const	O
unsigned	O
char	O
*	O
bytes	pointer
,	O
int	O
len	long
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
)	O
;	O
size_t	long
n	long
,	O
total	long
=	O
0	int
;	O
if	O
(	O
size	long
==	O
0	int
)	O
return	O
MU_ERR_BUFSPACE	O
;	O
size	long
--	O
;	O
switch	O
(	O
cidr	pointer
->	O
family	int
)	O
{	O
case	O
AF_INET	O
:	O
fmt	pointer
=	O
format_ipv4_bytes	int
;	O
break	O
;	O
case	O
AF_INET6	O
:	O
fmt	pointer
=	O
(	O
flags	int
&	O
MU_CIDR_FMT_SIMPLIFY	int
)	O
?	O
format_ipv6_bytes_simplified	int
:	O
format_ipv6_bytes_normal	int
;	O
break	O
;	O
default	O
:	O
return	O
MU_ERR_FAMILY	O
;	O
}	O
n	int
=	O
fmt	pointer
(	O
cidr	pointer
->	O
address	array
,	O
cidr	pointer
->	O
len	long
,	O
buf	pointer
,	O
size	pointer
)	O
;	O
if	O
(	O
buf	pointer
)	O
buf	pointer
+=	O
n	int
;	O
total	long
+=	O
n	int
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
MU_CIDR_FMT_ADDRONLY	int
)	O
)	O
{	O
if	O
(	O
total	long
++	O
<	O
size	long
)	O
*	O
buf	pointer
++	O
=	O
'/'	O
;	O
n	int
=	O
fmt	pointer
(	O
cidr	pointer
->	O
netmask	array
,	O
cidr	pointer
->	O
len	int
,	O
buf	pointer
,	O
size	array
-	O
total	long
)	O
;	O
if	O
(	O
buf	pointer
)	O
buf	pointer
+=	O
n	int
;	O
total	long
+=	O
n	int
;	O
}	O
if	O
(	O
buf	pointer
)	O
*	O
buf	pointer
++	O
=	O
0	int
;	O
if	O
(	O
pret	pointer
)	O
*	O
pret	pointer
=	O
total	long
;	O
return	O
0	int
;	O
}	O
int	O
mu_cidr_format	function
(	O
struct	O
mu_cidr	struct
*	O
cidr	pointer
,	O
int	O
flags	int
,	O
char	O
*	O
*	O
pbuf	pointer
)	O
{	O
char	O
buf	pointer
[	O
MU_CIDR_MAXBUFSIZE	int
]	O
;	O
int	O
rc	int
=	O
mu_cidr_to_string	function
(	O
cidr	pointer
,	O
flags	int
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
*	O
pbuf	pointer
=	O
strdup	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
*	O
buf	pointer
)	O
return	O
ENOMEM	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
month_start	array
[	O
]	O
=	O
{	O
0	int
,	O
31	int
,	O
59	int
,	O
90	int
,	O
120	int
,	O
151	int
,	O
181	int
,	O
212	int
,	O
243	int
,	O
273	int
,	O
304	int
,	O
334	int
,	O
365	int
}	O
;	O
int	O
mu_datetime_dayofyear	function
(	O
int	O
year	int
,	O
int	O
month	int
,	O
int	O
day	int
)	O
{	O
int	O
leap	int
,	O
month_days	int
;	O
if	O
(	O
year	int
<	O
0	int
||	O
month	int
<	O
1	int
||	O
month	int
>	O
12	int
||	O
day	int
<	O
1	int
)	O
return	O
-	O
1	int
;	O
leap	int
=	O
leap_year	function
(	O
year	int
)	O
;	O
month_days	int
=	O
month_start	array
[	O
month	int
]	O
-	O
month_start	array
[	O
month	int
-	O
1	int
]	O
+	O
(	O
(	O
month	int
==	O
2	int
)	O
?	O
leap	int
:	O
0	int
)	O
;	O
if	O
(	O
day	int
>	O
month_days	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
month	int
<=	O
2	int
)	O
leap	int
=	O
0	int
;	O
return	O
month_start	array
[	O
month	int
-	O
1	int
]	O
+	O
day	int
+	O
leap	int
;	O
}	O
int	O
mu_datetime_julianday	function
(	O
int	O
year	int
,	O
int	O
month	int
,	O
int	O
day	int
)	O
{	O
int	O
a	int
=	O
(	O
14	int
-	O
month	int
)	O
/	O
12	int
;	O
int	O
y	int
=	O
year	int
+	O
4800	int
-	O
a	int
;	O
int	O
m	int
=	O
month	int
+	O
12	int
*	O
a	int
-	O
3	int
;	O
return	O
day	int
+	O
(	O
153	O
*	O
m	pointer
+	O
2	int
)	O
/	O
5	int
+	O
365	int
*	O
y	int
+	O
y	int
/	O
4	int
-	O
y	int
/	O
100	int
+	O
y	int
/	O
400	int
-	O
32045	int
;	O
}	O
time_t	long
mu_datetime_to_utc	function
(	O
struct	O
tm	struct
*	O
tm	struct
,	O
struct	O
mu_timezone	struct
*	O
tz	pointer
)	O
{	O
int	O
jd	int
=	O
mu_datetime_julianday	function
(	O
tm	struct
->	O
tm_year	int
+	O
1900	int
,	O
tm	struct
->	O
tm_mon	int
+	O
1	int
,	O
tm	struct
->	O
tm_mday	int
)	O
;	O
return	O
(	O
jd	int
-	O
JD_OF_EPOCH	int
)	O
*	O
SECS_PER_DAY	pointer
+	O
(	O
tm	struct
->	O
tm_hour	int
*	O
60	int
+	O
tm	struct
->	O
tm_min	int
)	O
*	O
60	int
+	O
tm	struct
->	O
tm_sec	int
-	O
(	O
tz	pointer
?	O
tz	pointer
->	O
utc_offset	int
:	O
0	int
)	O
;	O
}	O
void	O
mu_gdb_bt	function
(	O
)	O
{	O
int	O
i	int
;	O
pid_t	int
master_pid	int
=	O
getpid	function
(	O
)	O
;	O
pid_t	int
pid	int
;	O
static	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
static	O
char	O
fname	pointer
[	O
1024	int
]	O
;	O
int	O
fd	int
;	O
char	O
*	O
argv	pointer
[	O
8	int
]	O
;	O
if	O
(	O
!	O
mu_program_name	pointer
)	O
abort	function
(	O
)	O
;	O
sprintf	function
(	O
fname	pointer
,	O
"/tmp/mailutils.%s.%lu"	pointer
,	O
mu_program_name	pointer
,	O
(	O
unsigned	O
long	O
)	O
master_pid	pointer
)	O
;	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
(	O
pid_t	int
)	O
-	O
1	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
pid	int
)	O
{	O
sleep	function
(	O
10	int
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
mu_getmaxfd	function
(	O
)	O
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
close	pointer
(	O
i	int
)	O
;	O
fd	int
=	O
open	function
(	O
fname	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
,	O
0600	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
abort	function
(	O
)	O
;	O
dup2	function
(	O
fd	int
,	O
1	int
)	O
;	O
dup2	function
(	O
fd	int
,	O
2	int
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
"/usr/bin/gdb"	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
mu_full_program_name	pointer
;	O
sprintf	function
(	O
buf	pointer
,	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
master_pid	pointer
)	O
;	O
argv	pointer
[	O
2	int
]	O
=	O
buf	pointer
;	O
argv	pointer
[	O
3	int
]	O
=	O
"-ex"	pointer
;	O
argv	pointer
[	O
4	int
]	O
=	O
"bt"	pointer
;	O
argv	pointer
[	O
5	int
]	O
=	O
"-ex"	pointer
;	O
argv	pointer
[	O
6	int
]	O
=	O
"kill"	pointer
;	O
argv	pointer
[	O
7	int
]	O
=	O
NULL	O
;	O
execvp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
void	O
mu_diag_init	function
(	O
)	O
{	O
if	O
(	O
!	O
mu_strerr	pointer
)	O
mu_stdstream_setup	function
(	O
MU_STDSTREAM_RESET_NONE	int
)	O
;	O
}	O
void	O
mu_diag_voutput	function
(	O
int	O
level	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
mu_diag_init	function
(	O
)	O
;	O
mu_stream_printf	function
(	O
mu_strerr	pointer
,	O
"\033s<%d>"	pointer
,	O
level	int
)	O
;	O
mu_stream_vprintf	function
(	O
mu_strerr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
mu_stream_write	function
(	O
mu_strerr	pointer
,	O
"\n"	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
}	O
void	O
mu_diag_output	function
(	O
int	O
level	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
mu_diag_voutput	function
(	O
level	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
mu_vdiag_at_locus_range	function
(	O
int	O
level	int
,	O
struct	O
mu_locus_range	struct
const	O
*	O
loc	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
struct	O
mu_locus_range	struct
old_loc	pointer
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
int	O
old_mode	int
;	O
int	O
restore	int
=	O
0	int
;	O
if	O
(	O
loc	pointer
)	O
{	O
if	O
(	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_GET_LOCUS_RANGE	int
,	O
&	O
old_loc	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_GET_MODE	int
,	O
&	O
old_mode	int
)	O
==	O
0	int
)	O
{	O
int	O
mode	int
=	O
old_mode	int
|	O
MU_LOGMODE_LOCUS	int
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
mode	int
)	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
(	O
void	O
*	O
)	O
loc	pointer
)	O
;	O
restore	int
=	O
1	int
;	O
}	O
}	O
}	O
mu_diag_voutput	function
(	O
level	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
if	O
(	O
restore	int
)	O
{	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
&	O
old_loc	int
)	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
old_mode	int
)	O
;	O
mu_locus_range_deinit	function
(	O
&	O
old_loc	int
)	O
;	O
}	O
}	O
void	O
mu_diag_at_locus_range	function
(	O
int	O
level	int
,	O
struct	O
mu_locus_range	struct
const	O
*	O
loc	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
mu_vdiag_at_locus_range	function
(	O
level	int
,	O
loc	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
mu_diag_at_locus_point	function
(	O
int	O
level	int
,	O
struct	O
mu_locus_point	struct
const	O
*	O
loc	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
struct	O
mu_locus_range	struct
lr	pointer
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
lr	pointer
.	O
beg	pointer
=	O
*	O
loc	pointer
;	O
va_start	O
(	O
ap	pointer
,	O
fmt	pointer
)	O
;	O
mu_vdiag_at_locus_range	function
(	O
level	int
,	O
&	O
lr	pointer
,	O
fmt	pointer
,	O
ap	pointer
)	O
;	O
va_end	O
(	O
ap	pointer
)	O
;	O
}	O
void	O
mu_diag_vprintf	function
(	O
int	O
level	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
mu_diag_init	function
(	O
)	O
;	O
mu_stream_printf	function
(	O
mu_strerr	pointer
,	O
"\033s<%d>"	pointer
,	O
level	int
)	O
;	O
mu_stream_vprintf	function
(	O
mu_strerr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
}	O
void	O
mu_diag_cont_vprintf	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
mu_diag_init	function
(	O
)	O
;	O
mu_stream_vprintf	function
(	O
mu_strerr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
}	O
void	O
mu_diag_printf	function
(	O
int	O
level	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
mu_diag_vprintf	function
(	O
level	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
mu_diag_cont_printf	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
mu_diag_cont_vprintf	function
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
const	O
char	O
*	O
mu_diag_level_to_string	function
(	O
int	O
level	int
)	O
{	O
switch	O
(	O
level	int
)	O
{	O
case	O
MU_DIAG_EMERG	O
:	O
return	O
_	O
(	O
"emergency"	pointer
)	O
;	O
case	O
MU_DIAG_ALERT	O
:	O
return	O
_	O
(	O
"alert"	pointer
)	O
;	O
case	O
MU_DIAG_CRIT	O
:	O
return	O
_	O
(	O
"critical"	pointer
)	O
;	O
case	O
MU_DIAG_ERROR	O
:	O
return	O
_	O
(	O
"error"	pointer
)	O
;	O
case	O
MU_DIAG_WARNING	int
:	O
return	O
_	O
(	O
"warning"	pointer
)	O
;	O
case	O
MU_DIAG_NOTICE	O
:	O
return	O
_	O
(	O
"notice"	pointer
)	O
;	O
case	O
MU_DIAG_INFO	O
:	O
return	O
_	O
(	O
"info"	pointer
)	O
;	O
case	O
MU_DIAG_DEBUG	O
:	O
return	O
_	O
(	O
"debug"	pointer
)	O
;	O
}	O
return	O
_	O
(	O
"unknown"	pointer
)	O
;	O
}	O
void	O
mu_diag_funcall	function
(	O
mu_log_level_t	O
level	pointer
,	O
const	O
char	O
*	O
func	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
int	O
err	int
)	O
{	O
if	O
(	O
err	O
)	O
mu_diag_output	function
(	O
level	int
,	O
_	O
(	O
"%s(%s) failed: %s"	pointer
)	O
,	O
func	pointer
,	O
mu_prstr	function
(	O
arg	pointer
)	O
,	O
mu_strerror	function
(	O
err	pointer
)	O
)	O
;	O
else	O
mu_diag_output	function
(	O
level	int
,	O
_	O
(	O
"%s(%s) failed"	pointer
)	O
,	O
func	pointer
,	O
mu_prstr	function
(	O
arg	pointer
)	O
)	O
;	O
}	O
static	O
enum	O
mu_filter_result	enum
_dq_encoder	function
(	O
void	O
*	O
xd	pointer
MU_ARG_UNUSED	O
,	O
enum	O
mu_filter_command	enum
cmd	enum
,	O
struct	O
mu_filter_io	struct
*	O
iobuf	pointer
)	O
{	O
size_t	long
i	long
,	O
j	long
;	O
const	O
unsigned	O
char	O
*	O
iptr	pointer
;	O
size_t	long
isize	long
;	O
char	O
*	O
optr	pointer
;	O
size_t	long
osize	long
;	O
switch	O
(	O
cmd	enum
)	O
{	O
case	O
mu_filter_init	int
:	O
case	O
mu_filter_done	int
:	O
return	O
mu_filter_ok	int
;	O
default	O
:	O
break	O
;	O
}	O
iptr	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
iobuf	pointer
->	O
input	pointer
;	O
isize	long
=	O
iobuf	pointer
->	O
isize	long
;	O
optr	pointer
=	O
iobuf	pointer
->	O
output	pointer
;	O
osize	long
=	O
iobuf	pointer
->	O
osize	long
;	O
for	O
(	O
i	long
=	O
j	long
=	O
0	int
;	O
i	long
<	O
isize	long
&&	O
j	long
<	O
osize	long
;	O
i	long
++	O
)	O
{	O
unsigned	O
char	O
c	int
=	O
*	O
iptr	pointer
++	O
;	O
if	O
(	O
strchr	function
(	O
"\\\""	pointer
,	O
c	int
)	O
)	O
{	O
if	O
(	O
j	long
+	O
1	int
==	O
osize	long
)	O
{	O
if	O
(	O
i	long
==	O
0	int
)	O
{	O
iobuf	pointer
->	O
osize	long
=	O
2	int
;	O
return	O
mu_filter_moreoutput	int
;	O
}	O
break	O
;	O
}	O
else	O
{	O
optr	pointer
[	O
j	long
++	O
]	O
=	O
'\\'	O
;	O
optr	pointer
[	O
j	long
++	O
]	O
=	O
c	int
;	O
}	O
}	O
else	O
optr	pointer
[	O
j	long
++	O
]	O
=	O
c	int
;	O
}	O
iobuf	pointer
->	O
isize	long
=	O
i	long
;	O
iobuf	pointer
->	O
osize	long
=	O
j	long
;	O
return	O
mu_filter_ok	int
;	O
}	O
static	O
enum	O
mu_filter_result	enum
_dq_decoder	function
(	O
void	O
*	O
xd	pointer
MU_ARG_UNUSED	O
,	O
enum	O
mu_filter_command	enum
cmd	enum
,	O
struct	O
mu_filter_io	struct
*	O
iobuf	pointer
)	O
{	O
size_t	long
i	long
,	O
j	long
;	O
const	O
unsigned	O
char	O
*	O
iptr	pointer
;	O
size_t	long
isize	long
;	O
char	O
*	O
optr	pointer
;	O
size_t	long
osize	long
;	O
switch	O
(	O
cmd	enum
)	O
{	O
case	O
mu_filter_init	int
:	O
case	O
mu_filter_done	int
:	O
return	O
mu_filter_ok	int
;	O
default	O
:	O
break	O
;	O
}	O
iptr	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
iobuf	pointer
->	O
input	pointer
;	O
isize	long
=	O
iobuf	pointer
->	O
isize	long
;	O
optr	pointer
=	O
iobuf	pointer
->	O
output	pointer
;	O
osize	long
=	O
iobuf	pointer
->	O
osize	long
;	O
for	O
(	O
i	long
=	O
j	long
=	O
0	int
;	O
i	long
<	O
isize	long
&&	O
j	long
<	O
osize	long
;	O
i	long
++	O
)	O
{	O
unsigned	O
char	O
c	int
=	O
*	O
iptr	pointer
++	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
if	O
(	O
i	long
+	O
1	int
==	O
isize	long
)	O
break	O
;	O
optr	pointer
[	O
j	long
++	O
]	O
=	O
*	O
iptr	pointer
++	O
;	O
}	O
else	O
optr	pointer
[	O
j	long
++	O
]	O
=	O
c	int
;	O
}	O
iobuf	pointer
->	O
isize	long
=	O
i	long
;	O
iobuf	pointer
->	O
osize	long
=	O
j	long
;	O
return	O
mu_filter_ok	int
;	O
}	O
static	O
struct	O
_mu_filter_record	struct
_dq_filter	struct
=	O
{	O
"dq"	pointer
,	O
NULL	O
,	O
_dq_encoder	function
,	O
_dq_decoder	function
,	O
}	O
;	O
mu_filter_record_t	pointer
mu_dq_filter	pointer
=	O
&	O
_dq_filter	struct
;	O
static	O
int	O
negate_filter_mode	function
(	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
==	O
MU_FILTER_DECODE	int
)	O
return	O
MU_FILTER_ENCODE	int
;	O
else	O
if	O
(	O
mode	int
==	O
MU_FILTER_ENCODE	int
)	O
return	O
MU_FILTER_DECODE	int
;	O
abort	function
(	O
)	O
;	O
}	O
static	O
int	O
_add_next_link	function
(	O
mu_stream_t	pointer
*	O
pret	pointer
,	O
mu_stream_t	pointer
transport	pointer
,	O
int	O
defmode	int
,	O
int	O
flags	int
,	O
size_t	long
argc	long
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
(	O
*	O
pred	pointer
)	O
(	O
void	O
*	O
,	O
mu_stream_t	pointer
,	O
const	O
char	O
*	O
)	O
,	O
void	O
*	O
closure	pointer
)	O
{	O
int	O
mode	int
;	O
int	O
qmark	int
=	O
0	int
;	O
char	O
*	O
fltname	pointer
;	O
int	O
status	int
=	O
0	int
;	O
fltname	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
if	O
(	O
fltname	pointer
[	O
0	int
]	O
==	O
'?'	O
)	O
{	O
if	O
(	O
pred	pointer
)	O
qmark	int
=	O
1	int
;	O
fltname	pointer
++	O
;	O
}	O
if	O
(	O
fltname	pointer
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
mode	int
=	O
negate_filter_mode	function
(	O
defmode	pointer
)	O
;	O
fltname	pointer
++	O
;	O
}	O
else	O
mode	int
=	O
defmode	int
;	O
if	O
(	O
qmark	int
==	O
0	int
||	O
pred	pointer
(	O
closure	pointer
,	O
transport	pointer
,	O
fltname	pointer
)	O
)	O
{	O
status	int
=	O
mu_filter_create_args	function
(	O
pret	pointer
,	O
transport	pointer
,	O
fltname	pointer
,	O
argc	long
,	O
(	O
const	O
char	O
*	O
*	O
)	O
argv	pointer
,	O
mode	int
,	O
flags	int
)	O
;	O
mu_stream_unref	function
(	O
transport	pointer
)	O
;	O
}	O
return	O
status	int
;	O
}	O
int	O
_filter_chain_create	function
(	O
mu_stream_t	pointer
*	O
pret	pointer
,	O
mu_stream_t	pointer
transport	pointer
,	O
int	O
defmode	int
,	O
int	O
flags	int
,	O
size_t	long
argc	long
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
(	O
*	O
pred	pointer
)	O
(	O
void	O
*	O
,	O
mu_stream_t	pointer
,	O
const	O
char	O
*	O
)	O
,	O
void	O
*	O
closure	pointer
)	O
{	O
while	O
(	O
argc	long
)	O
{	O
size_t	long
i	long
;	O
int	O
status	int
;	O
mu_stream_t	pointer
stream	pointer
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
argc	long
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	long
]	O
,	O
"+"	pointer
)	O
==	O
0	int
)	O
break	O
;	O
status	int
=	O
_add_next_link	function
(	O
&	O
stream	pointer
,	O
transport	pointer
,	O
defmode	pointer
,	O
flags	int
,	O
i	int
,	O
argv	pointer
,	O
pred	pointer
,	O
closure	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
transport	pointer
=	O
stream	pointer
;	O
argc	long
-=	O
i	long
;	O
argv	pointer
+=	O
i	long
;	O
if	O
(	O
argc	long
)	O
{	O
argc	long
--	O
;	O
argv	pointer
++	O
;	O
}	O
}	O
*	O
pret	pointer
=	O
transport	pointer
;	O
return	O
0	int
;	O
}	O
int	O
_filter_chain_create_rev	function
(	O
mu_stream_t	pointer
*	O
pret	pointer
,	O
mu_stream_t	pointer
transport	pointer
,	O
int	O
defmode	int
,	O
int	O
flags	int
,	O
size_t	long
argc	long
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
(	O
*	O
pred	pointer
)	O
(	O
void	O
*	O
,	O
mu_stream_t	pointer
,	O
const	O
char	O
*	O
)	O
,	O
void	O
*	O
closure	pointer
)	O
{	O
size_t	long
pos	long
;	O
for	O
(	O
pos	long
=	O
argc	long
;	O
pos	long
>	O
0	int
;	O
)	O
{	O
size_t	long
i	long
;	O
int	O
status	int
;	O
mu_stream_t	pointer
stream	pointer
;	O
for	O
(	O
i	long
=	O
pos	long
;	O
i	long
>	O
0	int
;	O
i	long
--	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	long
-	O
1	int
]	O
,	O
"+"	pointer
)	O
==	O
0	int
)	O
break	O
;	O
}	O
status	int
=	O
_add_next_link	function
(	O
&	O
stream	pointer
,	O
transport	pointer
,	O
defmode	pointer
,	O
flags	long
,	O
pos	long
-	O
i	long
,	O
argv	pointer
+	O
i	long
,	O
pred	pointer
,	O
closure	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
transport	pointer
=	O
stream	pointer
;	O
if	O
(	O
i	long
>	O
0	int
)	O
i	long
--	O
;	O
pos	long
=	O
i	long
;	O
}	O
*	O
pret	pointer
=	O
transport	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_filter_chain_create_pred	function
(	O
mu_stream_t	pointer
*	O
pret	pointer
,	O
mu_stream_t	pointer
transport	pointer
,	O
int	O
defmode	int
,	O
int	O
flags	int
,	O
size_t	long
argc	long
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
(	O
*	O
pred	pointer
)	O
(	O
void	O
*	O
,	O
mu_stream_t	pointer
,	O
const	O
char	O
*	O
)	O
,	O
void	O
*	O
closure	pointer
)	O
{	O
int	O
rc	int
;	O
mu_stream_ref	function
(	O
transport	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
MU_STREAM_WRITE	int
)	O
rc	int
=	O
_filter_chain_create_rev	function
(	O
pret	pointer
,	O
transport	pointer
,	O
defmode	pointer
,	O
flags	int
,	O
argc	int
,	O
argv	pointer
,	O
pred	pointer
,	O
closure	pointer
)	O
;	O
else	O
rc	int
=	O
_filter_chain_create	function
(	O
pret	pointer
,	O
transport	pointer
,	O
defmode	pointer
,	O
flags	int
,	O
argc	int
,	O
argv	pointer
,	O
pred	pointer
,	O
closure	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_stream_unref	function
(	O
transport	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_filter_chain_create	function
(	O
mu_stream_t	pointer
*	O
pret	pointer
,	O
mu_stream_t	pointer
transport	pointer
,	O
int	O
defmode	int
,	O
int	O
flags	int
,	O
size_t	long
argc	long
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
return	O
mu_filter_chain_create_pred	function
(	O
pret	pointer
,	O
transport	pointer
,	O
defmode	pointer
,	O
flags	int
,	O
argc	int
,	O
argv	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
struct	O
transcode_map	struct
{	O
const	O
char	O
*	O
ent	pointer
;	O
size_t	long
len	long
;	O
int	O
ch	int
;	O
}	O
;	O
static	O
struct	O
transcode_map	struct
transcode_map	array
[	O
]	O
=	O
{	O
{	O
S	pointer
(	O
"&amp;"	pointer
)	O
,	O
'&'	O
}	O
,	O
{	O
S	function
(	O
"&gt;"	pointer
)	O
,	O
'>'	O
}	O
,	O
{	O
S	function
(	O
"&lt;"	pointer
)	O
,	O
'<'	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
transcode_map	struct
*	O
ch2ent	function
(	O
int	O
c	int
)	O
{	O
struct	O
transcode_map	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
transcode_map	pointer
;	O
p	pointer
->	O
ent	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
p	pointer
->	O
ch	int
==	O
c	int
)	O
return	O
p	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
htmlent_encode_state	struct
{	O
char	O
buf	pointer
[	O
6	int
]	O
;	O
int	O
idx	int
;	O
}	O
;	O
static	O
enum	O
mu_filter_result	enum
_htmlent_encoder	function
(	O
void	O
*	O
xd	pointer
,	O
enum	O
mu_filter_command	enum
cmd	enum
,	O
struct	O
mu_filter_io	struct
*	O
iobuf	pointer
)	O
{	O
struct	O
htmlent_encode_state	struct
*	O
cp	pointer
=	O
xd	pointer
;	O
const	O
char	O
*	O
iptr	pointer
;	O
size_t	long
isize	long
;	O
char	O
*	O
optr	pointer
;	O
size_t	long
osize	long
;	O
switch	O
(	O
cmd	enum
)	O
{	O
case	O
mu_filter_init	int
:	O
cp	pointer
->	O
idx	int
=	O
-	O
1	int
;	O
return	O
mu_filter_ok	int
;	O
case	O
mu_filter_done	int
:	O
return	O
mu_filter_ok	int
;	O
default	O
:	O
break	O
;	O
}	O
iptr	pointer
=	O
iobuf	pointer
->	O
input	pointer
;	O
isize	long
=	O
iobuf	pointer
->	O
isize	long
;	O
optr	pointer
=	O
iobuf	pointer
->	O
output	pointer
;	O
osize	long
=	O
iobuf	pointer
->	O
osize	long
;	O
while	O
(	O
isize	long
&&	O
osize	long
)	O
{	O
if	O
(	O
cp	pointer
->	O
idx	long
>	O
0	int
)	O
{	O
*	O
optr	pointer
++	O
=	O
cp	pointer
->	O
buf	pointer
[	O
--	O
cp	pointer
->	O
idx	long
]	O
;	O
--	O
osize	long
;	O
}	O
else	O
{	O
struct	O
transcode_map	struct
*	O
p	pointer
;	O
int	O
c	int
=	O
*	O
iptr	pointer
++	O
;	O
--	O
isize	long
;	O
p	pointer
=	O
ch2ent	function
(	O
c	int
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
char	O
const	O
*	O
q	pointer
=	O
p	pointer
->	O
ent	pointer
+	O
p	pointer
->	O
len	long
;	O
cp	pointer
->	O
idx	long
=	O
0	int
;	O
while	O
(	O
q	pointer
>	O
p	pointer
->	O
ent	pointer
)	O
cp	pointer
->	O
buf	pointer
[	O
cp	pointer
->	O
idx	long
++	O
]	O
=	O
*	O
--	O
q	pointer
;	O
}	O
else	O
{	O
*	O
optr	pointer
++	O
=	O
c	int
;	O
--	O
osize	long
;	O
}	O
}	O
}	O
iobuf	pointer
->	O
isize	long
-=	O
isize	long
;	O
iobuf	pointer
->	O
osize	long
-=	O
osize	long
;	O
return	O
mu_filter_ok	int
;	O
}	O
enum	O
htmlent_decode_phase	enum
{	O
enc_init	int
,	O
enc_map	int
,	O
enc_rollback	int
,	O
enc_finish	int
}	O
;	O
struct	O
htmlent_decode_state	struct
{	O
enum	O
htmlent_decode_phase	enum
phase	enum
;	O
struct	O
transcode_map	struct
*	O
map	pointer
;	O
int	O
idx	int
;	O
int	O
pos	int
;	O
}	O
;	O
static	O
enum	O
htmlent_decode_phase	enum
nextchar	O
(	O
struct	O
htmlent_decode_state	struct
*	O
s	pointer
,	O
int	O
c	int
)	O
{	O
if	O
(	O
c	int
==	O
s	pointer
->	O
map	pointer
->	O
ent	pointer
[	O
s	pointer
->	O
idx	int
]	O
)	O
{	O
if	O
(	O
++	O
s	pointer
->	O
idx	int
==	O
s	pointer
->	O
map	pointer
->	O
len	int
)	O
s	pointer
->	O
phase	int
=	O
enc_finish	int
;	O
else	O
s	pointer
->	O
phase	pointer
=	O
enc_map	int
;	O
}	O
else	O
{	O
struct	O
transcode_map	struct
*	O
map	pointer
;	O
for	O
(	O
map	pointer
=	O
s	pointer
->	O
map	pointer
;	O
map	pointer
->	O
ent	pointer
&&	O
c	pointer
>	O
map	pointer
->	O
ent	pointer
[	O
s	pointer
->	O
idx	int
]	O
;	O
map	pointer
++	O
)	O
;	O
if	O
(	O
map	pointer
->	O
ent	pointer
==	O
NULL	O
||	O
c	int
!=	O
map	pointer
->	O
ent	pointer
[	O
s	pointer
->	O
idx	int
]	O
)	O
{	O
if	O
(	O
s	pointer
->	O
idx	int
!=	O
0	int
)	O
{	O
s	pointer
->	O
phase	long
=	O
enc_rollback	int
;	O
s	pointer
->	O
pos	long
=	O
0	int
;	O
}	O
else	O
DECODE_INIT	function
(	O
s	pointer
)	O
;	O
}	O
else	O
{	O
s	pointer
->	O
map	pointer
=	O
map	pointer
;	O
if	O
(	O
++	O
s	pointer
->	O
idx	int
==	O
s	pointer
->	O
map	pointer
->	O
len	int
)	O
s	pointer
->	O
phase	int
=	O
enc_finish	int
;	O
else	O
s	pointer
->	O
phase	int
=	O
enc_map	int
;	O
}	O
}	O
return	O
s	pointer
->	O
phase	int
;	O
}	O
static	O
enum	O
mu_filter_result	enum
_htmlent_decoder	function
(	O
void	O
*	O
xd	pointer
,	O
enum	O
mu_filter_command	enum
cmd	enum
,	O
struct	O
mu_filter_io	struct
*	O
iobuf	pointer
)	O
{	O
struct	O
htmlent_decode_state	struct
*	O
cp	pointer
=	O
xd	pointer
;	O
const	O
char	O
*	O
iptr	pointer
;	O
size_t	long
isize	long
;	O
char	O
*	O
optr	pointer
;	O
size_t	long
osize	long
;	O
switch	O
(	O
cmd	enum
)	O
{	O
case	O
mu_filter_init	int
:	O
DECODE_INIT	function
(	O
cp	pointer
)	O
;	O
return	O
mu_filter_ok	int
;	O
case	O
mu_filter_done	int
:	O
return	O
mu_filter_ok	int
;	O
default	O
:	O
break	O
;	O
}	O
iptr	pointer
=	O
iobuf	pointer
->	O
input	pointer
;	O
isize	long
=	O
iobuf	pointer
->	O
isize	long
;	O
optr	pointer
=	O
iobuf	pointer
->	O
output	pointer
;	O
osize	long
=	O
iobuf	pointer
->	O
osize	long
;	O
while	O
(	O
isize	long
&&	O
osize	long
)	O
{	O
switch	O
(	O
cp	pointer
->	O
phase	int
)	O
{	O
case	O
enc_init	int
:	O
nextchar	O
(	O
cp	pointer
,	O
*	O
iptr	pointer
)	O
;	O
if	O
(	O
cp	pointer
->	O
phase	int
==	O
enc_init	int
)	O
{	O
*	O
optr	pointer
++	O
=	O
*	O
iptr	pointer
;	O
--	O
osize	long
;	O
}	O
++	O
iptr	pointer
;	O
--	O
isize	long
;	O
break	O
;	O
case	O
enc_map	int
:	O
nextchar	O
(	O
cp	pointer
,	O
*	O
iptr	pointer
)	O
;	O
if	O
(	O
cp	pointer
->	O
phase	enum
==	O
enc_map	int
||	O
cp	pointer
->	O
phase	enum
==	O
enc_finish	int
)	O
{	O
++	O
iptr	pointer
;	O
--	O
isize	long
;	O
}	O
else	O
if	O
(	O
cp	pointer
->	O
phase	int
==	O
enc_init	int
)	O
{	O
*	O
optr	pointer
++	O
=	O
*	O
iptr	pointer
++	O
;	O
--	O
osize	long
;	O
--	O
isize	long
;	O
}	O
break	O
;	O
case	O
enc_finish	int
:	O
*	O
optr	pointer
++	O
=	O
cp	pointer
->	O
map	pointer
->	O
ch	char
;	O
--	O
osize	long
;	O
DECODE_INIT	function
(	O
cp	pointer
)	O
;	O
break	O
;	O
case	O
enc_rollback	int
:	O
*	O
optr	pointer
++	O
=	O
cp	pointer
->	O
map	pointer
->	O
ent	pointer
[	O
cp	pointer
->	O
pos	long
]	O
;	O
--	O
osize	long
;	O
if	O
(	O
++	O
cp	pointer
->	O
pos	long
==	O
cp	pointer
->	O
idx	int
)	O
DECODE_INIT	function
(	O
cp	pointer
)	O
;	O
break	O
;	O
}	O
}	O
iobuf	pointer
->	O
isize	long
-=	O
isize	long
;	O
iobuf	pointer
->	O
osize	long
-=	O
osize	long
;	O
return	O
mu_filter_ok	int
;	O
}	O
static	O
int	O
alloc_state	function
(	O
void	O
*	O
*	O
pret	pointer
,	O
int	O
mode	int
,	O
int	O
argc	int
MU_ARG_UNUSED	O
,	O
const	O
char	O
*	O
*	O
argv	pointer
MU_ARG_UNUSED	O
)	O
{	O
union	O
{	O
struct	O
htmlent_decode_state	struct
decode	pointer
;	O
struct	O
htmlent_encode_state	struct
encode	pointer
;	O
}	O
*	O
cp	pointer
;	O
switch	O
(	O
mode	int
)	O
{	O
case	O
MU_FILTER_ENCODE	int
:	O
cp	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
cp	pointer
->	O
encode	pointer
)	O
)	O
;	O
if	O
(	O
!	O
cp	pointer
)	O
return	O
ENOMEM	int
;	O
cp	pointer
->	O
encode	struct
.	O
idx	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
MU_FILTER_DECODE	int
:	O
cp	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
cp	pointer
->	O
decode	pointer
)	O
)	O
;	O
if	O
(	O
!	O
cp	pointer
)	O
return	O
ENOMEM	int
;	O
cp	pointer
->	O
decode	struct
.	O
idx	int
=	O
0	int
;	O
cp	pointer
->	O
decode	struct
.	O
map	pointer
=	O
transcode_map	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
*	O
pret	pointer
=	O
cp	pointer
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
_mu_filter_record	struct
_htmlent_filter	struct
=	O
{	O
"htmlent"	pointer
,	O
alloc_state	function
,	O
_htmlent_encoder	function
,	O
_htmlent_decoder	function
,	O
}	O
;	O
mu_filter_record_t	pointer
mu_htmlent_filter	pointer
=	O
&	O
_htmlent_filter	struct
;	O
struct	O
_mu_linelen_filter	struct
{	O
size_t	long
max_len	long
;	O
size_t	long
cur_len	long
;	O
}	O
;	O
static	O
enum	O
mu_filter_result	enum
_ll_encoder	function
(	O
void	O
*	O
xd	pointer
,	O
enum	O
mu_filter_command	enum
cmd	enum
,	O
struct	O
mu_filter_io	struct
*	O
iobuf	pointer
)	O
{	O
struct	O
_mu_linelen_filter	struct
*	O
flt	pointer
=	O
xd	pointer
;	O
const	O
char	O
*	O
iptr	pointer
;	O
size_t	long
isize	long
;	O
char	O
*	O
optr	pointer
;	O
size_t	long
osize	long
;	O
size_t	long
consumed	long
,	O
written	long
;	O
switch	O
(	O
cmd	enum
)	O
{	O
case	O
mu_filter_init	int
:	O
flt	pointer
->	O
cur_len	int
=	O
0	int
;	O
case	O
mu_filter_done	int
:	O
return	O
mu_filter_ok	int
;	O
default	O
:	O
break	O
;	O
}	O
iptr	pointer
=	O
iobuf	pointer
->	O
input	pointer
;	O
isize	long
=	O
iobuf	pointer
->	O
isize	long
;	O
optr	pointer
=	O
iobuf	pointer
->	O
output	pointer
;	O
osize	long
=	O
iobuf	pointer
->	O
osize	long
;	O
for	O
(	O
consumed	long
=	O
written	long
=	O
0	int
;	O
consumed	long
<	O
isize	long
&&	O
written	long
<	O
osize	long
;	O
)	O
{	O
char	O
*	O
p	pointer
;	O
size_t	long
rest	long
=	O
flt	pointer
->	O
max_len	pointer
-	O
flt	pointer
->	O
cur_len	int
;	O
size_t	long
len	long
=	O
isize	long
-	O
consumed	long
;	O
if	O
(	O
len	long
>	O
rest	long
)	O
len	long
=	O
rest	long
;	O
p	pointer
=	O
memchr	function
(	O
iptr	pointer
+	O
consumed	long
,	O
'\n'	O
,	O
len	long
)	O
;	O
if	O
(	O
p	pointer
)	O
len	long
=	O
p	pointer
-	O
iptr	pointer
-	O
consumed	long
+	O
1	int
;	O
rest	long
=	O
osize	long
-	O
written	long
;	O
if	O
(	O
len	long
>	O
rest	long
)	O
{	O
len	long
=	O
rest	long
;	O
p	pointer
=	O
NULL	O
;	O
}	O
memcpy	function
(	O
optr	pointer
+	O
written	long
,	O
iptr	pointer
+	O
consumed	long
,	O
len	long
)	O
;	O
written	long
+=	O
len	long
;	O
consumed	long
+=	O
len	long
;	O
if	O
(	O
p	pointer
)	O
flt	pointer
->	O
cur_len	int
=	O
0	int
;	O
else	O
{	O
flt	pointer
->	O
cur_len	long
+=	O
len	long
;	O
if	O
(	O
flt	pointer
->	O
cur_len	int
==	O
flt	pointer
->	O
max_len	int
)	O
{	O
if	O
(	O
written	long
<	O
osize	long
)	O
optr	pointer
[	O
written	long
++	O
]	O
=	O
'\n'	O
;	O
flt	pointer
->	O
cur_len	int
=	O
0	int
;	O
}	O
}	O
}	O
iobuf	pointer
->	O
isize	long
=	O
consumed	long
;	O
iobuf	pointer
->	O
osize	long
=	O
written	long
;	O
return	O
mu_filter_ok	int
;	O
}	O
int	O
mu_linelen_filter_create	function
(	O
mu_stream_t	pointer
*	O
pstream	pointer
,	O
mu_stream_t	pointer
stream	pointer
,	O
size_t	long
limit	long
,	O
int	O
flags	int
)	O
{	O
struct	O
_mu_linelen_filter	struct
*	O
flt	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
flt	pointer
)	O
)	O
;	O
if	O
(	O
!	O
flt	pointer
)	O
return	O
ENOMEM	int
;	O
flt	pointer
->	O
max_len	pointer
=	O
limit	pointer
;	O
return	O
mu_filter_stream_create	function
(	O
pstream	pointer
,	O
stream	pointer
,	O
MU_FILTER_ENCODE	int
,	O
_ll_encoder	int
,	O
flt	pointer
,	O
flags	int
)	O
;	O
}	O
static	O
int	O
alloc_state	function
(	O
void	O
*	O
*	O
pret	pointer
,	O
int	O
mode	int
MU_ARG_UNUSED	O
,	O
int	O
argc	int
,	O
const	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
struct	O
_mu_linelen_filter	struct
*	O
flt	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
flt	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
flt	pointer
)	O
return	O
ENOMEM	int
;	O
flt	pointer
->	O
cur_len	int
=	O
0	int
;	O
flt	pointer
->	O
max_len	int
=	O
76	int
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
char	O
*	O
p	pointer
;	O
flt	pointer
->	O
max_len	int
=	O
strtoul	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
free	function
(	O
flt	pointer
)	O
;	O
return	O
MU_ERR_PARSE	O
;	O
}	O
}	O
*	O
pret	pointer
=	O
flt	pointer
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
_mu_filter_record	struct
_linelen_filter	struct
=	O
{	O
"LINELEN"	pointer
,	O
alloc_state	function
,	O
_ll_encoder	function
,	O
NULL	O
,	O
}	O
;	O
mu_filter_record_t	pointer
mu_linelen_filter	pointer
=	O
&	O
_linelen_filter	struct
;	O
int	O
mu_imapio_send_msgset	function
(	O
mu_imapio_t	pointer
io	pointer
,	O
mu_msgset_t	pointer
msgset	pointer
)	O
{	O
return	O
mu_msgset_imap_print	function
(	O
io	pointer
->	O
_imap_stream	pointer
,	O
msgset	pointer
)	O
;	O
}	O
int	O
mu_imapio_get_streams	function
(	O
struct	O
_mu_imapio	struct
*	O
io	pointer
,	O
mu_stream_t	pointer
*	O
streams	pointer
)	O
{	O
int	O
rc	int
;	O
mu_stream_flush	function
(	O
io	pointer
->	O
_imap_stream	pointer
)	O
;	O
if	O
(	O
io	pointer
->	O
_imap_transcript	int
)	O
rc	int
=	O
mu_stream_ioctl	function
(	O
io	pointer
->	O
_imap_stream	pointer
,	O
MU_IOCTL_SUBSTREAM	int
,	O
MU_IOCTL_OP_GET	int
,	O
streams	pointer
)	O
;	O
else	O
{	O
streams	pointer
[	O
0	int
]	O
=	O
io	pointer
->	O
_imap_stream	pointer
;	O
mu_stream_ref	function
(	O
streams	pointer
[	O
0	int
]	O
)	O
;	O
streams	pointer
[	O
1	int
]	O
=	O
io	pointer
->	O
_imap_stream	pointer
;	O
mu_stream_ref	function
(	O
streams	pointer
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_imapio_set_streams	function
(	O
struct	O
_mu_imapio	struct
*	O
io	pointer
,	O
mu_stream_t	pointer
*	O
streams	pointer
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
io	pointer
->	O
_imap_transcript	int
)	O
rc	int
=	O
mu_stream_ioctl	function
(	O
io	pointer
->	O
_imap_stream	pointer
,	O
MU_IOCTL_SUBSTREAM	int
,	O
MU_IOCTL_OP_SET	int
,	O
streams	pointer
)	O
;	O
else	O
{	O
mu_stream_t	pointer
tmp	pointer
;	O
if	O
(	O
streams	pointer
[	O
0	int
]	O
==	O
streams	pointer
[	O
1	int
]	O
)	O
{	O
tmp	pointer
=	O
streams	pointer
[	O
0	int
]	O
;	O
mu_stream_ref	function
(	O
tmp	pointer
)	O
;	O
mu_stream_ref	function
(	O
tmp	pointer
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
else	O
rc	int
=	O
mu_iostream_create	function
(	O
&	O
tmp	pointer
,	O
streams	pointer
[	O
0	int
]	O
,	O
streams	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_stream_unref	function
(	O
io	pointer
->	O
_imap_stream	pointer
)	O
;	O
io	pointer
->	O
_imap_stream	pointer
=	O
tmp	pointer
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_list_to_array	function
(	O
mu_list_t	pointer
list	pointer
,	O
void	O
*	O
*	O
array	pointer
,	O
size_t	long
count	long
,	O
size_t	long
*	O
pcount	pointer
)	O
{	O
size_t	long
total	long
=	O
0	int
;	O
if	O
(	O
!	O
list	pointer
)	O
return	O
EINVAL	int
;	O
total	long
=	O
(	O
count	long
<	O
list	pointer
->	O
count	long
)	O
?	O
count	long
:	O
list	pointer
->	O
count	long
;	O
if	O
(	O
array	pointer
)	O
{	O
size_t	long
i	long
;	O
struct	O
list_data	struct
*	O
current	pointer
;	O
for	O
(	O
i	long
=	O
0	int
,	O
current	pointer
=	O
list	pointer
->	O
head	struct
.	O
next	pointer
;	O
i	long
<	O
total	long
&&	O
current	long
!=	O
&	O
list	pointer
->	O
head	struct
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
)	O
array	array
[	O
i	long
++	O
]	O
=	O
current	pointer
->	O
item	pointer
;	O
}	O
if	O
(	O
pcount	long
)	O
*	O
pcount	pointer
=	O
total	long
;	O
return	O
0	int
;	O
}	O
int	O
mu_list_fold	function
(	O
mu_list_t	pointer
list	pointer
,	O
mu_list_folder_t	pointer
fold	pointer
,	O
void	O
*	O
data	pointer
,	O
void	O
*	O
prev	pointer
,	O
void	O
*	O
return_value	pointer
)	O
{	O
struct	O
list_data	struct
*	O
current	pointer
;	O
int	O
status	int
=	O
0	int
;	O
if	O
(	O
list	pointer
==	O
NULL	O
||	O
fold	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
return_value	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
for	O
(	O
current	pointer
=	O
list	pointer
->	O
head	struct
.	O
next	pointer
;	O
current	pointer
!=	O
&	O
list	pointer
->	O
head	struct
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
)	O
{	O
status	int
=	O
fold	pointer
(	O
current	pointer
->	O
item	pointer
,	O
data	pointer
,	O
prev	pointer
,	O
&	O
prev	pointer
)	O
;	O
if	O
(	O
status	int
)	O
break	O
;	O
}	O
*	O
(	O
void	O
*	O
*	O
)	O
return_value	pointer
=	O
prev	pointer
;	O
return	O
status	int
;	O
}	O
int	O
mu_list_foreach_dir	function
(	O
mu_list_t	pointer
list	pointer
,	O
int	O
dir	int
,	O
mu_list_action_t	pointer
action	pointer
,	O
void	O
*	O
cbdata	pointer
)	O
{	O
mu_iterator_t	pointer
itr	pointer
;	O
int	O
status	int
=	O
0	int
;	O
if	O
(	O
list	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
action	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
status	int
=	O
mu_list_get_iterator	function
(	O
list	pointer
,	O
&	O
itr	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_iterator_ctl	function
(	O
itr	pointer
,	O
mu_itrctl_set_direction	int
,	O
&	O
dir	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
for	O
(	O
mu_iterator_first	function
(	O
itr	pointer
)	O
;	O
!	O
mu_iterator_is_done	function
(	O
itr	pointer
)	O
;	O
mu_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
void	O
*	O
item	pointer
;	O
mu_iterator_current	function
(	O
itr	pointer
,	O
&	O
item	pointer
)	O
;	O
if	O
(	O
(	O
status	int
=	O
action	pointer
(	O
item	pointer
,	O
cbdata	pointer
)	O
)	O
)	O
break	O
;	O
}	O
mu_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
return	O
status	int
;	O
}	O
struct	O
list_iterator	struct
{	O
mu_list_t	pointer
list	pointer
;	O
struct	O
list_data	struct
*	O
cur	pointer
;	O
int	O
backwards	int
;	O
}	O
;	O
static	O
int	O
first	function
(	O
void	O
*	O
owner	pointer
)	O
{	O
struct	O
list_iterator	struct
*	O
itr	pointer
=	O
owner	pointer
;	O
if	O
(	O
itr	pointer
->	O
backwards	int
)	O
itr	pointer
->	O
cur	pointer
=	O
itr	pointer
->	O
list	pointer
->	O
head	struct
.	O
prev	pointer
;	O
else	O
itr	pointer
->	O
cur	pointer
=	O
itr	pointer
->	O
list	pointer
->	O
head	struct
.	O
next	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
next	function
(	O
void	O
*	O
owner	pointer
)	O
{	O
struct	O
list_iterator	struct
*	O
itr	pointer
=	O
owner	pointer
;	O
if	O
(	O
itr	pointer
->	O
backwards	int
)	O
itr	pointer
->	O
cur	pointer
=	O
itr	pointer
->	O
cur	pointer
->	O
prev	pointer
;	O
else	O
itr	pointer
->	O
cur	pointer
=	O
itr	pointer
->	O
cur	pointer
->	O
next	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
getitem	function
(	O
void	O
*	O
owner	pointer
,	O
void	O
*	O
*	O
pret	pointer
,	O
const	O
void	O
*	O
*	O
pkey	pointer
)	O
{	O
struct	O
list_iterator	struct
*	O
itr	pointer
=	O
owner	pointer
;	O
*	O
pret	pointer
=	O
itr	pointer
->	O
cur	pointer
->	O
item	pointer
;	O
if	O
(	O
pkey	pointer
)	O
*	O
pkey	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
finished_p	function
(	O
void	O
*	O
owner	pointer
)	O
{	O
struct	O
list_iterator	struct
*	O
itr	pointer
=	O
owner	pointer
;	O
return	O
itr	pointer
->	O
cur	pointer
==	O
&	O
itr	pointer
->	O
list	pointer
->	O
head	pointer
;	O
}	O
static	O
int	O
destroy	function
(	O
mu_iterator_t	pointer
iterator	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
list_iterator	struct
*	O
itr	pointer
=	O
data	pointer
;	O
mu_iterator_detach	function
(	O
&	O
itr	pointer
->	O
list	pointer
->	O
itr	pointer
,	O
iterator	pointer
)	O
;	O
free	function
(	O
data	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
delitem	function
(	O
void	O
*	O
owner	pointer
,	O
void	O
*	O
item	pointer
)	O
{	O
struct	O
list_iterator	struct
*	O
itr	pointer
=	O
owner	pointer
;	O
return	O
itr	pointer
->	O
cur	pointer
==	O
item	pointer
?	O
MU_ITR_DELITEM_NEXT	int
:	O
MU_ITR_DELITEM_NOTHING	int
;	O
}	O
static	O
int	O
list_data_dup	function
(	O
void	O
*	O
*	O
ptr	pointer
,	O
void	O
*	O
owner	pointer
)	O
{	O
*	O
ptr	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
list_iterator	struct
)	O
)	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
memcpy	function
(	O
*	O
ptr	pointer
,	O
owner	pointer
,	O
sizeof	O
(	O
struct	O
list_iterator	struct
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
list_itrctl	function
(	O
void	O
*	O
owner	pointer
,	O
enum	O
mu_itrctl_req	enum
req	enum
,	O
void	O
*	O
arg	pointer
)	O
{	O
struct	O
list_iterator	struct
*	O
itr	pointer
=	O
owner	pointer
;	O
mu_list_t	pointer
list	pointer
=	O
itr	pointer
->	O
list	pointer
;	O
struct	O
list_data	struct
*	O
ptr	pointer
;	O
switch	O
(	O
req	enum
)	O
{	O
case	O
mu_itrctl_tell	int
:	O
if	O
(	O
itr	pointer
->	O
cur	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_NOENT	O
;	O
else	O
{	O
size_t	long
count	long
;	O
for	O
(	O
count	long
=	O
0	int
,	O
ptr	pointer
=	O
list	pointer
->	O
head	struct
.	O
next	pointer
;	O
ptr	pointer
!=	O
&	O
list	pointer
->	O
head	struct
;	O
ptr	pointer
=	O
ptr	pointer
->	O
next	pointer
,	O
count	long
++	O
)	O
{	O
if	O
(	O
ptr	pointer
==	O
itr	pointer
->	O
cur	pointer
)	O
{	O
*	O
(	O
size_t	long
*	O
)	O
arg	pointer
=	O
count	long
;	O
return	O
0	int
;	O
}	O
}	O
return	O
MU_ERR_NOENT	O
;	O
}	O
break	O
;	O
case	O
mu_itrctl_delete	int
:	O
case	O
mu_itrctl_delete_nd	int
:	O
if	O
(	O
itr	pointer
->	O
cur	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_NOENT	O
;	O
else	O
{	O
struct	O
list_data	struct
*	O
prev	pointer
;	O
ptr	pointer
=	O
itr	pointer
->	O
cur	pointer
;	O
prev	pointer
=	O
ptr	pointer
->	O
prev	pointer
;	O
mu_iterator_delitem	function
(	O
list	pointer
->	O
itr	pointer
,	O
ptr	pointer
)	O
;	O
prev	pointer
->	O
next	pointer
=	O
ptr	pointer
->	O
next	pointer
;	O
ptr	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
prev	pointer
;	O
if	O
(	O
req	pointer
==	O
mu_itrctl_delete	int
)	O
DESTROY_ITEM	O
(	O
list	pointer
,	O
ptr	pointer
)	O
;	O
free	function
(	O
ptr	pointer
)	O
;	O
list	pointer
->	O
count	long
--	O
;	O
}	O
break	O
;	O
case	O
mu_itrctl_replace	int
:	O
case	O
mu_itrctl_replace_nd	int
:	O
if	O
(	O
itr	pointer
->	O
cur	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_NOENT	O
;	O
if	O
(	O
!	O
arg	pointer
)	O
return	O
EINVAL	int
;	O
ptr	pointer
=	O
itr	pointer
->	O
cur	pointer
;	O
if	O
(	O
req	pointer
==	O
mu_itrctl_replace	pointer
)	O
DESTROY_ITEM	O
(	O
list	pointer
,	O
ptr	pointer
)	O
;	O
ptr	pointer
=	O
itr	pointer
->	O
cur	pointer
;	O
ptr	pointer
->	O
item	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
mu_itrctl_insert	int
:	O
if	O
(	O
itr	pointer
->	O
cur	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_NOENT	O
;	O
if	O
(	O
!	O
arg	pointer
)	O
return	O
EINVAL	int
;	O
return	O
_mu_list_insert_item	function
(	O
list	pointer
,	O
itr	pointer
->	O
cur	pointer
,	O
arg	pointer
,	O
0	int
)	O
;	O
case	O
mu_itrctl_insert_list	int
:	O
if	O
(	O
itr	pointer
->	O
cur	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_NOENT	O
;	O
if	O
(	O
!	O
arg	pointer
)	O
return	O
EINVAL	int
;	O
else	O
{	O
mu_list_t	pointer
new_list	pointer
=	O
arg	pointer
;	O
_mu_list_insert_sublist	function
(	O
list	pointer
,	O
itr	pointer
->	O
cur	pointer
,	O
new_list	pointer
->	O
head	struct
.	O
next	pointer
,	O
new_list	pointer
->	O
head	struct
.	O
prev	pointer
,	O
new_list	pointer
->	O
count	long
,	O
0	int
)	O
;	O
_mu_list_clear	function
(	O
new_list	pointer
)	O
;	O
}	O
break	O
;	O
case	O
mu_itrctl_qry_direction	int
:	O
if	O
(	O
!	O
arg	pointer
)	O
return	O
EINVAL	int
;	O
else	O
*	O
(	O
int	O
*	O
)	O
arg	pointer
=	O
itr	pointer
->	O
backwards	int
;	O
break	O
;	O
case	O
mu_itrctl_set_direction	int
:	O
if	O
(	O
!	O
arg	pointer
)	O
return	O
EINVAL	int
;	O
else	O
itr	pointer
->	O
backwards	int
=	O
!	O
!	O
*	O
(	O
int	O
*	O
)	O
arg	pointer
;	O
break	O
;	O
case	O
mu_itrctl_count	int
:	O
if	O
(	O
!	O
arg	pointer
)	O
return	O
EINVAL	int
;	O
return	O
mu_list_count	function
(	O
itr	pointer
->	O
list	pointer
,	O
arg	pointer
)	O
;	O
default	O
:	O
return	O
ENOSYS	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_list_get_iterator	function
(	O
mu_list_t	pointer
list	pointer
,	O
mu_iterator_t	pointer
*	O
piterator	pointer
)	O
{	O
mu_iterator_t	pointer
iterator	pointer
;	O
int	O
status	int
;	O
struct	O
list_iterator	struct
*	O
itr	pointer
;	O
if	O
(	O
!	O
list	pointer
)	O
return	O
EINVAL	int
;	O
itr	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
*	O
itr	pointer
)	O
;	O
if	O
(	O
!	O
itr	pointer
)	O
return	O
ENOMEM	int
;	O
itr	pointer
->	O
list	pointer
=	O
list	pointer
;	O
itr	pointer
->	O
cur	pointer
=	O
NULL	O
;	O
status	int
=	O
mu_iterator_create	function
(	O
&	O
iterator	pointer
,	O
itr	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
itr	pointer
)	O
;	O
return	O
status	int
;	O
}	O
mu_iterator_set_first	function
(	O
iterator	pointer
,	O
first	function
)	O
;	O
mu_iterator_set_next	function
(	O
iterator	pointer
,	O
next	pointer
)	O
;	O
mu_iterator_set_getitem	function
(	O
iterator	pointer
,	O
getitem	function
)	O
;	O
mu_iterator_set_finished_p	function
(	O
iterator	pointer
,	O
finished_p	function
)	O
;	O
mu_iterator_set_delitem	function
(	O
iterator	pointer
,	O
delitem	function
)	O
;	O
mu_iterator_set_destroy	function
(	O
iterator	pointer
,	O
destroy	function
)	O
;	O
mu_iterator_set_dup	function
(	O
iterator	pointer
,	O
list_data_dup	function
)	O
;	O
mu_iterator_set_itrctl	function
(	O
iterator	pointer
,	O
list_itrctl	function
)	O
;	O
mu_iterator_attach	function
(	O
&	O
list	pointer
->	O
itr	pointer
,	O
iterator	pointer
)	O
;	O
*	O
piterator	pointer
=	O
iterator	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_list_pop	function
(	O
mu_list_t	pointer
list	pointer
,	O
void	O
*	O
*	O
item	pointer
)	O
{	O
struct	O
list_data	struct
*	O
last	pointer
,	O
*	O
prev	pointer
;	O
if	O
(	O
list	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
list	pointer
->	O
count	long
==	O
0	int
)	O
return	O
MU_ERR_NOENT	O
;	O
last	pointer
=	O
list	pointer
->	O
head	struct
.	O
prev	pointer
;	O
prev	pointer
=	O
last	pointer
->	O
prev	pointer
;	O
mu_iterator_delitem	function
(	O
list	pointer
->	O
itr	pointer
,	O
last	pointer
)	O
;	O
prev	pointer
->	O
next	pointer
=	O
last	pointer
->	O
next	pointer
;	O
prev	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
prev	pointer
;	O
if	O
(	O
item	pointer
)	O
*	O
item	pointer
=	O
last	pointer
->	O
item	pointer
;	O
else	O
DESTROY_ITEM	O
(	O
list	pointer
,	O
last	pointer
)	O
;	O
free	function
(	O
last	pointer
)	O
;	O
list	pointer
->	O
count	long
--	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_list_remove	function
(	O
mu_list_t	pointer
list	pointer
,	O
const	O
void	O
*	O
item	pointer
)	O
{	O
struct	O
list_data	struct
*	O
current	pointer
;	O
mu_list_comparator_t	pointer
comp	pointer
;	O
int	O
status	int
=	O
MU_ERR_NOENT	O
;	O
if	O
(	O
list	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
comp	pointer
=	O
list	pointer
->	O
comp	pointer
?	O
list	pointer
->	O
comp	pointer
:	O
_mu_list_ptr_comparator	function
;	O
mu_monitor_wrlock	function
(	O
list	pointer
->	O
monitor	pointer
)	O
;	O
for	O
(	O
current	pointer
=	O
list	pointer
->	O
head	struct
.	O
next	pointer
;	O
current	pointer
!=	O
&	O
list	pointer
->	O
head	struct
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
comp	pointer
(	O
current	pointer
->	O
item	pointer
,	O
item	pointer
)	O
==	O
0	int
)	O
{	O
struct	O
list_data	struct
*	O
previous	pointer
=	O
current	pointer
->	O
prev	pointer
;	O
mu_iterator_delitem	function
(	O
list	pointer
->	O
itr	pointer
,	O
current	pointer
)	O
;	O
previous	pointer
->	O
next	pointer
=	O
current	pointer
->	O
next	pointer
;	O
current	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
previous	pointer
;	O
DESTROY_ITEM	O
(	O
list	pointer
,	O
current	pointer
)	O
;	O
free	function
(	O
current	pointer
)	O
;	O
list	pointer
->	O
count	long
--	O
;	O
status	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
mu_monitor_unlock	function
(	O
list	pointer
->	O
monitor	pointer
)	O
;	O
return	O
status	int
;	O
}	O
int	O
mu_list_remove_nd	function
(	O
mu_list_t	pointer
list	pointer
,	O
const	O
void	O
*	O
item	pointer
)	O
{	O
mu_list_destroy_item_t	pointer
dptr	pointer
=	O
mu_list_set_destroy_item	function
(	O
list	pointer
,	O
NULL	O
)	O
;	O
int	O
rc	int
=	O
mu_list_remove	function
(	O
list	pointer
,	O
item	pointer
)	O
;	O
mu_list_set_destroy_item	function
(	O
list	pointer
,	O
dptr	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_list_slice2_dup	function
(	O
mu_list_t	pointer
*	O
pdest	pointer
,	O
mu_list_t	pointer
list	pointer
,	O
size_t	long
from	pointer
,	O
size_t	long
to	long
,	O
int	O
(	O
*	O
dup_item	pointer
)	O
(	O
void	O
*	O
*	O
,	O
void	O
*	O
,	O
void	O
*	O
)	O
,	O
void	O
*	O
dup_data	pointer
)	O
{	O
size_t	long
arr	pointer
[	O
2	int
]	O
=	O
{	O
from	pointer
,	O
to	pointer
}	O
;	O
return	O
mu_list_slice_dup	function
(	O
pdest	pointer
,	O
list	pointer
,	O
arr	pointer
,	O
2	int
,	O
dup_item	pointer
,	O
dup_data	pointer
)	O
;	O
}	O
int	O
mu_list_slice2	function
(	O
mu_list_t	pointer
*	O
pdest	pointer
,	O
mu_list_t	pointer
list	pointer
,	O
size_t	long
from	pointer
,	O
size_t	long
to	long
)	O
{	O
return	O
mu_list_slice2_dup	function
(	O
pdest	pointer
,	O
list	pointer
,	O
from	pointer
,	O
to	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
int	O
mu_locus_point_set_file	function
(	O
struct	O
mu_locus_point	struct
*	O
pt	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
int	O
rc	int
;	O
char	O
const	O
*	O
ref	pointer
;	O
rc	int
=	O
mu_ident_ref	function
(	O
filename	pointer
,	O
&	O
ref	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_ident_deref	function
(	O
pt	pointer
->	O
mu_file	pointer
)	O
;	O
pt	pointer
->	O
mu_file	pointer
=	O
ref	pointer
;	O
return	O
0	int
;	O
}	O
void	O
mu_locus_point_init	function
(	O
struct	O
mu_locus_point	struct
*	O
pt	pointer
)	O
{	O
memset	function
(	O
pt	pointer
,	O
0	int
,	O
sizeof	O
*	O
pt	pointer
)	O
;	O
}	O
void	O
mu_locus_point_deinit	function
(	O
struct	O
mu_locus_point	struct
*	O
pt	pointer
)	O
{	O
mu_ident_deref	function
(	O
pt	pointer
->	O
mu_file	pointer
)	O
;	O
memset	function
(	O
pt	pointer
,	O
0	int
,	O
sizeof	O
*	O
pt	pointer
)	O
;	O
}	O
int	O
mu_locus_point_copy	function
(	O
struct	O
mu_locus_point	struct
*	O
dest	pointer
,	O
struct	O
mu_locus_point	struct
const	O
*	O
src	pointer
)	O
{	O
int	O
rc	int
=	O
mu_locus_point_set_file	function
(	O
dest	pointer
,	O
src	pointer
->	O
mu_file	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
dest	pointer
->	O
mu_col	int
=	O
src	pointer
->	O
mu_col	int
;	O
dest	pointer
->	O
mu_line	int
=	O
src	pointer
->	O
mu_line	int
;	O
}	O
return	O
rc	int
;	O
}	O
void	O
mu_locus_range_init	function
(	O
struct	O
mu_locus_range	struct
*	O
dest	pointer
)	O
{	O
memset	function
(	O
dest	pointer
,	O
0	int
,	O
sizeof	O
*	O
dest	pointer
)	O
;	O
}	O
int	O
mu_locus_range_copy	function
(	O
struct	O
mu_locus_range	struct
*	O
dest	pointer
,	O
struct	O
mu_locus_range	struct
const	O
*	O
src	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_locus_range	struct
tmp	pointer
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
if	O
(	O
!	O
dest	pointer
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
rc	int
=	O
mu_locus_point_copy	function
(	O
&	O
tmp	pointer
.	O
beg	struct
,	O
&	O
src	pointer
->	O
beg	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
rc	int
=	O
mu_locus_point_copy	function
(	O
&	O
tmp	pointer
.	O
end	pointer
,	O
&	O
src	pointer
->	O
end	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_locus_point_deinit	function
(	O
&	O
tmp	struct
.	O
beg	struct
)	O
;	O
else	O
{	O
mu_locus_range_deinit	function
(	O
dest	pointer
)	O
;	O
*	O
dest	pointer
=	O
tmp	pointer
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
void	O
mu_locus_range_deinit	function
(	O
struct	O
mu_locus_range	struct
*	O
lr	pointer
)	O
{	O
mu_locus_point_deinit	function
(	O
&	O
lr	pointer
->	O
beg	struct
)	O
;	O
mu_locus_point_deinit	function
(	O
&	O
lr	pointer
->	O
end	struct
)	O
;	O
}	O
int	O
mu_header_sget_firstof	function
(	O
mu_header_t	pointer
hdr	pointer
,	O
char	O
*	O
*	O
names	pointer
,	O
const	O
char	O
*	O
*	O
pval	pointer
,	O
int	O
*	O
pidx	pointer
)	O
{	O
int	O
status	int
;	O
const	O
char	O
*	O
s	pointer
=	O
NULL	O
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
names	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
status	int
=	O
mu_header_sget_value	O
(	O
hdr	pointer
,	O
names	pointer
[	O
i	int
]	O
,	O
&	O
s	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
&&	O
*	O
s	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
pval	pointer
)	O
*	O
pval	pointer
=	O
s	pointer
;	O
if	O
(	O
pidx	pointer
)	O
*	O
pidx	pointer
=	O
i	int
;	O
return	O
0	int
;	O
}	O
}	O
return	O
MU_ERR_NOENT	O
;	O
}	O
void	O
mu_message_imapenvelope_free	function
(	O
struct	O
mu_imapenvelope	struct
*	O
env	pointer
)	O
{	O
if	O
(	O
!	O
env	pointer
)	O
return	O
;	O
free	function
(	O
env	pointer
->	O
subject	pointer
)	O
;	O
mu_address_destroy	function
(	O
&	O
env	pointer
->	O
from	pointer
)	O
;	O
mu_address_destroy	function
(	O
&	O
env	pointer
->	O
sender	pointer
)	O
;	O
mu_address_destroy	function
(	O
&	O
env	pointer
->	O
reply_to	pointer
)	O
;	O
mu_address_destroy	function
(	O
&	O
env	pointer
->	O
to	pointer
)	O
;	O
mu_address_destroy	function
(	O
&	O
env	pointer
->	O
cc	pointer
)	O
;	O
mu_address_destroy	function
(	O
&	O
env	pointer
->	O
bcc	pointer
)	O
;	O
free	function
(	O
env	pointer
->	O
in_reply_to	pointer
)	O
;	O
free	function
(	O
env	pointer
->	O
message_id	pointer
)	O
;	O
free	function
(	O
env	pointer
)	O
;	O
}	O
int	O
mu_message_get_imapenvelope	function
(	O
mu_message_t	pointer
msg	pointer
,	O
struct	O
mu_imapenvelope	struct
*	O
*	O
pimapenvelope	pointer
)	O
{	O
struct	O
mu_imapenvelope	struct
*	O
imapenvelope	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
msg	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
pimapenvelope	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
if	O
(	O
msg	pointer
->	O
_imapenvelope	pointer
)	O
return	O
msg	pointer
->	O
_imapenvelope	pointer
(	O
msg	pointer
,	O
pimapenvelope	pointer
)	O
;	O
imapenvelope	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
imapenvelope	array
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
imapenvelope	pointer
)	O
return	O
ENOMEM	int
;	O
do	O
{	O
mu_header_t	pointer
hdr	pointer
;	O
mu_envelope_t	pointer
env	pointer
;	O
const	O
char	O
*	O
s	pointer
;	O
if	O
(	O
(	O
rc	int
=	O
mu_message_get_envelope	function
(	O
msg	pointer
,	O
&	O
env	pointer
)	O
)	O
)	O
break	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_envelope_sget_date	function
(	O
env	pointer
,	O
&	O
s	pointer
)	O
)	O
)	O
break	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_scan_datetime	function
(	O
s	pointer
,	O
MU_DATETIME_FROM	pointer
,	O
&	O
imapenvelope	pointer
->	O
date	struct
,	O
&	O
imapenvelope	pointer
->	O
tz	pointer
,	O
NULL	O
)	O
)	O
)	O
break	O
;	O
if	O
(	O
(	O
rc	int
=	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
hdr	pointer
)	O
)	O
)	O
break	O
;	O
rc	int
=	O
mu_header_get_address	function
(	O
hdr	pointer
,	O
MU_HEADER_FROM	pointer
,	O
&	O
imapenvelope	pointer
->	O
from	pointer
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
MU_ERR_NOENT	O
)	O
break	O
;	O
rc	int
=	O
mu_header_get_address	function
(	O
hdr	pointer
,	O
MU_HEADER_SENDER	pointer
,	O
&	O
imapenvelope	pointer
->	O
sender	pointer
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
MU_ERR_NOENT	O
)	O
break	O
;	O
rc	int
=	O
mu_header_get_address	function
(	O
hdr	pointer
,	O
MU_HEADER_REPLY_TO	pointer
,	O
&	O
imapenvelope	pointer
->	O
reply_to	pointer
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
MU_ERR_NOENT	O
)	O
break	O
;	O
rc	int
=	O
mu_header_get_address	function
(	O
hdr	pointer
,	O
MU_HEADER_TO	pointer
,	O
&	O
imapenvelope	pointer
->	O
to	pointer
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
MU_ERR_NOENT	O
)	O
break	O
;	O
rc	int
=	O
mu_header_get_address	function
(	O
hdr	pointer
,	O
MU_HEADER_CC	pointer
,	O
&	O
imapenvelope	pointer
->	O
cc	pointer
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
MU_ERR_NOENT	O
)	O
break	O
;	O
rc	int
=	O
mu_header_get_address	function
(	O
hdr	pointer
,	O
MU_HEADER_BCC	pointer
,	O
&	O
imapenvelope	pointer
->	O
bcc	pointer
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
MU_ERR_NOENT	O
)	O
break	O
;	O
rc	int
=	O
mu_header_aget_value_unfold	function
(	O
hdr	pointer
,	O
MU_HEADER_SUBJECT	pointer
,	O
&	O
imapenvelope	pointer
->	O
subject	pointer
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
MU_ERR_NOENT	O
)	O
break	O
;	O
rc	int
=	O
mu_header_aget_value_unfold	function
(	O
hdr	pointer
,	O
MU_HEADER_IN_REPLY_TO	pointer
,	O
&	O
imapenvelope	pointer
->	O
in_reply_to	pointer
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
MU_ERR_NOENT	O
)	O
break	O
;	O
rc	int
=	O
mu_header_aget_value_unfold	function
(	O
hdr	pointer
,	O
MU_HEADER_MESSAGE_ID	pointer
,	O
&	O
imapenvelope	pointer
->	O
message_id	pointer
)	O
;	O
}	O
while	O
(	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
mu_message_imapenvelope_free	function
(	O
imapenvelope	pointer
)	O
;	O
else	O
*	O
pimapenvelope	pointer
=	O
imapenvelope	pointer
;	O
return	O
rc	int
;	O
}	O
int	O
mu_message_set_imapenvelope	function
(	O
mu_message_t	pointer
msg	pointer
,	O
int	O
(	O
*	O
_imapenvelope	pointer
)	O
(	O
mu_message_t	pointer
,	O
struct	O
mu_imapenvelope	struct
*	O
*	O
)	O
,	O
void	O
*	O
owner	pointer
)	O
{	O
if	O
(	O
msg	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
msg	pointer
->	O
owner	pointer
!=	O
owner	pointer
)	O
return	O
EACCES	int
;	O
msg	pointer
->	O
_imapenvelope	pointer
=	O
_imapenvelope	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_message_get_body	function
(	O
mu_message_t	pointer
msg	pointer
,	O
mu_body_t	pointer
*	O
pbody	pointer
)	O
{	O
if	O
(	O
msg	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
pbody	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
if	O
(	O
msg	pointer
->	O
body	pointer
==	O
NULL	O
)	O
{	O
mu_body_t	pointer
body	pointer
;	O
int	O
status	int
=	O
mu_body_create	function
(	O
&	O
body	pointer
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
status	int
;	O
if	O
(	O
msg	pointer
->	O
rawstream	pointer
)	O
{	O
mu_stream_t	pointer
stream	pointer
;	O
int	O
flags	int
=	O
0	int
;	O
mu_stream_get_flags	function
(	O
msg	pointer
->	O
rawstream	pointer
,	O
&	O
flags	int
)	O
;	O
status	int
=	O
mu_streamref_create_abridged	function
(	O
&	O
stream	pointer
,	O
msg	pointer
->	O
rawstream	pointer
,	O
msg	pointer
->	O
orig_header_size	long
,	O
0	int
)	O
;	O
if	O
(	O
status	int
)	O
{	O
mu_body_destroy	function
(	O
&	O
body	pointer
,	O
msg	pointer
)	O
;	O
return	O
status	int
;	O
}	O
mu_body_set_stream	function
(	O
body	pointer
,	O
stream	pointer
,	O
msg	pointer
)	O
;	O
}	O
msg	pointer
->	O
body	pointer
=	O
body	pointer
;	O
}	O
*	O
pbody	pointer
=	O
msg	pointer
->	O
body	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_message_set_body	function
(	O
mu_message_t	pointer
msg	pointer
,	O
mu_body_t	pointer
body	pointer
,	O
void	O
*	O
owner	pointer
)	O
{	O
if	O
(	O
msg	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
msg	pointer
->	O
owner	pointer
!=	O
owner	pointer
)	O
return	O
EACCES	int
;	O
if	O
(	O
msg	pointer
->	O
body	pointer
)	O
mu_body_destroy	function
(	O
&	O
msg	pointer
->	O
body	pointer
,	O
msg	pointer
)	O
;	O
msg	pointer
->	O
body	pointer
=	O
body	pointer
;	O
msg	pointer
->	O
flags	int
|=	O
MESSAGE_MODIFIED	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_message_create	function
(	O
mu_message_t	pointer
*	O
pmsg	pointer
,	O
void	O
*	O
owner	pointer
)	O
{	O
mu_message_t	pointer
msg	pointer
;	O
int	O
status	int
;	O
if	O
(	O
pmsg	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
msg	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
msg	pointer
)	O
)	O
;	O
if	O
(	O
msg	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
status	int
=	O
mu_monitor_create	function
(	O
&	O
msg	pointer
->	O
monitor	pointer
,	O
0	int
,	O
msg	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
free	function
(	O
msg	pointer
)	O
;	O
return	O
status	int
;	O
}	O
msg	pointer
->	O
owner	pointer
=	O
owner	pointer
;	O
msg	pointer
->	O
ref_count	int
=	O
1	int
;	O
*	O
pmsg	pointer
=	O
msg	pointer
;	O
return	O
0	int
;	O
}	O
void	O
*	O
mu_message_get_owner	function
(	O
mu_message_t	pointer
msg	pointer
)	O
{	O
return	O
(	O
msg	pointer
==	O
NULL	O
)	O
?	O
NULL	O
:	O
msg	pointer
->	O
owner	pointer
;	O
}	O
int	O
mu_message_save_to_mailbox	function
(	O
mu_message_t	pointer
msg	pointer
,	O
const	O
char	O
*	O
toname	pointer
,	O
int	O
perms	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
mu_mailbox_t	pointer
to	pointer
=	O
0	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_create_default	function
(	O
&	O
to	pointer
,	O
toname	pointer
)	O
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MESSAGE	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"mu_mailbox_create_default (%s) failed: %s\n"	pointer
,	O
toname	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
goto	O
end	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_open	function
(	O
to	pointer
,	O
MU_STREAM_APPEND	int
|	O
MU_STREAM_CREAT	int
|	O
(	O
perms	int
&	O
MU_STREAM_IMASK	int
)	O
)	O
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MESSAGE	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"mu_mailbox_open (%s) failed: %s"	pointer
,	O
toname	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
goto	O
end	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_append_message	function
(	O
to	pointer
,	O
msg	pointer
)	O
)	O
)	O
{	O
mu_debug	O
(	O
MU_DEBCAT_MESSAGE	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"mu_mailbox_append_message (%s) failed: %s"	pointer
,	O
toname	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
goto	O
end	O
;	O
}	O
end	pointer
:	O
if	O
(	O
!	O
rc	int
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
mu_mailbox_close	function
(	O
to	pointer
)	O
)	O
)	O
mu_debug	O
(	O
MU_DEBCAT_MESSAGE	int
,	O
MU_DEBUG_ERROR	int
,	O
(	O
"mu_mailbox_close (%s) failed: %s"	pointer
,	O
toname	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
else	O
mu_mailbox_close	function
(	O
to	pointer
)	O
;	O
mu_mailbox_destroy	function
(	O
&	O
to	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_stream_scan_message	function
(	O
mu_stream_t	pointer
stream	pointer
,	O
struct	O
mu_message_scan	struct
*	O
sp	pointer
)	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
mu_off_t	long
off	long
;	O
size_t	long
n	long
;	O
int	O
status	int
;	O
int	O
in_header	int
=	O
1	int
;	O
size_t	long
hlines	long
=	O
0	int
;	O
size_t	long
blines	long
=	O
0	int
;	O
size_t	long
body_start	long
=	O
0	int
;	O
int	O
attr_flags	int
=	O
0	int
;	O
unsigned	O
long	O
uidvalidity	long
=	O
0	int
;	O
if	O
(	O
sp	pointer
->	O
flags	int
&	O
MU_SCAN_SEEK	int
)	O
{	O
status	int
=	O
mu_stream_seek	function
(	O
stream	pointer
,	O
sp	pointer
->	O
message_start	pointer
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
}	O
off	long
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
size_t	long
rdsize	long
;	O
status	int
=	O
mu_stream_readline	function
(	O
stream	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
&	O
n	long
)	O
;	O
if	O
(	O
status	int
||	O
n	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
sp	pointer
->	O
flags	int
&	O
MU_SCAN_SIZE	int
)	O
{	O
rdsize	long
=	O
sp	pointer
->	O
message_size	long
-	O
off	long
;	O
if	O
(	O
n	long
>	O
rdsize	long
)	O
n	int
=	O
rdsize	long
;	O
}	O
if	O
(	O
in_header	int
)	O
{	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
'\n'	O
)	O
{	O
in_header	int
=	O
0	int
;	O
body_start	long
=	O
off	long
+	O
1	int
;	O
}	O
if	O
(	O
buf	pointer
[	O
n	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
hlines	long
++	O
;	O
if	O
(	O
mu_c_strncasecmp	function
(	O
buf	pointer
,	O
"status:"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
mu_string_to_flags	function
(	O
buf	pointer
,	O
&	O
attr_flags	pointer
)	O
;	O
else	O
if	O
(	O
mu_c_strncasecmp	function
(	O
buf	pointer
,	O
"x-imapbase:"	pointer
,	O
11	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	pointer
;	O
uidvalidity	long
=	O
strtoul	function
(	O
buf	pointer
+	O
11	int
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
buf	pointer
[	O
n	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
blines	long
++	O
;	O
}	O
off	long
+=	O
n	long
;	O
}	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
if	O
(	O
!	O
body_start	int
)	O
body_start	pointer
=	O
off	long
;	O
sp	pointer
->	O
body_start	pointer
=	O
body_start	pointer
;	O
sp	pointer
->	O
body_end	long
=	O
off	long
;	O
sp	pointer
->	O
header_lines	long
=	O
hlines	long
;	O
sp	pointer
->	O
body_lines	long
=	O
blines	long
;	O
sp	pointer
->	O
attr_flags	pointer
=	O
attr_flags	int
;	O
sp	pointer
->	O
uidvalidity	long
=	O
uidvalidity	int
;	O
}	O
return	O
status	int
;	O
}	O
int	O
mu_message_get_uidl	function
(	O
mu_message_t	pointer
msg	pointer
,	O
char	O
*	O
buffer	pointer
,	O
size_t	long
buflen	long
,	O
size_t	long
*	O
pwriten	pointer
)	O
{	O
mu_header_t	pointer
header	pointer
=	O
NULL	O
;	O
size_t	long
n	long
=	O
0	int
;	O
int	O
status	int
;	O
if	O
(	O
msg	pointer
==	O
NULL	O
||	O
buffer	pointer
==	O
NULL	O
||	O
buflen	long
==	O
0	int
)	O
return	O
EINVAL	int
;	O
buffer	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
msg	pointer
->	O
_get_uidl	pointer
)	O
{	O
status	int
=	O
msg	pointer
->	O
_get_uidl	pointer
(	O
msg	pointer
,	O
buffer	pointer
,	O
buflen	long
,	O
pwriten	pointer
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
return	O
status	int
;	O
}	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
header	pointer
)	O
;	O
status	int
=	O
mu_header_get_value_unfold	function
(	O
header	pointer
,	O
"X-UIDL"	pointer
,	O
buffer	pointer
,	O
buflen	long
,	O
&	O
n	int
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
||	O
n	int
==	O
0	int
)	O
{	O
size_t	long
uid	int
=	O
0	int
;	O
struct	O
mu_md5_ctx	struct
md5context	struct
;	O
mu_stream_t	pointer
stream	pointer
=	O
NULL	O
;	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
unsigned	O
char	O
md5digest	array
[	O
16	int
]	O
;	O
char	O
*	O
tmp	pointer
;	O
n	long
=	O
0	int
;	O
mu_message_get_uid	function
(	O
msg	pointer
,	O
&	O
uid	int
)	O
;	O
mu_message_get_streamref	function
(	O
msg	pointer
,	O
&	O
stream	pointer
)	O
;	O
mu_md5_init_ctx	function
(	O
&	O
md5context	struct
)	O
;	O
status	int
=	O
mu_stream_seek	function
(	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
while	O
(	O
mu_stream_read	function
(	O
stream	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
&	O
n	long
)	O
==	O
0	int
&&	O
n	int
>	O
0	int
)	O
mu_md5_process_bytes	function
(	O
buf	pointer
,	O
n	long
,	O
&	O
md5context	struct
)	O
;	O
mu_md5_finish_ctx	function
(	O
&	O
md5context	struct
,	O
md5digest	int
)	O
;	O
tmp	pointer
=	O
buf	pointer
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
16	int
;	O
n	int
++	O
,	O
tmp	pointer
+=	O
2	int
)	O
sprintf	function
(	O
tmp	pointer
,	O
"%02x"	pointer
,	O
md5digest	array
[	O
n	int
]	O
)	O
;	O
*	O
tmp	pointer
=	O
'\0'	O
;	O
snprintf	function
(	O
buf	pointer
+	O
32	int
,	O
70	int
,	O
".%lu.%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
time	O
(	O
NULL	O
)	O
,	O
(	O
unsigned	O
long	O
)	O
uid	int
)	O
;	O
mu_header_set_value	function
(	O
header	pointer
,	O
"X-UIDL"	pointer
,	O
buf	array
,	O
1	int
)	O
;	O
buflen	long
--	O
;	O
strncpy	function
(	O
buffer	array
,	O
buf	pointer
,	O
buflen	long
)	O
[	O
buflen	int
]	O
=	O
'\0'	O
;	O
}	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
}	O
return	O
status	int
;	O
}	O
int	O
mu_message_set_uidl	function
(	O
mu_message_t	pointer
msg	pointer
,	O
int	O
(	O
*	O
_get_uidl	pointer
)	O
(	O
mu_message_t	pointer
,	O
char	O
*	O
,	O
size_t	long
,	O
size_t	long
*	O
)	O
,	O
void	O
*	O
owner	pointer
)	O
{	O
if	O
(	O
msg	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
msg	pointer
->	O
owner	pointer
!=	O
owner	pointer
)	O
return	O
EACCES	int
;	O
msg	pointer
->	O
_get_uidl	pointer
=	O
_get_uidl	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_mailcap_set_selector	function
(	O
mu_mailcap_t	pointer
mailcap	pointer
,	O
struct	O
mu_mailcap_selector_closure	struct
const	O
*	O
sel	pointer
)	O
{	O
if	O
(	O
!	O
mailcap	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
sel	pointer
)	O
mailcap	pointer
->	O
selector	pointer
=	O
*	O
sel	pointer
;	O
else	O
memset	function
(	O
&	O
mailcap	pointer
->	O
selector	pointer
,	O
0	int
,	O
sizeof	O
(	O
mailcap	pointer
->	O
selector	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_mailcap_get_selector	function
(	O
mu_mailcap_t	pointer
mailcap	pointer
,	O
struct	O
mu_mailcap_selector_closure	struct
*	O
sel	pointer
)	O
{	O
if	O
(	O
!	O
mailcap	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
sel	pointer
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
*	O
sel	pointer
=	O
mailcap	pointer
->	O
selector	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
copy_range	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
mu_msgrange	struct
const	O
*	O
range	pointer
=	O
item	pointer
;	O
mu_list_t	pointer
list	pointer
=	O
data	pointer
;	O
struct	O
mu_msgrange	struct
*	O
copy	pointer
;	O
copy	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
copy	pointer
)	O
)	O
;	O
if	O
(	O
!	O
copy	pointer
)	O
return	O
ENOMEM	int
;	O
*	O
copy	pointer
=	O
*	O
range	pointer
;	O
return	O
mu_list_append	function
(	O
list	pointer
,	O
copy	pointer
)	O
;	O
}	O
int	O
mu_msgset_copy	function
(	O
mu_msgset_t	pointer
src	pointer
,	O
mu_msgset_t	pointer
dst	pointer
)	O
{	O
mu_list_t	pointer
list	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
src	pointer
||	O
!	O
dst	pointer
)	O
return	O
EINVAL	int
;	O
rc	int
=	O
mu_list_create	function
(	O
&	O
list	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_list_foreach	function
(	O
src	pointer
->	O
list	pointer
,	O
copy_range	pointer
,	O
list	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
mu_list_append_list	function
(	O
dst	pointer
->	O
list	pointer
,	O
list	pointer
)	O
;	O
mu_list_destroy	function
(	O
&	O
list	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
struct	O
action_closure	struct
{	O
mu_msgset_msgno_action_t	pointer
action	pointer
;	O
void	O
*	O
data	pointer
;	O
mu_msgset_t	pointer
msgset	pointer
;	O
int	O
flags	int
;	O
}	O
;	O
static	O
int	O
call_action	function
(	O
struct	O
action_closure	struct
*	O
clos	pointer
,	O
size_t	long
i	long
)	O
{	O
size_t	long
n	long
;	O
int	O
cmd	int
;	O
if	O
(	O
_MU_MSGSET_MODE	O
(	O
clos	pointer
->	O
msgset	pointer
->	O
flags	int
)	O
!=	O
_MU_MSGSET_MODE	O
(	O
clos	pointer
->	O
flags	int
)	O
)	O
{	O
int	O
rc	int
;	O
switch	O
(	O
_MU_MSGSET_MODE	O
(	O
clos	pointer
->	O
flags	int
)	O
)	O
{	O
case	O
MU_MSGSET_NUM	int
:	O
cmd	int
=	O
MU_MAILBOX_UID_TO_MSGNO	int
;	O
break	O
;	O
case	O
MU_MSGSET_UID	int
:	O
cmd	int
=	O
MU_MAILBOX_MSGNO_TO_UID	int
;	O
break	O
;	O
default	O
:	O
return	O
EINVAL	int
;	O
}	O
rc	int
=	O
mu_mailbox_translate	function
(	O
clos	pointer
->	O
msgset	pointer
->	O
mbox	pointer
,	O
cmd	int
,	O
i	int
,	O
&	O
n	int
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
return	O
0	int
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
else	O
n	int
=	O
i	int
;	O
return	O
clos	pointer
->	O
action	pointer
(	O
n	long
,	O
clos	pointer
->	O
data	pointer
)	O
;	O
}	O
static	O
int	O
procrange	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
mu_msgrange	struct
*	O
mp	pointer
=	O
item	pointer
;	O
struct	O
action_closure	struct
*	O
clos	pointer
=	O
data	pointer
;	O
size_t	long
i	long
;	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
clos	pointer
->	O
flags	int
&	O
MU_MSGSET_FOREACH_BACKWARD	int
)	O
for	O
(	O
i	long
=	O
mp	pointer
->	O
msg_end	long
;	O
rc	int
==	O
0	int
&&	O
i	long
>=	O
mp	pointer
->	O
msg_beg	long
;	O
i	long
--	O
)	O
rc	int
=	O
call_action	function
(	O
clos	pointer
,	O
i	long
)	O
;	O
else	O
for	O
(	O
i	long
=	O
mp	pointer
->	O
msg_beg	long
;	O
rc	int
==	O
0	int
&&	O
i	long
<=	O
mp	pointer
->	O
msg_end	long
;	O
i	long
++	O
)	O
rc	int
=	O
call_action	function
(	O
clos	pointer
,	O
i	long
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_msgset_foreach_num	function
(	O
mu_msgset_t	pointer
msgset	pointer
,	O
int	O
flags	int
,	O
mu_msgset_msgno_action_t	pointer
action	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
action_closure	struct
clos	pointer
;	O
rc	int
=	O
mu_msgset_aggregate	function
(	O
msgset	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
clos	pointer
.	O
action	pointer
=	O
action	pointer
;	O
clos	pointer
.	O
data	pointer
=	O
data	pointer
;	O
clos	pointer
.	O
flags	int
=	O
flags	int
;	O
clos	pointer
.	O
msgset	pointer
=	O
msgset	pointer
;	O
return	O
mu_list_foreach_dir	function
(	O
msgset	pointer
->	O
list	pointer
,	O
!	O
!	O
(	O
flags	int
&	O
MU_MSGSET_FOREACH_BACKWARD	int
)	O
,	O
procrange	function
,	O
&	O
clos	pointer
)	O
;	O
}	O
void	O
mu_msgset_free	function
(	O
mu_msgset_t	pointer
mset	pointer
)	O
{	O
if	O
(	O
mset	pointer
)	O
{	O
mu_list_destroy	function
(	O
&	O
mset	pointer
->	O
list	pointer
)	O
;	O
free	function
(	O
mset	pointer
)	O
;	O
}	O
}	O
void	O
mu_msgset_destroy	function
(	O
mu_msgset_t	pointer
*	O
pset	pointer
)	O
{	O
if	O
(	O
pset	pointer
)	O
{	O
mu_msgset_free	function
(	O
*	O
pset	pointer
)	O
;	O
*	O
pset	pointer
=	O
NULL	O
;	O
}	O
}	O
struct	O
mu_msgset_format	struct
const	O
mu_msgset_formats	array
[	O
]	O
=	O
{	O
[	O
MU_MSGSET_FMT_IMAP	int
]	O
=	O
{	O
.	O
delim	O
=	O
","	pointer
,	O
.	O
range	pointer
=	O
":"	pointer
,	O
.	O
last	pointer
=	O
"*"	pointer
,	O
.	O
empty	pointer
=	O
"NIL"	int
}	O
,	O
[	O
MU_MSGSET_FMT_MH	int
]	O
=	O
{	O
.	O
delim	int
=	O
" "	pointer
,	O
.	O
range	pointer
=	O
"-"	pointer
,	O
.	O
last	pointer
=	O
"last"	pointer
}	O
}	O
;	O
struct	O
print_env	struct
{	O
mu_stream_t	pointer
stream	pointer
;	O
int	O
cont	pointer
;	O
struct	O
mu_msgset_format	struct
const	O
*	O
fmt	pointer
;	O
}	O
;	O
static	O
int	O
_msgrange_printer	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_msgrange	struct
*	O
range	pointer
=	O
item	pointer
;	O
struct	O
print_env	struct
*	O
env	pointer
=	O
data	pointer
;	O
if	O
(	O
env	pointer
->	O
cont	pointer
)	O
{	O
rc	int
=	O
mu_stream_printf	function
(	O
env	pointer
->	O
stream	pointer
,	O
"%s"	pointer
,	O
env	pointer
->	O
fmt	pointer
->	O
delim	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
else	O
env	pointer
->	O
cont	pointer
=	O
1	int
;	O
if	O
(	O
range	pointer
->	O
msg_beg	long
==	O
range	pointer
->	O
msg_end	long
)	O
rc	int
=	O
mu_stream_printf	function
(	O
env	pointer
->	O
stream	pointer
,	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
range	pointer
->	O
msg_beg	long
)	O
;	O
else	O
if	O
(	O
range	pointer
->	O
msg_end	long
==	O
0	int
)	O
rc	int
=	O
mu_stream_printf	function
(	O
env	pointer
->	O
stream	pointer
,	O
"%lu%s%s"	pointer
,	O
(	O
unsigned	O
long	O
)	O
range	pointer
->	O
msg_beg	long
,	O
env	pointer
->	O
fmt	pointer
->	O
range	pointer
,	O
env	pointer
->	O
fmt	pointer
->	O
last	long
)	O
;	O
else	O
if	O
(	O
range	pointer
->	O
msg_end	long
==	O
range	pointer
->	O
msg_beg	long
+	O
1	int
)	O
rc	int
=	O
mu_stream_printf	function
(	O
env	pointer
->	O
stream	pointer
,	O
"%lu%s%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
range	pointer
->	O
msg_beg	long
,	O
env	pointer
->	O
fmt	pointer
->	O
delim	int
,	O
(	O
unsigned	O
long	O
)	O
range	pointer
->	O
msg_end	long
)	O
;	O
else	O
rc	int
=	O
mu_stream_printf	function
(	O
env	pointer
->	O
stream	pointer
,	O
"%lu%s%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
range	pointer
->	O
msg_beg	long
,	O
env	pointer
->	O
fmt	pointer
->	O
range	pointer
,	O
(	O
unsigned	O
long	O
)	O
range	pointer
->	O
msg_end	long
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_stream_msgset_format	function
(	O
mu_stream_t	pointer
str	pointer
,	O
struct	O
mu_msgset_format	struct
const	O
*	O
fmt	pointer
,	O
mu_msgset_t	pointer
mset	pointer
)	O
{	O
struct	O
print_env	struct
env	pointer
;	O
int	O
rc	int
;	O
env	pointer
.	O
stream	pointer
=	O
str	pointer
;	O
env	pointer
.	O
cont	pointer
=	O
0	int
;	O
env	pointer
.	O
fmt	pointer
=	O
fmt	pointer
;	O
if	O
(	O
mu_list_is_empty	function
(	O
mset	pointer
->	O
list	pointer
)	O
)	O
{	O
if	O
(	O
env	pointer
.	O
fmt	pointer
->	O
empty	pointer
)	O
return	O
mu_stream_printf	function
(	O
str	pointer
,	O
"%s"	pointer
,	O
env	pointer
.	O
fmt	pointer
->	O
empty	pointer
)	O
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
mu_msgset_aggregate	function
(	O
mset	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
return	O
mu_list_foreach	function
(	O
mset	pointer
->	O
list	pointer
,	O
_msgrange_printer	pointer
,	O
&	O
env	pointer
)	O
;	O
}	O
int	O
mu_msgset_print	function
(	O
mu_stream_t	pointer
str	pointer
,	O
mu_msgset_t	pointer
mset	pointer
)	O
{	O
return	O
mu_stream_msgset_format	function
(	O
str	pointer
,	O
mu_msgset_fmt_imap	O
,	O
mset	pointer
)	O
;	O
}	O
int	O
_mu_msgset_translate_pair	function
(	O
mu_msgset_t	pointer
mset	pointer
,	O
int	O
mode	int
,	O
size_t	long
*	O
pbeg	pointer
,	O
size_t	long
*	O
pend	pointer
)	O
{	O
if	O
(	O
mset	pointer
->	O
mbox	pointer
)	O
{	O
int	O
cmd	int
,	O
rc	int
;	O
size_t	long
n	int
=	O
1	int
;	O
size_t	long
beg	long
=	O
*	O
pbeg	pointer
;	O
size_t	long
end	long
=	O
*	O
pend	pointer
;	O
switch	O
(	O
mode	int
)	O
{	O
case	O
MU_MSGSET_NUM	int
:	O
cmd	int
=	O
MU_MAILBOX_UID_TO_MSGNO	int
;	O
break	O
;	O
case	O
MU_MSGSET_UID	int
:	O
cmd	int
=	O
MU_MAILBOX_MSGNO_TO_UID	int
;	O
break	O
;	O
default	O
:	O
return	O
EINVAL	int
;	O
}	O
rc	int
=	O
mu_mailbox_translate	function
(	O
mset	pointer
->	O
mbox	pointer
,	O
cmd	int
,	O
beg	pointer
,	O
&	O
n	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
&&	O
cmd	int
==	O
MU_MAILBOX_UID_TO_MSGNO	int
)	O
{	O
size_t	long
x	long
;	O
if	O
(	O
end	long
==	O
MU_MSGNO_LAST	int
)	O
{	O
rc	int
=	O
mu_mailbox_uidnext	function
(	O
mset	pointer
->	O
mbox	pointer
,	O
&	O
x	long
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
else	O
x	long
=	O
end	long
;	O
for	O
(	O
;	O
rc	int
==	O
MU_ERR_NOENT	O
&&	O
beg	long
<	O
x	long
;	O
beg	long
++	O
)	O
rc	int
=	O
mu_mailbox_translate	function
(	O
mset	pointer
->	O
mbox	pointer
,	O
cmd	long
,	O
beg	long
,	O
&	O
n	long
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
*	O
pbeg	pointer
=	O
n	long
;	O
if	O
(	O
beg	long
==	O
end	long
)	O
*	O
pend	pointer
=	O
n	long
;	O
else	O
if	O
(	O
end	long
!=	O
MU_MSGNO_LAST	int
)	O
{	O
rc	int
=	O
mu_mailbox_translate	function
(	O
mset	pointer
->	O
mbox	pointer
,	O
cmd	long
,	O
end	pointer
,	O
&	O
n	long
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
&&	O
cmd	int
==	O
MU_MAILBOX_UID_TO_MSGNO	int
)	O
{	O
for	O
(	O
;	O
rc	int
==	O
MU_ERR_NOENT	O
&&	O
beg	long
<	O
end	long
;	O
end	long
--	O
)	O
rc	int
=	O
mu_mailbox_translate	function
(	O
mset	pointer
->	O
mbox	pointer
,	O
cmd	long
,	O
end	long
,	O
&	O
n	long
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
*	O
pend	pointer
=	O
n	long
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
_mu_msgset_translate_range	function
(	O
mu_msgset_t	pointer
mset	pointer
,	O
int	O
mode	int
,	O
struct	O
mu_msgrange	struct
*	O
r	pointer
)	O
{	O
return	O
_mu_msgset_translate_pair	function
(	O
mset	pointer
,	O
mode	int
,	O
&	O
r	pointer
->	O
msg_beg	long
,	O
&	O
r	pointer
->	O
msg_end	long
)	O
;	O
}	O
struct	O
trans_closure	struct
{	O
mu_msgset_t	pointer
mset	pointer
;	O
int	O
flags	int
;	O
}	O
;	O
static	O
int	O
trans_range	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
mu_msgrange	struct
const	O
*	O
range	pointer
=	O
item	pointer
;	O
struct	O
trans_closure	struct
*	O
clos	pointer
=	O
data	pointer
;	O
struct	O
mu_msgrange	struct
*	O
copy	pointer
;	O
int	O
rc	int
;	O
copy	pointer
=	O
malloc	function
(	O
sizeof	O
*	O
copy	pointer
)	O
;	O
if	O
(	O
!	O
copy	pointer
)	O
return	O
errno	O
;	O
*	O
copy	pointer
=	O
*	O
range	pointer
;	O
rc	int
=	O
_mu_msgset_translate_range	function
(	O
clos	pointer
->	O
mset	pointer
,	O
_MU_MSGSET_MODE	O
(	O
clos	pointer
->	O
flags	int
)	O
,	O
copy	pointer
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
rc	int
=	O
mu_list_append	function
(	O
clos	pointer
->	O
mset	pointer
->	O
list	pointer
,	O
copy	pointer
)	O
;	O
break	O
;	O
case	O
MU_ERR_NOENT	O
:	O
if	O
(	O
clos	pointer
->	O
flags	int
&	O
MU_MSGSET_IGNORE_TRANSERR	int
)	O
rc	int
=	O
0	int
;	O
default	O
:	O
free	function
(	O
copy	pointer
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_msgset_translate	function
(	O
mu_msgset_t	pointer
*	O
dst	pointer
,	O
mu_msgset_t	pointer
src	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
;	O
mu_msgset_t	pointer
tmp	pointer
;	O
rc	int
=	O
mu_msgset_create	function
(	O
&	O
tmp	pointer
,	O
src	pointer
->	O
mbox	pointer
,	O
src	pointer
->	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
tmp	pointer
->	O
format	pointer
=	O
src	pointer
->	O
format	pointer
;	O
if	O
(	O
_MU_MSGSET_MODE	O
(	O
flags	int
)	O
==	O
src	pointer
->	O
flags	int
)	O
{	O
rc	int
=	O
mu_msgset_copy	function
(	O
src	pointer
,	O
tmp	pointer
)	O
;	O
}	O
else	O
{	O
struct	O
trans_closure	struct
tc	struct
;	O
tc	struct
.	O
mset	pointer
=	O
tmp	pointer
;	O
tc	struct
.	O
flags	int
=	O
flags	int
;	O
rc	int
=	O
mu_list_foreach	function
(	O
src	pointer
->	O
list	pointer
,	O
trans_range	pointer
,	O
&	O
tc	pointer
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
mu_msgset_destroy	function
(	O
&	O
tmp	pointer
)	O
;	O
else	O
*	O
dst	pointer
=	O
tmp	pointer
;	O
return	O
rc	int
;	O
}	O
char	O
*	O
mu_program_name	pointer
;	O
char	O
*	O
mu_full_program_name	pointer
;	O
void	O
mu_set_program_name	function
(	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
mu_strdup	function
(	O
arg	pointer
)	O
;	O
free	function
(	O
mu_full_program_name	pointer
)	O
;	O
mu_full_program_name	pointer
=	O
p	pointer
;	O
p	pointer
=	O
strrchr	function
(	O
mu_full_program_name	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
++	O
p	pointer
;	O
else	O
p	pointer
=	O
(	O
char	O
*	O
)	O
mu_full_program_name	pointer
;	O
if	O
(	O
strlen	function
(	O
p	pointer
)	O
>	O
3	int
&&	O
memcmp	function
(	O
p	pointer
,	O
"lt-"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
p	pointer
+=	O
3	int
;	O
free	function
(	O
mu_program_name	pointer
)	O
;	O
mu_program_name	pointer
=	O
mu_strdup	function
(	O
p	pointer
)	O
;	O
}	O
static	O
void	O
_mh_prop_done	function
(	O
struct	O
_mu_property	struct
*	O
prop	pointer
)	O
{	O
struct	O
mu_mh_prop	struct
*	O
mhprop	pointer
=	O
prop	pointer
->	O
_prop_init_data	pointer
;	O
mu_header_t	pointer
header	pointer
=	O
prop	pointer
->	O
_prop_data	pointer
;	O
mu_header_destroy	function
(	O
&	O
header	pointer
)	O
;	O
free	function
(	O
mhprop	pointer
->	O
filename	pointer
)	O
;	O
free	function
(	O
mhprop	pointer
)	O
;	O
}	O
static	O
int	O
_mh_prop_getval	function
(	O
struct	O
_mu_property	struct
*	O
prop	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
*	O
pval	pointer
)	O
{	O
mu_header_t	pointer
header	pointer
=	O
prop	pointer
->	O
_prop_data	pointer
;	O
if	O
(	O
!	O
header	pointer
)	O
return	O
MU_ERR_NOENT	O
;	O
return	O
mu_header_sget_value	O
(	O
header	pointer
,	O
key	pointer
,	O
pval	pointer
)	O
;	O
}	O
static	O
int	O
_mh_prop_setval	function
(	O
struct	O
_mu_property	struct
*	O
prop	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
val	pointer
,	O
int	O
overwrite	int
)	O
{	O
struct	O
mu_mh_prop	struct
*	O
mhprop	pointer
=	O
prop	pointer
->	O
_prop_init_data	pointer
;	O
mu_header_t	pointer
header	pointer
=	O
prop	pointer
->	O
_prop_data	pointer
;	O
if	O
(	O
!	O
header	pointer
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
(	O
rc	int
=	O
mu_header_create	function
(	O
&	O
header	pointer
,	O
NULL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot create context %s: %s"	pointer
)	O
,	O
mhprop	pointer
->	O
filename	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
prop	pointer
->	O
_prop_data	pointer
=	O
header	pointer
;	O
}	O
return	O
mu_header_set_value	function
(	O
header	pointer
,	O
key	pointer
,	O
val	pointer
,	O
overwrite	int
)	O
;	O
}	O
static	O
int	O
_mh_prop_unset	function
(	O
struct	O
_mu_property	struct
*	O
prop	pointer
,	O
const	O
char	O
*	O
key	pointer
)	O
{	O
mu_header_t	pointer
header	pointer
=	O
prop	pointer
->	O
_prop_data	pointer
;	O
if	O
(	O
!	O
header	pointer
)	O
return	O
0	int
;	O
return	O
mu_header_remove	function
(	O
header	pointer
,	O
key	pointer
,	O
1	int
)	O
;	O
}	O
static	O
int	O
_mh_prop_getitr	function
(	O
struct	O
_mu_property	struct
*	O
prop	pointer
,	O
mu_iterator_t	pointer
*	O
pitr	pointer
)	O
{	O
mu_header_t	pointer
header	pointer
=	O
prop	pointer
->	O
_prop_data	pointer
;	O
return	O
mu_header_get_iterator	function
(	O
header	pointer
,	O
pitr	pointer
)	O
;	O
}	O
static	O
int	O
_mh_prop_clear	function
(	O
struct	O
_mu_property	struct
*	O
prop	pointer
)	O
{	O
mu_header_t	pointer
header	pointer
=	O
prop	pointer
->	O
_prop_data	pointer
;	O
return	O
mu_header_clear	function
(	O
header	pointer
)	O
;	O
}	O
static	O
int	O
_mh_prop_read_stream	function
(	O
mu_header_t	pointer
*	O
phdr	pointer
,	O
mu_stream_t	pointer
stream	pointer
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	pointer
flt	pointer
;	O
const	O
char	O
*	O
argv	pointer
[	O
4	int
]	O
;	O
mu_off_t	long
size	long
;	O
size_t	long
total	long
;	O
char	O
*	O
blurb	pointer
;	O
rc	int
=	O
mu_stream_size	function
(	O
stream	pointer
,	O
&	O
size	long
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
argv	pointer
[	O
0	int
]	O
=	O
"INLINE-COMMENT"	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
"#"	pointer
;	O
argv	pointer
[	O
2	int
]	O
=	O
"-r"	pointer
;	O
argv	pointer
[	O
3	int
]	O
=	O
NULL	O
;	O
rc	int
=	O
mu_filter_create_args	function
(	O
&	O
flt	pointer
,	O
stream	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
3	int
,	O
argv	array
,	O
MU_FILTER_DECODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot open filter stream: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
blurb	pointer
=	O
malloc	function
(	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
blurb	pointer
)	O
{	O
mu_stream_destroy	function
(	O
&	O
flt	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
total	long
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
size_t	long
n	long
;	O
rc	int
=	O
mu_stream_read	function
(	O
flt	pointer
,	O
blurb	int
+	O
total	long
,	O
size	long
-	O
total	long
,	O
&	O
n	long
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
if	O
(	O
n	long
==	O
0	int
)	O
break	O
;	O
total	long
+=	O
n	int
;	O
}	O
mu_stream_destroy	function
(	O
&	O
flt	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free	function
(	O
blurb	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_header_create	function
(	O
phdr	pointer
,	O
blurb	pointer
,	O
total	long
)	O
;	O
free	function
(	O
blurb	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_mh_prop_write_stream	function
(	O
mu_header_t	pointer
header	pointer
,	O
struct	O
mu_mh_prop	struct
*	O
mhprop	pointer
,	O
mu_stream_t	pointer
stream	pointer
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	pointer
instream	pointer
;	O
mu_off_t	long
size	long
;	O
mu_header_get_streamref	function
(	O
header	pointer
,	O
&	O
instream	pointer
)	O
;	O
rc	int
=	O
mu_stream_copy	function
(	O
stream	pointer
,	O
instream	pointer
,	O
0	int
,	O
&	O
size	long
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"error writing to context file %s: %s"	pointer
)	O
,	O
mhprop	pointer
->	O
filename	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
else	O
rc	int
=	O
mu_stream_truncate	function
(	O
stream	pointer
,	O
size	long
)	O
;	O
mu_stream_destroy	function
(	O
&	O
instream	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_mh_prop_fill	function
(	O
struct	O
_mu_property	struct
*	O
prop	pointer
)	O
{	O
struct	O
mu_mh_prop	struct
*	O
mhprop	pointer
=	O
prop	pointer
->	O
_prop_init_data	pointer
;	O
int	O
rc	int
;	O
mu_stream_t	pointer
stream	pointer
;	O
mu_header_t	pointer
header	pointer
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
stream	pointer
,	O
mhprop	pointer
->	O
filename	pointer
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
mu_header_create	function
(	O
&	O
header	pointer
,	O
NULL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
mu_error	function
(	O
_	O
(	O
"cannot create context %s: %s"	pointer
)	O
,	O
mhprop	pointer
->	O
filename	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
else	O
{	O
rc	int
=	O
_mh_prop_read_stream	function
(	O
&	O
header	pointer
,	O
stream	pointer
)	O
;	O
mu_stream_unref	function
(	O
stream	pointer
)	O
;	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
prop	pointer
->	O
_prop_data	pointer
=	O
header	pointer
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
_mh_prop_save	function
(	O
struct	O
_mu_property	struct
*	O
prop	pointer
)	O
{	O
struct	O
mu_mh_prop	struct
*	O
mhprop	pointer
=	O
prop	pointer
->	O
_prop_init_data	pointer
;	O
mu_header_t	pointer
header	pointer
=	O
prop	pointer
->	O
_prop_data	pointer
;	O
mu_stream_t	pointer
stream	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
mhprop	pointer
->	O
ro	pointer
)	O
return	O
0	int
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
stream	pointer
,	O
mhprop	pointer
->	O
filename	pointer
,	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
_mh_prop_write_stream	function
(	O
header	pointer
,	O
mhprop	pointer
,	O
stream	pointer
)	O
;	O
mu_stream_unref	function
(	O
stream	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_mh_property_init	function
(	O
struct	O
_mu_property	struct
*	O
prop	pointer
)	O
{	O
struct	O
mu_mh_prop	struct
*	O
mhprop	pointer
=	O
prop	pointer
->	O
_prop_init_data	pointer
;	O
if	O
(	O
!	O
mhprop	pointer
)	O
return	O
EINVAL	int
;	O
prop	pointer
->	O
_prop_data	pointer
=	O
NULL	O
;	O
prop	pointer
->	O
_prop_done	pointer
=	O
_mh_prop_done	pointer
;	O
prop	pointer
->	O
_prop_fill	pointer
=	O
_mh_prop_fill	function
;	O
prop	pointer
->	O
_prop_save	pointer
=	O
_mh_prop_save	function
;	O
prop	pointer
->	O
_prop_getval	pointer
=	O
_mh_prop_getval	function
;	O
prop	pointer
->	O
_prop_setval	pointer
=	O
_mh_prop_setval	function
;	O
prop	pointer
->	O
_prop_unset	pointer
=	O
_mh_prop_unset	function
;	O
prop	pointer
->	O
_prop_getitr	pointer
=	O
_mh_prop_getitr	function
;	O
prop	pointer
->	O
_prop_clear	pointer
=	O
_mh_prop_clear	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_property_sget_value	function
(	O
mu_property_t	pointer
prop	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
const	O
char	O
*	O
*	O
pval	pointer
)	O
{	O
int	O
rc	int
=	O
_mu_property_check	function
(	O
prop	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
!	O
prop	pointer
->	O
_prop_getval	pointer
)	O
return	O
MU_ERR_EMPTY_VFN	O
;	O
return	O
prop	pointer
->	O
_prop_getval	pointer
(	O
prop	pointer
,	O
key	pointer
,	O
pval	pointer
)	O
;	O
}	O
int	O
mu_property_aget_value	function
(	O
mu_property_t	pointer
prop	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
char	O
*	O
*	O
buffer	pointer
)	O
{	O
const	O
char	O
*	O
value	pointer
;	O
int	O
rc	int
=	O
mu_property_sget_value	function
(	O
prop	pointer
,	O
key	pointer
,	O
&	O
value	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
(	O
*	O
buffer	pointer
=	O
strdup	function
(	O
value	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_property_get_value	function
(	O
mu_property_t	pointer
prop	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
char	O
*	O
buffer	pointer
,	O
size_t	long
buflen	long
,	O
size_t	long
*	O
n	pointer
)	O
{	O
size_t	long
len	int
=	O
0	int
;	O
const	O
char	O
*	O
value	pointer
;	O
int	O
rc	int
=	O
mu_property_sget_value	function
(	O
prop	pointer
,	O
key	pointer
,	O
&	O
value	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
len	int
=	O
strlen	function
(	O
value	pointer
)	O
+	O
1	int
;	O
if	O
(	O
buffer	pointer
&&	O
buflen	long
)	O
{	O
if	O
(	O
buflen	long
<	O
len	int
)	O
len	int
=	O
buflen	long
;	O
len	int
--	O
;	O
memcpy	function
(	O
buffer	pointer
,	O
value	pointer
,	O
len	int
)	O
;	O
buffer	pointer
[	O
len	int
]	O
=	O
0	int
;	O
}	O
}	O
if	O
(	O
n	int
)	O
*	O
n	pointer
=	O
len	int
;	O
return	O
rc	int
;	O
}	O
int	O
mu_property_is_set	function
(	O
mu_property_t	pointer
prop	pointer
,	O
const	O
char	O
*	O
key	pointer
)	O
{	O
if	O
(	O
_mu_property_check	function
(	O
prop	pointer
)	O
)	O
return	O
0	int
;	O
return	O
mu_property_sget_value	function
(	O
prop	pointer
,	O
key	pointer
,	O
NULL	O
)	O
==	O
0	int
;	O
}	O
int	O
mu_sockaddr_create	function
(	O
struct	O
mu_sockaddr	struct
*	O
*	O
res	pointer
,	O
struct	O
sockaddr	struct
*	O
addr	pointer
,	O
socklen_t	int
len	int
)	O
{	O
struct	O
mu_sockaddr	struct
*	O
sa	pointer
;	O
sa	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
sa	pointer
)	O
)	O
;	O
if	O
(	O
!	O
sa	pointer
)	O
return	O
ENOMEM	int
;	O
sa	pointer
->	O
addr	pointer
=	O
malloc	function
(	O
len	int
)	O
;	O
if	O
(	O
!	O
sa	pointer
->	O
addr	pointer
)	O
{	O
free	function
(	O
sa	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
memcpy	function
(	O
sa	pointer
->	O
addr	pointer
,	O
addr	pointer
,	O
len	int
)	O
;	O
sa	pointer
->	O
addrlen	int
=	O
len	int
;	O
*	O
res	pointer
=	O
sa	pointer
;	O
return	O
0	int
;	O
}	O
static	O
void	O
stdstream_flushall_setup	function
(	O
void	O
)	O
;	O
static	O
void	O
std_bootstrap	function
(	O
struct	O
_mu_stream	struct
*	O
str	pointer
,	O
int	O
code	int
,	O
unsigned	O
long	O
lval	long
,	O
void	O
*	O
pval	pointer
)	O
{	O
struct	O
_mu_file_stream	struct
*	O
fstr	pointer
=	O
(	O
struct	O
_mu_file_stream	struct
*	O
)	O
str	pointer
;	O
_mu_file_stream_setup	function
(	O
fstr	pointer
)	O
;	O
str	pointer
->	O
event_cb	pointer
=	O
NULL	O
;	O
str	pointer
->	O
event_mask	int
=	O
0	int
;	O
str	pointer
->	O
event_cb_data	pointer
=	O
0	int
;	O
fstr	pointer
->	O
stream	pointer
.	O
flags	int
|=	O
_MU_STR_OPEN	int
;	O
mu_stream_set_buffer	function
(	O
(	O
mu_stream_t	pointer
)	O
fstr	pointer
,	O
mu_buffer_line	int
,	O
0	int
)	O
;	O
stdstream_flushall_setup	function
(	O
)	O
;	O
}	O
static	O
void	O
std_log_bootstrap	function
(	O
struct	O
_mu_stream	struct
*	O
str	pointer
,	O
int	O
code	int
,	O
unsigned	O
long	O
lval	long
,	O
void	O
*	O
pval	pointer
)	O
{	O
struct	O
_mu_log_stream	struct
*	O
logstr	pointer
=	O
(	O
struct	O
_mu_log_stream	struct
*	O
)	O
str	pointer
;	O
int	O
yes	int
=	O
1	int
;	O
mu_stream_t	pointer
errstr	pointer
,	O
transport	pointer
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_stdio_stream_create	function
(	O
&	O
errstr	pointer
,	O
MU_STDERR_FD	int
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: cannot open error stream: %s\n"	pointer
,	O
mu_program_name	pointer
?	O
mu_program_name	pointer
:	O
"<unknown>"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
mu_stream_ioctl	function
(	O
errstr	pointer
,	O
MU_IOCTL_FD	int
,	O
MU_IOCTL_FD_SET_BORROW	int
,	O
&	O
yes	int
)	O
;	O
if	O
(	O
!	O
mu_program_name	pointer
)	O
transport	pointer
=	O
errstr	pointer
;	O
else	O
{	O
char	O
*	O
fltargs	array
[	O
3	int
]	O
=	O
{	O
"INLINE-COMMENT"	pointer
,	O
}	O
;	O
mu_asprintf	function
(	O
&	O
fltargs	array
[	O
1	int
]	O
,	O
"%s: "	pointer
,	O
mu_program_name	pointer
)	O
;	O
fltargs	array
[	O
2	int
]	O
=	O
NULL	O
;	O
rc	int
=	O
mu_filter_create_args	function
(	O
&	O
transport	pointer
,	O
errstr	pointer
,	O
"INLINE-COMMENT"	pointer
,	O
2	int
,	O
(	O
const	O
char	O
*	O
*	O
)	O
fltargs	array
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_WRITE	int
)	O
;	O
mu_stream_unref	function
(	O
errstr	pointer
)	O
;	O
free	function
(	O
fltargs	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: cannot open output filter stream: %s"	pointer
,	O
mu_program_name	pointer
?	O
mu_program_name	pointer
:	O
"<unknown>"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
mu_stream_set_buffer	function
(	O
transport	pointer
,	O
mu_buffer_line	int
,	O
0	int
)	O
;	O
}	O
str	pointer
->	O
event_cb	pointer
=	O
NULL	O
;	O
str	pointer
->	O
event_mask	int
=	O
0	int
;	O
str	pointer
->	O
event_cb_data	pointer
=	O
0	int
;	O
_mu_log_stream_setup	function
(	O
logstr	pointer
,	O
transport	pointer
)	O
;	O
stdstream_flushall_setup	function
(	O
)	O
;	O
}	O
static	O
void	O
bootstrap_destroy	function
(	O
struct	O
_mu_stream	struct
*	O
str	pointer
)	O
{	O
}	O
static	O
struct	O
_mu_file_stream	struct
stdstream	array
[	O
2	int
]	O
=	O
{	O
{	O
.	O
stream	pointer
=	O
{	O
.	O
ref_count	int
=	O
1	int
,	O
.	O
buftype	char
=	O
mu_buffer_none	O
,	O
.	O
flags	int
=	O
MU_STREAM_READ	int
,	O
.	O
destroy	O
=	O
bootstrap_destroy	pointer
,	O
.	O
event_cb	pointer
=	O
std_bootstrap	O
,	O
.	O
event_mask	O
=	O
_MU_STR_EVMASK	O
(	O
_MU_STR_EVENT_BOOTSTRAP	int
)	O
}	O
,	O
.	O
fd	int
=	O
MU_STDIN_FD	int
,	O
.	O
filename	pointer
=	O
"<stdin>"	pointer
,	O
.	O
flags	int
=	O
_MU_FILE_STREAM_FD_BORROWED	int
|	O
_MU_FILE_STREAM_STATIC_FILENAME	int
}	O
,	O
{	O
.	O
stream	pointer
=	O
{	O
.	O
ref_count	int
=	O
1	int
,	O
.	O
buftype	char
=	O
mu_buffer_none	O
,	O
.	O
flags	int
=	O
MU_STREAM_WRITE	int
,	O
.	O
destroy	O
=	O
bootstrap_destroy	pointer
,	O
.	O
event_cb	pointer
=	O
std_bootstrap	O
,	O
.	O
event_mask	O
=	O
_MU_STR_EVMASK	O
(	O
_MU_STR_EVENT_BOOTSTRAP	int
)	O
}	O
,	O
.	O
fd	int
=	O
MU_STDOUT_FD	int
,	O
.	O
filename	pointer
=	O
"<stdout>"	pointer
,	O
.	O
flags	int
=	O
_MU_FILE_STREAM_FD_BORROWED	int
|	O
_MU_FILE_STREAM_STATIC_FILENAME	int
}	O
}	O
;	O
static	O
struct	O
_mu_log_stream	struct
default_strerr	struct
=	O
{	O
.	O
base	int
=	O
{	O
.	O
ref_count	int
=	O
1	int
,	O
.	O
buftype	char
=	O
mu_buffer_none	pointer
,	O
.	O
flags	int
=	O
MU_STREAM_WRITE	int
,	O
.	O
destroy	O
=	O
bootstrap_destroy	pointer
,	O
.	O
event_cb	pointer
=	O
std_log_bootstrap	O
,	O
.	O
event_mask	O
=	O
_MU_STR_EVMASK	O
(	O
_MU_STR_EVENT_BOOTSTRAP	int
)	O
}	O
}	O
;	O
mu_stream_t	pointer
mu_strin	pointer
=	O
(	O
mu_stream_t	pointer
)	O
&	O
stdstream	array
[	O
MU_STDIN_FD	int
]	O
;	O
mu_stream_t	pointer
mu_strout	pointer
=	O
(	O
mu_stream_t	pointer
)	O
&	O
stdstream	array
[	O
MU_STDOUT_FD	int
]	O
;	O
mu_stream_t	pointer
mu_strerr	pointer
=	O
(	O
mu_stream_t	pointer
)	O
&	O
default_strerr	int
;	O
static	O
void	O
stdstream_flushall	function
(	O
void	O
*	O
data	pointer
MU_ARG_UNUSED	O
)	O
{	O
mu_stream_flush	function
(	O
mu_strin	pointer
)	O
;	O
mu_stream_flush	function
(	O
mu_strout	pointer
)	O
;	O
mu_stream_flush	function
(	O
mu_strerr	pointer
)	O
;	O
}	O
static	O
void	O
stdstream_flushall_setup	function
(	O
void	O
)	O
{	O
static	O
int	O
_setup	int
=	O
0	int
;	O
if	O
(	O
!	O
_setup	pointer
)	O
{	O
mu_onexit	function
(	O
stdstream_flushall	pointer
,	O
NULL	O
)	O
;	O
_setup	int
=	O
1	int
;	O
}	O
}	O
void	O
mu_stdstream_setup	function
(	O
int	O
flags	int
)	O
{	O
int	O
rc	int
;	O
int	O
fd	int
;	O
int	O
yes	int
=	O
1	int
;	O
if	O
(	O
flags	int
&	O
MU_STDSTREAM_RESET_STRIN	int
)	O
mu_stream_destroy	function
(	O
&	O
mu_strin	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
MU_STDSTREAM_RESET_STROUT	int
)	O
mu_stream_destroy	function
(	O
&	O
mu_strout	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
MU_STDSTREAM_RESET_STRERR	int
)	O
mu_stream_destroy	function
(	O
&	O
mu_strerr	pointer
)	O
;	O
fd	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
)	O
;	O
switch	O
(	O
fd	int
)	O
{	O
case	O
0	int
:	O
fd	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_WRONLY	int
)	O
;	O
if	O
(	O
fd	int
!=	O
1	int
)	O
{	O
if	O
(	O
fd	int
>	O
2	int
)	O
close	function
(	O
fd	int
)	O
;	O
break	O
;	O
}	O
case	O
1	int
:	O
fd	int
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_WRONLY	int
)	O
;	O
if	O
(	O
fd	int
!=	O
2	int
)	O
close	function
(	O
fd	int
)	O
;	O
break	O
;	O
case	O
2	int
:	O
;	O
break	O
;	O
default	O
:	O
close	function
(	O
fd	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
mu_strin	pointer
)	O
{	O
rc	int
=	O
mu_stdio_stream_create	function
(	O
&	O
mu_strin	pointer
,	O
MU_STDIN_FD	int
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"mu_stdio_stream_create(%d): %s\n"	pointer
,	O
MU_STDIN_FD	int
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
mu_stream_ioctl	function
(	O
mu_strin	pointer
,	O
MU_IOCTL_FD	int
,	O
MU_IOCTL_FD_SET_BORROW	int
,	O
&	O
yes	int
)	O
;	O
}	O
if	O
(	O
!	O
mu_strout	pointer
)	O
{	O
rc	int
=	O
mu_stdio_stream_create	function
(	O
&	O
mu_strout	pointer
,	O
MU_STDOUT_FD	int
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"mu_stdio_stream_create(%d): %s\n"	pointer
,	O
MU_STDOUT_FD	int
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
mu_stream_ioctl	function
(	O
mu_strout	pointer
,	O
MU_IOCTL_FD	int
,	O
MU_IOCTL_FD_SET_BORROW	int
,	O
&	O
yes	int
)	O
;	O
}	O
if	O
(	O
!	O
mu_strerr	pointer
)	O
{	O
if	O
(	O
mu_stdstream_strerr_create	function
(	O
&	O
mu_strerr	pointer
,	O
MU_STRERR_STDERR	pointer
,	O
0	int
,	O
0	int
,	O
mu_program_name	pointer
,	O
NULL	O
)	O
)	O
abort	function
(	O
)	O
;	O
}	O
stdstream_flushall_setup	function
(	O
)	O
;	O
}	O
int	O
mu_printf	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
int	O
rc	int
;	O
va_list	array
ap	pointer
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
rc	int
=	O
mu_stream_vprintf	function
(	O
mu_strout	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
excmp	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
return	O
strcmp	function
(	O
*	O
(	O
const	O
char	O
*	O
*	O
)	O
a	pointer
,	O
*	O
(	O
const	O
char	O
*	O
*	O
)	O
b	pointer
)	O
;	O
}	O
static	O
char	O
*	O
*	O
make_exclusion_list	function
(	O
char	O
*	O
*	O
names	pointer
,	O
size_t	long
*	O
pcount	pointer
,	O
size_t	long
*	O
pmax	pointer
)	O
{	O
size_t	long
i	long
,	O
j	long
;	O
size_t	long
count	long
=	O
0	int
;	O
size_t	long
max_len	long
=	O
0	int
;	O
char	O
*	O
*	O
exlist	pointer
;	O
char	O
*	O
p	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
names	pointer
[	O
i	long
]	O
;	O
i	long
++	O
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
names	pointer
[	O
i	long
]	O
)	O
+	O
1	int
;	O
if	O
(	O
len	long
>	O
max_len	int
)	O
max_len	long
=	O
len	long
;	O
}	O
count	long
=	O
i	long
;	O
exlist	pointer
=	O
calloc	function
(	O
count	long
,	O
sizeof	O
(	O
exlist	array
[	O
0	int
]	O
)	O
+	O
max_len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
exlist	pointer
)	O
return	O
NULL	O
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
(	O
exlist	pointer
+	O
count	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
names	pointer
[	O
i	long
]	O
;	O
i	long
++	O
,	O
p	pointer
+=	O
max_len	long
+	O
1	int
)	O
{	O
exlist	array
[	O
i	long
]	O
=	O
p	pointer
;	O
for	O
(	O
j	long
=	O
0	int
;	O
names	pointer
[	O
i	long
]	O
[	O
j	long
]	O
;	O
j	long
++	O
)	O
p	pointer
[	O
j	long
]	O
=	O
mu_tolower	O
(	O
names	pointer
[	O
i	long
]	O
[	O
j	long
]	O
)	O
;	O
p	pointer
[	O
j	long
++	O
]	O
=	O
':'	O
;	O
memset	function
(	O
p	pointer
+	O
j	long
,	O
0	int
,	O
max_len	int
-	O
j	long
+	O
1	int
)	O
;	O
}	O
qsort	function
(	O
exlist	pointer
,	O
count	long
,	O
sizeof	O
(	O
exlist	array
[	O
0	int
]	O
)	O
,	O
excmp	pointer
)	O
;	O
*	O
pcount	pointer
=	O
count	pointer
;	O
*	O
pmax	pointer
=	O
max_len	pointer
;	O
return	O
exlist	pointer
;	O
}	O
int	O
mu_stream_header_copy	function
(	O
mu_stream_t	pointer
dst	pointer
,	O
mu_stream_t	pointer
src	pointer
,	O
char	O
*	O
*	O
exclude_names	pointer
)	O
{	O
int	O
rc	int
;	O
size_t	long
la_max	long
;	O
char	O
*	O
lookahead	int
;	O
size_t	long
la_idx	long
=	O
0	int
;	O
enum	O
{	O
save_state_init	int
,	O
save_state_expect	int
,	O
save_state_skip	int
,	O
save_state_copy	int
,	O
save_state_stop	int
}	O
state	pointer
=	O
save_state_init	int
;	O
int	O
i	int
=	O
0	int
;	O
int	O
j	int
=	O
0	int
;	O
char	O
*	O
*	O
exclude	pointer
;	O
size_t	long
excount	long
;	O
exclude	struct
=	O
make_exclusion_list	function
(	O
exclude_names	pointer
,	O
&	O
excount	O
,	O
&	O
la_max	struct
)	O
;	O
if	O
(	O
!	O
exclude	O
)	O
return	O
ENOMEM	int
;	O
lookahead	int
=	O
malloc	function
(	O
la_max	pointer
)	O
;	O
if	O
(	O
!	O
lookahead	int
)	O
{	O
free	function
(	O
exclude	struct
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
while	O
(	O
state	pointer
!=	O
save_state_stop	int
)	O
{	O
char	O
c	int
;	O
size_t	long
n	long
;	O
rc	int
=	O
mu_stream_read	function
(	O
src	pointer
,	O
&	O
c	int
,	O
1	int
,	O
&	O
n	long
)	O
;	O
if	O
(	O
rc	int
||	O
n	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
state	pointer
==	O
save_state_init	int
||	O
state	pointer
==	O
save_state_expect	int
)	O
{	O
if	O
(	O
la_idx	int
==	O
la_max	int
)	O
state	pointer
=	O
save_state_copy	int
;	O
else	O
{	O
lookahead	array
[	O
la_idx	int
++	O
]	O
=	O
c	int
;	O
c	int
=	O
mu_tolower	O
(	O
c	int
)	O
;	O
}	O
}	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
save_state_init	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
state	pointer
=	O
save_state_stop	int
;	O
break	O
;	O
}	O
j	long
=	O
0	int
;	O
state	pointer
=	O
save_state_copy	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	int
<	O
excount	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
exclude	struct
[	O
i	long
]	O
[	O
j	int
]	O
==	O
c	int
)	O
{	O
j	long
++	O
;	O
state	pointer
=	O
save_state_expect	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
save_state_expect	int
:	O
if	O
(	O
exclude	struct
[	O
i	long
]	O
[	O
j	int
]	O
!=	O
c	int
)	O
{	O
while	O
(	O
++	O
i	int
<	O
excount	int
)	O
{	O
if	O
(	O
memcmp	function
(	O
exclude	struct
[	O
i	long
-	O
1	int
]	O
,	O
exclude	struct
[	O
i	int
]	O
,	O
j	int
)	O
)	O
{	O
state	pointer
=	O
save_state_copy	int
;	O
break	O
;	O
}	O
if	O
(	O
exclude	struct
[	O
i	long
]	O
[	O
j	int
]	O
==	O
c	int
)	O
break	O
;	O
}	O
if	O
(	O
i	long
==	O
excount	int
)	O
state	pointer
=	O
save_state_copy	int
;	O
if	O
(	O
state	pointer
==	O
save_state_copy	int
)	O
break	O
;	O
}	O
if	O
(	O
c	int
==	O
':'	O
)	O
{	O
la_idx	long
=	O
0	int
;	O
state	pointer
=	O
save_state_skip	int
;	O
}	O
else	O
{	O
j	long
++	O
;	O
if	O
(	O
exclude	struct
[	O
i	long
]	O
[	O
j	long
]	O
==	O
0	int
)	O
state	pointer
=	O
save_state_copy	int
;	O
}	O
break	O
;	O
case	O
save_state_copy	int
:	O
if	O
(	O
la_idx	long
>	O
0	int
)	O
{	O
rc	int
=	O
mu_stream_write	function
(	O
dst	pointer
,	O
lookahead	int
,	O
la_idx	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
la_idx	int
=	O
0	int
;	O
}	O
rc	int
=	O
mu_stream_write	function
(	O
dst	pointer
,	O
&	O
c	int
,	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
state	pointer
=	O
save_state_init	int
;	O
break	O
;	O
case	O
save_state_skip	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
state	pointer
=	O
save_state_init	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
if	O
(	O
la_idx	int
>	O
1	int
)	O
rc	int
=	O
mu_stream_write	function
(	O
dst	pointer
,	O
lookahead	int
,	O
la_idx	int
-	O
1	int
,	O
NULL	O
)	O
;	O
}	O
free	function
(	O
lookahead	int
)	O
;	O
free	function
(	O
exclude	struct
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_c_strcasecmp	function
(	O
const	O
char	O
*	O
a	pointer
,	O
const	O
char	O
*	O
b	pointer
)	O
{	O
int	O
d	int
=	O
0	int
;	O
for	O
(	O
;	O
d	int
==	O
0	int
;	O
a	pointer
++	O
,	O
b	pointer
++	O
)	O
{	O
int	O
ac	int
=	O
(	O
int	O
)	O
*	O
a	pointer
;	O
int	O
bc	int
=	O
(	O
int	O
)	O
*	O
b	int
;	O
if	O
(	O
ac	int
==	O
0	int
||	O
bc	int
==	O
0	int
)	O
return	O
ac	int
-	O
bc	int
;	O
if	O
(	O
mu_isascii	O
(	O
ac	int
)	O
&&	O
mu_isascii	O
(	O
bc	int
)	O
)	O
d	int
=	O
mu_toupper	O
(	O
ac	int
)	O
-	O
mu_toupper	O
(	O
bc	int
)	O
;	O
else	O
d	int
=	O
ac	int
-	O
bc	int
;	O
}	O
return	O
d	int
;	O
}	O
int	O
mu_c_strncasecmp	function
(	O
const	O
char	O
*	O
a	pointer
,	O
const	O
char	O
*	O
b	pointer
,	O
size_t	long
n	long
)	O
{	O
int	O
d	int
=	O
0	int
;	O
for	O
(	O
;	O
d	pointer
==	O
0	int
&&	O
n	int
>	O
0	int
;	O
a	pointer
++	O
,	O
b	pointer
++	O
,	O
n	int
--	O
)	O
{	O
int	O
ac	int
=	O
(	O
int	O
)	O
*	O
a	pointer
;	O
int	O
bc	int
=	O
(	O
int	O
)	O
*	O
b	int
;	O
if	O
(	O
ac	int
==	O
0	int
||	O
bc	int
==	O
0	int
)	O
return	O
ac	int
-	O
bc	int
;	O
if	O
(	O
mu_isascii	O
(	O
ac	int
)	O
&&	O
mu_isascii	O
(	O
bc	int
)	O
)	O
d	int
=	O
mu_toupper	O
(	O
ac	int
)	O
-	O
mu_toupper	O
(	O
bc	int
)	O
;	O
else	O
d	int
=	O
ac	int
-	O
bc	int
;	O
}	O
return	O
d	int
;	O
}	O
int	O
mu_file_name_is_safe	function
(	O
char	O
const	O
*	O
str	pointer
)	O
{	O
enum	O
{	O
st_init	int
,	O
st_slash	int
,	O
st_dot	int
,	O
st_dotdot	int
}	O
state	int
;	O
unsigned	O
char	O
c	int
;	O
int	O
consume	int
=	O
0	int
;	O
if	O
(	O
!	O
str	pointer
)	O
return	O
0	int
;	O
state	pointer
=	O
(	O
*	O
str	pointer
==	O
'.'	O
)	O
?	O
st_dot	int
:	O
st_init	pointer
;	O
while	O
(	O
(	O
c	int
=	O
*	O
str	pointer
++	O
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
consume	int
)	O
consume	int
--	O
;	O
else	O
if	O
(	O
c	int
<	O
0xc0	int
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
st_init	int
:	O
if	O
(	O
c	int
==	O
'/'	O
)	O
state	pointer
=	O
st_slash	int
;	O
break	O
;	O
case	O
st_slash	int
:	O
if	O
(	O
c	int
==	O
'.'	O
)	O
state	pointer
=	O
st_dot	int
;	O
else	O
if	O
(	O
c	int
!=	O
'/'	O
)	O
state	pointer
=	O
st_init	int
;	O
break	O
;	O
case	O
st_dot	int
:	O
if	O
(	O
c	int
==	O
'.'	O
)	O
state	pointer
=	O
st_dotdot	int
;	O
else	O
if	O
(	O
c	int
==	O
'/'	O
)	O
state	pointer
=	O
st_slash	int
;	O
else	O
state	pointer
=	O
st_init	int
;	O
break	O
;	O
case	O
st_dotdot	int
:	O
if	O
(	O
c	int
==	O
'/'	O
)	O
return	O
0	int
;	O
else	O
state	pointer
=	O
st_init	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
c	int
&	O
0xc0	int
)	O
consume	int
=	O
1	int
;	O
else	O
if	O
(	O
c	int
&	O
0xe0	int
)	O
consume	int
=	O
2	int
;	O
else	O
if	O
(	O
c	int
&	O
0xf0	int
)	O
consume	int
=	O
3	int
;	O
}	O
if	O
(	O
state	pointer
==	O
st_dotdot	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
char	O
*	O
mu_str_skip_class	function
(	O
const	O
char	O
*	O
str	pointer
,	O
int	O
class	int
)	O
{	O
for	O
(	O
;	O
*	O
str	pointer
&&	O
mu_c_is_class	O
(	O
*	O
str	pointer
,	O
class	int
)	O
;	O
str	pointer
++	O
)	O
;	O
return	O
(	O
char	O
*	O
)	O
str	pointer
;	O
}	O
char	O
*	O
mu_str_skip_class_comp	function
(	O
const	O
char	O
*	O
str	pointer
,	O
int	O
class	int
)	O
{	O
for	O
(	O
;	O
*	O
str	pointer
&&	O
!	O
mu_c_is_class	O
(	O
*	O
str	pointer
,	O
class	int
)	O
;	O
str	pointer
++	O
)	O
;	O
return	O
(	O
char	O
*	O
)	O
str	pointer
;	O
}	O
char	O
*	O
mu_str_skip_cset	function
(	O
const	O
char	O
*	O
str	pointer
,	O
const	O
char	O
*	O
cset	pointer
)	O
{	O
for	O
(	O
;	O
*	O
str	pointer
&&	O
strchr	function
(	O
cset	pointer
,	O
*	O
str	pointer
)	O
;	O
str	pointer
++	O
)	O
;	O
return	O
(	O
char	O
*	O
)	O
str	pointer
;	O
}	O
char	O
*	O
mu_str_skip_cset_comp	function
(	O
const	O
char	O
*	O
str	pointer
,	O
const	O
char	O
*	O
cset	pointer
)	O
{	O
for	O
(	O
;	O
*	O
str	pointer
&&	O
strchr	function
(	O
cset	pointer
,	O
*	O
str	pointer
)	O
==	O
NULL	O
;	O
str	pointer
++	O
)	O
;	O
return	O
(	O
char	O
*	O
)	O
str	pointer
;	O
}	O
int	O
mu_string_unfold	function
(	O
char	O
*	O
text	pointer
,	O
size_t	long
*	O
plen	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
enum	O
uf_state	enum
{	O
uf_init	int
,	O
uf_nl	int
,	O
uf_fold	int
}	O
state	pointer
=	O
uf_init	int
;	O
if	O
(	O
!	O
text	pointer
)	O
return	O
EINVAL	int
;	O
for	O
(	O
p	pointer
=	O
q	pointer
=	O
text	pointer
;	O
*	O
q	pointer
;	O
q	pointer
++	O
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
uf_init	int
:	O
if	O
(	O
*	O
q	pointer
==	O
'\n'	O
)	O
state	pointer
=	O
uf_nl	int
;	O
else	O
*	O
p	pointer
++	O
=	O
*	O
q	pointer
;	O
break	O
;	O
case	O
uf_nl	int
:	O
if	O
(	O
ISSPACE	O
(	O
*	O
q	pointer
)	O
)	O
state	pointer
=	O
uf_fold	int
;	O
else	O
{	O
state	pointer
=	O
uf_init	int
;	O
*	O
p	pointer
++	O
=	O
*	O
q	pointer
;	O
}	O
break	O
;	O
case	O
uf_fold	int
:	O
if	O
(	O
!	O
ISSPACE	O
(	O
*	O
q	pointer
)	O
)	O
{	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
*	O
p	pointer
++	O
=	O
*	O
q	pointer
;	O
state	pointer
=	O
uf_init	int
;	O
}	O
break	O
;	O
}	O
}	O
*	O
p	pointer
++	O
=	O
0	int
;	O
if	O
(	O
plen	long
)	O
*	O
plen	pointer
=	O
p	pointer
-	O
text	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_vasnprintf	function
(	O
char	O
*	O
*	O
pbuf	pointer
,	O
size_t	long
*	O
psize	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
char	O
*	O
buf	pointer
=	O
*	O
pbuf	pointer
;	O
size_t	long
buflen	long
=	O
*	O
psize	pointer
;	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
!	O
buf	pointer
)	O
{	O
if	O
(	O
buflen	long
==	O
0	int
)	O
buflen	long
=	O
512	int
;	O
buf	pointer
=	O
calloc	function
(	O
1	int
,	O
buflen	long
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
ssize_t	long
n	long
;	O
va_list	array
aq	array
;	O
va_copy	O
(	O
aq	array
,	O
ap	array
)	O
;	O
n	long
=	O
vsnprintf	function
(	O
buf	pointer
,	O
buflen	long
,	O
fmt	pointer
,	O
aq	array
)	O
;	O
va_end	O
(	O
aq	array
)	O
;	O
if	O
(	O
n	long
<	O
0	int
||	O
n	long
>=	O
buflen	long
||	O
!	O
memchr	function
(	O
buf	pointer
,	O
'\0'	O
,	O
n	long
+	O
1	int
)	O
)	O
{	O
char	O
*	O
newbuf	pointer
;	O
size_t	long
newlen	long
=	O
buflen	long
*	O
2	int
;	O
if	O
(	O
newlen	long
<	O
buflen	long
)	O
{	O
rc	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
newbuf	pointer
=	O
realloc	function
(	O
buf	pointer
,	O
newlen	long
)	O
;	O
if	O
(	O
newbuf	pointer
==	O
NULL	O
)	O
{	O
rc	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
buflen	long
=	O
newlen	long
;	O
buf	pointer
=	O
newbuf	pointer
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
!	O
*	O
pbuf	pointer
)	O
{	O
free	function
(	O
buf	pointer
)	O
;	O
buf	pointer
=	O
NULL	O
;	O
buflen	long
=	O
0	int
;	O
}	O
}	O
*	O
pbuf	pointer
=	O
buf	pointer
;	O
*	O
psize	pointer
=	O
buflen	long
;	O
return	O
rc	int
;	O
}	O
static	O
void	O
print_bytes	function
(	O
unsigned	O
char	O
*	O
b	pointer
,	O
size_t	long
l	long
)	O
{	O
for	O
(	O
;	O
l	long
;	O
l	long
--	O
,	O
b	int
++	O
)	O
printf	function
(	O
" %02x"	pointer
,	O
*	O
b	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
flags	int
=	O
0	int
;	O
mu_set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
argc	long
<	O
2	int
)	O
{	O
mu_error	function
(	O
"usage: %s [-sS] CIDR [CIDR...]"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
while	O
(	O
--	O
argc	long
)	O
{	O
char	O
*	O
arg	pointer
=	O
*	O
++	O
argv	pointer
;	O
struct	O
mu_cidr	struct
cidr	pointer
;	O
int	O
rc	int
;	O
char	O
*	O
str	pointer
;	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"-s"	pointer
)	O
==	O
0	int
)	O
{	O
flags	int
|=	O
MU_CIDR_FMT_SIMPLIFY	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"-S"	pointer
)	O
==	O
0	int
)	O
{	O
flags	int
&=	O
~	O
MU_CIDR_FMT_SIMPLIFY	int
;	O
continue	O
;	O
}	O
rc	int
=	O
mu_cidr_from_string	function
(	O
&	O
cidr	pointer
,	O
arg	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
"%s: %s"	pointer
,	O
arg	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
continue	O
;	O
}	O
printf	function
(	O
"%s:\n"	pointer
,	O
arg	pointer
)	O
;	O
printf	function
(	O
"family = %d\n"	pointer
,	O
cidr	pointer
.	O
family	int
)	O
;	O
printf	function
(	O
"len = %d\n"	pointer
,	O
cidr	pointer
.	O
len	long
)	O
;	O
printf	function
(	O
"address ="	pointer
)	O
;	O
print_bytes	function
(	O
cidr	pointer
.	O
address	array
,	O
cidr	pointer
.	O
len	int
)	O
;	O
printf	function
(	O
"netmask ="	pointer
)	O
;	O
print_bytes	function
(	O
cidr	pointer
.	O
netmask	array
,	O
cidr	pointer
.	O
len	int
)	O
;	O
rc	int
=	O
mu_cidr_format	function
(	O
&	O
cidr	pointer
,	O
flags	int
,	O
&	O
str	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
"cannot covert to string: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
2	int
;	O
}	O
printf	function
(	O
"string = %s\n"	pointer
,	O
str	pointer
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
decode_octal	function
(	O
char	O
*	O
buf	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
unsigned	O
i	int
,	O
n	int
;	O
for	O
(	O
p	pointer
=	O
buf	pointer
;	O
*	O
p	pointer
;	O
)	O
{	O
if	O
(	O
*	O
buf	pointer
==	O
'\\'	O
)	O
{	O
buf	pointer
++	O
;	O
switch	O
(	O
*	O
buf	pointer
)	O
{	O
case	O
'a'	O
:	O
*	O
p	pointer
++	O
=	O
'\a'	O
;	O
buf	pointer
++	O
;	O
break	O
;	O
case	O
'b'	O
:	O
*	O
p	pointer
++	O
=	O
'\b'	O
;	O
buf	pointer
++	O
;	O
break	O
;	O
case	O
'f'	O
:	O
*	O
p	pointer
++	O
=	O
'\f'	O
;	O
buf	pointer
++	O
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
p	pointer
++	O
=	O
'\n'	O
;	O
buf	pointer
++	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
p	pointer
++	O
=	O
'\r'	O
;	O
buf	pointer
++	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
p	pointer
++	O
=	O
'\t'	O
;	O
buf	pointer
++	O
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
n	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
3	int
;	O
i	int
++	O
,	O
buf	pointer
++	O
)	O
{	O
unsigned	O
x	int
=	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
-	O
'0'	O
;	O
if	O
(	O
x	int
>	O
7	int
)	O
break	O
;	O
n	int
<<=	O
3	int
;	O
n	int
+=	O
x	int
;	O
}	O
if	O
(	O
i	int
!=	O
3	int
)	O
{	O
buf	pointer
-=	O
i	int
;	O
*	O
p	pointer
++	O
=	O
'\\'	O
;	O
}	O
else	O
*	O
p	pointer
++	O
=	O
n	int
;	O
break	O
;	O
default	O
:	O
*	O
p	pointer
++	O
=	O
'\\'	O
;	O
*	O
p	pointer
++	O
=	O
*	O
buf	pointer
++	O
;	O
break	O
;	O
}	O
}	O
else	O
*	O
p	pointer
++	O
=	O
*	O
buf	pointer
++	O
;	O
}	O
*	O
p	pointer
=	O
0	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
size_t	long
n	int
;	O
char	O
*	O
charset	pointer
=	O
"iso-8859-1"	pointer
;	O
char	O
*	O
encoding	pointer
=	O
"quoted-printable"	pointer
;	O
int	O
octal	int
=	O
0	int
;	O
while	O
(	O
(	O
rc	int
=	O
getopt	function
(	O
argc	int
,	O
argv	pointer
,	O
"c:e:hot"	pointer
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
rc	int
)	O
{	O
case	O
'c'	O
:	O
charset	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'e'	O
:	O
encoding	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'o'	O
:	O
octal	int
=	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
octal	int
=	O
0	int
;	O
break	O
;	O
case	O
'h'	O
:	O
printf	function
(	O
"usage: %s [-c charset] [-e encoding] [-ot]\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
default	O
:	O
exit	function
(	O
1	int
)	O
;	O
}	O
mu_stdstream_setup	function
(	O
MU_STDSTREAM_RESET_NONE	int
)	O
;	O
while	O
(	O
(	O
rc	int
=	O
mu_stream_getline	function
(	O
mu_strin	pointer
,	O
&	O
buf	pointer
,	O
&	O
size	long
,	O
&	O
n	int
)	O
)	O
==	O
0	int
&&	O
n	int
>	O
0	int
)	O
{	O
char	O
*	O
p	pointer
;	O
mu_rtrim_class	function
(	O
buf	pointer
,	O
MU_CTYPE_ENDLN	int
)	O
;	O
if	O
(	O
octal	int
)	O
decode_octal	function
(	O
buf	pointer
)	O
;	O
rc	int
=	O
mu_rfc2047_encode	function
(	O
charset	pointer
,	O
encoding	pointer
,	O
buf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_rfc2047_encode"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
else	O
if	O
(	O
p	pointer
)	O
mu_printf	function
(	O
"%s\n"	pointer
,	O
p	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_getline"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	int
,	O
rc	int
;	O
int	O
echo_state	int
=	O
0	int
;	O
size_t	long
n	int
;	O
char	O
buf	pointer
[	O
80	int
]	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
arg	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"-noecho"	pointer
)	O
==	O
0	int
)	O
{	O
MU_ASSERT	O
(	O
mu_stream_ioctl	function
(	O
mu_strin	pointer
,	O
MU_IOCTL_ECHO	int
,	O
MU_IOCTL_OP_SET	int
,	O
&	O
echo_state	pointer
)	O
)	O
;	O
echo_state	int
=	O
1	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: %s [-noecho]\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
while	O
(	O
(	O
rc	int
=	O
mu_stream_read	function
(	O
mu_strin	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
&	O
n	int
)	O
==	O
0	int
)	O
&&	O
n	int
>	O
0	int
)	O
fwrite	function
(	O
buf	pointer
,	O
1	int
,	O
n	int
,	O
stdout	pointer
)	O
;	O
if	O
(	O
echo_state	int
)	O
MU_ASSERT	O
(	O
mu_stream_ioctl	function
(	O
mu_strin	pointer
,	O
MU_IOCTL_ECHO	int
,	O
MU_IOCTL_OP_SET	int
,	O
&	O
echo_state	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_stream_t	pointer
str	pointer
=	O
mu_strout	pointer
;	O
int	O
i	int
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: %s: word|option [word|option...]\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"options are: -out, -err, -reset\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
mu_set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
char	O
*	O
arg	pointer
=	O
argv	pointer
[	O
i	int
]	O
;	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"-out"	pointer
)	O
==	O
0	int
)	O
str	pointer
=	O
mu_strout	pointer
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"-err"	pointer
)	O
==	O
0	int
)	O
str	pointer
=	O
mu_strerr	pointer
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"-reset"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
str	pointer
==	O
mu_strout	int
)	O
{	O
mu_stdstream_setup	function
(	O
MU_STDSTREAM_RESET_STROUT	pointer
)	O
;	O
str	pointer
=	O
mu_strout	pointer
;	O
}	O
else	O
{	O
mu_stdstream_setup	function
(	O
MU_STDSTREAM_RESET_STRERR	pointer
)	O
;	O
str	pointer
=	O
mu_strerr	pointer
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: unrecognized option %s\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
arg	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
mu_stream_printf	function
(	O
str	pointer
,	O
"%s\n"	pointer
,	O
arg	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
name	pointer
;	O
mu_stream_t	pointer
stream	pointer
;	O
void	O
match_string	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
int	O
rc	int
;	O
mu_url_t	pointer
u	pointer
,	O
url	pointer
;	O
struct	O
mu_locus_point	struct
loc	struct
;	O
if	O
(	O
(	O
rc	int
=	O
mu_url_create	function
(	O
&	O
u	pointer
,	O
str	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"mu_url_create %s ERROR: [%d] %s"	pointer
,	O
str	pointer
,	O
rc	int
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
;	O
}	O
MU_ASSERT	O
(	O
mu_stream_seek	function
(	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
)	O
;	O
loc	pointer
.	O
mu_file	pointer
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
loc	pointer
.	O
mu_line	int
=	O
0	int
;	O
loc	pointer
.	O
mu_col	int
=	O
0	int
;	O
rc	int
=	O
mu_wicket_stream_match_url	function
(	O
stream	pointer
,	O
&	O
loc	pointer
,	O
u	pointer
,	O
MU_URL_PARSE_ALL	O
,	O
&	O
url	pointer
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
printf	function
(	O
"%s matches %s at %s:%d\n"	pointer
,	O
mu_url_to_string	function
(	O
u	pointer
)	O
,	O
mu_url_to_string	function
(	O
url	pointer
)	O
,	O
loc	struct
.	O
mu_file	pointer
,	O
loc	pointer
.	O
mu_line	int
)	O
;	O
mu_url_destroy	function
(	O
&	O
url	pointer
)	O
;	O
break	O
;	O
case	O
MU_ERR_NOENT	O
:	O
printf	function
(	O
"no matches for %s\n"	pointer
,	O
mu_url_to_string	function
(	O
u	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
mu_error	function
(	O
"mu_wicket_stream_match_url: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
mu_url_destroy	function
(	O
&	O
u	pointer
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: %s filename [url [url...]]\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
name	pointer
=	O
argv	pointer
[	O
1	int
]	O
;	O
MU_ASSERT	O
(	O
mu_file_stream_create	function
(	O
&	O
stream	pointer
,	O
name	pointer
,	O
MU_STREAM_READ	int
)	O
)	O
;	O
if	O
(	O
argc	int
>	O
2	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
match_string	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
}	O
else	O
{	O
mu_stream_t	pointer
in	pointer
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
,	O
n	pointer
;	O
int	O
rc	int
;	O
MU_ASSERT	O
(	O
mu_stdio_stream_create	function
(	O
&	O
in	pointer
,	O
MU_STDIN_FD	int
,	O
0	int
)	O
)	O
;	O
while	O
(	O
(	O
rc	int
=	O
mu_stream_getline	function
(	O
in	pointer
,	O
&	O
buf	pointer
,	O
&	O
size	long
,	O
&	O
n	pointer
)	O
)	O
==	O
0	int
&&	O
n	pointer
>	O
0	int
)	O
match_string	function
(	O
mu_str_stripws	function
(	O
buf	pointer
)	O
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
in	pointer
)	O
;	O
}	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
decode_tab	struct
{	O
int	O
mask	int
;	O
int	O
(	O
*	O
fun	pointer
)	O
(	O
mu_url_t	pointer
,	O
size_t	long
)	O
;	O
size_t	long
off	long
;	O
}	O
;	O
static	O
int	O
_url_dec_str	function
(	O
mu_url_t	pointer
url	pointer
,	O
size_t	long
off	long
)	O
{	O
char	O
*	O
*	O
pptr	pointer
=	O
(	O
char	O
*	O
*	O
)	O
(	O
(	O
char	O
*	O
)	O
url	pointer
+	O
off	long
)	O
;	O
mu_str_url_decode_inline	function
(	O
*	O
pptr	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_url_dec_param	function
(	O
mu_url_t	pointer
url	pointer
,	O
size_t	long
off	long
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
url	pointer
->	O
fvcount	int
;	O
i	int
++	O
)	O
mu_str_url_decode_inline	function
(	O
url	pointer
->	O
fvpairs	pointer
[	O
i	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_url_dec_query	function
(	O
mu_url_t	pointer
url	pointer
,	O
size_t	long
off	long
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
url	pointer
->	O
qargc	int
;	O
i	int
++	O
)	O
mu_str_url_decode_inline	function
(	O
url	pointer
->	O
qargv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_url_dec_secret	function
(	O
mu_url_t	pointer
url	pointer
,	O
size_t	long
off	long
)	O
{	O
char	O
*	O
pass	pointer
;	O
mu_secret_t	pointer
newsec	pointer
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_str_url_decode	function
(	O
&	O
pass	pointer
,	O
mu_secret_password	function
(	O
url	pointer
->	O
secret	pointer
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_secret_create	function
(	O
&	O
newsec	pointer
,	O
pass	double
,	O
strlen	function
(	O
pass	pointer
)	O
)	O
;	O
memset	function
(	O
pass	pointer
,	O
0	int
,	O
strlen	function
(	O
pass	pointer
)	O
)	O
;	O
free	function
(	O
pass	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_secret_destroy	function
(	O
&	O
url	pointer
->	O
secret	pointer
)	O
;	O
url	pointer
->	O
secret	pointer
=	O
newsec	pointer
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
decode_tab	struct
decode_tab	array
[	O
]	O
=	O
{	O
{	O
MU_URL_SCHEME	int
,	O
_url_dec_str	int
,	O
mu_offsetof	O
(	O
struct	O
_mu_url	struct
,	O
scheme	pointer
)	O
}	O
,	O
{	O
MU_URL_USER	int
,	O
_url_dec_str	pointer
,	O
mu_offsetof	O
(	O
struct	O
_mu_url	struct
,	O
user	pointer
)	O
}	O
,	O
{	O
MU_URL_SECRET	int
,	O
_url_dec_secret	O
}	O
,	O
{	O
MU_URL_AUTH	int
,	O
_url_dec_str	int
,	O
mu_offsetof	O
(	O
struct	O
_mu_url	struct
,	O
auth	pointer
)	O
}	O
,	O
{	O
MU_URL_HOST	int
,	O
_url_dec_str	pointer
,	O
mu_offsetof	O
(	O
struct	O
_mu_url	struct
,	O
host	pointer
)	O
}	O
,	O
{	O
MU_URL_PATH	int
,	O
_url_dec_str	O
,	O
mu_offsetof	O
(	O
struct	O
_mu_url	struct
,	O
path	pointer
)	O
}	O
,	O
{	O
MU_URL_PARAM	int
,	O
_url_dec_param	O
,	O
0	int
}	O
,	O
{	O
MU_URL_QUERY	int
,	O
_url_dec_query	function
,	O
0	int
}	O
}	O
;	O
int	O
mu_url_decode	function
(	O
mu_url_t	pointer
url	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
url	pointer
)	O
return	O
EINVAL	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MU_ARRAY_SIZE	O
(	O
decode_tab	pointer
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
decode_tab	array
[	O
i	int
]	O
.	O
mask	int
)	O
{	O
int	O
rc	int
=	O
decode_tab	array
[	O
i	int
]	O
.	O
fun	pointer
(	O
url	pointer
,	O
decode_tab	pointer
[	O
i	int
]	O
.	O
off	long
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_url_dup	function
(	O
mu_url_t	pointer
old_url	pointer
,	O
mu_url_t	pointer
*	O
new_url	pointer
)	O
{	O
int	O
rc	int
;	O
const	O
char	O
*	O
s	pointer
;	O
mu_url_t	pointer
url	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
url	pointer
)	O
)	O
;	O
if	O
(	O
!	O
url	pointer
)	O
return	O
ENOMEM	int
;	O
mu_url_sget_name	function
(	O
old_url	pointer
,	O
&	O
s	pointer
)	O
;	O
url	pointer
->	O
name	pointer
=	O
strdup	function
(	O
s	pointer
)	O
;	O
if	O
(	O
!	O
url	pointer
->	O
name	pointer
)	O
{	O
free	function
(	O
url	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
rc	int
=	O
mu_url_copy_hints	function
(	O
url	pointer
,	O
old_url	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_url_destroy	function
(	O
&	O
url	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
*	O
new_url	pointer
=	O
url	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
url_reconstruct_to_pool	function
(	O
mu_url_t	pointer
url	pointer
,	O
mu_opool_t	pointer
pool	pointer
)	O
{	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
MU_URL_SCHEME	int
)	O
{	O
int	O
i	int
;	O
mu_opool_appendz	function
(	O
pool	pointer
,	O
url	pointer
->	O
scheme	pointer
)	O
;	O
mu_opool_append	function
(	O
pool	pointer
,	O
"://"	pointer
,	O
3	int
)	O
;	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
MU_URL_USER	int
)	O
mu_opool_appendz	function
(	O
pool	pointer
,	O
url	pointer
->	O
user	pointer
)	O
;	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
MU_URL_SECRET	int
)	O
mu_opool_append	function
(	O
pool	pointer
,	O
":***"	pointer
,	O
4	int
)	O
;	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
MU_URL_AUTH	int
)	O
{	O
mu_opool_append	function
(	O
pool	array
,	O
AUTH_PFX	int
,	O
sizeof	O
AUTH_PFX	int
-	O
1	int
)	O
;	O
mu_opool_appendz	function
(	O
pool	pointer
,	O
url	pointer
->	O
auth	pointer
)	O
;	O
}	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
MU_URL_HOST	int
)	O
{	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
(	O
MU_URL_USER	int
|	O
MU_URL_SECRET	int
|	O
MU_URL_AUTH	int
)	O
)	O
mu_opool_append_char	function
(	O
pool	array
,	O
'@'	O
)	O
;	O
mu_opool_appendz	function
(	O
pool	pointer
,	O
url	pointer
->	O
host	pointer
)	O
;	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
MU_URL_PORT	int
)	O
{	O
mu_opool_append_char	function
(	O
pool	array
,	O
':'	O
)	O
;	O
mu_opool_appendz	function
(	O
pool	pointer
,	O
url	pointer
->	O
portstr	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
(	O
MU_URL_USER	int
|	O
MU_URL_SECRET	int
|	O
MU_URL_AUTH	int
)	O
)	O
return	O
MU_ERR_URL_MISS_PARTS	int
;	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
MU_URL_PATH	int
)	O
{	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
MU_URL_HOST	int
)	O
mu_opool_append_char	function
(	O
pool	array
,	O
'/'	O
)	O
;	O
mu_opool_appendz	function
(	O
pool	pointer
,	O
url	pointer
->	O
path	pointer
)	O
;	O
}	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
MU_URL_PARAM	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
url	pointer
->	O
fvcount	int
;	O
i	int
++	O
)	O
{	O
mu_opool_append_char	function
(	O
pool	array
,	O
';'	O
)	O
;	O
mu_opool_append	function
(	O
pool	array
,	O
url	pointer
->	O
fvpairs	pointer
[	O
i	int
]	O
,	O
strlen	function
(	O
url	pointer
->	O
fvpairs	pointer
[	O
i	int
]	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
url	pointer
->	O
flags	int
&	O
MU_URL_QUERY	int
)	O
{	O
mu_opool_append_char	function
(	O
pool	array
,	O
'?'	O
)	O
;	O
mu_opool_append	function
(	O
pool	array
,	O
url	pointer
->	O
qargv	pointer
[	O
0	int
]	O
,	O
strlen	function
(	O
url	pointer
->	O
qargv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
url	pointer
->	O
qargc	int
;	O
i	int
++	O
)	O
{	O
mu_opool_append_char	function
(	O
pool	array
,	O
'&'	O
)	O
;	O
mu_opool_append	function
(	O
pool	array
,	O
url	pointer
->	O
qargv	pointer
[	O
i	int
]	O
,	O
strlen	function
(	O
url	pointer
->	O
qargv	pointer
[	O
i	int
]	O
)	O
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
url	pointer
->	O
flags	int
==	O
MU_URL_PATH	int
)	O
{	O
mu_opool_appendz	function
(	O
pool	pointer
,	O
url	pointer
->	O
path	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
MU_ERR_URL_MISS_PARTS	int
;	O
}	O
int	O
mu_url_sget_name	function
(	O
const	O
mu_url_t	pointer
url	pointer
,	O
const	O
char	O
*	O
*	O
retptr	pointer
)	O
{	O
if	O
(	O
!	O
url	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
url	pointer
->	O
name	pointer
)	O
{	O
mu_opool_t	pointer
pool	pointer
;	O
int	O
rc	int
;	O
char	O
*	O
ptr	pointer
,	O
*	O
newname	pointer
;	O
size_t	long
size	long
;	O
rc	int
=	O
mu_opool_create	function
(	O
&	O
pool	pointer
,	O
MU_OPOOL_DEFAULT	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
url_reconstruct_to_pool	function
(	O
url	pointer
,	O
pool	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_opool_destroy	function
(	O
&	O
pool	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
ptr	pointer
=	O
mu_opool_finish	function
(	O
pool	pointer
,	O
&	O
size	int
)	O
;	O
newname	pointer
=	O
realloc	function
(	O
url	pointer
->	O
name	pointer
,	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
newname	pointer
)	O
{	O
mu_opool_destroy	function
(	O
&	O
pool	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
memcpy	function
(	O
newname	pointer
,	O
ptr	pointer
,	O
size	long
)	O
;	O
newname	pointer
[	O
size	int
]	O
=	O
0	int
;	O
url	pointer
->	O
name	pointer
=	O
newname	pointer
;	O
mu_opool_destroy	function
(	O
&	O
pool	pointer
)	O
;	O
}	O
if	O
(	O
retptr	int
)	O
*	O
retptr	pointer
=	O
url	pointer
->	O
name	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_url_aget_name	function
(	O
const	O
mu_url_t	pointer
url	pointer
,	O
char	O
*	O
*	O
ret	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
const	O
char	O
*	O
ptr	pointer
;	O
int	O
rc	int
=	O
mu_url_sget_name	function
(	O
url	pointer
,	O
&	O
ptr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
s	pointer
=	O
strdup	function
(	O
ptr	pointer
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
errno	O
;	O
*	O
ret	pointer
=	O
s	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_url_get_name	function
(	O
const	O
mu_url_t	pointer
url	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
size_t	long
*	O
n	pointer
)	O
{	O
size_t	long
i	pointer
;	O
const	O
char	O
*	O
ptr	pointer
;	O
int	O
rc	int
=	O
mu_url_sget_name	function
(	O
url	pointer
,	O
&	O
ptr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
i	int
=	O
mu_cpystr	function
(	O
buf	pointer
,	O
ptr	pointer
,	O
size	long
)	O
;	O
if	O
(	O
n	int
)	O
*	O
n	pointer
=	O
i	int
;	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
mu_url_to_string	function
(	O
const	O
mu_url_t	pointer
url	pointer
)	O
{	O
const	O
char	O
*	O
ptr	pointer
;	O
if	O
(	O
mu_url_sget_name	function
(	O
url	pointer
,	O
&	O
ptr	pointer
)	O
)	O
return	O
""	pointer
;	O
return	O
ptr	pointer
;	O
}	O
int	O
mu_tls_enable	int
=	O
0	int
;	O
int	O
mu_tls_cert_file_checks	int
=	O
MU_TLS_CERT_FILE_CHECKS	O
;	O
int	O
mu_tls_key_file_checks	int
=	O
MU_TLS_KEY_FILE_CHECKS	O
;	O
int	O
mu_tls_ca_file_checks	int
=	O
MU_TLS_CA_FILE_CHECKS	O
;	O
static	O
int	O
check_err	function
(	O
int	O
rc	int
)	O
{	O
switch	O
(	O
rc	int
)	O
{	O
case	O
MU_ERR_PERM_OWNER_MISMATCH	int
:	O
case	O
MU_ERR_PERM_GROUP_WRITABLE	int
:	O
case	O
MU_ERR_PERM_WORLD_WRITABLE	int
:	O
case	O
MU_ERR_PERM_GROUP_READABLE	int
:	O
case	O
MU_ERR_PERM_WORLD_READABLE	int
:	O
case	O
MU_ERR_PERM_LINKED_WRDIR	int
:	O
case	O
MU_ERR_PERM_DIR_IWGRP	int
:	O
case	O
MU_ERR_PERM_DIR_IWOTH	int
:	O
return	O
MU_TLS_CONFIG_UNSAFE	int
;	O
default	O
:	O
return	O
MU_TLS_CONFIG_FAIL	int
;	O
}	O
}	O
int	O
mu_tls_config_check	function
(	O
struct	O
mu_tls_config	struct
const	O
*	O
conf	pointer
,	O
int	O
verbose	int
)	O
{	O
int	O
rc	int
;	O
int	O
res	int
=	O
MU_TLS_CONFIG_NULL	int
;	O
if	O
(	O
conf	pointer
->	O
cert_file	pointer
)	O
{	O
rc	int
=	O
mu_file_safety_check	function
(	O
conf	pointer
->	O
cert_file	pointer
,	O
mu_tls_cert_file_checks	int
,	O
-	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
verbose	int
)	O
mu_error	function
(	O
"%s: %s"	pointer
,	O
conf	pointer
->	O
cert_file	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
check_err	function
(	O
rc	int
)	O
;	O
}	O
res	int
=	O
MU_TLS_CONFIG_OK	int
;	O
}	O
if	O
(	O
conf	pointer
->	O
key_file	int
)	O
{	O
rc	int
=	O
mu_file_safety_check	function
(	O
conf	pointer
->	O
key_file	int
,	O
mu_tls_key_file_checks	int
,	O
-	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
verbose	int
)	O
mu_error	function
(	O
"%s: %s"	pointer
,	O
conf	pointer
->	O
key_file	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
check_err	function
(	O
rc	int
)	O
;	O
}	O
res	int
=	O
MU_TLS_CONFIG_OK	int
;	O
}	O
if	O
(	O
conf	pointer
->	O
ca_file	pointer
)	O
{	O
rc	int
=	O
mu_file_safety_check	function
(	O
conf	pointer
->	O
ca_file	int
,	O
mu_tls_ca_file_checks	int
,	O
-	O
1	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
verbose	int
)	O
mu_error	function
(	O
"%s: %s"	pointer
,	O
conf	pointer
->	O
ca_file	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
check_err	function
(	O
rc	int
)	O
;	O
}	O
res	int
=	O
MU_TLS_CONFIG_OK	int
;	O
}	O
if	O
(	O
conf	pointer
->	O
priorities	int
)	O
res	int
=	O
MU_TLS_CONFIG_OK	int
;	O
return	O
res	int
;	O
}	O
int	O
mu_dbm_firstkey	function
(	O
mu_dbm_file_t	pointer
db	pointer
,	O
struct	O
mu_dbm_datum	struct
*	O
ret	pointer
)	O
{	O
DBMSYSCK	O
(	O
db	pointer
,	O
_dbm_firstkey	pointer
)	O
;	O
if	O
(	O
!	O
db	pointer
->	O
db_descr	pointer
)	O
return	O
EINVAL	int
;	O
return	O
db	pointer
->	O
db_sys	pointer
->	O
_dbm_firstkey	pointer
(	O
db	pointer
,	O
ret	pointer
)	O
;	O
}	O
int	O
mu_dbm_get_name	function
(	O
mu_dbm_file_t	pointer
db	pointer
,	O
const	O
char	O
*	O
*	O
pname	pointer
)	O
{	O
if	O
(	O
!	O
db	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
pname	pointer
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
*	O
pname	pointer
=	O
db	pointer
->	O
db_name	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_dbm_open	function
(	O
mu_dbm_file_t	pointer
db	pointer
,	O
int	O
flags	int
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
!	O
db	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
db	pointer
->	O
db_sys	pointer
||	O
!	O
db	pointer
->	O
db_sys	pointer
->	O
_dbm_open	pointer
)	O
return	O
ENOSYS	int
;	O
return	O
db	pointer
->	O
db_sys	pointer
->	O
_dbm_open	pointer
(	O
db	pointer
,	O
flags	int
,	O
mode	int
)	O
;	O
}	O
int	O
mu_dbm_safety_set_owner	function
(	O
mu_dbm_file_t	pointer
db	pointer
,	O
uid_t	int
uid	int
)	O
{	O
if	O
(	O
!	O
db	pointer
)	O
return	O
EINVAL	int
;	O
db	pointer
->	O
db_owner	int
=	O
uid	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_dbm_safety_get_owner	function
(	O
mu_dbm_file_t	pointer
db	pointer
,	O
uid_t	int
*	O
uid	int
)	O
{	O
if	O
(	O
!	O
db	pointer
)	O
return	O
EINVAL	int
;	O
*	O
uid	int
=	O
db	pointer
->	O
db_owner	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_dbm_safety_set_flags	function
(	O
mu_dbm_file_t	pointer
db	pointer
,	O
int	O
flags	int
)	O
{	O
if	O
(	O
!	O
db	pointer
)	O
return	O
EINVAL	int
;	O
db	pointer
->	O
db_safety_flags	int
=	O
flags	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_dbm_safety_get_flags	function
(	O
mu_dbm_file_t	pointer
db	pointer
,	O
int	O
*	O
flags	int
)	O
{	O
if	O
(	O
!	O
db	pointer
)	O
return	O
EINVAL	int
;	O
*	O
flags	int
=	O
db	pointer
->	O
db_safety_flags	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_dbm_safety_check	function
(	O
mu_dbm_file_t	pointer
db	pointer
)	O
{	O
if	O
(	O
!	O
db	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
db	pointer
->	O
db_sys	pointer
||	O
!	O
db	pointer
->	O
db_sys	pointer
->	O
_dbm_file_safety	pointer
)	O
return	O
ENOSYS	int
;	O
return	O
db	pointer
->	O
db_sys	pointer
->	O
_dbm_file_safety	pointer
(	O
db	pointer
,	O
db	pointer
->	O
db_safety_flags	pointer
,	O
db	pointer
->	O
db_owner	int
)	O
;	O
}	O
static	O
void	O
argv_free	function
(	O
void	O
*	O
p	pointer
)	O
{	O
mu_argv_free	function
(	O
(	O
char	O
*	O
*	O
)	O
p	pointer
)	O
;	O
}	O
static	O
SCM	function
make_filter_port	function
(	O
SCM	function
port	int
,	O
SCM	function
name	pointer
,	O
SCM	function
args	pointer
,	O
int	O
filter_mode	int
,	O
char	O
const	O
*	O
func_name	pointer
)	O
{	O
char	O
*	O
fltname	pointer
;	O
mu_stream_t	pointer
filter	pointer
;	O
mu_stream_t	pointer
instr	pointer
;	O
size_t	long
argc	long
=	O
0	int
;	O
char	O
*	O
*	O
argv	pointer
=	O
NULL	O
;	O
int	O
rc	int
;	O
int	O
flags	int
=	O
0	int
;	O
char	O
*	O
port_mode	pointer
;	O
SCM_ASSERT	function
(	O
scm_port_p	O
(	O
port	int
)	O
,	O
port	O
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
name	pointer
)	O
,	O
name	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_VALIDATE_REST_ARGUMENT	function
(	O
args	pointer
)	O
;	O
port_mode	pointer
=	O
scm_to_locale_string	function
(	O
scm_port_mode	O
(	O
port	pointer
)	O
)	O
;	O
if	O
(	O
strchr	function
(	O
port_mode	pointer
,	O
'r'	O
)	O
)	O
flags	int
|=	O
MU_STREAM_READ	int
;	O
if	O
(	O
strchr	function
(	O
port_mode	pointer
,	O
'w'	O
)	O
)	O
flags	int
|=	O
MU_STREAM_WRITE	int
;	O
free	function
(	O
port_mode	pointer
)	O
;	O
if	O
(	O
!	O
flags	int
||	O
(	O
(	O
flags	int
&	O
(	O
MU_STREAM_READ	int
|	O
MU_STREAM_WRITE	int
)	O
)	O
==	O
(	O
MU_STREAM_READ	int
|	O
MU_STREAM_WRITE	int
)	O
)	O
)	O
scm_out_of_range	function
(	O
FUNC_NAME	O
,	O
port	O
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
fltname	pointer
=	O
scm_to_locale_string	function
(	O
name	pointer
)	O
;	O
scm_dynwind_free	function
(	O
fltname	pointer
)	O
;	O
rc	int
=	O
mu_scm_port_stream_create	function
(	O
&	O
instr	pointer
,	O
port	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to convert transport port ~A"	pointer
,	O
scm_list_1	function
(	O
port	pointer
)	O
)	O
;	O
}	O
if	O
(	O
!	O
scm_is_null	function
(	O
args	pointer
)	O
)	O
{	O
size_t	long
n	long
;	O
argc	int
=	O
scm_to_size_t	function
(	O
scm_length	function
(	O
args	pointer
)	O
)	O
+	O
1	int
;	O
argv	pointer
=	O
calloc	function
(	O
argc	long
+	O
1	int
,	O
sizeof	O
(	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
argv	pointer
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
ENOMEM	int
,	O
"Cannot allocate memory"	pointer
,	O
SCM_BOOL_F	O
)	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
strdup	function
(	O
fltname	pointer
)	O
;	O
n	long
=	O
1	int
;	O
for	O
(	O
;	O
!	O
scm_is_null	function
(	O
args	pointer
)	O
;	O
args	pointer
=	O
SCM_CDR	function
(	O
args	pointer
)	O
)	O
{	O
SCM	function
arg	O
=	O
SCM_CAR	function
(	O
args	pointer
)	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
arg	pointer
)	O
,	O
arg	pointer
,	O
SCM_ARGn	O
,	O
FUNC_NAME	O
)	O
;	O
argv	pointer
[	O
n	int
]	O
=	O
scm_to_locale_string	function
(	O
arg	pointer
)	O
;	O
n	int
++	O
;	O
}	O
argv	pointer
[	O
n	int
]	O
=	O
NULL	O
;	O
scm_dynwind_unwind_handler	function
(	O
argv_free	pointer
,	O
argv	pointer
,	O
SCM_F_WIND_EXPLICITLY	pointer
)	O
;	O
}	O
rc	int
=	O
mu_filter_create_args	function
(	O
&	O
filter	pointer
,	O
instr	pointer
,	O
fltname	pointer
,	O
argc	long
,	O
(	O
const	O
char	O
*	O
*	O
)	O
argv	pointer
,	O
filter_mode	int
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to create filter ~A"	pointer
,	O
scm_list_1	function
(	O
name	pointer
)	O
)	O
;	O
}	O
scm_dynwind_end	function
(	O
)	O
;	O
return	O
mu_port_make_from_stream	function
(	O
filter	pointer
,	O
flags	int
==	O
MU_STREAM_READ	int
?	O
SCM_RDNG	int
:	O
SCM_WRTNG	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_encoder_port	O
,	O
"mu-encoder-port"	pointer
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	O
SCM	function
port	O
,	O
SCM	function
name	pointer
,	O
SCM	function
args	pointer
)	O
,	O
"Create encoding port using Mailutils filter @var{name} with optional arguments\n"	pointer
"@var{args}. The @var{port} argument must be a port opened either for\n"	pointer
"writing or for reading, but not both. The returned port will have the same\n"	pointer
"mode as @var{port}."	pointer
"\n\n"	pointer
"If @var{port} is open for reading, data will be read from it, passed through the\n"	pointer
"filter and returned. If it is open for writing, data written to the returned\n"	pointer
"port will be passed through filter and its output will be written to @var{port}.\n"	pointer
)	O
{	O
return	O
make_filter_port	function
(	O
port	pointer
,	O
name	pointer
,	O
args	pointer
,	O
MU_FILTER_ENCODE	int
,	O
FUNC_NAME	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_decoder_port	pointer
,	O
"mu-decoder-port"	pointer
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	O
SCM	function
port	O
,	O
SCM	function
name	pointer
,	O
SCM	function
args	pointer
)	O
,	O
"Create a decoding port using Mailutils filter @var{name} with optional arguments\n"	pointer
"@var{args}. The @var{port} argument must be a port opened either for\n"	pointer
"writing or for reading, but not both. The returned port will have the same\n"	pointer
"mode as @var{port}."	pointer
"\n\n"	pointer
"If @var{port} is open for reading, data will be read from it, passed through the\n"	pointer
"filter and returned. If it is open for writing, data written to the returned\n"	pointer
"port will be passed through filter and its output will be written to @var{port}.\n"	pointer
)	O
{	O
return	O
make_filter_port	function
(	O
port	pointer
,	O
name	pointer
,	O
args	pointer
,	O
MU_FILTER_DECODE	O
,	O
FUNC_NAME	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_header_decode	pointer
,	O
"mu-header-decode"	pointer
,	O
1	int
,	O
1	int
,	O
0	int
,	O
(	O
SCM	function
hdr	pointer
,	O
SCM	function
charset	pointer
)	O
,	O
"Decode the header value @var{hdr}, encoded as per RFC 2047.\n"	pointer
"Optional @var{charset} defaults to @samp{utf-8}.\n"	pointer
)	O
{	O
char	O
*	O
c_hdr	pointer
,	O
*	O
c_charset	pointer
,	O
*	O
c_res	pointer
;	O
int	O
rc	int
;	O
SCM	function
res	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
hdr	pointer
)	O
,	O
hdr	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
if	O
(	O
SCM_UNBNDP	function
(	O
charset	pointer
)	O
)	O
c_charset	pointer
=	O
"utf-8"	pointer
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
charset	pointer
)	O
,	O
charset	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
c_charset	pointer
=	O
scm_to_locale_string	function
(	O
charset	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_charset	pointer
)	O
;	O
}	O
c_hdr	pointer
=	O
scm_to_locale_string	function
(	O
hdr	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_hdr	pointer
)	O
;	O
rc	int
=	O
mu_rfc2047_decode	function
(	O
c_charset	pointer
,	O
c_hdr	pointer
,	O
&	O
c_res	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't convert header value"	pointer
,	O
SCM_BOOL_F	O
)	O
;	O
scm_dynwind_end	function
(	O
)	O
;	O
res	pointer
=	O
scm_from_locale_string	function
(	O
c_res	pointer
)	O
;	O
free	function
(	O
c_res	pointer
)	O
;	O
return	O
res	pointer
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_header_encode	O
,	O
"mu-header-encode"	pointer
,	O
1	int
,	O
2	int
,	O
0	int
,	O
(	O
SCM	function
hdr	pointer
,	O
SCM	function
encoding	pointer
,	O
SCM	function
charset	pointer
)	O
,	O
"Encode the string @var{hdr} as per RFC 2047.\n"	pointer
"Both @var{encoding} and @var{charset} are optional.\n"	pointer
"Allowed values for @var{encoding} are @samp{base64} and @samp{quoted-printable}.\n"	pointer
"Default is selected depending on number of printable characters in @var{hdr}.\n"	pointer
"Optional @var{charset} defaults to @samp{utf-8}.\n"	pointer
)	O
{	O
char	O
*	O
c_hdr	pointer
,	O
*	O
c_charset	pointer
,	O
*	O
c_encoding	pointer
,	O
*	O
c_res	pointer
;	O
int	O
rc	int
;	O
SCM	function
res	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
hdr	pointer
)	O
,	O
hdr	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
if	O
(	O
SCM_UNBNDP	function
(	O
encoding	pointer
)	O
)	O
c_encoding	pointer
=	O
NULL	O
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
encoding	pointer
)	O
,	O
encoding	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
c_encoding	pointer
=	O
scm_to_locale_string	function
(	O
encoding	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_encoding	pointer
)	O
;	O
}	O
if	O
(	O
SCM_UNBNDP	function
(	O
charset	pointer
)	O
)	O
c_charset	pointer
=	O
"utf-8"	pointer
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
charset	pointer
)	O
,	O
charset	pointer
,	O
SCM_ARG3	pointer
,	O
FUNC_NAME	O
)	O
;	O
c_charset	pointer
=	O
scm_to_locale_string	function
(	O
charset	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_charset	pointer
)	O
;	O
}	O
c_hdr	pointer
=	O
scm_to_locale_string	function
(	O
hdr	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_hdr	pointer
)	O
;	O
if	O
(	O
!	O
c_encoding	pointer
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
c_hdr	pointer
)	O
;	O
size_t	long
i	long
,	O
enc	pointer
;	O
enc	pointer
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	int
<	O
len	long
;	O
i	int
++	O
)	O
if	O
(	O
!	O
mu_isprint	O
(	O
c_hdr	pointer
[	O
i	int
]	O
)	O
)	O
enc	pointer
++	O
;	O
c_encoding	pointer
=	O
(	O
enc	pointer
>	O
len	long
/	O
2	int
)	O
?	O
"base64"	int
:	O
"quoted-printable"	pointer
;	O
}	O
rc	int
=	O
mu_rfc2047_encode	function
(	O
c_charset	pointer
,	O
c_encoding	pointer
,	O
c_hdr	pointer
,	O
&	O
c_res	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't encode header value"	pointer
,	O
SCM_BOOL_F	O
)	O
;	O
scm_dynwind_end	function
(	O
)	O
;	O
res	pointer
=	O
scm_from_locale_string	function
(	O
c_res	pointer
)	O
;	O
free	function
(	O
c_res	pointer
)	O
;	O
return	O
res	pointer
;	O
}	O
void	O
mu_scm_filter_init	function
(	O
void	O
)	O
{	O
}	O
typedef	O
int	O
(	O
*	O
convfun	pointer
)	O
(	O
char	O
const	O
*	O
str	pointer
,	O
size_t	long
len	int
,	O
size_t	long
*	O
ncons	pointer
,	O
mu_opool_t	pointer
pool	pointer
)	O
;	O
static	O
int	O
hexconv	function
(	O
char	O
const	O
*	O
str	pointer
,	O
size_t	long
len	long
,	O
size_t	long
*	O
ncons	pointer
,	O
mu_opool_t	pointer
pool	pointer
)	O
;	O
static	O
int	O
uniconv	function
(	O
char	O
const	O
*	O
str	pointer
,	O
size_t	long
len	long
,	O
size_t	long
*	O
ncons	pointer
,	O
mu_opool_t	pointer
pool	pointer
)	O
;	O
struct	O
convertor	struct
{	O
char	O
const	O
*	O
pfx	pointer
;	O
size_t	long
len	long
;	O
convfun	pointer
fun	pointer
;	O
}	O
;	O
static	O
struct	O
convertor	struct
conv	array
[	O
]	O
=	O
{	O
{	O
"hex"	pointer
,	O
3	int
,	O
hexconv	int
}	O
,	O
{	O
"unicode"	pointer
,	O
7	int
,	O
uniconv	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
convfun	O
findconv	function
(	O
char	O
const	O
*	O
*	O
pstr	pointer
,	O
size_t	long
*	O
plen	pointer
)	O
{	O
struct	O
convertor	struct
*	O
cp	pointer
;	O
char	O
const	O
*	O
str	pointer
=	O
*	O
pstr	pointer
;	O
size_t	long
len	long
=	O
*	O
plen	pointer
;	O
for	O
(	O
cp	pointer
=	O
conv	pointer
;	O
cp	pointer
->	O
pfx	pointer
;	O
cp	pointer
++	O
)	O
{	O
if	O
(	O
len	int
>	O
cp	pointer
->	O
len	int
&&	O
strncasecmp	function
(	O
str	pointer
,	O
cp	pointer
->	O
pfx	pointer
,	O
cp	pointer
->	O
len	long
)	O
==	O
0	int
&&	O
str	pointer
[	O
cp	pointer
->	O
len	long
]	O
==	O
':'	O
)	O
{	O
*	O
pstr	pointer
+=	O
cp	pointer
->	O
len	long
+	O
1	int
;	O
*	O
plen	pointer
-=	O
cp	pointer
->	O
len	int
+	O
1	int
;	O
return	O
cp	pointer
->	O
fun	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
int	O
mu_i_sv_expand_encoded_char	function
(	O
char	O
const	O
*	O
input	pointer
,	O
size_t	long
len	long
,	O
char	O
*	O
*	O
exp	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
rc	int
;	O
convfun	pointer
fn	pointer
;	O
mu_opool_t	pointer
pool	pointer
;	O
fn	pointer
=	O
findconv	function
(	O
&	O
input	pointer
,	O
&	O
len	long
)	O
;	O
if	O
(	O
!	O
fn	pointer
)	O
return	O
MU_ERR_NOENT	O
;	O
rc	int
=	O
mu_opool_create	function
(	O
&	O
pool	pointer
,	O
MU_OPOOL_DEFAULT	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
while	O
(	O
rc	int
==	O
0	int
&&	O
len	int
>	O
0	int
)	O
{	O
if	O
(	O
mu_isblank	function
(	O
*	O
input	pointer
)	O
)	O
{	O
++	O
input	pointer
;	O
--	O
len	int
;	O
}	O
else	O
if	O
(	O
mu_isxdigit	O
(	O
*	O
input	pointer
)	O
)	O
{	O
size_t	long
n	long
;	O
rc	int
=	O
fn	pointer
(	O
input	pointer
,	O
len	long
,	O
&	O
n	long
,	O
pool	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
input	pointer
+=	O
n	int
;	O
len	int
-=	O
n	int
;	O
}	O
else	O
{	O
rc	int
=	O
EILSEQ	pointer
;	O
break	O
;	O
}	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
size_t	long
len	long
;	O
char	O
*	O
p	pointer
=	O
mu_opool_finish	function
(	O
pool	pointer
,	O
&	O
len	int
)	O
;	O
char	O
*	O
res	pointer
;	O
res	pointer
=	O
malloc	function
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
rc	int
=	O
errno	O
;	O
else	O
{	O
memcpy	function
(	O
res	pointer
,	O
p	pointer
,	O
len	long
)	O
;	O
res	pointer
[	O
len	long
]	O
=	O
0	int
;	O
*	O
exp	pointer
=	O
res	pointer
;	O
}	O
}	O
mu_opool_destroy	function
(	O
&	O
pool	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
hexconv	function
(	O
char	O
const	O
*	O
str	pointer
,	O
size_t	long
len	long
,	O
size_t	long
*	O
ncons	pointer
,	O
mu_opool_t	pointer
pool	pointer
)	O
{	O
char	O
c	int
;	O
if	O
(	O
len	int
<	O
2	int
)	O
return	O
EILSEQ	O
;	O
else	O
{	O
c	long
=	O
mu_hex2ul	function
(	O
*	O
str	pointer
)	O
;	O
++	O
str	pointer
;	O
if	O
(	O
!	O
mu_isxdigit	O
(	O
*	O
str	pointer
)	O
)	O
return	O
EILSEQ	O
;	O
c	int
=	O
(	O
c	int
<<	O
4	int
)	O
+	O
mu_hex2ul	function
(	O
*	O
str	pointer
)	O
;	O
mu_opool_append_char	function
(	O
pool	array
,	O
c	int
)	O
;	O
}	O
*	O
ncons	pointer
=	O
2	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
utf8_wctomb	function
(	O
unsigned	O
int	O
wc	int
,	O
mu_opool_t	pointer
pool	pointer
)	O
{	O
int	O
count	int
;	O
char	O
r	pointer
[	O
6	int
]	O
;	O
if	O
(	O
wc	int
<	O
0x80	int
)	O
count	int
=	O
1	int
;	O
else	O
if	O
(	O
wc	int
<	O
0x800	int
)	O
count	int
=	O
2	int
;	O
else	O
if	O
(	O
wc	int
<	O
0x10000	int
)	O
count	int
=	O
3	int
;	O
else	O
if	O
(	O
wc	int
<	O
0x200000	int
)	O
count	int
=	O
4	int
;	O
else	O
if	O
(	O
wc	int
<	O
0x4000000	int
)	O
count	int
=	O
5	int
;	O
else	O
if	O
(	O
wc	int
<=	O
0x7fffffff	int
)	O
count	int
=	O
6	int
;	O
else	O
return	O
EILSEQ	function
;	O
switch	O
(	O
count	int
)	O
{	O
case	O
6	int
:	O
r	pointer
[	O
5	int
]	O
=	O
0x80	int
|	O
(	O
wc	int
&	O
0x3f	int
)	O
;	O
wc	int
=	O
wc	int
>>	O
6	int
;	O
wc	int
|=	O
0x4000000	int
;	O
case	O
5	int
:	O
r	pointer
[	O
4	int
]	O
=	O
0x80	int
|	O
(	O
wc	int
&	O
0x3f	int
)	O
;	O
wc	long
=	O
wc	int
>>	O
6	int
;	O
wc	int
|=	O
0x200000	int
;	O
case	O
4	int
:	O
r	pointer
[	O
3	int
]	O
=	O
0x80	int
|	O
(	O
wc	int
&	O
0x3f	int
)	O
;	O
wc	long
=	O
wc	int
>>	O
6	int
;	O
wc	int
|=	O
0x10000	int
;	O
case	O
3	int
:	O
r	pointer
[	O
2	int
]	O
=	O
0x80	int
|	O
(	O
wc	int
&	O
0x3f	int
)	O
;	O
wc	long
=	O
wc	int
>>	O
6	int
;	O
wc	int
|=	O
0x800	int
;	O
case	O
2	int
:	O
r	pointer
[	O
1	int
]	O
=	O
0x80	int
|	O
(	O
wc	int
&	O
0x3f	int
)	O
;	O
wc	long
=	O
wc	int
>>	O
6	int
;	O
wc	int
|=	O
0xc0	int
;	O
case	O
1	int
:	O
r	pointer
[	O
0	int
]	O
=	O
wc	int
;	O
}	O
mu_opool_append	function
(	O
pool	pointer
,	O
r	pointer
,	O
count	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
uniconv	function
(	O
char	O
const	O
*	O
str	pointer
,	O
size_t	long
len	long
,	O
size_t	long
*	O
ncons	pointer
,	O
mu_opool_t	pointer
pool	pointer
)	O
{	O
unsigned	O
int	O
wc	int
=	O
0	int
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
len	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
i	int
>=	O
12	int
)	O
return	O
EILSEQ	int
;	O
if	O
(	O
!	O
mu_isxdigit	O
(	O
str	pointer
[	O
i	long
]	O
)	O
)	O
break	O
;	O
wc	long
=	O
(	O
wc	long
<<	O
4	int
)	O
+	O
mu_hex2ul	function
(	O
str	pointer
[	O
i	long
]	O
)	O
;	O
}	O
*	O
ncons	pointer
=	O
i	long
;	O
return	O
utf8_wctomb	function
(	O
wc	int
,	O
pool	pointer
)	O
;	O
}	O
int	O
retrieve_env	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
,	O
size_t	long
idx	long
,	O
char	O
*	O
*	O
pval	pointer
)	O
{	O
mu_sieve_machine_t	pointer
mach	pointer
;	O
if	O
(	O
idx	long
)	O
return	O
MU_ERR_NOENT	O
;	O
mach	pointer
=	O
data	pointer
;	O
return	O
mu_sieve_get_environ	function
(	O
mach	pointer
,	O
item	pointer
,	O
pval	pointer
)	O
;	O
}	O
static	O
int	O
sieve_test_environment	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
mu_sieve_value_t	struct
*	O
name	pointer
,	O
*	O
key_list	pointer
;	O
name	pointer
=	O
mu_sieve_get_arg_untyped	function
(	O
mach	pointer
,	O
0	int
)	O
;	O
key_list	long
=	O
mu_sieve_get_arg_untyped	function
(	O
mach	pointer
,	O
1	int
)	O
;	O
return	O
mu_sieve_vlist_compare	function
(	O
mach	pointer
,	O
name	pointer
,	O
key_list	pointer
,	O
retrieve_env	pointer
,	O
NULL	O
,	O
mach	pointer
)	O
;	O
}	O
static	O
mu_sieve_data_type	enum
environ_args	array
[	O
]	O
=	O
{	O
SVT_STRING	int
,	O
SVT_STRING_LIST	int
,	O
SVT_VOID	int
}	O
;	O
static	O
mu_sieve_tag_group_t	struct
environ_tag_groups	array
[	O
]	O
=	O
{	O
{	O
mu_sieve_match_part_tags	pointer
,	O
mu_sieve_match_part_checker	function
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
mu_sieve_require_environment	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
mu_sieve_register_test	function
(	O
mach	pointer
,	O
"environment"	pointer
,	O
sieve_test_environment	pointer
,	O
environ_args	pointer
,	O
environ_tag_groups	pointer
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
std_name_get	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
return	O
strdup	function
(	O
PACKAGE_NAME	pointer
)	O
;	O
}	O
static	O
char	O
*	O
std_version_get	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
return	O
strdup	function
(	O
PACKAGE_VERSION	pointer
)	O
;	O
}	O
static	O
char	O
*	O
std_host_get	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
char	O
*	O
host	pointer
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_get_host_name	function
(	O
&	O
host	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
return	O
host	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
std_domain_get	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
char	O
*	O
host	pointer
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_get_host_name	function
(	O
&	O
host	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
host	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
p	pointer
=	O
strdup	function
(	O
p	pointer
+	O
1	int
)	O
;	O
free	function
(	O
host	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
return	O
host	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
struct	O
stdenviron	struct
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
(	O
*	O
get	pointer
)	O
(	O
mu_sieve_machine_t	pointer
)	O
;	O
int	O
(	O
*	O
set	pointer
)	O
(	O
mu_sieve_machine_t	pointer
,	O
char	O
const	O
*	O
,	O
char	O
const	O
*	O
value	pointer
)	O
;	O
}	O
;	O
static	O
struct	O
stdenviron	struct
stdenv	array
[	O
]	O
=	O
{	O
{	O
"domain"	pointer
,	O
std_domain_get	pointer
,	O
NULL	O
}	O
,	O
{	O
"host"	pointer
,	O
std_host_get	pointer
,	O
NULL	O
}	O
,	O
{	O
"name"	pointer
,	O
std_name_get	pointer
,	O
NULL	O
}	O
,	O
{	O
"version"	pointer
,	O
std_version_get	pointer
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
stdenviron	struct
const	O
*	O
stdenv_find	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
struct	O
stdenviron	struct
const	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
stdenv	pointer
;	O
p	pointer
->	O
name	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
p	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
p	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
stdenv_get	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
char	O
const	O
*	O
name	pointer
)	O
{	O
struct	O
stdenviron	struct
const	O
*	O
p	pointer
=	O
stdenv_find	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
NULL	O
;	O
return	O
p	pointer
->	O
get	pointer
(	O
mach	pointer
)	O
;	O
}	O
static	O
int	O
stdenv_set	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
char	O
const	O
*	O
name	pointer
,	O
char	O
const	O
*	O
value	pointer
)	O
{	O
struct	O
stdenviron	struct
const	O
*	O
p	pointer
=	O
stdenv_find	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
MU_ERR_NOENT	O
;	O
if	O
(	O
!	O
p	pointer
->	O
set	pointer
)	O
return	O
EACCES	int
;	O
return	O
p	pointer
->	O
set	pointer
(	O
mach	pointer
,	O
name	pointer
,	O
value	pointer
)	O
;	O
}	O
int	O
mu_sieve_get_environ	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
char	O
const	O
*	O
name	pointer
,	O
char	O
*	O
*	O
retval	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
stdenv_get	function
(	O
mach	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
*	O
retval	pointer
=	O
p	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
mach	pointer
->	O
exenv	pointer
)	O
return	O
MU_ERR_NOENT	O
;	O
p	pointer
=	O
mu_assoc_get	function
(	O
mach	pointer
->	O
exenv	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
*	O
retval	pointer
=	O
strdup	function
(	O
p	pointer
)	O
;	O
if	O
(	O
!	O
*	O
retval	pointer
)	O
return	O
errno	O
;	O
}	O
else	O
return	O
MU_ERR_NOENT	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_sieve_set_environ	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
char	O
const	O
*	O
name	pointer
,	O
char	O
const	O
*	O
value	pointer
)	O
{	O
int	O
rc	int
;	O
rc	int
=	O
stdenv_set	function
(	O
mach	pointer
,	O
name	pointer
,	O
value	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
{	O
char	O
*	O
*	O
pptr	pointer
;	O
if	O
(	O
!	O
mach	pointer
->	O
exenv	pointer
)	O
{	O
int	O
rc	int
=	O
mu_assoc_create	function
(	O
&	O
mach	pointer
->	O
exenv	pointer
,	O
0	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_assoc_install_ref	function
(	O
mach	pointer
->	O
exenv	pointer
,	O
name	pointer
,	O
&	O
pptr	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
||	O
rc	int
==	O
MU_ERR_EXISTS	O
)	O
{	O
char	O
*	O
copy	pointer
=	O
strdup	function
(	O
value	pointer
)	O
;	O
if	O
(	O
!	O
copy	pointer
)	O
rc	int
=	O
errno	O
;	O
else	O
{	O
*	O
pptr	pointer
=	O
copy	pointer
;	O
rc	int
=	O
0	int
;	O
}	O
}	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
timestamp_test	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
char	O
const	O
*	O
hname	pointer
;	O
char	O
const	O
*	O
date	pointer
;	O
mu_header_t	pointer
hdr	pointer
;	O
char	O
*	O
val	pointer
;	O
time_t	long
now	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
time_t	long
tlimit	long
,	O
tval	struct
;	O
int	O
rc	int
;	O
mu_sieve_get_arg	function
(	O
mach	pointer
,	O
0	int
,	O
SVT_STRING	int
,	O
&	O
hname	O
)	O
;	O
mu_sieve_get_arg	function
(	O
mach	pointer
,	O
1	int
,	O
SVT_STRING	int
,	O
&	O
date	pointer
)	O
;	O
if	O
(	O
mu_parse_date	function
(	O
date	pointer
,	O
&	O
tlimit	struct
,	O
&	O
now	long
)	O
)	O
{	O
mu_sieve_error	function
(	O
mach	pointer
,	O
_	O
(	O
"cannot parse date specification (%s)"	pointer
)	O
,	O
date	pointer
)	O
;	O
mu_sieve_abort	function
(	O
mach	pointer
)	O
;	O
}	O
rc	int
=	O
mu_message_get_header	function
(	O
mu_sieve_get_message	function
(	O
mach	pointer
)	O
,	O
&	O
hdr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_sieve_error	function
(	O
mach	pointer
,	O
"mu_message_get_header: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_sieve_abort	function
(	O
mach	pointer
)	O
;	O
}	O
if	O
(	O
mu_header_aget_value	O
(	O
hdr	pointer
,	O
hname	pointer
,	O
&	O
val	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
mu_parse_date	function
(	O
val	pointer
,	O
&	O
tval	struct
,	O
&	O
now	long
)	O
)	O
{	O
mu_sieve_error	function
(	O
mach	pointer
,	O
"cannot parse header date specification (%s)"	pointer
,	O
val	pointer
)	O
;	O
free	function
(	O
val	pointer
)	O
;	O
mu_sieve_abort	function
(	O
mach	pointer
)	O
;	O
}	O
free	function
(	O
val	pointer
)	O
;	O
rc	int
=	O
tval	int
>	O
tlimit	int
;	O
if	O
(	O
mu_sieve_get_tag	function
(	O
mach	pointer
,	O
"before"	pointer
,	O
SVT_VOID	int
,	O
NULL	O
)	O
)	O
rc	int
=	O
!	O
rc	int
;	O
return	O
rc	int
;	O
}	O
static	O
mu_sieve_data_type	enum
timestamp_req_args	array
[	O
]	O
=	O
{	O
SVT_STRING	int
,	O
SVT_STRING	int
,	O
SVT_VOID	int
}	O
;	O
static	O
mu_sieve_tag_def_t	struct
timestamp_tags	array
[	O
]	O
=	O
{	O
{	O
"after"	pointer
,	O
SVT_VOID	int
}	O
,	O
{	O
"before"	pointer
,	O
SVT_VOID	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
mu_sieve_tag_group_t	struct
timestamp_tag_groups	array
[	O
]	O
=	O
{	O
{	O
timestamp_tags	pointer
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
SIEVE_EXPORT	O
(	O
timestamp	O
,	O
init	O
)	O
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
mu_sieve_register_test	function
(	O
mach	pointer
,	O
"timestamp"	pointer
,	O
timestamp_test	pointer
,	O
timestamp_req_args	pointer
,	O
timestamp_tag_groups	pointer
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
DCL	function
(	O
eq	int
,	O
==	O
)	O
DCL	function
(	O
ne	pointer
,	O
!=	O
)	O
DCL	function
(	O
gt	pointer
,	O
>	O
)	O
DCL	function
(	O
ge	pointer
,	O
>=	O
)	O
DCL	function
(	O
lt	pointer
,	O
<	O
)	O
DCL	function
(	O
le	pointer
,	O
<=	O
)	O
static	O
struct	O
reltest_tab	O
{	O
char	O
*	O
name	pointer
;	O
mu_sieve_relcmp_t	enum
test	enum
;	O
mu_sieve_relcmpn_t	pointer
stest	pointer
;	O
}	O
testtab	array
[	O
]	O
=	O
{	O
DEF	function
(	O
eq	int
)	O
,	O
DEF	function
(	O
ne	pointer
)	O
,	O
DEF	function
(	O
gt	int
)	O
,	O
DEF	function
(	O
ge	pointer
)	O
,	O
DEF	function
(	O
lt	pointer
)	O
,	O
DEF	function
(	O
le	pointer
)	O
}	O
;	O
static	O
struct	O
reltest_tab	struct
*	O
_relcmp_lookup	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
testtab	array
)	O
/	O
sizeof	O
(	O
testtab	array
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
testtab	array
[	O
i	int
]	O
.	O
name	pointer
,	O
str	pointer
)	O
==	O
0	int
)	O
return	O
&	O
testtab	array
[	O
i	int
]	O
;	O
return	O
0	int
;	O
}	O
int	O
mu_sieve_str_to_relcmp	function
(	O
const	O
char	O
*	O
str	pointer
,	O
mu_sieve_relcmp_t	struct
*	O
test	enum
,	O
mu_sieve_relcmpn_t	struct
*	O
stest	pointer
)	O
{	O
struct	O
reltest_tab	struct
*	O
t	pointer
=	O
_relcmp_lookup	function
(	O
str	pointer
)	O
;	O
if	O
(	O
t	pointer
)	O
{	O
if	O
(	O
test	enum
)	O
*	O
test	enum
=	O
t	pointer
->	O
test	char
;	O
if	O
(	O
stest	pointer
)	O
*	O
stest	pointer
=	O
t	pointer
->	O
stest	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
mu_sieve_relcmp_t	O
mu_sieve_get_relcmp	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
)	O
{	O
char	O
*	O
str	pointer
;	O
mu_sieve_relcmp_t	struct
test	pointer
=	O
NULL	O
;	O
if	O
(	O
mu_sieve_get_tag	function
(	O
mach	pointer
,	O
"value"	pointer
,	O
SVT_STRING	int
,	O
&	O
str	pointer
)	O
==	O
0	int
)	O
return	O
op_ne	pointer
;	O
mu_sieve_str_to_relcmp	function
(	O
str	pointer
,	O
&	O
test	char
,	O
NULL	O
)	O
;	O
return	O
test	int
;	O
}	O
int	O
mu_sieve_require_relational	function
(	O
mu_sieve_machine_t	pointer
mach	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
return	O
0	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_mailbox_t	pointer
mbx	pointer
;	O
mu_message_t	pointer
msg	pointer
=	O
NULL	O
;	O
char	O
*	O
mailbox_name	pointer
=	O
getenv	function
(	O
"MAIL"	pointer
)	O
;	O
mu_message_qid_t	pointer
qid	pointer
;	O
mu_stream_t	pointer
str	pointer
;	O
mu_set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
mu_stdstream_setup	function
(	O
MU_STDSTREAM_RESET_NONE	int
)	O
;	O
mu_registrar_record	function
(	O
mu_dotmail_record	pointer
)	O
;	O
argc	long
--	O
;	O
argv	pointer
++	O
;	O
if	O
(	O
argc	int
&&	O
strcmp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
"-d"	pointer
)	O
==	O
0	int
)	O
{	O
mu_debug_enable_category	function
(	O
"mailbox"	pointer
,	O
7	int
,	O
MU_DEBUG_LEVEL_UPTO	function
(	O
MU_DEBUG_PROT	pointer
)	O
)	O
;	O
argc	long
--	O
;	O
argv	pointer
++	O
;	O
}	O
MU_ASSERT	O
(	O
mu_mailbox_create_default	function
(	O
&	O
mbx	pointer
,	O
mailbox_name	pointer
)	O
)	O
;	O
MU_ASSERT	O
(	O
mu_mailbox_open	function
(	O
mbx	pointer
,	O
MU_STREAM_READ	int
|	O
MU_STREAM_QACCESS	int
)	O
)	O
;	O
if	O
(	O
argc	int
!=	O
1	int
)	O
{	O
mu_error	function
(	O
"only one argument is allowed"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
qid	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
MU_ASSERT	O
(	O
mu_mailbox_quick_get_message	function
(	O
mbx	pointer
,	O
qid	pointer
,	O
&	O
msg	pointer
)	O
)	O
;	O
MU_ASSERT	O
(	O
mu_message_get_streamref	function
(	O
msg	pointer
,	O
&	O
str	pointer
)	O
)	O
;	O
MU_ASSERT	O
(	O
mu_stream_copy	function
(	O
mu_strout	pointer
,	O
str	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
str	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
get_crlf_stream_size	function
(	O
mu_stream_t	pointer
str	pointer
,	O
mu_off_t	long
size	long
,	O
mu_off_t	long
*	O
prealsize	pointer
)	O
{	O
mu_stream_t	pointer
null	pointer
,	O
flt	pointer
;	O
mu_stream_stat_buffer	array
stat	array
;	O
int	O
rc	int
;	O
mu_off_t	long
needle	pointer
;	O
rc	int
=	O
mu_nullstream_create	function
(	O
&	O
null	int
,	O
MU_STREAM_WRITE	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_stream_set_stat	function
(	O
null	O
,	O
MU_STREAM_STAT_MASK	O
(	O
MU_STREAM_STAT_OUT	int
)	O
,	O
stat	array
)	O
;	O
rc	int
=	O
mu_filter_create	function
(	O
&	O
flt	pointer
,	O
null	O
,	O
"CRLF"	pointer
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_WRITE	int
)	O
;	O
mu_stream_unref	function
(	O
null	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_stream_seek	function
(	O
str	pointer
,	O
0	int
,	O
MU_SEEK_CUR	int
,	O
&	O
needle	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
rc	int
=	O
mu_stream_copy	function
(	O
flt	pointer
,	O
str	pointer
,	O
size	long
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
rc	int
=	O
mu_stream_seek	function
(	O
str	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
mu_stream_unref	function
(	O
flt	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
*	O
prealsize	pointer
=	O
stat	array
[	O
MU_STREAM_STAT_OUT	int
]	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_imap_append_stream_size	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
const	O
char	O
*	O
mailbox	pointer
,	O
int	O
flags	int
,	O
struct	O
tm	struct
*	O
tm	struct
,	O
struct	O
mu_timezone	struct
*	O
tz	pointer
,	O
mu_stream_t	pointer
stream	pointer
,	O
mu_off_t	long
size	long
)	O
{	O
int	O
status	int
;	O
mu_off_t	long
realsize	long
;	O
if	O
(	O
imap	pointer
==	O
NULL	O
||	O
!	O
mailbox	pointer
||	O
!	O
stream	pointer
||	O
size	long
==	O
0	int
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
imap	pointer
->	O
io	pointer
)	O
return	O
MU_ERR_NO_TRANSPORT	O
;	O
if	O
(	O
imap	pointer
->	O
session_state	enum
<	O
MU_IMAP_SESSION_AUTH	int
)	O
return	O
MU_ERR_SEQ	O
;	O
switch	O
(	O
imap	pointer
->	O
client_state	enum
)	O
{	O
case	O
MU_IMAP_CLIENT_READY	int
:	O
status	int
=	O
get_crlf_stream_size	function
(	O
stream	pointer
,	O
size	long
,	O
&	O
realsize	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
_mu_imap_tag_next	function
(	O
imap	pointer
)	O
;	O
MU_IMAP_CHECK_EAGAIN	O
(	O
imap	pointer
,	O
status	int
)	O
;	O
status	int
=	O
mu_imapio_printf	function
(	O
imap	pointer
->	O
io	pointer
,	O
"%s APPEND "	pointer
,	O
imap	pointer
->	O
tag_str	pointer
)	O
;	O
MU_IMAP_CHECK_ERROR	O
(	O
imap	pointer
,	O
status	int
)	O
;	O
status	int
=	O
mu_imapio_send_qstring	function
(	O
imap	pointer
->	O
io	pointer
,	O
mailbox	pointer
)	O
;	O
MU_IMAP_CHECK_ERROR	O
(	O
imap	pointer
,	O
status	int
)	O
;	O
if	O
(	O
flags	int
)	O
{	O
status	int
=	O
mu_imapio_send	function
(	O
imap	pointer
->	O
io	pointer
,	O
" "	pointer
,	O
1	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
status	int
=	O
mu_imapio_send_flags	function
(	O
imap	pointer
->	O
io	pointer
,	O
flags	int
)	O
;	O
MU_IMAP_CHECK_ERROR	O
(	O
imap	pointer
,	O
status	int
)	O
;	O
}	O
if	O
(	O
tm	struct
)	O
{	O
status	int
=	O
mu_imapio_send	function
(	O
imap	pointer
->	O
io	pointer
,	O
" "	pointer
,	O
1	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
status	int
=	O
mu_imapio_send_time	function
(	O
imap	pointer
->	O
io	pointer
,	O
tm	struct
,	O
tz	pointer
)	O
;	O
MU_IMAP_CHECK_ERROR	O
(	O
imap	pointer
,	O
status	int
)	O
;	O
}	O
status	int
=	O
mu_imapio_send	function
(	O
imap	pointer
->	O
io	pointer
,	O
" "	pointer
,	O
1	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
mu_stream_t	pointer
flt	pointer
;	O
status	int
=	O
mu_filter_create	function
(	O
&	O
flt	pointer
,	O
stream	pointer
,	O
"CRLF"	pointer
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
status	int
==	O
0	int
)	O
{	O
status	int
=	O
mu_imapio_send_literal_stream	function
(	O
imap	pointer
->	O
io	pointer
,	O
flt	pointer
,	O
realsize	pointer
)	O
;	O
mu_stream_unref	function
(	O
flt	pointer
)	O
;	O
}	O
}	O
MU_IMAP_CHECK_ERROR	O
(	O
imap	pointer
,	O
status	int
)	O
;	O
status	int
=	O
mu_imapio_send	function
(	O
imap	pointer
->	O
io	pointer
,	O
"\r\n"	pointer
,	O
2	int
)	O
;	O
MU_IMAP_CHECK_ERROR	O
(	O
imap	pointer
,	O
status	int
)	O
;	O
MU_IMAP_FCLR	O
(	O
imap	pointer
,	O
MU_IMAP_RESP	int
)	O
;	O
imap	pointer
->	O
client_state	enum
=	O
MU_IMAP_CLIENT_APPEND_RX	int
;	O
case	O
MU_IMAP_CLIENT_APPEND_RX	int
:	O
status	int
=	O
_mu_imap_response	function
(	O
imap	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
MU_IMAP_CHECK_EAGAIN	O
(	O
imap	pointer
,	O
status	int
)	O
;	O
switch	O
(	O
imap	pointer
->	O
response	enum
)	O
{	O
case	O
MU_IMAP_OK	int
:	O
status	int
=	O
0	int
;	O
break	O
;	O
case	O
MU_IMAP_NO	int
:	O
status	int
=	O
MU_ERR_FAILURE	O
;	O
break	O
;	O
case	O
MU_IMAP_BAD	int
:	O
status	int
=	O
MU_ERR_BADREPLY	O
;	O
break	O
;	O
}	O
imap	pointer
->	O
client_state	enum
=	O
MU_IMAP_CLIENT_READY	int
;	O
break	O
;	O
default	O
:	O
status	int
=	O
EINPROGRESS	int
;	O
}	O
return	O
status	int
;	O
}	O
void	O
mu_imap_callback	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
int	O
code	int
,	O
size_t	long
sdat	long
,	O
void	O
*	O
pdat	pointer
)	O
{	O
if	O
(	O
code	int
<	O
0	int
||	O
code	int
>=	O
_MU_IMAP_CB_MAX	int
||	O
!	O
imap	pointer
->	O
callback	pointer
[	O
code	int
]	O
.	O
action	int
)	O
return	O
;	O
imap	pointer
->	O
callback	pointer
[	O
code	int
]	O
.	O
action	pointer
(	O
imap	pointer
->	O
callback	pointer
[	O
code	int
]	O
.	O
data	pointer
,	O
code	int
,	O
sdat	int
,	O
pdat	pointer
)	O
;	O
}	O
void	O
mu_imap_register_callback_function	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
int	O
code	int
,	O
mu_imap_callback_t	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
if	O
(	O
code	int
<	O
0	int
||	O
code	int
>=	O
_MU_IMAP_CB_MAX	int
)	O
{	O
mu_error	function
(	O
"%s:%d: ignoring unsupported callback code %d"	pointer
,	O
__FILE__	O
,	O
__LINE__	O
,	O
code	int
)	O
;	O
return	O
;	O
}	O
imap	pointer
->	O
callback	pointer
[	O
code	int
]	O
.	O
action	pointer
=	O
callback	pointer
;	O
imap	pointer
->	O
callback	pointer
[	O
code	int
]	O
.	O
data	pointer
=	O
data	pointer
;	O
}	O
int	O
mu_imap_capability_test	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
*	O
pret	pointer
)	O
{	O
int	O
rc	int
;	O
rc	int
=	O
mu_imap_capability	function
(	O
imap	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
MU_IMAP_FCLR	O
(	O
imap	pointer
,	O
MU_IMAP_RESP	int
)	O
;	O
return	O
mu_list_locate	function
(	O
imap	pointer
->	O
capa	pointer
,	O
(	O
void	O
*	O
)	O
name	pointer
,	O
(	O
void	O
*	O
*	O
)	O
pret	pointer
)	O
;	O
}	O
int	O
mu_imap_disconnect	function
(	O
mu_imap_t	pointer
imap	pointer
)	O
{	O
if	O
(	O
imap	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
imap	pointer
->	O
client_state	enum
=	O
MU_IMAP_CLIENT_READY	int
;	O
MU_IMAP_FCLR	O
(	O
imap	pointer
,	O
MU_IMAP_RESP	int
)	O
;	O
mu_list_clear	function
(	O
imap	pointer
->	O
capa	pointer
)	O
;	O
mu_imapio_destroy	function
(	O
&	O
imap	pointer
->	O
io	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
_mu_imap_seterrstr	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
const	O
char	O
*	O
str	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
!	O
imap	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
len	int
+	O
1	int
>	O
imap	pointer
->	O
errsize	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
realloc	function
(	O
imap	pointer
->	O
errstr	pointer
,	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
ENOMEM	int
;	O
imap	pointer
->	O
errsize	long
=	O
len	int
+	O
1	int
;	O
imap	pointer
->	O
errstr	pointer
=	O
p	int
;	O
}	O
memcpy	function
(	O
imap	pointer
->	O
errstr	pointer
,	O
str	pointer
,	O
len	long
)	O
;	O
imap	pointer
->	O
errstr	pointer
[	O
len	int
]	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
int	O
_mu_imap_seterrstrz	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
const	O
char	O
*	O
str	pointer
)	O
{	O
return	O
_mu_imap_seterrstr	function
(	O
imap	pointer
,	O
str	pointer
,	O
strlen	function
(	O
str	pointer
)	O
)	O
;	O
}	O
void	O
_mu_imap_clrerrstr	function
(	O
mu_imap_t	pointer
imap	pointer
)	O
{	O
if	O
(	O
imap	pointer
&&	O
imap	pointer
->	O
errstr	pointer
)	O
imap	pointer
->	O
errstr	pointer
[	O
0	int
]	O
=	O
0	int
;	O
}	O
int	O
mu_imap_strerror	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
const	O
char	O
*	O
*	O
pstr	pointer
)	O
{	O
if	O
(	O
!	O
imap	pointer
)	O
{	O
*	O
pstr	pointer
=	O
"(imap not initialized)"	int
;	O
return	O
EINVAL	int
;	O
}	O
if	O
(	O
MU_IMAP_FISSET	O
(	O
imap	pointer
,	O
MU_IMAP_RESP	int
)	O
)	O
{	O
*	O
pstr	pointer
=	O
imap	pointer
->	O
errstr	pointer
;	O
return	O
0	int
;	O
}	O
*	O
pstr	pointer
=	O
"(no recent reply)"	int
;	O
return	O
MU_ERR_NOENT	O
;	O
}	O
enum	O
mu_imap_response	enum
mu_imap_response	function
(	O
mu_imap_t	pointer
imap	pointer
)	O
{	O
if	O
(	O
!	O
imap	pointer
)	O
return	O
MU_IMAP_BAD	int
;	O
return	O
imap	pointer
->	O
response	pointer
;	O
}	O
int	O
mu_imap_response_code	function
(	O
mu_imap_t	pointer
imap	pointer
)	O
{	O
if	O
(	O
!	O
imap	pointer
)	O
return	O
-	O
1	int
;	O
return	O
imap	pointer
->	O
response_code	pointer
;	O
}	O
int	O
mu_imap_list	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
const	O
char	O
*	O
refname	pointer
,	O
const	O
char	O
*	O
mboxname	pointer
,	O
mu_list_t	pointer
retlist	pointer
)	O
{	O
return	O
mu_imap_genlist	function
(	O
imap	pointer
,	O
0	int
,	O
refname	pointer
,	O
mboxname	pointer
,	O
retlist	pointer
)	O
;	O
}	O
int	O
mu_imap_list_new	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
const	O
char	O
*	O
refname	pointer
,	O
const	O
char	O
*	O
mboxname	pointer
,	O
mu_list_t	pointer
*	O
plist	pointer
)	O
{	O
return	O
mu_imap_genlist_new	function
(	O
imap	pointer
,	O
0	int
,	O
refname	pointer
,	O
mboxname	pointer
,	O
plist	pointer
)	O
;	O
}	O
int	O
mu_imap_lsub	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
const	O
char	O
*	O
refname	pointer
,	O
const	O
char	O
*	O
mboxname	pointer
,	O
mu_list_t	pointer
retlist	pointer
)	O
{	O
return	O
mu_imap_genlist	function
(	O
imap	pointer
,	O
1	int
,	O
refname	pointer
,	O
mboxname	pointer
,	O
retlist	pointer
)	O
;	O
}	O
int	O
mu_imap_lsub_new	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
const	O
char	O
*	O
refname	pointer
,	O
const	O
char	O
*	O
mboxname	pointer
,	O
mu_list_t	pointer
*	O
plist	pointer
)	O
{	O
return	O
mu_imap_genlist_new	function
(	O
imap	pointer
,	O
1	int
,	O
refname	pointer
,	O
mboxname	pointer
,	O
plist	pointer
)	O
;	O
}	O
static	O
int	O
_collect_flags	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
imap_list_element	struct
*	O
elt	pointer
=	O
item	pointer
;	O
int	O
*	O
args	pointer
=	O
data	pointer
;	O
if	O
(	O
elt	pointer
->	O
type	int
==	O
imap_eltype_string	int
)	O
mu_imap_flag_to_attribute	function
(	O
elt	pointer
->	O
v	union
.	O
string	pointer
,	O
args	array
)	O
;	O
return	O
0	int
;	O
}	O
int	O
_mu_imap_collect_flags	function
(	O
struct	O
imap_list_element	struct
*	O
arg	pointer
,	O
int	O
*	O
res	pointer
)	O
{	O
if	O
(	O
arg	pointer
->	O
type	int
!=	O
imap_eltype_list	int
)	O
return	O
EINVAL	int
;	O
*	O
res	pointer
=	O
0	int
;	O
mu_list_foreach	function
(	O
arg	pointer
->	O
v	pointer
.	O
list	pointer
,	O
_collect_flags	O
,	O
res	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
_select_response_action	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
mu_list_t	pointer
response	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
imap_list_element	struct
*	O
elt	pointer
;	O
elt	pointer
=	O
_mu_imap_list_at	function
(	O
response	enum
,	O
0	int
)	O
;	O
if	O
(	O
elt	pointer
&&	O
_mu_imap_list_element_is_string	function
(	O
elt	pointer
,	O
"FLAGS"	pointer
)	O
)	O
{	O
struct	O
imap_list_element	struct
*	O
arg	pointer
=	O
_mu_imap_list_at	function
(	O
response	enum
,	O
1	int
)	O
;	O
if	O
(	O
arg	pointer
&&	O
_mu_imap_collect_flags	function
(	O
arg	pointer
,	O
&	O
imap	pointer
->	O
mbox_stat	struct
.	O
defined_flags	int
)	O
==	O
0	int
)	O
imap	pointer
->	O
mbox_stat	struct
.	O
flags	int
|=	O
MU_IMAP_STAT_DEFINED_FLAGS	int
;	O
}	O
}	O
int	O
mu_imap_select	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
const	O
char	O
*	O
mbox	pointer
,	O
int	O
writable	int
,	O
struct	O
mu_imap_stat	struct
*	O
ps	pointer
)	O
{	O
int	O
status	int
;	O
if	O
(	O
imap	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
imap	pointer
->	O
io	pointer
)	O
return	O
MU_ERR_NO_TRANSPORT	O
;	O
if	O
(	O
imap	pointer
->	O
session_state	enum
!=	O
MU_IMAP_SESSION_AUTH	int
&&	O
imap	pointer
->	O
session_state	enum
!=	O
MU_IMAP_SESSION_SELECTED	int
)	O
return	O
MU_ERR_SEQ	O
;	O
if	O
(	O
!	O
mbox	pointer
)	O
{	O
if	O
(	O
imap	pointer
->	O
session_state	enum
==	O
MU_IMAP_SESSION_SELECTED	int
)	O
{	O
if	O
(	O
ps	pointer
)	O
*	O
ps	pointer
=	O
imap	pointer
->	O
mbox_stat	struct
;	O
return	O
0	int
;	O
}	O
return	O
MU_ERR_INFO_UNAVAILABLE	O
;	O
}	O
if	O
(	O
imap	pointer
->	O
mbox_name	pointer
&&	O
strcmp	function
(	O
imap	pointer
->	O
mbox_name	pointer
,	O
mbox	pointer
)	O
==	O
0	int
&&	O
writable	int
==	O
imap	pointer
->	O
mbox_writable	int
)	O
{	O
if	O
(	O
ps	pointer
)	O
*	O
ps	pointer
=	O
imap	pointer
->	O
mbox_stat	struct
;	O
return	O
0	int
;	O
}	O
switch	O
(	O
imap	pointer
->	O
client_state	enum
)	O
{	O
case	O
MU_IMAP_CLIENT_READY	int
:	O
status	int
=	O
_mu_imap_tag_next	function
(	O
imap	pointer
)	O
;	O
MU_IMAP_CHECK_EAGAIN	O
(	O
imap	pointer
,	O
status	int
)	O
;	O
status	int
=	O
mu_imapio_send_command	function
(	O
imap	pointer
->	O
io	pointer
,	O
imap	pointer
->	O
tag_str	pointer
,	O
NULL	O
,	O
writable	int
?	O
"SELECT"	pointer
:	O
"EXAMINE"	pointer
,	O
mbox	pointer
,	O
NULL	O
)	O
;	O
MU_IMAP_CHECK_ERROR	O
(	O
imap	pointer
,	O
status	int
)	O
;	O
MU_IMAP_FCLR	O
(	O
imap	pointer
,	O
MU_IMAP_RESP	int
)	O
;	O
imap	pointer
->	O
client_state	enum
=	O
MU_IMAP_CLIENT_SELECT_RX	int
;	O
case	O
MU_IMAP_CLIENT_SELECT_RX	int
:	O
memset	function
(	O
&	O
imap	pointer
->	O
mbox_stat	struct
,	O
0	int
,	O
sizeof	O
(	O
imap	pointer
->	O
mbox_stat	struct
)	O
)	O
;	O
status	int
=	O
_mu_imap_response	function
(	O
imap	pointer
,	O
_select_response_action	pointer
,	O
NULL	O
)	O
;	O
MU_IMAP_CHECK_EAGAIN	O
(	O
imap	pointer
,	O
status	int
)	O
;	O
switch	O
(	O
imap	pointer
->	O
response	enum
)	O
{	O
case	O
MU_IMAP_OK	int
:	O
imap	pointer
->	O
session_state	enum
=	O
MU_IMAP_SESSION_SELECTED	int
;	O
free	function
(	O
imap	pointer
->	O
mbox_name	pointer
)	O
;	O
imap	pointer
->	O
mbox_name	pointer
=	O
strdup	function
(	O
mbox	pointer
)	O
;	O
if	O
(	O
!	O
imap	pointer
->	O
mbox_name	pointer
)	O
{	O
imap	pointer
->	O
client_state	enum
=	O
MU_IMAP_CLIENT_ERROR	int
;	O
return	O
errno	O
;	O
}	O
imap	pointer
->	O
mbox_writable	enum
=	O
writable	int
;	O
if	O
(	O
ps	pointer
)	O
*	O
ps	pointer
=	O
imap	pointer
->	O
mbox_stat	struct
;	O
break	O
;	O
case	O
MU_IMAP_NO	int
:	O
status	int
=	O
EACCES	int
;	O
break	O
;	O
case	O
MU_IMAP_BAD	int
:	O
status	int
=	O
MU_ERR_BADREPLY	O
;	O
break	O
;	O
}	O
imap	pointer
->	O
client_state	enum
=	O
MU_IMAP_CLIENT_READY	int
;	O
break	O
;	O
default	O
:	O
status	int
=	O
EINPROGRESS	int
;	O
}	O
return	O
status	int
;	O
}	O
int	O
mu_imap_store	function
(	O
mu_imap_t	pointer
imap	pointer
,	O
int	O
uid	int
,	O
mu_msgset_t	pointer
msgset	pointer
,	O
const	O
char	O
*	O
items	pointer
)	O
{	O
char	O
const	O
*	O
argv	pointer
[	O
3	int
]	O
;	O
int	O
i	int
;	O
static	O
struct	O
imap_command	struct
com	struct
;	O
i	int
=	O
0	int
;	O
if	O
(	O
uid	int
)	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
"UID"	pointer
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
"STORE"	pointer
;	O
argv	pointer
[	O
i	int
++	O
]	O
=	O
"\\"	pointer
;	O
com	struct
.	O
session_state	enum
=	O
MU_IMAP_SESSION_SELECTED	int
;	O
com	struct
.	O
capa	pointer
=	O
NULL	O
;	O
com	struct
.	O
rx_state	int
=	O
MU_IMAP_CLIENT_STORE_RX	int
;	O
com	struct
.	O
argc	int
=	O
i	int
;	O
com	struct
.	O
argv	pointer
=	O
argv	pointer
;	O
com	struct
.	O
extra	int
=	O
items	int
;	O
com	struct
.	O
msgset	pointer
=	O
msgset	pointer
;	O
com	struct
.	O
tagged_handler	pointer
=	O
NULL	O
;	O
com	struct
.	O
untagged_handler	pointer
=	O
NULL	O
;	O
return	O
mu_imap_gencom	function
(	O
imap	pointer
,	O
&	O
com	struct
)	O
;	O
}	O
int	O
mu_smtp_dot	function
(	O
mu_smtp_t	pointer
smtp	pointer
)	O
{	O
int	O
status	int
;	O
if	O
(	O
!	O
smtp	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
MU_SMTP_FISSET	O
(	O
smtp	pointer
,	O
_MU_SMTP_ERR	int
)	O
)	O
return	O
MU_ERR_FAILURE	O
;	O
if	O
(	O
smtp	pointer
->	O
state	pointer
!=	O
MU_SMTP_DOT	int
)	O
return	O
MU_ERR_SEQ	O
;	O
status	int
=	O
mu_smtp_response	function
(	O
smtp	pointer
)	O
;	O
MU_SMTP_CHECK_ERROR	O
(	O
smtp	pointer
,	O
status	int
)	O
;	O
if	O
(	O
smtp	pointer
->	O
replcode	array
[	O
0	int
]	O
!=	O
'2'	O
)	O
return	O
MU_ERR_REPLY	O
;	O
smtp	pointer
->	O
state	pointer
=	O
MU_SMTP_MAIL	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_mbox_is_scheme	function
(	O
mu_record_t	pointer
record	pointer
,	O
mu_url_t	pointer
url	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
int	O
scheme_matched	int
=	O
mu_url_is_scheme	function
(	O
url	pointer
,	O
record	pointer
->	O
scheme	pointer
)	O
;	O
if	O
(	O
scheme_matched	int
||	O
mu_scheme_autodetect_p	function
(	O
url	pointer
)	O
)	O
{	O
struct	O
stat	struct
st	struct
;	O
const	O
char	O
*	O
path	pointer
;	O
mu_url_sget_path	function
(	O
url	pointer
,	O
&	O
path	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
path	pointer
,	O
&	O
st	struct
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
if	O
(	O
scheme_matched	int
)	O
return	O
MU_FOLDER_ATTRIBUTE_FILE	int
&	O
flags	int
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
S_ISREG	O
(	O
st	struct
.	O
st_mode	int
)	O
||	O
S_ISCHR	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
st	struct
.	O
st_size	long
==	O
0	int
)	O
{	O
rc	int
|=	O
MU_FOLDER_ATTRIBUTE_FILE	int
;	O
}	O
else	O
if	O
(	O
flags	int
&	O
MU_FOLDER_ATTRIBUTE_FILE	int
)	O
{	O
if	O
(	O
mu_autodetect_accuracy	function
(	O
)	O
>	O
0	int
)	O
{	O
int	O
fd	int
=	O
open	function
(	O
path	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
!=	O
-	O
1	int
)	O
{	O
char	O
buf	pointer
[	O
5	int
]	O
;	O
if	O
(	O
read	pointer
(	O
fd	int
,	O
buf	pointer
,	O
5	int
)	O
==	O
5	int
)	O
if	O
(	O
memcmp	function
(	O
buf	pointer
,	O
"From "	pointer
,	O
5	int
)	O
==	O
0	int
)	O
rc	int
|=	O
MU_FOLDER_ATTRIBUTE_FILE	int
;	O
close	function
(	O
fd	int
)	O
;	O
}	O
}	O
else	O
rc	int
|=	O
MU_FOLDER_ATTRIBUTE_FILE	int
;	O
}	O
}	O
if	O
(	O
(	O
flags	int
&	O
MU_FOLDER_ATTRIBUTE_DIRECTORY	int
)	O
&&	O
S_ISDIR	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
rc	int
|=	O
MU_FOLDER_ATTRIBUTE_DIRECTORY	int
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
struct	O
_mu_record	struct
_mbox_record	struct
=	O
{	O
MU_MBOX_PRIO	int
,	O
MU_MBOX_SCHEME	int
,	O
MU_RECORD_LOCAL	int
,	O
MU_URL_SCHEME	int
|	O
MU_URL_PATH	int
|	O
MU_URL_PARAM	int
,	O
MU_URL_PATH	int
,	O
mu_url_expand_path	function
,	O
_mailbox_mbox_init	function
,	O
NULL	O
,	O
_mu_fsfolder_init	function
,	O
NULL	O
,	O
_mbox_is_scheme	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
mu_record_t	pointer
mu_mbox_record	pointer
=	O
&	O
_mbox_record	struct
;	O
int	O
mu_nntp_body	function
(	O
mu_nntp_t	pointer
nntp	pointer
,	O
unsigned	O
long	O
number	pointer
,	O
unsigned	O
long	O
*	O
pnum	pointer
,	O
char	O
*	O
*	O
mid	pointer
,	O
mu_stream_t	pointer
*	O
pstream	pointer
)	O
{	O
int	O
status	int
;	O
char	O
*	O
message_id	pointer
=	O
NULL	O
;	O
if	O
(	O
number	pointer
!=	O
0	int
)	O
{	O
message_id	pointer
=	O
malloc	function
(	O
128	int
)	O
;	O
if	O
(	O
message_id	pointer
==	O
NULL	O
)	O
{	O
return	O
ENOMEM	int
;	O
}	O
snprintf	function
(	O
message_id	pointer
,	O
127	int
,	O
"%lu"	pointer
,	O
number	pointer
)	O
;	O
}	O
status	int
=	O
mu_nntp_body_id	function
(	O
nntp	pointer
,	O
message_id	pointer
,	O
pnum	pointer
,	O
mid	pointer
,	O
pstream	pointer
)	O
;	O
if	O
(	O
message_id	pointer
)	O
{	O
free	function
(	O
message_id	pointer
)	O
;	O
}	O
return	O
status	int
;	O
}	O
int	O
mu_nntp_body_id	function
(	O
mu_nntp_t	pointer
nntp	pointer
,	O
const	O
char	O
*	O
message_id	pointer
,	O
unsigned	O
long	O
*	O
pnum	pointer
,	O
char	O
*	O
*	O
mid	pointer
,	O
mu_stream_t	pointer
*	O
pstream	pointer
)	O
{	O
int	O
status	pointer
;	O
if	O
(	O
nntp	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
if	O
(	O
pstream	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
switch	O
(	O
nntp	pointer
->	O
state	pointer
)	O
{	O
case	O
MU_NNTP_NO_STATE	int
:	O
if	O
(	O
message_id	pointer
==	O
0	int
||	O
*	O
message_id	pointer
==	O
'\0'	O
)	O
{	O
status	pointer
=	O
mu_nntp_writeline	function
(	O
nntp	pointer
,	O
"BODY\r\n"	pointer
)	O
;	O
}	O
else	O
{	O
status	pointer
=	O
mu_nntp_writeline	function
(	O
nntp	pointer
,	O
"BODY %s\r\n"	pointer
,	O
message_id	pointer
)	O
;	O
}	O
MU_NNTP_CHECK_ERROR	O
(	O
nntp	pointer
,	O
status	pointer
)	O
;	O
mu_nntp_debug_cmd	function
(	O
nntp	pointer
)	O
;	O
nntp	pointer
->	O
state	pointer
=	O
MU_NNTP_BODY	int
;	O
case	O
MU_NNTP_BODY	int
:	O
status	pointer
=	O
mu_nntp_send	function
(	O
nntp	pointer
)	O
;	O
MU_NNTP_CHECK_EAGAIN	O
(	O
nntp	pointer
,	O
status	pointer
)	O
;	O
nntp	pointer
->	O
acknowledge	int
=	O
0	int
;	O
nntp	pointer
->	O
state	pointer
=	O
MU_NNTP_BODY_ACK	int
;	O
case	O
MU_NNTP_BODY_ACK	int
:	O
status	pointer
=	O
mu_nntp_response	function
(	O
nntp	pointer
,	O
NULL	O
,	O
0	int
,	O
NULL	O
)	O
;	O
MU_NNTP_CHECK_EAGAIN	O
(	O
nntp	pointer
,	O
status	pointer
)	O
;	O
mu_nntp_debug_ack	function
(	O
nntp	pointer
)	O
;	O
MU_NNTP_CHECK_CODE	O
(	O
nntp	pointer
,	O
MU_NNTP_RESP_CODE_BODY_FOLLOW	function
)	O
;	O
status	pointer
=	O
mu_nntp_parse_article	function
(	O
nntp	pointer
,	O
MU_NNTP_RESP_CODE_BODY_FOLLOW	function
,	O
pnum	pointer
,	O
mid	pointer
)	O
;	O
MU_NNTP_CHECK_ERROR	O
(	O
nntp	pointer
,	O
status	pointer
)	O
;	O
nntp	pointer
->	O
state	pointer
=	O
MU_NNTP_BODY_RX	int
;	O
case	O
MU_NNTP_BODY_RX	int
:	O
status	pointer
=	O
mu_nntp_stream_create	function
(	O
nntp	pointer
,	O
pstream	pointer
)	O
;	O
MU_NNTP_CHECK_ERROR	O
(	O
nntp	pointer
,	O
status	pointer
)	O
;	O
break	O
;	O
case	O
MU_NNTP_ERROR	int
:	O
status	pointer
=	O
ECANCELED	int
;	O
break	O
;	O
default	O
:	O
status	int
=	O
EINPROGRESS	int
;	O
}	O
return	O
status	int
;	O
}	O
void	O
mu_pop3_destroy	function
(	O
mu_pop3_t	pointer
*	O
ppop3	pointer
)	O
{	O
if	O
(	O
ppop3	pointer
&&	O
*	O
ppop3	pointer
)	O
{	O
mu_pop3_t	pointer
pop3	pointer
=	O
*	O
ppop3	pointer
;	O
if	O
(	O
pop3	pointer
->	O
ackbuf	pointer
)	O
free	function
(	O
pop3	pointer
->	O
ackbuf	pointer
)	O
;	O
if	O
(	O
pop3	pointer
->	O
rdbuf	pointer
)	O
free	function
(	O
pop3	pointer
->	O
rdbuf	pointer
)	O
;	O
if	O
(	O
pop3	pointer
->	O
timestamp	pointer
)	O
free	function
(	O
pop3	pointer
->	O
timestamp	pointer
)	O
;	O
mu_list_destroy	function
(	O
&	O
pop3	pointer
->	O
capa	pointer
)	O
;	O
if	O
(	O
pop3	pointer
->	O
carrier	pointer
)	O
mu_stream_destroy	function
(	O
&	O
pop3	pointer
->	O
carrier	pointer
)	O
;	O
free	function
(	O
pop3	pointer
)	O
;	O
*	O
ppop3	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
int	O
pop3_itr_dup	function
(	O
void	O
*	O
*	O
ptr	pointer
,	O
void	O
*	O
owner	pointer
)	O
;	O
static	O
int	O
pop3_itr_destroy	function
(	O
mu_iterator_t	pointer
itr	pointer
,	O
void	O
*	O
owner	pointer
)	O
;	O
static	O
int	O
pop3_itr_first	function
(	O
void	O
*	O
owner	pointer
)	O
;	O
static	O
int	O
pop3_itr_next	function
(	O
void	O
*	O
woner	pointer
)	O
;	O
static	O
int	O
pop3_itr_getitem	function
(	O
void	O
*	O
owner	pointer
,	O
void	O
*	O
*	O
pret	pointer
,	O
const	O
void	O
*	O
*	O
pkey	pointer
)	O
;	O
static	O
int	O
pop3_itr_delitem	function
(	O
void	O
*	O
owner	pointer
,	O
void	O
*	O
data	pointer
)	O
;	O
static	O
int	O
pop3_itr_finished_p	function
(	O
void	O
*	O
owner	pointer
)	O
;	O
struct	O
pop3_iterator	struct
{	O
mu_pop3_t	pointer
pop3	pointer
;	O
mu_stream_t	pointer
stream	pointer
;	O
int	O
done	int
;	O
char	O
*	O
item	pointer
;	O
char	O
*	O
rdbuf	pointer
;	O
size_t	long
rdsize	long
;	O
}	O
;	O
int	O
mu_pop3_iterator_create	function
(	O
mu_pop3_t	pointer
pop3	pointer
,	O
mu_iterator_t	pointer
*	O
piterator	pointer
)	O
{	O
struct	O
pop3_iterator	struct
*	O
pop3_iterator	pointer
;	O
mu_iterator_t	pointer
iterator	pointer
;	O
int	O
status	int
;	O
pop3_iterator	pointer
=	O
malloc	function
(	O
sizeof	O
*	O
pop3_iterator	pointer
)	O
;	O
if	O
(	O
pop3_iterator	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
status	int
=	O
mu_pop3_stream_create	function
(	O
pop3	pointer
,	O
&	O
pop3_iterator	pointer
->	O
stream	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
free	function
(	O
pop3_iterator	pointer
)	O
;	O
return	O
status	int
;	O
}	O
pop3_iterator	pointer
->	O
item	pointer
=	O
NULL	O
;	O
pop3_iterator	pointer
->	O
rdbuf	pointer
=	O
NULL	O
;	O
pop3_iterator	pointer
->	O
rdsize	long
=	O
0	int
;	O
pop3_iterator	pointer
->	O
done	int
=	O
0	int
;	O
pop3_iterator	pointer
->	O
pop3	pointer
=	O
pop3	pointer
;	O
status	int
=	O
mu_iterator_create	function
(	O
&	O
iterator	pointer
,	O
pop3_iterator	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
free	function
(	O
pop3_iterator	pointer
)	O
;	O
return	O
status	int
;	O
}	O
mu_iterator_set_first	function
(	O
iterator	pointer
,	O
pop3_itr_first	function
)	O
;	O
mu_iterator_set_next	function
(	O
iterator	pointer
,	O
pop3_itr_next	function
)	O
;	O
mu_iterator_set_getitem	function
(	O
iterator	pointer
,	O
pop3_itr_getitem	function
)	O
;	O
mu_iterator_set_finished_p	function
(	O
iterator	pointer
,	O
pop3_itr_finished_p	function
)	O
;	O
mu_iterator_set_delitem	function
(	O
iterator	pointer
,	O
pop3_itr_delitem	function
)	O
;	O
mu_iterator_set_destroy	function
(	O
iterator	pointer
,	O
pop3_itr_destroy	function
)	O
;	O
mu_iterator_set_dup	function
(	O
iterator	pointer
,	O
pop3_itr_dup	function
)	O
;	O
*	O
piterator	pointer
=	O
iterator	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
pop3_itr_dup	function
(	O
void	O
*	O
*	O
ptr	pointer
,	O
void	O
*	O
owner	pointer
)	O
{	O
struct	O
pop3_iterator	struct
*	O
pop3_iterator	pointer
=	O
(	O
struct	O
pop3_iterator	struct
*	O
)	O
owner	pointer
;	O
struct	O
pop3_iterator	struct
*	O
clone	pointer
=	O
malloc	function
(	O
sizeof	O
*	O
pop3_iterator	pointer
)	O
;	O
if	O
(	O
clone	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	O
;	O
*	O
clone	O
=	O
*	O
pop3_iterator	pointer
;	O
*	O
ptr	pointer
=	O
clone	function
;	O
return	O
0	int
;	O
}	O
static	O
int	O
pop3_itr_destroy	function
(	O
mu_iterator_t	pointer
iterator	pointer
,	O
void	O
*	O
owner	pointer
)	O
{	O
struct	O
pop3_iterator	struct
*	O
pop3_iterator	pointer
=	O
(	O
struct	O
pop3_iterator	struct
*	O
)	O
owner	pointer
;	O
if	O
(	O
!	O
pop3_iterator	pointer
->	O
done	int
)	O
{	O
char	O
buf	pointer
[	O
128	int
]	O
;	O
size_t	long
n	long
=	O
0	int
;	O
mu_stream_t	pointer
str	pointer
=	O
pop3_iterator	pointer
->	O
pop3	pointer
->	O
carrier	pointer
;	O
while	O
(	O
mu_stream_readline	function
(	O
str	pointer
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
&	O
n	long
)	O
>	O
0	int
&&	O
n	long
>	O
0	int
)	O
n	long
=	O
0	int
;	O
}	O
if	O
(	O
pop3_iterator	pointer
->	O
item	pointer
)	O
free	function
(	O
pop3_iterator	pointer
->	O
item	pointer
)	O
;	O
if	O
(	O
pop3_iterator	pointer
->	O
rdbuf	pointer
)	O
free	function
(	O
pop3_iterator	pointer
->	O
rdbuf	pointer
)	O
;	O
pop3_iterator	pointer
->	O
pop3	pointer
->	O
state	pointer
=	O
MU_POP3_NO_STATE	int
;	O
free	function
(	O
pop3_iterator	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
pop3_itr_first	function
(	O
void	O
*	O
data	pointer
)	O
{	O
return	O
pop3_itr_next	function
(	O
data	pointer
)	O
;	O
}	O
static	O
int	O
pop3_itr_next	function
(	O
void	O
*	O
owner	pointer
)	O
{	O
struct	O
pop3_iterator	struct
*	O
pop3_iterator	pointer
=	O
(	O
struct	O
pop3_iterator	struct
*	O
)	O
owner	pointer
;	O
int	O
status	int
=	O
0	int
;	O
size_t	long
n	int
;	O
status	int
=	O
mu_stream_getline	function
(	O
pop3_iterator	pointer
->	O
stream	pointer
,	O
&	O
pop3_iterator	pointer
->	O
rdbuf	pointer
,	O
&	O
pop3_iterator	pointer
->	O
rdsize	long
,	O
&	O
n	long
)	O
;	O
if	O
(	O
status	int
||	O
n	int
==	O
0	int
)	O
{	O
pop3_iterator	pointer
->	O
done	int
=	O
1	int
;	O
pop3_iterator	pointer
->	O
pop3	pointer
->	O
state	pointer
=	O
MU_POP3_NO_STATE	int
;	O
return	O
0	int
;	O
}	O
n	long
=	O
mu_rtrim_class	function
(	O
pop3_iterator	pointer
->	O
rdbuf	pointer
,	O
MU_CTYPE_SPACE	int
)	O
;	O
if	O
(	O
n	long
==	O
1	int
&&	O
pop3_iterator	pointer
->	O
rdbuf	pointer
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
pop3_iterator	pointer
->	O
done	int
=	O
1	int
;	O
pop3_iterator	pointer
->	O
pop3	pointer
->	O
state	int
=	O
MU_POP3_NO_STATE	int
;	O
}	O
else	O
pop3_iterator	pointer
->	O
item	pointer
=	O
pop3_iterator	pointer
->	O
rdbuf	pointer
;	O
return	O
status	int
;	O
}	O
static	O
int	O
pop3_itr_getitem	function
(	O
void	O
*	O
owner	pointer
,	O
void	O
*	O
*	O
item	pointer
,	O
const	O
void	O
*	O
*	O
pkey	pointer
)	O
{	O
struct	O
pop3_iterator	struct
*	O
pop3_iterator	pointer
=	O
(	O
struct	O
pop3_iterator	struct
*	O
)	O
owner	pointer
;	O
if	O
(	O
item	pointer
)	O
{	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
item	pointer
)	O
=	O
pop3_iterator	pointer
->	O
item	pointer
;	O
pop3_iterator	pointer
->	O
item	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
pkey	pointer
)	O
*	O
pkey	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
pop3_itr_finished_p	function
(	O
void	O
*	O
owner	pointer
)	O
{	O
struct	O
pop3_iterator	struct
*	O
pop3_iterator	pointer
=	O
(	O
struct	O
pop3_iterator	struct
*	O
)	O
owner	pointer
;	O
return	O
pop3_iterator	pointer
->	O
done	pointer
;	O
}	O
static	O
int	O
pop3_itr_delitem	function
(	O
void	O
*	O
owner	pointer
,	O
void	O
*	O
item	pointer
)	O
{	O
struct	O
pop3_iterator	struct
*	O
pop3_iterator	pointer
=	O
(	O
struct	O
pop3_iterator	struct
*	O
)	O
owner	pointer
;	O
return	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
item	pointer
)	O
==	O
pop3_iterator	pointer
->	O
item	pointer
?	O
MU_ITR_DELITEM_NEXT	int
:	O
MU_ITR_DELITEM_NOTHING	int
;	O
}	O
int	O
mu_pop3_list_all	function
(	O
mu_pop3_t	pointer
pop3	pointer
,	O
mu_iterator_t	pointer
*	O
piterator	pointer
)	O
{	O
int	O
status	int
=	O
mu_pop3_list_cmd	function
(	O
pop3	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_pop3_iterator_create	function
(	O
pop3	pointer
,	O
piterator	pointer
)	O
;	O
MU_POP3_CHECK_ERROR	O
(	O
pop3	pointer
,	O
status	int
)	O
;	O
pop3	pointer
->	O
state	enum
=	O
MU_POP3_LIST_RX	int
;	O
return	O
status	int
;	O
}	O
int	O
mu_pop3_quit	function
(	O
mu_pop3_t	pointer
pop3	pointer
)	O
{	O
int	O
status	int
;	O
if	O
(	O
pop3	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
switch	O
(	O
pop3	pointer
->	O
state	enum
)	O
{	O
case	O
MU_POP3_NO_STATE	int
:	O
status	int
=	O
mu_pop3_writeline	function
(	O
pop3	pointer
,	O
"QUIT\r\n"	pointer
)	O
;	O
MU_POP3_CHECK_ERROR	O
(	O
pop3	pointer
,	O
status	int
)	O
;	O
MU_POP3_FCLR	O
(	O
pop3	pointer
,	O
MU_POP3_ACK	int
)	O
;	O
pop3	pointer
->	O
state	pointer
=	O
MU_POP3_QUIT	int
;	O
case	O
MU_POP3_QUIT	int
:	O
status	int
=	O
mu_pop3_response	function
(	O
pop3	pointer
,	O
NULL	O
)	O
;	O
MU_POP3_CHECK_EAGAIN	O
(	O
pop3	pointer
,	O
status	int
)	O
;	O
MU_POP3_CHECK_OK	O
(	O
pop3	pointer
)	O
;	O
pop3	pointer
->	O
state	pointer
=	O
MU_POP3_NO_STATE	int
;	O
_mu_pop3_init	function
(	O
pop3	pointer
)	O
;	O
break	O
;	O
default	O
:	O
status	int
=	O
EINPROGRESS	int
;	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
pop3_get_streams	function
(	O
mu_pop3_t	pointer
pop3	pointer
,	O
mu_stream_t	pointer
*	O
streams	pointer
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
MU_POP3_FISSET	O
(	O
pop3	pointer
,	O
MU_POP3_TRACE	int
)	O
)	O
rc	int
=	O
mu_stream_ioctl	function
(	O
pop3	pointer
->	O
carrier	pointer
,	O
MU_IOCTL_SUBSTREAM	int
,	O
MU_IOCTL_OP_GET	int
,	O
streams	pointer
)	O
;	O
else	O
{	O
streams	pointer
[	O
0	int
]	O
=	O
pop3	pointer
->	O
carrier	pointer
;	O
mu_stream_ref	function
(	O
streams	pointer
[	O
0	int
]	O
)	O
;	O
streams	pointer
[	O
1	int
]	O
=	O
pop3	pointer
->	O
carrier	pointer
;	O
mu_stream_ref	function
(	O
streams	pointer
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
pop3_set_streams	function
(	O
mu_pop3_t	pointer
pop3	pointer
,	O
mu_stream_t	pointer
*	O
streams	pointer
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
MU_POP3_FISSET	O
(	O
pop3	pointer
,	O
MU_POP3_TRACE	int
)	O
)	O
rc	int
=	O
mu_stream_ioctl	function
(	O
pop3	pointer
->	O
carrier	pointer
,	O
MU_IOCTL_SUBSTREAM	int
,	O
MU_IOCTL_OP_SET	int
,	O
streams	pointer
)	O
;	O
else	O
{	O
mu_stream_t	pointer
tmp	pointer
;	O
if	O
(	O
streams	pointer
[	O
0	int
]	O
==	O
streams	pointer
[	O
1	int
]	O
)	O
{	O
tmp	pointer
=	O
streams	pointer
[	O
0	int
]	O
;	O
mu_stream_ref	function
(	O
tmp	pointer
)	O
;	O
mu_stream_ref	function
(	O
tmp	pointer
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
else	O
rc	int
=	O
mu_iostream_create	function
(	O
&	O
tmp	pointer
,	O
streams	pointer
[	O
0	int
]	O
,	O
streams	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_stream_unref	function
(	O
pop3	pointer
->	O
carrier	pointer
)	O
;	O
pop3	pointer
->	O
carrier	pointer
=	O
tmp	pointer
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
int	O
mu_pop3_stls	function
(	O
mu_pop3_t	pointer
pop3	pointer
)	O
{	O
return	O
ENOTSUP	O
;	O
}	O
int	O
mu_pop3_uidl_all	function
(	O
mu_pop3_t	pointer
pop3	pointer
,	O
mu_iterator_t	pointer
*	O
piterator	pointer
)	O
{	O
int	O
status	int
=	O
mu_pop3_uidl_all_cmd	function
(	O
pop3	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
mu_pop3_iterator_create	function
(	O
pop3	pointer
,	O
piterator	pointer
)	O
;	O
MU_POP3_CHECK_ERROR	O
(	O
pop3	pointer
,	O
status	int
)	O
;	O
pop3	pointer
->	O
state	enum
=	O
MU_POP3_UIDL_RX	int
;	O
return	O
status	int
;	O
}	O
static	O
int	O
echo_runcmd	function
(	O
char	O
*	O
*	O
ret	pointer
,	O
const	O
char	O
*	O
str	pointer
,	O
size_t	long
len	long
,	O
char	O
*	O
*	O
argv	pointer
,	O
void	O
*	O
closure	pointer
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	pointer
ps	pointer
;	O
mu_stream_t	pointer
outs	pointer
;	O
size_t	long
i	long
;	O
int	O
status	int
=	O
MU_WRDSE_OK	int
;	O
char	O
buf	pointer
[	O
128	int
]	O
;	O
size_t	long
n	long
;	O
*	O
ret	pointer
=	O
NULL	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
argv	pointer
[	O
i	long
]	O
;	O
i	long
++	O
)	O
;	O
rc	int
=	O
mu_prog_stream_create	function
(	O
&	O
ps	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
i	long
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"Can't run %s: %s"	pointer
)	O
,	O
argv	pointer
[	O
0	int
]	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
MU_WRDSE_USERERR	int
;	O
}	O
rc	int
=	O
mu_memory_stream_create	function
(	O
&	O
outs	pointer
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_memory_stream_create"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
mu_stream_destroy	function
(	O
&	O
ps	pointer
)	O
;	O
return	O
MU_WRDSE_USERERR	int
;	O
}	O
while	O
(	O
(	O
rc	int
=	O
mu_stream_read	function
(	O
ps	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
&	O
n	long
)	O
)	O
==	O
0	int
&&	O
n	long
>	O
0	int
)	O
{	O
int	O
wn	int
=	O
mu_stream_write	function
(	O
outs	pointer
,	O
buf	pointer
,	O
n	long
,	O
NULL	O
)	O
;	O
if	O
(	O
wn	long
)	O
{	O
mu_error	function
(	O
_	O
(	O
"error writing to temporary stream: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
wn	long
)	O
)	O
;	O
status	int
=	O
MU_WRDSE_USERERR	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
status	int
==	O
MU_WRDSE_OK	int
&&	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"error reading %s output: %s"	pointer
)	O
,	O
argv	pointer
[	O
0	int
]	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
status	int
=	O
MU_WRDSE_USERERR	int
;	O
}	O
mu_stream_destroy	function
(	O
&	O
ps	pointer
)	O
;	O
if	O
(	O
status	int
==	O
MU_WRDSE_OK	int
)	O
{	O
mu_off_t	long
size	long
;	O
char	O
*	O
p	pointer
;	O
mu_stream_size	function
(	O
outs	pointer
,	O
&	O
size	long
)	O
;	O
p	pointer
=	O
malloc	function
(	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
mu_stream_seek	function
(	O
outs	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
rc	int
=	O
mu_stream_read	function
(	O
outs	pointer
,	O
p	pointer
,	O
size	long
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
p	pointer
[	O
size	long
]	O
=	O
0	int
;	O
*	O
ret	pointer
=	O
p	pointer
;	O
}	O
else	O
{	O
free	function
(	O
p	pointer
)	O
;	O
mu_error	function
(	O
_	O
(	O
"error reading from temporary stream: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
status	int
=	O
MU_WRDSE_USERERR	int
;	O
}	O
}	O
else	O
status	int
=	O
MU_WRDSE_NOSPACE	int
;	O
}	O
mu_stream_destroy	function
(	O
&	O
outs	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
echo	function
(	O
char	O
*	O
s	pointer
,	O
int	O
*	O
nl	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
mu_wordsplit	struct
ws	pointer
;	O
int	O
wsflags	int
=	O
MU_WRDSF_NOSPLIT	O
|	O
MU_WRDSF_QUOTE	int
|	O
MU_WRDSF_ENV	int
;	O
size_t	long
len	long
;	O
ws	pointer
.	O
ws_env	pointer
=	O
(	O
const	O
char	O
*	O
*	O
)	O
environ	pointer
;	O
ws	pointer
.	O
ws_command	int
=	O
echo_runcmd	pointer
;	O
rc	int
=	O
mu_wordsplit	struct
(	O
s	pointer
,	O
&	O
ws	pointer
,	O
wsflags	int
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
MU_WRDSE_OK	int
:	O
break	O
;	O
case	O
MU_WRDSE_USERERR	int
:	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
return	O
1	int
;	O
default	O
:	O
mu_error	function
(	O
"%s"	pointer
,	O
mu_wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
return	O
1	int
;	O
}	O
len	long
=	O
strlen	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
)	O
;	O
mu_stream_write	function
(	O
mu_strout	pointer
,	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
,	O
len	long
,	O
NULL	O
)	O
;	O
*	O
nl	pointer
=	O
len	long
>	O
0	int
&&	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
;	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mail_echo	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
int	O
i	int
;	O
int	O
nl	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
>	O
1	int
)	O
mu_printf	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
echo	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
&	O
nl	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
nl	pointer
)	O
mu_printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mail_followup	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_message_t	pointer
msg	pointer
;	O
mu_header_t	pointer
hdr	pointer
;	O
char	O
*	O
str	pointer
;	O
msgset_t	struct
*	O
msglist	pointer
,	O
*	O
mp	pointer
;	O
compose_env_t	pointer
env	pointer
;	O
int	O
status	int
;	O
size_t	long
n	long
;	O
compose_init	function
(	O
&	O
env	pointer
)	O
;	O
if	O
(	O
msgset_parse	function
(	O
argc	int
,	O
argv	pointer
,	O
MSG_NODELETED	int
,	O
&	O
msglist	pointer
)	O
)	O
return	O
1	int
;	O
n	long
=	O
get_cursor	function
(	O
)	O
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"No applicable message"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
util_get_message	function
(	O
mbox	pointer
,	O
n	long
,	O
&	O
msg	pointer
)	O
)	O
{	O
msgset_free	function
(	O
msglist	pointer
)	O
;	O
return	O
1	int
;	O
}	O
mu_message_get_header	function
(	O
msg	pointer
,	O
&	O
hdr	pointer
)	O
;	O
if	O
(	O
mu_header_aget_value	O
(	O
hdr	pointer
,	O
MU_HEADER_SUBJECT	pointer
,	O
&	O
str	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
if	O
(	O
mu_unre_subject	function
(	O
str	pointer
,	O
NULL	O
)	O
)	O
util_strcat	function
(	O
&	O
p	pointer
,	O
util_reply_prefix	function
(	O
)	O
)	O
;	O
util_strcat	function
(	O
&	O
p	pointer
,	O
str	pointer
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
compose_header_set	function
(	O
&	O
env	pointer
,	O
MU_HEADER_SUBJECT	pointer
,	O
p	pointer
,	O
COMPOSE_REPLACE	pointer
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
compose_header_set	function
(	O
&	O
env	pointer
,	O
MU_HEADER_TO	pointer
,	O
util_get_sender	function
(	O
get_cursor	function
(	O
)	O
,	O
0	int
)	O
,	O
COMPOSE_SINGLE_LINE	pointer
)	O
;	O
for	O
(	O
mp	pointer
=	O
msglist	pointer
;	O
mp	pointer
;	O
mp	pointer
=	O
mp	pointer
->	O
next	pointer
)	O
compose_header_set	function
(	O
&	O
env	pointer
,	O
MU_HEADER_TO	pointer
,	O
util_get_sender	function
(	O
mp	pointer
->	O
msg_part	pointer
[	O
0	int
]	O
,	O
0	int
)	O
,	O
COMPOSE_SINGLE_LINE	pointer
)	O
;	O
msgset_free	function
(	O
msglist	pointer
)	O
;	O
mu_printf	function
(	O
"To: %s\n"	pointer
,	O
compose_header_get	function
(	O
&	O
env	pointer
,	O
MU_HEADER_TO	pointer
,	O
""	pointer
)	O
)	O
;	O
mu_printf	function
(	O
"Subject: %s\n\n"	pointer
,	O
compose_header_get	function
(	O
&	O
env	pointer
,	O
MU_HEADER_SUBJECT	pointer
,	O
""	pointer
)	O
)	O
;	O
status	int
=	O
mail_send0	function
(	O
&	O
env	pointer
,	O
mu_isupper	function
(	O
argv	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
)	O
;	O
compose_destroy	function
(	O
&	O
env	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
*	O
_cond_stack	pointer
;	O
static	O
int	O
_cond_stack_size	int
;	O
static	O
int	O
_cond_level	int
;	O
static	O
void	O
_cond_push	function
(	O
int	O
val	int
)	O
;	O
static	O
int	O
_cond_pop	function
(	O
void	O
)	O
;	O
int	O
if_cond	function
(	O
)	O
{	O
if	O
(	O
_cond_level	int
==	O
0	int
)	O
return	O
1	int
;	O
return	O
_cond_stack	array
[	O
_cond_level	int
-	O
1	int
]	O
;	O
}	O
void	O
_cond_push	function
(	O
int	O
val	int
)	O
{	O
if	O
(	O
!	O
_cond_stack	pointer
)	O
{	O
_cond_stack	pointer
=	O
calloc	function
(	O
COND_STK_SIZE	int
,	O
sizeof	O
(	O
_cond_stack	array
[	O
0	int
]	O
)	O
)	O
;	O
_cond_stack_size	int
=	O
COND_STK_SIZE	int
;	O
_cond_level	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
_cond_level	int
>=	O
_cond_stack_size	int
)	O
{	O
_cond_stack_size	int
+=	O
COND_STK_INCR	int
;	O
_cond_stack	pointer
=	O
realloc	function
(	O
_cond_stack	pointer
,	O
sizeof	O
(	O
_cond_stack	array
[	O
0	int
]	O
)	O
*	O
_cond_stack_size	pointer
)	O
;	O
}	O
if	O
(	O
!	O
_cond_stack	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"Not enough memory"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
_cond_stack	array
[	O
_cond_level	int
++	O
]	O
=	O
val	int
;	O
}	O
int	O
_cond_pop	function
(	O
)	O
{	O
if	O
(	O
_cond_level	int
==	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"Internal error: condition stack underflow"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
return	O
_cond_stack	array
[	O
--	O
_cond_level	int
]	O
;	O
}	O
int	O
mail_if	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
mode	pointer
;	O
int	O
cond	enum
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"if requires an argument: s | r | t"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
[	O
1	int
]	O
!=	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"Valid if arguments are: s | r | t"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
mailvar_get	function
(	O
&	O
mode	int
,	O
mailvar_name_mode	int
,	O
mailvar_type_string	int
,	O
1	int
)	O
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
if	O
(	O
if_cond	function
(	O
)	O
==	O
0	int
)	O
cond	double
=	O
0	int
;	O
else	O
{	O
switch	O
(	O
argv	array
[	O
1	int
]	O
[	O
0	int
]	O
)	O
{	O
case	O
's'	O
:	O
cond	enum
=	O
strcmp	function
(	O
mode	pointer
,	O
"send"	pointer
)	O
==	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
cond	enum
=	O
strcmp	function
(	O
mode	pointer
,	O
"read"	pointer
)	O
==	O
0	int
;	O
break	O
;	O
case	O
't'	O
:	O
cond	pointer
=	O
isatty	function
(	O
fileno	function
(	O
stdout	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
mu_error	function
(	O
_	O
(	O
"Valid if arguments are: s | r | t"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
_cond_push	function
(	O
cond	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mail_else	function
(	O
int	O
argc	int
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	pointer
MU_ARG_UNUSED	O
)	O
{	O
int	O
cond	double
;	O
if	O
(	O
_cond_level	int
==	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"else without matching if"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
cond	pointer
=	O
_cond_pop	function
(	O
)	O
;	O
if	O
(	O
if_cond	function
(	O
)	O
)	O
cond	double
=	O
!	O
cond	enum
;	O
_cond_push	function
(	O
cond	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
mail_endif	function
(	O
int	O
argc	int
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	pointer
MU_ARG_UNUSED	O
)	O
{	O
if	O
(	O
_cond_level	int
==	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"endif without matching if"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
_cond_pop	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
mail_list	function
(	O
int	O
argc	int
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	pointer
MU_ARG_UNUSED	O
)	O
{	O
mail_command_list	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
exit_code	int
;	O
void	O
mda_close_fds	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
long	O
fdlimit	long
=	O
sysconf	function
(	O
_SC_OPEN_MAX	int
)	O
;	O
for	O
(	O
i	int
=	O
3	int
;	O
i	int
<	O
fdlimit	long
;	O
i	int
++	O
)	O
close	function
(	O
i	int
)	O
;	O
}	O
int	O
mda_switch_user_id	function
(	O
struct	O
mu_auth_data	struct
*	O
auth	pointer
,	O
int	O
user	pointer
)	O
{	O
int	O
rc	int
;	O
uid_t	int
uid	int
;	O
if	O
(	O
!	O
auth	pointer
||	O
auth	pointer
->	O
change_uid	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
user	pointer
)	O
uid	int
=	O
auth	pointer
->	O
uid	int
;	O
else	O
uid	int
=	O
0	int
;	O
rc	int
=	O
setreuid	function
(	O
0	int
,	O
uid	int
)	O
;	O
if	O
(	O
rc	int
<	O
0	int
)	O
mda_error	function
(	O
"setreuid(0, %d): %s (r=%d, e=%d)"	int
,	O
uid	int
,	O
strerror	function
(	O
errno	O
)	O
,	O
getuid	function
(	O
)	O
,	O
geteuid	function
(	O
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
temp_errors	array
[	O
]	O
=	O
{	O
EAGAIN	int
,	O
EBUSY	int
,	O
EUSERS	int
,	O
ECONNABORTED	int
,	O
ECONNREFUSED	int
,	O
ECONNRESET	int
,	O
EDEADLK	int
,	O
EDEADLOCK	int
,	O
EFBIG	int
,	O
EHOSTDOWN	int
,	O
EHOSTUNREACH	int
,	O
EMFILE	int
,	O
ENETDOWN	int
,	O
ENETUNREACH	int
,	O
ENETRESET	int
,	O
ENFILE	int
,	O
ENOBUFS	int
,	O
ENOMEM	int
,	O
ENOSPC	int
,	O
EROFS	int
,	O
ESTALE	int
,	O
ETIMEDOUT	int
,	O
EWOULDBLOCK	O
,	O
}	O
;	O
static	O
void	O
guess_retval	function
(	O
int	O
ec	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
exit_code	int
==	O
EX_TEMPFAIL	int
)	O
return	O
;	O
if	O
(	O
ec	int
==	O
EDQUOT	int
)	O
{	O
exit_code	int
=	O
EX_QUOTA	int
;	O
return	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
temp_errors	array
)	O
/	O
sizeof	O
(	O
temp_errors	array
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
temp_errors	array
[	O
i	int
]	O
==	O
ec	int
)	O
{	O
exit_code	int
=	O
EX_TEMPFAIL	int
;	O
return	O
;	O
}	O
exit_code	int
=	O
EX_UNAVAILABLE	int
;	O
}	O
void	O
mda_error	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
guess_retval	function
(	O
errno	O
)	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
mu_verror	function
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
static	O
struct	O
mu_cli_capa	struct
mda_cli_capa	array
[	O
]	O
=	O
{	O
{	O
"forward"	pointer
,	O
NULL	O
,	O
mda_forward_cfg	O
}	O
,	O
{	O
"deliver"	pointer
,	O
mda_deliver_options	pointer
,	O
mda_deliver_cfg	int
}	O
,	O
{	O
"quota"	pointer
,	O
NULL	O
,	O
mda_mailquota_cfg	int
}	O
,	O
{	O
"script"	pointer
,	O
mda_script_options	pointer
,	O
mda_script_cfg	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
void	O
mda_cli_capa_init	function
(	O
void	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
mda_cli_capa	array
[	O
i	long
]	O
.	O
name	pointer
;	O
i	long
++	O
)	O
mu_cli_capa_register	function
(	O
&	O
mda_cli_capa	array
[	O
i	int
]	O
)	O
;	O
}	O
static	O
void	O
set_stderr	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
mu_log_syslog	int
=	O
0	int
;	O
}	O
static	O
struct	O
mu_option	struct
mda_options	array
[	O
]	O
=	O
{	O
MU_OPTION_GROUP	function
(	O
N_	O
(	O
"General options"	pointer
)	O
)	O
,	O
{	O
"stderr"	pointer
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"log to standard error"	pointer
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
set_stderr	pointer
}	O
,	O
MU_OPTION_END	O
}	O
,	O
*	O
options	array
[	O
]	O
=	O
{	O
mda_options	pointer
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
capa	pointer
[	O
]	O
=	O
{	O
"auth"	pointer
,	O
"debug"	pointer
,	O
"logging"	pointer
,	O
"mailbox"	pointer
,	O
"locking"	pointer
,	O
"mailer"	pointer
,	O
"sieve"	pointer
,	O
"deliver"	pointer
,	O
"forward"	pointer
,	O
"quota"	pointer
,	O
"script"	pointer
,	O
NULL	O
}	O
;	O
static	O
int	O
cb_stderr	function
(	O
void	O
*	O
data	pointer
,	O
mu_config_value_t	struct
*	O
val	pointer
)	O
{	O
int	O
res	int
;	O
if	O
(	O
mu_cfg_assert_value_type	function
(	O
val	int
,	O
MU_CFG_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
mu_str_to_c	function
(	O
val	int
->	O
v	union
.	O
string	pointer
,	O
mu_c_bool	int
,	O
&	O
res	int
,	O
NULL	O
)	O
)	O
mu_error	function
(	O
_	O
(	O
"not a boolean"	pointer
)	O
)	O
;	O
else	O
mu_log_syslog	int
=	O
!	O
res	pointer
;	O
return	O
0	int
;	O
}	O
struct	O
mu_cfg_param	struct
mda_cfg_param	array
[	O
]	O
=	O
{	O
{	O
"stderr"	pointer
,	O
mu_cfg_callback	int
,	O
NULL	O
,	O
0	int
,	O
cb_stderr	pointer
,	O
N_	O
(	O
"Log to stderr instead of syslog."	pointer
)	O
,	O
N_	O
(	O
"arg: bool"	pointer
)	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
struct	O
mu_cli_setup	struct
cli	struct
=	O
{	O
options	array
,	O
mda_cfg_param	pointer
,	O
N_	O
(	O
"mda -- the GNU local mail delivery agent."	pointer
)	O
,	O
N_	O
(	O
"[recipient...]"	pointer
)	O
,	O
}	O
;	O
static	O
void	O
version_hook	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
mu_stream_t	pointer
stream	pointer
)	O
{	O
mu_version_hook	function
(	O
po	pointer
,	O
stream	pointer
)	O
;	O
mu_stream_printf	function
(	O
stream	pointer
,	O
"%s\n"	pointer
,	O
_	O
(	O
"THIS BINARY IS COMPILED ONLY FOR TESTING MAILUTILS."	pointer
"  DON'T USE IT IN PRODUCTION!"	pointer
)	O
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
struct	O
mu_parseopt	struct
pohint	pointer
;	O
struct	O
mu_cfg_parse_hints	struct
cfhint	struct
;	O
umask	function
(	O
0077	int
)	O
;	O
MU_APP_INIT_NLS	O
(	O
)	O
;	O
mu_locker_set_default_flags	function
(	O
MU_LOCKER_PID	int
|	O
MU_LOCKER_RETRY	int
,	O
mu_locker_assign	int
)	O
;	O
mu_locker_set_default_retry_timeout	function
(	O
1	int
)	O
;	O
mu_locker_set_default_retry_count	function
(	O
300	int
)	O
;	O
MU_AUTH_REGISTER_ALL_MODULES	O
(	O
)	O
;	O
mu_register_all_formats	O
(	O
)	O
;	O
mu_registrar_record	function
(	O
mu_smtp_record	int
)	O
;	O
mda_filter_cfg_init	function
(	O
)	O
;	O
mu_log_syslog	int
=	O
1	int
;	O
mu_log_print_severity	int
=	O
1	int
;	O
mda_cli_capa_init	function
(	O
)	O
;	O
pohint	struct
.	O
po_flags	int
=	O
0	int
;	O
pohint	struct
.	O
po_package_name	pointer
=	O
PACKAGE_NAME	pointer
;	O
pohint	struct
.	O
po_flags	int
|=	O
MU_PARSEOPT_PACKAGE_NAME	int
;	O
pohint	struct
.	O
po_package_url	int
=	O
PACKAGE_URL	int
;	O
pohint	struct
.	O
po_flags	int
|=	O
MU_PARSEOPT_PACKAGE_URL	int
;	O
pohint	struct
.	O
po_bug_address	pointer
=	O
PACKAGE_BUGREPORT	pointer
;	O
pohint	struct
.	O
po_flags	int
|=	O
MU_PARSEOPT_BUG_ADDRESS	int
;	O
pohint	struct
.	O
po_extra_info	int
=	O
mu_general_help_text	int
;	O
pohint	struct
.	O
po_flags	int
|=	O
MU_PARSEOPT_EXTRA_INFO	int
;	O
pohint	struct
.	O
po_version_hook	int
=	O
version_hook	int
;	O
pohint	struct
.	O
po_flags	int
|=	O
MU_PARSEOPT_VERSION_HOOK	int
;	O
pohint	struct
.	O
po_negation	int
=	O
"no-"	int
;	O
pohint	struct
.	O
po_flags	int
|=	O
MU_PARSEOPT_NEGATION	int
;	O
cfhint	struct
.	O
site_file	int
=	O
TESTSUITE_CONFIG_FILE	int
;	O
mu_log_syslog	int
=	O
0	int
;	O
cfhint	struct
.	O
flags	int
=	O
MU_CFHINT_SITE_FILE	int
|	O
MU_CFHINT_NO_CONFIG_OVERRIDE	int
;	O
mu_cli_ext	function
(	O
argc	int
,	O
argv	pointer
,	O
&	O
cli	struct
,	O
&	O
pohint	struct
,	O
&	O
cfhint	O
,	O
capa	pointer
,	O
NULL	O
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"recipients not given"	pointer
)	O
)	O
;	O
return	O
EX_USAGE	int
;	O
}	O
mu_stdstream_strerr_setup	function
(	O
mu_log_syslog	int
?	O
MU_STRERR_SYSLOG	int
:	O
MU_STRERR_STDERR	pointer
)	O
;	O
return	O
mda_run_delivery	function
(	O
mda_deliver_to_user	pointer
,	O
argc	int
,	O
argv	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
current_folder	pointer
=	O
NULL	O
;	O
int	O
rcpt_mask	int
=	O
RCPT_DEFAULT	int
;	O
int	O
mh_auto_install	int
=	O
1	int
;	O
mu_property_t	pointer
mh_read_property_file	function
(	O
char	O
*	O
name	pointer
,	O
int	O
ro	int
)	O
{	O
mu_property_t	pointer
prop	pointer
;	O
struct	O
mu_mh_prop	struct
*	O
mhprop	pointer
;	O
int	O
rc	int
;	O
mhprop	int
=	O
mu_zalloc	function
(	O
sizeof	O
(	O
mhprop	array
[	O
0	int
]	O
)	O
)	O
;	O
mhprop	pointer
->	O
filename	pointer
=	O
name	pointer
;	O
mhprop	pointer
->	O
ro	pointer
=	O
ro	pointer
;	O
rc	int
=	O
mu_property_create_init	function
(	O
&	O
prop	pointer
,	O
mu_mh_property_init	pointer
,	O
mhprop	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_create_init"	pointer
,	O
name	pointer
,	O
rc	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
prop	pointer
;	O
}	O
static	O
int	O
prop_merger	function
(	O
const	O
char	O
*	O
field	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
mu_property_t	pointer
dst	pointer
=	O
data	pointer
;	O
return	O
mu_property_set_value	function
(	O
dst	pointer
,	O
field	pointer
,	O
value	pointer
,	O
1	int
)	O
;	O
}	O
void	O
mh_property_merge	function
(	O
mu_property_t	pointer
dst	pointer
,	O
mu_property_t	pointer
src	pointer
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
!	O
src	pointer
)	O
return	O
;	O
rc	int
=	O
mu_mhprop_iterate	function
(	O
src	pointer
,	O
prop_merger	pointer
,	O
dst	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_mhprop_iterate"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
_mh_init_global_context	function
(	O
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
ctx_name	pointer
;	O
if	O
(	O
mu_mh_context	pointer
)	O
return	O
;	O
p	pointer
=	O
getenv	function
(	O
"CONTEXT"	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
p	pointer
=	O
MH_CONTEXT_FILE	pointer
;	O
ctx_name	pointer
=	O
mh_expand_name	function
(	O
NULL	O
,	O
p	pointer
,	O
NAME_ANY	pointer
)	O
;	O
mu_mh_context	pointer
=	O
mh_read_property_file	function
(	O
ctx_name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
current_folder	pointer
)	O
current_folder	pointer
=	O
mh_global_context_get	function
(	O
"Current-Folder"	pointer
,	O
mh_global_profile_get	function
(	O
"Inbox"	pointer
,	O
"inbox"	pointer
)	O
)	O
;	O
}	O
void	O
mh_read_profile	function
(	O
)	O
{	O
char	O
*	O
p	pointer
;	O
const	O
char	O
*	O
fallback	pointer
;	O
p	pointer
=	O
getenv	function
(	O
"MH"	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
p	pointer
=	O
mu_tilde_expansion	function
(	O
p	pointer
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
else	O
{	O
char	O
*	O
home	pointer
=	O
mu_get_homedir	function
(	O
)	O
;	O
if	O
(	O
!	O
home	pointer
)	O
abort	function
(	O
)	O
;	O
p	pointer
=	O
mh_safe_make_file_name	function
(	O
home	pointer
,	O
MH_USER_PROFILE	pointer
)	O
;	O
free	function
(	O
home	pointer
)	O
;	O
}	O
if	O
(	O
mh_auto_install	pointer
&&	O
access	function
(	O
p	pointer
,	O
R_OK	int
)	O
)	O
mh_install	function
(	O
p	pointer
,	O
1	int
)	O
;	O
mu_mh_profile	pointer
=	O
mh_read_property_file	function
(	O
p	pointer
,	O
0	int
)	O
;	O
mu_set_folder_directory	function
(	O
mh_get_dir	function
(	O
)	O
)	O
;	O
mh_set_reply_regex	function
(	O
mh_global_profile_get	function
(	O
"Reply-Regex"	pointer
,	O
NULL	O
)	O
)	O
;	O
fallback	pointer
=	O
mh_global_profile_get	function
(	O
"Decode-Fallback"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
fallback	int
&&	O
mu_set_default_fallback	function
(	O
fallback	pointer
)	O
)	O
mu_error	function
(	O
_	O
(	O
"Incorrect value for decode-fallback"	pointer
)	O
)	O
;	O
_mh_init_global_context	function
(	O
)	O
;	O
}	O
const	O
char	O
*	O
mh_current_folder	function
(	O
)	O
{	O
return	O
mh_global_context_get	function
(	O
"Current-Folder"	pointer
,	O
mh_global_profile_get	function
(	O
"Inbox"	pointer
,	O
"inbox"	pointer
)	O
)	O
;	O
}	O
const	O
char	O
*	O
mh_set_current_folder	function
(	O
const	O
char	O
*	O
val	pointer
)	O
{	O
int	O
rc	int
=	O
mh_global_context_set	function
(	O
"Current-Folder"	pointer
,	O
val	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mh_global_context_set"	pointer
,	O
"Current-Folder"	pointer
,	O
rc	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
current_folder	pointer
=	O
mh_current_folder	function
(	O
)	O
;	O
return	O
current_folder	pointer
;	O
}	O
mu_property_t	pointer
mh_mailbox_get_property	function
(	O
mu_mailbox_t	pointer
mbox	pointer
)	O
{	O
mu_property_t	pointer
prop	pointer
;	O
int	O
rc	int
=	O
mu_mailbox_get_property	function
(	O
mbox	pointer
,	O
&	O
prop	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_mailbox_get_property"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
prop	pointer
;	O
}	O
void	O
mh_global_sequences_drop	function
(	O
mu_mailbox_t	pointer
mbox	pointer
)	O
{	O
mu_property_t	pointer
prop	pointer
=	O
mh_mailbox_get_property	function
(	O
mbox	pointer
)	O
;	O
int	O
rc	int
=	O
mu_property_clear	function
(	O
prop	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_clear"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
const	O
char	O
*	O
mh_global_sequences_get	function
(	O
mu_mailbox_t	pointer
mbox	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
defval	pointer
)	O
{	O
mu_property_t	pointer
prop	pointer
=	O
mh_mailbox_get_property	function
(	O
mbox	pointer
)	O
;	O
const	O
char	O
*	O
s	pointer
;	O
int	O
rc	int
=	O
mu_property_sget_value	function
(	O
prop	pointer
,	O
name	pointer
,	O
&	O
s	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
s	pointer
=	O
defval	int
;	O
else	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_sget_value"	pointer
,	O
name	pointer
,	O
rc	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
s	pointer
;	O
}	O
void	O
mh_global_sequences_set	function
(	O
mu_mailbox_t	pointer
mbox	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
value	pointer
)	O
{	O
mu_property_t	pointer
prop	pointer
=	O
mh_mailbox_get_property	function
(	O
mbox	pointer
)	O
;	O
int	O
rc	int
=	O
mu_property_set_value	function
(	O
prop	pointer
,	O
name	pointer
,	O
value	pointer
,	O
1	int
)	O
;	O
if	O
(	O
rc	int
&&	O
!	O
(	O
!	O
value	pointer
&&	O
rc	int
==	O
MU_ERR_NOENT	O
)	O
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_set_value"	pointer
,	O
name	pointer
,	O
rc	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
mh_global_sequences_iterate	function
(	O
mu_mailbox_t	pointer
mbox	pointer
,	O
mu_mhprop_iterator_t	pointer
fp	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
rc	int
;	O
mu_iterator_t	pointer
itr	pointer
;	O
mu_property_t	pointer
prop	pointer
=	O
mh_mailbox_get_property	function
(	O
mbox	pointer
)	O
;	O
rc	int
=	O
mu_property_get_iterator	function
(	O
prop	pointer
,	O
&	O
itr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_get_iterator"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
mu_mhprop_iterate	function
(	O
prop	pointer
,	O
fp	pointer
,	O
data	pointer
)	O
;	O
}	O
void	O
mh_global_save_state	function
(	O
)	O
{	O
int	O
rc	int
;	O
mh_global_context_set	function
(	O
"Current-Folder"	pointer
,	O
current_folder	pointer
)	O
;	O
rc	int
=	O
mu_property_save	function
(	O
mu_mh_context	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_property_save"	pointer
,	O
"context"	pointer
,	O
rc	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
char	O
acl_docstring	array
[	O
]	O
=	O
N_	O
(	O
"test access control lists"	pointer
)	O
;	O
static	O
char	O
acl_args_doc	array
[	O
]	O
=	O
N_	O
(	O
"ADDRESS [ADDRESS...]"	pointer
)	O
;	O
static	O
char	O
*	O
input_file_name	pointer
;	O
static	O
struct	O
mu_sockaddr	struct
*	O
target_sa	pointer
;	O
static	O
mu_acl_t	pointer
acl	pointer
;	O
static	O
const	O
char	O
*	O
path	pointer
=	O
"acl"	pointer
;	O
static	O
struct	O
mu_option	struct
acl_options	array
[	O
]	O
=	O
{	O
{	O
"file"	pointer
,	O
'f'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"read ACLs from FILE"	pointer
)	O
,	O
mu_c_string	int
,	O
&	O
input_file_name	int
}	O
,	O
{	O
"path"	pointer
,	O
'p'	O
,	O
N_	O
(	O
"PATH"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"path to the ACL in the configuration tree"	pointer
)	O
,	O
mu_c_string	int
,	O
&	O
path	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
mu_cfg_param	struct
acl_cfg_param	array
[	O
]	O
=	O
{	O
{	O
"acl"	pointer
,	O
mu_cfg_section	int
,	O
&	O
acl	pointer
,	O
0	int
,	O
NULL	O
,	O
"access control list"	function
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
rc	int
;	O
mu_acl_result_t	enum
result	enum
;	O
mu_cfg_tree_t	struct
*	O
tree	pointer
=	O
NULL	O
,	O
*	O
temp_tree	pointer
=	O
NULL	O
;	O
mu_cfg_node_t	struct
*	O
node	pointer
;	O
struct	O
mu_cfg_parse_hints	struct
hints	pointer
;	O
mu_action_getopt	function
(	O
&	O
argc	long
,	O
&	O
argv	pointer
,	O
acl_options	pointer
,	O
acl_docstring	pointer
,	O
acl_args_doc	pointer
)	O
;	O
if	O
(	O
argc	long
==	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"not enough arguments"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
memset	function
(	O
&	O
hints	pointer
,	O
0	int
,	O
sizeof	O
(	O
hints	pointer
)	O
)	O
;	O
hints	pointer
.	O
flags	int
=	O
MU_CFHINT_CUSTOM_FILE	int
;	O
hints	pointer
.	O
custom_file	pointer
=	O
input_file_name	pointer
;	O
mu_acl_cfg_init	function
(	O
)	O
;	O
if	O
(	O
mu_cfg_parse_config	function
(	O
&	O
tree	pointer
,	O
&	O
hints	pointer
)	O
)	O
exit	function
(	O
EX_CONFIG	pointer
)	O
;	O
if	O
(	O
!	O
tree	pointer
)	O
return	O
0	int
;	O
if	O
(	O
mu_cfg_find_node	function
(	O
tree	pointer
,	O
path	pointer
,	O
&	O
node	pointer
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot find node: %s"	pointer
)	O
,	O
path	pointer
)	O
;	O
return	O
1	int
;	O
}	O
mu_cfg_tree_create	function
(	O
&	O
temp_tree	struct
)	O
;	O
mu_cfg_tree_add_node	function
(	O
temp_tree	pointer
,	O
node	pointer
)	O
;	O
rc	int
=	O
mu_cfg_tree_reduce	function
(	O
temp_tree	pointer
,	O
NULL	O
,	O
acl_cfg_param	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
1	int
;	O
if	O
(	O
!	O
acl	pointer
)	O
{	O
mu_error	function
(	O
_	O
(	O
"No ACL found in config"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
while	O
(	O
argc	int
--	O
)	O
{	O
const	O
char	O
*	O
ap	pointer
=	O
*	O
argv	pointer
++	O
;	O
rc	int
=	O
mu_sockaddr_from_node	function
(	O
&	O
target_sa	pointer
,	O
ap	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
"mu_sockaddr_from_node: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
mu_printf	function
(	O
"Testing %s:\n"	pointer
,	O
ap	pointer
)	O
;	O
rc	int
=	O
mu_acl_check_sockaddr	function
(	O
acl	pointer
,	O
target_sa	pointer
->	O
addr	int
,	O
target_sa	pointer
->	O
addrlen	int
,	O
&	O
result	pointer
)	O
;	O
mu_sockaddr_free_list	function
(	O
target_sa	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
"mu_acl_check_sockaddr failed: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
switch	O
(	O
result	pointer
)	O
{	O
case	O
mu_acl_result_undefined	int
:	O
mu_printf	function
(	O
"%s: undefined\n"	pointer
,	O
ap	pointer
)	O
;	O
break	O
;	O
case	O
mu_acl_result_accept	int
:	O
mu_printf	function
(	O
"%s: accept\n"	pointer
,	O
ap	pointer
)	O
;	O
break	O
;	O
case	O
mu_acl_result_deny	int
:	O
mu_printf	function
(	O
"%s: deny\n"	pointer
,	O
ap	pointer
)	O
;	O
break	O
;	O
}	O
}	O
mu_cfg_destroy_tree	function
(	O
&	O
tree	pointer
)	O
;	O
mu_cfg_destroy_tree	function
(	O
&	O
temp_tree	pointer
)	O
;	O
return	O
0	int
;	O
}	O
char	O
flt2047_docstring	array
[	O
]	O
=	O
N_	O
(	O
"decode/encode email message headers"	pointer
)	O
;	O
static	O
char	O
flt2047_args_doc	array
[	O
]	O
=	O
N_	O
(	O
"[text]"	pointer
)	O
;	O
static	O
int	O
decode_mode	int
=	O
0	int
;	O
static	O
int	O
newline_option	int
=	O
0	int
;	O
static	O
const	O
char	O
*	O
charset	pointer
=	O
"iso-8859-1"	pointer
;	O
static	O
const	O
char	O
*	O
encoding	pointer
=	O
"quoted-printable"	pointer
;	O
static	O
void	O
set_encode_mode	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
decode_mode	int
=	O
0	int
;	O
}	O
static	O
struct	O
mu_option	struct
flt2047_options	array
[	O
]	O
=	O
{	O
{	O
"encode"	pointer
,	O
'e'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"encode the input (default)"	pointer
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
set_encode_mode	function
}	O
,	O
{	O
"decode"	pointer
,	O
'd'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"decode the input"	pointer
)	O
,	O
mu_c_bool	int
,	O
&	O
decode_mode	int
}	O
,	O
{	O
"newline"	pointer
,	O
'n'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"print additional newline"	pointer
)	O
,	O
mu_c_bool	int
,	O
&	O
newline_option	int
}	O
,	O
{	O
"charset"	pointer
,	O
'c'	O
,	O
N_	O
(	O
"NAME"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set charset (default: iso-8859-1)"	pointer
)	O
,	O
mu_c_string	int
,	O
&	O
charset	pointer
}	O
,	O
{	O
"encoding"	pointer
,	O
'E'	O
,	O
N_	O
(	O
"NAME"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"set encoding (default: quoted-printable)"	pointer
)	O
,	O
mu_c_string	int
,	O
&	O
encoding	pointer
}	O
,	O
MU_OPTION_END	O
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
p	pointer
;	O
mu_action_getopt	function
(	O
&	O
argc	long
,	O
&	O
argv	pointer
,	O
flt2047_options	pointer
,	O
flt2047_docstring	pointer
,	O
flt2047_args_doc	pointer
)	O
;	O
if	O
(	O
argc	long
)	O
{	O
char	O
*	O
p	pointer
;	O
while	O
(	O
argc	long
--	O
)	O
{	O
const	O
char	O
*	O
text	pointer
=	O
*	O
argv	pointer
++	O
;	O
if	O
(	O
decode_mode	pointer
)	O
rc	int
=	O
mu_rfc2047_decode	function
(	O
charset	pointer
,	O
text	pointer
,	O
&	O
p	pointer
)	O
;	O
else	O
rc	int
=	O
mu_rfc2047_encode	function
(	O
charset	pointer
,	O
encoding	pointer
,	O
text	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
"%s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mu_printf	function
(	O
"%s\n"	pointer
,	O
p	pointer
)	O
;	O
}	O
}	O
else	O
{	O
size_t	long
size	long
=	O
0	int
,	O
n	long
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
rc	int
=	O
mu_stream_getline	function
(	O
mu_strin	pointer
,	O
&	O
buf	pointer
,	O
&	O
size	long
,	O
&	O
n	long
)	O
)	O
==	O
0	int
&&	O
n	long
>	O
0	int
)	O
{	O
mu_rtrim_class	function
(	O
buf	pointer
,	O
MU_CTYPE_SPACE	int
)	O
;	O
if	O
(	O
decode_mode	int
)	O
rc	int
=	O
mu_rfc2047_decode	function
(	O
charset	pointer
,	O
buf	pointer
,	O
&	O
p	pointer
)	O
;	O
else	O
rc	int
=	O
mu_rfc2047_encode	function
(	O
charset	pointer
,	O
encoding	pointer
,	O
buf	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
"%s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mu_printf	function
(	O
"%s\n"	pointer
,	O
p	pointer
)	O
;	O
}	O
}	O
mu_stream_flush	function
(	O
mu_strout	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
describe	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
unused	pointer
)	O
{	O
int	O
len	int
=	O
strcspn	function
(	O
po	pointer
->	O
po_prog_doc	pointer
,	O
"\n"	pointer
)	O
;	O
mu_printf	function
(	O
"%.*s\n"	pointer
,	O
len	int
,	O
po	pointer
->	O
po_prog_doc	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
struct	O
mu_option	struct
common_options	array
[	O
]	O
=	O
{	O
{	O
"describe"	pointer
,	O
0	int
,	O
NULL	O
,	O
MU_OPTION_HIDDEN	pointer
,	O
"describe the program"	pointer
,	O
mu_c_string	int
,	O
NULL	O
,	O
describe	int
}	O
,	O
MU_OPTION_END	O
}	O
;	O
void	O
mu_action_getopt	function
(	O
int	O
*	O
pargc	pointer
,	O
char	O
*	O
*	O
*	O
pargv	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
docstring	pointer
,	O
char	O
const	O
*	O
argdoc	pointer
)	O
{	O
static	O
struct	O
mu_parseopt	struct
pohint	struct
=	O
{	O
.	O
po_flags	int
=	O
MU_PARSEOPT_PACKAGE_NAME	int
|	O
MU_PARSEOPT_PACKAGE_URL	int
|	O
MU_PARSEOPT_BUG_ADDRESS	int
|	O
MU_PARSEOPT_VERSION_HOOK	int
,	O
.	O
po_package_name	pointer
=	O
PACKAGE_NAME	pointer
,	O
.	O
po_package_url	pointer
=	O
PACKAGE_URL	pointer
,	O
.	O
po_bug_address	pointer
=	O
PACKAGE_BUGREPORT	pointer
,	O
.	O
po_version_hook	pointer
=	O
mu_version_hook	int
}	O
;	O
static	O
char	O
*	O
defcapa	array
[	O
]	O
=	O
{	O
"debug"	pointer
,	O
NULL	O
}	O
;	O
struct	O
mu_cfg_parse_hints	struct
cfhint	struct
=	O
{	O
.	O
flags	int
=	O
0	int
}	O
;	O
struct	O
mu_option	struct
*	O
options	array
[	O
3	int
]	O
=	O
{	O
common_options	pointer
,	O
opt	pointer
,	O
NULL	O
}	O
;	O
struct	O
mu_cli_setup	struct
cli	struct
=	O
{	O
.	O
prog_doc	pointer
=	O
(	O
char	O
*	O
)	O
docstring	pointer
,	O
.	O
prog_args	pointer
=	O
(	O
char	O
*	O
)	O
argdoc	pointer
,	O
.	O
optv	pointer
=	O
options	pointer
}	O
;	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
getenv	function
(	O
"MAILUTILS_PROGNAME"	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
pohint	struct
.	O
po_flags	int
|=	O
MU_PARSEOPT_PROG_NAME	int
;	O
pohint	struct
.	O
po_prog_name	pointer
=	O
p	pointer
;	O
}	O
MU_APP_INIT_NLS	O
(	O
)	O
;	O
mu_cli_ext	function
(	O
*	O
pargc	pointer
,	O
*	O
pargv	pointer
,	O
&	O
cli	struct
,	O
&	O
pohint	O
,	O
&	O
cfhint	O
,	O
defcapa	pointer
,	O
NULL	O
,	O
pargc	pointer
,	O
pargv	pointer
)	O
;	O
}	O
static	O
char	O
info_doc	array
[	O
]	O
=	O
N_	O
(	O
"show Mailutils configuration"	pointer
)	O
;	O
static	O
char	O
info_args_doc	array
[	O
]	O
=	O
N_	O
(	O
"[capa...]"	pointer
)	O
;	O
static	O
int	O
verbose	int
;	O
static	O
struct	O
mu_option	struct
info_options	array
[	O
]	O
=	O
{	O
{	O
"verbose"	pointer
,	O
'v'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"increase output verbosity"	pointer
)	O
,	O
mu_c_bool	int
,	O
&	O
verbose	int
}	O
,	O
MU_OPTION_END	O
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_action_getopt	function
(	O
&	O
argc	long
,	O
&	O
argv	pointer
,	O
info_options	pointer
,	O
info_doc	pointer
,	O
info_args_doc	pointer
)	O
;	O
if	O
(	O
argc	long
==	O
0	int
)	O
mu_format_options	function
(	O
mu_strout	pointer
,	O
verbose	int
)	O
;	O
else	O
{	O
int	O
i	int
,	O
found	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
const	O
struct	O
mu_conf_option	struct
*	O
opt	pointer
=	O
mu_check_option	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
opt	pointer
)	O
{	O
found	int
++	O
;	O
mu_format_conf_option	function
(	O
mu_strout	pointer
,	O
opt	pointer
,	O
verbose	int
)	O
;	O
}	O
}	O
return	O
found	int
==	O
argc	int
?	O
0	int
:	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
char	O
wicket_docstring	array
[	O
]	O
=	O
N_	O
(	O
"scan wickets for matching URLs"	pointer
)	O
;	O
static	O
char	O
wicket_args_doc	array
[	O
]	O
=	O
N_	O
(	O
"URL"	pointer
)	O
;	O
static	O
char	O
*	O
wicket_file	pointer
=	O
"~/.mu-tickets"	pointer
;	O
static	O
int	O
wicket_verbose	int
=	O
1	int
;	O
static	O
void	O
clear_wicket_verbose	function
(	O
struct	O
mu_parseopt	struct
*	O
po	pointer
,	O
struct	O
mu_option	struct
*	O
opt	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
wicket_verbose	int
=	O
0	int
;	O
}	O
static	O
struct	O
mu_option	struct
wicket_options	array
[	O
]	O
=	O
{	O
{	O
"file"	pointer
,	O
'f'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"use FILE instead of ~/.mu-tickets"	pointer
)	O
,	O
mu_c_string	int
,	O
&	O
wicket_file	int
}	O
,	O
{	O
"verbose"	pointer
,	O
'v'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"increase output verbosity"	pointer
)	O
,	O
mu_c_string	int
,	O
&	O
wicket_verbose	int
}	O
,	O
{	O
"quiet"	pointer
,	O
'q'	O
,	O
NULL	O
,	O
MU_OPTION_DEFAULT	int
,	O
N_	O
(	O
"suppress any output"	pointer
)	O
,	O
mu_c_string	int
,	O
NULL	O
,	O
clear_wicket_verbose	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
wicket_match	function
(	O
mu_stream_t	pointer
stream	pointer
,	O
const	O
char	O
*	O
str	pointer
)	O
{	O
int	O
rc	int
,	O
ret	int
;	O
mu_url_t	pointer
u	pointer
,	O
url	pointer
;	O
struct	O
mu_locus_point	struct
loc	struct
;	O
int	O
flags	int
=	O
MU_URL_PARSE_ALL	O
;	O
if	O
(	O
wicket_verbose	int
>	O
2	int
)	O
flags	int
&=	O
~	O
MU_URL_PARSE_HIDEPASS	int
;	O
rc	int
=	O
mu_url_create	function
(	O
&	O
u	pointer
,	O
str	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_url_create"	pointer
,	O
str	pointer
,	O
rc	int
)	O
;	O
return	O
2	int
;	O
}	O
rc	int
=	O
mu_stream_seek	function
(	O
stream	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_stream_seek"	pointer
,	O
"0"	pointer
,	O
rc	int
)	O
;	O
return	O
2	int
;	O
}	O
loc	pointer
.	O
mu_file	pointer
=	O
wicket_file	pointer
;	O
loc	struct
.	O
mu_line	int
=	O
0	int
;	O
rc	int
=	O
mu_wicket_stream_match_url	function
(	O
stream	pointer
,	O
&	O
loc	pointer
,	O
u	pointer
,	O
flags	int
,	O
&	O
url	pointer
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
ret	int
=	O
0	int
;	O
if	O
(	O
wicket_verbose	pointer
)	O
{	O
mu_printf	function
(	O
"%s: %s:%d"	pointer
,	O
str	pointer
,	O
loc	pointer
.	O
mu_file	pointer
,	O
loc	pointer
.	O
mu_line	int
)	O
;	O
if	O
(	O
wicket_verbose	int
>	O
1	int
)	O
mu_printf	function
(	O
": %s"	pointer
,	O
mu_url_to_string	function
(	O
url	pointer
)	O
)	O
;	O
mu_printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
MU_ERR_NOENT	O
:	O
if	O
(	O
wicket_verbose	int
)	O
mu_printf	function
(	O
"%s: %s\n"	pointer
,	O
str	pointer
,	O
_	O
(	O
"not found"	pointer
)	O
)	O
;	O
ret	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_wicket_stream_match_url"	pointer
,	O
str	pointer
,	O
rc	int
)	O
;	O
ret	int
=	O
2	int
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
mu_stream_t	pointer
stream	pointer
;	O
int	O
rc	int
,	O
i	int
,	O
exit_code	int
;	O
mu_action_getopt	function
(	O
&	O
argc	long
,	O
&	O
argv	pointer
,	O
wicket_options	pointer
,	O
wicket_docstring	pointer
,	O
wicket_args_doc	pointer
)	O
;	O
if	O
(	O
argc	long
==	O
0	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"not enough arguments"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
wicket_file	pointer
=	O
mu_tilde_expansion	function
(	O
wicket_file	pointer
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
wicket_file	pointer
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_tilde_expansion"	pointer
,	O
wicket_file	pointer
,	O
ENOMEM	int
)	O
;	O
return	O
2	int
;	O
}	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
stream	pointer
,	O
wicket_file	pointer
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot open input file %s: %s"	pointer
)	O
,	O
wicket_file	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
exit_code	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
rc	int
=	O
wicket_match	function
(	O
stream	pointer
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
exit_code	int
<	O
rc	int
)	O
exit_code	int
=	O
rc	int
;	O
if	O
(	O
!	O
wicket_verbose	pointer
)	O
break	O
;	O
}	O
}	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
return	O
exit_code	pointer
;	O
}	O
static	O
struct	O
PyModuleDef	O
moduledef	struct
=	O
{	O
PyModuleDef_HEAD_INIT	O
,	O
PY_MODULE	pointer
,	O
NULL	O
,	O
-	O
1	int
,	O
NULL	O
}	O
;	O
void	O
_mu_py_attach_errno	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
PyObject	O
*	O
module	O
=	O
_mu_py_attach_module	function
(	O
&	O
moduledef	struct
)	O
;	O
for	O
(	O
i	int
=	O
MU_ERR_BASE	O
;	O
i	int
<	O
MU_ERR_LAST	O
;	O
i	int
++	O
)	O
{	O
const	O
char	O
*	O
en	pointer
=	O
mu_errname	function
(	O
i	int
)	O
;	O
PyModule_AddIntConstant	function
(	O
module	O
,	O
en	pointer
,	O
i	int
)	O
;	O
}	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
rc	int
;	O
mu_mailbox_t	pointer
mbox	pointer
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: %s URL\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
mu_register_all_mbox_formats	O
(	O
)	O
;	O
MU_ASSERT	O
(	O
mu_mailbox_create	function
(	O
&	O
mbox	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
)	O
;	O
rc	int
=	O
mu_mailbox_remove	function
(	O
mbox	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
if	O
(	O
rc	int
==	O
ENOTEMPTY	int
)	O
{	O
printf	function
(	O
"mailbox removed, but has subfolders\n"	pointer
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
mu_mailbox_destroy	function
(	O
&	O
mbox	pointer
)	O
;	O
return	O
rc	int
!=	O
0	int
;	O
}	O
char	O
*	O
concatenated_filename	function
(	O
const	O
char	O
*	O
directory	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
suffix	pointer
)	O
{	O
char	O
*	O
result	pointer
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
strcmp	function
(	O
directory	pointer
,	O
"."	pointer
)	O
==	O
0	int
)	O
{	O
result	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
filename	pointer
)	O
+	O
(	O
suffix	pointer
!=	O
NULL	O
?	O
strlen	function
(	O
suffix	pointer
)	O
:	O
0	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
result	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
p	O
=	O
result	O
;	O
}	O
else	O
{	O
size_t	long
directory_len	long
=	O
strlen	function
(	O
directory	pointer
)	O
;	O
int	O
need_slash	int
=	O
(	O
directory_len	long
>	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
directory	pointer
)	O
&&	O
!	O
ISSLASH	O
(	O
directory	pointer
[	O
directory_len	long
-	O
1	int
]	O
)	O
)	O
;	O
result	O
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
directory_len	long
+	O
need_slash	int
+	O
strlen	function
(	O
filename	pointer
)	O
+	O
(	O
suffix	pointer
!=	O
NULL	O
?	O
strlen	function
(	O
suffix	pointer
)	O
:	O
0	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
result	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
result	pointer
,	O
directory	pointer
,	O
directory_len	long
)	O
;	O
p	pointer
=	O
result	O
+	O
directory_len	long
;	O
if	O
(	O
need_slash	O
)	O
*	O
p	pointer
++	O
=	O
'/'	O
;	O
}	O
p	pointer
=	O
stpcpy	function
(	O
p	O
,	O
filename	pointer
)	O
;	O
if	O
(	O
suffix	pointer
!=	O
NULL	O
)	O
stpcpy	function
(	O
p	O
,	O
suffix	O
)	O
;	O
return	O
result	O
;	O
}	O
bool	bool
strip_trailing_slashes	function
(	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
base	pointer
=	O
last_component	function
(	O
file	pointer
)	O
;	O
char	O
*	O
base_lim	pointer
;	O
bool	bool
had_slash	bool
;	O
if	O
(	O
!	O
*	O
base	pointer
)	O
base	pointer
=	O
file	pointer
;	O
base_lim	pointer
=	O
base	pointer
+	O
base_len	function
(	O
base	pointer
)	O
;	O
had_slash	bool
=	O
(	O
*	O
base_lim	pointer
!=	O
'\0'	O
)	O
;	O
*	O
base_lim	pointer
=	O
'\0'	O
;	O
return	O
had_slash	bool
;	O
}	O
static	O
inline	O
struct	O
_book_mark	struct
*	O
double_marks	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
struct	O
_book_mark	struct
*	O
p	pointer
)	O
{	O
(	O
void	O
)	O
edit	O
;	O
if	O
(	O
p	pointer
->	O
next	pointer
)	O
while	O
(	O
p	pointer
->	O
next	pointer
->	O
line	pointer
==	O
p	pointer
->	O
line	pointer
)	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
return	O
p	pointer
;	O
}	O
struct	O
_book_mark	struct
*	O
book_mark_find	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
line	int
)	O
{	O
struct	O
_book_mark	struct
*	O
p	pointer
;	O
if	O
(	O
!	O
edit	pointer
->	O
book_mark	int
)	O
{	O
edit	pointer
->	O
book_mark	pointer
=	O
g_malloc0	function
(	O
sizeof	O
(	O
struct	O
_book_mark	struct
)	O
)	O
;	O
edit	pointer
->	O
book_mark	pointer
->	O
line	int
=	O
-	O
1	int
;	O
return	O
edit	pointer
->	O
book_mark	int
;	O
}	O
for	O
(	O
p	pointer
=	O
edit	pointer
->	O
book_mark	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
line	int
>	O
line	pointer
)	O
break	O
;	O
if	O
(	O
p	pointer
->	O
line	int
<=	O
line	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
next	pointer
->	O
line	array
>	O
line	array
)	O
{	O
edit	pointer
->	O
book_mark	pointer
=	O
p	pointer
;	O
return	O
double_marks	function
(	O
edit	pointer
,	O
p	pointer
)	O
;	O
}	O
}	O
else	O
{	O
edit	pointer
->	O
book_mark	pointer
=	O
p	pointer
;	O
return	O
double_marks	function
(	O
edit	pointer
,	O
p	pointer
)	O
;	O
}	O
}	O
}	O
for	O
(	O
p	pointer
=	O
edit	pointer
->	O
book_mark	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
prev	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
p	pointer
->	O
next	pointer
->	O
line	pointer
<=	O
line	pointer
)	O
break	O
;	O
if	O
(	O
p	pointer
->	O
line	int
<=	O
line	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
next	pointer
->	O
line	array
>	O
line	array
)	O
{	O
edit	pointer
->	O
book_mark	pointer
=	O
p	pointer
;	O
return	O
double_marks	function
(	O
edit	pointer
,	O
p	pointer
)	O
;	O
}	O
}	O
else	O
{	O
edit	pointer
->	O
book_mark	pointer
=	O
p	pointer
;	O
return	O
double_marks	function
(	O
edit	pointer
,	O
p	pointer
)	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
book_mark_query_color	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
line	int
,	O
int	O
c	int
)	O
{	O
struct	O
_book_mark	struct
*	O
p	pointer
;	O
if	O
(	O
!	O
edit	pointer
->	O
book_mark	pointer
)	O
return	O
0	int
;	O
for	O
(	O
p	pointer
=	O
book_mark_find	function
(	O
edit	pointer
,	O
line	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
prev	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
line	int
!=	O
line	pointer
)	O
return	O
0	int
;	O
if	O
(	O
p	pointer
->	O
c	int
==	O
c	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
book_mark_insert	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
line	int
,	O
int	O
c	int
)	O
{	O
struct	O
_book_mark	struct
*	O
p	pointer
,	O
*	O
q	pointer
;	O
p	pointer
=	O
book_mark_find	function
(	O
edit	pointer
,	O
line	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_LINE	int
;	O
q	int
=	O
g_malloc0	function
(	O
sizeof	O
(	O
struct	O
_book_mark	struct
)	O
)	O
;	O
q	pointer
->	O
line	pointer
=	O
line	pointer
;	O
q	pointer
->	O
c	int
=	O
c	int
;	O
q	pointer
->	O
next	pointer
=	O
p	pointer
->	O
next	pointer
;	O
q	pointer
->	O
prev	pointer
=	O
p	pointer
;	O
if	O
(	O
p	pointer
->	O
next	pointer
)	O
p	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
q	pointer
;	O
p	pointer
->	O
next	pointer
=	O
q	pointer
;	O
}	O
int	O
book_mark_clear	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
line	int
,	O
int	O
c	int
)	O
{	O
struct	O
_book_mark	struct
*	O
p	pointer
,	O
*	O
q	pointer
;	O
int	O
r	int
=	O
1	int
;	O
if	O
(	O
!	O
edit	pointer
->	O
book_mark	pointer
)	O
return	O
r	int
;	O
for	O
(	O
p	pointer
=	O
book_mark_find	function
(	O
edit	pointer
,	O
line	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
q	pointer
)	O
{	O
q	pointer
=	O
p	pointer
->	O
prev	pointer
;	O
if	O
(	O
p	pointer
->	O
line	int
==	O
line	pointer
&&	O
(	O
p	pointer
->	O
c	int
==	O
c	int
||	O
c	int
==	O
-	O
1	int
)	O
)	O
{	O
r	int
=	O
0	int
;	O
edit	pointer
->	O
force	enum
|=	O
REDRAW_LINE	int
;	O
edit	pointer
->	O
book_mark	pointer
=	O
p	pointer
->	O
prev	pointer
;	O
p	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
p	pointer
->	O
next	pointer
;	O
if	O
(	O
p	pointer
->	O
next	pointer
)	O
p	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
p	pointer
->	O
prev	pointer
;	O
g_free	function
(	O
p	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
edit	pointer
->	O
book_mark	pointer
->	O
line	int
==	O
-	O
1	int
&&	O
!	O
edit	pointer
->	O
book_mark	pointer
->	O
next	pointer
)	O
{	O
g_free	function
(	O
edit	pointer
->	O
book_mark	pointer
)	O
;	O
edit	pointer
->	O
book_mark	int
=	O
0	int
;	O
}	O
return	O
r	pointer
;	O
}	O
void	O
book_mark_flush	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
c	int
)	O
{	O
struct	O
_book_mark	struct
*	O
p	pointer
,	O
*	O
q	pointer
;	O
if	O
(	O
!	O
edit	pointer
->	O
book_mark	pointer
)	O
return	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	int
;	O
while	O
(	O
edit	pointer
->	O
book_mark	pointer
->	O
prev	pointer
)	O
edit	pointer
->	O
book_mark	pointer
=	O
edit	pointer
->	O
book_mark	pointer
->	O
prev	pointer
;	O
for	O
(	O
q	pointer
=	O
edit	pointer
->	O
book_mark	pointer
->	O
next	pointer
;	O
q	pointer
;	O
q	pointer
=	O
p	pointer
)	O
{	O
p	pointer
=	O
q	pointer
->	O
next	pointer
;	O
if	O
(	O
q	pointer
->	O
c	char
==	O
c	int
||	O
c	int
==	O
-	O
1	int
)	O
{	O
q	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
q	pointer
->	O
next	pointer
;	O
if	O
(	O
p	pointer
)	O
p	pointer
->	O
prev	pointer
=	O
q	pointer
->	O
prev	pointer
;	O
g_free	function
(	O
q	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
edit	pointer
->	O
book_mark	pointer
->	O
next	pointer
)	O
{	O
g_free	function
(	O
edit	pointer
->	O
book_mark	pointer
)	O
;	O
edit	pointer
->	O
book_mark	int
=	O
0	int
;	O
}	O
}	O
void	O
book_mark_inc	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
line	int
)	O
{	O
if	O
(	O
edit	pointer
->	O
book_mark	pointer
)	O
{	O
struct	O
_book_mark	struct
*	O
p	pointer
;	O
p	pointer
=	O
book_mark_find	function
(	O
edit	pointer
,	O
line	int
)	O
;	O
for	O
(	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
p	pointer
->	O
line	array
++	O
;	O
}	O
}	O
}	O
void	O
book_mark_dec	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
line	int
)	O
{	O
if	O
(	O
edit	pointer
->	O
book_mark	pointer
)	O
{	O
struct	O
_book_mark	struct
*	O
p	pointer
;	O
p	pointer
=	O
book_mark_find	function
(	O
edit	pointer
,	O
line	int
)	O
;	O
for	O
(	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
p	pointer
->	O
line	array
--	O
;	O
}	O
}	O
}	O
static	O
char	O
*	O
get_absolute_name	function
(	O
const	O
char	O
*	O
file	pointer
)	O
{	O
char	O
dir	pointer
[	O
MC_MAXPATHLEN	int
]	O
;	O
if	O
(	O
file	pointer
[	O
0	int
]	O
==	O
PATH_SEP	int
)	O
return	O
g_strdup	function
(	O
file	pointer
)	O
;	O
mc_get_current_wd	function
(	O
dir	pointer
,	O
MC_MAXPATHLEN	pointer
)	O
;	O
return	O
concat_dir_and_file	function
(	O
dir	pointer
,	O
file	pointer
)	O
;	O
}	O
static	O
int	O
my_mkdir_rec	function
(	O
char	O
*	O
s	pointer
,	O
mode_t	int
mode	int
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
int	O
result	int
;	O
if	O
(	O
!	O
mc_mkdir	function
(	O
s	int
,	O
mode	int
)	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
vfs_file_is_local	function
(	O
s	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
PATH_SEP_STR	pointer
)	O
)	O
{	O
errno	O
=	O
ENOTDIR	int
;	O
return	O
-	O
1	int
;	O
}	O
p	pointer
=	O
concat_dir_and_file	function
(	O
s	pointer
,	O
".."	pointer
)	O
;	O
q	pointer
=	O
vfs_canon	function
(	O
p	pointer
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
if	O
(	O
!	O
(	O
result	int
=	O
my_mkdir_rec	function
(	O
q	int
,	O
mode	int
)	O
)	O
)	O
result	pointer
=	O
mc_mkdir	function
(	O
s	pointer
,	O
mode	int
)	O
;	O
g_free	function
(	O
q	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
int	O
my_mkdir	function
(	O
const	O
char	O
*	O
s	pointer
,	O
mode_t	int
mode	int
)	O
{	O
int	O
result	int
;	O
char	O
*	O
my_s	pointer
;	O
result	pointer
=	O
mc_mkdir	function
(	O
s	int
,	O
mode	int
)	O
;	O
if	O
(	O
result	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
vfs_canon	function
(	O
s	int
)	O
;	O
result	pointer
=	O
my_mkdir_rec	function
(	O
p	int
,	O
mode	int
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
if	O
(	O
result	pointer
==	O
0	int
)	O
{	O
my_s	pointer
=	O
get_absolute_name	function
(	O
s	pointer
)	O
;	O
g_free	function
(	O
my_s	pointer
)	O
;	O
}	O
return	O
result	pointer
;	O
}	O
int	O
my_rmdir	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
int	O
result	int
;	O
char	O
*	O
my_s	pointer
;	O
result	pointer
=	O
mc_rmdir	function
(	O
s	pointer
)	O
;	O
if	O
(	O
result	pointer
==	O
0	int
)	O
{	O
my_s	pointer
=	O
get_absolute_name	function
(	O
s	pointer
)	O
;	O
g_free	function
(	O
my_s	pointer
)	O
;	O
}	O
return	O
result	pointer
;	O
}	O
static	O
gboolean	int
is_logging_enabled	function
(	O
void	O
)	O
{	O
static	O
gboolean	int
logging_initialized	int
=	O
FALSE	O
;	O
static	O
gboolean	int
logging_enabled	int
=	O
FALSE	int
;	O
char	O
*	O
mc_ini	pointer
;	O
if	O
(	O
!	O
logging_initialized	pointer
)	O
{	O
mc_ini	pointer
=	O
g_strdup_printf	function
(	O
"%s/%s"	pointer
,	O
home_dir	pointer
,	O
PROFILE_NAME	pointer
)	O
;	O
logging_enabled	pointer
=	O
get_int	function
(	O
mc_ini	pointer
,	O
"development.enable_logging"	pointer
,	O
FALSE	O
)	O
;	O
g_free	function
(	O
mc_ini	pointer
)	O
;	O
logging_initialized	int
=	O
TRUE	O
;	O
}	O
return	O
logging_enabled	int
;	O
}	O
void	O
mc_log	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
FILE	struct
*	O
f	pointer
;	O
char	O
*	O
logfilename	pointer
;	O
if	O
(	O
is_logging_enabled	function
(	O
)	O
)	O
{	O
va_start	O
(	O
args	array
,	O
fmt	pointer
)	O
;	O
logfilename	pointer
=	O
g_strdup_printf	function
(	O
"%s/.mc/log"	pointer
,	O
home_dir	pointer
)	O
;	O
if	O
(	O
(	O
f	pointer
=	O
fopen	function
(	O
logfilename	pointer
,	O
"a"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
(	O
void	O
)	O
vfprintf	function
(	O
f	pointer
,	O
fmt	pointer
,	O
args	array
)	O
;	O
(	O
void	O
)	O
fclose	function
(	O
f	pointer
)	O
;	O
}	O
g_free	function
(	O
logfilename	pointer
)	O
;	O
}	O
}	O
struct	O
mount_entry	struct
{	O
char	O
*	O
me_devname	pointer
;	O
char	O
*	O
me_mountdir	pointer
;	O
char	O
*	O
me_type	pointer
;	O
dev_t	long
me_dev	long
;	O
struct	O
mount_entry	struct
*	O
me_next	pointer
;	O
}	O
;	O
struct	O
fs_usage	struct
{	O
long	O
fsu_blocks	long
;	O
long	O
fsu_bfree	long
;	O
long	O
fsu_bavail	long
;	O
long	O
fsu_files	long
;	O
long	O
fsu_ffree	long
;	O
}	O
;	O
static	O
int	O
get_fs_usage	function
(	O
char	O
*	O
path	pointer
,	O
struct	O
fs_usage	struct
*	O
fsp	pointer
)	O
;	O
static	O
struct	O
mount_entry	struct
*	O
mount_list	pointer
=	O
NULL	O
;	O
static	O
int	O
xatoi	function
(	O
const	O
char	O
*	O
cp	pointer
)	O
{	O
int	O
val	int
;	O
val	long
=	O
0	int
;	O
while	O
(	O
*	O
cp	pointer
)	O
{	O
if	O
(	O
*	O
cp	pointer
>=	O
'a'	O
&&	O
*	O
cp	pointer
<=	O
'f'	O
)	O
val	double
=	O
val	double
*	O
16	int
+	O
*	O
cp	pointer
-	O
'a'	O
+	O
10	int
;	O
else	O
if	O
(	O
*	O
cp	pointer
>=	O
'A'	O
&&	O
*	O
cp	pointer
<=	O
'F'	O
)	O
val	int
=	O
val	double
*	O
16	int
+	O
*	O
cp	pointer
-	O
'A'	O
+	O
10	int
;	O
else	O
if	O
(	O
*	O
cp	pointer
>=	O
'0'	O
&&	O
*	O
cp	pointer
<=	O
'9'	O
)	O
val	int
=	O
val	double
*	O
16	int
+	O
*	O
cp	pointer
-	O
'0'	O
;	O
else	O
break	O
;	O
cp	pointer
++	O
;	O
}	O
return	O
val	enum
;	O
}	O
static	O
struct	O
mount_entry	struct
*	O
read_filesystem_list	function
(	O
int	O
need_fs_type	int
,	O
int	O
all_fs	int
)	O
{	O
struct	O
mount_entry	struct
*	O
mlist	pointer
;	O
struct	O
mount_entry	struct
*	O
me	pointer
;	O
struct	O
mount_entry	struct
*	O
mtail	pointer
;	O
(	O
void	O
)	O
need_fs_type	bool
;	O
(	O
void	O
)	O
all_fs	pointer
;	O
me	pointer
=	O
(	O
struct	O
mount_entry	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
mount_entry	struct
)	O
)	O
;	O
me	pointer
->	O
me_next	pointer
=	O
NULL	O
;	O
mlist	pointer
=	O
mtail	pointer
=	O
me	pointer
;	O
{	O
struct	O
mntent	struct
*	O
mnt	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
const	O
char	O
*	O
devopt	pointer
;	O
fp	pointer
=	O
setmntent	function
(	O
MOUNTED	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
while	O
(	O
(	O
mnt	pointer
=	O
getmntent	function
(	O
fp	pointer
)	O
)	O
)	O
{	O
if	O
(	O
!	O
all_fs	pointer
&&	O
(	O
!	O
strcmp	function
(	O
mnt	pointer
->	O
mnt_type	pointer
,	O
"ignore"	pointer
)	O
||	O
!	O
strcmp	function
(	O
mnt	pointer
->	O
mnt_type	pointer
,	O
"auto"	pointer
)	O
)	O
)	O
continue	O
;	O
me	pointer
=	O
(	O
struct	O
mount_entry	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
mount_entry	struct
)	O
)	O
;	O
me	pointer
->	O
me_devname	pointer
=	O
strdup	function
(	O
mnt	pointer
->	O
mnt_fsname	pointer
)	O
;	O
me	pointer
->	O
me_mountdir	pointer
=	O
strdup	function
(	O
mnt	pointer
->	O
mnt_dir	pointer
)	O
;	O
me	pointer
->	O
me_type	pointer
=	O
strdup	function
(	O
mnt	pointer
->	O
mnt_type	pointer
)	O
;	O
devopt	pointer
=	O
strstr	function
(	O
mnt	pointer
->	O
mnt_opts	pointer
,	O
"dev="	pointer
)	O
;	O
if	O
(	O
devopt	pointer
)	O
{	O
if	O
(	O
devopt	pointer
[	O
4	int
]	O
==	O
'0'	O
&&	O
(	O
devopt	pointer
[	O
5	int
]	O
==	O
'x'	O
||	O
devopt	pointer
[	O
5	int
]	O
==	O
'X'	O
)	O
)	O
me	pointer
->	O
me_dev	long
=	O
xatoi	function
(	O
devopt	pointer
+	O
6	int
)	O
;	O
else	O
me	pointer
->	O
me_dev	long
=	O
xatoi	function
(	O
devopt	pointer
+	O
4	int
)	O
;	O
}	O
else	O
me	pointer
->	O
me_dev	long
=	O
-	O
1	int
;	O
me	pointer
->	O
me_next	pointer
=	O
NULL	O
;	O
mtail	pointer
->	O
me_next	pointer
=	O
me	pointer
;	O
mtail	pointer
=	O
me	pointer
;	O
}	O
if	O
(	O
endmntent	function
(	O
fp	pointer
)	O
==	O
0	int
)	O
return	O
NULL	O
;	O
}	O
me	pointer
=	O
mlist	pointer
;	O
mlist	pointer
=	O
mlist	pointer
->	O
me_next	pointer
;	O
free	function
(	O
me	pointer
)	O
;	O
return	O
mlist	int
;	O
}	O
void	O
init_my_statfs	function
(	O
void	O
)	O
{	O
mount_list	pointer
=	O
read_filesystem_list	function
(	O
1	int
,	O
1	int
)	O
;	O
}	O
void	O
my_statfs	function
(	O
struct	O
my_statfs	struct
*	O
myfs_stats	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
int	O
i	int
,	O
len	int
=	O
0	int
;	O
struct	O
mount_entry	struct
*	O
entry	pointer
=	O
NULL	O
;	O
struct	O
mount_entry	struct
*	O
temp	pointer
=	O
mount_list	pointer
;	O
struct	O
fs_usage	struct
fs_use	pointer
;	O
while	O
(	O
temp	pointer
)	O
{	O
i	int
=	O
strlen	function
(	O
temp	pointer
->	O
me_mountdir	pointer
)	O
;	O
if	O
(	O
i	int
>	O
len	int
&&	O
(	O
strncmp	function
(	O
path	pointer
,	O
temp	pointer
->	O
me_mountdir	pointer
,	O
i	int
)	O
==	O
0	int
)	O
)	O
if	O
(	O
!	O
entry	pointer
||	O
(	O
path	pointer
[	O
i	int
]	O
==	O
PATH_SEP	enum
||	O
path	pointer
[	O
i	int
]	O
==	O
0	int
)	O
)	O
{	O
len	int
=	O
i	int
;	O
entry	pointer
=	O
temp	pointer
;	O
}	O
temp	pointer
=	O
temp	pointer
->	O
me_next	pointer
;	O
}	O
if	O
(	O
entry	int
)	O
{	O
memset	function
(	O
&	O
fs_use	struct
,	O
0	int
,	O
sizeof	O
(	O
struct	O
fs_usage	struct
)	O
)	O
;	O
get_fs_usage	function
(	O
entry	pointer
->	O
me_mountdir	pointer
,	O
&	O
fs_use	pointer
)	O
;	O
myfs_stats	pointer
->	O
type	enum
=	O
entry	pointer
->	O
me_dev	long
;	O
myfs_stats	pointer
->	O
typename	pointer
=	O
entry	int
->	O
me_type	pointer
;	O
myfs_stats	pointer
->	O
mpoint	char
=	O
entry	pointer
->	O
me_mountdir	int
;	O
myfs_stats	pointer
->	O
device	pointer
=	O
entry	pointer
->	O
me_devname	pointer
;	O
myfs_stats	pointer
->	O
avail	int
=	O
getuid	function
(	O
)	O
?	O
fs_use	struct
.	O
fsu_bavail	long
/	O
2	int
:	O
fs_use	struct
.	O
fsu_bfree	int
/	O
2	int
;	O
myfs_stats	pointer
->	O
total	long
=	O
fs_use	struct
.	O
fsu_blocks	long
/	O
2	int
;	O
myfs_stats	pointer
->	O
nfree	pointer
=	O
fs_use	struct
.	O
fsu_ffree	pointer
;	O
myfs_stats	pointer
->	O
nodes	int
=	O
fs_use	struct
.	O
fsu_files	int
;	O
}	O
else	O
{	O
myfs_stats	pointer
->	O
type	int
=	O
0	int
;	O
myfs_stats	pointer
->	O
mpoint	pointer
=	O
"unknown"	pointer
;	O
myfs_stats	pointer
->	O
device	pointer
=	O
"unknown"	pointer
;	O
myfs_stats	pointer
->	O
avail	int
=	O
0	int
;	O
myfs_stats	pointer
->	O
total	long
=	O
0	int
;	O
myfs_stats	pointer
->	O
nfree	int
=	O
0	int
;	O
myfs_stats	pointer
->	O
nodes	int
=	O
0	int
;	O
}	O
}	O
static	O
long	O
fs_adjust_blocks	function
(	O
long	O
blocks	long
,	O
int	O
fromsize	int
,	O
int	O
tosize	int
)	O
{	O
if	O
(	O
tosize	int
<=	O
0	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
fromsize	int
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
fromsize	int
==	O
tosize	int
)	O
return	O
blocks	long
;	O
else	O
if	O
(	O
fromsize	int
>	O
tosize	int
)	O
return	O
blocks	long
*	O
(	O
fromsize	int
/	O
tosize	int
)	O
;	O
else	O
return	O
(	O
blocks	long
+	O
(	O
blocks	long
<	O
0	int
?	O
-	O
1	int
:	O
1	int
)	O
)	O
/	O
(	O
tosize	int
/	O
fromsize	int
)	O
;	O
}	O
static	O
int	O
get_fs_usage	function
(	O
char	O
*	O
path	pointer
,	O
struct	O
fs_usage	struct
*	O
fsp	pointer
)	O
{	O
struct	O
statfs	struct
fsd	struct
;	O
if	O
(	O
statfs	pointer
(	O
path	pointer
,	O
&	O
fsd	struct
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
fsp	pointer
->	O
fsu_blocks	long
=	O
CONVERT_BLOCKS	O
(	O
fsd	struct
.	O
f_blocks	long
)	O
;	O
fsp	pointer
->	O
fsu_bfree	long
=	O
CONVERT_BLOCKS	O
(	O
fsd	struct
.	O
f_bfree	long
)	O
;	O
fsp	pointer
->	O
fsu_bavail	long
=	O
CONVERT_BLOCKS	O
(	O
fsd	struct
.	O
f_bavail	long
)	O
;	O
fsp	pointer
->	O
fsu_files	long
=	O
fsd	struct
.	O
f_files	long
;	O
fsp	pointer
->	O
fsu_ffree	long
=	O
fsd	struct
.	O
f_ffree	long
;	O
return	O
0	int
;	O
}	O
void	O
ReportError	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
WORD	int
wCode	int
,	O
PSTR	pointer
szMsg	pointer
,	O
PSTR	pointer
szAltMsg	pointer
)	O
{	O
char	O
cNull	char
=	O
'\0'	O
;	O
BOOL	int
bFatal	int
=	O
wCode	int
&	O
RE_FATAL	int
;	O
BOOL	int
bWarning	int
=	O
wCode	int
&	O
RE_WARNING	int
;	O
wCode	int
&=	O
~	O
(	O
RE_FATAL	int
|	O
RE_WARNING	int
)	O
;	O
if	O
(	O
!	O
szMsg	pointer
)	O
szMsg	pointer
=	O
&	O
cNull	char
;	O
if	O
(	O
wCode	int
)	O
{	O
if	O
(	O
bWarning	int
)	O
printf	function
(	O
"*** Warning: "	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
"*** Error: "	pointer
)	O
;	O
bFatal	int
|=	O
(	O
pibIn	pointer
&&	O
(	O
pibIn	pointer
->	O
cErrors	int
++	O
>	O
MAX_ERRORS	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
pibIn	pointer
)	O
{	O
if	O
(	O
pibIn	pointer
->	O
pfileIn	pointer
||	O
pibIn	pointer
->	O
iLNPrev	int
)	O
{	O
printf	function
(	O
"line %d: "	pointer
,	O
pibIn	pointer
->	O
iLineNum	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
wCode	int
!=	O
RE_FILENOTFOUND	int
)	O
{	O
PSTRLEX	array
szTmp	array
;	O
szTmp	array
[	O
MAX_LEX	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
printf	function
(	O
"'%s'...\n  "	pointer
,	O
strncpy	function
(	O
szTmp	array
,	O
pibIn	pointer
->	O
pbufOrg	pointer
,	O
MAX_LEX	int
-	O
1	int
)	O
)	O
;	O
}	O
}	O
}	O
switch	O
(	O
wCode	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
printf	function
(	O
"Unknown error code %x: %s"	pointer
,	O
wCode	int
,	O
szMsg	pointer
)	O
;	O
case	O
RE_INIT	int
:	O
printf	function
(	O
"Initialization error."	pointer
)	O
;	O
break	O
;	O
case	O
RE_FILENOTFOUND	int
:	O
printf	function
(	O
"File not found \"%s\"."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_CANNOTOPEN	int
:	O
printf	function
(	O
"Cannot open file \"%s\"."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_UNEXPECTED	int
:	O
printf	function
(	O
"Unexpected character '%c' in input file."	pointer
,	O
*	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_UNEXPESCAPE	int
:	O
printf	function
(	O
"Unexpected escape sequence '%s' in input file."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_UNEXPNUMBER	int
:	O
printf	function
(	O
"Unexpected number %s in input file."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_EXPECTED	int
:	O
printf	function
(	O
"Expected '%c' before '%c'."	pointer
,	O
szMsg	pointer
[	O
1	int
]	O
,	O
szMsg	pointer
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
RE_LEXEXPECTED	int
:	O
printf	function
(	O
"Expected <%s>"	pointer
,	O
szMsg	pointer
)	O
;	O
if	O
(	O
szAltMsg	pointer
)	O
printf	function
(	O
" before '%s'"	pointer
,	O
szAltMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_BADCONTEXT	int
:	O
printf	function
(	O
"'%s' used in invalid context."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_DUPDECL	int
:	O
printf	function
(	O
"Duplicate declaration of model variable '%s'."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_DUPSECT	int
:	O
printf	function
(	O
"Only one '%s' section is allowed."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_OUTOFMEM	int
:	O
printf	function
(	O
"Out of memory in %s() !"	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_REDEF	int
:	O
printf	function
(	O
"'%s' redefined."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_EQNTOOLONG	int
:	O
printf	function
(	O
"Equation is too long.  Possibly missing terminator."	pointer
)	O
;	O
break	O
;	O
case	O
RE_BADSTATE	int
:	O
printf	function
(	O
"Invalid state identifier '%s'."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_UNDEFINED	int
:	O
printf	function
(	O
"Undefined identifier '%s'."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_NOINPDEF	int
:	O
printf	function
(	O
"Input '%s' is not initialized."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_NODYNEQN	int
:	O
printf	function
(	O
"State variable '%s' has no dynamics."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_NOOUTPUTEQN	int
:	O
printf	function
(	O
"Output variable '%s' is not computed anywhere."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_TOOMANYVARS	int
:	O
printf	function
(	O
"Too many %s declarations. Limit is %d."	pointer
,	O
szMsg	pointer
,	O
*	O
(	O
PINT	pointer
)	O
szAltMsg	pointer
)	O
;	O
break	O
;	O
case	O
RE_POSITIVE	int
:	O
printf	function
(	O
"Positive number expected."	pointer
)	O
;	O
break	O
;	O
case	O
RE_NAMETOOLONG	int
:	O
printf	function
(	O
"Name %s exceed %d characters."	pointer
,	O
szMsg	pointer
,	O
MAX_NAME	pointer
)	O
;	O
break	O
;	O
case	O
RE_UNBALPAR	int
:	O
printf	function
(	O
"Unbalanced () or equation too long at this line or above."	pointer
)	O
;	O
break	O
;	O
case	O
RE_NOEND	int
:	O
printf	function
(	O
"End keyword is missing in file %s."	pointer
,	O
szMsg	pointer
)	O
;	O
break	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
szAltMsg	pointer
&&	O
wCode	int
!=	O
RE_LEXEXPECTED	int
)	O
printf	function
(	O
"%s\n"	pointer
,	O
szAltMsg	pointer
)	O
;	O
if	O
(	O
bFatal	int
)	O
{	O
printf	function
(	O
"One or more fatal errors: Exiting...\n\n"	pointer
)	O
;	O
exit	function
(	O
wCode	int
)	O
;	O
}	O
}	O
__ptr_t	O
calloc	function
(	O
nmemb	long
,	O
size	long
)	O
register	O
__malloc_size_t	O
nmemb	long
;	O
register	O
__malloc_size_t	O
size	long
;	O
{	O
register	O
__ptr_t	O
result	pointer
=	O
malloc	function
(	O
nmemb	long
*	O
size	int
)	O
;	O
if	O
(	O
result	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
memset	function
(	O
result	pointer
,	O
0	int
,	O
nmemb	long
*	O
size	int
)	O
;	O
return	O
result	int
;	O
}	O
typedef	O
void	O
(	O
*	O
sig_t	pointer
)	O
(	O
int	O
)	O
;	O
static	O
void	O
connect_timed_out	function
(	O
void	O
)	O
;	O
byte	char
*	O
hostname_or_ip_to_address	function
(	O
char	O
*	O
hostname_specifier	pointer
)	O
;	O
int	O
tcp_fast_connections	int
=	O
0	int
;	O
static	O
int	O
connection_timeout_counter	int
=	O
TCP_TIME_OUT	int
;	O
static	O
int	O
allow_time_outs	int
=	O
TCP_ALLOW_TIMEOUTS	int
;	O
typedef	O
void	O
SIGFUN	function
(	O
int	O
sig	int
)	O
;	O
int	O
tcp_to_host	function
(	O
char	O
*	O
host	pointer
,	O
char	O
*	O
service	pointer
)	O
{	O
struct	O
sockaddr_in	struct
name	pointer
;	O
byte	char
*	O
address	pointer
;	O
int	O
connection	pointer
;	O
address	long
=	O
hostname_or_ip_to_address	function
(	O
host	pointer
)	O
;	O
if	O
(	O
!	O
address	long
)	O
return	O
(	O
-	O
1	int
)	O
;	O
memset	function
(	O
&	O
name	pointer
,	O
0	int
,	O
sizeof	O
(	O
name	pointer
)	O
)	O
;	O
name	pointer
.	O
sin_family	short
=	O
AF_INET	O
;	O
memcpy	function
(	O
&	O
name	pointer
.	O
sin_addr	struct
.	O
s_addr	int
,	O
address	array
,	O
4	int
)	O
;	O
if	O
(	O
isdigit	function
(	O
*	O
service	pointer
)	O
)	O
name	pointer
.	O
sin_port	enum
=	O
htons	function
(	O
atoi	function
(	O
service	pointer
)	O
)	O
;	O
else	O
{	O
struct	O
servent	struct
*	O
server	int
;	O
server	int
=	O
getservbyname	function
(	O
service	pointer
,	O
"tcp"	pointer
)	O
;	O
if	O
(	O
!	O
server	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
name	pointer
.	O
sin_port	enum
=	O
server	pointer
->	O
s_port	int
;	O
}	O
connection	pointer
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
IP	int
)	O
;	O
if	O
(	O
connection	int
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
{	O
int	O
error	int
;	O
if	O
(	O
allow_time_outs	int
)	O
{	O
signal	function
(	O
SIGALRM	int
,	O
(	O
sig_t	O
)	O
connect_timed_out	function
)	O
;	O
alarm	function
(	O
connection_timeout_counter	int
)	O
;	O
error	function
=	O
connect	function
(	O
connection	pointer
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
name	pointer
,	O
sizeof	O
(	O
name	pointer
)	O
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
signal	function
(	O
SIGALRM	int
,	O
(	O
SIGFUN	struct
*	O
)	O
NULL	O
)	O
;	O
}	O
else	O
error	pointer
=	O
connect	function
(	O
connection	pointer
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
name	pointer
,	O
sizeof	O
(	O
name	pointer
)	O
)	O
;	O
if	O
(	O
error	int
<	O
0	int
)	O
{	O
close	pointer
(	O
connection	pointer
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
}	O
return	O
(	O
connection	pointer
)	O
;	O
}	O
static	O
void	O
connect_timed_out	function
(	O
void	O
)	O
{	O
alarm	function
(	O
0	int
)	O
;	O
}	O
static	O
byte	char
address_buffer	array
[	O
8	int
]	O
;	O
byte	char
*	O
hostname_or_ip_to_address	function
(	O
char	O
*	O
hostname_specifier	pointer
)	O
{	O
struct	O
hostent	struct
*	O
entry	pointer
;	O
{	O
register	O
int	O
i	int
,	O
dots	int
=	O
0	int
,	O
invalid	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
hostname_specifier	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
hostname_specifier	pointer
[	O
i	int
]	O
==	O
'.'	O
)	O
dots	int
++	O
;	O
else	O
if	O
(	O
!	O
isdigit	function
(	O
hostname_specifier	pointer
[	O
i	int
]	O
)	O
)	O
{	O
invalid	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
dots	int
==	O
3	int
&&	O
!	O
invalid	int
)	O
{	O
int	O
offset	int
=	O
0	int
;	O
i	int
=	O
0	int
;	O
while	O
(	O
hostname_specifier	array
[	O
i	int
]	O
)	O
{	O
int	O
number	int
=	O
0	int
;	O
while	O
(	O
(	O
hostname_specifier	array
[	O
i	int
]	O
!=	O
'\0'	O
)	O
&&	O
(	O
hostname_specifier	array
[	O
i	int
]	O
!=	O
'.'	O
)	O
)	O
number	int
=	O
(	O
number	int
*	O
10	int
)	O
+	O
hostname_specifier	array
[	O
i	int
++	O
]	O
-	O
'0'	O
;	O
address_buffer	array
[	O
offset	int
++	O
]	O
=	O
number	int
;	O
if	O
(	O
hostname_specifier	array
[	O
i	int
]	O
)	O
i	int
++	O
;	O
}	O
return	O
(	O
address_buffer	int
)	O
;	O
}	O
}	O
entry	pointer
=	O
gethostbyname	function
(	O
hostname_specifier	pointer
)	O
;	O
if	O
(	O
entry	int
)	O
{	O
memcpy	function
(	O
address_buffer	pointer
,	O
entry	pointer
->	O
h_addr	O
,	O
4	int
)	O
;	O
return	O
(	O
address_buffer	pointer
)	O
;	O
}	O
else	O
return	O
(	O
(	O
byte	char
*	O
)	O
NULL	O
)	O
;	O
}	O
const	O
char	O
*	O
strcasestr2	function
(	O
const	O
char	O
*	O
s	pointer
,	O
const	O
char	O
*	O
pattern	pointer
)	O
{	O
int	O
length	int
=	O
strlen	function
(	O
pattern	pointer
)	O
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
strncasecmp	function
(	O
s	pointer
,	O
pattern	pointer
,	O
length	int
)	O
==	O
0	int
)	O
return	O
s	pointer
;	O
s	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
strncoll	function
(	O
const	O
char	O
*	O
a	pointer
,	O
const	O
char	O
*	O
b	pointer
,	O
int	O
len	int
)	O
{	O
char	O
*	O
tmpa	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
len	int
+	O
1	int
)	O
;	O
char	O
*	O
tmpb	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
tmpa	pointer
,	O
a	pointer
,	O
len	int
)	O
;	O
tmpa	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
memcpy	function
(	O
tmpb	pointer
,	O
b	pointer
,	O
len	int
)	O
;	O
tmpb	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
int	O
lose	int
=	O
strcoll	function
(	O
tmpa	pointer
,	O
tmpb	pointer
)	O
;	O
free	function
(	O
tmpa	pointer
)	O
;	O
free	function
(	O
tmpb	pointer
)	O
;	O
return	O
lose	O
;	O
}	O
static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: bt_upgrade.c,v 1.4 2014/04/17 20:27:25 sebdiaz Exp $"	pointer
;	O
int	O
CDB___bam_30_btreemeta	function
(	O
dbp	pointer
,	O
real_name	pointer
,	O
buf	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
char	O
*	O
real_name	pointer
;	O
u_int8_t	char
*	O
buf	pointer
;	O
{	O
BTMETA30	struct
*	O
newmeta	pointer
;	O
BTMETA2X	struct
*	O
oldmeta	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
int	O
ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
newmeta	pointer
=	O
(	O
BTMETA30	struct
*	O
)	O
buf	pointer
;	O
oldmeta	pointer
=	O
(	O
BTMETA2X	struct
*	O
)	O
buf	pointer
;	O
newmeta	pointer
->	O
re_pad	int
=	O
oldmeta	pointer
->	O
re_pad	int
;	O
newmeta	pointer
->	O
re_len	int
=	O
oldmeta	pointer
->	O
re_len	int
;	O
newmeta	pointer
->	O
minkey	int
=	O
oldmeta	pointer
->	O
minkey	int
;	O
newmeta	pointer
->	O
maxkey	int
=	O
oldmeta	pointer
->	O
maxkey	int
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
free	function
=	O
oldmeta	pointer
->	O
free	function
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
flags	int
=	O
oldmeta	pointer
->	O
flags	int
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
type	int
=	O
P_BTREEMETA	int
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
version	int
=	O
7	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_fileid	function
(	O
dbenv	pointer
,	O
real_name	pointer
,	O
1	int
,	O
buf	pointer
+	O
36	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
newmeta	pointer
->	O
root	pointer
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___bam_31_btreemeta	function
(	O
dbp	pointer
,	O
real_name	pointer
,	O
flags	int
,	O
fhp	pointer
,	O
h	pointer
,	O
dirtyp	int
)	O
DB	struct
*	O
dbp	pointer
;	O
char	O
*	O
real_name	pointer
;	O
u_int32_t	int
flags	int
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
int	O
*	O
dirtyp	pointer
;	O
{	O
if	O
(	O
dbp	pointer
==	O
NULL	O
)	O
dbp	pointer
=	O
NULL	O
;	O
if	O
(	O
real_name	pointer
==	O
NULL	O
)	O
real_name	pointer
=	O
NULL	O
;	O
if	O
(	O
fhp	pointer
==	O
NULL	O
)	O
fhp	pointer
=	O
NULL	O
;	O
BTMETA31	struct
*	O
newmeta	pointer
;	O
BTMETA30	struct
*	O
oldmeta	pointer
;	O
COMPQUIET	O
(	O
dbp	pointer
,	O
NULL	O
)	O
;	O
COMPQUIET	O
(	O
real_name	pointer
,	O
NULL	O
)	O
;	O
COMPQUIET	O
(	O
fhp	pointer
,	O
NULL	O
)	O
;	O
newmeta	pointer
=	O
(	O
BTMETA31	struct
*	O
)	O
h	pointer
;	O
oldmeta	pointer
=	O
(	O
BTMETA30	struct
*	O
)	O
h	pointer
;	O
newmeta	pointer
->	O
root	pointer
=	O
oldmeta	pointer
->	O
root	pointer
;	O
newmeta	pointer
->	O
re_pad	int
=	O
oldmeta	pointer
->	O
re_pad	int
;	O
newmeta	pointer
->	O
re_len	int
=	O
oldmeta	pointer
->	O
re_len	int
;	O
newmeta	pointer
->	O
minkey	int
=	O
oldmeta	pointer
->	O
minkey	int
;	O
newmeta	pointer
->	O
maxkey	pointer
=	O
oldmeta	pointer
->	O
maxkey	pointer
;	O
memmove	function
(	O
newmeta	pointer
->	O
dbmeta	struct
.	O
uid	int
,	O
oldmeta	pointer
->	O
dbmeta	struct
.	O
uid	int
,	O
sizeof	O
(	O
oldmeta	pointer
->	O
dbmeta	struct
.	O
uid	int
)	O
)	O
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
flags	int
=	O
oldmeta	pointer
->	O
dbmeta	struct
.	O
flags	int
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
record_count	int
=	O
0	int
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
key_count	int
=	O
0	int
;	O
ZERO_LSN	O
(	O
newmeta	pointer
->	O
dbmeta	struct
.	O
alloc_lsn	int
)	O
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
version	int
=	O
8	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_DUPSORT	int
)	O
)	O
F_SET	O
(	O
&	O
newmeta	pointer
->	O
dbmeta	char
,	O
BTM_DUPSORT	pointer
)	O
;	O
*	O
dirtyp	pointer
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___bam_31_lbtree	function
(	O
dbp	pointer
,	O
real_name	pointer
,	O
flags	int
,	O
fhp	pointer
,	O
h	pointer
,	O
dirtyp	int
)	O
DB	struct
*	O
dbp	pointer
;	O
char	O
*	O
real_name	pointer
;	O
u_int32_t	int
flags	int
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
int	O
*	O
dirtyp	pointer
;	O
{	O
BKEYDATA	struct
*	O
bk	pointer
;	O
db_pgno_t	int
pgno	int
;	O
db_indx_t	short
indx	short
;	O
int	O
ret	int
;	O
ret	int
=	O
0	int
;	O
for	O
(	O
indx	double
=	O
O_INDX	int
;	O
indx	short
<	O
NUM_ENT	O
(	O
h	int
)	O
;	O
indx	double
+=	O
P_INDX	int
)	O
{	O
bk	pointer
=	O
GET_BKEYDATA	O
(	O
h	pointer
,	O
indx	short
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
bk	pointer
->	O
type	enum
)	O
==	O
B_DUPLICATE	int
)	O
{	O
pgno	int
=	O
GET_BOVERFLOW	O
(	O
h	int
,	O
indx	double
)	O
->	O
pgno	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_31_offdup	function
(	O
dbp	pointer
,	O
real_name	pointer
,	O
fhp	pointer
,	O
LF_ISSET	O
(	O
DB_DUPSORT	int
)	O
?	O
1	int
:	O
0	int
,	O
&	O
pgno	int
)	O
)	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
pgno	int
!=	O
GET_BOVERFLOW	O
(	O
h	int
,	O
indx	double
)	O
->	O
pgno	int
)	O
{	O
*	O
dirtyp	pointer
=	O
1	int
;	O
GET_BOVERFLOW	O
(	O
h	pointer
,	O
indx	short
)	O
->	O
pgno	int
=	O
pgno	int
;	O
}	O
}	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: db_shash.c,v 1.3 2000/06/28 16:47:01 loic Exp $"	pointer
;	O
static	O
const	O
struct	O
{	O
u_int32_t	int
power	int
;	O
u_int32_t	int
prime	int
;	O
}	O
list	pointer
[	O
]	O
=	O
{	O
{	O
64	int
,	O
67	int
}	O
,	O
{	O
128	int
,	O
131	int
}	O
,	O
{	O
256	int
,	O
257	int
}	O
,	O
{	O
512	int
,	O
521	pointer
}	O
,	O
{	O
1024	int
,	O
1031	int
}	O
,	O
{	O
2048	int
,	O
2053	int
}	O
,	O
{	O
4096	int
,	O
4099	int
}	O
,	O
{	O
8192	int
,	O
8191	int
}	O
,	O
{	O
16384	int
,	O
16381	pointer
}	O
,	O
{	O
32768	int
,	O
32771	int
}	O
,	O
{	O
65536	pointer
,	O
65537	int
}	O
,	O
{	O
131072	pointer
,	O
131071	int
}	O
,	O
{	O
262144	pointer
,	O
262147	int
}	O
,	O
{	O
393216	pointer
,	O
393209	int
}	O
,	O
{	O
524288	pointer
,	O
524287	int
}	O
,	O
{	O
786432	pointer
,	O
786431	int
}	O
,	O
{	O
1048576	pointer
,	O
1048573	int
}	O
,	O
{	O
1572864	pointer
,	O
1572869	int
}	O
,	O
{	O
2097152	pointer
,	O
2097169	int
}	O
,	O
{	O
3145728	pointer
,	O
3145721	int
}	O
,	O
{	O
4194304	O
,	O
4194301	int
}	O
,	O
{	O
6291456	pointer
,	O
6291449	int
}	O
,	O
{	O
8388608	pointer
,	O
8388617	int
}	O
,	O
{	O
12582912	pointer
,	O
12582917	int
}	O
,	O
{	O
16777216	pointer
,	O
16777213	int
}	O
,	O
{	O
25165824	pointer
,	O
25165813	int
}	O
,	O
{	O
33554432	pointer
,	O
33554393	int
}	O
,	O
{	O
50331648	pointer
,	O
50331653	int
}	O
,	O
{	O
67108864	pointer
,	O
67108859	int
}	O
,	O
{	O
100663296	pointer
,	O
100663291	int
}	O
,	O
{	O
134217728	pointer
,	O
134217757	int
}	O
,	O
{	O
201326592	pointer
,	O
201326611	int
}	O
,	O
{	O
268435456	pointer
,	O
268435459	int
}	O
,	O
{	O
402653184	pointer
,	O
402653189	int
}	O
,	O
{	O
536870912	pointer
,	O
536870909	int
}	O
,	O
{	O
805306368	pointer
,	O
805306357	int
}	O
,	O
{	O
1073741824	pointer
,	O
1073741827	int
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
int	O
CDB___db_tablesize	function
(	O
n_buckets	pointer
)	O
u_int32_t	int
n_buckets	int
;	O
{	O
int	O
i	int
;	O
if	O
(	O
n_buckets	long
<	O
64	int
)	O
n_buckets	int
=	O
64	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
;	O
++	O
i	int
)	O
{	O
if	O
(	O
list	pointer
[	O
i	int
]	O
.	O
power	int
==	O
0	int
)	O
{	O
--	O
i	int
;	O
break	O
;	O
}	O
if	O
(	O
list	pointer
[	O
i	int
]	O
.	O
power	int
>=	O
n_buckets	long
)	O
break	O
;	O
}	O
return	O
(	O
list	pointer
[	O
i	int
]	O
.	O
prime	long
)	O
;	O
}	O
void	O
CDB___db_hashinit	function
(	O
begin	int
,	O
nelements	pointer
)	O
void	O
*	O
begin	pointer
;	O
u_int32_t	int
nelements	int
;	O
{	O
u_int32_t	int
i	int
;	O
SH_TAILQ_HEAD	function
(	O
hash_head	pointer
)	O
*	O
headp	pointer
;	O
headp	pointer
=	O
(	O
struct	O
hash_head	struct
*	O
)	O
begin	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nelements	int
;	O
i	int
++	O
,	O
headp	int
++	O
)	O
SH_TAILQ_INIT	function
(	O
headp	pointer
)	O
;	O
}	O
static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: hash_method.c,v 1.3 2000/06/28 16:47:01 loic Exp $"	pointer
;	O
static	O
int	O
__ham_set_h_ffactor	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__ham_set_h_hash	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
u_int32_t	int
(	O
*	O
)	O
(	O
const	O
void	O
*	O
,	O
u_int32_t	int
)	O
)	O
)	O
;	O
static	O
int	O
__ham_set_h_nelem	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
int	O
CDB___ham_db_create	function
(	O
dbp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
{	O
HASH	struct
*	O
hashp	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
sizeof	O
(	O
HASH	pointer
)	O
,	O
NULL	O
,	O
&	O
dbp	pointer
->	O
h_internal	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
hashp	pointer
=	O
dbp	pointer
->	O
h_internal	pointer
;	O
hashp	pointer
->	O
h_nelem	int
=	O
0	int
;	O
hashp	pointer
->	O
h_ffactor	int
=	O
0	int
;	O
hashp	pointer
->	O
h_hash	pointer
=	O
NULL	O
;	O
dbp	pointer
->	O
set_h_ffactor	pointer
=	O
__ham_set_h_ffactor	pointer
;	O
dbp	pointer
->	O
set_h_hash	pointer
=	O
__ham_set_h_hash	pointer
;	O
dbp	pointer
->	O
set_h_nelem	pointer
=	O
__ham_set_h_nelem	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___ham_db_close	function
(	O
dbp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
{	O
if	O
(	O
dbp	pointer
->	O
h_internal	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
CDB___os_free	function
(	O
dbp	pointer
->	O
h_internal	pointer
,	O
sizeof	O
(	O
HASH	pointer
)	O
)	O
;	O
dbp	pointer
->	O
h_internal	pointer
=	O
NULL	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__ham_set_h_ffactor	function
(	O
dbp	pointer
,	O
h_ffactor	int
)	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
h_ffactor	int
;	O
{	O
HASH	struct
*	O
hashp	pointer
;	O
DB_ILLEGAL_AFTER_OPEN	function
(	O
dbp	pointer
,	O
"set_h_ffactor"	pointer
)	O
;	O
DB_ILLEGAL_METHOD	O
(	O
dbp	pointer
,	O
DB_OK_HASH	pointer
)	O
;	O
hashp	pointer
=	O
dbp	pointer
->	O
h_internal	pointer
;	O
hashp	pointer
->	O
h_ffactor	int
=	O
h_ffactor	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__ham_set_h_hash	function
(	O
dbp	pointer
,	O
func	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
(	O
*	O
func	pointer
)	O
__P	O
(	O
(	O
const	O
void	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
{	O
HASH	struct
*	O
hashp	pointer
;	O
DB_ILLEGAL_AFTER_OPEN	function
(	O
dbp	pointer
,	O
"set_h_hash"	pointer
)	O
;	O
DB_ILLEGAL_METHOD	O
(	O
dbp	pointer
,	O
DB_OK_HASH	pointer
)	O
;	O
hashp	pointer
=	O
dbp	pointer
->	O
h_internal	pointer
;	O
hashp	pointer
->	O
h_hash	pointer
=	O
func	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__ham_set_h_nelem	function
(	O
dbp	pointer
,	O
h_nelem	int
)	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
h_nelem	int
;	O
{	O
HASH	struct
*	O
hashp	pointer
;	O
DB_ILLEGAL_AFTER_OPEN	function
(	O
dbp	pointer
,	O
"set_h_nelem"	pointer
)	O
;	O
DB_ILLEGAL_METHOD	O
(	O
dbp	pointer
,	O
DB_OK_HASH	pointer
)	O
;	O
hashp	pointer
=	O
dbp	pointer
->	O
h_internal	pointer
;	O
hashp	pointer
->	O
h_nelem	int
=	O
h_nelem	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: hash_upgrade.c,v 1.4 2014/04/17 20:27:29 sebdiaz Exp $"	pointer
;	O
int	O
CDB___ham_30_hashmeta	function
(	O
dbp	pointer
,	O
real_name	pointer
,	O
obuf	int
)	O
DB	struct
*	O
dbp	pointer
;	O
char	O
*	O
real_name	pointer
;	O
u_int8_t	char
*	O
obuf	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
HASHHDR	struct
*	O
oldmeta	pointer
;	O
HMETA30	struct
newmeta	pointer
;	O
u_int32_t	int
*	O
o_spares	pointer
,	O
*	O
n_spares	pointer
;	O
u_int32_t	int
fillf	int
,	O
maxb	int
,	O
nelem	long
;	O
int	O
i	int
,	O
non_zero	int
,	O
ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
memset	function
(	O
&	O
newmeta	struct
,	O
0	int
,	O
sizeof	O
(	O
newmeta	struct
)	O
)	O
;	O
oldmeta	pointer
=	O
(	O
HASHHDR	struct
*	O
)	O
obuf	pointer
;	O
newmeta	struct
.	O
dbmeta	struct
.	O
lsn	struct
=	O
oldmeta	pointer
->	O
lsn	struct
;	O
newmeta	struct
.	O
dbmeta	struct
.	O
pgno	int
=	O
oldmeta	pointer
->	O
pgno	int
;	O
newmeta	struct
.	O
dbmeta	struct
.	O
magic	int
=	O
oldmeta	pointer
->	O
magic	int
;	O
newmeta	struct
.	O
dbmeta	struct
.	O
version	int
=	O
6	int
;	O
newmeta	struct
.	O
dbmeta	struct
.	O
pagesize	long
=	O
oldmeta	pointer
->	O
pagesize	long
;	O
newmeta	struct
.	O
dbmeta	struct
.	O
type	int
=	O
P_HASHMETA	int
;	O
newmeta	struct
.	O
dbmeta	struct
.	O
flags	int
=	O
oldmeta	pointer
->	O
flags	int
;	O
newmeta	struct
.	O
max_bucket	pointer
=	O
oldmeta	pointer
->	O
max_bucket	int
;	O
newmeta	struct
.	O
high_mask	pointer
=	O
oldmeta	pointer
->	O
high_mask	int
;	O
newmeta	struct
.	O
low_mask	pointer
=	O
oldmeta	pointer
->	O
low_mask	int
;	O
newmeta	struct
.	O
ffactor	pointer
=	O
oldmeta	pointer
->	O
ffactor	int
;	O
newmeta	struct
.	O
nelem	long
=	O
oldmeta	pointer
->	O
nelem	int
;	O
newmeta	struct
.	O
h_charkey	int
=	O
oldmeta	pointer
->	O
h_charkey	int
;	O
nelem	long
=	O
newmeta	struct
.	O
nelem	long
;	O
fillf	int
=	O
newmeta	struct
.	O
ffactor	int
;	O
maxb	int
=	O
newmeta	struct
.	O
max_bucket	int
;	O
if	O
(	O
(	O
fillf	int
!=	O
0	int
&&	O
fillf	struct
*	O
maxb	pointer
<	O
2	int
*	O
nelem	int
)	O
||	O
(	O
fillf	int
==	O
0	int
&&	O
nelem	long
>	O
0x8000000	int
)	O
)	O
newmeta	struct
.	O
nelem	long
=	O
0	int
;	O
o_spares	int
=	O
oldmeta	pointer
->	O
spares	int
;	O
n_spares	int
=	O
newmeta	struct
.	O
spares	int
;	O
non_zero	int
=	O
0	int
;	O
n_spares	array
[	O
0	int
]	O
=	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
NCACHED	int
;	O
i	int
++	O
)	O
{	O
non_zero	int
=	O
non_zero	int
||	O
o_spares	pointer
[	O
i	int
-	O
1	int
]	O
!=	O
0	int
;	O
if	O
(	O
o_spares	pointer
[	O
i	int
-	O
1	int
]	O
==	O
0	int
&&	O
non_zero	int
)	O
n_spares	pointer
[	O
i	int
]	O
=	O
0	int
;	O
else	O
n_spares	array
[	O
i	int
]	O
=	O
1	int
+	O
o_spares	array
[	O
i	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_fileid	function
(	O
dbenv	pointer
,	O
real_name	pointer
,	O
1	int
,	O
newmeta	struct
.	O
dbmeta	struct
.	O
uid	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
memcpy	function
(	O
oldmeta	pointer
,	O
&	O
newmeta	struct
,	O
sizeof	O
(	O
newmeta	struct
)	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___ham_31_hashmeta	function
(	O
dbp	pointer
,	O
real_name	pointer
,	O
flags	int
,	O
fhp	pointer
,	O
h	pointer
,	O
dirtyp	int
)	O
DB	struct
*	O
dbp	pointer
;	O
char	O
*	O
real_name	pointer
;	O
u_int32_t	int
flags	int
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
int	O
*	O
dirtyp	pointer
;	O
{	O
if	O
(	O
dbp	pointer
||	O
real_name	pointer
||	O
fhp	pointer
)	O
{	O
}	O
HMETA31	struct
*	O
newmeta	pointer
;	O
HMETA30	struct
*	O
oldmeta	pointer
;	O
COMPQUIET	O
(	O
dbp	pointer
,	O
NULL	O
)	O
;	O
COMPQUIET	O
(	O
real_name	pointer
,	O
NULL	O
)	O
;	O
COMPQUIET	O
(	O
fhp	pointer
,	O
NULL	O
)	O
;	O
newmeta	pointer
=	O
(	O
HMETA31	struct
*	O
)	O
h	pointer
;	O
oldmeta	pointer
=	O
(	O
HMETA30	struct
*	O
)	O
h	pointer
;	O
memmove	function
(	O
newmeta	pointer
->	O
spares	pointer
,	O
oldmeta	pointer
->	O
spares	pointer
,	O
sizeof	O
(	O
oldmeta	pointer
->	O
spares	pointer
)	O
)	O
;	O
newmeta	pointer
->	O
h_charkey	pointer
=	O
oldmeta	pointer
->	O
h_charkey	int
;	O
newmeta	pointer
->	O
nelem	long
=	O
oldmeta	pointer
->	O
nelem	long
;	O
newmeta	pointer
->	O
ffactor	int
=	O
oldmeta	pointer
->	O
ffactor	int
;	O
newmeta	pointer
->	O
low_mask	int
=	O
oldmeta	pointer
->	O
low_mask	int
;	O
newmeta	pointer
->	O
high_mask	int
=	O
oldmeta	pointer
->	O
high_mask	int
;	O
newmeta	pointer
->	O
max_bucket	pointer
=	O
oldmeta	pointer
->	O
max_bucket	pointer
;	O
memmove	function
(	O
newmeta	pointer
->	O
dbmeta	struct
.	O
uid	int
,	O
oldmeta	pointer
->	O
dbmeta	struct
.	O
uid	int
,	O
sizeof	O
(	O
oldmeta	pointer
->	O
dbmeta	struct
.	O
uid	int
)	O
)	O
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
flags	int
=	O
oldmeta	pointer
->	O
dbmeta	struct
.	O
flags	int
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
record_count	int
=	O
0	int
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
key_count	int
=	O
0	int
;	O
ZERO_LSN	O
(	O
newmeta	pointer
->	O
dbmeta	struct
.	O
alloc_lsn	int
)	O
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
version	int
=	O
7	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_DUPSORT	int
)	O
)	O
F_SET	O
(	O
&	O
newmeta	pointer
->	O
dbmeta	char
,	O
DB_HASH_DUPSORT	pointer
)	O
;	O
*	O
dirtyp	pointer
=	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___ham_31_hash	function
(	O
dbp	pointer
,	O
real_name	pointer
,	O
flags	int
,	O
fhp	pointer
,	O
h	pointer
,	O
dirtyp	int
)	O
DB	struct
*	O
dbp	pointer
;	O
char	O
*	O
real_name	pointer
;	O
u_int32_t	int
flags	int
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
PAGE	struct
*	O
h	pointer
;	O
int	O
*	O
dirtyp	pointer
;	O
{	O
HKEYDATA	struct
*	O
hk	pointer
;	O
db_pgno_t	int
pgno	int
,	O
tpgno	int
;	O
db_indx_t	short
indx	short
;	O
int	O
ret	int
;	O
COMPQUIET	O
(	O
flags	int
,	O
0	int
)	O
;	O
ret	int
=	O
0	int
;	O
for	O
(	O
indx	short
=	O
0	int
;	O
indx	double
<	O
NUM_ENT	O
(	O
h	int
)	O
;	O
indx	double
+=	O
2	int
)	O
{	O
hk	pointer
=	O
(	O
HKEYDATA	struct
*	O
)	O
H_PAIRDATA	function
(	O
h	int
,	O
indx	short
)	O
;	O
if	O
(	O
HPAGE_PTYPE	O
(	O
hk	pointer
)	O
==	O
H_OFFDUP	int
)	O
{	O
memcpy	function
(	O
&	O
pgno	int
,	O
HOFFDUP_PGNO	function
(	O
hk	pointer
)	O
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
tpgno	int
=	O
pgno	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_31_offdup	function
(	O
dbp	pointer
,	O
real_name	pointer
,	O
fhp	pointer
,	O
LF_ISSET	O
(	O
DB_DUPSORT	int
)	O
?	O
1	int
:	O
0	int
,	O
&	O
tpgno	int
)	O
)	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
pgno	int
!=	O
tpgno	int
)	O
{	O
*	O
dirtyp	int
=	O
1	int
;	O
memcpy	function
(	O
HOFFDUP_PGNO	function
(	O
hk	pointer
)	O
,	O
&	O
tpgno	int
,	O
sizeof	O
(	O
db_pgno_t	int
)	O
)	O
;	O
}	O
}	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: mp_register.c,v 1.3 2000/06/28 16:47:02 loic Exp $"	pointer
;	O
int	O
CDB_memp_register	function
(	O
dbenv	pointer
,	O
ftype	pointer
,	O
pgin	pointer
,	O
pgout	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
int	O
ftype	int
;	O
int	O
(	O
*	O
pgin	pointer
)	O
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
db_pgno_t	int
,	O
void	O
*	O
,	O
DBT	struct
*	O
)	O
)	O
;	O
int	O
(	O
*	O
pgout	pointer
)	O
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
db_pgno_t	int
,	O
void	O
*	O
,	O
DBT	struct
*	O
)	O
)	O
;	O
{	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
DB_MPREG	struct
*	O
mpreg	pointer
;	O
int	O
ret	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
mp_handle	int
,	O
DB_INIT_MPOOL	int
)	O
;	O
dbmp	pointer
=	O
dbenv	pointer
->	O
mp_handle	pointer
;	O
MUTEX_THREAD_LOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
for	O
(	O
mpreg	int
=	O
LIST_FIRST	function
(	O
&	O
dbmp	pointer
->	O
dbregq	pointer
)	O
;	O
mpreg	pointer
!=	O
NULL	O
;	O
mpreg	pointer
=	O
LIST_NEXT	function
(	O
mpreg	pointer
,	O
q	pointer
)	O
)	O
if	O
(	O
mpreg	pointer
->	O
ftype	int
==	O
ftype	int
)	O
{	O
mpreg	pointer
->	O
pgin	int
=	O
pgin	int
;	O
mpreg	pointer
->	O
pgout	int
=	O
pgout	int
;	O
break	O
;	O
}	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
mpreg	pointer
!=	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
sizeof	O
(	O
DB_MPREG	pointer
)	O
,	O
NULL	O
,	O
&	O
mpreg	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
mpreg	pointer
->	O
ftype	pointer
=	O
ftype	int
;	O
mpreg	pointer
->	O
pgin	pointer
=	O
pgin	int
;	O
mpreg	pointer
->	O
pgout	pointer
=	O
pgout	pointer
;	O
MUTEX_THREAD_LOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
LIST_INSERT_HEAD	function
(	O
&	O
dbmp	pointer
->	O
dbregq	pointer
,	O
mpreg	pointer
,	O
q	int
)	O
;	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: os_fid.c,v 1.3 2000/06/28 16:47:02 loic Exp $"	pointer
;	O
static	O
u_int32_t	int
fid_serial	int
=	O
SERIAL_INIT	pointer
;	O
int	O
CDB___os_fileid	function
(	O
dbenv	pointer
,	O
fname	pointer
,	O
unique_okay	pointer
,	O
fidp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
const	O
char	O
*	O
fname	pointer
;	O
int	O
unique_okay	int
;	O
u_int8_t	char
*	O
fidp	pointer
;	O
{	O
struct	O
stat	struct
sb	struct
;	O
size_t	long
i	long
;	O
int	O
ret	int
;	O
u_int32_t	int
tmp	int
;	O
u_int8_t	char
*	O
p	pointer
;	O
memset	function
(	O
fidp	pointer
,	O
0	int
,	O
DB_FILE_ID_LEN	int
)	O
;	O
if	O
(	O
stat	struct
(	O
fname	pointer
,	O
&	O
sb	struct
)	O
)	O
{	O
ret	int
=	O
CDB___os_get_errno	function
(	O
)	O
;	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
fname	pointer
,	O
strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
fid_serial	int
==	O
SERIAL_INIT	int
)	O
fid_serial	int
=	O
(	O
u_int32_t	int
)	O
getpid	function
(	O
)	O
;	O
else	O
fid_serial	int
+=	O
100000	int
;	O
tmp	long
=	O
(	O
u_int32_t	int
)	O
sb	struct
.	O
st_ino	long
;	O
for	O
(	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
&	O
tmp	struct
,	O
i	int
=	O
sizeof	O
(	O
u_int32_t	int
)	O
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
*	O
fidp	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
tmp	array
=	O
(	O
u_int32_t	int
)	O
sb	struct
.	O
st_dev	long
;	O
for	O
(	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
&	O
tmp	struct
,	O
i	int
=	O
sizeof	O
(	O
u_int32_t	int
)	O
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
*	O
fidp	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
unique_okay	int
)	O
{	O
tmp	array
=	O
(	O
u_int32_t	int
)	O
time	struct
(	O
NULL	O
)	O
;	O
for	O
(	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
&	O
tmp	struct
,	O
i	int
=	O
sizeof	O
(	O
u_int32_t	int
)	O
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
*	O
fidp	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
for	O
(	O
p	pointer
=	O
(	O
u_int8_t	char
*	O
)	O
&	O
fid_serial	struct
,	O
i	int
=	O
sizeof	O
(	O
u_int32_t	int
)	O
;	O
i	int
>	O
0	int
;	O
--	O
i	int
)	O
*	O
fidp	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: os_region.c,v 1.4 2000/06/28 16:47:02 loic Exp $"	pointer
;	O
int	O
CDB___os_r_attach	function
(	O
dbenv	pointer
,	O
infop	pointer
,	O
rp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
REGINFO	struct
*	O
infop	pointer
;	O
REGION	struct
*	O
rp	pointer
;	O
{	O
OS_VMROUNDOFF	function
(	O
rp	pointer
->	O
size	long
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_PRIVATE	pointer
)	O
)	O
{	O
return	O
(	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
rp	pointer
->	O
size	int
,	O
NULL	O
,	O
&	O
infop	pointer
->	O
addr	pointer
)	O
)	O
;	O
}	O
if	O
(	O
CDB___db_jump	struct
.	O
j_map	pointer
!=	O
NULL	O
)	O
return	O
(	O
CDB___db_jump	struct
.	O
j_map	pointer
(	O
infop	pointer
->	O
name	pointer
,	O
rp	pointer
->	O
size	long
,	O
1	int
,	O
0	int
,	O
&	O
infop	pointer
->	O
addr	pointer
)	O
)	O
;	O
return	O
(	O
CDB___os_r_sysattach	function
(	O
dbenv	pointer
,	O
infop	pointer
,	O
rp	pointer
)	O
)	O
;	O
}	O
int	O
CDB___os_r_detach	function
(	O
dbenv	pointer
,	O
infop	pointer
,	O
destroy	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
REGINFO	struct
*	O
infop	pointer
;	O
int	O
destroy	int
;	O
{	O
REGION	struct
*	O
rp	pointer
;	O
rp	pointer
=	O
infop	pointer
->	O
rp	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_PRIVATE	pointer
)	O
)	O
{	O
CDB___os_free	function
(	O
infop	pointer
->	O
addr	pointer
,	O
rp	pointer
->	O
size	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
CDB___db_jump	struct
.	O
j_unmap	pointer
!=	O
NULL	O
)	O
return	O
(	O
CDB___db_jump	struct
.	O
j_unmap	pointer
(	O
infop	pointer
->	O
addr	pointer
,	O
rp	pointer
->	O
size	long
)	O
)	O
;	O
return	O
(	O
CDB___os_r_sysdetach	function
(	O
dbenv	pointer
,	O
infop	pointer
,	O
destroy	pointer
)	O
)	O
;	O
}	O
static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: os_rw.c,v 1.4 2000/06/28 16:47:02 loic Exp $"	pointer
;	O
int	O
CDB___os_io	function
(	O
dbenv	pointer
,	O
db_iop	pointer
,	O
op	pointer
,	O
niop	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_IO	struct
*	O
db_iop	pointer
;	O
int	O
op	int
;	O
size_t	long
*	O
niop	pointer
;	O
{	O
int	O
ret	int
;	O
MUTEX_THREAD_LOCK	O
(	O
db_iop	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_seek	function
(	O
dbenv	pointer
,	O
db_iop	pointer
->	O
fhp	pointer
,	O
db_iop	pointer
->	O
pagesize	long
,	O
db_iop	pointer
->	O
pgno	int
,	O
0	int
,	O
0	int
,	O
DB_OS_SEEK_SET	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
switch	O
(	O
op	int
)	O
{	O
case	O
DB_IO_READ	int
:	O
ret	int
=	O
CDB___os_read	function
(	O
dbenv	pointer
,	O
db_iop	pointer
->	O
fhp	pointer
,	O
db_iop	pointer
->	O
buf	pointer
,	O
db_iop	pointer
->	O
bytes	pointer
,	O
niop	pointer
)	O
;	O
break	O
;	O
case	O
DB_IO_WRITE	int
:	O
ret	int
=	O
CDB___os_write	function
(	O
dbenv	pointer
,	O
db_iop	pointer
->	O
fhp	pointer
,	O
db_iop	pointer
->	O
buf	pointer
,	O
db_iop	pointer
->	O
bytes	pointer
,	O
niop	pointer
)	O
;	O
break	O
;	O
}	O
err	pointer
:	O
MUTEX_THREAD_UNLOCK	O
(	O
db_iop	pointer
->	O
mutexp	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___os_read	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
addr	pointer
,	O
len	long
,	O
nrp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
void	O
*	O
addr	pointer
;	O
size_t	long
len	int
;	O
size_t	long
*	O
nrp	pointer
;	O
{	O
size_t	long
offset	long
;	O
ssize_t	long
nr	long
;	O
int	O
ret	int
;	O
u_int8_t	char
*	O
taddr	pointer
;	O
for	O
(	O
taddr	pointer
=	O
addr	pointer
,	O
offset	long
=	O
0	int
;	O
offset	long
<	O
len	int
;	O
taddr	long
+=	O
nr	long
,	O
offset	int
+=	O
nr	int
)	O
{	O
if	O
(	O
(	O
nr	long
=	O
CDB___db_jump	struct
.	O
j_read	pointer
!=	O
NULL	O
?	O
CDB___db_jump	struct
.	O
j_read	pointer
(	O
fhp	pointer
->	O
fd	pointer
,	O
taddr	pointer
,	O
len	long
-	O
offset	long
)	O
:	O
read	function
(	O
fhp	pointer
->	O
fd	pointer
,	O
taddr	pointer
,	O
len	long
-	O
offset	long
)	O
)	O
<	O
0	int
)	O
{	O
ret	int
=	O
CDB___os_get_errno	function
(	O
)	O
;	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"read: 0x%x, %lu: %s"	pointer
,	O
taddr	pointer
,	O
(	O
u_long	long
)	O
len	int
-	O
offset	long
,	O
strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
nr	long
==	O
0	int
)	O
break	O
;	O
}	O
*	O
nrp	pointer
=	O
taddr	int
-	O
(	O
u_int8_t	char
*	O
)	O
addr	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___os_write	function
(	O
dbenv	pointer
,	O
fhp	pointer
,	O
addr	pointer
,	O
len	long
,	O
nwp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_FH	struct
*	O
fhp	pointer
;	O
void	O
*	O
addr	pointer
;	O
size_t	long
len	int
;	O
size_t	long
*	O
nwp	pointer
;	O
{	O
size_t	long
offset	long
;	O
ssize_t	long
nw	long
;	O
int	O
ret	int
;	O
u_int8_t	char
*	O
taddr	pointer
;	O
for	O
(	O
taddr	pointer
=	O
addr	pointer
,	O
offset	long
=	O
0	int
;	O
offset	long
<	O
len	int
;	O
taddr	long
+=	O
nw	long
,	O
offset	long
+=	O
nw	long
)	O
if	O
(	O
(	O
nw	long
=	O
CDB___db_jump	struct
.	O
j_write	pointer
!=	O
NULL	O
?	O
CDB___db_jump	struct
.	O
j_write	pointer
(	O
fhp	pointer
->	O
fd	pointer
,	O
taddr	pointer
,	O
len	long
-	O
offset	long
)	O
:	O
write	function
(	O
fhp	pointer
->	O
fd	pointer
,	O
taddr	pointer
,	O
len	long
-	O
offset	long
)	O
)	O
<	O
0	int
)	O
{	O
ret	int
=	O
CDB___os_get_errno	function
(	O
)	O
;	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"write: 0x%x, %lu: %s"	pointer
,	O
taddr	pointer
,	O
(	O
u_long	long
)	O
len	int
-	O
offset	long
,	O
strerror	function
(	O
ret	int
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
*	O
nwp	pointer
=	O
len	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: qam_upgrade.c,v 1.3 2014/04/17 20:27:41 sebdiaz Exp $"	pointer
;	O
int	O
CDB___qam_31_qammeta	function
(	O
dbp	pointer
,	O
real_name	pointer
,	O
buf	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
char	O
*	O
real_name	pointer
;	O
u_int8_t	char
*	O
buf	pointer
;	O
{	O
if	O
(	O
dbp	pointer
||	O
real_name	pointer
)	O
{	O
}	O
QMETA31	struct
*	O
newmeta	pointer
;	O
QMETA30	struct
*	O
oldmeta	pointer
;	O
COMPQUIET	O
(	O
dbp	pointer
,	O
NULL	O
)	O
;	O
COMPQUIET	O
(	O
real_name	pointer
,	O
NULL	O
)	O
;	O
newmeta	pointer
=	O
(	O
QMETA31	struct
*	O
)	O
buf	pointer
;	O
oldmeta	pointer
=	O
(	O
QMETA30	struct
*	O
)	O
buf	pointer
;	O
newmeta	pointer
->	O
rec_page	int
=	O
oldmeta	pointer
->	O
rec_page	int
;	O
newmeta	pointer
->	O
re_pad	int
=	O
oldmeta	pointer
->	O
re_pad	int
;	O
newmeta	pointer
->	O
re_len	int
=	O
oldmeta	pointer
->	O
re_len	int
;	O
newmeta	pointer
->	O
cur_recno	int
=	O
oldmeta	pointer
->	O
cur_recno	int
;	O
newmeta	pointer
->	O
first_recno	pointer
=	O
oldmeta	pointer
->	O
first_recno	pointer
;	O
newmeta	pointer
->	O
start	pointer
=	O
oldmeta	pointer
->	O
start	pointer
;	O
memmove	function
(	O
newmeta	pointer
->	O
dbmeta	struct
.	O
uid	int
,	O
oldmeta	pointer
->	O
dbmeta	struct
.	O
uid	int
,	O
sizeof	O
(	O
oldmeta	pointer
->	O
dbmeta	struct
.	O
uid	int
)	O
)	O
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
flags	int
=	O
oldmeta	pointer
->	O
dbmeta	struct
.	O
flags	int
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
record_count	int
=	O
0	int
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
key_count	int
=	O
0	int
;	O
ZERO_LSN	O
(	O
newmeta	pointer
->	O
dbmeta	struct
.	O
alloc_lsn	int
)	O
;	O
newmeta	pointer
->	O
dbmeta	struct
.	O
version	int
=	O
2	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: xa_db.c,v 1.3 2000/06/28 16:47:03 loic Exp $"	pointer
;	O
static	O
int	O
__xa_close	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__xa_cursor	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
DBC	struct
*	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__xa_del	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__xa_get	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
static	O
int	O
__xa_put	function
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
typedef	O
struct	O
__xa_methods	struct
{	O
int	O
(	O
*	O
close	pointer
)	O
__P	O
(	O
(	O
DB	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
int	O
(	O
*	O
cursor	pointer
)	O
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
DBC	struct
*	O
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
int	O
(	O
*	O
del	pointer
)	O
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
int	O
(	O
*	O
get	pointer
)	O
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
int	O
(	O
*	O
put	pointer
)	O
__P	O
(	O
(	O
DB	struct
*	O
,	O
DB_TXN	struct
*	O
,	O
DBT	struct
*	O
,	O
DBT	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
}	O
XA_METHODS	pointer
;	O
int	O
CDB___db_xa_create	function
(	O
dbp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
{	O
XA_METHODS	struct
*	O
xam	pointer
;	O
int	O
ret	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
XA_METHODS	pointer
)	O
,	O
&	O
xam	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
dbp	pointer
->	O
xa_internal	pointer
=	O
xam	pointer
;	O
xam	pointer
->	O
close	pointer
=	O
dbp	pointer
->	O
close	pointer
;	O
xam	pointer
->	O
cursor	double
=	O
dbp	pointer
->	O
cursor	pointer
;	O
xam	pointer
->	O
del	int
=	O
dbp	pointer
->	O
del	pointer
;	O
xam	pointer
->	O
get	pointer
=	O
dbp	pointer
->	O
get	pointer
;	O
xam	pointer
->	O
put	int
=	O
dbp	pointer
->	O
put	int
;	O
dbp	pointer
->	O
close	pointer
=	O
__xa_close	int
;	O
dbp	pointer
->	O
cursor	pointer
=	O
__xa_cursor	int
;	O
dbp	pointer
->	O
del	pointer
=	O
__xa_del	pointer
;	O
dbp	pointer
->	O
get	pointer
=	O
__xa_get	int
;	O
dbp	pointer
->	O
put	int
=	O
__xa_put	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__xa_cursor	function
(	O
dbp	pointer
,	O
txn	pointer
,	O
dbcp	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_TXN	struct
*	O
txn	pointer
;	O
DBC	struct
*	O
*	O
dbcp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_TXN	struct
*	O
t	pointer
;	O
t	pointer
=	O
txn	pointer
!=	O
NULL	O
&&	O
txn	pointer
==	O
dbp	pointer
->	O
open_txn	pointer
?	O
txn	pointer
:	O
dbp	pointer
->	O
dbenv	pointer
->	O
xa_txn	pointer
;	O
if	O
(	O
t	pointer
->	O
txnid	int
==	O
TXN_INVALID	int
)	O
t	pointer
=	O
NULL	O
;	O
return	O
(	O
(	O
(	O
XA_METHODS	struct
*	O
)	O
dbp	pointer
->	O
xa_internal	pointer
)	O
->	O
cursor	pointer
(	O
dbp	pointer
,	O
t	pointer
,	O
dbcp	pointer
,	O
flags	int
)	O
)	O
;	O
}	O
static	O
int	O
__xa_del	function
(	O
dbp	pointer
,	O
txn	pointer
,	O
key	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_TXN	struct
*	O
txn	pointer
;	O
DBT	struct
*	O
key	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_TXN	struct
*	O
t	pointer
;	O
t	pointer
=	O
txn	pointer
!=	O
NULL	O
&&	O
txn	pointer
==	O
dbp	pointer
->	O
open_txn	pointer
?	O
txn	pointer
:	O
dbp	pointer
->	O
dbenv	pointer
->	O
xa_txn	pointer
;	O
if	O
(	O
t	pointer
->	O
txnid	int
==	O
TXN_INVALID	int
)	O
t	pointer
=	O
NULL	O
;	O
return	O
(	O
(	O
(	O
XA_METHODS	struct
*	O
)	O
dbp	pointer
->	O
xa_internal	pointer
)	O
->	O
del	pointer
(	O
dbp	pointer
,	O
t	pointer
,	O
key	pointer
,	O
flags	int
)	O
)	O
;	O
}	O
static	O
int	O
__xa_close	function
(	O
dbp	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
int	O
(	O
*	O
real_close	pointer
)	O
__P	O
(	O
(	O
DB	struct
*	O
,	O
u_int32_t	int
)	O
)	O
;	O
real_close	pointer
=	O
(	O
(	O
XA_METHODS	struct
*	O
)	O
dbp	pointer
->	O
xa_internal	pointer
)	O
->	O
close	pointer
;	O
CDB___os_free	function
(	O
dbp	pointer
->	O
xa_internal	pointer
,	O
sizeof	O
(	O
XA_METHODS	pointer
)	O
)	O
;	O
dbp	pointer
->	O
xa_internal	pointer
=	O
NULL	O
;	O
return	O
(	O
real_close	function
(	O
dbp	pointer
,	O
flags	int
)	O
)	O
;	O
}	O
static	O
int	O
__xa_get	function
(	O
dbp	pointer
,	O
txn	pointer
,	O
key	pointer
,	O
data	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_TXN	struct
*	O
txn	pointer
;	O
DBT	struct
*	O
key	pointer
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_TXN	struct
*	O
t	pointer
;	O
t	pointer
=	O
txn	pointer
!=	O
NULL	O
&&	O
txn	pointer
==	O
dbp	pointer
->	O
open_txn	pointer
?	O
txn	pointer
:	O
dbp	pointer
->	O
dbenv	pointer
->	O
xa_txn	pointer
;	O
if	O
(	O
t	pointer
->	O
txnid	int
==	O
TXN_INVALID	int
)	O
t	pointer
=	O
NULL	O
;	O
return	O
(	O
(	O
(	O
XA_METHODS	struct
*	O
)	O
dbp	pointer
->	O
xa_internal	pointer
)	O
->	O
get	pointer
(	O
dbp	pointer
,	O
t	int
,	O
key	pointer
,	O
data	pointer
,	O
flags	int
)	O
)	O
;	O
}	O
static	O
int	O
__xa_put	function
(	O
dbp	pointer
,	O
txn	pointer
,	O
key	pointer
,	O
data	pointer
,	O
flags	int
)	O
DB	struct
*	O
dbp	pointer
;	O
DB_TXN	struct
*	O
txn	pointer
;	O
DBT	struct
*	O
key	pointer
,	O
*	O
data	pointer
;	O
u_int32_t	int
flags	int
;	O
{	O
DB_TXN	struct
*	O
t	pointer
;	O
t	pointer
=	O
txn	pointer
!=	O
NULL	O
&&	O
txn	pointer
==	O
dbp	pointer
->	O
open_txn	pointer
?	O
txn	pointer
:	O
dbp	pointer
->	O
dbenv	pointer
->	O
xa_txn	pointer
;	O
if	O
(	O
t	pointer
->	O
txnid	int
==	O
TXN_INVALID	int
)	O
t	pointer
=	O
NULL	O
;	O
return	O
(	O
(	O
(	O
XA_METHODS	struct
*	O
)	O
dbp	pointer
->	O
xa_internal	pointer
)	O
->	O
put	function
(	O
dbp	pointer
,	O
t	pointer
,	O
key	pointer
,	O
data	pointer
,	O
flags	int
)	O
)	O
;	O
}	O
typedef	O
int	O
make_iso_compilers_happy	int
;	O
typedef	O
struct	O
Filter_t	O
{	O
Class_t	struct
*	O
Class	pointer
;	O
int	O
refs	int
;	O
Stream_t	struct
*	O
Next	pointer
;	O
Stream_t	struct
*	O
Buffer	pointer
;	O
int	O
dospos	int
;	O
int	O
unixpos	int
;	O
int	O
mode	int
;	O
int	O
rw	int
;	O
int	O
lastchar	int
;	O
}	O
Filter_t	struct
;	O
static	O
int	O
read_filter	function
(	O
Stream_t	struct
*	O
Stream	pointer
,	O
char	O
*	O
buf	pointer
,	O
mt_off_t	long
iwhere	long
,	O
size_t	long
len	int
)	O
{	O
DeclareThis	O
(	O
Filter_t	pointer
)	O
;	O
int	O
i	int
,	O
j	int
,	O
ret	int
;	O
unsigned	O
char	O
newchar	int
;	O
off_t	long
where	long
=	O
truncBytes32	function
(	O
iwhere	pointer
)	O
;	O
if	O
(	O
where	long
!=	O
This	pointer
->	O
unixpos	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Bad offset\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
This	pointer
->	O
rw	O
==	O
F_WRITE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Change of transfer direction!\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
This	pointer
->	O
rw	O
=	O
F_READ	int
;	O
ret	int
=	O
READS	O
(	O
This	pointer
->	O
Next	pointer
,	O
buf	pointer
,	O
(	O
mt_off_t	long
)	O
This	pointer
->	O
dospos	pointer
,	O
len	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
ret	int
;	O
j	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ret	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
buf	pointer
[	O
i	int
]	O
==	O
'\r'	O
)	O
continue	O
;	O
if	O
(	O
buf	pointer
[	O
i	int
]	O
==	O
0x1a	int
)	O
break	O
;	O
newchar	pointer
=	O
buf	pointer
[	O
i	int
]	O
;	O
This	pointer
->	O
lastchar	pointer
=	O
buf	pointer
[	O
j	int
++	O
]	O
=	O
newchar	int
;	O
}	O
This	pointer
->	O
dospos	int
+=	O
i	int
;	O
This	pointer
->	O
unixpos	int
+=	O
j	int
;	O
return	O
j	int
;	O
}	O
static	O
int	O
write_filter	function
(	O
Stream_t	struct
*	O
Stream	pointer
,	O
char	O
*	O
buf	pointer
,	O
mt_off_t	long
iwhere	long
,	O
size_t	long
len	long
)	O
{	O
DeclareThis	O
(	O
Filter_t	pointer
)	O
;	O
unsigned	O
int	O
i	int
,	O
j	int
;	O
int	O
ret	int
;	O
char	O
buffer	array
[	O
1025	int
]	O
;	O
unsigned	O
char	O
newchar	int
;	O
off_t	long
where	long
=	O
truncBytes32	function
(	O
iwhere	pointer
)	O
;	O
if	O
(	O
This	pointer
->	O
unixpos	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
where	long
!=	O
This	pointer
->	O
unixpos	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Bad offset\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
This	pointer
->	O
rw	O
==	O
F_READ	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Change of transfer direction!\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
This	pointer
->	O
rw	int
=	O
F_WRITE	int
;	O
j	int
=	O
i	int
=	O
0	int
;	O
while	O
(	O
i	int
<	O
1024	int
&&	O
j	int
<	O
len	int
)	O
{	O
if	O
(	O
buf	pointer
[	O
j	int
]	O
==	O
'\n'	O
)	O
{	O
buffer	pointer
[	O
i	int
++	O
]	O
=	O
'\r'	O
;	O
buffer	pointer
[	O
i	int
++	O
]	O
=	O
'\n'	O
;	O
j	int
++	O
;	O
continue	O
;	O
}	O
newchar	int
=	O
buf	pointer
[	O
j	int
++	O
]	O
;	O
buffer	pointer
[	O
i	int
++	O
]	O
=	O
newchar	int
;	O
}	O
This	pointer
->	O
unixpos	int
+=	O
j	int
;	O
ret	int
=	O
force_write	function
(	O
This	pointer
->	O
Next	pointer
,	O
buffer	pointer
,	O
(	O
mt_off_t	long
)	O
This	pointer
->	O
dospos	pointer
,	O
i	int
)	O
;	O
if	O
(	O
ret	int
>	O
0	int
)	O
This	pointer
->	O
dospos	int
+=	O
ret	int
;	O
if	O
(	O
ret	int
!=	O
(	O
signed	O
int	O
)	O
i	int
)	O
{	O
This	pointer
->	O
unixpos	int
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
j	int
;	O
}	O
static	O
int	O
free_filter	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
DeclareThis	O
(	O
Filter_t	pointer
)	O
;	O
char	O
buffer	int
=	O
0x1a	int
;	O
if	O
(	O
This	pointer
->	O
rw	O
==	O
F_WRITE	int
)	O
return	O
force_write	function
(	O
This	pointer
->	O
Next	pointer
,	O
&	O
buffer	pointer
,	O
(	O
mt_off_t	long
)	O
This	pointer
->	O
dospos	pointer
,	O
1	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
static	O
Class_t	struct
FilterClass	struct
=	O
{	O
read_filter	pointer
,	O
write_filter	int
,	O
0	int
,	O
free_filter	function
,	O
0	int
,	O
get_data_pass_through	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
Stream_t	struct
*	O
open_filter	function
(	O
Stream_t	struct
*	O
Next	pointer
,	O
int	O
convertCharset	enum
UNUSEDP	O
)	O
{	O
Filter_t	struct
*	O
This	pointer
;	O
This	pointer
=	O
New	O
(	O
Filter_t	pointer
)	O
;	O
if	O
(	O
!	O
This	pointer
)	O
return	O
NULL	O
;	O
This	pointer
->	O
Class	pointer
=	O
&	O
FilterClass	O
;	O
This	pointer
->	O
dospos	int
=	O
This	pointer
->	O
unixpos	int
=	O
This	pointer
->	O
rw	int
=	O
0	int
;	O
This	pointer
->	O
Next	pointer
=	O
Next	pointer
;	O
This	pointer
->	O
refs	int
=	O
1	int
;	O
This	pointer
->	O
Buffer	pointer
=	O
0	int
;	O
return	O
(	O
Stream_t	struct
*	O
)	O
This	pointer
;	O
}	O
void	O
printOom	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Out of memory error"	pointer
)	O
;	O
}	O
char	O
*	O
get_homedir	function
(	O
void	O
)	O
{	O
struct	O
passwd	struct
*	O
pw	pointer
;	O
uid_t	int
uid	int
;	O
char	O
*	O
homedir	pointer
;	O
char	O
*	O
username	pointer
;	O
homedir	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
homedir	pointer
)	O
return	O
homedir	pointer
;	O
pw	pointer
=	O
0	int
;	O
username	pointer
=	O
getenv	function
(	O
"LOGNAME"	pointer
)	O
;	O
if	O
(	O
!	O
username	pointer
)	O
username	pointer
=	O
getlogin	function
(	O
)	O
;	O
if	O
(	O
username	pointer
)	O
pw	pointer
=	O
getpwnam	function
(	O
username	pointer
)	O
;	O
if	O
(	O
pw	pointer
==	O
0	int
)	O
{	O
uid	int
=	O
geteuid	function
(	O
)	O
;	O
pw	pointer
=	O
getpwuid	function
(	O
uid	int
)	O
;	O
}	O
if	O
(	O
pw	pointer
)	O
return	O
pw	pointer
->	O
pw_dir	pointer
;	O
return	O
0	int
;	O
}	O
static	O
void	O
get_mcwd_file_name	function
(	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
mcwd_path	pointer
;	O
const	O
char	O
*	O
homedir	pointer
;	O
mcwd_path	pointer
=	O
getenv	function
(	O
"MCWD"	pointer
)	O
;	O
if	O
(	O
mcwd_path	pointer
==	O
NULL	O
||	O
*	O
mcwd_path	pointer
==	O
'\0'	O
)	O
{	O
homedir	pointer
=	O
get_homedir	function
(	O
)	O
;	O
if	O
(	O
!	O
homedir	pointer
)	O
homedir	pointer
=	O
"/tmp"	pointer
;	O
strncpy	function
(	O
file	pointer
,	O
homedir	pointer
,	O
MAXPATHLEN	O
-	O
6	int
)	O
;	O
file	pointer
[	O
MAXPATHLEN	O
-	O
6	int
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
file	pointer
,	O
"/.mcwd"	pointer
)	O
;	O
}	O
else	O
{	O
strncpy	function
(	O
file	pointer
,	O
mcwd_path	pointer
,	O
MAXPATHLEN	O
)	O
;	O
file	pointer
[	O
MAXPATHLEN	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
void	O
unlink_mcwd	function
(	O
void	O
)	O
{	O
char	O
file	pointer
[	O
MAXPATHLEN	O
+	O
1	int
]	O
;	O
get_mcwd_file_name	function
(	O
file	pointer
)	O
;	O
unlink	function
(	O
file	pointer
)	O
;	O
}	O
FILE	struct
*	O
open_mcwd	function
(	O
const	O
char	O
*	O
mode	pointer
)	O
{	O
struct	O
MT_STAT	O
sbuf	struct
;	O
char	O
file	pointer
[	O
MAXPATHLEN	O
+	O
1	int
]	O
;	O
time_t	long
now	long
;	O
get_mcwd_file_name	function
(	O
file	pointer
)	O
;	O
if	O
(	O
*	O
mode	pointer
==	O
'r'	O
)	O
{	O
if	O
(	O
MT_STAT	O
(	O
file	pointer
,	O
&	O
sbuf	struct
)	O
<	O
0	int
)	O
return	O
NULL	O
;	O
getTimeNow	function
(	O
&	O
now	pointer
)	O
;	O
if	O
(	O
now	long
-	O
sbuf	struct
.	O
st_mtime	O
>	O
6	int
*	O
60	int
*	O
60	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: \"%s\" is out of date, removing it\n"	pointer
,	O
file	pointer
)	O
;	O
unlink	function
(	O
file	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
return	O
fopen	function
(	O
file	pointer
,	O
mode	pointer
)	O
;	O
}	O
void	O
*	O
safe_malloc	function
(	O
size_t	long
size	int
)	O
{	O
void	O
*	O
p	pointer
;	O
p	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
printOom	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
void	O
print_sector	function
(	O
const	O
char	O
*	O
message	pointer
,	O
unsigned	O
char	O
*	O
data	pointer
,	O
int	O
size	int
)	O
{	O
int	O
col	int
;	O
int	O
row	int
;	O
printf	function
(	O
"%s:\n"	pointer
,	O
message	pointer
)	O
;	O
for	O
(	O
row	int
=	O
0	int
;	O
row	int
*	O
16	int
<	O
size	int
;	O
row	int
++	O
)	O
{	O
printf	function
(	O
"%03x  "	pointer
,	O
row	int
*	O
16	int
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
16	int
;	O
col	int
++	O
)	O
printf	function
(	O
"%02x "	pointer
,	O
data	pointer
[	O
row	int
*	O
16	int
+	O
col	int
]	O
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
16	int
;	O
col	int
++	O
)	O
{	O
if	O
(	O
isprint	function
(	O
data	pointer
[	O
row	int
*	O
16	int
+	O
col	int
]	O
)	O
)	O
printf	function
(	O
"%c"	pointer
,	O
data	pointer
[	O
row	int
*	O
16	int
+	O
col	int
]	O
)	O
;	O
else	O
printf	function
(	O
"."	pointer
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
time_t	long
getTimeNow	function
(	O
time_t	long
*	O
now	long
)	O
{	O
static	O
int	O
haveTime	int
=	O
0	int
;	O
static	O
time_t	long
sharedNow	long
;	O
if	O
(	O
!	O
haveTime	pointer
)	O
{	O
const	O
char	O
*	O
source_date_epoch	pointer
=	O
getenv	function
(	O
"SOURCE_DATE_EPOCH"	pointer
)	O
;	O
if	O
(	O
source_date_epoch	pointer
)	O
{	O
char	O
*	O
endptr	pointer
;	O
errno	O
=	O
0	int
;	O
time_t	long
epoch	long
=	O
STRTOTIME	function
(	O
source_date_epoch	int
,	O
&	O
endptr	pointer
,	O
10	int
)	O
;	O
if	O
(	O
endptr	pointer
==	O
source_date_epoch	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"SOURCE_DATE_EPOCH \"%s\" invalid\n"	pointer
,	O
source_date_epoch	pointer
)	O
;	O
else	O
if	O
(	O
errno	O
!=	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"SOURCE_DATE_EPOCH: strtoll: %s: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
,	O
source_date_epoch	pointer
)	O
;	O
else	O
if	O
(	O
*	O
endptr	pointer
!=	O
'\0'	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"SOURCE_DATE_EPOCH has trailing garbage \"%s\"\n"	pointer
,	O
endptr	pointer
)	O
;	O
else	O
{	O
sharedNow	int
=	O
epoch	int
;	O
haveTime	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
haveTime	pointer
)	O
{	O
time	function
(	O
&	O
sharedNow	int
)	O
;	O
haveTime	int
=	O
1	int
;	O
}	O
if	O
(	O
now	long
)	O
*	O
now	pointer
=	O
sharedNow	pointer
;	O
return	O
sharedNow	int
;	O
}	O
off_t	long
str_to_offset	function
(	O
char	O
*	O
str	pointer
)	O
{	O
char	O
s	pointer
,	O
*	O
endp	pointer
=	O
NULL	O
;	O
off_t	long
ofs	long
;	O
ofs	long
=	O
strtol	function
(	O
str	pointer
,	O
&	O
endp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ofs	long
<=	O
0	int
)	O
return	O
0	int
;	O
s	long
=	O
*	O
endp	pointer
++	O
;	O
if	O
(	O
s	long
)	O
{	O
if	O
(	O
s	long
==	O
's'	O
||	O
s	long
==	O
'S'	O
)	O
ofs	long
<<=	O
9	int
;	O
else	O
if	O
(	O
s	long
==	O
'k'	O
||	O
s	O
==	O
'K'	O
)	O
ofs	long
<<=	O
10	int
;	O
else	O
if	O
(	O
s	long
==	O
'm'	O
||	O
s	long
==	O
'M'	O
)	O
ofs	long
<<=	O
20	int
;	O
else	O
if	O
(	O
s	long
==	O
'g'	O
||	O
s	long
==	O
'G'	O
)	O
ofs	long
<<=	O
30	int
;	O
else	O
return	O
0	int
;	O
if	O
(	O
*	O
endp	pointer
)	O
return	O
0	int
;	O
}	O
return	O
ofs	long
;	O
}	O
typedef	O
struct	O
Arg_t	struct
{	O
char	O
*	O
target	pointer
;	O
MainParam_t	struct
mp	pointer
;	O
Stream_t	struct
*	O
SrcDir	pointer
;	O
int	O
entry	int
;	O
ClashHandling_t	O
ch	char
;	O
Stream_t	struct
*	O
targetDir	pointer
;	O
}	O
Arg_t	struct
;	O
typedef	O
struct	O
CreateArg_t	struct
{	O
Stream_t	struct
*	O
Dir	pointer
;	O
Stream_t	struct
*	O
NewDir	pointer
;	O
unsigned	O
char	O
attr	array
;	O
time_t	long
mtime	long
;	O
}	O
CreateArg_t	struct
;	O
static	O
int	O
makeit	function
(	O
dos_name_t	struct
*	O
dosname	pointer
,	O
char	O
*	O
longname	array
UNUSEDP	O
,	O
void	O
*	O
arg0	pointer
,	O
direntry_t	struct
*	O
targetEntry	int
)	O
{	O
Stream_t	struct
*	O
Target	pointer
;	O
CreateArg_t	struct
*	O
arg	pointer
=	O
(	O
CreateArg_t	struct
*	O
)	O
arg0	pointer
;	O
int	O
fat	int
;	O
direntry_t	struct
subEntry	struct
;	O
if	O
(	O
!	O
getfreeMinClusters	function
(	O
targetEntry	pointer
->	O
Dir	pointer
,	O
1	int
)	O
)	O
return	O
-	O
1	int
;	O
mk_entry	function
(	O
dosname	pointer
,	O
ATTR_DIR	int
,	O
1	int
,	O
0	int
,	O
arg	pointer
->	O
mtime	pointer
,	O
&	O
targetEntry	pointer
->	O
dir	pointer
)	O
;	O
Target	pointer
=	O
OpenFileByDirentry	function
(	O
targetEntry	pointer
)	O
;	O
if	O
(	O
!	O
Target	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Could not open Target\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
initializeDirentry	function
(	O
&	O
subEntry	struct
,	O
Target	pointer
)	O
;	O
subEntry	struct
.	O
entry	int
=	O
1	int
;	O
GET_DATA	O
(	O
targetEntry	pointer
->	O
Dir	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
&	O
fat	int
)	O
;	O
if	O
(	O
fat	int
==	O
fat32RootCluster	function
(	O
targetEntry	pointer
->	O
Dir	pointer
)	O
)	O
{	O
fat	int
=	O
0	int
;	O
}	O
mk_entry_from_base	function
(	O
"..      "	int
,	O
ATTR_DIR	int
,	O
fat	int
,	O
0	int
,	O
arg	pointer
->	O
mtime	pointer
,	O
&	O
subEntry	struct
.	O
dir	int
)	O
;	O
dir_write	function
(	O
&	O
subEntry	struct
)	O
;	O
FLUSH	function
(	O
(	O
Stream_t	struct
*	O
)	O
Target	pointer
)	O
;	O
subEntry	struct
.	O
entry	int
=	O
0	int
;	O
GET_DATA	O
(	O
Target	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
&	O
fat	int
)	O
;	O
mk_entry_from_base	function
(	O
".       "	int
,	O
ATTR_DIR	int
,	O
fat	int
,	O
0	int
,	O
arg	pointer
->	O
mtime	pointer
,	O
&	O
subEntry	struct
.	O
dir	int
)	O
;	O
dir_write	function
(	O
&	O
subEntry	struct
)	O
;	O
mk_entry	function
(	O
dosname	pointer
,	O
ATTR_DIR	int
|	O
arg	pointer
->	O
attr	array
,	O
fat	int
,	O
0	int
,	O
arg	pointer
->	O
mtime	pointer
,	O
&	O
targetEntry	pointer
->	O
dir	pointer
)	O
;	O
arg	pointer
->	O
NewDir	pointer
=	O
Target	pointer
;	O
return	O
0	int
;	O
}	O
static	O
void	O
usage	function
(	O
int	O
ret	int
)	O
NORETURN	O
;	O
static	O
void	O
usage	function
(	O
int	O
ret	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Mtools version %s, dated %s\n"	pointer
,	O
mversion	pointer
,	O
mdate	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Usage: %s [-D clash_option] file targetfile\n"	pointer
,	O
progname	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"       %s [-D clash_option] file [files...] target_directory\n"	pointer
,	O
progname	pointer
)	O
;	O
exit	function
(	O
ret	int
)	O
;	O
}	O
Stream_t	struct
*	O
createDir	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
ClashHandling_t	struct
*	O
ch	int
,	O
unsigned	O
char	O
attr	array
,	O
time_t	long
mtime	pointer
)	O
{	O
CreateArg_t	pointer
arg	pointer
;	O
int	O
ret	int
;	O
arg	pointer
.	O
Dir	pointer
=	O
Dir	pointer
;	O
arg	pointer
.	O
attr	int
=	O
attr	int
;	O
arg	pointer
.	O
mtime	pointer
=	O
mtime	pointer
;	O
if	O
(	O
!	O
getfreeMinClusters	function
(	O
Dir	pointer
,	O
1	int
)	O
)	O
return	O
NULL	O
;	O
ret	int
=	O
mwrite_one	function
(	O
Dir	pointer
,	O
filename	pointer
,	O
0	int
,	O
makeit	int
,	O
&	O
arg	pointer
,	O
ch	int
)	O
;	O
if	O
(	O
ret	int
<	O
1	int
)	O
return	O
NULL	O
;	O
else	O
return	O
arg	pointer
.	O
NewDir	int
;	O
}	O
static	O
int	O
createDirCallback	function
(	O
direntry_t	struct
*	O
entry	int
UNUSEDP	O
,	O
MainParam_t	struct
*	O
mp	pointer
)	O
{	O
Stream_t	struct
*	O
ret	pointer
;	O
time_t	long
now	long
;	O
ret	int
=	O
createDir	function
(	O
mp	pointer
->	O
File	pointer
,	O
mp	pointer
->	O
targetName	pointer
,	O
&	O
(	O
(	O
Arg_t	struct
*	O
)	O
(	O
mp	pointer
->	O
arg	pointer
)	O
)	O
->	O
ch	int
,	O
ATTR_DIR	pointer
,	O
getTimeNow	function
(	O
&	O
now	long
)	O
)	O
;	O
if	O
(	O
ret	int
==	O
NULL	O
)	O
return	O
ERROR_ONE	int
;	O
else	O
{	O
FREE	O
(	O
&	O
ret	pointer
)	O
;	O
return	O
GOT_ONE	int
;	O
}	O
}	O
void	O
mmd	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
type	enum
UNUSEDP	O
)	O
NORETURN	O
;	O
void	O
mmd	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
type	enum
UNUSEDP	O
)	O
{	O
Arg_t	struct
arg	pointer
;	O
int	O
c	double
;	O
init_clash_handling	function
(	O
&	O
arg	pointer
.	O
ch	int
)	O
;	O
if	O
(	O
helpFlag	function
(	O
argc	int
,	O
argv	pointer
)	O
)	O
usage	function
(	O
0	int
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt	function
(	O
argc	int
,	O
argv	pointer
,	O
"i:D:oh"	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'i'	O
:	O
set_cmd_line_image	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
usage	function
(	O
1	int
)	O
;	O
case	O
'o'	O
:	O
handle_clash_options	function
(	O
&	O
arg	pointer
.	O
ch	int
,	O
(	O
char	O
)	O
c	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
if	O
(	O
handle_clash_options	function
(	O
&	O
arg	pointer
.	O
ch	char
,	O
*	O
optarg	pointer
)	O
)	O
usage	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	function
(	O
0	int
)	O
;	O
default	O
:	O
usage	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
argc	int
-	O
optind	int
<	O
1	int
)	O
usage	function
(	O
1	int
)	O
;	O
init_mp	function
(	O
&	O
arg	pointer
.	O
mp	pointer
)	O
;	O
arg	pointer
.	O
mp	pointer
.	O
arg	pointer
=	O
(	O
void	O
*	O
)	O
&	O
arg	pointer
;	O
arg	pointer
.	O
mp	pointer
.	O
openflags	int
=	O
O_RDWR	int
;	O
arg	pointer
.	O
mp	pointer
.	O
callback	pointer
=	O
createDirCallback	int
;	O
arg	pointer
.	O
mp	pointer
.	O
lookupflags	int
=	O
OPEN_PARENT	int
|	O
DO_OPEN_DIRS	int
;	O
exit	function
(	O
main_loop	function
(	O
&	O
arg	pointer
.	O
mp	pointer
,	O
argv	pointer
+	O
optind	int
,	O
argc	int
-	O
optind	int
)	O
)	O
;	O
}	O
const	O
char	O
*	O
mversion	pointer
=	O
"4.0.23"	pointer
;	O
const	O
char	O
*	O
mdate	pointer
=	O
"December 9th, 2018"	pointer
;	O
const	O
char	O
*	O
mformat_banner	pointer
=	O
"MTOO4023"	pointer
;	O
int	O
got_signal	int
=	O
0	int
;	O
static	O
void	O
signal_handler	function
(	O
int	O
dummy	int
UNUSEDP	O
)	O
{	O
got_signal	int
=	O
1	int
;	O
}	O
void	O
setup_signal	function
(	O
void	O
)	O
{	O
signal	function
(	O
SIGHUP	int
,	O
signal_handler	function
)	O
;	O
signal	function
(	O
SIGINT	int
,	O
signal_handler	function
)	O
;	O
signal	function
(	O
SIGTERM	int
,	O
signal_handler	function
)	O
;	O
signal	function
(	O
SIGQUIT	int
,	O
signal_handler	function
)	O
;	O
}	O
static	O
void	O
_allow_interrupt	function
(	O
saved_sig_state	struct
*	O
ss	pointer
,	O
int	O
sig	int
,	O
int	O
slot	int
)	O
{	O
struct	O
sigaction	struct
new	struct
;	O
bzero	function
(	O
&	O
new	struct
,	O
sizeof	O
(	O
new	pointer
)	O
)	O
;	O
new	struct
.	O
sa_handler	pointer
=	O
signal_handler	function
;	O
new	struct
.	O
sa_flags	int
&=	O
~	O
SA_RESTART	int
;	O
if	O
(	O
sigaction	struct
(	O
sig	int
,	O
&	O
new	pointer
,	O
&	O
ss	struct
->	O
sa	pointer
[	O
slot	int
]	O
)	O
<	O
0	int
)	O
{	O
perror	function
(	O
"sigaction"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
allow_interrupts	function
(	O
saved_sig_state	struct
*	O
ss	pointer
)	O
{	O
_allow_interrupt	function
(	O
ss	O
,	O
SIGINT	int
,	O
0	int
)	O
;	O
_allow_interrupt	function
(	O
ss	pointer
,	O
SIGINT	int
,	O
1	int
)	O
;	O
_allow_interrupt	function
(	O
ss	O
,	O
SIGINT	int
,	O
2	int
)	O
;	O
_allow_interrupt	function
(	O
ss	long
,	O
SIGINT	int
,	O
3	int
)	O
;	O
}	O
static	O
void	O
_restore_interrupt	function
(	O
saved_sig_state	struct
*	O
ss	pointer
,	O
int	O
sig	int
,	O
int	O
slot	int
)	O
{	O
if	O
(	O
sigaction	struct
(	O
sig	int
,	O
&	O
ss	struct
->	O
sa	pointer
[	O
slot	int
]	O
,	O
NULL	O
)	O
<	O
0	int
)	O
{	O
perror	function
(	O
"restore sigaction"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
restore_interrupts	function
(	O
saved_sig_state	struct
*	O
ss	pointer
)	O
{	O
_restore_interrupt	function
(	O
ss	O
,	O
SIGINT	int
,	O
0	int
)	O
;	O
_restore_interrupt	function
(	O
ss	pointer
,	O
SIGINT	int
,	O
1	int
)	O
;	O
_restore_interrupt	function
(	O
ss	O
,	O
SIGINT	int
,	O
2	int
)	O
;	O
_restore_interrupt	function
(	O
ss	long
,	O
SIGINT	int
,	O
3	int
)	O
;	O
}	O
static	O
int	O
is_initialized	int
=	O
0	int
;	O
static	O
Stream_t	struct
*	O
fss	array
[	O
256	int
]	O
;	O
static	O
void	O
finish_sc	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
fss	array
[	O
i	int
]	O
&&	O
fss	array
[	O
i	int
]	O
->	O
refs	int
!=	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Streamcache allocation problem:%c %d\n"	pointer
,	O
i	int
,	O
fss	array
[	O
i	int
]	O
->	O
refs	int
)	O
;	O
FREE	O
(	O
&	O
(	O
fss	array
[	O
i	int
]	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
init_streamcache	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
if	O
(	O
is_initialized	int
)	O
return	O
;	O
is_initialized	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
fss	array
[	O
i	int
]	O
=	O
0	int
;	O
atexit	function
(	O
finish_sc	int
)	O
;	O
}	O
Stream_t	struct
*	O
open_root_dir	function
(	O
unsigned	O
char	O
drive	char
,	O
int	O
flags	int
,	O
int	O
*	O
isRop	pointer
)	O
{	O
Stream_t	struct
*	O
Fs	pointer
;	O
init_streamcache	function
(	O
)	O
;	O
drive	char
=	O
toupper	function
(	O
drive	char
)	O
;	O
if	O
(	O
fss	pointer
[	O
drive	int
]	O
)	O
Fs	pointer
=	O
fss	pointer
[	O
drive	int
]	O
;	O
else	O
{	O
Fs	pointer
=	O
fs_init	function
(	O
drive	char
,	O
flags	int
,	O
isRop	int
)	O
;	O
if	O
(	O
!	O
Fs	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot initialize '%c:'\n"	pointer
,	O
drive	char
)	O
;	O
return	O
NULL	O
;	O
}	O
fss	array
[	O
drive	int
]	O
=	O
Fs	pointer
;	O
}	O
return	O
OpenRoot	function
(	O
Fs	pointer
)	O
;	O
}	O
static	O
FILE	struct
*	O
tty	pointer
=	O
NULL	O
;	O
static	O
int	O
notty	int
=	O
0	int
;	O
static	O
int	O
ttyfd	int
=	O
-	O
1	int
;	O
int	O
mtools_raw_tty	int
=	O
1	int
;	O
typedef	O
struct	O
termios	struct
Terminal	struct
;	O
static	O
int	O
tty_mode	int
=	O
-	O
1	int
;	O
static	O
int	O
need_tty_reset	int
=	O
0	int
;	O
static	O
int	O
handlerIsSet	int
=	O
0	int
;	O
static	O
Terminal	struct
in_orig	pointer
;	O
static	O
void	O
tty_time_out	function
(	O
int	O
dummy	int
UNUSEDP	O
)	O
NORETURN	O
;	O
static	O
void	O
tty_time_out	function
(	O
int	O
dummy	int
UNUSEDP	O
)	O
{	O
int	O
exit_code	int
;	O
signal	function
(	O
SIGALRM	int
,	O
SIG_IGN	O
)	O
;	O
if	O
(	O
tty	int
&&	O
need_tty_reset	int
)	O
restore_tty	function
(	O
&	O
in_orig	int
)	O
;	O
exit_code	int
=	O
DONE	int
;	O
exit	function
(	O
exit_code	int
)	O
;	O
}	O
static	O
void	O
cleanup_tty	function
(	O
void	O
)	O
{	O
if	O
(	O
tty	int
&&	O
need_tty_reset	int
)	O
{	O
restore_tty	function
(	O
&	O
in_orig	struct
)	O
;	O
setup_signal	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
set_raw_tty	function
(	O
int	O
mode	int
)	O
{	O
Terminal	O
in_raw	int
;	O
if	O
(	O
mode	int
!=	O
tty_mode	int
&&	O
mode	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
handlerIsSet	int
)	O
{	O
gtty	function
(	O
STDIN	pointer
,	O
&	O
in_orig	pointer
)	O
;	O
need_tty_reset	int
=	O
1	int
;	O
atexit	function
(	O
cleanup_tty	int
)	O
;	O
handlerIsSet	int
=	O
1	int
;	O
}	O
setup_signal	function
(	O
)	O
;	O
signal	function
(	O
SIGALRM	int
,	O
tty_time_out	O
)	O
;	O
gtty	function
(	O
STDIN	pointer
,	O
&	O
in_raw	struct
)	O
;	O
if	O
(	O
mode	int
)	O
{	O
in_raw	struct
.	O
c_lflag	int
&=	O
~	O
ICANON	int
;	O
in_raw	struct
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
1	int
;	O
in_raw	struct
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
0	int
;	O
stty	function
(	O
STDIN	pointer
,	O
&	O
in_raw	struct
)	O
;	O
}	O
else	O
{	O
in_raw	struct
.	O
c_lflag	int
|=	O
ICANON	int
;	O
stty	function
(	O
STDIN	int
,	O
&	O
in_raw	O
)	O
;	O
}	O
tty_mode	enum
=	O
mode	int
;	O
discard_input	function
(	O
STDIN	pointer
)	O
;	O
}	O
}	O
FILE	struct
*	O
opentty	function
(	O
int	O
mode	int
)	O
{	O
if	O
(	O
notty	int
)	O
return	O
NULL	O
;	O
if	O
(	O
tty	pointer
==	O
NULL	O
)	O
{	O
ttyfd	int
=	O
open	function
(	O
"/dev/tty"	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
ttyfd	int
>=	O
0	int
)	O
{	O
tty	pointer
=	O
fdopen	function
(	O
ttyfd	int
,	O
"r"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
tty	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
isatty	function
(	O
0	int
)	O
)	O
{	O
notty	int
=	O
1	int
;	O
return	O
NULL	O
;	O
}	O
ttyfd	int
=	O
0	int
;	O
tty	pointer
=	O
stdin	pointer
;	O
}	O
if	O
(	O
mtools_raw_tty	int
)	O
set_raw_tty	function
(	O
mode	int
)	O
;	O
return	O
tty	int
;	O
}	O
int	O
ask_confirmation	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
char	O
ans	pointer
[	O
10	int
]	O
;	O
va_list	array
ap	array
;	O
if	O
(	O
!	O
opentty	function
(	O
-	O
1	int
)	O
)	O
return	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
va_start	O
(	O
ap	array
,	O
format	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
fflush	function
(	O
opentty	function
(	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
mtools_raw_tty	int
)	O
{	O
ans	pointer
[	O
0	int
]	O
=	O
fgetc	function
(	O
opentty	function
(	O
1	int
)	O
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
stderr	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
fgets	function
(	O
ans	int
,	O
9	int
,	O
opentty	function
(	O
0	int
)	O
)	O
==	O
NULL	O
)	O
ans	pointer
[	O
0	int
]	O
=	O
'n'	O
;	O
}	O
if	O
(	O
ans	pointer
[	O
0	int
]	O
==	O
'y'	O
||	O
ans	pointer
[	O
0	int
]	O
==	O
'Y'	O
)	O
return	O
0	int
;	O
if	O
(	O
ans	pointer
[	O
0	int
]	O
==	O
'n'	O
||	O
ans	pointer
[	O
0	int
]	O
==	O
'N'	O
)	O
return	O
-	O
1	int
;	O
}	O
}	O
static	O
const	O
uint32_t	int
mtable	array
[	O
0x100	int
]	O
=	O
{	O
0x00000000	int
,	O
0x0b0d090e	int
,	O
0x161a121c	int
,	O
0x1d171b12	int
,	O
0x2c342438	int
,	O
0x27392d36	int
,	O
0x3a2e3624	int
,	O
0x31233f2a	int
,	O
0x58684870	int
,	O
0x5365417e	int
,	O
0x4e725a6c	int
,	O
0x457f5362	int
,	O
0x745c6c48	int
,	O
0x7f516546	int
,	O
0x62467e54	int
,	O
0x694b775a	int
,	O
0xb0d090e0	int
,	O
0xbbdd99ee	int
,	O
0xa6ca82fc	int
,	O
0xadc78bf2	int
,	O
0x9ce4b4d8	int
,	O
0x97e9bdd6	int
,	O
0x8afea6c4	int
,	O
0x81f3afca	int
,	O
0xe8b8d890	int
,	O
0xe3b5d19e	int
,	O
0xfea2ca8c	int
,	O
0xf5afc382	int
,	O
0xc48cfca8	int
,	O
0xcf81f5a6	int
,	O
0xd296eeb4	int
,	O
0xd99be7ba	int
,	O
0x7bbb3bdb	int
,	O
0x70b632d5	int
,	O
0x6da129c7	int
,	O
0x66ac20c9	int
,	O
0x578f1fe3	int
,	O
0x5c8216ed	int
,	O
0x41950dff	int
,	O
0x4a9804f1	int
,	O
0x23d373ab	int
,	O
0x28de7aa5	int
,	O
0x35c961b7	int
,	O
0x3ec468b9	int
,	O
0x0fe75793	int
,	O
0x04ea5e9d	int
,	O
0x19fd458f	int
,	O
0x12f04c81	int
,	O
0xcb6bab3b	int
,	O
0xc066a235	int
,	O
0xdd71b927	int
,	O
0xd67cb029	int
,	O
0xe75f8f03	int
,	O
0xec52860d	int
,	O
0xf1459d1f	int
,	O
0xfa489411	int
,	O
0x9303e34b	int
,	O
0x980eea45	int
,	O
0x8519f157	int
,	O
0x8e14f859	int
,	O
0xbf37c773	int
,	O
0xb43ace7d	int
,	O
0xa92dd56f	int
,	O
0xa220dc61	int
,	O
0xf66d76ad	int
,	O
0xfd607fa3	int
,	O
0xe07764b1	int
,	O
0xeb7a6dbf	int
,	O
0xda595295	int
,	O
0xd1545b9b	int
,	O
0xcc434089	int
,	O
0xc74e4987	int
,	O
0xae053edd	int
,	O
0xa50837d3	int
,	O
0xb81f2cc1	int
,	O
0xb31225cf	int
,	O
0x82311ae5	int
,	O
0x893c13eb	int
,	O
0x942b08f9	int
,	O
0x9f2601f7	int
,	O
0x46bde64d	int
,	O
0x4db0ef43	int
,	O
0x50a7f451	int
,	O
0x5baafd5f	int
,	O
0x6a89c275	int
,	O
0x6184cb7b	int
,	O
0x7c93d069	int
,	O
0x779ed967	int
,	O
0x1ed5ae3d	int
,	O
0x15d8a733	int
,	O
0x08cfbc21	int
,	O
0x03c2b52f	int
,	O
0x32e18a05	int
,	O
0x39ec830b	int
,	O
0x24fb9819	int
,	O
0x2ff69117	int
,	O
0x8dd64d76	int
,	O
0x86db4478	int
,	O
0x9bcc5f6a	int
,	O
0x90c15664	int
,	O
0xa1e2694e	int
,	O
0xaaef6040	int
,	O
0xb7f87b52	int
,	O
0xbcf5725c	int
,	O
0xd5be0506	int
,	O
0xdeb30c08	int
,	O
0xc3a4171a	int
,	O
0xc8a91e14	int
,	O
0xf98a213e	int
,	O
0xf2872830	int
,	O
0xef903322	int
,	O
0xe49d3a2c	int
,	O
0x3d06dd96	int
,	O
0x360bd498	int
,	O
0x2b1ccf8a	int
,	O
0x2011c684	int
,	O
0x1132f9ae	int
,	O
0x1a3ff0a0	int
,	O
0x0728ebb2	int
,	O
0x0c25e2bc	int
,	O
0x656e95e6	int
,	O
0x6e639ce8	int
,	O
0x737487fa	int
,	O
0x78798ef4	int
,	O
0x495ab1de	int
,	O
0x4257b8d0	int
,	O
0x5f40a3c2	int
,	O
0x544daacc	int
,	O
0xf7daec41	int
,	O
0xfcd7e54f	int
,	O
0xe1c0fe5d	int
,	O
0xeacdf753	int
,	O
0xdbeec879	int
,	O
0xd0e3c177	int
,	O
0xcdf4da65	int
,	O
0xc6f9d36b	int
,	O
0xafb2a431	int
,	O
0xa4bfad3f	int
,	O
0xb9a8b62d	int
,	O
0xb2a5bf23	int
,	O
0x83868009	int
,	O
0x888b8907	int
,	O
0x959c9215	int
,	O
0x9e919b1b	int
,	O
0x470a7ca1	int
,	O
0x4c0775af	int
,	O
0x51106ebd	int
,	O
0x5a1d67b3	int
,	O
0x6b3e5899	int
,	O
0x60335197	int
,	O
0x7d244a85	int
,	O
0x7629438b	int
,	O
0x1f6234d1	int
,	O
0x146f3ddf	int
,	O
0x097826cd	int
,	O
0x02752fc3	int
,	O
0x335610e9	int
,	O
0x385b19e7	int
,	O
0x254c02f5	int
,	O
0x2e410bfb	int
,	O
0x8c61d79a	int
,	O
0x876cde94	int
,	O
0x9a7bc586	int
,	O
0x9176cc88	int
,	O
0xa055f3a2	int
,	O
0xab58faac	int
,	O
0xb64fe1be	int
,	O
0xbd42e8b0	int
,	O
0xd4099fea	int
,	O
0xdf0496e4	int
,	O
0xc2138df6	int
,	O
0xc91e84f8	int
,	O
0xf83dbbd2	int
,	O
0xf330b2dc	int
,	O
0xee27a9ce	int
,	O
0xe52aa0c0	int
,	O
0x3cb1477a	int
,	O
0x37bc4e74	int
,	O
0x2aab5566	int
,	O
0x21a65c68	int
,	O
0x10856342	int
,	O
0x1b886a4c	int
,	O
0x069f715e	int
,	O
0x0d927850	int
,	O
0x64d90f0a	int
,	O
0x6fd40604	int
,	O
0x72c31d16	int
,	O
0x79ce1418	int
,	O
0x48ed2b32	int
,	O
0x43e0223c	int
,	O
0x5ef7392e	int
,	O
0x55fa3020	int
,	O
0x01b79aec	int
,	O
0x0aba93e2	int
,	O
0x17ad88f0	int
,	O
0x1ca081fe	int
,	O
0x2d83bed4	int
,	O
0x268eb7da	int
,	O
0x3b99acc8	int
,	O
0x3094a5c6	int
,	O
0x59dfd29c	int
,	O
0x52d2db92	int
,	O
0x4fc5c080	int
,	O
0x44c8c98e	int
,	O
0x75ebf6a4	int
,	O
0x7ee6ffaa	int
,	O
0x63f1e4b8	int
,	O
0x68fcedb6	int
,	O
0xb1670a0c	int
,	O
0xba6a0302	int
,	O
0xa77d1810	int
,	O
0xac70111e	int
,	O
0x9d532e34	int
,	O
0x965e273a	int
,	O
0x8b493c28	int
,	O
0x80443526	int
,	O
0xe90f427c	int
,	O
0xe2024b72	int
,	O
0xff155060	int
,	O
0xf418596e	int
,	O
0xc53b6644	int
,	O
0xce366f4a	int
,	O
0xd3217458	int
,	O
0xd82c7d56	int
,	O
0x7a0ca137	int
,	O
0x7101a839	int
,	O
0x6c16b32b	int
,	O
0x671bba25	int
,	O
0x5638850f	int
,	O
0x5d358c01	int
,	O
0x40229713	int
,	O
0x4b2f9e1d	int
,	O
0x2264e947	int
,	O
0x2969e049	int
,	O
0x347efb5b	int
,	O
0x3f73f255	int
,	O
0x0e50cd7f	int
,	O
0x055dc471	int
,	O
0x184adf63	int
,	O
0x1347d66d	int
,	O
0xcadc31d7	int
,	O
0xc1d138d9	int
,	O
0xdcc623cb	int
,	O
0xd7cb2ac5	int
,	O
0xe6e815ef	int
,	O
0xede51ce1	int
,	O
0xf0f207f3	int
,	O
0xfbff0efd	int
,	O
0x92b479a7	int
,	O
0x99b970a9	int
,	O
0x84ae6bbb	int
,	O
0x8fa362b5	int
,	O
0xbe805d9f	int
,	O
0xb58d5491	int
,	O
0xa89a4f83	int
,	O
0xa397468d	int
,	O
}	O
;	O
void	O
_aes_invert	O
(	O
unsigned	O
rounds	int
,	O
uint32_t	int
*	O
dst	pointer
,	O
const	O
uint32_t	int
*	O
src	pointer
)	O
{	O
unsigned	O
i	int
;	O
if	O
(	O
src	pointer
==	O
dst	pointer
)	O
{	O
unsigned	O
j	int
,	O
k	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
rounds	int
*	O
4	int
;	O
i	int
<	O
j	int
;	O
i	int
+=	O
4	int
,	O
j	int
-=	O
4	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
SWAP	O
(	O
dst	pointer
[	O
i	int
+	O
k	int
]	O
,	O
dst	pointer
[	O
j	int
+	O
k	int
]	O
)	O
;	O
}	O
else	O
{	O
unsigned	O
k	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
rounds	int
*	O
4	int
;	O
i	int
+=	O
4	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
dst	pointer
[	O
i	int
+	O
k	int
]	O
=	O
src	pointer
[	O
rounds	int
*	O
4	int
-	O
i	int
+	O
k	int
]	O
;	O
}	O
for	O
(	O
i	int
=	O
4	int
;	O
i	int
<	O
4	int
*	O
rounds	int
;	O
i	int
++	O
)	O
MIX_COLUMN	function
(	O
mtable	pointer
,	O
dst	pointer
[	O
i	int
]	O
)	O
;	O
}	O
void	O
aes_invert_key	function
(	O
struct	O
aes_ctx	struct
*	O
dst	pointer
,	O
const	O
struct	O
aes_ctx	struct
*	O
src	pointer
)	O
{	O
switch	O
(	O
src	pointer
->	O
key_size	int
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
AES128_KEY_SIZE	int
:	O
aes128_invert_key	function
(	O
&	O
dst	pointer
->	O
u	union
.	O
ctx128	struct
,	O
&	O
src	pointer
->	O
u	union
.	O
ctx128	struct
)	O
;	O
break	O
;	O
case	O
AES192_KEY_SIZE	int
:	O
aes192_invert_key	function
(	O
&	O
dst	pointer
->	O
u	union
.	O
ctx192	struct
,	O
&	O
src	pointer
->	O
u	union
.	O
ctx192	struct
)	O
;	O
break	O
;	O
case	O
AES256_KEY_SIZE	int
:	O
aes256_invert_key	function
(	O
&	O
dst	pointer
->	O
u	union
.	O
ctx256	struct
,	O
&	O
src	pointer
->	O
u	union
.	O
ctx256	struct
)	O
;	O
break	O
;	O
}	O
dst	pointer
->	O
key_size	int
=	O
src	pointer
->	O
key_size	int
;	O
}	O
void	O
aes_set_decrypt_key	O
(	O
struct	O
aes_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
keysize	long
,	O
const	O
uint8_t	char
*	O
key	pointer
)	O
{	O
aes_set_encrypt_key	O
(	O
ctx	pointer
,	O
keysize	pointer
,	O
key	pointer
)	O
;	O
aes_invert_key	O
(	O
ctx	pointer
,	O
ctx	pointer
)	O
;	O
}	O
const	O
struct	O
nettle_cipher	struct
nettle_aes128	struct
=	O
{	O
"aes128"	pointer
,	O
sizeof	O
(	O
struct	O
aes128_ctx	struct
)	O
,	O
AES_BLOCK_SIZE	int
,	O
AES128_KEY_SIZE	int
,	O
(	O
nettle_set_key_func	function
*	O
)	O
aes128_set_encrypt_key	O
,	O
(	O
nettle_set_key_func	function
*	O
)	O
aes128_set_decrypt_key	O
,	O
(	O
nettle_cipher_func	function
*	O
)	O
aes128_encrypt	O
,	O
(	O
nettle_cipher_func	function
*	O
)	O
aes128_decrypt	O
}	O
;	O
void	O
aes128_invert_key	function
(	O
struct	O
aes128_ctx	struct
*	O
dst	pointer
,	O
const	O
struct	O
aes128_ctx	struct
*	O
src	pointer
)	O
{	O
_aes_invert	O
(	O
_AES128_ROUNDS	pointer
,	O
dst	pointer
->	O
keys	array
,	O
src	pointer
->	O
keys	array
)	O
;	O
}	O
void	O
aes128_set_decrypt_key	O
(	O
struct	O
aes128_ctx	struct
*	O
ctx	pointer
,	O
const	O
uint8_t	char
*	O
key	pointer
)	O
{	O
aes128_set_encrypt_key	O
(	O
ctx	pointer
,	O
key	pointer
)	O
;	O
aes128_invert_key	O
(	O
ctx	pointer
,	O
ctx	pointer
)	O
;	O
}	O
void	O
aes192_invert_key	function
(	O
struct	O
aes192_ctx	struct
*	O
dst	pointer
,	O
const	O
struct	O
aes192_ctx	struct
*	O
src	pointer
)	O
{	O
_aes_invert	O
(	O
_AES192_ROUNDS	int
,	O
dst	pointer
->	O
keys	array
,	O
src	pointer
->	O
keys	array
)	O
;	O
}	O
void	O
aes192_set_decrypt_key	O
(	O
struct	O
aes192_ctx	struct
*	O
ctx	pointer
,	O
const	O
uint8_t	char
*	O
key	pointer
)	O
{	O
aes192_set_encrypt_key	O
(	O
ctx	pointer
,	O
key	pointer
)	O
;	O
aes192_invert_key	O
(	O
ctx	pointer
,	O
ctx	pointer
)	O
;	O
}	O
void	O
arcfour_crypt	O
(	O
struct	O
arcfour_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
dst	pointer
,	O
const	O
uint8_t	char
*	O
src	pointer
)	O
{	O
register	O
uint8_t	char
i	char
,	O
j	int
;	O
register	O
int	O
si	pointer
,	O
sj	short
;	O
i	int
=	O
ctx	pointer
->	O
i	int
;	O
j	int
=	O
ctx	pointer
->	O
j	int
;	O
while	O
(	O
length	long
--	O
)	O
{	O
i	int
++	O
;	O
i	int
&=	O
0xff	int
;	O
si	pointer
=	O
ctx	pointer
->	O
S	array
[	O
i	int
]	O
;	O
j	int
+=	O
si	int
;	O
j	int
&=	O
0xff	int
;	O
sj	double
=	O
ctx	pointer
->	O
S	array
[	O
i	int
]	O
=	O
ctx	pointer
->	O
S	array
[	O
j	int
]	O
;	O
ctx	pointer
->	O
S	array
[	O
j	int
]	O
=	O
si	pointer
;	O
*	O
dst	pointer
++	O
=	O
*	O
src	pointer
++	O
^	O
ctx	pointer
->	O
S	array
[	O
(	O
si	pointer
+	O
sj	int
)	O
&	O
0xff	int
]	O
;	O
}	O
ctx	pointer
->	O
i	int
=	O
i	int
;	O
ctx	pointer
->	O
j	int
=	O
j	int
;	O
}	O
void	O
arcfour_set_key	O
(	O
struct	O
arcfour_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
key	pointer
)	O
{	O
unsigned	O
i	int
,	O
j	int
,	O
k	int
;	O
assert	O
(	O
length	long
>=	O
ARCFOUR_MIN_KEY_SIZE	int
)	O
;	O
assert	O
(	O
length	long
<=	O
ARCFOUR_MAX_KEY_SIZE	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
ctx	pointer
->	O
S	array
[	O
i	int
]	O
=	O
i	int
;	O
for	O
(	O
i	int
=	O
j	int
=	O
k	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
{	O
j	int
+=	O
ctx	pointer
->	O
S	array
[	O
i	int
]	O
+	O
key	pointer
[	O
k	int
]	O
;	O
j	int
&=	O
0xff	int
;	O
SWAP	O
(	O
ctx	pointer
->	O
S	array
[	O
i	int
]	O
,	O
ctx	pointer
->	O
S	array
[	O
j	int
]	O
)	O
;	O
k	int
=	O
(	O
k	int
+	O
1	int
)	O
%	O
length	long
;	O
}	O
ctx	pointer
->	O
i	int
=	O
ctx	pointer
->	O
j	int
=	O
0	int
;	O
}	O
void	O
arcfour128_set_key	O
(	O
struct	O
arcfour_ctx	struct
*	O
ctx	pointer
,	O
const	O
uint8_t	char
*	O
key	pointer
)	O
{	O
arcfour_set_key	O
(	O
ctx	pointer
,	O
ARCFOUR128_KEY_SIZE	int
,	O
key	pointer
)	O
;	O
}	O
static	O
const	O
uint8_t	char
hex_digits	array
[	O
16	int
]	O
=	O
"0123456789abcdef"	int
;	O
void	O
base16_encode_single	function
(	O
char	O
*	O
dst	pointer
,	O
uint8_t	char
src	pointer
)	O
{	O
dst	pointer
[	O
0	int
]	O
=	O
DIGIT	function
(	O
src	pointer
/	O
0x10	int
)	O
;	O
dst	pointer
[	O
1	int
]	O
=	O
DIGIT	function
(	O
src	pointer
)	O
;	O
}	O
void	O
base16_encode_update	O
(	O
char	O
*	O
dst	pointer
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
src	pointer
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
length	long
;	O
i	int
++	O
,	O
dst	pointer
+=	O
2	int
)	O
base16_encode_single	function
(	O
dst	pointer
,	O
src	pointer
[	O
i	long
]	O
)	O
;	O
}	O
static	O
nettle_armor_length_func	function
base16_encode_length	O
;	O
static	O
size_t	long
base16_encode_length	function
(	O
size_t	long
length	long
)	O
{	O
return	O
BASE16_ENCODE_LENGTH	O
(	O
length	long
)	O
;	O
}	O
static	O
nettle_armor_length_func	function
base16_decode_length	O
;	O
static	O
size_t	long
base16_decode_length	function
(	O
size_t	long
length	long
)	O
{	O
return	O
BASE16_DECODE_LENGTH	O
(	O
length	long
)	O
;	O
}	O
static	O
nettle_armor_init_func	O
base16_encode_init	pointer
;	O
static	O
void	O
base16_encode_init	function
(	O
void	O
*	O
ctx	pointer
UNUSED	O
)	O
{	O
}	O
static	O
nettle_armor_encode_update_func	struct
base16_encode_update_wrapper	pointer
;	O
static	O
size_t	long
base16_encode_update_wrapper	function
(	O
void	O
*	O
ctx	pointer
UNUSED	O
,	O
char	O
*	O
dst	pointer
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
src	pointer
)	O
{	O
base16_encode_update	O
(	O
dst	pointer
,	O
length	long
,	O
src	pointer
)	O
;	O
return	O
BASE16_ENCODE_LENGTH	O
(	O
length	long
)	O
;	O
}	O
static	O
nettle_armor_encode_final_func	pointer
base16_encode_final	pointer
;	O
static	O
size_t	long
base16_encode_final	function
(	O
void	O
*	O
ctx	pointer
UNUSED	O
,	O
char	O
*	O
dst	pointer
UNUSED	O
)	O
{	O
return	O
0	int
;	O
}	O
const	O
struct	O
nettle_armor	struct
nettle_base16	struct
=	O
_NETTLE_ARMOR_0	function
(	O
base16	struct
,	O
BASE16	pointer
)	O
;	O
static	O
nettle_armor_length_func	function
base64_encode_length	O
;	O
static	O
size_t	long
base64_encode_length	function
(	O
size_t	long
length	long
)	O
{	O
return	O
BASE64_ENCODE_LENGTH	O
(	O
length	long
)	O
;	O
}	O
static	O
nettle_armor_length_func	function
base64_decode_length	O
;	O
static	O
size_t	long
base64_decode_length	function
(	O
size_t	long
length	long
)	O
{	O
return	O
BASE64_DECODE_LENGTH	O
(	O
length	long
)	O
;	O
}	O
const	O
struct	O
nettle_armor	struct
nettle_base64	struct
=	O
_NETTLE_ARMOR	O
(	O
base64	pointer
,	O
BASE64	O
)	O
;	O
void	O
camellia128_set_encrypt_key	O
(	O
struct	O
camellia128_ctx	struct
*	O
ctx	pointer
,	O
const	O
uint8_t	char
*	O
key	pointer
)	O
{	O
uint64_t	long
k0	long
,	O
k1	long
;	O
uint64_t	long
subkey	pointer
[	O
_CAMELLIA128_NKEYS	int
+	O
2	int
]	O
;	O
uint64_t	long
w	long
;	O
k0	long
=	O
READ_UINT64	O
(	O
key	pointer
)	O
;	O
k1	long
=	O
READ_UINT64	O
(	O
key	pointer
+	O
8	int
)	O
;	O
subkey	pointer
[	O
0	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
1	int
]	O
=	O
k1	long
;	O
ROTL128	O
(	O
15	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
4	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
5	int
]	O
=	O
k1	long
;	O
ROTL128	O
(	O
30	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
10	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
11	int
]	O
=	O
k1	long
;	O
ROTL128	O
(	O
15	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
13	int
]	O
=	O
k1	long
;	O
ROTL128	O
(	O
17	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
16	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
17	int
]	O
=	O
k1	long
;	O
ROTL128	O
(	O
17	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
18	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
19	int
]	O
=	O
k1	long
;	O
ROTL128	O
(	O
17	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
22	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
23	int
]	O
=	O
k1	long
;	O
k0	long
=	O
subkey	pointer
[	O
0	int
]	O
;	O
w	int
=	O
subkey	pointer
[	O
1	int
]	O
;	O
CAMELLIA_F	O
(	O
k0	long
,	O
SIGMA1	int
,	O
k1	long
)	O
;	O
w	int
^=	O
k1	long
;	O
CAMELLIA_F	O
(	O
w	array
,	O
SIGMA2	int
,	O
k0	long
)	O
;	O
CAMELLIA_F	O
(	O
k0	long
,	O
SIGMA3	int
,	O
w	array
)	O
;	O
k1	long
^=	O
w	array
;	O
CAMELLIA_F	O
(	O
k1	long
,	O
SIGMA4	int
,	O
w	array
)	O
;	O
k0	long
^=	O
w	array
;	O
subkey	pointer
[	O
2	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
3	int
]	O
=	O
k1	long
;	O
ROTL128	O
(	O
15	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
6	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
7	int
]	O
=	O
k1	long
;	O
ROTL128	O
(	O
15	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
8	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
9	int
]	O
=	O
k1	long
;	O
ROTL128	O
(	O
15	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
12	int
]	O
=	O
k0	long
;	O
ROTL128	O
(	O
15	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
14	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
15	int
]	O
=	O
k1	long
;	O
ROTL128	O
(	O
34	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
20	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
21	int
]	O
=	O
k1	long
;	O
ROTL128	O
(	O
17	int
,	O
k0	long
,	O
k1	long
)	O
;	O
subkey	pointer
[	O
24	int
]	O
=	O
k0	long
;	O
subkey	pointer
[	O
25	int
]	O
=	O
k1	long
;	O
_camellia_absorb	O
(	O
_CAMELLIA128_NKEYS	int
,	O
ctx	pointer
->	O
keys	array
,	O
subkey	pointer
)	O
;	O
}	O
void	O
cbc_encrypt	function
(	O
const	O
void	O
*	O
ctx	pointer
,	O
nettle_cipher_func	function
*	O
f	pointer
,	O
size_t	long
block_size	long
,	O
uint8_t	char
*	O
iv	pointer
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
dst	pointer
,	O
const	O
uint8_t	char
*	O
src	pointer
)	O
{	O
assert	O
(	O
!	O
(	O
length	long
%	O
block_size	long
)	O
)	O
;	O
for	O
(	O
;	O
length	long
;	O
length	long
-=	O
block_size	long
,	O
src	pointer
+=	O
block_size	long
,	O
dst	pointer
+=	O
block_size	long
)	O
{	O
memxor	O
(	O
iv	pointer
,	O
src	pointer
,	O
block_size	long
)	O
;	O
f	pointer
(	O
ctx	pointer
,	O
block_size	long
,	O
dst	pointer
,	O
iv	pointer
)	O
;	O
memcpy	function
(	O
iv	pointer
,	O
dst	pointer
,	O
block_size	long
)	O
;	O
}	O
}	O
void	O
cbc_decrypt	function
(	O
const	O
void	O
*	O
ctx	pointer
,	O
nettle_cipher_func	function
*	O
f	pointer
,	O
size_t	long
block_size	long
,	O
uint8_t	char
*	O
iv	pointer
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
dst	pointer
,	O
const	O
uint8_t	char
*	O
src	pointer
)	O
{	O
assert	O
(	O
!	O
(	O
length	long
%	O
block_size	long
)	O
)	O
;	O
if	O
(	O
!	O
length	long
)	O
return	O
;	O
if	O
(	O
src	pointer
!=	O
dst	pointer
)	O
{	O
f	pointer
(	O
ctx	pointer
,	O
length	long
,	O
dst	pointer
,	O
src	pointer
)	O
;	O
memxor	O
(	O
dst	pointer
,	O
iv	pointer
,	O
block_size	long
)	O
;	O
memxor	O
(	O
dst	pointer
+	O
block_size	long
,	O
src	pointer
,	O
length	long
-	O
block_size	long
)	O
;	O
memcpy	function
(	O
iv	pointer
,	O
src	pointer
+	O
length	long
-	O
block_size	long
,	O
block_size	long
)	O
;	O
}	O
else	O
{	O
TMP_DECL	O
(	O
buffer	pointer
,	O
uint8_t	char
,	O
CBC_BUFFER_LIMIT	pointer
)	O
;	O
TMP_DECL	O
(	O
initial_iv	pointer
,	O
uint8_t	char
,	O
NETTLE_MAX_CIPHER_BLOCK_SIZE	O
)	O
;	O
size_t	long
buffer_size	long
;	O
if	O
(	O
length	long
<=	O
CBC_BUFFER_LIMIT	int
)	O
buffer_size	long
=	O
length	long
;	O
else	O
buffer_size	long
=	O
CBC_BUFFER_LIMIT	long
-	O
(	O
CBC_BUFFER_LIMIT	pointer
%	O
block_size	long
)	O
;	O
TMP_ALLOC	O
(	O
buffer	pointer
,	O
buffer_size	long
)	O
;	O
TMP_ALLOC	O
(	O
initial_iv	pointer
,	O
block_size	long
)	O
;	O
for	O
(	O
;	O
length	long
>	O
buffer_size	long
;	O
length	long
-=	O
buffer_size	long
,	O
dst	pointer
+=	O
buffer_size	long
)	O
{	O
f	pointer
(	O
ctx	pointer
,	O
buffer_size	long
,	O
buffer	pointer
,	O
dst	pointer
)	O
;	O
memcpy	function
(	O
initial_iv	pointer
,	O
iv	pointer
,	O
block_size	long
)	O
;	O
memcpy	function
(	O
iv	pointer
,	O
dst	pointer
+	O
buffer_size	long
-	O
block_size	long
,	O
block_size	long
)	O
;	O
memxor3	O
(	O
dst	pointer
+	O
block_size	long
,	O
buffer	pointer
+	O
block_size	long
,	O
dst	pointer
,	O
buffer_size	long
-	O
block_size	long
)	O
;	O
memxor3	O
(	O
dst	pointer
,	O
buffer	pointer
,	O
initial_iv	pointer
,	O
block_size	long
)	O
;	O
}	O
f	pointer
(	O
ctx	pointer
,	O
length	long
,	O
buffer	pointer
,	O
dst	pointer
)	O
;	O
memcpy	function
(	O
initial_iv	pointer
,	O
iv	pointer
,	O
block_size	long
)	O
;	O
memcpy	function
(	O
iv	pointer
,	O
dst	pointer
+	O
length	long
-	O
block_size	long
,	O
block_size	long
)	O
;	O
memxor3	O
(	O
dst	pointer
+	O
block_size	long
,	O
buffer	pointer
+	O
block_size	long
,	O
dst	pointer
,	O
length	long
-	O
block_size	long
)	O
;	O
memxor3	O
(	O
dst	pointer
,	O
buffer	pointer
,	O
initial_iv	pointer
,	O
block_size	long
)	O
;	O
}	O
}	O
void	O
cnd_memcpy	function
(	O
int	O
cnd	int
,	O
volatile	O
void	O
*	O
dst	pointer
,	O
const	O
volatile	O
void	O
*	O
src	pointer
,	O
size_t	long
n	int
)	O
{	O
const	O
volatile	O
unsigned	O
char	O
*	O
sp	pointer
=	O
src	pointer
;	O
volatile	O
unsigned	O
char	O
*	O
dp	pointer
=	O
dst	pointer
;	O
volatile	O
unsigned	O
char	O
c	int
;	O
volatile	O
unsigned	O
char	O
m	array
;	O
size_t	long
i	long
;	O
m	int
=	O
-	O
(	O
unsigned	O
char	O
)	O
cnd	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
c	int
=	O
(	O
sp	pointer
[	O
i	int
]	O
&	O
m	int
)	O
;	O
c	int
|=	O
(	O
dp	pointer
[	O
i	int
]	O
&	O
~	O
m	int
)	O
;	O
dp	pointer
[	O
i	int
]	O
=	O
c	int
;	O
}	O
}	O
int	O
main	function
(	O
int	O
argc	int
UNUSED	O
,	O
char	O
*	O
*	O
argv	pointer
UNUSED	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
uint8_t	char
buffer	pointer
[	O
CHUNK_SIZE	int
]	O
;	O
char	O
result	array
[	O
ENCODED_SIZE	O
+	O
1	int
]	O
;	O
unsigned	O
nbytes	int
;	O
int	O
encoded_bytes	int
;	O
nbytes	int
=	O
fread	function
(	O
buffer	pointer
,	O
1	int
,	O
CHUNK_SIZE	int
,	O
stdin	pointer
)	O
;	O
base16_encode_update	O
(	O
result	pointer
,	O
nbytes	int
,	O
buffer	array
)	O
;	O
encoded_bytes	int
=	O
BASE16_ENCODE_LENGTH	O
(	O
nbytes	int
)	O
;	O
result	pointer
[	O
encoded_bytes	int
++	O
]	O
=	O
'\n'	O
;	O
if	O
(	O
nbytes	int
<	O
CHUNK_SIZE	int
)	O
{	O
if	O
(	O
ferror	function
(	O
stdin	pointer
)	O
)	O
{	O
werror	function
(	O
"Error reading file: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
if	O
(	O
!	O
write_data	function
(	O
stdout	pointer
,	O
encoded_bytes	int
,	O
result	array
)	O
||	O
fflush	function
(	O
stdout	pointer
)	O
!=	O
0	int
)	O
{	O
werror	function
(	O
"Error writing file: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
if	O
(	O
!	O
write_data	function
(	O
stdout	pointer
,	O
encoded_bytes	int
,	O
result	array
)	O
)	O
{	O
werror	function
(	O
"Error writing file: %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
}	O
void	O
hmac_md5_set_key	O
(	O
struct	O
hmac_md5_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
key_length	long
,	O
const	O
uint8_t	char
*	O
key	pointer
)	O
{	O
HMAC_SET_KEY	O
(	O
ctx	pointer
,	O
&	O
nettle_md5	struct
,	O
key_length	long
,	O
key	pointer
)	O
;	O
}	O
void	O
hmac_md5_update	function
(	O
struct	O
hmac_md5_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
data	pointer
)	O
{	O
md5_update	O
(	O
&	O
ctx	pointer
->	O
state	pointer
,	O
length	long
,	O
data	pointer
)	O
;	O
}	O
void	O
hmac_md5_digest	O
(	O
struct	O
hmac_md5_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
digest	pointer
)	O
{	O
HMAC_DIGEST	O
(	O
ctx	pointer
,	O
&	O
nettle_md5	struct
,	O
length	long
,	O
digest	pointer
)	O
;	O
}	O
const	O
struct	O
nettle_hash	struct
*	O
const	O
_nettle_hashes	array
[	O
]	O
=	O
{	O
&	O
nettle_md2	struct
,	O
&	O
nettle_md4	struct
,	O
&	O
nettle_md5	struct
,	O
&	O
nettle_ripemd160	struct
,	O
&	O
nettle_sha1	struct
,	O
&	O
nettle_sha224	struct
,	O
&	O
nettle_sha256	struct
,	O
&	O
nettle_sha384	struct
,	O
&	O
nettle_sha512	struct
,	O
&	O
nettle_sha3_224	struct
,	O
&	O
nettle_sha3_256	struct
,	O
&	O
nettle_sha3_384	struct
,	O
&	O
nettle_sha3_512	struct
,	O
NULL	O
}	O
;	O
const	O
struct	O
nettle_hash	struct
*	O
const	O
*	O
nettle_get_hashes	function
(	O
void	O
)	O
{	O
return	O
_nettle_hashes	array
;	O
}	O
const	O
struct	O
nettle_hash	struct
nettle_ripemd160	struct
=	O
_NETTLE_HASH	O
(	O
ripemd160	O
,	O
RIPEMD160	O
)	O
;	O
void	O
salsa20_set_key	O
(	O
struct	O
salsa20_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
key	pointer
)	O
{	O
switch	O
(	O
length	long
)	O
{	O
case	O
SALSA20_128_KEY_SIZE	int
:	O
salsa20_128_set_key	O
(	O
ctx	pointer
,	O
key	pointer
)	O
;	O
break	O
;	O
case	O
SALSA20_256_KEY_SIZE	int
:	O
salsa20_256_set_key	O
(	O
ctx	pointer
,	O
key	pointer
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
void	O
salsa20_set_nonce	O
(	O
struct	O
salsa20_ctx	struct
*	O
ctx	pointer
,	O
const	O
uint8_t	char
*	O
nonce	pointer
)	O
{	O
ctx	pointer
->	O
input	array
[	O
6	int
]	O
=	O
LE_READ_UINT32	O
(	O
nonce	pointer
+	O
0	int
)	O
;	O
ctx	pointer
->	O
input	array
[	O
7	int
]	O
=	O
LE_READ_UINT32	O
(	O
nonce	pointer
+	O
4	int
)	O
;	O
ctx	pointer
->	O
input	array
[	O
8	int
]	O
=	O
0	int
;	O
ctx	pointer
->	O
input	array
[	O
9	int
]	O
=	O
0	int
;	O
}	O
const	O
struct	O
nettle_hash	struct
nettle_sha1	struct
=	O
_NETTLE_HASH	O
(	O
sha1	struct
,	O
SHA1	O
)	O
;	O
const	O
struct	O
nettle_hash	struct
nettle_sha256	struct
=	O
_NETTLE_HASH	O
(	O
sha256	O
,	O
SHA256	O
)	O
;	O
void	O
sha3_384_init	function
(	O
struct	O
sha3_384_ctx	struct
*	O
ctx	pointer
)	O
{	O
memset	function
(	O
ctx	pointer
,	O
0	int
,	O
offsetof	O
(	O
struct	O
sha3_384_ctx	struct
,	O
block	array
)	O
)	O
;	O
}	O
void	O
sha3_384_update	function
(	O
struct	O
sha3_384_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
data	pointer
)	O
{	O
ctx	pointer
->	O
index	function
=	O
_sha3_update	O
(	O
&	O
ctx	pointer
->	O
state	pointer
,	O
SHA3_384_BLOCK_SIZE	int
,	O
ctx	pointer
->	O
block	array
,	O
ctx	pointer
->	O
index	function
,	O
length	long
,	O
data	pointer
)	O
;	O
}	O
void	O
sha3_384_digest	O
(	O
struct	O
sha3_384_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
digest	pointer
)	O
{	O
_sha3_pad	O
(	O
&	O
ctx	pointer
->	O
state	pointer
,	O
SHA3_384_BLOCK_SIZE	int
,	O
ctx	pointer
->	O
block	array
,	O
ctx	pointer
->	O
index	function
)	O
;	O
_nettle_write_le64	function
(	O
length	long
,	O
digest	pointer
,	O
ctx	pointer
->	O
state	pointer
.	O
a	array
)	O
;	O
sha3_384_init	O
(	O
ctx	pointer
)	O
;	O
}	O
const	O
struct	O
nettle_hash	struct
nettle_sha384	struct
=	O
_NETTLE_HASH	O
(	O
sha384	O
,	O
SHA384	O
)	O
;	O
const	O
struct	O
nettle_cipher	struct
nettle_twofish128	struct
=	O
TWOFISH	function
(	O
128	int
)	O
;	O
const	O
struct	O
nettle_cipher	struct
nettle_twofish192	struct
=	O
TWOFISH	function
(	O
192	int
)	O
;	O
const	O
struct	O
nettle_cipher	struct
nettle_twofish256	struct
=	O
TWOFISH	function
(	O
256	int
)	O
;	O
void	O
_umac_l2_init	O
(	O
unsigned	O
size	int
,	O
uint32_t	int
*	O
k	pointer
)	O
{	O
unsigned	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
{	O
uint32_t	int
w	int
=	O
k	pointer
[	O
i	int
]	O
;	O
w	int
=	O
BE_SWAP32	function
(	O
w	array
)	O
;	O
k	pointer
[	O
i	int
]	O
=	O
w	int
&	O
KEY_MASK	int
;	O
}	O
}	O
void	O
_umac_l2	O
(	O
const	O
uint32_t	int
*	O
key	pointer
,	O
uint64_t	long
*	O
state	pointer
,	O
unsigned	O
n	int
,	O
uint64_t	long
count	long
,	O
const	O
uint64_t	long
*	O
m	long
)	O
{	O
uint64_t	long
*	O
prev	pointer
=	O
state	pointer
+	O
2	int
*	O
n	long
;	O
unsigned	O
i	long
;	O
if	O
(	O
count	long
==	O
0	int
)	O
memcpy	function
(	O
prev	pointer
,	O
m	pointer
,	O
n	long
*	O
sizeof	O
(	O
*	O
m	pointer
)	O
)	O
;	O
else	O
if	O
(	O
count	long
==	O
1	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
,	O
key	pointer
+=	O
6	int
)	O
{	O
uint64_t	long
y	long
=	O
_umac_poly64	O
(	O
key	pointer
[	O
0	int
]	O
,	O
key	pointer
[	O
1	int
]	O
,	O
1	int
,	O
prev	pointer
[	O
i	long
]	O
)	O
;	O
state	pointer
[	O
2	int
*	O
i	long
+	O
1	int
]	O
=	O
_umac_poly64	O
(	O
key	pointer
[	O
0	int
]	O
,	O
key	pointer
[	O
1	int
]	O
,	O
y	long
,	O
m	array
[	O
i	long
]	O
)	O
;	O
}	O
else	O
if	O
(	O
count	long
<	O
UMAC_POLY64_BLOCKS	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	int
++	O
,	O
key	pointer
+=	O
6	int
)	O
state	pointer
[	O
2	int
*	O
i	long
+	O
1	int
]	O
=	O
_umac_poly64	O
(	O
key	pointer
[	O
0	int
]	O
,	O
key	pointer
[	O
1	int
]	O
,	O
state	pointer
[	O
2	int
*	O
i	long
+	O
1	int
]	O
,	O
m	array
[	O
i	long
]	O
)	O
;	O
else	O
if	O
(	O
count	long
%	O
2	int
==	O
0	int
)	O
{	O
if	O
(	O
count	long
==	O
UMAC_POLY64_BLOCKS	int
)	O
for	O
(	O
i	long
=	O
0	int
,	O
key	pointer
+=	O
2	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
,	O
key	pointer
+=	O
6	int
)	O
{	O
uint64_t	long
y	long
=	O
state	pointer
[	O
2	int
*	O
i	long
+	O
1	int
]	O
;	O
if	O
(	O
y	long
>=	O
UMAC_P64	O
)	O
y	long
-=	O
UMAC_P64	O
;	O
state	pointer
[	O
2	int
*	O
i	long
]	O
=	O
0	int
;	O
state	pointer
[	O
2	int
*	O
i	long
+	O
1	int
]	O
=	O
1	int
;	O
_umac_poly128	O
(	O
key	pointer
,	O
state	pointer
+	O
2	int
*	O
i	long
,	O
0	int
,	O
y	long
)	O
;	O
}	O
memcpy	function
(	O
prev	pointer
,	O
m	pointer
,	O
n	long
*	O
sizeof	O
(	O
*	O
m	pointer
)	O
)	O
;	O
}	O
else	O
for	O
(	O
i	long
=	O
0	int
,	O
key	pointer
+=	O
2	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
,	O
key	pointer
+=	O
6	int
)	O
_umac_poly128	O
(	O
key	pointer
,	O
state	pointer
+	O
2	int
*	O
i	long
,	O
prev	pointer
[	O
i	long
]	O
,	O
m	array
[	O
i	int
]	O
)	O
;	O
}	O
void	O
_umac_l2_final	O
(	O
const	O
uint32_t	int
*	O
key	pointer
,	O
uint64_t	long
*	O
state	pointer
,	O
unsigned	O
n	int
,	O
uint64_t	long
count	long
)	O
{	O
uint64_t	long
*	O
prev	pointer
=	O
state	pointer
+	O
2	int
*	O
n	long
;	O
unsigned	O
i	int
;	O
assert	O
(	O
count	long
>	O
0	int
)	O
;	O
if	O
(	O
count	long
==	O
1	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
*	O
state	pointer
++	O
=	O
0	int
;	O
*	O
state	pointer
++	O
=	O
*	O
prev	pointer
++	O
;	O
}	O
else	O
if	O
(	O
count	long
<=	O
UMAC_POLY64_BLOCKS	int
)	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
uint64_t	long
y	long
;	O
*	O
state	pointer
++	O
=	O
0	int
;	O
y	long
=	O
*	O
state	pointer
;	O
if	O
(	O
y	long
>=	O
UMAC_P64	O
)	O
y	long
-=	O
UMAC_P64	O
;	O
*	O
state	pointer
++	O
=	O
y	long
;	O
}	O
else	O
{	O
uint64_t	long
pad	long
=	O
(	O
uint64_t	long
)	O
1	int
<<	O
63	int
;	O
if	O
(	O
count	long
%	O
2	int
==	O
1	int
)	O
for	O
(	O
i	long
=	O
0	int
,	O
key	pointer
+=	O
2	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
,	O
key	pointer
+=	O
6	int
)	O
_umac_poly128	O
(	O
key	pointer
,	O
state	pointer
+	O
2	int
*	O
i	long
,	O
prev	pointer
[	O
i	long
]	O
,	O
pad	pointer
)	O
;	O
else	O
for	O
(	O
i	long
=	O
0	int
,	O
key	pointer
+=	O
2	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
,	O
key	pointer
+=	O
6	int
)	O
_umac_poly128	O
(	O
key	pointer
,	O
state	pointer
+	O
2	int
*	O
i	long
,	O
pad	pointer
,	O
0	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	int
++	O
,	O
state	pointer
+=	O
2	int
)	O
{	O
uint64_t	long
yh	long
,	O
yl	long
;	O
yh	long
=	O
state	pointer
[	O
0	int
]	O
;	O
yl	long
=	O
state	pointer
[	O
1	int
]	O
;	O
if	O
(	O
yh	long
==	O
UMAC_P128_HI	O
&&	O
yl	long
>=	O
UMAC_P128_LO	O
)	O
{	O
state	pointer
[	O
0	int
]	O
=	O
0	int
;	O
state	pointer
[	O
1	int
]	O
=	O
yl	long
-=	O
UMAC_P128_LO	O
;	O
}	O
}	O
}	O
}	O
void	O
umac64_set_key	function
(	O
struct	O
umac64_ctx	struct
*	O
ctx	pointer
,	O
const	O
uint8_t	char
*	O
key	pointer
)	O
{	O
_umac_set_key	O
(	O
ctx	pointer
->	O
l1_key	array
,	O
ctx	pointer
->	O
l2_key	array
,	O
ctx	pointer
->	O
l3_key1	array
,	O
ctx	pointer
->	O
l3_key2	array
,	O
&	O
ctx	pointer
->	O
pdf_key	struct
,	O
key	pointer
,	O
2	int
)	O
;	O
memset	function
(	O
ctx	pointer
->	O
nonce	array
,	O
0	int
,	O
sizeof	O
(	O
ctx	pointer
->	O
nonce	array
)	O
)	O
;	O
ctx	pointer
->	O
nonce_low	short
=	O
0	int
;	O
ctx	pointer
->	O
nonce_length	short
=	O
sizeof	O
(	O
ctx	pointer
->	O
nonce	array
)	O
;	O
ctx	pointer
->	O
count	long
=	O
ctx	pointer
->	O
index	function
=	O
0	int
;	O
}	O
void	O
umac64_set_nonce	O
(	O
struct	O
umac64_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
nonce_length	long
,	O
const	O
uint8_t	char
*	O
nonce	pointer
)	O
{	O
assert	O
(	O
nonce_length	short
>	O
0	int
)	O
;	O
assert	O
(	O
nonce_length	short
<=	O
AES_BLOCK_SIZE	int
)	O
;	O
memcpy	function
(	O
ctx	pointer
->	O
nonce	array
,	O
nonce	array
,	O
nonce_length	short
)	O
;	O
memset	function
(	O
ctx	pointer
->	O
nonce	array
+	O
nonce_length	short
,	O
0	int
,	O
AES_BLOCK_SIZE	int
-	O
nonce_length	short
)	O
;	O
ctx	pointer
->	O
nonce_low	short
=	O
ctx	pointer
->	O
nonce	array
[	O
nonce_length	short
-	O
1	int
]	O
&	O
1	int
;	O
ctx	pointer
->	O
nonce	array
[	O
nonce_length	short
-	O
1	int
]	O
&=	O
~	O
1	int
;	O
ctx	pointer
->	O
nonce_length	short
=	O
nonce_length	short
;	O
}	O
void	O
umac64_update	O
(	O
struct	O
umac64_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
length	long
,	O
const	O
uint8_t	char
*	O
data	pointer
)	O
{	O
MD_UPDATE	O
(	O
ctx	pointer
,	O
length	long
,	O
data	pointer
,	O
UMAC64_BLOCK	pointer
,	O
(	O
void	O
)	O
0	int
)	O
;	O
}	O
void	O
umac64_digest	O
(	O
struct	O
umac64_ctx	struct
*	O
ctx	pointer
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
digest	pointer
)	O
{	O
uint32_t	int
tag	array
[	O
2	int
]	O
;	O
uint32_t	int
*	O
pad	pointer
;	O
assert	O
(	O
length	long
>	O
0	int
)	O
;	O
assert	O
(	O
length	long
<=	O
8	int
)	O
;	O
if	O
(	O
ctx	pointer
->	O
index	function
>	O
0	int
||	O
ctx	pointer
->	O
count	long
==	O
0	int
)	O
{	O
uint64_t	long
y	long
[	O
2	int
]	O
;	O
unsigned	O
pad	pointer
=	O
(	O
ctx	pointer
->	O
index	function
>	O
0	int
)	O
?	O
31	int
&	O
-	O
ctx	pointer
->	O
index	function
:	O
32	int
;	O
memset	function
(	O
ctx	pointer
->	O
block	array
+	O
ctx	pointer
->	O
index	function
,	O
0	int
,	O
pad	pointer
)	O
;	O
_umac_nh_n	O
(	O
y	long
,	O
2	int
,	O
ctx	pointer
->	O
l1_key	array
,	O
ctx	pointer
->	O
index	function
+	O
pad	pointer
,	O
ctx	pointer
->	O
block	array
)	O
;	O
y	long
[	O
0	int
]	O
+=	O
8	int
*	O
ctx	pointer
->	O
index	function
;	O
y	long
[	O
1	int
]	O
+=	O
8	int
*	O
ctx	pointer
->	O
index	function
;	O
_umac_l2	O
(	O
ctx	pointer
->	O
l2_key	array
,	O
ctx	pointer
->	O
l2_state	array
,	O
2	int
,	O
ctx	pointer
->	O
count	long
++	O
,	O
y	long
)	O
;	O
}	O
assert	O
(	O
ctx	pointer
->	O
count	long
>	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
ctx	pointer
->	O
nonce_low	short
&	O
_UMAC_NONCE_CACHED	int
)	O
)	O
{	O
aes128_encrypt	O
(	O
&	O
ctx	pointer
->	O
pdf_key	struct
,	O
AES_BLOCK_SIZE	int
,	O
(	O
uint8_t	char
*	O
)	O
ctx	pointer
->	O
pad_cache	array
,	O
ctx	pointer
->	O
nonce	array
)	O
;	O
ctx	pointer
->	O
nonce_low	short
|=	O
_UMAC_NONCE_CACHED	int
;	O
}	O
pad	pointer
=	O
ctx	pointer
->	O
pad_cache	array
+	O
2	int
*	O
(	O
ctx	pointer
->	O
nonce_low	short
&	O
1	int
)	O
;	O
ctx	pointer
->	O
nonce_low	short
++	O
;	O
if	O
(	O
!	O
(	O
ctx	pointer
->	O
nonce_low	short
&	O
1	int
)	O
)	O
{	O
unsigned	O
i	int
=	O
ctx	pointer
->	O
nonce_length	short
-	O
1	int
;	O
ctx	pointer
->	O
nonce_low	short
=	O
0	int
;	O
ctx	pointer
->	O
nonce	array
[	O
i	int
]	O
+=	O
2	int
;	O
if	O
(	O
ctx	pointer
->	O
nonce	array
[	O
i	int
]	O
==	O
0	int
&&	O
i	int
>	O
0	int
)	O
INCREMENT	O
(	O
i	int
,	O
ctx	pointer
->	O
nonce	array
)	O
;	O
}	O
_umac_l2_final	O
(	O
ctx	pointer
->	O
l2_key	array
,	O
ctx	pointer
->	O
l2_state	array
,	O
2	int
,	O
ctx	pointer
->	O
count	long
)	O
;	O
tag	array
[	O
0	int
]	O
=	O
pad	pointer
[	O
0	int
]	O
^	O
ctx	pointer
->	O
l3_key2	array
[	O
0	int
]	O
^	O
_umac_l3	O
(	O
ctx	pointer
->	O
l3_key1	array
,	O
ctx	pointer
->	O
l2_state	array
)	O
;	O
tag	array
[	O
1	int
]	O
=	O
pad	pointer
[	O
1	int
]	O
^	O
ctx	pointer
->	O
l3_key2	array
[	O
1	int
]	O
^	O
_umac_l3	O
(	O
ctx	pointer
->	O
l3_key1	array
+	O
8	int
,	O
ctx	pointer
->	O
l2_state	array
+	O
2	int
)	O
;	O
memcpy	function
(	O
digest	pointer
,	O
tag	array
,	O
length	long
)	O
;	O
ctx	pointer
->	O
count	long
=	O
ctx	pointer
->	O
index	function
=	O
0	int
;	O
}	O
void	O
xts_aes256_set_encrypt_key	function
(	O
struct	O
xts_aes256_key	struct
*	O
xts_key	pointer
,	O
const	O
uint8_t	char
*	O
key	pointer
)	O
{	O
aes256_set_encrypt_key	O
(	O
&	O
xts_key	pointer
->	O
cipher	pointer
,	O
key	pointer
)	O
;	O
aes256_set_encrypt_key	O
(	O
&	O
xts_key	pointer
->	O
tweak_cipher	struct
,	O
&	O
key	pointer
[	O
AES256_KEY_SIZE	int
]	O
)	O
;	O
}	O
void	O
xts_aes256_set_decrypt_key	function
(	O
struct	O
xts_aes256_key	struct
*	O
xts_key	pointer
,	O
const	O
uint8_t	char
*	O
key	pointer
)	O
{	O
aes256_set_decrypt_key	function
(	O
&	O
xts_key	pointer
->	O
cipher	struct
,	O
key	pointer
)	O
;	O
aes256_set_encrypt_key	O
(	O
&	O
xts_key	pointer
->	O
tweak_cipher	struct
,	O
&	O
key	pointer
[	O
AES256_KEY_SIZE	int
]	O
)	O
;	O
}	O
void	O
xts_aes256_encrypt_message	function
(	O
struct	O
xts_aes256_key	struct
*	O
xts_key	pointer
,	O
const	O
uint8_t	char
*	O
tweak	pointer
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
dst	pointer
,	O
const	O
uint8_t	char
*	O
src	pointer
)	O
{	O
xts_encrypt_message	O
(	O
&	O
xts_key	pointer
->	O
cipher	struct
,	O
&	O
xts_key	pointer
->	O
tweak_cipher	struct
,	O
(	O
nettle_cipher_func	function
*	O
)	O
aes256_encrypt	O
,	O
tweak	pointer
,	O
length	long
,	O
dst	pointer
,	O
src	pointer
)	O
;	O
}	O
void	O
xts_aes256_decrypt_message	function
(	O
struct	O
xts_aes256_key	struct
*	O
xts_key	pointer
,	O
const	O
uint8_t	char
*	O
tweak	pointer
,	O
size_t	long
length	long
,	O
uint8_t	char
*	O
dst	pointer
,	O
const	O
uint8_t	char
*	O
src	pointer
)	O
{	O
xts_decrypt_message	O
(	O
&	O
xts_key	pointer
->	O
cipher	struct
,	O
&	O
xts_key	pointer
->	O
tweak_cipher	struct
,	O
(	O
nettle_cipher_func	function
*	O
)	O
aes256_decrypt	O
,	O
(	O
nettle_cipher_func	function
*	O
)	O
aes256_encrypt	O
,	O
tweak	pointer
,	O
length	long
,	O
dst	pointer
,	O
src	pointer
)	O
;	O
}	O
static	O
struct	O
option	struct
const	O
long_options	array
[	O
]	O
=	O
{	O
{	O
"help"	pointer
,	O
0	int
,	O
0	int
,	O
opt_help	int
}	O
,	O
{	O
"version"	pointer
,	O
0	int
,	O
0	int
,	O
opt_version	int
}	O
,	O
{	O
"html"	pointer
,	O
0	int
,	O
0	int
,	O
opt_generate_html	int
}	O
,	O
{	O
"bibtex"	pointer
,	O
0	int
,	O
0	int
,	O
opt_generate_bibtex	int
}	O
,	O
{	O
"latex"	pointer
,	O
0	int
,	O
0	int
,	O
opt_generate_latex	int
}	O
,	O
{	O
"json"	pointer
,	O
0	int
,	O
0	int
,	O
opt_generate_json	int
}	O
,	O
{	O
"text"	pointer
,	O
0	int
,	O
0	int
,	O
opt_generate_text	int
}	O
,	O
{	O
"search"	pointer
,	O
0	int
,	O
0	int
,	O
opt_search_file	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
const	O
char	O
short_options	array
[	O
]	O
=	O
"hvtbljps"	pointer
;	O
void	O
parse_args	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
c	int
;	O
char	O
*	O
readme	pointer
=	O
argv	pointer
[	O
2	int
]	O
;	O
char	O
*	O
file	pointer
=	O
argv	pointer
[	O
2	int
]	O
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	array
,	O
short_options	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
opt_help	int
:	O
help	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
break	O
;	O
case	O
opt_version	int
:	O
version	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
break	O
;	O
case	O
opt_generate_html	int
:	O
html	int
=	O
1	int
;	O
orgadoc_html_start_tags	function
(	O
)	O
;	O
orgadoc_xml_parser	function
(	O
readme	pointer
)	O
;	O
orgadoc_html_end_tags	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
opt_generate_bibtex	int
:	O
bibtex	int
=	O
1	int
;	O
orgadoc_bibtex_start_tags	function
(	O
)	O
;	O
orgadoc_xml_parser	function
(	O
readme	pointer
)	O
;	O
orgadoc_bibtex_end_tags	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
opt_generate_latex	int
:	O
latex	int
=	O
1	int
;	O
orgadoc_latex_start_tags	function
(	O
)	O
;	O
orgadoc_xml_parser	function
(	O
readme	pointer
)	O
;	O
orgadoc_latex_end_tags	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
opt_generate_json	int
:	O
json	int
=	O
1	int
;	O
orgadoc_json_start_tags	function
(	O
)	O
;	O
orgadoc_xml_parser	function
(	O
readme	pointer
)	O
;	O
orgadoc_json_end_tags	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
opt_generate_text	int
:	O
text	pointer
=	O
1	int
;	O
orgadoc_text_start_tags	function
(	O
)	O
;	O
orgadoc_xml_parser	function
(	O
readme	pointer
)	O
;	O
orgadoc_text_end_tags	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
opt_search_file	int
:	O
orgadoc_search	function
(	O
file	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
default	O
:	O
help	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
orgadoc_search	function
(	O
char	O
*	O
file	pointer
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
f	pointer
=	O
fopen	function
(	O
file	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"ERROR: %s does not exist or cannot be opened! \n"	pointer
,	O
file	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
f	pointer
)	O
{	O
while	O
(	O
(	O
nread	int
=	O
fread	function
(	O
BUFFER	pointer
,	O
1	int
,	O
sizeof	O
BUFFER	int
,	O
f	pointer
)	O
)	O
>	O
0	int
)	O
fwrite	function
(	O
BUFFER	pointer
,	O
1	int
,	O
nread	int
,	O
stdout	pointer
)	O
;	O
}	O
fclose	function
(	O
f	pointer
)	O
;	O
}	O
static	O
void	O
__argmatch_die	function
(	O
void	O
)	O
{	O
ARGMATCH_DIE	int
;	O
}	O
argmatch_exit_fn	pointer
argmatch_die	pointer
=	O
__argmatch_die	pointer
;	O
ptrdiff_t	bool
argmatch	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
size_t	long
arglen	long
;	O
ptrdiff_t	long
matchind	long
=	O
-	O
1	int
;	O
bool	bool
ambiguous	bool
=	O
false	int
;	O
arglen	long
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
arglist	array
[	O
i	pointer
]	O
,	O
arg	pointer
,	O
arglen	pointer
)	O
)	O
{	O
if	O
(	O
strlen	function
(	O
arglist	array
[	O
i	long
]	O
)	O
==	O
arglen	pointer
)	O
return	O
i	long
;	O
else	O
if	O
(	O
matchind	int
==	O
-	O
1	int
)	O
matchind	long
=	O
i	long
;	O
else	O
{	O
if	O
(	O
vallist	pointer
==	O
NULL	O
||	O
memcmp	function
(	O
vallist	pointer
+	O
valsize	struct
*	O
matchind	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
{	O
ambiguous	bool
=	O
true	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
ambiguous	pointer
)	O
return	O
-	O
2	int
;	O
else	O
return	O
matchind	pointer
;	O
}	O
void	O
argmatch_invalid	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
ptrdiff_t	long
problem	long
)	O
{	O
char	O
const	O
*	O
format	pointer
=	O
(	O
problem	int
==	O
-	O
1	int
?	O
_	O
(	O
"invalid argument %s for %s"	pointer
)	O
:	O
_	O
(	O
"ambiguous argument %s for %s"	pointer
)	O
)	O
;	O
error	function
(	O
0	int
,	O
0	int
,	O
format	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
ARGMATCH_QUOTING_STYLE	pointer
,	O
value	pointer
)	O
,	O
quote_n	function
(	O
1	int
,	O
context	pointer
)	O
)	O
;	O
}	O
void	O
argmatch_valid	function
(	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
const	O
char	O
*	O
last_val	pointer
=	O
NULL	O
;	O
fputs	function
(	O
_	O
(	O
"Valid arguments are:"	pointer
)	O
,	O
stderr	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
(	O
i	long
==	O
0	int
)	O
||	O
memcmp	function
(	O
last_val	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	long
,	O
valsize	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\n  - %s"	pointer
,	O
quote	function
(	O
arglist	array
[	O
i	long
]	O
)	O
)	O
;	O
last_val	pointer
=	O
vallist	pointer
+	O
valsize	O
*	O
i	long
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
", %s"	pointer
,	O
quote	function
(	O
arglist	array
[	O
i	long
]	O
)	O
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
}	O
ptrdiff_t	bool
__xargmatch_internal	function
(	O
const	O
char	O
*	O
context	pointer
,	O
const	O
char	O
*	O
arg	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
,	O
argmatch_exit_fn	pointer
exit_fn	pointer
)	O
{	O
ptrdiff_t	long
res	long
=	O
argmatch	function
(	O
arg	pointer
,	O
arglist	int
,	O
vallist	pointer
,	O
valsize	pointer
)	O
;	O
if	O
(	O
res	int
>=	O
0	int
)	O
return	O
res	pointer
;	O
argmatch_invalid	function
(	O
context	pointer
,	O
arg	pointer
,	O
res	pointer
)	O
;	O
argmatch_valid	function
(	O
arglist	int
,	O
vallist	pointer
,	O
valsize	int
)	O
;	O
(	O
*	O
exit_fn	pointer
)	O
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
const	O
char	O
*	O
argmatch_to_argument	function
(	O
const	O
char	O
*	O
value	pointer
,	O
const	O
char	O
*	O
const	O
*	O
arglist	pointer
,	O
const	O
char	O
*	O
vallist	pointer
,	O
size_t	long
valsize	long
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
arglist	array
[	O
i	long
]	O
;	O
i	long
++	O
)	O
if	O
(	O
!	O
memcmp	function
(	O
value	pointer
,	O
vallist	pointer
+	O
valsize	O
*	O
i	int
,	O
valsize	int
)	O
)	O
return	O
arglist	array
[	O
i	long
]	O
;	O
return	O
NULL	O
;	O
}	O
bool	bool
c_isascii	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
0x00	int
&&	O
c	int
<=	O
0x7f	int
)	O
;	O
}	O
bool	bool
c_isalnum	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'Z'	O
)	O
)	O
;	O
}	O
bool	bool
c_isalpha	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'Z'	O
)	O
;	O
}	O
bool	bool
c_isblank	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
==	O
' '	O
||	O
c	int
==	O
'\t'	O
)	O
;	O
}	O
bool	bool
c_iscntrl	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
&	O
~	O
0x1f	int
)	O
==	O
0	int
||	O
c	int
==	O
0x7f	int
)	O
;	O
}	O
bool	bool
c_isdigit	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
;	O
}	O
bool	bool
c_islower	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'a'	O
&&	O
c	int
<=	O
'z'	O
)	O
;	O
}	O
bool	bool
c_isgraph	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'!'	O
&&	O
c	int
<=	O
'~'	O
)	O
;	O
}	O
bool	bool
c_isprint	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
' '	O
&&	O
c	int
<=	O
'~'	O
)	O
;	O
}	O
bool	bool
c_ispunct	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
>=	O
'!'	O
&&	O
c	int
<=	O
'~'	O
)	O
&&	O
!	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'Z'	O
)	O
)	O
)	O
;	O
}	O
bool	bool
c_isspace	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
==	O
' '	O
||	O
c	int
==	O
'\t'	O
||	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
'\v'	O
||	O
c	int
==	O
'\f'	O
||	O
c	int
==	O
'\r'	O
)	O
;	O
}	O
bool	bool
c_isupper	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'A'	O
&&	O
c	int
<=	O
'Z'	O
)	O
;	O
}	O
bool	bool
c_isxdigit	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
(	O
c	int
>=	O
'0'	O
&&	O
c	int
<=	O
'9'	O
)	O
||	O
(	O
(	O
c	int
&	O
~	O
0x20	int
)	O
>=	O
'A'	O
&&	O
(	O
c	int
&	O
~	O
0x20	int
)	O
<=	O
'F'	O
)	O
)	O
;	O
}	O
int	O
c_tolower	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'A'	O
&&	O
c	int
<=	O
'Z'	O
?	O
c	int
-	O
'A'	O
+	O
'a'	O
:	O
c	int
)	O
;	O
}	O
int	O
c_toupper	function
(	O
int	O
c	int
)	O
{	O
return	O
(	O
c	int
>=	O
'a'	O
&&	O
c	int
<=	O
'z'	O
?	O
c	int
-	O
'a'	O
+	O
'A'	O
:	O
c	int
)	O
;	O
}	O
int	O
c_strcasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
int	O
c_strncasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
,	O
size_t	long
n	long
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
||	O
n	long
==	O
0	int
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
--	O
n	long
==	O
0	int
||	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
bool	bool
strip_trailing_slashes	function
(	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
base	pointer
=	O
last_component	function
(	O
file	pointer
)	O
;	O
char	O
*	O
base_lim	pointer
;	O
bool	bool
had_slash	bool
;	O
if	O
(	O
!	O
*	O
base	pointer
)	O
base	pointer
=	O
file	pointer
;	O
base_lim	pointer
=	O
base	pointer
+	O
base_len	function
(	O
base	pointer
)	O
;	O
had_slash	bool
=	O
(	O
*	O
base_lim	pointer
!=	O
'\0'	O
)	O
;	O
*	O
base_lim	pointer
=	O
'\0'	O
;	O
return	O
had_slash	bool
;	O
}	O
static	O
inline	O
char	O
*	O
xstrcat	function
(	O
size_t	long
argcount	long
,	O
va_list	array
args	array
)	O
{	O
char	O
*	O
result	pointer
;	O
va_list	array
ap	array
;	O
size_t	long
totalsize	long
;	O
size_t	long
i	long
;	O
char	O
*	O
p	pointer
;	O
totalsize	long
=	O
0	int
;	O
va_copy	O
(	O
ap	array
,	O
args	array
)	O
;	O
for	O
(	O
i	long
=	O
argcount	long
;	O
i	long
>	O
0	int
;	O
i	long
--	O
)	O
{	O
const	O
char	O
*	O
next	pointer
=	O
va_arg	O
(	O
ap	array
,	O
const	O
char	O
*	O
)	O
;	O
totalsize	long
=	O
xsum	function
(	O
totalsize	long
,	O
strlen	function
(	O
next	pointer
)	O
)	O
;	O
}	O
va_end	O
(	O
ap	array
)	O
;	O
if	O
(	O
totalsize	long
==	O
SIZE_MAX	O
||	O
totalsize	long
>	O
INT_MAX	O
)	O
{	O
errno	O
=	O
EOVERFLOW	int
;	O
return	O
NULL	O
;	O
}	O
result	pointer
=	O
XNMALLOC	O
(	O
totalsize	long
+	O
1	int
,	O
char	O
)	O
;	O
p	pointer
=	O
result	pointer
;	O
for	O
(	O
i	long
=	O
argcount	long
;	O
i	long
>	O
0	int
;	O
i	long
--	O
)	O
{	O
const	O
char	O
*	O
next	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
char	O
*	O
)	O
;	O
size_t	long
len	long
=	O
strlen	function
(	O
next	pointer
)	O
;	O
memcpy	function
(	O
p	pointer
,	O
next	pointer
,	O
len	long
)	O
;	O
p	pointer
+=	O
len	long
;	O
}	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
result	pointer
;	O
}	O
char	O
*	O
xvasprintf	function
(	O
const	O
char	O
*	O
format	pointer
,	O
va_list	array
args	array
)	O
{	O
char	O
*	O
result	pointer
;	O
{	O
size_t	long
argcount	long
=	O
0	int
;	O
const	O
char	O
*	O
f	pointer
;	O
for	O
(	O
f	pointer
=	O
format	pointer
;	O
;	O
)	O
{	O
if	O
(	O
*	O
f	pointer
==	O
'\0'	O
)	O
return	O
xstrcat	function
(	O
argcount	long
,	O
args	array
)	O
;	O
if	O
(	O
*	O
f	pointer
!=	O
'%'	O
)	O
break	O
;	O
f	pointer
++	O
;	O
if	O
(	O
*	O
f	pointer
!=	O
's'	O
)	O
break	O
;	O
f	pointer
++	O
;	O
argcount	long
++	O
;	O
}	O
}	O
if	O
(	O
vasprintf	function
(	O
&	O
result	pointer
,	O
format	pointer
,	O
args	array
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOMEM	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
result	pointer
;	O
}	O
char	O
*	O
strkcpy	function
(	O
char	O
*	O
out	pointer
,	O
char	O
*	O
in	pointer
,	O
int	O
size	int
)	O
{	O
strncpy	function
(	O
out	pointer
,	O
in	pointer
,	O
size	int
)	O
;	O
out	pointer
[	O
size	int
-	O
1	int
]	O
=	O
0	int
;	O
return	O
(	O
out	pointer
)	O
;	O
}	O
int	O
strappend	function
(	O
char	O
*	O
*	O
str	pointer
,	O
char	O
*	O
cat	pointer
)	O
{	O
int	O
l1	int
,	O
l2	long
;	O
if	O
(	O
str	pointer
==	O
NULL	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
*	O
str	pointer
==	O
NULL	O
)	O
{	O
*	O
str	pointer
=	O
strdup	function
(	O
cat	pointer
)	O
;	O
malloc_check	O
(	O
*	O
str	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
l1	long
=	O
strlen	function
(	O
*	O
str	pointer
)	O
;	O
l2	long
=	O
strlen	function
(	O
cat	pointer
)	O
;	O
*	O
str	pointer
=	O
realloc	function
(	O
*	O
str	pointer
,	O
l1	long
+	O
l2	long
+	O
1	int
)	O
;	O
malloc_check	O
(	O
*	O
str	pointer
)	O
;	O
strcpy	function
(	O
(	O
*	O
str	pointer
)	O
+	O
l1	long
,	O
cat	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
int	O
vstrappendf	function
(	O
char	O
*	O
*	O
str	pointer
,	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
int	O
n	int
,	O
l	int
,	O
size	int
;	O
if	O
(	O
str	pointer
==	O
NULL	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
*	O
str	pointer
==	O
NULL	O
)	O
l	int
=	O
0	int
;	O
else	O
l	int
=	O
strlen	function
(	O
*	O
str	pointer
)	O
;	O
size	int
=	O
128	int
;	O
*	O
str	pointer
=	O
realloc	function
(	O
*	O
str	pointer
,	O
l	int
+	O
size	int
)	O
;	O
realloc_check	O
(	O
*	O
str	pointer
,	O
l	pointer
+	O
size	int
)	O
;	O
if	O
(	O
*	O
str	pointer
==	O
NULL	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
n	int
=	O
vsnprintf	function
(	O
(	O
*	O
str	pointer
)	O
+	O
l	long
,	O
size	int
,	O
fmt	pointer
,	O
ap	pointer
)	O
;	O
if	O
(	O
n	int
>	O
-	O
1	int
&&	O
n	int
<	O
size	int
)	O
return	O
(	O
0	int
)	O
;	O
else	O
if	O
(	O
n	long
>	O
-	O
1	int
)	O
size	long
=	O
n	int
+	O
1	int
;	O
else	O
size	long
=	O
size	long
*	O
2	int
;	O
if	O
(	O
(	O
*	O
str	pointer
=	O
realloc	function
(	O
*	O
str	pointer
,	O
l	long
+	O
size	int
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
strappendf	function
(	O
char	O
*	O
*	O
str	pointer
,	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
int	O
ret	int
;	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
ret	int
=	O
vstrappendf	function
(	O
str	pointer
,	O
fmt	pointer
,	O
ap	pointer
)	O
;	O
va_end	O
(	O
ap	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
c_strncasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
,	O
size_t	long
n	long
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
||	O
n	long
==	O
0	int
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
--	O
n	long
==	O
0	int
||	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
const	O
char	O
*	O
program_name	pointer
=	O
NULL	O
;	O
void	O
set_program_name	function
(	O
const	O
char	O
*	O
argv0	pointer
)	O
{	O
const	O
char	O
*	O
slash	pointer
;	O
const	O
char	O
*	O
base	pointer
;	O
if	O
(	O
argv0	pointer
==	O
NULL	O
)	O
{	O
fputs	function
(	O
"A NULL argv[0] was passed through an exec system call.\n"	pointer
,	O
stderr	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
slash	pointer
=	O
strrchr	function
(	O
argv0	pointer
,	O
'/'	O
)	O
;	O
base	pointer
=	O
(	O
slash	pointer
!=	O
NULL	O
?	O
slash	pointer
+	O
1	int
:	O
argv0	pointer
)	O
;	O
if	O
(	O
base	pointer
-	O
argv0	pointer
>=	O
7	int
&&	O
strncmp	function
(	O
base	pointer
-	O
7	int
,	O
"/.libs/"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
{	O
argv0	pointer
=	O
base	pointer
;	O
if	O
(	O
strncmp	function
(	O
base	pointer
,	O
"lt-"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
{	O
argv0	pointer
=	O
base	pointer
+	O
3	int
;	O
program_invocation_short_name	pointer
=	O
(	O
char	O
*	O
)	O
argv0	pointer
;	O
}	O
}	O
program_name	pointer
=	O
argv0	pointer
;	O
program_invocation_name	pointer
=	O
(	O
char	O
*	O
)	O
argv0	pointer
;	O
}	O
static	O
void	O
usage	function
(	O
const	O
char	O
*	O
arg	struct
,	O
FILE	struct
*	O
fp	pointer
,	O
int	O
code	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"usage: %s [-h] [-locus] [-delim=char] [-reduce] file\n"	pointer
,	O
arg	struct
)	O
;	O
exit	function
(	O
code	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
progname	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
char	O
*	O
file	pointer
=	O
NULL	O
;	O
struct	O
grecs_node	struct
*	O
tree	pointer
,	O
*	O
node	pointer
;	O
int	O
flags	int
=	O
GRECS_NODE_FLAG_QUOTE	int
|	O
GRECS_NODE_FLAG_PATH	int
;	O
int	O
reduce	int
=	O
0	int
;	O
while	O
(	O
--	O
argc	int
)	O
{	O
char	O
*	O
arg	struct
=	O
*	O
++	O
argv	pointer
;	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-locus"	pointer
)	O
==	O
0	int
)	O
flags	int
|=	O
GRECS_NODE_FLAG_LOCUS	int
;	O
else	O
if	O
(	O
strncmp	function
(	O
arg	struct
,	O
"-delim="	pointer
,	O
7	int
)	O
==	O
0	int
)	O
flags	int
|=	O
arg	struct
[	O
7	int
]	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-reduce"	pointer
)	O
==	O
0	int
)	O
reduce	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
arg	struct
,	O
"-h"	pointer
)	O
==	O
0	int
)	O
usage	function
(	O
progname	pointer
,	O
stdout	pointer
,	O
0	int
)	O
;	O
else	O
if	O
(	O
arg	struct
[	O
0	int
]	O
==	O
'-'	O
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
,	O
1	int
)	O
;	O
else	O
file	pointer
=	O
arg	struct
;	O
}	O
if	O
(	O
!	O
file	pointer
||	O
argc	int
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
,	O
1	int
)	O
;	O
tree	pointer
=	O
grecs_parse	function
(	O
file	pointer
)	O
;	O
if	O
(	O
!	O
tree	pointer
)	O
exit	function
(	O
1	int
)	O
;	O
if	O
(	O
reduce	int
)	O
grecs_tree_reduce	function
(	O
tree	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
for	O
(	O
node	pointer
=	O
grecs_tree_first_node	function
(	O
tree	pointer
)	O
;	O
node	pointer
;	O
node	pointer
=	O
grecs_next_node	function
(	O
node	pointer
)	O
)	O
{	O
grecs_print_node	function
(	O
node	pointer
,	O
flags	int
,	O
stdout	pointer
)	O
;	O
fputc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
}	O
grecs_tree_free	function
(	O
tree	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
static	O
void	O
printer	function
(	O
void	O
*	O
d	pointer
,	O
char	O
const	O
*	O
buf	pointer
,	O
size_t	long
size	long
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
d	pointer
;	O
fwrite	function
(	O
buf	pointer
,	O
size	long
,	O
1	int
,	O
fp	pointer
)	O
;	O
}	O
struct	O
json_format	struct
fmt	pointer
=	O
{	O
0	int
,	O
-	O
1	int
,	O
printer	pointer
,	O
NULL	O
}	O
;	O
static	O
void	O
usage	function
(	O
const	O
char	O
*	O
arg	struct
,	O
FILE	struct
*	O
fp	pointer
,	O
int	O
code	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"usage: %s [-file=FILE][-indent=N][-precision=N] [expr]\n"	pointer
,	O
arg	pointer
)	O
;	O
exit	function
(	O
code	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
progname	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
char	O
*	O
file	pointer
=	O
NULL	O
;	O
char	O
*	O
input	pointer
;	O
size_t	long
size	long
;	O
struct	O
json_value	struct
*	O
obj	pointer
;	O
char	O
*	O
key	pointer
=	O
NULL	O
;	O
while	O
(	O
--	O
argc	int
)	O
{	O
char	O
*	O
arg	pointer
=	O
*	O
++	O
argv	pointer
;	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"-file="	pointer
,	O
6	int
)	O
==	O
0	int
)	O
file	pointer
=	O
arg	pointer
+	O
6	int
;	O
else	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"-indent="	pointer
,	O
8	int
)	O
==	O
0	int
)	O
fmt	pointer
.	O
indent	int
=	O
atoi	function
(	O
arg	pointer
+	O
8	int
)	O
;	O
else	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"-search="	pointer
,	O
8	int
)	O
==	O
0	int
)	O
key	pointer
=	O
arg	pointer
+	O
8	int
;	O
else	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"-precision="	pointer
,	O
11	int
)	O
==	O
0	int
)	O
fmt	pointer
.	O
precision	long
=	O
atoi	function
(	O
arg	pointer
+	O
11	int
)	O
;	O
else	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
,	O
1	int
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
file	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
int	O
fd	int
;	O
ssize_t	long
n	long
;	O
if	O
(	O
argc	long
!=	O
0	int
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
,	O
1	int
)	O
;	O
fd	int
=	O
open	function
(	O
file	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
file	pointer
)	O
;	O
return	O
2	int
;	O
}	O
if	O
(	O
fstat	function
(	O
fd	int
,	O
&	O
st	struct
)	O
)	O
{	O
perror	function
(	O
"fstat"	pointer
)	O
;	O
return	O
2	int
;	O
}	O
size	long
=	O
(	O
size_t	long
)	O
st	struct
.	O
st_size	long
;	O
if	O
(	O
size	long
!=	O
st	struct
.	O
st_size	long
)	O
abort	function
(	O
)	O
;	O
input	pointer
=	O
grecs_malloc	function
(	O
size	long
+	O
1	int
)	O
;	O
n	long
=	O
read	pointer
(	O
fd	int
,	O
input	pointer
,	O
size	long
)	O
;	O
if	O
(	O
n	int
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"read"	pointer
)	O
;	O
return	O
2	int
;	O
}	O
if	O
(	O
n	long
!=	O
size	long
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: short read from %s\n"	pointer
,	O
progname	pointer
,	O
file	pointer
)	O
;	O
return	O
2	int
;	O
}	O
input	pointer
[	O
n	long
]	O
=	O
0	int
;	O
close	function
(	O
fd	int
)	O
;	O
}	O
else	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
if	O
(	O
file	pointer
)	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
,	O
1	int
)	O
;	O
input	pointer
=	O
*	O
argv	pointer
;	O
size	long
=	O
strlen	function
(	O
input	pointer
)	O
;	O
}	O
else	O
usage	function
(	O
progname	pointer
,	O
stderr	pointer
,	O
1	int
)	O
;	O
obj	pointer
=	O
json_parse_string	function
(	O
input	pointer
,	O
size	int
)	O
;	O
if	O
(	O
!	O
obj	pointer
)	O
{	O
json_err_locus	struct
.	O
beg	struct
.	O
file	pointer
=	O
json_err_locus	struct
.	O
end	struct
.	O
file	pointer
=	O
file	pointer
?	O
file	pointer
:	O
"input"	O
;	O
grecs_error	function
(	O
&	O
json_err_locus	struct
,	O
0	int
,	O
"%s"	pointer
,	O
json_err_diag	pointer
)	O
;	O
return	O
3	int
;	O
}	O
if	O
(	O
key	pointer
)	O
{	O
struct	O
json_value	struct
*	O
p	pointer
=	O
json_value_lookup	function
(	O
obj	pointer
,	O
key	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
4	int
;	O
obj	pointer
=	O
p	pointer
;	O
}	O
fmt	pointer
.	O
data	pointer
=	O
stdout	pointer
;	O
json_format_value	function
(	O
obj	pointer
,	O
&	O
fmt	pointer
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
return	O
0	int
;	O
}	O
pies_identity_t	function
pies_identity_create	function
(	O
char	O
const	O
*	O
user	pointer
)	O
{	O
pies_identity_t	pointer
id	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
id	pointer
)	O
)	O
;	O
if	O
(	O
id	pointer
)	O
{	O
id	pointer
->	O
provider	pointer
=	O
NULL	O
;	O
id	pointer
->	O
data	pointer
=	O
NULL	O
;	O
id	pointer
->	O
username	pointer
=	O
strdup	function
(	O
user	pointer
)	O
;	O
if	O
(	O
!	O
id	pointer
)	O
{	O
int	O
ec	int
=	O
errno	O
;	O
free	function
(	O
id	pointer
)	O
;	O
errno	O
=	O
ec	int
;	O
id	pointer
=	O
NULL	O
;	O
}	O
}	O
return	O
id	int
;	O
}	O
int	O
pies_authenticate	function
(	O
pies_identity_provider_t	pointer
pr	pointer
,	O
pies_identity_t	pointer
id	pointer
,	O
char	O
const	O
*	O
passwd	pointer
)	O
{	O
if	O
(	O
!	O
pr	int
||	O
!	O
id	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
pr	pointer
->	O
mech	pointer
->	O
authenticate	pointer
(	O
pr	int
,	O
id	int
,	O
passwd	pointer
)	O
==	O
0	int
)	O
{	O
id	pointer
->	O
provider	int
=	O
pr	int
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
char	O
const	O
*	O
pies_identity_user_name	function
(	O
pies_identity_t	pointer
id	pointer
)	O
{	O
if	O
(	O
!	O
id	pointer
)	O
return	O
NULL	O
;	O
return	O
id	pointer
->	O
username	pointer
;	O
}	O
int	O
pies_identity_is_user	function
(	O
pies_identity_t	pointer
id	pointer
,	O
char	O
*	O
const	O
*	O
users	pointer
)	O
{	O
if	O
(	O
!	O
id	int
)	O
return	O
0	int
;	O
return	O
is_array_member	function
(	O
users	O
,	O
id	pointer
->	O
username	pointer
)	O
;	O
}	O
int	O
pies_identity_is_group_member	function
(	O
pies_identity_t	pointer
id	pointer
,	O
char	O
*	O
const	O
*	O
groups	pointer
)	O
{	O
pies_identity_provider_t	pointer
provider	pointer
;	O
if	O
(	O
!	O
id	pointer
)	O
return	O
0	int
;	O
provider	pointer
=	O
id	pointer
->	O
provider	pointer
;	O
if	O
(	O
!	O
provider	pointer
)	O
return	O
0	int
;	O
return	O
provider	pointer
->	O
mech	pointer
->	O
is_group_member	pointer
(	O
provider	pointer
,	O
id	int
,	O
groups	pointer
)	O
;	O
}	O
void	O
pies_identity_destroy	function
(	O
pies_identity_t	pointer
id	pointer
)	O
{	O
pies_identity_provider_t	pointer
provider	pointer
=	O
id	pointer
->	O
provider	pointer
;	O
if	O
(	O
provider	pointer
&&	O
provider	pointer
->	O
mech	pointer
->	O
destroy_identity	pointer
)	O
provider	pointer
->	O
mech	pointer
->	O
destroy_identity	pointer
(	O
provider	pointer
,	O
id	int
)	O
;	O
free	function
(	O
id	pointer
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
*	O
progname	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
int	O
c	int
;	O
unsigned	O
count	int
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: %s FILE\n"	pointer
,	O
progname	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Prints number of lines in FILE.\n"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
fp	pointer
=	O
fopen	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
perror	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
2	int
;	O
}	O
count	int
=	O
0	int
;	O
while	O
(	O
(	O
c	int
=	O
fgetc	function
(	O
fp	pointer
)	O
)	O
!=	O
EOF	O
)	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
count	int
++	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
printf	function
(	O
"%u\n"	pointer
,	O
count	int
)	O
;	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
linemodes	array
[	O
NO_OF_LINEMODES	int
]	O
=	O
{	O
"solid"	pointer
,	O
"dotted"	pointer
,	O
"dotdashed"	pointer
,	O
"shortdashed"	pointer
,	O
"longdashed"	pointer
}	O
;	O
const	O
char	O
*	O
colorstyle	array
[	O
NO_OF_LINEMODES	int
]	O
=	O
{	O
"red"	pointer
,	O
"green"	pointer
,	O
"blue"	pointer
,	O
"magenta"	pointer
,	O
"cyan"	pointer
}	O
;	O
typedef	O
struct	O
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
Plotter	struct
*	O
default_init	pointer
;	O
}	O
Plotter_data	struct
;	O
static	O
const	O
Plotter_data	struct
_plotter_data	array
[	O
]	O
=	O
{	O
{	O
"generic"	pointer
,	O
&	O
_pl_g_default_plotter	int
}	O
,	O
{	O
"bitmap"	pointer
,	O
&	O
_pl_b_default_plotter	int
}	O
,	O
{	O
"meta"	pointer
,	O
&	O
_pl_m_default_plotter	struct
}	O
,	O
{	O
"tek"	pointer
,	O
&	O
_pl_t_default_plotter	function
}	O
,	O
{	O
"regis"	pointer
,	O
&	O
_pl_r_default_plotter	O
}	O
,	O
{	O
"hpgl"	pointer
,	O
&	O
_pl_h_default_plotter	O
}	O
,	O
{	O
"pcl"	pointer
,	O
&	O
_pl_q_default_plotter	O
}	O
,	O
{	O
"fig"	pointer
,	O
&	O
_pl_f_default_plotter	struct
}	O
,	O
{	O
"cgm"	pointer
,	O
&	O
_pl_c_default_plotter	O
}	O
,	O
{	O
"ps"	pointer
,	O
&	O
_pl_p_default_plotter	O
}	O
,	O
{	O
"ai"	pointer
,	O
&	O
_pl_a_default_plotter	O
}	O
,	O
{	O
"svg"	pointer
,	O
&	O
_pl_s_default_plotter	function
}	O
,	O
{	O
"gif"	pointer
,	O
&	O
_pl_i_default_plotter	O
}	O
,	O
{	O
"pnm"	pointer
,	O
&	O
_pl_n_default_plotter	function
}	O
,	O
{	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
(	O
const	O
Plotter	struct
*	O
)	O
NULL	O
}	O
}	O
;	O
static	O
bool	bool
_string_to_plotter_data	function
(	O
const	O
char	O
*	O
type	pointer
,	O
int	O
*	O
position	pointer
)	O
;	O
static	O
void	O
_api_warning	function
(	O
const	O
char	O
*	O
msg	pointer
)	O
;	O
Plotter	struct
*	O
pl_newpl_r	function
(	O
const	O
char	O
*	O
type	struct
,	O
FILE	struct
*	O
infile	pointer
,	O
FILE	struct
*	O
outfile	pointer
,	O
FILE	struct
*	O
errfile	pointer
,	O
const	O
PlotterParams	struct
*	O
plotter_params	pointer
)	O
{	O
bool	enum
found	enum
;	O
int	O
position	long
;	O
Plotter	struct
*	O
_plotter	pointer
;	O
found	enum
=	O
_string_to_plotter_data	function
(	O
type	enum
,	O
&	O
position	double
)	O
;	O
if	O
(	O
!	O
found	int
)	O
{	O
_api_warning	function
(	O
"ignoring request to create plotter of unknown type"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
_plotter	pointer
=	O
(	O
Plotter	struct
*	O
)	O
_pl_xmalloc	function
(	O
sizeof	O
(	O
Plotter	struct
)	O
)	O
;	O
memcpy	function
(	O
_plotter	pointer
,	O
_plotter_data	pointer
[	O
position	long
]	O
.	O
default_init	array
,	O
sizeof	O
(	O
Plotter	struct
)	O
)	O
;	O
_plotter	pointer
->	O
data	pointer
=	O
(	O
plPlotterData	struct
*	O
)	O
_pl_xmalloc	function
(	O
sizeof	O
(	O
plPlotterData	struct
)	O
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
infp	pointer
=	O
infile	pointer
;	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
=	O
outfile	pointer
;	O
_plotter	pointer
->	O
data	pointer
->	O
errfp	pointer
=	O
errfile	int
;	O
_pl_g_copy_params_to_plotter	function
(	O
_plotter	pointer
,	O
plotter_params	pointer
)	O
;	O
_plotter	pointer
->	O
initialize	pointer
(	O
_plotter	pointer
)	O
;	O
return	O
_plotter	pointer
;	O
}	O
static	O
bool	enum
_string_to_plotter_data	function
(	O
const	O
char	O
*	O
type	pointer
,	O
int	O
*	O
position	pointer
)	O
{	O
const	O
Plotter_data	struct
*	O
p	pointer
=	O
_plotter_data	O
;	O
bool	bool
found	bool
=	O
false	int
;	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
p	pointer
->	O
name	pointer
)	O
{	O
if	O
(	O
strcasecmp	function
(	O
(	O
char	O
*	O
)	O
type	pointer
,	O
(	O
char	O
*	O
)	O
p	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
found	enum
=	O
true	int
;	O
break	O
;	O
}	O
p	pointer
++	O
;	O
i	int
++	O
;	O
}	O
if	O
(	O
found	enum
)	O
*	O
position	pointer
=	O
i	int
;	O
return	O
found	int
;	O
}	O
int	O
pl_deletepl_r	function
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
{	O
if	O
(	O
_plotter	pointer
==	O
NULL	O
)	O
{	O
_api_warning	function
(	O
"ignoring request to delete a null Plotter"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
open	enum
)	O
_API_closepl	O
(	O
_plotter	pointer
)	O
;	O
_plotter	pointer
->	O
terminate	function
(	O
_plotter	pointer
)	O
;	O
free	function
(	O
_plotter	pointer
->	O
data	pointer
)	O
;	O
free	function
(	O
_plotter	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
_api_warning	function
(	O
const	O
char	O
*	O
msg	pointer
)	O
{	O
if	O
(	O
pl_libplot_warning_handler	pointer
!=	O
NULL	O
)	O
(	O
*	O
pl_libplot_warning_handler	pointer
)	O
(	O
msg	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"libplot: %s\n"	pointer
,	O
msg	pointer
)	O
;	O
}	O
PlotterParams	struct
*	O
pl_newplparams	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
PlotterParams	struct
*	O
_plotter_params_p	pointer
;	O
_plotter_params_p	pointer
=	O
(	O
PlotterParams	struct
*	O
)	O
_pl_xmalloc	function
(	O
sizeof	O
(	O
PlotterParams	struct
)	O
)	O
;	O
memcpy	function
(	O
_plotter_params_p	pointer
,	O
&	O
_default_plotter_params	struct
,	O
sizeof	O
(	O
PlotterParams	struct
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_PLOTTER_PARAMETERS	int
;	O
i	int
++	O
)	O
_plotter_params_p	pointer
->	O
plparams	array
[	O
i	int
]	O
=	O
(	O
void	O
*	O
)	O
NULL	O
;	O
return	O
_plotter_params_p	int
;	O
}	O
int	O
pl_deleteplparams	function
(	O
PlotterParams	struct
*	O
_plotter_params_p	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_PLOTTER_PARAMETERS	int
;	O
i	int
++	O
)	O
if	O
(	O
_known_params	array
[	O
i	int
]	O
.	O
is_string	enum
&&	O
_plotter_params_p	pointer
->	O
plparams	array
[	O
i	int
]	O
!=	O
NULL	O
)	O
free	function
(	O
_plotter_params_p	pointer
->	O
plparams	array
[	O
i	int
]	O
)	O
;	O
free	function
(	O
_plotter_params_p	pointer
)	O
;	O
return	O
0	int
;	O
}	O
PlotterParams	struct
*	O
pl_copyplparams	function
(	O
const	O
PlotterParams	struct
*	O
_plotter_params_p	pointer
)	O
{	O
int	O
i	int
;	O
PlotterParams	struct
*	O
new_plotter_params_p	pointer
;	O
new_plotter_params_p	pointer
=	O
(	O
PlotterParams	struct
*	O
)	O
_pl_xmalloc	function
(	O
sizeof	O
(	O
PlotterParams	struct
)	O
)	O
;	O
memcpy	function
(	O
new_plotter_params_p	pointer
,	O
&	O
_default_plotter_params	struct
,	O
sizeof	O
(	O
PlotterParams	struct
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_PLOTTER_PARAMETERS	int
;	O
i	int
++	O
)	O
new_plotter_params_p	pointer
->	O
plparams	array
[	O
i	int
]	O
=	O
_plotter_params_p	pointer
->	O
plparams	array
[	O
i	int
]	O
;	O
return	O
new_plotter_params_p	int
;	O
}	O
int	O
pl_setplparam	function
(	O
PlotterParams	struct
*	O
plotter_params	pointer
,	O
const	O
char	O
*	O
parameter	pointer
,	O
void	O
*	O
value	pointer
)	O
{	O
return	O
plotter_params	pointer
->	O
setplparam	pointer
(	O
plotter_params	pointer
,	O
parameter	pointer
,	O
value	pointer
)	O
;	O
}	O
static	O
const	O
int	O
_ai_fill_rule	array
[	O
PL_NUM_FILL_RULES	int
]	O
=	O
{	O
AI_FILL_ODD_WINDING	int
,	O
AI_FILL_NONZERO_WINDING	int
}	O
;	O
static	O
const	O
int	O
_ai_join_style	array
[	O
PL_NUM_JOIN_TYPES	int
]	O
=	O
{	O
AI_LINE_JOIN_MITER	int
,	O
AI_LINE_JOIN_ROUND	int
,	O
AI_LINE_JOIN_BEVEL	int
,	O
AI_LINE_JOIN_ROUND	int
}	O
;	O
static	O
const	O
int	O
_ai_cap_style	array
[	O
PL_NUM_CAP_TYPES	int
]	O
=	O
{	O
AI_LINE_CAP_BUTT	int
,	O
AI_LINE_CAP_ROUND	int
,	O
AI_LINE_CAP_PROJECT	int
,	O
AI_LINE_CAP_ROUND	int
}	O
;	O
void	O
_pl_a_set_attributes	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
bool	enum
changed_width	enum
=	O
false	int
;	O
int	O
desired_fill_rule	int
=	O
_ai_fill_rule	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_rule_type	int
]	O
;	O
double	O
desired_ai_line_width	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
device_line_width	double
;	O
int	O
desired_ai_cap_style	int
=	O
_ai_cap_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
cap_type	int
]	O
;	O
int	O
desired_ai_join_style	int
=	O
_ai_join_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
]	O
;	O
double	O
desired_ai_miter_limit	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
miter_limit	double
;	O
int	O
desired_ai_line_type	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
;	O
int	O
i	int
;	O
double	O
display_size_in_points	double
,	O
min_dash_unit	int
;	O
if	O
(	O
_plotter	pointer
->	O
ai_version	int
>=	O
AI_VERSION_5	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
>	O
0	int
&&	O
_plotter	pointer
->	O
ai_fill_rule_type	int
!=	O
desired_fill_rule	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d XR\n"	pointer
,	O
desired_fill_rule	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_fill_rule_type	int
=	O
desired_fill_rule	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
ai_cap_style	int
!=	O
desired_ai_cap_style	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d J\n"	pointer
,	O
desired_ai_cap_style	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_cap_style	int
=	O
desired_ai_cap_style	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
ai_join_style	int
!=	O
desired_ai_join_style	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d j\n"	pointer
,	O
desired_ai_join_style	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_join_style	int
=	O
desired_ai_join_style	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
==	O
PL_JOIN_MITER	int
&&	O
_plotter	pointer
->	O
ai_miter_limit	double
!=	O
desired_ai_miter_limit	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.4g M\n"	pointer
,	O
desired_ai_miter_limit	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_miter_limit	double
=	O
desired_ai_miter_limit	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
ai_line_width	double
!=	O
desired_ai_line_width	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.4f w\n"	pointer
,	O
desired_ai_line_width	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_line_width	double
=	O
desired_ai_line_width	int
;	O
changed_width	enum
=	O
true	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_in_effect	enum
||	O
_plotter	pointer
->	O
ai_line_type	int
!=	O
desired_ai_line_type	int
||	O
(	O
changed_width	int
&&	O
desired_ai_line_type	int
!=	O
PL_L_SOLID	int
)	O
)	O
{	O
double	O
*	O
dashbuf	pointer
;	O
int	O
num_dashes	int
;	O
double	O
offset	double
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_in_effect	enum
)	O
{	O
num_dashes	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_len	int
;	O
if	O
(	O
num_dashes	int
>	O
0	int
)	O
{	O
double	O
min_sing_val	pointer
,	O
max_sing_val	pointer
;	O
_matrix_sing_vals	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
,	O
&	O
min_sing_val	pointer
,	O
&	O
max_sing_val	pointer
)	O
;	O
dashbuf	pointer
=	O
(	O
double	O
*	O
)	O
_pl_xmalloc	function
(	O
num_dashes	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
{	O
double	O
dashlen	int
;	O
dashlen	int
=	O
min_sing_val	pointer
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
[	O
i	int
]	O
;	O
dashbuf	pointer
[	O
i	int
]	O
=	O
dashlen	int
;	O
}	O
offset	double
=	O
min_sing_val	pointer
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_offset	double
;	O
}	O
else	O
{	O
dashbuf	pointer
=	O
NULL	O
;	O
offset	int
=	O
0	int
;	O
}	O
desired_ai_line_type	double
=	O
SPECIAL_AI_LINE_TYPE	int
;	O
}	O
else	O
{	O
if	O
(	O
desired_ai_line_type	int
==	O
PL_L_SOLID	int
)	O
{	O
num_dashes	int
=	O
0	int
;	O
dashbuf	pointer
=	O
NULL	O
;	O
offset	double
=	O
0.0	int
;	O
}	O
else	O
{	O
const	O
int	O
*	O
dash_array	pointer
;	O
double	O
scale	double
;	O
num_dashes	int
=	O
_pl_g_line_styles	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
]	O
.	O
dash_array_len	int
;	O
dashbuf	pointer
=	O
(	O
double	O
*	O
)	O
_pl_xmalloc	function
(	O
num_dashes	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
dash_array	pointer
=	O
_pl_g_line_styles	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
]	O
.	O
dash_array	pointer
;	O
display_size_in_points	double
=	O
DMIN	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
xmax	double
-	O
_plotter	pointer
->	O
data	pointer
->	O
xmin	double
,	O
_plotter	pointer
->	O
data	pointer
->	O
ymax	double
-	O
_plotter	pointer
->	O
data	pointer
->	O
ymin	double
)	O
;	O
min_dash_unit	int
=	O
(	O
PL_MIN_DASH_UNIT_AS_FRACTION_OF_DISPLAY_SIZE	struct
*	O
display_size_in_points	pointer
)	O
;	O
scale	double
=	O
DMAX	O
(	O
min_dash_unit	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
device_line_width	double
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
dashbuf	pointer
[	O
i	int
]	O
=	O
scale	double
*	O
dash_array	pointer
[	O
i	int
]	O
;	O
offset	double
=	O
0.0	int
;	O
}	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"["	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
0	int
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.4f"	pointer
,	O
dashbuf	pointer
[	O
i	int
]	O
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
" %.4f"	pointer
,	O
dashbuf	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"] %.4f d\n"	pointer
,	O
offset	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
ai_line_type	pointer
=	O
desired_ai_line_type	pointer
;	O
free	function
(	O
dashbuf	pointer
)	O
;	O
}	O
return	O
;	O
}	O
bool	enum
_pl_a_begin_page	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
PL_NUM_PS_FONTS	int
;	O
i	int
++	O
)	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
ps_font_used	array
[	O
i	int
]	O
=	O
false	int
;	O
_plotter	pointer
->	O
ai_pen_cyan	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
ai_pen_magenta	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
ai_pen_yellow	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
ai_pen_black	double
=	O
1.0	int
;	O
_plotter	pointer
->	O
ai_fill_cyan	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
ai_fill_magenta	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
ai_fill_yellow	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
ai_fill_black	double
=	O
1.0	int
;	O
_plotter	pointer
->	O
ai_cyan_used	enum
=	O
false	int
;	O
_plotter	pointer
->	O
ai_magenta_used	enum
=	O
false	int
;	O
_plotter	pointer
->	O
ai_yellow_used	enum
=	O
false	int
;	O
_plotter	pointer
->	O
ai_black_used	enum
=	O
false	int
;	O
_plotter	pointer
->	O
ai_cap_style	int
=	O
AI_LINE_CAP_BUTT	int
;	O
_plotter	pointer
->	O
ai_join_style	int
=	O
AI_LINE_JOIN_MITER	int
;	O
_plotter	pointer
->	O
ai_miter_limit	double
=	O
4.0	int
;	O
_plotter	pointer
->	O
ai_line_type	int
=	O
PL_L_SOLID	int
;	O
_plotter	pointer
->	O
ai_line_width	double
=	O
1.0	int
;	O
_plotter	pointer
->	O
ai_fill_rule_type	int
=	O
0	int
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
parse_bitmap_size	bool
(	O
const	O
char	O
*	O
bitmap_size_s	pointer
,	O
int	O
*	O
width	int
,	O
int	O
*	O
height	int
)	O
;	O
const	O
Plotter	struct
_pl_b_default_plotter	struct
=	O
{	O
_pl_b_initialize	pointer
,	O
_pl_b_terminate	function
,	O
_pl_b_begin_page	function
,	O
_pl_b_erase_page	function
,	O
_pl_b_end_page	function
,	O
_pl_g_push_state	function
,	O
_pl_g_pop_state	function
,	O
_pl_b_paint_path	function
,	O
_pl_b_paint_paths	function
,	O
_pl_g_path_is_flushable	function
,	O
_pl_g_maybe_prepaint_segments	function
,	O
_pl_g_paint_marker	function
,	O
_pl_b_paint_point	function
,	O
_pl_g_paint_text_string_with_escapes	function
,	O
_pl_g_paint_text_string	function
,	O
_pl_g_get_text_width	function
,	O
_pl_g_retrieve_font	function
,	O
_pl_g_flush_output	function
,	O
_pl_g_warning	function
,	O
_pl_g_error	function
,	O
}	O
;	O
void	O
_pl_b_initialize	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
_pl_g_initialize	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
type	enum
=	O
PL_BITMAP	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
output_model	enum
=	O
PL_OUTPUT_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_wide_lines	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_dash_array	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_solid_fill	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_odd_winding_fill	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_nonzero_winding_fill	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_settable_bg	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_escaped_string_support	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_ps_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_pcl_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_stick_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_extra_stick_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_other_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
default_font_type	int
=	O
PL_F_HERSHEY	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
pcl_before_ps	enum
=	O
false	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_horizontal_justification	enum
=	O
false	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_vertical_justification	enum
=	O
false	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
issue_font_warning	enum
=	O
true	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_mixed_paths	enum
=	O
false	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_arc_scaling	enum
=	O
AS_AXES_PRESERVED	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_ellarc_scaling	enum
=	O
AS_AXES_PRESERVED	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_quad_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_cubic_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_box_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_circle_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_ellipse_scaling	enum
=	O
AS_AXES_PRESERVED	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
display_model_type	int
=	O
(	O
int	O
)	O
DISP_MODEL_VIRTUAL	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
display_coors_type	int
=	O
(	O
int	O
)	O
DISP_DEVICE_COORS_INTEGER_LIBXMI	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
flipped_y	enum
=	O
true	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
imin	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
=	O
569	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
=	O
569	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmax	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
xmin	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
xmax	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
ymin	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
ymax	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
page_data	pointer
=	O
(	O
plPageData	struct
*	O
)	O
NULL	O
;	O
_plotter	pointer
->	O
b_xn	enum
=	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
+	O
1	int
;	O
_plotter	pointer
->	O
b_yn	enum
=	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
+	O
1	int
;	O
_plotter	pointer
->	O
b_painted_set	pointer
=	O
(	O
void	O
*	O
)	O
NULL	O
;	O
_plotter	pointer
->	O
b_canvas	pointer
=	O
(	O
void	O
*	O
)	O
NULL	O
;	O
_plotter	pointer
->	O
b_arc_cache_data	pointer
=	O
(	O
void	O
*	O
)	O
miNewEllipseCache	function
(	O
)	O
;	O
{	O
const	O
char	O
*	O
bitmap_size_s	pointer
;	O
int	O
width	int
=	O
1	int
,	O
height	int
=	O
1	int
;	O
bitmap_size_s	pointer
=	O
(	O
const	O
char	O
*	O
)	O
_get_plot_param	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"BITMAPSIZE"	pointer
)	O
;	O
if	O
(	O
bitmap_size_s	int
&&	O
parse_bitmap_size	function
(	O
bitmap_size_s	pointer
,	O
&	O
width	int
,	O
&	O
height	int
)	O
&&	O
width	int
>=	O
1	int
&&	O
height	int
>=	O
1	int
)	O
{	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
=	O
width	int
-	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
=	O
height	int
-	O
1	int
;	O
_plotter	pointer
->	O
b_xn	int
=	O
width	int
;	O
_plotter	pointer
->	O
b_yn	int
=	O
height	int
;	O
}	O
}	O
_compute_ndc_to_device_map	function
(	O
_plotter	pointer
->	O
data	pointer
)	O
;	O
}	O
static	O
bool	enum
parse_bitmap_size	function
(	O
const	O
char	O
*	O
bitmap_size_s	pointer
,	O
int	O
*	O
width	int
,	O
int	O
*	O
height	int
)	O
{	O
int	O
local_width	int
=	O
1	int
,	O
local_height	int
=	O
1	int
;	O
if	O
(	O
bitmap_size_s	int
&&	O
sscanf	function
(	O
bitmap_size_s	pointer
,	O
"%dx%d"	pointer
,	O
&	O
local_width	pointer
,	O
&	O
local_height	pointer
)	O
==	O
2	int
&&	O
local_width	int
>	O
0	int
&&	O
local_height	int
>	O
0	int
)	O
{	O
*	O
width	pointer
=	O
local_width	int
;	O
*	O
height	int
=	O
local_height	int
;	O
return	O
true	int
;	O
}	O
else	O
return	O
false	int
;	O
}	O
void	O
_pl_b_terminate	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
miDeleteEllipseCache	function
(	O
(	O
miEllipseCache	struct
*	O
)	O
_plotter	pointer
->	O
b_arc_cache_data	pointer
)	O
;	O
_pl_g_terminate	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
}	O
int	O
_maybe_output_image	function
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
{	O
int	O
retval	int
;	O
switch	O
(	O
(	O
int	O
)	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
type	enum
)	O
)	O
{	O
case	O
(	O
int	O
)	O
PL_BITMAP	O
:	O
default	O
:	O
retval	int
=	O
_pl_b_maybe_output_image	function
(	O
_plotter	pointer
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
PL_PNM	int
:	O
retval	int
=	O
_pl_n_maybe_output_image	function
(	O
_plotter	pointer
)	O
;	O
break	O
;	O
}	O
return	O
retval	int
;	O
}	O
bool	enum
_pl_b_erase_page	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
_pl_b_delete_image	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_pl_b_new_image	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
return	O
true	int
;	O
}	O
bool	enum
_pl_b_begin_page	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
_pl_b_new_image	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
return	O
true	int
;	O
}	O
void	O
_pl_b_new_image	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
unsigned	O
char	O
red	int
,	O
green	int
,	O
blue	int
;	O
miPixel	struct
pixel	struct
;	O
red	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
red	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
green	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
green	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
blue	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
blue	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
pixel	struct
.	O
type	enum
=	O
MI_PIXEL_RGB_TYPE	int
;	O
pixel	struct
.	O
u	O
.	O
rgb	array
[	O
0	int
]	O
=	O
red	int
;	O
pixel	struct
.	O
u	O
.	O
rgb	array
[	O
1	int
]	O
=	O
green	int
;	O
pixel	struct
.	O
u	O
.	O
rgb	array
[	O
2	int
]	O
=	O
blue	int
;	O
_plotter	pointer
->	O
b_painted_set	pointer
=	O
(	O
void	O
*	O
)	O
miNewPaintedSet	O
(	O
)	O
;	O
_plotter	pointer
->	O
b_canvas	pointer
=	O
(	O
void	O
*	O
)	O
miNewCanvas	O
(	O
(	O
unsigned	O
int	O
)	O
_plotter	pointer
->	O
b_xn	pointer
,	O
(	O
unsigned	O
int	O
)	O
_plotter	pointer
->	O
b_yn	pointer
,	O
pixel	int
)	O
;	O
}	O
void	O
_pl_b_paint_point	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
double	O
xx	int
,	O
yy	int
;	O
int	O
ixx	int
,	O
iyy	int
;	O
unsigned	O
char	O
red	int
,	O
green	int
,	O
blue	int
;	O
miGC	struct
*	O
pGC	pointer
;	O
miPixel	struct
fgPixel	struct
,	O
bgPixel	struct
,	O
pixels	pointer
[	O
2	int
]	O
;	O
miPoint	struct
point	pointer
,	O
offset	array
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
!=	O
0	int
)	O
{	O
xx	int
=	O
XD	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
)	O
;	O
yy	int
=	O
YD	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
)	O
;	O
ixx	int
=	O
IROUND	O
(	O
xx	int
)	O
;	O
iyy	int
=	O
IROUND	O
(	O
yy	int
)	O
;	O
red	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
red	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
green	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
green	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
blue	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
.	O
blue	int
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
bgPixel	struct
.	O
type	enum
=	O
MI_PIXEL_RGB_TYPE	int
;	O
bgPixel	struct
.	O
u	union
.	O
rgb	array
[	O
0	int
]	O
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
red	int
&	O
0xff	int
;	O
bgPixel	struct
.	O
u	O
.	O
rgb	array
[	O
1	int
]	O
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
green	int
&	O
0xff	int
;	O
bgPixel	struct
.	O
u	O
.	O
rgb	array
[	O
2	int
]	O
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
bgcolor	struct
.	O
blue	int
&	O
0xff	int
;	O
fgPixel	struct
.	O
type	enum
=	O
MI_PIXEL_RGB_TYPE	int
;	O
fgPixel	struct
.	O
u	O
.	O
rgb	array
[	O
0	int
]	O
=	O
red	int
;	O
fgPixel	struct
.	O
u	O
.	O
rgb	array
[	O
1	int
]	O
=	O
green	int
;	O
fgPixel	struct
.	O
u	O
.	O
rgb	array
[	O
2	int
]	O
=	O
blue	int
;	O
pixels	pointer
[	O
0	int
]	O
=	O
bgPixel	struct
;	O
pixels	pointer
[	O
1	int
]	O
=	O
fgPixel	struct
;	O
pGC	pointer
=	O
miNewGC	O
(	O
2	int
,	O
pixels	pointer
)	O
;	O
_set_common_mi_attributes	function
(	O
_plotter	pointer
->	O
drawstate	pointer
,	O
(	O
void	O
*	O
)	O
pGC	pointer
)	O
;	O
point	pointer
.	O
x	double
=	O
ixx	int
;	O
point	pointer
.	O
y	double
=	O
iyy	int
;	O
miDrawPoints	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
pGC	pointer
,	O
MI_COORD_MODE_ORIGIN	int
,	O
1	int
,	O
&	O
point	pointer
)	O
;	O
miDeleteGC	O
(	O
pGC	pointer
)	O
;	O
offset	array
.	O
x	double
=	O
0	int
;	O
offset	array
.	O
y	double
=	O
0	int
;	O
miCopyPaintedSetToCanvas	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
,	O
(	O
miCanvas	struct
*	O
)	O
_plotter	pointer
->	O
b_canvas	pointer
,	O
offset	int
)	O
;	O
miClearPaintedSet	O
(	O
(	O
miPaintedSet	struct
*	O
)	O
_plotter	pointer
->	O
b_painted_set	pointer
)	O
;	O
}	O
}	O
static	O
int	O
_fig_pseudocolor	function
(	O
int	O
red	int
,	O
int	O
green	int
,	O
int	O
blue	int
,	O
const	O
long	O
int	O
*	O
fig_usercolors	pointer
,	O
int	O
fig_num_usercolors	int
)	O
;	O
int	O
_pl_f_fig_color	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
red	int
,	O
int	O
green	int
,	O
int	O
blue	int
)	O
{	O
int	O
fig_fgcolor_red	int
,	O
fig_fgcolor_green	int
,	O
fig_fgcolor_blue	int
;	O
long	O
int	O
fig_fgcolor_rgb	int
;	O
int	O
i	int
;	O
fig_fgcolor_red	int
=	O
(	O
red	int
>>	O
8	int
)	O
&	O
ONEBYTE	int
;	O
fig_fgcolor_green	int
=	O
(	O
green	int
>>	O
8	int
)	O
&	O
ONEBYTE	int
;	O
fig_fgcolor_blue	int
=	O
(	O
blue	int
>>	O
8	int
)	O
&	O
ONEBYTE	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
FIG_NUM_STD_COLORS	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
_pl_f_fig_stdcolors	array
[	O
i	int
]	O
.	O
red	int
==	O
fig_fgcolor_red	int
)	O
&&	O
(	O
_pl_f_fig_stdcolors	pointer
[	O
i	int
]	O
.	O
green	int
==	O
fig_fgcolor_green	int
)	O
&&	O
(	O
_pl_f_fig_stdcolors	pointer
[	O
i	int
]	O
.	O
blue	int
==	O
fig_fgcolor_blue	int
)	O
)	O
return	O
i	int
;	O
}	O
fig_fgcolor_rgb	int
=	O
(	O
fig_fgcolor_red	int
<<	O
16	int
)	O
+	O
(	O
fig_fgcolor_green	int
<<	O
8	int
)	O
+	O
(	O
fig_fgcolor_blue	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_plotter	pointer
->	O
fig_num_usercolors	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
fig_usercolors	array
[	O
i	int
]	O
==	O
fig_fgcolor_rgb	int
)	O
return	O
FIG_USER_COLOR_MIN	int
+	O
i	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
fig_num_usercolors	int
==	O
FIG_MAX_NUM_USER_COLORS	int
-	O
1	int
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
fig_colormap_warning_issued	enum
==	O
false	int
)	O
{	O
_plotter	pointer
->	O
warning	pointer
(	O
R___	O
(	O
_plotter	pointer
)	O
"supply of user-defined colors is exhausted"	int
)	O
;	O
_plotter	pointer
->	O
fig_colormap_warning_issued	enum
=	O
true	int
;	O
}	O
return	O
_fig_pseudocolor	function
(	O
fig_fgcolor_red	int
,	O
fig_fgcolor_green	int
,	O
fig_fgcolor_blue	int
,	O
_plotter	pointer
->	O
fig_usercolors	int
,	O
FIG_MAX_NUM_USER_COLORS	int
-	O
1	int
)	O
;	O
}	O
else	O
{	O
_plotter	pointer
->	O
fig_usercolors	array
[	O
_plotter	pointer
->	O
fig_num_usercolors	int
]	O
=	O
fig_fgcolor_rgb	int
;	O
_plotter	pointer
->	O
fig_num_usercolors	int
++	O
;	O
return	O
FIG_USER_COLOR_MIN	int
+	O
_plotter	pointer
->	O
fig_num_usercolors	int
-	O
1	int
;	O
}	O
}	O
static	O
int	O
_fig_pseudocolor	function
(	O
int	O
red	int
,	O
int	O
green	int
,	O
int	O
blue	int
,	O
const	O
long	O
int	O
*	O
fig_usercolors	pointer
,	O
int	O
fig_num_usercolors	int
)	O
{	O
unsigned	O
long	O
int	O
difference	long
=	O
INT_MAX	O
;	O
int	O
i	int
;	O
int	O
best	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
FIG_NUM_STD_COLORS	int
;	O
i	int
++	O
)	O
{	O
unsigned	O
long	O
int	O
newdifference	long
;	O
if	O
(	O
_pl_f_fig_stdcolors	pointer
[	O
i	int
]	O
.	O
red	int
==	O
0xff	int
&&	O
_pl_f_fig_stdcolors	array
[	O
i	int
]	O
.	O
green	int
==	O
0xff	int
&&	O
_pl_f_fig_stdcolors	array
[	O
i	int
]	O
.	O
blue	int
==	O
0xff	int
)	O
{	O
if	O
(	O
red	int
==	O
0xff	int
&&	O
green	int
==	O
0xff	int
&&	O
blue	int
==	O
0xff	int
)	O
{	O
difference	long
=	O
0	int
;	O
best	int
=	O
i	int
;	O
}	O
continue	O
;	O
}	O
newdifference	long
=	O
(	O
(	O
(	O
_pl_f_fig_stdcolors	array
[	O
i	int
]	O
.	O
red	int
-	O
red	int
)	O
*	O
(	O
_pl_f_fig_stdcolors	pointer
[	O
i	int
]	O
.	O
red	int
-	O
red	int
)	O
)	O
+	O
(	O
(	O
_pl_f_fig_stdcolors	array
[	O
i	int
]	O
.	O
green	int
-	O
green	int
)	O
*	O
(	O
_pl_f_fig_stdcolors	pointer
[	O
i	int
]	O
.	O
green	int
-	O
green	int
)	O
)	O
+	O
(	O
(	O
_pl_f_fig_stdcolors	pointer
[	O
i	int
]	O
.	O
blue	int
-	O
blue	int
)	O
*	O
(	O
_pl_f_fig_stdcolors	pointer
[	O
i	int
]	O
.	O
blue	int
-	O
blue	int
)	O
)	O
)	O
;	O
if	O
(	O
newdifference	long
<	O
difference	long
)	O
{	O
difference	long
=	O
newdifference	long
;	O
best	int
=	O
i	int
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
fig_num_usercolors	int
;	O
i	int
++	O
)	O
{	O
unsigned	O
long	O
int	O
newdifference	long
;	O
plColor	struct
usercolor	int
;	O
usercolor	struct
.	O
red	int
=	O
(	O
fig_usercolors	array
[	O
i	int
]	O
>>	O
16	int
)	O
&	O
ONEBYTE	int
;	O
usercolor	struct
.	O
green	int
=	O
(	O
fig_usercolors	array
[	O
i	int
]	O
>>	O
8	int
)	O
&	O
ONEBYTE	int
;	O
usercolor	struct
.	O
blue	int
=	O
(	O
fig_usercolors	array
[	O
i	int
]	O
>>	O
0	int
)	O
&	O
ONEBYTE	O
;	O
newdifference	long
=	O
(	O
(	O
usercolor	struct
.	O
red	int
-	O
red	int
)	O
*	O
(	O
usercolor	struct
.	O
red	int
-	O
red	int
)	O
+	O
(	O
usercolor	struct
.	O
green	int
-	O
green	int
)	O
*	O
(	O
usercolor	struct
.	O
green	int
-	O
green	int
)	O
+	O
(	O
usercolor	struct
.	O
blue	int
-	O
blue	int
)	O
*	O
(	O
usercolor	struct
.	O
blue	int
-	O
blue	int
)	O
)	O
;	O
if	O
(	O
newdifference	long
<	O
difference	long
)	O
{	O
difference	long
=	O
newdifference	long
;	O
best	int
=	O
i	int
+	O
FIG_USER_COLOR_MIN	int
;	O
}	O
}	O
return	O
best	int
;	O
}	O
void	O
_pl_f_set_pen_color	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
if	O
(	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
red	int
>	O
0xffff	int
)	O
||	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
green	int
>	O
0xffff	int
)	O
||	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
blue	int
>	O
0xffff	int
)	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fgcolor	int
=	O
_default_drawstate	struct
.	O
fig_fgcolor	int
;	O
else	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fgcolor	int
=	O
_pl_f_fig_color	function
(	O
R___	O
(	O
_plotter	pointer
)	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
red	int
,	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
green	int
,	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
blue	int
)	O
;	O
return	O
;	O
}	O
void	O
_pl_f_set_fill_color	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
double	O
fill_level	double
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor_base	struct
.	O
red	int
>	O
0xffff	int
||	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor_base	struct
.	O
green	int
>	O
0xffff	int
||	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor_base	struct
.	O
blue	int
>	O
0xffff	int
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fillcolor	pointer
=	O
_default_drawstate	struct
.	O
fig_fillcolor	int
;	O
else	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fillcolor	pointer
=	O
_pl_f_fig_color	function
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor_base	struct
.	O
red	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor_base	struct
.	O
green	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor_base	struct
.	O
blue	int
)	O
;	O
fill_level	double
=	O
(	O
(	O
double	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
-	O
1.	int
)	O
/	O
0xFFFE	int
;	O
if	O
(	O
fill_level	int
>	O
1.	int
)	O
fill_level	int
=	O
(	O
(	O
double	O
)	O
_default_drawstate	struct
.	O
fill_type	int
-	O
1.	int
)	O
/	O
0xFFFE	int
;	O
else	O
if	O
(	O
fill_level	double
<	O
0.	int
)	O
fill_level	double
=	O
-	O
1.0	int
;	O
if	O
(	O
fill_level	double
==	O
-	O
1.0	int
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fill_level	int
=	O
-	O
1	int
;	O
else	O
{	O
switch	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fillcolor	enum
)	O
{	O
case	O
FIG_C_WHITE	int
:	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fill_level	enum
=	O
20	int
;	O
break	O
;	O
case	O
FIG_C_BLACK	int
:	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fill_level	int
=	O
IROUND	O
(	O
20.0	int
-	O
20.0	int
*	O
fill_level	pointer
)	O
;	O
break	O
;	O
default	O
:	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fill_level	double
=	O
IROUND	O
(	O
20.0	int
+	O
20.0	int
*	O
fill_level	pointer
)	O
;	O
break	O
;	O
}	O
}	O
return	O
;	O
}	O
static	O
const	O
int	O
fig_horizontal_alignment_style	array
[	O
PL_NUM_HORIZ_JUST_TYPES	int
]	O
=	O
{	O
FIG_ALIGN_LEFT	int
,	O
FIG_ALIGN_CENTER	int
,	O
FIG_ALIGN_RIGHT	int
}	O
;	O
double	O
_pl_f_paint_text_string	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
const	O
unsigned	O
char	O
*	O
s	pointer
,	O
int	O
h_just	int
,	O
int	O
v_just	int
)	O
{	O
int	O
len	int
,	O
master_font_index	int
;	O
unsigned	O
char	O
*	O
ptr	pointer
,	O
*	O
t	pointer
;	O
double	O
theta	double
,	O
costheta	int
,	O
sintheta	int
;	O
double	O
label_width	double
,	O
label_ascent	int
;	O
double	O
initial_x	double
,	O
initial_y	int
;	O
double	O
horizontal_x	double
,	O
horizontal_y	int
,	O
vertical_x	double
,	O
vertical_y	int
;	O
double	O
horizontal_fig_length	double
,	O
vertical_fig_length	int
;	O
double	O
horizontal_fig_x	double
,	O
vertical_fig_x	int
;	O
double	O
horizontal_fig_y	double
,	O
vertical_fig_y	int
;	O
double	O
angle_device	double
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
font_type	int
!=	O
PL_F_POSTSCRIPT	int
)	O
return	O
0.0	int
;	O
if	O
(	O
v_just	int
!=	O
PL_JUST_BASE	int
)	O
return	O
0.0	int
;	O
if	O
(	O
*	O
s	pointer
==	O
(	O
unsigned	O
char	O
)	O
'\0'	O
)	O
return	O
0.0	int
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_font_point_size	int
==	O
0	int
)	O
return	O
0.0	int
;	O
theta	double
=	O
M_PI	int
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
text_rotation	double
/	O
180.0	int
;	O
sintheta	int
=	O
sin	function
(	O
theta	double
)	O
;	O
costheta	double
=	O
cos	function
(	O
theta	double
)	O
;	O
master_font_index	int
=	O
(	O
_pl_g_ps_typeface_info	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
typeface_index	int
]	O
.	O
fonts	int
)	O
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
font_index	int
]	O
;	O
label_width	int
=	O
_plotter	pointer
->	O
get_text_width	pointer
(	O
R___	O
(	O
_plotter	pointer
)	O
s	pointer
)	O
;	O
label_ascent	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
true_font_size	double
*	O
(	O
_pl_g_ps_font_info	array
[	O
master_font_index	int
]	O
)	O
.	O
font_ascent	double
/	O
1000.0	int
;	O
horizontal_x	double
=	O
costheta	struct
*	O
label_width	pointer
;	O
horizontal_y	double
=	O
sintheta	struct
*	O
label_width	pointer
;	O
vertical_x	double
=	O
-	O
sintheta	double
*	O
label_ascent	double
;	O
vertical_y	int
=	O
costheta	double
*	O
label_ascent	pointer
;	O
horizontal_fig_x	double
=	O
XDV	O
(	O
horizontal_x	int
,	O
horizontal_y	int
)	O
;	O
horizontal_fig_y	double
=	O
YDV	O
(	O
horizontal_x	int
,	O
horizontal_y	int
)	O
;	O
horizontal_fig_length	double
=	O
sqrt	function
(	O
horizontal_fig_x	struct
*	O
horizontal_fig_x	double
+	O
horizontal_fig_y	struct
*	O
horizontal_fig_y	pointer
)	O
;	O
angle_device	double
=	O
-	O
_xatan2	function
(	O
horizontal_fig_y	int
,	O
horizontal_fig_x	int
)	O
;	O
if	O
(	O
angle_device	double
==	O
0.0	int
)	O
angle_device	double
=	O
0.0	int
;	O
if	O
(	O
angle_device	double
!=	O
0.0	int
&&	O
strcmp	function
(	O
(	O
const	O
char	O
*	O
)	O
s	pointer
,	O
" "	pointer
)	O
==	O
0	int
)	O
return	O
_plotter	pointer
->	O
get_text_width	pointer
(	O
R___	O
(	O
_plotter	pointer
)	O
s	pointer
)	O
;	O
vertical_fig_x	double
=	O
XDV	O
(	O
vertical_x	int
,	O
vertical_y	int
)	O
;	O
vertical_fig_y	double
=	O
YDV	O
(	O
vertical_x	int
,	O
vertical_y	int
)	O
;	O
vertical_fig_length	double
=	O
sqrt	function
(	O
vertical_fig_x	O
*	O
vertical_fig_x	double
+	O
vertical_fig_y	struct
*	O
vertical_fig_y	pointer
)	O
;	O
initial_x	double
=	O
XD	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	double
)	O
.	O
x	double
,	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	double
)	O
.	O
y	double
)	O
;	O
initial_y	double
=	O
YD	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	double
)	O
.	O
x	double
,	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	double
)	O
.	O
y	double
)	O
;	O
_pl_f_set_pen_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
len	int
=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
s	pointer
)	O
;	O
ptr	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
_pl_xmalloc	function
(	O
(	O
4	int
*	O
len	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
t	pointer
=	O
ptr	pointer
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
'\\'	O
:	O
*	O
ptr	pointer
++	O
=	O
(	O
unsigned	O
char	O
)	O
'\\'	O
;	O
*	O
ptr	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
break	O
;	O
default	O
:	O
if	O
GOOD_PRINTABLE_ASCII	function
(	O
*	O
s	pointer
)	O
*	O
ptr	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
else	O
{	O
sprintf	function
(	O
(	O
char	O
*	O
)	O
ptr	pointer
,	O
"\\%03o"	pointer
,	O
(	O
unsigned	O
int	O
)	O
*	O
s	pointer
)	O
;	O
ptr	pointer
+=	O
4	int
;	O
s	pointer
++	O
;	O
}	O
break	O
;	O
}	O
}	O
*	O
ptr	pointer
=	O
(	O
unsigned	O
char	O
)	O
'\0'	O
;	O
if	O
(	O
_plotter	pointer
->	O
fig_drawing_depth	int
>	O
0	int
)	O
(	O
_plotter	pointer
->	O
fig_drawing_depth	int
)	O
--	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"#TEXT\n%d %d %d %d %d %d %.3f %.3f %d %.3f %.3f %d %d %s\\001\n"	pointer
,	O
4	int
,	O
fig_horizontal_alignment_style	array
[	O
h_just	int
]	O
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fgcolor	int
,	O
_plotter	pointer
->	O
fig_drawing_depth	int
,	O
0	int
,	O
_pl_g_ps_font_info	array
[	O
master_font_index	int
]	O
.	O
fig_id	pointer
,	O
(	O
double	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_font_point_size	int
,	O
angle_device	int
,	O
FONT_TYPE_PS	int
,	O
vertical_fig_length	int
,	O
horizontal_fig_length	int
,	O
IROUND	O
(	O
initial_x	int
)	O
,	O
IROUND	O
(	O
initial_y	int
)	O
,	O
t	double
)	O
;	O
free	function
(	O
t	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
return	O
label_width	pointer
;	O
}	O
const	O
plLineStyle	struct
_pl_g_line_styles	array
[	O
PL_NUM_LINE_TYPES	int
]	O
=	O
{	O
{	O
"solid"	pointer
,	O
PL_L_SOLID	int
,	O
0	int
,	O
{	O
0	int
}	O
}	O
,	O
{	O
"dotted"	pointer
,	O
PL_L_DOTTED	pointer
,	O
2	int
,	O
{	O
1	int
,	O
3	int
}	O
}	O
,	O
{	O
"dotdashed"	pointer
,	O
PL_L_DOTDASHED	pointer
,	O
4	int
,	O
{	O
4	int
,	O
3	int
,	O
1	int
,	O
3	int
}	O
}	O
,	O
{	O
"shortdashed"	pointer
,	O
PL_L_SHORTDASHED	pointer
,	O
2	int
,	O
{	O
4	int
,	O
4	int
}	O
}	O
,	O
{	O
"longdashed"	pointer
,	O
PL_L_LONGDASHED	pointer
,	O
2	int
,	O
{	O
7	int
,	O
4	int
}	O
}	O
,	O
{	O
"dotdotdashed"	pointer
,	O
PL_L_DOTDOTDASHED	pointer
,	O
6	int
,	O
{	O
4	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
3	int
}	O
}	O
,	O
{	O
"dotdotdotdashed"	pointer
,	O
PL_L_DOTDOTDOTDASHED	pointer
,	O
8	int
,	O
{	O
4	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
3	int
,	O
1	int
,	O
3	int
}	O
}	O
}	O
;	O
int	O
_API_fellipse	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
xc	double
,	O
double	O
yc	double
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
)	O
{	O
if	O
(	O
!	O
_plotter	pointer
->	O
data	pointer
->	O
open	enum
)	O
{	O
_plotter	pointer
->	O
error	pointer
(	O
R___	O
(	O
_plotter	pointer
)	O
"fellipse: invalid operation"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
)	O
_API_endpath	O
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
if	O
(	O
!	O
_plotter	pointer
->	O
drawstate	pointer
->	O
points_are_connected	enum
)	O
{	O
}	O
else	O
{	O
plPoint	struct
pc	struct
;	O
bool	enum
clockwise	enum
;	O
bool	enum
aligned_ellipse	enum
=	O
false	int
;	O
int	O
iangle	int
=	O
IROUND	O
(	O
angle	double
)	O
;	O
if	O
(	O
iangle	int
<	O
0	int
)	O
iangle	double
+=	O
(	O
1	int
+	O
(	O
-	O
iangle	int
/	O
90	int
)	O
)	O
*	O
90	int
;	O
if	O
(	O
iangle	double
%	O
90	int
==	O
0	int
&&	O
angle	double
==	O
(	O
double	O
)	O
iangle	int
)	O
aligned_ellipse	enum
=	O
true	int
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
=	O
_new_plPath	function
(	O
)	O
;	O
pc	struct
.	O
x	double
=	O
xc	double
;	O
pc	struct
.	O
y	double
=	O
yc	double
;	O
clockwise	enum
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
orientation	int
<	O
0	int
?	O
true	int
:	O
false	int
;	O
if	O
(	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_ellipse_scaling	enum
==	O
AS_ANY	int
)	O
||	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_ellipse_scaling	enum
==	O
AS_AXES_PRESERVED	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
axes_preserved	enum
&&	O
aligned_ellipse	enum
)	O
)	O
_add_ellipse	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
,	O
pc	struct
,	O
rx	struct
,	O
ry	int
,	O
angle	enum
,	O
clockwise	enum
)	O
;	O
else	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_ellarc_scaling	enum
==	O
AS_ANY	int
||	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_ellarc_scaling	enum
==	O
AS_AXES_PRESERVED	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
axes_preserved	enum
&&	O
aligned_ellipse	int
)	O
)	O
_add_ellipse_as_ellarcs	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
,	O
pc	struct
,	O
rx	struct
,	O
ry	int
,	O
angle	enum
,	O
clockwise	enum
)	O
;	O
else	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_cubic_scaling	enum
==	O
AS_ANY	int
)	O
_add_ellipse_as_bezier3s	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
,	O
pc	struct
,	O
rx	struct
,	O
ry	int
,	O
angle	enum
,	O
clockwise	enum
)	O
;	O
else	O
_add_ellipse_as_lines	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
,	O
pc	struct
,	O
rx	struct
,	O
ry	int
,	O
angle	enum
,	O
clockwise	enum
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
type	enum
==	O
PATH_SEGMENT_LIST	int
)	O
_plotter	pointer
->	O
maybe_prepaint_segments	pointer
(	O
R___	O
(	O
_plotter	pointer
)	O
0	int
)	O
;	O
}	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
=	O
xc	int
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
=	O
yc	double
;	O
return	O
0	int
;	O
}	O
int	O
_API_fpoint	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
x	double
,	O
double	O
y	double
)	O
{	O
if	O
(	O
!	O
_plotter	pointer
->	O
data	pointer
->	O
open	enum
)	O
{	O
_plotter	pointer
->	O
error	pointer
(	O
R___	O
(	O
_plotter	pointer
)	O
"fpoint: invalid operation"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
_API_endpath	O
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
=	O
x	double
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
=	O
y	double
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
==	O
0	int
)	O
return	O
0	int
;	O
_plotter	pointer
->	O
paint_point	pointer
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
_pl_g_paint_point	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
return	O
;	O
}	O
int	O
_API_farcrel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
dxc	double
,	O
double	O
dyc	double
,	O
double	O
dx0	double
,	O
double	O
dy0	double
,	O
double	O
dx1	pointer
,	O
double	O
dy1	int
)	O
{	O
return	O
_API_farc	function
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dxc	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dyc	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx1	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy1	int
)	O
;	O
}	O
int	O
_API_fbezier2rel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
dxc	double
,	O
double	O
dyc	double
,	O
double	O
dx0	double
,	O
double	O
dy0	double
,	O
double	O
dx1	pointer
,	O
double	O
dy1	int
)	O
{	O
return	O
_API_fbezier2	function
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dxc	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dyc	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx1	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy1	int
)	O
;	O
}	O
int	O
_API_fbezier3rel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
dx0	double
,	O
double	O
dy0	double
,	O
double	O
dx1	pointer
,	O
double	O
dy1	double
,	O
double	O
dx2	double
,	O
double	O
dy2	int
,	O
double	O
dx3	int
,	O
double	O
dy3	int
)	O
{	O
return	O
_API_fbezier3	function
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx1	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy1	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx2	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy2	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx3	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy3	int
)	O
;	O
}	O
int	O
_API_fellarcrel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
dxc	double
,	O
double	O
dyc	double
,	O
double	O
dx0	double
,	O
double	O
dy0	double
,	O
double	O
dx1	pointer
,	O
double	O
dy1	int
)	O
{	O
return	O
_API_fellarc	function
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dxc	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dyc	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx1	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy1	int
)	O
;	O
}	O
int	O
_API_fboxrel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
dx0	double
,	O
double	O
dy0	double
,	O
double	O
dx1	pointer
,	O
double	O
dy1	int
)	O
{	O
return	O
_API_fbox	O
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx1	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy1	int
)	O
;	O
}	O
int	O
_API_fcirclerel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
dx	pointer
,	O
double	O
dy	double
,	O
double	O
r	double
)	O
{	O
return	O
_API_fcircle	O
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy	double
,	O
r	double
)	O
;	O
}	O
int	O
_API_fellipserel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
dx	pointer
,	O
double	O
dy	double
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
)	O
{	O
return	O
_API_fellipse	function
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy	double
,	O
rx	struct
,	O
ry	int
,	O
angle	double
)	O
;	O
}	O
int	O
_API_fcontrel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
dx	pointer
,	O
double	O
dy	double
)	O
{	O
return	O
_API_fcont	O
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy	double
)	O
;	O
}	O
int	O
_API_flinerel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
dx0	double
,	O
double	O
dy0	double
,	O
double	O
dx1	pointer
,	O
double	O
dy1	int
)	O
{	O
return	O
_API_fline	O
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx1	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy1	int
)	O
;	O
}	O
int	O
_API_fmarkerrel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
dx	pointer
,	O
double	O
dy	double
,	O
int	O
type	int
,	O
double	O
size	double
)	O
{	O
return	O
_API_fmarker	function
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy	double
,	O
type	double
,	O
size	int
)	O
;	O
}	O
int	O
_API_fmoverel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
x	double
,	O
double	O
y	double
)	O
{	O
return	O
_API_fmove	O
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
y	double
)	O
;	O
}	O
int	O
_API_fpointrel	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
dx	pointer
,	O
double	O
dy	double
)	O
{	O
return	O
_API_fpoint	function
(	O
R___	O
(	O
_plotter	pointer
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
+	O
dx	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
+	O
dy	double
)	O
;	O
}	O
bool	enum
_pl_i_erase_page	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
i_animation	enum
&&	O
_plotter	pointer
->	O
data	pointer
->	O
page_number	int
==	O
1	int
&&	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
&&	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
frame_number	int
>	O
0	int
||	O
_plotter	pointer
->	O
i_frame_nonempty	int
)	O
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
i_header_written	enum
==	O
false	int
)	O
{	O
_pl_i_write_gif_header	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_plotter	pointer
->	O
i_header_written	enum
=	O
true	int
;	O
}	O
_pl_i_write_gif_image	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
}	O
_pl_i_delete_image	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_pl_i_new_image	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_plotter	pointer
->	O
i_frame_nonempty	enum
=	O
false	int
;	O
return	O
true	int
;	O
}	O
void	O
miDrawPoints	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
miCoordMode	enum
mode	enum
,	O
int	O
npt	int
,	O
const	O
miPoint	struct
*	O
pPts	pointer
)	O
{	O
MI_SETUP_PAINTED_SET	O
(	O
paintedSet	pointer
,	O
pGC	pointer
)	O
miDrawPoints_internal	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
mode	enum
,	O
npt	int
,	O
pPts	pointer
)	O
;	O
MI_TEAR_DOWN_PAINTED_SET	function
(	O
paintedSet	pointer
)	O
}	O
void	O
miDrawLines	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
miCoordMode	enum
mode	enum
,	O
int	O
npt	int
,	O
const	O
miPoint	struct
*	O
pPts	pointer
)	O
{	O
MI_SETUP_PAINTED_SET	O
(	O
paintedSet	pointer
,	O
pGC	pointer
)	O
miDrawLines_internal	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
mode	enum
,	O
npt	int
,	O
pPts	pointer
)	O
;	O
MI_TEAR_DOWN_PAINTED_SET	function
(	O
paintedSet	pointer
)	O
}	O
void	O
miFillPolygon	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
miPolygonShape	enum
shape	enum
,	O
miCoordMode	enum
mode	enum
,	O
int	O
count	int
,	O
const	O
miPoint	struct
*	O
pPts	pointer
)	O
{	O
MI_SETUP_PAINTED_SET	O
(	O
paintedSet	pointer
,	O
pGC	pointer
)	O
miFillPolygon_internal	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
shape	enum
,	O
mode	enum
,	O
count	int
,	O
pPts	pointer
)	O
;	O
MI_TEAR_DOWN_PAINTED_SET	function
(	O
paintedSet	pointer
)	O
}	O
void	O
miDrawRectangles	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
nrects	int
,	O
const	O
miRectangle	struct
*	O
prectInit	pointer
)	O
{	O
MI_SETUP_PAINTED_SET	O
(	O
paintedSet	pointer
,	O
pGC	pointer
)	O
;	O
miDrawRectangles_internal	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
nrects	int
,	O
prectInit	pointer
)	O
;	O
MI_TEAR_DOWN_PAINTED_SET	function
(	O
paintedSet	pointer
)	O
}	O
void	O
miFillRectangles	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
nrectFill	int
,	O
const	O
miRectangle	struct
*	O
prectInit	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"miFillRectangles()\n"	pointer
)	O
;	O
MI_SETUP_PAINTED_SET	O
(	O
paintedSet	pointer
,	O
pGC	pointer
)	O
;	O
miFillRectangles_internal	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
nrectFill	int
,	O
prectInit	pointer
)	O
;	O
MI_TEAR_DOWN_PAINTED_SET	function
(	O
paintedSet	pointer
)	O
}	O
void	O
miFillArcs	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
narcs	int
,	O
const	O
miArc	struct
*	O
parcs	pointer
)	O
{	O
MI_SETUP_PAINTED_SET	O
(	O
paintedSet	pointer
,	O
pGC	pointer
)	O
miFillArcs_internal	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
narcs	int
,	O
parcs	pointer
)	O
;	O
MI_TEAR_DOWN_PAINTED_SET	function
(	O
paintedSet	pointer
)	O
}	O
void	O
miDrawArcs_r	function
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
narcs	int
,	O
const	O
miArc	struct
*	O
parcs	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
{	O
MI_SETUP_PAINTED_SET	O
(	O
paintedSet	pointer
,	O
pGC	pointer
)	O
miDrawArcs_r_internal	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
narcs	int
,	O
parcs	pointer
,	O
ellipseCache	pointer
)	O
;	O
MI_TEAR_DOWN_PAINTED_SET	function
(	O
paintedSet	pointer
)	O
}	O
void	O
miDrawArcs_r_internal	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
narcs	int
,	O
const	O
miArc	struct
*	O
parcs	pointer
,	O
miEllipseCache	struct
*	O
ellipseCache	pointer
)	O
{	O
if	O
(	O
pGC	pointer
->	O
lineWidth	int
==	O
0	int
)	O
miZeroPolyArc_r	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
narcs	int
,	O
parcs	pointer
,	O
ellipseCache	pointer
)	O
;	O
else	O
miPolyArc_r	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
narcs	int
,	O
parcs	pointer
,	O
ellipseCache	pointer
)	O
;	O
}	O
void	O
miDrawLines_internal	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
miCoordMode	enum
mode	enum
,	O
int	O
npt	int
,	O
const	O
miPoint	struct
*	O
pPts	pointer
)	O
{	O
if	O
(	O
pGC	pointer
->	O
lineWidth	int
==	O
0	int
)	O
{	O
if	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_SOLID	int
)	O
miZeroLine	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
mode	enum
,	O
npt	int
,	O
pPts	pointer
)	O
;	O
else	O
miZeroDash	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
mode	enum
,	O
npt	int
,	O
pPts	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
pGC	pointer
->	O
lineStyle	int
==	O
(	O
int	O
)	O
MI_LINE_SOLID	int
)	O
miWideLine	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
mode	enum
,	O
npt	int
,	O
pPts	pointer
)	O
;	O
else	O
miWideDash	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
mode	enum
,	O
npt	int
,	O
pPts	pointer
)	O
;	O
}	O
}	O
void	O
miDrawRectangles_internal	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
int	O
nrects	int
,	O
const	O
miRectangle	struct
*	O
prectInit	pointer
)	O
{	O
const	O
miRectangle	struct
*	O
pR	pointer
=	O
prectInit	pointer
;	O
miPoint	struct
rect	array
[	O
5	int
]	O
;	O
int	O
i	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"miDrawRectangles_internal()\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nrects	int
;	O
i	int
++	O
)	O
{	O
rect	array
[	O
0	int
]	O
.	O
x	int
=	O
pR	pointer
->	O
x	int
;	O
rect	array
[	O
0	int
]	O
.	O
y	int
=	O
pR	pointer
->	O
y	int
;	O
rect	array
[	O
1	int
]	O
.	O
x	int
=	O
pR	pointer
->	O
x	int
+	O
(	O
int	O
)	O
pR	pointer
->	O
width	int
;	O
rect	array
[	O
1	int
]	O
.	O
y	int
=	O
rect	array
[	O
0	int
]	O
.	O
y	int
;	O
rect	array
[	O
2	int
]	O
.	O
x	int
=	O
rect	array
[	O
1	int
]	O
.	O
x	int
;	O
rect	array
[	O
2	int
]	O
.	O
y	int
=	O
pR	pointer
->	O
y	int
+	O
(	O
int	O
)	O
pR	pointer
->	O
height	int
;	O
rect	array
[	O
3	int
]	O
.	O
x	int
=	O
rect	array
[	O
0	int
]	O
.	O
x	int
;	O
rect	array
[	O
3	int
]	O
.	O
y	int
=	O
rect	array
[	O
2	int
]	O
.	O
y	int
;	O
rect	array
[	O
4	int
]	O
.	O
x	int
=	O
rect	array
[	O
0	int
]	O
.	O
x	int
;	O
rect	array
[	O
4	int
]	O
.	O
y	int
=	O
rect	array
[	O
0	int
]	O
.	O
y	int
;	O
miDrawLines_internal	O
(	O
paintedSet	pointer
,	O
pGC	pointer
,	O
MI_COORD_MODE_ORIGIN	int
,	O
5	int
,	O
rect	array
)	O
;	O
pR	pointer
++	O
;	O
}	O
}	O
static	O
int	O
GetFPolyYBounds	function
(	O
const	O
SppPoint	struct
*	O
pts	array
,	O
int	O
n	int
,	O
double	O
yFtrans	double
,	O
int	O
*	O
by	pointer
,	O
int	O
*	O
ty	pointer
)	O
;	O
void	O
miFillSppPoly	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	int
pixel	int
,	O
int	O
count	int
,	O
const	O
SppPoint	struct
*	O
ptsIn	pointer
,	O
int	O
xTrans	int
,	O
int	O
yTrans	int
,	O
double	O
xFtrans	double
,	O
double	O
yFtrans	double
)	O
{	O
double	O
xl	double
=	O
0.0	int
,	O
xr	double
=	O
0.0	int
,	O
ml	double
=	O
0.0	int
,	O
mr	double
=	O
0.0	int
,	O
dy	int
,	O
i	int
;	O
int	O
y	int
,	O
j	int
,	O
imin	int
,	O
ymin	int
,	O
ymax	int
;	O
int	O
left	int
,	O
right	int
,	O
nextleft	int
,	O
nextright	int
;	O
int	O
*	O
Marked	pointer
;	O
unsigned	O
int	O
*	O
width	int
,	O
*	O
FirstWidth	pointer
;	O
miPoint	struct
*	O
ptsOut	pointer
,	O
*	O
FirstPoint	pointer
;	O
imin	int
=	O
GetFPolyYBounds	function
(	O
ptsIn	pointer
,	O
count	int
,	O
yFtrans	double
,	O
&	O
ymin	int
,	O
&	O
ymax	int
)	O
;	O
y	int
=	O
ymax	double
-	O
ymin	int
+	O
1	int
;	O
if	O
(	O
(	O
count	int
<	O
3	int
)	O
||	O
(	O
y	int
<=	O
0	int
)	O
)	O
return	O
;	O
ptsOut	pointer
=	O
FirstPoint	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
y	double
)	O
;	O
width	array
=	O
FirstWidth	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
y	double
)	O
;	O
Marked	pointer
=	O
(	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
int	O
)	O
*	O
count	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
count	int
;	O
j	int
++	O
)	O
Marked	pointer
[	O
j	int
]	O
=	O
0	int
;	O
nextleft	int
=	O
nextright	int
=	O
imin	int
;	O
Marked	pointer
[	O
imin	int
]	O
=	O
-	O
1	int
;	O
y	int
=	O
ICEIL	O
(	O
ptsIn	pointer
[	O
nextleft	int
]	O
.	O
y	int
+	O
yFtrans	double
)	O
;	O
do	O
{	O
if	O
(	O
(	O
y	int
>	O
(	O
ptsIn	pointer
[	O
nextleft	int
]	O
.	O
y	int
+	O
yFtrans	double
)	O
||	O
ISEQUAL	O
(	O
y	int
,	O
ptsIn	pointer
[	O
nextleft	int
]	O
.	O
y	int
+	O
yFtrans	int
)	O
)	O
&&	O
Marked	pointer
[	O
nextleft	int
]	O
!=	O
1	int
)	O
{	O
Marked	pointer
[	O
nextleft	int
]	O
++	O
;	O
left	int
=	O
nextleft	int
++	O
;	O
if	O
(	O
nextleft	int
>=	O
count	int
)	O
nextleft	int
=	O
0	int
;	O
dy	int
=	O
ptsIn	pointer
[	O
nextleft	int
]	O
.	O
y	int
-	O
ptsIn	pointer
[	O
left	int
]	O
.	O
y	int
;	O
if	O
(	O
dy	double
!=	O
0.0	int
)	O
{	O
ml	int
=	O
(	O
ptsIn	pointer
[	O
nextleft	int
]	O
.	O
x	int
-	O
ptsIn	pointer
[	O
left	int
]	O
.	O
x	int
)	O
/	O
dy	int
;	O
dy	int
=	O
y	int
-	O
(	O
ptsIn	pointer
[	O
left	int
]	O
.	O
y	int
+	O
yFtrans	double
)	O
;	O
xl	int
=	O
(	O
ptsIn	pointer
[	O
left	int
]	O
.	O
x	int
+	O
xFtrans	int
)	O
+	O
ml	int
*	O
DMAX	O
(	O
dy	int
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
(	O
y	int
>	O
ptsIn	pointer
[	O
nextright	int
]	O
.	O
y	int
+	O
yFtrans	double
)	O
||	O
(	O
ISEQUAL	O
(	O
y	int
,	O
ptsIn	pointer
[	O
nextright	int
]	O
.	O
y	int
+	O
yFtrans	int
)	O
&&	O
Marked	pointer
[	O
nextright	int
]	O
!=	O
1	int
)	O
)	O
{	O
Marked	pointer
[	O
nextright	int
]	O
++	O
;	O
right	int
=	O
nextright	int
--	O
;	O
if	O
(	O
nextright	int
<	O
0	int
)	O
nextright	int
=	O
count	int
-	O
1	int
;	O
dy	int
=	O
ptsIn	pointer
[	O
nextright	int
]	O
.	O
y	int
-	O
ptsIn	pointer
[	O
right	int
]	O
.	O
y	int
;	O
if	O
(	O
dy	double
!=	O
0.0	int
)	O
{	O
mr	int
=	O
(	O
ptsIn	pointer
[	O
nextright	int
]	O
.	O
x	int
-	O
ptsIn	pointer
[	O
right	int
]	O
.	O
x	int
)	O
/	O
dy	int
;	O
dy	int
=	O
y	int
-	O
(	O
ptsIn	pointer
[	O
right	int
]	O
.	O
y	int
+	O
yFtrans	double
)	O
;	O
xr	int
=	O
(	O
ptsIn	pointer
[	O
right	int
]	O
.	O
x	int
+	O
xFtrans	int
)	O
+	O
mr	double
*	O
DMAX	O
(	O
dy	int
,	O
0	int
)	O
;	O
}	O
}	O
i	int
=	O
(	O
DMIN	O
(	O
ptsIn	pointer
[	O
nextleft	int
]	O
.	O
y	int
,	O
ptsIn	pointer
[	O
nextright	int
]	O
.	O
y	int
)	O
+	O
yFtrans	double
)	O
-	O
y	int
;	O
if	O
(	O
i	int
<	O
EPSILON	int
)	O
{	O
if	O
(	O
Marked	pointer
[	O
nextleft	int
]	O
&&	O
Marked	pointer
[	O
nextright	int
]	O
)	O
{	O
break	O
;	O
}	O
continue	O
;	O
}	O
else	O
{	O
j	int
=	O
(	O
int	O
)	O
i	int
;	O
if	O
(	O
!	O
j	int
)	O
j	int
++	O
;	O
}	O
while	O
(	O
j	int
>	O
0	int
)	O
{	O
int	O
cxl	int
,	O
cxr	int
;	O
ptsOut	pointer
->	O
y	int
=	O
(	O
y	int
)	O
+	O
yTrans	int
;	O
cxl	int
=	O
ICEIL	O
(	O
xl	int
)	O
;	O
cxr	int
=	O
ICEIL	O
(	O
xr	int
)	O
;	O
if	O
(	O
xl	int
<	O
xr	int
)	O
{	O
*	O
(	O
width	int
++	O
)	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
cxr	int
-	O
cxl	int
)	O
;	O
(	O
ptsOut	pointer
++	O
)	O
->	O
x	int
=	O
cxl	int
+	O
xTrans	int
;	O
}	O
else	O
{	O
*	O
(	O
width	int
++	O
)	O
=	O
(	O
unsigned	O
int	O
)	O
(	O
cxl	int
-	O
cxr	int
)	O
;	O
(	O
ptsOut	pointer
++	O
)	O
->	O
x	int
=	O
cxr	int
+	O
xTrans	int
;	O
}	O
y	int
++	O
;	O
xl	int
+=	O
ml	int
;	O
xr	double
+=	O
mr	int
;	O
j	int
--	O
;	O
}	O
}	O
while	O
(	O
y	int
<=	O
ymax	int
)	O
;	O
free	function
(	O
Marked	pointer
)	O
;	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pixel	int
,	O
ptsOut	pointer
-	O
FirstPoint	pointer
,	O
FirstPoint	pointer
,	O
FirstWidth	pointer
)	O
}	O
static	O
int	O
GetFPolyYBounds	function
(	O
const	O
SppPoint	struct
*	O
pts	array
,	O
int	O
n	int
,	O
double	O
yFtrans	double
,	O
int	O
*	O
by	pointer
,	O
int	O
*	O
ty	pointer
)	O
{	O
const	O
SppPoint	struct
*	O
ptsStart	pointer
=	O
pts	array
;	O
const	O
SppPoint	struct
*	O
ptMin	pointer
;	O
double	O
ymin	int
,	O
ymax	int
;	O
ptMin	pointer
=	O
pts	array
;	O
ymin	int
=	O
ymax	int
=	O
(	O
pts	array
++	O
)	O
->	O
y	int
;	O
while	O
(	O
--	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
pts	array
->	O
y	int
<	O
ymin	int
)	O
{	O
ptMin	pointer
=	O
pts	array
;	O
ymin	int
=	O
pts	array
->	O
y	int
;	O
}	O
if	O
(	O
pts	array
->	O
y	int
>	O
ymax	int
)	O
ymax	int
=	O
pts	array
->	O
y	int
;	O
pts	array
++	O
;	O
}	O
*	O
by	pointer
=	O
ICEIL	O
(	O
ymin	int
+	O
yFtrans	double
)	O
;	O
*	O
ty	pointer
=	O
ICEIL	O
(	O
ymax	int
+	O
yFtrans	double
-	O
1	int
)	O
;	O
return	O
(	O
ptMin	pointer
-	O
ptsStart	pointer
)	O
;	O
}	O
void	O
miDrawPoints_internal	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
const	O
miGC	struct
*	O
pGC	pointer
,	O
miCoordMode	enum
mode	enum
,	O
int	O
npt	int
,	O
const	O
miPoint	struct
*	O
pPts	pointer
)	O
{	O
unsigned	O
int	O
*	O
pwidthInit	pointer
,	O
*	O
pwidth	pointer
;	O
int	O
i	int
;	O
miPoint	struct
*	O
ppt	pointer
=	O
(	O
miPoint	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
npt	int
<=	O
0	int
)	O
return	O
;	O
ppt	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
npt	int
*	O
sizeof	O
(	O
miPoint	struct
)	O
)	O
;	O
if	O
(	O
mode	enum
==	O
MI_COORD_MODE_PREVIOUS	int
)	O
{	O
ppt	pointer
[	O
0	int
]	O
=	O
pPts	pointer
[	O
0	int
]	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
npt	int
;	O
i	int
++	O
)	O
{	O
ppt	pointer
[	O
i	int
]	O
.	O
x	int
=	O
ppt	pointer
[	O
i	int
-	O
1	int
]	O
.	O
x	int
+	O
pPts	pointer
[	O
i	int
]	O
.	O
x	int
;	O
ppt	pointer
[	O
i	int
]	O
.	O
y	int
=	O
ppt	pointer
[	O
i	int
-	O
1	int
]	O
.	O
y	int
+	O
pPts	pointer
[	O
i	int
]	O
.	O
y	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npt	int
;	O
i	int
++	O
)	O
ppt	pointer
[	O
i	int
]	O
=	O
pPts	pointer
[	O
i	int
]	O
;	O
}	O
pwidthInit	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
npt	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
pwidth	pointer
=	O
pwidthInit	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npt	int
;	O
i	int
++	O
)	O
*	O
pwidth	pointer
++	O
=	O
1	int
;	O
if	O
(	O
npt	int
>	O
1	int
)	O
miQuickSortSpansY	O
(	O
ppt	pointer
,	O
pwidthInit	pointer
,	O
npt	int
)	O
;	O
MI_PAINT_SPANS	O
(	O
paintedSet	pointer
,	O
pGC	pointer
->	O
pixels	pointer
[	O
1	int
]	O
,	O
npt	int
,	O
ppt	pointer
,	O
pwidthInit	pointer
)	O
}	O
const	O
char	O
mi_libxmi_ver	array
[	O
8	int
]	O
=	O
MI_LIBXMI_VER_STRING	pointer
;	O
void	O
_pl_m_emit_op_code	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
c	int
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
putc	function
(	O
c	int
,	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
;	O
}	O
void	O
_pl_m_emit_integer	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
x	enum
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
meta_portable_output	enum
)	O
fprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
,	O
" %d"	pointer
,	O
x	double
)	O
;	O
else	O
fwrite	function
(	O
(	O
void	O
*	O
)	O
&	O
x	double
,	O
sizeof	O
(	O
int	O
)	O
,	O
1	int
,	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
;	O
}	O
}	O
void	O
_pl_m_emit_float	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
x	double
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
meta_portable_output	enum
)	O
{	O
fprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
,	O
x	double
==	O
0.0	int
?	O
" 0"	int
:	O
" %g"	int
,	O
x	double
)	O
;	O
}	O
else	O
{	O
float	O
f	pointer
;	O
f	pointer
=	O
FROUND	function
(	O
x	double
)	O
;	O
fwrite	function
(	O
(	O
void	O
*	O
)	O
&	O
f	double
,	O
sizeof	O
(	O
float	O
)	O
,	O
1	int
,	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
;	O
}	O
}	O
}	O
void	O
_pl_m_emit_string	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
const	O
char	O
*	O
s	pointer
)	O
{	O
bool	bool
has_newline	bool
;	O
char	O
*	O
t	pointer
=	O
NULL	O
;	O
char	O
*	O
nl	pointer
;	O
const	O
char	O
*	O
u	pointer
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
s	pointer
=	O
"(null)"	pointer
;	O
if	O
(	O
strchr	function
(	O
s	pointer
,	O
'\n'	O
)	O
)	O
{	O
has_newline	bool
=	O
true	int
;	O
t	pointer
=	O
(	O
char	O
*	O
)	O
_pl_xmalloc	function
(	O
strlen	function
(	O
s	array
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
t	pointer
,	O
s	pointer
)	O
;	O
nl	pointer
=	O
strchr	function
(	O
t	int
,	O
'\n'	O
)	O
;	O
*	O
nl	pointer
=	O
'\0'	O
;	O
u	pointer
=	O
t	pointer
;	O
}	O
else	O
{	O
has_newline	enum
=	O
false	int
;	O
u	pointer
=	O
s	pointer
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
{	O
fputs	function
(	O
u	array
,	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
meta_portable_output	enum
==	O
false	int
)	O
putc	function
(	O
'\n'	O
,	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
;	O
}	O
if	O
(	O
has_newline	int
)	O
free	function
(	O
t	pointer
)	O
;	O
}	O
void	O
_pl_m_emit_terminator	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
meta_portable_output	enum
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
putc	function
(	O
'\n'	O
,	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
;	O
}	O
}	O
static	O
int	O
_idraw_pseudocolor	function
(	O
int	O
red	int
,	O
int	O
green	int
,	O
int	O
blue	int
)	O
;	O
void	O
_pl_p_set_pen_color	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fgcolor_red	pointer
=	O
(	O
(	O
double	O
)	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
red	int
)	O
)	O
/	O
0xFFFF	int
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fgcolor_green	pointer
=	O
(	O
(	O
double	O
)	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
green	int
)	O
)	O
/	O
0xFFFF	int
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fgcolor_blue	pointer
=	O
(	O
(	O
double	O
)	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
blue	int
)	O
)	O
/	O
0xFFFF	int
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_idraw_fgcolor	pointer
=	O
_idraw_pseudocolor	function
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
red	int
,	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
green	int
,	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fgcolor	struct
)	O
.	O
blue	int
)	O
;	O
return	O
;	O
}	O
void	O
_pl_p_set_fill_color	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
double	O
red	int
,	O
green	int
,	O
blue	int
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
==	O
0	int
)	O
return	O
;	O
red	int
=	O
(	O
(	O
double	O
)	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
)	O
.	O
red	int
)	O
)	O
/	O
0xFFFF	int
;	O
green	int
=	O
(	O
(	O
double	O
)	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
)	O
.	O
green	int
)	O
)	O
/	O
0xFFFF	int
;	O
blue	int
=	O
(	O
(	O
double	O
)	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fillcolor	struct
)	O
.	O
blue	int
)	O
)	O
/	O
0xFFFF	int
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_red	enum
=	O
red	int
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_green	enum
=	O
green	int
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_blue	enum
=	O
blue	int
;	O
_pl_p_set_pen_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_pl_p_compute_idraw_bgcolor	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
return	O
;	O
}	O
static	O
int	O
_idraw_pseudocolor	function
(	O
int	O
red	int
,	O
int	O
green	int
,	O
int	O
blue	int
)	O
{	O
double	O
difference	double
;	O
int	O
i	int
;	O
int	O
best	int
=	O
0	int
;	O
difference	double
=	O
DBL_MAX	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
PS_NUM_IDRAW_STD_COLORS	int
;	O
i	int
++	O
)	O
{	O
double	O
newdifference	double
;	O
if	O
(	O
_pl_p_idraw_stdcolors	array
[	O
i	int
]	O
.	O
red	int
==	O
0xffff	int
&&	O
_pl_p_idraw_stdcolors	array
[	O
i	int
]	O
.	O
green	int
==	O
0xffff	int
&&	O
_pl_p_idraw_stdcolors	array
[	O
i	int
]	O
.	O
blue	int
==	O
0xffff	int
)	O
{	O
if	O
(	O
red	int
==	O
0xffff	int
&&	O
green	int
==	O
0xffff	int
&&	O
blue	int
==	O
0xffff	int
)	O
{	O
difference	double
=	O
0.0	int
;	O
best	int
=	O
i	int
;	O
}	O
continue	O
;	O
}	O
newdifference	long
=	O
(	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	array
[	O
i	int
]	O
.	O
red	int
-	O
red	int
)	O
*	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	array
[	O
i	int
]	O
.	O
red	int
-	O
red	int
)	O
)	O
+	O
(	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	array
[	O
i	int
]	O
.	O
green	int
-	O
green	int
)	O
*	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	array
[	O
i	int
]	O
.	O
green	int
-	O
green	int
)	O
)	O
+	O
(	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	pointer
[	O
i	int
]	O
.	O
blue	int
-	O
blue	int
)	O
*	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	pointer
[	O
i	int
]	O
.	O
blue	int
-	O
blue	int
)	O
)	O
;	O
if	O
(	O
newdifference	long
<	O
difference	double
)	O
{	O
difference	long
=	O
newdifference	long
;	O
best	int
=	O
i	int
;	O
}	O
}	O
return	O
best	int
;	O
}	O
void	O
_pl_p_compute_idraw_bgcolor	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
double	O
truered	double
,	O
truegreen	double
,	O
trueblue	int
;	O
double	O
fgred	double
,	O
fggreen	double
,	O
fgblue	int
;	O
double	O
difference	double
=	O
DBL_MAX	O
;	O
int	O
i	int
,	O
j	int
;	O
int	O
best_bgcolor	int
=	O
0	int
,	O
best_shading	int
=	O
0	int
;	O
double	O
best_shade	double
=	O
0.0	int
;	O
truered	int
=	O
0xFFFF	int
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_red	int
;	O
truegreen	int
=	O
0xFFFF	int
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_green	int
;	O
trueblue	int
=	O
0xFFFF	int
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_blue	double
;	O
fgred	double
=	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_idraw_fgcolor	int
]	O
.	O
red	int
)	O
;	O
fggreen	double
=	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_idraw_fgcolor	int
]	O
.	O
green	int
)	O
;	O
fgblue	double
=	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_idraw_fgcolor	int
]	O
.	O
blue	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
PS_NUM_IDRAW_STD_COLORS	int
;	O
i	int
++	O
)	O
{	O
double	O
bgred	double
,	O
bggreen	int
,	O
bgblue	int
;	O
bgred	double
=	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	array
[	O
i	int
]	O
.	O
red	int
)	O
;	O
bggreen	double
=	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	array
[	O
i	int
]	O
.	O
green	int
)	O
;	O
bgblue	double
=	O
(	O
double	O
)	O
(	O
_pl_p_idraw_stdcolors	array
[	O
i	int
]	O
.	O
blue	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
PS_NUM_IDRAW_STD_SHADINGS	int
;	O
j	int
++	O
)	O
{	O
double	O
approxred	double
,	O
approxgreen	double
,	O
approxblue	int
;	O
double	O
shade	double
,	O
newdifference	long
;	O
shade	int
=	O
_pl_p_idraw_stdshadings	array
[	O
j	int
]	O
;	O
approxred	double
=	O
shade	double
*	O
bgred	double
+	O
(	O
1.0	int
-	O
shade	double
)	O
*	O
fgred	pointer
;	O
approxgreen	double
=	O
shade	double
*	O
bggreen	double
+	O
(	O
1.0	int
-	O
shade	double
)	O
*	O
fggreen	pointer
;	O
approxblue	double
=	O
shade	double
*	O
bgblue	double
+	O
(	O
1.0	int
-	O
shade	double
)	O
*	O
fgblue	pointer
;	O
newdifference	long
=	O
(	O
truered	int
-	O
approxred	double
)	O
*	O
(	O
truered	double
-	O
approxred	int
)	O
+	O
(	O
truegreen	int
-	O
approxgreen	double
)	O
*	O
(	O
truegreen	double
-	O
approxgreen	int
)	O
+	O
(	O
trueblue	int
-	O
approxblue	double
)	O
*	O
(	O
trueblue	double
-	O
approxblue	int
)	O
;	O
if	O
(	O
newdifference	long
<	O
difference	double
)	O
{	O
difference	long
=	O
newdifference	long
;	O
best_bgcolor	int
=	O
i	int
;	O
best_shading	int
=	O
j	int
;	O
best_shade	int
=	O
shade	int
;	O
}	O
}	O
}	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_idraw_bgcolor	double
=	O
best_bgcolor	int
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_idraw_shading	double
=	O
best_shading	int
;	O
if	O
(	O
best_shade	double
!=	O
0.0	int
)	O
{	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_red	double
=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_red	double
-	O
(	O
1.0	int
-	O
best_shade	int
)	O
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fgcolor_red	enum
)	O
/	O
best_shade	int
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_green	double
=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_green	double
-	O
(	O
1.0	int
-	O
best_shade	double
)	O
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fgcolor_green	enum
)	O
/	O
best_shade	int
;	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_blue	double
=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_blue	double
-	O
(	O
1.0	int
-	O
best_shade	double
)	O
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fgcolor_blue	double
)	O
/	O
best_shade	int
;	O
}	O
}	O
const	O
plColor	struct
_pl_p_idraw_stdcolors	array
[	O
PS_NUM_IDRAW_STD_COLORS	int
]	O
=	O
{	O
{	O
0x0000	int
,	O
0x0000	int
,	O
0x0000	int
}	O
,	O
{	O
0xa500	int
,	O
0x2a00	pointer
,	O
0x2a00	int
}	O
,	O
{	O
0xffff	int
,	O
0x0000	int
,	O
0x0000	int
}	O
,	O
{	O
0xffff	int
,	O
0xa5a5	int
,	O
0x0000	int
}	O
,	O
{	O
0xffff	int
,	O
0xffff	int
,	O
0x0000	int
}	O
,	O
{	O
0x0000	pointer
,	O
0xffff	int
,	O
0x0000	int
}	O
,	O
{	O
0x0000	int
,	O
0x0000	pointer
,	O
0xffff	int
}	O
,	O
{	O
0xbf00	int
,	O
0x0000	pointer
,	O
0xff00	int
}	O
,	O
{	O
0x4f00	int
,	O
0x2f00	pointer
,	O
0x4f00	int
}	O
,	O
{	O
0xffff	int
,	O
0xffff	int
,	O
0xffff	int
}	O
,	O
{	O
0xc350	int
,	O
0xc350	pointer
,	O
0xc350	int
}	O
,	O
{	O
0x80e8	int
,	O
0x80e8	int
,	O
0x80e8	int
}	O
}	O
;	O
const	O
char	O
*	O
const	O
_pl_p_idraw_stdcolornames	array
[	O
PS_NUM_IDRAW_STD_COLORS	int
]	O
=	O
{	O
"Black"	pointer
,	O
"Brown"	pointer
,	O
"Red"	pointer
,	O
"Orange"	pointer
,	O
"Yellow"	pointer
,	O
"Green"	pointer
,	O
"Blue"	pointer
,	O
"Indigo"	pointer
,	O
"Violet"	pointer
,	O
"White"	pointer
,	O
"LtGray"	pointer
,	O
"DkGray"	pointer
}	O
;	O
const	O
double	O
_pl_p_idraw_stdshadings	array
[	O
PS_NUM_IDRAW_STD_SHADINGS	int
]	O
=	O
{	O
0.0	int
,	O
0.25	int
,	O
0.5	int
,	O
0.75	int
,	O
1.0	int
}	O
;	O
bool	enum
_pl_r_end_page	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033\\"	pointer
)	O
;	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033[1;1H"	pointer
)	O
;	O
return	O
true	int
;	O
}	O
const	O
Plotter	struct
_pl_r_default_plotter	struct
=	O
{	O
_pl_r_initialize	pointer
,	O
_pl_r_terminate	function
,	O
_pl_r_begin_page	function
,	O
_pl_r_erase_page	function
,	O
_pl_r_end_page	function
,	O
_pl_g_push_state	function
,	O
_pl_g_pop_state	function
,	O
_pl_r_paint_path	function
,	O
_pl_r_paint_paths	function
,	O
_pl_r_path_is_flushable	function
,	O
_pl_r_maybe_prepaint_segments	function
,	O
_pl_g_paint_marker	function
,	O
_pl_r_paint_point	function
,	O
_pl_g_paint_text_string_with_escapes	function
,	O
_pl_g_paint_text_string	function
,	O
_pl_g_get_text_width	function
,	O
_pl_g_retrieve_font	function
,	O
_pl_g_flush_output	function
,	O
_pl_g_warning	function
,	O
_pl_g_error	function
,	O
}	O
;	O
void	O
_pl_r_initialize	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
_pl_g_initialize	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
type	enum
=	O
PL_REGIS	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
output_model	enum
=	O
PL_OUTPUT_VIA_CUSTOM_ROUTINES_IN_REAL_TIME	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_wide_lines	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_dash_array	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_solid_fill	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_odd_winding_fill	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_nonzero_winding_fill	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_settable_bg	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_escaped_string_support	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_ps_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_pcl_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_stick_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_extra_stick_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_other_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
default_font_type	int
=	O
PL_F_HERSHEY	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
pcl_before_ps	enum
=	O
false	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_horizontal_justification	enum
=	O
false	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_vertical_justification	enum
=	O
false	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
issue_font_warning	enum
=	O
true	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
max_unfilled_path_length	int
=	O
PL_MAX_UNFILLED_PATH_LENGTH	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_mixed_paths	enum
=	O
false	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_arc_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_ellarc_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_quad_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_cubic_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_box_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_circle_scaling	enum
=	O
AS_UNIFORM	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_ellipse_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
display_model_type	int
=	O
(	O
int	O
)	O
DISP_MODEL_VIRTUAL	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
display_coors_type	int
=	O
(	O
int	O
)	O
DISP_DEVICE_COORS_INTEGER_NON_LIBXMI	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
flipped_y	enum
=	O
true	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
imin	int
=	O
144	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
=	O
623	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
=	O
479	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmax	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
xmin	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
xmax	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
ymin	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
ymax	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
page_data	pointer
=	O
(	O
plPageData	struct
*	O
)	O
NULL	O
;	O
_compute_ndc_to_device_map	function
(	O
_plotter	pointer
->	O
data	pointer
)	O
;	O
_plotter	pointer
->	O
regis_pos	struct
.	O
x	double
=	O
0	int
;	O
_plotter	pointer
->	O
regis_pos	struct
.	O
y	double
=	O
0	int
;	O
_plotter	pointer
->	O
regis_position_is_unknown	enum
=	O
true	int
;	O
_plotter	pointer
->	O
regis_line_type	int
=	O
PL_L_SOLID	int
;	O
_plotter	pointer
->	O
regis_line_type_is_unknown	enum
=	O
true	int
;	O
_plotter	pointer
->	O
regis_fgcolor	int
=	O
0	int
;	O
_plotter	pointer
->	O
regis_bgcolor	int
=	O
0	int
;	O
_plotter	pointer
->	O
regis_fgcolor_is_unknown	enum
=	O
true	int
;	O
_plotter	pointer
->	O
regis_bgcolor_is_unknown	enum
=	O
true	int
;	O
}	O
void	O
_pl_r_terminate	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
_pl_g_terminate	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
}	O
static	O
const	O
plColorNameInfo	struct
_svg_colornames	array
[	O
NUM_SVG_COLORNAMES	int
+	O
1	int
]	O
=	O
{	O
{	O
"aqua"	int
,	O
0x00	int
,	O
0xff	int
,	O
0xff	int
}	O
,	O
{	O
"black"	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
}	O
,	O
{	O
"blue"	int
,	O
0x00	int
,	O
0x00	int
,	O
0xff	int
}	O
,	O
{	O
"fuchsia"	int
,	O
0xff	int
,	O
0x00	int
,	O
0xff	int
}	O
,	O
{	O
"gray"	int
,	O
0x80	int
,	O
0x80	int
,	O
0x80	int
}	O
,	O
{	O
"green"	int
,	O
0x00	int
,	O
0x80	int
,	O
0x00	int
}	O
,	O
{	O
"lime"	int
,	O
0x00	int
,	O
0xff	int
,	O
0x00	int
}	O
,	O
{	O
"maroon"	int
,	O
0x80	int
,	O
0x00	int
,	O
0x00	int
}	O
,	O
{	O
"navy"	int
,	O
0x00	int
,	O
0x00	int
,	O
0x80	int
}	O
,	O
{	O
"olive"	int
,	O
0x80	int
,	O
0x80	int
,	O
0x00	int
}	O
,	O
{	O
"purple"	int
,	O
0x80	int
,	O
0x00	int
,	O
0x80	int
}	O
,	O
{	O
"red"	int
,	O
0xff	int
,	O
0x00	int
,	O
0x00	int
}	O
,	O
{	O
"silver"	int
,	O
0xc0	int
,	O
0xc0	int
,	O
0xc0	int
}	O
,	O
{	O
"teal"	int
,	O
0x00	int
,	O
0x80	int
,	O
0x80	int
}	O
,	O
{	O
"white"	int
,	O
0xff	int
,	O
0xff	int
,	O
0xff	int
}	O
,	O
{	O
"yellow"	int
,	O
0xff	int
,	O
0xff	int
,	O
0x00	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
const	O
char	O
*	O
_libplot_color_to_svg_color	function
(	O
plColor	struct
color_48	pointer
,	O
char	O
charbuf	array
[	O
8	int
]	O
)	O
{	O
plColor	struct
color_24	struct
;	O
int	O
i	int
;	O
bool	enum
found	enum
=	O
false	int
;	O
const	O
char	O
*	O
svg_color	pointer
;	O
color_24	struct
.	O
red	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
color_48	struct
.	O
red	int
)	O
>>	O
8	int
;	O
color_24	struct
.	O
green	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
color_48	struct
.	O
green	int
)	O
>>	O
8	int
;	O
color_24	struct
.	O
blue	int
=	O
(	O
(	O
unsigned	O
int	O
)	O
color_48	struct
.	O
blue	int
)	O
>>	O
8	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_SVG_COLORNAMES	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
color_24	struct
.	O
red	int
==	O
_svg_colornames	array
[	O
i	int
]	O
.	O
red	int
&&	O
color_24	struct
.	O
green	int
==	O
_svg_colornames	array
[	O
i	int
]	O
.	O
green	int
&&	O
color_24	struct
.	O
blue	int
==	O
_svg_colornames	pointer
[	O
i	int
]	O
.	O
blue	int
)	O
{	O
found	enum
=	O
true	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
found	int
)	O
svg_color	int
=	O
_svg_colornames	array
[	O
i	int
]	O
.	O
name	pointer
;	O
else	O
{	O
sprintf	function
(	O
charbuf	pointer
,	O
"#%02x%02x%02x"	pointer
,	O
color_24	struct
.	O
red	int
,	O
color_24	struct
.	O
green	int
,	O
color_24	struct
.	O
blue	int
)	O
;	O
svg_color	int
=	O
charbuf	int
;	O
}	O
return	O
svg_color	pointer
;	O
}	O
static	O
const	O
double	O
identity_matrix	array
[	O
6	int
]	O
=	O
{	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
}	O
;	O
static	O
void	O
write_svg_point_style	function
(	O
plOutbuf	struct
*	O
page	pointer
,	O
const	O
plDrawState	struct
*	O
drawstate	pointer
)	O
;	O
void	O
_pl_s_paint_point	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"<circle "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_pl_s_set_matrix	function
(	O
R___	O
(	O
_plotter	pointer
)	O
identity_matrix	pointer
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"cx=\"%.5g\" cy=\"%.5g\" r=\"%s\" "	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pos	struct
.	O
y	double
,	O
"0.5px"	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
write_svg_point_style	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"/>\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
return	O
;	O
}	O
static	O
void	O
write_svg_point_style	function
(	O
plOutbuf	struct
*	O
page	pointer
,	O
const	O
plDrawState	struct
*	O
drawstate	pointer
)	O
{	O
char	O
color_buf	array
[	O
8	int
]	O
;	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"stroke=\"none\" "	pointer
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
sprintf	function
(	O
page	pointer
->	O
point	pointer
,	O
"fill=\"%s\""	pointer
,	O
_libplot_color_to_svg_color	function
(	O
drawstate	pointer
->	O
fgcolor	struct
,	O
color_buf	pointer
)	O
)	O
;	O
_update_buffer	function
(	O
page	pointer
)	O
;	O
}	O
void	O
_pl_t_set_attributes	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
if	O
(	O
(	O
!	O
(	O
_plotter	pointer
->	O
tek_line_type_is_unknown	int
)	O
)	O
&&	O
(	O
_plotter	pointer
->	O
tek_line_type	enum
==	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
)	O
)	O
return	O
;	O
switch	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
)	O
{	O
default	O
:	O
case	O
PL_L_SOLID	int
:	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033`"	pointer
)	O
;	O
break	O
;	O
case	O
PL_L_DOTTED	int
:	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033a"	pointer
)	O
;	O
break	O
;	O
case	O
PL_L_DOTDASHED	int
:	O
if	O
(	O
_plotter	pointer
->	O
tek_display_type	int
==	O
TEK_DPY_KERMIT	int
)	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033c"	pointer
)	O
;	O
else	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033b"	pointer
)	O
;	O
break	O
;	O
case	O
PL_L_SHORTDASHED	int
:	O
if	O
(	O
_plotter	pointer
->	O
tek_display_type	int
==	O
TEK_DPY_KERMIT	int
)	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033b"	pointer
)	O
;	O
else	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033c"	pointer
)	O
;	O
break	O
;	O
case	O
PL_L_LONGDASHED	int
:	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033d"	pointer
)	O
;	O
break	O
;	O
case	O
PL_L_DOTDOTDASHED	int
:	O
if	O
(	O
_plotter	pointer
->	O
tek_display_type	int
==	O
TEK_DPY_KERMIT	int
)	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033e"	pointer
)	O
;	O
else	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033b"	pointer
)	O
;	O
break	O
;	O
case	O
PL_L_DOTDOTDOTDASHED	int
:	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033b"	pointer
)	O
;	O
break	O
;	O
}	O
_plotter	pointer
->	O
tek_line_type	enum
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
;	O
_plotter	pointer
->	O
tek_line_type_is_unknown	enum
=	O
false	int
;	O
}	O
bool	enum
_pl_t_erase_page	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"\033\014"	pointer
)	O
;	O
_plotter	pointer
->	O
tek_mode	int
=	O
TEK_MODE_ALPHA	int
;	O
_pl_t_set_bg_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
return	O
true	int
;	O
}	O
void	O
_pl_t_tek_move	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
xx	int
,	O
int	O
yy	int
)	O
{	O
int	O
correct_tek_mode	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
points_are_connected	enum
?	O
TEK_MODE_PLOT	int
:	O
TEK_MODE_POINT	int
;	O
switch	O
(	O
correct_tek_mode	int
)	O
{	O
case	O
TEK_MODE_POINT	int
:	O
_write_byte	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
'\034'	O
)	O
;	O
break	O
;	O
case	O
TEK_MODE_PLOT	int
:	O
_write_byte	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
'\035'	O
)	O
;	O
break	O
;	O
default	O
:	O
return	O
;	O
}	O
_pl_t_tek_vector	function
(	O
R___	O
(	O
_plotter	pointer
)	O
xx	int
,	O
yy	int
)	O
;	O
_plotter	pointer
->	O
tek_pos	struct
.	O
x	double
=	O
xx	int
;	O
_plotter	pointer
->	O
tek_pos	struct
.	O
y	double
=	O
yy	int
;	O
_plotter	pointer
->	O
tek_position_is_unknown	enum
=	O
false	int
;	O
_plotter	pointer
->	O
tek_mode_is_unknown	enum
=	O
false	int
;	O
_plotter	pointer
->	O
tek_mode	int
=	O
correct_tek_mode	int
;	O
return	O
;	O
}	O
static	O
void	O
miInsertEdgeInET	function
(	O
EdgeTable	struct
*	O
ET	pointer
,	O
EdgeTableEntry	struct
*	O
ETE	pointer
,	O
int	O
scanline	int
,	O
ScanLineListBlock	struct
*	O
*	O
SLLBlock	pointer
,	O
int	O
*	O
iSLLBlock	pointer
)	O
{	O
EdgeTableEntry	struct
*	O
start	pointer
,	O
*	O
prev	pointer
;	O
ScanLineList	struct
*	O
pSLL	pointer
,	O
*	O
pPrevSLL	pointer
;	O
ScanLineListBlock	struct
*	O
tmpSLLBlock	pointer
;	O
pPrevSLL	pointer
=	O
&	O
ET	pointer
->	O
scanlines	struct
;	O
pSLL	pointer
=	O
pPrevSLL	pointer
->	O
next	pointer
;	O
while	O
(	O
pSLL	pointer
&&	O
(	O
pSLL	pointer
->	O
scanline	int
<	O
scanline	int
)	O
)	O
{	O
pPrevSLL	pointer
=	O
pSLL	pointer
;	O
pSLL	pointer
=	O
pSLL	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
(	O
!	O
pSLL	pointer
)	O
||	O
(	O
pSLL	pointer
->	O
scanline	int
>	O
scanline	int
)	O
)	O
{	O
if	O
(	O
*	O
iSLLBlock	pointer
>	O
SLLSPERBLOCK	int
-	O
1	int
)	O
{	O
tmpSLLBlock	pointer
=	O
(	O
ScanLineListBlock	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
ScanLineListBlock	struct
)	O
)	O
;	O
(	O
*	O
SLLBlock	pointer
)	O
->	O
next	pointer
=	O
tmpSLLBlock	pointer
;	O
tmpSLLBlock	pointer
->	O
next	pointer
=	O
(	O
ScanLineListBlock	struct
*	O
)	O
NULL	O
;	O
*	O
SLLBlock	pointer
=	O
tmpSLLBlock	pointer
;	O
*	O
iSLLBlock	pointer
=	O
0	int
;	O
}	O
pSLL	pointer
=	O
&	O
(	O
(	O
*	O
SLLBlock	pointer
)	O
->	O
SLLs	array
[	O
(	O
*	O
iSLLBlock	pointer
)	O
++	O
]	O
)	O
;	O
pSLL	pointer
->	O
next	pointer
=	O
pPrevSLL	pointer
->	O
next	pointer
;	O
pSLL	pointer
->	O
edgelist	pointer
=	O
(	O
EdgeTableEntry	struct
*	O
)	O
NULL	O
;	O
pPrevSLL	pointer
->	O
next	pointer
=	O
pSLL	pointer
;	O
}	O
pSLL	pointer
->	O
scanline	int
=	O
scanline	int
;	O
prev	pointer
=	O
(	O
EdgeTableEntry	struct
*	O
)	O
NULL	O
;	O
start	pointer
=	O
pSLL	pointer
->	O
edgelist	pointer
;	O
while	O
(	O
start	pointer
&&	O
(	O
start	pointer
->	O
bres	struct
.	O
minor_axis	int
<	O
ETE	pointer
->	O
bres	struct
.	O
minor_axis	int
)	O
)	O
{	O
prev	pointer
=	O
start	pointer
;	O
start	pointer
=	O
start	pointer
->	O
next	pointer
;	O
}	O
ETE	pointer
->	O
next	pointer
=	O
start	pointer
;	O
if	O
(	O
prev	pointer
)	O
prev	pointer
->	O
next	pointer
=	O
ETE	pointer
;	O
else	O
pSLL	pointer
->	O
edgelist	pointer
=	O
ETE	pointer
;	O
}	O
void	O
miCreateETandAET	O
(	O
int	O
count	int
,	O
const	O
miPoint	struct
*	O
pts	array
,	O
EdgeTable	struct
*	O
ET	pointer
,	O
EdgeTableEntry	struct
*	O
AET	pointer
,	O
EdgeTableEntry	struct
*	O
pETEs	pointer
,	O
ScanLineListBlock	struct
*	O
pSLLBlock	pointer
)	O
{	O
const	O
miPoint	struct
*	O
top	pointer
,	O
*	O
bottom	pointer
;	O
const	O
miPoint	struct
*	O
PrevPt	pointer
,	O
*	O
CurrPt	pointer
;	O
int	O
iSLLBlock	pointer
=	O
0	int
;	O
int	O
dy	int
;	O
if	O
(	O
count	int
<	O
2	int
)	O
return	O
;	O
AET	pointer
->	O
next	pointer
=	O
(	O
EdgeTableEntry	struct
*	O
)	O
NULL	O
;	O
AET	pointer
->	O
back	pointer
=	O
(	O
EdgeTableEntry	struct
*	O
)	O
NULL	O
;	O
AET	pointer
->	O
nextWETE	pointer
=	O
(	O
EdgeTableEntry	struct
*	O
)	O
NULL	O
;	O
AET	pointer
->	O
bres	struct
.	O
minor_axis	int
=	O
INT_MIN	O
;	O
ET	pointer
->	O
scanlines	struct
.	O
next	pointer
=	O
(	O
ScanLineList	struct
*	O
)	O
NULL	O
;	O
ET	pointer
->	O
ymax	double
=	O
INT_MIN	O
;	O
ET	pointer
->	O
ymin	double
=	O
INT_MAX	O
;	O
pSLLBlock	pointer
->	O
next	pointer
=	O
(	O
ScanLineListBlock	struct
*	O
)	O
NULL	O
;	O
PrevPt	pointer
=	O
&	O
pts	array
[	O
count	int
-	O
1	int
]	O
;	O
while	O
(	O
count	int
--	O
)	O
{	O
CurrPt	pointer
=	O
pts	array
++	O
;	O
if	O
(	O
PrevPt	pointer
->	O
y	double
>	O
CurrPt	pointer
->	O
y	double
)	O
{	O
bottom	pointer
=	O
PrevPt	pointer
,	O
top	pointer
=	O
CurrPt	pointer
;	O
pETEs	pointer
->	O
ClockWise	enum
=	O
false	int
;	O
}	O
else	O
{	O
bottom	pointer
=	O
CurrPt	pointer
,	O
top	pointer
=	O
PrevPt	pointer
;	O
pETEs	pointer
->	O
ClockWise	enum
=	O
true	int
;	O
}	O
if	O
(	O
bottom	pointer
->	O
y	double
!=	O
top	pointer
->	O
y	double
)	O
{	O
pETEs	pointer
->	O
ymax	double
=	O
bottom	pointer
->	O
y	double
-	O
1	int
;	O
dy	int
=	O
bottom	pointer
->	O
y	double
-	O
top	pointer
->	O
y	double
;	O
BRESINITPGONSTRUCT	O
(	O
dy	int
,	O
top	pointer
->	O
x	double
,	O
bottom	pointer
->	O
x	double
,	O
pETEs	pointer
->	O
bres	struct
)	O
;	O
miInsertEdgeInET	function
(	O
ET	pointer
,	O
pETEs	pointer
,	O
top	pointer
->	O
y	double
,	O
&	O
pSLLBlock	pointer
,	O
&	O
iSLLBlock	pointer
)	O
;	O
ET	pointer
->	O
ymax	double
=	O
IMAX	O
(	O
ET	pointer
->	O
ymax	double
,	O
PrevPt	pointer
->	O
y	double
)	O
;	O
ET	pointer
->	O
ymin	double
=	O
IMIN	O
(	O
ET	pointer
->	O
ymin	double
,	O
PrevPt	pointer
->	O
y	double
)	O
;	O
pETEs	pointer
++	O
;	O
}	O
PrevPt	pointer
=	O
CurrPt	pointer
;	O
}	O
}	O
void	O
miloadAET	O
(	O
EdgeTableEntry	struct
*	O
AET	pointer
,	O
EdgeTableEntry	struct
*	O
ETEs	pointer
)	O
{	O
EdgeTableEntry	struct
*	O
pPrevAET	pointer
;	O
EdgeTableEntry	struct
*	O
tmp	pointer
;	O
pPrevAET	pointer
=	O
AET	pointer
;	O
AET	pointer
=	O
AET	pointer
->	O
next	pointer
;	O
while	O
(	O
ETEs	pointer
)	O
{	O
while	O
(	O
AET	pointer
&&	O
(	O
AET	pointer
->	O
bres	struct
.	O
minor_axis	int
<	O
ETEs	pointer
->	O
bres	struct
.	O
minor_axis	int
)	O
)	O
{	O
pPrevAET	pointer
=	O
AET	pointer
;	O
AET	pointer
=	O
AET	pointer
->	O
next	pointer
;	O
}	O
tmp	pointer
=	O
ETEs	pointer
->	O
next	pointer
;	O
ETEs	pointer
->	O
next	pointer
=	O
AET	pointer
;	O
if	O
(	O
AET	pointer
)	O
AET	pointer
->	O
back	pointer
=	O
ETEs	pointer
;	O
ETEs	pointer
->	O
back	pointer
=	O
pPrevAET	pointer
;	O
pPrevAET	pointer
->	O
next	pointer
=	O
ETEs	pointer
;	O
pPrevAET	pointer
=	O
ETEs	pointer
;	O
ETEs	pointer
=	O
tmp	pointer
;	O
}	O
}	O
void	O
micomputeWAET	O
(	O
EdgeTableEntry	struct
*	O
AET	pointer
)	O
{	O
EdgeTableEntry	struct
*	O
pWETE	pointer
;	O
int	O
inside	int
=	O
1	int
;	O
int	O
isInside	int
=	O
0	int
;	O
AET	pointer
->	O
nextWETE	pointer
=	O
(	O
EdgeTableEntry	struct
*	O
)	O
NULL	O
;	O
pWETE	pointer
=	O
AET	pointer
;	O
AET	pointer
=	O
AET	pointer
->	O
next	pointer
;	O
while	O
(	O
AET	pointer
)	O
{	O
if	O
(	O
AET	pointer
->	O
ClockWise	enum
)	O
isInside	int
++	O
;	O
else	O
isInside	int
--	O
;	O
if	O
(	O
(	O
!	O
inside	int
&&	O
!	O
isInside	int
)	O
||	O
(	O
inside	int
&&	O
isInside	int
)	O
)	O
{	O
pWETE	pointer
->	O
nextWETE	pointer
=	O
AET	pointer
;	O
pWETE	pointer
=	O
AET	pointer
;	O
inside	int
=	O
!	O
inside	int
;	O
}	O
AET	pointer
=	O
AET	pointer
->	O
next	pointer
;	O
}	O
pWETE	pointer
->	O
nextWETE	pointer
=	O
(	O
EdgeTableEntry	struct
*	O
)	O
NULL	O
;	O
}	O
bool	enum
miInsertionSort	O
(	O
EdgeTableEntry	struct
*	O
AET	pointer
)	O
{	O
EdgeTableEntry	struct
*	O
pETEchase	pointer
;	O
EdgeTableEntry	struct
*	O
pETEinsert	pointer
;	O
EdgeTableEntry	struct
*	O
pETEchaseBackTMP	pointer
;	O
bool	enum
changed	enum
=	O
false	int
;	O
AET	pointer
=	O
AET	pointer
->	O
next	pointer
;	O
while	O
(	O
AET	pointer
)	O
{	O
pETEinsert	pointer
=	O
AET	pointer
;	O
pETEchase	pointer
=	O
AET	pointer
;	O
while	O
(	O
pETEchase	pointer
->	O
back	pointer
->	O
bres	struct
.	O
minor_axis	int
>	O
AET	pointer
->	O
bres	struct
.	O
minor_axis	int
)	O
pETEchase	pointer
=	O
pETEchase	pointer
->	O
back	pointer
;	O
AET	pointer
=	O
AET	pointer
->	O
next	pointer
;	O
if	O
(	O
pETEchase	pointer
!=	O
pETEinsert	pointer
)	O
{	O
pETEchaseBackTMP	pointer
=	O
pETEchase	pointer
->	O
back	pointer
;	O
pETEinsert	pointer
->	O
back	pointer
->	O
next	pointer
=	O
AET	pointer
;	O
if	O
(	O
AET	pointer
)	O
AET	pointer
->	O
back	pointer
=	O
pETEinsert	pointer
->	O
back	pointer
;	O
pETEinsert	pointer
->	O
next	pointer
=	O
pETEchase	pointer
;	O
pETEchase	pointer
->	O
back	pointer
->	O
next	pointer
=	O
pETEinsert	pointer
;	O
pETEchase	pointer
->	O
back	pointer
=	O
pETEinsert	pointer
;	O
pETEinsert	pointer
->	O
back	pointer
=	O
pETEchaseBackTMP	pointer
;	O
changed	enum
=	O
true	int
;	O
}	O
}	O
return	O
changed	enum
;	O
}	O
void	O
miFreeStorage	O
(	O
ScanLineListBlock	struct
*	O
pSLLBlock	pointer
)	O
{	O
ScanLineListBlock	struct
*	O
tmpSLLBlock	pointer
;	O
while	O
(	O
pSLLBlock	pointer
)	O
{	O
tmpSLLBlock	pointer
=	O
pSLLBlock	pointer
->	O
next	pointer
;	O
free	function
(	O
pSLLBlock	pointer
)	O
;	O
pSLLBlock	pointer
=	O
tmpSLLBlock	pointer
;	O
}	O
}	O
char	O
*	O
xstrdup	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
char	O
*	O
t	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
s	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
t	pointer
,	O
s	pointer
)	O
;	O
return	O
t	pointer
;	O
}	O
struct	O
prt	struct
*	O
palloc	function
(	O
void	O
)	O
{	O
struct	O
prt	struct
*	O
pp	pointer
;	O
pp	pointer
=	O
(	O
struct	O
prt	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
prt	struct
)	O
)	O
;	O
pp	pointer
->	O
pr_sym	pointer
=	O
NULL	O
;	O
pp	pointer
->	O
pr_link	pointer
=	O
NULL	O
;	O
pp	pointer
->	O
pr_which	pointer
=	O
P_VALUE	pointer
;	O
return	O
pp	pointer
;	O
}	O
void	O
pfree	function
(	O
struct	O
prt	struct
*	O
pp	pointer
)	O
{	O
if	O
(	O
pp	pointer
!=	O
NULL	O
)	O
{	O
pfree	function
(	O
pp	pointer
->	O
pr_link	pointer
)	O
;	O
free	function
(	O
(	O
void	O
*	O
)	O
pp	pointer
)	O
;	O
}	O
}	O
extern	O
int	O
h_errno	O
;	O
int	O
s4con	function
(	O
int	O
sockfd	int
,	O
struct	O
sockaddr	struct
*	O
serv	pointer
)	O
{	O
char	O
p	pointer
[	O
9	int
+	O
9	int
]	O
;	O
memset	function
(	O
p	pointer
,	O
0	int
,	O
sizeof	O
(	O
p	pointer
)	O
)	O
;	O
p	pointer
[	O
0	int
]	O
=	O
4	int
;	O
p	pointer
[	O
1	int
]	O
=	O
1	int
;	O
*	O
(	O
short	O
int	O
*	O
)	O
(	O
p	pointer
+	O
2	int
)	O
=	O
(	O
short	O
int	O
)	O
(	O
(	O
(	O
struct	O
sockaddr_in	struct
*	O
)	O
serv	pointer
)	O
->	O
sin_port	short
)	O
;	O
*	O
(	O
struct	O
in_addr	struct
*	O
)	O
(	O
p	pointer
+	O
4	int
)	O
=	O
(	O
(	O
struct	O
sockaddr_in	struct
*	O
)	O
serv	pointer
)	O
->	O
sin_addr	struct
;	O
memmove	function
(	O
p	pointer
+	O
8	int
,	O
SOCKS4USER	pointer
,	O
9	int
)	O
;	O
if	O
(	O
write	function
(	O
sockfd	int
,	O
p	pointer
,	O
10	int
)	O
==	O
10	int
)	O
{	O
if	O
(	O
read	function
(	O
sockfd	int
,	O
p	pointer
,	O
8	int
)	O
==	O
8	int
)	O
{	O
if	O
(	O
(	O
p	pointer
[	O
0	int
]	O
==	O
0	int
)	O
&&	O
(	O
p	pointer
[	O
1	int
]	O
==	O
90	int
)	O
)	O
return	O
0	int
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"%s %s: s4con:SOCKS4 server error reply:%02X %02X\n"	pointer
,	O
progname	pointer
,	O
__FILE__	O
,	O
p	pointer
[	O
0	int
]	O
,	O
p	pointer
[	O
1	int
]	O
)	O
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
CONVIASOCKS4_MAIN	function
(	O
int	O
sockfd	int
,	O
struct	O
sockaddr	struct
*	O
addr	pointer
)	O
{	O
int	O
ret	int
,	O
len	int
,	O
offset	int
;	O
char	O
*	O
p	pointer
;	O
ret	array
=	O
connect	function
(	O
sockfd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
(	O
my	struct
.	O
myaddr	struct
)	O
,	O
sizeof	O
(	O
struct	O
sockaddr	struct
)	O
)	O
;	O
if	O
(	O
ret	array
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s %s: CONVIASOCKS4_MAIN:connect:Connect to myaddr\n"	pointer
,	O
progname	pointer
,	O
__FILE__	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
my	struct
.	O
mytype	int
!=	O
SOCKS4_CONNECT	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s %s: "	pointer
"CONVIASOCKS4_MAIN:error method!This message shouldn't be printed!\n"	pointer
,	O
progname	pointer
,	O
__FILE__	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
ret	int
=	O
s4con	function
(	O
sockfd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
addr	pointer
)	O
;	O
if	O
(	O
ret	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
CONVIASOCKS4	function
(	O
int	O
sockfd	int
,	O
struct	O
timeval	struct
*	O
start	pointer
,	O
struct	O
timeval	struct
*	O
end	pointer
,	O
struct	O
thread_mem	struct
*	O
thread_mem	struct
)	O
{	O
int	O
ret	array
,	O
len	int
,	O
offset	int
;	O
char	O
*	O
p	pointer
;	O
ret	array
=	O
connect	function
(	O
sockfd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
(	O
my	struct
.	O
myaddr	struct
)	O
,	O
sizeof	O
(	O
struct	O
sockaddr	struct
)	O
)	O
;	O
if	O
(	O
ret	array
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s %s: CONVIASOCKS4:connect:Connect to myaddr\n"	pointer
,	O
progname	pointer
,	O
__FILE__	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
my	struct
.	O
mytype	int
!=	O
SOCKS4_CONNECT	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s %s: "	pointer
" CONVIASOCKS4:error method!This message shouldn't be printed!\n"	pointer
,	O
progname	pointer
,	O
__FILE__	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
gettimeofday	function
(	O
start	pointer
,	O
NULL	O
)	O
;	O
ret	int
=	O
s4con	function
(	O
sockfd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
(	O
thread_mem	struct
->	O
queue	struct
.	O
proxyaddr	struct
)	O
)	O
;	O
if	O
(	O
ret	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
gettimeofday	function
(	O
end	pointer
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
S4PCONGET	function
(	O
int	O
sockfd	int
,	O
struct	O
timeval	struct
*	O
start_CON	pointer
,	O
struct	O
timeval	struct
*	O
end_CON	pointer
,	O
struct	O
timeval	struct
*	O
start_GET	pointer
,	O
struct	O
thread_mem	struct
*	O
thread_mem	struct
)	O
{	O
int	O
ret	int
;	O
gettimeofday	function
(	O
start_CON	pointer
,	O
NULL	O
)	O
;	O
ret	int
=	O
s4con	function
(	O
sockfd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
(	O
target	struct
.	O
targetaddr	struct
)	O
)	O
;	O
if	O
(	O
ret	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
gettimeofday	function
(	O
end_CON	pointer
,	O
NULL	O
)	O
;	O
return	O
GET	function
(	O
sockfd	int
,	O
start_GET	pointer
,	O
thread_mem	struct
)	O
;	O
}	O
const	O
char	O
*	O
argp_program_bug_address	pointer
;	O
int	O
volatile	O
exit_failure	int
=	O
EXIT_FAILURE	int
;	O
int	O
getopt_long	function
(	O
int	O
argc	int
,	O
char	O
*	O
__getopt_argv_const	O
*	O
argv	pointer
,	O
const	O
char	O
*	O
options	pointer
,	O
const	O
struct	O
option	struct
*	O
long_options	pointer
,	O
int	O
*	O
opt_index	pointer
)	O
{	O
return	O
_getopt_internal	O
(	O
argc	int
,	O
(	O
char	O
*	O
*	O
)	O
argv	pointer
,	O
options	pointer
,	O
long_options	pointer
,	O
opt_index	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
int	O
_getopt_long_r	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
const	O
char	O
*	O
options	pointer
,	O
const	O
struct	O
option	struct
*	O
long_options	pointer
,	O
int	O
*	O
opt_index	pointer
,	O
struct	O
_getopt_data	struct
*	O
d	pointer
)	O
{	O
return	O
_getopt_internal_r	function
(	O
argc	int
,	O
argv	pointer
,	O
options	pointer
,	O
long_options	pointer
,	O
opt_index	pointer
,	O
0	int
,	O
0	int
,	O
d	pointer
)	O
;	O
}	O
int	O
getopt_long_only	function
(	O
int	O
argc	int
,	O
char	O
*	O
__getopt_argv_const	O
*	O
argv	pointer
,	O
const	O
char	O
*	O
options	pointer
,	O
const	O
struct	O
option	struct
*	O
long_options	pointer
,	O
int	O
*	O
opt_index	pointer
)	O
{	O
return	O
_getopt_internal	O
(	O
argc	int
,	O
(	O
char	O
*	O
*	O
)	O
argv	pointer
,	O
options	pointer
,	O
long_options	pointer
,	O
opt_index	pointer
,	O
1	int
,	O
0	int
)	O
;	O
}	O
int	O
_getopt_long_only_r	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
const	O
char	O
*	O
options	pointer
,	O
const	O
struct	O
option	struct
*	O
long_options	pointer
,	O
int	O
*	O
opt_index	pointer
,	O
struct	O
_getopt_data	struct
*	O
d	pointer
)	O
{	O
return	O
_getopt_internal_r	function
(	O
argc	int
,	O
argv	pointer
,	O
options	pointer
,	O
long_options	pointer
,	O
opt_index	pointer
,	O
1	int
,	O
0	int
,	O
d	pointer
)	O
;	O
}	O
int	O
PRINTF_FETCHARGS	O
(	O
va_list	array
args	array
,	O
arguments	struct
*	O
a	union
)	O
{	O
size_t	long
i	long
;	O
argument	struct
*	O
ap	pointer
;	O
for	O
(	O
i	long
=	O
0	int
,	O
ap	pointer
=	O
&	O
a	union
->	O
arg	pointer
[	O
0	int
]	O
;	O
i	long
<	O
a	union
->	O
count	long
;	O
i	long
++	O
,	O
ap	pointer
++	O
)	O
switch	O
(	O
ap	pointer
->	O
type	enum
)	O
{	O
case	O
TYPE_SCHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_schar	char
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_UCHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_uchar	char
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_SHORT	int
:	O
ap	pointer
->	O
a	union
.	O
a_short	short
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_USHORT	int
:	O
ap	pointer
->	O
a	union
.	O
a_ushort	short
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_INT	int
:	O
ap	pointer
->	O
a	union
.	O
a_int	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_UINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_uint	int
=	O
va_arg	O
(	O
args	array
,	O
unsigned	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_LONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_longint	long
=	O
va_arg	O
(	O
args	array
,	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_ULONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_ulongint	long
=	O
va_arg	O
(	O
args	array
,	O
unsigned	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_LONGLONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_longlongint	long long
=	O
va_arg	O
(	O
args	array
,	O
long	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_ULONGLONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_ulonglongint	long long
=	O
va_arg	O
(	O
args	array
,	O
unsigned	O
long	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_DOUBLE	int
:	O
ap	pointer
->	O
a	union
.	O
a_double	double
=	O
va_arg	O
(	O
args	array
,	O
double	O
)	O
;	O
break	O
;	O
case	O
TYPE_LONGDOUBLE	int
:	O
ap	pointer
->	O
a	union
.	O
a_longdouble	bool
=	O
va_arg	O
(	O
args	array
,	O
long	O
double	O
)	O
;	O
break	O
;	O
case	O
TYPE_CHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_char	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_WIDE_CHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_wide_char	int
=	O
(	O
sizeof	O
(	O
wint_t	int
)	O
<	O
sizeof	O
(	O
int	O
)	O
?	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
:	O
va_arg	O
(	O
args	array
,	O
wint_t	int
)	O
)	O
;	O
break	O
;	O
case	O
TYPE_STRING	int
:	O
ap	pointer
->	O
a	union
.	O
a_string	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
char	O
*	O
)	O
;	O
if	O
(	O
ap	pointer
->	O
a	union
.	O
a_string	pointer
==	O
NULL	O
)	O
ap	pointer
->	O
a	union
.	O
a_string	pointer
=	O
"(NULL)"	pointer
;	O
break	O
;	O
case	O
TYPE_WIDE_STRING	int
:	O
ap	pointer
->	O
a	union
.	O
a_wide_string	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
wchar_t	int
*	O
)	O
;	O
if	O
(	O
ap	pointer
->	O
a	union
.	O
a_wide_string	pointer
==	O
NULL	O
)	O
{	O
static	O
const	O
wchar_t	int
wide_null_string	array
[	O
]	O
=	O
{	O
(	O
wchar_t	int
)	O
'('	O
,	O
(	O
wchar_t	int
)	O
'N'	O
,	O
(	O
wchar_t	int
)	O
'U'	O
,	O
(	O
wchar_t	int
)	O
'L'	O
,	O
(	O
wchar_t	int
)	O
'L'	O
,	O
(	O
wchar_t	int
)	O
')'	O
,	O
(	O
wchar_t	int
)	O
0	int
}	O
;	O
ap	pointer
->	O
a	union
.	O
a_wide_string	pointer
=	O
wide_null_string	array
;	O
}	O
break	O
;	O
case	O
TYPE_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
void	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_SCHAR_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_schar_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
signed	O
char	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_SHORT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_short_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
short	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_INT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_int_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
int	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_LONGINT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_longint_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
long	O
int	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_LONGLONGINT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_longlongint_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
long	O
long	O
int	O
*	O
)	O
;	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
envar	struct
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
value	pointer
;	O
}	O
ENVAR	struct
;	O
static	O
void	O
grad_envar_assign_internal	function
(	O
char	O
*	O
name	pointer
,	O
int	O
namelen	int
,	O
char	O
*	O
value	pointer
,	O
int	O
valuelen	int
,	O
grad_list_t	O
*	O
*	O
plist	pointer
)	O
{	O
ENVAR	struct
*	O
env	pointer
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
!	O
value	pointer
)	O
{	O
if	O
(	O
namelen	int
>	O
2	int
&&	O
memcmp	function
(	O
name	pointer
,	O
"no"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
name	pointer
+=	O
2	int
;	O
namelen	long
-=	O
2	int
;	O
value	pointer
=	O
"0"	pointer
;	O
valuelen	int
=	O
1	int
;	O
}	O
else	O
{	O
value	pointer
=	O
"1"	pointer
;	O
valuelen	int
=	O
1	int
;	O
}	O
}	O
env	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
env	pointer
)	O
)	O
;	O
env	pointer
->	O
name	pointer
=	O
grad_emalloc	function
(	O
namelen	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
env	pointer
->	O
name	pointer
,	O
name	pointer
,	O
namelen	long
)	O
;	O
env	pointer
->	O
name	pointer
[	O
namelen	long
]	O
=	O
0	int
;	O
env	pointer
->	O
value	pointer
=	O
grad_emalloc	function
(	O
valuelen	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
env	pointer
->	O
value	pointer
,	O
value	pointer
,	O
valuelen	int
)	O
;	O
env	pointer
->	O
value	pointer
[	O
valuelen	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
*	O
plist	pointer
)	O
*	O
plist	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_list_append	function
(	O
*	O
plist	pointer
,	O
env	pointer
)	O
;	O
}	O
void	O
grad_envar_assign	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
value	pointer
,	O
grad_list_t	function
*	O
*	O
plist	pointer
)	O
{	O
grad_envar_assign_internal	function
(	O
name	pointer
,	O
strlen	function
(	O
name	pointer
)	O
,	O
value	pointer
,	O
value	pointer
?	O
strlen	function
(	O
value	pointer
)	O
:	O
0	int
,	O
plist	pointer
)	O
;	O
}	O
static	O
void	O
grad_envar_parse_grad_argcv_internal	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
grad_list_t	O
*	O
*	O
plist	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
p	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
argv	pointer
[	O
i	int
]	O
[	O
0	int
]	O
==	O
','	O
)	O
continue	O
;	O
p	pointer
=	O
strchr	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
'='	O
)	O
;	O
if	O
(	O
p	pointer
)	O
grad_envar_assign_internal	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
p	pointer
-	O
argv	pointer
[	O
i	int
]	O
,	O
p	pointer
+	O
1	int
,	O
strlen	function
(	O
p	pointer
+	O
1	int
)	O
,	O
plist	pointer
)	O
;	O
else	O
grad_envar_assign_internal	function
(	O
argv	pointer
[	O
i	int
]	O
,	O
strlen	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
,	O
NULL	O
,	O
0	int
,	O
plist	pointer
)	O
;	O
}	O
}	O
static	O
void	O
grad_envar_parse_internal	function
(	O
char	O
*	O
str	pointer
,	O
grad_list_t	function
*	O
*	O
plist	pointer
)	O
{	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
if	O
(	O
grad_argcv_get	function
(	O
str	pointer
,	O
","	pointer
,	O
NULL	O
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
)	O
{	O
if	O
(	O
argv	pointer
)	O
grad_argcv_free	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
return	O
;	O
}	O
grad_envar_parse_grad_argcv_internal	function
(	O
argc	int
,	O
argv	pointer
,	O
plist	pointer
)	O
;	O
grad_argcv_free	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
}	O
grad_envar_t	struct
*	O
grad_envar_parse	function
(	O
char	O
*	O
str	pointer
)	O
{	O
grad_list_t	struct
*	O
list	pointer
=	O
NULL	O
;	O
grad_envar_parse_internal	function
(	O
str	pointer
,	O
&	O
list	pointer
)	O
;	O
return	O
list	pointer
;	O
}	O
grad_envar_t	struct
*	O
grad_envar_parse_argcv	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
grad_list_t	struct
*	O
list	pointer
=	O
NULL	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
grad_envar_parse_internal	function
(	O
*	O
argv	pointer
++	O
,	O
&	O
list	pointer
)	O
;	O
}	O
return	O
list	pointer
;	O
}	O
static	O
int	O
grad_envar_free	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
ENVAR	struct
*	O
env	pointer
=	O
item	pointer
;	O
grad_free	function
(	O
env	pointer
->	O
name	pointer
)	O
;	O
grad_free	function
(	O
env	pointer
->	O
value	pointer
)	O
;	O
grad_free	function
(	O
env	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
grad_envar_free_list	function
(	O
grad_envar_t	struct
*	O
*	O
evp	pointer
)	O
{	O
grad_list_destroy	function
(	O
evp	pointer
,	O
grad_envar_free	O
,	O
NULL	O
)	O
;	O
}	O
char	O
*	O
grad_envar_lookup	function
(	O
grad_envar_t	struct
*	O
env	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
ENVAR	struct
*	O
p	pointer
;	O
grad_iterator_t	struct
*	O
itr	pointer
=	O
grad_iterator_create	function
(	O
env	pointer
)	O
;	O
if	O
(	O
!	O
itr	pointer
)	O
return	O
NULL	O
;	O
for	O
(	O
p	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
p	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
return	O
p	pointer
?	O
p	pointer
->	O
value	pointer
:	O
NULL	O
;	O
}	O
char	O
*	O
grad_envar_lookup_str	function
(	O
grad_envar_t	struct
*	O
env	pointer
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
defval	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
s	pointer
=	O
grad_envar_lookup	function
(	O
env	pointer
,	O
name	pointer
)	O
)	O
return	O
s	pointer
;	O
return	O
defval	int
;	O
}	O
int	O
grad_envar_lookup_int	function
(	O
grad_envar_t	struct
*	O
env	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
defval	int
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
s	pointer
=	O
grad_envar_lookup	function
(	O
env	pointer
,	O
name	pointer
)	O
)	O
return	O
atoi	function
(	O
s	pointer
)	O
;	O
return	O
defval	int
;	O
}	O
ENVAR	struct
*	O
grad_envar_dup	function
(	O
ENVAR	struct
*	O
env	pointer
)	O
{	O
ENVAR	struct
*	O
ep	pointer
;	O
ep	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
ep	pointer
)	O
)	O
;	O
ep	pointer
->	O
name	pointer
=	O
grad_estrdup	function
(	O
env	pointer
->	O
name	pointer
)	O
;	O
ep	pointer
->	O
value	pointer
=	O
grad_estrdup	function
(	O
env	pointer
->	O
value	pointer
)	O
;	O
return	O
ep	pointer
;	O
}	O
grad_envar_t	struct
*	O
grad_envar_merge_lists	function
(	O
grad_envar_t	struct
*	O
prim	pointer
,	O
grad_envar_t	struct
*	O
sec	pointer
)	O
{	O
grad_envar_t	struct
*	O
list	pointer
;	O
ENVAR	struct
*	O
p	pointer
;	O
grad_iterator_t	struct
*	O
itr	pointer
;	O
list	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
itr	pointer
=	O
grad_iterator_create	function
(	O
sec	pointer
)	O
;	O
if	O
(	O
itr	pointer
)	O
{	O
for	O
(	O
p	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
if	O
(	O
!	O
grad_envar_lookup	function
(	O
prim	pointer
,	O
p	pointer
->	O
name	pointer
)	O
)	O
{	O
grad_list_append	function
(	O
list	pointer
,	O
grad_envar_dup	function
(	O
p	pointer
)	O
)	O
;	O
}	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
}	O
itr	pointer
=	O
grad_iterator_create	function
(	O
prim	pointer
)	O
;	O
if	O
(	O
itr	pointer
)	O
{	O
for	O
(	O
p	pointer
=	O
grad_iterator_first	function
(	O
itr	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
grad_iterator_next	function
(	O
itr	pointer
)	O
)	O
grad_list_append	function
(	O
list	pointer
,	O
grad_envar_dup	function
(	O
p	pointer
)	O
)	O
;	O
grad_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
}	O
return	O
list	pointer
;	O
}	O
const	O
char	O
*	O
argp_program_bug_address	pointer
=	O
"<"	pointer
PACKAGE_BUGREPORT	pointer
">"	pointer
;	O
static	O
struct	O
argp_option	struct
rad_common_argp_option	array
[	O
]	O
=	O
{	O
{	O
"directory"	pointer
,	O
'd'	O
,	O
N_	O
(	O
"DIR"	pointer
)	O
,	O
0	int
,	O
N_	O
(	O
"Set path to the configuration directory"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
"license"	pointer
,	O
'L'	O
,	O
NULL	O
,	O
0	int
,	O
N_	O
(	O
"print license and exit"	pointer
)	O
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
error_t	int
rad_common_argp_parser	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
;	O
struct	O
argp	struct
grad_common_argp	struct
=	O
{	O
rad_common_argp_option	pointer
,	O
rad_common_argp_parser	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
struct	O
argp_child	struct
grad_common_argp_child	array
[	O
]	O
=	O
{	O
{	O
&	O
grad_common_argp	struct
,	O
0	int
,	O
N_	O
(	O
"Common options"	pointer
)	O
,	O
1	int
}	O
,	O
{	O
NULL	O
}	O
,	O
}	O
;	O
char	O
*	O
__argp_base_name	function
(	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
strrchr	function
(	O
arg	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
p	pointer
=	O
arg	pointer
;	O
else	O
p	pointer
++	O
;	O
return	O
(	O
char	O
*	O
)	O
p	pointer
;	O
}	O
static	O
char	O
license_text	array
[	O
]	O
=	O
N_	O
(	O
"   This program is free software; you can redistribute it and/or modify\n"	pointer
"   it under the terms of the GNU General Public License as published by\n"	<padding>
"   the Free Software Foundation; either version 3, or (at your option)\n"	<padding>
"   any later version.\n"	<padding>
"\n"	<padding>
"   This program is distributed in the hope that it will be useful,\n"	<padding>
"   but WITHOUT ANY WARRANTY; without even the implied warranty of\n"	<padding>
"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"	<padding>
"   GNU General Public License for more details.\n"	<padding>
"\n"	<padding>
"   You should have received a copy of the GNU General Public License\n"	<padding>
"   along with GNU Radius; if not, write to the Free Software Foundation,\n"	<padding>
"   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n"	<padding>
"\n"	pointer
)	O
;	O
static	O
error_t	int
rad_common_argp_parser	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'd'	O
:	O
grad_config_dir	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
'L'	O
:	O
printf	function
(	O
"%s"	pointer
,	O
_	O
(	O
license_text	pointer
)	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
case	O
ARGP_KEY_FINI	int
:	O
grad_path_init	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
error_t	O
grad_argp_parse	function
(	O
const	O
struct	O
argp	struct
*	O
argp	pointer
,	O
int	O
*	O
pargc	pointer
,	O
char	O
*	O
*	O
pargv	array
[	O
]	O
,	O
unsigned	O
flags	int
,	O
int	O
*	O
arg_index	int
,	O
void	O
*	O
input	pointer
)	O
{	O
error_t	int
ret	int
;	O
program_invocation_name	int
=	O
(	O
*	O
pargv	pointer
[	O
0	int
]	O
)	O
;	O
program_invocation_short_name	pointer
=	O
strrchr	function
(	O
program_invocation_name	int
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
program_invocation_short_name	pointer
)	O
program_invocation_short_name	pointer
=	O
program_invocation_name	int
;	O
else	O
program_invocation_short_name	pointer
++	O
;	O
ret	int
=	O
argp_parse	function
(	O
argp	struct
,	O
*	O
pargc	pointer
,	O
*	O
pargv	pointer
,	O
flags	int
,	O
arg_index	int
,	O
input	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
oid_t	pointer
oid_dup	function
(	O
oid_t	pointer
oid	pointer
)	O
{	O
oid_t	pointer
new_oid	pointer
;	O
new_oid	int
=	O
snmp_alloc	function
(	O
OIDSIZE	function
(	O
oid	pointer
)	O
+	O
sizeof	O
(	O
oid	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
new_oid	pointer
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
new_oid	pointer
,	O
oid	pointer
,	O
OIDSIZE	function
(	O
oid	pointer
)	O
+	O
sizeof	O
(	O
oid	pointer
[	O
0	int
]	O
)	O
)	O
;	O
return	O
new_oid	int
;	O
}	O
oid_t	function
oid_create	function
(	O
int	O
len	int
)	O
{	O
oid_t	pointer
oid	pointer
;	O
if	O
(	O
(	O
oid	pointer
=	O
snmp_alloc	function
(	O
(	O
len	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
oid	pointer
[	O
0	int
]	O
)	O
)	O
)	O
)	O
OIDLEN	O
(	O
oid	pointer
)	O
=	O
len	int
;	O
return	O
oid	pointer
;	O
}	O
oid_t	function
oid_create_from_string	function
(	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
tok	pointer
;	O
int	O
len	int
;	O
oid_t	pointer
name	pointer
,	O
p	pointer
;	O
if	O
(	O
*	O
str	pointer
==	O
'.'	O
)	O
str	pointer
++	O
;	O
for	O
(	O
tok	pointer
=	O
str	pointer
,	O
len	int
=	O
0	int
;	O
*	O
tok	pointer
;	O
tok	int
++	O
)	O
if	O
(	O
*	O
tok	int
==	O
'.'	O
)	O
len	int
++	O
;	O
len	int
++	O
;	O
name	pointer
=	O
snmp_alloc	function
(	O
sizeof	O
(	O
*	O
name	pointer
)	O
*	O
(	O
len	int
+	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
{	O
SNMP_SET_ERRNO	O
(	O
E_SNMP_NOMEM	int
)	O
;	O
return	O
NULL	O
;	O
}	O
OIDLEN	O
(	O
name	pointer
)	O
=	O
len	int
;	O
p	pointer
=	O
OIDPTR	O
(	O
name	pointer
)	O
;	O
tok	int
=	O
str	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
*	O
p	pointer
++	O
=	O
strtol	function
(	O
tok	int
,	O
&	O
tok	int
,	O
10	int
)	O
;	O
if	O
(	O
*	O
tok	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
*	O
tok	int
++	O
!=	O
'.'	O
)	O
{	O
SNMP_SET_ERRNO	O
(	O
E_SNMP_BAD_OID	int
)	O
;	O
snmp_free	function
(	O
name	pointer
)	O
;	O
name	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
return	O
name	pointer
;	O
}	O
oid_t	function
oid_create_from_subid	function
(	O
int	O
len	int
,	O
subid_t	int
*	O
subid	pointer
)	O
{	O
oid_t	pointer
oid	pointer
;	O
oid	pointer
=	O
snmp_alloc	function
(	O
(	O
len	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
oid	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
oid	pointer
)	O
{	O
SNMP_SET_ERRNO	O
(	O
E_SNMP_NOMEM	int
)	O
;	O
return	O
NULL	O
;	O
}	O
OIDLEN	O
(	O
oid	pointer
)	O
=	O
len	int
;	O
memcpy	function
(	O
OIDPTR	O
(	O
oid	pointer
)	O
,	O
subid	pointer
,	O
len	int
*	O
sizeof	O
(	O
oid	pointer
[	O
0	int
]	O
)	O
)	O
;	O
return	O
oid	pointer
;	O
}	O
int	O
oid_cmp	function
(	O
oid_t	pointer
a	pointer
,	O
oid_t	pointer
b	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
OIDLEN	O
(	O
a	int
)	O
!=	O
OIDLEN	O
(	O
b	int
)	O
)	O
return	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
OIDLEN	O
(	O
a	int
)	O
;	O
i	int
++	O
)	O
if	O
(	O
SUBID	O
(	O
a	int
,	O
i	int
)	O
!=	O
SUBID	O
(	O
b	pointer
,	O
i	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
char	O
*	O
sprint_oid	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
buflen	int
,	O
oid_t	pointer
oid	pointer
)	O
{	O
int	O
i	int
,	O
d	int
;	O
char	O
*	O
p	pointer
,	O
*	O
start	pointer
;	O
char	O
temp	array
[	O
64	int
]	O
;	O
int	O
len	int
=	O
OIDLEN	O
(	O
oid	pointer
)	O
;	O
oid_t	pointer
name	pointer
=	O
OIDPTR	O
(	O
oid	pointer
)	O
;	O
start	int
=	O
buf	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
buflen	int
<	O
3	int
)	O
{	O
*	O
buf	pointer
++	O
=	O
'>'	O
;	O
break	O
;	O
}	O
sprintf	function
(	O
temp	array
,	O
"%d"	pointer
,	O
*	O
name	pointer
)	O
;	O
d	int
=	O
strlen	function
(	O
temp	array
)	O
+	O
1	int
;	O
if	O
(	O
buflen	int
-	O
d	int
<	O
3	int
)	O
{	O
*	O
buf	pointer
++	O
=	O
'>'	O
;	O
break	O
;	O
}	O
buflen	int
-=	O
d	int
;	O
*	O
buf	pointer
++	O
=	O
'.'	O
;	O
for	O
(	O
p	pointer
=	O
temp	pointer
;	O
*	O
p	pointer
;	O
)	O
*	O
buf	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
name	pointer
++	O
;	O
}	O
*	O
buf	pointer
=	O
0	int
;	O
return	O
start	pointer
;	O
}	O
struct	O
snmp_pdu	struct
*	O
snmp_pdu_create	function
(	O
int	O
type	int
)	O
{	O
struct	O
snmp_pdu	struct
*	O
pdu	pointer
;	O
pdu	pointer
=	O
snmp_alloc	function
(	O
sizeof	O
(	O
*	O
pdu	pointer
)	O
)	O
;	O
pdu	pointer
->	O
type	enum
=	O
type	int
;	O
pdu	pointer
->	O
req_id	int
=	O
0	int
;	O
pdu	pointer
->	O
err_stat	int
=	O
0	int
;	O
pdu	pointer
->	O
err_ind	pointer
=	O
0	int
;	O
pdu	struct
->	O
var	pointer
=	O
NULL	O
;	O
return	O
pdu	pointer
;	O
}	O
void	O
snmp_pdu_free	function
(	O
struct	O
snmp_pdu	struct
*	O
pdu	pointer
)	O
{	O
if	O
(	O
!	O
pdu	pointer
)	O
return	O
;	O
snmp_var_free_list	function
(	O
pdu	pointer
->	O
var	pointer
)	O
;	O
snmp_free	function
(	O
pdu	pointer
)	O
;	O
}	O
void	O
snmp_pdu_add_var	function
(	O
struct	O
snmp_pdu	struct
*	O
pdu	pointer
,	O
struct	O
snmp_var	struct
*	O
var	pointer
)	O
{	O
var	int
->	O
next	pointer
=	O
pdu	pointer
->	O
var	pointer
;	O
pdu	pointer
->	O
var	enum
=	O
var	int
;	O
}	O
u_char	char
*	O
snmp_pdu_decode	function
(	O
u_char	char
*	O
data	pointer
,	O
int	O
*	O
length	pointer
,	O
struct	O
snmp_pdu	struct
*	O
pdu	pointer
)	O
{	O
u_char	char
*	O
buf	pointer
=	O
data	pointer
;	O
u_char	char
type	pointer
;	O
buf	pointer
=	O
asn_decode_header	function
(	O
buf	pointer
,	O
length	pointer
,	O
&	O
pdu	pointer
->	O
type	pointer
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
return	O
NULL	O
;	O
switch	O
(	O
pdu	pointer
->	O
type	pointer
)	O
{	O
case	O
SNMP_PDU_RESPONSE	O
:	O
case	O
SNMP_PDU_GET	O
:	O
case	O
SNMP_PDU_GETNEXT	O
:	O
case	O
SNMP_PDU_SET	O
:	O
buf	pointer
=	O
asn_decode_int	function
(	O
buf	pointer
,	O
length	pointer
,	O
&	O
type	pointer
,	O
&	O
pdu	pointer
->	O
req_id	int
,	O
sizeof	O
(	O
pdu	pointer
->	O
req_id	int
)	O
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
break	O
;	O
buf	pointer
=	O
asn_decode_int	function
(	O
buf	pointer
,	O
length	pointer
,	O
&	O
type	pointer
,	O
&	O
pdu	pointer
->	O
err_stat	pointer
,	O
sizeof	O
(	O
pdu	pointer
->	O
err_stat	pointer
)	O
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
break	O
;	O
buf	pointer
=	O
asn_decode_int	function
(	O
buf	pointer
,	O
length	pointer
,	O
&	O
type	pointer
,	O
&	O
pdu	pointer
->	O
err_ind	pointer
,	O
sizeof	O
(	O
pdu	pointer
->	O
err_ind	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
SNMP_SET_ERRNO	O
(	O
E_SNMP_UNKNOWN_REQ	int
)	O
;	O
buf	pointer
=	O
NULL	O
;	O
}	O
return	O
buf	pointer
;	O
}	O
u_char	char
*	O
snmp_pdu_encode	function
(	O
u_char	char
*	O
data	pointer
,	O
int	O
*	O
length	pointer
,	O
struct	O
snmp_pdu	struct
*	O
pdu	pointer
)	O
{	O
u_char	char
*	O
buf	pointer
=	O
data	pointer
;	O
buf	pointer
=	O
asn_encode_int	function
(	O
buf	pointer
,	O
length	pointer
,	O
(	O
ASN_UNIVERSAL	O
|	O
ASN_PRIMITIVE	O
|	O
ASN_INTEGER	O
)	O
,	O
pdu	pointer
->	O
req_id	int
)	O
;	O
BAIL_OUT	O
;	O
buf	pointer
=	O
asn_encode_int	function
(	O
buf	pointer
,	O
length	pointer
,	O
(	O
ASN_UNIVERSAL	O
|	O
ASN_PRIMITIVE	O
|	O
ASN_INTEGER	O
)	O
,	O
pdu	pointer
->	O
err_stat	pointer
)	O
;	O
BAIL_OUT	O
;	O
buf	pointer
=	O
asn_encode_int	function
(	O
buf	pointer
,	O
length	pointer
,	O
(	O
ASN_UNIVERSAL	O
|	O
ASN_PRIMITIVE	O
|	O
ASN_INTEGER	O
)	O
,	O
pdu	pointer
->	O
err_ind	pointer
)	O
;	O
BAIL_OUT	O
;	O
return	O
buf	pointer
;	O
}	O
void	O
snmp_read	function
(	O
)	O
;	O
int	O
snmp_query	function
(	O
struct	O
snmp_session	struct
*	O
sess	pointer
,	O
struct	O
snmp_pdu	struct
*	O
pdu	pointer
)	O
{	O
if	O
(	O
snmp_send	function
(	O
sess	pointer
,	O
pdu	pointer
)	O
)	O
return	O
-	O
1	int
;	O
snmp_poll	function
(	O
sess	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
snmp_poll	function
(	O
struct	O
snmp_session	struct
*	O
sess	pointer
)	O
{	O
int	O
rc	int
;	O
int	O
numfds	int
;	O
fd_set	struct
fdset	struct
;	O
struct	O
timeval	struct
timeout	struct
;	O
while	O
(	O
numfds	int
=	O
snmp_fdset	function
(	O
sess	pointer
,	O
&	O
fdset	pointer
)	O
)	O
{	O
timeout	struct
.	O
tv_usec	long
=	O
0	int
;	O
timeout	struct
.	O
tv_sec	long
=	O
1	int
;	O
rc	int
=	O
select	function
(	O
numfds	pointer
,	O
&	O
fdset	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
timeout	int
)	O
;	O
if	O
(	O
rc	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
snmp_timeout	function
(	O
sess	pointer
)	O
;	O
}	O
else	O
{	O
snmp_read	function
(	O
sess	pointer
,	O
&	O
fdset	pointer
)	O
;	O
}	O
}	O
}	O
void	O
snmp_timeout	function
(	O
struct	O
snmp_session	struct
*	O
sess	pointer
)	O
{	O
struct	O
snmp_session	struct
*	O
sp	pointer
;	O
struct	O
snmp_request	struct
*	O
req	pointer
,	O
*	O
preq	pointer
;	O
struct	O
timeval	struct
now	struct
;	O
gettimeofday	function
(	O
&	O
now	struct
,	O
(	O
struct	O
timezone	struct
*	O
)	O
0	int
)	O
;	O
for	O
(	O
sp	pointer
=	O
sess	pointer
;	O
sp	pointer
;	O
sp	pointer
=	O
sp	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
sp	pointer
->	O
sd	int
<	O
0	int
)	O
continue	O
;	O
preq	pointer
=	O
NULL	O
;	O
req	pointer
=	O
sp	pointer
->	O
request_list	pointer
;	O
while	O
(	O
req	pointer
)	O
{	O
if	O
(	O
timercmp	function
(	O
&	O
req	pointer
->	O
expire	O
,	O
&	O
now	O
,	O
<	O
)	O
)	O
{	O
if	O
(	O
req	pointer
->	O
retries	int
>	O
sp	pointer
->	O
retries	int
)	O
{	O
sp	pointer
->	O
converse	function
(	O
SNMP_CONV_TIMEOUT	pointer
,	O
sp	pointer
,	O
req	pointer
->	O
pdu	pointer
,	O
sp	pointer
->	O
app_closure	pointer
)	O
;	O
if	O
(	O
preq	int
)	O
{	O
preq	pointer
->	O
next	pointer
=	O
req	pointer
->	O
next	pointer
;	O
snmp_request_free	function
(	O
req	pointer
)	O
;	O
req	pointer
=	O
preq	pointer
->	O
next	pointer
;	O
}	O
else	O
{	O
sp	pointer
->	O
request_list	pointer
=	O
req	pointer
->	O
next	pointer
;	O
snmp_request_free	function
(	O
req	pointer
)	O
;	O
req	pointer
=	O
sp	pointer
->	O
request_list	pointer
;	O
}	O
continue	O
;	O
}	O
else	O
{	O
req	pointer
->	O
retries	int
++	O
;	O
req	pointer
->	O
timeout	int
<<=	O
1	int
;	O
snmp_request_xmit	function
(	O
sp	pointer
,	O
req	pointer
)	O
;	O
}	O
}	O
preq	pointer
=	O
req	pointer
;	O
req	pointer
=	O
req	pointer
->	O
next	pointer
;	O
}	O
}	O
}	O
void	O
snmp_read	function
(	O
struct	O
snmp_session	struct
*	O
sess	pointer
,	O
fd_set	struct
*	O
fdset	pointer
)	O
{	O
struct	O
snmp_session	struct
*	O
sp	pointer
;	O
struct	O
snmp_request	struct
*	O
req	pointer
,	O
*	O
prev	pointer
;	O
struct	O
snmp_pdu	struct
*	O
pdu	pointer
;	O
u_char	char
packet	pointer
[	O
SNMP_PACKET_LENGTH	int
]	O
;	O
struct	O
sockaddr_in	struct
sin	pointer
;	O
int	O
salen	int
;	O
int	O
length	int
;	O
char	O
comm	array
[	O
128	int
]	O
;	O
int	O
comm_len	int
;	O
for	O
(	O
sp	pointer
=	O
sess	pointer
;	O
sp	pointer
;	O
sp	pointer
=	O
sp	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
sp	pointer
->	O
sd	int
<	O
0	int
||	O
!	O
FD_ISSET	O
(	O
sp	pointer
->	O
sd	int
,	O
fdset	pointer
)	O
)	O
continue	O
;	O
salen	int
=	O
sizeof	O
(	O
sin	int
)	O
;	O
length	int
=	O
recvfrom	function
(	O
sp	pointer
->	O
sd	pointer
,	O
(	O
char	O
*	O
)	O
packet	struct
,	O
sizeof	O
(	O
packet	struct
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sin	int
,	O
&	O
salen	int
)	O
;	O
if	O
(	O
length	int
==	O
-	O
1	int
)	O
{	O
perror	function
(	O
"recvfrom"	pointer
)	O
;	O
continue	O
;	O
}	O
pdu	struct
=	O
snmp_pdu_create	function
(	O
0	int
)	O
;	O
if	O
(	O
!	O
pdu	pointer
)	O
{	O
continue	O
;	O
}	O
pdu	pointer
->	O
peer_sin	int
=	O
sin	int
;	O
pdu	pointer
->	O
req_id	int
=	O
0	int
;	O
comm_len	int
=	O
sizeof	O
(	O
comm	pointer
)	O
-	O
1	int
;	O
if	O
(	O
snmp_decode_request	function
(	O
sp	pointer
,	O
pdu	pointer
,	O
packet	struct
,	O
length	int
,	O
comm	pointer
,	O
&	O
comm_len	pointer
)	O
)	O
{	O
snmp_pdu_free	function
(	O
pdu	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
pdu	pointer
->	O
type	enum
==	O
SNMP_PDU_RESPONSE	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
sp	pointer
->	O
community	struct
.	O
str	pointer
,	O
comm	pointer
)	O
)	O
{	O
if	O
(	O
sp	pointer
->	O
converse	pointer
(	O
SNMP_CONV_COMMUNITY_MISMATCH	pointer
,	O
sp	pointer
,	O
pdu	struct
,	O
sp	pointer
->	O
app_closure	pointer
)	O
)	O
{	O
snmp_pdu_free	function
(	O
pdu	struct
)	O
;	O
continue	O
;	O
}	O
}	O
}	O
else	O
{	O
char	O
*	O
p	pointer
=	O
snmp_alloc	function
(	O
comm_len	pointer
+	O
1	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
SNMP_SET_ERRNO	O
(	O
E_SNMP_NOMEM	int
)	O
;	O
snmp_pdu_free	function
(	O
pdu	pointer
)	O
;	O
continue	O
;	O
}	O
strcpy	function
(	O
sp	pointer
->	O
community	struct
.	O
str	pointer
,	O
comm	pointer
)	O
;	O
if	O
(	O
sp	pointer
->	O
community	struct
.	O
str	pointer
)	O
snmp_free	function
(	O
sp	pointer
->	O
community	struct
.	O
str	pointer
)	O
;	O
sp	pointer
->	O
community	struct
.	O
str	pointer
=	O
p	int
;	O
sp	pointer
->	O
community	struct
.	O
len	int
=	O
comm_len	pointer
;	O
}	O
switch	O
(	O
pdu	pointer
->	O
type	enum
)	O
{	O
case	O
SNMP_PDU_RESPONSE	O
:	O
prev	pointer
=	O
NULL	O
;	O
for	O
(	O
req	pointer
=	O
sp	pointer
->	O
request_list	pointer
;	O
req	pointer
&&	O
req	pointer
->	O
pdu	pointer
->	O
req_id	int
!=	O
pdu	pointer
->	O
req_id	int
;	O
req	pointer
=	O
req	pointer
->	O
next	pointer
)	O
prev	pointer
=	O
req	pointer
;	O
if	O
(	O
!	O
req	pointer
)	O
{	O
snmp_pdu_free	function
(	O
pdu	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
sp	pointer
->	O
converse	function
(	O
SNMP_CONV_RECV_MSG	pointer
,	O
sp	pointer
,	O
pdu	pointer
,	O
sp	pointer
->	O
app_closure	pointer
)	O
)	O
{	O
if	O
(	O
!	O
prev	pointer
)	O
sp	pointer
->	O
request_list	pointer
=	O
req	pointer
->	O
next	pointer
;	O
else	O
prev	pointer
->	O
next	pointer
=	O
req	pointer
->	O
next	pointer
;	O
snmp_request_free	function
(	O
req	pointer
)	O
;	O
}	O
break	O
;	O
case	O
SNMP_PDU_GET	O
:	O
case	O
SNMP_PDU_GETNEXT	O
:	O
case	O
SNMP_PDU_SET	O
:	O
sp	pointer
->	O
converse	function
(	O
SNMP_CONV_RECV_MSG	pointer
,	O
sp	pointer
,	O
pdu	struct
,	O
sp	pointer
->	O
app_closure	pointer
)	O
;	O
break	O
;	O
default	O
:	O
;	O
}	O
snmp_pdu_free	function
(	O
pdu	pointer
)	O
;	O
}	O
}	O
char	O
*	O
asnprintf	function
(	O
char	O
*	O
resultbuf	pointer
,	O
size_t	long
*	O
lengthp	pointer
,	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
char	O
*	O
result	pointer
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
result	pointer
=	O
vasnprintf	function
(	O
resultbuf	pointer
,	O
lengthp	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
return	O
result	pointer
;	O
}	O
struct	O
cd_buf	struct
{	O
int	O
fd	int
;	O
}	O
;	O
static	O
inline	O
void	O
cdb_init	function
(	O
struct	O
cd_buf	struct
*	O
cdb	pointer
)	O
{	O
cdb	pointer
->	O
fd	int
=	O
AT_FDCWD	O
;	O
}	O
static	O
inline	O
int	O
cdb_fchdir	function
(	O
struct	O
cd_buf	struct
const	O
*	O
cdb	pointer
)	O
{	O
return	O
fchdir	function
(	O
cdb	pointer
->	O
fd	int
)	O
;	O
}	O
static	O
inline	O
void	O
cdb_free	function
(	O
struct	O
cd_buf	struct
const	O
*	O
cdb	pointer
)	O
{	O
if	O
(	O
0	int
<=	O
cdb	pointer
->	O
fd	int
)	O
{	O
bool	bool
close_fail	bool
=	O
close	function
(	O
cdb	pointer
->	O
fd	int
)	O
;	O
assert	O
(	O
!	O
close_fail	bool
)	O
;	O
}	O
}	O
static	O
int	O
cdb_advance_fd	function
(	O
struct	O
cd_buf	struct
*	O
cdb	pointer
,	O
char	O
const	O
*	O
dir	pointer
)	O
{	O
int	O
new_fd	int
=	O
openat	function
(	O
cdb	pointer
->	O
fd	int
,	O
dir	pointer
,	O
O_SEARCH	O
|	O
O_DIRECTORY	O
|	O
O_NOCTTY	int
|	O
O_NONBLOCK	int
)	O
;	O
if	O
(	O
new_fd	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
cdb_free	function
(	O
cdb	pointer
)	O
;	O
cdb	pointer
->	O
fd	int
=	O
new_fd	int
;	O
return	O
0	int
;	O
}	O
static	O
inline	O
char	O
*	O
find_non_slash	function
(	O
char	O
const	O
*	O
s	pointer
)	O
{	O
size_t	long
n_slash	long
=	O
strspn	function
(	O
s	pointer
,	O
"/"	pointer
)	O
;	O
return	O
(	O
char	O
*	O
)	O
s	pointer
+	O
n_slash	long
;	O
}	O
int	O
chdir_long	function
(	O
char	O
*	O
dir	pointer
)	O
{	O
int	O
e	int
=	O
chdir	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
e	int
==	O
0	int
||	O
errno	O
!=	O
ENAMETOOLONG	int
)	O
return	O
e	int
;	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
dir	pointer
)	O
;	O
char	O
*	O
dir_end	pointer
=	O
dir	pointer
+	O
len	long
;	O
struct	O
cd_buf	struct
cdb	pointer
;	O
size_t	long
n_leading_slash	long
;	O
cdb_init	function
(	O
&	O
cdb	pointer
)	O
;	O
assert	O
(	O
0	int
<	O
len	long
)	O
;	O
assert	O
(	O
PATH_MAX	int
<=	O
len	long
)	O
;	O
n_leading_slash	long
=	O
strspn	function
(	O
dir	pointer
,	O
"/"	pointer
)	O
;	O
if	O
(	O
n_leading_slash	long
==	O
2	int
)	O
{	O
int	O
err	int
;	O
char	O
*	O
slash	pointer
=	O
memchr	function
(	O
dir	pointer
+	O
3	int
,	O
'/'	O
,	O
dir_end	pointer
-	O
(	O
dir	pointer
+	O
3	int
)	O
)	O
;	O
if	O
(	O
slash	pointer
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENAMETOOLONG	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
slash	pointer
=	O
'\0'	O
;	O
err	int
=	O
cdb_advance_fd	function
(	O
&	O
cdb	pointer
,	O
dir	pointer
)	O
;	O
*	O
slash	pointer
=	O
'/'	O
;	O
if	O
(	O
err	int
!=	O
0	int
)	O
goto	O
Fail	O
;	O
dir	pointer
=	O
find_non_slash	function
(	O
slash	pointer
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
n_leading_slash	long
)	O
{	O
if	O
(	O
cdb_advance_fd	function
(	O
&	O
cdb	pointer
,	O
"/"	pointer
)	O
!=	O
0	int
)	O
goto	O
Fail	O
;	O
dir	pointer
+=	O
n_leading_slash	long
;	O
}	O
assert	O
(	O
*	O
dir	pointer
!=	O
'/'	O
)	O
;	O
assert	O
(	O
dir	pointer
<=	O
dir_end	pointer
)	O
;	O
while	O
(	O
PATH_MAX	int
<=	O
dir_end	pointer
-	O
dir	pointer
)	O
{	O
int	O
err	int
;	O
char	O
*	O
slash	pointer
=	O
memrchr	function
(	O
dir	pointer
,	O
'/'	O
,	O
PATH_MAX	int
)	O
;	O
if	O
(	O
slash	pointer
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENAMETOOLONG	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
slash	pointer
=	O
'\0'	O
;	O
assert	O
(	O
slash	pointer
-	O
dir	pointer
<	O
PATH_MAX	int
)	O
;	O
err	int
=	O
cdb_advance_fd	function
(	O
&	O
cdb	pointer
,	O
dir	pointer
)	O
;	O
*	O
slash	pointer
=	O
'/'	O
;	O
if	O
(	O
err	int
!=	O
0	int
)	O
goto	O
Fail	O
;	O
dir	pointer
=	O
find_non_slash	function
(	O
slash	pointer
+	O
1	int
)	O
;	O
}	O
if	O
(	O
dir	pointer
<	O
dir_end	pointer
)	O
{	O
if	O
(	O
cdb_advance_fd	function
(	O
&	O
cdb	pointer
,	O
dir	pointer
)	O
!=	O
0	int
)	O
goto	O
Fail	O
;	O
}	O
if	O
(	O
cdb_fchdir	function
(	O
&	O
cdb	pointer
)	O
!=	O
0	int
)	O
goto	O
Fail	O
;	O
cdb_free	function
(	O
&	O
cdb	pointer
)	O
;	O
return	O
0	int
;	O
Fail	O
:	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
cdb_free	function
(	O
&	O
cdb	pointer
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
char	O
*	O
concatenated_filename	function
(	O
const	O
char	O
*	O
directory	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
suffix	pointer
)	O
{	O
char	O
*	O
result	pointer
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
strcmp	function
(	O
directory	pointer
,	O
"."	pointer
)	O
==	O
0	int
)	O
{	O
result	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
filename	pointer
)	O
+	O
(	O
suffix	pointer
!=	O
NULL	O
?	O
strlen	function
(	O
suffix	pointer
)	O
:	O
0	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
result	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
p	O
=	O
result	O
;	O
}	O
else	O
{	O
size_t	long
directory_len	long
=	O
strlen	function
(	O
directory	pointer
)	O
;	O
int	O
need_slash	int
=	O
(	O
directory_len	long
>	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
directory	pointer
)	O
&&	O
!	O
ISSLASH	O
(	O
directory	pointer
[	O
directory_len	long
-	O
1	int
]	O
)	O
)	O
;	O
result	O
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
directory_len	long
+	O
need_slash	int
+	O
strlen	function
(	O
filename	pointer
)	O
+	O
(	O
suffix	pointer
!=	O
NULL	O
?	O
strlen	function
(	O
suffix	pointer
)	O
:	O
0	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
result	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
result	pointer
,	O
directory	pointer
,	O
directory_len	long
)	O
;	O
p	pointer
=	O
result	O
+	O
directory_len	long
;	O
if	O
(	O
need_slash	O
)	O
*	O
p	pointer
++	O
=	O
'/'	O
;	O
}	O
p	pointer
=	O
stpcpy	function
(	O
p	O
,	O
filename	pointer
)	O
;	O
if	O
(	O
suffix	pointer
!=	O
NULL	O
)	O
stpcpy	function
(	O
p	O
,	O
suffix	O
)	O
;	O
return	O
result	O
;	O
}	O
size_t	long
dir_len	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
prefix_length	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
;	O
size_t	long
length	long
;	O
prefix_length	long
+=	O
(	O
prefix_length	long
!=	O
0	int
?	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
prefix_length	long
]	O
)	O
)	O
:	O
(	O
ISSLASH	O
(	O
file	pointer
[	O
0	int
]	O
)	O
?	O
(	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
?	O
2	int
:	O
1	int
)	O
)	O
:	O
0	int
)	O
)	O
;	O
for	O
(	O
length	long
=	O
last_component	function
(	O
file	pointer
)	O
-	O
file	pointer
;	O
prefix_length	long
<	O
length	long
;	O
length	long
--	O
)	O
if	O
(	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
length	long
-	O
1	int
]	O
)	O
)	O
break	O
;	O
return	O
length	long
;	O
}	O
char	O
*	O
mdir_name	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
length	long
=	O
dir_len	function
(	O
file	pointer
)	O
;	O
bool	bool
append_dot	bool
=	O
(	O
length	long
==	O
0	int
||	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
length	long
==	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
&&	O
file	pointer
[	O
2	int
]	O
!=	O
'\0'	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
)	O
)	O
;	O
char	O
*	O
dir	pointer
=	O
malloc	function
(	O
length	long
+	O
append_dot	bool
+	O
1	int
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
dir	pointer
,	O
file	pointer
,	O
length	long
)	O
;	O
if	O
(	O
append_dot	bool
)	O
dir	pointer
[	O
length	long
++	O
]	O
=	O
'.'	O
;	O
dir	pointer
[	O
length	long
]	O
=	O
'\0'	O
;	O
return	O
dir	pointer
;	O
}	O
int	O
dup_safer	function
(	O
int	O
fd	int
)	O
{	O
return	O
fcntl	function
(	O
fd	int
,	O
F_DUPFD	int
,	O
STDERR_FILENO	int
+	O
1	int
)	O
;	O
}	O
void	O
display_version	function
(	O
struct	O
program	struct
const	O
*	O
prog	pointer
)	O
{	O
printf	function
(	O
"%s%s"	pointer
,	O
prog	pointer
->	O
name	pointer
,	O
COMMAND_VERSION	pointer
)	O
;	O
}	O
void	O
check_hv	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
struct	O
program	struct
const	O
*	O
prog	pointer
)	O
{	O
if	O
(	O
1	int
>=	O
argc	int
)	O
return	O
;	O
if	O
(	O
EXACTLY	function
(	O
"--help"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
)	O
{	O
printf	function
(	O
"Usage: %s %s%s"	pointer
,	O
prog	pointer
->	O
name	pointer
,	O
prog	pointer
->	O
help	pointer
,	O
BUGME	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
EXACTLY	function
(	O
"--version"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
)	O
{	O
display_version	function
(	O
prog	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
}	O
enum	O
tokens	enum
const	O
ctab	array
[	O
]	O
=	O
{	O
UNKN	O
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
SPACE	int
,	O
SPACE	int
,	O
NEWLN	int
,	O
SPACE	int
,	O
SPACE	int
,	O
SPACE	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
SPACE	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
DELIM	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
DELIM	int
,	O
IDCHAR	int
,	O
PERIOD	int
,	O
IDCHAR	int
,	O
DIGIT	int
,	O
DIGIT	int
,	O
DIGIT	int
,	O
DIGIT	int
,	O
DIGIT	int
,	O
DIGIT	int
,	O
DIGIT	int
,	O
DIGIT	int
,	O
DIGIT	int
,	O
DIGIT	int
,	O
COLON	int
,	O
SEMI	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
SBEGIN	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
UNKN	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
IDCHAR	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
IDCHAR	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
LETTER	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
IDCHAR	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
,	O
Letter	int
}	O
;	O
static	O
char	O
const	O
*	O
checkidentifier	function
(	O
char	O
const	O
*	O
id	pointer
,	O
int	O
delimiter	int
,	O
register	O
bool	bool
dotok	bool
)	O
{	O
register	O
char	O
const	O
*	O
temp	pointer
;	O
register	O
char	O
c	int
;	O
register	O
char	O
delim	int
=	O
delimiter	int
;	O
bool	bool
isid	bool
=	O
false	int
;	O
temp	enum
=	O
id	int
;	O
for	O
(	O
;	O
;	O
id	int
++	O
)	O
{	O
switch	O
(	O
ctab	array
[	O
(	O
unsigned	O
char	O
)	O
(	O
c	int
=	O
*	O
id	int
)	O
]	O
)	O
{	O
case	O
DIGIT	int
:	O
case	O
IDCHAR	int
:	O
case	O
LETTER	int
:	O
case	O
Letter	int
:	O
isid	enum
=	O
true	int
;	O
continue	O
;	O
case	O
PERIOD	int
:	O
if	O
(	O
dotok	int
)	O
continue	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
!	O
isid	int
||	O
(	O
c	int
&&	O
(	O
!	O
delim	int
||	O
(	O
c	int
!=	O
delim	int
&&	O
c	int
!=	O
' '	O
&&	O
c	int
!=	O
'\t'	O
&&	O
c	int
!=	O
'\n'	O
)	O
)	O
)	O
)	O
{	O
while	O
(	O
(	O
c	int
=	O
*	O
id	int
)	O
&&	O
c	int
!=	O
' '	O
&&	O
c	int
!=	O
'\t'	O
&&	O
c	int
!=	O
'\n'	O
&&	O
c	int
!=	O
delim	int
)	O
id	int
++	O
;	O
PFATAL	O
(	O
"invalid %s `%.*s'"	pointer
,	O
dotok	int
?	O
"identifier"	int
:	O
"symbol"	int
,	O
(	O
int	O
)	O
(	O
id	int
-	O
temp	int
)	O
,	O
temp	pointer
)	O
;	O
}	O
return	O
id	int
;	O
}	O
char	O
const	O
*	O
checkid	function
(	O
char	O
const	O
*	O
id	pointer
,	O
int	O
delimiter	int
)	O
{	O
return	O
checkidentifier	function
(	O
id	int
,	O
delimiter	int
,	O
true	int
)	O
;	O
}	O
char	O
const	O
*	O
checksym	function
(	O
char	O
const	O
*	O
sym	pointer
,	O
int	O
delimiter	int
)	O
{	O
return	O
checkidentifier	function
(	O
sym	pointer
,	O
delimiter	int
,	O
false	int
)	O
;	O
}	O
void	O
checksid	function
(	O
char	O
const	O
*	O
id	int
)	O
{	O
checkid	function
(	O
id	int
,	O
0	int
)	O
;	O
}	O
void	O
checkssym	function
(	O
char	O
const	O
*	O
sym	pointer
)	O
{	O
checksym	function
(	O
sym	pointer
,	O
0	int
)	O
;	O
}	O
static	O
bool	bool
is_colored	bool
(	O
enum	O
indicator_no	enum
type	enum
)	O
;	O
static	O
void	O
restore_default_color	function
(	O
void	O
)	O
;	O
COLOR_EXT_TYPE	struct
*	O
_rl_color_ext_list	pointer
=	O
0	int
;	O
void	O
_rl_put_indicator	function
(	O
const	O
struct	O
bin_str	struct
*	O
ind	O
)	O
{	O
fwrite	function
(	O
ind	pointer
->	O
string	pointer
,	O
ind	pointer
->	O
len	int
,	O
1	int
,	O
rl_outstream	int
)	O
;	O
}	O
static	O
bool	bool
is_colored	function
(	O
enum	O
indicator_no	enum
colored_filetype	enum
)	O
{	O
size_t	long
len	long
=	O
_rl_color_indicator	array
[	O
colored_filetype	int
]	O
.	O
len	long
;	O
char	O
const	O
*	O
s	pointer
=	O
_rl_color_indicator	array
[	O
colored_filetype	int
]	O
.	O
string	pointer
;	O
return	O
!	O
(	O
len	int
==	O
0	int
||	O
(	O
len	long
==	O
1	int
&&	O
strncmp	function
(	O
s	pointer
,	O
"0"	pointer
,	O
1	int
)	O
==	O
0	int
)	O
||	O
(	O
len	long
==	O
2	int
&&	O
strncmp	function
(	O
s	pointer
,	O
"00"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
)	O
;	O
}	O
static	O
void	O
restore_default_color	function
(	O
void	O
)	O
{	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_LEFT	int
]	O
)	O
;	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_RIGHT	int
]	O
)	O
;	O
}	O
void	O
_rl_set_normal_color	function
(	O
void	O
)	O
{	O
if	O
(	O
is_colored	function
(	O
C_NORM	int
)	O
)	O
{	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_LEFT	int
]	O
)	O
;	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_NORM	int
]	O
)	O
;	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_RIGHT	int
]	O
)	O
;	O
}	O
}	O
bool	bool
_rl_print_prefix_color	function
(	O
void	O
)	O
{	O
struct	O
bin_str	struct
*	O
s	pointer
;	O
s	pointer
=	O
&	O
_rl_color_indicator	array
[	O
C_PREFIX	int
]	O
;	O
if	O
(	O
s	pointer
->	O
string	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
is_colored	function
(	O
C_NORM	pointer
)	O
)	O
restore_default_color	function
(	O
)	O
;	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_LEFT	int
]	O
)	O
;	O
_rl_put_indicator	function
(	O
s	pointer
)	O
;	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_RIGHT	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
return	O
1	int
;	O
}	O
bool	bool
_rl_print_color_indicator	function
(	O
const	O
char	O
*	O
f	pointer
)	O
{	O
enum	O
indicator_no	enum
colored_filetype	enum
;	O
COLOR_EXT_TYPE	struct
*	O
ext	array
;	O
size_t	long
len	long
;	O
const	O
char	O
*	O
name	pointer
;	O
char	O
*	O
filename	pointer
;	O
struct	O
stat	struct
astat	struct
,	O
linkstat	int
;	O
mode_t	int
mode	int
;	O
int	O
linkok	int
;	O
int	O
stat_ok	int
;	O
name	pointer
=	O
f	pointer
;	O
filename	pointer
=	O
0	int
;	O
if	O
(	O
rl_filename_stat_hook	int
)	O
{	O
filename	pointer
=	O
savestring	O
(	O
f	pointer
)	O
;	O
(	O
*	O
rl_filename_stat_hook	pointer
)	O
(	O
&	O
filename	pointer
)	O
;	O
name	pointer
=	O
filename	pointer
;	O
}	O
stat_ok	int
=	O
lstat	function
(	O
name	pointer
,	O
&	O
astat	struct
)	O
;	O
if	O
(	O
stat_ok	int
==	O
0	int
)	O
{	O
mode	int
=	O
astat	struct
.	O
st_mode	int
;	O
if	O
(	O
S_ISLNK	O
(	O
mode	int
)	O
)	O
{	O
linkok	int
=	O
stat	struct
(	O
name	pointer
,	O
&	O
linkstat	struct
)	O
==	O
0	int
;	O
if	O
(	O
linkok	int
&&	O
strncmp	function
(	O
_rl_color_indicator	array
[	O
C_LINK	int
]	O
.	O
string	pointer
,	O
"target"	pointer
,	O
6	int
)	O
==	O
0	int
)	O
mode	int
=	O
linkstat	struct
.	O
st_mode	int
;	O
}	O
else	O
linkok	int
=	O
1	int
;	O
}	O
else	O
linkok	int
=	O
-	O
1	int
;	O
if	O
(	O
linkok	int
==	O
-	O
1	int
&&	O
_rl_color_indicator	array
[	O
C_MISSING	int
]	O
.	O
string	pointer
!=	O
NULL	O
)	O
colored_filetype	int
=	O
C_MISSING	int
;	O
else	O
if	O
(	O
linkok	int
==	O
0	int
&&	O
S_ISLNK	O
(	O
mode	int
)	O
&&	O
_rl_color_indicator	array
[	O
C_ORPHAN	int
]	O
.	O
string	pointer
!=	O
NULL	O
)	O
colored_filetype	int
=	O
C_ORPHAN	int
;	O
else	O
if	O
(	O
stat_ok	int
!=	O
0	int
)	O
{	O
static	O
enum	O
indicator_no	enum
filetype_indicator	array
[	O
]	O
=	O
FILETYPE_INDICATORS	int
;	O
colored_filetype	int
=	O
filetype_indicator	array
[	O
normal	int
]	O
;	O
}	O
else	O
{	O
if	O
(	O
S_ISREG	O
(	O
mode	int
)	O
)	O
{	O
colored_filetype	int
=	O
C_FILE	int
;	O
if	O
(	O
(	O
mode	int
&	O
S_ISUID	O
)	O
!=	O
0	int
&&	O
is_colored	function
(	O
C_SETUID	int
)	O
)	O
colored_filetype	int
=	O
C_SETUID	int
;	O
else	O
if	O
(	O
(	O
mode	int
&	O
S_ISGID	O
)	O
!=	O
0	int
&&	O
is_colored	function
(	O
C_SETGID	int
)	O
)	O
colored_filetype	int
=	O
C_SETGID	int
;	O
else	O
if	O
(	O
is_colored	function
(	O
C_CAP	pointer
)	O
&&	O
0	int
)	O
colored_filetype	int
=	O
C_CAP	int
;	O
else	O
if	O
(	O
(	O
mode	int
&	O
S_IXUGO	int
)	O
!=	O
0	int
&&	O
is_colored	function
(	O
C_EXEC	int
)	O
)	O
colored_filetype	int
=	O
C_EXEC	int
;	O
else	O
if	O
(	O
(	O
1	int
<	O
astat	struct
.	O
st_nlink	long
)	O
&&	O
is_colored	function
(	O
C_MULTIHARDLINK	int
)	O
)	O
colored_filetype	int
=	O
C_MULTIHARDLINK	int
;	O
}	O
else	O
if	O
(	O
S_ISDIR	O
(	O
mode	int
)	O
)	O
{	O
colored_filetype	int
=	O
C_DIR	int
;	O
if	O
(	O
(	O
mode	int
&	O
S_ISVTX	O
)	O
&&	O
(	O
mode	int
&	O
S_IWOTH	O
)	O
&&	O
is_colored	function
(	O
C_STICKY_OTHER_WRITABLE	int
)	O
)	O
colored_filetype	int
=	O
C_STICKY_OTHER_WRITABLE	int
;	O
else	O
if	O
(	O
(	O
mode	int
&	O
S_IWOTH	O
)	O
!=	O
0	int
&&	O
is_colored	function
(	O
C_OTHER_WRITABLE	int
)	O
)	O
colored_filetype	int
=	O
C_OTHER_WRITABLE	int
;	O
else	O
if	O
(	O
(	O
mode	int
&	O
S_ISVTX	O
)	O
!=	O
0	int
&&	O
is_colored	function
(	O
C_STICKY	int
)	O
)	O
colored_filetype	int
=	O
C_STICKY	int
;	O
}	O
else	O
if	O
(	O
S_ISLNK	O
(	O
mode	int
)	O
)	O
colored_filetype	int
=	O
C_LINK	int
;	O
else	O
if	O
(	O
S_ISFIFO	O
(	O
mode	int
)	O
)	O
colored_filetype	int
=	O
C_FIFO	int
;	O
else	O
if	O
(	O
S_ISSOCK	O
(	O
mode	int
)	O
)	O
colored_filetype	int
=	O
C_SOCK	int
;	O
else	O
if	O
(	O
S_ISBLK	O
(	O
mode	int
)	O
)	O
colored_filetype	int
=	O
C_BLK	int
;	O
else	O
if	O
(	O
S_ISCHR	O
(	O
mode	int
)	O
)	O
colored_filetype	int
=	O
C_CHR	int
;	O
else	O
{	O
colored_filetype	int
=	O
C_ORPHAN	int
;	O
}	O
}	O
ext	array
=	O
NULL	O
;	O
if	O
(	O
colored_filetype	int
==	O
C_FILE	int
)	O
{	O
len	int
=	O
strlen	function
(	O
name	pointer
)	O
;	O
name	pointer
+=	O
len	int
;	O
for	O
(	O
ext	array
=	O
_rl_color_ext_list	pointer
;	O
ext	array
!=	O
NULL	O
;	O
ext	array
=	O
ext	array
->	O
next	pointer
)	O
{	O
if	O
(	O
ext	array
->	O
ext	struct
.	O
len	int
<=	O
len	int
&&	O
strncmp	function
(	O
name	pointer
-	O
ext	array
->	O
ext	struct
.	O
len	int
,	O
ext	array
->	O
ext	struct
.	O
string	pointer
,	O
ext	array
->	O
ext	struct
.	O
len	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
}	O
free	function
(	O
filename	pointer
)	O
;	O
{	O
const	O
struct	O
bin_str	struct
*	O
const	O
s	pointer
=	O
ext	array
?	O
&	O
(	O
ext	array
->	O
seq	pointer
)	O
:	O
&	O
_rl_color_indicator	array
[	O
colored_filetype	int
]	O
;	O
if	O
(	O
s	pointer
->	O
string	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
is_colored	function
(	O
C_NORM	pointer
)	O
)	O
restore_default_color	function
(	O
)	O
;	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_LEFT	int
]	O
)	O
;	O
_rl_put_indicator	function
(	O
s	pointer
)	O
;	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_RIGHT	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
return	O
1	int
;	O
}	O
}	O
void	O
_rl_prep_non_filename_text	function
(	O
void	O
)	O
{	O
if	O
(	O
_rl_color_indicator	array
[	O
C_END	int
]	O
.	O
string	pointer
!=	O
NULL	O
)	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_END	int
]	O
)	O
;	O
else	O
{	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_LEFT	int
]	O
)	O
;	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_RESET	int
]	O
)	O
;	O
_rl_put_indicator	function
(	O
&	O
_rl_color_indicator	array
[	O
C_RIGHT	int
]	O
)	O
;	O
}	O
}	O
main	function
(	O
argc	int
,	O
argv	array
)	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
{	O
char	O
line	array
[	O
1024	int
]	O
,	O
*	O
t	pointer
;	O
int	O
len	int
,	O
done	int
;	O
line	pointer
[	O
0	int
]	O
=	O
0	int
;	O
done	int
=	O
0	int
;	O
using_history	function
(	O
)	O
;	O
while	O
(	O
!	O
done	int
)	O
{	O
printf	function
(	O
"history$ "	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
t	int
=	O
fgets	function
(	O
line	array
,	O
sizeof	O
(	O
line	array
)	O
-	O
1	int
,	O
stdin	pointer
)	O
;	O
if	O
(	O
t	int
&&	O
*	O
t	int
)	O
{	O
len	int
=	O
strlen	function
(	O
t	int
)	O
;	O
if	O
(	O
t	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
t	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
!	O
t	int
)	O
strcpy	function
(	O
line	array
,	O
"quit"	pointer
)	O
;	O
if	O
(	O
line	array
[	O
0	int
]	O
)	O
{	O
char	O
*	O
expansion	pointer
;	O
int	O
result	int
;	O
using_history	function
(	O
)	O
;	O
result	int
=	O
history_expand	function
(	O
line	int
,	O
&	O
expansion	int
)	O
;	O
if	O
(	O
result	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
expansion	pointer
)	O
;	O
if	O
(	O
result	int
<	O
0	int
||	O
result	int
==	O
2	int
)	O
{	O
free	function
(	O
expansion	pointer
)	O
;	O
continue	O
;	O
}	O
add_history	function
(	O
expansion	pointer
)	O
;	O
strncpy	function
(	O
line	array
,	O
expansion	pointer
,	O
sizeof	O
(	O
line	array
)	O
-	O
1	int
)	O
;	O
free	function
(	O
expansion	pointer
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
line	pointer
,	O
"quit"	pointer
)	O
==	O
0	int
)	O
done	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
line	pointer
,	O
"save"	pointer
)	O
==	O
0	int
)	O
write_history	function
(	O
"history_file"	pointer
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
line	pointer
,	O
"read"	pointer
)	O
==	O
0	int
)	O
read_history	function
(	O
"history_file"	pointer
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
line	pointer
,	O
"list"	pointer
)	O
==	O
0	int
)	O
{	O
register	O
HIST_ENTRY	struct
*	O
*	O
the_list	pointer
;	O
register	O
int	O
i	int
;	O
time_t	O
tt	int
;	O
char	O
timestr	array
[	O
128	int
]	O
;	O
the_list	pointer
=	O
history_list	function
(	O
)	O
;	O
if	O
(	O
the_list	pointer
)	O
for	O
(	O
i	int
=	O
0	int
;	O
the_list	array
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
tt	int
=	O
history_get_time	function
(	O
the_list	array
[	O
i	int
]	O
)	O
;	O
if	O
(	O
tt	int
)	O
strftime	function
(	O
timestr	pointer
,	O
sizeof	O
(	O
timestr	pointer
)	O
,	O
"%a %R"	pointer
,	O
localtime	function
(	O
&	O
tt	int
)	O
)	O
;	O
else	O
strcpy	function
(	O
timestr	pointer
,	O
"??"	pointer
)	O
;	O
printf	function
(	O
"%d: %s: %s\n"	pointer
,	O
i	int
+	O
history_base	int
,	O
timestr	pointer
,	O
the_list	array
[	O
i	int
]	O
->	O
line	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
strncmp	function
(	O
line	pointer
,	O
"delete"	pointer
,	O
6	int
)	O
==	O
0	int
)	O
{	O
int	O
which	int
;	O
if	O
(	O
(	O
sscanf	function
(	O
line	pointer
+	O
6	int
,	O
"%d"	pointer
,	O
&	O
which	int
)	O
)	O
==	O
1	int
)	O
{	O
HIST_ENTRY	struct
*	O
entry	pointer
=	O
remove_history	function
(	O
which	pointer
)	O
;	O
if	O
(	O
!	O
entry	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"No such entry %d\n"	pointer
,	O
which	pointer
)	O
;	O
else	O
{	O
free	function
(	O
entry	pointer
->	O
line	pointer
)	O
;	O
free	function
(	O
entry	pointer
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"non-numeric arg given to `delete'\n"	pointer
)	O
;	O
}	O
}	O
}	O
}	O
int	O
_rl_allow_pathname_alphabetic_chars	int
=	O
0	int
;	O
static	O
const	O
char	O
*	O
const	O
pathname_alphabetic_chars	pointer
=	O
"/-_=~.#$"	pointer
;	O
int	O
rl_alphabetic	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
ALPHABETIC	function
(	O
c	int
)	O
)	O
return	O
(	O
1	int
)	O
;	O
return	O
(	O
_rl_allow_pathname_alphabetic_chars	pointer
&&	O
strchr	function
(	O
pathname_alphabetic_chars	pointer
,	O
c	int
)	O
!=	O
NULL	O
)	O
;	O
}	O
int	O
_rl_walphabetic	function
(	O
wchar_t	int
wc	int
)	O
{	O
int	O
c	int
;	O
if	O
(	O
iswalnum	function
(	O
wc	int
)	O
)	O
return	O
(	O
1	int
)	O
;	O
c	int
=	O
wc	int
&	O
0177	int
;	O
return	O
(	O
_rl_allow_pathname_alphabetic_chars	pointer
&&	O
strchr	function
(	O
pathname_alphabetic_chars	pointer
,	O
c	int
)	O
!=	O
NULL	O
)	O
;	O
}	O
int	O
_rl_abort_internal	function
(	O
)	O
{	O
rl_ding	function
(	O
)	O
;	O
rl_clear_message	function
(	O
)	O
;	O
_rl_reset_argument	function
(	O
)	O
;	O
rl_clear_pending_input	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MACRODEF	pointer
)	O
;	O
while	O
(	O
rl_executing_macro	pointer
)	O
_rl_pop_executing_macro	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MULTIKEY	int
)	O
;	O
rl_last_func	pointer
=	O
(	O
rl_command_func_t	function
*	O
)	O
NULL	O
;	O
_rl_longjmp	function
(	O
_rl_top_level	int
,	O
1	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_abort	function
(	O
count	int
,	O
key	pointer
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
_rl_abort_internal	function
(	O
)	O
)	O
;	O
}	O
int	O
_rl_null_function	function
(	O
count	int
,	O
key	pointer
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
0	int
;	O
}	O
int	O
rl_tty_status	function
(	O
count	int
,	O
key	pointer
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
rl_copy_text	function
(	O
from	pointer
,	O
to	pointer
)	O
int	O
from	pointer
,	O
to	O
;	O
{	O
register	O
int	O
length	int
;	O
char	O
*	O
copy	pointer
;	O
if	O
(	O
from	pointer
>	O
to	O
)	O
SWAP	O
(	O
from	pointer
,	O
to	O
)	O
;	O
length	int
=	O
to	pointer
-	O
from	pointer
;	O
copy	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
+	O
length	int
)	O
;	O
strncpy	function
(	O
copy	O
,	O
rl_line_buffer	pointer
+	O
from	pointer
,	O
length	int
)	O
;	O
copy	pointer
[	O
length	int
]	O
=	O
'\0'	O
;	O
return	O
(	O
copy	O
)	O
;	O
}	O
void	O
rl_extend_line_buffer	function
(	O
len	int
)	O
int	O
len	int
;	O
{	O
while	O
(	O
len	int
>=	O
rl_line_buffer_len	int
)	O
{	O
rl_line_buffer_len	int
+=	O
DEFAULT_BUFFER_SIZE	int
;	O
rl_line_buffer	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
rl_line_buffer	pointer
,	O
rl_line_buffer_len	pointer
)	O
;	O
}	O
_rl_set_the_line	function
(	O
)	O
;	O
}	O
int	O
rl_tilde_expand	function
(	O
ignore	pointer
,	O
key	pointer
)	O
int	O
ignore	int
,	O
key	int
;	O
{	O
register	O
int	O
start	int
,	O
end	int
;	O
char	O
*	O
homedir	pointer
,	O
*	O
temp	pointer
;	O
int	O
len	int
;	O
end	int
=	O
rl_point	int
;	O
start	int
=	O
end	int
-	O
1	int
;	O
if	O
(	O
rl_point	int
==	O
rl_end	int
&&	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
==	O
'~'	O
)	O
{	O
homedir	pointer
=	O
tilde_expand	function
(	O
"~"	pointer
)	O
;	O
_rl_replace_text	function
(	O
homedir	pointer
,	O
start	int
,	O
end	int
)	O
;	O
xfree	function
(	O
homedir	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
start	int
>=	O
0	int
&&	O
rl_line_buffer	pointer
[	O
start	int
]	O
!=	O
'~'	O
)	O
{	O
for	O
(	O
;	O
!	O
whitespace	function
(	O
rl_line_buffer	pointer
[	O
start	int
]	O
)	O
&&	O
start	int
>=	O
0	int
;	O
start	int
--	O
)	O
;	O
start	int
++	O
;	O
}	O
else	O
if	O
(	O
start	int
<	O
0	int
)	O
start	int
=	O
0	int
;	O
end	int
=	O
start	int
;	O
do	O
end	int
++	O
;	O
while	O
(	O
whitespace	function
(	O
rl_line_buffer	pointer
[	O
end	int
]	O
)	O
==	O
0	int
&&	O
end	int
<	O
rl_end	int
)	O
;	O
if	O
(	O
whitespace	function
(	O
rl_line_buffer	pointer
[	O
end	int
]	O
)	O
||	O
end	int
>=	O
rl_end	int
)	O
end	int
--	O
;	O
if	O
(	O
rl_line_buffer	pointer
[	O
start	int
]	O
==	O
'~'	O
)	O
{	O
len	int
=	O
end	int
-	O
start	pointer
+	O
1	int
;	O
temp	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	int
+	O
1	int
)	O
;	O
strncpy	function
(	O
temp	pointer
,	O
rl_line_buffer	pointer
+	O
start	int
,	O
len	int
)	O
;	O
temp	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
homedir	pointer
=	O
tilde_expand	function
(	O
temp	pointer
)	O
;	O
xfree	function
(	O
temp	pointer
)	O
;	O
_rl_replace_text	function
(	O
homedir	pointer
,	O
start	int
,	O
end	int
)	O
;	O
xfree	function
(	O
homedir	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
_rl_ttymsg	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"readline: "	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
rl_forced_update_display	function
(	O
)	O
;	O
}	O
void	O
_rl_errmsg	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"readline: "	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
}	O
char	O
*	O
_rl_strindex	function
(	O
s1	pointer
,	O
s2	pointer
)	O
register	O
const	O
char	O
*	O
s1	pointer
,	O
*	O
s2	pointer
;	O
{	O
register	O
int	O
i	int
,	O
l	int
,	O
len	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
l	int
=	O
strlen	function
(	O
s2	pointer
)	O
,	O
len	int
=	O
strlen	function
(	O
s1	pointer
)	O
;	O
(	O
len	int
-	O
i	int
)	O
>=	O
l	int
;	O
i	int
++	O
)	O
if	O
(	O
_rl_strnicmp	function
(	O
s1	pointer
+	O
i	int
,	O
s2	int
,	O
l	int
)	O
==	O
0	int
)	O
return	O
(	O
(	O
char	O
*	O
)	O
(	O
s1	pointer
+	O
i	int
)	O
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
int	O
_rl_qsort_string_compare	function
(	O
s1	pointer
,	O
s2	pointer
)	O
char	O
*	O
*	O
s1	pointer
,	O
*	O
*	O
s2	pointer
;	O
{	O
return	O
(	O
strcoll	function
(	O
*	O
s1	pointer
,	O
*	O
s2	pointer
)	O
)	O
;	O
}	O
FUNCTION_FOR_MACRO	function
(	O
_rl_digit_p	pointer
)	O
FUNCTION_FOR_MACRO	function
(	O
_rl_digit_value	pointer
)	O
FUNCTION_FOR_MACRO	function
(	O
_rl_lowercase_p	pointer
)	O
FUNCTION_FOR_MACRO	function
(	O
_rl_pure_alphabetic	pointer
)	O
FUNCTION_FOR_MACRO	function
(	O
_rl_to_lower	pointer
)	O
FUNCTION_FOR_MACRO	function
(	O
_rl_to_upper	pointer
)	O
FUNCTION_FOR_MACRO	function
(	O
_rl_uppercase_p	pointer
)	O
void	O
rl_free	function
(	O
mem	pointer
)	O
void	O
*	O
mem	pointer
;	O
{	O
if	O
(	O
mem	pointer
)	O
free	function
(	O
mem	pointer
)	O
;	O
}	O
char	O
*	O
_rl_savestring	function
(	O
s	pointer
)	O
const	O
char	O
*	O
s	pointer
;	O
{	O
return	O
(	O
strcpy	function
(	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
1	int
+	O
(	O
int	O
)	O
strlen	function
(	O
s	pointer
)	O
)	O
,	O
(	O
s	pointer
)	O
)	O
)	O
;	O
}	O
void	O
free_permission_context	function
(	O
struct	O
permission_context	struct
*	O
ctx	pointer
)	O
{	O
}	O
char	O
*	O
asnprintf	function
(	O
char	O
*	O
resultbuf	pointer
,	O
size_t	long
*	O
lengthp	pointer
,	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
char	O
*	O
result	pointer
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
result	pointer
=	O
vasnprintf	function
(	O
resultbuf	pointer
,	O
lengthp	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
return	O
result	pointer
;	O
}	O
int	O
asprintf	function
(	O
char	O
*	O
*	O
resultp	pointer
,	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
int	O
result	pointer
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
result	pointer
=	O
vasprintf	function
(	O
resultp	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
return	O
result	pointer
;	O
}	O
int	O
close_stream	function
(	O
FILE	struct
*	O
stream	pointer
)	O
{	O
const	O
bool	bool
some_pending	bool
=	O
(	O
__fpending	function
(	O
stream	pointer
)	O
!=	O
0	int
)	O
;	O
const	O
bool	bool
prev_fail	bool
=	O
(	O
ferror	function
(	O
stream	pointer
)	O
!=	O
0	int
)	O
;	O
const	O
bool	bool
fclose_fail	bool
=	O
(	O
fclose	function
(	O
stream	pointer
)	O
!=	O
0	int
)	O
;	O
if	O
(	O
prev_fail	bool
||	O
(	O
fclose_fail	bool
&&	O
(	O
some_pending	bool
||	O
errno	O
!=	O
EBADF	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
fclose_fail	bool
)	O
errno	O
=	O
0	int
;	O
return	O
EOF	O
;	O
}	O
return	O
0	int
;	O
}	O
enum	O
{	O
SANITIZE_ADDRESS	enum
=	O
false	int
}	O
;	O
static	O
const	O
char	O
*	O
file_name	pointer
;	O
void	O
close_stdout_set_file_name	function
(	O
const	O
char	O
*	O
file	pointer
)	O
{	O
file_name	pointer
=	O
file	pointer
;	O
}	O
static	O
bool	bool
ignore_EPIPE	bool
;	O
void	O
close_stdout_set_ignore_EPIPE	function
(	O
bool	bool
ignore	bool
)	O
{	O
ignore_EPIPE	bool
=	O
ignore	bool
;	O
}	O
void	O
close_stdout	function
(	O
void	O
)	O
{	O
if	O
(	O
close_stream	function
(	O
stdout	pointer
)	O
!=	O
0	int
&&	O
!	O
(	O
ignore_EPIPE	bool
&&	O
errno	O
==	O
EPIPE	int
)	O
)	O
{	O
char	O
const	O
*	O
write_error	pointer
=	O
_	O
(	O
"write error"	pointer
)	O
;	O
if	O
(	O
file_name	pointer
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s: %s"	pointer
,	O
quotearg_colon	function
(	O
file_name	pointer
)	O
,	O
write_error	pointer
)	O
;	O
else	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
write_error	pointer
)	O
;	O
_exit	function
(	O
exit_failure	int
)	O
;	O
}	O
if	O
(	O
!	O
SANITIZE_ADDRESS	pointer
&&	O
close_stream	function
(	O
stderr	pointer
)	O
!=	O
0	int
)	O
_exit	function
(	O
exit_failure	int
)	O
;	O
}	O
int	O
copy_acl	function
(	O
const	O
char	O
*	O
src_name	pointer
,	O
int	O
source_desc	int
,	O
const	O
char	O
*	O
dst_name	pointer
,	O
int	O
dest_desc	int
,	O
mode_t	int
mode	int
)	O
{	O
int	O
ret	int
=	O
qcopy_acl	function
(	O
src_name	pointer
,	O
source_desc	int
,	O
dst_name	pointer
,	O
dest_desc	int
,	O
mode	int
)	O
;	O
switch	O
(	O
ret	int
)	O
{	O
case	O
-	O
2	int
:	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
quote	function
(	O
src_name	pointer
)	O
)	O
;	O
break	O
;	O
case	O
-	O
1	int
:	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"preserving permissions for %s"	pointer
)	O
,	O
quote	function
(	O
dst_name	pointer
)	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
ret	int
;	O
}	O
size_t	long
dir_len	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
prefix_length	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
;	O
size_t	long
length	long
;	O
prefix_length	long
+=	O
(	O
prefix_length	long
!=	O
0	int
?	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
prefix_length	long
]	O
)	O
)	O
:	O
(	O
ISSLASH	O
(	O
file	pointer
[	O
0	int
]	O
)	O
?	O
(	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
?	O
2	int
:	O
1	int
)	O
)	O
:	O
0	int
)	O
)	O
;	O
for	O
(	O
length	long
=	O
last_component	function
(	O
file	pointer
)	O
-	O
file	pointer
;	O
prefix_length	long
<	O
length	long
;	O
length	long
--	O
)	O
if	O
(	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
length	long
-	O
1	int
]	O
)	O
)	O
break	O
;	O
return	O
length	long
;	O
}	O
char	O
*	O
mdir_name	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
length	long
=	O
dir_len	function
(	O
file	pointer
)	O
;	O
bool	bool
append_dot	bool
=	O
(	O
length	long
==	O
0	int
||	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
length	long
==	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
&&	O
file	pointer
[	O
2	int
]	O
!=	O
'\0'	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
)	O
)	O
;	O
char	O
*	O
dir	pointer
=	O
malloc	function
(	O
length	long
+	O
append_dot	bool
+	O
1	int
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
dir	pointer
,	O
file	pointer
,	O
length	long
)	O
;	O
if	O
(	O
append_dot	bool
)	O
dir	pointer
[	O
length	long
++	O
]	O
=	O
'.'	O
;	O
dir	pointer
[	O
length	long
]	O
=	O
'\0'	O
;	O
return	O
dir	pointer
;	O
}	O
size_t	long
rpl_mbrtowc	function
(	O
wchar_t	int
*	O
pwc	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
size_t	long
n	long
,	O
mbstate_t	struct
*	O
ps	pointer
)	O
{	O
size_t	long
ret	long
;	O
wchar_t	int
wc	int
;	O
if	O
(	O
!	O
pwc	pointer
)	O
pwc	pointer
=	O
&	O
wc	int
;	O
ret	long
=	O
mbrtowc	function
(	O
pwc	pointer
,	O
s	pointer
,	O
n	long
,	O
ps	pointer
)	O
;	O
if	O
(	O
(	O
size_t	long
)	O
-	O
2	int
<=	O
ret	long
&&	O
n	long
!=	O
0	int
&&	O
!	O
hard_locale	function
(	O
LC_CTYPE	O
)	O
)	O
{	O
unsigned	O
char	O
uc	char
=	O
*	O
s	pointer
;	O
*	O
pwc	pointer
=	O
uc	char
;	O
return	O
1	int
;	O
}	O
return	O
ret	long
;	O
}	O
char	O
*	O
fread_file	function
(	O
FILE	struct
*	O
stream	pointer
,	O
size_t	long
*	O
length	pointer
)	O
{	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
alloc	long
=	O
BUFSIZ	int
;	O
{	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
fstat	function
(	O
fileno	function
(	O
stream	pointer
)	O
,	O
&	O
st	struct
)	O
>=	O
0	int
&&	O
S_ISREG	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
off_t	long
pos	long
=	O
ftello	function
(	O
stream	pointer
)	O
;	O
if	O
(	O
pos	long
>=	O
0	int
&&	O
pos	long
<	O
st	struct
.	O
st_size	long
)	O
{	O
off_t	long
alloc_off	long
=	O
st	struct
.	O
st_size	long
-	O
pos	long
;	O
if	O
(	O
SIZE_MAX	O
-	O
1	int
<	O
alloc_off	long
)	O
{	O
errno	O
=	O
ENOMEM	int
;	O
return	O
NULL	O
;	O
}	O
alloc	long
=	O
alloc_off	long
+	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
(	O
buf	pointer
=	O
malloc	function
(	O
alloc	long
)	O
)	O
)	O
return	O
NULL	O
;	O
{	O
size_t	long
size	long
=	O
0	int
;	O
int	O
save_errno	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
size_t	long
requested	long
=	O
alloc	long
-	O
size	long
;	O
size_t	long
count	long
=	O
fread	function
(	O
buf	pointer
+	O
size	long
,	O
1	int
,	O
requested	long
,	O
stream	pointer
)	O
;	O
size	long
+=	O
count	long
;	O
if	O
(	O
count	long
!=	O
requested	long
)	O
{	O
save_errno	int
=	O
errno	O
;	O
if	O
(	O
ferror	function
(	O
stream	pointer
)	O
)	O
break	O
;	O
if	O
(	O
size	long
<	O
alloc	long
-	O
1	int
)	O
{	O
char	O
*	O
smaller_buf	pointer
=	O
realloc	function
(	O
buf	pointer
,	O
size	long
+	O
1	int
)	O
;	O
if	O
(	O
smaller_buf	pointer
!=	O
NULL	O
)	O
buf	pointer
=	O
smaller_buf	pointer
;	O
}	O
buf	pointer
[	O
size	long
]	O
=	O
'\0'	O
;	O
*	O
length	pointer
=	O
size	long
;	O
return	O
buf	pointer
;	O
}	O
{	O
char	O
*	O
new_buf	pointer
;	O
if	O
(	O
alloc	long
==	O
SIZE_MAX	O
)	O
{	O
save_errno	int
=	O
ENOMEM	int
;	O
break	O
;	O
}	O
if	O
(	O
alloc	long
<	O
SIZE_MAX	O
-	O
alloc	long
/	O
2	int
)	O
alloc	long
=	O
alloc	long
+	O
alloc	long
/	O
2	int
;	O
else	O
alloc	long
=	O
SIZE_MAX	O
;	O
if	O
(	O
!	O
(	O
new_buf	pointer
=	O
realloc	function
(	O
buf	pointer
,	O
alloc	long
)	O
)	O
)	O
{	O
save_errno	int
=	O
errno	O
;	O
break	O
;	O
}	O
buf	pointer
=	O
new_buf	pointer
;	O
}	O
}	O
free	function
(	O
buf	pointer
)	O
;	O
errno	O
=	O
save_errno	int
;	O
return	O
NULL	O
;	O
}	O
}	O
static	O
char	O
*	O
internal_read_file	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
size_t	long
*	O
length	pointer
,	O
const	O
char	O
*	O
mode	pointer
)	O
{	O
FILE	struct
*	O
stream	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
mode	pointer
)	O
;	O
char	O
*	O
out	pointer
;	O
int	O
save_errno	int
;	O
if	O
(	O
!	O
stream	pointer
)	O
return	O
NULL	O
;	O
out	pointer
=	O
fread_file	function
(	O
stream	pointer
,	O
length	pointer
)	O
;	O
save_errno	int
=	O
errno	O
;	O
if	O
(	O
fclose	function
(	O
stream	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
out	pointer
)	O
{	O
save_errno	int
=	O
errno	O
;	O
free	function
(	O
out	pointer
)	O
;	O
}	O
errno	O
=	O
save_errno	int
;	O
return	O
NULL	O
;	O
}	O
return	O
out	pointer
;	O
}	O
char	O
*	O
read_file	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
size_t	long
*	O
length	pointer
)	O
{	O
return	O
internal_read_file	function
(	O
filename	pointer
,	O
length	pointer
,	O
"r"	pointer
)	O
;	O
}	O
char	O
*	O
read_binary_file	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
size_t	long
*	O
length	pointer
)	O
{	O
return	O
internal_read_file	function
(	O
filename	pointer
,	O
length	pointer
,	O
"rb"	pointer
)	O
;	O
}	O
char	O
*	O
readline	function
(	O
const	O
char	O
*	O
prompt	pointer
)	O
{	O
char	O
*	O
out	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
if	O
(	O
prompt	pointer
)	O
{	O
fputs	function
(	O
prompt	pointer
,	O
stdout	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
if	O
(	O
getline	function
(	O
&	O
out	pointer
,	O
&	O
size	long
,	O
stdin	pointer
)	O
<	O
0	int
)	O
return	O
NULL	O
;	O
while	O
(	O
*	O
out	pointer
&&	O
(	O
out	pointer
[	O
strlen	function
(	O
out	pointer
)	O
-	O
1	int
]	O
==	O
'\r'	O
||	O
out	pointer
[	O
strlen	function
(	O
out	pointer
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
)	O
out	pointer
[	O
strlen	function
(	O
out	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
out	pointer
;	O
}	O
const	O
char	O
version_etc_copyright	array
[	O
]	O
=	O
"Copyright %s %d Free Software Foundation, Inc."	pointer
;	O
enum	O
{	O
HAVE_GNU_CALLOC	int
=	O
1	int
}	O
;	O
void	O
*	O
xmalloc	function
(	O
size_t	long
n	long
)	O
{	O
void	O
*	O
p	pointer
=	O
malloc	function
(	O
n	long
)	O
;	O
if	O
(	O
!	O
p	pointer
&&	O
n	long
!=	O
0	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
n	long
)	O
{	O
if	O
(	O
!	O
n	long
&&	O
p	pointer
)	O
{	O
free	function
(	O
p	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
p	pointer
=	O
realloc	function
(	O
p	pointer
,	O
n	long
)	O
;	O
if	O
(	O
!	O
p	pointer
&&	O
n	long
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
x2realloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
*	O
pn	pointer
)	O
{	O
return	O
x2nrealloc	function
(	O
p	pointer
,	O
pn	pointer
,	O
1	int
)	O
;	O
}	O
void	O
*	O
xzalloc	function
(	O
size_t	long
s	long
)	O
{	O
return	O
memset	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
0	int
,	O
s	long
)	O
;	O
}	O
void	O
*	O
xcalloc	function
(	O
size_t	long
n	long
,	O
size_t	long
s	long
)	O
{	O
void	O
*	O
p	pointer
;	O
if	O
(	O
xalloc_oversized	O
(	O
n	long
,	O
s	long
)	O
||	O
(	O
!	O
(	O
p	pointer
=	O
calloc	function
(	O
n	long
,	O
s	long
)	O
)	O
&&	O
(	O
HAVE_GNU_CALLOC	int
||	O
n	long
!=	O
0	int
)	O
)	O
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xmemdup	function
(	O
void	O
const	O
*	O
p	pointer
,	O
size_t	long
s	long
)	O
{	O
return	O
memcpy	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
p	pointer
,	O
s	long
)	O
;	O
}	O
char	O
*	O
xstrdup	function
(	O
char	O
const	O
*	O
string	pointer
)	O
{	O
return	O
xmemdup	function
(	O
string	pointer
,	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
)	O
;	O
}	O
void	O
recfmt_parse_args	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
bool	bool
recfmt_process_data	function
(	O
rec_db_t	pointer
db	pointer
)	O
;	O
void	O
recfmt_process_db	function
(	O
rec_db_t	pointer
db	pointer
,	O
char	O
*	O
template	struct
)	O
;	O
char	O
*	O
recfmt_apply_template	function
(	O
rec_record_t	pointer
record	pointer
,	O
char	O
*	O
template	pointer
)	O
;	O
char	O
*	O
recfmt_get_subst	function
(	O
rec_record_t	pointer
record	pointer
,	O
char	O
*	O
str	pointer
)	O
;	O
char	O
*	O
recfmt_template	pointer
=	O
NULL	O
;	O
enum	O
{	O
COMMON_ARGS	O
,	O
FILE_ARG	int
}	O
;	O
static	O
const	O
struct	O
option	struct
GNU_longOptions	array
[	O
]	O
=	O
{	O
COMMON_LONG_ARGS	O
,	O
{	O
"file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
FILE_ARG	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
void	O
recutl_print_help	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Usage: recfmt [OPTION]... [TEMPLATE]\n"	pointer
)	O
)	O
;	O
fputs	function
(	O
_	O
(	O
"Apply a template to records read from standard input.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"  -f, --file=FILENAME                 read the template to apply from a file.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
recutl_print_help_common	function
(	O
)	O
;	O
puts	function
(	O
""	pointer
)	O
;	O
recutl_print_help_footer	function
(	O
)	O
;	O
}	O
void	O
recfmt_parse_args	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
c	int
;	O
int	O
ret	int
;	O
while	O
(	O
(	O
ret	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"f:"	pointer
,	O
GNU_longOptions	array
,	O
NULL	O
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
c	int
=	O
ret	int
;	O
switch	O
(	O
c	int
)	O
{	O
COMMON_ARGS_CASES	O
case	O
FILE_ARG	int
:	O
case	O
'f'	O
:	O
{	O
recfmt_template	pointer
=	O
recutl_read_file	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
!	O
recfmt_template	int
)	O
{	O
recutl_fatal	function
(	O
_	O
(	O
"can't open file %s for reading.\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
}	O
break	O
;	O
}	O
default	O
:	O
{	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
if	O
(	O
recfmt_template	int
)	O
{	O
recutl_fatal	function
(	O
_	O
(	O
"don't specify a template in the command line and -f at the same time.\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
(	O
argc	int
-	O
optind	int
)	O
!=	O
1	int
)	O
{	O
recutl_print_help	function
(	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
recfmt_template	pointer
=	O
xstrdup	function
(	O
argv	pointer
[	O
optind	int
++	O
]	O
)	O
;	O
}	O
}	O
char	O
*	O
recfmt_get_subst	function
(	O
rec_record_t	pointer
record	pointer
,	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
res	pointer
;	O
rec_sex_t	pointer
sex	pointer
;	O
sex	enum
=	O
rec_sex_new	function
(	O
false	int
)	O
;	O
if	O
(	O
!	O
rec_sex_compile	function
(	O
sex	pointer
,	O
str	pointer
)	O
)	O
{	O
recutl_fatal	function
(	O
_	O
(	O
"invalid expression in a template slot.\n"	pointer
)	O
)	O
;	O
}	O
res	int
=	O
rec_sex_eval_str	function
(	O
sex	pointer
,	O
record	pointer
)	O
;	O
if	O
(	O
!	O
res	pointer
)	O
{	O
recutl_fatal	function
(	O
_	O
(	O
"error evaluating expression in a template slot.\n"	pointer
)	O
)	O
;	O
}	O
rec_sex_destroy	function
(	O
sex	pointer
)	O
;	O
return	O
res	pointer
;	O
}	O
char	O
*	O
recfmt_apply_template	function
(	O
rec_record_t	pointer
record	pointer
,	O
char	O
*	O
template	pointer
)	O
{	O
rec_buf_t	struct
result_buf	struct
;	O
char	O
*	O
result	pointer
;	O
char	O
*	O
tmp	pointer
;	O
size_t	long
tmp_size	long
;	O
size_t	long
result_size	long
;	O
char	O
*	O
p	pointer
;	O
regex_t	struct
regexp	pointer
;	O
regmatch_t	struct
matches	pointer
;	O
char	O
*	O
subst_str	pointer
;	O
if	O
(	O
regcomp	function
(	O
&	O
regexp	struct
,	O
"\\{\\{"	pointer
"[^}]*"	pointer
"\\}\\}"	pointer
,	O
REG_EXTENDED	int
)	O
!=	O
0	int
)	O
{	O
recutl_fatal	function
(	O
_	O
(	O
"recfmt_apply_template: error compiling regexp. Please report this.\n"	pointer
)	O
)	O
;	O
}	O
result_buf	struct
=	O
rec_buf_new	function
(	O
&	O
result	pointer
,	O
&	O
result_size	struct
)	O
;	O
p	pointer
=	O
template	struct
;	O
while	O
(	O
*	O
p	pointer
&&	O
(	O
regexec	function
(	O
&	O
regexp	O
,	O
p	pointer
,	O
1	int
,	O
&	O
matches	pointer
,	O
0	int
)	O
==	O
0	int
)	O
&&	O
(	O
matches	struct
.	O
rm_so	int
!=	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
matches	struct
.	O
rm_so	int
>	O
0	int
)	O
{	O
tmp	pointer
=	O
xmalloc	function
(	O
matches	struct
.	O
rm_so	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
tmp	pointer
,	O
p	pointer
,	O
matches	struct
.	O
rm_so	int
)	O
;	O
tmp	pointer
[	O
matches	struct
.	O
rm_so	int
]	O
=	O
'\0'	O
;	O
rec_buf_puts	function
(	O
tmp	pointer
,	O
result_buf	struct
)	O
;	O
free	function
(	O
tmp	pointer
)	O
;	O
}	O
tmp_size	int
=	O
matches	struct
.	O
rm_eo	int
-	O
matches	struct
.	O
rm_so	int
-	O
4	int
;	O
tmp	pointer
=	O
xmalloc	function
(	O
tmp_size	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
tmp	pointer
,	O
p	pointer
+	O
matches	struct
.	O
rm_so	int
+	O
2	int
,	O
tmp_size	int
)	O
;	O
tmp	pointer
[	O
tmp_size	int
]	O
=	O
'\0'	O
;	O
p	pointer
=	O
p	pointer
+	O
matches	struct
.	O
rm_eo	int
;	O
subst_str	pointer
=	O
recfmt_get_subst	function
(	O
record	pointer
,	O
tmp	pointer
)	O
;	O
if	O
(	O
subst_str	pointer
)	O
{	O
rec_buf_puts	function
(	O
subst_str	pointer
,	O
result_buf	struct
)	O
;	O
free	function
(	O
subst_str	pointer
)	O
;	O
}	O
free	function
(	O
tmp	pointer
)	O
;	O
}	O
if	O
(	O
*	O
p	pointer
)	O
{	O
rec_buf_puts	function
(	O
p	pointer
,	O
result_buf	struct
)	O
;	O
}	O
rec_buf_close	function
(	O
result_buf	struct
)	O
;	O
return	O
result	pointer
;	O
}	O
void	O
recfmt_process_db	function
(	O
rec_db_t	pointer
db	pointer
,	O
char	O
*	O
template	struct
)	O
{	O
size_t	long
n_rset	long
;	O
rec_rset_t	pointer
rset	pointer
;	O
rec_record_t	pointer
record	pointer
;	O
char	O
*	O
result	pointer
;	O
rec_mset_iterator_t	struct
iter	struct
;	O
for	O
(	O
n_rset	long
=	O
0	int
;	O
n_rset	long
<	O
rec_db_size	O
(	O
db	pointer
)	O
;	O
n_rset	long
++	O
)	O
{	O
rset	pointer
=	O
rec_db_get_rset	function
(	O
db	pointer
,	O
n_rset	long
)	O
;	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_rset_mset	function
(	O
rset	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_RECORD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
record	pointer
,	O
NULL	O
)	O
)	O
{	O
result	pointer
=	O
recfmt_apply_template	function
(	O
record	pointer
,	O
template	struct
)	O
;	O
if	O
(	O
result	pointer
&&	O
(	O
*	O
result	pointer
!=	O
'\0'	O
)	O
)	O
{	O
printf	function
(	O
"%s"	pointer
,	O
result	pointer
)	O
;	O
free	function
(	O
result	pointer
)	O
;	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
rec_db_t	pointer
db	pointer
;	O
recutl_init	function
(	O
"recfmt"	pointer
)	O
;	O
recfmt_parse_args	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
db	pointer
=	O
recutl_read_db_from_file	function
(	O
NULL	O
)	O
;	O
if	O
(	O
db	pointer
&&	O
recfmt_template	pointer
)	O
{	O
recfmt_process_db	function
(	O
db	pointer
,	O
recfmt_template	pointer
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
char	O
*	O
last_component	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
const	O
*	O
base	pointer
=	O
name	pointer
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
char	O
const	O
*	O
p	pointer
;	O
bool	bool
saw_slash	bool
=	O
false	int
;	O
while	O
(	O
ISSLASH	O
(	O
*	O
base	pointer
)	O
)	O
base	pointer
++	O
;	O
for	O
(	O
p	pointer
=	O
base	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
ISSLASH	O
(	O
*	O
p	pointer
)	O
)	O
saw_slash	bool
=	O
true	int
;	O
else	O
if	O
(	O
saw_slash	bool
)	O
{	O
base	pointer
=	O
p	pointer
;	O
saw_slash	bool
=	O
false	int
;	O
}	O
}	O
return	O
(	O
char	O
*	O
)	O
base	pointer
;	O
}	O
size_t	long
base_len	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
size_t	long
len	long
;	O
size_t	long
prefix_len	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
for	O
(	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
1	int
<	O
len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
len	long
-	O
1	int
]	O
)	O
;	O
len	long
--	O
)	O
continue	O
;	O
if	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
len	long
==	O
1	int
&&	O
ISSLASH	O
(	O
name	pointer
[	O
0	int
]	O
)	O
&&	O
ISSLASH	O
(	O
name	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
name	pointer
[	O
2	int
]	O
)	O
return	O
2	int
;	O
if	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
prefix_len	long
&&	O
len	long
==	O
prefix_len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
prefix_len	long
]	O
)	O
)	O
return	O
prefix_len	long
+	O
1	int
;	O
return	O
len	long
;	O
}	O
size_t	long
dir_len	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
prefix_length	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
;	O
size_t	long
length	long
;	O
prefix_length	long
+=	O
(	O
prefix_length	long
!=	O
0	int
?	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
prefix_length	long
]	O
)	O
)	O
:	O
(	O
ISSLASH	O
(	O
file	pointer
[	O
0	int
]	O
)	O
?	O
(	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
ISSLASH	O
(	O
file	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
?	O
2	int
:	O
1	int
)	O
)	O
:	O
0	int
)	O
)	O
;	O
for	O
(	O
length	long
=	O
last_component	function
(	O
file	pointer
)	O
-	O
file	pointer
;	O
prefix_length	long
<	O
length	long
;	O
length	long
--	O
)	O
if	O
(	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
length	long
-	O
1	int
]	O
)	O
)	O
break	O
;	O
return	O
length	long
;	O
}	O
char	O
*	O
mdir_name	function
(	O
char	O
const	O
*	O
file	pointer
)	O
{	O
size_t	long
length	long
=	O
dir_len	function
(	O
file	pointer
)	O
;	O
bool	bool
append_dot	bool
=	O
(	O
length	long
==	O
0	int
||	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
length	long
==	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
file	pointer
)	O
&&	O
file	pointer
[	O
2	int
]	O
!=	O
'\0'	O
&&	O
!	O
ISSLASH	O
(	O
file	pointer
[	O
2	int
]	O
)	O
)	O
)	O
;	O
char	O
*	O
dir	pointer
=	O
malloc	function
(	O
length	long
+	O
append_dot	bool
+	O
1	int
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
return	O
NULL	O
;	O
memcpy	function
(	O
dir	pointer
,	O
file	pointer
,	O
length	long
)	O
;	O
if	O
(	O
append_dot	bool
)	O
dir	pointer
[	O
length	long
++	O
]	O
=	O
'.'	O
;	O
dir	pointer
[	O
length	long
]	O
=	O
'\0'	O
;	O
return	O
dir	pointer
;	O
}	O
bool	bool
hard_locale	function
(	O
int	O
category	int
)	O
{	O
bool	bool
hard	bool
=	O
true	int
;	O
char	O
const	O
*	O
p	pointer
=	O
setlocale	function
(	O
category	int
,	O
NULL	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
if	O
(	O
2	int
<=	O
GLIBC_VERSION	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
"C"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
p	pointer
,	O
"POSIX"	pointer
)	O
==	O
0	int
)	O
hard	bool
=	O
false	int
;	O
}	O
else	O
{	O
char	O
*	O
locale	pointer
=	O
strdup	function
(	O
p	pointer
)	O
;	O
if	O
(	O
locale	pointer
)	O
{	O
if	O
(	O
(	O
(	O
p	pointer
=	O
setlocale	function
(	O
category	int
,	O
"C"	pointer
)	O
)	O
&&	O
strcmp	function
(	O
p	pointer
,	O
locale	pointer
)	O
==	O
0	int
)	O
||	O
(	O
(	O
p	pointer
=	O
setlocale	function
(	O
category	int
,	O
"POSIX"	pointer
)	O
)	O
&&	O
strcmp	function
(	O
p	pointer
,	O
locale	pointer
)	O
==	O
0	int
)	O
)	O
hard	bool
=	O
false	int
;	O
setlocale	function
(	O
category	int
,	O
locale	pointer
)	O
;	O
free	function
(	O
locale	pointer
)	O
;	O
}	O
}	O
}	O
return	O
hard	bool
;	O
}	O
const	O
char	O
*	O
locale_charset	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
codeset	pointer
;	O
codeset	pointer
=	O
nl_langinfo	function
(	O
CODESET	int
)	O
;	O
if	O
(	O
codeset	pointer
==	O
NULL	O
)	O
codeset	pointer
=	O
""	pointer
;	O
{	O
{	O
if	O
(	O
codeset	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
codeset	pointer
=	O
"ASCII"	pointer
;	O
}	O
}	O
return	O
codeset	pointer
;	O
}	O
typedef	O
unsigned	O
char	O
small_t	char
;	O
verify	O
(	O
2	int
*	O
sa_alignment_max	int
-	O
1	int
<=	O
(	O
small_t	char
)	O
-	O
1	int
)	O
;	O
void	O
*	O
mmalloca	function
(	O
size_t	long
n	long
)	O
{	O
size_t	long
nplus	long
=	O
n	long
+	O
sizeof	O
(	O
small_t	char
)	O
+	O
2	int
*	O
sa_alignment_max	int
-	O
1	int
;	O
if	O
(	O
nplus	long
>=	O
n	long
)	O
{	O
char	O
*	O
mem	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
nplus	long
)	O
;	O
if	O
(	O
mem	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
p	pointer
=	O
(	O
char	O
*	O
)	O
(	O
(	O
(	O
(	O
uintptr_t	long
)	O
mem	pointer
+	O
sizeof	O
(	O
small_t	char
)	O
+	O
sa_alignment_max	int
-	O
1	int
)	O
&	O
~	O
(	O
uintptr_t	long
)	O
(	O
2	int
*	O
sa_alignment_max	int
-	O
1	int
)	O
)	O
+	O
sa_alignment_max	int
)	O
;	O
(	O
(	O
small_t	char
*	O
)	O
p	pointer
)	O
[	O
-	O
1	int
]	O
=	O
p	pointer
-	O
mem	pointer
;	O
return	O
p	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
void	O
freea	function
(	O
void	O
*	O
p	pointer
)	O
{	O
if	O
(	O
(	O
uintptr_t	long
)	O
p	pointer
&	O
(	O
sa_alignment_max	int
-	O
1	int
)	O
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
(	O
uintptr_t	long
)	O
p	pointer
&	O
sa_alignment_max	int
)	O
{	O
void	O
*	O
mem	pointer
=	O
(	O
char	O
*	O
)	O
p	pointer
-	O
(	O
(	O
small_t	char
*	O
)	O
p	pointer
)	O
[	O
-	O
1	int
]	O
;	O
free	function
(	O
mem	pointer
)	O
;	O
}	O
}	O
static	O
int	O
utmp_fd	int
=	O
-	O
1	int
;	O
static	O
enum	O
rushdb_result	enum
status	enum
=	O
rushdb_result_eof	int
;	O
static	O
struct	O
rush_utmp	struct
utmprec	struct
=	O
{	O
-	O
1	int
,	O
0	int
}	O
;	O
int	O
rush_utmp_open	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
rw	int
)	O
{	O
int	O
fd	int
;	O
fd	int
=	O
open	function
(	O
name	pointer
,	O
rw	int
?	O
O_RDWR	int
|	O
O_CREAT	int
:	O
O_RDONLY	int
,	O
rushdb_file_mode	pointer
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
utmp_fd	int
=	O
fd	int
;	O
return	O
0	int
;	O
}	O
int	O
rush_utmp_close	function
(	O
)	O
{	O
int	O
rc	int
=	O
close	function
(	O
utmp_fd	int
)	O
;	O
utmp_fd	int
=	O
-	O
1	int
;	O
return	O
rc	int
;	O
}	O
static	O
enum	O
rushdb_result	enum
rush_utmp_read0	function
(	O
int	O
statmap	int
,	O
int	O
*	O
pstatus	pointer
,	O
struct	O
rush_wtmp	struct
*	O
*	O
pwtmp	pointer
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
ssize_t	long
n	int
=	O
read	function
(	O
utmp_fd	pointer
,	O
&	O
utmprec	int
,	O
sizeof	O
(	O
utmprec	pointer
)	O
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
rushdb_result_eof	int
;	O
if	O
(	O
n	int
!=	O
sizeof	O
(	O
utmprec	pointer
)	O
)	O
return	O
rushdb_result_fail	int
;	O
if	O
(	O
rush_wtmp_seek	function
(	O
utmprec	struct
.	O
offset	int
)	O
)	O
return	O
rushdb_result_fail	int
;	O
if	O
(	O
statmap	int
==	O
0	int
||	O
RUSH_STATUS_MAP_ISSET	function
(	O
statmap	int
,	O
utmprec	struct
.	O
status	int
)	O
)	O
{	O
if	O
(	O
pwtmp	int
&&	O
rush_wtmp_read	function
(	O
pwtmp	pointer
)	O
)	O
return	O
rushdb_result_fail	int
;	O
break	O
;	O
}	O
}	O
*	O
pstatus	pointer
=	O
utmprec	struct
.	O
status	int
;	O
return	O
rushdb_result_ok	int
;	O
}	O
enum	O
rushdb_result	enum
rush_utmp_read	function
(	O
int	O
statmap	int
,	O
int	O
*	O
pstatus	pointer
,	O
struct	O
rush_wtmp	struct
*	O
*	O
pwtmp	pointer
)	O
{	O
return	O
status	int
=	O
rush_utmp_read0	function
(	O
statmap	pointer
,	O
pstatus	pointer
,	O
pwtmp	pointer
)	O
;	O
}	O
int	O
rush_utmp_chstatus	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
utmp_fd	int
==	O
-	O
1	int
||	O
utmprec	struct
.	O
status	int
==	O
-	O
1	int
||	O
!	O
(	O
status	int
==	O
RUSH_STATUS_AVAIL	int
||	O
status	int
==	O
RUSH_STATUS_INUSE	int
)	O
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
1	int
;	O
}	O
if	O
(	O
lseek	function
(	O
utmp_fd	pointer
,	O
-	O
sizeof	O
(	O
utmprec	pointer
)	O
,	O
SEEK_CUR	int
)	O
==	O
-	O
1	int
)	O
return	O
1	int
;	O
utmprec	struct
.	O
status	int
=	O
status	int
;	O
if	O
(	O
write	function
(	O
utmp_fd	pointer
,	O
&	O
utmprec	struct
,	O
sizeof	O
(	O
utmprec	pointer
)	O
)	O
!=	O
sizeof	O
(	O
utmprec	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
rush_utmp_write	function
(	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
)	O
{	O
int	O
rc	int
;	O
off_t	long
off	long
;	O
if	O
(	O
utmp_fd	int
==	O
-	O
1	int
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
1	int
;	O
}	O
off	long
=	O
rush_wtmp_append	function
(	O
wtmp	pointer
)	O
;	O
if	O
(	O
off	long
==	O
-	O
1	int
)	O
return	O
1	int
;	O
if	O
(	O
status	int
==	O
rushdb_result_ok	int
)	O
{	O
if	O
(	O
lseek	function
(	O
utmp_fd	pointer
,	O
-	O
sizeof	O
(	O
utmprec	pointer
)	O
,	O
SEEK_CUR	int
)	O
==	O
-	O
1	int
)	O
return	O
1	int
;	O
}	O
utmprec	struct
.	O
status	int
=	O
RUSH_STATUS_INUSE	int
;	O
utmprec	struct
.	O
offset	long
=	O
off	long
;	O
rushdb_lock	function
(	O
utmp_fd	pointer
,	O
sizeof	O
(	O
utmprec	pointer
)	O
,	O
0	int
,	O
SEEK_CUR	int
,	O
RUSH_LOCK_WRITE	pointer
)	O
;	O
rc	int
=	O
write	function
(	O
utmp_fd	pointer
,	O
&	O
utmprec	struct
,	O
sizeof	O
(	O
utmprec	struct
)	O
)	O
;	O
rushdb_unlock	function
(	O
utmp_fd	pointer
,	O
-	O
sizeof	O
(	O
utmprec	pointer
)	O
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
if	O
(	O
rc	int
!=	O
sizeof	O
(	O
utmprec	pointer
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
rush_utmp_lock_all	function
(	O
int	O
type	int
)	O
{	O
rushdb_lock	function
(	O
utmp_fd	pointer
,	O
0	int
,	O
0	int
,	O
SEEK_SET	int
,	O
type	int
)	O
;	O
}	O
void	O
rush_utmp_unlock_all	function
(	O
)	O
{	O
rushdb_unlock	function
(	O
utmp_fd	pointer
,	O
0	int
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
}	O
char	O
*	O
base_name	pointer
=	O
RUSH_DB	O
;	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
=	O
NULL	O
;	O
int	O
display_header	int
=	O
1	int
;	O
char	O
*	O
format	pointer
;	O
void	O
xalloc_die	function
(	O
)	O
{	O
error	function
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"not enough memory"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
char	O
*	O
default_format	pointer
=	O
"(user 10 Login) "	pointer
"(rule 8 Rule) "	pointer
"(start-time 0 Start) "	pointer
"(duration 10 Time) "	pointer
"(pid 10 PID) "	pointer
"(command 28 Command)"	pointer
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
status	int
;	O
rushdb_format_t	pointer
form	pointer
;	O
rush_set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
rush_i18n_init	function
(	O
)	O
;	O
format	pointer
=	O
getenv	function
(	O
"RUSHWHO_FORMAT"	pointer
)	O
;	O
if	O
(	O
!	O
format	pointer
)	O
format	pointer
=	O
default_format	pointer
;	O
get_options	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
argc	int
-=	O
optind	int
;	O
argv	pointer
+=	O
optind	int
;	O
if	O
(	O
argc	int
)	O
error	function
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"extra arguments"	pointer
)	O
)	O
;	O
if	O
(	O
format	pointer
[	O
0	int
]	O
==	O
'@'	O
)	O
format	pointer
=	O
rush_read_format	function
(	O
format	pointer
+	O
1	int
)	O
;	O
form	pointer
=	O
rushdb_compile_format	function
(	O
format	pointer
)	O
;	O
if	O
(	O
!	O
form	pointer
)	O
error	function
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"invalid format: %s"	pointer
)	O
,	O
rushdb_error_string	pointer
)	O
;	O
switch	O
(	O
rushdb_open	function
(	O
base_name	pointer
,	O
0	int
)	O
)	O
{	O
case	O
rushdb_result_ok	int
:	O
break	O
;	O
case	O
rushdb_result_eof	int
:	O
exit	function
(	O
0	int
)	O
;	O
case	O
rushdb_result_fail	int
:	O
error	pointer
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"cannot open database file %s"	pointer
)	O
,	O
base_name	pointer
)	O
;	O
}	O
if	O
(	O
display_header	int
)	O
rushdb_print_header	function
(	O
form	pointer
)	O
;	O
while	O
(	O
rush_utmp_read	function
(	O
RUSH_STATUS_MAP_BIT	function
(	O
RUSH_STATUS_INUSE	pointer
)	O
,	O
&	O
status	int
,	O
&	O
wtmp	pointer
)	O
==	O
rushdb_result_ok	int
)	O
{	O
rushdb_print	function
(	O
form	pointer
,	O
wtmp	pointer
,	O
1	int
)	O
;	O
free	function
(	O
wtmp	pointer
)	O
;	O
}	O
rushdb_close	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
void	O
get_time	function
(	O
INT	O
*	O
t	pointer
)	O
{	O
struct	O
timeb	struct
tp	struct
;	O
if	O
(	O
ftime	function
(	O
&	O
tp	pointer
)	O
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"ftime() system call in C function get_time() failed in file: "	struct
__FILE__	O
", line: %d\n"	pointer
,	O
__LINE__	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
t	pointer
[	O
0	int
]	O
=	O
tp	pointer
.	O
time	double
;	O
t	pointer
[	O
1	int
]	O
=	O
tp	pointer
.	O
millitm	int
;	O
t	pointer
[	O
2	int
]	O
=	O
tp	struct
.	O
timezone	long
;	O
t	pointer
[	O
3	int
]	O
=	O
tp	struct
.	O
dstflag	int
;	O
}	O
void	O
wait_for_time	function
(	O
INT	O
secs	long
,	O
INT	O
millis	int
)	O
{	O
sleep	function
(	O
secs	double
)	O
;	O
usleep	function
(	O
millis	O
*	O
1000	int
)	O
;	O
}	O
WidgetClass	O
Xaw_asciiTextWidgetClass	function
(	O
)	O
{	O
return	O
asciiTextWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_boxWidgetClass	function
(	O
)	O
{	O
return	O
boxWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_commandWidgetClass	function
(	O
)	O
{	O
return	O
commandWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_dialogWidgetClass	function
(	O
)	O
{	O
return	O
dialogWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_formWidgetClass	function
(	O
)	O
{	O
return	O
formWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_gripWidgetClass	function
(	O
)	O
{	O
return	O
gripWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_labelWidgetClass	function
(	O
)	O
{	O
return	O
labelWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_listWidgetClass	function
(	O
)	O
{	O
return	O
listWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_menuButtonWidgetClass	function
(	O
)	O
{	O
return	O
menuButtonWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_panedWidgetClass	function
(	O
)	O
{	O
return	O
panedWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_pannerWidgetClass	function
(	O
)	O
{	O
return	O
pannerWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_portholeWidgetClass	function
(	O
)	O
{	O
return	O
portholeWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_repeaterWidgetClass	function
(	O
)	O
{	O
return	O
repeaterWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_scrollbarWidgetClass	function
(	O
)	O
{	O
return	O
scrollbarWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_simpleWidgetClass	function
(	O
)	O
{	O
return	O
simpleWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_simpleMenuWidgetClass	function
(	O
)	O
{	O
return	O
simpleMenuWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_smeObjectClass	function
(	O
)	O
{	O
return	O
smeObjectClass	O
;	O
}	O
WidgetClass	O
Xaw_smeBSBObjectClass	function
(	O
)	O
{	O
return	O
smeBSBObjectClass	O
;	O
}	O
WidgetClass	O
Xaw_smeLineObjectClass	function
(	O
)	O
{	O
return	O
smeLineObjectClass	O
;	O
}	O
WidgetClass	O
Xaw_stripChartWidgetClass	function
(	O
)	O
{	O
return	O
stripChartWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_textWidgetClass	function
(	O
)	O
{	O
return	O
textWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_toggleWidgetClass	function
(	O
)	O
{	O
return	O
toggleWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_treeWidgetClass	function
(	O
)	O
{	O
return	O
treeWidgetClass	O
;	O
}	O
WidgetClass	O
Xaw_viewportWidgetClass	function
(	O
)	O
{	O
return	O
viewportWidgetClass	pointer
;	O
}	O
Widget	O
Xt_CreateManagedWidget	function
(	O
CHAR	O
*	O
name	pointer
,	O
WidgetClass	O
widget_class	int
,	O
Widget	O
parent	pointer
,	O
CHAR	O
*	O
*	O
arg_name	pointer
,	O
void	O
*	O
*	O
arg_val_ptr	pointer
,	O
INT	O
*	O
arg_val_int	pointer
,	O
INT	O
nargs	int
)	O
{	O
int	O
i	int
;	O
ArgList	struct
args	pointer
=	O
(	O
ArgList	pointer
)	O
alloca	function
(	O
nargs	int
*	O
sizeof	O
(	O
Arg	struct
)	O
)	O
;	O
if	O
(	O
!	O
args	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
"C_XT_WIDGET::Xt_CreateManagedWidget: "	pointer
"could not allocate memory\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
nargs	int
;	O
i	int
--	O
;	O
)	O
{	O
args	pointer
[	O
i	int
]	O
.	O
name	pointer
=	O
arg_name	array
[	O
i	int
]	O
;	O
args	array
[	O
i	int
]	O
.	O
value	int
=	O
(	O
arg_val_int	array
[	O
i	int
]	O
?	O
(	O
XtArgVal	pointer
)	O
arg_val_int	array
[	O
i	int
]	O
:	O
(	O
XtArgVal	pointer
)	O
arg_val_ptr	array
[	O
i	int
]	O
)	O
;	O
}	O
return	O
XtCreateManagedWidget	function
(	O
name	pointer
,	O
widget_class	int
,	O
parent	pointer
,	O
args	pointer
,	O
nargs	int
)	O
;	O
}	O
void	O
Xt_RealizeWidget	function
(	O
Widget	O
widget	O
)	O
{	O
XtRealizeWidget	function
(	O
widget	O
)	O
;	O
}	O
void	O
Xt_UnrealizeWidget	function
(	O
Widget	O
widget	O
)	O
{	O
XtUnrealizeWidget	function
(	O
widget	O
)	O
;	O
}	O
void	O
Xt_DestroyWidget	function
(	O
Widget	O
widget	O
)	O
{	O
XtDestroyWidget	function
(	O
widget	O
)	O
;	O
}	O
void	O
C_XT_WIDGET_Xt_HandleCallback	function
(	O
Widget	O
widget	O
,	O
INT	O
callback	pointer
,	O
EXT_OB	pointer
call_data	pointer
)	O
;	O
void	O
XtHandleCallback	function
(	O
Widget	O
widget	O
,	O
XtPointer	pointer
closure	pointer
,	O
XtPointer	pointer
call_data	pointer
)	O
{	O
C_XT_WIDGET_Xt_HandleCallback	function
(	O
widget	O
,	O
(	O
INT	O
)	O
closure	O
,	O
call_data	pointer
)	O
;	O
}	O
void	O
Xt_AddCallback	function
(	O
Widget	O
widget	O
,	O
CHAR	O
*	O
name	pointer
,	O
INT	O
callback	int
)	O
{	O
XtAddCallback	function
(	O
widget	O
,	O
name	pointer
,	O
XtHandleCallback	int
,	O
(	O
XtPointer	pointer
)	O
callback	pointer
)	O
;	O
}	O
int	O
set_cloexec_flag	function
(	O
int	O
desc	int
,	O
bool	bool
value	bool
)	O
{	O
int	O
flags	int
=	O
fcntl	function
(	O
desc	int
,	O
F_GETFD	int
,	O
0	int
)	O
;	O
if	O
(	O
0	int
<=	O
flags	int
)	O
{	O
int	O
newflags	int
=	O
(	O
value	bool
?	O
flags	int
|	O
FD_CLOEXEC	int
:	O
flags	int
&	O
~	O
FD_CLOEXEC	int
)	O
;	O
if	O
(	O
flags	int
==	O
newflags	int
||	O
fcntl	function
(	O
desc	int
,	O
F_SETFD	int
,	O
newflags	int
)	O
!=	O
-	O
1	int
)	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
dup_cloexec	function
(	O
int	O
fd	int
)	O
{	O
return	O
fcntl	function
(	O
fd	int
,	O
F_DUPFD_CLOEXEC	int
,	O
0	int
)	O
;	O
}	O
int	O
file_has_acl	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
stat	struct
const	O
*	O
sb	pointer
)	O
{	O
return	O
0	int
;	O
}	O
int	O
gl_sockets_startup	function
(	O
int	O
version	int
_GL_UNUSED	O
)	O
{	O
return	O
0	int
;	O
}	O
int	O
gl_sockets_cleanup	function
(	O
void	O
)	O
{	O
return	O
0	int
;	O
}	O
static	O
char	O
const	O
ao_ver_string	array
[	O
]	O
=	O
"41:0:16\n"	pointer
;	O
char	O
*	O
last_component	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
const	O
*	O
base	pointer
=	O
name	pointer
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
char	O
const	O
*	O
p	pointer
;	O
bool	bool
saw_slash	bool
=	O
false	int
;	O
while	O
(	O
ISSLASH	O
(	O
*	O
base	pointer
)	O
)	O
base	pointer
++	O
;	O
for	O
(	O
p	pointer
=	O
base	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
ISSLASH	O
(	O
*	O
p	pointer
)	O
)	O
saw_slash	bool
=	O
true	int
;	O
else	O
if	O
(	O
saw_slash	bool
)	O
{	O
base	pointer
=	O
p	pointer
;	O
saw_slash	bool
=	O
false	int
;	O
}	O
}	O
return	O
(	O
char	O
*	O
)	O
base	pointer
;	O
}	O
size_t	long
base_len	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
size_t	long
len	long
;	O
size_t	long
prefix_len	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
for	O
(	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
1	int
<	O
len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
len	long
-	O
1	int
]	O
)	O
;	O
len	long
--	O
)	O
continue	O
;	O
if	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
len	long
==	O
1	int
&&	O
ISSLASH	O
(	O
name	pointer
[	O
0	int
]	O
)	O
&&	O
ISSLASH	O
(	O
name	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
name	pointer
[	O
2	int
]	O
)	O
return	O
2	int
;	O
if	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
prefix_len	long
&&	O
len	long
==	O
prefix_len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
prefix_len	long
]	O
)	O
)	O
return	O
prefix_len	long
+	O
1	int
;	O
return	O
len	long
;	O
}	O
int	O
c_strcasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
int	O
c_strncasecmp	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
,	O
size_t	long
n	long
)	O
{	O
register	O
const	O
unsigned	O
char	O
*	O
p1	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s1	pointer
;	O
register	O
const	O
unsigned	O
char	O
*	O
p2	pointer
=	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
s2	pointer
;	O
unsigned	O
char	O
c1	char
,	O
c2	char
;	O
if	O
(	O
p1	pointer
==	O
p2	pointer
||	O
n	long
==	O
0	int
)	O
return	O
0	int
;	O
do	O
{	O
c1	char
=	O
c_tolower	function
(	O
*	O
p1	pointer
)	O
;	O
c2	char
=	O
c_tolower	function
(	O
*	O
p2	pointer
)	O
;	O
if	O
(	O
--	O
n	long
==	O
0	int
||	O
c1	char
==	O
'\0'	O
)	O
break	O
;	O
++	O
p1	pointer
;	O
++	O
p2	pointer
;	O
}	O
while	O
(	O
c1	char
==	O
c2	char
)	O
;	O
if	O
(	O
UCHAR_MAX	O
<=	O
INT_MAX	O
)	O
return	O
c1	char
-	O
c2	char
;	O
else	O
return	O
(	O
c1	char
>	O
c2	char
?	O
1	int
:	O
c1	char
<	O
c2	char
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
struct	O
cd_buf	struct
{	O
int	O
fd	int
;	O
}	O
;	O
static	O
void	O
cdb_init	function
(	O
struct	O
cd_buf	struct
*	O
cdb	pointer
)	O
{	O
cdb	pointer
->	O
fd	int
=	O
AT_FDCWD	O
;	O
}	O
static	O
int	O
cdb_fchdir	function
(	O
struct	O
cd_buf	struct
const	O
*	O
cdb	pointer
)	O
{	O
return	O
fchdir	function
(	O
cdb	pointer
->	O
fd	int
)	O
;	O
}	O
static	O
void	O
cdb_free	function
(	O
struct	O
cd_buf	struct
const	O
*	O
cdb	pointer
)	O
{	O
if	O
(	O
0	int
<=	O
cdb	pointer
->	O
fd	int
)	O
{	O
bool	bool
close_fail	bool
=	O
close	function
(	O
cdb	pointer
->	O
fd	int
)	O
;	O
assure	O
(	O
!	O
close_fail	bool
)	O
;	O
}	O
}	O
static	O
int	O
cdb_advance_fd	function
(	O
struct	O
cd_buf	struct
*	O
cdb	pointer
,	O
char	O
const	O
*	O
dir	pointer
)	O
{	O
int	O
new_fd	int
=	O
openat	function
(	O
cdb	pointer
->	O
fd	int
,	O
dir	pointer
,	O
O_SEARCH	O
|	O
O_DIRECTORY	O
|	O
O_NOCTTY	int
|	O
O_NONBLOCK	int
)	O
;	O
if	O
(	O
new_fd	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
cdb_free	function
(	O
cdb	pointer
)	O
;	O
cdb	pointer
->	O
fd	int
=	O
new_fd	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
_GL_ATTRIBUTE_PURE	O
find_non_slash	function
(	O
char	O
const	O
*	O
s	pointer
)	O
{	O
size_t	long
n_slash	long
=	O
strspn	function
(	O
s	pointer
,	O
"/"	pointer
)	O
;	O
return	O
(	O
char	O
*	O
)	O
s	pointer
+	O
n_slash	long
;	O
}	O
int	O
chdir_long	function
(	O
char	O
*	O
dir	pointer
)	O
{	O
int	O
e	int
=	O
chdir	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
e	int
==	O
0	int
||	O
errno	O
!=	O
ENAMETOOLONG	int
)	O
return	O
e	int
;	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
dir	pointer
)	O
;	O
char	O
*	O
dir_end	pointer
=	O
dir	pointer
+	O
len	long
;	O
struct	O
cd_buf	struct
cdb	pointer
;	O
size_t	long
n_leading_slash	long
;	O
cdb_init	function
(	O
&	O
cdb	pointer
)	O
;	O
assure	O
(	O
0	int
<	O
len	long
)	O
;	O
assure	O
(	O
PATH_MAX	int
<=	O
len	long
)	O
;	O
n_leading_slash	long
=	O
strspn	function
(	O
dir	pointer
,	O
"/"	pointer
)	O
;	O
if	O
(	O
n_leading_slash	long
==	O
2	int
)	O
{	O
int	O
err	int
;	O
char	O
*	O
slash	pointer
=	O
memchr	function
(	O
dir	pointer
+	O
3	int
,	O
'/'	O
,	O
dir_end	pointer
-	O
(	O
dir	pointer
+	O
3	int
)	O
)	O
;	O
if	O
(	O
slash	pointer
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENAMETOOLONG	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
slash	pointer
=	O
'\0'	O
;	O
err	int
=	O
cdb_advance_fd	function
(	O
&	O
cdb	pointer
,	O
dir	pointer
)	O
;	O
*	O
slash	pointer
=	O
'/'	O
;	O
if	O
(	O
err	int
!=	O
0	int
)	O
goto	O
Fail	O
;	O
dir	pointer
=	O
find_non_slash	function
(	O
slash	pointer
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
n_leading_slash	long
)	O
{	O
if	O
(	O
cdb_advance_fd	function
(	O
&	O
cdb	pointer
,	O
"/"	pointer
)	O
!=	O
0	int
)	O
goto	O
Fail	O
;	O
dir	pointer
+=	O
n_leading_slash	long
;	O
}	O
assure	O
(	O
*	O
dir	pointer
!=	O
'/'	O
)	O
;	O
assure	O
(	O
dir	pointer
<=	O
dir_end	pointer
)	O
;	O
while	O
(	O
PATH_MAX	int
<=	O
dir_end	pointer
-	O
dir	pointer
)	O
{	O
int	O
err	int
;	O
char	O
*	O
slash	pointer
=	O
memrchr	function
(	O
dir	pointer
,	O
'/'	O
,	O
PATH_MAX	int
)	O
;	O
if	O
(	O
slash	pointer
==	O
NULL	O
)	O
{	O
errno	O
=	O
ENAMETOOLONG	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
slash	pointer
=	O
'\0'	O
;	O
assure	O
(	O
slash	pointer
-	O
dir	pointer
<	O
PATH_MAX	int
)	O
;	O
err	int
=	O
cdb_advance_fd	function
(	O
&	O
cdb	pointer
,	O
dir	pointer
)	O
;	O
*	O
slash	pointer
=	O
'/'	O
;	O
if	O
(	O
err	int
!=	O
0	int
)	O
goto	O
Fail	O
;	O
dir	pointer
=	O
find_non_slash	function
(	O
slash	pointer
+	O
1	int
)	O
;	O
}	O
if	O
(	O
dir	pointer
<	O
dir_end	pointer
)	O
{	O
if	O
(	O
cdb_advance_fd	function
(	O
&	O
cdb	pointer
,	O
dir	pointer
)	O
!=	O
0	int
)	O
goto	O
Fail	O
;	O
}	O
if	O
(	O
cdb_fchdir	function
(	O
&	O
cdb	pointer
)	O
!=	O
0	int
)	O
goto	O
Fail	O
;	O
cdb_free	function
(	O
&	O
cdb	pointer
)	O
;	O
return	O
0	int
;	O
Fail	O
:	O
{	O
int	O
saved_errno	int
=	O
errno	O
;	O
cdb_free	function
(	O
&	O
cdb	pointer
)	O
;	O
errno	O
=	O
saved_errno	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
char	O
*	O
openat_proc_name	function
(	O
char	O
buf	array
[	O
OPENAT_BUFFER_SIZE	O
]	O
,	O
int	O
fd	int
,	O
char	O
const	O
*	O
file	pointer
)	O
{	O
static	O
int	O
proc_status	int
=	O
0	int
;	O
if	O
(	O
!	O
*	O
file	pointer
)	O
{	O
buf	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
buf	array
;	O
}	O
if	O
(	O
!	O
proc_status	int
)	O
{	O
int	O
proc_self_fd	int
=	O
open	function
(	O
"/proc/self/fd"	pointer
,	O
O_SEARCH	O
|	O
O_DIRECTORY	O
|	O
O_NOCTTY	int
|	O
O_NONBLOCK	int
)	O
;	O
if	O
(	O
proc_self_fd	int
<	O
0	int
)	O
proc_status	int
=	O
-	O
1	int
;	O
else	O
{	O
char	O
dotdot_buf	array
[	O
PROC_SELF_FD_NAME_SIZE_BOUND	O
(	O
sizeof	O
"../fd"	pointer
-	O
1	int
)	O
]	O
;	O
sprintf	function
(	O
dotdot_buf	array
,	O
PROC_SELF_FD_FORMAT	pointer
,	O
proc_self_fd	int
,	O
"../fd"	pointer
)	O
;	O
proc_status	int
=	O
access	function
(	O
dotdot_buf	array
,	O
F_OK	int
)	O
?	O
-	O
1	int
:	O
1	int
;	O
close	pointer
(	O
proc_self_fd	int
)	O
;	O
}	O
}	O
if	O
(	O
proc_status	int
<	O
0	int
)	O
return	O
NULL	O
;	O
else	O
{	O
size_t	long
bufsize	long
=	O
PROC_SELF_FD_NAME_SIZE_BOUND	O
(	O
strlen	function
(	O
file	pointer
)	O
)	O
;	O
char	O
*	O
result	pointer
=	O
buf	array
;	O
if	O
(	O
OPENAT_BUFFER_SIZE	O
<	O
bufsize	long
)	O
{	O
result	pointer
=	O
malloc	function
(	O
bufsize	long
)	O
;	O
if	O
(	O
!	O
result	pointer
)	O
return	O
NULL	O
;	O
}	O
sprintf	function
(	O
result	pointer
,	O
PROC_SELF_FD_FORMAT	pointer
,	O
fd	int
,	O
file	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
}	O
bool	bool
strip_trailing_slashes	function
(	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
base	pointer
=	O
last_component	function
(	O
file	pointer
)	O
;	O
char	O
*	O
base_lim	pointer
;	O
bool	bool
had_slash	bool
;	O
if	O
(	O
!	O
*	O
base	pointer
)	O
base	pointer
=	O
file	pointer
;	O
base_lim	pointer
=	O
base	pointer
+	O
base_len	function
(	O
base	pointer
)	O
;	O
had_slash	bool
=	O
(	O
*	O
base_lim	pointer
!=	O
'\0'	O
)	O
;	O
*	O
base_lim	pointer
=	O
'\0'	O
;	O
return	O
had_slash	bool
;	O
}	O
enum	O
{	O
HAVE_GNU_CALLOC	int
=	O
1	int
}	O
;	O
void	O
*	O
xmalloc	function
(	O
size_t	long
n	long
)	O
{	O
void	O
*	O
p	pointer
=	O
malloc	function
(	O
n	long
)	O
;	O
if	O
(	O
!	O
p	pointer
&&	O
n	long
!=	O
0	int
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
n	long
)	O
{	O
if	O
(	O
!	O
n	long
&&	O
p	pointer
)	O
{	O
free	function
(	O
p	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
p	pointer
=	O
realloc	function
(	O
p	pointer
,	O
n	long
)	O
;	O
if	O
(	O
!	O
p	pointer
&&	O
n	long
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
x2realloc	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
*	O
pn	pointer
)	O
{	O
return	O
x2nrealloc	function
(	O
p	pointer
,	O
pn	pointer
,	O
1	int
)	O
;	O
}	O
void	O
*	O
xzalloc	function
(	O
size_t	long
s	long
)	O
{	O
return	O
memset	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
0	int
,	O
s	long
)	O
;	O
}	O
void	O
*	O
xcalloc	function
(	O
size_t	long
n	long
,	O
size_t	long
s	long
)	O
{	O
void	O
*	O
p	pointer
;	O
if	O
(	O
(	O
!	O
HAVE_GNU_CALLOC	int
&&	O
xalloc_oversized	O
(	O
n	long
,	O
s	long
)	O
)	O
||	O
(	O
!	O
(	O
p	pointer
=	O
calloc	function
(	O
n	long
,	O
s	long
)	O
)	O
&&	O
(	O
HAVE_GNU_CALLOC	int
||	O
n	long
!=	O
0	int
)	O
)	O
)	O
xalloc_die	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
*	O
xmemdup	function
(	O
void	O
const	O
*	O
p	pointer
,	O
size_t	long
s	long
)	O
{	O
return	O
memcpy	function
(	O
xmalloc	function
(	O
s	long
)	O
,	O
p	pointer
,	O
s	long
)	O
;	O
}	O
char	O
*	O
xstrdup	function
(	O
char	O
const	O
*	O
string	pointer
)	O
{	O
return	O
xmemdup	function
(	O
string	pointer
,	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
)	O
;	O
}	O
static	O
void	O
xstrtol_error	function
(	O
enum	O
strtol_error	enum
err	enum
,	O
int	O
opt_idx	int
,	O
char	O
c	char
,	O
struct	O
option	struct
const	O
*	O
long_options	pointer
,	O
char	O
const	O
*	O
arg	pointer
,	O
int	O
exit_status	int
)	O
{	O
char	O
const	O
*	O
hyphens	pointer
=	O
"--"	pointer
;	O
char	O
const	O
*	O
msgid	pointer
;	O
char	O
const	O
*	O
option	struct
;	O
char	O
option_buffer	array
[	O
2	int
]	O
;	O
switch	O
(	O
err	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
LONGINT_INVALID	int
:	O
msgid	pointer
=	O
N_	O
(	O
"invalid %s%s argument '%s'"	pointer
)	O
;	O
break	O
;	O
case	O
LONGINT_INVALID_SUFFIX_CHAR	int
:	O
case	O
LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW	int
:	O
msgid	pointer
=	O
N_	O
(	O
"invalid suffix in %s%s argument '%s'"	pointer
)	O
;	O
break	O
;	O
case	O
LONGINT_OVERFLOW	int
:	O
msgid	pointer
=	O
N_	O
(	O
"%s%s argument '%s' too large"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
opt_idx	int
<	O
0	int
)	O
{	O
hyphens	pointer
-=	O
opt_idx	int
;	O
option_buffer	array
[	O
0	int
]	O
=	O
c	char
;	O
option_buffer	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
option	struct
=	O
option_buffer	array
;	O
}	O
else	O
option	struct
=	O
long_options	pointer
[	O
opt_idx	int
]	O
.	O
name	pointer
;	O
error	function
(	O
exit_status	int
,	O
0	int
,	O
gettext	function
(	O
msgid	pointer
)	O
,	O
hyphens	pointer
,	O
option	struct
,	O
arg	pointer
)	O
;	O
}	O
void	O
xstrtol_fatal	function
(	O
enum	O
strtol_error	enum
err	enum
,	O
int	O
opt_idx	int
,	O
char	O
c	char
,	O
struct	O
option	struct
const	O
*	O
long_options	pointer
,	O
char	O
const	O
*	O
arg	pointer
)	O
{	O
xstrtol_error	function
(	O
err	enum
,	O
opt_idx	int
,	O
c	char
,	O
long_options	pointer
,	O
arg	pointer
,	O
exit_failure	int
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
void	O
S_memcpy	function
(	O
char	O
*	O
dest	pointer
,	O
char	O
*	O
src	pointer
,	O
int	O
n	int
)	O
{	O
if	O
(	O
n	int
>	O
16	int
)	O
{	O
memcpy	function
(	O
dest	pointer
,	O
src	pointer
,	O
n	int
)	O
;	O
}	O
else	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
dest	pointer
[	O
i	int
]	O
=	O
src	pointer
[	O
i	int
]	O
;	O
}	O
}	O
int	O
ugetopt_long	function
(	O
argc	pointer
,	O
argv	pointer
,	O
options	pointer
,	O
long_options	pointer
,	O
opt_index	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
const	O
*	O
argv	pointer
;	O
const	O
char	O
*	O
options	pointer
;	O
const	O
struct	O
option	struct
*	O
long_options	pointer
;	O
int	O
*	O
opt_index	pointer
;	O
{	O
return	O
_ugetopt_internal	function
(	O
argc	int
,	O
argv	pointer
,	O
options	pointer
,	O
long_options	pointer
,	O
opt_index	pointer
,	O
0	int
)	O
;	O
}	O
int	O
ugetopt_long_only	function
(	O
argc	int
,	O
argv	pointer
,	O
options	pointer
,	O
long_options	pointer
,	O
opt_index	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
const	O
*	O
argv	pointer
;	O
const	O
char	O
*	O
options	pointer
;	O
const	O
struct	O
option	struct
*	O
long_options	pointer
;	O
int	O
*	O
opt_index	pointer
;	O
{	O
return	O
_ugetopt_internal	function
(	O
argc	int
,	O
argv	pointer
,	O
options	pointer
,	O
long_options	pointer
,	O
opt_index	pointer
,	O
1	int
)	O
;	O
}	O
static	O
int	O
f_strcmp	function
(	O
int	O
sense	int
,	O
const	O
void	O
*	O
vf1	pointer
,	O
const	O
void	O
*	O
vf2	pointer
)	O
{	O
char	O
*	O
f1	pointer
;	O
char	O
*	O
f2	pointer
;	O
f1	pointer
=	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
(	O
vf1	pointer
)	O
)	O
;	O
f2	pointer
=	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
(	O
vf2	pointer
)	O
)	O
;	O
if	O
(	O
sense	int
<	O
0	int
)	O
return	O
-	O
strcmp	function
(	O
f1	pointer
,	O
f2	pointer
)	O
;	O
return	O
strcmp	function
(	O
f1	pointer
,	O
f2	pointer
)	O
;	O
}	O
STRAR	struct
*	O
strar_copy_construct	function
(	O
STRAR	struct
*	O
src	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
s	pointer
;	O
STRAR	struct
*	O
ret	pointer
;	O
if	O
(	O
!	O
src	pointer
)	O
return	O
NULL	O
;	O
ret	pointer
=	O
strar_open	function
(	O
)	O
;	O
if	O
(	O
!	O
ret	pointer
)	O
return	O
NULL	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
s	pointer
=	O
strar_get	function
(	O
src	pointer
,	O
i	int
++	O
)	O
)	O
)	O
{	O
strar_add	function
(	O
ret	int
,	O
s	pointer
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
STRAR	struct
*	O
strar_open	function
(	O
void	O
)	O
{	O
STRAR	struct
*	O
strb	pointer
;	O
strb	pointer
=	O
(	O
STRAR	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
STRAR	struct
)	O
)	O
;	O
if	O
(	O
strb	pointer
==	O
(	O
STRAR	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
return	O
(	O
STRAR	struct
*	O
)	O
(	O
NULL	O
)	O
;	O
strb	pointer
->	O
lenM	int
=	O
0	int
;	O
strb	pointer
->	O
nsM	int
=	O
0	int
;	O
strb	pointer
->	O
storageM	pointer
=	O
strob_open	function
(	O
132	int
)	O
;	O
strb	pointer
->	O
listM	pointer
=	O
cplob_open	function
(	O
10	int
)	O
;	O
cplob_add_nta	function
(	O
strb	pointer
->	O
listM	pointer
,	O
NULL	O
)	O
;	O
return	O
strb	pointer
;	O
}	O
void	O
strar_reset	function
(	O
STRAR	struct
*	O
strar	pointer
)	O
{	O
strar	pointer
->	O
lenM	int
=	O
0	int
;	O
strar	pointer
->	O
nsM	int
=	O
0	int
;	O
strob_strcpy	function
(	O
strar	pointer
->	O
storageM	pointer
,	O
""	pointer
)	O
;	O
cplob_shallow_reset	function
(	O
strar	pointer
->	O
listM	pointer
)	O
;	O
}	O
void	O
strar_close	function
(	O
STRAR	struct
*	O
strar	pointer
)	O
{	O
strob_close	function
(	O
strar	pointer
->	O
storageM	pointer
)	O
;	O
swbis_free	O
(	O
cplob_release	function
(	O
strar	pointer
->	O
listM	pointer
)	O
)	O
;	O
swbis_free	O
(	O
strar	pointer
)	O
;	O
return	O
;	O
}	O
int	O
strar_num_elements	function
(	O
STRAR	struct
*	O
strar	pointer
)	O
{	O
return	O
strar	pointer
->	O
nsM	int
;	O
}	O
char	O
*	O
strar_get	function
(	O
STRAR	struct
*	O
strar	pointer
,	O
int	O
index	function
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
index	function
>=	O
strar	pointer
->	O
nsM	int
||	O
index	function
<	O
0	int
)	O
return	O
NULL	O
;	O
s	pointer
=	O
cplob_val	function
(	O
strar	pointer
->	O
listM	pointer
,	O
index	function
)	O
;	O
return	O
s	pointer
;	O
}	O
char	O
*	O
strar_return_store	function
(	O
STRAR	struct
*	O
strar	pointer
,	O
int	O
len	int
)	O
{	O
char	O
*	O
oldbase	pointer
;	O
char	O
*	O
base	pointer
;	O
char	O
*	O
last	pointer
;	O
int	O
nused	int
;	O
strar	pointer
->	O
lenM	int
=	O
strar	pointer
->	O
lenM	int
+	O
len	int
+	O
1	int
;	O
oldbase	int
=	O
strob_str	function
(	O
strar	pointer
->	O
storageM	pointer
)	O
;	O
strob_set_memlength	function
(	O
strar	pointer
->	O
storageM	pointer
,	O
strar	pointer
->	O
lenM	int
)	O
;	O
base	int
=	O
strob_str	function
(	O
strar	pointer
->	O
storageM	pointer
)	O
;	O
strar	pointer
->	O
nsM	int
++	O
;	O
if	O
(	O
base	int
!=	O
oldbase	int
)	O
{	O
int	O
index	function
=	O
0	int
;	O
char	O
*	O
p	pointer
;	O
while	O
(	O
(	O
p	pointer
=	O
cplob_val	function
(	O
strar	pointer
->	O
listM	pointer
,	O
index	function
)	O
)	O
)	O
{	O
cplob_additem	function
(	O
strar	pointer
->	O
listM	pointer
,	O
index	function
,	O
base	pointer
+	O
(	O
(	O
int	O
)	O
(	O
p	pointer
-	O
oldbase	int
)	O
)	O
)	O
;	O
index	function
++	O
;	O
}	O
}	O
nused	pointer
=	O
cplob_get_nused	function
(	O
strar	pointer
->	O
listM	pointer
)	O
-	O
1	int
;	O
if	O
(	O
nused	int
>	O
0	int
)	O
{	O
last	pointer
=	O
cplob_val	function
(	O
strar	pointer
->	O
listM	int
,	O
nused	int
-	O
1	int
)	O
;	O
}	O
else	O
{	O
last	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
last	pointer
)	O
{	O
last	pointer
=	O
last	pointer
+	O
strlen	function
(	O
last	pointer
)	O
+	O
1	int
;	O
}	O
else	O
{	O
last	pointer
=	O
base	pointer
;	O
}	O
cplob_add_nta	function
(	O
strar	pointer
->	O
listM	pointer
,	O
last	int
)	O
;	O
memset	function
(	O
last	pointer
,	O
(	O
int	O
)	O
'_'	O
,	O
len	int
)	O
;	O
*	O
(	O
last	pointer
+	O
len	int
)	O
=	O
'\0'	O
;	O
return	O
last	pointer
;	O
}	O
int	O
strar_add	function
(	O
STRAR	struct
*	O
strar	pointer
,	O
char	O
*	O
src	pointer
)	O
{	O
char	O
*	O
last	pointer
;	O
last	pointer
=	O
strar_return_store	function
(	O
strar	pointer
,	O
strlen	function
(	O
src	pointer
)	O
)	O
;	O
strcpy	function
(	O
last	pointer
,	O
src	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
strar_qsort	function
(	O
STRAR	struct
*	O
strar	pointer
,	O
int	O
(	O
*	O
f_comp	pointer
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
{	O
size_t	long
nused	long
;	O
nused	long
=	O
(	O
size_t	long
)	O
cplob_get_nused	function
(	O
strar	pointer
->	O
listM	pointer
)	O
-	O
1	int
;	O
std_quicksort	function
(	O
strar	pointer
->	O
listM	pointer
->	O
list	pointer
,	O
(	O
size_t	long
)	O
nused	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
f_comp	pointer
)	O
;	O
}	O
int	O
strar_qsort_neg_strcmp	function
(	O
const	O
void	O
*	O
vf1	pointer
,	O
const	O
void	O
*	O
vf2	pointer
)	O
{	O
return	O
f_strcmp	function
(	O
-	O
1	int
,	O
vf1	pointer
,	O
vf2	pointer
)	O
;	O
}	O
int	O
strar_qsort_strcmp	function
(	O
const	O
void	O
*	O
vf1	pointer
,	O
const	O
void	O
*	O
vf2	pointer
)	O
{	O
return	O
f_strcmp	function
(	O
1	int
,	O
vf1	pointer
,	O
vf2	pointer
)	O
;	O
}	O
void	O
strar_remove_index	function
(	O
STRAR	struct
*	O
strar	pointer
,	O
int	O
index	function
)	O
{	O
cplob_remove_index	function
(	O
strar	pointer
->	O
listM	pointer
,	O
index	function
)	O
;	O
strar	pointer
->	O
nsM	int
--	O
;	O
}	O
static	O
void	O
free_entry	function
(	O
swacfl_entry	struct
*	O
en	pointer
)	O
;	O
SWACFL	struct
*	O
swacfl_open	function
(	O
)	O
{	O
SWACFL	struct
*	O
swacfl	pointer
=	O
(	O
SWACFL	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
SWACFL	struct
)	O
)	O
;	O
if	O
(	O
!	O
swacfl	pointer
)	O
return	O
NULL	O
;	O
swacfl	pointer
->	O
entry_array_	pointer
=	O
cplob_open	function
(	O
8	int
)	O
;	O
cplob_additem	function
(	O
swacfl	pointer
->	O
entry_array_	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
return	O
swacfl	pointer
;	O
}	O
void	O
swacfl_close	function
(	O
SWACFL	struct
*	O
swacfl	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
swacfl_entry	struct
*	O
en	pointer
;	O
while	O
(	O
(	O
en	pointer
=	O
(	O
swacfl_entry	struct
*	O
)	O
cplob_val	function
(	O
swacfl	pointer
->	O
entry_array_	pointer
,	O
i	int
++	O
)	O
)	O
)	O
{	O
free_entry	function
(	O
en	pointer
)	O
;	O
}	O
cplob_close	function
(	O
swacfl	pointer
->	O
entry_array_	pointer
)	O
;	O
}	O
static	O
void	O
free_entry	function
(	O
swacfl_entry	struct
*	O
en	pointer
)	O
{	O
strob_close	function
(	O
en	pointer
->	O
archiveNameM	pointer
)	O
;	O
if	O
(	O
en	pointer
->	O
from_name_	pointer
)	O
swbis_free	O
(	O
en	pointer
->	O
from_name_	pointer
)	O
;	O
}	O
swacfl_entry	struct
*	O
swacfl_find_entry	function
(	O
SWACFL	struct
*	O
swacfl	pointer
,	O
char	O
*	O
archive_name	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
swacfl_entry	struct
*	O
en	pointer
;	O
char	O
*	O
p	pointer
;	O
archive_name	pointer
=	O
swlib_return_no_leading	function
(	O
archive_name	pointer
)	O
;	O
while	O
(	O
(	O
en	pointer
=	O
(	O
swacfl_entry	struct
*	O
)	O
cplob_val	function
(	O
swacfl	pointer
->	O
entry_array_	pointer
,	O
i	int
++	O
)	O
)	O
)	O
{	O
p	int
=	O
strob_str	function
(	O
en	pointer
->	O
archiveNameM	pointer
)	O
;	O
p	pointer
=	O
swlib_return_no_leading	function
(	O
p	pointer
)	O
;	O
if	O
(	O
swlib_compare_8859	function
(	O
archive_name	pointer
,	O
p	pointer
)	O
==	O
0	int
)	O
return	O
en	pointer
;	O
}	O
return	O
(	O
swacfl_entry	struct
*	O
)	O
NULL	O
;	O
}	O
void	O
swacfl_add	function
(	O
SWACFL	struct
*	O
swacfl	pointer
,	O
char	O
*	O
archive_name	pointer
,	O
char	O
*	O
source_name	pointer
,	O
int	O
type	int
)	O
{	O
E_DEBUG3	function
(	O
" archive_name=[%s] source_name=[%s]"	pointer
,	O
archive_name	pointer
,	O
source_name	pointer
)	O
;	O
swacfl_entry	struct
*	O
en	pointer
=	O
swacfl_make_entry	function
(	O
archive_name	pointer
,	O
source_name	pointer
,	O
type	int
)	O
;	O
swacfl_add_entry	function
(	O
swacfl	pointer
,	O
en	pointer
)	O
;	O
}	O
void	O
swacfl_add_entry	function
(	O
SWACFL	struct
*	O
swacfl	pointer
,	O
swacfl_entry	struct
*	O
en	pointer
)	O
{	O
CPLOB	struct
*	O
lob	pointer
=	O
swacfl	pointer
->	O
entry_array_	pointer
;	O
cplob_additem	function
(	O
lob	pointer
,	O
cplob_get_nused	function
(	O
lob	pointer
)	O
-	O
1	int
,	O
(	O
char	O
*	O
)	O
en	pointer
)	O
;	O
cplob_additem	function
(	O
lob	pointer
,	O
cplob_get_nused	function
(	O
lob	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
swacfl_entry	struct
*	O
swacfl_make_entry	function
(	O
char	O
*	O
archive_name	pointer
,	O
char	O
*	O
source_name	pointer
,	O
int	O
type	int
)	O
{	O
swacfl_entry	struct
*	O
en	pointer
=	O
(	O
swacfl_entry	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
swacfl_entry	O
)	O
)	O
;	O
en	pointer
->	O
archiveNameM	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
strob_strcpy	function
(	O
en	pointer
->	O
archiveNameM	pointer
,	O
archive_name	pointer
)	O
;	O
en	pointer
->	O
from_name_	pointer
=	O
swlib_strdup	function
(	O
source_name	pointer
)	O
;	O
en	pointer
->	O
source_code_	int
=	O
type	int
;	O
return	O
en	pointer
;	O
}	O
void	O
swacfl_set_source_name	function
(	O
swacfl_entry	struct
*	O
en	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
en	pointer
->	O
from_name_	pointer
)	O
swbis_free	O
(	O
en	pointer
->	O
from_name_	pointer
)	O
;	O
en	pointer
->	O
from_name_	pointer
=	O
swlib_strdup	function
(	O
name	pointer
)	O
;	O
}	O
o__inline__	O
void	O
swacfl_set_type	function
(	O
swacfl_entry	struct
*	O
en	pointer
,	O
int	O
type	int
)	O
{	O
en	pointer
->	O
source_code_	int
=	O
type	int
;	O
}	O
o__inline__	O
char	O
*	O
swacfl_get_archive_name	function
(	O
swacfl_entry	struct
*	O
en	pointer
)	O
{	O
return	O
strob_str	function
(	O
en	pointer
->	O
archiveNameM	pointer
)	O
;	O
}	O
o__inline__	O
char	O
*	O
swacfl_get_source_name	function
(	O
swacfl_entry	struct
*	O
en	pointer
)	O
{	O
return	O
en	pointer
->	O
from_name_	pointer
;	O
}	O
o__inline__	O
int	O
swacfl_get_type	function
(	O
swacfl_entry	struct
*	O
en	pointer
)	O
{	O
return	O
en	pointer
->	O
source_code_	pointer
;	O
}	O
const	O
struct	O
swintl_lang_map	struct
swintl_lang_table	array
[	O
]	O
=	O
{	O
{	O
"C"	pointer
,	O
""	pointer
}	O
,	O
{	O
"da"	pointer
,	O
"Danish"	int
}	O
,	O
{	O
"de"	pointer
,	O
"German"	int
}	O
,	O
{	O
"cs"	pointer
,	O
"Czech"	int
}	O
,	O
{	O
"en"	pointer
,	O
"English"	int
}	O
,	O
{	O
"es"	pointer
,	O
"Spanish"	int
}	O
,	O
{	O
"fi"	pointer
,	O
"Finnish"	int
}	O
,	O
{	O
"fr"	pointer
,	O
"French"	int
}	O
,	O
{	O
"hy"	pointer
,	O
"Armenian"	int
}	O
,	O
{	O
"hr"	pointer
,	O
"Croatian"	int
}	O
,	O
{	O
"hu"	pointer
,	O
"Hungarian"	int
}	O
,	O
{	O
"in"	pointer
,	O
"Indonesian"	int
}	O
,	O
{	O
"is"	pointer
,	O
"Icelandic"	int
}	O
,	O
{	O
"it"	pointer
,	O
"Italian"	int
}	O
,	O
{	O
"iw"	pointer
,	O
"Hebrew"	int
}	O
,	O
{	O
"ja"	pointer
,	O
"Japanese"	int
}	O
,	O
{	O
"ji"	pointer
,	O
"Yiddish"	int
}	O
,	O
{	O
"jw"	pointer
,	O
"Javanese"	int
}	O
,	O
{	O
"ko"	pointer
,	O
"Korean"	int
}	O
,	O
{	O
"no"	pointer
,	O
"Norwegian"	int
}	O
,	O
{	O
"pl"	pointer
,	O
"Polish"	int
}	O
,	O
{	O
"pt"	pointer
,	O
"Portuguese"	int
}	O
,	O
{	O
"pt_BR"	pointer
,	O
"pt_BR"	int
}	O
,	O
{	O
"ru"	pointer
,	O
"Russian"	int
}	O
,	O
{	O
"sk"	pointer
,	O
"Slovak"	int
}	O
,	O
{	O
"sv"	pointer
,	O
"Swedish"	int
}	O
,	O
{	O
"tr"	pointer
,	O
"Turkish"	int
}	O
,	O
{	O
"zh"	pointer
,	O
"Chinese"	pointer
}	O
,	O
{	O
(	O
char	O
*	O
)	O
NULL	O
,	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
}	O
}	O
;	O
char	O
*	O
swintl_get_lang_code	function
(	O
char	O
*	O
lang_name	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
swintl_lang_table	pointer
[	O
i	int
]	O
.	O
language_code_	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
lang_name	pointer
,	O
swintl_lang_table	pointer
[	O
i	int
]	O
.	O
language_name_	pointer
)	O
)	O
return	O
swintl_lang_table	pointer
[	O
i	int
]	O
.	O
language_code_	int
;	O
i	int
++	O
;	O
}	O
return	O
NULL	O
;	O
}	O
char	O
*	O
swintl_get_lang_name	function
(	O
char	O
*	O
lang_code	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
swintl_lang_table	pointer
[	O
i	int
]	O
.	O
language_code_	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
lang_code	pointer
,	O
swintl_lang_table	pointer
[	O
i	int
]	O
.	O
language_code_	pointer
)	O
)	O
return	O
swintl_lang_table	pointer
[	O
i	int
]	O
.	O
language_name_	int
;	O
i	int
++	O
;	O
}	O
return	O
NULL	O
;	O
}	O
int	O
swlib_rpmvercmp	function
(	O
const	O
char	O
*	O
a	pointer
,	O
const	O
char	O
*	O
b	pointer
)	O
{	O
char	O
oldch1	int
,	O
oldch2	pointer
;	O
char	O
*	O
str1	pointer
,	O
*	O
str2	pointer
;	O
char	O
*	O
one	function
,	O
*	O
two	pointer
;	O
int	O
rc	int
;	O
int	O
isnum	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
a	pointer
,	O
b	pointer
)	O
)	O
return	O
0	int
;	O
str1	pointer
=	O
alloca	function
(	O
strlen	function
(	O
a	pointer
)	O
+	O
1	int
)	O
;	O
str2	pointer
=	O
alloca	function
(	O
strlen	function
(	O
b	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
str1	pointer
,	O
a	pointer
)	O
;	O
strcpy	function
(	O
str2	pointer
,	O
b	pointer
)	O
;	O
one	int
=	O
str1	pointer
;	O
two	pointer
=	O
str2	pointer
;	O
while	O
(	O
*	O
one	int
&&	O
*	O
two	pointer
)	O
{	O
while	O
(	O
*	O
one	int
&&	O
!	O
xisalnum	function
(	O
*	O
one	pointer
)	O
)	O
one	int
++	O
;	O
while	O
(	O
*	O
two	pointer
&&	O
!	O
xisalnum	function
(	O
*	O
two	pointer
)	O
)	O
two	int
++	O
;	O
str1	pointer
=	O
one	function
;	O
str2	pointer
=	O
two	int
;	O
if	O
(	O
xisdigit	function
(	O
*	O
str1	pointer
)	O
)	O
{	O
while	O
(	O
*	O
str1	pointer
&&	O
xisdigit	function
(	O
*	O
str1	pointer
)	O
)	O
str1	pointer
++	O
;	O
while	O
(	O
*	O
str2	pointer
&&	O
xisdigit	function
(	O
*	O
str2	pointer
)	O
)	O
str2	pointer
++	O
;	O
isnum	int
=	O
1	int
;	O
}	O
else	O
{	O
while	O
(	O
*	O
str1	pointer
&&	O
xisalpha	function
(	O
*	O
str1	pointer
)	O
)	O
str1	pointer
++	O
;	O
while	O
(	O
*	O
str2	pointer
&&	O
xisalpha	function
(	O
*	O
str2	pointer
)	O
)	O
str2	pointer
++	O
;	O
isnum	int
=	O
0	int
;	O
}	O
oldch1	enum
=	O
*	O
str1	pointer
;	O
*	O
str1	pointer
=	O
'\0'	O
;	O
oldch2	pointer
=	O
*	O
str2	pointer
;	O
*	O
str2	pointer
=	O
'\0'	O
;	O
if	O
(	O
one	int
==	O
str1	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
two	pointer
==	O
str2	pointer
)	O
return	O
(	O
isnum	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
if	O
(	O
isnum	int
)	O
{	O
while	O
(	O
*	O
one	int
==	O
'0'	O
)	O
one	int
++	O
;	O
while	O
(	O
*	O
two	pointer
==	O
'0'	O
)	O
two	int
++	O
;	O
if	O
(	O
strlen	function
(	O
one	int
)	O
>	O
strlen	function
(	O
two	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strlen	function
(	O
two	pointer
)	O
>	O
strlen	function
(	O
one	int
)	O
)	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
strcmp	function
(	O
one	pointer
,	O
two	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
*	O
str1	pointer
=	O
oldch1	pointer
;	O
one	int
=	O
str1	pointer
;	O
*	O
str2	pointer
=	O
oldch2	pointer
;	O
two	pointer
=	O
str2	pointer
;	O
}	O
if	O
(	O
(	O
!	O
*	O
one	function
)	O
&&	O
(	O
!	O
*	O
two	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
*	O
one	pointer
)	O
return	O
-	O
1	int
;	O
else	O
return	O
1	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
char	O
line	array
[	O
LINELEN	int
]	O
,	O
*	O
t	pointer
;	O
int	O
c	int
;	O
int	O
debugmode	int
=	O
0	int
;	O
struct	O
stat	struct
st	struct
;	O
int	O
format	int
=	O
arf_ustar	int
;	O
XFORMAT	struct
*	O
xxformat	pointer
;	O
char	O
*	O
name	pointer
,	O
*	O
source	pointer
;	O
char	O
*	O
statname	pointer
;	O
char	O
*	O
s	pointer
;	O
while	O
(	O
1	int
)	O
{	O
int	O
option_index	int
=	O
0	int
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
c	int
=	O
ugetopt_long	function
(	O
argc	pointer
,	O
argv	pointer
,	O
"DH:"	pointer
,	O
long_options	array
,	O
&	O
option_index	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'D'	O
:	O
debugmode	int
=	O
1	int
;	O
break	O
;	O
case	O
'H'	O
:	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"ustar"	pointer
)	O
)	O
{	O
format	pointer
=	O
arf_ustar	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"newc"	pointer
)	O
)	O
{	O
format	int
=	O
arf_newascii	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"crc"	pointer
)	O
)	O
{	O
format	pointer
=	O
arf_crcascii	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"odc"	pointer
)	O
)	O
{	O
format	int
=	O
arf_oldascii	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"unrecognized format: %s\n"	pointer
,	O
optarg	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
break	O
;	O
}	O
}	O
xxformat	int
=	O
xformat_open	function
(	O
-	O
1	int
,	O
STDOUT_FILENO	int
,	O
format	pointer
)	O
;	O
while	O
(	O
fgets	function
(	O
line	array
,	O
LINELEN	int
-	O
1	int
,	O
stdin	pointer
)	O
!=	O
(	O
char	O
*	O
)	O
(	O
NULL	O
)	O
)	O
{	O
if	O
(	O
strlen	function
(	O
line	array
)	O
>=	O
LINELEN	int
-	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"filesize: line too long : %s\n"	pointer
,	O
line	array
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
t	pointer
=	O
strpbrk	function
(	O
line	array
,	O
"\n\r"	pointer
)	O
)	O
)	O
{	O
*	O
t	pointer
=	O
'\0'	O
;	O
}	O
if	O
(	O
strlen	function
(	O
line	array
)	O
)	O
{	O
if	O
(	O
(	O
s	pointer
=	O
strchr	function
(	O
line	array
,	O
' '	O
)	O
)	O
)	O
{	O
*	O
s	pointer
=	O
'\0'	O
;	O
source	pointer
=	O
++	O
s	pointer
;	O
name	pointer
=	O
line	pointer
;	O
statname	int
=	O
source	pointer
;	O
}	O
else	O
{	O
name	pointer
=	O
line	pointer
;	O
source	pointer
=	O
NULL	O
;	O
statname	pointer
=	O
line	pointer
;	O
}	O
if	O
(	O
lstat	function
(	O
statname	pointer
,	O
&	O
st	struct
)	O
==	O
0	int
)	O
{	O
xformat_write_file	function
(	O
xxformat	pointer
,	O
&	O
st	pointer
,	O
name	pointer
,	O
source	int
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"list2tar: lstat %s %s\n"	pointer
,	O
name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
}	O
}	O
xformat_write_trailer	function
(	O
xxformat	pointer
)	O
;	O
xformat_close	function
(	O
xxformat	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
int	O
yydebug	int
=	O
0	int
;	O
int	O
swlex_definition_file	int
=	O
SW_INFO	int
;	O
YYSTYPE	enum
yylval	pointer
;	O
static	O
int	O
usage	function
(	O
char	O
*	O
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
ret	int
=	O
0	int
,	O
fd	int
,	O
c	int
=	O
0	int
;	O
char	O
typestring	array
[	O
12	int
]	O
;	O
char	O
*	O
progname	pointer
;	O
int	O
posix_ignores	int
=	O
0	int
;	O
swparse_atlevel	int
=	O
0	int
;	O
progname	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
swparse_form_flag	int
=	O
0	int
;	O
swparse_form_flag	int
|=	O
SWPARSE_FORM_MKUP	int
;	O
yylval	struct
.	O
strb	pointer
=	O
strob_open	function
(	O
8	int
)	O
;	O
if	O
(	O
!	O
yylval	pointer
.	O
strb	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
" swparse: object allocation error.\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
usage	function
(	O
progname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
int	O
option_index	int
=	O
0	int
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"indent"	pointer
,	O
0	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"index"	pointer
,	O
0	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"info"	pointer
,	O
0	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"psf"	pointer
,	O
0	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"option"	pointer
,	O
0	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"psfi"	pointer
,	O
0	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"PSF"	pointer
,	O
0	int
,	O
0	int
,	O
'p'	O
}	O
,	O
{	O
"INFO"	pointer
,	O
0	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"INDEX"	pointer
,	O
0	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"debug"	pointer
,	O
0	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"level"	pointer
,	O
1	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"installed"	pointer
,	O
0	int
,	O
0	int
,	O
200	int
}	O
,	O
{	O
"INSTALLED"	pointer
,	O
0	int
,	O
0	int
,	O
200	int
}	O
,	O
{	O
"with-line-lengths"	pointer
,	O
0	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"posix-ignores"	pointer
,	O
0	int
,	O
0	int
,	O
'g'	O
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
0	int
,	O
'_'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
c	int
=	O
ugetopt_long	function
(	O
argc	pointer
,	O
argv	pointer
,	O
"hdbiopvgl:n_"	pointer
,	O
long_options	array
,	O
&	O
option_index	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'b'	O
:	O
swparse_form_flag	int
&=	O
~	O
SWPARSE_FORM_ALL	int
;	O
swparse_form_flag	int
|=	O
SWPARSE_FORM_INDENT	int
;	O
break	O
;	O
case	O
'h'	O
:	O
swlex_definition_file	int
=	O
SW_PSF_INCL	int
;	O
strncpy	function
(	O
typestring	pointer
,	O
"PSFi"	pointer
,	O
5	int
)	O
;	O
break	O
;	O
case	O
200	int
:	O
swlex_definition_file	int
=	O
SW_INSTALLED	int
;	O
strcpy	function
(	O
typestring	pointer
,	O
"INSTALLED"	pointer
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
swlex_definition_file	int
=	O
SW_INDEX	int
;	O
strncpy	function
(	O
typestring	pointer
,	O
"INDEX"	pointer
,	O
6	int
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
posix_ignores	int
=	O
1	int
;	O
swparse_form_flag	int
|=	O
SWPARSE_FORM_POLICY_POSIX_IGNORES	int
;	O
break	O
;	O
case	O
'o'	O
:	O
swlex_definition_file	int
=	O
SW_INFO	int
;	O
strncpy	function
(	O
typestring	pointer
,	O
"INFO"	pointer
,	O
5	int
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
swlex_definition_file	int
=	O
SW_OPTION	int
;	O
strcpy	function
(	O
typestring	pointer
,	O
"OPTION"	pointer
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
swlex_definition_file	int
=	O
SW_PSF	int
;	O
strncpy	function
(	O
typestring	pointer
,	O
"PSF"	pointer
,	O
4	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
if	O
(	O
!	O
optarg	pointer
)	O
usage	function
(	O
progname	pointer
)	O
;	O
swparse_atlevel	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
yydebug	int
=	O
1	int
;	O
swlex_debug	int
=	O
1	int
;	O
swparse_debug	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
swparse_form_flag	int
&=	O
~	O
SWPARSE_FORM_ALL	int
;	O
swparse_form_flag	int
|=	O
SWPARSE_FORM_MKUP_LEN	int
;	O
break	O
;	O
case	O
'_'	O
:	O
usage	function
(	O
progname	pointer
)	O
;	O
break	O
;	O
case	O
':'	O
:	O
usage	function
(	O
progname	pointer
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
usage	function
(	O
progname	pointer
)	O
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
progname	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
fd	int
=	O
open	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s : %s\n"	pointer
,	O
argv	pointer
[	O
optind	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
swlib_strncpy	function
(	O
swlex_filename	array
,	O
argv	array
[	O
optind	int
]	O
,	O
sizeof	O
(	O
swlex_filename	array
)	O
)	O
;	O
}	O
else	O
{	O
fd	int
=	O
STDIN_FILENO	int
;	O
swlib_strncpy	function
(	O
swlex_filename	array
,	O
"stdin"	pointer
,	O
sizeof	O
(	O
swlex_filename	array
)	O
)	O
;	O
}	O
swlex_inputfd	int
=	O
uxfio_opendup	function
(	O
fd	int
,	O
UXFIO_BUFTYPE_MEM	int
)	O
;	O
if	O
(	O
swlex_inputfd	int
<	O
0	int
)	O
{	O
exit	function
(	O
8	int
)	O
;	O
}	O
if	O
(	O
uxfio_fcntl	function
(	O
swlex_inputfd	pointer
,	O
UXFIO_F_SET_BUFACTIVE	pointer
,	O
0	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
" error in uxfio_fcntl.\n"	pointer
)	O
;	O
}	O
swparse_outputfd	int
=	O
uxfio_opendup	function
(	O
STDOUT_FILENO	int
,	O
0	int
)	O
;	O
if	O
(	O
swparse_outputfd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
" error in uxfio_open.\n"	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
if	O
(	O
uxfio_fcntl	function
(	O
swparse_outputfd	pointer
,	O
UXFIO_F_SET_BUFACTIVE	pointer
,	O
0	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
" error in uxfio_fcntl.\n"	pointer
)	O
;	O
}	O
ret	int
=	O
sw_yyparse	function
(	O
swlex_inputfd	pointer
,	O
swparse_outputfd	pointer
,	O
typestring	pointer
,	O
0	int
,	O
swparse_form_flag	int
)	O
;	O
strob_close	function
(	O
yylval	struct
.	O
strb	pointer
)	O
;	O
_exit	function
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
usage	function
(	O
char	O
*	O
progname	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"A POSIX-7.2 Metadata parser (A de-facto Implementation Extension utility).\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Copyright (C) 2005 James Lowe, Jr.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"This software is distributed under the GNU GPLv2.\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Usage: sw_parse {--installed|-i,--index|-o,--info|-p,--psf|-d,--option}\n"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"       [-level|-l level] [-with-line-lengths|-n] [-b|beautify][file]\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
int	O
taru_format_translate	function
(	O
int	O
ifd	int
,	O
int	O
ofd	int
,	O
enum	O
archive_format	enum
output_format	enum
)	O
{	O
int	O
parent	int
;	O
int	O
fpipe	array
[	O
2	int
]	O
;	O
int	O
status	int
=	O
0	int
,	O
ret	int
=	O
0	int
;	O
DEFER	struct
*	O
defer	pointer
=	O
NULL	O
;	O
TARU	struct
*	O
taru	pointer
=	O
taru_create	function
(	O
)	O
;	O
pipe	function
(	O
fpipe	struct
)	O
;	O
parent	pointer
=	O
swfork	function
(	O
(	O
sigset_t	struct
*	O
)	O
(	O
NULL	O
)	O
)	O
;	O
if	O
(	O
parent	pointer
==	O
0	int
)	O
{	O
close	pointer
(	O
fpipe	array
[	O
0	int
]	O
)	O
;	O
_exit	function
(	O
taru_process_copy_in	function
(	O
NULL	O
,	O
ifd	O
,	O
fpipe	array
[	O
1	int
]	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
parent	int
>	O
0	int
)	O
{	O
close	pointer
(	O
fpipe	array
[	O
1	int
]	O
)	O
;	O
ret	int
=	O
taru_process_copy_out	function
(	O
taru	pointer
,	O
fpipe	array
[	O
0	int
]	O
,	O
ofd	int
,	O
defer	int
,	O
NULL	O
,	O
output_format	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
(	O
intmax_t	long
*	O
)	O
NULL	O
,	O
NULL	O
)	O
;	O
while	O
(	O
!	O
waitpid	function
(	O
(	O
pid_t	int
)	O
parent	pointer
,	O
&	O
status	int
,	O
WNOHANG	int
)	O
)	O
{	O
;	O
}	O
if	O
(	O
!	O
status	int
&&	O
!	O
ret	int
)	O
return	O
0	int
;	O
}	O
else	O
{	O
return	O
-	O
3	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
print_dig	function
(	O
int	O
nofile	int
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
digtype	pointer
,	O
char	O
*	O
md5	pointer
,	O
char	O
*	O
sha1	pointer
,	O
char	O
*	O
sha512	pointer
)	O
{	O
if	O
(	O
nofile	int
==	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
digtype	pointer
,	O
"md5"	pointer
)	O
==	O
0	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"%s  %s\n"	pointer
,	O
md5	pointer
,	O
name	pointer
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
digtype	pointer
,	O
"sha512"	pointer
)	O
==	O
0	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"%s  %s\n"	pointer
,	O
sha512	pointer
,	O
name	pointer
)	O
;	O
else	O
fprintf	function
(	O
stdout	pointer
,	O
"%s  %s\n"	pointer
,	O
sha1	pointer
,	O
name	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
strcmp	function
(	O
digtype	pointer
,	O
"md5"	pointer
)	O
==	O
0	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"%s\n"	pointer
,	O
md5	O
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
digtype	pointer
,	O
"sha512"	pointer
)	O
==	O
0	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"%s\n"	pointer
,	O
sha512	pointer
)	O
;	O
else	O
fprintf	function
(	O
stdout	pointer
,	O
"%s\n"	pointer
,	O
sha1	array
)	O
;	O
}	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
fd	int
;	O
int	O
ret	int
=	O
0	int
;	O
int	O
nofile	int
=	O
0	int
;	O
char	O
digest	array
[	O
100	int
]	O
;	O
char	O
sha1	array
[	O
100	int
]	O
;	O
char	O
sha512	array
[	O
129	int
]	O
;	O
char	O
*	O
name	pointer
;	O
digest	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
sha1	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
1	int
+	O
nofile	int
]	O
,	O
"--no-name"	pointer
)	O
==	O
0	int
)	O
{	O
nofile	int
=	O
1	int
;	O
}	O
if	O
(	O
argc	int
<	O
2	int
+	O
nofile	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"testdigests [--no-name] {md5|sha1|sha512} file\n"	pointer
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
if	O
(	O
argc	int
<	O
3	int
+	O
nofile	int
||	O
strcmp	function
(	O
argv	pointer
[	O
2	int
+	O
nofile	int
]	O
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
fd	array
=	O
STDIN_FILENO	int
;	O
name	pointer
=	O
"-"	pointer
;	O
ret	int
=	O
swlib_digests	function
(	O
fd	int
,	O
digest	pointer
,	O
sha1	array
,	O
NULL	O
,	O
sha512	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error %d\n"	pointer
,	O
ret	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
print_dig	function
(	O
nofile	pointer
,	O
name	pointer
,	O
argv	array
[	O
1	int
+	O
nofile	int
]	O
,	O
digest	pointer
,	O
sha1	array
,	O
sha512	array
)	O
;	O
}	O
else	O
{	O
int	O
i	int
;	O
i	int
=	O
0	int
;	O
while	O
(	O
argv	pointer
[	O
2	int
+	O
nofile	int
+	O
i	int
]	O
!=	O
NULL	O
)	O
{	O
struct	O
stat	struct
st	struct
;	O
fd	int
=	O
open	function
(	O
argv	pointer
[	O
2	int
+	O
nofile	int
+	O
i	int
]	O
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
fstat	function
(	O
fd	int
,	O
&	O
st	struct
)	O
;	O
name	pointer
=	O
argv	pointer
[	O
2	int
+	O
nofile	int
+	O
i	int
]	O
;	O
if	O
(	O
!	O
S_ISREG	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s not regular file\n"	pointer
,	O
name	pointer
)	O
;	O
i	int
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
fd	int
<	O
0	int
)	O
exit	function
(	O
2	int
)	O
;	O
ret	int
=	O
swlib_digests	function
(	O
fd	int
,	O
digest	pointer
,	O
sha1	array
,	O
NULL	O
,	O
sha512	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error %d\n"	pointer
,	O
ret	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
close	function
(	O
fd	int
)	O
;	O
print_dig	function
(	O
nofile	pointer
,	O
name	pointer
,	O
argv	pointer
[	O
1	int
+	O
nofile	int
]	O
,	O
digest	pointer
,	O
sha1	array
,	O
sha512	O
)	O
;	O
i	int
++	O
;	O
}	O
}	O
exit	function
(	O
0	int
)	O
;	O
}	O
static	O
int	O
minLevel	int
=	O
RPMMESS_NORMAL	int
;	O
void	O
rpmIncreaseVerbosity	function
(	O
void	O
)	O
{	O
minLevel	int
--	O
;	O
}	O
void	O
rpmSetVerbosity	function
(	O
int	O
level	int
)	O
{	O
minLevel	int
=	O
level	int
;	O
}	O
int	O
rpmGetVerbosity	function
(	O
void	O
)	O
{	O
return	O
minLevel	int
;	O
}	O
int	O
rpmIsDebug	function
(	O
void	O
)	O
{	O
return	O
(	O
minLevel	int
<=	O
RPMMESS_DEBUG	int
)	O
;	O
}	O
int	O
rpmIsVerbose	function
(	O
void	O
)	O
{	O
return	O
(	O
minLevel	int
<=	O
RPMMESS_VERBOSE	int
)	O
;	O
}	O
void	O
rpmMessage	function
(	O
int	O
level	int
,	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
if	O
(	O
level	int
>=	O
minLevel	int
)	O
{	O
switch	O
(	O
level	int
)	O
{	O
case	O
RPMMESS_VERBOSE	int
:	O
case	O
RPMMESS_NORMAL	int
:	O
vfprintf	function
(	O
stdout	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
RPMMESS_DEBUG	int
:	O
if	O
(	O
*	O
format	pointer
!=	O
'+'	O
)	O
fprintf	function
(	O
stdout	pointer
,	O
"D: "	pointer
)	O
;	O
else	O
format	int
++	O
;	O
vfprintf	function
(	O
stdout	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
break	O
;	O
case	O
RPMMESS_WARNING	int
:	O
if	O
(	O
*	O
format	pointer
!=	O
'+'	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"warning: "	pointer
)	O
)	O
;	O
else	O
format	int
++	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
break	O
;	O
case	O
RPMMESS_ERROR	int
:	O
if	O
(	O
*	O
format	pointer
!=	O
'+'	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"error: "	pointer
)	O
)	O
;	O
else	O
format	pointer
++	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
break	O
;	O
case	O
RPMMESS_FATALERROR	int
:	O
if	O
(	O
*	O
format	pointer
!=	O
'+'	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"fatal error: "	pointer
)	O
)	O
;	O
else	O
format	pointer
++	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"internal error (rpm bug?): "	pointer
)	O
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
pid_t	int
pty_fork	function
(	O
int	O
*	O
ptrfdm	pointer
,	O
char	O
*	O
slave_name	array
,	O
const	O
struct	O
termios	struct
*	O
slave_termios	pointer
,	O
const	O
struct	O
winsize	struct
*	O
slave_winsize	pointer
)	O
{	O
int	O
fdm	int
,	O
fds	pointer
;	O
pid_t	int
pid	int
;	O
char	O
pts_name	array
[	O
20	int
]	O
;	O
if	O
(	O
(	O
fdm	int
=	O
ptym_open	function
(	O
pts_name	pointer
)	O
)	O
<	O
0	int
)	O
err_sys	function
(	O
"can't open master pty: %s"	pointer
,	O
pts_name	pointer
)	O
;	O
if	O
(	O
slave_name	pointer
!=	O
NULL	O
)	O
strcpy	function
(	O
slave_name	array
,	O
pts_name	pointer
)	O
;	O
if	O
(	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
if	O
(	O
setsid	function
(	O
)	O
<	O
0	int
)	O
err_sys	function
(	O
"setsid error"	pointer
)	O
;	O
if	O
(	O
(	O
fds	pointer
=	O
ptys_open	function
(	O
fdm	int
,	O
pts_name	pointer
)	O
)	O
<	O
0	int
)	O
err_sys	function
(	O
"can't open slave pty"	pointer
)	O
;	O
close	function
(	O
fdm	int
)	O
;	O
if	O
(	O
slave_termios	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
tcsetattr	function
(	O
fds	pointer
,	O
TCSANOW	int
,	O
slave_termios	int
)	O
<	O
0	int
)	O
err_sys	function
(	O
"tcsetattr error on slave pty"	pointer
)	O
;	O
}	O
if	O
(	O
slave_winsize	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
ioctl	function
(	O
fds	pointer
,	O
TIOCSWINSZ	int
,	O
slave_winsize	int
)	O
<	O
0	int
)	O
err_sys	function
(	O
"TIOCSWINSZ error on slave pty"	pointer
)	O
;	O
}	O
if	O
(	O
dup2	function
(	O
fds	pointer
,	O
STDIN_FILENO	int
)	O
!=	O
STDIN_FILENO	int
)	O
err_sys	function
(	O
"dup2 error to stdin"	pointer
)	O
;	O
if	O
(	O
dup2	function
(	O
fds	pointer
,	O
STDOUT_FILENO	int
)	O
!=	O
STDOUT_FILENO	int
)	O
err_sys	function
(	O
"dup2 error to stdout"	pointer
)	O
;	O
if	O
(	O
dup2	function
(	O
fds	pointer
,	O
STDERR_FILENO	int
)	O
!=	O
STDERR_FILENO	int
)	O
err_sys	function
(	O
"dup2 error to stderr"	pointer
)	O
;	O
if	O
(	O
fds	pointer
>	O
STDERR_FILENO	int
)	O
close	pointer
(	O
fds	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
*	O
ptrfdm	pointer
=	O
fdm	int
;	O
return	O
(	O
pid	int
)	O
;	O
}	O
}	O
int	O
ptym_open	function
(	O
char	O
*	O
pts_name	pointer
)	O
{	O
int	O
fdm	int
;	O
char	O
*	O
ptr1	pointer
,	O
*	O
ptr2	pointer
;	O
strcpy	function
(	O
pts_name	pointer
,	O
"/dev/ptyXY"	pointer
)	O
;	O
for	O
(	O
ptr1	pointer
=	O
"pqrstuvwxyzPQRST"	pointer
;	O
*	O
ptr1	pointer
!=	O
0	int
;	O
ptr1	pointer
++	O
)	O
{	O
pts_name	array
[	O
8	int
]	O
=	O
*	O
ptr1	pointer
;	O
for	O
(	O
ptr2	pointer
=	O
"0123456789abcdef"	pointer
;	O
*	O
ptr2	pointer
!=	O
0	int
;	O
ptr2	pointer
++	O
)	O
{	O
pts_name	array
[	O
9	int
]	O
=	O
*	O
ptr2	pointer
;	O
if	O
(	O
(	O
fdm	int
=	O
open	function
(	O
pts_name	int
,	O
O_RDWR	int
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
else	O
continue	O
;	O
}	O
pts_name	array
[	O
5	int
]	O
=	O
't'	O
;	O
return	O
(	O
fdm	int
)	O
;	O
}	O
}	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
int	O
ptys_open	function
(	O
int	O
fdm	int
,	O
char	O
*	O
pts_name	pointer
)	O
{	O
struct	O
group	struct
*	O
grptr	pointer
;	O
int	O
gid	int
,	O
fds	pointer
;	O
if	O
(	O
(	O
grptr	pointer
=	O
getgrnam	function
(	O
"tty"	pointer
)	O
)	O
!=	O
NULL	O
)	O
gid	int
=	O
grptr	pointer
->	O
gr_gid	int
;	O
else	O
gid	int
=	O
-	O
1	int
;	O
chown	function
(	O
pts_name	pointer
,	O
getuid	function
(	O
)	O
,	O
gid	int
)	O
;	O
chmod	function
(	O
pts_name	pointer
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IWGRP	O
)	O
;	O
if	O
(	O
(	O
fds	pointer
=	O
open	function
(	O
pts_name	int
,	O
O_RDWR	int
)	O
)	O
<	O
0	int
)	O
{	O
close	function
(	O
fdm	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
return	O
(	O
fds	pointer
)	O
;	O
}	O
static	O
struct	O
termios	struct
save_termios	struct
;	O
static	O
int	O
ttysavefd	int
=	O
-	O
1	int
;	O
static	O
enum	O
{	O
RESET	int
,	O
RAW	int
,	O
CBREAK	int
}	O
ttystate	enum
=	O
RESET	int
;	O
int	O
tty_cbreak	function
(	O
int	O
fd	int
)	O
{	O
struct	O
termios	struct
buf	struct
;	O
if	O
(	O
tcgetattr	function
(	O
fd	int
,	O
&	O
save_termios	struct
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
buf	struct
=	O
save_termios	struct
;	O
buf	struct
.	O
c_lflag	int
&=	O
~	O
(	O
ECHO	int
|	O
ICANON	int
)	O
;	O
buf	struct
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
1	int
;	O
buf	struct
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
0	int
;	O
if	O
(	O
tcsetattr	function
(	O
fd	int
,	O
TCSAFLUSH	int
,	O
&	O
buf	struct
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
ttystate	enum
=	O
CBREAK	int
;	O
ttysavefd	int
=	O
fd	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
tty_raw	function
(	O
int	O
fd	int
)	O
{	O
struct	O
termios	struct
buf	struct
;	O
if	O
(	O
tcgetattr	function
(	O
fd	int
,	O
&	O
save_termios	struct
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
buf	struct
=	O
save_termios	struct
;	O
buf	struct
.	O
c_lflag	int
&=	O
~	O
(	O
ECHO	int
|	O
ICANON	int
|	O
IEXTEN	int
|	O
ISIG	int
)	O
;	O
buf	struct
.	O
c_iflag	int
&=	O
~	O
(	O
BRKINT	int
|	O
ICRNL	int
|	O
INPCK	int
|	O
ISTRIP	int
|	O
IXON	int
)	O
;	O
buf	struct
.	O
c_cflag	int
&=	O
~	O
(	O
CSIZE	int
|	O
PARENB	int
)	O
;	O
buf	struct
.	O
c_cflag	int
|=	O
CS8	int
;	O
buf	struct
.	O
c_oflag	int
&=	O
~	O
(	O
OPOST	int
)	O
;	O
buf	struct
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
1	int
;	O
buf	struct
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
0	int
;	O
if	O
(	O
tcsetattr	function
(	O
fd	int
,	O
TCSAFLUSH	int
,	O
&	O
buf	struct
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
ttystate	enum
=	O
RAW	int
;	O
ttysavefd	int
=	O
fd	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
tty_reset	function
(	O
int	O
fd	int
)	O
{	O
if	O
(	O
ttystate	enum
!=	O
CBREAK	int
&&	O
ttystate	enum
!=	O
RAW	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
tcsetattr	function
(	O
fd	int
,	O
TCSAFLUSH	int
,	O
&	O
save_termios	struct
)	O
<	O
0	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
ttystate	enum
=	O
RESET	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
void	O
tty_atexit	function
(	O
void	O
)	O
{	O
if	O
(	O
ttysavefd	int
>=	O
0	int
)	O
tty_reset	function
(	O
ttysavefd	int
)	O
;	O
}	O
struct	O
termios	struct
*	O
tty_termios	function
(	O
void	O
)	O
{	O
return	O
(	O
&	O
save_termios	struct
)	O
;	O
}	O
unsigned	O
int	O
error_message_count	int
;	O
void	O
(	O
*	O
error_print_progname	pointer
)	O
(	O
)	O
=	O
NULL	O
;	O
extern	O
char	O
*	O
program_name	pointer
;	O
char	O
*	O
strerror	function
(	O
)	O
;	O
void	O
error	function
(	O
status	int
,	O
errnum	int
,	O
message	pointer
,	O
va_alist	pointer
)	O
int	O
status	int
;	O
int	O
errnum	int
;	O
char	O
*	O
message	pointer
;	O
va_dcl	function
{	O
if	O
(	O
error_print_progname	pointer
)	O
(	O
*	O
error_print_progname	pointer
)	O
(	O
)	O
;	O
else	O
{	O
fflush	function
(	O
stdout	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
message	pointer
,	O
a1	pointer
,	O
a2	pointer
,	O
a3	pointer
,	O
a4	pointer
,	O
a5	pointer
,	O
a6	pointer
,	O
a7	pointer
,	O
a8	pointer
)	O
;	O
++	O
error_message_count	int
;	O
if	O
(	O
errnum	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
": %s"	pointer
,	O
strerror	function
(	O
errnum	int
)	O
)	O
;	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
if	O
(	O
status	int
)	O
exit	function
(	O
status	int
)	O
;	O
}	O
char	O
*	O
last_component	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
const	O
*	O
base	pointer
=	O
name	pointer
+	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
char	O
const	O
*	O
p	pointer
;	O
bool	bool
saw_slash	bool
=	O
false	int
;	O
while	O
(	O
ISSLASH	O
(	O
*	O
base	pointer
)	O
)	O
base	pointer
++	O
;	O
for	O
(	O
p	pointer
=	O
base	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
ISSLASH	O
(	O
*	O
p	pointer
)	O
)	O
saw_slash	bool
=	O
true	int
;	O
else	O
if	O
(	O
saw_slash	bool
)	O
{	O
base	pointer
=	O
p	pointer
;	O
saw_slash	bool
=	O
false	int
;	O
}	O
}	O
return	O
(	O
char	O
*	O
)	O
base	pointer
;	O
}	O
size_t	long
base_len	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
size_t	long
len	long
;	O
size_t	long
prefix_len	long
=	O
FILE_SYSTEM_PREFIX_LEN	int
(	O
name	pointer
)	O
;	O
for	O
(	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
1	int
<	O
len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
len	long
-	O
1	int
]	O
)	O
;	O
len	long
--	O
)	O
continue	O
;	O
if	O
(	O
DOUBLE_SLASH_IS_DISTINCT_ROOT	int
&&	O
len	long
==	O
1	int
&&	O
ISSLASH	O
(	O
name	pointer
[	O
0	int
]	O
)	O
&&	O
ISSLASH	O
(	O
name	pointer
[	O
1	int
]	O
)	O
&&	O
!	O
name	pointer
[	O
2	int
]	O
)	O
return	O
2	int
;	O
if	O
(	O
FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE	int
&&	O
prefix_len	long
&&	O
len	long
==	O
prefix_len	long
&&	O
ISSLASH	O
(	O
name	pointer
[	O
prefix_len	long
]	O
)	O
)	O
return	O
prefix_len	long
+	O
1	int
;	O
return	O
len	long
;	O
}	O
int	O
volatile	O
exit_failure	int
=	O
EXIT_FAILURE	int
;	O
const	O
char	O
*	O
locale_charset	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
codeset	pointer
;	O
codeset	pointer
=	O
nl_langinfo	function
(	O
CODESET	int
)	O
;	O
if	O
(	O
codeset	pointer
==	O
NULL	O
)	O
codeset	pointer
=	O
""	pointer
;	O
{	O
{	O
if	O
(	O
codeset	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
codeset	pointer
=	O
"ASCII"	pointer
;	O
}	O
}	O
return	O
codeset	pointer
;	O
}	O
const	O
unsigned	O
int	O
is_basic_table	array
[	O
UCHAR_MAX	O
/	O
32	int
+	O
1	int
]	O
=	O
{	O
0x00001a00	int
,	O
0xffffffef	int
,	O
0xfffffffe	int
,	O
0x7ffffffe	int
}	O
;	O
struct	O
tag_handler	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
size_t	long
len	long
;	O
int	O
(	O
*	O
handler	pointer
)	O
(	O
char	O
*	O
,	O
struct	O
text_buffer	struct
*	O
)	O
;	O
}	O
;	O
struct	O
info_tag	struct
{	O
struct	O
info_tag	struct
*	O
next	pointer
;	O
char	O
*	O
kw	pointer
;	O
char	O
*	O
val	pointer
;	O
}	O
;	O
static	O
void	O
info_tag_free	function
(	O
struct	O
info_tag	struct
*	O
tag	pointer
)	O
{	O
while	O
(	O
tag	pointer
)	O
{	O
struct	O
info_tag	struct
*	O
next	pointer
=	O
tag	pointer
->	O
next	pointer
;	O
free	function
(	O
tag	pointer
->	O
kw	pointer
)	O
;	O
free	function
(	O
tag	pointer
->	O
val	pointer
)	O
;	O
free	function
(	O
tag	pointer
)	O
;	O
tag	pointer
=	O
next	pointer
;	O
}	O
}	O
static	O
struct	O
info_tag	struct
*	O
info_tag_find	function
(	O
struct	O
info_tag	struct
*	O
tag	pointer
,	O
const	O
char	O
*	O
kw	pointer
)	O
{	O
for	O
(	O
;	O
tag	pointer
;	O
tag	pointer
=	O
tag	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
tag	pointer
->	O
kw	pointer
,	O
kw	pointer
)	O
==	O
0	int
)	O
return	O
tag	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
info_tag	struct
*	O
tag_found_keyword	function
(	O
struct	O
text_buffer	struct
*	O
tmpbuf_ptr	pointer
,	O
char	O
*	O
*	O
kw	pointer
)	O
{	O
struct	O
info_tag	struct
*	O
tag	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
tag	pointer
)	O
)	O
;	O
tag	pointer
->	O
next	pointer
=	O
NULL	O
;	O
text_buffer_add_char	function
(	O
tmpbuf_ptr	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
kw	pointer
!=	O
tmpbuf_ptr	pointer
->	O
base	pointer
)	O
{	O
*	O
kw	pointer
=	O
tmpbuf_ptr	pointer
->	O
base	pointer
;	O
}	O
tag	pointer
->	O
kw	pointer
=	O
xstrdup	function
(	O
*	O
kw	pointer
)	O
;	O
tag	pointer
->	O
val	pointer
=	O
xstrdup	function
(	O
*	O
kw	pointer
+	O
strlen	function
(	O
*	O
kw	pointer
)	O
+	O
1	int
)	O
;	O
text_buffer_reset	function
(	O
tmpbuf_ptr	pointer
)	O
;	O
return	O
tag	pointer
;	O
}	O
static	O
int	O
tag_image	function
(	O
char	O
*	O
text	pointer
,	O
struct	O
text_buffer	struct
*	O
outbuf	pointer
)	O
{	O
mbi_iterator_t	struct
iter	struct
;	O
enum	O
{	O
state_kw	int
,	O
state_val	int
,	O
state_qstr	int
,	O
state_delim	int
}	O
state	pointer
=	O
state_kw	int
;	O
struct	O
text_buffer	struct
tmpbuf	struct
;	O
char	O
*	O
kw	pointer
;	O
struct	O
info_tag	struct
*	O
tag_head	pointer
=	O
NULL	O
,	O
*	O
tag	pointer
;	O
int	O
escaped	int
=	O
0	int
;	O
text_buffer_init	function
(	O
&	O
tmpbuf	struct
)	O
;	O
for	O
(	O
mbi_init	O
(	O
iter	pointer
,	O
text	pointer
,	O
strlen	function
(	O
text	pointer
)	O
)	O
;	O
mbi_avail	O
(	O
iter	pointer
)	O
;	O
mbi_advance	O
(	O
iter	pointer
)	O
)	O
{	O
const	O
char	O
*	O
cur_ptr	pointer
;	O
size_t	long
cur_len	long
;	O
if	O
(	O
mb_isspace	O
(	O
mbi_cur	O
(	O
iter	pointer
)	O
)	O
)	O
{	O
if	O
(	O
state	pointer
==	O
state_val	int
)	O
{	O
struct	O
info_tag	struct
*	O
new_kw	pointer
=	O
tag_found_keyword	function
(	O
&	O
tmpbuf	struct
,	O
&	O
kw	pointer
)	O
;	O
new_kw	pointer
->	O
next	pointer
=	O
tag_head	int
;	O
tag_head	int
=	O
new_kw	int
;	O
state	pointer
=	O
state_delim	int
;	O
continue	O
;	O
}	O
if	O
(	O
state	pointer
==	O
state_delim	int
)	O
continue	O
;	O
}	O
else	O
if	O
(	O
state	pointer
==	O
state_delim	int
)	O
state	pointer
=	O
state_kw	int
;	O
cur_len	long
=	O
mb_len	O
(	O
mbi_cur	O
(	O
iter	pointer
)	O
)	O
;	O
cur_ptr	pointer
=	O
mbi_cur_ptr	O
(	O
iter	pointer
)	O
;	O
if	O
(	O
state	pointer
==	O
state_qstr	int
&&	O
escaped	int
)	O
{	O
escaped	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
cur_len	int
==	O
1	int
)	O
{	O
switch	O
(	O
*	O
cur_ptr	pointer
)	O
{	O
case	O
'='	O
:	O
if	O
(	O
state	pointer
!=	O
state_kw	int
)	O
break	O
;	O
text_buffer_add_char	function
(	O
&	O
tmpbuf	struct
,	O
0	int
)	O
;	O
kw	pointer
=	O
tmpbuf	struct
.	O
base	pointer
;	O
if	O
(	O
!	O
mbi_avail	O
(	O
iter	pointer
)	O
)	O
break	O
;	O
mbi_advance	O
(	O
iter	pointer
)	O
;	O
state	pointer
=	O
state_val	int
;	O
cur_len	long
=	O
mb_len	O
(	O
mbi_cur	O
(	O
iter	pointer
)	O
)	O
;	O
cur_ptr	pointer
=	O
mbi_cur_ptr	O
(	O
iter	pointer
)	O
;	O
if	O
(	O
!	O
(	O
cur_len	int
==	O
1	int
&&	O
*	O
cur_ptr	pointer
==	O
'"'	O
)	O
)	O
break	O
;	O
case	O
'"'	O
:	O
if	O
(	O
state	pointer
==	O
state_val	int
)	O
{	O
state	pointer
=	O
state_qstr	int
;	O
continue	O
;	O
}	O
if	O
(	O
state	pointer
==	O
state_qstr	int
)	O
{	O
struct	O
info_tag	struct
*	O
new_kw	pointer
=	O
tag_found_keyword	function
(	O
&	O
tmpbuf	struct
,	O
&	O
kw	pointer
)	O
;	O
new_kw	pointer
->	O
next	pointer
=	O
tag_head	int
;	O
tag_head	int
=	O
new_kw	int
;	O
state	pointer
=	O
state_delim	int
;	O
continue	O
;	O
}	O
break	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
state	pointer
==	O
state_qstr	int
)	O
{	O
escaped	int
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
}	O
text_buffer_add_string	function
(	O
&	O
tmpbuf	O
,	O
cur_ptr	pointer
,	O
cur_len	int
)	O
;	O
}	O
tag	pointer
=	O
info_tag_find	function
(	O
tag_head	pointer
,	O
"text"	pointer
)	O
;	O
if	O
(	O
!	O
tag	pointer
)	O
tag	pointer
=	O
info_tag_find	function
(	O
tag_head	pointer
,	O
"alt"	pointer
)	O
;	O
if	O
(	O
tag	pointer
)	O
{	O
text_buffer_add_string	function
(	O
outbuf	pointer
,	O
tag	pointer
->	O
val	array
,	O
strlen	function
(	O
tag	pointer
->	O
val	array
)	O
)	O
;	O
}	O
text_buffer_free	function
(	O
&	O
tmpbuf	array
)	O
;	O
info_tag_free	function
(	O
tag_head	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
tag_handler	struct
tagtab	array
[	O
]	O
=	O
{	O
{	O
"image"	pointer
,	O
5	int
,	O
tag_image	int
}	O
,	O
{	O
"index"	pointer
,	O
5	int
,	O
NULL	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
tag_handler	struct
*	O
find_tag_handler	function
(	O
char	O
*	O
tag	pointer
,	O
size_t	long
taglen	long
)	O
{	O
struct	O
tag_handler	struct
*	O
tp	pointer
;	O
for	O
(	O
tp	pointer
=	O
tagtab	pointer
;	O
tp	pointer
->	O
name	pointer
;	O
tp	pointer
++	O
)	O
if	O
(	O
taglen	long
>=	O
tp	pointer
->	O
len	long
&&	O
strncmp	function
(	O
tp	pointer
->	O
name	pointer
,	O
tag	pointer
,	O
tp	pointer
->	O
len	long
)	O
==	O
0	int
)	O
return	O
tp	pointer
;	O
return	O
NULL	O
;	O
}	O
int	O
tag_expand	function
(	O
char	O
*	O
*	O
input	pointer
,	O
char	O
*	O
input_end	pointer
,	O
struct	O
text_buffer	struct
*	O
outbuf	pointer
,	O
int	O
*	O
is_index	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
*	O
input	pointer
;	O
char	O
*	O
q	pointer
;	O
size_t	long
len	long
;	O
struct	O
tag_handler	struct
*	O
tp	pointer
;	O
if	O
(	O
p	pointer
>=	O
input_end	pointer
-	O
3	int
||	O
memcmp	function
(	O
p	pointer
,	O
"\0\b["	pointer
,	O
3	int
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
p	pointer
+=	O
3	int
;	O
q	pointer
=	O
p	pointer
+	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
q	pointer
>=	O
input_end	pointer
-	O
3	int
||	O
memcmp	function
(	O
q	pointer
+	O
1	int
,	O
"\b]"	pointer
,	O
2	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
"index"	pointer
,	O
p	pointer
,	O
strlen	function
(	O
"index"	pointer
)	O
)	O
)	O
*	O
is_index	pointer
=	O
1	int
;	O
len	long
=	O
strcspn	function
(	O
p	pointer
,	O
" \t"	pointer
)	O
;	O
tp	pointer
=	O
find_tag_handler	function
(	O
p	pointer
,	O
len	long
)	O
;	O
if	O
(	O
tp	pointer
&&	O
tp	pointer
->	O
handler	pointer
)	O
{	O
while	O
(	O
p	pointer
[	O
len	long
]	O
==	O
' '	O
||	O
p	pointer
[	O
len	long
]	O
==	O
'\t'	O
)	O
++	O
len	long
;	O
tp	pointer
->	O
handler	pointer
(	O
p	pointer
+	O
len	int
,	O
outbuf	pointer
)	O
;	O
}	O
*	O
input	pointer
=	O
q	pointer
+	O
3	int
;	O
return	O
1	int
;	O
}	O
char	O
*	O
tilde_expand_word	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
char	O
*	O
dirname	pointer
=	O
filename	pointer
?	O
xstrdup	function
(	O
filename	pointer
)	O
:	O
NULL	O
;	O
if	O
(	O
dirname	pointer
&&	O
*	O
dirname	pointer
==	O
'~'	O
)	O
{	O
char	O
*	O
temp_name	pointer
;	O
if	O
(	O
!	O
dirname	pointer
[	O
1	int
]	O
||	O
IS_SLASH	O
(	O
dirname	pointer
[	O
1	int
]	O
)	O
)	O
{	O
char	O
*	O
temp_home	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
!	O
temp_home	pointer
)	O
{	O
struct	O
passwd	struct
*	O
entry	pointer
;	O
entry	pointer
=	O
(	O
struct	O
passwd	struct
*	O
)	O
getpwuid	function
(	O
getuid	function
(	O
)	O
)	O
;	O
if	O
(	O
entry	pointer
)	O
temp_home	pointer
=	O
entry	pointer
->	O
pw_dir	pointer
;	O
}	O
temp_name	pointer
=	O
xmalloc	function
(	O
1	int
+	O
strlen	function
(	O
&	O
dirname	pointer
[	O
1	int
]	O
)	O
+	O
(	O
temp_home	int
?	O
strlen	function
(	O
temp_home	pointer
)	O
:	O
0	int
)	O
)	O
;	O
if	O
(	O
temp_home	int
)	O
strcpy	function
(	O
temp_name	pointer
,	O
temp_home	pointer
)	O
;	O
else	O
temp_name	array
[	O
0	int
]	O
=	O
0	int
;	O
strcat	function
(	O
temp_name	pointer
,	O
&	O
dirname	array
[	O
1	int
]	O
)	O
;	O
free	function
(	O
dirname	pointer
)	O
;	O
dirname	pointer
=	O
xstrdup	function
(	O
temp_name	pointer
)	O
;	O
free	function
(	O
temp_name	pointer
)	O
;	O
}	O
else	O
{	O
struct	O
passwd	struct
*	O
user_entry	pointer
;	O
char	O
*	O
username	pointer
=	O
xmalloc	function
(	O
257	int
)	O
;	O
int	O
i	int
,	O
c	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
(	O
c	pointer
=	O
dirname	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
IS_SLASH	O
(	O
c	int
)	O
)	O
break	O
;	O
else	O
username	pointer
[	O
i	int
-	O
1	int
]	O
=	O
c	int
;	O
}	O
username	pointer
[	O
i	int
-	O
1	int
]	O
=	O
0	int
;	O
user_entry	pointer
=	O
(	O
struct	O
passwd	struct
*	O
)	O
getpwnam	function
(	O
username	pointer
)	O
;	O
if	O
(	O
user_entry	pointer
)	O
{	O
temp_name	pointer
=	O
xmalloc	function
(	O
1	int
+	O
strlen	function
(	O
user_entry	pointer
->	O
pw_dir	pointer
)	O
+	O
strlen	function
(	O
&	O
dirname	pointer
[	O
i	int
]	O
)	O
)	O
;	O
strcpy	function
(	O
temp_name	pointer
,	O
user_entry	pointer
->	O
pw_dir	pointer
)	O
;	O
strcat	function
(	O
temp_name	pointer
,	O
&	O
dirname	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
dirname	pointer
)	O
;	O
dirname	pointer
=	O
xstrdup	function
(	O
temp_name	pointer
)	O
;	O
free	function
(	O
temp_name	pointer
)	O
;	O
}	O
endpwent	function
(	O
)	O
;	O
free	function
(	O
username	pointer
)	O
;	O
}	O
}	O
return	O
dirname	pointer
;	O
}	O
int	O
PRINTF_FETCHARGS	O
(	O
va_list	array
args	array
,	O
arguments	struct
*	O
a	union
)	O
{	O
size_t	long
i	long
;	O
argument	struct
*	O
ap	pointer
;	O
for	O
(	O
i	long
=	O
0	int
,	O
ap	pointer
=	O
&	O
a	union
->	O
arg	pointer
[	O
0	int
]	O
;	O
i	long
<	O
a	union
->	O
count	long
;	O
i	long
++	O
,	O
ap	pointer
++	O
)	O
switch	O
(	O
ap	pointer
->	O
type	enum
)	O
{	O
case	O
TYPE_SCHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_schar	char
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_UCHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_uchar	char
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_SHORT	int
:	O
ap	pointer
->	O
a	union
.	O
a_short	short
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_USHORT	int
:	O
ap	pointer
->	O
a	union
.	O
a_ushort	short
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_INT	int
:	O
ap	pointer
->	O
a	union
.	O
a_int	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_UINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_uint	int
=	O
va_arg	O
(	O
args	array
,	O
unsigned	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_LONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_longint	long
=	O
va_arg	O
(	O
args	array
,	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_ULONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_ulongint	long
=	O
va_arg	O
(	O
args	array
,	O
unsigned	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_LONGLONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_longlongint	long long
=	O
va_arg	O
(	O
args	array
,	O
long	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_ULONGLONGINT	int
:	O
ap	pointer
->	O
a	union
.	O
a_ulonglongint	long long
=	O
va_arg	O
(	O
args	array
,	O
unsigned	O
long	O
long	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_DOUBLE	int
:	O
ap	pointer
->	O
a	union
.	O
a_double	double
=	O
va_arg	O
(	O
args	array
,	O
double	O
)	O
;	O
break	O
;	O
case	O
TYPE_LONGDOUBLE	int
:	O
ap	pointer
->	O
a	union
.	O
a_longdouble	bool
=	O
va_arg	O
(	O
args	array
,	O
long	O
double	O
)	O
;	O
break	O
;	O
case	O
TYPE_CHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_char	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
TYPE_WIDE_CHAR	int
:	O
ap	pointer
->	O
a	union
.	O
a_wide_char	int
=	O
(	O
sizeof	O
(	O
wint_t	int
)	O
<	O
sizeof	O
(	O
int	O
)	O
?	O
(	O
wint_t	int
)	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
:	O
va_arg	O
(	O
args	array
,	O
wint_t	int
)	O
)	O
;	O
break	O
;	O
case	O
TYPE_STRING	int
:	O
ap	pointer
->	O
a	union
.	O
a_string	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
char	O
*	O
)	O
;	O
if	O
(	O
ap	pointer
->	O
a	union
.	O
a_string	pointer
==	O
NULL	O
)	O
ap	pointer
->	O
a	union
.	O
a_string	pointer
=	O
"(NULL)"	pointer
;	O
break	O
;	O
case	O
TYPE_WIDE_STRING	int
:	O
ap	pointer
->	O
a	union
.	O
a_wide_string	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
wchar_t	int
*	O
)	O
;	O
if	O
(	O
ap	pointer
->	O
a	union
.	O
a_wide_string	pointer
==	O
NULL	O
)	O
{	O
static	O
const	O
wchar_t	int
wide_null_string	array
[	O
]	O
=	O
{	O
(	O
wchar_t	int
)	O
'('	O
,	O
(	O
wchar_t	int
)	O
'N'	O
,	O
(	O
wchar_t	int
)	O
'U'	O
,	O
(	O
wchar_t	int
)	O
'L'	O
,	O
(	O
wchar_t	int
)	O
'L'	O
,	O
(	O
wchar_t	int
)	O
')'	O
,	O
(	O
wchar_t	int
)	O
0	int
}	O
;	O
ap	pointer
->	O
a	union
.	O
a_wide_string	pointer
=	O
wide_null_string	array
;	O
}	O
break	O
;	O
case	O
TYPE_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
void	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_SCHAR_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_schar_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
signed	O
char	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_SHORT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_short_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
short	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_INT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_int_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
int	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_LONGINT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_longint_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
long	O
int	O
*	O
)	O
;	O
break	O
;	O
case	O
TYPE_COUNT_LONGLONGINT_POINTER	int
:	O
ap	pointer
->	O
a	union
.	O
a_count_longlongint_pointer	pointer
=	O
va_arg	O
(	O
args	array
,	O
long	O
long	O
int	O
*	O
)	O
;	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
debug_string	pointer
;	O
static	O
int	O
match	function
(	O
char	O
,	O
int	O
)	O
;	O
void	O
setup_debug	function
(	O
void	O
)	O
{	O
debug_string	pointer
=	O
""	pointer
;	O
string_option	function
(	O
"D"	pointer
,	O
"debug"	pointer
,	O
""	pointer
,	O
&	O
debug_string	struct
,	O
NULL	O
,	O
NULL	O
,	O
OPT_MISC	pointer
,	O
"set debug options to <string>"	pointer
)	O
;	O
}	O
void	O
dm	function
(	O
char	O
class	O
,	O
int	O
level	int
,	O
char	O
*	O
message	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	pointer
;	O
if	O
(	O
debug_string	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
!	O
match	function
(	O
class	pointer
,	O
level	int
)	O
)	O
return	O
;	O
va_start	O
(	O
ap	array
,	O
message	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
message	pointer
,	O
ap	array
)	O
;	O
}	O
int	O
match	function
(	O
char	O
class	O
,	O
int	O
level	int
)	O
{	O
char	O
*	O
s_index	pointer
=	O
debug_string	pointer
;	O
char	O
this_class	O
;	O
int	O
this_level	int
;	O
while	O
(	O
*	O
s_index	pointer
)	O
{	O
skipspaces	function
(	O
&	O
s_index	pointer
)	O
;	O
this_class	int
=	O
*	O
(	O
s_index	pointer
++	O
)	O
;	O
skipspaces	function
(	O
&	O
s_index	O
)	O
;	O
this_level	int
=	O
strtol	function
(	O
s_index	pointer
,	O
&	O
s_index	pointer
,	O
10	int
)	O
;	O
if	O
(	O
(	O
this_class	int
==	O
'@'	O
)	O
||	O
(	O
this_class	pointer
==	O
class	int
)	O
)	O
{	O
if	O
(	O
this_level	int
>=	O
level	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
top_left_string	pointer
;	O
static	O
char	O
*	O
top_centre_string	pointer
;	O
static	O
char	O
*	O
top_right_string	pointer
;	O
static	O
char	O
*	O
bottom_left_string	pointer
;	O
static	O
char	O
*	O
bottom_centre_string	pointer
;	O
static	O
char	O
*	O
bottom_right_string	pointer
;	O
static	O
char	O
*	O
message_string	pointer
;	O
void	O
setup_headers	function
(	O
void	O
)	O
{	O
top_left_string	pointer
=	O
NULL	O
;	O
string_option	function
(	O
"X"	pointer
,	O
"left-header"	pointer
,	O
"%L"	pointer
,	O
&	O
top_left_string	O
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	pointer
,	O
"specify string for left side of header"	pointer
)	O
;	O
bottom_left_string	pointer
=	O
NULL	O
;	O
string_option	function
(	O
"x"	pointer
,	O
"left-footer"	pointer
,	O
"%L"	pointer
,	O
&	O
bottom_left_string	O
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	pointer
,	O
"specify string for left side of footer"	pointer
)	O
;	O
top_centre_string	pointer
=	O
NULL	O
;	O
string_option	function
(	O
"Y"	pointer
,	O
"center-header"	pointer
,	O
"%N"	pointer
,	O
&	O
top_centre_string	O
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	pointer
,	O
"specify string for center of header"	pointer
)	O
;	O
bottom_centre_string	pointer
=	O
NULL	O
;	O
string_option	function
(	O
"y"	pointer
,	O
"center-footer"	pointer
,	O
"%n %p"	pointer
,	O
&	O
bottom_centre_string	O
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	pointer
,	O
"specify string for center of footer"	pointer
)	O
;	O
top_right_string	pointer
=	O
NULL	O
;	O
string_option	function
(	O
"Z"	pointer
,	O
"right-header"	pointer
,	O
"Page %P of %F"	pointer
,	O
&	O
top_right_string	O
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	pointer
,	O
"specify string for right side of header"	pointer
)	O
;	O
bottom_right_string	pointer
=	O
NULL	O
;	O
string_option	function
(	O
"z"	pointer
,	O
"right-footer"	pointer
,	O
"Page %P of %F"	pointer
,	O
&	O
bottom_right_string	O
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	pointer
,	O
"specify string for right side of footer"	pointer
)	O
;	O
message_string	pointer
=	O
NULL	O
;	O
string_option	function
(	O
"m"	pointer
,	O
"message"	pointer
,	O
NULL	O
,	O
&	O
message_string	O
,	O
NULL	O
,	O
NULL	O
,	O
OPT_PAGE_FURNITURE	pointer
,	O
"message to be printed over page"	pointer
)	O
;	O
}	O
void	O
print_text_header	function
(	O
long	O
page_number	long
,	O
long	O
total_pages	long
)	O
{	O
PS_startpage	function
(	O
top_left_string	pointer
,	O
top_centre_string	pointer
,	O
top_right_string	pointer
,	O
bottom_left_string	pointer
,	O
bottom_centre_string	pointer
,	O
bottom_right_string	pointer
,	O
message_string	pointer
,	O
page_number	long
,	O
total_pages	pointer
,	O
FALSE	O
)	O
;	O
}	O
void	O
print_file_header	function
(	O
long	O
page_no	int
)	O
{	O
char	O
page_no_string	array
[	O
10	int
]	O
;	O
sprintf	function
(	O
page_no_string	pointer
,	O
"Page %ld"	pointer
,	O
page_no	pointer
)	O
;	O
PS_startpage	function
(	O
"%L"	pointer
,	O
"File Index"	pointer
,	O
page_no_string	pointer
,	O
"%L"	pointer
,	O
"File Index"	pointer
,	O
page_no_string	pointer
,	O
message_string	pointer
,	O
page_no	pointer
,	O
0	int
,	O
TRUE	O
)	O
;	O
}	O
void	O
print_index_header	function
(	O
long	O
page_no	int
)	O
{	O
char	O
page_no_string	array
[	O
10	int
]	O
;	O
sprintf	function
(	O
page_no_string	pointer
,	O
"Page %ld"	pointer
,	O
page_no	pointer
)	O
;	O
PS_startpage	function
(	O
"%L"	pointer
,	O
"Function Index"	pointer
,	O
page_no_string	pointer
,	O
"%L"	pointer
,	O
"Function Index"	pointer
,	O
page_no_string	pointer
,	O
message_string	pointer
,	O
page_no	pointer
,	O
0	int
,	O
TRUE	O
)	O
;	O
}	O
void	O
skipspaces	function
(	O
char	O
*	O
*	O
ptr	pointer
)	O
{	O
while	O
(	O
*	O
*	O
ptr	pointer
&&	O
isspace	function
(	O
*	O
*	O
ptr	pointer
)	O
)	O
(	O
*	O
ptr	pointer
)	O
++	O
;	O
}	O
void	O
*	O
xmalloc	function
(	O
size_t	long
s	long
)	O
{	O
void	O
*	O
r	pointer
;	O
if	O
(	O
(	O
r	pointer
=	O
malloc	function
(	O
s	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
gettext	function
(	O
CMD_NAME	pointer
": cannot allocate memory\n"	pointer
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
return	O
r	pointer
;	O
}	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
v	pointer
,	O
size_t	long
s	pointer
)	O
{	O
void	O
*	O
r	pointer
;	O
if	O
(	O
(	O
r	pointer
=	O
realloc	function
(	O
v	pointer
,	O
s	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
gettext	function
(	O
CMD_NAME	pointer
": cannot reallocate memory\n"	pointer
)	O
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
return	O
r	int
;	O
}	O
static	O
unsigned	O
long	O
count	long
=	O
0	int
;	O
char	O
*	O
my_malloc	function
(	O
unsigned	O
long	O
size	long
)	O
{	O
char	O
*	O
ptr	pointer
;	O
ptr	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
ptr	pointer
)	O
count	long
+=	O
size	long
;	O
return	O
ptr	pointer
;	O
}	O
void	O
my_free	function
(	O
char	O
*	O
ptr	pointer
)	O
{	O
CHECK_PARAM_NOT_NULL	function
(	O
ptr	pointer
)	O
;	O
free	function
(	O
ptr	pointer
)	O
;	O
}	O
unsigned	O
long	O
total_malloced	function
(	O
void	O
)	O
{	O
return	O
count	long
;	O
}	O
char	O
*	O
my_strdup	function
(	O
char	O
*	O
src	pointer
)	O
{	O
unsigned	O
long	O
len	int
;	O
char	O
*	O
ptr	pointer
;	O
CHECK_PARAM_NOT_NULL	function
(	O
src	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
src	pointer
)	O
;	O
ptr	pointer
=	O
my_malloc	function
(	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
ptr	pointer
)	O
error_handler	function
(	O
"out of memory in strdup()"	pointer
)	O
;	O
strcpy	function
(	O
ptr	pointer
,	O
src	pointer
)	O
;	O
return	O
ptr	pointer
;	O
}	O
struct	O
mechdata	struct
{	O
time_t	long
max_skew	long
,	O
max_age	int
;	O
time_t	long
next_warn	long
;	O
}	O
;	O
static	O
void	O
mds_timestamp	function
(	O
struct	O
mechdata	O
*	O
*	O
md_r	pointer
)	O
{	O
struct	O
mechdata	struct
*	O
md	pointer
;	O
md	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
md	pointer
)	O
)	O
;	O
md	pointer
->	O
max_skew	pointer
=	O
getarg_ulong	function
(	O
)	O
;	O
md	pointer
->	O
max_age	pointer
=	O
getarg_ulong	function
(	O
)	O
;	O
md	pointer
->	O
next_warn	pointer
=	O
now	function
(	O
)	O
;	O
*	O
md_r	pointer
=	O
md	pointer
;	O
}	O
static	O
void	O
mes_timestamp	function
(	O
struct	O
mechdata	struct
*	O
*	O
md_r	pointer
,	O
int	O
*	O
maxprefix_io	pointer
,	O
int	O
*	O
maxsuffix_io	pointer
)	O
{	O
mds_timestamp	function
(	O
md_r	pointer
)	O
;	O
*	O
maxprefix_io	pointer
+=	O
4	int
;	O
}	O
static	O
void	O
menc_timestamp	function
(	O
struct	O
mechdata	struct
*	O
md	pointer
,	O
struct	O
buffer	struct
*	O
buf	pointer
)	O
{	O
*	O
(	O
uint32_t	int
*	O
)	O
buf_prepend	function
(	O
buf	pointer
,	O
4	int
)	O
=	O
htonl	function
(	O
now	function
(	O
)	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
mdec_timestamp	function
(	O
struct	O
mechdata	struct
*	O
md	pointer
,	O
struct	O
buffer	struct
*	O
buf	pointer
)	O
{	O
static	O
char	O
cbuf	array
[	O
40	int
]	O
;	O
uint32_t	int
*	O
tp	pointer
,	O
timestamp	int
;	O
time_t	long
tnow	long
;	O
long	O
age	long
;	O
BUF_UNPREPEND	O
(	O
tp	pointer
,	O
buf	pointer
,	O
4	int
)	O
;	O
timestamp	int
=	O
ntohl	function
(	O
*	O
tp	pointer
)	O
;	O
tnow	pointer
=	O
now	function
(	O
)	O
;	O
age	int
=	O
timestamp	int
-	O
(	O
uint32_t	int
)	O
tnow	pointer
;	O
if	O
(	O
age	long
>	O
0	int
)	O
{	O
if	O
(	O
!	O
md	pointer
->	O
max_age	int
||	O
age	int
<=	O
md	pointer
->	O
max_age	int
)	O
return	O
0	int
;	O
sprintf	function
(	O
cbuf	pointer
,	O
"packet too old (%lds)"	pointer
,	O
age	pointer
)	O
;	O
}	O
else	O
if	O
(	O
age	long
<	O
0	int
)	O
{	O
if	O
(	O
!	O
md	pointer
->	O
max_skew	int
||	O
age	int
>=	O
-	O
md	pointer
->	O
max_skew	int
)	O
return	O
0	int
;	O
sprintf	function
(	O
cbuf	pointer
,	O
"too much skew (%lds)"	pointer
,	O
-	O
age	pointer
)	O
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
tnow	int
<	O
md	pointer
->	O
next_warn	int
)	O
return	O
""	pointer
;	O
md	pointer
->	O
next_warn	int
=	O
tnow	pointer
+	O
WARN_EVERY	long
;	O
return	O
cbuf	pointer
;	O
}	O
STANDARD_MECHANISMLIST	O
(	O
"timestamp"	pointer
,	O
timestamp	pointer
)	O
;	O
struct	O
sbuf	struct
{	O
struct	O
sbuf	struct
*	O
qnext	pointer
;	O
size_t	long
c	pointer
;	O
union	O
{	O
char	O
ab	array
[	O
4	int
]	O
;	O
char	O
bdummy	O
;	O
}	O
u	pointer
;	O
}	O
;	O
static	O
struct	O
sbuf	struct
*	O
qBlist	pointer
;	O
char	O
*	O
zbufalc	function
(	O
c	pointer
)	O
size_t	long
c	long
;	O
{	O
register	O
struct	O
sbuf	struct
*	O
q	pointer
;	O
if	O
(	O
qBlist	pointer
==	O
NULL	O
)	O
{	O
q	pointer
=	O
(	O
struct	O
sbuf	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
sbuf	struct
)	O
+	O
c	int
-	O
4	int
)	O
;	O
q	pointer
->	O
c	int
=	O
c	int
;	O
}	O
else	O
{	O
q	pointer
=	O
qBlist	pointer
;	O
qBlist	pointer
=	O
q	pointer
->	O
qnext	pointer
;	O
if	O
(	O
q	pointer
->	O
c	int
<	O
c	int
)	O
{	O
q	pointer
=	O
(	O
struct	O
sbuf	struct
*	O
)	O
xrealloc	function
(	O
(	O
pointer	pointer
)	O
q	pointer
,	O
sizeof	O
(	O
struct	O
sbuf	struct
)	O
+	O
c	int
-	O
4	int
)	O
;	O
q	pointer
->	O
c	int
=	O
c	int
;	O
}	O
}	O
return	O
q	pointer
->	O
u	union
.	O
ab	array
;	O
}	O
void	O
ubuffree	function
(	O
z	pointer
)	O
char	O
*	O
z	pointer
;	O
{	O
struct	O
sbuf	struct
*	O
q	pointer
;	O
int	O
ioff	int
;	O
if	O
(	O
z	pointer
==	O
NULL	O
)	O
return	O
;	O
ioff	pointer
=	O
offsetof	O
(	O
struct	O
sbuf	struct
,	O
u	array
)	O
;	O
q	pointer
=	O
(	O
struct	O
sbuf	struct
*	O
)	O
(	O
pointer	pointer
)	O
(	O
z	pointer
-	O
ioff	pointer
)	O
;	O
q	pointer
->	O
qnext	pointer
=	O
qBlist	pointer
;	O
qBlist	pointer
=	O
q	pointer
;	O
}	O
char	O
*	O
zbufcpy	function
(	O
z	pointer
)	O
const	O
char	O
*	O
z	pointer
;	O
{	O
size_t	long
csize	long
;	O
char	O
*	O
zret	pointer
;	O
if	O
(	O
z	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
csize	long
=	O
strlen	function
(	O
z	pointer
)	O
+	O
1	int
;	O
zret	pointer
=	O
zbufalc	function
(	O
csize	long
)	O
;	O
memcpy	function
(	O
zret	pointer
,	O
z	pointer
,	O
csize	long
)	O
;	O
return	O
zret	pointer
;	O
}	O
size_t	long
cescape	function
(	O
z	pointer
)	O
char	O
*	O
z	pointer
;	O
{	O
char	O
*	O
zto	pointer
,	O
*	O
zfrom	pointer
;	O
zto	pointer
=	O
z	pointer
;	O
zfrom	pointer
=	O
z	pointer
;	O
while	O
(	O
*	O
zfrom	pointer
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
zfrom	pointer
!=	O
'\\'	O
)	O
{	O
*	O
zto	pointer
++	O
=	O
*	O
zfrom	pointer
++	O
;	O
continue	O
;	O
}	O
++	O
zfrom	pointer
;	O
switch	O
(	O
*	O
zfrom	pointer
)	O
{	O
case	O
'-'	O
:	O
*	O
zto	pointer
++	O
=	O
'-'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
*	O
zto	pointer
++	O
=	O
'\b'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
zto	pointer
++	O
=	O
'\n'	O
;	O
break	O
;	O
case	O
'N'	O
:	O
*	O
zto	pointer
++	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
zto	pointer
++	O
=	O
'\r'	O
;	O
break	O
;	O
case	O
's'	O
:	O
*	O
zto	pointer
++	O
=	O
' '	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
zto	pointer
++	O
=	O
'\t'	O
;	O
break	O
;	O
case	O
'\0'	O
:	O
--	O
zfrom	pointer
;	O
case	O
'\\'	O
:	O
*	O
zto	pointer
++	O
=	O
'\\'	O
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
{	O
int	O
i	int
;	O
i	int
=	O
*	O
zfrom	pointer
-	O
'0'	O
;	O
if	O
(	O
zfrom	array
[	O
1	int
]	O
>=	O
'0'	O
&&	O
zfrom	array
[	O
1	int
]	O
<=	O
'7'	O
)	O
i	int
=	O
8	int
*	O
i	int
+	O
*	O
++	O
zfrom	pointer
-	O
'0'	O
;	O
if	O
(	O
zfrom	array
[	O
1	int
]	O
>=	O
'0'	O
&&	O
zfrom	array
[	O
1	int
]	O
<=	O
'7'	O
)	O
i	int
=	O
8	int
*	O
i	int
+	O
*	O
++	O
zfrom	pointer
-	O
'0'	O
;	O
*	O
zto	pointer
++	O
=	O
(	O
char	O
)	O
i	int
;	O
}	O
break	O
;	O
case	O
'x'	O
:	O
{	O
int	O
i	int
;	O
i	int
=	O
0	int
;	O
while	O
(	O
isxdigit	function
(	O
BUCHAR	O
(	O
zfrom	array
[	O
1	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
isdigit	function
(	O
BUCHAR	O
(	O
zfrom	array
[	O
1	int
]	O
)	O
)	O
)	O
i	int
=	O
16	int
*	O
i	int
+	O
*	O
++	O
zfrom	pointer
-	O
'0'	O
;	O
else	O
if	O
(	O
isupper	function
(	O
BUCHAR	O
(	O
zfrom	array
[	O
1	int
]	O
)	O
)	O
)	O
i	int
=	O
16	int
*	O
i	int
+	O
*	O
++	O
zfrom	pointer
-	O
'A'	O
+	O
10	int
;	O
else	O
i	int
=	O
16	int
*	O
i	int
+	O
*	O
++	O
zfrom	pointer
-	O
'a'	O
+	O
10	int
;	O
}	O
*	O
zto	pointer
++	O
=	O
(	O
char	O
)	O
i	int
;	O
}	O
break	O
;	O
default	O
:	O
ulog	function
(	O
LOG_ERROR	int
,	O
"Unrecognized escape sequence \\%c"	pointer
,	O
*	O
zfrom	pointer
)	O
;	O
*	O
zto	pointer
++	O
=	O
*	O
zfrom	pointer
;	O
break	O
;	O
}	O
++	O
zfrom	pointer
;	O
}	O
*	O
zto	pointer
=	O
'\0'	O
;	O
return	O
(	O
size_t	long
)	O
(	O
zto	pointer
-	O
z	pointer
)	O
;	O
}	O
int	O
getopt_long	function
(	O
argc	int
,	O
argv	array
,	O
options	pointer
,	O
long_options	array
,	O
opt_index	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
const	O
*	O
argv	pointer
;	O
const	O
char	O
*	O
options	pointer
;	O
const	O
struct	O
option	struct
*	O
long_options	pointer
;	O
int	O
*	O
opt_index	pointer
;	O
{	O
return	O
_getopt_internal	function
(	O
argc	int
,	O
argv	pointer
,	O
options	pointer
,	O
long_options	pointer
,	O
opt_index	pointer
,	O
0	int
)	O
;	O
}	O
int	O
getopt_long_only	function
(	O
argc	int
,	O
argv	pointer
,	O
options	pointer
,	O
long_options	pointer
,	O
opt_index	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
const	O
*	O
argv	pointer
;	O
const	O
char	O
*	O
options	pointer
;	O
const	O
struct	O
option	struct
*	O
long_options	pointer
;	O
int	O
*	O
opt_index	pointer
;	O
{	O
return	O
_getopt_internal	function
(	O
argc	int
,	O
argv	pointer
,	O
options	pointer
,	O
long_options	pointer
,	O
opt_index	pointer
,	O
1	int
)	O
;	O
}	O
const	O
char	O
quote_rcsid	array
[	O
]	O
=	O
"$Id: quote.c,v 1.2 2002/03/05 19:10:42 ian Rel $"	O
;	O
__inline__	O
static	O
boolean	int
fneeds_quotes	function
P	O
(	O
(	O
const	O
char	O
*	O
z	pointer
)	O
)	O
;	O
__inline__	O
static	O
boolean	int
fneeds_quotes	function
(	O
z	pointer
)	O
const	O
char	O
*	O
z	pointer
;	O
{	O
return	O
z	pointer
!=	O
NULL	O
&&	O
z	pointer
[	O
strcspn	function
(	O
z	pointer
,	O
" \t\n"	pointer
)	O
]	O
!=	O
'\0'	O
;	O
}	O
boolean	int
fcmd_needs_quotes	function
(	O
qcmd	pointer
)	O
const	O
struct	O
scmd	struct
*	O
qcmd	pointer
;	O
{	O
if	O
(	O
fneeds_quotes	function
(	O
qcmd	pointer
->	O
zfrom	pointer
)	O
||	O
fneeds_quotes	function
(	O
qcmd	pointer
->	O
zto	pointer
)	O
||	O
fneeds_quotes	function
(	O
qcmd	pointer
->	O
zuser	pointer
)	O
||	O
fneeds_quotes	function
(	O
qcmd	pointer
->	O
znotify	pointer
)	O
)	O
return	O
TRUE	O
;	O
return	O
FALSE	O
;	O
}	O
void	O
uquote_cmd	function
(	O
qorig	pointer
,	O
qnew	pointer
)	O
const	O
struct	O
scmd	struct
*	O
qorig	pointer
;	O
struct	O
scmd	struct
*	O
qnew	pointer
;	O
{	O
qnew	pointer
->	O
bcmd	char
=	O
qorig	pointer
->	O
bcmd	char
;	O
qnew	pointer
->	O
bgrade	char
=	O
qorig	pointer
->	O
bgrade	char
;	O
qnew	pointer
->	O
pseq	pointer
=	O
qorig	pointer
->	O
pseq	pointer
;	O
qnew	pointer
->	O
zfrom	pointer
=	O
zquote_cmd_string	function
(	O
qorig	pointer
->	O
zfrom	pointer
,	O
FALSE	O
)	O
;	O
qnew	pointer
->	O
zto	pointer
=	O
zquote_cmd_string	function
(	O
qorig	pointer
->	O
zto	pointer
,	O
FALSE	O
)	O
;	O
qnew	pointer
->	O
zuser	pointer
=	O
zquote_cmd_string	function
(	O
qorig	pointer
->	O
zuser	pointer
,	O
FALSE	O
)	O
;	O
if	O
(	O
strchr	function
(	O
qorig	pointer
->	O
zoptions	pointer
,	O
'q'	O
)	O
!=	O
NULL	O
)	O
qnew	pointer
->	O
zoptions	pointer
=	O
zbufcpy	function
(	O
qorig	pointer
->	O
zoptions	pointer
)	O
;	O
else	O
{	O
size_t	long
clen	long
;	O
char	O
*	O
z	pointer
;	O
clen	long
=	O
strlen	function
(	O
qorig	pointer
->	O
zoptions	pointer
)	O
;	O
z	pointer
=	O
zbufalc	function
(	O
clen	long
+	O
2	int
)	O
;	O
memcpy	function
(	O
z	pointer
,	O
qorig	pointer
->	O
zoptions	pointer
,	O
clen	long
)	O
;	O
z	pointer
[	O
clen	long
]	O
=	O
'q'	O
;	O
z	pointer
[	O
clen	long
+	O
1	int
]	O
=	O
'\0'	O
;	O
qnew	pointer
->	O
zoptions	pointer
=	O
z	pointer
;	O
}	O
qnew	pointer
->	O
ztemp	pointer
=	O
zbufcpy	function
(	O
qorig	pointer
->	O
ztemp	pointer
)	O
;	O
qnew	pointer
->	O
imode	int
=	O
qorig	pointer
->	O
imode	int
;	O
qnew	pointer
->	O
znotify	pointer
=	O
zquote_cmd_string	function
(	O
qorig	pointer
->	O
znotify	pointer
,	O
FALSE	O
)	O
;	O
qnew	pointer
->	O
cbytes	pointer
=	O
qorig	pointer
->	O
cbytes	pointer
;	O
qnew	pointer
->	O
zcmd	pointer
=	O
zbufcpy	function
(	O
qorig	pointer
->	O
zcmd	pointer
)	O
;	O
qnew	pointer
->	O
ipos	pointer
=	O
qorig	pointer
->	O
ipos	pointer
;	O
}	O
void	O
ufree_quoted_cmd	function
(	O
qcmd	pointer
)	O
struct	O
scmd	struct
*	O
qcmd	pointer
;	O
{	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
qcmd	pointer
->	O
zfrom	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
qcmd	pointer
->	O
zto	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
qcmd	pointer
->	O
zuser	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
qcmd	pointer
->	O
ztemp	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
qcmd	pointer
->	O
znotify	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
qcmd	pointer
->	O
zcmd	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
qcmd	pointer
->	O
zoptions	pointer
)	O
;	O
}	O
pointer	pointer
xmalloc	function
(	O
c	long
)	O
size_t	long
c	long
;	O
{	O
pointer	pointer
pret	pointer
;	O
pret	pointer
=	O
malloc	function
(	O
c	long
)	O
;	O
if	O
(	O
pret	pointer
==	O
NULL	O
&&	O
c	long
!=	O
0	int
)	O
ulog	function
(	O
LOG_FATAL	int
,	O
"Out of memory"	pointer
)	O
;	O
return	O
pret	pointer
;	O
}	O
pointer	pointer
xrealloc	function
(	O
p	pointer
,	O
c	pointer
)	O
pointer	pointer
p	pointer
;	O
size_t	long
c	long
;	O
{	O
pointer	pointer
pret	pointer
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
xmalloc	function
(	O
c	long
)	O
;	O
pret	pointer
=	O
realloc	function
(	O
p	pointer
,	O
c	int
)	O
;	O
if	O
(	O
pret	pointer
==	O
NULL	O
&&	O
c	long
!=	O
0	int
)	O
ulog	function
(	O
LOG_FATAL	int
,	O
"Out of memory"	pointer
)	O
;	O
return	O
pret	pointer
;	O
}	O
const	O
char	O
prott_rcsid	array
[	O
]	O
=	O
"$Id: prott.c,v 1.32 2002/03/05 19:10:41 ian Rel $"	pointer
;	O
static	O
char	O
*	O
zTbuf	pointer
;	O
static	O
boolean	int
fTfile	int
;	O
static	O
int	O
cTtimeout	int
=	O
120	int
;	O
struct	O
uuconf_cmdtab	struct
asTproto_params	array
[	O
]	O
=	O
{	O
{	O
"timeout"	pointer
,	O
UUCONF_CMDTABTYPE_INT	O
,	O
(	O
pointer	pointer
)	O
&	O
cTtimeout	function
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
static	O
boolean	int
ftprocess_data	function
P	O
(	O
(	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
,	O
boolean	int
*	O
pfexit	pointer
,	O
size_t	long
*	O
pcneed	pointer
)	O
)	O
;	O
boolean	int
ftstart	function
(	O
qdaemon	pointer
,	O
pzlog	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
char	O
*	O
*	O
pzlog	pointer
;	O
{	O
*	O
pzlog	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
fconn_set	function
(	O
qdaemon	pointer
->	O
qconn	pointer
,	O
PARITYSETTING_NONE	pointer
,	O
STRIPSETTING_EIGHTBITS	pointer
,	O
XONXOFF_OFF	pointer
)	O
)	O
return	O
FALSE	O
;	O
zTbuf	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
CTBUFSIZE	int
+	O
CTFRAMELEN	int
)	O
;	O
zTbuf	array
[	O
0	int
]	O
=	O
0	int
;	O
zTbuf	array
[	O
1	int
]	O
=	O
0	int
;	O
fTfile	int
=	O
FALSE	O
;	O
usysdep_sleep	function
(	O
2	int
)	O
;	O
return	O
TRUE	O
;	O
}	O
boolean	int
ftshutdown	function
(	O
qdaemon	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
ATTRIBUTE_UNUSED	O
;	O
{	O
xfree	function
(	O
(	O
pointer	pointer
)	O
zTbuf	pointer
)	O
;	O
zTbuf	pointer
=	O
NULL	O
;	O
cTtimeout	pointer
=	O
120	int
;	O
return	O
TRUE	O
;	O
}	O
boolean	int
ftsendcmd	function
(	O
qdaemon	pointer
,	O
z	pointer
,	O
ilocal	pointer
,	O
iremote	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
const	O
char	O
*	O
z	pointer
;	O
int	O
ilocal	int
ATTRIBUTE_UNUSED	O
;	O
int	O
iremote	int
ATTRIBUTE_UNUSED	O
;	O
{	O
size_t	long
clen	long
,	O
csend	long
;	O
char	O
*	O
zalc	pointer
;	O
boolean	int
fret	int
;	O
DEBUG_MESSAGE1	O
(	O
DEBUG_UUCP_PROTO	pointer
,	O
"ftsendcmd: Sending command \"%s\""	pointer
,	O
z	pointer
)	O
;	O
clen	long
=	O
strlen	function
(	O
z	pointer
)	O
;	O
csend	long
=	O
(	O
(	O
clen	long
/	O
CTPACKSIZE	int
)	O
+	O
1	int
)	O
*	O
CTPACKSIZE	pointer
;	O
zalc	pointer
=	O
zbufalc	function
(	O
csend	long
)	O
;	O
memcpy	function
(	O
zalc	pointer
,	O
z	pointer
,	O
clen	long
)	O
;	O
if	O
(	O
csend	long
>	O
clen	long
)	O
bzero	function
(	O
zalc	pointer
+	O
clen	long
,	O
csend	long
-	O
clen	long
)	O
;	O
fret	int
=	O
fsend_data	function
(	O
qdaemon	pointer
->	O
qconn	pointer
,	O
zalc	pointer
,	O
csend	long
,	O
TRUE	O
)	O
;	O
ubuffree	function
(	O
zalc	pointer
)	O
;	O
return	O
fret	int
;	O
}	O
char	O
*	O
ztgetspace	function
(	O
qdaemon	pointer
,	O
pclen	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
ATTRIBUTE_UNUSED	O
;	O
size_t	long
*	O
pclen	pointer
;	O
{	O
*	O
pclen	pointer
=	O
CTBUFSIZE	int
;	O
return	O
zTbuf	int
+	O
CTFRAMELEN	int
;	O
}	O
boolean	int
ftsenddata	function
(	O
qdaemon	pointer
,	O
zdata	pointer
,	O
cdata	pointer
,	O
ilocal	pointer
,	O
iremote	pointer
,	O
ipos	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
char	O
*	O
zdata	pointer
;	O
size_t	long
cdata	long
;	O
int	O
ilocal	int
ATTRIBUTE_UNUSED	O
;	O
int	O
iremote	int
ATTRIBUTE_UNUSED	O
;	O
long	O
ipos	long
ATTRIBUTE_UNUSED	O
;	O
{	O
zdata	array
[	O
-	O
2	int
]	O
=	O
(	O
char	O
)	O
(	O
(	O
cdata	int
>>	O
8	int
)	O
&	O
0xff	int
)	O
;	O
zdata	array
[	O
-	O
1	int
]	O
=	O
(	O
char	O
)	O
(	O
cdata	int
&	O
0xff	int
)	O
;	O
return	O
fsend_data	function
(	O
qdaemon	pointer
->	O
qconn	pointer
,	O
zdata	int
-	O
CTFRAMELEN	int
,	O
cdata	int
+	O
CTFRAMELEN	int
,	O
FALSE	int
)	O
;	O
}	O
static	O
boolean	int
ftprocess_data	function
(	O
qdaemon	pointer
,	O
pfexit	pointer
,	O
pcneed	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
boolean	int
*	O
pfexit	pointer
;	O
size_t	long
*	O
pcneed	pointer
;	O
{	O
int	O
cinbuf	int
,	O
cfirst	int
,	O
clen	long
;	O
*	O
pfexit	pointer
=	O
FALSE	O
;	O
cinbuf	int
=	O
iPrecend	int
-	O
iPrecstart	int
;	O
if	O
(	O
cinbuf	long
<	O
0	int
)	O
cinbuf	pointer
+=	O
CRECBUFLEN	O
;	O
if	O
(	O
!	O
fTfile	pointer
)	O
{	O
while	O
(	O
cinbuf	int
>=	O
CTPACKSIZE	int
)	O
{	O
cfirst	int
=	O
CRECBUFLEN	O
-	O
iPrecstart	int
;	O
if	O
(	O
cfirst	int
>	O
CTPACKSIZE	int
)	O
cfirst	int
=	O
CTPACKSIZE	pointer
;	O
DEBUG_MESSAGE1	O
(	O
DEBUG_PROTO	pointer
,	O
"ftprocess_data: Got %d command bytes"	pointer
,	O
cfirst	pointer
)	O
;	O
if	O
(	O
!	O
fgot_data	function
(	O
qdaemon	pointer
,	O
abPrecbuf	array
+	O
iPrecstart	int
,	O
(	O
size_t	long
)	O
cfirst	pointer
,	O
abPrecbuf	O
,	O
(	O
size_t	long
)	O
CTPACKSIZE	int
-	O
cfirst	pointer
,	O
-	O
1	int
,	O
-	O
1	int
,	O
(	O
long	O
)	O
-	O
1	int
,	O
TRUE	O
,	O
pfexit	pointer
)	O
)	O
return	O
FALSE	O
;	O
iPrecstart	int
=	O
(	O
iPrecstart	int
+	O
CTPACKSIZE	int
)	O
%	O
CRECBUFLEN	O
;	O
if	O
(	O
*	O
pfexit	pointer
)	O
return	O
TRUE	O
;	O
cinbuf	pointer
-=	O
CTPACKSIZE	int
;	O
}	O
if	O
(	O
pcneed	pointer
!=	O
NULL	O
)	O
*	O
pcneed	pointer
=	O
CTPACKSIZE	int
-	O
cinbuf	int
;	O
return	O
TRUE	O
;	O
}	O
while	O
(	O
cinbuf	int
>=	O
CTFRAMELEN	int
)	O
{	O
clen	long
=	O
(	O
(	O
(	O
(	O
(	O
(	O
(	O
abPrecbuf	array
[	O
iPrecstart	int
]	O
&	O
0xff	int
)	O
<<	O
8	int
)	O
+	O
(	O
abPrecbuf	array
[	O
(	O
iPrecstart	int
+	O
1	int
)	O
%	O
CRECBUFLEN	O
]	O
&	O
0xff	int
)	O
)	O
<<	O
8	int
)	O
+	O
(	O
abPrecbuf	array
[	O
(	O
iPrecstart	int
+	O
2	int
)	O
%	O
CRECBUFLEN	O
]	O
&	O
0xff	int
)	O
)	O
<<	O
8	int
)	O
+	O
(	O
abPrecbuf	array
[	O
(	O
iPrecstart	int
+	O
3	int
)	O
%	O
CRECBUFLEN	O
]	O
&	O
0xff	int
)	O
)	O
;	O
if	O
(	O
cinbuf	long
<	O
clen	long
+	O
CTFRAMELEN	int
)	O
{	O
if	O
(	O
pcneed	pointer
!=	O
NULL	O
)	O
*	O
pcneed	pointer
=	O
clen	long
+	O
CTFRAMELEN	int
-	O
cinbuf	int
;	O
return	O
TRUE	O
;	O
}	O
iPrecstart	int
=	O
(	O
iPrecstart	int
+	O
CTFRAMELEN	int
)	O
%	O
CRECBUFLEN	O
;	O
cfirst	int
=	O
CRECBUFLEN	O
-	O
iPrecstart	int
;	O
if	O
(	O
cfirst	long
>	O
clen	long
)	O
cfirst	long
=	O
clen	long
;	O
DEBUG_MESSAGE1	O
(	O
DEBUG_PROTO	pointer
,	O
"ftprocess_data: Got %d data bytes"	pointer
,	O
clen	long
)	O
;	O
if	O
(	O
!	O
fgot_data	function
(	O
qdaemon	pointer
,	O
abPrecbuf	pointer
+	O
iPrecstart	int
,	O
(	O
size_t	long
)	O
cfirst	pointer
,	O
abPrecbuf	O
,	O
(	O
size_t	long
)	O
(	O
clen	long
-	O
cfirst	pointer
)	O
,	O
-	O
1	int
,	O
-	O
1	int
,	O
(	O
long	O
)	O
-	O
1	int
,	O
TRUE	O
,	O
pfexit	pointer
)	O
)	O
return	O
FALSE	O
;	O
iPrecstart	int
=	O
(	O
iPrecstart	int
+	O
clen	long
)	O
%	O
CRECBUFLEN	O
;	O
if	O
(	O
*	O
pfexit	pointer
)	O
return	O
TRUE	O
;	O
cinbuf	int
-=	O
clen	long
+	O
CTFRAMELEN	int
;	O
}	O
if	O
(	O
pcneed	pointer
!=	O
NULL	O
)	O
*	O
pcneed	pointer
=	O
CTFRAMELEN	int
-	O
cinbuf	int
;	O
return	O
TRUE	O
;	O
}	O
boolean	int
ftwait	function
(	O
qdaemon	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
{	O
while	O
(	O
TRUE	O
)	O
{	O
boolean	int
fexit	int
;	O
size_t	long
cneed	long
,	O
crec	long
;	O
if	O
(	O
!	O
ftprocess_data	function
(	O
qdaemon	pointer
,	O
&	O
fexit	pointer
,	O
&	O
cneed	long
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
fexit	pointer
)	O
return	O
TRUE	O
;	O
if	O
(	O
!	O
freceive_data	function
(	O
qdaemon	pointer
->	O
qconn	pointer
,	O
cneed	long
,	O
&	O
crec	long
,	O
cTtimeout	pointer
,	O
TRUE	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
crec	long
==	O
0	int
)	O
{	O
ulog	function
(	O
LOG_ERROR	int
,	O
"Timed out waiting for data"	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
}	O
boolean	int
ftfile	function
(	O
qdaemon	pointer
,	O
qtrans	pointer
,	O
fstart	pointer
,	O
fsend	pointer
,	O
cbytes	pointer
,	O
pfhandled	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
ATTRIBUTE_UNUSED	O
;	O
struct	O
stransfer	struct
*	O
qtrans	pointer
ATTRIBUTE_UNUSED	O
;	O
boolean	int
fstart	int
;	O
boolean	int
fsend	int
;	O
long	O
cbytes	long
ATTRIBUTE_UNUSED	O
;	O
boolean	int
*	O
pfhandled	pointer
;	O
{	O
*	O
pfhandled	pointer
=	O
FALSE	O
;	O
if	O
(	O
!	O
fsend	int
)	O
fTfile	pointer
=	O
fstart	pointer
;	O
return	O
TRUE	O
;	O
}	O
long	O
csysdep_bytes_free	function
(	O
zfile	pointer
)	O
const	O
char	O
*	O
zfile	pointer
;	O
{	O
struct	O
fs_usage	struct
s	struct
;	O
if	O
(	O
get_fs_usage	function
(	O
(	O
char	O
*	O
)	O
zfile	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
&	O
s	struct
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
s	struct
.	O
fsu_bavail	long
>=	O
LONG_MAX	O
/	O
(	O
long	O
)	O
512	int
)	O
return	O
LONG_MAX	O
;	O
return	O
s	struct
.	O
fsu_bavail	long
*	O
(	O
long	O
)	O
512	int
;	O
}	O
boolean	int
fsysdep_file_exists	function
(	O
zfile	pointer
)	O
const	O
char	O
*	O
zfile	pointer
;	O
{	O
struct	O
stat	struct
s	struct
;	O
return	O
stat	struct
(	O
(	O
char	O
*	O
)	O
zfile	pointer
,	O
&	O
s	struct
)	O
==	O
0	int
;	O
}	O
extern	O
struct	O
tm	struct
*	O
localtime	function
(	O
)	O
;	O
void	O
usysdep_localtime	function
(	O
itime	long
,	O
q	int
)	O
long	O
itime	long
;	O
struct	O
tm	struct
*	O
q	pointer
;	O
{	O
time_t	long
i	long
;	O
i	long
=	O
(	O
time_t	long
)	O
itime	long
;	O
*	O
q	pointer
=	O
*	O
localtime	function
(	O
&	O
i	long
)	O
;	O
}	O
unsigned	O
int	O
ixsysdep_file_mode	function
(	O
zfile	pointer
)	O
const	O
char	O
*	O
zfile	pointer
;	O
{	O
struct	O
stat	struct
s	struct
;	O
if	O
(	O
stat	struct
(	O
(	O
char	O
*	O
)	O
zfile	pointer
,	O
&	O
s	struct
)	O
!=	O
0	int
)	O
{	O
ulog	function
(	O
LOG_ERROR	int
,	O
"stat (%s): %s"	pointer
,	O
zfile	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
s	struct
.	O
st_mode	int
&	O
0777	int
)	O
==	O
0	int
)	O
return	O
0400	int
;	O
return	O
s	struct
.	O
st_mode	int
&	O
0777	int
;	O
}	O
extern	O
char	O
*	O
ttyname	function
(	O
)	O
;	O
const	O
char	O
*	O
zsysdep_port_name	function
(	O
ftcp_port	pointer
)	O
boolean	int
*	O
ftcp_port	pointer
;	O
{	O
const	O
char	O
*	O
z	pointer
;	O
*	O
ftcp_port	pointer
=	O
FALSE	O
;	O
{	O
size_t	long
clen	long
;	O
struct	O
sockaddr	struct
s	pointer
;	O
clen	long
=	O
sizeof	O
(	O
struct	O
sockaddr	struct
)	O
;	O
if	O
(	O
getsockname	function
(	O
0	int
,	O
&	O
s	pointer
,	O
&	O
clen	long
)	O
==	O
0	int
)	O
*	O
ftcp_port	pointer
=	O
TRUE	O
;	O
}	O
z	pointer
=	O
ttyname	function
(	O
0	int
)	O
;	O
if	O
(	O
z	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
strncmp	function
(	O
z	pointer
,	O
"/dev/"	pointer
,	O
sizeof	O
"/dev/"	pointer
-	O
1	int
)	O
==	O
0	int
)	O
return	O
z	pointer
+	O
sizeof	O
"/dev/"	pointer
-	O
1	int
;	O
else	O
return	O
z	pointer
;	O
}	O
const	O
char	O
tli_rcsid	array
[	O
]	O
=	O
"$Id: tli.c,v 1.8 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
const	O
char	O
_uuconf_base_rcsid	array
[	O
]	O
=	O
"$Id: base.c,v 1.6 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
void	O
_uuconf_ucmdtab_base	function
(	O
qoff	pointer
,	O
celes	pointer
,	O
pbase	pointer
,	O
qset	pointer
)	O
register	O
const	O
struct	O
cmdtab_offset	struct
*	O
qoff	pointer
;	O
size_t	long
celes	long
;	O
char	O
*	O
pbase	pointer
;	O
register	O
struct	O
uuconf_cmdtab	struct
*	O
qset	pointer
;	O
{	O
register	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
celes	int
;	O
i	long
++	O
,	O
qoff	int
++	O
,	O
qset	pointer
++	O
)	O
{	O
qset	pointer
->	O
uuconf_zcmd	pointer
=	O
qoff	pointer
->	O
zcmd	pointer
;	O
qset	pointer
->	O
uuconf_itype	int
=	O
qoff	pointer
->	O
itype	int
;	O
if	O
(	O
qoff	pointer
->	O
ioff	long
==	O
(	O
size_t	long
)	O
-	O
1	int
)	O
qset	pointer
->	O
uuconf_pvar	pointer
=	O
NULL	O
;	O
else	O
qset	pointer
->	O
uuconf_pvar	pointer
=	O
pbase	pointer
+	O
qoff	pointer
->	O
ioff	pointer
;	O
qset	pointer
->	O
uuconf_pifn	pointer
=	O
qoff	pointer
->	O
pifn	pointer
;	O
}	O
}	O
const	O
char	O
_uuconf_cmdfil_rcsid	array
[	O
]	O
=	O
"$Id: cmdfil.c,v 1.7 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
int	O
uuconf_cmd_file	function
(	O
pglobal	pointer
,	O
e	pointer
,	O
qtab	pointer
,	O
pinfo	pointer
,	O
pfiunknown	pointer
,	O
iflags	int
,	O
pblock	pointer
)	O
pointer	pointer
pglobal	pointer
;	O
FILE	struct
*	O
e	pointer
;	O
const	O
struct	O
uuconf_cmdtab	struct
*	O
qtab	pointer
;	O
pointer	pointer
pinfo	pointer
;	O
int	O
(	O
*	O
pfiunknown	pointer
)	O
P	O
(	O
(	O
pointer	pointer
,	O
int	O
,	O
char	O
*	O
*	O
,	O
pointer	pointer
,	O
pointer	pointer
)	O
)	O
;	O
int	O
iflags	int
;	O
pointer	pointer
pblock	pointer
;	O
{	O
struct	O
sglobal	struct
*	O
qglobal	pointer
=	O
(	O
struct	O
sglobal	struct
*	O
)	O
pglobal	pointer
;	O
boolean	int
fcont	int
;	O
char	O
*	O
zline	pointer
;	O
size_t	long
cline	long
;	O
int	O
iret	int
;	O
fcont	int
=	O
(	O
iflags	int
&	O
UUCONF_CMDTABFLAG_BACKSLASH	O
)	O
!=	O
0	int
;	O
zline	pointer
=	O
NULL	O
;	O
cline	long
=	O
0	int
;	O
iret	int
=	O
UUCONF_SUCCESS	O
;	O
qglobal	pointer
->	O
ilineno	int
=	O
0	int
;	O
while	O
(	O
(	O
fcont	int
?	O
_uuconf_getline	function
(	O
qglobal	pointer
,	O
&	O
zline	pointer
,	O
&	O
cline	long
,	O
e	pointer
)	O
:	O
getline	function
(	O
&	O
zline	pointer
,	O
&	O
cline	long
,	O
e	pointer
)	O
)	O
>	O
0	int
)	O
{	O
++	O
qglobal	pointer
->	O
ilineno	int
;	O
iret	int
=	O
uuconf_cmd_line	function
(	O
pglobal	pointer
,	O
zline	pointer
,	O
qtab	pointer
,	O
pinfo	pointer
,	O
pfiunknown	pointer
,	O
iflags	int
,	O
pblock	pointer
)	O
;	O
if	O
(	O
(	O
iret	int
&	O
UUCONF_CMDTABRET_KEEP	O
)	O
!=	O
0	int
)	O
{	O
iret	int
&=	O
~	O
UUCONF_CMDTABRET_KEEP	O
;	O
if	O
(	O
pblock	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
uuconf_add_block	function
(	O
pblock	pointer
,	O
zline	pointer
)	O
!=	O
0	int
)	O
{	O
qglobal	pointer
->	O
ierrno	int
=	O
errno	O
;	O
iret	int
=	O
(	O
UUCONF_MALLOC_FAILED	O
|	O
UUCONF_ERROR_ERRNO	O
|	O
UUCONF_ERROR_LINENO	O
)	O
;	O
break	O
;	O
}	O
}	O
zline	pointer
=	O
NULL	O
;	O
cline	long
=	O
0	int
;	O
}	O
if	O
(	O
(	O
iret	int
&	O
UUCONF_CMDTABRET_EXIT	O
)	O
!=	O
0	int
)	O
{	O
iret	int
&=	O
~	O
UUCONF_CMDTABRET_EXIT	O
;	O
if	O
(	O
iret	int
!=	O
UUCONF_SUCCESS	O
)	O
iret	int
|=	O
UUCONF_ERROR_LINENO	O
;	O
break	O
;	O
}	O
iret	int
=	O
UUCONF_SUCCESS	O
;	O
}	O
if	O
(	O
zline	pointer
!=	O
NULL	O
)	O
free	function
(	O
(	O
pointer	pointer
)	O
zline	pointer
)	O
;	O
return	O
iret	int
;	O
}	O
const	O
char	O
_uuconf_cmdlin_rcsid	array
[	O
]	O
=	O
"$Id: cmdlin.c,v 1.7 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
int	O
uuconf_cmd_line	function
(	O
pglobal	pointer
,	O
zline	pointer
,	O
qtab	pointer
,	O
pinfo	pointer
,	O
pfiunknown	pointer
,	O
iflags	int
,	O
pblock	pointer
)	O
pointer	pointer
pglobal	pointer
;	O
char	O
*	O
zline	pointer
;	O
const	O
struct	O
uuconf_cmdtab	struct
*	O
qtab	pointer
;	O
pointer	pointer
pinfo	pointer
;	O
int	O
(	O
*	O
pfiunknown	pointer
)	O
P	O
(	O
(	O
pointer	pointer
,	O
int	O
,	O
char	O
*	O
*	O
,	O
pointer	pointer
,	O
pointer	pointer
)	O
)	O
;	O
int	O
iflags	int
;	O
pointer	pointer
pblock	pointer
;	O
{	O
struct	O
sglobal	struct
*	O
qglobal	pointer
=	O
(	O
struct	O
sglobal	struct
*	O
)	O
pglobal	pointer
;	O
char	O
*	O
z	pointer
;	O
int	O
cargs	int
;	O
char	O
*	O
azargs	array
[	O
CSTACK	int
]	O
;	O
char	O
*	O
*	O
pzargs	pointer
;	O
int	O
iret	int
;	O
if	O
(	O
(	O
iflags	int
&	O
UUCONF_CMDTABFLAG_NOCOMMENTS	int
)	O
==	O
0	int
)	O
{	O
z	pointer
=	O
zline	pointer
;	O
while	O
(	O
(	O
z	pointer
=	O
strchr	function
(	O
z	pointer
,	O
'#'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
z	pointer
==	O
zline	pointer
||	O
*	O
(	O
z	pointer
-	O
1	int
)	O
!=	O
'\\'	O
)	O
{	O
*	O
z	pointer
=	O
'\0'	O
;	O
break	O
;	O
}	O
while	O
(	O
(	O
*	O
(	O
z	pointer
-	O
1	int
)	O
=	O
*	O
z	pointer
)	O
!=	O
'\0'	O
)	O
++	O
z	pointer
;	O
}	O
}	O
z	pointer
=	O
zline	pointer
;	O
cargs	int
=	O
0	int
;	O
pzargs	pointer
=	O
azargs	array
;	O
while	O
(	O
TRUE	O
)	O
{	O
while	O
(	O
*	O
z	pointer
!=	O
'\0'	O
&&	O
isspace	function
(	O
BUCHAR	O
(	O
*	O
z	pointer
)	O
)	O
)	O
++	O
z	pointer
;	O
if	O
(	O
*	O
z	pointer
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
cargs	int
>=	O
CSTACK	int
)	O
{	O
char	O
*	O
*	O
pzsplit	pointer
;	O
size_t	long
csplit	pointer
;	O
int	O
cmore	int
;	O
pzsplit	pointer
=	O
NULL	O
;	O
csplit	pointer
=	O
0	int
;	O
cmore	int
=	O
_uuconf_istrsplit	function
(	O
z	pointer
,	O
'\0'	O
,	O
&	O
pzsplit	pointer
,	O
&	O
csplit	pointer
)	O
;	O
if	O
(	O
cmore	int
<	O
0	int
)	O
{	O
qglobal	pointer
->	O
ierrno	int
=	O
errno	O
;	O
return	O
UUCONF_MALLOC_FAILED	O
|	O
UUCONF_ERROR_ERRNO	O
;	O
}	O
pzargs	pointer
=	O
(	O
char	O
*	O
*	O
)	O
malloc	function
(	O
(	O
cmore	pointer
+	O
CSTACK	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
pzargs	pointer
==	O
NULL	O
)	O
{	O
qglobal	pointer
->	O
ierrno	int
=	O
errno	O
;	O
free	function
(	O
(	O
pointer	pointer
)	O
pzsplit	pointer
)	O
;	O
return	O
UUCONF_MALLOC_FAILED	O
|	O
UUCONF_ERROR_ERRNO	O
;	O
}	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
pzargs	pointer
,	O
(	O
pointer	pointer
)	O
azargs	array
,	O
CSTACK	struct
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
(	O
pzargs	pointer
+	O
CSTACK	pointer
)	O
,	O
(	O
pointer	pointer
)	O
pzsplit	pointer
,	O
cmore	struct
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
cargs	O
=	O
cmore	pointer
+	O
CSTACK	int
;	O
free	function
(	O
(	O
pointer	pointer
)	O
pzsplit	pointer
)	O
;	O
break	O
;	O
}	O
azargs	array
[	O
cargs	int
]	O
=	O
z	pointer
;	O
++	O
cargs	int
;	O
while	O
(	O
*	O
z	pointer
!=	O
'\0'	O
&&	O
!	O
isspace	function
(	O
BUCHAR	O
(	O
*	O
z	pointer
)	O
)	O
)	O
z	pointer
++	O
;	O
if	O
(	O
*	O
z	pointer
==	O
'\0'	O
)	O
break	O
;	O
*	O
z	pointer
++	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
cargs	int
<=	O
0	int
)	O
return	O
UUCONF_CMDTABRET_CONTINUE	O
;	O
iret	int
=	O
uuconf_cmd_args	function
(	O
pglobal	pointer
,	O
cargs	int
,	O
pzargs	pointer
,	O
qtab	pointer
,	O
pinfo	pointer
,	O
pfiunknown	pointer
,	O
iflags	int
,	O
pblock	pointer
)	O
;	O
if	O
(	O
pzargs	pointer
!=	O
azargs	int
)	O
free	function
(	O
(	O
pointer	pointer
)	O
pzargs	pointer
)	O
;	O
return	O
iret	int
;	O
}	O
const	O
char	O
_uuconf_diacod_rcsid	array
[	O
]	O
=	O
"$Id: diacod.c,v 1.12 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
static	O
int	O
idcode	function
P	O
(	O
(	O
pointer	pointer
pglobal	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
pointer	pointer
pinfo	pointer
,	O
pointer	pointer
pvar	pointer
)	O
)	O
;	O
int	O
uuconf_dialcode	function
(	O
pglobal	pointer
,	O
zdial	pointer
,	O
pznum	pointer
)	O
pointer	pointer
pglobal	pointer
;	O
const	O
char	O
*	O
zdial	pointer
;	O
char	O
*	O
*	O
pznum	pointer
;	O
{	O
struct	O
sglobal	struct
*	O
qglobal	pointer
=	O
(	O
struct	O
sglobal	struct
*	O
)	O
pglobal	pointer
;	O
struct	O
uuconf_cmdtab	struct
as	array
[	O
2	int
]	O
;	O
char	O
*	O
*	O
pz	pointer
;	O
int	O
iret	int
;	O
as	array
[	O
0	int
]	O
.	O
uuconf_zcmd	pointer
=	O
zdial	pointer
;	O
as	array
[	O
0	int
]	O
.	O
uuconf_itype	int
=	O
UUCONF_CMDTABTYPE_FN	O
|	O
0	int
;	O
as	array
[	O
0	int
]	O
.	O
uuconf_pvar	pointer
=	O
(	O
pointer	pointer
)	O
pznum	pointer
;	O
as	array
[	O
0	int
]	O
.	O
uuconf_pifn	pointer
=	O
idcode	int
;	O
as	array
[	O
1	int
]	O
.	O
uuconf_zcmd	pointer
=	O
NULL	O
;	O
*	O
pznum	pointer
=	O
NULL	O
;	O
iret	int
=	O
UUCONF_SUCCESS	O
;	O
for	O
(	O
pz	pointer
=	O
qglobal	pointer
->	O
qprocess	pointer
->	O
pzdialcodefiles	pointer
;	O
*	O
pz	pointer
!=	O
NULL	O
;	O
pz	pointer
++	O
)	O
{	O
FILE	struct
*	O
e	pointer
;	O
e	pointer
=	O
fopen	function
(	O
*	O
pz	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
e	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
FNO_SUCH_FILE	O
(	O
)	O
)	O
continue	O
;	O
qglobal	pointer
->	O
ierrno	int
=	O
errno	O
;	O
iret	int
=	O
UUCONF_FOPEN_FAILED	O
|	O
UUCONF_ERROR_ERRNO	O
;	O
break	O
;	O
}	O
iret	int
=	O
uuconf_cmd_file	function
(	O
pglobal	pointer
,	O
e	pointer
,	O
as	array
,	O
(	O
pointer	pointer
)	O
NULL	O
,	O
(	O
uuconf_cmdtabfn	pointer
)	O
NULL	O
,	O
0	int
,	O
(	O
pointer	pointer
)	O
NULL	O
)	O
;	O
(	O
void	O
)	O
fclose	function
(	O
e	pointer
)	O
;	O
if	O
(	O
iret	int
!=	O
UUCONF_SUCCESS	O
||	O
*	O
pznum	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
iret	int
!=	O
UUCONF_SUCCESS	O
)	O
{	O
qglobal	pointer
->	O
zfilename	pointer
=	O
*	O
pz	pointer
;	O
iret	int
|=	O
UUCONF_ERROR_FILENAME	O
;	O
}	O
else	O
if	O
(	O
*	O
pznum	pointer
==	O
NULL	O
)	O
iret	int
=	O
UUCONF_NOT_FOUND	O
;	O
return	O
iret	int
;	O
}	O
static	O
int	O
idcode	function
(	O
pglobal	pointer
,	O
argc	int
,	O
argv	pointer
,	O
pvar	pointer
,	O
pinfo	pointer
)	O
pointer	pointer
pglobal	pointer
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
pointer	pointer
pvar	pointer
;	O
pointer	pointer
pinfo	pointer
ATTRIBUTE_UNUSED	O
;	O
{	O
struct	O
sglobal	struct
*	O
qglobal	pointer
=	O
(	O
struct	O
sglobal	struct
*	O
)	O
pglobal	pointer
;	O
char	O
*	O
*	O
pznum	pointer
=	O
(	O
char	O
*	O
*	O
)	O
pvar	pointer
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
*	O
pznum	pointer
=	O
malloc	function
(	O
1	int
)	O
;	O
if	O
(	O
*	O
pznum	pointer
!=	O
NULL	O
)	O
*	O
*	O
pznum	pointer
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
argc	int
==	O
2	int
)	O
*	O
pznum	pointer
=	O
strdup	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
else	O
return	O
UUCONF_SYNTAX_ERROR	O
|	O
UUCONF_CMDTABRET_EXIT	O
;	O
if	O
(	O
*	O
pznum	pointer
==	O
NULL	O
)	O
{	O
qglobal	pointer
->	O
ierrno	int
=	O
errno	O
;	O
return	O
(	O
UUCONF_MALLOC_FAILED	O
|	O
UUCONF_ERROR_ERRNO	O
|	O
UUCONF_CMDTABRET_EXIT	O
)	O
;	O
}	O
return	O
UUCONF_CMDTABRET_EXIT	O
;	O
}	O
const	O
char	O
_uuconf_dial_rcsid	array
[	O
]	O
=	O
"$Id: dial.c,v 1.7 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
int	O
uuconf_dialer_info	function
(	O
pglobal	pointer
,	O
zdialer	pointer
,	O
qdialer	pointer
)	O
pointer	pointer
pglobal	pointer
;	O
const	O
char	O
*	O
zdialer	pointer
;	O
struct	O
uuconf_dialer	struct
*	O
qdialer	pointer
;	O
{	O
int	O
iret	int
;	O
iret	int
=	O
uuconf_taylor_dialer_info	function
(	O
pglobal	pointer
,	O
zdialer	pointer
,	O
qdialer	pointer
)	O
;	O
if	O
(	O
iret	int
!=	O
UUCONF_NOT_FOUND	O
)	O
return	O
iret	int
;	O
return	O
UUCONF_NOT_FOUND	O
;	O
}	O
const	O
char	O
_uuconf_errstr_rcsid	array
[	O
]	O
=	O
"$Id: errstr.c,v 1.6 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
static	O
char	O
*	O
zeprint_num	function
P	O
(	O
(	O
char	O
*	O
zbuf	pointer
,	O
size_t	long
cbuf	O
,	O
int	O
ival	int
)	O
)	O
;	O
int	O
uuconf_error_string	function
(	O
pglobal	pointer
,	O
ierr	int
,	O
zbuf	pointer
,	O
cbuf	pointer
)	O
pointer	pointer
pglobal	pointer
;	O
int	O
ierr	int
;	O
char	O
*	O
zbuf	pointer
;	O
size_t	long
cbuf	long
;	O
{	O
struct	O
sglobal	struct
*	O
qglobal	pointer
=	O
(	O
struct	O
sglobal	struct
*	O
)	O
pglobal	pointer
;	O
const	O
char	O
*	O
zfile	pointer
;	O
size_t	long
cfile	long
;	O
const	O
char	O
*	O
zlineno	pointer
;	O
char	O
ablineno	array
[	O
100	int
]	O
;	O
size_t	long
clineno	long
;	O
const	O
char	O
*	O
zmsg	pointer
;	O
char	O
abmsg	array
[	O
100	int
]	O
;	O
size_t	long
cmsg	long
;	O
const	O
char	O
*	O
zerrno	pointer
;	O
size_t	long
cerrno	long
;	O
size_t	long
cret	long
;	O
size_t	long
ccopy	long
;	O
if	O
(	O
(	O
ierr	int
&	O
UUCONF_ERROR_FILENAME	O
)	O
==	O
0	int
||	O
qglobal	pointer
==	O
NULL	O
||	O
qglobal	pointer
->	O
zfilename	pointer
==	O
NULL	O
)	O
{	O
zfile	pointer
=	O
""	pointer
;	O
cfile	long
=	O
0	int
;	O
}	O
else	O
{	O
zfile	pointer
=	O
qglobal	pointer
->	O
zfilename	pointer
;	O
cfile	long
=	O
strlen	function
(	O
zfile	pointer
)	O
+	O
1	int
;	O
}	O
if	O
(	O
cfile	long
==	O
0	int
||	O
(	O
ierr	int
&	O
UUCONF_ERROR_LINENO	O
)	O
==	O
0	int
||	O
qglobal	pointer
==	O
NULL	O
||	O
qglobal	pointer
->	O
ilineno	int
<=	O
0	int
)	O
{	O
zlineno	pointer
=	O
""	pointer
;	O
clineno	pointer
=	O
0	int
;	O
}	O
else	O
{	O
zlineno	pointer
=	O
zeprint_num	function
(	O
ablineno	pointer
,	O
sizeof	O
ablineno	pointer
,	O
qglobal	pointer
->	O
ilineno	int
)	O
;	O
clineno	int
=	O
strlen	function
(	O
zlineno	pointer
)	O
+	O
1	int
;	O
}	O
switch	O
(	O
UUCONF_ERROR_VALUE	O
(	O
ierr	int
)	O
)	O
{	O
case	O
UUCONF_SUCCESS	O
:	O
zmsg	pointer
=	O
"no error"	pointer
;	O
break	O
;	O
case	O
UUCONF_NOT_FOUND	O
:	O
zmsg	int
=	O
"not found"	int
;	O
break	O
;	O
case	O
UUCONF_FOPEN_FAILED	O
:	O
zmsg	pointer
=	O
"fopen"	pointer
;	O
break	O
;	O
case	O
UUCONF_FSEEK_FAILED	int
:	O
zmsg	int
=	O
"fseek"	int
;	O
break	O
;	O
case	O
UUCONF_MALLOC_FAILED	O
:	O
zmsg	int
=	O
"malloc"	int
;	O
break	O
;	O
case	O
UUCONF_SYNTAX_ERROR	O
:	O
zmsg	int
=	O
"syntax error"	int
;	O
break	O
;	O
default	O
:	O
zmsg	pointer
=	O
zeprint_num	function
(	O
abmsg	pointer
,	O
sizeof	O
abmsg	pointer
,	O
UUCONF_ERROR_VALUE	O
(	O
ierr	int
)	O
)	O
;	O
zmsg	int
-=	O
sizeof	O
"error "	int
-	O
1	int
;	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
zmsg	pointer
,	O
(	O
pointer	pointer
)	O
"error "	pointer
,	O
sizeof	O
"error "	pointer
-	O
1	int
)	O
;	O
break	O
;	O
}	O
cmsg	int
=	O
strlen	function
(	O
zmsg	pointer
)	O
;	O
if	O
(	O
cfile	int
>	O
0	int
)	O
++	O
cmsg	int
;	O
if	O
(	O
(	O
ierr	int
&	O
UUCONF_ERROR_ERRNO	O
)	O
==	O
0	int
||	O
qglobal	pointer
==	O
NULL	O
)	O
{	O
zerrno	pointer
=	O
""	pointer
;	O
cerrno	pointer
=	O
0	int
;	O
}	O
else	O
{	O
zerrno	O
=	O
strerror	function
(	O
qglobal	pointer
->	O
ierrno	int
)	O
;	O
cerrno	int
=	O
strlen	function
(	O
zerrno	pointer
)	O
+	O
2	int
;	O
}	O
cret	long
=	O
cfile	long
+	O
clineno	int
+	O
cmsg	int
+	O
cerrno	int
+	O
1	int
;	O
if	O
(	O
cbuf	pointer
==	O
0	int
)	O
return	O
cret	int
;	O
--	O
cbuf	pointer
;	O
if	O
(	O
cfile	long
>	O
0	int
)	O
{	O
ccopy	long
=	O
cfile	long
-	O
1	int
;	O
if	O
(	O
ccopy	long
>	O
cbuf	pointer
)	O
ccopy	pointer
=	O
cbuf	pointer
;	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
zbuf	pointer
,	O
(	O
pointer	pointer
)	O
zfile	pointer
,	O
ccopy	int
)	O
;	O
zbuf	pointer
+=	O
ccopy	long
;	O
cbuf	pointer
-=	O
ccopy	int
;	O
if	O
(	O
cbuf	long
>	O
0	int
)	O
{	O
*	O
zbuf	pointer
++	O
=	O
':'	O
;	O
--	O
cbuf	pointer
;	O
}	O
}	O
if	O
(	O
clineno	long
>	O
0	int
)	O
{	O
ccopy	int
=	O
clineno	int
-	O
1	int
;	O
if	O
(	O
ccopy	long
>	O
cbuf	pointer
)	O
ccopy	pointer
=	O
cbuf	pointer
;	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
zbuf	pointer
,	O
(	O
pointer	pointer
)	O
zlineno	pointer
,	O
ccopy	int
)	O
;	O
zbuf	pointer
+=	O
ccopy	int
;	O
cbuf	pointer
-=	O
ccopy	int
;	O
if	O
(	O
cbuf	O
>	O
0	int
)	O
{	O
*	O
zbuf	pointer
++	O
=	O
':'	O
;	O
--	O
cbuf	pointer
;	O
}	O
}	O
if	O
(	O
cbuf	long
>	O
0	int
&&	O
cfile	int
>	O
0	int
)	O
{	O
*	O
zbuf	pointer
++	O
=	O
' '	O
;	O
--	O
cbuf	O
;	O
--	O
cmsg	int
;	O
}	O
ccopy	int
=	O
cmsg	int
;	O
if	O
(	O
ccopy	long
>	O
cbuf	O
)	O
ccopy	pointer
=	O
cbuf	O
;	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
zbuf	pointer
,	O
(	O
pointer	pointer
)	O
zmsg	pointer
,	O
ccopy	int
)	O
;	O
zbuf	pointer
+=	O
ccopy	int
;	O
cbuf	pointer
-=	O
ccopy	int
;	O
if	O
(	O
cerrno	int
>	O
0	int
)	O
{	O
if	O
(	O
cbuf	int
>	O
0	int
)	O
{	O
*	O
zbuf	pointer
++	O
=	O
':'	O
;	O
--	O
cbuf	pointer
;	O
}	O
if	O
(	O
cbuf	int
>	O
0	int
)	O
{	O
*	O
zbuf	pointer
++	O
=	O
' '	O
;	O
--	O
cbuf	O
;	O
}	O
ccopy	int
=	O
cerrno	int
-	O
2	int
;	O
if	O
(	O
ccopy	int
>	O
cbuf	O
)	O
ccopy	pointer
=	O
cbuf	pointer
;	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
zbuf	pointer
,	O
(	O
pointer	pointer
)	O
zerrno	pointer
,	O
ccopy	int
)	O
;	O
zbuf	pointer
+=	O
ccopy	int
;	O
cbuf	pointer
-=	O
ccopy	pointer
;	O
}	O
*	O
zbuf	pointer
=	O
'\0'	O
;	O
return	O
cret	int
;	O
}	O
static	O
char	O
*	O
zeprint_num	function
(	O
ab	array
,	O
c	int
,	O
i	int
)	O
char	O
*	O
ab	array
;	O
size_t	long
c	int
;	O
register	O
int	O
i	int
;	O
{	O
register	O
char	O
*	O
z	pointer
;	O
z	int
=	O
ab	array
+	O
c	int
;	O
*	O
--	O
z	pointer
=	O
'\0'	O
;	O
do	O
{	O
*	O
--	O
z	pointer
=	O
i	int
%	O
10	int
+	O
'0'	O
;	O
i	int
/=	O
10	int
;	O
}	O
while	O
(	O
i	int
!=	O
0	int
)	O
;	O
return	O
z	pointer
;	O
}	O
const	O
char	O
_uuconf_fredia_rcsid	array
[	O
]	O
=	O
"$Id: fredia.c,v 1.8 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
int	O
uuconf_dialer_free	function
(	O
pglobal	pointer
,	O
qdialer	pointer
)	O
pointer	pointer
pglobal	pointer
ATTRIBUTE_UNUSED	O
;	O
struct	O
uuconf_dialer	struct
*	O
qdialer	pointer
;	O
{	O
uuconf_free_block	function
(	O
qdialer	pointer
->	O
uuconf_palloc	pointer
)	O
;	O
return	O
UUCONF_SUCCESS	O
;	O
}	O
const	O
char	O
_uuconf_int_rcsid	array
[	O
]	O
=	O
"$Id: int.c,v 1.9 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
int	O
_uuconf_iint	function
(	O
qglobal	pointer
,	O
zval	pointer
,	O
p	pointer
,	O
fint	pointer
)	O
struct	O
sglobal	struct
*	O
qglobal	pointer
ATTRIBUTE_UNUSED	O
;	O
const	O
char	O
*	O
zval	pointer
;	O
pointer	pointer
p	pointer
;	O
boolean	int
fint	int
;	O
{	O
long	O
i	long
;	O
char	O
*	O
zend	pointer
;	O
i	long
=	O
strtol	function
(	O
(	O
char	O
*	O
)	O
zval	pointer
,	O
&	O
zend	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
zend	pointer
!=	O
'\0'	O
)	O
return	O
UUCONF_SYNTAX_ERROR	O
|	O
UUCONF_CMDTABRET_EXIT	O
;	O
if	O
(	O
fint	pointer
)	O
*	O
(	O
int	O
*	O
)	O
p	pointer
=	O
(	O
int	O
)	O
i	int
;	O
else	O
*	O
(	O
long	O
*	O
)	O
p	pointer
=	O
i	long
;	O
return	O
UUCONF_CMDTABRET_CONTINUE	O
;	O
}	O
const	O
char	O
_uuconf_lckdir_rcsid	array
[	O
]	O
=	O
"$Id: lckdir.c,v 1.6 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
int	O
uuconf_lockdir	function
(	O
pglobal	pointer
,	O
pzlock	pointer
)	O
pointer	pointer
pglobal	pointer
;	O
const	O
char	O
*	O
*	O
pzlock	pointer
;	O
{	O
struct	O
sglobal	struct
*	O
qglobal	pointer
=	O
(	O
struct	O
sglobal	struct
*	O
)	O
pglobal	pointer
;	O
*	O
pzlock	pointer
=	O
qglobal	pointer
->	O
qprocess	pointer
->	O
zlockdir	pointer
;	O
return	O
UUCONF_SUCCESS	O
;	O
}	O
const	O
char	O
_uuconf_locnm_rcsid	array
[	O
]	O
=	O
"$Id: locnm.c,v 1.7 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
int	O
uuconf_localname	function
(	O
pglobal	pointer
,	O
pzname	pointer
)	O
pointer	pointer
pglobal	pointer
;	O
const	O
char	O
*	O
*	O
pzname	pointer
;	O
{	O
struct	O
sglobal	struct
*	O
qglobal	pointer
=	O
(	O
struct	O
sglobal	struct
*	O
)	O
pglobal	pointer
;	O
*	O
pzname	pointer
=	O
qglobal	pointer
->	O
qprocess	pointer
->	O
zlocalname	pointer
;	O
if	O
(	O
*	O
pzname	pointer
!=	O
NULL	O
)	O
return	O
UUCONF_SUCCESS	O
;	O
else	O
return	O
UUCONF_NOT_FOUND	O
;	O
}	O
const	O
char	O
_uuconf_paramc_rcsid	array
[	O
]	O
=	O
"$Id: paramc.c,v 1.6 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
int	O
_uuconf_iadd_proto_param	function
(	O
qglobal	pointer
,	O
argc	int
,	O
argv	pointer
,	O
pqparam	pointer
,	O
pblock	pointer
)	O
struct	O
sglobal	struct
*	O
qglobal	pointer
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
struct	O
uuconf_proto_param	struct
*	O
*	O
pqparam	pointer
;	O
pointer	pointer
pblock	pointer
;	O
{	O
struct	O
uuconf_proto_param	struct
*	O
q	pointer
;	O
size_t	long
c	long
;	O
struct	O
uuconf_proto_param_entry	struct
*	O
qentry	pointer
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
return	O
UUCONF_SYNTAX_ERROR	O
|	O
UUCONF_CMDTABRET_EXIT	O
;	O
if	O
(	O
argv	pointer
[	O
0	int
]	O
[	O
1	int
]	O
!=	O
'\0'	O
)	O
return	O
UUCONF_SYNTAX_ERROR	O
|	O
UUCONF_CMDTABRET_EXIT	O
;	O
if	O
(	O
*	O
pqparam	pointer
==	O
NULL	O
)	O
{	O
*	O
pqparam	pointer
=	O
(	O
(	O
struct	O
uuconf_proto_param	struct
*	O
)	O
uuconf_malloc	function
(	O
pblock	pointer
,	O
2	int
*	O
sizeof	O
(	O
struct	O
uuconf_proto_param	struct
)	O
)	O
)	O
;	O
if	O
(	O
*	O
pqparam	pointer
==	O
NULL	O
)	O
{	O
qglobal	pointer
->	O
ierrno	int
=	O
errno	O
;	O
return	O
(	O
UUCONF_MALLOC_FAILED	O
|	O
UUCONF_ERROR_ERRNO	O
|	O
UUCONF_CMDTABRET_EXIT	O
)	O
;	O
}	O
(	O
*	O
pqparam	pointer
)	O
[	O
1	int
]	O
.	O
uuconf_bproto	int
=	O
'\0'	O
;	O
q	pointer
=	O
*	O
pqparam	pointer
;	O
q	pointer
->	O
uuconf_bproto	pointer
=	O
argv	pointer
[	O
0	int
]	O
[	O
0	int
]	O
;	O
q	pointer
->	O
uuconf_qentries	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
c	int
=	O
0	int
;	O
for	O
(	O
q	int
=	O
*	O
pqparam	pointer
;	O
q	pointer
->	O
uuconf_bproto	int
!=	O
'\0'	O
;	O
q	pointer
++	O
)	O
{	O
if	O
(	O
q	pointer
->	O
uuconf_bproto	pointer
==	O
argv	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
break	O
;	O
++	O
c	int
;	O
}	O
if	O
(	O
q	pointer
->	O
uuconf_bproto	char
==	O
'\0'	O
)	O
{	O
struct	O
uuconf_proto_param	struct
*	O
qnew	pointer
;	O
qnew	pointer
=	O
(	O
(	O
struct	O
uuconf_proto_param	struct
*	O
)	O
uuconf_malloc	function
(	O
pblock	pointer
,	O
(	O
(	O
c	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
struct	O
uuconf_proto_param	struct
)	O
)	O
)	O
)	O
;	O
if	O
(	O
qnew	pointer
==	O
NULL	O
)	O
{	O
qglobal	pointer
->	O
ierrno	int
=	O
errno	O
;	O
return	O
(	O
UUCONF_MALLOC_FAILED	O
|	O
UUCONF_ERROR_ERRNO	O
|	O
UUCONF_CMDTABRET_EXIT	O
)	O
;	O
}	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
qnew	pointer
,	O
(	O
pointer	pointer
)	O
*	O
pqparam	pointer
,	O
c	int
*	O
sizeof	O
(	O
struct	O
uuconf_proto_param	struct
)	O
)	O
;	O
qnew	pointer
[	O
c	int
+	O
1	int
]	O
.	O
uuconf_bproto	int
=	O
'\0'	O
;	O
uuconf_free	function
(	O
pblock	pointer
,	O
*	O
pqparam	pointer
)	O
;	O
*	O
pqparam	pointer
=	O
qnew	pointer
;	O
q	pointer
=	O
qnew	pointer
+	O
c	int
;	O
q	pointer
->	O
uuconf_bproto	pointer
=	O
argv	pointer
[	O
0	int
]	O
[	O
0	int
]	O
;	O
q	pointer
->	O
uuconf_qentries	pointer
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
q	pointer
->	O
uuconf_qentries	pointer
==	O
NULL	O
)	O
{	O
qentry	pointer
=	O
(	O
(	O
struct	O
uuconf_proto_param_entry	struct
*	O
)	O
uuconf_malloc	function
(	O
pblock	pointer
,	O
2	int
*	O
sizeof	O
(	O
struct	O
uuconf_proto_param_entry	struct
)	O
)	O
)	O
;	O
if	O
(	O
qentry	pointer
==	O
NULL	O
)	O
{	O
qglobal	pointer
->	O
ierrno	int
=	O
errno	O
;	O
return	O
(	O
UUCONF_MALLOC_FAILED	O
|	O
UUCONF_ERROR_ERRNO	O
|	O
UUCONF_CMDTABRET_EXIT	O
)	O
;	O
}	O
qentry	pointer
[	O
1	int
]	O
.	O
uuconf_cargs	int
=	O
0	int
;	O
q	pointer
->	O
uuconf_qentries	pointer
=	O
qentry	pointer
;	O
}	O
else	O
{	O
struct	O
uuconf_proto_param_entry	struct
*	O
qnewent	pointer
;	O
c	int
=	O
0	int
;	O
for	O
(	O
qentry	pointer
=	O
q	pointer
->	O
uuconf_qentries	pointer
;	O
qentry	pointer
->	O
uuconf_cargs	int
!=	O
0	int
;	O
qentry	pointer
++	O
)	O
++	O
c	int
;	O
qnewent	pointer
=	O
(	O
(	O
struct	O
uuconf_proto_param_entry	struct
*	O
)	O
uuconf_malloc	function
(	O
pblock	pointer
,	O
(	O
(	O
c	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
struct	O
uuconf_proto_param_entry	struct
)	O
)	O
)	O
)	O
;	O
if	O
(	O
qnewent	pointer
==	O
NULL	O
)	O
{	O
qglobal	pointer
->	O
ierrno	int
=	O
errno	O
;	O
return	O
(	O
UUCONF_MALLOC_FAILED	O
|	O
UUCONF_ERROR_ERRNO	O
|	O
UUCONF_CMDTABRET_EXIT	O
)	O
;	O
}	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
qnewent	pointer
,	O
(	O
pointer	pointer
)	O
q	pointer
->	O
uuconf_qentries	pointer
,	O
c	int
*	O
sizeof	O
(	O
struct	O
uuconf_proto_param_entry	struct
)	O
)	O
;	O
qnewent	pointer
[	O
c	int
+	O
1	int
]	O
.	O
uuconf_cargs	int
=	O
0	int
;	O
uuconf_free	function
(	O
pblock	pointer
,	O
q	pointer
->	O
uuconf_qentries	pointer
)	O
;	O
q	pointer
->	O
uuconf_qentries	int
=	O
qnewent	int
;	O
qentry	pointer
=	O
qnewent	int
+	O
c	int
;	O
}	O
qentry	pointer
->	O
uuconf_cargs	int
=	O
argc	int
-	O
1	int
;	O
qentry	pointer
->	O
uuconf_pzargs	pointer
=	O
(	O
char	O
*	O
*	O
)	O
uuconf_malloc	function
(	O
pblock	pointer
,	O
(	O
(	O
argc	int
-	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
)	O
;	O
if	O
(	O
qentry	pointer
->	O
uuconf_pzargs	pointer
==	O
NULL	O
)	O
{	O
qglobal	pointer
->	O
ierrno	int
=	O
errno	O
;	O
qentry	pointer
->	O
uuconf_cargs	int
=	O
0	int
;	O
return	O
(	O
UUCONF_MALLOC_FAILED	O
|	O
UUCONF_ERROR_ERRNO	O
|	O
UUCONF_CMDTABRET_EXIT	O
)	O
;	O
}	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
qentry	pointer
->	O
uuconf_pzargs	pointer
,	O
(	O
pointer	pointer
)	O
(	O
argv	pointer
+	O
1	int
)	O
,	O
(	O
argc	int
-	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
return	O
UUCONF_CMDTABRET_KEEP	O
;	O
}	O
const	O
char	O
_uuconf_prtsub_rcsid	array
[	O
]	O
=	O
"$Id: prtsub.c,v 1.8 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
void	O
_uuconf_uclear_port	function
(	O
qport	pointer
)	O
struct	O
uuconf_port	struct
*	O
qport	pointer
;	O
{	O
qport	pointer
->	O
uuconf_zname	pointer
=	O
NULL	O
;	O
qport	pointer
->	O
uuconf_ttype	enum
=	O
UUCONF_PORTTYPE_UNKNOWN	pointer
;	O
qport	pointer
->	O
uuconf_zprotocols	pointer
=	O
NULL	O
;	O
qport	pointer
->	O
uuconf_qproto_params	pointer
=	O
NULL	O
;	O
qport	pointer
->	O
uuconf_ireliable	int
=	O
(	O
UUCONF_RELIABLE_RELIABLE	O
|	O
UUCONF_RELIABLE_EIGHT	O
|	O
UUCONF_RELIABLE_FULLDUPLEX	O
)	O
;	O
qport	pointer
->	O
uuconf_zlockname	pointer
=	O
NULL	O
;	O
qport	pointer
->	O
uuconf_palloc	pointer
=	O
NULL	O
;	O
}	O
const	O
char	O
_uuconf_runuxq_rcsid	array
[	O
]	O
=	O
"$Id: runuxq.c,v 1.6 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
int	O
uuconf_runuuxqt	function
(	O
pglobal	pointer
,	O
pirunuuxqt	pointer
)	O
pointer	pointer
pglobal	pointer
;	O
int	O
*	O
pirunuuxqt	pointer
;	O
{	O
{	O
struct	O
sglobal	struct
*	O
qglobal	pointer
=	O
(	O
struct	O
sglobal	struct
*	O
)	O
pglobal	pointer
;	O
const	O
char	O
*	O
zrun	pointer
;	O
zrun	pointer
=	O
qglobal	pointer
->	O
qprocess	pointer
->	O
zrunuuxqt	pointer
;	O
if	O
(	O
zrun	pointer
==	O
NULL	O
||	O
strcasecmp	function
(	O
zrun	pointer
,	O
"once"	pointer
)	O
==	O
0	int
)	O
*	O
pirunuuxqt	pointer
=	O
UUCONF_RUNUUXQT_ONCE	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
zrun	pointer
,	O
"never"	pointer
)	O
==	O
0	int
)	O
*	O
pirunuuxqt	pointer
=	O
UUCONF_RUNUUXQT_NEVER	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
zrun	pointer
,	O
"percall"	pointer
)	O
==	O
0	int
)	O
*	O
pirunuuxqt	pointer
=	O
UUCONF_RUNUUXQT_PERCALL	int
;	O
else	O
{	O
char	O
*	O
zend	pointer
;	O
*	O
pirunuuxqt	pointer
=	O
strtol	function
(	O
(	O
char	O
*	O
)	O
qglobal	pointer
->	O
qprocess	pointer
->	O
zrunuuxqt	pointer
,	O
&	O
zend	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
zend	pointer
!=	O
'\0'	O
||	O
*	O
pirunuuxqt	pointer
<=	O
0	int
)	O
*	O
pirunuuxqt	pointer
=	O
UUCONF_RUNUUXQT_ONCE	pointer
;	O
}	O
}	O
return	O
UUCONF_SUCCESS	O
;	O
}	O
const	O
char	O
_uuconf_stafil_rcsid	array
[	O
]	O
=	O
"$Id: stafil.c,v 1.6 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
int	O
uuconf_statsfile	function
(	O
pglobal	pointer
,	O
pzstats	pointer
)	O
pointer	pointer
pglobal	pointer
;	O
const	O
char	O
*	O
*	O
pzstats	pointer
;	O
{	O
struct	O
sglobal	struct
*	O
qglobal	pointer
=	O
(	O
struct	O
sglobal	struct
*	O
)	O
pglobal	pointer
;	O
*	O
pzstats	pointer
=	O
qglobal	pointer
->	O
qprocess	pointer
->	O
zstatsfile	pointer
;	O
return	O
UUCONF_SUCCESS	O
;	O
}	O
const	O
char	O
_uuconf_strip_rcsid	array
[	O
]	O
=	O
"$Id: strip.c,v 1.3 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
int	O
uuconf_strip	function
(	O
pglobal	pointer
,	O
pistrip	pointer
)	O
pointer	pointer
pglobal	pointer
;	O
int	O
*	O
pistrip	pointer
;	O
{	O
struct	O
sglobal	struct
*	O
qglobal	pointer
=	O
(	O
struct	O
sglobal	struct
*	O
)	O
pglobal	pointer
;	O
*	O
pistrip	pointer
=	O
0	int
;	O
if	O
(	O
qglobal	pointer
->	O
qprocess	pointer
->	O
fstrip_login	pointer
)	O
*	O
pistrip	pointer
|=	O
UUCONF_STRIP_LOGIN	int
;	O
if	O
(	O
qglobal	pointer
->	O
qprocess	pointer
->	O
fstrip_proto	pointer
)	O
*	O
pistrip	pointer
|=	O
UUCONF_STRIP_PROTO	int
;	O
return	O
UUCONF_SUCCESS	O
;	O
}	O
const	O
char	O
_uuconf_tgcmp_rcsid	array
[	O
]	O
=	O
"$Id: tgcmp.c,v 1.6 2002/03/05 19:10:43 ian Rel $"	pointer
;	O
int	O
_uuconf_itime_grade_cmp	function
(	O
i1	enum
,	O
i2	int
)	O
long	O
i1	int
;	O
long	O
i2	int
;	O
{	O
return	O
UUCONF_GRADE_CMP	function
(	O
(	O
int	O
)	O
i1	int
,	O
(	O
int	O
)	O
i2	int
)	O
;	O
}	O
const	O
char	O
_uuconf_vinit_rcsid	array
[	O
]	O
=	O
"$Id: vinit.c,v 1.6 2002/03/05 19:10:43 ian Rel $"	pointer
;	O
static	O
int	O
ivinlib	function
P	O
(	O
(	O
struct	O
sglobal	struct
*	O
qglobal	pointer
,	O
const	O
char	O
*	O
z	pointer
,	O
size_t	long
csize	long
,	O
char	O
*	O
*	O
pz	pointer
)	O
)	O
;	O
static	O
int	O
ivinlib	function
(	O
qglobal	pointer
,	O
z	pointer
,	O
c	pointer
,	O
pz	pointer
)	O
struct	O
sglobal	struct
*	O
qglobal	pointer
;	O
const	O
char	O
*	O
z	pointer
;	O
size_t	long
c	long
;	O
char	O
*	O
*	O
pz	pointer
;	O
{	O
char	O
*	O
zalc	pointer
;	O
zalc	pointer
=	O
uuconf_malloc	function
(	O
qglobal	pointer
->	O
pblock	pointer
,	O
sizeof	O
OLDCONFIGLIB	O
-	O
1	int
+	O
c	int
)	O
;	O
if	O
(	O
zalc	pointer
==	O
NULL	O
)	O
{	O
qglobal	pointer
->	O
ierrno	int
=	O
errno	O
;	O
return	O
UUCONF_MALLOC_FAILED	O
|	O
UUCONF_ERROR_ERRNO	O
;	O
}	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
zalc	pointer
,	O
(	O
pointer	pointer
)	O
OLDCONFIGLIB	O
,	O
sizeof	O
OLDCONFIGLIB	O
-	O
1	int
)	O
;	O
memcpy	function
(	O
(	O
pointer	pointer
)	O
(	O
zalc	pointer
+	O
sizeof	O
OLDCONFIGLIB	O
-	O
1	int
)	O
,	O
(	O
pointer	pointer
)	O
z	pointer
,	O
c	int
)	O
;	O
*	O
pz	pointer
=	O
zalc	pointer
;	O
return	O
UUCONF_SUCCESS	O
;	O
}	O
int	O
uuconf_v2_init	function
(	O
ppglobal	pointer
)	O
pointer	pointer
*	O
ppglobal	pointer
;	O
{	O
struct	O
sglobal	struct
*	O
*	O
pqglobal	pointer
=	O
(	O
struct	O
sglobal	struct
*	O
*	O
)	O
ppglobal	pointer
;	O
int	O
iret	int
;	O
struct	O
sglobal	struct
*	O
qglobal	pointer
;	O
char	O
*	O
zdialcodes	pointer
;	O
if	O
(	O
*	O
pqglobal	pointer
==	O
NULL	O
)	O
{	O
iret	int
=	O
_uuconf_iinit_global	function
(	O
pqglobal	pointer
)	O
;	O
if	O
(	O
iret	int
!=	O
UUCONF_SUCCESS	O
)	O
return	O
iret	int
;	O
}	O
qglobal	pointer
=	O
*	O
pqglobal	pointer
;	O
iret	int
=	O
ivinlib	function
(	O
qglobal	pointer
,	O
V2_SYSTEMS	pointer
,	O
sizeof	O
V2_SYSTEMS	pointer
,	O
&	O
qglobal	pointer
->	O
qprocess	pointer
->	O
zv2systems	pointer
)	O
;	O
if	O
(	O
iret	int
!=	O
UUCONF_SUCCESS	O
)	O
return	O
iret	int
;	O
iret	int
=	O
ivinlib	function
(	O
qglobal	pointer
,	O
V2_DEVICES	pointer
,	O
sizeof	O
V2_DEVICES	pointer
,	O
&	O
qglobal	pointer
->	O
qprocess	pointer
->	O
zv2devices	pointer
)	O
;	O
if	O
(	O
iret	int
!=	O
UUCONF_SUCCESS	O
)	O
return	O
iret	int
;	O
iret	int
=	O
ivinlib	function
(	O
qglobal	pointer
,	O
V2_USERFILE	pointer
,	O
sizeof	O
V2_USERFILE	pointer
,	O
&	O
qglobal	pointer
->	O
qprocess	pointer
->	O
zv2userfile	pointer
)	O
;	O
if	O
(	O
iret	int
!=	O
UUCONF_SUCCESS	O
)	O
return	O
iret	int
;	O
iret	int
=	O
ivinlib	function
(	O
qglobal	pointer
,	O
V2_CMDS	pointer
,	O
sizeof	O
V2_CMDS	pointer
,	O
&	O
qglobal	pointer
->	O
qprocess	pointer
->	O
zv2cmds	pointer
)	O
;	O
if	O
(	O
iret	int
!=	O
UUCONF_SUCCESS	O
)	O
return	O
iret	int
;	O
iret	int
=	O
ivinlib	function
(	O
qglobal	pointer
,	O
V2_DIALCODES	pointer
,	O
sizeof	O
V2_DIALCODES	pointer
,	O
&	O
zdialcodes	struct
)	O
;	O
if	O
(	O
iret	int
!=	O
UUCONF_SUCCESS	O
)	O
return	O
iret	int
;	O
return	O
_uuconf_iadd_string	function
(	O
qglobal	pointer
,	O
zdialcodes	pointer
,	O
FALSE	O
,	O
FALSE	O
,	O
&	O
qglobal	pointer
->	O
qprocess	pointer
->	O
pzdialcodefiles	pointer
,	O
qglobal	pointer
->	O
pblock	pointer
)	O
;	O
}	O
const	O
char	O
uuname_rcsid	array
[	O
]	O
=	O
"$Id: uuname.c,v 1.24 2002/03/05 19:10:42 ian Rel $"	pointer
;	O
static	O
void	O
unusage	function
P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
unhelp	function
P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
const	O
struct	O
option	struct
asNlongopts	array
[	O
]	O
=	O
{	O
{	O
"aliases"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'a'	O
}	O
,	O
{	O
"local"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"config"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'I'	O
}	O
,	O
{	O
"debug"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
int	O
main	function
(	O
argc	int
,	O
argv	pointer
)	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
{	O
boolean	int
falias	int
=	O
FALSE	O
;	O
boolean	int
flocal	int
=	O
FALSE	O
;	O
const	O
char	O
*	O
zconfig	pointer
=	O
NULL	O
;	O
int	O
iopt	int
;	O
pointer	pointer
puuconf	pointer
;	O
int	O
iuuconf	int
;	O
zProgram	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
while	O
(	O
(	O
iopt	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"alI:vx:"	pointer
,	O
asNlongopts	pointer
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
iopt	int
)	O
{	O
case	O
'a'	O
:	O
falias	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'l'	O
:	O
flocal	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
'I'	O
:	O
if	O
(	O
fsysdep_other_config	function
(	O
optarg	pointer
)	O
)	O
zconfig	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'x'	O
:	O
iDebug	int
|=	O
idebug_parse	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
printf	function
(	O
"uuname (Taylor UUCP) %s\n"	pointer
,	O
VERSION	pointer
)	O
;	O
printf	function
(	O
"Copyright (C) 1991, 92, 93, 94, 1995, 2002 Ian Lance Taylor\n"	pointer
)	O
;	O
printf	function
(	O
"This program is free software; you may redistribute it under the terms of\n"	pointer
)	O
;	O
printf	function
(	O
"the GNU General Public LIcense.  This program has ABSOLUTELY NO WARRANTY.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
1	int
:	O
unhelp	function
(	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
unusage	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
optind	int
!=	O
argc	int
)	O
unusage	function
(	O
)	O
;	O
iuuconf	int
=	O
uuconf_init	function
(	O
&	O
puuconf	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
zconfig	pointer
)	O
;	O
if	O
(	O
iuuconf	int
!=	O
UUCONF_SUCCESS	O
)	O
ulog_uuconf	function
(	O
LOG_FATAL	int
,	O
puuconf	pointer
,	O
iuuconf	int
)	O
;	O
{	O
const	O
char	O
*	O
zdebug	pointer
;	O
iuuconf	int
=	O
uuconf_debuglevel	function
(	O
puuconf	pointer
,	O
&	O
zdebug	pointer
)	O
;	O
if	O
(	O
iuuconf	int
!=	O
UUCONF_SUCCESS	O
)	O
ulog_uuconf	function
(	O
LOG_FATAL	int
,	O
puuconf	pointer
,	O
iuuconf	int
)	O
;	O
if	O
(	O
zdebug	pointer
!=	O
NULL	O
)	O
iDebug	int
|=	O
idebug_parse	function
(	O
zdebug	pointer
)	O
;	O
}	O
usysdep_initialize	function
(	O
puuconf	pointer
,	O
INIT_SUID	O
|	O
INIT_NOCHDIR	O
)	O
;	O
if	O
(	O
flocal	int
)	O
{	O
const	O
char	O
*	O
zlocalname	pointer
;	O
iuuconf	int
=	O
uuconf_localname	function
(	O
puuconf	pointer
,	O
&	O
zlocalname	pointer
)	O
;	O
if	O
(	O
iuuconf	int
==	O
UUCONF_NOT_FOUND	O
)	O
{	O
zlocalname	pointer
=	O
zsysdep_localname	function
(	O
)	O
;	O
if	O
(	O
zlocalname	pointer
==	O
NULL	O
)	O
usysdep_exit	function
(	O
FALSE	O
)	O
;	O
}	O
else	O
if	O
(	O
iuuconf	int
!=	O
UUCONF_SUCCESS	O
)	O
ulog_uuconf	function
(	O
LOG_FATAL	int
,	O
puuconf	pointer
,	O
iuuconf	int
)	O
;	O
printf	function
(	O
"%s\n"	pointer
,	O
zlocalname	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
*	O
pznames	pointer
,	O
*	O
*	O
pz	pointer
;	O
iuuconf	int
=	O
uuconf_system_names	function
(	O
puuconf	pointer
,	O
&	O
pznames	pointer
,	O
falias	int
)	O
;	O
if	O
(	O
iuuconf	int
!=	O
UUCONF_SUCCESS	O
)	O
ulog_uuconf	function
(	O
LOG_FATAL	int
,	O
puuconf	pointer
,	O
iuuconf	int
)	O
;	O
for	O
(	O
pz	pointer
=	O
pznames	pointer
;	O
*	O
pz	pointer
!=	O
NULL	O
;	O
pz	pointer
++	O
)	O
printf	function
(	O
"%s\n"	pointer
,	O
*	O
pz	pointer
)	O
;	O
}	O
usysdep_exit	function
(	O
TRUE	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
unusage	function
(	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Usage: %s [-a] [-l] [-I file]\n"	pointer
,	O
zProgram	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Use %s --help for help\n"	pointer
,	O
zProgram	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
void	O
unhelp	function
(	O
)	O
{	O
printf	function
(	O
"Taylor UUCP %s, copyright (C) 1991, 92, 93, 94, 1995, 2002 Ian Lance Taylor\n"	pointer
,	O
VERSION	pointer
)	O
;	O
printf	function
(	O
"Usage: %s [-a] [-l] [-I file]\n"	pointer
,	O
zProgram	pointer
)	O
;	O
printf	function
(	O
" -a,--aliases: display aliases\n"	pointer
)	O
;	O
printf	function
(	O
" -l,--local: print local name\n"	pointer
)	O
;	O
printf	function
(	O
" -I,--config file: Set configuration file to use\n"	pointer
)	O
;	O
printf	function
(	O
" -v,--version: Print version and exit\n"	pointer
)	O
;	O
printf	function
(	O
" --help: Print help and exit\n"	pointer
)	O
;	O
printf	function
(	O
"Report bugs to taylor-uucp@gnu.org\n"	pointer
)	O
;	O
}	O
static	O
int	O
openpipe	function
(	O
int	O
dir	int
,	O
char	O
*	O
progname	pointer
,	O
va_list	array
ap	pointer
)	O
{	O
int	O
fds	pointer
[	O
2	int
]	O
;	O
char	O
*	O
args	array
[	O
100	int
]	O
;	O
int	O
argno	int
=	O
0	int
;	O
args	array
[	O
argno	int
++	O
]	O
=	O
progname	pointer
;	O
while	O
(	O
(	O
args	array
[	O
argno	int
++	O
]	O
=	O
va_arg	O
(	O
ap	pointer
,	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
;	O
if	O
(	O
pipe	function
(	O
fds	pointer
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
switch	O
(	O
fork	function
(	O
)	O
)	O
{	O
case	O
0	int
:	O
close	pointer
(	O
fds	pointer
[	O
1	int
-	O
dir	int
]	O
)	O
;	O
if	O
(	O
dup2	function
(	O
fds	pointer
[	O
dir	int
]	O
,	O
dir	pointer
)	O
==	O
-	O
1	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"error redirecting stream"	pointer
)	O
)	O
;	O
_exit	function
(	O
2	int
)	O
;	O
}	O
execvp	function
(	O
args	array
[	O
0	int
]	O
,	O
args	array
)	O
;	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"failed to execute %s"	pointer
)	O
,	O
progname	pointer
)	O
;	O
_exit	function
(	O
2	int
)	O
;	O
case	O
-	O
1	int
:	O
return	O
0	int
;	O
default	O
:	O
close	function
(	O
fds	pointer
[	O
dir	int
]	O
)	O
;	O
return	O
fds	pointer
[	O
1	int
-	O
dir	int
]	O
;	O
}	O
}	O
FILE	struct
*	O
readpipe	function
(	O
char	O
*	O
progname	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
fd	int
;	O
va_start	O
(	O
ap	array
,	O
progname	pointer
)	O
;	O
fd	int
=	O
openpipe	function
(	O
1	int
,	O
progname	pointer
,	O
ap	pointer
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
fdopen	function
(	O
fd	int
,	O
"r"	pointer
)	O
;	O
}	O
FILE	struct
*	O
writepipe	function
(	O
char	O
*	O
progname	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
fd	int
;	O
va_start	O
(	O
ap	array
,	O
progname	pointer
)	O
;	O
fd	int
=	O
openpipe	function
(	O
0	int
,	O
progname	pointer
,	O
ap	pointer
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
fdopen	function
(	O
fd	int
,	O
"w"	pointer
)	O
;	O
}	O
int	O
main	function
(	O
void	O
)	O
{	O
wget_iri	struct
*	O
uri	pointer
;	O
wget_http_connection	struct
*	O
conn	pointer
=	O
NULL	O
;	O
wget_http_request	struct
*	O
req	pointer
;	O
wget_cookie_db	struct
*	O
cookies	pointer
;	O
wget_logger_set_stream	function
(	O
wget_get_logger	function
(	O
WGET_LOGGER_DEBUG	int
)	O
,	O
stderr	pointer
)	O
;	O
wget_logger_set_stream	function
(	O
wget_get_logger	function
(	O
WGET_LOGGER_ERROR	int
)	O
,	O
stderr	pointer
)	O
;	O
wget_logger_set_stream	function
(	O
wget_get_logger	function
(	O
WGET_LOGGER_INFO	int
)	O
,	O
stdout	pointer
)	O
;	O
wget_net_init	function
(	O
)	O
;	O
uri	pointer
=	O
wget_iri_parse	function
(	O
"http://www.example.org"	pointer
,	O
NULL	O
)	O
;	O
req	pointer
=	O
wget_http_create_request	function
(	O
uri	pointer
,	O
"GET"	pointer
)	O
;	O
wget_http_add_header	function
(	O
req	pointer
,	O
"User-Agent"	pointer
,	O
"TheUserAgent/0.5"	pointer
)	O
;	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Accept-Encoding"	pointer
,	O
"gzip, deflate"	pointer
)	O
;	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Accept"	pointer
,	O
"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"	pointer
)	O
;	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Accept-Language"	pointer
,	O
"en-us,en;q=0.5"	pointer
)	O
;	O
wget_http_request_set_int	function
(	O
req	pointer
,	O
WGET_HTTP_RESPONSE_KEEPHEADER	int
,	O
1	int
)	O
;	O
const	O
char	O
*	O
cookie_string	pointer
;	O
cookies	pointer
=	O
wget_cookie_db_init	function
(	O
NULL	O
)	O
;	O
wget_cookie_set_keep_session_cookies	function
(	O
cookies	pointer
,	O
1	int
)	O
;	O
wget_cookie_db_load_psl	function
(	O
cookies	pointer
,	O
"public_suffixes.txt"	pointer
)	O
;	O
wget_cookie_db_load	function
(	O
cookies	pointer
,	O
"cookies.txt"	pointer
)	O
;	O
if	O
(	O
(	O
cookie_string	int
=	O
wget_cookie_create_request_header	function
(	O
cookies	pointer
,	O
uri	pointer
)	O
)	O
)	O
{	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Cookie"	pointer
,	O
cookie_string	pointer
)	O
;	O
wget_xfree	O
(	O
cookie_string	pointer
)	O
;	O
}	O
wget_http_open	function
(	O
&	O
conn	pointer
,	O
uri	pointer
)	O
;	O
if	O
(	O
conn	pointer
)	O
{	O
wget_http_response	struct
*	O
resp	pointer
;	O
if	O
(	O
wget_http_send_request	function
(	O
conn	pointer
,	O
req	pointer
)	O
==	O
0	int
)	O
{	O
resp	pointer
=	O
wget_http_get_response	function
(	O
conn	pointer
)	O
;	O
if	O
(	O
!	O
resp	pointer
)	O
goto	O
out	pointer
;	O
if	O
(	O
!	O
resp	pointer
->	O
keep_alive	pointer
)	O
wget_http_close	function
(	O
&	O
conn	pointer
)	O
;	O
wget_cookie_normalize_cookies	function
(	O
uri	pointer
,	O
resp	pointer
->	O
cookies	pointer
)	O
;	O
wget_cookie_store_cookies	function
(	O
cookies	pointer
,	O
resp	pointer
->	O
cookies	pointer
)	O
;	O
wget_cookie_db_save	function
(	O
cookies	pointer
,	O
"cookies.txt"	pointer
)	O
;	O
wget_info_printf	function
(	O
"%s%s\n"	pointer
,	O
resp	pointer
->	O
header	pointer
->	O
data	pointer
,	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
)	O
;	O
wget_http_free_response	function
(	O
&	O
resp	pointer
)	O
;	O
}	O
}	O
out	O
:	O
wget_cookie_db_free	function
(	O
&	O
cookies	O
)	O
;	O
wget_http_close	function
(	O
&	O
conn	pointer
)	O
;	O
wget_http_free_request	function
(	O
&	O
req	pointer
)	O
;	O
wget_iri_free	function
(	O
&	O
uri	pointer
)	O
;	O
wget_net_deinit	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
css_context	struct
{	O
wget_iri	struct
*	O
base	pointer
;	O
const	O
char	O
*	O
encoding	pointer
;	O
wget_buffer	struct
uri_buf	pointer
;	O
char	O
encoding_allocated	char
;	O
}	O
;	O
static	O
void	O
WGET_GCC_NORETURN	function
usage	function
(	O
const	O
char	O
*	O
myname	pointer
)	O
{	O
error_printf_exit	O
(	O
"\nUsage: %s [options] file...\n"	pointer
"  --base <URI>          Default base for relative URIs, default: http://www.example.com\n"	pointer
"  --encoding <Encoding> Default file character encoding, default: iso-8859-1\n"	pointer
"\n"	pointer
"  Examples:\n"	pointer
"    %s --base http://www.mydomain.com x.css\n"	pointer
"    cat x.css | %s --base http://www.mydomain.com -\n"	pointer
"\n"	pointer
"  Print URIs as found (without a base):\n"	pointer
"    %s --base \"\" x.css\n\n"	pointer
,	O
myname	int
,	O
myname	int
,	O
myname	int
,	O
myname	int
)	O
;	O
}	O
static	O
void	O
css_parse_encoding	function
(	O
void	O
*	O
context	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
size_t	long
len	long
)	O
{	O
struct	O
css_context	struct
*	O
ctx	pointer
=	O
context	pointer
;	O
if	O
(	O
!	O
ctx	pointer
->	O
encoding_allocated	pointer
&&	O
wget_strncasecmp_ascii	function
(	O
ctx	pointer
->	O
encoding	pointer
,	O
encoding	pointer
,	O
len	long
)	O
)	O
{	O
if	O
(	O
ctx	pointer
->	O
encoding	pointer
)	O
info_printf	function
(	O
"Encoding changed from '%s' to '%.*s'\n"	pointer
,	O
ctx	pointer
->	O
encoding	pointer
,	O
(	O
int	O
)	O
len	int
,	O
encoding	pointer
)	O
;	O
else	O
info_printf	function
(	O
"Encoding set to '%.*s'\n"	pointer
,	O
(	O
int	O
)	O
len	int
,	O
encoding	pointer
)	O
;	O
ctx	pointer
->	O
encoding	pointer
=	O
wget_strmemdup	function
(	O
encoding	pointer
,	O
len	long
)	O
;	O
ctx	pointer
->	O
encoding_allocated	int
=	O
1	int
;	O
}	O
}	O
static	O
void	O
css_parse_uri	function
(	O
void	O
*	O
context	pointer
,	O
const	O
char	O
*	O
url	pointer
,	O
size_t	long
len	long
,	O
size_t	long
pos	int
WGET_GCC_UNUSED	O
)	O
{	O
struct	O
css_context	struct
*	O
ctx	pointer
=	O
context	pointer
;	O
if	O
(	O
!	O
ctx	pointer
->	O
base	pointer
)	O
{	O
wget_info_printf	function
(	O
"  %.*s\n"	pointer
,	O
(	O
int	O
)	O
len	long
,	O
url	pointer
)	O
;	O
}	O
else	O
if	O
(	O
wget_iri_relative_to_abs	function
(	O
ctx	pointer
->	O
base	pointer
,	O
url	pointer
,	O
len	long
,	O
&	O
ctx	pointer
->	O
uri_buf	pointer
)	O
)	O
{	O
wget_info_printf	function
(	O
"  %.*s -> %s\n"	pointer
,	O
(	O
int	O
)	O
len	int
,	O
url	pointer
,	O
ctx	pointer
->	O
uri_buf	struct
.	O
data	pointer
)	O
;	O
}	O
else	O
{	O
error_printf	O
(	O
"Cannot resolve relative URI %.*s\n"	pointer
,	O
(	O
int	O
)	O
len	int
,	O
url	pointer
)	O
;	O
}	O
}	O
static	O
void	O
css_parse_localfile	function
(	O
const	O
char	O
*	O
fname	pointer
,	O
wget_iri	struct
*	O
base	pointer
,	O
const	O
char	O
*	O
encoding	pointer
)	O
{	O
struct	O
css_context	struct
context	pointer
=	O
{	O
.	O
base	pointer
=	O
base	pointer
,	O
.	O
encoding	pointer
=	O
encoding	pointer
}	O
;	O
wget_buffer_init	function
(	O
&	O
context	pointer
.	O
uri_buf	O
,	O
NULL	O
,	O
128	int
)	O
;	O
wget_css_parse_file	function
(	O
fname	pointer
,	O
css_parse_uri	pointer
,	O
css_parse_encoding	pointer
,	O
&	O
context	pointer
)	O
;	O
if	O
(	O
context	pointer
.	O
encoding_allocated	int
)	O
wget_xfree	O
(	O
context	pointer
.	O
encoding	pointer
)	O
;	O
wget_buffer_deinit	function
(	O
&	O
context	pointer
.	O
uri_buf	O
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
const	O
char	O
*	O
const	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
base	pointer
=	O
"http://www.example.com"	pointer
;	O
const	O
char	O
*	O
local_encoding	pointer
=	O
wget_local_charset_encoding	function
(	O
)	O
;	O
wget_iri	struct
*	O
base_uri	pointer
;	O
const	O
char	O
*	O
css_encoding	pointer
=	O
NULL	O
;	O
int	O
argpos	int
;	O
wget_logger_set_stream	function
(	O
wget_get_logger	function
(	O
WGET_LOGGER_ERROR	int
)	O
,	O
stderr	pointer
)	O
;	O
wget_logger_set_stream	function
(	O
wget_get_logger	function
(	O
WGET_LOGGER_INFO	int
)	O
,	O
stdout	pointer
)	O
;	O
for	O
(	O
argpos	int
=	O
1	int
;	O
argpos	int
<	O
argc	int
;	O
argpos	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
argv	pointer
[	O
argpos	int
]	O
,	O
"--base"	pointer
)	O
&&	O
argc	int
-	O
argpos	int
>	O
1	int
)	O
{	O
base	pointer
=	O
argv	pointer
[	O
++	O
argpos	int
]	O
;	O
info_printf	function
(	O
"Base URL encoding = '%s'\n"	pointer
,	O
local_encoding	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
argv	pointer
[	O
argpos	int
]	O
,	O
"--encoding"	pointer
)	O
&&	O
argc	int
-	O
argpos	int
>	O
1	int
)	O
{	O
css_encoding	pointer
=	O
argv	pointer
[	O
++	O
argpos	int
]	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
argv	pointer
[	O
argpos	int
]	O
,	O
"--"	pointer
)	O
)	O
{	O
argpos	int
++	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
argv	pointer
[	O
argpos	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
usage	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
}	O
else	O
break	O
;	O
}	O
base_uri	int
=	O
wget_iri_parse	function
(	O
base	int
,	O
local_encoding	pointer
)	O
;	O
for	O
(	O
;	O
argpos	int
<	O
argc	int
;	O
argpos	int
++	O
)	O
{	O
css_parse_localfile	function
(	O
argv	pointer
[	O
argpos	int
]	O
,	O
base_uri	int
,	O
css_encoding	int
)	O
;	O
}	O
wget_iri_free	function
(	O
&	O
base_uri	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
WGET_GCC_NORETURN	function
usage	function
(	O
const	O
char	O
*	O
myname	pointer
)	O
{	O
error_printf_exit	O
(	O
"\nUsage: %s [options] file...\n"	pointer
"  --base <URI>          Default base for relative URIs, default: http://www.example.com\n"	pointer
"  --encoding <Encoding> Default file character encoding, default: iso-8859-1\n"	pointer
"\n"	pointer
"  Examples:\n"	pointer
"    %s --base http://www.mydomain.com x.css\n"	pointer
"    cat x.css | %s --base http://www.mydomain.com -\n"	pointer
"    %s http://www.example.com\n"	pointer
"\n"	pointer
"  Print URIs as found (without a base):\n"	pointer
"    %s --base \"\" x.css\n\n"	pointer
,	O
myname	int
,	O
myname	int
,	O
myname	int
,	O
myname	int
,	O
myname	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
const	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
const	O
char	O
*	O
base	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
local_encoding	pointer
=	O
wget_local_charset_encoding	function
(	O
)	O
;	O
wget_iri	struct
*	O
base_uri	pointer
;	O
const	O
char	O
*	O
css_encoding	pointer
=	O
NULL	O
;	O
int	O
argpos	int
;	O
wget_logger_set_stream	function
(	O
wget_get_logger	function
(	O
WGET_LOGGER_ERROR	int
)	O
,	O
stderr	pointer
)	O
;	O
wget_logger_set_stream	function
(	O
wget_get_logger	function
(	O
WGET_LOGGER_INFO	int
)	O
,	O
stdout	pointer
)	O
;	O
for	O
(	O
argpos	int
=	O
1	int
;	O
argpos	int
<	O
argc	int
;	O
argpos	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
argv	pointer
[	O
argpos	int
]	O
,	O
"--base"	pointer
)	O
&&	O
argc	int
-	O
argpos	int
>	O
1	int
)	O
{	O
base	pointer
=	O
argv	pointer
[	O
++	O
argpos	int
]	O
;	O
info_printf	function
(	O
"Local URI encoding = '%s'\n"	pointer
,	O
local_encoding	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
argv	pointer
[	O
argpos	int
]	O
,	O
"--encoding"	pointer
)	O
&&	O
argc	int
-	O
argpos	int
>	O
1	int
)	O
{	O
css_encoding	pointer
=	O
argv	pointer
[	O
++	O
argpos	int
]	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
argv	pointer
[	O
argpos	int
]	O
,	O
"--"	pointer
)	O
)	O
{	O
argpos	int
++	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
argv	pointer
[	O
argpos	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
usage	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
}	O
else	O
break	O
;	O
}	O
base_uri	pointer
=	O
base	pointer
?	O
wget_iri_parse	function
(	O
base	int
,	O
local_encoding	pointer
)	O
:	O
NULL	O
;	O
for	O
(	O
;	O
argpos	int
<	O
argc	int
;	O
argpos	int
++	O
)	O
{	O
wget_vector	struct
*	O
css_urls	pointer
=	O
wget_css_get_urls_from_localfile	function
(	O
argv	pointer
[	O
argpos	int
]	O
,	O
base_uri	pointer
,	O
&	O
css_encoding	O
)	O
;	O
if	O
(	O
wget_vector_size	function
(	O
css_urls	pointer
)	O
>	O
0	int
)	O
{	O
info_printf	function
(	O
"URL encoding for %s is '%s':\n"	pointer
,	O
argv	pointer
[	O
argpos	int
]	O
,	O
css_encoding	int
?	O
css_encoding	int
:	O
"UTF-8"	int
)	O
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
css_urls	int
)	O
;	O
it	int
++	O
)	O
{	O
wget_css_parsed_url	struct
*	O
css_url	pointer
=	O
wget_vector_get	function
(	O
css_urls	pointer
,	O
it	int
)	O
;	O
if	O
(	O
css_url	pointer
->	O
abs_url	pointer
)	O
info_printf	function
(	O
"  %s -> %s\n"	pointer
,	O
css_url	pointer
->	O
url	pointer
,	O
css_url	pointer
->	O
abs_url	pointer
)	O
;	O
else	O
info_printf	function
(	O
"  %s\n"	pointer
,	O
css_url	pointer
->	O
url	pointer
)	O
;	O
}	O
info_printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
wget_vector_free	function
(	O
&	O
css_urls	int
)	O
;	O
}	O
wget_iri_free	function
(	O
&	O
base_uri	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
WGET_GCC_UNUSED	O
,	O
const	O
char	O
*	O
const	O
*	O
argv	pointer
WGET_GCC_UNUSED	O
)	O
{	O
wget_http_connection	struct
*	O
conn	pointer
=	O
NULL	O
;	O
wget_http_request	struct
*	O
req	pointer
;	O
wget_http_response	struct
*	O
resp	pointer
;	O
wget_iri	struct
*	O
iri	pointer
;	O
wget_global_init	function
(	O
WGET_ERROR_STREAM	int
,	O
stderr	pointer
,	O
WGET_INFO_STREAM	int
,	O
stdout	pointer
,	O
0	int
)	O
;	O
const	O
char	O
*	O
text	pointer
=	O
"alice->bob: authentication request\nbob-->alice: response"	pointer
;	O
const	O
char	O
*	O
style	pointer
=	O
"qsd"	pointer
;	O
wget_buffer	struct
*	O
url	pointer
=	O
wget_buffer_alloc	function
(	O
128	int
)	O
;	O
wget_buffer	struct
*	O
body	pointer
=	O
wget_buffer_alloc	function
(	O
128	int
)	O
;	O
wget_buffer_strcpy	function
(	O
body	pointer
,	O
"message="	pointer
)	O
;	O
wget_iri_escape_query	function
(	O
text	pointer
,	O
body	pointer
)	O
;	O
wget_buffer_printf_append	function
(	O
body	pointer
,	O
"&style=%s&apiVersion=1"	pointer
,	O
style	pointer
)	O
;	O
iri	pointer
=	O
wget_iri_parse	function
(	O
"https://www.websequencediagrams.com"	pointer
,	O
NULL	O
)	O
;	O
req	pointer
=	O
wget_http_create_request	function
(	O
iri	pointer
,	O
"POST"	pointer
)	O
;	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Connection"	pointer
,	O
"keepalive"	pointer
)	O
;	O
wget_http_request_set_body	function
(	O
req	pointer
,	O
"application/x-www-form-urlencoded"	pointer
,	O
wget_memdup	function
(	O
body	pointer
->	O
data	pointer
,	O
body	pointer
->	O
length	long
)	O
,	O
body	pointer
->	O
length	long
)	O
;	O
wget_http_open	function
(	O
&	O
conn	pointer
,	O
iri	pointer
)	O
;	O
if	O
(	O
conn	pointer
)	O
{	O
if	O
(	O
wget_http_send_request	function
(	O
conn	pointer
,	O
req	pointer
)	O
)	O
goto	O
out	pointer
;	O
resp	pointer
=	O
wget_http_get_response	function
(	O
conn	pointer
)	O
;	O
if	O
(	O
!	O
resp	pointer
)	O
goto	O
out	pointer
;	O
const	O
char	O
*	O
p	pointer
,	O
*	O
e	pointer
;	O
if	O
(	O
!	O
(	O
p	pointer
=	O
strstr	function
(	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
,	O
"\"img\": \""	pointer
)	O
)	O
)	O
goto	O
out	pointer
;	O
if	O
(	O
!	O
(	O
e	pointer
=	O
strchr	function
(	O
p	pointer
+	O
8	int
,	O
'\"'	O
)	O
)	O
)	O
goto	O
out	pointer
;	O
p	pointer
+=	O
8	int
;	O
wget_buffer_printf	function
(	O
url	pointer
,	O
"https://www.websequencediagrams.com/%.*s"	pointer
,	O
(	O
int	O
)	O
(	O
e	pointer
-	O
p	pointer
)	O
,	O
p	pointer
)	O
;	O
wget_http_free_response	function
(	O
&	O
resp	pointer
)	O
;	O
wget_http_free_request	function
(	O
&	O
req	pointer
)	O
;	O
wget_iri_free	function
(	O
&	O
iri	pointer
)	O
;	O
iri	pointer
=	O
wget_iri_parse	function
(	O
url	pointer
->	O
data	pointer
,	O
NULL	O
)	O
;	O
req	pointer
=	O
wget_http_create_request	function
(	O
iri	pointer
,	O
"GET"	pointer
)	O
;	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Accept-Encoding"	pointer
,	O
"gzip"	pointer
)	O
;	O
if	O
(	O
wget_http_send_request	function
(	O
conn	pointer
,	O
req	pointer
)	O
)	O
goto	O
out	pointer
;	O
resp	pointer
=	O
wget_http_get_response	function
(	O
conn	pointer
)	O
;	O
if	O
(	O
!	O
resp	pointer
)	O
goto	O
out	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
"out.png"	pointer
,	O
"wb"	pointer
)	O
)	O
)	O
{	O
fwrite	function
(	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
,	O
1	int
,	O
resp	pointer
->	O
body	pointer
->	O
length	long
,	O
fp	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
wget_info_printf	function
(	O
"Saved out.png\n"	pointer
)	O
;	O
}	O
}	O
out	pointer
:	O
wget_http_free_response	function
(	O
&	O
resp	pointer
)	O
;	O
wget_http_free_request	function
(	O
&	O
req	pointer
)	O
;	O
wget_http_close	function
(	O
&	O
conn	pointer
)	O
;	O
wget_iri_free	function
(	O
&	O
iri	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
body	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
url	pointer
)	O
;	O
wget_global_deinit	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
typedef	O
int	O
wget_decompressor_decompress_fn	function
(	O
wget_decompressor	struct
*	O
dc	pointer
,	O
char	O
*	O
src	pointer
,	O
size_t	long
srclen	long
)	O
;	O
typedef	O
void	O
wget_decompressor_exit_fn	function
(	O
wget_decompressor	struct
*	O
dc	pointer
)	O
;	O
struct	O
wget_decompressor_st	struct
{	O
z_stream	struct
z_strm	struct
;	O
wget_decompressor_sink_fn	struct
*	O
sink	pointer
;	O
wget_decompressor_error_handler	struct
*	O
error_handler	pointer
;	O
wget_decompressor_decompress_fn	struct
*	O
decompress	pointer
;	O
wget_decompressor_exit_fn	struct
*	O
exit	pointer
;	O
void	O
*	O
context	pointer
;	O
wget_content_encoding	pointer
encoding	pointer
;	O
}	O
;	O
static	O
int	O
gzip_init	function
(	O
z_stream	struct
*	O
strm	pointer
)	O
{	O
memset	function
(	O
strm	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
strm	pointer
)	O
)	O
;	O
if	O
(	O
inflateInit2	function
(	O
strm	pointer
,	O
15	int
+	O
32	int
)	O
!=	O
Z_OK	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to init gzip decompression\n"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
gzip_decompress	function
(	O
wget_decompressor	struct
*	O
dc	pointer
,	O
char	O
*	O
src	pointer
,	O
size_t	long
srclen	long
)	O
{	O
z_stream	struct
*	O
strm	pointer
;	O
char	O
dst	pointer
[	O
10240	int
]	O
;	O
int	O
status	int
;	O
if	O
(	O
!	O
srclen	long
)	O
{	O
if	O
(	O
dc	pointer
->	O
sink	pointer
)	O
dc	pointer
->	O
sink	function
(	O
dc	pointer
->	O
context	pointer
,	O
""	pointer
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
strm	pointer
=	O
&	O
dc	pointer
->	O
z_strm	pointer
;	O
strm	pointer
->	O
next_in	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
src	pointer
;	O
strm	pointer
->	O
avail_in	int
=	O
(	O
unsigned	O
int	O
)	O
srclen	long
;	O
do	O
{	O
strm	pointer
->	O
next_out	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
dst	pointer
;	O
strm	pointer
->	O
avail_out	int
=	O
sizeof	O
(	O
dst	pointer
)	O
;	O
status	int
=	O
inflate	function
(	O
strm	pointer
,	O
Z_SYNC_FLUSH	int
)	O
;	O
if	O
(	O
(	O
status	int
==	O
Z_OK	int
||	O
status	int
==	O
Z_STREAM_END	int
)	O
&&	O
strm	pointer
->	O
avail_out	int
<	O
sizeof	O
(	O
dst	pointer
)	O
)	O
{	O
if	O
(	O
dc	pointer
->	O
sink	pointer
)	O
dc	pointer
->	O
sink	function
(	O
dc	pointer
->	O
context	pointer
,	O
dst	pointer
,	O
sizeof	O
(	O
dst	pointer
)	O
-	O
strm	pointer
->	O
avail_out	int
)	O
;	O
}	O
}	O
while	O
(	O
status	int
==	O
Z_OK	int
&&	O
!	O
strm	pointer
->	O
avail_out	int
)	O
;	O
if	O
(	O
status	int
==	O
Z_OK	int
||	O
status	int
==	O
Z_STREAM_END	int
)	O
return	O
0	int
;	O
error_printf	O
(	O
_	O
(	O
"Failed to uncompress gzip stream (%d)\n"	pointer
)	O
,	O
status	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
gzip_exit	function
(	O
wget_decompressor	struct
*	O
dc	pointer
)	O
{	O
int	O
status	int
;	O
if	O
(	O
(	O
status	int
=	O
inflateEnd	function
(	O
&	O
dc	pointer
->	O
z_strm	struct
)	O
)	O
!=	O
Z_OK	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to close gzip stream (%d)\n"	pointer
)	O
,	O
status	int
)	O
;	O
}	O
}	O
static	O
int	O
deflate_init	function
(	O
z_stream	struct
*	O
strm	pointer
)	O
{	O
memset	function
(	O
strm	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
strm	pointer
)	O
)	O
;	O
if	O
(	O
inflateInit	O
(	O
strm	pointer
)	O
!=	O
Z_OK	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to init deflate decompression\n"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
identity	function
(	O
wget_decompressor	struct
*	O
dc	pointer
,	O
char	O
*	O
src	pointer
,	O
size_t	long
srclen	long
)	O
{	O
if	O
(	O
dc	pointer
->	O
sink	pointer
)	O
dc	pointer
->	O
sink	pointer
(	O
dc	pointer
->	O
context	pointer
,	O
src	pointer
,	O
srclen	long
)	O
;	O
return	O
0	int
;	O
}	O
wget_decompressor	struct
*	O
wget_decompress_open	function
(	O
wget_content_encoding	pointer
encoding	pointer
,	O
wget_decompressor_sink_fn	struct
*	O
sink	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
wget_decompressor	struct
*	O
dc	pointer
=	O
wget_calloc	function
(	O
1	int
,	O
sizeof	O
(	O
wget_decompressor	pointer
)	O
)	O
;	O
if	O
(	O
!	O
dc	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
encoding	pointer
==	O
wget_content_encoding_gzip	int
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
gzip_init	function
(	O
&	O
dc	pointer
->	O
z_strm	pointer
)	O
)	O
==	O
0	int
)	O
{	O
dc	pointer
->	O
decompress	pointer
=	O
gzip_decompress	int
;	O
dc	pointer
->	O
exit	int
=	O
gzip_exit	int
;	O
}	O
}	O
else	O
if	O
(	O
encoding	pointer
==	O
wget_content_encoding_deflate	int
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
deflate_init	function
(	O
&	O
dc	pointer
->	O
z_strm	pointer
)	O
)	O
==	O
0	int
)	O
{	O
dc	pointer
->	O
decompress	pointer
=	O
gzip_decompress	int
;	O
dc	pointer
->	O
exit	int
=	O
gzip_exit	int
;	O
}	O
}	O
else	O
if	O
(	O
encoding	pointer
==	O
wget_content_encoding_bzip2	int
)	O
{	O
}	O
else	O
if	O
(	O
encoding	pointer
==	O
wget_content_encoding_lzma	int
)	O
{	O
}	O
else	O
if	O
(	O
encoding	pointer
==	O
wget_content_encoding_brotli	int
)	O
{	O
}	O
else	O
if	O
(	O
encoding	pointer
==	O
wget_content_encoding_zstd	int
)	O
{	O
}	O
if	O
(	O
!	O
dc	pointer
->	O
decompress	pointer
)	O
{	O
debug_printf	O
(	O
"Falling back to Content-Encoding 'identity'\n"	pointer
)	O
;	O
dc	pointer
->	O
decompress	int
=	O
identity	int
;	O
}	O
if	O
(	O
rc	int
)	O
{	O
xfree	function
(	O
dc	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
dc	pointer
->	O
encoding	pointer
=	O
encoding	pointer
;	O
dc	pointer
->	O
sink	pointer
=	O
sink	pointer
;	O
dc	pointer
->	O
context	pointer
=	O
context	pointer
;	O
return	O
dc	int
;	O
}	O
void	O
wget_decompress_close	function
(	O
wget_decompressor	struct
*	O
dc	pointer
)	O
{	O
if	O
(	O
dc	pointer
)	O
{	O
if	O
(	O
dc	pointer
->	O
exit	function
)	O
dc	pointer
->	O
exit	function
(	O
dc	int
)	O
;	O
xfree	function
(	O
dc	pointer
)	O
;	O
}	O
}	O
int	O
wget_decompress	function
(	O
wget_decompressor	struct
*	O
dc	pointer
,	O
char	O
*	O
src	pointer
,	O
size_t	long
srclen	long
)	O
{	O
if	O
(	O
dc	pointer
)	O
{	O
int	O
rc	int
=	O
dc	pointer
->	O
decompress	pointer
(	O
dc	pointer
,	O
src	pointer
,	O
srclen	long
)	O
;	O
if	O
(	O
rc	int
&&	O
dc	pointer
->	O
error_handler	pointer
)	O
dc	pointer
->	O
error_handler	function
(	O
dc	pointer
,	O
rc	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
wget_decompress_set_error_handler	function
(	O
wget_decompressor	struct
*	O
dc	pointer
,	O
wget_decompressor_error_handler	struct
*	O
error_handler	pointer
)	O
{	O
if	O
(	O
dc	pointer
)	O
dc	pointer
->	O
error_handler	pointer
=	O
error_handler	pointer
;	O
}	O
void	O
*	O
wget_decompress_get_context	function
(	O
wget_decompressor	struct
*	O
dc	pointer
)	O
{	O
return	O
dc	pointer
?	O
dc	pointer
->	O
context	pointer
:	O
NULL	O
;	O
}	O
static	O
char	O
_encoding_names	array
[	O
wget_content_encoding_max	int
]	O
[	O
9	int
]	O
=	O
{	O
[	O
wget_content_encoding_identity	int
]	O
=	O
"identity"	pointer
,	O
[	O
wget_content_encoding_gzip	int
]	O
=	O
"gzip"	pointer
,	O
[	O
wget_content_encoding_deflate	int
]	O
=	O
"deflate"	pointer
,	O
[	O
wget_content_encoding_xz	int
]	O
=	O
"xz"	pointer
,	O
[	O
wget_content_encoding_lzma	int
]	O
=	O
"lzma"	pointer
,	O
[	O
wget_content_encoding_bzip2	int
]	O
=	O
"bzip2"	pointer
,	O
[	O
wget_content_encoding_brotli	int
]	O
=	O
"br"	pointer
,	O
[	O
wget_content_encoding_zstd	int
]	O
=	O
"zstd"	pointer
,	O
}	O
;	O
wget_content_encoding	O
wget_content_encoding_by_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
name	pointer
)	O
{	O
for	O
(	O
wget_content_encoding	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_content_encoding_max	int
;	O
it	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
_encoding_names	pointer
[	O
it	int
]	O
,	O
name	pointer
)	O
)	O
return	O
it	int
;	O
}	O
if	O
(	O
!	O
strcmp	function
(	O
"none"	pointer
,	O
name	pointer
)	O
)	O
return	O
wget_content_encoding_identity	pointer
;	O
}	O
return	O
wget_content_encoding_unknown	pointer
;	O
}	O
const	O
char	O
*	O
wget_content_encoding_to_name	function
(	O
wget_content_encoding	enum
type	enum
)	O
{	O
if	O
(	O
type	enum
>=	O
0	int
&&	O
type	int
<	O
wget_content_encoding_max	int
)	O
return	O
_encoding_names	pointer
[	O
type	int
]	O
;	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
wget_strerror	function
(	O
wget_error	O
err	pointer
)	O
{	O
switch	O
(	O
err	enum
)	O
{	O
case	O
WGET_E_SUCCESS	int
:	O
return	O
_	O
(	O
"Success"	pointer
)	O
;	O
case	O
WGET_E_UNKNOWN	int
:	O
return	O
_	O
(	O
"General error"	pointer
)	O
;	O
case	O
WGET_E_MEMORY	int
:	O
return	O
_	O
(	O
"No memory"	pointer
)	O
;	O
case	O
WGET_E_INVALID	int
:	O
return	O
_	O
(	O
"Invalid value"	pointer
)	O
;	O
case	O
WGET_E_TIMEOUT	int
:	O
return	O
_	O
(	O
"Timeout"	pointer
)	O
;	O
case	O
WGET_E_CONNECT	int
:	O
return	O
_	O
(	O
"Connect error"	pointer
)	O
;	O
case	O
WGET_E_HANDSHAKE	int
:	O
return	O
_	O
(	O
"Handshake error"	pointer
)	O
;	O
case	O
WGET_E_CERTIFICATE	int
:	O
return	O
_	O
(	O
"Certificate error"	pointer
)	O
;	O
case	O
WGET_E_TLS_DISABLED	int
:	O
return	O
_	O
(	O
"Wget has been built without TLS support"	pointer
)	O
;	O
case	O
WGET_E_GPG_DISABLED	int
:	O
return	O
_	O
(	O
"Wget has been built without GPG support"	pointer
)	O
;	O
case	O
WGET_E_GPG_VER_FAIL	int
:	O
return	O
_	O
(	O
"GPG signature is bad"	pointer
)	O
;	O
case	O
WGET_E_GPG_VER_ERR	int
:	O
return	O
_	O
(	O
"GPG error"	pointer
)	O
;	O
case	O
WGET_E_XML_PARSE_ERR	int
:	O
return	O
_	O
(	O
"Failed to parse XML"	pointer
)	O
;	O
case	O
WGET_E_OPEN	int
:	O
return	O
_	O
(	O
"Failed to open file"	pointer
)	O
;	O
case	O
WGET_E_IO	int
:	O
return	O
_	O
(	O
"I/O error"	pointer
)	O
;	O
case	O
WGET_E_UNSUPPORTED	int
:	O
return	O
_	O
(	O
"Unsupported function"	pointer
)	O
;	O
default	O
:	O
return	O
_	O
(	O
"Unknown error"	pointer
)	O
;	O
}	O
}	O
static	O
wget_hashmap_hash_fn	function
hash_string	O
,	O
hash_string_nocase	int
;	O
__attribute__	O
(	O
(	O
no_sanitize	O
(	O
"integer"	pointer
)	O
)	O
)	O
WGET_GCC_PURE	O
static	O
unsigned	O
int	O
hash_string	function
(	O
const	O
void	O
*	O
key	pointer
)	O
{	O
const	O
char	O
*	O
k	pointer
=	O
key	pointer
;	O
unsigned	O
int	O
hash	int
=	O
0	int
;	O
while	O
(	O
*	O
k	int
)	O
hash	pointer
=	O
hash	pointer
*	O
101	int
+	O
(	O
unsigned	O
char	O
)	O
*	O
k	int
++	O
;	O
return	O
hash	pointer
;	O
}	O
__attribute__	O
(	O
(	O
no_sanitize	O
(	O
"integer"	pointer
)	O
)	O
)	O
WGET_GCC_PURE	O
static	O
unsigned	O
int	O
hash_string_nocase	function
(	O
const	O
void	O
*	O
key	pointer
)	O
{	O
const	O
char	O
*	O
k	pointer
=	O
key	pointer
;	O
unsigned	O
int	O
hash	int
=	O
0	int
;	O
while	O
(	O
*	O
k	int
)	O
hash	pointer
=	O
hash	pointer
*	O
101	int
+	O
(	O
unsigned	O
char	O
)	O
tolower	function
(	O
*	O
k	pointer
++	O
)	O
;	O
return	O
hash	pointer
;	O
}	O
wget_stringmap	struct
*	O
wget_stringmap_create	function
(	O
int	O
max	int
)	O
{	O
return	O
wget_hashmap_create	function
(	O
max	int
,	O
hash_string	pointer
,	O
(	O
wget_hashmap_compare_fn	function
*	O
)	O
wget_strcmp	int
)	O
;	O
}	O
wget_stringmap	struct
*	O
wget_stringmap_create_nocase	function
(	O
int	O
max	int
)	O
{	O
return	O
wget_hashmap_create	function
(	O
max	int
,	O
hash_string_nocase	pointer
,	O
(	O
wget_hashmap_compare_fn	function
*	O
)	O
wget_strcasecmp	int
)	O
;	O
}	O
ssize_t	long
wget_strscpy	function
(	O
char	O
*	O
dst	pointer
,	O
const	O
char	O
*	O
src	pointer
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
unlikely	O
(	O
!	O
dst	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
unlikely	O
(	O
!	O
src	pointer
)	O
)	O
{	O
if	O
(	O
size	int
)	O
{	O
*	O
dst	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
else	O
return	O
-	O
1	int
;	O
}	O
const	O
char	O
*	O
old	pointer
=	O
src	pointer
;	O
if	O
(	O
likely	O
(	O
size	pointer
)	O
)	O
{	O
while	O
(	O
--	O
size	int
)	O
{	O
if	O
(	O
!	O
(	O
*	O
dst	pointer
++	O
=	O
*	O
src	pointer
++	O
)	O
)	O
return	O
src	pointer
-	O
old	pointer
-	O
1	int
;	O
}	O
*	O
dst	pointer
=	O
0	int
;	O
return	O
src	pointer
-	O
old	pointer
;	O
}	O
return	O
-	O
1	int
;	O
}	O
struct	O
wget_thread_st	struct
{	O
gl_thread_t	O
tid	long
;	O
}	O
;	O
struct	O
wget_thread_mutex_st	struct
{	O
gl_lock_t	pointer
mutex	pointer
;	O
}	O
;	O
struct	O
wget_thread_cond_st	struct
{	O
gl_cond_t	struct
cond	struct
;	O
}	O
;	O
int	O
wget_thread_mutex_init	function
(	O
wget_thread_mutex	pointer
*	O
mutex	pointer
)	O
{	O
*	O
mutex	pointer
=	O
wget_malloc	function
(	O
sizeof	O
(	O
struct	O
wget_thread_mutex_st	struct
)	O
)	O
;	O
if	O
(	O
!	O
*	O
mutex	pointer
)	O
return	O
WGET_E_MEMORY	int
;	O
return	O
glthread_lock_init	function
(	O
&	O
(	O
(	O
*	O
mutex	pointer
)	O
->	O
mutex	pointer
)	O
)	O
;	O
}	O
int	O
wget_thread_mutex_destroy	function
(	O
wget_thread_mutex	pointer
*	O
mutex	pointer
)	O
{	O
int	O
rc	int
=	O
glthread_lock_destroy	function
(	O
&	O
(	O
*	O
mutex	pointer
)	O
->	O
mutex	pointer
)	O
;	O
xfree	function
(	O
*	O
mutex	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
wget_thread_mutex_lock	function
(	O
wget_thread_mutex	pointer
mutex	pointer
)	O
{	O
glthread_lock_lock	function
(	O
&	O
mutex	pointer
->	O
mutex	union
)	O
;	O
}	O
void	O
wget_thread_mutex_unlock	function
(	O
wget_thread_mutex	pointer
mutex	pointer
)	O
{	O
glthread_lock_unlock	function
(	O
&	O
mutex	pointer
->	O
mutex	union
)	O
;	O
}	O
int	O
wget_thread_cond_init	function
(	O
wget_thread_cond	pointer
*	O
cond	pointer
)	O
{	O
*	O
cond	pointer
=	O
wget_malloc	function
(	O
sizeof	O
(	O
struct	O
wget_thread_cond_st	struct
)	O
)	O
;	O
if	O
(	O
!	O
*	O
cond	pointer
)	O
return	O
WGET_E_MEMORY	int
;	O
return	O
glthread_cond_init	function
(	O
&	O
(	O
(	O
*	O
cond	pointer
)	O
->	O
cond	union
)	O
)	O
;	O
}	O
int	O
wget_thread_cond_destroy	function
(	O
wget_thread_cond	pointer
*	O
cond	pointer
)	O
{	O
int	O
rc	int
=	O
glthread_cond_destroy	function
(	O
&	O
(	O
*	O
cond	pointer
)	O
->	O
cond	union
)	O
;	O
xfree	function
(	O
*	O
cond	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
wget_thread_cond_signal	function
(	O
wget_thread_cond	struct
cond	pointer
)	O
{	O
return	O
glthread_cond_broadcast	function
(	O
&	O
cond	pointer
->	O
cond	union
)	O
;	O
}	O
int	O
wget_thread_cond_wait	function
(	O
wget_thread_cond	pointer
cond	pointer
,	O
wget_thread_mutex	pointer
mutex	pointer
,	O
long	O
long	O
ms	long
)	O
{	O
if	O
(	O
ms	int
<=	O
0	int
)	O
return	O
glthread_cond_wait	function
(	O
&	O
cond	pointer
->	O
cond	union
,	O
&	O
mutex	pointer
->	O
mutex	union
)	O
;	O
struct	O
timespec	struct
ts	struct
;	O
gettime	function
(	O
&	O
ts	pointer
)	O
;	O
ms	int
+=	O
ts	struct
.	O
tv_sec	long
*	O
1000LL	int
+	O
ts	struct
.	O
tv_nsec	long
/	O
1000000	int
;	O
ts	struct
.	O
tv_sec	long
=	O
ms	long
/	O
1000	int
;	O
ts	struct
.	O
tv_nsec	long
=	O
(	O
ms	int
%	O
1000	int
)	O
*	O
1000000	int
;	O
return	O
glthread_cond_timedwait	function
(	O
&	O
cond	pointer
->	O
cond	union
,	O
&	O
mutex	pointer
->	O
mutex	union
,	O
&	O
ts	char
)	O
;	O
}	O
int	O
wget_thread_start	function
(	O
wget_thread	pointer
*	O
thread	pointer
,	O
void	O
*	O
(	O
*	O
start_routine	pointer
)	O
(	O
void	O
*	O
)	O
,	O
void	O
*	O
arg	pointer
,	O
WGET_GCC_UNUSED	O
int	O
flags	int
)	O
{	O
if	O
(	O
wget_thread_support	function
(	O
)	O
)	O
{	O
*	O
thread	pointer
=	O
wget_malloc	function
(	O
sizeof	O
(	O
struct	O
wget_thread_st	struct
)	O
)	O
;	O
if	O
(	O
!	O
*	O
thread	pointer
)	O
return	O
WGET_E_MEMORY	int
;	O
return	O
glthread_create	function
(	O
&	O
(	O
(	O
*	O
thread	pointer
)	O
->	O
tid	long
)	O
,	O
start_routine	pointer
,	O
arg	pointer
)	O
;	O
}	O
*	O
thread	pointer
=	O
NULL	O
;	O
start_routine	function
(	O
arg	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
wget_thread_cancel	function
(	O
WGET_GCC_UNUSED	O
wget_thread	pointer
thread	pointer
)	O
{	O
return	O
0	int
;	O
}	O
int	O
wget_thread_kill	function
(	O
WGET_GCC_UNUSED	O
wget_thread	pointer
thread	pointer
,	O
WGET_GCC_UNUSED	O
int	O
sig	int
)	O
{	O
return	O
0	int
;	O
}	O
int	O
wget_thread_join	function
(	O
wget_thread	pointer
*	O
thread	pointer
)	O
{	O
if	O
(	O
thread	long
&&	O
*	O
thread	pointer
&&	O
(	O
*	O
thread	pointer
)	O
->	O
tid	long
)	O
{	O
int	O
rc	int
=	O
glthread_join	function
(	O
(	O
*	O
thread	pointer
)	O
->	O
tid	long
,	O
NULL	O
)	O
;	O
xfree	function
(	O
*	O
thread	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
wget_thread_support	function
(	O
)	O
)	O
{	O
errno	O
=	O
ESRCH	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
wget_thread_id	O
wget_thread_self	function
(	O
void	O
)	O
{	O
return	O
gl_thread_self	function
(	O
)	O
;	O
}	O
bool	bool
wget_thread_support	function
(	O
void	O
)	O
{	O
return	O
true	int
;	O
}	O
int	O
fd_safer_flag	function
(	O
int	O
fd	array
,	O
int	O
flag	int
)	O
{	O
if	O
(	O
STDIN_FILENO	int
<=	O
fd	array
&&	O
fd	array
<=	O
STDERR_FILENO	int
)	O
{	O
int	O
f	int
=	O
dup_safer_flag	function
(	O
fd	array
,	O
flag	int
)	O
;	O
int	O
e	int
=	O
errno	O
;	O
close	function
(	O
fd	array
)	O
;	O
errno	O
=	O
e	int
;	O
fd	array
=	O
f	int
;	O
}	O
return	O
fd	array
;	O
}	O
int	O
fpurge	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
__fpurge	function
(	O
fp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
fseeko	function
(	O
FILE	struct
*	O
fp	pointer
,	O
off_t	long
offset	long
,	O
int	O
whence	int
)	O
{	O
if	O
(	O
fp	pointer
->	O
_IO_read_end	pointer
==	O
fp	pointer
->	O
_IO_read_ptr	pointer
&&	O
fp	pointer
->	O
_IO_write_ptr	pointer
==	O
fp	pointer
->	O
_IO_write_base	pointer
&&	O
fp	pointer
->	O
_IO_save_base	pointer
==	O
NULL	O
)	O
{	O
off_t	long
pos	long
=	O
lseek	function
(	O
fileno	function
(	O
fp	pointer
)	O
,	O
offset	long
,	O
whence	int
)	O
;	O
if	O
(	O
pos	long
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
fp	pointer
->	O
_flags	int
&=	O
~	O
_IO_EOF_SEEN	int
;	O
fp	pointer
->	O
_offset	long
=	O
pos	long
;	O
return	O
0	int
;	O
}	O
return	O
fseeko	function
(	O
fp	pointer
,	O
offset	long
,	O
whence	int
)	O
;	O
}	O
char	O
const	O
*	O
getprogname	function
(	O
void	O
)	O
{	O
return	O
program_invocation_short_name	pointer
;	O
}	O
size_t	long
strnlen1	function
(	O
const	O
char	O
*	O
string	pointer
,	O
size_t	long
maxlen	long
)	O
{	O
const	O
char	O
*	O
end	pointer
=	O
(	O
const	O
char	O
*	O
)	O
memchr	function
(	O
string	pointer
,	O
'\0'	O
,	O
maxlen	long
)	O
;	O
if	O
(	O
end	pointer
!=	O
NULL	O
)	O
return	O
end	pointer
-	O
string	pointer
+	O
1	int
;	O
else	O
return	O
maxlen	long
;	O
}	O
enum	O
{	O
STATS_METHOD_GET	int
=	O
1	int
,	O
STATS_METHOD_HEAD	int
=	O
2	int
,	O
STATS_METHOD_POST	int
=	O
3	int
,	O
}	O
;	O
typedef	O
struct	O
{	O
wget_iri	struct
*	O
iri	pointer
;	O
long	O
long	O
size_downloaded	long
,	O
size_decompressed	int
;	O
long	O
long	O
request_start	long
;	O
long	O
long	O
response_end	long
;	O
long	O
long	O
initial_response_duration	long
;	O
unsigned	O
long	O
long	O
id	long
,	O
parent_id	int
;	O
int	O
status	int
,	O
signature_status	int
;	O
char	O
encoding	pointer
,	O
method	int
;	O
const	O
char	O
*	O
mime_type	pointer
;	O
bool	bool
redirect	bool
:	O
1	int
;	O
time_t	long
last_modified	long
;	O
}	O
site_stats_t	struct
;	O
static	O
wget_vector	struct
*	O
data	pointer
;	O
static	O
wget_thread_mutex	pointer
mutex	pointer
;	O
static	O
wget_hashmap	struct
*	O
docs	pointer
;	O
static	O
FILE	struct
*	O
fp	pointer
;	O
static	O
void	O
free_stats	function
(	O
void	O
*	O
stats	pointer
)	O
{	O
site_stats_t	struct
*	O
s	pointer
=	O
stats	pointer
;	O
if	O
(	O
s	pointer
)	O
{	O
xfree	function
(	O
s	pointer
->	O
mime_type	pointer
)	O
;	O
xfree	function
(	O
s	pointer
)	O
;	O
}	O
}	O
void	O
site_stats_init	function
(	O
FILE	struct
*	O
fpout	pointer
)	O
{	O
wget_thread_mutex_init	function
(	O
&	O
mutex	pointer
)	O
;	O
data	pointer
=	O
wget_vector_create	function
(	O
8	int
,	O
NULL	O
)	O
;	O
wget_vector_set_destructor	function
(	O
data	pointer
,	O
free_stats	pointer
)	O
;	O
fp	pointer
=	O
fpout	pointer
;	O
}	O
void	O
site_stats_exit	function
(	O
void	O
)	O
{	O
wget_stringmap_free	function
(	O
&	O
docs	struct
)	O
;	O
wget_vector_free	function
(	O
&	O
data	pointer
)	O
;	O
wget_thread_mutex_destroy	function
(	O
&	O
mutex	pointer
)	O
;	O
}	O
void	O
stats_site_add	function
(	O
wget_http_response	struct
*	O
resp	pointer
,	O
wget_gpg_info_t	struct
*	O
gpg_info	pointer
)	O
{	O
JOB	struct
*	O
job	pointer
=	O
resp	pointer
->	O
req	pointer
->	O
user_data	pointer
;	O
wget_iri	struct
*	O
iri	pointer
=	O
job	pointer
->	O
iri	pointer
;	O
if	O
(	O
gpg_info	pointer
)	O
{	O
wget_thread_mutex_lock	function
(	O
mutex	pointer
)	O
;	O
if	O
(	O
!	O
docs	pointer
)	O
{	O
docs	pointer
=	O
wget_stringmap_create	function
(	O
128	int
)	O
;	O
wget_stringmap_set_key_destructor	function
(	O
docs	pointer
,	O
NULL	O
)	O
;	O
wget_stringmap_set_value_destructor	function
(	O
docs	pointer
,	O
NULL	O
)	O
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
data	pointer
)	O
;	O
it	int
++	O
)	O
{	O
site_stats_t	struct
*	O
e	pointer
=	O
wget_vector_get	function
(	O
data	pointer
,	O
it	int
)	O
;	O
wget_stringmap_put	function
(	O
docs	pointer
,	O
e	pointer
->	O
iri	pointer
->	O
uri	pointer
,	O
e	int
)	O
;	O
}	O
}	O
char	O
*	O
p	pointer
,	O
*	O
uri	pointer
=	O
wget_strdup	function
(	O
iri	pointer
->	O
uri	pointer
)	O
;	O
if	O
(	O
(	O
p	pointer
=	O
strrchr	function
(	O
uri	pointer
,	O
'.'	O
)	O
)	O
)	O
*	O
p	pointer
=	O
0	int
;	O
site_stats_t	struct
*	O
doc	pointer
;	O
wget_stringmap_get	function
(	O
docs	pointer
,	O
uri	pointer
,	O
&	O
doc	pointer
)	O
;	O
xfree	function
(	O
uri	pointer
)	O
;	O
if	O
(	O
doc	pointer
)	O
{	O
if	O
(	O
gpg_info	pointer
->	O
valid_sigs	pointer
)	O
doc	pointer
->	O
signature_status	int
=	O
1	int
;	O
else	O
if	O
(	O
gpg_info	pointer
->	O
invalid_sigs	int
)	O
doc	pointer
->	O
signature_status	int
=	O
2	int
;	O
else	O
if	O
(	O
gpg_info	pointer
->	O
bad_sigs	pointer
)	O
doc	pointer
->	O
signature_status	int
=	O
3	int
;	O
else	O
if	O
(	O
gpg_info	pointer
->	O
missing_sigs	pointer
)	O
doc	pointer
->	O
signature_status	int
=	O
4	int
;	O
wget_thread_mutex_unlock	function
(	O
mutex	pointer
)	O
;	O
return	O
;	O
}	O
wget_thread_mutex_unlock	function
(	O
mutex	pointer
)	O
;	O
}	O
site_stats_t	struct
*	O
doc	pointer
=	O
wget_calloc	function
(	O
1	int
,	O
sizeof	O
(	O
site_stats_t	pointer
)	O
)	O
;	O
doc	pointer
->	O
id	int
=	O
job	pointer
->	O
id	int
;	O
doc	pointer
->	O
parent_id	int
=	O
job	pointer
->	O
parent_id	pointer
;	O
doc	pointer
->	O
iri	pointer
=	O
iri	pointer
;	O
doc	pointer
->	O
status	int
=	O
resp	pointer
->	O
code	int
;	O
doc	pointer
->	O
encoding	pointer
=	O
resp	pointer
->	O
content_encoding	pointer
;	O
doc	pointer
->	O
redirect	int
=	O
!	O
!	O
job	pointer
->	O
redirection_level	pointer
;	O
doc	pointer
->	O
mime_type	pointer
=	O
wget_strdup	function
(	O
resp	pointer
->	O
content_type	pointer
)	O
;	O
doc	pointer
->	O
last_modified	pointer
=	O
resp	pointer
->	O
last_modified	pointer
;	O
doc	pointer
->	O
request_start	pointer
=	O
resp	pointer
->	O
req	pointer
->	O
request_start	pointer
;	O
doc	pointer
->	O
response_end	pointer
=	O
resp	pointer
->	O
response_end	pointer
;	O
doc	pointer
->	O
initial_response_duration	pointer
=	O
resp	pointer
->	O
req	pointer
->	O
first_response_start	pointer
-	O
resp	pointer
->	O
req	pointer
->	O
request_start	pointer
;	O
doc	pointer
->	O
size_downloaded	pointer
=	O
resp	pointer
->	O
cur_downloaded	pointer
;	O
doc	pointer
->	O
size_decompressed	pointer
=	O
resp	pointer
->	O
body	pointer
->	O
length	long
;	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
req	pointer
->	O
method	pointer
,	O
"GET"	pointer
)	O
)	O
{	O
doc	pointer
->	O
method	pointer
=	O
STATS_METHOD_GET	pointer
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
req	pointer
->	O
method	pointer
,	O
"HEAD"	pointer
)	O
)	O
{	O
doc	pointer
->	O
size_downloaded	pointer
=	O
resp	pointer
->	O
content_length	pointer
;	O
doc	pointer
->	O
method	pointer
=	O
STATS_METHOD_HEAD	pointer
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
req	pointer
->	O
method	pointer
,	O
"POST"	pointer
)	O
)	O
{	O
doc	pointer
->	O
method	pointer
=	O
STATS_METHOD_POST	pointer
;	O
}	O
wget_thread_mutex_lock	function
(	O
mutex	pointer
)	O
;	O
wget_vector_add	function
(	O
data	pointer
,	O
doc	pointer
)	O
;	O
if	O
(	O
docs	pointer
)	O
wget_stringmap_put	function
(	O
docs	pointer
,	O
doc	pointer
->	O
iri	pointer
->	O
uri	pointer
,	O
doc	pointer
)	O
;	O
wget_thread_mutex_unlock	function
(	O
mutex	pointer
)	O
;	O
}	O
static	O
int	O
print_human_entry	function
(	O
FILE	struct
*	O
_fp	pointer
,	O
site_stats_t	struct
*	O
doc	pointer
)	O
{	O
long	O
long	O
transfer_time	long
=	O
doc	pointer
->	O
response_end	long
-	O
doc	pointer
->	O
request_start	long
;	O
wget_fprintf	function
(	O
_fp	pointer
,	O
"  %6d %5lld %6lld %s\n"	pointer
,	O
doc	pointer
->	O
status	int
,	O
transfer_time	pointer
,	O
doc	pointer
->	O
size_downloaded	pointer
,	O
doc	pointer
->	O
iri	pointer
->	O
uri	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
print_csv_entry	function
(	O
FILE	struct
*	O
_fp	pointer
,	O
site_stats_t	struct
*	O
doc	pointer
)	O
{	O
long	O
long	O
transfer_time	long
=	O
doc	pointer
->	O
response_end	long
-	O
doc	pointer
->	O
request_start	long
;	O
wget_fprintf	function
(	O
_fp	pointer
,	O
"%llu,%llu,%s,%d,%d,%d,%lld,%lld,%lld,%lld,%d,%d,%ld,%s\n"	pointer
,	O
doc	pointer
->	O
id	int
,	O
doc	pointer
->	O
parent_id	pointer
,	O
doc	pointer
->	O
iri	pointer
->	O
uri	pointer
,	O
doc	pointer
->	O
status	int
,	O
!	O
doc	pointer
->	O
redirect	pointer
,	O
doc	pointer
->	O
method	int
,	O
doc	pointer
->	O
size_downloaded	pointer
,	O
doc	pointer
->	O
size_decompressed	pointer
,	O
transfer_time	pointer
,	O
doc	pointer
->	O
initial_response_duration	pointer
,	O
doc	pointer
->	O
encoding	pointer
,	O
doc	pointer
->	O
signature_status	pointer
,	O
doc	pointer
->	O
last_modified	pointer
,	O
doc	pointer
->	O
mime_type	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
print_human	function
(	O
void	O
)	O
{	O
wget_fprintf	function
(	O
fp	pointer
,	O
"\nSite Statistics:\n"	pointer
)	O
;	O
wget_fprintf	function
(	O
fp	pointer
,	O
"  %6s %5s %6s %s\n"	pointer
,	O
"Status"	pointer
,	O
"ms"	pointer
,	O
"Size"	pointer
,	O
"URL"	pointer
)	O
;	O
wget_vector_browse	function
(	O
data	pointer
,	O
(	O
wget_vector_browse_fn	struct
*	O
)	O
print_human_entry	pointer
,	O
fp	pointer
)	O
;	O
}	O
static	O
void	O
print_csv	function
(	O
void	O
)	O
{	O
wget_fprintf	function
(	O
fp	pointer
,	O
"ID,ParentID,URL,Status,Link,Method,Size,SizeDecompressed,TransferTime,ResponseTime,Encoding,Verification,Last-Modified,Content-Type\n"	pointer
)	O
;	O
wget_vector_browse	function
(	O
data	pointer
,	O
(	O
wget_vector_browse_fn	struct
*	O
)	O
print_csv_entry	pointer
,	O
fp	pointer
)	O
;	O
}	O
void	O
site_stats_print	function
(	O
void	O
)	O
{	O
if	O
(	O
config	struct
.	O
stats_site_args	pointer
->	O
format	pointer
==	O
WGET_STATS_FORMAT_HUMAN	int
)	O
print_human	function
(	O
)	O
;	O
else	O
print_csv	function
(	O
)	O
;	O
}	O
static	O
bool	bool
testing	bool
;	O
void	O
enable_testing	function
(	O
void	O
)	O
{	O
testing	bool
=	O
true	int
;	O
}	O
bool	bool
is_testing	function
(	O
void	O
)	O
{	O
return	O
testing	pointer
;	O
}	O
static	O
long	O
int	O
state	pointer
;	O
void	O
XaoS_srandom	function
(	O
unsigned	O
int	O
x	int
)	O
{	O
state	pointer
=	O
x	double
;	O
}	O
long	O
int	O
XaoS_random	function
(	O
void	O
)	O
{	O
state	pointer
=	O
(	O
(	O
state	pointer
*	O
1103515245	int
)	O
+	O
12345	int
)	O
&	O
MYLONG_MAX	int
;	O
return	O
state	pointer
;	O
}	O
uLong	long
ZEXPORT	O
adler32	function
(	O
adler	long
,	O
buf	pointer
,	O
len	int
)	O
uLong	long
adler	long
;	O
const	O
Bytef	char
*	O
buf	pointer
;	O
uInt	int
len	int
;	O
{	O
unsigned	O
long	O
s1	long
=	O
adler	long
&	O
0xffff	int
;	O
unsigned	O
long	O
s2	long
=	O
(	O
adler	long
>>	O
16	int
)	O
&	O
0xffff	int
;	O
int	O
k	int
;	O
if	O
(	O
buf	pointer
==	O
Z_NULL	int
)	O
return	O
1L	int
;	O
while	O
(	O
len	int
>	O
0	int
)	O
{	O
k	int
=	O
len	int
<	O
NMAX	int
?	O
len	int
:	O
NMAX	int
;	O
len	int
-=	O
k	int
;	O
while	O
(	O
k	int
>=	O
16	int
)	O
{	O
DO16	O
(	O
buf	pointer
)	O
;	O
buf	pointer
+=	O
16	int
;	O
k	int
-=	O
16	int
;	O
}	O
if	O
(	O
k	int
!=	O
0	int
)	O
do	O
{	O
s1	long
+=	O
*	O
buf	pointer
++	O
;	O
s2	pointer
+=	O
s1	pointer
;	O
}	O
while	O
(	O
--	O
k	long
)	O
;	O
s1	pointer
%=	O
BASE	int
;	O
s2	pointer
%=	O
BASE	int
;	O
}	O
return	O
(	O
s2	double
<<	O
16	int
)	O
|	O
s1	pointer
;	O
}	O