static	O
const	O
char	O
*	O
next_brace_sub	function
(	O
const	O
char	O
*	O
begin	pointer
,	O
int	O
flags	int
)	O
__THROW	O
;	O
static	O
int	O
glob_in_dir	function
(	O
const	O
char	O
*	O
pattern	pointer
,	O
const	O
char	O
*	O
directory	pointer
,	O
int	O
flags	int
,	O
int	O
(	O
*	O
errfunc	pointer
)	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
,	O
glob_t	struct
*	O
pglob	pointer
)	O
;	O
extern	O
int	O
__glob_pattern_type	function
(	O
const	O
char	O
*	O
pattern	pointer
,	O
int	O
quote	int
)	O
attribute_hidden	O
;	O
static	O
int	O
prefix_array	function
(	O
const	O
char	O
*	O
prefix	pointer
,	O
char	O
*	O
*	O
array	pointer
,	O
size_t	long
n	long
)	O
__THROW	O
;	O
static	O
int	O
collated_compare	function
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
__THROW	O
;	O
static	O
const	O
char	O
*	O
next_brace_sub	function
(	O
const	O
char	O
*	O
cp	pointer
,	O
int	O
flags	int
)	O
{	O
unsigned	O
int	O
depth	int
=	O
0	int
;	O
while	O
(	O
*	O
cp	pointer
!=	O
'\0'	O
)	O
if	O
(	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
==	O
0	int
&&	O
*	O
cp	pointer
==	O
'\\'	O
)	O
{	O
if	O
(	O
*	O
++	O
cp	pointer
==	O
'\0'	O
)	O
break	O
;	O
++	O
cp	pointer
;	O
}	O
else	O
{	O
if	O
(	O
(	O
*	O
cp	pointer
==	O
'}'	O
&&	O
depth	int
--	O
==	O
0	int
)	O
||	O
(	O
*	O
cp	pointer
==	O
','	O
&&	O
depth	int
==	O
0	int
)	O
)	O
break	O
;	O
if	O
(	O
*	O
cp	pointer
++	O
==	O
'{'	O
)	O
depth	int
++	O
;	O
}	O
return	O
*	O
cp	pointer
!=	O
'\0'	O
?	O
cp	pointer
:	O
NULL	O
;	O
}	O
int	O
glob	O
(	O
pattern	pointer
,	O
flags	int
,	O
errfunc	pointer
,	O
pglob	pointer
)	O
const	O
char	O
*	O
restrict	O
pattern	pointer
;	O
int	O
flags	int
;	O
int	O
(	O
*	O
errfunc	pointer
)	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
glob_t	struct
*	O
restrict	O
pglob	pointer
;	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
const	O
char	O
*	O
dirname	pointer
;	O
size_t	long
dirlen	long
;	O
int	O
status	int
;	O
size_t	long
oldcount	long
;	O
int	O
meta	int
;	O
int	O
dirname_modified	int
;	O
glob_t	struct
dirs	struct
;	O
if	O
(	O
pattern	pointer
==	O
NULL	O
||	O
pglob	pointer
==	O
NULL	O
||	O
(	O
flags	int
&	O
~	O
__GLOB_FLAGS	O
)	O
!=	O
0	int
)	O
{	O
__set_errno	O
(	O
EINVAL	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_DOOFFS	O
)	O
)	O
pglob	pointer
->	O
gl_offs	long
=	O
0	int
;	O
if	O
(	O
flags	int
&	O
GLOB_BRACE	O
)	O
{	O
const	O
char	O
*	O
begin	pointer
;	O
if	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
begin	pointer
=	O
strchr	function
(	O
pattern	pointer
,	O
'{'	O
)	O
;	O
else	O
{	O
begin	pointer
=	O
pattern	pointer
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
*	O
begin	pointer
==	O
'\0'	O
)	O
{	O
begin	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
begin	pointer
==	O
'\\'	O
&&	O
begin	pointer
[	O
1	int
]	O
!=	O
'\0'	O
)	O
++	O
begin	pointer
;	O
else	O
if	O
(	O
*	O
begin	pointer
==	O
'{'	O
)	O
break	O
;	O
++	O
begin	pointer
;	O
}	O
}	O
if	O
(	O
begin	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
firstc	long
;	O
char	O
*	O
alt_start	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
const	O
char	O
*	O
next	pointer
;	O
const	O
char	O
*	O
rest	pointer
;	O
size_t	long
rest_len	long
;	O
char	O
onealt	O
[	O
strlen	function
(	O
pattern	pointer
)	O
-	O
1	int
]	O
;	O
alt_start	pointer
=	O
mempcpy	function
(	O
onealt	O
,	O
pattern	pointer
,	O
begin	pointer
-	O
pattern	pointer
)	O
;	O
next	pointer
=	O
next_brace_sub	function
(	O
begin	pointer
+	O
1	int
,	O
flags	int
)	O
;	O
if	O
(	O
next	pointer
==	O
NULL	O
)	O
{	O
return	O
glob	O
(	O
pattern	pointer
,	O
flags	int
&	O
~	O
GLOB_BRACE	O
,	O
errfunc	pointer
,	O
pglob	pointer
)	O
;	O
}	O
rest	pointer
=	O
next	pointer
;	O
while	O
(	O
*	O
rest	pointer
!=	O
'}'	O
)	O
{	O
rest	pointer
=	O
next_brace_sub	function
(	O
rest	pointer
+	O
1	int
,	O
flags	int
)	O
;	O
if	O
(	O
rest	pointer
==	O
NULL	O
)	O
{	O
return	O
glob	O
(	O
pattern	pointer
,	O
flags	int
&	O
~	O
GLOB_BRACE	O
,	O
errfunc	pointer
,	O
pglob	pointer
)	O
;	O
}	O
}	O
rest_len	long
=	O
strlen	function
(	O
++	O
rest	pointer
)	O
+	O
1	int
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_APPEND	O
)	O
)	O
{	O
pglob	pointer
->	O
gl_pathc	long
=	O
0	int
;	O
pglob	pointer
->	O
gl_pathv	pointer
=	O
NULL	O
;	O
}	O
firstc	long
=	O
pglob	pointer
->	O
gl_pathc	long
;	O
p	pointer
=	O
begin	pointer
+	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
result	int
;	O
mempcpy	function
(	O
mempcpy	function
(	O
alt_start	pointer
,	O
p	pointer
,	O
next	pointer
-	O
p	pointer
)	O
,	O
rest	pointer
,	O
rest_len	long
)	O
;	O
result	int
=	O
glob	O
(	O
onealt	O
,	O
(	O
(	O
flags	int
&	O
~	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
)	O
|	O
GLOB_APPEND	O
)	O
,	O
errfunc	pointer
,	O
pglob	pointer
)	O
;	O
if	O
(	O
result	int
&&	O
result	int
!=	O
GLOB_NOMATCH	int
)	O
{	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_APPEND	O
)	O
)	O
{	O
globfree	O
(	O
pglob	pointer
)	O
;	O
pglob	pointer
->	O
gl_pathc	long
=	O
0	int
;	O
}	O
return	O
result	int
;	O
}	O
if	O
(	O
*	O
next	pointer
==	O
'}'	O
)	O
break	O
;	O
p	pointer
=	O
next	pointer
+	O
1	int
;	O
next	pointer
=	O
next_brace_sub	function
(	O
p	pointer
,	O
flags	int
)	O
;	O
assert	O
(	O
next	pointer
!=	O
NULL	O
)	O
;	O
}	O
if	O
(	O
pglob	pointer
->	O
gl_pathc	long
!=	O
firstc	long
)	O
return	O
0	int
;	O
else	O
if	O
(	O
!	O
(	O
flags	int
&	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
)	O
)	O
return	O
GLOB_NOMATCH	int
;	O
}	O
}	O
filename	pointer
=	O
strrchr	function
(	O
pattern	pointer
,	O
'/'	O
)	O
;	O
dirname_modified	int
=	O
0	int
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
(	O
GLOB_TILDE	O
|	O
GLOB_TILDE_CHECK	O
)	O
)	O
&&	O
pattern	pointer
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
dirname	pointer
=	O
pattern	pointer
;	O
dirlen	long
=	O
strlen	function
(	O
pattern	pointer
)	O
;	O
filename	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
filename	pointer
=	O
pattern	pointer
;	O
dirname	pointer
=	O
"."	pointer
;	O
dirlen	long
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
filename	pointer
==	O
pattern	pointer
||	O
(	O
filename	pointer
==	O
pattern	pointer
+	O
1	int
&&	O
pattern	pointer
[	O
0	int
]	O
==	O
'\\'	O
&&	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
==	O
0	int
)	O
)	O
{	O
dirname	pointer
=	O
"/"	pointer
;	O
dirlen	long
=	O
1	int
;	O
++	O
filename	pointer
;	O
}	O
else	O
{	O
char	O
*	O
newp	pointer
;	O
dirlen	long
=	O
filename	pointer
-	O
pattern	pointer
;	O
newp	pointer
=	O
__alloca	O
(	O
dirlen	long
+	O
1	int
)	O
;	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	function
(	O
newp	pointer
,	O
pattern	pointer
,	O
dirlen	long
)	O
)	O
=	O
'\0'	O
;	O
dirname	pointer
=	O
newp	pointer
;	O
++	O
filename	pointer
;	O
if	O
(	O
filename	pointer
[	O
0	int
]	O
==	O
'\0'	O
&&	O
dirlen	long
>	O
1	int
)	O
{	O
int	O
orig_flags	int
=	O
flags	int
;	O
int	O
val	array
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
&&	O
dirname	pointer
[	O
dirlen	long
-	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
char	O
*	O
p	pointer
=	O
(	O
char	O
*	O
)	O
&	O
dirname	pointer
[	O
dirlen	long
-	O
1	int
]	O
;	O
while	O
(	O
p	pointer
>	O
dirname	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
'\\'	O
)	O
--	O
p	pointer
;	O
if	O
(	O
(	O
&	O
dirname	pointer
[	O
dirlen	long
]	O
-	O
p	pointer
)	O
&	O
1	int
)	O
{	O
*	O
(	O
char	O
*	O
)	O
&	O
dirname	pointer
[	O
--	O
dirlen	long
]	O
=	O
'\0'	O
;	O
flags	int
&=	O
~	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
;	O
}	O
}	O
val	array
=	O
glob	O
(	O
dirname	pointer
,	O
flags	int
|	O
GLOB_MARK	O
,	O
errfunc	pointer
,	O
pglob	pointer
)	O
;	O
if	O
(	O
val	array
==	O
0	int
)	O
pglob	pointer
->	O
gl_flags	int
=	O
(	O
(	O
pglob	pointer
->	O
gl_flags	int
&	O
~	O
GLOB_MARK	O
)	O
|	O
(	O
flags	int
&	O
GLOB_MARK	O
)	O
)	O
;	O
else	O
if	O
(	O
val	array
==	O
GLOB_NOMATCH	int
&&	O
flags	int
!=	O
orig_flags	int
)	O
{	O
dirs	struct
.	O
gl_pathv	pointer
=	O
NULL	O
;	O
flags	int
=	O
orig_flags	int
;	O
oldcount	long
=	O
pglob	pointer
->	O
gl_pathc	long
+	O
pglob	pointer
->	O
gl_offs	long
;	O
goto	O
no_matches	O
;	O
}	O
return	O
val	array
;	O
}	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_APPEND	O
)	O
)	O
{	O
pglob	pointer
->	O
gl_pathc	long
=	O
0	int
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_DOOFFS	O
)	O
)	O
pglob	pointer
->	O
gl_pathv	pointer
=	O
NULL	O
;	O
else	O
{	O
size_t	long
i	long
;	O
pglob	pointer
->	O
gl_pathv	pointer
=	O
malloc	function
(	O
(	O
pglob	pointer
->	O
gl_offs	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
pglob	pointer
->	O
gl_pathv	pointer
==	O
NULL	O
)	O
return	O
GLOB_NOSPACE	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
pglob	pointer
->	O
gl_offs	long
;	O
++	O
i	long
)	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
i	long
]	O
=	O
NULL	O
;	O
}	O
}	O
oldcount	long
=	O
pglob	pointer
->	O
gl_pathc	long
+	O
pglob	pointer
->	O
gl_offs	long
;	O
if	O
(	O
(	O
flags	int
&	O
(	O
GLOB_TILDE	O
|	O
GLOB_TILDE_CHECK	O
)	O
)	O
&&	O
dirname	pointer
[	O
0	int
]	O
==	O
'~'	O
)	O
{	O
if	O
(	O
dirname	pointer
[	O
1	int
]	O
==	O
'\0'	O
||	O
dirname	pointer
[	O
1	int
]	O
==	O
'/'	O
||	O
(	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
&&	O
dirname	pointer
[	O
1	int
]	O
==	O
'\\'	O
&&	O
(	O
dirname	pointer
[	O
2	int
]	O
==	O
'\0'	O
||	O
dirname	pointer
[	O
2	int
]	O
==	O
'/'	O
)	O
)	O
)	O
{	O
const	O
char	O
*	O
home_dir	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
home_dir	pointer
==	O
NULL	O
||	O
home_dir	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
int	O
success	int
;	O
char	O
*	O
name	pointer
;	O
size_t	long
buflen	long
=	O
GET_LOGIN_NAME_MAX	O
(	O
)	O
+	O
1	int
;	O
if	O
(	O
buflen	long
==	O
0	int
)	O
buflen	long
=	O
20	int
;	O
name	pointer
=	O
__alloca	O
(	O
buflen	long
)	O
;	O
success	int
=	O
getlogin_r	function
(	O
name	pointer
,	O
buflen	long
)	O
==	O
0	int
;	O
if	O
(	O
success	int
)	O
{	O
struct	O
passwd	struct
*	O
p	pointer
;	O
long	O
int	O
pwbuflen	long
=	O
GETPW_R_SIZE_MAX	O
(	O
)	O
;	O
char	O
*	O
pwtmpbuf	pointer
;	O
struct	O
passwd	struct
pwbuf	struct
;	O
int	O
save	int
=	O
errno	O
;	O
if	O
(	O
pwbuflen	long
==	O
-	O
1	int
)	O
pwbuflen	long
=	O
1024	int
;	O
pwtmpbuf	pointer
=	O
__alloca	O
(	O
pwbuflen	long
)	O
;	O
while	O
(	O
getpwnam_r	function
(	O
name	pointer
,	O
&	O
pwbuf	struct
,	O
pwtmpbuf	pointer
,	O
pwbuflen	long
,	O
&	O
p	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
ERANGE	int
)	O
{	O
p	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
pwbuflen	long
*=	O
2	int
;	O
pwtmpbuf	pointer
=	O
__alloca	O
(	O
pwbuflen	long
)	O
;	O
__set_errno	O
(	O
save	int
)	O
;	O
}	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
home_dir	pointer
=	O
p	pointer
->	O
pw_dir	pointer
;	O
}	O
}	O
if	O
(	O
home_dir	pointer
==	O
NULL	O
||	O
home_dir	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
flags	int
&	O
GLOB_TILDE_CHECK	O
)	O
return	O
GLOB_NOMATCH	int
;	O
else	O
home_dir	pointer
=	O
"~"	pointer
;	O
}	O
if	O
(	O
dirname	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
dirname	pointer
=	O
home_dir	pointer
;	O
dirlen	long
=	O
strlen	function
(	O
dirname	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
newp	pointer
;	O
size_t	long
home_len	long
=	O
strlen	function
(	O
home_dir	pointer
)	O
;	O
newp	pointer
=	O
__alloca	O
(	O
home_len	long
+	O
dirlen	long
)	O
;	O
mempcpy	function
(	O
mempcpy	function
(	O
newp	pointer
,	O
home_dir	pointer
,	O
home_len	long
)	O
,	O
&	O
dirname	pointer
[	O
1	int
]	O
,	O
dirlen	long
)	O
;	O
dirname	pointer
=	O
newp	pointer
;	O
dirlen	long
+=	O
home_len	long
-	O
1	int
;	O
}	O
dirname_modified	int
=	O
1	int
;	O
}	O
else	O
{	O
char	O
*	O
end_name	pointer
=	O
strchr	function
(	O
dirname	pointer
,	O
'/'	O
)	O
;	O
const	O
char	O
*	O
user_name	pointer
;	O
const	O
char	O
*	O
home_dir	pointer
;	O
char	O
*	O
unescape	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
)	O
{	O
if	O
(	O
end_name	pointer
==	O
NULL	O
)	O
{	O
unescape	pointer
=	O
strchr	function
(	O
dirname	pointer
,	O
'\\'	O
)	O
;	O
if	O
(	O
unescape	pointer
)	O
end_name	pointer
=	O
strchr	function
(	O
unescape	pointer
,	O
'\0'	O
)	O
;	O
}	O
else	O
unescape	pointer
=	O
memchr	function
(	O
dirname	pointer
,	O
'\\'	O
,	O
end_name	pointer
-	O
dirname	pointer
)	O
;	O
}	O
if	O
(	O
end_name	pointer
==	O
NULL	O
)	O
user_name	pointer
=	O
dirname	pointer
+	O
1	int
;	O
else	O
{	O
char	O
*	O
newp	pointer
;	O
newp	pointer
=	O
__alloca	O
(	O
end_name	pointer
-	O
dirname	pointer
)	O
;	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	function
(	O
newp	pointer
,	O
dirname	pointer
+	O
1	int
,	O
end_name	pointer
-	O
dirname	pointer
)	O
)	O
=	O
'\0'	O
;	O
if	O
(	O
unescape	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
p	pointer
=	O
mempcpy	function
(	O
newp	pointer
,	O
dirname	pointer
+	O
1	int
,	O
unescape	pointer
-	O
dirname	pointer
-	O
1	int
)	O
;	O
char	O
*	O
q	pointer
=	O
unescape	pointer
;	O
while	O
(	O
*	O
q	pointer
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
q	pointer
==	O
'\\'	O
)	O
{	O
if	O
(	O
q	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
*	O
p	pointer
++	O
=	O
'\\'	O
;	O
break	O
;	O
}	O
++	O
q	pointer
;	O
}	O
*	O
p	pointer
++	O
=	O
*	O
q	pointer
++	O
;	O
}	O
*	O
p	pointer
=	O
'\0'	O
;	O
}	O
else	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	function
(	O
newp	pointer
,	O
dirname	pointer
+	O
1	int
,	O
end_name	pointer
-	O
dirname	pointer
)	O
)	O
=	O
'\0'	O
;	O
user_name	pointer
=	O
newp	pointer
;	O
}	O
{	O
struct	O
passwd	struct
*	O
p	pointer
;	O
long	O
int	O
buflen	long
=	O
GETPW_R_SIZE_MAX	O
(	O
)	O
;	O
char	O
*	O
pwtmpbuf	pointer
;	O
struct	O
passwd	struct
pwbuf	struct
;	O
int	O
save	int
=	O
errno	O
;	O
if	O
(	O
buflen	long
==	O
-	O
1	int
)	O
buflen	long
=	O
1024	int
;	O
pwtmpbuf	pointer
=	O
__alloca	O
(	O
buflen	long
)	O
;	O
while	O
(	O
getpwnam_r	function
(	O
user_name	pointer
,	O
&	O
pwbuf	struct
,	O
pwtmpbuf	pointer
,	O
buflen	long
,	O
&	O
p	pointer
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
ERANGE	int
)	O
{	O
p	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
buflen	long
*=	O
2	int
;	O
pwtmpbuf	pointer
=	O
__alloca	O
(	O
buflen	long
)	O
;	O
__set_errno	O
(	O
save	int
)	O
;	O
}	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
home_dir	pointer
=	O
p	pointer
->	O
pw_dir	pointer
;	O
else	O
home_dir	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
home_dir	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
newp	pointer
;	O
size_t	long
home_len	long
=	O
strlen	function
(	O
home_dir	pointer
)	O
;	O
size_t	long
rest_len	long
=	O
end_name	pointer
==	O
NULL	O
?	O
0	int
:	O
strlen	function
(	O
end_name	pointer
)	O
;	O
newp	pointer
=	O
__alloca	O
(	O
home_len	long
+	O
rest_len	long
+	O
1	int
)	O
;	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	function
(	O
mempcpy	function
(	O
newp	pointer
,	O
home_dir	pointer
,	O
home_len	long
)	O
,	O
end_name	pointer
,	O
rest_len	long
)	O
)	O
=	O
'\0'	O
;	O
dirname	pointer
=	O
newp	pointer
;	O
dirlen	long
=	O
home_len	long
+	O
rest_len	long
;	O
dirname_modified	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
flags	int
&	O
GLOB_TILDE_CHECK	O
)	O
return	O
GLOB_NOMATCH	int
;	O
}	O
}	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
{	O
struct	O
stat	struct
st	struct
;	O
struct_stat64	O
st64	struct
;	O
if	O
(	O
(	O
flags	int
&	O
GLOB_NOCHECK	O
)	O
||	O
(	O
(	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
)	O
?	O
(	O
(	O
*	O
pglob	pointer
->	O
gl_stat	pointer
)	O
(	O
dirname	pointer
,	O
&	O
st	struct
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
:	O
(	O
__stat64	O
(	O
dirname	pointer
,	O
&	O
st64	struct
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
st64	struct
.	O
st_mode	int
)	O
)	O
)	O
)	O
)	O
{	O
int	O
newcount	int
=	O
pglob	pointer
->	O
gl_pathc	long
+	O
pglob	pointer
->	O
gl_offs	long
;	O
char	O
*	O
*	O
new_gl_pathv	pointer
;	O
new_gl_pathv	pointer
=	O
realloc	function
(	O
pglob	pointer
->	O
gl_pathv	pointer
,	O
(	O
newcount	int
+	O
1	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
new_gl_pathv	pointer
==	O
NULL	O
)	O
{	O
nospace	O
:	O
free	function
(	O
pglob	pointer
->	O
gl_pathv	pointer
)	O
;	O
pglob	pointer
->	O
gl_pathv	pointer
=	O
NULL	O
;	O
pglob	pointer
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
pglob	pointer
->	O
gl_pathv	pointer
=	O
new_gl_pathv	pointer
;	O
if	O
(	O
flags	int
&	O
GLOB_MARK	O
)	O
{	O
char	O
*	O
p	pointer
;	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
newcount	int
]	O
=	O
malloc	function
(	O
dirlen	long
+	O
2	int
)	O
;	O
if	O
(	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
newcount	int
]	O
==	O
NULL	O
)	O
goto	O
nospace	O
;	O
p	pointer
=	O
mempcpy	function
(	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
newcount	int
]	O
,	O
dirname	pointer
,	O
dirlen	long
)	O
;	O
p	pointer
[	O
0	int
]	O
=	O
'/'	O
;	O
p	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
{	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
newcount	int
]	O
=	O
strdup	function
(	O
dirname	pointer
)	O
;	O
if	O
(	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
newcount	int
]	O
==	O
NULL	O
)	O
goto	O
nospace	O
;	O
}	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
++	O
newcount	int
]	O
=	O
NULL	O
;	O
++	O
pglob	pointer
->	O
gl_pathc	long
;	O
pglob	pointer
->	O
gl_flags	int
=	O
flags	int
;	O
return	O
0	int
;	O
}	O
return	O
GLOB_NOMATCH	int
;	O
}	O
meta	int
=	O
__glob_pattern_type	function
(	O
dirname	pointer
,	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
)	O
;	O
if	O
(	O
meta	int
&	O
5	int
)	O
{	O
size_t	long
i	long
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
&&	O
dirlen	long
>	O
0	int
&&	O
dirname	pointer
[	O
dirlen	long
-	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
char	O
*	O
p	pointer
=	O
(	O
char	O
*	O
)	O
&	O
dirname	pointer
[	O
dirlen	long
-	O
1	int
]	O
;	O
while	O
(	O
p	pointer
>	O
dirname	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
'\\'	O
)	O
--	O
p	pointer
;	O
if	O
(	O
(	O
&	O
dirname	pointer
[	O
dirlen	long
]	O
-	O
p	pointer
)	O
&	O
1	int
)	O
*	O
(	O
char	O
*	O
)	O
&	O
dirname	pointer
[	O
--	O
dirlen	long
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
__builtin_expect	O
(	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
)	O
!=	O
0	int
,	O
0	int
)	O
)	O
{	O
dirs	struct
.	O
gl_opendir	pointer
=	O
pglob	pointer
->	O
gl_opendir	pointer
;	O
dirs	struct
.	O
gl_readdir	pointer
=	O
pglob	pointer
->	O
gl_readdir	pointer
;	O
dirs	struct
.	O
gl_closedir	pointer
=	O
pglob	pointer
->	O
gl_closedir	pointer
;	O
dirs	struct
.	O
gl_stat	pointer
=	O
pglob	pointer
->	O
gl_stat	pointer
;	O
dirs	struct
.	O
gl_lstat	pointer
=	O
pglob	pointer
->	O
gl_lstat	pointer
;	O
}	O
status	int
=	O
glob	O
(	O
dirname	pointer
,	O
(	O
(	O
flags	int
&	O
(	O
GLOB_ERR	O
|	O
GLOB_NOESCAPE	O
|	O
GLOB_ALTDIRFUNC	O
)	O
)	O
|	O
GLOB_NOSORT	O
|	O
GLOB_ONLYDIR	O
)	O
,	O
errfunc	pointer
,	O
&	O
dirs	struct
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
flags	int
&	O
GLOB_NOCHECK	O
)	O
==	O
0	int
||	O
status	int
!=	O
GLOB_NOMATCH	int
)	O
return	O
status	int
;	O
goto	O
no_matches	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dirs	struct
.	O
gl_pathc	long
;	O
++	O
i	long
)	O
{	O
int	O
old_pathc	int
;	O
old_pathc	int
=	O
pglob	pointer
->	O
gl_pathc	long
;	O
status	int
=	O
glob_in_dir	function
(	O
filename	pointer
,	O
dirs	struct
.	O
gl_pathv	pointer
[	O
i	long
]	O
,	O
(	O
(	O
flags	int
|	O
GLOB_APPEND	O
)	O
&	O
~	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
)	O
,	O
errfunc	pointer
,	O
pglob	pointer
)	O
;	O
if	O
(	O
status	int
==	O
GLOB_NOMATCH	int
)	O
continue	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
globfree	O
(	O
&	O
dirs	struct
)	O
;	O
globfree	O
(	O
pglob	pointer
)	O
;	O
pglob	pointer
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
status	int
;	O
}	O
if	O
(	O
prefix_array	function
(	O
dirs	struct
.	O
gl_pathv	pointer
[	O
i	long
]	O
,	O
&	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
old_pathc	int
+	O
pglob	pointer
->	O
gl_offs	long
]	O
,	O
pglob	pointer
->	O
gl_pathc	long
-	O
old_pathc	int
)	O
)	O
{	O
globfree	O
(	O
&	O
dirs	struct
)	O
;	O
globfree	O
(	O
pglob	pointer
)	O
;	O
pglob	pointer
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
}	O
flags	int
|=	O
GLOB_MAGCHAR	O
;	O
if	O
(	O
pglob	pointer
->	O
gl_pathc	long
+	O
pglob	pointer
->	O
gl_offs	long
==	O
oldcount	long
)	O
{	O
no_matches	O
:	O
if	O
(	O
flags	int
&	O
GLOB_NOCHECK	O
)	O
{	O
int	O
newcount	int
=	O
pglob	pointer
->	O
gl_pathc	long
+	O
pglob	pointer
->	O
gl_offs	long
;	O
char	O
*	O
*	O
new_gl_pathv	pointer
;	O
new_gl_pathv	pointer
=	O
realloc	function
(	O
pglob	pointer
->	O
gl_pathv	pointer
,	O
(	O
newcount	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
new_gl_pathv	pointer
==	O
NULL	O
)	O
{	O
globfree	O
(	O
&	O
dirs	struct
)	O
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
pglob	pointer
->	O
gl_pathv	pointer
=	O
new_gl_pathv	pointer
;	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
newcount	int
]	O
=	O
strdup	function
(	O
pattern	pointer
)	O
;	O
if	O
(	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
newcount	int
]	O
==	O
NULL	O
)	O
{	O
globfree	O
(	O
&	O
dirs	struct
)	O
;	O
globfree	O
(	O
pglob	pointer
)	O
;	O
pglob	pointer
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
++	O
pglob	pointer
->	O
gl_pathc	long
;	O
++	O
newcount	int
;	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
newcount	int
]	O
=	O
NULL	O
;	O
pglob	pointer
->	O
gl_flags	int
=	O
flags	int
;	O
}	O
else	O
{	O
globfree	O
(	O
&	O
dirs	struct
)	O
;	O
return	O
GLOB_NOMATCH	int
;	O
}	O
}	O
globfree	O
(	O
&	O
dirs	struct
)	O
;	O
}	O
else	O
{	O
int	O
old_pathc	int
=	O
pglob	pointer
->	O
gl_pathc	long
;	O
int	O
orig_flags	int
=	O
flags	int
;	O
if	O
(	O
meta	int
&	O
2	int
)	O
{	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
dirname	pointer
,	O
'\\'	O
)	O
,	O
*	O
q	pointer
;	O
q	pointer
=	O
p	pointer
;	O
do	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\\'	O
)	O
{	O
*	O
q	pointer
=	O
*	O
++	O
p	pointer
;	O
--	O
dirlen	long
;	O
}	O
else	O
*	O
q	pointer
=	O
*	O
p	pointer
;	O
++	O
q	pointer
;	O
}	O
while	O
(	O
*	O
p	pointer
++	O
!=	O
'\0'	O
)	O
;	O
dirname_modified	int
=	O
1	int
;	O
}	O
if	O
(	O
dirname_modified	int
)	O
flags	int
&=	O
~	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
;	O
status	int
=	O
glob_in_dir	function
(	O
filename	pointer
,	O
dirname	pointer
,	O
flags	int
,	O
errfunc	pointer
,	O
pglob	pointer
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
if	O
(	O
status	int
==	O
GLOB_NOMATCH	int
&&	O
flags	int
!=	O
orig_flags	int
&&	O
pglob	pointer
->	O
gl_pathc	long
+	O
pglob	pointer
->	O
gl_offs	long
==	O
oldcount	long
)	O
{	O
dirs	struct
.	O
gl_pathv	pointer
=	O
NULL	O
;	O
flags	int
=	O
orig_flags	int
;	O
goto	O
no_matches	O
;	O
}	O
return	O
status	int
;	O
}	O
if	O
(	O
dirlen	long
>	O
0	int
)	O
{	O
if	O
(	O
prefix_array	function
(	O
dirname	pointer
,	O
&	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
old_pathc	int
+	O
pglob	pointer
->	O
gl_offs	long
]	O
,	O
pglob	pointer
->	O
gl_pathc	long
-	O
old_pathc	int
)	O
)	O
{	O
globfree	O
(	O
pglob	pointer
)	O
;	O
pglob	pointer
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
}	O
}	O
if	O
(	O
flags	int
&	O
GLOB_MARK	O
)	O
{	O
size_t	long
i	long
;	O
struct	O
stat	struct
st	struct
;	O
struct_stat64	O
st64	struct
;	O
for	O
(	O
i	long
=	O
oldcount	long
;	O
i	long
<	O
pglob	pointer
->	O
gl_pathc	long
+	O
pglob	pointer
->	O
gl_offs	long
;	O
++	O
i	long
)	O
if	O
(	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
?	O
(	O
(	O
*	O
pglob	pointer
->	O
gl_stat	pointer
)	O
(	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
i	long
]	O
,	O
&	O
st	struct
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
:	O
(	O
__stat64	O
(	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
i	long
]	O
,	O
&	O
st64	struct
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
st64	struct
.	O
st_mode	int
)	O
)	O
)	O
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
i	long
]	O
)	O
+	O
2	int
;	O
char	O
*	O
new	pointer
=	O
realloc	function
(	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
i	long
]	O
,	O
len	long
)	O
;	O
if	O
(	O
new	pointer
==	O
NULL	O
)	O
{	O
globfree	O
(	O
pglob	pointer
)	O
;	O
pglob	pointer
->	O
gl_pathc	long
=	O
0	int
;	O
return	O
GLOB_NOSPACE	int
;	O
}	O
strcpy	function
(	O
&	O
new	pointer
[	O
len	long
-	O
2	int
]	O
,	O
"/"	pointer
)	O
;	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
i	long
]	O
=	O
new	pointer
;	O
}	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
GLOB_NOSORT	O
)	O
)	O
{	O
qsort	function
(	O
&	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
oldcount	long
]	O
,	O
pglob	pointer
->	O
gl_pathc	long
+	O
pglob	pointer
->	O
gl_offs	long
-	O
oldcount	long
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
collated_compare	function
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
globfree	O
(	O
pglob	pointer
)	O
register	O
glob_t	struct
*	O
pglob	pointer
;	O
{	O
if	O
(	O
pglob	pointer
->	O
gl_pathv	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
pglob	pointer
->	O
gl_pathc	long
;	O
++	O
i	long
)	O
if	O
(	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
pglob	pointer
->	O
gl_offs	long
+	O
i	long
]	O
!=	O
NULL	O
)	O
free	function
(	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
pglob	pointer
->	O
gl_offs	long
+	O
i	long
]	O
)	O
;	O
free	function
(	O
pglob	pointer
->	O
gl_pathv	pointer
)	O
;	O
pglob	pointer
->	O
gl_pathv	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
int	O
collated_compare	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
char	O
*	O
const	O
*	O
ps1	pointer
=	O
a	pointer
;	O
char	O
*	O
s1	pointer
=	O
*	O
ps1	pointer
;	O
char	O
*	O
const	O
*	O
ps2	pointer
=	O
b	pointer
;	O
char	O
*	O
s2	pointer
=	O
*	O
ps2	pointer
;	O
if	O
(	O
s1	pointer
==	O
s2	pointer
)	O
return	O
0	int
;	O
if	O
(	O
s1	pointer
==	O
NULL	O
)	O
return	O
1	int
;	O
if	O
(	O
s2	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
return	O
strcoll	function
(	O
s1	pointer
,	O
s2	pointer
)	O
;	O
}	O
static	O
int	O
prefix_array	function
(	O
const	O
char	O
*	O
dirname	pointer
,	O
char	O
*	O
*	O
array	pointer
,	O
size_t	long
n	long
)	O
{	O
register	O
size_t	long
i	long
;	O
size_t	long
dirlen	long
=	O
strlen	function
(	O
dirname	pointer
)	O
;	O
if	O
(	O
dirlen	long
==	O
1	int
&&	O
dirname	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
dirlen	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
++	O
i	long
)	O
{	O
size_t	long
eltlen	long
=	O
strlen	function
(	O
array	pointer
[	O
i	long
]	O
)	O
+	O
1	int
;	O
char	O
*	O
new	pointer
=	O
malloc	function
(	O
dirlen	long
+	O
1	int
+	O
eltlen	long
)	O
;	O
if	O
(	O
new	pointer
==	O
NULL	O
)	O
{	O
while	O
(	O
i	long
>	O
0	int
)	O
free	function
(	O
array	pointer
[	O
--	O
i	long
]	O
)	O
;	O
return	O
1	int
;	O
}	O
{	O
char	O
*	O
endp	pointer
=	O
mempcpy	function
(	O
new	pointer
,	O
dirname	pointer
,	O
dirlen	long
)	O
;	O
*	O
endp	pointer
++	O
=	O
DIRSEP_CHAR	char
;	O
mempcpy	function
(	O
endp	pointer
,	O
array	pointer
[	O
i	long
]	O
,	O
eltlen	long
)	O
;	O
}	O
free	function
(	O
array	pointer
[	O
i	long
]	O
)	O
;	O
array	pointer
[	O
i	long
]	O
=	O
new	pointer
;	O
}	O
return	O
0	int
;	O
}	O
int	O
__glob_pattern_type	function
(	O
pattern	pointer
,	O
quote	int
)	O
const	O
char	O
*	O
pattern	pointer
;	O
int	O
quote	int
;	O
{	O
register	O
const	O
char	O
*	O
p	pointer
;	O
int	O
ret	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
pattern	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
++	O
p	pointer
)	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'?'	O
:	O
case	O
'*'	O
:	O
return	O
1	int
;	O
case	O
'\\'	O
:	O
if	O
(	O
quote	int
)	O
{	O
if	O
(	O
p	pointer
[	O
1	int
]	O
!=	O
'\0'	O
)	O
++	O
p	pointer
;	O
ret	int
|=	O
2	int
;	O
}	O
break	O
;	O
case	O
'['	O
:	O
ret	int
|=	O
4	int
;	O
break	O
;	O
case	O
']'	O
:	O
if	O
(	O
ret	int
&	O
4	int
)	O
return	O
1	int
;	O
break	O
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
__glob_pattern_p	O
(	O
pattern	pointer
,	O
quote	int
)	O
const	O
char	O
*	O
pattern	pointer
;	O
int	O
quote	int
;	O
{	O
return	O
__glob_pattern_type	function
(	O
pattern	pointer
,	O
quote	int
)	O
==	O
1	int
;	O
}	O
static	O
int	O
__attribute_noinline__	O
link_exists2_p	function
(	O
const	O
char	O
*	O
dir	pointer
,	O
size_t	long
dirlen	long
,	O
const	O
char	O
*	O
fname	pointer
,	O
glob_t	struct
*	O
pglob	pointer
)	O
{	O
size_t	long
fnamelen	long
=	O
strlen	function
(	O
fname	pointer
)	O
;	O
char	O
*	O
fullname	pointer
=	O
__alloca	O
(	O
dirlen	long
+	O
1	int
+	O
fnamelen	long
+	O
1	int
)	O
;	O
struct	O
stat	struct
st	struct
;	O
mempcpy	function
(	O
mempcpy	function
(	O
mempcpy	function
(	O
fullname	pointer
,	O
dir	pointer
,	O
dirlen	long
)	O
,	O
"/"	pointer
,	O
1	int
)	O
,	O
fname	pointer
,	O
fnamelen	long
+	O
1	int
)	O
;	O
return	O
(	O
*	O
pglob	pointer
->	O
gl_stat	pointer
)	O
(	O
fullname	pointer
,	O
&	O
st	struct
)	O
==	O
0	int
;	O
}	O
static	O
int	O
link_exists_p	function
(	O
int	O
dfd	int
,	O
const	O
char	O
*	O
dir	pointer
,	O
size_t	long
dirlen	long
,	O
const	O
char	O
*	O
fname	pointer
,	O
glob_t	struct
*	O
pglob	pointer
,	O
int	O
flags	int
)	O
{	O
if	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
)	O
return	O
link_exists2_p	function
(	O
dir	pointer
,	O
dirlen	long
,	O
fname	pointer
,	O
pglob	pointer
)	O
;	O
else	O
{	O
struct_stat64	O
st64	struct
;	O
return	O
__fxstatat64	function
(	O
_STAT_VER	O
,	O
dfd	int
,	O
fname	pointer
,	O
&	O
st64	struct
,	O
0	int
)	O
==	O
0	int
;	O
}	O
}	O
static	O
int	O
glob_in_dir	function
(	O
const	O
char	O
*	O
pattern	pointer
,	O
const	O
char	O
*	O
directory	pointer
,	O
int	O
flags	int
,	O
int	O
(	O
*	O
errfunc	pointer
)	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
,	O
glob_t	struct
*	O
pglob	pointer
)	O
{	O
size_t	long
dirlen	long
=	O
strlen	function
(	O
directory	pointer
)	O
;	O
void	O
*	O
stream	pointer
=	O
NULL	O
;	O
struct	O
globnames	struct
{	O
struct	O
globnames	struct
*	O
next	pointer
;	O
size_t	long
count	long
;	O
char	O
*	O
name	pointer
[	O
64	int
]	O
;	O
}	O
;	O
struct	O
globnames	struct
init_names	struct
;	O
struct	O
globnames	struct
*	O
names	pointer
=	O
&	O
init_names	struct
;	O
struct	O
globnames	struct
*	O
names_alloca	pointer
=	O
&	O
init_names	struct
;	O
size_t	long
nfound	long
=	O
0	int
;	O
size_t	long
allocasize	long
=	O
sizeof	O
(	O
init_names	struct
)	O
;	O
size_t	long
cur	long
=	O
0	int
;	O
int	O
meta	int
;	O
int	O
save	int
;	O
int	O
result	int
;	O
init_names	struct
.	O
next	pointer
=	O
NULL	O
;	O
init_names	struct
.	O
count	long
=	O
INITIAL_COUNT	O
;	O
meta	int
=	O
__glob_pattern_type	function
(	O
pattern	pointer
,	O
!	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
)	O
;	O
if	O
(	O
meta	int
==	O
0	int
&&	O
(	O
flags	int
&	O
(	O
GLOB_NOCHECK	O
|	O
GLOB_NOMAGIC	O
)	O
)	O
)	O
{	O
flags	int
|=	O
GLOB_NOCHECK	O
;	O
}	O
else	O
if	O
(	O
meta	int
==	O
0	int
)	O
{	O
struct	O
stat	struct
st	struct
;	O
struct_stat64	O
st64	struct
;	O
size_t	long
patlen	long
=	O
strlen	function
(	O
pattern	pointer
)	O
;	O
char	O
*	O
fullname	pointer
=	O
__alloca	O
(	O
dirlen	long
+	O
1	int
+	O
patlen	long
+	O
1	int
)	O
;	O
mempcpy	function
(	O
mempcpy	function
(	O
mempcpy	function
(	O
fullname	pointer
,	O
directory	pointer
,	O
dirlen	long
)	O
,	O
"/"	pointer
,	O
1	int
)	O
,	O
pattern	pointer
,	O
patlen	long
+	O
1	int
)	O
;	O
if	O
(	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
?	O
(	O
*	O
pglob	pointer
->	O
gl_stat	pointer
)	O
(	O
fullname	pointer
,	O
&	O
st	struct
)	O
:	O
__stat64	O
(	O
fullname	pointer
,	O
&	O
st64	struct
)	O
)	O
==	O
0	int
)	O
flags	int
|=	O
GLOB_NOCHECK	O
;	O
}	O
else	O
{	O
stream	pointer
=	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
?	O
(	O
*	O
pglob	pointer
->	O
gl_opendir	pointer
)	O
(	O
directory	pointer
)	O
:	O
opendir	function
(	O
directory	pointer
)	O
)	O
;	O
if	O
(	O
stream	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOTDIR	int
&&	O
(	O
(	O
errfunc	pointer
!=	O
NULL	O
&&	O
(	O
*	O
errfunc	pointer
)	O
(	O
directory	pointer
,	O
errno	O
)	O
)	O
||	O
(	O
flags	int
&	O
GLOB_ERR	O
)	O
)	O
)	O
return	O
GLOB_ABORTED	int
;	O
}	O
else	O
{	O
int	O
dfd	int
=	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
?	O
-	O
1	int
:	O
dirfd	function
(	O
(	O
DIR	struct
*	O
)	O
stream	pointer
)	O
)	O
;	O
int	O
fnm_flags	int
=	O
(	O
(	O
!	O
(	O
flags	int
&	O
GLOB_PERIOD	O
)	O
?	O
FNM_PERIOD	O
:	O
0	int
)	O
|	O
(	O
(	O
flags	int
&	O
GLOB_NOESCAPE	O
)	O
?	O
FNM_NOESCAPE	O
:	O
0	int
)	O
)	O
;	O
flags	int
|=	O
GLOB_MAGCHAR	O
;	O
while	O
(	O
1	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
size_t	long
len	long
;	O
struct	O
dirent	struct
*	O
d	pointer
=	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
?	O
(	O
(	O
struct	O
dirent	struct
*	O
)	O
(	O
*	O
pglob	pointer
->	O
gl_readdir	pointer
)	O
(	O
stream	pointer
)	O
)	O
:	O
__readdir	O
(	O
stream	pointer
)	O
)	O
;	O
if	O
(	O
d	pointer
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
!	O
REAL_DIR_ENTRY	O
(	O
d	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
flags	int
&	O
GLOB_ONLYDIR	O
)	O
&&	O
!	O
DIRENT_MIGHT_BE_DIR	O
(	O
d	pointer
)	O
)	O
continue	O
;	O
name	pointer
=	O
d	pointer
->	O
d_name	array
;	O
if	O
(	O
fnmatch	function
(	O
pattern	pointer
,	O
name	pointer
,	O
fnm_flags	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
DIRENT_MIGHT_BE_SYMLINK	O
(	O
d	pointer
)	O
||	O
link_exists_p	function
(	O
dfd	int
,	O
directory	pointer
,	O
dirlen	long
,	O
name	pointer
,	O
pglob	pointer
,	O
flags	int
)	O
)	O
{	O
if	O
(	O
cur	long
==	O
names	pointer
->	O
count	long
)	O
{	O
struct	O
globnames	struct
*	O
newnames	pointer
;	O
size_t	long
count	long
=	O
names	pointer
->	O
count	long
*	O
2	int
;	O
size_t	long
size	long
=	O
(	O
sizeof	O
(	O
struct	O
globnames	struct
)	O
+	O
(	O
(	O
count	long
-	O
INITIAL_COUNT	O
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
)	O
;	O
allocasize	long
+=	O
size	long
;	O
if	O
(	O
__libc_use_alloca	O
(	O
allocasize	long
)	O
)	O
newnames	pointer
=	O
names_alloca	pointer
=	O
__alloca	O
(	O
size	long
)	O
;	O
else	O
if	O
(	O
(	O
newnames	pointer
=	O
malloc	function
(	O
size	long
)	O
)	O
==	O
NULL	O
)	O
goto	O
memory_error	O
;	O
newnames	pointer
->	O
count	long
=	O
count	long
;	O
newnames	pointer
->	O
next	pointer
=	O
names	pointer
;	O
names	pointer
=	O
newnames	pointer
;	O
cur	long
=	O
0	int
;	O
}	O
len	long
=	O
_D_EXACT_NAMLEN	O
(	O
d	pointer
)	O
;	O
names	pointer
->	O
name	pointer
[	O
cur	long
]	O
=	O
malloc	function
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
names	pointer
->	O
name	pointer
[	O
cur	long
]	O
==	O
NULL	O
)	O
goto	O
memory_error	O
;	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	function
(	O
names	pointer
->	O
name	pointer
[	O
cur	long
++	O
]	O
,	O
name	pointer
,	O
len	long
)	O
)	O
=	O
'\0'	O
;	O
++	O
nfound	long
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
nfound	long
==	O
0	int
&&	O
(	O
flags	int
&	O
GLOB_NOCHECK	O
)	O
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
pattern	pointer
)	O
;	O
nfound	long
=	O
1	int
;	O
names	pointer
->	O
name	pointer
[	O
cur	long
]	O
=	O
malloc	function
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
names	pointer
->	O
name	pointer
[	O
cur	long
]	O
==	O
NULL	O
)	O
goto	O
memory_error	O
;	O
*	O
(	O
(	O
char	O
*	O
)	O
mempcpy	function
(	O
names	pointer
->	O
name	pointer
[	O
cur	long
++	O
]	O
,	O
pattern	pointer
,	O
len	long
)	O
)	O
=	O
'\0'	O
;	O
}	O
result	int
=	O
GLOB_NOMATCH	int
;	O
if	O
(	O
nfound	long
!=	O
0	int
)	O
{	O
char	O
*	O
*	O
new_gl_pathv	pointer
=	O
realloc	function
(	O
pglob	pointer
->	O
gl_pathv	pointer
,	O
(	O
pglob	pointer
->	O
gl_pathc	long
+	O
pglob	pointer
->	O
gl_offs	long
+	O
nfound	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
result	int
=	O
0	int
;	O
if	O
(	O
new_gl_pathv	pointer
==	O
NULL	O
)	O
{	O
memory_error	O
:	O
while	O
(	O
1	int
)	O
{	O
struct	O
globnames	struct
*	O
old	pointer
=	O
names	pointer
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cur	long
;	O
++	O
i	long
)	O
free	function
(	O
names	pointer
->	O
name	pointer
[	O
i	long
]	O
)	O
;	O
names	pointer
=	O
names	pointer
->	O
next	pointer
;	O
if	O
(	O
names	pointer
==	O
NULL	O
)	O
{	O
assert	O
(	O
old	pointer
==	O
&	O
init_names	struct
)	O
;	O
break	O
;	O
}	O
cur	long
=	O
names	pointer
->	O
count	long
;	O
if	O
(	O
old	pointer
==	O
names_alloca	pointer
)	O
names_alloca	pointer
=	O
names	pointer
;	O
else	O
free	function
(	O
old	pointer
)	O
;	O
}	O
result	int
=	O
GLOB_NOSPACE	int
;	O
}	O
else	O
{	O
while	O
(	O
1	int
)	O
{	O
struct	O
globnames	struct
*	O
old	pointer
=	O
names	pointer
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
cur	long
;	O
++	O
i	long
)	O
new_gl_pathv	pointer
[	O
pglob	pointer
->	O
gl_offs	long
+	O
pglob	pointer
->	O
gl_pathc	long
++	O
]	O
=	O
names	pointer
->	O
name	pointer
[	O
i	long
]	O
;	O
names	pointer
=	O
names	pointer
->	O
next	pointer
;	O
if	O
(	O
names	pointer
==	O
NULL	O
)	O
{	O
assert	O
(	O
old	pointer
==	O
&	O
init_names	struct
)	O
;	O
break	O
;	O
}	O
cur	long
=	O
names	pointer
->	O
count	long
;	O
if	O
(	O
old	pointer
==	O
names_alloca	pointer
)	O
names_alloca	pointer
=	O
names	pointer
;	O
else	O
free	function
(	O
old	pointer
)	O
;	O
}	O
pglob	pointer
->	O
gl_pathv	pointer
=	O
new_gl_pathv	pointer
;	O
pglob	pointer
->	O
gl_pathv	pointer
[	O
pglob	pointer
->	O
gl_offs	long
+	O
pglob	pointer
->	O
gl_pathc	long
]	O
=	O
NULL	O
;	O
pglob	pointer
->	O
gl_flags	int
=	O
flags	int
;	O
}	O
}	O
if	O
(	O
stream	pointer
!=	O
NULL	O
)	O
{	O
save	int
=	O
errno	O
;	O
if	O
(	O
__builtin_expect	O
(	O
flags	int
&	O
GLOB_ALTDIRFUNC	O
,	O
0	int
)	O
)	O
(	O
*	O
pglob	pointer
->	O
gl_closedir	pointer
)	O
(	O
stream	pointer
)	O
;	O
else	O
closedir	function
(	O
stream	pointer
)	O
;	O
__set_errno	O
(	O
save	int
)	O
;	O
}	O
return	O
result	int
;	O
}	O
