struct	O
process	struct
{	O
struct	O
process	struct
*	O
next	pointer
,	O
*	O
prev	pointer
;	O
int	O
type	enum
;	O
unsigned	O
timeout	int
;	O
pid_t	int
pid	int
;	O
time_t	long
start	long
;	O
union	O
{	O
struct	O
process	struct
*	O
redir	array
[	O
2	int
]	O
;	O
struct	O
process	struct
*	O
master	pointer
;	O
}	O
v	union
;	O
}	O
;	O
struct	O
process	struct
*	O
proc_list	pointer
;	O
struct	O
process	struct
*	O
proc_avail	pointer
;	O
struct	O
process	struct
*	O
proc_unlink	function
(	O
struct	O
process	struct
*	O
*	O
root	pointer
,	O
struct	O
process	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
prev	pointer
)	O
p	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
p	pointer
->	O
next	pointer
;	O
else	O
*	O
root	pointer
=	O
p	pointer
->	O
next	pointer
;	O
if	O
(	O
p	pointer
->	O
next	pointer
)	O
p	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
p	pointer
->	O
prev	pointer
;	O
p	pointer
->	O
next	pointer
=	O
p	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
return	O
p	pointer
;	O
}	O
struct	O
process	struct
*	O
proc_pop	function
(	O
struct	O
process	struct
*	O
*	O
pp	pointer
)	O
{	O
if	O
(	O
*	O
pp	pointer
)	O
return	O
proc_unlink	function
(	O
pp	pointer
,	O
*	O
pp	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
proc_push	function
(	O
struct	O
process	struct
*	O
*	O
pp	pointer
,	O
struct	O
process	struct
*	O
p	pointer
)	O
{	O
p	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
p	pointer
->	O
next	pointer
=	O
*	O
pp	pointer
;	O
if	O
(	O
*	O
pp	pointer
)	O
(	O
*	O
pp	pointer
)	O
->	O
prev	pointer
=	O
p	pointer
;	O
*	O
pp	pointer
=	O
p	pointer
;	O
}	O
struct	O
process	struct
*	O
register_process	function
(	O
int	O
type	enum
,	O
pid_t	int
pid	int
,	O
time_t	long
t	long
,	O
unsigned	O
timeout	int
)	O
{	O
struct	O
process	struct
*	O
p	pointer
;	O
if	O
(	O
proc_avail	pointer
)	O
p	pointer
=	O
proc_pop	function
(	O
&	O
proc_avail	pointer
)	O
;	O
else	O
p	pointer
=	O
emalloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
memset	function
(	O
p	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
->	O
type	enum
=	O
type	enum
;	O
p	pointer
->	O
timeout	int
=	O
timeout	int
;	O
p	pointer
->	O
pid	int
=	O
pid	int
;	O
p	pointer
->	O
start	long
=	O
t	long
;	O
proc_push	function
(	O
&	O
proc_list	pointer
,	O
p	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
void	O
deregister_process	function
(	O
pid_t	int
pid	int
,	O
time_t	long
t	long
)	O
{	O
struct	O
process	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
proc_list	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
p	pointer
->	O
pid	int
==	O
pid	int
)	O
{	O
if	O
(	O
p	pointer
->	O
prev	pointer
)	O
p	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
p	pointer
->	O
next	pointer
;	O
else	O
proc_list	pointer
=	O
p	pointer
;	O
if	O
(	O
p	pointer
->	O
next	pointer
)	O
p	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
p	pointer
->	O
prev	pointer
;	O
free	function
(	O
p	pointer
)	O
;	O
break	O
;	O
}	O
}	O
struct	O
process	struct
*	O
process_lookup	function
(	O
pid_t	int
pid	int
)	O
{	O
struct	O
process	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
proc_list	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
p	pointer
->	O
pid	int
==	O
pid	int
)	O
return	O
p	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
print_status	function
(	O
pid_t	int
pid	int
,	O
int	O
status	int
,	O
sigset_t	struct
*	O
mask	struct
)	O
{	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
if	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
==	O
0	int
)	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"process %lu exited successfully"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
)	O
;	O
else	O
diag	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"process %lu failed with status %d"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
,	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
int	O
prio	int
;	O
if	O
(	O
sigismember	function
(	O
mask	struct
,	O
WTERMSIG	O
(	O
status	int
)	O
)	O
)	O
prio	int
=	O
LOG_DEBUG	int
;	O
else	O
prio	int
=	O
LOG_ERR	int
;	O
diag	function
(	O
prio	int
,	O
_	O
(	O
"process %lu terminated on signal %d"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
,	O
WTERMSIG	O
(	O
status	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
WIFSTOPPED	O
(	O
status	int
)	O
)	O
diag	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"process %lu stopped on signal %d"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
,	O
WSTOPSIG	O
(	O
status	int
)	O
)	O
;	O
else	O
if	O
(	O
WCOREDUMP	O
(	O
status	int
)	O
)	O
diag	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"process %lu dumped core"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
;	O
else	O
diag	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"process %lu terminated with unrecognized status"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
;	O
}	O
void	O
process_cleanup	function
(	O
int	O
expect_term	int
)	O
{	O
pid_t	int
pid	int
;	O
int	O
status	int
;	O
while	O
(	O
(	O
pid	int
=	O
waitpid	function
(	O
-	O
1	int
,	O
&	O
status	int
,	O
WNOHANG	int
)	O
)	O
>	O
0	int
)	O
{	O
sigset_t	struct
set	struct
;	O
sigemptyset	function
(	O
&	O
set	struct
)	O
;	O
if	O
(	O
pid	int
==	O
self_test_pid	int
)	O
{	O
sigaddset	function
(	O
&	O
set	struct
,	O
SIGHUP	int
)	O
;	O
print_status	function
(	O
pid	int
,	O
status	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
exit_code	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
status	int
)	O
)	O
{	O
if	O
(	O
WTERMSIG	O
(	O
status	int
)	O
==	O
SIGHUP	int
)	O
exit_code	int
=	O
0	int
;	O
else	O
exit_code	int
=	O
2	int
;	O
}	O
else	O
exit_code	int
=	O
2	int
;	O
stop	int
=	O
1	int
;	O
}	O
else	O
{	O
struct	O
process	struct
*	O
p	pointer
=	O
process_lookup	function
(	O
pid	int
)	O
;	O
if	O
(	O
expect_term	int
)	O
sigaddset	function
(	O
&	O
set	struct
,	O
SIGTERM	int
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
sigaddset	function
(	O
&	O
set	struct
,	O
SIGTERM	int
)	O
;	O
sigaddset	function
(	O
&	O
set	struct
,	O
SIGKILL	int
)	O
;	O
}	O
print_status	function
(	O
pid	int
,	O
status	int
,	O
&	O
set	struct
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
continue	O
;	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
PROC_HANDLER	int
)	O
{	O
if	O
(	O
p	pointer
->	O
v	union
.	O
redir	array
[	O
REDIR_OUT	int
]	O
)	O
p	pointer
->	O
v	union
.	O
redir	array
[	O
REDIR_OUT	int
]	O
->	O
v	union
.	O
master	pointer
=	O
NULL	O
;	O
if	O
(	O
p	pointer
->	O
v	union
.	O
redir	array
[	O
REDIR_ERR	int
]	O
)	O
p	pointer
->	O
v	union
.	O
redir	array
[	O
REDIR_ERR	int
]	O
->	O
v	union
.	O
master	pointer
=	O
NULL	O
;	O
}	O
p	pointer
->	O
pid	int
=	O
0	int
;	O
proc_unlink	function
(	O
&	O
proc_list	pointer
,	O
p	pointer
)	O
;	O
proc_push	function
(	O
&	O
proc_avail	pointer
,	O
p	pointer
)	O
;	O
}	O
}	O
}	O
void	O
process_timeouts	function
(	O
)	O
{	O
struct	O
process	struct
*	O
p	pointer
;	O
time_t	long
now	long
=	O
time	function
(	O
NULL	O
)	O
;	O
time_t	long
alarm_time	long
=	O
0	int
,	O
x	long
;	O
debug	O
(	O
2	int
,	O
(	O
_	O
(	O
"begin scanning process list"	pointer
)	O
)	O
)	O
;	O
for	O
(	O
p	pointer
=	O
proc_list	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
x	long
=	O
now	long
-	O
p	pointer
->	O
start	long
;	O
if	O
(	O
x	long
>=	O
p	pointer
->	O
timeout	int
)	O
{	O
diag	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"process %lu timed out"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
p	pointer
->	O
pid	int
)	O
;	O
kill	function
(	O
p	pointer
->	O
pid	int
,	O
SIGKILL	int
)	O
;	O
}	O
else	O
if	O
(	O
alarm_time	long
==	O
0	int
||	O
p	pointer
->	O
timeout	int
-	O
x	long
<	O
alarm_time	long
)	O
alarm_time	long
=	O
p	pointer
->	O
timeout	int
-	O
x	long
;	O
}	O
if	O
(	O
alarm_time	long
)	O
{	O
debug	O
(	O
2	int
,	O
(	O
_	O
(	O
"scheduling alarm in %lu seconds"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
alarm_time	long
)	O
)	O
;	O
alarm	function
(	O
alarm_time	long
)	O
;	O
}	O
debug	O
(	O
2	int
,	O
(	O
"end scanning process list"	pointer
)	O
)	O
;	O
}	O
int	O
switchpriv	function
(	O
struct	O
prog_handler	struct
*	O
hp	pointer
)	O
{	O
if	O
(	O
hp	pointer
->	O
uid	int
==	O
0	int
||	O
hp	pointer
->	O
uid	int
==	O
getuid	function
(	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
setgroups	function
(	O
hp	pointer
->	O
gidc	long
,	O
hp	pointer
->	O
gidv	pointer
)	O
<	O
0	int
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
"setgroups: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
setregid	function
(	O
hp	pointer
->	O
gidv	pointer
[	O
0	int
]	O
,	O
hp	pointer
->	O
gidv	pointer
[	O
0	int
]	O
)	O
<	O
0	int
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
"setregid(%lu,%lu): %s"	pointer
,	O
(	O
unsigned	O
long	O
)	O
hp	pointer
->	O
gidv	pointer
[	O
0	int
]	O
,	O
(	O
unsigned	O
long	O
)	O
hp	pointer
->	O
gidv	pointer
[	O
0	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
setreuid	function
(	O
hp	pointer
->	O
uid	int
,	O
hp	pointer
->	O
uid	int
)	O
<	O
0	int
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
"setreuid(%lu,%lu): %s"	pointer
,	O
(	O
unsigned	O
long	O
)	O
hp	pointer
->	O
uid	int
,	O
(	O
unsigned	O
long	O
)	O
hp	pointer
->	O
uid	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
typedef	O
fd_set	struct
*	O
bigfd_set	pointer
;	O
static	O
void	O
close_fds	function
(	O
bigfd_set	pointer
fdset	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
dup	function
(	O
0	int
)	O
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
{	O
if	O
(	O
fdset	pointer
&&	O
BIGFD_ISSET	O
(	O
i	int
,	O
fdset	pointer
)	O
)	O
continue	O
;	O
close	function
(	O
i	int
)	O
;	O
}	O
}	O
static	O
void	O
redir_exit	function
(	O
int	O
sig	int
)	O
{	O
_exit	function
(	O
0	int
)	O
;	O
}	O
int	O
open_redirector	function
(	O
const	O
char	O
*	O
tag	pointer
,	O
int	O
prio	int
,	O
struct	O
process	struct
*	O
*	O
return_proc	pointer
)	O
{	O
int	O
p	pointer
[	O
2	int
]	O
;	O
FILE	struct
*	O
fp	pointer
;	O
char	O
buf	array
[	O
512	int
]	O
;	O
pid_t	int
pid	int
;	O
bigfd_set	pointer
fdset	pointer
;	O
if	O
(	O
pipe	function
(	O
p	pointer
)	O
)	O
{	O
diag	function
(	O
LOG_ERR	int
,	O
_	O
(	O
"cannot start redirector for %s, pipe failed: %s"	pointer
)	O
,	O
tag	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
{	O
case	O
0	int
:	O
fdset	pointer
=	O
BIGFD_SET_ALLOC	O
(	O
)	O
;	O
BIGFD_SET	O
(	O
p	pointer
[	O
0	int
]	O
,	O
fdset	pointer
)	O
;	O
if	O
(	O
facility	int
<=	O
0	int
)	O
BIGFD_SET	O
(	O
2	int
,	O
fdset	pointer
)	O
;	O
close_fds	function
(	O
fdset	pointer
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
signal_setup	function
(	O
redir_exit	function
)	O
;	O
fp	pointer
=	O
fdopen	function
(	O
p	pointer
[	O
0	int
]	O
,	O
"r"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
_exit	function
(	O
1	int
)	O
;	O
if	O
(	O
facility	int
>	O
0	int
)	O
openlog	function
(	O
tag	pointer
,	O
LOG_PID	int
,	O
facility	int
)	O
;	O
while	O
(	O
fgets	function
(	O
buf	array
,	O
sizeof	O
(	O
buf	array
)	O
,	O
fp	pointer
)	O
>	O
0	int
)	O
{	O
int	O
len	long
=	O
strlen	function
(	O
buf	array
)	O
;	O
if	O
(	O
len	long
&&	O
buf	array
[	O
len	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
buf	array
[	O
len	long
-	O
1	int
]	O
=	O
0	int
;	O
diag	function
(	O
prio	int
,	O
"%s"	pointer
,	O
buf	array
)	O
;	O
}	O
_exit	function
(	O
0	int
)	O
;	O
case	O
-	O
1	int
:	O
diag	function
(	O
LOG_CRIT	int
,	O
_	O
(	O
"cannot run redirector `%s': fork failed: %s"	pointer
)	O
,	O
tag	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
default	O
:	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"redirector for %s started, pid=%lu"	pointer
)	O
,	O
tag	pointer
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
)	O
;	O
close	function
(	O
p	pointer
[	O
0	int
]	O
)	O
;	O
*	O
return_proc	pointer
=	O
register_process	function
(	O
PROC_REDIR	int
,	O
pid	int
,	O
time	function
(	O
NULL	O
)	O
,	O
0	int
)	O
;	O
return	O
p	pointer
[	O
1	int
]	O
;	O
}	O
}	O
static	O
void	O
runcmd	function
(	O
const	O
char	O
*	O
cmd	pointer
,	O
char	O
*	O
*	O
envhint	pointer
,	O
event_mask	struct
*	O
event	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
int	O
shell	int
)	O
{	O
char	O
*	O
kve	pointer
[	O
13	int
]	O
;	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
char	O
buf	array
[	O
1024	int
]	O
;	O
int	O
i	int
=	O
0	int
,	O
j	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
char	O
*	O
xargv	array
[	O
4	int
]	O
;	O
struct	O
wordsplit	struct
ws	pointer
;	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
"file"	pointer
;	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
(	O
char	O
*	O
)	O
file	pointer
;	O
snprintf	function
(	O
buf	array
,	O
sizeof	O
buf	array
,	O
"%d"	pointer
,	O
event	pointer
->	O
sys_mask	int
)	O
;	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
"sysev_code"	pointer
;	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
estrdup	function
(	O
buf	array
)	O
;	O
if	O
(	O
self_test_pid	int
)	O
{	O
snprintf	function
(	O
buf	array
,	O
sizeof	O
buf	array
,	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
self_test_pid	int
)	O
;	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
"self_test_pid"	pointer
;	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
estrdup	function
(	O
buf	array
)	O
;	O
}	O
q	pointer
=	O
buf	array
;	O
for	O
(	O
p	pointer
=	O
trans_tokfirst	function
(	O
sysev_transtab	array
,	O
event	pointer
->	O
sys_mask	int
,	O
&	O
j	int
)	O
;	O
p	pointer
;	O
p	pointer
=	O
trans_toknext	function
(	O
sysev_transtab	array
,	O
event	pointer
->	O
sys_mask	int
,	O
&	O
j	int
)	O
)	O
{	O
if	O
(	O
q	pointer
>	O
buf	array
)	O
*	O
q	pointer
++	O
=	O
' '	O
;	O
while	O
(	O
*	O
p	pointer
)	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
}	O
*	O
q	pointer
=	O
0	int
;	O
if	O
(	O
q	pointer
>	O
buf	array
)	O
{	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
"sysev_name"	pointer
;	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
estrdup	function
(	O
buf	array
)	O
;	O
}	O
p	pointer
=	O
trans_toktostr	function
(	O
genev_transtab	array
,	O
event	pointer
->	O
gen_mask	int
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
snprintf	function
(	O
buf	array
,	O
sizeof	O
buf	array
,	O
"%d"	pointer
,	O
event	pointer
->	O
gen_mask	int
)	O
;	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
"genev_code"	pointer
;	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
estrdup	function
(	O
buf	array
)	O
;	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
"genev_name"	pointer
;	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
p	pointer
;	O
}	O
kve	pointer
[	O
i	int
++	O
]	O
=	O
0	int
;	O
ws	pointer
.	O
ws_env	pointer
=	O
(	O
const	O
char	O
*	O
*	O
)	O
kve	pointer
;	O
if	O
(	O
wordsplit	struct
(	O
cmd	pointer
,	O
&	O
ws	pointer
,	O
WRDSF_NOCMD	int
|	O
WRDSF_QUOTE	O
|	O
WRDSF_SQUEEZE_DELIMS	int
|	O
WRDSF_CESCAPES	int
|	O
WRDSF_ENV	int
|	O
WRDSF_ENV_KV	int
|	O
(	O
shell	int
?	O
WRDSF_NOSPLIT	int
:	O
0	int
)	O
)	O
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
"wordsplit: %s"	pointer
,	O
wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
_exit	function
(	O
127	int
)	O
;	O
}	O
if	O
(	O
shell	int
)	O
{	O
xargv	array
[	O
0	int
]	O
=	O
"/bin/sh"	pointer
;	O
xargv	array
[	O
1	int
]	O
=	O
"-c"	pointer
;	O
xargv	array
[	O
2	int
]	O
=	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
;	O
xargv	array
[	O
3	int
]	O
=	O
NULL	O
;	O
argv	pointer
=	O
xargv	array
;	O
}	O
else	O
argv	pointer
=	O
ws	pointer
.	O
ws_wordv	pointer
;	O
execve	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
,	O
environ_setup	function
(	O
envhint	pointer
,	O
kve	pointer
)	O
)	O
;	O
diag	function
(	O
LOG_ERR	int
,	O
"execve: %s \"%s\": %s"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
cmd	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
_exit	function
(	O
127	int
)	O
;	O
}	O
static	O
int	O
prog_handler_run	function
(	O
struct	O
watchpoint	struct
*	O
wp	pointer
,	O
event_mask	struct
*	O
event	pointer
,	O
const	O
char	O
*	O
dirname	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
pid_t	int
pid	int
;	O
int	O
redir_fd	array
[	O
2	int
]	O
=	O
{	O
-	O
1	int
,	O
-	O
1	int
}	O
;	O
struct	O
process	struct
*	O
redir_proc	array
[	O
2	int
]	O
=	O
{	O
NULL	O
,	O
NULL	O
}	O
;	O
struct	O
process	struct
*	O
p	pointer
;	O
struct	O
prog_handler	struct
*	O
hp	pointer
=	O
data	pointer
;	O
if	O
(	O
!	O
hp	pointer
->	O
command	pointer
)	O
return	O
0	int
;	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"starting %s, dir=%s, file=%s"	pointer
)	O
,	O
hp	pointer
->	O
command	pointer
,	O
dirname	pointer
,	O
file	pointer
)	O
)	O
;	O
if	O
(	O
hp	pointer
->	O
flags	int
&	O
HF_STDERR	int
)	O
redir_fd	array
[	O
REDIR_ERR	int
]	O
=	O
open_redirector	function
(	O
hp	pointer
->	O
command	pointer
,	O
LOG_ERR	int
,	O
&	O
redir_proc	array
[	O
REDIR_ERR	int
]	O
)	O
;	O
if	O
(	O
hp	pointer
->	O
flags	int
&	O
HF_STDOUT	int
)	O
redir_fd	array
[	O
REDIR_OUT	int
]	O
=	O
open_redirector	function
(	O
hp	pointer
->	O
command	pointer
,	O
LOG_INFO	int
,	O
&	O
redir_proc	array
[	O
REDIR_OUT	int
]	O
)	O
;	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
==	O
-	O
1	int
)	O
{	O
diag	function
(	O
LOG_ERR	int
,	O
"fork: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
close	function
(	O
redir_fd	array
[	O
REDIR_OUT	int
]	O
)	O
;	O
close	function
(	O
redir_fd	array
[	O
REDIR_ERR	int
]	O
)	O
;	O
if	O
(	O
redir_proc	array
[	O
REDIR_OUT	int
]	O
)	O
kill	function
(	O
redir_proc	array
[	O
REDIR_OUT	int
]	O
->	O
pid	int
,	O
SIGKILL	int
)	O
;	O
if	O
(	O
redir_proc	array
[	O
REDIR_ERR	int
]	O
)	O
kill	function
(	O
redir_proc	array
[	O
REDIR_ERR	int
]	O
->	O
pid	int
,	O
SIGKILL	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
bigfd_set	pointer
fdset	pointer
=	O
BIGFD_SET_ALLOC	O
(	O
)	O
;	O
if	O
(	O
switchpriv	function
(	O
hp	pointer
)	O
)	O
_exit	function
(	O
127	int
)	O
;	O
if	O
(	O
chdir	function
(	O
dirname	pointer
)	O
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
_	O
(	O
"cannot change to %s: %s"	pointer
)	O
,	O
dirname	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
_exit	function
(	O
127	int
)	O
;	O
}	O
if	O
(	O
redir_fd	array
[	O
REDIR_OUT	int
]	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
redir_fd	array
[	O
REDIR_OUT	int
]	O
!=	O
1	int
&&	O
dup2	function
(	O
redir_fd	array
[	O
REDIR_OUT	int
]	O
,	O
1	int
)	O
==	O
-	O
1	int
)	O
{	O
diag	function
(	O
LOG_ERR	int
,	O
"dup2: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
_exit	function
(	O
127	int
)	O
;	O
}	O
BIGFD_SET	O
(	O
1	int
,	O
fdset	pointer
)	O
;	O
}	O
if	O
(	O
redir_fd	array
[	O
REDIR_ERR	int
]	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
redir_fd	array
[	O
REDIR_ERR	int
]	O
!=	O
2	int
&&	O
dup2	function
(	O
redir_fd	array
[	O
REDIR_ERR	int
]	O
,	O
2	int
)	O
==	O
-	O
1	int
)	O
{	O
diag	function
(	O
LOG_ERR	int
,	O
"dup2: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
_exit	function
(	O
127	int
)	O
;	O
}	O
BIGFD_SET	O
(	O
2	int
,	O
fdset	pointer
)	O
;	O
}	O
close_fds	function
(	O
fdset	pointer
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
signal_setup	function
(	O
SIG_DFL	O
)	O
;	O
runcmd	function
(	O
hp	pointer
->	O
command	pointer
,	O
hp	pointer
->	O
env	pointer
,	O
event	pointer
,	O
file	pointer
,	O
hp	pointer
->	O
flags	int
&	O
HF_SHELL	int
)	O
;	O
}	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"%s running; dir=%s, file=%s, pid=%lu"	pointer
)	O
,	O
hp	pointer
->	O
command	pointer
,	O
dirname	pointer
,	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
)	O
;	O
p	pointer
=	O
register_process	function
(	O
PROC_HANDLER	int
,	O
pid	int
,	O
time	function
(	O
NULL	O
)	O
,	O
hp	pointer
->	O
timeout	int
)	O
;	O
if	O
(	O
redir_proc	array
[	O
REDIR_OUT	int
]	O
)	O
{	O
redir_proc	array
[	O
REDIR_OUT	int
]	O
->	O
v	union
.	O
master	pointer
=	O
p	pointer
;	O
redir_proc	array
[	O
REDIR_OUT	int
]	O
->	O
timeout	int
=	O
hp	pointer
->	O
timeout	int
;	O
}	O
if	O
(	O
redir_proc	array
[	O
REDIR_ERR	int
]	O
)	O
{	O
redir_proc	array
[	O
REDIR_ERR	int
]	O
->	O
v	union
.	O
master	pointer
=	O
p	pointer
;	O
redir_proc	array
[	O
REDIR_ERR	int
]	O
->	O
timeout	int
=	O
hp	pointer
->	O
timeout	int
;	O
}	O
memcpy	function
(	O
p	pointer
->	O
v	union
.	O
redir	array
,	O
redir_proc	array
,	O
sizeof	O
(	O
p	pointer
->	O
v	union
.	O
redir	array
)	O
)	O
;	O
close	function
(	O
redir_fd	array
[	O
REDIR_OUT	int
]	O
)	O
;	O
close	function
(	O
redir_fd	array
[	O
REDIR_ERR	int
]	O
)	O
;	O
if	O
(	O
hp	pointer
->	O
flags	int
&	O
HF_NOWAIT	int
)	O
{	O
return	O
0	int
;	O
}	O
debug	O
(	O
1	int
,	O
(	O
_	O
(	O
"waiting for %s (%lu) to terminate"	pointer
)	O
,	O
hp	pointer
->	O
command	pointer
,	O
(	O
unsigned	O
long	O
)	O
pid	int
)	O
)	O
;	O
while	O
(	O
time	function
(	O
NULL	O
)	O
-	O
p	pointer
->	O
start	long
<	O
2	int
*	O
p	pointer
->	O
timeout	int
)	O
{	O
sleep	function
(	O
1	int
)	O
;	O
process_cleanup	function
(	O
1	int
)	O
;	O
if	O
(	O
p	pointer
->	O
pid	int
==	O
0	int
)	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
envfree	function
(	O
char	O
*	O
*	O
env	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
env	pointer
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
env	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
free	function
(	O
env	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
env	pointer
)	O
;	O
}	O
void	O
prog_handler_free	function
(	O
struct	O
prog_handler	struct
*	O
hp	pointer
)	O
{	O
free	function
(	O
hp	pointer
->	O
command	pointer
)	O
;	O
free	function
(	O
hp	pointer
->	O
gidv	pointer
)	O
;	O
envfree	function
(	O
hp	pointer
->	O
env	pointer
)	O
;	O
}	O
static	O
void	O
prog_handler_free_data	function
(	O
void	O
*	O
ptr	pointer
)	O
{	O
prog_handler_free	function
(	O
(	O
struct	O
prog_handler	struct
*	O
)	O
ptr	pointer
)	O
;	O
}	O
struct	O
handler	struct
*	O
prog_handler_alloc	function
(	O
event_mask	struct
ev_mask	struct
,	O
filpatlist_t	pointer
fpat	pointer
,	O
struct	O
prog_handler	struct
*	O
p	pointer
)	O
{	O
struct	O
handler	struct
*	O
hp	pointer
=	O
handler_alloc	function
(	O
ev_mask	struct
)	O
;	O
struct	O
prog_handler	struct
*	O
mem	pointer
;	O
hp	pointer
->	O
fnames	pointer
=	O
fpat	pointer
;	O
hp	pointer
->	O
run	pointer
=	O
prog_handler_run	function
;	O
hp	pointer
->	O
free	function
=	O
prog_handler_free_data	function
;	O
mem	pointer
=	O
emalloc	function
(	O
sizeof	O
(	O
*	O
mem	pointer
)	O
)	O
;	O
*	O
mem	pointer
=	O
*	O
p	pointer
;	O
hp	pointer
->	O
data	pointer
=	O
mem	pointer
;	O
memset	function
(	O
p	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
return	O
hp	pointer
;	O
}	O
size_t	long
prog_handler_envrealloc	function
(	O
struct	O
prog_handler	struct
*	O
hp	pointer
,	O
size_t	long
count	long
)	O
{	O
size_t	long
i	int
;	O
if	O
(	O
!	O
hp	pointer
->	O
env	pointer
)	O
{	O
hp	pointer
->	O
env	pointer
=	O
ecalloc	function
(	O
count	long
+	O
1	int
,	O
sizeof	O
(	O
hp	pointer
->	O
env	pointer
[	O
0	int
]	O
)	O
)	O
;	O
i	int
=	O
0	int
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
hp	pointer
->	O
env	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
hp	pointer
->	O
env	pointer
=	O
erealloc	function
(	O
hp	pointer
->	O
env	pointer
,	O
(	O
i	int
+	O
count	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
hp	pointer
->	O
env	pointer
[	O
0	int
]	O
)	O
)	O
;	O
memset	function
(	O
hp	pointer
->	O
env	pointer
+	O
i	int
,	O
0	int
,	O
(	O
count	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
hp	pointer
->	O
env	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
return	O
i	int
;	O
}	O
