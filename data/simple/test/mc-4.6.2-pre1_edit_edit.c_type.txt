int	O
edit_key_emulation	int
=	O
EDIT_KEY_EMULATION_NORMAL	int
;	O
int	O
option_word_wrap_line_length	int
=	O
72	int
;	O
int	O
option_typewriter_wrap	int
=	O
0	int
;	O
int	O
option_auto_para_formatting	int
=	O
0	int
;	O
int	O
option_tab_spacing	int
=	O
8	int
;	O
int	O
option_fill_tabs_with_spaces	int
=	O
0	int
;	O
int	O
option_return_does_auto_indent	int
=	O
1	int
;	O
int	O
option_backspace_through_tabs	int
=	O
0	int
;	O
int	O
option_fake_half_tabs	int
=	O
1	int
;	O
int	O
option_save_mode	int
=	O
EDIT_QUICK_SAVE	int
;	O
int	O
option_save_position	int
=	O
1	int
;	O
int	O
option_max_undo	int
=	O
32768	int
;	O
int	O
option_edit_right_extreme	int
=	O
0	int
;	O
int	O
option_edit_left_extreme	int
=	O
0	int
;	O
int	O
option_edit_top_extreme	int
=	O
0	int
;	O
int	O
option_edit_bottom_extreme	int
=	O
0	int
;	O
const	O
char	O
*	O
option_whole_chars_search	pointer
=	O
"0123456789abcdefghijklmnopqrstuvwxyz_"	pointer
;	O
char	O
*	O
option_backup_ext	pointer
=	O
NULL	O
;	O
static	O
void	O
user_menu	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
;	O
int	O
edit_get_byte	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
byte_index	long
)	O
{	O
unsigned	O
long	O
p	pointer
;	O
if	O
(	O
byte_index	long
>=	O
(	O
edit	pointer
->	O
curs1	long
+	O
edit	pointer
->	O
curs2	long
)	O
||	O
byte_index	long
<	O
0	int
)	O
return	O
'\n'	O
;	O
if	O
(	O
byte_index	long
>=	O
edit	pointer
->	O
curs1	long
)	O
{	O
p	pointer
=	O
edit	pointer
->	O
curs1	long
+	O
edit	pointer
->	O
curs2	long
-	O
byte_index	long
-	O
1	int
;	O
return	O
edit	pointer
->	O
buffers2	array
[	O
p	pointer
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
EDIT_BUF_SIZE	O
-	O
(	O
p	pointer
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
]	O
;	O
}	O
else	O
{	O
return	O
edit	pointer
->	O
buffers1	array
[	O
byte_index	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
byte_index	long
&	O
M_EDIT_BUF_SIZE	O
]	O
;	O
}	O
}	O
static	O
void	O
edit_init_buffers	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
MAXBUFF	int
;	O
j	int
++	O
)	O
{	O
edit	pointer
->	O
buffers1	array
[	O
j	int
]	O
=	O
NULL	O
;	O
edit	pointer
->	O
buffers2	array
[	O
j	int
]	O
=	O
NULL	O
;	O
}	O
edit	pointer
->	O
curs1	long
=	O
0	int
;	O
edit	pointer
->	O
curs2	long
=	O
0	int
;	O
edit	pointer
->	O
buffers2	array
[	O
0	int
]	O
=	O
g_malloc	function
(	O
EDIT_BUF_SIZE	O
)	O
;	O
}	O
static	O
int	O
edit_load_file_fast	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
long	O
buf	pointer
,	O
buf2	long
;	O
int	O
file	pointer
=	O
-	O
1	int
;	O
edit	pointer
->	O
curs2	long
=	O
edit	pointer
->	O
last_byte	long
;	O
buf2	long
=	O
edit	pointer
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
;	O
if	O
(	O
(	O
file	pointer
=	O
mc_open	function
(	O
filename	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
GString	struct
*	O
errmsg	pointer
=	O
g_string_new	function
(	O
NULL	O
)	O
;	O
g_string_sprintf	O
(	O
errmsg	pointer
,	O
_	O
(	O
" Cannot open %s for reading "	pointer
)	O
,	O
filename	pointer
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	pointer
)	O
,	O
get_sys_error	O
(	O
errmsg	pointer
->	O
str	pointer
)	O
)	O
;	O
g_string_free	function
(	O
errmsg	pointer
,	O
TRUE	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
edit	pointer
->	O
buffers2	array
[	O
buf2	long
]	O
)	O
edit	pointer
->	O
buffers2	array
[	O
buf2	long
]	O
=	O
g_malloc	function
(	O
EDIT_BUF_SIZE	O
)	O
;	O
mc_read	function
(	O
file	pointer
,	O
(	O
char	O
*	O
)	O
edit	pointer
->	O
buffers2	array
[	O
buf2	long
]	O
+	O
EDIT_BUF_SIZE	O
-	O
(	O
edit	pointer
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
,	O
edit	pointer
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
;	O
for	O
(	O
buf	pointer
=	O
buf2	long
-	O
1	int
;	O
buf	pointer
>=	O
0	int
;	O
buf	pointer
--	O
)	O
{	O
if	O
(	O
!	O
edit	pointer
->	O
buffers2	array
[	O
buf	pointer
]	O
)	O
edit	pointer
->	O
buffers2	array
[	O
buf	pointer
]	O
=	O
g_malloc	function
(	O
EDIT_BUF_SIZE	O
)	O
;	O
mc_read	function
(	O
file	pointer
,	O
(	O
char	O
*	O
)	O
edit	pointer
->	O
buffers2	array
[	O
buf	pointer
]	O
,	O
EDIT_BUF_SIZE	O
)	O
;	O
}	O
mc_close	function
(	O
file	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
const	O
struct	O
edit_filters	struct
{	O
const	O
char	O
*	O
read	pointer
,	O
*	O
write	pointer
,	O
*	O
extension	function
;	O
}	O
all_filters	array
[	O
]	O
=	O
{	O
{	O
"bzip2 -cd %s 2>&1"	pointer
,	O
"bzip2 > %s"	pointer
,	O
".bz2"	pointer
}	O
,	O
{	O
"gzip -cd %s 2>&1"	pointer
,	O
"gzip > %s"	pointer
,	O
".gz"	pointer
}	O
,	O
{	O
"gzip -cd %s 2>&1"	pointer
,	O
"gzip > %s"	pointer
,	O
".Z"	pointer
}	O
}	O
;	O
static	O
int	O
edit_find_filter	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
size_t	long
i	array
,	O
l	pointer
,	O
e	pointer
;	O
if	O
(	O
!	O
filename	pointer
)	O
return	O
-	O
1	int
;	O
l	pointer
=	O
strlen	function
(	O
filename	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
sizeof	O
(	O
all_filters	array
)	O
/	O
sizeof	O
(	O
all_filters	array
[	O
0	int
]	O
)	O
;	O
i	array
++	O
)	O
{	O
e	pointer
=	O
strlen	function
(	O
all_filters	array
[	O
i	array
]	O
.	O
extension	function
)	O
;	O
if	O
(	O
l	pointer
>	O
e	pointer
)	O
if	O
(	O
!	O
strcmp	function
(	O
all_filters	array
[	O
i	array
]	O
.	O
extension	function
,	O
filename	pointer
+	O
l	pointer
-	O
e	pointer
)	O
)	O
return	O
i	array
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
char	O
*	O
edit_get_filter	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
int	O
i	array
,	O
l	pointer
;	O
char	O
*	O
p	pointer
,	O
*	O
quoted_name	pointer
;	O
i	array
=	O
edit_find_filter	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
i	array
<	O
0	int
)	O
return	O
0	int
;	O
quoted_name	pointer
=	O
name_quote	function
(	O
filename	pointer
,	O
0	int
)	O
;	O
l	pointer
=	O
strlen	function
(	O
quoted_name	pointer
)	O
;	O
p	pointer
=	O
g_malloc	function
(	O
strlen	function
(	O
all_filters	array
[	O
i	array
]	O
.	O
read	pointer
)	O
+	O
l	pointer
+	O
2	int
)	O
;	O
sprintf	function
(	O
p	pointer
,	O
all_filters	array
[	O
i	array
]	O
.	O
read	pointer
,	O
quoted_name	pointer
)	O
;	O
g_free	function
(	O
quoted_name	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
char	O
*	O
edit_get_write_filter	function
(	O
const	O
char	O
*	O
write_name	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
int	O
i	array
,	O
l	pointer
;	O
char	O
*	O
p	pointer
,	O
*	O
writename	pointer
;	O
i	array
=	O
edit_find_filter	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
i	array
<	O
0	int
)	O
return	O
0	int
;	O
writename	pointer
=	O
name_quote	function
(	O
write_name	pointer
,	O
0	int
)	O
;	O
l	pointer
=	O
strlen	function
(	O
writename	pointer
)	O
;	O
p	pointer
=	O
g_malloc	function
(	O
strlen	function
(	O
all_filters	array
[	O
i	array
]	O
.	O
write	pointer
)	O
+	O
l	pointer
+	O
2	int
)	O
;	O
sprintf	function
(	O
p	pointer
,	O
all_filters	array
[	O
i	array
]	O
.	O
write	pointer
,	O
writename	pointer
)	O
;	O
g_free	function
(	O
writename	pointer
)	O
;	O
return	O
p	pointer
;	O
}	O
static	O
long	O
edit_insert_stream	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
FILE	struct
*	O
f	pointer
)	O
{	O
int	O
c	int
;	O
long	O
i	array
=	O
0	int
;	O
while	O
(	O
(	O
c	int
=	O
fgetc	function
(	O
f	pointer
)	O
)	O
>=	O
0	int
)	O
{	O
edit_insert	function
(	O
edit	pointer
,	O
c	int
)	O
;	O
i	array
++	O
;	O
}	O
return	O
i	array
;	O
}	O
long	O
edit_write_stream	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
FILE	struct
*	O
f	pointer
)	O
{	O
long	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
edit	pointer
->	O
last_byte	long
;	O
i	array
++	O
)	O
if	O
(	O
fputc	function
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
i	array
)	O
,	O
f	pointer
)	O
<	O
0	int
)	O
break	O
;	O
return	O
i	array
;	O
}	O
int	O
edit_insert_file	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
edit_get_filter	function
(	O
filename	pointer
)	O
)	O
)	O
{	O
FILE	struct
*	O
f	pointer
;	O
long	O
current	long
=	O
edit	pointer
->	O
curs1	long
;	O
f	pointer
=	O
(	O
FILE	struct
*	O
)	O
popen	function
(	O
p	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
f	pointer
)	O
{	O
edit_insert_stream	function
(	O
edit	pointer
,	O
f	pointer
)	O
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
current	long
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
if	O
(	O
pclose	function
(	O
f	pointer
)	O
>	O
0	int
)	O
{	O
GString	struct
*	O
errmsg	pointer
=	O
g_string_new	function
(	O
NULL	O
)	O
;	O
g_string_sprintf	O
(	O
errmsg	pointer
,	O
_	O
(	O
" Error reading from pipe: %s "	pointer
)	O
,	O
p	pointer
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	pointer
)	O
,	O
errmsg	pointer
->	O
str	pointer
)	O
;	O
g_string_free	function
(	O
errmsg	pointer
,	O
TRUE	O
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
GString	struct
*	O
errmsg	pointer
=	O
g_string_new	function
(	O
NULL	O
)	O
;	O
g_string_sprintf	O
(	O
errmsg	pointer
,	O
_	O
(	O
" Cannot open pipe for reading: %s "	pointer
)	O
,	O
p	pointer
)	O
;	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	pointer
)	O
,	O
errmsg	pointer
->	O
str	pointer
)	O
;	O
g_string_free	function
(	O
errmsg	pointer
,	O
TRUE	O
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
return	O
0	int
;	O
}	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
else	O
{	O
int	O
i	array
,	O
file	pointer
,	O
blocklen	int
;	O
long	O
current	long
=	O
edit	pointer
->	O
curs1	long
;	O
unsigned	O
char	O
*	O
buf	pointer
;	O
if	O
(	O
(	O
file	pointer
=	O
mc_open	function
(	O
filename	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
==	O
-	O
1	int
)	O
return	O
0	int
;	O
buf	pointer
=	O
g_malloc	function
(	O
TEMP_BUF_LEN	int
)	O
;	O
while	O
(	O
(	O
blocklen	int
=	O
mc_read	function
(	O
file	pointer
,	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
TEMP_BUF_LEN	int
)	O
)	O
>	O
0	int
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
blocklen	int
;	O
i	array
++	O
)	O
edit_insert	function
(	O
edit	pointer
,	O
buf	pointer
[	O
i	array
]	O
)	O
;	O
}	O
edit_cursor_move	function
(	O
edit	pointer
,	O
current	long
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
g_free	function
(	O
buf	pointer
)	O
;	O
mc_close	function
(	O
file	pointer
)	O
;	O
if	O
(	O
blocklen	int
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
check_file_access	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
int	O
file	pointer
;	O
GString	struct
*	O
errmsg	pointer
=	O
(	O
GString	struct
*	O
)	O
0	int
;	O
file	pointer
=	O
mc_open	function
(	O
filename	pointer
,	O
O_NONBLOCK	int
|	O
O_RDONLY	int
|	O
O_BINARY	int
,	O
0666	int
)	O
;	O
if	O
(	O
file	pointer
<	O
0	int
)	O
{	O
file	pointer
=	O
mc_open	function
(	O
filename	pointer
,	O
O_NONBLOCK	int
|	O
O_RDONLY	int
|	O
O_BINARY	int
|	O
O_CREAT	int
|	O
O_EXCL	int
,	O
0666	int
)	O
;	O
if	O
(	O
file	pointer
<	O
0	int
)	O
{	O
g_string_sprintf	O
(	O
errmsg	pointer
=	O
g_string_new	function
(	O
NULL	O
)	O
,	O
_	O
(	O
" Cannot open %s for reading "	pointer
)	O
,	O
filename	pointer
)	O
;	O
goto	O
cleanup	O
;	O
}	O
else	O
{	O
edit	pointer
->	O
delete_file	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
mc_fstat	function
(	O
file	pointer
,	O
st	pointer
)	O
<	O
0	int
)	O
{	O
g_string_sprintf	O
(	O
errmsg	pointer
=	O
g_string_new	function
(	O
NULL	O
)	O
,	O
_	O
(	O
" Cannot get size/permissions for %s "	pointer
)	O
,	O
filename	pointer
)	O
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
!	O
S_ISREG	O
(	O
st	pointer
->	O
st_mode	int
)	O
)	O
{	O
g_string_sprintf	O
(	O
errmsg	pointer
=	O
g_string_new	function
(	O
NULL	O
)	O
,	O
_	O
(	O
" %s is not a regular file "	pointer
)	O
,	O
filename	pointer
)	O
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
st	pointer
->	O
st_size	long
>	O
0	int
)	O
{	O
edit	pointer
->	O
delete_file	int
=	O
0	int
;	O
}	O
if	O
(	O
st	pointer
->	O
st_size	long
>=	O
SIZE_LIMIT	O
)	O
{	O
g_string_sprintf	O
(	O
errmsg	pointer
=	O
g_string_new	function
(	O
NULL	O
)	O
,	O
_	O
(	O
" File %s is too large "	pointer
)	O
,	O
filename	pointer
)	O
;	O
goto	O
cleanup	O
;	O
}	O
cleanup	O
:	O
(	O
void	O
)	O
mc_close	function
(	O
file	pointer
)	O
;	O
if	O
(	O
errmsg	pointer
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	pointer
)	O
,	O
errmsg	pointer
->	O
str	pointer
)	O
;	O
g_string_free	function
(	O
errmsg	pointer
,	O
TRUE	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
edit_load_file	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
fast_load	int
=	O
1	int
;	O
if	O
(	O
edit_find_filter	function
(	O
edit	pointer
->	O
filename	pointer
)	O
>=	O
0	int
)	O
fast_load	int
=	O
0	int
;	O
if	O
(	O
!	O
vfs_file_is_local	function
(	O
edit	pointer
->	O
filename	pointer
)	O
)	O
fast_load	int
=	O
0	int
;	O
if	O
(	O
*	O
edit	pointer
->	O
filename	pointer
)	O
{	O
if	O
(	O
check_file_access	function
(	O
edit	pointer
,	O
edit	pointer
->	O
filename	pointer
,	O
&	O
edit	pointer
->	O
stat1	struct
)	O
)	O
return	O
1	int
;	O
}	O
else	O
{	O
fast_load	int
=	O
0	int
;	O
}	O
edit_init_buffers	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
fast_load	int
)	O
{	O
edit	pointer
->	O
last_byte	long
=	O
edit	pointer
->	O
stat1	struct
.	O
st_size	long
;	O
edit_load_file_fast	function
(	O
edit	pointer
,	O
edit	pointer
->	O
filename	pointer
)	O
;	O
edit	pointer
->	O
total_lines	long
=	O
edit_count_lines	function
(	O
edit	pointer
,	O
0	int
,	O
edit	pointer
->	O
last_byte	long
)	O
;	O
}	O
else	O
{	O
edit	pointer
->	O
last_byte	long
=	O
0	int
;	O
if	O
(	O
*	O
edit	pointer
->	O
filename	pointer
)	O
{	O
edit	pointer
->	O
stack_disable	int
=	O
1	int
;	O
if	O
(	O
!	O
edit_insert_file	function
(	O
edit	pointer
,	O
edit	pointer
->	O
filename	pointer
)	O
)	O
{	O
edit_clean	function
(	O
edit	pointer
)	O
;	O
return	O
1	int
;	O
}	O
edit	pointer
->	O
stack_disable	int
=	O
0	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
edit_load_position	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
char	O
*	O
filename	pointer
;	O
long	O
line	int
,	O
column	pointer
;	O
if	O
(	O
!	O
edit	pointer
->	O
filename	pointer
||	O
!	O
*	O
edit	pointer
->	O
filename	pointer
)	O
return	O
;	O
filename	pointer
=	O
vfs_canon	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
load_file_position	function
(	O
filename	pointer
,	O
&	O
line	int
,	O
&	O
column	pointer
)	O
;	O
g_free	function
(	O
filename	pointer
)	O
;	O
edit_move_to_line	function
(	O
edit	pointer
,	O
line	int
-	O
1	int
)	O
;	O
edit	pointer
->	O
prev_col	long
=	O
column	pointer
;	O
edit_move_to_prev_col	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
)	O
;	O
edit_move_display	function
(	O
edit	pointer
,	O
line	int
-	O
(	O
edit	pointer
->	O
num_widget_lines	int
/	O
2	int
)	O
)	O
;	O
}	O
static	O
void	O
edit_save_position	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
!	O
edit	pointer
->	O
filename	pointer
||	O
!	O
*	O
edit	pointer
->	O
filename	pointer
)	O
return	O
;	O
filename	pointer
=	O
vfs_canon	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
save_file_position	function
(	O
filename	pointer
,	O
edit	pointer
->	O
curs_line	long
+	O
1	int
,	O
edit	pointer
->	O
curs_col	long
)	O
;	O
g_free	function
(	O
filename	pointer
)	O
;	O
}	O
static	O
inline	O
void	O
edit_purge_widget	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
len	int
=	O
sizeof	O
(	O
WEdit	struct
)	O
-	O
sizeof	O
(	O
Widget	struct
)	O
;	O
char	O
*	O
start	pointer
=	O
(	O
char	O
*	O
)	O
edit	pointer
+	O
sizeof	O
(	O
Widget	struct
)	O
;	O
memset	function
(	O
start	pointer
,	O
0	int
,	O
len	int
)	O
;	O
edit	pointer
->	O
macro_i	int
=	O
-	O
1	int
;	O
}	O
WEdit	struct
*	O
edit_init	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
lines	pointer
,	O
int	O
columns	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
long	O
line	int
)	O
{	O
int	O
to_free	int
=	O
0	int
;	O
option_auto_syntax	int
=	O
1	int
;	O
if	O
(	O
!	O
edit	pointer
)	O
{	O
static	O
char	O
option_whole_chars_search_buf	array
[	O
256	int
]	O
;	O
if	O
(	O
option_whole_chars_search_buf	array
!=	O
option_whole_chars_search	pointer
)	O
{	O
size_t	long
i	array
;	O
size_t	long
len	int
=	O
strlen	function
(	O
option_whole_chars_search	pointer
)	O
;	O
strcpy	function
(	O
option_whole_chars_search_buf	array
,	O
option_whole_chars_search	pointer
)	O
;	O
for	O
(	O
i	array
=	O
1	int
;	O
i	array
<=	O
sizeof	O
(	O
option_whole_chars_search_buf	array
)	O
;	O
i	array
++	O
)	O
{	O
if	O
(	O
islower	function
(	O
i	array
)	O
&&	O
!	O
strchr	function
(	O
option_whole_chars_search	pointer
,	O
i	array
)	O
)	O
{	O
option_whole_chars_search_buf	array
[	O
len	int
++	O
]	O
=	O
i	array
;	O
}	O
}	O
option_whole_chars_search_buf	array
[	O
len	int
]	O
=	O
0	int
;	O
option_whole_chars_search	pointer
=	O
option_whole_chars_search_buf	array
;	O
}	O
edit	pointer
=	O
g_malloc0	function
(	O
sizeof	O
(	O
WEdit	struct
)	O
)	O
;	O
to_free	int
=	O
1	int
;	O
}	O
edit_purge_widget	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
num_widget_lines	int
=	O
lines	pointer
;	O
edit	pointer
->	O
num_widget_columns	int
=	O
columns	pointer
;	O
edit	pointer
->	O
stat1	struct
.	O
st_mode	int
=	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IRGRP	O
|	O
S_IROTH	O
;	O
edit	pointer
->	O
stat1	struct
.	O
st_uid	int
=	O
getuid	function
(	O
)	O
;	O
edit	pointer
->	O
stat1	struct
.	O
st_gid	int
=	O
getgid	function
(	O
)	O
;	O
edit	pointer
->	O
stat1	struct
.	O
st_mtime	O
=	O
0	int
;	O
edit	pointer
->	O
bracket	long
=	O
-	O
1	int
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit_set_filename	function
(	O
edit	pointer
,	O
filename	pointer
)	O
;	O
edit	pointer
->	O
stack_size	long
=	O
START_STACK_SIZE	int
;	O
edit	pointer
->	O
stack_size_mask	long
=	O
START_STACK_SIZE	int
-	O
1	int
;	O
edit	pointer
->	O
undo_stack	pointer
=	O
g_malloc	function
(	O
(	O
edit	pointer
->	O
stack_size	long
+	O
10	int
)	O
*	O
sizeof	O
(	O
long	O
)	O
)	O
;	O
if	O
(	O
edit_load_file	function
(	O
edit	pointer
)	O
)	O
{	O
if	O
(	O
to_free	int
)	O
g_free	function
(	O
edit	pointer
)	O
;	O
return	O
0	int
;	O
}	O
edit	pointer
->	O
loading_done	int
=	O
1	int
;	O
edit	pointer
->	O
modified	long
=	O
0	int
;	O
edit	pointer
->	O
locked	int
=	O
0	int
;	O
edit_load_syntax	function
(	O
edit	pointer
,	O
0	int
,	O
0	int
)	O
;	O
{	O
int	O
color	pointer
;	O
edit_get_syntax_color	function
(	O
edit	pointer
,	O
-	O
1	int
,	O
&	O
color	pointer
)	O
;	O
}	O
if	O
(	O
(	O
line	int
==	O
0	int
)	O
&&	O
option_save_position	int
)	O
{	O
edit_load_position	function
(	O
edit	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
line	int
<=	O
0	int
)	O
line	int
=	O
1	int
;	O
edit_move_display	function
(	O
edit	pointer
,	O
line	int
-	O
1	int
)	O
;	O
edit_move_to_line	function
(	O
edit	pointer
,	O
line	int
-	O
1	int
)	O
;	O
}	O
edit_load_user_map	function
(	O
edit	pointer
)	O
;	O
return	O
edit	pointer
;	O
}	O
int	O
edit_clean	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
j	int
=	O
0	int
;	O
if	O
(	O
!	O
edit	pointer
)	O
return	O
0	int
;	O
if	O
(	O
edit	pointer
->	O
locked	int
)	O
edit	pointer
->	O
locked	int
=	O
edit_unlock_file	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
option_save_position	int
)	O
edit_save_position	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
edit	pointer
->	O
delete_file	int
)	O
unlink	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
edit_free_syntax_rules	function
(	O
edit	pointer
)	O
;	O
book_mark_flush	function
(	O
edit	pointer
,	O
-	O
1	int
)	O
;	O
for	O
(	O
;	O
j	int
<=	O
MAXBUFF	int
;	O
j	int
++	O
)	O
{	O
g_free	function
(	O
edit	pointer
->	O
buffers1	array
[	O
j	int
]	O
)	O
;	O
g_free	function
(	O
edit	pointer
->	O
buffers2	array
[	O
j	int
]	O
)	O
;	O
}	O
g_free	function
(	O
edit	pointer
->	O
undo_stack	pointer
)	O
;	O
g_free	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
g_free	function
(	O
edit	pointer
->	O
dir	pointer
)	O
;	O
edit_purge_widget	function
(	O
edit	pointer
)	O
;	O
freestrs	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
int	O
edit_renew	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
lines	pointer
=	O
edit	pointer
->	O
num_widget_lines	int
;	O
int	O
columns	pointer
=	O
edit	pointer
->	O
num_widget_columns	int
;	O
int	O
retval	pointer
=	O
1	int
;	O
edit_clean	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
!	O
edit_init	function
(	O
edit	pointer
,	O
lines	pointer
,	O
columns	pointer
,	O
""	pointer
,	O
0	int
)	O
)	O
retval	pointer
=	O
0	int
;	O
return	O
retval	pointer
;	O
}	O
int	O
edit_reload	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
WEdit	struct
*	O
e	pointer
;	O
int	O
lines	pointer
=	O
edit	pointer
->	O
num_widget_lines	int
;	O
int	O
columns	pointer
=	O
edit	pointer
->	O
num_widget_columns	int
;	O
e	pointer
=	O
g_malloc0	function
(	O
sizeof	O
(	O
WEdit	struct
)	O
)	O
;	O
e	pointer
->	O
widget	pointer
=	O
edit	pointer
->	O
widget	pointer
;	O
if	O
(	O
!	O
edit_init	function
(	O
e	pointer
,	O
lines	pointer
,	O
columns	pointer
,	O
filename	pointer
,	O
0	int
)	O
)	O
{	O
g_free	function
(	O
e	pointer
)	O
;	O
return	O
0	int
;	O
}	O
edit_clean	function
(	O
edit	pointer
)	O
;	O
memcpy	function
(	O
edit	pointer
,	O
e	pointer
,	O
sizeof	O
(	O
WEdit	struct
)	O
)	O
;	O
g_free	function
(	O
e	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
edit_push_action	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
c	int
,	O
...	O
)	O
{	O
unsigned	O
long	O
sp	long
=	O
edit	pointer
->	O
stack_pointer	long
;	O
unsigned	O
long	O
spm1	long
;	O
long	O
*	O
t	long
;	O
if	O
(	O
sp	long
>	O
edit	pointer
->	O
stack_size	long
-	O
10	int
)	O
{	O
if	O
(	O
option_max_undo	int
<	O
256	int
)	O
option_max_undo	int
=	O
256	int
;	O
if	O
(	O
edit	pointer
->	O
stack_size	long
<	O
(	O
unsigned	O
long	O
)	O
option_max_undo	int
)	O
{	O
t	long
=	O
g_realloc	function
(	O
edit	pointer
->	O
undo_stack	pointer
,	O
(	O
edit	pointer
->	O
stack_size	long
*	O
2	int
+	O
10	int
)	O
*	O
sizeof	O
(	O
long	O
)	O
)	O
;	O
if	O
(	O
t	long
)	O
{	O
edit	pointer
->	O
undo_stack	pointer
=	O
t	long
;	O
edit	pointer
->	O
stack_size	long
<<=	O
1	int
;	O
edit	pointer
->	O
stack_size_mask	long
=	O
edit	pointer
->	O
stack_size	long
-	O
1	int
;	O
}	O
}	O
}	O
spm1	long
=	O
(	O
edit	pointer
->	O
stack_pointer	long
-	O
1	int
)	O
&	O
edit	pointer
->	O
stack_size_mask	long
;	O
if	O
(	O
edit	pointer
->	O
stack_disable	int
)	O
return	O
;	O
if	O
(	O
edit	pointer
->	O
stack_bottom	long
!=	O
sp	long
&&	O
spm1	long
!=	O
edit	pointer
->	O
stack_bottom	long
&&	O
(	O
(	O
sp	long
-	O
2	int
)	O
&	O
edit	pointer
->	O
stack_size_mask	long
)	O
!=	O
edit	pointer
->	O
stack_bottom	long
)	O
{	O
int	O
d	double
;	O
if	O
(	O
edit	pointer
->	O
undo_stack	pointer
[	O
spm1	long
]	O
<	O
0	int
)	O
{	O
d	double
=	O
edit	pointer
->	O
undo_stack	pointer
[	O
(	O
sp	long
-	O
2	int
)	O
&	O
edit	pointer
->	O
stack_size_mask	long
]	O
;	O
if	O
(	O
d	double
==	O
c	int
)	O
{	O
if	O
(	O
edit	pointer
->	O
undo_stack	pointer
[	O
spm1	long
]	O
>	O
-	O
1000000000	int
)	O
{	O
if	O
(	O
c	int
<	O
KEY_PRESS	int
)	O
edit	pointer
->	O
undo_stack	pointer
[	O
spm1	long
]	O
--	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
c	int
==	O
CURS_LEFT	int
&&	O
d	double
==	O
CURS_RIGHT	int
)	O
||	O
(	O
c	int
==	O
CURS_RIGHT	int
&&	O
d	double
==	O
CURS_LEFT	int
)	O
)	O
{	O
if	O
(	O
edit	pointer
->	O
undo_stack	pointer
[	O
spm1	long
]	O
==	O
-	O
2	int
)	O
edit	pointer
->	O
stack_pointer	long
=	O
spm1	long
;	O
else	O
edit	pointer
->	O
undo_stack	pointer
[	O
spm1	long
]	O
++	O
;	O
return	O
;	O
}	O
}	O
else	O
{	O
d	double
=	O
edit	pointer
->	O
undo_stack	pointer
[	O
spm1	long
]	O
;	O
if	O
(	O
d	double
==	O
c	int
)	O
{	O
if	O
(	O
c	int
>=	O
KEY_PRESS	int
)	O
return	O
;	O
edit	pointer
->	O
undo_stack	pointer
[	O
sp	long
]	O
=	O
-	O
2	int
;	O
goto	O
check_bottom	O
;	O
}	O
else	O
if	O
(	O
(	O
c	int
==	O
CURS_LEFT	int
&&	O
d	double
==	O
CURS_RIGHT	int
)	O
||	O
(	O
c	int
==	O
CURS_RIGHT	int
&&	O
d	double
==	O
CURS_LEFT	int
)	O
)	O
{	O
edit	pointer
->	O
stack_pointer	long
=	O
spm1	long
;	O
return	O
;	O
}	O
}	O
}	O
edit	pointer
->	O
undo_stack	pointer
[	O
sp	long
]	O
=	O
c	int
;	O
check_bottom	O
:	O
edit	pointer
->	O
stack_pointer	long
=	O
(	O
edit	pointer
->	O
stack_pointer	long
+	O
1	int
)	O
&	O
edit	pointer
->	O
stack_size_mask	long
;	O
c	int
=	O
(	O
edit	pointer
->	O
stack_pointer	long
+	O
2	int
)	O
&	O
edit	pointer
->	O
stack_size_mask	long
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
c	int
==	O
edit	pointer
->	O
stack_bottom	long
||	O
(	O
(	O
(	O
unsigned	O
long	O
)	O
c	int
+	O
1	int
)	O
&	O
edit	pointer
->	O
stack_size_mask	long
)	O
==	O
edit	pointer
->	O
stack_bottom	long
)	O
do	O
{	O
edit	pointer
->	O
stack_bottom	long
=	O
(	O
edit	pointer
->	O
stack_bottom	long
+	O
1	int
)	O
&	O
edit	pointer
->	O
stack_size_mask	long
;	O
}	O
while	O
(	O
edit	pointer
->	O
undo_stack	pointer
[	O
edit	pointer
->	O
stack_bottom	long
]	O
<	O
KEY_PRESS	int
&&	O
edit	pointer
->	O
stack_bottom	long
!=	O
edit	pointer
->	O
stack_pointer	long
)	O
;	O
if	O
(	O
edit	pointer
->	O
stack_pointer	long
!=	O
edit	pointer
->	O
stack_bottom	long
&&	O
edit	pointer
->	O
undo_stack	pointer
[	O
edit	pointer
->	O
stack_bottom	long
]	O
<	O
KEY_PRESS	int
)	O
edit	pointer
->	O
stack_bottom	long
=	O
edit	pointer
->	O
stack_pointer	long
=	O
0	int
;	O
}	O
static	O
long	O
pop_action	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
c	int
;	O
unsigned	O
long	O
sp	long
=	O
edit	pointer
->	O
stack_pointer	long
;	O
if	O
(	O
sp	long
==	O
edit	pointer
->	O
stack_bottom	long
)	O
{	O
return	O
STACK_BOTTOM	int
;	O
}	O
sp	long
=	O
(	O
sp	long
-	O
1	int
)	O
&	O
edit	pointer
->	O
stack_size_mask	long
;	O
if	O
(	O
(	O
c	int
=	O
edit	pointer
->	O
undo_stack	pointer
[	O
sp	long
]	O
)	O
>=	O
0	int
)	O
{	O
edit	pointer
->	O
stack_pointer	long
=	O
(	O
edit	pointer
->	O
stack_pointer	long
-	O
1	int
)	O
&	O
edit	pointer
->	O
stack_size_mask	long
;	O
return	O
c	int
;	O
}	O
if	O
(	O
sp	long
==	O
edit	pointer
->	O
stack_bottom	long
)	O
{	O
return	O
STACK_BOTTOM	int
;	O
}	O
c	int
=	O
edit	pointer
->	O
undo_stack	pointer
[	O
(	O
sp	long
-	O
1	int
)	O
&	O
edit	pointer
->	O
stack_size_mask	long
]	O
;	O
if	O
(	O
edit	pointer
->	O
undo_stack	pointer
[	O
sp	long
]	O
==	O
-	O
2	int
)	O
{	O
edit	pointer
->	O
stack_pointer	long
=	O
sp	long
;	O
}	O
else	O
edit	pointer
->	O
undo_stack	pointer
[	O
sp	long
]	O
++	O
;	O
return	O
c	int
;	O
}	O
static	O
inline	O
void	O
edit_modification	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit	pointer
->	O
caches_valid	int
=	O
0	int
;	O
edit	pointer
->	O
screen_modified	int
=	O
1	int
;	O
if	O
(	O
!	O
edit	pointer
->	O
modified	long
&&	O
!	O
edit	pointer
->	O
delete_file	int
)	O
edit	pointer
->	O
locked	int
=	O
edit_lock_file	function
(	O
edit	pointer
->	O
filename	pointer
)	O
;	O
edit	pointer
->	O
modified	long
=	O
1	int
;	O
}	O
void	O
edit_insert	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
c	int
)	O
{	O
if	O
(	O
edit	pointer
->	O
last_byte	long
>=	O
SIZE_LIMIT	O
)	O
return	O
;	O
if	O
(	O
edit	pointer
->	O
curs1	long
<	O
edit	pointer
->	O
start_display	long
)	O
{	O
edit	pointer
->	O
start_display	long
++	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
edit	pointer
->	O
start_line	long
++	O
;	O
}	O
if	O
(	O
edit	pointer
->	O
loading_done	int
)	O
{	O
edit_modification	function
(	O
edit	pointer
)	O
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
edit	pointer
->	O
book_mark	pointer
)	O
book_mark_inc	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
)	O
;	O
edit	pointer
->	O
curs_line	long
++	O
;	O
edit	pointer
->	O
total_lines	long
++	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_LINE_ABOVE	O
|	O
REDRAW_AFTER_CURSOR	O
;	O
}	O
edit_push_action	function
(	O
edit	pointer
,	O
BACKSPACE	int
)	O
;	O
edit	pointer
->	O
mark1	long
+=	O
(	O
edit	pointer
->	O
mark1	long
>	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
mark2	long
+=	O
(	O
edit	pointer
->	O
mark2	long
>	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
last_get_rule	long
+=	O
(	O
edit	pointer
->	O
last_get_rule	long
>	O
edit	pointer
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
(	O
edit	pointer
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
edit	pointer
->	O
buffers1	array
[	O
edit	pointer
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
g_malloc	function
(	O
EDIT_BUF_SIZE	O
)	O
;	O
edit	pointer
->	O
buffers1	array
[	O
edit	pointer
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
edit	pointer
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
]	O
=	O
(	O
unsigned	O
char	O
)	O
c	int
;	O
edit	pointer
->	O
last_byte	long
++	O
;	O
edit	pointer
->	O
curs1	long
++	O
;	O
}	O
void	O
edit_insert_ahead	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
c	int
)	O
{	O
if	O
(	O
edit	pointer
->	O
last_byte	long
>=	O
SIZE_LIMIT	O
)	O
return	O
;	O
if	O
(	O
edit	pointer
->	O
curs1	long
<	O
edit	pointer
->	O
start_display	long
)	O
{	O
edit	pointer
->	O
start_display	long
++	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
edit	pointer
->	O
start_line	long
++	O
;	O
}	O
edit_modification	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
edit	pointer
->	O
book_mark	pointer
)	O
book_mark_inc	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
)	O
;	O
edit	pointer
->	O
total_lines	long
++	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_AFTER_CURSOR	O
;	O
}	O
edit_push_action	function
(	O
edit	pointer
,	O
DELCHAR	int
)	O
;	O
edit	pointer
->	O
mark1	long
+=	O
(	O
edit	pointer
->	O
mark1	long
>=	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
mark2	long
+=	O
(	O
edit	pointer
->	O
mark2	long
>=	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
last_get_rule	long
+=	O
(	O
edit	pointer
->	O
last_get_rule	long
>=	O
edit	pointer
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
(	O
(	O
edit	pointer
->	O
curs2	long
+	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
edit	pointer
->	O
buffers2	array
[	O
(	O
edit	pointer
->	O
curs2	long
+	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
g_malloc	function
(	O
EDIT_BUF_SIZE	O
)	O
;	O
edit	pointer
->	O
buffers2	array
[	O
edit	pointer
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
EDIT_BUF_SIZE	O
-	O
(	O
edit	pointer
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
]	O
=	O
c	int
;	O
edit	pointer
->	O
last_byte	long
++	O
;	O
edit	pointer
->	O
curs2	long
++	O
;	O
}	O
int	O
edit_delete	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
p	pointer
;	O
if	O
(	O
!	O
edit	pointer
->	O
curs2	long
)	O
return	O
0	int
;	O
edit	pointer
->	O
mark1	long
-=	O
(	O
edit	pointer
->	O
mark1	long
>	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
mark2	long
-=	O
(	O
edit	pointer
->	O
mark2	long
>	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
last_get_rule	long
-=	O
(	O
edit	pointer
->	O
last_get_rule	long
>	O
edit	pointer
->	O
curs1	long
)	O
;	O
p	pointer
=	O
edit	pointer
->	O
buffers2	array
[	O
(	O
edit	pointer
->	O
curs2	long
-	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
EDIT_BUF_SIZE	O
-	O
(	O
(	O
edit	pointer
->	O
curs2	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
]	O
;	O
if	O
(	O
!	O
(	O
edit	pointer
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
g_free	function
(	O
edit	pointer
->	O
buffers2	array
[	O
edit	pointer
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
)	O
;	O
edit	pointer
->	O
buffers2	array
[	O
edit	pointer
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
NULL	O
;	O
}	O
edit	pointer
->	O
last_byte	long
--	O
;	O
edit	pointer
->	O
curs2	long
--	O
;	O
edit_modification	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
'\n'	O
)	O
{	O
if	O
(	O
edit	pointer
->	O
book_mark	pointer
)	O
book_mark_dec	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
)	O
;	O
edit	pointer
->	O
total_lines	long
--	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_AFTER_CURSOR	O
;	O
}	O
edit_push_action	function
(	O
edit	pointer
,	O
p	pointer
+	O
256	int
)	O
;	O
if	O
(	O
edit	pointer
->	O
curs1	long
<	O
edit	pointer
->	O
start_display	long
)	O
{	O
edit	pointer
->	O
start_display	long
--	O
;	O
if	O
(	O
p	pointer
==	O
'\n'	O
)	O
edit	pointer
->	O
start_line	long
--	O
;	O
}	O
return	O
p	pointer
;	O
}	O
static	O
int	O
edit_backspace	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
p	pointer
;	O
if	O
(	O
!	O
edit	pointer
->	O
curs1	long
)	O
return	O
0	int
;	O
edit	pointer
->	O
mark1	long
-=	O
(	O
edit	pointer
->	O
mark1	long
>=	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
mark2	long
-=	O
(	O
edit	pointer
->	O
mark2	long
>=	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
last_get_rule	long
-=	O
(	O
edit	pointer
->	O
last_get_rule	long
>=	O
edit	pointer
->	O
curs1	long
)	O
;	O
p	pointer
=	O
*	O
(	O
edit	pointer
->	O
buffers1	array
[	O
(	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
+	O
(	O
(	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
(	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
g_free	function
(	O
edit	pointer
->	O
buffers1	array
[	O
edit	pointer
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
)	O
;	O
edit	pointer
->	O
buffers1	array
[	O
edit	pointer
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
NULL	O
;	O
}	O
edit	pointer
->	O
last_byte	long
--	O
;	O
edit	pointer
->	O
curs1	long
--	O
;	O
edit_modification	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
'\n'	O
)	O
{	O
if	O
(	O
edit	pointer
->	O
book_mark	pointer
)	O
book_mark_dec	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
)	O
;	O
edit	pointer
->	O
curs_line	long
--	O
;	O
edit	pointer
->	O
total_lines	long
--	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_AFTER_CURSOR	O
;	O
}	O
edit_push_action	function
(	O
edit	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
edit	pointer
->	O
curs1	long
<	O
edit	pointer
->	O
start_display	long
)	O
{	O
edit	pointer
->	O
start_display	long
--	O
;	O
if	O
(	O
p	pointer
==	O
'\n'	O
)	O
edit	pointer
->	O
start_line	long
--	O
;	O
}	O
return	O
p	pointer
;	O
}	O
int	O
edit_cursor_move	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
increment	long
)	O
{	O
int	O
c	int
;	O
if	O
(	O
increment	long
<	O
0	int
)	O
{	O
for	O
(	O
;	O
increment	long
<	O
0	int
;	O
increment	long
++	O
)	O
{	O
if	O
(	O
!	O
edit	pointer
->	O
curs1	long
)	O
return	O
-	O
1	int
;	O
edit_push_action	function
(	O
edit	pointer
,	O
CURS_RIGHT	int
)	O
;	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
;	O
if	O
(	O
!	O
(	O
(	O
edit	pointer
->	O
curs2	long
+	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
edit	pointer
->	O
buffers2	array
[	O
(	O
edit	pointer
->	O
curs2	long
+	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
g_malloc	function
(	O
EDIT_BUF_SIZE	O
)	O
;	O
edit	pointer
->	O
buffers2	array
[	O
edit	pointer
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
EDIT_BUF_SIZE	O
-	O
(	O
edit	pointer
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
]	O
=	O
c	int
;	O
edit	pointer
->	O
curs2	long
++	O
;	O
c	int
=	O
edit	pointer
->	O
buffers1	array
[	O
(	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
(	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
]	O
;	O
if	O
(	O
!	O
(	O
(	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
g_free	function
(	O
edit	pointer
->	O
buffers1	array
[	O
edit	pointer
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
)	O
;	O
edit	pointer
->	O
buffers1	array
[	O
edit	pointer
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
NULL	O
;	O
}	O
edit	pointer
->	O
curs1	long
--	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
edit	pointer
->	O
curs_line	long
--	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_LINE_BELOW	O
;	O
}	O
}	O
return	O
c	int
;	O
}	O
else	O
if	O
(	O
increment	long
>	O
0	int
)	O
{	O
for	O
(	O
;	O
increment	long
>	O
0	int
;	O
increment	long
--	O
)	O
{	O
if	O
(	O
!	O
edit	pointer
->	O
curs2	long
)	O
return	O
-	O
2	int
;	O
edit_push_action	function
(	O
edit	pointer
,	O
CURS_LEFT	int
)	O
;	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
(	O
edit	pointer
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
edit	pointer
->	O
buffers1	array
[	O
edit	pointer
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
g_malloc	function
(	O
EDIT_BUF_SIZE	O
)	O
;	O
edit	pointer
->	O
buffers1	array
[	O
edit	pointer
->	O
curs1	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
edit	pointer
->	O
curs1	long
&	O
M_EDIT_BUF_SIZE	O
]	O
=	O
c	int
;	O
edit	pointer
->	O
curs1	long
++	O
;	O
c	int
=	O
edit	pointer
->	O
buffers2	array
[	O
(	O
edit	pointer
->	O
curs2	long
-	O
1	int
)	O
>>	O
S_EDIT_BUF_SIZE	int
]	O
[	O
EDIT_BUF_SIZE	O
-	O
(	O
(	O
edit	pointer
->	O
curs2	long
-	O
1	int
)	O
&	O
M_EDIT_BUF_SIZE	O
)	O
-	O
1	int
]	O
;	O
if	O
(	O
!	O
(	O
edit	pointer
->	O
curs2	long
&	O
M_EDIT_BUF_SIZE	O
)	O
)	O
{	O
g_free	function
(	O
edit	pointer
->	O
buffers2	array
[	O
edit	pointer
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
)	O
;	O
edit	pointer
->	O
buffers2	array
[	O
edit	pointer
->	O
curs2	long
>>	O
S_EDIT_BUF_SIZE	int
]	O
=	O
0	int
;	O
}	O
edit	pointer
->	O
curs2	long
--	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
edit	pointer
->	O
curs_line	long
++	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_LINE_ABOVE	O
;	O
}	O
}	O
return	O
c	int
;	O
}	O
else	O
return	O
-	O
3	int
;	O
}	O
long	O
edit_eol	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
current	long
)	O
{	O
if	O
(	O
current	long
<	O
edit	pointer
->	O
last_byte	long
)	O
{	O
for	O
(	O
;	O
;	O
current	long
++	O
)	O
if	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
current	long
)	O
==	O
'\n'	O
)	O
break	O
;	O
}	O
else	O
return	O
edit	pointer
->	O
last_byte	long
;	O
return	O
current	long
;	O
}	O
long	O
edit_bol	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
current	long
)	O
{	O
if	O
(	O
current	long
>	O
0	int
)	O
{	O
for	O
(	O
;	O
;	O
current	long
--	O
)	O
if	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
current	long
-	O
1	int
)	O
==	O
'\n'	O
)	O
break	O
;	O
}	O
else	O
return	O
0	int
;	O
return	O
current	long
;	O
}	O
int	O
edit_count_lines	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
current	long
,	O
int	O
upto	int
)	O
{	O
int	O
lines	pointer
=	O
0	int
;	O
if	O
(	O
upto	int
>	O
edit	pointer
->	O
last_byte	long
)	O
upto	int
=	O
edit	pointer
->	O
last_byte	long
;	O
if	O
(	O
current	long
<	O
0	int
)	O
current	long
=	O
0	int
;	O
while	O
(	O
current	long
<	O
upto	int
)	O
if	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
current	long
++	O
)	O
==	O
'\n'	O
)	O
lines	pointer
++	O
;	O
return	O
lines	pointer
;	O
}	O
long	O
edit_move_forward	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
current	long
,	O
int	O
lines	pointer
,	O
long	O
upto	int
)	O
{	O
if	O
(	O
upto	int
)	O
{	O
return	O
edit_count_lines	function
(	O
edit	pointer
,	O
current	long
,	O
upto	int
)	O
;	O
}	O
else	O
{	O
int	O
next	pointer
;	O
if	O
(	O
lines	pointer
<	O
0	int
)	O
lines	pointer
=	O
0	int
;	O
while	O
(	O
lines	pointer
--	O
)	O
{	O
next	pointer
=	O
edit_eol	function
(	O
edit	pointer
,	O
current	long
)	O
+	O
1	int
;	O
if	O
(	O
next	pointer
>	O
edit	pointer
->	O
last_byte	long
)	O
break	O
;	O
else	O
current	long
=	O
next	pointer
;	O
}	O
return	O
current	long
;	O
}	O
}	O
long	O
edit_move_backward	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
current	long
,	O
int	O
lines	pointer
)	O
{	O
if	O
(	O
lines	pointer
<	O
0	int
)	O
lines	pointer
=	O
0	int
;	O
current	long
=	O
edit_bol	function
(	O
edit	pointer
,	O
current	long
)	O
;	O
while	O
(	O
(	O
lines	pointer
--	O
)	O
&&	O
current	long
!=	O
0	int
)	O
current	long
=	O
edit_bol	function
(	O
edit	pointer
,	O
current	long
-	O
1	int
)	O
;	O
return	O
current	long
;	O
}	O
long	O
edit_move_forward3	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
current	long
,	O
int	O
cols	int
,	O
long	O
upto	int
)	O
{	O
long	O
p	pointer
,	O
q	long
;	O
int	O
col	int
=	O
0	int
;	O
if	O
(	O
upto	int
)	O
{	O
q	long
=	O
upto	int
;	O
cols	int
=	O
-	O
10	int
;	O
}	O
else	O
q	long
=	O
edit	pointer
->	O
last_byte	long
+	O
2	int
;	O
for	O
(	O
col	int
=	O
0	int
,	O
p	pointer
=	O
current	long
;	O
p	pointer
<	O
q	long
;	O
p	pointer
++	O
)	O
{	O
int	O
c	int
;	O
if	O
(	O
cols	int
!=	O
-	O
10	int
)	O
{	O
if	O
(	O
col	int
==	O
cols	int
)	O
return	O
p	pointer
;	O
if	O
(	O
col	int
>	O
cols	int
)	O
return	O
p	pointer
-	O
1	int
;	O
}	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'\t'	O
)	O
col	int
+=	O
TAB_SIZE	O
-	O
col	int
%	O
TAB_SIZE	O
;	O
else	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
upto	int
)	O
return	O
col	int
;	O
else	O
return	O
p	pointer
;	O
}	O
else	O
if	O
(	O
c	int
<	O
32	int
||	O
c	int
==	O
127	int
)	O
col	int
+=	O
2	int
;	O
else	O
col	int
++	O
;	O
}	O
return	O
col	int
;	O
}	O
int	O
edit_get_col	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
return	O
edit_move_forward3	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
,	O
0	int
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
}	O
void	O
edit_update_curs_row	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit	pointer
->	O
curs_row	long
=	O
edit	pointer
->	O
curs_line	long
-	O
edit	pointer
->	O
start_line	long
;	O
}	O
void	O
edit_update_curs_col	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit	pointer
->	O
curs_col	long
=	O
edit_move_forward3	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
,	O
0	int
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
}	O
void	O
edit_scroll_upward	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
unsigned	O
long	O
i	array
)	O
{	O
unsigned	O
long	O
lines_above	long
=	O
edit	pointer
->	O
start_line	long
;	O
if	O
(	O
i	array
>	O
lines_above	long
)	O
i	array
=	O
lines_above	long
;	O
if	O
(	O
i	array
)	O
{	O
edit	pointer
->	O
start_line	long
-=	O
i	array
;	O
edit	pointer
->	O
start_display	long
=	O
edit_move_backward	function
(	O
edit	pointer
,	O
edit	pointer
->	O
start_display	long
,	O
i	array
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit	pointer
->	O
force	int
&=	O
(	O
0xfff	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
}	O
edit_update_curs_row	function
(	O
edit	pointer
)	O
;	O
}	O
void	O
edit_scroll_downward	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
i	array
)	O
{	O
int	O
lines_below	int
;	O
lines_below	int
=	O
edit	pointer
->	O
total_lines	long
-	O
edit	pointer
->	O
start_line	long
-	O
(	O
edit	pointer
->	O
num_widget_lines	int
-	O
1	int
)	O
;	O
if	O
(	O
lines_below	int
>	O
0	int
)	O
{	O
if	O
(	O
i	array
>	O
lines_below	int
)	O
i	array
=	O
lines_below	int
;	O
edit	pointer
->	O
start_line	long
+=	O
i	array
;	O
edit	pointer
->	O
start_display	long
=	O
edit_move_forward	function
(	O
edit	pointer
,	O
edit	pointer
->	O
start_display	long
,	O
i	array
,	O
0	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit	pointer
->	O
force	int
&=	O
(	O
0xfff	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
}	O
edit_update_curs_row	function
(	O
edit	pointer
)	O
;	O
}	O
void	O
edit_scroll_right	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
i	array
)	O
{	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit	pointer
->	O
force	int
&=	O
(	O
0xfff	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
edit	pointer
->	O
start_col	long
-=	O
i	array
;	O
}	O
void	O
edit_scroll_left	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
i	array
)	O
{	O
if	O
(	O
edit	pointer
->	O
start_col	long
)	O
{	O
edit	pointer
->	O
start_col	long
+=	O
i	array
;	O
if	O
(	O
edit	pointer
->	O
start_col	long
>	O
0	int
)	O
edit	pointer
->	O
start_col	long
=	O
0	int
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit	pointer
->	O
force	int
&=	O
(	O
0xfff	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
}	O
}	O
static	O
int	O
is_in_indent	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
p	pointer
=	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
while	O
(	O
p	pointer
<	O
edit	pointer
->	O
curs1	long
)	O
if	O
(	O
!	O
strchr	function
(	O
" \t"	pointer
,	O
edit_get_byte	function
(	O
edit	pointer
,	O
p	pointer
++	O
)	O
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
left_of_four_spaces	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
;	O
void	O
edit_move_to_prev_col	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
p	pointer
)	O
{	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit_move_forward3	function
(	O
edit	pointer
,	O
p	pointer
,	O
edit	pointer
->	O
prev_col	long
,	O
0	int
)	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
if	O
(	O
is_in_indent	function
(	O
edit	pointer
)	O
&&	O
option_fake_half_tabs	int
)	O
{	O
edit_update_curs_col	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
space_width	int
)	O
if	O
(	O
edit	pointer
->	O
curs_col	long
%	O
(	O
HALF_TAB_SIZE	O
*	O
space_width	int
)	O
)	O
{	O
int	O
q	long
=	O
edit	pointer
->	O
curs_col	long
;	O
edit	pointer
->	O
curs_col	long
-=	O
(	O
edit	pointer
->	O
curs_col	long
%	O
(	O
HALF_TAB_SIZE	O
*	O
space_width	int
)	O
)	O
;	O
p	pointer
=	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit_move_forward3	function
(	O
edit	pointer
,	O
p	pointer
,	O
edit	pointer
->	O
curs_col	long
,	O
0	int
)	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
left_of_four_spaces	function
(	O
edit	pointer
)	O
)	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit_move_forward3	function
(	O
edit	pointer
,	O
p	pointer
,	O
q	long
,	O
0	int
)	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
}	O
}	O
}	O
void	O
edit_move_up	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
unsigned	O
long	O
i	array
,	O
int	O
scroll	int
)	O
{	O
unsigned	O
long	O
p	pointer
,	O
l	pointer
=	O
edit	pointer
->	O
curs_line	long
;	O
if	O
(	O
i	array
>	O
l	pointer
)	O
i	array
=	O
l	pointer
;	O
if	O
(	O
i	array
)	O
{	O
if	O
(	O
i	array
>	O
1	int
)	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
if	O
(	O
scroll	int
)	O
edit_scroll_upward	function
(	O
edit	pointer
,	O
i	array
)	O
;	O
p	pointer
=	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
(	O
p	pointer
=	O
edit_move_backward	function
(	O
edit	pointer
,	O
p	pointer
,	O
i	array
)	O
)	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_move_to_prev_col	function
(	O
edit	pointer
,	O
p	pointer
)	O
;	O
edit	pointer
->	O
search_start	long
=	O
edit	pointer
->	O
curs1	long
;	O
edit	pointer
->	O
found_len	int
=	O
0	int
;	O
}	O
}	O
static	O
int	O
is_blank	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
offset	long
)	O
{	O
long	O
s	pointer
,	O
f	pointer
;	O
int	O
c	int
;	O
s	pointer
=	O
edit_bol	function
(	O
edit	pointer
,	O
offset	long
)	O
;	O
f	pointer
=	O
edit_eol	function
(	O
edit	pointer
,	O
offset	long
)	O
-	O
1	int
;	O
while	O
(	O
s	pointer
<=	O
f	pointer
)	O
{	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
s	pointer
++	O
)	O
;	O
if	O
(	O
!	O
isspace	function
(	O
c	int
)	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
long	O
edit_find_line	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
line	int
)	O
{	O
int	O
i	array
,	O
j	int
=	O
0	int
;	O
int	O
m	int
=	O
2000000000	int
;	O
if	O
(	O
!	O
edit	pointer
->	O
caches_valid	int
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
N_LINE_CACHES	int
;	O
i	array
++	O
)	O
edit	pointer
->	O
line_numbers	array
[	O
i	array
]	O
=	O
edit	pointer
->	O
line_offsets	array
[	O
i	array
]	O
=	O
0	int
;	O
edit	pointer
->	O
line_numbers	array
[	O
1	int
]	O
=	O
edit	pointer
->	O
curs_line	long
;	O
edit	pointer
->	O
line_offsets	array
[	O
1	int
]	O
=	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
line_numbers	array
[	O
2	int
]	O
=	O
edit	pointer
->	O
total_lines	long
;	O
edit	pointer
->	O
line_offsets	array
[	O
2	int
]	O
=	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
last_byte	long
)	O
;	O
edit	pointer
->	O
caches_valid	int
=	O
1	int
;	O
}	O
if	O
(	O
line	int
>=	O
edit	pointer
->	O
total_lines	long
)	O
return	O
edit	pointer
->	O
line_offsets	array
[	O
2	int
]	O
;	O
if	O
(	O
line	int
<=	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
N_LINE_CACHES	int
;	O
i	array
++	O
)	O
{	O
int	O
n	long
;	O
n	long
=	O
abs	function
(	O
edit	pointer
->	O
line_numbers	array
[	O
i	array
]	O
-	O
line	int
)	O
;	O
if	O
(	O
n	long
<	O
m	int
)	O
{	O
m	int
=	O
n	long
;	O
j	int
=	O
i	array
;	O
}	O
}	O
if	O
(	O
m	int
==	O
0	int
)	O
return	O
edit	pointer
->	O
line_offsets	array
[	O
j	int
]	O
;	O
if	O
(	O
m	int
==	O
1	int
&&	O
j	int
>=	O
3	int
)	O
i	array
=	O
j	int
;	O
else	O
i	array
=	O
3	int
+	O
(	O
rand	function
(	O
)	O
%	O
(	O
N_LINE_CACHES	int
-	O
3	int
)	O
)	O
;	O
if	O
(	O
line	int
>	O
edit	pointer
->	O
line_numbers	array
[	O
j	int
]	O
)	O
edit	pointer
->	O
line_offsets	array
[	O
i	array
]	O
=	O
edit_move_forward	function
(	O
edit	pointer
,	O
edit	pointer
->	O
line_offsets	array
[	O
j	int
]	O
,	O
line	int
-	O
edit	pointer
->	O
line_numbers	array
[	O
j	int
]	O
,	O
0	int
)	O
;	O
else	O
edit	pointer
->	O
line_offsets	array
[	O
i	array
]	O
=	O
edit_move_backward	function
(	O
edit	pointer
,	O
edit	pointer
->	O
line_offsets	array
[	O
j	int
]	O
,	O
edit	pointer
->	O
line_numbers	array
[	O
j	int
]	O
-	O
line	int
)	O
;	O
edit	pointer
->	O
line_numbers	array
[	O
i	array
]	O
=	O
line	int
;	O
return	O
edit	pointer
->	O
line_offsets	array
[	O
i	array
]	O
;	O
}	O
int	O
line_is_blank	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
line	int
)	O
{	O
return	O
is_blank	function
(	O
edit	pointer
,	O
edit_find_line	function
(	O
edit	pointer
,	O
line	int
)	O
)	O
;	O
}	O
static	O
void	O
edit_move_up_paragraph	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
scroll	int
)	O
{	O
int	O
i	array
;	O
if	O
(	O
edit	pointer
->	O
curs_line	long
<=	O
1	int
)	O
{	O
i	array
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
line_is_blank	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
)	O
)	O
{	O
if	O
(	O
line_is_blank	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
-	O
1	int
)	O
)	O
{	O
for	O
(	O
i	array
=	O
edit	pointer
->	O
curs_line	long
-	O
1	int
;	O
i	array
;	O
i	array
--	O
)	O
if	O
(	O
!	O
line_is_blank	function
(	O
edit	pointer
,	O
i	array
)	O
)	O
{	O
i	array
++	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	array
=	O
edit	pointer
->	O
curs_line	long
-	O
1	int
;	O
i	array
;	O
i	array
--	O
)	O
if	O
(	O
line_is_blank	function
(	O
edit	pointer
,	O
i	array
)	O
)	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	array
=	O
edit	pointer
->	O
curs_line	long
-	O
1	int
;	O
i	array
;	O
i	array
--	O
)	O
if	O
(	O
line_is_blank	function
(	O
edit	pointer
,	O
i	array
)	O
)	O
break	O
;	O
}	O
}	O
edit_move_up	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
-	O
i	array
,	O
scroll	int
)	O
;	O
}	O
void	O
edit_move_down	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
i	array
,	O
int	O
scroll	int
)	O
{	O
long	O
p	pointer
,	O
l	pointer
=	O
edit	pointer
->	O
total_lines	long
-	O
edit	pointer
->	O
curs_line	long
;	O
if	O
(	O
i	array
>	O
l	pointer
)	O
i	array
=	O
l	pointer
;	O
if	O
(	O
i	array
)	O
{	O
if	O
(	O
i	array
>	O
1	int
)	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
if	O
(	O
scroll	int
)	O
edit_scroll_downward	function
(	O
edit	pointer
,	O
i	array
)	O
;	O
p	pointer
=	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
(	O
p	pointer
=	O
edit_move_forward	function
(	O
edit	pointer
,	O
p	pointer
,	O
i	array
,	O
0	int
)	O
)	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_move_to_prev_col	function
(	O
edit	pointer
,	O
p	pointer
)	O
;	O
edit	pointer
->	O
search_start	long
=	O
edit	pointer
->	O
curs1	long
;	O
edit	pointer
->	O
found_len	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
edit_move_down_paragraph	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
scroll	int
)	O
{	O
int	O
i	array
;	O
if	O
(	O
edit	pointer
->	O
curs_line	long
>=	O
edit	pointer
->	O
total_lines	long
-	O
1	int
)	O
{	O
i	array
=	O
edit	pointer
->	O
total_lines	long
;	O
}	O
else	O
{	O
if	O
(	O
line_is_blank	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
)	O
)	O
{	O
if	O
(	O
line_is_blank	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
+	O
1	int
)	O
)	O
{	O
for	O
(	O
i	array
=	O
edit	pointer
->	O
curs_line	long
+	O
1	int
;	O
i	array
;	O
i	array
++	O
)	O
if	O
(	O
!	O
line_is_blank	function
(	O
edit	pointer
,	O
i	array
)	O
||	O
i	array
>	O
edit	pointer
->	O
total_lines	long
)	O
{	O
i	array
--	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	array
=	O
edit	pointer
->	O
curs_line	long
+	O
1	int
;	O
i	array
;	O
i	array
++	O
)	O
if	O
(	O
line_is_blank	function
(	O
edit	pointer
,	O
i	array
)	O
||	O
i	array
>=	O
edit	pointer
->	O
total_lines	long
)	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	array
=	O
edit	pointer
->	O
curs_line	long
+	O
1	int
;	O
i	array
;	O
i	array
++	O
)	O
if	O
(	O
line_is_blank	function
(	O
edit	pointer
,	O
i	array
)	O
||	O
i	array
>=	O
edit	pointer
->	O
total_lines	long
)	O
break	O
;	O
}	O
}	O
edit_move_down	function
(	O
edit	pointer
,	O
i	array
-	O
edit	pointer
->	O
curs_line	long
,	O
scroll	int
)	O
;	O
}	O
static	O
void	O
edit_begin_page	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_update_curs_row	function
(	O
edit	pointer
)	O
;	O
edit_move_up	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_row	long
,	O
0	int
)	O
;	O
}	O
static	O
void	O
edit_end_page	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_update_curs_row	function
(	O
edit	pointer
)	O
;	O
edit_move_down	function
(	O
edit	pointer
,	O
edit	pointer
->	O
num_widget_lines	int
-	O
edit	pointer
->	O
curs_row	long
-	O
1	int
,	O
0	int
)	O
;	O
}	O
static	O
void	O
edit_move_to_top	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
if	O
(	O
edit	pointer
->	O
curs_line	long
)	O
{	O
edit_cursor_move	function
(	O
edit	pointer
,	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit_move_to_prev_col	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit	pointer
->	O
search_start	long
=	O
0	int
;	O
edit_update_curs_row	function
(	O
edit	pointer
)	O
;	O
}	O
}	O
static	O
void	O
edit_move_to_bottom	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
if	O
(	O
edit	pointer
->	O
curs_line	long
<	O
edit	pointer
->	O
total_lines	long
)	O
{	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs2	long
)	O
;	O
edit	pointer
->	O
start_display	long
=	O
edit	pointer
->	O
last_byte	long
;	O
edit	pointer
->	O
start_line	long
=	O
edit	pointer
->	O
total_lines	long
;	O
edit_update_curs_row	function
(	O
edit	pointer
)	O
;	O
edit_scroll_upward	function
(	O
edit	pointer
,	O
edit	pointer
->	O
num_widget_lines	int
-	O
1	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
}	O
static	O
void	O
edit_cursor_to_bol	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
search_start	long
=	O
edit	pointer
->	O
curs1	long
;	O
edit	pointer
->	O
prev_col	long
=	O
edit_get_col	function
(	O
edit	pointer
)	O
;	O
}	O
static	O
void	O
edit_cursor_to_eol	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_cursor_move	function
(	O
edit	pointer
,	O
edit_eol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
edit	pointer
->	O
search_start	long
=	O
edit	pointer
->	O
curs1	long
;	O
edit	pointer
->	O
prev_col	long
=	O
edit_get_col	function
(	O
edit	pointer
)	O
;	O
}	O
void	O
edit_move_to_line	function
(	O
WEdit	struct
*	O
e	pointer
,	O
long	O
line	int
)	O
{	O
if	O
(	O
line	int
<	O
e	pointer
->	O
curs_line	long
)	O
edit_move_up	function
(	O
e	pointer
,	O
e	pointer
->	O
curs_line	long
-	O
line	int
,	O
0	int
)	O
;	O
else	O
edit_move_down	function
(	O
e	pointer
,	O
line	int
-	O
e	pointer
->	O
curs_line	long
,	O
0	int
)	O
;	O
edit_scroll_screen_over_cursor	function
(	O
e	pointer
)	O
;	O
}	O
void	O
edit_move_display	function
(	O
WEdit	struct
*	O
e	pointer
,	O
long	O
line	int
)	O
{	O
if	O
(	O
line	int
<	O
e	pointer
->	O
start_line	long
)	O
edit_scroll_upward	function
(	O
e	pointer
,	O
e	pointer
->	O
start_line	long
-	O
line	int
)	O
;	O
else	O
edit_scroll_downward	function
(	O
e	pointer
,	O
line	int
-	O
e	pointer
->	O
start_line	long
)	O
;	O
}	O
void	O
edit_push_markers	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_push_action	function
(	O
edit	pointer
,	O
MARK_1	int
+	O
edit	pointer
->	O
mark1	long
)	O
;	O
edit_push_action	function
(	O
edit	pointer
,	O
MARK_2	int
+	O
edit	pointer
->	O
mark2	long
)	O
;	O
}	O
void	O
edit_set_markers	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
m1	long
,	O
long	O
m2	long
,	O
int	O
c1	int
,	O
int	O
c2	int
)	O
{	O
edit	pointer
->	O
mark1	long
=	O
m1	long
;	O
edit	pointer
->	O
mark2	long
=	O
m2	long
;	O
edit	pointer
->	O
column1	int
=	O
c1	int
;	O
edit	pointer
->	O
column2	int
=	O
c2	int
;	O
}	O
void	O
edit_mark_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
unmark	int
)	O
{	O
edit_push_markers	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
unmark	int
)	O
{	O
edit_set_markers	function
(	O
edit	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
else	O
{	O
if	O
(	O
edit	pointer
->	O
mark2	long
>=	O
0	int
)	O
{	O
edit_set_markers	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
,	O
-	O
1	int
,	O
edit	pointer
->	O
curs_col	long
,	O
edit	pointer
->	O
curs_col	long
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
else	O
edit_set_markers	function
(	O
edit	pointer
,	O
edit	pointer
->	O
mark1	long
,	O
edit	pointer
->	O
curs1	long
,	O
edit	pointer
->	O
column1	int
,	O
edit	pointer
->	O
curs_col	long
)	O
;	O
}	O
}	O
static	O
unsigned	O
long	O
my_type_of	function
(	O
int	O
c	int
)	O
{	O
int	O
x	array
,	O
r	int
=	O
0	int
;	O
const	O
char	O
*	O
p	pointer
,	O
*	O
q	long
;	O
const	O
char	O
option_chars_move_whole_word	array
[	O
]	O
=	O
"!=&|<>^~ !:;, !'!`!.?!\"!( !) !Aa0 !+-*/= |<> ![ !] !\\#! "	pointer
;	O
if	O
(	O
!	O
c	int
)	O
return	O
0	int
;	O
if	O
(	O
c	int
==	O
'!'	O
)	O
{	O
if	O
(	O
*	O
option_chars_move_whole_word	array
==	O
'!'	O
)	O
return	O
2	int
;	O
return	O
0x80000000UL	int
;	O
}	O
if	O
(	O
isupper	function
(	O
c	int
)	O
)	O
c	int
=	O
'A'	O
;	O
else	O
if	O
(	O
islower	function
(	O
c	int
)	O
)	O
c	int
=	O
'a'	O
;	O
else	O
if	O
(	O
isalpha	function
(	O
c	int
)	O
)	O
c	int
=	O
'a'	O
;	O
else	O
if	O
(	O
isdigit	function
(	O
c	int
)	O
)	O
c	int
=	O
'0'	O
;	O
else	O
if	O
(	O
isspace	function
(	O
c	int
)	O
)	O
c	int
=	O
' '	O
;	O
q	long
=	O
strchr	function
(	O
option_chars_move_whole_word	array
,	O
c	int
)	O
;	O
if	O
(	O
!	O
q	long
)	O
return	O
0xFFFFFFFFUL	int
;	O
do	O
{	O
for	O
(	O
x	array
=	O
1	int
,	O
p	pointer
=	O
option_chars_move_whole_word	array
;	O
p	pointer
<	O
q	long
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
==	O
'!'	O
)	O
x	array
<<=	O
1	int
;	O
r	int
|=	O
x	array
;	O
}	O
while	O
(	O
(	O
q	long
=	O
strchr	function
(	O
q	long
+	O
1	int
,	O
c	int
)	O
)	O
)	O
;	O
return	O
r	int
;	O
}	O
static	O
void	O
edit_left_word_move	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
s	pointer
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
c1	int
,	O
c2	int
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
edit	pointer
->	O
curs1	long
)	O
break	O
;	O
c1	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
;	O
c2	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
(	O
my_type_of	function
(	O
c1	int
)	O
&	O
my_type_of	function
(	O
c2	int
)	O
)	O
)	O
break	O
;	O
if	O
(	O
isspace	function
(	O
c1	int
)	O
&&	O
!	O
isspace	function
(	O
c2	int
)	O
)	O
break	O
;	O
if	O
(	O
s	pointer
)	O
if	O
(	O
!	O
isspace	function
(	O
c1	int
)	O
&&	O
isspace	function
(	O
c2	int
)	O
)	O
break	O
;	O
}	O
}	O
static	O
void	O
edit_left_word_move_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_left_word_move	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
static	O
void	O
edit_right_word_move	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
s	pointer
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
c1	int
,	O
c2	int
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
1	int
)	O
;	O
if	O
(	O
edit	pointer
->	O
curs1	long
>=	O
edit	pointer
->	O
last_byte	long
)	O
break	O
;	O
c1	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
;	O
c2	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
if	O
(	O
!	O
(	O
my_type_of	function
(	O
c1	int
)	O
&	O
my_type_of	function
(	O
c2	int
)	O
)	O
)	O
break	O
;	O
if	O
(	O
isspace	function
(	O
c1	int
)	O
&&	O
!	O
isspace	function
(	O
c2	int
)	O
)	O
break	O
;	O
if	O
(	O
s	pointer
)	O
if	O
(	O
!	O
isspace	function
(	O
c1	int
)	O
&&	O
isspace	function
(	O
c2	int
)	O
)	O
break	O
;	O
}	O
}	O
static	O
void	O
edit_right_word_move_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_right_word_move	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
static	O
void	O
edit_right_delete_word	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
c1	int
,	O
c2	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
edit	pointer
->	O
curs1	long
>=	O
edit	pointer
->	O
last_byte	long
)	O
break	O
;	O
c1	int
=	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
c2	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
if	O
(	O
(	O
isspace	function
(	O
c1	int
)	O
==	O
0	int
)	O
!=	O
(	O
isspace	function
(	O
c2	int
)	O
==	O
0	int
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
my_type_of	function
(	O
c1	int
)	O
&	O
my_type_of	function
(	O
c2	int
)	O
)	O
)	O
break	O
;	O
}	O
}	O
static	O
void	O
edit_left_delete_word	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
c1	int
,	O
c2	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
edit	pointer
->	O
curs1	long
<=	O
0	int
)	O
break	O
;	O
c1	int
=	O
edit_backspace	function
(	O
edit	pointer
)	O
;	O
c2	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
;	O
if	O
(	O
(	O
isspace	function
(	O
c1	int
)	O
==	O
0	int
)	O
!=	O
(	O
isspace	function
(	O
c2	int
)	O
==	O
0	int
)	O
)	O
break	O
;	O
if	O
(	O
!	O
(	O
my_type_of	function
(	O
c1	int
)	O
&	O
my_type_of	function
(	O
c2	int
)	O
)	O
)	O
break	O
;	O
}	O
}	O
static	O
void	O
edit_do_undo	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
ac	long
;	O
long	O
count	int
=	O
0	int
;	O
edit	pointer
->	O
stack_disable	int
=	O
1	int
;	O
while	O
(	O
(	O
ac	long
=	O
pop_action	function
(	O
edit	pointer
)	O
)	O
<	O
KEY_PRESS	int
)	O
{	O
switch	O
(	O
(	O
int	O
)	O
ac	long
)	O
{	O
case	O
STACK_BOTTOM	int
:	O
goto	O
done_undo	O
;	O
case	O
CURS_RIGHT	int
:	O
edit_cursor_move	function
(	O
edit	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CURS_LEFT	int
:	O
edit_cursor_move	function
(	O
edit	pointer
,	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
BACKSPACE	int
:	O
edit_backspace	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
DELCHAR	int
:	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
COLUMN_ON	int
:	O
column_highlighting	int
=	O
1	int
;	O
break	O
;	O
case	O
COLUMN_OFF	int
:	O
column_highlighting	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
ac	long
>=	O
256	int
&&	O
ac	long
<	O
512	int
)	O
edit_insert_ahead	function
(	O
edit	pointer
,	O
ac	long
-	O
256	int
)	O
;	O
if	O
(	O
ac	long
>=	O
0	int
&&	O
ac	long
<	O
256	int
)	O
edit_insert	function
(	O
edit	pointer
,	O
ac	long
)	O
;	O
if	O
(	O
ac	long
>=	O
MARK_1	int
-	O
2	int
&&	O
ac	long
<	O
MARK_2	int
-	O
2	int
)	O
{	O
edit	pointer
->	O
mark1	long
=	O
ac	long
-	O
MARK_1	int
;	O
edit	pointer
->	O
column1	int
=	O
edit_move_forward3	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
mark1	long
)	O
,	O
0	int
,	O
edit	pointer
->	O
mark1	long
)	O
;	O
}	O
else	O
if	O
(	O
ac	long
>=	O
MARK_2	int
-	O
2	int
&&	O
ac	long
<	O
KEY_PRESS	int
)	O
{	O
edit	pointer
->	O
mark2	long
=	O
ac	long
-	O
MARK_2	int
;	O
edit	pointer
->	O
column2	int
=	O
edit_move_forward3	function
(	O
edit	pointer
,	O
edit_bol	function
(	O
edit	pointer
,	O
edit	pointer
->	O
mark2	long
)	O
,	O
0	int
,	O
edit	pointer
->	O
mark2	long
)	O
;	O
}	O
if	O
(	O
count	int
++	O
)	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
if	O
(	O
edit	pointer
->	O
start_display	long
>	O
ac	long
-	O
KEY_PRESS	int
)	O
{	O
edit	pointer
->	O
start_line	long
-=	O
edit_count_lines	function
(	O
edit	pointer
,	O
ac	long
-	O
KEY_PRESS	int
,	O
edit	pointer
->	O
start_display	long
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
else	O
if	O
(	O
edit	pointer
->	O
start_display	long
<	O
ac	long
-	O
KEY_PRESS	int
)	O
{	O
edit	pointer
->	O
start_line	long
+=	O
edit_count_lines	function
(	O
edit	pointer
,	O
edit	pointer
->	O
start_display	long
,	O
ac	long
-	O
KEY_PRESS	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
edit	pointer
->	O
start_display	long
=	O
ac	long
-	O
KEY_PRESS	int
;	O
edit_update_curs_row	function
(	O
edit	pointer
)	O
;	O
done_undo	O
:	O
;	O
edit	pointer
->	O
stack_disable	int
=	O
0	int
;	O
}	O
static	O
void	O
edit_delete_to_line_end	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
while	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
!=	O
'\n'	O
)	O
{	O
if	O
(	O
!	O
edit	pointer
->	O
curs2	long
)	O
break	O
;	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
}	O
}	O
static	O
void	O
edit_delete_to_line_begin	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
while	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
!=	O
'\n'	O
)	O
{	O
if	O
(	O
!	O
edit	pointer
->	O
curs1	long
)	O
break	O
;	O
edit_backspace	function
(	O
edit	pointer
)	O
;	O
}	O
}	O
void	O
edit_delete_line	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
while	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
!=	O
'\n'	O
)	O
{	O
(	O
void	O
)	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
}	O
(	O
void	O
)	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
while	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
!=	O
'\n'	O
)	O
{	O
(	O
void	O
)	O
edit_backspace	function
(	O
edit	pointer
)	O
;	O
}	O
;	O
}	O
static	O
void	O
insert_spaces_tab	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
half	int
)	O
{	O
int	O
i	array
;	O
edit_update_curs_col	function
(	O
edit	pointer
)	O
;	O
i	array
=	O
(	O
(	O
edit	pointer
->	O
curs_col	long
/	O
(	O
option_tab_spacing	int
*	O
space_width	int
/	O
(	O
half	int
+	O
1	int
)	O
)	O
)	O
+	O
1	int
)	O
*	O
(	O
option_tab_spacing	int
*	O
space_width	int
/	O
(	O
half	int
+	O
1	int
)	O
)	O
-	O
edit	pointer
->	O
curs_col	long
;	O
while	O
(	O
i	array
>	O
0	int
)	O
{	O
edit_insert	function
(	O
edit	pointer
,	O
' '	O
)	O
;	O
i	array
-=	O
space_width	int
;	O
}	O
}	O
static	O
int	O
is_aligned_on_a_tab	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_update_curs_col	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
(	O
edit	pointer
->	O
curs_col	long
%	O
(	O
TAB_SIZE	O
*	O
space_width	int
)	O
)	O
&&	O
edit	pointer
->	O
curs_col	long
%	O
(	O
TAB_SIZE	O
*	O
space_width	int
)	O
!=	O
(	O
HALF_TAB_SIZE	O
*	O
space_width	int
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
right_of_four_spaces	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
i	array
,	O
ch	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
1	int
;	O
i	array
<=	O
HALF_TAB_SIZE	O
;	O
i	array
++	O
)	O
ch	int
|=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
-	O
i	array
)	O
;	O
if	O
(	O
ch	int
==	O
' '	O
)	O
return	O
is_aligned_on_a_tab	function
(	O
edit	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
left_of_four_spaces	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
i	array
,	O
ch	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
HALF_TAB_SIZE	O
;	O
i	array
++	O
)	O
ch	int
|=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
+	O
i	array
)	O
;	O
if	O
(	O
ch	int
==	O
' '	O
)	O
return	O
is_aligned_on_a_tab	function
(	O
edit	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
edit_indent_width	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
long	O
p	pointer
)	O
{	O
long	O
q	long
=	O
p	pointer
;	O
while	O
(	O
strchr	function
(	O
"\t "	pointer
,	O
edit_get_byte	function
(	O
edit	pointer
,	O
q	long
)	O
)	O
&&	O
q	long
<	O
edit	pointer
->	O
last_byte	long
-	O
1	int
)	O
q	long
++	O
;	O
return	O
edit_move_forward3	function
(	O
edit	pointer
,	O
p	pointer
,	O
0	int
,	O
q	long
)	O
;	O
}	O
void	O
edit_insert_indent	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
indent	int
)	O
{	O
if	O
(	O
!	O
option_fill_tabs_with_spaces	int
)	O
{	O
while	O
(	O
indent	int
>=	O
TAB_SIZE	O
)	O
{	O
edit_insert	function
(	O
edit	pointer
,	O
'\t'	O
)	O
;	O
indent	int
-=	O
TAB_SIZE	O
;	O
}	O
}	O
while	O
(	O
indent	int
--	O
>	O
0	int
)	O
edit_insert	function
(	O
edit	pointer
,	O
' '	O
)	O
;	O
}	O
static	O
void	O
edit_auto_indent	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
p	pointer
;	O
char	O
c	int
;	O
p	pointer
=	O
edit	pointer
->	O
curs1	long
;	O
p	pointer
=	O
edit_move_backward	function
(	O
edit	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
p	pointer
++	O
)	O
;	O
if	O
(	O
c	int
!=	O
' '	O
&&	O
c	int
!=	O
'\t'	O
)	O
break	O
;	O
edit_insert	function
(	O
edit	pointer
,	O
c	int
)	O
;	O
}	O
}	O
static	O
void	O
edit_double_newline	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_insert	function
(	O
edit	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
==	O
'\n'	O
)	O
return	O
;	O
if	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
-	O
2	int
)	O
==	O
'\n'	O
)	O
return	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit_insert	function
(	O
edit	pointer
,	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
edit_tab_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
i	array
;	O
if	O
(	O
option_fake_half_tabs	int
)	O
{	O
if	O
(	O
is_in_indent	function
(	O
edit	pointer
)	O
)	O
{	O
if	O
(	O
!	O
option_fill_tabs_with_spaces	int
&&	O
right_of_four_spaces	function
(	O
edit	pointer
)	O
)	O
{	O
for	O
(	O
i	array
=	O
1	int
;	O
i	array
<=	O
HALF_TAB_SIZE	O
;	O
i	array
++	O
)	O
edit_backspace	function
(	O
edit	pointer
)	O
;	O
edit_insert	function
(	O
edit	pointer
,	O
'\t'	O
)	O
;	O
}	O
else	O
{	O
insert_spaces_tab	function
(	O
edit	pointer
,	O
1	int
)	O
;	O
}	O
return	O
;	O
}	O
}	O
if	O
(	O
option_fill_tabs_with_spaces	int
)	O
{	O
insert_spaces_tab	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
edit_insert	function
(	O
edit	pointer
,	O
'\t'	O
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
check_and_wrap_line	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
int	O
curs	int
,	O
c	int
;	O
if	O
(	O
!	O
option_typewriter_wrap	int
)	O
return	O
;	O
edit_update_curs_col	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
edit	pointer
->	O
curs_col	long
<	O
option_word_wrap_line_length	int
)	O
return	O
;	O
curs	int
=	O
edit	pointer
->	O
curs1	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
curs	int
--	O
;	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
curs	int
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
curs	int
<=	O
0	int
)	O
{	O
edit_insert	function
(	O
edit	pointer
,	O
'\n'	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
c	int
==	O
' '	O
||	O
c	int
==	O
'\t'	O
)	O
{	O
int	O
current	long
=	O
edit	pointer
->	O
curs1	long
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
curs	int
-	O
edit	pointer
->	O
curs1	long
+	O
1	int
)	O
;	O
edit_insert	function
(	O
edit	pointer
,	O
'\n'	O
)	O
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
current	long
-	O
edit	pointer
->	O
curs1	long
+	O
1	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
edit_execute_macro	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
struct	O
macro	struct
macro	struct
[	O
]	O
,	O
int	O
n	long
)	O
;	O
void	O
edit_push_key_press	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit_push_action	function
(	O
edit	pointer
,	O
KEY_PRESS	int
+	O
edit	pointer
->	O
start_display	long
)	O
;	O
if	O
(	O
edit	pointer
->	O
mark2	long
==	O
-	O
1	int
)	O
edit_push_action	function
(	O
edit	pointer
,	O
MARK_1	int
+	O
edit	pointer
->	O
mark1	long
)	O
;	O
}	O
static	O
long	O
edit_get_bracket	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
in_screen	int
,	O
unsigned	O
long	O
furthest_bracket_search	long
)	O
{	O
const	O
char	O
*	O
const	O
b	pointer
=	O
"{}{[][()("	pointer
,	O
*	O
p	pointer
;	O
int	O
i	array
=	O
1	int
,	O
a	pointer
,	O
inc	int
=	O
-	O
1	int
,	O
c	int
,	O
d	double
,	O
n	long
=	O
0	int
;	O
unsigned	O
long	O
j	int
=	O
0	int
;	O
long	O
q	long
;	O
edit_update_curs_row	function
(	O
edit	pointer
)	O
;	O
c	int
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
;	O
p	pointer
=	O
strchr	function
(	O
b	pointer
,	O
c	int
)	O
;	O
if	O
(	O
!	O
furthest_bracket_search	long
)	O
furthest_bracket_search	long
--	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
-	O
1	int
;	O
d	double
=	O
p	pointer
[	O
1	int
]	O
;	O
if	O
(	O
strchr	function
(	O
"{[("	pointer
,	O
c	int
)	O
)	O
inc	int
=	O
1	int
;	O
for	O
(	O
q	long
=	O
edit	pointer
->	O
curs1	long
+	O
inc	int
;	O
;	O
q	long
+=	O
inc	int
)	O
{	O
if	O
(	O
q	long
>=	O
edit	pointer
->	O
last_byte	long
||	O
q	long
<	O
0	int
)	O
break	O
;	O
a	pointer
=	O
edit_get_byte	function
(	O
edit	pointer
,	O
q	long
)	O
;	O
if	O
(	O
j	int
++	O
>	O
furthest_bracket_search	long
)	O
break	O
;	O
if	O
(	O
in_screen	int
)	O
{	O
if	O
(	O
q	long
<	O
edit	pointer
->	O
start_display	long
)	O
break	O
;	O
if	O
(	O
inc	int
>	O
0	int
&&	O
a	pointer
==	O
'\n'	O
)	O
if	O
(	O
n	long
++	O
>=	O
edit	pointer
->	O
num_widget_lines	int
-	O
edit	pointer
->	O
curs_row	long
)	O
break	O
;	O
}	O
i	array
+=	O
(	O
a	pointer
==	O
c	int
)	O
-	O
(	O
a	pointer
==	O
d	double
)	O
;	O
if	O
(	O
!	O
i	array
)	O
return	O
q	long
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
long	O
last_bracket	long
=	O
-	O
1	int
;	O
void	O
edit_find_bracket	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
edit	pointer
->	O
bracket	long
=	O
edit_get_bracket	function
(	O
edit	pointer
,	O
1	int
,	O
10000	int
)	O
;	O
if	O
(	O
last_bracket	long
!=	O
edit	pointer
->	O
bracket	long
)	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
last_bracket	long
=	O
edit	pointer
->	O
bracket	long
;	O
}	O
static	O
void	O
edit_goto_matching_bracket	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
long	O
q	long
;	O
q	long
=	O
edit_get_bracket	function
(	O
edit	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
q	long
<	O
0	int
)	O
return	O
;	O
edit	pointer
->	O
bracket	long
=	O
edit	pointer
->	O
curs1	long
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
edit_cursor_move	function
(	O
edit	pointer
,	O
q	long
-	O
edit	pointer
->	O
curs1	long
)	O
;	O
}	O
void	O
edit_execute_key_command	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
command	pointer
,	O
int	O
char_for_insertion	int
)	O
{	O
if	O
(	O
command	pointer
==	O
CK_Begin_Record_Macro	int
)	O
{	O
edit	pointer
->	O
macro_i	int
=	O
0	int
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_CHAR_ONLY	O
|	O
REDRAW_LINE	O
;	O
return	O
;	O
}	O
if	O
(	O
command	pointer
==	O
CK_End_Record_Macro	int
&&	O
edit	pointer
->	O
macro_i	int
!=	O
-	O
1	int
)	O
{	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
edit_save_macro_cmd	function
(	O
edit	pointer
,	O
edit	pointer
->	O
macro	struct
,	O
edit	pointer
->	O
macro_i	int
)	O
;	O
edit	pointer
->	O
macro_i	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
edit	pointer
->	O
macro_i	int
>=	O
0	int
&&	O
edit	pointer
->	O
macro_i	int
<	O
MAX_MACRO_LENGTH	int
-	O
1	int
)	O
{	O
edit	pointer
->	O
macro	struct
[	O
edit	pointer
->	O
macro_i	int
]	O
.	O
command	pointer
=	O
command	pointer
;	O
edit	pointer
->	O
macro	struct
[	O
edit	pointer
->	O
macro_i	int
++	O
]	O
.	O
ch	int
=	O
char_for_insertion	int
;	O
}	O
if	O
(	O
command	pointer
!=	O
CK_Undo	int
&&	O
command	pointer
!=	O
CK_Ext_Mode	int
)	O
edit_push_key_press	function
(	O
edit	pointer
)	O
;	O
edit_execute_cmd	function
(	O
edit	pointer
,	O
command	pointer
,	O
char_for_insertion	int
)	O
;	O
if	O
(	O
column_highlighting	int
)	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
static	O
const	O
char	O
*	O
const	O
shell_cmd	pointer
[	O
]	O
=	O
SHELL_COMMANDS_i	O
;	O
void	O
edit_execute_cmd	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
int	O
command	pointer
,	O
int	O
char_for_insertion	int
)	O
{	O
edit	pointer
->	O
force	int
|=	O
REDRAW_LINE	O
;	O
if	O
(	O
edit	pointer
->	O
found_len	int
||	O
column_highlighting	int
)	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
if	O
(	O
command	pointer
/	O
100	int
==	O
6	int
)	O
{	O
column_highlighting	int
=	O
0	int
;	O
if	O
(	O
!	O
edit	pointer
->	O
highlight	int
||	O
(	O
edit	pointer
->	O
mark2	long
!=	O
-	O
1	int
&&	O
edit	pointer
->	O
mark1	long
!=	O
edit	pointer
->	O
mark2	long
)	O
)	O
{	O
edit_mark_cmd	function
(	O
edit	pointer
,	O
1	int
)	O
;	O
edit_mark_cmd	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
}	O
edit	pointer
->	O
highlight	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
edit	pointer
->	O
highlight	int
)	O
edit_mark_cmd	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
edit	pointer
->	O
highlight	int
=	O
0	int
;	O
}	O
if	O
(	O
command	pointer
==	O
CK_Undo	int
)	O
{	O
edit_do_undo	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
found_len	int
=	O
0	int
;	O
edit	pointer
->	O
prev_col	long
=	O
edit_get_col	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
search_start	long
=	O
edit	pointer
->	O
curs1	long
;	O
return	O
;	O
}	O
if	O
(	O
char_for_insertion	int
>=	O
0	int
)	O
{	O
if	O
(	O
edit	pointer
->	O
overwrite	int
)	O
{	O
if	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
)	O
!=	O
'\n'	O
)	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
}	O
edit_insert	function
(	O
edit	pointer
,	O
char_for_insertion	int
)	O
;	O
if	O
(	O
option_auto_para_formatting	int
)	O
{	O
format_paragraph	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
else	O
check_and_wrap_line	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
found_len	int
=	O
0	int
;	O
edit	pointer
->	O
prev_col	long
=	O
edit_get_col	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
search_start	long
=	O
edit	pointer
->	O
curs1	long
;	O
edit_find_bracket	function
(	O
edit	pointer
)	O
;	O
return	O
;	O
}	O
switch	O
(	O
command	pointer
)	O
{	O
case	O
CK_Begin_Page	int
:	O
case	O
CK_End_Page	int
:	O
case	O
CK_Begin_Page_Highlight	int
:	O
case	O
CK_End_Page_Highlight	int
:	O
case	O
CK_Word_Left	int
:	O
case	O
CK_Word_Right	int
:	O
case	O
CK_Up	int
:	O
case	O
CK_Down	int
:	O
case	O
CK_Word_Left_Highlight	int
:	O
case	O
CK_Word_Right_Highlight	int
:	O
case	O
CK_Up_Highlight	int
:	O
case	O
CK_Down_Highlight	int
:	O
if	O
(	O
edit	pointer
->	O
mark2	long
==	O
-	O
1	int
)	O
break	O
;	O
case	O
CK_Left	int
:	O
case	O
CK_Right	int
:	O
case	O
CK_Left_Highlight	int
:	O
case	O
CK_Right_Highlight	int
:	O
edit	pointer
->	O
force	int
|=	O
REDRAW_CHAR_ONLY	O
;	O
}	O
switch	O
(	O
command	pointer
)	O
{	O
case	O
CK_BackSpace	int
:	O
if	O
(	O
option_backspace_through_tabs	int
&&	O
is_in_indent	function
(	O
edit	pointer
)	O
)	O
{	O
while	O
(	O
edit_get_byte	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs1	long
-	O
1	int
)	O
!=	O
'\n'	O
&&	O
edit	pointer
->	O
curs1	long
>	O
0	int
)	O
edit_backspace	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
option_fake_half_tabs	int
)	O
{	O
int	O
i	array
;	O
if	O
(	O
is_in_indent	function
(	O
edit	pointer
)	O
&&	O
right_of_four_spaces	function
(	O
edit	pointer
)	O
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
HALF_TAB_SIZE	O
;	O
i	array
++	O
)	O
edit_backspace	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
edit_backspace	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Delete	int
:	O
if	O
(	O
option_fake_half_tabs	int
)	O
{	O
int	O
i	array
;	O
if	O
(	O
is_in_indent	function
(	O
edit	pointer
)	O
&&	O
left_of_four_spaces	function
(	O
edit	pointer
)	O
)	O
{	O
for	O
(	O
i	array
=	O
1	int
;	O
i	array
<=	O
HALF_TAB_SIZE	O
;	O
i	array
++	O
)	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
}	O
}	O
edit_delete	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Delete_Word_Left	int
:	O
edit_left_delete_word	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Delete_Word_Right	int
:	O
edit_right_delete_word	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Delete_Line	int
:	O
edit_delete_line	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Delete_To_Line_End	int
:	O
edit_delete_to_line_end	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Delete_To_Line_Begin	int
:	O
edit_delete_to_line_begin	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Enter	int
:	O
if	O
(	O
option_auto_para_formatting	int
)	O
{	O
edit_double_newline	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
option_return_does_auto_indent	int
)	O
edit_auto_indent	function
(	O
edit	pointer
)	O
;	O
format_paragraph	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
edit_insert	function
(	O
edit	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
option_return_does_auto_indent	int
)	O
{	O
edit_auto_indent	function
(	O
edit	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
CK_Return	int
:	O
edit_insert	function
(	O
edit	pointer
,	O
'\n'	O
)	O
;	O
break	O
;	O
case	O
CK_Page_Up	int
:	O
case	O
CK_Page_Up_Highlight	int
:	O
edit_move_up	function
(	O
edit	pointer
,	O
edit	pointer
->	O
num_widget_lines	int
-	O
1	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Page_Down	int
:	O
case	O
CK_Page_Down_Highlight	int
:	O
edit_move_down	function
(	O
edit	pointer
,	O
edit	pointer
->	O
num_widget_lines	int
-	O
1	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Left	int
:	O
case	O
CK_Left_Highlight	int
:	O
if	O
(	O
option_fake_half_tabs	int
)	O
{	O
if	O
(	O
is_in_indent	function
(	O
edit	pointer
)	O
&&	O
right_of_four_spaces	function
(	O
edit	pointer
)	O
)	O
{	O
edit_cursor_move	function
(	O
edit	pointer
,	O
-	O
HALF_TAB_SIZE	O
)	O
;	O
edit	pointer
->	O
force	int
&=	O
(	O
0xFFF	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
break	O
;	O
}	O
}	O
edit_cursor_move	function
(	O
edit	pointer
,	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Right	int
:	O
case	O
CK_Right_Highlight	int
:	O
if	O
(	O
option_fake_half_tabs	int
)	O
{	O
if	O
(	O
is_in_indent	function
(	O
edit	pointer
)	O
&&	O
left_of_four_spaces	function
(	O
edit	pointer
)	O
)	O
{	O
edit_cursor_move	function
(	O
edit	pointer
,	O
HALF_TAB_SIZE	O
)	O
;	O
edit	pointer
->	O
force	int
&=	O
(	O
0xFFF	int
-	O
REDRAW_CHAR_ONLY	O
)	O
;	O
break	O
;	O
}	O
}	O
edit_cursor_move	function
(	O
edit	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Begin_Page	int
:	O
case	O
CK_Begin_Page_Highlight	int
:	O
edit_begin_page	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_End_Page	int
:	O
case	O
CK_End_Page_Highlight	int
:	O
edit_end_page	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Word_Left	int
:	O
case	O
CK_Word_Left_Highlight	int
:	O
edit_left_word_move_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Word_Right	int
:	O
case	O
CK_Word_Right_Highlight	int
:	O
edit_right_word_move_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Up	int
:	O
case	O
CK_Up_Highlight	int
:	O
edit_move_up	function
(	O
edit	pointer
,	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Down	int
:	O
case	O
CK_Down_Highlight	int
:	O
edit_move_down	function
(	O
edit	pointer
,	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Paragraph_Up	int
:	O
case	O
CK_Paragraph_Up_Highlight	int
:	O
edit_move_up_paragraph	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Paragraph_Down	int
:	O
case	O
CK_Paragraph_Down_Highlight	int
:	O
edit_move_down_paragraph	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Scroll_Up	int
:	O
case	O
CK_Scroll_Up_Highlight	int
:	O
edit_move_up	function
(	O
edit	pointer
,	O
1	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Scroll_Down	int
:	O
case	O
CK_Scroll_Down_Highlight	int
:	O
edit_move_down	function
(	O
edit	pointer
,	O
1	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Home	int
:	O
case	O
CK_Home_Highlight	int
:	O
edit_cursor_to_bol	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_End	int
:	O
case	O
CK_End_Highlight	int
:	O
edit_cursor_to_eol	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Tab	int
:	O
edit_tab_cmd	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
option_auto_para_formatting	int
)	O
{	O
format_paragraph	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
else	O
check_and_wrap_line	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Toggle_Insert	int
:	O
edit	pointer
->	O
overwrite	int
=	O
(	O
edit	pointer
->	O
overwrite	int
==	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Mark	int
:	O
if	O
(	O
edit	pointer
->	O
mark2	long
>=	O
0	int
)	O
{	O
if	O
(	O
column_highlighting	int
)	O
edit_push_action	function
(	O
edit	pointer
,	O
COLUMN_ON	int
)	O
;	O
column_highlighting	int
=	O
0	int
;	O
}	O
edit_mark_cmd	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Column_Mark	int
:	O
if	O
(	O
!	O
column_highlighting	int
)	O
edit_push_action	function
(	O
edit	pointer
,	O
COLUMN_OFF	int
)	O
;	O
column_highlighting	int
=	O
1	int
;	O
edit_mark_cmd	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Unmark	int
:	O
if	O
(	O
column_highlighting	int
)	O
edit_push_action	function
(	O
edit	pointer
,	O
COLUMN_ON	int
)	O
;	O
column_highlighting	int
=	O
0	int
;	O
edit_mark_cmd	function
(	O
edit	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Toggle_Bookmark	int
:	O
book_mark_clear	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
,	O
BOOK_MARK_FOUND_COLOR	O
)	O
;	O
if	O
(	O
book_mark_query_color	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
,	O
BOOK_MARK_COLOR	O
)	O
)	O
book_mark_clear	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
,	O
BOOK_MARK_COLOR	O
)	O
;	O
else	O
book_mark_insert	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
,	O
BOOK_MARK_COLOR	O
)	O
;	O
break	O
;	O
case	O
CK_Flush_Bookmarks	int
:	O
book_mark_flush	function
(	O
edit	pointer
,	O
BOOK_MARK_COLOR	O
)	O
;	O
book_mark_flush	function
(	O
edit	pointer
,	O
BOOK_MARK_FOUND_COLOR	O
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
break	O
;	O
case	O
CK_Next_Bookmark	int
:	O
if	O
(	O
edit	pointer
->	O
book_mark	pointer
)	O
{	O
struct	O
_book_mark	struct
*	O
p	pointer
;	O
p	pointer
=	O
(	O
struct	O
_book_mark	struct
*	O
)	O
book_mark_find	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
)	O
;	O
if	O
(	O
p	pointer
->	O
next	pointer
)	O
{	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
if	O
(	O
p	pointer
->	O
line	int
>=	O
edit	pointer
->	O
start_line	long
+	O
edit	pointer
->	O
num_widget_lines	int
||	O
p	pointer
->	O
line	int
<	O
edit	pointer
->	O
start_line	long
)	O
edit_move_display	function
(	O
edit	pointer
,	O
p	pointer
->	O
line	int
-	O
edit	pointer
->	O
num_widget_lines	int
/	O
2	int
)	O
;	O
edit_move_to_line	function
(	O
edit	pointer
,	O
p	pointer
->	O
line	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
CK_Prev_Bookmark	int
:	O
if	O
(	O
edit	pointer
->	O
book_mark	pointer
)	O
{	O
struct	O
_book_mark	struct
*	O
p	pointer
;	O
p	pointer
=	O
(	O
struct	O
_book_mark	struct
*	O
)	O
book_mark_find	function
(	O
edit	pointer
,	O
edit	pointer
->	O
curs_line	long
)	O
;	O
while	O
(	O
p	pointer
->	O
line	int
==	O
edit	pointer
->	O
curs_line	long
)	O
if	O
(	O
p	pointer
->	O
prev	pointer
)	O
p	pointer
=	O
p	pointer
->	O
prev	pointer
;	O
if	O
(	O
p	pointer
->	O
line	int
>=	O
0	int
)	O
{	O
if	O
(	O
p	pointer
->	O
line	int
>=	O
edit	pointer
->	O
start_line	long
+	O
edit	pointer
->	O
num_widget_lines	int
||	O
p	pointer
->	O
line	int
<	O
edit	pointer
->	O
start_line	long
)	O
edit_move_display	function
(	O
edit	pointer
,	O
p	pointer
->	O
line	int
-	O
edit	pointer
->	O
num_widget_lines	int
/	O
2	int
)	O
;	O
edit_move_to_line	function
(	O
edit	pointer
,	O
p	pointer
->	O
line	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
CK_Beginning_Of_Text	int
:	O
case	O
CK_Beginning_Of_Text_Highlight	int
:	O
edit_move_to_top	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_End_Of_Text	int
:	O
case	O
CK_End_Of_Text_Highlight	int
:	O
edit_move_to_bottom	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Copy	int
:	O
edit_block_copy_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Remove	int
:	O
edit_block_delete_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Move	int
:	O
edit_block_move_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_XStore	int
:	O
edit_copy_to_X_buf_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_XCut	int
:	O
edit_cut_to_X_buf_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_XPaste	int
:	O
edit_paste_from_X_buf_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Selection_History	int
:	O
edit_paste_from_history	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Save_As	int
:	O
edit_save_as_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Save	int
:	O
edit_save_confirm_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Load	int
:	O
edit_load_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Save_Block	int
:	O
edit_save_block_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Insert_File	int
:	O
edit_insert_file_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Toggle_Syntax	int
:	O
if	O
(	O
(	O
option_syntax_highlighting	int
^=	O
1	int
)	O
==	O
1	int
)	O
edit_load_syntax	function
(	O
edit	pointer
,	O
NULL	O
,	O
option_syntax_type	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
break	O
;	O
case	O
CK_Find	int
:	O
edit_search_cmd	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Find_Again	int
:	O
edit_search_cmd	function
(	O
edit	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Replace	int
:	O
edit_replace_cmd	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
CK_Replace_Again	int
:	O
edit_replace_cmd	function
(	O
edit	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
CK_Complete_Word	int
:	O
edit_complete_word_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Exit	int
:	O
dlg_stop	function
(	O
edit	pointer
->	O
widget	pointer
.	O
parent	pointer
)	O
;	O
break	O
;	O
case	O
CK_New	int
:	O
edit_new_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Help	int
:	O
edit_help_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Refresh	int
:	O
edit_refresh_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Date	int
:	O
{	O
time_t	long
t	long
;	O
char	O
s	pointer
[	O
1024	int
]	O
;	O
char	O
time_format	array
[	O
]	O
=	O
"_c"	pointer
;	O
time_format	array
[	O
0	int
]	O
=	O
'%'	O
;	O
time	long
(	O
&	O
t	long
)	O
;	O
strftime	function
(	O
s	pointer
,	O
sizeof	O
(	O
s	pointer
)	O
,	O
time_format	array
,	O
localtime	function
(	O
&	O
t	long
)	O
)	O
;	O
edit_print_string	function
(	O
edit	pointer
,	O
s	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
break	O
;	O
}	O
case	O
CK_Goto	int
:	O
edit_goto_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Paragraph_Format	int
:	O
format_paragraph	function
(	O
edit	pointer
,	O
1	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
break	O
;	O
case	O
CK_Delete_Macro	int
:	O
edit_delete_macro_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Match_Bracket	int
:	O
edit_goto_matching_bracket	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_User_Menu	int
:	O
user_menu	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Sort	int
:	O
edit_sort_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_ExtCmd	int
:	O
edit_ext_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Mail	int
:	O
edit_mail_dialog	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Shell	int
:	O
view_other_cmd	function
(	O
)	O
;	O
break	O
;	O
case	O
CK_Select_Codepage	int
:	O
edit_select_codepage_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Insert_Literal	int
:	O
edit_insert_literal_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Execute_Macro	int
:	O
edit_execute_macro_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Begin_End_Macro	int
:	O
edit_begin_end_macro_cmd	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Ext_Mode	int
:	O
edit	pointer
->	O
extmod	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
(	O
command	pointer
/	O
1000	int
)	O
==	O
1	int
)	O
edit_block_process_cmd	function
(	O
edit	pointer
,	O
shell_cmd	pointer
[	O
command	pointer
-	O
1000	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
command	pointer
>	O
CK_Macro	O
(	O
0	int
)	O
&&	O
command	pointer
<=	O
CK_Last_Macro	O
)	O
{	O
struct	O
macro	struct
m	int
[	O
MAX_MACRO_LENGTH	int
]	O
;	O
int	O
nm	int
;	O
if	O
(	O
edit_load_macro_cmd	function
(	O
edit	pointer
,	O
m	int
,	O
&	O
nm	int
,	O
command	pointer
-	O
2000	int
)	O
)	O
edit_execute_macro	function
(	O
edit	pointer
,	O
m	int
,	O
nm	int
)	O
;	O
}	O
switch	O
(	O
command	pointer
)	O
{	O
case	O
CK_Find	int
:	O
case	O
CK_Find_Again	int
:	O
case	O
CK_Replace	int
:	O
case	O
CK_Replace_Again	int
:	O
case	O
CK_Complete_Word	int
:	O
edit	pointer
->	O
prev_col	long
=	O
edit_get_col	function
(	O
edit	pointer
)	O
;	O
break	O
;	O
case	O
CK_Up	int
:	O
case	O
CK_Up_Highlight	int
:	O
case	O
CK_Down	int
:	O
case	O
CK_Down_Highlight	int
:	O
case	O
CK_Page_Up	int
:	O
case	O
CK_Page_Up_Highlight	int
:	O
case	O
CK_Page_Down	int
:	O
case	O
CK_Page_Down_Highlight	int
:	O
case	O
CK_Beginning_Of_Text	int
:	O
case	O
CK_Beginning_Of_Text_Highlight	int
:	O
case	O
CK_End_Of_Text	int
:	O
case	O
CK_End_Of_Text_Highlight	int
:	O
case	O
CK_Paragraph_Up	int
:	O
case	O
CK_Paragraph_Up_Highlight	int
:	O
case	O
CK_Paragraph_Down	int
:	O
case	O
CK_Paragraph_Down_Highlight	int
:	O
case	O
CK_Scroll_Up	int
:	O
case	O
CK_Scroll_Up_Highlight	int
:	O
case	O
CK_Scroll_Down	int
:	O
case	O
CK_Scroll_Down_Highlight	int
:	O
edit	pointer
->	O
search_start	long
=	O
edit	pointer
->	O
curs1	long
;	O
edit	pointer
->	O
found_len	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
edit	pointer
->	O
found_len	int
=	O
0	int
;	O
edit	pointer
->	O
prev_col	long
=	O
edit_get_col	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
search_start	long
=	O
edit	pointer
->	O
curs1	long
;	O
}	O
edit_find_bracket	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
option_auto_para_formatting	int
)	O
{	O
switch	O
(	O
command	pointer
)	O
{	O
case	O
CK_BackSpace	int
:	O
case	O
CK_Delete	int
:	O
case	O
CK_Delete_Word_Left	int
:	O
case	O
CK_Delete_Word_Right	int
:	O
case	O
CK_Delete_To_Line_End	int
:	O
case	O
CK_Delete_To_Line_Begin	int
:	O
format_paragraph	function
(	O
edit	pointer
,	O
0	int
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
}	O
}	O
}	O
static	O
void	O
edit_execute_macro	function
(	O
WEdit	struct
*	O
edit	pointer
,	O
struct	O
macro	struct
macro	struct
[	O
]	O
,	O
int	O
n	long
)	O
{	O
int	O
i	array
=	O
0	int
;	O
if	O
(	O
edit	pointer
->	O
macro_depth	int
++	O
>	O
256	int
)	O
{	O
edit_error_dialog	O
(	O
_	O
(	O
"Error"	pointer
)	O
,	O
_	O
(	O
"Macro recursion is too deep"	pointer
)	O
)	O
;	O
edit	pointer
->	O
macro_depth	int
--	O
;	O
return	O
;	O
}	O
edit	pointer
->	O
force	int
|=	O
REDRAW_PAGE	O
;	O
for	O
(	O
;	O
i	array
<	O
n	long
;	O
i	array
++	O
)	O
{	O
edit_execute_cmd	function
(	O
edit	pointer
,	O
macro	struct
[	O
i	array
]	O
.	O
command	pointer
,	O
macro	struct
[	O
i	array
]	O
.	O
ch	int
)	O
;	O
}	O
edit_update_screen	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
macro_depth	int
--	O
;	O
}	O
static	O
void	O
user_menu	function
(	O
WEdit	struct
*	O
edit	pointer
)	O
{	O
FILE	struct
*	O
fd	int
;	O
int	O
nomark	int
;	O
struct	O
stat	struct
status	int
;	O
long	O
start_mark	pointer
,	O
end_mark	pointer
;	O
char	O
*	O
block_file	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
BLOCK_FILE	O
)	O
;	O
int	O
rc	pointer
=	O
0	int
;	O
nomark	int
=	O
eval_marks	function
(	O
edit	pointer
,	O
&	O
start_mark	pointer
,	O
&	O
end_mark	pointer
)	O
;	O
if	O
(	O
!	O
nomark	int
)	O
edit_save_block	function
(	O
edit	pointer
,	O
block_file	pointer
,	O
start_mark	pointer
,	O
end_mark	pointer
)	O
;	O
user_menu_cmd	function
(	O
edit	pointer
)	O
;	O
if	O
(	O
mc_stat	function
(	O
block_file	pointer
,	O
&	O
status	int
)	O
!=	O
0	int
||	O
!	O
status	int
.	O
st_size	long
)	O
{	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
!	O
nomark	int
)	O
{	O
rc	pointer
=	O
edit_block_delete_cmd	function
(	O
edit	pointer
)	O
;	O
}	O
if	O
(	O
!	O
rc	pointer
)	O
{	O
edit_insert_file	function
(	O
edit	pointer
,	O
block_file	pointer
)	O
;	O
}	O
if	O
(	O
(	O
fd	int
=	O
fopen	function
(	O
block_file	pointer
,	O
"w"	pointer
)	O
)	O
)	O
{	O
fclose	function
(	O
fd	int
)	O
;	O
}	O
edit_refresh_cmd	function
(	O
edit	pointer
)	O
;	O
edit	pointer
->	O
force	int
|=	O
REDRAW_COMPLETELY	O
;	O
cleanup	O
:	O
g_free	function
(	O
block_file	pointer
)	O
;	O
}	O
