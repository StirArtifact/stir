static	O
unsigned	O
char	O
header_magic	array
[	O
4	int
]	O
=	O
{	O
0x8e	int
,	O
0xad	int
,	O
0xe8	int
,	O
0x01	int
}	O
;	O
static	O
int	O
typeSizes	array
[	O
]	O
=	O
{	O
-	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
4	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
}	O
;	O
struct	O
headerToken	struct
{	O
struct	O
indexEntry	struct
*	O
index	function
;	O
int	O
indexUsed	int
;	O
int	O
indexAlloced	int
;	O
int	O
sorted	int
;	O
int	O
usageCount	int
;	O
}	O
;	O
struct	O
entryInfo	struct
{	O
int_32	int
tag	int
;	O
int_32	int
type	enum
;	O
int_32	int
offset	long
;	O
int_32	int
count	long
;	O
}	O
;	O
struct	O
indexEntry	struct
{	O
struct	O
entryInfo	struct
info	struct
;	O
void	O
*	O
data	pointer
;	O
int	O
length	int
;	O
}	O
;	O
struct	O
sprintfTag	struct
{	O
headerTagTagFunction	pointer
ext	pointer
;	O
int	O
extNum	int
;	O
int_32	int
tag	int
;	O
int	O
justOne	int
;	O
int	O
arrayCount	int
;	O
char	O
*	O
format	pointer
;	O
char	O
*	O
type	enum
;	O
int	O
pad	int
;	O
}	O
;	O
struct	O
extensionCache	struct
{	O
int_32	int
type	enum
;	O
int_32	int
count	long
;	O
int	O
avail	int
;	O
int	O
freeit	int
;	O
const	O
void	O
*	O
data	pointer
;	O
}	O
;	O
struct	O
sprintfToken	struct
{	O
enum	O
{	O
PTOK_NONE	int
=	O
0	int
,	O
PTOK_TAG	int
,	O
PTOK_ARRAY	int
,	O
PTOK_STRING	int
,	O
PTOK_COND	int
}	O
type	enum
;	O
union	O
{	O
struct	O
{	O
struct	O
sprintfToken	struct
*	O
format	pointer
;	O
int	O
numTokens	int
;	O
}	O
array	struct
;	O
struct	O
sprintfTag	struct
tag	int
;	O
struct	O
{	O
char	O
*	O
string	pointer
;	O
int	O
len	int
;	O
}	O
string	pointer
;	O
struct	O
{	O
struct	O
sprintfToken	struct
*	O
ifFormat	pointer
;	O
int	O
numIfTokens	int
;	O
struct	O
sprintfToken	struct
*	O
elseFormat	pointer
;	O
int	O
numElseTokens	int
;	O
struct	O
sprintfTag	struct
tag	int
;	O
}	O
cond	struct
;	O
}	O
u	union
;	O
}	O
;	O
static	O
int	O
probe_headers	int
=	O
0	int
;	O
static	O
void	O
headerProbeAddr	function
(	O
Header	pointer
h	pointer
,	O
const	O
char	O
*	O
msg	pointer
,	O
void	O
*	O
p	pointer
,	O
const	O
char	O
*	O
imsg	pointer
)	O
{	O
const	O
char	O
*	O
mchkstr	pointer
=	O
NULL	O
;	O
switch	O
(	O
mprobe	function
(	O
p	pointer
)	O
)	O
{	O
case	O
MCHECK_DISABLED	int
:	O
case	O
MCHECK_OK	int
:	O
return	O
;	O
break	O
;	O
case	O
MCHECK_HEAD	int
:	O
mchkstr	pointer
=	O
"HEAD"	pointer
;	O
break	O
;	O
case	O
MCHECK_TAIL	int
:	O
mchkstr	pointer
=	O
"TAIL"	pointer
;	O
break	O
;	O
case	O
MCHECK_FREE	int
:	O
mchkstr	pointer
=	O
"FREE"	pointer
;	O
break	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"*** MCHECK_%s h %p"	pointer
,	O
mchkstr	pointer
,	O
h	pointer
)	O
;	O
if	O
(	O
imsg	pointer
&&	O
p	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
" %s %p"	pointer
,	O
imsg	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
msg	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
" %s"	pointer
,	O
msg	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
headerProbe	function
(	O
Header	pointer
h	pointer
,	O
const	O
char	O
*	O
msg	pointer
)	O
{	O
char	O
imsg	pointer
[	O
256	int
]	O
;	O
int	O
i	int
;	O
headerProbeAddr	function
(	O
h	pointer
,	O
msg	pointer
,	O
h	pointer
,	O
"header"	pointer
)	O
;	O
sprintf	function
(	O
imsg	pointer
,	O
"index (used %d)"	pointer
,	O
h	pointer
->	O
indexUsed	int
)	O
;	O
headerProbeAddr	function
(	O
h	pointer
,	O
msg	pointer
,	O
h	pointer
->	O
index	function
,	O
imsg	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
h	pointer
->	O
indexUsed	int
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
imsg	pointer
,	O
"index[%d:%d].data"	pointer
,	O
i	int
,	O
h	pointer
->	O
indexUsed	int
)	O
;	O
headerProbeAddr	function
(	O
h	pointer
,	O
msg	pointer
,	O
h	pointer
->	O
index	function
[	O
i	int
]	O
.	O
data	pointer
,	O
imsg	pointer
)	O
;	O
}	O
}	O
static	O
void	O
copyEntry	function
(	O
struct	O
indexEntry	struct
*	O
entry	pointer
,	O
int_32	int
*	O
type	enum
,	O
void	O
*	O
*	O
p	pointer
,	O
int_32	int
*	O
c	int
,	O
int	O
minimizeMemory	int
)	O
{	O
int	O
i	int
,	O
tableSize	int
;	O
char	O
*	O
*	O
ptrEntry	pointer
;	O
char	O
*	O
chptr	pointer
;	O
if	O
(	O
type	enum
)	O
*	O
type	enum
=	O
entry	pointer
->	O
info	struct
.	O
type	enum
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
entry	pointer
->	O
info	struct
.	O
count	long
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
;	O
switch	O
(	O
entry	pointer
->	O
info	struct
.	O
type	enum
)	O
{	O
case	O
RPM_STRING_TYPE	int
:	O
if	O
(	O
entry	pointer
->	O
info	struct
.	O
count	long
==	O
1	int
)	O
{	O
*	O
p	pointer
=	O
entry	pointer
->	O
data	pointer
;	O
break	O
;	O
}	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
i	int
=	O
entry	pointer
->	O
info	struct
.	O
count	long
;	O
tableSize	int
=	O
i	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
;	O
if	O
(	O
minimizeMemory	int
)	O
{	O
ptrEntry	pointer
=	O
*	O
p	pointer
=	O
xmalloc	function
(	O
tableSize	int
)	O
;	O
chptr	pointer
=	O
entry	pointer
->	O
data	pointer
;	O
}	O
else	O
{	O
ptrEntry	pointer
=	O
*	O
p	pointer
=	O
xmalloc	function
(	O
tableSize	int
+	O
entry	pointer
->	O
length	int
)	O
;	O
chptr	pointer
=	O
(	O
(	O
char	O
*	O
)	O
*	O
p	pointer
)	O
+	O
tableSize	int
;	O
memcpy	function
(	O
chptr	pointer
,	O
entry	pointer
->	O
data	pointer
,	O
entry	pointer
->	O
length	int
)	O
;	O
}	O
while	O
(	O
i	int
--	O
)	O
{	O
*	O
ptrEntry	pointer
++	O
=	O
chptr	pointer
;	O
chptr	pointer
=	O
strchr	function
(	O
chptr	pointer
,	O
0	int
)	O
;	O
chptr	pointer
++	O
;	O
}	O
break	O
;	O
default	O
:	O
*	O
p	pointer
=	O
entry	pointer
->	O
data	pointer
;	O
break	O
;	O
}	O
}	O
static	O
int	O
dataLength	function
(	O
int_32	int
type	enum
,	O
const	O
void	O
*	O
p	pointer
,	O
int_32	int
count	long
,	O
int	O
onDisk	int
)	O
{	O
int	O
thisLen	int
,	O
length	int
,	O
i	int
;	O
char	O
*	O
*	O
src	pointer
,	O
*	O
chptr	pointer
;	O
length	int
=	O
0	int
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
RPM_STRING_TYPE	int
:	O
if	O
(	O
count	long
==	O
1	int
)	O
{	O
length	int
=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
;	O
break	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"grabData() RPM_STRING_TYPE count must be 1.\n"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
i	int
=	O
count	long
;	O
length	int
=	O
0	int
;	O
if	O
(	O
onDisk	int
)	O
{	O
chptr	pointer
=	O
(	O
char	O
*	O
)	O
p	pointer
;	O
while	O
(	O
i	int
--	O
)	O
{	O
thisLen	int
=	O
strlen	function
(	O
chptr	pointer
)	O
+	O
1	int
;	O
length	int
+=	O
thisLen	int
;	O
chptr	pointer
+=	O
thisLen	int
;	O
}	O
}	O
else	O
{	O
src	pointer
=	O
(	O
char	O
*	O
*	O
)	O
p	pointer
;	O
while	O
(	O
i	int
--	O
)	O
{	O
length	int
+=	O
strlen	function
(	O
*	O
src	pointer
++	O
)	O
+	O
1	int
;	O
}	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
typeSizes	array
[	O
type	enum
]	O
!=	O
-	O
1	int
)	O
length	int
=	O
typeSizes	array
[	O
type	enum
]	O
*	O
count	long
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Data type %d not supported\n"	pointer
)	O
,	O
(	O
int	O
)	O
type	enum
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
}	O
return	O
length	int
;	O
}	O
struct	O
headerIteratorS	struct
{	O
Header	pointer
h	pointer
;	O
int	O
next_index	int
;	O
}	O
;	O
HeaderIterator	pointer
headerInitIterator	function
(	O
Header	pointer
h	pointer
)	O
{	O
HeaderIterator	pointer
hi	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
headerIteratorS	struct
)	O
)	O
;	O
headerSort	function
(	O
h	pointer
)	O
;	O
hi	pointer
->	O
h	pointer
=	O
headerLink	function
(	O
h	pointer
)	O
;	O
hi	pointer
->	O
next_index	int
=	O
0	int
;	O
return	O
hi	pointer
;	O
}	O
void	O
headerFreeIterator	function
(	O
HeaderIterator	pointer
iter	pointer
)	O
{	O
headerFree	function
(	O
iter	pointer
->	O
h	pointer
)	O
;	O
free	function
(	O
iter	pointer
)	O
;	O
}	O
int	O
headerNextIterator	function
(	O
HeaderIterator	pointer
iter	pointer
,	O
int_32	int
*	O
tag	int
,	O
int_32	int
*	O
type	enum
,	O
void	O
*	O
*	O
p	pointer
,	O
int_32	int
*	O
c	int
)	O
{	O
Header	pointer
h	pointer
=	O
iter	pointer
->	O
h	pointer
;	O
int	O
slot	int
=	O
iter	pointer
->	O
next_index	int
;	O
if	O
(	O
slot	int
==	O
h	pointer
->	O
indexUsed	int
)	O
{	O
return	O
0	int
;	O
}	O
iter	pointer
->	O
next_index	int
++	O
;	O
if	O
(	O
tag	int
)	O
{	O
*	O
tag	int
=	O
h	pointer
->	O
index	function
[	O
slot	int
]	O
.	O
info	struct
.	O
tag	int
;	O
}	O
copyEntry	function
(	O
h	pointer
->	O
index	function
+	O
slot	int
,	O
type	enum
,	O
p	pointer
,	O
c	int
,	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
indexCmp	function
(	O
const	O
void	O
*	O
ap	pointer
,	O
const	O
void	O
*	O
bp	pointer
)	O
{	O
int_32	int
a	int
,	O
b	int
;	O
a	int
=	O
(	O
(	O
struct	O
indexEntry	struct
*	O
)	O
ap	pointer
)	O
->	O
info	struct
.	O
tag	int
;	O
b	int
=	O
(	O
(	O
struct	O
indexEntry	struct
*	O
)	O
bp	pointer
)	O
->	O
info	struct
.	O
tag	int
;	O
if	O
(	O
a	int
>	O
b	int
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
a	int
<	O
b	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
void	O
headerSort	function
(	O
Header	pointer
h	pointer
)	O
{	O
if	O
(	O
!	O
h	pointer
->	O
sorted	int
)	O
{	O
qsort	function
(	O
h	pointer
->	O
index	function
,	O
h	pointer
->	O
indexUsed	int
,	O
sizeof	O
(	O
struct	O
indexEntry	struct
)	O
,	O
indexCmp	function
)	O
;	O
h	pointer
->	O
sorted	int
=	O
1	int
;	O
}	O
}	O
Header	pointer
headerCopy	function
(	O
Header	pointer
h	pointer
)	O
{	O
int_32	int
tag	int
,	O
type	enum
,	O
count	long
;	O
void	O
*	O
ptr	pointer
;	O
HeaderIterator	pointer
headerIter	pointer
;	O
Header	pointer
res	pointer
=	O
headerNew	function
(	O
)	O
;	O
headerIter	pointer
=	O
headerInitIterator	function
(	O
h	pointer
)	O
;	O
while	O
(	O
headerNextIterator	function
(	O
headerIter	pointer
,	O
&	O
tag	int
,	O
&	O
type	enum
,	O
&	O
ptr	pointer
,	O
&	O
count	long
)	O
)	O
{	O
headerAddEntry	function
(	O
res	pointer
,	O
tag	int
,	O
type	enum
,	O
ptr	pointer
,	O
count	long
)	O
;	O
if	O
(	O
type	enum
==	O
RPM_STRING_ARRAY_TYPE	int
||	O
type	enum
==	O
RPM_I18NSTRING_TYPE	int
)	O
free	function
(	O
ptr	pointer
)	O
;	O
}	O
res	pointer
->	O
sorted	int
=	O
1	int
;	O
headerFreeIterator	function
(	O
headerIter	pointer
)	O
;	O
return	O
res	pointer
;	O
}	O
Header	pointer
headerLoad	function
(	O
void	O
*	O
pv	pointer
)	O
{	O
int_32	int
il	int
;	O
char	O
*	O
p	pointer
=	O
pv	pointer
;	O
const	O
char	O
*	O
dataStart	pointer
;	O
struct	O
entryInfo	struct
*	O
pe	pointer
;	O
struct	O
indexEntry	struct
*	O
entry	pointer
;	O
struct	O
headerToken	struct
*	O
h	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
headerToken	struct
)	O
)	O
;	O
const	O
char	O
*	O
src	pointer
;	O
char	O
*	O
dst	pointer
;	O
int	O
i	int
;	O
int	O
count	long
;	O
il	int
=	O
ntohl	function
(	O
*	O
(	O
(	O
int_32	int
*	O
)	O
p	pointer
)	O
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
h	pointer
->	O
indexAlloced	int
=	O
il	int
;	O
h	pointer
->	O
indexUsed	int
=	O
il	int
;	O
h	pointer
->	O
index	function
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
indexEntry	struct
)	O
*	O
il	int
)	O
;	O
h	pointer
->	O
usageCount	int
=	O
1	int
;	O
h	pointer
->	O
sorted	int
=	O
1	int
;	O
pe	pointer
=	O
(	O
struct	O
entryInfo	struct
*	O
)	O
p	pointer
;	O
dataStart	pointer
=	O
(	O
char	O
*	O
)	O
(	O
pe	pointer
+	O
h	pointer
->	O
indexUsed	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
entry	pointer
=	O
h	pointer
->	O
index	function
;	O
i	int
<	O
h	pointer
->	O
indexUsed	int
;	O
i	int
++	O
,	O
entry	pointer
++	O
,	O
pe	pointer
++	O
)	O
{	O
entry	pointer
->	O
info	struct
.	O
type	enum
=	O
htonl	function
(	O
pe	pointer
->	O
type	enum
)	O
;	O
entry	pointer
->	O
info	struct
.	O
tag	int
=	O
htonl	function
(	O
pe	pointer
->	O
tag	int
)	O
;	O
entry	pointer
->	O
info	struct
.	O
count	long
=	O
htonl	function
(	O
pe	pointer
->	O
count	long
)	O
;	O
entry	pointer
->	O
info	struct
.	O
offset	long
=	O
-	O
1	int
;	O
if	O
(	O
entry	pointer
->	O
info	struct
.	O
type	enum
<	O
RPM_MIN_TYPE	int
||	O
entry	pointer
->	O
info	struct
.	O
type	enum
>	O
RPM_MAX_TYPE	int
)	O
return	O
NULL	O
;	O
src	pointer
=	O
dataStart	pointer
+	O
htonl	function
(	O
pe	pointer
->	O
offset	long
)	O
;	O
entry	pointer
->	O
length	int
=	O
dataLength	function
(	O
entry	pointer
->	O
info	struct
.	O
type	enum
,	O
src	pointer
,	O
entry	pointer
->	O
info	struct
.	O
count	long
,	O
1	int
)	O
;	O
entry	pointer
->	O
data	pointer
=	O
dst	pointer
=	O
xmalloc	function
(	O
entry	pointer
->	O
length	int
)	O
;	O
switch	O
(	O
entry	pointer
->	O
info	struct
.	O
type	enum
)	O
{	O
case	O
RPM_INT32_TYPE	int
:	O
count	long
=	O
entry	pointer
->	O
info	struct
.	O
count	long
;	O
while	O
(	O
count	long
--	O
)	O
{	O
*	O
(	O
(	O
int_32	int
*	O
)	O
dst	pointer
)	O
=	O
htonl	function
(	O
*	O
(	O
(	O
int_32	int
*	O
)	O
src	pointer
)	O
)	O
;	O
src	pointer
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
dst	pointer
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
}	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
count	long
=	O
entry	pointer
->	O
info	struct
.	O
count	long
;	O
while	O
(	O
count	long
--	O
)	O
{	O
*	O
(	O
(	O
int_16	short
*	O
)	O
dst	pointer
)	O
=	O
htons	function
(	O
*	O
(	O
(	O
int_16	short
*	O
)	O
src	pointer
)	O
)	O
;	O
src	pointer
+=	O
sizeof	O
(	O
int_16	short
)	O
;	O
dst	pointer
+=	O
sizeof	O
(	O
int_16	short
)	O
;	O
}	O
break	O
;	O
default	O
:	O
memcpy	function
(	O
dst	pointer
,	O
src	pointer
,	O
entry	pointer
->	O
length	int
)	O
;	O
break	O
;	O
}	O
}	O
return	O
h	pointer
;	O
}	O
static	O
void	O
*	O
doHeaderUnload	function
(	O
Header	pointer
h	pointer
,	O
int	O
*	O
lengthPtr	pointer
)	O
{	O
int	O
i	int
;	O
int	O
type	enum
,	O
diff	int
;	O
void	O
*	O
p	pointer
;	O
int_32	int
*	O
pi	pointer
;	O
struct	O
entryInfo	struct
*	O
pe	pointer
;	O
struct	O
indexEntry	struct
*	O
entry	pointer
;	O
char	O
*	O
chptr	pointer
,	O
*	O
src	pointer
,	O
*	O
dataStart	pointer
;	O
int	O
count	long
;	O
headerSort	function
(	O
h	pointer
)	O
;	O
*	O
lengthPtr	pointer
=	O
headerSizeof	function
(	O
h	pointer
,	O
0	int
)	O
;	O
pi	pointer
=	O
p	pointer
=	O
xmalloc	function
(	O
*	O
lengthPtr	pointer
)	O
;	O
*	O
pi	pointer
++	O
=	O
htonl	function
(	O
h	pointer
->	O
indexUsed	int
)	O
;	O
*	O
pi	pointer
++	O
=	O
htonl	function
(	O
*	O
lengthPtr	pointer
-	O
sizeof	O
(	O
int_32	int
)	O
-	O
sizeof	O
(	O
int_32	int
)	O
-	O
(	O
sizeof	O
(	O
struct	O
entryInfo	struct
)	O
*	O
h	pointer
->	O
indexUsed	int
)	O
)	O
;	O
pe	pointer
=	O
(	O
struct	O
entryInfo	struct
*	O
)	O
pi	pointer
;	O
dataStart	pointer
=	O
chptr	pointer
=	O
(	O
char	O
*	O
)	O
(	O
pe	pointer
+	O
h	pointer
->	O
indexUsed	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
entry	pointer
=	O
h	pointer
->	O
index	function
;	O
i	int
<	O
h	pointer
->	O
indexUsed	int
;	O
i	int
++	O
,	O
entry	pointer
++	O
,	O
pe	pointer
++	O
)	O
{	O
pe	pointer
->	O
type	enum
=	O
htonl	function
(	O
entry	pointer
->	O
info	struct
.	O
type	enum
)	O
;	O
pe	pointer
->	O
tag	int
=	O
htonl	function
(	O
entry	pointer
->	O
info	struct
.	O
tag	int
)	O
;	O
pe	pointer
->	O
count	long
=	O
htonl	function
(	O
entry	pointer
->	O
info	struct
.	O
count	long
)	O
;	O
type	enum
=	O
entry	pointer
->	O
info	struct
.	O
type	enum
;	O
if	O
(	O
typeSizes	array
[	O
type	enum
]	O
>	O
1	int
)	O
{	O
diff	int
=	O
typeSizes	array
[	O
type	enum
]	O
-	O
(	O
(	O
chptr	pointer
-	O
dataStart	pointer
)	O
%	O
typeSizes	array
[	O
type	enum
]	O
)	O
;	O
if	O
(	O
diff	int
!=	O
typeSizes	array
[	O
type	enum
]	O
)	O
{	O
memset	function
(	O
chptr	pointer
,	O
0	int
,	O
diff	int
)	O
;	O
chptr	pointer
+=	O
diff	int
;	O
}	O
}	O
pe	pointer
->	O
offset	long
=	O
htonl	function
(	O
chptr	pointer
-	O
dataStart	pointer
)	O
;	O
switch	O
(	O
entry	pointer
->	O
info	struct
.	O
type	enum
)	O
{	O
case	O
RPM_INT32_TYPE	int
:	O
count	long
=	O
entry	pointer
->	O
info	struct
.	O
count	long
;	O
src	pointer
=	O
entry	pointer
->	O
data	pointer
;	O
while	O
(	O
count	long
--	O
)	O
{	O
*	O
(	O
(	O
int_32	int
*	O
)	O
chptr	pointer
)	O
=	O
htonl	function
(	O
*	O
(	O
(	O
int_32	int
*	O
)	O
src	pointer
)	O
)	O
;	O
chptr	pointer
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
src	pointer
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
}	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
count	long
=	O
entry	pointer
->	O
info	struct
.	O
count	long
;	O
src	pointer
=	O
entry	pointer
->	O
data	pointer
;	O
while	O
(	O
count	long
--	O
)	O
{	O
*	O
(	O
(	O
int_16	short
*	O
)	O
chptr	pointer
)	O
=	O
htons	function
(	O
*	O
(	O
(	O
int_16	short
*	O
)	O
src	pointer
)	O
)	O
;	O
chptr	pointer
+=	O
sizeof	O
(	O
int_16	short
)	O
;	O
src	pointer
+=	O
sizeof	O
(	O
int_16	short
)	O
;	O
}	O
break	O
;	O
default	O
:	O
memcpy	function
(	O
chptr	pointer
,	O
entry	pointer
->	O
data	pointer
,	O
entry	pointer
->	O
length	int
)	O
;	O
chptr	pointer
+=	O
entry	pointer
->	O
length	int
;	O
break	O
;	O
}	O
}	O
return	O
p	pointer
;	O
}	O
void	O
*	O
headerUnload	function
(	O
Header	pointer
h	pointer
)	O
{	O
int	O
length	int
;	O
return	O
doHeaderUnload	function
(	O
h	pointer
,	O
&	O
length	int
)	O
;	O
}	O
int	O
headerWrite	function
(	O
FD_t	pointer
fd	pointer
,	O
Header	pointer
h	pointer
,	O
int	O
magicp	int
)	O
{	O
void	O
*	O
p	pointer
;	O
int	O
length	int
;	O
int_32	int
l	int
;	O
ssize_t	long
nb	long
;	O
p	pointer
=	O
doHeaderUnload	function
(	O
h	pointer
,	O
&	O
length	int
)	O
;	O
if	O
(	O
magicp	int
)	O
{	O
nb	long
=	O
Fwrite	function
(	O
header_magic	array
,	O
sizeof	O
(	O
char	O
)	O
,	O
sizeof	O
(	O
header_magic	array
)	O
,	O
fd	pointer
)	O
;	O
if	O
(	O
nb	long
!=	O
sizeof	O
(	O
header_magic	array
)	O
)	O
{	O
free	function
(	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
l	int
=	O
htonl	function
(	O
0	int
)	O
;	O
nb	long
=	O
Fwrite	function
(	O
&	O
l	int
,	O
sizeof	O
(	O
char	O
)	O
,	O
sizeof	O
(	O
l	int
)	O
,	O
fd	pointer
)	O
;	O
if	O
(	O
nb	long
!=	O
sizeof	O
(	O
l	int
)	O
)	O
{	O
free	function
(	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
nb	long
=	O
Fwrite	function
(	O
p	pointer
,	O
sizeof	O
(	O
char	O
)	O
,	O
length	int
,	O
fd	pointer
)	O
;	O
if	O
(	O
nb	long
!=	O
length	int
)	O
{	O
free	function
(	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
free	function
(	O
p	pointer
)	O
;	O
return	O
0	int
;	O
}	O
Header	pointer
headerRead	function
(	O
FD_t	pointer
fd	pointer
,	O
int	O
magicp	int
)	O
{	O
int_32	int
block	array
[	O
40	int
]	O
;	O
int_32	int
reserved	int
;	O
int_32	int
*	O
p	pointer
;	O
int_32	int
il	int
,	O
dl	int
;	O
int_32	int
magic	int
;	O
Header	pointer
h	pointer
;	O
void	O
*	O
dataBlock	pointer
;	O
int	O
totalSize	int
;	O
int	O
i	int
;	O
i	int
=	O
2	int
;	O
if	O
(	O
magicp	int
==	O
HEADER_MAGIC_YES	int
)	O
i	int
+=	O
2	int
;	O
if	O
(	O
timedRead	function
(	O
fd	pointer
,	O
(	O
char	O
*	O
)	O
block	array
,	O
i	int
*	O
sizeof	O
(	O
*	O
block	array
)	O
)	O
!=	O
(	O
i	int
*	O
sizeof	O
(	O
*	O
block	array
)	O
)	O
)	O
return	O
NULL	O
;	O
i	int
=	O
0	int
;	O
if	O
(	O
magicp	int
==	O
HEADER_MAGIC_YES	int
)	O
{	O
magic	int
=	O
block	array
[	O
i	int
++	O
]	O
;	O
if	O
(	O
memcmp	function
(	O
&	O
magic	int
,	O
header_magic	array
,	O
sizeof	O
(	O
magic	int
)	O
)	O
)	O
{	O
return	O
NULL	O
;	O
}	O
reserved	int
=	O
block	array
[	O
i	int
++	O
]	O
;	O
}	O
il	int
=	O
ntohl	function
(	O
block	array
[	O
i	int
++	O
]	O
)	O
;	O
dl	int
=	O
ntohl	function
(	O
block	array
[	O
i	int
++	O
]	O
)	O
;	O
totalSize	int
=	O
sizeof	O
(	O
int_32	int
)	O
+	O
sizeof	O
(	O
int_32	int
)	O
+	O
(	O
il	int
*	O
sizeof	O
(	O
struct	O
entryInfo	struct
)	O
)	O
+	O
dl	int
;	O
if	O
(	O
totalSize	int
>	O
(	O
32	int
*	O
1024	int
*	O
1024	int
)	O
)	O
return	O
NULL	O
;	O
dataBlock	pointer
=	O
p	pointer
=	O
xmalloc	function
(	O
totalSize	int
)	O
;	O
*	O
p	pointer
++	O
=	O
htonl	function
(	O
il	int
)	O
;	O
*	O
p	pointer
++	O
=	O
htonl	function
(	O
dl	int
)	O
;	O
totalSize	int
-=	O
sizeof	O
(	O
int_32	int
)	O
+	O
sizeof	O
(	O
int_32	int
)	O
;	O
if	O
(	O
timedRead	function
(	O
fd	pointer
,	O
(	O
char	O
*	O
)	O
p	pointer
,	O
totalSize	int
)	O
!=	O
totalSize	int
)	O
return	O
NULL	O
;	O
h	pointer
=	O
headerLoad	function
(	O
dataBlock	pointer
)	O
;	O
free	function
(	O
dataBlock	pointer
)	O
;	O
return	O
h	pointer
;	O
}	O
void	O
headerDump	function
(	O
Header	pointer
h	pointer
,	O
FILE	struct
*	O
f	pointer
,	O
int	O
flags	int
,	O
const	O
struct	O
headerTagTableEntry	struct
*	O
tags	pointer
)	O
{	O
int	O
i	int
;	O
struct	O
indexEntry	struct
*	O
p	pointer
;	O
const	O
struct	O
headerTagTableEntry	struct
*	O
tage	pointer
;	O
const	O
char	O
*	O
tag	int
;	O
char	O
*	O
type	enum
;	O
fprintf	function
(	O
f	pointer
,	O
"Entry count: %d\n"	pointer
,	O
h	pointer
->	O
indexUsed	int
)	O
;	O
p	pointer
=	O
h	pointer
->	O
index	function
;	O
fprintf	function
(	O
f	pointer
,	O
"\n             CT  TAG                  TYPE         "	pointer
"      OFSET      COUNT\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
h	pointer
->	O
indexUsed	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
p	pointer
->	O
info	struct
.	O
type	enum
)	O
{	O
case	O
RPM_NULL_TYPE	int
:	O
type	enum
=	O
"NULL_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_CHAR_TYPE	int
:	O
type	enum
=	O
"CHAR_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_BIN_TYPE	int
:	O
type	enum
=	O
"BIN_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_INT8_TYPE	int
:	O
type	enum
=	O
"INT8_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
type	enum
=	O
"INT16_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_INT32_TYPE	int
:	O
type	enum
=	O
"INT32_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_STRING_TYPE	int
:	O
type	enum
=	O
"STRING_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
type	enum
=	O
"STRING_ARRAY_TYPE"	pointer
;	O
break	O
;	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
type	enum
=	O
"I18N_STRING_TYPE"	pointer
;	O
break	O
;	O
default	O
:	O
type	enum
=	O
"(unknown)"	pointer
;	O
break	O
;	O
}	O
tage	pointer
=	O
tags	pointer
;	O
while	O
(	O
tage	pointer
->	O
name	pointer
&&	O
tage	pointer
->	O
val	array
!=	O
p	pointer
->	O
info	struct
.	O
tag	int
)	O
tage	pointer
++	O
;	O
if	O
(	O
!	O
tage	pointer
->	O
name	pointer
)	O
tag	int
=	O
"(unknown)"	pointer
;	O
else	O
tag	int
=	O
tage	pointer
->	O
name	pointer
;	O
fprintf	function
(	O
f	pointer
,	O
"Entry      : %.3d (%d)%-14s %-18s 0x%.8x %.8d\n"	pointer
,	O
i	int
,	O
p	pointer
->	O
info	struct
.	O
tag	int
,	O
tag	int
,	O
type	enum
,	O
(	O
unsigned	O
)	O
p	pointer
->	O
info	struct
.	O
offset	long
,	O
(	O
int	O
)	O
p	pointer
->	O
info	struct
.	O
count	long
)	O
;	O
if	O
(	O
flags	int
&	O
HEADER_DUMP_INLINE	int
)	O
{	O
char	O
*	O
dp	pointer
=	O
p	pointer
->	O
data	pointer
;	O
int	O
c	int
=	O
p	pointer
->	O
info	struct
.	O
count	long
;	O
int	O
ct	int
=	O
0	int
;	O
switch	O
(	O
p	pointer
->	O
info	struct
.	O
type	enum
)	O
{	O
case	O
RPM_INT32_TYPE	int
:	O
while	O
(	O
c	int
--	O
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"       Data: %.3d 0x%08x (%d)\n"	pointer
,	O
ct	int
++	O
,	O
(	O
unsigned	O
)	O
*	O
(	O
(	O
int_32	int
*	O
)	O
dp	pointer
)	O
,	O
(	O
int	O
)	O
*	O
(	O
(	O
int_32	int
*	O
)	O
dp	pointer
)	O
)	O
;	O
dp	pointer
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
}	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
while	O
(	O
c	int
--	O
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"       Data: %.3d 0x%04x (%d)\n"	pointer
,	O
ct	int
++	O
,	O
(	O
unsigned	O
)	O
(	O
*	O
(	O
(	O
int_16	short
*	O
)	O
dp	pointer
)	O
&	O
0xffff	int
)	O
,	O
(	O
int	O
)	O
*	O
(	O
(	O
int_16	short
*	O
)	O
dp	pointer
)	O
)	O
;	O
dp	pointer
+=	O
sizeof	O
(	O
int_16	short
)	O
;	O
}	O
break	O
;	O
case	O
RPM_INT8_TYPE	int
:	O
while	O
(	O
c	int
--	O
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"       Data: %.3d 0x%02x (%d)\n"	pointer
,	O
ct	int
++	O
,	O
(	O
unsigned	O
)	O
(	O
*	O
(	O
(	O
int_8	char
*	O
)	O
dp	pointer
)	O
&	O
0xff	int
)	O
,	O
(	O
int	O
)	O
*	O
(	O
(	O
int_8	char
*	O
)	O
dp	pointer
)	O
)	O
;	O
dp	pointer
+=	O
sizeof	O
(	O
int_8	char
)	O
;	O
}	O
break	O
;	O
case	O
RPM_BIN_TYPE	int
:	O
while	O
(	O
c	int
>	O
0	int
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"       Data: %.3d "	pointer
,	O
ct	int
)	O
;	O
while	O
(	O
c	int
--	O
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"%02x "	pointer
,	O
(	O
unsigned	O
)	O
(	O
*	O
(	O
int_8	char
*	O
)	O
dp	pointer
&	O
0xff	int
)	O
)	O
;	O
ct	int
++	O
;	O
dp	pointer
+=	O
sizeof	O
(	O
int_8	char
)	O
;	O
if	O
(	O
!	O
(	O
ct	int
%	O
8	int
)	O
)	O
{	O
break	O
;	O
}	O
}	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
RPM_CHAR_TYPE	int
:	O
while	O
(	O
c	int
--	O
)	O
{	O
char	O
ch	char
=	O
(	O
char	O
)	O
*	O
(	O
(	O
char	O
*	O
)	O
dp	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"       Data: %.3d 0x%2x %c (%d)\n"	pointer
,	O
ct	int
++	O
,	O
(	O
unsigned	O
)	O
(	O
ch	char
&	O
0xff	int
)	O
,	O
(	O
isprint	function
(	O
ch	char
)	O
?	O
ch	char
:	O
' '	O
)	O
,	O
(	O
int	O
)	O
*	O
(	O
(	O
char	O
*	O
)	O
dp	pointer
)	O
)	O
;	O
dp	pointer
+=	O
sizeof	O
(	O
char	O
)	O
;	O
}	O
break	O
;	O
case	O
RPM_STRING_TYPE	int
:	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
while	O
(	O
c	int
--	O
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"       Data: %.3d %s\n"	pointer
,	O
ct	int
++	O
,	O
(	O
char	O
*	O
)	O
dp	pointer
)	O
;	O
dp	pointer
=	O
strchr	function
(	O
dp	pointer
,	O
0	int
)	O
;	O
dp	pointer
++	O
;	O
}	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Data type %d not supported\n"	pointer
)	O
,	O
(	O
int	O
)	O
p	pointer
->	O
info	struct
.	O
type	enum
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
}	O
p	pointer
++	O
;	O
}	O
}	O
static	O
struct	O
indexEntry	struct
*	O
findEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
int_32	int
type	enum
)	O
{	O
struct	O
indexEntry	struct
*	O
entry	pointer
,	O
*	O
entry2	pointer
,	O
*	O
last	pointer
;	O
struct	O
indexEntry	struct
key	struct
;	O
if	O
(	O
!	O
h	pointer
->	O
sorted	int
)	O
headerSort	function
(	O
h	pointer
)	O
;	O
key	struct
.	O
info	struct
.	O
tag	int
=	O
tag	int
;	O
entry2	pointer
=	O
entry	pointer
=	O
bsearch	function
(	O
&	O
key	struct
,	O
h	pointer
->	O
index	function
,	O
h	pointer
->	O
indexUsed	int
,	O
sizeof	O
(	O
struct	O
indexEntry	struct
)	O
,	O
indexCmp	function
)	O
;	O
if	O
(	O
!	O
entry	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
type	enum
==	O
RPM_NULL_TYPE	int
)	O
return	O
entry	pointer
;	O
while	O
(	O
entry	pointer
->	O
info	struct
.	O
tag	int
==	O
tag	int
&&	O
entry	pointer
->	O
info	struct
.	O
type	enum
!=	O
type	enum
&&	O
entry	pointer
>	O
h	pointer
->	O
index	function
)	O
entry	pointer
--	O
;	O
if	O
(	O
entry	pointer
->	O
info	struct
.	O
tag	int
==	O
tag	int
&&	O
entry	pointer
->	O
info	struct
.	O
type	enum
==	O
type	enum
)	O
return	O
entry	pointer
;	O
last	pointer
=	O
h	pointer
->	O
index	function
+	O
h	pointer
->	O
indexUsed	int
;	O
while	O
(	O
entry2	pointer
->	O
info	struct
.	O
tag	int
==	O
tag	int
&&	O
entry2	pointer
->	O
info	struct
.	O
type	enum
!=	O
type	enum
&&	O
entry2	pointer
<	O
last	pointer
)	O
entry2	pointer
++	O
;	O
if	O
(	O
entry	pointer
->	O
info	struct
.	O
tag	int
==	O
tag	int
&&	O
entry	pointer
->	O
info	struct
.	O
type	enum
==	O
type	enum
)	O
return	O
entry	pointer
;	O
return	O
NULL	O
;	O
}	O
int	O
headerIsEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
)	O
{	O
return	O
(	O
findEntry	function
(	O
h	pointer
,	O
tag	int
,	O
RPM_NULL_TYPE	int
)	O
?	O
1	int
:	O
0	int
)	O
;	O
}	O
int	O
headerGetRawEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
int_32	int
*	O
type	enum
,	O
void	O
*	O
*	O
p	pointer
,	O
int_32	int
*	O
c	int
)	O
{	O
struct	O
indexEntry	struct
*	O
entry	pointer
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
headerIsEntry	function
(	O
h	pointer
,	O
tag	int
)	O
;	O
entry	pointer
=	O
findEntry	function
(	O
h	pointer
,	O
tag	int
,	O
RPM_NULL_TYPE	int
)	O
;	O
if	O
(	O
!	O
entry	pointer
)	O
{	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
=	O
NULL	O
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
copyEntry	function
(	O
entry	pointer
,	O
type	enum
,	O
p	pointer
,	O
c	int
,	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
headerMatchLocale	function
(	O
const	O
char	O
*	O
td	pointer
,	O
const	O
char	O
*	O
l	int
,	O
const	O
char	O
*	O
le	pointer
)	O
{	O
const	O
char	O
*	O
fe	pointer
;	O
if	O
(	O
strlen	function
(	O
td	pointer
)	O
==	O
(	O
le	pointer
-	O
l	int
)	O
&&	O
!	O
strncmp	function
(	O
td	pointer
,	O
l	int
,	O
(	O
le	pointer
-	O
l	int
)	O
)	O
)	O
return	O
1	int
;	O
for	O
(	O
fe	pointer
=	O
l	int
;	O
fe	pointer
<	O
le	pointer
&&	O
*	O
fe	pointer
!=	O
'@'	O
;	O
fe	pointer
++	O
)	O
;	O
if	O
(	O
fe	pointer
<	O
le	pointer
&&	O
!	O
strncmp	function
(	O
td	pointer
,	O
l	int
,	O
(	O
fe	pointer
-	O
l	int
)	O
)	O
)	O
return	O
1	int
;	O
for	O
(	O
fe	pointer
=	O
l	int
;	O
fe	pointer
<	O
le	pointer
&&	O
*	O
fe	pointer
!=	O
'.'	O
;	O
fe	pointer
++	O
)	O
;	O
if	O
(	O
fe	pointer
<	O
le	pointer
&&	O
!	O
strncmp	function
(	O
td	pointer
,	O
l	int
,	O
(	O
fe	pointer
-	O
l	int
)	O
)	O
)	O
return	O
1	int
;	O
for	O
(	O
fe	pointer
=	O
l	int
;	O
fe	pointer
<	O
le	pointer
&&	O
*	O
fe	pointer
!=	O
'_'	O
;	O
fe	pointer
++	O
)	O
;	O
if	O
(	O
fe	pointer
<	O
le	pointer
&&	O
!	O
strncmp	function
(	O
td	pointer
,	O
l	int
,	O
(	O
fe	pointer
-	O
l	int
)	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
headerFindI18NString	function
(	O
Header	pointer
h	pointer
,	O
struct	O
indexEntry	struct
*	O
entry	pointer
)	O
{	O
const	O
char	O
*	O
lang	pointer
,	O
*	O
l	int
,	O
*	O
le	pointer
;	O
struct	O
indexEntry	struct
*	O
table	pointer
;	O
if	O
(	O
(	O
lang	pointer
=	O
getenv	function
(	O
"LANGUAGE"	pointer
)	O
)	O
==	O
NULL	O
&&	O
(	O
lang	pointer
=	O
getenv	function
(	O
"LC_ALL"	pointer
)	O
)	O
==	O
NULL	O
&&	O
(	O
lang	pointer
=	O
getenv	function
(	O
"LC_MESSAGES"	pointer
)	O
)	O
==	O
NULL	O
&&	O
(	O
lang	pointer
=	O
getenv	function
(	O
"LANG"	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
entry	pointer
->	O
data	pointer
;	O
if	O
(	O
(	O
table	pointer
=	O
findEntry	function
(	O
h	pointer
,	O
HEADER_I18NTABLE	int
,	O
RPM_STRING_ARRAY_TYPE	int
)	O
)	O
==	O
NULL	O
)	O
return	O
entry	pointer
->	O
data	pointer
;	O
for	O
(	O
l	int
=	O
lang	pointer
;	O
*	O
l	int
;	O
l	int
=	O
le	pointer
)	O
{	O
const	O
char	O
*	O
td	pointer
;	O
char	O
*	O
ed	pointer
;	O
int	O
langNum	int
;	O
while	O
(	O
*	O
l	int
&&	O
*	O
l	int
==	O
':'	O
)	O
l	int
++	O
;	O
if	O
(	O
*	O
l	int
==	O
'\0'	O
)	O
break	O
;	O
for	O
(	O
le	pointer
=	O
l	int
;	O
*	O
le	pointer
&&	O
*	O
le	pointer
!=	O
':'	O
;	O
le	pointer
++	O
)	O
;	O
for	O
(	O
langNum	int
=	O
0	int
,	O
td	pointer
=	O
table	pointer
->	O
data	pointer
,	O
ed	pointer
=	O
entry	pointer
->	O
data	pointer
;	O
langNum	int
<	O
entry	pointer
->	O
info	struct
.	O
count	long
;	O
langNum	int
++	O
,	O
td	pointer
+=	O
strlen	function
(	O
td	pointer
)	O
+	O
1	int
,	O
ed	pointer
+=	O
strlen	function
(	O
ed	pointer
)	O
+	O
1	int
)	O
{	O
if	O
(	O
headerMatchLocale	function
(	O
td	pointer
,	O
l	int
,	O
le	pointer
)	O
)	O
return	O
ed	pointer
;	O
}	O
}	O
return	O
entry	pointer
->	O
data	pointer
;	O
}	O
static	O
int	O
intGetEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
int_32	int
*	O
type	enum
,	O
void	O
*	O
*	O
p	pointer
,	O
int_32	int
*	O
c	int
,	O
int	O
minMem	int
)	O
{	O
struct	O
indexEntry	struct
*	O
entry	pointer
;	O
char	O
*	O
chptr	pointer
;	O
HEADERPROBE	O
(	O
h	pointer
,	O
"intGetEntry"	pointer
)	O
;	O
entry	pointer
=	O
findEntry	function
(	O
h	pointer
,	O
tag	int
,	O
RPM_NULL_TYPE	int
)	O
;	O
if	O
(	O
!	O
entry	pointer
)	O
{	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
=	O
NULL	O
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
entry	pointer
->	O
info	struct
.	O
type	enum
==	O
RPM_I18NSTRING_TYPE	int
)	O
{	O
chptr	pointer
=	O
headerFindI18NString	function
(	O
h	pointer
,	O
entry	pointer
)	O
;	O
if	O
(	O
type	enum
)	O
*	O
type	enum
=	O
RPM_STRING_TYPE	int
;	O
if	O
(	O
c	int
)	O
*	O
c	int
=	O
1	int
;	O
*	O
p	pointer
=	O
chptr	pointer
;	O
}	O
else	O
{	O
copyEntry	function
(	O
entry	pointer
,	O
type	enum
,	O
p	pointer
,	O
c	int
,	O
minMem	int
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
headerGetEntryMinMemory	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
int_32	int
*	O
type	enum
,	O
void	O
*	O
*	O
p	pointer
,	O
int_32	int
*	O
c	int
)	O
{	O
return	O
intGetEntry	function
(	O
h	pointer
,	O
tag	int
,	O
type	enum
,	O
p	pointer
,	O
c	int
,	O
1	int
)	O
;	O
}	O
int	O
headerGetEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
int_32	int
*	O
type	enum
,	O
void	O
*	O
*	O
p	pointer
,	O
int_32	int
*	O
c	int
)	O
{	O
return	O
intGetEntry	function
(	O
h	pointer
,	O
tag	int
,	O
type	enum
,	O
p	pointer
,	O
c	int
,	O
0	int
)	O
;	O
}	O
Header	pointer
headerNew	function
(	O
)	O
{	O
Header	pointer
h	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
headerToken	struct
)	O
)	O
;	O
h	pointer
->	O
indexAlloced	int
=	O
INDEX_MALLOC_SIZE	int
;	O
h	pointer
->	O
index	function
=	O
xcalloc	function
(	O
h	pointer
->	O
indexAlloced	int
,	O
sizeof	O
(	O
struct	O
indexEntry	struct
)	O
)	O
;	O
h	pointer
->	O
indexUsed	int
=	O
0	int
;	O
h	pointer
->	O
sorted	int
=	O
0	int
;	O
h	pointer
->	O
usageCount	int
=	O
1	int
;	O
return	O
(	O
Header	pointer
)	O
h	pointer
;	O
}	O
void	O
headerFree	function
(	O
Header	pointer
h	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
--	O
h	pointer
->	O
usageCount	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
h	pointer
->	O
indexUsed	int
;	O
i	int
++	O
)	O
free	function
(	O
h	pointer
->	O
index	function
[	O
i	int
]	O
.	O
data	pointer
)	O
;	O
free	function
(	O
h	pointer
->	O
index	function
)	O
;	O
free	function
(	O
h	pointer
)	O
;	O
}	O
Header	pointer
headerLink	function
(	O
Header	pointer
h	pointer
)	O
{	O
HEADERPROBE	O
(	O
h	pointer
,	O
"headerLink"	pointer
)	O
;	O
h	pointer
->	O
usageCount	int
++	O
;	O
return	O
h	pointer
;	O
}	O
int	O
headerUsageCount	function
(	O
Header	pointer
h	pointer
)	O
{	O
return	O
h	pointer
->	O
usageCount	int
;	O
}	O
unsigned	O
int	O
headerSizeof	function
(	O
Header	pointer
h	pointer
,	O
int	O
magicp	int
)	O
{	O
unsigned	O
int	O
size	long
;	O
int	O
i	int
,	O
diff	int
;	O
int_32	int
type	enum
;	O
headerSort	function
(	O
h	pointer
)	O
;	O
size	long
=	O
sizeof	O
(	O
int_32	int
)	O
;	O
size	long
+=	O
sizeof	O
(	O
int_32	int
)	O
;	O
size	long
+=	O
sizeof	O
(	O
struct	O
entryInfo	struct
)	O
*	O
h	pointer
->	O
indexUsed	int
;	O
if	O
(	O
magicp	int
)	O
{	O
size	long
+=	O
8	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
h	pointer
->	O
indexUsed	int
;	O
i	int
++	O
)	O
{	O
type	enum
=	O
h	pointer
->	O
index	function
[	O
i	int
]	O
.	O
info	struct
.	O
type	enum
;	O
if	O
(	O
typeSizes	array
[	O
type	enum
]	O
>	O
1	int
)	O
{	O
diff	int
=	O
typeSizes	array
[	O
type	enum
]	O
-	O
(	O
size	long
%	O
typeSizes	array
[	O
type	enum
]	O
)	O
;	O
if	O
(	O
diff	int
!=	O
typeSizes	array
[	O
type	enum
]	O
)	O
{	O
size	long
+=	O
diff	int
;	O
}	O
}	O
size	long
+=	O
h	pointer
->	O
index	function
[	O
i	int
]	O
.	O
length	int
;	O
}	O
return	O
size	long
;	O
}	O
static	O
void	O
copyData	function
(	O
int_32	int
type	enum
,	O
void	O
*	O
dstPtr	pointer
,	O
const	O
void	O
*	O
srcPtr	pointer
,	O
int_32	int
c	int
,	O
int	O
dataLength	function
)	O
{	O
const	O
char	O
*	O
*	O
src	pointer
;	O
char	O
*	O
dst	pointer
;	O
int	O
i	int
,	O
len	int
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
case	O
RPM_I18NSTRING_TYPE	int
:	O
i	int
=	O
c	int
;	O
src	pointer
=	O
(	O
const	O
char	O
*	O
*	O
)	O
srcPtr	pointer
;	O
dst	pointer
=	O
dstPtr	pointer
;	O
while	O
(	O
i	int
--	O
)	O
{	O
len	int
=	O
*	O
src	pointer
?	O
strlen	function
(	O
*	O
src	pointer
)	O
+	O
1	int
:	O
0	int
;	O
memcpy	function
(	O
dst	pointer
,	O
*	O
src	pointer
,	O
len	int
)	O
;	O
dst	pointer
+=	O
len	int
;	O
src	pointer
++	O
;	O
}	O
break	O
;	O
default	O
:	O
memcpy	function
(	O
dstPtr	pointer
,	O
srcPtr	pointer
,	O
dataLength	function
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
*	O
grabData	function
(	O
int_32	int
type	enum
,	O
const	O
void	O
*	O
p	pointer
,	O
int_32	int
c	int
,	O
int	O
*	O
lengthPtr	pointer
)	O
{	O
int	O
length	int
;	O
void	O
*	O
data	pointer
;	O
length	int
=	O
dataLength	function
(	O
type	enum
,	O
p	pointer
,	O
c	int
,	O
0	int
)	O
;	O
data	pointer
=	O
xmalloc	function
(	O
length	int
)	O
;	O
copyData	function
(	O
type	enum
,	O
data	pointer
,	O
p	pointer
,	O
c	int
,	O
length	int
)	O
;	O
*	O
lengthPtr	pointer
=	O
length	int
;	O
return	O
data	pointer
;	O
}	O
int	O
headerAddEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
int_32	int
type	enum
,	O
const	O
void	O
*	O
p	pointer
,	O
int_32	int
c	int
)	O
{	O
struct	O
indexEntry	struct
*	O
entry	pointer
;	O
h	pointer
->	O
sorted	int
=	O
0	int
;	O
if	O
(	O
c	int
<=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Bad count for headerAddEntry(): %d\n"	pointer
)	O
,	O
(	O
int	O
)	O
c	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
h	pointer
->	O
indexUsed	int
==	O
h	pointer
->	O
indexAlloced	int
)	O
{	O
h	pointer
->	O
indexAlloced	int
+=	O
INDEX_MALLOC_SIZE	int
;	O
h	pointer
->	O
index	function
=	O
xrealloc	function
(	O
h	pointer
->	O
index	function
,	O
h	pointer
->	O
indexAlloced	int
*	O
sizeof	O
(	O
struct	O
indexEntry	struct
)	O
)	O
;	O
}	O
entry	pointer
=	O
h	pointer
->	O
index	function
+	O
h	pointer
->	O
indexUsed	int
++	O
;	O
entry	pointer
->	O
info	struct
.	O
tag	int
=	O
tag	int
;	O
entry	pointer
->	O
info	struct
.	O
type	enum
=	O
type	enum
;	O
entry	pointer
->	O
info	struct
.	O
count	long
=	O
c	int
;	O
entry	pointer
->	O
info	struct
.	O
offset	long
=	O
-	O
1	int
;	O
entry	pointer
->	O
data	pointer
=	O
grabData	function
(	O
type	enum
,	O
p	pointer
,	O
c	int
,	O
&	O
entry	pointer
->	O
length	int
)	O
;	O
h	pointer
->	O
sorted	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
char	O
*	O
*	O
headerGetLangs	function
(	O
Header	pointer
h	pointer
)	O
{	O
char	O
*	O
*	O
s	pointer
,	O
*	O
e	pointer
,	O
*	O
*	O
table	pointer
;	O
int	O
i	int
,	O
type	enum
,	O
count	long
;	O
if	O
(	O
!	O
headerGetRawEntry	function
(	O
h	pointer
,	O
HEADER_I18NTABLE	int
,	O
&	O
type	enum
,	O
(	O
void	O
*	O
*	O
)	O
&	O
s	pointer
,	O
&	O
count	long
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
table	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xcalloc	function
(	O
(	O
count	long
+	O
1	int
)	O
,	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
e	pointer
=	O
*	O
s	pointer
;	O
i	int
<	O
count	long
>	O
0	int
;	O
i	int
++	O
,	O
e	pointer
+=	O
strlen	function
(	O
e	pointer
)	O
+	O
1	int
)	O
{	O
table	pointer
[	O
i	int
]	O
=	O
e	pointer
;	O
}	O
table	pointer
[	O
count	long
]	O
=	O
NULL	O
;	O
return	O
table	pointer
;	O
}	O
int	O
headerAddI18NString	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
const	O
char	O
*	O
string	pointer
,	O
const	O
char	O
*	O
lang	pointer
)	O
{	O
struct	O
indexEntry	struct
*	O
table	pointer
,	O
*	O
entry	pointer
;	O
char	O
*	O
chptr	pointer
;	O
const	O
char	O
*	O
*	O
strArray	pointer
;	O
int	O
length	int
;	O
int	O
ghosts	int
;	O
int	O
i	int
,	O
langNum	int
;	O
char	O
*	O
buf	pointer
;	O
table	pointer
=	O
findEntry	function
(	O
h	pointer
,	O
HEADER_I18NTABLE	int
,	O
RPM_STRING_ARRAY_TYPE	int
)	O
;	O
entry	pointer
=	O
findEntry	function
(	O
h	pointer
,	O
tag	int
,	O
RPM_I18NSTRING_TYPE	int
)	O
;	O
if	O
(	O
!	O
table	pointer
&&	O
entry	pointer
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
table	pointer
&&	O
!	O
entry	pointer
)	O
{	O
const	O
char	O
*	O
charArray	array
[	O
2	int
]	O
;	O
int	O
count	long
=	O
0	int
;	O
if	O
(	O
!	O
lang	pointer
||	O
(	O
lang	pointer
[	O
0	int
]	O
==	O
'C'	O
&&	O
lang	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
)	O
{	O
charArray	array
[	O
count	long
++	O
]	O
=	O
"C"	pointer
;	O
}	O
else	O
{	O
charArray	array
[	O
count	long
++	O
]	O
=	O
"C"	pointer
;	O
charArray	array
[	O
count	long
++	O
]	O
=	O
lang	pointer
;	O
}	O
if	O
(	O
!	O
headerAddEntry	function
(	O
h	pointer
,	O
HEADER_I18NTABLE	int
,	O
RPM_STRING_ARRAY_TYPE	int
,	O
&	O
charArray	array
,	O
count	long
)	O
)	O
return	O
0	int
;	O
table	pointer
=	O
findEntry	function
(	O
h	pointer
,	O
HEADER_I18NTABLE	int
,	O
RPM_STRING_ARRAY_TYPE	int
)	O
;	O
}	O
if	O
(	O
!	O
lang	pointer
)	O
lang	pointer
=	O
"C"	pointer
;	O
chptr	pointer
=	O
table	pointer
->	O
data	pointer
;	O
for	O
(	O
langNum	int
=	O
0	int
;	O
langNum	int
<	O
table	pointer
->	O
info	struct
.	O
count	long
;	O
langNum	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
chptr	pointer
,	O
lang	pointer
)	O
)	O
break	O
;	O
chptr	pointer
+=	O
strlen	function
(	O
chptr	pointer
)	O
+	O
1	int
;	O
}	O
if	O
(	O
langNum	int
>=	O
table	pointer
->	O
info	struct
.	O
count	long
)	O
{	O
length	int
=	O
strlen	function
(	O
lang	pointer
)	O
+	O
1	int
;	O
table	pointer
->	O
data	pointer
=	O
xrealloc	function
(	O
table	pointer
->	O
data	pointer
,	O
table	pointer
->	O
length	int
+	O
length	int
)	O
;	O
memcpy	function
(	O
(	O
(	O
char	O
*	O
)	O
table	pointer
->	O
data	pointer
)	O
+	O
table	pointer
->	O
length	int
,	O
lang	pointer
,	O
length	int
)	O
;	O
table	pointer
->	O
length	int
+=	O
length	int
;	O
table	pointer
->	O
info	struct
.	O
count	long
++	O
;	O
}	O
if	O
(	O
!	O
entry	pointer
)	O
{	O
strArray	pointer
=	O
alloca	function
(	O
sizeof	O
(	O
*	O
strArray	pointer
)	O
*	O
(	O
langNum	int
+	O
1	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
langNum	int
;	O
i	int
++	O
)	O
strArray	pointer
[	O
i	int
]	O
=	O
""	pointer
;	O
strArray	pointer
[	O
langNum	int
]	O
=	O
string	pointer
;	O
return	O
headerAddEntry	function
(	O
h	pointer
,	O
tag	int
,	O
RPM_I18NSTRING_TYPE	int
,	O
strArray	pointer
,	O
langNum	int
+	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
langNum	int
>=	O
entry	pointer
->	O
info	struct
.	O
count	long
)	O
{	O
ghosts	int
=	O
langNum	int
-	O
entry	pointer
->	O
info	struct
.	O
count	long
;	O
length	int
=	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
+	O
ghosts	int
;	O
entry	pointer
->	O
data	pointer
=	O
xrealloc	function
(	O
entry	pointer
->	O
data	pointer
,	O
entry	pointer
->	O
length	int
+	O
length	int
)	O
;	O
memset	function
(	O
(	O
(	O
char	O
*	O
)	O
entry	pointer
->	O
data	pointer
)	O
+	O
entry	pointer
->	O
length	int
,	O
'\0'	O
,	O
ghosts	int
)	O
;	O
strcpy	function
(	O
(	O
(	O
char	O
*	O
)	O
entry	pointer
->	O
data	pointer
)	O
+	O
entry	pointer
->	O
length	int
+	O
ghosts	int
,	O
string	pointer
)	O
;	O
entry	pointer
->	O
length	int
+=	O
length	int
;	O
entry	pointer
->	O
info	struct
.	O
count	long
=	O
langNum	int
+	O
1	int
;	O
}	O
else	O
{	O
char	O
*	O
b	int
,	O
*	O
be	pointer
,	O
*	O
e	pointer
,	O
*	O
ee	pointer
,	O
*	O
t	pointer
;	O
size_t	long
bn	long
,	O
sn	long
,	O
en	long
;	O
b	int
=	O
be	pointer
=	O
e	pointer
=	O
ee	pointer
=	O
entry	pointer
->	O
data	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
table	pointer
->	O
info	struct
.	O
count	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
langNum	int
)	O
be	pointer
=	O
ee	pointer
;	O
ee	pointer
+=	O
strlen	function
(	O
ee	pointer
)	O
+	O
1	int
;	O
if	O
(	O
i	int
==	O
langNum	int
)	O
e	pointer
=	O
ee	pointer
;	O
}	O
bn	long
=	O
(	O
be	pointer
-	O
b	int
)	O
;	O
sn	long
=	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
;	O
en	long
=	O
(	O
ee	pointer
-	O
e	pointer
)	O
;	O
length	int
=	O
bn	long
+	O
sn	long
+	O
en	long
;	O
t	pointer
=	O
buf	pointer
=	O
xmalloc	function
(	O
length	int
)	O
;	O
memcpy	function
(	O
t	pointer
,	O
b	int
,	O
bn	long
)	O
;	O
t	pointer
+=	O
bn	long
;	O
memcpy	function
(	O
t	pointer
,	O
string	pointer
,	O
sn	long
)	O
;	O
t	pointer
+=	O
sn	long
;	O
memcpy	function
(	O
t	pointer
,	O
e	pointer
,	O
en	long
)	O
;	O
t	pointer
+=	O
en	long
;	O
entry	pointer
->	O
length	int
-=	O
strlen	function
(	O
be	pointer
)	O
+	O
1	int
;	O
entry	pointer
->	O
length	int
+=	O
sn	long
;	O
free	function
(	O
entry	pointer
->	O
data	pointer
)	O
;	O
entry	pointer
->	O
data	pointer
=	O
buf	pointer
;	O
}	O
return	O
0	int
;	O
}	O
int	O
headerModifyEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
int_32	int
type	enum
,	O
void	O
*	O
p	pointer
,	O
int_32	int
c	int
)	O
{	O
struct	O
indexEntry	struct
*	O
entry	pointer
;	O
void	O
*	O
oldData	pointer
;	O
entry	pointer
=	O
findEntry	function
(	O
h	pointer
,	O
tag	int
,	O
type	enum
)	O
;	O
if	O
(	O
!	O
entry	pointer
)	O
{	O
return	O
0	int
;	O
}	O
while	O
(	O
entry	pointer
>	O
h	pointer
->	O
index	function
&&	O
(	O
entry	pointer
-	O
1	int
)	O
->	O
info	struct
.	O
tag	int
==	O
tag	int
)	O
entry	pointer
--	O
;	O
oldData	pointer
=	O
entry	pointer
->	O
data	pointer
;	O
entry	pointer
->	O
info	struct
.	O
count	long
=	O
c	int
;	O
entry	pointer
->	O
info	struct
.	O
type	enum
=	O
type	enum
;	O
entry	pointer
->	O
data	pointer
=	O
grabData	function
(	O
type	enum
,	O
p	pointer
,	O
c	int
,	O
&	O
entry	pointer
->	O
length	int
)	O
;	O
free	function
(	O
oldData	pointer
)	O
;	O
return	O
1	int
;	O
}	O
int	O
headerAddOrAppendEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
int_32	int
type	enum
,	O
void	O
*	O
p	pointer
,	O
int_32	int
c	int
)	O
{	O
if	O
(	O
findEntry	function
(	O
h	pointer
,	O
tag	int
,	O
type	enum
)	O
)	O
{	O
return	O
headerAppendEntry	function
(	O
h	pointer
,	O
tag	int
,	O
type	enum
,	O
p	pointer
,	O
c	int
)	O
;	O
}	O
else	O
{	O
return	O
headerAddEntry	function
(	O
h	pointer
,	O
tag	int
,	O
type	enum
,	O
p	pointer
,	O
c	int
)	O
;	O
}	O
}	O
int	O
headerAppendEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
,	O
int_32	int
type	enum
,	O
void	O
*	O
p	pointer
,	O
int_32	int
c	int
)	O
{	O
struct	O
indexEntry	struct
*	O
entry	pointer
;	O
int	O
length	int
;	O
entry	pointer
=	O
findEntry	function
(	O
h	pointer
,	O
tag	int
,	O
type	enum
)	O
;	O
if	O
(	O
!	O
entry	pointer
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
type	enum
==	O
RPM_STRING_TYPE	int
||	O
type	enum
==	O
RPM_I18NSTRING_TYPE	int
)	O
{	O
return	O
0	int
;	O
}	O
length	int
=	O
dataLength	function
(	O
type	enum
,	O
p	pointer
,	O
c	int
,	O
0	int
)	O
;	O
entry	pointer
->	O
data	pointer
=	O
xrealloc	function
(	O
entry	pointer
->	O
data	pointer
,	O
entry	pointer
->	O
length	int
+	O
length	int
)	O
;	O
copyData	function
(	O
type	enum
,	O
(	O
(	O
char	O
*	O
)	O
entry	pointer
->	O
data	pointer
)	O
+	O
entry	pointer
->	O
length	int
,	O
p	pointer
,	O
c	int
,	O
length	int
)	O
;	O
entry	pointer
->	O
length	int
+=	O
length	int
;	O
entry	pointer
->	O
info	struct
.	O
count	long
+=	O
c	int
;	O
return	O
0	int
;	O
}	O
int	O
headerRemoveEntry	function
(	O
Header	pointer
h	pointer
,	O
int_32	int
tag	int
)	O
{	O
struct	O
indexEntry	struct
*	O
entry	pointer
,	O
*	O
last	pointer
;	O
entry	pointer
=	O
findEntry	function
(	O
h	pointer
,	O
tag	int
,	O
RPM_NULL_TYPE	int
)	O
;	O
if	O
(	O
!	O
entry	pointer
)	O
return	O
1	int
;	O
while	O
(	O
entry	pointer
>	O
h	pointer
->	O
index	function
&&	O
(	O
entry	pointer
-	O
1	int
)	O
->	O
info	struct
.	O
tag	int
==	O
tag	int
)	O
entry	pointer
--	O
;	O
last	pointer
=	O
h	pointer
->	O
index	function
+	O
h	pointer
->	O
indexUsed	int
;	O
while	O
(	O
entry	pointer
->	O
info	struct
.	O
tag	int
==	O
tag	int
&&	O
entry	pointer
<	O
last	pointer
)	O
{	O
free	function
(	O
entry	pointer
->	O
data	pointer
)	O
;	O
*	O
(	O
entry	pointer
++	O
)	O
=	O
*	O
(	O
--	O
last	pointer
)	O
;	O
}	O
h	pointer
->	O
indexUsed	int
=	O
last	pointer
-	O
h	pointer
->	O
index	function
;	O
h	pointer
->	O
sorted	int
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
char	O
escapedChar	function
(	O
const	O
char	O
ch	char
)	O
{	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'a'	O
:	O
return	O
'\a'	O
;	O
case	O
'b'	O
:	O
return	O
'\b'	O
;	O
case	O
'f'	O
:	O
return	O
'\f'	O
;	O
case	O
'n'	O
:	O
return	O
'\n'	O
;	O
case	O
'r'	O
:	O
return	O
'\r'	O
;	O
case	O
't'	O
:	O
return	O
'\t'	O
;	O
case	O
'v'	O
:	O
return	O
'\v'	O
;	O
default	O
:	O
return	O
ch	char
;	O
}	O
}	O
static	O
void	O
freeFormat	function
(	O
struct	O
sprintfToken	struct
*	O
format	pointer
,	O
int	O
num	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
format	pointer
[	O
i	int
]	O
.	O
type	enum
)	O
{	O
case	O
PTOK_ARRAY	int
:	O
freeFormat	function
(	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
array	struct
.	O
format	pointer
,	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
array	struct
.	O
numTokens	int
)	O
;	O
break	O
;	O
case	O
PTOK_COND	int
:	O
freeFormat	function
(	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
,	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
cond	struct
.	O
numIfTokens	int
)	O
;	O
freeFormat	function
(	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
cond	struct
.	O
elseFormat	pointer
,	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
cond	struct
.	O
numElseTokens	int
)	O
;	O
break	O
;	O
case	O
PTOK_NONE	int
:	O
case	O
PTOK_TAG	int
:	O
case	O
PTOK_STRING	int
:	O
default	O
:	O
break	O
;	O
}	O
}	O
free	function
(	O
format	pointer
)	O
;	O
}	O
static	O
void	O
findTag	function
(	O
char	O
*	O
name	pointer
,	O
const	O
struct	O
headerTagTableEntry	struct
*	O
tags	pointer
,	O
const	O
struct	O
headerSprintfExtension	struct
*	O
extensions	pointer
,	O
const	O
struct	O
headerTagTableEntry	struct
*	O
*	O
tagMatch	pointer
,	O
const	O
struct	O
headerSprintfExtension	struct
*	O
*	O
extMatch	pointer
)	O
{	O
const	O
struct	O
headerTagTableEntry	struct
*	O
entry	pointer
;	O
const	O
struct	O
headerSprintfExtension	struct
*	O
ext	pointer
;	O
char	O
*	O
tagname	pointer
;	O
*	O
tagMatch	pointer
=	O
NULL	O
;	O
*	O
extMatch	pointer
=	O
NULL	O
;	O
if	O
(	O
strncmp	function
(	O
"RPMTAG_"	pointer
,	O
name	pointer
,	O
sizeof	O
(	O
"RPMTAG_"	pointer
)	O
-	O
1	int
)	O
)	O
{	O
tagname	pointer
=	O
alloca	function
(	O
strlen	function
(	O
name	pointer
)	O
+	O
10	int
)	O
;	O
strcpy	function
(	O
tagname	pointer
,	O
"RPMTAG_"	pointer
)	O
;	O
strcat	function
(	O
tagname	pointer
,	O
name	pointer
)	O
;	O
}	O
else	O
{	O
tagname	pointer
=	O
name	pointer
;	O
}	O
ext	pointer
=	O
extensions	pointer
;	O
while	O
(	O
ext	pointer
&&	O
ext	pointer
->	O
type	enum
!=	O
HEADER_EXT_LAST	int
)	O
{	O
if	O
(	O
ext	pointer
->	O
type	enum
==	O
HEADER_EXT_TAG	int
&&	O
!	O
strcasecmp	function
(	O
ext	pointer
->	O
name	pointer
,	O
tagname	pointer
)	O
)	O
break	O
;	O
if	O
(	O
ext	pointer
->	O
type	enum
==	O
HEADER_EXT_MORE	int
)	O
ext	pointer
=	O
ext	pointer
->	O
u	union
.	O
more	pointer
;	O
else	O
ext	pointer
++	O
;	O
}	O
if	O
(	O
ext	pointer
&&	O
ext	pointer
->	O
type	enum
==	O
HEADER_EXT_TAG	int
)	O
{	O
*	O
extMatch	pointer
=	O
ext	pointer
;	O
return	O
;	O
}	O
for	O
(	O
entry	pointer
=	O
tags	pointer
;	O
entry	pointer
->	O
name	pointer
;	O
entry	pointer
++	O
)	O
if	O
(	O
!	O
strcasecmp	function
(	O
entry	pointer
->	O
name	pointer
,	O
tagname	pointer
)	O
)	O
break	O
;	O
if	O
(	O
entry	pointer
->	O
name	pointer
)	O
{	O
*	O
tagMatch	pointer
=	O
entry	pointer
;	O
return	O
;	O
}	O
}	O
static	O
int	O
parseExpression	function
(	O
struct	O
sprintfToken	struct
*	O
token	pointer
,	O
char	O
*	O
str	pointer
,	O
const	O
struct	O
headerTagTableEntry	struct
*	O
tags	pointer
,	O
const	O
struct	O
headerSprintfExtension	struct
*	O
extensions	pointer
,	O
char	O
*	O
*	O
endPtr	pointer
,	O
const	O
char	O
*	O
*	O
error	pointer
)	O
;	O
static	O
int	O
parseFormat	function
(	O
char	O
*	O
str	pointer
,	O
const	O
struct	O
headerTagTableEntry	struct
*	O
tags	pointer
,	O
const	O
struct	O
headerSprintfExtension	struct
*	O
extensions	pointer
,	O
struct	O
sprintfToken	struct
*	O
*	O
formatPtr	pointer
,	O
int	O
*	O
numTokensPtr	pointer
,	O
char	O
*	O
*	O
endPtr	pointer
,	O
int	O
state	pointer
,	O
const	O
char	O
*	O
*	O
error	pointer
)	O
{	O
char	O
*	O
chptr	pointer
,	O
*	O
start	pointer
,	O
*	O
next	pointer
,	O
*	O
dst	pointer
;	O
struct	O
sprintfToken	struct
*	O
format	pointer
;	O
int	O
numTokens	int
;	O
int	O
currToken	int
;	O
const	O
struct	O
headerTagTableEntry	struct
*	O
tag	int
;	O
const	O
struct	O
headerSprintfExtension	struct
*	O
ext	pointer
;	O
int	O
i	int
;	O
int	O
done	int
=	O
0	int
;	O
numTokens	int
=	O
0	int
;	O
for	O
(	O
chptr	pointer
=	O
str	pointer
;	O
*	O
chptr	pointer
;	O
chptr	pointer
++	O
)	O
if	O
(	O
*	O
chptr	pointer
==	O
'%'	O
)	O
numTokens	int
++	O
;	O
numTokens	int
=	O
numTokens	int
*	O
2	int
+	O
1	int
;	O
format	pointer
=	O
xcalloc	function
(	O
numTokens	int
,	O
sizeof	O
(	O
*	O
format	pointer
)	O
)	O
;	O
if	O
(	O
endPtr	pointer
)	O
*	O
endPtr	pointer
=	O
NULL	O
;	O
dst	pointer
=	O
start	pointer
=	O
str	pointer
;	O
currToken	int
=	O
-	O
1	int
;	O
while	O
(	O
*	O
start	pointer
&&	O
!	O
done	int
)	O
{	O
switch	O
(	O
*	O
start	pointer
)	O
{	O
case	O
'%'	O
:	O
if	O
(	O
*	O
(	O
start	pointer
+	O
1	int
)	O
==	O
'%'	O
)	O
{	O
if	O
(	O
currToken	int
<	O
0	int
||	O
format	pointer
[	O
currToken	int
]	O
.	O
type	enum
!=	O
PTOK_STRING	int
)	O
{	O
currToken	int
++	O
;	O
format	pointer
[	O
currToken	int
]	O
.	O
type	enum
=	O
PTOK_STRING	int
;	O
dst	pointer
=	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
string	pointer
.	O
string	pointer
=	O
start	pointer
;	O
}	O
start	pointer
++	O
;	O
*	O
dst	pointer
++	O
=	O
*	O
start	pointer
++	O
;	O
break	O
;	O
}	O
currToken	int
++	O
;	O
*	O
dst	pointer
++	O
=	O
'\0'	O
;	O
start	pointer
++	O
;	O
if	O
(	O
*	O
start	pointer
==	O
'|'	O
)	O
{	O
char	O
*	O
newEnd	pointer
;	O
start	pointer
++	O
;	O
if	O
(	O
parseExpression	function
(	O
format	pointer
+	O
currToken	int
,	O
start	pointer
,	O
tags	pointer
,	O
extensions	pointer
,	O
&	O
newEnd	pointer
,	O
error	pointer
)	O
)	O
{	O
freeFormat	function
(	O
format	pointer
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
start	pointer
=	O
newEnd	pointer
;	O
}	O
else	O
{	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
format	pointer
=	O
start	pointer
;	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
pad	int
=	O
0	int
;	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
justOne	int
=	O
0	int
;	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
arrayCount	int
=	O
0	int
;	O
chptr	pointer
=	O
start	pointer
;	O
while	O
(	O
*	O
chptr	pointer
&&	O
*	O
chptr	pointer
!=	O
'{'	O
&&	O
*	O
chptr	pointer
!=	O
'%'	O
)	O
chptr	pointer
++	O
;	O
if	O
(	O
!	O
*	O
chptr	pointer
||	O
*	O
chptr	pointer
==	O
'%'	O
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"missing { after %"	pointer
)	O
;	O
freeFormat	function
(	O
format	pointer
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
*	O
chptr	pointer
++	O
=	O
'\0'	O
;	O
while	O
(	O
start	pointer
<	O
chptr	pointer
)	O
{	O
if	O
(	O
isdigit	function
(	O
*	O
start	pointer
)	O
)	O
{	O
i	int
=	O
strtoul	function
(	O
start	pointer
,	O
&	O
start	pointer
,	O
10	int
)	O
;	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
pad	int
+=	O
i	int
;	O
}	O
else	O
{	O
start	pointer
++	O
;	O
}	O
}	O
if	O
(	O
*	O
start	pointer
==	O
'='	O
)	O
{	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
justOne	int
=	O
1	int
;	O
start	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
start	pointer
==	O
'#'	O
)	O
{	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
justOne	int
=	O
1	int
;	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
arrayCount	int
=	O
1	int
;	O
start	pointer
++	O
;	O
}	O
next	pointer
=	O
start	pointer
;	O
while	O
(	O
*	O
next	pointer
&&	O
*	O
next	pointer
!=	O
'}'	O
)	O
next	pointer
++	O
;	O
if	O
(	O
!	O
*	O
next	pointer
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"missing } after %{"	pointer
)	O
;	O
freeFormat	function
(	O
format	pointer
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
*	O
next	pointer
++	O
=	O
'\0'	O
;	O
chptr	pointer
=	O
start	pointer
;	O
while	O
(	O
*	O
chptr	pointer
&&	O
*	O
chptr	pointer
!=	O
':'	O
)	O
chptr	pointer
++	O
;	O
if	O
(	O
*	O
chptr	pointer
)	O
{	O
*	O
chptr	pointer
++	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
*	O
chptr	pointer
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"empty tag format"	pointer
)	O
;	O
freeFormat	function
(	O
format	pointer
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
type	enum
=	O
chptr	pointer
;	O
}	O
else	O
{	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
type	enum
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
*	O
start	pointer
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"empty tag name"	pointer
)	O
;	O
freeFormat	function
(	O
format	pointer
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
i	int
=	O
0	int
;	O
findTag	function
(	O
start	pointer
,	O
tags	pointer
,	O
extensions	pointer
,	O
&	O
tag	int
,	O
&	O
ext	pointer
)	O
;	O
if	O
(	O
tag	int
)	O
{	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
ext	pointer
=	O
NULL	O
;	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
tag	int
=	O
tag	int
->	O
val	array
;	O
}	O
else	O
if	O
(	O
ext	pointer
)	O
{	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
ext	pointer
=	O
ext	pointer
->	O
u	union
.	O
tagFunction	pointer
;	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
tag	int
.	O
extNum	int
=	O
ext	pointer
-	O
extensions	pointer
;	O
}	O
else	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"unknown tag"	pointer
)	O
;	O
freeFormat	function
(	O
format	pointer
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
format	pointer
[	O
currToken	int
]	O
.	O
type	enum
=	O
PTOK_TAG	int
;	O
start	pointer
=	O
next	pointer
;	O
}	O
break	O
;	O
case	O
'['	O
:	O
*	O
dst	pointer
++	O
=	O
'\0'	O
;	O
*	O
start	pointer
++	O
=	O
'\0'	O
;	O
currToken	int
++	O
;	O
if	O
(	O
parseFormat	function
(	O
start	pointer
,	O
tags	pointer
,	O
extensions	pointer
,	O
&	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
array	struct
.	O
format	pointer
,	O
&	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
array	struct
.	O
numTokens	int
,	O
&	O
start	pointer
,	O
PARSER_IN_ARRAY	int
,	O
error	pointer
)	O
)	O
{	O
freeFormat	function
(	O
format	pointer
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
start	pointer
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"] expected at end of array"	pointer
)	O
;	O
freeFormat	function
(	O
format	pointer
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
dst	pointer
=	O
start	pointer
;	O
format	pointer
[	O
currToken	int
]	O
.	O
type	enum
=	O
PTOK_ARRAY	int
;	O
break	O
;	O
case	O
']'	O
:	O
case	O
'}'	O
:	O
if	O
(	O
(	O
*	O
start	pointer
==	O
']'	O
&&	O
state	pointer
!=	O
PARSER_IN_ARRAY	int
)	O
||	O
(	O
*	O
start	pointer
==	O
'}'	O
&&	O
state	pointer
!=	O
PARSER_IN_EXPR	int
)	O
)	O
{	O
if	O
(	O
*	O
start	pointer
==	O
']'	O
)	O
*	O
error	pointer
=	O
_	O
(	O
"unexpected ]"	pointer
)	O
;	O
else	O
*	O
error	pointer
=	O
_	O
(	O
"unexpected }"	pointer
)	O
;	O
freeFormat	function
(	O
format	pointer
,	O
numTokens	int
)	O
;	O
return	O
1	int
;	O
}	O
*	O
start	pointer
++	O
=	O
'\0'	O
;	O
*	O
endPtr	pointer
=	O
start	pointer
;	O
done	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
currToken	int
<	O
0	int
||	O
format	pointer
[	O
currToken	int
]	O
.	O
type	enum
!=	O
PTOK_STRING	int
)	O
{	O
currToken	int
++	O
;	O
format	pointer
[	O
currToken	int
]	O
.	O
type	enum
=	O
PTOK_STRING	int
;	O
dst	pointer
=	O
format	pointer
[	O
currToken	int
]	O
.	O
u	union
.	O
string	pointer
.	O
string	pointer
=	O
start	pointer
;	O
}	O
if	O
(	O
*	O
start	pointer
==	O
'\\'	O
)	O
{	O
start	pointer
++	O
;	O
*	O
dst	pointer
++	O
=	O
escapedChar	function
(	O
*	O
start	pointer
++	O
)	O
;	O
}	O
else	O
{	O
*	O
dst	pointer
++	O
=	O
*	O
start	pointer
++	O
;	O
}	O
break	O
;	O
}	O
}	O
*	O
dst	pointer
=	O
'\0'	O
;	O
currToken	int
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
currToken	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
format	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
PTOK_STRING	int
)	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
string	pointer
.	O
len	int
=	O
strlen	function
(	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
string	pointer
.	O
string	pointer
)	O
;	O
}	O
*	O
numTokensPtr	pointer
=	O
currToken	int
;	O
*	O
formatPtr	pointer
=	O
format	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parseExpression	function
(	O
struct	O
sprintfToken	struct
*	O
token	pointer
,	O
char	O
*	O
str	pointer
,	O
const	O
struct	O
headerTagTableEntry	struct
*	O
tags	pointer
,	O
const	O
struct	O
headerSprintfExtension	struct
*	O
extensions	pointer
,	O
char	O
*	O
*	O
endPtr	pointer
,	O
const	O
char	O
*	O
*	O
error	pointer
)	O
{	O
char	O
*	O
chptr	pointer
,	O
*	O
end	pointer
;	O
const	O
struct	O
headerTagTableEntry	struct
*	O
tag	int
;	O
const	O
struct	O
headerSprintfExtension	struct
*	O
ext	pointer
;	O
*	O
error	pointer
=	O
NULL	O
;	O
chptr	pointer
=	O
str	pointer
;	O
while	O
(	O
*	O
chptr	pointer
&&	O
*	O
chptr	pointer
!=	O
'?'	O
)	O
chptr	pointer
++	O
;	O
if	O
(	O
*	O
chptr	pointer
!=	O
'?'	O
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"? expected in expression"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
*	O
chptr	pointer
++	O
=	O
'\0'	O
;	O
;	O
if	O
(	O
*	O
chptr	pointer
!=	O
'{'	O
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"{ expected after ? in expression"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
chptr	pointer
++	O
;	O
if	O
(	O
parseFormat	function
(	O
chptr	pointer
,	O
tags	pointer
,	O
extensions	pointer
,	O
&	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
,	O
&	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
numIfTokens	int
,	O
&	O
end	pointer
,	O
PARSER_IN_EXPR	int
,	O
error	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
*	O
end	pointer
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"} expected in expression"	pointer
)	O
;	O
freeFormat	function
(	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
,	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
numIfTokens	int
)	O
;	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
chptr	pointer
=	O
end	pointer
;	O
if	O
(	O
*	O
chptr	pointer
!=	O
':'	O
&&	O
*	O
chptr	pointer
!=	O
'|'	O
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
": expected following ? subexpression"	pointer
)	O
;	O
freeFormat	function
(	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
,	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
numIfTokens	int
)	O
;	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
*	O
chptr	pointer
==	O
'|'	O
)	O
{	O
parseFormat	function
(	O
xstrdup	function
(	O
""	pointer
)	O
,	O
tags	pointer
,	O
extensions	pointer
,	O
&	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
elseFormat	pointer
,	O
&	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
numElseTokens	int
,	O
&	O
end	pointer
,	O
PARSER_IN_EXPR	int
,	O
error	pointer
)	O
;	O
}	O
else	O
{	O
chptr	pointer
++	O
;	O
if	O
(	O
*	O
chptr	pointer
!=	O
'{'	O
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"{ expected after : in expression"	pointer
)	O
;	O
freeFormat	function
(	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
,	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
numIfTokens	int
)	O
;	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
chptr	pointer
++	O
;	O
if	O
(	O
parseFormat	function
(	O
chptr	pointer
,	O
tags	pointer
,	O
extensions	pointer
,	O
&	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
elseFormat	pointer
,	O
&	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
numElseTokens	int
,	O
&	O
end	pointer
,	O
PARSER_IN_EXPR	int
,	O
error	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
*	O
end	pointer
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"} expected in expression"	pointer
)	O
;	O
freeFormat	function
(	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
,	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
numIfTokens	int
)	O
;	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
chptr	pointer
=	O
end	pointer
;	O
if	O
(	O
*	O
chptr	pointer
!=	O
'|'	O
)	O
{	O
*	O
error	pointer
=	O
_	O
(	O
"| expected at end of expression"	pointer
)	O
;	O
freeFormat	function
(	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
,	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
numIfTokens	int
)	O
;	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
=	O
NULL	O
;	O
freeFormat	function
(	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
elseFormat	pointer
,	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
numElseTokens	int
)	O
;	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
elseFormat	pointer
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
}	O
chptr	pointer
++	O
;	O
*	O
endPtr	pointer
=	O
chptr	pointer
;	O
findTag	function
(	O
str	pointer
,	O
tags	pointer
,	O
extensions	pointer
,	O
&	O
tag	int
,	O
&	O
ext	pointer
)	O
;	O
if	O
(	O
tag	int
)	O
{	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
tag	int
.	O
ext	pointer
=	O
NULL	O
;	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
tag	int
.	O
tag	int
=	O
tag	int
->	O
val	array
;	O
}	O
else	O
if	O
(	O
ext	pointer
)	O
{	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
tag	int
.	O
ext	pointer
=	O
ext	pointer
->	O
u	union
.	O
tagFunction	pointer
;	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
tag	int
.	O
extNum	int
=	O
ext	pointer
-	O
extensions	pointer
;	O
}	O
else	O
{	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
tag	int
.	O
ext	pointer
=	O
NULL	O
;	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
tag	int
.	O
tag	int
=	O
-	O
1	int
;	O
}	O
token	pointer
->	O
type	enum
=	O
PTOK_COND	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
getExtension	function
(	O
Header	pointer
h	pointer
,	O
headerTagTagFunction	pointer
fn	pointer
,	O
int_32	int
*	O
typeptr	pointer
,	O
const	O
void	O
*	O
*	O
data	pointer
,	O
int_32	int
*	O
countptr	pointer
,	O
struct	O
extensionCache	struct
*	O
ext	pointer
)	O
{	O
if	O
(	O
!	O
ext	pointer
->	O
avail	int
)	O
{	O
if	O
(	O
fn	pointer
(	O
h	pointer
,	O
&	O
ext	pointer
->	O
type	enum
,	O
&	O
ext	pointer
->	O
data	pointer
,	O
&	O
ext	pointer
->	O
count	long
,	O
&	O
ext	pointer
->	O
freeit	int
)	O
)	O
return	O
1	int
;	O
ext	pointer
->	O
avail	int
=	O
1	int
;	O
}	O
*	O
typeptr	pointer
=	O
ext	pointer
->	O
type	enum
;	O
*	O
data	pointer
=	O
ext	pointer
->	O
data	pointer
;	O
*	O
countptr	pointer
=	O
ext	pointer
->	O
count	long
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
formatValue	function
(	O
struct	O
sprintfTag	struct
*	O
tag	int
,	O
Header	pointer
h	pointer
,	O
const	O
struct	O
headerSprintfExtension	struct
*	O
extensions	pointer
,	O
struct	O
extensionCache	struct
*	O
extCache	pointer
,	O
int	O
element	array
)	O
{	O
int	O
len	int
;	O
char	O
buf	pointer
[	O
20	int
]	O
;	O
int_32	int
count	long
,	O
type	enum
;	O
const	O
void	O
*	O
data	pointer
;	O
unsigned	O
int	O
intVal	int
;	O
char	O
*	O
val	array
=	O
NULL	O
;	O
const	O
char	O
*	O
*	O
strarray	pointer
;	O
int	O
mayfree	int
=	O
0	int
;	O
int	O
countBuf	int
;	O
headerTagFormatFunction	pointer
tagtype	pointer
=	O
NULL	O
;	O
const	O
struct	O
headerSprintfExtension	struct
*	O
ext	pointer
;	O
if	O
(	O
tag	int
->	O
ext	pointer
)	O
{	O
if	O
(	O
getExtension	function
(	O
h	pointer
,	O
tag	int
->	O
ext	pointer
,	O
&	O
type	enum
,	O
&	O
data	pointer
,	O
&	O
count	long
,	O
extCache	pointer
+	O
tag	int
->	O
extNum	int
)	O
)	O
{	O
count	long
=	O
1	int
;	O
type	enum
=	O
RPM_STRING_TYPE	int
;	O
data	pointer
=	O
"(none)"	pointer
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
headerGetEntry	function
(	O
h	pointer
,	O
tag	int
->	O
tag	int
,	O
&	O
type	enum
,	O
(	O
void	O
*	O
*	O
)	O
&	O
data	pointer
,	O
&	O
count	long
)	O
)	O
{	O
count	long
=	O
1	int
;	O
type	enum
=	O
RPM_STRING_TYPE	int
;	O
data	pointer
=	O
"(none)"	pointer
;	O
}	O
mayfree	int
=	O
1	int
;	O
}	O
if	O
(	O
tag	int
->	O
arrayCount	int
)	O
{	O
if	O
(	O
type	enum
==	O
RPM_STRING_ARRAY_TYPE	int
)	O
free	function
(	O
(	O
void	O
*	O
)	O
data	pointer
)	O
;	O
countBuf	int
=	O
count	long
;	O
data	pointer
=	O
&	O
countBuf	int
;	O
count	long
=	O
1	int
;	O
type	enum
=	O
RPM_INT32_TYPE	int
;	O
}	O
strcpy	function
(	O
buf	pointer
,	O
"%"	pointer
)	O
;	O
strcat	function
(	O
buf	pointer
,	O
tag	int
->	O
format	pointer
)	O
;	O
if	O
(	O
tag	int
->	O
type	enum
)	O
{	O
ext	pointer
=	O
extensions	pointer
;	O
while	O
(	O
ext	pointer
->	O
type	enum
!=	O
HEADER_EXT_LAST	int
)	O
{	O
if	O
(	O
ext	pointer
->	O
type	enum
==	O
HEADER_EXT_FORMAT	int
&&	O
!	O
strcmp	function
(	O
ext	pointer
->	O
name	pointer
,	O
tag	int
->	O
type	enum
)	O
)	O
{	O
tagtype	pointer
=	O
ext	pointer
->	O
u	union
.	O
formatFunction	pointer
;	O
break	O
;	O
}	O
if	O
(	O
ext	pointer
->	O
type	enum
==	O
HEADER_EXT_MORE	int
)	O
ext	pointer
=	O
ext	pointer
->	O
u	union
.	O
more	pointer
;	O
else	O
ext	pointer
++	O
;	O
}	O
}	O
switch	O
(	O
type	enum
)	O
{	O
case	O
RPM_STRING_ARRAY_TYPE	int
:	O
strarray	pointer
=	O
(	O
const	O
char	O
*	O
*	O
)	O
data	pointer
;	O
if	O
(	O
tagtype	pointer
)	O
{	O
val	array
=	O
tagtype	pointer
(	O
RPM_STRING_TYPE	int
,	O
strarray	pointer
[	O
element	array
]	O
,	O
buf	pointer
,	O
tag	int
->	O
pad	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
val	array
)	O
{	O
strcat	function
(	O
buf	pointer
,	O
"s"	pointer
)	O
;	O
len	int
=	O
strlen	function
(	O
strarray	pointer
[	O
element	array
]	O
)	O
+	O
tag	int
->	O
pad	int
+	O
20	int
;	O
val	array
=	O
xmalloc	function
(	O
len	int
)	O
;	O
sprintf	function
(	O
val	array
,	O
buf	pointer
,	O
strarray	pointer
[	O
element	array
]	O
)	O
;	O
}	O
if	O
(	O
mayfree	int
)	O
free	function
(	O
(	O
void	O
*	O
)	O
data	pointer
)	O
;	O
break	O
;	O
case	O
RPM_STRING_TYPE	int
:	O
if	O
(	O
tagtype	pointer
)	O
{	O
val	array
=	O
tagtype	pointer
(	O
RPM_STRING_ARRAY_TYPE	int
,	O
data	pointer
,	O
buf	pointer
,	O
tag	int
->	O
pad	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
val	array
)	O
{	O
strcat	function
(	O
buf	pointer
,	O
"s"	pointer
)	O
;	O
len	int
=	O
strlen	function
(	O
data	pointer
)	O
+	O
tag	int
->	O
pad	int
+	O
20	int
;	O
val	array
=	O
xmalloc	function
(	O
len	int
)	O
;	O
sprintf	function
(	O
val	array
,	O
buf	pointer
,	O
data	pointer
)	O
;	O
}	O
break	O
;	O
case	O
RPM_CHAR_TYPE	int
:	O
case	O
RPM_INT8_TYPE	int
:	O
case	O
RPM_INT16_TYPE	int
:	O
case	O
RPM_INT32_TYPE	int
:	O
switch	O
(	O
type	enum
)	O
{	O
case	O
RPM_CHAR_TYPE	int
:	O
case	O
RPM_INT8_TYPE	int
:	O
intVal	int
=	O
*	O
(	O
(	O
(	O
int_8	char
*	O
)	O
data	pointer
)	O
+	O
element	array
)	O
;	O
break	O
;	O
case	O
RPM_INT16_TYPE	int
:	O
intVal	int
=	O
*	O
(	O
(	O
(	O
uint_16	short
*	O
)	O
data	pointer
)	O
+	O
element	array
)	O
;	O
break	O
;	O
default	O
:	O
case	O
RPM_INT32_TYPE	int
:	O
intVal	int
=	O
*	O
(	O
(	O
(	O
int_32	int
*	O
)	O
data	pointer
)	O
+	O
element	array
)	O
;	O
}	O
if	O
(	O
tagtype	pointer
)	O
{	O
val	array
=	O
tagtype	pointer
(	O
RPM_INT32_TYPE	int
,	O
&	O
intVal	int
,	O
buf	pointer
,	O
tag	int
->	O
pad	int
,	O
element	array
)	O
;	O
}	O
if	O
(	O
!	O
val	array
)	O
{	O
strcat	function
(	O
buf	pointer
,	O
"d"	pointer
)	O
;	O
len	int
=	O
10	int
+	O
tag	int
->	O
pad	int
+	O
20	int
;	O
val	array
=	O
xmalloc	function
(	O
len	int
)	O
;	O
sprintf	function
(	O
val	array
,	O
buf	pointer
,	O
intVal	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
val	array
=	O
xstrdup	function
(	O
_	O
(	O
"(unknown type)"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
return	O
val	array
;	O
}	O
static	O
char	O
*	O
singleSprintf	function
(	O
Header	pointer
h	pointer
,	O
struct	O
sprintfToken	struct
*	O
token	pointer
,	O
const	O
struct	O
headerSprintfExtension	struct
*	O
extensions	pointer
,	O
struct	O
extensionCache	struct
*	O
extCache	pointer
,	O
int	O
element	array
)	O
{	O
char	O
*	O
val	array
,	O
*	O
thisItem	pointer
;	O
int	O
thisItemLen	int
;	O
int	O
len	int
,	O
alloced	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
numElements	int
;	O
int	O
type	enum
;	O
struct	O
sprintfToken	struct
*	O
condFormat	pointer
;	O
int	O
condNumFormats	int
;	O
switch	O
(	O
token	pointer
->	O
type	enum
)	O
{	O
case	O
PTOK_NONE	int
:	O
break	O
;	O
case	O
PTOK_STRING	int
:	O
val	array
=	O
xmalloc	function
(	O
token	pointer
->	O
u	union
.	O
string	pointer
.	O
len	int
+	O
1	int
)	O
;	O
strcpy	function
(	O
val	array
,	O
token	pointer
->	O
u	union
.	O
string	pointer
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
PTOK_TAG	int
:	O
val	array
=	O
formatValue	function
(	O
&	O
token	pointer
->	O
u	union
.	O
tag	int
,	O
h	pointer
,	O
extensions	pointer
,	O
extCache	pointer
,	O
token	pointer
->	O
u	union
.	O
tag	int
.	O
justOne	int
?	O
0	int
:	O
element	array
)	O
;	O
break	O
;	O
case	O
PTOK_COND	int
:	O
if	O
(	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
tag	int
.	O
ext	pointer
||	O
headerIsEntry	function
(	O
h	pointer
,	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
tag	int
.	O
tag	int
)	O
)	O
{	O
condFormat	pointer
=	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
ifFormat	pointer
;	O
condNumFormats	int
=	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
numIfTokens	int
;	O
}	O
else	O
{	O
condFormat	pointer
=	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
elseFormat	pointer
;	O
condNumFormats	int
=	O
token	pointer
->	O
u	union
.	O
cond	struct
.	O
numElseTokens	int
;	O
}	O
alloced	int
=	O
condNumFormats	int
*	O
20	int
;	O
val	array
=	O
xmalloc	function
(	O
alloced	int
?	O
alloced	int
:	O
1	int
)	O
;	O
*	O
val	array
=	O
'\0'	O
;	O
len	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
condNumFormats	int
;	O
i	int
++	O
)	O
{	O
thisItem	pointer
=	O
singleSprintf	function
(	O
h	pointer
,	O
condFormat	pointer
+	O
i	int
,	O
extensions	pointer
,	O
extCache	pointer
,	O
element	array
)	O
;	O
thisItemLen	int
=	O
strlen	function
(	O
thisItem	pointer
)	O
;	O
if	O
(	O
(	O
thisItemLen	int
+	O
len	int
)	O
>=	O
alloced	int
)	O
{	O
alloced	int
=	O
(	O
thisItemLen	int
+	O
len	int
)	O
+	O
200	int
;	O
val	array
=	O
xrealloc	function
(	O
val	array
,	O
alloced	int
)	O
;	O
}	O
strcat	function
(	O
val	array
,	O
thisItem	pointer
)	O
;	O
len	int
+=	O
thisItemLen	int
;	O
free	function
(	O
thisItem	pointer
)	O
;	O
}	O
break	O
;	O
case	O
PTOK_ARRAY	int
:	O
numElements	int
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
token	pointer
->	O
u	union
.	O
array	struct
.	O
numTokens	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
token	pointer
->	O
u	union
.	O
array	struct
.	O
format	pointer
[	O
i	int
]	O
.	O
type	enum
!=	O
PTOK_TAG	int
||	O
token	pointer
->	O
u	union
.	O
array	struct
.	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
tag	int
.	O
arrayCount	int
||	O
token	pointer
->	O
u	union
.	O
array	struct
.	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
tag	int
.	O
justOne	int
)	O
continue	O
;	O
if	O
(	O
token	pointer
->	O
u	union
.	O
array	struct
.	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
tag	int
.	O
ext	pointer
)	O
{	O
const	O
void	O
*	O
data	pointer
;	O
if	O
(	O
getExtension	function
(	O
h	pointer
,	O
token	pointer
->	O
u	union
.	O
array	struct
.	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
tag	int
.	O
ext	pointer
,	O
&	O
type	enum
,	O
&	O
data	pointer
,	O
&	O
numElements	int
,	O
extCache	pointer
+	O
token	pointer
->	O
u	union
.	O
array	struct
.	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
tag	int
.	O
extNum	int
)	O
)	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
headerGetEntry	function
(	O
h	pointer
,	O
token	pointer
->	O
u	union
.	O
array	struct
.	O
format	pointer
[	O
i	int
]	O
.	O
u	union
.	O
tag	int
.	O
tag	int
,	O
&	O
type	enum
,	O
(	O
void	O
*	O
*	O
)	O
&	O
val	array
,	O
&	O
numElements	int
)	O
)	O
continue	O
;	O
if	O
(	O
type	enum
==	O
RPM_STRING_ARRAY_TYPE	int
)	O
free	function
(	O
val	array
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
numElements	int
==	O
-	O
1	int
)	O
{	O
val	array
=	O
xstrdup	function
(	O
"(none)"	pointer
)	O
;	O
}	O
else	O
{	O
alloced	int
=	O
numElements	int
*	O
token	pointer
->	O
u	union
.	O
array	struct
.	O
numTokens	int
*	O
20	int
;	O
val	array
=	O
xmalloc	function
(	O
alloced	int
)	O
;	O
*	O
val	array
=	O
'\0'	O
;	O
len	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numElements	int
;	O
j	int
++	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
token	pointer
->	O
u	union
.	O
array	struct
.	O
numTokens	int
;	O
i	int
++	O
)	O
{	O
thisItem	pointer
=	O
singleSprintf	function
(	O
h	pointer
,	O
token	pointer
->	O
u	union
.	O
array	struct
.	O
format	pointer
+	O
i	int
,	O
extensions	pointer
,	O
extCache	pointer
,	O
j	int
)	O
;	O
thisItemLen	int
=	O
strlen	function
(	O
thisItem	pointer
)	O
;	O
if	O
(	O
(	O
thisItemLen	int
+	O
len	int
)	O
>=	O
alloced	int
)	O
{	O
alloced	int
=	O
(	O
thisItemLen	int
+	O
len	int
)	O
+	O
200	int
;	O
val	array
=	O
xrealloc	function
(	O
val	array
,	O
alloced	int
)	O
;	O
}	O
strcat	function
(	O
val	array
,	O
thisItem	pointer
)	O
;	O
len	int
+=	O
thisItemLen	int
;	O
free	function
(	O
thisItem	pointer
)	O
;	O
}	O
}	O
}	O
break	O
;	O
}	O
return	O
val	array
;	O
}	O
static	O
struct	O
extensionCache	struct
*	O
allocateExtensionCache	function
(	O
const	O
struct	O
headerSprintfExtension	struct
*	O
extensions	pointer
)	O
{	O
const	O
struct	O
headerSprintfExtension	struct
*	O
ext	pointer
=	O
extensions	pointer
;	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
ext	pointer
->	O
type	enum
!=	O
HEADER_EXT_LAST	int
)	O
{	O
i	int
++	O
;	O
if	O
(	O
ext	pointer
->	O
type	enum
==	O
HEADER_EXT_MORE	int
)	O
ext	pointer
=	O
ext	pointer
->	O
u	union
.	O
more	pointer
;	O
else	O
ext	pointer
++	O
;	O
}	O
return	O
xcalloc	function
(	O
i	int
,	O
sizeof	O
(	O
struct	O
extensionCache	struct
)	O
)	O
;	O
}	O
static	O
void	O
freeExtensionCache	function
(	O
const	O
struct	O
headerSprintfExtension	struct
*	O
extensions	pointer
,	O
struct	O
extensionCache	struct
*	O
cache	pointer
)	O
{	O
const	O
struct	O
headerSprintfExtension	struct
*	O
ext	pointer
=	O
extensions	pointer
;	O
int	O
i	int
=	O
0	int
;	O
while	O
(	O
ext	pointer
->	O
type	enum
!=	O
HEADER_EXT_LAST	int
)	O
{	O
if	O
(	O
cache	pointer
[	O
i	int
]	O
.	O
freeit	int
)	O
free	function
(	O
(	O
void	O
*	O
)	O
cache	pointer
[	O
i	int
]	O
.	O
data	pointer
)	O
;	O
i	int
++	O
;	O
if	O
(	O
ext	pointer
->	O
type	enum
==	O
HEADER_EXT_MORE	int
)	O
ext	pointer
=	O
ext	pointer
->	O
u	union
.	O
more	pointer
;	O
else	O
ext	pointer
++	O
;	O
}	O
free	function
(	O
cache	pointer
)	O
;	O
}	O
char	O
*	O
headerSprintf	function
(	O
Header	pointer
h	pointer
,	O
const	O
char	O
*	O
origFmt	pointer
,	O
const	O
struct	O
headerTagTableEntry	struct
*	O
tags	pointer
,	O
const	O
struct	O
headerSprintfExtension	struct
*	O
extensions	pointer
,	O
const	O
char	O
*	O
*	O
error	pointer
)	O
{	O
char	O
*	O
fmtString	pointer
;	O
struct	O
sprintfToken	struct
*	O
format	pointer
;	O
int	O
numTokens	int
;	O
char	O
*	O
answer	pointer
;	O
const	O
char	O
*	O
piece	pointer
;	O
int	O
answerLength	int
;	O
int	O
answerAlloced	int
;	O
int	O
pieceLength	int
;	O
int	O
i	int
;	O
struct	O
extensionCache	struct
*	O
extCache	pointer
;	O
fmtString	pointer
=	O
xstrdup	function
(	O
origFmt	pointer
)	O
;	O
if	O
(	O
parseFormat	function
(	O
fmtString	pointer
,	O
tags	pointer
,	O
extensions	pointer
,	O
&	O
format	pointer
,	O
&	O
numTokens	int
,	O
NULL	O
,	O
PARSER_BEGIN	int
,	O
error	pointer
)	O
)	O
{	O
free	function
(	O
fmtString	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
extCache	pointer
=	O
allocateExtensionCache	function
(	O
extensions	pointer
)	O
;	O
answerAlloced	int
=	O
1024	int
;	O
answerLength	int
=	O
0	int
;	O
answer	pointer
=	O
xmalloc	function
(	O
answerAlloced	int
)	O
;	O
*	O
answer	pointer
=	O
'\0'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
numTokens	int
;	O
i	int
++	O
)	O
{	O
piece	pointer
=	O
singleSprintf	function
(	O
h	pointer
,	O
format	pointer
+	O
i	int
,	O
extensions	pointer
,	O
extCache	pointer
,	O
0	int
)	O
;	O
if	O
(	O
piece	pointer
)	O
{	O
pieceLength	int
=	O
strlen	function
(	O
piece	pointer
)	O
;	O
if	O
(	O
(	O
answerLength	int
+	O
pieceLength	int
)	O
>=	O
answerAlloced	int
)	O
{	O
while	O
(	O
(	O
answerLength	int
+	O
pieceLength	int
)	O
>=	O
answerAlloced	int
)	O
answerAlloced	int
+=	O
1024	int
;	O
answer	pointer
=	O
xrealloc	function
(	O
answer	pointer
,	O
answerAlloced	int
)	O
;	O
}	O
strcat	function
(	O
answer	pointer
,	O
piece	pointer
)	O
;	O
answerLength	int
+=	O
pieceLength	int
;	O
free	function
(	O
(	O
void	O
*	O
)	O
piece	pointer
)	O
;	O
}	O
}	O
free	function
(	O
fmtString	pointer
)	O
;	O
freeExtensionCache	function
(	O
extensions	pointer
,	O
extCache	pointer
)	O
;	O
free	function
(	O
format	pointer
)	O
;	O
return	O
answer	pointer
;	O
}	O
static	O
char	O
*	O
octalFormat	function
(	O
int_32	int
type	enum
,	O
const	O
void	O
*	O
data	pointer
,	O
char	O
*	O
formatPrefix	pointer
,	O
int	O
padding	int
,	O
int	O
element	array
)	O
{	O
char	O
*	O
val	array
;	O
if	O
(	O
type	enum
!=	O
RPM_INT32_TYPE	int
)	O
{	O
val	array
=	O
xstrdup	function
(	O
_	O
(	O
"(not a number)"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
val	array
=	O
xmalloc	function
(	O
20	int
+	O
padding	int
)	O
;	O
strcat	function
(	O
formatPrefix	pointer
,	O
"o"	pointer
)	O
;	O
sprintf	function
(	O
val	array
,	O
formatPrefix	pointer
,	O
*	O
(	O
(	O
int_32	int
*	O
)	O
data	pointer
)	O
)	O
;	O
}	O
return	O
val	array
;	O
}	O
static	O
char	O
*	O
hexFormat	function
(	O
int_32	int
type	enum
,	O
const	O
void	O
*	O
data	pointer
,	O
char	O
*	O
formatPrefix	pointer
,	O
int	O
padding	int
,	O
int	O
element	array
)	O
{	O
char	O
*	O
val	array
;	O
if	O
(	O
type	enum
!=	O
RPM_INT32_TYPE	int
)	O
{	O
val	array
=	O
xstrdup	function
(	O
_	O
(	O
"(not a number)"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
val	array
=	O
xmalloc	function
(	O
20	int
+	O
padding	int
)	O
;	O
strcat	function
(	O
formatPrefix	pointer
,	O
"x"	pointer
)	O
;	O
sprintf	function
(	O
val	array
,	O
formatPrefix	pointer
,	O
*	O
(	O
(	O
int_32	int
*	O
)	O
data	pointer
)	O
)	O
;	O
}	O
return	O
val	array
;	O
}	O
static	O
char	O
*	O
realDateFormat	function
(	O
int_32	int
type	enum
,	O
const	O
void	O
*	O
data	pointer
,	O
char	O
*	O
formatPrefix	pointer
,	O
int	O
padding	int
,	O
int	O
element	array
,	O
char	O
*	O
strftimeFormat	pointer
)	O
{	O
char	O
*	O
val	array
;	O
struct	O
tm	struct
*	O
tstruct	pointer
;	O
char	O
buf	pointer
[	O
50	int
]	O
;	O
if	O
(	O
type	enum
!=	O
RPM_INT32_TYPE	int
)	O
{	O
val	array
=	O
xstrdup	function
(	O
_	O
(	O
"(not a number)"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
val	array
=	O
xmalloc	function
(	O
50	int
+	O
padding	int
)	O
;	O
strcat	function
(	O
formatPrefix	pointer
,	O
"s"	pointer
)	O
;	O
{	O
time_t	long
dateint	long
=	O
*	O
(	O
(	O
int_32	int
*	O
)	O
data	pointer
)	O
;	O
tstruct	pointer
=	O
localtime	function
(	O
&	O
dateint	long
)	O
;	O
}	O
(	O
void	O
)	O
strftime	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
-	O
1	int
,	O
strftimeFormat	pointer
,	O
tstruct	pointer
)	O
;	O
sprintf	function
(	O
val	array
,	O
formatPrefix	pointer
,	O
buf	pointer
)	O
;	O
}	O
return	O
val	array
;	O
}	O
static	O
char	O
*	O
dateFormat	function
(	O
int_32	int
type	enum
,	O
const	O
void	O
*	O
data	pointer
,	O
char	O
*	O
formatPrefix	pointer
,	O
int	O
padding	int
,	O
int	O
element	array
)	O
{	O
return	O
realDateFormat	function
(	O
type	enum
,	O
data	pointer
,	O
formatPrefix	pointer
,	O
padding	int
,	O
element	array
,	O
"%c"	pointer
)	O
;	O
}	O
static	O
char	O
*	O
dayFormat	function
(	O
int_32	int
type	enum
,	O
const	O
void	O
*	O
data	pointer
,	O
char	O
*	O
formatPrefix	pointer
,	O
int	O
padding	int
,	O
int	O
element	array
)	O
{	O
return	O
realDateFormat	function
(	O
type	enum
,	O
data	pointer
,	O
formatPrefix	pointer
,	O
padding	int
,	O
element	array
,	O
"%a %b %d %Y"	pointer
)	O
;	O
}	O
static	O
char	O
*	O
shescapeFormat	function
(	O
int_32	int
type	enum
,	O
const	O
void	O
*	O
data	pointer
,	O
char	O
*	O
formatPrefix	pointer
,	O
int	O
padding	int
,	O
int	O
element	array
)	O
{	O
char	O
*	O
result	pointer
,	O
*	O
dst	pointer
,	O
*	O
src	pointer
,	O
*	O
buf	pointer
;	O
if	O
(	O
type	enum
==	O
RPM_INT32_TYPE	int
)	O
{	O
result	pointer
=	O
xmalloc	function
(	O
padding	int
+	O
20	int
)	O
;	O
strcat	function
(	O
formatPrefix	pointer
,	O
"d"	pointer
)	O
;	O
sprintf	function
(	O
result	pointer
,	O
formatPrefix	pointer
,	O
*	O
(	O
(	O
int_32	int
*	O
)	O
data	pointer
)	O
)	O
;	O
}	O
else	O
{	O
buf	pointer
=	O
alloca	function
(	O
strlen	function
(	O
data	pointer
)	O
+	O
padding	int
+	O
2	int
)	O
;	O
strcat	function
(	O
formatPrefix	pointer
,	O
"s"	pointer
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
formatPrefix	pointer
,	O
data	pointer
)	O
;	O
result	pointer
=	O
dst	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
buf	pointer
)	O
*	O
4	int
+	O
3	int
)	O
;	O
*	O
dst	pointer
++	O
=	O
'\''	O
;	O
for	O
(	O
src	pointer
=	O
buf	pointer
;	O
*	O
src	pointer
;	O
src	pointer
++	O
)	O
{	O
if	O
(	O
*	O
src	pointer
==	O
'\''	O
)	O
{	O
*	O
dst	pointer
++	O
=	O
'\''	O
;	O
*	O
dst	pointer
++	O
=	O
'\\'	O
;	O
*	O
dst	pointer
++	O
=	O
'\''	O
;	O
*	O
dst	pointer
++	O
=	O
'\''	O
;	O
}	O
else	O
{	O
*	O
dst	pointer
++	O
=	O
*	O
src	pointer
;	O
}	O
}	O
*	O
dst	pointer
++	O
=	O
'\''	O
;	O
*	O
dst	pointer
=	O
'\0'	O
;	O
}	O
return	O
result	pointer
;	O
}	O
const	O
struct	O
headerSprintfExtension	struct
headerDefaultFormats	array
[	O
]	O
=	O
{	O
{	O
HEADER_EXT_FORMAT	int
,	O
"octal"	pointer
,	O
{	O
octalFormat	function
}	O
}	O
,	O
{	O
HEADER_EXT_FORMAT	int
,	O
"hex"	pointer
,	O
{	O
hexFormat	function
}	O
}	O
,	O
{	O
HEADER_EXT_FORMAT	int
,	O
"date"	pointer
,	O
{	O
dateFormat	function
}	O
}	O
,	O
{	O
HEADER_EXT_FORMAT	int
,	O
"day"	pointer
,	O
{	O
dayFormat	function
}	O
}	O
,	O
{	O
HEADER_EXT_FORMAT	int
,	O
"shescape"	pointer
,	O
{	O
shescapeFormat	function
}	O
}	O
,	O
{	O
HEADER_EXT_LAST	int
,	O
NULL	O
,	O
{	O
NULL	O
}	O
}	O
}	O
;	O
void	O
headerCopyTags	function
(	O
Header	pointer
headerFrom	pointer
,	O
Header	pointer
headerTo	pointer
,	O
int	O
*	O
tagstocopy	pointer
)	O
{	O
int	O
*	O
p	pointer
;	O
if	O
(	O
headerFrom	pointer
==	O
headerTo	pointer
)	O
return	O
;	O
for	O
(	O
p	pointer
=	O
tagstocopy	pointer
;	O
*	O
p	pointer
!=	O
0	int
;	O
p	pointer
++	O
)	O
{	O
char	O
*	O
s	pointer
;	O
int	O
type	enum
,	O
count	long
;	O
if	O
(	O
headerIsEntry	function
(	O
headerTo	pointer
,	O
*	O
p	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
headerGetEntry	function
(	O
headerFrom	pointer
,	O
*	O
p	pointer
,	O
&	O
type	enum
,	O
(	O
void	O
*	O
*	O
)	O
&	O
s	pointer
,	O
&	O
count	long
)	O
)	O
continue	O
;	O
headerAddEntry	function
(	O
headerTo	pointer
,	O
*	O
p	pointer
,	O
type	enum
,	O
s	pointer
,	O
count	long
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
(	O
type	enum
==	O
RPM_STRING_ARRAY_TYPE	int
||	O
type	enum
==	O
RPM_I18NSTRING_TYPE	int
)	O
)	O
free	function
(	O
s	pointer
)	O
;	O
}	O
}	O
