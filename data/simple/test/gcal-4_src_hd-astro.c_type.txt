__BEGIN_DECLARATIONS	O
static	O
double	O
meeus_equinox_solstice	function
__P_	O
(	O
(	O
const	O
double	O
mode	enum
,	O
const	O
int	O
year	int
,	O
int	O
hour	int
,	O
int	O
min	int
)	O
)	O
;	O
__END_DECLARATIONS	O
static	O
double	O
meeus_equinox_solstice	function
(	O
mode	enum
,	O
year	int
,	O
hour	int
,	O
min	int
)	O
const	O
double	O
mode	enum
;	O
const	O
int	O
year	int
;	O
int	O
hour	int
;	O
int	O
min	int
;	O
{	O
auto	O
double	O
meridian_time	double
=	O
HHMM2DAY	O
(	O
hour	int
,	O
min	int
)	O
;	O
auto	O
double	O
jc	double
=	O
(	O
(	O
double	O
)	O
year	int
-	O
2000.0	int
)	O
/	O
1000	int
;	O
auto	O
double	O
mjd	long
;	O
auto	O
double	O
w	double
;	O
auto	O
double	O
c	double
;	O
auto	O
double	O
l	double
;	O
auto	O
int	O
d	int
;	O
auto	O
int	O
m	int
;	O
auto	O
int	O
y	double
;	O
switch	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
mode	enum
)	O
)	O
{	O
case	O
0	int
:	O
mjd	long
=	O
730201.30984	int
+	O
(	O
365242.37404	int
+	O
(	O
0.05169	int
-	O
(	O
0.00411	int
+	O
0.00057	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
;	O
break	O
;	O
case	O
90	int
:	O
mjd	long
=	O
730294.06767	int
+	O
(	O
365241.62603	int
+	O
(	O
0.00325	int
+	O
(	O
0.00888	int
-	O
0.00030	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
;	O
break	O
;	O
case	O
180	int
:	O
mjd	long
=	O
730387.71715	int
+	O
(	O
365242.01767	int
-	O
(	O
0.11575	int
-	O
(	O
0.00337	int
+	O
0.00078	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
;	O
break	O
;	O
case	O
270	int
:	O
mjd	long
=	O
730477.55925	int
+	O
(	O
365242.74049	int
-	O
(	O
0.06223	int
+	O
(	O
0.00823	int
-	O
0.00032	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
jc	double
=	O
(	O
mjd	long
-	O
730122.5	int
)	O
/	O
36525.0	int
;	O
w	double
=	O
35999.373	int
*	O
jc	double
-	O
2.47	int
;	O
l	double
=	O
1.0	int
+	O
0.0334	int
*	O
cos	function
(	O
TORAD	O
(	O
w	double
)	O
)	O
+	O
0.0007	int
*	O
cos	function
(	O
TORAD	O
(	O
2.0	int
*	O
w	double
)	O
)	O
;	O
c	double
=	O
0.00485	int
*	O
cos	function
(	O
TORAD	O
(	O
324.96	int
+	O
1934.136	int
*	O
jc	double
)	O
)	O
+	O
0.00203	int
*	O
cos	function
(	O
TORAD	O
(	O
337.23	int
+	O
32964.467	int
*	O
jc	double
)	O
)	O
+	O
0.00199	int
*	O
cos	function
(	O
TORAD	O
(	O
342.08	int
+	O
20.186	int
*	O
jc	double
)	O
)	O
+	O
0.00182	int
*	O
cos	function
(	O
TORAD	O
(	O
27.85	int
+	O
445267.112	int
*	O
jc	double
)	O
)	O
+	O
0.00156	int
*	O
cos	function
(	O
TORAD	O
(	O
73.14	int
+	O
45036.886	int
*	O
jc	double
)	O
)	O
+	O
0.00136	int
*	O
cos	function
(	O
TORAD	O
(	O
171.52	int
+	O
22518.443	int
*	O
jc	double
)	O
)	O
+	O
0.00077	int
*	O
cos	function
(	O
TORAD	O
(	O
222.54	int
+	O
65928.934	int
*	O
jc	double
)	O
)	O
+	O
0.00074	int
*	O
cos	function
(	O
TORAD	O
(	O
296.72	int
+	O
3034.906	int
*	O
jc	double
)	O
)	O
+	O
0.00070	int
*	O
cos	function
(	O
TORAD	O
(	O
243.58	int
+	O
9037.513	int
*	O
jc	double
)	O
)	O
+	O
0.00058	int
*	O
cos	function
(	O
TORAD	O
(	O
119.81	int
+	O
33718.147	int
*	O
jc	double
)	O
)	O
+	O
0.00052	int
*	O
cos	function
(	O
TORAD	O
(	O
297.17	int
+	O
150.678	int
*	O
jc	double
)	O
)	O
+	O
0.00050	int
*	O
cos	function
(	O
TORAD	O
(	O
21.02	int
+	O
2281.226	int
*	O
jc	double
)	O
)	O
+	O
0.00045	int
*	O
cos	function
(	O
TORAD	O
(	O
247.54	int
+	O
29929.562	int
*	O
jc	double
)	O
)	O
+	O
0.00044	int
*	O
cos	function
(	O
TORAD	O
(	O
325.15	int
+	O
31555.956	int
*	O
jc	double
)	O
)	O
+	O
0.00029	int
*	O
cos	function
(	O
TORAD	O
(	O
60.93	int
+	O
4443.417	int
*	O
jc	double
)	O
)	O
+	O
0.00018	int
*	O
cos	function
(	O
TORAD	O
(	O
155.12	int
+	O
67555.328	int
*	O
jc	double
)	O
)	O
+	O
0.00017	int
*	O
cos	function
(	O
TORAD	O
(	O
288.79	int
+	O
4562.452	int
*	O
jc	double
)	O
)	O
+	O
0.00016	int
*	O
cos	function
(	O
TORAD	O
(	O
198.04	int
+	O
62894.029	int
*	O
jc	double
)	O
)	O
+	O
0.00014	int
*	O
cos	function
(	O
TORAD	O
(	O
199.76	int
+	O
31436.921	int
*	O
jc	double
)	O
)	O
+	O
0.00012	int
*	O
cos	function
(	O
TORAD	O
(	O
95.39	int
+	O
14577.848	int
*	O
jc	double
)	O
)	O
+	O
0.00012	int
*	O
cos	function
(	O
TORAD	O
(	O
287.11	int
+	O
31931.756	int
*	O
jc	double
)	O
)	O
+	O
0.00012	int
*	O
cos	function
(	O
TORAD	O
(	O
320.81	int
+	O
34777.259	int
*	O
jc	double
)	O
)	O
+	O
0.00009	int
*	O
cos	function
(	O
TORAD	O
(	O
227.73	int
+	O
1222.114	int
*	O
jc	double
)	O
)	O
+	O
0.00008	int
*	O
cos	function
(	O
TORAD	O
(	O
15.45	int
+	O
16859.074	int
*	O
jc	double
)	O
)	O
;	O
mjd	long
+=	O
(	O
c	double
/	O
l	double
)	O
;	O
num2date	function
(	O
(	O
Ulint	long
)	O
mjd	long
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	double
)	O
;	O
val2hours	function
(	O
mjd	long
,	O
&	O
hour	int
,	O
&	O
min	int
,	O
NULL	O
)	O
;	O
mjd	long
-=	O
SS2DAY	O
(	O
delta_t	function
(	O
d	int
,	O
m	int
,	O
y	double
,	O
hour	int
,	O
min	int
)	O
)	O
;	O
mjd	long
+=	O
meridian_time	double
;	O
return	O
(	O
mjd	long
)	O
;	O
}	O
double	O
equinox_solstice	function
(	O
longitude	double
,	O
day	int
,	O
month	int
,	O
year	int
,	O
hour	int
,	O
min	int
)	O
const	O
double	O
longitude	double
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
const	O
int	O
hour	int
;	O
const	O
int	O
min	int
;	O
{	O
auto	O
double	O
mjd	long
;	O
if	O
(	O
*	O
year	int
<	O
6000	int
)	O
{	O
mjd	long
=	O
meeus_equinox_solstice	function
(	O
longitude	double
,	O
*	O
year	int
,	O
hour	int
,	O
min	int
)	O
;	O
num2date	function
(	O
(	O
Ulint	long
)	O
mjd	long
,	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
}	O
else	O
mjd	long
=	O
sun_longitude	function
(	O
longitude	double
,	O
day	int
,	O
month	int
,	O
year	int
,	O
hour	int
,	O
min	int
,	O
FALSE	O
)	O
;	O
return	O
(	O
mjd	long
)	O
;	O
}	O
double	O
delta_t	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
hour	int
,	O
min	int
)	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
const	O
int	O
hour	int
;	O
const	O
int	O
min	int
;	O
{	O
static	O
short	O
int	O
dt_table	array
[	O
]	O
=	O
{	O
8500	int
,	O
8200	int
,	O
7900	int
,	O
7700	int
,	O
7400	int
,	O
7200	int
,	O
7000	int
,	O
6700	int
,	O
6500	int
,	O
6300	int
,	O
6200	int
,	O
6000	int
,	O
5800	int
,	O
5700	int
,	O
5500	int
,	O
5400	int
,	O
5300	int
,	O
5100	int
,	O
5000	int
,	O
4900	int
,	O
4800	int
,	O
4700	int
,	O
4600	int
,	O
4500	int
,	O
4400	int
,	O
4300	int
,	O
4200	int
,	O
4100	int
,	O
4000	int
,	O
3800	int
,	O
3700	int
,	O
3600	int
,	O
3500	int
,	O
3400	int
,	O
3300	int
,	O
3200	int
,	O
3100	int
,	O
3000	int
,	O
2800	int
,	O
2700	int
,	O
2600	int
,	O
2500	int
,	O
2400	int
,	O
2300	int
,	O
2200	int
,	O
2100	int
,	O
2000	int
,	O
1900	int
,	O
1800	int
,	O
1700	int
,	O
1600	int
,	O
1500	int
,	O
1400	int
,	O
1400	int
,	O
1300	int
,	O
1200	int
,	O
1200	int
,	O
1100	int
,	O
1100	int
,	O
1000	int
,	O
1000	int
,	O
1000	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
900	int
,	O
1000	int
,	O
1000	int
,	O
1000	int
,	O
1000	int
,	O
1000	int
,	O
1000	int
,	O
1000	int
,	O
1000	int
,	O
1000	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1100	int
,	O
1200	int
,	O
1200	int
,	O
1200	int
,	O
1200	int
,	O
1200	int
,	O
1200	int
,	O
1200	int
,	O
1200	int
,	O
1200	int
,	O
1200	int
,	O
1300	int
,	O
1300	int
,	O
1300	int
,	O
1300	int
,	O
1300	int
,	O
1300	int
,	O
1300	int
,	O
1400	int
,	O
1400	int
,	O
1400	int
,	O
1400	int
,	O
1400	int
,	O
1400	int
,	O
1400	int
,	O
1500	int
,	O
1500	int
,	O
1500	int
,	O
1500	int
,	O
1500	int
,	O
1500	int
,	O
1500	int
,	O
1600	int
,	O
1600	int
,	O
1600	int
,	O
1600	int
,	O
1600	int
,	O
1600	int
,	O
1600	int
,	O
1600	int
,	O
1600	int
,	O
1600	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1700	int
,	O
1600	int
,	O
1600	int
,	O
1600	int
,	O
1600	int
,	O
1500	int
,	O
1500	int
,	O
1400	int
,	O
1400	int
,	O
1370	int
,	O
1340	int
,	O
1310	int
,	O
1290	int
,	O
1270	int
,	O
1260	int
,	O
1250	int
,	O
1250	int
,	O
1250	int
,	O
1250	int
,	O
1250	int
,	O
1250	int
,	O
1250	int
,	O
1250	int
,	O
1250	int
,	O
1250	int
,	O
1250	int
,	O
1240	int
,	O
1230	int
,	O
1220	int
,	O
1200	int
,	O
1170	int
,	O
1140	int
,	O
1110	int
,	O
1060	int
,	O
1020	int
,	O
960	int
,	O
910	int
,	O
860	int
,	O
800	int
,	O
750	int
,	O
700	int
,	O
660	int
,	O
630	int
,	O
600	int
,	O
580	int
,	O
570	int
,	O
560	int
,	O
560	int
,	O
560	int
,	O
570	int
,	O
580	int
,	O
590	int
,	O
610	int
,	O
620	int
,	O
630	int
,	O
650	int
,	O
660	int
,	O
680	int
,	O
690	int
,	O
710	int
,	O
720	int
,	O
730	int
,	O
740	int
,	O
750	int
,	O
760	int
,	O
770	int
,	O
770	int
,	O
780	int
,	O
780	int
,	O
788	int
,	O
782	int
,	O
754	int
,	O
697	int
,	O
640	int
,	O
602	int
,	O
541	int
,	O
410	int
,	O
292	int
,	O
182	int
,	O
161	int
,	O
10	int
,	O
-	O
102	int
,	O
-	O
128	int
,	O
-	O
269	int
,	O
-	O
324	int
,	O
-	O
364	int
,	O
-	O
454	int
,	O
-	O
471	int
,	O
-	O
511	int
,	O
-	O
540	int
,	O
-	O
542	int
,	O
-	O
520	int
,	O
-	O
546	int
,	O
-	O
546	int
,	O
-	O
579	int
,	O
-	O
563	int
,	O
-	O
564	int
,	O
-	O
580	int
,	O
-	O
566	int
,	O
-	O
587	int
,	O
-	O
601	int
,	O
-	O
619	int
,	O
-	O
664	int
,	O
-	O
644	int
,	O
-	O
647	int
,	O
-	O
609	int
,	O
-	O
576	int
,	O
-	O
466	int
,	O
-	O
374	int
,	O
-	O
272	int
,	O
-	O
154	int
,	O
-	O
2	int
,	O
124	int
,	O
264	int
,	O
386	int
,	O
537	int
,	O
614	int
,	O
775	int
,	O
913	int
,	O
1046	int
,	O
1153	int
,	O
1336	int
,	O
1465	int
,	O
1601	int
,	O
1720	int
,	O
1824	int
,	O
1906	int
,	O
2025	int
,	O
2095	int
,	O
2116	int
,	O
2225	int
,	O
2241	int
,	O
2303	int
,	O
2349	int
,	O
2362	int
,	O
2386	int
,	O
2449	int
,	O
2434	int
,	O
2408	int
,	O
2402	int
,	O
2400	int
,	O
2387	int
,	O
2395	int
,	O
2386	int
,	O
2393	int
,	O
2373	int
,	O
2392	int
,	O
2396	int
,	O
2402	int
,	O
2433	int
,	O
2483	int
,	O
2530	int
,	O
2570	int
,	O
2624	int
,	O
2677	int
,	O
2728	int
,	O
2778	int
,	O
2825	int
,	O
2871	int
,	O
2915	int
,	O
2957	int
,	O
2997	int
,	O
3036	int
,	O
3072	int
,	O
3107	int
,	O
3135	int
,	O
3168	int
,	O
3218	int
,	O
3268	int
,	O
3315	int
,	O
3359	int
,	O
3400	int
,	O
3447	int
,	O
3503	int
,	O
3573	int
,	O
3654	int
,	O
3743	int
,	O
3829	int
,	O
3920	int
,	O
4018	int
,	O
4117	int
,	O
4223	int
,	O
4337	int
,	O
4449	int
,	O
4548	int
,	O
4646	int
,	O
4752	int
,	O
4853	int
,	O
4959	int
,	O
5054	int
,	O
5138	int
,	O
5217	int
,	O
5296	int
,	O
5379	int
,	O
5434	int
,	O
5487	int
,	O
5532	int
,	O
5582	int
,	O
5630	int
,	O
5686	int
,	O
5757	int
,	O
5831	int
,	O
5912	int
,	O
5998	int
,	O
6078	int
,	O
6163	int
,	O
6240	int
,	O
6330	int
,	O
6410	int
,	O
6480	int
,	O
6580	int
,	O
6700	int
,	O
6800	int
,	O
6900	int
,	O
7000	int
,	O
7100	int
,	O
7200	int
,	O
7300	int
,	O
7400	int
,	O
7500	int
,	O
7600	int
}	O
;	O
auto	O
double	O
julian_years	double
;	O
auto	O
double	O
result	double
;	O
auto	O
double	O
p	double
;	O
auto	O
double	O
b	pointer
;	O
static	O
int	O
dt_table_size	int
=	O
sizeof	O
dt_table	array
/	O
sizeof	O
(	O
short	O
int	O
)	O
;	O
static	O
int	O
dt_table_end	int
;	O
static	O
int	O
dt_table_start	int
=	O
1630	int
;	O
auto	O
int	O
dt_diff	array
[	O
6	int
]	O
;	O
register	O
int	O
n	long
;	O
register	O
int	O
i	int
;	O
register	O
int	O
j	int
;	O
static	O
Bool	int
is_initialized	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
is_initialized	int
)	O
{	O
dt_table_end	int
=	O
dt_table_start	int
+	O
dt_table_size	int
-	O
1	int
;	O
is_initialized	int
=	O
TRUE	O
;	O
}	O
julian_years	double
=	O
2000.0	int
+	O
(	O
date2num	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
+	O
HHMM2DAY	O
(	O
hour	int
,	O
min	int
)	O
-	O
730122.0	int
)	O
/	O
365.25	int
;	O
if	O
(	O
year	int
>	O
dt_table_end	int
)	O
{	O
b	pointer
=	O
julian_years	double
-	O
dt_table_end	int
;	O
p	double
=	O
dt_table	array
[	O
dt_table_size	int
-	O
1	int
]	O
-	O
dt_table	array
[	O
dt_table_size	int
-	O
2	int
]	O
;	O
result	double
=	O
(	O
dt_table	array
[	O
dt_table_size	int
-	O
101	int
]	O
-	O
(	O
dt_table	array
[	O
dt_table_size	int
-	O
1	int
]	O
-	O
100.0	int
*	O
p	double
)	O
)	O
*	O
0.0001	int
;	O
return	O
(	O
0.01	int
*	O
(	O
dt_table	array
[	O
dt_table_size	int
-	O
1	int
]	O
+	O
p	double
*	O
b	pointer
+	O
result	double
*	O
b	pointer
*	O
b	pointer
)	O
)	O
;	O
}	O
if	O
(	O
year	int
<	O
dt_table_start	int
)	O
{	O
b	pointer
=	O
0.01	int
*	O
(	O
julian_years	double
-	O
2000.0	int
)	O
;	O
if	O
(	O
year	int
>=	O
948	int
)	O
return	O
(	O
(	O
23.58	int
*	O
b	pointer
+	O
100.3	int
)	O
*	O
b	pointer
+	O
101.6	int
)	O
;	O
b	pointer
+=	O
3.75	int
;	O
return	O
(	O
35.0	int
*	O
b	pointer
*	O
b	pointer
+	O
40.0	int
)	O
;	O
}	O
do	O
{	O
i	int
=	O
year	int
-	O
dt_table_start	int
;	O
j	int
=	O
i	int
+	O
1	int
;	O
result	double
=	O
dt_table	array
[	O
i	int
]	O
;	O
if	O
(	O
j	int
>=	O
dt_table_size	int
)	O
break	O
;	O
p	double
=	O
julian_years	double
-	O
year	int
;	O
result	double
+=	O
(	O
p	double
*	O
(	O
dt_table	array
[	O
j	int
]	O
-	O
dt_table	array
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
i	int
-	O
1	int
<	O
0	int
||	O
i	int
+	O
2	int
>=	O
dt_table_size	int
)	O
break	O
;	O
j	int
=	O
i	int
-	O
2	int
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
5	int
;	O
n	long
++	O
,	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
<	O
0	int
||	O
j	int
+	O
1	int
>=	O
dt_table_size	int
)	O
dt_diff	array
[	O
n	long
]	O
=	O
0	int
;	O
else	O
dt_diff	array
[	O
n	long
]	O
=	O
dt_table	array
[	O
j	int
+	O
1	int
]	O
-	O
dt_table	array
[	O
j	int
]	O
;	O
}	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
4	int
;	O
n	long
++	O
)	O
dt_diff	array
[	O
n	long
]	O
=	O
dt_diff	array
[	O
n	long
+	O
1	int
]	O
-	O
dt_diff	array
[	O
n	long
]	O
;	O
b	pointer
=	O
0.25	int
*	O
p	double
*	O
(	O
p	double
-	O
1.0	int
)	O
;	O
result	double
+=	O
b	pointer
*	O
(	O
dt_diff	array
[	O
1	int
]	O
+	O
dt_diff	array
[	O
2	int
]	O
)	O
;	O
if	O
(	O
i	int
+	O
2	int
>=	O
dt_table_size	int
)	O
break	O
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
3	int
;	O
n	long
++	O
)	O
dt_diff	array
[	O
n	long
]	O
=	O
dt_diff	array
[	O
n	long
+	O
1	int
]	O
-	O
dt_diff	array
[	O
n	long
]	O
;	O
b	pointer
=	O
2.0	int
*	O
b	pointer
/	O
3.0	int
;	O
result	double
+=	O
(	O
(	O
p	double
-	O
0.5	int
)	O
*	O
b	pointer
*	O
dt_diff	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
i	int
-	O
2	int
<	O
0	int
||	O
i	int
+	O
3	int
>	O
dt_table_size	int
)	O
break	O
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
2	int
;	O
n	long
++	O
)	O
dt_diff	array
[	O
n	long
]	O
=	O
dt_diff	array
[	O
n	long
+	O
1	int
]	O
-	O
dt_diff	array
[	O
n	long
]	O
;	O
b	pointer
=	O
0.125	int
*	O
b	pointer
*	O
(	O
p	double
+	O
1.0	int
)	O
*	O
(	O
p	double
-	O
2.0	int
)	O
;	O
result	double
+=	O
(	O
b	pointer
*	O
(	O
dt_diff	array
[	O
0	int
]	O
+	O
dt_diff	array
[	O
1	int
]	O
)	O
)	O
;	O
}	O
while	O
(	O
FALSE	O
)	O
;	O
result	double
*=	O
0.01	int
;	O
if	O
(	O
year	int
<	O
1955	int
)	O
{	O
b	pointer
=	O
(	O
julian_years	double
-	O
1955.0	int
)	O
;	O
result	double
+=	O
(	O
-	O
0.000091	int
*	O
(	O
-	O
25.8	int
+	O
26.0	int
)	O
*	O
b	pointer
*	O
b	pointer
)	O
;	O
}	O
return	O
(	O
result	double
)	O
;	O
}	O
double	O
moonphase	function
(	O
phase_selector	double
,	O
find_eclipse	int
,	O
eclipse_type	pointer
,	O
lunation	pointer
,	O
day	int
,	O
month	int
,	O
year	int
,	O
hour	int
,	O
min	int
)	O
const	O
double	O
phase_selector	double
;	O
const	O
Bool	int
find_eclipse	int
;	O
double	O
*	O
eclipse_type	pointer
;	O
Ulint	long
*	O
lunation	pointer
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
int	O
hour	int
;	O
int	O
min	int
;	O
{	O
auto	O
double	O
the_lunation	double
;	O
auto	O
double	O
jc_julian_centuries	double
;	O
auto	O
double	O
jc_jc	double
;	O
auto	O
double	O
julian_date	double
;	O
auto	O
double	O
sea_sun_eccent_anomaly	double
;	O
auto	O
double	O
sea_sea	double
;	O
auto	O
double	O
sma_sun_mean_anomaly	double
;	O
auto	O
double	O
sma_2	double
;	O
auto	O
double	O
mma_moon_mean_anomaly	double
;	O
auto	O
double	O
mma_2	double
;	O
auto	O
double	O
mma_3	double
;	O
auto	O
double	O
mma_m_sma	double
;	O
auto	O
double	O
mma_p_sma	double
;	O
auto	O
double	O
mla_moon_latitude	double
;	O
auto	O
double	O
mla_2	double
;	O
auto	O
double	O
moon_longitude	double
;	O
auto	O
double	O
meridian_time	double
=	O
HHMM2DAY	O
(	O
hour	int
,	O
min	int
)	O
;	O
auto	O
double	O
mjd	long
=	O
0.0	int
;	O
auto	O
double	O
jd	double
=	O
0.0	int
;	O
auto	O
double	O
jd2	double
;	O
auto	O
double	O
a	pointer
;	O
auto	O
double	O
coeff1	double
;	O
auto	O
double	O
coeff2	double
;	O
register	O
int	O
selector	int
=	O
(	O
int	O
)	O
ROUND	O
(	O
phase_selector	double
*	O
4.0	int
)	O
;	O
auto	O
Bool	int
is_lunation_given	int
=	O
(	O
*	O
lunation	pointer
!=	O
0L	int
)	O
;	O
if	O
(	O
!	O
is_lunation_given	int
)	O
{	O
jd	double
=	O
date2num	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
)	O
+	O
meridian_time	double
;	O
num2date	function
(	O
(	O
Ulint	long
)	O
jd	double
,	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
val2hours	function
(	O
jd	double
,	O
&	O
hour	int
,	O
&	O
min	int
,	O
NULL	O
)	O
;	O
mjd	long
=	O
jd	double
+	O
SS2DAY	O
(	O
delta_t	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
,	O
hour	int
,	O
min	int
)	O
)	O
;	O
the_lunation	double
=	O
(	O
Slint	long
)	O
(	O
(	O
mjd	long
+	O
0.11111112	int
)	O
/	O
29.5305892	int
)	O
+	O
1.0	int
;	O
*	O
lunation	pointer
=	O
(	O
Ulint	long
)	O
the_lunation	double
;	O
}	O
else	O
the_lunation	double
=	O
*	O
lunation	pointer
;	O
the_lunation	double
-=	O
(	O
24725.0	int
-	O
phase_selector	double
)	O
;	O
LOOP	O
{	O
jc_julian_centuries	double
=	O
the_lunation	double
/	O
1236.85	int
;	O
jc_jc	double
=	O
jc_julian_centuries	double
*	O
jc_julian_centuries	double
;	O
jd2	double
=	O
julian_date	double
=	O
2451550.09765	int
+	O
29.530588853	int
*	O
the_lunation	double
+	O
jc_jc	double
*	O
(	O
0.0001337	int
+	O
jc_julian_centuries	double
*	O
(	O
-	O
0.000000150	int
+	O
0.00000000073	int
*	O
jc_julian_centuries	double
)	O
)	O
;	O
sea_sun_eccent_anomaly	double
=	O
1.0	int
+	O
jc_julian_centuries	double
*	O
(	O
-	O
0.002516	int
+	O
-	O
0.0000074	int
*	O
jc_julian_centuries	double
)	O
;	O
sma_sun_mean_anomaly	double
=	O
TORAD	O
(	O
2.5534	int
+	O
29.10535669	int
*	O
the_lunation	double
+	O
jc_jc	double
*	O
(	O
-	O
0.0000218	int
+	O
-	O
0.00000011	int
*	O
jc_julian_centuries	double
)	O
)	O
;	O
mma_moon_mean_anomaly	double
=	O
TORAD	O
(	O
201.5643	int
+	O
385.81693528	int
*	O
the_lunation	double
+	O
jc_jc	double
*	O
(	O
0.0107438	int
+	O
jc_julian_centuries	double
*	O
(	O
0.00001239	int
+	O
-	O
0.000000058	int
*	O
jc_julian_centuries	double
)	O
)	O
)	O
;	O
mla_moon_latitude	double
=	O
TORAD	O
(	O
160.7108	int
+	O
390.67050274	int
*	O
the_lunation	double
+	O
jc_jc	double
*	O
(	O
-	O
0.0016341	int
*	O
jc_julian_centuries	double
*	O
(	O
-	O
0.00000227	int
+	O
0.000000011	int
*	O
jc_julian_centuries	double
)	O
)	O
)	O
;	O
moon_longitude	double
=	O
TORAD	O
(	O
124.7746	int
-	O
1.56375580	int
*	O
the_lunation	double
+	O
jc_jc	double
*	O
(	O
0.0020691	int
+	O
0.00000215	int
*	O
jc_julian_centuries	double
)	O
)	O
;	O
mla_2	double
=	O
2.0	int
*	O
mla_moon_latitude	double
;	O
sma_2	double
=	O
2.0	int
*	O
sma_sun_mean_anomaly	double
;	O
mma_2	double
=	O
2.0	int
*	O
mma_moon_mean_anomaly	double
;	O
mma_3	double
=	O
3.0	int
*	O
mma_moon_mean_anomaly	double
;	O
mma_m_sma	double
=	O
mma_moon_mean_anomaly	double
-	O
sma_sun_mean_anomaly	double
;	O
mma_p_sma	double
=	O
mma_moon_mean_anomaly	double
+	O
sma_sun_mean_anomaly	double
;	O
sea_sea	double
=	O
sea_sun_eccent_anomaly	double
*	O
sea_sun_eccent_anomaly	double
;	O
a	pointer
=	O
TORAD	O
(	O
299.77	int
+	O
0.107408	int
*	O
the_lunation	double
-	O
0.009173	int
*	O
jc_jc	double
)	O
;	O
coeff1	double
=	O
0.000325	int
*	O
sin	function
(	O
a	pointer
)	O
+	O
0.000165	int
*	O
sin	function
(	O
TORAD	O
(	O
251.88	int
+	O
0.016321	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000164	int
*	O
sin	function
(	O
TORAD	O
(	O
251.83	int
+	O
26.651886	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000126	int
*	O
sin	function
(	O
TORAD	O
(	O
349.42	int
+	O
36.412478	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000110	int
*	O
sin	function
(	O
TORAD	O
(	O
84.66	int
+	O
18.206239	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000062	int
*	O
sin	function
(	O
TORAD	O
(	O
141.74	int
+	O
53.303771	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000060	int
*	O
sin	function
(	O
TORAD	O
(	O
207.14	int
+	O
2.453732	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000056	int
*	O
sin	function
(	O
TORAD	O
(	O
154.84	int
+	O
7.306860	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000047	int
*	O
sin	function
(	O
TORAD	O
(	O
34.52	int
+	O
27.261239	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000042	int
*	O
sin	function
(	O
TORAD	O
(	O
207.19	int
+	O
0.121824	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000040	int
*	O
sin	function
(	O
TORAD	O
(	O
291.34	int
+	O
1.844379	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000037	int
*	O
sin	function
(	O
TORAD	O
(	O
161.72	int
+	O
24.198154	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000035	int
*	O
sin	function
(	O
TORAD	O
(	O
239.56	int
+	O
25.513099	int
*	O
the_lunation	double
)	O
)	O
+	O
0.000023	int
*	O
sin	function
(	O
TORAD	O
(	O
331.55	int
+	O
3.592518	int
*	O
the_lunation	double
)	O
)	O
;	O
if	O
(	O
!	O
(	O
selector	int
&	O
1	int
)	O
)	O
coeff2	double
=	O
-	O
0.00111	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
mla_2	double
)	O
-	O
0.00057	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
+	O
mla_2	double
)	O
+	O
0.00056	int
*	O
sin	function
(	O
mma_2	double
+	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.00042	int
*	O
sin	function
(	O
mma_3	double
)	O
+	O
0.00042	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
+	O
mla_2	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.00038	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
-	O
mla_2	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.00024	int
*	O
sin	function
(	O
mma_2	double
-	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.00017	int
*	O
sin	function
(	O
moon_longitude	double
)	O
-	O
0.00007	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
+	O
sma_2	double
)	O
+	O
0.00004	int
*	O
sin	function
(	O
mma_2	double
-	O
mla_2	double
)	O
+	O
0.00004	int
*	O
sin	function
(	O
3.0	int
*	O
sma_sun_mean_anomaly	double
)	O
+	O
0.00003	int
*	O
sin	function
(	O
mma_p_sma	double
-	O
mla_2	double
)	O
+	O
0.00003	int
*	O
sin	function
(	O
mma_2	double
+	O
mla_2	double
)	O
-	O
0.00003	int
*	O
sin	function
(	O
mma_p_sma	double
+	O
mla_2	double
)	O
+	O
0.00003	int
*	O
sin	function
(	O
mma_m_sma	double
+	O
mla_2	double
)	O
-	O
0.00002	int
*	O
sin	function
(	O
mma_m_sma	double
-	O
mla_2	double
)	O
-	O
0.00002	int
*	O
sin	function
(	O
mma_3	double
+	O
sma_sun_mean_anomaly	double
)	O
+	O
0.00002	int
*	O
sin	function
(	O
4.0	int
*	O
mma_moon_mean_anomaly	double
)	O
;	O
else	O
coeff2	double
=	O
0.00306	int
-	O
0.00038	int
*	O
cos	function
(	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.00026	int
*	O
cos	function
(	O
mma_moon_mean_anomaly	double
)	O
-	O
0.00002	int
*	O
cos	function
(	O
mma_m_sma	double
)	O
+	O
0.00002	int
*	O
cos	function
(	O
mma_p_sma	double
)	O
+	O
0.00002	int
*	O
cos	function
(	O
mla_2	double
)	O
;	O
switch	O
(	O
selector	int
)	O
{	O
case	O
0	int
:	O
julian_date	double
+=	O
(	O
-	O
0.40720	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
)	O
+	O
0.17241	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.01608	int
*	O
sin	function
(	O
mma_2	double
)	O
+	O
0.01039	int
*	O
sin	function
(	O
mla_2	double
)	O
+	O
0.00739	int
*	O
sin	function
(	O
mma_m_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.00514	int
*	O
sin	function
(	O
mma_p_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.00208	int
*	O
sin	function
(	O
sma_2	double
)	O
*	O
sea_sea	double
)	O
;	O
break	O
;	O
case	O
2	int
:	O
julian_date	double
+=	O
(	O
-	O
0.40614	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
)	O
+	O
0.17302	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.01614	int
*	O
sin	function
(	O
mma_2	double
)	O
+	O
0.01043	int
*	O
sin	function
(	O
mla_2	double
)	O
+	O
0.00734	int
*	O
sin	function
(	O
mma_m_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.00515	int
*	O
sin	function
(	O
mma_p_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.00209	int
*	O
sin	function
(	O
sma_2	double
)	O
*	O
sea_sea	double
)	O
;	O
break	O
;	O
case	O
3	int
:	O
coeff2	double
=	O
-	O
coeff2	double
;	O
case	O
1	int
:	O
julian_date	double
+=	O
(	O
-	O
0.62801	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
)	O
+	O
0.17172	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.01183	int
*	O
sin	function
(	O
mma_p_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.00862	int
*	O
sin	function
(	O
mma_2	double
)	O
+	O
0.00804	int
*	O
sin	function
(	O
mla_2	double
)	O
+	O
0.00454	int
*	O
sin	function
(	O
mma_m_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.00204	int
*	O
sin	function
(	O
sma_2	double
)	O
*	O
sea_sea	double
-	O
0.00180	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
mla_2	double
)	O
-	O
0.00070	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
+	O
mla_2	double
)	O
-	O
0.00040	int
*	O
sin	function
(	O
mma_3	double
)	O
-	O
0.00034	int
*	O
sin	function
(	O
mma_2	double
-	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.00032	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
+	O
mla_2	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.00032	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
-	O
mla_2	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.00028	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
+	O
sma_2	double
)	O
*	O
sea_sea	double
+	O
0.00027	int
*	O
sin	function
(	O
mma_2	double
+	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.00017	int
*	O
sin	function
(	O
moon_longitude	double
)	O
-	O
0.00005	int
*	O
sin	function
(	O
mma_m_sma	double
-	O
mla_2	double
)	O
+	O
0.00004	int
*	O
sin	function
(	O
mma_2	double
+	O
mla_2	double
)	O
-	O
0.00004	int
*	O
sin	function
(	O
mma_p_sma	double
+	O
mla_2	double
)	O
+	O
0.00004	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
sma_2	double
)	O
+	O
0.00003	int
*	O
sin	function
(	O
mma_p_sma	double
-	O
mla_2	double
)	O
+	O
0.00003	int
*	O
sin	function
(	O
3.0	int
*	O
sma_sun_mean_anomaly	double
)	O
+	O
0.00002	int
*	O
sin	function
(	O
mma_2	double
-	O
mla_2	double
)	O
+	O
0.00002	int
*	O
sin	function
(	O
mma_m_sma	double
+	O
mla_2	double
)	O
-	O
0.00002	int
*	O
sin	function
(	O
mma_3	double
+	O
sma_sun_mean_anomaly	double
)	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
julian_date	double
+=	O
(	O
coeff1	double
+	O
coeff2	double
)	O
;	O
julian_date	double
-=	O
(	O
MIN_BCE_TO_1_CE	int
-	O
1.5	int
)	O
;	O
num2date	function
(	O
(	O
Ulint	long
)	O
julian_date	double
,	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
val2hours	function
(	O
julian_date	double
,	O
&	O
hour	int
,	O
&	O
min	int
,	O
NULL	O
)	O
;	O
julian_date	double
-=	O
SS2DAY	O
(	O
delta_t	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
,	O
hour	int
,	O
min	int
)	O
)	O
;	O
julian_date	double
+=	O
meridian_time	double
;	O
num2date	function
(	O
(	O
Ulint	long
)	O
julian_date	double
,	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
if	O
(	O
!	O
is_lunation_given	int
)	O
{	O
if	O
(	O
(	O
Ulint	long
)	O
julian_date	double
<	O
(	O
Ulint	long
)	O
jd	double
)	O
{	O
the_lunation	double
+=	O
1.0	int
;	O
(	O
*	O
lunation	pointer
)	O
++	O
;	O
}	O
else	O
break	O
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
eclipse_type	pointer
!=	O
(	O
double	O
*	O
)	O
NULL	O
)	O
*	O
eclipse_type	pointer
=	O
SPECIAL_VALUE	O
;	O
if	O
(	O
find_eclipse	int
&&	O
!	O
(	O
selector	int
&	O
1	int
)	O
)	O
{	O
if	O
(	O
eclipse_type	pointer
==	O
(	O
double	O
*	O
)	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
sin	function
(	O
abs	function
(	O
mla_moon_latitude	double
)	O
)	O
<=	O
0.36	int
)	O
{	O
auto	O
double	O
f	double
;	O
auto	O
double	O
f_2	double
;	O
auto	O
double	O
p	double
;	O
auto	O
double	O
q	double
;	O
auto	O
double	O
g	double
;	O
auto	O
double	O
u	double
;	O
f	double
=	O
mla_moon_latitude	double
-	O
0.02665	int
*	O
sin	function
(	O
moon_longitude	double
)	O
;	O
f_2	double
=	O
2.0	int
*	O
f	double
;	O
p	double
=	O
0.2070	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.0024	int
*	O
sin	function
(	O
sma_2	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.0392	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
)	O
+	O
0.0116	int
*	O
sin	function
(	O
mma_2	double
)	O
-	O
0.0730	int
*	O
sin	function
(	O
mma_p_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.0067	int
*	O
sin	function
(	O
mma_m_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.0118	int
*	O
sin	function
(	O
f_2	double
)	O
;	O
q	double
=	O
5.2207	int
-	O
0.0048	int
*	O
cos	function
(	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.0020	int
*	O
cos	function
(	O
sma_2	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.3299	int
*	O
cos	function
(	O
mma_moon_mean_anomaly	double
)	O
-	O
0.0060	int
*	O
cos	function
(	O
mma_p_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.0041	int
*	O
cos	function
(	O
mma_m_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
;	O
g	double
=	O
(	O
p	double
*	O
cos	function
(	O
f	double
)	O
+	O
q	double
*	O
sin	function
(	O
f	double
)	O
)	O
*	O
(	O
1.0	int
-	O
0.0048	int
*	O
cos	function
(	O
abs	function
(	O
f	double
)	O
)	O
)	O
;	O
u	double
=	O
0.0059	int
+	O
0.0046	int
*	O
cos	function
(	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.0182	int
*	O
cos	function
(	O
mma_moon_mean_anomaly	double
)	O
+	O
0.0004	int
*	O
cos	function
(	O
mma_2	double
)	O
-	O
0.0005	int
*	O
cos	function
(	O
mma_p_sma	double
)	O
;	O
if	O
(	O
phase_selector	double
==	O
MPHASE_FUL	int
)	O
{	O
f	double
=	O
(	O
1.0248	int
-	O
u	double
-	O
abs	function
(	O
g	double
)	O
)	O
/	O
0.545	int
;	O
if	O
(	O
f	double
>	O
-	O
1.059	int
)	O
{	O
if	O
(	O
f	double
<	O
0.0	int
)	O
*	O
eclipse_type	pointer
=	O
ECLIPSE_PENUMBRAL	int
;	O
else	O
{	O
if	O
(	O
(	O
(	O
1.0128	int
-	O
u	double
-	O
abs	function
(	O
g	double
)	O
)	O
/	O
0.545	int
>	O
0.0	int
)	O
&&	O
(	O
(	O
0.4678	int
-	O
u	double
)	O
*	O
(	O
0.4678	int
-	O
u	double
)	O
-	O
g	double
*	O
g	double
>	O
0.0	int
)	O
)	O
*	O
eclipse_type	pointer
=	O
ECLIPSE_TOTAL	int
;	O
else	O
*	O
eclipse_type	pointer
=	O
ECLIPSE_PARTIAL	int
;	O
}	O
coeff1	double
=	O
-	O
0.4065	int
;	O
coeff2	double
=	O
0.1727	int
;	O
}	O
}	O
else	O
if	O
(	O
abs	function
(	O
g	double
)	O
<=	O
1.5433	int
+	O
u	double
)	O
{	O
if	O
(	O
(	O
(	O
g	double
>=	O
-	O
0.9972	int
)	O
&&	O
(	O
g	double
<=	O
0.9972	int
)	O
)	O
||	O
(	O
(	O
abs	function
(	O
g	double
)	O
>=	O
0.9972	int
)	O
&&	O
(	O
abs	function
(	O
g	double
)	O
<	O
0.9972	int
+	O
abs	function
(	O
u	double
)	O
)	O
)	O
)	O
{	O
if	O
(	O
u	double
<	O
0.0	int
||	O
(	O
(	O
g	double
>	O
0.0	int
)	O
&&	O
(	O
u	double
>=	O
0.0	int
)	O
&&	O
(	O
u	double
<=	O
0.0047	int
)	O
&&	O
(	O
u	double
<	O
0.00464	int
*	O
sqrt	function
(	O
1.0	int
-	O
g	double
*	O
g	double
)	O
)	O
)	O
)	O
*	O
eclipse_type	pointer
=	O
ECLIPSE_TOTAL	int
;	O
else	O
*	O
eclipse_type	pointer
=	O
ECLIPSE_ANNULAR	int
;	O
}	O
else	O
*	O
eclipse_type	pointer
=	O
ECLIPSE_PARTIAL	int
;	O
coeff1	double
=	O
-	O
0.4075	int
;	O
coeff2	double
=	O
0.1721	int
;	O
}	O
if	O
(	O
*	O
eclipse_type	pointer
!=	O
SPECIAL_VALUE	O
)	O
{	O
auto	O
int	O
d	int
;	O
auto	O
int	O
m	int
;	O
auto	O
int	O
y	double
;	O
jd2	double
+=	O
(	O
coeff1	double
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
)	O
+	O
coeff2	double
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.0161	int
*	O
sin	function
(	O
mma_2	double
)	O
-	O
0.0097	int
*	O
sin	function
(	O
f_2	double
)	O
+	O
0.0073	int
*	O
sin	function
(	O
mma_m_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.0050	int
*	O
sin	function
(	O
mma_p_sma	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.0023	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
-	O
f_2	double
)	O
+	O
0.0021	int
*	O
sin	function
(	O
sma_2	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.0012	int
*	O
sin	function
(	O
mma_moon_mean_anomaly	double
+	O
f_2	double
)	O
+	O
0.0006	int
*	O
sin	function
(	O
mma_2	double
+	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.0004	int
*	O
sin	function
(	O
mma_3	double
)	O
-	O
0.0003	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
+	O
f_2	double
)	O
*	O
sea_sun_eccent_anomaly	double
+	O
0.0003	int
*	O
sin	function
(	O
a	pointer
)	O
-	O
0.0002	int
*	O
sin	function
(	O
sma_sun_mean_anomaly	double
-	O
f_2	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.0002	int
*	O
sin	function
(	O
mma_2	double
-	O
sma_sun_mean_anomaly	double
)	O
*	O
sea_sun_eccent_anomaly	double
-	O
0.0002	int
*	O
sin	function
(	O
moon_longitude	double
)	O
)	O
;	O
jd2	double
-=	O
(	O
MIN_BCE_TO_1_CE	int
-	O
1.5	int
)	O
;	O
num2date	function
(	O
(	O
Ulint	long
)	O
jd2	double
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	double
)	O
;	O
val2hours	function
(	O
jd2	double
,	O
&	O
hour	int
,	O
&	O
min	int
,	O
NULL	O
)	O
;	O
jd2	double
-=	O
SS2DAY	O
(	O
delta_t	function
(	O
d	int
,	O
m	int
,	O
y	double
,	O
hour	int
,	O
min	int
)	O
)	O
;	O
jd2	double
+=	O
meridian_time	double
;	O
*	O
eclipse_type	pointer
+=	O
jd2	double
;	O
}	O
}	O
}	O
return	O
(	O
julian_date	double
)	O
;	O
}	O
double	O
next_sun_longitude	function
(	O
longitude	double
,	O
step	double
,	O
mjd	long
,	O
day	int
,	O
month	int
,	O
year	int
,	O
hour	int
,	O
min	int
)	O
double	O
*	O
longitude	double
;	O
const	O
double	O
step	double
;	O
const	O
double	O
mjd	long
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
const	O
int	O
hour	int
;	O
const	O
int	O
min	int
;	O
{	O
auto	O
double	O
next	double
;	O
*	O
longitude	double
+=	O
step	double
;	O
if	O
(	O
*	O
longitude	double
>=	O
DEGS_PER_24_HOURS	int
)	O
*	O
longitude	double
=	O
(	O
double	O
)	O
(	O
(	O
(	O
(	O
int	O
)	O
*	O
longitude	double
)	O
%	O
(	O
int	O
)	O
DEGS_PER_24_HOURS	int
)	O
+	O
(	O
*	O
longitude	double
-	O
(	O
int	O
)	O
*	O
longitude	double
)	O
)	O
;	O
next	double
=	O
sun_longitude	function
(	O
*	O
longitude	double
,	O
day	int
,	O
month	int
,	O
year	int
,	O
hour	int
,	O
min	int
,	O
TRUE	O
)	O
;	O
if	O
(	O
(	O
Slint	long
)	O
next	double
-	O
(	O
Slint	long
)	O
mjd	long
<	O
0L	int
||	O
(	O
Slint	long
)	O
next	double
-	O
(	O
Slint	long
)	O
mjd	long
>	O
DAY_LAST	int
||	O
next	double
==	O
SPECIAL_VALUE	O
)	O
{	O
if	O
(	O
(	O
Slint	long
)	O
next	double
-	O
(	O
Slint	long
)	O
mjd	long
>	O
DAY_LAST	int
)	O
{	O
(	O
*	O
year	int
)	O
--	O
;	O
next	double
=	O
sun_longitude	function
(	O
*	O
longitude	double
,	O
day	int
,	O
month	int
,	O
year	int
,	O
hour	int
,	O
min	int
,	O
FALSE	O
)	O
;	O
}	O
else	O
{	O
(	O
*	O
year	int
)	O
++	O
;	O
next	double
=	O
sun_longitude	function
(	O
*	O
longitude	double
,	O
day	int
,	O
month	int
,	O
year	int
,	O
hour	int
,	O
min	int
,	O
TRUE	O
)	O
;	O
}	O
}	O
return	O
(	O
next	double
)	O
;	O
}	O
double	O
sun_longitude	function
(	O
longitude	double
,	O
day	int
,	O
month	int
,	O
year	int
,	O
hour	int
,	O
min	int
,	O
next_mode	int
)	O
const	O
double	O
longitude	double
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
int	O
hour	int
;	O
int	O
min	int
;	O
const	O
Bool	int
next_mode	int
;	O
{	O
auto	O
double	O
x	double
;	O
auto	O
double	O
low	double
=	O
0.0	int
;	O
auto	O
double	O
high	double
=	O
0.0	int
;	O
auto	O
double	O
delta	double
;	O
auto	O
double	O
meridian_time	double
=	O
HHMM2DAY	O
(	O
hour	int
,	O
min	int
)	O
;	O
auto	O
double	O
mjd	long
;	O
auto	O
double	O
jc	double
;	O
auto	O
double	O
argument_of_perihelion	double
;	O
auto	O
double	O
mean_anomaly	double
;	O
auto	O
double	O
eccentricity	double
;	O
auto	O
double	O
anomaly_of_eccentric	double
;	O
auto	O
double	O
divisor_term	double
;	O
auto	O
double	O
true_anomaly	double
;	O
auto	O
double	O
ecliptic_longitude	double
;	O
register	O
int	O
y	double
=	O
*	O
year	int
;	O
register	O
int	O
steps	int
=	O
0	int
;	O
register	O
int	O
i	int
;	O
LABEL_sel_start	O
:	O
i	int
=	O
0	int
;	O
if	O
(	O
longitude	double
==	O
SPECIAL_VALUE	O
)	O
mjd	long
=	O
date2num	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
)	O
+	O
SS2DAY	O
(	O
delta_t	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
,	O
hour	int
,	O
min	int
)	O
)	O
+	O
meridian_time	double
-	O
730122.5	int
;	O
else	O
{	O
mjd	long
=	O
date2num	function
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
*	O
year	int
)	O
+	O
SS2DAY	O
(	O
delta_t	function
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
*	O
year	int
,	O
hour	int
,	O
min	int
)	O
)	O
-	O
730122.5	int
;	O
if	O
(	O
*	O
year	int
<=	O
greg	pointer
->	O
year	int
)	O
mjd	long
-=	O
(	O
(	O
*	O
year	int
/	O
100	int
)	O
-	O
(	O
*	O
year	int
/	O
400	int
)	O
-	O
2	int
)	O
;	O
low	double
=	O
mjd	long
+	O
longitude	double
+	O
65.0	int
;	O
high	double
=	O
mjd	long
+	O
longitude	double
+	O
95.0	int
;	O
mjd	long
=	O
(	O
high	double
+	O
low	double
)	O
*	O
0.5	int
;	O
}	O
LOOP	O
{	O
jc	double
=	O
mjd	long
/	O
36525.0	int
;	O
argument_of_perihelion	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
282.93735	int
+	O
(	O
0.71953	int
+	O
(	O
0.00046	int
*	O
jc	double
)	O
)	O
*	O
jc	double
)	O
)	O
;	O
mean_anomaly	double
=	O
TORAD	O
(	O
FIXANGLE	O
(	O
357.52910	int
+	O
(	O
35999.05030	int
-	O
(	O
0.0001559	int
+	O
0.00000048	int
*	O
jc	double
)	O
*	O
jc	double
)	O
*	O
jc	double
)	O
)	O
;	O
eccentricity	double
=	O
0.016708617	int
-	O
(	O
0.000042037	int
+	O
(	O
0.0000001236	int
*	O
jc	double
)	O
)	O
*	O
jc	double
;	O
delta	double
=	O
mean_anomaly	double
+	O
eccentricity	double
*	O
sin	function
(	O
mean_anomaly	double
)	O
*	O
(	O
1.0	int
+	O
eccentricity	double
*	O
cos	function
(	O
mean_anomaly	double
)	O
)	O
;	O
do	O
{	O
x	double
=	O
delta	double
;	O
delta	double
=	O
x	double
-	O
(	O
x	double
-	O
eccentricity	double
*	O
sin	function
(	O
x	double
)	O
-	O
mean_anomaly	double
)	O
/	O
(	O
1.0	int
-	O
eccentricity	double
*	O
cos	function
(	O
x	double
)	O
)	O
;	O
}	O
while	O
(	O
abs	function
(	O
abs	function
(	O
x	double
)	O
-	O
abs	function
(	O
delta	double
)	O
)	O
>	O
0.000001	int
)	O
;	O
anomaly_of_eccentric	double
=	O
delta	double
;	O
divisor_term	double
=	O
cos	function
(	O
anomaly_of_eccentric	double
)	O
-	O
eccentricity	double
;	O
true_anomaly	double
=	O
atan	function
(	O
(	O
sqrt	function
(	O
1.0	int
-	O
eccentricity	double
*	O
eccentricity	double
)	O
*	O
sin	function
(	O
anomaly_of_eccentric	double
)	O
)	O
/	O
divisor_term	double
)	O
;	O
if	O
(	O
divisor_term	double
<	O
0.0	int
)	O
true_anomaly	double
+=	O
MY_PI	int
;	O
ecliptic_longitude	double
=	O
FIXANGLE	O
(	O
TODEG	O
(	O
true_anomaly	double
+	O
argument_of_perihelion	double
)	O
+	O
jc	double
-	O
0.00569	int
-	O
0.00479	int
*	O
sin	function
(	O
TORAD	O
(	O
124.90	int
-	O
(	O
1934.134	int
-	O
(	O
0.002063	int
*	O
jc	double
)	O
)	O
*	O
jc	double
)	O
)	O
)	O
;	O
if	O
(	O
longitude	double
==	O
SPECIAL_VALUE	O
)	O
return	O
(	O
ecliptic_longitude	double
)	O
;	O
delta	double
=	O
abs	function
(	O
longitude	double
-	O
abs	function
(	O
ecliptic_longitude	double
)	O
)	O
;	O
if	O
(	O
delta	double
>	O
DEGS_PER_12_HOURS	int
)	O
{	O
ecliptic_longitude	double
-=	O
DEGS_PER_24_HOURS	int
;	O
if	O
(	O
(	O
longitude	double
>	O
330.0	int
)	O
&&	O
(	O
abs	function
(	O
ecliptic_longitude	double
)	O
<	O
longitude	double
)	O
)	O
ecliptic_longitude	double
=	O
longitude	double
+	O
1.0	int
;	O
else	O
if	O
(	O
ecliptic_longitude	double
<	O
-	O
DEGS_PER_12_HOURS	int
)	O
ecliptic_longitude	double
=	O
-	O
ecliptic_longitude	double
;	O
}	O
if	O
(	O
delta	double
>	O
0.000001	int
)	O
{	O
if	O
(	O
ecliptic_longitude	double
>	O
longitude	double
)	O
high	double
=	O
mjd	long
;	O
else	O
low	double
=	O
mjd	long
;	O
mjd	long
=	O
(	O
high	double
+	O
low	double
)	O
*	O
0.5	int
;	O
}	O
else	O
break	O
;	O
if	O
(	O
++	O
i	int
>=	O
100	int
)	O
my_error	function
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"sun_longitude():interpolation<"	pointer
,	O
i	int
)	O
;	O
}	O
mjd	long
+=	O
730122.5	int
;	O
num2date	function
(	O
(	O
Ulint	long
)	O
mjd	long
,	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
val2hours	function
(	O
mjd	long
,	O
&	O
hour	int
,	O
&	O
min	int
,	O
NULL	O
)	O
;	O
mjd	long
-=	O
SS2DAY	O
(	O
delta_t	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
*	O
year	int
,	O
hour	int
,	O
min	int
)	O
)	O
;	O
mjd	long
+=	O
meridian_time	double
;	O
num2date	function
(	O
(	O
Ulint	long
)	O
mjd	long
,	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
if	O
(	O
!	O
next_mode	int
&&	O
(	O
y	double
!=	O
*	O
year	int
)	O
)	O
{	O
if	O
(	O
++	O
steps	int
>	O
1	int
)	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
*	O
year	int
-=	O
2	int
;	O
if	O
(	O
!	O
*	O
year	int
)	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
goto	O
LABEL_sel_start	O
;	O
}	O
delta	double
=	O
mjd	long
-	O
(	O
Slint	long
)	O
mjd	long
;	O
if	O
(	O
delta	double
<	O
0.0	int
)	O
mjd	long
=	O
(	O
Slint	long
)	O
mjd	long
+	O
(	O
1.0	int
+	O
delta	double
)	O
;	O
return	O
(	O
mjd	long
)	O
;	O
}	O
void	O
val2hours	function
(	O
val	double
,	O
hour	int
,	O
min	int
,	O
sec	pointer
)	O
double	O
val	double
;	O
int	O
*	O
hour	int
;	O
int	O
*	O
min	int
;	O
double	O
*	O
sec	pointer
;	O
{	O
register	O
int	O
sign	int
=	O
SGN	O
(	O
val	double
)	O
;	O
val	double
=	O
abs	function
(	O
val	double
)	O
;	O
val	double
-=	O
(	O
Ulint	long
)	O
val	double
;	O
val	double
*=	O
HOURS_PER_DAY	int
;	O
*	O
hour	int
=	O
(	O
int	O
)	O
val	double
;	O
val	double
-=	O
(	O
int	O
)	O
val	double
;	O
if	O
(	O
sec	pointer
!=	O
(	O
double	O
*	O
)	O
NULL	O
)	O
{	O
val	double
*=	O
MINS_PER_HOUR	int
;	O
*	O
min	int
=	O
(	O
int	O
)	O
val	double
;	O
val	double
-=	O
(	O
int	O
)	O
val	double
;	O
*	O
sec	pointer
=	O
val	double
*	O
SECS_PER_MIN	O
;	O
if	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
*	O
sec	pointer
)	O
>	O
SECS_PER_MIN	O
)	O
{	O
*	O
sec	pointer
=	O
0.0	int
;	O
(	O
*	O
min	int
)	O
++	O
;	O
if	O
(	O
*	O
min	int
>	O
MINS_PER_HOUR	int
)	O
{	O
*	O
min	int
=	O
0	int
;	O
(	O
*	O
hour	int
)	O
++	O
;	O
if	O
(	O
*	O
hour	int
>=	O
HOURS_PER_DAY	int
)	O
*	O
hour	int
=	O
0	int
;	O
}	O
}	O
}	O
else	O
{	O
*	O
min	int
=	O
(	O
int	O
)	O
ROUND	O
(	O
val	double
*	O
MINS_PER_HOUR	int
)	O
;	O
if	O
(	O
*	O
min	int
>=	O
MINS_PER_HOUR	int
)	O
{	O
if	O
(	O
(	O
*	O
hour	int
)	O
+	O
1	int
>=	O
HOURS_PER_DAY	int
)	O
*	O
min	int
=	O
MINS_PER_HOUR	int
-	O
1	int
;	O
else	O
{	O
(	O
*	O
hour	int
)	O
++	O
;	O
*	O
min	int
=	O
0	int
;	O
}	O
}	O
}	O
*	O
hour	int
*=	O
sign	int
;	O
*	O
min	int
*=	O
sign	int
;	O
if	O
(	O
sec	pointer
!=	O
(	O
double	O
*	O
)	O
NULL	O
)	O
*	O
sec	pointer
*=	O
sign	int
;	O
}	O
void	O
val2degrees	function
(	O
val	double
,	O
degree	pointer
,	O
min	int
,	O
sec	pointer
)	O
double	O
val	double
;	O
int	O
*	O
degree	pointer
;	O
int	O
*	O
min	int
;	O
double	O
*	O
sec	pointer
;	O
{	O
register	O
int	O
sign	int
=	O
SGN	O
(	O
val	double
)	O
;	O
val	double
=	O
abs	function
(	O
val	double
)	O
;	O
val	double
=	O
FIXANGLE	O
(	O
val	double
)	O
;	O
*	O
degree	pointer
=	O
(	O
int	O
)	O
val	double
;	O
val	double
-=	O
(	O
int	O
)	O
val	double
;	O
if	O
(	O
sec	pointer
!=	O
(	O
double	O
*	O
)	O
NULL	O
)	O
{	O
val	double
*=	O
MINS_PER_HOUR	int
;	O
*	O
min	int
=	O
(	O
int	O
)	O
val	double
;	O
val	double
-=	O
(	O
int	O
)	O
val	double
;	O
*	O
sec	pointer
=	O
val	double
*	O
SECS_PER_MIN	O
;	O
if	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
*	O
sec	pointer
)	O
>	O
SECS_PER_MIN	O
)	O
{	O
*	O
sec	pointer
=	O
0.0	int
;	O
(	O
*	O
min	int
)	O
++	O
;	O
if	O
(	O
*	O
min	int
>	O
MINS_PER_HOUR	int
)	O
{	O
*	O
min	int
=	O
0	int
;	O
(	O
*	O
degree	pointer
)	O
++	O
;	O
if	O
(	O
*	O
degree	pointer
>=	O
(	O
int	O
)	O
DEGS_PER_24_HOURS	int
)	O
*	O
degree	pointer
=	O
0	int
;	O
}	O
}	O
}	O
else	O
{	O
*	O
min	int
=	O
(	O
int	O
)	O
ROUND	O
(	O
val	double
*	O
MINS_PER_HOUR	int
)	O
;	O
if	O
(	O
*	O
min	int
>=	O
MINS_PER_HOUR	int
)	O
{	O
if	O
(	O
(	O
*	O
degree	pointer
)	O
+	O
1	int
>=	O
(	O
int	O
)	O
DEGS_PER_24_HOURS	int
)	O
*	O
min	int
=	O
MINS_PER_HOUR	int
-	O
1	int
;	O
else	O
{	O
(	O
*	O
degree	pointer
)	O
++	O
;	O
*	O
min	int
=	O
0	int
;	O
}	O
}	O
}	O
*	O
degree	pointer
*=	O
sign	int
;	O
*	O
min	int
*=	O
sign	int
;	O
if	O
(	O
sec	pointer
!=	O
(	O
double	O
*	O
)	O
NULL	O
)	O
*	O
sec	pointer
*=	O
sign	int
;	O
}	O
double	O
my_cot	function
(	O
x	double
)	O
double	O
x	double
;	O
{	O
x	double
=	O
tan	function
(	O
x	double
)	O
;	O
if	O
(	O
x	double
==	O
0.0	int
)	O
my_error	function
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"my_cot()="	pointer
,	O
0	int
)	O
;	O
return	O
(	O
1.0	int
/	O
x	double
)	O
;	O
}	O
double	O
my_acot	function
(	O
x	double
)	O
double	O
x	double
;	O
{	O
if	O
(	O
x	double
==	O
0.0	int
)	O
return	O
(	O
MY_HALF_PI	int
)	O
;	O
if	O
(	O
x	double
>	O
0.0	int
)	O
return	O
(	O
atan	function
(	O
1.0	int
/	O
x	double
)	O
)	O
;	O
return	O
(	O
atan	function
(	O
1.0	int
/	O
x	double
)	O
+	O
MY_PI	int
)	O
;	O
}	O
double	O
my_atan2	function
(	O
y	double
,	O
x	double
)	O
double	O
y	double
;	O
double	O
x	double
;	O
{	O
if	O
(	O
x	double
>	O
0.0	int
)	O
return	O
(	O
atan	function
(	O
y	double
/	O
x	double
)	O
)	O
;	O
else	O
if	O
(	O
x	double
<	O
0.0	int
)	O
return	O
(	O
atan	function
(	O
y	double
/	O
x	double
)	O
+	O
MY_PI	int
)	O
;	O
else	O
if	O
(	O
y	double
>	O
0.0	int
)	O
return	O
(	O
MY_HALF_PI	int
)	O
;	O
else	O
if	O
(	O
y	double
<	O
0.0	int
)	O
return	O
(	O
-	O
MY_HALF_PI	int
)	O
;	O
return	O
(	O
0.0	int
)	O
;	O
}	O
