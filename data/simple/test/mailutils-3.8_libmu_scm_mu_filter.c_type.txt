static	O
void	O
argv_free	function
(	O
void	O
*	O
p	pointer
)	O
{	O
mu_argv_free	function
(	O
(	O
char	O
*	O
*	O
)	O
p	pointer
)	O
;	O
}	O
static	O
SCM	function
make_filter_port	function
(	O
SCM	function
port	int
,	O
SCM	function
name	pointer
,	O
SCM	function
args	int
,	O
int	O
filter_mode	int
,	O
char	O
const	O
*	O
func_name	pointer
)	O
{	O
char	O
*	O
fltname	pointer
;	O
mu_stream_t	pointer
filter	pointer
;	O
mu_stream_t	pointer
instr	pointer
;	O
size_t	long
argc	int
=	O
0	int
;	O
char	O
*	O
*	O
argv	pointer
=	O
NULL	O
;	O
int	O
rc	int
;	O
int	O
flags	int
=	O
0	int
;	O
char	O
*	O
port_mode	pointer
;	O
SCM_ASSERT	function
(	O
scm_port_p	function
(	O
port	int
)	O
,	O
port	int
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
name	pointer
)	O
,	O
name	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_VALIDATE_REST_ARGUMENT	function
(	O
args	int
)	O
;	O
port_mode	pointer
=	O
scm_to_locale_string	function
(	O
scm_port_mode	function
(	O
port	int
)	O
)	O
;	O
if	O
(	O
strchr	function
(	O
port_mode	pointer
,	O
'r'	O
)	O
)	O
flags	int
|=	O
MU_STREAM_READ	int
;	O
if	O
(	O
strchr	function
(	O
port_mode	pointer
,	O
'w'	O
)	O
)	O
flags	int
|=	O
MU_STREAM_WRITE	int
;	O
free	function
(	O
port_mode	pointer
)	O
;	O
if	O
(	O
!	O
flags	int
||	O
(	O
(	O
flags	int
&	O
(	O
MU_STREAM_READ	int
|	O
MU_STREAM_WRITE	int
)	O
)	O
==	O
(	O
MU_STREAM_READ	int
|	O
MU_STREAM_WRITE	int
)	O
)	O
)	O
scm_out_of_range	function
(	O
FUNC_NAME	O
,	O
port	int
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
fltname	pointer
=	O
scm_to_locale_string	function
(	O
name	pointer
)	O
;	O
scm_dynwind_free	function
(	O
fltname	pointer
)	O
;	O
rc	int
=	O
mu_scm_port_stream_create	function
(	O
&	O
instr	pointer
,	O
port	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to convert transport port ~A"	pointer
,	O
scm_list_1	function
(	O
port	int
)	O
)	O
;	O
}	O
if	O
(	O
!	O
scm_is_null	function
(	O
args	int
)	O
)	O
{	O
size_t	long
n	int
;	O
argc	int
=	O
scm_to_size_t	function
(	O
scm_length	function
(	O
args	int
)	O
)	O
+	O
1	int
;	O
argv	pointer
=	O
calloc	function
(	O
argc	int
+	O
1	int
,	O
sizeof	O
(	O
argv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
argv	pointer
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
ENOMEM	int
,	O
"Cannot allocate memory"	pointer
,	O
SCM_BOOL_F	O
)	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
strdup	function
(	O
fltname	pointer
)	O
;	O
n	int
=	O
1	int
;	O
for	O
(	O
;	O
!	O
scm_is_null	function
(	O
args	int
)	O
;	O
args	int
=	O
SCM_CDR	function
(	O
args	int
)	O
)	O
{	O
SCM	function
arg	pointer
=	O
SCM_CAR	O
(	O
args	int
)	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
arg	pointer
)	O
,	O
arg	pointer
,	O
SCM_ARGn	O
,	O
FUNC_NAME	O
)	O
;	O
argv	pointer
[	O
n	int
]	O
=	O
scm_to_locale_string	function
(	O
arg	pointer
)	O
;	O
n	int
++	O
;	O
}	O
argv	pointer
[	O
n	int
]	O
=	O
NULL	O
;	O
scm_dynwind_unwind_handler	function
(	O
argv_free	function
,	O
argv	pointer
,	O
SCM_F_WIND_EXPLICITLY	O
)	O
;	O
}	O
rc	int
=	O
mu_filter_create_args	function
(	O
&	O
filter	pointer
,	O
instr	pointer
,	O
fltname	pointer
,	O
argc	int
,	O
(	O
const	O
char	O
*	O
*	O
)	O
argv	pointer
,	O
filter_mode	int
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Failed to create filter ~A"	pointer
,	O
scm_list_1	function
(	O
name	pointer
)	O
)	O
;	O
}	O
scm_dynwind_end	function
(	O
)	O
;	O
return	O
mu_port_make_from_stream	function
(	O
filter	pointer
,	O
flags	int
==	O
MU_STREAM_READ	int
?	O
SCM_RDNG	O
:	O
SCM_WRTNG	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_encoder_port	O
,	O
"mu-encoder-port"	pointer
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	O
SCM	function
port	int
,	O
SCM	function
name	pointer
,	O
SCM	function
args	int
)	O
,	O
"Create encoding port using Mailutils filter @var{name} with optional arguments\n"	pointer
"@var{args}. The @var{port} argument must be a port opened either for\n"	pointer
"writing or for reading, but not both. The returned port will have the same\n"	pointer
"mode as @var{port}."	pointer
"\n\n"	pointer
"If @var{port} is open for reading, data will be read from it, passed through the\n"	pointer
"filter and returned. If it is open for writing, data written to the returned\n"	pointer
"port will be passed through filter and its output will be written to @var{port}.\n"	pointer
)	O
{	O
return	O
make_filter_port	function
(	O
port	int
,	O
name	pointer
,	O
args	int
,	O
MU_FILTER_ENCODE	int
,	O
FUNC_NAME	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_decoder_port	O
,	O
"mu-decoder-port"	pointer
,	O
2	int
,	O
0	int
,	O
1	int
,	O
(	O
SCM	function
port	int
,	O
SCM	function
name	pointer
,	O
SCM	function
args	int
)	O
,	O
"Create a decoding port using Mailutils filter @var{name} with optional arguments\n"	pointer
"@var{args}. The @var{port} argument must be a port opened either for\n"	pointer
"writing or for reading, but not both. The returned port will have the same\n"	pointer
"mode as @var{port}."	pointer
"\n\n"	pointer
"If @var{port} is open for reading, data will be read from it, passed through the\n"	pointer
"filter and returned. If it is open for writing, data written to the returned\n"	pointer
"port will be passed through filter and its output will be written to @var{port}.\n"	pointer
)	O
{	O
return	O
make_filter_port	function
(	O
port	int
,	O
name	pointer
,	O
args	int
,	O
MU_FILTER_DECODE	int
,	O
FUNC_NAME	O
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_header_decode	O
,	O
"mu-header-decode"	pointer
,	O
1	int
,	O
1	int
,	O
0	int
,	O
(	O
SCM	function
hdr	pointer
,	O
SCM	function
charset	pointer
)	O
,	O
"Decode the header value @var{hdr}, encoded as per RFC 2047.\n"	pointer
"Optional @var{charset} defaults to @samp{utf-8}.\n"	pointer
)	O
{	O
char	O
*	O
c_hdr	pointer
,	O
*	O
c_charset	pointer
,	O
*	O
c_res	pointer
;	O
int	O
rc	int
;	O
SCM	function
res	pointer
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
hdr	pointer
)	O
,	O
hdr	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
if	O
(	O
SCM_UNBNDP	function
(	O
charset	pointer
)	O
)	O
c_charset	pointer
=	O
"utf-8"	pointer
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
charset	pointer
)	O
,	O
charset	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
c_charset	pointer
=	O
scm_to_locale_string	function
(	O
charset	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_charset	pointer
)	O
;	O
}	O
c_hdr	pointer
=	O
scm_to_locale_string	function
(	O
hdr	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_hdr	pointer
)	O
;	O
rc	int
=	O
mu_rfc2047_decode	function
(	O
c_charset	pointer
,	O
c_hdr	pointer
,	O
&	O
c_res	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't convert header value"	pointer
,	O
SCM_BOOL_F	O
)	O
;	O
scm_dynwind_end	function
(	O
)	O
;	O
res	pointer
=	O
scm_from_locale_string	function
(	O
c_res	pointer
)	O
;	O
free	function
(	O
c_res	pointer
)	O
;	O
return	O
res	pointer
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_mu_header_encode	O
,	O
"mu-header-encode"	pointer
,	O
1	int
,	O
2	int
,	O
0	int
,	O
(	O
SCM	function
hdr	pointer
,	O
SCM	function
encoding	pointer
,	O
SCM	function
charset	pointer
)	O
,	O
"Encode the string @var{hdr} as per RFC 2047.\n"	pointer
"Both @var{encoding} and @var{charset} are optional.\n"	pointer
"Allowed values for @var{encoding} are @samp{base64} and @samp{quoted-printable}.\n"	pointer
"Default is selected depending on number of printable characters in @var{hdr}.\n"	pointer
"Optional @var{charset} defaults to @samp{utf-8}.\n"	pointer
)	O
{	O
char	O
*	O
c_hdr	pointer
,	O
*	O
c_charset	pointer
,	O
*	O
c_encoding	pointer
,	O
*	O
c_res	pointer
;	O
int	O
rc	int
;	O
SCM	function
res	pointer
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
hdr	pointer
)	O
,	O
hdr	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
scm_dynwind_begin	function
(	O
0	int
)	O
;	O
if	O
(	O
SCM_UNBNDP	function
(	O
encoding	pointer
)	O
)	O
c_encoding	pointer
=	O
NULL	O
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
encoding	pointer
)	O
,	O
encoding	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
c_encoding	pointer
=	O
scm_to_locale_string	function
(	O
encoding	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_encoding	pointer
)	O
;	O
}	O
if	O
(	O
SCM_UNBNDP	function
(	O
charset	pointer
)	O
)	O
c_charset	pointer
=	O
"utf-8"	pointer
;	O
else	O
{	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
charset	pointer
)	O
,	O
charset	pointer
,	O
SCM_ARG3	O
,	O
FUNC_NAME	O
)	O
;	O
c_charset	pointer
=	O
scm_to_locale_string	function
(	O
charset	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_charset	pointer
)	O
;	O
}	O
c_hdr	pointer
=	O
scm_to_locale_string	function
(	O
hdr	pointer
)	O
;	O
scm_dynwind_free	function
(	O
c_hdr	pointer
)	O
;	O
if	O
(	O
!	O
c_encoding	pointer
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
c_hdr	pointer
)	O
;	O
size_t	long
i	long
,	O
enc	long
;	O
enc	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
len	long
;	O
i	long
++	O
)	O
if	O
(	O
!	O
mu_isprint	O
(	O
c_hdr	pointer
[	O
i	long
]	O
)	O
)	O
enc	long
++	O
;	O
c_encoding	pointer
=	O
(	O
enc	long
>	O
len	long
/	O
2	int
)	O
?	O
"base64"	pointer
:	O
"quoted-printable"	pointer
;	O
}	O
rc	int
=	O
mu_rfc2047_encode	function
(	O
c_charset	pointer
,	O
c_encoding	pointer
,	O
c_hdr	pointer
,	O
&	O
c_res	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_scm_error	function
(	O
FUNC_NAME	O
,	O
rc	int
,	O
"Can't encode header value"	pointer
,	O
SCM_BOOL_F	O
)	O
;	O
scm_dynwind_end	function
(	O
)	O
;	O
res	pointer
=	O
scm_from_locale_string	function
(	O
c_res	pointer
)	O
;	O
free	function
(	O
c_res	pointer
)	O
;	O
return	O
res	pointer
;	O
}	O
void	O
mu_scm_filter_init	function
(	O
void	O
)	O
{	O
}	O
