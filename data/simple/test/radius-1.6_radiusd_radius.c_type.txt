void	O
radius_send_reply	function
(	O
int	O
code	char
,	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
grad_avp_t	struct
*	O
reply_pairs	pointer
,	O
char	O
*	O
msg	pointer
,	O
int	O
fd	int
)	O
{	O
if	O
(	O
radreq	pointer
->	O
reply_code	int
==	O
0	int
)	O
{	O
grad_avp_t	struct
*	O
reply	pointer
;	O
radreq	pointer
->	O
reply_code	int
=	O
code	char
;	O
radreq	pointer
->	O
reply_msg	pointer
=	O
grad_estrdup	function
(	O
msg	pointer
)	O
;	O
reply	pointer
=	O
grad_avl_dup	function
(	O
reply_pairs	pointer
)	O
;	O
grad_avl_move_attr	function
(	O
&	O
reply	pointer
,	O
&	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_PROXY_STATE	int
)	O
;	O
switch	O
(	O
code	char
)	O
{	O
case	O
RT_PASSWORD_REJECT	int
:	O
case	O
RT_ACCESS_REJECT	int
:	O
radreq	pointer
->	O
reply_pairs	pointer
=	O
NULL	O
;	O
grad_avl_move_attr	function
(	O
&	O
radreq	pointer
->	O
reply_pairs	pointer
,	O
&	O
reply	pointer
,	O
DA_REPLY_MESSAGE	int
)	O
;	O
grad_avl_move_attr	function
(	O
&	O
radreq	pointer
->	O
reply_pairs	pointer
,	O
&	O
reply	pointer
,	O
DA_PROXY_STATE	int
)	O
;	O
grad_avl_free	function
(	O
reply	pointer
)	O
;	O
stat_inc	O
(	O
auth	O
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_rejects	O
)	O
;	O
break	O
;	O
case	O
RT_ACCESS_ACCEPT	int
:	O
stat_inc	O
(	O
auth	O
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_accepts	O
)	O
;	O
default	O
:	O
radreq	pointer
->	O
reply_pairs	pointer
=	O
grad_client_encrypt_pairlist	function
(	O
reply	pointer
,	O
radreq	pointer
->	O
request	pointer
->	O
authenticator	array
,	O
radreq	pointer
->	O
request	pointer
->	O
secret	pointer
)	O
;	O
}	O
}	O
grad_server_send_reply	function
(	O
fd	int
,	O
radreq	pointer
->	O
request	pointer
,	O
radreq	pointer
->	O
reply_code	int
,	O
radreq	pointer
->	O
reply_pairs	pointer
,	O
radreq	pointer
->	O
reply_msg	pointer
)	O
;	O
}	O
static	O
int	O
validate_client	function
(	O
grad_request_t	struct
*	O
radreq	pointer
)	O
{	O
CLIENT	struct
*	O
cl	pointer
;	O
if	O
(	O
(	O
cl	pointer
=	O
client_lookup_ip	function
(	O
radreq	pointer
->	O
ipaddr	int
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log_req	function
(	O
GRAD_LOG_ERR	int
,	O
radreq	pointer
,	O
_	O
(	O
"request from unknown client"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
radreq	pointer
->	O
secret	pointer
=	O
cl	pointer
->	O
secret	pointer
;	O
return	O
0	int
;	O
}	O
int	O
radius_verify_digest	function
(	O
REQUEST	struct
*	O
req	pointer
)	O
{	O
radiusd_request_t	struct
*	O
radreq	pointer
=	O
req	pointer
->	O
data	pointer
;	O
size_t	long
len	int
=	O
req	pointer
->	O
rawsize	long
;	O
int	O
secretlen	int
;	O
char	O
zero	int
[	O
GRAD_AUTHENTICATOR_LENGTH	int
]	O
;	O
u_char	char
*	O
recvbuf	pointer
;	O
u_char	char
digest	array
[	O
GRAD_AUTHENTICATOR_LENGTH	int
]	O
;	O
secretlen	int
=	O
strlen	function
(	O
radreq	pointer
->	O
request	pointer
->	O
secret	pointer
)	O
;	O
recvbuf	pointer
=	O
grad_emalloc	function
(	O
len	int
+	O
secretlen	int
)	O
;	O
memcpy	function
(	O
recvbuf	pointer
,	O
req	pointer
->	O
rawdata	pointer
,	O
len	int
)	O
;	O
memset	function
(	O
zero	int
,	O
0	int
,	O
sizeof	O
(	O
zero	int
)	O
)	O
;	O
if	O
(	O
memcmp	function
(	O
radreq	pointer
->	O
request	pointer
->	O
authenticator	array
,	O
zero	int
,	O
GRAD_AUTHENTICATOR_LENGTH	int
)	O
==	O
0	int
)	O
return	O
REQ_AUTH_ZERO	int
;	O
memset	function
(	O
recvbuf	pointer
+	O
4	int
,	O
0	int
,	O
GRAD_AUTHENTICATOR_LENGTH	int
)	O
;	O
memcpy	function
(	O
recvbuf	pointer
+	O
len	int
,	O
radreq	pointer
->	O
request	pointer
->	O
secret	pointer
,	O
secretlen	int
)	O
;	O
grad_md5_calc	function
(	O
digest	array
,	O
recvbuf	pointer
,	O
len	int
+	O
secretlen	int
)	O
;	O
grad_free	function
(	O
recvbuf	pointer
)	O
;	O
return	O
memcmp	function
(	O
digest	array
,	O
radreq	pointer
->	O
request	pointer
->	O
authenticator	array
,	O
GRAD_AUTHENTICATOR_LENGTH	int
)	O
?	O
REQ_AUTH_BAD	int
:	O
REQ_AUTH_OK	int
;	O
}	O
static	O
void	O
add_server_address	function
(	O
grad_request_t	struct
*	O
req	pointer
,	O
const	O
struct	O
sockaddr_in	struct
*	O
sa	pointer
)	O
{	O
grad_avl_add_pair	function
(	O
&	O
req	pointer
->	O
avlist	pointer
,	O
grad_avp_create_integer	function
(	O
DA_GNU_SERVER_ADDRESS	int
,	O
ntohl	function
(	O
sa	pointer
->	O
sin_addr	struct
.	O
s_addr	int
)	O
)	O
)	O
;	O
grad_avl_add_pair	function
(	O
&	O
req	pointer
->	O
avlist	pointer
,	O
grad_avp_create_integer	function
(	O
DA_GNU_SERVER_PORT	int
,	O
ntohs	function
(	O
sa	pointer
->	O
sin_port	short
)	O
)	O
)	O
;	O
}	O
int	O
radius_auth_req_decode	function
(	O
const	O
struct	O
sockaddr_in	struct
*	O
srv_sa	pointer
,	O
const	O
struct	O
sockaddr_in	struct
*	O
clt_sa	pointer
,	O
void	O
*	O
input	pointer
,	O
size_t	long
inputsize	long
,	O
void	O
*	O
*	O
output	pointer
)	O
{	O
grad_request_t	struct
*	O
greq	pointer
;	O
radiusd_request_t	struct
*	O
radreq	pointer
;	O
log_open	function
(	O
GRAD_LOG_AUTH	O
)	O
;	O
if	O
(	O
suspend_flag	int
)	O
{	O
stat_inc	O
(	O
auth	O
,	O
ntohl	function
(	O
clt_sa	pointer
->	O
sin_addr	struct
.	O
s_addr	int
)	O
,	O
num_dropped	O
)	O
;	O
return	O
1	int
;	O
}	O
greq	pointer
=	O
grad_decode_pdu	function
(	O
ntohl	function
(	O
clt_sa	pointer
->	O
sin_addr	struct
.	O
s_addr	int
)	O
,	O
ntohs	function
(	O
clt_sa	pointer
->	O
sin_port	short
)	O
,	O
input	pointer
,	O
inputsize	long
)	O
;	O
if	O
(	O
!	O
greq	pointer
)	O
return	O
1	int
;	O
if	O
(	O
validate_client	function
(	O
greq	pointer
)	O
)	O
{	O
stat_inc	O
(	O
auth	O
,	O
greq	pointer
->	O
ipaddr	int
,	O
num_dropped	O
)	O
;	O
grad_request_free	function
(	O
greq	pointer
)	O
;	O
return	O
1	int
;	O
}	O
radreq	pointer
=	O
radiusd_request_alloc	function
(	O
greq	pointer
)	O
;	O
add_server_address	function
(	O
radreq	pointer
->	O
request	pointer
,	O
srv_sa	pointer
)	O
;	O
if	O
(	O
grad_avl_find	function
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_CHAP_PASSWORD	int
)	O
&&	O
!	O
grad_avl_find	function
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_CHAP_CHALLENGE	int
)	O
)	O
{	O
grad_avp_t	struct
*	O
p	pointer
=	O
grad_avp_create_binary	function
(	O
DA_CHAP_CHALLENGE	int
,	O
GRAD_AUTHENTICATOR_LENGTH	int
,	O
radreq	pointer
->	O
request	pointer
->	O
authenticator	array
)	O
;	O
grad_avl_add_pair	function
(	O
&	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
p	pointer
)	O
;	O
}	O
*	O
output	pointer
=	O
radreq	pointer
;	O
return	O
0	int
;	O
}	O
int	O
radius_acct_req_decode	function
(	O
const	O
struct	O
sockaddr_in	struct
*	O
srv_sa	pointer
,	O
const	O
struct	O
sockaddr_in	struct
*	O
clt_sa	pointer
,	O
void	O
*	O
input	pointer
,	O
size_t	long
inputsize	long
,	O
void	O
*	O
*	O
output	pointer
)	O
{	O
grad_request_t	struct
*	O
greq	pointer
;	O
log_open	function
(	O
GRAD_LOG_ACCT	O
)	O
;	O
if	O
(	O
suspend_flag	int
)	O
{	O
stat_inc	O
(	O
acct	function
,	O
ntohl	function
(	O
clt_sa	pointer
->	O
sin_addr	struct
.	O
s_addr	int
)	O
,	O
num_dropped	O
)	O
;	O
return	O
1	int
;	O
}	O
greq	pointer
=	O
grad_decode_pdu	function
(	O
ntohl	function
(	O
clt_sa	pointer
->	O
sin_addr	struct
.	O
s_addr	int
)	O
,	O
ntohs	function
(	O
clt_sa	pointer
->	O
sin_port	short
)	O
,	O
input	pointer
,	O
inputsize	long
)	O
;	O
if	O
(	O
!	O
greq	pointer
)	O
return	O
1	int
;	O
if	O
(	O
validate_client	function
(	O
greq	pointer
)	O
)	O
{	O
stat_inc	O
(	O
acct	function
,	O
greq	pointer
->	O
ipaddr	int
,	O
num_dropped	O
)	O
;	O
grad_request_free	function
(	O
greq	pointer
)	O
;	O
return	O
1	int
;	O
}	O
add_server_address	function
(	O
greq	pointer
,	O
srv_sa	pointer
)	O
;	O
*	O
output	pointer
=	O
radiusd_request_alloc	function
(	O
greq	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
decrypt_pair	function
(	O
grad_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
pair	pointer
)	O
{	O
if	O
(	O
pair	pointer
->	O
prop	int
&	O
GRAD_AP_ENCRYPT	O
)	O
{	O
char	O
password	pointer
[	O
GRAD_STRING_LENGTH	int
+	O
1	int
]	O
;	O
req_decrypt_password	function
(	O
password	pointer
,	O
req	pointer
,	O
pair	pointer
)	O
;	O
grad_free	function
(	O
pair	pointer
->	O
avp_strvalue	O
)	O
;	O
pair	pointer
->	O
avp_strvalue	O
=	O
grad_estrdup	function
(	O
password	pointer
)	O
;	O
pair	pointer
->	O
avp_strlength	O
=	O
strlen	function
(	O
pair	pointer
->	O
avp_strvalue	O
)	O
;	O
}	O
}	O
grad_avp_t	struct
*	O
radius_decrypt_request_pairs	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
plist	pointer
)	O
{	O
grad_avp_t	struct
*	O
pair	pointer
;	O
for	O
(	O
pair	pointer
=	O
plist	pointer
;	O
pair	pointer
;	O
pair	pointer
=	O
pair	pointer
->	O
next	pointer
)	O
decrypt_pair	function
(	O
req	pointer
->	O
request	pointer
,	O
pair	pointer
)	O
;	O
return	O
plist	pointer
;	O
}	O
void	O
radius_destroy_pairs	function
(	O
grad_avp_t	struct
*	O
*	O
p	pointer
)	O
{	O
grad_avp_t	struct
*	O
pair	pointer
;	O
if	O
(	O
!	O
p	pointer
||	O
!	O
*	O
p	pointer
)	O
return	O
;	O
for	O
(	O
pair	pointer
=	O
*	O
p	pointer
;	O
pair	pointer
;	O
pair	pointer
=	O
pair	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
pair	pointer
->	O
prop	int
&	O
GRAD_AP_ENCRYPT	O
)	O
memset	function
(	O
pair	pointer
->	O
avp_strvalue	O
,	O
0	int
,	O
pair	pointer
->	O
avp_strlength	O
)	O
;	O
}	O
grad_avl_free	function
(	O
*	O
p	pointer
)	O
;	O
*	O
p	pointer
=	O
NULL	O
;	O
}	O
static	O
grad_avp_t	struct
*	O
_extract_pairs	function
(	O
grad_request_t	struct
*	O
req	pointer
,	O
int	O
prop	int
)	O
{	O
int	O
i	int
;	O
grad_avp_t	struct
*	O
newlist	pointer
=	O
NULL	O
;	O
grad_avp_t	struct
*	O
pair	pointer
;	O
char	O
password	pointer
[	O
GRAD_STRING_LENGTH	int
+	O
1	int
]	O
;	O
int	O
found	int
=	O
0	int
;	O
for	O
(	O
pair	pointer
=	O
req	pointer
->	O
avlist	pointer
;	O
!	O
found	int
&&	O
pair	pointer
;	O
pair	pointer
=	O
pair	pointer
->	O
next	pointer
)	O
if	O
(	O
pair	pointer
->	O
prop	int
&	O
(	O
prop	int
|	O
GRAD_AP_ENCRYPT	O
)	O
)	O
{	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
found	int
)	O
return	O
NULL	O
;	O
newlist	pointer
=	O
grad_avl_dup	function
(	O
req	pointer
->	O
avlist	pointer
)	O
;	O
for	O
(	O
pair	pointer
=	O
newlist	pointer
;	O
pair	pointer
;	O
pair	pointer
=	O
pair	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
pair	pointer
->	O
prop	int
&	O
prop	int
)	O
decrypt_pair	function
(	O
req	pointer
,	O
pair	pointer
)	O
;	O
}	O
return	O
newlist	pointer
;	O
}	O
static	O
int	O
find_prop	function
(	O
grad_nas_t	struct
*	O
nas	int
,	O
char	O
*	O
name	pointer
,	O
int	O
defval	pointer
)	O
{	O
if	O
(	O
!	O
nas	int
)	O
return	O
defval	pointer
;	O
return	O
grad_envar_lookup_int	function
(	O
nas	int
->	O
args	pointer
,	O
name	pointer
,	O
defval	pointer
)	O
;	O
}	O
int	O
radius_req_cmp	function
(	O
void	O
*	O
adata	pointer
,	O
void	O
*	O
bdata	pointer
)	O
{	O
grad_request_t	struct
*	O
a	pointer
=	O
(	O
(	O
radiusd_request_t	struct
*	O
)	O
adata	pointer
)	O
->	O
request	pointer
;	O
grad_request_t	struct
*	O
b	pointer
=	O
(	O
(	O
radiusd_request_t	struct
*	O
)	O
bdata	pointer
)	O
->	O
request	pointer
;	O
int	O
prop	int
=	O
0	int
;	O
grad_avp_t	struct
*	O
alist	pointer
=	O
NULL	O
,	O
*	O
blist	pointer
=	O
NULL	O
,	O
*	O
ap	array
,	O
*	O
bp	pointer
;	O
int	O
rc	int
;	O
grad_nas_t	struct
*	O
nas	int
;	O
if	O
(	O
proxy_cmp	function
(	O
(	O
radiusd_request_t	struct
*	O
)	O
adata	pointer
,	O
(	O
radiusd_request_t	struct
*	O
)	O
bdata	pointer
)	O
==	O
0	int
)	O
return	O
RCMP_PROXY	int
;	O
if	O
(	O
a	pointer
->	O
ipaddr	int
!=	O
b	pointer
->	O
ipaddr	int
||	O
a	pointer
->	O
code	char
!=	O
b	pointer
->	O
code	char
)	O
return	O
RCMP_NE	int
;	O
if	O
(	O
a	pointer
->	O
id	char
==	O
b	pointer
->	O
id	char
&&	O
memcmp	function
(	O
a	pointer
->	O
authenticator	array
,	O
b	pointer
->	O
authenticator	array
,	O
sizeof	O
(	O
a	pointer
->	O
authenticator	array
)	O
)	O
==	O
0	int
)	O
return	O
RCMP_EQ	int
;	O
nas	int
=	O
grad_nas_request_to_nas	function
(	O
a	pointer
)	O
;	O
switch	O
(	O
a	pointer
->	O
code	char
)	O
{	O
case	O
RT_ACCESS_REQUEST	int
:	O
case	O
RT_ACCESS_ACCEPT	int
:	O
case	O
RT_ACCESS_REJECT	int
:	O
case	O
RT_ACCESS_CHALLENGE	int
:	O
prop	int
=	O
find_prop	function
(	O
nas	int
,	O
"compare-auth-flag"	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
prop	int
)	O
prop	int
=	O
find_prop	function
(	O
nas	int
,	O
"compare-attribute-flag"	pointer
,	O
auth_comp_flag	int
)	O
;	O
break	O
;	O
case	O
RT_ACCOUNTING_REQUEST	int
:	O
case	O
RT_ACCOUNTING_RESPONSE	int
:	O
case	O
RT_ACCOUNTING_STATUS	int
:	O
case	O
RT_ACCOUNTING_MESSAGE	int
:	O
prop	int
=	O
find_prop	function
(	O
nas	int
,	O
"compare-acct-flag"	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
prop	int
)	O
prop	int
=	O
find_prop	function
(	O
nas	int
,	O
"compare-attribute-flag"	pointer
,	O
acct_comp_flag	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
prop	int
==	O
0	int
)	O
return	O
RCMP_NE	int
;	O
prop	int
=	O
GRAD_AP_USER_FLAG	O
(	O
prop	int
)	O
;	O
alist	pointer
=	O
_extract_pairs	function
(	O
a	pointer
,	O
prop	int
)	O
;	O
blist	pointer
=	O
_extract_pairs	function
(	O
b	pointer
,	O
prop	int
)	O
;	O
ap	array
=	O
alist	pointer
?	O
alist	pointer
:	O
a	pointer
->	O
avlist	pointer
;	O
bp	pointer
=	O
blist	pointer
?	O
blist	pointer
:	O
b	pointer
->	O
avlist	pointer
;	O
rc	int
=	O
grad_avl_cmp	function
(	O
ap	array
,	O
bp	pointer
,	O
prop	int
)	O
||	O
grad_avl_cmp	function
(	O
bp	pointer
,	O
ap	array
,	O
prop	int
)	O
;	O
radius_destroy_pairs	function
(	O
&	O
alist	pointer
)	O
;	O
radius_destroy_pairs	function
(	O
&	O
blist	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
memcpy	function
(	O
a	pointer
->	O
authenticator	array
,	O
b	pointer
->	O
authenticator	array
,	O
sizeof	O
(	O
a	pointer
->	O
authenticator	array
)	O
)	O
;	O
grad_avl_free	function
(	O
a	pointer
->	O
avlist	pointer
)	O
;	O
a	pointer
->	O
avlist	pointer
=	O
grad_avl_dup	function
(	O
b	pointer
->	O
avlist	pointer
)	O
;	O
a	pointer
->	O
id	char
=	O
b	pointer
->	O
id	char
;	O
}	O
return	O
rc	int
==	O
0	int
?	O
RCMP_EQ	int
:	O
RCMP_NE	int
;	O
}	O
void	O
radius_req_update	function
(	O
void	O
*	O
req_ptr	pointer
,	O
void	O
*	O
data_ptr	pointer
)	O
{	O
radiusd_request_t	struct
*	O
req	pointer
=	O
req_ptr	pointer
;	O
RADIUS_UPDATE	struct
*	O
upd	pointer
=	O
data_ptr	pointer
;	O
if	O
(	O
req	pointer
->	O
request	pointer
->	O
id	char
!=	O
upd	pointer
->	O
id	char
)	O
return	O
;	O
req	pointer
->	O
server_id	int
=	O
upd	pointer
->	O
proxy_id	int
;	O
req	pointer
->	O
realm	array
=	O
grad_realm_lookup_name	function
(	O
upd	pointer
->	O
realmname	array
)	O
;	O
req	pointer
->	O
server_no	int
=	O
upd	pointer
->	O
server_no	int
;	O
GRAD_DEBUG4	O
(	O
1	int
,	O
"Update request %d: proxy_id=%d, realm=%s, server_no=%d"	pointer
,	O
req	pointer
->	O
request	pointer
->	O
id	char
,	O
upd	pointer
->	O
proxy_id	int
,	O
upd	pointer
->	O
realmname	array
,	O
upd	pointer
->	O
server_no	int
)	O
;	O
}	O
void	O
radius_req_free	function
(	O
void	O
*	O
req	pointer
)	O
{	O
radiusd_request_free	function
(	O
(	O
radiusd_request_t	struct
*	O
)	O
req	pointer
)	O
;	O
}	O
void	O
radius_req_drop	function
(	O
int	O
type	int
,	O
void	O
*	O
data	pointer
,	O
void	O
*	O
orig_data	pointer
,	O
int	O
fd	int
,	O
const	O
char	O
*	O
status_str	pointer
)	O
{	O
radiusd_request_t	struct
*	O
radreq	pointer
=	O
data	pointer
?	O
data	pointer
:	O
orig_data	pointer
;	O
grad_log_req	function
(	O
GRAD_LOG_NOTICE	int
,	O
radreq	pointer
->	O
request	pointer
,	O
"%s: %s"	pointer
,	O
_	O
(	O
"Dropping packet"	pointer
)	O
,	O
status_str	pointer
)	O
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
R_AUTH	int
:	O
stat_inc	O
(	O
auth	O
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_dropped	O
)	O
;	O
break	O
;	O
case	O
R_ACCT	int
:	O
stat_inc	O
(	O
acct	function
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_dropped	O
)	O
;	O
}	O
}	O
void	O
radius_req_xmit	function
(	O
REQUEST	struct
*	O
request	pointer
)	O
{	O
radiusd_request_t	struct
*	O
req	pointer
=	O
request	pointer
->	O
data	pointer
;	O
if	O
(	O
request	pointer
->	O
code	char
==	O
0	int
)	O
{	O
if	O
(	O
req	pointer
->	O
reply_code	int
==	O
0	int
&&	O
req	pointer
->	O
realm	array
)	O
{	O
proxy_retry	function
(	O
req	pointer
,	O
request	pointer
->	O
fd	int
)	O
;	O
}	O
else	O
{	O
radius_send_reply	function
(	O
0	int
,	O
req	pointer
,	O
NULL	O
,	O
NULL	O
,	O
request	pointer
->	O
fd	int
)	O
;	O
grad_log_req	function
(	O
GRAD_LOG_NOTICE	int
,	O
req	pointer
->	O
request	pointer
,	O
_	O
(	O
"Retransmitting %s reply"	pointer
)	O
,	O
request_class	struct
[	O
request	pointer
->	O
type	int
]	O
.	O
name	pointer
)	O
;	O
}	O
}	O
else	O
radius_req_drop	function
(	O
request	pointer
->	O
type	int
,	O
NULL	O
,	O
req	pointer
,	O
request	pointer
->	O
fd	int
,	O
_	O
(	O
"request failed"	pointer
)	O
)	O
;	O
}	O
int	O
radius_req_failure	function
(	O
int	O
type	int
,	O
struct	O
sockaddr_in	struct
*	O
addr	int
)	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
R_AUTH	int
:	O
stat_inc	O
(	O
auth	O
,	O
ntohl	function
(	O
addr	int
->	O
sin_addr	struct
.	O
s_addr	int
)	O
,	O
num_bad_req	O
)	O
;	O
break	O
;	O
case	O
R_ACCT	int
:	O
stat_inc	O
(	O
acct	function
,	O
ntohl	function
(	O
addr	int
->	O
sin_addr	struct
.	O
s_addr	int
)	O
,	O
num_bad_req	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
radius_status_server	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
int	O
fd	int
)	O
{	O
radius_send_reply	function
(	O
RT_ACCESS_ACCEPT	int
,	O
radreq	pointer
,	O
NULL	O
,	O
"GNU Radius server fully operational"	pointer
,	O
fd	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
radius_respond	function
(	O
REQUEST	struct
*	O
req	pointer
)	O
{	O
int	O
rc	int
;	O
radiusd_request_t	struct
*	O
radreq	pointer
=	O
req	pointer
->	O
data	pointer
;	O
forward_request	function
(	O
req	pointer
->	O
type	int
,	O
radreq	pointer
)	O
;	O
radiusd_sql_clear_cache	O
(	O
)	O
;	O
hints_setup	function
(	O
radreq	pointer
)	O
;	O
if	O
(	O
radreq	pointer
->	O
request	pointer
->	O
code	char
==	O
RT_ACCESS_REQUEST	int
&&	O
rad_auth_check_username	function
(	O
radreq	pointer
,	O
req	pointer
->	O
fd	int
)	O
)	O
return	O
1	int
;	O
switch	O
(	O
radreq	pointer
->	O
request	pointer
->	O
code	char
)	O
{	O
case	O
RT_ACCESS_REQUEST	int
:	O
stat_inc	O
(	O
auth	O
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_access_req	O
)	O
;	O
if	O
(	O
rad_auth_init	function
(	O
radreq	pointer
,	O
req	pointer
->	O
fd	int
)	O
<	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
proxy_send	function
(	O
req	pointer
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
break	O
;	O
case	O
RT_ACCOUNTING_REQUEST	int
:	O
stat_inc	O
(	O
acct	function
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_req	O
)	O
;	O
if	O
(	O
proxy_send	function
(	O
req	pointer
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
break	O
;	O
case	O
RT_ACCESS_ACCEPT	int
:	O
case	O
RT_ACCESS_REJECT	int
:	O
case	O
RT_ACCOUNTING_RESPONSE	int
:	O
case	O
RT_ACCESS_CHALLENGE	int
:	O
if	O
(	O
!	O
req	pointer
->	O
orig	pointer
)	O
{	O
char	O
buf	pointer
[	O
GRAD_MAX_SHORTNAME	int
]	O
;	O
grad_log_req	function
(	O
GRAD_LOG_PROXY	O
|	O
GRAD_LOG_ERR	int
,	O
radreq	pointer
->	O
request	pointer
,	O
_	O
(	O
"Unrecognized proxy reply from server %s, proxy ID %d"	pointer
)	O
,	O
client_lookup_name	function
(	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
)	O
,	O
radreq	pointer
->	O
request	pointer
->	O
id	char
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
proxy_receive	function
(	O
radreq	pointer
,	O
req	pointer
->	O
orig	pointer
->	O
data	pointer
,	O
req	pointer
->	O
fd	int
)	O
<	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
break	O
;	O
}	O
switch	O
(	O
radreq	pointer
->	O
request	pointer
->	O
code	char
)	O
{	O
case	O
RT_ACCESS_REQUEST	int
:	O
rad_authenticate	function
(	O
radreq	pointer
,	O
req	pointer
->	O
fd	int
)	O
;	O
break	O
;	O
case	O
RT_ACCOUNTING_REQUEST	int
:	O
rc	int
=	O
radius_verify_digest	function
(	O
req	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
REQ_AUTH_BAD	int
)	O
stat_inc	O
(	O
acct	function
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_bad_sign	O
)	O
;	O
rad_accounting	function
(	O
radreq	pointer
,	O
req	pointer
->	O
fd	int
,	O
rc	int
)	O
;	O
break	O
;	O
case	O
RT_STATUS_SERVER	int
:	O
radius_status_server	function
(	O
radreq	pointer
,	O
req	pointer
->	O
fd	int
)	O
;	O
break	O
;	O
default	O
:	O
stat_inc	O
(	O
acct	function
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_unknowntypes	O
)	O
;	O
grad_log_req	function
(	O
GRAD_LOG_NOTICE	int
,	O
radreq	pointer
->	O
request	pointer
,	O
_	O
(	O
"unknown request code %d"	pointer
)	O
,	O
radreq	pointer
->	O
request	pointer
->	O
code	char
)	O
;	O
return	O
-	O
1	int
;	O
}	O
radius_trace_path	function
(	O
radreq	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
radius_req_register_locus	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
switch	O
(	O
req	pointer
->	O
request	pointer
->	O
code	char
)	O
{	O
case	O
RT_ACCESS_REQUEST	int
:	O
case	O
RT_ACCESS_ACCEPT	int
:	O
case	O
RT_ACCESS_REJECT	int
:	O
case	O
RT_ACCESS_CHALLENGE	int
:	O
if	O
(	O
!	O
auth_trace_rules	int
)	O
return	O
;	O
break	O
;	O
case	O
RT_ACCOUNTING_REQUEST	int
:	O
case	O
RT_ACCOUNTING_RESPONSE	int
:	O
case	O
RT_ACCOUNTING_STATUS	int
:	O
case	O
RT_ACCOUNTING_MESSAGE	int
:	O
if	O
(	O
!	O
acct_trace_rules	int
)	O
return	O
;	O
break	O
;	O
default	O
:	O
return	O
;	O
}	O
if	O
(	O
!	O
req	pointer
->	O
locus_list	pointer
)	O
req	pointer
->	O
locus_list	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_list_prepend	function
(	O
req	pointer
->	O
locus_list	pointer
,	O
loc	struct
)	O
;	O
}	O
struct	O
trace_data	struct
{	O
struct	O
obstack	struct
stk	struct
;	O
char	O
*	O
file	pointer
;	O
}	O
;	O
static	O
char	O
*	O
skip_common_substring	function
(	O
char	O
*	O
str	pointer
,	O
char	O
*	O
pat	pointer
)	O
{	O
char	O
*	O
start	pointer
=	O
str	pointer
;	O
while	O
(	O
*	O
str	pointer
==	O
*	O
pat	pointer
++	O
)	O
if	O
(	O
*	O
str	pointer
++	O
==	O
'/'	O
)	O
start	pointer
=	O
str	pointer
;	O
return	O
start	pointer
;	O
}	O
static	O
int	O
_trace_path_compose	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
grad_locus_t	struct
*	O
loc	struct
=	O
item	pointer
;	O
struct	O
trace_data	struct
*	O
td	pointer
=	O
data	pointer
;	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
if	O
(	O
!	O
td	pointer
->	O
file	pointer
)	O
{	O
td	pointer
->	O
file	pointer
=	O
loc	struct
->	O
file	pointer
;	O
obstack_grow	O
(	O
&	O
td	pointer
->	O
stk	struct
,	O
loc	struct
->	O
file	pointer
,	O
strlen	function
(	O
loc	struct
->	O
file	pointer
)	O
)	O
;	O
obstack_1grow	O
(	O
&	O
td	pointer
->	O
stk	struct
,	O
':'	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
td	pointer
->	O
file	pointer
,	O
loc	struct
->	O
file	pointer
)	O
==	O
0	int
)	O
{	O
obstack_1grow	O
(	O
&	O
td	pointer
->	O
stk	struct
,	O
','	O
)	O
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
;	O
obstack_1grow	O
(	O
&	O
td	pointer
->	O
stk	struct
,	O
';'	O
)	O
;	O
obstack_1grow	O
(	O
&	O
td	pointer
->	O
stk	struct
,	O
' '	O
)	O
;	O
p	pointer
=	O
skip_common_substring	function
(	O
loc	struct
->	O
file	pointer
,	O
td	pointer
->	O
file	pointer
)	O
;	O
obstack_grow	O
(	O
&	O
td	pointer
->	O
stk	struct
,	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
)	O
;	O
obstack_1grow	O
(	O
&	O
td	pointer
->	O
stk	struct
,	O
':'	O
)	O
;	O
td	pointer
->	O
file	pointer
=	O
loc	struct
->	O
file	pointer
;	O
}	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
buf	pointer
,	O
"%lu"	pointer
,	O
(	O
unsigned	O
long	O
)	O
loc	struct
->	O
line	long
)	O
;	O
obstack_grow	O
(	O
&	O
td	pointer
->	O
stk	struct
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
radius_trace_path	function
(	O
radiusd_request_t	struct
*	O
req	pointer
)	O
{	O
struct	O
trace_data	struct
td	pointer
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
!	O
req	pointer
->	O
locus_list	pointer
)	O
return	O
;	O
obstack_init	O
(	O
&	O
td	pointer
.	O
stk	struct
)	O
;	O
td	pointer
.	O
file	pointer
=	O
NULL	O
;	O
grad_list_iterate	function
(	O
req	pointer
->	O
locus_list	pointer
,	O
_trace_path_compose	function
,	O
&	O
td	pointer
)	O
;	O
p	pointer
=	O
obstack_finish	O
(	O
&	O
td	pointer
.	O
stk	struct
)	O
;	O
grad_log_req	function
(	O
GRAD_LOG_INFO	int
,	O
req	pointer
->	O
request	pointer
,	O
_	O
(	O
"rule trace: %s"	pointer
)	O
,	O
p	pointer
)	O
;	O
obstack_free	function
(	O
&	O
td	pointer
.	O
stk	struct
,	O
NULL	O
)	O
;	O
}	O
