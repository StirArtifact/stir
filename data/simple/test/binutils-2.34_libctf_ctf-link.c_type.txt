void	O
ctf_add_type_mapping	function
(	O
ctf_file_t	struct
*	O
src_fp	pointer
,	O
ctf_id_t	long
src_type	long
,	O
ctf_file_t	struct
*	O
dst_fp	pointer
,	O
ctf_id_t	long
dst_type	long
)	O
{	O
if	O
(	O
LCTF_TYPE_ISPARENT	O
(	O
src_fp	pointer
,	O
src_type	long
)	O
&&	O
src_fp	pointer
->	O
ctf_parent	pointer
)	O
src_fp	pointer
=	O
src_fp	pointer
->	O
ctf_parent	pointer
;	O
src_type	long
=	O
LCTF_TYPE_TO_INDEX	O
(	O
src_fp	pointer
,	O
src_type	long
)	O
;	O
if	O
(	O
LCTF_TYPE_ISPARENT	O
(	O
dst_fp	pointer
,	O
dst_type	long
)	O
&&	O
dst_fp	pointer
->	O
ctf_parent	pointer
)	O
dst_fp	pointer
=	O
dst_fp	pointer
->	O
ctf_parent	pointer
;	O
dst_type	long
=	O
LCTF_TYPE_TO_INDEX	O
(	O
dst_fp	pointer
,	O
dst_type	long
)	O
;	O
if	O
(	O
dst_fp	pointer
->	O
ctf_link_type_mapping	pointer
==	O
NULL	O
)	O
{	O
ctf_hash_fun	pointer
f	pointer
=	O
ctf_hash_type_mapping_key	function
;	O
ctf_hash_eq_fun	pointer
e	pointer
=	O
ctf_hash_eq_type_mapping_key	function
;	O
if	O
(	O
(	O
dst_fp	pointer
->	O
ctf_link_type_mapping	pointer
=	O
ctf_dynhash_create	function
(	O
f	pointer
,	O
e	pointer
,	O
free	function
,	O
NULL	O
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
}	O
ctf_link_type_mapping_key_t	struct
*	O
key	pointer
;	O
key	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
ctf_link_type_mapping_key	struct
)	O
)	O
;	O
if	O
(	O
!	O
key	pointer
)	O
return	O
;	O
key	pointer
->	O
cltm_fp	pointer
=	O
src_fp	pointer
;	O
key	pointer
->	O
cltm_idx	long
=	O
src_type	long
;	O
ctf_dynhash_insert	function
(	O
dst_fp	pointer
->	O
ctf_link_type_mapping	pointer
,	O
key	pointer
,	O
(	O
void	O
*	O
)	O
(	O
uintptr_t	long
)	O
dst_type	long
)	O
;	O
}	O
ctf_id_t	long
ctf_type_mapping	function
(	O
ctf_file_t	struct
*	O
src_fp	pointer
,	O
ctf_id_t	long
src_type	long
,	O
ctf_file_t	struct
*	O
*	O
dst_fp	pointer
)	O
{	O
ctf_link_type_mapping_key_t	struct
key	pointer
;	O
ctf_file_t	struct
*	O
target_fp	pointer
=	O
*	O
dst_fp	pointer
;	O
ctf_id_t	long
dst_type	long
=	O
0	int
;	O
if	O
(	O
LCTF_TYPE_ISPARENT	O
(	O
src_fp	pointer
,	O
src_type	long
)	O
&&	O
src_fp	pointer
->	O
ctf_parent	pointer
)	O
src_fp	pointer
=	O
src_fp	pointer
->	O
ctf_parent	pointer
;	O
src_type	long
=	O
LCTF_TYPE_TO_INDEX	O
(	O
src_fp	pointer
,	O
src_type	long
)	O
;	O
key	pointer
.	O
cltm_fp	pointer
=	O
src_fp	pointer
;	O
key	pointer
.	O
cltm_idx	long
=	O
src_type	long
;	O
if	O
(	O
target_fp	pointer
->	O
ctf_link_type_mapping	pointer
)	O
dst_type	long
=	O
(	O
uintptr_t	long
)	O
ctf_dynhash_lookup	function
(	O
target_fp	pointer
->	O
ctf_link_type_mapping	pointer
,	O
&	O
key	pointer
)	O
;	O
if	O
(	O
dst_type	long
!=	O
0	int
)	O
{	O
dst_type	long
=	O
LCTF_INDEX_TO_TYPE	O
(	O
target_fp	pointer
,	O
dst_type	long
,	O
target_fp	pointer
->	O
ctf_parent	pointer
!=	O
NULL	O
)	O
;	O
*	O
dst_fp	pointer
=	O
target_fp	pointer
;	O
return	O
dst_type	long
;	O
}	O
if	O
(	O
target_fp	pointer
->	O
ctf_parent	pointer
)	O
target_fp	pointer
=	O
target_fp	pointer
->	O
ctf_parent	pointer
;	O
else	O
return	O
0	int
;	O
if	O
(	O
target_fp	pointer
->	O
ctf_link_type_mapping	pointer
)	O
dst_type	long
=	O
(	O
uintptr_t	long
)	O
ctf_dynhash_lookup	function
(	O
target_fp	pointer
->	O
ctf_link_type_mapping	pointer
,	O
&	O
key	pointer
)	O
;	O
if	O
(	O
dst_type	long
)	O
dst_type	long
=	O
LCTF_INDEX_TO_TYPE	O
(	O
target_fp	pointer
,	O
dst_type	long
,	O
target_fp	pointer
->	O
ctf_parent	pointer
!=	O
NULL	O
)	O
;	O
*	O
dst_fp	pointer
=	O
target_fp	pointer
;	O
return	O
dst_type	long
;	O
}	O
static	O
void	O
ctf_arc_close_thunk	function
(	O
void	O
*	O
arc	pointer
)	O
{	O
ctf_arc_close	function
(	O
(	O
ctf_archive_t	struct
*	O
)	O
arc	pointer
)	O
;	O
}	O
static	O
void	O
ctf_file_close_thunk	function
(	O
void	O
*	O
file	pointer
)	O
{	O
ctf_file_close	function
(	O
(	O
ctf_file_t	struct
*	O
)	O
file	pointer
)	O
;	O
}	O
int	O
ctf_link_add_ctf	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_archive_t	struct
*	O
ctf	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
char	O
*	O
dupname	pointer
=	O
NULL	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_LINKADDEDLATE	int
)	O
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_inputs	pointer
==	O
NULL	O
)	O
fp	pointer
->	O
ctf_link_inputs	pointer
=	O
ctf_dynhash_create	function
(	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
,	O
free	function
,	O
ctf_arc_close_thunk	function
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_inputs	pointer
==	O
NULL	O
)	O
goto	O
oom	O
;	O
if	O
(	O
(	O
dupname	pointer
=	O
strdup	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
goto	O
oom	O
;	O
if	O
(	O
ctf_dynhash_insert	function
(	O
fp	pointer
->	O
ctf_link_inputs	pointer
,	O
dupname	pointer
,	O
ctf	pointer
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
return	O
0	int
;	O
oom	O
:	O
free	function
(	O
fp	pointer
->	O
ctf_link_inputs	pointer
)	O
;	O
fp	pointer
->	O
ctf_link_inputs	pointer
=	O
NULL	O
;	O
free	function
(	O
dupname	pointer
)	O
;	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
)	O
;	O
}	O
static	O
ctf_file_t	struct
*	O
ctf_create_per_cu	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
cuname	pointer
)	O
{	O
ctf_file_t	struct
*	O
cu_fp	pointer
;	O
const	O
char	O
*	O
ctf_name	pointer
=	O
NULL	O
;	O
char	O
*	O
dynname	pointer
=	O
NULL	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_cu_mapping	pointer
)	O
{	O
if	O
(	O
(	O
(	O
ctf_name	pointer
=	O
ctf_dynhash_lookup	function
(	O
fp	pointer
->	O
ctf_link_cu_mapping	pointer
,	O
filename	pointer
)	O
)	O
==	O
NULL	O
)	O
&&	O
(	O
(	O
ctf_name	pointer
=	O
ctf_dynhash_lookup	function
(	O
fp	pointer
->	O
ctf_link_cu_mapping	pointer
,	O
cuname	pointer
)	O
)	O
==	O
NULL	O
)	O
)	O
ctf_name	pointer
=	O
filename	pointer
;	O
}	O
if	O
(	O
ctf_name	pointer
==	O
NULL	O
)	O
ctf_name	pointer
=	O
filename	pointer
;	O
if	O
(	O
(	O
cu_fp	pointer
=	O
ctf_dynhash_lookup	function
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
,	O
ctf_name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
int	O
err	long
;	O
if	O
(	O
(	O
cu_fp	pointer
=	O
ctf_create	function
(	O
&	O
err	long
)	O
)	O
==	O
NULL	O
)	O
{	O
ctf_dprintf	function
(	O
"Cannot create per-CU CTF archive for CU %s from "	pointer
"input file %s: %s\n"	pointer
,	O
cuname	pointer
,	O
filename	pointer
,	O
ctf_errmsg	function
(	O
err	long
)	O
)	O
;	O
ctf_set_errno	function
(	O
fp	pointer
,	O
err	long
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
dynname	pointer
=	O
strdup	function
(	O
ctf_name	pointer
)	O
)	O
==	O
NULL	O
)	O
goto	O
oom	O
;	O
if	O
(	O
ctf_dynhash_insert	function
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
,	O
dynname	pointer
,	O
cu_fp	pointer
)	O
<	O
0	int
)	O
goto	O
oom	O
;	O
ctf_import	function
(	O
cu_fp	pointer
,	O
fp	pointer
)	O
;	O
ctf_cuname_set	function
(	O
cu_fp	pointer
,	O
cuname	pointer
)	O
;	O
ctf_parent_name_set	function
(	O
cu_fp	pointer
,	O
_CTF_SECTION	array
)	O
;	O
}	O
return	O
cu_fp	pointer
;	O
oom	O
:	O
free	function
(	O
dynname	pointer
)	O
;	O
ctf_file_close	function
(	O
cu_fp	pointer
)	O
;	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
;	O
return	O
NULL	O
;	O
}	O
int	O
ctf_link_add_cu_mapping	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
from	pointer
,	O
const	O
char	O
*	O
to	pointer
)	O
{	O
int	O
err	long
;	O
char	O
*	O
f	pointer
,	O
*	O
t	pointer
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_cu_mapping	pointer
==	O
NULL	O
)	O
fp	pointer
->	O
ctf_link_cu_mapping	pointer
=	O
ctf_dynhash_create	function
(	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
,	O
free	function
,	O
free	function
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_cu_mapping	pointer
==	O
NULL	O
)	O
return	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
==	O
NULL	O
)	O
fp	pointer
->	O
ctf_link_outputs	pointer
=	O
ctf_dynhash_create	function
(	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
,	O
free	function
,	O
ctf_file_close_thunk	function
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
==	O
NULL	O
)	O
return	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
;	O
f	pointer
=	O
strdup	function
(	O
from	pointer
)	O
;	O
t	pointer
=	O
strdup	function
(	O
to	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
||	O
!	O
t	pointer
)	O
goto	O
oom	O
;	O
if	O
(	O
ctf_create_per_cu	function
(	O
fp	pointer
,	O
t	pointer
,	O
t	pointer
)	O
==	O
NULL	O
)	O
goto	O
oom_noerrno	O
;	O
err	long
=	O
ctf_dynhash_insert	function
(	O
fp	pointer
->	O
ctf_link_cu_mapping	pointer
,	O
f	pointer
,	O
t	pointer
)	O
;	O
if	O
(	O
err	long
)	O
{	O
ctf_set_errno	function
(	O
fp	pointer
,	O
err	long
)	O
;	O
goto	O
oom_noerrno	O
;	O
}	O
return	O
0	int
;	O
oom	O
:	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
;	O
oom_noerrno	O
:	O
free	function
(	O
f	pointer
)	O
;	O
free	function
(	O
t	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
void	O
ctf_link_set_memb_name_changer	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_link_memb_name_changer_f	function
*	O
changer	pointer
,	O
void	O
*	O
arg	pointer
)	O
{	O
fp	pointer
->	O
ctf_link_memb_name_changer	pointer
=	O
changer	pointer
;	O
fp	pointer
->	O
ctf_link_memb_name_changer_arg	pointer
=	O
arg	pointer
;	O
}	O
typedef	O
struct	O
ctf_link_in_member_cb_arg	struct
{	O
ctf_file_t	struct
*	O
out_fp	pointer
;	O
const	O
char	O
*	O
file_name	pointer
;	O
ctf_file_t	struct
*	O
in_fp	pointer
;	O
ctf_file_t	struct
*	O
main_input_fp	pointer
;	O
const	O
char	O
*	O
cu_name	pointer
;	O
char	O
*	O
arcname	pointer
;	O
int	O
done_main_member	int
;	O
int	O
share_mode	int
;	O
int	O
in_input_cu_file	int
;	O
}	O
ctf_link_in_member_cb_arg_t	struct
;	O
static	O
int	O
ctf_link_one_type	function
(	O
ctf_id_t	long
type	long
,	O
int	O
isroot	int
_libctf_unused_	O
,	O
void	O
*	O
arg_	pointer
)	O
{	O
ctf_link_in_member_cb_arg_t	struct
*	O
arg	pointer
=	O
(	O
ctf_link_in_member_cb_arg_t	struct
*	O
)	O
arg_	pointer
;	O
ctf_file_t	struct
*	O
per_cu_out_fp	pointer
;	O
int	O
err	long
;	O
if	O
(	O
arg	pointer
->	O
share_mode	int
!=	O
CTF_LINK_SHARE_UNCONFLICTED	int
)	O
{	O
ctf_dprintf	function
(	O
"Share-duplicated mode not yet implemented.\n"	pointer
)	O
;	O
return	O
ctf_set_errno	function
(	O
arg	pointer
->	O
out_fp	pointer
,	O
ECTF_NOTYET	int
)	O
;	O
}	O
if	O
(	O
!	O
arg	pointer
->	O
in_input_cu_file	int
)	O
{	O
if	O
(	O
ctf_add_type	function
(	O
arg	pointer
->	O
out_fp	pointer
,	O
arg	pointer
->	O
in_fp	pointer
,	O
type	long
)	O
!=	O
CTF_ERR	O
)	O
return	O
0	int
;	O
err	long
=	O
ctf_errno	function
(	O
arg	pointer
->	O
out_fp	pointer
)	O
;	O
if	O
(	O
err	long
!=	O
ECTF_CONFLICT	int
)	O
{	O
if	O
(	O
err	long
!=	O
ECTF_NONREPRESENTABLE	int
)	O
ctf_dprintf	function
(	O
"Cannot link type %lx from archive member %s, input file %s "	pointer
"into output link: %s\n"	pointer
,	O
type	long
,	O
arg	pointer
->	O
arcname	pointer
,	O
arg	pointer
->	O
file_name	pointer
,	O
ctf_errmsg	function
(	O
err	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
ctf_set_errno	function
(	O
arg	pointer
->	O
out_fp	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
per_cu_out_fp	pointer
=	O
ctf_create_per_cu	function
(	O
arg	pointer
->	O
out_fp	pointer
,	O
arg	pointer
->	O
file_name	pointer
,	O
arg	pointer
->	O
cu_name	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ctf_add_type	function
(	O
per_cu_out_fp	pointer
,	O
arg	pointer
->	O
in_fp	pointer
,	O
type	long
)	O
!=	O
CTF_ERR	O
)	O
return	O
0	int
;	O
err	long
=	O
ctf_errno	function
(	O
per_cu_out_fp	pointer
)	O
;	O
if	O
(	O
err	long
!=	O
ECTF_NONREPRESENTABLE	int
)	O
ctf_dprintf	function
(	O
"Cannot link type %lx from CTF archive member %s, input file %s "	pointer
"into output per-CU CTF archive member %s: %s: skipped\n"	pointer
,	O
type	long
,	O
arg	pointer
->	O
arcname	pointer
,	O
arg	pointer
->	O
file_name	pointer
,	O
arg	pointer
->	O
arcname	pointer
,	O
ctf_errmsg	function
(	O
err	long
)	O
)	O
;	O
if	O
(	O
err	long
==	O
ECTF_CONFLICT	int
)	O
ctf_set_errno	function
(	O
arg	pointer
->	O
out_fp	pointer
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
check_variable	function
(	O
const	O
char	O
*	O
name	pointer
,	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_id_t	long
type	long
,	O
ctf_dvdef_t	struct
*	O
*	O
out_dvd	pointer
)	O
{	O
ctf_dvdef_t	struct
*	O
dvd	pointer
;	O
dvd	pointer
=	O
ctf_dynhash_lookup	function
(	O
fp	pointer
->	O
ctf_dvhash	pointer
,	O
name	pointer
)	O
;	O
*	O
out_dvd	pointer
=	O
dvd	pointer
;	O
if	O
(	O
!	O
dvd	pointer
)	O
return	O
1	int
;	O
if	O
(	O
dvd	pointer
->	O
dvd_type	long
!=	O
type	long
)	O
{	O
ctf_dprintf	function
(	O
"Inexpressible duplicate variable %s skipped.\n"	pointer
,	O
name	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
ctf_link_one_variable	function
(	O
const	O
char	O
*	O
name	pointer
,	O
ctf_id_t	long
type	long
,	O
void	O
*	O
arg_	pointer
)	O
{	O
ctf_link_in_member_cb_arg_t	struct
*	O
arg	pointer
=	O
(	O
ctf_link_in_member_cb_arg_t	struct
*	O
)	O
arg_	pointer
;	O
ctf_file_t	struct
*	O
per_cu_out_fp	pointer
;	O
ctf_id_t	long
dst_type	long
=	O
0	int
;	O
ctf_file_t	struct
*	O
check_fp	pointer
;	O
ctf_dvdef_t	struct
*	O
dvd	pointer
;	O
check_fp	pointer
=	O
arg	pointer
->	O
out_fp	pointer
;	O
dst_type	long
=	O
ctf_type_mapping	function
(	O
arg	pointer
->	O
in_fp	pointer
,	O
type	long
,	O
&	O
check_fp	pointer
)	O
;	O
if	O
(	O
dst_type	long
!=	O
0	int
)	O
{	O
if	O
(	O
check_fp	pointer
==	O
arg	pointer
->	O
out_fp	pointer
)	O
{	O
if	O
(	O
check_variable	function
(	O
name	pointer
,	O
check_fp	pointer
,	O
dst_type	long
,	O
&	O
dvd	pointer
)	O
)	O
{	O
if	O
(	O
ctf_add_variable	function
(	O
check_fp	pointer
,	O
name	pointer
,	O
dst_type	long
)	O
<	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
arg	pointer
->	O
out_fp	pointer
,	O
ctf_errno	function
(	O
check_fp	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
dvd	pointer
&&	O
dvd	pointer
->	O
dvd_type	long
==	O
type	long
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
(	O
per_cu_out_fp	pointer
=	O
ctf_create_per_cu	function
(	O
arg	pointer
->	O
out_fp	pointer
,	O
arg	pointer
->	O
file_name	pointer
,	O
arg	pointer
->	O
cu_name	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
dst_type	long
==	O
0	int
)	O
{	O
check_fp	pointer
=	O
per_cu_out_fp	pointer
;	O
dst_type	long
=	O
ctf_type_mapping	function
(	O
arg	pointer
->	O
in_fp	pointer
,	O
type	long
,	O
&	O
check_fp	pointer
)	O
;	O
if	O
(	O
dst_type	long
==	O
0	int
)	O
{	O
ctf_dprintf	function
(	O
"Type %lx for variable %s in input file %s not "	pointer
"found: skipped.\n"	pointer
,	O
type	long
,	O
name	pointer
,	O
arg	pointer
->	O
file_name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
check_variable	function
(	O
name	pointer
,	O
per_cu_out_fp	pointer
,	O
dst_type	long
,	O
&	O
dvd	pointer
)	O
)	O
if	O
(	O
ctf_add_variable	function
(	O
per_cu_out_fp	pointer
,	O
name	pointer
,	O
dst_type	long
)	O
<	O
0	int
)	O
return	O
(	O
ctf_set_errno	function
(	O
arg	pointer
->	O
out_fp	pointer
,	O
ctf_errno	function
(	O
per_cu_out_fp	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ctf_link_one_input_archive_member	function
(	O
ctf_file_t	struct
*	O
in_fp	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
void	O
*	O
arg_	pointer
)	O
{	O
ctf_link_in_member_cb_arg_t	struct
*	O
arg	pointer
=	O
(	O
ctf_link_in_member_cb_arg_t	struct
*	O
)	O
arg_	pointer
;	O
int	O
err	long
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
_CTF_SECTION	array
)	O
==	O
0	int
)	O
{	O
if	O
(	O
arg	pointer
->	O
done_main_member	int
)	O
return	O
0	int
;	O
arg	pointer
->	O
arcname	pointer
=	O
strdup	function
(	O
".ctf."	pointer
)	O
;	O
if	O
(	O
arg	pointer
->	O
arcname	pointer
)	O
{	O
char	O
*	O
new_name	pointer
;	O
new_name	pointer
=	O
ctf_str_append	function
(	O
arg	pointer
->	O
arcname	pointer
,	O
arg	pointer
->	O
file_name	pointer
)	O
;	O
if	O
(	O
new_name	pointer
)	O
arg	pointer
->	O
arcname	pointer
=	O
new_name	pointer
;	O
else	O
free	function
(	O
arg	pointer
->	O
arcname	pointer
)	O
;	O
}	O
}	O
else	O
{	O
arg	pointer
->	O
arcname	pointer
=	O
strdup	function
(	O
name	pointer
)	O
;	O
ctf_import	function
(	O
in_fp	pointer
,	O
arg	pointer
->	O
main_input_fp	pointer
)	O
;	O
arg	pointer
->	O
in_input_cu_file	int
=	O
1	int
;	O
}	O
if	O
(	O
!	O
arg	pointer
->	O
arcname	pointer
)	O
return	O
ctf_set_errno	function
(	O
in_fp	pointer
,	O
ENOMEM	int
)	O
;	O
arg	pointer
->	O
cu_name	pointer
=	O
name	pointer
;	O
if	O
(	O
strncmp	function
(	O
arg	pointer
->	O
cu_name	pointer
,	O
".ctf."	pointer
,	O
strlen	function
(	O
".ctf."	pointer
)	O
)	O
==	O
0	int
)	O
arg	pointer
->	O
cu_name	pointer
+=	O
strlen	function
(	O
".ctf."	pointer
)	O
;	O
arg	pointer
->	O
in_fp	pointer
=	O
in_fp	pointer
;	O
if	O
(	O
(	O
err	long
=	O
ctf_type_iter_all	function
(	O
in_fp	pointer
,	O
ctf_link_one_type	function
,	O
arg	pointer
)	O
)	O
>	O
-	O
1	int
)	O
err	long
=	O
ctf_variable_iter	function
(	O
in_fp	pointer
,	O
ctf_link_one_variable	function
,	O
arg	pointer
)	O
;	O
arg	pointer
->	O
in_input_cu_file	int
=	O
0	int
;	O
free	function
(	O
arg	pointer
->	O
arcname	pointer
)	O
;	O
if	O
(	O
err	long
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
empty_link_type_mapping	function
(	O
void	O
*	O
key	pointer
_libctf_unused_	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg	pointer
_libctf_unused_	O
)	O
{	O
ctf_file_t	struct
*	O
fp	pointer
=	O
(	O
ctf_file_t	struct
*	O
)	O
value	int
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_type_mapping	pointer
)	O
ctf_dynhash_empty	function
(	O
fp	pointer
->	O
ctf_link_type_mapping	pointer
)	O
;	O
}	O
static	O
void	O
ctf_link_one_input_archive	function
(	O
void	O
*	O
key	pointer
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg_	pointer
)	O
{	O
const	O
char	O
*	O
file_name	pointer
=	O
(	O
const	O
char	O
*	O
)	O
key	pointer
;	O
ctf_archive_t	struct
*	O
arc	pointer
=	O
(	O
ctf_archive_t	struct
*	O
)	O
value	int
;	O
ctf_link_in_member_cb_arg_t	struct
*	O
arg	pointer
=	O
(	O
ctf_link_in_member_cb_arg_t	struct
*	O
)	O
arg_	pointer
;	O
int	O
err	long
;	O
arg	pointer
->	O
file_name	pointer
=	O
file_name	pointer
;	O
arg	pointer
->	O
done_main_member	int
=	O
0	int
;	O
if	O
(	O
(	O
arg	pointer
->	O
main_input_fp	pointer
=	O
ctf_arc_open_by_name	function
(	O
arc	pointer
,	O
NULL	O
,	O
&	O
err	long
)	O
)	O
==	O
NULL	O
)	O
if	O
(	O
err	long
!=	O
ECTF_ARNNAME	int
)	O
{	O
ctf_dprintf	function
(	O
"Cannot open main archive member in input file %s in the "	pointer
"link: skipping: %s.\n"	pointer
,	O
arg	pointer
->	O
file_name	pointer
,	O
ctf_errmsg	function
(	O
err	long
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ctf_link_one_input_archive_member	function
(	O
arg	pointer
->	O
main_input_fp	pointer
,	O
_CTF_SECTION	array
,	O
arg	pointer
)	O
<	O
0	int
)	O
{	O
ctf_file_close	function
(	O
arg	pointer
->	O
main_input_fp	pointer
)	O
;	O
return	O
;	O
}	O
arg	pointer
->	O
done_main_member	int
=	O
1	int
;	O
if	O
(	O
ctf_archive_iter	function
(	O
arc	pointer
,	O
ctf_link_one_input_archive_member	function
,	O
arg	pointer
)	O
<	O
0	int
)	O
ctf_dprintf	function
(	O
"Cannot traverse archive in input file %s: link "	pointer
"cannot continue: %s.\n"	pointer
,	O
arg	pointer
->	O
file_name	pointer
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
arg	pointer
->	O
out_fp	pointer
)	O
)	O
)	O
;	O
else	O
{	O
ctf_set_errno	function
(	O
arg	pointer
->	O
out_fp	pointer
,	O
0	int
)	O
;	O
}	O
ctf_file_close	function
(	O
arg	pointer
->	O
main_input_fp	pointer
)	O
;	O
if	O
(	O
arg	pointer
->	O
out_fp	pointer
->	O
ctf_link_type_mapping	pointer
)	O
ctf_dynhash_empty	function
(	O
arg	pointer
->	O
out_fp	pointer
->	O
ctf_link_type_mapping	pointer
)	O
;	O
ctf_dynhash_iter	function
(	O
arg	pointer
->	O
out_fp	pointer
->	O
ctf_link_outputs	pointer
,	O
empty_link_type_mapping	function
,	O
NULL	O
)	O
;	O
}	O
int	O
ctf_link	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
int	O
share_mode	int
)	O
{	O
ctf_link_in_member_cb_arg_t	struct
arg	pointer
;	O
memset	function
(	O
&	O
arg	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
ctf_link_in_member_cb_arg	struct
)	O
)	O
;	O
arg	pointer
.	O
out_fp	pointer
=	O
fp	pointer
;	O
arg	pointer
.	O
share_mode	int
=	O
share_mode	int
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_inputs	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
==	O
NULL	O
)	O
fp	pointer
->	O
ctf_link_outputs	pointer
=	O
ctf_dynhash_create	function
(	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
,	O
free	function
,	O
ctf_file_close_thunk	function
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
==	O
NULL	O
)	O
return	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
;	O
ctf_dynhash_iter	function
(	O
fp	pointer
->	O
ctf_link_inputs	pointer
,	O
ctf_link_one_input_archive	function
,	O
&	O
arg	pointer
)	O
;	O
if	O
(	O
ctf_errno	function
(	O
fp	pointer
)	O
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
ctf_link_out_string_cb_arg	struct
{	O
const	O
char	O
*	O
str	pointer
;	O
uint32_t	int
offset	long
;	O
int	O
err	long
;	O
}	O
ctf_link_out_string_cb_arg_t	struct
;	O
static	O
void	O
ctf_link_intern_extern_string	function
(	O
void	O
*	O
key	pointer
_libctf_unused_	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg_	pointer
)	O
{	O
ctf_file_t	struct
*	O
fp	pointer
=	O
(	O
ctf_file_t	struct
*	O
)	O
value	int
;	O
ctf_link_out_string_cb_arg_t	struct
*	O
arg	pointer
=	O
(	O
ctf_link_out_string_cb_arg_t	struct
*	O
)	O
arg_	pointer
;	O
fp	pointer
->	O
ctf_flags	int
|=	O
LCTF_DIRTY	int
;	O
if	O
(	O
!	O
ctf_str_add_external	function
(	O
fp	pointer
,	O
arg	pointer
->	O
str	pointer
,	O
arg	pointer
->	O
offset	long
)	O
)	O
arg	pointer
->	O
err	long
=	O
ENOMEM	int
;	O
}	O
int	O
ctf_link_add_strtab	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_link_strtab_string_f	function
*	O
add_string	pointer
,	O
void	O
*	O
arg	pointer
)	O
{	O
const	O
char	O
*	O
str	pointer
;	O
uint32_t	int
offset	long
;	O
int	O
err	long
=	O
0	int
;	O
while	O
(	O
(	O
str	pointer
=	O
add_string	pointer
(	O
&	O
offset	long
,	O
arg	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
ctf_link_out_string_cb_arg_t	struct
iter_arg	struct
=	O
{	O
str	pointer
,	O
offset	long
,	O
0	int
}	O
;	O
fp	pointer
->	O
ctf_flags	int
|=	O
LCTF_DIRTY	int
;	O
if	O
(	O
!	O
ctf_str_add_external	function
(	O
fp	pointer
,	O
str	pointer
,	O
offset	long
)	O
)	O
err	long
=	O
ENOMEM	int
;	O
ctf_dynhash_iter	function
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
,	O
ctf_link_intern_extern_string	function
,	O
&	O
iter_arg	struct
)	O
;	O
if	O
(	O
iter_arg	struct
.	O
err	long
)	O
err	long
=	O
iter_arg	struct
.	O
err	long
;	O
}	O
return	O
-	O
err	long
;	O
}	O
int	O
ctf_link_shuffle_syms	function
(	O
ctf_file_t	struct
*	O
fp	pointer
_libctf_unused_	O
,	O
ctf_link_iter_symbol_f	function
*	O
add_sym	pointer
_libctf_unused_	O
,	O
void	O
*	O
arg	pointer
_libctf_unused_	O
)	O
{	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
ctf_name_list_accum_cb_arg	struct
{	O
char	O
*	O
*	O
names	pointer
;	O
ctf_file_t	struct
*	O
fp	pointer
;	O
ctf_file_t	struct
*	O
*	O
files	pointer
;	O
size_t	long
i	pointer
;	O
char	O
*	O
*	O
dynames	pointer
;	O
size_t	long
ndynames	long
;	O
}	O
ctf_name_list_accum_cb_arg_t	struct
;	O
static	O
void	O
ctf_accumulate_archive_names	function
(	O
void	O
*	O
key	pointer
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg_	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
(	O
const	O
char	O
*	O
)	O
key	pointer
;	O
ctf_file_t	struct
*	O
fp	pointer
=	O
(	O
ctf_file_t	struct
*	O
)	O
value	int
;	O
char	O
*	O
*	O
names	pointer
;	O
ctf_file_t	struct
*	O
*	O
files	pointer
;	O
ctf_name_list_accum_cb_arg_t	struct
*	O
arg	pointer
=	O
(	O
ctf_name_list_accum_cb_arg_t	struct
*	O
)	O
arg_	pointer
;	O
if	O
(	O
(	O
names	pointer
=	O
realloc	function
(	O
arg	pointer
->	O
names	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
++	O
(	O
arg	pointer
->	O
i	pointer
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
(	O
arg	pointer
->	O
i	pointer
)	O
--	O
;	O
ctf_set_errno	function
(	O
arg	pointer
->	O
fp	pointer
,	O
ENOMEM	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
files	pointer
=	O
realloc	function
(	O
arg	pointer
->	O
files	pointer
,	O
sizeof	O
(	O
ctf_file_t	struct
*	O
)	O
*	O
arg	pointer
->	O
i	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
(	O
arg	pointer
->	O
i	pointer
)	O
--	O
;	O
ctf_set_errno	function
(	O
arg	pointer
->	O
fp	pointer
,	O
ENOMEM	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
fp	pointer
->	O
ctf_link_memb_name_changer	pointer
)	O
{	O
char	O
*	O
*	O
dynames	pointer
;	O
char	O
*	O
dyname	pointer
;	O
void	O
*	O
nc_arg	pointer
=	O
fp	pointer
->	O
ctf_link_memb_name_changer_arg	pointer
;	O
dyname	pointer
=	O
fp	pointer
->	O
ctf_link_memb_name_changer	pointer
(	O
fp	pointer
,	O
name	pointer
,	O
nc_arg	pointer
)	O
;	O
if	O
(	O
dyname	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
dynames	pointer
=	O
realloc	function
(	O
arg	pointer
->	O
dynames	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
++	O
(	O
arg	pointer
->	O
ndynames	long
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
(	O
arg	pointer
->	O
ndynames	long
)	O
--	O
;	O
ctf_set_errno	function
(	O
arg	pointer
->	O
fp	pointer
,	O
ENOMEM	int
)	O
;	O
return	O
;	O
}	O
arg	pointer
->	O
dynames	pointer
=	O
dynames	pointer
;	O
name	pointer
=	O
(	O
const	O
char	O
*	O
)	O
dyname	pointer
;	O
}	O
}	O
arg	pointer
->	O
names	pointer
=	O
names	pointer
;	O
arg	pointer
->	O
names	pointer
[	O
(	O
arg	pointer
->	O
i	pointer
)	O
-	O
1	int
]	O
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
arg	pointer
->	O
files	pointer
=	O
files	pointer
;	O
arg	pointer
->	O
files	pointer
[	O
(	O
arg	pointer
->	O
i	pointer
)	O
-	O
1	int
]	O
=	O
fp	pointer
;	O
}	O
static	O
void	O
ctf_change_parent_name	function
(	O
void	O
*	O
key	pointer
_libctf_unused_	O
,	O
void	O
*	O
value	int
,	O
void	O
*	O
arg	pointer
)	O
{	O
ctf_file_t	struct
*	O
fp	pointer
=	O
(	O
ctf_file_t	struct
*	O
)	O
value	int
;	O
const	O
char	O
*	O
name	pointer
=	O
(	O
const	O
char	O
*	O
)	O
arg	pointer
;	O
ctf_parent_name_set	function
(	O
fp	pointer
,	O
name	pointer
)	O
;	O
}	O
unsigned	O
char	O
*	O
ctf_link_write	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
size_t	long
*	O
size	long
,	O
size_t	long
threshold	long
)	O
{	O
ctf_name_list_accum_cb_arg_t	struct
arg	pointer
;	O
char	O
*	O
*	O
names	pointer
;	O
char	O
*	O
transformed_name	pointer
=	O
NULL	O
;	O
ctf_file_t	struct
*	O
*	O
files	pointer
;	O
FILE	struct
*	O
f	pointer
=	O
NULL	O
;	O
int	O
err	long
;	O
long	O
fsize	long
;	O
const	O
char	O
*	O
errloc	pointer
;	O
unsigned	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
memset	function
(	O
&	O
arg	pointer
,	O
0	int
,	O
sizeof	O
(	O
ctf_name_list_accum_cb_arg_t	struct
)	O
)	O
;	O
arg	pointer
.	O
fp	pointer
=	O
fp	pointer
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
)	O
{	O
ctf_dynhash_iter	function
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
,	O
ctf_accumulate_archive_names	function
,	O
&	O
arg	pointer
)	O
;	O
if	O
(	O
ctf_errno	function
(	O
fp	pointer
)	O
<	O
0	int
)	O
{	O
errloc	pointer
=	O
"hash creation"	pointer
;	O
goto	O
err	long
;	O
}	O
}	O
if	O
(	O
arg	pointer
.	O
i	pointer
==	O
0	int
)	O
return	O
ctf_write_mem	function
(	O
fp	pointer
,	O
size	long
,	O
threshold	long
)	O
;	O
if	O
(	O
(	O
names	pointer
=	O
realloc	function
(	O
arg	pointer
.	O
names	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
arg	pointer
.	O
i	pointer
+	O
1	int
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errloc	pointer
=	O
"name reallocation"	pointer
;	O
goto	O
err_no	O
;	O
}	O
arg	pointer
.	O
names	pointer
=	O
names	pointer
;	O
memmove	function
(	O
&	O
(	O
arg	pointer
.	O
names	pointer
[	O
1	int
]	O
)	O
,	O
arg	pointer
.	O
names	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
arg	pointer
.	O
i	pointer
)	O
)	O
;	O
arg	pointer
.	O
names	pointer
[	O
0	int
]	O
=	O
(	O
char	O
*	O
)	O
_CTF_SECTION	array
;	O
if	O
(	O
fp	pointer
->	O
ctf_link_memb_name_changer	pointer
)	O
{	O
void	O
*	O
nc_arg	pointer
=	O
fp	pointer
->	O
ctf_link_memb_name_changer_arg	pointer
;	O
transformed_name	pointer
=	O
fp	pointer
->	O
ctf_link_memb_name_changer	pointer
(	O
fp	pointer
,	O
_CTF_SECTION	array
,	O
nc_arg	pointer
)	O
;	O
if	O
(	O
transformed_name	pointer
!=	O
NULL	O
)	O
{	O
arg	pointer
.	O
names	pointer
[	O
0	int
]	O
=	O
transformed_name	pointer
;	O
ctf_dynhash_iter	function
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
,	O
ctf_change_parent_name	function
,	O
transformed_name	pointer
)	O
;	O
}	O
}	O
if	O
(	O
(	O
files	pointer
=	O
realloc	function
(	O
arg	pointer
.	O
files	pointer
,	O
sizeof	O
(	O
struct	O
ctf_file	struct
*	O
)	O
*	O
(	O
arg	pointer
.	O
i	pointer
+	O
1	int
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errloc	pointer
=	O
"ctf_file reallocation"	pointer
;	O
goto	O
err_no	O
;	O
}	O
arg	pointer
.	O
files	pointer
=	O
files	pointer
;	O
memmove	function
(	O
&	O
(	O
arg	pointer
.	O
files	pointer
[	O
1	int
]	O
)	O
,	O
arg	pointer
.	O
files	pointer
,	O
sizeof	O
(	O
ctf_file_t	struct
*	O
)	O
*	O
(	O
arg	pointer
.	O
i	pointer
)	O
)	O
;	O
arg	pointer
.	O
files	pointer
[	O
0	int
]	O
=	O
fp	pointer
;	O
if	O
(	O
(	O
f	pointer
=	O
tmpfile	function
(	O
)	O
)	O
==	O
NULL	O
)	O
{	O
errloc	pointer
=	O
"tempfile creation"	pointer
;	O
goto	O
err_no	O
;	O
}	O
if	O
(	O
(	O
err	long
=	O
ctf_arc_write_fd	function
(	O
fileno	function
(	O
f	pointer
)	O
,	O
arg	pointer
.	O
files	pointer
,	O
arg	pointer
.	O
i	pointer
+	O
1	int
,	O
(	O
const	O
char	O
*	O
*	O
)	O
arg	pointer
.	O
names	pointer
,	O
threshold	long
)	O
)	O
<	O
0	int
)	O
{	O
errloc	pointer
=	O
"archive writing"	pointer
;	O
ctf_set_errno	function
(	O
fp	pointer
,	O
err	long
)	O
;	O
goto	O
err	long
;	O
}	O
if	O
(	O
fseek	function
(	O
f	pointer
,	O
0	int
,	O
SEEK_END	int
)	O
<	O
0	int
)	O
{	O
errloc	pointer
=	O
"seeking to end"	pointer
;	O
goto	O
err_no	O
;	O
}	O
if	O
(	O
(	O
fsize	long
=	O
ftell	function
(	O
f	pointer
)	O
)	O
<	O
0	int
)	O
{	O
errloc	pointer
=	O
"filesize determination"	pointer
;	O
goto	O
err_no	O
;	O
}	O
if	O
(	O
fseek	function
(	O
f	pointer
,	O
0	int
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
errloc	pointer
=	O
"filepos resetting"	pointer
;	O
goto	O
err_no	O
;	O
}	O
if	O
(	O
(	O
buf	pointer
=	O
malloc	function
(	O
fsize	long
)	O
)	O
==	O
NULL	O
)	O
{	O
errloc	pointer
=	O
"CTF archive buffer allocation"	pointer
;	O
goto	O
err_no	O
;	O
}	O
while	O
(	O
!	O
feof	function
(	O
f	pointer
)	O
&&	O
fread	function
(	O
buf	pointer
,	O
fsize	long
,	O
1	int
,	O
f	pointer
)	O
==	O
0	int
)	O
if	O
(	O
ferror	function
(	O
f	pointer
)	O
)	O
{	O
errloc	pointer
=	O
"reading archive from temporary file"	pointer
;	O
goto	O
err_no	O
;	O
}	O
*	O
size	long
=	O
fsize	long
;	O
free	function
(	O
arg	pointer
.	O
names	pointer
)	O
;	O
free	function
(	O
arg	pointer
.	O
files	pointer
)	O
;	O
free	function
(	O
transformed_name	pointer
)	O
;	O
if	O
(	O
arg	pointer
.	O
ndynames	long
)	O
{	O
size_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
arg	pointer
.	O
ndynames	long
;	O
i	pointer
++	O
)	O
free	function
(	O
arg	pointer
.	O
dynames	pointer
[	O
i	pointer
]	O
)	O
;	O
free	function
(	O
arg	pointer
.	O
dynames	pointer
)	O
;	O
}	O
return	O
buf	pointer
;	O
err_no	O
:	O
ctf_set_errno	function
(	O
fp	pointer
,	O
errno	O
)	O
;	O
err	long
:	O
free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
f	pointer
)	O
fclose	function
(	O
f	pointer
)	O
;	O
free	function
(	O
arg	pointer
.	O
names	pointer
)	O
;	O
free	function
(	O
arg	pointer
.	O
files	pointer
)	O
;	O
free	function
(	O
transformed_name	pointer
)	O
;	O
if	O
(	O
arg	pointer
.	O
ndynames	long
)	O
{	O
size_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
arg	pointer
.	O
ndynames	long
;	O
i	pointer
++	O
)	O
free	function
(	O
arg	pointer
.	O
dynames	pointer
[	O
i	pointer
]	O
)	O
;	O
free	function
(	O
arg	pointer
.	O
dynames	pointer
)	O
;	O
}	O
ctf_dprintf	function
(	O
"Cannot write archive in link: %s failure: %s\n"	pointer
,	O
errloc	pointer
,	O
ctf_errmsg	function
(	O
ctf_errno	function
(	O
fp	pointer
)	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
