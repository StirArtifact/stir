int	O
mu_cfg_parser_verbose	int
;	O
static	O
mu_list_t	pointer
parse_node_list	pointer
;	O
size_t	long
mu_cfg_error_count	long
;	O
static	O
int	O
_mu_cfg_errcnt	int
;	O
int	O
mu_cfg_yylex	function
(	O
)	O
;	O
void	O
_mu_line_begin	function
(	O
void	O
)	O
;	O
void	O
_mu_line_add	function
(	O
char	O
*	O
text	pointer
,	O
size_t	long
len	long
)	O
;	O
char	O
*	O
_mu_line_finish	function
(	O
void	O
)	O
;	O
static	O
int	O
mu_cfg_yyerror	function
(	O
char	O
*	O
s	pointer
)	O
{	O
mu_error	function
(	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
0	int
;	O
}	O
static	O
mu_config_value_t	struct
*	O
config_value_dup	function
(	O
mu_config_value_t	struct
*	O
src	pointer
)	O
{	O
if	O
(	O
!	O
src	pointer
)	O
return	O
NULL	O
;	O
else	O
{	O
mu_config_value_t	struct
*	O
val	array
=	O
mu_alloc	function
(	O
sizeof	O
(	O
*	O
val	array
)	O
)	O
;	O
*	O
val	array
=	O
*	O
src	pointer
;	O
return	O
val	array
;	O
}	O
}	O
static	O
int	O
_node_set_parent	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
mu_cfg_node	struct
*	O
node	pointer
=	O
item	pointer
;	O
node	pointer
->	O
parent	pointer
=	O
data	pointer
;	O
return	O
0	int
;	O
}	O
static	O
mu_cfg_node_t	struct
*	O
mu_cfg_alloc_node	function
(	O
enum	O
mu_cfg_node_type	enum
type	pointer
,	O
struct	O
mu_locus_range	struct
*	O
loc	pointer
,	O
const	O
char	O
*	O
tag	pointer
,	O
mu_config_value_t	struct
*	O
label	pointer
,	O
mu_list_t	pointer
nodelist	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
mu_cfg_node_t	struct
*	O
np	pointer
;	O
size_t	long
size	long
=	O
sizeof	O
*	O
np	pointer
+	O
strlen	function
(	O
tag	pointer
)	O
+	O
1	int
;	O
np	pointer
=	O
mu_alloc	function
(	O
size	long
)	O
;	O
np	pointer
->	O
type	pointer
=	O
type	pointer
;	O
mu_locus_range_init	function
(	O
&	O
np	pointer
->	O
locus	struct
)	O
;	O
mu_locus_range_copy	function
(	O
&	O
np	pointer
->	O
locus	struct
,	O
loc	pointer
)	O
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
(	O
np	pointer
+	O
1	int
)	O
;	O
np	pointer
->	O
tag	pointer
=	O
p	pointer
;	O
strcpy	function
(	O
p	pointer
,	O
tag	pointer
)	O
;	O
np	pointer
->	O
label	pointer
=	O
label	pointer
;	O
np	pointer
->	O
nodes	pointer
=	O
nodelist	pointer
;	O
np	pointer
->	O
parent	pointer
=	O
NULL	O
;	O
return	O
np	pointer
;	O
}	O
void	O
mu_cfg_free_node	function
(	O
mu_cfg_node_t	struct
*	O
node	pointer
)	O
{	O
free	function
(	O
node	pointer
->	O
label	pointer
)	O
;	O
free	function
(	O
node	pointer
)	O
;	O
}	O
static	O
void	O
debug_print_node	function
(	O
mu_cfg_node_t	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
mu_debug_level_p	function
(	O
MU_DEBCAT_CONFIG	int
,	O
MU_DEBUG_TRACE0	int
)	O
)	O
{	O
if	O
(	O
node	pointer
->	O
type	pointer
==	O
mu_cfg_node_undefined	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"unknown statement type!"	pointer
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
}	O
else	O
{	O
mu_error	function
(	O
"statement: %s, id: %s"	pointer
,	O
node_type_str	O
(	O
node	pointer
->	O
type	pointer
)	O
,	O
node	pointer
->	O
tag	pointer
?	O
node	pointer
->	O
tag	pointer
:	O
"(null)"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
free_node_item	function
(	O
void	O
*	O
item	pointer
)	O
{	O
mu_cfg_node_t	struct
*	O
node	pointer
=	O
item	pointer
;	O
switch	O
(	O
node	pointer
->	O
type	pointer
)	O
{	O
case	O
mu_cfg_node_statement	int
:	O
mu_list_destroy	function
(	O
&	O
node	pointer
->	O
nodes	pointer
)	O
;	O
break	O
;	O
case	O
mu_cfg_node_undefined	int
:	O
case	O
mu_cfg_node_param	int
:	O
break	O
;	O
}	O
mu_cfg_free_node	function
(	O
node	pointer
)	O
;	O
}	O
int	O
mu_cfg_create_node_list	function
(	O
mu_list_t	pointer
*	O
plist	pointer
)	O
{	O
int	O
rc	int
;	O
mu_list_t	pointer
list	pointer
;	O
rc	int
=	O
mu_list_create	function
(	O
&	O
list	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
mu_list_set_destroy_item	function
(	O
list	pointer
,	O
free_node_item	function
)	O
;	O
*	O
plist	pointer
=	O
list	pointer
;	O
return	O
0	int
;	O
}	O
extern	O
int	O
mu_cfg_yydebug	int
;	O
enum	O
yytokentype	enum
{	O
MU_TOK_IDENT	int
=	O
258	int
,	O
MU_TOK_STRING	int
=	O
259	int
,	O
MU_TOK_QSTRING	int
=	O
260	int
,	O
MU_TOK_MSTRING	int
=	O
261	int
}	O
;	O
typedef	O
union	O
YYSTYPE	union
{	O
mu_cfg_node_t	struct
node	pointer
;	O
mu_cfg_node_t	struct
*	O
pnode	pointer
;	O
mu_list_t	pointer
nodelist	pointer
;	O
char	O
*	O
string	pointer
;	O
mu_config_value_t	struct
value	struct
,	O
*	O
pvalue	pointer
;	O
mu_list_t	pointer
list	pointer
;	O
}	O
YYSTYPE	union
;	O
extern	O
YYSTYPE	union
mu_cfg_yylval	union
;	O
extern	O
YYLTYPE	O
mu_cfg_yylloc	struct
;	O
int	O
mu_cfg_yyparse	function
(	O
void	O
)	O
;	O
typedef	O
unsigned	O
char	O
yytype_uint8	char
;	O
typedef	O
signed	O
char	O
yytype_int8	char
;	O
typedef	O
unsigned	O
short	O
int	O
yytype_uint16	short
;	O
typedef	O
short	O
int	O
yytype_int16	short
;	O
union	O
mu_cfg_yyalloc	union
{	O
yytype_int16	short
yyss_alloc	short
;	O
YYSTYPE	union
yyvs_alloc	union
;	O
YYLTYPE	O
yyls_alloc	struct
;	O
}	O
;	O
static	O
const	O
yytype_uint8	char
yytranslate	array
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
10	int
,	O
11	int
,	O
2	int
,	O
2	int
,	O
12	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
7	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
8	int
,	O
2	int
,	O
9	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yyprhs	array
[	O
]	O
=	O
{	O
0	int
,	O
0	int
,	O
3	int
,	O
5	int
,	O
7	int
,	O
10	int
,	O
12	int
,	O
14	int
,	O
18	int
,	O
24	int
,	O
31	int
,	O
33	int
,	O
34	int
,	O
36	int
,	O
38	int
,	O
40	int
,	O
43	int
,	O
45	int
,	O
47	int
,	O
49	int
,	O
51	int
,	O
53	int
,	O
55	int
,	O
57	int
,	O
59	int
,	O
62	int
,	O
66	int
,	O
71	int
,	O
73	int
,	O
77	int
,	O
78	int
}	O
;	O
static	O
const	O
yytype_int8	char
yyrhs	array
[	O
]	O
=	O
{	O
14	int
,	O
0	int
,	O
-	O
1	int
,	O
15	int
,	O
-	O
1	int
,	O
16	int
,	O
-	O
1	int
,	O
15	int
,	O
16	int
,	O
-	O
1	int
,	O
17	int
,	O
-	O
1	int
,	O
18	int
,	O
-	O
1	int
,	O
19	int
,	O
21	int
,	O
7	int
,	O
-	O
1	int
,	O
19	int
,	O
20	int
,	O
8	int
,	O
9	int
,	O
29	int
,	O
-	O
1	int
,	O
19	int
,	O
20	int
,	O
8	int
,	O
15	int
,	O
9	int
,	O
29	int
,	O
-	O
1	int
,	O
3	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
21	int
,	O
-	O
1	int
,	O
22	int
,	O
-	O
1	int
,	O
23	int
,	O
-	O
1	int
,	O
22	int
,	O
23	int
,	O
-	O
1	int
,	O
24	int
,	O
-	O
1	int
,	O
27	int
,	O
-	O
1	int
,	O
6	int
,	O
-	O
1	int
,	O
4	int
,	O
-	O
1	int
,	O
3	int
,	O
-	O
1	int
,	O
25	int
,	O
-	O
1	int
,	O
26	int
,	O
-	O
1	int
,	O
5	int
,	O
-	O
1	int
,	O
26	int
,	O
5	int
,	O
-	O
1	int
,	O
10	int
,	O
28	int
,	O
11	int
,	O
-	O
1	int
,	O
10	int
,	O
28	int
,	O
12	int
,	O
11	int
,	O
-	O
1	int
,	O
23	int
,	O
-	O
1	int
,	O
28	int
,	O
12	int
,	O
23	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
7	int
,	O
-	O
1	int
}	O
;	O
static	O
const	O
yytype_uint16	short
yyrline	array
[	O
]	O
=	O
{	O
0	int
,	O
196	int
,	O
196	int
,	O
202	int
,	O
207	int
,	O
215	int
,	O
216	int
,	O
219	int
,	O
228	int
,	O
235	int
,	O
245	int
,	O
249	int
,	O
252	int
,	O
255	int
,	O
290	int
,	O
300	int
,	O
306	int
,	O
311	int
,	O
316	int
,	O
323	int
,	O
324	int
,	O
325	int
,	O
328	int
,	O
347	int
,	O
352	int
,	O
359	int
,	O
363	int
,	O
369	int
,	O
374	int
,	O
381	int
,	O
382	int
}	O
;	O
static	O
const	O
char	O
*	O
const	O
yytname	array
[	O
]	O
=	O
{	O
"$end"	pointer
,	O
"error"	pointer
,	O
"$undefined"	pointer
,	O
"MU_TOK_IDENT"	pointer
,	O
"MU_TOK_STRING"	pointer
,	O
"MU_TOK_QSTRING"	pointer
,	O
"MU_TOK_MSTRING"	pointer
,	O
"';'"	pointer
,	O
"'{'"	pointer
,	O
"'}'"	pointer
,	O
"'('"	pointer
,	O
"')'"	pointer
,	O
"','"	pointer
,	O
"$accept"	pointer
,	O
"input"	pointer
,	O
"stmtlist"	pointer
,	O
"stmt"	pointer
,	O
"simple"	pointer
,	O
"block"	pointer
,	O
"ident"	pointer
,	O
"tag"	pointer
,	O
"vallist"	pointer
,	O
"vlist"	pointer
,	O
"value"	pointer
,	O
"string"	pointer
,	O
"slist"	pointer
,	O
"slist0"	pointer
,	O
"list"	pointer
,	O
"values"	pointer
,	O
"opt_sc"	pointer
,	O
YY_NULL	int
}	O
;	O
static	O
const	O
yytype_uint8	char
mu_cfg_yyr1	array
[	O
]	O
=	O
{	O
0	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
15	int
,	O
16	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
22	int
,	O
23	int
,	O
23	int
,	O
23	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
26	int
,	O
27	int
,	O
27	int
,	O
28	int
,	O
28	int
,	O
29	int
,	O
29	int
}	O
;	O
static	O
const	O
yytype_uint8	char
mu_cfg_yyr2	array
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
3	int
,	O
5	int
,	O
6	int
,	O
1	int
,	O
0	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
1	int
,	O
3	int
,	O
0	int
,	O
1	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yydefact	array
[	O
]	O
=	O
{	O
0	int
,	O
10	int
,	O
0	int
,	O
2	int
,	O
3	int
,	O
5	int
,	O
6	int
,	O
11	int
,	O
1	int
,	O
4	int
,	O
20	int
,	O
19	int
,	O
23	int
,	O
18	int
,	O
0	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
16	int
,	O
21	int
,	O
22	int
,	O
17	int
,	O
27	int
,	O
0	int
,	O
0	int
,	O
7	int
,	O
15	int
,	O
24	int
,	O
25	int
,	O
0	int
,	O
29	int
,	O
0	int
,	O
26	int
,	O
28	int
,	O
30	int
,	O
8	int
,	O
29	int
,	O
9	int
}	O
;	O
static	O
const	O
yytype_int8	char
yydefgoto	array
[	O
]	O
=	O
{	O
-	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
24	int
,	O
36	int
}	O
;	O
static	O
const	O
yytype_int8	char
mu_cfg_yypact	array
[	O
]	O
=	O
{	O
-	O
1	int
,	O
-	O
14	int
,	O
11	int
,	O
-	O
1	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
15	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
15	int
,	O
14	int
,	O
16	int
,	O
15	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
19	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
3	int
,	O
0	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
2	int
,	O
20	int
,	O
7	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
20	int
,	O
-	O
14	int
}	O
;	O
static	O
const	O
yytype_int8	char
yypgoto	array
[	O
]	O
=	O
{	O
-	O
14	int
,	O
-	O
14	int
,	O
1	int
,	O
-	O
3	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
13	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
14	int
,	O
-	O
9	int
}	O
;	O
static	O
const	O
yytype_uint8	char
mu_cfg_yytable	array
[	O
]	O
=	O
{	O
9	int
,	O
23	int
,	O
1	int
,	O
1	int
,	O
27	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
31	int
,	O
1	int
,	O
8	int
,	O
14	int
,	O
33	int
,	O
29	int
,	O
30	int
,	O
37	int
,	O
34	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
25	int
,	O
26	int
,	O
28	int
,	O
14	int
,	O
32	int
,	O
35	int
,	O
38	int
,	O
9	int
}	O
;	O
static	O
const	O
yytype_uint8	char
mu_cfg_yycheck	array
[	O
]	O
=	O
{	O
3	int
,	O
14	int
,	O
3	int
,	O
3	int
,	O
17	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
9	int
,	O
3	int
,	O
0	int
,	O
10	int
,	O
11	int
,	O
11	int
,	O
12	int
,	O
9	int
,	O
30	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
8	int
,	O
7	int
,	O
5	int
,	O
10	int
,	O
25	int
,	O
7	int
,	O
37	int
,	O
32	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yystos	array
[	O
]	O
=	O
{	O
0	int
,	O
3	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
0	int
,	O
16	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
10	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
23	int
,	O
28	int
,	O
8	int
,	O
7	int
,	O
23	int
,	O
5	int
,	O
11	int
,	O
12	int
,	O
9	int
,	O
15	int
,	O
11	int
,	O
23	int
,	O
7	int
,	O
29	int
,	O
9	int
,	O
29	int
}	O
;	O
static	O
void	O
yy_symbol_value_print	function
(	O
FILE	struct
*	O
yyoutput	pointer
,	O
int	O
yytype	int
,	O
YYSTYPE	union
const	O
*	O
const	O
yyvaluep	pointer
,	O
YYLTYPE	O
const	O
*	O
const	O
yylocationp	pointer
)	O
{	O
FILE	struct
*	O
yyo	pointer
=	O
yyoutput	pointer
;	O
YYUSE	O
(	O
yyo	pointer
)	O
;	O
if	O
(	O
!	O
yyvaluep	pointer
)	O
return	O
;	O
YYUSE	O
(	O
yylocationp	pointer
)	O
;	O
YYUSE	O
(	O
yyoutput	pointer
)	O
;	O
switch	O
(	O
yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
void	O
yy_symbol_print	function
(	O
FILE	struct
*	O
yyoutput	pointer
,	O
int	O
yytype	int
,	O
YYSTYPE	union
const	O
*	O
const	O
yyvaluep	pointer
,	O
YYLTYPE	O
const	O
*	O
const	O
yylocationp	pointer
)	O
{	O
if	O
(	O
yytype	int
<	O
YYNTOKENS	int
)	O
YYFPRINTF	O
(	O
yyoutput	pointer
,	O
"token %s ("	pointer
,	O
yytname	array
[	O
yytype	int
]	O
)	O
;	O
else	O
YYFPRINTF	O
(	O
yyoutput	pointer
,	O
"nterm %s ("	pointer
,	O
yytname	array
[	O
yytype	int
]	O
)	O
;	O
YY_LOCATION_PRINT	O
(	O
yyoutput	pointer
,	O
*	O
yylocationp	pointer
)	O
;	O
YYFPRINTF	O
(	O
yyoutput	pointer
,	O
": "	pointer
)	O
;	O
yy_symbol_value_print	function
(	O
yyoutput	pointer
,	O
yytype	int
,	O
yyvaluep	pointer
,	O
yylocationp	pointer
)	O
;	O
YYFPRINTF	O
(	O
yyoutput	pointer
,	O
")"	pointer
)	O
;	O
}	O
static	O
void	O
yy_stack_print	function
(	O
yytype_int16	short
*	O
yybottom	pointer
,	O
yytype_int16	short
*	O
yytop	pointer
)	O
{	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
"Stack now"	pointer
)	O
;	O
for	O
(	O
;	O
yybottom	pointer
<=	O
yytop	pointer
;	O
yybottom	pointer
++	O
)	O
{	O
int	O
yybot	int
=	O
*	O
yybottom	pointer
;	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
" %d"	pointer
,	O
yybot	int
)	O
;	O
}	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
yy_reduce_print	function
(	O
YYSTYPE	union
*	O
yyvsp	pointer
,	O
YYLTYPE	O
*	O
yylsp	pointer
,	O
int	O
mu_cfg_yyrule	int
)	O
{	O
int	O
yynrhs	int
=	O
mu_cfg_yyr2	array
[	O
mu_cfg_yyrule	int
]	O
;	O
int	O
yyi	int
;	O
unsigned	O
long	O
int	O
yylno	long
=	O
yyrline	array
[	O
mu_cfg_yyrule	int
]	O
;	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
"Reducing stack by rule %d (line %lu):\n"	pointer
,	O
mu_cfg_yyrule	int
-	O
1	int
,	O
yylno	long
)	O
;	O
for	O
(	O
yyi	int
=	O
0	int
;	O
yyi	int
<	O
yynrhs	int
;	O
yyi	int
++	O
)	O
{	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
"   $%d = "	pointer
,	O
yyi	int
+	O
1	int
)	O
;	O
yy_symbol_print	function
(	O
stderr	pointer
,	O
yyrhs	array
[	O
yyprhs	array
[	O
mu_cfg_yyrule	int
]	O
+	O
yyi	int
]	O
,	O
&	O
(	O
yyvsp	pointer
[	O
(	O
yyi	int
+	O
1	int
)	O
-	O
(	O
yynrhs	int
)	O
]	O
)	O
,	O
&	O
(	O
yylsp	pointer
[	O
(	O
yyi	int
+	O
1	int
)	O
-	O
(	O
yynrhs	int
)	O
]	O
)	O
)	O
;	O
YYFPRINTF	O
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
int	O
mu_cfg_yydebug	int
;	O
static	O
void	O
yydestruct	function
(	O
const	O
char	O
*	O
yymsg	pointer
,	O
int	O
yytype	int
,	O
YYSTYPE	union
*	O
yyvaluep	pointer
,	O
YYLTYPE	O
*	O
yylocationp	pointer
)	O
{	O
YYUSE	O
(	O
yyvaluep	pointer
)	O
;	O
YYUSE	O
(	O
yylocationp	pointer
)	O
;	O
if	O
(	O
!	O
yymsg	pointer
)	O
yymsg	pointer
=	O
"Deleting"	pointer
;	O
YY_SYMBOL_PRINT	O
(	O
yymsg	pointer
,	O
yytype	int
,	O
yyvaluep	pointer
,	O
yylocationp	pointer
)	O
;	O
switch	O
(	O
yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
int	O
mu_cfg_yychar	int
;	O
YYSTYPE	union
mu_cfg_yylval	union
YY_INITIAL_VALUE	O
(	O
yyval_default	O
)	O
;	O
YYLTYPE	O
mu_cfg_yylloc	struct
;	O
int	O
mu_cfg_yynerrs	int
;	O
int	O
mu_cfg_yyparse	function
(	O
void	O
)	O
{	O
int	O
mu_cfg_yystate	int
;	O
int	O
yyerrstatus	int
;	O
yytype_int16	short
yyssa	array
[	O
YYINITDEPTH	int
]	O
;	O
yytype_int16	short
*	O
yyss	pointer
;	O
yytype_int16	short
*	O
yyssp	pointer
;	O
YYSTYPE	union
yyvsa	array
[	O
YYINITDEPTH	int
]	O
;	O
YYSTYPE	union
*	O
yyvs	pointer
;	O
YYSTYPE	union
*	O
yyvsp	pointer
;	O
YYLTYPE	O
yylsa	array
[	O
YYINITDEPTH	int
]	O
;	O
YYLTYPE	O
*	O
yyls	pointer
;	O
YYLTYPE	O
*	O
yylsp	pointer
;	O
YYLTYPE	O
yyerror_range	array
[	O
3	int
]	O
;	O
YYSIZE_T	O
yystacksize	long
;	O
int	O
yyn	int
;	O
int	O
yyresult	int
;	O
int	O
yytoken	int
=	O
0	int
;	O
YYSTYPE	union
mu_cfg_yyval	union
;	O
YYLTYPE	O
yyloc	struct
;	O
int	O
mu_cfg_yylen	int
=	O
0	int
;	O
yyssp	pointer
=	O
yyss	pointer
=	O
yyssa	array
;	O
yyvsp	pointer
=	O
yyvs	pointer
=	O
yyvsa	array
;	O
yylsp	pointer
=	O
yyls	pointer
=	O
yylsa	array
;	O
yystacksize	long
=	O
YYINITDEPTH	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Starting parse\n"	pointer
)	O
)	O
;	O
mu_cfg_yystate	int
=	O
0	int
;	O
yyerrstatus	int
=	O
0	int
;	O
mu_cfg_yynerrs	int
=	O
0	int
;	O
mu_cfg_yychar	int
=	O
YYEMPTY	O
;	O
yylsp	pointer
[	O
0	int
]	O
=	O
mu_cfg_yylloc	struct
;	O
goto	O
yysetstate	O
;	O
yynewstate	O
:	O
yyssp	pointer
++	O
;	O
yysetstate	O
:	O
*	O
yyssp	pointer
=	O
mu_cfg_yystate	int
;	O
if	O
(	O
yyss	pointer
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	pointer
)	O
{	O
YYSIZE_T	O
yysize	long
=	O
yyssp	pointer
-	O
yyss	pointer
+	O
1	int
;	O
if	O
(	O
YYMAXDEPTH	int
<=	O
yystacksize	long
)	O
goto	O
yyexhaustedlab	O
;	O
yystacksize	long
*=	O
2	int
;	O
if	O
(	O
YYMAXDEPTH	int
<	O
yystacksize	long
)	O
yystacksize	long
=	O
YYMAXDEPTH	int
;	O
{	O
yytype_int16	short
*	O
yyss1	pointer
=	O
yyss	pointer
;	O
union	O
mu_cfg_yyalloc	union
*	O
yyptr	pointer
=	O
(	O
union	O
mu_cfg_yyalloc	union
*	O
)	O
YYSTACK_ALLOC	O
(	O
YYSTACK_BYTES	O
(	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
!	O
yyptr	pointer
)	O
goto	O
yyexhaustedlab	O
;	O
YYSTACK_RELOCATE	O
(	O
yyss_alloc	short
,	O
yyss	pointer
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyvs_alloc	union
,	O
yyvs	pointer
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyls_alloc	struct
,	O
yyls	pointer
)	O
;	O
if	O
(	O
yyss1	pointer
!=	O
yyssa	array
)	O
YYSTACK_FREE	O
(	O
yyss1	pointer
)	O
;	O
}	O
yyssp	pointer
=	O
yyss	pointer
+	O
yysize	long
-	O
1	int
;	O
yyvsp	pointer
=	O
yyvs	pointer
+	O
yysize	long
-	O
1	int
;	O
yylsp	pointer
=	O
yyls	pointer
+	O
yysize	long
-	O
1	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Stack size increased to %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
int	O
)	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
yyss	pointer
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	pointer
)	O
YYABORT	O
;	O
}	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Entering state %d\n"	pointer
,	O
mu_cfg_yystate	int
)	O
)	O
;	O
if	O
(	O
mu_cfg_yystate	int
==	O
YYFINAL	int
)	O
YYACCEPT	O
;	O
goto	O
yybackup	O
;	O
yybackup	O
:	O
yyn	int
=	O
mu_cfg_yypact	array
[	O
mu_cfg_yystate	int
]	O
;	O
if	O
(	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
goto	O
yydefault	O
;	O
if	O
(	O
mu_cfg_yychar	int
==	O
YYEMPTY	O
)	O
{	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Reading a token: "	pointer
)	O
)	O
;	O
mu_cfg_yychar	int
=	O
YYLEX	O
;	O
}	O
if	O
(	O
mu_cfg_yychar	int
<=	O
YYEOF	int
)	O
{	O
mu_cfg_yychar	int
=	O
yytoken	int
=	O
YYEOF	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Now at end of input.\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
mu_cfg_yychar	int
)	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Next token is"	pointer
,	O
yytoken	int
,	O
&	O
mu_cfg_yylval	union
,	O
&	O
mu_cfg_yylloc	struct
)	O
;	O
}	O
yyn	int
+=	O
yytoken	int
;	O
if	O
(	O
yyn	int
<	O
0	int
||	O
YYLAST	int
<	O
yyn	int
||	O
mu_cfg_yycheck	array
[	O
yyn	int
]	O
!=	O
yytoken	int
)	O
goto	O
yydefault	O
;	O
yyn	int
=	O
mu_cfg_yytable	array
[	O
yyn	int
]	O
;	O
if	O
(	O
yyn	int
<=	O
0	int
)	O
{	O
if	O
(	O
yytable_value_is_error	O
(	O
yyn	int
)	O
)	O
goto	O
yyerrlab	O
;	O
yyn	int
=	O
-	O
yyn	int
;	O
goto	O
yyreduce	O
;	O
}	O
if	O
(	O
yyerrstatus	int
)	O
yyerrstatus	int
--	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	pointer
,	O
yytoken	int
,	O
&	O
mu_cfg_yylval	union
,	O
&	O
mu_cfg_yylloc	struct
)	O
;	O
mu_cfg_yychar	int
=	O
YYEMPTY	O
;	O
mu_cfg_yystate	int
=	O
yyn	int
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	pointer
=	O
mu_cfg_yylval	union
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
*	O
++	O
yylsp	pointer
=	O
mu_cfg_yylloc	struct
;	O
goto	O
yynewstate	O
;	O
yydefault	O
:	O
yyn	int
=	O
yydefact	array
[	O
mu_cfg_yystate	int
]	O
;	O
if	O
(	O
yyn	int
==	O
0	int
)	O
goto	O
yyerrlab	O
;	O
goto	O
yyreduce	O
;	O
yyreduce	O
:	O
mu_cfg_yylen	int
=	O
mu_cfg_yyr2	array
[	O
yyn	int
]	O
;	O
mu_cfg_yyval	union
=	O
yyvsp	pointer
[	O
1	int
-	O
mu_cfg_yylen	int
]	O
;	O
YYLLOC_DEFAULT	O
(	O
yyloc	struct
,	O
(	O
yylsp	pointer
-	O
mu_cfg_yylen	int
)	O
,	O
mu_cfg_yylen	int
)	O
;	O
YY_REDUCE_PRINT	O
(	O
yyn	int
)	O
;	O
switch	O
(	O
yyn	int
)	O
{	O
case	O
2	int
:	O
{	O
parse_node_list	pointer
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
nodelist	pointer
)	O
;	O
}	O
break	O
;	O
case	O
3	int
:	O
{	O
mu_cfg_create_node_list	function
(	O
&	O
(	O
mu_cfg_yyval	union
.	O
nodelist	pointer
)	O
)	O
;	O
mu_list_append	function
(	O
(	O
mu_cfg_yyval	union
.	O
nodelist	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
pnode	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
4	int
:	O
{	O
mu_list_append	function
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
nodelist	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
pnode	pointer
)	O
)	O
;	O
(	O
mu_cfg_yyval	union
.	O
nodelist	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
nodelist	pointer
)	O
;	O
debug_print_node	function
(	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
pnode	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
7	int
:	O
{	O
struct	O
mu_locus_range	struct
lr	pointer
;	O
lr	pointer
.	O
beg	struct
=	O
(	O
yylsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
beg	struct
;	O
lr	pointer
.	O
end	struct
=	O
(	O
yylsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
)	O
.	O
end	struct
;	O
(	O
mu_cfg_yyval	union
.	O
pnode	pointer
)	O
=	O
mu_cfg_alloc_node	function
(	O
mu_cfg_node_param	int
,	O
&	O
lr	pointer
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
string	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
pvalue	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
8	int
:	O
{	O
struct	O
mu_locus_range	struct
lr	pointer
;	O
lr	pointer
.	O
beg	struct
=	O
(	O
yylsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
5	int
)	O
]	O
)	O
.	O
beg	struct
;	O
lr	pointer
.	O
end	struct
=	O
(	O
yylsp	pointer
[	O
(	O
5	int
)	O
-	O
(	O
5	int
)	O
]	O
)	O
.	O
end	struct
;	O
(	O
mu_cfg_yyval	union
.	O
pnode	pointer
)	O
=	O
mu_cfg_alloc_node	function
(	O
mu_cfg_node_statement	int
,	O
&	O
lr	pointer
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
string	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
pvalue	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
9	int
:	O
{	O
struct	O
mu_locus_range	struct
lr	pointer
;	O
lr	pointer
.	O
beg	struct
=	O
(	O
yylsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
6	int
)	O
]	O
)	O
.	O
beg	struct
;	O
lr	pointer
.	O
end	struct
=	O
(	O
yylsp	pointer
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
)	O
.	O
end	struct
;	O
(	O
mu_cfg_yyval	union
.	O
pnode	pointer
)	O
=	O
mu_cfg_alloc_node	function
(	O
mu_cfg_node_statement	int
,	O
&	O
lr	pointer
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
string	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
pvalue	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
4	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
nodelist	pointer
)	O
)	O
;	O
mu_list_foreach	function
(	O
(	O
yyvsp	pointer
[	O
(	O
4	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
nodelist	pointer
)	O
,	O
_node_set_parent	function
,	O
(	O
mu_cfg_yyval	union
.	O
pnode	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
11	int
:	O
{	O
(	O
mu_cfg_yyval	union
.	O
pvalue	pointer
)	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
13	int
:	O
{	O
size_t	long
n	long
=	O
0	int
;	O
mu_list_count	function
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	pointer
)	O
,	O
&	O
n	long
)	O
;	O
if	O
(	O
n	long
==	O
1	int
)	O
{	O
mu_list_get	function
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	pointer
)	O
,	O
0	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
(	O
mu_cfg_yyval	union
.	O
pvalue	pointer
)	O
)	O
;	O
}	O
else	O
{	O
size_t	long
i	long
;	O
mu_config_value_t	struct
val	array
;	O
val	array
.	O
type	pointer
=	O
MU_CFG_ARRAY	int
;	O
val	array
.	O
v	pointer
.	O
arg	pointer
.	O
c	int
=	O
n	long
;	O
val	array
.	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
=	O
mu_alloc	function
(	O
n	long
*	O
sizeof	O
(	O
val	array
.	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
val	array
.	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
)	O
{	O
mu_error	function
(	O
_	O
(	O
"not enough memory"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
{	O
mu_config_value_t	struct
*	O
v	pointer
;	O
mu_list_get	function
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	pointer
)	O
,	O
i	long
,	O
(	O
void	O
*	O
*	O
)	O
&	O
v	pointer
)	O
;	O
val	array
.	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
[	O
i	long
]	O
=	O
*	O
v	pointer
;	O
}	O
(	O
mu_cfg_yyval	union
.	O
pvalue	pointer
)	O
=	O
config_value_dup	function
(	O
&	O
val	array
)	O
;	O
}	O
mu_list_destroy	function
(	O
&	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
14	int
:	O
{	O
int	O
rc	int
=	O
mu_list_create	function
(	O
&	O
(	O
mu_cfg_yyval	union
.	O
list	pointer
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot create list: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
mu_list_append	function
(	O
(	O
mu_cfg_yyval	union
.	O
list	pointer
)	O
,	O
config_value_dup	function
(	O
&	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
value	struct
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
15	int
:	O
{	O
mu_list_append	function
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
list	pointer
)	O
,	O
config_value_dup	function
(	O
&	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
value	struct
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
16	int
:	O
{	O
(	O
mu_cfg_yyval	union
.	O
value	struct
)	O
.	O
type	pointer
=	O
MU_CFG_STRING	int
;	O
(	O
mu_cfg_yyval	union
.	O
value	struct
)	O
.	O
v	pointer
.	O
string	pointer
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	pointer
)	O
;	O
}	O
break	O
;	O
case	O
17	int
:	O
{	O
(	O
mu_cfg_yyval	union
.	O
value	struct
)	O
.	O
type	pointer
=	O
MU_CFG_LIST	int
;	O
(	O
mu_cfg_yyval	union
.	O
value	struct
)	O
.	O
v	pointer
.	O
list	pointer
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	pointer
)	O
;	O
}	O
break	O
;	O
case	O
18	int
:	O
{	O
(	O
mu_cfg_yyval	union
.	O
value	struct
)	O
.	O
type	pointer
=	O
MU_CFG_STRING	int
;	O
(	O
mu_cfg_yyval	union
.	O
value	struct
)	O
.	O
v	pointer
.	O
string	pointer
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	pointer
)	O
;	O
}	O
break	O
;	O
case	O
22	int
:	O
{	O
mu_iterator_t	pointer
itr	pointer
;	O
mu_list_get_iterator	function
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	pointer
)	O
,	O
&	O
itr	pointer
)	O
;	O
_mu_line_begin	function
(	O
)	O
;	O
for	O
(	O
mu_iterator_first	function
(	O
itr	pointer
)	O
;	O
!	O
mu_iterator_is_done	function
(	O
itr	pointer
)	O
;	O
mu_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
char	O
*	O
p	pointer
;	O
mu_iterator_current	function
(	O
itr	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
p	pointer
)	O
;	O
_mu_line_add	function
(	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
)	O
;	O
}	O
(	O
mu_cfg_yyval	union
.	O
string	pointer
)	O
=	O
_mu_line_finish	function
(	O
)	O
;	O
mu_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
mu_list_destroy	function
(	O
&	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
list	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
23	int
:	O
{	O
mu_list_create	function
(	O
&	O
(	O
mu_cfg_yyval	union
.	O
list	pointer
)	O
)	O
;	O
mu_list_append	function
(	O
(	O
mu_cfg_yyval	union
.	O
list	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
string	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
24	int
:	O
{	O
mu_list_append	function
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
list	pointer
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
string	pointer
)	O
)	O
;	O
(	O
mu_cfg_yyval	union
.	O
list	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
list	pointer
)	O
;	O
}	O
break	O
;	O
case	O
25	int
:	O
{	O
(	O
mu_cfg_yyval	union
.	O
list	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
list	pointer
)	O
;	O
}	O
break	O
;	O
case	O
26	int
:	O
{	O
(	O
mu_cfg_yyval	union
.	O
list	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
list	pointer
)	O
;	O
}	O
break	O
;	O
case	O
27	int
:	O
{	O
mu_list_create	function
(	O
&	O
(	O
mu_cfg_yyval	union
.	O
list	pointer
)	O
)	O
;	O
mu_list_append	function
(	O
(	O
mu_cfg_yyval	union
.	O
list	pointer
)	O
,	O
config_value_dup	function
(	O
&	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
value	struct
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
28	int
:	O
{	O
mu_list_append	function
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
list	pointer
)	O
,	O
config_value_dup	function
(	O
&	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
value	struct
)	O
)	O
)	O
;	O
(	O
mu_cfg_yyval	union
.	O
list	pointer
)	O
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
list	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_SYMBOL_PRINT	O
(	O
"-> $$ ="	pointer
,	O
mu_cfg_yyr1	array
[	O
yyn	int
]	O
,	O
&	O
mu_cfg_yyval	union
,	O
&	O
yyloc	struct
)	O
;	O
YYPOPSTACK	O
(	O
mu_cfg_yylen	int
)	O
;	O
mu_cfg_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
*	O
++	O
yyvsp	pointer
=	O
mu_cfg_yyval	union
;	O
*	O
++	O
yylsp	pointer
=	O
yyloc	struct
;	O
yyn	int
=	O
mu_cfg_yyr1	array
[	O
yyn	int
]	O
;	O
mu_cfg_yystate	int
=	O
yypgoto	array
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
+	O
*	O
yyssp	pointer
;	O
if	O
(	O
0	int
<=	O
mu_cfg_yystate	int
&&	O
mu_cfg_yystate	int
<=	O
YYLAST	int
&&	O
mu_cfg_yycheck	array
[	O
mu_cfg_yystate	int
]	O
==	O
*	O
yyssp	pointer
)	O
mu_cfg_yystate	int
=	O
mu_cfg_yytable	array
[	O
mu_cfg_yystate	int
]	O
;	O
else	O
mu_cfg_yystate	int
=	O
yydefgoto	array
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
;	O
goto	O
yynewstate	O
;	O
yyerrlab	O
:	O
yytoken	int
=	O
mu_cfg_yychar	int
==	O
YYEMPTY	O
?	O
YYEMPTY	O
:	O
YYTRANSLATE	O
(	O
mu_cfg_yychar	int
)	O
;	O
if	O
(	O
!	O
yyerrstatus	int
)	O
{	O
++	O
mu_cfg_yynerrs	int
;	O
mu_cfg_yyerror	function
(	O
YY_	O
(	O
"syntax error"	pointer
)	O
)	O
;	O
}	O
yyerror_range	array
[	O
1	int
]	O
=	O
mu_cfg_yylloc	struct
;	O
if	O
(	O
yyerrstatus	int
==	O
3	int
)	O
{	O
if	O
(	O
mu_cfg_yychar	int
<=	O
YYEOF	int
)	O
{	O
if	O
(	O
mu_cfg_yychar	int
==	O
YYEOF	int
)	O
YYABORT	O
;	O
}	O
else	O
{	O
yydestruct	function
(	O
"Error: discarding"	pointer
,	O
yytoken	int
,	O
&	O
mu_cfg_yylval	union
,	O
&	O
mu_cfg_yylloc	struct
)	O
;	O
mu_cfg_yychar	int
=	O
YYEMPTY	O
;	O
}	O
}	O
goto	O
yyerrlab1	O
;	O
yyerrorlab	O
:	O
if	O
(	O
0	int
)	O
goto	O
yyerrorlab	O
;	O
yyerror_range	array
[	O
1	int
]	O
=	O
yylsp	pointer
[	O
1	int
-	O
mu_cfg_yylen	int
]	O
;	O
YYPOPSTACK	O
(	O
mu_cfg_yylen	int
)	O
;	O
mu_cfg_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
mu_cfg_yystate	int
=	O
*	O
yyssp	pointer
;	O
goto	O
yyerrlab1	O
;	O
yyerrlab1	O
:	O
yyerrstatus	int
=	O
3	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
yyn	int
=	O
mu_cfg_yypact	array
[	O
mu_cfg_yystate	int
]	O
;	O
if	O
(	O
!	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
{	O
yyn	int
+=	O
YYTERROR	int
;	O
if	O
(	O
0	int
<=	O
yyn	int
&&	O
yyn	int
<=	O
YYLAST	int
&&	O
mu_cfg_yycheck	array
[	O
yyn	int
]	O
==	O
YYTERROR	int
)	O
{	O
yyn	int
=	O
mu_cfg_yytable	array
[	O
yyn	int
]	O
;	O
if	O
(	O
0	int
<	O
yyn	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
yyssp	pointer
==	O
yyss	pointer
)	O
YYABORT	O
;	O
yyerror_range	array
[	O
1	int
]	O
=	O
*	O
yylsp	pointer
;	O
yydestruct	function
(	O
"Error: popping"	pointer
,	O
yystos	array
[	O
mu_cfg_yystate	int
]	O
,	O
yyvsp	pointer
,	O
yylsp	pointer
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
mu_cfg_yystate	int
=	O
*	O
yyssp	pointer
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
}	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	pointer
=	O
mu_cfg_yylval	union
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
yyerror_range	array
[	O
2	int
]	O
=	O
mu_cfg_yylloc	struct
;	O
YYLLOC_DEFAULT	O
(	O
yyloc	struct
,	O
yyerror_range	array
,	O
2	int
)	O
;	O
*	O
++	O
yylsp	pointer
=	O
yyloc	struct
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	pointer
,	O
yystos	array
[	O
yyn	int
]	O
,	O
yyvsp	pointer
,	O
yylsp	pointer
)	O
;	O
mu_cfg_yystate	int
=	O
yyn	int
;	O
goto	O
yynewstate	O
;	O
yyacceptlab	O
:	O
yyresult	int
=	O
0	int
;	O
goto	O
yyreturn	O
;	O
yyabortlab	O
:	O
yyresult	int
=	O
1	int
;	O
goto	O
yyreturn	O
;	O
yyexhaustedlab	O
:	O
mu_cfg_yyerror	function
(	O
YY_	O
(	O
"memory exhausted"	pointer
)	O
)	O
;	O
yyresult	int
=	O
2	int
;	O
yyreturn	O
:	O
if	O
(	O
mu_cfg_yychar	int
!=	O
YYEMPTY	O
)	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
mu_cfg_yychar	int
)	O
;	O
yydestruct	function
(	O
"Cleanup: discarding lookahead"	pointer
,	O
yytoken	int
,	O
&	O
mu_cfg_yylval	union
,	O
&	O
mu_cfg_yylloc	struct
)	O
;	O
}	O
YYPOPSTACK	O
(	O
mu_cfg_yylen	int
)	O
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
while	O
(	O
yyssp	pointer
!=	O
yyss	pointer
)	O
{	O
yydestruct	function
(	O
"Cleanup: popping"	pointer
,	O
yystos	array
[	O
*	O
yyssp	pointer
]	O
,	O
yyvsp	pointer
,	O
yylsp	pointer
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
yyss	pointer
!=	O
yyssa	array
)	O
YYSTACK_FREE	O
(	O
yyss	pointer
)	O
;	O
return	O
YYID	O
(	O
yyresult	int
)	O
;	O
}	O
void	O
mu_cfg_set_debug	function
(	O
)	O
{	O
if	O
(	O
mu_debug_level_p	function
(	O
MU_DEBCAT_CONFIG	int
,	O
MU_DEBUG_TRACE7	int
)	O
)	O
mu_cfg_yydebug	int
=	O
1	int
;	O
}	O
int	O
mu_cfg_parse	function
(	O
mu_cfg_tree_t	struct
*	O
*	O
ptree	pointer
)	O
{	O
int	O
rc	int
;	O
mu_cfg_tree_t	struct
*	O
tree	pointer
;	O
mu_opool_t	pointer
pool	pointer
;	O
int	O
save_mode	int
=	O
0	int
,	O
mode	int
;	O
struct	O
mu_locus_range	struct
save_locus	struct
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_GET_MODE	int
,	O
&	O
save_mode	int
)	O
;	O
mode	int
=	O
save_mode	int
|	O
MU_LOGMODE_LOCUS	int
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
mode	int
)	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_GET_LOCUS_RANGE	int
,	O
&	O
save_locus	struct
)	O
;	O
mu_cfg_set_debug	function
(	O
)	O
;	O
_mu_cfg_errcnt	int
=	O
0	int
;	O
rc	int
=	O
mu_cfg_yyparse	function
(	O
)	O
;	O
pool	pointer
=	O
mu_cfg_lexer_pool	function
(	O
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
&&	O
_mu_cfg_errcnt	int
)	O
{	O
mu_opool_destroy	function
(	O
&	O
pool	pointer
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
{	O
tree	pointer
=	O
mu_alloc	function
(	O
sizeof	O
(	O
*	O
tree	pointer
)	O
)	O
;	O
tree	pointer
->	O
nodes	pointer
=	O
parse_node_list	pointer
;	O
tree	pointer
->	O
pool	pointer
=	O
pool	pointer
;	O
parse_node_list	pointer
=	O
NULL	O
;	O
*	O
ptree	pointer
=	O
tree	pointer
;	O
}	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
save_mode	int
)	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
&	O
save_locus	struct
)	O
;	O
mu_locus_range_deinit	function
(	O
&	O
save_locus	struct
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
mu_cfg_tree_union	function
(	O
mu_cfg_tree_t	struct
*	O
*	O
pa	pointer
,	O
mu_cfg_tree_t	struct
*	O
*	O
pb	pointer
)	O
{	O
mu_cfg_tree_t	struct
*	O
a	pointer
,	O
*	O
b	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
!	O
pb	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
*	O
pb	pointer
)	O
return	O
0	int
;	O
b	pointer
=	O
*	O
pb	pointer
;	O
if	O
(	O
!	O
pa	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
!	O
*	O
pa	pointer
)	O
{	O
*	O
pa	pointer
=	O
b	pointer
;	O
*	O
pb	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
else	O
a	pointer
=	O
*	O
pa	pointer
;	O
rc	int
=	O
mu_opool_union	function
(	O
&	O
b	pointer
->	O
pool	pointer
,	O
&	O
a	pointer
->	O
pool	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
b	pointer
->	O
nodes	pointer
)	O
{	O
mu_list_append_list	function
(	O
a	pointer
->	O
nodes	pointer
,	O
b	pointer
->	O
nodes	pointer
)	O
;	O
mu_list_destroy	function
(	O
&	O
b	pointer
->	O
nodes	pointer
)	O
;	O
}	O
free	function
(	O
b	pointer
)	O
;	O
*	O
pb	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
mu_cfg_tree_t	struct
*	O
do_include	function
(	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
mu_cfg_parse_hints	struct
*	O
hints	pointer
,	O
struct	O
mu_locus_range	struct
const	O
*	O
loc	pointer
)	O
{	O
struct	O
stat	struct
sb	struct
;	O
char	O
*	O
tmpname	pointer
=	O
NULL	O
;	O
mu_cfg_tree_t	struct
*	O
tree	pointer
=	O
NULL	O
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
name	pointer
=	O
tmpname	pointer
=	O
mu_make_file_name	O
(	O
SYSCONFDIR	O
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
{	O
mu_error	function
(	O
"%s"	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
stat	struct
(	O
name	pointer
,	O
&	O
sb	struct
)	O
==	O
0	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
S_ISDIR	O
(	O
sb	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
hints	pointer
->	O
flags	int
&	O
MU_CFHINT_PROGRAM	int
)	O
{	O
char	O
*	O
file	pointer
=	O
mu_make_file_name	O
(	O
name	pointer
,	O
hints	pointer
->	O
program	pointer
)	O
;	O
rc	int
=	O
mu_cfg_parse_file	function
(	O
&	O
tree	pointer
,	O
file	pointer
,	O
hints	pointer
->	O
flags	int
)	O
;	O
free	function
(	O
file	pointer
)	O
;	O
}	O
else	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_WARNING	int
,	O
loc	pointer
,	O
_	O
(	O
"ignoring `include': directory argument is allowed only from the top-level configuration file"	pointer
)	O
)	O
;	O
}	O
}	O
else	O
rc	int
=	O
mu_cfg_parse_file	function
(	O
&	O
tree	pointer
,	O
name	pointer
,	O
hints	pointer
->	O
flags	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
&&	O
tree	pointer
)	O
{	O
struct	O
mu_cfg_parse_hints	struct
xhints	struct
=	O
*	O
hints	pointer
;	O
xhints	struct
.	O
flags	int
&=	O
~	O
MU_CFHINT_PROGRAM	int
;	O
mu_cfg_tree_postprocess	function
(	O
tree	pointer
,	O
&	O
xhints	struct
)	O
;	O
}	O
}	O
else	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
loc	pointer
,	O
_	O
(	O
"include file or directory does not exist"	pointer
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
}	O
else	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
loc	pointer
,	O
_	O
(	O
"cannot stat include file or directory: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
}	O
free	function
(	O
tmpname	pointer
)	O
;	O
return	O
tree	pointer
;	O
}	O
int	O
mu_cfg_tree_postprocess	function
(	O
mu_cfg_tree_t	struct
*	O
tree	pointer
,	O
struct	O
mu_cfg_parse_hints	struct
*	O
hints	pointer
)	O
{	O
int	O
rc	int
;	O
mu_iterator_t	pointer
itr	pointer
;	O
if	O
(	O
!	O
tree	pointer
->	O
nodes	pointer
)	O
return	O
0	int
;	O
rc	int
=	O
mu_list_get_iterator	function
(	O
tree	pointer
->	O
nodes	pointer
,	O
&	O
itr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
for	O
(	O
mu_iterator_first	function
(	O
itr	pointer
)	O
;	O
!	O
mu_iterator_is_done	function
(	O
itr	pointer
)	O
;	O
mu_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
mu_cfg_node_t	struct
*	O
node	pointer
;	O
mu_iterator_current	function
(	O
itr	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
node	pointer
)	O
;	O
if	O
(	O
node	pointer
->	O
type	pointer
==	O
mu_cfg_node_statement	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
node	pointer
->	O
tag	pointer
,	O
"program"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
hints	pointer
->	O
flags	int
&	O
MU_CFHINT_PROGRAM	int
)	O
{	O
if	O
(	O
node	pointer
->	O
label	pointer
->	O
type	pointer
==	O
MU_CFG_STRING	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
node	pointer
->	O
label	pointer
->	O
v	pointer
.	O
string	pointer
,	O
hints	pointer
->	O
program	pointer
)	O
==	O
0	int
)	O
{	O
mu_list_foreach	function
(	O
node	pointer
->	O
nodes	pointer
,	O
_node_set_parent	function
,	O
node	pointer
->	O
parent	pointer
)	O
;	O
mu_iterator_ctl	function
(	O
itr	pointer
,	O
mu_itrctl_insert_list	int
,	O
node	pointer
->	O
nodes	pointer
)	O
;	O
mu_iterator_ctl	function
(	O
itr	pointer
,	O
mu_itrctl_delete	int
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"argument to `program' is not a string"	pointer
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
mu_iterator_ctl	function
(	O
itr	pointer
,	O
mu_itrctl_delete	int
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_WARNING	int
,	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"ignoring `program' block: not located in top-level configuration file"	pointer
)	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
node	pointer
->	O
type	pointer
==	O
mu_cfg_node_param	int
&&	O
strcmp	function
(	O
node	pointer
->	O
tag	pointer
,	O
"include"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
node	pointer
->	O
label	pointer
->	O
type	pointer
==	O
MU_CFG_STRING	int
)	O
{	O
mu_cfg_tree_t	struct
*	O
t	pointer
=	O
do_include	function
(	O
node	pointer
->	O
label	pointer
->	O
v	pointer
.	O
string	pointer
,	O
hints	pointer
,	O
&	O
node	pointer
->	O
locus	struct
)	O
;	O
if	O
(	O
t	pointer
)	O
{	O
mu_iterator_ctl	function
(	O
itr	pointer
,	O
mu_itrctl_insert_list	int
,	O
t	pointer
->	O
nodes	pointer
)	O
;	O
mu_opool_union	function
(	O
&	O
tree	pointer
->	O
pool	pointer
,	O
&	O
t	pointer
->	O
pool	pointer
)	O
;	O
mu_cfg_destroy_tree	function
(	O
&	O
t	pointer
)	O
;	O
}	O
}	O
else	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"argument to `include' is not a string"	pointer
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
}	O
mu_iterator_ctl	function
(	O
itr	pointer
,	O
mu_itrctl_delete	int
,	O
NULL	O
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_mu_cfg_preorder_recursive	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
cbdata	pointer
)	O
{	O
mu_cfg_node_t	struct
*	O
node	pointer
=	O
item	pointer
;	O
struct	O
mu_cfg_iter_closure	struct
*	O
clos	pointer
=	O
cbdata	pointer
;	O
int	O
rc	int
;	O
switch	O
(	O
node	pointer
->	O
type	pointer
)	O
{	O
case	O
mu_cfg_node_undefined	int
:	O
abort	function
(	O
)	O
;	O
case	O
mu_cfg_node_statement	int
:	O
switch	O
(	O
clos	pointer
->	O
beg	struct
(	O
node	pointer
,	O
clos	pointer
->	O
data	pointer
)	O
)	O
{	O
case	O
MU_CFG_ITER_OK	int
:	O
rc	int
=	O
mu_cfg_preorder	function
(	O
node	pointer
->	O
nodes	pointer
,	O
clos	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
clos	pointer
->	O
end	struct
&&	O
clos	pointer
->	O
end	struct
(	O
node	pointer
,	O
clos	pointer
->	O
data	pointer
)	O
==	O
MU_CFG_ITER_STOP	int
)	O
return	O
MU_ERR_USER0	O
;	O
break	O
;	O
case	O
MU_CFG_ITER_SKIP	int
:	O
break	O
;	O
case	O
MU_CFG_ITER_STOP	int
:	O
return	O
MU_ERR_USER0	O
;	O
}	O
break	O
;	O
case	O
mu_cfg_node_param	int
:	O
if	O
(	O
clos	pointer
->	O
beg	struct
(	O
node	pointer
,	O
clos	pointer
->	O
data	pointer
)	O
==	O
MU_CFG_ITER_STOP	int
)	O
return	O
MU_ERR_USER0	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mu_cfg_preorder	function
(	O
mu_list_t	pointer
nodelist	pointer
,	O
struct	O
mu_cfg_iter_closure	struct
*	O
clos	pointer
)	O
{	O
if	O
(	O
!	O
nodelist	pointer
)	O
return	O
0	int
;	O
return	O
mu_list_foreach	function
(	O
nodelist	pointer
,	O
_mu_cfg_preorder_recursive	function
,	O
clos	pointer
)	O
;	O
}	O
void	O
mu_cfg_destroy_tree	function
(	O
mu_cfg_tree_t	struct
*	O
*	O
ptree	pointer
)	O
{	O
if	O
(	O
ptree	pointer
&&	O
*	O
ptree	pointer
)	O
{	O
mu_cfg_tree_t	struct
*	O
tree	pointer
=	O
*	O
ptree	pointer
;	O
mu_list_destroy	function
(	O
&	O
tree	pointer
->	O
nodes	pointer
)	O
;	O
mu_opool_destroy	function
(	O
&	O
tree	pointer
->	O
pool	pointer
)	O
;	O
*	O
ptree	pointer
=	O
NULL	O
;	O
}	O
}	O
struct	O
mu_cfg_section_list	struct
{	O
struct	O
mu_cfg_section_list	struct
*	O
next	pointer
;	O
struct	O
mu_cfg_section	int
*	O
sec	pointer
;	O
}	O
;	O
struct	O
scan_tree_data	struct
{	O
struct	O
mu_cfg_section_list	struct
*	O
list	pointer
;	O
void	O
*	O
target	pointer
;	O
void	O
*	O
call_data	pointer
;	O
mu_cfg_tree_t	struct
*	O
tree	pointer
;	O
int	O
error	int
;	O
}	O
;	O
static	O
struct	O
mu_cfg_cont	struct
*	O
find_container	function
(	O
mu_list_t	pointer
list	pointer
,	O
enum	O
mu_cfg_cont_type	enum
type	pointer
,	O
const	O
char	O
*	O
ident	pointer
,	O
size_t	long
len	long
)	O
{	O
mu_iterator_t	pointer
iter	pointer
;	O
struct	O
mu_cfg_cont	struct
*	O
ret	pointer
=	O
NULL	O
;	O
if	O
(	O
len	long
==	O
0	int
)	O
len	long
=	O
strlen	function
(	O
ident	pointer
)	O
;	O
mu_list_get_iterator	function
(	O
list	pointer
,	O
&	O
iter	pointer
)	O
;	O
for	O
(	O
mu_iterator_first	function
(	O
iter	pointer
)	O
;	O
!	O
mu_iterator_is_done	function
(	O
iter	pointer
)	O
;	O
mu_iterator_next	function
(	O
iter	pointer
)	O
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
;	O
mu_iterator_current	function
(	O
iter	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cont	pointer
)	O
;	O
if	O
(	O
cont	pointer
->	O
type	pointer
==	O
type	pointer
&&	O
strlen	function
(	O
cont	pointer
->	O
v	pointer
.	O
ident	pointer
)	O
==	O
len	long
&&	O
memcmp	function
(	O
cont	pointer
->	O
v	pointer
.	O
ident	pointer
,	O
ident	pointer
,	O
len	long
)	O
==	O
0	int
)	O
{	O
ret	pointer
=	O
cont	pointer
;	O
break	O
;	O
}	O
}	O
mu_iterator_destroy	function
(	O
&	O
iter	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
struct	O
mu_cfg_section	int
*	O
find_subsection	function
(	O
struct	O
mu_cfg_section	int
*	O
sec	pointer
,	O
const	O
char	O
*	O
ident	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
children	pointer
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
=	O
find_container	function
(	O
sec	pointer
->	O
children	pointer
,	O
mu_cfg_cont_section	int
,	O
ident	pointer
,	O
len	long
)	O
;	O
if	O
(	O
cont	pointer
)	O
return	O
&	O
cont	pointer
->	O
v	pointer
.	O
section	struct
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
mu_cfg_param	struct
*	O
find_param	function
(	O
struct	O
mu_cfg_section	int
*	O
sec	pointer
,	O
const	O
char	O
*	O
ident	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
sec	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
children	pointer
)	O
{	O
struct	O
mu_cfg_cont	struct
*	O
cont	pointer
=	O
find_container	function
(	O
sec	pointer
->	O
children	pointer
,	O
mu_cfg_cont_param	int
,	O
ident	pointer
,	O
len	long
)	O
;	O
if	O
(	O
cont	pointer
)	O
return	O
&	O
cont	pointer
->	O
v	pointer
.	O
param	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
push_section	function
(	O
struct	O
scan_tree_data	struct
*	O
dat	pointer
,	O
struct	O
mu_cfg_section	int
*	O
sec	pointer
)	O
{	O
struct	O
mu_cfg_section_list	struct
*	O
p	pointer
=	O
mu_alloc	function
(	O
sizeof	O
*	O
p	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
mu_error	function
(	O
_	O
(	O
"not enough memory"	pointer
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
p	pointer
->	O
sec	pointer
=	O
sec	pointer
;	O
p	pointer
->	O
next	pointer
=	O
dat	pointer
->	O
list	pointer
;	O
dat	pointer
->	O
list	pointer
=	O
p	pointer
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
mu_cfg_section	int
*	O
pop_section	function
(	O
struct	O
scan_tree_data	struct
*	O
dat	pointer
)	O
{	O
struct	O
mu_cfg_section_list	struct
*	O
p	pointer
=	O
dat	pointer
->	O
list	pointer
;	O
struct	O
mu_cfg_section	int
*	O
sec	pointer
=	O
p	pointer
->	O
sec	pointer
;	O
dat	pointer
->	O
list	pointer
=	O
p	pointer
->	O
next	pointer
;	O
free	function
(	O
p	pointer
)	O
;	O
return	O
sec	pointer
;	O
}	O
static	O
int	O
valcvt	function
(	O
const	O
struct	O
mu_locus_range	struct
*	O
locus	struct
,	O
void	O
*	O
tgt	pointer
,	O
mu_c_type_t	enum
type	pointer
,	O
mu_config_value_t	struct
*	O
val	array
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
errmsg	pointer
;	O
if	O
(	O
val	array
->	O
type	pointer
!=	O
MU_CFG_STRING	int
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
locus	struct
,	O
_	O
(	O
"expected string value"	pointer
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
rc	int
=	O
mu_str_to_c	function
(	O
val	array
->	O
v	pointer
.	O
string	pointer
,	O
type	pointer
,	O
tgt	pointer
,	O
&	O
errmsg	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
locus	struct
,	O
"%s"	pointer
,	O
errmsg	pointer
?	O
errmsg	pointer
:	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
free	function
(	O
errmsg	pointer
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
struct	O
set_closure	struct
{	O
mu_list_t	pointer
list	pointer
;	O
int	O
type	pointer
;	O
struct	O
scan_tree_data	struct
*	O
sdata	pointer
;	O
const	O
struct	O
mu_locus_range	struct
*	O
locus	struct
;	O
}	O
;	O
static	O
size_t	long
config_type_size	array
[	O
]	O
=	O
{	O
[	O
mu_c_string	int
]	O
=	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
[	O
mu_c_short	int
]	O
=	O
sizeof	O
(	O
short	O
)	O
,	O
[	O
mu_c_ushort	int
]	O
=	O
sizeof	O
(	O
unsigned	O
short	O
)	O
,	O
[	O
mu_c_int	int
]	O
=	O
sizeof	O
(	O
int	O
)	O
,	O
[	O
mu_c_uint	int
]	O
=	O
sizeof	O
(	O
unsigned	O
)	O
,	O
[	O
mu_c_long	int
]	O
=	O
sizeof	O
(	O
long	O
)	O
,	O
[	O
mu_c_ulong	int
]	O
=	O
sizeof	O
(	O
unsigned	O
long	O
)	O
,	O
[	O
mu_c_size	int
]	O
=	O
sizeof	O
(	O
size_t	long
)	O
,	O
[	O
mu_c_time	int
]	O
=	O
sizeof	O
(	O
time_t	long
)	O
,	O
[	O
mu_c_bool	int
]	O
=	O
sizeof	O
(	O
int	O
)	O
,	O
[	O
mu_c_ipv4	int
]	O
=	O
sizeof	O
(	O
struct	O
in_addr	struct
)	O
,	O
[	O
mu_c_cidr	int
]	O
=	O
sizeof	O
(	O
struct	O
mu_cidr	struct
)	O
,	O
[	O
mu_c_host	int
]	O
=	O
sizeof	O
(	O
struct	O
in_addr	struct
)	O
,	O
}	O
;	O
static	O
int	O
_set_fun	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
mu_config_value_t	struct
*	O
val	array
=	O
item	pointer
;	O
struct	O
set_closure	struct
*	O
clos	pointer
=	O
data	pointer
;	O
void	O
*	O
tgt	pointer
;	O
size_t	long
size	long
;	O
if	O
(	O
(	O
size_t	long
)	O
clos	pointer
->	O
type	pointer
>=	O
MU_ARRAY_SIZE	O
(	O
config_type_size	array
)	O
||	O
(	O
size	long
=	O
config_type_size	array
[	O
clos	pointer
->	O
type	pointer
]	O
)	O
==	O
0	int
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_EMERG	int
,	O
clos	pointer
->	O
locus	struct
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: unhandled data type %d"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
clos	pointer
->	O
type	pointer
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
tgt	pointer
=	O
mu_alloc	function
(	O
size	long
)	O
;	O
if	O
(	O
!	O
tgt	pointer
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
clos	pointer
->	O
locus	struct
,	O
_	O
(	O
"not enough memory"	pointer
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
valcvt	function
(	O
clos	pointer
->	O
locus	struct
,	O
&	O
tgt	pointer
,	O
clos	pointer
->	O
type	pointer
,	O
val	array
)	O
==	O
0	int
)	O
mu_list_append	function
(	O
clos	pointer
->	O
list	pointer
,	O
tgt	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_param	function
(	O
struct	O
scan_tree_data	struct
*	O
sdata	pointer
,	O
const	O
mu_cfg_node_t	struct
*	O
node	pointer
)	O
{	O
void	O
*	O
tgt	pointer
;	O
struct	O
set_closure	struct
clos	pointer
;	O
struct	O
mu_cfg_param	struct
*	O
param	pointer
=	O
find_param	function
(	O
sdata	pointer
->	O
list	pointer
->	O
sec	pointer
,	O
node	pointer
->	O
tag	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
param	pointer
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"unknown keyword `%s'"	pointer
)	O
,	O
node	pointer
->	O
tag	pointer
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
param	pointer
->	O
data	pointer
)	O
tgt	pointer
=	O
param	pointer
->	O
data	pointer
;	O
else	O
if	O
(	O
sdata	pointer
->	O
list	pointer
->	O
sec	pointer
->	O
target	pointer
)	O
tgt	pointer
=	O
(	O
char	O
*	O
)	O
sdata	pointer
->	O
list	pointer
->	O
sec	pointer
->	O
target	pointer
+	O
param	pointer
->	O
offset	long
;	O
else	O
if	O
(	O
sdata	pointer
->	O
target	pointer
)	O
tgt	pointer
=	O
(	O
char	O
*	O
)	O
sdata	pointer
->	O
target	pointer
+	O
param	pointer
->	O
offset	long
;	O
else	O
if	O
(	O
param	pointer
->	O
type	pointer
==	O
mu_cfg_callback	int
)	O
tgt	pointer
=	O
NULL	O
;	O
else	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_EMERG	int
,	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"INTERNAL ERROR: cannot determine target offset for "	pointer
"%s"	pointer
)	O
,	O
param	pointer
->	O
ident	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
memset	function
(	O
&	O
clos	pointer
,	O
0	int
,	O
sizeof	O
clos	pointer
)	O
;	O
clos	pointer
.	O
type	pointer
=	O
MU_CFG_TYPE	O
(	O
param	pointer
->	O
type	pointer
)	O
;	O
if	O
(	O
MU_CFG_IS_LIST	O
(	O
param	pointer
->	O
type	pointer
)	O
)	O
{	O
clos	pointer
.	O
sdata	pointer
=	O
sdata	pointer
;	O
clos	pointer
.	O
locus	struct
=	O
&	O
node	pointer
->	O
locus	struct
;	O
switch	O
(	O
node	pointer
->	O
label	pointer
->	O
type	pointer
)	O
{	O
case	O
MU_CFG_LIST	int
:	O
break	O
;	O
case	O
MU_CFG_STRING	int
:	O
{	O
mu_list_t	pointer
list	pointer
;	O
mu_list_create	function
(	O
&	O
list	pointer
)	O
;	O
mu_list_append	function
(	O
list	pointer
,	O
config_value_dup	function
(	O
node	pointer
->	O
label	pointer
)	O
)	O
;	O
node	pointer
->	O
label	pointer
->	O
type	pointer
=	O
MU_CFG_LIST	int
;	O
node	pointer
->	O
label	pointer
->	O
v	pointer
.	O
list	pointer
=	O
list	pointer
;	O
}	O
break	O
;	O
case	O
MU_CFG_ARRAY	int
:	O
mu_diag_at_locus_range	function
(	O
MU_LOG_ERROR	int
,	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"expected list, but found array"	pointer
)	O
)	O
;	O
mu_cfg_error_count	long
++	O
;	O
return	O
1	int
;	O
}	O
mu_list_create	function
(	O
&	O
clos	pointer
.	O
list	pointer
)	O
;	O
mu_list_foreach	function
(	O
node	pointer
->	O
label	pointer
->	O
v	pointer
.	O
list	pointer
,	O
_set_fun	function
,	O
&	O
clos	pointer
)	O
;	O
*	O
(	O
mu_list_t	pointer
*	O
)	O
tgt	pointer
=	O
clos	pointer
.	O
list	pointer
;	O
}	O
else	O
if	O
(	O
clos	pointer
.	O
type	pointer
==	O
mu_cfg_callback	int
)	O
{	O
if	O
(	O
!	O
param	pointer
->	O
callback	pointer
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_EMERG	int
,	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"INTERNAL ERROR: %s: callback not defined"	pointer
)	O
,	O
node	pointer
->	O
tag	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
(	O
void	O
*	O
)	O
&	O
node	pointer
->	O
locus	struct
)	O
;	O
if	O
(	O
param	pointer
->	O
callback	pointer
(	O
tgt	pointer
,	O
node	pointer
->	O
label	pointer
)	O
)	O
return	O
1	int
;	O
}	O
else	O
return	O
valcvt	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
tgt	pointer
,	O
clos	pointer
.	O
type	pointer
,	O
node	pointer
->	O
label	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_scan_tree_helper	function
(	O
const	O
mu_cfg_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
scan_tree_data	struct
*	O
sdata	pointer
=	O
data	pointer
;	O
struct	O
mu_cfg_section	int
*	O
sec	pointer
;	O
switch	O
(	O
node	pointer
->	O
type	pointer
)	O
{	O
case	O
mu_cfg_node_undefined	int
:	O
abort	function
(	O
)	O
;	O
case	O
mu_cfg_node_statement	int
:	O
sec	pointer
=	O
find_subsection	function
(	O
sdata	pointer
->	O
list	pointer
->	O
sec	pointer
,	O
node	pointer
->	O
tag	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
sec	pointer
)	O
{	O
if	O
(	O
mu_cfg_parser_verbose	int
)	O
{	O
mu_diag_at_locus_range	function
(	O
MU_LOG_WARNING	int
,	O
&	O
node	pointer
->	O
locus	struct
,	O
_	O
(	O
"unknown section `%s'"	pointer
)	O
,	O
node	pointer
->	O
tag	pointer
)	O
;	O
}	O
return	O
MU_CFG_ITER_SKIP	int
;	O
}	O
if	O
(	O
!	O
sec	pointer
->	O
children	pointer
)	O
return	O
MU_CFG_ITER_SKIP	int
;	O
if	O
(	O
sec	pointer
->	O
data	pointer
)	O
sec	pointer
->	O
target	pointer
=	O
sec	pointer
->	O
data	pointer
;	O
else	O
if	O
(	O
sdata	pointer
->	O
list	pointer
->	O
sec	pointer
->	O
target	pointer
)	O
sec	pointer
->	O
target	pointer
=	O
(	O
char	O
*	O
)	O
sdata	pointer
->	O
list	pointer
->	O
sec	pointer
->	O
target	pointer
+	O
sec	pointer
->	O
offset	long
;	O
else	O
if	O
(	O
sdata	pointer
->	O
target	pointer
)	O
sec	pointer
->	O
target	pointer
=	O
(	O
char	O
*	O
)	O
sdata	pointer
->	O
target	pointer
+	O
sec	pointer
->	O
offset	long
;	O
else	O
sec	pointer
->	O
target	pointer
=	O
NULL	O
;	O
if	O
(	O
sec	pointer
->	O
parser	pointer
)	O
{	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
(	O
void	O
*	O
)	O
&	O
node	pointer
->	O
locus	struct
)	O
;	O
if	O
(	O
sec	pointer
->	O
parser	pointer
(	O
mu_cfg_section_start	int
,	O
node	pointer
,	O
sec	pointer
->	O
label	pointer
,	O
&	O
sec	pointer
->	O
target	pointer
,	O
sdata	pointer
->	O
call_data	pointer
,	O
sdata	pointer
->	O
tree	pointer
)	O
)	O
{	O
sdata	pointer
->	O
error	int
++	O
;	O
return	O
MU_CFG_ITER_SKIP	int
;	O
}	O
}	O
push_section	function
(	O
sdata	pointer
,	O
sec	pointer
)	O
;	O
break	O
;	O
case	O
mu_cfg_node_param	int
:	O
if	O
(	O
parse_param	function
(	O
sdata	pointer
,	O
node	pointer
)	O
)	O
{	O
sdata	pointer
->	O
error	int
++	O
;	O
return	O
MU_CFG_ITER_SKIP	int
;	O
}	O
break	O
;	O
}	O
return	O
MU_CFG_ITER_OK	int
;	O
}	O
static	O
int	O
_scan_tree_end_helper	function
(	O
const	O
mu_cfg_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
scan_tree_data	struct
*	O
sdata	pointer
=	O
data	pointer
;	O
struct	O
mu_cfg_section	int
*	O
sec	pointer
;	O
switch	O
(	O
node	pointer
->	O
type	pointer
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
mu_cfg_node_statement	int
:	O
sec	pointer
=	O
pop_section	function
(	O
sdata	pointer
)	O
;	O
if	O
(	O
sec	pointer
&&	O
sec	pointer
->	O
parser	pointer
)	O
{	O
if	O
(	O
sec	pointer
->	O
parser	pointer
(	O
mu_cfg_section_end	int
,	O
node	pointer
,	O
sec	pointer
->	O
label	pointer
,	O
&	O
sec	pointer
->	O
target	pointer
,	O
sdata	pointer
->	O
call_data	pointer
,	O
sdata	pointer
->	O
tree	pointer
)	O
)	O
{	O
sdata	pointer
->	O
error	int
++	O
;	O
return	O
MU_CFG_ITER_SKIP	int
;	O
}	O
}	O
}	O
return	O
MU_CFG_ITER_OK	int
;	O
}	O
int	O
mu_cfg_scan_tree	function
(	O
mu_cfg_tree_t	struct
*	O
tree	pointer
,	O
struct	O
mu_cfg_section	int
*	O
sections	pointer
,	O
void	O
*	O
target	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
scan_tree_data	struct
dat	pointer
;	O
struct	O
mu_cfg_iter_closure	struct
clos	pointer
;	O
int	O
save_mode	int
=	O
0	int
,	O
mode	int
;	O
struct	O
mu_locus_range	struct
save_locus	struct
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
int	O
rc	int
;	O
dat	pointer
.	O
tree	pointer
=	O
tree	pointer
;	O
dat	pointer
.	O
list	pointer
=	O
NULL	O
;	O
dat	pointer
.	O
error	int
=	O
0	int
;	O
dat	pointer
.	O
call_data	pointer
=	O
data	pointer
;	O
dat	pointer
.	O
target	pointer
=	O
target	pointer
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_GET_MODE	int
,	O
&	O
save_mode	int
)	O
;	O
mode	int
=	O
save_mode	int
|	O
MU_LOGMODE_LOCUS	int
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
mode	int
)	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_GET_LOCUS_RANGE	int
,	O
&	O
save_locus	struct
)	O
;	O
if	O
(	O
push_section	function
(	O
&	O
dat	pointer
,	O
sections	pointer
)	O
)	O
return	O
1	int
;	O
clos	pointer
.	O
beg	struct
=	O
_scan_tree_helper	function
;	O
clos	pointer
.	O
end	struct
=	O
_scan_tree_end_helper	function
;	O
clos	pointer
.	O
data	pointer
=	O
&	O
dat	pointer
;	O
rc	int
=	O
mu_cfg_preorder	function
(	O
tree	pointer
->	O
nodes	pointer
,	O
&	O
clos	pointer
)	O
;	O
pop_section	function
(	O
&	O
dat	pointer
)	O
;	O
if	O
(	O
rc	int
&&	O
rc	int
!=	O
MU_ERR_USER0	O
)	O
dat	pointer
.	O
error	int
++	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_MODE	int
,	O
&	O
save_mode	int
)	O
;	O
mu_stream_ioctl	function
(	O
mu_strerr	pointer
,	O
MU_IOCTL_LOGSTREAM	int
,	O
MU_IOCTL_LOGSTREAM_SET_LOCUS_RANGE	int
,	O
&	O
save_locus	struct
)	O
;	O
return	O
dat	pointer
.	O
error	int
;	O
}	O
int	O
mu_cfg_find_section	function
(	O
struct	O
mu_cfg_section	int
*	O
root_sec	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
mu_cfg_section	int
*	O
*	O
retval	pointer
)	O
{	O
while	O
(	O
path	pointer
[	O
0	int
]	O
)	O
{	O
struct	O
mu_cfg_section	int
*	O
sec	pointer
;	O
size_t	long
len	long
;	O
const	O
char	O
*	O
p	pointer
;	O
while	O
(	O
*	O
path	pointer
==	O
MU_CFG_PATH_DELIM	char
)	O
path	pointer
++	O
;	O
if	O
(	O
*	O
path	pointer
==	O
0	int
)	O
return	O
MU_ERR_NOENT	O
;	O
p	pointer
=	O
strchr	function
(	O
path	pointer
,	O
MU_CFG_PATH_DELIM	char
)	O
;	O
if	O
(	O
p	pointer
)	O
len	long
=	O
p	pointer
-	O
path	pointer
;	O
else	O
len	long
=	O
strlen	function
(	O
path	pointer
)	O
;	O
sec	pointer
=	O
find_subsection	function
(	O
root_sec	pointer
,	O
path	pointer
,	O
len	long
)	O
;	O
if	O
(	O
!	O
sec	pointer
)	O
return	O
MU_ERR_NOENT	O
;	O
root_sec	pointer
=	O
sec	pointer
;	O
path	pointer
+=	O
len	long
;	O
}	O
if	O
(	O
retval	pointer
)	O
*	O
retval	pointer
=	O
root_sec	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_cfg_tree_create	function
(	O
struct	O
mu_cfg_tree	struct
*	O
*	O
ptree	pointer
)	O
{	O
struct	O
mu_cfg_tree	struct
*	O
tree	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
*	O
tree	pointer
)	O
;	O
if	O
(	O
!	O
tree	pointer
)	O
return	O
errno	O
;	O
mu_opool_create	function
(	O
&	O
tree	pointer
->	O
pool	pointer
,	O
MU_OPOOL_ENOMEMABRT	int
)	O
;	O
*	O
ptree	pointer
=	O
tree	pointer
;	O
return	O
0	int
;	O
}	O
mu_cfg_node_t	struct
*	O
mu_cfg_tree_create_node	function
(	O
struct	O
mu_cfg_tree	struct
*	O
tree	pointer
,	O
enum	O
mu_cfg_node_type	enum
type	pointer
,	O
const	O
struct	O
mu_locus_range	struct
*	O
loc	pointer
,	O
const	O
char	O
*	O
tag	pointer
,	O
const	O
char	O
*	O
label	pointer
,	O
mu_list_t	pointer
nodelist	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
mu_cfg_node_t	struct
*	O
np	pointer
;	O
size_t	long
size	long
=	O
sizeof	O
*	O
np	pointer
+	O
strlen	function
(	O
tag	pointer
)	O
+	O
1	int
;	O
mu_config_value_t	struct
val	array
;	O
np	pointer
=	O
mu_alloc	function
(	O
size	long
)	O
;	O
np	pointer
->	O
type	pointer
=	O
type	pointer
;	O
mu_locus_range_init	function
(	O
&	O
np	pointer
->	O
locus	struct
)	O
;	O
if	O
(	O
loc	pointer
)	O
mu_locus_range_copy	function
(	O
&	O
np	pointer
->	O
locus	struct
,	O
loc	pointer
)	O
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
(	O
np	pointer
+	O
1	int
)	O
;	O
np	pointer
->	O
tag	pointer
=	O
p	pointer
;	O
strcpy	function
(	O
p	pointer
,	O
tag	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
;	O
val	array
.	O
type	pointer
=	O
MU_CFG_STRING	int
;	O
if	O
(	O
label	pointer
)	O
{	O
mu_opool_clear	function
(	O
tree	pointer
->	O
pool	pointer
)	O
;	O
mu_opool_appendz	function
(	O
tree	pointer
->	O
pool	pointer
,	O
label	pointer
)	O
;	O
mu_opool_append_char	function
(	O
tree	pointer
->	O
pool	pointer
,	O
0	int
)	O
;	O
val	array
.	O
v	pointer
.	O
string	pointer
=	O
mu_opool_finish	function
(	O
tree	pointer
->	O
pool	pointer
,	O
NULL	O
)	O
;	O
np	pointer
->	O
label	pointer
=	O
config_value_dup	function
(	O
&	O
val	array
)	O
;	O
}	O
else	O
np	pointer
->	O
label	pointer
=	O
NULL	O
;	O
np	pointer
->	O
nodes	pointer
=	O
nodelist	pointer
;	O
return	O
np	pointer
;	O
}	O
void	O
mu_cfg_tree_add_node	function
(	O
mu_cfg_tree_t	struct
*	O
tree	pointer
,	O
mu_cfg_node_t	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
!	O
node	pointer
)	O
return	O
;	O
if	O
(	O
!	O
tree	pointer
->	O
nodes	pointer
)	O
mu_cfg_create_node_list	function
(	O
&	O
tree	pointer
->	O
nodes	pointer
)	O
;	O
mu_list_append	function
(	O
tree	pointer
->	O
nodes	pointer
,	O
node	pointer
)	O
;	O
}	O
void	O
mu_cfg_tree_add_nodelist	function
(	O
mu_cfg_tree_t	struct
*	O
tree	pointer
,	O
mu_list_t	pointer
nodelist	pointer
)	O
{	O
if	O
(	O
!	O
nodelist	pointer
)	O
return	O
;	O
if	O
(	O
!	O
tree	pointer
->	O
nodes	pointer
)	O
mu_cfg_create_node_list	function
(	O
&	O
tree	pointer
->	O
nodes	pointer
)	O
;	O
mu_list_append_list	function
(	O
tree	pointer
->	O
nodes	pointer
,	O
nodelist	pointer
)	O
;	O
}	O
int	O
mu_cfg_value_eq	function
(	O
mu_config_value_t	struct
*	O
a	pointer
,	O
mu_config_value_t	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
a	pointer
->	O
type	pointer
!=	O
b	pointer
->	O
type	pointer
)	O
return	O
0	int
;	O
switch	O
(	O
a	pointer
->	O
type	pointer
)	O
{	O
case	O
MU_CFG_STRING	int
:	O
if	O
(	O
a	pointer
->	O
v	pointer
.	O
string	pointer
==	O
NULL	O
)	O
return	O
b	pointer
->	O
v	pointer
.	O
string	pointer
==	O
NULL	O
;	O
return	O
strcmp	function
(	O
a	pointer
->	O
v	pointer
.	O
string	pointer
,	O
b	pointer
->	O
v	pointer
.	O
string	pointer
)	O
==	O
0	int
;	O
case	O
MU_CFG_LIST	int
:	O
{	O
int	O
ret	pointer
=	O
1	int
;	O
size_t	long
cnt	long
;	O
size_t	long
i	long
;	O
mu_iterator_t	pointer
aitr	pointer
,	O
bitr	pointer
;	O
mu_list_count	function
(	O
a	pointer
->	O
v	pointer
.	O
list	pointer
,	O
&	O
cnt	long
)	O
;	O
mu_list_count	function
(	O
b	pointer
->	O
v	pointer
.	O
list	pointer
,	O
&	O
i	long
)	O
;	O
if	O
(	O
i	long
!=	O
cnt	long
)	O
return	O
1	int
;	O
mu_list_get_iterator	function
(	O
a	pointer
->	O
v	pointer
.	O
list	pointer
,	O
&	O
aitr	pointer
)	O
;	O
mu_list_get_iterator	function
(	O
b	pointer
->	O
v	pointer
.	O
list	pointer
,	O
&	O
bitr	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
,	O
mu_iterator_first	function
(	O
aitr	pointer
)	O
,	O
mu_iterator_first	function
(	O
bitr	pointer
)	O
;	O
!	O
mu_iterator_is_done	function
(	O
aitr	pointer
)	O
&&	O
!	O
mu_iterator_is_done	function
(	O
bitr	pointer
)	O
;	O
mu_iterator_next	function
(	O
aitr	pointer
)	O
,	O
mu_iterator_next	function
(	O
bitr	pointer
)	O
,	O
i	long
++	O
)	O
{	O
mu_config_value_t	struct
*	O
ap	array
,	O
*	O
bp	pointer
;	O
mu_iterator_current	function
(	O
aitr	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
ap	array
)	O
;	O
mu_iterator_current	function
(	O
bitr	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
bp	pointer
)	O
;	O
ret	pointer
=	O
mu_cfg_value_eq	function
(	O
ap	array
,	O
bp	pointer
)	O
;	O
if	O
(	O
!	O
ret	pointer
)	O
break	O
;	O
}	O
mu_iterator_destroy	function
(	O
&	O
aitr	pointer
)	O
;	O
mu_iterator_destroy	function
(	O
&	O
bitr	pointer
)	O
;	O
return	O
ret	pointer
&&	O
i	long
==	O
cnt	long
;	O
}	O
case	O
MU_CFG_ARRAY	int
:	O
if	O
(	O
a	pointer
->	O
v	pointer
.	O
arg	pointer
.	O
c	int
==	O
b	pointer
->	O
v	pointer
.	O
arg	pointer
.	O
c	int
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
a	pointer
->	O
v	pointer
.	O
arg	pointer
.	O
c	int
;	O
i	long
++	O
)	O
if	O
(	O
!	O
mu_cfg_value_eq	function
(	O
&	O
a	pointer
->	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
[	O
i	long
]	O
,	O
&	O
b	pointer
->	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
[	O
i	long
]	O
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
split_cfg_path	function
(	O
const	O
char	O
*	O
path	pointer
,	O
int	O
*	O
pargc	pointer
,	O
char	O
*	O
*	O
*	O
pargv	pointer
)	O
{	O
int	O
argc	long
;	O
char	O
*	O
*	O
argv	pointer
;	O
char	O
*	O
delim	pointer
=	O
MU_CFG_PATH_DELIM_STR	pointer
;	O
char	O
static_delim	array
[	O
2	int
]	O
=	O
{	O
0	int
,	O
0	int
}	O
;	O
if	O
(	O
path	pointer
[	O
0	int
]	O
==	O
'\\'	O
)	O
{	O
argv	pointer
=	O
calloc	function
(	O
2	int
,	O
sizeof	O
(	O
*	O
argv	pointer
)	O
)	O
;	O
if	O
(	O
!	O
argv	pointer
)	O
return	O
ENOMEM	int
;	O
argv	pointer
[	O
0	int
]	O
=	O
strdup	function
(	O
path	pointer
+	O
1	int
)	O
;	O
if	O
(	O
!	O
argv	pointer
[	O
0	int
]	O
)	O
{	O
free	function
(	O
argv	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
argv	pointer
[	O
1	int
]	O
=	O
NULL	O
;	O
argc	long
=	O
1	int
;	O
}	O
else	O
{	O
struct	O
mu_wordsplit	struct
ws	pointer
;	O
if	O
(	O
mu_ispunct	O
(	O
path	pointer
[	O
0	int
]	O
)	O
)	O
{	O
delim	pointer
=	O
static_delim	array
;	O
delim	pointer
[	O
0	int
]	O
=	O
path	pointer
[	O
0	int
]	O
;	O
path	pointer
++	O
;	O
}	O
ws	pointer
.	O
ws_delim	pointer
=	O
delim	pointer
;	O
if	O
(	O
mu_wordsplit	struct
(	O
path	pointer
,	O
&	O
ws	pointer
,	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_DELIM	O
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot split line `%s': %s"	pointer
)	O
,	O
path	pointer
,	O
mu_wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
argc	long
=	O
ws	pointer
.	O
ws_wordc	long
;	O
argv	pointer
=	O
ws	pointer
.	O
ws_wordv	pointer
;	O
ws	pointer
.	O
ws_wordc	long
=	O
0	int
;	O
ws	pointer
.	O
ws_wordv	pointer
=	O
NULL	O
;	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
}	O
*	O
pargc	pointer
=	O
argc	long
;	O
*	O
pargv	pointer
=	O
argv	pointer
;	O
return	O
0	int
;	O
}	O
struct	O
find_data	struct
{	O
int	O
argc	long
;	O
char	O
*	O
*	O
argv	pointer
;	O
int	O
tag	pointer
;	O
mu_config_value_t	struct
*	O
label	pointer
;	O
const	O
mu_cfg_node_t	struct
*	O
node	pointer
;	O
}	O
;	O
static	O
void	O
free_value_mem	function
(	O
mu_config_value_t	struct
*	O
p	pointer
)	O
{	O
switch	O
(	O
p	pointer
->	O
type	pointer
)	O
{	O
case	O
MU_CFG_STRING	int
:	O
free	function
(	O
(	O
char	O
*	O
)	O
p	pointer
->	O
v	pointer
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
MU_CFG_LIST	int
:	O
break	O
;	O
case	O
MU_CFG_ARRAY	int
:	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
p	pointer
->	O
v	pointer
.	O
arg	pointer
.	O
c	int
;	O
i	long
++	O
)	O
free_value_mem	function
(	O
&	O
p	pointer
->	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
[	O
i	long
]	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
destroy_value	function
(	O
void	O
*	O
p	pointer
)	O
{	O
mu_config_value_t	struct
*	O
val	array
=	O
p	pointer
;	O
if	O
(	O
val	array
)	O
{	O
free_value_mem	function
(	O
val	array
)	O
;	O
free	function
(	O
val	array
)	O
;	O
}	O
}	O
static	O
mu_config_value_t	struct
*	O
parse_label	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
mu_config_value_t	struct
*	O
val	array
=	O
NULL	O
;	O
size_t	long
i	long
;	O
struct	O
mu_wordsplit	struct
ws	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
if	O
(	O
len	long
>	O
1	int
&&	O
str	pointer
[	O
0	int
]	O
==	O
'('	O
&&	O
str	pointer
[	O
len	long
-	O
1	int
]	O
==	O
')'	O
)	O
{	O
mu_list_t	pointer
lst	pointer
;	O
ws	pointer
.	O
ws_delim	pointer
=	O
","	pointer
;	O
if	O
(	O
mu_wordsplit_len	function
(	O
str	pointer
+	O
1	int
,	O
len	long
-	O
2	int
,	O
&	O
ws	pointer
,	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_DELIM	O
|	O
MU_WRDSF_WS	O
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot split line `%s': %s"	pointer
)	O
,	O
str	pointer
,	O
mu_wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
mu_list_create	function
(	O
&	O
lst	pointer
)	O
;	O
mu_list_set_destroy_item	function
(	O
lst	pointer
,	O
destroy_value	function
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ws	pointer
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
{	O
mu_config_value_t	struct
*	O
p	pointer
=	O
mu_alloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
->	O
type	pointer
=	O
MU_CFG_STRING	int
;	O
p	pointer
->	O
v	pointer
.	O
string	pointer
=	O
ws	pointer
.	O
ws_wordv	pointer
[	O
i	long
]	O
;	O
mu_list_append	function
(	O
lst	pointer
,	O
p	pointer
)	O
;	O
}	O
val	array
=	O
mu_alloc	function
(	O
sizeof	O
(	O
*	O
val	array
)	O
)	O
;	O
val	array
->	O
type	pointer
=	O
MU_CFG_LIST	int
;	O
val	array
->	O
v	pointer
.	O
list	pointer
=	O
lst	pointer
;	O
}	O
else	O
{	O
if	O
(	O
mu_wordsplit	struct
(	O
str	pointer
,	O
&	O
ws	pointer
,	O
MU_WRDSF_DEFFLAGS	O
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot split line `%s': %s"	pointer
)	O
,	O
str	pointer
,	O
mu_wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
val	array
=	O
mu_alloc	function
(	O
sizeof	O
(	O
*	O
val	array
)	O
)	O
;	O
if	O
(	O
ws	pointer
.	O
ws_wordc	long
==	O
1	int
)	O
{	O
val	array
->	O
type	pointer
=	O
MU_CFG_STRING	int
;	O
val	array
->	O
v	pointer
.	O
string	pointer
=	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
;	O
}	O
else	O
{	O
val	array
->	O
type	pointer
=	O
MU_CFG_ARRAY	int
;	O
val	array
->	O
v	pointer
.	O
arg	pointer
.	O
c	int
=	O
ws	pointer
.	O
ws_wordc	long
;	O
val	array
->	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
=	O
mu_alloc	function
(	O
ws	pointer
.	O
ws_wordc	long
*	O
sizeof	O
(	O
val	array
->	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ws	pointer
.	O
ws_wordc	long
;	O
i	long
++	O
)	O
{	O
val	array
->	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
[	O
i	long
]	O
.	O
type	pointer
=	O
MU_CFG_STRING	int
;	O
val	array
->	O
v	pointer
.	O
arg	pointer
.	O
v	pointer
[	O
i	long
]	O
.	O
v	pointer
.	O
string	pointer
=	O
ws	pointer
.	O
ws_wordv	pointer
[	O
i	long
]	O
;	O
}	O
}	O
ws	pointer
.	O
ws_wordc	long
=	O
0	int
;	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
}	O
return	O
val	array
;	O
}	O
static	O
void	O
parse_tag	function
(	O
struct	O
find_data	struct
*	O
fptr	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
fptr	pointer
->	O
argv	pointer
[	O
fptr	pointer
->	O
tag	pointer
]	O
,	O
'='	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
*	O
p	pointer
++	O
=	O
0	int
;	O
fptr	pointer
->	O
label	pointer
=	O
parse_label	function
(	O
p	pointer
)	O
;	O
}	O
else	O
fptr	pointer
->	O
label	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
node_finder	function
(	O
const	O
mu_cfg_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
find_data	struct
*	O
fdptr	pointer
=	O
data	pointer
;	O
if	O
(	O
strcmp	function
(	O
fdptr	pointer
->	O
argv	pointer
[	O
fdptr	pointer
->	O
tag	pointer
]	O
,	O
node	pointer
->	O
tag	pointer
)	O
==	O
0	int
&&	O
(	O
!	O
fdptr	pointer
->	O
label	pointer
||	O
mu_cfg_value_eq	function
(	O
fdptr	pointer
->	O
label	pointer
,	O
node	pointer
->	O
label	pointer
)	O
)	O
)	O
{	O
fdptr	pointer
->	O
tag	pointer
++	O
;	O
if	O
(	O
fdptr	pointer
->	O
tag	pointer
==	O
fdptr	pointer
->	O
argc	long
)	O
{	O
fdptr	pointer
->	O
node	pointer
=	O
node	pointer
;	O
return	O
MU_CFG_ITER_STOP	int
;	O
}	O
parse_tag	function
(	O
fdptr	pointer
)	O
;	O
return	O
MU_CFG_ITER_OK	int
;	O
}	O
return	O
node	pointer
->	O
type	pointer
==	O
mu_cfg_node_statement	int
?	O
MU_CFG_ITER_SKIP	int
:	O
MU_CFG_ITER_OK	int
;	O
}	O
int	O
mu_cfg_find_node	function
(	O
mu_cfg_tree_t	struct
*	O
tree	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
mu_cfg_node_t	struct
*	O
*	O
pval	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
find_data	struct
data	pointer
;	O
rc	int
=	O
split_cfg_path	function
(	O
path	pointer
,	O
&	O
data	pointer
.	O
argc	long
,	O
&	O
data	pointer
.	O
argv	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
data	pointer
.	O
tag	pointer
=	O
0	int
;	O
if	O
(	O
data	pointer
.	O
argc	long
)	O
{	O
struct	O
mu_cfg_iter_closure	struct
clos	pointer
;	O
parse_tag	function
(	O
&	O
data	pointer
)	O
;	O
clos	pointer
.	O
beg	struct
=	O
node_finder	function
;	O
clos	pointer
.	O
end	struct
=	O
NULL	O
;	O
clos	pointer
.	O
data	pointer
=	O
&	O
data	pointer
;	O
rc	int
=	O
mu_cfg_preorder	function
(	O
tree	pointer
->	O
nodes	pointer
,	O
&	O
clos	pointer
)	O
;	O
destroy_value	function
(	O
data	pointer
.	O
label	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
MU_ERR_USER0	O
)	O
{	O
*	O
pval	pointer
=	O
(	O
mu_cfg_node_t	struct
*	O
)	O
data	pointer
.	O
node	pointer
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
rc	int
!=	O
0	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERR	O
,	O
"mu_cfg_preorder"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
}	O
return	O
MU_ERR_NOENT	O
;	O
}	O
int	O
mu_cfg_create_subtree	function
(	O
const	O
char	O
*	O
path	pointer
,	O
mu_cfg_node_t	struct
*	O
*	O
pnode	pointer
)	O
{	O
int	O
rc	int
;	O
int	O
argc	long
,	O
i	long
;	O
char	O
*	O
*	O
argv	pointer
;	O
enum	O
mu_cfg_node_type	enum
type	pointer
;	O
mu_cfg_node_t	struct
*	O
node	pointer
=	O
NULL	O
;	O
struct	O
mu_locus_range	struct
locus	struct
=	O
MU_LOCUS_RANGE_INITIALIZER	O
;	O
rc	int
=	O
split_cfg_path	function
(	O
path	pointer
,	O
&	O
argc	long
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
for	O
(	O
i	long
=	O
argc	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
{	O
mu_list_t	pointer
nodelist	pointer
=	O
NULL	O
;	O
mu_config_value_t	struct
*	O
label	pointer
=	O
NULL	O
;	O
char	O
*	O
q	pointer
=	O
argv	pointer
[	O
i	long
]	O
,	O
*	O
p	pointer
;	O
mu_cfg_node_t	struct
*	O
parent	pointer
;	O
type	pointer
=	O
mu_cfg_node_statement	int
;	O
do	O
{	O
p	pointer
=	O
strchr	function
(	O
q	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
p	pointer
&&	O
p	pointer
>	O
argv	pointer
[	O
i	long
]	O
&&	O
p	pointer
[	O
-	O
1	int
]	O
!=	O
'\\'	O
)	O
{	O
*	O
p	pointer
++	O
=	O
0	int
;	O
label	pointer
=	O
parse_label	function
(	O
p	pointer
)	O
;	O
if	O
(	O
i	long
==	O
argc	long
-	O
1	int
)	O
type	pointer
=	O
mu_cfg_node_param	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
p	pointer
)	O
q	pointer
=	O
p	pointer
+	O
1	int
;	O
else	O
break	O
;	O
}	O
while	O
(	O
*	O
q	pointer
)	O
;	O
if	O
(	O
node	pointer
)	O
{	O
mu_cfg_create_node_list	function
(	O
&	O
nodelist	pointer
)	O
;	O
mu_list_append	function
(	O
nodelist	pointer
,	O
node	pointer
)	O
;	O
}	O
parent	pointer
=	O
mu_cfg_alloc_node	function
(	O
type	pointer
,	O
&	O
locus	struct
,	O
argv	pointer
[	O
i	long
]	O
,	O
label	pointer
,	O
nodelist	pointer
)	O
;	O
if	O
(	O
node	pointer
)	O
node	pointer
->	O
parent	pointer
=	O
parent	pointer
;	O
node	pointer
=	O
parent	pointer
;	O
}	O
mu_argcv_free	function
(	O
argc	long
,	O
argv	pointer
)	O
;	O
*	O
pnode	pointer
=	O
node	pointer
;	O
return	O
0	int
;	O
}	O
int	O
mu_cfg_parse_config	function
(	O
mu_cfg_tree_t	struct
*	O
*	O
ptree	pointer
,	O
struct	O
mu_cfg_parse_hints	struct
*	O
hints	pointer
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
mu_cfg_tree_t	struct
*	O
tree	pointer
=	O
NULL	O
,	O
*	O
tmp	pointer
;	O
struct	O
mu_cfg_parse_hints	struct
xhints	struct
;	O
if	O
(	O
(	O
hints	pointer
->	O
flags	int
&	O
MU_CFHINT_SITE_FILE	int
)	O
&&	O
hints	pointer
->	O
site_file	pointer
)	O
{	O
rc	int
=	O
mu_cfg_parse_file	function
(	O
&	O
tmp	pointer
,	O
hints	pointer
->	O
site_file	pointer
,	O
hints	pointer
->	O
flags	int
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
mu_cfg_tree_postprocess	function
(	O
tmp	pointer
,	O
hints	pointer
)	O
;	O
mu_cfg_tree_union	function
(	O
&	O
tree	pointer
,	O
&	O
tmp	pointer
)	O
;	O
case	O
ENOENT	int
:	O
rc	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
mu_error	function
(	O
"%s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
xhints	struct
=	O
*	O
hints	pointer
;	O
xhints	struct
.	O
flags	int
&=	O
~	O
MU_CFHINT_PROGRAM	int
;	O
if	O
(	O
(	O
hints	pointer
->	O
flags	int
&	O
MU_CFHINT_PER_USER_FILE	int
)	O
&&	O
(	O
hints	pointer
->	O
flags	int
&	O
MU_CFHINT_PROGRAM	int
)	O
)	O
{	O
size_t	long
size	long
=	O
3	int
+	O
strlen	function
(	O
hints	pointer
->	O
program	pointer
)	O
+	O
1	int
;	O
char	O
*	O
file_name	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
file_name	pointer
)	O
{	O
strcpy	function
(	O
file_name	pointer
,	O
"~/."	pointer
)	O
;	O
strcat	function
(	O
file_name	pointer
,	O
hints	pointer
->	O
program	pointer
)	O
;	O
rc	int
=	O
mu_cfg_parse_file	function
(	O
&	O
tmp	pointer
,	O
file_name	pointer
,	O
xhints	struct
.	O
flags	int
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
mu_cfg_tree_postprocess	function
(	O
tmp	pointer
,	O
&	O
xhints	struct
)	O
;	O
mu_cfg_tree_union	function
(	O
&	O
tree	pointer
,	O
&	O
tmp	pointer
)	O
;	O
break	O
;	O
case	O
ENOENT	int
:	O
rc	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
mu_error	function
(	O
"%s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_cfg_destroy_tree	function
(	O
&	O
tree	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
free	function
(	O
file_name	pointer
)	O
;	O
}	O
}	O
if	O
(	O
(	O
hints	pointer
->	O
flags	int
&	O
MU_CFHINT_CUSTOM_FILE	int
)	O
&&	O
hints	pointer
->	O
custom_file	pointer
)	O
{	O
rc	int
=	O
mu_cfg_parse_file	function
(	O
&	O
tmp	pointer
,	O
hints	pointer
->	O
custom_file	pointer
,	O
xhints	struct
.	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"errors parsing file %s: %s"	pointer
)	O
,	O
hints	pointer
->	O
custom_file	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_cfg_destroy_tree	function
(	O
&	O
tree	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
else	O
{	O
mu_cfg_tree_postprocess	function
(	O
tmp	pointer
,	O
&	O
xhints	struct
)	O
;	O
mu_cfg_tree_union	function
(	O
&	O
tree	pointer
,	O
&	O
tmp	pointer
)	O
;	O
}	O
}	O
*	O
ptree	pointer
=	O
tree	pointer
;	O
return	O
rc	int
;	O
}	O
