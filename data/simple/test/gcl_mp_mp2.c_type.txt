unsigned	O
plong	int
MOST_NEGS	array
[	O
3	int
]	O
=	O
{	O
0x01ff0003	int
,	O
0xff000003	int
,	O
1	int
<<	O
31	int
}	O
;	O
unsigned	O
plong	int
ABS_MOST_NEGS	array
[	O
3	int
]	O
=	O
{	O
0x01ff0003	int
,	O
0x01000003	int
,	O
1	int
<<	O
31	int
}	O
;	O
GEN	O
stoi	function
(	O
x	int
)	O
plong	int
x	int
;	O
{	O
GEN	O
y	int
;	O
if	O
(	O
!	O
x	int
)	O
return	O
gzero	O
;	O
y	int
=	O
cgeti	function
(	O
3	int
)	O
;	O
if	O
(	O
x	int
>	O
0	int
)	O
{	O
y	int
[	O
1	int
]	O
=	O
0x1000003	int
;	O
y	int
[	O
2	int
]	O
=	O
x	int
;	O
}	O
else	O
{	O
y	int
[	O
1	int
]	O
=	O
0xff000003	int
;	O
y	int
[	O
2	int
]	O
=	O
-	O
x	int
;	O
}	O
return	O
y	int
;	O
}	O
GEN	O
cgetg	function
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
,	O
y	int
;	O
{	O
unsigned	O
plong	int
p1	int
;	O
GEN	O
z	int
;	O
p1	int
=	O
avma	O
-	O
(	O
(	O
(	O
unsigned	O
short	O
)	O
x	int
)	O
<<	O
2	int
)	O
;	O
if	O
(	O
p1	int
<	O
bot	O
)	O
err	function
(	O
errpile	O
)	O
;	O
avma	O
=	O
p1	int
;	O
z	int
=	O
(	O
GEN	O
)	O
p1	int
;	O
z	int
[	O
0	int
]	O
=	O
0x10000	int
+	O
x	int
+	O
(	O
y	int
<<	O
24	int
)	O
;	O
return	O
z	int
;	O
}	O
GEN	O
cgeti	function
(	O
x	int
)	O
plong	int
x	int
;	O
{	O
unsigned	O
plong	int
p1	int
;	O
GEN	O
z	int
;	O
p1	int
=	O
avma	O
-	O
4	int
*	O
x	int
;	O
if	O
(	O
p1	int
<	O
bot	O
)	O
err	function
(	O
errpile	O
)	O
;	O
avma	O
=	O
p1	int
;	O
z	int
=	O
(	O
GEN	O
)	O
p1	int
;	O
z	int
[	O
0	int
]	O
=	O
0x1010000	int
+	O
x	int
;	O
return	O
z	int
;	O
}	O
GEN	O
icopy	function
(	O
x	int
)	O
GEN	O
x	int
;	O
{	O
GEN	O
y	int
;	O
plong	int
lx	O
=	O
lgef	O
(	O
x	int
)	O
,	O
i	O
;	O
y	int
=	O
cgeti	function
(	O
lx	O
)	O
;	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<	O
lx	O
;	O
i	O
++	O
)	O
y	int
[	O
i	O
]	O
=	O
x	int
[	O
i	O
]	O
;	O
return	O
y	int
;	O
}	O
GEN	O
negi	O
(	O
x	int
)	O
GEN	O
x	int
;	O
{	O
plong	int
s	int
=	O
signe	O
(	O
x	int
)	O
;	O
GEN	O
y	int
;	O
if	O
(	O
!	O
s	int
)	O
return	O
gzero	O
;	O
y	int
=	O
icopy	function
(	O
x	int
)	O
;	O
setsigne	O
(	O
y	int
,	O
-	O
s	int
)	O
;	O
return	O
y	int
;	O
}	O
GEN	O
absi	O
(	O
x	int
)	O
GEN	O
x	int
;	O
{	O
GEN	O
y	int
;	O
plong	int
s	int
=	O
signe	O
(	O
x	int
)	O
;	O
if	O
(	O
!	O
s	int
)	O
return	O
gzero	O
;	O
y	int
=	O
icopy	function
(	O
x	int
)	O
;	O
setsigne	O
(	O
y	int
,	O
1	int
)	O
;	O
return	O
y	int
;	O
}	O
plong	int
itos	O
(	O
x	int
)	O
GEN	O
x	int
;	O
{	O
plong	int
s	int
=	O
signe	O
(	O
x	int
)	O
,	O
p2	O
;	O
unsigned	O
plong	int
p1	int
;	O
if	O
(	O
!	O
s	int
)	O
return	O
0	int
;	O
if	O
(	O
lgef	O
(	O
x	int
)	O
>	O
3	int
)	O
err	function
(	O
affer2	O
)	O
;	O
p1	int
=	O
x	int
[	O
2	int
]	O
;	O
if	O
(	O
p1	int
>=	O
0x80000000	int
)	O
err	function
(	O
affer2	O
)	O
;	O
p2	O
=	O
(	O
s	int
>	O
0	int
)	O
?	O
p1	int
:	O
(	O
-	O
(	O
(	O
plong	int
)	O
p1	int
)	O
)	O
;	O
return	O
p2	O
;	O
}	O
void	O
affsi	O
(	O
s	int
,	O
x	int
)	O
plong	int
s	int
;	O
GEN	O
x	int
;	O
{	O
plong	int
lx	O
;	O
if	O
(	O
!	O
s	int
)	O
{	O
x	int
[	O
1	int
]	O
=	O
2	int
;	O
return	O
;	O
}	O
lx	O
=	O
lg	O
(	O
x	int
)	O
;	O
if	O
(	O
lx	O
<	O
3	int
)	O
err	function
(	O
affer1	O
)	O
;	O
if	O
(	O
s	int
>	O
0	int
)	O
{	O
x	int
[	O
1	int
]	O
=	O
0x1000003	int
;	O
x	int
[	O
2	int
]	O
=	O
s	int
;	O
}	O
else	O
{	O
s	int
=	O
-	O
s	int
;	O
if	O
(	O
s	int
<	O
0	int
)	O
{	O
if	O
(	O
lx	O
<	O
4	int
)	O
err	function
(	O
affer1	O
)	O
;	O
x	int
[	O
1	int
]	O
=	O
0xff000004	int
;	O
x	int
[	O
2	int
]	O
=	O
0	int
;	O
x	int
[	O
3	int
]	O
=	O
1	int
;	O
}	O
else	O
{	O
x	int
[	O
1	int
]	O
=	O
0xff000003	int
;	O
x	int
[	O
2	int
]	O
=	O
s	int
;	O
}	O
}	O
}	O
void	O
affii	O
(	O
x	int
,	O
y	int
)	O
GEN	O
x	int
,	O
y	int
;	O
{	O
plong	int
lx	O
=	O
lgef	O
(	O
x	int
)	O
,	O
i	O
;	O
if	O
(	O
x	int
==	O
y	int
)	O
return	O
;	O
if	O
(	O
lg	O
(	O
y	int
)	O
<	O
lx	O
)	O
err	function
(	O
affer3	O
)	O
;	O
for	O
(	O
i	O
=	O
1	int
;	O
i	O
<	O
lx	O
;	O
i	O
++	O
)	O
y	int
[	O
i	O
]	O
=	O
x	int
[	O
i	O
]	O
;	O
}	O
GEN	O
shifts	function
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
,	O
y	int
;	O
{	O
plong	int
t	array
[	O
3	int
]	O
;	O
if	O
(	O
!	O
x	int
)	O
return	O
gzero	O
;	O
t	array
[	O
0	int
]	O
=	O
0x1010003	int
;	O
if	O
(	O
x	int
>	O
0	int
)	O
{	O
t	array
[	O
1	int
]	O
=	O
0x1000003	int
;	O
t	array
[	O
2	int
]	O
=	O
x	int
;	O
}	O
else	O
{	O
t	array
[	O
1	int
]	O
=	O
0xff000003	int
;	O
t	array
[	O
2	int
]	O
=	O
-	O
x	int
;	O
}	O
return	O
shifti	function
(	O
t	array
,	O
y	int
)	O
;	O
}	O
GEN	O
shifti	function
(	O
x	int
,	O
n	int
)	O
GEN	O
x	int
;	O
plong	int
n	int
;	O
{	O
plong	int
lx	O
=	O
lgef	O
(	O
x	int
)	O
,	O
i	O
,	O
s	int
=	O
signe	O
(	O
x	int
)	O
,	O
d	O
,	O
m	O
,	O
p1	int
,	O
p2	O
,	O
k	O
;	O
GEN	O
y	int
;	O
TEMPVARS2	O
ulong	O
hiremainder	O
;	O
if	O
(	O
!	O
s	int
)	O
return	O
gzero	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
icopy	function
(	O
x	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
d	O
=	O
n	int
>>	O
5	int
;	O
m	O
=	O
n	int
&	O
31	int
;	O
if	O
(	O
m	O
)	O
{	O
p1	int
=	O
shiftl	O
(	O
x	int
[	O
2	int
]	O
,	O
m	O
)	O
;	O
p2	O
=	O
hiremainder	O
;	O
k	O
=	O
0	int
;	O
if	O
(	O
p2	O
)	O
{	O
y	int
=	O
cgeti	function
(	O
lx	O
+	O
d	O
+	O
1	int
)	O
;	O
for	O
(	O
i	O
=	O
lx	O
+	O
1	int
;	O
i	O
<=	O
lx	O
+	O
d	O
;	O
i	O
++	O
)	O
y	int
[	O
i	O
]	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
lx	O
;	O
i	O
>=	O
4	int
;	O
i	O
--	O
)	O
{	O
y	int
[	O
i	O
]	O
=	O
shiftl	O
(	O
x	int
[	O
i	O
-	O
1	int
]	O
,	O
m	O
)	O
+	O
k	O
;	O
k	O
=	O
hiremainder	O
;	O
}	O
y	int
[	O
3	int
]	O
=	O
p1	int
+	O
k	O
;	O
y	int
[	O
2	int
]	O
=	O
p2	O
;	O
}	O
else	O
{	O
y	int
=	O
cgeti	function
(	O
lx	O
+	O
d	O
)	O
;	O
for	O
(	O
i	O
=	O
lx	O
;	O
i	O
<	O
lx	O
+	O
d	O
;	O
i	O
++	O
)	O
y	int
[	O
i	O
]	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
lx	O
-	O
1	int
;	O
i	O
>=	O
3	int
;	O
i	O
--	O
)	O
{	O
y	int
[	O
i	O
]	O
=	O
shiftl	O
(	O
x	int
[	O
i	O
]	O
,	O
m	O
)	O
+	O
k	O
;	O
k	O
=	O
hiremainder	O
;	O
}	O
y	int
[	O
2	int
]	O
=	O
p1	int
+	O
k	O
;	O
}	O
}	O
else	O
{	O
y	int
=	O
cgeti	function
(	O
lx	O
+	O
d	O
)	O
;	O
for	O
(	O
i	O
=	O
lx	O
;	O
i	O
<	O
lx	O
+	O
d	O
;	O
i	O
++	O
)	O
y	int
[	O
i	O
]	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
lx	O
-	O
1	int
;	O
i	O
>=	O
2	int
;	O
i	O
--	O
)	O
y	int
[	O
i	O
]	O
=	O
x	int
[	O
i	O
]	O
;	O
}	O
}	O
else	O
{	O
n	int
=	O
-	O
n	int
;	O
d	O
=	O
n	int
>>	O
5	int
;	O
m	O
=	O
n	int
&	O
31	int
;	O
if	O
(	O
lx	O
<	O
d	O
+	O
3	int
)	O
return	O
gzero	O
;	O
if	O
(	O
!	O
m	O
)	O
{	O
y	int
=	O
cgeti	function
(	O
lx	O
-	O
d	O
)	O
;	O
for	O
(	O
i	O
=	O
2	int
;	O
i	O
<	O
lx	O
-	O
d	O
;	O
i	O
++	O
)	O
y	int
[	O
i	O
]	O
=	O
x	int
[	O
i	O
]	O
;	O
}	O
else	O
{	O
m	O
=	O
32	int
-	O
m	O
;	O
d	O
++	O
;	O
p1	int
=	O
shiftl	O
(	O
x	int
[	O
2	int
]	O
,	O
m	O
)	O
;	O
if	O
(	O
hiremainder	O
)	O
{	O
y	int
=	O
cgeti	function
(	O
lx	O
-	O
d	O
+	O
1	int
)	O
;	O
y	int
[	O
2	int
]	O
=	O
hiremainder	O
;	O
for	O
(	O
i	O
=	O
3	int
;	O
i	O
<=	O
lx	O
-	O
d	O
;	O
i	O
++	O
)	O
{	O
p2	O
=	O
shiftl	O
(	O
x	int
[	O
i	O
]	O
,	O
m	O
)	O
;	O
y	int
[	O
i	O
]	O
=	O
p1	int
+	O
hiremainder	O
;	O
p1	int
=	O
p2	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
lx	O
==	O
d	O
+	O
2	int
)	O
return	O
gzero	O
;	O
y	int
=	O
cgeti	function
(	O
lx	O
-	O
d	O
)	O
;	O
for	O
(	O
i	O
=	O
3	int
;	O
i	O
<=	O
lx	O
-	O
d	O
;	O
i	O
++	O
)	O
{	O
p2	O
=	O
shiftl	O
(	O
x	int
[	O
i	O
]	O
,	O
m	O
)	O
;	O
y	int
[	O
i	O
-	O
1	int
]	O
=	O
p1	int
+	O
hiremainder	O
;	O
p1	int
=	O
p2	O
;	O
}	O
}	O
}	O
}	O
y	int
[	O
1	int
]	O
=	O
y	int
[	O
0	int
]	O
;	O
setsigne	O
(	O
y	int
,	O
s	int
)	O
;	O
return	O
y	int
;	O
}	O
GEN	O
mptrunc	O
(	O
x	int
)	O
GEN	O
x	int
;	O
{	O
plong	int
e	O
,	O
i	O
,	O
s	int
,	O
lx	O
=	O
lg	O
(	O
x	int
)	O
,	O
p1	int
,	O
p2	O
,	O
m	O
;	O
unsigned	O
plong	int
d	O
;	O
TEMPVARS2	O
GEN	O
y	int
;	O
ulong	O
hiremainder	O
;	O
if	O
(	O
typ	O
(	O
x	int
)	O
==	O
1	int
)	O
return	O
icopy	function
(	O
x	int
)	O
;	O
s	int
=	O
signe	O
(	O
x	int
)	O
;	O
if	O
(	O
!	O
s	int
)	O
return	O
gzero	O
;	O
e	O
=	O
expo	O
(	O
x	int
)	O
;	O
if	O
(	O
e	O
<	O
0	int
)	O
return	O
gzero	O
;	O
d	O
=	O
e	O
>>	O
5	int
;	O
m	O
=	O
e	O
&	O
31	int
;	O
if	O
(	O
d	O
>=	O
lx	O
-	O
2	int
)	O
err	function
(	O
truer2	O
)	O
;	O
y	int
=	O
cgeti	function
(	O
d	O
+	O
3	int
)	O
;	O
y	int
[	O
1	int
]	O
=	O
y	int
[	O
0	int
]	O
;	O
setsigne	O
(	O
y	int
,	O
s	int
)	O
;	O
if	O
(	O
m	O
==	O
31	int
)	O
for	O
(	O
i	O
=	O
2	int
;	O
i	O
<=	O
d	O
+	O
2	int
;	O
i	O
++	O
)	O
y	int
[	O
i	O
]	O
=	O
x	int
[	O
i	O
]	O
;	O
else	O
{	O
m	O
++	O
;	O
p1	int
=	O
0	int
;	O
for	O
(	O
i	O
=	O
2	int
;	O
i	O
<=	O
d	O
+	O
2	int
;	O
i	O
++	O
)	O
{	O
p2	O
=	O
shiftl	O
(	O
x	int
[	O
i	O
]	O
,	O
m	O
)	O
;	O
y	int
[	O
i	O
]	O
=	O
hiremainder	O
+	O
p1	int
;	O
p1	int
=	O
p2	O
;	O
}	O
}	O
return	O
y	int
;	O
}	O
GEN	O
mpent	O
(	O
x	int
)	O
GEN	O
x	int
;	O
{	O
plong	int
e	O
,	O
i	O
,	O
lx	O
=	O
lg	O
(	O
x	int
)	O
,	O
m	O
,	O
f	O
,	O
p1	int
,	O
p2	O
;	O
unsigned	O
plong	int
d	O
;	O
ulong	O
hiremainder	O
;	O
GEN	O
y	int
,	O
z	int
;	O
TEMPVARS2	O
if	O
(	O
typ	O
(	O
x	int
)	O
==	O
1	int
)	O
return	O
icopy	function
(	O
x	int
)	O
;	O
if	O
(	O
signe	O
(	O
x	int
)	O
>=	O
0	int
)	O
return	O
mptrunc	O
(	O
x	int
)	O
;	O
e	O
=	O
expo	O
(	O
x	int
)	O
;	O
if	O
(	O
e	O
<	O
0	int
)	O
{	O
y	int
=	O
cgeti	function
(	O
3	int
)	O
;	O
y	int
[	O
2	int
]	O
=	O
1	int
;	O
y	int
[	O
1	int
]	O
=	O
0xff000003	int
;	O
return	O
y	int
;	O
}	O
d	O
=	O
e	O
>>	O
5	int
;	O
m	O
=	O
e	O
&	O
31	int
;	O
if	O
(	O
d	O
>=	O
lx	O
-	O
2	int
)	O
err	function
(	O
truer2	O
)	O
;	O
y	int
=	O
cgeti	function
(	O
d	O
+	O
3	int
)	O
;	O
y	int
[	O
1	int
]	O
=	O
0xff000003	int
+	O
d	O
;	O
if	O
(	O
m	O
==	O
31	int
)	O
{	O
for	O
(	O
i	O
=	O
2	int
;	O
i	O
<=	O
d	O
+	O
2	int
;	O
i	O
++	O
)	O
y	int
[	O
i	O
]	O
=	O
x	int
[	O
i	O
]	O
;	O
while	O
(	O
(	O
i	O
<	O
lx	O
)	O
&&	O
(	O
!	O
x	int
[	O
i	O
]	O
)	O
)	O
i	O
++	O
;	O
f	O
=	O
(	O
i	O
<	O
lx	O
)	O
;	O
}	O
else	O
{	O
m	O
++	O
;	O
p1	int
=	O
0	int
;	O
for	O
(	O
i	O
=	O
2	int
;	O
i	O
<=	O
d	O
+	O
2	int
;	O
i	O
++	O
)	O
{	O
p2	O
=	O
shiftl	O
(	O
x	int
[	O
i	O
]	O
,	O
m	O
)	O
;	O
y	int
[	O
i	O
]	O
=	O
hiremainder	O
+	O
p1	int
;	O
p1	int
=	O
p2	O
;	O
}	O
if	O
(	O
p1	int
)	O
f	O
=	O
1	int
;	O
else	O
{	O
while	O
(	O
(	O
i	O
<	O
lx	O
)	O
&&	O
(	O
!	O
x	int
[	O
i	O
]	O
)	O
)	O
i	O
++	O
;	O
f	O
=	O
(	O
i	O
<	O
lx	O
)	O
;	O
}	O
}	O
if	O
(	O
f	O
)	O
{	O
for	O
(	O
i	O
=	O
d	O
+	O
2	int
;	O
(	O
i	O
>=	O
2	int
)	O
&&	O
(	O
y	int
[	O
i	O
]	O
==	O
0xffffffff	int
)	O
;	O
i	O
--	O
)	O
y	int
[	O
i	O
]	O
=	O
0	int
;	O
if	O
(	O
i	O
>=	O
2	int
)	O
y	int
[	O
i	O
]	O
++	O
;	O
else	O
{	O
z	int
=	O
y	int
;	O
y	int
=	O
cgeti	function
(	O
1	int
)	O
;	O
*	O
y	int
=	O
(	O
*	O
z	int
)	O
+	O
1	int
;	O
y	int
[	O
1	int
]	O
=	O
z	int
[	O
1	int
]	O
+	O
1	int
;	O
}	O
}	O
return	O
y	int
;	O
}	O
int	O
cmpsi	O
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
;	O
GEN	O
y	int
;	O
{	O
ulong	O
p	O
;	O
if	O
(	O
!	O
x	int
)	O
return	O
-	O
signe	O
(	O
y	int
)	O
;	O
if	O
(	O
x	int
>	O
0	int
)	O
{	O
if	O
(	O
signe	O
(	O
y	int
)	O
<=	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
lgef	O
(	O
y	int
)	O
>	O
3	int
)	O
return	O
-	O
1	int
;	O
p	O
=	O
y	int
[	O
2	int
]	O
;	O
if	O
(	O
p	O
==	O
x	int
)	O
return	O
0	int
;	O
return	O
(	O
p	O
<	O
(	O
ulong	O
)	O
x	int
)	O
?	O
1	int
:	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
signe	O
(	O
y	int
)	O
>=	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
lgef	O
(	O
y	int
)	O
>	O
3	int
)	O
{	O
if	O
(	O
-	O
x	int
<	O
0	int
)	O
{	O
if	O
(	O
lgef	O
(	O
y	int
)	O
==	O
4	int
&&	O
y	int
[	O
2	int
]	O
==	O
0	int
&&	O
y	int
[	O
3	int
]	O
==	O
1	int
)	O
return	O
0	int
;	O
else	O
return	O
1	int
;	O
}	O
}	O
p	O
=	O
y	int
[	O
2	int
]	O
;	O
if	O
(	O
p	O
==	O
-	O
x	int
)	O
return	O
0	int
;	O
return	O
(	O
p	O
<	O
(	O
ulong	O
)	O
(	O
-	O
x	int
)	O
)	O
?	O
-	O
1	int
:	O
1	int
;	O
}	O
}	O
int	O
cmpii	O
(	O
x	int
,	O
y	int
)	O
GEN	O
x	int
,	O
y	int
;	O
{	O
plong	int
sx	O
=	O
signe	O
(	O
x	int
)	O
,	O
sy	O
=	O
signe	O
(	O
y	int
)	O
,	O
lx	O
,	O
ly	O
,	O
i	O
;	O
if	O
(	O
sx	O
<	O
sy	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
sx	O
>	O
sy	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
sx	O
)	O
return	O
0	int
;	O
lx	O
=	O
lgef	O
(	O
x	int
)	O
;	O
ly	O
=	O
lgef	O
(	O
y	int
)	O
;	O
if	O
(	O
lx	O
>	O
ly	O
)	O
return	O
sx	O
;	O
if	O
(	O
lx	O
<	O
ly	O
)	O
return	O
-	O
sx	O
;	O
for	O
(	O
i	O
=	O
2	int
;	O
(	O
i	O
<	O
lx	O
)	O
&&	O
(	O
x	int
[	O
i	O
]	O
==	O
y	int
[	O
i	O
]	O
)	O
;	O
i	O
++	O
)	O
;	O
if	O
(	O
i	O
==	O
lx	O
)	O
return	O
0	int
;	O
return	O
(	O
(	O
ulong	O
)	O
x	int
[	O
i	O
]	O
>	O
(	O
ulong	O
)	O
y	int
[	O
i	O
]	O
)	O
?	O
sx	O
:	O
-	O
sx	O
;	O
}	O
GEN	O
addss	function
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
,	O
y	int
;	O
{	O
plong	int
t	array
[	O
3	int
]	O
;	O
if	O
(	O
!	O
x	int
)	O
return	O
stoi	function
(	O
y	int
)	O
;	O
t	array
[	O
0	int
]	O
=	O
0x1010003	int
;	O
if	O
(	O
x	int
>	O
0	int
)	O
{	O
t	array
[	O
1	int
]	O
=	O
0x1000003	int
;	O
t	array
[	O
2	int
]	O
=	O
x	int
;	O
}	O
else	O
{	O
t	array
[	O
1	int
]	O
=	O
0xff000003	int
;	O
t	array
[	O
2	int
]	O
=	O
-	O
x	int
;	O
}	O
return	O
addsi	function
(	O
y	int
,	O
t	array
)	O
;	O
}	O
GEN	O
subii	O
(	O
x	int
,	O
y	int
)	O
GEN	O
x	int
,	O
y	int
;	O
{	O
plong	int
s	int
=	O
signe	O
(	O
y	int
)	O
;	O
GEN	O
z	int
;	O
if	O
(	O
x	int
==	O
y	int
)	O
return	O
gzero	O
;	O
setsigne	O
(	O
y	int
,	O
-	O
s	int
)	O
;	O
z	int
=	O
addii	function
(	O
x	int
,	O
y	int
)	O
;	O
setsigne	O
(	O
y	int
,	O
s	int
)	O
;	O
return	O
z	int
;	O
}	O
GEN	O
subsi	O
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
;	O
GEN	O
y	int
;	O
{	O
plong	int
s	int
=	O
signe	O
(	O
y	int
)	O
;	O
GEN	O
z	int
;	O
setsigne	O
(	O
y	int
,	O
-	O
s	int
)	O
;	O
z	int
=	O
addsi	function
(	O
x	int
,	O
y	int
)	O
;	O
setsigne	O
(	O
y	int
,	O
s	int
)	O
;	O
return	O
z	int
;	O
}	O
GEN	O
subss	function
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
,	O
y	int
;	O
{	O
if	O
(	O
y	int
==	O
(	O
1	int
<<	O
31	int
)	O
)	O
return	O
addsi	function
(	O
x	int
,	O
ABS_MOST_NEGS	array
)	O
;	O
return	O
addss	function
(	O
-	O
y	int
,	O
x	int
)	O
;	O
}	O
GEN	O
convi	O
(	O
x	int
)	O
GEN	O
x	int
;	O
{	O
plong	int
lx	O
,	O
av	O
=	O
avma	O
,	O
lz	O
;	O
GEN	O
z	int
,	O
p1	int
,	O
p2	O
;	O
if	O
(	O
!	O
signe	O
(	O
x	int
)	O
)	O
{	O
z	int
=	O
cgeti	function
(	O
3	int
)	O
;	O
z	int
[	O
1	int
]	O
=	O
-	O
1	int
;	O
z	int
[	O
2	int
]	O
=	O
0	int
;	O
avma	O
=	O
av	O
;	O
return	O
z	int
+	O
3	int
;	O
}	O
p1	int
=	O
absi	O
(	O
x	int
)	O
;	O
lx	O
=	O
lgef	O
(	O
p1	int
)	O
;	O
lz	O
=	O
(	O
(	O
lx	O
-	O
2	int
)	O
*	O
15	int
)	O
/	O
14	int
+	O
3	int
;	O
z	int
=	O
cgeti	function
(	O
lz	O
)	O
;	O
z	int
[	O
1	int
]	O
=	O
-	O
1	int
;	O
for	O
(	O
p2	O
=	O
z	int
+	O
2	int
;	O
signe	O
(	O
p1	int
)	O
;	O
p2	O
++	O
)	O
*	O
p2	O
=	O
divisii	O
(	O
p1	int
,	O
1000000000	int
,	O
p1	int
)	O
;	O
avma	O
=	O
av	O
;	O
return	O
p2	O
;	O
}	O
void	O
mulsii	O
(	O
x	int
,	O
y	int
,	O
z	int
)	O
plong	int
x	int
;	O
GEN	O
y	int
,	O
z	int
;	O
{	O
plong	int
av	O
=	O
avma	O
;	O
GEN	O
p1	int
;	O
p1	int
=	O
mulsi	O
(	O
x	int
,	O
y	int
)	O
;	O
affii	O
(	O
p1	int
,	O
z	int
)	O
;	O
avma	O
=	O
av	O
;	O
}	O
void	O
addsii	O
(	O
x	int
,	O
y	int
,	O
z	int
)	O
plong	int
x	int
;	O
GEN	O
y	int
,	O
z	int
;	O
{	O
plong	int
av	O
=	O
avma	O
;	O
GEN	O
p1	int
;	O
p1	int
=	O
addsi	function
(	O
x	int
,	O
y	int
)	O
;	O
affii	O
(	O
p1	int
,	O
z	int
)	O
;	O
avma	O
=	O
av	O
;	O
}	O
plong	int
divisii	O
(	O
x	int
,	O
y	int
,	O
z	int
)	O
plong	int
y	int
;	O
GEN	O
x	int
,	O
z	int
;	O
{	O
plong	int
av	O
=	O
avma	O
,	O
k	O
;	O
GEN	O
p1	int
;	O
p1	int
=	O
divis	O
(	O
x	int
,	O
y	int
)	O
;	O
affii	O
(	O
p1	int
,	O
z	int
)	O
;	O
avma	O
=	O
av	O
;	O
k	O
=	O
hiremainder	O
;	O
return	O
k	O
;	O
}	O
plong	int
vals	function
(	O
x	int
)	O
plong	int
x	int
;	O
{	O
unsigned	O
short	O
int	O
y	int
,	O
z	int
;	O
int	O
s	int
;	O
if	O
(	O
!	O
x	int
)	O
return	O
-	O
1	int
;	O
y	int
=	O
x	int
;	O
if	O
(	O
!	O
y	int
)	O
{	O
s	int
=	O
16	int
;	O
y	int
=	O
(	O
(	O
ulong	O
)	O
x	int
)	O
>>	O
16	int
;	O
}	O
else	O
s	int
=	O
0	int
;	O
z	int
=	O
y	int
&	O
255	int
;	O
if	O
(	O
!	O
z	int
)	O
{	O
s	int
+=	O
8	int
;	O
z	int
=	O
y	int
>>	O
8	int
;	O
}	O
y	int
=	O
z	int
&	O
15	int
;	O
if	O
(	O
!	O
y	int
)	O
{	O
s	int
+=	O
4	int
;	O
y	int
=	O
z	int
>>	O
4	int
;	O
}	O
z	int
=	O
y	int
&	O
3	int
;	O
if	O
(	O
!	O
z	int
)	O
{	O
s	int
+=	O
2	int
;	O
z	int
=	O
y	int
>>	O
2	int
;	O
}	O
return	O
(	O
z	int
&	O
1	int
)	O
?	O
s	int
:	O
s	int
+	O
1	int
;	O
}	O
plong	int
vali	O
(	O
x	int
)	O
GEN	O
x	int
;	O
{	O
plong	int
i	O
,	O
lx	O
=	O
lgef	O
(	O
x	int
)	O
;	O
if	O
(	O
!	O
signe	O
(	O
x	int
)	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	O
=	O
lx	O
-	O
1	int
;	O
(	O
i	O
>=	O
2	int
)	O
&&	O
(	O
!	O
x	int
[	O
i	O
]	O
)	O
;	O
i	O
--	O
)	O
;	O
return	O
(	O
(	O
lx	O
-	O
1	int
-	O
i	O
)	O
<<	O
5	int
)	O
+	O
vals	function
(	O
x	int
[	O
i	O
]	O
)	O
;	O
}	O
GEN	O
dvmdss	O
(	O
x	int
,	O
y	int
,	O
z	int
)	O
plong	int
x	int
,	O
y	int
;	O
GEN	O
*	O
z	int
;	O
{	O
GEN	O
p1	int
;	O
p1	int
=	O
divss	function
(	O
x	int
,	O
y	int
)	O
;	O
*	O
z	int
=	O
stoi	function
(	O
hiremainder	O
)	O
;	O
return	O
p1	int
;	O
}	O
GEN	O
dvmdsi	O
(	O
x	int
,	O
y	int
,	O
z	int
)	O
plong	int
x	int
;	O
GEN	O
y	int
,	O
*	O
z	int
;	O
{	O
GEN	O
p1	int
;	O
p1	int
=	O
divsi	O
(	O
x	int
,	O
y	int
)	O
;	O
*	O
z	int
=	O
stoi	function
(	O
hiremainder	O
)	O
;	O
return	O
p1	int
;	O
}	O
GEN	O
dvmdis	O
(	O
x	int
,	O
y	int
,	O
z	int
)	O
plong	int
y	int
;	O
GEN	O
x	int
,	O
*	O
z	int
;	O
{	O
GEN	O
p1	int
;	O
p1	int
=	O
divis	O
(	O
x	int
,	O
y	int
)	O
;	O
*	O
z	int
=	O
stoi	function
(	O
hiremainder	O
)	O
;	O
return	O
p1	int
;	O
}	O
GEN	O
ressi	O
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
;	O
GEN	O
y	int
;	O
{	O
divsi	O
(	O
x	int
,	O
y	int
)	O
;	O
return	O
stoi	function
(	O
hiremainder	O
)	O
;	O
}	O
GEN	O
modsi	O
(	O
x	int
,	O
y	int
)	O
plong	int
x	int
;	O
GEN	O
y	int
;	O
{	O
plong	int
s	int
;	O
GEN	O
p1	int
;	O
divsi	O
(	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
!	O
hiremainder	O
)	O
return	O
gzero	O
;	O
if	O
(	O
x	int
>	O
0	int
)	O
return	O
stoi	function
(	O
hiremainder	O
)	O
;	O
else	O
{	O
s	int
=	O
signe	O
(	O
y	int
)	O
;	O
setsigne	O
(	O
y	int
,	O
1	int
)	O
;	O
p1	int
=	O
addsi	function
(	O
hiremainder	O
,	O
y	int
)	O
;	O
setsigne	O
(	O
y	int
,	O
s	int
)	O
;	O
return	O
p1	int
;	O
}	O
}	O
GEN	O
modis	O
(	O
x	int
,	O
y	int
)	O
plong	int
y	int
;	O
GEN	O
x	int
;	O
{	O
divis	O
(	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
!	O
hiremainder	O
)	O
return	O
gzero	O
;	O
return	O
(	O
signe	O
(	O
x	int
)	O
>	O
0	int
)	O
?	O
stoi	function
(	O
hiremainder	O
)	O
:	O
stoi	function
(	O
abs	O
(	O
y	int
)	O
+	O
hiremainder	O
)	O
;	O
}	O
GEN	O
resis	O
(	O
x	int
,	O
y	int
)	O
plong	int
y	int
;	O
GEN	O
x	int
;	O
{	O
divis	O
(	O
x	int
,	O
y	int
)	O
;	O
return	O
stoi	function
(	O
hiremainder	O
)	O
;	O
}	O
GEN	O
modii	O
(	O
x	int
,	O
y	int
)	O
GEN	O
x	int
,	O
y	int
;	O
{	O
plong	int
av	O
=	O
avma	O
,	O
tetpil	O
;	O
GEN	O
p1	int
;	O
p1	int
=	O
dvmdii	O
(	O
x	int
,	O
y	int
,	O
-	O
1	int
)	O
;	O
if	O
(	O
signe	O
(	O
p1	int
)	O
>=	O
0	int
)	O
return	O
p1	int
;	O
tetpil	O
=	O
avma	O
;	O
p1	int
=	O
(	O
signe	O
(	O
y	int
)	O
>	O
0	int
)	O
?	O
addii	function
(	O
p1	int
,	O
y	int
)	O
:	O
subii	O
(	O
p1	int
,	O
y	int
)	O
;	O
return	O
gerepile	O
(	O
av	O
,	O
tetpil	O
,	O
p1	int
)	O
;	O
}	O
int	O
mpdivis	O
(	O
x	int
,	O
y	int
,	O
z	int
)	O
GEN	O
x	int
,	O
y	int
,	O
z	int
;	O
{	O
plong	int
av	O
=	O
avma	O
;	O
GEN	O
p1	int
,	O
p2	O
;	O
p1	int
=	O
dvmdii	O
(	O
x	int
,	O
y	int
,	O
&	O
p2	O
)	O
;	O
if	O
(	O
signe	O
(	O
p2	O
)	O
)	O
{	O
avma	O
=	O
av	O
;	O
return	O
0	int
;	O
}	O
affii	O
(	O
p1	int
,	O
z	int
)	O
;	O
avma	O
=	O
av	O
;	O
return	O
1	int
;	O
}	O
int	O
divise	O
(	O
x	int
,	O
y	int
)	O
GEN	O
x	int
,	O
y	int
;	O
{	O
plong	int
av	O
=	O
avma	O
;	O
GEN	O
p1	int
;	O
p1	int
=	O
dvmdii	O
(	O
x	int
,	O
y	int
,	O
-	O
1	int
)	O
;	O
avma	O
=	O
av	O
;	O
return	O
signe	O
(	O
p1	int
)	O
?	O
0	int
:	O
1	int
;	O
}	O
GEN	O
gerepile	O
(	O
l	O
,	O
p	O
,	O
q	O
)	O
GEN	O
l	O
,	O
p	O
,	O
q	O
;	O
{	O
plong	int
av	O
,	O
declg	O
,	O
tl	O
;	O
GEN	O
ll	O
,	O
pp	O
,	O
l1	O
,	O
l2	O
,	O
l3	O
;	O
declg	O
=	O
(	O
plong	int
)	O
l	O
-	O
(	O
plong	int
)	O
p	O
;	O
if	O
(	O
declg	O
<=	O
0	int
)	O
return	O
q	O
;	O
for	O
(	O
ll	O
=	O
l	O
,	O
pp	O
=	O
p	O
;	O
pp	O
>	O
(	O
GEN	O
)	O
avma	O
;	O
)	O
*	O
--	O
ll	O
=	O
*	O
--	O
pp	O
;	O
av	O
=	O
(	O
plong	int
)	O
ll	O
;	O
while	O
(	O
(	O
ll	O
<	O
l	O
)	O
||	O
(	O
(	O
ll	O
==	O
l	O
)	O
&&	O
(	O
plong	int
)	O
q	O
)	O
)	O
{	O
l2	O
=	O
ll	O
+	O
lontyp	O
[	O
tl	O
=	O
typ	O
(	O
ll	O
)	O
]	O
;	O
if	O
(	O
tl	O
==	O
10	int
)	O
{	O
l3	O
=	O
ll	O
+	O
lgef	O
(	O
ll	O
)	O
;	O
ll	O
+=	O
lg	O
(	O
ll	O
)	O
;	O
if	O
(	O
l3	O
>	O
ll	O
)	O
l3	O
=	O
l2	O
;	O
}	O
else	O
{	O
ll	O
+=	O
lg	O
(	O
ll	O
)	O
;	O
l3	O
=	O
ll	O
;	O
}	O
for	O
(	O
;	O
l2	O
<	O
l3	O
;	O
l2	O
++	O
)	O
{	O
l1	O
=	O
(	O
GEN	O
)	O
(	O
*	O
l2	O
)	O
;	O
if	O
(	O
(	O
l1	O
<	O
l	O
)	O
&&	O
(	O
l1	O
>=	O
(	O
GEN	O
)	O
avma	O
)	O
)	O
{	O
if	O
(	O
l1	O
<	O
p	O
)	O
*	O
l2	O
+=	O
declg	O
;	O
else	O
if	O
(	O
ll	O
<=	O
l	O
)	O
err	function
(	O
gerper	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
!	O
(	O
(	O
plong	int
)	O
q	O
)	O
)	O
||	O
(	O
(	O
q	O
<	O
p	O
)	O
&&	O
(	O
q	O
>=	O
(	O
GEN	O
)	O
avma	O
)	O
)	O
)	O
{	O
avma	O
=	O
av	O
;	O
return	O
q	O
+	O
(	O
declg	O
>>	O
2	int
)	O
;	O
}	O
else	O
{	O
avma	O
=	O
av	O
;	O
return	O
q	O
;	O
}	O
}	O
void	O
cgiv	O
(	O
x	int
)	O
GEN	O
x	int
;	O
{	O
plong	int
p	O
;	O
if	O
(	O
(	O
p	O
=	O
pere	O
(	O
x	int
)	O
)	O
==	O
255	int
)	O
return	O
;	O
if	O
(	O
(	O
x	int
!=	O
(	O
GEN	O
)	O
avma	O
)	O
||	O
(	O
p	O
>	O
1	int
)	O
)	O
{	O
setpere	O
(	O
x	int
,	O
p	O
-	O
1	int
)	O
;	O
return	O
;	O
}	O
do	O
x	int
+=	O
lg	O
(	O
x	int
)	O
;	O
while	O
(	O
!	O
pere	O
(	O
x	int
)	O
)	O
;	O
avma	O
=	O
(	O
plong	int
)	O
x	int
;	O
return	O
;	O
}	O
