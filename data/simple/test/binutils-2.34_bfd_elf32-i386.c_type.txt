static	O
reloc_howto_type	struct
elf_howto_table	array
[	O
]	O
=	O
{	O
HOWTO	O
(	O
R_386_NONE	int
,	O
0	int
,	O
3	int
,	O
0	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_dont	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_NONE"	pointer
,	O
TRUE	int
,	O
0x00000000	int
,	O
0x00000000	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_32"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_PC32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_PC32"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_386_GOT32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_GOT32"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_PLT32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_PLT32"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_386_COPY	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_COPY"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_GLOB_DAT	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_GLOB_DAT"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_JUMP_SLOT	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_JUMP_SLOT"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_RELATIVE	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_RELATIVE"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_GOTOFF	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_GOTOFF"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_GOTPC	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_GOTPC"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_TPOFF	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_TPOFF"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_IE	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_IE"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_GOTIE	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_GOTIE"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_LE	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_LE"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_GD	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_GD"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_LDM	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_LDM"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_16	int
,	O
0	int
,	O
1	int
,	O
16	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_16"	pointer
,	O
TRUE	int
,	O
0xffff	int
,	O
0xffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_PC16	int
,	O
0	int
,	O
1	int
,	O
16	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_PC16"	pointer
,	O
TRUE	int
,	O
0xffff	int
,	O
0xffff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_386_8	int
,	O
0	int
,	O
0	int
,	O
8	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_8"	pointer
,	O
TRUE	int
,	O
0xff	int
,	O
0xff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_PC8	int
,	O
0	int
,	O
0	int
,	O
8	int
,	O
TRUE	int
,	O
0	int
,	O
complain_overflow_signed	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_PC8"	pointer
,	O
TRUE	int
,	O
0xff	int
,	O
0xff	int
,	O
TRUE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_LDO_32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_LDO_32"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_IE_32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_IE_32"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_LE_32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_LE_32"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_DTPMOD32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_DTPMOD32"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_DTPOFF32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_DTPOFF32"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_TPOFF32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_TPOFF32"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_SIZE32	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_unsigned	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_SIZE32"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_GOTDESC	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_GOTDESC"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_DESC_CALL	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_dont	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_DESC_CALL"	pointer
,	O
FALSE	int
,	O
0	int
,	O
0	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_TLS_DESC	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_TLS_DESC"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_IRELATIVE	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_IRELATIVE"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_GOT32X	int
,	O
0	int
,	O
2	int
,	O
32	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_bitfield	int
,	O
bfd_elf_generic_reloc	function
,	O
"R_386_GOT32X"	pointer
,	O
TRUE	int
,	O
0xffffffff	int
,	O
0xffffffff	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_GNU_VTINHERIT	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_dont	int
,	O
NULL	O
,	O
"R_386_GNU_VTINHERIT"	pointer
,	O
FALSE	int
,	O
0	int
,	O
0	int
,	O
FALSE	int
)	O
,	O
HOWTO	O
(	O
R_386_GNU_VTENTRY	int
,	O
0	int
,	O
2	int
,	O
0	int
,	O
FALSE	int
,	O
0	int
,	O
complain_overflow_dont	int
,	O
_bfd_elf_rel_vtable_reloc_fn	function
,	O
"R_386_GNU_VTENTRY"	pointer
,	O
FALSE	int
,	O
0	int
,	O
0	int
,	O
FALSE	int
)	O
}	O
;	O
static	O
reloc_howto_type	struct
*	O
elf_i386_reloc_type_lookup	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_reloc_code_real_type	enum
code	int
)	O
{	O
switch	O
(	O
code	int
)	O
{	O
case	O
BFD_RELOC_NONE	int
:	O
TRACE	O
(	O
"BFD_RELOC_NONE"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_NONE	int
]	O
;	O
case	O
BFD_RELOC_32	int
:	O
TRACE	O
(	O
"BFD_RELOC_32"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_32	int
]	O
;	O
case	O
BFD_RELOC_CTOR	int
:	O
TRACE	O
(	O
"BFD_RELOC_CTOR"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_32	int
]	O
;	O
case	O
BFD_RELOC_32_PCREL	int
:	O
TRACE	O
(	O
"BFD_RELOC_PC32"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_PC32	int
]	O
;	O
case	O
BFD_RELOC_386_GOT32	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_GOT32"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_GOT32	int
]	O
;	O
case	O
BFD_RELOC_386_PLT32	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_PLT32"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_PLT32	int
]	O
;	O
case	O
BFD_RELOC_386_COPY	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_COPY"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_COPY	int
]	O
;	O
case	O
BFD_RELOC_386_GLOB_DAT	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_GLOB_DAT"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_GLOB_DAT	int
]	O
;	O
case	O
BFD_RELOC_386_JUMP_SLOT	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_JUMP_SLOT"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_JUMP_SLOT	int
]	O
;	O
case	O
BFD_RELOC_386_RELATIVE	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_RELATIVE"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_RELATIVE	int
]	O
;	O
case	O
BFD_RELOC_386_GOTOFF	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_GOTOFF"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_GOTOFF	int
]	O
;	O
case	O
BFD_RELOC_386_GOTPC	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_GOTPC"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_GOTPC	int
]	O
;	O
case	O
BFD_RELOC_386_TLS_TPOFF	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_TPOFF"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_TPOFF	int
-	O
R_386_ext_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_IE	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_IE"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_IE	int
-	O
R_386_ext_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_GOTIE	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_GOTIE"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_GOTIE	int
-	O
R_386_ext_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_LE	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_LE"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_LE	int
-	O
R_386_ext_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_GD	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_GD"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_GD	int
-	O
R_386_ext_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_LDM	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_LDM"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_LDM	int
-	O
R_386_ext_offset	O
]	O
;	O
case	O
BFD_RELOC_16	int
:	O
TRACE	O
(	O
"BFD_RELOC_16"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_16	int
-	O
R_386_ext_offset	O
]	O
;	O
case	O
BFD_RELOC_16_PCREL	int
:	O
TRACE	O
(	O
"BFD_RELOC_16_PCREL"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_PC16	int
-	O
R_386_ext_offset	O
]	O
;	O
case	O
BFD_RELOC_8	int
:	O
TRACE	O
(	O
"BFD_RELOC_8"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_8	int
-	O
R_386_ext_offset	O
]	O
;	O
case	O
BFD_RELOC_8_PCREL	int
:	O
TRACE	O
(	O
"BFD_RELOC_8_PCREL"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_PC8	int
-	O
R_386_ext_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_LDO_32	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_LDO_32"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_LDO_32	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_IE_32	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_IE_32"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_IE_32	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_LE_32	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_LE_32"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_LE_32	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_DTPMOD32	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_DTPMOD32"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_DTPMOD32	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_DTPOFF32	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_DTPOFF32"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_DTPOFF32	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_TPOFF32	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_TPOFF32"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_TPOFF32	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_SIZE32	int
:	O
TRACE	O
(	O
"BFD_RELOC_SIZE32"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_SIZE32	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_GOTDESC	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_GOTDESC"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_GOTDESC	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_DESC_CALL	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_DESC_CALL"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_DESC_CALL	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_386_TLS_DESC	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_TLS_DESC"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_TLS_DESC	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_386_IRELATIVE	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_IRELATIVE"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_IRELATIVE	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_386_GOT32X	int
:	O
TRACE	O
(	O
"BFD_RELOC_386_GOT32X"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_GOT32X	int
-	O
R_386_tls_offset	O
]	O
;	O
case	O
BFD_RELOC_VTABLE_INHERIT	int
:	O
TRACE	O
(	O
"BFD_RELOC_VTABLE_INHERIT"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_GNU_VTINHERIT	int
-	O
R_386_vt_offset	O
]	O
;	O
case	O
BFD_RELOC_VTABLE_ENTRY	int
:	O
TRACE	O
(	O
"BFD_RELOC_VTABLE_ENTRY"	pointer
)	O
;	O
return	O
&	O
elf_howto_table	array
[	O
R_386_GNU_VTENTRY	int
-	O
R_386_vt_offset	O
]	O
;	O
default	O
:	O
TRACE	O
(	O
"Unknown"	pointer
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unsupported relocation type: %#x"	pointer
)	O
,	O
abfd	pointer
,	O
(	O
int	O
)	O
code	int
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
static	O
reloc_howto_type	struct
*	O
elf_i386_reloc_name_lookup	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
r_name	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
sizeof	O
(	O
elf_howto_table	array
)	O
/	O
sizeof	O
(	O
elf_howto_table	array
[	O
0	int
]	O
)	O
;	O
i	pointer
++	O
)	O
if	O
(	O
elf_howto_table	array
[	O
i	pointer
]	O
.	O
name	pointer
!=	O
NULL	O
&&	O
strcasecmp	function
(	O
elf_howto_table	array
[	O
i	pointer
]	O
.	O
name	pointer
,	O
r_name	pointer
)	O
==	O
0	int
)	O
return	O
&	O
elf_howto_table	array
[	O
i	pointer
]	O
;	O
return	O
NULL	O
;	O
}	O
static	O
reloc_howto_type	struct
*	O
elf_i386_rtype_to_howto	function
(	O
unsigned	O
r_type	int
)	O
{	O
unsigned	O
int	O
indx	long
;	O
if	O
(	O
(	O
indx	long
=	O
r_type	int
)	O
>=	O
R_386_standard	O
&&	O
(	O
(	O
indx	long
=	O
r_type	int
-	O
R_386_ext_offset	O
)	O
-	O
R_386_standard	O
>=	O
R_386_ext	O
-	O
R_386_standard	O
)	O
&&	O
(	O
(	O
indx	long
=	O
r_type	int
-	O
R_386_tls_offset	O
)	O
-	O
R_386_ext	O
>=	O
R_386_ext2	O
-	O
R_386_ext	O
)	O
&&	O
(	O
(	O
indx	long
=	O
r_type	int
-	O
R_386_vt_offset	O
)	O
-	O
R_386_ext2	O
>=	O
R_386_vt	O
-	O
R_386_ext2	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
elf_howto_table	array
[	O
indx	long
]	O
.	O
type	enum
!=	O
r_type	int
)	O
return	O
NULL	O
;	O
return	O
&	O
elf_howto_table	array
[	O
indx	long
]	O
;	O
}	O
static	O
bfd_boolean	int
elf_i386_info_to_howto_rel	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
arelent	struct
*	O
cache_ptr	pointer
,	O
Elf_Internal_Rela	struct
*	O
dst	pointer
)	O
{	O
unsigned	O
int	O
r_type	int
=	O
ELF32_R_TYPE	O
(	O
dst	pointer
->	O
r_info	array
)	O
;	O
if	O
(	O
(	O
cache_ptr	pointer
->	O
howto	pointer
=	O
elf_i386_rtype_to_howto	function
(	O
r_type	int
)	O
)	O
==	O
NULL	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unsupported relocation type %#x"	pointer
)	O
,	O
abfd	pointer
,	O
r_type	int
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_i386_is_local_label_name	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
name	pointer
[	O
1	int
]	O
==	O
'X'	O
)	O
return	O
TRUE	int
;	O
return	O
_bfd_elf_is_local_label_name	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
elf_i386_grok_prstatus	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
int	O
offset	long
;	O
size_t	long
size	long
;	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
8	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"FreeBSD"	pointer
)	O
==	O
0	int
)	O
{	O
int	O
pr_version	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
)	O
;	O
if	O
(	O
pr_version	int
!=	O
1	int
)	O
return	O
FALSE	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
20	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
24	int
)	O
;	O
offset	long
=	O
28	int
;	O
size	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
8	int
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
note	pointer
->	O
descsz	array
)	O
{	O
default	O
:	O
return	O
FALSE	int
;	O
case	O
144	int
:	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
signal	int
=	O
bfd_get_16	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
12	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
lwpid	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
24	int
)	O
;	O
offset	long
=	O
72	int
;	O
size	long
=	O
68	int
;	O
break	O
;	O
}	O
}	O
return	O
_bfd_elfcore_make_pseudosection	function
(	O
abfd	pointer
,	O
".reg"	pointer
,	O
size	long
,	O
note	pointer
->	O
descpos	long
+	O
offset	long
)	O
;	O
}	O
static	O
bfd_boolean	int
elf_i386_grok_psinfo	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Note	struct
*	O
note	pointer
)	O
{	O
if	O
(	O
note	pointer
->	O
namesz	array
==	O
8	int
&&	O
strcmp	function
(	O
note	pointer
->	O
namedata	pointer
,	O
"FreeBSD"	pointer
)	O
==	O
0	int
)	O
{	O
int	O
pr_version	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
)	O
;	O
if	O
(	O
pr_version	int
!=	O
1	int
)	O
return	O
FALSE	int
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
program	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
8	int
,	O
17	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
25	int
,	O
81	int
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
note	pointer
->	O
descsz	array
)	O
{	O
default	O
:	O
return	O
FALSE	int
;	O
case	O
124	int
:	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
pid	int
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
12	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
program	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
28	int
,	O
16	int
)	O
;	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
=	O
_bfd_elfcore_strndup	function
(	O
abfd	pointer
,	O
note	pointer
->	O
descdata	pointer
+	O
44	int
,	O
80	int
)	O
;	O
}	O
}	O
{	O
char	O
*	O
command	pointer
=	O
elf_tdata	O
(	O
abfd	pointer
)	O
->	O
core	pointer
->	O
command	pointer
;	O
int	O
n	long
=	O
strlen	function
(	O
command	pointer
)	O
;	O
if	O
(	O
0	int
<	O
n	long
&&	O
command	pointer
[	O
n	long
-	O
1	int
]	O
==	O
' '	O
)	O
command	pointer
[	O
n	long
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
bfd_byte	char
elf_i386_lazy_plt0_entry	array
[	O
12	int
]	O
=	O
{	O
0xff	int
,	O
0x35	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xff	int
,	O
0x25	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_lazy_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xff	int
,	O
0x25	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x68	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xe9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_pic_lazy_plt0_entry	array
[	O
12	int
]	O
=	O
{	O
0xff	int
,	O
0xb3	int
,	O
4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xff	int
,	O
0xa3	int
,	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_pic_lazy_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xff	int
,	O
0xa3	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x68	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xe9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_non_lazy_plt_entry	array
[	O
NON_LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xff	int
,	O
0x25	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x90	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_pic_non_lazy_plt_entry	array
[	O
NON_LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xff	int
,	O
0xa3	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x90	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_lazy_ibt_plt0_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xff	int
,	O
0x35	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xff	int
,	O
0x25	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x40	int
,	O
0x00	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_lazy_ibt_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xf3	int
,	O
0x0f	int
,	O
0x1e	int
,	O
0xfb	int
,	O
0x68	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xe9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x90	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_pic_lazy_ibt_plt0_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xff	int
,	O
0xb3	int
,	O
4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xff	int
,	O
0xa3	int
,	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x40	int
,	O
0x00	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_non_lazy_ibt_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xf3	int
,	O
0x0f	int
,	O
0x1e	int
,	O
0xfb	int
,	O
0xff	int
,	O
0x25	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x44	int
,	O
0x00	int
,	O
0x00	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_pic_non_lazy_ibt_plt_entry	array
[	O
LAZY_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0xf3	int
,	O
0x0f	int
,	O
0x1e	int
,	O
0xfb	int
,	O
0xff	int
,	O
0xa3	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x66	int
,	O
0x0f	int
,	O
0x1f	int
,	O
0x44	int
,	O
0x00	int
,	O
0x00	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_eh_frame_lazy_plt	array
[	O
]	O
=	O
{	O
PLT_CIE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
'z'	O
,	O
'R'	O
,	O
0	int
,	O
1	int
,	O
0x7c	int
,	O
8	int
,	O
1	int
,	O
DW_EH_PE_pcrel	int
|	O
DW_EH_PE_sdata4	int
,	O
DW_CFA_def_cfa	int
,	O
4	int
,	O
4	int
,	O
DW_CFA_offset	int
+	O
8	int
,	O
1	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
PLT_FDE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
PLT_CIE_LENGTH	int
+	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DW_CFA_def_cfa_offset	int
,	O
8	int
,	O
DW_CFA_advance_loc	int
+	O
6	int
,	O
DW_CFA_def_cfa_offset	int
,	O
12	int
,	O
DW_CFA_advance_loc	int
+	O
10	int
,	O
DW_CFA_def_cfa_expression	int
,	O
11	int
,	O
DW_OP_breg4	int
,	O
4	int
,	O
DW_OP_breg8	int
,	O
0	int
,	O
DW_OP_lit15	int
,	O
DW_OP_and	int
,	O
DW_OP_lit11	int
,	O
DW_OP_ge	int
,	O
DW_OP_lit2	int
,	O
DW_OP_shl	int
,	O
DW_OP_plus	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_eh_frame_lazy_ibt_plt	array
[	O
]	O
=	O
{	O
PLT_CIE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
'z'	O
,	O
'R'	O
,	O
0	int
,	O
1	int
,	O
0x7c	int
,	O
8	int
,	O
1	int
,	O
DW_EH_PE_pcrel	int
|	O
DW_EH_PE_sdata4	int
,	O
DW_CFA_def_cfa	int
,	O
4	int
,	O
4	int
,	O
DW_CFA_offset	int
+	O
8	int
,	O
1	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
PLT_FDE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
PLT_CIE_LENGTH	int
+	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DW_CFA_def_cfa_offset	int
,	O
8	int
,	O
DW_CFA_advance_loc	int
+	O
6	int
,	O
DW_CFA_def_cfa_offset	int
,	O
12	int
,	O
DW_CFA_advance_loc	int
+	O
10	int
,	O
DW_CFA_def_cfa_expression	int
,	O
11	int
,	O
DW_OP_breg4	int
,	O
4	int
,	O
DW_OP_breg8	int
,	O
0	int
,	O
DW_OP_lit15	int
,	O
DW_OP_and	int
,	O
DW_OP_lit9	int
,	O
DW_OP_ge	int
,	O
DW_OP_lit2	int
,	O
DW_OP_shl	int
,	O
DW_OP_plus	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_eh_frame_non_lazy_plt	array
[	O
]	O
=	O
{	O
PLT_CIE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
'z'	O
,	O
'R'	O
,	O
0	int
,	O
1	int
,	O
0x7c	int
,	O
8	int
,	O
1	int
,	O
DW_EH_PE_pcrel	int
|	O
DW_EH_PE_sdata4	int
,	O
DW_CFA_def_cfa	int
,	O
4	int
,	O
4	int
,	O
DW_CFA_offset	int
+	O
8	int
,	O
1	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
PLT_GOT_FDE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
PLT_CIE_LENGTH	int
+	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
}	O
;	O
static	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
elf_i386_lazy_plt	struct
=	O
{	O
elf_i386_lazy_plt0_entry	array
,	O
sizeof	O
(	O
elf_i386_lazy_plt0_entry	array
)	O
,	O
elf_i386_lazy_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
8	int
,	O
0	int
,	O
2	int
,	O
7	int
,	O
12	int
,	O
0	int
,	O
0	int
,	O
6	int
,	O
elf_i386_pic_lazy_plt0_entry	array
,	O
elf_i386_pic_lazy_plt_entry	array
,	O
elf_i386_eh_frame_lazy_plt	array
,	O
sizeof	O
(	O
elf_i386_eh_frame_lazy_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_non_lazy_plt_layout	struct
elf_i386_non_lazy_plt	struct
=	O
{	O
elf_i386_non_lazy_plt_entry	array
,	O
elf_i386_pic_non_lazy_plt_entry	array
,	O
NON_LAZY_PLT_ENTRY_SIZE	int
,	O
2	int
,	O
0	int
,	O
elf_i386_eh_frame_non_lazy_plt	array
,	O
sizeof	O
(	O
elf_i386_eh_frame_non_lazy_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
elf_i386_lazy_ibt_plt	struct
=	O
{	O
elf_i386_lazy_ibt_plt0_entry	array
,	O
sizeof	O
(	O
elf_i386_lazy_ibt_plt0_entry	array
)	O
,	O
elf_i386_lazy_ibt_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
8	int
,	O
0	int
,	O
4	int
+	O
2	int
,	O
4	int
+	O
1	int
,	O
4	int
+	O
6	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
elf_i386_pic_lazy_ibt_plt0_entry	array
,	O
elf_i386_lazy_ibt_plt_entry	array
,	O
elf_i386_eh_frame_lazy_ibt_plt	array
,	O
sizeof	O
(	O
elf_i386_eh_frame_lazy_ibt_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_non_lazy_plt_layout	struct
elf_i386_non_lazy_ibt_plt	struct
=	O
{	O
elf_i386_non_lazy_ibt_plt_entry	array
,	O
elf_i386_pic_non_lazy_ibt_plt_entry	array
,	O
LAZY_PLT_ENTRY_SIZE	int
,	O
4	int
+	O
2	int
,	O
0	int
,	O
elf_i386_eh_frame_non_lazy_plt	array
,	O
sizeof	O
(	O
elf_i386_eh_frame_non_lazy_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_backend_data	struct
elf_i386_arch_bed	struct
=	O
{	O
is_normal	int
}	O
;	O
static	O
bfd_boolean	int
elf_i386_check_tls_transition	function
(	O
asection	struct
*	O
sec	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
,	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hashes	pointer
,	O
unsigned	O
int	O
r_type	int
,	O
const	O
Elf_Internal_Rela	struct
*	O
rel	pointer
,	O
const	O
Elf_Internal_Rela	struct
*	O
relend	pointer
)	O
{	O
unsigned	O
int	O
val	array
,	O
type	enum
,	O
reg	int
;	O
unsigned	O
long	O
r_symndx	long
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
bfd_vma	long
offset	long
;	O
bfd_byte	char
*	O
call	pointer
;	O
bfd_boolean	int
indirect_call	int
;	O
offset	long
=	O
rel	pointer
->	O
r_offset	array
;	O
switch	O
(	O
r_type	int
)	O
{	O
case	O
R_386_TLS_GD	int
:	O
case	O
R_386_TLS_LDM	int
:	O
if	O
(	O
offset	long
<	O
2	int
||	O
(	O
rel	pointer
+	O
1	int
)	O
>=	O
relend	pointer
)	O
return	O
FALSE	int
;	O
indirect_call	int
=	O
FALSE	int
;	O
call	pointer
=	O
contents	pointer
+	O
offset	long
+	O
4	int
;	O
val	array
=	O
*	O
(	O
call	pointer
-	O
5	int
)	O
;	O
type	enum
=	O
*	O
(	O
call	pointer
-	O
6	int
)	O
;	O
if	O
(	O
r_type	int
==	O
R_386_TLS_GD	int
)	O
{	O
if	O
(	O
(	O
offset	long
+	O
10	int
)	O
>	O
sec	pointer
->	O
size	long
||	O
(	O
type	enum
!=	O
0x8d	int
&&	O
type	enum
!=	O
0x04	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
type	enum
==	O
0x04	int
)	O
{	O
if	O
(	O
offset	long
<	O
3	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
*	O
(	O
call	pointer
-	O
7	int
)	O
!=	O
0x8d	int
||	O
val	array
!=	O
0x1d	int
||	O
call	pointer
[	O
0	int
]	O
!=	O
0xe8	int
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
reg	int
=	O
val	array
&	O
7	int
;	O
if	O
(	O
(	O
val	array
&	O
0xf8	int
)	O
!=	O
0x80	int
||	O
reg	int
==	O
4	int
||	O
reg	int
==	O
0	int
)	O
return	O
FALSE	int
;	O
indirect_call	int
=	O
call	pointer
[	O
0	int
]	O
==	O
0xff	int
;	O
if	O
(	O
!	O
(	O
reg	int
==	O
3	int
&&	O
call	pointer
[	O
0	int
]	O
==	O
0xe8	int
&&	O
call	pointer
[	O
5	int
]	O
==	O
0x90	int
)	O
&&	O
!	O
(	O
call	pointer
[	O
0	int
]	O
==	O
0x67	int
&&	O
call	pointer
[	O
1	int
]	O
==	O
0xe8	int
)	O
&&	O
!	O
(	O
indirect_call	int
&&	O
(	O
call	pointer
[	O
1	int
]	O
&	O
0xf8	int
)	O
==	O
0x90	int
&&	O
(	O
call	pointer
[	O
1	int
]	O
&	O
0x7	int
)	O
==	O
reg	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
type	enum
!=	O
0x8d	int
||	O
(	O
offset	long
+	O
9	int
)	O
>	O
sec	pointer
->	O
size	long
)	O
return	O
FALSE	int
;	O
reg	int
=	O
val	array
&	O
7	int
;	O
if	O
(	O
(	O
val	array
&	O
0xf8	int
)	O
!=	O
0x80	int
||	O
reg	int
==	O
4	int
||	O
reg	int
==	O
0	int
)	O
return	O
FALSE	int
;	O
indirect_call	int
=	O
call	pointer
[	O
0	int
]	O
==	O
0xff	int
;	O
if	O
(	O
!	O
(	O
reg	int
==	O
3	int
&&	O
call	pointer
[	O
0	int
]	O
==	O
0xe8	int
)	O
&&	O
!	O
(	O
call	pointer
[	O
0	int
]	O
==	O
0x67	int
&&	O
call	pointer
[	O
1	int
]	O
==	O
0xe8	int
)	O
&&	O
!	O
(	O
indirect_call	int
&&	O
(	O
call	pointer
[	O
1	int
]	O
&	O
0xf8	int
)	O
==	O
0x90	int
&&	O
(	O
call	pointer
[	O
1	int
]	O
&	O
0x7	int
)	O
==	O
reg	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
r_symndx	long
=	O
ELF32_R_SYM	O
(	O
rel	pointer
[	O
1	int
]	O
.	O
r_info	array
)	O
;	O
if	O
(	O
r_symndx	long
<	O
symtab_hdr	struct
->	O
sh_info	array
)	O
return	O
FALSE	int
;	O
h	pointer
=	O
sym_hashes	pointer
[	O
r_symndx	long
-	O
symtab_hdr	struct
->	O
sh_info	array
]	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
||	O
!	O
(	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
)	O
->	O
tls_get_addr	int
)	O
return	O
FALSE	int
;	O
else	O
if	O
(	O
indirect_call	int
)	O
return	O
(	O
ELF32_R_TYPE	O
(	O
rel	pointer
[	O
1	int
]	O
.	O
r_info	array
)	O
==	O
R_386_GOT32X	int
)	O
;	O
else	O
return	O
(	O
ELF32_R_TYPE	O
(	O
rel	pointer
[	O
1	int
]	O
.	O
r_info	array
)	O
==	O
R_386_PC32	int
||	O
ELF32_R_TYPE	O
(	O
rel	pointer
[	O
1	int
]	O
.	O
r_info	array
)	O
==	O
R_386_PLT32	int
)	O
;	O
case	O
R_386_TLS_IE	int
:	O
if	O
(	O
offset	long
<	O
1	int
||	O
(	O
offset	long
+	O
4	int
)	O
>	O
sec	pointer
->	O
size	long
)	O
return	O
FALSE	int
;	O
val	array
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
1	int
)	O
;	O
if	O
(	O
val	array
==	O
0xa1	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
offset	long
<	O
2	int
)	O
return	O
FALSE	int
;	O
type	enum
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
2	int
)	O
;	O
return	O
(	O
(	O
type	enum
==	O
0x8b	int
||	O
type	enum
==	O
0x03	int
)	O
&&	O
(	O
val	array
&	O
0xc7	int
)	O
==	O
0x05	int
)	O
;	O
case	O
R_386_TLS_GOTIE	int
:	O
case	O
R_386_TLS_IE_32	int
:	O
if	O
(	O
offset	long
<	O
2	int
||	O
(	O
offset	long
+	O
4	int
)	O
>	O
sec	pointer
->	O
size	long
)	O
return	O
FALSE	int
;	O
val	array
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
1	int
)	O
;	O
if	O
(	O
(	O
val	array
&	O
0xc0	int
)	O
!=	O
0x80	int
||	O
(	O
val	array
&	O
7	int
)	O
==	O
4	int
)	O
return	O
FALSE	int
;	O
type	enum
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
2	int
)	O
;	O
return	O
type	enum
==	O
0x8b	int
||	O
type	enum
==	O
0x2b	int
||	O
type	enum
==	O
0x03	int
;	O
case	O
R_386_TLS_GOTDESC	int
:	O
if	O
(	O
offset	long
<	O
2	int
||	O
(	O
offset	long
+	O
4	int
)	O
>	O
sec	pointer
->	O
size	long
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
2	int
)	O
!=	O
0x8d	int
)	O
return	O
FALSE	int
;	O
val	array
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
offset	long
-	O
1	int
)	O
;	O
return	O
(	O
val	array
&	O
0xc7	int
)	O
==	O
0x83	int
;	O
case	O
R_386_TLS_DESC_CALL	int
:	O
if	O
(	O
offset	long
+	O
2	int
<=	O
sec	pointer
->	O
size	long
)	O
{	O
call	pointer
=	O
contents	pointer
+	O
offset	long
;	O
return	O
call	pointer
[	O
0	int
]	O
==	O
0xff	int
&&	O
call	pointer
[	O
1	int
]	O
==	O
0x10	int
;	O
}	O
return	O
FALSE	int
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
elf_i386_tls_transition	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
,	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hashes	pointer
,	O
unsigned	O
int	O
*	O
r_type	int
,	O
int	O
tls_type	char
,	O
const	O
Elf_Internal_Rela	struct
*	O
rel	pointer
,	O
const	O
Elf_Internal_Rela	struct
*	O
relend	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
unsigned	O
long	O
r_symndx	long
,	O
bfd_boolean	int
from_relocate_section	int
)	O
{	O
unsigned	O
int	O
from_type	int
=	O
*	O
r_type	int
;	O
unsigned	O
int	O
to_type	int
=	O
from_type	int
;	O
bfd_boolean	int
check	int
=	O
TRUE	int
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
type	enum
==	O
STT_FUNC	int
||	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
)	O
)	O
return	O
TRUE	int
;	O
switch	O
(	O
from_type	int
)	O
{	O
case	O
R_386_TLS_GD	int
:	O
case	O
R_386_TLS_GOTDESC	int
:	O
case	O
R_386_TLS_DESC_CALL	int
:	O
case	O
R_386_TLS_IE_32	int
:	O
case	O
R_386_TLS_IE	int
:	O
case	O
R_386_TLS_GOTIE	int
:	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
{	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
to_type	int
=	O
R_386_TLS_LE_32	int
;	O
else	O
if	O
(	O
from_type	int
!=	O
R_386_TLS_IE	int
&&	O
from_type	int
!=	O
R_386_TLS_GOTIE	int
)	O
to_type	int
=	O
R_386_TLS_IE_32	int
;	O
}	O
if	O
(	O
from_relocate_section	int
)	O
{	O
unsigned	O
int	O
new_to_type	int
=	O
to_type	int
;	O
if	O
(	O
TLS_TRANSITION_IE_TO_LE_P	O
(	O
info	pointer
,	O
h	pointer
,	O
tls_type	char
)	O
)	O
new_to_type	int
=	O
R_386_TLS_LE_32	int
;	O
if	O
(	O
to_type	int
==	O
R_386_TLS_GD	int
||	O
to_type	int
==	O
R_386_TLS_GOTDESC	int
||	O
to_type	int
==	O
R_386_TLS_DESC_CALL	int
)	O
{	O
if	O
(	O
tls_type	char
==	O
GOT_TLS_IE_POS	int
)	O
new_to_type	int
=	O
R_386_TLS_GOTIE	int
;	O
else	O
if	O
(	O
tls_type	char
&	O
GOT_TLS_IE	int
)	O
new_to_type	int
=	O
R_386_TLS_IE_32	int
;	O
}	O
check	int
=	O
new_to_type	int
!=	O
to_type	int
&&	O
from_type	int
==	O
to_type	int
;	O
to_type	int
=	O
new_to_type	int
;	O
}	O
break	O
;	O
case	O
R_386_TLS_LDM	int
:	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
to_type	int
=	O
R_386_TLS_LE_32	int
;	O
break	O
;	O
default	O
:	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
from_type	int
==	O
to_type	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
check	int
&&	O
!	O
elf_i386_check_tls_transition	function
(	O
sec	pointer
,	O
contents	pointer
,	O
symtab_hdr	struct
,	O
sym_hashes	pointer
,	O
from_type	int
,	O
rel	pointer
,	O
relend	pointer
)	O
)	O
{	O
reloc_howto_type	struct
*	O
from	pointer
,	O
*	O
to	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
from	pointer
=	O
elf_i386_rtype_to_howto	function
(	O
from_type	int
)	O
;	O
to	pointer
=	O
elf_i386_rtype_to_howto	function
(	O
to_type	int
)	O
;	O
if	O
(	O
h	pointer
)	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
else	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
I386_ELF_DATA	int
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
name	pointer
=	O
"*unknown*"	pointer
;	O
else	O
{	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
isym	pointer
=	O
bfd_sym_from_r_symndx	function
(	O
&	O
htab	struct
->	O
sym_cache	struct
,	O
abfd	pointer
,	O
r_symndx	long
)	O
;	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
abfd	pointer
,	O
symtab_hdr	struct
,	O
isym	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: TLS transition from %s to %s against `%s'"	pointer
" at %#"	pointer
PRIx64	O
" in section `%pA' failed"	pointer
)	O
,	O
abfd	pointer
,	O
from	pointer
->	O
name	pointer
,	O
to	pointer
->	O
name	pointer
,	O
name	pointer
,	O
(	O
uint64_t	long
)	O
rel	pointer
->	O
r_offset	array
,	O
sec	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
*	O
r_type	int
=	O
to_type	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_i386_convert_load_reloc	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
,	O
bfd_byte	char
*	O
contents	pointer
,	O
unsigned	O
int	O
*	O
r_type_p	pointer
,	O
Elf_Internal_Rela	struct
*	O
irel	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
bfd_boolean	int
*	O
converted	pointer
,	O
struct	O
bfd_link_info	struct
*	O
link_info	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
unsigned	O
int	O
opcode	int
;	O
unsigned	O
int	O
modrm	int
;	O
bfd_boolean	int
baseless	int
;	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
unsigned	O
int	O
addend	long
;	O
unsigned	O
int	O
nop	int
;	O
bfd_vma	long
nop_offset	long
;	O
bfd_boolean	int
is_pic	int
;	O
bfd_boolean	int
to_reloc_32	int
;	O
unsigned	O
int	O
r_type	int
;	O
unsigned	O
int	O
r_symndx	long
;	O
bfd_vma	long
roff	long
=	O
irel	pointer
->	O
r_offset	array
;	O
bfd_boolean	int
local_ref	int
;	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
;	O
if	O
(	O
roff	long
<	O
2	int
)	O
return	O
TRUE	int
;	O
addend	long
=	O
bfd_get_32	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
roff	long
)	O
;	O
if	O
(	O
addend	long
!=	O
0	int
)	O
return	O
TRUE	int
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
link_info	pointer
,	O
I386_ELF_DATA	int
)	O
;	O
is_pic	int
=	O
bfd_link_pic	O
(	O
link_info	pointer
)	O
;	O
r_type	int
=	O
*	O
r_type_p	pointer
;	O
r_symndx	long
=	O
ELF32_R_SYM	O
(	O
irel	pointer
->	O
r_info	array
)	O
;	O
modrm	int
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
baseless	int
=	O
(	O
modrm	int
&	O
0xc7	int
)	O
==	O
0x5	int
;	O
if	O
(	O
baseless	int
&&	O
is_pic	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
isym	pointer
=	O
bfd_sym_from_r_symndx	function
(	O
&	O
htab	struct
->	O
sym_cache	struct
,	O
abfd	pointer
,	O
r_symndx	long
)	O
;	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
abfd	pointer
,	O
symtab_hdr	struct
,	O
isym	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: direct GOT relocation R_386_GOT32X against `%s' without base"	pointer
" register can not be used when making a shared object"	pointer
)	O
,	O
abfd	pointer
,	O
name	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
opcode	int
=	O
bfd_get_8	O
(	O
abfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
2	int
)	O
;	O
to_reloc_32	int
=	O
!	O
is_pic	int
||	O
baseless	int
;	O
eh	pointer
=	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
opcode	int
==	O
0x0ff	int
)	O
goto	O
convert_branch	O
;	O
else	O
goto	O
convert_load	O
;	O
}	O
local_ref	int
=	O
SYMBOL_REFERENCES_LOCAL_P	O
(	O
link_info	pointer
,	O
h	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
&&	O
!	O
eh	pointer
->	O
linker_def	int
&&	O
local_ref	int
)	O
{	O
if	O
(	O
opcode	int
==	O
0xff	int
)	O
{	O
if	O
(	O
is_pic	int
)	O
return	O
TRUE	int
;	O
else	O
goto	O
convert_branch	O
;	O
}	O
else	O
{	O
to_reloc_32	int
=	O
TRUE	int
;	O
goto	O
convert_load	O
;	O
}	O
}	O
if	O
(	O
opcode	int
==	O
0xff	int
)	O
{	O
if	O
(	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
local_ref	int
)	O
{	O
convert_branch	O
:	O
if	O
(	O
modrm	int
==	O
0x15	int
||	O
(	O
modrm	int
&	O
0xf8	int
)	O
==	O
0x90	int
)	O
{	O
modrm	int
=	O
0xe8	int
;	O
if	O
(	O
eh	pointer
&&	O
eh	pointer
->	O
tls_get_addr	int
)	O
{	O
nop	int
=	O
0x67	int
;	O
nop_offset	long
=	O
irel	pointer
->	O
r_offset	array
-	O
2	int
;	O
}	O
else	O
{	O
nop	int
=	O
htab	struct
->	O
params	pointer
->	O
call_nop_byte	char
;	O
if	O
(	O
htab	struct
->	O
params	pointer
->	O
call_nop_as_suffix	int
)	O
{	O
nop_offset	long
=	O
roff	long
+	O
3	int
;	O
irel	pointer
->	O
r_offset	array
-=	O
1	int
;	O
}	O
else	O
nop_offset	long
=	O
roff	long
-	O
2	int
;	O
}	O
}	O
else	O
{	O
modrm	int
=	O
0xe9	int
;	O
nop	int
=	O
NOP_OPCODE	O
;	O
nop_offset	long
=	O
roff	long
+	O
3	int
;	O
irel	pointer
->	O
r_offset	array
-=	O
1	int
;	O
}	O
bfd_put_8	O
(	O
abfd	pointer
,	O
nop	int
,	O
contents	pointer
+	O
nop_offset	long
)	O
;	O
bfd_put_8	O
(	O
abfd	pointer
,	O
modrm	int
,	O
contents	pointer
+	O
irel	pointer
->	O
r_offset	array
-	O
1	int
)	O
;	O
bfd_put_32	O
(	O
abfd	pointer
,	O
-	O
4	int
,	O
contents	pointer
+	O
irel	pointer
->	O
r_offset	array
)	O
;	O
irel	pointer
->	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
r_symndx	long
,	O
R_386_PC32	int
)	O
;	O
*	O
r_type_p	pointer
=	O
R_386_PC32	int
;	O
*	O
converted	pointer
=	O
TRUE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
h	pointer
==	O
htab	struct
->	O
elf	struct
.	O
hdynamic	pointer
)	O
return	O
TRUE	int
;	O
if	O
(	O
h	pointer
->	O
start_stop	int
||	O
eh	pointer
->	O
linker_def	int
||	O
(	O
(	O
h	pointer
->	O
def_regular	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
local_ref	int
)	O
)	O
{	O
convert_load	O
:	O
if	O
(	O
opcode	int
==	O
0x8b	int
)	O
{	O
if	O
(	O
to_reloc_32	int
)	O
{	O
r_type	int
=	O
R_386_32	int
;	O
modrm	int
=	O
0xc0	int
|	O
(	O
modrm	int
&	O
0x38	int
)	O
>>	O
3	int
;	O
bfd_put_8	O
(	O
abfd	pointer
,	O
modrm	int
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
opcode	int
=	O
0xc7	int
;	O
}	O
else	O
{	O
r_type	int
=	O
R_386_GOTOFF	int
;	O
opcode	int
=	O
0x8d	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
to_reloc_32	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
opcode	int
==	O
0x85	int
)	O
{	O
modrm	int
=	O
0xc0	int
|	O
(	O
modrm	int
&	O
0x38	int
)	O
>>	O
3	int
;	O
opcode	int
=	O
0xf7	int
;	O
}	O
else	O
{	O
modrm	int
=	O
(	O
0xc0	int
|	O
(	O
modrm	int
&	O
0x38	int
)	O
>>	O
3	int
|	O
(	O
opcode	int
&	O
0x3c	int
)	O
)	O
;	O
opcode	int
=	O
0x81	int
;	O
}	O
bfd_put_8	O
(	O
abfd	pointer
,	O
modrm	int
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
r_type	int
=	O
R_386_32	int
;	O
}	O
bfd_put_8	O
(	O
abfd	pointer
,	O
opcode	int
,	O
contents	pointer
+	O
roff	long
-	O
2	int
)	O
;	O
irel	pointer
->	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
r_symndx	long
,	O
r_type	int
)	O
;	O
*	O
r_type_p	pointer
=	O
r_type	int
;	O
*	O
converted	pointer
=	O
TRUE	int
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_i386_check_relocs	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
sec	pointer
,	O
const	O
Elf_Internal_Rela	struct
*	O
relocs	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hashes	pointer
;	O
const	O
Elf_Internal_Rela	struct
*	O
rel	pointer
;	O
const	O
Elf_Internal_Rela	struct
*	O
rel_end	pointer
;	O
asection	struct
*	O
sreloc	pointer
;	O
bfd_byte	char
*	O
contents	pointer
;	O
bfd_boolean	int
converted	pointer
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
)	O
return	O
TRUE	int
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
I386_ELF_DATA	int
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
{	O
sec	pointer
->	O
check_relocs_failed	O
=	O
1	int
;	O
return	O
FALSE	int
;	O
}	O
BFD_ASSERT	O
(	O
is_x86_elf	O
(	O
abfd	pointer
,	O
htab	struct
)	O
)	O
;	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
!=	O
NULL	O
)	O
contents	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
;	O
else	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
&	O
contents	pointer
)	O
)	O
{	O
sec	pointer
->	O
check_relocs_failed	O
=	O
1	int
;	O
return	O
FALSE	int
;	O
}	O
symtab_hdr	struct
=	O
&	O
elf_symtab_hdr	O
(	O
abfd	pointer
)	O
;	O
sym_hashes	pointer
=	O
elf_sym_hashes	O
(	O
abfd	pointer
)	O
;	O
converted	pointer
=	O
FALSE	int
;	O
sreloc	pointer
=	O
NULL	O
;	O
rel_end	pointer
=	O
relocs	pointer
+	O
sec	pointer
->	O
reloc_count	int
;	O
for	O
(	O
rel	pointer
=	O
relocs	pointer
;	O
rel	pointer
<	O
rel_end	pointer
;	O
rel	pointer
++	O
)	O
{	O
unsigned	O
int	O
r_type	int
;	O
unsigned	O
int	O
r_symndx	long
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
;	O
Elf_Internal_Sym	struct
*	O
isym	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
bfd_boolean	int
size_reloc	int
;	O
r_symndx	long
=	O
ELF32_R_SYM	O
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
r_type	int
=	O
ELF32_R_TYPE	O
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
if	O
(	O
r_symndx	long
>=	O
NUM_SHDR_ENTRIES	O
(	O
symtab_hdr	struct
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: bad symbol index: %d"	pointer
)	O
,	O
abfd	pointer
,	O
r_symndx	long
)	O
;	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
r_symndx	long
<	O
symtab_hdr	struct
->	O
sh_info	array
)	O
{	O
isym	pointer
=	O
bfd_sym_from_r_symndx	function
(	O
&	O
htab	struct
->	O
sym_cache	struct
,	O
abfd	pointer
,	O
r_symndx	long
)	O
;	O
if	O
(	O
isym	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
ELF32_ST_TYPE	O
(	O
isym	pointer
->	O
st_info	array
)	O
==	O
STT_GNU_IFUNC	int
)	O
{	O
h	pointer
=	O
_bfd_elf_x86_get_local_sym_hash	function
(	O
htab	struct
,	O
abfd	pointer
,	O
rel	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
=	O
bfd_elf_sym_name	function
(	O
abfd	pointer
,	O
symtab_hdr	struct
,	O
isym	pointer
,	O
NULL	O
)	O
;	O
h	pointer
->	O
type	enum
=	O
STT_GNU_IFUNC	int
;	O
h	pointer
->	O
def_regular	int
=	O
1	int
;	O
h	pointer
->	O
ref_regular	int
=	O
1	int
;	O
h	pointer
->	O
forced_local	int
=	O
1	int
;	O
h	pointer
->	O
root	struct
.	O
type	enum
=	O
bfd_link_hash_defined	int
;	O
}	O
else	O
h	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
isym	pointer
=	O
NULL	O
;	O
h	pointer
=	O
sym_hashes	pointer
[	O
r_symndx	long
-	O
symtab_hdr	struct
->	O
sh_info	array
]	O
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
}	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
r_type	int
==	O
R_386_GOTOFF	int
)	O
eh	pointer
->	O
gotoff_ref	int
=	O
1	int
;	O
h	pointer
->	O
ref_regular	int
=	O
1	int
;	O
}	O
if	O
(	O
r_type	int
==	O
R_386_GOT32X	int
&&	O
(	O
h	pointer
==	O
NULL	O
||	O
h	pointer
->	O
type	enum
!=	O
STT_GNU_IFUNC	int
)	O
)	O
{	O
Elf_Internal_Rela	struct
*	O
irel	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
rel	pointer
;	O
if	O
(	O
!	O
elf_i386_convert_load_reloc	function
(	O
abfd	pointer
,	O
symtab_hdr	struct
,	O
contents	pointer
,	O
&	O
r_type	int
,	O
irel	pointer
,	O
h	pointer
,	O
&	O
converted	pointer
,	O
info	pointer
)	O
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
!	O
elf_i386_tls_transition	function
(	O
info	pointer
,	O
abfd	pointer
,	O
sec	pointer
,	O
contents	pointer
,	O
symtab_hdr	struct
,	O
sym_hashes	pointer
,	O
&	O
r_type	int
,	O
GOT_UNKNOWN	int
,	O
rel	pointer
,	O
rel_end	pointer
,	O
h	pointer
,	O
r_symndx	long
,	O
FALSE	int
)	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
h	pointer
==	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
)	O
htab	struct
->	O
got_referenced	int
=	O
TRUE	int
;	O
switch	O
(	O
r_type	int
)	O
{	O
case	O
R_386_TLS_LDM	int
:	O
htab	struct
->	O
tls_ld_or_ldm_got	union
.	O
refcount	int
=	O
1	int
;	O
goto	O
create_got	O
;	O
case	O
R_386_PLT32	int
:	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
continue	O
;	O
eh	pointer
->	O
zero_undefweak	int
&=	O
0x2	int
;	O
h	pointer
->	O
needs_plt	int
=	O
1	int
;	O
h	pointer
->	O
plt	union
.	O
refcount	int
=	O
1	int
;	O
break	O
;	O
case	O
R_386_SIZE32	int
:	O
size_reloc	int
=	O
TRUE	int
;	O
goto	O
do_size	O
;	O
case	O
R_386_TLS_IE_32	int
:	O
case	O
R_386_TLS_IE	int
:	O
case	O
R_386_TLS_GOTIE	int
:	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
info	pointer
->	O
flags	int
|=	O
DF_STATIC_TLS	O
;	O
case	O
R_386_GOT32	int
:	O
case	O
R_386_GOT32X	int
:	O
case	O
R_386_TLS_GD	int
:	O
case	O
R_386_TLS_GOTDESC	int
:	O
case	O
R_386_TLS_DESC_CALL	int
:	O
{	O
int	O
tls_type	char
,	O
old_tls_type	int
;	O
switch	O
(	O
r_type	int
)	O
{	O
default	O
:	O
case	O
R_386_GOT32	int
:	O
case	O
R_386_GOT32X	int
:	O
tls_type	char
=	O
GOT_NORMAL	int
;	O
break	O
;	O
case	O
R_386_TLS_GD	int
:	O
tls_type	char
=	O
GOT_TLS_GD	int
;	O
break	O
;	O
case	O
R_386_TLS_GOTDESC	int
:	O
case	O
R_386_TLS_DESC_CALL	int
:	O
tls_type	char
=	O
GOT_TLS_GDESC	int
;	O
break	O
;	O
case	O
R_386_TLS_IE_32	int
:	O
if	O
(	O
ELF32_R_TYPE	O
(	O
rel	pointer
->	O
r_info	array
)	O
==	O
r_type	int
)	O
tls_type	char
=	O
GOT_TLS_IE_NEG	int
;	O
else	O
tls_type	char
=	O
GOT_TLS_IE	int
;	O
break	O
;	O
case	O
R_386_TLS_IE	int
:	O
case	O
R_386_TLS_GOTIE	int
:	O
tls_type	char
=	O
GOT_TLS_IE_POS	int
;	O
break	O
;	O
}	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
h	pointer
->	O
got	union
.	O
refcount	int
=	O
1	int
;	O
old_tls_type	int
=	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_type	char
;	O
}	O
else	O
{	O
bfd_signed_vma	long
*	O
local_got_refcounts	pointer
;	O
local_got_refcounts	pointer
=	O
elf_local_got_refcounts	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
local_got_refcounts	pointer
==	O
NULL	O
)	O
{	O
bfd_size_type	long
size	long
;	O
size	long
=	O
symtab_hdr	struct
->	O
sh_info	array
;	O
size	long
*=	O
(	O
sizeof	O
(	O
bfd_signed_vma	long
)	O
+	O
sizeof	O
(	O
bfd_vma	long
)	O
+	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
local_got_refcounts	pointer
=	O
(	O
bfd_signed_vma	long
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
size	long
)	O
;	O
if	O
(	O
local_got_refcounts	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
elf_local_got_refcounts	O
(	O
abfd	pointer
)	O
=	O
local_got_refcounts	pointer
;	O
elf_x86_local_tlsdesc_gotent	O
(	O
abfd	pointer
)	O
=	O
(	O
bfd_vma	long
*	O
)	O
(	O
local_got_refcounts	pointer
+	O
symtab_hdr	struct
->	O
sh_info	array
)	O
;	O
elf_x86_local_got_tls_type	O
(	O
abfd	pointer
)	O
=	O
(	O
char	O
*	O
)	O
(	O
local_got_refcounts	pointer
+	O
2	int
*	O
symtab_hdr	struct
->	O
sh_info	array
)	O
;	O
}	O
local_got_refcounts	pointer
[	O
r_symndx	long
]	O
=	O
1	int
;	O
old_tls_type	int
=	O
elf_x86_local_got_tls_type	O
(	O
abfd	pointer
)	O
[	O
r_symndx	long
]	O
;	O
}	O
if	O
(	O
(	O
old_tls_type	int
&	O
GOT_TLS_IE	int
)	O
&&	O
(	O
tls_type	char
&	O
GOT_TLS_IE	int
)	O
)	O
tls_type	char
|=	O
old_tls_type	int
;	O
else	O
if	O
(	O
old_tls_type	int
!=	O
tls_type	char
&&	O
old_tls_type	int
!=	O
GOT_UNKNOWN	int
&&	O
(	O
!	O
GOT_TLS_GD_ANY_P	O
(	O
old_tls_type	int
)	O
||	O
(	O
tls_type	char
&	O
GOT_TLS_IE	int
)	O
==	O
0	int
)	O
)	O
{	O
if	O
(	O
(	O
old_tls_type	int
&	O
GOT_TLS_IE	int
)	O
&&	O
GOT_TLS_GD_ANY_P	O
(	O
tls_type	char
)	O
)	O
tls_type	char
=	O
old_tls_type	int
;	O
else	O
if	O
(	O
GOT_TLS_GD_ANY_P	O
(	O
old_tls_type	int
)	O
&&	O
GOT_TLS_GD_ANY_P	O
(	O
tls_type	char
)	O
)	O
tls_type	char
|=	O
old_tls_type	int
;	O
else	O
{	O
if	O
(	O
h	pointer
)	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
else	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
abfd	pointer
,	O
symtab_hdr	struct
,	O
isym	pointer
,	O
NULL	O
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: `%s' accessed both as normal and "	pointer
"thread local symbol"	pointer
)	O
,	O
abfd	pointer
,	O
name	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
}	O
if	O
(	O
old_tls_type	int
!=	O
tls_type	char
)	O
{	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_type	char
=	O
tls_type	char
;	O
else	O
elf_x86_local_got_tls_type	O
(	O
abfd	pointer
)	O
[	O
r_symndx	long
]	O
=	O
tls_type	char
;	O
}	O
}	O
case	O
R_386_GOTOFF	int
:	O
case	O
R_386_GOTPC	int
:	O
create_got	O
:	O
if	O
(	O
r_type	int
!=	O
R_386_TLS_IE	int
)	O
{	O
if	O
(	O
eh	pointer
!=	O
NULL	O
)	O
{	O
eh	pointer
->	O
zero_undefweak	int
&=	O
0x2	int
;	O
if	O
(	O
r_type	int
==	O
R_386_GOTOFF	int
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
&&	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
htab	struct
->	O
got_referenced	int
=	O
TRUE	int
;	O
}	O
break	O
;	O
}	O
case	O
R_386_TLS_LE_32	int
:	O
case	O
R_386_TLS_LE	int
:	O
if	O
(	O
eh	pointer
!=	O
NULL	O
)	O
eh	pointer
->	O
zero_undefweak	int
&=	O
0x2	int
;	O
if	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
break	O
;	O
info	pointer
->	O
flags	int
|=	O
DF_STATIC_TLS	O
;	O
goto	O
do_relocation	O
;	O
case	O
R_386_32	int
:	O
case	O
R_386_PC32	int
:	O
if	O
(	O
eh	pointer
!=	O
NULL	O
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
!=	O
0	int
)	O
eh	pointer
->	O
zero_undefweak	int
|=	O
0x2	int
;	O
do_relocation	O
:	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
(	O
bfd_link_executable	O
(	O
info	pointer
)	O
||	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
)	O
)	O
{	O
bfd_boolean	int
func_pointer_ref	int
=	O
FALSE	int
;	O
if	O
(	O
r_type	int
==	O
R_386_PC32	int
)	O
{	O
if	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
)	O
h	pointer
->	O
pointer_equality_needed	int
=	O
1	int
;	O
else	O
if	O
(	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
&&	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: unsupported non-PIC call to IFUNC `%s'"	pointer
)	O
,	O
abfd	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
}	O
else	O
{	O
h	pointer
->	O
pointer_equality_needed	int
=	O
1	int
;	O
if	O
(	O
r_type	int
==	O
R_386_32	int
&&	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_READONLY	int
)	O
==	O
0	int
)	O
func_pointer_ref	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
func_pointer_ref	int
)	O
{	O
h	pointer
->	O
non_got_ref	int
=	O
1	int
;	O
if	O
(	O
!	O
h	pointer
->	O
def_regular	int
||	O
(	O
sec	pointer
->	O
flags	int
&	O
(	O
SEC_CODE	int
|	O
SEC_READONLY	int
)	O
)	O
!=	O
0	int
)	O
h	pointer
->	O
plt	union
.	O
refcount	int
=	O
1	int
;	O
}	O
}	O
size_reloc	int
=	O
FALSE	int
;	O
do_size	O
:	O
if	O
(	O
NEED_DYNAMIC_RELOCATION_P	O
(	O
info	pointer
,	O
FALSE	int
,	O
h	pointer
,	O
sec	pointer
,	O
r_type	int
,	O
R_386_32	int
)	O
)	O
{	O
struct	O
elf_dyn_relocs	struct
*	O
p	pointer
;	O
struct	O
elf_dyn_relocs	struct
*	O
*	O
head	pointer
;	O
if	O
(	O
sreloc	pointer
==	O
NULL	O
)	O
{	O
sreloc	pointer
=	O
_bfd_elf_make_dynamic_reloc_section	function
(	O
sec	pointer
,	O
htab	struct
->	O
elf	struct
.	O
dynobj	pointer
,	O
2	int
,	O
abfd	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
sreloc	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
head	pointer
=	O
&	O
eh	pointer
->	O
dyn_relocs	pointer
;	O
}	O
else	O
{	O
void	O
*	O
*	O
vpp	pointer
;	O
asection	struct
*	O
s	pointer
;	O
isym	pointer
=	O
bfd_sym_from_r_symndx	function
(	O
&	O
htab	struct
->	O
sym_cache	struct
,	O
abfd	pointer
,	O
r_symndx	long
)	O
;	O
if	O
(	O
isym	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
s	pointer
=	O
bfd_section_from_elf_index	function
(	O
abfd	pointer
,	O
isym	pointer
->	O
st_shndx	array
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
s	pointer
=	O
sec	pointer
;	O
vpp	pointer
=	O
&	O
elf_section_data	O
(	O
s	pointer
)	O
->	O
local_dynrel	pointer
;	O
head	pointer
=	O
(	O
struct	O
elf_dyn_relocs	struct
*	O
*	O
)	O
vpp	pointer
;	O
}	O
p	pointer
=	O
*	O
head	pointer
;	O
if	O
(	O
p	pointer
==	O
NULL	O
||	O
p	pointer
->	O
sec	pointer
!=	O
sec	pointer
)	O
{	O
bfd_size_type	long
amt	long
=	O
sizeof	O
*	O
p	pointer
;	O
p	pointer
=	O
(	O
struct	O
elf_dyn_relocs	struct
*	O
)	O
bfd_alloc	function
(	O
htab	struct
->	O
elf	struct
.	O
dynobj	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
p	pointer
->	O
next	pointer
=	O
*	O
head	pointer
;	O
*	O
head	pointer
=	O
p	pointer
;	O
p	pointer
->	O
sec	pointer
=	O
sec	pointer
;	O
p	pointer
->	O
count	int
=	O
0	int
;	O
p	pointer
->	O
pc_count	long
=	O
0	int
;	O
}	O
p	pointer
->	O
count	int
+=	O
1	int
;	O
if	O
(	O
r_type	int
==	O
R_386_PC32	int
||	O
size_reloc	int
)	O
p	pointer
->	O
pc_count	long
+=	O
1	int
;	O
}	O
break	O
;	O
case	O
R_386_GNU_VTINHERIT	int
:	O
if	O
(	O
!	O
bfd_elf_gc_record_vtinherit	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
h	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
)	O
goto	O
error_return	O
;	O
break	O
;	O
case	O
R_386_GNU_VTENTRY	int
:	O
if	O
(	O
!	O
bfd_elf_gc_record_vtentry	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
h	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
)	O
goto	O
error_return	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
!=	O
contents	pointer
)	O
{	O
if	O
(	O
!	O
converted	pointer
&&	O
!	O
info	pointer
->	O
keep_memory	int
)	O
free	function
(	O
contents	pointer
)	O
;	O
else	O
{	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
=	O
contents	pointer
;	O
}	O
}	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
relocs	pointer
!=	O
relocs	pointer
&&	O
converted	pointer
)	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
relocs	pointer
=	O
(	O
Elf_Internal_Rela	struct
*	O
)	O
relocs	pointer
;	O
return	O
TRUE	int
;	O
error_return	O
:	O
if	O
(	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_hdr	struct
.	O
contents	pointer
!=	O
contents	pointer
)	O
free	function
(	O
contents	pointer
)	O
;	O
sec	pointer
->	O
check_relocs_failed	O
=	O
1	int
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
elf_i386_fake_sections	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
Elf_Internal_Shdr	struct
*	O
hdr	pointer
,	O
asection	struct
*	O
sec	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
bfd_section_name	function
(	O
sec	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
".reloc"	pointer
)	O
==	O
0	int
)	O
hdr	pointer
->	O
sh_type	array
=	O
SHT_PROGBITS	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_vma	long
elf_i386_tpoff	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd_vma	long
address	long
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
;	O
bfd_vma	long
static_tls_size	long
;	O
if	O
(	O
htab	struct
->	O
tls_sec	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
static_tls_size	long
=	O
BFD_ALIGN	O
(	O
htab	struct
->	O
tls_size	long
,	O
bed	pointer
->	O
static_tls_alignment	int
)	O
;	O
return	O
static_tls_size	long
+	O
htab	struct
->	O
tls_sec	pointer
->	O
vma	long
-	O
address	long
;	O
}	O
static	O
bfd_boolean	int
elf_i386_relocate_section	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
asection	struct
*	O
input_section	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
Elf_Internal_Rela	struct
*	O
relocs	pointer
,	O
Elf_Internal_Sym	struct
*	O
local_syms	pointer
,	O
asection	struct
*	O
*	O
local_sections	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
Elf_Internal_Shdr	struct
*	O
symtab_hdr	struct
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
sym_hashes	pointer
;	O
bfd_vma	long
*	O
local_got_offsets	pointer
;	O
bfd_vma	long
*	O
local_tlsdesc_gotents	pointer
;	O
Elf_Internal_Rela	struct
*	O
rel	pointer
;	O
Elf_Internal_Rela	struct
*	O
wrel	pointer
;	O
Elf_Internal_Rela	struct
*	O
relend	pointer
;	O
bfd_boolean	int
is_vxworks_tls	int
;	O
unsigned	O
plt_entry_size	int
;	O
if	O
(	O
input_section	pointer
->	O
check_relocs_failed	O
)	O
return	O
FALSE	int
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
I386_ELF_DATA	int
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
is_x86_elf	O
(	O
input_bfd	pointer
,	O
htab	struct
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
symtab_hdr	struct
=	O
&	O
elf_symtab_hdr	O
(	O
input_bfd	pointer
)	O
;	O
sym_hashes	pointer
=	O
elf_sym_hashes	O
(	O
input_bfd	pointer
)	O
;	O
local_got_offsets	pointer
=	O
elf_local_got_offsets	O
(	O
input_bfd	pointer
)	O
;	O
local_tlsdesc_gotents	pointer
=	O
elf_x86_local_tlsdesc_gotent	O
(	O
input_bfd	pointer
)	O
;	O
is_vxworks_tls	int
=	O
(	O
htab	struct
->	O
target_os	enum
==	O
is_vxworks	int
&&	O
bfd_link_pic	O
(	O
info	pointer
)	O
&&	O
!	O
strcmp	function
(	O
input_section	pointer
->	O
output_section	pointer
->	O
name	pointer
,	O
".tls_vars"	pointer
)	O
)	O
;	O
_bfd_x86_elf_set_tls_module_base	function
(	O
info	pointer
)	O
;	O
plt_entry_size	int
=	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
;	O
rel	pointer
=	O
wrel	pointer
=	O
relocs	pointer
;	O
relend	pointer
=	O
relocs	pointer
+	O
input_section	pointer
->	O
reloc_count	int
;	O
for	O
(	O
;	O
rel	pointer
<	O
relend	pointer
;	O
wrel	pointer
++	O
,	O
rel	pointer
++	O
)	O
{	O
unsigned	O
int	O
r_type	int
,	O
r_type_tls	int
;	O
reloc_howto_type	struct
*	O
howto	pointer
;	O
unsigned	O
long	O
r_symndx	long
;	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
;	O
Elf_Internal_Sym	struct
*	O
sym	pointer
;	O
asection	struct
*	O
sec	pointer
;	O
bfd_vma	long
off	long
,	O
offplt	long
,	O
plt_offset	long
;	O
bfd_vma	long
relocation	pointer
;	O
bfd_boolean	int
unresolved_reloc	int
;	O
bfd_reloc_status_type	enum
r	enum
;	O
unsigned	O
int	O
indx	long
;	O
int	O
tls_type	char
;	O
bfd_vma	long
st_size	long
;	O
asection	struct
*	O
resolved_plt	pointer
;	O
bfd_boolean	int
resolved_to_zero	int
;	O
bfd_boolean	int
relative_reloc	int
;	O
r_type	int
=	O
ELF32_R_TYPE	O
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
if	O
(	O
r_type	int
==	O
R_386_GNU_VTINHERIT	int
||	O
r_type	int
==	O
R_386_GNU_VTENTRY	int
)	O
{	O
if	O
(	O
wrel	pointer
!=	O
rel	pointer
)	O
*	O
wrel	pointer
=	O
*	O
rel	pointer
;	O
continue	O
;	O
}	O
howto	pointer
=	O
elf_i386_rtype_to_howto	function
(	O
r_type	int
)	O
;	O
if	O
(	O
howto	pointer
==	O
NULL	O
)	O
return	O
_bfd_unrecognized_reloc	function
(	O
input_bfd	pointer
,	O
input_section	pointer
,	O
r_type	int
)	O
;	O
r_symndx	long
=	O
ELF32_R_SYM	O
(	O
rel	pointer
->	O
r_info	array
)	O
;	O
h	pointer
=	O
NULL	O
;	O
sym	pointer
=	O
NULL	O
;	O
sec	pointer
=	O
NULL	O
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
if	O
(	O
r_symndx	long
<	O
symtab_hdr	struct
->	O
sh_info	array
)	O
{	O
sym	pointer
=	O
local_syms	pointer
+	O
r_symndx	long
;	O
sec	pointer
=	O
local_sections	pointer
[	O
r_symndx	long
]	O
;	O
relocation	pointer
=	O
(	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
+	O
sym	pointer
->	O
st_value	array
)	O
;	O
st_size	long
=	O
sym	pointer
->	O
st_size	long
;	O
if	O
(	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
==	O
STT_SECTION	int
&&	O
(	O
(	O
sec	pointer
->	O
flags	int
&	O
SEC_MERGE	int
)	O
!=	O
0	int
||	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
sec	pointer
->	O
output_offset	long
!=	O
0	int
)	O
)	O
)	O
{	O
bfd_vma	long
addend	long
;	O
bfd_byte	char
*	O
where	long
=	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
;	O
switch	O
(	O
howto	pointer
->	O
size	long
)	O
{	O
case	O
0	int
:	O
addend	long
=	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
where	long
)	O
;	O
if	O
(	O
howto	pointer
->	O
pc_relative	int
)	O
{	O
addend	long
=	O
(	O
addend	long
^	O
0x80	int
)	O
-	O
0x80	int
;	O
addend	long
+=	O
1	int
;	O
}	O
break	O
;	O
case	O
1	int
:	O
addend	long
=	O
bfd_get_16	O
(	O
input_bfd	pointer
,	O
where	long
)	O
;	O
if	O
(	O
howto	pointer
->	O
pc_relative	int
)	O
{	O
addend	long
=	O
(	O
addend	long
^	O
0x8000	int
)	O
-	O
0x8000	int
;	O
addend	long
+=	O
2	int
;	O
}	O
break	O
;	O
case	O
2	int
:	O
addend	long
=	O
bfd_get_32	O
(	O
input_bfd	pointer
,	O
where	long
)	O
;	O
if	O
(	O
howto	pointer
->	O
pc_relative	int
)	O
{	O
addend	long
=	O
(	O
addend	long
^	O
0x80000000	int
)	O
-	O
0x80000000	int
;	O
addend	long
+=	O
4	int
;	O
}	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
addend	long
+=	O
sec	pointer
->	O
output_offset	long
;	O
else	O
{	O
asection	struct
*	O
msec	pointer
=	O
sec	pointer
;	O
addend	long
=	O
_bfd_elf_rel_local_sym	function
(	O
output_bfd	pointer
,	O
sym	pointer
,	O
&	O
msec	pointer
,	O
addend	long
)	O
;	O
addend	long
-=	O
relocation	pointer
;	O
addend	long
+=	O
msec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
msec	pointer
->	O
output_offset	long
;	O
}	O
switch	O
(	O
howto	pointer
->	O
size	long
)	O
{	O
case	O
0	int
:	O
if	O
(	O
howto	pointer
->	O
pc_relative	int
)	O
addend	long
-=	O
1	int
;	O
bfd_put_8	O
(	O
input_bfd	pointer
,	O
addend	long
,	O
where	long
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
howto	pointer
->	O
pc_relative	int
)	O
addend	long
-=	O
2	int
;	O
bfd_put_16	O
(	O
input_bfd	pointer
,	O
addend	long
,	O
where	long
)	O
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
howto	pointer
->	O
pc_relative	int
)	O
addend	long
-=	O
4	int
;	O
bfd_put_32	O
(	O
input_bfd	pointer
,	O
addend	long
,	O
where	long
)	O
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
ELF32_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
==	O
STT_GNU_IFUNC	int
)	O
{	O
h	pointer
=	O
_bfd_elf_x86_get_local_sym_hash	function
(	O
htab	struct
,	O
input_bfd	pointer
,	O
rel	pointer
,	O
FALSE	int
)	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
=	O
sym	pointer
->	O
st_value	array
;	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
=	O
sec	pointer
;	O
}	O
}	O
else	O
{	O
bfd_boolean	int
warned	int
ATTRIBUTE_UNUSED	O
;	O
bfd_boolean	int
ignored	int
ATTRIBUTE_UNUSED	O
;	O
RELOC_FOR_GLOBAL_SYMBOL	O
(	O
info	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
rel	pointer
,	O
r_symndx	long
,	O
symtab_hdr	struct
,	O
sym_hashes	pointer
,	O
h	pointer
,	O
sec	pointer
,	O
relocation	pointer
,	O
unresolved_reloc	int
,	O
warned	int
,	O
ignored	int
)	O
;	O
st_size	long
=	O
h	pointer
->	O
size	long
;	O
}	O
if	O
(	O
sec	pointer
!=	O
NULL	O
&&	O
discarded_section	function
(	O
sec	pointer
)	O
)	O
{	O
_bfd_clear_contents	function
(	O
howto	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
contents	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
;	O
wrel	pointer
->	O
r_offset	array
=	O
rel	pointer
->	O
r_offset	array
;	O
wrel	pointer
->	O
r_info	array
=	O
0	int
;	O
wrel	pointer
->	O
r_addend	array
=	O
0	int
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
)	O
wrel	pointer
--	O
;	O
continue	O
;	O
}	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
{	O
if	O
(	O
wrel	pointer
!=	O
rel	pointer
)	O
*	O
wrel	pointer
=	O
*	O
rel	pointer
;	O
continue	O
;	O
}	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
&&	O
h	pointer
->	O
def_regular	int
)	O
{	O
asection	struct
*	O
gotplt	pointer
,	O
*	O
base_got	pointer
;	O
bfd_vma	long
plt_index	long
;	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
elf_section_type	O
(	O
input_section	pointer
)	O
==	O
SHT_NOTE	int
)	O
goto	O
skip_ifunc	O
;	O
if	O
(	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
)	O
continue	O
;	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
)	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
plt_second	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
;	O
}	O
else	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
gotplt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
;	O
}	O
else	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
iplt	pointer
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
gotplt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
igotplt	pointer
;	O
}	O
switch	O
(	O
r_type	int
)	O
{	O
default	O
:	O
break	O
;	O
case	O
R_386_GOT32	int
:	O
case	O
R_386_GOT32X	int
:	O
base_got	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
;	O
off	long
=	O
h	pointer
->	O
got	union
.	O
offset	long
;	O
if	O
(	O
base_got	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
off	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
)	O
{	O
plt_index	long
=	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
/	O
plt_entry_size	int
-	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
)	O
;	O
off	long
=	O
(	O
plt_index	long
+	O
3	int
)	O
*	O
4	int
;	O
base_got	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
;	O
}	O
else	O
{	O
plt_index	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
/	O
plt_entry_size	int
;	O
off	long
=	O
plt_index	long
*	O
4	int
;	O
base_got	pointer
=	O
htab	struct
->	O
elf	struct
.	O
igotplt	pointer
;	O
}	O
if	O
(	O
h	pointer
->	O
dynindx	long
==	O
-	O
1	int
||	O
h	pointer
->	O
forced_local	int
||	O
info	pointer
->	O
symbolic	int
)	O
{	O
if	O
(	O
(	O
off	long
&	O
1	int
)	O
!=	O
0	int
)	O
off	long
&=	O
~	O
1	int
;	O
else	O
{	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
relocation	pointer
,	O
base_got	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
h	pointer
->	O
got	union
.	O
offset	long
|=	O
1	int
;	O
}	O
}	O
relocation	pointer
=	O
off	long
;	O
}	O
else	O
relocation	pointer
=	O
(	O
base_got	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
base_got	pointer
->	O
output_offset	long
+	O
off	long
-	O
gotplt	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
gotplt	pointer
->	O
output_offset	long
)	O
;	O
if	O
(	O
rel	pointer
->	O
r_offset	array
>	O
1	int
&&	O
(	O
*	O
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
1	int
)	O
&	O
0xc7	int
)	O
==	O
0x5	int
&&	O
*	O
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
)	O
!=	O
0x8d	int
)	O
{	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
goto	O
disallow_got32	O
;	O
relocation	pointer
+=	O
(	O
gotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
gotplt	pointer
->	O
output_offset	long
)	O
;	O
}	O
else	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
==	O
NULL	O
)	O
{	O
relocation	pointer
+=	O
gotplt	pointer
->	O
output_offset	long
;	O
}	O
goto	O
do_relocation	O
;	O
}	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
if	O
(	O
r_type	int
==	O
R_386_32	int
&&	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
)	O
goto	O
do_ifunc_pointer	O
;	O
goto	O
bad_ifunc_reloc	O
;	O
}	O
relocation	pointer
=	O
(	O
resolved_plt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
resolved_plt	pointer
->	O
output_offset	long
+	O
plt_offset	long
)	O
;	O
switch	O
(	O
r_type	int
)	O
{	O
default	O
:	O
bad_ifunc_reloc	O
:	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
else	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
,	O
sym	pointer
,	O
NULL	O
)	O
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: relocation %s against STT_GNU_IFUNC "	pointer
"symbol `%s' isn't supported"	pointer
)	O
,	O
input_bfd	pointer
,	O
howto	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
case	O
R_386_32	int
:	O
if	O
(	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
&&	O
h	pointer
->	O
non_got_ref	int
)	O
||	O
h	pointer
->	O
plt	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
Elf_Internal_Rela	struct
outrel	struct
;	O
asection	struct
*	O
sreloc	pointer
;	O
bfd_vma	long
offset	long
;	O
do_ifunc_pointer	O
:	O
offset	long
=	O
_bfd_elf_section_offset	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
input_section	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
;	O
if	O
(	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
||	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
2	int
)	O
abort	function
(	O
)	O
;	O
outrel	struct
.	O
r_offset	array
=	O
(	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
input_section	pointer
->	O
output_offset	long
+	O
offset	long
)	O
;	O
if	O
(	O
POINTER_LOCAL_IFUNC_P	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
minfo	pointer
(	O
_	O
(	O
"Local IFUNC function `%s' in %pB\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
;	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
0	int
,	O
R_386_IRELATIVE	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
,	O
contents	pointer
+	O
offset	long
)	O
;	O
}	O
else	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
h	pointer
->	O
dynindx	long
,	O
r_type	int
)	O
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
sreloc	pointer
=	O
htab	struct
->	O
elf	struct
.	O
irelifunc	pointer
;	O
else	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
)	O
sreloc	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
;	O
else	O
sreloc	pointer
=	O
htab	struct
->	O
elf	struct
.	O
irelplt	pointer
;	O
elf_append_rel	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
continue	O
;	O
}	O
case	O
R_386_PC32	int
:	O
case	O
R_386_PLT32	int
:	O
goto	O
do_relocation	O
;	O
case	O
R_386_GOTOFF	int
:	O
relocation	pointer
-=	O
(	O
gotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
gotplt	pointer
->	O
output_offset	long
)	O
;	O
goto	O
do_relocation	O
;	O
}	O
}	O
skip_ifunc	O
:	O
resolved_to_zero	int
=	O
(	O
eh	pointer
!=	O
NULL	O
&&	O
UNDEFINED_WEAK_RESOLVED_TO_ZERO	O
(	O
info	pointer
,	O
eh	pointer
)	O
)	O
;	O
switch	O
(	O
r_type	int
)	O
{	O
case	O
R_386_GOT32X	int
:	O
case	O
R_386_GOT32	int
:	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
relative_reloc	int
=	O
FALSE	int
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
off	long
=	O
h	pointer
->	O
got	union
.	O
offset	long
;	O
if	O
(	O
RESOLVED_LOCALLY_P	O
(	O
info	pointer
,	O
h	pointer
,	O
htab	struct
)	O
)	O
{	O
if	O
(	O
(	O
off	long
&	O
1	int
)	O
!=	O
0	int
)	O
off	long
&=	O
~	O
1	int
;	O
else	O
{	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
relocation	pointer
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
h	pointer
->	O
got	union
.	O
offset	long
|=	O
1	int
;	O
if	O
(	O
GENERATE_RELATIVE_RELOC_P	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
eh	pointer
->	O
no_finish_dynamic_symbol	int
=	O
1	int
;	O
relative_reloc	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
else	O
unresolved_reloc	int
=	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
local_got_offsets	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
off	long
=	O
local_got_offsets	pointer
[	O
r_symndx	long
]	O
;	O
if	O
(	O
(	O
off	long
&	O
1	int
)	O
!=	O
0	int
)	O
off	long
&=	O
~	O
1	int
;	O
else	O
{	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
relocation	pointer
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
local_got_offsets	pointer
[	O
r_symndx	long
]	O
|=	O
1	int
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
relative_reloc	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
relative_reloc	int
)	O
{	O
asection	struct
*	O
s	pointer
;	O
Elf_Internal_Rela	struct
outrel	struct
;	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
outrel	struct
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
)	O
;	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
0	int
,	O
R_386_RELATIVE	int
)	O
;	O
elf_append_rel	function
(	O
output_bfd	pointer
,	O
s	pointer
,	O
&	O
outrel	struct
)	O
;	O
}	O
if	O
(	O
off	long
>=	O
(	O
bfd_vma	long
)	O
-	O
2	int
)	O
abort	function
(	O
)	O
;	O
relocation	pointer
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
)	O
;	O
if	O
(	O
rel	pointer
->	O
r_offset	array
>	O
1	int
&&	O
(	O
*	O
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
1	int
)	O
&	O
0xc7	int
)	O
==	O
0x5	int
&&	O
*	O
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
)	O
!=	O
0x8d	int
)	O
{	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
disallow_got32	O
:	O
if	O
(	O
h	pointer
==	O
NULL	O
||	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
==	O
NULL	O
)	O
name	pointer
=	O
bfd_elf_sym_name	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
,	O
sym	pointer
,	O
NULL	O
)	O
;	O
else	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: direct GOT relocation %s against `%s'"	pointer
" without base register can not be used"	pointer
" when making a shared object"	pointer
)	O
,	O
input_bfd	pointer
,	O
howto	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
else	O
{	O
relocation	pointer
-=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
)	O
;	O
}	O
break	O
;	O
case	O
R_386_GOTOFF	int
:	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
&&	O
h	pointer
)	O
{	O
if	O
(	O
!	O
h	pointer
->	O
def_regular	int
)	O
{	O
const	O
char	O
*	O
v	pointer
;	O
switch	O
(	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
)	O
{	O
case	O
STV_HIDDEN	int
:	O
v	pointer
=	O
_	O
(	O
"hidden symbol"	pointer
)	O
;	O
break	O
;	O
case	O
STV_INTERNAL	int
:	O
v	pointer
=	O
_	O
(	O
"internal symbol"	pointer
)	O
;	O
break	O
;	O
case	O
STV_PROTECTED	int
:	O
v	pointer
=	O
_	O
(	O
"protected symbol"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
v	pointer
=	O
_	O
(	O
"symbol"	pointer
)	O
;	O
break	O
;	O
}	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: relocation R_386_GOTOFF against undefined %s"	pointer
" `%s' can not be used when making a shared object"	pointer
)	O
,	O
input_bfd	pointer
,	O
v	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
!	O
SYMBOL_REFERENCES_LOCAL_P	O
(	O
info	pointer
,	O
h	pointer
)	O
&&	O
(	O
h	pointer
->	O
type	enum
==	O
STT_FUNC	int
||	O
h	pointer
->	O
type	enum
==	O
STT_OBJECT	int
)	O
&&	O
ELF_ST_VISIBILITY	O
(	O
h	pointer
->	O
other	int
)	O
==	O
STV_PROTECTED	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: relocation R_386_GOTOFF against protected %s"	pointer
" `%s' can not be used when making a shared object"	pointer
)	O
,	O
input_bfd	pointer
,	O
h	pointer
->	O
type	enum
==	O
STT_FUNC	int
?	O
"function"	pointer
:	O
"data"	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
relocation	pointer
-=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
;	O
break	O
;	O
case	O
R_386_GOTPC	int
:	O
relocation	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
R_386_PLT32	int
:	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
||	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
==	O
NULL	O
)	O
{	O
break	O
;	O
}	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
if	O
(	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
)	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
plt_second	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
;	O
}	O
else	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
}	O
else	O
{	O
resolved_plt	pointer
=	O
htab	struct
->	O
plt_got	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
;	O
}	O
relocation	pointer
=	O
(	O
resolved_plt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
resolved_plt	pointer
->	O
output_offset	long
+	O
plt_offset	long
)	O
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
R_386_SIZE32	int
:	O
relocation	pointer
=	O
st_size	long
;	O
case	O
R_386_32	int
:	O
case	O
R_386_PC32	int
:	O
if	O
(	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
==	O
0	int
||	O
is_vxworks_tls	int
)	O
break	O
;	O
if	O
(	O
GENERATE_DYNAMIC_RELOCATION_P	O
(	O
info	pointer
,	O
eh	pointer
,	O
r_type	int
,	O
FALSE	int
,	O
resolved_to_zero	int
,	O
(	O
r_type	int
==	O
R_386_PC32	int
)	O
)	O
)	O
{	O
Elf_Internal_Rela	struct
outrel	struct
;	O
bfd_boolean	int
skip	int
,	O
relocate	int
;	O
asection	struct
*	O
sreloc	pointer
;	O
skip	int
=	O
FALSE	int
;	O
relocate	int
=	O
FALSE	int
;	O
outrel	struct
.	O
r_offset	array
=	O
_bfd_elf_section_offset	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
input_section	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
;	O
if	O
(	O
outrel	struct
.	O
r_offset	array
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
skip	int
=	O
TRUE	int
;	O
else	O
if	O
(	O
outrel	struct
.	O
r_offset	array
==	O
(	O
bfd_vma	long
)	O
-	O
2	int
)	O
skip	int
=	O
TRUE	int
,	O
relocate	int
=	O
TRUE	int
;	O
outrel	struct
.	O
r_offset	array
+=	O
(	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
input_section	pointer
->	O
output_offset	long
)	O
;	O
if	O
(	O
skip	int
)	O
memset	function
(	O
&	O
outrel	struct
,	O
0	int
,	O
sizeof	O
outrel	struct
)	O
;	O
else	O
if	O
(	O
COPY_INPUT_RELOC_P	O
(	O
info	pointer
,	O
h	pointer
,	O
r_type	int
)	O
)	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
h	pointer
->	O
dynindx	long
,	O
r_type	int
)	O
;	O
else	O
{	O
relocate	int
=	O
TRUE	int
;	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
0	int
,	O
R_386_RELATIVE	int
)	O
;	O
}	O
sreloc	pointer
=	O
elf_section_data	O
(	O
input_section	pointer
)	O
->	O
sreloc	pointer
;	O
if	O
(	O
sreloc	pointer
==	O
NULL	O
||	O
sreloc	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
{	O
r	enum
=	O
bfd_reloc_notsupported	int
;	O
goto	O
check_relocation_error	O
;	O
}	O
elf_append_rel	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
if	O
(	O
!	O
relocate	int
)	O
continue	O
;	O
}	O
break	O
;	O
case	O
R_386_TLS_IE	int
:	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
{	O
Elf_Internal_Rela	struct
outrel	struct
;	O
asection	struct
*	O
sreloc	pointer
;	O
outrel	struct
.	O
r_offset	array
=	O
rel	pointer
->	O
r_offset	array
+	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
input_section	pointer
->	O
output_offset	long
;	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
0	int
,	O
R_386_RELATIVE	int
)	O
;	O
sreloc	pointer
=	O
elf_section_data	O
(	O
input_section	pointer
)	O
->	O
sreloc	pointer
;	O
if	O
(	O
sreloc	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
elf_append_rel	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
}	O
case	O
R_386_TLS_GD	int
:	O
case	O
R_386_TLS_GOTDESC	int
:	O
case	O
R_386_TLS_DESC_CALL	int
:	O
case	O
R_386_TLS_IE_32	int
:	O
case	O
R_386_TLS_GOTIE	int
:	O
tls_type	char
=	O
GOT_UNKNOWN	int
;	O
if	O
(	O
h	pointer
==	O
NULL	O
&&	O
local_got_offsets	pointer
)	O
tls_type	char
=	O
elf_x86_local_got_tls_type	O
(	O
input_bfd	pointer
)	O
[	O
r_symndx	long
]	O
;	O
else	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
tls_type	char
=	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_type	char
;	O
if	O
(	O
tls_type	char
==	O
GOT_TLS_IE	int
)	O
tls_type	char
=	O
GOT_TLS_IE_NEG	int
;	O
r_type_tls	int
=	O
r_type	int
;	O
if	O
(	O
!	O
elf_i386_tls_transition	function
(	O
info	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
contents	pointer
,	O
symtab_hdr	struct
,	O
sym_hashes	pointer
,	O
&	O
r_type_tls	int
,	O
tls_type	char
,	O
rel	pointer
,	O
relend	pointer
,	O
h	pointer
,	O
r_symndx	long
,	O
TRUE	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
r_type_tls	int
==	O
R_386_TLS_LE_32	int
)	O
{	O
BFD_ASSERT	O
(	O
!	O
unresolved_reloc	int
)	O
;	O
if	O
(	O
r_type	int
==	O
R_386_TLS_GD	int
)	O
{	O
unsigned	O
int	O
type	enum
;	O
bfd_vma	long
roff	long
;	O
type	enum
=	O
*	O
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
)	O
;	O
if	O
(	O
type	enum
==	O
0x04	int
)	O
{	O
roff	long
=	O
rel	pointer
->	O
r_offset	array
+	O
5	int
;	O
}	O
else	O
{	O
roff	long
=	O
rel	pointer
->	O
r_offset	array
+	O
6	int
;	O
}	O
memcpy	function
(	O
contents	pointer
+	O
roff	long
-	O
8	int
,	O
"\x65\xa1\0\0\0\0\x81\xe8\0\0\0"	pointer
,	O
12	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
elf_i386_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
,	O
contents	pointer
+	O
roff	long
)	O
;	O
rel	pointer
++	O
;	O
wrel	pointer
++	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_386_TLS_GOTDESC	int
)	O
{	O
unsigned	O
int	O
val	array
;	O
bfd_vma	long
roff	long
;	O
roff	long
=	O
rel	pointer
->	O
r_offset	array
;	O
val	array
=	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
val	array
^	O
0x86	int
,	O
contents	pointer
+	O
roff	long
-	O
1	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
-	O
elf_i386_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
,	O
contents	pointer
+	O
roff	long
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_386_TLS_DESC_CALL	int
)	O
{	O
bfd_vma	long
roff	long
;	O
roff	long
=	O
rel	pointer
->	O
r_offset	array
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x66	int
,	O
contents	pointer
+	O
roff	long
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x90	int
,	O
contents	pointer
+	O
roff	long
+	O
1	int
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_386_TLS_IE	int
)	O
{	O
unsigned	O
int	O
val	array
;	O
val	array
=	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
1	int
)	O
;	O
if	O
(	O
val	array
==	O
0xa1	int
)	O
{	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xb8	int
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
1	int
)	O
;	O
}	O
else	O
{	O
unsigned	O
int	O
type	enum
;	O
type	enum
=	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
)	O
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
0x8b	int
:	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xc7	int
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xc0	int
|	O
(	O
(	O
val	array
>>	O
3	int
)	O
&	O
7	int
)	O
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
1	int
)	O
;	O
break	O
;	O
case	O
0x03	int
:	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x81	int
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xc0	int
|	O
(	O
(	O
val	array
>>	O
3	int
)	O
&	O
7	int
)	O
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
BFD_FAIL	O
(	O
)	O
;	O
break	O
;	O
}	O
}	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
-	O
elf_i386_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
)	O
;	O
continue	O
;	O
}	O
else	O
{	O
unsigned	O
int	O
val	array
,	O
type	enum
;	O
type	enum
=	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
)	O
;	O
val	array
=	O
bfd_get_8	O
(	O
input_bfd	pointer
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
1	int
)	O
;	O
if	O
(	O
type	enum
==	O
0x8b	int
)	O
{	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xc7	int
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xc0	int
|	O
(	O
(	O
val	array
>>	O
3	int
)	O
&	O
7	int
)	O
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
type	enum
==	O
0x2b	int
)	O
{	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x81	int
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xe8	int
|	O
(	O
(	O
val	array
>>	O
3	int
)	O
&	O
7	int
)	O
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
type	enum
==	O
0x03	int
)	O
{	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x81	int
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xc0	int
|	O
(	O
(	O
val	array
>>	O
3	int
)	O
&	O
7	int
)	O
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
1	int
)	O
;	O
}	O
else	O
BFD_FAIL	O
(	O
)	O
;	O
if	O
(	O
r_type	int
==	O
R_386_TLS_GOTIE	int
)	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
-	O
elf_i386_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
)	O
;	O
else	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
elf_i386_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
,	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
off	long
=	O
h	pointer
->	O
got	union
.	O
offset	long
;	O
offplt	long
=	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tlsdesc_got	long
;	O
}	O
else	O
{	O
if	O
(	O
local_got_offsets	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
off	long
=	O
local_got_offsets	pointer
[	O
r_symndx	long
]	O
;	O
offplt	long
=	O
local_tlsdesc_gotents	pointer
[	O
r_symndx	long
]	O
;	O
}	O
if	O
(	O
(	O
off	long
&	O
1	int
)	O
!=	O
0	int
)	O
off	long
&=	O
~	O
1	int
;	O
else	O
{	O
Elf_Internal_Rela	struct
outrel	struct
;	O
int	O
dr_type	int
;	O
asection	struct
*	O
sreloc	pointer
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
indx	long
=	O
h	pointer
&&	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
?	O
h	pointer
->	O
dynindx	long
:	O
0	int
;	O
if	O
(	O
GOT_TLS_GDESC_P	O
(	O
tls_type	char
)	O
)	O
{	O
bfd_byte	char
*	O
loc	pointer
;	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
indx	long
,	O
R_386_TLS_DESC	int
)	O
;	O
BFD_ASSERT	O
(	O
htab	struct
->	O
sgotplt_jump_table_size	long
+	O
offplt	long
+	O
8	int
<=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
size	long
)	O
;	O
outrel	struct
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
+	O
offplt	long
+	O
htab	struct
->	O
sgotplt_jump_table_size	long
)	O
;	O
sreloc	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
;	O
loc	pointer
=	O
sreloc	pointer
->	O
contents	pointer
;	O
loc	pointer
+=	O
(	O
htab	struct
->	O
next_tls_desc_index	long
++	O
*	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
)	O
;	O
BFD_ASSERT	O
(	O
loc	pointer
+	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
<=	O
sreloc	pointer
->	O
contents	pointer
+	O
sreloc	pointer
->	O
size	long
)	O
;	O
bfd_elf32_swap_reloc_out	function
(	O
output_bfd	pointer
,	O
&	O
outrel	struct
,	O
loc	pointer
)	O
;	O
if	O
(	O
indx	long
==	O
0	int
)	O
{	O
BFD_ASSERT	O
(	O
!	O
unresolved_reloc	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
relocation	pointer
-	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
,	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
contents	pointer
+	O
offplt	long
+	O
htab	struct
->	O
sgotplt_jump_table_size	long
+	O
4	int
)	O
;	O
}	O
else	O
{	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
contents	pointer
+	O
offplt	long
+	O
htab	struct
->	O
sgotplt_jump_table_size	long
+	O
4	int
)	O
;	O
}	O
}	O
sreloc	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
;	O
outrel	struct
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
)	O
;	O
if	O
(	O
GOT_TLS_GD_P	O
(	O
tls_type	char
)	O
)	O
dr_type	int
=	O
R_386_TLS_DTPMOD32	int
;	O
else	O
if	O
(	O
GOT_TLS_GDESC_P	O
(	O
tls_type	char
)	O
)	O
goto	O
dr_done	O
;	O
else	O
if	O
(	O
tls_type	char
==	O
GOT_TLS_IE_POS	int
)	O
dr_type	int
=	O
R_386_TLS_TPOFF	int
;	O
else	O
dr_type	int
=	O
R_386_TLS_TPOFF32	int
;	O
if	O
(	O
dr_type	int
==	O
R_386_TLS_TPOFF	int
&&	O
indx	long
==	O
0	int
)	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
relocation	pointer
-	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
else	O
if	O
(	O
dr_type	int
==	O
R_386_TLS_TPOFF32	int
&&	O
indx	long
==	O
0	int
)	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
-	O
relocation	pointer
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
else	O
if	O
(	O
dr_type	int
!=	O
R_386_TLS_DESC	int
)	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
indx	long
,	O
dr_type	int
)	O
;	O
elf_append_rel	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
if	O
(	O
GOT_TLS_GD_P	O
(	O
tls_type	char
)	O
)	O
{	O
if	O
(	O
indx	long
==	O
0	int
)	O
{	O
BFD_ASSERT	O
(	O
!	O
unresolved_reloc	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
relocation	pointer
-	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
+	O
4	int
)	O
;	O
}	O
else	O
{	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
+	O
4	int
)	O
;	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
indx	long
,	O
R_386_TLS_DTPOFF32	int
)	O
;	O
outrel	struct
.	O
r_offset	array
+=	O
4	int
;	O
elf_append_rel	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
}	O
}	O
else	O
if	O
(	O
tls_type	char
==	O
GOT_TLS_IE_BOTH	int
)	O
{	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
indx	long
==	O
0	int
?	O
relocation	pointer
-	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
:	O
0	int
)	O
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
+	O
4	int
)	O
;	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
indx	long
,	O
R_386_TLS_TPOFF	int
)	O
;	O
outrel	struct
.	O
r_offset	array
+=	O
4	int
;	O
elf_append_rel	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
}	O
dr_done	O
:	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
h	pointer
->	O
got	union
.	O
offset	long
|=	O
1	int
;	O
else	O
local_got_offsets	pointer
[	O
r_symndx	long
]	O
|=	O
1	int
;	O
}	O
if	O
(	O
off	long
>=	O
(	O
bfd_vma	long
)	O
-	O
2	int
&&	O
!	O
GOT_TLS_GDESC_P	O
(	O
tls_type	char
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
r_type_tls	int
==	O
R_386_TLS_GOTDESC	int
||	O
r_type_tls	int
==	O
R_386_TLS_DESC_CALL	int
)	O
{	O
relocation	pointer
=	O
htab	struct
->	O
sgotplt_jump_table_size	long
+	O
offplt	long
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
r_type_tls	int
==	O
r_type	int
)	O
{	O
bfd_vma	long
g_o_t	long
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
;	O
relocation	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
-	O
g_o_t	long
;	O
if	O
(	O
(	O
r_type	int
==	O
R_386_TLS_IE	int
||	O
r_type	int
==	O
R_386_TLS_GOTIE	int
)	O
&&	O
tls_type	char
==	O
GOT_TLS_IE_BOTH	int
)	O
relocation	pointer
+=	O
4	int
;	O
if	O
(	O
r_type	int
==	O
R_386_TLS_IE	int
)	O
relocation	pointer
+=	O
g_o_t	long
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_386_TLS_GD	int
)	O
{	O
unsigned	O
int	O
val	array
,	O
type	enum
;	O
bfd_vma	long
roff	long
;	O
type	enum
=	O
*	O
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
)	O
;	O
val	array
=	O
*	O
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
1	int
)	O
;	O
if	O
(	O
type	enum
==	O
0x04	int
)	O
{	O
val	array
>>=	O
3	int
;	O
roff	long
=	O
rel	pointer
->	O
r_offset	array
-	O
3	int
;	O
}	O
else	O
{	O
roff	long
=	O
rel	pointer
->	O
r_offset	array
-	O
2	int
;	O
}	O
memcpy	function
(	O
contents	pointer
+	O
roff	long
,	O
"\x65\xa1\0\0\0\0\x2b\x80\0\0\0"	pointer
,	O
12	int
)	O
;	O
contents	pointer
[	O
roff	long
+	O
7	int
]	O
=	O
0x80	int
|	O
(	O
val	array
&	O
7	int
)	O
;	O
if	O
(	O
tls_type	char
==	O
GOT_TLS_IE_POS	int
)	O
contents	pointer
[	O
roff	long
+	O
6	int
]	O
=	O
0x03	int
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
-	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
,	O
contents	pointer
+	O
roff	long
+	O
8	int
)	O
;	O
rel	pointer
++	O
;	O
wrel	pointer
++	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_386_TLS_GOTDESC	int
)	O
{	O
bfd_vma	long
roff	long
;	O
roff	long
=	O
rel	pointer
->	O
r_offset	array
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x8b	int
,	O
contents	pointer
+	O
roff	long
-	O
2	int
)	O
;	O
if	O
(	O
tls_type	char
==	O
GOT_TLS_IE_BOTH	int
)	O
off	long
+=	O
4	int
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
-	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
,	O
contents	pointer
+	O
roff	long
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_386_TLS_DESC_CALL	int
)	O
{	O
bfd_vma	long
roff	long
;	O
roff	long
=	O
rel	pointer
->	O
r_offset	array
;	O
if	O
(	O
tls_type	char
!=	O
GOT_TLS_IE_NEG	int
)	O
{	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x66	int
,	O
contents	pointer
+	O
roff	long
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0x90	int
,	O
contents	pointer
+	O
roff	long
+	O
1	int
)	O
;	O
}	O
else	O
{	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xf7	int
,	O
contents	pointer
+	O
roff	long
)	O
;	O
bfd_put_8	O
(	O
output_bfd	pointer
,	O
0xd8	int
,	O
contents	pointer
+	O
roff	long
+	O
1	int
)	O
;	O
}	O
continue	O
;	O
}	O
else	O
BFD_ASSERT	O
(	O
FALSE	int
)	O
;	O
break	O
;	O
case	O
R_386_TLS_LDM	int
:	O
if	O
(	O
!	O
elf_i386_tls_transition	function
(	O
info	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
contents	pointer
,	O
symtab_hdr	struct
,	O
sym_hashes	pointer
,	O
&	O
r_type	int
,	O
GOT_UNKNOWN	int
,	O
rel	pointer
,	O
relend	pointer
,	O
h	pointer
,	O
r_symndx	long
,	O
TRUE	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
r_type	int
!=	O
R_386_TLS_LDM	int
)	O
{	O
BFD_ASSERT	O
(	O
r_type	int
==	O
R_386_TLS_LE_32	int
)	O
;	O
if	O
(	O
*	O
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
+	O
4	int
)	O
==	O
0xff	int
||	O
*	O
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
+	O
4	int
)	O
==	O
0x67	int
)	O
memcpy	function
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
,	O
"\x65\xa1\0\0\0\0\x8d\xb6\0\0\0"	pointer
,	O
12	int
)	O
;	O
else	O
memcpy	function
(	O
contents	pointer
+	O
rel	pointer
->	O
r_offset	array
-	O
2	int
,	O
"\x65\xa1\0\0\0\0\x90\x8d\x74\x26"	pointer
,	O
11	int
)	O
;	O
rel	pointer
++	O
;	O
wrel	pointer
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
off	long
=	O
htab	struct
->	O
tls_ld_or_ldm_got	union
.	O
offset	long
;	O
if	O
(	O
off	long
&	O
1	int
)	O
off	long
&=	O
~	O
1	int
;	O
else	O
{	O
Elf_Internal_Rela	struct
outrel	struct
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
outrel	struct
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
off	long
+	O
4	int
)	O
;	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
0	int
,	O
R_386_TLS_DTPMOD32	int
)	O
;	O
elf_append_rel	function
(	O
output_bfd	pointer
,	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
,	O
&	O
outrel	struct
)	O
;	O
htab	struct
->	O
tls_ld_or_ldm_got	union
.	O
offset	long
|=	O
1	int
;	O
}	O
relocation	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
off	long
-	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
;	O
unresolved_reloc	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
R_386_TLS_LDO_32	int
:	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
||	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_CODE	int
)	O
==	O
0	int
)	O
relocation	pointer
-=	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
;	O
else	O
relocation	pointer
=	O
-	O
elf_i386_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
;	O
break	O
;	O
case	O
R_386_TLS_LE_32	int
:	O
case	O
R_386_TLS_LE	int
:	O
if	O
(	O
!	O
bfd_link_executable	O
(	O
info	pointer
)	O
)	O
{	O
Elf_Internal_Rela	struct
outrel	struct
;	O
asection	struct
*	O
sreloc	pointer
;	O
outrel	struct
.	O
r_offset	array
=	O
rel	pointer
->	O
r_offset	array
+	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
input_section	pointer
->	O
output_offset	long
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
indx	long
=	O
h	pointer
->	O
dynindx	long
;	O
else	O
indx	long
=	O
0	int
;	O
if	O
(	O
r_type	int
==	O
R_386_TLS_LE_32	int
)	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
indx	long
,	O
R_386_TLS_TPOFF32	int
)	O
;	O
else	O
outrel	struct
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
indx	long
,	O
R_386_TLS_TPOFF	int
)	O
;	O
sreloc	pointer
=	O
elf_section_data	O
(	O
input_section	pointer
)	O
->	O
sreloc	pointer
;	O
if	O
(	O
sreloc	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
elf_append_rel	function
(	O
output_bfd	pointer
,	O
sreloc	pointer
,	O
&	O
outrel	struct
)	O
;	O
if	O
(	O
indx	long
)	O
continue	O
;	O
else	O
if	O
(	O
r_type	int
==	O
R_386_TLS_LE_32	int
)	O
relocation	pointer
=	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
-	O
relocation	pointer
;	O
else	O
relocation	pointer
-=	O
_bfd_x86_elf_dtpoff_base	function
(	O
info	pointer
)	O
;	O
}	O
else	O
if	O
(	O
r_type	int
==	O
R_386_TLS_LE_32	int
)	O
relocation	pointer
=	O
elf_i386_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
;	O
else	O
relocation	pointer
=	O
-	O
elf_i386_tpoff	function
(	O
info	pointer
,	O
relocation	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
unresolved_reloc	int
&&	O
!	O
(	O
(	O
input_section	pointer
->	O
flags	int
&	O
SEC_DEBUGGING	int
)	O
!=	O
0	int
&&	O
h	pointer
->	O
def_dynamic	int
)	O
&&	O
_bfd_elf_section_offset	function
(	O
output_bfd	pointer
,	O
info	pointer
,	O
input_section	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB(%pA+%#"	pointer
PRIx64	O
"): unresolvable %s relocation against symbol `%s'"	pointer
)	O
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
(	O
uint64_t	long
)	O
rel	pointer
->	O
r_offset	array
,	O
howto	pointer
->	O
name	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
do_relocation	O
:	O
r	enum
=	O
_bfd_final_link_relocate	function
(	O
howto	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
contents	pointer
,	O
rel	pointer
->	O
r_offset	array
,	O
relocation	pointer
,	O
0	int
)	O
;	O
check_relocation_error	O
:	O
if	O
(	O
r	enum
!=	O
bfd_reloc_ok	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
name	pointer
=	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
;	O
else	O
{	O
name	pointer
=	O
bfd_elf_string_from_elf_section	function
(	O
input_bfd	pointer
,	O
symtab_hdr	struct
->	O
sh_link	array
,	O
sym	pointer
->	O
st_name	array
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
*	O
name	pointer
==	O
'\0'	O
)	O
name	pointer
=	O
bfd_section_name	function
(	O
sec	pointer
)	O
;	O
}	O
if	O
(	O
r	enum
==	O
bfd_reloc_overflow	int
)	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
reloc_overflow	pointer
)	O
(	O
info	pointer
,	O
(	O
h	pointer
?	O
&	O
h	pointer
->	O
root	struct
:	O
NULL	O
)	O
,	O
name	pointer
,	O
howto	pointer
->	O
name	pointer
,	O
(	O
bfd_vma	long
)	O
0	int
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
rel	pointer
->	O
r_offset	array
)	O
;	O
else	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB(%pA+%#"	pointer
PRIx64	O
"): reloc against `%s': error %d"	pointer
)	O
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
(	O
uint64_t	long
)	O
rel	pointer
->	O
r_offset	array
,	O
name	pointer
,	O
(	O
int	O
)	O
r	enum
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
wrel	pointer
!=	O
rel	pointer
)	O
*	O
wrel	pointer
=	O
*	O
rel	pointer
;	O
}	O
if	O
(	O
wrel	pointer
!=	O
rel	pointer
)	O
{	O
Elf_Internal_Shdr	struct
*	O
rel_hdr	pointer
;	O
size_t	long
deleted	long
=	O
rel	pointer
-	O
wrel	pointer
;	O
rel_hdr	pointer
=	O
_bfd_elf_single_rel_hdr	function
(	O
input_section	pointer
->	O
output_section	pointer
)	O
;	O
rel_hdr	pointer
->	O
sh_size	array
-=	O
rel_hdr	pointer
->	O
sh_entsize	array
*	O
deleted	long
;	O
if	O
(	O
rel_hdr	pointer
->	O
sh_size	array
==	O
0	int
)	O
{	O
rel_hdr	pointer
->	O
sh_size	array
=	O
rel_hdr	pointer
->	O
sh_entsize	array
;	O
deleted	long
-=	O
1	int
;	O
}	O
rel_hdr	pointer
=	O
_bfd_elf_single_rel_hdr	function
(	O
input_section	pointer
)	O
;	O
rel_hdr	pointer
->	O
sh_size	array
-=	O
rel_hdr	pointer
->	O
sh_entsize	array
*	O
deleted	long
;	O
input_section	pointer
->	O
reloc_count	int
-=	O
deleted	long
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_i386_finish_dynamic_symbol	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
unsigned	O
plt_entry_size	int
;	O
struct	O
elf_x86_link_hash_entry	struct
*	O
eh	pointer
;	O
bfd_boolean	int
local_undefweak	int
;	O
bfd_boolean	int
use_plt_second	int
;	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
I386_ELF_DATA	int
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
plt_entry_size	int
=	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
;	O
use_plt_second	int
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
;	O
eh	pointer
=	O
(	O
struct	O
elf_x86_link_hash_entry	struct
*	O
)	O
h	pointer
;	O
if	O
(	O
eh	pointer
->	O
no_finish_dynamic_symbol	int
)	O
abort	function
(	O
)	O
;	O
local_undefweak	int
=	O
UNDEFINED_WEAK_RESOLVED_TO_ZERO	O
(	O
info	pointer
,	O
eh	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
bfd_vma	long
plt_index	long
,	O
plt_offset	long
;	O
bfd_vma	long
got_offset	long
;	O
Elf_Internal_Rela	struct
rel	pointer
;	O
bfd_byte	char
*	O
loc	pointer
;	O
asection	struct
*	O
plt	union
,	O
*	O
resolved_plt	pointer
,	O
*	O
gotplt	pointer
,	O
*	O
relplt	pointer
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
!=	O
NULL	O
)	O
{	O
plt	union
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
;	O
gotplt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
;	O
relplt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelplt	pointer
;	O
}	O
else	O
{	O
plt	union
=	O
htab	struct
->	O
elf	struct
.	O
iplt	pointer
;	O
gotplt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
igotplt	pointer
;	O
relplt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
irelplt	pointer
;	O
}	O
VERIFY_PLT_ENTRY	O
(	O
info	pointer
,	O
h	pointer
,	O
plt	union
,	O
gotplt	pointer
,	O
relplt	pointer
,	O
local_undefweak	int
)	O
if	O
(	O
plt	union
==	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
)	O
{	O
got_offset	long
=	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
/	O
plt_entry_size	int
-	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
)	O
;	O
got_offset	long
=	O
(	O
got_offset	long
+	O
3	int
)	O
*	O
4	int
;	O
}	O
else	O
{	O
got_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
/	O
plt_entry_size	int
;	O
got_offset	long
=	O
got_offset	long
*	O
4	int
;	O
}	O
memcpy	function
(	O
plt	union
->	O
contents	pointer
+	O
h	pointer
->	O
plt	union
.	O
offset	long
,	O
htab	struct
->	O
plt	union
.	O
plt_entry	pointer
,	O
plt_entry_size	int
)	O
;	O
if	O
(	O
use_plt_second	int
)	O
{	O
const	O
bfd_byte	char
*	O
plt_entry	pointer
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
plt_entry	pointer
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
pic_plt_entry	pointer
;	O
else	O
plt_entry	pointer
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry	pointer
;	O
memcpy	function
(	O
htab	struct
->	O
plt_second	union
->	O
contents	pointer
+	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
,	O
plt_entry	pointer
,	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
)	O
;	O
resolved_plt	pointer
=	O
htab	struct
->	O
plt_second	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
;	O
}	O
else	O
{	O
resolved_plt	pointer
=	O
plt	union
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
if	O
(	O
!	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
gotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
gotplt	pointer
->	O
output_offset	long
+	O
got_offset	long
)	O
,	O
resolved_plt	pointer
->	O
contents	pointer
+	O
plt_offset	long
+	O
htab	struct
->	O
plt	union
.	O
plt_got_offset	int
)	O
;	O
if	O
(	O
htab	struct
->	O
target_os	enum
==	O
is_vxworks	int
)	O
{	O
int	O
s	pointer
,	O
k	int
,	O
reloc_index	int
;	O
s	pointer
=	O
(	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
-	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
)	O
/	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
)	O
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
k	int
=	O
PLTRESOLVE_RELOCS_SHLIB	int
;	O
else	O
k	int
=	O
PLTRESOLVE_RELOCS	int
;	O
reloc_index	int
=	O
k	int
+	O
s	pointer
*	O
PLT_NON_JUMP_SLOT_RELOCS	int
;	O
loc	pointer
=	O
(	O
htab	struct
->	O
srelplt2	pointer
->	O
contents	pointer
+	O
reloc_index	int
*	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
)	O
;	O
rel	pointer
.	O
r_offset	array
=	O
(	O
plt	union
->	O
output_section	pointer
->	O
vma	long
+	O
plt	union
->	O
output_offset	long
+	O
h	pointer
->	O
plt	union
.	O
offset	long
+	O
2	int
)	O
,	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
->	O
indx	long
,	O
R_386_32	int
)	O
;	O
bfd_elf32_swap_reloc_out	function
(	O
output_bfd	pointer
,	O
&	O
rel	pointer
,	O
loc	pointer
)	O
;	O
rel	pointer
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
+	O
got_offset	long
)	O
;	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
htab	struct
->	O
elf	struct
.	O
hplt	pointer
->	O
indx	long
,	O
R_386_32	int
)	O
;	O
bfd_elf32_swap_reloc_out	function
(	O
output_bfd	pointer
,	O
&	O
rel	pointer
,	O
loc	pointer
+	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
)	O
;	O
}	O
}	O
else	O
{	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
got_offset	long
,	O
resolved_plt	pointer
->	O
contents	pointer
+	O
plt_offset	long
+	O
htab	struct
->	O
plt	union
.	O
plt_got_offset	int
)	O
;	O
}	O
if	O
(	O
!	O
local_undefweak	int
)	O
{	O
if	O
(	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
)	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
plt	union
->	O
output_section	pointer
->	O
vma	long
+	O
plt	union
->	O
output_offset	long
+	O
h	pointer
->	O
plt	union
.	O
offset	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_lazy_offset	int
)	O
,	O
gotplt	pointer
->	O
contents	pointer
+	O
got_offset	long
)	O
;	O
rel	pointer
.	O
r_offset	array
=	O
(	O
gotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
gotplt	pointer
->	O
output_offset	long
+	O
got_offset	long
)	O
;	O
if	O
(	O
PLT_LOCAL_IFUNC_P	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
minfo	pointer
(	O
_	O
(	O
"Local IFUNC function `%s' in %pB\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
,	O
gotplt	pointer
->	O
contents	pointer
+	O
got_offset	long
)	O
;	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
0	int
,	O
R_386_IRELATIVE	int
)	O
;	O
plt_index	long
=	O
htab	struct
->	O
next_irelative_index	long
--	O
;	O
}	O
else	O
{	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
h	pointer
->	O
dynindx	long
,	O
R_386_JUMP_SLOT	int
)	O
;	O
plt_index	long
=	O
htab	struct
->	O
next_jump_slot_index	long
++	O
;	O
}	O
loc	pointer
=	O
relplt	pointer
->	O
contents	pointer
+	O
plt_index	long
*	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
;	O
bfd_elf32_swap_reloc_out	function
(	O
output_bfd	pointer
,	O
&	O
rel	pointer
,	O
loc	pointer
)	O
;	O
if	O
(	O
plt	union
==	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
&&	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
)	O
{	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
plt_index	long
*	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
,	O
plt	union
->	O
contents	pointer
+	O
h	pointer
->	O
plt	union
.	O
offset	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_reloc_offset	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
-	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_plt_offset	int
+	O
4	int
)	O
,	O
(	O
plt	union
->	O
contents	pointer
+	O
h	pointer
->	O
plt	union
.	O
offset	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt_plt_offset	int
)	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
bfd_vma	long
got_offset	long
,	O
plt_offset	long
;	O
asection	struct
*	O
plt	union
,	O
*	O
got	union
,	O
*	O
gotplt	pointer
;	O
const	O
bfd_byte	char
*	O
got_plt_entry	pointer
;	O
plt	union
=	O
htab	struct
->	O
plt_got	union
;	O
got	union
=	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
;	O
gotplt	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
;	O
got_offset	long
=	O
h	pointer
->	O
got	union
.	O
offset	long
;	O
if	O
(	O
got_offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
||	O
plt	union
==	O
NULL	O
||	O
got	union
==	O
NULL	O
||	O
gotplt	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
!	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
got_plt_entry	pointer
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry	pointer
;	O
got_offset	long
+=	O
got	union
->	O
output_section	pointer
->	O
vma	long
+	O
got	union
->	O
output_offset	long
;	O
}	O
else	O
{	O
got_plt_entry	pointer
=	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
pic_plt_entry	pointer
;	O
got_offset	long
+=	O
(	O
got	union
->	O
output_section	pointer
->	O
vma	long
+	O
got	union
->	O
output_offset	long
-	O
gotplt	pointer
->	O
output_section	pointer
->	O
vma	long
-	O
gotplt	pointer
->	O
output_offset	long
)	O
;	O
}	O
plt_offset	long
=	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
;	O
memcpy	function
(	O
plt	union
->	O
contents	pointer
+	O
plt_offset	long
,	O
got_plt_entry	pointer
,	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
got_offset	long
,	O
(	O
plt	union
->	O
contents	pointer
+	O
plt_offset	long
+	O
htab	struct
->	O
non_lazy_plt	pointer
->	O
plt_got_offset	int
)	O
)	O
;	O
}	O
if	O
(	O
!	O
local_undefweak	int
&&	O
!	O
h	pointer
->	O
def_regular	int
&&	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
||	O
eh	pointer
->	O
plt_got	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
)	O
{	O
sym	pointer
->	O
st_shndx	array
=	O
SHN_UNDEF	int
;	O
if	O
(	O
!	O
h	pointer
->	O
pointer_equality_needed	int
)	O
sym	pointer
->	O
st_value	array
=	O
0	int
;	O
}	O
_bfd_x86_elf_link_fixup_ifunc_symbol	function
(	O
info	pointer
,	O
htab	struct
,	O
h	pointer
,	O
sym	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
got	union
.	O
offset	long
!=	O
(	O
bfd_vma	long
)	O
-	O
1	int
&&	O
!	O
GOT_TLS_GD_ANY_P	O
(	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_type	char
)	O
&&	O
(	O
elf_x86_hash_entry	O
(	O
h	pointer
)	O
->	O
tls_type	char
&	O
GOT_TLS_IE	int
)	O
==	O
0	int
&&	O
!	O
local_undefweak	int
)	O
{	O
Elf_Internal_Rela	struct
rel	pointer
;	O
asection	struct
*	O
relgot	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
==	O
NULL	O
||	O
htab	struct
->	O
elf	struct
.	O
srelgot	pointer
==	O
NULL	O
)	O
abort	function
(	O
)	O
;	O
rel	pointer
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
output_offset	long
+	O
(	O
h	pointer
->	O
got	union
.	O
offset	long
&	O
~	O
(	O
bfd_vma	long
)	O
1	int
)	O
)	O
;	O
if	O
(	O
h	pointer
->	O
def_regular	int
&&	O
h	pointer
->	O
type	enum
==	O
STT_GNU_IFUNC	int
)	O
{	O
if	O
(	O
h	pointer
->	O
plt	union
.	O
offset	long
==	O
(	O
bfd_vma	long
)	O
-	O
1	int
)	O
{	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
==	O
NULL	O
)	O
{	O
relgot	pointer
=	O
htab	struct
->	O
elf	struct
.	O
irelplt	pointer
;	O
}	O
if	O
(	O
SYMBOL_REFERENCES_LOCAL_P	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
info	pointer
->	O
callbacks	pointer
->	O
minfo	pointer
(	O
_	O
(	O
"Local IFUNC function `%s' in %pB\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
owner	pointer
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
h	pointer
->	O
got	union
.	O
offset	long
)	O
;	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
0	int
,	O
R_386_IRELATIVE	int
)	O
;	O
}	O
else	O
goto	O
do_glob_dat	O
;	O
}	O
else	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
goto	O
do_glob_dat	O
;	O
}	O
else	O
{	O
asection	struct
*	O
plt	union
;	O
bfd_vma	long
plt_offset	long
;	O
if	O
(	O
!	O
h	pointer
->	O
pointer_equality_needed	int
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
htab	struct
->	O
plt_second	union
!=	O
NULL	O
)	O
{	O
plt	union
=	O
htab	struct
->	O
plt_second	union
;	O
plt_offset	long
=	O
eh	pointer
->	O
plt_second	union
.	O
offset	long
;	O
}	O
else	O
{	O
plt	union
=	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
?	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
:	O
htab	struct
->	O
elf	struct
.	O
iplt	pointer
;	O
plt_offset	long
=	O
h	pointer
->	O
plt	union
.	O
offset	long
;	O
}	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
plt	union
->	O
output_section	pointer
->	O
vma	long
+	O
plt	union
->	O
output_offset	long
+	O
plt_offset	long
)	O
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
h	pointer
->	O
got	union
.	O
offset	long
)	O
;	O
return	O
TRUE	int
;	O
}	O
}	O
else	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
&&	O
SYMBOL_REFERENCES_LOCAL_P	O
(	O
info	pointer
,	O
h	pointer
)	O
)	O
{	O
BFD_ASSERT	O
(	O
(	O
h	pointer
->	O
got	union
.	O
offset	long
&	O
1	int
)	O
!=	O
0	int
)	O
;	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
0	int
,	O
R_386_RELATIVE	int
)	O
;	O
}	O
else	O
{	O
BFD_ASSERT	O
(	O
(	O
h	pointer
->	O
got	union
.	O
offset	long
&	O
1	int
)	O
==	O
0	int
)	O
;	O
do_glob_dat	O
:	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
bfd_vma	long
)	O
0	int
,	O
htab	struct
->	O
elf	struct
.	O
sgot	pointer
->	O
contents	pointer
+	O
h	pointer
->	O
got	union
.	O
offset	long
)	O
;	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
h	pointer
->	O
dynindx	long
,	O
R_386_GLOB_DAT	int
)	O
;	O
}	O
elf_append_rel	function
(	O
output_bfd	pointer
,	O
relgot	pointer
,	O
&	O
rel	pointer
)	O
;	O
}	O
if	O
(	O
h	pointer
->	O
needs_copy	int
)	O
{	O
Elf_Internal_Rela	struct
rel	pointer
;	O
asection	struct
*	O
s	pointer
;	O
VERIFY_COPY_RELOC	O
(	O
h	pointer
,	O
htab	struct
)	O
rel	pointer
.	O
r_offset	array
=	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
h	pointer
->	O
dynindx	long
,	O
R_386_COPY	int
)	O
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
==	O
htab	struct
->	O
elf	struct
.	O
sdynrelro	pointer
)	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
sreldynrelro	pointer
;	O
else	O
s	pointer
=	O
htab	struct
->	O
elf	struct
.	O
srelbss	pointer
;	O
elf_append_rel	function
(	O
output_bfd	pointer
,	O
s	pointer
,	O
&	O
rel	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_i386_finish_local_dynamic_symbol	function
(	O
void	O
*	O
*	O
slot	pointer
,	O
void	O
*	O
inf	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
*	O
slot	pointer
;	O
struct	O
bfd_link_info	struct
*	O
info	pointer
=	O
(	O
struct	O
bfd_link_info	struct
*	O
)	O
inf	pointer
;	O
return	O
elf_i386_finish_dynamic_symbol	function
(	O
info	pointer
->	O
output_bfd	pointer
,	O
info	pointer
,	O
h	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
bfd_boolean	int
elf_i386_pie_finish_undefweak_symbol	function
(	O
struct	O
bfd_hash_entry	struct
*	O
bh	pointer
,	O
void	O
*	O
inf	pointer
)	O
{	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
=	O
(	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
struct	O
bfd_link_info	struct
*	O
info	pointer
=	O
(	O
struct	O
bfd_link_info	struct
*	O
)	O
inf	pointer
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefweak	int
||	O
h	pointer
->	O
dynindx	long
!=	O
-	O
1	int
)	O
return	O
TRUE	int
;	O
return	O
elf_i386_finish_dynamic_symbol	function
(	O
info	pointer
->	O
output_bfd	pointer
,	O
info	pointer
,	O
h	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
enum	O
elf_reloc_type_class	enum
elf_i386_reloc_type_class	function
(	O
const	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
const	O
asection	struct
*	O
rel_sec	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
Elf_Internal_Rela	struct
*	O
rela	struct
)	O
{	O
bfd	struct
*	O
abfd	pointer
=	O
info	pointer
->	O
output_bfd	pointer
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
;	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
htab	struct
->	O
dynsym	pointer
!=	O
NULL	O
&&	O
htab	struct
->	O
dynsym	pointer
->	O
contents	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
long	O
r_symndx	long
=	O
ELF32_R_SYM	O
(	O
rela	struct
->	O
r_info	array
)	O
;	O
if	O
(	O
r_symndx	long
!=	O
STN_UNDEF	int
)	O
{	O
Elf_Internal_Sym	struct
sym	pointer
;	O
if	O
(	O
!	O
bed	pointer
->	O
s	pointer
->	O
swap_symbol_in	pointer
(	O
abfd	pointer
,	O
(	O
htab	struct
->	O
dynsym	pointer
->	O
contents	pointer
+	O
r_symndx	long
*	O
sizeof	O
(	O
Elf32_External_Sym	struct
)	O
)	O
,	O
0	int
,	O
&	O
sym	pointer
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
ELF32_ST_TYPE	O
(	O
sym	pointer
.	O
st_info	array
)	O
==	O
STT_GNU_IFUNC	int
)	O
return	O
reloc_class_ifunc	int
;	O
}	O
}	O
switch	O
(	O
ELF32_R_TYPE	O
(	O
rela	struct
->	O
r_info	array
)	O
)	O
{	O
case	O
R_386_IRELATIVE	int
:	O
return	O
reloc_class_ifunc	int
;	O
case	O
R_386_RELATIVE	int
:	O
return	O
reloc_class_relative	int
;	O
case	O
R_386_JUMP_SLOT	int
:	O
return	O
reloc_class_plt	int
;	O
case	O
R_386_COPY	int
:	O
return	O
reloc_class_copy	int
;	O
default	O
:	O
return	O
reloc_class_normal	int
;	O
}	O
}	O
static	O
bfd_boolean	int
elf_i386_finish_dynamic_sections	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
;	O
htab	struct
=	O
_bfd_x86_elf_finish_dynamic_sections	function
(	O
output_bfd	pointer
,	O
info	pointer
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
htab	struct
->	O
elf	struct
.	O
dynamic_sections_created	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
&&	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
>	O
0	int
)	O
{	O
elf_section_data	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_section	pointer
)	O
->	O
this_hdr	struct
.	O
sh_entsize	array
=	O
4	int
;	O
if	O
(	O
htab	struct
->	O
plt	union
.	O
has_plt0	int
)	O
{	O
memcpy	function
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
contents	pointer
,	O
htab	struct
->	O
plt	union
.	O
plt0_entry	pointer
,	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_entry_size	int
)	O
;	O
memset	function
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
contents	pointer
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_entry_size	int
,	O
htab	struct
->	O
plt0_pad_byte	char
,	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
-	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_entry_size	int
)	O
;	O
if	O
(	O
!	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
+	O
4	int
)	O
,	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
contents	pointer
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_got1_offset	int
)	O
;	O
bfd_put_32	O
(	O
output_bfd	pointer
,	O
(	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
sgotplt	pointer
->	O
output_offset	long
+	O
8	int
)	O
,	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
contents	pointer
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_got2_offset	int
)	O
;	O
if	O
(	O
htab	struct
->	O
target_os	enum
==	O
is_vxworks	int
)	O
{	O
Elf_Internal_Rela	struct
rel	pointer
;	O
int	O
num_plts	int
=	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
size	long
/	O
htab	struct
->	O
plt	union
.	O
plt_entry_size	int
)	O
-	O
1	int
;	O
unsigned	O
char	O
*	O
p	pointer
;	O
asection	struct
*	O
srelplt2	pointer
=	O
htab	struct
->	O
srelplt2	pointer
;	O
rel	pointer
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_offset	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_got1_offset	int
)	O
;	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
->	O
indx	long
,	O
R_386_32	int
)	O
;	O
bfd_elf32_swap_reloc_out	function
(	O
output_bfd	pointer
,	O
&	O
rel	pointer
,	O
srelplt2	pointer
->	O
contents	pointer
)	O
;	O
rel	pointer
.	O
r_offset	array
=	O
(	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
htab	struct
->	O
elf	struct
.	O
splt	pointer
->	O
output_offset	long
+	O
htab	struct
->	O
lazy_plt	pointer
->	O
plt0_got2_offset	int
)	O
;	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
->	O
indx	long
,	O
R_386_32	int
)	O
;	O
bfd_elf32_swap_reloc_out	function
(	O
output_bfd	pointer
,	O
&	O
rel	pointer
,	O
srelplt2	pointer
->	O
contents	pointer
+	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
)	O
;	O
p	pointer
=	O
srelplt2	pointer
->	O
contents	pointer
;	O
if	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
p	pointer
+=	O
PLTRESOLVE_RELOCS_SHLIB	int
*	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
;	O
else	O
p	pointer
+=	O
PLTRESOLVE_RELOCS	int
*	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
;	O
for	O
(	O
;	O
num_plts	int
;	O
num_plts	int
--	O
)	O
{	O
bfd_elf32_swap_reloc_in	function
(	O
output_bfd	pointer
,	O
p	pointer
,	O
&	O
rel	pointer
)	O
;	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
htab	struct
->	O
elf	struct
.	O
hgot	pointer
->	O
indx	long
,	O
R_386_32	int
)	O
;	O
bfd_elf32_swap_reloc_out	function
(	O
output_bfd	pointer
,	O
&	O
rel	pointer
,	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
;	O
bfd_elf32_swap_reloc_in	function
(	O
output_bfd	pointer
,	O
p	pointer
,	O
&	O
rel	pointer
)	O
;	O
rel	pointer
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
htab	struct
->	O
elf	struct
.	O
hplt	pointer
->	O
indx	long
,	O
R_386_32	int
)	O
;	O
bfd_elf32_swap_reloc_out	function
(	O
output_bfd	pointer
,	O
&	O
rel	pointer
,	O
p	pointer
)	O
;	O
p	pointer
+=	O
sizeof	O
(	O
Elf32_External_Rel	struct
)	O
;	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
bfd_link_pie	O
(	O
info	pointer
)	O
)	O
bfd_hash_traverse	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
elf_i386_pie_finish_undefweak_symbol	function
,	O
info	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
elf_i386_output_arch_local_syms	function
(	O
bfd	struct
*	O
output_bfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
void	O
*	O
flaginfo	pointer
ATTRIBUTE_UNUSED	O
,	O
int	O
(	O
*	O
func	pointer
)	O
(	O
void	O
*	O
,	O
const	O
char	O
*	O
,	O
Elf_Internal_Sym	struct
*	O
,	O
asection	struct
*	O
,	O
struct	O
elf_link_hash_entry	struct
*	O
)	O
ATTRIBUTE_UNUSED	O
)	O
{	O
struct	O
elf_x86_link_hash_table	struct
*	O
htab	struct
=	O
elf_x86_hash_table	O
(	O
info	pointer
,	O
I386_ELF_DATA	int
)	O
;	O
if	O
(	O
htab	struct
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
htab_traverse	function
(	O
htab	struct
->	O
loc_hash_table	pointer
,	O
elf_i386_finish_local_dynamic_symbol	function
,	O
info	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
elf_i386_nacl_plt	struct
;	O
static	O
long	O
elf_i386_get_synthetic_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
long	O
symcount	int
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
*	O
syms	pointer
ATTRIBUTE_UNUSED	O
,	O
long	O
dynsymcount	int
,	O
asymbol	struct
*	O
*	O
dynsyms	pointer
,	O
asymbol	struct
*	O
*	O
ret	pointer
)	O
{	O
long	O
count	int
,	O
i	pointer
,	O
n	long
;	O
int	O
j	int
;	O
bfd_byte	char
*	O
plt_contents	pointer
;	O
long	O
relsize	long
;	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
*	O
lazy_plt	pointer
;	O
const	O
struct	O
elf_x86_non_lazy_plt_layout	struct
*	O
non_lazy_plt	pointer
;	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
*	O
lazy_ibt_plt	pointer
;	O
const	O
struct	O
elf_x86_non_lazy_plt_layout	struct
*	O
non_lazy_ibt_plt	pointer
;	O
asection	struct
*	O
plt	union
;	O
bfd_vma	long
got_addr	long
;	O
enum	O
elf_x86_plt_type	enum
plt_type	enum
;	O
struct	O
elf_x86_plt	struct
plts	array
[	O
]	O
=	O
{	O
{	O
".plt"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
plt_unknown	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".plt.got"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
plt_non_lazy	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
".plt.sec"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
plt_second	union
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
plt_non_lazy	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
*	O
ret	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
abfd	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
EXEC_P	int
)	O
)	O
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
dynsymcount	int
<=	O
0	int
)	O
return	O
0	int
;	O
relsize	long
=	O
bfd_get_dynamic_reloc_upper_bound	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
relsize	long
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
non_lazy_plt	pointer
=	O
NULL	O
;	O
lazy_plt	pointer
=	O
NULL	O
;	O
non_lazy_ibt_plt	pointer
=	O
NULL	O
;	O
lazy_ibt_plt	pointer
=	O
NULL	O
;	O
switch	O
(	O
get_elf_x86_backend_data	O
(	O
abfd	pointer
)	O
->	O
target_os	enum
)	O
{	O
case	O
is_normal	int
:	O
case	O
is_solaris	int
:	O
non_lazy_plt	pointer
=	O
&	O
elf_i386_non_lazy_plt	struct
;	O
lazy_ibt_plt	pointer
=	O
&	O
elf_i386_lazy_ibt_plt	struct
;	O
non_lazy_ibt_plt	pointer
=	O
&	O
elf_i386_non_lazy_ibt_plt	struct
;	O
case	O
is_vxworks	int
:	O
lazy_plt	pointer
=	O
&	O
elf_i386_lazy_plt	struct
;	O
break	O
;	O
case	O
is_nacl	int
:	O
lazy_plt	pointer
=	O
&	O
elf_i386_nacl_plt	struct
;	O
break	O
;	O
}	O
got_addr	long
=	O
0	int
;	O
count	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
plts	array
[	O
j	int
]	O
.	O
name	pointer
!=	O
NULL	O
;	O
j	int
++	O
)	O
{	O
plt	union
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
plts	array
[	O
j	int
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
plt	union
==	O
NULL	O
||	O
plt	union
->	O
size	long
==	O
0	int
)	O
continue	O
;	O
plt_contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
plt	union
->	O
size	long
)	O
;	O
if	O
(	O
plt_contents	pointer
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
!	O
bfd_get_section_contents	function
(	O
abfd	pointer
,	O
(	O
asection	struct
*	O
)	O
plt	union
,	O
plt_contents	pointer
,	O
0	int
,	O
plt	union
->	O
size	long
)	O
)	O
{	O
free	function
(	O
plt_contents	pointer
)	O
;	O
break	O
;	O
}	O
plt_type	enum
=	O
plt_unknown	int
;	O
if	O
(	O
plts	array
[	O
j	int
]	O
.	O
type	enum
==	O
plt_unknown	int
&&	O
(	O
plt	union
->	O
size	long
>=	O
(	O
lazy_plt	pointer
->	O
plt0_entry_size	int
+	O
lazy_plt	pointer
->	O
plt_entry_size	int
)	O
)	O
)	O
{	O
if	O
(	O
memcmp	function
(	O
plt_contents	pointer
,	O
lazy_plt	pointer
->	O
plt0_entry	pointer
,	O
lazy_plt	pointer
->	O
plt0_got1_offset	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
lazy_ibt_plt	pointer
!=	O
NULL	O
&&	O
(	O
memcmp	function
(	O
plt_contents	pointer
+	O
lazy_ibt_plt	pointer
->	O
plt0_entry_size	int
,	O
lazy_ibt_plt	pointer
->	O
plt_entry	pointer
,	O
lazy_ibt_plt	pointer
->	O
plt_got_offset	int
)	O
==	O
0	int
)	O
)	O
plt_type	enum
=	O
plt_lazy	int
|	O
plt_second	union
;	O
else	O
plt_type	enum
=	O
plt_lazy	int
;	O
}	O
else	O
if	O
(	O
memcmp	function
(	O
plt_contents	pointer
,	O
lazy_plt	pointer
->	O
pic_plt0_entry	pointer
,	O
lazy_plt	pointer
->	O
plt0_got1_offset	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
lazy_ibt_plt	pointer
!=	O
NULL	O
&&	O
(	O
memcmp	function
(	O
plt_contents	pointer
+	O
lazy_ibt_plt	pointer
->	O
plt0_entry_size	int
,	O
lazy_ibt_plt	pointer
->	O
pic_plt_entry	pointer
,	O
lazy_ibt_plt	pointer
->	O
plt_got_offset	int
)	O
==	O
0	int
)	O
)	O
plt_type	enum
=	O
plt_lazy	int
|	O
plt_pic	int
|	O
plt_second	union
;	O
else	O
plt_type	enum
=	O
plt_lazy	int
|	O
plt_pic	int
;	O
}	O
}	O
if	O
(	O
non_lazy_plt	pointer
!=	O
NULL	O
&&	O
(	O
plt_type	enum
==	O
plt_unknown	int
||	O
plt_type	enum
==	O
plt_non_lazy	int
)	O
&&	O
plt	union
->	O
size	long
>=	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
)	O
{	O
if	O
(	O
memcmp	function
(	O
plt_contents	pointer
,	O
non_lazy_plt	pointer
->	O
plt_entry	pointer
,	O
non_lazy_plt	pointer
->	O
plt_got_offset	int
)	O
==	O
0	int
)	O
plt_type	enum
=	O
plt_non_lazy	int
;	O
else	O
if	O
(	O
memcmp	function
(	O
plt_contents	pointer
,	O
non_lazy_plt	pointer
->	O
pic_plt_entry	pointer
,	O
non_lazy_plt	pointer
->	O
plt_got_offset	int
)	O
==	O
0	int
)	O
plt_type	enum
=	O
plt_pic	int
;	O
}	O
if	O
(	O
(	O
non_lazy_ibt_plt	pointer
!=	O
NULL	O
)	O
&&	O
(	O
plt_type	enum
==	O
plt_unknown	int
||	O
plt_type	enum
==	O
plt_second	union
)	O
&&	O
plt	union
->	O
size	long
>=	O
non_lazy_ibt_plt	pointer
->	O
plt_entry_size	int
)	O
{	O
if	O
(	O
memcmp	function
(	O
plt_contents	pointer
,	O
non_lazy_ibt_plt	pointer
->	O
plt_entry	pointer
,	O
non_lazy_ibt_plt	pointer
->	O
plt_got_offset	int
)	O
==	O
0	int
)	O
{	O
plt_type	enum
=	O
plt_second	union
;	O
non_lazy_plt	pointer
=	O
non_lazy_ibt_plt	pointer
;	O
}	O
else	O
if	O
(	O
memcmp	function
(	O
plt_contents	pointer
,	O
non_lazy_ibt_plt	pointer
->	O
pic_plt_entry	pointer
,	O
non_lazy_ibt_plt	pointer
->	O
plt_got_offset	int
)	O
==	O
0	int
)	O
{	O
plt_type	enum
=	O
plt_second	union
|	O
plt_pic	int
;	O
non_lazy_plt	pointer
=	O
non_lazy_ibt_plt	pointer
;	O
}	O
}	O
if	O
(	O
plt_type	enum
==	O
plt_unknown	int
)	O
{	O
free	function
(	O
plt_contents	pointer
)	O
;	O
continue	O
;	O
}	O
plts	array
[	O
j	int
]	O
.	O
sec	pointer
=	O
plt	union
;	O
plts	array
[	O
j	int
]	O
.	O
type	enum
=	O
plt_type	enum
;	O
if	O
(	O
(	O
plt_type	enum
&	O
plt_lazy	int
)	O
)	O
{	O
plts	array
[	O
j	int
]	O
.	O
plt_got_offset	int
=	O
lazy_plt	pointer
->	O
plt_got_offset	int
;	O
plts	array
[	O
j	int
]	O
.	O
plt_entry_size	int
=	O
lazy_plt	pointer
->	O
plt_entry_size	int
;	O
i	pointer
=	O
1	int
;	O
}	O
else	O
{	O
plts	array
[	O
j	int
]	O
.	O
plt_got_offset	int
=	O
non_lazy_plt	pointer
->	O
plt_got_offset	int
;	O
plts	array
[	O
j	int
]	O
.	O
plt_entry_size	int
=	O
non_lazy_plt	pointer
->	O
plt_entry_size	int
;	O
i	pointer
=	O
0	int
;	O
}	O
if	O
(	O
(	O
plt_type	enum
&	O
(	O
plt_lazy	int
|	O
plt_second	union
)	O
)	O
==	O
(	O
plt_lazy	int
|	O
plt_second	union
)	O
)	O
plts	array
[	O
j	int
]	O
.	O
count	int
=	O
0	int
;	O
else	O
{	O
n	long
=	O
plt	union
->	O
size	long
/	O
plts	array
[	O
j	int
]	O
.	O
plt_entry_size	int
;	O
plts	array
[	O
j	int
]	O
.	O
count	int
=	O
n	long
;	O
count	int
+=	O
n	long
-	O
i	pointer
;	O
}	O
plts	array
[	O
j	int
]	O
.	O
contents	pointer
=	O
plt_contents	pointer
;	O
if	O
(	O
(	O
plt_type	enum
&	O
plt_pic	int
)	O
)	O
got_addr	long
=	O
(	O
bfd_vma	long
)	O
-	O
1	int
;	O
}	O
return	O
_bfd_x86_elf_get_synthetic_symtab	function
(	O
abfd	pointer
,	O
count	int
,	O
relsize	long
,	O
got_addr	long
,	O
plts	array
,	O
dynsyms	pointer
,	O
ret	pointer
)	O
;	O
}	O
static	O
bfd	struct
*	O
elf_i386_link_setup_gnu_properties	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
struct	O
elf_x86_init_table	struct
init_table	struct
;	O
switch	O
(	O
get_elf_x86_backend_data	O
(	O
info	pointer
->	O
output_bfd	pointer
)	O
->	O
target_os	enum
)	O
{	O
case	O
is_normal	int
:	O
case	O
is_solaris	int
:	O
init_table	struct
.	O
plt0_pad_byte	char
=	O
0x0	int
;	O
init_table	struct
.	O
lazy_plt	pointer
=	O
&	O
elf_i386_lazy_plt	struct
;	O
init_table	struct
.	O
non_lazy_plt	pointer
=	O
&	O
elf_i386_non_lazy_plt	struct
;	O
init_table	struct
.	O
lazy_ibt_plt	pointer
=	O
&	O
elf_i386_lazy_ibt_plt	struct
;	O
init_table	struct
.	O
non_lazy_ibt_plt	pointer
=	O
&	O
elf_i386_non_lazy_ibt_plt	struct
;	O
break	O
;	O
case	O
is_vxworks	int
:	O
init_table	struct
.	O
plt0_pad_byte	char
=	O
0x90	int
;	O
init_table	struct
.	O
lazy_plt	pointer
=	O
&	O
elf_i386_lazy_plt	struct
;	O
init_table	struct
.	O
non_lazy_plt	pointer
=	O
NULL	O
;	O
init_table	struct
.	O
lazy_ibt_plt	pointer
=	O
NULL	O
;	O
init_table	struct
.	O
non_lazy_ibt_plt	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
is_nacl	int
:	O
init_table	struct
.	O
plt0_pad_byte	char
=	O
0x90	int
;	O
init_table	struct
.	O
lazy_plt	pointer
=	O
&	O
elf_i386_nacl_plt	struct
;	O
init_table	struct
.	O
non_lazy_plt	pointer
=	O
NULL	O
;	O
init_table	struct
.	O
lazy_ibt_plt	pointer
=	O
NULL	O
;	O
init_table	struct
.	O
non_lazy_ibt_plt	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
init_table	struct
.	O
r_info	array
=	O
elf32_r_info	function
;	O
init_table	struct
.	O
r_sym	pointer
=	O
elf32_r_sym	function
;	O
return	O
_bfd_x86_elf_link_setup_gnu_properties	function
(	O
info	pointer
,	O
&	O
init_table	struct
)	O
;	O
}	O
static	O
bfd_boolean	int
elf_i386_fbsd_init_file_header	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
if	O
(	O
!	O
_bfd_elf_init_file_header	function
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
struct	O
elf_x86_backend_data	struct
elf_i386_solaris_arch_bed	struct
=	O
{	O
is_solaris	int
}	O
;	O
static	O
bfd_boolean	int
elf32_i386_copy_solaris_special_section_fields	function
(	O
const	O
bfd	struct
*	O
ibfd	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
obfd	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
Elf_Internal_Shdr	struct
*	O
isection	pointer
ATTRIBUTE_UNUSED	O
,	O
Elf_Internal_Shdr	struct
*	O
osection	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
elf32_iamcu_elf_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_default_set_arch_mach	function
(	O
abfd	pointer
,	O
bfd_arch_iamcu	int
,	O
bfd_mach_i386_iamcu	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
bfd_byte	char
elf_i386_nacl_plt0_entry	array
[	O
]	O
=	O
{	O
0xff	int
,	O
0x35	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x8b	int
,	O
0x0d	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x83	int
,	O
0xe1	int
,	O
NACLMASK	int
,	O
0xff	int
,	O
0xe1	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_nacl_plt_entry	array
[	O
NACL_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0x8b	int
,	O
0x0d	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x83	int
,	O
0xe1	int
,	O
NACLMASK	int
,	O
0xff	int
,	O
0xe1	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x68	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xe9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_nacl_pic_plt0_entry	array
[	O
sizeof	O
(	O
elf_i386_nacl_plt0_entry	array
)	O
]	O
=	O
{	O
0xff	int
,	O
0x73	int
,	O
0x04	int
,	O
0x8b	int
,	O
0x4b	int
,	O
0x08	int
,	O
0x83	int
,	O
0xe1	int
,	O
0xe0	int
,	O
0xff	int
,	O
0xe1	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_nacl_pic_plt_entry	array
[	O
NACL_PLT_ENTRY_SIZE	int
]	O
=	O
{	O
0x8b	int
,	O
0x8b	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x83	int
,	O
0xe1	int
,	O
0xe0	int
,	O
0xff	int
,	O
0xe1	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x68	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0xe9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
,	O
0x90	int
}	O
;	O
static	O
const	O
bfd_byte	char
elf_i386_nacl_eh_frame_plt	array
[	O
]	O
=	O
{	O
PLT_CIE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
'z'	O
,	O
'R'	O
,	O
0	int
,	O
1	int
,	O
0x7c	int
,	O
8	int
,	O
1	int
,	O
DW_EH_PE_pcrel	int
|	O
DW_EH_PE_sdata4	int
,	O
DW_CFA_def_cfa	int
,	O
4	int
,	O
4	int
,	O
DW_CFA_offset	int
+	O
8	int
,	O
1	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
,	O
PLT_FDE_LENGTH	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
PLT_CIE_LENGTH	int
+	O
8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
DW_CFA_def_cfa_offset	int
,	O
8	int
,	O
DW_CFA_advance_loc	int
+	O
6	int
,	O
DW_CFA_def_cfa_offset	int
,	O
12	int
,	O
DW_CFA_advance_loc	int
+	O
58	int
,	O
DW_CFA_def_cfa_expression	int
,	O
13	int
,	O
DW_OP_breg4	int
,	O
4	int
,	O
DW_OP_breg8	int
,	O
0	int
,	O
DW_OP_const1u	int
,	O
63	int
,	O
DW_OP_and	int
,	O
DW_OP_const1u	int
,	O
37	int
,	O
DW_OP_ge	int
,	O
DW_OP_lit2	int
,	O
DW_OP_shl	int
,	O
DW_OP_plus	int
,	O
DW_CFA_nop	int
,	O
DW_CFA_nop	int
}	O
;	O
static	O
const	O
struct	O
elf_x86_lazy_plt_layout	struct
elf_i386_nacl_plt	struct
=	O
{	O
elf_i386_nacl_plt0_entry	array
,	O
sizeof	O
(	O
elf_i386_nacl_plt0_entry	array
)	O
,	O
elf_i386_nacl_plt_entry	array
,	O
NACL_PLT_ENTRY_SIZE	int
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
8	int
,	O
0	int
,	O
2	int
,	O
33	int
,	O
38	int
,	O
0	int
,	O
0	int
,	O
32	int
,	O
elf_i386_nacl_pic_plt0_entry	array
,	O
elf_i386_nacl_pic_plt_entry	array
,	O
elf_i386_nacl_eh_frame_plt	array
,	O
sizeof	O
(	O
elf_i386_nacl_eh_frame_plt	array
)	O
}	O
;	O
static	O
const	O
struct	O
elf_x86_backend_data	struct
elf_i386_nacl_arch_bed	struct
=	O
{	O
is_nacl	int
}	O
;	O
static	O
bfd_boolean	int
elf32_i386_nacl_elf_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_default_set_arch_mach	function
(	O
abfd	pointer
,	O
bfd_arch_i386	int
,	O
bfd_mach_i386_i386_nacl	O
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
const	O
struct	O
elf_x86_backend_data	struct
elf_i386_vxworks_arch_bed	struct
=	O
{	O
is_vxworks	int
}	O
;	O
