static	O
unsigned	O
int	O
plural_expression_histogram	function
(	O
const	O
struct	O
plural_distribution	struct
*	O
self	pointer
,	O
int	O
min	int
,	O
int	O
max	int
,	O
unsigned	O
long	O
j	long
)	O
{	O
if	O
(	O
min	int
<	O
0	int
)	O
min	int
=	O
0	int
;	O
if	O
(	O
max	int
-	O
min	int
>	O
1000	int
)	O
max	int
=	O
min	int
+	O
1000	int
;	O
if	O
(	O
min	int
<=	O
max	int
)	O
{	O
const	O
struct	O
expression	struct
*	O
expr	pointer
=	O
self	pointer
->	O
expr	pointer
;	O
unsigned	O
long	O
n	long
;	O
unsigned	O
int	O
count	pointer
;	O
install_sigfpe_handler	function
(	O
)	O
;	O
count	pointer
=	O
0	int
;	O
for	O
(	O
n	long
=	O
min	int
;	O
n	long
<=	O
max	int
;	O
n	long
++	O
)	O
{	O
unsigned	O
long	O
val	union
=	O
plural_eval	function
(	O
expr	pointer
,	O
n	long
)	O
;	O
if	O
(	O
val	union
==	O
j	long
)	O
count	pointer
++	O
;	O
}	O
uninstall_sigfpe_handler	function
(	O
)	O
;	O
return	O
count	pointer
;	O
}	O
else	O
return	O
0	int
;	O
}	O
int	O
check_plural_eval	function
(	O
const	O
struct	O
expression	struct
*	O
plural_expr	pointer
,	O
unsigned	O
long	O
nplurals_value	long
,	O
const	O
message_ty	struct
*	O
header	pointer
,	O
struct	O
plural_distribution	struct
*	O
distribution	pointer
)	O
{	O
unsigned	O
char	O
*	O
volatile	O
array	pointer
;	O
if	O
(	O
nplurals_value	long
<=	O
100	int
)	O
array	pointer
=	O
XCALLOC	O
(	O
nplurals_value	long
,	O
unsigned	O
char	O
)	O
;	O
else	O
array	pointer
=	O
NULL	O
;	O
if	O
(	O
sigsetjmp	O
(	O
sigfpe_exit	array
,	O
1	int
)	O
==	O
0	int
)	O
{	O
unsigned	O
long	O
n	long
;	O
install_sigfpe_handler	function
(	O
)	O
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<=	O
1000	int
;	O
n	long
++	O
)	O
{	O
unsigned	O
long	O
val	union
=	O
plural_eval	function
(	O
plural_expr	pointer
,	O
n	long
)	O
;	O
if	O
(	O
(	O
long	O
)	O
val	union
<	O
0	int
)	O
{	O
uninstall_sigfpe_handler	function
(	O
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"plural expression can produce negative values"	pointer
)	O
)	O
;	O
free	function
(	O
array	pointer
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
val	union
>=	O
nplurals_value	long
)	O
{	O
char	O
*	O
msg	pointer
;	O
uninstall_sigfpe_handler	function
(	O
)	O
;	O
msg	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"nplurals = %lu but plural expression can produce values as large as %lu"	pointer
)	O
,	O
nplurals_value	long
,	O
val	union
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg	pointer
)	O
;	O
free	function
(	O
msg	pointer
)	O
;	O
free	function
(	O
array	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
array	pointer
!=	O
NULL	O
&&	O
array	pointer
[	O
val	union
]	O
<	O
OFTEN	int
)	O
array	pointer
[	O
val	union
]	O
++	O
;	O
}	O
uninstall_sigfpe_handler	function
(	O
)	O
;	O
if	O
(	O
array	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
long	O
val	union
;	O
for	O
(	O
val	union
=	O
0	int
;	O
val	union
<	O
nplurals_value	long
;	O
val	union
++	O
)	O
array	pointer
[	O
val	union
]	O
=	O
(	O
array	pointer
[	O
val	union
]	O
==	O
OFTEN	int
?	O
1	int
:	O
0	int
)	O
;	O
}	O
distribution	pointer
->	O
expr	pointer
=	O
plural_expr	pointer
;	O
distribution	pointer
->	O
often	pointer
=	O
array	pointer
;	O
distribution	pointer
->	O
often_length	long
=	O
(	O
array	pointer
!=	O
NULL	O
?	O
nplurals_value	long
:	O
0	int
)	O
;	O
distribution	pointer
->	O
histogram	pointer
=	O
plural_expression_histogram	function
;	O
return	O
0	int
;	O
}	O
else	O
{	O
const	O
char	O
*	O
msg	pointer
;	O
uninstall_sigfpe_handler	function
(	O
)	O
;	O
switch	O
(	O
sigfpe_code	int
)	O
{	O
case	O
FPE_INTDIV	int
:	O
msg	pointer
=	O
_	O
(	O
"plural expression can produce division by zero"	pointer
)	O
;	O
break	O
;	O
case	O
FPE_INTOVF	int
:	O
msg	pointer
=	O
_	O
(	O
"plural expression can produce integer overflow"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
msg	pointer
=	O
_	O
(	O
"plural expression can produce arithmetic exceptions, possibly division by zero"	pointer
)	O
;	O
}	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg	pointer
)	O
;	O
free	function
(	O
array	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
static	O
char	O
*	O
plural_help	function
(	O
const	O
char	O
*	O
nullentry	pointer
)	O
{	O
struct	O
plural_table_entry	struct
*	O
ptentry	pointer
=	O
NULL	O
;	O
{	O
const	O
char	O
*	O
language	pointer
;	O
language	pointer
=	O
c_strstr	function
(	O
nullentry	pointer
,	O
"Language: "	pointer
)	O
;	O
if	O
(	O
language	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
;	O
language	pointer
+=	O
10	int
;	O
len	long
=	O
strcspn	function
(	O
language	pointer
,	O
" \t\n"	pointer
)	O
;	O
if	O
(	O
len	long
>	O
0	int
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
plural_table_size	long
;	O
j	long
++	O
)	O
if	O
(	O
len	long
==	O
strlen	function
(	O
plural_table	array
[	O
j	long
]	O
.	O
lang	pointer
)	O
&&	O
strncmp	function
(	O
language	pointer
,	O
plural_table	array
[	O
j	long
]	O
.	O
lang	pointer
,	O
len	long
)	O
==	O
0	int
)	O
{	O
ptentry	pointer
=	O
&	O
plural_table	array
[	O
j	long
]	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
ptentry	pointer
==	O
NULL	O
)	O
{	O
const	O
char	O
*	O
language	pointer
;	O
language	pointer
=	O
c_strstr	function
(	O
nullentry	pointer
,	O
"Language-Team: "	pointer
)	O
;	O
if	O
(	O
language	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
j	long
;	O
language	pointer
+=	O
15	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
plural_table_size	long
;	O
j	long
++	O
)	O
if	O
(	O
strncmp	function
(	O
language	pointer
,	O
plural_table	array
[	O
j	long
]	O
.	O
language	pointer
,	O
strlen	function
(	O
plural_table	array
[	O
j	long
]	O
.	O
language	pointer
)	O
)	O
==	O
0	int
)	O
{	O
ptentry	pointer
=	O
&	O
plural_table	array
[	O
j	long
]	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
ptentry	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
helpline1	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"Try using the following, valid for %s:"	pointer
)	O
,	O
ptentry	pointer
->	O
language	pointer
)	O
;	O
char	O
*	O
help	pointer
=	O
xasprintf	function
(	O
"%s\n\"Plural-Forms: %s\\n\"\n"	pointer
,	O
helpline1	pointer
,	O
ptentry	pointer
->	O
value	pointer
)	O
;	O
free	function
(	O
helpline1	pointer
)	O
;	O
return	O
help	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
check_plural	function
(	O
message_list_ty	struct
*	O
mlp	pointer
,	O
int	O
ignore_untranslated_messages	int
,	O
int	O
ignore_fuzzy_messages	int
,	O
struct	O
plural_distribution	struct
*	O
distributionp	pointer
)	O
{	O
int	O
seen_errors	int
=	O
0	int
;	O
const	O
message_ty	struct
*	O
has_plural	pointer
;	O
unsigned	O
long	O
min_nplurals	long
;	O
const	O
message_ty	struct
*	O
min_pos	pointer
;	O
unsigned	O
long	O
max_nplurals	long
;	O
const	O
message_ty	struct
*	O
max_pos	pointer
;	O
struct	O
plural_distribution	struct
distribution	pointer
;	O
size_t	long
j	long
;	O
message_ty	struct
*	O
header	pointer
;	O
has_plural	pointer
=	O
NULL	O
;	O
min_nplurals	long
=	O
ULONG_MAX	O
;	O
min_pos	pointer
=	O
NULL	O
;	O
max_nplurals	long
=	O
0	int
;	O
max_pos	pointer
=	O
NULL	O
;	O
distribution	pointer
.	O
expr	pointer
=	O
NULL	O
;	O
distribution	pointer
.	O
often	pointer
=	O
NULL	O
;	O
distribution	pointer
.	O
often_length	long
=	O
0	int
;	O
distribution	pointer
.	O
histogram	pointer
=	O
NULL	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
!	O
mp	pointer
->	O
obsolete	bool
&&	O
!	O
(	O
ignore_untranslated_messages	int
&&	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
&&	O
!	O
(	O
ignore_fuzzy_messages	int
&&	O
(	O
mp	pointer
->	O
is_fuzzy	bool
&&	O
!	O
is_header	O
(	O
mp	pointer
)	O
)	O
)	O
&&	O
mp	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
const	O
char	O
*	O
p_end	pointer
;	O
unsigned	O
long	O
n	long
;	O
if	O
(	O
has_plural	pointer
==	O
NULL	O
)	O
has_plural	pointer
=	O
mp	pointer
;	O
n	long
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
mp	pointer
->	O
msgstr	pointer
,	O
p_end	pointer
=	O
p	pointer
+	O
mp	pointer
->	O
msgstr_len	long
;	O
p	pointer
<	O
p_end	pointer
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
)	O
n	long
++	O
;	O
if	O
(	O
min_nplurals	long
>	O
n	long
)	O
{	O
min_nplurals	long
=	O
n	long
;	O
min_pos	pointer
=	O
mp	pointer
;	O
}	O
if	O
(	O
max_nplurals	long
<	O
n	long
)	O
{	O
max_nplurals	long
=	O
n	long
;	O
max_pos	pointer
=	O
mp	pointer
;	O
}	O
}	O
}	O
header	pointer
=	O
message_list_search	function
(	O
mlp	pointer
,	O
NULL	O
,	O
""	pointer
)	O
;	O
if	O
(	O
header	pointer
!=	O
NULL	O
&&	O
!	O
header	pointer
->	O
obsolete	bool
)	O
{	O
const	O
char	O
*	O
nullentry	pointer
;	O
const	O
char	O
*	O
plural	pointer
;	O
const	O
char	O
*	O
nplurals	pointer
;	O
nullentry	pointer
=	O
header	pointer
->	O
msgstr	pointer
;	O
plural	pointer
=	O
c_strstr	function
(	O
nullentry	pointer
,	O
"plural="	pointer
)	O
;	O
nplurals	pointer
=	O
c_strstr	function
(	O
nullentry	pointer
,	O
"nplurals="	pointer
)	O
;	O
if	O
(	O
plural	pointer
==	O
NULL	O
&&	O
has_plural	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
msg1	pointer
=	O
_	O
(	O
"message catalog has plural form translations"	pointer
)	O
;	O
const	O
char	O
*	O
msg2	pointer
=	O
_	O
(	O
"but header entry lacks a \"plural=EXPRESSION\" attribute"	pointer
)	O
;	O
char	O
*	O
help	pointer
=	O
plural_help	function
(	O
nullentry	pointer
)	O
;	O
if	O
(	O
help	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
msg2ext	pointer
=	O
xasprintf	function
(	O
"%s\n%s"	pointer
,	O
msg2	pointer
,	O
help	pointer
)	O
;	O
po_xerror2	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
has_plural	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg1	pointer
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	int
,	O
msg2ext	pointer
)	O
;	O
free	function
(	O
msg2ext	pointer
)	O
;	O
free	function
(	O
help	pointer
)	O
;	O
}	O
else	O
po_xerror2	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
has_plural	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg1	pointer
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg2	pointer
)	O
;	O
seen_errors	int
++	O
;	O
}	O
if	O
(	O
nplurals	pointer
==	O
NULL	O
&&	O
has_plural	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
msg1	pointer
=	O
_	O
(	O
"message catalog has plural form translations"	pointer
)	O
;	O
const	O
char	O
*	O
msg2	pointer
=	O
_	O
(	O
"but header entry lacks a \"nplurals=INTEGER\" attribute"	pointer
)	O
;	O
char	O
*	O
help	pointer
=	O
plural_help	function
(	O
nullentry	pointer
)	O
;	O
if	O
(	O
help	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
msg2ext	pointer
=	O
xasprintf	function
(	O
"%s\n%s"	pointer
,	O
msg2	pointer
,	O
help	pointer
)	O
;	O
po_xerror2	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
has_plural	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg1	pointer
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	int
,	O
msg2ext	pointer
)	O
;	O
free	function
(	O
msg2ext	pointer
)	O
;	O
free	function
(	O
help	pointer
)	O
;	O
}	O
else	O
po_xerror2	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
has_plural	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg1	pointer
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg2	pointer
)	O
;	O
seen_errors	int
++	O
;	O
}	O
if	O
(	O
plural	pointer
!=	O
NULL	O
&&	O
nplurals	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
endp	pointer
;	O
unsigned	O
long	O
int	O
nplurals_value	long
;	O
struct	O
parse_args	struct
args	array
;	O
const	O
struct	O
expression	struct
*	O
plural_expr	pointer
;	O
nplurals	pointer
+=	O
9	int
;	O
while	O
(	O
*	O
nplurals	pointer
!=	O
'\0'	O
&&	O
c_isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
nplurals	pointer
)	O
)	O
++	O
nplurals	pointer
;	O
endp	pointer
=	O
nplurals	pointer
;	O
nplurals_value	long
=	O
0	int
;	O
if	O
(	O
*	O
nplurals	pointer
>=	O
'0'	O
&&	O
*	O
nplurals	pointer
<=	O
'9'	O
)	O
nplurals_value	long
=	O
strtoul	function
(	O
nplurals	pointer
,	O
(	O
char	O
*	O
*	O
)	O
&	O
endp	pointer
,	O
10	int
)	O
;	O
if	O
(	O
nplurals	pointer
==	O
endp	pointer
)	O
{	O
const	O
char	O
*	O
msg	pointer
=	O
_	O
(	O
"invalid nplurals value"	pointer
)	O
;	O
char	O
*	O
help	pointer
=	O
plural_help	function
(	O
nullentry	pointer
)	O
;	O
if	O
(	O
help	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
msgext	pointer
=	O
xasprintf	function
(	O
"%s\n%s"	pointer
,	O
msg	pointer
,	O
help	pointer
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	int
,	O
msgext	pointer
)	O
;	O
free	function
(	O
msgext	pointer
)	O
;	O
free	function
(	O
help	pointer
)	O
;	O
}	O
else	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg	pointer
)	O
;	O
seen_errors	int
++	O
;	O
}	O
plural	pointer
+=	O
7	int
;	O
args	array
.	O
cp	pointer
=	O
plural	pointer
;	O
if	O
(	O
parse_plural_expression	function
(	O
&	O
args	array
)	O
!=	O
0	int
)	O
{	O
const	O
char	O
*	O
msg	pointer
=	O
_	O
(	O
"invalid plural expression"	pointer
)	O
;	O
char	O
*	O
help	pointer
=	O
plural_help	function
(	O
nullentry	pointer
)	O
;	O
if	O
(	O
help	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
msgext	pointer
=	O
xasprintf	function
(	O
"%s\n%s"	pointer
,	O
msg	pointer
,	O
help	pointer
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	int
,	O
msgext	pointer
)	O
;	O
free	function
(	O
msgext	pointer
)	O
;	O
free	function
(	O
help	pointer
)	O
;	O
}	O
else	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg	pointer
)	O
;	O
seen_errors	int
++	O
;	O
}	O
plural_expr	pointer
=	O
args	array
.	O
res	pointer
;	O
if	O
(	O
!	O
seen_errors	int
)	O
seen_errors	int
=	O
check_plural_eval	function
(	O
plural_expr	pointer
,	O
nplurals_value	long
,	O
header	pointer
,	O
&	O
distribution	pointer
)	O
;	O
if	O
(	O
!	O
seen_errors	int
)	O
{	O
if	O
(	O
min_nplurals	long
<	O
nplurals_value	long
)	O
{	O
char	O
*	O
msg1	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"nplurals = %lu"	pointer
)	O
,	O
nplurals_value	long
)	O
;	O
char	O
*	O
msg2	pointer
=	O
xasprintf	function
(	O
ngettext	function
(	O
"but some messages have only one plural form"	pointer
,	O
"but some messages have only %lu plural forms"	pointer
,	O
min_nplurals	long
)	O
,	O
min_nplurals	long
)	O
;	O
po_xerror2	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg1	pointer
,	O
min_pos	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg2	pointer
)	O
;	O
free	function
(	O
msg2	pointer
)	O
;	O
free	function
(	O
msg1	pointer
)	O
;	O
seen_errors	int
++	O
;	O
}	O
else	O
if	O
(	O
max_nplurals	long
>	O
nplurals_value	long
)	O
{	O
char	O
*	O
msg1	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"nplurals = %lu"	pointer
)	O
,	O
nplurals_value	long
)	O
;	O
char	O
*	O
msg2	pointer
=	O
xasprintf	function
(	O
ngettext	function
(	O
"but some messages have one plural form"	pointer
,	O
"but some messages have %lu plural forms"	pointer
,	O
max_nplurals	long
)	O
,	O
max_nplurals	long
)	O
;	O
po_xerror2	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
header	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg1	pointer
,	O
max_pos	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg2	pointer
)	O
;	O
free	function
(	O
msg2	pointer
)	O
;	O
free	function
(	O
msg1	pointer
)	O
;	O
seen_errors	int
++	O
;	O
}	O
}	O
}	O
else	O
goto	O
no_plural	O
;	O
}	O
else	O
{	O
if	O
(	O
has_plural	pointer
!=	O
NULL	O
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
has_plural	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"message catalog has plural form translations, but lacks a header entry with \"Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\""	pointer
)	O
)	O
;	O
seen_errors	int
++	O
;	O
}	O
no_plural	O
:	O
distribution	pointer
.	O
expr	pointer
=	O
&	O
germanic_plural	struct
;	O
{	O
unsigned	O
char	O
*	O
array	pointer
=	O
XCALLOC	O
(	O
2	int
,	O
unsigned	O
char	O
)	O
;	O
array	pointer
[	O
1	int
]	O
=	O
1	int
;	O
distribution	pointer
.	O
often	pointer
=	O
array	pointer
;	O
}	O
distribution	pointer
.	O
often_length	long
=	O
2	int
;	O
distribution	pointer
.	O
histogram	pointer
=	O
plural_expression_histogram	function
;	O
}	O
if	O
(	O
seen_errors	int
>	O
0	int
)	O
free	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
distribution	pointer
.	O
often	pointer
)	O
;	O
else	O
*	O
distributionp	pointer
=	O
distribution	pointer
;	O
return	O
seen_errors	int
;	O
}	O
static	O
const	O
message_ty	struct
*	O
curr_mp	pointer
;	O
static	O
lex_pos_ty	struct
curr_msgid_pos	struct
;	O
static	O
void	O
formatstring_error_logger	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
__attribute__	O
(	O
(	O
__format__	O
(	O
__printf__	O
,	O
1	int
,	O
2	int
)	O
)	O
)	O
;	O
static	O
void	O
formatstring_error_logger	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
char	O
*	O
msg	pointer
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
if	O
(	O
vasprintf	function
(	O
&	O
msg	pointer
,	O
format	pointer
,	O
args	array
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"memory exhausted"	pointer
)	O
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
curr_mp	pointer
,	O
curr_msgid_pos	struct
.	O
file_name	pointer
,	O
curr_msgid_pos	struct
.	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
msg	pointer
)	O
;	O
free	function
(	O
msg	pointer
)	O
;	O
}	O
static	O
int	O
check_pair	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
const	O
char	O
*	O
msgid	pointer
,	O
const	O
lex_pos_ty	struct
*	O
msgid_pos	pointer
,	O
const	O
char	O
*	O
msgid_plural	pointer
,	O
const	O
char	O
*	O
msgstr	pointer
,	O
size_t	long
msgstr_len	long
,	O
const	O
enum	O
is_format	enum
is_format	enum
[	O
NFORMATS	int
]	O
,	O
int	O
check_newlines	int
,	O
int	O
check_format_strings	int
,	O
const	O
struct	O
plural_distribution	struct
*	O
distribution	pointer
,	O
int	O
check_compatibility	int
,	O
int	O
check_accelerators	int
,	O
char	O
accelerator_char	char
)	O
{	O
int	O
seen_errors	int
;	O
int	O
has_newline	int
;	O
unsigned	O
int	O
j	long
;	O
if	O
(	O
msgid	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
0	int
;	O
seen_errors	int
=	O
0	int
;	O
if	O
(	O
check_newlines	int
)	O
{	O
has_newline	int
=	O
(	O
msgid	pointer
[	O
0	int
]	O
==	O
'\n'	O
)	O
;	O
if	O
(	O
msgid_plural	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
if	O
(	O
TEST_NEWLINE	O
(	O
msgid_plural	pointer
)	O
!=	O
has_newline	int
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
msgid_pos	pointer
->	O
file_name	pointer
,	O
msgid_pos	pointer
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
_	O
(	O
"'msgid' and 'msgid_plural' entries do not both begin with '\\n'"	pointer
)	O
)	O
;	O
seen_errors	int
++	O
;	O
}	O
for	O
(	O
p	pointer
=	O
msgstr	pointer
,	O
j	long
=	O
0	int
;	O
p	pointer
<	O
msgstr	pointer
+	O
msgstr_len	long
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
,	O
j	long
++	O
)	O
if	O
(	O
TEST_NEWLINE	O
(	O
p	pointer
)	O
!=	O
has_newline	int
)	O
{	O
char	O
*	O
msg	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"'msgid' and 'msgstr[%u]' entries do not both begin with '\\n'"	pointer
)	O
,	O
j	long
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
msgid_pos	pointer
->	O
file_name	pointer
,	O
msgid_pos	pointer
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
msg	pointer
)	O
;	O
free	function
(	O
msg	pointer
)	O
;	O
seen_errors	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
TEST_NEWLINE	O
(	O
msgstr	pointer
)	O
!=	O
has_newline	int
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
msgid_pos	pointer
->	O
file_name	pointer
,	O
msgid_pos	pointer
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
_	O
(	O
"'msgid' and 'msgstr' entries do not both begin with '\\n'"	pointer
)	O
)	O
;	O
seen_errors	int
++	O
;	O
}	O
}	O
has_newline	int
=	O
(	O
msgid	pointer
[	O
strlen	function
(	O
msgid	pointer
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
;	O
if	O
(	O
msgid_plural	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
if	O
(	O
TEST_NEWLINE	O
(	O
msgid_plural	pointer
)	O
!=	O
has_newline	int
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
msgid_pos	pointer
->	O
file_name	pointer
,	O
msgid_pos	pointer
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
_	O
(	O
"'msgid' and 'msgid_plural' entries do not both end with '\\n'"	pointer
)	O
)	O
;	O
seen_errors	int
++	O
;	O
}	O
for	O
(	O
p	pointer
=	O
msgstr	pointer
,	O
j	long
=	O
0	int
;	O
p	pointer
<	O
msgstr	pointer
+	O
msgstr_len	long
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
,	O
j	long
++	O
)	O
if	O
(	O
TEST_NEWLINE	O
(	O
p	pointer
)	O
!=	O
has_newline	int
)	O
{	O
char	O
*	O
msg	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"'msgid' and 'msgstr[%u]' entries do not both end with '\\n'"	pointer
)	O
,	O
j	long
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
msgid_pos	pointer
->	O
file_name	pointer
,	O
msgid_pos	pointer
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
msg	pointer
)	O
;	O
free	function
(	O
msg	pointer
)	O
;	O
seen_errors	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
TEST_NEWLINE	O
(	O
msgstr	pointer
)	O
!=	O
has_newline	int
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
msgid_pos	pointer
->	O
file_name	pointer
,	O
msgid_pos	pointer
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
_	O
(	O
"'msgid' and 'msgstr' entries do not both end with '\\n'"	pointer
)	O
)	O
;	O
seen_errors	int
++	O
;	O
}	O
}	O
}	O
if	O
(	O
check_compatibility	int
&&	O
msgid_plural	pointer
!=	O
NULL	O
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
msgid_pos	pointer
->	O
file_name	pointer
,	O
msgid_pos	pointer
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
_	O
(	O
"plural handling is a GNU gettext extension"	pointer
)	O
)	O
;	O
seen_errors	int
++	O
;	O
}	O
if	O
(	O
check_format_strings	int
)	O
{	O
curr_mp	pointer
=	O
mp	pointer
;	O
curr_msgid_pos	struct
=	O
*	O
msgid_pos	pointer
;	O
seen_errors	int
+=	O
check_msgid_msgstr_format	function
(	O
msgid	pointer
,	O
msgid_plural	pointer
,	O
msgstr	pointer
,	O
msgstr_len	long
,	O
is_format	enum
,	O
mp	pointer
->	O
range	struct
,	O
distribution	pointer
,	O
formatstring_error_logger	function
)	O
;	O
}	O
if	O
(	O
check_accelerators	int
&&	O
msgid_plural	pointer
==	O
NULL	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
strchr	function
(	O
msgid	pointer
,	O
accelerator_char	char
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
&&	O
strchr	function
(	O
p	pointer
+	O
1	int
,	O
accelerator_char	char
)	O
==	O
NULL	O
)	O
{	O
unsigned	O
int	O
count	pointer
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
msgstr	pointer
;	O
(	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
accelerator_char	char
)	O
)	O
!=	O
NULL	O
;	O
p	pointer
++	O
)	O
if	O
(	O
p	pointer
[	O
1	int
]	O
==	O
accelerator_char	char
)	O
p	pointer
++	O
;	O
else	O
count	pointer
++	O
;	O
if	O
(	O
count	pointer
==	O
0	int
)	O
{	O
char	O
*	O
msg	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"msgstr lacks the keyboard accelerator mark '%c'"	pointer
)	O
,	O
accelerator_char	char
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
msgid_pos	pointer
->	O
file_name	pointer
,	O
msgid_pos	pointer
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
msg	pointer
)	O
;	O
free	function
(	O
msg	pointer
)	O
;	O
seen_errors	int
++	O
;	O
}	O
else	O
if	O
(	O
count	pointer
>	O
1	int
)	O
{	O
char	O
*	O
msg	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"msgstr has too many keyboard accelerator marks '%c'"	pointer
)	O
,	O
accelerator_char	char
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
msgid_pos	pointer
->	O
file_name	pointer
,	O
msgid_pos	pointer
->	O
line_number	long
,	O
(	O
size_t	long
)	O
(	O
-	O
1	int
)	O
,	O
false	int
,	O
msg	pointer
)	O
;	O
free	function
(	O
msg	pointer
)	O
;	O
seen_errors	int
++	O
;	O
}	O
}	O
}	O
return	O
seen_errors	int
;	O
}	O
static	O
int	O
check_header_entry	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
const	O
char	O
*	O
msgstr_string	pointer
)	O
{	O
static	O
const	O
char	O
*	O
required_fields	array
[	O
]	O
=	O
{	O
"Project-Id-Version"	pointer
,	O
"PO-Revision-Date"	pointer
,	O
"Last-Translator"	pointer
,	O
"Language-Team"	pointer
,	O
"MIME-Version"	pointer
,	O
"Content-Type"	pointer
,	O
"Content-Transfer-Encoding"	pointer
,	O
"Language"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
default_values	array
[	O
]	O
=	O
{	O
"PACKAGE VERSION"	pointer
,	O
"YEAR-MO-DA HO:MI+ZONE"	pointer
,	O
"FULL NAME <EMAIL@ADDRESS>"	pointer
,	O
"LANGUAGE <LL@li.org>"	pointer
,	O
NULL	O
,	O
"text/plain; charset=CHARSET"	pointer
,	O
"ENCODING"	pointer
,	O
""	pointer
}	O
;	O
const	O
size_t	long
nfields	long
=	O
SIZEOF	O
(	O
required_fields	array
)	O
;	O
int	O
seen_errors	int
=	O
0	int
;	O
int	O
cnt	int
;	O
for	O
(	O
cnt	int
=	O
0	int
;	O
cnt	int
<	O
nfields	long
;	O
++	O
cnt	int
)	O
{	O
int	O
severity	int
=	O
PO_SEVERITY_WARNING	int
;	O
const	O
char	O
*	O
field	pointer
=	O
required_fields	array
[	O
cnt	int
]	O
;	O
size_t	long
len	long
=	O
strlen	function
(	O
field	pointer
)	O
;	O
const	O
char	O
*	O
line	long
;	O
for	O
(	O
line	long
=	O
msgstr_string	pointer
;	O
*	O
line	long
!=	O
'\0'	O
;	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
line	long
,	O
field	pointer
,	O
len	long
)	O
==	O
0	int
&&	O
line	long
[	O
len	long
]	O
==	O
':'	O
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
line	long
+	O
len	long
+	O
1	int
;	O
if	O
(	O
*	O
p	pointer
==	O
' '	O
)	O
p	pointer
++	O
;	O
if	O
(	O
default_values	array
[	O
cnt	int
]	O
!=	O
NULL	O
&&	O
strncmp	function
(	O
p	pointer
,	O
default_values	array
[	O
cnt	int
]	O
,	O
strlen	function
(	O
default_values	array
[	O
cnt	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
p	pointer
+=	O
strlen	function
(	O
default_values	array
[	O
cnt	int
]	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
{	O
char	O
*	O
msg	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"header field '%s' still has the initial default value\n"	pointer
)	O
,	O
field	pointer
)	O
;	O
po_xerror	pointer
(	O
severity	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	int
,	O
msg	pointer
)	O
;	O
free	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
severity	int
==	O
PO_SEVERITY_ERROR	int
)	O
seen_errors	int
++	O
;	O
}	O
}	O
break	O
;	O
}	O
line	long
=	O
strchrnul	function
(	O
line	long
,	O
'\n'	O
)	O
;	O
if	O
(	O
*	O
line	long
==	O
'\n'	O
)	O
line	long
++	O
;	O
}	O
if	O
(	O
*	O
line	long
==	O
'\0'	O
)	O
{	O
char	O
*	O
msg	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"header field '%s' missing in header\n"	pointer
)	O
,	O
field	pointer
)	O
;	O
po_xerror	pointer
(	O
severity	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
true	int
,	O
msg	pointer
)	O
;	O
free	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
severity	int
==	O
PO_SEVERITY_ERROR	int
)	O
seen_errors	int
++	O
;	O
}	O
}	O
return	O
seen_errors	int
;	O
}	O
int	O
check_message	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
const	O
lex_pos_ty	struct
*	O
msgid_pos	pointer
,	O
int	O
check_newlines	int
,	O
int	O
check_format_strings	int
,	O
const	O
struct	O
plural_distribution	struct
*	O
distribution	pointer
,	O
int	O
check_header	int
,	O
int	O
check_compatibility	int
,	O
int	O
check_accelerators	int
,	O
char	O
accelerator_char	char
)	O
{	O
int	O
seen_errors	int
=	O
0	int
;	O
if	O
(	O
check_header	int
&&	O
is_header	O
(	O
mp	pointer
)	O
)	O
seen_errors	int
+=	O
check_header_entry	function
(	O
mp	pointer
,	O
mp	pointer
->	O
msgstr	pointer
)	O
;	O
seen_errors	int
+=	O
check_pair	function
(	O
mp	pointer
,	O
mp	pointer
->	O
msgid	pointer
,	O
msgid_pos	pointer
,	O
mp	pointer
->	O
msgid_plural	pointer
,	O
mp	pointer
->	O
msgstr	pointer
,	O
mp	pointer
->	O
msgstr_len	long
,	O
mp	pointer
->	O
is_format	enum
,	O
check_newlines	int
,	O
check_format_strings	int
,	O
distribution	pointer
,	O
check_compatibility	int
,	O
check_accelerators	int
,	O
accelerator_char	char
)	O
;	O
return	O
seen_errors	int
;	O
}	O
int	O
check_message_list	function
(	O
message_list_ty	struct
*	O
mlp	pointer
,	O
int	O
ignore_untranslated_messages	int
,	O
int	O
ignore_fuzzy_messages	int
,	O
int	O
check_newlines	int
,	O
int	O
check_format_strings	int
,	O
int	O
check_header	int
,	O
int	O
check_compatibility	int
,	O
int	O
check_accelerators	int
,	O
char	O
accelerator_char	char
)	O
{	O
int	O
seen_errors	int
=	O
0	int
;	O
struct	O
plural_distribution	struct
distribution	pointer
;	O
size_t	long
j	long
;	O
distribution	pointer
.	O
expr	pointer
=	O
NULL	O
;	O
distribution	pointer
.	O
often	pointer
=	O
NULL	O
;	O
distribution	pointer
.	O
often_length	long
=	O
0	int
;	O
distribution	pointer
.	O
histogram	pointer
=	O
NULL	O
;	O
if	O
(	O
check_header	int
)	O
seen_errors	int
+=	O
check_plural	function
(	O
mlp	pointer
,	O
ignore_untranslated_messages	int
,	O
ignore_fuzzy_messages	int
,	O
&	O
distribution	pointer
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
!	O
mp	pointer
->	O
obsolete	bool
&&	O
!	O
(	O
ignore_untranslated_messages	int
&&	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
&&	O
!	O
(	O
ignore_fuzzy_messages	int
&&	O
(	O
mp	pointer
->	O
is_fuzzy	bool
&&	O
!	O
is_header	O
(	O
mp	pointer
)	O
)	O
)	O
)	O
seen_errors	int
+=	O
check_message	function
(	O
mp	pointer
,	O
&	O
mp	pointer
->	O
pos	struct
,	O
check_newlines	int
,	O
check_format_strings	int
,	O
&	O
distribution	pointer
,	O
check_header	int
,	O
check_compatibility	int
,	O
check_accelerators	int
,	O
accelerator_char	char
)	O
;	O
}	O
return	O
seen_errors	int
;	O
}	O
static	O
int	O
syntax_check_ellipsis_unicode	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
const	O
char	O
*	O
msgid	pointer
)	O
{	O
const	O
char	O
*	O
str	pointer
=	O
msgid	pointer
;	O
const	O
char	O
*	O
str_limit	pointer
=	O
str	pointer
+	O
strlen	function
(	O
msgid	pointer
)	O
;	O
int	O
seen_errors	int
=	O
0	int
;	O
while	O
(	O
str	pointer
<	O
str_limit	pointer
)	O
{	O
const	O
char	O
*	O
end	pointer
,	O
*	O
cp	pointer
;	O
ucs4_t	int
ending_char	int
;	O
end	pointer
=	O
sentence_end	function
(	O
str	pointer
,	O
&	O
ending_char	int
)	O
;	O
cp	pointer
=	O
end	pointer
-	O
(	O
ending_char	int
==	O
'.'	O
?	O
2	int
:	O
3	int
)	O
;	O
if	O
(	O
cp	pointer
>=	O
str	pointer
&&	O
memcmp	function
(	O
cp	pointer
,	O
"..."	pointer
,	O
3	int
)	O
==	O
0	int
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"ASCII ellipsis ('...') instead of Unicode"	pointer
)	O
)	O
;	O
seen_errors	int
++	O
;	O
}	O
str	pointer
=	O
end	pointer
+	O
1	int
;	O
}	O
return	O
seen_errors	int
;	O
}	O
static	O
int	O
syntax_check_space_ellipsis	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
const	O
char	O
*	O
msgid	pointer
)	O
{	O
const	O
char	O
*	O
str	pointer
=	O
msgid	pointer
;	O
const	O
char	O
*	O
str_limit	pointer
=	O
str	pointer
+	O
strlen	function
(	O
msgid	pointer
)	O
;	O
int	O
seen_errors	int
=	O
0	int
;	O
while	O
(	O
str	pointer
<	O
str_limit	pointer
)	O
{	O
const	O
char	O
*	O
end	pointer
,	O
*	O
ellipsis	pointer
=	O
NULL	O
;	O
ucs4_t	int
ending_char	int
;	O
end	pointer
=	O
sentence_end	function
(	O
str	pointer
,	O
&	O
ending_char	int
)	O
;	O
if	O
(	O
ending_char	int
==	O
0x2026	int
)	O
ellipsis	pointer
=	O
end	pointer
;	O
else	O
if	O
(	O
ending_char	int
==	O
'.'	O
)	O
{	O
const	O
char	O
*	O
cp	pointer
=	O
end	pointer
-	O
2	int
;	O
if	O
(	O
cp	pointer
>=	O
str	pointer
&&	O
memcmp	function
(	O
cp	pointer
,	O
"..."	pointer
,	O
3	int
)	O
==	O
0	int
)	O
ellipsis	pointer
=	O
cp	pointer
;	O
}	O
else	O
{	O
const	O
char	O
*	O
cp	pointer
=	O
end	pointer
-	O
3	int
;	O
if	O
(	O
cp	pointer
>=	O
str	pointer
&&	O
memcmp	function
(	O
cp	pointer
,	O
"..."	pointer
,	O
3	int
)	O
==	O
0	int
)	O
ellipsis	pointer
=	O
cp	pointer
;	O
else	O
{	O
ucs4_t	int
uc	int
=	O
0xfffd	int
;	O
for	O
(	O
cp	pointer
=	O
end	pointer
-	O
1	int
;	O
cp	pointer
>=	O
str	pointer
;	O
cp	pointer
--	O
)	O
{	O
u8_mbtouc	function
(	O
&	O
uc	int
,	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
cp	pointer
,	O
end	pointer
-	O
cp	pointer
)	O
;	O
if	O
(	O
uc	int
!=	O
0xfffd	int
)	O
break	O
;	O
}	O
if	O
(	O
uc	int
==	O
0x2026	int
)	O
ellipsis	pointer
=	O
cp	pointer
;	O
}	O
}	O
if	O
(	O
ellipsis	pointer
)	O
{	O
const	O
char	O
*	O
cp	pointer
;	O
ucs4_t	int
uc	int
=	O
0xfffd	int
;	O
for	O
(	O
cp	pointer
=	O
ellipsis	pointer
-	O
1	int
;	O
cp	pointer
>=	O
str	pointer
;	O
cp	pointer
--	O
)	O
{	O
u8_mbtouc	function
(	O
&	O
uc	int
,	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
cp	pointer
,	O
ellipsis	pointer
-	O
cp	pointer
)	O
;	O
if	O
(	O
uc	int
!=	O
0xfffd	int
)	O
break	O
;	O
}	O
if	O
(	O
uc	int
!=	O
0xfffd	int
&&	O
uc_is_space	function
(	O
uc	int
)	O
)	O
{	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"space before ellipsis found in user visible strings"	pointer
)	O
)	O
;	O
seen_errors	int
++	O
;	O
}	O
}	O
str	pointer
=	O
end	pointer
+	O
1	int
;	O
}	O
return	O
seen_errors	int
;	O
}	O
struct	O
callback_arg	struct
{	O
const	O
message_ty	struct
*	O
mp	pointer
;	O
int	O
seen_errors	int
;	O
}	O
;	O
static	O
void	O
syntax_check_quote_unicode_callback	function
(	O
char	O
quote	char
,	O
const	O
char	O
*	O
quoted	pointer
,	O
size_t	long
quoted_length	long
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
callback_arg	struct
*	O
arg	pointer
=	O
data	pointer
;	O
switch	O
(	O
quote	char
)	O
{	O
case	O
'"'	O
:	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
arg	pointer
->	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"ASCII double quote used instead of Unicode"	pointer
)	O
)	O
;	O
arg	pointer
->	O
seen_errors	int
++	O
;	O
break	O
;	O
case	O
'\''	O
:	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
arg	pointer
->	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
_	O
(	O
"ASCII single quote used instead of Unicode"	pointer
)	O
)	O
;	O
arg	pointer
->	O
seen_errors	int
++	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
int	O
syntax_check_quote_unicode	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
const	O
char	O
*	O
msgid	pointer
)	O
{	O
struct	O
callback_arg	struct
arg	pointer
;	O
arg	pointer
.	O
mp	pointer
=	O
mp	pointer
;	O
arg	pointer
.	O
seen_errors	int
=	O
0	int
;	O
scan_quoted	function
(	O
msgid	pointer
,	O
strlen	function
(	O
msgid	pointer
)	O
,	O
syntax_check_quote_unicode_callback	function
,	O
&	O
arg	pointer
)	O
;	O
return	O
arg	pointer
.	O
seen_errors	int
;	O
}	O
struct	O
bullet_ty	struct
{	O
int	O
c	int
;	O
size_t	long
depth	long
;	O
}	O
;	O
struct	O
bullet_stack_ty	struct
{	O
struct	O
bullet_ty	struct
*	O
items	pointer
;	O
size_t	long
nitems	long
;	O
size_t	long
nitems_max	long
;	O
}	O
;	O
static	O
struct	O
bullet_stack_ty	struct
bullet_stack	struct
;	O
static	O
int	O
syntax_check_bullet_unicode	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
const	O
char	O
*	O
msgid	pointer
)	O
{	O
const	O
char	O
*	O
str	pointer
=	O
msgid	pointer
;	O
const	O
char	O
*	O
str_limit	pointer
=	O
str	pointer
+	O
strlen	function
(	O
msgid	pointer
)	O
;	O
struct	O
bullet_ty	struct
*	O
last_bullet	pointer
=	O
NULL	O
;	O
bool	bool
seen_error	bool
=	O
false	int
;	O
bullet_stack	struct
.	O
nitems	long
=	O
0	int
;	O
while	O
(	O
str	pointer
<	O
str_limit	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
str	pointer
,	O
*	O
end	pointer
;	O
while	O
(	O
p	pointer
<	O
str_limit	pointer
&&	O
c_isspace	function
(	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
if	O
(	O
(	O
*	O
p	pointer
==	O
'*'	O
||	O
*	O
p	pointer
==	O
'-'	O
)	O
&&	O
*	O
(	O
p	pointer
+	O
1	int
)	O
==	O
' '	O
)	O
{	O
size_t	long
depth	long
=	O
p	pointer
-	O
str	pointer
;	O
if	O
(	O
last_bullet	pointer
==	O
NULL	O
||	O
depth	long
>	O
last_bullet	pointer
->	O
depth	long
)	O
{	O
struct	O
bullet_ty	struct
bullet	struct
;	O
bullet	struct
.	O
c	int
=	O
*	O
p	pointer
;	O
bullet	struct
.	O
depth	long
=	O
depth	long
;	O
if	O
(	O
bullet_stack	struct
.	O
nitems	long
>=	O
bullet_stack	struct
.	O
nitems_max	long
)	O
{	O
bullet_stack	struct
.	O
nitems_max	long
=	O
2	int
*	O
bullet_stack	struct
.	O
nitems_max	long
+	O
4	int
;	O
bullet_stack	struct
.	O
items	pointer
=	O
xrealloc	function
(	O
bullet_stack	struct
.	O
items	pointer
,	O
bullet_stack	struct
.	O
nitems_max	long
*	O
sizeof	O
(	O
struct	O
bullet_ty	struct
)	O
)	O
;	O
}	O
last_bullet	pointer
=	O
&	O
bullet_stack	struct
.	O
items	pointer
[	O
bullet_stack	struct
.	O
nitems	long
++	O
]	O
;	O
memcpy	function
(	O
last_bullet	pointer
,	O
&	O
bullet	struct
,	O
sizeof	O
(	O
struct	O
bullet_ty	struct
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
depth	long
<	O
last_bullet	pointer
->	O
depth	long
)	O
{	O
if	O
(	O
bullet_stack	struct
.	O
nitems	long
>	O
1	int
)	O
{	O
bullet_stack	struct
.	O
nitems	long
--	O
;	O
last_bullet	pointer
=	O
&	O
bullet_stack	struct
.	O
items	pointer
[	O
bullet_stack	struct
.	O
nitems	long
-	O
1	int
]	O
;	O
}	O
else	O
last_bullet	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
last_bullet	pointer
&&	O
depth	long
==	O
last_bullet	pointer
->	O
depth	long
)	O
{	O
if	O
(	O
last_bullet	pointer
->	O
c	int
!=	O
*	O
p	pointer
)	O
last_bullet	pointer
->	O
c	int
=	O
*	O
p	pointer
;	O
else	O
{	O
seen_error	bool
=	O
true	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
bullet_stack	struct
.	O
nitems	long
=	O
0	int
;	O
last_bullet	pointer
=	O
NULL	O
;	O
}	O
end	pointer
=	O
strchrnul	function
(	O
str	pointer
,	O
'\n'	O
)	O
;	O
str	pointer
=	O
end	pointer
+	O
1	int
;	O
}	O
if	O
(	O
seen_error	bool
)	O
{	O
char	O
*	O
msg	pointer
;	O
msg	pointer
=	O
xasprintf	function
(	O
_	O
(	O
"ASCII bullet ('%c') instead of Unicode"	pointer
)	O
,	O
last_bullet	pointer
->	O
c	int
)	O
;	O
po_xerror	pointer
(	O
PO_SEVERITY_ERROR	int
,	O
mp	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
false	int
,	O
msg	pointer
)	O
;	O
free	function
(	O
msg	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
typedef	O
int	O
(	O
*	O
syntax_check_function	pointer
)	O
(	O
const	O
message_ty	struct
*	O
mp	pointer
,	O
const	O
char	O
*	O
msgid	pointer
)	O
;	O
static	O
const	O
syntax_check_function	pointer
sc_funcs	array
[	O
NSYNTAXCHECKS	int
]	O
=	O
{	O
syntax_check_ellipsis_unicode	function
,	O
syntax_check_space_ellipsis	function
,	O
syntax_check_quote_unicode	function
,	O
syntax_check_bullet_unicode	function
}	O
;	O
static	O
int	O
syntax_check_message	function
(	O
const	O
message_ty	struct
*	O
mp	pointer
)	O
{	O
int	O
seen_errors	int
=	O
0	int
;	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NSYNTAXCHECKS	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
mp	pointer
->	O
do_syntax_check	array
[	O
i	long
]	O
==	O
yes	int
)	O
{	O
seen_errors	int
+=	O
sc_funcs	array
[	O
i	long
]	O
(	O
mp	pointer
,	O
mp	pointer
->	O
msgid	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
msgid_plural	pointer
)	O
seen_errors	int
+=	O
sc_funcs	array
[	O
i	long
]	O
(	O
mp	pointer
,	O
mp	pointer
->	O
msgid_plural	pointer
)	O
;	O
}	O
}	O
return	O
seen_errors	int
;	O
}	O
int	O
syntax_check_message_list	function
(	O
message_list_ty	struct
*	O
mlp	pointer
)	O
{	O
int	O
seen_errors	int
=	O
0	int
;	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
!	O
is_header	O
(	O
mp	pointer
)	O
)	O
seen_errors	int
+=	O
syntax_check_message	function
(	O
mp	pointer
)	O
;	O
}	O
return	O
seen_errors	int
;	O
}	O
