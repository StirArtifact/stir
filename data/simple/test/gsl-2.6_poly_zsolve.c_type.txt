int	O
gsl_poly_complex_solve	function
(	O
const	O
double	O
*	O
a	double
,	O
size_t	long
n	int
,	O
gsl_poly_complex_workspace	struct
*	O
w	array
,	O
gsl_complex_packed_ptr	pointer
z	double
)	O
{	O
int	O
status	int
;	O
double	O
*	O
m	pointer
;	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"number of terms must be a positive integer"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
n	int
==	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"cannot solve for only one term"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
a	double
[	O
n	int
-	O
1	int
]	O
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"leading term of polynomial must be non-zero"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
w	array
->	O
nc	long
!=	O
n	int
-	O
1	int
)	O
{	O
GSL_ERROR	O
(	O
"size of workspace does not match polynomial"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
m	pointer
=	O
w	array
->	O
matrix	pointer
;	O
set_companion_matrix	function
(	O
a	double
,	O
n	int
-	O
1	int
,	O
m	pointer
)	O
;	O
balance_companion_matrix	function
(	O
m	pointer
,	O
n	int
-	O
1	int
)	O
;	O
status	int
=	O
qr_companion	function
(	O
m	pointer
,	O
n	int
-	O
1	int
,	O
z	double
)	O
;	O
if	O
(	O
status	int
)	O
{	O
GSL_ERROR	O
(	O
"root solving qr method failed to converge"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
