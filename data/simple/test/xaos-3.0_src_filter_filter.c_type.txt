struct	O
queue	pointer
*	O
create_queue	function
(	O
struct	O
filter	struct
*	O
f	pointer
)	O
{	O
struct	O
queue	pointer
*	O
q	pointer
=	O
calloc	function
(	O
sizeof	O
(	O
struct	O
queue	pointer
)	O
,	O
1	int
)	O
;	O
q	pointer
->	O
first	pointer
=	O
q	pointer
->	O
last	pointer
=	O
f	pointer
;	O
f	pointer
->	O
queue	pointer
=	O
q	pointer
;	O
f	pointer
->	O
next	pointer
=	O
f	pointer
->	O
previous	pointer
=	O
NULL	O
;	O
return	O
(	O
q	pointer
)	O
;	O
}	O
void	O
insertfilter	function
(	O
struct	O
filter	struct
*	O
f1	pointer
,	O
struct	O
filter	struct
*	O
f2	pointer
)	O
{	O
f1	pointer
->	O
next	pointer
=	O
f2	pointer
;	O
f1	pointer
->	O
queue	pointer
=	O
f2	pointer
->	O
queue	pointer
;	O
f1	pointer
->	O
queue	pointer
->	O
isinitialized	int
=	O
0	int
;	O
f1	pointer
->	O
previous	pointer
=	O
f2	pointer
->	O
previous	pointer
;	O
if	O
(	O
f2	pointer
->	O
previous	pointer
!=	O
NULL	O
)	O
f2	pointer
->	O
previous	pointer
->	O
next	pointer
=	O
f1	pointer
;	O
else	O
f2	pointer
->	O
queue	pointer
->	O
first	pointer
=	O
f1	pointer
;	O
f2	pointer
->	O
previous	pointer
=	O
f1	pointer
;	O
}	O
void	O
addfilter	function
(	O
struct	O
filter	struct
*	O
f1	pointer
,	O
struct	O
filter	struct
*	O
f2	pointer
)	O
{	O
f1	pointer
->	O
previous	pointer
=	O
f2	pointer
;	O
f1	pointer
->	O
queue	pointer
=	O
f2	pointer
->	O
queue	pointer
;	O
f1	pointer
->	O
queue	pointer
->	O
isinitialized	int
=	O
0	int
;	O
f1	pointer
->	O
next	pointer
=	O
f2	pointer
->	O
next	pointer
;	O
if	O
(	O
f2	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
f2	pointer
->	O
next	pointer
->	O
previous	pointer
=	O
f1	pointer
;	O
else	O
f2	pointer
->	O
queue	pointer
->	O
last	pointer
=	O
f1	pointer
;	O
f2	pointer
->	O
next	pointer
=	O
f1	pointer
;	O
}	O
void	O
removefilter	pointer
(	O
struct	O
filter	struct
*	O
f	pointer
)	O
{	O
if	O
(	O
f	pointer
->	O
action	pointer
->	O
removefilter	pointer
!=	O
NULL	O
)	O
f	pointer
->	O
action	pointer
->	O
removefilter	pointer
(	O
f	pointer
)	O
;	O
if	O
(	O
f	pointer
->	O
previous	pointer
!=	O
NULL	O
)	O
f	pointer
->	O
previous	pointer
->	O
next	pointer
=	O
f	pointer
->	O
next	pointer
;	O
else	O
f	pointer
->	O
queue	pointer
->	O
first	pointer
=	O
f	pointer
->	O
next	pointer
;	O
if	O
(	O
f	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
f	pointer
->	O
next	pointer
->	O
previous	pointer
=	O
f	pointer
->	O
previous	pointer
;	O
else	O
f	pointer
->	O
queue	pointer
->	O
last	pointer
=	O
f	pointer
->	O
previous	pointer
;	O
f	pointer
->	O
queue	pointer
->	O
isinitialized	int
=	O
0	int
;	O
}	O
int	O
initqueue	function
(	O
struct	O
queue	pointer
*	O
q	pointer
)	O
{	O
struct	O
requirements	struct
noreq	struct
=	O
{	O
0	int
,	O
ALLMASK	O
,	O
0	int
}	O
;	O
struct	O
initdata	struct
init	int
=	O
{	O
NULL	O
,	O
0	int
}	O
;	O
q	pointer
->	O
palettechg	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
q	pointer
->	O
first	pointer
->	O
action	pointer
->	O
requirement	pointer
(	O
q	pointer
->	O
first	pointer
,	O
&	O
noreq	struct
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
q	pointer
->	O
last	pointer
->	O
action	pointer
->	O
initialize	pointer
(	O
q	pointer
->	O
last	pointer
,	O
&	O
init	int
)	O
)	O
return	O
0	int
;	O
q	pointer
->	O
isinitialized	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
int	O
reqimage	function
(	O
struct	O
filter	struct
*	O
f	pointer
,	O
struct	O
requirements	struct
*	O
req	struct
,	O
int	O
supportedmask	int
,	O
int	O
flags	int
)	O
{	O
f	pointer
->	O
req	struct
=	O
*	O
req	struct
;	O
req	struct
->	O
supportedmask	int
&=	O
supportedmask	int
;	O
if	O
(	O
!	O
req	struct
->	O
supportedmask	int
)	O
return	O
0	int
;	O
if	O
(	O
flags	int
&	O
TOUCHIMAGE	int
&&	O
req	struct
->	O
flags	int
&	O
IMAGEDATA	int
)	O
{	O
req	struct
->	O
flags	int
=	O
flags	int
;	O
}	O
else	O
req	struct
->	O
flags	int
&=	O
flags	int
;	O
return	O
1	int
;	O
}	O
int	O
inherimage	function
(	O
struct	O
filter	struct
*	O
f	pointer
,	O
struct	O
initdata	struct
*	O
data	pointer
,	O
int	O
flags	int
,	O
int	O
width	int
,	O
int	O
height	int
,	O
struct	O
palette	struct
*	O
palette	struct
,	O
float	O
pixelwidth	float
,	O
float	O
pixelheight	float
)	O
{	O
int	O
newimage	int
=	O
0	int
;	O
int	O
subimage	int
=	O
1	int
;	O
int	O
sharedimage	int
=	O
1	int
;	O
struct	O
image	struct
*	O
i	pointer
;	O
int	O
ddatalost	int
=	O
0	int
;	O
if	O
(	O
width	int
==	O
0	int
)	O
width	int
=	O
data	pointer
->	O
image	struct
->	O
width	int
;	O
if	O
(	O
height	int
==	O
0	int
)	O
height	int
=	O
data	pointer
->	O
image	struct
->	O
height	int
;	O
if	O
(	O
pixelwidth	float
==	O
0	int
)	O
pixelwidth	float
=	O
data	pointer
->	O
image	struct
->	O
pixelwidth	float
;	O
if	O
(	O
pixelheight	float
==	O
0	int
)	O
pixelheight	float
=	O
data	pointer
->	O
image	struct
->	O
pixelheight	float
;	O
if	O
(	O
palette	struct
==	O
NULL	O
)	O
palette	struct
=	O
data	pointer
->	O
image	struct
->	O
palette	struct
;	O
if	O
(	O
!	O
(	O
palette	struct
->	O
type	int
&	O
f	pointer
->	O
req	struct
.	O
supportedmask	int
)	O
)	O
{	O
f	pointer
->	O
image	struct
=	O
data	pointer
->	O
image	struct
;	O
return	O
0	int
;	O
}	O
if	O
(	O
flags	int
&	O
NEWIMAGE	int
)	O
newimage	int
=	O
1	int
,	O
sharedimage	int
=	O
0	int
,	O
subimage	int
=	O
0	int
;	O
if	O
(	O
flags	int
&	O
IMAGEDATA	int
)	O
subimage	int
=	O
0	int
,	O
sharedimage	int
=	O
0	int
,	O
newimage	int
=	O
1	int
;	O
if	O
(	O
(	O
flags	int
&	O
TOUCHIMAGE	int
)	O
&&	O
(	O
f	pointer
->	O
req	struct
.	O
flags	int
&	O
IMAGEDATA	int
)	O
)	O
subimage	int
=	O
0	int
,	O
newimage	int
=	O
1	int
,	O
sharedimage	int
=	O
0	int
;	O
if	O
(	O
width	int
!=	O
data	pointer
->	O
image	struct
->	O
width	int
||	O
height	int
!=	O
data	pointer
->	O
image	struct
->	O
height	int
||	O
palette	struct
!=	O
data	pointer
->	O
image	struct
->	O
palette	struct
)	O
newimage	int
=	O
1	int
,	O
sharedimage	int
=	O
0	int
;	O
if	O
(	O
f	pointer
->	O
childimage	pointer
!=	O
NULL	O
&&	O
(	O
f	pointer
->	O
flags	int
&	O
ALLOCEDIMAGE	int
)	O
)	O
{	O
if	O
(	O
!	O
newimage	int
&&	O
(	O
f	pointer
->	O
flags	int
&	O
ALLOCEDIMAGE	int
)	O
)	O
destroyinheredimage	function
(	O
f	pointer
)	O
,	O
ddatalost	int
=	O
1	int
;	O
if	O
(	O
subimage	int
&&	O
!	O
(	O
f	pointer
->	O
flags	int
&	O
SHAREDDATA	int
)	O
)	O
destroyinheredimage	function
(	O
f	pointer
)	O
,	O
ddatalost	int
=	O
1	int
;	O
if	O
(	O
!	O
subimage	int
&&	O
(	O
f	pointer
->	O
flags	int
&	O
SHAREDDATA	int
)	O
)	O
destroyinheredimage	function
(	O
f	pointer
)	O
,	O
ddatalost	int
=	O
1	int
;	O
if	O
(	O
f	pointer
->	O
flags	int
&	O
SHAREDDATA	int
&&	O
(	O
(	O
data	pointer
->	O
flags	int
&	O
DATALOST	int
)	O
||	O
f	pointer
->	O
imageversion	int
!=	O
data	pointer
->	O
image	struct
->	O
version	int
)	O
)	O
destroyinheredimage	function
(	O
f	pointer
)	O
,	O
ddatalost	int
=	O
1	int
;	O
if	O
(	O
sharedimage	int
)	O
destroyinheredimage	function
(	O
f	pointer
)	O
,	O
ddatalost	int
=	O
1	int
;	O
if	O
(	O
f	pointer
->	O
childimage	pointer
!=	O
NULL	O
&&	O
(	O
f	pointer
->	O
childimage	pointer
->	O
width	int
!=	O
width	int
||	O
f	pointer
->	O
childimage	pointer
->	O
height	int
!=	O
height	int
||	O
f	pointer
->	O
childimage	pointer
->	O
palette	struct
!=	O
palette	struct
||	O
f	pointer
->	O
childimage	pointer
->	O
bytesperpixel	int
!=	O
bytesperpixel	int
(	O
palette	struct
->	O
type	int
)	O
||	O
f	pointer
->	O
childimage	pointer
->	O
nimages	int
<	O
f	pointer
->	O
req	struct
.	O
nimages	int
)	O
)	O
destroyinheredimage	function
(	O
f	pointer
)	O
,	O
ddatalost	int
=	O
1	int
;	O
}	O
i	pointer
=	O
f	pointer
->	O
childimage	pointer
;	O
if	O
(	O
newimage	int
)	O
{	O
if	O
(	O
!	O
(	O
f	pointer
->	O
flags	int
&	O
ALLOCEDIMAGE	int
)	O
)	O
{	O
if	O
(	O
subimage	int
)	O
{	O
i	pointer
=	O
create_subimage	function
(	O
data	pointer
->	O
image	struct
,	O
width	int
,	O
height	int
,	O
f	pointer
->	O
req	struct
.	O
nimages	int
,	O
palette	struct
,	O
pixelwidth	float
,	O
pixelheight	float
)	O
;	O
f	pointer
->	O
flags	int
|=	O
ALLOCEDIMAGE	int
|	O
SHAREDDATA	int
;	O
ddatalost	int
=	O
1	int
;	O
}	O
else	O
{	O
i	pointer
=	O
create_image_mem	function
(	O
width	int
,	O
height	int
,	O
f	pointer
->	O
req	struct
.	O
nimages	int
,	O
palette	struct
,	O
pixelwidth	float
,	O
pixelheight	float
)	O
;	O
f	pointer
->	O
flags	int
|=	O
ALLOCEDIMAGE	int
;	O
ddatalost	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
i	pointer
==	O
NULL	O
)	O
{	O
f	pointer
->	O
image	struct
=	O
data	pointer
->	O
image	struct
;	O
return	O
0	int
;	O
}	O
if	O
(	O
sharedimage	int
)	O
i	pointer
=	O
data	pointer
->	O
image	struct
,	O
ddatalost	int
=	O
(	O
data	pointer
->	O
flags	int
&	O
DATALOST	int
)	O
||	O
(	O
f	pointer
->	O
childimage	pointer
!=	O
data	pointer
->	O
image	struct
)	O
;	O
if	O
(	O
sharedimage	int
&&	O
datalost	O
(	O
f	pointer
,	O
data	pointer
)	O
)	O
ddatalost	int
=	O
1	int
;	O
else	O
if	O
(	O
(	O
f	pointer
->	O
flags	int
|	O
SHAREDDATA	int
)	O
&&	O
datalost	O
(	O
f	pointer
,	O
data	pointer
)	O
&&	O
!	O
(	O
i	pointer
->	O
flags	int
&	O
FREEDATA	int
)	O
)	O
ddatalost	int
=	O
1	int
;	O
if	O
(	O
ddatalost	int
)	O
data	pointer
->	O
flags	int
|=	O
DATALOST	int
;	O
else	O
data	pointer
->	O
flags	int
&=	O
~	O
DATALOST	int
;	O
f	pointer
->	O
image	struct
=	O
data	pointer
->	O
image	struct
;	O
f	pointer
->	O
childimage	pointer
=	O
i	pointer
;	O
f	pointer
->	O
imageversion	int
=	O
data	pointer
->	O
image	struct
->	O
version	int
;	O
data	pointer
->	O
image	struct
=	O
i	pointer
;	O
return	O
1	int
;	O
}	O
void	O
destroyinheredimage	function
(	O
struct	O
filter	struct
*	O
f	pointer
)	O
{	O
if	O
(	O
f	pointer
->	O
flags	int
&	O
ALLOCEDIMAGE	int
)	O
destroy_image	function
(	O
f	pointer
->	O
childimage	pointer
)	O
,	O
f	pointer
->	O
flags	int
&=	O
~	O
(	O
ALLOCEDIMAGE	int
|	O
SHAREDDATA	int
)	O
,	O
f	pointer
->	O
childimage	pointer
=	O
NULL	O
;	O
}	O
void	O
updateinheredimage	function
(	O
struct	O
filter	struct
*	O
f	pointer
)	O
{	O
if	O
(	O
(	O
f	pointer
->	O
flags	int
&	O
SHAREDDATA	int
)	O
&&	O
f	pointer
->	O
childimage	pointer
)	O
{	O
if	O
(	O
f	pointer
->	O
childimage	pointer
->	O
nimages	int
==	O
2	int
&&	O
f	pointer
->	O
image	struct
->	O
currimage	int
!=	O
f	pointer
->	O
childimage	pointer
->	O
currimage	int
)	O
f	pointer
->	O
childimage	pointer
->	O
flip	pointer
(	O
f	pointer
->	O
childimage	pointer
)	O
;	O
}	O
}	O
void	O
inhermisc	function
(	O
struct	O
filter	struct
*	O
f	pointer
,	O
struct	O
initdata	struct
*	O
data	pointer
)	O
{	O
f	pointer
->	O
wait_function	pointer
=	O
data	pointer
->	O
wait_function	pointer
;	O
f	pointer
->	O
fractalc	pointer
=	O
data	pointer
->	O
fractalc	pointer
;	O
}	O
struct	O
filter	struct
*	O
createfilter	function
(	O
struct	O
filteraction	struct
*	O
fa	pointer
)	O
{	O
struct	O
filter	struct
*	O
f	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
filter	struct
)	O
)	O
;	O
if	O
(	O
f	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
f	pointer
->	O
queue	pointer
=	O
NULL	O
;	O
f	pointer
->	O
next	pointer
=	O
NULL	O
;	O
f	pointer
->	O
childimage	pointer
=	O
NULL	O
;	O
f	pointer
->	O
flags	int
=	O
0	int
;	O
f	pointer
->	O
previous	pointer
=	O
NULL	O
;	O
f	pointer
->	O
action	pointer
=	O
fa	pointer
;	O
f	pointer
->	O
image	struct
=	O
NULL	O
;	O
f	pointer
->	O
req	struct
.	O
nimages	int
=	O
1	int
;	O
f	pointer
->	O
data	pointer
=	O
NULL	O
;	O
return	O
(	O
f	pointer
)	O
;	O
}	O
void	O
convertupgeneric	function
(	O
struct	O
filter	struct
*	O
f	pointer
,	O
int	O
*	O
x	pointer
,	O
int	O
*	O
y	pointer
)	O
{	O
if	O
(	O
f	pointer
->	O
next	pointer
!=	O
NULL	O
)	O
f	pointer
->	O
next	pointer
->	O
action	pointer
->	O
convertup	pointer
(	O
f	pointer
->	O
next	pointer
,	O
x	pointer
,	O
y	pointer
)	O
;	O
}	O
void	O
convertdowngeneric	function
(	O
struct	O
filter	struct
*	O
f	pointer
,	O
int	O
*	O
x	pointer
,	O
int	O
*	O
y	pointer
)	O
{	O
if	O
(	O
f	pointer
->	O
previous	pointer
!=	O
NULL	O
)	O
f	pointer
->	O
previous	pointer
->	O
action	pointer
->	O
convertdown	pointer
(	O
f	pointer
->	O
previous	pointer
,	O
x	pointer
,	O
y	pointer
)	O
;	O
}	O
