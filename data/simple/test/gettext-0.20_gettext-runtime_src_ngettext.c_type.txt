static	O
int	O
do_expand	int
;	O
static	O
const	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"context"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"domain"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
const	O
char	O
*	O
expand_escape	function
(	O
const	O
char	O
*	O
str	pointer
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
optchar	int
;	O
const	O
char	O
*	O
msgid	pointer
;	O
const	O
char	O
*	O
msgid_plural	pointer
;	O
const	O
char	O
*	O
count	pointer
;	O
unsigned	O
long	O
n	long
;	O
bool	bool
do_help	bool
=	O
false	int
;	O
bool	bool
do_version	bool
=	O
false	int
;	O
const	O
char	O
*	O
domain	pointer
=	O
getenv	function
(	O
"TEXTDOMAIN"	pointer
)	O
;	O
const	O
char	O
*	O
domaindir	pointer
=	O
getenv	function
(	O
"TEXTDOMAINDIR"	pointer
)	O
;	O
const	O
char	O
*	O
context	pointer
=	O
NULL	O
;	O
do_expand	int
=	O
false	int
;	O
set_program_name	function
(	O
argv	array
[	O
0	int
]	O
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
relocate	O
(	O
LOCALEDIR	O
)	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
atexit	function
(	O
close_stdout	function
)	O
;	O
while	O
(	O
(	O
optchar	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	array
,	O
"+c:d:eEhV"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
optchar	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'c'	O
:	O
context	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'd'	O
:	O
domain	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'e'	O
:	O
do_expand	int
=	O
true	int
;	O
break	O
;	O
case	O
'E'	O
:	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	function
(	O
"%s (GNU %s) %s\n"	pointer
,	O
basename	function
(	O
program_name	pointer
)	O
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	pointer
)	O
,	O
"1995-1997, 2000-2019"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Written by %s.\n"	pointer
)	O
,	O
proper_name	function
(	O
"Ulrich Drepper"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
usage	function
(	O
EXIT_SUCCESS	int
)	O
;	O
switch	O
(	O
argc	int
-	O
optind	int
)	O
{	O
default	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many arguments"	pointer
)	O
)	O
;	O
case	O
4	int
:	O
domain	pointer
=	O
argv	array
[	O
optind	int
++	O
]	O
;	O
case	O
3	int
:	O
break	O
;	O
case	O
2	int
:	O
case	O
1	int
:	O
case	O
0	int
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"missing arguments"	pointer
)	O
)	O
;	O
}	O
msgid	pointer
=	O
argv	array
[	O
optind	int
++	O
]	O
;	O
msgid_plural	pointer
=	O
argv	array
[	O
optind	int
++	O
]	O
;	O
count	pointer
=	O
argv	array
[	O
optind	int
++	O
]	O
;	O
if	O
(	O
optind	int
!=	O
argc	int
)	O
abort	function
(	O
)	O
;	O
{	O
char	O
*	O
endp	pointer
;	O
unsigned	O
long	O
tmp_val	long
;	O
errno	O
=	O
0	int
;	O
tmp_val	long
=	O
strtoul	function
(	O
count	pointer
,	O
&	O
endp	pointer
,	O
10	int
)	O
;	O
if	O
(	O
errno	O
==	O
0	int
&&	O
count	pointer
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
endp	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
n	long
=	O
tmp_val	long
;	O
else	O
n	long
=	O
99	int
;	O
}	O
if	O
(	O
do_expand	int
)	O
{	O
msgid	pointer
=	O
expand_escape	function
(	O
msgid	pointer
)	O
;	O
msgid_plural	pointer
=	O
expand_escape	function
(	O
msgid_plural	pointer
)	O
;	O
}	O
if	O
(	O
domain	pointer
==	O
NULL	O
||	O
domain	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
fputs	function
(	O
n	long
==	O
1	int
?	O
msgid	pointer
:	O
msgid_plural	pointer
,	O
stdout	pointer
)	O
;	O
else	O
{	O
if	O
(	O
domaindir	pointer
!=	O
NULL	O
&&	O
domaindir	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
bindtextdomain	function
(	O
domain	pointer
,	O
domaindir	pointer
)	O
;	O
fputs	function
(	O
(	O
context	pointer
!=	O
NULL	O
?	O
dnpgettext_expr	O
(	O
domain	pointer
,	O
context	pointer
,	O
msgid	pointer
,	O
msgid_plural	pointer
,	O
n	long
)	O
:	O
dngettext	function
(	O
domain	pointer
,	O
msgid	pointer
,	O
msgid_plural	pointer
,	O
n	long
)	O
)	O
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION] [TEXTDOMAIN] MSGID MSGID-PLURAL COUNT\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Display native language translation of a textual message whose grammatical\nform depends on a number.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  -d, --domain=TEXTDOMAIN   retrieve translated message from TEXTDOMAIN\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -c, --context=CONTEXT     specify context for MSGID\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -e                        enable expansion of some escape sequences\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -E                        (ignored for compatibility)\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  [TEXTDOMAIN]              retrieve translated message from TEXTDOMAIN\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  MSGID MSGID-PLURAL        translate MSGID (singular) / MSGID-PLURAL (plural)\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  COUNT                     choose singular/plural form based on this value\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Informative output:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -h, --help                display this help and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -V, --version             display version information and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"If the TEXTDOMAIN parameter is not given, the domain is determined from the\nenvironment variable TEXTDOMAIN.  If the message catalog is not found in the\nregular directory, another location can be specified with the environment\nvariable TEXTDOMAINDIR.\nStandard search directory: %s\n"	pointer
)	O
,	O
getenv	function
(	O
"IN_HELP2MAN"	pointer
)	O
==	O
NULL	O
?	O
LOCALEDIR	O
:	O
"@localedir@"	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
expand_escape	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
retval	pointer
,	O
*	O
rp	pointer
;	O
const	O
char	O
*	O
cp	pointer
=	O
str	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
cp	pointer
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
cp	pointer
[	O
0	int
]	O
!=	O
'\\'	O
)	O
++	O
cp	pointer
;	O
if	O
(	O
cp	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
str	pointer
;	O
if	O
(	O
cp	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
return	O
str	pointer
;	O
if	O
(	O
strchr	function
(	O
"abcfnrtv\\01234567"	pointer
,	O
cp	pointer
[	O
1	int
]	O
)	O
!=	O
NULL	O
)	O
break	O
;	O
++	O
cp	pointer
;	O
}	O
retval	pointer
=	O
XNMALLOC	O
(	O
strlen	function
(	O
str	pointer
)	O
,	O
char	O
)	O
;	O
rp	pointer
=	O
retval	pointer
+	O
(	O
cp	pointer
-	O
str	pointer
)	O
;	O
memcpy	function
(	O
retval	pointer
,	O
str	pointer
,	O
cp	pointer
-	O
str	pointer
)	O
;	O
do	O
{	O
switch	O
(	O
*	O
++	O
cp	pointer
)	O
{	O
case	O
'a'	O
:	O
*	O
rp	pointer
++	O
=	O
'\a'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'b'	O
:	O
*	O
rp	pointer
++	O
=	O
'\b'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'f'	O
:	O
*	O
rp	pointer
++	O
=	O
'\f'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
rp	pointer
++	O
=	O
'\n'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
rp	pointer
++	O
=	O
'\r'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
rp	pointer
++	O
=	O
'\t'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'v'	O
:	O
*	O
rp	pointer
++	O
=	O
'\v'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'\\'	O
:	O
*	O
rp	pointer
=	O
'\\'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
{	O
int	O
ch	int
=	O
*	O
cp	pointer
++	O
-	O
'0'	O
;	O
if	O
(	O
*	O
cp	pointer
>=	O
'0'	O
&&	O
*	O
cp	pointer
<=	O
'7'	O
)	O
{	O
ch	int
*=	O
8	int
;	O
ch	int
+=	O
*	O
cp	pointer
++	O
-	O
'0'	O
;	O
if	O
(	O
*	O
cp	pointer
>=	O
'0'	O
&&	O
*	O
cp	pointer
<=	O
'7'	O
)	O
{	O
ch	int
*=	O
8	int
;	O
ch	int
+=	O
*	O
cp	pointer
++	O
-	O
'0'	O
;	O
}	O
}	O
*	O
rp	pointer
=	O
ch	int
;	O
}	O
break	O
;	O
default	O
:	O
*	O
rp	pointer
=	O
'\\'	O
;	O
break	O
;	O
}	O
while	O
(	O
cp	pointer
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
cp	pointer
[	O
0	int
]	O
!=	O
'\\'	O
)	O
*	O
rp	pointer
++	O
=	O
*	O
cp	pointer
++	O
;	O
}	O
while	O
(	O
cp	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
;	O
*	O
rp	pointer
=	O
'\0'	O
;	O
return	O
(	O
const	O
char	O
*	O
)	O
retval	pointer
;	O
}	O
