static	O
FILE	struct
*	O
create_output_file	function
(	O
char	O
const	O
*	O
,	O
int	O
)	O
;	O
static	O
lin	long
locate_hunk	function
(	O
lin	long
)	O
;	O
static	O
bool	bool
apply_hunk	function
(	O
struct	O
outstate	struct
*	O
,	O
lin	long
)	O
;	O
static	O
bool	bool
patch_match	function
(	O
lin	long
,	O
lin	long
,	O
lin	long
,	O
lin	long
)	O
;	O
static	O
bool	bool
spew_output	function
(	O
struct	O
outstate	struct
*	O
,	O
struct	O
stat	struct
*	O
)	O
;	O
static	O
int	O
numeric_string	function
(	O
char	O
const	O
*	O
,	O
bool	bool
,	O
char	O
const	O
*	O
)	O
;	O
static	O
void	O
cleanup	function
(	O
void	O
)	O
;	O
static	O
void	O
get_some_switches	function
(	O
void	O
)	O
;	O
static	O
void	O
init_output	function
(	O
struct	O
outstate	struct
*	O
)	O
;	O
static	O
FILE	struct
*	O
open_outfile	function
(	O
char	O
const	O
*	O
)	O
;	O
static	O
void	O
init_reject	function
(	O
char	O
const	O
*	O
)	O
;	O
static	O
void	O
reinitialize_almost_everything	function
(	O
void	O
)	O
;	O
static	O
void	O
remove_if_needed	function
(	O
char	O
const	O
*	O
,	O
int	O
*	O
)	O
;	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
,	O
int	O
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
void	O
abort_hunk	function
(	O
char	O
const	O
*	O
,	O
bool	bool
,	O
bool	bool
)	O
;	O
static	O
void	O
abort_hunk_context	function
(	O
bool	bool
,	O
bool	bool
)	O
;	O
static	O
void	O
abort_hunk_unified	function
(	O
bool	bool
,	O
bool	bool
)	O
;	O
static	O
void	O
output_file	function
(	O
char	O
const	O
*	O
,	O
int	O
*	O
,	O
const	O
struct	O
stat	struct
*	O
,	O
char	O
const	O
*	O
,	O
const	O
struct	O
stat	struct
*	O
,	O
mode_t	int
,	O
bool	bool
)	O
;	O
static	O
void	O
init_files_to_delete	function
(	O
void	O
)	O
;	O
static	O
void	O
init_files_to_output	function
(	O
void	O
)	O
;	O
static	O
void	O
delete_files	function
(	O
void	O
)	O
;	O
static	O
void	O
output_files	function
(	O
struct	O
stat	struct
const	O
*	O
)	O
;	O
static	O
bool	bool
merge	bool
;	O
static	O
enum	O
diff	enum
reject_format	enum
=	O
NO_DIFF	int
;	O
static	O
bool	bool
make_backups	bool
;	O
static	O
bool	bool
backup_if_mismatch	bool
;	O
static	O
char	O
const	O
*	O
version_control	pointer
;	O
static	O
char	O
const	O
*	O
version_control_context	pointer
;	O
static	O
bool	bool
remove_empty_files	bool
;	O
static	O
bool	bool
explicit_inname	bool
;	O
static	O
enum	O
{	O
RO_IGNORE	int
,	O
RO_WARN	int
,	O
RO_FAIL	int
}	O
read_only_behavior	enum
=	O
RO_WARN	int
;	O
static	O
bool	bool
reverse_flag_specified	bool
;	O
static	O
char	O
const	O
*	O
do_defines	pointer
;	O
static	O
char	O
const	O
if_defined	array
[	O
]	O
=	O
"\n#ifdef %s\n"	pointer
;	O
static	O
char	O
const	O
not_defined	array
[	O
]	O
=	O
"\n#ifndef %s\n"	pointer
;	O
static	O
char	O
const	O
else_defined	array
[	O
]	O
=	O
"\n#else\n"	pointer
;	O
static	O
char	O
const	O
end_defined	array
[	O
]	O
=	O
"\n#endif\n"	pointer
;	O
static	O
int	O
Argc	int
;	O
static	O
char	O
*	O
*	O
Argv	pointer
;	O
static	O
FILE	struct
*	O
rejfp	pointer
;	O
static	O
char	O
const	O
*	O
patchname	pointer
;	O
static	O
char	O
*	O
rejname	pointer
;	O
static	O
char	O
const	O
*	O
TMPREJNAME	pointer
;	O
static	O
int	O
TMPREJNAME_needs_removal	int
;	O
static	O
lin	long
maxfuzz	long
=	O
2	int
;	O
static	O
char	O
serrbuf	array
[	O
BUFSIZ	int
]	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
char	O
const	O
*	O
val	array
;	O
bool	bool
somefailed	bool
=	O
false	int
;	O
struct	O
outstate	struct
outstate	struct
;	O
struct	O
stat	struct
tmpoutst	struct
;	O
char	O
numbuf	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
bool	bool
written_to_rejname	bool
=	O
false	int
;	O
bool	bool
apply_empty_patch	bool
=	O
false	int
;	O
mode_t	int
file_type	int
;	O
int	O
outfd	int
=	O
-	O
1	int
;	O
bool	bool
have_git_diff	bool
=	O
false	int
;	O
exit_failure	int
=	O
2	int
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
init_time	function
(	O
)	O
;	O
setbuf	function
(	O
stderr	pointer
,	O
serrbuf	array
)	O
;	O
bufsize	long
=	O
8	int
*	O
1024	int
;	O
buf	pointer
=	O
xmalloc	function
(	O
bufsize	long
)	O
;	O
strippath	int
=	O
-	O
1	int
;	O
val	array
=	O
getenv	function
(	O
"QUOTING_STYLE"	pointer
)	O
;	O
{	O
int	O
i	int
=	O
val	array
?	O
argmatch	function
(	O
val	array
,	O
quoting_style_args	array
,	O
0	int
,	O
0	int
)	O
:	O
-	O
1	int
;	O
set_quoting_style	function
(	O
(	O
struct	O
quoting_options	O
*	O
)	O
0	int
,	O
i	int
<	O
0	int
?	O
shell_quoting_style	int
:	O
(	O
enum	O
quoting_style	enum
)	O
i	int
)	O
;	O
}	O
posixly_correct	bool
=	O
getenv	function
(	O
"POSIXLY_CORRECT"	pointer
)	O
!=	O
0	int
;	O
backup_if_mismatch	bool
=	O
!	O
posixly_correct	bool
;	O
patch_get	int
=	O
(	O
(	O
val	array
=	O
getenv	function
(	O
"PATCH_GET"	pointer
)	O
)	O
?	O
numeric_string	function
(	O
val	array
,	O
true	int
,	O
"PATCH_GET value"	pointer
)	O
:	O
0	int
)	O
;	O
val	array
=	O
getenv	function
(	O
"SIMPLE_BACKUP_SUFFIX"	pointer
)	O
;	O
simple_backup_suffix	pointer
=	O
val	array
&&	O
*	O
val	array
?	O
val	array
:	O
".orig"	pointer
;	O
if	O
(	O
(	O
version_control	pointer
=	O
getenv	function
(	O
"PATCH_VERSION_CONTROL"	pointer
)	O
)	O
)	O
version_control_context	pointer
=	O
"$PATCH_VERSION_CONTROL"	pointer
;	O
else	O
if	O
(	O
(	O
version_control	pointer
=	O
getenv	function
(	O
"VERSION_CONTROL"	pointer
)	O
)	O
)	O
version_control_context	pointer
=	O
"$VERSION_CONTROL"	pointer
;	O
Argc	int
=	O
argc	int
;	O
Argv	pointer
=	O
argv	pointer
;	O
get_some_switches	function
(	O
)	O
;	O
if	O
(	O
set_utc	bool
)	O
setenv	function
(	O
"TZ"	pointer
,	O
"UTC"	pointer
,	O
1	int
)	O
;	O
if	O
(	O
make_backups	bool
|	O
backup_if_mismatch	bool
)	O
backup_type	enum
=	O
get_version	function
(	O
version_control_context	pointer
,	O
version_control	pointer
)	O
;	O
init_backup_hash_table	function
(	O
)	O
;	O
init_files_to_delete	function
(	O
)	O
;	O
init_files_to_output	function
(	O
)	O
;	O
init_output	function
(	O
&	O
outstate	struct
)	O
;	O
if	O
(	O
outfile	pointer
)	O
outstate	struct
.	O
ofp	pointer
=	O
open_outfile	function
(	O
outfile	pointer
)	O
;	O
set_signals	function
(	O
false	int
)	O
;	O
if	O
(	O
inname	pointer
&&	O
outfile	pointer
)	O
{	O
apply_empty_patch	bool
=	O
true	int
;	O
file_type	int
=	O
S_IFREG	O
;	O
inerrno	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
open_patch_file	function
(	O
patchname	pointer
)	O
;	O
there_is_another_patch	function
(	O
!	O
(	O
inname	pointer
||	O
posixly_correct	bool
)	O
,	O
&	O
file_type	int
)	O
||	O
apply_empty_patch	bool
;	O
reinitialize_almost_everything	function
(	O
)	O
,	O
apply_empty_patch	bool
=	O
false	int
)	O
{	O
int	O
hunk	int
=	O
0	int
;	O
int	O
failed	int
=	O
0	int
;	O
bool	bool
mismatch	bool
=	O
false	int
;	O
char	O
const	O
*	O
outname	pointer
=	O
NULL	O
;	O
if	O
(	O
have_git_diff	bool
!=	O
pch_git_diff	function
(	O
)	O
)	O
{	O
have_git_diff	bool
=	O
!	O
have_git_diff	bool
;	O
output_files	function
(	O
NULL	O
)	O
;	O
}	O
if	O
(	O
TMPREJNAME_needs_removal	int
)	O
{	O
if	O
(	O
rejfp	pointer
)	O
{	O
fclose	function
(	O
rejfp	pointer
)	O
;	O
rejfp	pointer
=	O
NULL	O
;	O
}	O
remove_if_needed	function
(	O
TMPREJNAME	pointer
,	O
&	O
TMPREJNAME_needs_removal	int
)	O
;	O
}	O
if	O
(	O
TMPOUTNAME_needs_removal	int
)	O
{	O
if	O
(	O
outfd	int
!=	O
-	O
1	int
)	O
{	O
close	pointer
(	O
outfd	int
)	O
;	O
outfd	int
=	O
-	O
1	int
;	O
}	O
remove_if_needed	function
(	O
TMPOUTNAME	pointer
,	O
&	O
TMPOUTNAME_needs_removal	int
)	O
;	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
!	O
file_type	int
)	O
{	O
say	function
(	O
"File %s: can't change file type from 0%o to 0%o.\n"	pointer
,	O
quotearg	function
(	O
inname	pointer
)	O
,	O
pch_mode	function
(	O
reverse	bool
)	O
&	O
S_IFMT	O
,	O
pch_mode	function
(	O
!	O
reverse	bool
)	O
&	O
S_IFMT	O
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
somefailed	bool
=	O
true	int
;	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
)	O
{	O
if	O
(	O
outfile	pointer
)	O
outname	pointer
=	O
outfile	pointer
;	O
else	O
if	O
(	O
pch_copy	function
(	O
)	O
||	O
pch_rename	function
(	O
)	O
)	O
outname	pointer
=	O
pch_name	function
(	O
!	O
strcmp	function
(	O
inname	pointer
,	O
pch_name	function
(	O
OLD	int
)	O
)	O
)	O
;	O
else	O
outname	pointer
=	O
inname	pointer
;	O
}	O
if	O
(	O
pch_git_diff	function
(	O
)	O
&&	O
!	O
skip_rest_of_patch	bool
)	O
{	O
struct	O
stat	struct
outstat	struct
;	O
int	O
outerrno	int
=	O
0	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
inname	pointer
,	O
outname	pointer
)	O
)	O
{	O
if	O
(	O
inerrno	int
==	O
-	O
1	int
)	O
inerrno	int
=	O
lstat	function
(	O
inname	pointer
,	O
&	O
instat	struct
)	O
?	O
errno	O
:	O
0	int
;	O
outstat	struct
=	O
instat	struct
;	O
outerrno	int
=	O
inerrno	int
;	O
}	O
else	O
outerrno	int
=	O
lstat	function
(	O
outname	pointer
,	O
&	O
outstat	struct
)	O
?	O
errno	O
:	O
0	int
;	O
if	O
(	O
!	O
outerrno	int
)	O
{	O
if	O
(	O
has_queued_output	function
(	O
&	O
outstat	struct
)	O
)	O
{	O
output_files	function
(	O
&	O
outstat	struct
)	O
;	O
outerrno	int
=	O
lstat	function
(	O
outname	pointer
,	O
&	O
outstat	struct
)	O
?	O
errno	O
:	O
0	int
;	O
inerrno	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
outerrno	int
)	O
set_queued_output	function
(	O
&	O
outstat	struct
,	O
true	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
)	O
{	O
if	O
(	O
!	O
get_input_file	function
(	O
inname	pointer
,	O
outname	pointer
,	O
file_type	int
)	O
)	O
{	O
skip_rest_of_patch	bool
=	O
true	int
;	O
somefailed	bool
=	O
true	int
;	O
}	O
}	O
if	O
(	O
read_only_behavior	enum
!=	O
RO_IGNORE	int
&&	O
!	O
inerrno	int
&&	O
!	O
S_ISLNK	O
(	O
instat	struct
.	O
st_mode	int
)	O
&&	O
access	function
(	O
inname	pointer
,	O
W_OK	int
)	O
!=	O
0	int
)	O
{	O
say	function
(	O
"File %s is read-only; "	pointer
,	O
quotearg	function
(	O
inname	pointer
)	O
)	O
;	O
if	O
(	O
read_only_behavior	enum
==	O
RO_WARN	int
)	O
say	function
(	O
"trying to patch anyway\n"	pointer
)	O
;	O
else	O
{	O
say	function
(	O
"refusing to patch\n"	pointer
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
somefailed	bool
=	O
true	int
;	O
}	O
}	O
tmpoutst	struct
.	O
st_size	long
=	O
-	O
1	int
;	O
outfd	int
=	O
make_tempfile	function
(	O
&	O
TMPOUTNAME	pointer
,	O
'o'	O
,	O
outname	pointer
,	O
O_WRONLY	int
|	O
binary_transput	int
,	O
instat	struct
.	O
st_mode	int
)	O
;	O
TMPOUTNAME_needs_removal	int
=	O
1	int
;	O
if	O
(	O
diff_type	enum
==	O
ED_DIFF	int
)	O
{	O
outstate	struct
.	O
zero_output	bool
=	O
false	int
;	O
somefailed	bool
|=	O
skip_rest_of_patch	bool
;	O
do_ed_script	function
(	O
inname	pointer
,	O
TMPOUTNAME	pointer
,	O
&	O
TMPOUTNAME_needs_removal	int
,	O
outstate	struct
.	O
ofp	pointer
)	O
;	O
if	O
(	O
!	O
dry_run	bool
&&	O
!	O
outfile	pointer
&&	O
!	O
skip_rest_of_patch	bool
)	O
{	O
if	O
(	O
fstat	function
(	O
outfd	int
,	O
&	O
tmpoutst	struct
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"%s"	pointer
,	O
TMPOUTNAME	pointer
)	O
;	O
outstate	struct
.	O
zero_output	bool
=	O
tmpoutst	struct
.	O
st_size	long
==	O
0	int
;	O
}	O
close	pointer
(	O
outfd	int
)	O
;	O
outfd	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
int	O
got_hunk	int
;	O
bool	bool
apply_anyway	bool
=	O
merge	bool
;	O
if	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
diff_type	enum
==	O
GIT_BINARY_DIFF	int
)	O
{	O
say	function
(	O
"File %s: git binary diffs are not supported.\n"	pointer
,	O
quotearg	function
(	O
outname	pointer
)	O
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
somefailed	bool
=	O
true	int
;	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
!	O
outfile	pointer
)	O
{	O
init_output	function
(	O
&	O
outstate	struct
)	O
;	O
outstate	struct
.	O
ofp	pointer
=	O
fdopen	function
(	O
outfd	int
,	O
binary_transput	int
?	O
"wb"	pointer
:	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
outstate	struct
.	O
ofp	pointer
)	O
pfatal	function
(	O
"%s"	pointer
,	O
TMPOUTNAME	pointer
)	O
;	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
)	O
{	O
scan_input	function
(	O
inname	pointer
,	O
file_type	int
)	O
;	O
if	O
(	O
verbosity	enum
!=	O
SILENT	int
)	O
{	O
bool	bool
renamed	bool
=	O
strcmp	function
(	O
inname	pointer
,	O
outname	pointer
)	O
;	O
say	function
(	O
"patching %s %s%c"	pointer
,	O
S_ISLNK	O
(	O
file_type	int
)	O
?	O
"symbolic link"	pointer
:	O
"file"	pointer
,	O
quotearg	function
(	O
outname	pointer
)	O
,	O
renamed	bool
?	O
' '	O
:	O
'\n'	O
)	O
;	O
if	O
(	O
renamed	bool
)	O
say	function
(	O
"(%s from %s)\n"	pointer
,	O
pch_copy	function
(	O
)	O
?	O
"copied"	pointer
:	O
(	O
pch_rename	function
(	O
)	O
?	O
"renamed"	pointer
:	O
"read"	pointer
)	O
,	O
inname	pointer
)	O
;	O
if	O
(	O
verbosity	enum
==	O
VERBOSE	int
)	O
say	function
(	O
"Using Plan %s...\n"	pointer
,	O
using_plan_a	bool
?	O
"A"	pointer
:	O
"B"	pointer
)	O
;	O
}	O
}	O
while	O
(	O
0	int
<	O
(	O
got_hunk	int
=	O
another_hunk	function
(	O
diff_type	enum
,	O
reverse	bool
)	O
)	O
)	O
{	O
lin	long
where	long
=	O
0	int
;	O
lin	long
newwhere	long
;	O
lin	long
fuzz	long
=	O
0	int
;	O
lin	long
mymaxfuzz	long
;	O
if	O
(	O
merge	bool
)	O
{	O
mymaxfuzz	long
=	O
0	int
;	O
}	O
else	O
{	O
lin	long
prefix_context	long
=	O
pch_prefix_context	function
(	O
)	O
;	O
lin	long
suffix_context	long
=	O
pch_suffix_context	function
(	O
)	O
;	O
lin	long
context	pointer
=	O
(	O
prefix_context	long
<	O
suffix_context	long
?	O
suffix_context	long
:	O
prefix_context	long
)	O
;	O
mymaxfuzz	long
=	O
(	O
maxfuzz	long
<	O
context	pointer
?	O
maxfuzz	long
:	O
context	pointer
)	O
;	O
}	O
hunk	int
++	O
;	O
if	O
(	O
!	O
skip_rest_of_patch	bool
)	O
{	O
do	O
{	O
where	long
=	O
locate_hunk	function
(	O
fuzz	long
)	O
;	O
if	O
(	O
!	O
where	long
||	O
fuzz	long
||	O
in_offset	long
)	O
mismatch	bool
=	O
true	int
;	O
if	O
(	O
hunk	int
==	O
1	int
&&	O
!	O
where	long
&&	O
!	O
(	O
force	bool
|	O
apply_anyway	bool
)	O
&&	O
reverse	bool
==	O
reverse_flag_specified	bool
)	O
{	O
if	O
(	O
!	O
pch_swap	function
(	O
)	O
)	O
{	O
say	function
(	O
"Not enough memory to try swapped hunk!  Assuming unswapped.\n"	pointer
)	O
;	O
continue	O
;	O
}	O
where	long
=	O
locate_hunk	function
(	O
fuzz	long
)	O
;	O
if	O
(	O
where	long
&&	O
(	O
ok_to_reverse	function
(	O
"%s patch detected!"	pointer
,	O
(	O
reverse	bool
?	O
"Unreversed"	pointer
:	O
"Reversed (or previously applied)"	pointer
)	O
)	O
)	O
)	O
reverse	bool
=	O
!	O
reverse	bool
;	O
else	O
{	O
if	O
(	O
!	O
pch_swap	function
(	O
)	O
)	O
fatal	function
(	O
"lost hunk on alloc error!"	pointer
)	O
;	O
if	O
(	O
where	long
)	O
{	O
apply_anyway	bool
=	O
true	int
;	O
fuzz	long
--	O
;	O
where	long
=	O
0	int
;	O
}	O
}	O
}	O
}	O
while	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
!	O
where	long
&&	O
++	O
fuzz	long
<=	O
mymaxfuzz	long
)	O
;	O
if	O
(	O
skip_rest_of_patch	bool
)	O
{	O
if	O
(	O
outstate	struct
.	O
ofp	pointer
&&	O
!	O
outfile	pointer
)	O
{	O
fclose	function
(	O
outstate	struct
.	O
ofp	pointer
)	O
;	O
outstate	struct
.	O
ofp	pointer
=	O
0	int
;	O
outfd	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
newwhere	long
=	O
(	O
where	long
?	O
where	long
:	O
pch_first	function
(	O
)	O
)	O
+	O
out_offset	long
;	O
if	O
(	O
skip_rest_of_patch	bool
||	O
(	O
merge	bool
&&	O
!	O
merge_hunk	function
(	O
hunk	int
,	O
&	O
outstate	struct
,	O
where	long
,	O
&	O
somefailed	bool
)	O
)	O
||	O
(	O
!	O
merge	bool
&&	O
(	O
(	O
where	long
==	O
1	int
&&	O
pch_says_nonexistent	function
(	O
reverse	bool
)	O
==	O
2	int
&&	O
instat	struct
.	O
st_size	long
)	O
||	O
!	O
where	long
||	O
!	O
apply_hunk	function
(	O
&	O
outstate	struct
,	O
where	long
)	O
)	O
)	O
)	O
{	O
abort_hunk	function
(	O
outname	pointer
,	O
!	O
failed	int
,	O
reverse	bool
)	O
;	O
failed	int
++	O
;	O
if	O
(	O
verbosity	enum
==	O
VERBOSE	int
||	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
verbosity	enum
!=	O
SILENT	int
)	O
)	O
say	function
(	O
"Hunk #%d %s at %s.\n"	pointer
,	O
hunk	int
,	O
skip_rest_of_patch	bool
?	O
"ignored"	pointer
:	O
"FAILED"	pointer
,	O
format_linenum	function
(	O
numbuf	array
,	O
newwhere	long
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
merge	bool
&&	O
(	O
verbosity	enum
==	O
VERBOSE	int
||	O
(	O
verbosity	enum
!=	O
SILENT	int
&&	O
(	O
fuzz	long
||	O
in_offset	long
)	O
)	O
)	O
)	O
{	O
say	function
(	O
"Hunk #%d succeeded at %s"	pointer
,	O
hunk	int
,	O
format_linenum	function
(	O
numbuf	array
,	O
newwhere	long
)	O
)	O
;	O
if	O
(	O
fuzz	long
)	O
say	function
(	O
" with fuzz %s"	pointer
,	O
format_linenum	function
(	O
numbuf	array
,	O
fuzz	long
)	O
)	O
;	O
if	O
(	O
in_offset	long
)	O
say	function
(	O
" (offset %s line%s)"	pointer
,	O
format_linenum	function
(	O
numbuf	array
,	O
in_offset	long
)	O
,	O
"s"	pointer
+	O
(	O
in_offset	long
==	O
1	int
)	O
)	O
;	O
say	function
(	O
".\n"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
skip_rest_of_patch	bool
)	O
{	O
if	O
(	O
got_hunk	int
<	O
0	int
&&	O
using_plan_a	bool
)	O
{	O
if	O
(	O
outfile	pointer
)	O
fatal	function
(	O
"out of memory using Plan A"	pointer
)	O
;	O
say	function
(	O
"\n\nRan out of memory using Plan A -- trying again...\n\n"	pointer
)	O
;	O
if	O
(	O
outstate	struct
.	O
ofp	pointer
)	O
{	O
fclose	function
(	O
outstate	struct
.	O
ofp	pointer
)	O
;	O
outstate	struct
.	O
ofp	pointer
=	O
0	int
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
!	O
spew_output	function
(	O
&	O
outstate	struct
,	O
&	O
tmpoutst	struct
)	O
)	O
{	O
say	function
(	O
"Skipping patch.\n"	pointer
)	O
;	O
skip_rest_of_patch	bool
=	O
true	int
;	O
}	O
}	O
}	O
ignore_signals	function
(	O
)	O
;	O
if	O
(	O
!	O
skip_rest_of_patch	bool
&&	O
!	O
outfile	pointer
)	O
{	O
bool	bool
backup	bool
=	O
make_backups	bool
||	O
(	O
backup_if_mismatch	bool
&&	O
(	O
mismatch	bool
|	O
failed	int
)	O
)	O
;	O
if	O
(	O
outstate	struct
.	O
zero_output	bool
&&	O
(	O
remove_empty_files	bool
||	O
(	O
pch_says_nonexistent	function
(	O
!	O
reverse	bool
)	O
==	O
2	int
&&	O
!	O
posixly_correct	bool
)	O
||	O
S_ISLNK	O
(	O
file_type	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
dry_run	bool
)	O
output_file	function
(	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
outname	pointer
,	O
(	O
inname	pointer
==	O
outname	pointer
)	O
?	O
&	O
instat	struct
:	O
NULL	O
,	O
file_type	int
|	O
0	int
,	O
backup	bool
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
outstate	struct
.	O
zero_output	bool
&&	O
pch_says_nonexistent	function
(	O
!	O
reverse	bool
)	O
&&	O
!	O
(	O
merge	bool
&&	O
somefailed	bool
)	O
)	O
{	O
mismatch	bool
=	O
true	int
;	O
if	O
(	O
verbosity	enum
!=	O
SILENT	int
)	O
say	function
(	O
"File %s is not empty after patch, as expected\n"	pointer
,	O
quotearg	function
(	O
outname	pointer
)	O
)	O
;	O
}	O
if	O
(	O
!	O
dry_run	bool
)	O
{	O
mode_t	int
old_mode	int
=	O
pch_mode	function
(	O
reverse	bool
)	O
;	O
mode_t	int
new_mode	int
=	O
pch_mode	function
(	O
!	O
reverse	bool
)	O
;	O
bool	bool
set_mode	bool
=	O
new_mode	int
&&	O
old_mode	int
!=	O
new_mode	int
;	O
if	O
(	O
failed	int
<	O
hunk	int
||	O
diff_type	enum
==	O
ED_DIFF	int
||	O
set_mode	bool
||	O
pch_copy	function
(	O
)	O
||	O
pch_rename	function
(	O
)	O
)	O
{	O
enum	O
file_attributes	enum
attr	enum
=	O
0	int
;	O
struct	O
timespec	struct
new_time	struct
=	O
pch_timestamp	function
(	O
!	O
reverse	bool
)	O
;	O
mode_t	int
mode	int
=	O
file_type	int
|	O
(	O
(	O
new_mode	int
?	O
new_mode	int
:	O
instat	struct
.	O
st_mode	int
)	O
&	O
S_IRWXUGO	O
)	O
;	O
if	O
(	O
(	O
set_time	bool
|	O
set_utc	bool
)	O
&&	O
new_time	struct
.	O
tv_sec	long
!=	O
-	O
1	int
)	O
{	O
struct	O
timespec	struct
old_time	struct
=	O
pch_timestamp	function
(	O
reverse	bool
)	O
;	O
if	O
(	O
!	O
force	bool
&&	O
!	O
inerrno	int
&&	O
pch_says_nonexistent	function
(	O
reverse	bool
)	O
!=	O
2	int
&&	O
old_time	struct
.	O
tv_sec	long
!=	O
-	O
1	int
&&	O
timespec_cmp	function
(	O
old_time	struct
,	O
get_stat_mtime	function
(	O
&	O
instat	struct
)	O
)	O
)	O
say	function
(	O
"Not setting time of file %s "	pointer
"(time mismatch)\n"	pointer
,	O
quotearg	function
(	O
outname	pointer
)	O
)	O
;	O
else	O
if	O
(	O
!	O
force	bool
&&	O
(	O
mismatch	bool
|	O
failed	int
)	O
)	O
say	function
(	O
"Not setting time of file %s "	pointer
"(contents mismatch)\n"	pointer
,	O
quotearg	function
(	O
outname	pointer
)	O
)	O
;	O
else	O
attr	enum
|=	O
FA_TIMES	int
;	O
}	O
if	O
(	O
inerrno	int
)	O
set_file_attributes	function
(	O
TMPOUTNAME	pointer
,	O
attr	enum
,	O
NULL	O
,	O
NULL	O
,	O
mode	int
,	O
&	O
new_time	struct
)	O
;	O
else	O
{	O
attr	enum
|=	O
FA_IDS	int
|	O
FA_MODE	int
|	O
FA_XATTRS	int
;	O
set_file_attributes	function
(	O
TMPOUTNAME	pointer
,	O
attr	enum
,	O
inname	pointer
,	O
&	O
instat	struct
,	O
mode	int
,	O
&	O
new_time	struct
)	O
;	O
}	O
output_file	function
(	O
TMPOUTNAME	pointer
,	O
&	O
TMPOUTNAME_needs_removal	int
,	O
&	O
tmpoutst	struct
,	O
outname	pointer
,	O
NULL	O
,	O
mode	int
,	O
backup	bool
)	O
;	O
if	O
(	O
pch_rename	function
(	O
)	O
)	O
output_file	function
(	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
inname	pointer
,	O
&	O
instat	struct
,	O
mode	int
,	O
backup	bool
)	O
;	O
}	O
else	O
output_file	function
(	O
outname	pointer
,	O
NULL	O
,	O
&	O
tmpoutst	struct
,	O
NULL	O
,	O
NULL	O
,	O
file_type	int
|	O
0	int
,	O
backup	bool
)	O
;	O
}	O
}	O
}	O
if	O
(	O
diff_type	enum
!=	O
ED_DIFF	int
)	O
{	O
struct	O
stat	struct
rejst	struct
;	O
if	O
(	O
failed	int
)	O
{	O
if	O
(	O
fstat	function
(	O
fileno	function
(	O
rejfp	pointer
)	O
,	O
&	O
rejst	struct
)	O
!=	O
0	int
||	O
fclose	function
(	O
rejfp	pointer
)	O
!=	O
0	int
)	O
write_fatal	function
(	O
)	O
;	O
rejfp	pointer
=	O
NULL	O
;	O
somefailed	bool
=	O
true	int
;	O
say	function
(	O
"%d out of %d hunk%s %s"	pointer
,	O
failed	int
,	O
hunk	int
,	O
"s"	pointer
+	O
(	O
hunk	int
==	O
1	int
)	O
,	O
skip_rest_of_patch	bool
?	O
"ignored"	pointer
:	O
"FAILED"	pointer
)	O
;	O
if	O
(	O
outname	pointer
&&	O
(	O
!	O
rejname	pointer
||	O
strcmp	function
(	O
rejname	pointer
,	O
"-"	pointer
)	O
!=	O
0	int
)	O
)	O
{	O
char	O
*	O
rej	pointer
=	O
rejname	pointer
;	O
if	O
(	O
!	O
rejname	pointer
)	O
{	O
const	O
char	O
*	O
s	enum
=	O
simple_backup_suffix	pointer
;	O
size_t	long
len	long
;	O
simple_backup_suffix	pointer
=	O
".rej"	pointer
;	O
rej	pointer
=	O
find_backup_file_name	function
(	O
outname	pointer
,	O
simple_backups	int
)	O
;	O
len	long
=	O
strlen	function
(	O
rej	pointer
)	O
;	O
if	O
(	O
rej	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'~'	O
)	O
rej	pointer
[	O
len	long
-	O
1	int
]	O
=	O
'#'	O
;	O
simple_backup_suffix	pointer
=	O
s	enum
;	O
}	O
say	function
(	O
" -- saving rejects to file %s\n"	pointer
,	O
quotearg	function
(	O
rej	pointer
)	O
)	O
;	O
if	O
(	O
!	O
dry_run	bool
)	O
{	O
if	O
(	O
rejname	pointer
)	O
{	O
if	O
(	O
!	O
written_to_rejname	bool
)	O
{	O
copy_file	function
(	O
TMPREJNAME	pointer
,	O
rejname	pointer
,	O
0	int
,	O
0	int
,	O
S_IFREG	O
|	O
0666	int
,	O
true	int
)	O
;	O
written_to_rejname	bool
=	O
true	int
;	O
}	O
else	O
append_to_file	function
(	O
TMPREJNAME	pointer
,	O
rejname	pointer
)	O
;	O
}	O
else	O
{	O
struct	O
stat	struct
oldst	struct
;	O
int	O
olderrno	int
;	O
olderrno	int
=	O
lstat	function
(	O
rej	pointer
,	O
&	O
oldst	struct
)	O
?	O
errno	O
:	O
0	int
;	O
if	O
(	O
olderrno	int
&&	O
olderrno	int
!=	O
ENOENT	int
)	O
write_fatal	function
(	O
)	O
;	O
if	O
(	O
!	O
olderrno	int
&&	O
lookup_file_id	function
(	O
&	O
oldst	struct
)	O
==	O
CREATED	int
)	O
append_to_file	function
(	O
TMPREJNAME	pointer
,	O
rej	pointer
)	O
;	O
else	O
move_file	function
(	O
TMPREJNAME	pointer
,	O
&	O
TMPREJNAME_needs_removal	int
,	O
&	O
rejst	struct
,	O
rej	pointer
,	O
S_IFREG	O
|	O
0666	int
,	O
false	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
rejname	pointer
)	O
free	function
(	O
rej	pointer
)	O
;	O
}	O
else	O
say	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
set_signals	function
(	O
true	int
)	O
;	O
}	O
if	O
(	O
outstate	struct
.	O
ofp	pointer
&&	O
(	O
ferror	function
(	O
outstate	struct
.	O
ofp	pointer
)	O
||	O
fclose	function
(	O
outstate	struct
.	O
ofp	pointer
)	O
!=	O
0	int
)	O
)	O
write_fatal	function
(	O
)	O
;	O
output_files	function
(	O
NULL	O
)	O
;	O
delete_files	function
(	O
)	O
;	O
cleanup	function
(	O
)	O
;	O
if	O
(	O
somefailed	bool
)	O
exit	function
(	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
reinitialize_almost_everything	function
(	O
void	O
)	O
{	O
re_patch	function
(	O
)	O
;	O
re_input	function
(	O
)	O
;	O
input_lines	long
=	O
0	int
;	O
last_frozen_line	long
=	O
0	int
;	O
if	O
(	O
inname	pointer
&&	O
!	O
explicit_inname	bool
)	O
{	O
free	function
(	O
inname	pointer
)	O
;	O
inname	pointer
=	O
0	int
;	O
}	O
in_offset	long
=	O
0	int
;	O
out_offset	long
=	O
0	int
;	O
diff_type	enum
=	O
NO_DIFF	int
;	O
if	O
(	O
revision	pointer
)	O
{	O
free	function
(	O
revision	pointer
)	O
;	O
revision	pointer
=	O
0	int
;	O
}	O
reverse	bool
=	O
reverse_flag_specified	bool
;	O
skip_rest_of_patch	bool
=	O
false	int
;	O
}	O
static	O
char	O
const	O
shortopts	array
[	O
]	O
=	O
"bB:cd:D:eEfF:g:i:l"	pointer
"nNo:p:r:RstTuvV:x:Y:z:Z"	pointer
;	O
static	O
struct	O
option	struct
const	O
longopts	array
[	O
]	O
=	O
{	O
{	O
"backup"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'b'	O
}	O
,	O
{	O
"prefix"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'B'	O
}	O
,	O
{	O
"context"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"directory"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"ifdef"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"ed"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"remove-empty-files"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'E'	O
}	O
,	O
{	O
"force"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'f'	O
}	O
,	O
{	O
"fuzz"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
{	O
"get"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'g'	O
}	O
,	O
{	O
"input"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"ignore-whitespace"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"merge"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
'm'	O
}	O
,	O
{	O
"normal"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"forward"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'N'	O
}	O
,	O
{	O
"output"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"strip"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"reject-file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
{	O
"reverse"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
{	O
"quiet"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"silent"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"batch"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
{	O
"set-time"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'T'	O
}	O
,	O
{	O
"unified"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'u'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"version-control"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
"debug"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"basename-prefix"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'Y'	O
}	O
,	O
{	O
"suffix"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'z'	O
}	O
,	O
{	O
"set-utc"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'Z'	O
}	O
,	O
{	O
"dry-run"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
1	int
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
2	int
}	O
,	O
{	O
"binary"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
3	int
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
4	int
}	O
,	O
{	O
"backup-if-mismatch"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
5	int
}	O
,	O
{	O
"no-backup-if-mismatch"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
6	int
}	O
,	O
{	O
"posix"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
7	int
}	O
,	O
{	O
"quoting-style"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
8	int
}	O
,	O
{	O
"reject-format"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
9	int
}	O
,	O
{	O
"read-only"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
10	int
}	O
,	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
char	O
const	O
*	O
const	O
option_help	array
[	O
]	O
=	O
{	O
"Input options:"	pointer
,	O
""	pointer
,	O
"  -p NUM  --strip=NUM  Strip NUM leading components from file names."	pointer
,	O
"  -F LINES  --fuzz LINES  Set the fuzz factor to LINES for inexact matching."	pointer
,	O
"  -l  --ignore-whitespace  Ignore white space changes between patch and input."	pointer
,	O
""	pointer
,	O
"  -c  --context  Interpret the patch as a context difference."	pointer
,	O
"  -e  --ed  Interpret the patch as an ed script."	pointer
,	O
"  -n  --normal  Interpret the patch as a normal difference."	pointer
,	O
"  -u  --unified  Interpret the patch as a unified difference."	pointer
,	O
""	pointer
,	O
"  -N  --forward  Ignore patches that appear to be reversed or already applied."	pointer
,	O
"  -R  --reverse  Assume patches were created with old and new files swapped."	pointer
,	O
""	pointer
,	O
"  -i PATCHFILE  --input=PATCHFILE  Read patch from PATCHFILE instead of stdin."	pointer
,	O
""	pointer
,	O
"Output options:"	pointer
,	O
""	pointer
,	O
"  -o FILE  --output=FILE  Output patched files to FILE."	pointer
,	O
"  -r FILE  --reject-file=FILE  Output rejects to FILE."	pointer
,	O
""	pointer
,	O
"  -D NAME  --ifdef=NAME  Make merged if-then-else output using NAME."	pointer
,	O
"  -m  --merge  Merge using conflict markers instead of creating reject files."	pointer
,	O
"  -E  --remove-empty-files  Remove output files that are empty after patching."	pointer
,	O
""	pointer
,	O
"  -Z  --set-utc  Set times of patched files, assuming diff uses UTC (GMT)."	pointer
,	O
"  -T  --set-time  Likewise, assuming local time."	pointer
,	O
""	pointer
,	O
"  --quoting-style=WORD   output file names using quoting style WORD."	pointer
,	O
"    Valid WORDs are: literal, shell, shell-always, c, escape."	pointer
,	O
"    Default is taken from QUOTING_STYLE env variable, or 'shell' if unset."	pointer
,	O
""	pointer
,	O
"Backup and version control options:"	pointer
,	O
""	pointer
,	O
"  -b  --backup  Back up the original contents of each file."	pointer
,	O
"  --backup-if-mismatch  Back up if the patch does not match exactly."	pointer
,	O
"  --no-backup-if-mismatch  Back up mismatches only if otherwise requested."	pointer
,	O
""	pointer
,	O
"  -V STYLE  --version-control=STYLE  Use STYLE version control."	pointer
,	O
"	STYLE is either 'simple', 'numbered', or 'existing'."	pointer
,	O
"  -B PREFIX  --prefix=PREFIX  Prepend PREFIX to backup file names."	pointer
,	O
"  -Y PREFIX  --basename-prefix=PREFIX  Prepend PREFIX to backup file basenames."	pointer
,	O
"  -z SUFFIX  --suffix=SUFFIX  Append SUFFIX to backup file names."	pointer
,	O
""	pointer
,	O
"  -g NUM  --get=NUM  Get files from RCS etc. if positive; ask if negative."	pointer
,	O
""	pointer
,	O
"Miscellaneous options:"	pointer
,	O
""	pointer
,	O
"  -t  --batch  Ask no questions; skip bad-Prereq patches; assume reversed."	pointer
,	O
"  -f  --force  Like -t, but ignore bad-Prereq patches, and assume unreversed."	pointer
,	O
"  -s  --quiet  --silent  Work silently unless an error occurs."	pointer
,	O
"  --verbose  Output extra information about the work being done."	pointer
,	O
"  --dry-run  Do not actually change any files; just print what would happen."	pointer
,	O
"  --posix  Conform to the POSIX standard."	pointer
,	O
""	pointer
,	O
"  -d DIR  --directory=DIR  Change the working directory to DIR first."	pointer
,	O
"  --reject-format=FORMAT  Create 'context' or 'unified' rejects."	pointer
,	O
"  --binary  Read and write data in binary mode."	pointer
,	O
"  --read-only=BEHAVIOR  How to handle read-only input files: 'ignore' that they"	pointer
,	O
"                        are read-only, 'warn' (default), or 'fail'."	pointer
,	O
""	pointer
,	O
"  -v  --version  Output version info."	pointer
,	O
"  --help  Output this help."	pointer
,	O
""	pointer
,	O
"Report bugs to <"	pointer
PACKAGE_BUGREPORT	pointer
">."	pointer
,	O
0	int
}	O
;	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
stream	pointer
,	O
int	O
status	int
)	O
{	O
char	O
const	O
*	O
const	O
*	O
p	pointer
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"%s: Try '%s --help' for more information.\n"	pointer
,	O
program_name	pointer
,	O
Argv	pointer
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"Usage: %s [OPTION]... [ORIGFILE [PATCHFILE]]\n\n"	pointer
,	O
Argv	pointer
[	O
0	int
]	O
)	O
;	O
for	O
(	O
p	pointer
=	O
option_help	array
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
fprintf	function
(	O
stream	pointer
,	O
"%s\n"	pointer
,	O
*	O
p	pointer
)	O
;	O
}	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
void	O
get_some_switches	function
(	O
void	O
)	O
{	O
int	O
optc	int
;	O
free	function
(	O
rejname	pointer
)	O
;	O
rejname	pointer
=	O
0	int
;	O
if	O
(	O
optind	int
==	O
Argc	int
)	O
return	O
;	O
while	O
(	O
(	O
optc	int
=	O
getopt_long	function
(	O
Argc	int
,	O
Argv	pointer
,	O
shortopts	array
,	O
longopts	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'b'	O
:	O
make_backups	bool
=	O
true	int
;	O
if	O
(	O
Argc	int
-	O
optind	int
==	O
3	int
&&	O
strcmp	function
(	O
Argv	pointer
[	O
optind	int
-	O
1	int
]	O
,	O
"-b"	pointer
)	O
==	O
0	int
&&	O
!	O
(	O
Argv	pointer
[	O
optind	int
+	O
0	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
Argv	pointer
[	O
optind	int
+	O
0	int
]	O
[	O
1	int
]	O
)	O
&&	O
!	O
(	O
Argv	pointer
[	O
optind	int
+	O
1	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
Argv	pointer
[	O
optind	int
+	O
1	int
]	O
[	O
1	int
]	O
)	O
&&	O
!	O
(	O
Argv	pointer
[	O
optind	int
+	O
2	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
Argv	pointer
[	O
optind	int
+	O
2	int
]	O
[	O
1	int
]	O
)	O
)	O
{	O
optarg	pointer
=	O
Argv	pointer
[	O
optind	int
++	O
]	O
;	O
if	O
(	O
verbosity	enum
!=	O
SILENT	int
)	O
say	function
(	O
"warning: the '-b %s' option is obsolete; use '-b -z %s' instead\n"	pointer
,	O
optarg	pointer
,	O
optarg	pointer
)	O
;	O
goto	O
case_z	O
;	O
}	O
break	O
;	O
case	O
'B'	O
:	O
if	O
(	O
!	O
*	O
optarg	pointer
)	O
fatal	function
(	O
"backup prefix is empty"	pointer
)	O
;	O
origprae	pointer
=	O
savestr	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
diff_type	enum
=	O
CONTEXT_DIFF	int
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
chdir	function
(	O
optarg	pointer
)	O
<	O
0	int
)	O
pfatal	function
(	O
"Can't change to directory %s"	pointer
,	O
quotearg	function
(	O
optarg	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
do_defines	pointer
=	O
savestr	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
diff_type	enum
=	O
ED_DIFF	int
;	O
break	O
;	O
case	O
'E'	O
:	O
remove_empty_files	bool
=	O
true	int
;	O
break	O
;	O
case	O
'f'	O
:	O
force	bool
=	O
true	int
;	O
break	O
;	O
case	O
'F'	O
:	O
maxfuzz	long
=	O
numeric_string	function
(	O
optarg	pointer
,	O
false	int
,	O
"fuzz factor"	pointer
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
patch_get	int
=	O
numeric_string	function
(	O
optarg	pointer
,	O
true	int
,	O
"get option value"	pointer
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
patchname	pointer
=	O
savestr	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
canonicalize	bool
=	O
true	int
;	O
break	O
;	O
case	O
'm'	O
:	O
merge	bool
=	O
true	int
;	O
if	O
(	O
optarg	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"merge"	pointer
)	O
)	O
conflict_style	enum
=	O
MERGE_MERGE	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
optarg	pointer
,	O
"diff3"	pointer
)	O
)	O
conflict_style	enum
=	O
MERGE_DIFF3	int
;	O
else	O
usage	function
(	O
stderr	pointer
,	O
2	int
)	O
;	O
}	O
else	O
conflict_style	enum
=	O
MERGE_MERGE	int
;	O
break	O
;	O
case	O
'n'	O
:	O
diff_type	enum
=	O
NORMAL_DIFF	int
;	O
break	O
;	O
case	O
'N'	O
:	O
noreverse	bool
=	O
true	int
;	O
break	O
;	O
case	O
'o'	O
:	O
outfile	pointer
=	O
savestr	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
strippath	int
=	O
numeric_string	function
(	O
optarg	pointer
,	O
false	int
,	O
"strip count"	pointer
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
rejname	pointer
=	O
savestr	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
reverse	bool
=	O
true	int
;	O
reverse_flag_specified	bool
=	O
true	int
;	O
break	O
;	O
case	O
's'	O
:	O
verbosity	enum
=	O
SILENT	int
;	O
break	O
;	O
case	O
't'	O
:	O
batch	bool
=	O
true	int
;	O
break	O
;	O
case	O
'T'	O
:	O
set_time	bool
=	O
true	int
;	O
break	O
;	O
case	O
'u'	O
:	O
diff_type	enum
=	O
UNI_DIFF	int
;	O
break	O
;	O
case	O
'v'	O
:	O
version	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'V'	O
:	O
version_control	pointer
=	O
optarg	pointer
;	O
version_control_context	pointer
=	O
"--version-control or -V option"	pointer
;	O
break	O
;	O
case	O
'x'	O
:	O
debug	int
=	O
numeric_string	function
(	O
optarg	pointer
,	O
true	int
,	O
"debugging option"	pointer
)	O
;	O
break	O
;	O
case	O
'Y'	O
:	O
if	O
(	O
!	O
*	O
optarg	pointer
)	O
fatal	function
(	O
"backup basename prefix is empty"	pointer
)	O
;	O
origbase	pointer
=	O
savestr	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'z'	O
:	O
case_z	O
:	O
if	O
(	O
!	O
*	O
optarg	pointer
)	O
fatal	function
(	O
"backup suffix is empty"	pointer
)	O
;	O
origsuff	pointer
=	O
savestr	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
set_utc	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
1	int
:	O
dry_run	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
2	int
:	O
verbosity	enum
=	O
VERBOSE	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
3	int
:	O
no_strip_trailing_cr	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
4	int
:	O
usage	function
(	O
stdout	pointer
,	O
0	int
)	O
;	O
case	O
CHAR_MAX	O
+	O
5	int
:	O
backup_if_mismatch	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
6	int
:	O
backup_if_mismatch	bool
=	O
false	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
7	int
:	O
posixly_correct	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
8	int
:	O
{	O
int	O
i	int
=	O
argmatch	function
(	O
optarg	pointer
,	O
quoting_style_args	array
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
invalid_arg	O
(	O
"quoting style"	pointer
,	O
optarg	pointer
,	O
i	int
)	O
;	O
usage	function
(	O
stderr	pointer
,	O
2	int
)	O
;	O
}	O
set_quoting_style	function
(	O
(	O
struct	O
quoting_options	O
*	O
)	O
0	int
,	O
(	O
enum	O
quoting_style	enum
)	O
i	int
)	O
;	O
}	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
9	int
:	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"context"	pointer
)	O
==	O
0	int
)	O
reject_format	enum
=	O
NEW_CONTEXT_DIFF	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"unified"	pointer
)	O
==	O
0	int
)	O
reject_format	enum
=	O
UNI_DIFF	int
;	O
else	O
usage	function
(	O
stderr	pointer
,	O
2	int
)	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
10	int
:	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"ignore"	pointer
)	O
==	O
0	int
)	O
read_only_behavior	enum
=	O
RO_IGNORE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"warn"	pointer
)	O
==	O
0	int
)	O
read_only_behavior	enum
=	O
RO_WARN	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"fail"	pointer
)	O
==	O
0	int
)	O
read_only_behavior	enum
=	O
RO_FAIL	int
;	O
else	O
usage	function
(	O
stderr	pointer
,	O
2	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
stderr	pointer
,	O
2	int
)	O
;	O
}	O
}	O
if	O
(	O
optind	int
<	O
Argc	int
)	O
{	O
inname	pointer
=	O
savestr	function
(	O
Argv	pointer
[	O
optind	int
++	O
]	O
)	O
;	O
explicit_inname	bool
=	O
true	int
;	O
invc	int
=	O
-	O
1	int
;	O
if	O
(	O
optind	int
<	O
Argc	int
)	O
{	O
patchname	pointer
=	O
savestr	function
(	O
Argv	pointer
[	O
optind	int
++	O
]	O
)	O
;	O
if	O
(	O
optind	int
<	O
Argc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s: extra operand\n"	pointer
,	O
program_name	pointer
,	O
quotearg	function
(	O
Argv	pointer
[	O
optind	int
]	O
)	O
)	O
;	O
usage	function
(	O
stderr	pointer
,	O
2	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
int	O
numeric_string	function
(	O
char	O
const	O
*	O
string	pointer
,	O
bool	bool
negative_allowed	bool
,	O
char	O
const	O
*	O
argtype_msgid	pointer
)	O
{	O
int	O
value	pointer
=	O
0	int
;	O
char	O
const	O
*	O
p	pointer
=	O
string	pointer
;	O
int	O
sign	int
=	O
*	O
p	pointer
==	O
'-'	O
?	O
-	O
1	int
:	O
1	int
;	O
p	pointer
+=	O
*	O
p	pointer
==	O
'-'	O
||	O
*	O
p	pointer
==	O
'+'	O
;	O
do	O
{	O
int	O
v10	int
=	O
value	pointer
*	O
10	int
;	O
int	O
digit	int
=	O
*	O
p	pointer
-	O
'0'	O
;	O
int	O
signed_digit	int
=	O
sign	int
*	O
digit	int
;	O
int	O
next_value	int
=	O
v10	int
+	O
signed_digit	int
;	O
if	O
(	O
9	int
<	O
(	O
unsigned	O
)	O
digit	int
)	O
fatal	function
(	O
"%s %s is not a number"	pointer
,	O
argtype_msgid	pointer
,	O
quotearg	function
(	O
string	pointer
)	O
)	O
;	O
if	O
(	O
v10	int
/	O
10	int
!=	O
value	pointer
||	O
(	O
next_value	int
<	O
v10	int
)	O
!=	O
(	O
signed_digit	int
<	O
0	int
)	O
)	O
fatal	function
(	O
"%s %s is too large"	pointer
,	O
argtype_msgid	pointer
,	O
quotearg	function
(	O
string	pointer
)	O
)	O
;	O
value	pointer
=	O
next_value	int
;	O
}	O
while	O
(	O
*	O
++	O
p	pointer
)	O
;	O
if	O
(	O
value	pointer
<	O
0	int
&&	O
!	O
negative_allowed	bool
)	O
fatal	function
(	O
"%s %s is negative"	pointer
,	O
argtype_msgid	pointer
,	O
quotearg	function
(	O
string	pointer
)	O
)	O
;	O
return	O
value	pointer
;	O
}	O
static	O
lin	long
locate_hunk	function
(	O
lin	long
fuzz	long
)	O
{	O
lin	long
first_guess	long
=	O
pch_first	function
(	O
)	O
+	O
in_offset	long
;	O
lin	long
offset	long
;	O
lin	long
pat_lines	long
=	O
pch_ptrn_lines	function
(	O
)	O
;	O
lin	long
prefix_context	long
=	O
pch_prefix_context	function
(	O
)	O
;	O
lin	long
suffix_context	long
=	O
pch_suffix_context	function
(	O
)	O
;	O
lin	long
context	pointer
=	O
(	O
prefix_context	long
<	O
suffix_context	long
?	O
suffix_context	long
:	O
prefix_context	long
)	O
;	O
lin	long
prefix_fuzz	long
=	O
fuzz	long
+	O
prefix_context	long
-	O
context	pointer
;	O
lin	long
suffix_fuzz	long
=	O
fuzz	long
+	O
suffix_context	long
-	O
context	pointer
;	O
lin	long
max_where	long
=	O
input_lines	long
-	O
(	O
pat_lines	long
-	O
suffix_fuzz	long
)	O
+	O
1	int
;	O
lin	long
min_where	long
=	O
last_frozen_line	long
+	O
1	int
-	O
(	O
prefix_context	long
-	O
prefix_fuzz	long
)	O
;	O
lin	long
max_pos_offset	long
=	O
max_where	long
-	O
first_guess	long
;	O
lin	long
max_neg_offset	long
=	O
first_guess	long
-	O
min_where	long
;	O
lin	long
max_offset	long
=	O
(	O
max_pos_offset	long
<	O
max_neg_offset	long
?	O
max_neg_offset	long
:	O
max_pos_offset	long
)	O
;	O
if	O
(	O
!	O
pat_lines	long
)	O
return	O
first_guess	long
;	O
if	O
(	O
first_guess	long
<=	O
max_neg_offset	long
)	O
max_neg_offset	long
=	O
first_guess	long
-	O
1	int
;	O
if	O
(	O
prefix_fuzz	long
<	O
0	int
&&	O
pch_first	function
(	O
)	O
<=	O
1	int
)	O
{	O
if	O
(	O
suffix_fuzz	long
<	O
0	int
)	O
if	O
(	O
pat_lines	long
!=	O
input_lines	long
||	O
prefix_context	long
<	O
last_frozen_line	long
)	O
return	O
0	int
;	O
offset	long
=	O
1	int
-	O
first_guess	long
;	O
if	O
(	O
last_frozen_line	long
<=	O
prefix_context	long
&&	O
offset	long
<=	O
max_pos_offset	long
&&	O
patch_match	function
(	O
first_guess	long
,	O
offset	long
,	O
0	int
,	O
suffix_fuzz	long
)	O
)	O
{	O
in_offset	long
+=	O
offset	long
;	O
return	O
first_guess	long
+	O
offset	long
;	O
}	O
else	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
prefix_fuzz	long
<	O
0	int
)	O
prefix_fuzz	long
=	O
0	int
;	O
if	O
(	O
suffix_fuzz	long
<	O
0	int
)	O
{	O
offset	long
=	O
first_guess	long
-	O
(	O
input_lines	long
-	O
pat_lines	long
+	O
1	int
)	O
;	O
if	O
(	O
offset	long
<=	O
max_neg_offset	long
&&	O
patch_match	function
(	O
first_guess	long
,	O
-	O
offset	long
,	O
prefix_fuzz	long
,	O
0	int
)	O
)	O
{	O
in_offset	long
-=	O
offset	long
;	O
return	O
first_guess	long
-	O
offset	long
;	O
}	O
else	O
return	O
0	int
;	O
}	O
for	O
(	O
offset	long
=	O
0	int
;	O
offset	long
<=	O
max_offset	long
;	O
offset	long
++	O
)	O
{	O
char	O
numbuf0	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
if	O
(	O
offset	long
<=	O
max_pos_offset	long
&&	O
patch_match	function
(	O
first_guess	long
,	O
offset	long
,	O
prefix_fuzz	long
,	O
suffix_fuzz	long
)	O
)	O
{	O
if	O
(	O
debug	int
&	O
1	int
)	O
say	function
(	O
"Offset changing from %s to %s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
in_offset	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
in_offset	long
+	O
offset	long
)	O
)	O
;	O
in_offset	long
+=	O
offset	long
;	O
return	O
first_guess	long
+	O
offset	long
;	O
}	O
if	O
(	O
0	int
<	O
offset	long
&&	O
offset	long
<=	O
max_neg_offset	long
&&	O
patch_match	function
(	O
first_guess	long
,	O
-	O
offset	long
,	O
prefix_fuzz	long
,	O
suffix_fuzz	long
)	O
)	O
{	O
if	O
(	O
debug	int
&	O
1	int
)	O
say	function
(	O
"Offset changing from %s to %s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
in_offset	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
in_offset	long
-	O
offset	long
)	O
)	O
;	O
in_offset	long
-=	O
offset	long
;	O
return	O
first_guess	long
-	O
offset	long
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
mangled_patch	function
(	O
lin	long
old	long
,	O
lin	long
new	long
)	O
{	O
char	O
numbuf0	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
if	O
(	O
debug	int
&	O
1	int
)	O
say	function
(	O
"oldchar = '%c', newchar = '%c'\n"	pointer
,	O
pch_char	function
(	O
old	long
)	O
,	O
pch_char	function
(	O
new	long
)	O
)	O
;	O
fatal	function
(	O
"Out-of-sync patch, lines %s,%s -- mangled text or line numbers, "	pointer
"maybe?"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
pch_hunk_beg	function
(	O
)	O
+	O
old	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
pch_hunk_beg	function
(	O
)	O
+	O
new	long
)	O
)	O
;	O
}	O
static	O
void	O
print_unidiff_range	function
(	O
FILE	struct
*	O
fp	pointer
,	O
lin	long
start	long
,	O
lin	long
count	long
)	O
{	O
char	O
numbuf0	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
switch	O
(	O
count	long
)	O
{	O
case	O
0	int
:	O
fprintf	function
(	O
fp	pointer
,	O
"%s,0"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
start	long
-	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
start	long
)	O
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
fp	pointer
,	O
"%s,%s"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
start	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
count	long
)	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
print_header_line	function
(	O
FILE	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
tag	pointer
,	O
bool	bool
reverse	bool
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
pch_name	function
(	O
reverse	bool
)	O
;	O
const	O
char	O
*	O
timestr	pointer
=	O
pch_timestr	function
(	O
reverse	bool
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s %s%s\n"	pointer
,	O
tag	pointer
,	O
name	pointer
?	O
name	pointer
:	O
"/dev/null"	pointer
,	O
timestr	pointer
?	O
timestr	pointer
:	O
""	pointer
)	O
;	O
}	O
static	O
void	O
abort_hunk_unified	function
(	O
bool	bool
header	bool
,	O
bool	bool
reverse	bool
)	O
{	O
lin	long
old	long
=	O
1	int
;	O
lin	long
lastline	long
=	O
pch_ptrn_lines	function
(	O
)	O
;	O
lin	long
new	long
=	O
lastline	long
+	O
1	int
;	O
if	O
(	O
header	bool
)	O
{	O
if	O
(	O
pch_name	function
(	O
INDEX	int
)	O
)	O
fprintf	function
(	O
rejfp	pointer
,	O
"Index: %s\n"	pointer
,	O
pch_name	function
(	O
INDEX	int
)	O
)	O
;	O
print_header_line	function
(	O
rejfp	pointer
,	O
"---"	pointer
,	O
reverse	bool
)	O
;	O
print_header_line	function
(	O
rejfp	pointer
,	O
"+++"	pointer
,	O
!	O
reverse	bool
)	O
;	O
}	O
fprintf	function
(	O
rejfp	pointer
,	O
"@@ -"	pointer
)	O
;	O
print_unidiff_range	function
(	O
rejfp	pointer
,	O
pch_first	function
(	O
)	O
+	O
out_offset	long
,	O
lastline	long
)	O
;	O
fprintf	function
(	O
rejfp	pointer
,	O
" +"	pointer
)	O
;	O
print_unidiff_range	function
(	O
rejfp	pointer
,	O
pch_newfirst	function
(	O
)	O
+	O
out_offset	long
,	O
pch_repl_lines	function
(	O
)	O
)	O
;	O
fprintf	function
(	O
rejfp	pointer
,	O
" @@\n"	pointer
)	O
;	O
while	O
(	O
pch_char	function
(	O
new	long
)	O
==	O
'='	O
||	O
pch_char	function
(	O
new	long
)	O
==	O
'\n'	O
)	O
new	long
++	O
;	O
if	O
(	O
diff_type	enum
!=	O
UNI_DIFF	int
)	O
pch_normalize	function
(	O
UNI_DIFF	int
)	O
;	O
for	O
(	O
;	O
;	O
old	long
++	O
,	O
new	long
++	O
)	O
{	O
for	O
(	O
;	O
pch_char	function
(	O
old	long
)	O
==	O
'-'	O
;	O
old	long
++	O
)	O
{	O
fputc	function
(	O
'-'	O
,	O
rejfp	pointer
)	O
;	O
pch_write_line	function
(	O
old	long
,	O
rejfp	pointer
)	O
;	O
}	O
for	O
(	O
;	O
pch_char	function
(	O
new	long
)	O
==	O
'+'	O
;	O
new	long
++	O
)	O
{	O
fputc	function
(	O
'+'	O
,	O
rejfp	pointer
)	O
;	O
pch_write_line	function
(	O
new	long
,	O
rejfp	pointer
)	O
;	O
}	O
if	O
(	O
old	long
>	O
lastline	long
)	O
break	O
;	O
if	O
(	O
pch_char	function
(	O
new	long
)	O
!=	O
pch_char	function
(	O
old	long
)	O
)	O
mangled_patch	function
(	O
old	long
,	O
new	long
)	O
;	O
fputc	function
(	O
' '	O
,	O
rejfp	pointer
)	O
;	O
pch_write_line	function
(	O
old	long
,	O
rejfp	pointer
)	O
;	O
}	O
if	O
(	O
pch_char	function
(	O
new	long
)	O
!=	O
'^'	O
)	O
mangled_patch	function
(	O
old	long
,	O
new	long
)	O
;	O
}	O
static	O
void	O
abort_hunk_context	function
(	O
bool	bool
header	bool
,	O
bool	bool
reverse	bool
)	O
{	O
lin	long
i	int
;	O
lin	long
pat_end	long
=	O
pch_end	function
(	O
)	O
;	O
lin	long
oldfirst	long
=	O
pch_first	function
(	O
)	O
+	O
out_offset	long
;	O
lin	long
newfirst	long
=	O
pch_newfirst	function
(	O
)	O
+	O
out_offset	long
;	O
lin	long
oldlast	long
=	O
oldfirst	long
+	O
pch_ptrn_lines	function
(	O
)	O
-	O
1	int
;	O
lin	long
newlast	long
=	O
newfirst	long
+	O
pch_repl_lines	function
(	O
)	O
-	O
1	int
;	O
char	O
const	O
*	O
stars	pointer
=	O
(	O
int	O
)	O
NEW_CONTEXT_DIFF	int
<=	O
(	O
int	O
)	O
diff_type	enum
?	O
" ****"	pointer
:	O
""	pointer
;	O
char	O
const	O
*	O
minuses	pointer
=	O
(	O
int	O
)	O
NEW_CONTEXT_DIFF	int
<=	O
(	O
int	O
)	O
diff_type	enum
?	O
" ----"	pointer
:	O
" -----"	pointer
;	O
char	O
const	O
*	O
c_function	pointer
=	O
pch_c_function	function
(	O
)	O
;	O
if	O
(	O
diff_type	enum
==	O
UNI_DIFF	int
)	O
pch_normalize	function
(	O
NEW_CONTEXT_DIFF	int
)	O
;	O
if	O
(	O
header	bool
)	O
{	O
if	O
(	O
pch_name	function
(	O
INDEX	int
)	O
)	O
fprintf	function
(	O
rejfp	pointer
,	O
"Index: %s\n"	pointer
,	O
pch_name	function
(	O
INDEX	int
)	O
)	O
;	O
print_header_line	function
(	O
rejfp	pointer
,	O
"***"	pointer
,	O
reverse	bool
)	O
;	O
print_header_line	function
(	O
rejfp	pointer
,	O
"---"	pointer
,	O
!	O
reverse	bool
)	O
;	O
}	O
fprintf	function
(	O
rejfp	pointer
,	O
"***************%s\n"	pointer
,	O
c_function	pointer
?	O
c_function	pointer
:	O
""	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
pat_end	long
;	O
i	int
++	O
)	O
{	O
char	O
numbuf0	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
switch	O
(	O
pch_char	function
(	O
i	int
)	O
)	O
{	O
case	O
'*'	O
:	O
if	O
(	O
oldlast	long
<	O
oldfirst	long
)	O
fprintf	function
(	O
rejfp	pointer
,	O
"*** 0%s\n"	pointer
,	O
stars	pointer
)	O
;	O
else	O
if	O
(	O
oldlast	long
==	O
oldfirst	long
)	O
fprintf	function
(	O
rejfp	pointer
,	O
"*** %s%s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
oldfirst	long
)	O
,	O
stars	pointer
)	O
;	O
else	O
fprintf	function
(	O
rejfp	pointer
,	O
"*** %s,%s%s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
oldfirst	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
oldlast	long
)	O
,	O
stars	pointer
)	O
;	O
break	O
;	O
case	O
'='	O
:	O
if	O
(	O
newlast	long
<	O
newfirst	long
)	O
fprintf	function
(	O
rejfp	pointer
,	O
"--- 0%s\n"	pointer
,	O
minuses	pointer
)	O
;	O
else	O
if	O
(	O
newlast	long
==	O
newfirst	long
)	O
fprintf	function
(	O
rejfp	pointer
,	O
"--- %s%s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
newfirst	long
)	O
,	O
minuses	pointer
)	O
;	O
else	O
fprintf	function
(	O
rejfp	pointer
,	O
"--- %s,%s%s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
newfirst	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
newlast	long
)	O
,	O
minuses	pointer
)	O
;	O
break	O
;	O
case	O
' '	O
:	O
case	O
'-'	O
:	O
case	O
'+'	O
:	O
case	O
'!'	O
:	O
fprintf	function
(	O
rejfp	pointer
,	O
"%c "	pointer
,	O
pch_char	function
(	O
i	int
)	O
)	O
;	O
case	O
'\n'	O
:	O
pch_write_line	function
(	O
i	int
,	O
rejfp	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fatal	function
(	O
"fatal internal error in abort_hunk_context"	pointer
)	O
;	O
}	O
if	O
(	O
ferror	function
(	O
rejfp	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
abort_hunk	function
(	O
char	O
const	O
*	O
outname	pointer
,	O
bool	bool
header	bool
,	O
bool	bool
reverse	bool
)	O
{	O
if	O
(	O
!	O
TMPREJNAME_needs_removal	int
)	O
init_reject	function
(	O
outname	pointer
)	O
;	O
if	O
(	O
reject_format	enum
==	O
UNI_DIFF	int
||	O
(	O
reject_format	enum
==	O
NO_DIFF	int
&&	O
diff_type	enum
==	O
UNI_DIFF	int
)	O
)	O
abort_hunk_unified	function
(	O
header	bool
,	O
reverse	bool
)	O
;	O
else	O
abort_hunk_context	function
(	O
header	bool
,	O
reverse	bool
)	O
;	O
}	O
static	O
bool	bool
apply_hunk	function
(	O
struct	O
outstate	struct
*	O
outstate	struct
,	O
lin	long
where	long
)	O
{	O
lin	long
old	long
=	O
1	int
;	O
lin	long
lastline	long
=	O
pch_ptrn_lines	function
(	O
)	O
;	O
lin	long
new	long
=	O
lastline	long
+	O
1	int
;	O
enum	O
{	O
OUTSIDE	int
,	O
IN_IFNDEF	int
,	O
IN_IFDEF	int
,	O
IN_ELSE	int
}	O
def_state	enum
=	O
OUTSIDE	int
;	O
char	O
const	O
*	O
R_do_defines	pointer
=	O
do_defines	pointer
;	O
lin	long
pat_end	long
=	O
pch_end	function
(	O
)	O
;	O
FILE	struct
*	O
fp	pointer
=	O
outstate	struct
->	O
ofp	pointer
;	O
where	long
--	O
;	O
while	O
(	O
pch_char	function
(	O
new	long
)	O
==	O
'='	O
||	O
pch_char	function
(	O
new	long
)	O
==	O
'\n'	O
)	O
new	long
++	O
;	O
while	O
(	O
old	long
<=	O
lastline	long
)	O
{	O
if	O
(	O
pch_char	function
(	O
old	long
)	O
==	O
'-'	O
)	O
{	O
assert	O
(	O
outstate	struct
->	O
after_newline	bool
)	O
;	O
if	O
(	O
!	O
copy_till	function
(	O
outstate	struct
,	O
where	long
+	O
old	long
-	O
1	int
)	O
)	O
return	O
false	int
;	O
if	O
(	O
R_do_defines	pointer
)	O
{	O
if	O
(	O
def_state	enum
==	O
OUTSIDE	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
outstate	struct
->	O
after_newline	bool
+	O
not_defined	array
,	O
R_do_defines	pointer
)	O
;	O
def_state	enum
=	O
IN_IFNDEF	int
;	O
}	O
else	O
if	O
(	O
def_state	enum
==	O
IN_IFDEF	int
)	O
{	O
fputs	function
(	O
outstate	struct
->	O
after_newline	bool
+	O
else_defined	array
,	O
fp	pointer
)	O
;	O
def_state	enum
=	O
IN_ELSE	int
;	O
}	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
outstate	struct
->	O
after_newline	bool
=	O
pch_write_line	function
(	O
old	long
,	O
fp	pointer
)	O
;	O
outstate	struct
->	O
zero_output	bool
=	O
false	int
;	O
}	O
last_frozen_line	long
++	O
;	O
old	long
++	O
;	O
}	O
else	O
if	O
(	O
new	long
>	O
pat_end	long
)	O
{	O
break	O
;	O
}	O
else	O
if	O
(	O
pch_char	function
(	O
new	long
)	O
==	O
'+'	O
)	O
{	O
if	O
(	O
!	O
copy_till	function
(	O
outstate	struct
,	O
where	long
+	O
old	long
-	O
1	int
)	O
)	O
return	O
false	int
;	O
if	O
(	O
R_do_defines	pointer
)	O
{	O
if	O
(	O
def_state	enum
==	O
IN_IFNDEF	int
)	O
{	O
fputs	function
(	O
outstate	struct
->	O
after_newline	bool
+	O
else_defined	array
,	O
fp	pointer
)	O
;	O
def_state	enum
=	O
IN_ELSE	int
;	O
}	O
else	O
if	O
(	O
def_state	enum
==	O
OUTSIDE	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
outstate	struct
->	O
after_newline	bool
+	O
if_defined	array
,	O
R_do_defines	pointer
)	O
;	O
def_state	enum
=	O
IN_IFDEF	int
;	O
}	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
}	O
outstate	struct
->	O
after_newline	bool
=	O
pch_write_line	function
(	O
new	long
,	O
fp	pointer
)	O
;	O
outstate	struct
->	O
zero_output	bool
=	O
false	int
;	O
new	long
++	O
;	O
}	O
else	O
if	O
(	O
pch_char	function
(	O
new	long
)	O
!=	O
pch_char	function
(	O
old	long
)	O
)	O
mangled_patch	function
(	O
old	long
,	O
new	long
)	O
;	O
else	O
if	O
(	O
pch_char	function
(	O
new	long
)	O
==	O
'!'	O
)	O
{	O
assert	O
(	O
outstate	struct
->	O
after_newline	bool
)	O
;	O
if	O
(	O
!	O
copy_till	function
(	O
outstate	struct
,	O
where	long
+	O
old	long
-	O
1	int
)	O
)	O
return	O
false	int
;	O
assert	O
(	O
outstate	struct
->	O
after_newline	bool
)	O
;	O
if	O
(	O
R_do_defines	pointer
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
1	int
+	O
not_defined	array
,	O
R_do_defines	pointer
)	O
;	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
def_state	enum
=	O
IN_IFNDEF	int
;	O
}	O
do	O
{	O
if	O
(	O
R_do_defines	pointer
)	O
{	O
outstate	struct
->	O
after_newline	bool
=	O
pch_write_line	function
(	O
old	long
,	O
fp	pointer
)	O
;	O
}	O
last_frozen_line	long
++	O
;	O
old	long
++	O
;	O
}	O
while	O
(	O
pch_char	function
(	O
old	long
)	O
==	O
'!'	O
)	O
;	O
if	O
(	O
R_do_defines	pointer
)	O
{	O
fputs	function
(	O
outstate	struct
->	O
after_newline	bool
+	O
else_defined	array
,	O
fp	pointer
)	O
;	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
def_state	enum
=	O
IN_ELSE	int
;	O
}	O
do	O
{	O
outstate	struct
->	O
after_newline	bool
=	O
pch_write_line	function
(	O
new	long
,	O
fp	pointer
)	O
;	O
new	long
++	O
;	O
}	O
while	O
(	O
pch_char	function
(	O
new	long
)	O
==	O
'!'	O
)	O
;	O
outstate	struct
->	O
zero_output	bool
=	O
false	int
;	O
}	O
else	O
{	O
assert	O
(	O
pch_char	function
(	O
new	long
)	O
==	O
' '	O
)	O
;	O
old	long
++	O
;	O
new	long
++	O
;	O
if	O
(	O
R_do_defines	pointer
&&	O
def_state	enum
!=	O
OUTSIDE	int
)	O
{	O
fputs	function
(	O
outstate	struct
->	O
after_newline	bool
+	O
end_defined	array
,	O
fp	pointer
)	O
;	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
outstate	struct
->	O
after_newline	bool
=	O
true	int
;	O
def_state	enum
=	O
OUTSIDE	int
;	O
}	O
}	O
}	O
if	O
(	O
new	long
<=	O
pat_end	long
&&	O
pch_char	function
(	O
new	long
)	O
==	O
'+'	O
)	O
{	O
if	O
(	O
!	O
copy_till	function
(	O
outstate	struct
,	O
where	long
+	O
old	long
-	O
1	int
)	O
)	O
return	O
false	int
;	O
if	O
(	O
R_do_defines	pointer
)	O
{	O
if	O
(	O
def_state	enum
==	O
OUTSIDE	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
outstate	struct
->	O
after_newline	bool
+	O
if_defined	array
,	O
R_do_defines	pointer
)	O
;	O
def_state	enum
=	O
IN_IFDEF	int
;	O
}	O
else	O
if	O
(	O
def_state	enum
==	O
IN_IFNDEF	int
)	O
{	O
fputs	function
(	O
outstate	struct
->	O
after_newline	bool
+	O
else_defined	array
,	O
fp	pointer
)	O
;	O
def_state	enum
=	O
IN_ELSE	int
;	O
}	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
outstate	struct
->	O
zero_output	bool
=	O
false	int
;	O
}	O
do	O
{	O
if	O
(	O
!	O
outstate	struct
->	O
after_newline	bool
&&	O
putc	function
(	O
'\n'	O
,	O
fp	pointer
)	O
==	O
EOF	O
)	O
write_fatal	function
(	O
)	O
;	O
outstate	struct
->	O
after_newline	bool
=	O
pch_write_line	function
(	O
new	long
,	O
fp	pointer
)	O
;	O
outstate	struct
->	O
zero_output	bool
=	O
false	int
;	O
new	long
++	O
;	O
}	O
while	O
(	O
new	long
<=	O
pat_end	long
&&	O
pch_char	function
(	O
new	long
)	O
==	O
'+'	O
)	O
;	O
}	O
if	O
(	O
R_do_defines	pointer
&&	O
def_state	enum
!=	O
OUTSIDE	int
)	O
{	O
fputs	function
(	O
outstate	struct
->	O
after_newline	bool
+	O
end_defined	array
,	O
fp	pointer
)	O
;	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
outstate	struct
->	O
after_newline	bool
=	O
true	int
;	O
}	O
out_offset	long
+=	O
pch_repl_lines	function
(	O
)	O
-	O
pch_ptrn_lines	function
(	O
)	O
;	O
return	O
true	int
;	O
}	O
static	O
FILE	struct
*	O
create_output_file	function
(	O
char	O
const	O
*	O
name	pointer
,	O
int	O
open_flags	int
)	O
{	O
int	O
fd	int
=	O
create_file	function
(	O
name	pointer
,	O
O_WRONLY	int
|	O
binary_transput	int
|	O
open_flags	int
,	O
instat	struct
.	O
st_mode	int
,	O
true	int
)	O
;	O
FILE	struct
*	O
f	pointer
=	O
fdopen	function
(	O
fd	int
,	O
binary_transput	int
?	O
"wb"	pointer
:	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
pfatal	function
(	O
"Can't create file %s"	pointer
,	O
quotearg	function
(	O
name	pointer
)	O
)	O
;	O
return	O
f	pointer
;	O
}	O
static	O
void	O
init_output	function
(	O
struct	O
outstate	struct
*	O
outstate	struct
)	O
{	O
outstate	struct
->	O
ofp	pointer
=	O
NULL	O
;	O
outstate	struct
->	O
after_newline	bool
=	O
true	int
;	O
outstate	struct
->	O
zero_output	bool
=	O
true	int
;	O
}	O
static	O
FILE	struct
*	O
open_outfile	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
"-"	pointer
)	O
!=	O
0	int
)	O
return	O
create_output_file	function
(	O
name	pointer
,	O
0	int
)	O
;	O
else	O
{	O
FILE	struct
*	O
ofp	pointer
;	O
int	O
stdout_dup	int
=	O
dup	function
(	O
fileno	function
(	O
stdout	pointer
)	O
)	O
;	O
if	O
(	O
stdout_dup	int
==	O
-	O
1	int
)	O
pfatal	function
(	O
"Failed to duplicate standard output"	pointer
)	O
;	O
ofp	pointer
=	O
fdopen	function
(	O
stdout_dup	int
,	O
"a"	pointer
)	O
;	O
if	O
(	O
!	O
ofp	pointer
)	O
pfatal	function
(	O
"Failed to duplicate standard output"	pointer
)	O
;	O
if	O
(	O
dup2	function
(	O
fileno	function
(	O
stderr	pointer
)	O
,	O
fileno	function
(	O
stdout	pointer
)	O
)	O
==	O
-	O
1	int
)	O
pfatal	function
(	O
"Failed to redirect messages to standard error"	pointer
)	O
;	O
return	O
ofp	pointer
;	O
}	O
}	O
static	O
void	O
init_reject	function
(	O
char	O
const	O
*	O
outname	pointer
)	O
{	O
int	O
fd	int
;	O
fd	int
=	O
make_tempfile	function
(	O
&	O
TMPREJNAME	pointer
,	O
'r'	O
,	O
outname	pointer
,	O
O_WRONLY	int
|	O
binary_transput	int
,	O
0666	int
)	O
;	O
TMPREJNAME_needs_removal	int
=	O
1	int
;	O
rejfp	pointer
=	O
fdopen	function
(	O
fd	int
,	O
binary_transput	int
?	O
"wb"	pointer
:	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
rejfp	pointer
)	O
pfatal	function
(	O
"Can't open stream for file %s"	pointer
,	O
quotearg	function
(	O
TMPREJNAME	pointer
)	O
)	O
;	O
}	O
bool	bool
copy_till	function
(	O
struct	O
outstate	struct
*	O
outstate	struct
,	O
lin	long
lastline	long
)	O
{	O
lin	long
R_last_frozen_line	long
=	O
last_frozen_line	long
;	O
FILE	struct
*	O
fp	pointer
=	O
outstate	struct
->	O
ofp	pointer
;	O
char	O
const	O
*	O
s	enum
;	O
size_t	long
size	pointer
;	O
if	O
(	O
R_last_frozen_line	long
>	O
lastline	long
)	O
{	O
say	function
(	O
"misordered hunks! output would be garbled\n"	pointer
)	O
;	O
return	O
false	int
;	O
}	O
while	O
(	O
R_last_frozen_line	long
<	O
lastline	long
)	O
{	O
s	enum
=	O
ifetch	function
(	O
++	O
R_last_frozen_line	long
,	O
false	int
,	O
&	O
size	pointer
)	O
;	O
if	O
(	O
size	pointer
)	O
{	O
if	O
(	O
(	O
!	O
outstate	struct
->	O
after_newline	bool
&&	O
putc	function
(	O
'\n'	O
,	O
fp	pointer
)	O
==	O
EOF	O
)	O
||	O
!	O
fwrite	function
(	O
s	enum
,	O
sizeof	O
*	O
s	enum
,	O
size	pointer
,	O
fp	pointer
)	O
)	O
write_fatal	function
(	O
)	O
;	O
outstate	struct
->	O
after_newline	bool
=	O
s	enum
[	O
size	pointer
-	O
1	int
]	O
==	O
'\n'	O
;	O
outstate	struct
->	O
zero_output	bool
=	O
false	int
;	O
}	O
}	O
last_frozen_line	long
=	O
R_last_frozen_line	long
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
spew_output	function
(	O
struct	O
outstate	struct
*	O
outstate	struct
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
if	O
(	O
debug	int
&	O
256	int
)	O
{	O
char	O
numbuf0	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
char	O
numbuf1	array
[	O
LINENUM_LENGTH_BOUND	O
+	O
1	int
]	O
;	O
say	function
(	O
"il=%s lfl=%s\n"	pointer
,	O
format_linenum	function
(	O
numbuf0	array
,	O
input_lines	long
)	O
,	O
format_linenum	function
(	O
numbuf1	array
,	O
last_frozen_line	long
)	O
)	O
;	O
}	O
if	O
(	O
last_frozen_line	long
<	O
input_lines	long
)	O
if	O
(	O
!	O
copy_till	function
(	O
outstate	struct
,	O
input_lines	long
)	O
)	O
return	O
false	int
;	O
if	O
(	O
outstate	struct
->	O
ofp	pointer
&&	O
!	O
outfile	pointer
)	O
{	O
if	O
(	O
fflush	function
(	O
outstate	struct
->	O
ofp	pointer
)	O
!=	O
0	int
||	O
fstat	function
(	O
fileno	function
(	O
outstate	struct
->	O
ofp	pointer
)	O
,	O
st	pointer
)	O
!=	O
0	int
||	O
fclose	function
(	O
outstate	struct
->	O
ofp	pointer
)	O
!=	O
0	int
)	O
write_fatal	function
(	O
)	O
;	O
outstate	struct
->	O
ofp	pointer
=	O
0	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
patch_match	function
(	O
lin	long
base	int
,	O
lin	long
offset	long
,	O
lin	long
prefix_fuzz	long
,	O
lin	long
suffix_fuzz	long
)	O
{	O
lin	long
pline	long
=	O
1	int
+	O
prefix_fuzz	long
;	O
lin	long
iline	long
;	O
lin	long
pat_lines	long
=	O
pch_ptrn_lines	function
(	O
)	O
-	O
suffix_fuzz	long
;	O
size_t	long
size	pointer
;	O
char	O
const	O
*	O
p	pointer
;	O
for	O
(	O
iline	long
=	O
base	int
+	O
offset	long
+	O
prefix_fuzz	long
;	O
pline	long
<=	O
pat_lines	long
;	O
pline	long
++	O
,	O
iline	long
++	O
)	O
{	O
p	pointer
=	O
ifetch	function
(	O
iline	long
,	O
offset	long
>=	O
0	int
,	O
&	O
size	pointer
)	O
;	O
if	O
(	O
canonicalize	bool
)	O
{	O
if	O
(	O
!	O
similar	function
(	O
p	pointer
,	O
size	pointer
,	O
pfetch	function
(	O
pline	long
)	O
,	O
pch_line_len	function
(	O
pline	long
)	O
)	O
)	O
return	O
false	int
;	O
}	O
else	O
if	O
(	O
size	pointer
!=	O
pch_line_len	function
(	O
pline	long
)	O
||	O
memcmp	function
(	O
p	pointer
,	O
pfetch	function
(	O
pline	long
)	O
,	O
size	pointer
)	O
!=	O
0	int
)	O
return	O
false	int
;	O
}	O
return	O
true	int
;	O
}	O
bool	bool
similar	function
(	O
char	O
const	O
*	O
a	struct
,	O
size_t	long
alen	long
,	O
char	O
const	O
*	O
b	struct
,	O
size_t	long
blen	long
)	O
{	O
alen	long
-=	O
alen	long
&&	O
a	struct
[	O
alen	long
-	O
1	int
]	O
==	O
'\n'	O
;	O
blen	long
-=	O
blen	long
&&	O
b	struct
[	O
blen	long
-	O
1	int
]	O
==	O
'\n'	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
blen	long
||	O
(	O
*	O
b	struct
==	O
' '	O
||	O
*	O
b	struct
==	O
'\t'	O
)	O
)	O
{	O
while	O
(	O
blen	long
&&	O
(	O
*	O
b	struct
==	O
' '	O
||	O
*	O
b	struct
==	O
'\t'	O
)	O
)	O
b	struct
++	O
,	O
blen	long
--	O
;	O
if	O
(	O
alen	long
)	O
{	O
if	O
(	O
!	O
(	O
*	O
a	struct
==	O
' '	O
||	O
*	O
a	struct
==	O
'\t'	O
)	O
)	O
return	O
false	int
;	O
do	O
a	struct
++	O
,	O
alen	long
--	O
;	O
while	O
(	O
alen	long
&&	O
(	O
*	O
a	struct
==	O
' '	O
||	O
*	O
a	struct
==	O
'\t'	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
alen	long
||	O
!	O
blen	long
)	O
return	O
alen	long
==	O
blen	long
;	O
}	O
else	O
if	O
(	O
!	O
alen	long
||	O
*	O
a	struct
++	O
!=	O
*	O
b	struct
++	O
)	O
return	O
false	int
;	O
else	O
alen	long
--	O
,	O
blen	long
--	O
;	O
}	O
}	O
struct	O
file_to_delete	struct
{	O
char	O
*	O
name	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
bool	bool
backup	bool
;	O
}	O
;	O
static	O
gl_list_t	pointer
files_to_delete	pointer
;	O
static	O
void	O
init_files_to_delete	function
(	O
void	O
)	O
{	O
files_to_delete	pointer
=	O
gl_list_create_empty	function
(	O
GL_LINKED_LIST	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
true	int
)	O
;	O
}	O
static	O
void	O
delete_file_later	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
struct	O
stat	struct
*	O
st	pointer
,	O
bool	bool
backup	bool
)	O
{	O
struct	O
file_to_delete	struct
*	O
file_to_delete	struct
;	O
struct	O
stat	struct
st_tmp	struct
;	O
if	O
(	O
!	O
st	pointer
)	O
{	O
if	O
(	O
lstat	function
(	O
name	pointer
,	O
&	O
st_tmp	struct
)	O
!=	O
0	int
)	O
pfatal	function
(	O
"Can't get file attributes of %s %s"	pointer
,	O
"file"	pointer
,	O
name	pointer
)	O
;	O
st	pointer
=	O
&	O
st_tmp	struct
;	O
}	O
file_to_delete	struct
=	O
xmalloc	function
(	O
sizeof	O
*	O
file_to_delete	struct
)	O
;	O
file_to_delete	struct
->	O
name	pointer
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
file_to_delete	struct
->	O
st	pointer
=	O
*	O
st	pointer
;	O
file_to_delete	struct
->	O
backup	bool
=	O
backup	bool
;	O
gl_list_add_last	function
(	O
files_to_delete	pointer
,	O
file_to_delete	struct
)	O
;	O
insert_file_id	function
(	O
st	pointer
,	O
DELETE_LATER	int
)	O
;	O
}	O
static	O
void	O
delete_files	function
(	O
void	O
)	O
{	O
gl_list_iterator_t	struct
iter	struct
;	O
const	O
void	O
*	O
elt	pointer
;	O
iter	struct
=	O
gl_list_iterator	function
(	O
files_to_delete	pointer
)	O
;	O
while	O
(	O
gl_list_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
elt	pointer
,	O
NULL	O
)	O
)	O
{	O
const	O
struct	O
file_to_delete	struct
*	O
file_to_delete	struct
=	O
elt	pointer
;	O
if	O
(	O
lookup_file_id	function
(	O
&	O
file_to_delete	struct
->	O
st	pointer
)	O
==	O
DELETE_LATER	int
)	O
{	O
mode_t	int
mode	int
=	O
file_to_delete	struct
->	O
st	pointer
.	O
st_mode	int
;	O
if	O
(	O
verbosity	enum
==	O
VERBOSE	int
)	O
say	function
(	O
"Removing %s %s\n"	pointer
,	O
S_ISLNK	O
(	O
mode	int
)	O
?	O
"symbolic link"	pointer
:	O
"file"	pointer
,	O
quotearg	function
(	O
file_to_delete	struct
->	O
name	pointer
)	O
)	O
;	O
move_file	function
(	O
0	int
,	O
0	int
,	O
0	int
,	O
file_to_delete	struct
->	O
name	pointer
,	O
mode	int
,	O
file_to_delete	struct
->	O
backup	bool
)	O
;	O
removedirs	function
(	O
file_to_delete	struct
->	O
name	pointer
)	O
;	O
}	O
}	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
struct	O
file_to_output	struct
{	O
char	O
*	O
from	pointer
;	O
struct	O
stat	struct
from_st	struct
;	O
char	O
*	O
to	pointer
;	O
mode_t	int
mode	int
;	O
bool	bool
backup	bool
;	O
}	O
;	O
static	O
gl_list_t	pointer
files_to_output	pointer
;	O
static	O
void	O
output_file_later	function
(	O
char	O
const	O
*	O
from	pointer
,	O
int	O
*	O
from_needs_removal	pointer
,	O
const	O
struct	O
stat	struct
*	O
from_st	struct
,	O
char	O
const	O
*	O
to	pointer
,	O
mode_t	int
mode	int
,	O
bool	bool
backup	bool
)	O
{	O
struct	O
file_to_output	struct
*	O
file_to_output	struct
;	O
file_to_output	struct
=	O
xmalloc	function
(	O
sizeof	O
*	O
file_to_output	struct
)	O
;	O
file_to_output	struct
->	O
from	pointer
=	O
xstrdup	function
(	O
from	pointer
)	O
;	O
file_to_output	struct
->	O
from_st	struct
=	O
*	O
from_st	struct
;	O
file_to_output	struct
->	O
to	pointer
=	O
to	pointer
?	O
xstrdup	function
(	O
to	pointer
)	O
:	O
NULL	O
;	O
file_to_output	struct
->	O
mode	int
=	O
mode	int
;	O
file_to_output	struct
->	O
backup	bool
=	O
backup	bool
;	O
gl_list_add_last	function
(	O
files_to_output	pointer
,	O
file_to_output	struct
)	O
;	O
if	O
(	O
from_needs_removal	pointer
)	O
*	O
from_needs_removal	pointer
=	O
0	int
;	O
}	O
static	O
void	O
output_file_now	function
(	O
char	O
const	O
*	O
from	pointer
,	O
int	O
*	O
from_needs_removal	pointer
,	O
const	O
struct	O
stat	struct
*	O
from_st	struct
,	O
char	O
const	O
*	O
to	pointer
,	O
mode_t	int
mode	int
,	O
bool	bool
backup	bool
)	O
{	O
if	O
(	O
to	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
backup	bool
)	O
create_backup	function
(	O
from	pointer
,	O
from_st	struct
,	O
true	int
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
from_st	struct
->	O
st_size	long
!=	O
-	O
1	int
)	O
;	O
move_file	function
(	O
from	pointer
,	O
from_needs_removal	pointer
,	O
from_st	struct
,	O
to	pointer
,	O
mode	int
,	O
backup	bool
)	O
;	O
}	O
}	O
static	O
void	O
output_file	function
(	O
char	O
const	O
*	O
from	pointer
,	O
int	O
*	O
from_needs_removal	pointer
,	O
const	O
struct	O
stat	struct
*	O
from_st	struct
,	O
char	O
const	O
*	O
to	pointer
,	O
const	O
struct	O
stat	struct
*	O
to_st	pointer
,	O
mode_t	int
mode	int
,	O
bool	bool
backup	bool
)	O
{	O
if	O
(	O
from	pointer
==	O
NULL	O
)	O
{	O
delete_file_later	function
(	O
to	pointer
,	O
to_st	pointer
,	O
backup	bool
)	O
;	O
}	O
else	O
if	O
(	O
pch_git_diff	function
(	O
)	O
&&	O
pch_says_nonexistent	function
(	O
reverse	bool
)	O
!=	O
2	int
)	O
{	O
output_file_later	function
(	O
from	pointer
,	O
from_needs_removal	pointer
,	O
from_st	struct
,	O
to	pointer
,	O
mode	int
,	O
backup	bool
)	O
;	O
}	O
else	O
output_file_now	function
(	O
from	pointer
,	O
from_needs_removal	pointer
,	O
from_st	struct
,	O
to	pointer
,	O
mode	int
,	O
backup	bool
)	O
;	O
}	O
static	O
void	O
dispose_file_to_output	function
(	O
const	O
void	O
*	O
elt	pointer
)	O
{	O
const	O
struct	O
file_to_output	struct
*	O
file_to_output	struct
=	O
elt	pointer
;	O
free	function
(	O
file_to_output	struct
->	O
from	pointer
)	O
;	O
free	function
(	O
file_to_output	struct
->	O
to	pointer
)	O
;	O
}	O
static	O
void	O
init_files_to_output	function
(	O
void	O
)	O
{	O
files_to_output	pointer
=	O
gl_list_create_empty	function
(	O
GL_LINKED_LIST	O
,	O
NULL	O
,	O
NULL	O
,	O
dispose_file_to_output	function
,	O
true	int
)	O
;	O
}	O
static	O
void	O
gl_list_clear	function
(	O
gl_list_t	pointer
list	pointer
)	O
{	O
while	O
(	O
gl_list_size	function
(	O
list	pointer
)	O
>	O
0	int
)	O
gl_list_remove_at	function
(	O
list	pointer
,	O
0	int
)	O
;	O
}	O
static	O
void	O
output_files	function
(	O
struct	O
stat	struct
const	O
*	O
st	pointer
)	O
{	O
gl_list_iterator_t	struct
iter	struct
;	O
const	O
void	O
*	O
elt	pointer
;	O
iter	struct
=	O
gl_list_iterator	function
(	O
files_to_output	pointer
)	O
;	O
while	O
(	O
gl_list_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
elt	pointer
,	O
NULL	O
)	O
)	O
{	O
const	O
struct	O
file_to_output	struct
*	O
file_to_output	struct
=	O
elt	pointer
;	O
int	O
from_needs_removal	pointer
=	O
1	int
;	O
struct	O
stat	struct
const	O
*	O
from_st	struct
=	O
&	O
file_to_output	struct
->	O
from_st	struct
;	O
output_file_now	function
(	O
file_to_output	struct
->	O
from	pointer
,	O
&	O
from_needs_removal	pointer
,	O
from_st	struct
,	O
file_to_output	struct
->	O
to	pointer
,	O
file_to_output	struct
->	O
mode	int
,	O
file_to_output	struct
->	O
backup	bool
)	O
;	O
if	O
(	O
from_needs_removal	pointer
)	O
unlink	function
(	O
file_to_output	struct
->	O
from	pointer
)	O
;	O
if	O
(	O
st	pointer
&&	O
st	pointer
->	O
st_dev	long
==	O
from_st	struct
->	O
st_dev	long
&&	O
st	pointer
->	O
st_ino	long
==	O
from_st	struct
->	O
st_ino	long
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
const	O
void	O
*	O
elt2	pointer
=	O
gl_list_get_at	function
(	O
files_to_output	pointer
,	O
0	int
)	O
;	O
gl_list_remove_at	function
(	O
files_to_output	pointer
,	O
0	int
)	O
;	O
if	O
(	O
elt	pointer
==	O
elt2	pointer
)	O
break	O
;	O
}	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
return	O
;	O
}	O
}	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
gl_list_clear	function
(	O
files_to_output	pointer
)	O
;	O
}	O
static	O
void	O
forget_output_files	function
(	O
void	O
)	O
{	O
gl_list_iterator_t	struct
iter	struct
=	O
gl_list_iterator	function
(	O
files_to_output	pointer
)	O
;	O
const	O
void	O
*	O
elt	pointer
;	O
while	O
(	O
gl_list_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
elt	pointer
,	O
NULL	O
)	O
)	O
{	O
const	O
struct	O
file_to_output	struct
*	O
file_to_output	struct
=	O
elt	pointer
;	O
unlink	function
(	O
file_to_output	struct
->	O
from	pointer
)	O
;	O
}	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
gl_list_clear	function
(	O
files_to_output	pointer
)	O
;	O
}	O
void	O
fatal_exit	function
(	O
int	O
sig	int
)	O
{	O
cleanup	function
(	O
)	O
;	O
if	O
(	O
sig	int
)	O
exit_with_signal	function
(	O
sig	int
)	O
;	O
exit	function
(	O
2	int
)	O
;	O
}	O
static	O
void	O
remove_if_needed	function
(	O
char	O
const	O
*	O
name	pointer
,	O
int	O
*	O
needs_removal	pointer
)	O
{	O
if	O
(	O
*	O
needs_removal	pointer
)	O
{	O
unlink	function
(	O
name	pointer
)	O
;	O
*	O
needs_removal	pointer
=	O
0	int
;	O
}	O
}	O
static	O
void	O
cleanup	function
(	O
void	O
)	O
{	O
remove_if_needed	function
(	O
TMPINNAME	pointer
,	O
&	O
TMPINNAME_needs_removal	int
)	O
;	O
remove_if_needed	function
(	O
TMPOUTNAME	pointer
,	O
&	O
TMPOUTNAME_needs_removal	int
)	O
;	O
remove_if_needed	function
(	O
TMPPATNAME	pointer
,	O
&	O
TMPPATNAME_needs_removal	int
)	O
;	O
remove_if_needed	function
(	O
TMPREJNAME	pointer
,	O
&	O
TMPREJNAME_needs_removal	int
)	O
;	O
forget_output_files	function
(	O
)	O
;	O
}	O
