char	O
*	O
hostname	pointer
=	O
0	int
;	O
extern	O
char	O
*	O
getenv	function
(	O
const	O
char	O
*	O
)	O
;	O
extern	O
int	O
isprefix	function
(	O
register	O
char	O
*	O
s1	pointer
,	O
register	O
char	O
*	O
s2	pointer
)	O
;	O
extern	O
char	O
*	O
*	O
genget	function
(	O
char	O
*	O
,	O
char	O
*	O
*	O
,	O
int	O
)	O
;	O
extern	O
int	O
Ambiguous	function
(	O
)	O
;	O
typedef	O
int	O
(	O
*	O
intrtn_t	pointer
)	O
(	O
int	O
,	O
char	O
*	O
[	O
]	O
)	O
;	O
static	O
int	O
call	function
(	O
intrtn_t	pointer
,	O
...	O
)	O
;	O
typedef	O
struct	O
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
help	pointer
;	O
int	O
(	O
*	O
handler	pointer
)	O
(	O
)	O
;	O
int	O
needconnect	int
;	O
}	O
Command	struct
;	O
static	O
char	O
line	pointer
[	O
256	int
]	O
;	O
static	O
char	O
saveline	array
[	O
256	int
]	O
;	O
static	O
int	O
margc	int
;	O
static	O
char	O
*	O
margv	array
[	O
20	int
]	O
;	O
static	O
void	O
makeargv	function
(	O
void	O
)	O
{	O
register	O
char	O
*	O
cp	pointer
,	O
*	O
cp2	pointer
,	O
c	int
;	O
register	O
char	O
*	O
*	O
argp	pointer
=	O
margv	array
;	O
margc	int
=	O
0	int
;	O
cp	pointer
=	O
line	pointer
;	O
if	O
(	O
*	O
cp	pointer
==	O
'!'	O
)	O
{	O
strcpy	function
(	O
saveline	array
,	O
line	pointer
)	O
;	O
*	O
argp	pointer
++	O
=	O
"!"	pointer
;	O
margc	int
++	O
;	O
cp	pointer
++	O
;	O
}	O
while	O
(	O
(	O
c	int
=	O
*	O
cp	pointer
)	O
)	O
{	O
register	O
int	O
inquote	int
=	O
0	int
;	O
while	O
(	O
isspace	function
(	O
c	int
)	O
)	O
c	int
=	O
*	O
++	O
cp	pointer
;	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
break	O
;	O
*	O
argp	pointer
++	O
=	O
cp	pointer
;	O
margc	int
+=	O
1	int
;	O
for	O
(	O
cp2	pointer
=	O
cp	pointer
;	O
c	int
!=	O
'\0'	O
;	O
c	int
=	O
*	O
++	O
cp	pointer
)	O
{	O
if	O
(	O
inquote	int
)	O
{	O
if	O
(	O
c	int
==	O
inquote	int
)	O
{	O
inquote	int
=	O
0	int
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
*	O
++	O
cp	pointer
)	O
==	O
'\0'	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'"'	O
)	O
{	O
inquote	int
=	O
'"'	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\''	O
)	O
{	O
inquote	int
=	O
'\''	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
isspace	function
(	O
c	int
)	O
)	O
break	O
;	O
}	O
*	O
cp2	pointer
++	O
=	O
c	int
;	O
}	O
*	O
cp2	pointer
=	O
'\0'	O
;	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
break	O
;	O
cp	pointer
++	O
;	O
}	O
*	O
argp	pointer
++	O
=	O
0	int
;	O
}	O
static	O
int	O
special	function
(	O
register	O
char	O
*	O
s	long
)	O
{	O
register	O
char	O
c	int
;	O
char	O
b	char
;	O
switch	O
(	O
*	O
s	long
)	O
{	O
case	O
'^'	O
:	O
b	char
=	O
*	O
++	O
s	long
;	O
if	O
(	O
b	char
==	O
'?'	O
)	O
{	O
c	int
=	O
b	char
|	O
0x40	int
;	O
}	O
else	O
{	O
c	int
=	O
b	char
&	O
0x1f	int
;	O
}	O
break	O
;	O
default	O
:	O
c	int
=	O
*	O
s	long
;	O
break	O
;	O
}	O
return	O
c	int
;	O
}	O
static	O
const	O
char	O
*	O
control	function
(	O
register	O
cc_t	char
c	int
)	O
{	O
static	O
char	O
buf	pointer
[	O
5	int
]	O
;	O
register	O
unsigned	O
int	O
uic	int
=	O
(	O
unsigned	O
int	O
)	O
c	int
;	O
if	O
(	O
uic	int
==	O
0x7f	int
)	O
return	O
(	O
"^?"	pointer
)	O
;	O
if	O
(	O
c	int
==	O
(	O
cc_t	char
)	O
_POSIX_VDISABLE	char
)	O
{	O
return	O
"off"	pointer
;	O
}	O
if	O
(	O
uic	int
>=	O
0x80	int
)	O
{	O
buf	pointer
[	O
0	int
]	O
=	O
'\\'	O
;	O
buf	pointer
[	O
1	int
]	O
=	O
(	O
(	O
c	int
>>	O
6	int
)	O
&	O
07	int
)	O
+	O
'0'	O
;	O
buf	pointer
[	O
2	int
]	O
=	O
(	O
(	O
c	int
>>	O
3	int
)	O
&	O
07	int
)	O
+	O
'0'	O
;	O
buf	pointer
[	O
3	int
]	O
=	O
(	O
c	int
&	O
07	int
)	O
+	O
'0'	O
;	O
buf	pointer
[	O
4	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
uic	int
>=	O
0x20	int
)	O
{	O
buf	pointer
[	O
0	int
]	O
=	O
c	int
;	O
buf	pointer
[	O
1	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
buf	pointer
[	O
0	int
]	O
=	O
'^'	O
;	O
buf	pointer
[	O
1	int
]	O
=	O
'@'	O
+	O
c	int
;	O
buf	pointer
[	O
2	int
]	O
=	O
0	int
;	O
}	O
return	O
(	O
buf	pointer
)	O
;	O
}	O
struct	O
sendlist	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
help	pointer
;	O
int	O
needconnect	int
;	O
int	O
narg	int
;	O
int	O
(	O
*	O
handler	pointer
)	O
(	O
)	O
;	O
int	O
nbyte	int
;	O
int	O
what	int
;	O
}	O
;	O
static	O
int	O
send_esc	function
(	O
void	O
)	O
,	O
send_help	function
(	O
void	O
)	O
,	O
send_docmd	function
(	O
char	O
*	O
)	O
,	O
send_dontcmd	function
(	O
char	O
*	O
)	O
,	O
send_willcmd	function
(	O
char	O
*	O
)	O
,	O
send_wontcmd	function
(	O
char	O
*	O
)	O
;	O
static	O
struct	O
sendlist	struct
Sendlist	array
[	O
]	O
=	O
{	O
{	O
"ao"	pointer
,	O
"Send Telnet Abort output"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
AO	int
}	O
,	O
{	O
"ayt"	pointer
,	O
"Send Telnet 'Are You There'"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
AYT	int
}	O
,	O
{	O
"brk"	pointer
,	O
"Send Telnet Break"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
BREAK	int
}	O
,	O
{	O
"break"	pointer
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
BREAK	int
}	O
,	O
{	O
"ec"	pointer
,	O
"Send Telnet Erase Character"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
EC	int
}	O
,	O
{	O
"el"	pointer
,	O
"Send Telnet Erase Line"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
EL	int
}	O
,	O
{	O
"escape"	pointer
,	O
"Send current escape character"	pointer
,	O
1	int
,	O
0	int
,	O
send_esc	function
,	O
1	int
,	O
0	int
}	O
,	O
{	O
"ga"	pointer
,	O
"Send Telnet 'Go Ahead' sequence"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
GA	int
}	O
,	O
{	O
"ip"	pointer
,	O
"Send Telnet Interrupt Process"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
IP	int
}	O
,	O
{	O
"intp"	pointer
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
IP	int
}	O
,	O
{	O
"interrupt"	pointer
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
IP	int
}	O
,	O
{	O
"intr"	pointer
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
IP	int
}	O
,	O
{	O
"nop"	pointer
,	O
"Send Telnet 'No operation'"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
NOP	int
}	O
,	O
{	O
"eor"	pointer
,	O
"Send Telnet 'End of Record'"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
EOR	int
}	O
,	O
{	O
"abort"	pointer
,	O
"Send Telnet 'Abort Process'"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
ABORT	int
}	O
,	O
{	O
"susp"	pointer
,	O
"Send Telnet 'Suspend Process'"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
SUSP	int
}	O
,	O
{	O
"eof"	pointer
,	O
"Send Telnet End of File Character"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
2	int
,	O
xEOF	int
}	O
,	O
{	O
"synch"	pointer
,	O
"Perform Telnet 'Synch operation'"	pointer
,	O
1	int
,	O
0	int
,	O
dosynch	function
,	O
2	int
,	O
0	int
}	O
,	O
{	O
"getstatus"	pointer
,	O
"Send request for STATUS"	pointer
,	O
1	int
,	O
0	int
,	O
get_status	function
,	O
6	int
,	O
0	int
}	O
,	O
{	O
"?"	pointer
,	O
"Display send options"	pointer
,	O
0	int
,	O
0	int
,	O
send_help	function
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
send_help	function
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"do"	pointer
,	O
0	int
,	O
0	int
,	O
1	int
,	O
send_docmd	function
,	O
3	int
,	O
0	int
}	O
,	O
{	O
"dont"	pointer
,	O
0	int
,	O
0	int
,	O
1	int
,	O
send_dontcmd	function
,	O
3	int
,	O
0	int
}	O
,	O
{	O
"will"	pointer
,	O
0	int
,	O
0	int
,	O
1	int
,	O
send_willcmd	function
,	O
3	int
,	O
0	int
}	O
,	O
{	O
"wont"	pointer
,	O
0	int
,	O
0	int
,	O
1	int
,	O
send_wontcmd	function
,	O
3	int
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
int	O
sendcmd	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
count	int
;	O
int	O
i	int
;	O
struct	O
sendlist	struct
*	O
s	long
;	O
int	O
success	int
=	O
0	int
;	O
int	O
needconnect	int
=	O
0	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
printf	function
(	O
"need at least one argument for 'send' command\n"	pointer
)	O
;	O
printf	function
(	O
"'send ?' for help\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
s	long
=	O
GETSEND	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
s	long
==	O
0	int
)	O
{	O
printf	function
(	O
"Unknown send argument '%s'\n'send ?' for help.\n"	pointer
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
Ambiguous	function
(	O
s	long
)	O
)	O
{	O
printf	function
(	O
"Ambiguous send argument '%s'\n'send ?' for help.\n"	pointer
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
i	int
+	O
s	long
->	O
narg	int
>=	O
argc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Need %d argument%s to 'send %s' command.  'send %s ?' for help.\n"	pointer
,	O
s	long
->	O
narg	int
,	O
s	long
->	O
narg	int
==	O
1	int
?	O
""	pointer
:	O
"s"	pointer
,	O
s	long
->	O
name	pointer
,	O
s	long
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
count	int
+=	O
s	long
->	O
nbyte	int
;	O
if	O
(	O
s	long
->	O
handler	pointer
==	O
send_help	function
)	O
{	O
send_help	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
i	int
+=	O
s	long
->	O
narg	int
;	O
needconnect	int
+=	O
s	long
->	O
needconnect	int
;	O
}	O
if	O
(	O
!	O
connected	int
&&	O
needconnect	int
)	O
{	O
printf	function
(	O
"?Need to be connected first.\n"	pointer
)	O
;	O
printf	function
(	O
"'send ?' for help\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
NETROOM	O
(	O
)	O
<	O
count	int
)	O
{	O
printf	function
(	O
"There is not enough room in the buffer TO the network\n"	pointer
)	O
;	O
printf	function
(	O
"to process your request.  Nothing will be done.\n"	pointer
)	O
;	O
printf	function
(	O
"('send synch' will throw away most data in the network\n"	pointer
)	O
;	O
printf	function
(	O
"buffer, if this might help.)\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
s	long
=	O
GETSEND	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Telnet 'send' error - argument disappeared!\n"	pointer
)	O
;	O
quit	function
(	O
)	O
;	O
}	O
if	O
(	O
s	long
->	O
handler	pointer
)	O
{	O
count	int
++	O
;	O
success	int
+=	O
(	O
*	O
s	long
->	O
handler	pointer
)	O
(	O
(	O
s	long
->	O
narg	int
>	O
0	int
)	O
?	O
argv	pointer
[	O
i	int
+	O
1	int
]	O
:	O
0	int
,	O
(	O
s	long
->	O
narg	int
>	O
1	int
)	O
?	O
argv	pointer
[	O
i	int
+	O
2	int
]	O
:	O
0	int
)	O
;	O
i	int
+=	O
s	long
->	O
narg	int
;	O
}	O
else	O
{	O
NET2ADD	O
(	O
IAC	int
,	O
s	long
->	O
what	int
)	O
;	O
printoption	function
(	O
"SENT"	pointer
,	O
IAC	int
,	O
s	long
->	O
what	int
)	O
;	O
}	O
}	O
return	O
(	O
count	int
==	O
success	int
)	O
;	O
}	O
static	O
int	O
send_esc	function
(	O
void	O
)	O
{	O
NETADD	O
(	O
escape	char
)	O
;	O
return	O
1	int
;	O
}	O
int	O
send_tncmd	function
(	O
void	O
(	O
*	O
func	pointer
)	O
(	O
)	O
,	O
char	O
*	O
cmd	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
char	O
*	O
*	O
cpp	pointer
;	O
extern	O
char	O
*	O
telopts	array
[	O
]	O
;	O
register	O
int	O
val	array
=	O
0	int
;	O
if	O
(	O
isprefix	function
(	O
name	pointer
,	O
"help"	pointer
)	O
||	O
isprefix	function
(	O
name	pointer
,	O
"?"	pointer
)	O
)	O
{	O
register	O
int	O
col	int
,	O
len	char
;	O
printf	function
(	O
"Usage: send %s <value|option>\n"	pointer
,	O
cmd	pointer
)	O
;	O
printf	function
(	O
"\"value\" must be from 0 to 255\n"	pointer
)	O
;	O
printf	function
(	O
"Valid options are:\n\t"	pointer
)	O
;	O
col	int
=	O
8	int
;	O
for	O
(	O
cpp	pointer
=	O
telopts	array
;	O
*	O
cpp	pointer
;	O
cpp	pointer
++	O
)	O
{	O
len	char
=	O
strlen	function
(	O
*	O
cpp	pointer
)	O
+	O
3	int
;	O
if	O
(	O
col	int
+	O
len	char
>	O
65	int
)	O
{	O
printf	function
(	O
"\n\t"	pointer
)	O
;	O
col	int
=	O
8	int
;	O
}	O
printf	function
(	O
" \"%s\""	pointer
,	O
*	O
cpp	pointer
)	O
;	O
col	int
+=	O
len	char
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
cpp	pointer
=	O
(	O
char	O
*	O
*	O
)	O
genget	function
(	O
name	pointer
,	O
telopts	array
,	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
Ambiguous	function
(	O
cpp	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': ambiguous argument ('send %s ?' for help).\n"	pointer
,	O
name	pointer
,	O
cmd	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
cpp	pointer
)	O
{	O
val	array
=	O
cpp	pointer
-	O
telopts	array
;	O
}	O
else	O
{	O
register	O
char	O
*	O
cp	pointer
=	O
name	pointer
;	O
while	O
(	O
*	O
cp	pointer
>=	O
'0'	O
&&	O
*	O
cp	pointer
<=	O
'9'	O
)	O
{	O
val	array
*=	O
10	int
;	O
val	array
+=	O
*	O
cp	pointer
-	O
'0'	O
;	O
cp	pointer
++	O
;	O
}	O
if	O
(	O
*	O
cp	pointer
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': unknown argument ('send %s ?' for help).\n"	pointer
,	O
name	pointer
,	O
cmd	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
val	array
<	O
0	int
||	O
val	array
>	O
255	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': bad value ('send %s ?' for help).\n"	pointer
,	O
name	pointer
,	O
cmd	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
connected	int
)	O
{	O
printf	function
(	O
"?Need to be connected first.\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
(	O
*	O
func	pointer
)	O
(	O
val	array
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
send_docmd	function
(	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
send_tncmd	function
(	O
send_do	function
,	O
"do"	pointer
,	O
name	pointer
)	O
)	O
;	O
}	O
static	O
int	O
send_dontcmd	function
(	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
send_tncmd	function
(	O
send_dont	function
,	O
"dont"	pointer
,	O
name	pointer
)	O
)	O
;	O
}	O
static	O
int	O
send_willcmd	function
(	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
send_tncmd	function
(	O
send_will	function
,	O
"will"	pointer
,	O
name	pointer
)	O
)	O
;	O
}	O
static	O
int	O
send_wontcmd	function
(	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
send_tncmd	function
(	O
send_wont	function
,	O
"wont"	pointer
,	O
name	pointer
)	O
)	O
;	O
}	O
static	O
int	O
send_help	function
(	O
void	O
)	O
{	O
struct	O
sendlist	struct
*	O
s	long
;	O
for	O
(	O
s	long
=	O
Sendlist	array
;	O
s	long
->	O
name	pointer
;	O
s	long
++	O
)	O
{	O
if	O
(	O
s	long
->	O
help	pointer
)	O
printf	function
(	O
"%-15s %s\n"	pointer
,	O
s	long
->	O
name	pointer
,	O
s	long
->	O
help	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
lclchars	function
(	O
void	O
)	O
{	O
donelclchars	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
togdebug	function
(	O
void	O
)	O
{	O
if	O
(	O
net	int
>	O
0	int
&&	O
(	O
SetSockOpt	function
(	O
net	int
,	O
SOL_SOCKET	int
,	O
SO_DEBUG	int
,	O
debug	int
)	O
)	O
<	O
0	int
)	O
{	O
perror	function
(	O
"setsockopt (SO_DEBUG)"	pointer
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
togcrlf	function
(	O
void	O
)	O
{	O
if	O
(	O
crlf	int
)	O
{	O
printf	function
(	O
"Will send carriage returns as telnet <CR><LF>.\n"	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Will send carriage returns as telnet <CR><NUL>.\n"	pointer
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
binmode	int
;	O
static	O
int	O
togbinary	function
(	O
int	O
val	array
)	O
{	O
donebinarytoggle	int
=	O
1	int
;	O
if	O
(	O
val	array
>=	O
0	int
)	O
{	O
binmode	int
=	O
val	array
;	O
}	O
else	O
{	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_BINARY	int
)	O
&&	O
my_want_state_is_do	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
binmode	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
&&	O
my_want_state_is_dont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
binmode	int
=	O
0	int
;	O
}	O
val	array
=	O
binmode	int
?	O
0	int
:	O
1	int
;	O
}	O
if	O
(	O
val	array
==	O
1	int
)	O
{	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_BINARY	int
)	O
&&	O
my_want_state_is_do	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	function
(	O
"Already operating in binary mode with remote host.\n"	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Negotiating binary mode with remote host.\n"	pointer
)	O
;	O
tel_enter_binary	function
(	O
3	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
&&	O
my_want_state_is_dont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	function
(	O
"Already in network ascii mode with remote host.\n"	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Negotiating network ascii mode with remote host.\n"	pointer
)	O
;	O
tel_leave_binary	function
(	O
3	int
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
togrbinary	function
(	O
int	O
val	array
)	O
{	O
donebinarytoggle	int
=	O
1	int
;	O
if	O
(	O
val	array
==	O
-	O
1	int
)	O
val	array
=	O
my_want_state_is_do	O
(	O
TELOPT_BINARY	int
)	O
?	O
0	int
:	O
1	int
;	O
if	O
(	O
val	array
==	O
1	int
)	O
{	O
if	O
(	O
my_want_state_is_do	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	function
(	O
"Already receiving in binary mode.\n"	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Negotiating binary mode on input.\n"	pointer
)	O
;	O
tel_enter_binary	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
my_want_state_is_dont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	function
(	O
"Already receiving in network ascii mode.\n"	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Negotiating network ascii mode on input.\n"	pointer
)	O
;	O
tel_leave_binary	function
(	O
1	int
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
togxbinary	function
(	O
int	O
val	array
)	O
{	O
donebinarytoggle	int
=	O
1	int
;	O
if	O
(	O
val	array
==	O
-	O
1	int
)	O
val	array
=	O
my_want_state_is_will	O
(	O
TELOPT_BINARY	int
)	O
?	O
0	int
:	O
1	int
;	O
if	O
(	O
val	array
==	O
1	int
)	O
{	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	function
(	O
"Already transmitting in binary mode.\n"	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Negotiating binary mode on output.\n"	pointer
)	O
;	O
tel_enter_binary	function
(	O
2	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_BINARY	int
)	O
)	O
{	O
printf	function
(	O
"Already transmitting in network ascii mode.\n"	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Negotiating network ascii mode on output.\n"	pointer
)	O
;	O
tel_leave_binary	function
(	O
2	int
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
togglehelp	function
(	O
void	O
)	O
;	O
struct	O
togglelist	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
help	pointer
;	O
int	O
(	O
*	O
handler	pointer
)	O
(	O
)	O
;	O
int	O
*	O
variable	pointer
;	O
const	O
char	O
*	O
actionexplanation	pointer
;	O
}	O
;	O
static	O
struct	O
togglelist	struct
Togglelist	array
[	O
]	O
=	O
{	O
{	O
"autoflush"	pointer
,	O
"flushing of output when sending interrupt characters"	pointer
,	O
0	int
,	O
&	O
autoflush	int
,	O
"flush output when sending interrupt characters"	pointer
}	O
,	O
{	O
"autosynch"	pointer
,	O
"automatic sending of interrupt characters in urgent mode"	pointer
,	O
0	int
,	O
&	O
autosynch	int
,	O
"send interrupt characters in urgent mode"	pointer
}	O
,	O
{	O
"skiprc"	pointer
,	O
"don't read ~/.telnetrc file"	pointer
,	O
0	int
,	O
&	O
skiprc	int
,	O
"skip reading of ~/.telnetrc file"	pointer
}	O
,	O
{	O
"binary"	pointer
,	O
"sending and receiving of binary data"	pointer
,	O
togbinary	function
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"inbinary"	pointer
,	O
"receiving of binary data"	pointer
,	O
togrbinary	function
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"outbinary"	pointer
,	O
"sending of binary data"	pointer
,	O
togxbinary	function
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"crlf"	pointer
,	O
"sending carriage returns as telnet <CR><LF>"	pointer
,	O
togcrlf	function
,	O
&	O
crlf	int
,	O
0	int
}	O
,	O
{	O
"crmod"	pointer
,	O
"mapping of received carriage returns"	pointer
,	O
0	int
,	O
&	O
crmod	int
,	O
"map carriage return on output"	pointer
}	O
,	O
{	O
"localchars"	pointer
,	O
"local recognition of certain control characters"	pointer
,	O
lclchars	function
,	O
&	O
localchars	int
,	O
"recognize certain control characters"	pointer
}	O
,	O
{	O
" "	pointer
,	O
""	pointer
,	O
0	int
}	O
,	O
{	O
"debug"	pointer
,	O
"debugging"	pointer
,	O
togdebug	function
,	O
&	O
debug	int
,	O
"turn on socket level debugging"	pointer
}	O
,	O
{	O
"netdata"	pointer
,	O
"printing of hexadecimal network data (debugging)"	pointer
,	O
0	int
,	O
&	O
netdata	int
,	O
"print hexadecimal representation of network traffic"	pointer
}	O
,	O
{	O
"prettydump"	pointer
,	O
"output of \"netdata\" to user readable format (debugging)"	pointer
,	O
0	int
,	O
&	O
prettydump	int
,	O
"print user readable output for \"netdata\""	pointer
}	O
,	O
{	O
"options"	pointer
,	O
"viewing of options processing (debugging)"	pointer
,	O
0	int
,	O
&	O
showoptions	int
,	O
"show option processing"	pointer
}	O
,	O
{	O
"termdata"	pointer
,	O
"(debugging) toggle printing of hexadecimal terminal data"	pointer
,	O
0	int
,	O
&	O
termdata	int
,	O
"print hexadecimal representation of terminal traffic"	pointer
}	O
,	O
{	O
"?"	pointer
,	O
0	int
,	O
togglehelp	function
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
togglehelp	function
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
int	O
togglehelp	function
(	O
void	O
)	O
{	O
struct	O
togglelist	struct
*	O
c	int
;	O
for	O
(	O
c	int
=	O
Togglelist	array
;	O
c	int
->	O
name	pointer
;	O
c	int
++	O
)	O
{	O
if	O
(	O
c	int
->	O
help	pointer
)	O
{	O
if	O
(	O
*	O
c	int
->	O
help	pointer
)	O
printf	function
(	O
"%-15s toggle %s\n"	pointer
,	O
c	int
->	O
name	pointer
,	O
c	int
->	O
help	pointer
)	O
;	O
else	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
"%-15s %s\n"	pointer
,	O
"?"	pointer
,	O
"display help information"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
settogglehelp	function
(	O
int	O
set	int
)	O
{	O
struct	O
togglelist	struct
*	O
c	int
;	O
for	O
(	O
c	int
=	O
Togglelist	array
;	O
c	int
->	O
name	pointer
;	O
c	int
++	O
)	O
{	O
if	O
(	O
c	int
->	O
help	pointer
)	O
{	O
if	O
(	O
*	O
c	int
->	O
help	pointer
)	O
printf	function
(	O
"%-15s %s %s\n"	pointer
,	O
c	int
->	O
name	pointer
,	O
set	int
?	O
"enable"	pointer
:	O
"disable"	pointer
,	O
c	int
->	O
help	pointer
)	O
;	O
else	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
int	O
toggle	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
retval	int
=	O
1	int
;	O
char	O
*	O
name	pointer
;	O
struct	O
togglelist	struct
*	O
c	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Need an argument to 'toggle' command.  'toggle ?' for help.\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
argc	int
--	O
;	O
argv	pointer
++	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
name	pointer
=	O
*	O
argv	pointer
++	O
;	O
c	int
=	O
GETTOGGLE	O
(	O
name	pointer
)	O
;	O
if	O
(	O
Ambiguous	function
(	O
c	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': ambiguous argument ('toggle ?' for help).\n"	pointer
,	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': unknown argument ('toggle ?' for help).\n"	pointer
,	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
c	int
->	O
variable	pointer
)	O
{	O
*	O
c	int
->	O
variable	pointer
=	O
!	O
*	O
c	int
->	O
variable	pointer
;	O
if	O
(	O
c	int
->	O
actionexplanation	pointer
)	O
{	O
printf	function
(	O
"%s %s.\n"	pointer
,	O
*	O
c	int
->	O
variable	pointer
?	O
"Will"	pointer
:	O
"Won't"	pointer
,	O
c	int
->	O
actionexplanation	pointer
)	O
;	O
}	O
}	O
if	O
(	O
c	int
->	O
handler	pointer
)	O
{	O
retval	int
&=	O
(	O
*	O
c	int
->	O
handler	pointer
)	O
(	O
-	O
1	int
)	O
;	O
}	O
}	O
}	O
return	O
retval	int
;	O
}	O
struct	O
termio	struct
new_tc	struct
=	O
{	O
0	int
}	O
;	O
struct	O
setlist	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
help	pointer
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
)	O
;	O
cc_t	char
*	O
charp	pointer
;	O
}	O
;	O
static	O
struct	O
setlist	struct
Setlist	array
[	O
]	O
=	O
{	O
{	O
"echo"	pointer
,	O
"character to toggle local echoing on/off"	pointer
,	O
0	int
,	O
&	O
echoc	char
}	O
,	O
{	O
"escape"	pointer
,	O
"character to escape back to telnet command mode"	pointer
,	O
0	int
,	O
&	O
escape	char
}	O
,	O
{	O
"rlogin"	pointer
,	O
"rlogin escape character"	pointer
,	O
0	int
,	O
&	O
rlogin	char
}	O
,	O
{	O
"tracefile"	pointer
,	O
"file to write trace information to"	pointer
,	O
SetNetTrace	function
,	O
(	O
cc_t	char
*	O
)	O
NetTraceFile	array
}	O
,	O
{	O
" "	pointer
,	O
""	pointer
}	O
,	O
{	O
" "	pointer
,	O
"The following need 'localchars' to be toggled true"	pointer
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"flushoutput"	pointer
,	O
"character to cause an Abort Output"	pointer
,	O
0	int
,	O
termFlushCharp	O
}	O
,	O
{	O
"interrupt"	pointer
,	O
"character to cause an Interrupt Process"	pointer
,	O
0	int
,	O
termIntCharp	O
}	O
,	O
{	O
"quit"	pointer
,	O
"character to cause an Abort process"	pointer
,	O
0	int
,	O
termQuitCharp	O
}	O
,	O
{	O
"eof"	pointer
,	O
"character to cause an EOF "	pointer
,	O
0	int
,	O
termEofCharp	O
}	O
,	O
{	O
" "	pointer
,	O
""	pointer
}	O
,	O
{	O
" "	pointer
,	O
"The following are for local editing in linemode"	pointer
,	O
0	int
,	O
0	int
}	O
,	O
{	O
"erase"	pointer
,	O
"character to use to erase a character"	pointer
,	O
0	int
,	O
termEraseCharp	O
}	O
,	O
{	O
"kill"	pointer
,	O
"character to use to erase a line"	pointer
,	O
0	int
,	O
termKillCharp	O
}	O
,	O
{	O
"lnext"	pointer
,	O
"character to use for literal next"	pointer
,	O
0	int
,	O
termLiteralNextCharp	O
}	O
,	O
{	O
"susp"	pointer
,	O
"character to cause a Suspend Process"	pointer
,	O
0	int
,	O
termSuspCharp	O
}	O
,	O
{	O
"reprint"	pointer
,	O
"character to use for line reprint"	pointer
,	O
0	int
,	O
termRprntCharp	O
}	O
,	O
{	O
"worderase"	pointer
,	O
"character to use to erase a word"	pointer
,	O
0	int
,	O
termWerasCharp	O
}	O
,	O
{	O
"start"	pointer
,	O
"character to use for XON"	pointer
,	O
0	int
,	O
termStartCharp	O
}	O
,	O
{	O
"stop"	pointer
,	O
"character to use for XOFF"	pointer
,	O
0	int
,	O
termStopCharp	O
}	O
,	O
{	O
"forw1"	pointer
,	O
"alternate end of line character"	pointer
,	O
0	int
,	O
termForw1Charp	O
}	O
,	O
{	O
"forw2"	pointer
,	O
"alternate end of line character"	pointer
,	O
0	int
,	O
termForw2Charp	O
}	O
,	O
{	O
"ayt"	pointer
,	O
"alternate AYT character"	pointer
,	O
0	int
,	O
termAytCharp	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
struct	O
setlist	struct
*	O
getset	function
(	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
struct	O
setlist	struct
*	O
)	O
genget	function
(	O
name	pointer
,	O
(	O
char	O
*	O
*	O
)	O
Setlist	array
,	O
sizeof	O
(	O
struct	O
setlist	struct
)	O
)	O
;	O
}	O
void	O
set_escape_char	function
(	O
char	O
*	O
s	long
)	O
{	O
if	O
(	O
rlogin	char
!=	O
_POSIX_VDISABLE	char
)	O
{	O
rlogin	char
=	O
(	O
s	long
&&	O
*	O
s	long
)	O
?	O
special	function
(	O
s	long
)	O
:	O
_POSIX_VDISABLE	char
;	O
printf	function
(	O
"Telnet rlogin escape character is '%s'.\n"	pointer
,	O
control	function
(	O
rlogin	char
)	O
)	O
;	O
}	O
else	O
{	O
escape	char
=	O
(	O
s	long
&&	O
*	O
s	long
)	O
?	O
special	function
(	O
s	long
)	O
:	O
_POSIX_VDISABLE	char
;	O
printf	function
(	O
"Telnet escape character is '%s'.\n"	pointer
,	O
control	function
(	O
escape	char
)	O
)	O
;	O
}	O
}	O
static	O
int	O
setcmd	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
value	int
;	O
struct	O
setlist	struct
*	O
ct	pointer
;	O
struct	O
togglelist	struct
*	O
c	int
;	O
if	O
(	O
argc	int
<	O
2	int
||	O
argc	int
>	O
3	int
)	O
{	O
printf	function
(	O
"Format is 'set Name Value'\n'set ?' for help.\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
argc	int
==	O
2	int
)	O
&&	O
(	O
isprefix	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"?"	pointer
)	O
||	O
isprefix	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"help"	pointer
)	O
)	O
)	O
{	O
for	O
(	O
ct	pointer
=	O
Setlist	array
;	O
ct	pointer
->	O
name	pointer
;	O
ct	pointer
++	O
)	O
printf	function
(	O
"%-15s %s\n"	pointer
,	O
ct	pointer
->	O
name	pointer
,	O
ct	pointer
->	O
help	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
settogglehelp	function
(	O
1	int
)	O
;	O
printf	function
(	O
"%-15s %s\n"	pointer
,	O
"?"	pointer
,	O
"display help information"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
ct	pointer
=	O
getset	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
ct	pointer
==	O
0	int
)	O
{	O
c	int
=	O
GETTOGGLE	O
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': unknown argument ('set ?' for help).\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
Ambiguous	function
(	O
c	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': ambiguous argument ('set ?' for help).\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	int
->	O
variable	pointer
)	O
{	O
if	O
(	O
(	O
argc	int
==	O
2	int
)	O
||	O
(	O
strcmp	function
(	O
"on"	pointer
,	O
argv	pointer
[	O
2	int
]	O
)	O
==	O
0	int
)	O
)	O
*	O
c	int
->	O
variable	pointer
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
"off"	pointer
,	O
argv	pointer
[	O
2	int
]	O
)	O
==	O
0	int
)	O
*	O
c	int
->	O
variable	pointer
=	O
0	int
;	O
else	O
{	O
printf	function
(	O
"Format is 'set togglename [on|off]'\n'set ?' for help.\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	int
->	O
actionexplanation	pointer
)	O
{	O
printf	function
(	O
"%s %s.\n"	pointer
,	O
*	O
c	int
->	O
variable	pointer
?	O
"Will"	pointer
:	O
"Won't"	pointer
,	O
c	int
->	O
actionexplanation	pointer
)	O
;	O
}	O
}	O
if	O
(	O
c	int
->	O
handler	pointer
)	O
(	O
*	O
c	int
->	O
handler	pointer
)	O
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
argc	int
!=	O
3	int
)	O
{	O
printf	function
(	O
"Format is 'set Name Value'\n'set ?' for help.\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
Ambiguous	function
(	O
ct	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': ambiguous argument ('set ?' for help).\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
ct	pointer
->	O
handler	pointer
)	O
{	O
(	O
*	O
ct	pointer
->	O
handler	pointer
)	O
(	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
printf	function
(	O
"%s set to \"%s\".\n"	pointer
,	O
ct	pointer
->	O
name	pointer
,	O
(	O
char	O
*	O
)	O
ct	pointer
->	O
charp	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
strcmp	function
(	O
"off"	pointer
,	O
argv	pointer
[	O
2	int
]	O
)	O
)	O
{	O
value	int
=	O
special	function
(	O
argv	pointer
[	O
2	int
]	O
)	O
;	O
}	O
else	O
{	O
value	int
=	O
_POSIX_VDISABLE	char
;	O
}	O
*	O
(	O
ct	pointer
->	O
charp	pointer
)	O
=	O
(	O
cc_t	char
)	O
value	int
;	O
printf	function
(	O
"%s character is '%s'.\n"	pointer
,	O
ct	pointer
->	O
name	pointer
,	O
control	function
(	O
*	O
(	O
ct	pointer
->	O
charp	pointer
)	O
)	O
)	O
;	O
}	O
slc_check	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
unsetcmd	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
struct	O
setlist	struct
*	O
ct	pointer
;	O
struct	O
togglelist	struct
*	O
c	int
;	O
register	O
char	O
*	O
name	pointer
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Need an argument to 'unset' command.  'unset ?' for help.\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
isprefix	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"?"	pointer
)	O
||	O
isprefix	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"help"	pointer
)	O
)	O
{	O
for	O
(	O
ct	pointer
=	O
Setlist	array
;	O
ct	pointer
->	O
name	pointer
;	O
ct	pointer
++	O
)	O
printf	function
(	O
"%-15s %s\n"	pointer
,	O
ct	pointer
->	O
name	pointer
,	O
ct	pointer
->	O
help	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
settogglehelp	function
(	O
0	int
)	O
;	O
printf	function
(	O
"%-15s %s\n"	pointer
,	O
"?"	pointer
,	O
"display help information"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
argc	int
--	O
;	O
argv	pointer
++	O
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
name	pointer
=	O
*	O
argv	pointer
++	O
;	O
ct	pointer
=	O
getset	function
(	O
name	pointer
)	O
;	O
if	O
(	O
ct	pointer
==	O
0	int
)	O
{	O
c	int
=	O
GETTOGGLE	O
(	O
name	pointer
)	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': unknown argument ('unset ?' for help).\n"	pointer
,	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
Ambiguous	function
(	O
c	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': ambiguous argument ('unset ?' for help).\n"	pointer
,	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	int
->	O
variable	pointer
)	O
{	O
*	O
c	int
->	O
variable	pointer
=	O
0	int
;	O
if	O
(	O
c	int
->	O
actionexplanation	pointer
)	O
{	O
printf	function
(	O
"%s %s.\n"	pointer
,	O
*	O
c	int
->	O
variable	pointer
?	O
"Will"	pointer
:	O
"Won't"	pointer
,	O
c	int
->	O
actionexplanation	pointer
)	O
;	O
}	O
}	O
if	O
(	O
c	int
->	O
handler	pointer
)	O
(	O
*	O
c	int
->	O
handler	pointer
)	O
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
Ambiguous	function
(	O
ct	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': ambiguous argument ('unset ?' for help).\n"	pointer
,	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
ct	pointer
->	O
handler	pointer
)	O
{	O
(	O
*	O
ct	pointer
->	O
handler	pointer
)	O
(	O
0	int
)	O
;	O
printf	function
(	O
"%s reset to \"%s\".\n"	pointer
,	O
ct	pointer
->	O
name	pointer
,	O
(	O
char	O
*	O
)	O
ct	pointer
->	O
charp	pointer
)	O
;	O
}	O
else	O
{	O
*	O
(	O
ct	pointer
->	O
charp	pointer
)	O
=	O
_POSIX_VDISABLE	char
;	O
printf	function
(	O
"%s character is '%s'.\n"	pointer
,	O
ct	pointer
->	O
name	pointer
,	O
control	function
(	O
*	O
(	O
ct	pointer
->	O
charp	pointer
)	O
)	O
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
extern	O
int	O
kludgelinemode	int
;	O
static	O
int	O
dokludgemode	function
(	O
void	O
)	O
{	O
kludgelinemode	int
=	O
1	int
;	O
send_wont	function
(	O
TELOPT_LINEMODE	int
,	O
1	int
)	O
;	O
send_dont	function
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
send_dont	function
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dolinemode	function
(	O
void	O
)	O
{	O
if	O
(	O
kludgelinemode	int
)	O
send_dont	function
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
send_will	function
(	O
TELOPT_LINEMODE	int
,	O
1	int
)	O
;	O
send_dont	function
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
docharmode	function
(	O
void	O
)	O
{	O
if	O
(	O
kludgelinemode	int
)	O
send_do	function
(	O
TELOPT_SGA	int
,	O
1	int
)	O
;	O
else	O
send_wont	function
(	O
TELOPT_LINEMODE	int
,	O
1	int
)	O
;	O
send_do	function
(	O
TELOPT_ECHO	int
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
dolmmode	function
(	O
int	O
bit	int
,	O
int	O
on	int
)	O
{	O
unsigned	O
char	O
c	int
;	O
extern	O
int	O
linemode	int
;	O
if	O
(	O
my_want_state_is_wont	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
{	O
printf	function
(	O
"?Need to have LINEMODE option enabled first.\n"	pointer
)	O
;	O
printf	function
(	O
"'mode ?' for help.\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
on	int
)	O
c	int
=	O
(	O
linemode	int
|	O
bit	int
)	O
;	O
else	O
c	int
=	O
(	O
linemode	int
&	O
~	O
bit	int
)	O
;	O
lm_mode	function
(	O
&	O
c	int
,	O
1	int
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
int	O
set_mode	function
(	O
int	O
bit	int
)	O
{	O
return	O
dolmmode	function
(	O
bit	int
,	O
1	int
)	O
;	O
}	O
int	O
clear_mode	function
(	O
int	O
bit	int
)	O
{	O
return	O
dolmmode	function
(	O
bit	int
,	O
0	int
)	O
;	O
}	O
struct	O
modelist	array
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
help	pointer
;	O
int	O
(	O
*	O
handler	pointer
)	O
(	O
)	O
;	O
int	O
needconnect	int
;	O
int	O
arg1	int
;	O
}	O
;	O
extern	O
int	O
modehelp	function
(	O
void	O
)	O
;	O
static	O
struct	O
modelist	array
ModeList	array
[	O
]	O
=	O
{	O
{	O
"character"	pointer
,	O
"Disable LINEMODE option"	pointer
,	O
docharmode	function
,	O
1	int
}	O
,	O
{	O
""	pointer
,	O
"(or disable obsolete line-by-line mode)"	pointer
,	O
0	int
}	O
,	O
{	O
"line"	pointer
,	O
"Enable LINEMODE option"	pointer
,	O
dolinemode	function
,	O
1	int
}	O
,	O
{	O
""	pointer
,	O
"(or enable obsolete line-by-line mode)"	pointer
,	O
0	int
}	O
,	O
{	O
""	pointer
,	O
""	pointer
,	O
0	int
}	O
,	O
{	O
""	pointer
,	O
"These require the LINEMODE option to be enabled"	pointer
,	O
0	int
}	O
,	O
{	O
"isig"	pointer
,	O
"Enable signal trapping"	pointer
,	O
set_mode	function
,	O
1	int
,	O
MODE_TRAPSIG	int
}	O
,	O
{	O
"+isig"	pointer
,	O
0	int
,	O
set_mode	function
,	O
1	int
,	O
MODE_TRAPSIG	int
}	O
,	O
{	O
"-isig"	pointer
,	O
"Disable signal trapping"	pointer
,	O
clear_mode	function
,	O
1	int
,	O
MODE_TRAPSIG	int
}	O
,	O
{	O
"edit"	pointer
,	O
"Enable character editing"	pointer
,	O
set_mode	function
,	O
1	int
,	O
MODE_EDIT	int
}	O
,	O
{	O
"+edit"	pointer
,	O
0	int
,	O
set_mode	function
,	O
1	int
,	O
MODE_EDIT	int
}	O
,	O
{	O
"-edit"	pointer
,	O
"Disable character editing"	pointer
,	O
clear_mode	function
,	O
1	int
,	O
MODE_EDIT	int
}	O
,	O
{	O
"softtabs"	pointer
,	O
"Enable tab expansion"	pointer
,	O
set_mode	function
,	O
1	int
,	O
MODE_SOFT_TAB	int
}	O
,	O
{	O
"+softtabs"	pointer
,	O
0	int
,	O
set_mode	function
,	O
1	int
,	O
MODE_SOFT_TAB	int
}	O
,	O
{	O
"-softtabs"	pointer
,	O
"Disable character editing"	pointer
,	O
clear_mode	function
,	O
1	int
,	O
MODE_SOFT_TAB	int
}	O
,	O
{	O
"litecho"	pointer
,	O
"Enable literal character echo"	pointer
,	O
set_mode	function
,	O
1	int
,	O
MODE_LIT_ECHO	int
}	O
,	O
{	O
"+litecho"	pointer
,	O
0	int
,	O
set_mode	function
,	O
1	int
,	O
MODE_LIT_ECHO	int
}	O
,	O
{	O
"-litecho"	pointer
,	O
"Disable literal character echo"	pointer
,	O
clear_mode	function
,	O
1	int
,	O
MODE_LIT_ECHO	int
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
modehelp	function
,	O
0	int
}	O
,	O
{	O
"kludgeline"	pointer
,	O
0	int
,	O
dokludgemode	function
,	O
1	int
}	O
,	O
{	O
""	pointer
,	O
""	pointer
,	O
0	int
}	O
,	O
{	O
"?"	pointer
,	O
"Print help information"	pointer
,	O
modehelp	function
,	O
0	int
}	O
,	O
{	O
0	int
}	O
,	O
}	O
;	O
int	O
modehelp	function
(	O
void	O
)	O
{	O
struct	O
modelist	array
*	O
mt	pointer
;	O
printf	function
(	O
"format is:  'mode Mode', where 'Mode' is one of:\n\n"	pointer
)	O
;	O
for	O
(	O
mt	pointer
=	O
ModeList	array
;	O
mt	pointer
->	O
name	pointer
;	O
mt	pointer
++	O
)	O
{	O
if	O
(	O
mt	pointer
->	O
help	pointer
)	O
{	O
if	O
(	O
*	O
mt	pointer
->	O
help	pointer
)	O
printf	function
(	O
"%-15s %s\n"	pointer
,	O
mt	pointer
->	O
name	pointer
,	O
mt	pointer
->	O
help	pointer
)	O
;	O
else	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
modecmd	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
struct	O
modelist	array
*	O
mt	pointer
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
printf	function
(	O
"'mode' command requires an argument\n"	pointer
)	O
;	O
printf	function
(	O
"'mode ?' for help.\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
mt	pointer
=	O
GETMODECMD	O
(	O
argv	pointer
[	O
1	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Unknown mode '%s' ('mode ?' for help).\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
Ambiguous	function
(	O
mt	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Ambiguous mode '%s' ('mode ?' for help).\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
mt	pointer
->	O
needconnect	int
&&	O
!	O
connected	int
)	O
{	O
printf	function
(	O
"?Need to be connected first.\n"	pointer
)	O
;	O
printf	function
(	O
"'mode ?' for help.\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
mt	pointer
->	O
handler	pointer
)	O
{	O
return	O
(	O
*	O
mt	pointer
->	O
handler	pointer
)	O
(	O
mt	pointer
->	O
arg1	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
display	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
struct	O
togglelist	struct
*	O
tl	pointer
;	O
struct	O
setlist	struct
*	O
sl	pointer
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
for	O
(	O
tl	pointer
=	O
Togglelist	array
;	O
tl	pointer
->	O
name	pointer
;	O
tl	pointer
++	O
)	O
{	O
dotog	O
(	O
tl	pointer
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
for	O
(	O
sl	pointer
=	O
Setlist	array
;	O
sl	pointer
->	O
name	pointer
;	O
sl	pointer
++	O
)	O
{	O
doset	O
(	O
sl	pointer
)	O
;	O
}	O
}	O
else	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
sl	pointer
=	O
getset	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
tl	pointer
=	O
GETTOGGLE	O
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
Ambiguous	function
(	O
sl	pointer
)	O
||	O
Ambiguous	function
(	O
tl	pointer
)	O
)	O
{	O
printf	function
(	O
"?Ambiguous argument '%s'.\n"	pointer
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
sl	pointer
&&	O
!	O
tl	pointer
)	O
{	O
printf	function
(	O
"?Unknown argument '%s'.\n"	pointer
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
tl	pointer
)	O
{	O
dotog	O
(	O
tl	pointer
)	O
;	O
}	O
if	O
(	O
sl	pointer
)	O
{	O
doset	O
(	O
sl	pointer
)	O
;	O
}	O
}	O
}	O
}	O
optionstatus	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
setescape	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
register	O
char	O
*	O
arg	pointer
;	O
char	O
buf	pointer
[	O
50	int
]	O
;	O
printf	function
(	O
"Deprecated usage - please use 'set escape%s%s' in the future.\n"	pointer
,	O
(	O
argc	int
>	O
2	int
)	O
?	O
" "	pointer
:	O
""	pointer
,	O
(	O
argc	int
>	O
2	int
)	O
?	O
argv	pointer
[	O
1	int
]	O
:	O
""	pointer
)	O
;	O
if	O
(	O
argc	int
>	O
2	int
)	O
arg	pointer
=	O
argv	pointer
[	O
1	int
]	O
;	O
else	O
{	O
printf	function
(	O
"new escape character: "	pointer
)	O
;	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
stdin	pointer
)	O
;	O
arg	pointer
=	O
buf	pointer
;	O
}	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
escape	char
=	O
arg	pointer
[	O
0	int
]	O
;	O
if	O
(	O
!	O
In3270	int
)	O
{	O
printf	function
(	O
"Escape character is '%s'.\n"	pointer
,	O
control	function
(	O
escape	char
)	O
)	O
;	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
togcrmod	function
(	O
void	O
)	O
{	O
crmod	int
=	O
!	O
crmod	int
;	O
printf	function
(	O
"Deprecated usage - please use 'toggle crmod' in the future.\n"	pointer
)	O
;	O
printf	function
(	O
"%s map carriage return on output.\n"	pointer
,	O
crmod	int
?	O
"Will"	pointer
:	O
"Won't"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
return	O
1	int
;	O
}	O
int	O
suspend	function
(	O
void	O
)	O
{	O
setcommandmode	function
(	O
)	O
;	O
{	O
long	O
oldrows	long
,	O
oldcols	long
,	O
newrows	long
,	O
newcols	long
,	O
err	long
;	O
err	long
=	O
(	O
TerminalWindowSize	function
(	O
&	O
oldrows	long
,	O
&	O
oldcols	long
)	O
==	O
0	int
)	O
?	O
1	int
:	O
0	int
;	O
kill	function
(	O
0	int
,	O
SIGTSTP	int
)	O
;	O
if	O
(	O
TerminalWindowSize	function
(	O
&	O
newrows	long
,	O
&	O
newcols	long
)	O
&&	O
connected	int
&&	O
(	O
err	long
||	O
(	O
(	O
oldrows	long
!=	O
newrows	long
)	O
||	O
(	O
oldcols	long
!=	O
newcols	long
)	O
)	O
)	O
)	O
{	O
sendnaws	function
(	O
)	O
;	O
}	O
}	O
TerminalSaveState	function
(	O
)	O
;	O
setconnmode	function
(	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
int	O
shell	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
long	O
oldrows	long
,	O
oldcols	long
,	O
newrows	long
,	O
newcols	long
,	O
err	long
;	O
setcommandmode	function
(	O
)	O
;	O
err	long
=	O
(	O
TerminalWindowSize	function
(	O
&	O
oldrows	long
,	O
&	O
oldcols	long
)	O
==	O
0	int
)	O
?	O
1	int
:	O
0	int
;	O
switch	O
(	O
vfork	function
(	O
)	O
)	O
{	O
case	O
-	O
1	int
:	O
perror	function
(	O
"Fork failed\n"	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
{	O
register	O
char	O
*	O
shellp	pointer
,	O
*	O
shellname	pointer
;	O
extern	O
char	O
*	O
strrchr	function
(	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
shellp	pointer
=	O
getenv	function
(	O
"SHELL"	pointer
)	O
;	O
if	O
(	O
shellp	pointer
==	O
NULL	O
)	O
shellp	pointer
=	O
"/bin/sh"	pointer
;	O
if	O
(	O
(	O
shellname	pointer
=	O
strrchr	function
(	O
shellp	pointer
,	O
'/'	O
)	O
)	O
==	O
0	int
)	O
shellname	pointer
=	O
shellp	pointer
;	O
else	O
shellname	pointer
++	O
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
execl	function
(	O
shellp	pointer
,	O
shellname	pointer
,	O
"-c"	pointer
,	O
&	O
saveline	array
[	O
1	int
]	O
,	O
NULL	O
)	O
;	O
else	O
execl	function
(	O
shellp	pointer
,	O
shellname	pointer
,	O
NULL	O
)	O
;	O
perror	function
(	O
"Execl"	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
default	O
:	O
wait	function
(	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
TerminalWindowSize	function
(	O
&	O
newrows	long
,	O
&	O
newcols	long
)	O
&&	O
connected	int
&&	O
(	O
err	long
||	O
(	O
(	O
oldrows	long
!=	O
newrows	long
)	O
||	O
(	O
oldcols	long
!=	O
newcols	long
)	O
)	O
)	O
)	O
{	O
sendnaws	function
(	O
)	O
;	O
}	O
break	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
bye	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
extern	O
int	O
resettermname	int
;	O
if	O
(	O
connected	int
)	O
{	O
shutdown	function
(	O
net	int
,	O
2	int
)	O
;	O
printf	function
(	O
"Connection closed.\n"	pointer
)	O
;	O
NetClose	function
(	O
net	int
)	O
;	O
connected	int
=	O
0	int
;	O
resettermname	int
=	O
1	int
;	O
tninit	function
(	O
)	O
;	O
}	O
if	O
(	O
(	O
argc	int
!=	O
2	int
)	O
||	O
(	O
strcmp	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"fromquit"	pointer
)	O
!=	O
0	int
)	O
)	O
{	O
longjmp	function
(	O
toplevel	array
,	O
1	int
)	O
;	O
}	O
return	O
1	int
;	O
}	O
int	O
quit	function
(	O
void	O
)	O
{	O
call	function
(	O
bye	function
,	O
"bye"	pointer
,	O
"fromquit"	pointer
,	O
0	int
)	O
;	O
Exit	function
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
logout	function
(	O
void	O
)	O
{	O
send_do	function
(	O
TELOPT_LOGOUT	int
,	O
1	int
)	O
;	O
netflush	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
struct	O
slclist	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
help	pointer
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
)	O
;	O
int	O
arg	pointer
;	O
}	O
;	O
static	O
void	O
slc_help	function
(	O
void	O
)	O
;	O
struct	O
slclist	struct
SlcList	array
[	O
]	O
=	O
{	O
{	O
"export"	pointer
,	O
"Use local special character definitions"	pointer
,	O
slc_mode_export	function
,	O
0	int
}	O
,	O
{	O
"import"	pointer
,	O
"Use remote special character definitions"	pointer
,	O
slc_mode_import	function
,	O
1	int
}	O
,	O
{	O
"check"	pointer
,	O
"Verify remote special character definitions"	pointer
,	O
slc_mode_import	function
,	O
0	int
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
slc_help	function
,	O
0	int
}	O
,	O
{	O
"?"	pointer
,	O
"Print help information"	pointer
,	O
slc_help	function
,	O
0	int
}	O
,	O
{	O
0	int
}	O
,	O
}	O
;	O
static	O
void	O
slc_help	function
(	O
void	O
)	O
{	O
struct	O
slclist	struct
*	O
c	int
;	O
for	O
(	O
c	int
=	O
SlcList	array
;	O
c	int
->	O
name	pointer
;	O
c	int
++	O
)	O
{	O
if	O
(	O
c	int
->	O
help	pointer
)	O
{	O
if	O
(	O
*	O
c	int
->	O
help	pointer
)	O
printf	function
(	O
"%-15s %s\n"	pointer
,	O
c	int
->	O
name	pointer
,	O
c	int
->	O
help	pointer
)	O
;	O
else	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
struct	O
slclist	struct
*	O
getslc	function
(	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
struct	O
slclist	struct
*	O
)	O
genget	function
(	O
name	pointer
,	O
(	O
char	O
*	O
*	O
)	O
SlcList	array
,	O
sizeof	O
(	O
struct	O
slclist	struct
)	O
)	O
;	O
}	O
static	O
int	O
slccmd	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
struct	O
slclist	struct
*	O
c	int
;	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Need an argument to 'slc' command.  'slc ?' for help.\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
c	int
=	O
getslc	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': unknown argument ('slc ?' for help).\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
Ambiguous	function
(	O
c	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': ambiguous argument ('slc ?' for help).\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
(	O
*	O
c	int
->	O
handler	pointer
)	O
(	O
c	int
->	O
arg	pointer
)	O
;	O
slcstate	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
struct	O
envlist	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
help	pointer
;	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
)	O
;	O
int	O
narg	int
;	O
}	O
;	O
extern	O
struct	O
env_lst	struct
*	O
env_define	function
(	O
const	O
char	O
*	O
,	O
unsigned	O
char	O
*	O
)	O
;	O
extern	O
void	O
env_undefine	function
(	O
const	O
char	O
*	O
)	O
,	O
env_export	function
(	O
const	O
char	O
*	O
)	O
,	O
env_unexport	function
(	O
const	O
char	O
*	O
)	O
,	O
env_send	function
(	O
const	O
char	O
*	O
)	O
,	O
env_list	function
(	O
void	O
)	O
;	O
static	O
void	O
env_help	function
(	O
void	O
)	O
;	O
struct	O
envlist	struct
EnvList	array
[	O
]	O
=	O
{	O
{	O
"define"	pointer
,	O
"Define an environment variable"	pointer
,	O
(	O
void	O
(	O
*	O
)	O
(	O
)	O
)	O
env_define	function
,	O
2	int
}	O
,	O
{	O
"undefine"	pointer
,	O
"Undefine an environment variable"	pointer
,	O
env_undefine	function
,	O
1	int
}	O
,	O
{	O
"export"	pointer
,	O
"Mark an environment variable for automatic export"	pointer
,	O
env_export	function
,	O
1	int
}	O
,	O
{	O
"unexport"	pointer
,	O
"Don't mark an environment variable for automatic export"	pointer
,	O
env_unexport	function
,	O
1	int
}	O
,	O
{	O
"send"	pointer
,	O
"Send an environment variable"	pointer
,	O
env_send	function
,	O
1	int
}	O
,	O
{	O
"list"	pointer
,	O
"List the current environment variables"	pointer
,	O
env_list	function
,	O
0	int
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
env_help	function
,	O
0	int
}	O
,	O
{	O
"?"	pointer
,	O
"Print help information"	pointer
,	O
env_help	function
,	O
0	int
}	O
,	O
{	O
0	int
}	O
,	O
}	O
;	O
static	O
void	O
env_help	function
(	O
void	O
)	O
{	O
struct	O
envlist	struct
*	O
c	int
;	O
for	O
(	O
c	int
=	O
EnvList	array
;	O
c	int
->	O
name	pointer
;	O
c	int
++	O
)	O
{	O
if	O
(	O
c	int
->	O
help	pointer
)	O
{	O
if	O
(	O
*	O
c	int
->	O
help	pointer
)	O
printf	function
(	O
"%-15s %s\n"	pointer
,	O
c	int
->	O
name	pointer
,	O
c	int
->	O
help	pointer
)	O
;	O
else	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
struct	O
envlist	struct
*	O
getenvcmd	function
(	O
char	O
*	O
name	pointer
)	O
{	O
return	O
(	O
struct	O
envlist	struct
*	O
)	O
genget	function
(	O
name	pointer
,	O
(	O
char	O
*	O
*	O
)	O
EnvList	array
,	O
sizeof	O
(	O
struct	O
envlist	struct
)	O
)	O
;	O
}	O
int	O
env_cmd	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
struct	O
envlist	struct
*	O
c	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Need an argument to 'environ' command.  'environ ?' for help.\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
c	int
=	O
getenvcmd	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': unknown argument ('environ ?' for help).\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
Ambiguous	function
(	O
c	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"'%s': ambiguous argument ('environ ?' for help).\n"	pointer
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	int
->	O
narg	int
+	O
2	int
!=	O
argc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Need %s%d argument%s to 'environ %s' command.  'environ ?' for help.\n"	pointer
,	O
c	int
->	O
narg	int
<	O
argc	int
+	O
2	int
?	O
"only "	pointer
:	O
""	pointer
,	O
c	int
->	O
narg	int
,	O
c	int
->	O
narg	int
==	O
1	int
?	O
""	pointer
:	O
"s"	pointer
,	O
c	int
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
(	O
*	O
c	int
->	O
handler	pointer
)	O
(	O
argv	pointer
[	O
2	int
]	O
,	O
argv	pointer
[	O
3	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
struct	O
env_lst	struct
{	O
struct	O
env_lst	struct
*	O
next	pointer
;	O
struct	O
env_lst	struct
*	O
prev	pointer
;	O
unsigned	O
char	O
*	O
var	pointer
;	O
unsigned	O
char	O
*	O
value	int
;	O
int	O
export	int
;	O
int	O
welldefined	int
;	O
}	O
;	O
struct	O
env_lst	struct
envlisthead	struct
;	O
struct	O
env_lst	struct
*	O
env_find	function
(	O
const	O
char	O
*	O
var	pointer
)	O
{	O
register	O
struct	O
env_lst	struct
*	O
ep	pointer
;	O
for	O
(	O
ep	pointer
=	O
envlisthead	struct
.	O
next	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
(	O
char	O
*	O
)	O
ep	pointer
->	O
var	pointer
,	O
var	pointer
)	O
==	O
0	int
)	O
return	O
(	O
ep	pointer
)	O
;	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
void	O
env_init	function
(	O
void	O
)	O
{	O
extern	O
char	O
*	O
*	O
environ	pointer
;	O
register	O
char	O
*	O
*	O
epp	pointer
,	O
*	O
cp	pointer
;	O
register	O
struct	O
env_lst	struct
*	O
ep	pointer
;	O
extern	O
char	O
*	O
strchr	function
(	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
for	O
(	O
epp	pointer
=	O
environ	pointer
;	O
*	O
epp	pointer
;	O
epp	pointer
++	O
)	O
{	O
cp	pointer
=	O
strchr	function
(	O
*	O
epp	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
{	O
*	O
cp	pointer
=	O
'\0'	O
;	O
ep	pointer
=	O
env_define	function
(	O
*	O
epp	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
cp	pointer
+	O
1	int
)	O
;	O
ep	pointer
->	O
export	int
=	O
0	int
;	O
*	O
cp	pointer
=	O
'='	O
;	O
}	O
}	O
if	O
(	O
(	O
ep	pointer
=	O
env_find	function
(	O
"DISPLAY"	pointer
)	O
)	O
&&	O
(	O
(	O
*	O
ep	pointer
->	O
value	int
==	O
':'	O
)	O
||	O
(	O
strncmp	function
(	O
(	O
char	O
*	O
)	O
ep	pointer
->	O
value	int
,	O
"unix:"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
)	O
)	O
{	O
char	O
*	O
hostname	pointer
=	O
localhost	function
(	O
)	O
;	O
char	O
*	O
cp2	pointer
=	O
strchr	function
(	O
(	O
char	O
*	O
)	O
ep	pointer
->	O
value	int
,	O
':'	O
)	O
;	O
cp	pointer
=	O
malloc	function
(	O
strlen	function
(	O
hostname	pointer
)	O
+	O
strlen	function
(	O
cp2	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
cp	pointer
,	O
"%s%s"	pointer
,	O
hostname	pointer
,	O
cp2	pointer
)	O
;	O
free	function
(	O
ep	pointer
->	O
value	int
)	O
;	O
ep	pointer
->	O
value	int
=	O
(	O
unsigned	O
char	O
*	O
)	O
cp	pointer
;	O
free	function
(	O
hostname	pointer
)	O
;	O
}	O
if	O
(	O
(	O
env_find	function
(	O
"USER"	pointer
)	O
==	O
NULL	O
)	O
&&	O
(	O
ep	pointer
=	O
env_find	function
(	O
"LOGNAME"	pointer
)	O
)	O
)	O
{	O
env_define	function
(	O
"USER"	pointer
,	O
ep	pointer
->	O
value	int
)	O
;	O
env_unexport	function
(	O
"USER"	pointer
)	O
;	O
}	O
env_export	function
(	O
"DISPLAY"	pointer
)	O
;	O
env_export	function
(	O
"PRINTER"	pointer
)	O
;	O
}	O
struct	O
env_lst	struct
*	O
env_define	function
(	O
const	O
char	O
*	O
var	pointer
,	O
unsigned	O
char	O
*	O
value	int
)	O
{	O
register	O
struct	O
env_lst	struct
*	O
ep	pointer
=	O
env_find	function
(	O
var	pointer
)	O
;	O
if	O
(	O
ep	pointer
)	O
{	O
free	function
(	O
ep	pointer
->	O
var	pointer
)	O
;	O
free	function
(	O
ep	pointer
->	O
value	int
)	O
;	O
}	O
else	O
{	O
ep	pointer
=	O
(	O
struct	O
env_lst	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
env_lst	struct
)	O
)	O
;	O
ep	pointer
->	O
next	pointer
=	O
envlisthead	struct
.	O
next	pointer
;	O
envlisthead	struct
.	O
next	pointer
=	O
ep	pointer
;	O
ep	pointer
->	O
prev	pointer
=	O
&	O
envlisthead	struct
;	O
if	O
(	O
ep	pointer
->	O
next	pointer
)	O
ep	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
ep	pointer
;	O
}	O
ep	pointer
->	O
welldefined	int
=	O
opt_welldefined	function
(	O
(	O
char	O
*	O
)	O
var	pointer
)	O
;	O
ep	pointer
->	O
export	int
=	O
1	int
;	O
ep	pointer
->	O
var	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
strdup	function
(	O
(	O
char	O
*	O
)	O
var	pointer
)	O
;	O
ep	pointer
->	O
value	int
=	O
(	O
unsigned	O
char	O
*	O
)	O
strdup	function
(	O
(	O
char	O
*	O
)	O
value	int
)	O
;	O
return	O
(	O
ep	pointer
)	O
;	O
}	O
void	O
env_undefine	function
(	O
const	O
char	O
*	O
var	pointer
)	O
{	O
register	O
struct	O
env_lst	struct
*	O
ep	pointer
=	O
env_find	function
(	O
var	pointer
)	O
;	O
if	O
(	O
ep	pointer
)	O
{	O
ep	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
ep	pointer
->	O
next	pointer
;	O
if	O
(	O
ep	pointer
->	O
next	pointer
)	O
ep	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
ep	pointer
->	O
prev	pointer
;	O
free	function
(	O
ep	pointer
->	O
var	pointer
)	O
;	O
free	function
(	O
ep	pointer
->	O
value	int
)	O
;	O
free	function
(	O
ep	pointer
)	O
;	O
}	O
}	O
void	O
env_export	function
(	O
const	O
char	O
*	O
var	pointer
)	O
{	O
register	O
struct	O
env_lst	struct
*	O
ep	pointer
=	O
env_find	function
(	O
var	pointer
)	O
;	O
if	O
(	O
ep	pointer
)	O
ep	pointer
->	O
export	int
=	O
1	int
;	O
}	O
void	O
env_unexport	function
(	O
const	O
char	O
*	O
var	pointer
)	O
{	O
register	O
struct	O
env_lst	struct
*	O
ep	pointer
=	O
env_find	function
(	O
var	pointer
)	O
;	O
if	O
(	O
ep	pointer
)	O
ep	pointer
->	O
export	int
=	O
0	int
;	O
}	O
void	O
env_send	function
(	O
const	O
char	O
*	O
var	pointer
)	O
{	O
register	O
struct	O
env_lst	struct
*	O
ep	pointer
;	O
if	O
(	O
my_state_is_wont	O
(	O
TELOPT_NEW_ENVIRON	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot send '%s': Telnet ENVIRON option not enabled\n"	pointer
,	O
var	pointer
)	O
;	O
return	O
;	O
}	O
ep	pointer
=	O
env_find	function
(	O
var	pointer
)	O
;	O
if	O
(	O
ep	pointer
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot send '%s': variable not defined\n"	pointer
,	O
var	pointer
)	O
;	O
return	O
;	O
}	O
env_opt_start_info	function
(	O
)	O
;	O
env_opt_add	function
(	O
ep	pointer
->	O
var	pointer
)	O
;	O
env_opt_end	function
(	O
0	int
)	O
;	O
}	O
void	O
env_list	function
(	O
void	O
)	O
{	O
register	O
struct	O
env_lst	struct
*	O
ep	pointer
;	O
for	O
(	O
ep	pointer
=	O
envlisthead	struct
.	O
next	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
{	O
printf	function
(	O
"%c %-20s %s\n"	pointer
,	O
ep	pointer
->	O
export	int
?	O
'*'	O
:	O
' '	O
,	O
ep	pointer
->	O
var	pointer
,	O
ep	pointer
->	O
value	int
)	O
;	O
}	O
}	O
unsigned	O
char	O
*	O
env_default	function
(	O
int	O
init	int
,	O
int	O
welldefined	int
)	O
{	O
static	O
struct	O
env_lst	struct
*	O
nep	pointer
=	O
NULL	O
;	O
if	O
(	O
init	int
)	O
{	O
nep	pointer
=	O
&	O
envlisthead	struct
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
nep	pointer
)	O
{	O
while	O
(	O
(	O
nep	pointer
=	O
nep	pointer
->	O
next	pointer
)	O
)	O
{	O
if	O
(	O
nep	pointer
->	O
export	int
&&	O
(	O
nep	pointer
->	O
welldefined	int
==	O
welldefined	int
)	O
)	O
return	O
(	O
nep	pointer
->	O
var	pointer
)	O
;	O
}	O
}	O
return	O
(	O
NULL	O
)	O
;	O
}	O
unsigned	O
char	O
*	O
env_getvalue	function
(	O
const	O
char	O
*	O
var	pointer
)	O
{	O
register	O
struct	O
env_lst	struct
*	O
ep	pointer
=	O
env_find	function
(	O
var	pointer
)	O
;	O
if	O
(	O
ep	pointer
)	O
return	O
(	O
ep	pointer
->	O
value	int
)	O
;	O
return	O
(	O
NULL	O
)	O
;	O
}	O
static	O
int	O
status	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
if	O
(	O
connected	int
)	O
{	O
printf	function
(	O
"Connected to %s.\n"	pointer
,	O
hostname	pointer
)	O
;	O
if	O
(	O
(	O
argc	int
<	O
2	int
)	O
||	O
strcmp	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
"notmuch"	pointer
)	O
)	O
{	O
int	O
mode	int
=	O
getconnmode	function
(	O
)	O
;	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_LINEMODE	int
)	O
)	O
{	O
printf	function
(	O
"Operating with LINEMODE option\n"	pointer
)	O
;	O
printf	function
(	O
"%s line editing\n"	pointer
,	O
(	O
mode	int
&	O
MODE_EDIT	int
)	O
?	O
"Local"	pointer
:	O
"No"	pointer
)	O
;	O
printf	function
(	O
"%s catching of signals\n"	pointer
,	O
(	O
mode	int
&	O
MODE_TRAPSIG	int
)	O
?	O
"Local"	pointer
:	O
"No"	pointer
)	O
;	O
slcstate	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
kludgelinemode	int
&&	O
my_want_state_is_dont	O
(	O
TELOPT_SGA	int
)	O
)	O
{	O
printf	function
(	O
"Operating in obsolete linemode\n"	pointer
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"Operating in single character mode\n"	pointer
)	O
;	O
if	O
(	O
localchars	int
)	O
printf	function
(	O
"Catching signals locally\n"	pointer
)	O
;	O
}	O
printf	function
(	O
"%s character echo\n"	pointer
,	O
(	O
mode	int
&	O
MODE_ECHO	int
)	O
?	O
"Local"	pointer
:	O
"Remote"	pointer
)	O
;	O
if	O
(	O
my_want_state_is_will	O
(	O
TELOPT_LFLOW	int
)	O
)	O
printf	function
(	O
"%s flow control\n"	pointer
,	O
(	O
mode	int
&	O
MODE_FLOW	int
)	O
?	O
"Local"	pointer
:	O
"No"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
printf	function
(	O
"No connection.\n"	pointer
)	O
;	O
}	O
printf	function
(	O
"Escape character is '%s'.\n"	pointer
,	O
control	function
(	O
escape	char
)	O
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
cmdrc	function
(	O
char	O
*	O
m1	pointer
,	O
char	O
*	O
m2	pointer
)	O
;	O
int	O
tn	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
struct	O
addrinfo	struct
*	O
result	pointer
,	O
*	O
aip	pointer
,	O
hints	struct
;	O
const	O
int	O
on	int
=	O
1	int
;	O
int	O
err	long
;	O
char	O
*	O
cmd	pointer
,	O
*	O
hostp	pointer
=	O
0	int
,	O
*	O
portp	pointer
=	O
0	int
,	O
*	O
user	pointer
=	O
0	int
;	O
memset	function
(	O
&	O
hints	struct
,	O
0	int
,	O
sizeof	O
(	O
hints	struct
)	O
)	O
;	O
if	O
(	O
connected	int
)	O
{	O
printf	function
(	O
"?Already connected to %s\n"	pointer
,	O
hostname	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
strcpy	function
(	O
line	pointer
,	O
"open "	pointer
)	O
;	O
printf	function
(	O
"(to) "	pointer
)	O
;	O
fgets	function
(	O
&	O
line	pointer
[	O
strlen	function
(	O
line	pointer
)	O
]	O
,	O
sizeof	O
(	O
line	pointer
)	O
-	O
strlen	function
(	O
line	pointer
)	O
,	O
stdin	pointer
)	O
;	O
makeargv	function
(	O
)	O
;	O
argc	int
=	O
margc	int
;	O
argv	pointer
=	O
margv	array
;	O
}	O
cmd	pointer
=	O
*	O
argv	pointer
;	O
--	O
argc	int
;	O
++	O
argv	pointer
;	O
while	O
(	O
argc	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"help"	pointer
)	O
==	O
0	int
||	O
isprefix	function
(	O
*	O
argv	pointer
,	O
"?"	pointer
)	O
)	O
goto	O
usage	O
;	O
if	O
(	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"-l"	pointer
)	O
==	O
0	int
)	O
{	O
--	O
argc	int
;	O
++	O
argv	pointer
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
goto	O
usage	O
;	O
user	pointer
=	O
*	O
argv	pointer
++	O
;	O
--	O
argc	int
;	O
continue	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"-a"	pointer
)	O
==	O
0	int
)	O
{	O
--	O
argc	int
;	O
++	O
argv	pointer
;	O
autologin	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"-6"	pointer
)	O
==	O
0	int
)	O
{	O
--	O
argc	int
;	O
++	O
argv	pointer
;	O
hints	struct
.	O
ai_family	int
=	O
AF_INET6	O
;	O
continue	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"-4"	pointer
)	O
==	O
0	int
)	O
{	O
--	O
argc	int
;	O
++	O
argv	pointer
;	O
hints	struct
.	O
ai_family	int
=	O
AF_INET	O
;	O
continue	O
;	O
}	O
if	O
(	O
hostp	pointer
==	O
0	int
)	O
{	O
hostp	pointer
=	O
*	O
argv	pointer
++	O
;	O
--	O
argc	int
;	O
continue	O
;	O
}	O
if	O
(	O
portp	pointer
==	O
0	int
)	O
{	O
portp	pointer
=	O
*	O
argv	pointer
++	O
;	O
--	O
argc	int
;	O
continue	O
;	O
}	O
usage	O
:	O
printf	function
(	O
"usage: %s [-4] [-6] [-l user] [-a] host-name [port]\n"	pointer
,	O
cmd	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
hostp	pointer
==	O
0	int
)	O
goto	O
usage	O
;	O
if	O
(	O
!	O
portp	pointer
)	O
{	O
portp	pointer
=	O
"telnet"	pointer
;	O
telnetport	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
*	O
portp	pointer
==	O
'-'	O
)	O
{	O
portp	pointer
++	O
;	O
telnetport	int
=	O
1	int
;	O
}	O
else	O
telnetport	int
=	O
0	int
;	O
}	O
free	function
(	O
hostname	pointer
)	O
;	O
hostname	pointer
=	O
malloc	function
(	O
strlen	function
(	O
hostp	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
hostname	pointer
)	O
strcpy	function
(	O
hostname	pointer
,	O
hostp	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
"Can't allocate memory to copy hostname\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
hints	struct
.	O
ai_flags	int
=	O
AI_ADDRCONFIG	int
;	O
hints	struct
.	O
ai_socktype	int
=	O
SOCK_STREAM	int
;	O
err	long
=	O
getaddrinfo	function
(	O
hostp	pointer
,	O
portp	pointer
,	O
&	O
hints	struct
,	O
&	O
result	pointer
)	O
;	O
if	O
(	O
err	long
)	O
{	O
const	O
char	O
*	O
errmsg	pointer
;	O
if	O
(	O
err	long
==	O
EAI_SYSTEM	O
)	O
errmsg	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
else	O
errmsg	pointer
=	O
gai_strerror	function
(	O
err	long
)	O
;	O
printf	function
(	O
"%s/%s: lookup failure: %s\n"	pointer
,	O
hostp	pointer
,	O
portp	pointer
,	O
errmsg	pointer
)	O
;	O
return	O
0	int
;	O
}	O
aip	pointer
=	O
result	pointer
;	O
do	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
err	long
=	O
getnameinfo	function
(	O
aip	pointer
->	O
ai_addr	pointer
,	O
aip	pointer
->	O
ai_addrlen	int
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NUMERICHOST	int
)	O
;	O
if	O
(	O
err	long
)	O
{	O
const	O
char	O
*	O
errmsg	pointer
;	O
if	O
(	O
err	long
==	O
EAI_SYSTEM	O
)	O
errmsg	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
else	O
errmsg	pointer
=	O
gai_strerror	function
(	O
err	long
)	O
;	O
printf	function
(	O
"getnameinfo error: %s\n"	pointer
,	O
errmsg	pointer
)	O
;	O
return	O
0	int
;	O
}	O
printf	function
(	O
"Trying %s...\n"	pointer
,	O
buf	pointer
)	O
;	O
net	int
=	O
socket	function
(	O
aip	pointer
->	O
ai_family	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
net	int
<	O
0	int
)	O
{	O
perror	function
(	O
"telnet: socket"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
debug	int
)	O
{	O
err	long
=	O
setsockopt	function
(	O
net	int
,	O
SOL_SOCKET	int
,	O
SO_DEBUG	int
,	O
&	O
on	int
,	O
sizeof	O
(	O
on	int
)	O
)	O
;	O
if	O
(	O
err	long
<	O
0	int
)	O
perror	function
(	O
"setsockopt (SO_DEBUG)"	pointer
)	O
;	O
}	O
err	long
=	O
connect	function
(	O
net	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
aip	pointer
->	O
ai_addr	pointer
,	O
aip	pointer
->	O
ai_addrlen	int
)	O
;	O
if	O
(	O
err	long
<	O
0	int
)	O
{	O
if	O
(	O
aip	pointer
->	O
ai_next	pointer
)	O
{	O
perror	function
(	O
"Connection failed"	pointer
)	O
;	O
aip	pointer
=	O
aip	pointer
->	O
ai_next	pointer
;	O
close	function
(	O
net	int
)	O
;	O
continue	O
;	O
}	O
perror	function
(	O
"telnet: Unable to connect to remote host"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
connected	int
++	O
;	O
}	O
while	O
(	O
!	O
connected	int
)	O
;	O
freeaddrinfo	function
(	O
result	pointer
)	O
;	O
cmdrc	function
(	O
hostp	pointer
,	O
hostname	pointer
)	O
;	O
if	O
(	O
autologin	int
&&	O
user	pointer
==	O
NULL	O
)	O
{	O
struct	O
passwd	struct
*	O
pw	pointer
;	O
user	pointer
=	O
getenv	function
(	O
"USER"	pointer
)	O
;	O
if	O
(	O
user	pointer
==	O
NULL	O
||	O
(	O
(	O
pw	pointer
=	O
getpwnam	function
(	O
user	pointer
)	O
)	O
&&	O
pw	pointer
->	O
pw_uid	int
!=	O
getuid	function
(	O
)	O
)	O
)	O
{	O
if	O
(	O
(	O
pw	pointer
=	O
getpwuid	function
(	O
getuid	function
(	O
)	O
)	O
)	O
)	O
user	pointer
=	O
pw	pointer
->	O
pw_name	pointer
;	O
else	O
user	pointer
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
user	pointer
)	O
{	O
env_define	function
(	O
"USER"	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
user	pointer
)	O
;	O
env_export	function
(	O
"USER"	pointer
)	O
;	O
}	O
call	function
(	O
status	function
,	O
"status"	pointer
,	O
"notmuch"	pointer
,	O
0	int
)	O
;	O
if	O
(	O
setjmp	function
(	O
peerdied	array
)	O
==	O
0	int
)	O
telnet	function
(	O
user	pointer
)	O
;	O
close	function
(	O
net	int
)	O
;	O
ExitString	function
(	O
"Connection closed by foreign host.\n"	pointer
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
char	O
openhelp	array
[	O
]	O
=	O
"connect to a site"	pointer
,	O
closehelp	array
[	O
]	O
=	O
"close current connection"	pointer
,	O
logouthelp	array
[	O
]	O
=	O
"forcibly logout remote user and close the connection"	pointer
,	O
quithelp	array
[	O
]	O
=	O
"exit telnet"	pointer
,	O
statushelp	array
[	O
]	O
=	O
"print status information"	pointer
,	O
helphelp	array
[	O
]	O
=	O
"print help information"	pointer
,	O
sendhelp	array
[	O
]	O
=	O
"transmit special characters ('send ?' for more)"	pointer
,	O
sethelp	array
[	O
]	O
=	O
"set operating parameters ('set ?' for more)"	pointer
,	O
unsethelp	array
[	O
]	O
=	O
"unset operating parameters ('unset ?' for more)"	pointer
,	O
togglestring	array
[	O
]	O
=	O
"toggle operating parameters ('toggle ?' for more)"	pointer
,	O
slchelp	array
[	O
]	O
=	O
"change state of special characters ('slc ?' for more)"	pointer
,	O
displayhelp	array
[	O
]	O
=	O
"display operating parameters"	pointer
,	O
zhelp	array
[	O
]	O
=	O
"suspend telnet"	pointer
,	O
shellhelp	array
[	O
]	O
=	O
"invoke a subshell"	pointer
,	O
envhelp	array
[	O
]	O
=	O
"change environment variables ('environ ?' for more)"	pointer
,	O
modestring	array
[	O
]	O
=	O
"try to enter line or character mode ('mode ?' for more)"	pointer
;	O
static	O
int	O
help	pointer
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
static	O
Command	struct
cmdtab	array
[	O
]	O
=	O
{	O
{	O
"close"	pointer
,	O
closehelp	array
,	O
bye	function
,	O
1	int
}	O
,	O
{	O
"logout"	pointer
,	O
logouthelp	array
,	O
logout	function
,	O
1	int
}	O
,	O
{	O
"display"	pointer
,	O
displayhelp	array
,	O
display	function
,	O
0	int
}	O
,	O
{	O
"mode"	pointer
,	O
modestring	array
,	O
modecmd	function
,	O
0	int
}	O
,	O
{	O
"open"	pointer
,	O
openhelp	array
,	O
tn	function
,	O
0	int
}	O
,	O
{	O
"quit"	pointer
,	O
quithelp	array
,	O
quit	function
,	O
0	int
}	O
,	O
{	O
"send"	pointer
,	O
sendhelp	array
,	O
sendcmd	function
,	O
0	int
}	O
,	O
{	O
"set"	pointer
,	O
sethelp	array
,	O
setcmd	function
,	O
0	int
}	O
,	O
{	O
"unset"	pointer
,	O
unsethelp	array
,	O
unsetcmd	function
,	O
0	int
}	O
,	O
{	O
"status"	pointer
,	O
statushelp	array
,	O
status	function
,	O
0	int
}	O
,	O
{	O
"toggle"	pointer
,	O
togglestring	array
,	O
toggle	function
,	O
0	int
}	O
,	O
{	O
"slc"	pointer
,	O
slchelp	array
,	O
slccmd	function
,	O
0	int
}	O
,	O
{	O
"z"	pointer
,	O
zhelp	array
,	O
suspend	function
,	O
0	int
}	O
,	O
{	O
"!"	pointer
,	O
shellhelp	array
,	O
shell	function
,	O
0	int
}	O
,	O
{	O
"environ"	pointer
,	O
envhelp	array
,	O
env_cmd	function
,	O
0	int
}	O
,	O
{	O
"?"	pointer
,	O
helphelp	array
,	O
help	pointer
,	O
0	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
char	O
crmodhelp	array
[	O
]	O
=	O
"deprecated command -- use 'toggle crmod' instead"	pointer
;	O
static	O
char	O
escapehelp	array
[	O
]	O
=	O
"deprecated command -- use 'set escape' instead"	pointer
;	O
static	O
Command	struct
cmdtab2	array
[	O
]	O
=	O
{	O
{	O
"help"	pointer
,	O
0	int
,	O
help	pointer
,	O
0	int
}	O
,	O
{	O
"escape"	pointer
,	O
escapehelp	array
,	O
setescape	function
,	O
0	int
}	O
,	O
{	O
"crmod"	pointer
,	O
crmodhelp	array
,	O
togcrmod	function
,	O
0	int
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
int	O
call	function
(	O
intrtn_t	pointer
routine	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
char	O
*	O
args	array
[	O
100	int
]	O
;	O
int	O
argno	int
=	O
0	int
;	O
va_start	O
(	O
ap	array
,	O
routine	pointer
)	O
;	O
while	O
(	O
(	O
args	array
[	O
argno	int
++	O
]	O
=	O
va_arg	O
(	O
ap	array
,	O
char	O
*	O
)	O
)	O
!=	O
0	int
)	O
{	O
;	O
}	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
(	O
*	O
routine	pointer
)	O
(	O
argno	int
-	O
1	int
,	O
args	array
)	O
;	O
}	O
static	O
Command	struct
*	O
getcmd	function
(	O
char	O
*	O
name	pointer
)	O
{	O
Command	struct
*	O
cm	pointer
;	O
if	O
(	O
(	O
cm	pointer
=	O
(	O
Command	struct
*	O
)	O
genget	function
(	O
name	pointer
,	O
(	O
char	O
*	O
*	O
)	O
cmdtab	array
,	O
sizeof	O
(	O
Command	struct
)	O
)	O
)	O
)	O
return	O
cm	pointer
;	O
return	O
(	O
Command	struct
*	O
)	O
genget	function
(	O
name	pointer
,	O
(	O
char	O
*	O
*	O
)	O
cmdtab2	array
,	O
sizeof	O
(	O
Command	struct
)	O
)	O
;	O
}	O
void	O
command	function
(	O
int	O
top	pointer
,	O
char	O
*	O
tbuf	pointer
,	O
int	O
cnt	int
)	O
{	O
register	O
Command	struct
*	O
c	int
;	O
setcommandmode	function
(	O
)	O
;	O
if	O
(	O
!	O
top	pointer
)	O
{	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
else	O
{	O
signal	function
(	O
SIGINT	int
,	O
SIG_DFL	O
)	O
;	O
signal	function
(	O
SIGQUIT	int
,	O
SIG_DFL	O
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
rlogin	char
==	O
_POSIX_VDISABLE	char
)	O
printf	function
(	O
"%s> "	pointer
,	O
prompt	pointer
)	O
;	O
if	O
(	O
tbuf	pointer
)	O
{	O
register	O
char	O
*	O
cp	pointer
;	O
cp	pointer
=	O
line	pointer
;	O
while	O
(	O
cnt	int
>	O
0	int
&&	O
(	O
*	O
cp	pointer
++	O
=	O
*	O
tbuf	pointer
++	O
)	O
!=	O
'\n'	O
)	O
cnt	int
--	O
;	O
tbuf	pointer
=	O
0	int
;	O
if	O
(	O
cp	pointer
==	O
line	pointer
||	O
*	O
--	O
cp	pointer
!=	O
'\n'	O
||	O
cp	pointer
==	O
line	pointer
)	O
goto	O
getline	function
;	O
*	O
cp	pointer
=	O
'\0'	O
;	O
if	O
(	O
rlogin	char
==	O
_POSIX_VDISABLE	char
)	O
printf	function
(	O
"%s\n"	pointer
,	O
line	pointer
)	O
;	O
}	O
else	O
{	O
getline	function
:	O
if	O
(	O
rlogin	char
!=	O
_POSIX_VDISABLE	char
)	O
printf	function
(	O
"%s> "	pointer
,	O
prompt	pointer
)	O
;	O
if	O
(	O
fgets	function
(	O
line	pointer
,	O
sizeof	O
(	O
line	pointer
)	O
,	O
stdin	pointer
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
feof	function
(	O
stdin	pointer
)	O
||	O
ferror	function
(	O
stdin	pointer
)	O
)	O
{	O
quit	function
(	O
)	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
line	pointer
[	O
0	int
]	O
==	O
0	int
)	O
break	O
;	O
makeargv	function
(	O
)	O
;	O
if	O
(	O
margv	array
[	O
0	int
]	O
==	O
0	int
)	O
{	O
break	O
;	O
}	O
c	int
=	O
getcmd	function
(	O
margv	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
Ambiguous	function
(	O
c	int
)	O
)	O
{	O
printf	function
(	O
"?Ambiguous command\n"	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
printf	function
(	O
"?Invalid command\n"	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
->	O
needconnect	int
&&	O
!	O
connected	int
)	O
{	O
printf	function
(	O
"?Need to be connected first.\n"	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
*	O
c	int
->	O
handler	pointer
)	O
(	O
margc	int
,	O
margv	array
)	O
)	O
{	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
top	pointer
)	O
{	O
if	O
(	O
!	O
connected	int
)	O
{	O
longjmp	function
(	O
toplevel	array
,	O
1	int
)	O
;	O
}	O
setconnmode	function
(	O
0	int
)	O
;	O
}	O
}	O
static	O
int	O
help	pointer
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
register	O
Command	struct
*	O
c	int
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
printf	function
(	O
"Commands may be abbreviated.  Commands are:\n\n"	pointer
)	O
;	O
for	O
(	O
c	int
=	O
cmdtab	array
;	O
c	int
->	O
name	pointer
;	O
c	int
++	O
)	O
if	O
(	O
c	int
->	O
help	pointer
)	O
{	O
printf	function
(	O
"%-*s\t%s\n"	pointer
,	O
HELPINDENT	O
,	O
c	int
->	O
name	pointer
,	O
c	int
->	O
help	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
while	O
(	O
--	O
argc	int
>	O
0	int
)	O
{	O
register	O
char	O
*	O
arg	pointer
;	O
arg	pointer
=	O
*	O
++	O
argv	pointer
;	O
c	int
=	O
getcmd	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
Ambiguous	function
(	O
c	int
)	O
)	O
printf	function
(	O
"?Ambiguous help command %s\n"	pointer
,	O
arg	pointer
)	O
;	O
else	O
if	O
(	O
c	int
==	O
(	O
Command	struct
*	O
)	O
0	int
)	O
printf	function
(	O
"?Invalid help command %s\n"	pointer
,	O
arg	pointer
)	O
;	O
else	O
printf	function
(	O
"%s\n"	pointer
,	O
c	int
->	O
help	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
rcname	pointer
=	O
0	int
;	O
static	O
void	O
cmdrc	function
(	O
char	O
*	O
m1	pointer
,	O
char	O
*	O
m2	pointer
)	O
{	O
register	O
Command	struct
*	O
c	int
;	O
FILE	struct
*	O
rcfile	pointer
;	O
int	O
gotmachine	int
=	O
0	int
;	O
int	O
l1	int
=	O
strlen	function
(	O
m1	pointer
)	O
;	O
int	O
l2	int
=	O
strlen	function
(	O
m2	pointer
)	O
;	O
if	O
(	O
skiprc	int
)	O
return	O
;	O
if	O
(	O
rcname	pointer
==	O
0	int
)	O
{	O
const	O
char	O
*	O
home	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
home	pointer
)	O
rcname	pointer
=	O
xasprintf	function
(	O
"%s/.telnetrc"	pointer
,	O
home	pointer
)	O
;	O
else	O
rcname	pointer
=	O
xstrdup	function
(	O
"/.telnetrc"	pointer
)	O
;	O
}	O
if	O
(	O
(	O
rcfile	pointer
=	O
fopen	function
(	O
rcname	pointer
,	O
"r"	pointer
)	O
)	O
==	O
0	int
)	O
{	O
return	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
fgets	function
(	O
line	pointer
,	O
sizeof	O
(	O
line	pointer
)	O
,	O
rcfile	pointer
)	O
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
line	pointer
[	O
0	int
]	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
line	pointer
[	O
0	int
]	O
==	O
'#'	O
)	O
continue	O
;	O
if	O
(	O
gotmachine	int
)	O
{	O
if	O
(	O
!	O
isspace	function
(	O
line	pointer
[	O
0	int
]	O
)	O
)	O
gotmachine	int
=	O
0	int
;	O
}	O
if	O
(	O
gotmachine	int
==	O
0	int
)	O
{	O
if	O
(	O
isspace	function
(	O
line	pointer
[	O
0	int
]	O
)	O
)	O
continue	O
;	O
if	O
(	O
strncasecmp	function
(	O
line	pointer
,	O
m1	pointer
,	O
l1	int
)	O
==	O
0	int
)	O
strncpy	function
(	O
line	pointer
,	O
&	O
line	pointer
[	O
l1	int
]	O
,	O
sizeof	O
(	O
line	pointer
)	O
-	O
l1	int
)	O
;	O
else	O
if	O
(	O
strncasecmp	function
(	O
line	pointer
,	O
m2	pointer
,	O
l2	int
)	O
==	O
0	int
)	O
strncpy	function
(	O
line	pointer
,	O
&	O
line	pointer
[	O
l2	int
]	O
,	O
sizeof	O
(	O
line	pointer
)	O
-	O
l2	int
)	O
;	O
else	O
if	O
(	O
strncasecmp	function
(	O
line	pointer
,	O
"DEFAULT"	pointer
,	O
7	int
)	O
==	O
0	int
)	O
strncpy	function
(	O
line	pointer
,	O
&	O
line	pointer
[	O
7	int
]	O
,	O
sizeof	O
(	O
line	pointer
)	O
-	O
7	int
)	O
;	O
else	O
continue	O
;	O
if	O
(	O
line	pointer
[	O
0	int
]	O
!=	O
' '	O
&&	O
line	pointer
[	O
0	int
]	O
!=	O
'\t'	O
&&	O
line	pointer
[	O
0	int
]	O
!=	O
'\n'	O
)	O
continue	O
;	O
gotmachine	int
=	O
1	int
;	O
}	O
makeargv	function
(	O
)	O
;	O
if	O
(	O
margv	array
[	O
0	int
]	O
==	O
0	int
)	O
continue	O
;	O
c	int
=	O
getcmd	function
(	O
margv	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
Ambiguous	function
(	O
c	int
)	O
)	O
{	O
printf	function
(	O
"?Ambiguous command: %s\n"	pointer
,	O
margv	array
[	O
0	int
]	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
0	int
)	O
{	O
printf	function
(	O
"?Invalid command: %s\n"	pointer
,	O
margv	array
[	O
0	int
]	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
->	O
needconnect	int
&&	O
!	O
connected	int
)	O
{	O
printf	function
(	O
"?Need to be connected first for %s.\n"	pointer
,	O
margv	array
[	O
0	int
]	O
)	O
;	O
continue	O
;	O
}	O
(	O
*	O
c	int
->	O
handler	pointer
)	O
(	O
margc	int
,	O
margv	array
)	O
;	O
}	O
fclose	function
(	O
rcfile	pointer
)	O
;	O
}	O
