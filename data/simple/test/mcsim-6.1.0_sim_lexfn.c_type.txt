typedef	O
struct	O
tagINPUTFUNCTIONMAP	struct
{	O
PSTR	pointer
szName	pointer
;	O
int	O
iIFNType	int
;	O
}	O
IFM	struct
,	O
*	O
PIFM	pointer
;	O
IFM	struct
vrgifmMap	array
[	O
]	O
=	O
{	O
{	O
"PerDose"	pointer
,	O
IFN_PERDOSE	int
}	O
,	O
{	O
"PerExp"	pointer
,	O
IFN_PEREXP	int
}	O
,	O
{	O
"PerTransit"	pointer
,	O
IFN_PERTRANS	int
}	O
,	O
{	O
"NDoses"	pointer
,	O
IFN_NDOSES	int
}	O
,	O
{	O
"Spikes"	pointer
,	O
IFN_SPIKES	int
}	O
,	O
{	O
"Events"	pointer
,	O
IFN_EVENTS	int
}	O
,	O
{	O
""	pointer
,	O
IFN_NULL	int
}	O
}	O
;	O
extern	O
PSTR	pointer
vrgszLexTypes	array
[	O
]	O
;	O
extern	O
VMMAPSTRCT	struct
vrgvmGlo	array
[	O
]	O
;	O
int	O
GetFnType	function
(	O
PSTR	pointer
szName	pointer
)	O
{	O
PIFM	pointer
pifm	pointer
=	O
&	O
vrgifmMap	array
[	O
0	int
]	O
;	O
while	O
(	O
*	O
pifm	pointer
->	O
szName	pointer
&&	O
MyStrcmp	function
(	O
szName	pointer
,	O
pifm	pointer
->	O
szName	pointer
)	O
)	O
pifm	pointer
++	O
;	O
return	O
(	O
pifm	pointer
->	O
iIFNType	int
)	O
;	O
}	O
void	O
InitIFN	function
(	O
PIFN	pointer
pifn	pointer
)	O
{	O
pifn	pointer
->	O
dTStartPeriod	double
=	O
0.0	int
;	O
pifn	pointer
->	O
bOn	int
=	O
FALSE	int
;	O
pifn	pointer
->	O
dMag	double
=	O
0.0	int
;	O
pifn	pointer
->	O
dTper	double
=	O
0.0	int
;	O
pifn	pointer
->	O
dT0	double
=	O
0.0	int
;	O
pifn	pointer
->	O
dTexp	double
=	O
0.0	int
;	O
pifn	pointer
->	O
dDecay	double
=	O
0.0	int
;	O
pifn	pointer
->	O
dVal	double
=	O
0.0	int
;	O
pifn	pointer
->	O
nDoses	int
=	O
0	int
;	O
pifn	pointer
->	O
hMag	long
=	O
0	int
;	O
pifn	pointer
->	O
hTper	long
=	O
0	int
;	O
pifn	pointer
->	O
hT0	long
=	O
0	int
;	O
pifn	pointer
->	O
hTexp	long
=	O
0	int
;	O
pifn	pointer
->	O
hDecay	long
=	O
0	int
;	O
pifn	pointer
->	O
nDoses	int
=	O
0	int
;	O
pifn	pointer
->	O
iDoseCur	int
=	O
0	int
;	O
}	O
BOOL	int
DefDepParm	function
(	O
PSTR	pointer
szLex	pointer
,	O
PDOUBLE	pointer
pdValue	pointer
,	O
HANDLE	long
*	O
phvar	pointer
)	O
{	O
BOOL	int
bReturn	int
=	O
TRUE	int
;	O
if	O
(	O
IsIdentifier	O
(	O
szLex	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
*	O
phvar	pointer
=	O
(	O
HANDLE	long
)	O
GetParmHandle	O
(	O
szLex	pointer
)	O
)	O
)	O
{	O
bReturn	int
=	O
FALSE	int
;	O
ReportError	function
(	O
NULL	O
,	O
RE_UNDEFINED	int
,	O
szLex	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
*	O
pdValue	pointer
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
*	O
phvar	pointer
=	O
0	int
;	O
}	O
return	O
(	O
bReturn	int
)	O
;	O
}	O
BOOL	int
GetInputArgs	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PIFN	pointer
pifn	pointer
,	O
int	O
nArgs	int
)	O
{	O
PSTRLEX	array
*	O
rgszLex	pointer
=	O
malloc	function
(	O
nArgs	int
*	O
sizeof	O
(	O
PSTRLEX	array
)	O
)	O
;	O
int	O
*	O
rgiTypes	pointer
=	O
malloc	function
(	O
nArgs	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
int	O
i	int
;	O
BOOL	int
bReturn	int
=	O
FALSE	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nArgs	int
;	O
i	int
++	O
)	O
rgiTypes	pointer
[	O
i	int
]	O
=	O
LX_INTEGER	int
|	O
LX_FLOAT	int
|	O
LX_IDENTIFIER	int
;	O
if	O
(	O
GetFuncArgs	function
(	O
pibIn	pointer
,	O
nArgs	int
,	O
rgiTypes	pointer
,	O
rgszLex	pointer
[	O
0	int
]	O
)	O
)	O
{	O
bReturn	int
=	O
TRUE	int
;	O
bReturn	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
0	int
]	O
,	O
&	O
pifn	pointer
->	O
dMag	double
,	O
&	O
pifn	pointer
->	O
hMag	long
)	O
;	O
bReturn	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
1	int
]	O
,	O
&	O
pifn	pointer
->	O
dTper	double
,	O
&	O
pifn	pointer
->	O
hTper	long
)	O
;	O
bReturn	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
2	int
]	O
,	O
&	O
pifn	pointer
->	O
dT0	double
,	O
&	O
pifn	pointer
->	O
hT0	long
)	O
;	O
if	O
(	O
(	O
pifn	pointer
->	O
iType	int
==	O
IFN_PEREXP	int
)	O
||	O
(	O
pifn	pointer
->	O
iType	int
==	O
IFN_PERTRANS	int
)	O
)	O
bReturn	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
3	int
]	O
,	O
&	O
pifn	pointer
->	O
dDecay	double
,	O
&	O
pifn	pointer
->	O
hDecay	long
)	O
;	O
else	O
bReturn	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
3	int
]	O
,	O
&	O
pifn	pointer
->	O
dTexp	double
,	O
&	O
pifn	pointer
->	O
hTexp	long
)	O
;	O
if	O
(	O
(	O
pifn	pointer
->	O
iType	int
==	O
IFN_PERTRANS	int
)	O
&&	O
(	O
nArgs	int
==	O
5	int
)	O
)	O
bReturn	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
4	int
]	O
,	O
&	O
pifn	pointer
->	O
dNcpt	double
,	O
&	O
pifn	pointer
->	O
hNcpt	long
)	O
;	O
if	O
(	O
!	O
bReturn	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
,	O
"input-spec"	pointer
,	O
NULL	O
)	O
;	O
}	O
free	function
(	O
rgiTypes	pointer
)	O
;	O
free	function
(	O
rgszLex	pointer
)	O
;	O
return	O
(	O
bReturn	int
)	O
;	O
}	O
BOOL	int
GetNNumbers	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
int	O
nNumbers	int
,	O
PDOUBLE	pointer
rgd	pointer
)	O
{	O
BOOL	int
bErr	int
=	O
FALSE	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nNumbers	int
&&	O
!	O
bErr	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
)	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
;	O
if	O
(	O
!	O
(	O
bErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_NUMBER	O
)	O
)	O
)	O
rgd	pointer
[	O
i	int
]	O
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
}	O
return	O
bErr	int
;	O
}	O
BOOL	int
GetNDoses	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
PIFN	pointer
pifn	pointer
)	O
{	O
PSTRLEX	array
*	O
rgszLex	pointer
;	O
PSTRLEX	array
szTmp	array
;	O
int	O
*	O
rgiTypes	pointer
,	O
iType	int
;	O
long	O
i	int
,	O
j	long
,	O
iLB	long
,	O
iUB	long
,	O
iDoseArg	long
;	O
BOOL	int
bOK	int
=	O
TRUE	int
;	O
BOOL	int
bErr	int
=	O
FALSE	int
;	O
HVAR	long
hvar	long
;	O
if	O
(	O
(	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
)	O
)	O
goto	O
Exit_GetNDoses	O
;	O
if	O
(	O
(	O
bErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_INTEGER	int
)	O
)	O
)	O
goto	O
Exit_GetNDoses	O
;	O
pifn	pointer
->	O
nDoses	int
=	O
atoi	function
(	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
(	O
pifn	pointer
->	O
nDoses	int
<=	O
0	int
)	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"positive-integer"	pointer
,	O
szLex	pointer
)	O
;	O
goto	O
Exit_GetNDoses	O
;	O
}	O
iDoseArg	long
=	O
2	int
*	O
pifn	pointer
->	O
nDoses	int
;	O
if	O
(	O
!	O
(	O
rgiTypes	pointer
=	O
InitiVector	function
(	O
iDoseArg	long
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetNDoses"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
rgszLex	pointer
=	O
(	O
PSTRLEX	array
*	O
)	O
malloc	function
(	O
iDoseArg	long
*	O
sizeof	O
(	O
PSTRLEX	array
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetNDoses"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pifn	pointer
->	O
rgT0s	pointer
=	O
InitdVector	function
(	O
pifn	pointer
->	O
nDoses	int
+	O
1	int
)	O
)	O
||	O
!	O
(	O
pifn	pointer
->	O
rgMags	pointer
=	O
InitdVector	function
(	O
pifn	pointer
->	O
nDoses	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetNDoses"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pifn	pointer
->	O
rghT0s	pointer
=	O
(	O
HANDLE	long
*	O
)	O
malloc	function
(	O
(	O
pifn	pointer
->	O
nDoses	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
HANDLE	long
)	O
)	O
)	O
||	O
!	O
(	O
pifn	pointer
->	O
rghMags	pointer
=	O
(	O
HANDLE	long
*	O
)	O
malloc	function
(	O
pifn	pointer
->	O
nDoses	int
*	O
sizeof	O
(	O
HANDLE	long
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetNDoses"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetPunct	function
(	O
pibIn	pointer
,	O
rgszLex	pointer
[	O
0	int
]	O
,	O
','	O
)	O
)	O
)	O
{	O
*	O
(	O
rgszLex	pointer
[	O
0	int
]	O
+	O
1	int
)	O
=	O
','	O
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
|	O
RE_FATAL	int
,	O
rgszLex	pointer
[	O
0	int
]	O
,	O
NULL	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
iDoseArg	long
/	O
2	int
)	O
&&	O
bOK	int
;	O
i	int
++	O
)	O
{	O
rgiTypes	pointer
[	O
i	int
]	O
=	O
LX_INTEGER	int
|	O
LX_FLOAT	int
|	O
LX_IDENTIFIER	int
;	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
&=	O
(	O
iType	int
&	O
rgiTypes	pointer
[	O
i	int
]	O
)	O
>	O
0	int
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
vrgszLexTypes	array
[	O
rgiTypes	pointer
[	O
i	int
]	O
]	O
,	O
szLex	pointer
)	O
;	O
iLB	long
=	O
iUB	long
=	O
-	O
1	int
;	O
if	O
(	O
GetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
'['	O
)	O
)	O
GetArrayBounds	function
(	O
pibIn	pointer
,	O
&	O
iLB	long
,	O
&	O
iUB	long
)	O
;	O
if	O
(	O
iUB	long
==	O
-	O
1	int
)	O
{	O
strcpy	function
(	O
rgszLex	pointer
[	O
i	int
]	O
,	O
szLex	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
2	int
*	O
(	O
iUB	long
-	O
iLB	long
)	O
!=	O
iDoseArg	long
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_TOOMANYPVARS	int
|	O
RE_FATAL	int
,	O
"GetNDoses"	pointer
,	O
NULL	O
)	O
;	O
for	O
(	O
j	long
=	O
iLB	long
;	O
j	long
<	O
iUB	long
;	O
j	long
++	O
)	O
{	O
sprintf	function
(	O
szTmp	array
,	O
"%s_%ld"	pointer
,	O
szLex	pointer
,	O
j	long
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	function
(	O
szTmp	array
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_UNDEFINED	int
|	O
RE_FATAL	int
,	O
szTmp	array
,	O
NULL	O
)	O
;	O
else	O
{	O
strcpy	function
(	O
rgszLex	pointer
[	O
i	int
+	O
j	long
-	O
iLB	long
]	O
,	O
szTmp	array
)	O
;	O
}	O
}	O
if	O
(	O
(	O
bErr	int
=	O
!	O
GetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
','	O
)	O
)	O
)	O
goto	O
Exit_GetNDoses	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
iDoseArg	long
/	O
2	int
;	O
i	int
<	O
iDoseArg	long
&&	O
bOK	int
;	O
i	int
++	O
)	O
{	O
rgiTypes	pointer
[	O
i	int
]	O
=	O
LX_INTEGER	int
|	O
LX_FLOAT	int
|	O
LX_IDENTIFIER	int
;	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
&=	O
(	O
iType	int
&	O
rgiTypes	pointer
[	O
i	int
]	O
)	O
>	O
0	int
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
vrgszLexTypes	array
[	O
rgiTypes	pointer
[	O
i	int
]	O
]	O
,	O
szLex	pointer
)	O
;	O
iLB	long
=	O
iUB	long
=	O
-	O
1	int
;	O
if	O
(	O
GetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
'['	O
)	O
)	O
GetArrayBounds	function
(	O
pibIn	pointer
,	O
&	O
iLB	long
,	O
&	O
iUB	long
)	O
;	O
if	O
(	O
iUB	long
==	O
-	O
1	int
)	O
{	O
strcpy	function
(	O
rgszLex	pointer
[	O
i	int
]	O
,	O
szLex	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
2	int
*	O
(	O
iUB	long
-	O
iLB	long
)	O
!=	O
iDoseArg	long
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_TOOMANYPVARS	int
|	O
RE_FATAL	int
,	O
"GetNDoses"	pointer
,	O
NULL	O
)	O
;	O
for	O
(	O
j	long
=	O
iLB	long
;	O
j	long
<	O
iUB	long
;	O
j	long
++	O
)	O
{	O
sprintf	function
(	O
szTmp	array
,	O
"%s_%ld"	pointer
,	O
szLex	pointer
,	O
j	long
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
!	O
(	O
hvar	long
=	O
GetVarHandle	function
(	O
szTmp	array
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_UNDEFINED	int
|	O
RE_FATAL	int
,	O
szTmp	array
,	O
NULL	O
)	O
;	O
else	O
{	O
strcpy	function
(	O
rgszLex	pointer
[	O
i	int
+	O
j	long
-	O
iLB	long
]	O
,	O
szTmp	array
)	O
;	O
}	O
}	O
if	O
(	O
(	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szTmp	array
,	O
CH_RPAREN	O
)	O
)	O
)	O
goto	O
Exit_GetNDoses	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
bErr	int
=	O
(	O
szTmp	array
[	O
0	int
]	O
!=	O
CH_RPAREN	O
)	O
)	O
)	O
goto	O
Exit_GetNDoses	O
;	O
bOK	int
=	O
TRUE	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pifn	pointer
->	O
nDoses	int
;	O
i	int
++	O
)	O
bOK	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
i	int
]	O
,	O
pifn	pointer
->	O
rgMags	pointer
+	O
i	int
,	O
pifn	pointer
->	O
rghMags	pointer
+	O
i	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pifn	pointer
->	O
nDoses	int
;	O
i	int
++	O
)	O
bOK	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
i	int
+	O
pifn	pointer
->	O
nDoses	int
]	O
,	O
pifn	pointer
->	O
rgT0s	pointer
+	O
i	int
,	O
pifn	pointer
->	O
rghT0s	pointer
+	O
i	int
)	O
;	O
i	int
=	O
pifn	pointer
->	O
nDoses	int
;	O
pifn	pointer
->	O
rgT0s	pointer
[	O
i	int
]	O
=	O
DBL_MAX	O
;	O
pifn	pointer
->	O
rghT0s	pointer
[	O
i	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
bOK	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
|	O
RE_FATAL	int
,	O
"input-spec"	pointer
,	O
NULL	O
)	O
;	O
Exit_GetNDoses	O
:	O
if	O
(	O
bErr	int
)	O
printf	function
(	O
"Syntax: NDoses (nInputs, <n Magnitudes>, <n T0's>)\n\n"	pointer
)	O
;	O
return	O
(	O
!	O
bErr	int
)	O
;	O
}	O
BOOL	int
GetEvents	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
PIFN	pointer
pifn	pointer
)	O
{	O
PSTRLEX	array
*	O
rgszLex	pointer
;	O
int	O
iType	int
,	O
*	O
rgiTypes	pointer
;	O
int	O
i	int
,	O
iDoseArg	long
;	O
BOOL	int
bOK	int
=	O
TRUE	int
;	O
BOOL	int
bErr	int
=	O
FALSE	int
;	O
if	O
(	O
(	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
)	O
)	O
goto	O
Exit_GetEvents	O
;	O
NextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
&=	O
(	O
iType	int
&	O
(	O
LX_IDENTIFIER	int
)	O
)	O
>	O
0	int
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
vrgszLexTypes	array
[	O
LX_IDENTIFIER	int
]	O
,	O
szLex	pointer
)	O
;	O
if	O
(	O
!	O
(	O
pifn	pointer
->	O
target_state	long
=	O
(	O
HANDLE	long
)	O
GetParmHandle	O
(	O
szLex	pointer
)	O
)	O
)	O
{	O
ReportError	function
(	O
NULL	O
,	O
RE_UNDEFINED	int
|	O
RE_FATAL	int
,	O
szLex	pointer
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
','	O
)	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
","	pointer
,	O
szLex	pointer
)	O
;	O
}	O
if	O
(	O
(	O
bErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_INTEGER	int
)	O
)	O
)	O
goto	O
Exit_GetEvents	O
;	O
pifn	pointer
->	O
nDoses	int
=	O
atoi	function
(	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
(	O
pifn	pointer
->	O
nDoses	int
<=	O
0	int
)	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"positive-integer"	pointer
,	O
szLex	pointer
)	O
;	O
goto	O
Exit_GetEvents	O
;	O
}	O
iDoseArg	long
=	O
3	int
*	O
pifn	pointer
->	O
nDoses	int
;	O
if	O
(	O
!	O
(	O
rgiTypes	pointer
=	O
InitiVector	function
(	O
iDoseArg	long
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetEvents"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
rgszLex	pointer
=	O
(	O
PSTRLEX	array
*	O
)	O
malloc	function
(	O
iDoseArg	long
*	O
sizeof	O
(	O
PSTRLEX	array
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetEvents"	pointer
,	O
NULL	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
iDoseArg	long
&&	O
bOK	int
;	O
i	int
++	O
)	O
{	O
rgiTypes	pointer
[	O
i	int
]	O
=	O
LX_INTEGER	int
|	O
LX_FLOAT	int
|	O
LX_IDENTIFIER	int
;	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
rgszLex	pointer
[	O
i	int
]	O
,	O
','	O
)	O
)	O
)	O
{	O
*	O
(	O
rgszLex	pointer
[	O
i	int
]	O
+	O
1	int
)	O
=	O
','	O
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
|	O
RE_FATAL	int
,	O
rgszLex	pointer
[	O
i	int
]	O
,	O
NULL	O
)	O
;	O
}	O
NextLex	function
(	O
pibIn	pointer
,	O
rgszLex	pointer
[	O
i	int
]	O
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
&=	O
(	O
iType	int
&	O
rgiTypes	pointer
[	O
i	int
]	O
)	O
>	O
0	int
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
vrgszLexTypes	array
[	O
rgiTypes	pointer
[	O
i	int
]	O
]	O
,	O
rgszLex	pointer
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
(	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_RPAREN	O
)	O
)	O
)	O
goto	O
Exit_GetEvents	O
;	O
if	O
(	O
!	O
(	O
pifn	pointer
->	O
rgT0s	pointer
=	O
InitdVector	function
(	O
pifn	pointer
->	O
nDoses	int
)	O
)	O
||	O
!	O
(	O
pifn	pointer
->	O
rgOper	pointer
=	O
InitiVector	function
(	O
pifn	pointer
->	O
nDoses	int
)	O
)	O
||	O
!	O
(	O
pifn	pointer
->	O
rgMags	pointer
=	O
InitdVector	function
(	O
pifn	pointer
->	O
nDoses	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetEvents"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pifn	pointer
->	O
rghT0s	pointer
=	O
(	O
HANDLE	long
*	O
)	O
malloc	function
(	O
(	O
pifn	pointer
->	O
nDoses	int
)	O
*	O
sizeof	O
(	O
HANDLE	long
)	O
)	O
)	O
||	O
!	O
(	O
pifn	pointer
->	O
rghMags	pointer
=	O
(	O
HANDLE	long
*	O
)	O
malloc	function
(	O
pifn	pointer
->	O
nDoses	int
*	O
sizeof	O
(	O
HANDLE	long
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetEvents"	pointer
,	O
NULL	O
)	O
;	O
bOK	int
=	O
TRUE	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pifn	pointer
->	O
nDoses	int
;	O
i	int
++	O
)	O
bOK	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
i	int
]	O
,	O
pifn	pointer
->	O
rgT0s	pointer
+	O
i	int
,	O
pifn	pointer
->	O
rghT0s	pointer
+	O
i	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pifn	pointer
->	O
nDoses	int
;	O
i	int
++	O
)	O
{	O
pifn	pointer
->	O
rgOper	pointer
[	O
i	int
]	O
=	O
GetKeywordCode	function
(	O
rgszLex	pointer
[	O
pifn	pointer
->	O
nDoses	int
+	O
i	int
]	O
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pifn	pointer
->	O
rgOper	pointer
[	O
i	int
]	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"Replace, Add or Multiply operation"	pointer
,	O
rgszLex	pointer
[	O
pifn	pointer
->	O
nDoses	int
+	O
i	int
]	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pifn	pointer
->	O
nDoses	int
;	O
i	int
++	O
)	O
bOK	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
2	int
*	O
pifn	pointer
->	O
nDoses	int
+	O
i	int
]	O
,	O
pifn	pointer
->	O
rgMags	pointer
+	O
i	int
,	O
pifn	pointer
->	O
rghMags	pointer
+	O
i	int
)	O
;	O
if	O
(	O
!	O
bOK	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
|	O
RE_FATAL	int
,	O
"input-spec"	pointer
,	O
NULL	O
)	O
;	O
Exit_GetEvents	O
:	O
if	O
(	O
bErr	int
)	O
printf	function
(	O
"Syntax: Events (State, nEvents, <n Times>, <n Operations>, "	pointer
"<n Values>)\n\n"	pointer
)	O
;	O
return	O
(	O
!	O
bErr	int
)	O
;	O
}	O
BOOL	int
GetSpikes	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
szLex	pointer
,	O
PIFN	pointer
pifn	pointer
)	O
{	O
PSTRLEX	array
*	O
rgszLex	pointer
;	O
int	O
*	O
rgiTypes	pointer
,	O
iType	int
;	O
int	O
i	int
,	O
iDoseArg	long
;	O
BOOL	int
bOK	int
=	O
TRUE	int
;	O
BOOL	int
bErr	int
=	O
FALSE	int
;	O
if	O
(	O
(	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_LPAREN	O
)	O
)	O
)	O
goto	O
Exit_GetSpikes	O
;	O
if	O
(	O
(	O
bErr	int
=	O
ENextLex	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
LX_INTEGER	int
)	O
)	O
)	O
goto	O
Exit_GetSpikes	O
;	O
pifn	pointer
->	O
nDoses	int
=	O
atoi	function
(	O
szLex	pointer
)	O
;	O
if	O
(	O
(	O
bErr	int
=	O
(	O
pifn	pointer
->	O
nDoses	int
<=	O
0	int
)	O
)	O
)	O
{	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
"positive-integer"	pointer
,	O
szLex	pointer
)	O
;	O
goto	O
Exit_GetSpikes	O
;	O
}	O
iDoseArg	long
=	O
2	int
*	O
pifn	pointer
->	O
nDoses	int
;	O
if	O
(	O
!	O
(	O
rgiTypes	pointer
=	O
InitiVector	function
(	O
iDoseArg	long
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetSpikes"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
rgszLex	pointer
=	O
(	O
PSTRLEX	array
*	O
)	O
malloc	function
(	O
iDoseArg	long
*	O
sizeof	O
(	O
PSTRLEX	array
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetSpikes"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pifn	pointer
->	O
rgT0s	pointer
=	O
InitdVector	function
(	O
pifn	pointer
->	O
nDoses	int
)	O
)	O
||	O
!	O
(	O
pifn	pointer
->	O
rgMags	pointer
=	O
InitdVector	function
(	O
pifn	pointer
->	O
nDoses	int
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetSpikes"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
pifn	pointer
->	O
rghT0s	pointer
=	O
(	O
HANDLE	long
*	O
)	O
malloc	function
(	O
(	O
pifn	pointer
->	O
nDoses	int
)	O
*	O
sizeof	O
(	O
HANDLE	long
)	O
)	O
)	O
||	O
!	O
(	O
pifn	pointer
->	O
rghMags	pointer
=	O
(	O
HANDLE	long
*	O
)	O
malloc	function
(	O
pifn	pointer
->	O
nDoses	int
*	O
sizeof	O
(	O
HANDLE	long
)	O
)	O
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_OUTOFMEM	int
|	O
RE_FATAL	int
,	O
"GetSpikes"	pointer
,	O
NULL	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
iDoseArg	long
&&	O
bOK	int
;	O
i	int
++	O
)	O
{	O
rgiTypes	pointer
[	O
i	int
]	O
=	O
LX_INTEGER	int
|	O
LX_FLOAT	int
|	O
LX_IDENTIFIER	int
;	O
if	O
(	O
!	O
(	O
bOK	int
=	O
GetOptPunct	function
(	O
pibIn	pointer
,	O
rgszLex	pointer
[	O
i	int
]	O
,	O
','	O
)	O
)	O
)	O
{	O
*	O
(	O
rgszLex	pointer
[	O
i	int
]	O
+	O
1	int
)	O
=	O
','	O
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
|	O
RE_FATAL	int
,	O
rgszLex	pointer
[	O
i	int
]	O
,	O
NULL	O
)	O
;	O
break	O
;	O
}	O
NextLex	function
(	O
pibIn	pointer
,	O
rgszLex	pointer
[	O
i	int
]	O
,	O
&	O
iType	int
)	O
;	O
if	O
(	O
!	O
(	O
bOK	int
&=	O
(	O
iType	int
&	O
rgiTypes	pointer
[	O
i	int
]	O
)	O
>	O
0	int
)	O
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
|	O
RE_FATAL	int
,	O
vrgszLexTypes	array
[	O
rgiTypes	pointer
[	O
i	int
]	O
]	O
,	O
rgszLex	pointer
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
(	O
bErr	int
=	O
EGetPunct	function
(	O
pibIn	pointer
,	O
szLex	pointer
,	O
CH_RPAREN	O
)	O
)	O
)	O
goto	O
Exit_GetSpikes	O
;	O
bOK	int
=	O
TRUE	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pifn	pointer
->	O
nDoses	int
;	O
i	int
++	O
)	O
bOK	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
i	int
]	O
,	O
pifn	pointer
->	O
rgMags	pointer
+	O
i	int
,	O
pifn	pointer
->	O
rghMags	pointer
+	O
i	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
pifn	pointer
->	O
nDoses	int
;	O
i	int
++	O
)	O
bOK	int
&=	O
DefDepParm	function
(	O
rgszLex	pointer
[	O
i	int
+	O
pifn	pointer
->	O
nDoses	int
]	O
,	O
pifn	pointer
->	O
rgT0s	pointer
+	O
i	int
,	O
pifn	pointer
->	O
rghT0s	pointer
+	O
i	int
)	O
;	O
if	O
(	O
!	O
bOK	int
)	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_EXPECTED	int
|	O
RE_FATAL	int
,	O
"input-spec"	pointer
,	O
NULL	O
)	O
;	O
Exit_GetSpikes	O
:	O
if	O
(	O
bErr	int
)	O
printf	function
(	O
"Syntax: Spikes (nInputs, <n Magnitudes>, <n Times>)\n\n"	pointer
)	O
;	O
return	O
(	O
!	O
bErr	int
)	O
;	O
}	O
BOOL	int
GetInputFn	function
(	O
PINPUTBUF	pointer
pibIn	pointer
,	O
PSTR	pointer
sz	pointer
,	O
PIFN	pointer
pifn	pointer
)	O
{	O
INPUTBUF	struct
ibDummy	struct
;	O
PINPUTBUF	pointer
pibDum	pointer
=	O
&	O
ibDummy	struct
;	O
PSTRLEX	array
szLex	pointer
;	O
int	O
iType	int
;	O
BOOL	int
bReturn	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
pibIn	pointer
||	O
!	O
pifn	pointer
)	O
return	O
(	O
FALSE	int
)	O
;	O
if	O
(	O
sz	pointer
)	O
MakeStringBuffer	function
(	O
pibIn	pointer
,	O
pibDum	pointer
,	O
sz	pointer
)	O
;	O
else	O
pibDum	pointer
=	O
pibIn	pointer
;	O
NextLex	function
(	O
pibDum	pointer
,	O
szLex	pointer
,	O
&	O
iType	int
)	O
;	O
switch	O
(	O
iType	int
)	O
{	O
default	O
:	O
case	O
LX_NULL	int
:	O
case	O
LX_PUNCT	int
:	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"input-spec"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
LX_FLOAT	int
:	O
case	O
LX_INTEGER	int
:	O
case	O
LX_IDENTIFIER	int
:	O
InitIFN	function
(	O
pifn	pointer
)	O
;	O
if	O
(	O
iType	int
==	O
LX_IDENTIFIER	int
)	O
{	O
pifn	pointer
->	O
iType	int
=	O
GetFnType	function
(	O
szLex	pointer
)	O
;	O
switch	O
(	O
pifn	pointer
->	O
iType	int
)	O
{	O
case	O
IFN_NDOSES	int
:	O
bReturn	int
=	O
GetNDoses	function
(	O
pibDum	pointer
,	O
szLex	pointer
,	O
pifn	pointer
)	O
;	O
break	O
;	O
case	O
IFN_SPIKES	int
:	O
bReturn	int
=	O
GetSpikes	function
(	O
pibDum	pointer
,	O
szLex	pointer
,	O
pifn	pointer
)	O
;	O
break	O
;	O
case	O
IFN_EVENTS	int
:	O
bReturn	int
=	O
GetEvents	function
(	O
pibDum	pointer
,	O
szLex	pointer
,	O
pifn	pointer
)	O
;	O
break	O
;	O
default	O
:	O
pifn	pointer
->	O
iType	int
=	O
IFN_NULL	int
;	O
ReportError	function
(	O
pibIn	pointer
,	O
RE_LEXEXPECTED	int
,	O
"input-spec"	pointer
,	O
szLex	pointer
)	O
;	O
break	O
;	O
case	O
IFN_PERDOSE	int
:	O
case	O
IFN_PEREXP	int
:	O
bReturn	int
=	O
GetInputArgs	function
(	O
pibDum	pointer
,	O
pifn	pointer
,	O
4	int
)	O
;	O
break	O
;	O
case	O
IFN_PERTRANS	int
:	O
bReturn	int
=	O
GetInputArgs	function
(	O
pibDum	pointer
,	O
pifn	pointer
,	O
5	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
pifn	pointer
->	O
iType	int
=	O
IFN_CONSTANT	int
;	O
pifn	pointer
->	O
dMag	double
=	O
pifn	pointer
->	O
dVal	double
=	O
atof	function
(	O
szLex	pointer
)	O
;	O
pifn	pointer
->	O
bOn	int
=	O
TRUE	int
;	O
bReturn	int
=	O
TRUE	int
;	O
}	O
break	O
;	O
}	O
return	O
(	O
bReturn	int
)	O
;	O
}	O
