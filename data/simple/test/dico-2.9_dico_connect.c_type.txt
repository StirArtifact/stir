const	O
char	O
*	O
xscript_prefix	array
[	O
]	O
=	O
{	O
"S:"	pointer
,	O
"C:"	pointer
}	O
;	O
static	O
int	O
parse_initial_reply	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
size_t	long
n	long
=	O
0	int
;	O
size_t	long
len	long
;	O
if	O
(	O
!	O
dict_status_p	function
(	O
conn	pointer
,	O
"220"	pointer
)	O
)	O
return	O
1	int
;	O
p	pointer
=	O
strchr	function
(	O
conn	pointer
->	O
buf	pointer
,	O
'<'	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
1	int
;	O
p	pointer
++	O
;	O
while	O
(	O
(	O
len	long
=	O
strcspn	function
(	O
p	pointer
,	O
".>"	pointer
)	O
)	O
)	O
{	O
char	O
*	O
s	long
;	O
if	O
(	O
conn	pointer
->	O
capac	int
==	O
n	long
)	O
{	O
if	O
(	O
n	long
==	O
0	int
)	O
n	long
=	O
2	int
;	O
conn	pointer
->	O
capav	pointer
=	O
x2nrealloc	function
(	O
conn	pointer
->	O
capav	pointer
,	O
&	O
n	long
,	O
sizeof	O
(	O
conn	pointer
->	O
capav	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
s	long
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
s	long
,	O
p	pointer
,	O
len	long
)	O
;	O
s	long
[	O
len	long
]	O
=	O
0	int
;	O
conn	pointer
->	O
capav	pointer
[	O
conn	pointer
->	O
capac	int
++	O
]	O
=	O
s	long
;	O
p	pointer
+=	O
len	long
+	O
1	int
;	O
if	O
(	O
p	pointer
[	O
-	O
1	int
]	O
==	O
'>'	O
)	O
break	O
;	O
}	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
'<'	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
1	int
;	O
len	long
=	O
strcspn	function
(	O
p	pointer
,	O
">"	pointer
)	O
;	O
if	O
(	O
p	pointer
[	O
len	long
]	O
!=	O
'>'	O
)	O
return	O
1	int
;	O
len	long
++	O
;	O
conn	pointer
->	O
msgid	pointer
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
conn	pointer
->	O
msgid	pointer
,	O
p	pointer
,	O
len	long
)	O
;	O
conn	pointer
->	O
msgid	pointer
[	O
len	long
]	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
apop_auth	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
,	O
struct	O
auth_cred	struct
*	O
cred	pointer
)	O
{	O
int	O
i	long
;	O
struct	O
md5_ctx	struct
md5context	struct
;	O
unsigned	O
char	O
md5digest	array
[	O
16	int
]	O
;	O
char	O
buf	pointer
[	O
sizeof	O
(	O
md5digest	array
)	O
*	O
2	int
+	O
1	int
]	O
;	O
char	O
*	O
p	pointer
;	O
md5_init_ctx	function
(	O
&	O
md5context	struct
)	O
;	O
md5_process_bytes	function
(	O
conn	pointer
->	O
msgid	pointer
,	O
strlen	function
(	O
conn	pointer
->	O
msgid	pointer
)	O
,	O
&	O
md5context	struct
)	O
;	O
md5_process_bytes	function
(	O
cred	pointer
->	O
pass	pointer
,	O
strlen	function
(	O
cred	pointer
->	O
pass	pointer
)	O
,	O
&	O
md5context	struct
)	O
;	O
md5_finish_ctx	function
(	O
&	O
md5context	struct
,	O
md5digest	array
)	O
;	O
for	O
(	O
i	long
=	O
0	int
,	O
p	pointer
=	O
buf	pointer
;	O
i	long
<	O
16	int
;	O
i	long
++	O
,	O
p	pointer
+=	O
2	int
)	O
sprintf	function
(	O
p	pointer
,	O
"%02x"	pointer
,	O
md5digest	array
[	O
i	long
]	O
)	O
;	O
*	O
p	pointer
=	O
0	int
;	O
stream_printf	function
(	O
conn	pointer
->	O
str	pointer
,	O
"AUTH %s %s\r\n"	pointer
,	O
cred	pointer
->	O
user	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
dict_read_reply	function
(	O
conn	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"No reply from server"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
dict_status_p	function
(	O
conn	pointer
,	O
"230"	pointer
)	O
==	O
0	int
;	O
}	O
static	O
int	O
dict_auth	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
,	O
dico_url_t	pointer
url	pointer
)	O
{	O
int	O
rc	int
=	O
saslauth	function
(	O
conn	pointer
,	O
url	pointer
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
AUTH_OK	int
:	O
return	O
0	int
;	O
case	O
AUTH_CONT	int
:	O
if	O
(	O
dict_capa	function
(	O
conn	pointer
,	O
"auth"	pointer
)	O
)	O
{	O
struct	O
auth_cred	struct
cred	pointer
;	O
switch	O
(	O
auth_cred_get	function
(	O
url	pointer
->	O
host	pointer
,	O
&	O
cred	pointer
)	O
)	O
{	O
case	O
GETCRED_OK	int
:	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Attempting APOP authentication\n"	pointer
)	O
)	O
;	O
rc	int
=	O
apop_auth	function
(	O
conn	pointer
,	O
&	O
cred	pointer
)	O
;	O
auth_cred_free	function
(	O
&	O
cred	pointer
)	O
;	O
return	O
rc	int
;	O
case	O
GETCRED_FAIL	int
:	O
dico_log	function
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"Not enough credentials for authentication"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
GETCRED_NOAUTH	int
:	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Skipping authentication\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
return	O
0	int
;	O
case	O
AUTH_FAIL	int
:	O
break	O
;	O
}	O
return	O
1	int
;	O
}	O
char	O
*	O
get_homedir	function
(	O
void	O
)	O
{	O
char	O
*	O
homedir	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
!	O
homedir	pointer
)	O
{	O
struct	O
passwd	pointer
*	O
pw	pointer
=	O
getpwuid	function
(	O
geteuid	function
(	O
)	O
)	O
;	O
homedir	pointer
=	O
pw	pointer
->	O
pw_dir	pointer
;	O
}	O
return	O
homedir	pointer
;	O
}	O
int	O
ds_tilde_expand	function
(	O
const	O
char	O
*	O
str	pointer
,	O
char	O
*	O
*	O
output	pointer
)	O
{	O
char	O
*	O
dir	pointer
;	O
if	O
(	O
str	pointer
[	O
0	int
]	O
!=	O
'~'	O
)	O
return	O
0	int
;	O
if	O
(	O
str	pointer
[	O
1	int
]	O
==	O
'/'	O
)	O
{	O
dir	pointer
=	O
get_homedir	function
(	O
)	O
;	O
str	pointer
+=	O
2	int
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
;	O
size_t	long
len	long
;	O
char	O
*	O
name	pointer
;	O
struct	O
passwd	pointer
*	O
pw	pointer
;	O
str	pointer
++	O
;	O
p	pointer
=	O
strchr	function
(	O
str	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
0	int
;	O
len	long
=	O
p	pointer
-	O
str	pointer
;	O
name	pointer
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
name	pointer
,	O
str	pointer
,	O
len	long
)	O
;	O
name	pointer
[	O
len	long
]	O
=	O
0	int
;	O
pw	pointer
=	O
getpwnam	function
(	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
pw	pointer
)	O
{	O
dir	pointer
=	O
pw	pointer
->	O
pw_dir	pointer
;	O
str	pointer
=	O
p	pointer
+	O
1	int
;	O
}	O
}	O
*	O
output	pointer
=	O
dico_full_file_name	function
(	O
dir	pointer
,	O
str	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
auth_cred_dup	function
(	O
struct	O
auth_cred	struct
*	O
dst	pointer
,	O
const	O
struct	O
auth_cred	struct
*	O
src	pointer
)	O
{	O
dst	pointer
->	O
user	pointer
=	O
src	pointer
->	O
user	pointer
?	O
xstrdup	function
(	O
src	pointer
->	O
user	pointer
)	O
:	O
NULL	O
;	O
dst	pointer
->	O
pass	pointer
=	O
src	pointer
->	O
pass	pointer
?	O
xstrdup	function
(	O
src	pointer
->	O
pass	pointer
)	O
:	O
NULL	O
;	O
}	O
void	O
auth_cred_free	function
(	O
struct	O
auth_cred	struct
*	O
cred	pointer
)	O
{	O
free	function
(	O
cred	pointer
->	O
user	pointer
)	O
;	O
free	function
(	O
cred	pointer
->	O
pass	pointer
)	O
;	O
dico_list_destroy	function
(	O
&	O
cred	pointer
->	O
mech	pointer
)	O
;	O
free	function
(	O
cred	pointer
->	O
service	pointer
)	O
;	O
free	function
(	O
cred	pointer
->	O
realm	pointer
)	O
;	O
free	function
(	O
cred	pointer
->	O
hostname	pointer
)	O
;	O
}	O
int	O
auth_cred_get	function
(	O
char	O
*	O
host	pointer
,	O
struct	O
auth_cred	struct
*	O
cred	pointer
)	O
{	O
memset	function
(	O
cred	pointer
,	O
0	int
,	O
sizeof	O
(	O
cred	pointer
[	O
0	int
]	O
)	O
)	O
;	O
auth_cred_dup	function
(	O
cred	pointer
,	O
&	O
default_cred	struct
)	O
;	O
if	O
(	O
default_cred	struct
.	O
user	pointer
&&	O
default_cred	struct
.	O
pass	pointer
)	O
{	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Obtained authentication credentials from the command line\n"	pointer
)	O
)	O
;	O
return	O
GETCRED_OK	int
;	O
}	O
else	O
{	O
int	O
flags	int
=	O
0	int
;	O
if	O
(	O
autologin_file	pointer
)	O
{	O
if	O
(	O
access	function
(	O
autologin_file	pointer
,	O
F_OK	int
)	O
)	O
dico_log	function
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"File %s does not exist"	pointer
)	O
,	O
autologin_file	pointer
)	O
;	O
else	O
parse_autologin	function
(	O
autologin_file	pointer
,	O
host	pointer
,	O
cred	pointer
,	O
&	O
flags	int
)	O
;	O
}	O
if	O
(	O
!	O
flags	int
&&	O
DEFAULT_AUTOLOGIN_FILE	pointer
)	O
{	O
char	O
*	O
home	pointer
=	O
get_homedir	function
(	O
)	O
;	O
char	O
*	O
filename	pointer
=	O
dico_full_file_name	function
(	O
home	pointer
,	O
DEFAULT_AUTOLOGIN_FILE	pointer
)	O
;	O
parse_autologin	function
(	O
filename	pointer
,	O
host	pointer
,	O
cred	pointer
,	O
&	O
flags	int
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
}	O
if	O
(	O
flags	int
&	O
AUTOLOGIN_NOAUTH	int
)	O
return	O
GETCRED_NOAUTH	int
;	O
}	O
if	O
(	O
cred	pointer
->	O
user	pointer
&&	O
!	O
cred	pointer
->	O
pass	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
getpass	function
(	O
_	O
(	O
"Password:"	pointer
)	O
)	O
;	O
cred	pointer
->	O
pass	pointer
=	O
p	pointer
?	O
xstrdup	function
(	O
p	pointer
)	O
:	O
NULL	O
;	O
}	O
return	O
(	O
cred	pointer
->	O
user	pointer
&&	O
cred	pointer
->	O
pass	pointer
)	O
?	O
GETCRED_OK	int
:	O
GETCRED_FAIL	int
;	O
}	O
void	O
dict_transcript	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
,	O
int	O
state	pointer
)	O
{	O
if	O
(	O
state	pointer
==	O
conn	pointer
->	O
transcript	int
)	O
return	O
;	O
if	O
(	O
state	pointer
==	O
0	int
)	O
{	O
dico_stream_t	pointer
transport	pointer
;	O
if	O
(	O
dico_stream_ioctl	function
(	O
conn	pointer
->	O
str	pointer
,	O
DICO_IOCTL_GET_TRANSPORT	int
,	O
&	O
transport	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_CRIT	int
,	O
errno	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: cannot get stream transport"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
dico_stream_ioctl	function
(	O
conn	pointer
->	O
str	pointer
,	O
DICO_IOCTL_SET_TRANSPORT	int
,	O
NULL	O
)	O
)	O
{	O
dico_log	function
(	O
L_CRIT	int
,	O
errno	O
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: cannot set stream transport"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
)	O
;	O
return	O
;	O
}	O
dico_stream_close	function
(	O
conn	pointer
->	O
str	pointer
)	O
;	O
dico_stream_destroy	function
(	O
&	O
conn	pointer
->	O
str	pointer
)	O
;	O
conn	pointer
->	O
str	pointer
=	O
transport	pointer
;	O
conn	pointer
->	O
transcript	int
=	O
state	pointer
;	O
}	O
else	O
{	O
dico_stream_t	pointer
logstr	pointer
=	O
dico_log_stream_create	function
(	O
L_DEBUG	int
)	O
;	O
if	O
(	O
!	O
logstr	pointer
)	O
xalloc_die	function
(	O
)	O
;	O
conn	pointer
->	O
str	pointer
=	O
xdico_transcript_stream_create	function
(	O
conn	pointer
->	O
str	pointer
,	O
logstr	pointer
,	O
xscript_prefix	array
)	O
;	O
conn	pointer
->	O
transcript	int
=	O
state	pointer
;	O
}	O
}	O
static	O
char	O
const	O
*	O
urlstr	pointer
(	O
dico_url_t	pointer
url	pointer
)	O
{	O
if	O
(	O
!	O
url	pointer
->	O
string	pointer
)	O
{	O
if	O
(	O
!	O
url	pointer
->	O
proto	pointer
)	O
xdico_assign_string	function
(	O
&	O
url	pointer
->	O
proto	pointer
,	O
"dict"	pointer
)	O
;	O
if	O
(	O
!	O
url	pointer
->	O
port	pointer
)	O
xdico_assign_string	function
(	O
&	O
url	pointer
->	O
port	pointer
,	O
DICO_DICT_PORT_STR	pointer
)	O
;	O
if	O
(	O
url	pointer
->	O
host	pointer
)	O
{	O
asprintf	function
(	O
&	O
url	pointer
->	O
string	pointer
,	O
"%s://%s:%s"	pointer
,	O
url	pointer
->	O
proto	pointer
,	O
url	pointer
->	O
host	pointer
,	O
url	pointer
->	O
port	pointer
)	O
;	O
}	O
else	O
{	O
asprintf	function
(	O
&	O
url	pointer
->	O
string	pointer
,	O
"%s:///%s"	pointer
,	O
url	pointer
->	O
proto	pointer
,	O
url	pointer
->	O
path	pointer
)	O
;	O
}	O
}	O
return	O
url	pointer
->	O
string	pointer
;	O
}	O
int	O
dict_connect	function
(	O
struct	O
dict_connection	struct
*	O
*	O
pconn	pointer
,	O
dico_url_t	pointer
url	pointer
)	O
{	O
int	O
fd	int
,	O
rc	int
,	O
family	int
;	O
struct	O
addrinfo	struct
hints	struct
,	O
*	O
res	pointer
,	O
*	O
rp	pointer
;	O
dico_stream_t	pointer
str	pointer
;	O
struct	O
dict_connection	struct
*	O
conn	pointer
;	O
char	O
const	O
*	O
port	pointer
=	O
url	pointer
->	O
port	pointer
?	O
url	pointer
->	O
port	pointer
:	O
DICO_DICT_PORT_STR	pointer
;	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
_	O
(	O
"Connecting to %s\n"	pointer
)	O
,	O
urlstr	pointer
(	O
url	pointer
)	O
)	O
;	O
if	O
(	O
source_addr	pointer
)	O
{	O
memset	function
(	O
&	O
hints	struct
,	O
0	int
,	O
sizeof	O
(	O
hints	struct
)	O
)	O
;	O
hints	struct
.	O
ai_socktype	int
=	O
SOCK_STREAM	int
;	O
rc	int
=	O
getaddrinfo	function
(	O
source_addr	pointer
,	O
NULL	O
,	O
&	O
hints	struct
,	O
&	O
res	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"bad source address: %s"	pointer
)	O
,	O
gai_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
rp	pointer
=	O
res	pointer
;	O
rp	pointer
;	O
rp	pointer
=	O
rp	pointer
->	O
ai_next	pointer
)	O
{	O
fd	int
=	O
socket	function
(	O
rp	pointer
->	O
ai_family	int
,	O
rp	pointer
->	O
ai_socktype	int
,	O
rp	pointer
->	O
ai_protocol	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
continue	O
;	O
if	O
(	O
bind	function
(	O
fd	int
,	O
rp	pointer
->	O
ai_addr	pointer
,	O
rp	pointer
->	O
ai_addrlen	int
)	O
==	O
0	int
)	O
break	O
;	O
close	function
(	O
fd	int
)	O
;	O
}	O
if	O
(	O
!	O
rp	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"can't bind to the source address"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
fd	int
=	O
-	O
1	int
;	O
}	O
memset	function
(	O
&	O
hints	struct
,	O
0	int
,	O
sizeof	O
(	O
hints	struct
)	O
)	O
;	O
hints	struct
.	O
ai_socktype	int
=	O
SOCK_STREAM	int
;	O
if	O
(	O
url	pointer
->	O
host	pointer
)	O
{	O
rc	int
=	O
getaddrinfo	function
(	O
url	pointer
->	O
host	pointer
,	O
port	pointer
,	O
&	O
hints	struct
,	O
&	O
res	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: can't get address: %s"	pointer
)	O
,	O
url	pointer
->	O
host	pointer
,	O
gai_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
struct	O
sockaddr_un	struct
*	O
s	long
;	O
if	O
(	O
strlen	function
(	O
url	pointer
->	O
path	pointer
)	O
>=	O
sizeof	O
s	long
->	O
sun_path	array
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: UNIX socket name too long"	pointer
)	O
,	O
url	pointer
->	O
path	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
hints	struct
.	O
ai_family	int
=	O
AF_UNIX	O
;	O
hints	struct
.	O
ai_addrlen	int
=	O
sizeof	O
(	O
struct	O
sockaddr_un	struct
)	O
;	O
s	long
=	O
xcalloc	function
(	O
1	int
,	O
hints	struct
.	O
ai_addrlen	int
)	O
;	O
s	long
->	O
sun_family	short
=	O
AF_UNIX	O
;	O
strcpy	function
(	O
s	long
->	O
sun_path	array
,	O
url	pointer
->	O
path	pointer
)	O
;	O
hints	struct
.	O
ai_addr	pointer
=	O
(	O
struct	O
sockaddr	struct
*	O
)	O
s	long
;	O
res	pointer
=	O
&	O
hints	struct
;	O
}	O
for	O
(	O
rp	pointer
=	O
res	pointer
;	O
rp	pointer
;	O
rp	pointer
=	O
rp	pointer
->	O
ai_next	pointer
)	O
{	O
if	O
(	O
fd	int
!=	O
-	O
1	int
&&	O
family	int
!=	O
rp	pointer
->	O
ai_family	int
)	O
{	O
close	function
(	O
fd	int
)	O
;	O
fd	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
family	int
=	O
rp	pointer
->	O
ai_family	int
;	O
fd	int
=	O
socket	function
(	O
family	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot create dict socket"	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
connect	function
(	O
fd	int
,	O
rp	pointer
->	O
ai_addr	pointer
,	O
rp	pointer
->	O
ai_addrlen	int
)	O
!=	O
-	O
1	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
rp	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: cannot connect"	pointer
)	O
,	O
urlstr	pointer
(	O
url	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
res	pointer
==	O
&	O
hints	struct
)	O
free	function
(	O
res	pointer
->	O
ai_addr	pointer
)	O
;	O
else	O
freeaddrinfo	function
(	O
res	pointer
)	O
;	O
if	O
(	O
(	O
str	pointer
=	O
dico_fd_io_stream_create	function
(	O
fd	int
,	O
fd	int
)	O
)	O
==	O
NULL	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
errno	O
,	O
_	O
(	O
"cannot create dict stream: %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
conn	pointer
=	O
xzalloc	function
(	O
sizeof	O
(	O
*	O
conn	pointer
)	O
)	O
;	O
conn	pointer
->	O
str	pointer
=	O
str	pointer
;	O
conn	pointer
->	O
fd	int
=	O
fd	int
;	O
dict_transcript	function
(	O
conn	pointer
,	O
transcript	int
)	O
;	O
if	O
(	O
dict_read_reply	function
(	O
conn	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"No reply from server"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
parse_initial_reply	function
(	O
conn	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"Invalid reply from server"	pointer
)	O
)	O
;	O
dict_conn_close	function
(	O
conn	pointer
)	O
;	O
return	O
1	int
;	O
}	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Sending client information\n"	pointer
)	O
)	O
;	O
stream_printf	function
(	O
conn	pointer
->	O
str	pointer
,	O
"CLIENT \"%s\"\r\n"	pointer
,	O
client	pointer
)	O
;	O
dict_read_reply	function
(	O
conn	pointer
)	O
;	O
if	O
(	O
!	O
dict_status_p	function
(	O
conn	pointer
,	O
"250"	pointer
)	O
)	O
dico_log	function
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"Unexpected reply to CLIENT command: `%s'"	pointer
)	O
,	O
conn	pointer
->	O
buf	pointer
)	O
;	O
obstack_init	O
(	O
&	O
conn	pointer
->	O
stk	struct
)	O
;	O
if	O
(	O
!	O
noauth_option	int
&&	O
dict_auth	function
(	O
conn	pointer
,	O
url	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"Authentication failed"	pointer
)	O
)	O
;	O
dict_conn_close	function
(	O
conn	pointer
)	O
;	O
return	O
1	int
;	O
}	O
*	O
pconn	pointer
=	O
conn	pointer
;	O
return	O
0	int
;	O
}	O
int	O
dict_read_reply	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
conn	pointer
->	O
buf	pointer
)	O
conn	pointer
->	O
buf	pointer
[	O
0	int
]	O
=	O
0	int
;	O
rc	int
=	O
dico_stream_getline	function
(	O
conn	pointer
->	O
str	pointer
,	O
&	O
conn	pointer
->	O
buf	pointer
,	O
&	O
conn	pointer
->	O
size	long
,	O
&	O
conn	pointer
->	O
level	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
conn	pointer
->	O
level	int
=	O
dico_trim_nl	function
(	O
conn	pointer
->	O
buf	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
dict_status_p	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
,	O
const	O
char	O
*	O
status	int
)	O
{	O
return	O
conn	pointer
->	O
level	int
>	O
3	int
&&	O
memcmp	function
(	O
conn	pointer
->	O
buf	pointer
,	O
status	int
,	O
3	int
)	O
==	O
0	int
&&	O
(	O
isspace	function
(	O
conn	pointer
->	O
buf	pointer
[	O
3	int
]	O
)	O
||	O
(	O
conn	pointer
->	O
level	int
==	O
5	int
&&	O
memcmp	function
(	O
conn	pointer
->	O
buf	pointer
+	O
3	int
,	O
"\r\n"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
)	O
;	O
}	O
int	O
dict_capa	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
,	O
char	O
*	O
capa	pointer
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
conn	pointer
->	O
capac	int
;	O
i	long
++	O
)	O
if	O
(	O
strcmp	function
(	O
conn	pointer
->	O
capav	pointer
[	O
i	long
]	O
,	O
capa	pointer
)	O
==	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
dict_multiline_reply	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
)	O
{	O
int	O
rc	int
;	O
size_t	long
nlines	long
=	O
0	int
;	O
while	O
(	O
(	O
rc	int
=	O
dict_read_reply	function
(	O
conn	pointer
)	O
)	O
==	O
0	int
)	O
{	O
char	O
*	O
ptr	pointer
=	O
conn	pointer
->	O
buf	pointer
;	O
size_t	long
len	long
=	O
conn	pointer
->	O
level	int
;	O
if	O
(	O
*	O
ptr	pointer
==	O
'.'	O
)	O
{	O
if	O
(	O
ptr	pointer
[	O
1	int
]	O
==	O
0	int
)	O
break	O
;	O
else	O
if	O
(	O
ptr	pointer
[	O
1	int
]	O
==	O
'.'	O
)	O
{	O
ptr	pointer
++	O
;	O
len	long
--	O
;	O
}	O
}	O
obstack_grow	O
(	O
&	O
conn	pointer
->	O
stk	struct
,	O
ptr	pointer
,	O
len	long
)	O
;	O
obstack_1grow	O
(	O
&	O
conn	pointer
->	O
stk	struct
,	O
'\n'	O
)	O
;	O
nlines	long
++	O
;	O
}	O
obstack_1grow	O
(	O
&	O
conn	pointer
->	O
stk	struct
,	O
0	int
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
dict_define	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
,	O
char	O
*	O
database	pointer
,	O
char	O
*	O
word	pointer
)	O
{	O
int	O
rc	int
;	O
XDICO_DEBUG_F2	O
(	O
1	int
,	O
_	O
(	O
"Sending query for word \"%s\" in database \"%s\"\n"	pointer
)	O
,	O
word	pointer
,	O
database	pointer
)	O
;	O
stream_printf	function
(	O
conn	pointer
->	O
str	pointer
,	O
"DEFINE \"%s\" \"%s\"\r\n"	pointer
,	O
quotearg_n	function
(	O
0	int
,	O
database	pointer
)	O
,	O
quotearg_n	function
(	O
1	int
,	O
word	pointer
)	O
)	O
;	O
dict_read_reply	function
(	O
conn	pointer
)	O
;	O
if	O
(	O
dict_status_p	function
(	O
conn	pointer
,	O
"150"	pointer
)	O
)	O
{	O
unsigned	O
long	O
i	long
,	O
count	long
;	O
char	O
*	O
p	pointer
;	O
count	long
=	O
strtoul	function
(	O
conn	pointer
->	O
buf	pointer
+	O
3	int
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
ngettext	function
(	O
"Reading %lu definition\n"	pointer
,	O
"Reading %lu definitions\n"	pointer
,	O
count	long
)	O
,	O
count	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
count	long
;	O
i	long
++	O
)	O
{	O
dict_read_reply	function
(	O
conn	pointer
)	O
;	O
if	O
(	O
!	O
dict_status_p	function
(	O
conn	pointer
,	O
"151"	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"Unexpected reply in place of definition %lu"	pointer
)	O
,	O
i	long
)	O
;	O
break	O
;	O
}	O
obstack_grow	O
(	O
&	O
conn	pointer
->	O
stk	struct
,	O
conn	pointer
->	O
buf	pointer
,	O
conn	pointer
->	O
level	int
)	O
;	O
obstack_1grow	O
(	O
&	O
conn	pointer
->	O
stk	struct
,	O
0	int
)	O
;	O
dict_multiline_reply	function
(	O
conn	pointer
)	O
;	O
}	O
dict_read_reply	function
(	O
conn	pointer
)	O
;	O
dict_result_create	function
(	O
conn	pointer
,	O
dict_result_define	int
,	O
count	long
,	O
obstack_finish	O
(	O
&	O
conn	pointer
->	O
stk	struct
)	O
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
else	O
rc	int
=	O
1	int
;	O
return	O
rc	int
;	O
}	O
int	O
dict_match	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
,	O
char	O
*	O
database	pointer
,	O
char	O
*	O
strategy	pointer
,	O
char	O
*	O
word	pointer
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
levenshtein_threshold	int
&&	O
conn	pointer
->	O
levdist	long
!=	O
levenshtein_threshold	int
&&	O
dict_capa	function
(	O
conn	pointer
,	O
"xlev"	pointer
)	O
)	O
{	O
XDICO_DEBUG	O
(	O
1	int
,	O
_	O
(	O
"Setting Levenshtein threshold\n"	pointer
)	O
)	O
;	O
stream_printf	function
(	O
conn	pointer
->	O
str	pointer
,	O
"XLEV %u\n"	pointer
,	O
levenshtein_threshold	int
)	O
;	O
dict_read_reply	function
(	O
conn	pointer
)	O
;	O
if	O
(	O
dict_status_p	function
(	O
conn	pointer
,	O
"250"	pointer
)	O
)	O
conn	pointer
->	O
levdist	long
=	O
levenshtein_threshold	int
;	O
else	O
{	O
dico_log	function
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"Server rejected XLEV command"	pointer
)	O
)	O
;	O
dico_log	function
(	O
L_WARN	int
,	O
0	int
,	O
_	O
(	O
"Server reply: %s"	pointer
)	O
,	O
conn	pointer
->	O
buf	pointer
)	O
;	O
}	O
}	O
XDICO_DEBUG_F3	O
(	O
1	int
,	O
_	O
(	O
"Sending query to match word \"%s\" in "	pointer
"database \"%s\", "	pointer
"using \"%s\"\n"	pointer
)	O
,	O
word	pointer
,	O
database	pointer
,	O
strategy	pointer
)	O
;	O
stream_printf	function
(	O
conn	pointer
->	O
str	pointer
,	O
"MATCH \"%s\" \"%s\" \"%s\"\r\n"	pointer
,	O
quotearg_n	function
(	O
0	int
,	O
database	pointer
)	O
,	O
quotearg_n	function
(	O
1	int
,	O
strategy	pointer
)	O
,	O
quotearg_n	function
(	O
2	int
,	O
word	pointer
)	O
)	O
;	O
dict_read_reply	function
(	O
conn	pointer
)	O
;	O
if	O
(	O
dict_status_p	function
(	O
conn	pointer
,	O
"152"	pointer
)	O
)	O
{	O
unsigned	O
long	O
count	long
;	O
char	O
*	O
p	pointer
;	O
count	long
=	O
strtoul	function
(	O
conn	pointer
->	O
buf	pointer
+	O
3	int
,	O
&	O
p	pointer
,	O
10	int
)	O
;	O
XDICO_DEBUG_F1	O
(	O
1	int
,	O
ngettext	function
(	O
"Reading %lu match\n"	pointer
,	O
"Reading %lu matches\n"	pointer
,	O
count	long
)	O
,	O
count	long
)	O
;	O
dict_multiline_reply	function
(	O
conn	pointer
)	O
;	O
dict_result_create	function
(	O
conn	pointer
,	O
dict_result_match	int
,	O
count	long
,	O
obstack_finish	O
(	O
&	O
conn	pointer
->	O
stk	struct
)	O
)	O
;	O
dict_read_reply	function
(	O
conn	pointer
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
else	O
rc	int
=	O
1	int
;	O
return	O
rc	int
;	O
}	O
static	O
size_t	long
count_lines	function
(	O
char	O
*	O
p	pointer
)	O
{	O
size_t	long
count	long
=	O
0	int
;	O
while	O
(	O
(	O
p	pointer
=	O
strchr	function
(	O
p	pointer
,	O
'\n'	O
)	O
)	O
)	O
{	O
count	long
++	O
;	O
p	pointer
++	O
;	O
}	O
return	O
count	long
;	O
}	O
static	O
void	O
_result_parse_def	function
(	O
struct	O
dict_result	struct
*	O
res	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
size_t	long
i	long
;	O
struct	O
define_result	struct
*	O
def	pointer
=	O
xcalloc	function
(	O
res	pointer
->	O
count	long
,	O
sizeof	O
(	O
*	O
def	pointer
)	O
)	O
;	O
struct	O
dico_tokbuf	struct
tb	pointer
;	O
dico_tokenize_begin	function
(	O
&	O
tb	pointer
)	O
;	O
res	pointer
->	O
set	union
.	O
def	pointer
=	O
def	pointer
;	O
p	pointer
=	O
res	pointer
->	O
base	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
res	pointer
->	O
count	long
;	O
i	long
++	O
,	O
def	pointer
++	O
)	O
{	O
xdico_tokenize_string	function
(	O
&	O
tb	pointer
,	O
p	pointer
)	O
;	O
def	pointer
->	O
word	pointer
=	O
xstrdup	function
(	O
tb	pointer
.	O
tb_tokv	pointer
[	O
1	int
]	O
)	O
;	O
def	pointer
->	O
database	pointer
=	O
xstrdup	function
(	O
tb	pointer
.	O
tb_tokv	pointer
[	O
2	int
]	O
)	O
;	O
def	pointer
->	O
descr	pointer
=	O
xstrdup	function
(	O
tb	pointer
.	O
tb_tokv	pointer
[	O
3	int
]	O
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
;	O
def	pointer
->	O
defn	pointer
=	O
p	pointer
;	O
def	pointer
->	O
nlines	long
=	O
count_lines	function
(	O
p	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
;	O
}	O
dico_tokenize_end	function
(	O
&	O
tb	pointer
)	O
;	O
}	O
static	O
void	O
_result_free_def	function
(	O
struct	O
dict_result	struct
*	O
res	pointer
)	O
{	O
size_t	long
i	long
;	O
struct	O
define_result	struct
*	O
def	pointer
=	O
res	pointer
->	O
set	union
.	O
def	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
res	pointer
->	O
count	long
;	O
i	long
++	O
,	O
def	pointer
++	O
)	O
{	O
free	function
(	O
def	pointer
->	O
word	pointer
)	O
;	O
free	function
(	O
def	pointer
->	O
database	pointer
)	O
;	O
free	function
(	O
def	pointer
->	O
descr	pointer
)	O
;	O
}	O
free	function
(	O
res	pointer
->	O
set	union
.	O
def	pointer
)	O
;	O
}	O
static	O
void	O
_result_parse_mat	function
(	O
struct	O
dict_result	struct
*	O
res	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
size_t	long
i	long
;	O
struct	O
match_result	struct
*	O
mat	pointer
=	O
xcalloc	function
(	O
res	pointer
->	O
count	long
,	O
sizeof	O
(	O
*	O
mat	pointer
)	O
)	O
;	O
res	pointer
->	O
set	union
.	O
mat	pointer
=	O
mat	pointer
;	O
for	O
(	O
i	long
=	O
0	int
,	O
p	pointer
=	O
strtok	function
(	O
res	pointer
->	O
base	int
,	O
"\n"	pointer
)	O
;	O
i	long
<	O
res	pointer
->	O
count	long
;	O
p	pointer
=	O
strtok	function
(	O
NULL	O
,	O
"\n"	pointer
)	O
,	O
i	long
++	O
,	O
mat	pointer
++	O
)	O
{	O
size_t	long
len	long
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
dico_log	function
(	O
L_NOTICE	int
,	O
0	int
,	O
_	O
(	O
"Not enough data in the result"	pointer
)	O
)	O
;	O
res	pointer
->	O
count	long
=	O
i	long
;	O
break	O
;	O
}	O
mat	pointer
->	O
database	pointer
=	O
p	pointer
;	O
len	long
=	O
strcspn	function
(	O
p	pointer
,	O
" \t"	pointer
)	O
;	O
p	pointer
[	O
len	long
]	O
=	O
0	int
;	O
p	pointer
+=	O
len	long
+	O
1	int
;	O
p	pointer
+=	O
strspn	function
(	O
p	pointer
,	O
" \t"	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
==	O
'"'	O
&&	O
p	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'"'	O
)	O
{	O
p	pointer
[	O
len	long
-	O
1	int
]	O
=	O
0	int
;	O
p	pointer
++	O
;	O
}	O
mat	pointer
->	O
word	pointer
=	O
p	pointer
;	O
}	O
}	O
static	O
void	O
_result_free_mat	function
(	O
struct	O
dict_result	struct
*	O
res	pointer
)	O
{	O
free	function
(	O
res	pointer
->	O
set	union
.	O
mat	pointer
)	O
;	O
}	O
struct	O
dict_result	struct
*	O
dict_result_create	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
,	O
enum	O
dict_result_type	enum
type	enum
,	O
size_t	long
count	long
,	O
char	O
*	O
base	int
)	O
{	O
struct	O
dict_result	struct
*	O
res	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
res	pointer
)	O
)	O
;	O
res	pointer
->	O
conn	pointer
=	O
conn	pointer
;	O
res	pointer
->	O
prev	pointer
=	O
conn	pointer
->	O
last_result	pointer
;	O
conn	pointer
->	O
last_result	pointer
=	O
res	pointer
;	O
res	pointer
->	O
type	enum
=	O
type	enum
;	O
res	pointer
->	O
count	long
=	O
count	long
;	O
res	pointer
->	O
base	int
=	O
base	int
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
dict_result_define	int
:	O
_result_parse_def	function
(	O
res	pointer
)	O
;	O
break	O
;	O
case	O
dict_result_match	int
:	O
_result_parse_mat	function
(	O
res	pointer
)	O
;	O
break	O
;	O
case	O
dict_result_text	int
:	O
break	O
;	O
}	O
return	O
res	pointer
;	O
}	O
void	O
dict_result_free	function
(	O
struct	O
dict_result	struct
*	O
res	pointer
)	O
{	O
if	O
(	O
!	O
res	pointer
)	O
return	O
;	O
if	O
(	O
res	pointer
==	O
res	pointer
->	O
conn	pointer
->	O
last_result	pointer
)	O
{	O
obstack_free	O
(	O
&	O
res	pointer
->	O
conn	pointer
->	O
stk	struct
,	O
res	pointer
->	O
base	int
)	O
;	O
res	pointer
->	O
conn	pointer
->	O
last_result	pointer
=	O
res	pointer
->	O
prev	pointer
;	O
}	O
else	O
{	O
struct	O
dict_result	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
res	pointer
->	O
conn	pointer
->	O
last_result	pointer
;	O
p	pointer
&&	O
p	pointer
->	O
prev	pointer
!=	O
res	pointer
;	O
p	pointer
=	O
p	pointer
->	O
prev	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
dico_log	function
(	O
L_CRIT	int
,	O
0	int
,	O
_	O
(	O
"Freeing unlinked result"	pointer
)	O
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
p	pointer
->	O
prev	pointer
=	O
res	pointer
->	O
prev	pointer
;	O
}	O
switch	O
(	O
res	pointer
->	O
type	enum
)	O
{	O
case	O
dict_result_define	int
:	O
_result_free_def	function
(	O
res	pointer
)	O
;	O
break	O
;	O
case	O
dict_result_match	int
:	O
_result_free_mat	function
(	O
res	pointer
)	O
;	O
break	O
;	O
case	O
dict_result_text	int
:	O
break	O
;	O
}	O
free	function
(	O
res	pointer
)	O
;	O
}	O
void	O
dict_conn_close	function
(	O
struct	O
dict_connection	struct
*	O
conn	pointer
)	O
{	O
struct	O
dict_result	struct
*	O
res	pointer
;	O
dico_stream_close	function
(	O
conn	pointer
->	O
str	pointer
)	O
;	O
dico_stream_destroy	function
(	O
&	O
conn	pointer
->	O
str	pointer
)	O
;	O
free	function
(	O
conn	pointer
->	O
msgid	pointer
)	O
;	O
free	function
(	O
conn	pointer
->	O
buf	pointer
)	O
;	O
dico_argcv_free	function
(	O
conn	pointer
->	O
capac	int
,	O
conn	pointer
->	O
capav	pointer
)	O
;	O
for	O
(	O
res	pointer
=	O
conn	pointer
->	O
last_result	pointer
;	O
res	pointer
;	O
)	O
{	O
struct	O
dict_result	struct
*	O
prev	pointer
=	O
res	pointer
->	O
prev	pointer
;	O
dict_result_free	function
(	O
res	pointer
)	O
;	O
res	pointer
=	O
prev	pointer
;	O
}	O
obstack_free	O
(	O
&	O
conn	pointer
->	O
stk	struct
,	O
NULL	O
)	O
;	O
free	function
(	O
conn	pointer
)	O
;	O
}	O
