char	O
*	O
info_parsed_filename	pointer
=	O
NULL	O
;	O
char	O
*	O
info_parsed_nodename	pointer
=	O
NULL	O
;	O
int	O
read_bracketed_filename	function
(	O
char	O
*	O
string	pointer
,	O
char	O
*	O
*	O
filename	pointer
)	O
{	O
register	O
int	O
i	int
=	O
0	int
;	O
int	O
count	pointer
=	O
0	int
;	O
int	O
first_close	int
=	O
-	O
1	int
;	O
if	O
(	O
*	O
string	pointer
!=	O
'('	O
)	O
return	O
0	int
;	O
string	pointer
++	O
;	O
count	pointer
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
string	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
string	pointer
[	O
i	int
]	O
==	O
'('	O
)	O
count	pointer
++	O
;	O
else	O
if	O
(	O
string	pointer
[	O
i	int
]	O
==	O
')'	O
)	O
{	O
if	O
(	O
first_close	int
==	O
-	O
1	int
)	O
first_close	int
=	O
i	int
;	O
count	pointer
--	O
;	O
if	O
(	O
count	pointer
==	O
0	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
count	pointer
>	O
0	int
)	O
{	O
if	O
(	O
first_close	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
filename	pointer
)	O
*	O
filename	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
i	int
=	O
first_close	int
;	O
}	O
if	O
(	O
filename	pointer
)	O
{	O
*	O
filename	pointer
=	O
xcalloc	function
(	O
1	int
,	O
i	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
*	O
filename	pointer
,	O
string	pointer
,	O
i	int
)	O
;	O
}	O
return	O
i	int
+	O
2	int
;	O
}	O
void	O
info_parse_node	function
(	O
char	O
*	O
string	pointer
)	O
{	O
int	O
nodename_len	int
;	O
free	function
(	O
info_parsed_filename	pointer
)	O
;	O
free	function
(	O
info_parsed_nodename	pointer
)	O
;	O
info_parsed_filename	pointer
=	O
0	int
;	O
info_parsed_nodename	pointer
=	O
0	int
;	O
if	O
(	O
!	O
string	pointer
||	O
!	O
*	O
string	pointer
)	O
return	O
;	O
string	pointer
+=	O
skip_whitespace_and_newlines	function
(	O
string	pointer
)	O
;	O
string	pointer
+=	O
read_bracketed_filename	function
(	O
string	pointer
,	O
&	O
info_parsed_filename	pointer
)	O
;	O
string	pointer
+=	O
skip_whitespace_and_newlines	function
(	O
string	pointer
)	O
;	O
nodename_len	int
=	O
read_quoted_string	function
(	O
string	pointer
,	O
""	pointer
,	O
0	int
,	O
&	O
info_parsed_nodename	pointer
)	O
;	O
if	O
(	O
nodename_len	int
!=	O
0	int
)	O
{	O
canonicalize_whitespace	function
(	O
info_parsed_nodename	pointer
)	O
;	O
}	O
}	O
long	O
read_quoted_string	function
(	O
char	O
*	O
start	int
,	O
char	O
*	O
terminator	pointer
,	O
int	O
lines	int
,	O
char	O
*	O
*	O
output	pointer
)	O
{	O
long	O
len	long
;	O
char	O
*	O
nl	pointer
=	O
0	int
,	O
saved_char	char
;	O
if	O
(	O
lines	int
)	O
{	O
int	O
i	int
;	O
nl	pointer
=	O
start	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
lines	int
;	O
i	int
++	O
)	O
{	O
nl	pointer
=	O
strchr	function
(	O
nl	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
nl	pointer
)	O
break	O
;	O
nl	pointer
++	O
;	O
}	O
if	O
(	O
nl	pointer
)	O
{	O
saved_char	char
=	O
*	O
nl	pointer
;	O
*	O
nl	pointer
=	O
'\0'	O
;	O
}	O
}	O
if	O
(	O
start	int
[	O
0	int
]	O
!=	O
'\177'	O
)	O
{	O
len	long
=	O
strcspn	function
(	O
start	int
,	O
terminator	pointer
)	O
;	O
if	O
(	O
*	O
terminator	pointer
&&	O
!	O
start	int
[	O
len	long
]	O
)	O
{	O
len	long
=	O
0	int
;	O
*	O
output	pointer
=	O
0	int
;	O
}	O
else	O
{	O
*	O
output	pointer
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
*	O
output	pointer
,	O
start	int
,	O
len	long
)	O
;	O
(	O
*	O
output	pointer
)	O
[	O
len	long
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
{	O
len	long
=	O
strcspn	function
(	O
start	int
+	O
1	int
,	O
"\177"	pointer
)	O
;	O
if	O
(	O
*	O
terminator	pointer
&&	O
!	O
(	O
start	int
+	O
1	int
)	O
[	O
len	long
]	O
)	O
{	O
len	long
=	O
0	int
;	O
*	O
output	pointer
=	O
0	int
;	O
}	O
else	O
{	O
*	O
output	pointer
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
*	O
output	pointer
,	O
start	int
+	O
1	int
,	O
len	long
)	O
;	O
(	O
*	O
output	pointer
)	O
[	O
len	long
]	O
=	O
'\0'	O
;	O
len	long
+=	O
2	int
;	O
}	O
}	O
if	O
(	O
nl	pointer
)	O
*	O
nl	pointer
=	O
saved_char	char
;	O
return	O
len	long
;	O
}	O
REFERENCE	struct
*	O
info_get_menu_entry_by_label	function
(	O
NODE	struct
*	O
node	pointer
,	O
char	O
*	O
label	pointer
,	O
int	O
sloppy	int
)	O
{	O
register	O
int	O
i	int
;	O
int	O
best_guess	int
=	O
-	O
1	int
;	O
REFERENCE	struct
*	O
entry	pointer
;	O
REFERENCE	struct
*	O
*	O
references	pointer
=	O
node	pointer
->	O
references	pointer
;	O
if	O
(	O
!	O
references	pointer
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
entry	pointer
=	O
references	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
entry	pointer
->	O
type	enum
!=	O
REFERENCE_MENU_ITEM	int
)	O
continue	O
;	O
if	O
(	O
mbscasecmp	function
(	O
label	pointer
,	O
entry	pointer
->	O
label	pointer
)	O
==	O
0	int
)	O
return	O
entry	pointer
;	O
else	O
if	O
(	O
sloppy	int
&&	O
best_guess	int
==	O
-	O
1	int
&&	O
(	O
mbsncasecmp	function
(	O
entry	pointer
->	O
label	pointer
,	O
label	pointer
,	O
strlen	function
(	O
label	pointer
)	O
)	O
==	O
0	int
)	O
)	O
best_guess	int
=	O
i	int
;	O
}	O
if	O
(	O
sloppy	int
&&	O
best_guess	int
!=	O
-	O
1	int
)	O
return	O
references	pointer
[	O
best_guess	int
]	O
;	O
return	O
0	int
;	O
}	O
REFERENCE	struct
*	O
*	O
info_concatenate_references	function
(	O
REFERENCE	struct
*	O
*	O
ref1	pointer
,	O
REFERENCE	struct
*	O
*	O
ref2	pointer
)	O
{	O
register	O
int	O
i	int
,	O
j	int
;	O
REFERENCE	struct
*	O
*	O
result	pointer
;	O
int	O
size	long
=	O
0	int
;	O
if	O
(	O
ref1	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
ref1	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
size	long
+=	O
i	int
;	O
}	O
if	O
(	O
ref2	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
ref2	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
size	long
+=	O
i	int
;	O
}	O
result	pointer
=	O
xmalloc	function
(	O
(	O
1	int
+	O
size	long
)	O
*	O
sizeof	O
(	O
REFERENCE	struct
*	O
)	O
)	O
;	O
j	int
=	O
0	int
;	O
if	O
(	O
ref1	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
ref1	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
result	pointer
[	O
j	int
++	O
]	O
=	O
ref1	pointer
[	O
i	int
]	O
;	O
}	O
if	O
(	O
ref2	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
ref2	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
result	pointer
[	O
j	int
++	O
]	O
=	O
ref2	pointer
[	O
i	int
]	O
;	O
}	O
result	pointer
[	O
j	int
]	O
=	O
NULL	O
;	O
return	O
result	pointer
;	O
}	O
REFERENCE	struct
*	O
info_copy_reference	function
(	O
REFERENCE	struct
*	O
src	pointer
)	O
{	O
REFERENCE	struct
*	O
dest	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
REFERENCE	struct
)	O
)	O
;	O
dest	pointer
->	O
label	pointer
=	O
src	pointer
->	O
label	pointer
?	O
xstrdup	function
(	O
src	pointer
->	O
label	pointer
)	O
:	O
NULL	O
;	O
dest	pointer
->	O
filename	pointer
=	O
src	pointer
->	O
filename	pointer
?	O
xstrdup	function
(	O
src	pointer
->	O
filename	pointer
)	O
:	O
NULL	O
;	O
dest	pointer
->	O
nodename	pointer
=	O
src	pointer
->	O
nodename	pointer
?	O
xstrdup	function
(	O
src	pointer
->	O
nodename	pointer
)	O
:	O
NULL	O
;	O
dest	pointer
->	O
start	int
=	O
src	pointer
->	O
start	int
;	O
dest	pointer
->	O
end	int
=	O
src	pointer
->	O
end	int
;	O
dest	pointer
->	O
line_number	long
=	O
src	pointer
->	O
line_number	long
;	O
dest	pointer
->	O
type	enum
=	O
src	pointer
->	O
type	enum
;	O
return	O
dest	pointer
;	O
}	O
REFERENCE	struct
*	O
*	O
info_copy_references	function
(	O
REFERENCE	struct
*	O
*	O
ref1	pointer
)	O
{	O
int	O
i	int
;	O
REFERENCE	struct
*	O
*	O
result	pointer
;	O
int	O
size	long
;	O
if	O
(	O
!	O
ref1	pointer
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
ref1	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
size	long
=	O
i	int
;	O
result	pointer
=	O
xmalloc	function
(	O
(	O
1	int
+	O
size	long
)	O
*	O
sizeof	O
(	O
REFERENCE	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
ref1	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
result	pointer
[	O
i	int
]	O
=	O
info_copy_reference	function
(	O
ref1	pointer
[	O
i	int
]	O
)	O
;	O
result	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
return	O
result	pointer
;	O
}	O
void	O
info_reference_free	function
(	O
REFERENCE	struct
*	O
ref	pointer
)	O
{	O
if	O
(	O
ref	pointer
)	O
{	O
free	function
(	O
ref	pointer
->	O
label	pointer
)	O
;	O
free	function
(	O
ref	pointer
->	O
filename	pointer
)	O
;	O
free	function
(	O
ref	pointer
->	O
nodename	pointer
)	O
;	O
free	function
(	O
ref	pointer
)	O
;	O
}	O
}	O
void	O
info_free_references	function
(	O
REFERENCE	struct
*	O
*	O
references	pointer
)	O
{	O
register	O
int	O
i	int
;	O
REFERENCE	struct
*	O
entry	pointer
;	O
if	O
(	O
references	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
references	pointer
&&	O
(	O
entry	pointer
=	O
references	pointer
[	O
i	int
]	O
)	O
;	O
i	int
++	O
)	O
info_reference_free	function
(	O
entry	pointer
)	O
;	O
free	function
(	O
references	pointer
)	O
;	O
}	O
}	O
REFERENCE	struct
*	O
info_new_reference	function
(	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
nodename	pointer
)	O
{	O
REFERENCE	struct
*	O
r	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
REFERENCE	struct
)	O
)	O
;	O
r	pointer
->	O
label	pointer
=	O
0	int
;	O
r	pointer
->	O
filename	pointer
=	O
filename	pointer
?	O
xstrdup	function
(	O
filename	pointer
)	O
:	O
0	int
;	O
r	pointer
->	O
nodename	pointer
=	O
nodename	pointer
?	O
xstrdup	function
(	O
nodename	pointer
)	O
:	O
0	int
;	O
r	pointer
->	O
start	int
=	O
0	int
;	O
r	pointer
->	O
end	int
=	O
0	int
;	O
r	pointer
->	O
line_number	long
=	O
0	int
;	O
r	pointer
->	O
type	enum
=	O
0	int
;	O
return	O
r	pointer
;	O
}	O
void	O
canonicalize_whitespace	function
(	O
char	O
*	O
string	pointer
)	O
{	O
register	O
int	O
i	int
,	O
j	int
;	O
int	O
len	long
,	O
whitespace_found	int
,	O
whitespace_loc	int
=	O
0	int
;	O
char	O
*	O
temp	pointer
;	O
if	O
(	O
!	O
string	pointer
)	O
return	O
;	O
len	long
=	O
strlen	function
(	O
string	pointer
)	O
;	O
temp	pointer
=	O
xmalloc	function
(	O
1	int
+	O
len	long
)	O
;	O
whitespace_found	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
;	O
string	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
whitespace_or_newline	O
(	O
string	pointer
[	O
i	int
]	O
)	O
)	O
{	O
whitespace_found	int
++	O
;	O
whitespace_loc	int
=	O
i	int
;	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
whitespace_found	int
&&	O
whitespace_loc	int
)	O
{	O
whitespace_found	int
=	O
0	int
;	O
if	O
(	O
j	int
)	O
temp	pointer
[	O
j	int
++	O
]	O
=	O
' '	O
;	O
}	O
temp	pointer
[	O
j	int
++	O
]	O
=	O
string	pointer
[	O
i	int
]	O
;	O
}	O
}	O
if	O
(	O
j	int
&&	O
whitespace	O
(	O
temp	pointer
[	O
j	int
-	O
1	int
]	O
)	O
)	O
j	int
--	O
;	O
temp	pointer
[	O
j	int
]	O
=	O
'\0'	O
;	O
strcpy	function
(	O
string	pointer
,	O
temp	pointer
)	O
;	O
free	function
(	O
temp	pointer
)	O
;	O
}	O
int	O
ansi_escape	function
(	O
mbi_iterator_t	struct
iter	pointer
,	O
size_t	long
*	O
plen	pointer
)	O
{	O
if	O
(	O
raw_escapes_p	int
&&	O
*	O
mbi_cur_ptr	O
(	O
iter	pointer
)	O
==	O
'\033'	O
&&	O
mbi_avail	O
(	O
iter	pointer
)	O
)	O
{	O
mbi_advance	O
(	O
iter	pointer
)	O
;	O
if	O
(	O
*	O
mbi_cur_ptr	O
(	O
iter	pointer
)	O
==	O
'['	O
&&	O
mbi_avail	O
(	O
iter	pointer
)	O
)	O
{	O
ITER_SETBYTES	O
(	O
iter	pointer
,	O
1	int
)	O
;	O
mbi_advance	O
(	O
iter	pointer
)	O
;	O
if	O
(	O
isdigit	function
(	O
*	O
mbi_cur_ptr	O
(	O
iter	pointer
)	O
)	O
&&	O
mbi_avail	O
(	O
iter	pointer
)	O
)	O
{	O
ITER_SETBYTES	O
(	O
iter	pointer
,	O
1	int
)	O
;	O
mbi_advance	O
(	O
iter	pointer
)	O
;	O
if	O
(	O
*	O
mbi_cur_ptr	O
(	O
iter	pointer
)	O
==	O
'm'	O
)	O
{	O
*	O
plen	pointer
=	O
4	int
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
isdigit	function
(	O
*	O
mbi_cur_ptr	O
(	O
iter	pointer
)	O
)	O
&&	O
mbi_avail	O
(	O
iter	pointer
)	O
)	O
{	O
ITER_SETBYTES	O
(	O
iter	pointer
,	O
1	int
)	O
;	O
mbi_advance	O
(	O
iter	pointer
)	O
;	O
if	O
(	O
*	O
mbi_cur_ptr	O
(	O
iter	pointer
)	O
==	O
'm'	O
)	O
{	O
*	O
plen	pointer
=	O
5	int
;	O
return	O
1	int
;	O
}	O
}	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
text_buffer	struct
printed_rep	struct
=	O
{	O
0	int
}	O
;	O
char	O
*	O
printed_representation	function
(	O
mbi_iterator_t	struct
*	O
iter	pointer
,	O
int	O
*	O
delim	pointer
,	O
size_t	long
pl_chars	long
,	O
size_t	long
*	O
pchars	pointer
,	O
size_t	long
*	O
pbytes	pointer
)	O
{	O
struct	O
text_buffer	struct
*	O
rep	pointer
=	O
&	O
printed_rep	struct
;	O
char	O
*	O
cur_ptr	pointer
=	O
(	O
char	O
*	O
)	O
mbi_cur_ptr	O
(	O
*	O
iter	pointer
)	O
;	O
size_t	long
cur_len	long
=	O
mb_len	O
(	O
mbi_cur	O
(	O
*	O
iter	pointer
)	O
)	O
;	O
text_buffer_reset	O
(	O
&	O
printed_rep	struct
)	O
;	O
if	O
(	O
mb_isprint	O
(	O
mbi_cur	O
(	O
*	O
iter	pointer
)	O
)	O
)	O
{	O
*	O
pchars	pointer
=	O
wcwidth	function
(	O
(	O
*	O
iter	pointer
)	O
.	O
cur	struct
.	O
wc	int
)	O
;	O
*	O
pbytes	pointer
=	O
cur_len	long
;	O
return	O
cur_ptr	pointer
;	O
}	O
else	O
if	O
(	O
cur_len	long
==	O
1	int
)	O
{	O
if	O
(	O
*	O
cur_ptr	pointer
==	O
'\n'	O
||	O
*	O
cur_ptr	pointer
==	O
'\r'	O
)	O
{	O
if	O
(	O
*	O
cur_ptr	pointer
==	O
'\r'	O
&&	O
cur_ptr	pointer
[	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
*	O
pchars	pointer
=	O
0	int
;	O
*	O
pbytes	pointer
=	O
0	int
;	O
return	O
cur_ptr	pointer
;	O
}	O
*	O
pchars	pointer
=	O
1	int
;	O
*	O
pbytes	pointer
=	O
cur_len	long
;	O
*	O
delim	pointer
=	O
*	O
cur_ptr	pointer
;	O
text_buffer_add_char	function
(	O
rep	pointer
,	O
' '	O
)	O
;	O
return	O
cur_ptr	pointer
;	O
}	O
else	O
if	O
(	O
ansi_escape	function
(	O
*	O
iter	pointer
,	O
&	O
cur_len	long
)	O
)	O
{	O
*	O
pchars	pointer
=	O
0	int
;	O
*	O
pbytes	pointer
=	O
cur_len	long
;	O
ITER_SETBYTES	O
(	O
*	O
iter	pointer
,	O
cur_len	long
)	O
;	O
return	O
cur_ptr	pointer
;	O
}	O
else	O
if	O
(	O
*	O
cur_ptr	pointer
==	O
'\t'	O
)	O
{	O
int	O
i	int
=	O
0	int
;	O
*	O
pchars	pointer
=	O
(	O
(	O
pl_chars	long
+	O
8	int
)	O
&	O
0xf8	int
)	O
-	O
pl_chars	long
;	O
*	O
pbytes	pointer
=	O
*	O
pchars	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
*	O
pbytes	pointer
;	O
i	int
++	O
)	O
text_buffer_add_char	function
(	O
rep	pointer
,	O
' '	O
)	O
;	O
return	O
text_buffer_base	O
(	O
rep	pointer
)	O
;	O
}	O
}	O
if	O
(	O
iscntrl	function
(	O
*	O
cur_ptr	pointer
)	O
&&	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
cur_ptr	pointer
<	O
127	int
)	O
{	O
*	O
pchars	pointer
=	O
2	int
;	O
*	O
pbytes	pointer
=	O
2	int
;	O
text_buffer_add_char	function
(	O
rep	pointer
,	O
'^'	O
)	O
;	O
text_buffer_add_char	function
(	O
rep	pointer
,	O
*	O
cur_ptr	pointer
|	O
0x40	int
)	O
;	O
return	O
text_buffer_base	O
(	O
rep	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
cur_ptr	pointer
==	O
DEL	char
)	O
{	O
*	O
pchars	pointer
=	O
0	int
;	O
*	O
pbytes	pointer
=	O
0	int
;	O
return	O
text_buffer_base	O
(	O
rep	pointer
)	O
;	O
}	O
else	O
{	O
*	O
pchars	pointer
=	O
4	int
;	O
*	O
pbytes	pointer
=	O
4	int
;	O
text_buffer_printf	function
(	O
rep	pointer
,	O
"\\%o"	pointer
,	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
cur_ptr	pointer
)	O
;	O
return	O
text_buffer_base	O
(	O
rep	pointer
)	O
;	O
}	O
}	O
int	O
preprocess_nodes_p	int
;	O
static	O
int	O
rewrite_p	int
;	O
static	O
char	O
*	O
inptr	pointer
;	O
static	O
char	O
*	O
input_start	pointer
;	O
static	O
size_t	long
input_length	long
;	O
struct	O
text_buffer	struct
output_buf	struct
;	O
static	O
TAG	struct
*	O
*	O
anchor_to_adjust	pointer
;	O
static	O
int	O
node_offset	int
;	O
static	O
long	O
int	O
output_bytes_difference	long
;	O
static	O
int	O
convert_encoding_p	int
;	O
static	O
int	O
file_is_in_utf8	int
;	O
static	O
iconv_t	pointer
iconv_to_output	pointer
;	O
static	O
iconv_t	pointer
iconv_to_utf8	pointer
;	O
void	O
init_conversion	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
)	O
{	O
char	O
*	O
target_encoding	pointer
;	O
convert_encoding_p	int
=	O
0	int
;	O
if	O
(	O
!	O
fb	pointer
)	O
return	O
;	O
file_is_in_utf8	int
=	O
0	int
;	O
if	O
(	O
!	O
fb	pointer
->	O
encoding	pointer
)	O
return	O
;	O
target_encoding	pointer
=	O
nl_langinfo	function
(	O
CODESET	int
)	O
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
target_encoding	pointer
,	O
fb	pointer
->	O
encoding	pointer
)	O
)	O
return	O
;	O
iconv_to_output	pointer
=	O
iconv_open	function
(	O
target_encoding	pointer
,	O
fb	pointer
->	O
encoding	pointer
)	O
;	O
if	O
(	O
iconv_to_output	pointer
==	O
(	O
iconv_t	pointer
)	O
-	O
1	int
)	O
return	O
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
"UTF8"	pointer
,	O
fb	pointer
->	O
encoding	pointer
)	O
||	O
!	O
strcasecmp	function
(	O
"UTF-8"	pointer
,	O
fb	pointer
->	O
encoding	pointer
)	O
)	O
file_is_in_utf8	int
=	O
1	int
;	O
if	O
(	O
!	O
file_is_in_utf8	int
)	O
{	O
iconv_to_utf8	pointer
=	O
iconv_open	function
(	O
"UTF-8"	pointer
,	O
fb	pointer
->	O
encoding	pointer
)	O
;	O
if	O
(	O
iconv_to_utf8	pointer
==	O
(	O
iconv_t	pointer
)	O
-	O
1	int
)	O
{	O
iconv_close	function
(	O
iconv_to_output	pointer
)	O
;	O
return	O
;	O
}	O
}	O
convert_encoding_p	int
=	O
1	int
;	O
rewrite_p	int
=	O
1	int
;	O
}	O
void	O
close_conversion	function
(	O
void	O
)	O
{	O
if	O
(	O
convert_encoding_p	int
)	O
{	O
iconv_close	function
(	O
iconv_to_output	pointer
)	O
;	O
if	O
(	O
!	O
file_is_in_utf8	int
)	O
iconv_close	function
(	O
iconv_to_utf8	pointer
)	O
;	O
}	O
}	O
static	O
void	O
init_output_stream	function
(	O
FILE_BUFFER	struct
*	O
fb	pointer
)	O
{	O
init_conversion	function
(	O
fb	pointer
)	O
;	O
output_bytes_difference	long
=	O
0	int
;	O
if	O
(	O
rewrite_p	int
)	O
text_buffer_init	function
(	O
&	O
output_buf	struct
)	O
;	O
}	O
static	O
size_t	long
saved_offset	long
;	O
static	O
char	O
*	O
saved_inptr	pointer
;	O
static	O
long	O
saved_difference	long
;	O
void	O
save_conversion_state	function
(	O
void	O
)	O
{	O
saved_offset	long
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct
)	O
;	O
saved_inptr	pointer
=	O
inptr	pointer
;	O
saved_difference	long
=	O
output_bytes_difference	long
;	O
}	O
void	O
reset_conversion	function
(	O
void	O
)	O
{	O
text_buffer_off	O
(	O
&	O
output_buf	struct
)	O
=	O
saved_offset	long
;	O
inptr	pointer
=	O
saved_inptr	pointer
;	O
output_bytes_difference	long
=	O
saved_difference	long
;	O
}	O
static	O
void	O
copy_direct	function
(	O
long	O
n	long
)	O
{	O
text_buffer_add_string	function
(	O
&	O
output_buf	struct
,	O
inptr	pointer
,	O
n	long
)	O
;	O
inptr	pointer
+=	O
n	long
;	O
}	O
static	O
int	O
degrade_utf8	function
(	O
char	O
*	O
*	O
from	pointer
,	O
size_t	long
*	O
from_left	pointer
)	O
{	O
static	O
struct	O
encoding_replacement	struct
{	O
char	O
*	O
from_string	pointer
;	O
char	O
*	O
to_string	pointer
;	O
}	O
er	array
[	O
]	O
=	O
{	O
{	O
"\xE2\x80\x98"	pointer
,	O
"'"	pointer
}	O
,	O
{	O
"\xE2\x80\x99"	pointer
,	O
"'"	pointer
}	O
,	O
{	O
"\xE2\x80\x9C"	pointer
,	O
"\""	pointer
}	O
,	O
{	O
"\xE2\x80\x9D"	pointer
,	O
"\""	pointer
}	O
,	O
{	O
"\xC2\xA9"	pointer
,	O
"(C)"	pointer
}	O
,	O
{	O
"\xC2\xBB"	pointer
,	O
">>"	pointer
}	O
,	O
{	O
"\xE2\x86\x92"	pointer
,	O
"->"	pointer
}	O
,	O
{	O
"\xE2\x87\x92"	pointer
,	O
"=>"	pointer
}	O
,	O
{	O
"\xE2\x8A\xA3"	pointer
,	O
"-|"	pointer
}	O
,	O
{	O
"\xE2\x98\x85"	pointer
,	O
"-!-"	pointer
}	O
,	O
{	O
"\xE2\x86\xA6"	pointer
,	O
"==>"	pointer
}	O
,	O
{	O
"\xE2\x80\x90"	pointer
,	O
"-"	pointer
}	O
,	O
{	O
"\xE2\x80\x91"	pointer
,	O
"-"	pointer
}	O
,	O
{	O
"\xE2\x80\x92"	pointer
,	O
"-"	pointer
}	O
,	O
{	O
"\xE2\x80\x93"	pointer
,	O
"-"	pointer
}	O
,	O
{	O
"\xE2\x80\x94"	pointer
,	O
"--"	pointer
}	O
,	O
{	O
"\xE2\x88\x92"	pointer
,	O
"-"	pointer
}	O
,	O
{	O
"\xE2\x80\xA6"	pointer
,	O
"..."	pointer
}	O
,	O
{	O
"\xE2\x80\xA2"	pointer
,	O
"*"	pointer
}	O
,	O
{	O
"\xC3\xA0"	pointer
,	O
"a`"	pointer
}	O
,	O
{	O
"\xC3\xA2"	pointer
,	O
"a^"	pointer
}	O
,	O
{	O
"\xC3\xA4"	pointer
,	O
"a\""	pointer
}	O
,	O
{	O
"\xC3\xA6"	pointer
,	O
"ae"	pointer
}	O
,	O
{	O
"\xC3\xA9"	pointer
,	O
"e'"	pointer
}	O
,	O
{	O
"\xC3\xA8"	pointer
,	O
"e`"	pointer
}	O
,	O
{	O
"\xC3\xAA"	pointer
,	O
"e^"	pointer
}	O
,	O
{	O
"\xC3\xAB"	pointer
,	O
"e\""	pointer
}	O
,	O
{	O
"\xC3\xB6"	pointer
,	O
"o\""	pointer
}	O
,	O
{	O
"\xC3\xBC"	pointer
,	O
"u\""	pointer
}	O
,	O
{	O
"\xC3\x84"	pointer
,	O
"A\""	pointer
}	O
,	O
{	O
"\xC3\x96"	pointer
,	O
"O\""	pointer
}	O
,	O
{	O
"\xC3\x9c"	pointer
,	O
"U\""	pointer
}	O
,	O
{	O
"\xC3\xB1"	pointer
,	O
"n~"	pointer
}	O
,	O
{	O
"\xC3\x87"	pointer
,	O
"C,"	pointer
}	O
,	O
{	O
"\xC3\xA7"	pointer
,	O
"c,"	pointer
}	O
,	O
{	O
"\xC3\x9f"	pointer
,	O
"ss"	pointer
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
struct	O
encoding_replacement	struct
*	O
erp	pointer
;	O
for	O
(	O
erp	pointer
=	O
er	array
;	O
erp	pointer
->	O
from_string	pointer
!=	O
0	int
;	O
erp	pointer
++	O
)	O
{	O
int	O
width	long
=	O
strlen	function
(	O
erp	pointer
->	O
from_string	pointer
)	O
;	O
if	O
(	O
width	long
>	O
*	O
from_left	pointer
)	O
continue	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
erp	pointer
->	O
from_string	pointer
,	O
*	O
from	pointer
,	O
width	long
)	O
)	O
{	O
text_buffer_add_string	function
(	O
&	O
output_buf	struct
,	O
erp	pointer
->	O
to_string	pointer
,	O
strlen	function
(	O
erp	pointer
->	O
to_string	pointer
)	O
)	O
;	O
*	O
from	pointer
+=	O
width	long
;	O
*	O
from_left	pointer
-=	O
width	long
;	O
return	O
1	int
;	O
}	O
}	O
text_buffer_add_string	function
(	O
&	O
output_buf	struct
,	O
"?"	pointer
,	O
1	int
)	O
;	O
(	O
*	O
from	pointer
)	O
++	O
;	O
(	O
*	O
from_left	pointer
)	O
--	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
copy_converting	function
(	O
long	O
n	long
)	O
{	O
size_t	long
bytes_left	long
,	O
orig_bytes_left	long
;	O
int	O
extra_at_end	int
;	O
size_t	long
iconv_ret	long
;	O
long	O
output_start	long
;	O
size_t	long
utf8_char_free	long
;	O
char	O
utf8_char	array
[	O
4	int
]	O
;	O
char	O
*	O
utf8_char_ptr	pointer
,	O
*	O
orig_inptr	pointer
;	O
size_t	long
i	int
;	O
text_buffer_alloc	function
(	O
&	O
output_buf	struct
,	O
(	O
size_t	long
)	O
n	long
)	O
;	O
output_start	long
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct
)	O
;	O
bytes_left	long
=	O
n	long
;	O
extra_at_end	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
iconv_ret	long
=	O
text_buffer_iconv	function
(	O
&	O
output_buf	struct
,	O
iconv_to_output	pointer
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	pointer
,	O
&	O
bytes_left	long
)	O
;	O
if	O
(	O
iconv_ret	long
!=	O
(	O
size_t	long
)	O
-	O
1	int
&&	O
text_buffer_iconv	function
(	O
&	O
output_buf	struct
,	O
iconv_to_output	pointer
,	O
NULL	O
,	O
NULL	O
)	O
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
errno	O
)	O
{	O
case	O
E2BIG	int
:	O
text_buffer_alloc	function
(	O
&	O
output_buf	struct
,	O
n	long
)	O
;	O
continue	O
;	O
case	O
EINVAL	int
:	O
if	O
(	O
inptr	pointer
-	O
input_start	pointer
+	O
(	O
bytes_left	long
-	O
1	int
)	O
<=	O
input_length	long
-	O
2	int
)	O
{	O
bytes_left	long
++	O
;	O
extra_at_end	int
++	O
;	O
}	O
else	O
{	O
copy_direct	function
(	O
bytes_left	long
)	O
;	O
bytes_left	long
=	O
0	int
;	O
}	O
continue	O
;	O
default	O
:	O
info_error	function
(	O
_	O
(	O
"Error converting file character encoding"	pointer
)	O
)	O
;	O
inptr	pointer
+=	O
bytes_left	long
;	O
return	O
0	int
;	O
case	O
EILSEQ	int
:	O
break	O
;	O
}	O
text_buffer_iconv	function
(	O
&	O
output_buf	struct
,	O
iconv_to_output	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
file_is_in_utf8	int
)	O
{	O
degrade_utf8	function
(	O
&	O
inptr	pointer
,	O
&	O
bytes_left	long
)	O
;	O
continue	O
;	O
}	O
utf8_char_ptr	pointer
=	O
utf8_char	array
;	O
orig_inptr	pointer
=	O
inptr	pointer
;	O
orig_bytes_left	long
=	O
bytes_left	long
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
4	int
;	O
i	int
++	O
)	O
{	O
utf8_char_free	long
=	O
i	int
;	O
errno	O
=	O
0	int
;	O
iconv_ret	long
=	O
iconv	function
(	O
iconv_to_utf8	pointer
,	O
(	O
ICONV_CONST	O
char	O
*	O
*	O
)	O
&	O
inptr	pointer
,	O
&	O
bytes_left	long
,	O
&	O
utf8_char_ptr	pointer
,	O
&	O
utf8_char_free	long
)	O
;	O
if	O
(	O
(	O
iconv_ret	long
==	O
(	O
size_t	long
)	O
-	O
1	int
&&	O
errno	O
!=	O
E2BIG	int
)	O
||	O
utf8_char_ptr	pointer
>	O
utf8_char	array
)	O
break	O
;	O
}	O
if	O
(	O
iconv_ret	long
==	O
(	O
size_t	long
)	O
-	O
1	int
&&	O
errno	O
!=	O
E2BIG	int
)	O
{	O
inptr	pointer
=	O
orig_inptr	pointer
;	O
copy_direct	function
(	O
1	int
)	O
;	O
bytes_left	long
=	O
orig_bytes_left	long
-	O
1	int
;	O
}	O
else	O
{	O
utf8_char_ptr	pointer
=	O
utf8_char	array
;	O
degrade_utf8	function
(	O
&	O
utf8_char_ptr	pointer
,	O
&	O
i	int
)	O
;	O
if	O
(	O
bytes_left	long
<=	O
0	int
)	O
{	O
utf8_char_ptr	pointer
=	O
utf8_char	array
;	O
i	int
=	O
4	int
;	O
iconv	function
(	O
iconv_to_utf8	pointer
,	O
NULL	O
,	O
NULL	O
,	O
&	O
utf8_char_ptr	pointer
,	O
&	O
utf8_char_free	long
)	O
;	O
if	O
(	O
utf8_char_ptr	pointer
>	O
utf8_char	array
)	O
{	O
utf8_char_ptr	pointer
=	O
utf8_char	array
;	O
degrade_utf8	function
(	O
&	O
utf8_char_ptr	pointer
,	O
&	O
i	int
)	O
;	O
}	O
}	O
}	O
}	O
output_bytes_difference	long
+=	O
n	long
-	O
(	O
(	O
signed	O
long	O
)	O
text_buffer_off	O
(	O
&	O
output_buf	struct
)	O
-	O
output_start	long
)	O
;	O
return	O
extra_at_end	int
;	O
}	O
static	O
void	O
copy_input_to_output	function
(	O
long	O
n	long
)	O
{	O
if	O
(	O
rewrite_p	int
)	O
{	O
long	O
bytes_left	long
;	O
bytes_left	long
=	O
n	long
;	O
while	O
(	O
bytes_left	long
>	O
0	int
)	O
{	O
if	O
(	O
!	O
convert_encoding_p	int
)	O
{	O
copy_direct	function
(	O
bytes_left	long
)	O
;	O
bytes_left	long
=	O
0	int
;	O
}	O
else	O
{	O
long	O
bytes_to_convert	long
;	O
long	O
extra_written	long
;	O
bytes_to_convert	long
=	O
bytes_left	long
;	O
if	O
(	O
anchor_to_adjust	pointer
)	O
{	O
char	O
*	O
first_anchor	pointer
=	O
input_start	pointer
+	O
(	O
*	O
anchor_to_adjust	pointer
)	O
->	O
nodestart	long
-	O
node_offset	int
;	O
if	O
(	O
first_anchor	pointer
<	O
inptr	pointer
+	O
bytes_left	long
)	O
{	O
bytes_to_convert	long
=	O
first_anchor	pointer
-	O
inptr	pointer
+	O
1	int
;	O
if	O
(	O
bytes_to_convert	long
<	O
0	int
)	O
{	O
anchor_to_adjust	pointer
=	O
0	int
;	O
bytes_to_convert	long
=	O
bytes_left	long
;	O
}	O
}	O
}	O
extra_written	long
=	O
copy_converting	function
(	O
bytes_to_convert	long
)	O
;	O
bytes_left	long
-=	O
bytes_to_convert	long
+	O
extra_written	long
;	O
}	O
if	O
(	O
anchor_to_adjust	pointer
)	O
while	O
(	O
(	O
*	O
anchor_to_adjust	pointer
)	O
->	O
nodestart	long
-	O
node_offset	int
<=	O
inptr	pointer
-	O
input_start	pointer
)	O
{	O
(	O
*	O
anchor_to_adjust	pointer
)	O
->	O
nodestart_adjusted	long
=	O
(	O
*	O
anchor_to_adjust	pointer
)	O
->	O
nodestart	long
-	O
output_bytes_difference	long
;	O
anchor_to_adjust	pointer
++	O
;	O
if	O
(	O
!	O
*	O
anchor_to_adjust	pointer
||	O
(	O
*	O
anchor_to_adjust	pointer
)	O
->	O
cache	struct
.	O
nodelen	long
!=	O
0	int
)	O
{	O
anchor_to_adjust	pointer
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
else	O
inptr	pointer
+=	O
n	long
;	O
}	O
static	O
void	O
skip_input	function
(	O
long	O
n	long
)	O
{	O
if	O
(	O
preprocess_nodes_p	int
)	O
{	O
inptr	pointer
+=	O
n	long
;	O
output_bytes_difference	long
+=	O
n	long
;	O
}	O
else	O
if	O
(	O
rewrite_p	int
)	O
{	O
copy_input_to_output	function
(	O
n	long
)	O
;	O
}	O
else	O
{	O
inptr	pointer
+=	O
n	long
;	O
}	O
}	O
static	O
void	O
write_extra_bytes_to_output	function
(	O
char	O
*	O
input	pointer
,	O
long	O
n	long
)	O
{	O
if	O
(	O
preprocess_nodes_p	int
)	O
{	O
text_buffer_add_string	function
(	O
&	O
output_buf	struct
,	O
input	pointer
,	O
n	long
)	O
;	O
output_bytes_difference	long
-=	O
n	long
;	O
}	O
}	O
static	O
void	O
write_tag_contents	function
(	O
char	O
*	O
input	pointer
,	O
long	O
n	long
)	O
{	O
if	O
(	O
rewrite_p	int
)	O
{	O
text_buffer_add_string	function
(	O
&	O
output_buf	struct
,	O
input	pointer
,	O
n	long
)	O
;	O
output_bytes_difference	long
-=	O
n	long
;	O
}	O
}	O
static	O
void	O
skip_tag_contents	function
(	O
long	O
n	long
)	O
{	O
if	O
(	O
rewrite_p	int
)	O
{	O
inptr	pointer
+=	O
n	long
;	O
output_bytes_difference	long
+=	O
n	long
;	O
}	O
}	O
static	O
void	O
parse_top_node_line	function
(	O
NODE	struct
*	O
node	pointer
)	O
{	O
char	O
*	O
*	O
store_in	pointer
=	O
0	int
;	O
char	O
*	O
nodename	pointer
;	O
char	O
*	O
ptr	pointer
;	O
int	O
value_length	int
;	O
if	O
(	O
*	O
node	pointer
->	O
contents	pointer
==	O
'\n'	O
)	O
return	O
;	O
node	pointer
->	O
next	pointer
=	O
node	pointer
->	O
prev	pointer
=	O
node	pointer
->	O
up	pointer
=	O
0	int
;	O
ptr	pointer
=	O
node	pointer
->	O
contents	pointer
;	O
while	O
(	O
1	int
)	O
{	O
store_in	pointer
=	O
0	int
;	O
ptr	pointer
+=	O
skip_whitespace	function
(	O
ptr	pointer
)	O
;	O
if	O
(	O
!	O
strncasecmp	function
(	O
ptr	pointer
,	O
INFO_FILE_LABEL	pointer
,	O
strlen	function
(	O
INFO_FILE_LABEL	pointer
)	O
)	O
)	O
{	O
ptr	pointer
+=	O
strlen	function
(	O
INFO_FILE_LABEL	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncasecmp	function
(	O
ptr	pointer
,	O
INFO_NODE_LABEL	pointer
,	O
strlen	function
(	O
INFO_NODE_LABEL	pointer
)	O
)	O
)	O
{	O
ptr	pointer
+=	O
strlen	function
(	O
INFO_NODE_LABEL	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncasecmp	function
(	O
ptr	pointer
,	O
INFO_PREV_LABEL	pointer
,	O
strlen	function
(	O
INFO_PREV_LABEL	pointer
)	O
)	O
)	O
{	O
ptr	pointer
+=	O
strlen	function
(	O
INFO_PREV_LABEL	pointer
)	O
;	O
store_in	pointer
=	O
&	O
node	pointer
->	O
prev	pointer
;	O
}	O
else	O
if	O
(	O
!	O
strncasecmp	function
(	O
ptr	pointer
,	O
INFO_ALTPREV_LABEL	pointer
,	O
strlen	function
(	O
INFO_ALTPREV_LABEL	pointer
)	O
)	O
)	O
{	O
ptr	pointer
+=	O
strlen	function
(	O
INFO_ALTPREV_LABEL	pointer
)	O
;	O
store_in	pointer
=	O
&	O
node	pointer
->	O
prev	pointer
;	O
}	O
else	O
if	O
(	O
!	O
strncasecmp	function
(	O
ptr	pointer
,	O
INFO_NEXT_LABEL	pointer
,	O
strlen	function
(	O
INFO_NEXT_LABEL	pointer
)	O
)	O
)	O
{	O
ptr	pointer
+=	O
strlen	function
(	O
INFO_NEXT_LABEL	pointer
)	O
;	O
store_in	pointer
=	O
&	O
node	pointer
->	O
next	pointer
;	O
}	O
else	O
if	O
(	O
!	O
strncasecmp	function
(	O
ptr	pointer
,	O
INFO_UP_LABEL	pointer
,	O
strlen	function
(	O
INFO_UP_LABEL	pointer
)	O
)	O
)	O
{	O
ptr	pointer
+=	O
strlen	function
(	O
INFO_UP_LABEL	pointer
)	O
;	O
store_in	pointer
=	O
&	O
node	pointer
->	O
up	pointer
;	O
}	O
else	O
{	O
store_in	pointer
=	O
0	int
;	O
}	O
ptr	pointer
+=	O
skip_whitespace	function
(	O
ptr	pointer
)	O
;	O
if	O
(	O
*	O
ptr	pointer
!=	O
'('	O
)	O
value_length	int
=	O
0	int
;	O
else	O
value_length	int
=	O
read_bracketed_filename	function
(	O
ptr	pointer
,	O
0	int
)	O
;	O
value_length	int
+=	O
read_quoted_string	function
(	O
ptr	pointer
+	O
value_length	int
,	O
"\n\r\t,"	pointer
,	O
1	int
,	O
&	O
nodename	pointer
)	O
;	O
if	O
(	O
store_in	pointer
)	O
{	O
*	O
store_in	pointer
=	O
xmalloc	function
(	O
value_length	int
+	O
1	int
)	O
;	O
strncpy	function
(	O
*	O
store_in	pointer
,	O
ptr	pointer
,	O
value_length	int
)	O
;	O
(	O
*	O
store_in	pointer
)	O
[	O
value_length	int
]	O
=	O
'\0'	O
;	O
}	O
free	function
(	O
nodename	pointer
)	O
;	O
ptr	pointer
+=	O
value_length	int
;	O
if	O
(	O
*	O
ptr	pointer
==	O
'\n'	O
||	O
!	O
*	O
ptr	pointer
)	O
break	O
;	O
ptr	pointer
+=	O
1	int
;	O
}	O
}	O
static	O
int	O
scan_reference_marker	function
(	O
REFERENCE	struct
*	O
entry	pointer
,	O
int	O
in_parentheses	int
)	O
{	O
if	O
(	O
!	O
preprocess_nodes_p	int
)	O
{	O
if	O
(	O
rewrite_p	int
)	O
entry	pointer
->	O
start	int
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct
)	O
;	O
else	O
entry	pointer
->	O
start	int
=	O
inptr	pointer
-	O
input_start	pointer
;	O
}	O
if	O
(	O
inptr	pointer
[	O
0	int
]	O
==	O
'\n'	O
)	O
{	O
entry	pointer
->	O
type	enum
=	O
REFERENCE_MENU_ITEM	int
;	O
if	O
(	O
!	O
preprocess_nodes_p	int
)	O
entry	pointer
->	O
start	int
++	O
;	O
}	O
else	O
entry	pointer
->	O
type	enum
=	O
REFERENCE_XREF	int
;	O
if	O
(	O
entry	pointer
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
)	O
copy_input_to_output	function
(	O
strlen	function
(	O
"\n* "	pointer
)	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
strchr	function
(	O
" \t\r\n"	pointer
,	O
inptr	pointer
[	O
strlen	function
(	O
"*Note"	pointer
)	O
]	O
)	O
)	O
{	O
copy_input_to_output	function
(	O
strlen	function
(	O
"*Note:"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
inptr	pointer
[	O
1	int
]	O
==	O
'N'	O
)	O
{	O
write_extra_bytes_to_output	function
(	O
"See"	pointer
,	O
3	int
)	O
;	O
in_parentheses	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
in_parentheses	int
)	O
{	O
write_extra_bytes_to_output	function
(	O
"see"	pointer
,	O
3	int
)	O
;	O
}	O
skip_input	function
(	O
strlen	function
(	O
"*Note"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
in_parentheses	int
)	O
skip_input	function
(	O
skip_whitespace	function
(	O
inptr	pointer
)	O
)	O
;	O
}	O
copy_input_to_output	function
(	O
skip_whitespace_and_newlines	function
(	O
inptr	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
scan_reference_label	function
(	O
REFERENCE	struct
*	O
entry	pointer
,	O
int	O
in_index	int
)	O
{	O
int	O
max_lines	int
;	O
int	O
len	long
,	O
label_len	int
=	O
0	int
;	O
if	O
(	O
inptr	pointer
[	O
0	int
]	O
==	O
'('	O
)	O
label_len	int
=	O
read_bracketed_filename	function
(	O
inptr	pointer
,	O
&	O
entry	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
)	O
max_lines	int
=	O
1	int
;	O
else	O
max_lines	int
=	O
2	int
;	O
if	O
(	O
!	O
in_index	int
||	O
inptr	pointer
[	O
label_len	int
]	O
==	O
'\177'	O
)	O
{	O
len	long
=	O
read_quoted_string	function
(	O
inptr	pointer
+	O
label_len	int
,	O
":"	pointer
,	O
max_lines	int
,	O
&	O
entry	pointer
->	O
nodename	pointer
)	O
;	O
canonicalize_whitespace	function
(	O
entry	pointer
->	O
nodename	pointer
)	O
;	O
if	O
(	O
!	O
len	long
)	O
return	O
0	int
;	O
label_len	int
+=	O
len	long
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
;	O
int	O
n	long
,	O
m	int
=	O
0	int
;	O
p	pointer
=	O
inptr	pointer
+	O
label_len	int
;	O
while	O
(	O
1	int
)	O
{	O
n	long
=	O
strcspn	function
(	O
p	pointer
,	O
":\n\177"	pointer
)	O
;	O
if	O
(	O
p	pointer
[	O
n	long
]	O
==	O
':'	O
)	O
{	O
m	int
+=	O
n	long
+	O
1	int
;	O
p	pointer
+=	O
n	long
+	O
1	int
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
m	int
==	O
0	int
)	O
return	O
0	int
;	O
label_len	int
+=	O
m	int
-	O
1	int
;	O
}	O
entry	pointer
->	O
label	pointer
=	O
xmalloc	function
(	O
label_len	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
entry	pointer
->	O
label	pointer
,	O
inptr	pointer
,	O
label_len	int
)	O
;	O
entry	pointer
->	O
label	pointer
[	O
label_len	int
]	O
=	O
'\0'	O
;	O
canonicalize_whitespace	function
(	O
entry	pointer
->	O
label	pointer
)	O
;	O
if	O
(	O
preprocess_nodes_p	int
)	O
entry	pointer
->	O
start	int
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct
)	O
;	O
copy_input_to_output	function
(	O
label_len	int
)	O
;	O
if	O
(	O
rewrite_p	int
)	O
entry	pointer
->	O
end	int
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct
)	O
;	O
else	O
entry	pointer
->	O
end	int
=	O
inptr	pointer
-	O
input_start	pointer
;	O
skip_input	function
(	O
1	int
)	O
;	O
if	O
(	O
entry	pointer
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
)	O
write_extra_bytes_to_output	function
(	O
" "	pointer
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
scan_reference_target	function
(	O
REFERENCE	struct
*	O
entry	pointer
,	O
NODE	struct
*	O
node	pointer
,	O
int	O
in_parentheses	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
entry	pointer
->	O
type	enum
==	O
REFERENCE_XREF	int
)	O
{	O
int	O
length	int
=	O
0	int
;	O
char	O
*	O
target_start	pointer
=	O
inptr	pointer
;	O
char	O
*	O
nl_off	pointer
=	O
0	int
;	O
int	O
space_at_start_of_line	int
=	O
0	int
;	O
length	int
+=	O
skip_whitespace_and_newlines	function
(	O
inptr	pointer
)	O
;	O
length	int
+=	O
read_bracketed_filename	function
(	O
inptr	pointer
+	O
length	int
,	O
&	O
entry	pointer
->	O
filename	pointer
)	O
;	O
length	int
+=	O
skip_whitespace_and_newlines	function
(	O
inptr	pointer
+	O
length	int
)	O
;	O
length	int
+=	O
read_quoted_string	function
(	O
inptr	pointer
+	O
length	int
,	O
",."	pointer
,	O
2	int
,	O
&	O
entry	pointer
->	O
nodename	pointer
)	O
;	O
skip_input	function
(	O
length	int
)	O
;	O
nl_off	pointer
=	O
strchr	function
(	O
target_start	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
nl_off	pointer
)	O
{	O
if	O
(	O
nl_off	pointer
<	O
inptr	pointer
)	O
space_at_start_of_line	int
=	O
skip_whitespace	function
(	O
nl_off	pointer
+	O
1	int
)	O
;	O
else	O
nl_off	pointer
=	O
0	int
;	O
}	O
canonicalize_whitespace	function
(	O
entry	pointer
->	O
nodename	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
filename	pointer
)	O
{	O
if	O
(	O
nl_off	pointer
&&	O
nl_off	pointer
<	O
target_start	pointer
+	O
(	O
length	int
-	O
space_at_start_of_line	int
)	O
/	O
2	int
)	O
{	O
int	O
i	int
;	O
write_extra_bytes_to_output	function
(	O
"\n"	pointer
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
space_at_start_of_line	int
;	O
i	int
++	O
)	O
write_extra_bytes_to_output	function
(	O
" "	pointer
,	O
1	int
)	O
;	O
skip_input	function
(	O
strspn	function
(	O
inptr	pointer
,	O
" "	pointer
)	O
)	O
;	O
nl_off	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
*	O
inptr	pointer
!=	O
'\n'	O
)	O
{	O
write_extra_bytes_to_output	function
(	O
" "	pointer
,	O
1	int
)	O
;	O
}	O
write_extra_bytes_to_output	function
(	O
"("	pointer
,	O
1	int
)	O
;	O
write_extra_bytes_to_output	function
(	O
entry	pointer
->	O
filename	pointer
,	O
strlen	function
(	O
entry	pointer
->	O
filename	pointer
)	O
)	O
;	O
write_extra_bytes_to_output	function
(	O
" manual)"	pointer
,	O
strlen	function
(	O
" manual)"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
in_parentheses	int
&&	O
inptr	pointer
[	O
0	int
]	O
==	O
'.'	O
)	O
skip_input	function
(	O
1	int
)	O
;	O
copy_input_to_output	function
(	O
strspn	function
(	O
inptr	pointer
,	O
".),"	pointer
)	O
)	O
;	O
if	O
(	O
nl_off	pointer
&&	O
*	O
inptr	pointer
!=	O
'\n'	O
)	O
{	O
int	O
i	int
;	O
write_extra_bytes_to_output	function
(	O
"\n"	pointer
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
space_at_start_of_line	int
;	O
i	int
++	O
)	O
write_extra_bytes_to_output	function
(	O
" "	pointer
,	O
1	int
)	O
;	O
skip_input	function
(	O
strspn	function
(	O
inptr	pointer
,	O
" "	pointer
)	O
)	O
;	O
}	O
}	O
else	O
{	O
int	O
line_len	int
;	O
int	O
length	int
=	O
0	int
;	O
length	int
=	O
skip_whitespace	function
(	O
inptr	pointer
)	O
;	O
length	int
+=	O
read_bracketed_filename	function
(	O
inptr	pointer
+	O
length	int
,	O
&	O
entry	pointer
->	O
filename	pointer
)	O
;	O
length	int
+=	O
strspn	function
(	O
inptr	pointer
+	O
length	int
,	O
" "	pointer
)	O
;	O
length	int
+=	O
read_quoted_string	function
(	O
inptr	pointer
+	O
length	int
,	O
",.\t\n"	pointer
,	O
2	int
,	O
&	O
entry	pointer
->	O
nodename	pointer
)	O
;	O
if	O
(	O
inptr	pointer
[	O
length	int
]	O
==	O
'.'	O
)	O
length	int
++	O
;	O
if	O
(	O
node	pointer
->	O
flags	int
&	O
N_IsDir	int
)	O
{	O
char	O
*	O
linestart	pointer
;	O
linestart	pointer
=	O
memrchr	function
(	O
input_start	pointer
,	O
'\n'	O
,	O
inptr	pointer
-	O
input_start	pointer
)	O
;	O
if	O
(	O
!	O
linestart	pointer
)	O
linestart	pointer
=	O
input_start	pointer
;	O
else	O
linestart	pointer
++	O
;	O
line_len	int
=	O
inptr	pointer
-	O
linestart	pointer
;	O
}	O
if	O
(	O
node	pointer
->	O
flags	int
&	O
N_IsIndex	int
)	O
copy_input_to_output	function
(	O
length	int
)	O
;	O
else	O
{	O
skip_input	function
(	O
length	int
)	O
;	O
if	O
(	O
(	O
node	pointer
->	O
flags	int
&	O
N_IsDir	int
)	O
&&	O
inptr	pointer
[	O
strspn	function
(	O
inptr	pointer
,	O
" "	pointer
)	O
]	O
==	O
'\n'	O
)	O
{	O
skip_input	function
(	O
strspn	function
(	O
inptr	pointer
,	O
" "	pointer
)	O
)	O
;	O
if	O
(	O
line_len	int
<=	O
strspn	function
(	O
inptr	pointer
+	O
1	int
,	O
" "	pointer
)	O
)	O
skip_input	function
(	O
1	int
+	O
line_len	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
length	int
;	O
i	int
++	O
)	O
write_extra_bytes_to_output	function
(	O
" "	pointer
,	O
1	int
)	O
;	O
}	O
}	O
{	O
char	O
*	O
lineptr	pointer
=	O
inptr	pointer
;	O
lineptr	pointer
+=	O
skip_whitespace	function
(	O
inptr	pointer
)	O
;	O
if	O
(	O
*	O
lineptr	pointer
==	O
'\n'	O
)	O
lineptr	pointer
+=	O
1	int
+	O
skip_whitespace	function
(	O
lineptr	pointer
+	O
1	int
)	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
lineptr	pointer
,	O
"(line "	pointer
,	O
strlen	function
(	O
"(line "	pointer
)	O
)	O
)	O
{	O
lineptr	pointer
+=	O
strlen	function
(	O
"(line "	pointer
)	O
;	O
entry	pointer
->	O
line_number	long
=	O
strtol	function
(	O
lineptr	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
entry	pointer
->	O
line_number	long
=	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
char	O
safe_string_index	function
(	O
char	O
*	O
ptr	pointer
,	O
long	O
index	function
,	O
char	O
*	O
base	pointer
,	O
long	O
len	long
)	O
{	O
long	O
offset	long
=	O
ptr	pointer
-	O
base	pointer
;	O
if	O
(	O
offset	long
+	O
index	function
<	O
0	int
||	O
offset	long
+	O
index	function
>=	O
len	long
)	O
return	O
0	int
;	O
return	O
ptr	pointer
[	O
index	function
]	O
;	O
}	O
static	O
void	O
scan_info_tag	function
(	O
NODE	struct
*	O
node	pointer
,	O
int	O
*	O
in_index	int
,	O
FILE_BUFFER	struct
*	O
fb	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
p1	pointer
;	O
struct	O
text_buffer	struct
*	O
expansion	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
text_buffer	struct
)	O
)	O
;	O
p	pointer
=	O
inptr	pointer
;	O
p1	pointer
=	O
p	pointer
;	O
text_buffer_init	function
(	O
expansion	pointer
)	O
;	O
if	O
(	O
tag_expand	function
(	O
&	O
p1	pointer
,	O
input_start	pointer
+	O
input_length	long
,	O
expansion	pointer
,	O
in_index	int
)	O
)	O
{	O
if	O
(	O
*	O
in_index	int
)	O
node	pointer
->	O
flags	int
|=	O
N_IsIndex	int
;	O
if	O
(	O
!	O
rewrite_p	int
)	O
{	O
rewrite_p	int
=	O
1	int
;	O
init_output_stream	function
(	O
fb	pointer
)	O
;	O
inptr	pointer
=	O
node	pointer
->	O
contents	pointer
;	O
}	O
copy_input_to_output	function
(	O
p	pointer
-	O
inptr	pointer
)	O
;	O
write_tag_contents	function
(	O
text_buffer_base	O
(	O
expansion	pointer
)	O
,	O
text_buffer_off	O
(	O
expansion	pointer
)	O
)	O
;	O
skip_tag_contents	function
(	O
p1	pointer
-	O
inptr	pointer
)	O
;	O
}	O
else	O
{	O
copy_input_to_output	function
(	O
p	pointer
-	O
inptr	pointer
+	O
1	int
)	O
;	O
}	O
text_buffer_free	function
(	O
expansion	pointer
)	O
;	O
free	function
(	O
expansion	pointer
)	O
;	O
}	O
static	O
char	O
*	O
forward_to_info_syntax	function
(	O
char	O
*	O
contents	pointer
)	O
{	O
while	O
(	O
contents	pointer
<	O
input_start	pointer
+	O
input_length	long
-	O
3	int
)	O
{	O
if	O
(	O
looking_at_string	O
(	O
contents	pointer
,	O
INFO_MENU_ENTRY_LABEL	pointer
)	O
||	O
looking_at_string	O
(	O
contents	pointer
,	O
INFO_XREF_LABEL	pointer
)	O
||	O
!	O
memcmp	function
(	O
contents	pointer
,	O
"\0\b["	pointer
,	O
3	int
)	O
)	O
return	O
contents	pointer
;	O
contents	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
scan_node_contents	function
(	O
NODE	struct
*	O
node	pointer
,	O
FILE_BUFFER	struct
*	O
fb	pointer
,	O
TAG	struct
*	O
*	O
tag_ptr	pointer
)	O
{	O
int	O
in_menu	int
=	O
0	int
;	O
char	O
*	O
match	pointer
;	O
REFERENCE	struct
*	O
*	O
refs	pointer
=	O
NULL	O
;	O
size_t	long
refs_index	long
=	O
0	int
,	O
refs_slots	long
=	O
0	int
;	O
int	O
in_index	int
=	O
0	int
;	O
rewrite_p	int
=	O
preprocess_nodes_p	int
;	O
init_output_stream	function
(	O
fb	pointer
)	O
;	O
if	O
(	O
fb	pointer
)	O
{	O
char	O
*	O
file_contents	pointer
;	O
anchor_to_adjust	pointer
=	O
tag_ptr	pointer
+	O
1	int
;	O
if	O
(	O
!	O
*	O
anchor_to_adjust	pointer
)	O
anchor_to_adjust	pointer
=	O
0	int
;	O
else	O
if	O
(	O
*	O
anchor_to_adjust	pointer
&&	O
(	O
*	O
anchor_to_adjust	pointer
)	O
->	O
cache	struct
.	O
nodelen	long
!=	O
0	int
)	O
anchor_to_adjust	pointer
=	O
0	int
;	O
if	O
(	O
!	O
node	pointer
->	O
subfile	pointer
)	O
file_contents	pointer
=	O
fb	pointer
->	O
contents	pointer
;	O
else	O
{	O
FILE_BUFFER	struct
*	O
f	pointer
=	O
info_find_subfile	function
(	O
node	pointer
->	O
subfile	pointer
)	O
;	O
if	O
(	O
!	O
f	pointer
)	O
return	O
;	O
file_contents	pointer
=	O
f	pointer
->	O
contents	pointer
;	O
}	O
node_offset	int
=	O
(	O
*	O
tag_ptr	pointer
)	O
->	O
nodestart	long
+	O
skip_node_separator	function
(	O
file_contents	pointer
+	O
(	O
*	O
tag_ptr	pointer
)	O
->	O
nodestart	long
)	O
;	O
}	O
else	O
anchor_to_adjust	pointer
=	O
0	int
;	O
refs	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
*	O
refs	pointer
)	O
;	O
refs_slots	long
=	O
1	int
;	O
parse_top_node_line	function
(	O
node	pointer
)	O
;	O
inptr	pointer
=	O
node	pointer
->	O
contents	pointer
;	O
input_start	pointer
=	O
node	pointer
->	O
contents	pointer
;	O
input_length	long
=	O
node	pointer
->	O
nodelen	long
;	O
while	O
(	O
(	O
match	pointer
=	O
forward_to_info_syntax	function
(	O
inptr	pointer
)	O
)	O
&&	O
match	pointer
<	O
node	pointer
->	O
contents	pointer
+	O
node	pointer
->	O
nodelen	long
)	O
{	O
int	O
in_parentheses	int
=	O
0	int
;	O
REFERENCE	struct
*	O
entry	pointer
;	O
copy_input_to_output	function
(	O
match	pointer
-	O
inptr	pointer
)	O
;	O
if	O
(	O
(	O
in_menu	int
&&	O
match	pointer
[	O
0	int
]	O
==	O
'\n'	O
)	O
||	O
match	pointer
[	O
0	int
]	O
==	O
'*'	O
)	O
{	O
entry	pointer
=	O
info_new_reference	function
(	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
safe_string_index	function
(	O
inptr	pointer
,	O
-	O
1	int
,	O
input_start	pointer
,	O
input_length	long
)	O
==	O
'('	O
&&	O
safe_string_index	function
(	O
inptr	pointer
,	O
1	int
,	O
input_start	pointer
,	O
input_length	long
)	O
==	O
'n'	O
)	O
in_parentheses	int
=	O
1	int
;	O
save_conversion_state	function
(	O
)	O
;	O
if	O
(	O
!	O
scan_reference_marker	function
(	O
entry	pointer
,	O
in_parentheses	int
)	O
)	O
goto	O
not_a_reference	O
;	O
if	O
(	O
!	O
scan_reference_label	function
(	O
entry	pointer
,	O
in_index	int
)	O
)	O
goto	O
not_a_reference	O
;	O
if	O
(	O
*	O
inptr	pointer
==	O
':'	O
)	O
{	O
int	O
label_len	int
;	O
skip_input	function
(	O
1	int
)	O
;	O
if	O
(	O
entry	pointer
->	O
type	enum
==	O
REFERENCE_MENU_ITEM	int
)	O
write_extra_bytes_to_output	function
(	O
" "	pointer
,	O
1	int
)	O
;	O
label_len	int
=	O
strlen	function
(	O
entry	pointer
->	O
label	pointer
)	O
;	O
if	O
(	O
label_len	int
>=	O
2	int
&&	O
entry	pointer
->	O
label	pointer
[	O
label_len	int
-	O
1	int
]	O
==	O
0177	int
)	O
{	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
entry	pointer
->	O
label	pointer
,	O
'\177'	O
)	O
;	O
memmove	function
(	O
p	pointer
,	O
p	pointer
+	O
1	int
,	O
label_len	int
-	O
(	O
p	pointer
-	O
entry	pointer
->	O
label	pointer
)	O
-	O
1	int
)	O
;	O
entry	pointer
->	O
label	pointer
[	O
label_len	int
-	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
{	O
free	function
(	O
entry	pointer
->	O
filename	pointer
)	O
;	O
entry	pointer
->	O
filename	pointer
=	O
0	int
;	O
free	function
(	O
entry	pointer
->	O
nodename	pointer
)	O
;	O
entry	pointer
->	O
nodename	pointer
=	O
0	int
;	O
if	O
(	O
!	O
scan_reference_target	function
(	O
entry	pointer
,	O
node	pointer
,	O
in_parentheses	int
)	O
)	O
goto	O
not_a_reference	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
char	O
*	O
cur_inptr	pointer
;	O
not_a_reference	O
:	O
cur_inptr	pointer
=	O
inptr	pointer
;	O
reset_conversion	function
(	O
)	O
;	O
copy_input_to_output	function
(	O
cur_inptr	pointer
-	O
inptr	pointer
)	O
;	O
info_reference_free	function
(	O
entry	pointer
)	O
;	O
continue	O
;	O
}	O
add_pointer_to_array	O
(	O
entry	pointer
,	O
refs_index	long
,	O
refs	pointer
,	O
refs_slots	long
,	O
50	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
in_menu	int
&&	O
!	O
strncmp	function
(	O
match	pointer
,	O
INFO_MENU_LABEL	pointer
,	O
strlen	function
(	O
INFO_MENU_LABEL	pointer
)	O
)	O
)	O
{	O
in_menu	int
=	O
1	int
;	O
skip_input	function
(	O
strlen	function
(	O
"\n* Menu:"	pointer
)	O
)	O
;	O
if	O
(	O
*	O
inptr	pointer
==	O
'\n'	O
)	O
skip_input	function
(	O
strspn	function
(	O
inptr	pointer
,	O
"\n"	pointer
)	O
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
match	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
scan_info_tag	function
(	O
node	pointer
,	O
&	O
in_index	int
,	O
fb	pointer
)	O
;	O
}	O
else	O
copy_input_to_output	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
inptr	pointer
<	O
node	pointer
->	O
contents	pointer
+	O
node	pointer
->	O
nodelen	long
)	O
copy_input_to_output	function
(	O
(	O
node	pointer
->	O
contents	pointer
+	O
node	pointer
->	O
nodelen	long
)	O
-	O
inptr	pointer
)	O
;	O
if	O
(	O
rewrite_p	int
)	O
text_buffer_add_string	function
(	O
&	O
output_buf	struct
,	O
"\0"	pointer
,	O
1	int
)	O
;	O
close_conversion	function
(	O
)	O
;	O
node	pointer
->	O
references	pointer
=	O
refs	pointer
;	O
if	O
(	O
rewrite_p	int
)	O
{	O
node	pointer
->	O
contents	pointer
=	O
text_buffer_base	O
(	O
&	O
output_buf	struct
)	O
;	O
node	pointer
->	O
flags	int
|=	O
N_WasRewritten	int
;	O
node	pointer
->	O
nodelen	long
=	O
text_buffer_off	O
(	O
&	O
output_buf	struct
)	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
fb	pointer
&&	O
tag_ptr	pointer
)	O
{	O
tag_ptr	pointer
++	O
;	O
while	O
(	O
*	O
tag_ptr	pointer
&&	O
(	O
*	O
tag_ptr	pointer
)	O
->	O
cache	struct
.	O
nodelen	long
==	O
0	int
)	O
{	O
(	O
*	O
tag_ptr	pointer
)	O
->	O
nodestart_adjusted	long
=	O
(	O
*	O
tag_ptr	pointer
)	O
->	O
nodestart	long
-	O
output_bytes_difference	long
;	O
tag_ptr	pointer
++	O
;	O
}	O
}	O
}	O
FILE_BUFFER	struct
*	O
file_buffer_of_window	function
(	O
WINDOW	struct
*	O
window	pointer
)	O
{	O
if	O
(	O
!	O
window	pointer
->	O
node	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
)	O
return	O
info_find_file	function
(	O
window	pointer
->	O
node	pointer
->	O
fullpath	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
node_printed_rep	function
(	O
NODE	struct
*	O
node	pointer
)	O
{	O
static	O
char	O
*	O
rep	pointer
;	O
if	O
(	O
node	pointer
->	O
fullpath	pointer
)	O
{	O
char	O
*	O
filename	pointer
=	O
filename_non_directory	function
(	O
node	pointer
->	O
fullpath	pointer
)	O
;	O
rep	pointer
=	O
xrealloc	function
(	O
rep	pointer
,	O
1	int
+	O
strlen	function
(	O
filename	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
node	pointer
->	O
nodename	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
rep	pointer
,	O
"(%s)%s"	pointer
,	O
filename	pointer
,	O
node	pointer
->	O
nodename	pointer
)	O
;	O
return	O
rep	pointer
;	O
}	O
else	O
return	O
node	pointer
->	O
nodename	pointer
;	O
}	O
char	O
*	O
filename_non_directory	function
(	O
char	O
*	O
pathname	pointer
)	O
{	O
register	O
char	O
*	O
filename	pointer
=	O
pathname	pointer
+	O
strlen	function
(	O
pathname	pointer
)	O
;	O
if	O
(	O
HAVE_DRIVE	O
(	O
pathname	pointer
)	O
)	O
pathname	pointer
+=	O
2	int
;	O
while	O
(	O
filename	pointer
>	O
pathname	pointer
&&	O
!	O
IS_SLASH	O
(	O
filename	pointer
[	O
-	O
1	int
]	O
)	O
)	O
filename	pointer
--	O
;	O
return	O
filename	pointer
;	O
}	O
int	O
internal_info_node_p	function
(	O
NODE	struct
*	O
node	pointer
)	O
{	O
return	O
(	O
node	pointer
!=	O
NULL	O
)	O
&&	O
(	O
node	pointer
->	O
flags	int
&	O
N_IsInternal	int
)	O
;	O
}	O
void	O
name_internal_node	function
(	O
NODE	struct
*	O
node	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
!	O
node	pointer
)	O
return	O
;	O
node	pointer
->	O
fullpath	pointer
=	O
""	pointer
;	O
node	pointer
->	O
subfile	pointer
=	O
0	int
;	O
node	pointer
->	O
nodename	pointer
=	O
name	pointer
;	O
node	pointer
->	O
flags	int
|=	O
N_IsInternal	int
;	O
}	O
WINDOW	struct
*	O
get_internal_info_window	function
(	O
char	O
*	O
name	pointer
)	O
{	O
WINDOW	struct
*	O
win	pointer
;	O
for	O
(	O
win	pointer
=	O
windows	pointer
;	O
win	pointer
;	O
win	pointer
=	O
win	pointer
->	O
next	pointer
)	O
if	O
(	O
internal_info_node_p	function
(	O
win	pointer
->	O
node	pointer
)	O
&&	O
(	O
strcmp	function
(	O
win	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
)	O
break	O
;	O
return	O
win	pointer
;	O
}	O
void	O
text_buffer_init	function
(	O
struct	O
text_buffer	struct
*	O
buf	array
)	O
{	O
memset	function
(	O
buf	array
,	O
0	int
,	O
sizeof	O
*	O
buf	array
)	O
;	O
}	O
void	O
text_buffer_free	function
(	O
struct	O
text_buffer	struct
*	O
buf	array
)	O
{	O
free	function
(	O
buf	array
->	O
base	pointer
)	O
;	O
}	O
size_t	long
text_buffer_vprintf	function
(	O
struct	O
text_buffer	struct
*	O
buf	array
,	O
const	O
char	O
*	O
format	pointer
,	O
va_list	array
ap	array
)	O
{	O
ssize_t	long
n	long
;	O
va_list	array
ap_copy	array
;	O
if	O
(	O
!	O
buf	array
->	O
base	pointer
)	O
{	O
if	O
(	O
buf	array
->	O
size	long
==	O
0	int
)	O
buf	array
->	O
size	long
=	O
MIN_TEXT_BUF_ALLOC	int
;	O
buf	array
->	O
base	pointer
=	O
xmalloc	function
(	O
buf	array
->	O
size	long
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
va_copy	O
(	O
ap_copy	array
,	O
ap	array
)	O
;	O
n	long
=	O
vsnprintf	function
(	O
buf	array
->	O
base	pointer
+	O
buf	array
->	O
off	long
,	O
buf	array
->	O
size	long
-	O
buf	array
->	O
off	long
,	O
format	pointer
,	O
ap_copy	array
)	O
;	O
va_end	O
(	O
ap_copy	array
)	O
;	O
if	O
(	O
n	long
<	O
0	int
||	O
buf	array
->	O
off	long
+	O
n	long
>=	O
buf	array
->	O
size	long
||	O
!	O
memchr	function
(	O
buf	array
->	O
base	pointer
+	O
buf	array
->	O
off	long
,	O
'\0'	O
,	O
buf	array
->	O
size	long
-	O
buf	array
->	O
off	long
+	O
1	int
)	O
)	O
{	O
size_t	long
newlen	long
=	O
buf	array
->	O
size	long
*	O
2	int
;	O
if	O
(	O
newlen	long
<	O
buf	array
->	O
size	long
)	O
xalloc_die	function
(	O
)	O
;	O
buf	array
->	O
size	long
=	O
newlen	long
;	O
buf	array
->	O
base	pointer
=	O
xrealloc	function
(	O
buf	array
->	O
base	pointer
,	O
buf	array
->	O
size	long
)	O
;	O
}	O
else	O
{	O
buf	array
->	O
off	long
+=	O
n	long
;	O
break	O
;	O
}	O
}	O
return	O
n	long
;	O
}	O
void	O
text_buffer_alloc	function
(	O
struct	O
text_buffer	struct
*	O
buf	array
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
buf	array
->	O
off	long
+	O
len	long
>	O
buf	array
->	O
size	long
)	O
{	O
buf	array
->	O
size	long
=	O
buf	array
->	O
off	long
+	O
len	long
;	O
if	O
(	O
buf	array
->	O
size	long
<	O
MIN_TEXT_BUF_ALLOC	int
)	O
buf	array
->	O
size	long
=	O
MIN_TEXT_BUF_ALLOC	int
;	O
buf	array
->	O
base	pointer
=	O
xrealloc	function
(	O
buf	array
->	O
base	pointer
,	O
buf	array
->	O
size	long
)	O
;	O
}	O
}	O
size_t	long
text_buffer_space_left	function
(	O
struct	O
text_buffer	struct
*	O
buf	array
)	O
{	O
return	O
buf	array
->	O
size	long
-	O
buf	array
->	O
off	long
;	O
}	O
size_t	long
text_buffer_iconv	function
(	O
struct	O
text_buffer	struct
*	O
buf	array
,	O
iconv_t	pointer
iconv_state	pointer
,	O
ICONV_CONST	O
char	O
*	O
*	O
inbuf	pointer
,	O
size_t	long
*	O
inbytesleft	pointer
)	O
{	O
size_t	long
out_bytes_left	long
;	O
char	O
*	O
outptr	pointer
;	O
size_t	long
iconv_ret	long
;	O
outptr	pointer
=	O
text_buffer_base	O
(	O
buf	array
)	O
+	O
text_buffer_off	O
(	O
buf	array
)	O
;	O
out_bytes_left	long
=	O
text_buffer_space_left	function
(	O
buf	array
)	O
;	O
iconv_ret	long
=	O
iconv	function
(	O
iconv_state	pointer
,	O
inbuf	pointer
,	O
inbytesleft	pointer
,	O
&	O
outptr	pointer
,	O
&	O
out_bytes_left	long
)	O
;	O
text_buffer_off	O
(	O
buf	array
)	O
=	O
outptr	pointer
-	O
text_buffer_base	O
(	O
buf	array
)	O
;	O
return	O
iconv_ret	long
;	O
}	O
size_t	long
text_buffer_add_string	function
(	O
struct	O
text_buffer	struct
*	O
buf	array
,	O
const	O
char	O
*	O
str	pointer
,	O
size_t	long
len	long
)	O
{	O
text_buffer_alloc	function
(	O
buf	array
,	O
len	long
)	O
;	O
memcpy	function
(	O
buf	array
->	O
base	pointer
+	O
buf	array
->	O
off	long
,	O
str	pointer
,	O
len	long
)	O
;	O
buf	array
->	O
off	long
+=	O
len	long
;	O
return	O
len	long
;	O
}	O
size_t	long
text_buffer_fill	function
(	O
struct	O
text_buffer	struct
*	O
buf	array
,	O
int	O
c	int
,	O
size_t	long
len	long
)	O
{	O
char	O
*	O
p	pointer
;	O
int	O
i	int
;	O
text_buffer_alloc	function
(	O
buf	array
,	O
len	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
p	pointer
=	O
buf	array
->	O
base	pointer
+	O
buf	array
->	O
off	long
;	O
i	int
<	O
len	long
;	O
i	int
++	O
)	O
*	O
p	pointer
++	O
=	O
c	int
;	O
buf	array
->	O
off	long
+=	O
len	long
;	O
return	O
len	long
;	O
}	O
void	O
text_buffer_add_char	function
(	O
struct	O
text_buffer	struct
*	O
buf	array
,	O
int	O
c	int
)	O
{	O
char	O
ch	char
=	O
c	int
;	O
text_buffer_add_string	function
(	O
buf	array
,	O
&	O
ch	char
,	O
1	int
)	O
;	O
}	O
size_t	long
text_buffer_printf	function
(	O
struct	O
text_buffer	struct
*	O
buf	array
,	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
size_t	long
n	long
;	O
va_start	O
(	O
ap	array
,	O
format	pointer
)	O
;	O
n	long
=	O
text_buffer_vprintf	function
(	O
buf	array
,	O
format	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
n	long
;	O
}	O
struct	O
info_namelist_entry	struct
{	O
struct	O
info_namelist_entry	struct
*	O
next	pointer
;	O
char	O
name	pointer
[	O
1	int
]	O
;	O
}	O
;	O
int	O
info_namelist_add	function
(	O
struct	O
info_namelist_entry	struct
*	O
*	O
ptop	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
info_namelist_entry	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
*	O
ptop	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
fncmp	O
(	O
p	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
1	int
;	O
p	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
+	O
strlen	function
(	O
name	pointer
)	O
)	O
;	O
strcpy	function
(	O
p	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
p	pointer
->	O
next	pointer
=	O
*	O
ptop	pointer
;	O
*	O
ptop	pointer
=	O
p	pointer
;	O
return	O
0	int
;	O
}	O
void	O
info_namelist_free	function
(	O
struct	O
info_namelist_entry	struct
*	O
top	pointer
)	O
{	O
while	O
(	O
top	pointer
)	O
{	O
struct	O
info_namelist_entry	struct
*	O
next	pointer
=	O
top	pointer
->	O
next	pointer
;	O
free	function
(	O
top	pointer
)	O
;	O
top	pointer
=	O
next	pointer
;	O
}	O
}	O
