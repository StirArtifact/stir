static	O
bfd_boolean	int
elf_vxworks_gott_symbol_p	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
char	O
leading	char
;	O
leading	char
=	O
bfd_get_symbol_leading_char	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
leading	char
)	O
{	O
if	O
(	O
*	O
name	pointer
!=	O
leading	char
)	O
return	O
FALSE	int
;	O
name	pointer
++	O
;	O
}	O
return	O
(	O
strcmp	function
(	O
name	pointer
,	O
"__GOTT_BASE__"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
name	pointer
,	O
"__GOTT_INDEX__"	pointer
)	O
==	O
0	int
)	O
;	O
}	O
bfd_boolean	int
elf_vxworks_add_symbol_hook	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
,	O
const	O
char	O
*	O
*	O
namep	pointer
,	O
flagword	int
*	O
flagsp	pointer
,	O
asection	struct
*	O
*	O
secp	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd_vma	long
*	O
valp	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
if	O
(	O
(	O
bfd_link_pic	O
(	O
info	pointer
)	O
||	O
abfd	pointer
->	O
flags	int
&	O
DYNAMIC	int
)	O
&&	O
elf_vxworks_gott_symbol_p	function
(	O
abfd	pointer
,	O
*	O
namep	pointer
)	O
)	O
{	O
sym	pointer
->	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_WEAK	int
,	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
)	O
;	O
*	O
flagsp	pointer
|=	O
BSF_WEAK	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
elf_vxworks_create_dynamic_sections	function
(	O
bfd	struct
*	O
dynobj	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
asection	struct
*	O
*	O
srelplt2_out	pointer
)	O
{	O
struct	O
elf_link_hash_table	struct
*	O
htab	struct
;	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
asection	struct
*	O
s	pointer
;	O
htab	struct
=	O
elf_hash_table	O
(	O
info	pointer
)	O
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
dynobj	pointer
)	O
;	O
if	O
(	O
!	O
bfd_link_pic	O
(	O
info	pointer
)	O
)	O
{	O
s	pointer
=	O
bfd_make_section_anyway_with_flags	function
(	O
dynobj	pointer
,	O
bed	pointer
->	O
default_use_rela_p	int
?	O
".rela.plt.unloaded"	pointer
:	O
".rel.plt.unloaded"	pointer
,	O
SEC_HAS_CONTENTS	int
|	O
SEC_IN_MEMORY	int
|	O
SEC_READONLY	int
|	O
SEC_LINKER_CREATED	int
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
!	O
bfd_set_section_alignment	function
(	O
s	pointer
,	O
bed	pointer
->	O
s	pointer
->	O
log_file_align	char
)	O
)	O
return	O
FALSE	int
;	O
*	O
srelplt2_out	pointer
=	O
s	pointer
;	O
}	O
if	O
(	O
htab	struct
->	O
hgot	pointer
)	O
{	O
htab	struct
->	O
hgot	pointer
->	O
indx	long
=	O
-	O
2	int
;	O
htab	struct
->	O
hgot	pointer
->	O
other	int
&=	O
~	O
ELF_ST_VISIBILITY	O
(	O
-	O
1	int
)	O
;	O
htab	struct
->	O
hgot	pointer
->	O
forced_local	int
=	O
0	int
;	O
if	O
(	O
!	O
bfd_elf_link_record_dynamic_symbol	function
(	O
info	pointer
,	O
htab	struct
->	O
hgot	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
htab	struct
->	O
hplt	pointer
)	O
{	O
htab	struct
->	O
hplt	pointer
->	O
indx	long
=	O
-	O
2	int
;	O
htab	struct
->	O
hplt	pointer
->	O
type	enum
=	O
STT_FUNC	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
int	O
elf_vxworks_link_output_symbol_hook	function
(	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
const	O
char	O
*	O
name	pointer
,	O
Elf_Internal_Sym	struct
*	O
sym	pointer
,	O
asection	struct
*	O
input_sec	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
elf_link_hash_entry	struct
*	O
h	pointer
)	O
{	O
if	O
(	O
h	pointer
&&	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
&&	O
elf_vxworks_gott_symbol_p	function
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
undef	struct
.	O
abfd	pointer
,	O
name	pointer
)	O
)	O
sym	pointer
->	O
st_info	array
=	O
ELF_ST_INFO	O
(	O
STB_GLOBAL	int
,	O
ELF_ST_TYPE	O
(	O
sym	pointer
->	O
st_info	array
)	O
)	O
;	O
return	O
1	int
;	O
}	O
bfd_boolean	int
elf_vxworks_emit_relocs	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
asection	struct
*	O
input_section	pointer
,	O
Elf_Internal_Shdr	struct
*	O
input_rel_hdr	pointer
,	O
Elf_Internal_Rela	struct
*	O
internal_relocs	pointer
,	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
rel_hash	pointer
)	O
{	O
const	O
struct	O
elf_backend_data	struct
*	O
bed	pointer
;	O
int	O
j	int
;	O
bed	pointer
=	O
get_elf_backend_data	O
(	O
output_bfd	pointer
)	O
;	O
if	O
(	O
output_bfd	pointer
->	O
flags	int
&	O
(	O
DYNAMIC	int
|	O
EXEC_P	int
)	O
)	O
{	O
Elf_Internal_Rela	struct
*	O
irela	pointer
;	O
Elf_Internal_Rela	struct
*	O
irelaend	pointer
;	O
struct	O
elf_link_hash_entry	struct
*	O
*	O
hash_ptr	pointer
;	O
for	O
(	O
irela	pointer
=	O
internal_relocs	pointer
,	O
irelaend	pointer
=	O
irela	pointer
+	O
(	O
NUM_SHDR_ENTRIES	O
(	O
input_rel_hdr	pointer
)	O
*	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
)	O
,	O
hash_ptr	pointer
=	O
rel_hash	pointer
;	O
irela	pointer
<	O
irelaend	pointer
;	O
irela	pointer
+=	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
,	O
hash_ptr	pointer
++	O
)	O
{	O
if	O
(	O
*	O
hash_ptr	pointer
&&	O
(	O
*	O
hash_ptr	pointer
)	O
->	O
def_dynamic	int
&&	O
!	O
(	O
*	O
hash_ptr	pointer
)	O
->	O
def_regular	int
&&	O
(	O
(	O
*	O
hash_ptr	pointer
)	O
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
(	O
*	O
hash_ptr	pointer
)	O
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
&&	O
(	O
*	O
hash_ptr	pointer
)	O
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
bed	pointer
->	O
s	pointer
->	O
int_rels_per_ext_rel	char
;	O
j	int
++	O
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
(	O
*	O
hash_ptr	pointer
)	O
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
int	O
this_idx	int
=	O
sec	pointer
->	O
output_section	pointer
->	O
target_index	int
;	O
irela	pointer
[	O
j	int
]	O
.	O
r_info	array
=	O
ELF32_R_INFO	O
(	O
this_idx	int
,	O
ELF32_R_TYPE	O
(	O
irela	pointer
[	O
j	int
]	O
.	O
r_info	array
)	O
)	O
;	O
irela	pointer
[	O
j	int
]	O
.	O
r_addend	array
+=	O
(	O
*	O
hash_ptr	pointer
)	O
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
;	O
irela	pointer
[	O
j	int
]	O
.	O
r_addend	array
+=	O
sec	pointer
->	O
output_offset	long
;	O
}	O
*	O
hash_ptr	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
return	O
_bfd_elf_link_output_relocs	function
(	O
output_bfd	pointer
,	O
input_section	pointer
,	O
input_rel_hdr	pointer
,	O
internal_relocs	pointer
,	O
rel_hash	pointer
)	O
;	O
}	O
bfd_boolean	int
elf_vxworks_final_write_processing	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
struct	O
bfd_elf_section_data	struct
*	O
d	pointer
;	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".rel.plt.unloaded"	pointer
)	O
;	O
if	O
(	O
!	O
sec	pointer
)	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".rela.plt.unloaded"	pointer
)	O
;	O
if	O
(	O
sec	pointer
)	O
{	O
d	pointer
=	O
elf_section_data	O
(	O
sec	pointer
)	O
;	O
d	pointer
->	O
this_hdr	struct
.	O
sh_link	array
=	O
elf_onesymtab	O
(	O
abfd	pointer
)	O
;	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".plt"	pointer
)	O
;	O
if	O
(	O
sec	pointer
)	O
d	pointer
->	O
this_hdr	struct
.	O
sh_info	array
=	O
elf_section_data	O
(	O
sec	pointer
)	O
->	O
this_idx	int
;	O
}	O
return	O
_bfd_elf_final_write_processing	function
(	O
abfd	pointer
)	O
;	O
}	O
bfd_boolean	int
elf_vxworks_add_dynamic_entries	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
if	O
(	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".tls_data"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_VX_WRS_TLS_DATA_START	int
,	O
0	int
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_VX_WRS_TLS_DATA_SIZE	int
,	O
0	int
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_VX_WRS_TLS_DATA_ALIGN	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".tls_vars"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_VX_WRS_TLS_VARS_START	int
,	O
0	int
)	O
||	O
!	O
_bfd_elf_add_dynamic_entry	function
(	O
info	pointer
,	O
DT_VX_WRS_TLS_VARS_SIZE	int
,	O
0	int
)	O
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
elf_vxworks_finish_dynamic_entry	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
Elf_Internal_Dyn	struct
*	O
dyn	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
switch	O
(	O
dyn	pointer
->	O
d_tag	array
)	O
{	O
default	O
:	O
return	O
FALSE	int
;	O
case	O
DT_VX_WRS_TLS_DATA_START	int
:	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".tls_data"	pointer
)	O
;	O
dyn	pointer
->	O
d_un	union
.	O
d_ptr	array
=	O
sec	pointer
->	O
vma	long
;	O
break	O
;	O
case	O
DT_VX_WRS_TLS_DATA_SIZE	int
:	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".tls_data"	pointer
)	O
;	O
dyn	pointer
->	O
d_un	union
.	O
d_val	array
=	O
sec	pointer
->	O
size	long
;	O
break	O
;	O
case	O
DT_VX_WRS_TLS_DATA_ALIGN	int
:	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".tls_data"	pointer
)	O
;	O
dyn	pointer
->	O
d_un	union
.	O
d_val	array
=	O
(	O
bfd_size_type	long
)	O
1	int
<<	O
bfd_section_alignment	function
(	O
sec	pointer
)	O
;	O
break	O
;	O
case	O
DT_VX_WRS_TLS_VARS_START	int
:	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".tls_vars"	pointer
)	O
;	O
dyn	pointer
->	O
d_un	union
.	O
d_ptr	array
=	O
sec	pointer
->	O
vma	long
;	O
break	O
;	O
case	O
DT_VX_WRS_TLS_VARS_SIZE	int
:	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
output_bfd	pointer
,	O
".tls_vars"	pointer
)	O
;	O
dyn	pointer
->	O
d_un	union
.	O
d_val	array
=	O
sec	pointer
->	O
size	long
;	O
break	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
