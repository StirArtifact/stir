static	O
int	O
genv_get_right_eigenvectors	function
(	O
const	O
gsl_matrix	struct
*	O
S	pointer
,	O
const	O
gsl_matrix	struct
*	O
T	pointer
,	O
gsl_matrix	struct
*	O
Z	pointer
,	O
gsl_matrix_complex	struct
*	O
evec	pointer
,	O
gsl_eigen_genv_workspace	struct
*	O
w	pointer
)	O
;	O
static	O
void	O
genv_normalize_eigenvectors	function
(	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_matrix_complex	struct
*	O
evec	pointer
)	O
;	O
gsl_eigen_genv_workspace	struct
*	O
gsl_eigen_genv_alloc	function
(	O
const	O
size_t	long
n	long
)	O
{	O
gsl_eigen_genv_workspace	struct
*	O
w	pointer
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"matrix dimension must be positive integer"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
w	pointer
=	O
(	O
gsl_eigen_genv_workspace	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
gsl_eigen_genv_workspace	struct
)	O
)	O
;	O
if	O
(	O
w	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for workspace"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
w	pointer
->	O
size	long
=	O
n	long
;	O
w	pointer
->	O
Q	pointer
=	O
NULL	O
;	O
w	pointer
->	O
Z	pointer
=	O
NULL	O
;	O
w	pointer
->	O
gen_workspace_p	pointer
=	O
gsl_eigen_gen_alloc	function
(	O
n	long
)	O
;	O
if	O
(	O
w	pointer
->	O
gen_workspace_p	pointer
==	O
0	int
)	O
{	O
gsl_eigen_genv_free	function
(	O
w	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for gen workspace"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
gsl_eigen_gen_params	function
(	O
1	int
,	O
1	int
,	O
1	int
,	O
w	pointer
->	O
gen_workspace_p	pointer
)	O
;	O
w	pointer
->	O
work1	pointer
=	O
gsl_vector_alloc	function
(	O
n	long
)	O
;	O
w	pointer
->	O
work2	pointer
=	O
gsl_vector_alloc	function
(	O
n	long
)	O
;	O
w	pointer
->	O
work3	pointer
=	O
gsl_vector_alloc	function
(	O
n	long
)	O
;	O
w	pointer
->	O
work4	pointer
=	O
gsl_vector_alloc	function
(	O
n	long
)	O
;	O
w	pointer
->	O
work5	pointer
=	O
gsl_vector_alloc	function
(	O
n	long
)	O
;	O
w	pointer
->	O
work6	pointer
=	O
gsl_vector_alloc	function
(	O
n	long
)	O
;	O
if	O
(	O
w	pointer
->	O
work1	pointer
==	O
0	int
||	O
w	pointer
->	O
work2	pointer
==	O
0	int
||	O
w	pointer
->	O
work3	pointer
==	O
0	int
||	O
w	pointer
->	O
work4	pointer
==	O
0	int
||	O
w	pointer
->	O
work5	pointer
==	O
0	int
||	O
w	pointer
->	O
work6	pointer
==	O
0	int
)	O
{	O
gsl_eigen_genv_free	function
(	O
w	pointer
)	O
;	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for additional workspace"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
return	O
(	O
w	pointer
)	O
;	O
}	O
void	O
gsl_eigen_genv_free	function
(	O
gsl_eigen_genv_workspace	struct
*	O
w	pointer
)	O
{	O
RETURN_IF_NULL	O
(	O
w	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
gen_workspace_p	pointer
)	O
gsl_eigen_gen_free	function
(	O
w	pointer
->	O
gen_workspace_p	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
work1	pointer
)	O
gsl_vector_free	function
(	O
w	pointer
->	O
work1	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
work2	pointer
)	O
gsl_vector_free	function
(	O
w	pointer
->	O
work2	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
work3	pointer
)	O
gsl_vector_free	function
(	O
w	pointer
->	O
work3	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
work4	pointer
)	O
gsl_vector_free	function
(	O
w	pointer
->	O
work4	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
work5	pointer
)	O
gsl_vector_free	function
(	O
w	pointer
->	O
work5	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
work6	pointer
)	O
gsl_vector_free	function
(	O
w	pointer
->	O
work6	pointer
)	O
;	O
free	function
(	O
w	pointer
)	O
;	O
}	O
int	O
gsl_eigen_genv	function
(	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_matrix	struct
*	O
B	pointer
,	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_vector	struct
*	O
beta	long double
,	O
gsl_matrix_complex	struct
*	O
evec	pointer
,	O
gsl_eigen_genv_workspace	struct
*	O
w	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
A	pointer
->	O
size1	long
;	O
if	O
(	O
N	int
!=	O
A	pointer
->	O
size2	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square to compute eigenvalues"	pointer
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
(	O
N	int
!=	O
B	pointer
->	O
size1	long
)	O
||	O
(	O
N	int
!=	O
B	pointer
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"B matrix dimensions must match A"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
alpha	long double
->	O
size	long
!=	O
N	int
||	O
beta	long double
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"eigenvalue vector must match matrix size"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
w	pointer
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"matrix size does not match workspace"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
evec	pointer
->	O
size1	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"eigenvector matrix has wrong size"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
int	O
s	pointer
;	O
gsl_matrix	struct
Z	pointer
;	O
Z	pointer
.	O
size1	long
=	O
N	int
;	O
Z	pointer
.	O
size2	long
=	O
N	int
;	O
Z	pointer
.	O
tda	long
=	O
2	int
*	O
N	int
;	O
Z	pointer
.	O
data	pointer
=	O
evec	pointer
->	O
data	pointer
;	O
Z	pointer
.	O
block	pointer
=	O
0	int
;	O
Z	pointer
.	O
owner	int
=	O
0	int
;	O
s	pointer
=	O
gsl_eigen_gen_QZ	function
(	O
A	pointer
,	O
B	pointer
,	O
alpha	long double
,	O
beta	long double
,	O
w	pointer
->	O
Q	pointer
,	O
&	O
Z	pointer
,	O
w	pointer
->	O
gen_workspace_p	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
Z	pointer
)	O
{	O
gsl_matrix_memcpy	function
(	O
w	pointer
->	O
Z	pointer
,	O
&	O
Z	pointer
)	O
;	O
}	O
if	O
(	O
s	pointer
==	O
GSL_SUCCESS	int
)	O
{	O
s	pointer
=	O
genv_get_right_eigenvectors	function
(	O
A	pointer
,	O
B	pointer
,	O
&	O
Z	pointer
,	O
evec	pointer
,	O
w	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
GSL_SUCCESS	int
)	O
genv_normalize_eigenvectors	function
(	O
alpha	long double
,	O
evec	pointer
)	O
;	O
}	O
return	O
s	pointer
;	O
}	O
}	O
int	O
gsl_eigen_genv_QZ	function
(	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_matrix	struct
*	O
B	pointer
,	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_vector	struct
*	O
beta	long double
,	O
gsl_matrix_complex	struct
*	O
evec	pointer
,	O
gsl_matrix	struct
*	O
Q	pointer
,	O
gsl_matrix	struct
*	O
Z	pointer
,	O
gsl_eigen_genv_workspace	struct
*	O
w	pointer
)	O
{	O
if	O
(	O
Q	pointer
&&	O
(	O
A	pointer
->	O
size1	long
!=	O
Q	pointer
->	O
size1	long
||	O
A	pointer
->	O
size1	long
!=	O
Q	pointer
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"Q matrix has wrong dimensions"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
Z	pointer
&&	O
(	O
A	pointer
->	O
size1	long
!=	O
Z	pointer
->	O
size1	long
||	O
A	pointer
->	O
size1	long
!=	O
Z	pointer
->	O
size2	long
)	O
)	O
{	O
GSL_ERROR	O
(	O
"Z matrix has wrong dimensions"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
int	O
s	pointer
;	O
w	pointer
->	O
Q	pointer
=	O
Q	pointer
;	O
w	pointer
->	O
Z	pointer
=	O
Z	pointer
;	O
s	pointer
=	O
gsl_eigen_genv	function
(	O
A	pointer
,	O
B	pointer
,	O
alpha	long double
,	O
beta	long double
,	O
evec	pointer
,	O
w	pointer
)	O
;	O
w	pointer
->	O
Q	pointer
=	O
NULL	O
;	O
w	pointer
->	O
Z	pointer
=	O
NULL	O
;	O
return	O
s	pointer
;	O
}	O
}	O
static	O
int	O
genv_get_right_eigenvectors	function
(	O
const	O
gsl_matrix	struct
*	O
S	pointer
,	O
const	O
gsl_matrix	struct
*	O
T	pointer
,	O
gsl_matrix	struct
*	O
Z	pointer
,	O
gsl_matrix_complex	struct
*	O
evec	pointer
,	O
gsl_eigen_genv_workspace	struct
*	O
w	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
w	pointer
->	O
size	long
;	O
const	O
double	O
small	double
=	O
GSL_DBL_MIN	int
*	O
N	int
/	O
GSL_DBL_EPSILON	int
;	O
const	O
double	O
big	double
=	O
1.0	int
/	O
small	double
;	O
const	O
double	O
bignum	double
=	O
1.0	int
/	O
(	O
GSL_DBL_MIN	int
*	O
N	int
)	O
;	O
size_t	long
i	long
,	O
j	long
,	O
k	long
,	O
end	long
;	O
int	O
is	int
;	O
double	O
anorm	double
,	O
bnorm	double
;	O
double	O
temp	double
,	O
temp2	double
,	O
temp2r	double
,	O
temp2i	double
;	O
double	O
ascale	double
,	O
bscale	double
;	O
double	O
salfar	double
,	O
sbeta	double
;	O
double	O
acoef	double
,	O
bcoefr	double
,	O
bcoefi	double
,	O
acoefa	double
,	O
bcoefa	double
;	O
double	O
creala	double
,	O
cimaga	double
,	O
crealb	double
,	O
cimagb	double
,	O
cre2a	double
,	O
cim2a	double
,	O
cre2b	double
,	O
cim2b	double
;	O
double	O
dmin	double
,	O
xmax	double
;	O
double	O
scale	double
;	O
size_t	long
nw	long
,	O
na	long
;	O
int	O
lsa	int
,	O
lsb	int
;	O
int	O
complex_pair	int
;	O
gsl_complex	struct
z_zero	struct
,	O
z_one	struct
;	O
double	O
bdiag	array
[	O
2	int
]	O
=	O
{	O
0.0	int
,	O
0.0	int
}	O
;	O
double	O
sum	array
[	O
4	int
]	O
;	O
int	O
il2by2	int
;	O
size_t	long
jr	long
,	O
jc	long
,	O
ja	long
;	O
double	O
xscale	double
;	O
gsl_vector_complex_view	struct
ecol	struct
;	O
gsl_vector_view	struct
re	struct
,	O
im	struct
,	O
re2	struct
,	O
im2	struct
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z_zero	struct
,	O
0.0	int
,	O
0.0	int
)	O
;	O
GSL_SET_COMPLEX	O
(	O
&	O
z_one	struct
,	O
1.0	int
,	O
0.0	int
)	O
;	O
anorm	double
=	O
fabs	function
(	O
gsl_matrix_get	function
(	O
S	pointer
,	O
0	int
,	O
0	int
)	O
)	O
;	O
if	O
(	O
N	int
>	O
1	int
)	O
anorm	double
+=	O
fabs	function
(	O
gsl_matrix_get	function
(	O
S	pointer
,	O
1	int
,	O
0	int
)	O
)	O
;	O
bnorm	double
=	O
fabs	function
(	O
gsl_matrix_get	function
(	O
T	pointer
,	O
0	int
,	O
0	int
)	O
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work1	pointer
,	O
0	int
,	O
0.0	int
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work2	pointer
,	O
0	int
,	O
0.0	int
)	O
;	O
for	O
(	O
j	long
=	O
1	int
;	O
j	long
<	O
N	int
;	O
++	O
j	long
)	O
{	O
temp	double
=	O
temp2	double
=	O
0.0	int
;	O
if	O
(	O
gsl_matrix_get	function
(	O
S	pointer
,	O
j	long
,	O
j	long
-	O
1	int
)	O
==	O
0.0	int
)	O
end	long
=	O
j	long
;	O
else	O
end	long
=	O
j	long
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
end	long
;	O
++	O
i	long
)	O
{	O
temp	double
+=	O
fabs	function
(	O
gsl_matrix_get	function
(	O
S	pointer
,	O
i	long
,	O
j	long
)	O
)	O
;	O
temp2	double
+=	O
fabs	function
(	O
gsl_matrix_get	function
(	O
T	pointer
,	O
i	long
,	O
j	long
)	O
)	O
;	O
}	O
gsl_vector_set	function
(	O
w	pointer
->	O
work1	pointer
,	O
j	long
,	O
temp	double
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work2	pointer
,	O
j	long
,	O
temp2	double
)	O
;	O
for	O
(	O
i	long
=	O
end	long
;	O
i	long
<	O
GSL_MIN	O
(	O
j	long
+	O
2	int
,	O
N	int
)	O
;	O
++	O
i	long
)	O
{	O
temp	double
+=	O
fabs	function
(	O
gsl_matrix_get	function
(	O
S	pointer
,	O
i	long
,	O
j	long
)	O
)	O
;	O
temp2	double
+=	O
fabs	function
(	O
gsl_matrix_get	function
(	O
T	pointer
,	O
i	long
,	O
j	long
)	O
)	O
;	O
}	O
anorm	double
=	O
GSL_MAX	O
(	O
anorm	double
,	O
temp	double
)	O
;	O
bnorm	double
=	O
GSL_MAX	O
(	O
bnorm	double
,	O
temp2	double
)	O
;	O
}	O
ascale	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
anorm	double
,	O
GSL_DBL_MIN	int
)	O
;	O
bscale	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
bnorm	double
,	O
GSL_DBL_MIN	int
)	O
;	O
complex_pair	int
=	O
0	int
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
N	int
;	O
++	O
k	long
)	O
{	O
size_t	long
je	long
=	O
N	int
-	O
1	int
-	O
k	long
;	O
if	O
(	O
complex_pair	int
)	O
{	O
complex_pair	int
=	O
0	int
;	O
continue	O
;	O
}	O
nw	long
=	O
1	int
;	O
if	O
(	O
je	long
>	O
0	int
)	O
{	O
if	O
(	O
gsl_matrix_get	function
(	O
S	pointer
,	O
je	long
,	O
je	long
-	O
1	int
)	O
!=	O
0.0	int
)	O
{	O
complex_pair	int
=	O
1	int
;	O
nw	long
=	O
2	int
;	O
}	O
}	O
if	O
(	O
!	O
complex_pair	int
)	O
{	O
if	O
(	O
fabs	function
(	O
gsl_matrix_get	function
(	O
S	pointer
,	O
je	long
,	O
je	long
)	O
)	O
<=	O
GSL_DBL_MIN	int
&&	O
fabs	function
(	O
gsl_matrix_get	function
(	O
T	pointer
,	O
je	long
,	O
je	long
)	O
)	O
<=	O
GSL_DBL_MIN	int
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
N	int
;	O
++	O
i	long
)	O
gsl_matrix_complex_set	function
(	O
evec	pointer
,	O
i	long
,	O
je	long
,	O
z_zero	struct
)	O
;	O
gsl_matrix_complex_set	function
(	O
evec	pointer
,	O
je	long
,	O
je	long
,	O
z_one	struct
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
N	int
;	O
++	O
i	long
)	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
i	long
,	O
0.0	int
)	O
;	O
}	O
else	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
N	int
;	O
++	O
i	long
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
i	long
,	O
0.0	int
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work4	pointer
,	O
i	long
,	O
0.0	int
)	O
;	O
}	O
}	O
if	O
(	O
!	O
complex_pair	int
)	O
{	O
temp	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
GSL_MAX	O
(	O
fabs	function
(	O
gsl_matrix_get	function
(	O
S	pointer
,	O
je	long
,	O
je	long
)	O
)	O
*	O
ascale	double
,	O
fabs	function
(	O
gsl_matrix_get	function
(	O
T	pointer
,	O
je	long
,	O
je	long
)	O
)	O
*	O
bscale	double
)	O
)	O
;	O
salfar	double
=	O
(	O
temp	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
je	long
,	O
je	long
)	O
)	O
*	O
ascale	double
;	O
sbeta	double
=	O
(	O
temp	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
je	long
,	O
je	long
)	O
)	O
*	O
bscale	double
;	O
acoef	double
=	O
sbeta	double
*	O
ascale	double
;	O
bcoefr	double
=	O
salfar	double
*	O
bscale	double
;	O
bcoefi	double
=	O
0.0	int
;	O
scale	double
=	O
1.0	int
;	O
lsa	int
=	O
fabs	function
(	O
sbeta	double
)	O
>=	O
GSL_DBL_MIN	int
&&	O
fabs	function
(	O
acoef	double
)	O
<	O
small	double
;	O
lsb	int
=	O
fabs	function
(	O
salfar	double
)	O
>=	O
GSL_DBL_MIN	int
&&	O
fabs	function
(	O
bcoefr	double
)	O
<	O
small	double
;	O
if	O
(	O
lsa	int
)	O
scale	double
=	O
(	O
small	double
/	O
fabs	function
(	O
sbeta	double
)	O
)	O
*	O
GSL_MIN	O
(	O
anorm	double
,	O
big	double
)	O
;	O
if	O
(	O
lsb	int
)	O
scale	double
=	O
GSL_MAX	O
(	O
scale	double
,	O
(	O
small	double
/	O
fabs	function
(	O
salfar	double
)	O
)	O
*	O
GSL_MIN	O
(	O
bnorm	double
,	O
big	double
)	O
)	O
;	O
if	O
(	O
lsa	int
||	O
lsb	int
)	O
{	O
scale	double
=	O
GSL_MIN	O
(	O
scale	double
,	O
1.0	int
/	O
(	O
GSL_DBL_MIN	int
*	O
GSL_MAX	O
(	O
1.0	int
,	O
GSL_MAX	O
(	O
fabs	function
(	O
acoef	double
)	O
,	O
fabs	function
(	O
bcoefr	double
)	O
)	O
)	O
)	O
)	O
;	O
if	O
(	O
lsa	int
)	O
acoef	double
=	O
ascale	double
*	O
(	O
scale	double
*	O
sbeta	double
)	O
;	O
else	O
acoef	double
*=	O
scale	double
;	O
if	O
(	O
lsb	int
)	O
bcoefr	double
=	O
bscale	double
*	O
(	O
scale	double
*	O
salfar	double
)	O
;	O
else	O
bcoefr	double
*=	O
scale	double
;	O
}	O
acoefa	double
=	O
fabs	function
(	O
acoef	double
)	O
;	O
bcoefa	double
=	O
fabs	function
(	O
bcoefr	double
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
,	O
1.0	int
)	O
;	O
xmax	double
=	O
1.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
je	long
;	O
++	O
i	long
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
i	long
,	O
bcoefr	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
i	long
,	O
je	long
)	O
-	O
acoef	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
i	long
,	O
je	long
)	O
)	O
;	O
}	O
}	O
else	O
{	O
gsl_matrix_const_view	struct
vs	struct
=	O
gsl_matrix_const_submatrix	function
(	O
S	pointer
,	O
je	long
-	O
1	int
,	O
je	long
-	O
1	int
,	O
2	int
,	O
2	int
)	O
;	O
gsl_matrix_const_view	struct
vt	struct
=	O
gsl_matrix_const_submatrix	function
(	O
T	pointer
,	O
je	long
-	O
1	int
,	O
je	long
-	O
1	int
,	O
2	int
,	O
2	int
)	O
;	O
gsl_schur_gen_eigvals	function
(	O
&	O
vs	struct
.	O
matrix	struct
,	O
&	O
vt	struct
.	O
matrix	struct
,	O
&	O
bcoefr	double
,	O
&	O
temp2	double
,	O
&	O
bcoefi	double
,	O
&	O
acoef	double
,	O
&	O
temp	double
)	O
;	O
if	O
(	O
bcoefi	double
==	O
0.0	int
)	O
{	O
GSL_ERROR	O
(	O
"gsl_schur_gen_eigvals failed on complex block"	pointer
,	O
GSL_FAILURE	int
)	O
;	O
}	O
acoefa	double
=	O
fabs	function
(	O
acoef	double
)	O
;	O
bcoefa	double
=	O
fabs	function
(	O
bcoefr	double
)	O
+	O
fabs	function
(	O
bcoefi	double
)	O
;	O
scale	double
=	O
1.0	int
;	O
if	O
(	O
acoefa	double
*	O
GSL_DBL_EPSILON	int
<	O
GSL_DBL_MIN	int
&&	O
acoefa	double
>=	O
GSL_DBL_MIN	int
)	O
scale	double
=	O
(	O
GSL_DBL_MIN	int
/	O
GSL_DBL_EPSILON	int
)	O
/	O
acoefa	double
;	O
if	O
(	O
bcoefa	double
*	O
GSL_DBL_EPSILON	int
<	O
GSL_DBL_MIN	int
&&	O
bcoefa	double
>=	O
GSL_DBL_MIN	int
)	O
scale	double
=	O
GSL_MAX	O
(	O
scale	double
,	O
(	O
GSL_DBL_MIN	int
/	O
GSL_DBL_EPSILON	int
)	O
/	O
bcoefa	double
)	O
;	O
if	O
(	O
GSL_DBL_MIN	int
*	O
acoefa	double
>	O
ascale	double
)	O
scale	double
=	O
ascale	double
/	O
(	O
GSL_DBL_MIN	int
*	O
acoefa	double
)	O
;	O
if	O
(	O
GSL_DBL_MIN	int
*	O
bcoefa	double
>	O
bscale	double
)	O
scale	double
=	O
GSL_MIN	O
(	O
scale	double
,	O
bscale	double
/	O
(	O
GSL_DBL_MIN	int
*	O
bcoefa	double
)	O
)	O
;	O
if	O
(	O
scale	double
!=	O
1.0	int
)	O
{	O
acoef	double
*=	O
scale	double
;	O
acoefa	double
=	O
fabs	function
(	O
acoef	double
)	O
;	O
bcoefr	double
*=	O
scale	double
;	O
bcoefi	double
*=	O
scale	double
;	O
bcoefa	double
=	O
fabs	function
(	O
bcoefr	double
)	O
+	O
fabs	function
(	O
bcoefi	double
)	O
;	O
}	O
temp	double
=	O
acoef	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
je	long
,	O
je	long
-	O
1	int
)	O
;	O
temp2r	double
=	O
acoef	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
je	long
,	O
je	long
)	O
-	O
bcoefr	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
je	long
,	O
je	long
)	O
;	O
temp2i	double
=	O
-	O
bcoefi	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
je	long
,	O
je	long
)	O
;	O
if	O
(	O
fabs	function
(	O
temp	double
)	O
>=	O
fabs	function
(	O
temp2r	double
)	O
+	O
fabs	function
(	O
temp2i	double
)	O
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
,	O
1.0	int
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
,	O
0.0	int
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
-	O
1	int
,	O
-	O
temp2r	double
/	O
temp	double
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
-	O
1	int
,	O
-	O
temp2i	double
/	O
temp	double
)	O
;	O
}	O
else	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
-	O
1	int
,	O
1.0	int
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
-	O
1	int
,	O
0.0	int
)	O
;	O
temp	double
=	O
acoef	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
je	long
-	O
1	int
,	O
je	long
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
,	O
(	O
bcoefr	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
je	long
-	O
1	int
,	O
je	long
-	O
1	int
)	O
-	O
acoef	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
je	long
-	O
1	int
,	O
je	long
-	O
1	int
)	O
)	O
/	O
temp	double
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
,	O
bcoefi	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
je	long
-	O
1	int
,	O
je	long
-	O
1	int
)	O
/	O
temp	double
)	O
;	O
}	O
xmax	double
=	O
GSL_MAX	O
(	O
fabs	function
(	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
)	O
)	O
+	O
fabs	function
(	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
)	O
)	O
,	O
fabs	function
(	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
-	O
1	int
)	O
)	O
+	O
fabs	function
(	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
-	O
1	int
)	O
)	O
)	O
;	O
creala	double
=	O
acoef	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
-	O
1	int
)	O
;	O
cimaga	double
=	O
acoef	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
-	O
1	int
)	O
;	O
crealb	double
=	O
bcoefr	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
-	O
1	int
)	O
-	O
bcoefi	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
-	O
1	int
)	O
;	O
cimagb	double
=	O
bcoefi	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
-	O
1	int
)	O
+	O
bcoefr	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
-	O
1	int
)	O
;	O
cre2a	double
=	O
acoef	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
)	O
;	O
cim2a	double
=	O
acoef	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
)	O
;	O
cre2b	double
=	O
bcoefr	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
)	O
-	O
bcoefi	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
)	O
;	O
cim2b	double
=	O
bcoefi	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
je	long
)	O
+	O
bcoefr	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
je	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
je	long
-	O
1	int
;	O
++	O
i	long
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
i	long
,	O
-	O
creala	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
i	long
,	O
je	long
-	O
1	int
)	O
+	O
crealb	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
i	long
,	O
je	long
-	O
1	int
)	O
-	O
cre2a	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
i	long
,	O
je	long
)	O
+	O
cre2b	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
i	long
,	O
je	long
)	O
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work4	pointer
,	O
i	long
,	O
-	O
cimaga	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
i	long
,	O
je	long
-	O
1	int
)	O
+	O
cimagb	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
i	long
,	O
je	long
-	O
1	int
)	O
-	O
cim2a	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
i	long
,	O
je	long
)	O
+	O
cim2b	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
i	long
,	O
je	long
)	O
)	O
;	O
}	O
}	O
dmin	double
=	O
GSL_MAX	O
(	O
GSL_DBL_MIN	int
,	O
GSL_MAX	O
(	O
GSL_DBL_EPSILON	int
*	O
acoefa	double
*	O
anorm	double
,	O
GSL_DBL_EPSILON	int
*	O
bcoefa	double
*	O
bnorm	double
)	O
)	O
;	O
il2by2	int
=	O
0	int
;	O
for	O
(	O
is	int
=	O
(	O
int	O
)	O
je	long
-	O
(	O
int	O
)	O
nw	long
;	O
is	int
>=	O
0	int
;	O
--	O
is	int
)	O
{	O
j	long
=	O
(	O
size_t	long
)	O
is	int
;	O
if	O
(	O
!	O
il2by2	int
&&	O
j	long
>	O
0	int
)	O
{	O
if	O
(	O
gsl_matrix_get	function
(	O
S	pointer
,	O
j	long
,	O
j	long
-	O
1	int
)	O
!=	O
0.0	int
)	O
{	O
il2by2	int
=	O
1	int
;	O
continue	O
;	O
}	O
}	O
bdiag	array
[	O
0	int
]	O
=	O
gsl_matrix_get	function
(	O
T	pointer
,	O
j	long
,	O
j	long
)	O
;	O
if	O
(	O
il2by2	int
)	O
{	O
na	long
=	O
2	int
;	O
bdiag	array
[	O
1	int
]	O
=	O
gsl_matrix_get	function
(	O
T	pointer
,	O
j	long
+	O
1	int
,	O
j	long
+	O
1	int
)	O
;	O
}	O
else	O
na	long
=	O
1	int
;	O
if	O
(	O
nw	long
==	O
1	int
)	O
{	O
gsl_matrix_const_view	struct
sv	struct
=	O
gsl_matrix_const_submatrix	function
(	O
S	pointer
,	O
j	long
,	O
j	long
,	O
na	long
,	O
na	long
)	O
;	O
gsl_vector_view	struct
xv	struct
,	O
bv	struct
;	O
bv	struct
=	O
gsl_vector_subvector	function
(	O
w	pointer
->	O
work3	pointer
,	O
j	long
,	O
na	long
)	O
;	O
xv	struct
=	O
gsl_vector_view_array_with_stride	function
(	O
sum	array
,	O
2	int
,	O
na	long
)	O
;	O
gsl_schur_solve_equation	function
(	O
acoef	double
,	O
&	O
sv	struct
.	O
matrix	struct
,	O
bcoefr	double
,	O
bdiag	array
[	O
0	int
]	O
,	O
bdiag	array
[	O
1	int
]	O
,	O
&	O
bv	struct
.	O
vector	struct
,	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
scale	double
,	O
&	O
temp	double
,	O
dmin	double
)	O
;	O
}	O
else	O
{	O
double	O
bdat	array
[	O
4	int
]	O
;	O
gsl_matrix_const_view	struct
sv	struct
=	O
gsl_matrix_const_submatrix	function
(	O
S	pointer
,	O
j	long
,	O
j	long
,	O
na	long
,	O
na	long
)	O
;	O
gsl_vector_complex_view	struct
xv	struct
=	O
gsl_vector_complex_view_array	function
(	O
sum	array
,	O
na	long
)	O
;	O
gsl_vector_complex_view	struct
bv	struct
=	O
gsl_vector_complex_view_array	function
(	O
bdat	array
,	O
na	long
)	O
;	O
gsl_complex	struct
z	struct
;	O
bdat	array
[	O
0	int
]	O
=	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
j	long
)	O
;	O
bdat	array
[	O
1	int
]	O
=	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
j	long
)	O
;	O
if	O
(	O
na	long
==	O
2	int
)	O
{	O
bdat	array
[	O
2	int
]	O
=	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
j	long
+	O
1	int
)	O
;	O
bdat	array
[	O
3	int
]	O
=	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
j	long
+	O
1	int
)	O
;	O
}	O
GSL_SET_COMPLEX	O
(	O
&	O
z	struct
,	O
bcoefr	double
,	O
bcoefi	double
)	O
;	O
gsl_schur_solve_equation_z	function
(	O
acoef	double
,	O
&	O
sv	struct
.	O
matrix	struct
,	O
&	O
z	struct
,	O
bdiag	array
[	O
0	int
]	O
,	O
bdiag	array
[	O
1	int
]	O
,	O
&	O
bv	struct
.	O
vector	struct
,	O
&	O
xv	struct
.	O
vector	struct
,	O
&	O
scale	double
,	O
&	O
temp	double
,	O
dmin	double
)	O
;	O
}	O
if	O
(	O
scale	double
<	O
1.0	int
)	O
{	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<=	O
je	long
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
jr	long
,	O
scale	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
jr	long
)	O
)	O
;	O
if	O
(	O
nw	long
==	O
2	int
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work4	pointer
,	O
jr	long
,	O
scale	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
jr	long
)	O
)	O
;	O
}	O
}	O
}	O
xmax	double
=	O
GSL_MAX	O
(	O
scale	double
*	O
xmax	double
,	O
temp	double
)	O
;	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<	O
na	long
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
j	long
+	O
jr	long
,	O
sum	array
[	O
jr	long
*	O
na	long
]	O
)	O
;	O
if	O
(	O
nw	long
==	O
2	int
)	O
gsl_vector_set	function
(	O
w	pointer
->	O
work4	pointer
,	O
j	long
+	O
jr	long
,	O
sum	array
[	O
jr	long
*	O
na	long
+	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
j	long
>	O
0	int
)	O
{	O
xscale	double
=	O
1.0	int
/	O
GSL_MAX	O
(	O
1.0	int
,	O
xmax	double
)	O
;	O
temp	double
=	O
acoefa	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work1	pointer
,	O
j	long
)	O
+	O
bcoefa	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work2	pointer
,	O
j	long
)	O
;	O
if	O
(	O
il2by2	int
)	O
{	O
temp	double
=	O
GSL_MAX	O
(	O
temp	double
,	O
acoefa	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work1	pointer
,	O
j	long
+	O
1	int
)	O
+	O
bcoefa	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work2	pointer
,	O
j	long
+	O
1	int
)	O
)	O
;	O
}	O
temp	double
=	O
GSL_MAX	O
(	O
temp	double
,	O
GSL_MAX	O
(	O
acoefa	double
,	O
bcoefa	double
)	O
)	O
;	O
if	O
(	O
temp	double
>	O
bignum	double
*	O
xscale	double
)	O
{	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<=	O
je	long
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
jr	long
,	O
xscale	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
jr	long
)	O
)	O
;	O
if	O
(	O
nw	long
==	O
2	int
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work4	pointer
,	O
jr	long
,	O
xscale	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
jr	long
)	O
)	O
;	O
}	O
}	O
xmax	double
*=	O
xscale	double
;	O
}	O
for	O
(	O
ja	long
=	O
0	int
;	O
ja	long
<	O
na	long
;	O
++	O
ja	long
)	O
{	O
if	O
(	O
complex_pair	int
)	O
{	O
creala	double
=	O
acoef	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
j	long
+	O
ja	long
)	O
;	O
cimaga	double
=	O
acoef	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
j	long
+	O
ja	long
)	O
;	O
crealb	double
=	O
bcoefr	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
j	long
+	O
ja	long
)	O
-	O
bcoefi	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
j	long
+	O
ja	long
)	O
;	O
cimagb	double
=	O
bcoefi	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
j	long
+	O
ja	long
)	O
+	O
bcoefr	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
j	long
+	O
ja	long
)	O
;	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<=	O
j	long
-	O
1	int
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
jr	long
,	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
jr	long
)	O
-	O
creala	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
+	O
crealb	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
)	O
;	O
gsl_vector_set	function
(	O
w	pointer
->	O
work4	pointer
,	O
jr	long
,	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
jr	long
)	O
-	O
cimaga	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
+	O
cimagb	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
)	O
;	O
}	O
}	O
else	O
{	O
creala	double
=	O
acoef	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
j	long
+	O
ja	long
)	O
;	O
crealb	double
=	O
bcoefr	double
*	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
j	long
+	O
ja	long
)	O
;	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<=	O
j	long
-	O
1	int
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work3	pointer
,	O
jr	long
,	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
jr	long
)	O
-	O
creala	double
*	O
gsl_matrix_get	function
(	O
S	pointer
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
+	O
crealb	double
*	O
gsl_matrix_get	function
(	O
T	pointer
,	O
jr	long
,	O
j	long
+	O
ja	long
)	O
)	O
;	O
}	O
}	O
}	O
}	O
il2by2	int
=	O
0	int
;	O
}	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<	O
N	int
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work5	pointer
,	O
jr	long
,	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
0	int
)	O
*	O
gsl_matrix_get	function
(	O
Z	pointer
,	O
jr	long
,	O
0	int
)	O
)	O
;	O
if	O
(	O
nw	long
==	O
2	int
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work6	pointer
,	O
jr	long
,	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
0	int
)	O
*	O
gsl_matrix_get	function
(	O
Z	pointer
,	O
jr	long
,	O
0	int
)	O
)	O
;	O
}	O
}	O
for	O
(	O
jc	long
=	O
1	int
;	O
jc	long
<=	O
je	long
;	O
++	O
jc	long
)	O
{	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<	O
N	int
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work5	pointer
,	O
jr	long
,	O
gsl_vector_get	function
(	O
w	pointer
->	O
work5	pointer
,	O
jr	long
)	O
+	O
gsl_vector_get	function
(	O
w	pointer
->	O
work3	pointer
,	O
jc	long
)	O
*	O
gsl_matrix_get	function
(	O
Z	pointer
,	O
jr	long
,	O
jc	long
)	O
)	O
;	O
if	O
(	O
nw	long
==	O
2	int
)	O
{	O
gsl_vector_set	function
(	O
w	pointer
->	O
work6	pointer
,	O
jr	long
,	O
gsl_vector_get	function
(	O
w	pointer
->	O
work6	pointer
,	O
jr	long
)	O
+	O
gsl_vector_get	function
(	O
w	pointer
->	O
work4	pointer
,	O
jc	long
)	O
*	O
gsl_matrix_get	function
(	O
Z	pointer
,	O
jr	long
,	O
jc	long
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
complex_pair	int
)	O
{	O
ecol	struct
=	O
gsl_matrix_complex_column	function
(	O
evec	pointer
,	O
je	long
-	O
1	int
)	O
;	O
re	struct
=	O
gsl_vector_complex_real	function
(	O
&	O
ecol	struct
.	O
vector	struct
)	O
;	O
im	struct
=	O
gsl_vector_complex_imag	function
(	O
&	O
ecol	struct
.	O
vector	struct
)	O
;	O
ecol	struct
=	O
gsl_matrix_complex_column	function
(	O
evec	pointer
,	O
je	long
)	O
;	O
re2	struct
=	O
gsl_vector_complex_real	function
(	O
&	O
ecol	struct
.	O
vector	struct
)	O
;	O
im2	struct
=	O
gsl_vector_complex_imag	function
(	O
&	O
ecol	struct
.	O
vector	struct
)	O
;	O
}	O
else	O
{	O
ecol	struct
=	O
gsl_matrix_complex_column	function
(	O
evec	pointer
,	O
je	long
)	O
;	O
re	struct
=	O
gsl_vector_complex_real	function
(	O
&	O
ecol	struct
.	O
vector	struct
)	O
;	O
im	struct
=	O
gsl_vector_complex_imag	function
(	O
&	O
ecol	struct
.	O
vector	struct
)	O
;	O
}	O
for	O
(	O
jr	long
=	O
0	int
;	O
jr	long
<	O
N	int
;	O
++	O
jr	long
)	O
{	O
gsl_vector_set	function
(	O
&	O
re	struct
.	O
vector	struct
,	O
jr	long
,	O
gsl_vector_get	function
(	O
w	pointer
->	O
work5	pointer
,	O
jr	long
)	O
)	O
;	O
if	O
(	O
complex_pair	int
)	O
{	O
gsl_vector_set	function
(	O
&	O
im	struct
.	O
vector	struct
,	O
jr	long
,	O
gsl_vector_get	function
(	O
w	pointer
->	O
work6	pointer
,	O
jr	long
)	O
)	O
;	O
gsl_vector_set	function
(	O
&	O
re2	struct
.	O
vector	struct
,	O
jr	long
,	O
gsl_vector_get	function
(	O
w	pointer
->	O
work5	pointer
,	O
jr	long
)	O
)	O
;	O
gsl_vector_set	function
(	O
&	O
im2	struct
.	O
vector	struct
,	O
jr	long
,	O
-	O
gsl_vector_get	function
(	O
w	pointer
->	O
work6	pointer
,	O
jr	long
)	O
)	O
;	O
}	O
else	O
{	O
gsl_vector_set	function
(	O
&	O
im	struct
.	O
vector	struct
,	O
jr	long
,	O
0.0	int
)	O
;	O
}	O
}	O
xmax	double
=	O
0.0	int
;	O
if	O
(	O
complex_pair	int
)	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
;	O
++	O
j	long
)	O
{	O
xmax	double
=	O
GSL_MAX	O
(	O
xmax	double
,	O
fabs	function
(	O
gsl_vector_get	function
(	O
&	O
re	struct
.	O
vector	struct
,	O
j	long
)	O
)	O
+	O
fabs	function
(	O
gsl_vector_get	function
(	O
&	O
im	struct
.	O
vector	struct
,	O
j	long
)	O
)	O
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
;	O
++	O
j	long
)	O
{	O
xmax	double
=	O
GSL_MAX	O
(	O
xmax	double
,	O
fabs	function
(	O
gsl_vector_get	function
(	O
&	O
re	struct
.	O
vector	struct
,	O
j	long
)	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
xmax	double
>	O
GSL_DBL_MIN	int
)	O
{	O
xscale	double
=	O
1.0	int
/	O
xmax	double
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
N	int
;	O
++	O
j	long
)	O
{	O
gsl_vector_set	function
(	O
&	O
re	struct
.	O
vector	struct
,	O
j	long
,	O
gsl_vector_get	function
(	O
&	O
re	struct
.	O
vector	struct
,	O
j	long
)	O
*	O
xscale	double
)	O
;	O
if	O
(	O
complex_pair	int
)	O
{	O
gsl_vector_set	function
(	O
&	O
im	struct
.	O
vector	struct
,	O
j	long
,	O
gsl_vector_get	function
(	O
&	O
im	struct
.	O
vector	struct
,	O
j	long
)	O
*	O
xscale	double
)	O
;	O
gsl_vector_set	function
(	O
&	O
re2	struct
.	O
vector	struct
,	O
j	long
,	O
gsl_vector_get	function
(	O
&	O
re2	struct
.	O
vector	struct
,	O
j	long
)	O
*	O
xscale	double
)	O
;	O
gsl_vector_set	function
(	O
&	O
im2	struct
.	O
vector	struct
,	O
j	long
,	O
gsl_vector_get	function
(	O
&	O
im2	struct
.	O
vector	struct
,	O
j	long
)	O
*	O
xscale	double
)	O
;	O
}	O
}	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
void	O
genv_normalize_eigenvectors	function
(	O
gsl_vector_complex	struct
*	O
alpha	long double
,	O
gsl_matrix_complex	struct
*	O
evec	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
evec	pointer
->	O
size1	long
;	O
size_t	long
i	long
;	O
gsl_complex	struct
ai	struct
;	O
gsl_vector_complex_view	struct
vi	double
;	O
gsl_vector_view	struct
re	struct
,	O
im	struct
;	O
double	O
scale	double
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
N	int
;	O
++	O
i	long
)	O
{	O
ai	struct
=	O
gsl_vector_complex_get	function
(	O
alpha	long double
,	O
i	long
)	O
;	O
vi	double
=	O
gsl_matrix_complex_column	function
(	O
evec	pointer
,	O
i	long
)	O
;	O
re	struct
=	O
gsl_vector_complex_real	function
(	O
&	O
vi	double
.	O
vector	struct
)	O
;	O
if	O
(	O
GSL_IMAG	O
(	O
ai	struct
)	O
==	O
0.0	int
)	O
{	O
scale	double
=	O
1.0	int
/	O
gsl_blas_dnrm2	function
(	O
&	O
re	struct
.	O
vector	struct
)	O
;	O
gsl_blas_dscal	function
(	O
scale	double
,	O
&	O
re	struct
.	O
vector	struct
)	O
;	O
}	O
else	O
if	O
(	O
GSL_IMAG	O
(	O
ai	struct
)	O
>	O
0.0	int
)	O
{	O
im	struct
=	O
gsl_vector_complex_imag	function
(	O
&	O
vi	double
.	O
vector	struct
)	O
;	O
scale	double
=	O
1.0	int
/	O
gsl_hypot	function
(	O
gsl_blas_dnrm2	function
(	O
&	O
re	struct
.	O
vector	struct
)	O
,	O
gsl_blas_dnrm2	function
(	O
&	O
im	struct
.	O
vector	struct
)	O
)	O
;	O
gsl_blas_zdscal	function
(	O
scale	double
,	O
&	O
vi	double
.	O
vector	struct
)	O
;	O
vi	double
=	O
gsl_matrix_complex_column	function
(	O
evec	pointer
,	O
i	long
+	O
1	int
)	O
;	O
gsl_blas_zdscal	function
(	O
scale	double
,	O
&	O
vi	double
.	O
vector	struct
)	O
;	O
}	O
}	O
}	O
