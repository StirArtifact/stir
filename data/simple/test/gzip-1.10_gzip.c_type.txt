static	O
char	O
const	O
*	O
const	O
license_msg	array
[	O
]	O
=	O
{	O
"Copyright (C) 2018 Free Software Foundation, Inc."	pointer
,	O
"Copyright (C) 1993 Jean-loup Gailly."	pointer
,	O
"This is free software.  You may redistribute copies of it under the terms of"	pointer
,	O
"the GNU General Public License <https://www.gnu.org/licenses/gpl.html>."	pointer
,	O
"There is NO WARRANTY, to the extent permitted by law."	pointer
,	O
0	int
}	O
;	O
DECLARE	O
(	O
uch	char
,	O
inbuf	array
,	O
INBUFSIZ	int
+	O
INBUF_EXTRA	int
)	O
;	O
DECLARE	O
(	O
uch	char
,	O
outbuf	array
,	O
OUTBUFSIZ	int
+	O
OUTBUF_EXTRA	int
)	O
;	O
DECLARE	O
(	O
ush	short
,	O
d_buf	array
,	O
DIST_BUFSIZE	int
)	O
;	O
DECLARE	O
(	O
uch	char
,	O
window	array
,	O
2L	int
*	O
WSIZE	int
)	O
;	O
DECLARE	O
(	O
ush	short
,	O
tab_prefix	O
,	O
1L	int
<<	O
BITS	int
)	O
;	O
static	O
bool	bool
presume_input_tty	bool
;	O
static	O
bool	bool
synchronous	bool
;	O
static	O
int	O
ascii	int
=	O
0	int
;	O
int	O
to_stdout	int
=	O
0	int
;	O
static	O
int	O
decompress	int
=	O
0	int
;	O
static	O
int	O
force	int
=	O
0	int
;	O
static	O
int	O
keep	int
=	O
0	int
;	O
static	O
int	O
no_name	int
=	O
-	O
1	int
;	O
static	O
int	O
no_time	int
=	O
-	O
1	int
;	O
static	O
int	O
recursive	int
=	O
0	int
;	O
static	O
int	O
list	int
=	O
0	int
;	O
int	O
verbose	int
=	O
0	int
;	O
int	O
quiet	int
=	O
0	int
;	O
static	O
int	O
do_lzw	int
=	O
0	int
;	O
int	O
test	int
=	O
0	int
;	O
static	O
int	O
foreground	int
=	O
0	int
;	O
char	O
*	O
program_name	pointer
;	O
int	O
maxbits	int
=	O
BITS	int
;	O
int	O
method	int
=	O
DEFLATED	int
;	O
int	O
level	int
=	O
6	int
;	O
int	O
exit_code	int
=	O
OK	int
;	O
int	O
save_orig_name	int
;	O
static	O
int	O
last_member	int
;	O
static	O
int	O
part_nb	int
;	O
off_t	long
ifile_size	long
;	O
static	O
char	O
*	O
env	pointer
;	O
static	O
char	O
const	O
*	O
z_suffix	pointer
;	O
static	O
size_t	long
z_len	long
;	O
struct	O
timespec	struct
time_stamp	struct
;	O
static	O
sigset_t	struct
caught_signals	struct
;	O
static	O
int	O
volatile	O
exiting_signal	int
;	O
static	O
int	O
volatile	O
remove_ofname_fd	int
=	O
-	O
1	int
;	O
static	O
char	O
volatile	O
remove_ofname	array
[	O
MAX_PATH_LEN	int
]	O
;	O
static	O
bool	bool
stdin_was_read	bool
;	O
off_t	long
bytes_in	long
;	O
off_t	long
bytes_out	long
;	O
static	O
off_t	long
total_in	long
;	O
static	O
off_t	long
total_out	long
;	O
char	O
ifname	array
[	O
MAX_PATH_LEN	int
]	O
;	O
char	O
ofname	array
[	O
MAX_PATH_LEN	int
]	O
;	O
static	O
char	O
dfname	array
[	O
MAX_PATH_LEN	int
]	O
;	O
static	O
struct	O
stat	struct
istat	struct
;	O
int	O
ifd	int
;	O
int	O
ofd	int
;	O
static	O
int	O
dfd	int
=	O
-	O
1	int
;	O
unsigned	O
insize	int
;	O
unsigned	O
inptr	int
;	O
unsigned	O
outcnt	int
;	O
int	O
rsync	int
=	O
0	int
;	O
static	O
int	O
handled_sig	array
[	O
]	O
=	O
{	O
SIGINT	int
,	O
SIGHUP	int
,	O
SIGPIPE	int
,	O
SIGTERM	int
,	O
SIGXCPU	int
,	O
SIGXFSZ	int
}	O
;	O
enum	O
{	O
PRESUME_INPUT_TTY_OPTION	int
=	O
CHAR_MAX	O
+	O
1	int
,	O
RSYNCABLE_OPTION	int
,	O
SYNCHRONOUS_OPTION	int
,	O
ENV_OPTION	int
}	O
;	O
static	O
char	O
const	O
shortopts	array
[	O
]	O
=	O
"ab:cdfhH?klLmMnNqrS:tvVZ123456789"	pointer
;	O
static	O
const	O
struct	O
option	struct
longopts	array
[	O
]	O
=	O
{	O
{	O
"ascii"	pointer
,	O
0	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"to-stdout"	pointer
,	O
0	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"stdout"	pointer
,	O
0	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"decompress"	pointer
,	O
0	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"uncompress"	pointer
,	O
0	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"force"	pointer
,	O
0	int
,	O
0	int
,	O
'f'	O
}	O
,	O
{	O
"help"	pointer
,	O
0	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"keep"	pointer
,	O
0	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"list"	pointer
,	O
0	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"license"	pointer
,	O
0	int
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"no-name"	pointer
,	O
0	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
"name"	pointer
,	O
0	int
,	O
0	int
,	O
'N'	O
}	O
,	O
{	O
"-presume-input-tty"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
PRESUME_INPUT_TTY_OPTION	int
}	O
,	O
{	O
"quiet"	pointer
,	O
0	int
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"silent"	pointer
,	O
0	int
,	O
0	int
,	O
'q'	O
}	O
,	O
{	O
"synchronous"	pointer
,	O
0	int
,	O
0	int
,	O
SYNCHRONOUS_OPTION	int
}	O
,	O
{	O
"recursive"	pointer
,	O
0	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"suffix"	pointer
,	O
1	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"test"	pointer
,	O
0	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
0	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"version"	pointer
,	O
0	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
"fast"	pointer
,	O
0	int
,	O
0	int
,	O
'1'	O
}	O
,	O
{	O
"best"	pointer
,	O
0	int
,	O
0	int
,	O
'9'	O
}	O
,	O
{	O
"lzw"	pointer
,	O
0	int
,	O
0	int
,	O
'Z'	O
}	O
,	O
{	O
"bits"	pointer
,	O
1	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"rsyncable"	pointer
,	O
0	int
,	O
0	int
,	O
RSYNCABLE_OPTION	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
local	O
noreturn	O
void	O
try_help	function
(	O
void	O
)	O
;	O
local	O
void	O
help	function
(	O
void	O
)	O
;	O
local	O
void	O
license	function
(	O
void	O
)	O
;	O
local	O
void	O
version	function
(	O
void	O
)	O
;	O
local	O
int	O
input_eof	function
(	O
void	O
)	O
;	O
local	O
void	O
treat_stdin	function
(	O
void	O
)	O
;	O
local	O
void	O
treat_file	function
(	O
char	O
*	O
iname	pointer
)	O
;	O
local	O
int	O
create_outfile	function
(	O
void	O
)	O
;	O
local	O
char	O
*	O
get_suffix	function
(	O
char	O
*	O
name	pointer
)	O
;	O
local	O
int	O
open_input_file	function
(	O
char	O
*	O
iname	pointer
,	O
struct	O
stat	struct
*	O
sbuf	pointer
)	O
;	O
local	O
void	O
discard_input_bytes	function
(	O
size_t	long
nbytes	long
,	O
unsigned	O
int	O
flags	pointer
)	O
;	O
local	O
int	O
make_ofname	function
(	O
void	O
)	O
;	O
local	O
void	O
shorten_name	function
(	O
char	O
*	O
name	pointer
)	O
;	O
local	O
int	O
get_method	function
(	O
int	O
in	int
)	O
;	O
local	O
void	O
do_list	function
(	O
int	O
ifd	int
,	O
int	O
method	int
)	O
;	O
local	O
int	O
check_ofname	function
(	O
void	O
)	O
;	O
local	O
void	O
copy_stat	function
(	O
struct	O
stat	struct
*	O
ifstat	pointer
)	O
;	O
local	O
void	O
install_signal_handlers	function
(	O
void	O
)	O
;	O
static	O
void	O
remove_output_file	function
(	O
bool	bool
)	O
;	O
static	O
void	O
abort_gzip_signal	function
(	O
int	O
)	O
;	O
local	O
noreturn	O
void	O
do_exit	function
(	O
int	O
exitcode	int
)	O
;	O
static	O
void	O
finish_out	function
(	O
void	O
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
static	O
int	O
(	O
*	O
work	pointer
)	O
(	O
int	O
infile	int
,	O
int	O
outfile	int
)	O
=	O
zip	function
;	O
local	O
void	O
treat_dir	function
(	O
int	O
fd	int
,	O
char	O
*	O
dir	pointer
)	O
;	O
static	O
void	O
try_help	function
(	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Try `%s --help' for more information.\n"	pointer
,	O
program_name	pointer
)	O
;	O
do_exit	function
(	O
ERROR	int
)	O
;	O
}	O
local	O
void	O
help	function
(	O
)	O
{	O
static	O
char	O
const	O
*	O
const	O
help_msg	array
[	O
]	O
=	O
{	O
"Compress or uncompress FILEs (by default, compress FILES in-place)."	pointer
,	O
""	pointer
,	O
"Mandatory arguments to long options are mandatory for short options too."	pointer
,	O
""	pointer
,	O
"  -c, --stdout      write on standard output, keep original files unchanged"	pointer
,	O
"  -d, --decompress  decompress"	pointer
,	O
"  -f, --force       force overwrite of output file and compress links"	pointer
,	O
"  -h, --help        give this help"	pointer
,	O
"  -k, --keep        keep (don't delete) input files"	pointer
,	O
"  -l, --list        list compressed file contents"	pointer
,	O
"  -L, --license     display software license"	pointer
,	O
"  -n, --no-name     do not save or restore the original name and timestamp"	pointer
,	O
"  -N, --name        save or restore the original name and timestamp"	pointer
,	O
"  -q, --quiet       suppress all warnings"	pointer
,	O
"  -r, --recursive   operate recursively on directories"	pointer
,	O
"      --rsyncable   make rsync-friendly archive"	pointer
,	O
"  -S, --suffix=SUF  use suffix SUF on compressed files"	pointer
,	O
"      --synchronous synchronous output (safer if system crashes, but slower)"	pointer
,	O
"  -t, --test        test compressed file integrity"	pointer
,	O
"  -v, --verbose     verbose mode"	pointer
,	O
"  -V, --version     display version number"	pointer
,	O
"  -1, --fast        compress faster"	pointer
,	O
"  -9, --best        compress better"	pointer
,	O
""	pointer
,	O
"With no FILE, or when FILE is -, read standard input."	pointer
,	O
""	pointer
,	O
"Report bugs to <bug-gzip@gnu.org>."	pointer
,	O
0	int
}	O
;	O
char	O
const	O
*	O
const	O
*	O
p	pointer
=	O
help_msg	array
;	O
printf	function
(	O
"Usage: %s [OPTION]... [FILE]...\n"	pointer
,	O
program_name	pointer
)	O
;	O
while	O
(	O
*	O
p	pointer
)	O
printf	function
(	O
"%s\n"	pointer
,	O
*	O
p	pointer
++	O
)	O
;	O
}	O
local	O
void	O
license	function
(	O
)	O
{	O
char	O
const	O
*	O
const	O
*	O
p	pointer
=	O
license_msg	array
;	O
printf	function
(	O
"%s %s\n"	pointer
,	O
program_name	pointer
,	O
Version	pointer
)	O
;	O
while	O
(	O
*	O
p	pointer
)	O
printf	function
(	O
"%s\n"	pointer
,	O
*	O
p	pointer
++	O
)	O
;	O
}	O
local	O
void	O
version	function
(	O
)	O
{	O
license	function
(	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
"Written by Jean-loup Gailly.\n"	pointer
)	O
;	O
}	O
local	O
void	O
progerror	function
(	O
char	O
const	O
*	O
string	pointer
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
;	O
errno	O
=	O
e	int
;	O
perror	function
(	O
string	pointer
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
file_count	int
;	O
size_t	long
proglen	long
;	O
char	O
*	O
*	O
argv_copy	pointer
;	O
int	O
env_argc	int
;	O
char	O
*	O
*	O
env_argv	pointer
;	O
EXPAND	O
(	O
argc	int
,	O
argv	pointer
)	O
;	O
program_name	pointer
=	O
gzip_base_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
proglen	long
=	O
strlen	function
(	O
program_name	pointer
)	O
;	O
if	O
(	O
4	int
<	O
proglen	long
&&	O
strequ	O
(	O
program_name	pointer
+	O
proglen	long
-	O
4	int
,	O
".exe"	pointer
)	O
)	O
program_name	pointer
[	O
proglen	long
-	O
4	int
]	O
=	O
'\0'	O
;	O
argv_copy	pointer
=	O
argv	pointer
;	O
env	pointer
=	O
add_envopt	function
(	O
&	O
env_argc	int
,	O
&	O
argv_copy	pointer
,	O
OPTIONS_VAR	pointer
)	O
;	O
env_argv	pointer
=	O
env	pointer
?	O
argv_copy	pointer
:	O
NULL	O
;	O
z_suffix	pointer
=	O
Z_SUFFIX	pointer
;	O
z_len	long
=	O
strlen	function
(	O
z_suffix	pointer
)	O
;	O
while	O
(	O
true	int
)	O
{	O
int	O
optc	int
;	O
int	O
longind	int
=	O
-	O
1	int
;	O
if	O
(	O
env_argv	pointer
)	O
{	O
if	O
(	O
env_argv	pointer
[	O
optind	int
]	O
&&	O
strequ	O
(	O
env_argv	pointer
[	O
optind	int
]	O
,	O
"--"	pointer
)	O
)	O
optc	int
=	O
ENV_OPTION	int
+	O
'-'	O
;	O
else	O
{	O
optc	int
=	O
getopt_long	function
(	O
env_argc	int
,	O
env_argv	pointer
,	O
shortopts	array
,	O
longopts	array
,	O
&	O
longind	int
)	O
;	O
if	O
(	O
0	int
<=	O
optc	int
)	O
optc	int
+=	O
ENV_OPTION	int
;	O
else	O
{	O
if	O
(	O
optind	int
!=	O
env_argc	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
(	O
"%s: %s: non-option in "	pointer
OPTIONS_VAR	pointer
" environment variable\n"	pointer
)	O
,	O
program_name	pointer
,	O
env_argv	pointer
[	O
optind	int
]	O
)	O
;	O
try_help	function
(	O
)	O
;	O
}	O
if	O
(	O
env_argc	int
!=	O
1	int
&&	O
!	O
quiet	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
(	O
"%s: warning: "	pointer
OPTIONS_VAR	pointer
" environment variable"	pointer
" is deprecated; use an alias or script\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
free	function
(	O
env_argv	pointer
)	O
;	O
env_argv	pointer
=	O
NULL	O
;	O
optind	int
=	O
1	int
;	O
longind	int
=	O
-	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
env_argv	pointer
)	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
shortopts	array
,	O
longopts	array
,	O
&	O
longind	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'a'	O
:	O
ascii	int
=	O
1	int
;	O
break	O
;	O
case	O
'b'	O
:	O
maxbits	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
for	O
(	O
;	O
*	O
optarg	pointer
;	O
optarg	pointer
++	O
)	O
if	O
(	O
!	O
(	O
'0'	O
<=	O
*	O
optarg	pointer
&&	O
*	O
optarg	pointer
<=	O
'9'	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: -b operand is not an integer\n"	pointer
,	O
program_name	pointer
)	O
;	O
try_help	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
'c'	O
:	O
to_stdout	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
decompress	int
=	O
1	int
;	O
break	O
;	O
case	O
'f'	O
:	O
force	int
++	O
;	O
break	O
;	O
case	O
'h'	O
:	O
case	O
'H'	O
:	O
help	function
(	O
)	O
;	O
finish_out	function
(	O
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
keep	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
list	int
=	O
decompress	int
=	O
to_stdout	int
=	O
1	int
;	O
break	O
;	O
case	O
'L'	O
:	O
license	function
(	O
)	O
;	O
finish_out	function
(	O
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
no_time	int
=	O
1	int
;	O
break	O
;	O
case	O
'M'	O
:	O
no_time	int
=	O
0	int
;	O
break	O
;	O
case	O
'n'	O
:	O
case	O
'n'	O
+	O
ENV_OPTION	int
:	O
no_name	int
=	O
no_time	int
=	O
1	int
;	O
break	O
;	O
case	O
'N'	O
:	O
case	O
'N'	O
+	O
ENV_OPTION	int
:	O
no_name	int
=	O
no_time	int
=	O
0	int
;	O
break	O
;	O
case	O
PRESUME_INPUT_TTY_OPTION	int
:	O
presume_input_tty	bool
=	O
true	int
;	O
break	O
;	O
case	O
'q'	O
:	O
case	O
'q'	O
+	O
ENV_OPTION	int
:	O
quiet	int
=	O
1	int
;	O
verbose	int
=	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
recursive	int
=	O
1	int
;	O
break	O
;	O
case	O
RSYNCABLE_OPTION	int
:	O
case	O
RSYNCABLE_OPTION	int
+	O
ENV_OPTION	int
:	O
rsync	int
=	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
z_len	long
=	O
strlen	function
(	O
optarg	pointer
)	O
;	O
z_suffix	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
SYNCHRONOUS_OPTION	int
:	O
synchronous	bool
=	O
true	int
;	O
break	O
;	O
case	O
't'	O
:	O
test	int
=	O
decompress	int
=	O
to_stdout	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
case	O
'v'	O
+	O
ENV_OPTION	int
:	O
verbose	int
++	O
;	O
quiet	int
=	O
0	int
;	O
break	O
;	O
case	O
'V'	O
:	O
version	function
(	O
)	O
;	O
finish_out	function
(	O
)	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: -Z not supported in this version\n"	pointer
,	O
program_name	pointer
)	O
;	O
try_help	function
(	O
)	O
;	O
break	O
;	O
case	O
'1'	O
+	O
ENV_OPTION	int
:	O
case	O
'2'	O
+	O
ENV_OPTION	int
:	O
case	O
'3'	O
+	O
ENV_OPTION	int
:	O
case	O
'4'	O
+	O
ENV_OPTION	int
:	O
case	O
'5'	O
+	O
ENV_OPTION	int
:	O
case	O
'6'	O
+	O
ENV_OPTION	int
:	O
case	O
'7'	O
+	O
ENV_OPTION	int
:	O
case	O
'8'	O
+	O
ENV_OPTION	int
:	O
case	O
'9'	O
+	O
ENV_OPTION	int
:	O
optc	int
-=	O
ENV_OPTION	int
;	O
FALLTHROUGH	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
level	int
=	O
optc	int
-	O
'0'	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
ENV_OPTION	int
<=	O
optc	int
&&	O
optc	int
!=	O
ENV_OPTION	int
+	O
'?'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
;	O
if	O
(	O
longind	int
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"-%c: "	pointer
,	O
optc	int
-	O
ENV_OPTION	int
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"--%s: "	pointer
,	O
longopts	array
[	O
longind	int
]	O
.	O
name	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
(	O
"option not valid in "	pointer
OPTIONS_VAR	pointer
" environment variable\n"	pointer
)	O
)	O
;	O
}	O
try_help	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
no_time	int
<	O
0	int
)	O
no_time	int
=	O
decompress	int
;	O
if	O
(	O
no_name	int
<	O
0	int
)	O
no_name	int
=	O
decompress	int
;	O
file_count	int
=	O
argc	int
-	O
optind	int
;	O
if	O
(	O
ascii	int
&&	O
!	O
quiet	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: option --ascii ignored on this system\n"	pointer
,	O
program_name	pointer
)	O
;	O
}	O
if	O
(	O
z_len	long
==	O
0	int
||	O
z_len	long
>	O
MAX_SUFFIX	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: invalid suffix '%s'\n"	pointer
,	O
program_name	pointer
,	O
z_suffix	pointer
)	O
;	O
do_exit	function
(	O
ERROR	int
)	O
;	O
}	O
if	O
(	O
do_lzw	int
&&	O
!	O
decompress	int
)	O
work	pointer
=	O
lzw	function
;	O
ALLOC	O
(	O
uch	char
,	O
inbuf	array
,	O
INBUFSIZ	int
+	O
INBUF_EXTRA	int
)	O
;	O
ALLOC	O
(	O
uch	char
,	O
outbuf	array
,	O
OUTBUFSIZ	int
+	O
OUTBUF_EXTRA	int
)	O
;	O
ALLOC	O
(	O
ush	short
,	O
d_buf	array
,	O
DIST_BUFSIZE	int
)	O
;	O
ALLOC	O
(	O
uch	char
,	O
window	array
,	O
2L	int
*	O
WSIZE	int
)	O
;	O
ALLOC	O
(	O
ush	short
,	O
tab_prefix	O
,	O
1L	int
<<	O
BITS	int
)	O
;	O
exiting_signal	int
=	O
quiet	int
?	O
SIGPIPE	int
:	O
0	int
;	O
install_signal_handlers	function
(	O
)	O
;	O
if	O
(	O
file_count	int
!=	O
0	int
)	O
{	O
if	O
(	O
to_stdout	int
&&	O
!	O
test	int
&&	O
!	O
list	int
&&	O
(	O
!	O
decompress	int
||	O
!	O
ascii	int
)	O
)	O
{	O
SET_BINARY_MODE	O
(	O
STDOUT_FILENO	int
)	O
;	O
}	O
while	O
(	O
optind	int
<	O
argc	int
)	O
{	O
treat_file	function
(	O
argv	pointer
[	O
optind	int
++	O
]	O
)	O
;	O
}	O
}	O
else	O
{	O
treat_stdin	function
(	O
)	O
;	O
}	O
if	O
(	O
stdin_was_read	bool
&&	O
close	pointer
(	O
STDIN_FILENO	int
)	O
!=	O
0	int
)	O
{	O
strcpy	function
(	O
ifname	array
,	O
"stdin"	pointer
)	O
;	O
read_error	function
(	O
)	O
;	O
}	O
if	O
(	O
list	int
)	O
{	O
if	O
(	O
!	O
quiet	int
&&	O
1	int
<	O
file_count	int
)	O
do_list	function
(	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
if	O
(	O
fflush	function
(	O
stdout	pointer
)	O
!=	O
0	int
)	O
write_error	function
(	O
)	O
;	O
}	O
if	O
(	O
to_stdout	int
&&	O
(	O
(	O
synchronous	bool
&&	O
fdatasync	function
(	O
STDOUT_FILENO	int
)	O
!=	O
0	int
&&	O
errno	O
!=	O
EINVAL	int
)	O
||	O
close	pointer
(	O
STDOUT_FILENO	int
)	O
!=	O
0	int
)	O
&&	O
errno	O
!=	O
EBADF	int
)	O
write_error	function
(	O
)	O
;	O
do_exit	function
(	O
exit_code	int
)	O
;	O
}	O
local	O
int	O
input_eof	function
(	O
)	O
{	O
if	O
(	O
!	O
decompress	int
||	O
last_member	int
)	O
return	O
1	int
;	O
if	O
(	O
inptr	int
==	O
insize	int
)	O
{	O
if	O
(	O
insize	int
!=	O
INBUFSIZ	int
||	O
fill_inbuf	function
(	O
1	int
)	O
==	O
EOF	O
)	O
return	O
1	int
;	O
inptr	int
=	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
get_input_size_and_time	function
(	O
void	O
)	O
{	O
ifile_size	long
=	O
-	O
1	int
;	O
time_stamp	struct
.	O
tv_nsec	long
=	O
-	O
1	int
;	O
if	O
(	O
S_ISREG	O
(	O
istat	struct
.	O
st_mode	int
)	O
)	O
{	O
ifile_size	long
=	O
istat	struct
.	O
st_size	long
;	O
if	O
(	O
!	O
no_time	int
||	O
list	int
)	O
time_stamp	struct
=	O
get_stat_mtime	function
(	O
&	O
istat	struct
)	O
;	O
}	O
}	O
local	O
void	O
treat_stdin	function
(	O
)	O
{	O
if	O
(	O
!	O
force	int
&&	O
!	O
list	int
&&	O
(	O
presume_input_tty	bool
||	O
isatty	function
(	O
decompress	int
?	O
STDIN_FILENO	int
:	O
STDOUT_FILENO	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
quiet	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
(	O
"%s: compressed data not %s a terminal."	pointer
" Use -f to force %scompression.\n"	pointer
"For help, type: %s -h\n"	pointer
)	O
,	O
program_name	pointer
,	O
decompress	int
?	O
"read from"	pointer
:	O
"written to"	pointer
,	O
decompress	int
?	O
"de"	pointer
:	O
""	pointer
,	O
program_name	pointer
)	O
;	O
do_exit	function
(	O
ERROR	int
)	O
;	O
}	O
if	O
(	O
decompress	int
||	O
!	O
ascii	int
)	O
{	O
SET_BINARY_MODE	O
(	O
STDIN_FILENO	int
)	O
;	O
}	O
if	O
(	O
!	O
test	int
&&	O
!	O
list	int
&&	O
(	O
!	O
decompress	int
||	O
!	O
ascii	int
)	O
)	O
{	O
SET_BINARY_MODE	O
(	O
STDOUT_FILENO	int
)	O
;	O
}	O
strcpy	function
(	O
ifname	array
,	O
"stdin"	pointer
)	O
;	O
strcpy	function
(	O
ofname	array
,	O
"stdout"	pointer
)	O
;	O
if	O
(	O
fstat	function
(	O
STDIN_FILENO	int
,	O
&	O
istat	struct
)	O
!=	O
0	int
)	O
{	O
progerror	function
(	O
"standard input"	pointer
)	O
;	O
do_exit	function
(	O
ERROR	int
)	O
;	O
}	O
get_input_size_and_time	function
(	O
)	O
;	O
clear_bufs	function
(	O
)	O
;	O
to_stdout	int
=	O
1	int
;	O
part_nb	int
=	O
0	int
;	O
ifd	int
=	O
STDIN_FILENO	int
;	O
stdin_was_read	bool
=	O
true	int
;	O
if	O
(	O
decompress	int
)	O
{	O
method	int
=	O
get_method	function
(	O
ifd	int
)	O
;	O
if	O
(	O
method	int
<	O
0	int
)	O
{	O
do_exit	function
(	O
exit_code	int
)	O
;	O
}	O
}	O
if	O
(	O
list	int
)	O
{	O
do_list	function
(	O
ifd	int
,	O
method	int
)	O
;	O
return	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
work	pointer
(	O
STDIN_FILENO	int
,	O
STDOUT_FILENO	int
)	O
!=	O
OK	int
)	O
return	O
;	O
if	O
(	O
input_eof	function
(	O
)	O
)	O
break	O
;	O
method	int
=	O
get_method	function
(	O
ifd	int
)	O
;	O
if	O
(	O
method	int
<	O
0	int
)	O
return	O
;	O
bytes_out	long
=	O
0	int
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
if	O
(	O
test	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
" OK\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
decompress	int
)	O
{	O
display_ratio	function
(	O
bytes_in	long
-	O
(	O
bytes_out	long
-	O
header_bytes	long
)	O
,	O
bytes_in	long
,	O
stderr	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
char	O
const	O
dot	char
=	O
'.'	O
;	O
static	O
bool	bool
atdir_eq	function
(	O
char	O
const	O
*	O
dir	pointer
,	O
ptrdiff_t	long
dirlen	long
)	O
{	O
if	O
(	O
dirlen	long
==	O
0	int
)	O
dir	pointer
=	O
&	O
dot	char
,	O
dirlen	long
=	O
1	int
;	O
return	O
memcmp	function
(	O
dfname	array
,	O
dir	pointer
,	O
dirlen	long
)	O
==	O
0	int
&&	O
!	O
dfname	array
[	O
dirlen	long
]	O
;	O
}	O
static	O
int	O
atdir_set	function
(	O
char	O
const	O
*	O
dir	pointer
,	O
ptrdiff_t	long
dirlen	long
)	O
{	O
enum	O
{	O
try_opening_directories	int
=	O
true	int
}	O
;	O
if	O
(	O
try_opening_directories	int
&&	O
!	O
atdir_eq	function
(	O
dir	pointer
,	O
dirlen	long
)	O
)	O
{	O
if	O
(	O
0	int
<=	O
dfd	int
)	O
close	pointer
(	O
dfd	int
)	O
;	O
if	O
(	O
dirlen	long
==	O
0	int
)	O
dir	pointer
=	O
&	O
dot	char
,	O
dirlen	long
=	O
1	int
;	O
memcpy	function
(	O
dfname	array
,	O
dir	pointer
,	O
dirlen	long
)	O
;	O
dfname	array
[	O
dirlen	long
]	O
=	O
'\0'	O
;	O
dfd	int
=	O
open	function
(	O
dfname	array
,	O
O_SEARCH	O
|	O
O_DIRECTORY	O
)	O
;	O
}	O
return	O
dfd	int
;	O
}	O
local	O
void	O
treat_file	function
(	O
iname	pointer
)	O
char	O
*	O
iname	pointer
;	O
{	O
if	O
(	O
strequ	O
(	O
iname	pointer
,	O
"-"	pointer
)	O
)	O
{	O
int	O
cflag	int
=	O
to_stdout	int
;	O
treat_stdin	function
(	O
)	O
;	O
to_stdout	int
=	O
cflag	int
;	O
return	O
;	O
}	O
ifd	int
=	O
open_input_file	function
(	O
iname	pointer
,	O
&	O
istat	struct
)	O
;	O
if	O
(	O
ifd	int
<	O
0	int
)	O
return	O
;	O
if	O
(	O
S_ISDIR	O
(	O
istat	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
recursive	int
)	O
{	O
treat_dir	function
(	O
ifd	int
,	O
iname	pointer
)	O
;	O
return	O
;	O
}	O
close	pointer
(	O
ifd	int
)	O
;	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: %s is a directory -- ignored\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
)	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
to_stdout	int
)	O
{	O
if	O
(	O
!	O
S_ISREG	O
(	O
istat	struct
.	O
st_mode	int
)	O
)	O
{	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: %s is not a directory or a regular file - ignored\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
)	O
)	O
;	O
close	pointer
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
istat	struct
.	O
st_mode	int
&	O
S_ISUID	O
)	O
{	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: %s is set-user-ID on execution - ignored\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
)	O
)	O
;	O
close	pointer
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
istat	struct
.	O
st_mode	int
&	O
S_ISGID	O
)	O
{	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: %s is set-group-ID on execution - ignored\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
)	O
)	O
;	O
close	pointer
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
force	int
)	O
{	O
if	O
(	O
istat	struct
.	O
st_mode	int
&	O
S_ISVTX	O
)	O
{	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: %s has the sticky bit set - file ignored\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
)	O
)	O
;	O
close	pointer
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
2	int
<=	O
istat	struct
.	O
st_nlink	long
)	O
{	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: %s has %lu other link%c -- unchanged\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
,	O
(	O
unsigned	O
long	O
int	O
)	O
istat	struct
.	O
st_nlink	long
-	O
1	int
,	O
istat	struct
.	O
st_nlink	long
==	O
2	int
?	O
' '	O
:	O
's'	O
)	O
)	O
;	O
close	pointer
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
}	O
}	O
get_input_size_and_time	function
(	O
)	O
;	O
if	O
(	O
to_stdout	int
&&	O
!	O
list	int
&&	O
!	O
test	int
)	O
{	O
strcpy	function
(	O
ofname	array
,	O
"stdout"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
make_ofname	function
(	O
)	O
!=	O
OK	int
)	O
{	O
close	pointer
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
clear_bufs	function
(	O
)	O
;	O
part_nb	int
=	O
0	int
;	O
if	O
(	O
decompress	int
)	O
{	O
method	int
=	O
get_method	function
(	O
ifd	int
)	O
;	O
if	O
(	O
method	int
<	O
0	int
)	O
{	O
close	pointer
(	O
ifd	int
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
list	int
)	O
{	O
do_list	function
(	O
ifd	int
,	O
method	int
)	O
;	O
if	O
(	O
close	pointer
(	O
ifd	int
)	O
!=	O
0	int
)	O
read_error	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
to_stdout	int
)	O
{	O
ofd	int
=	O
STDOUT_FILENO	int
;	O
}	O
else	O
{	O
if	O
(	O
create_outfile	function
(	O
)	O
!=	O
OK	int
)	O
return	O
;	O
if	O
(	O
!	O
decompress	int
&&	O
save_orig_name	int
&&	O
!	O
verbose	int
&&	O
!	O
quiet	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s compressed to %s\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
,	O
ofname	array
)	O
;	O
}	O
}	O
if	O
(	O
!	O
save_orig_name	int
)	O
save_orig_name	int
=	O
!	O
no_name	int
;	O
if	O
(	O
verbose	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:\t"	pointer
,	O
ifname	array
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
(	O
*	O
work	pointer
)	O
(	O
ifd	int
,	O
ofd	int
)	O
!=	O
OK	int
)	O
{	O
method	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
input_eof	function
(	O
)	O
)	O
break	O
;	O
method	int
=	O
get_method	function
(	O
ifd	int
)	O
;	O
if	O
(	O
method	int
<	O
0	int
)	O
break	O
;	O
bytes_out	long
=	O
0	int
;	O
}	O
if	O
(	O
close	pointer
(	O
ifd	int
)	O
!=	O
0	int
)	O
read_error	function
(	O
)	O
;	O
if	O
(	O
!	O
to_stdout	int
)	O
{	O
copy_stat	function
(	O
&	O
istat	struct
)	O
;	O
if	O
(	O
(	O
synchronous	bool
&&	O
(	O
(	O
0	int
<=	O
dfd	int
&&	O
fdatasync	function
(	O
dfd	int
)	O
!=	O
0	int
&&	O
errno	O
!=	O
EINVAL	int
)	O
||	O
(	O
fsync	function
(	O
ofd	int
)	O
!=	O
0	int
&&	O
errno	O
!=	O
EINVAL	int
)	O
)	O
)	O
||	O
close	pointer
(	O
ofd	int
)	O
!=	O
0	int
)	O
write_error	function
(	O
)	O
;	O
if	O
(	O
!	O
keep	int
)	O
{	O
sigset_t	struct
oldset	struct
;	O
int	O
unlink_errno	int
;	O
char	O
*	O
ifbase	pointer
=	O
last_component	function
(	O
ifname	array
)	O
;	O
int	O
ufd	int
=	O
atdir_eq	function
(	O
ifname	array
,	O
ifbase	pointer
-	O
ifname	array
)	O
?	O
dfd	int
:	O
-	O
1	int
;	O
int	O
res	int
;	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
caught_signals	struct
,	O
&	O
oldset	struct
)	O
;	O
remove_ofname_fd	int
=	O
-	O
1	int
;	O
res	int
=	O
ufd	int
<	O
0	int
?	O
xunlink	function
(	O
ifname	array
)	O
:	O
unlinkat	function
(	O
ufd	int
,	O
ifbase	pointer
,	O
0	int
)	O
;	O
unlink_errno	int
=	O
res	int
==	O
0	int
?	O
0	int
:	O
errno	O
;	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
&	O
oldset	struct
,	O
NULL	O
)	O
;	O
if	O
(	O
unlink_errno	int
)	O
{	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
errno	O
=	O
unlink_errno	int
;	O
perror	function
(	O
ifname	array
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
method	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
to_stdout	int
)	O
remove_output_file	function
(	O
false	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
if	O
(	O
test	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
" OK"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
decompress	int
)	O
{	O
display_ratio	function
(	O
bytes_out	long
-	O
(	O
bytes_in	long
-	O
header_bytes	long
)	O
,	O
bytes_out	long
,	O
stderr	pointer
)	O
;	O
}	O
else	O
{	O
display_ratio	function
(	O
bytes_in	long
-	O
(	O
bytes_out	long
-	O
header_bytes	long
)	O
,	O
bytes_in	long
,	O
stderr	pointer
)	O
;	O
}	O
if	O
(	O
!	O
test	int
&&	O
!	O
to_stdout	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
" -- %s %s"	pointer
,	O
keep	int
?	O
"created"	pointer
:	O
"replaced with"	pointer
,	O
ofname	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
volatile_strcpy	function
(	O
char	O
volatile	O
*	O
dst	pointer
,	O
char	O
const	O
volatile	O
*	O
src	pointer
)	O
{	O
while	O
(	O
(	O
*	O
dst	pointer
++	O
=	O
*	O
src	pointer
++	O
)	O
)	O
continue	O
;	O
}	O
local	O
int	O
create_outfile	function
(	O
)	O
{	O
int	O
name_shortened	int
=	O
0	int
;	O
int	O
flags	pointer
=	O
(	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_EXCL	int
|	O
(	O
ascii	int
&&	O
decompress	int
?	O
0	int
:	O
O_BINARY	int
)	O
)	O
;	O
char	O
const	O
*	O
base	pointer
=	O
ofname	array
;	O
int	O
atfd	int
=	O
AT_FDCWD	O
;	O
if	O
(	O
!	O
keep	int
)	O
{	O
char	O
const	O
*	O
b	struct
=	O
last_component	function
(	O
ofname	array
)	O
;	O
int	O
f	int
=	O
atdir_set	function
(	O
ofname	array
,	O
b	struct
-	O
ofname	array
)	O
;	O
if	O
(	O
0	int
<=	O
f	int
)	O
{	O
base	pointer
=	O
b	struct
;	O
atfd	int
=	O
f	int
;	O
}	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
open_errno	int
;	O
sigset_t	struct
oldset	struct
;	O
volatile_strcpy	function
(	O
remove_ofname	array
,	O
ofname	array
)	O
;	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
caught_signals	struct
,	O
&	O
oldset	struct
)	O
;	O
remove_ofname_fd	int
=	O
ofd	int
=	O
openat	function
(	O
atfd	int
,	O
base	pointer
,	O
flags	pointer
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
open_errno	int
=	O
errno	O
;	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
&	O
oldset	struct
,	O
NULL	O
)	O
;	O
if	O
(	O
0	int
<=	O
ofd	int
)	O
break	O
;	O
switch	O
(	O
open_errno	int
)	O
{	O
case	O
ENAMETOOLONG	int
:	O
shorten_name	function
(	O
ofname	array
)	O
;	O
name_shortened	int
=	O
1	int
;	O
break	O
;	O
case	O
EEXIST	int
:	O
if	O
(	O
check_ofname	function
(	O
)	O
!=	O
OK	int
)	O
{	O
close	pointer
(	O
ifd	int
)	O
;	O
return	O
ERROR	int
;	O
}	O
break	O
;	O
default	O
:	O
progerror	function
(	O
ofname	array
)	O
;	O
close	pointer
(	O
ifd	int
)	O
;	O
return	O
ERROR	int
;	O
}	O
}	O
if	O
(	O
name_shortened	int
&&	O
decompress	int
)	O
{	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: %s: warning, name truncated\n"	pointer
,	O
program_name	pointer
,	O
ofname	array
)	O
)	O
;	O
}	O
return	O
OK	int
;	O
}	O
local	O
char	O
*	O
get_suffix	function
(	O
name	pointer
)	O
char	O
*	O
name	pointer
;	O
{	O
int	O
nlen	int
,	O
slen	int
;	O
char	O
suffix	array
[	O
MAX_SUFFIX	int
+	O
3	int
]	O
;	O
static	O
char	O
const	O
*	O
known_suffixes	array
[	O
]	O
=	O
{	O
NULL	O
,	O
".gz"	pointer
,	O
".z"	pointer
,	O
".taz"	pointer
,	O
".tgz"	pointer
,	O
"-gz"	pointer
,	O
"-z"	pointer
,	O
"_z"	pointer
,	O
NULL	O
,	O
NULL	O
}	O
;	O
char	O
const	O
*	O
*	O
suf	pointer
;	O
bool	bool
suffix_of_builtin	bool
=	O
false	int
;	O
for	O
(	O
suf	pointer
=	O
known_suffixes	array
+	O
1	int
;	O
*	O
suf	pointer
;	O
suf	pointer
++	O
)	O
{	O
size_t	long
suflen	long
=	O
strlen	function
(	O
*	O
suf	pointer
)	O
;	O
if	O
(	O
z_len	long
<	O
suflen	long
&&	O
strequ	O
(	O
z_suffix	pointer
,	O
*	O
suf	pointer
+	O
suflen	long
-	O
z_len	long
)	O
)	O
{	O
suffix_of_builtin	bool
=	O
true	int
;	O
break	O
;	O
}	O
}	O
char	O
*	O
z_lower	pointer
=	O
xstrdup	function
(	O
z_suffix	pointer
)	O
;	O
strlwr	function
(	O
z_lower	pointer
)	O
;	O
known_suffixes	array
[	O
suffix_of_builtin	bool
?	O
sizeof	O
known_suffixes	array
/	O
sizeof	O
*	O
known_suffixes	array
-	O
2	int
:	O
0	int
]	O
=	O
z_lower	pointer
;	O
suf	pointer
=	O
known_suffixes	array
+	O
suffix_of_builtin	bool
;	O
nlen	int
=	O
strlen	function
(	O
name	pointer
)	O
;	O
if	O
(	O
nlen	int
<=	O
MAX_SUFFIX	int
+	O
2	int
)	O
{	O
strcpy	function
(	O
suffix	array
,	O
name	pointer
)	O
;	O
}	O
else	O
{	O
strcpy	function
(	O
suffix	array
,	O
name	pointer
+	O
nlen	int
-	O
MAX_SUFFIX	int
-	O
2	int
)	O
;	O
}	O
strlwr	function
(	O
suffix	array
)	O
;	O
slen	int
=	O
strlen	function
(	O
suffix	array
)	O
;	O
char	O
*	O
match	pointer
=	O
NULL	O
;	O
do	O
{	O
int	O
s	pointer
=	O
strlen	function
(	O
*	O
suf	pointer
)	O
;	O
if	O
(	O
slen	int
>	O
s	pointer
&&	O
!	O
ISSLASH	O
(	O
suffix	array
[	O
slen	int
-	O
s	pointer
-	O
1	int
]	O
)	O
&&	O
strequ	O
(	O
suffix	array
+	O
slen	int
-	O
s	pointer
,	O
*	O
suf	pointer
)	O
)	O
{	O
match	pointer
=	O
name	pointer
+	O
nlen	int
-	O
s	pointer
;	O
break	O
;	O
}	O
}	O
while	O
(	O
*	O
++	O
suf	pointer
!=	O
NULL	O
)	O
;	O
free	function
(	O
z_lower	pointer
)	O
;	O
return	O
match	pointer
;	O
}	O
static	O
int	O
open_and_stat	function
(	O
char	O
*	O
name	pointer
,	O
int	O
flags	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
int	O
fd	int
;	O
int	O
atfd	int
=	O
AT_FDCWD	O
;	O
char	O
const	O
*	O
base	pointer
=	O
name	pointer
;	O
if	O
(	O
!	O
to_stdout	int
&&	O
!	O
force	int
)	O
{	O
if	O
(	O
HAVE_WORKING_O_NOFOLLOW	int
)	O
flags	pointer
|=	O
O_NOFOLLOW	O
;	O
else	O
{	O
if	O
(	O
lstat	function
(	O
name	pointer
,	O
st	pointer
)	O
!=	O
0	int
)	O
return	O
-	O
1	int
;	O
else	O
if	O
(	O
S_ISLNK	O
(	O
st	pointer
->	O
st_mode	int
)	O
)	O
{	O
errno	O
=	O
ELOOP	int
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
keep	int
)	O
{	O
char	O
const	O
*	O
b	struct
=	O
last_component	function
(	O
name	pointer
)	O
;	O
int	O
f	int
=	O
atdir_set	function
(	O
name	pointer
,	O
b	struct
-	O
name	pointer
)	O
;	O
if	O
(	O
0	int
<=	O
f	int
)	O
{	O
base	pointer
=	O
b	struct
;	O
atfd	int
=	O
f	int
;	O
}	O
}	O
fd	int
=	O
openat	function
(	O
atfd	int
,	O
base	pointer
,	O
flags	pointer
)	O
;	O
if	O
(	O
0	int
<=	O
fd	int
&&	O
fstat	function
(	O
fd	int
,	O
st	pointer
)	O
!=	O
0	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
errno	O
=	O
e	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
fd	int
;	O
}	O
static	O
int	O
open_input_file	function
(	O
iname	pointer
,	O
sbuf	pointer
)	O
char	O
*	O
iname	pointer
;	O
struct	O
stat	struct
*	O
sbuf	pointer
;	O
{	O
int	O
ilen	int
;	O
int	O
z_suffix_errno	int
=	O
0	int
;	O
static	O
char	O
const	O
*	O
suffixes	array
[	O
]	O
=	O
{	O
NULL	O
,	O
".gz"	pointer
,	O
".z"	pointer
,	O
"-z"	pointer
,	O
".Z"	pointer
,	O
NULL	O
}	O
;	O
char	O
const	O
*	O
*	O
suf	pointer
=	O
suffixes	array
;	O
char	O
const	O
*	O
s	pointer
;	O
int	O
fd	int
;	O
int	O
open_flags	int
=	O
(	O
O_RDONLY	int
|	O
O_NONBLOCK	int
|	O
O_NOCTTY	int
|	O
(	O
ascii	int
&&	O
!	O
decompress	int
?	O
0	int
:	O
O_BINARY	int
)	O
)	O
;	O
*	O
suf	pointer
=	O
z_suffix	pointer
;	O
if	O
(	O
sizeof	O
ifname	array
-	O
1	int
<=	O
strlen	function
(	O
iname	pointer
)	O
)	O
goto	O
name_too_long	O
;	O
strcpy	function
(	O
ifname	array
,	O
iname	pointer
)	O
;	O
fd	int
=	O
open_and_stat	function
(	O
ifname	array
,	O
open_flags	int
,	O
sbuf	pointer
)	O
;	O
if	O
(	O
0	int
<=	O
fd	int
)	O
return	O
fd	int
;	O
if	O
(	O
!	O
decompress	int
||	O
errno	O
!=	O
ENOENT	int
)	O
{	O
progerror	function
(	O
ifname	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
s	pointer
=	O
get_suffix	function
(	O
ifname	array
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
progerror	function
(	O
ifname	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
ilen	int
=	O
strlen	function
(	O
ifname	array
)	O
;	O
if	O
(	O
strequ	O
(	O
z_suffix	pointer
,	O
".gz"	pointer
)	O
)	O
suf	pointer
++	O
;	O
do	O
{	O
char	O
const	O
*	O
s0	pointer
=	O
s	pointer
=	O
*	O
suf	pointer
;	O
strcpy	function
(	O
ifname	array
,	O
iname	pointer
)	O
;	O
if	O
(	O
sizeof	O
ifname	array
<=	O
ilen	int
+	O
strlen	function
(	O
s	pointer
)	O
)	O
goto	O
name_too_long	O
;	O
strcat	function
(	O
ifname	array
,	O
s	pointer
)	O
;	O
fd	int
=	O
open_and_stat	function
(	O
ifname	array
,	O
open_flags	int
,	O
sbuf	pointer
)	O
;	O
if	O
(	O
0	int
<=	O
fd	int
)	O
return	O
fd	int
;	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
{	O
progerror	function
(	O
ifname	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
strequ	O
(	O
s0	pointer
,	O
z_suffix	pointer
)	O
)	O
z_suffix_errno	int
=	O
errno	O
;	O
}	O
while	O
(	O
*	O
++	O
suf	pointer
!=	O
NULL	O
)	O
;	O
strcpy	function
(	O
ifname	array
,	O
iname	pointer
)	O
;	O
strcat	function
(	O
ifname	array
,	O
z_suffix	pointer
)	O
;	O
errno	O
=	O
z_suffix_errno	int
;	O
progerror	function
(	O
ifname	array
)	O
;	O
return	O
-	O
1	int
;	O
name_too_long	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s: file name too long\n"	pointer
,	O
program_name	pointer
,	O
iname	pointer
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
return	O
-	O
1	int
;	O
}	O
local	O
int	O
make_ofname	function
(	O
)	O
{	O
char	O
*	O
suff	pointer
;	O
strcpy	function
(	O
ofname	array
,	O
ifname	array
)	O
;	O
suff	pointer
=	O
get_suffix	function
(	O
ofname	array
)	O
;	O
if	O
(	O
decompress	int
)	O
{	O
if	O
(	O
suff	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
recursive	int
&&	O
(	O
list	int
||	O
test	int
)	O
)	O
return	O
OK	int
;	O
if	O
(	O
verbose	int
||	O
(	O
!	O
recursive	int
&&	O
!	O
quiet	int
)	O
)	O
{	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: %s: unknown suffix -- ignored\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
)	O
)	O
;	O
}	O
return	O
WARNING	int
;	O
}	O
strlwr	function
(	O
suff	pointer
)	O
;	O
if	O
(	O
strequ	O
(	O
suff	pointer
,	O
".tgz"	pointer
)	O
||	O
strequ	O
(	O
suff	pointer
,	O
".taz"	pointer
)	O
)	O
{	O
strcpy	function
(	O
suff	pointer
,	O
".tar"	pointer
)	O
;	O
}	O
else	O
{	O
*	O
suff	pointer
=	O
'\0'	O
;	O
}	O
}	O
else	O
if	O
(	O
suff	pointer
&&	O
!	O
force	int
)	O
{	O
if	O
(	O
verbose	int
||	O
(	O
!	O
recursive	int
&&	O
!	O
quiet	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s already has %s suffix -- unchanged\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
,	O
suff	pointer
)	O
;	O
}	O
return	O
WARNING	int
;	O
}	O
else	O
{	O
save_orig_name	int
=	O
0	int
;	O
if	O
(	O
sizeof	O
ofname	array
<=	O
strlen	function
(	O
ofname	array
)	O
+	O
z_len	long
)	O
goto	O
name_too_long	O
;	O
strcat	function
(	O
ofname	array
,	O
z_suffix	pointer
)	O
;	O
}	O
return	O
OK	int
;	O
name_too_long	O
:	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: %s: file name too long\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
)	O
)	O
;	O
return	O
WARNING	int
;	O
}	O
static	O
void	O
discard_input_bytes	function
(	O
nbytes	long
,	O
flags	pointer
)	O
size_t	long
nbytes	long
;	O
unsigned	O
int	O
flags	pointer
;	O
{	O
while	O
(	O
nbytes	long
!=	O
0	int
)	O
{	O
uch	char
c	char
=	O
get_byte	O
(	O
)	O
;	O
if	O
(	O
flags	pointer
&	O
HEADER_CRC	int
)	O
updcrc	function
(	O
&	O
c	char
,	O
1	int
)	O
;	O
if	O
(	O
nbytes	long
!=	O
(	O
size_t	long
)	O
-	O
1	int
)	O
nbytes	long
--	O
;	O
else	O
if	O
(	O
!	O
c	char
)	O
break	O
;	O
}	O
}	O
local	O
int	O
get_method	function
(	O
in	int
)	O
int	O
in	int
;	O
{	O
uch	char
flags	pointer
;	O
uch	char
magic	array
[	O
10	int
]	O
;	O
int	O
imagic0	int
;	O
int	O
imagic1	int
;	O
ulg	long
stamp	long
;	O
if	O
(	O
force	int
&&	O
to_stdout	int
)	O
{	O
imagic0	int
=	O
try_byte	O
(	O
)	O
;	O
magic	array
[	O
0	int
]	O
=	O
imagic0	int
;	O
imagic1	int
=	O
try_byte	O
(	O
)	O
;	O
magic	array
[	O
1	int
]	O
=	O
imagic1	int
;	O
}	O
else	O
{	O
magic	array
[	O
0	int
]	O
=	O
get_byte	O
(	O
)	O
;	O
imagic0	int
=	O
0	int
;	O
if	O
(	O
magic	array
[	O
0	int
]	O
)	O
{	O
magic	array
[	O
1	int
]	O
=	O
get_byte	O
(	O
)	O
;	O
imagic1	int
=	O
0	int
;	O
}	O
else	O
{	O
imagic1	int
=	O
try_byte	O
(	O
)	O
;	O
magic	array
[	O
1	int
]	O
=	O
imagic1	int
;	O
}	O
}	O
method	int
=	O
-	O
1	int
;	O
part_nb	int
++	O
;	O
header_bytes	long
=	O
0	int
;	O
last_member	int
=	O
0	int
;	O
if	O
(	O
memcmp	function
(	O
magic	array
,	O
GZIP_MAGIC	pointer
,	O
2	int
)	O
==	O
0	int
||	O
memcmp	function
(	O
magic	array
,	O
OLD_GZIP_MAGIC	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
method	int
=	O
(	O
int	O
)	O
get_byte	O
(	O
)	O
;	O
if	O
(	O
method	int
!=	O
DEFLATED	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s: unknown method %d -- not supported\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
,	O
method	int
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
return	O
-	O
1	int
;	O
}	O
work	pointer
=	O
unzip	function
;	O
flags	pointer
=	O
(	O
uch	char
)	O
get_byte	O
(	O
)	O
;	O
if	O
(	O
(	O
flags	pointer
&	O
ENCRYPTED	int
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s is encrypted -- not supported\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
flags	pointer
&	O
RESERVED	int
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s has flags 0x%x -- not supported\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
,	O
flags	pointer
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
if	O
(	O
force	int
<=	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
stamp	long
=	O
(	O
ulg	long
)	O
get_byte	O
(	O
)	O
;	O
stamp	long
|=	O
(	O
(	O
ulg	long
)	O
get_byte	O
(	O
)	O
)	O
<<	O
8	int
;	O
stamp	long
|=	O
(	O
(	O
ulg	long
)	O
get_byte	O
(	O
)	O
)	O
<<	O
16	int
;	O
stamp	long
|=	O
(	O
(	O
ulg	long
)	O
get_byte	O
(	O
)	O
)	O
<<	O
24	int
;	O
if	O
(	O
stamp	long
!=	O
0	int
&&	O
!	O
no_time	int
)	O
{	O
if	O
(	O
stamp	long
<=	O
TYPE_MAXIMUM	O
(	O
time_t	long
)	O
)	O
{	O
time_stamp	struct
.	O
tv_sec	long
=	O
stamp	long
;	O
time_stamp	struct
.	O
tv_nsec	long
=	O
0	int
;	O
}	O
else	O
{	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: %s: MTIME %lu out of range for this platform\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
,	O
stamp	long
)	O
)	O
;	O
time_stamp	struct
.	O
tv_sec	long
=	O
TYPE_MAXIMUM	O
(	O
time_t	long
)	O
;	O
time_stamp	struct
.	O
tv_nsec	long
=	O
TIMESPEC_RESOLUTION	int
-	O
1	int
;	O
}	O
}	O
magic	array
[	O
8	int
]	O
=	O
get_byte	O
(	O
)	O
;	O
magic	array
[	O
9	int
]	O
=	O
get_byte	O
(	O
)	O
;	O
if	O
(	O
flags	pointer
&	O
HEADER_CRC	int
)	O
{	O
magic	array
[	O
2	int
]	O
=	O
DEFLATED	int
;	O
magic	array
[	O
3	int
]	O
=	O
flags	pointer
;	O
magic	array
[	O
4	int
]	O
=	O
stamp	long
&	O
0xff	int
;	O
magic	array
[	O
5	int
]	O
=	O
(	O
stamp	long
>>	O
8	int
)	O
&	O
0xff	int
;	O
magic	array
[	O
6	int
]	O
=	O
(	O
stamp	long
>>	O
16	int
)	O
&	O
0xff	int
;	O
magic	array
[	O
7	int
]	O
=	O
stamp	long
>>	O
24	int
;	O
updcrc	function
(	O
NULL	O
,	O
0	int
)	O
;	O
updcrc	function
(	O
magic	array
,	O
10	int
)	O
;	O
}	O
if	O
(	O
(	O
flags	pointer
&	O
EXTRA_FIELD	int
)	O
!=	O
0	int
)	O
{	O
uch	char
lenbuf	array
[	O
2	int
]	O
;	O
unsigned	O
int	O
len	int
=	O
lenbuf	array
[	O
0	int
]	O
=	O
get_byte	O
(	O
)	O
;	O
len	int
|=	O
(	O
lenbuf	array
[	O
1	int
]	O
=	O
get_byte	O
(	O
)	O
)	O
<<	O
8	int
;	O
if	O
(	O
verbose	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s: extra field of %u bytes ignored\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
,	O
len	int
)	O
;	O
}	O
if	O
(	O
flags	pointer
&	O
HEADER_CRC	int
)	O
updcrc	function
(	O
lenbuf	array
,	O
2	int
)	O
;	O
discard_input_bytes	function
(	O
len	int
,	O
flags	pointer
)	O
;	O
}	O
if	O
(	O
(	O
flags	pointer
&	O
ORIG_NAME	int
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
no_name	int
||	O
(	O
to_stdout	int
&&	O
!	O
list	int
)	O
||	O
part_nb	int
>	O
1	int
)	O
{	O
discard_input_bytes	function
(	O
-	O
1	int
,	O
flags	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
=	O
gzip_base_name	function
(	O
ofname	array
)	O
;	O
char	O
*	O
base	pointer
=	O
p	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
*	O
p	pointer
=	O
(	O
char	O
)	O
get_byte	O
(	O
)	O
;	O
if	O
(	O
*	O
p	pointer
++	O
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
p	pointer
>=	O
ofname	array
+	O
sizeof	O
(	O
ofname	array
)	O
)	O
{	O
gzip_error	function
(	O
"corrupted input -- file name too large"	pointer
)	O
;	O
}	O
}	O
if	O
(	O
flags	pointer
&	O
HEADER_CRC	int
)	O
updcrc	function
(	O
(	O
uch	char
*	O
)	O
base	pointer
,	O
p	pointer
-	O
base	pointer
)	O
;	O
p	pointer
=	O
gzip_base_name	function
(	O
base	pointer
)	O
;	O
memmove	function
(	O
base	pointer
,	O
p	pointer
,	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
list	int
)	O
{	O
MAKE_LEGAL_NAME	O
(	O
base	pointer
)	O
;	O
if	O
(	O
base	pointer
)	O
list	int
=	O
0	int
;	O
}	O
}	O
}	O
if	O
(	O
(	O
flags	pointer
&	O
COMMENT	int
)	O
!=	O
0	int
)	O
{	O
discard_input_bytes	function
(	O
-	O
1	int
,	O
flags	pointer
)	O
;	O
}	O
if	O
(	O
flags	pointer
&	O
HEADER_CRC	int
)	O
{	O
unsigned	O
int	O
crc16	int
=	O
updcrc	function
(	O
magic	array
,	O
0	int
)	O
&	O
0xffff	int
;	O
unsigned	O
int	O
header16	int
=	O
get_byte	O
(	O
)	O
;	O
header16	int
|=	O
(	O
(	O
unsigned	O
int	O
)	O
get_byte	O
(	O
)	O
)	O
<<	O
8	int
;	O
if	O
(	O
header16	int
!=	O
crc16	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s: header checksum 0x%04x != computed checksum 0x%04x\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
,	O
header16	int
,	O
crc16	int
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
if	O
(	O
force	int
<=	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
part_nb	int
==	O
1	int
)	O
{	O
header_bytes	long
=	O
inptr	int
+	O
2	int
*	O
4	int
;	O
}	O
}	O
else	O
if	O
(	O
memcmp	function
(	O
magic	array
,	O
PKZIP_MAGIC	pointer
,	O
2	int
)	O
==	O
0	int
&&	O
inptr	int
==	O
2	int
&&	O
memcmp	function
(	O
(	O
char	O
*	O
)	O
inbuf	array
,	O
PKZIP_MAGIC	pointer
,	O
4	int
)	O
==	O
0	int
)	O
{	O
inptr	int
=	O
0	int
;	O
work	pointer
=	O
unzip	function
;	O
if	O
(	O
check_zipfile	function
(	O
in	int
)	O
!=	O
OK	int
)	O
return	O
-	O
1	int
;	O
last_member	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
memcmp	function
(	O
magic	array
,	O
PACK_MAGIC	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
work	pointer
=	O
unpack	function
;	O
method	int
=	O
PACKED	int
;	O
}	O
else	O
if	O
(	O
memcmp	function
(	O
magic	array
,	O
LZW_MAGIC	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
work	pointer
=	O
unlzw	function
;	O
method	int
=	O
COMPRESSED	int
;	O
last_member	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
memcmp	function
(	O
magic	array
,	O
LZH_MAGIC	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
work	pointer
=	O
unlzh	function
;	O
method	int
=	O
LZHED	int
;	O
last_member	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
force	int
&&	O
to_stdout	int
&&	O
!	O
list	int
)	O
{	O
method	int
=	O
STORED	int
;	O
work	pointer
=	O
copy	function
;	O
if	O
(	O
imagic1	int
!=	O
EOF	O
)	O
inptr	int
--	O
;	O
last_member	int
=	O
1	int
;	O
if	O
(	O
imagic0	int
!=	O
EOF	O
)	O
{	O
write_buf	function
(	O
STDOUT_FILENO	int
,	O
magic	array
,	O
1	int
)	O
;	O
bytes_out	long
++	O
;	O
}	O
}	O
if	O
(	O
method	int
>=	O
0	int
)	O
return	O
method	int
;	O
if	O
(	O
part_nb	int
==	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\n%s: %s: not in gzip format\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
magic	array
[	O
0	int
]	O
==	O
0	int
)	O
{	O
int	O
inbyte	int
;	O
for	O
(	O
inbyte	int
=	O
imagic1	int
;	O
inbyte	int
==	O
0	int
;	O
inbyte	int
=	O
try_byte	O
(	O
)	O
)	O
continue	O
;	O
if	O
(	O
inbyte	int
==	O
EOF	O
)	O
{	O
if	O
(	O
verbose	int
)	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"\n%s: %s: decompression OK, trailing zero bytes ignored\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
)	O
)	O
;	O
return	O
-	O
3	int
;	O
}	O
}	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"\n%s: %s: decompression OK, trailing garbage ignored\n"	pointer
,	O
program_name	pointer
,	O
ifname	array
)	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
}	O
local	O
void	O
do_list	function
(	O
ifd	int
,	O
method	int
)	O
int	O
ifd	int
;	O
int	O
method	int
;	O
{	O
ulg	long
crc	long
;	O
static	O
int	O
first_time	int
=	O
1	int
;	O
static	O
char	O
const	O
*	O
const	O
methods	array
[	O
MAX_METHODS	int
]	O
=	O
{	O
"store"	pointer
,	O
"compr"	pointer
,	O
"pack "	pointer
,	O
"lzh  "	pointer
,	O
""	pointer
,	O
""	pointer
,	O
""	pointer
,	O
""	pointer
,	O
"defla"	pointer
}	O
;	O
int	O
positive_off_t_width	int
=	O
INT_STRLEN_BOUND	O
(	O
off_t	long
)	O
-	O
1	int
;	O
if	O
(	O
first_time	int
&&	O
method	int
>=	O
0	int
)	O
{	O
first_time	int
=	O
0	int
;	O
if	O
(	O
verbose	int
)	O
{	O
printf	function
(	O
"method  crc     date  time  "	pointer
)	O
;	O
}	O
if	O
(	O
!	O
quiet	int
)	O
{	O
printf	function
(	O
"%*.*s %*.*s  ratio uncompressed_name\n"	pointer
,	O
positive_off_t_width	int
,	O
positive_off_t_width	int
,	O
"compressed"	pointer
,	O
positive_off_t_width	int
,	O
positive_off_t_width	int
,	O
"uncompressed"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
method	int
<	O
0	int
)	O
{	O
if	O
(	O
total_in	long
<=	O
0	int
||	O
total_out	long
<=	O
0	int
)	O
return	O
;	O
if	O
(	O
verbose	int
)	O
{	O
printf	function
(	O
"                            "	pointer
)	O
;	O
}	O
if	O
(	O
verbose	int
||	O
!	O
quiet	int
)	O
{	O
fprint_off	function
(	O
stdout	pointer
,	O
total_in	long
,	O
positive_off_t_width	int
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
fprint_off	function
(	O
stdout	pointer
,	O
total_out	long
,	O
positive_off_t_width	int
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
}	O
display_ratio	function
(	O
total_out	long
-	O
(	O
total_in	long
-	O
header_bytes	long
)	O
,	O
total_out	long
,	O
stdout	pointer
)	O
;	O
printf	function
(	O
" (totals)\n"	pointer
)	O
;	O
return	O
;	O
}	O
crc	long
=	O
(	O
ulg	long
)	O
~	O
0	int
;	O
bytes_out	long
=	O
-	O
1L	int
;	O
bytes_in	long
=	O
ifile_size	long
;	O
if	O
(	O
method	int
==	O
DEFLATED	int
&&	O
!	O
last_member	int
)	O
{	O
bytes_in	long
=	O
lseek	function
(	O
ifd	int
,	O
(	O
off_t	long
)	O
(	O
-	O
8	int
)	O
,	O
SEEK_END	int
)	O
;	O
if	O
(	O
bytes_in	long
!=	O
-	O
1L	int
)	O
{	O
uch	char
buf	pointer
[	O
8	int
]	O
;	O
bytes_in	long
+=	O
8L	int
;	O
if	O
(	O
read	pointer
(	O
ifd	int
,	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
!=	O
sizeof	O
(	O
buf	pointer
)	O
)	O
{	O
read_error	function
(	O
)	O
;	O
}	O
crc	long
=	O
LG	O
(	O
buf	pointer
)	O
;	O
bytes_out	long
=	O
LG	O
(	O
buf	pointer
+	O
4	int
)	O
;	O
}	O
}	O
if	O
(	O
verbose	int
)	O
{	O
static	O
char	O
const	O
month_abbr	array
[	O
]	O
[	O
4	int
]	O
=	O
{	O
"Jan"	pointer
,	O
"Feb"	pointer
,	O
"Mar"	pointer
,	O
"Apr"	pointer
,	O
"May"	pointer
,	O
"Jun"	pointer
,	O
"Jul"	pointer
,	O
"Aug"	pointer
,	O
"Sep"	pointer
,	O
"Oct"	pointer
,	O
"Nov"	pointer
,	O
"Dec"	pointer
}	O
;	O
struct	O
tm	struct
*	O
tm	struct
=	O
localtime	function
(	O
&	O
time_stamp	struct
.	O
tv_sec	long
)	O
;	O
printf	function
(	O
"%5s %08lx "	pointer
,	O
methods	array
[	O
method	int
]	O
,	O
crc	long
)	O
;	O
if	O
(	O
tm	struct
)	O
printf	function
(	O
"%s%3d %02d:%02d "	pointer
,	O
month_abbr	array
[	O
tm	struct
->	O
tm_mon	int
]	O
,	O
tm	struct
->	O
tm_mday	int
,	O
tm	struct
->	O
tm_hour	int
,	O
tm	struct
->	O
tm_min	int
)	O
;	O
else	O
printf	function
(	O
"??? ?? ??:?? "	pointer
)	O
;	O
}	O
fprint_off	function
(	O
stdout	pointer
,	O
bytes_in	long
,	O
positive_off_t_width	int
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
fprint_off	function
(	O
stdout	pointer
,	O
bytes_out	long
,	O
positive_off_t_width	int
)	O
;	O
printf	function
(	O
" "	pointer
)	O
;	O
if	O
(	O
bytes_in	long
==	O
-	O
1L	int
)	O
{	O
total_in	long
=	O
-	O
1L	int
;	O
bytes_in	long
=	O
bytes_out	long
=	O
header_bytes	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
total_in	long
>=	O
0	int
)	O
{	O
total_in	long
+=	O
bytes_in	long
;	O
}	O
if	O
(	O
bytes_out	long
==	O
-	O
1L	int
)	O
{	O
total_out	long
=	O
-	O
1L	int
;	O
bytes_in	long
=	O
bytes_out	long
=	O
header_bytes	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
total_out	long
>=	O
0	int
)	O
{	O
total_out	long
+=	O
bytes_out	long
;	O
}	O
display_ratio	function
(	O
bytes_out	long
-	O
(	O
bytes_in	long
-	O
header_bytes	long
)	O
,	O
bytes_out	long
,	O
stdout	pointer
)	O
;	O
printf	function
(	O
" %s\n"	pointer
,	O
ofname	array
)	O
;	O
}	O
local	O
void	O
shorten_name	function
(	O
name	pointer
)	O
char	O
*	O
name	pointer
;	O
{	O
int	O
len	int
;	O
char	O
*	O
trunc	pointer
=	O
NULL	O
;	O
int	O
plen	int
;	O
int	O
min_part	int
=	O
MIN_PART	int
;	O
char	O
*	O
p	pointer
;	O
len	int
=	O
strlen	function
(	O
name	pointer
)	O
;	O
if	O
(	O
decompress	int
)	O
{	O
if	O
(	O
len	int
<=	O
1	int
)	O
gzip_error	function
(	O
"name too short"	pointer
)	O
;	O
name	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
;	O
}	O
p	pointer
=	O
get_suffix	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
gzip_error	function
(	O
"can't recover suffix\n"	pointer
)	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
save_orig_name	int
=	O
1	int
;	O
if	O
(	O
len	int
>	O
4	int
&&	O
strequ	O
(	O
p	pointer
-	O
4	int
,	O
".tar"	pointer
)	O
)	O
{	O
strcpy	function
(	O
p	pointer
-	O
4	int
,	O
".tgz"	pointer
)	O
;	O
return	O
;	O
}	O
do	O
{	O
p	pointer
=	O
last_component	function
(	O
name	pointer
)	O
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
plen	int
=	O
strcspn	function
(	O
p	pointer
,	O
PART_SEP	pointer
)	O
;	O
p	pointer
+=	O
plen	int
;	O
if	O
(	O
plen	int
>	O
min_part	int
)	O
trunc	pointer
=	O
p	pointer
-	O
1	int
;	O
if	O
(	O
*	O
p	pointer
)	O
p	pointer
++	O
;	O
}	O
}	O
while	O
(	O
trunc	pointer
==	O
NULL	O
&&	O
--	O
min_part	int
!=	O
0	int
)	O
;	O
if	O
(	O
trunc	pointer
!=	O
NULL	O
)	O
{	O
do	O
{	O
trunc	pointer
[	O
0	int
]	O
=	O
trunc	pointer
[	O
1	int
]	O
;	O
}	O
while	O
(	O
*	O
trunc	pointer
++	O
)	O
;	O
trunc	pointer
--	O
;	O
}	O
else	O
{	O
trunc	pointer
=	O
strrchr	function
(	O
name	pointer
,	O
PART_SEP	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
trunc	pointer
)	O
gzip_error	function
(	O
"internal error in shorten_name"	pointer
)	O
;	O
if	O
(	O
trunc	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
trunc	pointer
--	O
;	O
}	O
strcpy	function
(	O
trunc	pointer
,	O
z_suffix	pointer
)	O
;	O
}	O
local	O
int	O
check_ofname	function
(	O
)	O
{	O
if	O
(	O
!	O
force	int
)	O
{	O
int	O
ok	int
=	O
0	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s already exists;"	pointer
,	O
program_name	pointer
,	O
ofname	array
)	O
;	O
if	O
(	O
foreground	int
&&	O
(	O
presume_input_tty	bool
||	O
isatty	function
(	O
STDIN_FILENO	int
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
" do you wish to overwrite (y or n)? "	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
ok	int
=	O
yesno	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
ok	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"\tnot overwritten\n"	pointer
)	O
;	O
if	O
(	O
exit_code	int
==	O
OK	int
)	O
exit_code	int
=	O
WARNING	int
;	O
return	O
ERROR	int
;	O
}	O
}	O
if	O
(	O
xunlink	function
(	O
ofname	array
)	O
)	O
{	O
progerror	function
(	O
ofname	array
)	O
;	O
return	O
ERROR	int
;	O
}	O
return	O
OK	int
;	O
}	O
static	O
void	O
do_chown	function
(	O
int	O
fd	int
,	O
char	O
const	O
*	O
name	pointer
,	O
uid_t	int
uid	int
,	O
gid_t	int
gid	int
)	O
{	O
ignore_value	O
(	O
fchown	function
(	O
fd	int
,	O
uid	int
,	O
gid	int
)	O
)	O
;	O
}	O
local	O
void	O
copy_stat	function
(	O
ifstat	pointer
)	O
struct	O
stat	struct
*	O
ifstat	pointer
;	O
{	O
mode_t	int
mode	int
=	O
ifstat	pointer
->	O
st_mode	int
&	O
S_IRWXUGO	O
;	O
int	O
r	struct
;	O
bool	bool
restoring	bool
;	O
struct	O
timespec	struct
timespec	struct
[	O
2	int
]	O
;	O
timespec	struct
[	O
0	int
]	O
=	O
get_stat_atime	function
(	O
ifstat	pointer
)	O
;	O
timespec	struct
[	O
1	int
]	O
=	O
get_stat_mtime	function
(	O
ifstat	pointer
)	O
;	O
restoring	bool
=	O
(	O
decompress	int
&&	O
0	int
<=	O
time_stamp	struct
.	O
tv_nsec	long
&&	O
!	O
(	O
timespec	struct
[	O
1	int
]	O
.	O
tv_sec	long
==	O
time_stamp	struct
.	O
tv_sec	long
&&	O
timespec	struct
[	O
1	int
]	O
.	O
tv_nsec	long
==	O
time_stamp	struct
.	O
tv_nsec	long
)	O
)	O
;	O
if	O
(	O
restoring	bool
)	O
timespec	struct
[	O
1	int
]	O
=	O
time_stamp	struct
;	O
if	O
(	O
fdutimens	function
(	O
ofd	int
,	O
ofname	array
,	O
timespec	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
restoring	bool
&&	O
1	int
<	O
verbose	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: timestamp restored\n"	pointer
,	O
ofname	array
)	O
;	O
}	O
}	O
else	O
{	O
int	O
e	int
=	O
errno	O
;	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
errno	O
=	O
e	int
;	O
perror	function
(	O
ofname	array
)	O
;	O
}	O
}	O
do_chown	function
(	O
ofd	int
,	O
ofname	array
,	O
-	O
1	int
,	O
ifstat	pointer
->	O
st_gid	int
)	O
;	O
r	struct
=	O
fchmod	function
(	O
ofd	int
,	O
mode	int
)	O
;	O
if	O
(	O
r	struct
!=	O
0	int
)	O
{	O
int	O
e	int
=	O
errno	O
;	O
WARN	O
(	O
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
errno	O
=	O
e	int
;	O
perror	function
(	O
ofname	array
)	O
;	O
}	O
}	O
do_chown	function
(	O
ofd	int
,	O
ofname	array
,	O
ifstat	pointer
->	O
st_uid	int
,	O
-	O
1	int
)	O
;	O
}	O
local	O
void	O
treat_dir	function
(	O
fd	int
,	O
dir	pointer
)	O
int	O
fd	int
;	O
char	O
*	O
dir	pointer
;	O
{	O
DIR	struct
*	O
dirp	pointer
;	O
char	O
nbuf	array
[	O
MAX_PATH_LEN	int
]	O
;	O
char	O
*	O
entries	pointer
;	O
char	O
const	O
*	O
entry	pointer
;	O
size_t	long
entrylen	long
;	O
dirp	pointer
=	O
fdopendir	function
(	O
fd	int
)	O
;	O
if	O
(	O
dirp	pointer
==	O
NULL	O
)	O
{	O
progerror	function
(	O
dir	pointer
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
;	O
}	O
entries	pointer
=	O
streamsavedir	function
(	O
dirp	pointer
,	O
SAVEDIR_SORT_NONE	int
)	O
;	O
if	O
(	O
!	O
entries	pointer
)	O
progerror	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
closedir	function
(	O
dirp	pointer
)	O
!=	O
0	int
)	O
progerror	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
!	O
entries	pointer
)	O
return	O
;	O
for	O
(	O
entry	pointer
=	O
entries	pointer
;	O
*	O
entry	pointer
;	O
entry	pointer
+=	O
entrylen	long
+	O
1	int
)	O
{	O
size_t	long
len	int
=	O
strlen	function
(	O
dir	pointer
)	O
;	O
entrylen	long
=	O
strlen	function
(	O
entry	pointer
)	O
;	O
if	O
(	O
strequ	O
(	O
entry	pointer
,	O
"."	pointer
)	O
||	O
strequ	O
(	O
entry	pointer
,	O
".."	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
len	int
+	O
entrylen	long
<	O
MAX_PATH_LEN	int
-	O
2	int
)	O
{	O
strcpy	function
(	O
nbuf	array
,	O
dir	pointer
)	O
;	O
if	O
(	O
*	O
last_component	function
(	O
nbuf	array
)	O
&&	O
!	O
ISSLASH	O
(	O
nbuf	array
[	O
len	int
-	O
1	int
]	O
)	O
)	O
nbuf	array
[	O
len	int
++	O
]	O
=	O
'/'	O
;	O
strcpy	function
(	O
nbuf	array
+	O
len	int
,	O
entry	pointer
)	O
;	O
treat_file	function
(	O
nbuf	array
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s/%s: pathname too long\n"	pointer
,	O
program_name	pointer
,	O
dir	pointer
,	O
entry	pointer
)	O
;	O
exit_code	int
=	O
ERROR	int
;	O
}	O
}	O
free	function
(	O
entries	pointer
)	O
;	O
}	O
static	O
void	O
install_signal_handlers	function
(	O
)	O
{	O
int	O
nsigs	int
=	O
sizeof	O
handled_sig	array
/	O
sizeof	O
handled_sig	array
[	O
0	int
]	O
;	O
int	O
i	int
;	O
struct	O
sigaction	struct
act	struct
;	O
sigemptyset	function
(	O
&	O
caught_signals	struct
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nsigs	int
;	O
i	int
++	O
)	O
{	O
sigaction	struct
(	O
handled_sig	array
[	O
i	int
]	O
,	O
NULL	O
,	O
&	O
act	struct
)	O
;	O
if	O
(	O
act	struct
.	O
sa_handler	pointer
!=	O
SIG_IGN	O
)	O
sigaddset	function
(	O
&	O
caught_signals	struct
,	O
handled_sig	array
[	O
i	int
]	O
)	O
;	O
}	O
act	struct
.	O
sa_handler	pointer
=	O
abort_gzip_signal	function
;	O
act	struct
.	O
sa_mask	struct
=	O
caught_signals	struct
;	O
act	struct
.	O
sa_flags	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nsigs	int
;	O
i	int
++	O
)	O
if	O
(	O
sigismember	function
(	O
&	O
caught_signals	struct
,	O
handled_sig	array
[	O
i	int
]	O
)	O
)	O
{	O
if	O
(	O
i	int
==	O
0	int
)	O
foreground	int
=	O
1	int
;	O
sigaction	struct
(	O
handled_sig	array
[	O
i	int
]	O
,	O
&	O
act	struct
,	O
NULL	O
)	O
;	O
}	O
}	O
local	O
void	O
do_exit	function
(	O
exitcode	int
)	O
int	O
exitcode	int
;	O
{	O
static	O
int	O
in_exit	int
=	O
0	int
;	O
if	O
(	O
in_exit	int
)	O
exit	function
(	O
exitcode	int
)	O
;	O
in_exit	int
=	O
1	int
;	O
free	function
(	O
env	pointer
)	O
;	O
env	pointer
=	O
NULL	O
;	O
FREE	O
(	O
inbuf	array
)	O
;	O
FREE	O
(	O
outbuf	array
)	O
;	O
FREE	O
(	O
d_buf	array
)	O
;	O
FREE	O
(	O
window	array
)	O
;	O
FREE	O
(	O
tab_prefix	O
)	O
;	O
exit	function
(	O
exitcode	int
)	O
;	O
}	O
static	O
void	O
finish_out	function
(	O
void	O
)	O
{	O
if	O
(	O
fclose	function
(	O
stdout	pointer
)	O
!=	O
0	int
)	O
write_error	function
(	O
)	O
;	O
do_exit	function
(	O
OK	int
)	O
;	O
}	O
static	O
void	O
remove_output_file	function
(	O
bool	bool
signals_already_blocked	bool
)	O
{	O
int	O
fd	int
;	O
sigset_t	struct
oldset	struct
;	O
if	O
(	O
!	O
signals_already_blocked	bool
)	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
caught_signals	struct
,	O
&	O
oldset	struct
)	O
;	O
fd	int
=	O
remove_ofname_fd	int
;	O
if	O
(	O
0	int
<=	O
fd	int
)	O
{	O
char	O
fname	pointer
[	O
MAX_PATH_LEN	int
]	O
;	O
remove_ofname_fd	int
=	O
-	O
1	int
;	O
close	pointer
(	O
fd	int
)	O
;	O
volatile_strcpy	function
(	O
fname	pointer
,	O
remove_ofname	array
)	O
;	O
xunlink	function
(	O
fname	pointer
)	O
;	O
}	O
if	O
(	O
!	O
signals_already_blocked	bool
)	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
&	O
oldset	struct
,	O
NULL	O
)	O
;	O
}	O
void	O
abort_gzip	function
(	O
void	O
)	O
{	O
remove_output_file	function
(	O
false	int
)	O
;	O
do_exit	function
(	O
ERROR	int
)	O
;	O
}	O
static	O
void	O
abort_gzip_signal	function
(	O
int	O
sig	int
)	O
{	O
remove_output_file	function
(	O
true	int
)	O
;	O
if	O
(	O
sig	int
==	O
exiting_signal	int
)	O
_exit	function
(	O
WARNING	int
)	O
;	O
signal	function
(	O
sig	int
,	O
SIG_DFL	O
)	O
;	O
raise	function
(	O
sig	int
)	O
;	O
}	O
