struct	O
sockaddr_in	struct
data_dest	struct
;	O
struct	O
sockaddr_in	struct
his_addr	struct
;	O
int	O
logging	int
;	O
int	O
type	enum
=	O
TYPE_A	int
;	O
int	O
form	int
=	O
FORM_N	int
;	O
int	O
debug	int
;	O
int	O
timeout	int
=	O
900	int
;	O
int	O
maxtimeout	int
=	O
7200	int
;	O
int	O
pdata	int
=	O
-	O
1	int
;	O
char	O
*	O
hostname	pointer
;	O
int	O
usedefault	int
=	O
1	int
;	O
char	O
tmpline	array
[	O
7	int
]	O
;	O
struct	O
credentials	struct
cred	struct
;	O
static	O
struct	O
sockaddr_in	struct
ctrl_addr	struct
;	O
static	O
struct	O
sockaddr_in	struct
data_source	struct
;	O
static	O
struct	O
sockaddr_in	struct
pasv_addr	struct
;	O
static	O
int	O
data	array
=	O
-	O
1	int
;	O
static	O
jmp_buf	array
urgcatch	array
;	O
static	O
int	O
stru	int
=	O
STRU_F	int
;	O
static	O
int	O
stru_mode	int
=	O
MODE_S	int
;	O
static	O
int	O
anon_only	int
;	O
static	O
int	O
no_version	int
;	O
static	O
int	O
daemon_mode	int
;	O
static	O
off_t	long
file_size	long
;	O
static	O
off_t	long
byte_count	long
;	O
static	O
sig_atomic_t	int
transflag	int
;	O
static	O
const	O
char	O
*	O
pid_file	pointer
=	O
PATH_FTPDPID	O
;	O
static	O
int	O
defumask	int
=	O
CMASK	int
;	O
static	O
int	O
login_attempts	int
;	O
static	O
int	O
askpasswd	int
;	O
static	O
char	O
curname	array
[	O
10	int
]	O
;	O
static	O
char	O
ttyline	array
[	O
20	int
]	O
;	O
static	O
char	O
*	O
off_to_str	function
(	O
off_t	long
off	long
)	O
{	O
static	O
char	O
bufs	array
[	O
NUM_SIMUL_OFF_TO_STRS	int
]	O
[	O
80	int
]	O
;	O
static	O
char	O
(	O
*	O
next_buf	pointer
)	O
[	O
80	int
]	O
=	O
bufs	array
;	O
if	O
(	O
next_buf	pointer
>=	O
(	O
bufs	array
+	O
NUM_SIMUL_OFF_TO_STRS	int
)	O
)	O
next_buf	pointer
=	O
bufs	array
;	O
if	O
(	O
sizeof	O
(	O
off	long
)	O
>	O
sizeof	O
(	O
long	O
)	O
)	O
sprintf	function
(	O
*	O
next_buf	pointer
,	O
"%lld"	pointer
,	O
(	O
long	O
long	O
int	O
)	O
off	long
)	O
;	O
else	O
if	O
(	O
sizeof	O
(	O
off	long
)	O
==	O
sizeof	O
(	O
long	O
)	O
)	O
sprintf	function
(	O
*	O
next_buf	pointer
,	O
"%ld"	pointer
,	O
off	long
)	O
;	O
else	O
sprintf	function
(	O
*	O
next_buf	pointer
,	O
"%d"	pointer
,	O
(	O
int	O
)	O
off	long
)	O
;	O
return	O
*	O
next_buf	pointer
++	O
;	O
}	O
static	O
int	O
swaitmax	int
=	O
SWAITMAX	int
;	O
static	O
int	O
swaitint	int
=	O
SWAITINT	int
;	O
extern	O
int	O
yyparse	function
(	O
void	O
)	O
;	O
static	O
void	O
ack	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
complete_login	function
(	O
struct	O
credentials	struct
*	O
)	O
;	O
static	O
char	O
*	O
curdir	function
(	O
void	O
)	O
;	O
static	O
FILE	struct
*	O
dataconn	function
(	O
const	O
char	O
*	O
,	O
off_t	long
,	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
dolog	function
(	O
struct	O
sockaddr_in	struct
*	O
,	O
struct	O
credentials	struct
*	O
)	O
;	O
static	O
void	O
end_login	function
(	O
struct	O
credentials	struct
*	O
)	O
;	O
static	O
FILE	struct
*	O
getdatasock	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
char	O
*	O
gunique	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
lostconn	function
(	O
int	O
)	O
;	O
static	O
void	O
myoob	function
(	O
int	O
)	O
;	O
static	O
int	O
receive_data	function
(	O
FILE	struct
*	O
,	O
FILE	struct
*	O
)	O
;	O
static	O
void	O
send_data	function
(	O
FILE	struct
*	O
,	O
FILE	struct
*	O
,	O
off_t	long
)	O
;	O
static	O
void	O
sigquit	function
(	O
int	O
)	O
;	O
const	O
char	O
doc	pointer
[	O
]	O
=	O
"File Transfer Protocol Daemon"	pointer
;	O
static	O
struct	O
argp_option	struct
options	pointer
[	O
]	O
=	O
{	O
{	O
"anonymous-only"	pointer
,	O
'A'	O
,	O
NULL	O
,	O
0	int
,	O
"server configured for anonymous service only"	pointer
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"daemon"	pointer
,	O
'D'	O
,	O
NULL	O
,	O
0	int
,	O
"start the ftpd standalone"	pointer
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"debug"	pointer
,	O
'd'	O
,	O
NULL	O
,	O
0	int
,	O
"debug mode"	pointer
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"logging"	pointer
,	O
'l'	O
,	O
NULL	O
,	O
0	int
,	O
"increase verbosity of syslog messages"	pointer
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"pidfile"	pointer
,	O
'p'	O
,	O
"PIDFILE"	pointer
,	O
OPTION_ARG_OPTIONAL	int
,	O
"change default location of pidfile"	pointer
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"no-version"	pointer
,	O
'q'	O
,	O
NULL	O
,	O
0	int
,	O
"do not display version in banner"	pointer
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"timeout"	pointer
,	O
't'	O
,	O
"TIMEOUT"	pointer
,	O
0	int
,	O
"set default idle timeout"	pointer
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"max-timeout"	pointer
,	O
'T'	O
,	O
NULL	O
,	O
0	int
,	O
"reset maximum value of timeout allowed"	pointer
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"umask"	pointer
,	O
'u'	O
,	O
"VAL"	pointer
,	O
0	int
,	O
"set default umask"	pointer
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
"auth"	pointer
,	O
'a'	O
,	O
"AUTH"	pointer
,	O
OPTION_ARG_OPTIONAL	int
,	O
"use AUTH for authentication"	pointer
,	O
GRID	int
+	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
"AUTH can be one of the following:"	pointer
,	O
GRID	int
+	O
2	int
}	O
,	O
{	O
"  default"	pointer
,	O
0	int
,	O
NULL	O
,	O
OPTION_DOC	int
|	O
OPTION_NO_TRANS	int
,	O
"passwd authentication"	pointer
,	O
GRID	int
+	O
3	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'A'	O
:	O
anon_only	int
=	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
if	O
(	O
strcasecmp	function
(	O
arg	pointer
,	O
"default"	pointer
)	O
==	O
0	int
)	O
cred	struct
.	O
auth_type	int
=	O
AUTH_TYPE_PASSWD	int
;	O
break	O
;	O
case	O
'D'	O
:	O
daemon_mode	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
debug	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
logging	int
++	O
;	O
break	O
;	O
case	O
'p'	O
:	O
pid_file	pointer
=	O
arg	pointer
;	O
break	O
;	O
case	O
'q'	O
:	O
no_version	int
=	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
timeout	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
maxtimeout	int
<	O
timeout	int
)	O
maxtimeout	int
=	O
timeout	int
;	O
break	O
;	O
case	O
'T'	O
:	O
maxtimeout	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
timeout	int
>	O
maxtimeout	int
)	O
timeout	int
=	O
maxtimeout	int
;	O
break	O
;	O
case	O
'u'	O
:	O
{	O
long	O
val	array
=	O
0	int
;	O
val	array
=	O
strtol	function
(	O
arg	pointer
,	O
&	O
arg	pointer
,	O
8	int
)	O
;	O
if	O
(	O
*	O
arg	pointer
!=	O
'\0'	O
||	O
val	array
<	O
0	int
)	O
argp_error	function
(	O
state	pointer
,	O
"bad value for -u"	pointer
)	O
;	O
else	O
defumask	int
=	O
val	array
;	O
break	O
;	O
}	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
options	pointer
,	O
parse_opt	function
,	O
NULL	O
,	O
doc	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
,	O
char	O
*	O
*	O
envp	pointer
)	O
{	O
int	O
index	function
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
tzset	function
(	O
)	O
;	O
iu_argp_init	O
(	O
"ftpd"	pointer
,	O
default_program_authors	array
)	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
&	O
index	function
,	O
NULL	O
)	O
;	O
if	O
(	O
argc	int
-	O
index	function
!=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"surplus arguments; try `%s --help' for more info"	pointer
,	O
program_name	pointer
)	O
;	O
openlog	function
(	O
"ftpd"	pointer
,	O
LOG_PID	int
|	O
LOG_NDELAY	int
,	O
LOG_FTP	O
)	O
;	O
freopen	function
(	O
PATH_DEVNULL	O
,	O
"w"	pointer
,	O
stderr	pointer
)	O
;	O
if	O
(	O
daemon_mode	int
)	O
{	O
if	O
(	O
server_mode	function
(	O
pid_file	pointer
,	O
&	O
his_addr	struct
,	O
argv	pointer
)	O
<	O
0	int
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
socklen_t	int
addrlen	int
=	O
sizeof	O
(	O
his_addr	struct
)	O
;	O
if	O
(	O
getpeername	function
(	O
STDIN_FILENO	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
his_addr	struct
,	O
&	O
addrlen	int
)	O
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"getpeername (%s): %m"	pointer
,	O
program_name	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
signal	function
(	O
SIGHUP	int
,	O
sigquit	function
)	O
;	O
signal	function
(	O
SIGINT	int
,	O
sigquit	function
)	O
;	O
signal	function
(	O
SIGQUIT	int
,	O
sigquit	function
)	O
;	O
signal	function
(	O
SIGTERM	int
,	O
sigquit	function
)	O
;	O
signal	function
(	O
SIGPIPE	int
,	O
lostconn	function
)	O
;	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_IGN	O
)	O
;	O
if	O
(	O
signal	function
(	O
SIGURG	int
,	O
myoob	function
)	O
==	O
SIG_ERR	O
)	O
syslog	function
(	O
LOG_ERR	int
,	O
"signal: %m"	pointer
)	O
;	O
{	O
socklen_t	int
addrlen	int
=	O
sizeof	O
(	O
ctrl_addr	struct
)	O
;	O
if	O
(	O
getsockname	function
(	O
STDIN_FILENO	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
ctrl_addr	struct
,	O
&	O
addrlen	int
)	O
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"getsockname (%s): %m"	pointer
,	O
program_name	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
{	O
int	O
tos	char
=	O
IPTOS_LOWDELAY	int
;	O
if	O
(	O
setsockopt	function
(	O
STDIN_FILENO	int
,	O
IPPROTO_IP	int
,	O
IP_TOS	int
,	O
(	O
char	O
*	O
)	O
&	O
tos	char
,	O
sizeof	O
(	O
int	O
)	O
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setsockopt (IP_TOS): %m"	pointer
)	O
;	O
}	O
{	O
int	O
on	int
=	O
1	int
;	O
if	O
(	O
setsockopt	function
(	O
STDIN_FILENO	int
,	O
SOL_SOCKET	int
,	O
SO_OOBINLINE	int
,	O
(	O
char	O
*	O
)	O
&	O
on	int
,	O
sizeof	O
(	O
on	int
)	O
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_ERR	int
,	O
"setsockopt: %m"	pointer
)	O
;	O
}	O
{	O
int	O
keepalive	int
=	O
1	int
;	O
if	O
(	O
setsockopt	function
(	O
STDIN_FILENO	int
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
(	O
char	O
*	O
)	O
&	O
keepalive	int
,	O
sizeof	O
(	O
keepalive	int
)	O
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setsockopt (SO_KEEPALIVE): %m"	pointer
)	O
;	O
}	O
if	O
(	O
fcntl	function
(	O
STDIN_FILENO	int
,	O
F_SETOWN	O
,	O
getpid	function
(	O
)	O
)	O
==	O
-	O
1	int
)	O
syslog	function
(	O
LOG_ERR	int
,	O
"fcntl F_SETOWN: %m"	pointer
)	O
;	O
dolog	function
(	O
&	O
his_addr	struct
,	O
&	O
cred	struct
)	O
;	O
if	O
(	O
display_file	function
(	O
PATH_NOLOGIN	O
,	O
530	int
)	O
==	O
0	int
)	O
{	O
reply	function
(	O
530	int
,	O
"System not available."	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
display_file	function
(	O
PATH_FTPWELCOME	O
,	O
220	int
)	O
;	O
hostname	pointer
=	O
localhost	function
(	O
)	O
;	O
if	O
(	O
!	O
hostname	pointer
)	O
perror_reply	function
(	O
550	int
,	O
"Local resource failure: malloc"	pointer
)	O
;	O
if	O
(	O
!	O
no_version	int
)	O
reply	function
(	O
220	int
,	O
"%s FTP server (%s %s) ready."	pointer
,	O
hostname	pointer
,	O
PACKAGE_NAME	pointer
,	O
PACKAGE_VERSION	pointer
)	O
;	O
else	O
reply	function
(	O
220	int
,	O
"%s FTP server ready."	pointer
,	O
hostname	pointer
)	O
;	O
setjmp	function
(	O
errcatch	array
)	O
;	O
for	O
(	O
;	O
;	O
)	O
yyparse	function
(	O
)	O
;	O
}	O
static	O
char	O
*	O
curdir	function
(	O
void	O
)	O
{	O
static	O
char	O
*	O
path	pointer
=	O
0	int
;	O
extern	O
char	O
*	O
xgetcwd	function
(	O
void	O
)	O
;	O
free	function
(	O
path	pointer
)	O
;	O
path	pointer
=	O
xgetcwd	function
(	O
)	O
;	O
if	O
(	O
!	O
path	pointer
)	O
return	O
(	O
char	O
*	O
)	O
""	pointer
;	O
if	O
(	O
path	pointer
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
char	O
*	O
tmp	pointer
=	O
realloc	function
(	O
path	pointer
,	O
strlen	function
(	O
path	pointer
)	O
+	O
2	int
)	O
;	O
if	O
(	O
!	O
tmp	pointer
)	O
{	O
free	function
(	O
path	pointer
)	O
;	O
return	O
(	O
char	O
*	O
)	O
""	pointer
;	O
}	O
strcat	function
(	O
tmp	pointer
,	O
"/"	pointer
)	O
;	O
path	pointer
=	O
tmp	pointer
;	O
}	O
return	O
(	O
cred	struct
.	O
guest	int
?	O
path	pointer
+	O
1	int
:	O
path	pointer
)	O
;	O
}	O
static	O
void	O
sigquit	function
(	O
int	O
signo	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"got signal %s"	pointer
,	O
strsignal	function
(	O
signo	int
)	O
)	O
;	O
dologout	function
(	O
-	O
1	int
)	O
;	O
}	O
static	O
void	O
lostconn	function
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
if	O
(	O
debug	int
)	O
syslog	function
(	O
LOG_DEBUG	int
,	O
"lost connection"	pointer
)	O
;	O
dologout	function
(	O
-	O
1	int
)	O
;	O
}	O
char	O
*	O
sgetsave	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
char	O
*	O
string	pointer
;	O
size_t	long
len	char
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
s	pointer
=	O
""	pointer
;	O
len	char
=	O
strlen	function
(	O
s	pointer
)	O
+	O
1	int
;	O
string	pointer
=	O
malloc	function
(	O
len	char
)	O
;	O
if	O
(	O
string	pointer
==	O
NULL	O
)	O
{	O
perror_reply	function
(	O
421	int
,	O
"Local resource failure: malloc"	pointer
)	O
;	O
dologout	function
(	O
1	int
)	O
;	O
}	O
memcpy	function
(	O
string	pointer
,	O
s	pointer
,	O
len	char
)	O
;	O
return	O
string	pointer
;	O
}	O
static	O
void	O
complete_login	function
(	O
struct	O
credentials	struct
*	O
pcred	pointer
)	O
{	O
if	O
(	O
setegid	function
(	O
(	O
gid_t	int
)	O
pcred	pointer
->	O
gid	int
)	O
<	O
0	int
)	O
{	O
reply	function
(	O
550	int
,	O
"Can't set gid."	pointer
)	O
;	O
return	O
;	O
}	O
initgroups	function
(	O
pcred	pointer
->	O
name	pointer
,	O
pcred	pointer
->	O
gid	int
)	O
;	O
snprintf	function
(	O
ttyline	array
,	O
sizeof	O
(	O
ttyline	array
)	O
,	O
"ftp%d"	pointer
,	O
getpid	function
(	O
)	O
)	O
;	O
logwtmp_keep_open	function
(	O
ttyline	array
,	O
pcred	pointer
->	O
name	pointer
,	O
pcred	pointer
->	O
remotehost	pointer
)	O
;	O
if	O
(	O
pcred	pointer
->	O
guest	int
)	O
{	O
if	O
(	O
chroot	function
(	O
pcred	pointer
->	O
rootdir	pointer
)	O
<	O
0	int
||	O
chdir	function
(	O
pcred	pointer
->	O
homedir	pointer
)	O
<	O
0	int
)	O
{	O
reply	function
(	O
550	int
,	O
"Can't set guest privileges."	pointer
)	O
;	O
goto	O
bad	O
;	O
}	O
}	O
else	O
if	O
(	O
pcred	pointer
->	O
dochroot	int
)	O
{	O
if	O
(	O
chroot	function
(	O
pcred	pointer
->	O
rootdir	pointer
)	O
<	O
0	int
||	O
chdir	function
(	O
pcred	pointer
->	O
homedir	pointer
)	O
<	O
0	int
)	O
{	O
reply	function
(	O
550	int
,	O
"Can't change root."	pointer
)	O
;	O
goto	O
bad	O
;	O
}	O
setenv	function
(	O
"HOME"	pointer
,	O
pcred	pointer
->	O
homedir	pointer
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
chdir	function
(	O
pcred	pointer
->	O
rootdir	pointer
)	O
<	O
0	int
)	O
{	O
if	O
(	O
chdir	function
(	O
"/"	pointer
)	O
<	O
0	int
)	O
{	O
reply	function
(	O
530	int
,	O
"User %s: can't change directory to %s."	pointer
,	O
pcred	pointer
->	O
name	pointer
,	O
pcred	pointer
->	O
homedir	pointer
)	O
;	O
goto	O
bad	O
;	O
}	O
else	O
lreply	function
(	O
230	int
,	O
"No directory! Logging in with home=/"	pointer
)	O
;	O
}	O
if	O
(	O
seteuid	function
(	O
(	O
uid_t	int
)	O
pcred	pointer
->	O
uid	int
)	O
<	O
0	int
)	O
{	O
reply	function
(	O
550	int
,	O
"Can't set uid."	pointer
)	O
;	O
goto	O
bad	O
;	O
}	O
display_file	function
(	O
PATH_FTPLOGINMESG	O
,	O
230	int
)	O
;	O
if	O
(	O
pcred	pointer
->	O
guest	int
)	O
{	O
reply	function
(	O
230	int
,	O
"Guest login ok, access restrictions apply."	pointer
)	O
;	O
if	O
(	O
logging	int
)	O
syslog	function
(	O
LOG_INFO	int
,	O
"ANONYMOUS FTP LOGIN FROM %s"	pointer
,	O
pcred	pointer
->	O
remotehost	pointer
)	O
;	O
}	O
else	O
{	O
reply	function
(	O
230	int
,	O
"User %s logged in."	pointer
,	O
pcred	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
logging	int
)	O
syslog	function
(	O
LOG_INFO	int
,	O
"FTP LOGIN FROM %s as %s"	pointer
,	O
pcred	pointer
->	O
remotehost	pointer
,	O
pcred	pointer
->	O
name	pointer
)	O
;	O
}	O
umask	function
(	O
defumask	int
)	O
;	O
return	O
;	O
bad	O
:	O
end_login	function
(	O
pcred	pointer
)	O
;	O
}	O
void	O
user	pointer
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
cred	struct
.	O
logged_in	int
)	O
{	O
if	O
(	O
cred	struct
.	O
guest	int
||	O
cred	struct
.	O
dochroot	int
)	O
{	O
reply	function
(	O
530	int
,	O
"Can't change user from guest login."	pointer
)	O
;	O
return	O
;	O
}	O
end_login	function
(	O
&	O
cred	struct
)	O
;	O
}	O
if	O
(	O
auth_user	function
(	O
name	pointer
,	O
&	O
cred	struct
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
cred	struct
.	O
message	pointer
)	O
{	O
reply	function
(	O
530	int
,	O
"%s"	pointer
,	O
cred	struct
.	O
message	pointer
)	O
;	O
free	function
(	O
cred	struct
.	O
message	pointer
)	O
;	O
cred	struct
.	O
message	pointer
=	O
NULL	O
;	O
}	O
else	O
reply	function
(	O
530	int
,	O
"User %s access denied."	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
logging	int
)	O
syslog	function
(	O
LOG_NOTICE	int
,	O
"FTP LOGIN REFUSED FROM %s, %s"	pointer
,	O
cred	struct
.	O
remotehost	pointer
,	O
name	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
anon_only	int
&&	O
!	O
cred	struct
.	O
guest	int
&&	O
!	O
cred	struct
.	O
dochroot	int
)	O
{	O
reply	function
(	O
530	int
,	O
"Sorry, only anonymous ftp allowed"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
logging	int
)	O
{	O
strncpy	function
(	O
curname	array
,	O
name	pointer
,	O
sizeof	O
(	O
curname	array
)	O
-	O
1	int
)	O
;	O
curname	array
[	O
sizeof	O
(	O
curname	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
cred	struct
.	O
message	pointer
)	O
{	O
reply	function
(	O
331	int
,	O
"%s"	pointer
,	O
cred	struct
.	O
message	pointer
)	O
;	O
free	function
(	O
cred	struct
.	O
message	pointer
)	O
;	O
cred	struct
.	O
message	pointer
=	O
NULL	O
;	O
}	O
else	O
reply	function
(	O
331	int
,	O
"Password required for %s."	pointer
,	O
name	pointer
)	O
;	O
askpasswd	int
=	O
1	int
;	O
if	O
(	O
login_attempts	int
)	O
sleep	function
(	O
(	O
unsigned	O
)	O
login_attempts	int
)	O
;	O
}	O
static	O
void	O
end_login	function
(	O
struct	O
credentials	struct
*	O
pcred	pointer
)	O
{	O
char	O
*	O
remotehost	pointer
=	O
pcred	pointer
->	O
remotehost	pointer
;	O
int	O
atype	int
=	O
pcred	pointer
->	O
auth_type	int
;	O
seteuid	function
(	O
(	O
uid_t	int
)	O
0	int
)	O
;	O
if	O
(	O
pcred	pointer
->	O
logged_in	int
)	O
logwtmp_keep_open	function
(	O
ttyline	array
,	O
""	pointer
,	O
""	pointer
)	O
;	O
free	function
(	O
pcred	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
pcred	pointer
->	O
passwd	pointer
)	O
{	O
memset	function
(	O
pcred	pointer
->	O
passwd	pointer
,	O
0	int
,	O
strlen	function
(	O
pcred	pointer
->	O
passwd	pointer
)	O
)	O
;	O
free	function
(	O
pcred	pointer
->	O
passwd	pointer
)	O
;	O
}	O
free	function
(	O
pcred	pointer
->	O
homedir	pointer
)	O
;	O
free	function
(	O
pcred	pointer
->	O
rootdir	pointer
)	O
;	O
free	function
(	O
pcred	pointer
->	O
shell	pointer
)	O
;	O
if	O
(	O
pcred	pointer
->	O
pass	function
)	O
{	O
memset	function
(	O
pcred	pointer
->	O
pass	function
,	O
0	int
,	O
strlen	function
(	O
pcred	pointer
->	O
pass	function
)	O
)	O
;	O
free	function
(	O
pcred	pointer
->	O
pass	function
)	O
;	O
}	O
free	function
(	O
pcred	pointer
->	O
message	pointer
)	O
;	O
memset	function
(	O
pcred	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
pcred	pointer
)	O
)	O
;	O
pcred	pointer
->	O
remotehost	pointer
=	O
remotehost	pointer
;	O
pcred	pointer
->	O
auth_type	int
=	O
atype	int
;	O
}	O
void	O
pass	function
(	O
const	O
char	O
*	O
passwd	pointer
)	O
{	O
if	O
(	O
cred	struct
.	O
logged_in	int
||	O
askpasswd	int
==	O
0	int
)	O
{	O
reply	function
(	O
503	int
,	O
"Login with USER first."	pointer
)	O
;	O
return	O
;	O
}	O
askpasswd	int
=	O
0	int
;	O
if	O
(	O
!	O
cred	struct
.	O
guest	int
)	O
{	O
if	O
(	O
auth_pass	function
(	O
passwd	pointer
,	O
&	O
cred	struct
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
cred	struct
.	O
message	pointer
)	O
{	O
reply	function
(	O
530	int
,	O
"%s"	pointer
,	O
cred	struct
.	O
message	pointer
)	O
;	O
free	function
(	O
cred	struct
.	O
message	pointer
)	O
;	O
cred	struct
.	O
message	pointer
=	O
NULL	O
;	O
}	O
else	O
reply	function
(	O
530	int
,	O
"Login incorrect."	pointer
)	O
;	O
if	O
(	O
logging	int
)	O
syslog	function
(	O
LOG_NOTICE	int
,	O
"FTP LOGIN FAILED FROM %s, %s"	pointer
,	O
cred	struct
.	O
remotehost	pointer
,	O
curname	array
)	O
;	O
if	O
(	O
login_attempts	int
++	O
>=	O
5	int
)	O
{	O
syslog	function
(	O
LOG_NOTICE	int
,	O
"repeated login failures from %s"	pointer
,	O
cred	struct
.	O
remotehost	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
return	O
;	O
}	O
}	O
cred	struct
.	O
logged_in	int
=	O
1	int
;	O
complete_login	function
(	O
&	O
cred	struct
)	O
;	O
login_attempts	int
=	O
0	int
;	O
}	O
void	O
retrieve	function
(	O
const	O
char	O
*	O
cmd	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
FILE	struct
*	O
fin	pointer
,	O
*	O
dout	pointer
;	O
struct	O
stat	struct
st	struct
;	O
int	O
(	O
*	O
closefunc	pointer
)	O
(	O
FILE	struct
*	O
)	O
;	O
size_t	long
buffer_size	long
=	O
0	int
;	O
if	O
(	O
cmd	pointer
==	O
0	int
)	O
{	O
fin	pointer
=	O
fopen	function
(	O
name	pointer
,	O
"r"	pointer
)	O
,	O
closefunc	pointer
=	O
fclose	function
;	O
st	struct
.	O
st_size	long
=	O
0	int
;	O
}	O
else	O
{	O
char	O
line	pointer
[	O
BUFSIZ	int
]	O
;	O
snprintf	function
(	O
line	pointer
,	O
sizeof	O
line	pointer
,	O
cmd	pointer
,	O
name	pointer
)	O
;	O
name	pointer
=	O
line	pointer
;	O
fin	pointer
=	O
ftpd_popen	function
(	O
line	pointer
,	O
"r"	pointer
)	O
,	O
closefunc	pointer
=	O
ftpd_pclose	function
;	O
st	struct
.	O
st_size	long
=	O
-	O
1	int
;	O
buffer_size	long
=	O
BUFSIZ	int
;	O
}	O
if	O
(	O
fin	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
errno	O
!=	O
0	int
)	O
{	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
if	O
(	O
cmd	pointer
==	O
0	int
)	O
{	O
LOGCMD	O
(	O
"get"	pointer
,	O
name	pointer
)	O
;	O
}	O
}	O
return	O
;	O
}	O
byte_count	long
=	O
-	O
1	int
;	O
if	O
(	O
cmd	pointer
==	O
0	int
&&	O
(	O
fstat	function
(	O
fileno	function
(	O
fin	pointer
)	O
,	O
&	O
st	struct
)	O
<	O
0	int
||	O
!	O
S_ISREG	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
)	O
{	O
reply	function
(	O
550	int
,	O
"%s: not a plain file."	pointer
,	O
name	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
restart_point	long
)	O
{	O
if	O
(	O
type	enum
==	O
TYPE_A	int
)	O
{	O
off_t	long
i	long
,	O
n	long
;	O
int	O
c	int
;	O
n	long
=	O
restart_point	long
;	O
i	long
=	O
0	int
;	O
while	O
(	O
i	long
++	O
<	O
n	long
)	O
{	O
c	int
=	O
getc	function
(	O
fin	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
i	long
++	O
;	O
}	O
}	O
else	O
if	O
(	O
lseek	function
(	O
fileno	function
(	O
fin	pointer
)	O
,	O
restart_point	long
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
dout	pointer
=	O
dataconn	function
(	O
name	pointer
,	O
st	struct
.	O
st_size	long
,	O
"w"	pointer
)	O
;	O
if	O
(	O
dout	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
send_data	function
(	O
fin	pointer
,	O
dout	pointer
,	O
buffer_size	long
)	O
;	O
fclose	function
(	O
dout	pointer
)	O
;	O
data	array
=	O
-	O
1	int
;	O
pdata	int
=	O
-	O
1	int
;	O
done	O
:	O
if	O
(	O
cmd	pointer
==	O
0	int
)	O
LOGBYTES	O
(	O
"get"	pointer
,	O
name	pointer
,	O
byte_count	long
)	O
;	O
(	O
*	O
closefunc	pointer
)	O
(	O
fin	pointer
)	O
;	O
}	O
void	O
store	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
mode	pointer
,	O
int	O
unique	int
)	O
{	O
FILE	struct
*	O
fout	pointer
,	O
*	O
din	pointer
;	O
struct	O
stat	struct
st	struct
;	O
int	O
(	O
*	O
closefunc	pointer
)	O
(	O
FILE	struct
*	O
)	O
;	O
if	O
(	O
unique	int
&&	O
stat	struct
(	O
name	pointer
,	O
&	O
st	struct
)	O
==	O
0	int
)	O
{	O
const	O
char	O
*	O
name_unique	pointer
=	O
gunique	function
(	O
name	pointer
)	O
;	O
if	O
(	O
name_unique	pointer
)	O
name	pointer
=	O
name_unique	pointer
;	O
else	O
{	O
LOGCMD	O
(	O
*	O
mode	pointer
==	O
'w'	O
?	O
"put"	pointer
:	O
"append"	pointer
,	O
name	pointer
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
restart_point	long
)	O
mode	pointer
=	O
"r+"	pointer
;	O
fout	pointer
=	O
fopen	function
(	O
name	pointer
,	O
mode	pointer
)	O
;	O
closefunc	pointer
=	O
fclose	function
;	O
if	O
(	O
fout	pointer
==	O
NULL	O
)	O
{	O
perror_reply	function
(	O
553	int
,	O
name	pointer
)	O
;	O
LOGCMD	O
(	O
*	O
mode	pointer
==	O
'w'	O
?	O
"put"	pointer
:	O
"append"	pointer
,	O
name	pointer
)	O
;	O
return	O
;	O
}	O
byte_count	long
=	O
-	O
1	int
;	O
if	O
(	O
restart_point	long
)	O
{	O
if	O
(	O
type	enum
==	O
TYPE_A	int
)	O
{	O
off_t	long
i	long
,	O
n	long
;	O
int	O
c	int
;	O
n	long
=	O
restart_point	long
;	O
i	long
=	O
0	int
;	O
while	O
(	O
i	long
++	O
<	O
n	long
)	O
{	O
c	int
=	O
getc	function
(	O
fout	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
{	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
i	long
++	O
;	O
}	O
if	O
(	O
fseeko	function
(	O
fout	pointer
,	O
0L	int
,	O
SEEK_CUR	int
)	O
<	O
0	int
)	O
{	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
else	O
if	O
(	O
lseek	function
(	O
fileno	function
(	O
fout	pointer
)	O
,	O
restart_point	long
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
{	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
goto	O
done	O
;	O
}	O
}	O
din	pointer
=	O
dataconn	function
(	O
name	pointer
,	O
(	O
off_t	long
)	O
-	O
1	int
,	O
"r"	pointer
)	O
;	O
if	O
(	O
din	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
if	O
(	O
receive_data	function
(	O
din	pointer
,	O
fout	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
unique	int
)	O
reply	function
(	O
226	int
,	O
"Transfer complete (unique file name:%s)."	pointer
,	O
name	pointer
)	O
;	O
else	O
reply	function
(	O
226	int
,	O
"Transfer complete."	pointer
)	O
;	O
}	O
fclose	function
(	O
din	pointer
)	O
;	O
data	array
=	O
-	O
1	int
;	O
pdata	int
=	O
-	O
1	int
;	O
done	O
:	O
LOGBYTES	O
(	O
*	O
mode	pointer
==	O
'w'	O
?	O
"put"	pointer
:	O
"append"	pointer
,	O
name	pointer
,	O
byte_count	long
)	O
;	O
(	O
*	O
closefunc	pointer
)	O
(	O
fout	pointer
)	O
;	O
}	O
static	O
FILE	struct
*	O
getdatasock	function
(	O
const	O
char	O
*	O
mode	pointer
)	O
{	O
int	O
s	pointer
,	O
t	int
,	O
tries	int
;	O
if	O
(	O
data	array
>=	O
0	int
)	O
return	O
fdopen	function
(	O
data	array
,	O
mode	pointer
)	O
;	O
seteuid	function
(	O
(	O
uid_t	int
)	O
0	int
)	O
;	O
s	pointer
=	O
socket	function
(	O
AF_INET	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
s	pointer
<	O
0	int
)	O
goto	O
bad	O
;	O
{	O
int	O
on	int
=	O
1	int
;	O
if	O
(	O
setsockopt	function
(	O
s	pointer
,	O
SOL_SOCKET	int
,	O
SO_REUSEADDR	int
,	O
(	O
char	O
*	O
)	O
&	O
on	int
,	O
sizeof	O
(	O
on	int
)	O
)	O
<	O
0	int
)	O
goto	O
bad	O
;	O
}	O
data_source	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
data_source	struct
.	O
sin_addr	struct
=	O
ctrl_addr	struct
.	O
sin_addr	struct
;	O
for	O
(	O
tries	int
=	O
1	int
;	O
;	O
tries	int
++	O
)	O
{	O
if	O
(	O
bind	function
(	O
s	pointer
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
data_source	struct
,	O
sizeof	O
(	O
data_source	struct
)	O
)	O
>=	O
0	int
)	O
break	O
;	O
if	O
(	O
errno	O
!=	O
EADDRINUSE	int
||	O
tries	int
>	O
10	int
)	O
goto	O
bad	O
;	O
sleep	function
(	O
tries	int
)	O
;	O
}	O
seteuid	function
(	O
(	O
uid_t	int
)	O
cred	struct
.	O
uid	int
)	O
;	O
{	O
int	O
on	int
=	O
IPTOS_THROUGHPUT	int
;	O
if	O
(	O
setsockopt	function
(	O
s	pointer
,	O
IPPROTO_IP	int
,	O
IP_TOS	int
,	O
(	O
char	O
*	O
)	O
&	O
on	int
,	O
sizeof	O
(	O
int	O
)	O
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setsockopt (IP_TOS): %m"	pointer
)	O
;	O
}	O
return	O
(	O
fdopen	function
(	O
s	pointer
,	O
mode	pointer
)	O
)	O
;	O
bad	O
:	O
t	int
=	O
errno	O
;	O
seteuid	function
(	O
(	O
uid_t	int
)	O
cred	struct
.	O
uid	int
)	O
;	O
close	pointer
(	O
s	pointer
)	O
;	O
errno	O
=	O
t	int
;	O
return	O
NULL	O
;	O
}	O
static	O
FILE	struct
*	O
dataconn	function
(	O
const	O
char	O
*	O
name	pointer
,	O
off_t	long
size	long
,	O
const	O
char	O
*	O
mode	pointer
)	O
{	O
char	O
sizebuf	array
[	O
32	int
]	O
;	O
FILE	struct
*	O
file	pointer
;	O
int	O
retry	int
=	O
0	int
;	O
file_size	long
=	O
size	long
;	O
byte_count	long
=	O
0	int
;	O
if	O
(	O
size	long
!=	O
(	O
off_t	long
)	O
-	O
1	int
)	O
snprintf	function
(	O
sizebuf	array
,	O
sizeof	O
(	O
sizebuf	array
)	O
,	O
" (%s bytes)"	pointer
,	O
off_to_str	function
(	O
size	long
)	O
)	O
;	O
else	O
*	O
sizebuf	array
=	O
'\0'	O
;	O
if	O
(	O
pdata	int
>=	O
0	int
)	O
{	O
struct	O
sockaddr_in	struct
from	struct
;	O
socklen_t	int
s	pointer
;	O
socklen_t	int
fromlen	int
=	O
sizeof	O
(	O
from	struct
)	O
;	O
signal	function
(	O
SIGALRM	int
,	O
toolong	function
)	O
;	O
alarm	function
(	O
(	O
unsigned	O
)	O
timeout	int
)	O
;	O
s	pointer
=	O
accept	function
(	O
pdata	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	struct
,	O
&	O
fromlen	int
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
if	O
(	O
s	pointer
<	O
0	int
)	O
{	O
reply	function
(	O
425	int
,	O
"Can't open data connection."	pointer
)	O
;	O
close	pointer
(	O
pdata	int
)	O
;	O
pdata	int
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
close	pointer
(	O
pdata	int
)	O
;	O
pdata	int
=	O
s	pointer
;	O
{	O
int	O
tos	char
=	O
IPTOS_THROUGHPUT	int
;	O
setsockopt	function
(	O
s	pointer
,	O
IPPROTO_IP	int
,	O
IP_TOS	int
,	O
(	O
char	O
*	O
)	O
&	O
tos	char
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
{	O
int	O
keepalive	int
=	O
1	int
;	O
setsockopt	function
(	O
s	pointer
,	O
SOL_SOCKET	int
,	O
SO_KEEPALIVE	int
,	O
(	O
char	O
*	O
)	O
&	O
keepalive	int
,	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
reply	function
(	O
150	int
,	O
"Opening %s mode data connection for '%s'%s."	pointer
,	O
type	enum
==	O
TYPE_A	int
?	O
"ASCII"	pointer
:	O
"BINARY"	pointer
,	O
name	pointer
,	O
sizebuf	array
)	O
;	O
return	O
fdopen	function
(	O
pdata	int
,	O
mode	pointer
)	O
;	O
}	O
if	O
(	O
data	array
>=	O
0	int
)	O
{	O
reply	function
(	O
125	int
,	O
"Using existing data connection for '%s'%s."	pointer
,	O
name	pointer
,	O
sizebuf	array
)	O
;	O
usedefault	int
=	O
1	int
;	O
return	O
fdopen	function
(	O
data	array
,	O
mode	pointer
)	O
;	O
}	O
if	O
(	O
usedefault	int
)	O
data_dest	struct
=	O
his_addr	struct
;	O
usedefault	int
=	O
1	int
;	O
file	pointer
=	O
getdatasock	function
(	O
mode	pointer
)	O
;	O
if	O
(	O
file	pointer
==	O
NULL	O
)	O
{	O
reply	function
(	O
425	int
,	O
"Can't create data socket (%s,%d): %s."	pointer
,	O
inet_ntoa	function
(	O
data_source	struct
.	O
sin_addr	struct
)	O
,	O
ntohs	function
(	O
data_source	struct
.	O
sin_port	short
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
data	array
=	O
fileno	function
(	O
file	pointer
)	O
;	O
while	O
(	O
connect	function
(	O
data	array
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
data_dest	struct
,	O
sizeof	O
(	O
data_dest	struct
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EADDRINUSE	int
&&	O
retry	int
<	O
swaitmax	int
)	O
{	O
sleep	function
(	O
(	O
unsigned	O
)	O
swaitint	int
)	O
;	O
retry	int
+=	O
swaitint	int
;	O
continue	O
;	O
}	O
perror_reply	function
(	O
425	int
,	O
"Can't build data connection"	pointer
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
data	array
=	O
-	O
1	int
;	O
return	O
NULL	O
;	O
}	O
reply	function
(	O
150	int
,	O
"Opening %s mode data connection for '%s'%s."	pointer
,	O
type	enum
==	O
TYPE_A	int
?	O
"ASCII"	pointer
:	O
"BINARY"	pointer
,	O
name	pointer
,	O
sizebuf	array
)	O
;	O
return	O
file	pointer
;	O
}	O
static	O
void	O
send_data	function
(	O
FILE	struct
*	O
instr	pointer
,	O
FILE	struct
*	O
outstr	pointer
,	O
off_t	long
blksize	long
)	O
{	O
int	O
c	int
,	O
cnt	int
,	O
filefd	int
,	O
netfd	int
;	O
char	O
*	O
buf	pointer
,	O
*	O
bp	pointer
;	O
off_t	long
curpos	long
;	O
size_t	long
len	char
,	O
filesize	long
;	O
transflag	int
++	O
;	O
if	O
(	O
setjmp	function
(	O
urgcatch	array
)	O
)	O
{	O
transflag	int
=	O
0	int
;	O
return	O
;	O
}	O
netfd	int
=	O
fileno	function
(	O
outstr	pointer
)	O
;	O
filefd	int
=	O
fileno	function
(	O
instr	pointer
)	O
;	O
if	O
(	O
file_size	long
>	O
0	int
)	O
{	O
curpos	long
=	O
lseek	function
(	O
filefd	int
,	O
0	int
,	O
SEEK_CUR	int
)	O
;	O
if	O
(	O
curpos	long
>=	O
0	int
)	O
{	O
filesize	long
=	O
file_size	long
-	O
curpos	long
;	O
buf	pointer
=	O
mmap	function
(	O
0	int
,	O
filesize	long
,	O
PROT_READ	int
,	O
MAP_SHARED	int
,	O
filefd	int
,	O
curpos	long
)	O
;	O
}	O
}	O
switch	O
(	O
type	enum
)	O
{	O
case	O
TYPE_A	int
:	O
if	O
(	O
file_size	long
>	O
0	int
&&	O
curpos	long
>=	O
0	int
&&	O
buf	pointer
!=	O
MAP_FAILED	O
)	O
{	O
len	char
=	O
0	int
;	O
while	O
(	O
len	char
<	O
filesize	long
)	O
{	O
byte_count	long
++	O
;	O
if	O
(	O
buf	pointer
[	O
len	char
]	O
==	O
'\n'	O
)	O
{	O
if	O
(	O
ferror	function
(	O
outstr	pointer
)	O
)	O
break	O
;	O
putc	function
(	O
'\r'	O
,	O
outstr	pointer
)	O
;	O
}	O
putc	function
(	O
buf	pointer
[	O
len	char
]	O
,	O
outstr	pointer
)	O
;	O
len	char
++	O
;	O
}	O
fflush	function
(	O
outstr	pointer
)	O
;	O
transflag	int
=	O
0	int
;	O
munmap	function
(	O
buf	pointer
,	O
filesize	long
)	O
;	O
if	O
(	O
ferror	function
(	O
outstr	pointer
)	O
)	O
goto	O
data_err	O
;	O
reply	function
(	O
226	int
,	O
"Transfer complete."	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
(	O
c	int
=	O
getc	function
(	O
instr	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
byte_count	long
++	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
ferror	function
(	O
outstr	pointer
)	O
)	O
goto	O
data_err	O
;	O
putc	function
(	O
'\r'	O
,	O
outstr	pointer
)	O
;	O
}	O
putc	function
(	O
c	int
,	O
outstr	pointer
)	O
;	O
}	O
fflush	function
(	O
outstr	pointer
)	O
;	O
transflag	int
=	O
0	int
;	O
if	O
(	O
ferror	function
(	O
instr	pointer
)	O
)	O
goto	O
file_err	O
;	O
if	O
(	O
ferror	function
(	O
outstr	pointer
)	O
)	O
goto	O
data_err	O
;	O
reply	function
(	O
226	int
,	O
"Transfer complete."	pointer
)	O
;	O
return	O
;	O
case	O
TYPE_I	int
:	O
case	O
TYPE_L	int
:	O
if	O
(	O
file_size	long
>	O
0	int
&&	O
curpos	long
>=	O
0	int
&&	O
buf	pointer
!=	O
MAP_FAILED	O
)	O
{	O
bp	pointer
=	O
buf	pointer
;	O
len	char
=	O
filesize	long
;	O
do	O
{	O
cnt	int
=	O
write	pointer
(	O
netfd	int
,	O
bp	pointer
,	O
len	char
)	O
;	O
len	char
-=	O
cnt	int
;	O
bp	pointer
+=	O
cnt	int
;	O
if	O
(	O
cnt	int
>	O
0	int
)	O
byte_count	long
+=	O
cnt	int
;	O
}	O
while	O
(	O
cnt	int
>	O
0	int
&&	O
len	char
>	O
0	int
)	O
;	O
transflag	int
=	O
0	int
;	O
munmap	function
(	O
buf	pointer
,	O
(	O
size_t	long
)	O
filesize	long
)	O
;	O
if	O
(	O
cnt	int
<	O
0	int
)	O
goto	O
data_err	O
;	O
reply	function
(	O
226	int
,	O
"Transfer complete."	pointer
)	O
;	O
return	O
;	O
}	O
buf	pointer
=	O
malloc	function
(	O
(	O
u_int	int
)	O
blksize	long
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
{	O
transflag	int
=	O
0	int
;	O
perror_reply	function
(	O
451	int
,	O
"Local resource failure: malloc"	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
(	O
cnt	int
=	O
read	pointer
(	O
filefd	int
,	O
buf	pointer
,	O
(	O
u_int	int
)	O
blksize	long
)	O
)	O
>	O
0	int
&&	O
write	pointer
(	O
netfd	int
,	O
buf	pointer
,	O
cnt	int
)	O
==	O
cnt	int
)	O
byte_count	long
+=	O
cnt	int
;	O
transflag	int
=	O
0	int
;	O
free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
cnt	int
!=	O
0	int
)	O
{	O
if	O
(	O
cnt	int
<	O
0	int
)	O
goto	O
file_err	O
;	O
goto	O
data_err	O
;	O
}	O
reply	function
(	O
226	int
,	O
"Transfer complete."	pointer
)	O
;	O
return	O
;	O
default	O
:	O
transflag	int
=	O
0	int
;	O
reply	function
(	O
550	int
,	O
"Unimplemented TYPE %d in send_data"	pointer
,	O
type	enum
)	O
;	O
return	O
;	O
}	O
data_err	O
:	O
transflag	int
=	O
0	int
;	O
perror_reply	function
(	O
426	int
,	O
"Data connection"	pointer
)	O
;	O
return	O
;	O
file_err	O
:	O
transflag	int
=	O
0	int
;	O
perror_reply	function
(	O
551	int
,	O
"Error on input file"	pointer
)	O
;	O
}	O
static	O
int	O
receive_data	function
(	O
FILE	struct
*	O
instr	pointer
,	O
FILE	struct
*	O
outstr	pointer
)	O
{	O
int	O
c	int
;	O
int	O
cnt	int
,	O
bare_lfs	int
=	O
0	int
;	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
transflag	int
++	O
;	O
if	O
(	O
setjmp	function
(	O
urgcatch	array
)	O
)	O
{	O
transflag	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
type	enum
)	O
{	O
case	O
TYPE_I	int
:	O
case	O
TYPE_L	int
:	O
while	O
(	O
(	O
cnt	int
=	O
read	pointer
(	O
fileno	function
(	O
instr	pointer
)	O
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
write	pointer
(	O
fileno	function
(	O
outstr	pointer
)	O
,	O
buf	pointer
,	O
cnt	int
)	O
!=	O
cnt	int
)	O
goto	O
file_err	O
;	O
byte_count	long
+=	O
cnt	int
;	O
}	O
if	O
(	O
cnt	int
<	O
0	int
)	O
goto	O
data_err	O
;	O
transflag	int
=	O
0	int
;	O
return	O
0	int
;	O
case	O
TYPE_E	int
:	O
reply	function
(	O
553	int
,	O
"TYPE E not implemented."	pointer
)	O
;	O
transflag	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
case	O
TYPE_A	int
:	O
while	O
(	O
(	O
c	int
=	O
getc	function
(	O
instr	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
byte_count	long
++	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
bare_lfs	int
++	O
;	O
while	O
(	O
c	int
==	O
'\r'	O
)	O
{	O
if	O
(	O
ferror	function
(	O
outstr	pointer
)	O
)	O
goto	O
data_err	O
;	O
c	int
=	O
getc	function
(	O
instr	pointer
)	O
;	O
if	O
(	O
c	int
!=	O
'\n'	O
)	O
{	O
putc	function
(	O
'\r'	O
,	O
outstr	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'\0'	O
||	O
c	int
==	O
EOF	O
)	O
goto	O
contin2	O
;	O
}	O
}	O
putc	function
(	O
c	int
,	O
outstr	pointer
)	O
;	O
contin2	O
:	O
;	O
}	O
fflush	function
(	O
outstr	pointer
)	O
;	O
if	O
(	O
ferror	function
(	O
instr	pointer
)	O
)	O
goto	O
data_err	O
;	O
if	O
(	O
ferror	function
(	O
outstr	pointer
)	O
)	O
goto	O
file_err	O
;	O
transflag	int
=	O
0	int
;	O
if	O
(	O
bare_lfs	int
)	O
{	O
lreply	function
(	O
226	int
,	O
"WARNING! %d bare linefeeds received in ASCII mode"	pointer
,	O
bare_lfs	int
)	O
;	O
printf	function
(	O
"   File may not have transferred correctly.\r\n"	pointer
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
default	O
:	O
reply	function
(	O
550	int
,	O
"Unimplemented TYPE %d in receive_data"	pointer
,	O
type	enum
)	O
;	O
transflag	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
data_err	O
:	O
transflag	int
=	O
0	int
;	O
perror_reply	function
(	O
426	int
,	O
"Data Connection"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
file_err	O
:	O
transflag	int
=	O
0	int
;	O
perror_reply	function
(	O
452	int
,	O
"Error writing file"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
void	O
statfilecmd	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
FILE	struct
*	O
fin	pointer
;	O
int	O
c	int
;	O
char	O
line	pointer
[	O
LINE_MAX	O
]	O
;	O
snprintf	function
(	O
line	pointer
,	O
sizeof	O
(	O
line	pointer
)	O
,	O
"/bin/ls -lgA %s"	pointer
,	O
filename	pointer
)	O
;	O
fin	pointer
=	O
ftpd_popen	function
(	O
line	pointer
,	O
"r"	pointer
)	O
;	O
lreply	function
(	O
211	int
,	O
"status of %s:"	pointer
,	O
filename	pointer
)	O
;	O
while	O
(	O
(	O
c	int
=	O
getc	function
(	O
fin	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
if	O
(	O
ferror	function
(	O
stdout	pointer
)	O
)	O
{	O
perror_reply	function
(	O
421	int
,	O
"control connection"	pointer
)	O
;	O
ftpd_pclose	function
(	O
fin	pointer
)	O
;	O
dologout	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
ferror	function
(	O
fin	pointer
)	O
)	O
{	O
perror_reply	function
(	O
551	int
,	O
filename	pointer
)	O
;	O
ftpd_pclose	function
(	O
fin	pointer
)	O
;	O
return	O
;	O
}	O
putc	function
(	O
'\r'	O
,	O
stdout	pointer
)	O
;	O
}	O
putc	function
(	O
c	int
,	O
stdout	pointer
)	O
;	O
}	O
ftpd_pclose	function
(	O
fin	pointer
)	O
;	O
reply	function
(	O
211	int
,	O
"End of Status"	pointer
)	O
;	O
}	O
void	O
statcmd	function
(	O
void	O
)	O
{	O
struct	O
sockaddr_in	struct
*	O
sin	pointer
;	O
unsigned	O
char	O
*	O
a	pointer
,	O
*	O
p	pointer
;	O
lreply	function
(	O
211	int
,	O
"%s FTP server status:"	pointer
,	O
hostname	pointer
)	O
;	O
if	O
(	O
!	O
no_version	int
)	O
printf	function
(	O
"     ftpd (%s) %s\r\n"	pointer
,	O
PACKAGE_NAME	pointer
,	O
PACKAGE_VERSION	pointer
)	O
;	O
printf	function
(	O
"     Connected to %s"	pointer
,	O
cred	struct
.	O
remotehost	pointer
)	O
;	O
if	O
(	O
!	O
isdigit	function
(	O
cred	struct
.	O
remotehost	pointer
[	O
0	int
]	O
)	O
)	O
printf	function
(	O
" (%s)"	pointer
,	O
inet_ntoa	function
(	O
his_addr	struct
.	O
sin_addr	struct
)	O
)	O
;	O
printf	function
(	O
"\r\n"	pointer
)	O
;	O
if	O
(	O
cred	struct
.	O
logged_in	int
)	O
{	O
if	O
(	O
cred	struct
.	O
guest	int
)	O
printf	function
(	O
"     Logged in anonymously\r\n"	pointer
)	O
;	O
else	O
printf	function
(	O
"     Logged in as %s\r\n"	pointer
,	O
cred	struct
.	O
name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
askpasswd	int
)	O
printf	function
(	O
"     Waiting for password\r\n"	pointer
)	O
;	O
else	O
printf	function
(	O
"     Waiting for user name\r\n"	pointer
)	O
;	O
printf	function
(	O
"     TYPE: %s"	pointer
,	O
typenames	array
[	O
type	enum
]	O
)	O
;	O
if	O
(	O
type	enum
==	O
TYPE_A	int
||	O
type	enum
==	O
TYPE_E	int
)	O
printf	function
(	O
", FORM: %s"	pointer
,	O
formnames	array
[	O
form	int
]	O
)	O
;	O
if	O
(	O
type	enum
==	O
TYPE_L	int
)	O
printf	function
(	O
" %d"	pointer
,	O
CHAR_BIT	O
)	O
;	O
printf	function
(	O
"; STRUcture: %s; transfer MODE: %s\r\n"	pointer
,	O
strunames	array
[	O
stru	int
]	O
,	O
modenames	array
[	O
stru_mode	int
]	O
)	O
;	O
if	O
(	O
data	array
!=	O
-	O
1	int
)	O
printf	function
(	O
"     Data connection open\r\n"	pointer
)	O
;	O
else	O
if	O
(	O
pdata	int
!=	O
-	O
1	int
)	O
{	O
printf	function
(	O
"     in Passive mode"	pointer
)	O
;	O
sin	pointer
=	O
&	O
pasv_addr	struct
;	O
goto	O
printaddr	O
;	O
}	O
else	O
if	O
(	O
usedefault	int
==	O
0	int
)	O
{	O
printf	function
(	O
"     PORT"	pointer
)	O
;	O
sin	pointer
=	O
&	O
data_dest	struct
;	O
printaddr	O
:	O
a	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
sin	pointer
->	O
sin_addr	struct
;	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
sin	pointer
->	O
sin_port	short
;	O
printf	function
(	O
" (%d,%d,%d,%d,%d,%d)\r\n"	pointer
,	O
UC	O
(	O
a	pointer
[	O
0	int
]	O
)	O
,	O
UC	O
(	O
a	pointer
[	O
1	int
]	O
)	O
,	O
UC	O
(	O
a	pointer
[	O
2	int
]	O
)	O
,	O
UC	O
(	O
a	pointer
[	O
3	int
]	O
)	O
,	O
UC	O
(	O
p	pointer
[	O
0	int
]	O
)	O
,	O
UC	O
(	O
p	pointer
[	O
1	int
]	O
)	O
)	O
;	O
}	O
else	O
printf	function
(	O
"     No data connection\r\n"	pointer
)	O
;	O
reply	function
(	O
211	int
,	O
"End of status"	pointer
)	O
;	O
}	O
void	O
fatal	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
reply	function
(	O
451	int
,	O
"Error in server: %s\n"	pointer
,	O
s	pointer
)	O
;	O
reply	function
(	O
221	int
,	O
"Closing connection due to server error."	pointer
)	O
;	O
dologout	function
(	O
0	int
)	O
;	O
}	O
void	O
reply	function
(	O
int	O
n	long
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
printf	function
(	O
"%d "	pointer
,	O
n	long
)	O
;	O
vprintf	function
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
printf	function
(	O
"\r\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
debug	int
)	O
{	O
syslog	function
(	O
LOG_DEBUG	int
,	O
"<--- %d "	pointer
,	O
n	long
)	O
;	O
vsyslog	function
(	O
LOG_DEBUG	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
}	O
}	O
void	O
lreply	function
(	O
int	O
n	long
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
printf	function
(	O
"%d- "	pointer
,	O
n	long
)	O
;	O
vprintf	function
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
printf	function
(	O
"\r\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
debug	int
)	O
{	O
syslog	function
(	O
LOG_DEBUG	int
,	O
"<--- %d- "	pointer
,	O
n	long
)	O
;	O
vsyslog	function
(	O
LOG_DEBUG	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
}	O
}	O
static	O
void	O
ack	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
reply	function
(	O
250	int
,	O
"%s command successful."	pointer
,	O
s	pointer
)	O
;	O
}	O
void	O
nack	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
reply	function
(	O
502	int
,	O
"%s command not implemented."	pointer
,	O
s	pointer
)	O
;	O
}	O
void	O
delete	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
LOGCMD	O
(	O
"delete"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
name	pointer
,	O
&	O
st	struct
)	O
<	O
0	int
)	O
{	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
rmdir	function
(	O
name	pointer
)	O
<	O
0	int
)	O
{	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
return	O
;	O
}	O
goto	O
done	O
;	O
}	O
if	O
(	O
unlink	function
(	O
name	pointer
)	O
<	O
0	int
)	O
{	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
return	O
;	O
}	O
done	O
:	O
ack	function
(	O
"DELE"	pointer
)	O
;	O
}	O
void	O
cwd	short
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
if	O
(	O
chdir	function
(	O
path	pointer
)	O
<	O
0	int
)	O
perror_reply	function
(	O
550	int
,	O
path	pointer
)	O
;	O
else	O
ack	function
(	O
"CWD"	pointer
)	O
;	O
}	O
void	O
makedir	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
extern	O
char	O
*	O
xgetcwd	function
(	O
void	O
)	O
;	O
LOGCMD	O
(	O
"mkdir"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
mkdir	function
(	O
name	pointer
,	O
0777	int
)	O
<	O
0	int
)	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
else	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
reply	function
(	O
257	int
,	O
"\"%s\" new directory created."	pointer
,	O
name	pointer
)	O
;	O
else	O
{	O
char	O
*	O
current	pointer
=	O
xgetcwd	function
(	O
)	O
;	O
if	O
(	O
current	pointer
)	O
{	O
if	O
(	O
current	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
current	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
reply	function
(	O
257	int
,	O
"\"%s/%s\" new directory created."	pointer
,	O
current	pointer
,	O
name	pointer
)	O
;	O
free	function
(	O
current	pointer
)	O
;	O
}	O
else	O
reply	function
(	O
257	int
,	O
"(unknown absolute name) new directory created."	pointer
)	O
;	O
}	O
}	O
void	O
removedir	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
LOGCMD	O
(	O
"rmdir"	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
rmdir	function
(	O
name	pointer
)	O
<	O
0	int
)	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
else	O
ack	function
(	O
"RMD"	pointer
)	O
;	O
}	O
void	O
pwd	function
(	O
void	O
)	O
{	O
extern	O
char	O
*	O
xgetcwd	function
(	O
void	O
)	O
;	O
char	O
*	O
path	pointer
=	O
xgetcwd	function
(	O
)	O
;	O
if	O
(	O
path	pointer
)	O
{	O
reply	function
(	O
257	int
,	O
"\"%s\" is current directory."	pointer
,	O
path	pointer
)	O
;	O
free	function
(	O
path	pointer
)	O
;	O
}	O
else	O
reply	function
(	O
550	int
,	O
"%s."	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
char	O
*	O
renamefrom	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
stat	struct
(	O
name	pointer
,	O
&	O
st	struct
)	O
<	O
0	int
)	O
{	O
perror_reply	function
(	O
550	int
,	O
name	pointer
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
reply	function
(	O
350	int
,	O
"File exists, ready for destination name"	pointer
)	O
;	O
return	O
(	O
char	O
*	O
)	O
(	O
name	pointer
)	O
;	O
}	O
void	O
renamecmd	function
(	O
const	O
char	O
*	O
from	struct
,	O
const	O
char	O
*	O
to	pointer
)	O
{	O
LOGCMD2	O
(	O
"rename"	pointer
,	O
from	struct
,	O
to	pointer
)	O
;	O
if	O
(	O
rename	function
(	O
from	struct
,	O
to	pointer
)	O
<	O
0	int
)	O
perror_reply	function
(	O
550	int
,	O
"rename"	pointer
)	O
;	O
else	O
ack	function
(	O
"RNTO"	pointer
)	O
;	O
}	O
static	O
void	O
dolog	function
(	O
struct	O
sockaddr_in	struct
*	O
sin	pointer
,	O
struct	O
credentials	struct
*	O
pcred	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
struct	O
hostent	struct
*	O
hp	pointer
=	O
gethostbyaddr	function
(	O
(	O
char	O
*	O
)	O
&	O
sin	pointer
->	O
sin_addr	struct
,	O
sizeof	O
(	O
struct	O
in_addr	struct
)	O
,	O
AF_INET	O
)	O
;	O
if	O
(	O
hp	pointer
)	O
name	pointer
=	O
hp	pointer
->	O
h_name	pointer
;	O
else	O
name	pointer
=	O
inet_ntoa	function
(	O
sin	pointer
->	O
sin_addr	struct
)	O
;	O
free	function
(	O
pcred	pointer
->	O
remotehost	pointer
)	O
;	O
pcred	pointer
->	O
remotehost	pointer
=	O
sgetsave	function
(	O
name	pointer
)	O
;	O
if	O
(	O
logging	int
)	O
syslog	function
(	O
LOG_INFO	int
,	O
"connection from %s"	pointer
,	O
pcred	pointer
->	O
remotehost	pointer
)	O
;	O
}	O
void	O
dologout	function
(	O
int	O
status	int
)	O
{	O
transflag	int
=	O
0	int
;	O
if	O
(	O
cred	struct
.	O
logged_in	int
)	O
{	O
seteuid	function
(	O
(	O
uid_t	int
)	O
0	int
)	O
;	O
logwtmp_keep_open	function
(	O
ttyline	array
,	O
""	pointer
,	O
""	pointer
)	O
;	O
}	O
_exit	function
(	O
status	int
)	O
;	O
}	O
static	O
void	O
myoob	function
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
char	O
*	O
cp	pointer
;	O
if	O
(	O
!	O
transflag	int
)	O
return	O
;	O
cp	pointer
=	O
tmpline	array
;	O
if	O
(	O
telnet_fgets	function
(	O
cp	pointer
,	O
7	int
,	O
stdin	pointer
)	O
==	O
NULL	O
)	O
{	O
reply	function
(	O
221	int
,	O
"You could at least say goodbye."	pointer
)	O
;	O
dologout	function
(	O
0	int
)	O
;	O
}	O
upper	function
(	O
cp	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
cp	pointer
,	O
"ABOR\r\n"	pointer
)	O
==	O
0	int
)	O
{	O
tmpline	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
reply	function
(	O
426	int
,	O
"Transfer aborted. Data connection closed."	pointer
)	O
;	O
reply	function
(	O
226	int
,	O
"Abort successful"	pointer
)	O
;	O
longjmp	function
(	O
urgcatch	array
,	O
1	int
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
cp	pointer
,	O
"STAT\r\n"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
file_size	long
!=	O
(	O
off_t	long
)	O
-	O
1	int
)	O
reply	function
(	O
213	int
,	O
"Status: %s of %s bytes transferred"	pointer
,	O
off_to_str	function
(	O
byte_count	long
)	O
,	O
off_to_str	function
(	O
file_size	long
)	O
)	O
;	O
else	O
reply	function
(	O
213	int
,	O
"Status: %s bytes transferred"	pointer
,	O
off_to_str	function
(	O
byte_count	long
)	O
)	O
;	O
}	O
}	O
void	O
passive	function
(	O
void	O
)	O
{	O
socklen_t	int
len	char
;	O
char	O
*	O
p	pointer
,	O
*	O
a	pointer
;	O
pdata	int
=	O
socket	function
(	O
AF_INET	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
pdata	int
<	O
0	int
)	O
{	O
perror_reply	function
(	O
425	int
,	O
"Can't open passive connection"	pointer
)	O
;	O
return	O
;	O
}	O
pasv_addr	struct
=	O
ctrl_addr	struct
;	O
pasv_addr	struct
.	O
sin_port	short
=	O
0	int
;	O
seteuid	function
(	O
(	O
uid_t	int
)	O
0	int
)	O
;	O
if	O
(	O
bind	function
(	O
pdata	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
pasv_addr	struct
,	O
sizeof	O
(	O
pasv_addr	struct
)	O
)	O
<	O
0	int
)	O
{	O
seteuid	function
(	O
(	O
uid_t	int
)	O
cred	struct
.	O
uid	int
)	O
;	O
goto	O
pasv_error	O
;	O
}	O
seteuid	function
(	O
(	O
uid_t	int
)	O
cred	struct
.	O
uid	int
)	O
;	O
len	char
=	O
sizeof	O
(	O
pasv_addr	struct
)	O
;	O
if	O
(	O
getsockname	function
(	O
pdata	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
pasv_addr	struct
,	O
&	O
len	char
)	O
<	O
0	int
)	O
goto	O
pasv_error	O
;	O
if	O
(	O
listen	function
(	O
pdata	int
,	O
1	int
)	O
<	O
0	int
)	O
goto	O
pasv_error	O
;	O
a	pointer
=	O
(	O
char	O
*	O
)	O
&	O
pasv_addr	struct
.	O
sin_addr	struct
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
&	O
pasv_addr	struct
.	O
sin_port	short
;	O
reply	function
(	O
227	int
,	O
"Entering Passive Mode (%d,%d,%d,%d,%d,%d)"	pointer
,	O
UC	O
(	O
a	pointer
[	O
0	int
]	O
)	O
,	O
UC	O
(	O
a	pointer
[	O
1	int
]	O
)	O
,	O
UC	O
(	O
a	pointer
[	O
2	int
]	O
)	O
,	O
UC	O
(	O
a	pointer
[	O
3	int
]	O
)	O
,	O
UC	O
(	O
p	pointer
[	O
0	int
]	O
)	O
,	O
UC	O
(	O
p	pointer
[	O
1	int
]	O
)	O
)	O
;	O
return	O
;	O
pasv_error	O
:	O
close	pointer
(	O
pdata	int
)	O
;	O
pdata	int
=	O
-	O
1	int
;	O
perror_reply	function
(	O
425	int
,	O
"Can't open passive connection"	pointer
)	O
;	O
return	O
;	O
}	O
static	O
char	O
*	O
gunique	function
(	O
const	O
char	O
*	O
local	pointer
)	O
{	O
static	O
char	O
*	O
string	pointer
=	O
0	int
;	O
struct	O
stat	struct
st	struct
;	O
int	O
count	int
;	O
char	O
*	O
cp	pointer
;	O
cp	pointer
=	O
strrchr	function
(	O
local	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
*	O
cp	pointer
=	O
'\0'	O
;	O
if	O
(	O
stat	struct
(	O
cp	pointer
?	O
local	pointer
:	O
"."	pointer
,	O
&	O
st	struct
)	O
<	O
0	int
)	O
{	O
perror_reply	function
(	O
553	int
,	O
cp	pointer
?	O
local	pointer
:	O
"."	pointer
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
if	O
(	O
cp	pointer
)	O
*	O
cp	pointer
=	O
'/'	O
;	O
free	function
(	O
string	pointer
)	O
;	O
string	pointer
=	O
malloc	function
(	O
strlen	function
(	O
local	pointer
)	O
+	O
5	int
)	O
;	O
if	O
(	O
string	pointer
)	O
{	O
strcpy	function
(	O
string	pointer
,	O
local	pointer
)	O
;	O
cp	pointer
=	O
string	pointer
+	O
strlen	function
(	O
string	pointer
)	O
;	O
*	O
cp	pointer
++	O
=	O
'.'	O
;	O
for	O
(	O
count	int
=	O
1	int
;	O
count	int
<	O
100	int
;	O
count	int
++	O
)	O
{	O
sprintf	function
(	O
cp	pointer
,	O
"%d"	pointer
,	O
count	int
)	O
;	O
if	O
(	O
stat	struct
(	O
string	pointer
,	O
&	O
st	struct
)	O
<	O
0	int
)	O
return	O
string	pointer
;	O
}	O
}	O
reply	function
(	O
452	int
,	O
"Unique file name cannot be created."	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
perror_reply	function
(	O
int	O
code	int
,	O
const	O
char	O
*	O
string	pointer
)	O
{	O
reply	function
(	O
code	int
,	O
"%s: %s."	pointer
,	O
string	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
static	O
char	O
*	O
onefile	array
[	O
]	O
=	O
{	O
""	pointer
,	O
0	int
}	O
;	O
void	O
send_file_list	function
(	O
const	O
char	O
*	O
whichf	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
DIR	struct
*	O
dirp	pointer
=	O
NULL	O
;	O
struct	O
dirent	struct
*	O
dir	pointer
;	O
FILE	struct
*	O
dout	pointer
=	O
NULL	O
;	O
char	O
*	O
*	O
dirlist	pointer
,	O
*	O
dirname	pointer
;	O
int	O
simple	int
=	O
0	int
;	O
int	O
freeglob	int
=	O
0	int
;	O
glob_t	struct
gl	struct
;	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
if	O
(	O
strpbrk	function
(	O
whichf	pointer
,	O
"~{[*?"	pointer
)	O
!=	O
NULL	O
)	O
{	O
int	O
flags	int
=	O
GLOB_NOCHECK	O
;	O
flags	int
|=	O
GLOB_BRACE	O
;	O
flags	int
|=	O
GLOB_TILDE	O
;	O
memset	function
(	O
&	O
gl	struct
,	O
0	int
,	O
sizeof	O
(	O
gl	struct
)	O
)	O
;	O
freeglob	int
=	O
1	int
;	O
if	O
(	O
glob	O
(	O
whichf	pointer
,	O
flags	int
,	O
0	int
,	O
&	O
gl	struct
)	O
)	O
{	O
reply	function
(	O
550	int
,	O
"not found"	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
else	O
if	O
(	O
gl	struct
.	O
gl_pathc	long
==	O
0	int
)	O
{	O
errno	O
=	O
ENOENT	int
;	O
perror_reply	function
(	O
550	int
,	O
whichf	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
dirlist	pointer
=	O
gl	struct
.	O
gl_pathv	pointer
;	O
}	O
else	O
{	O
p	pointer
=	O
strdup	function
(	O
whichf	pointer
)	O
;	O
onefile	array
[	O
0	int
]	O
=	O
p	pointer
;	O
dirlist	pointer
=	O
onefile	array
;	O
simple	int
=	O
1	int
;	O
}	O
if	O
(	O
setjmp	function
(	O
urgcatch	array
)	O
)	O
{	O
transflag	int
=	O
0	int
;	O
goto	O
out	O
;	O
}	O
while	O
(	O
(	O
dirname	pointer
=	O
*	O
dirlist	pointer
++	O
)	O
)	O
{	O
if	O
(	O
stat	struct
(	O
dirname	pointer
,	O
&	O
st	struct
)	O
<	O
0	int
)	O
{	O
if	O
(	O
dirname	pointer
[	O
0	int
]	O
==	O
'-'	O
&&	O
*	O
dirlist	pointer
==	O
NULL	O
&&	O
transflag	int
==	O
0	int
)	O
{	O
retrieve	function
(	O
"/bin/ls %s"	pointer
,	O
dirname	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
perror_reply	function
(	O
550	int
,	O
whichf	pointer
)	O
;	O
if	O
(	O
dout	pointer
!=	O
NULL	O
)	O
{	O
fclose	function
(	O
dout	pointer
)	O
;	O
transflag	int
=	O
0	int
;	O
data	array
=	O
-	O
1	int
;	O
pdata	int
=	O
-	O
1	int
;	O
}	O
goto	O
out	O
;	O
}	O
if	O
(	O
S_ISREG	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
dout	pointer
==	O
NULL	O
)	O
{	O
dout	pointer
=	O
dataconn	function
(	O
"file list"	pointer
,	O
(	O
off_t	long
)	O
-	O
1	int
,	O
"w"	pointer
)	O
;	O
if	O
(	O
dout	pointer
==	O
NULL	O
)	O
goto	O
out	O
;	O
transflag	int
++	O
;	O
}	O
fprintf	function
(	O
dout	pointer
,	O
"%s%s\n"	pointer
,	O
dirname	pointer
,	O
type	enum
==	O
TYPE_A	int
?	O
"\r"	pointer
:	O
""	pointer
)	O
;	O
byte_count	long
+=	O
strlen	function
(	O
dirname	pointer
)	O
+	O
1	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
S_ISDIR	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
continue	O
;	O
dirp	pointer
=	O
opendir	function
(	O
dirname	pointer
)	O
;	O
if	O
(	O
dirp	pointer
==	O
NULL	O
)	O
continue	O
;	O
while	O
(	O
(	O
dir	pointer
=	O
readdir	function
(	O
dirp	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
nbuf	pointer
;	O
if	O
(	O
dir	pointer
->	O
d_name	array
[	O
0	int
]	O
==	O
'.'	O
&&	O
dir	pointer
->	O
d_name	array
[	O
1	int
]	O
==	O
'\0'	O
)	O
continue	O
;	O
if	O
(	O
dir	pointer
->	O
d_name	array
[	O
0	int
]	O
==	O
'.'	O
&&	O
dir	pointer
->	O
d_name	array
[	O
1	int
]	O
==	O
'.'	O
&&	O
dir	pointer
->	O
d_name	array
[	O
2	int
]	O
==	O
'\0'	O
)	O
continue	O
;	O
nbuf	pointer
=	O
alloca	O
(	O
strlen	function
(	O
dirname	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
dir	pointer
->	O
d_name	array
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
nbuf	pointer
,	O
"%s/%s"	pointer
,	O
dirname	pointer
,	O
dir	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
simple	int
||	O
(	O
stat	struct
(	O
nbuf	pointer
,	O
&	O
st	struct
)	O
==	O
0	int
&&	O
S_ISREG	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
)	O
{	O
if	O
(	O
dout	pointer
==	O
NULL	O
)	O
{	O
dout	pointer
=	O
dataconn	function
(	O
"file list"	pointer
,	O
(	O
off_t	long
)	O
-	O
1	int
,	O
"w"	pointer
)	O
;	O
if	O
(	O
dout	pointer
==	O
NULL	O
)	O
goto	O
out	O
;	O
transflag	int
++	O
;	O
}	O
if	O
(	O
nbuf	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
nbuf	pointer
[	O
1	int
]	O
==	O
'/'	O
)	O
fprintf	function
(	O
dout	pointer
,	O
"%s%s\n"	pointer
,	O
&	O
nbuf	pointer
[	O
2	int
]	O
,	O
type	enum
==	O
TYPE_A	int
?	O
"\r"	pointer
:	O
""	pointer
)	O
;	O
else	O
fprintf	function
(	O
dout	pointer
,	O
"%s%s\n"	pointer
,	O
nbuf	pointer
,	O
type	enum
==	O
TYPE_A	int
?	O
"\r"	pointer
:	O
""	pointer
)	O
;	O
byte_count	long
+=	O
strlen	function
(	O
nbuf	pointer
)	O
+	O
1	int
;	O
}	O
}	O
closedir	function
(	O
dirp	pointer
)	O
;	O
}	O
if	O
(	O
dout	pointer
==	O
NULL	O
)	O
reply	function
(	O
550	int
,	O
"No files found."	pointer
)	O
;	O
else	O
if	O
(	O
ferror	function
(	O
dout	pointer
)	O
!=	O
0	int
)	O
perror_reply	function
(	O
550	int
,	O
"Data connection"	pointer
)	O
;	O
else	O
reply	function
(	O
226	int
,	O
"Transfer complete."	pointer
)	O
;	O
transflag	int
=	O
0	int
;	O
if	O
(	O
dout	pointer
!=	O
NULL	O
)	O
fclose	function
(	O
dout	pointer
)	O
;	O
data	array
=	O
-	O
1	int
;	O
pdata	int
=	O
-	O
1	int
;	O
out	O
:	O
free	function
(	O
p	pointer
)	O
;	O
if	O
(	O
freeglob	int
)	O
{	O
freeglob	int
=	O
0	int
;	O
globfree	O
(	O
&	O
gl	struct
)	O
;	O
}	O
}	O
