static	O
int	O
ftsoptions	pointer
=	O
FTS_NOSTAT	int
|	O
FTS_TIGHT_CYCLE_CHECK	int
|	O
FTS_CWDFD	int
|	O
FTS_VERBATIM	int
;	O
static	O
int	O
prev_depth	int
=	O
INT_MIN	O
;	O
static	O
int	O
curr_fd	int
=	O
-	O
1	int
;	O
static	O
bool	bool
find	function
(	O
char	O
*	O
arg	pointer
)	O
__attribute_warn_unused_result__	O
;	O
static	O
bool	bool
process_all_startpoints	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
__attribute_warn_unused_result__	O
;	O
static	O
void	O
left_dir	function
(	O
void	O
)	O
{	O
if	O
(	O
ftsoptions	pointer
&	O
FTS_CWDFD	int
)	O
{	O
if	O
(	O
curr_fd	int
>=	O
0	int
)	O
{	O
close	function
(	O
curr_fd	int
)	O
;	O
curr_fd	int
=	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
}	O
}	O
static	O
void	O
inside_dir	function
(	O
int	O
dir_fd	int
)	O
{	O
if	O
(	O
ftsoptions	pointer
&	O
FTS_CWDFD	int
)	O
{	O
assert	O
(	O
dir_fd	int
==	O
AT_FDCWD	O
||	O
dir_fd	int
>=	O
0	int
)	O
;	O
state	pointer
.	O
cwd_dir_fd	int
=	O
dir_fd	int
;	O
if	O
(	O
curr_fd	int
<	O
0	int
)	O
{	O
if	O
(	O
AT_FDCWD	O
==	O
dir_fd	int
)	O
{	O
curr_fd	int
=	O
AT_FDCWD	O
;	O
}	O
else	O
if	O
(	O
dir_fd	int
>=	O
0	int
)	O
{	O
curr_fd	int
=	O
dup_cloexec	function
(	O
dir_fd	int
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
curr_fd	int
>=	O
0	int
||	O
dir_fd	int
>=	O
0	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
}	O
}	O
static	O
char	O
*	O
get_fts_info_name	function
(	O
int	O
info	int
)	O
{	O
static	O
char	O
buf	pointer
[	O
10	int
]	O
;	O
switch	O
(	O
info	int
)	O
{	O
HANDLECASE	O
(	O
FTS_D	int
)	O
;	O
HANDLECASE	O
(	O
FTS_DC	int
)	O
;	O
HANDLECASE	O
(	O
FTS_DEFAULT	int
)	O
;	O
HANDLECASE	O
(	O
FTS_DNR	int
)	O
;	O
HANDLECASE	O
(	O
FTS_DOT	int
)	O
;	O
HANDLECASE	O
(	O
FTS_DP	int
)	O
;	O
HANDLECASE	O
(	O
FTS_ERR	int
)	O
;	O
HANDLECASE	O
(	O
FTS_F	int
)	O
;	O
HANDLECASE	O
(	O
FTS_INIT	int
)	O
;	O
HANDLECASE	O
(	O
FTS_NS	int
)	O
;	O
HANDLECASE	O
(	O
FTS_NSOK	int
)	O
;	O
HANDLECASE	O
(	O
FTS_SL	int
)	O
;	O
HANDLECASE	O
(	O
FTS_SLNONE	int
)	O
;	O
HANDLECASE	O
(	O
FTS_W	int
)	O
;	O
default	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"[%d]"	pointer
,	O
info	int
)	O
;	O
return	O
buf	pointer
;	O
}	O
}	O
static	O
void	O
visit	function
(	O
FTS	struct
*	O
p	pointer
,	O
FTSENT	struct
*	O
ent	pointer
,	O
struct	O
stat	struct
*	O
pstat	pointer
)	O
{	O
struct	O
predicate	struct
*	O
eval_tree	pointer
;	O
state	pointer
.	O
have_stat	bool
=	O
(	O
ent	pointer
->	O
fts_info	short
!=	O
FTS_NS	int
)	O
&&	O
(	O
ent	pointer
->	O
fts_info	short
!=	O
FTS_NSOK	int
)	O
;	O
state	pointer
.	O
rel_pathname	pointer
=	O
ent	pointer
->	O
fts_accpath	pointer
;	O
state	pointer
.	O
cwd_dir_fd	int
=	O
p	pointer
->	O
fts_cwd_fd	int
;	O
eval_tree	pointer
=	O
get_eval_tree	function
(	O
)	O
;	O
apply_predicate	function
(	O
ent	pointer
->	O
fts_path	pointer
,	O
pstat	pointer
,	O
eval_tree	pointer
)	O
;	O
if	O
(	O
state	pointer
.	O
stop_at_current_level	bool
)	O
{	O
fts_set	function
(	O
p	pointer
,	O
ent	pointer
,	O
FTS_SKIP	int
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
partial_quotearg_n	function
(	O
int	O
n	long
,	O
char	O
*	O
s	enum
,	O
size_t	long
len	long
,	O
enum	O
quoting_style	enum
style	enum
)	O
{	O
if	O
(	O
0	int
==	O
len	long
)	O
{	O
return	O
quotearg_n_style	function
(	O
n	long
,	O
style	enum
,	O
""	pointer
)	O
;	O
}	O
else	O
{	O
char	O
saved	char
;	O
const	O
char	O
*	O
result	pointer
;	O
saved	char
=	O
s	enum
[	O
len	long
]	O
;	O
s	enum
[	O
len	long
]	O
=	O
0	int
;	O
result	pointer
=	O
quotearg_n_style	function
(	O
n	long
,	O
style	enum
,	O
s	enum
)	O
;	O
s	enum
[	O
len	long
]	O
=	O
saved	char
;	O
return	O
result	pointer
;	O
}	O
}	O
static	O
void	O
issue_loop_warning	function
(	O
FTSENT	struct
*	O
ent	pointer
)	O
{	O
if	O
(	O
S_ISLNK	O
(	O
ent	pointer
->	O
fts_statp	array
->	O
st_mode	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"Symbolic link %s is part of a loop in the directory hierarchy; we have already visited the directory to which it points."	pointer
)	O
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
ent	pointer
->	O
fts_path	pointer
)	O
)	O
;	O
}	O
else	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"File system loop detected; "	pointer
"%s is part of the same file system loop as %s."	pointer
)	O
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
ent	pointer
->	O
fts_path	pointer
)	O
,	O
partial_quotearg_n	function
(	O
1	int
,	O
ent	pointer
->	O
fts_cycle	union
->	O
fts_path	pointer
,	O
ent	pointer
->	O
fts_cycle	union
->	O
fts_pathlen	long
,	O
options	struct
.	O
err_quoting_style	enum
)	O
)	O
;	O
}	O
}	O
static	O
bool	bool
symlink_loop	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
stat	struct
stbuf	struct
;	O
const	O
int	O
rv	int
=	O
options	struct
.	O
xstat	pointer
(	O
name	pointer
,	O
&	O
stbuf	struct
)	O
;	O
return	O
(	O
0	int
!=	O
rv	int
)	O
&&	O
(	O
ELOOP	int
==	O
errno	O
)	O
;	O
}	O
static	O
void	O
show_outstanding_execdirs	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugExec	int
)	O
{	O
int	O
seen	int
=	O
0	int
;	O
struct	O
predicate	struct
*	O
p	pointer
;	O
p	pointer
=	O
get_eval_tree	function
(	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"Outstanding execdirs:"	pointer
)	O
;	O
while	O
(	O
p	pointer
)	O
{	O
const	O
char	O
*	O
pfx	pointer
;	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_execdir	function
)	O
)	O
pfx	pointer
=	O
"-execdir"	pointer
;	O
else	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_okdir	function
)	O
)	O
pfx	pointer
=	O
"-okdir"	pointer
;	O
else	O
pfx	pointer
=	O
NULL	O
;	O
if	O
(	O
pfx	pointer
)	O
{	O
size_t	long
i	int
;	O
const	O
struct	O
exec_val	struct
*	O
execp	pointer
=	O
&	O
p	pointer
->	O
args	union
.	O
exec_vec	struct
;	O
++	O
seen	int
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s "	pointer
,	O
pfx	pointer
)	O
;	O
if	O
(	O
execp	pointer
->	O
multiple	bool
)	O
fprintf	function
(	O
fp	pointer
,	O
"multiple "	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%"	pointer
PRIuMAX	O
" args: "	pointer
,	O
(	O
uintmax_t	long
)	O
execp	pointer
->	O
state	pointer
.	O
cmd_argc	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
execp	pointer
->	O
state	pointer
.	O
cmd_argc	long
;	O
++	O
i	int
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s "	pointer
,	O
execp	pointer
->	O
state	pointer
.	O
cmd_argv	pointer
[	O
i	int
]	O
)	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
p	pointer
=	O
p	pointer
->	O
pred_next	pointer
;	O
}	O
if	O
(	O
!	O
seen	int
)	O
fprintf	function
(	O
fp	pointer
,	O
" none\n"	pointer
)	O
;	O
}	O
else	O
{	O
}	O
}	O
static	O
void	O
consider_visiting	function
(	O
FTS	struct
*	O
p	pointer
,	O
FTSENT	struct
*	O
ent	pointer
)	O
{	O
struct	O
stat	struct
statbuf	pointer
;	O
mode_t	int
mode	int
;	O
int	O
ignore	bool
,	O
isdir	int
;	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugSearch	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"consider_visiting (early): %s: "	pointer
"fts_info=%-6s, fts_level=%2d, prev_depth=%d "	pointer
"fts_path=%s, fts_accpath=%s\n"	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
ent	pointer
->	O
fts_path	pointer
)	O
,	O
get_fts_info_name	function
(	O
ent	pointer
->	O
fts_info	short
)	O
,	O
(	O
int	O
)	O
ent	pointer
->	O
fts_level	long
,	O
prev_depth	int
,	O
quotearg_n_style	function
(	O
1	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
ent	pointer
->	O
fts_path	pointer
)	O
,	O
quotearg_n_style	function
(	O
2	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
ent	pointer
->	O
fts_accpath	pointer
)	O
)	O
;	O
if	O
(	O
ent	pointer
->	O
fts_info	short
==	O
FTS_DP	int
)	O
{	O
left_dir	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
ent	pointer
->	O
fts_level	long
>	O
prev_depth	int
||	O
ent	pointer
->	O
fts_level	long
==	O
0	int
)	O
{	O
left_dir	function
(	O
)	O
;	O
}	O
inside_dir	function
(	O
p	pointer
->	O
fts_cwd_fd	int
)	O
;	O
prev_depth	int
=	O
ent	pointer
->	O
fts_level	long
;	O
statbuf	pointer
.	O
st_ino	long
=	O
ent	pointer
->	O
fts_statp	array
->	O
st_ino	long
;	O
if	O
(	O
ent	pointer
->	O
fts_info	short
==	O
FTS_ERR	int
||	O
ent	pointer
->	O
fts_info	short
==	O
FTS_DNR	int
)	O
{	O
nonfatal_target_file_error	function
(	O
ent	pointer
->	O
fts_errno	int
,	O
ent	pointer
->	O
fts_path	pointer
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
ent	pointer
->	O
fts_info	short
==	O
FTS_DC	int
)	O
{	O
issue_loop_warning	function
(	O
ent	pointer
)	O
;	O
error_severity	function
(	O
EXIT_FAILURE	int
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
ent	pointer
->	O
fts_info	short
==	O
FTS_SLNONE	int
)	O
{	O
if	O
(	O
symlink_loop	function
(	O
ent	pointer
->	O
fts_accpath	pointer
)	O
)	O
{	O
nonfatal_target_file_error	function
(	O
ELOOP	int
,	O
ent	pointer
->	O
fts_path	pointer
)	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
ent	pointer
->	O
fts_info	short
==	O
FTS_NS	int
)	O
{	O
if	O
(	O
ent	pointer
->	O
fts_level	long
==	O
0	int
)	O
{	O
nonfatal_target_file_error	function
(	O
ent	pointer
->	O
fts_errno	int
,	O
ent	pointer
->	O
fts_path	pointer
)	O
;	O
return	O
;	O
}	O
else	O
{	O
if	O
(	O
symlink_loop	function
(	O
ent	pointer
->	O
fts_accpath	pointer
)	O
)	O
{	O
nonfatal_target_file_error	function
(	O
ELOOP	int
,	O
ent	pointer
->	O
fts_path	pointer
)	O
;	O
return	O
;	O
}	O
else	O
{	O
nonfatal_target_file_error	function
(	O
ent	pointer
->	O
fts_errno	int
,	O
ent	pointer
->	O
fts_path	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
ent	pointer
->	O
fts_info	short
==	O
FTS_NSOK	int
||	O
ent	pointer
->	O
fts_info	short
==	O
FTS_NS	int
)	O
{	O
assert	O
(	O
!	O
state	pointer
.	O
have_stat	bool
)	O
;	O
assert	O
(	O
ent	pointer
->	O
fts_info	short
==	O
FTS_NSOK	int
||	O
state	pointer
.	O
type	enum
==	O
0	int
)	O
;	O
mode	int
=	O
state	pointer
.	O
type	enum
;	O
}	O
else	O
{	O
state	pointer
.	O
have_stat	bool
=	O
true	int
;	O
state	pointer
.	O
have_type	bool
=	O
true	int
;	O
statbuf	pointer
=	O
*	O
(	O
ent	pointer
->	O
fts_statp	array
)	O
;	O
state	pointer
.	O
type	enum
=	O
mode	int
=	O
statbuf	pointer
.	O
st_mode	int
;	O
if	O
(	O
00000	int
==	O
mode	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"WARNING: file %s appears to have mode 0000"	pointer
)	O
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
ent	pointer
->	O
fts_path	pointer
)	O
)	O
;	O
}	O
}	O
state	pointer
.	O
curdepth	int
=	O
ent	pointer
->	O
fts_level	long
;	O
if	O
(	O
mode	int
)	O
{	O
if	O
(	O
!	O
digest_mode	function
(	O
&	O
mode	int
,	O
ent	pointer
->	O
fts_path	pointer
,	O
ent	pointer
->	O
fts_name	array
,	O
&	O
statbuf	pointer
,	O
0	int
)	O
)	O
return	O
;	O
}	O
ignore	bool
=	O
0	int
;	O
isdir	int
=	O
S_ISDIR	O
(	O
mode	int
)	O
||	O
(	O
FTS_D	int
==	O
ent	pointer
->	O
fts_info	short
)	O
||	O
(	O
FTS_DP	int
==	O
ent	pointer
->	O
fts_info	short
)	O
||	O
(	O
FTS_DC	int
==	O
ent	pointer
->	O
fts_info	short
)	O
;	O
if	O
(	O
isdir	int
&&	O
(	O
ent	pointer
->	O
fts_info	short
==	O
FTS_NSOK	int
)	O
)	O
{	O
fts_set	function
(	O
p	pointer
,	O
ent	pointer
,	O
FTS_AGAIN	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
options	struct
.	O
maxdepth	int
>=	O
0	int
)	O
{	O
if	O
(	O
ent	pointer
->	O
fts_level	long
>=	O
options	struct
.	O
maxdepth	int
)	O
{	O
fts_set	function
(	O
p	pointer
,	O
ent	pointer
,	O
FTS_SKIP	int
)	O
;	O
if	O
(	O
ent	pointer
->	O
fts_level	long
>	O
options	struct
.	O
maxdepth	int
)	O
ignore	bool
=	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
ent	pointer
->	O
fts_info	short
==	O
FTS_D	int
)	O
&&	O
!	O
options	struct
.	O
do_dir_first	bool
)	O
{	O
ignore	bool
=	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
ent	pointer
->	O
fts_info	short
==	O
FTS_DP	int
)	O
&&	O
options	struct
.	O
do_dir_first	bool
)	O
{	O
ignore	bool
=	O
1	int
;	O
}	O
else	O
if	O
(	O
ent	pointer
->	O
fts_level	long
<	O
options	struct
.	O
mindepth	int
)	O
{	O
ignore	bool
=	O
1	int
;	O
}	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugSearch	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"consider_visiting (late): %s: "	pointer
"fts_info=%-6s, isdir=%d ignore=%d have_stat=%d have_type=%d \n"	pointer
,	O
quotearg_n_style	function
(	O
0	int
,	O
options	struct
.	O
err_quoting_style	enum
,	O
ent	pointer
->	O
fts_path	pointer
)	O
,	O
get_fts_info_name	function
(	O
ent	pointer
->	O
fts_info	short
)	O
,	O
isdir	int
,	O
ignore	bool
,	O
state	pointer
.	O
have_stat	bool
,	O
state	pointer
.	O
have_type	bool
)	O
;	O
if	O
(	O
!	O
ignore	bool
)	O
{	O
visit	function
(	O
p	pointer
,	O
ent	pointer
,	O
&	O
statbuf	pointer
)	O
;	O
}	O
if	O
(	O
ent	pointer
->	O
fts_info	short
==	O
FTS_DP	int
)	O
{	O
state	pointer
.	O
stop_at_current_level	bool
=	O
false	int
;	O
}	O
}	O
static	O
bool	bool
find	function
(	O
char	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
arglist	array
[	O
2	int
]	O
;	O
FTS	struct
*	O
p	pointer
;	O
FTSENT	struct
*	O
ent	pointer
;	O
state	pointer
.	O
starting_path_length	int
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
inside_dir	function
(	O
AT_FDCWD	O
)	O
;	O
arglist	array
[	O
0	int
]	O
=	O
arg	pointer
;	O
arglist	array
[	O
1	int
]	O
=	O
NULL	O
;	O
switch	O
(	O
options	struct
.	O
symlink_handling	enum
)	O
{	O
case	O
SYMLINK_ALWAYS_DEREF	int
:	O
ftsoptions	pointer
|=	O
FTS_COMFOLLOW	int
|	O
FTS_LOGICAL	int
;	O
break	O
;	O
case	O
SYMLINK_DEREF_ARGSONLY	int
:	O
ftsoptions	pointer
|=	O
FTS_COMFOLLOW	int
|	O
FTS_PHYSICAL	int
;	O
break	O
;	O
case	O
SYMLINK_NEVER_DEREF	int
:	O
ftsoptions	pointer
|=	O
FTS_PHYSICAL	int
;	O
break	O
;	O
}	O
if	O
(	O
options	struct
.	O
stay_on_filesystem	bool
)	O
ftsoptions	pointer
|=	O
FTS_XDEV	int
;	O
p	pointer
=	O
fts_open	function
(	O
arglist	array
,	O
ftsoptions	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
NULL	O
==	O
p	pointer
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"cannot search %s"	pointer
)	O
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
arg	pointer
)	O
)	O
;	O
error_severity	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
int	O
level	pointer
=	O
INT_MIN	O
;	O
while	O
(	O
(	O
errno	O
=	O
0	int
,	O
ent	pointer
=	O
fts_read	function
(	O
p	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
state	pointer
.	O
execdirs_outstanding	bool
)	O
{	O
if	O
(	O
(	O
int	O
)	O
ent	pointer
->	O
fts_level	long
!=	O
level	pointer
)	O
{	O
show_outstanding_execdirs	function
(	O
stderr	pointer
)	O
;	O
complete_pending_execdirs	function
(	O
)	O
;	O
}	O
}	O
level	pointer
=	O
(	O
int	O
)	O
ent	pointer
->	O
fts_level	long
;	O
state	pointer
.	O
already_issued_stat_error_msg	bool
=	O
false	int
;	O
state	pointer
.	O
have_stat	bool
=	O
false	int
;	O
state	pointer
.	O
have_type	bool
=	O
!	O
!	O
ent	pointer
->	O
fts_statp	array
->	O
st_mode	int
;	O
state	pointer
.	O
type	enum
=	O
state	pointer
.	O
have_type	bool
?	O
ent	pointer
->	O
fts_statp	array
->	O
st_mode	int
:	O
0	int
;	O
consider_visiting	function
(	O
p	pointer
,	O
ent	pointer
)	O
;	O
}	O
if	O
(	O
errno	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"failed to read file names from file system at or below %s"	pointer
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
arg	pointer
)	O
)	O
;	O
error_severity	function
(	O
EXIT_FAILURE	int
)	O
;	O
return	O
false	int
;	O
}	O
if	O
(	O
0	int
!=	O
fts_close	function
(	O
p	pointer
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"failed to restore working directory after searching %s"	pointer
)	O
,	O
arg	pointer
)	O
;	O
error_severity	function
(	O
EXIT_FAILURE	int
)	O
;	O
return	O
false	int
;	O
}	O
p	pointer
=	O
NULL	O
;	O
}	O
return	O
true	int
;	O
}	O
static	O
bool	bool
process_all_startpoints	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
&&	O
!	O
looks_like_expression	function
(	O
argv	array
[	O
i	int
]	O
,	O
true	int
)	O
;	O
i	int
++	O
)	O
{	O
state	pointer
.	O
starting_path_length	int
=	O
strlen	function
(	O
argv	array
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
find	function
(	O
argv	array
[	O
i	int
]	O
)	O
)	O
return	O
false	int
;	O
}	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
char	O
defaultpath	array
[	O
2	int
]	O
=	O
"."	pointer
;	O
return	O
find	function
(	O
defaultpath	array
)	O
;	O
}	O
return	O
true	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	array
)	O
{	O
int	O
end_of_leading_options	int
=	O
0	int
;	O
struct	O
predicate	struct
*	O
eval_tree	pointer
;	O
if	O
(	O
argv	array
[	O
0	int
]	O
)	O
set_program_name	function
(	O
argv	array
[	O
0	int
]	O
)	O
;	O
else	O
set_program_name	function
(	O
"find"	pointer
)	O
;	O
record_initial_cwd	function
(	O
)	O
;	O
state	pointer
.	O
already_issued_stat_error_msg	bool
=	O
false	int
;	O
state	pointer
.	O
exit_status	int
=	O
0	int
;	O
state	pointer
.	O
execdirs_outstanding	bool
=	O
false	int
;	O
state	pointer
.	O
cwd_dir_fd	int
=	O
AT_FDCWD	O
;	O
if	O
(	O
fd_leak_check_is_enabled	function
(	O
)	O
)	O
{	O
remember_non_cloexec_fds	function
(	O
)	O
;	O
}	O
state	pointer
.	O
shared_files	pointer
=	O
sharefile_init	function
(	O
"w"	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
state	pointer
.	O
shared_files	pointer
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"Failed to initialize shared-file hash table"	pointer
)	O
)	O
;	O
}	O
set_option_defaults	function
(	O
&	O
options	struct
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
if	O
(	O
atexit	function
(	O
close_stdout	function
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
_	O
(	O
"The atexit library function failed"	pointer
)	O
)	O
;	O
}	O
end_of_leading_options	int
=	O
process_leading_options	function
(	O
argc	int
,	O
argv	array
)	O
;	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugStat	int
)	O
options	struct
.	O
xstat	pointer
=	O
debug_stat	function
;	O
eval_tree	pointer
=	O
build_expression_tree	function
(	O
argc	int
,	O
argv	array
,	O
end_of_leading_options	int
)	O
;	O
if	O
(	O
!	O
options	struct
.	O
open_nofollow_available	bool
)	O
{	O
}	O
if	O
(	O
process_all_startpoints	function
(	O
argc	int
-	O
end_of_leading_options	int
,	O
argv	array
+	O
end_of_leading_options	int
)	O
)	O
{	O
show_success_rates	function
(	O
eval_tree	pointer
)	O
;	O
cleanup	function
(	O
)	O
;	O
}	O
return	O
state	pointer
.	O
exit_status	int
;	O
}	O
bool	bool
is_fts_enabled	function
(	O
int	O
*	O
fts_options	int
)	O
{	O
*	O
fts_options	int
=	O
ftsoptions	pointer
;	O
return	O
true	int
;	O
}	O
