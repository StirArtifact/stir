static	O
int	O
http_server_port	int
,	O
https_server_port	int
,	O
ocsp_server_port	int
,	O
h2_server_port	int
,	O
keep_tmpfiles	int
,	O
reject_http_connection	int
,	O
reject_https_connection	int
;	O
static	O
wget_vector	struct
*	O
request_urls	pointer
;	O
static	O
wget_test_url_t	struct
*	O
urls	pointer
;	O
static	O
size_t	long
nurls	long
;	O
static	O
char	O
tmpdir	array
[	O
128	int
]	O
;	O
static	O
char	O
server_send_content_length	char
=	O
1	int
;	O
static	O
struct	O
MHD_Daemon	O
*	O
httpdaemon	pointer
,	O
*	O
httpsdaemon	pointer
,	O
*	O
ocspdaemon	pointer
,	O
*	O
h2daemon	pointer
;	O
struct	O
query_string	struct
{	O
wget_buffer	struct
*	O
params	pointer
;	O
int	O
it	int
;	O
}	O
;	O
static	O
char	O
*	O
key_pem	pointer
,	O
*	O
cert_pem	pointer
;	O
enum	O
SERVER_MODE	enum
{	O
HTTP_MODE	int
,	O
HTTPS_MODE	int
,	O
OCSP_MODE	int
,	O
OCSP_STAP_MODE	int
,	O
H2_MODE	int
}	O
;	O
static	O
enum	O
PASS	enum
{	O
HTTP_1_1_PASS	int
,	O
H2_PASS	int
,	O
END_PASS	int
}	O
proto_pass	enum
;	O
static	O
char	O
*	O
_scan_directory	function
(	O
const	O
char	O
*	O
data	pointer
)	O
{	O
return	O
strchr	function
(	O
data	pointer
,	O
'/'	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
_parse_hostname	function
(	O
const	O
char	O
*	O
data	pointer
)	O
{	O
if	O
(	O
data	pointer
)	O
{	O
if	O
(	O
!	O
wget_strncasecmp_ascii	function
(	O
data	pointer
,	O
"http://"	pointer
,	O
7	int
)	O
)	O
{	O
return	O
strchr	function
(	O
data	pointer
+=	O
7	int
,	O
'/'	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strncasecmp_ascii	function
(	O
data	pointer
,	O
"https://"	pointer
,	O
8	int
)	O
)	O
{	O
return	O
strchr	function
(	O
data	pointer
+=	O
8	int
,	O
'/'	O
)	O
;	O
}	O
}	O
return	O
data	pointer
;	O
}	O
static	O
void	O
_replace_space_with_plus	function
(	O
wget_buffer	struct
*	O
buf	pointer
,	O
const	O
char	O
*	O
data	pointer
)	O
{	O
for	O
(	O
;	O
*	O
data	pointer
;	O
data	pointer
++	O
)	O
wget_buffer_memcat	function
(	O
buf	pointer
,	O
*	O
data	pointer
==	O
' '	O
?	O
"+"	pointer
:	O
data	pointer
,	O
1	int
)	O
;	O
}	O
static	O
int	O
_print_query_string	function
(	O
void	O
*	O
cls	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
WGET_GCC_UNUSED	O
,	O
const	O
char	O
*	O
key	int
,	O
const	O
char	O
*	O
value	pointer
)	O
{	O
struct	O
query_string	struct
*	O
query	pointer
=	O
cls	pointer
;	O
if	O
(	O
key	int
&&	O
!	O
query	pointer
->	O
it	int
)	O
{	O
wget_buffer_strcpy	function
(	O
query	pointer
->	O
params	pointer
,	O
"?"	pointer
)	O
;	O
_replace_space_with_plus	function
(	O
query	pointer
->	O
params	pointer
,	O
key	int
)	O
;	O
if	O
(	O
value	pointer
)	O
{	O
wget_buffer_strcat	function
(	O
query	pointer
->	O
params	pointer
,	O
"="	pointer
)	O
;	O
_replace_space_with_plus	function
(	O
query	pointer
->	O
params	pointer
,	O
value	pointer
)	O
;	O
}	O
}	O
if	O
(	O
key	int
&&	O
query	pointer
->	O
it	int
)	O
{	O
wget_buffer_strcat	function
(	O
query	pointer
->	O
params	pointer
,	O
"&"	pointer
)	O
;	O
_replace_space_with_plus	function
(	O
query	pointer
->	O
params	pointer
,	O
key	int
)	O
;	O
if	O
(	O
value	pointer
)	O
{	O
wget_buffer_strcat	function
(	O
query	pointer
->	O
params	pointer
,	O
"="	pointer
)	O
;	O
_replace_space_with_plus	function
(	O
query	pointer
->	O
params	pointer
,	O
value	pointer
)	O
;	O
}	O
}	O
query	pointer
->	O
it	int
++	O
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
_print_header_range	function
(	O
void	O
*	O
cls	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
WGET_GCC_UNUSED	O
,	O
const	O
char	O
*	O
key	int
,	O
const	O
char	O
*	O
value	pointer
)	O
{	O
wget_buffer	struct
*	O
header_range	pointer
=	O
cls	pointer
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
key	int
,	O
MHD_HTTP_HEADER_RANGE	pointer
)	O
)	O
{	O
wget_buffer_strcpy	function
(	O
header_range	pointer
,	O
key	int
)	O
;	O
if	O
(	O
value	pointer
)	O
{	O
wget_buffer_strcat	function
(	O
header_range	pointer
,	O
value	pointer
)	O
;	O
}	O
}	O
return	O
MHD_YES	int
;	O
}	O
struct	O
ResponseContentCallbackParam	struct
{	O
const	O
char	O
*	O
response_data	pointer
;	O
size_t	long
response_size	long
;	O
}	O
;	O
static	O
ssize_t	long
_callback	function
(	O
void	O
*	O
cls	pointer
,	O
uint64_t	long
pos	int
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
buf_size	long
)	O
{	O
size_t	long
size_to_copy	long
;	O
struct	O
ResponseContentCallbackParam	struct
*	O
const	O
param	pointer
=	O
(	O
struct	O
ResponseContentCallbackParam	struct
*	O
)	O
cls	pointer
;	O
if	O
(	O
pos	int
>=	O
param	pointer
->	O
response_size	long
)	O
return	O
MHD_CONTENT_READER_END_OF_STREAM	O
;	O
buf_size	long
=	O
(	O
param	pointer
->	O
response_size	long
/	O
2	int
)	O
+	O
1	int
;	O
if	O
(	O
buf_size	long
<	O
(	O
param	pointer
->	O
response_size	long
-	O
pos	int
)	O
)	O
size_to_copy	long
=	O
buf_size	long
;	O
else	O
size_to_copy	long
=	O
param	pointer
->	O
response_size	long
-	O
pos	int
;	O
memcpy	function
(	O
buf	pointer
,	O
param	pointer
->	O
response_data	pointer
+	O
pos	int
,	O
size_to_copy	long
)	O
;	O
return	O
size_to_copy	long
;	O
}	O
static	O
void	O
_free_callback_param	function
(	O
void	O
*	O
cls	pointer
)	O
{	O
wget_free	pointer
(	O
cls	pointer
)	O
;	O
}	O
static	O
int	O
_answer_to_connection	function
(	O
void	O
*	O
cls	pointer
WGET_GCC_UNUSED	O
,	O
struct	O
MHD_Connection	O
*	O
connection	pointer
,	O
const	O
char	O
*	O
url	pointer
,	O
const	O
char	O
*	O
method	array
,	O
const	O
char	O
*	O
version	int
WGET_GCC_UNUSED	O
,	O
const	O
char	O
*	O
upload_data	pointer
WGET_GCC_UNUSED	O
,	O
size_t	long
*	O
upload_data_size	pointer
WGET_GCC_UNUSED	O
,	O
void	O
*	O
*	O
con_cls	pointer
WGET_GCC_UNUSED	O
)	O
{	O
struct	O
MHD_Response	O
*	O
response	pointer
=	O
NULL	O
;	O
struct	O
query_string	struct
query	pointer
;	O
int	O
ret	int
=	O
0	int
;	O
time_t	long
modified	long
;	O
const	O
char	O
*	O
modified_val	pointer
,	O
*	O
to_bytes_string	pointer
=	O
""	pointer
;	O
ssize_t	long
from_bytes	long
,	O
to_bytes	long
;	O
size_t	long
body_len	long
;	O
char	O
content_len	array
[	O
100	int
]	O
,	O
content_range	array
[	O
100	int
]	O
;	O
bool	bool
https	bool
=	O
!	O
!	O
MHD_get_connection_info	function
(	O
connection	pointer
,	O
MHD_CONNECTION_INFO_PROTOCOL	int
)	O
;	O
query	pointer
.	O
params	pointer
=	O
wget_buffer_alloc	function
(	O
1024	int
)	O
;	O
query	pointer
.	O
it	int
=	O
0	int
;	O
MHD_get_connection_values	function
(	O
connection	pointer
,	O
MHD_GET_ARGUMENT_KIND	int
,	O
&	O
_print_query_string	function
,	O
&	O
query	pointer
)	O
;	O
modified_val	pointer
=	O
MHD_lookup_connection_value	function
(	O
connection	pointer
,	O
MHD_HEADER_KIND	int
,	O
MHD_HTTP_HEADER_IF_MODIFIED_SINCE	pointer
)	O
;	O
modified	long
=	O
0	int
;	O
if	O
(	O
modified_val	pointer
)	O
modified	long
=	O
wget_http_parse_full_date	function
(	O
modified_val	pointer
)	O
;	O
wget_buffer	struct
*	O
header_range	pointer
=	O
wget_buffer_alloc	function
(	O
1024	int
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
method	array
,	O
"GET"	pointer
)	O
)	O
MHD_get_connection_values	function
(	O
connection	pointer
,	O
MHD_HEADER_KIND	int
,	O
&	O
_print_header_range	function
,	O
header_range	pointer
)	O
;	O
from_bytes	long
=	O
to_bytes	long
=	O
body_len	long
=	O
0	int
;	O
if	O
(	O
*	O
header_range	pointer
->	O
data	pointer
)	O
{	O
const	O
char	O
*	O
from_bytes_string	pointer
;	O
const	O
char	O
*	O
range_string	pointer
=	O
strchr	function
(	O
header_range	pointer
->	O
data	pointer
,	O
'='	O
)	O
;	O
to_bytes_string	pointer
=	O
strchr	function
(	O
range_string	pointer
,	O
'-'	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
to_bytes_string	pointer
,	O
"-"	pointer
)	O
)	O
to_bytes	long
=	O
(	O
ssize_t	long
)	O
atoi	function
(	O
to_bytes_string	pointer
+	O
1	int
)	O
;	O
from_bytes_string	pointer
=	O
wget_strmemdup	function
(	O
range_string	pointer
,	O
to_bytes_string	pointer
-	O
range_string	pointer
)	O
;	O
from_bytes	long
=	O
(	O
ssize_t	long
)	O
atoi	function
(	O
from_bytes_string	pointer
+	O
1	int
)	O
;	O
wget_xfree	O
(	O
from_bytes_string	pointer
)	O
;	O
}	O
wget_buffer	struct
*	O
url_full	pointer
=	O
wget_buffer_alloc	function
(	O
1024	int
)	O
;	O
wget_buffer_strcpy	function
(	O
url_full	pointer
,	O
url	pointer
)	O
;	O
if	O
(	O
query	pointer
.	O
params	pointer
->	O
data	pointer
)	O
wget_buffer_strcat	function
(	O
url_full	pointer
,	O
query	pointer
.	O
params	pointer
->	O
data	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
query	pointer
.	O
params	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
url_full	pointer
->	O
data	pointer
,	O
"/"	pointer
)	O
)	O
wget_buffer_strcat	function
(	O
url_full	pointer
,	O
"index.html"	pointer
)	O
;	O
unsigned	O
int	O
found	int
=	O
0	int
,	O
chunked	int
=	O
0	int
;	O
for	O
(	O
unsigned	O
it1	int
=	O
0	int
;	O
it1	int
<	O
nurls	long
&&	O
!	O
found	int
;	O
it1	int
++	O
)	O
{	O
if	O
(	O
urls	pointer
[	O
it1	int
]	O
.	O
http_only	bool
&&	O
https	bool
)	O
continue	O
;	O
if	O
(	O
urls	pointer
[	O
it1	int
]	O
.	O
https_only	bool
&&	O
!	O
https	bool
)	O
continue	O
;	O
const	O
char	O
*	O
dir	array
=	O
_scan_directory	function
(	O
url_full	pointer
->	O
data	pointer
+	O
1	int
)	O
;	O
if	O
(	O
dir	array
&&	O
!	O
strcmp	function
(	O
dir	array
,	O
"/"	pointer
)	O
)	O
wget_buffer_strcat	function
(	O
url_full	pointer
,	O
"index.html"	pointer
)	O
;	O
const	O
char	O
*	O
host	pointer
=	O
_parse_hostname	function
(	O
url_full	pointer
->	O
data	pointer
)	O
;	O
if	O
(	O
host	pointer
&&	O
!	O
strcmp	function
(	O
host	pointer
,	O
"/"	pointer
)	O
)	O
wget_buffer_strcat	function
(	O
url_full	pointer
,	O
"index.html"	pointer
)	O
;	O
wget_buffer	struct
*	O
url_iri	pointer
=	O
wget_buffer_alloc	function
(	O
1024	int
)	O
;	O
wget_buffer_strcpy	function
(	O
url_iri	pointer
,	O
urls	pointer
[	O
it1	int
]	O
.	O
name	pointer
)	O
;	O
MHD_http_unescape	function
(	O
url_iri	pointer
->	O
data	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
_parse_hostname	function
(	O
url_full	pointer
->	O
data	pointer
)	O
,	O
_parse_hostname	function
(	O
url_iri	pointer
->	O
data	pointer
)	O
)	O
)	O
{	O
size_t	long
body_length	long
=	O
urls	pointer
[	O
it1	int
]	O
.	O
body_len	long
?	O
urls	pointer
[	O
it1	int
]	O
.	O
body_len	long
:	O
(	O
urls	pointer
[	O
it1	int
]	O
.	O
body	pointer
?	O
strlen	function
(	O
urls	pointer
[	O
it1	int
]	O
.	O
body	pointer
)	O
:	O
0	int
)	O
;	O
int	O
bad_request	int
=	O
0	int
;	O
for	O
(	O
unsigned	O
it2	int
=	O
0	int
;	O
urls	pointer
[	O
it1	int
]	O
.	O
expected_req_headers	array
[	O
it2	int
]	O
;	O
it2	int
++	O
)	O
{	O
const	O
char	O
*	O
header	pointer
=	O
urls	pointer
[	O
it1	int
]	O
.	O
expected_req_headers	array
[	O
it2	int
]	O
;	O
if	O
(	O
header	pointer
)	O
{	O
const	O
char	O
*	O
header_value	pointer
=	O
strchr	function
(	O
header	pointer
,	O
':'	O
)	O
;	O
const	O
char	O
*	O
header_key	pointer
=	O
wget_strmemdup	function
(	O
header	pointer
,	O
header_value	pointer
-	O
header	pointer
)	O
;	O
const	O
char	O
*	O
got_val	pointer
=	O
MHD_lookup_connection_value	function
(	O
connection	pointer
,	O
MHD_HEADER_KIND	int
,	O
header_key	pointer
)	O
;	O
if	O
(	O
!	O
got_val	pointer
||	O
strcmp	function
(	O
got_val	pointer
,	O
header_value	pointer
+	O
2	int
)	O
)	O
{	O
bad_request	int
=	O
1	int
;	O
wget_xfree	O
(	O
header_key	pointer
)	O
;	O
break	O
;	O
}	O
wget_xfree	O
(	O
header_key	pointer
)	O
;	O
}	O
}	O
for	O
(	O
unsigned	O
it2	int
=	O
0	int
;	O
urls	pointer
[	O
it1	int
]	O
.	O
unexpected_req_headers	array
[	O
it2	int
]	O
&&	O
!	O
bad_request	int
;	O
it2	int
++	O
)	O
{	O
const	O
char	O
*	O
header_key	pointer
=	O
urls	pointer
[	O
it1	int
]	O
.	O
unexpected_req_headers	array
[	O
it2	int
]	O
;	O
const	O
char	O
*	O
got_val	pointer
=	O
MHD_lookup_connection_value	function
(	O
connection	pointer
,	O
MHD_HEADER_KIND	int
,	O
header_key	pointer
)	O
;	O
if	O
(	O
got_val	pointer
)	O
{	O
bad_request	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
bad_request	int
)	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
0	int
,	O
(	O
void	O
*	O
)	O
""	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_BAD_REQUEST	int
,	O
response	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
url_iri	pointer
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
wget_strcmp	function
(	O
urls	pointer
[	O
it1	int
]	O
.	O
name	pointer
+	O
3	int
,	O
"bad.txt"	pointer
)	O
)	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
body_length	long
,	O
(	O
void	O
*	O
)	O
urls	pointer
[	O
it1	int
]	O
.	O
body	pointer
,	O
MHD_RESPMEM_MUST_COPY	int
)	O
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_OK	int
,	O
response	pointer
)	O
;	O
MHD_add_response_header	function
(	O
response	pointer
,	O
"Transfer-Encoding"	pointer
,	O
"chunked"	pointer
)	O
;	O
MHD_add_response_header	function
(	O
response	pointer
,	O
"Connection"	pointer
,	O
"close"	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
url_iri	pointer
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
for	O
(	O
int	O
it2	int
=	O
0	int
;	O
urls	pointer
[	O
it1	int
]	O
.	O
headers	pointer
[	O
it2	int
]	O
;	O
it2	int
++	O
)	O
{	O
const	O
char	O
*	O
header	pointer
=	O
urls	pointer
[	O
it1	int
]	O
.	O
headers	pointer
[	O
it2	int
]	O
;	O
if	O
(	O
header	pointer
)	O
{	O
const	O
char	O
*	O
header_value	pointer
=	O
strchr	function
(	O
header	pointer
,	O
':'	O
)	O
;	O
const	O
char	O
*	O
header_key	pointer
=	O
wget_strmemdup	function
(	O
header	pointer
,	O
header_value	pointer
-	O
header	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
header_key	pointer
,	O
"Transfer-Encoding"	pointer
)	O
&&	O
!	O
strcmp	function
(	O
header_value	pointer
+	O
2	int
,	O
"chunked"	pointer
)	O
)	O
chunked	int
=	O
1	int
;	O
wget_xfree	O
(	O
header_key	pointer
)	O
;	O
}	O
}	O
if	O
(	O
chunked	int
==	O
1	int
)	O
{	O
struct	O
ResponseContentCallbackParam	struct
*	O
callback_param	pointer
=	O
wget_malloc	function
(	O
sizeof	O
(	O
struct	O
ResponseContentCallbackParam	struct
)	O
)	O
;	O
callback_param	pointer
->	O
response_data	pointer
=	O
urls	pointer
[	O
it1	int
]	O
.	O
body	pointer
;	O
callback_param	pointer
->	O
response_size	long
=	O
body_length	long
;	O
response	pointer
=	O
MHD_create_response_from_callback	function
(	O
MHD_SIZE_UNKNOWN	O
,	O
1024	int
,	O
&	O
_callback	function
,	O
callback_param	pointer
,	O
&	O
_free_callback_param	function
)	O
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_OK	int
,	O
response	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
url_iri	pointer
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
atoi	function
(	O
urls	pointer
[	O
it1	int
]	O
.	O
code	short
)	O
/	O
100	int
==	O
3	int
)	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
0	int
,	O
(	O
void	O
*	O
)	O
""	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
for	O
(	O
unsigned	O
it2	int
=	O
0	int
;	O
urls	pointer
[	O
it1	int
]	O
.	O
headers	pointer
[	O
it2	int
]	O
;	O
it2	int
++	O
)	O
{	O
const	O
char	O
*	O
header	pointer
=	O
urls	pointer
[	O
it1	int
]	O
.	O
headers	pointer
[	O
it2	int
]	O
;	O
if	O
(	O
header	pointer
)	O
{	O
const	O
char	O
*	O
header_value	pointer
=	O
strchr	function
(	O
header	pointer
,	O
':'	O
)	O
;	O
const	O
char	O
*	O
header_key	pointer
=	O
wget_strmemdup	function
(	O
header	pointer
,	O
header_value	pointer
-	O
header	pointer
)	O
;	O
MHD_add_response_header	function
(	O
response	pointer
,	O
header_key	pointer
,	O
header_value	pointer
+	O
2	int
)	O
;	O
wget_xfree	O
(	O
header_key	pointer
)	O
;	O
}	O
}	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_FOUND	int
,	O
response	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
url_iri	pointer
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
atoi	function
(	O
urls	pointer
[	O
it1	int
]	O
.	O
code	short
)	O
!=	O
200	int
)	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
body_length	long
,	O
(	O
void	O
*	O
)	O
urls	pointer
[	O
it1	int
]	O
.	O
body	pointer
,	O
MHD_RESPMEM_MUST_COPY	int
)	O
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_NOT_FOUND	int
,	O
response	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
url_iri	pointer
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
wget_strcmp	function
(	O
urls	pointer
[	O
it1	int
]	O
.	O
auth_method	pointer
,	O
"Basic"	pointer
)	O
)	O
{	O
char	O
*	O
pass	pointer
=	O
NULL	O
;	O
char	O
*	O
user	pointer
=	O
MHD_basic_auth_get_username_password	function
(	O
connection	pointer
,	O
&	O
pass	pointer
)	O
;	O
if	O
(	O
(	O
user	pointer
==	O
NULL	O
&&	O
pass	pointer
==	O
NULL	O
)	O
||	O
wget_strcmp	function
(	O
user	pointer
,	O
urls	pointer
[	O
it1	int
]	O
.	O
auth_username	pointer
)	O
||	O
wget_strcmp	function
(	O
pass	pointer
,	O
urls	pointer
[	O
it1	int
]	O
.	O
auth_password	pointer
)	O
)	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
strlen	function
(	O
"DENIED"	pointer
)	O
,	O
(	O
void	O
*	O
)	O
"DENIED"	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_basic_auth_fail_response	function
(	O
connection	pointer
,	O
"basic@example.com"	pointer
,	O
response	pointer
)	O
;	O
MHD_free	function
(	O
user	pointer
)	O
;	O
MHD_free	function
(	O
pass	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
url_iri	pointer
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
MHD_free	function
(	O
user	pointer
)	O
;	O
MHD_free	function
(	O
pass	pointer
)	O
;	O
}	O
if	O
(	O
!	O
wget_strcmp	function
(	O
urls	pointer
[	O
it1	int
]	O
.	O
auth_method	pointer
,	O
"Digest"	pointer
)	O
)	O
{	O
const	O
char	O
*	O
realm	pointer
=	O
"digest@example.com"	pointer
;	O
char	O
*	O
user	pointer
=	O
MHD_digest_auth_get_username	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
wget_strcmp	function
(	O
user	pointer
,	O
urls	pointer
[	O
it1	int
]	O
.	O
auth_username	pointer
)	O
)	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
strlen	function
(	O
"DENIED"	pointer
)	O
,	O
(	O
void	O
*	O
)	O
"DENIED"	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_auth_fail_response	function
(	O
connection	pointer
,	O
realm	pointer
,	O
TEST_OPAQUE_STR	pointer
,	O
response	pointer
,	O
MHD_NO	int
)	O
;	O
MHD_free	function
(	O
user	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
url_iri	pointer
)	O
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
ret	int
=	O
MHD_digest_auth_check	function
(	O
connection	pointer
,	O
realm	pointer
,	O
user	pointer
,	O
urls	pointer
[	O
it1	int
]	O
.	O
auth_password	pointer
,	O
300	int
)	O
;	O
MHD_free	function
(	O
user	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
==	O
MHD_INVALID_NONCE	O
)	O
||	O
(	O
ret	int
==	O
MHD_NO	int
)	O
)	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
strlen	function
(	O
"DENIED"	pointer
)	O
,	O
(	O
void	O
*	O
)	O
"DENIED"	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
if	O
(	O
response	pointer
)	O
{	O
ret	int
=	O
MHD_queue_auth_fail_response	function
(	O
connection	pointer
,	O
realm	pointer
,	O
TEST_OPAQUE_STR	pointer
,	O
response	pointer
,	O
(	O
ret	int
==	O
MHD_INVALID_NONCE	O
)	O
?	O
MHD_YES	int
:	O
MHD_NO	int
)	O
;	O
found	int
=	O
1	int
;	O
}	O
else	O
ret	int
=	O
MHD_NO	int
;	O
wget_buffer_free	function
(	O
&	O
url_iri	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
modified	long
&&	O
urls	pointer
[	O
it1	int
]	O
.	O
modified	long
<=	O
modified	long
)	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
0	int
,	O
(	O
void	O
*	O
)	O
""	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_NOT_MODIFIED	int
,	O
response	pointer
)	O
;	O
}	O
else	O
if	O
(	O
*	O
header_range	pointer
->	O
data	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
to_bytes_string	pointer
,	O
"-"	pointer
)	O
)	O
to_bytes	long
=	O
body_length	long
-	O
1	int
;	O
body_len	long
=	O
to_bytes	long
-	O
from_bytes	long
+	O
1	int
;	O
if	O
(	O
from_bytes	long
>	O
to_bytes	long
||	O
from_bytes	long
>=	O
(	O
int	O
)	O
body_length	long
)	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
0	int
,	O
(	O
void	O
*	O
)	O
""	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_RANGE_NOT_SATISFIABLE	int
,	O
response	pointer
)	O
;	O
}	O
else	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
body_len	long
,	O
(	O
void	O
*	O
)	O
(	O
urls	pointer
[	O
it1	int
]	O
.	O
body	pointer
+	O
from_bytes	long
)	O
,	O
MHD_RESPMEM_MUST_COPY	int
)	O
;	O
MHD_add_response_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_ACCEPT_RANGES	pointer
,	O
"bytes"	pointer
)	O
;	O
wget_snprintf	function
(	O
content_range	array
,	O
sizeof	O
(	O
content_range	array
)	O
,	O
"%zd-%zd/%zu"	pointer
,	O
from_bytes	long
,	O
to_bytes	long
,	O
body_len	long
)	O
;	O
MHD_add_response_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_CONTENT_RANGE	pointer
,	O
content_range	array
)	O
;	O
wget_snprintf	function
(	O
content_len	array
,	O
sizeof	O
(	O
content_len	array
)	O
,	O
"%zu"	pointer
,	O
body_len	long
)	O
;	O
MHD_add_response_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_CONTENT_LENGTH	pointer
,	O
content_len	array
)	O
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_PARTIAL_CONTENT	int
,	O
response	pointer
)	O
;	O
}	O
}	O
else	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
body_length	long
,	O
(	O
void	O
*	O
)	O
urls	pointer
[	O
it1	int
]	O
.	O
body	pointer
,	O
MHD_RESPMEM_MUST_COPY	int
)	O
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_OK	int
,	O
response	pointer
)	O
;	O
}	O
if	O
(	O
*	O
urls	pointer
[	O
it1	int
]	O
.	O
headers	pointer
)	O
{	O
for	O
(	O
unsigned	O
int	O
it2	int
=	O
0	int
;	O
urls	pointer
[	O
it1	int
]	O
.	O
headers	pointer
[	O
it2	int
]	O
!=	O
NULL	O
;	O
it2	int
++	O
)	O
{	O
const	O
char	O
*	O
header	pointer
=	O
urls	pointer
[	O
it1	int
]	O
.	O
headers	pointer
[	O
it2	int
]	O
;	O
if	O
(	O
header	pointer
)	O
{	O
const	O
char	O
*	O
header_value	pointer
=	O
strchr	function
(	O
header	pointer
,	O
':'	O
)	O
;	O
const	O
char	O
*	O
header_key	pointer
=	O
wget_strmemdup	function
(	O
header	pointer
,	O
header_value	pointer
-	O
header	pointer
)	O
;	O
MHD_add_response_header	function
(	O
response	pointer
,	O
header_key	pointer
,	O
header_value	pointer
+	O
2	int
)	O
;	O
wget_xfree	O
(	O
header_key	pointer
)	O
;	O
}	O
}	O
}	O
found	int
=	O
1	int
;	O
}	O
wget_buffer_free	function
(	O
&	O
url_iri	pointer
)	O
;	O
}	O
if	O
(	O
!	O
found	int
)	O
{	O
response	pointer
=	O
MHD_create_response_from_buffer	function
(	O
0	int
,	O
(	O
void	O
*	O
)	O
""	pointer
,	O
MHD_RESPMEM_PERSISTENT	int
)	O
;	O
ret	int
=	O
MHD_queue_response	function
(	O
connection	pointer
,	O
MHD_HTTP_NOT_FOUND	int
,	O
response	pointer
)	O
;	O
}	O
wget_buffer_free	function
(	O
&	O
url_full	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
header_range	pointer
)	O
;	O
char	O
server_version	array
[	O
50	int
]	O
;	O
wget_snprintf	function
(	O
server_version	array
,	O
sizeof	O
(	O
server_version	array
)	O
,	O
"Libmicrohttpd/%08x"	pointer
,	O
(	O
unsigned	O
int	O
)	O
MHD_VERSION	int
)	O
;	O
MHD_add_response_header	function
(	O
response	pointer
,	O
"Server"	pointer
,	O
server_version	array
)	O
;	O
MHD_destroy_response	function
(	O
response	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
void	O
_http_server_stop	function
(	O
void	O
)	O
{	O
MHD_stop_daemon	function
(	O
httpdaemon	pointer
)	O
;	O
MHD_stop_daemon	function
(	O
httpsdaemon	pointer
)	O
;	O
MHD_stop_daemon	function
(	O
ocspdaemon	pointer
)	O
;	O
MHD_stop_daemon	function
(	O
h2daemon	pointer
)	O
;	O
wget_xfree	O
(	O
key_pem	pointer
)	O
;	O
wget_xfree	O
(	O
cert_pem	pointer
)	O
;	O
}	O
static	O
int	O
_check_to_accept	function
(	O
void	O
*	O
cls	pointer
,	O
WGET_GCC_UNUSED	O
const	O
struct	O
sockaddr	struct
*	O
addr	pointer
,	O
WGET_GCC_UNUSED	O
socklen_t	int
addrlen	int
)	O
{	O
int	O
server_mode	int
=	O
(	O
int	O
)	O
(	O
ptrdiff_t	long
)	O
cls	pointer
;	O
if	O
(	O
server_mode	int
==	O
HTTP_MODE	int
)	O
return	O
reject_http_connection	int
?	O
MHD_NO	int
:	O
MHD_YES	int
;	O
return	O
reject_https_connection	int
?	O
MHD_NO	int
:	O
MHD_YES	int
;	O
}	O
static	O
int	O
_http_server_start	function
(	O
int	O
SERVER_MODE	enum
)	O
{	O
uint16_t	short
port_num	short
=	O
0	int
;	O
if	O
(	O
SERVER_MODE	enum
==	O
HTTP_MODE	int
)	O
{	O
static	O
char	O
rnd	array
[	O
8	int
]	O
=	O
"realrnd"	pointer
;	O
httpdaemon	pointer
=	O
MHD_start_daemon	function
(	O
MHD_USE_SELECT_INTERNALLY	int
,	O
port_num	short
,	O
_check_to_accept	function
,	O
(	O
void	O
*	O
)	O
(	O
ptrdiff_t	long
)	O
SERVER_MODE	enum
,	O
&	O
_answer_to_connection	function
,	O
NULL	O
,	O
MHD_OPTION_DIGEST_AUTH_RANDOM	int
,	O
sizeof	O
(	O
rnd	array
)	O
,	O
rnd	array
,	O
MHD_OPTION_NONCE_NC_SIZE	int
,	O
300	int
,	O
MHD_OPTION_END	int
)	O
;	O
if	O
(	O
!	O
httpdaemon	pointer
)	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
SERVER_MODE	enum
==	O
HTTPS_MODE	int
||	O
SERVER_MODE	enum
==	O
H2_MODE	int
)	O
{	O
size_t	long
size	pointer
;	O
if	O
(	O
!	O
ocspdaemon	pointer
)	O
{	O
key_pem	pointer
=	O
wget_read_file	function
(	O
SRCDIR	O
"/certs/x509-server-key.pem"	pointer
,	O
&	O
size	pointer
)	O
;	O
cert_pem	pointer
=	O
wget_read_file	function
(	O
SRCDIR	O
"/certs/x509-server-cert.pem"	pointer
,	O
&	O
size	pointer
)	O
;	O
if	O
(	O
(	O
key_pem	pointer
==	O
NULL	O
)	O
||	O
(	O
cert_pem	pointer
==	O
NULL	O
)	O
)	O
{	O
wget_error_printf	function
(	O
_	O
(	O
"The key/certificate files could not be read.\n"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
SERVER_MODE	enum
==	O
HTTPS_MODE	int
)	O
{	O
httpsdaemon	pointer
=	O
MHD_start_daemon	function
(	O
MHD_USE_SELECT_INTERNALLY	int
|	O
MHD_USE_TLS	int
|	O
MHD_USE_POST_HANDSHAKE_AUTH_SUPPORT	int
,	O
port_num	short
,	O
_check_to_accept	function
,	O
(	O
void	O
*	O
)	O
(	O
ptrdiff_t	long
)	O
SERVER_MODE	enum
,	O
&	O
_answer_to_connection	function
,	O
NULL	O
,	O
MHD_OPTION_HTTPS_MEM_KEY	int
,	O
key_pem	pointer
,	O
MHD_OPTION_HTTPS_MEM_CERT	int
,	O
cert_pem	pointer
,	O
MHD_OPTION_CONNECTION_MEMORY_LIMIT	int
,	O
(	O
size_t	long
)	O
1	int
*	O
1024	int
*	O
1024	int
,	O
MHD_OPTION_END	int
)	O
;	O
if	O
(	O
!	O
httpsdaemon	pointer
)	O
{	O
wget_error_printf	function
(	O
_	O
(	O
"Cannot start the HTTPS server.\n"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
h2daemon	pointer
)	O
{	O
wget_error_printf	function
(	O
_	O
(	O
"Cannot start the h2 server.\n"	pointer
)	O
)	O
;	O
wget_error_printf	function
(	O
_	O
(	O
"HTTP/2 support for MHD not found.\n"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
SERVER_MODE	enum
==	O
OCSP_MODE	int
)	O
{	O
if	O
(	O
!	O
ocspdaemon	pointer
)	O
return	O
1	int
;	O
}	O
if	O
(	O
0	int
)	O
{	O
}	O
else	O
if	O
(	O
MHD_NO	int
!=	O
MHD_is_feature_supported	function
(	O
MHD_FEATURE_AUTODETECT_BIND_PORT	int
)	O
)	O
{	O
const	O
union	O
MHD_DaemonInfo	union
*	O
dinfo	pointer
=	O
NULL	O
;	O
if	O
(	O
SERVER_MODE	enum
==	O
HTTP_MODE	int
)	O
dinfo	pointer
=	O
MHD_get_daemon_info	function
(	O
httpdaemon	pointer
,	O
MHD_DAEMON_INFO_BIND_PORT	int
)	O
;	O
else	O
if	O
(	O
SERVER_MODE	enum
==	O
HTTPS_MODE	int
||	O
SERVER_MODE	enum
==	O
OCSP_STAP_MODE	int
)	O
dinfo	pointer
=	O
MHD_get_daemon_info	function
(	O
httpsdaemon	pointer
,	O
MHD_DAEMON_INFO_BIND_PORT	int
)	O
;	O
if	O
(	O
!	O
dinfo	pointer
||	O
dinfo	pointer
->	O
port	short
==	O
0	int
)	O
return	O
1	int
;	O
port_num	short
=	O
dinfo	pointer
->	O
port	short
;	O
if	O
(	O
SERVER_MODE	enum
==	O
HTTP_MODE	int
)	O
http_server_port	int
=	O
port_num	short
;	O
else	O
if	O
(	O
SERVER_MODE	enum
==	O
HTTPS_MODE	int
||	O
SERVER_MODE	enum
==	O
OCSP_STAP_MODE	int
)	O
https_server_port	int
=	O
port_num	short
;	O
}	O
else	O
{	O
const	O
union	O
MHD_DaemonInfo	union
*	O
dinfo	pointer
=	O
NULL	O
;	O
int	O
sock_fd	int
;	O
if	O
(	O
SERVER_MODE	enum
==	O
HTTP_MODE	int
)	O
dinfo	pointer
=	O
MHD_get_daemon_info	function
(	O
httpdaemon	pointer
,	O
MHD_DAEMON_INFO_LISTEN_FD	int
)	O
;	O
else	O
if	O
(	O
SERVER_MODE	enum
==	O
HTTPS_MODE	int
||	O
SERVER_MODE	enum
==	O
OCSP_STAP_MODE	int
)	O
dinfo	pointer
=	O
MHD_get_daemon_info	function
(	O
httpsdaemon	pointer
,	O
MHD_DAEMON_INFO_LISTEN_FD	int
)	O
;	O
if	O
(	O
!	O
dinfo	pointer
)	O
return	O
1	int
;	O
sock_fd	int
=	O
dinfo	pointer
->	O
listen_fd	int
;	O
struct	O
sockaddr_storage	struct
addr_store	struct
;	O
struct	O
sockaddr	struct
*	O
addr	pointer
=	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
addr_store	struct
;	O
socklen_t	int
addr_len	int
=	O
sizeof	O
(	O
addr_store	struct
)	O
;	O
if	O
(	O
getsockname	function
(	O
sock_fd	int
,	O
addr	pointer
,	O
&	O
addr_len	int
)	O
==	O
0	int
)	O
{	O
char	O
s_port	int
[	O
NI_MAXSERV	int
]	O
;	O
if	O
(	O
getnameinfo	function
(	O
addr	pointer
,	O
addr_len	int
,	O
NULL	O
,	O
0	int
,	O
s_port	int
,	O
sizeof	O
(	O
s_port	int
)	O
,	O
NI_NUMERICSERV	int
)	O
==	O
0	int
)	O
{	O
port_num	short
=	O
(	O
uint16_t	short
)	O
atoi	function
(	O
s_port	int
)	O
;	O
if	O
(	O
SERVER_MODE	enum
==	O
HTTP_MODE	int
)	O
http_server_port	int
=	O
port_num	short
;	O
else	O
if	O
(	O
SERVER_MODE	enum
==	O
HTTPS_MODE	int
||	O
SERVER_MODE	enum
==	O
OCSP_STAP_MODE	int
)	O
https_server_port	int
=	O
port_num	short
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
_remove_directory	function
(	O
const	O
char	O
*	O
dirname	pointer
)	O
;	O
static	O
void	O
_empty_directory	function
(	O
const	O
char	O
*	O
dirname	pointer
)	O
{	O
DIR	struct
*	O
dir	array
;	O
size_t	long
dirlen	long
=	O
strlen	function
(	O
dirname	pointer
)	O
;	O
if	O
(	O
(	O
dir	array
=	O
opendir	function
(	O
dirname	pointer
)	O
)	O
)	O
{	O
struct	O
dirent	struct
*	O
dp	pointer
;	O
while	O
(	O
(	O
dp	pointer
=	O
readdir	function
(	O
dir	array
)	O
)	O
)	O
{	O
if	O
(	O
*	O
dp	pointer
->	O
d_name	array
==	O
'.'	O
&&	O
(	O
dp	pointer
->	O
d_name	array
[	O
1	int
]	O
==	O
0	int
||	O
(	O
dp	pointer
->	O
d_name	array
[	O
1	int
]	O
==	O
'.'	O
&&	O
dp	pointer
->	O
d_name	array
[	O
2	int
]	O
==	O
0	int
)	O
)	O
)	O
continue	O
;	O
char	O
fname	pointer
[	O
dirlen	long
+	O
1	int
+	O
strlen	function
(	O
dp	pointer
->	O
d_name	array
)	O
+	O
1	int
]	O
;	O
wget_snprintf	function
(	O
fname	pointer
,	O
sizeof	O
(	O
fname	pointer
)	O
,	O
"%s/%s"	pointer
,	O
dirname	pointer
,	O
dp	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
unlink	function
(	O
fname	pointer
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EISDIR	int
||	O
errno	O
==	O
EPERM	int
||	O
errno	O
==	O
EACCES	int
)	O
_remove_directory	function
(	O
fname	pointer
)	O
;	O
else	O
wget_error_printf	function
(	O
_	O
(	O
"Failed to unlink %s (%d)\n"	pointer
)	O
,	O
fname	pointer
,	O
errno	O
)	O
;	O
}	O
}	O
closedir	function
(	O
dir	array
)	O
;	O
wget_debug_printf	function
(	O
"Removed test directory '%s'\n"	pointer
,	O
dirname	pointer
)	O
;	O
}	O
else	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
wget_error_printf	function
(	O
_	O
(	O
"Failed to opendir %s (%d)\n"	pointer
)	O
,	O
dirname	pointer
,	O
errno	O
)	O
;	O
}	O
static	O
void	O
_remove_directory	function
(	O
const	O
char	O
*	O
dirname	pointer
)	O
{	O
_empty_directory	function
(	O
dirname	pointer
)	O
;	O
if	O
(	O
rmdir	function
(	O
dirname	pointer
)	O
==	O
-	O
1	int
&&	O
errno	O
!=	O
ENOENT	int
)	O
wget_error_printf	function
(	O
_	O
(	O
"Failed to rmdir %s (%d)\n"	pointer
)	O
,	O
dirname	pointer
,	O
errno	O
)	O
;	O
}	O
void	O
wget_test_stop_server	function
(	O
void	O
)	O
{	O
wget_vector_free	function
(	O
&	O
request_urls	pointer
)	O
;	O
for	O
(	O
wget_test_url_t	struct
*	O
url	pointer
=	O
urls	pointer
;	O
url	pointer
<	O
urls	pointer
+	O
nurls	long
;	O
url	pointer
++	O
)	O
{	O
if	O
(	O
url	pointer
->	O
body_original	pointer
)	O
{	O
wget_xfree	O
(	O
url	pointer
->	O
body	pointer
)	O
;	O
url	pointer
->	O
body_original	pointer
=	O
NULL	O
;	O
}	O
for	O
(	O
size_t	long
it	int
=	O
0	int
;	O
it	int
<	O
countof	O
(	O
url	pointer
->	O
headers	pointer
)	O
;	O
it	int
++	O
)	O
{	O
if	O
(	O
url	pointer
->	O
headers_original	array
[	O
it	int
]	O
)	O
{	O
wget_xfree	O
(	O
url	pointer
->	O
headers	pointer
[	O
it	int
]	O
)	O
;	O
url	pointer
->	O
headers_original	array
[	O
it	int
]	O
=	O
NULL	O
;	O
}	O
}	O
}	O
if	O
(	O
chdir	function
(	O
".."	pointer
)	O
!=	O
0	int
)	O
wget_error_printf	function
(	O
_	O
(	O
"Failed to chdir ..\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
keep_tmpfiles	int
)	O
_remove_directory	function
(	O
tmpdir	array
)	O
;	O
wget_global_deinit	function
(	O
)	O
;	O
_http_server_stop	function
(	O
)	O
;	O
}	O
static	O
char	O
*	O
_insert_ports	function
(	O
const	O
char	O
*	O
src	pointer
)	O
{	O
if	O
(	O
!	O
src	pointer
||	O
(	O
!	O
strstr	function
(	O
src	pointer
,	O
"{{port}}"	pointer
)	O
&&	O
!	O
strstr	function
(	O
src	pointer
,	O
"{{sslport}}"	pointer
)	O
&&	O
!	O
strstr	function
(	O
src	pointer
,	O
"{{ocspport}}"	pointer
)	O
)	O
)	O
return	O
NULL	O
;	O
size_t	long
srclen	long
=	O
strlen	function
(	O
src	pointer
)	O
+	O
1	int
;	O
char	O
*	O
ret	int
=	O
wget_malloc	function
(	O
srclen	long
)	O
;	O
char	O
*	O
dst	pointer
=	O
ret	int
;	O
while	O
(	O
*	O
src	pointer
)	O
{	O
if	O
(	O
*	O
src	pointer
==	O
'{'	O
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
src	pointer
,	O
"{{port}}"	pointer
,	O
8	int
)	O
)	O
{	O
if	O
(	O
proto_pass	enum
==	O
HTTP_1_1_PASS	int
)	O
{	O
dst	pointer
+=	O
wget_snprintf	function
(	O
dst	pointer
,	O
srclen	long
-	O
(	O
dst	pointer
-	O
ret	int
)	O
,	O
"%d"	pointer
,	O
http_server_port	int
)	O
;	O
}	O
src	pointer
+=	O
8	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
src	pointer
,	O
"{{sslport}}"	pointer
,	O
11	int
)	O
)	O
{	O
if	O
(	O
proto_pass	enum
==	O
HTTP_1_1_PASS	int
)	O
{	O
dst	pointer
+=	O
wget_snprintf	function
(	O
dst	pointer
,	O
srclen	long
-	O
(	O
dst	pointer
-	O
ret	int
)	O
,	O
"%d"	pointer
,	O
https_server_port	int
)	O
;	O
}	O
src	pointer
+=	O
11	int
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
src	pointer
,	O
"{{ocspport}}"	pointer
,	O
12	int
)	O
)	O
{	O
dst	pointer
+=	O
wget_snprintf	function
(	O
dst	pointer
,	O
srclen	long
-	O
(	O
dst	pointer
-	O
ret	int
)	O
,	O
"%d"	pointer
,	O
ocsp_server_port	int
)	O
;	O
src	pointer
+=	O
12	int
;	O
continue	O
;	O
}	O
}	O
*	O
dst	pointer
++	O
=	O
*	O
src	pointer
++	O
;	O
}	O
*	O
dst	pointer
=	O
0	int
;	O
return	O
ret	int
;	O
}	O
static	O
void	O
_write_msg	function
(	O
const	O
char	O
*	O
msg	pointer
,	O
size_t	long
len	long
)	O
{	O
if	O
(	O
isatty	function
(	O
fileno	function
(	O
stderr	pointer
)	O
)	O
)	O
{	O
if	O
(	O
len	long
&&	O
msg	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
len	long
--	O
;	O
wget_fprintf	function
(	O
stderr	pointer
,	O
"\033[33m%.*s\033[m\n"	pointer
,	O
(	O
int	O
)	O
len	long
,	O
msg	pointer
)	O
;	O
}	O
else	O
fwrite	function
(	O
msg	pointer
,	O
1	int
,	O
len	long
,	O
stderr	pointer
)	O
;	O
}	O
void	O
wget_test_start_server	function
(	O
int	O
first_key	int
,	O
...	O
)	O
{	O
int	O
rc	int
,	O
key	int
;	O
va_list	array
args	array
;	O
bool	bool
start_http	bool
=	O
1	int
;	O
bool	bool
ocsp_stap	bool
=	O
0	int
;	O
bool	bool
start_https	bool
=	O
1	int
;	O
wget_global_init	function
(	O
WGET_DEBUG_FUNC	int
,	O
_write_msg	function
,	O
WGET_ERROR_FUNC	int
,	O
_write_msg	function
,	O
WGET_INFO_FUNC	int
,	O
_write_msg	function
,	O
0	int
)	O
;	O
va_start	O
(	O
args	array
,	O
first_key	int
)	O
;	O
for	O
(	O
key	int
=	O
first_key	int
;	O
key	int
;	O
key	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
WGET_TEST_RESPONSE_URLS	int
:	O
urls	pointer
=	O
va_arg	O
(	O
args	array
,	O
wget_test_url_t	struct
*	O
)	O
;	O
nurls	long
=	O
va_arg	O
(	O
args	array
,	O
size_t	long
)	O
;	O
break	O
;	O
case	O
WGET_TEST_SERVER_SEND_CONTENT_LENGTH	int
:	O
server_send_content_length	char
=	O
!	O
!	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_HTTPS_ONLY	int
:	O
start_http	bool
=	O
0	int
;	O
break	O
;	O
case	O
WGET_TEST_HTTP_ONLY	int
:	O
start_https	bool
=	O
0	int
;	O
break	O
;	O
case	O
WGET_TEST_H2_ONLY	int
:	O
start_http	bool
=	O
0	int
;	O
start_https	bool
=	O
0	int
;	O
break	O
;	O
case	O
WGET_TEST_HTTP_REJECT_CONNECTIONS	int
:	O
reject_http_connection	int
=	O
1	int
;	O
break	O
;	O
case	O
WGET_TEST_HTTPS_REJECT_CONNECTIONS	int
:	O
reject_https_connection	int
=	O
1	int
;	O
break	O
;	O
case	O
WGET_TEST_FEATURE_MHD	int
:	O
break	O
;	O
case	O
WGET_TEST_FEATURE_TLS	int
:	O
break	O
;	O
case	O
WGET_TEST_FEATURE_IDN	int
:	O
wget_error_printf	function
(	O
_	O
(	O
"Support for LibIDN not found. Skipping\n"	pointer
)	O
)	O
;	O
exit	function
(	O
WGET_TEST_EXIT_SKIP	int
)	O
;	O
break	O
;	O
case	O
WGET_TEST_FEATURE_PLUGIN	int
:	O
break	O
;	O
case	O
WGET_TEST_FEATURE_OCSP	int
:	O
wget_error_printf	function
(	O
_	O
(	O
"Test requires GnuTLS with OCSP support. Skipping\n"	pointer
)	O
)	O
;	O
exit	function
(	O
WGET_TEST_EXIT_SKIP	int
)	O
;	O
break	O
;	O
case	O
WGET_TEST_FEATURE_OCSP_STAPLING	int
:	O
wget_error_printf	function
(	O
_	O
(	O
"MHD or GnuTLS version insufficient. Skipping\n"	pointer
)	O
)	O
;	O
exit	function
(	O
WGET_TEST_EXIT_SKIP	int
)	O
;	O
case	O
WGET_TEST_SKIP_H2	int
:	O
break	O
;	O
default	O
:	O
wget_error_printf	function
(	O
_	O
(	O
"Unknown option %d\n"	pointer
)	O
,	O
key	int
)	O
;	O
}	O
}	O
va_end	O
(	O
args	array
)	O
;	O
atexit	function
(	O
wget_test_stop_server	function
)	O
;	O
wget_snprintf	function
(	O
tmpdir	array
,	O
sizeof	O
(	O
tmpdir	array
)	O
,	O
".test_%d"	pointer
,	O
(	O
int	O
)	O
getpid	function
(	O
)	O
)	O
;	O
_remove_directory	function
(	O
tmpdir	array
)	O
;	O
if	O
(	O
mkdir	function
(	O
tmpdir	array
,	O
0755	int
)	O
!=	O
0	int
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Failed to create tmpdir (%d)\n"	pointer
)	O
,	O
errno	O
)	O
;	O
if	O
(	O
chdir	function
(	O
tmpdir	array
)	O
!=	O
0	int
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Failed to change to tmpdir (%d)\n"	pointer
)	O
,	O
errno	O
)	O
;	O
if	O
(	O
start_http	bool
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
_http_server_start	function
(	O
HTTP_MODE	int
)	O
)	O
!=	O
0	int
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Failed to start HTTP server, error %d\n"	pointer
)	O
,	O
rc	int
)	O
;	O
}	O
if	O
(	O
start_https	bool
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
_http_server_start	function
(	O
HTTPS_MODE	int
)	O
)	O
!=	O
0	int
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Failed to start HTTPS server, error %d\n"	pointer
)	O
,	O
rc	int
)	O
;	O
}	O
}	O
static	O
void	O
_scan_for_unexpected	function
(	O
const	O
char	O
*	O
dirname	pointer
,	O
const	O
wget_test_file_t	struct
*	O
expected_files	pointer
)	O
{	O
DIR	struct
*	O
dir	array
;	O
struct	O
stat	struct
st	struct
;	O
size_t	long
dirlen	long
=	O
strlen	function
(	O
dirname	pointer
)	O
;	O
wget_info_printf	function
(	O
"Entering %s\n"	pointer
,	O
dirname	pointer
)	O
;	O
if	O
(	O
(	O
dir	array
=	O
opendir	function
(	O
dirname	pointer
)	O
)	O
)	O
{	O
struct	O
dirent	struct
*	O
dp	pointer
;	O
while	O
(	O
(	O
dp	pointer
=	O
readdir	function
(	O
dir	array
)	O
)	O
)	O
{	O
char	O
fname	pointer
[	O
dirlen	long
+	O
1	int
+	O
strlen	function
(	O
dp	pointer
->	O
d_name	array
)	O
+	O
1	int
]	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
dp	pointer
->	O
d_name	array
,	O
"."	pointer
)	O
||	O
!	O
strcmp	function
(	O
dp	pointer
->	O
d_name	array
,	O
".."	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
*	O
dirname	pointer
==	O
'.'	O
&&	O
dirname	pointer
[	O
1	int
]	O
==	O
0	int
)	O
wget_snprintf	function
(	O
fname	pointer
,	O
sizeof	O
(	O
fname	pointer
)	O
,	O
"%s"	pointer
,	O
dp	pointer
->	O
d_name	array
)	O
;	O
else	O
wget_snprintf	function
(	O
fname	pointer
,	O
sizeof	O
(	O
fname	pointer
)	O
,	O
"%s/%s"	pointer
,	O
dirname	pointer
,	O
dp	pointer
->	O
d_name	array
)	O
;	O
wget_info_printf	function
(	O
" - %s/%s\n"	pointer
,	O
dirname	pointer
,	O
dp	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
stat	struct
(	O
fname	pointer
,	O
&	O
st	struct
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
_scan_for_unexpected	function
(	O
fname	pointer
,	O
expected_files	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
expected_files	pointer
)	O
{	O
size_t	long
it	int
;	O
wget_info_printf	function
(	O
_	O
(	O
"search %s\n"	pointer
)	O
,	O
fname	pointer
)	O
;	O
for	O
(	O
it	int
=	O
0	int
;	O
expected_files	pointer
[	O
it	int
]	O
.	O
name	pointer
;	O
it	int
++	O
)	O
{	O
const	O
char	O
*	O
restricted_fname	pointer
=	O
expected_files	pointer
[	O
it	int
]	O
.	O
name	pointer
;	O
if	O
(	O
!	O
strcmp	function
(	O
restricted_fname	pointer
,	O
fname	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
expected_files	pointer
[	O
it	int
]	O
.	O
name	pointer
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Unexpected file %s/%s found\n"	pointer
)	O
,	O
tmpdir	array
,	O
fname	pointer
)	O
;	O
}	O
else	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Unexpected file %s/%s found\n"	pointer
)	O
,	O
tmpdir	array
,	O
fname	pointer
)	O
;	O
}	O
closedir	function
(	O
dir	array
)	O
;	O
}	O
else	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Failed to diropen %s\n"	pointer
)	O
,	O
dirname	pointer
)	O
;	O
}	O
void	O
wget_test	function
(	O
int	O
first_key	int
,	O
...	O
)	O
{	O
if	O
(	O
!	O
httpdaemon	pointer
&&	O
!	O
httpsdaemon	pointer
)	O
exit	function
(	O
WGET_TEST_EXIT_SKIP	int
)	O
;	O
for	O
(	O
proto_pass	enum
=	O
0	int
;	O
proto_pass	enum
<	O
END_PASS	int
;	O
proto_pass	enum
++	O
)	O
{	O
if	O
(	O
proto_pass	enum
==	O
HTTP_1_1_PASS	int
&&	O
!	O
httpdaemon	pointer
&&	O
!	O
httpsdaemon	pointer
)	O
continue	O
;	O
if	O
(	O
proto_pass	enum
==	O
H2_PASS	int
)	O
{	O
continue	O
;	O
if	O
(	O
!	O
h2daemon	pointer
)	O
continue	O
;	O
}	O
for	O
(	O
wget_test_url_t	struct
*	O
url	pointer
=	O
urls	pointer
;	O
url	pointer
<	O
urls	pointer
+	O
nurls	long
;	O
url	pointer
++	O
)	O
{	O
char	O
*	O
p	pointer
=	O
_insert_ports	function
(	O
url	pointer
->	O
body	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
url	pointer
->	O
body_original	pointer
=	O
url	pointer
->	O
body	pointer
;	O
url	pointer
->	O
body	pointer
=	O
p	pointer
;	O
}	O
for	O
(	O
unsigned	O
it	int
=	O
0	int
;	O
it	int
<	O
countof	O
(	O
url	pointer
->	O
headers	pointer
)	O
&&	O
url	pointer
->	O
headers	pointer
[	O
it	int
]	O
;	O
it	int
++	O
)	O
{	O
p	pointer
=	O
_insert_ports	function
(	O
url	pointer
->	O
headers	pointer
[	O
it	int
]	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
url	pointer
->	O
headers_original	array
[	O
it	int
]	O
=	O
url	pointer
->	O
headers	pointer
[	O
it	int
]	O
;	O
url	pointer
->	O
headers	pointer
[	O
it	int
]	O
=	O
p	pointer
;	O
}	O
}	O
}	O
const	O
char	O
*	O
request_url	pointer
,	O
*	O
options	pointer
=	O
""	pointer
,	O
*	O
executable	pointer
;	O
const	O
wget_test_file_t	struct
*	O
expected_files	pointer
=	O
NULL	O
,	O
*	O
existing_files	pointer
=	O
NULL	O
;	O
wget_buffer	struct
*	O
cmd	pointer
=	O
wget_buffer_alloc	function
(	O
1024	int
)	O
;	O
unsigned	O
it	int
;	O
int	O
key	int
,	O
fd	array
,	O
rc	int
,	O
expected_error_code2	int
=	O
-	O
1	int
,	O
expected_error_code	int
=	O
0	int
;	O
va_list	array
args	array
;	O
char	O
server_send_content_length_old	char
=	O
server_send_content_length	char
;	O
bool	bool
options_alloc	bool
=	O
0	int
;	O
if	O
(	O
proto_pass	enum
==	O
H2_PASS	int
)	O
executable	pointer
=	O
BUILDDIR	O
"/../src/wget2_noinstall"	pointer
EXEEXT	O
" -d --no-config --no-local-db --max-threads=1 --prefer-family=ipv4 --no-proxy --timeout 10 --https-enforce=hard --ca-certificate="	pointer
SRCDIR	O
"/certs/x509-ca-cert.pem --no-ocsp"	pointer
;	O
else	O
executable	pointer
=	O
BUILDDIR	O
"/../src/wget2_noinstall"	pointer
EXEEXT	O
" -d --no-config --no-local-db --max-threads=1 --prefer-family=ipv4 --no-proxy --timeout 10"	pointer
;	O
keep_tmpfiles	int
=	O
0	int
;	O
if	O
(	O
!	O
request_urls	pointer
)	O
{	O
request_urls	pointer
=	O
wget_vector_create	function
(	O
8	int
,	O
NULL	O
)	O
;	O
wget_vector_set_destructor	function
(	O
request_urls	pointer
,	O
NULL	O
)	O
;	O
}	O
va_start	O
(	O
args	array
,	O
first_key	int
)	O
;	O
for	O
(	O
key	int
=	O
first_key	int
;	O
key	int
;	O
key	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
WGET_TEST_REQUEST_URL	int
:	O
if	O
(	O
(	O
request_url	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
char	O
*	O
)	O
)	O
)	O
wget_vector_add	function
(	O
request_urls	pointer
,	O
request_url	pointer
)	O
;	O
break	O
;	O
case	O
WGET_TEST_REQUEST_URLS	int
:	O
while	O
(	O
(	O
request_url	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
char	O
*	O
)	O
)	O
)	O
wget_vector_add	function
(	O
request_urls	pointer
,	O
request_url	pointer
)	O
;	O
break	O
;	O
case	O
WGET_TEST_EXPECTED_ERROR_CODE	int
:	O
expected_error_code	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_EXPECTED_ERROR_CODE2	int
:	O
expected_error_code2	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_EXPECTED_FILES	int
:	O
expected_files	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
wget_test_file_t	struct
*	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_EXISTING_FILES	int
:	O
existing_files	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
wget_test_file_t	struct
*	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_OPTIONS	int
:	O
{	O
options	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
char	O
*	O
)	O
;	O
const	O
char	O
*	O
tmp	pointer
=	O
_insert_ports	function
(	O
options	pointer
)	O
;	O
if	O
(	O
tmp	pointer
)	O
{	O
options	pointer
=	O
tmp	pointer
;	O
options_alloc	bool
=	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
WGET_TEST_KEEP_TMPFILES	int
:	O
keep_tmpfiles	int
=	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_EXECUTABLE	int
:	O
executable	pointer
=	O
va_arg	O
(	O
args	array
,	O
const	O
char	O
*	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_SERVER_SEND_CONTENT_LENGTH	int
:	O
server_send_content_length	char
=	O
!	O
!	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
;	O
break	O
;	O
case	O
WGET_TEST_POST_HANDSHAKE_AUTH	int
:	O
if	O
(	O
va_arg	O
(	O
args	array
,	O
int	O
)	O
)	O
{	O
}	O
break	O
;	O
case	O
WGET_TEST_OCSP_RESP_FILE	int
:	O
break	O
;	O
default	O
:	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Unknown option %d [%s]\n"	pointer
)	O
,	O
key	int
,	O
options	pointer
)	O
;	O
}	O
}	O
va_end	O
(	O
args	array
)	O
;	O
wget_buffer_printf	function
(	O
cmd	pointer
,	O
"../%s"	pointer
,	O
tmpdir	array
)	O
;	O
_empty_directory	function
(	O
cmd	pointer
->	O
data	pointer
)	O
;	O
if	O
(	O
existing_files	pointer
)	O
{	O
for	O
(	O
it	int
=	O
0	int
;	O
existing_files	pointer
[	O
it	int
]	O
.	O
name	pointer
;	O
it	int
++	O
)	O
{	O
mkdir_path	function
(	O
existing_files	pointer
[	O
it	int
]	O
.	O
name	pointer
,	O
1	int
)	O
;	O
if	O
(	O
existing_files	pointer
[	O
it	int
]	O
.	O
hardlink	pointer
)	O
{	O
if	O
(	O
link	function
(	O
existing_files	pointer
[	O
it	int
]	O
.	O
hardlink	pointer
,	O
existing_files	pointer
[	O
it	int
]	O
.	O
name	pointer
)	O
!=	O
0	int
)	O
{	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Failed to link %s/%s -> %s/%s [%s]\n"	pointer
)	O
,	O
tmpdir	array
,	O
existing_files	pointer
[	O
it	int
]	O
.	O
hardlink	pointer
,	O
tmpdir	array
,	O
existing_files	pointer
[	O
it	int
]	O
.	O
name	pointer
,	O
options	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
fd	array
=	O
open	function
(	O
existing_files	pointer
[	O
it	int
]	O
.	O
name	pointer
,	O
O_CREAT	int
|	O
O_WRONLY	int
|	O
O_TRUNC	int
|	O
O_BINARY	int
,	O
0644	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
const	O
char	O
*	O
existing_content	pointer
=	O
_insert_ports	function
(	O
existing_files	pointer
[	O
it	int
]	O
.	O
content	pointer
)	O
;	O
if	O
(	O
!	O
existing_content	pointer
)	O
existing_content	pointer
=	O
existing_files	pointer
[	O
it	int
]	O
.	O
content	pointer
;	O
ssize_t	long
nbytes	long
=	O
write	function
(	O
fd	array
,	O
existing_content	pointer
,	O
strlen	function
(	O
existing_content	pointer
)	O
)	O
;	O
close	function
(	O
fd	array
)	O
;	O
if	O
(	O
nbytes	long
!=	O
(	O
ssize_t	long
)	O
strlen	function
(	O
existing_content	pointer
)	O
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Failed to write %zu bytes to file %s/%s [%s]\n"	pointer
)	O
,	O
strlen	function
(	O
existing_content	pointer
)	O
,	O
tmpdir	array
,	O
existing_files	pointer
[	O
it	int
]	O
.	O
name	pointer
,	O
options	pointer
)	O
;	O
if	O
(	O
existing_files	pointer
[	O
it	int
]	O
.	O
timestamp	long
)	O
{	O
if	O
(	O
utime	function
(	O
existing_files	pointer
[	O
it	int
]	O
.	O
name	pointer
,	O
&	O
(	O
struct	O
utimbuf	struct
)	O
{	O
0	int
,	O
existing_files	pointer
[	O
it	int
]	O
.	O
timestamp	long
}	O
)	O
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Failed to set mtime of %s/%s [%s]\n"	pointer
)	O
,	O
tmpdir	array
,	O
existing_files	pointer
[	O
it	int
]	O
.	O
name	pointer
,	O
options	pointer
)	O
;	O
}	O
if	O
(	O
existing_content	pointer
!=	O
existing_files	pointer
[	O
it	int
]	O
.	O
content	pointer
)	O
wget_xfree	O
(	O
existing_content	pointer
)	O
;	O
}	O
else	O
{	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Failed to write open file %s/%s [%s] (%d,%s)\n"	pointer
)	O
,	O
tmpdir	array
,	O
*	O
existing_files	pointer
[	O
it	int
]	O
.	O
name	pointer
==	O
'/'	O
?	O
existing_files	pointer
[	O
it	int
]	O
.	O
name	pointer
+	O
1	int
:	O
existing_files	pointer
[	O
it	int
]	O
.	O
name	pointer
,	O
options	pointer
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
}	O
const	O
char	O
*	O
valgrind	pointer
=	O
getenv	function
(	O
"VALGRIND_TESTS"	pointer
)	O
;	O
if	O
(	O
!	O
valgrind	pointer
||	O
!	O
*	O
valgrind	pointer
||	O
!	O
strcmp	function
(	O
valgrind	pointer
,	O
"0"	pointer
)	O
)	O
{	O
const	O
char	O
*	O
emulator	pointer
=	O
getenv	function
(	O
"EMULATOR"	pointer
)	O
;	O
if	O
(	O
emulator	pointer
&&	O
*	O
emulator	pointer
)	O
wget_buffer_printf	function
(	O
cmd	pointer
,	O
"%s %s %s"	pointer
,	O
emulator	pointer
,	O
executable	pointer
,	O
options	pointer
)	O
;	O
else	O
wget_buffer_printf	function
(	O
cmd	pointer
,	O
"%s %s"	pointer
,	O
executable	pointer
,	O
options	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
valgrind	pointer
,	O
"1"	pointer
)	O
)	O
{	O
wget_buffer_printf	function
(	O
cmd	pointer
,	O
"valgrind --error-exitcode=301 --leak-check=yes --show-reachable=yes --track-origins=yes --child-silent-after-fork=yes --suppressions="	pointer
SRCDIR	O
"/valgrind-suppressions %s %s"	pointer
,	O
executable	pointer
,	O
options	pointer
)	O
;	O
}	O
else	O
wget_buffer_printf	function
(	O
cmd	pointer
,	O
"%s %s %s"	pointer
,	O
valgrind	pointer
,	O
executable	pointer
,	O
options	pointer
)	O
;	O
for	O
(	O
it	int
=	O
0	int
;	O
it	int
<	O
(	O
size_t	long
)	O
wget_vector_size	function
(	O
request_urls	pointer
)	O
;	O
it	int
++	O
)	O
{	O
request_url	pointer
=	O
wget_vector_get	function
(	O
request_urls	pointer
,	O
it	int
)	O
;	O
if	O
(	O
!	O
wget_strncasecmp_ascii	function
(	O
request_url	pointer
,	O
"http://"	pointer
,	O
7	int
)	O
||	O
!	O
wget_strncasecmp_ascii	function
(	O
request_url	pointer
,	O
"https://"	pointer
,	O
8	int
)	O
)	O
{	O
char	O
*	O
tmp	pointer
=	O
_insert_ports	function
(	O
request_url	pointer
)	O
;	O
wget_buffer_printf_append	function
(	O
cmd	pointer
,	O
" \"%s\""	pointer
,	O
tmp	pointer
?	O
tmp	pointer
:	O
request_url	pointer
)	O
;	O
wget_xfree	O
(	O
tmp	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
proto_pass	enum
==	O
HTTP_1_1_PASS	int
)	O
{	O
wget_buffer_printf_append	function
(	O
cmd	pointer
,	O
" \"http://localhost:%d/%s\""	pointer
,	O
http_server_port	int
,	O
request_url	pointer
)	O
;	O
}	O
}	O
}	O
wget_buffer_strcat	function
(	O
cmd	pointer
,	O
" 2>&1"	pointer
)	O
;	O
wget_info_printf	function
(	O
"cmd=%s\n"	pointer
,	O
cmd	pointer
->	O
data	pointer
)	O
;	O
wget_error_printf	function
(	O
_	O
(	O
"\n  Testing '%s'\n"	pointer
)	O
,	O
cmd	pointer
->	O
data	pointer
)	O
;	O
FILE	struct
*	O
pp	pointer
;	O
if	O
(	O
(	O
pp	pointer
=	O
popen	function
(	O
cmd	pointer
->	O
data	pointer
,	O
"r"	pointer
)	O
)	O
)	O
{	O
char	O
buf	pointer
[	O
4096	int
]	O
;	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
pp	pointer
)	O
)	O
{	O
fputs	function
(	O
buf	pointer
,	O
stderr	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
}	O
rc	int
=	O
pclose	function
(	O
pp	pointer
)	O
;	O
}	O
else	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Failed to execute test (%d) [%s]\n"	pointer
)	O
,	O
errno	O
,	O
options	pointer
)	O
;	O
if	O
(	O
!	O
WIFEXITED	O
(	O
rc	int
)	O
)	O
{	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Unexpected error code %d, expected %d [%s]\n"	pointer
)	O
,	O
rc	int
,	O
expected_error_code	int
,	O
options	pointer
)	O
;	O
}	O
else	O
if	O
(	O
WEXITSTATUS	O
(	O
rc	int
)	O
!=	O
expected_error_code	int
)	O
{	O
if	O
(	O
expected_error_code2	int
>=	O
0	int
)	O
{	O
if	O
(	O
WEXITSTATUS	O
(	O
rc	int
)	O
!=	O
expected_error_code2	int
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Unexpected error code %d, expected %d or %d [%s]\n"	pointer
)	O
,	O
WEXITSTATUS	O
(	O
rc	int
)	O
,	O
expected_error_code	int
,	O
expected_error_code2	int
,	O
options	pointer
)	O
;	O
}	O
else	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Unexpected error code %d, expected %d [%s]\n"	pointer
)	O
,	O
WEXITSTATUS	O
(	O
rc	int
)	O
,	O
expected_error_code	int
,	O
options	pointer
)	O
;	O
}	O
if	O
(	O
expected_files	pointer
)	O
{	O
for	O
(	O
it	int
=	O
0	int
;	O
expected_files	pointer
[	O
it	int
]	O
.	O
name	pointer
;	O
it	int
++	O
)	O
{	O
struct	O
stat	struct
st	struct
;	O
const	O
char	O
*	O
fname	pointer
=	O
expected_files	pointer
[	O
it	int
]	O
.	O
name	pointer
;	O
if	O
(	O
stat	struct
(	O
fname	pointer
,	O
&	O
st	struct
)	O
!=	O
0	int
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Missing expected file '%s/%s' [%s]\n"	pointer
)	O
,	O
tmpdir	array
,	O
fname	pointer
,	O
options	pointer
)	O
;	O
if	O
(	O
expected_files	pointer
[	O
it	int
]	O
.	O
content	pointer
)	O
{	O
char	O
*	O
content	pointer
=	O
wget_malloc	function
(	O
st	struct
.	O
st_size	long
?	O
st	struct
.	O
st_size	long
:	O
1	int
)	O
;	O
if	O
(	O
(	O
fd	array
=	O
open	function
(	O
fname	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
ssize_t	long
nbytes	long
=	O
read	function
(	O
fd	array
,	O
content	pointer
,	O
st	struct
.	O
st_size	long
)	O
;	O
close	function
(	O
fd	array
)	O
;	O
if	O
(	O
nbytes	long
!=	O
st	struct
.	O
st_size	long
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Failed to read %lld bytes from file '%s/%s', just got %zd [%s]\n"	pointer
)	O
,	O
(	O
long	O
long	O
)	O
st	struct
.	O
st_size	long
,	O
tmpdir	array
,	O
fname	pointer
,	O
nbytes	long
,	O
options	pointer
)	O
;	O
const	O
char	O
*	O
expected_content	pointer
=	O
_insert_ports	function
(	O
expected_files	pointer
[	O
it	int
]	O
.	O
content	pointer
)	O
;	O
bool	bool
expected_content_alloc	bool
=	O
0	int
;	O
if	O
(	O
!	O
expected_content	pointer
)	O
expected_content	pointer
=	O
expected_files	pointer
[	O
it	int
]	O
.	O
content	pointer
;	O
else	O
expected_content_alloc	bool
=	O
1	int
;	O
size_t	long
content_length	long
=	O
expected_files	pointer
[	O
it	int
]	O
.	O
content_length	long
?	O
expected_files	pointer
[	O
it	int
]	O
.	O
content_length	long
:	O
strlen	function
(	O
expected_content	pointer
)	O
;	O
if	O
(	O
content_length	long
!=	O
(	O
size_t	long
)	O
nbytes	long
||	O
memcmp	function
(	O
expected_content	pointer
,	O
content	pointer
,	O
nbytes	long
)	O
!=	O
0	int
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Unexpected content in %s [%s]\n"	pointer
)	O
,	O
fname	pointer
,	O
options	pointer
)	O
;	O
if	O
(	O
expected_content_alloc	bool
)	O
wget_xfree	O
(	O
expected_content	pointer
)	O
;	O
}	O
wget_xfree	O
(	O
content	pointer
)	O
;	O
}	O
if	O
(	O
expected_files	pointer
[	O
it	int
]	O
.	O
timestamp	long
&&	O
st	struct
.	O
st_mtime	O
!=	O
expected_files	pointer
[	O
it	int
]	O
.	O
timestamp	long
)	O
wget_error_printf_exit	function
(	O
_	O
(	O
"Unexpected timestamp '%s/%s' [%s]\n"	pointer
)	O
,	O
tmpdir	array
,	O
fname	pointer
,	O
options	pointer
)	O
;	O
}	O
}	O
_scan_for_unexpected	function
(	O
"."	pointer
,	O
expected_files	pointer
)	O
;	O
wget_vector_clear	function
(	O
request_urls	pointer
)	O
;	O
wget_buffer_free	function
(	O
&	O
cmd	pointer
)	O
;	O
if	O
(	O
options_alloc	bool
)	O
wget_xfree	O
(	O
options	pointer
)	O
;	O
server_send_content_length	char
=	O
server_send_content_length_old	char
;	O
for	O
(	O
wget_test_url_t	struct
*	O
url	pointer
=	O
urls	pointer
;	O
url	pointer
<	O
urls	pointer
+	O
nurls	long
;	O
url	pointer
++	O
)	O
{	O
if	O
(	O
url	pointer
->	O
body_original	pointer
)	O
{	O
wget_xfree	O
(	O
url	pointer
->	O
body	pointer
)	O
;	O
url	pointer
->	O
body	pointer
=	O
url	pointer
->	O
body_original	pointer
;	O
url	pointer
->	O
body_original	pointer
=	O
NULL	O
;	O
}	O
for	O
(	O
it	int
=	O
0	int
;	O
it	int
<	O
countof	O
(	O
url	pointer
->	O
headers	pointer
)	O
&&	O
url	pointer
->	O
headers	pointer
[	O
it	int
]	O
;	O
it	int
++	O
)	O
{	O
if	O
(	O
url	pointer
->	O
headers_original	array
[	O
it	int
]	O
)	O
{	O
wget_xfree	O
(	O
url	pointer
->	O
headers	pointer
[	O
it	int
]	O
)	O
;	O
url	pointer
->	O
headers	pointer
[	O
it	int
]	O
=	O
url	pointer
->	O
headers_original	array
[	O
it	int
]	O
;	O
url	pointer
->	O
headers_original	array
[	O
it	int
]	O
=	O
NULL	O
;	O
}	O
}	O
}	O
}	O
}	O
int	O
wget_test_get_http_server_port	function
(	O
void	O
)	O
{	O
return	O
proto_pass	enum
==	O
H2_PASS	int
?	O
h2_server_port	int
:	O
http_server_port	int
;	O
}	O
int	O
wget_test_get_https_server_port	function
(	O
void	O
)	O
{	O
return	O
proto_pass	enum
==	O
H2_PASS	int
?	O
h2_server_port	int
:	O
https_server_port	int
;	O
}	O
int	O
wget_test_get_h2_server_port	function
(	O
void	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
int	O
wget_test_get_ocsp_server_port	function
(	O
void	O
)	O
{	O
return	O
ocsp_server_port	int
;	O
}	O
int	O
wget_test_check_file_system	function
(	O
void	O
)	O
{	O
static	O
char	O
fname	pointer
[	O
3	int
]	O
[	O
3	int
]	O
=	O
{	O
"Ab"	pointer
,	O
"ab"	pointer
,	O
"AB"	pointer
}	O
;	O
char	O
buf	pointer
[	O
sizeof	O
(	O
fname	pointer
[	O
0	int
]	O
)	O
]	O
;	O
int	O
flags	int
=	O
0	int
,	O
fd	array
;	O
ssize_t	long
rc	int
;	O
_empty_directory	function
(	O
tmpdir	array
)	O
;	O
for	O
(	O
unsigned	O
it	int
=	O
0	int
;	O
it	int
<	O
countof	O
(	O
fname	pointer
)	O
;	O
it	int
++	O
)	O
{	O
if	O
(	O
(	O
fd	array
=	O
open	function
(	O
fname	pointer
[	O
it	int
]	O
,	O
O_WRONLY	int
|	O
O_TRUNC	int
|	O
O_CREAT	int
|	O
O_BINARY	int
,	O
0644	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
rc	int
=	O
write	function
(	O
fd	array
,	O
fname	pointer
[	O
it	int
]	O
,	O
sizeof	O
(	O
fname	pointer
[	O
0	int
]	O
)	O
)	O
;	O
close	function
(	O
fd	array
)	O
;	O
if	O
(	O
rc	int
!=	O
sizeof	O
(	O
fname	pointer
[	O
0	int
]	O
)	O
)	O
{	O
wget_debug_printf	function
(	O
"%s: Failed to write to '%s/%s' (%d) %zd %zu\n"	pointer
,	O
__func__	O
,	O
tmpdir	array
,	O
fname	pointer
[	O
it	int
]	O
,	O
errno	O
,	O
rc	int
,	O
sizeof	O
(	O
fname	pointer
[	O
0	int
]	O
)	O
)	O
;	O
goto	O
out	pointer
;	O
}	O
}	O
else	O
{	O
wget_debug_printf	function
(	O
"%s: Failed to write open '%s/%s'\n"	pointer
,	O
__func__	O
,	O
tmpdir	array
,	O
fname	pointer
[	O
it	int
]	O
)	O
;	O
goto	O
out	pointer
;	O
}	O
}	O
for	O
(	O
unsigned	O
it	int
=	O
0	int
;	O
it	int
<	O
countof	O
(	O
fname	pointer
)	O
;	O
it	int
++	O
)	O
{	O
if	O
(	O
(	O
fd	array
=	O
open	function
(	O
fname	pointer
[	O
it	int
]	O
,	O
O_RDONLY	int
|	O
O_BINARY	int
,	O
0644	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
rc	int
=	O
read	function
(	O
fd	array
,	O
buf	pointer
,	O
sizeof	O
(	O
fname	pointer
[	O
0	int
]	O
)	O
)	O
;	O
close	function
(	O
fd	array
)	O
;	O
if	O
(	O
rc	int
!=	O
sizeof	O
(	O
fname	pointer
[	O
0	int
]	O
)	O
)	O
{	O
wget_debug_printf	function
(	O
"%s: Failed to read from '%s/%s'\n"	pointer
,	O
__func__	O
,	O
tmpdir	array
,	O
fname	pointer
[	O
it	int
]	O
)	O
;	O
goto	O
out	pointer
;	O
}	O
if	O
(	O
strcmp	function
(	O
buf	pointer
,	O
fname	pointer
[	O
it	int
]	O
)	O
)	O
{	O
wget_debug_printf	function
(	O
"%s: Found case-mangling file system\n"	pointer
,	O
__func__	O
)	O
;	O
flags	int
=	O
WGET_TEST_FS_CASEMATTERS	int
;	O
goto	O
out	pointer
;	O
}	O
}	O
else	O
{	O
wget_debug_printf	function
(	O
"%s: Failed to read open '%s/%s'\n"	pointer
,	O
__func__	O
,	O
tmpdir	array
,	O
fname	pointer
[	O
it	int
]	O
)	O
;	O
goto	O
out	pointer
;	O
}	O
}	O
wget_debug_printf	function
(	O
"%s: Found case-respecting file system\n"	pointer
,	O
__func__	O
)	O
;	O
out	pointer
:	O
_empty_directory	function
(	O
tmpdir	array
)	O
;	O
return	O
flags	int
;	O
}	O
