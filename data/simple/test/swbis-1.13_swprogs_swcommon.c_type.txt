char	O
*	O
CHARTRUE	pointer
=	O
"true"	pointer
;	O
extern	O
struct	O
extendedOptions	struct
*	O
optionsArray	pointer
;	O
static	O
int	O
g_logger_sigterm	int
=	O
0	int
;	O
static	O
ssize_t	long
try_nibble	function
(	O
int	O
fd	int
,	O
void	O
*	O
buf	pointer
,	O
int	O
timeout	int
)	O
{	O
return	O
read	pointer
(	O
fd	int
,	O
buf	pointer
,	O
1	int
)	O
;	O
}	O
static	O
void	O
logger_sig_handler	function
(	O
int	O
signum	int
)	O
{	O
switch	O
(	O
signum	int
)	O
{	O
case	O
SIGTERM	int
:	O
case	O
SIGUSR2	int
:	O
case	O
SIGABRT	int
:	O
g_logger_sigterm	int
=	O
signum	int
;	O
break	O
;	O
}	O
}	O
static	O
void	O
detect_special_verbose_status	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
sptr	pointer
)	O
{	O
if	O
(	O
strstr	function
(	O
sptr	pointer
,	O
"SW_CONTROL_SCRIPT_BEGINS"	pointer
)	O
)	O
{	O
G_set_is_in_control_script	O
(	O
G	pointer
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
sptr	pointer
,	O
"SW_CONTROL_SCRIPT_ENDS"	pointer
)	O
)	O
{	O
G_set_is_in_control_script	O
(	O
G	pointer
,	O
0	int
)	O
;	O
}	O
}	O
static	O
int	O
is_ssh_sys_error	function
(	O
char	O
*	O
sptr	pointer
)	O
{	O
if	O
(	O
strstr	function
(	O
sptr	pointer
,	O
"DOING SOMETHING NASTY!"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"man-in-the-middle attack!"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"Offending key in"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"Offending key for"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"Connection refused"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
" Name or service not known"	pointer
)	O
||	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
static	O
int	O
is_unix_sys_error	function
(	O
char	O
*	O
sptr	pointer
)	O
{	O
return	O
(	O
strstr	function
(	O
sptr	pointer
,	O
"bnormal termination"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"bnormal Termination"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"SIGABRT"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"SIGINT"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"ermission denied"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"ot permitted"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
" input/output"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
" Input/Output"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
" i/o"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
" I/O"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"i/o "	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"I/O "	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
" error"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
" Error"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"error "	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"Error "	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"roken pipe"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"ead-only"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"ead only"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"o such file"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"o such device"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"o space"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"ccess denied"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"out of memory"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"ot enough space"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"format error"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"Bad "	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"bad file"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"Too many "	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"too many "	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"oo large "	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"nvalid arg"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"Unexpected EOF in archive"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"nexpected eof in archive"	pointer
)	O
||	O
strstr	function
(	O
sptr	pointer
,	O
"NUL blocks at start"	pointer
)	O
||	O
0	int
)	O
;	O
}	O
static	O
int	O
writeline	function
(	O
int	O
do_stderr	int
,	O
int	O
do_log	int
,	O
int	O
logfd	int
,	O
int	O
efd	int
,	O
char	O
*	O
msg_prefix	pointer
,	O
char	O
*	O
p_sptr	pointer
,	O
int	O
len	int
)	O
{	O
char	O
*	O
sptr	pointer
;	O
int	O
ret	int
;	O
int	O
eret	int
=	O
0	int
;	O
int	O
lret	int
=	O
0	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG3	O
(	O
"do_log=%d  logfd=%d"	pointer
,	O
do_log	int
,	O
logfd	int
)	O
;	O
E_DEBUG3	O
(	O
"do_stderr=%d  efd=%d"	pointer
,	O
do_stderr	int
,	O
efd	int
)	O
;	O
if	O
(	O
msg_prefix	pointer
&&	O
strlen	function
(	O
msg_prefix	pointer
)	O
&&	O
strstr	function
(	O
p_sptr	pointer
,	O
msg_prefix	pointer
)	O
==	O
NULL	O
)	O
{	O
tmp	pointer
=	O
strob_open	function
(	O
40	int
)	O
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"%s%s"	pointer
,	O
msg_prefix	pointer
,	O
p_sptr	pointer
)	O
;	O
sptr	pointer
=	O
strob_str	function
(	O
tmp	pointer
)	O
;	O
len	int
=	O
strlen	function
(	O
sptr	pointer
)	O
;	O
}	O
else	O
{	O
tmp	pointer
=	O
NULL	O
;	O
sptr	pointer
=	O
p_sptr	pointer
;	O
}	O
if	O
(	O
do_stderr	int
)	O
{	O
eret	int
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	pointer
,	O
efd	int
,	O
sptr	pointer
,	O
len	int
)	O
;	O
}	O
if	O
(	O
do_log	int
&&	O
logfd	int
>	O
0	int
)	O
lret	int
=	O
swutil_writelogline	function
(	O
logfd	int
,	O
sptr	pointer
)	O
;	O
ret	int
=	O
eret	int
;	O
ret	int
=	O
lret	int
<	O
0	int
?	O
lret	int
:	O
ret	int
;	O
E_DEBUG2	O
(	O
"return = %d"	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
tmp	pointer
)	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
is_event	function
(	O
char	O
*	O
line	pointer
,	O
int	O
*	O
status	int
,	O
int	O
*	O
is_swbis_event	pointer
,	O
int	O
*	O
is_swi_eventp	pointer
,	O
int	O
*	O
is_posix_eventp	pointer
)	O
{	O
*	O
status	int
=	O
0	int
;	O
*	O
is_swbis_event	pointer
=	O
0	int
;	O
*	O
is_swi_eventp	pointer
=	O
0	int
;	O
*	O
is_posix_eventp	pointer
=	O
0	int
;	O
if	O
(	O
strstr	function
(	O
line	pointer
,	O
": SW_"	pointer
)	O
||	O
strstr	function
(	O
line	pointer
,	O
": SWI_"	pointer
)	O
||	O
strstr	function
(	O
line	pointer
,	O
": SWBIS_"	pointer
)	O
)	O
{	O
if	O
(	O
swevent_is_error	function
(	O
line	pointer
,	O
status	int
)	O
&&	O
*	O
status	int
==	O
0	int
)	O
{	O
*	O
status	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
strstr	function
(	O
line	pointer
,	O
": SWBIS_"	pointer
)	O
)	O
*	O
is_swbis_event	pointer
=	O
1	int
;	O
if	O
(	O
strstr	function
(	O
line	pointer
,	O
": SWI_"	pointer
)	O
)	O
*	O
is_swi_eventp	pointer
=	O
1	int
;	O
if	O
(	O
strstr	function
(	O
line	pointer
,	O
": SW_"	pointer
)	O
)	O
*	O
is_posix_eventp	pointer
=	O
1	int
;	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
static	O
int	O
write_error_line	function
(	O
GB	struct
*	O
G	pointer
,	O
struct	O
sw_logspec	struct
*	O
logspec	pointer
,	O
int	O
vofd	int
,	O
int	O
vefd	int
,	O
STROB	struct
*	O
linebuf	pointer
,	O
int	O
len	int
,	O
int	O
verbose_level	int
,	O
int	O
swi_event_fd	int
)	O
{	O
int	O
evret	int
=	O
0	int
;	O
int	O
ret	int
=	O
0	int
;	O
int	O
event_status	int
;	O
int	O
is_swi_event	int
=	O
0	int
;	O
int	O
is_posix_event	int
=	O
0	int
;	O
int	O
is_swbis_event	pointer
;	O
char	O
*	O
news	pointer
;	O
char	O
*	O
sptr	pointer
;	O
int	O
do_log	int
=	O
0	int
;	O
int	O
do_stderr	int
=	O
0	int
;	O
struct	O
swEvents	struct
*	O
ev	pointer
=	O
NULL	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG2	O
(	O
"verbose_level=%d"	pointer
,	O
verbose_level	int
)	O
;	O
E_DEBUG3	O
(	O
"vefd=%d  vofd=%d"	pointer
,	O
vefd	int
,	O
vofd	int
)	O
;	O
sptr	pointer
=	O
strob_str	function
(	O
linebuf	pointer
)	O
;	O
detect_special_verbose_status	function
(	O
G	pointer
,	O
sptr	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
is_event	function
(	O
sptr	pointer
,	O
&	O
event_status	int
,	O
&	O
is_swbis_event	pointer
,	O
&	O
is_swi_event	int
,	O
&	O
is_posix_event	int
)	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
swi_event_fd	int
>=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
news	pointer
=	O
strdup	function
(	O
sptr	pointer
)	O
;	O
E_DEBUG2	O
(	O
"sptr=[%s]"	pointer
,	O
news	pointer
)	O
;	O
if	O
(	O
(	O
ev	pointer
=	O
swevents_get_struct_by_message	function
(	O
sptr	pointer
,	O
swevent_get_events_array	function
(	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"swbis internal error: EVENT NOT Found for [%s]\n"	pointer
,	O
sptr	pointer
)	O
;	O
}	O
else	O
{	O
;	O
}	O
evret	int
=	O
swevent_write_rpsh_event	function
(	O
swi_event_fd	int
,	O
news	pointer
,	O
len	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
evret	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error writing event pipe in write_error_line: %d\n"	pointer
,	O
evret	int
)	O
;	O
}	O
free	function
(	O
news	pointer
)	O
;	O
}	O
if	O
(	O
is_swi_event	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
do_log	int
=	O
1	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
do_log	int
=	O
0	int
;	O
}	O
do_stderr	int
=	O
swlib_test_verbose	function
(	O
ev	pointer
,	O
verbose_level	int
,	O
is_swbis_event	pointer
,	O
is_swi_event	int
,	O
event_status	int
,	O
is_posix_event	int
)	O
;	O
if	O
(	O
do_log	int
||	O
do_stderr	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
event_status	int
)	O
{	O
E_DEBUG	O
(	O
"calling writeline"	pointer
)	O
;	O
ret	int
=	O
writeline	function
(	O
do_stderr	int
,	O
do_log	int
,	O
logspec	pointer
->	O
logfdM	int
,	O
vefd	int
,	O
""	pointer
,	O
sptr	pointer
,	O
len	int
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
vofd	int
>=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"calling writeline"	pointer
)	O
;	O
ret	int
=	O
writeline	function
(	O
do_stderr	int
,	O
do_log	int
,	O
logspec	pointer
->	O
logfdM	int
,	O
vofd	int
,	O
""	pointer
,	O
sptr	pointer
,	O
len	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"nothing"	pointer
)	O
;	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
logspec	pointer
->	O
loglevelM	int
>	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
do_log	int
=	O
1	int
;	O
}	O
if	O
(	O
verbose_level	int
>	O
0	int
)	O
{	O
int	O
is_ssh	int
=	O
0	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
is_unix_sys_error	function
(	O
sptr	pointer
)	O
||	O
(	O
is_ssh	int
=	O
is_ssh_sys_error	function
(	O
sptr	pointer
)	O
)	O
||	O
verbose_level	int
>=	O
SWC_VERBOSE_6	int
)	O
{	O
E_DEBUG	O
(	O
"calling writeline"	pointer
)	O
;	O
do_stderr	int
=	O
1	int
;	O
if	O
(	O
is_ssh	int
)	O
{	O
ret	int
=	O
writeline	function
(	O
do_stderr	int
,	O
do_log	int
,	O
logspec	pointer
->	O
logfdM	int
,	O
vefd	int
,	O
"ssh: "	pointer
,	O
sptr	pointer
,	O
len	int
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
writeline	function
(	O
do_stderr	int
,	O
do_log	int
,	O
logspec	pointer
->	O
logfdM	int
,	O
vefd	int
,	O
""	pointer
,	O
sptr	pointer
,	O
len	int
)	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
logspec	pointer
->	O
loglevelM	int
>=	O
2	int
||	O
G_is_in_control_script	O
(	O
G	pointer
)	O
||	O
0	int
)	O
{	O
do_log	int
=	O
1	int
;	O
}	O
else	O
{	O
do_log	int
=	O
0	int
;	O
}	O
if	O
(	O
verbose_level	int
>=	O
G	pointer
->	O
g_verbose_threshold	int
||	O
G_is_in_control_script	O
(	O
G	pointer
)	O
||	O
0	int
)	O
{	O
do_stderr	int
=	O
1	int
;	O
}	O
else	O
{	O
do_stderr	int
=	O
0	int
;	O
}	O
E_DEBUG	O
(	O
"calling writeline"	pointer
)	O
;	O
ret	int
=	O
writeline	function
(	O
do_stderr	int
,	O
do_log	int
,	O
logspec	pointer
->	O
logfdM	int
,	O
vofd	int
,	O
""	pointer
,	O
sptr	pointer
,	O
len	int
)	O
;	O
}	O
}	O
}	O
return	O
ret	int
;	O
}	O
static	O
int	O
write_log	function
(	O
GB	struct
*	O
G	pointer
,	O
STROB	struct
*	O
linebuf	pointer
,	O
struct	O
sw_logspec	struct
*	O
logspec	pointer
,	O
int	O
vofd	int
,	O
int	O
vefd	int
,	O
void	O
*	O
bufa	pointer
,	O
size_t	long
len	int
,	O
int	O
verbose_level	int
,	O
int	O
swi_event_fd	int
)	O
{	O
char	O
*	O
s	pointer
;	O
char	O
s1	pointer
;	O
char	O
*	O
nl	pointer
;	O
int	O
ret	int
;	O
int	O
tot	int
=	O
0	int
;	O
strob_strncat	function
(	O
linebuf	pointer
,	O
(	O
char	O
*	O
)	O
bufa	pointer
,	O
len	int
)	O
;	O
s	pointer
=	O
strob_str	function
(	O
linebuf	pointer
)	O
;	O
nl	pointer
=	O
strpbrk	function
(	O
s	pointer
,	O
"\n"	pointer
)	O
;	O
while	O
(	O
nl	pointer
)	O
{	O
s1	pointer
=	O
*	O
(	O
nl	pointer
+	O
1	int
)	O
;	O
*	O
(	O
nl	pointer
+	O
1	int
)	O
=	O
'\0'	O
;	O
ret	int
=	O
write_error_line	function
(	O
G	pointer
,	O
logspec	pointer
,	O
vofd	int
,	O
vefd	int
,	O
linebuf	pointer
,	O
strlen	function
(	O
s	pointer
)	O
,	O
verbose_level	int
,	O
swi_event_fd	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ret	int
>	O
0	int
)	O
tot	int
+=	O
ret	int
;	O
*	O
(	O
nl	pointer
+	O
1	int
)	O
=	O
s1	pointer
;	O
memmove	function
(	O
s	pointer
,	O
(	O
nl	pointer
+	O
1	int
)	O
,	O
strlen	function
(	O
nl	pointer
+	O
1	int
)	O
+	O
1	int
)	O
;	O
nl	pointer
=	O
strpbrk	function
(	O
s	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
return	O
tot	int
;	O
}	O
static	O
int	O
do_run_cmd	function
(	O
SHCMD	struct
*	O
cmd	int
,	O
int	O
verbose_level	int
)	O
{	O
int	O
ret	int
;	O
SHCMD	struct
*	O
cmdvec	pointer
[	O
2	int
]	O
;	O
if	O
(	O
cmd	int
==	O
NULL	O
)	O
return	O
0	int
;	O
cmdvec	pointer
[	O
0	int
]	O
=	O
cmd	int
;	O
cmdvec	pointer
[	O
1	int
]	O
=	O
(	O
SHCMD	struct
*	O
)	O
NULL	O
;	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
3	int
,	O
0	int
,	O
STDERR_FILENO	int
,	O
"sending SIGTERM to remote script.\n"	pointer
)	O
;	O
if	O
(	O
verbose_level	int
>=	O
SWC_VERBOSE_6	int
)	O
{	O
shcmd_debug_show_command	function
(	O
cmdvec	pointer
[	O
0	int
]	O
,	O
STDERR_FILENO	int
)	O
;	O
}	O
shcmd_cmdvec_exec	function
(	O
cmdvec	pointer
)	O
;	O
shcmd_cmdvec_wait	function
(	O
cmdvec	pointer
)	O
;	O
ret	int
=	O
shcmd_get_exitval	function
(	O
cmdvec	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Error: client script shutdown failed.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: Stranded processes may be left on target and intermediate hosts.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: The failed command was: "	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
shcmd_debug_show_command	function
(	O
cmd	int
,	O
STDERR_FILENO	int
)	O
;	O
}	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
3	int
,	O
0	int
,	O
STDERR_FILENO	int
,	O
"remote kill returned %d\n"	pointer
,	O
ret	int
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
process_targetfile_line	function
(	O
STROB	struct
*	O
tmp	pointer
,	O
char	O
*	O
*	O
current_arg	pointer
)	O
{	O
char	O
*	O
end	pointer
;	O
char	O
*	O
line	pointer
;	O
strob_set_length	function
(	O
tmp	pointer
,	O
strob_strlen	function
(	O
tmp	pointer
)	O
+	O
2	int
)	O
;	O
line	pointer
=	O
strob_str	function
(	O
tmp	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
line	pointer
)	O
==	O
0	int
)	O
{	O
*	O
current_arg	pointer
=	O
line	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
(	O
end	pointer
=	O
strpbrk	function
(	O
line	pointer
,	O
"\n\r#"	pointer
)	O
)	O
)	O
{	O
*	O
end	pointer
=	O
'\0'	O
;	O
end	pointer
--	O
;	O
}	O
else	O
{	O
end	pointer
=	O
line	pointer
+	O
strlen	function
(	O
line	pointer
)	O
-	O
1	int
;	O
}	O
while	O
(	O
end	pointer
>	O
line	pointer
&&	O
isspace	function
(	O
*	O
end	pointer
)	O
)	O
{	O
*	O
end	pointer
=	O
'\0'	O
;	O
end	pointer
--	O
;	O
}	O
while	O
(	O
isspace	function
(	O
*	O
line	pointer
)	O
)	O
line	pointer
++	O
;	O
if	O
(	O
strlen	function
(	O
line	pointer
)	O
&&	O
*	O
line	pointer
!=	O
'@'	O
)	O
{	O
memmove	function
(	O
line	pointer
+	O
1	int
,	O
line	pointer
,	O
strlen	function
(	O
line	pointer
)	O
+	O
1	int
)	O
;	O
*	O
line	pointer
=	O
'@'	O
;	O
}	O
*	O
current_arg	pointer
=	O
line	pointer
;	O
return	O
strlen	function
(	O
line	pointer
)	O
;	O
}	O
static	O
void	O
get_dir_component	function
(	O
STROB	struct
*	O
ret	int
,	O
char	O
*	O
news	pointer
,	O
int	O
nf	int
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
i	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
20	int
)	O
;	O
i	int
=	O
0	int
;	O
s	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
news	pointer
,	O
"/"	pointer
)	O
;	O
while	O
(	O
s	pointer
&&	O
i	int
<	O
nf	int
)	O
{	O
s	pointer
=	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
"/"	pointer
)	O
;	O
i	int
++	O
;	O
}	O
if	O
(	O
s	pointer
)	O
{	O
if	O
(	O
strob_strtok	function
(	O
tmp	pointer
,	O
NULL	O
,	O
"/"	pointer
)	O
==	O
NULL	O
)	O
strob_strcpy	function
(	O
ret	int
,	O
""	pointer
)	O
;	O
else	O
strob_strcpy	function
(	O
ret	int
,	O
s	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
ret	int
,	O
""	pointer
)	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
}	O
static	O
STROB	struct
*	O
determine_longest_common_dir	function
(	O
STRAR	struct
*	O
p_sourcepath_list	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
char	O
*	O
dirname	pointer
;	O
int	O
is_same	int
;	O
int	O
nf	int
;	O
int	O
n	int
;	O
int	O
nrel	int
;	O
char	O
*	O
news	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
ret	int
;	O
char	O
*	O
current_dir	pointer
;	O
STRAR	struct
*	O
sourcepath_list	pointer
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
!	O
p_sourcepath_list	pointer
)	O
return	O
NULL	O
;	O
sourcepath_list	pointer
=	O
strar_copy_construct	function
(	O
p_sourcepath_list	pointer
)	O
;	O
if	O
(	O
!	O
sourcepath_list	pointer
)	O
return	O
NULL	O
;	O
ret	int
=	O
strob_open	function
(	O
24	int
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
24	int
)	O
;	O
dirname	pointer
=	O
NULL	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
n	int
=	O
0	int
;	O
nrel	int
=	O
0	int
;	O
while	O
(	O
(	O
s	pointer
=	O
strar_get	function
(	O
sourcepath_list	pointer
,	O
n	int
)	O
)	O
)	O
{	O
news	pointer
=	O
strdup	function
(	O
s	pointer
)	O
;	O
swlib_squash_all_dot_slash	function
(	O
news	pointer
)	O
;	O
swlib_squash_double_slash	function
(	O
news	pointer
)	O
;	O
swlib_squash_trailing_slash	function
(	O
news	pointer
)	O
;	O
if	O
(	O
*	O
news	pointer
!=	O
'/'	O
)	O
nrel	int
++	O
;	O
free	function
(	O
news	pointer
)	O
;	O
n	int
++	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
nrel	int
&&	O
nrel	int
!=	O
(	O
n	int
-	O
1	int
)	O
)	O
{	O
strob_close	function
(	O
ret	int
)	O
;	O
strar_close	function
(	O
sourcepath_list	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
strar_qsort	function
(	O
sourcepath_list	pointer
,	O
strar_qsort_neg_strcmp	function
)	O
;	O
if	O
(	O
nrel	int
==	O
0	int
)	O
{	O
strob_strcpy	function
(	O
ret	int
,	O
"/"	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
current_dir	pointer
=	O
NULL	O
;	O
nf	int
=	O
0	int
;	O
is_same	int
=	O
1	int
;	O
while	O
(	O
is_same	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
nf	int
++	O
;	O
n	int
=	O
0	int
;	O
while	O
(	O
(	O
s	pointer
=	O
strar_get	function
(	O
sourcepath_list	pointer
,	O
n	int
)	O
)	O
)	O
{	O
E_DEBUG2	O
(	O
"s=[%s]"	pointer
,	O
s	pointer
)	O
;	O
news	pointer
=	O
strdup	function
(	O
s	pointer
)	O
;	O
swlib_squash_all_dot_slash	function
(	O
news	pointer
)	O
;	O
swlib_squash_trailing_slash	function
(	O
news	pointer
)	O
;	O
swlib_squash_double_slash	function
(	O
news	pointer
)	O
;	O
get_dir_component	function
(	O
tmp	pointer
,	O
news	pointer
,	O
nf	int
-	O
1	int
)	O
;	O
E_DEBUG2	O
(	O
"component is [%s]"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
if	O
(	O
current_dir	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
strob_strlen	function
(	O
tmp	pointer
)	O
)	O
{	O
current_dir	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
else	O
{	O
is_same	int
=	O
0	int
;	O
}	O
E_DEBUG2	O
(	O
"setting current_dir=[%s]"	pointer
,	O
current_dir	pointer
)	O
;	O
}	O
else	O
{	O
E_DEBUG2	O
(	O
"current_dir is already [%s]"	pointer
,	O
current_dir	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
,	O
current_dir	pointer
)	O
!=	O
0	int
)	O
{	O
is_same	int
=	O
0	int
;	O
E_DEBUG3	O
(	O
"found difference [%s] [%s]"	pointer
,	O
current_dir	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
free	function
(	O
current_dir	pointer
)	O
;	O
current_dir	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
else	O
{	O
;	O
}	O
}	O
n	int
++	O
;	O
free	function
(	O
news	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
"out of while"	pointer
)	O
;	O
if	O
(	O
current_dir	pointer
)	O
{	O
E_DEBUG2	O
(	O
"dir catting [%s]"	pointer
,	O
current_dir	pointer
)	O
;	O
swlib_unix_dircat	function
(	O
ret	int
,	O
current_dir	pointer
)	O
;	O
free	function
(	O
current_dir	pointer
)	O
;	O
current_dir	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
"s == NULL"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
E_DEBUG2	O
(	O
"returning [%s]"	pointer
,	O
strob_str	function
(	O
ret	int
)	O
)	O
;	O
strar_close	function
(	O
sourcepath_list	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
STROB	struct
*	O
swc_make_multiplepathlist	function
(	O
STRAR	struct
*	O
sourcepath_listM	pointer
,	O
STROB	struct
*	O
rootdir	pointer
,	O
STROB	struct
*	O
firstpath	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
char	O
*	O
b	pointer
;	O
char	O
*	O
dir2	pointer
;	O
char	O
*	O
base	int
;	O
int	O
n	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
strb	pointer
;	O
STROB	struct
*	O
lpath	pointer
;	O
lpath	pointer
=	O
determine_longest_common_dir	function
(	O
sourcepath_listM	pointer
)	O
;	O
if	O
(	O
lpath	pointer
==	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
"return NULL"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
rootdir	pointer
)	O
{	O
strob_strcpy	function
(	O
rootdir	pointer
,	O
strob_str	function
(	O
lpath	pointer
)	O
)	O
;	O
E_DEBUG2	O
(	O
"rootdir is [%s]"	pointer
,	O
strob_str	function
(	O
rootdir	pointer
)	O
)	O
;	O
}	O
base	int
=	O
strob_str	function
(	O
lpath	pointer
)	O
;	O
E_DEBUG2	O
(	O
"base is [%s]"	pointer
,	O
base	int
)	O
;	O
strb	pointer
=	O
strob_open	function
(	O
24	int
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
24	int
)	O
;	O
n	int
=	O
0	int
;	O
while	O
(	O
(	O
s	pointer
=	O
strar_get	function
(	O
sourcepath_listM	pointer
,	O
n	int
)	O
)	O
)	O
{	O
E_DEBUG2	O
(	O
"s=[%s]"	pointer
,	O
s	pointer
)	O
;	O
swlib_squash_trailing_slash	function
(	O
s	pointer
)	O
;	O
b	pointer
=	O
strstr	function
(	O
s	pointer
,	O
base	int
)	O
;	O
if	O
(	O
b	pointer
==	O
NULL	O
||	O
b	pointer
!=	O
s	pointer
)	O
{	O
E_DEBUG	O
(	O
"return NULL"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
else	O
{	O
dir2	pointer
=	O
s	pointer
+	O
strlen	function
(	O
base	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
base	int
,	O
"/"	pointer
)	O
)	O
{	O
if	O
(	O
*	O
dir2	pointer
!=	O
'/'	O
)	O
{	O
E_DEBUG	O
(	O
"return NULL"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
dir2	pointer
++	O
;	O
}	O
else	O
{	O
;	O
}	O
E_DEBUG2	O
(	O
"dir2=[%s]"	pointer
,	O
dir2	pointer
)	O
;	O
strob_sprintf	function
(	O
strb	pointer
,	O
1	int
,	O
"\"%s\" "	pointer
,	O
(	O
strlen	function
(	O
dir2	pointer
)	O
==	O
0	int
?	O
"."	pointer
:	O
dir2	pointer
)	O
)	O
;	O
if	O
(	O
firstpath	pointer
)	O
strob_strcpy	function
(	O
firstpath	pointer
,	O
dir2	pointer
)	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
n	int
++	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
lpath	pointer
)	O
;	O
E_DEBUG2	O
(	O
"list is [%s]"	pointer
,	O
strob_str	function
(	O
strb	pointer
)	O
)	O
;	O
return	O
strb	pointer
;	O
}	O
char	O
*	O
swc_print_umask	function
(	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	int
)	O
{	O
int	O
ret	int
;	O
mode_t	int
mode	int
=	O
swlib_get_umask	function
(	O
)	O
;	O
ret	int
=	O
snprintf	function
(	O
buf	pointer
,	O
len	int
-	O
1	int
,	O
"%03o"	pointer
,	O
(	O
unsigned	O
int	O
)	O
mode	int
)	O
;	O
buf	pointer
[	O
ret	int
]	O
=	O
'\0'	O
;	O
return	O
buf	pointer
;	O
}	O
ERRORCODE	struct
*	O
createErrorCode	function
(	O
void	O
)	O
{	O
ERRORCODE	struct
*	O
ec	pointer
=	O
(	O
ERRORCODE	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
ERRORCODE	struct
)	O
)	O
;	O
ec	pointer
->	O
codeM	pointer
=	O
0	int
;	O
return	O
ec	pointer
;	O
}	O
void	O
destroyErrorCode	function
(	O
ERRORCODE	struct
*	O
EC	pointer
)	O
{	O
free	function
(	O
EC	pointer
)	O
;	O
}	O
void	O
swc_setErrorCode	function
(	O
ERRORCODE	struct
*	O
EC	pointer
,	O
int	O
code	int
,	O
char	O
*	O
msg	pointer
)	O
{	O
EC	pointer
->	O
codeM	pointer
=	O
code	int
;	O
}	O
int	O
swc_getErrorCode	function
(	O
ERRORCODE	struct
*	O
EC	pointer
)	O
{	O
return	O
EC	pointer
->	O
codeM	pointer
;	O
}	O
void	O
swc_copyright_info	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
"Copyright (C) 2004,2005,2006,2007,2008,2009,2010 Jim Lowe\n"	pointer
"Portions are copyright 1985-2000 Free Software Foundation, Inc.\n"	pointer
"This software is distributed under the terms of the GNU General Public License\n"	pointer
"and comes with NO WARRANTY to the extent permitted by law.\n"	pointer
"See the file named COPYING for details.\n"	pointer
)	O
;	O
}	O
int	O
swc_parse_soc_spec	function
(	O
char	O
*	O
arg	pointer
,	O
char	O
*	O
*	O
selections	pointer
,	O
char	O
*	O
*	O
target	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
*	O
target	pointer
=	O
NULL	O
;	O
*	O
selections	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
arg	pointer
)	O
{	O
*	O
selections	pointer
=	O
NULL	O
;	O
*	O
target	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"@:"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
strlen	function
(	O
arg	pointer
)	O
>	O
2	int
)	O
{	O
*	O
target	pointer
=	O
strdup	function
(	O
arg	pointer
+	O
1	int
)	O
;	O
}	O
else	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
!=	O
'@'	O
)	O
{	O
*	O
selections	pointer
=	O
strdup	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
(	O
p	pointer
=	O
strrchr	function
(	O
*	O
selections	pointer
,	O
(	O
int	O
)	O
'@'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
*	O
target	pointer
=	O
strdup	function
(	O
p	pointer
+	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
arg	pointer
[	O
0	int
]	O
==	O
'@'	O
)	O
{	O
*	O
target	pointer
=	O
strdup	function
(	O
arg	pointer
+	O
1	int
)	O
;	O
}	O
else	O
{	O
;	O
}	O
if	O
(	O
*	O
target	pointer
&&	O
*	O
*	O
target	pointer
==	O
':'	O
)	O
*	O
target	pointer
=	O
strdup	function
(	O
++	O
(	O
*	O
target	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swc_construct_newkill_vector	function
(	O
SHCMD	struct
*	O
kmd	pointer
,	O
int	O
nhops	int
,	O
STRAR	struct
*	O
tramp_list	pointer
,	O
char	O
*	O
script_pid	pointer
,	O
int	O
verbose_level	int
)	O
{	O
int	O
i	int
=	O
0	int
;	O
char	O
*	O
*	O
argvec	pointer
;	O
char	O
*	O
clientmsg	pointer
;	O
char	O
*	O
pid	int
;	O
char	O
*	O
s	pointer
;	O
char	O
*	O
h	pointer
;	O
if	O
(	O
!	O
script_pid	pointer
||	O
strlen	function
(	O
script_pid	pointer
)	O
==	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
7	int
,	O
0	int
,	O
STDERR_FILENO	int
,	O
"In swc_construct_newkill_vector: looping thru argvec\n"	pointer
)	O
;	O
argvec	pointer
=	O
shcmd_get_argvector	function
(	O
kmd	pointer
)	O
;	O
while	O
(	O
*	O
argvec	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
*	O
argvec	pointer
,	O
SWC_KILL_PID_MARK	pointer
)	O
==	O
0	int
)	O
{	O
clientmsg	pointer
=	O
strar_get	function
(	O
tramp_list	pointer
,	O
i	int
++	O
)	O
;	O
if	O
(	O
!	O
clientmsg	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
strlen	function
(	O
clientmsg	pointer
)	O
==	O
0	int
)	O
return	O
-	O
2	int
;	O
pid	int
=	O
strrchr	function
(	O
clientmsg	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
pid	int
)	O
return	O
-	O
3	int
;	O
if	O
(	O
strlen	function
(	O
pid	int
)	O
==	O
0	int
)	O
return	O
-	O
4	int
;	O
pid	int
++	O
;	O
s	pointer
=	O
pid	int
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
isdigit	function
(	O
(	O
int	O
)	O
*	O
s	pointer
)	O
)	O
return	O
-	O
5	int
;	O
s	pointer
++	O
;	O
}	O
*	O
(	O
pid	int
-	O
1	int
)	O
=	O
'\0'	O
;	O
h	pointer
=	O
strrchr	function
(	O
clientmsg	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
h	pointer
)	O
return	O
-	O
8	int
;	O
h	pointer
++	O
;	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
7	int
,	O
0	int
,	O
STDERR_FILENO	int
,	O
"construct_newkill_vector: list:  host:pid [%s:%s]\n"	pointer
,	O
h	pointer
,	O
pid	int
)	O
;	O
*	O
argvec	pointer
=	O
strdup	function
(	O
pid	int
)	O
;	O
}	O
argvec	pointer
++	O
;	O
}	O
if	O
(	O
i	int
!=	O
nhops	int
-	O
1	int
)	O
return	O
-	O
9	int
;	O
clientmsg	pointer
=	O
strar_get	function
(	O
tramp_list	pointer
,	O
i	int
)	O
;	O
if	O
(	O
clientmsg	pointer
)	O
{	O
if	O
(	O
strstr	function
(	O
clientmsg	pointer
,	O
SWBIS_TARGET_CTL_MSG_125	pointer
)	O
!=	O
clientmsg	pointer
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
-	O
1	int
,	O
0	int
,	O
STDERR_FILENO	int
,	O
"construct_newkill_vector: unexpected tramp in the list: %s]\n"	pointer
,	O
strar_get	function
(	O
tramp_list	pointer
,	O
i	int
)	O
)	O
;	O
return	O
-	O
12	int
;	O
}	O
}	O
else	O
{	O
return	O
-	O
14	int
;	O
}	O
argvec	pointer
=	O
shcmd_get_argvector	function
(	O
kmd	pointer
)	O
;	O
while	O
(	O
*	O
argvec	pointer
)	O
{	O
if	O
(	O
*	O
(	O
argvec	pointer
+	O
1	int
)	O
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
shcmd_add_arg	function
(	O
kmd	pointer
,	O
"kill"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
kmd	pointer
,	O
script_pid	pointer
)	O
;	O
break	O
;	O
}	O
argvec	pointer
++	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
swc_form_command_args	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
context	pointer
,	O
char	O
*	O
targetpath	pointer
,	O
STRAR	struct
*	O
target_cmdlist	pointer
,	O
int	O
opt_preview	int
,	O
int	O
nhops	int
,	O
int	O
opt_no_getconf	int
,	O
char	O
*	O
landing_shell	pointer
)	O
{	O
STROB	struct
*	O
tmpcommand	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
targetpath	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
strar_add	function
(	O
target_cmdlist	pointer
,	O
"/bin/cat"	pointer
)	O
;	O
}	O
else	O
{	O
strob_strcpy	function
(	O
tmpcommand	pointer
,	O
swssh_landing_command	function
(	O
landing_shell	pointer
,	O
opt_no_getconf	int
)	O
)	O
;	O
if	O
(	O
G	pointer
->	O
g_do_cleanshM	int
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
tmpcommand	pointer
,	O
STROB_DO_APPEND	int
,	O
" _swbis _%s"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
}	O
else	O
{	O
;	O
}	O
swssh_protect_shell_metacharacters	function
(	O
tmpcommand	pointer
,	O
nhops	int
,	O
CMD_TAINTED_CHARS	pointer
)	O
;	O
strar_add	function
(	O
target_cmdlist	pointer
,	O
strob_str	function
(	O
tmpcommand	pointer
)	O
)	O
;	O
}	O
strob_close	function
(	O
tmpcommand	pointer
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
swc_make_absolute_path	function
(	O
char	O
*	O
target_current_dir	pointer
,	O
char	O
*	O
target_path	pointer
)	O
{	O
char	O
*	O
ret	int
;	O
STROB	struct
*	O
tmp	pointer
;	O
if	O
(	O
*	O
target_path	pointer
==	O
'/'	O
)	O
return	O
target_path	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
target_current_dir	pointer
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
"/"	pointer
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
target_path	pointer
)	O
;	O
ret	int
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
char	O
*	O
swc_validate_targetpath	function
(	O
int	O
nhops	int
,	O
char	O
*	O
targetpath	pointer
,	O
char	O
*	O
default_target	pointer
,	O
char	O
*	O
cwd	short
,	O
char	O
*	O
context	pointer
)	O
{	O
if	O
(	O
nhops	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s error\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
context	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
targetpath	pointer
==	O
NULL	O
)	O
{	O
targetpath	pointer
=	O
default_target	pointer
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
nhops	int
==	O
0	int
&&	O
*	O
targetpath	pointer
==	O
':'	O
)	O
{	O
if	O
(	O
*	O
(	O
targetpath	pointer
+	O
1	int
)	O
!=	O
'/'	O
&&	O
*	O
(	O
targetpath	pointer
+	O
1	int
)	O
!=	O
'-'	O
)	O
{	O
STROB	struct
*	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
cwd	short
)	O
;	O
swlib_unix_dircat	function
(	O
tmp	pointer
,	O
targetpath	pointer
+	O
1	int
)	O
;	O
targetpath	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
}	O
else	O
{	O
targetpath	pointer
++	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
nhops	int
==	O
0	int
&&	O
strncmp	function
(	O
targetpath	pointer
,	O
"\\:"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
targetpath	pointer
++	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
nhops	int
>	O
0	int
&&	O
strcmp	function
(	O
default_target	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
default_target	pointer
=	O
"."	pointer
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
targetpath	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
||	O
strlen	function
(	O
targetpath	pointer
)	O
==	O
0	int
)	O
{	O
targetpath	pointer
=	O
default_target	pointer
;	O
if	O
(	O
nhops	int
>=	O
1	int
&&	O
(	O
*	O
targetpath	pointer
)	O
==	O
'\0'	O
)	O
{	O
targetpath	pointer
=	O
strdup	function
(	O
"/"	pointer
)	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
swlib_is_sh_tainted_string	function
(	O
targetpath	pointer
)	O
)	O
{	O
E_DEBUG2	O
(	O
"string tainted with shell meta-characters: %s"	pointer
,	O
targetpath	pointer
)	O
;	O
swlib_doif_writef	O
(	O
1	int
,	O
-	O
1	int
,	O
0	int
,	O
STDERR_FILENO	int
,	O
"%s directory name is tainted with shell meta-characters\n"	pointer
,	O
context	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
targetpath	pointer
,	O
"-"	pointer
)	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
targetpath	pointer
,	O
"."	pointer
)	O
==	O
0	int
)	O
{	O
;	O
}	O
else	O
if	O
(	O
nhops	int
<	O
1	int
&&	O
*	O
targetpath	pointer
!=	O
'/'	O
)	O
{	O
swlib_doif_writef	O
(	O
1	int
,	O
-	O
1	int
,	O
0	int
,	O
STDERR_FILENO	int
,	O
"target path [%s] not absolute.\n"	pointer
,	O
targetpath	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
strdup	function
(	O
targetpath	pointer
)	O
;	O
}	O
int	O
swc_do_preview_cmd	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
prefix	pointer
,	O
FILE	struct
*	O
fver	pointer
,	O
char	O
*	O
targetpath	pointer
,	O
SHCMD	struct
*	O
sshcmd	pointer
,	O
SHCMD	struct
*	O
kmd	pointer
,	O
char	O
*	O
cl_target	pointer
,	O
STRAR	struct
*	O
cmdlist	pointer
,	O
int	O
nhops	int
,	O
int	O
do_first	int
,	O
int	O
opt_no_getconf	int
,	O
char	O
*	O
landing_shell	pointer
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
char	O
*	O
*	O
argvec	pointer
;	O
char	O
*	O
*	O
args	pointer
;	O
char	O
*	O
*	O
p	pointer
;	O
if	O
(	O
do_first	int
)	O
ret	int
=	O
swc_form_command_args	function
(	O
G	pointer
,	O
"target"	pointer
,	O
targetpath	pointer
,	O
cmdlist	pointer
,	O
1	int
,	O
nhops	int
,	O
opt_no_getconf	int
,	O
landing_shell	pointer
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
ret	int
=	O
swssh_assemble_ssh_cmd	function
(	O
sshcmd	pointer
,	O
cmdlist	pointer
,	O
(	O
STRAR	struct
*	O
)	O
NULL	O
,	O
nhops	int
)	O
;	O
if	O
(	O
ret	int
)	O
{	O
return	O
-	O
2	int
;	O
}	O
args	pointer
=	O
shcmd_get_argvector	function
(	O
sshcmd	pointer
)	O
;	O
p	pointer
=	O
args	pointer
;	O
while	O
(	O
p	pointer
&&	O
*	O
p	pointer
)	O
{	O
fprintf	function
(	O
fver	pointer
,	O
"[%s]"	pointer
,	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
}	O
fprintf	function
(	O
fver	pointer
,	O
"\n"	pointer
)	O
;	O
argvec	pointer
=	O
shcmd_get_argvector	function
(	O
kmd	pointer
)	O
;	O
while	O
(	O
*	O
argvec	pointer
)	O
{	O
if	O
(	O
*	O
(	O
argvec	pointer
+	O
1	int
)	O
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
shcmd_add_arg	function
(	O
kmd	pointer
,	O
"kill"	pointer
)	O
;	O
shcmd_add_arg	function
(	O
kmd	pointer
,	O
"$PPID"	pointer
)	O
;	O
break	O
;	O
}	O
argvec	pointer
++	O
;	O
}	O
fprintf	function
(	O
fver	pointer
,	O
"%s"	pointer
,	O
prefix	pointer
)	O
;	O
args	pointer
=	O
shcmd_get_argvector	function
(	O
kmd	pointer
)	O
;	O
p	pointer
=	O
args	pointer
;	O
while	O
(	O
p	pointer
&&	O
*	O
p	pointer
)	O
{	O
fprintf	function
(	O
fver	pointer
,	O
"[%s]"	pointer
,	O
*	O
p	pointer
)	O
;	O
p	pointer
++	O
;	O
}	O
fprintf	function
(	O
fver	pointer
,	O
"\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
swc_initialize_logspec	function
(	O
struct	O
sw_logspec	struct
*	O
logspec	pointer
,	O
char	O
*	O
logfile	pointer
,	O
int	O
log_level	int
)	O
{	O
int	O
fd	int
;	O
logspec	pointer
->	O
loglevelM	int
=	O
0	int
;	O
logspec	pointer
->	O
logfdM	int
=	O
-	O
1	int
;	O
if	O
(	O
log_level	int
>	O
0	int
)	O
{	O
fd	int
=	O
swc_open_logfile	function
(	O
logfile	pointer
)	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
logspec	pointer
->	O
logfdM	int
=	O
fd	int
;	O
logspec	pointer
->	O
loglevelM	int
=	O
log_level	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error opening logfile : %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
logfile	pointer
)	O
;	O
}	O
}	O
return	O
;	O
}	O
int	O
swc_open_logfile	function
(	O
char	O
*	O
logfile	pointer
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
open	function
(	O
logfile	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_APPEND	int
,	O
0644	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swc_open_filename	function
(	O
char	O
*	O
sourcefilename	pointer
,	O
int	O
*	O
open_errorp	pointer
)	O
{	O
int	O
fd	int
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
flag	int
;	O
*	O
open_errorp	pointer
=	O
-	O
1	int
;	O
if	O
(	O
strcmp	function
(	O
sourcefilename	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
open_errorp	pointer
=	O
0	int
;	O
return	O
STDIN_FILENO	int
;	O
}	O
if	O
(	O
stat	struct
(	O
sourcefilename	pointer
,	O
&	O
st	pointer
)	O
<	O
0	int
)	O
{	O
*	O
open_errorp	pointer
=	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
*	O
open_errorp	pointer
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
S_ISCHR	O
(	O
st	pointer
.	O
st_mode	int
)	O
||	O
S_ISBLK	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
flag	int
=	O
O_RDONLY	int
;	O
}	O
else	O
{	O
flag	int
=	O
O_RDONLY	int
;	O
}	O
fd	int
=	O
open	function
(	O
sourcefilename	pointer
,	O
flag	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"open error : (%s) : %s\n"	pointer
,	O
sourcefilename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
*	O
open_errorp	pointer
=	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
open_errorp	pointer
=	O
0	int
;	O
return	O
fd	int
;	O
}	O
pid_t	int
swc_run_ssh_command	function
(	O
GB	struct
*	O
G	pointer
,	O
SHCMD	struct
*	O
*	O
sshcmd	pointer
,	O
STRAR	struct
*	O
cmdlist	pointer
,	O
char	O
*	O
path	pointer
,	O
int	O
opt_preview	int
,	O
int	O
nhops	int
,	O
int	O
*	O
o_fdar	pointer
,	O
int	O
*	O
i_fdar	pointer
,	O
struct	O
termios	struct
*	O
login_orig_termiosP	pointer
,	O
struct	O
winsize	struct
*	O
login_sizeP	pointer
,	O
pid_t	int
*	O
pump_pid	pointer
,	O
char	O
*	O
fork_type	pointer
,	O
int	O
make_master_raw	int
,	O
sigset_t	struct
*	O
ignoremask	pointer
,	O
int	O
is_no_fork_ok	int
,	O
int	O
verbose_level	int
,	O
int	O
*	O
source_file_size	pointer
,	O
int	O
opt_no_getconf	int
,	O
int	O
*	O
is_local_fd	pointer
,	O
char	O
*	O
landing_shell	pointer
,	O
int	O
error_fd	int
,	O
struct	O
sw_logspec	struct
*	O
logspec	pointer
)	O
{	O
int	O
did_open	int
=	O
0	int
;	O
int	O
i_fdm	array
[	O
3	int
]	O
;	O
int	O
fdm	array
[	O
3	int
]	O
;	O
pid_t	int
ts_pid	int
;	O
int	O
ret	int
;	O
int	O
fd	int
;	O
*	O
pump_pid	pointer
=	O
0	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG2	O
(	O
"path=[%s]"	pointer
,	O
path	pointer
)	O
;	O
E_DEBUG2	O
(	O
"nhops=[%d]"	pointer
,	O
nhops	int
)	O
;	O
E_DEBUG2	O
(	O
"is_no_fork_ok=[%d]"	pointer
,	O
is_no_fork_ok	int
)	O
;	O
if	O
(	O
source_file_size	pointer
)	O
*	O
source_file_size	pointer
=	O
0	int
;	O
if	O
(	O
is_local_fd	pointer
)	O
*	O
is_local_fd	pointer
=	O
0	int
;	O
if	O
(	O
is_no_fork_ok	int
>	O
0	int
&&	O
nhops	int
==	O
0	int
&&	O
*	O
path	pointer
==	O
'/'	O
&&	O
1	int
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
E_DEBUG	O
(	O
"Local File"	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
path	pointer
,	O
&	O
st	pointer
)	O
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
1	int
,	O
logspec	pointer
,	O
error_fd	int
,	O
"SW_SOURCE_ACCESS_ERROR while accessing local file %s : %s\n"	pointer
,	O
path	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
2	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
st	pointer
.	O
st_mode	int
)	O
&&	O
G	pointer
->	O
g_do_createM	int
==	O
0	int
&&	O
1	int
)	O
{	O
if	O
(	O
source_file_size	pointer
)	O
{	O
*	O
source_file_size	pointer
=	O
(	O
int	O
)	O
(	O
st	pointer
.	O
st_size	long
)	O
;	O
}	O
fd	int
=	O
open	function
(	O
path	pointer
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"open error %s : %s\n"	pointer
,	O
path	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
S_ISREG	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
if	O
(	O
is_local_fd	pointer
)	O
*	O
is_local_fd	pointer
=	O
1	int
;	O
i_fdm	array
[	O
0	int
]	O
=	O
fd	int
;	O
i_fdm	array
[	O
1	int
]	O
=	O
open	function
(	O
"/dev/null"	pointer
,	O
O_RDWR	int
,	O
0	int
)	O
;	O
i_fdm	array
[	O
2	int
]	O
=	O
i_fdar	pointer
[	O
2	int
]	O
;	O
did_open	int
=	O
1	int
;	O
fork_type	pointer
=	O
SWFORK_NO_FORK	pointer
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
verbose_level	int
>	O
SWC_VERBOSE_8	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Local file opened : %s\n"	pointer
,	O
path	pointer
)	O
;	O
}	O
}	O
}	O
E_DEBUG2	O
(	O
"did_open=%d"	pointer
,	O
did_open	int
)	O
;	O
if	O
(	O
did_open	int
==	O
0	int
)	O
{	O
i_fdm	array
[	O
0	int
]	O
=	O
i_fdar	pointer
[	O
0	int
]	O
;	O
i_fdm	array
[	O
1	int
]	O
=	O
i_fdar	pointer
[	O
1	int
]	O
;	O
i_fdm	array
[	O
2	int
]	O
=	O
i_fdar	pointer
[	O
2	int
]	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
swc_form_command_args	function
(	O
G	pointer
,	O
"target"	pointer
,	O
path	pointer
,	O
cmdlist	pointer
,	O
opt_preview	int
,	O
nhops	int
,	O
opt_no_getconf	int
,	O
landing_shell	pointer
)	O
;	O
SWLIB_ASSERT	O
(	O
ret	int
==	O
0	int
)	O
;	O
ret	int
=	O
swssh_assemble_ssh_cmd	function
(	O
sshcmd	pointer
[	O
0	int
]	O
,	O
cmdlist	pointer
,	O
(	O
STRAR	struct
*	O
)	O
(	O
NULL	O
)	O
,	O
nhops	int
)	O
;	O
SWLIB_ASSERT	O
(	O
ret	int
==	O
0	int
)	O
;	O
}	O
if	O
(	O
nhops	int
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"Set sigdelset(ignoremask, SIGINT);"	pointer
)	O
;	O
sigdelset	function
(	O
ignoremask	pointer
,	O
SIGINT	int
)	O
;	O
}	O
ts_pid	int
=	O
swlib_fork	function
(	O
fork_type	pointer
,	O
fdm	array
,	O
i_fdm	array
[	O
1	int
]	O
,	O
i_fdm	array
[	O
0	int
]	O
,	O
i_fdm	array
[	O
2	int
]	O
,	O
login_orig_termiosP	pointer
,	O
login_sizeP	pointer
,	O
pump_pid	pointer
,	O
make_master_raw	int
,	O
ignoremask	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
fork_type	pointer
,	O
SWFORK_NO_FORK	pointer
)	O
!=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"Fork Happened"	pointer
)	O
;	O
if	O
(	O
ts_pid	int
==	O
0	int
)	O
{	O
if	O
(	O
verbose_level	int
>=	O
SWC_VERBOSE_4	int
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_4	int
,	O
0	int
,	O
STDERR_FILENO	int
,	O
"Executing : "	pointer
)	O
;	O
shcmd_debug_show_command	function
(	O
sshcmd	pointer
[	O
0	int
]	O
,	O
STDERR_FILENO	int
)	O
;	O
}	O
swgp_close_all_fd	function
(	O
3	int
)	O
;	O
if	O
(	O
nhops	int
>=	O
1	int
)	O
{	O
swc_set_sig_ign_by_mask	function
(	O
ignoremask	pointer
)	O
;	O
}	O
shcmd_unix_execve	function
(	O
sshcmd	pointer
[	O
0	int
]	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"exec failed\n"	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
ts_pid	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fork error : %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
;	O
E_DEBUG	O
(	O
"No Fork Happened"	pointer
)	O
;	O
}	O
o_fdar	pointer
[	O
0	int
]	O
=	O
fdm	array
[	O
0	int
]	O
;	O
o_fdar	pointer
[	O
1	int
]	O
=	O
fdm	array
[	O
1	int
]	O
;	O
o_fdar	pointer
[	O
2	int
]	O
=	O
fdm	array
[	O
2	int
]	O
;	O
return	O
ts_pid	int
;	O
}	O
int	O
swc_analyze_status_array	function
(	O
pid_t	int
*	O
pid	int
,	O
int	O
num	int
,	O
int	O
*	O
status	int
,	O
int	O
debug	int
)	O
{	O
int	O
i	int
;	O
int	O
ret	int
=	O
0	int
;	O
int	O
x	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pid	int
[	O
i	int
]	O
<	O
0	int
&&	O
status	int
[	O
i	int
]	O
)	O
{	O
if	O
(	O
WIFEXITED	O
(	O
status	int
[	O
i	int
]	O
)	O
)	O
{	O
x	pointer
=	O
WEXITSTATUS	O
(	O
status	int
[	O
i	int
]	O
)	O
;	O
if	O
(	O
x	pointer
)	O
ret	int
++	O
;	O
if	O
(	O
debug	int
>=	O
SWC_VERBOSE_IDB	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"status[pid=%d] exit val = %d\n"	pointer
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
,	O
x	pointer
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: process[pid=%d] failed to exit normally\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
pid	int
[	O
i	int
]	O
)	O
;	O
ret	int
++	O
;	O
}	O
}	O
}	O
return	O
ret	int
;	O
}	O
int	O
swc_do_run_kill_cmd	function
(	O
SHCMD	struct
*	O
killcmd	pointer
,	O
SHCMD	struct
*	O
target_kmd	pointer
,	O
SHCMD	struct
*	O
source_kmd	pointer
,	O
int	O
verbose_level	int
)	O
{	O
int	O
ret	int
;	O
ret	int
=	O
do_run_cmd	function
(	O
killcmd	pointer
,	O
verbose_level	int
)	O
;	O
ret	int
=	O
do_run_cmd	function
(	O
target_kmd	pointer
,	O
verbose_level	int
)	O
;	O
ret	int
=	O
do_run_cmd	function
(	O
source_kmd	pointer
,	O
verbose_level	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swc_checkbasename	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
strlen	function
(	O
s	pointer
)	O
>	O
1	int
)	O
if	O
(	O
!	O
s	pointer
||	O
*	O
s	pointer
==	O
'\0'	O
||	O
*	O
s	pointer
==	O
'/'	O
||	O
strchr	function
(	O
s	pointer
,	O
'/'	O
)	O
||	O
s	pointer
[	O
strlen	function
(	O
s	pointer
)	O
-	O
1	int
]	O
==	O
'/'	O
||	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
swc_record_pid	function
(	O
pid_t	int
pid	int
,	O
pid_t	int
*	O
p_pid_array	pointer
,	O
int	O
*	O
p_pid_array_len	pointer
,	O
int	O
verbose_level	int
)	O
{	O
if	O
(	O
*	O
p_pid_array_len	pointer
<	O
SWC_PID_ARRAY_LEN	int
&&	O
pid	int
>	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
verbose_level	int
,	O
SWC_VERBOSE_IDB	int
,	O
0	int
,	O
STDERR_FILENO	int
,	O
"%s : record_pid [%d]\n"	pointer
,	O
SW_UTILNAME	pointer
,	O
(	O
int	O
)	O
pid	int
)	O
;	O
p_pid_array	pointer
[	O
(	O
*	O
p_pid_array_len	pointer
)	O
]	O
=	O
pid	int
;	O
p_pid_array	pointer
[	O
(	O
*	O
p_pid_array_len	pointer
)	O
+	O
SWC_PID_ARRAY_LEN	int
]	O
=	O
pid	int
;	O
(	O
*	O
p_pid_array_len	pointer
)	O
++	O
;	O
}	O
}	O
void	O
swc_set_sig_ign_by_mask	function
(	O
sigset_t	struct
*	O
ignoremask	pointer
)	O
{	O
if	O
(	O
sigismember	function
(	O
ignoremask	pointer
,	O
SIGTERM	int
)	O
)	O
{	O
swgp_signal	function
(	O
SIGTERM	int
,	O
SIG_IGN	O
)	O
;	O
}	O
if	O
(	O
sigismember	function
(	O
ignoremask	pointer
,	O
SIGALRM	int
)	O
)	O
{	O
swgp_signal	function
(	O
SIGALRM	int
,	O
SIG_IGN	O
)	O
;	O
}	O
if	O
(	O
sigismember	function
(	O
ignoremask	pointer
,	O
SIGINT	int
)	O
)	O
{	O
swgp_signal	function
(	O
SIGINT	int
,	O
SIG_IGN	O
)	O
;	O
}	O
}	O
int	O
swc_process_selection_files	function
(	O
GB	struct
*	O
G	pointer
,	O
VPLOB	union
*	O
swspec_list	pointer
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
n	int
;	O
int	O
i	int
;	O
int	O
fd	int
;	O
int	O
retval	int
;	O
SWVERID	struct
*	O
swverid	pointer
=	O
NULL	O
;	O
retval	int
=	O
0	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SWC_TARGET_FD_ARRAY_LEN	int
;	O
i	int
++	O
)	O
{	O
fd	int
=	O
G	pointer
->	O
g_selectfd_array	array
[	O
i	int
]	O
;	O
if	O
(	O
fd	int
>=	O
0	int
)	O
{	O
while	O
(	O
(	O
n	int
=	O
swgp_read_line	function
(	O
fd	int
,	O
(	O
STROB	struct
*	O
)	O
tmp	pointer
,	O
DO_NOT_APPEND	int
)	O
)	O
>	O
0	int
)	O
{	O
s	pointer
=	O
strob_str	function
(	O
tmp	pointer
)	O
;	O
while	O
(	O
swlib_squash_trailing_char	function
(	O
s	pointer
,	O
'\n'	O
)	O
==	O
0	int
)	O
;	O
if	O
(	O
strlen	function
(	O
s	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
swverid	pointer
=	O
swverid_open	function
(	O
NULL	O
,	O
s	pointer
)	O
;	O
if	O
(	O
swverid	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error processing software selection from file: [%s]\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
s	pointer
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
goto	O
error_out	O
;	O
}	O
else	O
{	O
vplob_add	function
(	O
swspec_list	pointer
,	O
(	O
void	O
*	O
)	O
swverid	pointer
)	O
;	O
}	O
}	O
if	O
(	O
fd	int
>	O
STDERR_FILENO	int
)	O
close	pointer
(	O
fd	int
)	O
;	O
G	pointer
->	O
g_selectfd_array	array
[	O
i	int
]	O
=	O
-	O
1	int
;	O
}	O
else	O
{	O
;	O
}	O
}	O
error_out	O
:	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
int	O
swc_process_selection_args	function
(	O
VPLOB	union
*	O
swspec_list	pointer
,	O
char	O
*	O
*	O
argvector	pointer
,	O
int	O
uargc	int
,	O
int	O
*	O
poptind	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
int	O
count	int
=	O
0	int
;	O
int	O
error_count	int
=	O
0	int
;	O
SWVERID	struct
*	O
swverid	pointer
=	O
NULL	O
;	O
int	O
is_last	int
;	O
is_last	int
=	O
0	int
;	O
error_count	int
=	O
0	int
;	O
if	O
(	O
!	O
swspec_list	pointer
)	O
return	O
-	O
1	int
;	O
while	O
(	O
*	O
poptind	pointer
<	O
uargc	int
&&	O
is_last	int
==	O
0	int
)	O
{	O
s	pointer
=	O
argvector	pointer
[	O
*	O
poptind	pointer
]	O
;	O
if	O
(	O
s	pointer
&&	O
*	O
s	pointer
==	O
'@'	O
)	O
{	O
break	O
;	O
}	O
if	O
(	O
strlen	function
(	O
s	pointer
)	O
>	O
0	int
&&	O
s	pointer
[	O
strlen	function
(	O
s	pointer
)	O
-	O
1	int
]	O
==	O
'@'	O
)	O
{	O
is_last	int
=	O
1	int
;	O
}	O
(	O
*	O
poptind	pointer
)	O
++	O
;	O
count	int
++	O
;	O
swverid	pointer
=	O
swverid_open	function
(	O
NULL	O
,	O
s	pointer
)	O
;	O
if	O
(	O
swverid	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: error processing software selection: %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
s	pointer
)	O
;	O
(	O
error_count	int
)	O
++	O
;	O
}	O
else	O
{	O
vplob_add	function
(	O
swspec_list	pointer
,	O
(	O
void	O
*	O
)	O
swverid	pointer
)	O
;	O
}	O
}	O
return	O
error_count	int
;	O
}	O
int	O
swc_read_selections_file	function
(	O
void	O
)	O
{	O
return	O
0	int
;	O
}	O
char	O
*	O
swc_get_next_target	function
(	O
char	O
*	O
*	O
argvector	pointer
,	O
int	O
uargc	int
,	O
int	O
*	O
poptind	pointer
,	O
int	O
*	O
targetsfd_array	pointer
,	O
char	O
*	O
default_target	pointer
,	O
int	O
*	O
pnum_remains	pointer
)	O
{	O
static	O
int	O
did_one	int
=	O
0	int
;	O
static	O
int	O
targetfd_index	int
=	O
0	int
;	O
char	O
*	O
tmpch	pointer
;	O
char	O
*	O
current_arg	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
int	O
fd	int
;	O
int	O
n	int
;	O
*	O
pnum_remains	pointer
=	O
0	int
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
if	O
(	O
*	O
poptind	pointer
==	O
uargc	int
&&	O
targetsfd_array	pointer
[	O
targetfd_index	int
]	O
<	O
0	int
&&	O
did_one	int
==	O
0	int
)	O
{	O
did_one	int
=	O
1	int
;	O
*	O
pnum_remains	pointer
=	O
0	int
;	O
strob_strcpy	function
(	O
tmp	pointer
,	O
"@"	pointer
)	O
;	O
tmpch	pointer
=	O
default_target	pointer
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
tmpch	pointer
)	O
;	O
current_arg	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
(	O
*	O
poptind	pointer
)	O
++	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
current_arg	pointer
;	O
}	O
did_one	int
=	O
1	int
;	O
if	O
(	O
(	O
*	O
poptind	pointer
)	O
<	O
uargc	int
)	O
{	O
current_arg	pointer
=	O
argvector	pointer
[	O
(	O
*	O
poptind	pointer
)	O
++	O
]	O
;	O
*	O
pnum_remains	pointer
=	O
uargc	int
-	O
(	O
*	O
poptind	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
current_arg	pointer
,	O
"@"	pointer
)	O
==	O
0	int
)	O
{	O
current_arg	pointer
=	O
argvector	pointer
[	O
(	O
*	O
poptind	pointer
)	O
++	O
]	O
;	O
if	O
(	O
!	O
current_arg	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"invalid target.\n"	pointer
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
strob_strcpy	function
(	O
tmp	pointer
,	O
"@"	pointer
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
current_arg	pointer
)	O
;	O
current_arg	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
current_arg	pointer
!=	O
'@'	O
)	O
{	O
strob_strcpy	function
(	O
tmp	pointer
,	O
"@"	pointer
)	O
;	O
strob_strcat	function
(	O
tmp	pointer
,	O
current_arg	pointer
)	O
;	O
current_arg	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
else	O
{	O
current_arg	pointer
=	O
strdup	function
(	O
current_arg	pointer
)	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
current_arg	pointer
;	O
}	O
fd	int
=	O
targetsfd_array	pointer
[	O
targetfd_index	int
]	O
;	O
while	O
(	O
fd	int
>=	O
0	int
)	O
{	O
*	O
pnum_remains	pointer
=	O
1	int
;	O
n	int
=	O
swgp_read_line	function
(	O
fd	int
,	O
(	O
STROB	struct
*	O
)	O
tmp	pointer
,	O
DO_NOT_APPEND	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
process_targetfile_line	function
(	O
tmp	pointer
,	O
&	O
current_arg	pointer
)	O
>=	O
1	int
)	O
{	O
current_arg	pointer
=	O
strdup	function
(	O
current_arg	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
current_arg	pointer
;	O
}	O
else	O
{	O
;	O
}	O
}	O
else	O
if	O
(	O
n	int
==	O
0	int
)	O
{	O
targetfd_index	int
++	O
;	O
}	O
else	O
{	O
targetfd_index	int
++	O
;	O
}	O
fd	int
=	O
targetsfd_array	pointer
[	O
targetfd_index	int
]	O
;	O
}	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
void	O
swc_flush_logger	function
(	O
GB	struct
*	O
G	pointer
,	O
STROB	struct
*	O
slinebuf	pointer
,	O
STROB	struct
*	O
tlinebuf	pointer
,	O
int	O
efd	int
,	O
int	O
ofd	int
,	O
struct	O
sw_logspec	struct
*	O
logspec	pointer
,	O
int	O
verboselevel	int
)	O
{	O
write_log	function
(	O
G	pointer
,	O
slinebuf	pointer
,	O
logspec	pointer
,	O
ofd	int
,	O
efd	int
,	O
""	pointer
,	O
0	int
,	O
verboselevel	int
,	O
-	O
1	int
)	O
;	O
write_log	function
(	O
G	pointer
,	O
tlinebuf	pointer
,	O
logspec	pointer
,	O
ofd	int
,	O
efd	int
,	O
""	pointer
,	O
0	int
,	O
verboselevel	int
,	O
-	O
1	int
)	O
;	O
if	O
(	O
logspec	pointer
&&	O
logspec	pointer
->	O
logfdM	int
>	O
0	int
)	O
{	O
close	pointer
(	O
logspec	pointer
->	O
logfdM	int
)	O
;	O
}	O
}	O
pid_t	int
swc_fork_logger	function
(	O
GB	struct
*	O
G	pointer
,	O
STROB	struct
*	O
x_slinebuf	pointer
,	O
STROB	struct
*	O
x_tlinebuf	pointer
,	O
int	O
efd	int
,	O
int	O
ofd	int
,	O
struct	O
sw_logspec	struct
*	O
logspec	pointer
,	O
int	O
*	O
s_efd	pointer
,	O
int	O
*	O
t_efd	pointer
,	O
int	O
vlevel	int
,	O
int	O
*	O
swi_event_fd_p	pointer
)	O
{	O
pid_t	int
pid	int
;	O
int	O
spipe	array
[	O
2	int
]	O
;	O
int	O
tpipe	array
[	O
2	int
]	O
;	O
int	O
ppipe	array
[	O
2	int
]	O
;	O
sigset_t	struct
fork_defaultmask	pointer
;	O
sigset_t	struct
fork_blockmask	pointer
;	O
STROB	struct
*	O
slinebuf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
STROB	struct
*	O
tlinebuf	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
if	O
(	O
s_efd	pointer
)	O
{	O
if	O
(	O
pipe	function
(	O
spipe	array
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
spipe	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
spipe	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
if	O
(	O
pipe	function
(	O
tpipe	array
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
swi_event_fd_p	pointer
)	O
{	O
if	O
(	O
pipe	function
(	O
ppipe	array
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
ppipe	array
[	O
0	int
]	O
=	O
-	O
1	int
;	O
ppipe	array
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
sigemptyset	function
(	O
&	O
fork_blockmask	pointer
)	O
;	O
sigaddset	function
(	O
&	O
fork_blockmask	pointer
,	O
SIGINT	int
)	O
;	O
sigaddset	function
(	O
&	O
fork_blockmask	pointer
,	O
SIGTERM	int
)	O
;	O
sigaddset	function
(	O
&	O
fork_blockmask	pointer
,	O
SIGALRM	int
)	O
;	O
sigemptyset	function
(	O
&	O
fork_defaultmask	pointer
)	O
;	O
sigaddset	function
(	O
&	O
fork_defaultmask	pointer
,	O
SIGINT	int
)	O
;	O
sigaddset	function
(	O
&	O
fork_defaultmask	pointer
,	O
SIGPIPE	int
)	O
;	O
sigaddset	function
(	O
&	O
fork_defaultmask	pointer
,	O
SIGTERM	int
)	O
;	O
pid	int
=	O
swndfork	function
(	O
&	O
fork_blockmask	pointer
,	O
&	O
fork_defaultmask	pointer
)	O
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
int	O
status	int
;	O
int	O
rra	int
;	O
int	O
sra	int
;	O
int	O
done_s	int
;	O
int	O
rrb	int
;	O
int	O
srb	int
;	O
int	O
done_t	int
;	O
char	O
*	O
bufa	pointer
;	O
char	O
*	O
bufb	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
swgp_signal	function
(	O
SIGABRT	int
,	O
logger_sig_handler	function
)	O
;	O
swgp_signal	function
(	O
SWBIS_LOGGER_SIGTERM	O
,	O
logger_sig_handler	function
)	O
;	O
bufa	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
SWLIB_PIPE_BUF	int
+	O
SWLIB_PIPE_BUF	int
)	O
;	O
bufb	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
SWLIB_PIPE_BUF	int
+	O
SWLIB_PIPE_BUF	int
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
100	int
)	O
;	O
if	O
(	O
s_efd	pointer
)	O
close	pointer
(	O
spipe	array
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
tpipe	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
ppipe	array
[	O
0	int
]	O
>=	O
0	int
)	O
close	pointer
(	O
ppipe	array
[	O
0	int
]	O
)	O
;	O
memset	function
(	O
bufa	pointer
,	O
'\0'	O
,	O
SWLIB_PIPE_BUF	int
+	O
SWLIB_PIPE_BUF	int
)	O
;	O
memset	function
(	O
bufb	pointer
,	O
'\0'	O
,	O
SWLIB_PIPE_BUF	int
+	O
SWLIB_PIPE_BUF	int
)	O
;	O
if	O
(	O
(	O
s_efd	pointer
&&	O
spipe	array
[	O
0	int
]	O
<=	O
6	int
)	O
||	O
tpipe	array
[	O
0	int
]	O
<=	O
6	int
||	O
(	O
ppipe	array
[	O
1	int
]	O
>=	O
0	int
&&	O
ppipe	array
[	O
1	int
]	O
<=	O
6	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: internal error in fork_logger\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
logspec	pointer
->	O
logfdM	int
>=	O
0	int
&&	O
logspec	pointer
->	O
logfdM	int
<=	O
6	int
)	O
{	O
while	O
(	O
logspec	pointer
->	O
logfdM	int
<=	O
6	int
&&	O
logspec	pointer
->	O
logfdM	int
!=	O
-	O
1	int
)	O
logspec	pointer
->	O
logfdM	int
=	O
dup	function
(	O
logspec	pointer
->	O
logfdM	int
)	O
;	O
}	O
if	O
(	O
s_efd	pointer
)	O
{	O
if	O
(	O
dup2	function
(	O
spipe	array
[	O
0	int
]	O
,	O
3	int
)	O
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"dup2 error (loc=a)\n"	pointer
)	O
;	O
}	O
else	O
{	O
close	pointer
(	O
3	int
)	O
;	O
}	O
if	O
(	O
dup2	function
(	O
tpipe	array
[	O
0	int
]	O
,	O
4	int
)	O
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"dup2 error (loc=b)\n"	pointer
)	O
;	O
if	O
(	O
ppipe	array
[	O
1	int
]	O
>=	O
0	int
)	O
{	O
if	O
(	O
dup2	function
(	O
ppipe	array
[	O
1	int
]	O
,	O
5	int
)	O
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"dup2 error (loc=c)\n"	pointer
)	O
;	O
ppipe	array
[	O
1	int
]	O
=	O
5	int
;	O
}	O
else	O
{	O
close	pointer
(	O
5	int
)	O
;	O
}	O
if	O
(	O
efd	int
!=	O
2	int
)	O
if	O
(	O
dup2	function
(	O
efd	int
,	O
2	int
)	O
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"dup2 error (loc=c)\n"	pointer
)	O
;	O
if	O
(	O
logspec	pointer
->	O
logfdM	int
>=	O
0	int
)	O
{	O
if	O
(	O
dup2	function
(	O
logspec	pointer
->	O
logfdM	int
,	O
6	int
)	O
<	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"dup2 error (loc=e)\n"	pointer
)	O
;	O
logspec	pointer
->	O
logfdM	int
=	O
6	int
;	O
}	O
else	O
{	O
close	pointer
(	O
6	int
)	O
;	O
}	O
swgp_close_all_fd	function
(	O
7	int
)	O
;	O
done_s	int
=	O
0	int
;	O
done_t	int
=	O
0	int
;	O
if	O
(	O
!	O
s_efd	pointer
)	O
done_s	int
++	O
;	O
while	O
(	O
(	O
!	O
done_s	int
||	O
!	O
done_t	int
)	O
&&	O
g_logger_sigterm	int
==	O
0	int
)	O
{	O
rra	int
=	O
0	int
;	O
rrb	int
=	O
0	int
;	O
if	O
(	O
!	O
done_s	int
)	O
{	O
sra	int
=	O
swgpReadFdNonblock	function
(	O
bufa	pointer
,	O
3	int
,	O
&	O
rra	int
)	O
;	O
if	O
(	O
sra	int
<	O
0	int
||	O
(	O
sra	int
&&	O
!	O
rra	int
)	O
)	O
done_s	int
++	O
;	O
}	O
if	O
(	O
rra	int
>	O
0	int
)	O
{	O
write_log	function
(	O
G	pointer
,	O
slinebuf	pointer
,	O
logspec	pointer
,	O
ofd	int
,	O
efd	int
,	O
bufa	pointer
,	O
rra	int
,	O
vlevel	int
,	O
ppipe	array
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
!	O
done_t	int
)	O
{	O
srb	int
=	O
swgpReadFdNonblock	function
(	O
bufb	pointer
,	O
4	int
,	O
&	O
rrb	int
)	O
;	O
if	O
(	O
srb	int
<	O
0	int
||	O
(	O
srb	int
&&	O
!	O
rrb	int
)	O
)	O
done_t	int
++	O
;	O
}	O
if	O
(	O
rrb	int
>	O
0	int
)	O
{	O
write_log	function
(	O
G	pointer
,	O
tlinebuf	pointer
,	O
logspec	pointer
,	O
ofd	int
,	O
efd	int
,	O
bufb	pointer
,	O
rrb	int
,	O
vlevel	int
,	O
ppipe	array
[	O
1	int
]	O
)	O
;	O
}	O
}	O
status	int
=	O
0	int
;	O
if	O
(	O
g_logger_sigterm	int
)	O
{	O
switch	O
(	O
g_logger_sigterm	int
)	O
{	O
case	O
SIGTERM	int
:	O
case	O
SIGUSR2	int
:	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"logger process terminated normally on SIGUSR2.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
break	O
;	O
case	O
SIGABRT	int
:	O
status	int
=	O
1	int
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"logger process: abnormal termination on SIGABRT.\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
break	O
;	O
default	O
:	O
status	int
=	O
2	int
;	O
strob_sprintf	function
(	O
tmp	pointer
,	O
0	int
,	O
"logger process: abnormal termination: signum=%d\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
(	O
int	O
)	O
g_logger_sigterm	int
)	O
;	O
break	O
;	O
}	O
swlib_doif_writef	O
(	O
vlevel	int
,	O
status	int
?	O
1	int
:	O
SWC_VERBOSE_6	int
,	O
logspec	pointer
,	O
efd	int
,	O
"%s"	pointer
,	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
}	O
else	O
{	O
swlib_doif_writef	O
(	O
vlevel	int
,	O
SWC_VERBOSE_8	int
,	O
logspec	pointer
,	O
efd	int
,	O
"logger unexpected exit.\n"	pointer
)	O
;	O
}	O
swc_flush_logger	function
(	O
G	pointer
,	O
slinebuf	pointer
,	O
tlinebuf	pointer
,	O
efd	int
,	O
ofd	int
,	O
logspec	pointer
,	O
vlevel	int
)	O
;	O
_exit	function
(	O
status	int
)	O
;	O
}	O
strob_close	function
(	O
slinebuf	pointer
)	O
;	O
strob_close	function
(	O
tlinebuf	pointer
)	O
;	O
if	O
(	O
s_efd	pointer
)	O
close	pointer
(	O
spipe	array
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
tpipe	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
ppipe	array
[	O
1	int
]	O
>=	O
0	int
)	O
close	pointer
(	O
ppipe	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
swi_event_fd_p	pointer
)	O
*	O
swi_event_fd_p	pointer
=	O
ppipe	array
[	O
0	int
]	O
;	O
if	O
(	O
s_efd	pointer
)	O
*	O
s_efd	pointer
=	O
spipe	array
[	O
1	int
]	O
;	O
*	O
t_efd	pointer
=	O
tpipe	array
[	O
1	int
]	O
;	O
return	O
pid	int
;	O
}	O
char	O
*	O
swc_get_pax_read_command	function
(	O
struct	O
g_pax_read_command	struct
g_pax_read_commands	pointer
[	O
]	O
,	O
char	O
*	O
keyid	pointer
,	O
int	O
verbose_level	int
,	O
int	O
keep	int
,	O
char	O
*	O
paxdefault	pointer
)	O
{	O
int	O
i	int
;	O
char	O
*	O
id	pointer
;	O
char	O
*	O
ret	int
;	O
struct	O
g_pax_read_command	struct
*	O
readcmd	pointer
;	O
E_DEBUG2	O
(	O
"BEGIN struct=%p"	pointer
,	O
(	O
void	O
*	O
)	O
g_pax_read_commands	pointer
)	O
;	O
E_DEBUG2	O
(	O
"BEGIN keyid=%s"	pointer
,	O
keyid	pointer
)	O
;	O
E_DEBUG2	O
(	O
"BEGIN verbose_level=%d"	pointer
,	O
verbose_level	int
)	O
;	O
E_DEBUG2	O
(	O
"BEGIN keep=%d"	pointer
,	O
keep	int
)	O
;	O
E_DEBUG2	O
(	O
"BEGIN paxdefault=%s"	pointer
,	O
paxdefault	pointer
)	O
;	O
if	O
(	O
!	O
keyid	pointer
)	O
{	O
return	O
NULL	O
;	O
}	O
if	O
(	O
keyid	pointer
==	O
NULL	O
||	O
strlen	function
(	O
keyid	pointer
)	O
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"strlen(keyid) == 0"	pointer
)	O
;	O
keyid	pointer
=	O
DEFAULT_PAX_R	pointer
;	O
}	O
i	int
=	O
0	int
;	O
readcmd	pointer
=	O
&	O
(	O
g_pax_read_commands	pointer
[	O
i	int
]	O
)	O
;	O
id	pointer
=	O
readcmd	pointer
->	O
idM	char
;	O
while	O
(	O
id	pointer
)	O
{	O
E_DEBUG	O
(	O
"while.."	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
keyid	pointer
,	O
id	pointer
)	O
==	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"strcmp(keyid, id) == 0"	pointer
)	O
;	O
ret	int
=	O
NULL	O
;	O
if	O
(	O
keep	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
readcmd	pointer
->	O
keep_commandM	pointer
;	O
}	O
if	O
(	O
ret	int
==	O
NULL	O
&&	O
verbose_level	int
<=	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
readcmd	pointer
->	O
commandM	pointer
;	O
}	O
if	O
(	O
ret	int
==	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
readcmd	pointer
->	O
verbose_commandM	pointer
;	O
}	O
E_DEBUG2	O
(	O
"return pax command [%s]"	pointer
,	O
ret	int
)	O
;	O
return	O
ret	int
;	O
}	O
i	int
++	O
;	O
readcmd	pointer
=	O
&	O
(	O
g_pax_read_commands	pointer
[	O
i	int
]	O
)	O
;	O
id	pointer
=	O
readcmd	pointer
->	O
idM	char
;	O
}	O
return	O
swc_get_pax_read_command	function
(	O
g_pax_read_commands	pointer
,	O
paxdefault	pointer
,	O
verbose_level	int
,	O
keep	int
,	O
DEFAULT_PAX_R	pointer
)	O
;	O
}	O
char	O
*	O
swc_get_pax_write_command	function
(	O
struct	O
g_pax_write_command	struct
g_pax_write_commands	pointer
[	O
]	O
,	O
char	O
*	O
keyid	pointer
,	O
int	O
verbose_level	int
,	O
char	O
*	O
paxdefault	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
char	O
*	O
id	pointer
;	O
struct	O
g_pax_write_command	struct
*	O
writecmd	pointer
;	O
if	O
(	O
!	O
keyid	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
strlen	function
(	O
keyid	pointer
)	O
==	O
0	int
)	O
{	O
return	O
swc_get_pax_write_command	function
(	O
g_pax_write_commands	pointer
,	O
DEFAULT_PAX_W	pointer
,	O
verbose_level	int
,	O
DEFAULT_PAX_W	pointer
)	O
;	O
}	O
writecmd	pointer
=	O
&	O
(	O
g_pax_write_commands	pointer
[	O
i	int
]	O
)	O
;	O
id	pointer
=	O
writecmd	pointer
->	O
idM	char
;	O
while	O
(	O
id	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
keyid	pointer
,	O
id	pointer
)	O
==	O
0	int
)	O
return	O
writecmd	pointer
->	O
commandM	pointer
;	O
i	int
++	O
;	O
writecmd	pointer
=	O
&	O
(	O
g_pax_write_commands	pointer
[	O
i	int
]	O
)	O
;	O
id	pointer
=	O
writecmd	pointer
->	O
idM	char
;	O
}	O
return	O
swc_get_pax_write_command	function
(	O
g_pax_write_commands	pointer
,	O
paxdefault	pointer
,	O
verbose_level	int
,	O
DEFAULT_PAX_W	pointer
)	O
;	O
}	O
char	O
*	O
swc_get_pax_remove_command	function
(	O
struct	O
g_pax_remove_command	struct
g_pax_remove_commands	pointer
[	O
]	O
,	O
char	O
*	O
keyid	pointer
,	O
int	O
verbose_level	int
,	O
char	O
*	O
paxdefault	pointer
)	O
{	O
int	O
i	int
=	O
0	int
;	O
char	O
*	O
id	pointer
;	O
struct	O
g_pax_remove_command	struct
*	O
removecmd	pointer
;	O
if	O
(	O
!	O
keyid	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
strlen	function
(	O
keyid	pointer
)	O
==	O
0	int
)	O
{	O
return	O
swc_get_pax_remove_command	function
(	O
g_pax_remove_commands	pointer
,	O
DEFAULT_PAX_REM	pointer
,	O
verbose_level	int
,	O
DEFAULT_PAX_REM	pointer
)	O
;	O
}	O
removecmd	pointer
=	O
&	O
(	O
g_pax_remove_commands	pointer
[	O
i	int
]	O
)	O
;	O
id	pointer
=	O
removecmd	pointer
->	O
idM	char
;	O
while	O
(	O
id	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
keyid	pointer
,	O
id	pointer
)	O
==	O
0	int
)	O
return	O
removecmd	pointer
->	O
commandM	pointer
;	O
i	int
++	O
;	O
removecmd	pointer
=	O
&	O
(	O
g_pax_remove_commands	pointer
[	O
i	int
]	O
)	O
;	O
id	pointer
=	O
removecmd	pointer
->	O
idM	char
;	O
}	O
return	O
swc_get_pax_remove_command	function
(	O
g_pax_remove_commands	pointer
,	O
paxdefault	pointer
,	O
verbose_level	int
,	O
DEFAULT_PAX_REM	pointer
)	O
;	O
}	O
int	O
swc_process_swoperand_file	function
(	O
SWLOG	struct
*	O
swutil	pointer
,	O
char	O
*	O
type_string	pointer
,	O
char	O
*	O
filename	pointer
,	O
int	O
*	O
p_stdin_in_use	pointer
,	O
int	O
*	O
p_array_index	pointer
,	O
int	O
*	O
fd_array	pointer
)	O
{	O
int	O
list_fd	int
;	O
if	O
(	O
strcmp	function
(	O
filename	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
(	O
*	O
p_stdin_in_use	pointer
)	O
++	O
;	O
list_fd	int
=	O
STDIN_FILENO	int
;	O
}	O
else	O
{	O
list_fd	int
=	O
open	function
(	O
filename	pointer
,	O
O_RDONLY	int
,	O
0	int
)	O
;	O
if	O
(	O
list_fd	int
<	O
0	int
)	O
{	O
swutil_doif_writef2	function
(	O
swutil	pointer
,	O
swutil	pointer
->	O
swu_fail_loudlyM	int
,	O
"error opening %s list file\n"	pointer
,	O
type_string	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
*	O
p_array_index	pointer
>=	O
SWC_TARGET_FD_ARRAY_LEN	int
-	O
2	int
)	O
{	O
swutil_doif_writef2	function
(	O
swutil	pointer
,	O
swutil	pointer
->	O
swu_fail_loudlyM	int
,	O
"too many %s files\n"	pointer
,	O
type_string	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
fd_array	pointer
[	O
(	O
*	O
p_array_index	pointer
)	O
++	O
]	O
=	O
list_fd	int
;	O
fd_array	pointer
[	O
(	O
*	O
p_array_index	pointer
)	O
]	O
=	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
swc_set_boolean_x_option	function
(	O
struct	O
extendedOptions	struct
*	O
opta	pointer
,	O
enum	O
eOpts	enum
nopt	enum
,	O
char	O
*	O
arg	pointer
,	O
char	O
*	O
*	O
optionp	pointer
)	O
{	O
set_opta	function
(	O
opta	pointer
,	O
nopt	enum
,	O
arg	pointer
)	O
;	O
}	O
int	O
swc_write_source_copy_script	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
sourcepath	pointer
,	O
int	O
do_get_file_type	int
,	O
int	O
verbose_threshold	int
,	O
int	O
delaytime	int
,	O
int	O
nhops	int
,	O
char	O
*	O
pax_write_command_key	pointer
,	O
char	O
*	O
hostname	pointer
,	O
char	O
*	O
blocksize	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
n_source_specs	int
;	O
char	O
*	O
dirname	pointer
;	O
char	O
*	O
spath	pointer
;	O
char	O
*	O
pax_write_command	pointer
;	O
char	O
*	O
xx	pointer
;	O
STROB	struct
*	O
buffer	array
,	O
*	O
opt1	pointer
,	O
*	O
opt2	pointer
;	O
STROB	struct
*	O
buffer_new	pointer
;	O
STROB	struct
*	O
subsh	pointer
,	O
*	O
subsh2	pointer
;	O
STROB	struct
*	O
tmp	pointer
;	O
STROB	struct
*	O
tmp1	pointer
;	O
STROB	struct
*	O
tmp2	pointer
;	O
STROB	struct
*	O
mpath	pointer
;	O
STROB	struct
*	O
set_vx	pointer
;	O
STROB	struct
*	O
to_devnull	pointer
;	O
STROB	struct
*	O
rootdir	pointer
;	O
STROB	struct
*	O
firstpath	pointer
;	O
STROB	struct
*	O
shell_lib_buf	pointer
;	O
int	O
vlv	int
;	O
vlv	int
=	O
G	pointer
->	O
g_verboseG	int
;	O
if	O
(	O
strstr	function
(	O
sourcepath	pointer
,	O
".."	pointer
)	O
==	O
sourcepath	pointer
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
strstr	function
(	O
sourcepath	pointer
,	O
"../"	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
swlib_is_sh_tainted_string	function
(	O
sourcepath	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
swlib_squash_double_slash	function
(	O
sourcepath	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
sourcepath	pointer
)	O
>	O
1	int
)	O
{	O
if	O
(	O
sourcepath	pointer
[	O
strlen	function
(	O
sourcepath	pointer
)	O
-	O
1	int
]	O
==	O
'/'	O
)	O
{	O
sourcepath	pointer
[	O
strlen	function
(	O
sourcepath	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
buffer	array
=	O
strob_open	function
(	O
1	int
)	O
;	O
buffer_new	pointer
=	O
strob_open	function
(	O
1	int
)	O
;	O
to_devnull	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
opt1	pointer
=	O
strob_open	function
(	O
1	int
)	O
;	O
opt2	pointer
=	O
strob_open	function
(	O
1	int
)	O
;	O
set_vx	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
tmp	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
tmp1	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
tmp2	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
subsh	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
subsh2	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
rootdir	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
firstpath	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
shell_lib_buf	pointer
=	O
strob_open	function
(	O
10	int
)	O
;	O
if	O
(	O
vlv	int
>=	O
SWC_VERBOSE_SWIDB	int
)	O
{	O
strob_strcpy	function
(	O
set_vx	pointer
,	O
"set -vx\n"	pointer
)	O
;	O
}	O
if	O
(	O
vlv	int
<=	O
verbose_threshold	int
)	O
{	O
strob_strcpy	function
(	O
to_devnull	pointer
,	O
"2>/dev/null"	pointer
)	O
;	O
}	O
swlib_dirname	function
(	O
tmp	pointer
,	O
sourcepath	pointer
)	O
;	O
dirname	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
swlib_basename	function
(	O
tmp	pointer
,	O
sourcepath	pointer
)	O
;	O
spath	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
if	O
(	O
do_get_file_type	int
)	O
{	O
if	O
(	O
strchr	function
(	O
spath	pointer
,	O
'\n'	O
)	O
||	O
strlen	function
(	O
spath	pointer
)	O
>	O
MAX_CONTROL_MESG_LEN	int
-	O
strlen	function
(	O
SWBIS_SWINSTALL_SOURCE_CTL_ARCHIVE	O
":"	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
strob_sprintf	function
(	O
opt1	pointer
,	O
0	int
,	O
"echo "	pointer
"\""	pointer
SWBIS_SWINSTALL_SOURCE_CTL_ARCHIVE	O
": %s\""	pointer
,	O
spath	pointer
)	O
;	O
strob_sprintf	function
(	O
opt2	pointer
,	O
0	int
,	O
"echo "	pointer
"\""	pointer
SWBIS_SWINSTALL_SOURCE_CTL_DIRECTORY	O
": %s\""	pointer
,	O
spath	pointer
)	O
;	O
}	O
pax_write_command	pointer
=	O
swc_get_pax_write_command	function
(	O
G	pointer
->	O
g_pax_write_commands	pointer
,	O
pax_write_command_key	pointer
,	O
G	pointer
->	O
g_verboseG	int
,	O
DEFAULT_PAX_W	pointer
)	O
;	O
if	O
(	O
swlib_is_sh_tainted_string	function
(	O
spath	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
swlib_is_sh_tainted_string	function
(	O
dirname	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
spath	pointer
,	O
"/"	pointer
)	O
==	O
0	int
&&	O
strcmp	function
(	O
dirname	pointer
,	O
"/"	pointer
)	O
==	O
0	int
)	O
{	O
free	function
(	O
spath	pointer
)	O
;	O
spath	pointer
=	O
strdup	function
(	O
"."	pointer
)	O
;	O
}	O
if	O
(	O
G	pointer
->	O
g_sourcepath_listM	pointer
)	O
n_source_specs	int
=	O
strar_num_elements	function
(	O
G	pointer
->	O
g_sourcepath_listM	pointer
)	O
;	O
else	O
n_source_specs	int
=	O
1	int
;	O
if	O
(	O
n_source_specs	int
>	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"n_source_specs > 1"	pointer
)	O
;	O
mpath	pointer
=	O
swc_make_multiplepathlist	function
(	O
G	pointer
->	O
g_sourcepath_listM	pointer
,	O
rootdir	pointer
,	O
firstpath	pointer
)	O
;	O
if	O
(	O
mpath	pointer
)	O
{	O
dirname	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
rootdir	pointer
)	O
)	O
;	O
spath	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
firstpath	pointer
)	O
)	O
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"n_source_specs not > 1"	pointer
)	O
;	O
mpath	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
n_source_specs	int
>	O
1	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
mpath	pointer
==	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
n_source_specs	int
=	O
1	int
;	O
}	O
}	O
strob_sprintf	function
(	O
tmp1	pointer
,	O
0	int
,	O
"%s"	pointer
,	O
spath	pointer
)	O
,	O
strob_sprintf	function
(	O
tmp2	pointer
,	O
0	int
,	O
"%s"	pointer
,	O
sourcepath	pointer
)	O
,	O
strob_strcpy	function
(	O
buffer_new	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
get_opta	function
(	O
G	pointer
->	O
optaM	pointer
,	O
SW_E_swbis_shell_command	int
)	O
,	O
"detect"	pointer
)	O
==	O
0	int
)	O
{	O
swpl_bashin_detect	function
(	O
buffer_new	pointer
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
get_opta	function
(	O
G	pointer
->	O
optaM	pointer
,	O
SW_E_swbis_shell_command	int
)	O
,	O
"posix"	pointer
)	O
==	O
0	int
)	O
{	O
swpl_bashin_posixsh	function
(	O
buffer_new	pointer
)	O
;	O
}	O
else	O
{	O
swpl_bashin_testsh	function
(	O
buffer_new	pointer
,	O
get_opta	function
(	O
G	pointer
->	O
optaM	pointer
,	O
SW_E_swbis_shell_command	int
)	O
)	O
;	O
}	O
strob_sprintf	function
(	O
buffer_new	pointer
,	O
STROB_DO_APPEND	int
,	O
"echo "	pointer
SWBIS_TARGET_CTL_MSG_125	pointer
": "	pointer
KILL_PID	pointer
"\n"	pointer
CSHID	O
"%s\n"	pointer
"%s"	pointer
"%s"	pointer
"%s\n"	pointer
"do_create=\"%s\"\n"	pointer
"multiple_source=\"%s\"\n"	pointer
"blocksize=\"%s\"\n"	pointer
"dirname=\"%s\"\n"	pointer
"path=\"%s\"\n"	pointer
"sourcepath=\"%s\"\n"	pointer
"sw_retval=0\n"	pointer
"sb__delaytime=%d\n"	pointer
"pax_write_command_key=\"%s\"\n"	pointer
CSHID	O
"if test -d \"$dirname\"; then\n"	pointer
"	cd \"$dirname\"\n"	pointer
"	sw_retval=$?\n"	pointer
"	case $sw_retval in\n"	pointer
"	0)\n"	pointer
"	if test \"$multiple_source\" -o \\( -d \"$path\" -a -r \"$path\" \\) -o \\( \"$do_create\" -a -r \"$path\" \\); then\n"	pointer
"		\t\t%s\n"	pointer
"		\t\t%s\n"	pointer
"		\t\t%s\n"	pointer
"	# disable test for gnu tar when the selected tar command\n"	pointer
"	# is tar, this preserves ability to only use generic tar options\n"	pointer
"	# and avoid addition of the --format=pax string\n"	pointer
"		case \"${pax_write_command_key}\" in\n"	pointer
"		tar)\n"	pointer
"		( exit 1 ) # false\n"	pointer
"		;;\n"	pointer
"		*)\n"	pointer
"		shls_check_for_gnu_tar \n"	pointer
"		;;\n"	pointer
"		esac\n"	pointer
"		has_gnu_tar=$?\n"	pointer
"		case \"$multiple_source\" in\n"	pointer
"			\"\")\n"	pointer
"				case \"$has_gnu_tar\" in \n"	pointer
"				0)  # Yes, has gnu tar as tar\n"	pointer
"				tar cbf 1 - --format=pax \"$path\"\n"	pointer
"				sw_retval=$?\n"	pointer
"				;;\n"	pointer
"				*)\n"	pointer
"				%s \"$path\"\n"	pointer
"				sw_retval=$?\n"	pointer
"				;;\n"	pointer
"				esac\n"	pointer
"			;;\n"	pointer
"			x)\n"	pointer
"				case \"$has_gnu_tar\" in \n"	pointer
"				0)  # Yes, has gnu tar as tar\n"	pointer
"				tar cbf 1 - --format=pax %s\n"	pointer
"				sw_retval=$?\n"	pointer
"				;;\n"	pointer
"				*)\n"	pointer
"				%s %s\n"	pointer
"				sw_retval=$?\n"	pointer
"				;;\n"	pointer
"				esac\n"	pointer
"			;;\n"	pointer
"		esac\n"	pointer
"\t\t%s\n"	pointer
"	elif test -e \"$path\" -a -r \"$path\"; then\n"	pointer
"\t\t%s\n"	pointer
"\t\t%s\n"	pointer
"\t\t%s\n"	pointer
"		dd ibs=\"$blocksize\" obs=512 if=\"$path\" %s;\n"	pointer
"		sw_retval=$?\n"	pointer
"\t\t%s\n"	pointer
"	else\n"	pointer
"\t\t%s\n"	pointer
"\t\t%s\n"	pointer
"		sw_retval=1\n"	pointer
"	fi\n"	pointer
"	;;\n"	pointer
"	*)\n"	pointer
"\t\t%s\n"	pointer
"\t\t%s\n"	pointer
"	;;\n"	pointer
"	esac\n"	pointer
CSHID	O
"elif test -e \"$sourcepath\" -a -r \"$sourcepath\"; then\n"	pointer
"\t%s\n"	pointer
"\t%s\n"	pointer
"\t%s\n"	pointer
"	dd ibs=\"$blocksize\" obs=512 if=\"$sourcepath\" %s;\n"	pointer
"	sw_retval=$?\n"	pointer
"\t%s\n"	pointer
CSHID	O
"else\n"	pointer
"\t%s\n"	pointer
"\t%s\n"	pointer
"	sw_retval=1\n"	pointer
"fi\n"	pointer
"if test \"$sw_retval\" != \"0\"; then\n"	pointer
"	 sb__delaytime=0;\n"	pointer
"fi\n"	pointer
"sleep \"$sb__delaytime\"\n"	pointer
"%s\n"	pointer
"%s\n"	pointer
,	O
SEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SESSION_BEGINS	int
,	O
""	pointer
)	O
,	O
swicol_subshell_marks	function
(	O
subsh	pointer
,	O
"source"	pointer
,	O
'L'	O
,	O
nhops	int
,	O
vlv	int
)	O
,	O
strob_str	function
(	O
set_vx	pointer
)	O
,	O
shlib_get_function_text_by_name	function
(	O
"shls_check_for_gnu_tar"	pointer
,	O
shell_lib_buf	pointer
,	O
NULL	O
)	O
,	O
(	O
G	pointer
->	O
g_do_createM	int
!=	O
0	int
)	O
?	O
"x"	pointer
:	O
""	pointer
,	O
(	O
n_source_specs	int
>	O
1	int
)	O
?	O
"x"	pointer
:	O
""	pointer
,	O
blocksize	pointer
,	O
dirname	pointer
,	O
spath	pointer
,	O
sourcepath	pointer
,	O
delaytime	int
,	O
pax_write_command_key	pointer
,	O
strob_str	function
(	O
opt2	pointer
)	O
,	O
SEVENT	O
(	O
1	int
,	O
-	O
1	int
,	O
SW_SOURCE_ACCESS_BEGINS	int
,	O
""	pointer
)	O
,	O
SEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOURCE_ACCESS_BEGINS	int
,	O
""	pointer
)	O
,	O
pax_write_command	pointer
,	O
mpath	pointer
?	O
strob_str	function
(	O
mpath	pointer
)	O
:	O
"."	pointer
,	O
pax_write_command	pointer
,	O
mpath	pointer
?	O
strob_str	function
(	O
mpath	pointer
)	O
:	O
"."	pointer
,	O
SEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOURCE_ACCESS_ENDS	int
,	O
"status=0"	pointer
)	O
,	O
strob_str	function
(	O
opt1	pointer
)	O
,	O
SEVENT	O
(	O
1	int
,	O
-	O
1	int
,	O
SW_SOURCE_ACCESS_BEGINS	int
,	O
""	pointer
)	O
,	O
SEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOURCE_ACCESS_BEGINS	int
,	O
""	pointer
)	O
,	O
strob_str	function
(	O
to_devnull	pointer
)	O
,	O
SEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOURCE_ACCESS_ENDS	int
,	O
"status=0"	pointer
)	O
,	O
SEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOURCE_ACCESS_ERROR	int
,	O
strob_str	function
(	O
tmp1	pointer
)	O
)	O
,	O
SEVENT	O
(	O
1	int
,	O
-	O
1	int
,	O
SW_SOURCE_ACCESS_ERROR	int
,	O
strob_str	function
(	O
tmp1	pointer
)	O
)	O
,	O
SEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOURCE_ACCESS_ERROR	int
,	O
strob_str	function
(	O
tmp1	pointer
)	O
)	O
,	O
SEVENT	O
(	O
1	int
,	O
-	O
1	int
,	O
SW_SOURCE_ACCESS_ERROR	int
,	O
strob_str	function
(	O
tmp1	pointer
)	O
)	O
,	O
strob_str	function
(	O
opt1	pointer
)	O
,	O
SEVENT	O
(	O
1	int
,	O
-	O
1	int
,	O
SW_SOURCE_ACCESS_BEGINS	int
,	O
""	pointer
)	O
,	O
SEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOURCE_ACCESS_BEGINS	int
,	O
""	pointer
)	O
,	O
strob_str	function
(	O
to_devnull	pointer
)	O
,	O
SEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOURCE_ACCESS_ENDS	int
,	O
"status=0"	pointer
)	O
,	O
SEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SOURCE_ACCESS_ERROR	int
,	O
strob_str	function
(	O
tmp2	pointer
)	O
)	O
,	O
SEVENT	O
(	O
1	int
,	O
-	O
1	int
,	O
SW_SOURCE_ACCESS_ERROR	int
,	O
strob_str	function
(	O
tmp2	pointer
)	O
)	O
,	O
SEVENT	O
(	O
2	int
,	O
vlv	int
,	O
SW_SESSION_ENDS	int
,	O
"status=$sw_retval"	pointer
)	O
,	O
swicol_subshell_marks	function
(	O
subsh2	pointer
,	O
"source"	pointer
,	O
'R'	O
,	O
nhops	int
,	O
vlv	int
)	O
)	O
;	O
xx	pointer
=	O
strob_str	function
(	O
buffer_new	pointer
)	O
;	O
ret	int
=	O
atomicio	function
(	O
(	O
ssize_t	long
(	O
*	O
)	O
(	O
int	O
,	O
void	O
*	O
,	O
size_t	long
)	O
)	O
write	pointer
,	O
ofd	int
,	O
xx	pointer
,	O
strlen	function
(	O
xx	pointer
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
int	O
)	O
strlen	function
(	O
xx	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
G	pointer
->	O
g_source_script_name	pointer
)	O
{	O
E_DEBUG2	O
(	O
"writing source script: %s"	pointer
,	O
G	pointer
->	O
g_source_script_name	pointer
)	O
;	O
swlib_tee_to_file	function
(	O
G	pointer
->	O
g_source_script_name	pointer
,	O
-	O
1	int
,	O
xx	pointer
,	O
-	O
1	int
,	O
0	int
)	O
;	O
}	O
free	function
(	O
spath	pointer
)	O
;	O
free	function
(	O
dirname	pointer
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
strob_close	function
(	O
tmp1	pointer
)	O
;	O
strob_close	function
(	O
tmp2	pointer
)	O
;	O
strob_close	function
(	O
buffer	array
)	O
;	O
strob_close	function
(	O
buffer_new	pointer
)	O
;	O
strob_close	function
(	O
opt1	pointer
)	O
;	O
strob_close	function
(	O
opt2	pointer
)	O
;	O
strob_close	function
(	O
set_vx	pointer
)	O
;	O
strob_close	function
(	O
to_devnull	pointer
)	O
;	O
strob_close	function
(	O
subsh	pointer
)	O
;	O
strob_close	function
(	O
subsh2	pointer
)	O
;	O
strob_close	function
(	O
rootdir	pointer
)	O
;	O
strob_close	function
(	O
shell_lib_buf	pointer
)	O
;	O
if	O
(	O
mpath	pointer
)	O
strob_close	function
(	O
mpath	pointer
)	O
;	O
return	O
!	O
(	O
ret	int
>	O
0	int
)	O
;	O
}	O
int	O
swc_read_target_message_129	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
fd	int
,	O
STROB	struct
*	O
cdir	pointer
,	O
int	O
vlevel	int
,	O
char	O
*	O
loc	pointer
)	O
{	O
int	O
ret	int
;	O
STROB	struct
*	O
control_message	pointer
;	O
char	O
*	O
tag	pointer
;	O
char	O
*	O
d	pointer
;	O
tag	pointer
=	O
SWBIS_TARGET_CTL_MSG_129	pointer
": "	pointer
;	O
control_message	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
strob_strcpy	function
(	O
cdir	pointer
,	O
""	pointer
)	O
;	O
ret	int
=	O
swc_read_target_ctl_message	function
(	O
G	pointer
,	O
fd	int
,	O
control_message	pointer
,	O
vlevel	int
,	O
loc	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
strstr	function
(	O
strob_str	function
(	O
control_message	pointer
)	O
,	O
tag	pointer
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
d	pointer
=	O
strob_str	function
(	O
control_message	pointer
)	O
+	O
strlen	function
(	O
tag	pointer
)	O
;	O
strob_strcpy	function
(	O
cdir	pointer
,	O
d	pointer
)	O
;	O
swlib_squash_all_trailing_vnewline	function
(	O
strob_str	function
(	O
cdir	pointer
)	O
)	O
;	O
strob_close	function
(	O
control_message	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
swc_read_target_ctl_message	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
fd	int
,	O
STROB	struct
*	O
control_message	pointer
,	O
int	O
vlevel	int
,	O
char	O
*	O
loc	pointer
)	O
{	O
int	O
n	int
;	O
char	O
c	int
[	O
2	int
]	O
;	O
int	O
count	int
=	O
0	int
;	O
E_DEBUG2	O
(	O
"BEGIN loc=%s"	pointer
,	O
loc	pointer
)	O
strob_strcpy	function
(	O
control_message	pointer
,	O
""	pointer
)	O
;	O
c	int
[	O
1	int
]	O
=	O
'\0'	O
;	O
n	int
=	O
try_nibble	function
(	O
fd	int
,	O
(	O
void	O
*	O
)	O
&	O
c	int
,	O
3	int
)	O
;	O
if	O
(	O
n	int
!=	O
1	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
count	int
++	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
while	O
(	O
n	int
==	O
1	int
&&	O
c	int
[	O
0	int
]	O
!=	O
'\n'	O
&&	O
count	int
<	O
MAX_CONTROL_MESG_LEN	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strob_strcat	function
(	O
control_message	pointer
,	O
c	int
)	O
;	O
n	int
=	O
read	pointer
(	O
fd	int
,	O
(	O
void	O
*	O
)	O
&	O
c	int
,	O
1	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
n	int
==	O
1	int
)	O
count	int
++	O
;	O
}	O
E_DEBUG	O
(	O
"out of loop"	pointer
)	O
;	O
swlib_doif_writef	O
(	O
vlevel	int
,	O
SWC_VERBOSE_IDB	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
G	pointer
->	O
g_stderr_fd	int
,	O
"%s control message: %s\n"	pointer
,	O
loc	pointer
,	O
strob_str	function
(	O
control_message	pointer
)	O
)	O
;	O
E_DEBUG	O
(	O
"after msg"	pointer
)	O
;	O
if	O
(	O
n	int
==	O
1	int
&&	O
count	int
==	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"return 0"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
n	int
==	O
1	int
&&	O
count	int
<	O
MAX_CONTROL_MESG_LEN	int
)	O
{	O
E_DEBUG2	O
(	O
"return count=%d"	pointer
,	O
count	int
)	O
;	O
return	O
count	int
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
"return -1"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
char	O
*	O
swc_get_target_script_pid	function
(	O
GB	struct
*	O
G	pointer
,	O
STROB	struct
*	O
control_message	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
char	O
*	O
p	pointer
;	O
char	O
*	O
ed	pointer
;	O
char	O
*	O
ret	int
;	O
s	pointer
=	O
strob_str	function
(	O
control_message	pointer
)	O
;	O
p	pointer
=	O
strstr	function
(	O
s	pointer
,	O
SWBIS_TARGET_CTL_MSG_125	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
p	pointer
!=	O
s	pointer
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
p	pointer
+=	O
strlen	function
(	O
SWBIS_TARGET_CTL_MSG_125	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
':'	O
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
' '	O
)	O
return	O
(	O
char	O
*	O
)	O
NULL	O
;	O
p	pointer
++	O
;	O
ret	int
=	O
strdup	function
(	O
p	pointer
)	O
;	O
if	O
(	O
(	O
ed	pointer
=	O
strpbrk	function
(	O
ret	int
,	O
"\n\r"	pointer
)	O
)	O
)	O
*	O
ed	pointer
=	O
'\0'	O
;	O
return	O
ret	int
;	O
}	O
int	O
swc_read_start_ctl_message	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
fd	int
,	O
STROB	struct
*	O
control_message	pointer
,	O
STRAR	struct
*	O
tramp_list	pointer
,	O
int	O
vlevel	int
,	O
char	O
*	O
*	O
pscript_pid	pointer
,	O
char	O
*	O
loc	pointer
)	O
{	O
int	O
ret	int
=	O
0	int
;	O
E_DEBUG2	O
(	O
"START loc=%s"	pointer
,	O
loc	pointer
)	O
;	O
strob_strcpy	function
(	O
control_message	pointer
,	O
""	pointer
)	O
;	O
while	O
(	O
ret	int
>=	O
0	int
&&	O
strstr	function
(	O
strob_str	function
(	O
control_message	pointer
)	O
,	O
SWBIS_TARGET_CTL_MSG_125	pointer
)	O
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
ret	int
=	O
swc_read_target_ctl_message	function
(	O
G	pointer
,	O
fd	int
,	O
control_message	pointer
,	O
vlevel	int
,	O
loc	pointer
)	O
;	O
E_DEBUG2	O
(	O
"ret=%d"	pointer
,	O
ret	int
)	O
;	O
if	O
(	O
ret	int
>=	O
0	int
&&	O
strob_strlen	function
(	O
control_message	pointer
)	O
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
strar_add	function
(	O
tramp_list	pointer
,	O
strob_str	function
(	O
control_message	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
"error"	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
*	O
pscript_pid	pointer
=	O
swc_get_target_script_pid	function
(	O
G	pointer
,	O
control_message	pointer
)	O
;	O
if	O
(	O
*	O
pscript_pid	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ret	int
=	O
0	int
;	O
}	O
else	O
{	O
swlib_doif_writef	O
(	O
vlevel	int
,	O
SWC_VERBOSE_IDB	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
G	pointer
->	O
g_stderr_fd	int
,	O
"remote script pid: %s\n"	pointer
,	O
*	O
pscript_pid	pointer
)	O
;	O
}	O
E_DEBUG2	O
(	O
"returning %d"	pointer
,	O
ret	int
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
swc_tee_to_file	function
(	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
buf	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
fd	int
;	O
int	O
res	int
;	O
if	O
(	O
isdigit	function
(	O
(	O
int	O
)	O
(	O
*	O
filename	pointer
)	O
)	O
)	O
{	O
fd	int
=	O
swlib_atoi	function
(	O
filename	pointer
,	O
&	O
res	int
)	O
;	O
if	O
(	O
res	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
fd	int
=	O
open	function
(	O
filename	pointer
,	O
O_RDWR	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
0644	int
)	O
;	O
}	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
fd	int
;	O
ret	int
=	O
uxfio_unix_safe_write	function
(	O
fd	int
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
(	O
int	O
)	O
strlen	function
(	O
buf	pointer
)	O
)	O
return	O
-	O
1	int
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
ret	int
;	O
}	O
void	O
swc_gf_xformat_close	function
(	O
GB	struct
*	O
G	pointer
,	O
XFORMAT	struct
*	O
xformat	pointer
)	O
{	O
if	O
(	O
xformat	pointer
)	O
xformat_close	function
(	O
xformat	pointer
)	O
;	O
G	pointer
->	O
g_xformat	pointer
=	O
NULL	O
;	O
}	O
int	O
swc_get_stderr_fd	function
(	O
GB	struct
*	O
G	pointer
)	O
{	O
return	O
G	pointer
->	O
g_stderr_fd	int
;	O
}	O
int	O
swc_shutdown_logger	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
signum	int
)	O
{	O
int	O
i	int
;	O
int	O
status	int
=	O
0	int
;	O
int	O
time_to_wait	int
=	O
10	int
;	O
int	O
ret	int
;	O
int	O
retval	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
signum	int
==	O
0	int
)	O
{	O
signum	int
=	O
SWBIS_LOGGER_SIGTERM	O
;	O
}	O
if	O
(	O
G	pointer
->	O
g_logger_pid	int
>	O
0	int
)	O
{	O
if	O
(	O
kill	function
(	O
G	pointer
->	O
g_logger_pid	int
,	O
signum	int
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: kill(2): %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
G	pointer
->	O
g_swevent_fd	int
>=	O
0	int
)	O
close	pointer
(	O
G	pointer
->	O
g_swevent_fd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_IDB	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"waitpid() on logger_pid [%d]\n"	pointer
,	O
G	pointer
->	O
g_logger_pid	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
AGAIN	O
:	O
ret	int
=	O
waitpid	function
(	O
G	pointer
->	O
g_logger_pid	int
,	O
&	O
status	int
,	O
WNOHANG	int
)	O
;	O
i	int
=	O
0	int
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
while	O
(	O
ret	int
==	O
0	int
&&	O
i	int
<	O
time_to_wait	int
)	O
{	O
usleep	function
(	O
50000	int
)	O
;	O
ret	int
=	O
waitpid	function
(	O
G	pointer
->	O
g_logger_pid	int
,	O
&	O
status	int
,	O
WNOHANG	int
)	O
;	O
E_DEBUG3	O
(	O
"waitpid returned %d status=%d"	pointer
,	O
ret	int
,	O
status	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
ret	int
;	O
i	int
++	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ret	int
==	O
0	int
&&	O
signum	int
!=	O
SIGKILL	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
signum	int
=	O
SIGKILL	int
;	O
if	O
(	O
kill	function
(	O
G	pointer
->	O
g_logger_pid	int
,	O
signum	int
)	O
<	O
0	int
)	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: kill(2): %s\n"	pointer
,	O
swlib_utilname_get	function
(	O
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
goto	O
AGAIN	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
if	O
(	O
signum	int
!=	O
SIGKILL	int
)	O
{	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
retval	int
=	O
WEXITSTATUS	O
(	O
status	int
)	O
;	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
retval	int
=	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
retval	int
=	O
-	O
2	int
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_IDB	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"finished waitpid() on logger_pid [%d]\n"	pointer
,	O
G	pointer
->	O
g_logger_pid	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
close	pointer
(	O
G	pointer
->	O
g_t_efd	int
)	O
;	O
close	pointer
(	O
G	pointer
->	O
g_s_efd	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG2	O
(	O
"retval=%d"	pointer
,	O
retval	int
)	O
;	O
return	O
retval	int
;	O
}	O
void	O
swc_set_stderr_fd	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
fd	int
)	O
{	O
G	pointer
->	O
g_stderr_fd	int
=	O
fd	int
;	O
swutil_set_stderr_fd	function
(	O
G	pointer
->	O
g_swlog	pointer
,	O
fd	int
)	O
;	O
}	O
void	O
swc_stderr_fd2_set	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
fd	int
)	O
{	O
G	pointer
->	O
g_save_stderr_fdM	int
=	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
;	O
swc_set_stderr_fd	function
(	O
G	pointer
,	O
fd	int
)	O
;	O
}	O
void	O
swc_stderr_fd2_restore	function
(	O
GB	struct
*	O
G	pointer
)	O
{	O
swc_set_stderr_fd	function
(	O
G	pointer
,	O
G	pointer
->	O
g_save_stderr_fdM	int
)	O
;	O
}	O
void	O
swc_lc_raise	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
,	O
int	O
signo	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_IDB	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"raising signal %d at %s:%d\n"	pointer
,	O
signo	int
,	O
file	pointer
,	O
line	pointer
)	O
;	O
G	pointer
->	O
g_signal_flag	int
=	O
signo	int
;	O
raise	function
(	O
signo	int
)	O
;	O
}	O
void	O
swc_lc_exit	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
file	pointer
,	O
int	O
line	pointer
,	O
int	O
status	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_IDB	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"exiting at %s:%d with value %d\n"	pointer
,	O
file	pointer
,	O
line	pointer
,	O
status	int
)	O
;	O
exit	function
(	O
status	int
)	O
;	O
}	O
int	O
swc_is_option_true	function
(	O
char	O
*	O
s	pointer
)	O
{	O
return	O
swlib_is_option_true	function
(	O
s	pointer
)	O
;	O
}	O
int	O
sw_exitval	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
count	int
,	O
int	O
suc	int
)	O
{	O
if	O
(	O
G	pointer
->	O
g_master_alarm	int
==	O
0	int
&&	O
suc	int
&&	O
count	int
==	O
suc	int
)	O
return	O
0	int
;	O
if	O
(	O
suc	int
&&	O
count	int
)	O
return	O
2	int
;	O
if	O
(	O
suc	int
==	O
0	int
)	O
return	O
1	int
;	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
G	pointer
->	O
g_fail_loudly	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"abnormal exit\n"	pointer
)	O
;	O
return	O
255	int
;	O
}	O
void	O
swc_check_for_current_signals	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
lineno	int
,	O
char	O
*	O
no_remote_kill	pointer
)	O
{	O
sigset_t	struct
pending_set	struct
;	O
int	O
signum	int
;	O
int	O
ret	int
;	O
ret	int
=	O
sigpending	function
(	O
&	O
pending_set	struct
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
signum	int
=	O
0	int
;	O
if	O
(	O
sigismember	function
(	O
&	O
pending_set	struct
,	O
SIGINT	int
)	O
==	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"got pending SIGINT"	pointer
)	O
;	O
signum	int
=	O
SIGINT	int
;	O
}	O
else	O
if	O
(	O
sigismember	function
(	O
&	O
pending_set	struct
,	O
SIGTERM	int
)	O
==	O
1	int
)	O
{	O
E_DEBUG	O
(	O
"got pending SIGTERM"	pointer
)	O
;	O
signum	int
=	O
SIGTERM	int
;	O
}	O
if	O
(	O
signum	int
)	O
{	O
(	O
*	O
G	pointer
->	O
g_safe_sig_handler	pointer
)	O
(	O
signum	int
)	O
;	O
}	O
}	O
switch	O
(	O
G	pointer
->	O
g_signal_flag	int
)	O
{	O
case	O
SIGUSR1	int
:	O
if	O
(	O
G	pointer
->	O
g_running_signalusr1M	int
)	O
{	O
return	O
;	O
}	O
G	pointer
->	O
g_running_signalusr1M	int
=	O
1	int
;	O
(	O
*	O
(	O
G	pointer
->	O
g_main_sig_handler	pointer
)	O
)	O
(	O
G	pointer
->	O
g_signal_flag	int
)	O
;	O
break	O
;	O
case	O
SIGTERM	int
:	O
case	O
SIGPIPE	int
:	O
case	O
SIGINT	int
:	O
if	O
(	O
G	pointer
->	O
g_running_signalsetM	int
)	O
{	O
return	O
;	O
}	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_IDB	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"swc_check_for_current_signals: line=%d Got signal %d.\n"	pointer
,	O
lineno	int
,	O
G	pointer
->	O
g_signal_flag	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
swgp_signal_block	function
(	O
SIGTERM	int
,	O
(	O
sigset_t	struct
*	O
)	O
NULL	O
)	O
;	O
swgp_signal_block	function
(	O
SIGINT	int
,	O
(	O
sigset_t	struct
*	O
)	O
NULL	O
)	O
;	O
swgp_signal_block	function
(	O
SIGPIPE	int
,	O
(	O
sigset_t	struct
*	O
)	O
NULL	O
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
G	pointer
->	O
g_running_signalsetM	int
=	O
1	int
;	O
(	O
*	O
(	O
G	pointer
->	O
g_main_sig_handler	pointer
)	O
)	O
(	O
G	pointer
->	O
g_signal_flag	int
)	O
;	O
E_DEBUG	O
(	O
""	pointer
)	O
;	O
break	O
;	O
}	O
}	O
pid_t	int
swc_run_source_script	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
swutil_x_mode	int
,	O
int	O
local_stdin	int
,	O
int	O
source_pipe	int
,	O
char	O
*	O
source_path	pointer
,	O
int	O
nhops	int
,	O
char	O
*	O
pax_write_command_key	pointer
,	O
sigset_t	struct
*	O
fork_blockmask	pointer
,	O
sigset_t	struct
*	O
fork_defaultmask	pointer
,	O
char	O
*	O
hostname	pointer
,	O
char	O
*	O
blocksize	pointer
,	O
int	O
verbose_threshold	int
,	O
int	O
(	O
*	O
fp_script	pointer
)	O
(	O
GB	struct
*	O
G	pointer
,	O
int	O
ofd	int
,	O
char	O
*	O
sourcepath	pointer
,	O
int	O
do_get_file_type	int
,	O
int	O
vlv	int
,	O
int	O
delaytime	int
,	O
int	O
nhops	int
,	O
char	O
*	O
pax_write_command_key	pointer
,	O
char	O
*	O
hostname	pointer
,	O
char	O
*	O
blocksize	pointer
)	O
)	O
{	O
pid_t	int
write_pid	int
;	O
if	O
(	O
(	O
swutil_x_mode	int
==	O
0	int
||	O
local_stdin	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
write_pid	int
=	O
swndfork	function
(	O
fork_blockmask	pointer
,	O
fork_defaultmask	pointer
)	O
;	O
if	O
(	O
write_pid	int
==	O
0	int
)	O
{	O
int	O
ret_source	int
=	O
0	int
;	O
if	O
(	O
swutil_x_mode	int
&&	O
local_stdin	int
==	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_IDB2	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"running source script.\n"	pointer
)	O
;	O
ret_source	int
=	O
(	O
*	O
fp_script	pointer
)	O
(	O
G	pointer
,	O
source_pipe	int
,	O
source_path	pointer
,	O
SWINSTALL_DO_SOURCE_CTL_MESSAGE	O
,	O
verbose_threshold	int
,	O
SWC_SCRIPT_SLEEP_DELAY	int
,	O
nhops	int
,	O
pax_write_command_key	pointer
,	O
hostname	pointer
,	O
blocksize	pointer
)	O
;	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_IDB2	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"Source script finished return value=%d.\n"	pointer
,	O
ret_source	int
)	O
;	O
}	O
else	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
G	pointer
->	O
g_fail_loudly	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"Unexpected Dead code excpeption\n"	pointer
)	O
;	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
SWC_VERBOSE_IDB2	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"NOT running source script in child, exiting with %d.\n"	pointer
,	O
ret_source	int
)	O
;	O
LCEXIT	O
(	O
1	int
)	O
;	O
}	O
_exit	function
(	O
ret_source	int
)	O
;	O
}	O
else	O
if	O
(	O
write_pid	int
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
G	pointer
->	O
g_fail_loudly	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"fork error : %s\n"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
return	O
write_pid	int
;	O
}	O
void	O
swc_helptext_target_syntax	function
(	O
FILE	struct
*	O
fp	pointer
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
"\n"	pointer
" Target Syntax:\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
"   software_selections\n"	pointer
"       Refer to the software objects (products, filesets)\n"	pointer
"       on which to be operated.\n"	pointer
"\n"	pointer
"   target\n"	pointer
"       Refers to the software_collection where the software\n"	pointer
"       selections are to be applied.\n"	pointer
"       Target follows syntax of Section 4.1.4.2 (Source and Target\n"	pointer
"       Specification and Logic) summarized as follows:\n"	pointer
"\n"	pointer
"       target : HOST_CHARACTER_STRING ':' PATHNAME_CHARACTER_STRING\n"	pointer
"              | HOST_CHARACTER_STRING ':'\n"	pointer
"              | HOST_CHARACTER_STRING \n"	pointer
"              | PATHNAME_CHARACTER_STRING \n"	pointer
"              ; \n"	pointer
"\n"	pointer
"       PATHNAME_CHARACTER_STRING must be an absolute path unless the\n"	pointer
"                                 target has a HOST_CHARACTER_STRING\n"	pointer
"                                 in which case it may be a relative path.\n"	pointer
"       HOST_CHARACTER_STRING is an IP or hostname or '-'\n"	pointer
"          NOTE: A '-' indicating standard output is an implementation\n"	pointer
"                    extension.\n"	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
"\n"	pointer
" Implementation Extension Target Syntax:\n"	pointer
"\n"	pointer
" Multiple Ssh Hop Syntax:\n"	pointer
"   Two styles supported, one using @@ as the\n"	pointer
"   delimeter and another using a colon\n"	pointer
"\n"	pointer
"   Delimiter: @@  (double @)\n"	pointer
"     [User@]Host@@Host[@@Host]:File\n"	pointer
"\n"	pointer
"   Delimiter: : (colon)\n"	pointer
"     :File\n"	pointer
"     [User@]Host\n"	pointer
"     [User@]Host:\n"	pointer
"     [User@]Host:File\n"	pointer
"     [User@]Host:Host:\n"	pointer
"     [User@]Host:Host:File\n"	pointer
"     [User@]Host:[User@]Host:\n"	pointer
"         'Host' may contain an underscore and if it does\n"	pointer
"          [since it is illegal in a hostname] is interpreted\n"	pointer
"          as host_port\n"	pointer
"\n"	pointer
)	O
;	O
}	O
int	O
swc_wait_on_script	function
(	O
GB	struct
*	O
G	pointer
,	O
pid_t	int
write_pid	int
,	O
char	O
*	O
location	pointer
)	O
{	O
pid_t	int
ret	int
;	O
int	O
status	int
;	O
ret	int
=	O
waitpid	function
(	O
write_pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
G	pointer
->	O
g_fail_loudly	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"%s scripts waitpid : %s\n"	pointer
,	O
location	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
)	O
{	O
return	O
(	O
int	O
)	O
(	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
;	O
}	O
else	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
G	pointer
->	O
g_fail_loudly	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"%s script had abnormal exit.\n"	pointer
,	O
location	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
}	O
void	O
swc_set_shell_dash_s_command	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
wopt_shell_command	pointer
)	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
char	O
*	O
sh_dash_s	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
32	int
)	O
;	O
if	O
(	O
strcasecmp	function
(	O
wopt_shell_command	pointer
,	O
SWC_SHELL_KEY_POSIX	pointer
)	O
==	O
0	int
||	O
strcasecmp	function
(	O
wopt_shell_command	pointer
,	O
SWC_SHELL_KEY_DETECT	pointer
)	O
==	O
0	int
)	O
{	O
wopt_shell_command	pointer
=	O
SWC_SHELL_KEY_SH	O
;	O
}	O
sh_dash_s	pointer
=	O
swssh_landing_command	function
(	O
wopt_shell_command	pointer
,	O
0	int
)	O
;	O
if	O
(	O
G	pointer
->	O
g_do_cleanshM	int
==	O
0	int
)	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_NO_APPEND	int
,	O
"%s /_swbis /_%s"	pointer
,	O
sh_dash_s	pointer
,	O
swlib_utilname_get	function
(	O
)	O
)	O
;	O
}	O
else	O
{	O
strob_sprintf	function
(	O
tmp	pointer
,	O
STROB_NO_APPEND	int
,	O
"%s"	pointer
,	O
sh_dash_s	pointer
)	O
;	O
}	O
G	pointer
->	O
g_sh_dash_s	pointer
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
}	O
int	O
swc_write_swi_debug	function
(	O
SWI	struct
*	O
swi	pointer
,	O
char	O
*	O
filename	pointer
)	O
{	O
int	O
fd	int
;	O
int	O
res	int
;	O
char	O
*	O
image	pointer
;	O
if	O
(	O
isdigit	function
(	O
(	O
int	O
)	O
(	O
*	O
filename	pointer
)	O
)	O
)	O
{	O
fd	int
=	O
swlib_atoi	function
(	O
filename	pointer
,	O
&	O
res	int
)	O
;	O
if	O
(	O
res	int
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
fd	int
=	O
open	function
(	O
filename	pointer
,	O
O_RDWR	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
0644	int
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
image	pointer
=	O
swi_dump_string_s	function
(	O
swi	pointer
,	O
"(SWI*)"	pointer
)	O
;	O
if	O
(	O
!	O
image	pointer
)	O
return	O
-	O
1	int
;	O
res	int
=	O
uxfio_unix_safe_write	function
(	O
fd	int
,	O
image	pointer
,	O
strlen	function
(	O
image	pointer
)	O
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
res	int
;	O
}	O
char	O
*	O
swc_convert_multi_host_target_syntax	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
target_spec	pointer
)	O
{	O
char	O
*	O
retval	int
;	O
char	O
*	O
tmp_target_spec	pointer
;	O
char	O
*	O
first	int
;	O
char	O
*	O
second	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
len	int
;	O
int	O
cnt	int
;	O
int	O
is_a_host	int
;	O
int	O
is_a_file	int
;	O
retval	int
=	O
strdup	function
(	O
target_spec	pointer
)	O
;	O
if	O
(	O
(	O
first	int
=	O
strchr	function
(	O
target_spec	pointer
,	O
':'	O
)	O
)	O
!=	O
NULL	O
&&	O
(	O
second	pointer
=	O
strchr	function
(	O
first	int
+	O
1	int
,	O
':'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
first	int
==	O
target_spec	pointer
&&	O
second	pointer
==	O
target_spec	pointer
+	O
strlen	function
(	O
target_spec	pointer
)	O
-	O
1	int
)	O
{	O
swlib_doif_writef	O
(	O
G	pointer
->	O
g_verboseG	int
,	O
G	pointer
->	O
g_fail_loudly	int
,	O
&	O
G	pointer
->	O
g_logspec	pointer
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
"warning: assuming %s is a host\n"	pointer
,	O
target_spec	pointer
)	O
;	O
*	O
second	pointer
=	O
'\0'	O
;	O
retval	int
=	O
strdup	function
(	O
first	int
+	O
1	int
)	O
;	O
return	O
retval	int
;	O
}	O
else	O
{	O
len	int
=	O
strlen	function
(	O
target_spec	pointer
)	O
;	O
is_a_host	int
=	O
0	int
;	O
is_a_file	int
=	O
0	int
;	O
cnt	int
=	O
len	int
;	O
tmp_target_spec	pointer
=	O
retval	int
;	O
s	pointer
=	O
tmp_target_spec	pointer
+	O
(	O
len	int
-	O
1	int
)	O
;	O
while	O
(	O
cnt	int
>	O
0	int
)	O
{	O
s	pointer
=	O
tmp_target_spec	pointer
+	O
(	O
cnt	int
-	O
1	int
)	O
;	O
if	O
(	O
cnt	int
==	O
len	int
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
':'	O
)	O
{	O
is_a_host	int
=	O
1	int
;	O
*	O
s	pointer
=	O
'\0'	O
;	O
}	O
else	O
{	O
is_a_file	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
':'	O
)	O
{	O
if	O
(	O
is_a_host	int
)	O
{	O
*	O
s	pointer
=	O
'\r'	O
;	O
}	O
else	O
{	O
is_a_host	int
=	O
1	int
;	O
}	O
}	O
cnt	int
--	O
;	O
}	O
{	O
STROB	struct
*	O
tmp	pointer
;	O
tmp	pointer
=	O
strob_open	function
(	O
14	int
)	O
;	O
s	pointer
=	O
tmp_target_spec	pointer
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
'\r'	O
)	O
{	O
strob_strcat	function
(	O
tmp	pointer
,	O
"@@"	pointer
)	O
;	O
}	O
else	O
{	O
strob_charcat	function
(	O
tmp	pointer
,	O
(	O
int	O
)	O
(	O
*	O
s	pointer
)	O
)	O
;	O
}	O
s	pointer
++	O
;	O
}	O
retval	int
=	O
strdup	function
(	O
strob_str	function
(	O
tmp	pointer
)	O
)	O
;	O
strob_close	function
(	O
tmp	pointer
)	O
;	O
return	O
retval	int
;	O
}	O
}	O
}	O
else	O
{	O
return	O
retval	int
;	O
}	O
return	O
retval	int
;	O
}	O
int	O
sw_e_msg	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
int	O
ret	int
;	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
format	pointer
)	O
;	O
ret	int
=	O
doif_i_writef	function
(	O
G	pointer
->	O
g_verboseG	int
,	O
G	pointer
->	O
g_fail_loudly	int
,	O
&	O
(	O
G	pointer
->	O
g_logspec	pointer
)	O
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
format	pointer
,	O
&	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
sw_l_msg	function
(	O
GB	struct
*	O
G	pointer
,	O
int	O
at_level	int
,	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
int	O
ret	int
;	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
format	pointer
)	O
;	O
ret	int
=	O
doif_i_writef	function
(	O
G	pointer
->	O
g_verboseG	int
,	O
at_level	int
,	O
&	O
(	O
G	pointer
->	O
g_logspec	pointer
)	O
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
format	pointer
,	O
&	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
sw_d_msg	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
int	O
dl	int
;	O
int	O
ret	int
;	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
format	pointer
)	O
;	O
dl	int
=	O
G	pointer
->	O
g_verboseG	int
;	O
if	O
(	O
G	pointer
->	O
devel_verboseM	int
)	O
dl	int
=	O
SWC_VERBOSE_IDB2	int
;	O
ret	int
=	O
doif_i_writef	function
(	O
dl	int
,	O
SWC_VERBOSE_IDB2	int
,	O
&	O
(	O
G	pointer
->	O
g_logspec	pointer
)	O
,	O
swc_get_stderr_fd	function
(	O
G	pointer
)	O
,	O
format	pointer
,	O
&	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
ret	int
;	O
}	O
void	O
swc_check_shell_command_key	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
cmd	int
)	O
{	O
char	O
*	O
wopt_shell_command	pointer
=	O
cmd	int
;	O
if	O
(	O
strcmp	function
(	O
wopt_shell_command	pointer
,	O
SWC_SHELL_KEY_BASH	O
)	O
&&	O
strcmp	function
(	O
wopt_shell_command	pointer
,	O
SWC_SHELL_KEY_SH	O
)	O
&&	O
strcmp	function
(	O
wopt_shell_command	pointer
,	O
SWC_SHELL_KEY_KSH	O
)	O
&&	O
strcmp	function
(	O
wopt_shell_command	pointer
,	O
SWC_SHELL_KEY_MKSH	O
)	O
&&	O
strcmp	function
(	O
wopt_shell_command	pointer
,	O
SWC_SHELL_KEY_DETECT	pointer
)	O
&&	O
strcmp	function
(	O
wopt_shell_command	pointer
,	O
SWC_SHELL_KEY_POSIX	pointer
)	O
)	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"illegal shell command: %s \n"	pointer
,	O
wopt_shell_command	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
swc_check_all_pax_commands	function
(	O
GB	struct
*	O
G	pointer
)	O
{	O
char	O
*	O
command	pointer
;	O
char	O
*	O
xcmd	pointer
;	O
char	O
*	O
type	enum
;	O
type	enum
=	O
"write"	pointer
;	O
command	pointer
=	O
get_opta	function
(	O
G	pointer
->	O
optaM	pointer
,	O
SW_E_swbis_local_pax_write_command	int
)	O
,	O
xcmd	pointer
=	O
swc_get_pax_write_command	function
(	O
G	pointer
->	O
g_pax_write_commands	pointer
,	O
command	pointer
,	O
1	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
!	O
xcmd	pointer
)	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"illegal pax %s command: %s \n"	pointer
,	O
type	enum
,	O
command	pointer
)	O
;	O
LCEXIT	O
(	O
1	int
)	O
;	O
}	O
command	pointer
=	O
get_opta	function
(	O
G	pointer
->	O
optaM	pointer
,	O
SW_E_swbis_remote_pax_write_command	int
)	O
;	O
xcmd	pointer
=	O
swc_get_pax_write_command	function
(	O
G	pointer
->	O
g_pax_write_commands	pointer
,	O
command	pointer
,	O
1	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
!	O
xcmd	pointer
)	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"illegal pax %s command: %s \n"	pointer
,	O
type	enum
,	O
command	pointer
)	O
;	O
LCEXIT	O
(	O
1	int
)	O
;	O
}	O
type	enum
=	O
"read"	pointer
;	O
command	pointer
=	O
get_opta	function
(	O
G	pointer
->	O
optaM	pointer
,	O
SW_E_swbis_remote_pax_read_command	int
)	O
;	O
xcmd	pointer
=	O
swc_get_pax_write_command	function
(	O
G	pointer
->	O
g_pax_write_commands	pointer
,	O
command	pointer
,	O
1	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
!	O
xcmd	pointer
)	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"illegal pax %s command: %s \n"	pointer
,	O
type	enum
,	O
command	pointer
)	O
;	O
LCEXIT	O
(	O
1	int
)	O
;	O
}	O
command	pointer
=	O
get_opta	function
(	O
G	pointer
->	O
optaM	pointer
,	O
SW_E_swbis_local_pax_read_command	int
)	O
;	O
xcmd	pointer
=	O
swc_get_pax_write_command	function
(	O
G	pointer
->	O
g_pax_write_commands	pointer
,	O
command	pointer
,	O
1	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
!	O
xcmd	pointer
)	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"illegal pax %s command: %s \n"	pointer
,	O
type	enum
,	O
command	pointer
)	O
;	O
LCEXIT	O
(	O
1	int
)	O
;	O
}	O
}	O
void	O
swc_process_pax_command	function
(	O
GB	struct
*	O
G	pointer
,	O
char	O
*	O
command	pointer
,	O
char	O
*	O
type	enum
,	O
int	O
sw_e_num	int
)	O
{	O
char	O
*	O
xcmd	pointer
;	O
if	O
(	O
strcmp	function
(	O
type	enum
,	O
"write"	pointer
)	O
==	O
0	int
)	O
{	O
xcmd	pointer
=	O
swc_get_pax_write_command	function
(	O
G	pointer
->	O
g_pax_write_commands	pointer
,	O
command	pointer
,	O
G	pointer
->	O
g_verboseG	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
type	enum
,	O
"read"	pointer
)	O
==	O
0	int
)	O
{	O
xcmd	pointer
=	O
swc_get_pax_read_command	function
(	O
G	pointer
->	O
g_pax_read_commands	pointer
,	O
command	pointer
,	O
0	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
type	enum
,	O
"remove"	pointer
)	O
==	O
0	int
)	O
{	O
xcmd	pointer
=	O
swc_get_pax_remove_command	function
(	O
G	pointer
->	O
g_pax_remove_commands	pointer
,	O
command	pointer
,	O
0	int
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
else	O
{	O
xcmd	pointer
=	O
NULL	O
;	O
sw_e_msg	function
(	O
G	pointer
,	O
"internal error\n"	pointer
)	O
;	O
LCEXIT	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
xcmd	pointer
==	O
NULL	O
)	O
{	O
sw_e_msg	function
(	O
G	pointer
,	O
"illegal pax %s command: %s \n"	pointer
,	O
type	enum
,	O
command	pointer
)	O
;	O
LCEXIT	O
(	O
1	int
)	O
;	O
}	O
set_opta	function
(	O
G	pointer
->	O
optaM	pointer
,	O
sw_e_num	int
,	O
command	pointer
)	O
;	O
}	O
char	O
*	O
swc_get_default_sh_dash_s	function
(	O
GB	struct
*	O
G	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
get_opta	function
(	O
G	pointer
->	O
optaM	pointer
,	O
SW_E_swbis_shell_command	int
)	O
,	O
SWC_SHELL_KEY_DETECT	pointer
)	O
==	O
0	int
)	O
return	O
SWSSH_DETECT_POISON_DEFAULT	pointer
;	O
else	O
return	O
G	pointer
->	O
g_sh_dash_s	pointer
;	O
}	O
