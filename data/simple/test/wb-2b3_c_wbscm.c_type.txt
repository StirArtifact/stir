FILE	struct
*	O
diagout	pointer
;	O
static	O
char	O
s_iwb	array
[	O
]	O
=	O
"init-wb"	pointer
;	O
SCM	O
iwb	O
(	O
max_ents	O
,	O
max_buks	O
,	O
max_size	O
)	O
SCM	O
max_ents	O
,	O
max_buks	O
,	O
max_size	O
;	O
{	O
ASRTER	O
(	O
INUMP	O
(	O
max_ents	O
)	O
,	O
max_ents	O
,	O
ARG1	O
,	O
s_iwb	array
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
max_buks	O
)	O
,	O
max_buks	O
,	O
ARG2	O
,	O
s_iwb	array
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
max_size	O
)	O
,	O
max_size	O
,	O
ARG3	O
,	O
s_iwb	array
)	O
;	O
diagout	pointer
=	O
stdout	pointer
;	O
return	O
MAKINUM	function
(	O
init_wb	O
(	O
INUM	O
(	O
max_ents	O
)	O
,	O
INUM	O
(	O
max_buks	O
)	O
,	O
INUM	O
(	O
max_size	O
)	O
)	O
)	O
;	O
}	O
SCM	O
fwb	function
(	O
)	O
{	O
return	O
MAKINUM	function
(	O
final_wb	function
(	O
)	O
)	O
;	O
}	O
void	O
final_db	function
(	O
)	O
{	O
final_wb	function
(	O
)	O
;	O
}	O
long	O
tc16_hand	long
,	O
tc16_segd	long
;	O
typedef	O
struct	O
lhand	struct
{	O
HAND	struct
hand	struct
;	O
SCM	O
seg	int
;	O
}	O
LHAND	struct
;	O
int	O
prinseg	O
(	O
exp	O
,	O
port	int
,	O
writing	int
)	O
SCM	O
exp	O
;	O
SCM	O
port	int
;	O
int	O
writing	int
;	O
{	O
lputs	O
(	O
"#<seg "	pointer
,	O
port	int
)	O
;	O
scm_intprint	O
(	O
LSEG	O
(	O
exp	O
)	O
->	O
ID	long
,	O
10	int
,	O
port	int
)	O
;	O
lputc	O
(	O
'>'	O
,	O
port	int
)	O
;	O
return	O
1	int
;	O
}	O
int	O
prinhan	O
(	O
exp	O
,	O
port	int
,	O
writing	int
)	O
SCM	O
exp	O
;	O
SCM	O
port	int
;	O
int	O
writing	int
;	O
{	O
lputs	O
(	O
"#<han "	pointer
,	O
port	int
)	O
;	O
scm_intprint	O
(	O
CDR	O
(	O
exp	O
)	O
,	O
-	O
16	int
,	O
port	int
)	O
;	O
lputc	O
(	O
'>'	O
,	O
port	int
)	O
;	O
return	O
1	int
;	O
}	O
SCM	O
markhan	O
(	O
ptr	O
)	O
SCM	O
ptr	O
;	O
{	O
return	O
LHANSEG	O
(	O
ptr	O
)	O
;	O
}	O
sizet	O
freehan	O
(	O
p	O
)	O
CELLPTR	O
p	O
;	O
{	O
must_free	O
(	O
CHARS	function
(	O
(	O
SCM	O
)	O
p	O
)	O
,	O
sizeof	O
(	O
LHAND	struct
)	O
)	O
;	O
return	O
sizeof	O
(	O
LHAND	struct
)	O
;	O
}	O
sizet	O
freeseg	O
(	O
p	O
)	O
CELLPTR	O
p	O
;	O
{	O
close_seg	O
(	O
LSEG	O
(	O
(	O
SCM	O
)	O
p	O
)	O
,	O
1	int
)	O
;	O
return	O
sizeof	O
(	O
SEGD	struct
)	O
;	O
}	O
static	O
smobfuns	O
segdsmob	int
=	O
{	O
mark0	O
,	O
freeseg	O
,	O
prinseg	O
,	O
0L	int
}	O
;	O
static	O
smobfuns	O
handsmob	int
=	O
{	O
markhan	O
,	O
freehan	O
,	O
prinhan	O
,	O
0L	int
}	O
;	O
SCM	O
makhand	O
(	O
lseg	pointer
)	O
SCM	O
lseg	pointer
;	O
{	O
SCM	O
s	O
;	O
DEFER_INTS	O
;	O
s	O
=	O
must_malloc_cell	O
(	O
sizeof	O
(	O
LHAND	struct
)	O
+	O
0L	int
,	O
tc16_hand	long
,	O
"WB handle"	pointer
)	O
;	O
LHAN	O
(	O
s	O
)	O
->	O
seg	int
=	O
lseg	pointer
;	O
ALLOW_INTS	O
;	O
return	O
s	O
;	O
}	O
SCM	O
makseg	function
(	O
lseg	pointer
)	O
SEGD	struct
*	O
lseg	pointer
;	O
{	O
SCM	O
z	O
;	O
if	O
(	O
!	O
lseg	pointer
)	O
return	O
BOOL_F	O
;	O
NEWCELL	function
(	O
z	O
)	O
;	O
DEFER_INTS	O
;	O
SETCHARS	function
(	O
z	O
,	O
lseg	pointer
)	O
;	O
CAR	function
(	O
z	O
)	O
=	O
tc16_segd	long
;	O
ALLOW_INTS	O
;	O
return	O
z	O
;	O
}	O
static	O
char	O
s_han_seg	array
[	O
]	O
=	O
"han:seg"	pointer
;	O
SCM	O
lhan_seg	O
(	O
han	O
)	O
SCM	O
han	O
;	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
han	O
)	O
&&	O
HANP	O
(	O
han	O
)	O
,	O
han	O
,	O
ARG1	O
,	O
s_han_seg	array
)	O
;	O
return	O
LHANSEG	O
(	O
han	O
)	O
;	O
}	O
static	O
char	O
s_han_id	array
[	O
]	O
=	O
"han:id"	pointer
;	O
SCM	O
lhan_id	O
(	O
han	O
)	O
SCM	O
han	O
;	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
han	O
)	O
&&	O
HANP	O
(	O
han	O
)	O
,	O
han	O
,	O
ARG1	O
,	O
s_han_id	array
)	O
;	O
return	O
ulong2num	O
(	O
LHANHAN	O
(	O
han	O
)	O
->	O
ID	long
)	O
;	O
}	O
static	O
char	O
s_seg_str	array
[	O
]	O
=	O
"seg:str"	pointer
;	O
SCM	O
lseg_str	O
(	O
seg	int
)	O
SCM	O
seg	int
;	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
seg	int
)	O
&&	O
SEGP	O
(	O
seg	int
)	O
,	O
seg	int
,	O
ARG1	O
,	O
s_seg_str	array
)	O
;	O
return	O
makfrom0str	O
(	O
seg_str	O
(	O
LSEG	O
(	O
seg	int
)	O
)	O
)	O
;	O
}	O
static	O
char	O
s_seg_mutable_P	array
[	O
]	O
=	O
"seg:mutable?"	pointer
;	O
SCM	O
lseg_mutable_P	O
(	O
seg	int
)	O
SCM	O
seg	int
;	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
seg	int
)	O
&&	O
SEGP	O
(	O
seg	int
)	O
,	O
seg	int
,	O
ARG1	O
,	O
s_seg_mutable_P	array
)	O
;	O
return	O
seg_mutable_P	O
(	O
LSEG	O
(	O
seg	int
)	O
)	O
?	O
BOOL_T	O
:	O
BOOL_F	O
;	O
}	O
static	O
char	O
s_open_seg	array
[	O
]	O
=	O
"open-seg"	pointer
;	O
SCM	O
lopen_seg	O
(	O
filename	O
,	O
mode	O
)	O
SCM	O
filename	O
,	O
mode	O
;	O
{	O
SEGD	struct
*	O
seg	int
;	O
ASRTER	O
(	O
NIMP	O
(	O
filename	O
)	O
&&	O
STRINGP	function
(	O
filename	O
)	O
,	O
filename	O
,	O
ARG1	O
,	O
s_open_seg	array
)	O
;	O
seg	int
=	O
open_seg	O
(	O
UCHARS	O
(	O
filename	O
)	O
,	O
!	O
(	O
BOOL_F	O
==	O
mode	O
||	O
INUM0	O
==	O
mode	O
)	O
)	O
;	O
return	O
makseg	function
(	O
seg	int
)	O
;	O
}	O
static	O
char	O
s_make_seg	array
[	O
]	O
=	O
"make-seg"	pointer
;	O
SCM	O
lmake_seg	O
(	O
filename	O
,	O
bsiz	O
)	O
SCM	O
filename	O
,	O
bsiz	O
;	O
{	O
SEGD	struct
*	O
seg	int
;	O
ASRTER	O
(	O
NIMP	O
(	O
filename	O
)	O
&&	O
STRINGP	function
(	O
filename	O
)	O
,	O
filename	O
,	O
ARG1	O
,	O
s_make_seg	array
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
bsiz	O
)	O
,	O
bsiz	O
,	O
ARG2	O
,	O
s_make_seg	array
)	O
;	O
seg	int
=	O
make_seg	O
(	O
UCHARS	O
(	O
filename	O
)	O
,	O
INUM	O
(	O
bsiz	O
)	O
)	O
;	O
return	O
makseg	function
(	O
seg	int
)	O
;	O
}	O
static	O
char	O
s_close_seg	array
[	O
]	O
=	O
"close-seg"	pointer
;	O
SCM	O
lclose_seg	O
(	O
seg	int
,	O
hammer	O
)	O
SCM	O
seg	int
,	O
hammer	O
;	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
seg	int
)	O
&&	O
SEGP	O
(	O
seg	int
)	O
,	O
seg	int
,	O
ARG1	O
,	O
s_close_seg	array
)	O
;	O
return	O
MAKINUM	function
(	O
close_seg	O
(	O
LSEG	O
(	O
seg	int
)	O
,	O
NFALSEP	O
(	O
hammer	O
)	O
)	O
)	O
;	O
}	O
static	O
char	O
s_open_bt	array
[	O
]	O
=	O
"open-bt"	pointer
;	O
SCM	O
lopen_bt	O
(	O
seg	int
,	O
blknum	O
,	O
wcb	O
)	O
SCM	O
seg	int
,	O
blknum	O
,	O
wcb	O
;	O
{	O
SCM	O
bthan	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
seg	int
)	O
&&	O
SEGP	O
(	O
seg	int
)	O
,	O
seg	int
,	O
ARG1	O
,	O
s_open_bt	array
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
blknum	O
)	O
,	O
blknum	O
,	O
ARG2	O
,	O
s_open_bt	array
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
wcb	O
)	O
,	O
wcb	O
,	O
ARG3	O
,	O
s_open_bt	array
)	O
;	O
bthan	O
=	O
makhand	O
(	O
seg	int
)	O
;	O
if	O
(	O
!	O
err_P	O
(	O
bt_open	O
(	O
LSEG	O
(	O
seg	int
)	O
,	O
INUM	O
(	O
blknum	O
)	O
,	O
LHANHAN	O
(	O
bthan	O
)	O
,	O
INUM	O
(	O
wcb	O
)	O
)	O
)	O
)	O
return	O
bthan	O
;	O
else	O
return	O
BOOL_F	O
;	O
}	O
static	O
char	O
s_create_bt	array
[	O
]	O
=	O
"create-bt"	pointer
;	O
SCM	O
lcreate_bt	O
(	O
seg	int
,	O
typ	O
,	O
wcb	O
)	O
SCM	O
seg	int
,	O
typ	O
,	O
wcb	O
;	O
{	O
SCM	O
bthan	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
seg	int
)	O
&&	O
SEGP	O
(	O
seg	int
)	O
,	O
seg	int
,	O
ARG1	O
,	O
s_create_bt	array
)	O
;	O
ASRTER	O
(	O
ICHRP	O
(	O
typ	O
)	O
,	O
typ	O
,	O
ARG2	O
,	O
s_create_bt	array
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
wcb	O
)	O
,	O
wcb	O
,	O
ARG3	O
,	O
s_create_bt	array
)	O
;	O
bthan	O
=	O
makhand	O
(	O
seg	int
)	O
;	O
if	O
(	O
!	O
err_P	O
(	O
bt_create	O
(	O
LSEG	O
(	O
seg	int
)	O
,	O
ICHR	O
(	O
typ	O
)	O
,	O
LHANHAN	O
(	O
bthan	O
)	O
,	O
INUM	O
(	O
wcb	O
)	O
)	O
)	O
)	O
return	O
bthan	O
;	O
else	O
return	O
BOOL_F	O
;	O
}	O
static	O
char	O
s_close_bt	array
[	O
]	O
=	O
"close-bt!"	pointer
;	O
SCM	O
lclose_bt	O
(	O
bthan	O
)	O
SCM	O
bthan	O
;	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
bthan	O
)	O
&&	O
HANP	O
(	O
bthan	O
)	O
,	O
bthan	O
,	O
ARG1	O
,	O
s_close_bt	array
)	O
;	O
bt_close	O
(	O
LHANHAN	O
(	O
bthan	O
)	O
)	O
;	O
return	O
UNSPECIFIED	O
;	O
}	O
int	O
wrapproc	function
(	O
keystr	pointer
,	O
klen	int
,	O
vstr	pointer
,	O
vlen	int
,	O
long_tab	pointer
)	O
unsigned	O
char	O
*	O
keystr	pointer
;	O
int	O
klen	int
;	O
unsigned	O
char	O
*	O
vstr	pointer
;	O
int	O
vlen	int
;	O
unsigned	O
long	O
*	O
long_tab	pointer
;	O
{	O
SCM	O
res	O
=	O
apply	O
(	O
(	O
SCM	O
)	O
long_tab	pointer
,	O
makfromstr	O
(	O
keystr	pointer
,	O
klen	int
)	O
,	O
cons	O
(	O
makfromstr	O
(	O
vstr	pointer
,	O
vlen	int
)	O
,	O
listofnull	O
)	O
)	O
;	O
if	O
INUMP	O
(	O
res	O
)	O
return	O
INUM	O
(	O
res	O
)	O
;	O
if	O
(	O
BOOL_F	O
==	O
res	O
)	O
return	O
notpres	O
;	O
if	O
(	O
BOOL_T	O
==	O
res	O
)	O
return	O
success	O
;	O
if	O
(	O
IMP	function
(	O
res	O
)	O
||	O
!	O
STRINGP	function
(	O
res	O
)	O
)	O
return	O
typerr	O
;	O
{	O
int	O
i	int
=	O
LENGTH	function
(	O
res	O
)	O
;	O
if	O
(	O
i	int
>	O
255	int
)	O
return	O
typerr	O
;	O
while	O
(	O
i	int
--	O
)	O
vstr	pointer
[	O
i	int
]	O
=	O
CHARS	function
(	O
res	O
)	O
[	O
i	int
]	O
;	O
return	O
LENGTH	function
(	O
res	O
)	O
;	O
}	O
}	O
static	O
char	O
s_bt_scan	array
[	O
]	O
=	O
"bt:scan"	pointer
;	O
SCM	O
lscan	O
(	O
bthan	O
,	O
op	O
,	O
args	O
)	O
SCM	O
bthan	O
,	O
op	O
,	O
args	O
;	O
{	O
SCM	O
key1	O
,	O
key2	O
,	O
scmproc	O
,	O
blklim	O
;	O
char	O
ikey	O
[	O
256	int
]	O
;	O
int	O
ipkt	O
[	O
pkt_size	int
]	O
,	O
res	O
,	O
klen2	O
;	O
pkt_set_skey_count	O
(	O
ipkt	O
,	O
0	int
)	O
;	O
ASRTER	O
(	O
4	int
==	O
ilength	O
(	O
args	O
)	O
,	O
args	O
,	O
WNA	O
,	O
s_bt_scan	array
)	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
bthan	O
)	O
&&	O
HANP	O
(	O
bthan	O
)	O
,	O
bthan	O
,	O
ARG1	O
,	O
s_bt_scan	array
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
op	O
)	O
,	O
op	O
,	O
ARG2	O
,	O
s_bt_scan	array
)	O
;	O
key1	O
=	O
CAR	function
(	O
args	O
)	O
;	O
args	O
=	O
CDR	O
(	O
args	O
)	O
;	O
if	O
FALSEP	O
(	O
key1	O
)	O
{	O
key1	O
=	O
nullstr	O
;	O
pkt_set_skey_len	O
(	O
ipkt	O
,	O
LENGTH	function
(	O
key1	O
)	O
)	O
;	O
}	O
else	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
key1	O
)	O
&&	O
STRINGP	function
(	O
key1	O
)	O
,	O
key1	O
,	O
ARG3	O
,	O
s_bt_scan	array
)	O
;	O
pkt_set_skey_len	O
(	O
ipkt	O
,	O
LENGTH	function
(	O
key1	O
)	O
)	O
;	O
memcpy	O
(	O
ikey	O
,	O
CHARS	function
(	O
key1	O
)	O
,	O
LENGTH	function
(	O
key1	O
)	O
)	O
;	O
}	O
key2	O
=	O
CAR	function
(	O
args	O
)	O
;	O
args	O
=	O
CDR	O
(	O
args	O
)	O
;	O
if	O
FALSEP	O
(	O
key2	O
)	O
{	O
key2	O
=	O
nullstr	O
;	O
klen2	O
=	O
end_of_chain	O
;	O
}	O
else	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
key2	O
)	O
&&	O
STRINGP	function
(	O
key2	O
)	O
,	O
key2	O
,	O
ARG4	O
,	O
s_bt_scan	array
)	O
;	O
klen2	O
=	O
LENGTH	function
(	O
key2	O
)	O
;	O
}	O
scmproc	O
=	O
CAR	function
(	O
args	O
)	O
;	O
args	O
=	O
CDR	O
(	O
args	O
)	O
;	O
ASRTER	O
(	O
FALSEP	O
(	O
scmproc	O
)	O
||	O
(	O
NIMP	O
(	O
scmproc	O
)	O
&&	O
BOOL_T	O
==	O
procedurep	O
(	O
scmproc	O
)	O
)	O
,	O
scmproc	O
,	O
ARG5	O
,	O
s_bt_scan	array
)	O
;	O
blklim	O
=	O
CAR	function
(	O
args	O
)	O
;	O
args	O
=	O
CDR	O
(	O
args	O
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
blklim	O
)	O
,	O
blklim	O
,	O
ARG5	O
,	O
s_bt_scan	array
)	O
;	O
res	O
=	O
bt_scan	O
(	O
(	O
HAND	struct
*	O
)	O
CHARS	function
(	O
bthan	O
)	O
,	O
INUM	O
(	O
op	O
)	O
,	O
ikey	O
,	O
pkt_skey_len	O
(	O
ipkt	O
)	O
,	O
UCHARS	O
(	O
key2	O
)	O
,	O
klen2	O
,	O
FALSEP	O
(	O
scmproc	O
)	O
?	O
0L	int
:	O
wrapproc	function
,	O
scmproc	O
,	O
ipkt	O
,	O
INUM	O
(	O
blklim	O
)	O
)	O
;	O
return	O
cons2	O
(	O
MAKINUM	function
(	O
res	O
)	O
,	O
MAKINUM	function
(	O
pkt_skey_count	O
(	O
ipkt	O
)	O
)	O
,	O
cons	O
(	O
makfromstr	O
(	O
ikey	O
,	O
pkt_skey_len	O
(	O
ipkt	O
)	O
)	O
,	O
EOL	O
)	O
)	O
;	O
}	O
static	O
char	O
s_bt_get	array
[	O
]	O
=	O
"bt:get"	pointer
;	O
SCM	O
lbt_get	O
(	O
bthan	O
,	O
key	O
)	O
SCM	O
bthan	O
,	O
key	O
;	O
{	O
unsigned	O
char	O
buff	O
[	O
256	int
]	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
bthan	O
)	O
&&	O
HANP	O
(	O
bthan	O
)	O
,	O
bthan	O
,	O
ARG1	O
,	O
s_bt_get	array
)	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
key	O
)	O
&&	O
STRINGP	function
(	O
key	O
)	O
,	O
key	O
,	O
ARG2	O
,	O
s_bt_get	array
)	O
;	O
{	O
int	O
tlen	O
=	O
bt_get	O
(	O
LHANHAN	O
(	O
bthan	O
)	O
,	O
UCHARS	O
(	O
key	O
)	O
,	O
LENGTH	function
(	O
key	O
)	O
,	O
buff	O
)	O
;	O
if	O
(	O
tlen	O
>=	O
0	int
)	O
return	O
makfromstr	O
(	O
buff	O
,	O
tlen	O
)	O
;	O
return	O
BOOL_F	O
;	O
}	O
}	O
static	O
char	O
s_bt_next	array
[	O
]	O
=	O
"bt:next"	pointer
;	O
SCM	O
lbt_next	O
(	O
bthan	O
,	O
key	O
)	O
SCM	O
bthan	O
,	O
key	O
;	O
{	O
unsigned	O
char	O
buff	O
[	O
256	int
]	O
;	O
int	O
klen	int
;	O
ASRTER	O
(	O
NIMP	O
(	O
bthan	O
)	O
&&	O
HANP	O
(	O
bthan	O
)	O
,	O
bthan	O
,	O
ARG1	O
,	O
s_bt_next	array
)	O
;	O
if	O
FALSEP	O
(	O
key	O
)	O
{	O
key	O
=	O
nullstr	O
;	O
klen	int
=	O
start_of_chain	O
;	O
}	O
else	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
key	O
)	O
&&	O
STRINGP	function
(	O
key	O
)	O
,	O
key	O
,	O
ARG2	O
,	O
s_bt_next	array
)	O
;	O
klen	int
=	O
LENGTH	function
(	O
key	O
)	O
;	O
}	O
{	O
int	O
tlen	O
=	O
bt_next	O
(	O
LHANHAN	O
(	O
bthan	O
)	O
,	O
UCHARS	O
(	O
key	O
)	O
,	O
klen	int
,	O
buff	O
)	O
;	O
if	O
(	O
tlen	O
>=	O
0	int
)	O
return	O
makfromstr	O
(	O
buff	O
,	O
tlen	O
)	O
;	O
return	O
BOOL_F	O
;	O
}	O
}	O
static	O
char	O
s_bt_prev	array
[	O
]	O
=	O
"bt:prev"	pointer
;	O
SCM	O
lbt_prev	O
(	O
bthan	O
,	O
key	O
)	O
SCM	O
bthan	O
,	O
key	O
;	O
{	O
unsigned	O
char	O
buff	O
[	O
256	int
]	O
;	O
int	O
klen	int
;	O
ASRTER	O
(	O
NIMP	O
(	O
bthan	O
)	O
&&	O
HANP	O
(	O
bthan	O
)	O
,	O
bthan	O
,	O
ARG1	O
,	O
s_bt_prev	array
)	O
;	O
if	O
FALSEP	O
(	O
key	O
)	O
{	O
key	O
=	O
nullstr	O
;	O
klen	int
=	O
end_of_chain	O
;	O
}	O
else	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
key	O
)	O
&&	O
STRINGP	function
(	O
key	O
)	O
,	O
key	O
,	O
ARG2	O
,	O
s_bt_prev	array
)	O
;	O
klen	int
=	O
LENGTH	function
(	O
key	O
)	O
;	O
}	O
{	O
int	O
tlen	O
=	O
bt_prev	O
(	O
LHANHAN	O
(	O
bthan	O
)	O
,	O
UCHARS	O
(	O
key	O
)	O
,	O
klen	int
,	O
buff	O
)	O
;	O
if	O
(	O
tlen	O
>=	O
0	int
)	O
return	O
makfromstr	O
(	O
buff	O
,	O
tlen	O
)	O
;	O
return	O
BOOL_F	O
;	O
}	O
}	O
static	O
char	O
s_bt_rem	array
[	O
]	O
=	O
"bt:rem!"	pointer
;	O
SCM	O
lbt_rem	O
(	O
bthan	O
,	O
key	O
)	O
SCM	O
bthan	O
,	O
key	O
;	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
bthan	O
)	O
&&	O
HANP	O
(	O
bthan	O
)	O
,	O
bthan	O
,	O
ARG1	O
,	O
s_bt_rem	array
)	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
key	O
)	O
&&	O
STRINGP	function
(	O
key	O
)	O
,	O
key	O
,	O
ARG2	O
,	O
s_bt_rem	array
)	O
;	O
if	O
(	O
!	O
bt_rem	O
(	O
LHANHAN	O
(	O
bthan	O
)	O
,	O
UCHARS	O
(	O
key	O
)	O
,	O
LENGTH	function
(	O
key	O
)	O
,	O
0L	int
)	O
)	O
return	O
BOOL_T	O
;	O
else	O
return	O
BOOL_F	O
;	O
}	O
static	O
char	O
s_bt_read	array
[	O
]	O
=	O
"bt:rem"	pointer
;	O
SCM	O
lbt_read	O
(	O
bthan	O
,	O
key	O
)	O
SCM	O
bthan	O
,	O
key	O
;	O
{	O
unsigned	O
char	O
buff	O
[	O
256	int
]	O
;	O
int	O
tlen	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
bthan	O
)	O
&&	O
HANP	O
(	O
bthan	O
)	O
,	O
bthan	O
,	O
ARG1	O
,	O
s_bt_read	array
)	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
key	O
)	O
&&	O
STRINGP	function
(	O
key	O
)	O
,	O
key	O
,	O
ARG2	O
,	O
s_bt_read	array
)	O
;	O
tlen	O
=	O
bt_rem	O
(	O
LHANHAN	O
(	O
bthan	O
)	O
,	O
UCHARS	O
(	O
key	O
)	O
,	O
LENGTH	function
(	O
key	O
)	O
,	O
buff	O
)	O
;	O
if	O
(	O
tlen	O
>=	O
0	int
)	O
return	O
makfromstr	O
(	O
buff	O
,	O
tlen	O
)	O
;	O
return	O
BOOL_F	O
;	O
}	O
static	O
char	O
s_bt_rem_star	array
[	O
]	O
=	O
"bt:rem*"	pointer
;	O
SCM	O
lbt_rem_star	O
(	O
bthan	O
,	O
key	O
,	O
key2	O
)	O
SCM	O
bthan	O
,	O
key	O
,	O
key2	O
;	O
{	O
char	O
tmpstr	O
[	O
256	int
]	O
;	O
int	O
klen	int
,	O
klen2	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
bthan	O
)	O
&&	O
HANP	O
(	O
bthan	O
)	O
,	O
bthan	O
,	O
ARG1	O
,	O
s_bt_rem_star	array
)	O
;	O
if	O
FALSEP	O
(	O
key	O
)	O
{	O
key	O
=	O
nullstr	O
;	O
klen	int
=	O
start_of_chain	O
;	O
}	O
else	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
key	O
)	O
&&	O
STRINGP	function
(	O
key	O
)	O
,	O
key	O
,	O
ARG2	O
,	O
s_bt_rem_star	array
)	O
;	O
klen	int
=	O
LENGTH	function
(	O
key	O
)	O
;	O
}	O
if	O
(	O
klen	int
>	O
0	int
)	O
memcpy	O
(	O
tmpstr	O
,	O
CHARS	function
(	O
key	O
)	O
,	O
klen	int
)	O
;	O
if	O
FALSEP	O
(	O
key2	O
)	O
{	O
key2	O
=	O
nullstr	O
;	O
klen2	O
=	O
end_of_chain	O
;	O
}	O
else	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
key2	O
)	O
&&	O
STRINGP	function
(	O
key2	O
)	O
,	O
key2	O
,	O
ARG3	O
,	O
s_bt_rem_star	array
)	O
;	O
klen2	O
=	O
LENGTH	function
(	O
key2	O
)	O
;	O
}	O
if	O
(	O
!	O
bt_rem_range	O
(	O
LHANHAN	O
(	O
bthan	O
)	O
,	O
tmpstr	O
,	O
klen	int
,	O
UCHARS	O
(	O
key2	O
)	O
,	O
klen2	O
)	O
)	O
return	O
BOOL_T	O
;	O
else	O
return	O
BOOL_F	O
;	O
}	O
static	O
char	O
s_bt_put	array
[	O
]	O
=	O
"bt:put!"	pointer
;	O
SCM	O
lbt_put	O
(	O
bthan	O
,	O
key	O
,	O
val	O
)	O
SCM	O
bthan	O
,	O
key	O
,	O
val	O
;	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
bthan	O
)	O
&&	O
HANP	O
(	O
bthan	O
)	O
,	O
bthan	O
,	O
ARG1	O
,	O
s_bt_put	array
)	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
key	O
)	O
&&	O
STRINGP	function
(	O
key	O
)	O
,	O
key	O
,	O
ARG2	O
,	O
s_bt_put	array
)	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
val	O
)	O
&&	O
STRINGP	function
(	O
val	O
)	O
,	O
val	O
,	O
ARG3	O
,	O
s_bt_put	array
)	O
;	O
if	O
(	O
!	O
bt_put	O
(	O
LHANHAN	O
(	O
bthan	O
)	O
,	O
UCHARS	O
(	O
key	O
)	O
,	O
LENGTH	function
(	O
key	O
)	O
,	O
UCHARS	O
(	O
val	O
)	O
,	O
LENGTH	function
(	O
val	O
)	O
)	O
)	O
return	O
BOOL_T	O
;	O
else	O
return	O
BOOL_F	O
;	O
}	O
static	O
char	O
s_bt_write	array
[	O
]	O
=	O
"bt:put"	pointer
;	O
SCM	O
lbt_write	O
(	O
bthan	O
,	O
key	O
,	O
val	O
)	O
SCM	O
bthan	O
,	O
key	O
,	O
val	O
;	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
bthan	O
)	O
&&	O
HANP	O
(	O
bthan	O
)	O
,	O
bthan	O
,	O
ARG1	O
,	O
s_bt_write	array
)	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
key	O
)	O
&&	O
STRINGP	function
(	O
key	O
)	O
,	O
key	O
,	O
ARG2	O
,	O
s_bt_write	array
)	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
val	O
)	O
&&	O
STRINGP	function
(	O
val	O
)	O
,	O
val	O
,	O
ARG3	O
,	O
s_bt_write	array
)	O
;	O
if	O
(	O
!	O
bt_write	O
(	O
LHANHAN	O
(	O
bthan	O
)	O
,	O
UCHARS	O
(	O
key	O
)	O
,	O
LENGTH	function
(	O
key	O
)	O
,	O
UCHARS	O
(	O
val	O
)	O
,	O
LENGTH	function
(	O
val	O
)	O
)	O
)	O
return	O
BOOL_T	O
;	O
else	O
return	O
BOOL_F	O
;	O
}	O
static	O
char	O
s_create_db	array
[	O
]	O
=	O
"create-db"	pointer
;	O
SCM	O
lcreate_db	O
(	O
seg	int
,	O
typ	O
,	O
name	int
)	O
SCM	O
seg	int
,	O
typ	O
,	O
name	int
;	O
{	O
SCM	O
a_han	O
;	O
SCM	O
d_han	O
;	O
SCM	O
tmp_str	O
=	O
makstr	O
(	O
5	int
)	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
seg	int
)	O
&&	O
SEGP	O
(	O
seg	int
)	O
,	O
seg	int
,	O
ARG1	O
,	O
s_create_db	array
)	O
;	O
ASRTER	O
(	O
ICHRP	O
(	O
typ	O
)	O
,	O
typ	O
,	O
ARG2	O
,	O
s_create_db	array
)	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
name	int
)	O
&&	O
STRINGP	function
(	O
name	int
)	O
,	O
name	int
,	O
ARG3	O
,	O
s_create_db	array
)	O
;	O
a_han	O
=	O
lcreate_bt	O
(	O
seg	int
,	O
typ	O
,	O
INUM0	O
)	O
;	O
d_han	O
=	O
lopen_bt	O
(	O
seg	int
,	O
MAKINUM	function
(	O
1	int
)	O
,	O
INUM0	O
)	O
;	O
if	O
(	O
FALSEP	O
(	O
a_han	O
)	O
||	O
FALSEP	O
(	O
d_han	O
)	O
)	O
return	O
BOOL_F	O
;	O
CHARS	function
(	O
tmp_str	O
)	O
[	O
0	int
]	O
=	O
4	int
;	O
long2str	O
(	O
UCHARS	O
(	O
tmp_str	O
)	O
,	O
1	int
,	O
han_id	O
(	O
LHANHAN	O
(	O
a_han	O
)	O
)	O
)	O
;	O
lbt_put	O
(	O
d_han	O
,	O
name	int
,	O
tmp_str	O
)	O
;	O
lclose_bt	O
(	O
d_han	O
)	O
;	O
return	O
a_han	O
;	O
}	O
static	O
char	O
s_open_db	array
[	O
]	O
=	O
"open-db"	pointer
;	O
SCM	O
lopen_db	O
(	O
seg	int
,	O
name	int
)	O
SCM	O
seg	int
,	O
name	int
;	O
{	O
SCM	O
d_han	O
,	O
nn	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
seg	int
)	O
&&	O
SEGP	O
(	O
seg	int
)	O
,	O
seg	int
,	O
ARG1	O
,	O
s_open_db	array
)	O
;	O
ASRTER	O
(	O
NIMP	O
(	O
name	int
)	O
&&	O
STRINGP	function
(	O
name	int
)	O
,	O
name	int
,	O
ARG2	O
,	O
s_open_db	array
)	O
;	O
d_han	O
=	O
lopen_bt	O
(	O
seg	int
,	O
MAKINUM	function
(	O
1	int
)	O
,	O
INUM0	O
)	O
;	O
nn	O
=	O
lbt_get	O
(	O
d_han	O
,	O
name	int
)	O
;	O
if	O
(	O
NIMP	O
(	O
nn	O
)	O
&&	O
STRINGP	function
(	O
nn	O
)	O
&&	O
(	O
LENGTH	function
(	O
nn	O
)	O
>	O
4	int
)	O
&&	O
(	O
CHARS	function
(	O
nn	O
)	O
[	O
0	int
]	O
==	O
4	int
)	O
)	O
return	O
lopen_bt	O
(	O
seg	int
,	O
MAKINUM	function
(	O
str2long	O
(	O
UCHARS	O
(	O
nn	O
)	O
+	O
1	int
,	O
0	int
)	O
)	O
,	O
INUM0	O
)	O
;	O
else	O
return	O
BOOL_F	O
;	O
}	O
static	O
char	O
s_flush_ents	array
[	O
]	O
=	O
"flush-ents"	pointer
;	O
SCM	O
lflush_ents	O
(	O
numtry	O
,	O
numflush	O
)	O
SCM	O
numtry	O
,	O
numflush	O
;	O
{	O
ASRTER	O
(	O
INUMP	O
(	O
numtry	O
)	O
,	O
numtry	O
,	O
ARG1	O
,	O
s_flush_ents	array
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
numflush	O
)	O
,	O
numflush	O
,	O
ARG2	O
,	O
s_flush_ents	array
)	O
;	O
return	O
MAKINUM	function
(	O
ents_flush	O
(	O
INUM	O
(	O
numtry	O
)	O
,	O
INUM	O
(	O
numflush	O
)	O
)	O
)	O
;	O
}	O
SCM	O
lcheck_access	function
(	O
)	O
{	O
check_access	function
(	O
)	O
;	O
return	O
UNSPECIFIED	O
;	O
}	O
SCM	O
lclear	function
(	O
)	O
{	O
clear_stats	function
(	O
)	O
;	O
return	O
UNSPECIFIED	O
;	O
}	O
SCM	O
lstats	function
(	O
)	O
{	O
stats	function
(	O
)	O
;	O
return	O
UNSPECIFIED	O
;	O
}	O
SCM	O
lcstats	function
(	O
)	O
{	O
cstats	function
(	O
)	O
;	O
return	O
UNSPECIFIED	O
;	O
}	O
SCM	O
lsb	function
(	O
)	O
{	O
sb	function
(	O
)	O
;	O
return	O
UNSPECIFIED	O
;	O
}	O
static	O
char	O
s_s2l	array
[	O
]	O
=	O
"str2long"	pointer
;	O
SCM	O
s2l	O
(	O
str	O
,	O
pos	O
)	O
SCM	O
str	O
,	O
pos	O
;	O
{	O
ASRTER	O
(	O
NIMP	O
(	O
str	O
)	O
&&	O
STRINGP	function
(	O
str	O
)	O
,	O
str	O
,	O
ARG1	O
,	O
s_s2l	array
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
pos	O
)	O
,	O
pos	O
,	O
ARG2	O
,	O
s_s2l	array
)	O
;	O
ASRTER	O
(	O
LENGTH	function
(	O
str	O
)	O
>=	O
INUM	O
(	O
pos	O
)	O
+	O
4	int
,	O
pos	O
,	O
OUTOFRANGE	O
,	O
s_s2l	array
)	O
;	O
return	O
MAKINUM	function
(	O
str2long	O
(	O
CHARS	function
(	O
str	O
)	O
,	O
INUM	O
(	O
pos	O
)	O
)	O
)	O
;	O
}	O
static	O
char	O
s_l2s	array
[	O
]	O
=	O
"long2str!"	pointer
;	O
SCM	O
l2s	O
(	O
str	O
,	O
pos	O
,	O
clong	O
)	O
SCM	O
str	O
,	O
pos	O
,	O
clong	O
;	O
{	O
unsigned	O
long	O
clng	O
=	O
0	int
;	O
ASRTER	O
(	O
NIMP	O
(	O
str	O
)	O
&&	O
STRINGP	function
(	O
str	O
)	O
,	O
str	O
,	O
ARG1	O
,	O
s_l2s	array
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
pos	O
)	O
,	O
pos	O
,	O
ARG2	O
,	O
s_l2s	array
)	O
;	O
ASRTER	O
(	O
NUMBERP	O
(	O
clong	O
)	O
,	O
clong	O
,	O
ARG3	O
,	O
s_l2s	array
)	O
;	O
ASRTER	O
(	O
LENGTH	function
(	O
str	O
)	O
>=	O
INUM	O
(	O
pos	O
)	O
+	O
4	int
,	O
pos	O
,	O
OUTOFRANGE	O
,	O
s_l2s	array
)	O
;	O
ASRTER	O
(	O
INUMP	O
(	O
clong	O
)	O
,	O
clong	O
,	O
ARG1	O
,	O
s_l2s	array
)	O
;	O
clng	O
=	O
INUM	O
(	O
(	O
unsigned	O
long	O
)	O
clong	O
)	O
;	O
long2str	O
(	O
CHARS	function
(	O
str	O
)	O
,	O
INUM	O
(	O
pos	O
)	O
,	O
clng	O
)	O
;	O
return	O
UNSPECIFIED	O
;	O
}	O
SCM	O
wb_err_P	O
(	O
x	O
)	O
SCM	O
x	O
;	O
{	O
if	O
(	O
INUMP	O
(	O
x	O
)	O
)	O
return	O
err_P	O
(	O
INUM	O
(	O
x	O
)	O
)	O
?	O
BOOL_T	O
:	O
BOOL_F	O
;	O
return	O
BOOL_F	O
;	O
}	O
static	O
iproc	O
subr0s	array
[	O
]	O
=	O
{	O
{	O
"final-wb"	pointer
,	O
fwb	function
}	O
,	O
{	O
"check-access!"	pointer
,	O
lcheck_access	function
}	O
,	O
{	O
"clear-stats"	pointer
,	O
lclear	function
}	O
,	O
{	O
"stats"	pointer
,	O
lstats	function
}	O
,	O
{	O
"cstats"	pointer
,	O
lcstats	function
}	O
,	O
{	O
"show-buffers"	pointer
,	O
lsb	function
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
iproc	O
subr1s	array
[	O
]	O
=	O
{	O
{	O
s_close_bt	array
,	O
lclose_bt	O
}	O
,	O
{	O
s_han_seg	array
,	O
lhan_seg	O
}	O
,	O
{	O
s_han_id	array
,	O
lhan_id	O
}	O
,	O
{	O
s_seg_str	array
,	O
lseg_str	O
}	O
,	O
{	O
s_seg_mutable_P	array
,	O
lseg_mutable_P	O
}	O
,	O
{	O
"wb:err?"	pointer
,	O
wb_err_P	O
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
iproc	O
subr2s	array
[	O
]	O
=	O
{	O
{	O
s_open_seg	array
,	O
lopen_seg	O
}	O
,	O
{	O
s_make_seg	array
,	O
lmake_seg	O
}	O
,	O
{	O
s_close_seg	array
,	O
lclose_seg	O
}	O
,	O
{	O
s_bt_get	array
,	O
lbt_get	O
}	O
,	O
{	O
s_bt_next	array
,	O
lbt_next	O
}	O
,	O
{	O
s_bt_prev	array
,	O
lbt_prev	O
}	O
,	O
{	O
s_bt_rem	array
,	O
lbt_rem	O
}	O
,	O
{	O
s_bt_read	array
,	O
lbt_read	O
}	O
,	O
{	O
s_open_db	array
,	O
lopen_db	O
}	O
,	O
{	O
s_flush_ents	array
,	O
lflush_ents	O
}	O
,	O
{	O
s_s2l	array
,	O
s2l	O
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
iproc	O
subr3s	array
[	O
]	O
=	O
{	O
{	O
s_iwb	array
,	O
iwb	O
}	O
,	O
{	O
s_open_bt	array
,	O
lopen_bt	O
}	O
,	O
{	O
s_create_bt	array
,	O
lcreate_bt	O
}	O
,	O
{	O
s_bt_put	array
,	O
lbt_put	O
}	O
,	O
{	O
s_bt_write	array
,	O
lbt_write	O
}	O
,	O
{	O
s_create_db	array
,	O
lcreate_db	O
}	O
,	O
{	O
s_bt_rem_star	array
,	O
lbt_rem_star	O
}	O
,	O
{	O
s_l2s	array
,	O
l2s	O
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
void	O
init_db	function
(	O
)	O
{	O
tc16_hand	long
=	O
newsmob	function
(	O
&	O
handsmob	int
)	O
;	O
tc16_segd	long
=	O
newsmob	function
(	O
&	O
segdsmob	int
)	O
;	O
init_iprocs	function
(	O
subr0s	array
,	O
tc7_subr_0	O
)	O
;	O
init_iprocs	function
(	O
subr1s	array
,	O
tc7_subr_1	O
)	O
;	O
init_iprocs	function
(	O
subr2s	array
,	O
tc7_subr_2	O
)	O
;	O
init_iprocs	function
(	O
subr3s	array
,	O
tc7_subr_3	O
)	O
;	O
make_subr	function
(	O
s_bt_scan	array
,	O
tc7_lsubr_2	O
,	O
lscan	O
)	O
;	O
add_feature	function
(	O
s_open_db	array
+	O
5	int
)	O
;	O
add_feature	function
(	O
s_iwb	array
+	O
5	int
)	O
;	O
add_final	function
(	O
final_db	function
)	O
;	O
scm_ldstr	function
(	O
"\n\n(define (db:put! han ckey val)\n  (define len (string-length val))\n  (define (put! han ckey val)\n    (and (wb:err? (bt:put! han ckey val))\n	 (slib:error 'db:put 'could-not-put han ckey val)))\n  (cond ((> len 255)\n	 (put! han ckey (substring val 0 255))\n	 (do ((kdx 1 (+ 1 kdx))\n	      (idx 510 (+ 255 idx))\n	      (ldx 255 idx))\n	     ((>= idx len)\n	      (put! han (string-append ckey (bytes kdx))\n		    (substring val ldx len)))\n	   (put! han (string-append ckey (bytes kdx))\n		 (substring val ldx idx))))\n	(else (put! han ckey val))))\n\n(define (db:get han ckey)\n  (define val (bt:get han ckey))\n  (and val\n       (case (string-length val)\n	 ((255)\n	  (let ((ckey+ (string-append ckey (bytes 255)))\n		(strs (list val)))\n	    (define bytes:0 (bytes 0))\n	    (define tail strs)\n	    (define (maproc k v)\n	      (set-cdr! tail (list v))\n	      (set! tail (cdr tail))\n	      #t)\n	    (do ((res (bt:scan han 0 (string-append ckey bytes:0) ckey+\n			       maproc 1)\n		      (bt:scan han 0 (caddr res) ckey+ maproc 1)))\n		((not (= -1 (car res)))\n		 (apply string-append strs)))))\n	 (else val))))\n"	pointer
)	O
;	O
}	O
void	O
init_wbscm	function
(	O
)	O
{	O
init_db	function
(	O
)	O
;	O
}	O
