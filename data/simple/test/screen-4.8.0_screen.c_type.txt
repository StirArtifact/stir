extern	O
char	O
Term	array
[	O
]	O
,	O
screenterm	array
[	O
]	O
,	O
*	O
*	O
environ	pointer
,	O
Termcap	array
[	O
]	O
;	O
int	O
force_vt	int
=	O
1	int
;	O
int	O
VBellWait	int
,	O
MsgWait	int
,	O
MsgMinWait	int
,	O
SilenceWait	int
;	O
extern	O
struct	O
acluser	struct
*	O
users	pointer
;	O
extern	O
struct	O
display	struct
*	O
displays	pointer
,	O
*	O
display	struct
;	O
extern	O
struct	O
LayFuncs	struct
MarkLf	struct
;	O
extern	O
int	O
visual_bell	int
;	O
extern	O
unsigned	O
char	O
mark_key_tab	array
[	O
]	O
;	O
extern	O
char	O
version	array
[	O
]	O
;	O
extern	O
char	O
DefaultShell	array
[	O
]	O
;	O
extern	O
char	O
*	O
zmodem_sendcmd	pointer
;	O
extern	O
char	O
*	O
zmodem_recvcmd	pointer
;	O
extern	O
struct	O
layout	struct
*	O
layout_last	pointer
;	O
char	O
*	O
ShellProg	pointer
;	O
char	O
*	O
ShellArgs	array
[	O
2	int
]	O
;	O
extern	O
struct	O
NewWindow	struct
nwin_undef	struct
,	O
nwin_default	struct
,	O
nwin_options	struct
;	O
struct	O
backtick	struct
;	O
static	O
struct	O
passwd	struct
*	O
getpwbyname	function
__P	O
(	O
(	O
char	O
*	O
,	O
struct	O
passwd	struct
*	O
)	O
)	O
;	O
static	O
void	O
SigChldHandler	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
sigret_t	void
SigChld	function
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
static	O
sigret_t	void
SigInt	function
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
static	O
sigret_t	void
CoreDump	function
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
static	O
sigret_t	void
FinitHandler	function
__P	O
(	O
SIGPROTOARG	O
)	O
;	O
static	O
void	O
DoWait	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
serv_read_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
serv_select_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
logflush_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
backtick_filter	function
__P	O
(	O
(	O
struct	O
backtick	struct
*	O
)	O
)	O
;	O
static	O
void	O
backtick_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
runbacktick	function
__P	O
(	O
(	O
struct	O
backtick	struct
*	O
,	O
int	O
*	O
,	O
time_t	long
)	O
)	O
;	O
static	O
int	O
IsSymbol	function
__P	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
ParseChar	function
__P	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
ParseEscape	function
__P	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
pad_expand	function
__P	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
SetTtyname	function
__P	O
(	O
(	O
bool	bool
,	O
struct	O
stat	struct
*	O
)	O
)	O
;	O
int	O
nversion	int
;	O
struct	O
passwd	struct
*	O
ppp	pointer
;	O
char	O
*	O
attach_tty	pointer
;	O
bool	bool
attach_tty_is_in_new_ns	bool
=	O
false	int
;	O
char	O
attach_tty_name_in_ns	array
[	O
MAXPATHLEN	O
]	O
;	O
int	O
attach_fd	int
=	O
-	O
1	int
;	O
char	O
*	O
attach_term	pointer
;	O
char	O
*	O
LoginName	pointer
;	O
struct	O
mode	struct
attach_Mode	struct
;	O
char	O
SockPath	array
[	O
MAXPATHLEN	O
+	O
2	int
*	O
MAXSTR	int
]	O
;	O
char	O
*	O
SockName	pointer
;	O
char	O
*	O
SockMatch	pointer
=	O
NULL	O
;	O
int	O
ServerSocket	int
=	O
-	O
1	int
;	O
struct	O
event	struct
serv_read	struct
;	O
struct	O
event	struct
serv_select	struct
;	O
struct	O
event	struct
logflushev	struct
;	O
char	O
*	O
*	O
NewEnv	pointer
=	O
NULL	O
;	O
char	O
*	O
RcFileName	pointer
=	O
NULL	O
;	O
char	O
*	O
home	pointer
;	O
char	O
*	O
screenlogfile	pointer
;	O
int	O
log_flush	int
=	O
10	int
;	O
int	O
logtstamp_on	int
=	O
0	int
;	O
char	O
*	O
logtstamp_string	pointer
;	O
int	O
logtstamp_after	int
=	O
120	int
;	O
char	O
*	O
hardcopydir	pointer
=	O
NULL	O
;	O
char	O
*	O
BellString	pointer
;	O
char	O
*	O
VisualBellString	pointer
;	O
char	O
*	O
ActivityString	pointer
;	O
char	O
*	O
BufferFile	pointer
;	O
char	O
*	O
PowDetachString	pointer
;	O
char	O
*	O
hstatusstring	pointer
;	O
char	O
*	O
captionstring	pointer
;	O
char	O
*	O
timestring	pointer
;	O
char	O
*	O
wliststr	pointer
;	O
char	O
*	O
wlisttit	pointer
;	O
int	O
auto_detach	int
=	O
1	int
;	O
int	O
iflag	int
,	O
rflag	int
,	O
dflag	int
,	O
lsflag	int
,	O
quietflag	int
,	O
wipeflag	int
,	O
xflag	int
;	O
int	O
cmdflag	int
;	O
int	O
queryflag	int
=	O
-	O
1	int
;	O
int	O
adaptflag	int
;	O
char	O
*	O
multi	pointer
;	O
char	O
*	O
multi_home	pointer
;	O
int	O
multi_uid	int
;	O
int	O
own_uid	int
;	O
int	O
multiattach	int
;	O
int	O
tty_mode	int
;	O
int	O
tty_oldmode	int
=	O
-	O
1	int
;	O
char	O
HostName	array
[	O
MAXSTR	int
]	O
;	O
int	O
MasterPid	int
,	O
PanicPid	int
;	O
int	O
real_uid	int
,	O
real_gid	int
,	O
eff_uid	int
,	O
eff_gid	int
;	O
int	O
default_startup	int
;	O
int	O
ZombieKey_destroy	int
,	O
ZombieKey_resurrect	int
,	O
ZombieKey_onerror	int
;	O
char	O
*	O
preselect	array
=	O
NULL	O
;	O
char	O
*	O
screenencodings	pointer
;	O
int	O
cjkwidth	int
;	O
int	O
nethackflag	int
=	O
0	int
;	O
int	O
maxwin	int
;	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
struct	O
win	struct
*	O
fore	pointer
;	O
struct	O
win	struct
*	O
windows	pointer
;	O
struct	O
win	struct
*	O
console_window	pointer
;	O
char	O
strnomem	array
[	O
]	O
=	O
"Out of memory."	pointer
;	O
static	O
int	O
InterruptPlease	int
;	O
static	O
int	O
GotSigChld	int
;	O
static	O
int	O
lf_secreopen	function
(	O
name	pointer
,	O
wantfd	int
,	O
l	pointer
)	O
char	O
*	O
name	pointer
;	O
int	O
wantfd	int
;	O
struct	O
logfile	struct
*	O
l	pointer
;	O
{	O
int	O
got_fd	int
;	O
close	function
(	O
wantfd	int
)	O
;	O
if	O
(	O
(	O
(	O
got_fd	int
=	O
secopen	function
(	O
name	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_APPEND	int
,	O
0666	int
)	O
)	O
<	O
0	int
)	O
||	O
lf_move_fd	function
(	O
got_fd	int
,	O
wantfd	int
)	O
<	O
0	int
)	O
{	O
logfclose	function
(	O
l	pointer
)	O
;	O
debug1	O
(	O
"lf_secreopen: failed for %s\n"	pointer
,	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
l	pointer
->	O
st	pointer
->	O
st_ino	long
=	O
l	pointer
->	O
st	pointer
->	O
st_dev	long
=	O
0	int
;	O
debug2	O
(	O
"lf_secreopen: %d = %s\n"	pointer
,	O
wantfd	int
,	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
passwd	struct
*	O
getpwbyname	function
(	O
name	pointer
,	O
ppp	pointer
)	O
char	O
*	O
name	pointer
;	O
struct	O
passwd	struct
*	O
ppp	pointer
;	O
{	O
int	O
n	int
;	O
struct	O
spwd	struct
*	O
sss	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
spw	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
ppp	pointer
&&	O
!	O
(	O
ppp	pointer
=	O
getpwnam	function
(	O
name	pointer
)	O
)	O
)	O
return	O
NULL	O
;	O
pw_try_again	O
:	O
n	int
=	O
0	int
;	O
if	O
(	O
ppp	pointer
->	O
pw_passwd	pointer
[	O
0	int
]	O
==	O
'#'	O
&&	O
ppp	pointer
->	O
pw_passwd	pointer
[	O
1	int
]	O
==	O
'#'	O
&&	O
strcmp	function
(	O
ppp	pointer
->	O
pw_passwd	pointer
+	O
2	int
,	O
ppp	pointer
->	O
pw_name	pointer
)	O
==	O
0	int
)	O
n	int
=	O
13	int
;	O
for	O
(	O
;	O
n	int
<	O
13	int
;	O
n	int
++	O
)	O
{	O
char	O
c	char
=	O
ppp	pointer
->	O
pw_passwd	pointer
[	O
n	int
]	O
;	O
if	O
(	O
!	O
(	O
c	char
==	O
'.'	O
||	O
c	char
==	O
'/'	O
||	O
c	char
==	O
'$'	O
||	O
(	O
c	char
>=	O
'0'	O
&&	O
c	char
<=	O
'9'	O
)	O
||	O
(	O
c	char
>=	O
'a'	O
&&	O
c	char
<=	O
'z'	O
)	O
||	O
(	O
c	char
>=	O
'A'	O
&&	O
c	char
<=	O
'Z'	O
)	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
n	int
<	O
13	int
&&	O
sss	pointer
==	O
0	int
)	O
{	O
sss	pointer
=	O
getspnam	function
(	O
ppp	pointer
->	O
pw_name	pointer
)	O
;	O
if	O
(	O
sss	pointer
)	O
{	O
if	O
(	O
spw	pointer
)	O
free	function
(	O
spw	pointer
)	O
;	O
ppp	pointer
->	O
pw_passwd	pointer
=	O
spw	pointer
=	O
SaveStr	function
(	O
sss	pointer
->	O
sp_pwdp	pointer
)	O
;	O
endspent	function
(	O
)	O
;	O
goto	O
pw_try_again	O
;	O
}	O
endspent	function
(	O
)	O
;	O
}	O
if	O
(	O
n	int
<	O
13	int
)	O
ppp	pointer
->	O
pw_passwd	pointer
=	O
0	int
;	O
if	O
(	O
ppp	pointer
->	O
pw_passwd	pointer
&&	O
strlen	function
(	O
ppp	pointer
->	O
pw_passwd	pointer
)	O
==	O
13	int
+	O
11	int
)	O
ppp	pointer
->	O
pw_passwd	pointer
[	O
13	int
]	O
=	O
0	int
;	O
return	O
ppp	pointer
;	O
}	O
static	O
char	O
*	O
locale_name	function
(	O
void	O
)	O
{	O
static	O
char	O
*	O
s	pointer
;	O
if	O
(	O
!	O
s	pointer
)	O
{	O
s	pointer
=	O
getenv	function
(	O
"LC_ALL"	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
s	pointer
=	O
getenv	function
(	O
"LC_CTYPE"	pointer
)	O
;	O
if	O
(	O
s	pointer
==	O
NULL	O
)	O
s	pointer
=	O
getenv	function
(	O
"LANG"	pointer
)	O
;	O
}	O
return	O
s	pointer
;	O
}	O
int	O
main	function
(	O
int	O
ac	int
,	O
char	O
*	O
*	O
av	pointer
)	O
{	O
register	O
int	O
n	int
;	O
char	O
*	O
ap	pointer
;	O
char	O
*	O
av0	pointer
;	O
char	O
socknamebuf	array
[	O
2	int
*	O
MAXSTR	int
]	O
;	O
int	O
mflag	int
=	O
0	int
;	O
char	O
*	O
myname	pointer
=	O
(	O
ac	int
==	O
0	int
)	O
?	O
"screen"	pointer
:	O
av	pointer
[	O
0	int
]	O
;	O
char	O
*	O
SockDir	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
oumask	int
;	O
struct	O
NewWindow	struct
nwin	struct
;	O
int	O
detached	int
=	O
0	int
;	O
char	O
*	O
sockp	pointer
;	O
char	O
*	O
sty	pointer
=	O
0	int
;	O
closeallfiles	function
(	O
0	int
)	O
;	O
snprintf	function
(	O
version	array
,	O
59	int
,	O
"%d.%.2d.%.2d%s (%s%s) %s"	pointer
,	O
REV	int
,	O
VERS	int
,	O
PATCHLEVEL	int
,	O
STATE	pointer
,	O
ORIGIN	pointer
,	O
GIT_REV	O
,	O
DATE	pointer
)	O
;	O
nversion	int
=	O
REV	int
*	O
10000	int
+	O
VERS	int
*	O
100	int
+	O
PATCHLEVEL	int
;	O
debug2	O
(	O
"-- screen debug started %s (%s)\n"	pointer
,	O
*	O
av	pointer
,	O
version	array
)	O
;	O
debug	O
(	O
"POSIX\n"	pointer
)	O
;	O
debug	O
(	O
"TERMIO\n"	pointer
)	O
;	O
debug	O
(	O
"Window size changing enabled\n"	pointer
)	O
;	O
debug	O
(	O
"SETREUID\n"	pointer
)	O
;	O
debug	O
(	O
"USEBCOPY\n"	pointer
)	O
;	O
debug	O
(	O
"UTMPOK\n"	pointer
)	O
;	O
debug	O
(	O
"LOADAV\n"	pointer
)	O
;	O
debug	O
(	O
"NETHACK\n"	pointer
)	O
;	O
debug	O
(	O
"TERMINFO\n"	pointer
)	O
;	O
debug	O
(	O
"SHADOWPW\n"	pointer
)	O
;	O
debug1	O
(	O
"NAME_MAX = %d\n"	pointer
,	O
NAME_MAX	int
)	O
;	O
BellString	pointer
=	O
SaveStr	function
(	O
"Bell in window %n"	pointer
)	O
;	O
VisualBellString	pointer
=	O
SaveStr	function
(	O
"   Wuff,  Wuff!!  "	pointer
)	O
;	O
ActivityString	pointer
=	O
SaveStr	function
(	O
"Activity in window %n"	pointer
)	O
;	O
screenlogfile	pointer
=	O
SaveStr	function
(	O
"screenlog.%n"	pointer
)	O
;	O
logtstamp_string	pointer
=	O
SaveStr	function
(	O
"-- %n:%t -- time-stamp -- %M/%d/%y %c:%s --\n"	pointer
)	O
;	O
hstatusstring	pointer
=	O
SaveStr	function
(	O
"%h"	pointer
)	O
;	O
captionstring	pointer
=	O
SaveStr	function
(	O
"%4n %t"	pointer
)	O
;	O
timestring	pointer
=	O
SaveStr	function
(	O
"%c:%s %M %d %H%? %l%?"	pointer
)	O
;	O
wlisttit	pointer
=	O
SaveStr	function
(	O
" Num Name%=Flags"	pointer
)	O
;	O
wliststr	pointer
=	O
SaveStr	function
(	O
"%4n %t%=%f"	pointer
)	O
;	O
BufferFile	pointer
=	O
SaveStr	function
(	O
DEFAULT_BUFFERFILE	pointer
)	O
;	O
ShellProg	pointer
=	O
NULL	O
;	O
PowDetachString	pointer
=	O
0	int
;	O
default_startup	int
=	O
(	O
ac	int
>	O
1	int
)	O
?	O
0	int
:	O
1	int
;	O
adaptflag	int
=	O
0	int
;	O
VBellWait	int
=	O
VBELLWAIT	int
*	O
1000	int
;	O
MsgWait	int
=	O
MSGWAIT	int
*	O
1000	int
;	O
MsgMinWait	int
=	O
MSGMINWAIT	int
*	O
1000	int
;	O
SilenceWait	int
=	O
SILENCEWAIT	int
;	O
zmodem_sendcmd	pointer
=	O
SaveStr	function
(	O
"!!! sz -vv -b "	pointer
)	O
;	O
zmodem_recvcmd	pointer
=	O
SaveStr	function
(	O
"!!! rz -vv -b -E"	pointer
)	O
;	O
CompileKeys	function
(	O
(	O
char	O
*	O
)	O
0	int
,	O
0	int
,	O
mark_key_tab	array
)	O
;	O
InitBuiltinTabs	function
(	O
)	O
;	O
screenencodings	pointer
=	O
SaveStr	function
(	O
SCREENENCODINGS	O
)	O
;	O
cjkwidth	int
=	O
0	int
;	O
nwin	struct
=	O
nwin_undef	struct
;	O
nwin_options	struct
=	O
nwin_undef	struct
;	O
strncpy	function
(	O
screenterm	array
,	O
"screen"	pointer
,	O
MAXTERMLEN	int
)	O
;	O
screenterm	array
[	O
MAXTERMLEN	int
]	O
=	O
'\0'	O
;	O
real_uid	int
=	O
getuid	function
(	O
)	O
;	O
real_gid	int
=	O
getgid	function
(	O
)	O
;	O
eff_uid	int
=	O
geteuid	function
(	O
)	O
;	O
eff_gid	int
=	O
getegid	function
(	O
)	O
;	O
logreopen_register	function
(	O
lf_secreopen	function
)	O
;	O
av0	pointer
=	O
*	O
av	pointer
;	O
if	O
(	O
*	O
av0	pointer
==	O
'-'	O
)	O
{	O
rflag	int
=	O
4	int
;	O
xflag	int
=	O
1	int
;	O
ShellProg	pointer
=	O
SaveStr	function
(	O
DefaultShell	array
)	O
;	O
}	O
while	O
(	O
ac	int
>	O
0	int
)	O
{	O
ap	pointer
=	O
*	O
++	O
av	pointer
;	O
if	O
(	O
--	O
ac	int
>	O
0	int
&&	O
*	O
ap	pointer
==	O
'-'	O
)	O
{	O
if	O
(	O
ap	pointer
[	O
1	int
]	O
==	O
'-'	O
&&	O
ap	pointer
[	O
2	int
]	O
==	O
0	int
)	O
{	O
av	pointer
++	O
;	O
ac	int
--	O
;	O
break	O
;	O
}	O
if	O
(	O
ap	pointer
[	O
1	int
]	O
==	O
'-'	O
&&	O
!	O
strcmp	function
(	O
ap	pointer
,	O
"--version"	pointer
)	O
)	O
{	O
printf	function
(	O
"Screen version %s\n"	pointer
,	O
version	array
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
ap	pointer
[	O
1	int
]	O
==	O
'-'	O
&&	O
!	O
strcmp	function
(	O
ap	pointer
,	O
"--help"	pointer
)	O
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
while	O
(	O
ap	pointer
&&	O
*	O
ap	pointer
&&	O
*	O
++	O
ap	pointer
)	O
{	O
switch	O
(	O
*	O
ap	pointer
)	O
{	O
case	O
'a'	O
:	O
nwin_options	struct
.	O
aflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'A'	O
:	O
adaptflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
*	O
++	O
ap	pointer
)	O
preselect	array
=	O
ap	pointer
;	O
else	O
{	O
if	O
(	O
!	O
--	O
ac	int
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Specify a window to preselect with -p"	pointer
,	O
NULL	O
)	O
;	O
preselect	array
=	O
*	O
++	O
av	pointer
;	O
}	O
ap	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
'c'	O
:	O
if	O
(	O
*	O
++	O
ap	pointer
)	O
RcFileName	pointer
=	O
ap	pointer
;	O
else	O
{	O
if	O
(	O
--	O
ac	int
==	O
0	int
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Specify an alternate rc-filename with -c"	pointer
,	O
NULL	O
)	O
;	O
RcFileName	pointer
=	O
*	O
++	O
av	pointer
;	O
}	O
ap	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
'e'	O
:	O
if	O
(	O
!	O
*	O
++	O
ap	pointer
)	O
{	O
if	O
(	O
--	O
ac	int
==	O
0	int
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Specify command characters with -e"	pointer
,	O
NULL	O
)	O
;	O
ap	pointer
=	O
*	O
++	O
av	pointer
;	O
}	O
if	O
(	O
ParseEscape	function
(	O
ap	pointer
)	O
)	O
Panic	function
(	O
0	int
,	O
"Two characters are required with -e option, not '%s'."	pointer
,	O
ap	pointer
)	O
;	O
ap	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
'f'	O
:	O
ap	pointer
++	O
;	O
switch	O
(	O
*	O
ap	pointer
++	O
)	O
{	O
case	O
'n'	O
:	O
case	O
'0'	O
:	O
nwin_options	struct
.	O
flowflag	int
=	O
FLOW_NOW	O
*	O
0	int
;	O
break	O
;	O
case	O
'\0'	O
:	O
ap	pointer
--	O
;	O
case	O
'y'	O
:	O
case	O
'1'	O
:	O
nwin_options	struct
.	O
flowflag	int
=	O
FLOW_NOW	O
*	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
nwin_options	struct
.	O
flowflag	int
=	O
FLOW_AUTOFLAG	O
;	O
break	O
;	O
default	O
:	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Unknown flow option -%s"	pointer
,	O
--	O
ap	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'h'	O
:	O
if	O
(	O
--	O
ac	int
==	O
0	int
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
nwin_options	struct
.	O
histheight	int
=	O
atoi	function
(	O
*	O
++	O
av	pointer
)	O
;	O
if	O
(	O
nwin_options	struct
.	O
histheight	int
<	O
0	int
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
"-h: %s: negative scrollback size?"	pointer
,	O
*	O
av	pointer
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
iflag	int
=	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
if	O
(	O
--	O
ac	int
==	O
0	int
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Specify a new window-name with -t"	pointer
,	O
NULL	O
)	O
;	O
nwin_options	struct
.	O
aka	pointer
=	O
*	O
++	O
av	pointer
;	O
break	O
;	O
case	O
'l'	O
:	O
ap	pointer
++	O
;	O
switch	O
(	O
*	O
ap	pointer
++	O
)	O
{	O
case	O
'n'	O
:	O
case	O
'0'	O
:	O
nwin_options	struct
.	O
lflag	int
=	O
0	int
;	O
break	O
;	O
case	O
'\0'	O
:	O
ap	pointer
--	O
;	O
case	O
'y'	O
:	O
case	O
'1'	O
:	O
nwin_options	struct
.	O
lflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
nwin_options	struct
.	O
lflag	int
=	O
3	int
;	O
break	O
;	O
case	O
's'	O
:	O
case	O
'i'	O
:	O
lsflag	int
=	O
1	int
;	O
if	O
(	O
ac	int
>	O
1	int
&&	O
!	O
SockMatch	pointer
)	O
{	O
SockMatch	pointer
=	O
*	O
++	O
av	pointer
;	O
ac	int
--	O
;	O
}	O
ap	pointer
=	O
NULL	O
;	O
break	O
;	O
default	O
:	O
exit_with_usage	function
(	O
myname	pointer
,	O
"%s: Unknown suboption to -l"	pointer
,	O
--	O
ap	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'w'	O
:	O
if	O
(	O
strcmp	function
(	O
ap	pointer
+	O
1	int
,	O
"ipe"	pointer
)	O
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Unknown option %s"	pointer
,	O
--	O
ap	pointer
)	O
;	O
lsflag	int
=	O
1	int
;	O
wipeflag	int
=	O
1	int
;	O
if	O
(	O
ac	int
>	O
1	int
&&	O
!	O
SockMatch	pointer
)	O
{	O
SockMatch	pointer
=	O
*	O
++	O
av	pointer
;	O
ac	int
--	O
;	O
}	O
break	O
;	O
case	O
'L'	O
:	O
if	O
(	O
!	O
strcmp	function
(	O
ap	pointer
+	O
1	int
,	O
"ogfile"	pointer
)	O
)	O
{	O
if	O
(	O
--	O
ac	int
==	O
0	int
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Specify logfile path with -Logfile"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
strlen	function
(	O
*	O
++	O
av	pointer
)	O
>	O
PATH_MAX	int
)	O
Panic	function
(	O
1	int
,	O
"-Logfile name too long. (max. %d char)"	pointer
,	O
PATH_MAX	int
)	O
;	O
free	function
(	O
screenlogfile	pointer
)	O
;	O
screenlogfile	pointer
=	O
SaveStr	function
(	O
*	O
av	pointer
)	O
;	O
ap	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
ap	pointer
,	O
"L"	pointer
)	O
)	O
nwin_options	struct
.	O
Lflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'm'	O
:	O
mflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'O'	O
:	O
force_vt	int
=	O
0	int
;	O
break	O
;	O
case	O
'T'	O
:	O
if	O
(	O
--	O
ac	int
==	O
0	int
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Specify terminal-type with -T"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
strlen	function
(	O
*	O
++	O
av	pointer
)	O
<	O
MAXTERMLEN	int
)	O
{	O
strncpy	function
(	O
screenterm	array
,	O
*	O
av	pointer
,	O
MAXTERMLEN	int
)	O
;	O
screenterm	array
[	O
MAXTERMLEN	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
Panic	function
(	O
0	int
,	O
"-T: terminal name too long. (max. %d char)"	pointer
,	O
MAXTERMLEN	int
)	O
;	O
nwin_options	struct
.	O
term	struct
=	O
screenterm	array
;	O
break	O
;	O
case	O
'q'	O
:	O
quietflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'Q'	O
:	O
queryflag	int
=	O
1	int
;	O
cmdflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'r'	O
:	O
case	O
'R'	O
:	O
case	O
'x'	O
:	O
if	O
(	O
ac	int
>	O
1	int
&&	O
*	O
av	pointer
[	O
1	int
]	O
!=	O
'-'	O
&&	O
!	O
SockMatch	pointer
)	O
{	O
SockMatch	pointer
=	O
*	O
++	O
av	pointer
;	O
ac	int
--	O
;	O
debug2	O
(	O
"rflag=%d, SockMatch=%s\n"	pointer
,	O
dflag	int
,	O
SockMatch	pointer
)	O
;	O
}	O
if	O
(	O
*	O
ap	pointer
==	O
'x'	O
)	O
xflag	int
=	O
1	int
;	O
if	O
(	O
rflag	int
)	O
rflag	int
=	O
2	int
;	O
rflag	int
+=	O
(	O
*	O
ap	pointer
==	O
'R'	O
)	O
?	O
2	int
:	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
dflag	int
=	O
1	int
;	O
case	O
'D'	O
:	O
if	O
(	O
!	O
dflag	int
)	O
dflag	int
=	O
2	int
;	O
if	O
(	O
ac	int
==	O
2	int
)	O
{	O
if	O
(	O
*	O
av	pointer
[	O
1	int
]	O
!=	O
'-'	O
&&	O
!	O
SockMatch	pointer
)	O
{	O
SockMatch	pointer
=	O
*	O
++	O
av	pointer
;	O
ac	int
--	O
;	O
debug2	O
(	O
"dflag=%d, SockMatch=%s\n"	pointer
,	O
dflag	int
,	O
SockMatch	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
--	O
ac	int
==	O
0	int
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Specify shell with -s"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
ShellProg	pointer
)	O
free	function
(	O
ShellProg	pointer
)	O
;	O
ShellProg	pointer
=	O
SaveStr	function
(	O
*	O
++	O
av	pointer
)	O
;	O
debug1	O
(	O
"ShellProg: '%s'\n"	pointer
,	O
ShellProg	pointer
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
if	O
(	O
!	O
SockMatch	pointer
)	O
{	O
if	O
(	O
--	O
ac	int
==	O
0	int
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Specify session-name with -S"	pointer
,	O
NULL	O
)	O
;	O
SockMatch	pointer
=	O
*	O
++	O
av	pointer
;	O
}	O
if	O
(	O
!	O
*	O
SockMatch	pointer
)	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Empty session-name?"	pointer
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'X'	O
:	O
cmdflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
printf	function
(	O
"Screen version %s\n"	pointer
,	O
version	array
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
case	O
'U'	O
:	O
nwin_options	struct
.	O
encoding	int
=	O
nwin_options	struct
.	O
encoding	int
==	O
-	O
1	int
?	O
UTF8	int
:	O
0	int
;	O
break	O
;	O
default	O
:	O
exit_with_usage	function
(	O
myname	pointer
,	O
"Unknown option %s"	pointer
,	O
--	O
ap	pointer
)	O
;	O
}	O
}	O
}	O
else	O
break	O
;	O
}	O
signal	function
(	O
SIGBUS	int
,	O
CoreDump	function
)	O
;	O
signal	function
(	O
SIGSEGV	int
,	O
CoreDump	function
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
if	O
(	O
nwin_options	struct
.	O
encoding	int
==	O
-	O
1	int
)	O
{	O
nwin_options	struct
.	O
encoding	int
=	O
FindEncoding	function
(	O
nl_langinfo	function
(	O
CODESET	int
)	O
)	O
;	O
debug1	O
(	O
"locale says encoding = %d\n"	pointer
,	O
nwin_options	struct
.	O
encoding	int
)	O
;	O
}	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
(	O
s	pointer
=	O
locale_name	function
(	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
"zh_"	pointer
,	O
3	int
)	O
||	O
!	O
strncmp	function
(	O
s	pointer
,	O
"ja_"	pointer
,	O
3	int
)	O
||	O
!	O
strncmp	function
(	O
s	pointer
,	O
"ko_"	pointer
,	O
3	int
)	O
)	O
{	O
cjkwidth	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
nwin_options	struct
.	O
aka	pointer
)	O
{	O
if	O
(	O
nwin_options	struct
.	O
encoding	int
>	O
0	int
)	O
{	O
size_t	long
len	int
=	O
strlen	function
(	O
nwin_options	struct
.	O
aka	pointer
)	O
;	O
size_t	long
newsz	long
;	O
char	O
*	O
newbuf	pointer
=	O
malloc	function
(	O
3	int
*	O
len	int
)	O
;	O
if	O
(	O
!	O
newbuf	pointer
)	O
Panic	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
newsz	long
=	O
RecodeBuf	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
nwin_options	struct
.	O
aka	pointer
,	O
len	int
,	O
nwin_options	struct
.	O
encoding	int
,	O
0	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
newbuf	pointer
)	O
;	O
newbuf	pointer
[	O
newsz	long
]	O
=	O
'\0'	O
;	O
nwin_options	struct
.	O
aka	pointer
=	O
newbuf	pointer
;	O
}	O
else	O
{	O
nwin_options	struct
.	O
aka	pointer
=	O
SaveStr	function
(	O
nwin_options	struct
.	O
aka	pointer
)	O
;	O
}	O
}	O
if	O
(	O
SockMatch	pointer
&&	O
strlen	function
(	O
SockMatch	pointer
)	O
>=	O
MAXSTR	int
)	O
Panic	function
(	O
0	int
,	O
"Ridiculously long socketname - try again."	pointer
)	O
;	O
if	O
(	O
cmdflag	int
&&	O
!	O
rflag	int
&&	O
!	O
dflag	int
&&	O
!	O
xflag	int
)	O
xflag	int
=	O
1	int
;	O
if	O
(	O
!	O
cmdflag	int
&&	O
dflag	int
&&	O
mflag	int
&&	O
!	O
(	O
rflag	int
||	O
xflag	int
)	O
)	O
detached	int
=	O
1	int
;	O
nwin	struct
=	O
nwin_options	struct
;	O
nwin	struct
.	O
encoding	int
=	O
nwin_undef	struct
.	O
encoding	int
;	O
if	O
(	O
ac	int
)	O
nwin	struct
.	O
args	pointer
=	O
av	pointer
;	O
signal	function
(	O
SIGXFSZ	int
,	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
if	O
(	O
!	O
ShellProg	pointer
)	O
{	O
register	O
char	O
*	O
sh	pointer
;	O
sh	pointer
=	O
getenv	function
(	O
"SHELL"	pointer
)	O
;	O
ShellProg	pointer
=	O
SaveStr	function
(	O
sh	pointer
?	O
sh	pointer
:	O
DefaultShell	array
)	O
;	O
}	O
ShellArgs	array
[	O
0	int
]	O
=	O
ShellProg	pointer
;	O
home	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
!	O
mflag	int
&&	O
!	O
SockMatch	pointer
)	O
{	O
sty	pointer
=	O
getenv	function
(	O
"STY"	pointer
)	O
;	O
if	O
(	O
sty	pointer
&&	O
*	O
sty	pointer
==	O
0	int
)	O
sty	pointer
=	O
0	int
;	O
}	O
if	O
(	O
!	O
(	O
nethackflag	int
=	O
(	O
getenv	function
(	O
"NETHACKOPTIONS"	pointer
)	O
!=	O
NULL	O
)	O
)	O
)	O
{	O
char	O
nethackrc	array
[	O
MAXPATHLEN	O
]	O
;	O
if	O
(	O
home	pointer
&&	O
(	O
strlen	function
(	O
home	pointer
)	O
<	O
(	O
MAXPATHLEN	O
-	O
20	int
)	O
)	O
)	O
{	O
sprintf	function
(	O
nethackrc	array
,	O
"%s/.nethackrc"	pointer
,	O
home	pointer
)	O
;	O
nethackflag	int
=	O
!	O
access	function
(	O
nethackrc	array
,	O
F_OK	int
)	O
;	O
}	O
}	O
own_uid	int
=	O
multi_uid	int
=	O
real_uid	int
;	O
if	O
(	O
SockMatch	pointer
&&	O
(	O
sockp	pointer
=	O
index	function
(	O
SockMatch	pointer
,	O
'/'	O
)	O
)	O
)	O
{	O
*	O
sockp	pointer
=	O
0	int
;	O
multi	pointer
=	O
SockMatch	pointer
;	O
SockMatch	pointer
=	O
sockp	pointer
+	O
1	int
;	O
if	O
(	O
*	O
multi	pointer
)	O
{	O
struct	O
passwd	struct
*	O
mppp	pointer
;	O
if	O
(	O
(	O
mppp	pointer
=	O
getpwnam	function
(	O
multi	pointer
)	O
)	O
==	O
(	O
struct	O
passwd	struct
*	O
)	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"Cannot identify account '%s'."	pointer
,	O
multi	pointer
)	O
;	O
multi_uid	int
=	O
mppp	pointer
->	O
pw_uid	int
;	O
multi_home	pointer
=	O
SaveStr	function
(	O
mppp	pointer
->	O
pw_dir	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
multi_home	pointer
)	O
>	O
MAXPATHLEN	O
-	O
10	int
)	O
Panic	function
(	O
0	int
,	O
"home directory path too long"	pointer
)	O
;	O
if	O
(	O
rflag	int
||	O
lsflag	int
)	O
xflag	int
=	O
1	int
;	O
detached	int
=	O
0	int
;	O
multiattach	int
=	O
1	int
;	O
}	O
if	O
(	O
eff_uid	int
&&	O
(	O
multi_uid	int
!=	O
eff_uid	int
)	O
)	O
Panic	function
(	O
0	int
,	O
"Must run suid root for multiuser support."	pointer
)	O
;	O
}	O
if	O
(	O
SockMatch	pointer
&&	O
*	O
SockMatch	pointer
==	O
0	int
)	O
SockMatch	pointer
=	O
0	int
;	O
if	O
(	O
(	O
LoginName	pointer
=	O
getlogin	function
(	O
)	O
)	O
&&	O
LoginName	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
(	O
ppp	pointer
=	O
getpwnam	function
(	O
LoginName	pointer
)	O
)	O
!=	O
(	O
struct	O
passwd	struct
*	O
)	O
0	int
)	O
if	O
(	O
(	O
int	O
)	O
ppp	pointer
->	O
pw_uid	int
!=	O
real_uid	int
)	O
ppp	pointer
=	O
(	O
struct	O
passwd	struct
*	O
)	O
0	int
;	O
}	O
if	O
(	O
ppp	pointer
==	O
0	int
)	O
{	O
if	O
(	O
(	O
ppp	pointer
=	O
getpwuid	function
(	O
real_uid	int
)	O
)	O
==	O
0	int
)	O
{	O
Panic	function
(	O
0	int
,	O
"getpwuid() can't identify your account!"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
LoginName	pointer
=	O
ppp	pointer
->	O
pw_name	pointer
;	O
}	O
LoginName	pointer
=	O
SaveStr	function
(	O
LoginName	pointer
)	O
;	O
ppp	pointer
=	O
getpwbyname	function
(	O
LoginName	pointer
,	O
ppp	pointer
)	O
;	O
if	O
(	O
home	pointer
==	O
0	int
||	O
*	O
home	pointer
==	O
'\0'	O
)	O
home	pointer
=	O
ppp	pointer
->	O
pw_dir	pointer
;	O
if	O
(	O
strlen	function
(	O
LoginName	pointer
)	O
>	O
MAXLOGINLEN	int
)	O
Panic	function
(	O
0	int
,	O
"LoginName too long - sorry."	pointer
)	O
;	O
if	O
(	O
multi	pointer
&&	O
strlen	function
(	O
multi	pointer
)	O
>	O
MAXLOGINLEN	int
)	O
Panic	function
(	O
0	int
,	O
"Screen owner name too long - sorry."	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
home	pointer
)	O
>	O
MAXPATHLEN	O
-	O
25	int
)	O
Panic	function
(	O
0	int
,	O
"$HOME too long - sorry."	pointer
)	O
;	O
attach_tty	pointer
=	O
""	pointer
;	O
if	O
(	O
!	O
detached	int
&&	O
!	O
lsflag	int
&&	O
!	O
cmdflag	int
&&	O
!	O
(	O
dflag	int
&&	O
!	O
mflag	int
&&	O
!	O
rflag	int
&&	O
!	O
xflag	int
)	O
&&	O
!	O
(	O
sty	pointer
&&	O
!	O
SockMatch	pointer
&&	O
!	O
mflag	int
&&	O
!	O
rflag	int
&&	O
!	O
xflag	int
)	O
)	O
{	O
int	O
fl	int
;	O
SetTtyname	function
(	O
true	int
,	O
&	O
st	pointer
)	O
;	O
tty_mode	int
=	O
(	O
int	O
)	O
st	pointer
.	O
st_mode	int
&	O
0777	int
;	O
fl	int
=	O
fcntl	function
(	O
0	int
,	O
F_GETFL	int
,	O
0	int
)	O
;	O
if	O
(	O
fl	int
!=	O
-	O
1	int
&&	O
(	O
fl	int
&	O
(	O
O_RDWR	int
|	O
O_RDONLY	int
|	O
O_WRONLY	int
)	O
)	O
==	O
O_RDWR	int
)	O
attach_fd	int
=	O
0	int
;	O
if	O
(	O
attach_fd	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
n	int
=	O
secopen	function
(	O
attach_tty	pointer
,	O
O_RDWR	int
|	O
O_NONBLOCK	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"Cannot open your terminal '%s' - please check."	pointer
,	O
attach_tty	pointer
)	O
;	O
attach_fd	int
=	O
n	int
;	O
}	O
debug2	O
(	O
"attach_tty is %s, attach_fd is %d\n"	pointer
,	O
attach_tty	pointer
,	O
attach_fd	int
)	O
;	O
if	O
(	O
(	O
attach_term	pointer
=	O
getenv	function
(	O
"TERM"	pointer
)	O
)	O
==	O
0	int
||	O
*	O
attach_term	pointer
==	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"Please set a terminal type."	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
attach_term	pointer
)	O
>	O
MAXTERMLEN	int
)	O
Panic	function
(	O
0	int
,	O
"$TERM too long - sorry."	pointer
)	O
;	O
GetTTY	function
(	O
0	int
,	O
&	O
attach_Mode	struct
)	O
;	O
}	O
if	O
(	O
(	O
oumask	int
=	O
(	O
int	O
)	O
umask	function
(	O
0	int
)	O
)	O
==	O
-	O
1	int
)	O
Panic	function
(	O
errno	O
,	O
"Cannot change umask to zero"	pointer
)	O
;	O
SockDir	pointer
=	O
getenv	function
(	O
"SCREENDIR"	pointer
)	O
;	O
if	O
(	O
SockDir	pointer
)	O
{	O
if	O
(	O
strlen	function
(	O
SockDir	pointer
)	O
>=	O
MAXPATHLEN	O
-	O
1	int
)	O
Panic	function
(	O
0	int
,	O
"Ridiculously long $SCREENDIR - try again."	pointer
)	O
;	O
if	O
(	O
multi	pointer
)	O
Panic	function
(	O
0	int
,	O
"No $SCREENDIR with multi screens, please."	pointer
)	O
;	O
}	O
if	O
(	O
multiattach	int
)	O
{	O
SockDir	pointer
=	O
SOCKDIR	O
;	O
sprintf	function
(	O
SockPath	array
,	O
"%s/S-%s"	pointer
,	O
SockDir	pointer
,	O
multi	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
SockDir	pointer
)	O
{	O
if	O
(	O
access	function
(	O
SockDir	pointer
,	O
F_OK	int
)	O
)	O
{	O
debug1	O
(	O
"SockDir '%s' missing ...\n"	pointer
,	O
SockDir	pointer
)	O
;	O
if	O
(	O
UserContext	function
(	O
)	O
>	O
0	int
)	O
{	O
if	O
(	O
mkdir	function
(	O
SockDir	pointer
,	O
0700	int
)	O
)	O
UserReturn	function
(	O
0	int
)	O
;	O
UserReturn	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
UserStatus	function
(	O
)	O
<=	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"Cannot make directory '%s'."	pointer
,	O
SockDir	pointer
)	O
;	O
}	O
if	O
(	O
SockDir	pointer
!=	O
SockPath	array
)	O
strcpy	function
(	O
SockPath	array
,	O
SockDir	pointer
)	O
;	O
}	O
else	O
{	O
SockDir	pointer
=	O
SOCKDIR	O
;	O
if	O
(	O
stat	struct
(	O
SockDir	pointer
,	O
&	O
st	pointer
)	O
)	O
{	O
n	int
=	O
(	O
eff_uid	int
==	O
0	int
&&	O
(	O
real_uid	int
||	O
eff_gid	int
==	O
real_gid	int
)	O
)	O
?	O
0755	int
:	O
(	O
eff_gid	int
!=	O
real_gid	int
)	O
?	O
0775	int
:	O
0777	int
|	O
S_ISVTX	O
;	O
if	O
(	O
mkdir	function
(	O
SockDir	pointer
,	O
n	int
)	O
==	O
-	O
1	int
)	O
Panic	function
(	O
errno	O
,	O
"Cannot make directory '%s'"	pointer
,	O
SockDir	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
S_ISDIR	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
Panic	function
(	O
0	int
,	O
"'%s' must be a directory."	pointer
,	O
SockDir	pointer
)	O
;	O
if	O
(	O
eff_uid	int
==	O
0	int
&&	O
real_uid	int
&&	O
(	O
int	O
)	O
st	pointer
.	O
st_uid	int
!=	O
eff_uid	int
)	O
Panic	function
(	O
0	int
,	O
"Directory '%s' must be owned by root."	pointer
,	O
SockDir	pointer
)	O
;	O
n	int
=	O
(	O
eff_uid	int
==	O
0	int
&&	O
(	O
real_uid	int
||	O
(	O
st	pointer
.	O
st_mode	int
&	O
0775	int
)	O
!=	O
0775	int
)	O
)	O
?	O
0755	int
:	O
(	O
eff_gid	int
==	O
(	O
int	O
)	O
st	pointer
.	O
st_gid	int
&&	O
eff_gid	int
!=	O
real_gid	int
)	O
?	O
0775	int
:	O
0777	int
;	O
if	O
(	O
(	O
(	O
int	O
)	O
st	pointer
.	O
st_mode	int
&	O
0777	int
)	O
!=	O
n	int
)	O
Panic	function
(	O
0	int
,	O
"Directory '%s' must have mode %03o."	pointer
,	O
SockDir	pointer
,	O
n	int
)	O
;	O
}	O
sprintf	function
(	O
SockPath	array
,	O
"%s/S-%s"	pointer
,	O
SockDir	pointer
,	O
LoginName	pointer
)	O
;	O
if	O
(	O
access	function
(	O
SockPath	array
,	O
F_OK	int
)	O
)	O
{	O
if	O
(	O
mkdir	function
(	O
SockPath	array
,	O
0700	int
)	O
==	O
-	O
1	int
&&	O
errno	O
!=	O
EEXIST	int
)	O
Panic	function
(	O
errno	O
,	O
"Cannot make directory '%s'"	pointer
,	O
SockPath	array
)	O
;	O
(	O
void	O
)	O
chown	function
(	O
SockPath	array
,	O
real_uid	int
,	O
real_gid	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
stat	struct
(	O
SockPath	array
,	O
&	O
st	pointer
)	O
==	O
-	O
1	int
)	O
Panic	function
(	O
errno	O
,	O
"Cannot access %s"	pointer
,	O
SockPath	array
)	O
;	O
else	O
if	O
(	O
!	O
S_ISDIR	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
Panic	function
(	O
0	int
,	O
"%s is not a directory."	pointer
,	O
SockPath	array
)	O
;	O
if	O
(	O
multi	pointer
)	O
{	O
if	O
(	O
(	O
int	O
)	O
st	pointer
.	O
st_uid	int
!=	O
multi_uid	int
)	O
Panic	function
(	O
0	int
,	O
"%s is not the owner of %s."	pointer
,	O
multi	pointer
,	O
SockPath	array
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
int	O
)	O
st	pointer
.	O
st_uid	int
!=	O
real_uid	int
)	O
Panic	function
(	O
0	int
,	O
"You are not the owner of %s."	pointer
,	O
SockPath	array
)	O
;	O
}	O
if	O
(	O
(	O
st	pointer
.	O
st_mode	int
&	O
0777	int
)	O
!=	O
0700	int
)	O
Panic	function
(	O
0	int
,	O
"Directory %s must have mode 700."	pointer
,	O
SockPath	array
)	O
;	O
if	O
(	O
SockMatch	pointer
&&	O
index	function
(	O
SockMatch	pointer
,	O
'/'	O
)	O
)	O
Panic	function
(	O
0	int
,	O
"Bad session name '%s'"	pointer
,	O
SockMatch	pointer
)	O
;	O
SockName	pointer
=	O
SockPath	array
+	O
strlen	function
(	O
SockPath	array
)	O
+	O
1	int
;	O
*	O
SockName	pointer
=	O
0	int
;	O
(	O
void	O
)	O
umask	function
(	O
oumask	int
)	O
;	O
debug2	O
(	O
"SockPath: %s  SockMatch: %s\n"	pointer
,	O
SockPath	array
,	O
SockMatch	pointer
?	O
SockMatch	pointer
:	O
"NULL"	pointer
)	O
;	O
(	O
void	O
)	O
gethostname	function
(	O
HostName	array
,	O
MAXSTR	int
)	O
;	O
HostName	array
[	O
MAXSTR	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
ap	pointer
=	O
index	function
(	O
HostName	array
,	O
'.'	O
)	O
)	O
!=	O
NULL	O
)	O
*	O
ap	pointer
=	O
'\0'	O
;	O
if	O
(	O
lsflag	int
)	O
{	O
int	O
i	int
,	O
fo	int
,	O
oth	int
;	O
bool	bool
sock	bool
;	O
if	O
(	O
multi	pointer
)	O
real_uid	int
=	O
multi_uid	int
;	O
SET_GUID	O
(	O
)	O
;	O
i	int
=	O
FindSocket	function
(	O
(	O
int	O
*	O
)	O
NULL	O
,	O
&	O
fo	int
,	O
&	O
oth	int
,	O
SockMatch	pointer
,	O
&	O
sock	bool
)	O
;	O
if	O
(	O
quietflag	int
)	O
{	O
if	O
(	O
rflag	int
)	O
exit	function
(	O
10	int
+	O
i	int
)	O
;	O
else	O
exit	function
(	O
9	int
+	O
(	O
fo	int
||	O
oth	int
?	O
1	int
:	O
0	int
)	O
+	O
fo	int
)	O
;	O
}	O
if	O
(	O
fo	int
==	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"No Sockets found in %s.\n"	pointer
,	O
SockPath	array
)	O
;	O
Msg	function
(	O
0	int
,	O
"%d Socket%s in %s."	pointer
,	O
fo	int
,	O
fo	int
>	O
1	int
?	O
"s"	pointer
:	O
""	pointer
,	O
SockPath	array
)	O
;	O
eexit	function
(	O
0	int
)	O
;	O
}	O
signal	function
(	O
SIG_BYE	O
,	O
AttacherFinit	function
)	O
;	O
if	O
(	O
cmdflag	int
)	O
{	O
SetTtyname	function
(	O
false	int
,	O
&	O
st	pointer
)	O
;	O
if	O
(	O
!	O
*	O
av	pointer
)	O
Panic	function
(	O
0	int
,	O
"Please specify a command."	pointer
)	O
;	O
SET_GUID	O
(	O
)	O
;	O
SendCmdMessage	function
(	O
sty	pointer
,	O
SockMatch	pointer
,	O
av	pointer
,	O
queryflag	int
>=	O
0	int
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
rflag	int
||	O
xflag	int
)	O
{	O
debug	O
(	O
"screen -r: - is there anybody out there?\n"	pointer
)	O
;	O
if	O
(	O
Attach	function
(	O
MSG_ATTACH	int
)	O
)	O
{	O
Attacher	function
(	O
)	O
;	O
}	O
if	O
(	O
multiattach	int
)	O
Panic	function
(	O
0	int
,	O
"Can't create sessions of other users."	pointer
)	O
;	O
debug	O
(	O
"screen -r: backend not responding -- still crying\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
dflag	int
&&	O
!	O
mflag	int
)	O
{	O
SetTtyname	function
(	O
false	int
,	O
&	O
st	pointer
)	O
;	O
Attach	function
(	O
MSG_DETACH	int
)	O
;	O
Msg	function
(	O
0	int
,	O
"[%s %sdetached.]\n"	pointer
,	O
SockName	pointer
,	O
(	O
dflag	int
>	O
1	int
?	O
"power "	pointer
:	O
""	pointer
)	O
)	O
;	O
eexit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
!	O
SockMatch	pointer
&&	O
!	O
mflag	int
&&	O
sty	pointer
)	O
{	O
SetTtyname	function
(	O
false	int
,	O
&	O
st	pointer
)	O
;	O
SET_GUID	O
(	O
)	O
;	O
nwin_options	struct
.	O
args	pointer
=	O
av	pointer
;	O
SendCreateMsg	function
(	O
sty	pointer
,	O
&	O
nwin	struct
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
nwin_compose	function
(	O
&	O
nwin_default	struct
,	O
&	O
nwin_options	struct
,	O
&	O
nwin_default	struct
)	O
;	O
if	O
(	O
!	O
detached	int
||	O
dflag	int
!=	O
2	int
)	O
MasterPid	int
=	O
fork	function
(	O
)	O
;	O
else	O
MasterPid	int
=	O
0	int
;	O
switch	O
(	O
MasterPid	int
)	O
{	O
case	O
-	O
1	int
:	O
Panic	function
(	O
errno	O
,	O
"fork"	pointer
)	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
if	O
(	O
detached	int
)	O
exit	function
(	O
0	int
)	O
;	O
if	O
(	O
SockMatch	pointer
)	O
sprintf	function
(	O
socknamebuf	array
,	O
"%d.%s"	pointer
,	O
MasterPid	int
,	O
SockMatch	pointer
)	O
;	O
else	O
sprintf	function
(	O
socknamebuf	array
,	O
"%d.%s.%s"	pointer
,	O
MasterPid	int
,	O
stripdev	function
(	O
attach_tty	pointer
)	O
,	O
HostName	array
)	O
;	O
for	O
(	O
ap	pointer
=	O
socknamebuf	array
;	O
*	O
ap	pointer
;	O
ap	pointer
++	O
)	O
if	O
(	O
*	O
ap	pointer
==	O
'/'	O
)	O
*	O
ap	pointer
=	O
'-'	O
;	O
if	O
(	O
strlen	function
(	O
socknamebuf	array
)	O
>	O
NAME_MAX	int
)	O
socknamebuf	array
[	O
NAME_MAX	int
]	O
=	O
0	int
;	O
sprintf	function
(	O
SockPath	array
+	O
strlen	function
(	O
SockPath	array
)	O
,	O
"/%s"	pointer
,	O
socknamebuf	array
)	O
;	O
SET_GUID	O
(	O
)	O
;	O
Attacher	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
detached	int
)	O
PanicPid	int
=	O
getppid	function
(	O
)	O
;	O
if	O
(	O
DefaultEsc	int
==	O
-	O
1	int
)	O
DefaultEsc	int
=	O
Ctrl	O
(	O
'a'	O
)	O
;	O
if	O
(	O
DefaultMetaEsc	int
==	O
-	O
1	int
)	O
DefaultMetaEsc	int
=	O
'a'	O
;	O
ap	pointer
=	O
av0	pointer
+	O
strlen	function
(	O
av0	pointer
)	O
-	O
1	int
;	O
while	O
(	O
ap	pointer
>=	O
av0	pointer
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
"screen"	pointer
,	O
ap	pointer
,	O
6	int
)	O
)	O
{	O
memcpy	function
(	O
ap	pointer
,	O
"SCREEN"	pointer
,	O
6	int
)	O
;	O
break	O
;	O
}	O
ap	pointer
--	O
;	O
}	O
if	O
(	O
ap	pointer
<	O
av0	pointer
)	O
*	O
av0	pointer
=	O
'S'	O
;	O
if	O
(	O
!	O
detached	int
)	O
{	O
if	O
(	O
attach_fd	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
n	int
=	O
secopen	function
(	O
attach_tty	pointer
,	O
O_RDWR	int
|	O
O_NONBLOCK	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"Cannot reopen '%s' - please check."	pointer
,	O
attach_tty	pointer
)	O
;	O
}	O
else	O
n	int
=	O
dup	function
(	O
attach_fd	int
)	O
;	O
}	O
else	O
n	int
=	O
-	O
1	int
;	O
freopen	function
(	O
"/dev/null"	pointer
,	O
"r"	pointer
,	O
stdin	pointer
)	O
;	O
freopen	function
(	O
"/dev/null"	pointer
,	O
"w"	pointer
,	O
stdout	pointer
)	O
;	O
freopen	function
(	O
"/dev/null"	pointer
,	O
"w"	pointer
,	O
stderr	pointer
)	O
;	O
debug	O
(	O
"-- screen.back debug started\n"	pointer
)	O
;	O
if	O
(	O
UserAdd	function
(	O
LoginName	pointer
,	O
(	O
char	O
*	O
)	O
0	int
,	O
(	O
struct	O
acluser	struct
*	O
*	O
)	O
0	int
)	O
<	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"Could not create user info"	pointer
)	O
;	O
if	O
(	O
!	O
detached	int
)	O
{	O
if	O
(	O
MakeDisplay	function
(	O
LoginName	pointer
,	O
attach_tty	pointer
,	O
attach_term	pointer
,	O
n	int
,	O
getppid	function
(	O
)	O
,	O
&	O
attach_Mode	struct
)	O
==	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"Could not alloc display"	pointer
)	O
;	O
PanicPid	int
=	O
0	int
;	O
D_encoding	O
=	O
nwin_options	struct
.	O
encoding	int
>	O
0	int
?	O
nwin_options	struct
.	O
encoding	int
:	O
0	int
;	O
debug1	O
(	O
"D_encoding = %d\n"	pointer
,	O
D_encoding	O
)	O
;	O
}	O
if	O
(	O
SockMatch	pointer
)	O
{	O
sprintf	function
(	O
socknamebuf	array
,	O
"%d.%s"	pointer
,	O
(	O
int	O
)	O
getpid	function
(	O
)	O
,	O
SockMatch	pointer
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
socknamebuf	array
,	O
"%d.%s.%s"	pointer
,	O
(	O
int	O
)	O
getpid	function
(	O
)	O
,	O
stripdev	function
(	O
attach_tty	pointer
)	O
,	O
HostName	array
)	O
;	O
}	O
for	O
(	O
ap	pointer
=	O
socknamebuf	array
;	O
*	O
ap	pointer
;	O
ap	pointer
++	O
)	O
if	O
(	O
*	O
ap	pointer
==	O
'/'	O
)	O
*	O
ap	pointer
=	O
'-'	O
;	O
if	O
(	O
strlen	function
(	O
socknamebuf	array
)	O
>	O
NAME_MAX	int
)	O
{	O
debug2	O
(	O
"Socketname %s truncated to %d chars\n"	pointer
,	O
socknamebuf	array
,	O
NAME_MAX	int
)	O
;	O
socknamebuf	array
[	O
NAME_MAX	int
]	O
=	O
0	int
;	O
}	O
sprintf	function
(	O
SockPath	array
+	O
strlen	function
(	O
SockPath	array
)	O
,	O
"/%s"	pointer
,	O
socknamebuf	array
)	O
;	O
ServerSocket	int
=	O
MakeServerSocket	function
(	O
true	int
)	O
;	O
if	O
(	O
(	O
ap	pointer
=	O
getenv	function
(	O
"SYSSCREENRC"	pointer
)	O
)	O
)	O
(	O
void	O
)	O
StartRc	function
(	O
ap	pointer
,	O
0	int
)	O
;	O
else	O
(	O
void	O
)	O
StartRc	function
(	O
ETCSCREENRC	O
,	O
0	int
)	O
;	O
(	O
void	O
)	O
StartRc	function
(	O
RcFileName	pointer
,	O
0	int
)	O
;	O
InitUtmp	function
(	O
)	O
;	O
if	O
(	O
display	struct
)	O
{	O
if	O
(	O
InitTermcap	function
(	O
0	int
,	O
0	int
)	O
)	O
{	O
debug	O
(	O
"Could not init termcap - exiting\n"	pointer
)	O
;	O
fcntl	function
(	O
D_userfd	O
,	O
F_SETFL	int
,	O
0	int
)	O
;	O
freetty	function
(	O
)	O
;	O
if	O
(	O
D_userpid	O
)	O
Kill	function
(	O
D_userpid	O
,	O
SIG_BYE	O
)	O
;	O
eexit	function
(	O
1	int
)	O
;	O
}	O
MakeDefaultCanvas	function
(	O
)	O
;	O
InitTerm	function
(	O
0	int
)	O
;	O
RemoveLoginSlot	function
(	O
)	O
;	O
}	O
else	O
MakeTermcap	function
(	O
1	int
)	O
;	O
InitLoadav	function
(	O
)	O
;	O
InitKeytab	function
(	O
)	O
;	O
MakeNewEnv	function
(	O
)	O
;	O
signal	function
(	O
SIGHUP	int
,	O
SigHup	function
)	O
;	O
signal	function
(	O
SIGINT	int
,	O
FinitHandler	function
)	O
;	O
signal	function
(	O
SIGQUIT	int
,	O
FinitHandler	function
)	O
;	O
signal	function
(	O
SIGTERM	int
,	O
FinitHandler	function
)	O
;	O
signal	function
(	O
SIGTTIN	int
,	O
SIG_IGN	O
)	O
;	O
signal	function
(	O
SIGTTOU	int
,	O
SIG_IGN	O
)	O
;	O
if	O
(	O
display	struct
)	O
{	O
brktty	function
(	O
D_userfd	O
)	O
;	O
SetMode	function
(	O
&	O
D_OldMode	O
,	O
&	O
D_NewMode	O
,	O
D_flow	O
,	O
iflag	int
)	O
;	O
SetTTY	function
(	O
D_userfd	O
,	O
&	O
D_NewMode	O
)	O
;	O
if	O
(	O
fcntl	function
(	O
D_userfd	O
,	O
F_SETFL	int
,	O
FNBLOCK	O
)	O
)	O
Msg	function
(	O
errno	O
,	O
"Warning: NBLOCK fcntl failed"	pointer
)	O
;	O
}	O
else	O
brktty	function
(	O
-	O
1	int
)	O
;	O
signal	function
(	O
SIGCHLD	int
,	O
SigChld	function
)	O
;	O
if	O
(	O
(	O
ap	pointer
=	O
getenv	function
(	O
"SYSSCREENRC"	pointer
)	O
)	O
)	O
FinishRc	function
(	O
ap	pointer
)	O
;	O
else	O
FinishRc	function
(	O
ETCSCREENRC	O
)	O
;	O
FinishRc	function
(	O
RcFileName	pointer
)	O
;	O
debug2	O
(	O
"UID %d  EUID %d\n"	pointer
,	O
(	O
int	O
)	O
getuid	function
(	O
)	O
,	O
(	O
int	O
)	O
geteuid	function
(	O
)	O
)	O
;	O
if	O
(	O
windows	pointer
==	O
NULL	O
)	O
{	O
debug	O
(	O
"We open one default window, as screenrc did not specify one.\n"	pointer
)	O
;	O
if	O
(	O
MakeWindow	function
(	O
&	O
nwin	struct
)	O
==	O
-	O
1	int
)	O
{	O
fd_set	struct
rfd	struct
;	O
struct	O
timeval	struct
tv	struct
=	O
{	O
MsgWait	int
/	O
1000	int
,	O
1000	int
*	O
(	O
MsgWait	int
%	O
1000	int
)	O
}	O
;	O
FD_SET	O
(	O
0	int
,	O
&	O
rfd	struct
)	O
;	O
Msg	function
(	O
0	int
,	O
"Sorry, could not find a PTY or TTY."	pointer
)	O
;	O
select	function
(	O
1	int
,	O
&	O
rfd	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
tv	struct
)	O
;	O
Finit	function
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
ac	int
)	O
MakeWindow	function
(	O
&	O
nwin	struct
)	O
;	O
if	O
(	O
display	struct
&&	O
default_startup	int
)	O
display_copyright	function
(	O
)	O
;	O
signal	function
(	O
SIGINT	int
,	O
SigInt	function
)	O
;	O
if	O
(	O
rflag	int
&&	O
(	O
rflag	int
&	O
1	int
)	O
==	O
0	int
&&	O
!	O
quietflag	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"New screen..."	pointer
)	O
;	O
rflag	int
=	O
0	int
;	O
}	O
serv_read	struct
.	O
type	enum
=	O
EV_READ	int
;	O
serv_read	struct
.	O
fd	int
=	O
ServerSocket	int
;	O
serv_read	struct
.	O
handler	pointer
=	O
serv_read_fn	function
;	O
evenq	function
(	O
&	O
serv_read	struct
)	O
;	O
serv_select	struct
.	O
pri	int
=	O
-	O
10	int
;	O
serv_select	struct
.	O
type	enum
=	O
EV_ALWAYS	int
;	O
serv_select	struct
.	O
handler	pointer
=	O
serv_select_fn	function
;	O
evenq	function
(	O
&	O
serv_select	struct
)	O
;	O
logflushev	struct
.	O
type	enum
=	O
EV_TIMEOUT	int
;	O
logflushev	struct
.	O
handler	pointer
=	O
logflush_fn	function
;	O
sched	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
WindowDied	function
(	O
p	pointer
,	O
wstat	int
,	O
wstat_valid	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
wstat	int
;	O
int	O
wstat_valid	int
;	O
{	O
int	O
killit	int
=	O
0	int
;	O
if	O
(	O
p	pointer
->	O
w_destroyev	struct
.	O
data	pointer
==	O
(	O
char	O
*	O
)	O
p	pointer
)	O
{	O
wstat	int
=	O
p	pointer
->	O
w_exitstatus	int
;	O
wstat_valid	int
=	O
1	int
;	O
evdeq	function
(	O
&	O
p	pointer
->	O
w_destroyev	struct
)	O
;	O
p	pointer
->	O
w_destroyev	struct
.	O
data	pointer
=	O
0	int
;	O
}	O
if	O
(	O
!	O
wstat_valid	int
&&	O
p	pointer
->	O
w_pid	int
>	O
0	int
)	O
{	O
if	O
(	O
waitpid	function
(	O
p	pointer
->	O
w_pid	int
,	O
&	O
wstat	int
,	O
WNOHANG	int
|	O
WUNTRACED	int
)	O
==	O
p	pointer
->	O
w_pid	int
)	O
{	O
p	pointer
->	O
w_pid	int
=	O
0	int
;	O
wstat_valid	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
ZombieKey_destroy	int
&&	O
ZombieKey_onerror	int
&&	O
wstat_valid	int
&&	O
WIFEXITED	O
(	O
wstat	int
)	O
&&	O
WEXITSTATUS	O
(	O
wstat	int
)	O
==	O
0	int
)	O
killit	int
=	O
1	int
;	O
if	O
(	O
ZombieKey_destroy	int
&&	O
!	O
killit	int
)	O
{	O
char	O
buf	pointer
[	O
100	int
]	O
,	O
*	O
s	pointer
,	O
reason	array
[	O
100	int
]	O
;	O
time_t	long
now	long
;	O
if	O
(	O
wstat_valid	int
)	O
{	O
if	O
(	O
WIFEXITED	O
(	O
wstat	int
)	O
)	O
if	O
(	O
WEXITSTATUS	O
(	O
wstat	int
)	O
)	O
sprintf	function
(	O
reason	array
,	O
"terminated with exit status %d"	pointer
,	O
WEXITSTATUS	O
(	O
wstat	int
)	O
)	O
;	O
else	O
sprintf	function
(	O
reason	array
,	O
"terminated normally"	pointer
)	O
;	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
wstat	int
)	O
)	O
sprintf	function
(	O
reason	array
,	O
"terminated with signal %d%s"	pointer
,	O
WTERMSIG	O
(	O
wstat	int
)	O
,	O
WCOREDUMP	O
(	O
wstat	int
)	O
?	O
" (core file generated)"	pointer
:	O
""	pointer
)	O
;	O
}	O
else	O
sprintf	function
(	O
reason	array
,	O
"detached from window"	pointer
)	O
;	O
(	O
void	O
)	O
time	struct
(	O
&	O
now	long
)	O
;	O
s	pointer
=	O
ctime	function
(	O
&	O
now	long
)	O
;	O
if	O
(	O
s	pointer
&&	O
*	O
s	pointer
)	O
s	pointer
[	O
strlen	function
(	O
s	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
debug3	O
(	O
"window %d (%s) going into zombie state fd %d"	pointer
,	O
p	pointer
->	O
w_number	int
,	O
p	pointer
->	O
w_title	pointer
,	O
p	pointer
->	O
w_ptyfd	int
)	O
;	O
if	O
(	O
p	pointer
->	O
w_slot	pointer
!=	O
(	O
slot_t	pointer
)	O
0	int
&&	O
p	pointer
->	O
w_slot	pointer
!=	O
(	O
slot_t	pointer
)	O
-	O
1	int
)	O
{	O
RemoveUtmp	function
(	O
p	pointer
)	O
;	O
p	pointer
->	O
w_slot	pointer
=	O
0	int
;	O
}	O
CloseDevice	function
(	O
p	pointer
)	O
;	O
p	pointer
->	O
w_deadpid	int
=	O
p	pointer
->	O
w_pid	int
;	O
p	pointer
->	O
w_pid	int
=	O
0	int
;	O
ResetWindow	function
(	O
p	pointer
)	O
;	O
p	pointer
->	O
w_y	O
=	O
MFindUsedLine	function
(	O
p	pointer
,	O
p	pointer
->	O
w_bot	int
,	O
1	int
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"\n\r=== Command %s (%s) ==="	pointer
,	O
reason	array
,	O
s	pointer
?	O
s	pointer
:	O
"?"	pointer
)	O
;	O
WriteString	function
(	O
p	pointer
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
p	pointer
->	O
w_poll_zombie_timeout	int
)	O
{	O
debug2	O
(	O
"Set zombie poll timeout for window %s to %d\n"	pointer
,	O
p	pointer
->	O
w_title	pointer
,	O
p	pointer
->	O
w_poll_zombie_timeout	int
)	O
;	O
SetTimeout	function
(	O
&	O
p	pointer
->	O
w_zombieev	struct
,	O
p	pointer
->	O
w_poll_zombie_timeout	int
*	O
1000	int
)	O
;	O
evenq	function
(	O
&	O
p	pointer
->	O
w_zombieev	struct
)	O
;	O
}	O
WindowChanged	function
(	O
p	pointer
,	O
'f'	O
)	O
;	O
}	O
else	O
KillWindow	function
(	O
p	pointer
)	O
;	O
CarefulUtmp	O
(	O
)	O
;	O
}	O
static	O
void	O
SigChldHandler	function
(	O
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
while	O
(	O
GotSigChld	int
)	O
{	O
GotSigChld	int
=	O
0	int
;	O
DoWait	function
(	O
)	O
;	O
}	O
if	O
(	O
stat	struct
(	O
SockPath	array
,	O
&	O
st	pointer
)	O
==	O
-	O
1	int
)	O
{	O
debug1	O
(	O
"SigChldHandler: Yuck! cannot stat '%s'\n"	pointer
,	O
SockPath	array
)	O
;	O
if	O
(	O
!	O
RecoverSocket	function
(	O
)	O
)	O
{	O
debug	O
(	O
"SCREEN cannot recover from corrupt Socket, bye\n"	pointer
)	O
;	O
Finit	function
(	O
1	int
)	O
;	O
}	O
else	O
debug1	O
(	O
"'%s' reconstructed\n"	pointer
,	O
SockPath	array
)	O
;	O
}	O
else	O
debug2	O
(	O
"SigChldHandler: stat '%s' o.k. (%03o)\n"	pointer
,	O
SockPath	array
,	O
(	O
int	O
)	O
st	pointer
.	O
st_mode	int
)	O
;	O
}	O
static	O
sigret_t	void
SigChld	function
SIGDEFARG	O
{	O
debug	O
(	O
"SigChld()\n"	pointer
)	O
;	O
GotSigChld	int
=	O
1	int
;	O
SIGRETURN	O
;	O
}	O
sigret_t	void
SigHup	function
SIGDEFARG	O
{	O
while	O
(	O
(	O
display	struct
=	O
displays	pointer
)	O
!=	O
0	int
)	O
Hangup	function
(	O
)	O
;	O
SIGRETURN	O
;	O
}	O
static	O
sigret_t	void
SigInt	function
SIGDEFARG	O
{	O
signal	function
(	O
SIGINT	int
,	O
SigInt	function
)	O
;	O
debug	O
(	O
"SigInt() careful\n"	pointer
)	O
;	O
InterruptPlease	int
=	O
1	int
;	O
SIGRETURN	O
;	O
}	O
static	O
sigret_t	void
CoreDump	function
SIGDEFARG	O
{	O
struct	O
display	struct
*	O
disp	pointer
;	O
char	O
buf	pointer
[	O
80	int
]	O
;	O
char	O
*	O
dump_msg	pointer
=	O
" (core dumped)"	pointer
;	O
int	O
running_w_s_bit	int
=	O
getuid	function
(	O
)	O
!=	O
geteuid	function
(	O
)	O
;	O
if	O
(	O
running_w_s_bit	int
)	O
dump_msg	pointer
=	O
""	pointer
;	O
setgid	function
(	O
getgid	function
(	O
)	O
)	O
;	O
setuid	function
(	O
getuid	function
(	O
)	O
)	O
;	O
unlink	function
(	O
"core"	pointer
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"\r\n[screen caught signal %d.%s]\r\n"	pointer
,	O
sigsig	int
,	O
dump_msg	pointer
)	O
;	O
for	O
(	O
disp	pointer
=	O
displays	pointer
;	O
disp	pointer
;	O
disp	pointer
=	O
disp	pointer
->	O
d_next	pointer
)	O
{	O
if	O
(	O
disp	pointer
->	O
d_nonblock	int
<	O
-	O
1	int
||	O
disp	pointer
->	O
d_nonblock	int
>	O
1000000	int
)	O
continue	O
;	O
fcntl	function
(	O
disp	pointer
->	O
d_userfd	int
,	O
F_SETFL	int
,	O
0	int
)	O
;	O
SetTTY	function
(	O
disp	pointer
->	O
d_userfd	int
,	O
&	O
D_OldMode	O
)	O
;	O
write	function
(	O
disp	pointer
->	O
d_userfd	int
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
Kill	function
(	O
disp	pointer
->	O
d_userpid	int
,	O
SIG_BYE	O
)	O
;	O
}	O
if	O
(	O
running_w_s_bit	int
)	O
{	O
Kill	function
(	O
getpid	function
(	O
)	O
,	O
SIGKILL	int
)	O
;	O
eexit	function
(	O
11	int
)	O
;	O
}	O
else	O
abort	function
(	O
)	O
;	O
SIGRETURN	O
;	O
}	O
static	O
void	O
DoWait	function
(	O
)	O
{	O
register	O
int	O
pid	int
;	O
struct	O
win	struct
*	O
p	pointer
,	O
*	O
next	pointer
;	O
int	O
wstat	int
;	O
while	O
(	O
(	O
pid	int
=	O
waitpid	function
(	O
-	O
1	int
,	O
&	O
wstat	int
,	O
WNOHANG	int
|	O
WUNTRACED	int
)	O
)	O
>	O
0	int
)	O
{	O
for	O
(	O
p	pointer
=	O
windows	pointer
;	O
p	pointer
;	O
p	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
p	pointer
->	O
w_next	pointer
;	O
if	O
(	O
(	O
p	pointer
->	O
w_pid	int
&&	O
pid	int
==	O
p	pointer
->	O
w_pid	int
)	O
||	O
(	O
p	pointer
->	O
w_deadpid	int
&&	O
pid	int
==	O
p	pointer
->	O
w_deadpid	int
)	O
)	O
{	O
p	pointer
->	O
w_pid	int
=	O
0	int
;	O
if	O
(	O
WIFSTOPPED	O
(	O
wstat	int
)	O
)	O
{	O
debug3	O
(	O
"Window %d pid %d: WIFSTOPPED (sig %d)\n"	pointer
,	O
p	pointer
->	O
w_number	int
,	O
pid	int
,	O
WSTOPSIG	O
(	O
wstat	int
)	O
)	O
;	O
if	O
(	O
WSTOPSIG	O
(	O
wstat	int
)	O
==	O
SIGTTIN	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Suspended (tty input)"	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
WSTOPSIG	O
(	O
wstat	int
)	O
==	O
SIGTTOU	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Suspended (tty output)"	pointer
)	O
;	O
continue	O
;	O
}	O
Msg	function
(	O
0	int
,	O
"Child has been stopped, restarting."	pointer
)	O
;	O
if	O
(	O
killpg	function
(	O
pid	int
,	O
SIGCONT	int
)	O
)	O
kill	function
(	O
pid	int
,	O
SIGCONT	int
)	O
;	O
}	O
else	O
{	O
p	pointer
->	O
w_destroyev	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
p	pointer
;	O
p	pointer
->	O
w_exitstatus	int
=	O
wstat	int
;	O
SetTimeout	function
(	O
&	O
p	pointer
->	O
w_destroyev	struct
,	O
10	int
*	O
1000	int
)	O
;	O
evenq	function
(	O
&	O
p	pointer
->	O
w_destroyev	struct
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
p	pointer
->	O
w_pwin	pointer
&&	O
pid	int
==	O
p	pointer
->	O
w_pwin	pointer
->	O
p_pid	int
)	O
{	O
debug2	O
(	O
"pseudo of win Nr %d died. pid == %d\n"	pointer
,	O
p	pointer
->	O
w_number	int
,	O
p	pointer
->	O
w_pwin	pointer
->	O
p_pid	int
)	O
;	O
FreePseudowin	function
(	O
p	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
p	pointer
==	O
0	int
)	O
{	O
debug1	O
(	O
"pid %d not found - hope that's ok\n"	pointer
,	O
pid	int
)	O
;	O
}	O
}	O
}	O
static	O
sigret_t	void
FinitHandler	function
SIGDEFARG	O
{	O
debug1	O
(	O
"FinitHandler called, sig %d.\n"	pointer
,	O
sigsig	int
)	O
;	O
Finit	function
(	O
1	int
)	O
;	O
SIGRETURN	O
;	O
}	O
void	O
Finit	function
(	O
int	O
i	int
)	O
{	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
signal	function
(	O
SIGHUP	int
,	O
SIG_IGN	O
)	O
;	O
debug1	O
(	O
"Finit(%d);\n"	pointer
,	O
i	int
)	O
;	O
while	O
(	O
windows	pointer
)	O
{	O
struct	O
win	struct
*	O
p	pointer
=	O
windows	pointer
;	O
windows	pointer
=	O
windows	pointer
->	O
w_next	pointer
;	O
FreeWindow	function
(	O
p	pointer
)	O
;	O
}	O
if	O
(	O
ServerSocket	int
!=	O
-	O
1	int
)	O
{	O
debug1	O
(	O
"we unlink(%s)\n"	pointer
,	O
SockPath	array
)	O
;	O
xseteuid	function
(	O
real_uid	int
)	O
;	O
xsetegid	function
(	O
real_gid	int
)	O
;	O
(	O
void	O
)	O
unlink	function
(	O
SockPath	array
)	O
;	O
xseteuid	function
(	O
eff_uid	int
)	O
;	O
xsetegid	function
(	O
eff_gid	int
)	O
;	O
}	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
if	O
(	O
D_status	O
)	O
RemoveStatus	function
(	O
)	O
;	O
FinitTerm	function
(	O
)	O
;	O
RestoreLoginSlot	function
(	O
)	O
;	O
AddStr	function
(	O
"[screen is terminating]\r\n"	pointer
)	O
;	O
Flush	function
(	O
3	int
)	O
;	O
SetTTY	function
(	O
D_userfd	O
,	O
&	O
D_OldMode	O
)	O
;	O
fcntl	function
(	O
D_userfd	O
,	O
F_SETFL	int
,	O
0	int
)	O
;	O
freetty	function
(	O
)	O
;	O
Kill	function
(	O
D_userpid	O
,	O
SIG_BYE	O
)	O
;	O
}	O
exit	function
(	O
i	int
)	O
;	O
}	O
void	O
eexit	function
(	O
int	O
e	int
)	O
{	O
debug	O
(	O
"eexit\n"	pointer
)	O
;	O
if	O
(	O
ServerSocket	int
!=	O
-	O
1	int
)	O
{	O
debug1	O
(	O
"we unlink(%s)\n"	pointer
,	O
SockPath	array
)	O
;	O
setgid	function
(	O
real_gid	int
)	O
;	O
setuid	function
(	O
real_uid	int
)	O
;	O
(	O
void	O
)	O
unlink	function
(	O
SockPath	array
)	O
;	O
}	O
exit	function
(	O
e	int
)	O
;	O
}	O
void	O
Hangup	function
(	O
)	O
{	O
if	O
(	O
display	struct
==	O
0	int
)	O
return	O
;	O
debug1	O
(	O
"Hangup %x\n"	pointer
,	O
display	struct
)	O
;	O
if	O
(	O
D_userfd	O
>=	O
0	int
)	O
{	O
close	function
(	O
D_userfd	O
)	O
;	O
D_userfd	O
=	O
-	O
1	int
;	O
}	O
if	O
(	O
auto_detach	int
||	O
displays	pointer
->	O
d_next	pointer
)	O
Detach	function
(	O
D_HANGUP	int
)	O
;	O
else	O
Finit	function
(	O
0	int
)	O
;	O
}	O
void	O
Detach	function
(	O
int	O
mode	struct
)	O
{	O
int	O
sign	int
=	O
0	int
,	O
pid	int
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
struct	O
win	struct
*	O
p	pointer
;	O
if	O
(	O
display	struct
==	O
0	int
)	O
return	O
;	O
signal	function
(	O
SIGHUP	int
,	O
SIG_IGN	O
)	O
;	O
debug1	O
(	O
"Detach(%d)\n"	pointer
,	O
mode	struct
)	O
;	O
if	O
(	O
D_status	O
)	O
RemoveStatus	function
(	O
)	O
;	O
FinitTerm	function
(	O
)	O
;	O
if	O
(	O
!	O
display	struct
)	O
return	O
;	O
switch	O
(	O
mode	struct
)	O
{	O
case	O
D_HANGUP	int
:	O
sign	int
=	O
SIG_BYE	O
;	O
break	O
;	O
case	O
D_DETACH	int
:	O
AddStrSock	O
(	O
"detached"	pointer
)	O
;	O
sign	int
=	O
SIG_BYE	O
;	O
break	O
;	O
case	O
D_STOP	int
:	O
sign	int
=	O
SIG_STOP	O
;	O
break	O
;	O
case	O
D_REMOTE	int
:	O
AddStrSock	O
(	O
"remote detached"	pointer
)	O
;	O
sign	int
=	O
SIG_BYE	O
;	O
break	O
;	O
case	O
D_POWER	int
:	O
AddStrSock	O
(	O
"power detached"	pointer
)	O
;	O
if	O
(	O
PowDetachString	pointer
)	O
{	O
AddStr	function
(	O
PowDetachString	pointer
)	O
;	O
AddStr	function
(	O
"\r\n"	pointer
)	O
;	O
}	O
sign	int
=	O
SIG_POWER_BYE	O
;	O
break	O
;	O
case	O
D_REMOTE_POWER	int
:	O
AddStrSock	O
(	O
"remote power detached"	pointer
)	O
;	O
if	O
(	O
PowDetachString	pointer
)	O
{	O
AddStr	function
(	O
PowDetachString	pointer
)	O
;	O
AddStr	function
(	O
"\r\n"	pointer
)	O
;	O
}	O
sign	int
=	O
SIG_POWER_BYE	O
;	O
break	O
;	O
case	O
D_LOCK	int
:	O
ClearAll	function
(	O
)	O
;	O
sign	int
=	O
SIG_LOCK	O
;	O
break	O
;	O
}	O
if	O
(	O
displays	pointer
->	O
d_next	pointer
==	O
0	int
)	O
{	O
for	O
(	O
p	pointer
=	O
windows	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
w_next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
w_slot	pointer
!=	O
(	O
slot_t	pointer
)	O
-	O
1	int
&&	O
!	O
(	O
p	pointer
->	O
w_lflag	int
&	O
2	int
)	O
)	O
{	O
RemoveUtmp	function
(	O
p	pointer
)	O
;	O
p	pointer
->	O
w_slot	pointer
=	O
(	O
slot_t	pointer
)	O
0	int
;	O
}	O
}	O
}	O
if	O
(	O
mode	struct
!=	O
D_HANGUP	int
)	O
RestoreLoginSlot	function
(	O
)	O
;	O
if	O
(	O
displays	pointer
->	O
d_next	pointer
==	O
0	int
&&	O
console_window	pointer
)	O
{	O
if	O
(	O
TtyGrabConsole	function
(	O
console_window	pointer
->	O
w_ptyfd	int
,	O
0	int
,	O
"detach"	pointer
)	O
)	O
{	O
debug	O
(	O
"could not release console - killing window\n"	pointer
)	O
;	O
KillWindow	function
(	O
console_window	pointer
)	O
;	O
display	struct
=	O
displays	pointer
;	O
}	O
}	O
if	O
(	O
D_fore	O
)	O
{	O
ReleaseAutoWritelock	function
(	O
display	struct
,	O
D_fore	O
)	O
;	O
D_user	O
->	O
u_detachwin	int
=	O
D_fore	O
->	O
w_number	int
;	O
D_user	O
->	O
u_detachotherwin	int
=	O
D_other	O
?	O
D_other	O
->	O
w_number	int
:	O
-	O
1	int
;	O
}	O
AutosaveLayout	function
(	O
D_layout	O
)	O
;	O
layout_last	pointer
=	O
D_layout	O
;	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
p	pointer
=	O
Layer2Window	O
(	O
cv	pointer
->	O
c_layer	pointer
)	O
;	O
SetCanvasWindow	function
(	O
cv	pointer
,	O
0	int
)	O
;	O
if	O
(	O
p	pointer
)	O
WindowChanged	function
(	O
p	pointer
,	O
'u'	O
)	O
;	O
}	O
pid	int
=	O
D_userpid	O
;	O
debug2	O
(	O
"display: %#x displays: %#x\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
display	struct
,	O
(	O
unsigned	O
int	O
)	O
displays	pointer
)	O
;	O
FreeDisplay	function
(	O
)	O
;	O
if	O
(	O
displays	pointer
==	O
0	int
)	O
(	O
void	O
)	O
chsock	function
(	O
)	O
;	O
Kill	function
(	O
pid	int
,	O
sign	int
)	O
;	O
debug2	O
(	O
"Detach: Signal %d to Attacher(%d)!\n"	pointer
,	O
sign	int
,	O
pid	int
)	O
;	O
debug	O
(	O
"Detach returns, we are successfully detached.\n"	pointer
)	O
;	O
signal	function
(	O
SIGHUP	int
,	O
SigHup	function
)	O
;	O
}	O
static	O
int	O
IsSymbol	function
(	O
char	O
*	O
e	int
,	O
char	O
*	O
s	pointer
)	O
{	O
register	O
int	O
l	pointer
;	O
l	pointer
=	O
strlen	function
(	O
s	pointer
)	O
;	O
return	O
strncmp	function
(	O
e	int
,	O
s	pointer
,	O
l	pointer
)	O
==	O
0	int
&&	O
e	int
[	O
l	pointer
]	O
==	O
'='	O
;	O
}	O
void	O
MakeNewEnv	function
(	O
)	O
{	O
register	O
char	O
*	O
*	O
op	pointer
,	O
*	O
*	O
np	pointer
;	O
static	O
char	O
stybuf	array
[	O
MAXSTR	int
]	O
;	O
for	O
(	O
op	pointer
=	O
environ	pointer
;	O
*	O
op	pointer
;	O
++	O
op	pointer
)	O
;	O
if	O
(	O
NewEnv	pointer
)	O
free	function
(	O
(	O
char	O
*	O
)	O
NewEnv	pointer
)	O
;	O
NewEnv	pointer
=	O
np	pointer
=	O
(	O
char	O
*	O
*	O
)	O
malloc	function
(	O
(	O
unsigned	O
)	O
(	O
op	pointer
-	O
environ	pointer
+	O
7	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
*	O
)	O
)	O
;	O
if	O
(	O
!	O
NewEnv	pointer
)	O
Panic	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
sprintf	function
(	O
stybuf	array
,	O
"STY=%s"	pointer
,	O
strlen	function
(	O
SockName	pointer
)	O
<=	O
MAXSTR	int
-	O
5	int
?	O
SockName	pointer
:	O
"?"	pointer
)	O
;	O
*	O
np	pointer
++	O
=	O
stybuf	array
;	O
*	O
np	pointer
++	O
=	O
Term	array
;	O
np	pointer
++	O
;	O
np	pointer
+=	O
2	int
;	O
for	O
(	O
op	pointer
=	O
environ	pointer
;	O
*	O
op	pointer
;	O
++	O
op	pointer
)	O
{	O
if	O
(	O
!	O
IsSymbol	function
(	O
*	O
op	pointer
,	O
"TERM"	pointer
)	O
&&	O
!	O
IsSymbol	function
(	O
*	O
op	pointer
,	O
"TERMCAP"	pointer
)	O
&&	O
!	O
IsSymbol	function
(	O
*	O
op	pointer
,	O
"STY"	pointer
)	O
&&	O
!	O
IsSymbol	function
(	O
*	O
op	pointer
,	O
"WINDOW"	pointer
)	O
&&	O
!	O
IsSymbol	function
(	O
*	O
op	pointer
,	O
"SCREENCAP"	pointer
)	O
&&	O
!	O
IsSymbol	function
(	O
*	O
op	pointer
,	O
"SHELL"	pointer
)	O
&&	O
!	O
IsSymbol	function
(	O
*	O
op	pointer
,	O
"LINES"	pointer
)	O
&&	O
!	O
IsSymbol	function
(	O
*	O
op	pointer
,	O
"COLUMNS"	pointer
)	O
)	O
*	O
np	pointer
++	O
=	O
*	O
op	pointer
;	O
}	O
*	O
np	pointer
=	O
0	int
;	O
}	O
DEFINE_VARARGS_FN	O
(	O
Msg	function
)	O
{	O
char	O
buf	pointer
[	O
MAXPATHLEN	O
*	O
2	int
]	O
;	O
PROCESS_MESSAGE	O
(	O
buf	pointer
)	O
;	O
debug2	O
(	O
"Msg('%s') (%#x);\n"	pointer
,	O
buf	pointer
,	O
(	O
unsigned	O
int	O
)	O
display	struct
)	O
;	O
if	O
(	O
display	struct
&&	O
displays	pointer
)	O
MakeStatus	function
(	O
buf	pointer
)	O
;	O
else	O
if	O
(	O
displays	pointer
)	O
{	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
MakeStatus	function
(	O
buf	pointer
)	O
;	O
}	O
else	O
if	O
(	O
display	struct
)	O
{	O
char	O
*	O
tty	pointer
=	O
D_usertty	O
;	O
struct	O
display	struct
*	O
olddisplay	pointer
=	O
display	struct
;	O
display	struct
=	O
0	int
;	O
SendErrorMsg	function
(	O
tty	pointer
,	O
buf	pointer
)	O
;	O
display	struct
=	O
olddisplay	pointer
;	O
}	O
else	O
printf	function
(	O
"%s\r\n"	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
queryflag	int
>=	O
0	int
)	O
write	function
(	O
queryflag	int
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
DEFINE_VARARGS_FN	O
(	O
Panic	function
)	O
{	O
char	O
buf	pointer
[	O
MAXPATHLEN	O
*	O
2	int
]	O
;	O
PROCESS_MESSAGE	O
(	O
buf	pointer
)	O
;	O
debug3	O
(	O
"Panic('%s'); display=%x displays=%x\n"	pointer
,	O
buf	pointer
,	O
display	struct
,	O
displays	pointer
)	O
;	O
if	O
(	O
displays	pointer
==	O
0	int
&&	O
display	struct
==	O
0	int
)	O
{	O
printf	function
(	O
"%s\r\n"	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
PanicPid	int
)	O
Kill	function
(	O
PanicPid	int
,	O
SIG_BYE	O
)	O
;	O
}	O
else	O
if	O
(	O
displays	pointer
==	O
0	int
)	O
{	O
char	O
*	O
tty	pointer
=	O
D_usertty	O
;	O
display	struct
=	O
0	int
;	O
SendErrorMsg	function
(	O
tty	pointer
,	O
buf	pointer
)	O
;	O
sleep	function
(	O
2	int
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
else	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
if	O
(	O
D_status	O
)	O
RemoveStatus	function
(	O
)	O
;	O
FinitTerm	function
(	O
)	O
;	O
Flush	function
(	O
3	int
)	O
;	O
RestoreLoginSlot	function
(	O
)	O
;	O
SetTTY	function
(	O
D_userfd	O
,	O
&	O
D_OldMode	O
)	O
;	O
fcntl	function
(	O
D_userfd	O
,	O
F_SETFL	int
,	O
0	int
)	O
;	O
write	function
(	O
D_userfd	O
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
write	function
(	O
D_userfd	O
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
freetty	function
(	O
)	O
;	O
if	O
(	O
D_userpid	O
)	O
Kill	function
(	O
D_userpid	O
,	O
SIG_BYE	O
)	O
;	O
}	O
if	O
(	O
tty_oldmode	int
>=	O
0	int
)	O
{	O
if	O
(	O
setuid	function
(	O
own_uid	int
)	O
)	O
xseteuid	function
(	O
own_uid	int
)	O
;	O
debug1	O
(	O
"Panic: changing back modes from %s\n"	pointer
,	O
attach_tty	pointer
)	O
;	O
chmod	function
(	O
attach_tty	pointer
,	O
tty_oldmode	int
)	O
;	O
}	O
eexit	function
(	O
1	int
)	O
;	O
}	O
DEFINE_VARARGS_FN	O
(	O
QueryMsg	function
)	O
{	O
char	O
buf	pointer
[	O
MAXPATHLEN	O
*	O
2	int
]	O
;	O
if	O
(	O
queryflag	int
<	O
0	int
)	O
return	O
;	O
PROCESS_MESSAGE	O
(	O
buf	pointer
)	O
;	O
write	function
(	O
queryflag	int
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
DEFINE_VARARGS_FN	O
(	O
Dummy	function
)	O
{	O
}	O
static	O
char	O
winmsg_buf	array
[	O
MAXSTR	int
]	O
;	O
static	O
int	O
winmsg_rend	array
[	O
MAX_WINMSG_REND	int
]	O
;	O
static	O
int	O
winmsg_rendpos	array
[	O
MAX_WINMSG_REND	int
]	O
;	O
static	O
int	O
winmsg_numrend	int
;	O
static	O
char	O
*	O
pad_expand	function
(	O
char	O
*	O
buf	pointer
,	O
char	O
*	O
p	pointer
,	O
int	O
numpad	int
,	O
int	O
padlen	int
)	O
{	O
char	O
*	O
pn	pointer
,	O
*	O
pn2	pointer
;	O
int	O
i	int
,	O
r	int
;	O
padlen	int
=	O
padlen	int
-	O
(	O
p	pointer
-	O
buf	pointer
)	O
;	O
if	O
(	O
padlen	int
<	O
0	int
)	O
padlen	int
=	O
0	int
;	O
pn2	pointer
=	O
pn	pointer
=	O
p	pointer
+	O
padlen	int
;	O
r	int
=	O
winmsg_numrend	int
;	O
while	O
(	O
p	pointer
>=	O
buf	pointer
)	O
{	O
if	O
(	O
r	int
&&	O
*	O
p	pointer
!=	O
127	int
&&	O
p	pointer
-	O
buf	pointer
==	O
winmsg_rendpos	array
[	O
r	int
-	O
1	int
]	O
)	O
{	O
winmsg_rendpos	array
[	O
--	O
r	int
]	O
=	O
pn	pointer
-	O
buf	pointer
;	O
continue	O
;	O
}	O
*	O
pn	pointer
--	O
=	O
*	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
--	O
==	O
127	int
)	O
{	O
pn	pointer
[	O
1	int
]	O
=	O
' '	O
;	O
i	int
=	O
numpad	int
>	O
0	int
?	O
(	O
padlen	int
+	O
numpad	int
-	O
1	int
)	O
/	O
numpad	int
:	O
0	int
;	O
padlen	int
-=	O
i	int
;	O
while	O
(	O
i	int
--	O
>	O
0	int
)	O
*	O
pn	pointer
--	O
=	O
' '	O
;	O
numpad	int
--	O
;	O
if	O
(	O
r	int
&&	O
p	pointer
-	O
buf	pointer
+	O
1	int
==	O
winmsg_rendpos	array
[	O
r	int
-	O
1	int
]	O
)	O
winmsg_rendpos	array
[	O
--	O
r	int
]	O
=	O
pn	pointer
-	O
buf	pointer
+	O
1	int
;	O
}	O
}	O
return	O
pn2	pointer
;	O
}	O
struct	O
backtick	struct
{	O
struct	O
backtick	struct
*	O
next	pointer
;	O
int	O
num	int
;	O
int	O
tick	long
;	O
int	O
lifespan	int
;	O
time_t	long
bestbefore	long
;	O
char	O
result	array
[	O
MAXSTR	int
]	O
;	O
char	O
*	O
*	O
cmdv	pointer
;	O
struct	O
event	struct
ev	struct
;	O
char	O
*	O
buf	pointer
;	O
int	O
bufi	int
;	O
}	O
;	O
struct	O
backtick	struct
*	O
backticks	pointer
;	O
static	O
void	O
backtick_filter	function
(	O
struct	O
backtick	struct
*	O
bt	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
int	O
c	char
;	O
for	O
(	O
p	pointer
=	O
q	pointer
=	O
bt	pointer
->	O
result	array
;	O
(	O
c	char
=	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
++	O
)	O
!=	O
0	int
;	O
)	O
{	O
if	O
(	O
c	char
==	O
'\t'	O
)	O
c	char
=	O
' '	O
;	O
if	O
(	O
c	char
>=	O
' '	O
||	O
c	char
==	O
'\005'	O
)	O
*	O
q	pointer
++	O
=	O
c	char
;	O
}	O
*	O
q	pointer
=	O
0	int
;	O
}	O
static	O
void	O
backtick_fn	function
(	O
struct	O
event	struct
*	O
ev	struct
,	O
char	O
*	O
data	pointer
)	O
{	O
struct	O
backtick	struct
*	O
bt	pointer
;	O
int	O
i	int
,	O
j	int
,	O
k	int
,	O
l	pointer
;	O
bt	pointer
=	O
(	O
struct	O
backtick	struct
*	O
)	O
data	pointer
;	O
debug1	O
(	O
"backtick_fn for #%d\n"	pointer
,	O
bt	pointer
->	O
num	int
)	O
;	O
i	int
=	O
bt	pointer
->	O
bufi	int
;	O
l	pointer
=	O
read	function
(	O
ev	struct
->	O
fd	int
,	O
bt	pointer
->	O
buf	pointer
+	O
i	int
,	O
MAXSTR	int
-	O
i	int
)	O
;	O
if	O
(	O
l	pointer
<=	O
0	int
)	O
{	O
debug1	O
(	O
"EOF on backtick #%d\n"	pointer
,	O
bt	pointer
->	O
num	int
)	O
;	O
evdeq	function
(	O
ev	struct
)	O
;	O
close	function
(	O
ev	struct
->	O
fd	int
)	O
;	O
ev	struct
->	O
fd	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
debug1	O
(	O
"read %d bytes\n"	pointer
,	O
l	pointer
)	O
;	O
i	int
+=	O
l	pointer
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
l	pointer
;	O
j	int
++	O
)	O
if	O
(	O
bt	pointer
->	O
buf	pointer
[	O
i	int
-	O
j	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
break	O
;	O
if	O
(	O
j	int
<	O
l	pointer
)	O
{	O
for	O
(	O
k	int
=	O
i	int
-	O
j	int
-	O
2	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
if	O
(	O
bt	pointer
->	O
buf	pointer
[	O
k	int
]	O
==	O
'\n'	O
)	O
break	O
;	O
k	int
++	O
;	O
bcopy	function
(	O
bt	pointer
->	O
buf	pointer
+	O
k	int
,	O
bt	pointer
->	O
result	array
,	O
i	int
-	O
j	int
-	O
k	int
)	O
;	O
bt	pointer
->	O
result	array
[	O
i	int
-	O
j	int
-	O
k	int
-	O
1	int
]	O
=	O
0	int
;	O
backtick_filter	function
(	O
bt	pointer
)	O
;	O
WindowChanged	function
(	O
0	int
,	O
'`'	O
)	O
;	O
}	O
if	O
(	O
j	int
==	O
l	pointer
&&	O
i	int
==	O
MAXSTR	int
)	O
{	O
j	int
=	O
MAXSTR	int
/	O
2	int
;	O
l	pointer
=	O
j	int
+	O
1	int
;	O
}	O
if	O
(	O
j	int
<	O
l	pointer
)	O
{	O
if	O
(	O
j	int
)	O
bcopy	function
(	O
bt	pointer
->	O
buf	pointer
+	O
i	int
-	O
j	int
,	O
bt	pointer
->	O
buf	pointer
,	O
j	int
)	O
;	O
i	int
=	O
j	int
;	O
}	O
bt	pointer
->	O
bufi	int
=	O
i	int
;	O
}	O
void	O
setbacktick	function
(	O
int	O
num	int
,	O
int	O
lifespan	int
,	O
int	O
tick	long
,	O
char	O
*	O
*	O
cmdv	pointer
)	O
{	O
struct	O
backtick	struct
*	O
*	O
btp	pointer
,	O
*	O
bt	pointer
;	O
char	O
*	O
*	O
v	pointer
;	O
debug1	O
(	O
"setbacktick called for backtick #%d\n"	pointer
,	O
num	int
)	O
;	O
for	O
(	O
btp	pointer
=	O
&	O
backticks	pointer
;	O
(	O
bt	pointer
=	O
*	O
btp	pointer
)	O
!=	O
0	int
;	O
btp	pointer
=	O
&	O
bt	pointer
->	O
next	pointer
)	O
if	O
(	O
bt	pointer
->	O
num	int
==	O
num	int
)	O
break	O
;	O
if	O
(	O
!	O
bt	pointer
&&	O
!	O
cmdv	pointer
)	O
return	O
;	O
if	O
(	O
bt	pointer
)	O
{	O
for	O
(	O
v	pointer
=	O
bt	pointer
->	O
cmdv	pointer
;	O
*	O
v	pointer
;	O
v	pointer
++	O
)	O
free	function
(	O
*	O
v	pointer
)	O
;	O
free	function
(	O
bt	pointer
->	O
cmdv	pointer
)	O
;	O
if	O
(	O
bt	pointer
->	O
buf	pointer
)	O
free	function
(	O
bt	pointer
->	O
buf	pointer
)	O
;	O
if	O
(	O
bt	pointer
->	O
ev	struct
.	O
fd	int
>=	O
0	int
)	O
close	function
(	O
bt	pointer
->	O
ev	struct
.	O
fd	int
)	O
;	O
evdeq	function
(	O
&	O
bt	pointer
->	O
ev	struct
)	O
;	O
}	O
if	O
(	O
bt	pointer
&&	O
!	O
cmdv	pointer
)	O
{	O
*	O
btp	pointer
=	O
bt	pointer
->	O
next	pointer
;	O
free	function
(	O
bt	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
bt	pointer
)	O
{	O
bt	pointer
=	O
(	O
struct	O
backtick	struct
*	O
)	O
malloc	function
(	O
sizeof	O
*	O
bt	pointer
)	O
;	O
if	O
(	O
!	O
bt	pointer
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
return	O
;	O
}	O
bzero	function
(	O
bt	pointer
,	O
sizeof	O
(	O
*	O
bt	pointer
)	O
)	O
;	O
bt	pointer
->	O
next	pointer
=	O
0	int
;	O
*	O
btp	pointer
=	O
bt	pointer
;	O
}	O
bt	pointer
->	O
num	int
=	O
num	int
;	O
bt	pointer
->	O
tick	long
=	O
tick	long
;	O
bt	pointer
->	O
lifespan	int
=	O
lifespan	int
;	O
bt	pointer
->	O
bestbefore	long
=	O
0	int
;	O
bt	pointer
->	O
result	array
[	O
0	int
]	O
=	O
0	int
;	O
bt	pointer
->	O
buf	pointer
=	O
0	int
;	O
bt	pointer
->	O
bufi	int
=	O
0	int
;	O
bt	pointer
->	O
cmdv	pointer
=	O
cmdv	pointer
;	O
bt	pointer
->	O
ev	struct
.	O
fd	int
=	O
-	O
1	int
;	O
if	O
(	O
bt	pointer
->	O
tick	long
==	O
0	int
&&	O
bt	pointer
->	O
lifespan	int
==	O
0	int
)	O
{	O
debug	O
(	O
"setbacktick: continuous mode\n"	pointer
)	O
;	O
bt	pointer
->	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
MAXSTR	int
)	O
;	O
if	O
(	O
bt	pointer
->	O
buf	pointer
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
setbacktick	function
(	O
num	int
,	O
0	int
,	O
0	int
,	O
(	O
char	O
*	O
*	O
)	O
0	int
)	O
;	O
return	O
;	O
}	O
bt	pointer
->	O
ev	struct
.	O
type	enum
=	O
EV_READ	int
;	O
bt	pointer
->	O
ev	struct
.	O
fd	int
=	O
readpipe	function
(	O
bt	pointer
->	O
cmdv	pointer
)	O
;	O
bt	pointer
->	O
ev	struct
.	O
handler	pointer
=	O
backtick_fn	function
;	O
bt	pointer
->	O
ev	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
bt	pointer
;	O
if	O
(	O
bt	pointer
->	O
ev	struct
.	O
fd	int
>=	O
0	int
)	O
evenq	function
(	O
&	O
bt	pointer
->	O
ev	struct
)	O
;	O
}	O
}	O
static	O
char	O
*	O
runbacktick	function
(	O
struct	O
backtick	struct
*	O
bt	pointer
,	O
int	O
*	O
tickp	pointer
,	O
time_t	long
now	long
)	O
{	O
int	O
f	int
,	O
i	int
,	O
l	pointer
,	O
j	int
;	O
time_t	long
now2	long
;	O
debug1	O
(	O
"runbacktick called for backtick #%d\n"	pointer
,	O
bt	pointer
->	O
num	int
)	O
;	O
if	O
(	O
bt	pointer
->	O
tick	long
&&	O
(	O
!	O
*	O
tickp	pointer
||	O
bt	pointer
->	O
tick	long
<	O
*	O
tickp	pointer
)	O
)	O
*	O
tickp	pointer
=	O
bt	pointer
->	O
tick	long
;	O
if	O
(	O
(	O
bt	pointer
->	O
lifespan	int
==	O
0	int
&&	O
bt	pointer
->	O
tick	long
==	O
0	int
)	O
||	O
now	long
<	O
bt	pointer
->	O
bestbefore	long
)	O
{	O
debug1	O
(	O
"returning old result (%d)\n"	pointer
,	O
bt	pointer
->	O
lifespan	int
)	O
;	O
return	O
bt	pointer
->	O
result	array
;	O
}	O
f	int
=	O
readpipe	function
(	O
bt	pointer
->	O
cmdv	pointer
)	O
;	O
if	O
(	O
f	int
==	O
-	O
1	int
)	O
return	O
bt	pointer
->	O
result	array
;	O
i	int
=	O
0	int
;	O
while	O
(	O
(	O
l	pointer
=	O
read	function
(	O
f	int
,	O
bt	pointer
->	O
result	array
+	O
i	int
,	O
sizeof	O
(	O
bt	pointer
->	O
result	array
)	O
-	O
i	int
)	O
)	O
>	O
0	int
)	O
{	O
debug1	O
(	O
"runbacktick: read %d bytes\n"	pointer
,	O
l	pointer
)	O
;	O
i	int
+=	O
l	pointer
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
l	pointer
;	O
j	int
++	O
)	O
if	O
(	O
bt	pointer
->	O
result	array
[	O
i	int
-	O
j	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
break	O
;	O
if	O
(	O
j	int
==	O
l	pointer
&&	O
i	int
==	O
sizeof	O
(	O
bt	pointer
->	O
result	array
)	O
)	O
{	O
j	int
=	O
sizeof	O
(	O
bt	pointer
->	O
result	array
)	O
/	O
2	int
;	O
l	pointer
=	O
j	int
+	O
1	int
;	O
}	O
if	O
(	O
j	int
<	O
l	pointer
)	O
{	O
bcopy	function
(	O
bt	pointer
->	O
result	array
+	O
i	int
-	O
j	int
,	O
bt	pointer
->	O
result	array
,	O
j	int
)	O
;	O
i	int
=	O
j	int
;	O
}	O
}	O
close	function
(	O
f	int
)	O
;	O
bt	pointer
->	O
result	array
[	O
sizeof	O
(	O
bt	pointer
->	O
result	array
)	O
-	O
1	int
]	O
=	O
'\n'	O
;	O
if	O
(	O
i	int
&&	O
bt	pointer
->	O
result	array
[	O
i	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
i	int
--	O
;	O
debug1	O
(	O
"runbacktick: finished, %d bytes\n"	pointer
,	O
i	int
)	O
;	O
bt	pointer
->	O
result	array
[	O
i	int
]	O
=	O
0	int
;	O
backtick_filter	function
(	O
bt	pointer
)	O
;	O
(	O
void	O
)	O
time	struct
(	O
&	O
now2	long
)	O
;	O
bt	pointer
->	O
bestbefore	long
=	O
now2	long
+	O
bt	pointer
->	O
lifespan	int
;	O
return	O
bt	pointer
->	O
result	array
;	O
}	O
int	O
AddWinMsgRend	function
(	O
const	O
char	O
*	O
str	pointer
,	O
int	O
r	int
)	O
{	O
if	O
(	O
winmsg_numrend	int
>=	O
MAX_WINMSG_REND	int
||	O
str	pointer
<	O
winmsg_buf	array
||	O
str	pointer
>=	O
winmsg_buf	array
+	O
MAXSTR	int
)	O
return	O
-	O
1	int
;	O
winmsg_rend	array
[	O
winmsg_numrend	int
]	O
=	O
r	int
;	O
winmsg_rendpos	array
[	O
winmsg_numrend	int
]	O
=	O
str	pointer
-	O
winmsg_buf	array
;	O
winmsg_numrend	int
++	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
MakeWinMsgEv	function
(	O
char	O
*	O
str	pointer
,	O
struct	O
win	struct
*	O
win	struct
,	O
int	O
esc	int
,	O
int	O
padlen	int
,	O
struct	O
event	struct
*	O
ev	struct
,	O
int	O
rec	int
)	O
{	O
static	O
int	O
tick	long
;	O
char	O
*	O
s	pointer
=	O
str	pointer
;	O
register	O
char	O
*	O
p	pointer
=	O
winmsg_buf	array
;	O
register	O
int	O
ctrl	int
;	O
struct	O
timeval	struct
now	long
;	O
struct	O
tm	struct
*	O
tm	struct
;	O
int	O
l	pointer
,	O
i	int
,	O
r	int
;	O
int	O
num	int
;	O
int	O
zeroflg	int
;	O
int	O
longflg	int
;	O
int	O
minusflg	int
;	O
int	O
plusflg	int
;	O
int	O
qmflag	int
=	O
0	int
,	O
omflag	int
=	O
0	int
,	O
qmnumrend	int
=	O
0	int
;	O
char	O
*	O
qmpos	pointer
=	O
0	int
;	O
int	O
numpad	int
=	O
0	int
;	O
int	O
lastpad	int
=	O
0	int
;	O
int	O
truncpos	int
=	O
-	O
1	int
;	O
int	O
truncper	int
=	O
0	int
;	O
int	O
trunclong	int
=	O
0	int
;	O
struct	O
backtick	struct
*	O
bt	pointer
=	O
NULL	O
;	O
if	O
(	O
winmsg_numrend	int
>=	O
0	int
)	O
winmsg_numrend	int
=	O
0	int
;	O
else	O
winmsg_numrend	int
=	O
-	O
winmsg_numrend	int
;	O
tick	long
=	O
0	int
;	O
tm	struct
=	O
0	int
;	O
ctrl	int
=	O
0	int
;	O
gettimeofday	function
(	O
&	O
now	long
,	O
NULL	O
)	O
;	O
for	O
(	O
;	O
*	O
s	pointer
&&	O
(	O
l	pointer
=	O
winmsg_buf	array
+	O
MAXSTR	int
-	O
1	int
-	O
p	pointer
)	O
>	O
0	int
;	O
s	pointer
++	O
,	O
p	pointer
++	O
)	O
{	O
*	O
p	pointer
=	O
*	O
s	pointer
;	O
if	O
(	O
ctrl	int
)	O
{	O
ctrl	int
=	O
0	int
;	O
if	O
(	O
*	O
s	pointer
!=	O
'^'	O
&&	O
*	O
s	pointer
>=	O
64	int
)	O
*	O
p	pointer
&=	O
0x1f	int
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
s	pointer
!=	O
esc	int
)	O
{	O
if	O
(	O
esc	int
==	O
'%'	O
)	O
{	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
'^'	O
:	O
ctrl	int
=	O
1	int
;	O
*	O
p	pointer
--	O
=	O
'^'	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
continue	O
;	O
}	O
if	O
(	O
*	O
++	O
s	pointer
==	O
esc	int
)	O
continue	O
;	O
if	O
(	O
(	O
plusflg	int
=	O
*	O
s	pointer
==	O
'+'	O
)	O
!=	O
0	int
)	O
s	pointer
++	O
;	O
if	O
(	O
(	O
minusflg	int
=	O
*	O
s	pointer
==	O
'-'	O
)	O
!=	O
0	int
)	O
s	pointer
++	O
;	O
if	O
(	O
(	O
zeroflg	int
=	O
*	O
s	pointer
==	O
'0'	O
)	O
!=	O
0	int
)	O
s	pointer
++	O
;	O
num	int
=	O
0	int
;	O
while	O
(	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'9'	O
)	O
num	int
=	O
num	int
*	O
10	int
+	O
(	O
*	O
s	pointer
++	O
-	O
'0'	O
)	O
;	O
if	O
(	O
(	O
longflg	int
=	O
*	O
s	pointer
==	O
'L'	O
)	O
!=	O
0	int
)	O
s	pointer
++	O
;	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
'?'	O
:	O
p	pointer
--	O
;	O
if	O
(	O
qmpos	pointer
)	O
{	O
if	O
(	O
(	O
!	O
qmflag	int
&&	O
!	O
omflag	int
)	O
||	O
omflag	int
==	O
1	int
)	O
{	O
p	pointer
=	O
qmpos	pointer
;	O
if	O
(	O
qmnumrend	int
<	O
winmsg_numrend	int
)	O
winmsg_numrend	int
=	O
qmnumrend	int
;	O
}	O
qmpos	pointer
=	O
0	int
;	O
break	O
;	O
}	O
qmpos	pointer
=	O
p	pointer
;	O
qmnumrend	int
=	O
winmsg_numrend	int
;	O
qmflag	int
=	O
omflag	int
=	O
0	int
;	O
break	O
;	O
case	O
':'	O
:	O
p	pointer
--	O
;	O
if	O
(	O
!	O
qmpos	pointer
)	O
break	O
;	O
if	O
(	O
qmflag	int
&&	O
omflag	int
!=	O
1	int
)	O
{	O
omflag	int
=	O
1	int
;	O
qmpos	pointer
=	O
p	pointer
;	O
qmnumrend	int
=	O
winmsg_numrend	int
;	O
}	O
else	O
{	O
p	pointer
=	O
qmpos	pointer
;	O
if	O
(	O
qmnumrend	int
<	O
winmsg_numrend	int
)	O
winmsg_numrend	int
=	O
qmnumrend	int
;	O
omflag	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'D'	O
:	O
case	O
'm'	O
:	O
case	O
'M'	O
:	O
case	O
'y'	O
:	O
case	O
'Y'	O
:	O
case	O
'a'	O
:	O
case	O
'A'	O
:	O
case	O
's'	O
:	O
case	O
'c'	O
:	O
case	O
'C'	O
:	O
if	O
(	O
l	pointer
<	O
4	int
)	O
break	O
;	O
if	O
(	O
tm	struct
==	O
0	int
)	O
{	O
time_t	long
nowsec	long
=	O
now	long
.	O
tv_sec	long
;	O
tm	struct
=	O
localtime	function
(	O
&	O
nowsec	long
)	O
;	O
}	O
qmflag	int
=	O
1	int
;	O
if	O
(	O
!	O
tick	long
||	O
tick	long
>	O
3600	int
)	O
tick	long
=	O
3600	int
;	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
'd'	O
:	O
sprintf	function
(	O
p	pointer
,	O
"%02d"	pointer
,	O
tm	struct
->	O
tm_mday	int
%	O
100	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
strftime	function
(	O
p	pointer
,	O
l	pointer
,	O
(	O
longflg	int
?	O
"%A"	pointer
:	O
"%a"	pointer
)	O
,	O
tm	struct
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
sprintf	function
(	O
p	pointer
,	O
"%02d"	pointer
,	O
tm	struct
->	O
tm_mon	int
+	O
1	int
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
strftime	function
(	O
p	pointer
,	O
l	pointer
,	O
(	O
longflg	int
?	O
"%B"	pointer
:	O
"%b"	pointer
)	O
,	O
tm	struct
)	O
;	O
break	O
;	O
case	O
'y'	O
:	O
sprintf	function
(	O
p	pointer
,	O
"%02d"	pointer
,	O
tm	struct
->	O
tm_year	int
%	O
100	int
)	O
;	O
break	O
;	O
case	O
'Y'	O
:	O
sprintf	function
(	O
p	pointer
,	O
"%04d"	pointer
,	O
tm	struct
->	O
tm_year	int
+	O
1900	int
)	O
;	O
break	O
;	O
case	O
'a'	O
:	O
sprintf	function
(	O
p	pointer
,	O
tm	struct
->	O
tm_hour	int
>=	O
12	int
?	O
"pm"	pointer
:	O
"am"	pointer
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
sprintf	function
(	O
p	pointer
,	O
tm	struct
->	O
tm_hour	int
>=	O
12	int
?	O
"PM"	pointer
:	O
"AM"	pointer
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
sprintf	function
(	O
p	pointer
,	O
"%02d"	pointer
,	O
tm	struct
->	O
tm_sec	int
)	O
;	O
tick	long
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
sprintf	function
(	O
p	pointer
,	O
zeroflg	int
?	O
"%02d:%02d"	pointer
:	O
"%2d:%02d"	pointer
,	O
tm	struct
->	O
tm_hour	int
,	O
tm	struct
->	O
tm_min	int
)	O
;	O
if	O
(	O
!	O
tick	long
||	O
tick	long
>	O
60	int
)	O
tick	long
=	O
60	int
;	O
break	O
;	O
case	O
'C'	O
:	O
sprintf	function
(	O
p	pointer
,	O
zeroflg	int
?	O
"%02d:%02d"	pointer
:	O
"%2d:%02d"	pointer
,	O
(	O
tm	struct
->	O
tm_hour	int
+	O
11	int
)	O
%	O
12	int
+	O
1	int
,	O
tm	struct
->	O
tm_min	int
)	O
;	O
if	O
(	O
!	O
tick	long
||	O
tick	long
>	O
60	int
)	O
tick	long
=	O
60	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
break	O
;	O
case	O
'X'	O
:	O
case	O
'x'	O
:	O
*	O
p	pointer
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
win	struct
&&	O
win	struct
->	O
w_cmdargs	array
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
l	pointer
<	O
strlen	function
(	O
win	struct
->	O
w_cmdargs	array
[	O
i	int
]	O
)	O
+	O
1	int
)	O
break	O
;	O
sprintf	function
(	O
p	pointer
,	O
i	int
?	O
" %s"	pointer
:	O
"%s"	pointer
,	O
win	struct
->	O
w_cmdargs	array
[	O
i	int
]	O
)	O
;	O
l	pointer
-=	O
strlen	function
(	O
p	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
i	int
==	O
0	int
&&	O
*	O
s	pointer
==	O
'X'	O
)	O
break	O
;	O
}	O
p	pointer
--	O
;	O
break	O
;	O
case	O
'l'	O
:	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
l	pointer
>	O
20	int
)	O
AddLoadav	function
(	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
qmflag	int
=	O
1	int
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
}	O
else	O
*	O
p	pointer
=	O
'?'	O
;	O
if	O
(	O
!	O
tick	long
||	O
tick	long
>	O
60	int
)	O
tick	long
=	O
60	int
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
break	O
;	O
case	O
'`'	O
:	O
case	O
'h'	O
:	O
if	O
(	O
rec	int
>=	O
10	int
||	O
(	O
*	O
s	pointer
==	O
'h'	O
&&	O
(	O
win	struct
==	O
0	int
||	O
win	struct
->	O
w_hstatus	pointer
==	O
0	int
||	O
*	O
win	struct
->	O
w_hstatus	pointer
==	O
0	int
)	O
)	O
)	O
{	O
p	pointer
--	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
s	pointer
==	O
'`'	O
)	O
{	O
for	O
(	O
bt	pointer
=	O
backticks	pointer
;	O
bt	pointer
;	O
bt	pointer
=	O
bt	pointer
->	O
next	pointer
)	O
if	O
(	O
bt	pointer
->	O
num	int
==	O
num	int
)	O
break	O
;	O
if	O
(	O
bt	pointer
==	O
0	int
)	O
{	O
p	pointer
--	O
;	O
break	O
;	O
}	O
}	O
{	O
char	O
savebuf	array
[	O
sizeof	O
(	O
winmsg_buf	array
)	O
]	O
;	O
int	O
oldtick	int
=	O
tick	long
;	O
int	O
oldnumrend	int
=	O
winmsg_numrend	int
;	O
*	O
p	pointer
=	O
0	int
;	O
strcpy	function
(	O
savebuf	array
,	O
winmsg_buf	array
)	O
;	O
winmsg_numrend	int
=	O
-	O
winmsg_numrend	int
;	O
MakeWinMsgEv	function
(	O
*	O
s	pointer
==	O
'h'	O
?	O
win	struct
->	O
w_hstatus	pointer
:	O
runbacktick	function
(	O
bt	pointer
,	O
&	O
oldtick	int
,	O
now	long
.	O
tv_sec	long
)	O
,	O
win	struct
,	O
'\005'	O
,	O
0	int
,	O
(	O
struct	O
event	struct
*	O
)	O
0	int
,	O
rec	int
+	O
1	int
)	O
;	O
debug2	O
(	O
"oldtick=%d tick=%d\n"	pointer
,	O
oldtick	int
,	O
tick	long
)	O
;	O
if	O
(	O
!	O
tick	long
||	O
oldtick	int
<	O
tick	long
)	O
tick	long
=	O
oldtick	int
;	O
if	O
(	O
(	O
int	O
)	O
strlen	function
(	O
winmsg_buf	array
)	O
<	O
l	pointer
)	O
strcat	function
(	O
savebuf	array
,	O
winmsg_buf	array
)	O
;	O
strcpy	function
(	O
winmsg_buf	array
,	O
savebuf	array
)	O
;	O
while	O
(	O
oldnumrend	int
<	O
winmsg_numrend	int
)	O
winmsg_rendpos	array
[	O
oldnumrend	int
++	O
]	O
+=	O
p	pointer
-	O
winmsg_buf	array
;	O
if	O
(	O
*	O
p	pointer
)	O
qmflag	int
=	O
1	int
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
'w'	O
:	O
case	O
'W'	O
:	O
{	O
struct	O
win	struct
*	O
oldfore	pointer
=	O
0	int
;	O
char	O
*	O
ss	pointer
;	O
if	O
(	O
display	struct
)	O
{	O
oldfore	pointer
=	O
D_fore	O
;	O
D_fore	O
=	O
win	struct
;	O
}	O
ss	pointer
=	O
AddWindows	function
(	O
p	pointer
,	O
l	pointer
-	O
1	int
,	O
(	O
*	O
s	pointer
==	O
'w'	O
?	O
0	int
:	O
1	int
)	O
|	O
(	O
longflg	int
?	O
0	int
:	O
2	int
)	O
|	O
(	O
plusflg	int
?	O
4	int
:	O
0	int
)	O
|	O
(	O
minusflg	int
?	O
8	int
:	O
0	int
)	O
,	O
win	struct
?	O
win	struct
->	O
w_number	int
:	O
-	O
1	int
)	O
;	O
if	O
(	O
display	struct
)	O
D_fore	O
=	O
oldfore	pointer
;	O
}	O
if	O
(	O
*	O
p	pointer
)	O
qmflag	int
=	O
1	int
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
break	O
;	O
case	O
'u'	O
:	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
win	struct
)	O
AddOtherUsers	function
(	O
p	pointer
,	O
l	pointer
-	O
1	int
,	O
win	struct
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
qmflag	int
=	O
1	int
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
break	O
;	O
case	O
'f'	O
:	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
win	struct
)	O
AddWindowFlags	function
(	O
p	pointer
,	O
l	pointer
-	O
1	int
,	O
win	struct
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
qmflag	int
=	O
1	int
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
win	struct
&&	O
(	O
int	O
)	O
strlen	function
(	O
win	struct
->	O
w_title	pointer
)	O
<	O
l	pointer
)	O
{	O
strcpy	function
(	O
p	pointer
,	O
win	struct
->	O
w_title	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
qmflag	int
=	O
1	int
;	O
}	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
break	O
;	O
case	O
'{'	O
:	O
{	O
char	O
rbuf	array
[	O
128	int
]	O
;	O
s	pointer
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
127	int
;	O
i	int
++	O
)	O
if	O
(	O
s	pointer
[	O
i	int
]	O
&&	O
s	pointer
[	O
i	int
]	O
!=	O
'}'	O
)	O
rbuf	array
[	O
i	int
]	O
=	O
s	pointer
[	O
i	int
]	O
;	O
else	O
break	O
;	O
if	O
(	O
s	pointer
[	O
i	int
]	O
==	O
'}'	O
&&	O
winmsg_numrend	int
<	O
MAX_WINMSG_REND	int
)	O
{	O
r	int
=	O
-	O
1	int
;	O
rbuf	array
[	O
i	int
]	O
=	O
0	int
;	O
debug1	O
(	O
"MakeWinMsg attrcolor %s\n"	pointer
,	O
rbuf	array
)	O
;	O
if	O
(	O
i	int
!=	O
1	int
||	O
rbuf	array
[	O
0	int
]	O
!=	O
'-'	O
)	O
r	int
=	O
ParseAttrColor	function
(	O
rbuf	array
,	O
(	O
char	O
*	O
)	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
r	int
!=	O
-	O
1	int
||	O
(	O
i	int
==	O
1	int
&&	O
rbuf	array
[	O
0	int
]	O
==	O
'-'	O
)	O
)	O
{	O
winmsg_rend	array
[	O
winmsg_numrend	int
]	O
=	O
r	int
;	O
winmsg_rendpos	array
[	O
winmsg_numrend	int
]	O
=	O
p	pointer
-	O
winmsg_buf	array
;	O
winmsg_numrend	int
++	O
;	O
}	O
}	O
s	pointer
+=	O
i	int
;	O
p	pointer
--	O
;	O
}	O
break	O
;	O
case	O
'H'	O
:	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
(	O
int	O
)	O
strlen	function
(	O
HostName	array
)	O
<	O
l	pointer
)	O
{	O
strcpy	function
(	O
p	pointer
,	O
HostName	array
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
qmflag	int
=	O
1	int
;	O
}	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
{	O
char	O
*	O
session_name	pointer
;	O
*	O
p	pointer
=	O
0	int
;	O
session_name	pointer
=	O
strchr	function
(	O
SockName	pointer
,	O
'.'	O
)	O
+	O
1	int
;	O
if	O
(	O
(	O
int	O
)	O
strlen	function
(	O
session_name	pointer
)	O
<	O
l	pointer
)	O
{	O
strcpy	function
(	O
p	pointer
,	O
session_name	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
qmflag	int
=	O
1	int
;	O
}	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
'p'	O
:	O
{	O
sprintf	function
(	O
p	pointer
,	O
"%d"	pointer
,	O
(	O
plusflg	int
&&	O
display	struct
)	O
?	O
D_userpid	O
:	O
getpid	function
(	O
)	O
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
'F'	O
:	O
p	pointer
--	O
;	O
if	O
(	O
display	struct
&&	O
(	O
(	O
ev	struct
&&	O
ev	struct
==	O
&	O
D_forecv	O
->	O
c_captev	struct
)	O
||	O
(	O
!	O
ev	struct
&&	O
win	struct
&&	O
win	struct
==	O
D_fore	O
)	O
)	O
)	O
minusflg	int
=	O
!	O
minusflg	int
;	O
if	O
(	O
minusflg	int
)	O
qmflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'P'	O
:	O
p	pointer
--	O
;	O
if	O
(	O
display	struct
&&	O
ev	struct
&&	O
ev	struct
!=	O
&	O
D_hstatusev	O
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
=	O
(	O
struct	O
canvas	struct
*	O
)	O
ev	struct
->	O
data	pointer
;	O
if	O
(	O
ev	struct
==	O
&	O
cv	pointer
->	O
c_captev	struct
&&	O
cv	pointer
->	O
c_layer	pointer
->	O
l_layfn	pointer
==	O
&	O
MarkLf	struct
)	O
qmflag	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
'E'	O
:	O
p	pointer
--	O
;	O
if	O
(	O
display	struct
&&	O
D_ESCseen	O
)	O
qmflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'>'	O
:	O
truncpos	int
=	O
p	pointer
-	O
winmsg_buf	array
;	O
truncper	int
=	O
num	int
>	O
100	int
?	O
100	int
:	O
num	int
;	O
trunclong	int
=	O
longflg	int
;	O
p	pointer
--	O
;	O
break	O
;	O
case	O
'='	O
:	O
case	O
'<'	O
:	O
*	O
p	pointer
=	O
' '	O
;	O
if	O
(	O
num	int
||	O
zeroflg	int
||	O
plusflg	int
||	O
longflg	int
||	O
(	O
*	O
s	pointer
!=	O
'='	O
)	O
)	O
{	O
if	O
(	O
minusflg	int
)	O
{	O
num	int
=	O
(	O
plusflg	int
?	O
lastpad	int
:	O
padlen	int
)	O
-	O
num	int
;	O
if	O
(	O
!	O
plusflg	int
&&	O
padlen	int
==	O
0	int
)	O
num	int
=	O
p	pointer
-	O
winmsg_buf	array
;	O
plusflg	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
zeroflg	int
)	O
{	O
if	O
(	O
*	O
s	pointer
!=	O
'='	O
&&	O
num	int
==	O
0	int
&&	O
!	O
plusflg	int
)	O
num	int
=	O
100	int
;	O
if	O
(	O
num	int
>	O
100	int
)	O
num	int
=	O
100	int
;	O
if	O
(	O
padlen	int
==	O
0	int
)	O
num	int
=	O
p	pointer
-	O
winmsg_buf	array
;	O
else	O
num	int
=	O
(	O
padlen	int
-	O
(	O
plusflg	int
?	O
lastpad	int
:	O
0	int
)	O
)	O
*	O
num	int
/	O
100	int
;	O
}	O
if	O
(	O
num	int
<	O
0	int
)	O
num	int
=	O
0	int
;	O
if	O
(	O
plusflg	int
)	O
num	int
+=	O
lastpad	int
;	O
if	O
(	O
num	int
>	O
MAXSTR	int
-	O
1	int
)	O
num	int
=	O
MAXSTR	int
-	O
1	int
;	O
if	O
(	O
numpad	int
)	O
p	pointer
=	O
pad_expand	function
(	O
winmsg_buf	array
,	O
p	pointer
,	O
numpad	int
,	O
num	int
)	O
;	O
numpad	int
=	O
0	int
;	O
if	O
(	O
p	pointer
-	O
winmsg_buf	array
>	O
num	int
&&	O
!	O
longflg	int
)	O
{	O
int	O
left	pointer
,	O
trunc	int
;	O
if	O
(	O
truncpos	int
==	O
-	O
1	int
)	O
{	O
truncpos	int
=	O
lastpad	int
;	O
truncper	int
=	O
0	int
;	O
}	O
trunc	int
=	O
lastpad	int
+	O
truncper	int
*	O
(	O
num	int
-	O
lastpad	int
)	O
/	O
100	int
;	O
if	O
(	O
trunc	int
>	O
num	int
)	O
trunc	int
=	O
num	int
;	O
if	O
(	O
trunc	int
<	O
lastpad	int
)	O
trunc	int
=	O
lastpad	int
;	O
left	pointer
=	O
truncpos	int
-	O
trunc	int
;	O
if	O
(	O
left	pointer
>	O
p	pointer
-	O
winmsg_buf	array
-	O
num	int
)	O
left	pointer
=	O
p	pointer
-	O
winmsg_buf	array
-	O
num	int
;	O
debug1	O
(	O
"lastpad = %d, "	pointer
,	O
lastpad	int
)	O
;	O
debug3	O
(	O
"truncpos = %d, trunc = %d, left = %d\n"	pointer
,	O
truncpos	int
,	O
trunc	int
,	O
left	pointer
)	O
;	O
if	O
(	O
left	pointer
>	O
0	int
)	O
{	O
if	O
(	O
left	pointer
+	O
lastpad	int
>	O
p	pointer
-	O
winmsg_buf	array
)	O
left	pointer
=	O
p	pointer
-	O
winmsg_buf	array
-	O
lastpad	int
;	O
if	O
(	O
p	pointer
-	O
winmsg_buf	array
-	O
lastpad	int
-	O
left	pointer
>	O
0	int
)	O
bcopy	function
(	O
winmsg_buf	array
+	O
lastpad	int
+	O
left	pointer
,	O
winmsg_buf	array
+	O
lastpad	int
,	O
p	pointer
-	O
winmsg_buf	array
-	O
lastpad	int
-	O
left	pointer
)	O
;	O
p	pointer
-=	O
left	pointer
;	O
r	int
=	O
winmsg_numrend	int
;	O
while	O
(	O
r	int
&&	O
winmsg_rendpos	array
[	O
r	int
-	O
1	int
]	O
>	O
lastpad	int
)	O
{	O
r	int
--	O
;	O
winmsg_rendpos	array
[	O
r	int
]	O
-=	O
left	pointer
;	O
if	O
(	O
winmsg_rendpos	array
[	O
r	int
]	O
<	O
lastpad	int
)	O
winmsg_rendpos	array
[	O
r	int
]	O
=	O
lastpad	int
;	O
}	O
if	O
(	O
trunclong	int
)	O
{	O
if	O
(	O
p	pointer
-	O
winmsg_buf	array
>	O
lastpad	int
)	O
winmsg_buf	array
[	O
lastpad	int
]	O
=	O
'.'	O
;	O
if	O
(	O
p	pointer
-	O
winmsg_buf	array
>	O
lastpad	int
+	O
1	int
)	O
winmsg_buf	array
[	O
lastpad	int
+	O
1	int
]	O
=	O
'.'	O
;	O
if	O
(	O
p	pointer
-	O
winmsg_buf	array
>	O
lastpad	int
+	O
2	int
)	O
winmsg_buf	array
[	O
lastpad	int
+	O
2	int
]	O
=	O
'.'	O
;	O
}	O
}	O
if	O
(	O
p	pointer
-	O
winmsg_buf	array
>	O
num	int
)	O
{	O
p	pointer
=	O
winmsg_buf	array
+	O
num	int
;	O
if	O
(	O
trunclong	int
)	O
{	O
if	O
(	O
num	int
-	O
1	int
>=	O
lastpad	int
)	O
p	pointer
[	O
-	O
1	int
]	O
=	O
'.'	O
;	O
if	O
(	O
num	int
-	O
2	int
>=	O
lastpad	int
)	O
p	pointer
[	O
-	O
2	int
]	O
=	O
'.'	O
;	O
if	O
(	O
num	int
-	O
3	int
>=	O
lastpad	int
)	O
p	pointer
[	O
-	O
3	int
]	O
=	O
'.'	O
;	O
}	O
r	int
=	O
winmsg_numrend	int
;	O
while	O
(	O
r	int
&&	O
winmsg_rendpos	array
[	O
r	int
-	O
1	int
]	O
>	O
num	int
)	O
winmsg_rendpos	array
[	O
--	O
r	int
]	O
=	O
num	int
;	O
}	O
truncpos	int
=	O
-	O
1	int
;	O
trunclong	int
=	O
0	int
;	O
if	O
(	O
lastpad	int
>	O
p	pointer
-	O
winmsg_buf	array
)	O
lastpad	int
=	O
p	pointer
-	O
winmsg_buf	array
;	O
debug1	O
(	O
"lastpad now %d\n"	pointer
,	O
lastpad	int
)	O
;	O
}	O
if	O
(	O
*	O
s	pointer
==	O
'='	O
)	O
{	O
while	O
(	O
p	pointer
-	O
winmsg_buf	array
<	O
num	int
)	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
lastpad	int
=	O
p	pointer
-	O
winmsg_buf	array
;	O
truncpos	int
=	O
-	O
1	int
;	O
trunclong	int
=	O
0	int
;	O
debug1	O
(	O
"lastpad2 now %d\n"	pointer
,	O
lastpad	int
)	O
;	O
}	O
p	pointer
--	O
;	O
}	O
else	O
if	O
(	O
padlen	int
)	O
{	O
*	O
p	pointer
=	O
127	int
;	O
numpad	int
++	O
;	O
}	O
break	O
;	O
case	O
'n'	O
:	O
s	pointer
++	O
;	O
default	O
:	O
s	pointer
--	O
;	O
if	O
(	O
l	pointer
>	O
10	int
+	O
num	int
)	O
{	O
if	O
(	O
num	int
==	O
0	int
)	O
num	int
=	O
1	int
;	O
if	O
(	O
!	O
win	struct
)	O
sprintf	function
(	O
p	pointer
,	O
"%*s"	pointer
,	O
num	int
,	O
num	int
>	O
1	int
?	O
"--"	pointer
:	O
"-"	pointer
)	O
;	O
else	O
sprintf	function
(	O
p	pointer
,	O
"%*d"	pointer
,	O
num	int
,	O
win	struct
->	O
w_number	int
)	O
;	O
qmflag	int
=	O
1	int
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
qmpos	pointer
&&	O
!	O
qmflag	int
)	O
p	pointer
=	O
qmpos	pointer
+	O
1	int
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
if	O
(	O
numpad	int
)	O
{	O
if	O
(	O
padlen	int
>	O
MAXSTR	int
-	O
1	int
)	O
padlen	int
=	O
MAXSTR	int
-	O
1	int
;	O
p	pointer
=	O
pad_expand	function
(	O
winmsg_buf	array
,	O
p	pointer
,	O
numpad	int
,	O
padlen	int
)	O
;	O
}	O
if	O
(	O
ev	struct
)	O
{	O
evdeq	function
(	O
ev	struct
)	O
;	O
ev	struct
->	O
timeout	struct
.	O
tv_sec	long
=	O
0	int
;	O
ev	struct
->	O
timeout	struct
.	O
tv_usec	long
=	O
0	int
;	O
}	O
if	O
(	O
ev	struct
&&	O
tick	long
)	O
{	O
now	long
.	O
tv_usec	long
=	O
100000	int
;	O
if	O
(	O
tick	long
==	O
1	int
)	O
now	long
.	O
tv_sec	long
++	O
;	O
else	O
now	long
.	O
tv_sec	long
+=	O
tick	long
-	O
(	O
now	long
.	O
tv_sec	long
%	O
tick	long
)	O
;	O
ev	struct
->	O
timeout	struct
=	O
now	long
;	O
debug2	O
(	O
"NEW timeout %d %d\n"	pointer
,	O
ev	struct
->	O
timeout	struct
.	O
tv_sec	long
,	O
tick	long
)	O
;	O
}	O
return	O
winmsg_buf	array
;	O
}	O
char	O
*	O
MakeWinMsg	function
(	O
char	O
*	O
s	pointer
,	O
struct	O
win	struct
*	O
win	struct
,	O
int	O
esc	int
)	O
{	O
return	O
MakeWinMsgEv	function
(	O
s	pointer
,	O
win	struct
,	O
esc	int
,	O
0	int
,	O
(	O
struct	O
event	struct
*	O
)	O
0	int
,	O
0	int
)	O
;	O
}	O
void	O
PutWinMsg	function
(	O
char	O
*	O
s	pointer
,	O
int	O
start	int
,	O
int	O
max	int
)	O
{	O
int	O
i	int
,	O
p	pointer
,	O
l	pointer
,	O
r	int
,	O
n	int
;	O
struct	O
mchar	struct
rend	struct
;	O
struct	O
mchar	struct
rendstack	array
[	O
MAX_WINMSG_REND	int
]	O
;	O
int	O
rendstackn	int
=	O
0	int
;	O
if	O
(	O
s	pointer
!=	O
winmsg_buf	array
)	O
{	O
debug1	O
(	O
"PutWinMsg %s plain\n"	pointer
,	O
s	pointer
)	O
;	O
l	pointer
=	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
l	pointer
>	O
max	int
)	O
l	pointer
=	O
max	int
;	O
l	pointer
-=	O
start	int
;	O
s	pointer
+=	O
start	int
;	O
while	O
(	O
l	pointer
--	O
>	O
0	int
)	O
PUTCHARLP	function
(	O
*	O
s	pointer
++	O
)	O
;	O
return	O
;	O
}	O
rend	struct
=	O
D_rend	O
;	O
p	pointer
=	O
0	int
;	O
l	pointer
=	O
strlen	function
(	O
s	pointer
)	O
;	O
debug2	O
(	O
"PutWinMsg %s start attr %x\n"	pointer
,	O
s	pointer
,	O
rend	struct
.	O
attr	char
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
winmsg_numrend	int
&&	O
max	int
>	O
0	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
p	pointer
>	O
winmsg_rendpos	array
[	O
i	int
]	O
||	O
winmsg_rendpos	array
[	O
i	int
]	O
>	O
l	pointer
)	O
break	O
;	O
if	O
(	O
p	pointer
<	O
winmsg_rendpos	array
[	O
i	int
]	O
)	O
{	O
n	int
=	O
winmsg_rendpos	array
[	O
i	int
]	O
-	O
p	pointer
;	O
if	O
(	O
n	int
>	O
max	int
)	O
n	int
=	O
max	int
;	O
max	int
-=	O
n	int
;	O
p	pointer
+=	O
n	int
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
{	O
if	O
(	O
start	int
--	O
>	O
0	int
)	O
s	pointer
++	O
;	O
else	O
PUTCHARLP	function
(	O
*	O
s	pointer
++	O
)	O
;	O
}	O
}	O
r	int
=	O
winmsg_rend	array
[	O
i	int
]	O
;	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
rendstackn	int
>	O
0	int
)	O
rend	struct
=	O
rendstack	array
[	O
--	O
rendstackn	int
]	O
;	O
}	O
else	O
{	O
rendstack	array
[	O
rendstackn	int
++	O
]	O
=	O
rend	struct
;	O
ApplyAttrColor	function
(	O
r	int
,	O
&	O
rend	struct
)	O
;	O
}	O
SetRendition	function
(	O
&	O
rend	struct
)	O
;	O
}	O
if	O
(	O
p	pointer
<	O
l	pointer
)	O
{	O
n	int
=	O
l	pointer
-	O
p	pointer
;	O
if	O
(	O
n	int
>	O
max	int
)	O
n	int
=	O
max	int
;	O
while	O
(	O
n	int
--	O
>	O
0	int
)	O
{	O
if	O
(	O
start	int
--	O
>	O
0	int
)	O
s	pointer
++	O
;	O
else	O
PUTCHARLP	function
(	O
*	O
s	pointer
++	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
serv_read_fn	function
(	O
struct	O
event	struct
*	O
ev	struct
,	O
char	O
*	O
data	pointer
)	O
{	O
debug	O
(	O
"Knock - knock!\n"	pointer
)	O
;	O
ReceiveMsg	function
(	O
)	O
;	O
}	O
static	O
void	O
serv_select_fn	function
(	O
struct	O
event	struct
*	O
ev	struct
,	O
char	O
*	O
data	pointer
)	O
{	O
struct	O
win	struct
*	O
p	pointer
;	O
debug	O
(	O
"serv_select_fn called\n"	pointer
)	O
;	O
if	O
(	O
GotSigChld	int
)	O
SigChldHandler	function
(	O
)	O
;	O
if	O
(	O
InterruptPlease	int
)	O
{	O
debug	O
(	O
"Backend received interrupt\n"	pointer
)	O
;	O
if	O
(	O
fore	pointer
&&	O
displays	pointer
)	O
{	O
char	O
ibuf	char
=	O
displays	pointer
->	O
d_OldMode	struct
.	O
tio	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
;	O
write	function
(	O
W_UWP	O
(	O
fore	pointer
)	O
?	O
fore	pointer
->	O
w_pwin	pointer
->	O
p_ptyfd	int
:	O
fore	pointer
->	O
w_ptyfd	int
,	O
&	O
ibuf	char
,	O
1	int
)	O
;	O
debug1	O
(	O
"Backend wrote interrupt to %d"	pointer
,	O
fore	pointer
->	O
w_number	int
)	O
;	O
debug1	O
(	O
"%s\n"	pointer
,	O
W_UWP	O
(	O
fore	pointer
)	O
?	O
" (pseudowin)"	pointer
:	O
""	pointer
)	O
;	O
}	O
InterruptPlease	int
=	O
0	int
;	O
}	O
for	O
(	O
p	pointer
=	O
windows	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
w_next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
w_bell	int
==	O
BELL_FOUND	int
||	O
p	pointer
->	O
w_bell	int
==	O
BELL_VISUAL	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
int	O
visual	int
=	O
p	pointer
->	O
w_bell	int
==	O
BELL_VISUAL	int
||	O
visual_bell	int
;	O
p	pointer
->	O
w_bell	int
=	O
BELL_ON	int
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
if	O
(	O
cv	pointer
->	O
c_layer	pointer
->	O
l_bottom	pointer
==	O
&	O
p	pointer
->	O
w_layer	struct
)	O
break	O
;	O
if	O
(	O
cv	pointer
==	O
0	int
)	O
{	O
p	pointer
->	O
w_bell	int
=	O
BELL_DONE	int
;	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
MakeWinMsg	function
(	O
BellString	pointer
,	O
p	pointer
,	O
'%'	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
visual	int
&&	O
!	O
D_VB	O
&&	O
(	O
!	O
D_status	O
||	O
!	O
D_status_bell	O
)	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
VisualBellString	pointer
)	O
;	O
if	O
(	O
D_status	O
)	O
{	O
D_status_bell	O
=	O
1	int
;	O
debug1	O
(	O
"using vbell timeout %d\n"	pointer
,	O
VBellWait	int
)	O
;	O
SetTimeout	function
(	O
&	O
D_statusev	O
,	O
VBellWait	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
p	pointer
->	O
w_monitor	int
==	O
MON_FOUND	int
)	O
p	pointer
->	O
w_monitor	int
=	O
MON_DONE	int
;	O
WindowChanged	function
(	O
p	pointer
,	O
'f'	O
)	O
;	O
}	O
if	O
(	O
p	pointer
->	O
w_monitor	int
==	O
MON_FOUND	int
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
p	pointer
->	O
w_monitor	int
=	O
MON_ON	int
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
if	O
(	O
cv	pointer
->	O
c_layer	pointer
->	O
l_bottom	pointer
==	O
&	O
p	pointer
->	O
w_layer	struct
)	O
break	O
;	O
if	O
(	O
cv	pointer
)	O
continue	O
;	O
if	O
(	O
!	O
(	O
ACLBYTE	O
(	O
p	pointer
->	O
w_mon_notify	pointer
,	O
D_user	O
->	O
u_id	int
)	O
&	O
ACLBIT	O
(	O
D_user	O
->	O
u_id	int
)	O
)	O
)	O
continue	O
;	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
MakeWinMsg	function
(	O
ActivityString	pointer
,	O
p	pointer
,	O
'%'	O
)	O
)	O
;	O
p	pointer
->	O
w_monitor	int
=	O
MON_DONE	int
;	O
}	O
WindowChanged	function
(	O
p	pointer
,	O
'f'	O
)	O
;	O
}	O
if	O
(	O
p	pointer
->	O
w_silence	int
==	O
SILENCE_FOUND	int
)	O
{	O
if	O
(	O
p	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
)	O
{	O
p	pointer
->	O
w_silence	int
=	O
SILENCE_ON	int
;	O
WindowChanged	function
(	O
p	pointer
,	O
'f'	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
if	O
(	O
D_status	O
==	O
STATUS_ON_WIN	int
)	O
continue	O
;	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
int	O
lx	int
,	O
ly	int
;	O
lx	int
=	O
cv	pointer
->	O
c_layer	pointer
->	O
l_x	int
;	O
ly	int
=	O
cv	pointer
->	O
c_layer	pointer
->	O
l_y	int
;	O
if	O
(	O
lx	int
==	O
cv	pointer
->	O
c_layer	pointer
->	O
l_width	int
)	O
lx	int
--	O
;	O
if	O
(	O
ly	int
+	O
cv	pointer
->	O
c_yoff	int
<	O
cv	pointer
->	O
c_ys	int
)	O
{	O
int	O
i	int
,	O
n	int
=	O
cv	pointer
->	O
c_ys	int
-	O
(	O
ly	int
+	O
cv	pointer
->	O
c_yoff	int
)	O
;	O
cv	pointer
->	O
c_yoff	int
=	O
cv	pointer
->	O
c_ys	int
-	O
ly	int
;	O
RethinkViewportOffsets	function
(	O
cv	pointer
)	O
;	O
if	O
(	O
n	int
>	O
cv	pointer
->	O
c_layer	pointer
->	O
l_height	int
)	O
n	int
=	O
cv	pointer
->	O
c_layer	pointer
->	O
l_height	int
;	O
CV_CALL	O
(	O
cv	pointer
,	O
LScrollV	function
(	O
flayer	pointer
,	O
-	O
n	int
,	O
0	int
,	O
flayer	pointer
->	O
l_height	int
-	O
1	int
,	O
0	int
)	O
;	O
LayRedisplayLine	O
(	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
LayRedisplayLine	O
(	O
i	int
,	O
0	int
,	O
flayer	pointer
->	O
l_width	int
-	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
cv	pointer
==	O
cv	pointer
->	O
c_display	pointer
->	O
d_forecv	pointer
)	O
LaySetCursor	O
(	O
)	O
;	O
)	O
;	O
}	O
else	O
if	O
(	O
ly	int
+	O
cv	pointer
->	O
c_yoff	int
>	O
cv	pointer
->	O
c_ye	int
)	O
{	O
int	O
i	int
,	O
n	int
=	O
ly	int
+	O
cv	pointer
->	O
c_yoff	int
-	O
cv	pointer
->	O
c_ye	int
;	O
cv	pointer
->	O
c_yoff	int
=	O
cv	pointer
->	O
c_ye	int
-	O
ly	int
;	O
RethinkViewportOffsets	function
(	O
cv	pointer
)	O
;	O
if	O
(	O
n	int
>	O
cv	pointer
->	O
c_layer	pointer
->	O
l_height	int
)	O
n	int
=	O
cv	pointer
->	O
c_layer	pointer
->	O
l_height	int
;	O
CV_CALL	O
(	O
cv	pointer
,	O
LScrollV	function
(	O
flayer	pointer
,	O
n	int
,	O
0	int
,	O
cv	pointer
->	O
c_layer	pointer
->	O
l_height	int
-	O
1	int
,	O
0	int
)	O
;	O
LayRedisplayLine	O
(	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
LayRedisplayLine	O
(	O
i	int
+	O
flayer	pointer
->	O
l_height	int
-	O
n	int
,	O
0	int
,	O
flayer	pointer
->	O
l_width	int
-	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
cv	pointer
==	O
cv	pointer
->	O
c_display	pointer
->	O
d_forecv	pointer
)	O
LaySetCursor	O
(	O
)	O
;	O
)	O
;	O
}	O
if	O
(	O
lx	int
+	O
cv	pointer
->	O
c_xoff	int
<	O
cv	pointer
->	O
c_xs	int
)	O
{	O
int	O
i	int
,	O
n	int
=	O
cv	pointer
->	O
c_xs	int
-	O
(	O
lx	int
+	O
cv	pointer
->	O
c_xoff	int
)	O
;	O
if	O
(	O
n	int
<	O
(	O
cv	pointer
->	O
c_xe	int
-	O
cv	pointer
->	O
c_xs	int
+	O
1	int
)	O
/	O
2	int
)	O
n	int
=	O
(	O
cv	pointer
->	O
c_xe	int
-	O
cv	pointer
->	O
c_xs	int
+	O
1	int
)	O
/	O
2	int
;	O
if	O
(	O
cv	pointer
->	O
c_xoff	int
+	O
n	int
>	O
cv	pointer
->	O
c_xs	int
)	O
n	int
=	O
cv	pointer
->	O
c_xs	int
-	O
cv	pointer
->	O
c_xoff	int
;	O
cv	pointer
->	O
c_xoff	int
+=	O
n	int
;	O
RethinkViewportOffsets	function
(	O
cv	pointer
)	O
;	O
if	O
(	O
n	int
>	O
cv	pointer
->	O
c_layer	pointer
->	O
l_width	int
)	O
n	int
=	O
cv	pointer
->	O
c_layer	pointer
->	O
l_width	int
;	O
CV_CALL	O
(	O
cv	pointer
,	O
LayRedisplayLine	O
(	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
flayer	pointer
->	O
l_height	int
;	O
i	int
++	O
)	O
{	O
LScrollH	function
(	O
flayer	pointer
,	O
-	O
n	int
,	O
i	int
,	O
0	int
,	O
flayer	pointer
->	O
l_width	int
-	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
LayRedisplayLine	O
(	O
i	int
,	O
0	int
,	O
n	int
-	O
1	int
,	O
1	int
)	O
;	O
}	O
if	O
(	O
cv	pointer
==	O
cv	pointer
->	O
c_display	pointer
->	O
d_forecv	pointer
)	O
LaySetCursor	O
(	O
)	O
;	O
)	O
;	O
}	O
else	O
if	O
(	O
lx	int
+	O
cv	pointer
->	O
c_xoff	int
>	O
cv	pointer
->	O
c_xe	int
)	O
{	O
int	O
i	int
,	O
n	int
=	O
lx	int
+	O
cv	pointer
->	O
c_xoff	int
-	O
cv	pointer
->	O
c_xe	int
;	O
if	O
(	O
n	int
<	O
(	O
cv	pointer
->	O
c_xe	int
-	O
cv	pointer
->	O
c_xs	int
+	O
1	int
)	O
/	O
2	int
)	O
n	int
=	O
(	O
cv	pointer
->	O
c_xe	int
-	O
cv	pointer
->	O
c_xs	int
+	O
1	int
)	O
/	O
2	int
;	O
if	O
(	O
cv	pointer
->	O
c_xoff	int
-	O
n	int
+	O
cv	pointer
->	O
c_layer	pointer
->	O
l_width	int
-	O
1	int
<	O
cv	pointer
->	O
c_xe	int
)	O
n	int
=	O
cv	pointer
->	O
c_xoff	int
+	O
cv	pointer
->	O
c_layer	pointer
->	O
l_width	int
-	O
1	int
-	O
cv	pointer
->	O
c_xe	int
;	O
cv	pointer
->	O
c_xoff	int
-=	O
n	int
;	O
RethinkViewportOffsets	function
(	O
cv	pointer
)	O
;	O
if	O
(	O
n	int
>	O
cv	pointer
->	O
c_layer	pointer
->	O
l_width	int
)	O
n	int
=	O
cv	pointer
->	O
c_layer	pointer
->	O
l_width	int
;	O
CV_CALL	O
(	O
cv	pointer
,	O
LayRedisplayLine	O
(	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
flayer	pointer
->	O
l_height	int
;	O
i	int
++	O
)	O
{	O
LScrollH	function
(	O
flayer	pointer
,	O
n	int
,	O
i	int
,	O
0	int
,	O
flayer	pointer
->	O
l_width	int
-	O
1	int
,	O
0	int
,	O
0	int
)	O
;	O
LayRedisplayLine	O
(	O
i	int
,	O
flayer	pointer
->	O
l_width	int
-	O
n	int
,	O
flayer	pointer
->	O
l_width	int
-	O
1	int
,	O
1	int
)	O
;	O
}	O
if	O
(	O
cv	pointer
==	O
cv	pointer
->	O
c_display	pointer
->	O
d_forecv	pointer
)	O
LaySetCursor	O
(	O
)	O
;	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
if	O
(	O
D_status	O
==	O
STATUS_ON_WIN	int
||	O
D_cvlist	O
==	O
0	int
||	O
D_cvlist	O
->	O
c_next	pointer
==	O
0	int
)	O
continue	O
;	O
debug1	O
(	O
"serv_select_fn: Restore on cv %#x\n"	pointer
,	O
(	O
int	O
)	O
D_forecv	O
)	O
;	O
CV_CALL	O
(	O
D_forecv	O
,	O
LayRestore	O
(	O
)	O
;	O
LaySetCursor	O
(	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
logflush_fn	function
(	O
struct	O
event	struct
*	O
ev	struct
,	O
char	O
*	O
data	pointer
)	O
{	O
struct	O
win	struct
*	O
p	pointer
;	O
char	O
*	O
buf	pointer
;	O
int	O
n	int
;	O
if	O
(	O
!	O
islogfile	function
(	O
NULL	O
)	O
)	O
return	O
;	O
logfflush	function
(	O
NULL	O
)	O
;	O
n	int
=	O
log_flush	int
?	O
log_flush	int
:	O
(	O
logtstamp_after	int
+	O
4	int
)	O
/	O
5	int
;	O
if	O
(	O
n	int
)	O
{	O
SetTimeout	function
(	O
ev	struct
,	O
n	int
*	O
1000	int
)	O
;	O
evenq	function
(	O
ev	struct
)	O
;	O
}	O
if	O
(	O
!	O
logtstamp_on	int
)	O
return	O
;	O
for	O
(	O
p	pointer
=	O
windows	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
w_next	pointer
)	O
{	O
if	O
(	O
!	O
p	pointer
->	O
w_log	pointer
)	O
continue	O
;	O
p	pointer
->	O
w_logsilence	int
+=	O
n	int
;	O
if	O
(	O
p	pointer
->	O
w_logsilence	int
<	O
logtstamp_after	int
)	O
continue	O
;	O
if	O
(	O
p	pointer
->	O
w_logsilence	int
-	O
n	int
>=	O
logtstamp_after	int
)	O
continue	O
;	O
buf	pointer
=	O
MakeWinMsg	function
(	O
logtstamp_string	pointer
,	O
p	pointer
,	O
'%'	O
)	O
;	O
logfwrite	function
(	O
p	pointer
->	O
w_log	pointer
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
}	O
static	O
char	O
*	O
ParseChar	function
(	O
char	O
*	O
p	pointer
,	O
char	O
*	O
cp	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
*	O
p	pointer
==	O
'^'	O
&&	O
p	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
*	O
++	O
p	pointer
==	O
'?'	O
)	O
*	O
cp	pointer
=	O
'\177'	O
;	O
else	O
if	O
(	O
*	O
p	pointer
>=	O
'@'	O
)	O
*	O
cp	pointer
=	O
Ctrl	O
(	O
*	O
p	pointer
)	O
;	O
else	O
return	O
0	int
;	O
++	O
p	pointer
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'\\'	O
&&	O
*	O
++	O
p	pointer
<=	O
'7'	O
&&	O
*	O
p	pointer
>=	O
'0'	O
)	O
{	O
*	O
cp	pointer
=	O
0	int
;	O
do	O
*	O
cp	pointer
=	O
*	O
cp	pointer
*	O
8	int
+	O
*	O
p	pointer
-	O
'0'	O
;	O
while	O
(	O
*	O
++	O
p	pointer
<=	O
'7'	O
&&	O
*	O
p	pointer
>=	O
'0'	O
)	O
;	O
}	O
else	O
*	O
cp	pointer
=	O
*	O
p	pointer
++	O
;	O
return	O
p	pointer
;	O
}	O
static	O
int	O
ParseEscape	function
(	O
char	O
*	O
p	pointer
)	O
{	O
unsigned	O
char	O
buf	pointer
[	O
2	int
]	O
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
SetEscape	function
(	O
(	O
struct	O
acluser	struct
*	O
)	O
0	int
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
else	O
{	O
if	O
(	O
(	O
p	pointer
=	O
ParseChar	function
(	O
p	pointer
,	O
(	O
char	O
*	O
)	O
buf	pointer
)	O
)	O
==	O
NULL	O
||	O
(	O
p	pointer
=	O
ParseChar	function
(	O
p	pointer
,	O
(	O
char	O
*	O
)	O
buf	pointer
+	O
1	int
)	O
)	O
==	O
NULL	O
||	O
*	O
p	pointer
)	O
return	O
-	O
1	int
;	O
SetEscape	function
(	O
(	O
struct	O
acluser	struct
*	O
)	O
0	int
,	O
buf	pointer
[	O
0	int
]	O
,	O
buf	pointer
[	O
1	int
]	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
SetTtyname	function
(	O
bool	bool
fatal	bool
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
int	O
ret	int
;	O
int	O
saved_errno	int
=	O
0	int
;	O
attach_tty_is_in_new_ns	bool
=	O
false	int
;	O
memset	function
(	O
&	O
attach_tty_name_in_ns	array
,	O
0	int
,	O
sizeof	O
(	O
attach_tty_name_in_ns	array
)	O
)	O
;	O
errno	O
=	O
0	int
;	O
attach_tty	pointer
=	O
ttyname	function
(	O
0	int
)	O
;	O
if	O
(	O
!	O
attach_tty	pointer
)	O
{	O
if	O
(	O
errno	O
==	O
ENODEV	int
)	O
{	O
saved_errno	int
=	O
errno	O
;	O
attach_tty	pointer
=	O
"/proc/self/fd/0"	pointer
;	O
attach_tty_is_in_new_ns	bool
=	O
true	int
;	O
ret	int
=	O
readlink	function
(	O
attach_tty	pointer
,	O
attach_tty_name_in_ns	array
,	O
sizeof	O
(	O
attach_tty_name_in_ns	array
)	O
)	O
;	O
if	O
(	O
ret	int
<	O
0	int
||	O
(	O
size_t	long
)	O
ret	int
>=	O
sizeof	O
(	O
attach_tty_name_in_ns	array
)	O
)	O
Panic	function
(	O
0	int
,	O
"Bad tty '%s'"	pointer
,	O
attach_tty	pointer
)	O
;	O
}	O
else	O
if	O
(	O
fatal	bool
)	O
{	O
Panic	function
(	O
0	int
,	O
"Must be connected to a terminal."	pointer
)	O
;	O
}	O
else	O
{	O
attach_tty	pointer
=	O
""	pointer
;	O
}	O
}	O
if	O
(	O
attach_tty	pointer
&&	O
strcmp	function
(	O
attach_tty	pointer
,	O
""	pointer
)	O
)	O
{	O
if	O
(	O
stat	struct
(	O
attach_tty	pointer
,	O
st	pointer
)	O
)	O
Panic	function
(	O
errno	O
,	O
"Cannot access '%s'"	pointer
,	O
attach_tty	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
attach_tty	pointer
)	O
>=	O
MAXPATHLEN	O
)	O
Panic	function
(	O
0	int
,	O
"TtyName too long - sorry."	pointer
)	O
;	O
if	O
(	O
saved_errno	int
!=	O
ENODEV	int
&&	O
CheckTtyname	function
(	O
attach_tty	pointer
)	O
)	O
Panic	function
(	O
0	int
,	O
"Bad tty '%s'"	pointer
,	O
attach_tty	pointer
)	O
;	O
}	O
}	O
