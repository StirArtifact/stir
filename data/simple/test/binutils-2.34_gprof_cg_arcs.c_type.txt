static	O
int	O
cmp_topo	function
(	O
const	O
PTR	O
,	O
const	O
PTR	O
)	O
;	O
static	O
void	O
propagate_time	function
(	O
Sym	struct
*	O
)	O
;	O
static	O
void	O
cycle_time	function
(	O
void	O
)	O
;	O
static	O
void	O
cycle_link	function
(	O
void	O
)	O
;	O
static	O
void	O
inherit_flags	function
(	O
Sym	struct
*	O
)	O
;	O
static	O
void	O
propagate_flags	function
(	O
Sym	struct
*	O
*	O
)	O
;	O
static	O
int	O
cmp_total	function
(	O
const	O
PTR	O
,	O
const	O
PTR	O
)	O
;	O
Sym	struct
*	O
cycle_header	pointer
;	O
unsigned	O
int	O
num_cycles	int
;	O
Arc	struct
*	O
*	O
arcs	pointer
;	O
unsigned	O
int	O
numarcs	int
;	O
Arc	struct
*	O
arc_lookup	function
(	O
Sym	struct
*	O
parent	pointer
,	O
Sym	struct
*	O
child	double
)	O
{	O
Arc	struct
*	O
arc	struct
;	O
if	O
(	O
!	O
parent	pointer
||	O
!	O
child	double
)	O
{	O
printf	function
(	O
"[arc_lookup] parent == 0 || child == 0\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
DBG	O
(	O
LOOKUPDEBUG	O
,	O
printf	function
(	O
"[arc_lookup] parent %s child %s\n"	pointer
,	O
parent	pointer
->	O
name	pointer
,	O
child	double
->	O
name	pointer
)	O
)	O
;	O
for	O
(	O
arc	struct
=	O
parent	pointer
->	O
cg	struct
.	O
children	pointer
;	O
arc	struct
;	O
arc	struct
=	O
arc	struct
->	O
next_child	pointer
)	O
{	O
DBG	O
(	O
LOOKUPDEBUG	O
,	O
printf	function
(	O
"[arc_lookup]\t parent %s child %s\n"	pointer
,	O
arc	struct
->	O
parent	pointer
->	O
name	pointer
,	O
arc	struct
->	O
child	double
->	O
name	pointer
)	O
)	O
;	O
if	O
(	O
child	double
->	O
addr	pointer
>=	O
arc	struct
->	O
child	double
->	O
addr	pointer
&&	O
child	double
->	O
end_addr	long
<=	O
arc	struct
->	O
child	double
->	O
end_addr	long
)	O
{	O
return	O
arc	struct
;	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
arc_add	function
(	O
Sym	struct
*	O
parent	pointer
,	O
Sym	struct
*	O
child	double
,	O
unsigned	O
long	O
count	int
)	O
{	O
static	O
unsigned	O
int	O
maxarcs	int
=	O
0	int
;	O
Arc	struct
*	O
arc	struct
,	O
*	O
*	O
newarcs	pointer
;	O
DBG	O
(	O
TALLYDEBUG	O
,	O
printf	function
(	O
"[arc_add] %lu arcs from %s to %s\n"	pointer
,	O
count	int
,	O
parent	pointer
->	O
name	pointer
,	O
child	double
->	O
name	pointer
)	O
)	O
;	O
arc	struct
=	O
arc_lookup	function
(	O
parent	pointer
,	O
child	double
)	O
;	O
if	O
(	O
arc	struct
)	O
{	O
DBG	O
(	O
TALLYDEBUG	O
,	O
printf	function
(	O
"[tally] hit %lu += %lu\n"	pointer
,	O
arc	struct
->	O
count	int
,	O
count	int
)	O
)	O
;	O
arc	struct
->	O
count	int
+=	O
count	int
;	O
return	O
;	O
}	O
arc	struct
=	O
(	O
Arc	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
arc	struct
)	O
)	O
;	O
memset	function
(	O
arc	struct
,	O
0	int
,	O
sizeof	O
(	O
*	O
arc	struct
)	O
)	O
;	O
arc	struct
->	O
parent	pointer
=	O
parent	pointer
;	O
arc	struct
->	O
child	double
=	O
child	double
;	O
arc	struct
->	O
count	int
=	O
count	int
;	O
if	O
(	O
parent	pointer
!=	O
child	double
)	O
{	O
if	O
(	O
numarcs	int
==	O
maxarcs	int
)	O
{	O
if	O
(	O
maxarcs	int
==	O
0	int
)	O
maxarcs	int
=	O
1	int
;	O
maxarcs	int
*=	O
2	int
;	O
newarcs	pointer
=	O
(	O
Arc	struct
*	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
Arc	struct
*	O
)	O
*	O
maxarcs	int
)	O
;	O
memcpy	function
(	O
newarcs	pointer
,	O
arcs	pointer
,	O
numarcs	int
*	O
sizeof	O
(	O
Arc	struct
*	O
)	O
)	O
;	O
free	function
(	O
arcs	pointer
)	O
;	O
arcs	pointer
=	O
newarcs	pointer
;	O
}	O
arcs	pointer
[	O
numarcs	int
++	O
]	O
=	O
arc	struct
;	O
}	O
arc	struct
->	O
next_child	pointer
=	O
parent	pointer
->	O
cg	struct
.	O
children	pointer
;	O
parent	pointer
->	O
cg	struct
.	O
children	pointer
=	O
arc	struct
;	O
arc	struct
->	O
next_parent	pointer
=	O
child	double
->	O
cg	struct
.	O
parents	pointer
;	O
child	double
->	O
cg	struct
.	O
parents	pointer
=	O
arc	struct
;	O
}	O
static	O
int	O
cmp_topo	function
(	O
const	O
PTR	O
lp	pointer
,	O
const	O
PTR	O
rp	pointer
)	O
{	O
const	O
Sym	struct
*	O
left	pointer
=	O
*	O
(	O
const	O
Sym	struct
*	O
*	O
)	O
lp	pointer
;	O
const	O
Sym	struct
*	O
right	pointer
=	O
*	O
(	O
const	O
Sym	struct
*	O
*	O
)	O
rp	pointer
;	O
return	O
left	pointer
->	O
cg	struct
.	O
top_order	int
-	O
right	pointer
->	O
cg	struct
.	O
top_order	int
;	O
}	O
static	O
void	O
propagate_time	function
(	O
Sym	struct
*	O
parent	pointer
)	O
{	O
Arc	struct
*	O
arc	struct
;	O
Sym	struct
*	O
child	double
;	O
double	O
share	double
,	O
prop_share	double
;	O
if	O
(	O
parent	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
==	O
0.0	int
)	O
{	O
return	O
;	O
}	O
for	O
(	O
arc	struct
=	O
parent	pointer
->	O
cg	struct
.	O
children	pointer
;	O
arc	struct
;	O
arc	struct
=	O
arc	struct
->	O
next_child	pointer
)	O
{	O
child	double
=	O
arc	struct
->	O
child	double
;	O
if	O
(	O
arc	struct
->	O
count	int
==	O
0	int
||	O
child	double
==	O
parent	pointer
||	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
child	double
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
!=	O
child	double
)	O
{	O
if	O
(	O
parent	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
num	int
==	O
child	double
->	O
cg	struct
.	O
cyc	struct
.	O
num	int
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
parent	pointer
->	O
cg	struct
.	O
top_order	int
<=	O
child	double
->	O
cg	struct
.	O
top_order	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"[propagate] toporder botches\n"	pointer
)	O
;	O
}	O
child	double
=	O
child	double
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
;	O
}	O
else	O
{	O
if	O
(	O
parent	pointer
->	O
cg	struct
.	O
top_order	int
<=	O
child	double
->	O
cg	struct
.	O
top_order	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"[propagate] toporder botches\n"	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
child	double
->	O
ncalls	long
==	O
0	int
)	O
{	O
continue	O
;	O
}	O
arc	struct
->	O
time	struct
=	O
child	double
->	O
hist	struct
.	O
time	struct
*	O
(	O
(	O
(	O
double	O
)	O
arc	struct
->	O
count	int
)	O
/	O
(	O
(	O
double	O
)	O
child	double
->	O
ncalls	long
)	O
)	O
;	O
arc	struct
->	O
child_time	double
=	O
child	double
->	O
cg	struct
.	O
child_time	double
*	O
(	O
(	O
(	O
double	O
)	O
arc	struct
->	O
count	int
)	O
/	O
(	O
(	O
double	O
)	O
child	double
->	O
ncalls	long
)	O
)	O
;	O
share	double
=	O
arc	struct
->	O
time	struct
+	O
arc	struct
->	O
child_time	double
;	O
parent	pointer
->	O
cg	struct
.	O
child_time	double
+=	O
share	double
;	O
prop_share	double
=	O
parent	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
*	O
share	double
;	O
parent	pointer
->	O
cg	struct
.	O
prop	struct
.	O
child	double
+=	O
prop_share	double
;	O
arc	struct
->	O
time	struct
*=	O
parent	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
;	O
arc	struct
->	O
child_time	double
*=	O
parent	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
;	O
if	O
(	O
parent	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
!=	O
parent	pointer
)	O
{	O
parent	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
->	O
cg	struct
.	O
child_time	double
+=	O
share	double
;	O
parent	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
->	O
cg	struct
.	O
prop	struct
.	O
child	double
+=	O
prop_share	double
;	O
}	O
DBG	O
(	O
PROPDEBUG	O
,	O
printf	function
(	O
"[prop_time] child \t"	pointer
)	O
;	O
print_name	function
(	O
child	double
)	O
;	O
printf	function
(	O
" with %f %f %lu/%lu\n"	pointer
,	O
child	double
->	O
hist	struct
.	O
time	struct
,	O
child	double
->	O
cg	struct
.	O
child_time	double
,	O
arc	struct
->	O
count	int
,	O
child	double
->	O
ncalls	long
)	O
;	O
printf	function
(	O
"[prop_time] parent\t"	pointer
)	O
;	O
print_name	function
(	O
parent	pointer
)	O
;	O
printf	function
(	O
"\n[prop_time] share %f\n"	pointer
,	O
share	double
)	O
)	O
;	O
}	O
}	O
static	O
void	O
cycle_time	function
(	O
void	O
)	O
{	O
Sym	struct
*	O
member	pointer
,	O
*	O
cyc	struct
;	O
for	O
(	O
cyc	struct
=	O
&	O
cycle_header	pointer
[	O
1	int
]	O
;	O
cyc	struct
<=	O
&	O
cycle_header	pointer
[	O
num_cycles	int
]	O
;	O
++	O
cyc	struct
)	O
{	O
for	O
(	O
member	pointer
=	O
cyc	struct
->	O
cg	struct
.	O
cyc	struct
.	O
next	pointer
;	O
member	pointer
;	O
member	pointer
=	O
member	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
next	pointer
)	O
{	O
if	O
(	O
member	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
==	O
0.0	int
)	O
{	O
continue	O
;	O
}	O
cyc	struct
->	O
hist	struct
.	O
time	struct
+=	O
member	pointer
->	O
hist	struct
.	O
time	struct
;	O
}	O
cyc	struct
->	O
cg	struct
.	O
prop	struct
.	O
self	double
=	O
cyc	struct
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
*	O
cyc	struct
->	O
hist	struct
.	O
time	struct
;	O
}	O
}	O
static	O
void	O
cycle_link	function
(	O
void	O
)	O
{	O
Sym	struct
*	O
sym	pointer
,	O
*	O
cyc	struct
,	O
*	O
member	pointer
;	O
Arc	struct
*	O
arc	struct
;	O
int	O
num	int
;	O
num_cycles	int
=	O
0	int
;	O
for	O
(	O
sym	pointer
=	O
symtab	struct
.	O
base	int
;	O
sym	pointer
<	O
symtab	struct
.	O
limit	pointer
;	O
++	O
sym	pointer
)	O
{	O
if	O
(	O
sym	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
==	O
sym	pointer
&&	O
sym	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
next	pointer
)	O
{	O
++	O
num_cycles	int
;	O
}	O
}	O
cycle_header	pointer
=	O
(	O
Sym	struct
*	O
)	O
xmalloc	function
(	O
(	O
num_cycles	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
Sym	struct
)	O
)	O
;	O
num	int
=	O
0	int
;	O
cyc	struct
=	O
cycle_header	pointer
;	O
for	O
(	O
sym	pointer
=	O
symtab	struct
.	O
base	int
;	O
sym	pointer
<	O
symtab	struct
.	O
limit	pointer
;	O
++	O
sym	pointer
)	O
{	O
if	O
(	O
!	O
(	O
sym	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
==	O
sym	pointer
&&	O
sym	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
next	pointer
!=	O
0	int
)	O
)	O
{	O
continue	O
;	O
}	O
++	O
num	int
;	O
++	O
cyc	struct
;	O
sym_init	function
(	O
cyc	struct
)	O
;	O
cyc	struct
->	O
cg	struct
.	O
print_flag	int
=	O
TRUE	int
;	O
cyc	struct
->	O
cg	struct
.	O
top_order	int
=	O
DFN_NAN	int
;	O
cyc	struct
->	O
cg	struct
.	O
cyc	struct
.	O
num	int
=	O
num	int
;	O
cyc	struct
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
=	O
cyc	struct
;	O
cyc	struct
->	O
cg	struct
.	O
cyc	struct
.	O
next	pointer
=	O
sym	pointer
;	O
DBG	O
(	O
CYCLEDEBUG	O
,	O
printf	function
(	O
"[cycle_link] "	pointer
)	O
;	O
print_name	function
(	O
sym	pointer
)	O
;	O
printf	function
(	O
" is the head of cycle %d\n"	pointer
,	O
num	int
)	O
)	O
;	O
for	O
(	O
member	pointer
=	O
sym	pointer
;	O
member	pointer
;	O
member	pointer
=	O
member	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
next	pointer
)	O
{	O
member	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
num	int
=	O
num	int
;	O
member	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
=	O
cyc	struct
;	O
}	O
for	O
(	O
member	pointer
=	O
sym	pointer
;	O
member	pointer
;	O
member	pointer
=	O
member	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
next	pointer
)	O
{	O
for	O
(	O
arc	struct
=	O
member	pointer
->	O
cg	struct
.	O
parents	pointer
;	O
arc	struct
;	O
arc	struct
=	O
arc	struct
->	O
next_parent	pointer
)	O
{	O
if	O
(	O
arc	struct
->	O
parent	pointer
==	O
member	pointer
)	O
{	O
continue	O
;	O
}	O
if	O
(	O
arc	struct
->	O
parent	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
num	int
==	O
num	int
)	O
{	O
cyc	struct
->	O
cg	struct
.	O
self_calls	long
+=	O
arc	struct
->	O
count	int
;	O
}	O
else	O
{	O
cyc	struct
->	O
ncalls	long
+=	O
arc	struct
->	O
count	int
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
inherit_flags	function
(	O
Sym	struct
*	O
child	double
)	O
{	O
Sym	struct
*	O
head	pointer
,	O
*	O
parent	pointer
,	O
*	O
member	pointer
;	O
Arc	struct
*	O
arc	struct
;	O
head	pointer
=	O
child	double
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
;	O
if	O
(	O
child	double
==	O
head	pointer
)	O
{	O
child	double
->	O
cg	struct
.	O
print_flag	int
=	O
FALSE	int
;	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
=	O
0.0	int
;	O
for	O
(	O
arc	struct
=	O
child	double
->	O
cg	struct
.	O
parents	pointer
;	O
arc	struct
;	O
arc	struct
=	O
arc	struct
->	O
next_parent	pointer
)	O
{	O
parent	pointer
=	O
arc	struct
->	O
parent	pointer
;	O
if	O
(	O
child	double
==	O
parent	pointer
)	O
{	O
continue	O
;	O
}	O
child	double
->	O
cg	struct
.	O
print_flag	int
|=	O
parent	pointer
->	O
cg	struct
.	O
print_flag	int
;	O
if	O
(	O
child	double
->	O
ncalls	long
!=	O
0	int
)	O
{	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
+=	O
parent	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
*	O
(	O
(	O
(	O
double	O
)	O
arc	struct
->	O
count	int
)	O
/	O
(	O
(	O
double	O
)	O
child	double
->	O
ncalls	long
)	O
)	O
;	O
}	O
}	O
}	O
else	O
{	O
head	pointer
->	O
cg	struct
.	O
print_flag	int
=	O
FALSE	int
;	O
head	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
=	O
0.0	int
;	O
for	O
(	O
member	pointer
=	O
head	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
next	pointer
;	O
member	pointer
;	O
member	pointer
=	O
member	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
next	pointer
)	O
{	O
for	O
(	O
arc	struct
=	O
member	pointer
->	O
cg	struct
.	O
parents	pointer
;	O
arc	struct
;	O
arc	struct
=	O
arc	struct
->	O
next_parent	pointer
)	O
{	O
if	O
(	O
arc	struct
->	O
parent	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
==	O
head	pointer
)	O
{	O
continue	O
;	O
}	O
parent	pointer
=	O
arc	struct
->	O
parent	pointer
;	O
head	pointer
->	O
cg	struct
.	O
print_flag	int
|=	O
parent	pointer
->	O
cg	struct
.	O
print_flag	int
;	O
if	O
(	O
head	pointer
->	O
ncalls	long
!=	O
0	int
)	O
{	O
head	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
+=	O
parent	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
*	O
(	O
(	O
(	O
double	O
)	O
arc	struct
->	O
count	int
)	O
/	O
(	O
(	O
double	O
)	O
head	pointer
->	O
ncalls	long
)	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
member	pointer
=	O
head	pointer
;	O
member	pointer
;	O
member	pointer
=	O
member	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
next	pointer
)	O
{	O
member	pointer
->	O
cg	struct
.	O
print_flag	int
=	O
head	pointer
->	O
cg	struct
.	O
print_flag	int
;	O
member	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
=	O
head	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
;	O
}	O
}	O
}	O
static	O
void	O
propagate_flags	function
(	O
Sym	struct
*	O
*	O
symbols	pointer
)	O
{	O
int	O
sym_index	int
;	O
Sym	struct
*	O
old_head	pointer
,	O
*	O
child	double
;	O
old_head	pointer
=	O
0	int
;	O
for	O
(	O
sym_index	int
=	O
symtab	struct
.	O
len	long
-	O
1	int
;	O
sym_index	int
>=	O
0	int
;	O
--	O
sym_index	int
)	O
{	O
child	double
=	O
symbols	pointer
[	O
sym_index	int
]	O
;	O
if	O
(	O
child	double
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
!=	O
old_head	pointer
)	O
{	O
old_head	pointer
=	O
child	double
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
;	O
inherit_flags	function
(	O
child	double
)	O
;	O
}	O
DBG	O
(	O
PROPDEBUG	O
,	O
printf	function
(	O
"[prop_flags] "	pointer
)	O
;	O
print_name	function
(	O
child	double
)	O
;	O
printf	function
(	O
"inherits print-flag %d and prop-fract %f\n"	pointer
,	O
child	double
->	O
cg	struct
.	O
print_flag	int
,	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
)	O
)	O
;	O
if	O
(	O
!	O
child	double
->	O
cg	struct
.	O
print_flag	int
)	O
{	O
if	O
(	O
sym_lookup	function
(	O
&	O
syms	pointer
[	O
INCL_GRAPH	int
]	O
,	O
child	double
->	O
addr	pointer
)	O
||	O
(	O
syms	pointer
[	O
INCL_GRAPH	int
]	O
.	O
len	long
==	O
0	int
&&	O
!	O
sym_lookup	function
(	O
&	O
syms	pointer
[	O
EXCL_GRAPH	int
]	O
,	O
child	double
->	O
addr	pointer
)	O
)	O
)	O
{	O
child	double
->	O
cg	struct
.	O
print_flag	int
=	O
TRUE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
sym_lookup	function
(	O
&	O
syms	pointer
[	O
INCL_GRAPH	int
]	O
,	O
child	double
->	O
addr	pointer
)	O
&&	O
sym_lookup	function
(	O
&	O
syms	pointer
[	O
EXCL_GRAPH	int
]	O
,	O
child	double
->	O
addr	pointer
)	O
)	O
{	O
child	double
->	O
cg	struct
.	O
print_flag	int
=	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
==	O
0.0	int
)	O
{	O
if	O
(	O
sym_lookup	function
(	O
&	O
syms	pointer
[	O
INCL_TIME	int
]	O
,	O
child	double
->	O
addr	pointer
)	O
||	O
(	O
syms	pointer
[	O
INCL_TIME	int
]	O
.	O
len	long
==	O
0	int
&&	O
!	O
sym_lookup	function
(	O
&	O
syms	pointer
[	O
EXCL_TIME	int
]	O
,	O
child	double
->	O
addr	pointer
)	O
)	O
)	O
{	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
=	O
1.0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
sym_lookup	function
(	O
&	O
syms	pointer
[	O
INCL_TIME	int
]	O
,	O
child	double
->	O
addr	pointer
)	O
&&	O
sym_lookup	function
(	O
&	O
syms	pointer
[	O
EXCL_TIME	int
]	O
,	O
child	double
->	O
addr	pointer
)	O
)	O
{	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
=	O
0.0	int
;	O
}	O
}	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
self	double
=	O
child	double
->	O
hist	struct
.	O
time	struct
*	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
;	O
print_time	double
+=	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
self	double
;	O
DBG	O
(	O
PROPDEBUG	O
,	O
printf	function
(	O
"[prop_flags] "	pointer
)	O
;	O
print_name	function
(	O
child	double
)	O
;	O
printf	function
(	O
" ends up with printflag %d and prop-fract %f\n"	pointer
,	O
child	double
->	O
cg	struct
.	O
print_flag	int
,	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
)	O
;	O
printf	function
(	O
"[prop_flags] time %f propself %f print_time %f\n"	pointer
,	O
child	double
->	O
hist	struct
.	O
time	struct
,	O
child	double
->	O
cg	struct
.	O
prop	struct
.	O
self	double
,	O
print_time	double
)	O
)	O
;	O
}	O
}	O
static	O
int	O
cmp_total	function
(	O
const	O
PTR	O
lp	pointer
,	O
const	O
PTR	O
rp	pointer
)	O
{	O
const	O
Sym	struct
*	O
left	pointer
=	O
*	O
(	O
const	O
Sym	struct
*	O
*	O
)	O
lp	pointer
;	O
const	O
Sym	struct
*	O
right	pointer
=	O
*	O
(	O
const	O
Sym	struct
*	O
*	O
)	O
rp	pointer
;	O
double	O
diff	double
;	O
diff	double
=	O
(	O
left	pointer
->	O
cg	struct
.	O
prop	struct
.	O
self	double
+	O
left	pointer
->	O
cg	struct
.	O
prop	struct
.	O
child	double
)	O
-	O
(	O
right	pointer
->	O
cg	struct
.	O
prop	struct
.	O
self	double
+	O
right	pointer
->	O
cg	struct
.	O
prop	struct
.	O
child	double
)	O
;	O
if	O
(	O
diff	double
<	O
0.0	int
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
diff	double
>	O
0.0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
left	pointer
->	O
name	pointer
&&	O
left	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
num	int
!=	O
0	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
right	pointer
->	O
name	pointer
&&	O
right	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
num	int
!=	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
left	pointer
->	O
name	pointer
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
right	pointer
->	O
name	pointer
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
left	pointer
->	O
name	pointer
[	O
0	int
]	O
!=	O
'_'	O
&&	O
right	pointer
->	O
name	pointer
[	O
0	int
]	O
==	O
'_'	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
left	pointer
->	O
name	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
right	pointer
->	O
name	pointer
[	O
0	int
]	O
!=	O
'_'	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
left	pointer
->	O
ncalls	long
>	O
right	pointer
->	O
ncalls	long
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
left	pointer
->	O
ncalls	long
<	O
right	pointer
->	O
ncalls	long
)	O
{	O
return	O
1	int
;	O
}	O
return	O
strcmp	function
(	O
left	pointer
->	O
name	pointer
,	O
right	pointer
->	O
name	pointer
)	O
;	O
}	O
Sym	struct
*	O
*	O
cg_assemble	function
(	O
void	O
)	O
{	O
Sym	struct
*	O
parent	pointer
,	O
*	O
*	O
time_sorted_syms	pointer
,	O
*	O
*	O
top_sorted_syms	pointer
;	O
unsigned	O
int	O
sym_index	int
;	O
Arc	struct
*	O
arc	struct
;	O
for	O
(	O
parent	pointer
=	O
symtab	struct
.	O
base	int
;	O
parent	pointer
<	O
symtab	struct
.	O
limit	pointer
;	O
parent	pointer
++	O
)	O
{	O
parent	pointer
->	O
cg	struct
.	O
child_time	double
=	O
0.0	int
;	O
arc	struct
=	O
arc_lookup	function
(	O
parent	pointer
,	O
parent	pointer
)	O
;	O
if	O
(	O
arc	struct
&&	O
parent	pointer
==	O
arc	struct
->	O
child	double
)	O
{	O
parent	pointer
->	O
ncalls	long
-=	O
arc	struct
->	O
count	int
;	O
parent	pointer
->	O
cg	struct
.	O
self_calls	long
=	O
arc	struct
->	O
count	int
;	O
}	O
else	O
{	O
parent	pointer
->	O
cg	struct
.	O
self_calls	long
=	O
0	int
;	O
}	O
parent	pointer
->	O
cg	struct
.	O
prop	struct
.	O
fract	double
=	O
0.0	int
;	O
parent	pointer
->	O
cg	struct
.	O
prop	struct
.	O
self	double
=	O
0.0	int
;	O
parent	pointer
->	O
cg	struct
.	O
prop	struct
.	O
child	double
=	O
0.0	int
;	O
parent	pointer
->	O
cg	struct
.	O
print_flag	int
=	O
FALSE	int
;	O
parent	pointer
->	O
cg	struct
.	O
top_order	int
=	O
DFN_NAN	int
;	O
parent	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
num	int
=	O
0	int
;	O
parent	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
head	pointer
=	O
parent	pointer
;	O
parent	pointer
->	O
cg	struct
.	O
cyc	struct
.	O
next	pointer
=	O
0	int
;	O
if	O
(	O
ignore_direct_calls	int
)	O
find_call	function
(	O
parent	pointer
,	O
parent	pointer
->	O
addr	pointer
,	O
(	O
parent	pointer
+	O
1	int
)	O
->	O
addr	pointer
)	O
;	O
}	O
for	O
(	O
parent	pointer
=	O
symtab	struct
.	O
base	int
;	O
parent	pointer
<	O
symtab	struct
.	O
limit	pointer
;	O
parent	pointer
++	O
)	O
{	O
if	O
(	O
parent	pointer
->	O
cg	struct
.	O
top_order	int
==	O
DFN_NAN	int
)	O
cg_dfn	function
(	O
parent	pointer
)	O
;	O
}	O
cycle_link	function
(	O
)	O
;	O
top_sorted_syms	pointer
=	O
(	O
Sym	struct
*	O
*	O
)	O
xmalloc	function
(	O
symtab	struct
.	O
len	long
*	O
sizeof	O
(	O
Sym	struct
*	O
)	O
)	O
;	O
for	O
(	O
sym_index	int
=	O
0	int
;	O
sym_index	int
<	O
symtab	struct
.	O
len	long
;	O
++	O
sym_index	int
)	O
top_sorted_syms	pointer
[	O
sym_index	int
]	O
=	O
&	O
symtab	struct
.	O
base	int
[	O
sym_index	int
]	O
;	O
qsort	function
(	O
top_sorted_syms	pointer
,	O
symtab	struct
.	O
len	long
,	O
sizeof	O
(	O
Sym	struct
*	O
)	O
,	O
cmp_topo	function
)	O
;	O
DBG	O
(	O
DFNDEBUG	O
,	O
printf	function
(	O
"[cg_assemble] topological sort listing\n"	pointer
)	O
;	O
for	O
(	O
sym_index	int
=	O
0	int
;	O
sym_index	int
<	O
symtab	struct
.	O
len	long
;	O
++	O
sym_index	int
)	O
{	O
printf	function
(	O
"[cg_assemble] "	pointer
)	O
;	O
printf	function
(	O
"%d:"	pointer
,	O
top_sorted_syms	pointer
[	O
sym_index	int
]	O
->	O
cg	struct
.	O
top_order	int
)	O
;	O
print_name	function
(	O
top_sorted_syms	pointer
[	O
sym_index	int
]	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
)	O
;	O
propagate_flags	function
(	O
top_sorted_syms	pointer
)	O
;	O
cycle_time	function
(	O
)	O
;	O
for	O
(	O
sym_index	int
=	O
0	int
;	O
sym_index	int
<	O
symtab	struct
.	O
len	long
;	O
++	O
sym_index	int
)	O
propagate_time	function
(	O
top_sorted_syms	pointer
[	O
sym_index	int
]	O
)	O
;	O
free	function
(	O
top_sorted_syms	pointer
)	O
;	O
time_sorted_syms	pointer
=	O
(	O
Sym	struct
*	O
*	O
)	O
xmalloc	function
(	O
(	O
symtab	struct
.	O
len	long
+	O
num_cycles	int
)	O
*	O
sizeof	O
(	O
Sym	struct
*	O
)	O
)	O
;	O
for	O
(	O
sym_index	int
=	O
0	int
;	O
sym_index	int
<	O
symtab	struct
.	O
len	long
;	O
sym_index	int
++	O
)	O
time_sorted_syms	pointer
[	O
sym_index	int
]	O
=	O
&	O
symtab	struct
.	O
base	int
[	O
sym_index	int
]	O
;	O
for	O
(	O
sym_index	int
=	O
1	int
;	O
sym_index	int
<=	O
num_cycles	int
;	O
sym_index	int
++	O
)	O
time_sorted_syms	pointer
[	O
symtab	struct
.	O
len	long
+	O
sym_index	int
-	O
1	int
]	O
=	O
&	O
cycle_header	pointer
[	O
sym_index	int
]	O
;	O
qsort	function
(	O
time_sorted_syms	pointer
,	O
symtab	struct
.	O
len	long
+	O
num_cycles	int
,	O
sizeof	O
(	O
Sym	struct
*	O
)	O
,	O
cmp_total	function
)	O
;	O
for	O
(	O
sym_index	int
=	O
0	int
;	O
sym_index	int
<	O
symtab	struct
.	O
len	long
+	O
num_cycles	int
;	O
sym_index	int
++	O
)	O
time_sorted_syms	pointer
[	O
sym_index	int
]	O
->	O
cg	struct
.	O
index	function
=	O
sym_index	int
+	O
1	int
;	O
return	O
time_sorted_syms	pointer
;	O
}	O
