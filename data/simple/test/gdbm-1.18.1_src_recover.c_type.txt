int	O
gdbm_copy_meta	function
(	O
GDBM_FILE	pointer
dst	pointer
,	O
GDBM_FILE	pointer
src	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
fstat	function
(	O
src	pointer
->	O
desc	int
,	O
&	O
st	struct
)	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
src	pointer
,	O
GDBM_FILE_STAT_ERROR	int
,	O
src	pointer
->	O
need_recovery	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fchown	function
(	O
dst	pointer
->	O
desc	int
,	O
st	struct
.	O
st_uid	int
,	O
st	struct
.	O
st_gid	int
)	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dst	pointer
,	O
GDBM_ERR_FILE_OWNER	int
,	O
dst	pointer
->	O
need_recovery	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fchmod	function
(	O
dst	pointer
->	O
desc	int
,	O
st	struct
.	O
st_mode	int
&	O
0777	int
)	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dst	pointer
,	O
GDBM_ERR_FILE_MODE	int
,	O
dst	pointer
->	O
need_recovery	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
backup_name	pointer
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
char	O
*	O
buf	pointer
;	O
size_t	long
len	long
;	O
size_t	long
suf_pos	long
;	O
size_t	long
suf_len	long
;	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
+	O
sizeof	O
(	O
INITIAL_SUFFIX	pointer
)	O
;	O
buf	pointer
=	O
malloc	function
(	O
len	long
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
return	O
NULL	O
;	O
strcpy	function
(	O
buf	pointer
,	O
name	pointer
)	O
;	O
suf_pos	long
=	O
strlen	function
(	O
buf	pointer
)	O
+	O
2	int
;	O
suf_len	long
=	O
1	int
;	O
strcat	function
(	O
buf	pointer
,	O
INITIAL_SUFFIX	pointer
)	O
;	O
while	O
(	O
access	function
(	O
buf	pointer
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
size_t	long
i	long
=	O
suf_len	long
;	O
while	O
(	O
buf	pointer
[	O
suf_pos	long
+	O
i	long
-	O
1	int
]	O
==	O
'9'	O
)	O
{	O
buf	pointer
[	O
suf_pos	long
+	O
i	long
-	O
1	int
]	O
=	O
'0'	O
;	O
i	long
--	O
;	O
if	O
(	O
i	long
==	O
0	int
)	O
{	O
char	O
*	O
p	pointer
=	O
realloc	function
(	O
buf	pointer
,	O
++	O
len	long
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
SAVE_ERRNO	O
(	O
free	function
(	O
buf	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
memmove	function
(	O
p	pointer
+	O
suf_pos	long
+	O
1	int
,	O
p	pointer
+	O
suf_pos	long
,	O
suf_len	long
+	O
2	int
)	O
;	O
buf	pointer
=	O
p	pointer
;	O
suf_len	long
++	O
;	O
i	long
++	O
;	O
}	O
}	O
++	O
buf	pointer
[	O
suf_pos	long
+	O
i	long
-	O
1	int
]	O
;	O
}	O
return	O
buf	pointer
;	O
}	O
static	O
int	O
_gdbm_finish_transfer	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
GDBM_FILE	pointer
new_dbf	pointer
,	O
gdbm_recovery	struct
*	O
rcvr	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
i	long
;	O
if	O
(	O
_gdbm_end_update	function
(	O
new_dbf	pointer
)	O
)	O
{	O
gdbm_close	function
(	O
new_dbf	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
gdbm_sync	function
(	O
new_dbf	pointer
)	O
;	O
if	O
(	O
gdbm_copy_meta	function
(	O
new_dbf	pointer
,	O
dbf	pointer
)	O
)	O
{	O
gdbm_close	function
(	O
new_dbf	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
_gdbm_mapped_unmap	function
(	O
dbf	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
GDBM_RCVR_BACKUP	int
)	O
{	O
char	O
*	O
bkname	pointer
=	O
backup_name	pointer
(	O
dbf	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
!	O
bkname	pointer
)	O
{	O
SAVE_ERRNO	O
(	O
gdbm_close	function
(	O
new_dbf	pointer
)	O
)	O
;	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_BACKUP_FAILED	int
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
rename	function
(	O
dbf	pointer
->	O
name	pointer
,	O
bkname	pointer
)	O
!=	O
0	int
)	O
{	O
SAVE_ERRNO	O
(	O
gdbm_close	function
(	O
new_dbf	pointer
)	O
;	O
free	function
(	O
bkname	pointer
)	O
)	O
;	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_BACKUP_FAILED	int
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rcvr	pointer
->	O
backup_name	pointer
=	O
bkname	pointer
;	O
}	O
if	O
(	O
rename	function
(	O
new_dbf	pointer
->	O
name	pointer
,	O
dbf	pointer
->	O
name	pointer
)	O
!=	O
0	int
)	O
{	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_REORGANIZE_FAILED	int
,	O
FALSE	int
)	O
;	O
gdbm_close	function
(	O
new_dbf	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
dbf	pointer
->	O
file_locking	int
)	O
_gdbm_unlock_file	function
(	O
dbf	pointer
)	O
;	O
close	function
(	O
dbf	pointer
->	O
desc	int
)	O
;	O
free	function
(	O
dbf	pointer
->	O
header	pointer
)	O
;	O
free	function
(	O
dbf	pointer
->	O
dir	long
)	O
;	O
if	O
(	O
dbf	pointer
->	O
bucket_cache	pointer
!=	O
NULL	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dbf	pointer
->	O
cache_size	long
;	O
i	long
++	O
)	O
{	O
free	function
(	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
i	long
]	O
.	O
ca_bucket	pointer
)	O
;	O
free	function
(	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
i	long
]	O
.	O
ca_data	struct
.	O
dptr	pointer
)	O
;	O
}	O
free	function
(	O
dbf	pointer
->	O
bucket_cache	pointer
)	O
;	O
}	O
dbf	pointer
->	O
desc	int
=	O
new_dbf	pointer
->	O
desc	int
;	O
dbf	pointer
->	O
header	pointer
=	O
new_dbf	pointer
->	O
header	pointer
;	O
dbf	pointer
->	O
dir	long
=	O
new_dbf	pointer
->	O
dir	long
;	O
dbf	pointer
->	O
bucket	pointer
=	O
new_dbf	pointer
->	O
bucket	pointer
;	O
dbf	pointer
->	O
bucket_dir	int
=	O
new_dbf	pointer
->	O
bucket_dir	int
;	O
dbf	pointer
->	O
last_read	long
=	O
new_dbf	pointer
->	O
last_read	long
;	O
dbf	pointer
->	O
bucket_cache	pointer
=	O
new_dbf	pointer
->	O
bucket_cache	pointer
;	O
dbf	pointer
->	O
cache_size	long
=	O
new_dbf	pointer
->	O
cache_size	long
;	O
dbf	pointer
->	O
header_changed	int
=	O
new_dbf	pointer
->	O
header_changed	int
;	O
dbf	pointer
->	O
directory_changed	int
=	O
new_dbf	pointer
->	O
directory_changed	int
;	O
dbf	pointer
->	O
bucket_changed	int
=	O
new_dbf	pointer
->	O
bucket_changed	int
;	O
dbf	pointer
->	O
second_changed	int
=	O
new_dbf	pointer
->	O
second_changed	int
;	O
free	function
(	O
new_dbf	pointer
->	O
name	pointer
)	O
;	O
free	function
(	O
new_dbf	pointer
)	O
;	O
if	O
(	O
dbf	pointer
->	O
memory_mapping	int
)	O
_gdbm_mapped_init	function
(	O
dbf	pointer
)	O
;	O
gdbm_file_sync	function
(	O
dbf	pointer
)	O
;	O
dbf	pointer
->	O
cache_entry	pointer
=	O
&	O
dbf	pointer
->	O
bucket_cache	pointer
[	O
0	int
]	O
;	O
return	O
_gdbm_get_bucket	function
(	O
dbf	pointer
,	O
0	int
)	O
;	O
}	O
int	O
_gdbm_next_bucket_dir	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
int	O
bucket_dir	int
)	O
{	O
int	O
dir_count	int
=	O
GDBM_DIR_COUNT	O
(	O
dbf	pointer
)	O
;	O
if	O
(	O
bucket_dir	int
<	O
0	int
||	O
bucket_dir	int
>=	O
dir_count	int
)	O
bucket_dir	int
=	O
dir_count	int
;	O
else	O
{	O
off_t	long
cur	long
=	O
dbf	pointer
->	O
dir	long
[	O
bucket_dir	int
]	O
;	O
while	O
(	O
++	O
bucket_dir	int
<	O
dir_count	int
&&	O
cur	long
==	O
dbf	pointer
->	O
dir	long
[	O
bucket_dir	int
]	O
)	O
;	O
}	O
return	O
bucket_dir	int
;	O
}	O
static	O
int	O
check_db	function
(	O
GDBM_FILE	pointer
dbf	pointer
)	O
{	O
int	O
bucket_dir	int
,	O
i	long
;	O
int	O
nbuckets	int
=	O
GDBM_DIR_COUNT	O
(	O
dbf	pointer
)	O
;	O
if	O
(	O
_gdbm_validate_header	function
(	O
dbf	pointer
)	O
)	O
return	O
1	int
;	O
for	O
(	O
bucket_dir	int
=	O
0	int
;	O
bucket_dir	int
<	O
nbuckets	int
;	O
bucket_dir	int
=	O
_gdbm_next_bucket_dir	function
(	O
dbf	pointer
,	O
bucket_dir	int
)	O
)	O
{	O
if	O
(	O
_gdbm_get_bucket	function
(	O
dbf	pointer
,	O
bucket_dir	int
)	O
)	O
return	O
1	int
;	O
else	O
{	O
if	O
(	O
dbf	pointer
->	O
bucket	pointer
->	O
count	int
<	O
0	int
||	O
dbf	pointer
->	O
bucket	pointer
->	O
count	int
>	O
dbf	pointer
->	O
header	pointer
->	O
bucket_elems	int
)	O
return	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dbf	pointer
->	O
header	pointer
->	O
bucket_elems	int
;	O
i	long
++	O
)	O
{	O
char	O
*	O
dptr	pointer
;	O
datum	struct
key	struct
;	O
int	O
hashval	int
,	O
bucket	pointer
,	O
off	long
;	O
if	O
(	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
hash_value	int
==	O
-	O
1	int
)	O
continue	O
;	O
dptr	pointer
=	O
_gdbm_read_entry	function
(	O
dbf	pointer
,	O
i	long
)	O
;	O
if	O
(	O
!	O
dptr	pointer
)	O
return	O
1	int
;	O
key	struct
.	O
dptr	pointer
=	O
dptr	pointer
;	O
key	struct
.	O
dsize	int
=	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
key_size	int
;	O
if	O
(	O
memcmp	function
(	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
key_start	array
,	O
key	struct
.	O
dptr	pointer
,	O
(	O
SMALL	int
<	O
key	struct
.	O
dsize	int
?	O
SMALL	int
:	O
key	struct
.	O
dsize	int
)	O
)	O
)	O
return	O
1	int
;	O
_gdbm_hash_key	function
(	O
dbf	pointer
,	O
key	struct
,	O
&	O
hashval	int
,	O
&	O
bucket	pointer
,	O
&	O
off	long
)	O
;	O
if	O
(	O
bucket	pointer
>=	O
nbuckets	int
)	O
return	O
1	int
;	O
if	O
(	O
hashval	int
!=	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
hash_value	int
)	O
return	O
1	int
;	O
if	O
(	O
dbf	pointer
->	O
dir	long
[	O
bucket	pointer
]	O
!=	O
dbf	pointer
->	O
dir	long
[	O
bucket_dir	int
]	O
)	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
run_recovery	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
GDBM_FILE	pointer
new_dbf	pointer
,	O
gdbm_recovery	struct
*	O
rcvr	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
bucket_dir	int
,	O
i	long
;	O
int	O
nbuckets	int
=	O
GDBM_DIR_COUNT	O
(	O
dbf	pointer
)	O
;	O
for	O
(	O
bucket_dir	int
=	O
0	int
;	O
bucket_dir	int
<	O
nbuckets	int
;	O
bucket_dir	int
=	O
_gdbm_next_bucket_dir	function
(	O
dbf	pointer
,	O
bucket_dir	int
)	O
)	O
{	O
if	O
(	O
_gdbm_get_bucket	function
(	O
dbf	pointer
,	O
bucket_dir	int
)	O
)	O
{	O
if	O
(	O
flags	int
&	O
GDBM_RCVR_ERRFUN	int
)	O
rcvr	pointer
->	O
errfun	pointer
(	O
rcvr	pointer
->	O
data	pointer
,	O
_	O
(	O
"can't read bucket #%d: %s"	pointer
)	O
,	O
bucket_dir	int
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
rcvr	pointer
->	O
failed_buckets	long
++	O
;	O
if	O
(	O
(	O
flags	int
&	O
GDBM_RCVR_MAX_FAILED_BUCKETS	int
)	O
&&	O
rcvr	pointer
->	O
failed_buckets	long
==	O
rcvr	pointer
->	O
max_failed_buckets	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
flags	int
&	O
GDBM_RCVR_MAX_FAILURES	int
)	O
&&	O
(	O
rcvr	pointer
->	O
failed_buckets	long
+	O
rcvr	pointer
->	O
failed_keys	long
)	O
==	O
rcvr	pointer
->	O
max_failures	long
)	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
rcvr	pointer
->	O
recovered_buckets	long
++	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dbf	pointer
->	O
header	pointer
->	O
bucket_elems	int
;	O
i	long
++	O
)	O
{	O
char	O
*	O
dptr	pointer
;	O
datum	struct
key	struct
,	O
data	pointer
;	O
if	O
(	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
hash_value	int
==	O
-	O
1	int
)	O
continue	O
;	O
dptr	pointer
=	O
_gdbm_read_entry	function
(	O
dbf	pointer
,	O
i	long
)	O
;	O
if	O
(	O
dptr	pointer
)	O
rcvr	pointer
->	O
recovered_keys	long
++	O
;	O
else	O
{	O
if	O
(	O
flags	int
&	O
GDBM_RCVR_ERRFUN	int
)	O
rcvr	pointer
->	O
errfun	pointer
(	O
rcvr	pointer
->	O
data	pointer
,	O
_	O
(	O
"can't read key pair %d:%d (%lu:%d): %s"	pointer
)	O
,	O
bucket_dir	int
,	O
i	long
,	O
(	O
unsigned	O
long	O
)	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
data_pointer	long
,	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
key_size	int
+	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
data_size	int
,	O
gdbm_db_strerror	function
(	O
dbf	pointer
)	O
)	O
;	O
rcvr	pointer
->	O
failed_keys	long
++	O
;	O
if	O
(	O
(	O
flags	int
&	O
GDBM_RCVR_MAX_FAILED_KEYS	int
)	O
&&	O
rcvr	pointer
->	O
failed_keys	long
==	O
rcvr	pointer
->	O
max_failed_keys	long
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
flags	int
&	O
GDBM_RCVR_MAX_FAILURES	int
)	O
&&	O
(	O
rcvr	pointer
->	O
failed_buckets	long
+	O
rcvr	pointer
->	O
failed_keys	long
)	O
==	O
rcvr	pointer
->	O
max_failures	long
)	O
return	O
-	O
1	int
;	O
continue	O
;	O
}	O
key	struct
.	O
dptr	pointer
=	O
dptr	pointer
;	O
key	struct
.	O
dsize	int
=	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
key_size	int
;	O
data	pointer
.	O
dptr	pointer
=	O
dptr	pointer
+	O
key	struct
.	O
dsize	int
;	O
data	pointer
.	O
dsize	int
=	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
data_size	int
;	O
if	O
(	O
gdbm_store	function
(	O
new_dbf	pointer
,	O
key	struct
,	O
data	pointer
,	O
GDBM_INSERT	int
)	O
!=	O
0	int
)	O
{	O
switch	O
(	O
gdbm_last_errno	function
(	O
new_dbf	pointer
)	O
)	O
{	O
case	O
GDBM_CANNOT_REPLACE	int
:	O
rcvr	pointer
->	O
duplicate_keys	long
++	O
;	O
if	O
(	O
flags	int
&	O
GDBM_RCVR_ERRFUN	int
)	O
rcvr	pointer
->	O
errfun	pointer
(	O
rcvr	pointer
->	O
data	pointer
,	O
_	O
(	O
"ignoring duplicate key %d:%d (%lu:%d)"	pointer
)	O
,	O
bucket_dir	int
,	O
i	long
,	O
(	O
unsigned	O
long	O
)	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
data_pointer	long
,	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
key_size	int
+	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
data_size	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
flags	int
&	O
GDBM_RCVR_ERRFUN	int
)	O
rcvr	pointer
->	O
errfun	pointer
(	O
rcvr	pointer
->	O
data	pointer
,	O
_	O
(	O
"fatal: can't store element %d:%d (%lu:%d): %s"	pointer
)	O
,	O
bucket_dir	int
,	O
i	long
,	O
(	O
unsigned	O
long	O
)	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
data_pointer	long
,	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
key_size	int
+	O
dbf	pointer
->	O
bucket	pointer
->	O
h_table	array
[	O
i	long
]	O
.	O
data_size	int
,	O
gdbm_db_strerror	function
(	O
new_dbf	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
gdbm_recover	function
(	O
GDBM_FILE	pointer
dbf	pointer
,	O
gdbm_recovery	struct
*	O
rcvr	pointer
,	O
int	O
flags	int
)	O
{	O
GDBM_FILE	pointer
new_dbf	pointer
;	O
char	O
*	O
new_name	pointer
;	O
size_t	long
len	long
;	O
int	O
fd	int
;	O
int	O
rc	int
;	O
gdbm_recovery	struct
rs	struct
;	O
if	O
(	O
dbf	pointer
->	O
read_write	int
==	O
GDBM_READER	int
)	O
{	O
GDBM_SET_ERRNO	O
(	O
dbf	pointer
,	O
GDBM_READER_CANT_REORGANIZE	int
,	O
dbf	pointer
->	O
need_recovery	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
rcvr	pointer
)	O
{	O
rcvr	pointer
=	O
&	O
rs	struct
;	O
flags	int
=	O
0	int
;	O
}	O
rcvr	pointer
->	O
recovered_keys	long
=	O
0	int
;	O
rcvr	pointer
->	O
recovered_buckets	long
=	O
0	int
;	O
rcvr	pointer
->	O
failed_keys	long
=	O
0	int
;	O
rcvr	pointer
->	O
failed_buckets	long
=	O
0	int
;	O
rcvr	pointer
->	O
duplicate_keys	long
=	O
0	int
;	O
rcvr	pointer
->	O
backup_name	pointer
=	O
NULL	O
;	O
rc	int
=	O
0	int
;	O
if	O
(	O
(	O
flags	int
&	O
GDBM_RCVR_FORCE	int
)	O
||	O
check_db	function
(	O
dbf	pointer
)	O
)	O
{	O
gdbm_clear_error	function
(	O
dbf	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
dbf	pointer
->	O
name	pointer
)	O
;	O
new_name	pointer
=	O
malloc	function
(	O
len	long
+	O
sizeof	O
(	O
TMPSUF	pointer
)	O
)	O
;	O
if	O
(	O
!	O
new_name	pointer
)	O
{	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_MALLOC_ERROR	int
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcat	function
(	O
strcpy	function
(	O
new_name	pointer
,	O
dbf	pointer
->	O
name	pointer
)	O
,	O
TMPSUF	pointer
)	O
;	O
fd	int
=	O
mkstemp	function
(	O
new_name	pointer
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_FILE_OPEN_ERROR	int
,	O
FALSE	int
)	O
;	O
free	function
(	O
new_name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
new_dbf	pointer
=	O
gdbm_fd_open	function
(	O
fd	int
,	O
new_name	pointer
,	O
dbf	pointer
->	O
header	pointer
->	O
block_size	int
,	O
GDBM_WRCREAT	int
|	O
(	O
dbf	pointer
->	O
cloexec	int
?	O
GDBM_CLOEXEC	int
:	O
0	int
)	O
|	O
GDBM_CLOERROR	int
,	O
dbf	pointer
->	O
fatal_err	pointer
)	O
;	O
SAVE_ERRNO	O
(	O
free	function
(	O
new_name	pointer
)	O
)	O
;	O
if	O
(	O
new_dbf	pointer
==	O
NULL	O
)	O
{	O
GDBM_SET_ERRNO	O
(	O
NULL	O
,	O
GDBM_REORGANIZE_FAILED	int
,	O
FALSE	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
rc	int
=	O
run_recovery	function
(	O
dbf	pointer
,	O
new_dbf	pointer
,	O
rcvr	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
rc	int
=	O
_gdbm_finish_transfer	function
(	O
dbf	pointer
,	O
new_dbf	pointer
,	O
rcvr	pointer
,	O
flags	int
)	O
;	O
else	O
gdbm_close	function
(	O
new_dbf	pointer
)	O
;	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
gdbm_clear_error	function
(	O
dbf	pointer
)	O
;	O
dbf	pointer
->	O
need_recovery	int
=	O
FALSE	int
;	O
}	O
return	O
rc	int
;	O
}	O
