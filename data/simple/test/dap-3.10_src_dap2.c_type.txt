extern	O
dataobs	struct
dap_obs	array
[	O
]	O
;	O
extern	O
FILE	struct
*	O
dap_lst	pointer
;	O
extern	O
FILE	struct
*	O
dap_log	pointer
;	O
extern	O
FILE	struct
*	O
dap_err	pointer
;	O
extern	O
char	O
*	O
dap_dapname	pointer
;	O
extern	O
char	O
dap_sttnm	array
[	O
NSTATS	O
]	O
[	O
STATLEN	int
+	O
1	int
]	O
;	O
static	O
int	O
dblcmp	function
(	O
double	O
*	O
x	array
,	O
double	O
*	O
y	pointer
)	O
{	O
if	O
(	O
*	O
x	array
<	O
*	O
y	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
x	array
>	O
*	O
y	pointer
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ddblcmp	function
(	O
double	O
*	O
*	O
x	array
,	O
double	O
*	O
*	O
y	pointer
)	O
{	O
if	O
(	O
*	O
*	O
x	array
<	O
*	O
*	O
y	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
*	O
x	array
>	O
*	O
*	O
y	pointer
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
(	O
*	O
cmp	pointer
)	O
(	O
)	O
=	O
&	O
dblcmp	function
;	O
static	O
int	O
(	O
*	O
dcmp	pointer
)	O
(	O
)	O
=	O
&	O
ddblcmp	function
;	O
static	O
void	O
pctpttest	function
(	O
double	O
wtpt	double
,	O
double	O
cumwt	double
,	O
double	O
nextcum	double
,	O
int	O
*	O
pctpt	pointer
,	O
int	O
n	int
,	O
int	O
*	O
excess	pointer
)	O
{	O
if	O
(	O
cumwt	double
<=	O
wtpt	double
&&	O
wtpt	double
<	O
nextcum	double
)	O
{	O
*	O
pctpt	pointer
=	O
n	int
;	O
if	O
(	O
wtpt	double
>	O
cumwt	double
)	O
*	O
excess	pointer
=	O
1	int
;	O
}	O
}	O
static	O
void	O
pctile2	function
(	O
double	O
*	O
*	O
*	O
val	pointer
,	O
int	O
nobs	int
,	O
int	O
nvar	int
,	O
int	O
*	O
varv	array
,	O
int	O
*	O
wtvar	pointer
,	O
int	O
*	O
stats	array
)	O
{	O
int	O
v	int
;	O
int	O
*	O
pctptmem	pointer
;	O
int	O
*	O
*	O
pctpt	pointer
;	O
int	O
*	O
excessmem	pointer
;	O
int	O
*	O
*	O
excess	pointer
;	O
int	O
pn	int
;	O
int	O
pi	int
;	O
double	O
pct	double
;	O
static	O
double	O
sumwt	double
;	O
static	O
double	O
cumwt	double
;	O
static	O
double	O
nextcum	double
;	O
static	O
double	O
wtpt	double
;	O
double	O
upct	array
[	O
MAXPCTPT	int
]	O
;	O
int	O
n	int
;	O
int	O
ptindex	int
;	O
int	O
s	int
;	O
double	O
q1	double
,	O
q3	double
;	O
int	O
typen	int
;	O
dap_swap	function
(	O
)	O
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(pctile2) missing _type_ variable\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
pctptmem	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nvar	int
*	O
(	O
9	int
+	O
MAXPCTPT	int
)	O
,	O
""	pointer
)	O
;	O
pctpt	pointer
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
excessmem	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nvar	int
*	O
(	O
9	int
+	O
MAXPCTPT	int
)	O
,	O
""	pointer
)	O
;	O
excess	pointer
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
for	O
(	O
pn	int
=	O
0	int
;	O
pn	int
<	O
MAXPCTPT	int
&&	O
stats	array
[	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pn	int
]	O
;	O
pn	int
++	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
dap_sttnm	array
[	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pn	int
]	O
+	O
1	int
,	O
"%lf"	pointer
,	O
&	O
upct	array
[	O
pn	int
]	O
)	O
!=	O
1	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(pctile2) invalid percentile: %s\n"	pointer
,	O
dap_sttnm	array
[	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pn	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
pctpt	pointer
[	O
v	int
]	O
=	O
pctptmem	pointer
+	O
v	int
*	O
(	O
9	int
+	O
MAXPCTPT	int
)	O
;	O
excess	pointer
[	O
v	int
]	O
=	O
excessmem	pointer
+	O
v	int
*	O
(	O
9	int
+	O
MAXPCTPT	int
)	O
;	O
qsort	function
(	O
(	O
void	O
*	O
)	O
val	pointer
[	O
v	int
]	O
,	O
(	O
size_t	long
)	O
nobs	int
,	O
(	O
size_t	long
)	O
(	O
sizeof	O
(	O
double	O
*	O
)	O
)	O
,	O
dcmp	pointer
)	O
;	O
for	O
(	O
n	int
=	O
0	int
,	O
sumwt	double
=	O
0.0	int
;	O
n	int
<	O
nobs	int
;	O
n	int
++	O
)	O
sumwt	double
+=	O
val	pointer
[	O
v	int
]	O
[	O
n	int
]	O
[	O
1	int
]	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
9	int
+	O
pn	int
;	O
s	int
++	O
)	O
{	O
excess	pointer
[	O
v	int
]	O
[	O
s	int
]	O
=	O
0	int
;	O
pctpt	pointer
[	O
v	int
]	O
[	O
s	int
]	O
=	O
nobs	int
-	O
1	int
;	O
}	O
for	O
(	O
n	int
=	O
0	int
,	O
cumwt	double
=	O
0.0	int
;	O
n	int
<	O
nobs	int
;	O
n	int
++	O
,	O
cumwt	double
=	O
nextcum	double
)	O
{	O
nextcum	double
=	O
cumwt	double
+	O
val	pointer
[	O
v	int
]	O
[	O
n	int
]	O
[	O
1	int
]	O
;	O
pctpttest	function
(	O
sumwt	double
/	O
100.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	pointer
[	O
v	int
]	O
,	O
n	int
,	O
excess	pointer
[	O
v	int
]	O
)	O
;	O
pctpttest	function
(	O
sumwt	double
/	O
20.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	pointer
[	O
v	int
]	O
+	O
1	int
,	O
n	int
,	O
excess	pointer
[	O
v	int
]	O
+	O
1	int
)	O
;	O
pctpttest	function
(	O
sumwt	double
/	O
10.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	pointer
[	O
v	int
]	O
+	O
2	int
,	O
n	int
,	O
excess	pointer
[	O
v	int
]	O
+	O
2	int
)	O
;	O
pctpttest	function
(	O
sumwt	double
/	O
4.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	pointer
[	O
v	int
]	O
+	O
3	int
,	O
n	int
,	O
excess	pointer
[	O
v	int
]	O
+	O
3	int
)	O
;	O
pctpttest	function
(	O
sumwt	double
/	O
2.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	pointer
[	O
v	int
]	O
+	O
4	int
,	O
n	int
,	O
excess	pointer
[	O
v	int
]	O
+	O
4	int
)	O
;	O
pctpttest	function
(	O
3.0	int
*	O
sumwt	double
/	O
4.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	pointer
[	O
v	int
]	O
+	O
5	int
,	O
n	int
,	O
excess	pointer
[	O
v	int
]	O
+	O
5	int
)	O
;	O
pctpttest	function
(	O
9.0	int
*	O
sumwt	double
/	O
10.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	pointer
[	O
v	int
]	O
+	O
6	int
,	O
n	int
,	O
excess	pointer
[	O
v	int
]	O
+	O
6	int
)	O
;	O
pctpttest	function
(	O
95.0	int
*	O
sumwt	double
/	O
100.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	pointer
[	O
v	int
]	O
+	O
7	int
,	O
n	int
,	O
excess	pointer
[	O
v	int
]	O
+	O
7	int
)	O
;	O
pctpttest	function
(	O
99.0	int
*	O
sumwt	double
/	O
100.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	pointer
[	O
v	int
]	O
+	O
8	int
,	O
n	int
,	O
excess	pointer
[	O
v	int
]	O
+	O
8	int
)	O
;	O
for	O
(	O
pi	int
=	O
0	int
;	O
pi	int
<	O
pn	int
;	O
pi	int
++	O
)	O
{	O
pctpttest	function
(	O
upct	array
[	O
pi	int
]	O
*	O
sumwt	double
/	O
100.0	int
,	O
cumwt	double
,	O
nextcum	double
,	O
pctpt	pointer
[	O
v	int
]	O
+	O
9	int
+	O
pi	int
,	O
n	int
,	O
excess	pointer
[	O
v	int
]	O
+	O
9	int
+	O
pi	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
9	int
+	O
pn	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
stats	array
[	O
P1	O
+	O
s	int
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
ptindex	int
=	O
pctpt	pointer
[	O
v	int
]	O
[	O
s	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	pointer
[	O
v	int
]	O
[	O
s	int
]	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
v	int
]	O
[	O
s	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.5	int
*	O
(	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
v	int
]	O
[	O
s	int
]	O
]	O
[	O
0	int
]	O
+	O
val	pointer
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
}	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
dap_sttnm	array
[	O
P1	O
+	O
s	int
]	O
)	O
;	O
output	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
stats	array
[	O
N	int
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
(	O
double	O
)	O
nobs	int
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"N"	pointer
)	O
;	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
MIN	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
val	pointer
[	O
v	int
]	O
[	O
0	int
]	O
[	O
0	int
]	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"MIN"	pointer
)	O
;	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
MAX	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
val	pointer
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
[	O
0	int
]	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"MAX"	pointer
)	O
;	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
QRANGE	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
ptindex	int
=	O
pctpt	pointer
[	O
v	int
]	O
[	O
3	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	pointer
[	O
v	int
]	O
[	O
3	int
]	O
)	O
q1	double
=	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
v	int
]	O
[	O
3	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
q1	double
=	O
0.5	int
*	O
(	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
v	int
]	O
[	O
3	int
]	O
]	O
[	O
0	int
]	O
+	O
val	pointer
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
ptindex	int
=	O
pctpt	pointer
[	O
v	int
]	O
[	O
5	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	pointer
[	O
v	int
]	O
[	O
5	int
]	O
)	O
q3	double
=	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
v	int
]	O
[	O
5	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
q3	double
=	O
0.5	int
*	O
(	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
v	int
]	O
[	O
5	int
]	O
]	O
[	O
0	int
]	O
+	O
val	pointer
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
q3	double
-	O
q1	double
;	O
}	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"QRANGE"	pointer
)	O
;	O
output	function
(	O
)	O
;	O
}	O
dap_swap	function
(	O
)	O
;	O
dap_free	function
(	O
pctptmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
pctpt	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
excessmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
excess	pointer
,	O
""	pointer
)	O
;	O
}	O
static	O
void	O
pctile1	function
(	O
double	O
*	O
*	O
*	O
val	pointer
,	O
int	O
nobs	int
,	O
int	O
nvar	int
,	O
int	O
*	O
varv	array
,	O
int	O
*	O
stats	array
)	O
{	O
int	O
v	int
;	O
double	O
dnobs	double
;	O
static	O
int	O
pctpt	pointer
[	O
9	int
+	O
MAXPCTPT	int
]	O
;	O
int	O
pn	int
;	O
double	O
pct	double
;	O
static	O
int	O
excess	pointer
[	O
9	int
+	O
MAXPCTPT	int
]	O
;	O
int	O
ptindex	int
;	O
int	O
s	int
;	O
double	O
q1	double
,	O
q3	double
;	O
int	O
typen	int
;	O
dap_swap	function
(	O
)	O
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(pctile1) missing _type_ variable\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
dnobs	double
=	O
(	O
double	O
)	O
nobs	int
;	O
pctpt	pointer
[	O
0	int
]	O
=	O
(	O
int	O
)	O
floor	function
(	O
dnobs	double
/	O
100.0	int
)	O
;	O
excess	pointer
[	O
0	int
]	O
=	O
(	O
(	O
dnobs	double
/	O
100.0	int
)	O
>	O
floor	function
(	O
dnobs	double
/	O
100.0	int
)	O
)	O
;	O
pctpt	pointer
[	O
1	int
]	O
=	O
(	O
int	O
)	O
floor	function
(	O
dnobs	double
/	O
20.0	int
)	O
;	O
excess	pointer
[	O
1	int
]	O
=	O
(	O
(	O
dnobs	double
/	O
20.0	int
)	O
>	O
floor	function
(	O
dnobs	double
/	O
20.0	int
)	O
)	O
;	O
pctpt	pointer
[	O
2	int
]	O
=	O
(	O
int	O
)	O
floor	function
(	O
dnobs	double
/	O
10.0	int
)	O
;	O
excess	pointer
[	O
2	int
]	O
=	O
(	O
(	O
dnobs	double
/	O
10.0	int
)	O
>	O
floor	function
(	O
dnobs	double
/	O
10.0	int
)	O
)	O
;	O
pctpt	pointer
[	O
3	int
]	O
=	O
(	O
int	O
)	O
floor	function
(	O
dnobs	double
/	O
4.0	int
)	O
;	O
excess	pointer
[	O
3	int
]	O
=	O
(	O
(	O
dnobs	double
/	O
4.0	int
)	O
>	O
floor	function
(	O
dnobs	double
/	O
4.0	int
)	O
)	O
;	O
pctpt	pointer
[	O
4	int
]	O
=	O
(	O
int	O
)	O
floor	function
(	O
dnobs	double
/	O
2.0	int
)	O
;	O
excess	pointer
[	O
4	int
]	O
=	O
(	O
(	O
dnobs	double
/	O
2.0	int
)	O
>	O
floor	function
(	O
dnobs	double
/	O
2.0	int
)	O
)	O
;	O
pctpt	pointer
[	O
5	int
]	O
=	O
(	O
int	O
)	O
floor	function
(	O
3.0	int
*	O
dnobs	double
/	O
4.0	int
)	O
;	O
excess	pointer
[	O
5	int
]	O
=	O
(	O
(	O
3.0	int
*	O
dnobs	double
/	O
4.0	int
)	O
>	O
floor	function
(	O
3.0	int
*	O
dnobs	double
/	O
4.0	int
)	O
)	O
;	O
pctpt	pointer
[	O
6	int
]	O
=	O
(	O
int	O
)	O
floor	function
(	O
9.0	int
*	O
dnobs	double
/	O
10.0	int
)	O
;	O
excess	pointer
[	O
6	int
]	O
=	O
(	O
(	O
9.0	int
*	O
dnobs	double
/	O
10.0	int
)	O
>	O
floor	function
(	O
9.0	int
*	O
dnobs	double
/	O
10.0	int
)	O
)	O
;	O
pctpt	pointer
[	O
7	int
]	O
=	O
(	O
int	O
)	O
floor	function
(	O
95.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
;	O
excess	pointer
[	O
7	int
]	O
=	O
(	O
(	O
95.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
>	O
floor	function
(	O
95.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
)	O
;	O
pctpt	pointer
[	O
8	int
]	O
=	O
(	O
int	O
)	O
floor	function
(	O
99.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
;	O
excess	pointer
[	O
8	int
]	O
=	O
(	O
(	O
99.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
>	O
floor	function
(	O
99.0	int
*	O
dnobs	double
/	O
100.0	int
)	O
)	O
;	O
for	O
(	O
pn	int
=	O
0	int
;	O
pn	int
<	O
MAXPCTPT	int
&&	O
stats	array
[	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pn	int
]	O
;	O
pn	int
++	O
)	O
{	O
sscanf	function
(	O
dap_sttnm	array
[	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pn	int
]	O
+	O
1	int
,	O
"%lf"	pointer
,	O
&	O
pct	double
)	O
;	O
pctpt	pointer
[	O
9	int
+	O
pn	int
]	O
=	O
(	O
int	O
)	O
floor	function
(	O
pct	double
*	O
dnobs	double
/	O
100.0	int
)	O
;	O
excess	pointer
[	O
9	int
+	O
pn	int
]	O
=	O
(	O
(	O
pct	double
*	O
dnobs	double
/	O
100.0	int
)	O
>	O
floor	function
(	O
pct	double
*	O
dnobs	double
/	O
100.0	int
)	O
)	O
;	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
qsort	function
(	O
(	O
void	O
*	O
)	O
val	pointer
[	O
v	int
]	O
,	O
(	O
size_t	long
)	O
nobs	int
,	O
(	O
size_t	long
)	O
sizeof	O
(	O
double	O
*	O
)	O
,	O
dcmp	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
9	int
+	O
pn	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
stats	array
[	O
P1	O
+	O
s	int
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
ptindex	int
=	O
pctpt	pointer
[	O
s	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	pointer
[	O
s	int
]	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
s	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.5	int
*	O
(	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
s	int
]	O
]	O
[	O
0	int
]	O
+	O
val	pointer
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
}	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
dap_sttnm	array
[	O
P1	O
+	O
s	int
]	O
)	O
;	O
output	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
stats	array
[	O
N	int
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
dnobs	double
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"N"	pointer
)	O
;	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
MIN	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
val	pointer
[	O
v	int
]	O
[	O
0	int
]	O
[	O
0	int
]	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"MIN"	pointer
)	O
;	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
MAX	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
val	pointer
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
[	O
0	int
]	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"MAX"	pointer
)	O
;	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
RANGE	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
val	pointer
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
[	O
0	int
]	O
-	O
val	pointer
[	O
v	int
]	O
[	O
0	int
]	O
[	O
0	int
]	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"RANGE"	pointer
)	O
;	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
QRANGE	O
]	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
ptindex	int
=	O
pctpt	pointer
[	O
3	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	pointer
[	O
3	int
]	O
)	O
q1	double
=	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
3	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
q1	double
=	O
0.5	int
*	O
(	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
3	int
]	O
]	O
[	O
0	int
]	O
+	O
val	pointer
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
ptindex	int
=	O
pctpt	pointer
[	O
5	int
]	O
-	O
1	int
;	O
if	O
(	O
ptindex	int
<	O
0	int
)	O
ptindex	int
=	O
0	int
;	O
if	O
(	O
excess	pointer
[	O
5	int
]	O
)	O
q3	double
=	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
5	int
]	O
]	O
[	O
0	int
]	O
;	O
else	O
q3	double
=	O
0.5	int
*	O
(	O
val	pointer
[	O
v	int
]	O
[	O
pctpt	pointer
[	O
5	int
]	O
]	O
[	O
0	int
]	O
+	O
val	pointer
[	O
v	int
]	O
[	O
ptindex	int
]	O
[	O
0	int
]	O
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
q3	double
-	O
q1	double
;	O
}	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"QRANGE"	pointer
)	O
;	O
output	function
(	O
)	O
;	O
}	O
dap_swap	function
(	O
)	O
;	O
}	O
void	O
pctiles	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
varlist	array
,	O
char	O
*	O
statlist	array
,	O
char	O
*	O
marks	array
)	O
{	O
char	O
*	O
outname	pointer
;	O
int	O
stats	array
[	O
NSTATS	O
]	O
;	O
int	O
*	O
varv	array
;	O
int	O
*	O
markv	array
;	O
int	O
nvar	int
;	O
int	O
nmark	int
;	O
int	O
nobs	int
;	O
char	O
*	O
outlist	pointer
;	O
int	O
*	O
wtvar	pointer
;	O
int	O
v	int
;	O
double	O
*	O
valmem	pointer
;	O
double	O
*	O
*	O
valpair	pointer
;	O
double	O
*	O
*	O
*	O
val	pointer
;	O
int	O
weighted	int
;	O
int	O
more	int
;	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(pctiles) No dataset name given.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
outname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
dap_suffix	function
(	O
outname	pointer
,	O
fname	array
,	O
".pct"	pointer
)	O
;	O
varv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
markv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
wtvar	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
outlist	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
dap_stats	function
(	O
statlist	array
,	O
stats	array
)	O
;	O
nvar	int
=	O
dap_mnsparse	function
(	O
varlist	array
,	O
outlist	pointer
,	O
varv	array
,	O
wtvar	pointer
,	O
stats	array
)	O
;	O
if	O
(	O
marks	array
&&	O
marks	array
[	O
0	int
]	O
)	O
{	O
strcat	function
(	O
outlist	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
outlist	pointer
,	O
marks	array
)	O
;	O
}	O
outset	function
(	O
outname	pointer
,	O
outlist	pointer
)	O
;	O
nmark	int
=	O
dap_list	function
(	O
marks	array
,	O
markv	array
,	O
dap_maxvar	int
)	O
;	O
valmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
2	int
*	O
dap_maxval	int
,	O
""	pointer
)	O
;	O
valpair	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nvar	int
*	O
dap_maxval	int
,	O
""	pointer
)	O
;	O
val	pointer
=	O
(	O
double	O
*	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
,	O
weighted	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
wtvar	pointer
[	O
v	int
]	O
>=	O
0	int
)	O
weighted	int
=	O
1	int
;	O
}	O
for	O
(	O
nobs	int
=	O
0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
nobs	int
++	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
if	O
(	O
weighted	int
)	O
pctile2	function
(	O
val	pointer
,	O
nobs	int
,	O
nvar	int
,	O
varv	array
,	O
wtvar	pointer
,	O
stats	array
)	O
;	O
else	O
pctile1	function
(	O
val	pointer
,	O
nobs	int
,	O
nvar	int
,	O
varv	array
,	O
stats	array
)	O
;	O
nobs	int
=	O
0	int
;	O
}	O
if	O
(	O
more	int
)	O
{	O
if	O
(	O
nobs	int
<	O
dap_maxval	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
valpair	pointer
[	O
dap_maxval	int
*	O
v	int
+	O
nobs	int
]	O
=	O
valmem	pointer
+	O
2	int
*	O
(	O
dap_maxval	int
*	O
v	int
+	O
nobs	int
)	O
;	O
val	pointer
[	O
v	int
]	O
=	O
valpair	pointer
+	O
v	int
*	O
dap_maxval	int
;	O
val	pointer
[	O
v	int
]	O
[	O
nobs	int
]	O
[	O
0	int
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
;	O
if	O
(	O
wtvar	pointer
[	O
v	int
]	O
>=	O
0	int
)	O
val	pointer
[	O
v	int
]	O
[	O
nobs	int
]	O
[	O
1	int
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
wtvar	pointer
[	O
v	int
]	O
]	O
;	O
else	O
val	pointer
[	O
v	int
]	O
[	O
nobs	int
]	O
[	O
1	int
]	O
=	O
1.0	int
;	O
if	O
(	O
!	O
finite	function
(	O
val	pointer
[	O
v	int
]	O
[	O
nobs	int
]	O
[	O
0	int
]	O
)	O
||	O
!	O
finite	function
(	O
val	pointer
[	O
v	int
]	O
[	O
nobs	int
]	O
[	O
1	int
]	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(pctiles) NaN value %d for %s\n"	pointer
,	O
nobs	int
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
fputs	function
(	O
"(pctiles) Too many data.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
dap_free	function
(	O
outname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
markv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
wtvar	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
outlist	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
valmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
valpair	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
val	pointer
,	O
""	pointer
)	O
;	O
}	O
static	O
void	O
corr1	function
(	O
int	O
*	O
varv	array
,	O
int	O
nvar	int
,	O
double	O
*	O
*	O
cormat	pointer
,	O
double	O
ss	array
[	O
]	O
,	O
int	O
nobs	int
)	O
{	O
int	O
varn	array
[	O
3	int
]	O
;	O
int	O
typen	int
;	O
double	O
nf	double
;	O
int	O
v	int
,	O
w	int
;	O
double	O
r	double
;	O
if	O
(	O
nobs	int
<	O
2	int
)	O
return	O
;	O
dap_swap	function
(	O
)	O
;	O
nf	double
=	O
sqrt	function
(	O
(	O
double	O
)	O
(	O
nobs	int
-	O
2	int
)	O
)	O
;	O
varn	array
[	O
0	int
]	O
=	O
dap_varnum	function
(	O
"_var1_"	pointer
)	O
;	O
varn	array
[	O
1	int
]	O
=	O
dap_varnum	function
(	O
"_var2_"	pointer
)	O
;	O
varn	array
[	O
2	int
]	O
=	O
dap_varnum	function
(	O
"_corr_"	pointer
)	O
;	O
typen	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
v	int
;	O
w	int
++	O
)	O
cormat	pointer
[	O
v	int
]	O
[	O
w	int
]	O
=	O
cormat	pointer
[	O
w	int
]	O
[	O
v	int
]	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"N"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
varn	array
[	O
0	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
varn	array
[	O
1	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
w	int
]	O
]	O
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varn	array
[	O
2	int
]	O
]	O
=	O
(	O
double	O
)	O
nobs	int
;	O
output	function
(	O
)	O
;	O
}	O
}	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"CORR"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
varn	array
[	O
0	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
varn	array
[	O
1	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
w	int
]	O
]	O
)	O
;	O
if	O
(	O
w	int
==	O
v	int
)	O
cormat	pointer
[	O
v	int
]	O
[	O
w	int
]	O
=	O
1.0	int
;	O
else	O
cormat	pointer
[	O
v	int
]	O
[	O
w	int
]	O
/=	O
sqrt	function
(	O
ss	array
[	O
v	int
]	O
*	O
ss	array
[	O
w	int
]	O
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varn	array
[	O
2	int
]	O
]	O
=	O
cormat	pointer
[	O
v	int
]	O
[	O
w	int
]	O
;	O
output	function
(	O
)	O
;	O
}	O
}	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"PCORR"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
varn	array
[	O
0	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
for	O
(	O
w	int
=	O
0	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
varn	array
[	O
1	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
w	int
]	O
]	O
)	O
;	O
r	double
=	O
fabs	function
(	O
cormat	pointer
[	O
v	int
]	O
[	O
w	int
]	O
)	O
;	O
if	O
(	O
r	double
==	O
1.0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varn	array
[	O
2	int
]	O
]	O
=	O
0.0	int
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varn	array
[	O
2	int
]	O
]	O
=	O
2.0	int
*	O
probt	function
(	O
nf	double
*	O
r	double
/	O
sqrt	function
(	O
1.0	int
-	O
r	double
*	O
r	double
)	O
,	O
nobs	int
-	O
2	int
)	O
;	O
output	function
(	O
)	O
;	O
}	O
}	O
dap_swap	function
(	O
)	O
;	O
}	O
void	O
corr	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
varlist	array
,	O
char	O
*	O
marks	array
)	O
{	O
char	O
*	O
outname	pointer
;	O
char	O
varstr	array
[	O
11	int
]	O
;	O
char	O
*	O
outlist	pointer
;	O
int	O
*	O
markv	array
;	O
int	O
nmark	int
;	O
int	O
*	O
varv	array
;	O
int	O
nvar	int
;	O
int	O
nobs	int
;	O
double	O
*	O
cormem	pointer
;	O
double	O
*	O
*	O
cormat	pointer
;	O
int	O
v	int
,	O
w	int
;	O
double	O
*	O
sum	pointer
;	O
double	O
*	O
ss	array
;	O
double	O
vtmp	double
;	O
double	O
tmp	double
;	O
double	O
dn	double
;	O
int	O
more	int
;	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(corr) No dataset name given.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
markv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
varv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
outname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
dap_suffix	function
(	O
outname	pointer
,	O
fname	array
,	O
".cor"	pointer
)	O
;	O
outlist	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
marks	array
)	O
+	O
22	int
,	O
""	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
nvar	int
=	O
dap_list	function
(	O
varlist	array
,	O
varv	array
,	O
dap_maxvar	int
)	O
;	O
cormem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
nvar	int
,	O
""	pointer
)	O
;	O
cormat	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
cormat	pointer
[	O
v	int
]	O
=	O
cormem	pointer
+	O
v	int
*	O
nvar	int
;	O
sum	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
ss	array
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
outlist	pointer
,	O
marks	array
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
>=	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(corr) Variable not of type dap_double: %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
sprintf	function
(	O
varstr	array
,	O
"_var1_ %d"	pointer
,	O
dap_namelen	int
)	O
;	O
dap_vd	function
(	O
varstr	array
,	O
0	int
)	O
;	O
sprintf	function
(	O
varstr	array
,	O
"_var2_ %d"	pointer
,	O
dap_namelen	int
)	O
;	O
dap_vd	function
(	O
varstr	array
,	O
0	int
)	O
;	O
sprintf	function
(	O
varstr	array
,	O
"_corr_ %d"	pointer
,	O
DBL	O
)	O
;	O
dap_vd	function
(	O
varstr	array
,	O
0	int
)	O
;	O
strcat	function
(	O
outlist	pointer
,	O
" _var1_ _var2_ _corr_"	pointer
)	O
;	O
outset	function
(	O
outname	pointer
,	O
outlist	pointer
)	O
;	O
nmark	int
=	O
dap_list	function
(	O
marks	array
,	O
markv	array
,	O
dap_maxvar	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
!=	O
DBL	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(corr) variables must be of type double: %s\n"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
w	int
=	O
v	int
+	O
1	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
cormat	pointer
[	O
v	int
]	O
[	O
w	int
]	O
=	O
0.0	int
;	O
sum	pointer
[	O
v	int
]	O
=	O
0.0	int
;	O
ss	array
[	O
v	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
nobs	int
=	O
0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
nobs	int
++	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
corr1	function
(	O
varv	array
,	O
nvar	int
,	O
cormat	pointer
,	O
ss	array
,	O
nobs	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
w	int
=	O
v	int
+	O
1	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
cormat	pointer
[	O
v	int
]	O
[	O
w	int
]	O
=	O
0.0	int
;	O
sum	pointer
[	O
v	int
]	O
=	O
0.0	int
;	O
ss	array
[	O
v	int
]	O
=	O
0.0	int
;	O
}	O
nobs	int
=	O
0	int
;	O
}	O
if	O
(	O
more	int
)	O
{	O
dn	double
=	O
(	O
double	O
)	O
nobs	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
vtmp	double
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
;	O
if	O
(	O
!	O
finite	function
(	O
vtmp	double
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(corr) NaN value %d for %s\n"	pointer
,	O
nobs	int
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
nobs	int
)	O
{	O
tmp	double
=	O
sum	pointer
[	O
v	int
]	O
-	O
dn	double
*	O
vtmp	double
;	O
for	O
(	O
w	int
=	O
v	int
+	O
1	int
;	O
w	int
<	O
nvar	int
;	O
w	int
++	O
)	O
{	O
cormat	pointer
[	O
v	int
]	O
[	O
w	int
]	O
+=	O
tmp	double
*	O
(	O
sum	pointer
[	O
w	int
]	O
-	O
dn	double
*	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
w	int
]	O
]	O
)	O
/	O
(	O
dn	double
*	O
(	O
dn	double
+	O
1.0	int
)	O
)	O
;	O
}	O
ss	array
[	O
v	int
]	O
+=	O
tmp	double
*	O
tmp	double
/	O
(	O
dn	double
*	O
(	O
dn	double
+	O
1.0	int
)	O
)	O
;	O
}	O
sum	pointer
[	O
v	int
]	O
+=	O
vtmp	double
;	O
}	O
}	O
}	O
dap_free	function
(	O
markv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
outname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
outlist	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
cormem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
cormat	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
sum	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
ss	array
,	O
""	pointer
)	O
;	O
}	O
static	O
int	O
groupparse	function
(	O
char	O
*	O
varspec	array
,	O
int	O
varv	array
[	O
]	O
,	O
int	O
classtype	array
[	O
]	O
)	O
{	O
int	O
s	int
;	O
int	O
i	int
;	O
int	O
v	int
;	O
char	O
*	O
varname	pointer
;	O
int	O
n	int
;	O
int	O
nvar	int
;	O
int	O
number	int
;	O
if	O
(	O
!	O
varspec	array
)	O
return	O
0	int
;	O
varname	pointer
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
varspec	array
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
nvar	int
=	O
0	int
,	O
number	int
=	O
0	int
;	O
varspec	array
[	O
s	int
]	O
;	O
)	O
{	O
classtype	array
[	O
nvar	int
]	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
varspec	array
[	O
s	int
+	O
i	int
]	O
&&	O
varspec	array
[	O
s	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
varname	pointer
[	O
i	int
]	O
=	O
varspec	array
[	O
s	int
+	O
i	int
]	O
;	O
else	O
{	O
varname	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(groupparse) variable name too long: %s\n"	pointer
,	O
varname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
varname	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
s	int
+=	O
i	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
varname	pointer
)	O
)	O
>=	O
0	int
)	O
{	O
varv	array
[	O
nvar	int
]	O
=	O
v	int
;	O
while	O
(	O
varspec	array
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
if	O
(	O
number	int
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
!=	O
DBL	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(groupparse) grouping variable must be of type double: %s\n"	pointer
,	O
varname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
'0'	O
<=	O
varspec	array
[	O
s	int
]	O
&&	O
varspec	array
[	O
s	int
]	O
<=	O
'9'	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
==	O
DBL	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
,	O
i	int
=	O
0	int
;	O
'0'	O
<=	O
varspec	array
[	O
s	int
+	O
i	int
]	O
&&	O
varspec	array
[	O
s	int
+	O
i	int
]	O
<=	O
'9'	O
;	O
i	int
++	O
)	O
n	int
=	O
10	int
*	O
n	int
+	O
varspec	array
[	O
s	int
+	O
i	int
]	O
-	O
'0'	O
;	O
if	O
(	O
!	O
n	int
||	O
(	O
varspec	array
[	O
s	int
+	O
i	int
]	O
!=	O
'#'	O
&&	O
varspec	array
[	O
s	int
+	O
i	int
]	O
!=	O
'^'	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(groupparse) invalid number of groups: %s\n"	pointer
,	O
varspec	array
+	O
s	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
switch	O
(	O
varspec	array
[	O
s	int
+	O
i	int
]	O
)	O
{	O
case	O
'^'	O
:	O
classtype	array
[	O
nvar	int
]	O
=	O
-	O
n	int
;	O
break	O
;	O
case	O
'#'	O
:	O
classtype	array
[	O
nvar	int
]	O
=	O
n	int
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
dap_err	pointer
,	O
"(groupparse) invalid class type: %s\n"	pointer
,	O
varspec	array
+	O
s	int
+	O
i	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
s	int
+=	O
i	int
+	O
1	int
;	O
while	O
(	O
varspec	array
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
if	O
(	O
n	int
>	O
dap_maxbars	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(groupparse) too many classes: %d\n"	pointer
,	O
n	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(groupparse) grouping variable must be of type double: %s\n"	pointer
,	O
varname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(groupparse) missing number of groups for %s\n"	pointer
,	O
varname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
nvar	int
++	O
;	O
}	O
else	O
if	O
(	O
number	int
<	O
0	int
)	O
{	O
if	O
(	O
varname	pointer
[	O
0	int
]	O
==	O
'-'	O
)	O
classtype	array
[	O
0	int
]	O
|=	O
GRPDESC	int
;	O
if	O
(	O
varname	pointer
[	O
1	int
]	O
==	O
'0'	O
)	O
classtype	array
[	O
0	int
]	O
|=	O
GRP0	int
;	O
}	O
else	O
if	O
(	O
!	O
nvar	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
varname	pointer
,	O
"#"	pointer
)	O
)	O
number	int
=	O
GRPNUMBER	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
varname	pointer
,	O
"/"	pointer
)	O
)	O
number	int
=	O
GRPFRACTION	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
varname	pointer
,	O
"%"	pointer
)	O
)	O
number	int
=	O
GRPPERCENT	O
;	O
classtype	array
[	O
0	int
]	O
=	O
0	int
;	O
nvar	int
++	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(groupparse) unknown variable: %s\n"	pointer
,	O
varname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
varspec	array
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
}	O
dap_free	function
(	O
varname	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
number	int
<	O
0	int
)	O
return	O
-	O
4	int
*	O
nvar	int
+	O
number	int
;	O
return	O
nvar	int
;	O
}	O
static	O
void	O
getpoints	function
(	O
double	O
*	O
*	O
numval	pointer
,	O
int	O
nonum	int
,	O
int	O
*	O
ctype	pointer
,	O
int	O
nobs	int
,	O
double	O
*	O
*	O
point	pointer
)	O
{	O
int	O
v	int
;	O
double	O
width	double
;	O
int	O
p	double
;	O
int	O
index	function
;	O
double	O
excess	pointer
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nonum	int
;	O
v	int
++	O
)	O
{	O
qsort	function
(	O
(	O
void	O
*	O
)	O
numval	pointer
[	O
v	int
]	O
,	O
(	O
size_t	long
)	O
nobs	int
,	O
(	O
size_t	long
)	O
sizeof	O
(	O
double	O
)	O
,	O
cmp	pointer
)	O
;	O
if	O
(	O
ctype	pointer
[	O
v	int
]	O
<	O
0	int
)	O
{	O
width	double
=	O
(	O
numval	pointer
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
-	O
numval	pointer
[	O
v	int
]	O
[	O
0	int
]	O
)	O
/	O
(	O
(	O
double	O
)	O
-	O
ctype	pointer
[	O
v	int
]	O
)	O
;	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
-	O
ctype	pointer
[	O
v	int
]	O
;	O
p	double
++	O
)	O
point	pointer
[	O
v	int
]	O
[	O
p	double
]	O
=	O
numval	pointer
[	O
v	int
]	O
[	O
0	int
]	O
+	O
(	O
(	O
double	O
)	O
p	double
)	O
*	O
width	double
;	O
point	pointer
[	O
v	int
]	O
[	O
p	double
]	O
=	O
numval	pointer
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
;	O
}	O
else	O
if	O
(	O
ctype	pointer
[	O
v	int
]	O
>	O
0	int
)	O
{	O
for	O
(	O
p	double
=	O
0	int
;	O
p	double
<	O
ctype	pointer
[	O
v	int
]	O
;	O
p	double
++	O
)	O
{	O
index	function
=	O
(	O
int	O
)	O
floor	function
(	O
(	O
(	O
double	O
)	O
(	O
p	double
*	O
nobs	int
)	O
)	O
/	O
(	O
(	O
double	O
)	O
ctype	pointer
[	O
v	int
]	O
)	O
)	O
;	O
excess	pointer
=	O
(	O
(	O
double	O
)	O
(	O
p	double
*	O
nobs	int
)	O
)	O
/	O
(	O
(	O
double	O
)	O
ctype	pointer
[	O
v	int
]	O
)	O
-	O
(	O
double	O
)	O
index	function
;	O
if	O
(	O
excess	pointer
>	O
0.0	int
&&	O
index	function
<	O
nobs	int
-	O
1	int
)	O
point	pointer
[	O
v	int
]	O
[	O
p	double
]	O
=	O
0.5	int
*	O
(	O
numval	pointer
[	O
v	int
]	O
[	O
index	function
]	O
+	O
numval	pointer
[	O
v	int
]	O
[	O
index	function
+	O
1	int
]	O
)	O
;	O
else	O
point	pointer
[	O
v	int
]	O
[	O
p	double
]	O
=	O
numval	pointer
[	O
v	int
]	O
[	O
(	O
int	O
)	O
rint	function
(	O
(	O
(	O
double	O
)	O
(	O
p	double
*	O
nobs	int
)	O
)	O
/	O
(	O
(	O
double	O
)	O
ctype	pointer
[	O
v	int
]	O
)	O
)	O
]	O
;	O
}	O
point	pointer
[	O
v	int
]	O
[	O
p	double
]	O
=	O
numval	pointer
[	O
v	int
]	O
[	O
nobs	int
-	O
1	int
]	O
;	O
}	O
}	O
}	O
void	O
group	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
varspec	array
,	O
char	O
*	O
marks	array
)	O
{	O
char	O
*	O
outname	pointer
;	O
int	O
*	O
markv	array
;	O
int	O
nmark	int
;	O
int	O
*	O
varv	array
;	O
int	O
*	O
ctype	pointer
;	O
double	O
*	O
nummem	pointer
;	O
double	O
*	O
*	O
numval	pointer
;	O
int	O
nvar	int
;	O
int	O
number	int
;	O
int	O
v	int
;	O
char	O
*	O
grpname	pointer
;	O
int	O
*	O
grpv	pointer
;	O
int	O
nobs	int
;	O
int	O
nnan	int
;	O
int	O
allgood	int
;	O
double	O
*	O
ptmem	pointer
;	O
double	O
*	O
*	O
point	pointer
;	O
double	O
dnobs	double
;	O
double	O
count	double
;	O
double	O
countinc	double
;	O
int	O
p	double
;	O
int	O
more	int
;	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(group) No dataset name given.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
outname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
dap_suffix	function
(	O
outname	pointer
,	O
fname	array
,	O
".grp"	pointer
)	O
;	O
grpname	pointer
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
3	int
,	O
""	pointer
)	O
;	O
markv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
varv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
ctype	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
nmark	int
=	O
dap_list	function
(	O
marks	array
,	O
markv	array
,	O
dap_maxvar	int
)	O
;	O
nvar	int
=	O
groupparse	function
(	O
varspec	array
,	O
varv	array
,	O
ctype	pointer
)	O
;	O
if	O
(	O
nvar	int
<	O
0	int
)	O
{	O
number	int
=	O
-	O
(	O
(	O
-	O
nvar	int
)	O
%	O
4	int
)	O
;	O
nvar	int
=	O
-	O
(	O
nvar	int
-	O
number	int
)	O
/	O
4	int
;	O
}	O
else	O
number	int
=	O
0	int
;	O
grpv	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
(	O
number	int
?	O
1	int
:	O
nvar	int
)	O
,	O
""	pointer
)	O
;	O
if	O
(	O
!	O
number	int
)	O
{	O
strcpy	function
(	O
grpname	pointer
,	O
"_"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
strcpy	function
(	O
grpname	pointer
+	O
1	int
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
grpname	pointer
[	O
dap_namelen	int
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
grpname	pointer
,	O
" -1"	pointer
)	O
;	O
grpv	pointer
[	O
v	int
]	O
=	O
dap_vd	function
(	O
grpname	pointer
,	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
grpv	pointer
[	O
0	int
]	O
=	O
dap_vd	function
(	O
"_N_ -1"	pointer
,	O
0	int
)	O
;	O
varv	array
[	O
0	int
]	O
=	O
grpv	pointer
[	O
0	int
]	O
;	O
}	O
outset	function
(	O
outname	pointer
,	O
""	pointer
)	O
;	O
nummem	pointer
=	O
NULL	O
;	O
numval	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
number	int
)	O
{	O
nummem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
dap_maxval	int
,	O
"dap_maxval"	pointer
)	O
;	O
numval	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
nvar	int
*	O
dap_maxval	int
*	O
sizeof	O
(	O
double	O
*	O
)	O
,	O
"dap_maxval"	pointer
)	O
;	O
ptmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
(	O
dap_maxbars	int
+	O
1	int
)	O
,	O
"dap_maxbars"	pointer
)	O
;	O
point	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
numval	pointer
[	O
v	int
]	O
=	O
nummem	pointer
+	O
v	int
*	O
dap_maxval	int
;	O
point	pointer
[	O
v	int
]	O
=	O
ptmem	pointer
+	O
v	int
*	O
(	O
dap_maxbars	int
+	O
1	int
)	O
;	O
}	O
}	O
for	O
(	O
dap_mark	function
(	O
)	O
,	O
nobs	int
=	O
0	int
,	O
nnan	int
=	O
0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
if	O
(	O
!	O
number	int
)	O
getpoints	function
(	O
numval	pointer
,	O
nvar	int
,	O
ctype	pointer
,	O
nobs	int
,	O
point	pointer
)	O
;	O
dnobs	double
=	O
(	O
double	O
)	O
nobs	int
;	O
dap_rewind	function
(	O
)	O
;	O
count	double
=	O
1.0	int
;	O
countinc	double
=	O
1.0	int
;	O
if	O
(	O
nnan	int
>	O
0	int
)	O
fprintf	function
(	O
dap_log	pointer
,	O
"(group) %d NaNs\n"	pointer
,	O
nnan	int
)	O
;	O
if	O
(	O
number	int
)	O
{	O
if	O
(	O
ctype	pointer
[	O
0	int
]	O
&	O
GRP0	int
)	O
count	double
=	O
0.0	int
;	O
if	O
(	O
ctype	pointer
[	O
0	int
]	O
&	O
GRPDESC	int
)	O
{	O
countinc	double
=	O
-	O
1.0	int
;	O
count	double
=	O
dnobs	double
-	O
1.0	int
+	O
count	double
;	O
}	O
}	O
for	O
(	O
;	O
step	function
(	O
)	O
&&	O
!	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
;	O
)	O
{	O
if	O
(	O
number	int
)	O
{	O
for	O
(	O
v	int
=	O
1	int
,	O
allgood	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
finite	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
)	O
{	O
allgood	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
allgood	int
)	O
{	O
switch	O
(	O
number	int
)	O
{	O
case	O
GRPNUMBER	O
:	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
grpv	pointer
[	O
0	int
]	O
]	O
=	O
count	double
;	O
break	O
;	O
case	O
GRPFRACTION	O
:	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
grpv	pointer
[	O
0	int
]	O
]	O
=	O
count	double
/	O
dnobs	double
;	O
break	O
;	O
case	O
GRPPERCENT	O
:	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
grpv	pointer
[	O
0	int
]	O
]	O
=	O
100.0	int
*	O
count	double
/	O
dnobs	double
;	O
break	O
;	O
}	O
count	double
+=	O
countinc	double
;	O
}	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
grpv	pointer
[	O
0	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
else	O
{	O
for	O
(	O
v	int
=	O
0	int
,	O
allgood	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
finite	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
)	O
{	O
allgood	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
allgood	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
p	double
=	O
1	int
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
>	O
point	pointer
[	O
v	int
]	O
[	O
p	double
]	O
;	O
p	double
++	O
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
grpv	pointer
[	O
v	int
]	O
]	O
=	O
(	O
double	O
)	O
p	double
;	O
}	O
}	O
else	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
grpv	pointer
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
dap_mark	function
(	O
)	O
;	O
}	O
nobs	int
=	O
0	int
;	O
nnan	int
=	O
0	int
;	O
}	O
if	O
(	O
number	int
)	O
{	O
for	O
(	O
v	int
=	O
1	int
,	O
allgood	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
finite	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
)	O
{	O
allgood	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
allgood	int
)	O
nobs	int
++	O
;	O
else	O
nnan	int
++	O
;	O
}	O
else	O
{	O
if	O
(	O
nobs	int
<	O
dap_maxval	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
,	O
allgood	int
=	O
1	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
finite	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
)	O
{	O
allgood	int
=	O
0	int
;	O
break	O
;	O
}	O
numval	pointer
[	O
v	int
]	O
[	O
nobs	int
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
;	O
}	O
if	O
(	O
allgood	int
)	O
nobs	int
++	O
;	O
else	O
nnan	int
++	O
;	O
}	O
else	O
{	O
fputs	function
(	O
"(group) too many data.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
number	int
)	O
{	O
dap_free	function
(	O
nummem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
numval	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
ptmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
point	pointer
,	O
""	pointer
)	O
;	O
}	O
dap_free	function
(	O
outname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
grpname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
grpv	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
markv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
ctype	pointer
,	O
""	pointer
)	O
;	O
}	O
static	O
void	O
freq1	function
(	O
int	O
*	O
varv	array
,	O
int	O
nvar	int
,	O
double	O
count	double
,	O
double	O
sumcount	double
,	O
int	O
*	O
statv	pointer
,	O
int	O
typen	int
,	O
int	O
celln	int
)	O
{	O
dap_swap	function
(	O
)	O
;	O
if	O
(	O
statv	pointer
[	O
FREQCNT	int
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"COUNT"	pointer
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
celln	int
]	O
=	O
count	double
;	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
statv	pointer
[	O
FREQPCT	int
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"PERCENT"	pointer
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
celln	int
]	O
=	O
100.0	int
*	O
count	double
/	O
sumcount	double
;	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
statv	pointer
[	O
FREQFRA	int
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"FRACTION"	pointer
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
celln	int
]	O
=	O
count	double
/	O
sumcount	double
;	O
output	function
(	O
)	O
;	O
}	O
dap_swap	function
(	O
)	O
;	O
}	O
static	O
void	O
statparse	function
(	O
char	O
*	O
stats	array
,	O
int	O
*	O
statv	pointer
)	O
{	O
int	O
s	int
;	O
int	O
i	int
;	O
char	O
*	O
stat	pointer
;	O
stat	pointer
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
NFREQSTAT	int
;	O
s	int
++	O
)	O
statv	pointer
[	O
s	int
]	O
=	O
0	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
stats	array
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
while	O
(	O
stats	array
[	O
s	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
stats	array
[	O
s	int
+	O
i	int
]	O
&&	O
stats	array
[	O
s	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
stat	pointer
[	O
i	int
]	O
=	O
stats	array
[	O
s	int
+	O
i	int
]	O
;	O
else	O
{	O
stat	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(statparse) Statistic name too long: %s\n"	pointer
,	O
stat	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
stat	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
s	int
+=	O
i	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"COUNT"	pointer
)	O
)	O
statv	pointer
[	O
FREQCNT	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"PERCENT"	pointer
)	O
)	O
statv	pointer
[	O
FREQPCT	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"ROWPERC"	pointer
)	O
)	O
statv	pointer
[	O
FREQROW	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"COLPERC"	pointer
)	O
)	O
statv	pointer
[	O
FREQCOL	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"FRACTION"	pointer
)	O
)	O
statv	pointer
[	O
FREQFRA	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"EXPECTED"	pointer
)	O
)	O
statv	pointer
[	O
FREQEXP	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"CHISQ"	pointer
)	O
)	O
statv	pointer
[	O
FREQCHISQ	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"ODDSRAT"	pointer
)	O
)	O
statv	pointer
[	O
FREQODDRAT	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"ORDINAL"	pointer
)	O
)	O
statv	pointer
[	O
FREQORD	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"FISHER"	pointer
)	O
)	O
statv	pointer
[	O
FREQFISHER	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"CMH"	pointer
)	O
)	O
statv	pointer
[	O
FREQCMH	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"PAIR"	pointer
)	O
)	O
statv	pointer
[	O
FREQPAIR	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	pointer
,	O
"NOMINAL"	pointer
)	O
)	O
statv	pointer
[	O
FREQNOM	int
]	O
=	O
1	int
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(statparse) Invalid statistic name: %s\n"	pointer
,	O
stat	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
stats	array
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
}	O
dap_free	function
(	O
stat	pointer
,	O
""	pointer
)	O
;	O
}	O
static	O
int	O
findlev	function
(	O
int	O
v	int
,	O
char	O
*	O
*	O
level	double
,	O
int	O
*	O
nlevels	pointer
)	O
{	O
int	O
l	int
;	O
static	O
char	O
*	O
str	array
=	O
NULL	O
;	O
char	O
*	O
s	int
;	O
if	O
(	O
!	O
str	array
)	O
str	array
=	O
dap_malloc	function
(	O
21	int
,	O
""	pointer
)	O
;	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
>	O
0	int
)	O
s	int
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
;	O
else	O
{	O
s	int
=	O
str	array
;	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
==	O
INT	int
)	O
sprintf	function
(	O
str	array
,	O
"%d"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
v	int
]	O
)	O
;	O
else	O
sprintf	function
(	O
str	array
,	O
"%g"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
v	int
]	O
)	O
;	O
}	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
*	O
nlevels	pointer
;	O
l	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
s	int
,	O
level	double
[	O
l	int
]	O
)	O
)	O
return	O
l	int
;	O
}	O
if	O
(	O
*	O
nlevels	pointer
<	O
dap_maxlev	int
)	O
{	O
strcpy	function
(	O
level	double
[	O
l	int
]	O
,	O
s	int
)	O
;	O
(	O
*	O
nlevels	pointer
)	O
++	O
;	O
return	O
l	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(findlev) Too many levels at: %s\n"	pointer
,	O
s	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
tabentry	function
(	O
int	O
*	O
varv	array
,	O
double	O
*	O
*	O
tab	pointer
,	O
char	O
*	O
*	O
level	double
[	O
2	int
]	O
,	O
int	O
nlevels	pointer
[	O
2	int
]	O
,	O
double	O
count	double
)	O
{	O
dap_swap	function
(	O
)	O
;	O
tab	pointer
[	O
findlev	function
(	O
varv	array
[	O
0	int
]	O
,	O
level	double
[	O
0	int
]	O
,	O
nlevels	pointer
)	O
]	O
[	O
findlev	function
(	O
varv	array
[	O
1	int
]	O
,	O
level	double
[	O
1	int
]	O
,	O
nlevels	pointer
+	O
1	int
)	O
]	O
=	O
count	double
;	O
dap_swap	function
(	O
)	O
;	O
}	O
static	O
void	O
valcpy	function
(	O
int	O
v	int
,	O
char	O
*	O
val	pointer
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
>	O
0	int
)	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
v	int
]	O
,	O
val	pointer
)	O
;	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
==	O
INT	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
v	int
]	O
=	O
atoi	function
(	O
val	pointer
)	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
v	int
]	O
=	O
atof	function
(	O
val	pointer
)	O
;	O
}	O
static	O
void	O
freq2	function
(	O
double	O
*	O
*	O
tab	pointer
,	O
char	O
*	O
*	O
level	double
[	O
2	int
]	O
,	O
int	O
nlevels	pointer
[	O
2	int
]	O
,	O
int	O
*	O
statv	pointer
,	O
int	O
*	O
markv	array
,	O
int	O
nmark	int
,	O
int	O
*	O
varv	array
,	O
int	O
typen	int
,	O
int	O
celln	int
)	O
{	O
int	O
v	int
;	O
int	O
l	int
;	O
double	O
*	O
expmem	pointer
;	O
double	O
*	O
*	O
expect	pointer
;	O
double	O
*	O
rowsum	pointer
;	O
double	O
*	O
colsum	pointer
;	O
double	O
sum	pointer
;	O
double	O
*	O
amem	pointer
;	O
double	O
*	O
*	O
a	double
;	O
double	O
*	O
dmem	pointer
;	O
double	O
*	O
*	O
d	pointer
;	O
double	O
p	double
,	O
q	double
;	O
double	O
tmp1	double
,	O
tmp2	double
,	O
tmp3	double
,	O
tmp4	double
;	O
double	O
w	int
;	O
double	O
t	double
;	O
double	O
var	double
;	O
int	O
r	double
,	O
c	int
;	O
double	O
diff	double
;	O
double	O
chisq	double
;	O
int	O
rr	int
,	O
cc	int
;	O
double	O
upleft	double
,	O
dnleft	double
;	O
double	O
denom	double
,	O
prob	double
,	O
oneprob	double
,	O
othprob	double
;	O
double	O
hx	double
,	O
hy	double
,	O
hxy	double
;	O
double	O
uv	double
;	O
sum	pointer
=	O
0.0	int
;	O
oneprob	double
=	O
0.0	int
;	O
expmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
expect	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
dap_maxlev	int
;	O
l	int
++	O
)	O
expect	pointer
[	O
l	int
]	O
=	O
expmem	pointer
+	O
l	int
*	O
dap_maxlev	int
;	O
rowsum	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
colsum	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
amem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
dmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
a	double
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
d	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
dap_maxlev	int
;	O
l	int
++	O
)	O
{	O
a	double
[	O
l	int
]	O
=	O
amem	pointer
+	O
l	int
*	O
dap_maxlev	int
;	O
d	pointer
[	O
l	int
]	O
=	O
dmem	pointer
+	O
l	int
*	O
dap_maxlev	int
;	O
}	O
dap_swap	function
(	O
)	O
;	O
if	O
(	O
statv	pointer
[	O
FREQCHISQ	int
]	O
||	O
statv	pointer
[	O
FREQODDRAT	int
]	O
||	O
statv	pointer
[	O
FREQORD	int
]	O
||	O
statv	pointer
[	O
FREQFISHER	int
]	O
||	O
statv	pointer
[	O
FREQPAIR	int
]	O
||	O
statv	pointer
[	O
FREQNOM	int
]	O
)	O
{	O
dap_head	function
(	O
markv	array
,	O
nmark	int
)	O
;	O
fputs	function
(	O
"Variable: Levels\n"	pointer
,	O
dap_lst	pointer
)	O
;	O
fputs	function
(	O
"----------------\n"	pointer
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
2	int
;	O
v	int
++	O
)	O
{	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%s:"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
nlevels	pointer
[	O
v	int
]	O
;	O
l	int
++	O
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
" %s"	pointer
,	O
level	double
[	O
v	int
]	O
[	O
l	int
]	O
)	O
;	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
if	O
(	O
statv	pointer
[	O
FREQEXP	int
]	O
||	O
statv	pointer
[	O
FREQCHISQ	int
]	O
||	O
statv	pointer
[	O
FREQORD	int
]	O
||	O
statv	pointer
[	O
FREQFISHER	int
]	O
||	O
statv	pointer
[	O
FREQROW	int
]	O
||	O
statv	pointer
[	O
FREQCOL	int
]	O
||	O
statv	pointer
[	O
FREQPAIR	int
]	O
||	O
statv	pointer
[	O
FREQNOM	int
]	O
)	O
{	O
for	O
(	O
r	double
=	O
0	int
,	O
sum	pointer
=	O
0.0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
{	O
rowsum	pointer
[	O
r	double
]	O
=	O
0.0	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
rowsum	pointer
[	O
r	double
]	O
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
;	O
sum	pointer
+=	O
rowsum	pointer
[	O
r	double
]	O
;	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
colsum	pointer
[	O
c	int
]	O
=	O
0.0	int
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
colsum	pointer
[	O
c	int
]	O
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
;	O
}	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
expect	pointer
[	O
r	double
]	O
[	O
c	int
]	O
=	O
rowsum	pointer
[	O
r	double
]	O
*	O
colsum	pointer
[	O
c	int
]	O
/	O
sum	pointer
;	O
}	O
if	O
(	O
statv	pointer
[	O
FREQEXP	int
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"EXPECTED"	pointer
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
{	O
valcpy	function
(	O
varv	array
[	O
0	int
]	O
,	O
level	double
[	O
0	int
]	O
[	O
r	double
]	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
valcpy	function
(	O
varv	array
[	O
1	int
]	O
,	O
level	double
[	O
1	int
]	O
[	O
c	int
]	O
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
celln	int
]	O
=	O
expect	pointer
[	O
r	double
]	O
[	O
c	int
]	O
;	O
output	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
statv	pointer
[	O
FREQROW	int
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"ROWPERC"	pointer
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
{	O
valcpy	function
(	O
varv	array
[	O
0	int
]	O
,	O
level	double
[	O
0	int
]	O
[	O
r	double
]	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
valcpy	function
(	O
varv	array
[	O
1	int
]	O
,	O
level	double
[	O
1	int
]	O
[	O
c	int
]	O
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
celln	int
]	O
=	O
100.0	int
*	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
/	O
rowsum	pointer
[	O
r	double
]	O
;	O
output	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
statv	pointer
[	O
FREQCOL	int
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typen	int
]	O
,	O
"COLPERC"	pointer
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
{	O
valcpy	function
(	O
varv	array
[	O
0	int
]	O
,	O
level	double
[	O
0	int
]	O
[	O
r	double
]	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
valcpy	function
(	O
varv	array
[	O
1	int
]	O
,	O
level	double
[	O
1	int
]	O
[	O
c	int
]	O
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
celln	int
]	O
=	O
100.0	int
*	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
/	O
colsum	pointer
[	O
c	int
]	O
;	O
output	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
statv	pointer
[	O
FREQCHISQ	int
]	O
)	O
{	O
for	O
(	O
r	double
=	O
0	int
,	O
chisq	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
diff	double
=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
-	O
expect	pointer
[	O
r	double
]	O
[	O
c	int
]	O
;	O
chisq	double
+=	O
diff	double
*	O
diff	double
/	O
expect	pointer
[	O
r	double
]	O
[	O
c	int
]	O
;	O
}	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Chisq0[%d] = %g, Prob[Chisq > Chisq0] = %.5f\n"	pointer
,	O
(	O
nlevels	pointer
[	O
0	int
]	O
-	O
1	int
)	O
*	O
(	O
nlevels	pointer
[	O
1	int
]	O
-	O
1	int
)	O
,	O
chisq	double
,	O
ceil	function
(	O
100000.0	int
*	O
probchisq	function
(	O
chisq	double
,	O
(	O
nlevels	pointer
[	O
0	int
]	O
-	O
1	int
)	O
*	O
(	O
nlevels	pointer
[	O
1	int
]	O
-	O
1	int
)	O
)	O
)	O
/	O
100000.0	int
)	O
;	O
}	O
if	O
(	O
statv	pointer
[	O
FREQODDRAT	int
]	O
)	O
{	O
if	O
(	O
nlevels	pointer
[	O
0	int
]	O
==	O
2	int
&&	O
nlevels	pointer
[	O
1	int
]	O
==	O
2	int
)	O
{	O
tmp1	double
=	O
(	O
tab	pointer
[	O
0	int
]	O
[	O
0	int
]	O
+	O
0.5	int
)	O
*	O
(	O
tab	pointer
[	O
1	int
]	O
[	O
1	int
]	O
+	O
0.5	int
)	O
/	O
(	O
(	O
tab	pointer
[	O
0	int
]	O
[	O
1	int
]	O
+	O
0.5	int
)	O
*	O
(	O
tab	pointer
[	O
1	int
]	O
[	O
0	int
]	O
+	O
0.5	int
)	O
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Odds ratio = %g\nlog(Odds ratio) = %g, ASE = %g\n"	pointer
,	O
tmp1	double
,	O
log	function
(	O
tmp1	double
)	O
,	O
sqrt	function
(	O
1.0	int
/	O
(	O
tab	pointer
[	O
0	int
]	O
[	O
0	int
]	O
+	O
0.5	int
)	O
+	O
1.0	int
/	O
(	O
tab	pointer
[	O
1	int
]	O
[	O
0	int
]	O
+	O
0.5	int
)	O
+	O
1.0	int
/	O
(	O
tab	pointer
[	O
0	int
]	O
[	O
1	int
]	O
+	O
0.5	int
)	O
+	O
1.0	int
/	O
(	O
tab	pointer
[	O
1	int
]	O
[	O
1	int
]	O
+	O
0.5	int
)	O
)	O
)	O
;	O
}	O
else	O
fputs	function
(	O
"(freq2) Odds ratio computed for 2 x 2 tables only.\n"	pointer
,	O
dap_log	pointer
)	O
;	O
}	O
if	O
(	O
statv	pointer
[	O
FREQFISHER	int
]	O
)	O
{	O
if	O
(	O
nlevels	pointer
[	O
0	int
]	O
==	O
2	int
&&	O
nlevels	pointer
[	O
1	int
]	O
==	O
2	int
)	O
{	O
if	O
(	O
tab	pointer
[	O
0	int
]	O
[	O
0	int
]	O
>=	O
expect	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
{	O
denom	double
=	O
dap_bincoeff	function
(	O
sum	pointer
,	O
colsum	pointer
[	O
0	int
]	O
)	O
;	O
for	O
(	O
upleft	double
=	O
tab	pointer
[	O
0	int
]	O
[	O
0	int
]	O
,	O
dnleft	double
=	O
tab	pointer
[	O
1	int
]	O
[	O
0	int
]	O
,	O
prob	double
=	O
0.0	int
;	O
upleft	double
<=	O
rowsum	pointer
[	O
0	int
]	O
&&	O
upleft	double
<=	O
colsum	pointer
[	O
0	int
]	O
;	O
upleft	double
+=	O
1.0	int
,	O
dnleft	double
-=	O
1.0	int
)	O
{	O
if	O
(	O
prob	double
==	O
0.0	int
)	O
{	O
oneprob	double
=	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
0	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
1	int
]	O
,	O
dnleft	double
)	O
;	O
prob	double
=	O
oneprob	double
;	O
}	O
else	O
prob	double
+=	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
0	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
1	int
]	O
,	O
dnleft	double
)	O
;	O
}	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Fisher's exact test: right     %g\n"	pointer
,	O
prob	double
/	O
denom	double
)	O
;	O
for	O
(	O
upleft	double
=	O
ceil	function
(	O
expect	pointer
[	O
1	int
]	O
[	O
0	int
]	O
)	O
,	O
dnleft	double
=	O
colsum	pointer
[	O
0	int
]	O
-	O
upleft	double
;	O
upleft	double
<=	O
rowsum	pointer
[	O
1	int
]	O
&&	O
upleft	double
<=	O
colsum	pointer
[	O
0	int
]	O
;	O
upleft	double
+=	O
1.0	int
,	O
dnleft	double
-=	O
1.0	int
)	O
{	O
othprob	double
=	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
1	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
0	int
]	O
,	O
dnleft	double
)	O
;	O
if	O
(	O
othprob	double
<=	O
oneprob	double
)	O
prob	double
+=	O
othprob	double
;	O
}	O
if	O
(	O
tab	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
expect	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
prob	double
=	O
1.0	int
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"                     2-tailed  %g\n"	pointer
,	O
prob	double
/	O
denom	double
)	O
;	O
}	O
if	O
(	O
tab	pointer
[	O
0	int
]	O
[	O
0	int
]	O
<=	O
expect	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
{	O
denom	double
=	O
dap_bincoeff	function
(	O
sum	pointer
,	O
colsum	pointer
[	O
1	int
]	O
)	O
;	O
for	O
(	O
upleft	double
=	O
tab	pointer
[	O
1	int
]	O
[	O
0	int
]	O
,	O
dnleft	double
=	O
tab	pointer
[	O
0	int
]	O
[	O
0	int
]	O
,	O
prob	double
=	O
0.0	int
;	O
upleft	double
<=	O
rowsum	pointer
[	O
1	int
]	O
&&	O
upleft	double
<=	O
colsum	pointer
[	O
0	int
]	O
;	O
upleft	double
+=	O
1.0	int
,	O
dnleft	double
-=	O
1.0	int
)	O
{	O
if	O
(	O
prob	double
==	O
0.0	int
)	O
{	O
oneprob	double
=	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
1	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
0	int
]	O
,	O
dnleft	double
)	O
;	O
prob	double
=	O
oneprob	double
;	O
}	O
else	O
prob	double
+=	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
1	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
0	int
]	O
,	O
dnleft	double
)	O
;	O
}	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Fisher's exact test: left      %g\n"	pointer
,	O
prob	double
/	O
denom	double
)	O
;	O
for	O
(	O
upleft	double
=	O
ceil	function
(	O
expect	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
,	O
dnleft	double
=	O
colsum	pointer
[	O
0	int
]	O
-	O
upleft	double
;	O
upleft	double
<=	O
rowsum	pointer
[	O
0	int
]	O
&&	O
upleft	double
<=	O
colsum	pointer
[	O
0	int
]	O
;	O
upleft	double
+=	O
1.0	int
,	O
dnleft	double
-=	O
1.0	int
)	O
{	O
othprob	double
=	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
0	int
]	O
,	O
upleft	double
)	O
*	O
dap_bincoeff	function
(	O
rowsum	pointer
[	O
1	int
]	O
,	O
dnleft	double
)	O
;	O
if	O
(	O
othprob	double
<=	O
oneprob	double
)	O
prob	double
+=	O
othprob	double
;	O
}	O
if	O
(	O
tab	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
expect	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
prob	double
=	O
1.0	int
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"                     2-tailed  %g\n"	pointer
,	O
prob	double
/	O
denom	double
)	O
;	O
}	O
}	O
else	O
fputs	function
(	O
"(freq2) Fisher's exact test computed for 2 x 2 tables only.\n"	pointer
,	O
dap_log	pointer
)	O
;	O
}	O
if	O
(	O
statv	pointer
[	O
FREQORD	int
]	O
)	O
{	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
=	O
0.0	int
;	O
d	pointer
[	O
r	double
]	O
[	O
c	int
]	O
=	O
0.0	int
;	O
for	O
(	O
rr	int
=	O
0	int
;	O
rr	int
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
rr	int
++	O
)	O
for	O
(	O
cc	int
=	O
0	int
;	O
cc	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
cc	int
++	O
)	O
{	O
if	O
(	O
(	O
rr	int
<	O
r	double
&&	O
cc	int
<	O
c	int
)	O
||	O
(	O
rr	int
>	O
r	double
&&	O
cc	int
>	O
c	int
)	O
)	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
+=	O
tab	pointer
[	O
rr	int
]	O
[	O
cc	int
]	O
;	O
else	O
if	O
(	O
(	O
rr	int
<	O
r	double
&&	O
cc	int
>	O
c	int
)	O
||	O
(	O
rr	int
>	O
r	double
&&	O
cc	int
<	O
c	int
)	O
)	O
d	pointer
[	O
r	double
]	O
[	O
c	int
]	O
+=	O
tab	pointer
[	O
rr	int
]	O
[	O
cc	int
]	O
;	O
}	O
}	O
for	O
(	O
r	double
=	O
0	int
,	O
p	double
=	O
0.0	int
,	O
q	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
p	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
;	O
q	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
d	pointer
[	O
r	double
]	O
[	O
c	int
]	O
;	O
}	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Statistic          Value   ASE\n"	pointer
)	O
;	O
for	O
(	O
r	double
=	O
0	int
,	O
var	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp1	double
=	O
q	double
*	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
-	O
p	double
*	O
d	pointer
[	O
r	double
]	O
[	O
c	int
]	O
;	O
var	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp1	double
*	O
tmp1	double
;	O
}	O
tmp2	double
=	O
p	double
+	O
q	double
;	O
tmp2	double
*=	O
tmp2	double
;	O
tmp2	double
*=	O
tmp2	double
;	O
var	double
*=	O
16.0	int
/	O
tmp2	double
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Gamma             %6.3f  %5.3f\n"	pointer
,	O
(	O
p	double
-	O
q	double
)	O
/	O
(	O
p	double
+	O
q	double
)	O
,	O
sqrt	function
(	O
var	double
)	O
)	O
;	O
for	O
(	O
r	double
=	O
0	int
,	O
tmp1	double
=	O
sum	pointer
*	O
sum	pointer
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
tmp1	double
-=	O
rowsum	pointer
[	O
r	double
]	O
*	O
rowsum	pointer
[	O
r	double
]	O
;	O
for	O
(	O
c	int
=	O
0	int
,	O
tmp2	double
=	O
sum	pointer
*	O
sum	pointer
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
tmp2	double
-=	O
colsum	pointer
[	O
c	int
]	O
*	O
colsum	pointer
[	O
c	int
]	O
;	O
w	int
=	O
sqrt	function
(	O
tmp1	double
*	O
tmp2	double
)	O
;	O
t	double
=	O
(	O
p	double
-	O
q	double
)	O
/	O
w	int
;	O
for	O
(	O
r	double
=	O
0	int
,	O
var	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp3	double
=	O
2.0	int
*	O
w	int
*	O
(	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
-	O
d	pointer
[	O
r	double
]	O
[	O
c	int
]	O
)	O
+	O
t	double
*	O
(	O
rowsum	pointer
[	O
r	double
]	O
*	O
tmp2	double
+	O
colsum	pointer
[	O
c	int
]	O
*	O
tmp1	double
)	O
;	O
var	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp3	double
*	O
tmp3	double
;	O
}	O
tmp4	double
=	O
tmp1	double
+	O
tmp2	double
;	O
var	double
=	O
(	O
var	double
-	O
sum	pointer
*	O
sum	pointer
*	O
sum	pointer
*	O
t	double
*	O
t	double
*	O
tmp4	double
*	O
tmp4	double
)	O
/	O
(	O
w	int
*	O
w	int
*	O
w	int
*	O
w	int
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Kendall's Tau-b   %6.3f  %5.3f\n"	pointer
,	O
t	double
,	O
sqrt	function
(	O
var	double
)	O
)	O
;	O
for	O
(	O
r	double
=	O
0	int
,	O
var	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp3	double
=	O
tmp1	double
*	O
(	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
-	O
d	pointer
[	O
r	double
]	O
[	O
c	int
]	O
)	O
-	O
(	O
p	double
-	O
q	double
)	O
*	O
(	O
sum	pointer
-	O
rowsum	pointer
[	O
r	double
]	O
)	O
;	O
var	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp3	double
*	O
tmp3	double
;	O
}	O
var	double
*=	O
4.0	int
/	O
(	O
tmp1	double
*	O
tmp1	double
*	O
tmp1	double
*	O
tmp1	double
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Somers' D C|R     %6.3f  %5.3f\n"	pointer
,	O
(	O
p	double
-	O
q	double
)	O
/	O
tmp1	double
,	O
sqrt	function
(	O
var	double
)	O
)	O
;	O
for	O
(	O
r	double
=	O
0	int
,	O
var	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp3	double
=	O
tmp2	double
*	O
(	O
a	double
[	O
r	double
]	O
[	O
c	int
]	O
-	O
d	pointer
[	O
r	double
]	O
[	O
c	int
]	O
)	O
-	O
(	O
p	double
-	O
q	double
)	O
*	O
(	O
sum	pointer
-	O
colsum	pointer
[	O
c	int
]	O
)	O
;	O
var	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp3	double
*	O
tmp3	double
;	O
}	O
var	double
*=	O
4.0	int
/	O
(	O
tmp2	double
*	O
tmp2	double
*	O
tmp2	double
*	O
tmp2	double
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Somers' D R|C     %6.3f  %5.3f\n"	pointer
,	O
(	O
p	double
-	O
q	double
)	O
/	O
tmp2	double
,	O
sqrt	function
(	O
var	double
)	O
)	O
;	O
}	O
if	O
(	O
statv	pointer
[	O
FREQPAIR	int
]	O
)	O
{	O
if	O
(	O
nlevels	pointer
[	O
0	int
]	O
!=	O
nlevels	pointer
[	O
1	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(freq2) PAIR requires square table, table is %d x %d.\n"	pointer
,	O
nlevels	pointer
[	O
0	int
]	O
,	O
nlevels	pointer
[	O
1	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
r	double
=	O
0	int
,	O
p	double
=	O
0.0	int
,	O
q	double
=	O
0.0	int
,	O
tmp1	double
=	O
0.0	int
,	O
tmp2	double
=	O
0.0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
{	O
p	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
r	double
]	O
;	O
q	double
+=	O
expect	pointer
[	O
r	double
]	O
[	O
r	double
]	O
;	O
tmp1	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
r	double
]	O
*	O
(	O
rowsum	pointer
[	O
r	double
]	O
+	O
colsum	pointer
[	O
r	double
]	O
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp3	double
=	O
(	O
rowsum	pointer
[	O
c	int
]	O
+	O
colsum	pointer
[	O
r	double
]	O
)	O
;	O
tmp2	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp3	double
*	O
tmp3	double
;	O
}	O
}	O
p	double
/=	O
sum	pointer
;	O
q	double
/=	O
sum	pointer
;	O
tmp1	double
/=	O
sum	pointer
*	O
sum	pointer
;	O
tmp2	double
/=	O
sum	pointer
*	O
sum	pointer
*	O
sum	pointer
;	O
tmp3	double
=	O
1.0	int
-	O
p	double
;	O
tmp4	double
=	O
1.0	int
-	O
q	double
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Statistic          Value   ASE\n"	pointer
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Kappa             %6.3f  %5.3f\n"	pointer
,	O
(	O
p	double
-	O
q	double
)	O
/	O
tmp4	double
,	O
sqrt	function
(	O
(	O
p	double
*	O
tmp3	double
/	O
(	O
tmp4	double
*	O
tmp4	double
)	O
+	O
2.0	int
*	O
tmp3	double
*	O
(	O
2.0	int
*	O
p	double
*	O
q	double
-	O
tmp1	double
)	O
/	O
(	O
tmp4	double
*	O
tmp4	double
*	O
tmp4	double
)	O
+	O
tmp3	double
*	O
tmp3	double
*	O
(	O
tmp2	double
-	O
4.0	int
*	O
q	double
*	O
q	double
)	O
/	O
(	O
tmp4	double
*	O
tmp4	double
*	O
tmp4	double
*	O
tmp4	double
)	O
)	O
/	O
sum	pointer
)	O
)	O
;	O
}	O
if	O
(	O
statv	pointer
[	O
FREQNOM	int
]	O
)	O
{	O
for	O
(	O
hx	double
=	O
0.0	int
,	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
hx	double
-=	O
rowsum	pointer
[	O
r	double
]	O
*	O
log	function
(	O
rowsum	pointer
[	O
r	double
]	O
/	O
sum	pointer
)	O
;	O
hx	double
/=	O
sum	pointer
;	O
for	O
(	O
hy	double
=	O
0.0	int
,	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
hy	double
-=	O
colsum	pointer
[	O
c	int
]	O
*	O
log	function
(	O
colsum	pointer
[	O
c	int
]	O
/	O
sum	pointer
)	O
;	O
hy	double
/=	O
sum	pointer
;	O
for	O
(	O
hxy	double
=	O
0.0	int
,	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
hxy	double
-=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
log	function
(	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
/	O
sum	pointer
)	O
;	O
hxy	double
/=	O
sum	pointer
;	O
uv	double
=	O
hx	double
+	O
hy	double
-	O
hxy	double
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Statistic              Value   ASE\n"	pointer
)	O
;	O
for	O
(	O
var	double
=	O
0.0	int
,	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp1	double
=	O
hy	double
*	O
log	function
(	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
/	O
rowsum	pointer
[	O
r	double
]	O
)	O
+	O
(	O
hx	double
-	O
hxy	double
)	O
*	O
log	function
(	O
colsum	pointer
[	O
c	int
]	O
/	O
sum	pointer
)	O
;	O
var	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp1	double
*	O
tmp1	double
;	O
}	O
var	double
=	O
sqrt	function
(	O
var	double
)	O
/	O
(	O
sum	pointer
*	O
hy	double
*	O
hy	double
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Uncertainty C|R       %6.3f  %5.3f\n"	pointer
,	O
uv	double
/	O
hy	double
,	O
var	double
)	O
;	O
for	O
(	O
var	double
=	O
0.0	int
,	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp1	double
=	O
hx	double
*	O
log	function
(	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
/	O
colsum	pointer
[	O
c	int
]	O
)	O
+	O
(	O
hy	double
-	O
hxy	double
)	O
*	O
log	function
(	O
rowsum	pointer
[	O
r	double
]	O
/	O
sum	pointer
)	O
;	O
var	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp1	double
*	O
tmp1	double
;	O
}	O
var	double
=	O
sqrt	function
(	O
var	double
)	O
/	O
(	O
sum	pointer
*	O
hx	double
*	O
hx	double
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Uncertainty R|C       %6.3f  %5.3f\n"	pointer
,	O
uv	double
/	O
hx	double
,	O
var	double
)	O
;	O
for	O
(	O
var	double
=	O
0.0	int
,	O
r	double
=	O
0	int
;	O
r	double
<	O
nlevels	pointer
[	O
0	int
]	O
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
nlevels	pointer
[	O
1	int
]	O
;	O
c	int
++	O
)	O
{	O
tmp1	double
=	O
hxy	double
*	O
log	function
(	O
rowsum	pointer
[	O
r	double
]	O
*	O
colsum	pointer
[	O
c	int
]	O
/	O
(	O
sum	pointer
*	O
sum	pointer
)	O
)	O
-	O
(	O
hx	double
+	O
hy	double
)	O
*	O
log	function
(	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
/	O
sum	pointer
)	O
;	O
var	double
+=	O
tab	pointer
[	O
r	double
]	O
[	O
c	int
]	O
*	O
tmp1	double
*	O
tmp1	double
;	O
}	O
tmp2	double
=	O
hx	double
+	O
hy	double
;	O
var	double
=	O
2.0	int
*	O
sqrt	function
(	O
var	double
)	O
/	O
(	O
sum	pointer
*	O
tmp2	double
*	O
tmp2	double
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Uncertainty Symmetric %6.3f  %5.3f\n"	pointer
,	O
2.0	int
*	O
uv	double
/	O
(	O
hx	double
+	O
hy	double
)	O
,	O
var	double
)	O
;	O
}	O
dap_swap	function
(	O
)	O
;	O
dap_free	function
(	O
expmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
expect	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
rowsum	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
colsum	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
amem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
a	double
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
dmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
d	pointer
,	O
""	pointer
)	O
;	O
}	O
static	O
int	O
freqparse	function
(	O
char	O
*	O
varlist	array
,	O
int	O
*	O
varv	array
,	O
int	O
*	O
wt	pointer
)	O
{	O
int	O
nvars	int
;	O
int	O
m	int
;	O
int	O
i	int
;	O
char	O
*	O
mname	pointer
;	O
int	O
wtvar	pointer
;	O
wt	pointer
[	O
0	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
!	O
varlist	array
)	O
return	O
0	int
;	O
mname	pointer
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
varlist	array
[	O
m	int
]	O
==	O
' '	O
;	O
m	int
++	O
)	O
;	O
for	O
(	O
nvars	int
=	O
0	int
,	O
wtvar	pointer
=	O
0	int
;	O
varlist	array
[	O
m	int
]	O
;	O
)	O
{	O
if	O
(	O
varlist	array
[	O
m	int
]	O
==	O
'*'	O
)	O
{	O
if	O
(	O
wtvar	pointer
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(freqparse) Only one weight variable allowed: %s\n"	pointer
,	O
varlist	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
wtvar	pointer
=	O
1	int
;	O
for	O
(	O
m	int
++	O
;	O
varlist	array
[	O
m	int
]	O
==	O
' '	O
;	O
m	int
++	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array
[	O
m	int
+	O
i	int
]	O
&&	O
varlist	array
[	O
m	int
+	O
i	int
]	O
!=	O
' '	O
&&	O
varlist	array
[	O
m	int
+	O
i	int
]	O
!=	O
'*'	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
mname	pointer
[	O
i	int
]	O
=	O
varlist	array
[	O
m	int
+	O
i	int
]	O
;	O
else	O
{	O
mname	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_list) Variable name too long: %s\n"	pointer
,	O
mname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
mname	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
wtvar	pointer
)	O
{	O
if	O
(	O
(	O
wt	pointer
[	O
0	int
]	O
=	O
dap_varnum	function
(	O
mname	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_list) Weight variable unknown: %s\n"	pointer
,	O
mname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
varv	array
[	O
nvars	int
++	O
]	O
=	O
dap_varnum	function
(	O
mname	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_list) Variable unknown: %s\n"	pointer
,	O
mname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
m	int
+=	O
i	int
;	O
while	O
(	O
varlist	array
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
}	O
dap_free	function
(	O
mname	pointer
,	O
""	pointer
)	O
;	O
return	O
nvars	int
;	O
}	O
static	O
void	O
cmh1	function
(	O
double	O
*	O
*	O
tab	pointer
,	O
double	O
*	O
cmh	pointer
,	O
double	O
*	O
cmhvar	pointer
)	O
{	O
double	O
rowsum	pointer
[	O
2	int
]	O
;	O
double	O
colsum	pointer
[	O
2	int
]	O
;	O
double	O
tabsum	double
;	O
rowsum	pointer
[	O
0	int
]	O
=	O
tab	pointer
[	O
0	int
]	O
[	O
0	int
]	O
+	O
tab	pointer
[	O
0	int
]	O
[	O
1	int
]	O
;	O
rowsum	pointer
[	O
1	int
]	O
=	O
tab	pointer
[	O
1	int
]	O
[	O
0	int
]	O
+	O
tab	pointer
[	O
1	int
]	O
[	O
1	int
]	O
;	O
colsum	pointer
[	O
0	int
]	O
=	O
tab	pointer
[	O
0	int
]	O
[	O
0	int
]	O
+	O
tab	pointer
[	O
1	int
]	O
[	O
0	int
]	O
;	O
colsum	pointer
[	O
1	int
]	O
=	O
tab	pointer
[	O
0	int
]	O
[	O
1	int
]	O
+	O
tab	pointer
[	O
1	int
]	O
[	O
1	int
]	O
;	O
tabsum	double
=	O
rowsum	pointer
[	O
0	int
]	O
+	O
rowsum	pointer
[	O
1	int
]	O
;	O
*	O
cmh	pointer
+=	O
tab	pointer
[	O
0	int
]	O
[	O
0	int
]	O
-	O
rowsum	pointer
[	O
0	int
]	O
*	O
colsum	pointer
[	O
0	int
]	O
/	O
tabsum	double
;	O
*	O
cmhvar	pointer
+=	O
rowsum	pointer
[	O
0	int
]	O
*	O
rowsum	pointer
[	O
1	int
]	O
*	O
colsum	pointer
[	O
0	int
]	O
*	O
colsum	pointer
[	O
1	int
]	O
/	O
(	O
tabsum	double
*	O
tabsum	double
*	O
(	O
tabsum	double
-	O
1.0	int
)	O
)	O
;	O
}	O
static	O
void	O
printcmh	function
(	O
double	O
cmh	pointer
,	O
double	O
cmhvar	pointer
,	O
int	O
*	O
varv	array
,	O
int	O
nvar	int
,	O
int	O
*	O
markv	array
,	O
int	O
nmark	int
)	O
{	O
int	O
v	int
;	O
dap_swap	function
(	O
)	O
;	O
dap_head	function
(	O
markv	array
,	O
nmark	int
)	O
;	O
cmh	pointer
=	O
fabs	function
(	O
cmh	pointer
)	O
-	O
0.5	int
;	O
cmh	pointer
*=	O
cmh	pointer
/	O
cmhvar	pointer
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"Cochran-Mantel-Haenszel test for %s x %s, stratified by"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
1	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
2	int
]	O
]	O
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
-	O
2	int
;	O
v	int
++	O
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
" %s"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"M0-squared = %g, Prob[M-squared > M0-squared] = %g\n"	pointer
,	O
cmh	pointer
,	O
rint	function
(	O
10000.0	int
*	O
probchisq	function
(	O
cmh	pointer
,	O
1	int
)	O
)	O
/	O
10000.0	int
)	O
;	O
dap_swap	function
(	O
)	O
;	O
}	O
void	O
freq	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
varlist	array
,	O
char	O
*	O
stats	array
,	O
char	O
*	O
marks	array
)	O
{	O
char	O
*	O
outname	pointer
;	O
int	O
statv	pointer
[	O
NFREQSTAT	int
]	O
;	O
int	O
typen	int
;	O
int	O
celln	int
;	O
int	O
*	O
markv	array
;	O
int	O
nmark	int
;	O
int	O
*	O
varv	array
;	O
int	O
nvar	int
;	O
int	O
v	int
;	O
int	O
wt	pointer
;	O
char	O
*	O
outlist	pointer
;	O
double	O
count	double
;	O
double	O
sumcount	double
;	O
double	O
*	O
tabmem	pointer
;	O
double	O
*	O
*	O
tab	pointer
;	O
char	O
*	O
levmem	pointer
;	O
char	O
*	O
*	O
level	double
[	O
2	int
]	O
;	O
int	O
nlevels	pointer
[	O
2	int
]	O
;	O
int	O
l1	int
,	O
l2	int
;	O
double	O
cmh	pointer
,	O
cmhvar	pointer
;	O
int	O
more	int
,	O
moremore	int
;	O
int	O
(	O
*	O
strc	pointer
)	O
(	O
)	O
;	O
strc	pointer
=	O
&	O
strcmp	function
;	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(freq) No dataset name given.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
outname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
dap_suffix	function
(	O
outname	pointer
,	O
fname	array
,	O
".frq"	pointer
)	O
;	O
outlist	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
markv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
varv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
tabmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxlev	int
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
tab	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
l1	int
<	O
dap_maxlev	int
;	O
l1	int
++	O
)	O
tab	pointer
[	O
l1	int
]	O
=	O
tabmem	pointer
+	O
l1	int
*	O
dap_maxlev	int
;	O
levmem	pointer
=	O
dap_malloc	function
(	O
2	int
*	O
dap_maxlev	int
*	O
(	O
dap_strlen	int
+	O
1	int
)	O
,	O
""	pointer
)	O
;	O
level	double
[	O
0	int
]	O
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
level	double
[	O
1	int
]	O
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxlev	int
,	O
""	pointer
)	O
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
l1	int
<	O
dap_maxlev	int
;	O
l1	int
++	O
)	O
{	O
level	double
[	O
0	int
]	O
[	O
l1	int
]	O
=	O
levmem	pointer
+	O
l1	int
*	O
(	O
dap_strlen	int
+	O
1	int
)	O
;	O
level	double
[	O
1	int
]	O
[	O
l1	int
]	O
=	O
level	double
[	O
0	int
]	O
[	O
l1	int
]	O
+	O
dap_maxlev	int
*	O
(	O
dap_strlen	int
+	O
1	int
)	O
;	O
}	O
statparse	function
(	O
stats	array
,	O
statv	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
if	O
(	O
(	O
typen	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fputs	function
(	O
"(freq) Missing _type_ variable.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
nmark	int
=	O
dap_list	function
(	O
marks	array
,	O
markv	array
,	O
dap_maxvar	int
)	O
;	O
nvar	int
=	O
freqparse	function
(	O
varlist	array
,	O
varv	array
,	O
&	O
wt	pointer
)	O
;	O
if	O
(	O
statv	pointer
[	O
FREQCMH	int
]	O
&&	O
nvar	int
<	O
3	int
)	O
{	O
fputs	function
(	O
"(freq) Cochran-Mantel-Haenszel test performed only for tables with dimension >= 3.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
celln	int
=	O
dap_vd	function
(	O
"_cell_ -1"	pointer
,	O
0	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
!	O
v	int
)	O
strcpy	function
(	O
outlist	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
else	O
{	O
strcat	function
(	O
outlist	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
outlist	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
}	O
}	O
strcat	function
(	O
outlist	pointer
,	O
" _cell_ "	pointer
)	O
;	O
strcat	function
(	O
outlist	pointer
,	O
marks	array
)	O
;	O
outset	function
(	O
outname	pointer
,	O
outlist	pointer
)	O
;	O
nlevels	pointer
[	O
0	int
]	O
=	O
0	int
;	O
nlevels	pointer
[	O
1	int
]	O
=	O
0	int
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
l1	int
<	O
dap_maxlev	int
;	O
l1	int
++	O
)	O
for	O
(	O
l2	int
=	O
0	int
;	O
l2	int
<	O
dap_maxlev	int
;	O
l2	int
++	O
)	O
tab	pointer
[	O
l1	int
]	O
[	O
l2	int
]	O
=	O
0.0	int
;	O
for	O
(	O
dap_mark	function
(	O
)	O
,	O
sumcount	double
=	O
0.0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
dap_rewind	function
(	O
)	O
;	O
if	O
(	O
nvar	int
==	O
2	int
)	O
{	O
qsort	function
(	O
level	double
[	O
0	int
]	O
[	O
0	int
]	O
,	O
nlevels	pointer
[	O
0	int
]	O
,	O
dap_strlen	int
+	O
1	int
,	O
strc	pointer
)	O
;	O
qsort	function
(	O
level	double
[	O
1	int
]	O
[	O
0	int
]	O
,	O
nlevels	pointer
[	O
1	int
]	O
,	O
dap_strlen	int
+	O
1	int
,	O
strc	pointer
)	O
;	O
}	O
for	O
(	O
count	double
=	O
0.0	int
,	O
cmh	pointer
=	O
0.0	int
,	O
cmhvar	pointer
=	O
0.0	int
,	O
moremore	int
=	O
1	int
;	O
moremore	int
;	O
)	O
{	O
dap_mark	function
(	O
)	O
;	O
moremore	int
=	O
(	O
step	function
(	O
)	O
&&	O
!	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
varv	array
,	O
nvar	int
)	O
||	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
freq1	function
(	O
varv	array
,	O
nvar	int
,	O
count	double
,	O
sumcount	double
,	O
statv	pointer
,	O
typen	int
,	O
celln	int
)	O
;	O
if	O
(	O
nvar	int
==	O
2	int
)	O
tabentry	function
(	O
varv	array
,	O
tab	pointer
,	O
level	double
,	O
nlevels	pointer
,	O
count	double
)	O
;	O
else	O
if	O
(	O
statv	pointer
[	O
FREQCMH	int
]	O
)	O
{	O
tabentry	function
(	O
varv	array
+	O
nvar	int
-	O
2	int
,	O
tab	pointer
,	O
level	double
,	O
nlevels	pointer
,	O
count	double
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
varv	array
,	O
nvar	int
-	O
2	int
)	O
)	O
cmh1	function
(	O
tab	pointer
,	O
&	O
cmh	pointer
,	O
&	O
cmhvar	pointer
)	O
;	O
}	O
count	double
=	O
0.0	int
;	O
}	O
if	O
(	O
wt	pointer
>=	O
0	int
)	O
count	double
+=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
wt	pointer
]	O
;	O
else	O
count	double
+=	O
1.0	int
;	O
}	O
if	O
(	O
nvar	int
==	O
2	int
)	O
freq2	function
(	O
tab	pointer
,	O
level	double
,	O
nlevels	pointer
,	O
statv	pointer
,	O
markv	array
,	O
nmark	int
,	O
varv	array
,	O
typen	int
,	O
celln	int
)	O
;	O
else	O
if	O
(	O
statv	pointer
[	O
FREQCMH	int
]	O
)	O
printcmh	function
(	O
cmh	pointer
,	O
cmhvar	pointer
,	O
varv	array
,	O
nvar	int
,	O
markv	array
,	O
nmark	int
)	O
;	O
for	O
(	O
l1	int
=	O
0	int
;	O
l1	int
<	O
dap_maxlev	int
;	O
l1	int
++	O
)	O
for	O
(	O
l2	int
=	O
0	int
;	O
l2	int
<	O
dap_maxlev	int
;	O
l2	int
++	O
)	O
tab	pointer
[	O
l1	int
]	O
[	O
l2	int
]	O
=	O
0.0	int
;	O
sumcount	double
=	O
0.0	int
;	O
nlevels	pointer
[	O
0	int
]	O
=	O
0	int
;	O
nlevels	pointer
[	O
1	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
nvar	int
==	O
2	int
)	O
{	O
findlev	function
(	O
varv	array
[	O
0	int
]	O
,	O
level	double
[	O
0	int
]	O
,	O
nlevels	pointer
)	O
;	O
findlev	function
(	O
varv	array
[	O
1	int
]	O
,	O
level	double
[	O
1	int
]	O
,	O
nlevels	pointer
+	O
1	int
)	O
;	O
}	O
if	O
(	O
wt	pointer
>=	O
0	int
)	O
sumcount	double
+=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
wt	pointer
]	O
;	O
else	O
sumcount	double
+=	O
1.0	int
;	O
}	O
dap_free	function
(	O
outname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
outlist	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
markv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
tabmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
tab	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
levmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
level	double
[	O
0	int
]	O
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
level	double
[	O
1	int
]	O
,	O
""	pointer
)	O
;	O
}	O
static	O
void	O
trim1	function
(	O
double	O
*	O
vpct	pointer
,	O
int	O
nvar	int
,	O
double	O
*	O
*	O
val	pointer
,	O
int	O
nobs	int
,	O
double	O
*	O
vmin	pointer
,	O
double	O
*	O
vmax	pointer
)	O
{	O
int	O
v	int
;	O
int	O
trimcnt	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
trimcnt	int
=	O
(	O
int	O
)	O
rint	function
(	O
vpct	pointer
[	O
v	int
]	O
/	O
100.0	int
*	O
(	O
(	O
double	O
)	O
nobs	int
)	O
)	O
;	O
qsort	function
(	O
(	O
void	O
*	O
)	O
val	pointer
[	O
v	int
]	O
,	O
(	O
size_t	long
)	O
nobs	int
,	O
(	O
size_t	long
)	O
sizeof	O
(	O
double	O
)	O
,	O
cmp	pointer
)	O
;	O
vmin	pointer
[	O
v	int
]	O
=	O
val	pointer
[	O
v	int
]	O
[	O
trimcnt	int
]	O
;	O
vmax	pointer
[	O
v	int
]	O
=	O
val	pointer
[	O
v	int
]	O
[	O
nobs	int
-	O
trimcnt	int
-	O
1	int
]	O
;	O
}	O
}	O
static	O
int	O
trimparse	function
(	O
char	O
*	O
trimspec	pointer
,	O
int	O
*	O
varv	array
,	O
double	O
*	O
vpct	pointer
)	O
{	O
int	O
n	int
;	O
int	O
i	int
;	O
char	O
*	O
varname	pointer
;	O
int	O
v	int
;	O
double	O
div	function
;	O
int	O
digits	int
;	O
int	O
nvar	int
;	O
if	O
(	O
!	O
trimspec	pointer
)	O
return	O
0	int
;	O
varname	pointer
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
trimspec	pointer
[	O
n	int
]	O
==	O
' '	O
;	O
n	int
++	O
)	O
;	O
for	O
(	O
nvar	int
=	O
0	int
;	O
trimspec	pointer
[	O
n	int
]	O
;	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
trimspec	pointer
[	O
n	int
+	O
i	int
]	O
&&	O
trimspec	pointer
[	O
n	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
varname	pointer
[	O
i	int
]	O
=	O
trimspec	pointer
[	O
n	int
+	O
i	int
]	O
;	O
else	O
{	O
varname	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(trimparse) trim variable name too long: %s\n"	pointer
,	O
varname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
varname	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
n	int
+=	O
i	int
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
varname	pointer
)	O
)	O
>=	O
0	int
)	O
{	O
varv	array
[	O
nvar	int
]	O
=	O
v	int
;	O
while	O
(	O
trimspec	pointer
[	O
n	int
]	O
==	O
' '	O
)	O
n	int
++	O
;	O
for	O
(	O
digits	int
=	O
0	int
,	O
div	function
=	O
0.0	int
;	O
(	O
'0'	O
<=	O
trimspec	pointer
[	O
n	int
]	O
&&	O
trimspec	pointer
[	O
n	int
]	O
<=	O
'9'	O
)	O
||	O
trimspec	pointer
[	O
n	int
]	O
==	O
'.'	O
;	O
n	int
++	O
)	O
{	O
if	O
(	O
trimspec	pointer
[	O
n	int
]	O
==	O
'.'	O
)	O
{	O
if	O
(	O
div	function
>=	O
1.0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(trimparse) multiple decimal points in percent for %s\n"	pointer
,	O
varname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
div	function
=	O
1.0	int
;	O
}	O
else	O
{	O
digits	int
=	O
10	int
*	O
digits	int
+	O
trimspec	pointer
[	O
n	int
]	O
-	O
'0'	O
;	O
if	O
(	O
div	function
>=	O
1.0	int
)	O
div	function
*=	O
10.0	int
;	O
}	O
}	O
vpct	pointer
[	O
nvar	int
]	O
=	O
(	O
double	O
)	O
digits	int
;	O
if	O
(	O
div	function
>=	O
1.0	int
)	O
vpct	pointer
[	O
nvar	int
]	O
/=	O
div	function
;	O
if	O
(	O
vpct	pointer
[	O
nvar	int
]	O
>	O
0.0	int
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
v	int
]	O
==	O
DBL	O
)	O
nvar	int
++	O
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(trimparse) trim variable not double: %s\n"	pointer
,	O
varname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(trimparse) no percent for trim variable: %s\n"	pointer
,	O
varname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(trimparse) unknown trim variable: %s\n"	pointer
,	O
varname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
trimspec	pointer
[	O
n	int
]	O
==	O
' '	O
)	O
n	int
++	O
;	O
}	O
dap_free	function
(	O
varname	pointer
,	O
""	pointer
)	O
;	O
return	O
nvar	int
;	O
}	O
void	O
trim	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
trimspec	pointer
,	O
char	O
*	O
marks	array
)	O
{	O
char	O
*	O
outname	pointer
;	O
int	O
*	O
markv	array
;	O
int	O
nmark	int
;	O
int	O
*	O
varv	array
;	O
double	O
*	O
vpct	pointer
;	O
int	O
nvar	int
;	O
double	O
*	O
valmem	pointer
;	O
double	O
*	O
*	O
val	pointer
;	O
int	O
v	int
;	O
int	O
nobs	int
;	O
double	O
*	O
vmin	pointer
;	O
double	O
*	O
vmax	pointer
;	O
int	O
more	int
;	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(trim) No dataset name given.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
outname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
dap_suffix	function
(	O
outname	pointer
,	O
fname	array
,	O
".trm"	pointer
)	O
;	O
markv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
varv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
vpct	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
vmin	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
vmax	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
nmark	int
=	O
dap_list	function
(	O
marks	array
,	O
markv	array
,	O
dap_maxvar	int
)	O
;	O
nvar	int
=	O
trimparse	function
(	O
trimspec	pointer
,	O
varv	array
,	O
vpct	pointer
)	O
;	O
outset	function
(	O
outname	pointer
,	O
""	pointer
)	O
;	O
valmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
*	O
dap_maxval	int
,	O
""	pointer
)	O
;	O
val	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
*	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<=	O
nvar	int
;	O
v	int
++	O
)	O
val	pointer
[	O
v	int
]	O
=	O
valmem	pointer
+	O
v	int
*	O
dap_maxval	int
;	O
for	O
(	O
dap_mark	function
(	O
)	O
,	O
nobs	int
=	O
0	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
nobs	int
++	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
trim1	function
(	O
vpct	pointer
,	O
nvar	int
,	O
val	pointer
,	O
nobs	int
,	O
vmin	pointer
,	O
vmax	pointer
)	O
;	O
dap_rewind	function
(	O
)	O
;	O
while	O
(	O
step	function
(	O
)	O
&&	O
!	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
<	O
vmin	pointer
[	O
v	int
]	O
||	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
>	O
vmax	pointer
[	O
v	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
v	int
==	O
nvar	int
)	O
output	function
(	O
)	O
;	O
dap_mark	function
(	O
)	O
;	O
}	O
nobs	int
=	O
0	int
;	O
}	O
if	O
(	O
nobs	int
<	O
dap_maxval	int
)	O
{	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
finite	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
)	O
val	pointer
[	O
v	int
]	O
[	O
nobs	int
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(trim) NaN value %d for %s\n"	pointer
,	O
nobs	int
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
fputs	function
(	O
"(group) Too many data.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
dap_free	function
(	O
outname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
markv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
vpct	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
valmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
val	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
vmin	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
vmax	pointer
,	O
""	pointer
)	O
;	O
}	O
