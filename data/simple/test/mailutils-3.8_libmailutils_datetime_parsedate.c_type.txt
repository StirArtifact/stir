static	O
inline	O
int	O
ISDIGIT	function
(	O
unsigned	O
c	int
)	O
{	O
return	O
mu_isdigit	O
(	O
c	int
)	O
;	O
}	O
static	O
int	O
pd_yyparse	function
(	O
void	O
)	O
;	O
static	O
int	O
pd_yylex	function
(	O
void	O
)	O
;	O
static	O
int	O
pd_yyerror	function
(	O
char	O
*	O
s	pointer
)	O
;	O
typedef	O
struct	O
_lex_tab	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
int	O
type	int
;	O
int	O
value	int
;	O
}	O
SYMBOL	struct
;	O
typedef	O
enum	O
meridian	enum
{	O
MERam	int
,	O
MERpm	int
,	O
MER24	int
}	O
MERIDIAN	enum
;	O
struct	O
pd_date	struct
{	O
int	O
mask	int
;	O
int	O
day	int
;	O
int	O
hour	int
;	O
int	O
minute	int
;	O
int	O
month	int
;	O
int	O
second	int
;	O
int	O
year	int
;	O
int	O
tz	pointer
;	O
char	O
const	O
*	O
tzname	array
;	O
enum	O
meridian	enum
meridian	enum
;	O
int	O
number	int
;	O
int	O
ordinal	int
;	O
}	O
;	O
int	O
pd_date_union	function
(	O
struct	O
pd_date	struct
*	O
a	pointer
,	O
struct	O
pd_date	struct
*	O
b	pointer
)	O
{	O
int	O
diff	int
=	O
(	O
~	O
a	pointer
->	O
mask	int
)	O
&	O
b	pointer
->	O
mask	int
;	O
if	O
(	O
!	O
diff	int
)	O
return	O
1	int
;	O
a	pointer
->	O
mask	int
|=	O
diff	int
;	O
if	O
(	O
diff	int
&	O
MU_PD_MASK_SECOND	int
)	O
a	pointer
->	O
second	int
=	O
b	pointer
->	O
second	int
;	O
if	O
(	O
diff	int
&	O
MU_PD_MASK_MINUTE	int
)	O
a	pointer
->	O
minute	int
=	O
b	pointer
->	O
minute	int
;	O
if	O
(	O
diff	int
&	O
MU_PD_MASK_HOUR	int
)	O
a	pointer
->	O
hour	int
=	O
b	pointer
->	O
hour	int
;	O
if	O
(	O
diff	int
&	O
MU_PD_MASK_DAY	int
)	O
a	pointer
->	O
day	int
=	O
b	pointer
->	O
day	int
;	O
if	O
(	O
diff	int
&	O
MU_PD_MASK_MONTH	int
)	O
a	pointer
->	O
month	int
=	O
b	pointer
->	O
month	int
;	O
if	O
(	O
diff	int
&	O
MU_PD_MASK_YEAR	int
)	O
a	pointer
->	O
year	int
=	O
b	pointer
->	O
year	int
;	O
if	O
(	O
diff	int
&	O
MU_PD_MASK_TZ	int
)	O
a	pointer
->	O
tz	pointer
=	O
b	pointer
->	O
tz	pointer
;	O
if	O
(	O
diff	int
&	O
MU_PD_MASK_MERIDIAN	int
)	O
a	pointer
->	O
meridian	enum
=	O
b	pointer
->	O
meridian	enum
;	O
if	O
(	O
diff	int
&	O
MU_PD_MASK_ORDINAL	int
)	O
a	pointer
->	O
ordinal	int
=	O
b	pointer
->	O
ordinal	int
;	O
if	O
(	O
diff	int
&	O
MU_PD_MASK_NUMBER	int
)	O
a	pointer
->	O
number	int
=	O
b	pointer
->	O
number	int
;	O
return	O
0	int
;	O
}	O
struct	O
pd_datespec	struct
{	O
struct	O
pd_date	struct
date	struct
;	O
struct	O
pd_date	struct
rel	struct
;	O
}	O
;	O
static	O
struct	O
pd_datespec	struct
pd	struct
;	O
static	O
const	O
char	O
*	O
yyinput	pointer
;	O
enum	O
yytokentype	enum
{	O
T_AGO	int
=	O
258	int
,	O
T_DST	int
=	O
259	int
,	O
T_ID	int
=	O
260	int
,	O
T_DAY	int
=	O
261	int
,	O
T_DAY_UNIT	int
=	O
262	int
,	O
T_HOUR_UNIT	int
=	O
263	int
,	O
T_MINUTE_UNIT	int
=	O
264	int
,	O
T_MONTH	int
=	O
265	int
,	O
T_MONTH_UNIT	int
=	O
266	int
,	O
T_SEC_UNIT	int
=	O
267	int
,	O
T_SNUMBER	int
=	O
268	int
,	O
T_UNUMBER	int
=	O
269	int
,	O
T_YEAR_UNIT	int
=	O
270	int
,	O
T_ZONE	int
=	O
271	int
,	O
T_DAYZONE	int
=	O
272	int
,	O
T_MERIDIAN	int
=	O
273	int
}	O
;	O
typedef	O
union	O
YYSTYPE	union
{	O
int	O
number	int
;	O
enum	O
meridian	enum
meridian	enum
;	O
struct	O
pd_date	struct
date	struct
;	O
struct	O
pd_datespec	struct
datespec	struct
;	O
struct	O
{	O
char	O
const	O
*	O
name	pointer
;	O
int	O
delta	int
;	O
}	O
tz	pointer
;	O
}	O
YYSTYPE	union
;	O
extern	O
YYSTYPE	union
pd_yylval	union
;	O
int	O
pd_yyparse	function
(	O
void	O
)	O
;	O
typedef	O
unsigned	O
char	O
yytype_uint8	char
;	O
typedef	O
signed	O
char	O
yytype_int8	char
;	O
typedef	O
unsigned	O
short	O
int	O
yytype_uint16	short
;	O
typedef	O
short	O
int	O
yytype_int16	short
;	O
union	O
pd_yyalloc	union
{	O
yytype_int16	short
yyss_alloc	short
;	O
YYSTYPE	union
yyvs_alloc	union
;	O
}	O
;	O
static	O
const	O
yytype_uint8	char
yytranslate	array
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
20	int
,	O
2	int
,	O
2	int
,	O
21	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
19	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
18	int
}	O
;	O
static	O
const	O
yytype_uint8	char
pd_yyr1	array
[	O
]	O
=	O
{	O
0	int
,	O
22	int
,	O
23	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
24	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
25	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
26	int
,	O
27	int
,	O
27	int
,	O
27	int
,	O
28	int
,	O
28	int
,	O
28	int
,	O
29	int
,	O
29	int
,	O
29	int
,	O
29	int
,	O
29	int
,	O
29	int
,	O
29	int
,	O
29	int
,	O
29	int
,	O
30	int
,	O
30	int
,	O
31	int
,	O
31	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
32	int
,	O
33	int
,	O
33	int
}	O
;	O
static	O
const	O
yytype_uint8	char
pd_yyr2	array
[	O
]	O
=	O
{	O
0	int
,	O
2	int
,	O
1	int
,	O
0	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
4	int
,	O
4	int
,	O
6	int
,	O
6	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
3	int
,	O
5	int
,	O
3	int
,	O
3	int
,	O
2	int
,	O
4	int
,	O
2	int
,	O
3	int
,	O
5	int
,	O
2	int
,	O
1	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
2	int
,	O
2	int
,	O
1	int
,	O
0	int
,	O
1	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yydefact	array
[	O
]	O
=	O
{	O
3	int
,	O
0	int
,	O
2	int
,	O
1	int
,	O
19	int
,	O
43	int
,	O
46	int
,	O
49	int
,	O
0	int
,	O
40	int
,	O
52	int
,	O
0	int
,	O
6	int
,	O
37	int
,	O
16	int
,	O
17	int
,	O
4	int
,	O
7	int
,	O
8	int
,	O
10	int
,	O
9	int
,	O
5	int
,	O
32	int
,	O
33	int
,	O
0	int
,	O
20	int
,	O
26	int
,	O
42	int
,	O
45	int
,	O
48	int
,	O
39	int
,	O
51	int
,	O
36	int
,	O
21	int
,	O
41	int
,	O
44	int
,	O
47	int
,	O
28	int
,	O
38	int
,	O
50	int
,	O
0	int
,	O
35	int
,	O
11	int
,	O
0	int
,	O
0	int
,	O
18	int
,	O
31	int
,	O
0	int
,	O
34	int
,	O
0	int
,	O
0	int
,	O
25	int
,	O
29	int
,	O
24	int
,	O
53	int
,	O
22	int
,	O
0	int
,	O
0	int
,	O
27	int
,	O
13	int
,	O
54	int
,	O
0	int
,	O
12	int
,	O
0	int
,	O
30	int
,	O
53	int
,	O
23	int
,	O
15	int
,	O
14	int
}	O
;	O
static	O
const	O
yytype_int8	char
yydefgoto	array
[	O
]	O
=	O
{	O
-	O
1	int
,	O
1	int
,	O
2	int
,	O
16	int
,	O
17	int
,	O
18	int
,	O
19	int
,	O
20	int
,	O
21	int
,	O
22	int
,	O
23	int
,	O
62	int
}	O
;	O
static	O
const	O
yytype_int8	char
pd_yypact	array
[	O
]	O
=	O
{	O
-	O
7	int
,	O
8	int
,	O
21	int
,	O
-	O
7	int
,	O
1	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
4	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
32	int
,	O
-	O
6	int
,	O
-	O
7	int
,	O
38	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
11	int
,	O
-	O
7	int
,	O
31	int
,	O
-	O
7	int
,	O
34	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
3	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
46	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
48	int
,	O
49	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
41	int
,	O
-	O
7	int
,	O
50	int
,	O
51	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
42	int
,	O
45	int
,	O
39	int
,	O
53	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
54	int
,	O
-	O
7	int
,	O
55	int
,	O
-	O
7	int
,	O
33	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
}	O
;	O
static	O
const	O
yytype_int8	char
yypgoto	array
[	O
]	O
=	O
{	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
22	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
-	O
7	int
,	O
52	int
,	O
5	int
}	O
;	O
static	O
const	O
yytype_uint8	char
pd_yytable	array
[	O
]	O
=	O
{	O
33	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
37	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
3	int
,	O
41	int
,	O
26	int
,	O
24	int
,	O
42	int
,	O
43	int
,	O
46	int
,	O
44	int
,	O
51	int
,	O
52	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
25	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
47	int
,	O
13	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
45	int
,	O
30	int
,	O
31	int
,	O
49	int
,	O
67	int
,	O
32	int
,	O
34	int
,	O
35	int
,	O
36	int
,	O
60	int
,	O
38	int
,	O
39	int
,	O
50	int
,	O
59	int
,	O
41	int
,	O
42	int
,	O
43	int
,	O
53	int
,	O
60	int
,	O
61	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
58	int
,	O
63	int
,	O
64	int
,	O
65	int
,	O
66	int
,	O
68	int
,	O
57	int
,	O
0	int
,	O
0	int
,	O
48	int
}	O
;	O
static	O
const	O
yytype_int8	char
pd_yycheck	array
[	O
]	O
=	O
{	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
0	int
,	O
15	int
,	O
14	int
,	O
10	int
,	O
18	int
,	O
19	int
,	O
3	int
,	O
21	int
,	O
13	int
,	O
14	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
20	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
4	int
,	O
11	int
,	O
12	int
,	O
14	int
,	O
13	int
,	O
15	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
18	int
,	O
11	int
,	O
12	int
,	O
20	int
,	O
13	int
,	O
15	int
,	O
18	int
,	O
19	int
,	O
13	int
,	O
18	int
,	O
19	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
21	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
65	int
,	O
49	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
22	int
}	O
;	O
static	O
const	O
yytype_uint8	char
yystos	array
[	O
]	O
=	O
{	O
0	int
,	O
23	int
,	O
24	int
,	O
0	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
14	int
,	O
15	int
,	O
16	int
,	O
17	int
,	O
25	int
,	O
26	int
,	O
27	int
,	O
28	int
,	O
29	int
,	O
30	int
,	O
31	int
,	O
32	int
,	O
10	int
,	O
20	int
,	O
14	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
11	int
,	O
12	int
,	O
15	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
15	int
,	O
18	int
,	O
19	int
,	O
21	int
,	O
4	int
,	O
3	int
,	O
14	int
,	O
32	int
,	O
14	int
,	O
20	int
,	O
13	int
,	O
14	int
,	O
13	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
26	int
,	O
14	int
,	O
13	int
,	O
18	int
,	O
19	int
,	O
33	int
,	O
21	int
,	O
14	int
,	O
14	int
,	O
14	int
,	O
13	int
,	O
33	int
}	O
;	O
static	O
void	O
yydestruct	function
(	O
const	O
char	O
*	O
yymsg	pointer
,	O
int	O
yytype	int
,	O
YYSTYPE	union
*	O
yyvaluep	pointer
)	O
{	O
YYUSE	O
(	O
yyvaluep	pointer
)	O
;	O
if	O
(	O
!	O
yymsg	pointer
)	O
yymsg	pointer
=	O
"Deleting"	pointer
;	O
YY_SYMBOL_PRINT	O
(	O
yymsg	pointer
,	O
yytype	int
,	O
yyvaluep	pointer
,	O
yylocationp	O
)	O
;	O
switch	O
(	O
yytype	int
)	O
{	O
default	O
:	O
break	O
;	O
}	O
}	O
int	O
pd_yychar	int
;	O
YYSTYPE	union
pd_yylval	union
YY_INITIAL_VALUE	O
(	O
yyval_default	O
)	O
;	O
int	O
pd_yynerrs	int
;	O
int	O
pd_yyparse	function
(	O
void	O
)	O
{	O
int	O
pd_yystate	int
;	O
int	O
yyerrstatus	int
;	O
yytype_int16	short
yyssa	array
[	O
YYINITDEPTH	int
]	O
;	O
yytype_int16	short
*	O
yyss	pointer
;	O
yytype_int16	short
*	O
yyssp	pointer
;	O
YYSTYPE	union
yyvsa	array
[	O
YYINITDEPTH	int
]	O
;	O
YYSTYPE	union
*	O
yyvs	pointer
;	O
YYSTYPE	union
*	O
yyvsp	pointer
;	O
YYSIZE_T	O
yystacksize	long
;	O
int	O
yyn	int
;	O
int	O
yyresult	int
;	O
int	O
yytoken	int
=	O
0	int
;	O
YYSTYPE	union
pd_yyval	union
;	O
int	O
pd_yylen	int
=	O
0	int
;	O
yyssp	pointer
=	O
yyss	pointer
=	O
yyssa	array
;	O
yyvsp	pointer
=	O
yyvs	pointer
=	O
yyvsa	array
;	O
yystacksize	long
=	O
YYINITDEPTH	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Starting parse\n"	pointer
)	O
)	O
;	O
pd_yystate	int
=	O
0	int
;	O
yyerrstatus	int
=	O
0	int
;	O
pd_yynerrs	int
=	O
0	int
;	O
pd_yychar	int
=	O
YYEMPTY	O
;	O
goto	O
yysetstate	O
;	O
yynewstate	O
:	O
yyssp	pointer
++	O
;	O
yysetstate	O
:	O
*	O
yyssp	pointer
=	O
pd_yystate	int
;	O
if	O
(	O
yyss	pointer
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	pointer
)	O
{	O
YYSIZE_T	O
yysize	long
=	O
yyssp	pointer
-	O
yyss	pointer
+	O
1	int
;	O
if	O
(	O
YYMAXDEPTH	int
<=	O
yystacksize	long
)	O
goto	O
yyexhaustedlab	O
;	O
yystacksize	long
*=	O
2	int
;	O
if	O
(	O
YYMAXDEPTH	int
<	O
yystacksize	long
)	O
yystacksize	long
=	O
YYMAXDEPTH	int
;	O
{	O
yytype_int16	short
*	O
yyss1	pointer
=	O
yyss	pointer
;	O
union	O
pd_yyalloc	union
*	O
yyptr	pointer
=	O
(	O
union	O
pd_yyalloc	union
*	O
)	O
YYSTACK_ALLOC	O
(	O
YYSTACK_BYTES	O
(	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
!	O
yyptr	pointer
)	O
goto	O
yyexhaustedlab	O
;	O
YYSTACK_RELOCATE	O
(	O
yyss_alloc	short
,	O
yyss	pointer
)	O
;	O
YYSTACK_RELOCATE	O
(	O
yyvs_alloc	union
,	O
yyvs	pointer
)	O
;	O
if	O
(	O
yyss1	pointer
!=	O
yyssa	array
)	O
YYSTACK_FREE	O
(	O
yyss1	pointer
)	O
;	O
}	O
yyssp	pointer
=	O
yyss	pointer
+	O
yysize	long
-	O
1	int
;	O
yyvsp	pointer
=	O
yyvs	pointer
+	O
yysize	long
-	O
1	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Stack size increased to %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
int	O
)	O
yystacksize	long
)	O
)	O
;	O
if	O
(	O
yyss	pointer
+	O
yystacksize	long
-	O
1	int
<=	O
yyssp	pointer
)	O
YYABORT	O
;	O
}	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Entering state %d\n"	pointer
,	O
pd_yystate	int
)	O
)	O
;	O
if	O
(	O
pd_yystate	int
==	O
YYFINAL	int
)	O
YYACCEPT	O
;	O
goto	O
yybackup	O
;	O
yybackup	O
:	O
yyn	int
=	O
pd_yypact	array
[	O
pd_yystate	int
]	O
;	O
if	O
(	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
goto	O
yydefault	O
;	O
if	O
(	O
pd_yychar	int
==	O
YYEMPTY	O
)	O
{	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Reading a token: "	pointer
)	O
)	O
;	O
pd_yychar	int
=	O
YYLEX	O
;	O
}	O
if	O
(	O
pd_yychar	int
<=	O
YYEOF	int
)	O
{	O
pd_yychar	int
=	O
yytoken	int
=	O
YYEOF	int
;	O
YYDPRINTF	O
(	O
(	O
stderr	pointer
,	O
"Now at end of input.\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
pd_yychar	int
)	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Next token is"	pointer
,	O
yytoken	int
,	O
&	O
pd_yylval	union
,	O
&	O
pd_yylloc	O
)	O
;	O
}	O
yyn	int
+=	O
yytoken	int
;	O
if	O
(	O
yyn	int
<	O
0	int
||	O
YYLAST	int
<	O
yyn	int
||	O
pd_yycheck	array
[	O
yyn	int
]	O
!=	O
yytoken	int
)	O
goto	O
yydefault	O
;	O
yyn	int
=	O
pd_yytable	array
[	O
yyn	int
]	O
;	O
if	O
(	O
yyn	int
<=	O
0	int
)	O
{	O
if	O
(	O
yytable_value_is_error	O
(	O
yyn	int
)	O
)	O
goto	O
yyerrlab	O
;	O
yyn	int
=	O
-	O
yyn	int
;	O
goto	O
yyreduce	O
;	O
}	O
if	O
(	O
yyerrstatus	int
)	O
yyerrstatus	int
--	O
;	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	pointer
,	O
yytoken	int
,	O
&	O
pd_yylval	union
,	O
&	O
pd_yylloc	O
)	O
;	O
pd_yychar	int
=	O
YYEMPTY	O
;	O
pd_yystate	int
=	O
yyn	int
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	pointer
=	O
pd_yylval	union
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
goto	O
yynewstate	O
;	O
yydefault	O
:	O
yyn	int
=	O
yydefact	array
[	O
pd_yystate	int
]	O
;	O
if	O
(	O
yyn	int
==	O
0	int
)	O
goto	O
yyerrlab	O
;	O
goto	O
yyreduce	O
;	O
yyreduce	O
:	O
pd_yylen	int
=	O
pd_yyr2	array
[	O
yyn	int
]	O
;	O
pd_yyval	union
=	O
yyvsp	pointer
[	O
1	int
-	O
pd_yylen	int
]	O
;	O
YY_REDUCE_PRINT	O
(	O
yyn	int
)	O
;	O
switch	O
(	O
yyn	int
)	O
{	O
case	O
2	int
:	O
{	O
pd	struct
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
datespec	struct
)	O
;	O
}	O
break	O
;	O
case	O
3	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
datespec	struct
)	O
.	O
date	struct
)	O
;	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
datespec	struct
)	O
.	O
rel	struct
)	O
;	O
}	O
break	O
;	O
case	O
4	int
:	O
{	O
if	O
(	O
pd_date_union	function
(	O
&	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
,	O
&	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
)	O
)	O
YYERROR	O
;	O
(	O
pd_yyval	union
.	O
datespec	struct
)	O
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
;	O
}	O
break	O
;	O
case	O
5	int
:	O
{	O
if	O
(	O
pd_date_union	function
(	O
&	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
rel	struct
,	O
&	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
)	O
)	O
YYERROR	O
;	O
(	O
pd_yyval	union
.	O
datespec	struct
)	O
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
;	O
}	O
break	O
;	O
case	O
6	int
:	O
{	O
if	O
(	O
MASK_IS_SET	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
.	O
mask	int
,	O
(	O
MU_PD_MASK_TIME	O
|	O
MU_PD_MASK_DATE	O
)	O
)	O
&&	O
!	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
rel	struct
.	O
mask	int
)	O
{	O
if	O
(	O
MASK_IS_SET	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_YEAR	int
)	O
)	O
{	O
if	O
(	O
!	O
MASK_IS_SET	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_TZ	int
)	O
)	O
SET_TZ_PACK	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
else	O
YYERROR	O
;	O
}	O
else	O
{	O
SET_YEAR	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
>	O
10000	int
)	O
{	O
SET_DAY	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
%	O
100	int
)	O
;	O
SET_MONTH	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
,	O
(	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
/	O
100	int
)	O
%	O
100	int
)	O
;	O
SET_YEAR	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
/	O
10000	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
<	O
100	int
)	O
{	O
SET_YEAR	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
else	O
{	O
SET_HOUR	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
/	O
100	int
)	O
;	O
SET_MINUTE	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
%	O
100	int
)	O
;	O
}	O
SET_MERIDIAN	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
.	O
date	struct
,	O
MER24	int
)	O
;	O
}	O
}	O
(	O
pd_yyval	union
.	O
datespec	struct
)	O
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
datespec	struct
)	O
;	O
}	O
break	O
;	O
case	O
11	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_HOUR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MERIDIAN	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
meridian	enum
)	O
)	O
;	O
}	O
break	O
;	O
case	O
12	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_HOUR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MINUTE	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MERIDIAN	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
meridian	enum
)	O
)	O
;	O
}	O
break	O
;	O
case	O
13	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_HOUR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MINUTE	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MERIDIAN	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
MER24	int
)	O
;	O
SET_TZ_PACK	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
14	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_HOUR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MINUTE	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_SECOND	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
5	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MERIDIAN	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
meridian	enum
)	O
)	O
;	O
}	O
break	O
;	O
case	O
15	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_HOUR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MINUTE	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_SECOND	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
5	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MERIDIAN	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
MER24	int
)	O
;	O
SET_TZ_PACK	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
6	int
)	O
-	O
(	O
6	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
16	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_TZ	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
tz	pointer
)	O
.	O
delta	int
)	O
;	O
(	O
pd_yyval	union
.	O
date	struct
)	O
.	O
tzname	array
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
tz	pointer
)	O
.	O
name	pointer
;	O
}	O
break	O
;	O
case	O
17	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_TZ	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
tz	pointer
)	O
.	O
delta	int
-	O
60	int
)	O
;	O
(	O
pd_yyval	union
.	O
date	struct
)	O
.	O
tzname	array
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
tz	pointer
)	O
.	O
name	pointer
;	O
}	O
break	O
;	O
case	O
18	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_TZ	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
tz	pointer
)	O
.	O
delta	int
-	O
60	int
)	O
;	O
(	O
pd_yyval	union
.	O
date	struct
)	O
.	O
tzname	array
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
tz	pointer
)	O
.	O
name	pointer
;	O
}	O
break	O
;	O
case	O
19	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_ORDINAL	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
1	int
)	O
;	O
SET_NUMBER	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
20	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_ORDINAL	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
1	int
)	O
;	O
SET_NUMBER	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
21	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_ORDINAL	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_NUMBER	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
22	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
23	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
if	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
number	int
)	O
>=	O
1000	int
)	O
{	O
SET_YEAR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
5	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
else	O
{	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_YEAR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
5	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
24	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_YEAR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
-	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
-	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
25	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
if	O
(	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
<	O
32	int
)	O
{	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_YEAR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
-	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
else	O
{	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
-	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_YEAR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
26	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
27	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_YEAR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
4	int
)	O
-	O
(	O
4	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
28	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
29	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_YEAR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
3	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
30	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_ORDINAL	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
1	int
)	O
;	O
SET_NUMBER	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
3	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
SET_YEAR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
5	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
if	O
(	O
pd_date_union	function
(	O
&	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
&	O
(	O
yyvsp	pointer
[	O
(	O
4	int
)	O
-	O
(	O
5	int
)	O
]	O
.	O
date	struct
)	O
)	O
)	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
31	int
:	O
{	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
second	int
=	O
-	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
second	int
;	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
minute	int
=	O
-	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
minute	int
;	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
hour	int
=	O
-	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
hour	int
;	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
day	int
=	O
-	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
day	int
;	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
month	int
=	O
-	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
month	int
;	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
year	int
=	O
-	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
.	O
year	int
;	O
(	O
pd_yyval	union
.	O
date	struct
)	O
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
;	O
}	O
break	O
;	O
case	O
33	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
if	O
(	O
pd_date_union	function
(	O
&	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
&	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
date	struct
)	O
)	O
)	O
YYERROR	O
;	O
}	O
break	O
;	O
case	O
34	int
:	O
{	O
if	O
(	O
pd_date_union	function
(	O
&	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
,	O
&	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
)	O
)	O
YYERROR	O
;	O
(	O
pd_yyval	union
.	O
date	struct
)	O
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
date	struct
)	O
;	O
}	O
break	O
;	O
case	O
35	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_YEAR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
36	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_YEAR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
37	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_YEAR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
38	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
39	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
40	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_MONTH	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
41	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
42	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
43	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_DAY	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
44	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_HOUR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
45	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_HOUR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
46	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_HOUR	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
47	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_MINUTE	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
48	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_MINUTE	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
49	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_MINUTE	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
50	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_SECOND	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
51	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_SECOND	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
*	O
(	O
yyvsp	pointer
[	O
(	O
2	int
)	O
-	O
(	O
2	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
52	int
:	O
{	O
DATE_INIT	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
)	O
;	O
SET_SECOND	O
(	O
(	O
pd_yyval	union
.	O
date	struct
)	O
,	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
number	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
53	int
:	O
{	O
(	O
pd_yyval	union
.	O
meridian	enum
)	O
=	O
MER24	int
;	O
}	O
break	O
;	O
case	O
54	int
:	O
{	O
(	O
pd_yyval	union
.	O
meridian	enum
)	O
=	O
(	O
yyvsp	pointer
[	O
(	O
1	int
)	O
-	O
(	O
1	int
)	O
]	O
.	O
meridian	enum
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
YY_SYMBOL_PRINT	O
(	O
"-> $$ ="	pointer
,	O
pd_yyr1	array
[	O
yyn	int
]	O
,	O
&	O
pd_yyval	union
,	O
&	O
yyloc	O
)	O
;	O
YYPOPSTACK	O
(	O
pd_yylen	int
)	O
;	O
pd_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
*	O
++	O
yyvsp	pointer
=	O
pd_yyval	union
;	O
yyn	int
=	O
pd_yyr1	array
[	O
yyn	int
]	O
;	O
pd_yystate	int
=	O
yypgoto	array
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
+	O
*	O
yyssp	pointer
;	O
if	O
(	O
0	int
<=	O
pd_yystate	int
&&	O
pd_yystate	int
<=	O
YYLAST	int
&&	O
pd_yycheck	array
[	O
pd_yystate	int
]	O
==	O
*	O
yyssp	pointer
)	O
pd_yystate	int
=	O
pd_yytable	array
[	O
pd_yystate	int
]	O
;	O
else	O
pd_yystate	int
=	O
yydefgoto	array
[	O
yyn	int
-	O
YYNTOKENS	int
]	O
;	O
goto	O
yynewstate	O
;	O
yyerrlab	O
:	O
yytoken	int
=	O
pd_yychar	int
==	O
YYEMPTY	O
?	O
YYEMPTY	O
:	O
YYTRANSLATE	O
(	O
pd_yychar	int
)	O
;	O
if	O
(	O
!	O
yyerrstatus	int
)	O
{	O
++	O
pd_yynerrs	int
;	O
pd_yyerror	function
(	O
YY_	O
(	O
"syntax error"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
yyerrstatus	int
==	O
3	int
)	O
{	O
if	O
(	O
pd_yychar	int
<=	O
YYEOF	int
)	O
{	O
if	O
(	O
pd_yychar	int
==	O
YYEOF	int
)	O
YYABORT	O
;	O
}	O
else	O
{	O
yydestruct	function
(	O
"Error: discarding"	pointer
,	O
yytoken	int
,	O
&	O
pd_yylval	union
)	O
;	O
pd_yychar	int
=	O
YYEMPTY	O
;	O
}	O
}	O
goto	O
yyerrlab1	O
;	O
yyerrorlab	O
:	O
if	O
(	O
0	int
)	O
goto	O
yyerrorlab	O
;	O
YYPOPSTACK	O
(	O
pd_yylen	int
)	O
;	O
pd_yylen	int
=	O
0	int
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
pd_yystate	int
=	O
*	O
yyssp	pointer
;	O
goto	O
yyerrlab1	O
;	O
yyerrlab1	O
:	O
yyerrstatus	int
=	O
3	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
yyn	int
=	O
pd_yypact	array
[	O
pd_yystate	int
]	O
;	O
if	O
(	O
!	O
yypact_value_is_default	O
(	O
yyn	int
)	O
)	O
{	O
yyn	int
+=	O
YYTERROR	int
;	O
if	O
(	O
0	int
<=	O
yyn	int
&&	O
yyn	int
<=	O
YYLAST	int
&&	O
pd_yycheck	array
[	O
yyn	int
]	O
==	O
YYTERROR	int
)	O
{	O
yyn	int
=	O
pd_yytable	array
[	O
yyn	int
]	O
;	O
if	O
(	O
0	int
<	O
yyn	int
)	O
break	O
;	O
}	O
}	O
if	O
(	O
yyssp	pointer
==	O
yyss	pointer
)	O
YYABORT	O
;	O
yydestruct	function
(	O
"Error: popping"	pointer
,	O
yystos	array
[	O
pd_yystate	int
]	O
,	O
yyvsp	pointer
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
pd_yystate	int
=	O
*	O
yyssp	pointer
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
}	O
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	O
*	O
++	O
yyvsp	pointer
=	O
pd_yylval	union
;	O
YY_IGNORE_MAYBE_UNINITIALIZED_END	O
YY_SYMBOL_PRINT	O
(	O
"Shifting"	pointer
,	O
yystos	array
[	O
yyn	int
]	O
,	O
yyvsp	pointer
,	O
yylsp	O
)	O
;	O
pd_yystate	int
=	O
yyn	int
;	O
goto	O
yynewstate	O
;	O
yyacceptlab	O
:	O
yyresult	int
=	O
0	int
;	O
goto	O
yyreturn	O
;	O
yyabortlab	O
:	O
yyresult	int
=	O
1	int
;	O
goto	O
yyreturn	O
;	O
yyexhaustedlab	O
:	O
pd_yyerror	function
(	O
YY_	O
(	O
"memory exhausted"	pointer
)	O
)	O
;	O
yyresult	int
=	O
2	int
;	O
yyreturn	O
:	O
if	O
(	O
pd_yychar	int
!=	O
YYEMPTY	O
)	O
{	O
yytoken	int
=	O
YYTRANSLATE	O
(	O
pd_yychar	int
)	O
;	O
yydestruct	function
(	O
"Cleanup: discarding lookahead"	pointer
,	O
yytoken	int
,	O
&	O
pd_yylval	union
)	O
;	O
}	O
YYPOPSTACK	O
(	O
pd_yylen	int
)	O
;	O
YY_STACK_PRINT	O
(	O
yyss	pointer
,	O
yyssp	pointer
)	O
;	O
while	O
(	O
yyssp	pointer
!=	O
yyss	pointer
)	O
{	O
yydestruct	function
(	O
"Cleanup: popping"	pointer
,	O
yystos	array
[	O
*	O
yyssp	pointer
]	O
,	O
yyvsp	pointer
)	O
;	O
YYPOPSTACK	O
(	O
1	int
)	O
;	O
}	O
if	O
(	O
yyss	pointer
!=	O
yyssa	array
)	O
YYSTACK_FREE	O
(	O
yyss	pointer
)	O
;	O
return	O
YYID	O
(	O
yyresult	int
)	O
;	O
}	O
static	O
SYMBOL	struct
const	O
month_day_tab	array
[	O
]	O
=	O
{	O
{	O
"january"	pointer
,	O
T_MONTH	int
,	O
1	int
}	O
,	O
{	O
"february"	pointer
,	O
T_MONTH	int
,	O
2	int
}	O
,	O
{	O
"march"	pointer
,	O
T_MONTH	int
,	O
3	int
}	O
,	O
{	O
"april"	pointer
,	O
T_MONTH	int
,	O
4	int
}	O
,	O
{	O
"may"	pointer
,	O
T_MONTH	int
,	O
5	int
}	O
,	O
{	O
"june"	pointer
,	O
T_MONTH	int
,	O
6	int
}	O
,	O
{	O
"july"	pointer
,	O
T_MONTH	int
,	O
7	int
}	O
,	O
{	O
"august"	pointer
,	O
T_MONTH	int
,	O
8	int
}	O
,	O
{	O
"september"	pointer
,	O
T_MONTH	int
,	O
9	int
}	O
,	O
{	O
"sept"	pointer
,	O
T_MONTH	int
,	O
9	int
}	O
,	O
{	O
"october"	pointer
,	O
T_MONTH	int
,	O
10	int
}	O
,	O
{	O
"november"	pointer
,	O
T_MONTH	int
,	O
11	int
}	O
,	O
{	O
"december"	pointer
,	O
T_MONTH	int
,	O
12	int
}	O
,	O
{	O
"sunday"	pointer
,	O
T_DAY	int
,	O
0	int
}	O
,	O
{	O
"monday"	pointer
,	O
T_DAY	int
,	O
1	int
}	O
,	O
{	O
"tuesday"	pointer
,	O
T_DAY	int
,	O
2	int
}	O
,	O
{	O
"tues"	pointer
,	O
T_DAY	int
,	O
2	int
}	O
,	O
{	O
"wednesday"	pointer
,	O
T_DAY	int
,	O
3	int
}	O
,	O
{	O
"wednes"	pointer
,	O
T_DAY	int
,	O
3	int
}	O
,	O
{	O
"thursday"	pointer
,	O
T_DAY	int
,	O
4	int
}	O
,	O
{	O
"thur"	pointer
,	O
T_DAY	int
,	O
4	int
}	O
,	O
{	O
"thurs"	pointer
,	O
T_DAY	int
,	O
4	int
}	O
,	O
{	O
"friday"	pointer
,	O
T_DAY	int
,	O
5	int
}	O
,	O
{	O
"saturday"	pointer
,	O
T_DAY	int
,	O
6	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
SYMBOL	struct
const	O
units_tab	array
[	O
]	O
=	O
{	O
{	O
"year"	pointer
,	O
T_YEAR_UNIT	int
,	O
1	int
}	O
,	O
{	O
"month"	pointer
,	O
T_MONTH_UNIT	int
,	O
1	int
}	O
,	O
{	O
"fortnight"	pointer
,	O
T_DAY_UNIT	int
,	O
14	int
}	O
,	O
{	O
"week"	pointer
,	O
T_DAY_UNIT	int
,	O
7	int
}	O
,	O
{	O
"day"	pointer
,	O
T_DAY_UNIT	int
,	O
1	int
}	O
,	O
{	O
"hour"	pointer
,	O
T_HOUR_UNIT	int
,	O
1	int
}	O
,	O
{	O
"minute"	pointer
,	O
T_MINUTE_UNIT	int
,	O
1	int
}	O
,	O
{	O
"min"	pointer
,	O
T_MINUTE_UNIT	int
,	O
1	int
}	O
,	O
{	O
"second"	pointer
,	O
T_SEC_UNIT	int
,	O
1	int
}	O
,	O
{	O
"sec"	pointer
,	O
T_SEC_UNIT	int
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
SYMBOL	struct
const	O
other_tab	array
[	O
]	O
=	O
{	O
{	O
"tomorrow"	pointer
,	O
T_MINUTE_UNIT	int
,	O
1	int
*	O
24	int
*	O
60	int
}	O
,	O
{	O
"yesterday"	pointer
,	O
T_MINUTE_UNIT	int
,	O
-	O
1	int
*	O
24	int
*	O
60	int
}	O
,	O
{	O
"today"	pointer
,	O
T_MINUTE_UNIT	int
,	O
0	int
}	O
,	O
{	O
"now"	pointer
,	O
T_MINUTE_UNIT	int
,	O
0	int
}	O
,	O
{	O
"last"	pointer
,	O
T_UNUMBER	int
,	O
-	O
1	int
}	O
,	O
{	O
"this"	pointer
,	O
T_MINUTE_UNIT	int
,	O
0	int
}	O
,	O
{	O
"next"	pointer
,	O
T_UNUMBER	int
,	O
1	int
}	O
,	O
{	O
"first"	pointer
,	O
T_UNUMBER	int
,	O
1	int
}	O
,	O
{	O
"third"	pointer
,	O
T_UNUMBER	int
,	O
3	int
}	O
,	O
{	O
"fourth"	pointer
,	O
T_UNUMBER	int
,	O
4	int
}	O
,	O
{	O
"fifth"	pointer
,	O
T_UNUMBER	int
,	O
5	int
}	O
,	O
{	O
"sixth"	pointer
,	O
T_UNUMBER	int
,	O
6	int
}	O
,	O
{	O
"seventh"	pointer
,	O
T_UNUMBER	int
,	O
7	int
}	O
,	O
{	O
"eighth"	pointer
,	O
T_UNUMBER	int
,	O
8	int
}	O
,	O
{	O
"ninth"	pointer
,	O
T_UNUMBER	int
,	O
9	int
}	O
,	O
{	O
"tenth"	pointer
,	O
T_UNUMBER	int
,	O
10	int
}	O
,	O
{	O
"eleventh"	pointer
,	O
T_UNUMBER	int
,	O
11	int
}	O
,	O
{	O
"twelfth"	pointer
,	O
T_UNUMBER	int
,	O
12	int
}	O
,	O
{	O
"ago"	pointer
,	O
T_AGO	int
,	O
1	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
SYMBOL	struct
const	O
tz_tab	array
[	O
]	O
=	O
{	O
{	O
"gmt"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
0	int
)	O
}	O
,	O
{	O
"ut"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
0	int
)	O
}	O
,	O
{	O
"utc"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
0	int
)	O
}	O
,	O
{	O
"wet"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
0	int
)	O
}	O
,	O
{	O
"bst"	pointer
,	O
T_DAYZONE	int
,	O
HOUR	O
(	O
0	int
)	O
}	O
,	O
{	O
"wat"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
1	int
)	O
}	O
,	O
{	O
"at"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
2	int
)	O
}	O
,	O
{	O
"ast"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
4	int
)	O
}	O
,	O
{	O
"adt"	pointer
,	O
T_DAYZONE	int
,	O
HOUR	O
(	O
4	int
)	O
}	O
,	O
{	O
"est"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
5	int
)	O
}	O
,	O
{	O
"edt"	pointer
,	O
T_DAYZONE	int
,	O
HOUR	O
(	O
5	int
)	O
}	O
,	O
{	O
"cst"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
6	int
)	O
}	O
,	O
{	O
"cdt"	pointer
,	O
T_DAYZONE	int
,	O
HOUR	O
(	O
6	int
)	O
}	O
,	O
{	O
"mst"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
7	int
)	O
}	O
,	O
{	O
"mdt"	pointer
,	O
T_DAYZONE	int
,	O
HOUR	O
(	O
7	int
)	O
}	O
,	O
{	O
"pst"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
8	int
)	O
}	O
,	O
{	O
"pdt"	pointer
,	O
T_DAYZONE	int
,	O
HOUR	O
(	O
8	int
)	O
}	O
,	O
{	O
"yst"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
9	int
)	O
}	O
,	O
{	O
"ydt"	pointer
,	O
T_DAYZONE	int
,	O
HOUR	O
(	O
9	int
)	O
}	O
,	O
{	O
"hst"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
10	int
)	O
}	O
,	O
{	O
"hdt"	pointer
,	O
T_DAYZONE	int
,	O
HOUR	O
(	O
10	int
)	O
}	O
,	O
{	O
"cat"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
10	int
)	O
}	O
,	O
{	O
"ahst"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
10	int
)	O
}	O
,	O
{	O
"nt"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
11	int
)	O
}	O
,	O
{	O
"idlw"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
12	int
)	O
}	O
,	O
{	O
"cet"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
1	int
)	O
}	O
,	O
{	O
"met"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
1	int
)	O
}	O
,	O
{	O
"mewt"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
1	int
)	O
}	O
,	O
{	O
"mest"	pointer
,	O
T_DAYZONE	int
,	O
-	O
HOUR	O
(	O
1	int
)	O
}	O
,	O
{	O
"mesz"	pointer
,	O
T_DAYZONE	int
,	O
-	O
HOUR	O
(	O
1	int
)	O
}	O
,	O
{	O
"swt"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
1	int
)	O
}	O
,	O
{	O
"sst"	pointer
,	O
T_DAYZONE	int
,	O
-	O
HOUR	O
(	O
1	int
)	O
}	O
,	O
{	O
"fwt"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
1	int
)	O
}	O
,	O
{	O
"fst"	pointer
,	O
T_DAYZONE	int
,	O
-	O
HOUR	O
(	O
1	int
)	O
}	O
,	O
{	O
"eet"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
2	int
)	O
}	O
,	O
{	O
"bt"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
3	int
)	O
}	O
,	O
{	O
"zp4"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
4	int
)	O
}	O
,	O
{	O
"zp5"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
5	int
)	O
}	O
,	O
{	O
"zp6"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
6	int
)	O
}	O
,	O
{	O
"wast"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
7	int
)	O
}	O
,	O
{	O
"wadt"	pointer
,	O
T_DAYZONE	int
,	O
-	O
HOUR	O
(	O
7	int
)	O
}	O
,	O
{	O
"cct"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
8	int
)	O
}	O
,	O
{	O
"jst"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
9	int
)	O
}	O
,	O
{	O
"east"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
10	int
)	O
}	O
,	O
{	O
"eadt"	pointer
,	O
T_DAYZONE	int
,	O
-	O
HOUR	O
(	O
10	int
)	O
}	O
,	O
{	O
"gst"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
10	int
)	O
}	O
,	O
{	O
"nzt"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
12	int
)	O
}	O
,	O
{	O
"nzst"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
12	int
)	O
}	O
,	O
{	O
"nzdt"	pointer
,	O
T_DAYZONE	int
,	O
-	O
HOUR	O
(	O
12	int
)	O
}	O
,	O
{	O
"idle"	pointer
,	O
T_ZONE	int
,	O
-	O
HOUR	O
(	O
12	int
)	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
SYMBOL	struct
const	O
mil_tz_tab	array
[	O
]	O
=	O
{	O
{	O
"a"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
1	int
)	O
}	O
,	O
{	O
"b"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
2	int
)	O
}	O
,	O
{	O
"c"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
3	int
)	O
}	O
,	O
{	O
"d"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
4	int
)	O
}	O
,	O
{	O
"e"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
5	int
)	O
}	O
,	O
{	O
"f"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
6	int
)	O
}	O
,	O
{	O
"g"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
7	int
)	O
}	O
,	O
{	O
"h"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
8	int
)	O
}	O
,	O
{	O
"i"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
9	int
)	O
}	O
,	O
{	O
"k"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
10	int
)	O
}	O
,	O
{	O
"l"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
11	int
)	O
}	O
,	O
{	O
"m"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
12	int
)	O
}	O
,	O
{	O
"n"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
1	int
)	O
}	O
,	O
{	O
"o"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
2	int
)	O
}	O
,	O
{	O
"p"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
3	int
)	O
}	O
,	O
{	O
"q"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
4	int
)	O
}	O
,	O
{	O
"r"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
5	int
)	O
}	O
,	O
{	O
"s"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
6	int
)	O
}	O
,	O
{	O
"t"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
7	int
)	O
}	O
,	O
{	O
"u"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
8	int
)	O
}	O
,	O
{	O
"v"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
9	int
)	O
}	O
,	O
{	O
"w"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
10	int
)	O
}	O
,	O
{	O
"x"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
11	int
)	O
}	O
,	O
{	O
"y"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
-	O
12	int
)	O
}	O
,	O
{	O
"z"	pointer
,	O
T_ZONE	int
,	O
HOUR	O
(	O
0	int
)	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
int	O
pd_yyerror	function
(	O
char	O
*	O
s	pointer
MU_ARG_UNUSED	O
)	O
{	O
return	O
0	int
;	O
}	O
static	O
int	O
norm_hour	function
(	O
int	O
hours	int
,	O
MERIDIAN	enum
meridian	enum
)	O
{	O
switch	O
(	O
meridian	enum
)	O
{	O
case	O
MER24	int
:	O
if	O
(	O
hours	int
<	O
0	int
||	O
hours	int
>	O
23	int
)	O
return	O
-	O
1	int
;	O
return	O
hours	int
;	O
case	O
MERam	int
:	O
if	O
(	O
hours	int
<	O
1	int
||	O
hours	int
>	O
12	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
hours	int
==	O
12	int
)	O
hours	int
=	O
0	int
;	O
return	O
hours	int
;	O
case	O
MERpm	int
:	O
if	O
(	O
hours	int
<	O
1	int
||	O
hours	int
>	O
12	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
hours	int
==	O
12	int
)	O
hours	int
=	O
0	int
;	O
return	O
hours	int
+	O
12	int
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
int	O
norm_year	function
(	O
int	O
year	int
)	O
{	O
if	O
(	O
year	int
<	O
0	int
)	O
year	int
=	O
-	O
year	int
;	O
if	O
(	O
year	int
<	O
69	int
)	O
year	int
+=	O
2000	int
;	O
else	O
if	O
(	O
year	int
<	O
100	int
)	O
year	int
+=	O
1900	int
;	O
return	O
year	int
;	O
}	O
static	O
int	O
sym_lookup	function
(	O
char	O
*	O
buff	pointer
)	O
{	O
register	O
char	O
*	O
p	pointer
;	O
register	O
char	O
*	O
q	pointer
;	O
register	O
const	O
SYMBOL	struct
*	O
tp	pointer
;	O
int	O
i	int
;	O
int	O
abbrev	int
;	O
mu_strlower	function
(	O
buff	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
buff	pointer
,	O
"am"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
buff	pointer
,	O
"a.m."	pointer
)	O
==	O
0	int
)	O
{	O
pd_yylval	union
.	O
meridian	enum
=	O
MERam	int
;	O
return	O
T_MERIDIAN	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
buff	pointer
,	O
"pm"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
buff	pointer
,	O
"p.m."	pointer
)	O
==	O
0	int
)	O
{	O
pd_yylval	union
.	O
meridian	enum
=	O
MERpm	int
;	O
return	O
T_MERIDIAN	int
;	O
}	O
if	O
(	O
strlen	function
(	O
buff	pointer
)	O
==	O
3	int
)	O
abbrev	int
=	O
1	int
;	O
else	O
if	O
(	O
strlen	function
(	O
buff	pointer
)	O
==	O
4	int
&&	O
buff	pointer
[	O
3	int
]	O
==	O
'.'	O
)	O
{	O
abbrev	int
=	O
1	int
;	O
buff	pointer
[	O
3	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
abbrev	int
=	O
0	int
;	O
for	O
(	O
tp	pointer
=	O
month_day_tab	array
;	O
tp	pointer
->	O
name	pointer
;	O
tp	pointer
++	O
)	O
{	O
if	O
(	O
abbrev	int
)	O
{	O
if	O
(	O
strncmp	function
(	O
buff	pointer
,	O
tp	pointer
->	O
name	pointer
,	O
3	int
)	O
==	O
0	int
)	O
{	O
pd_yylval	union
.	O
number	int
=	O
tp	pointer
->	O
value	int
;	O
return	O
tp	pointer
->	O
type	int
;	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
buff	pointer
,	O
tp	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
pd_yylval	union
.	O
number	int
=	O
tp	pointer
->	O
value	int
;	O
return	O
tp	pointer
->	O
type	int
;	O
}	O
}	O
for	O
(	O
tp	pointer
=	O
tz_tab	array
;	O
tp	pointer
->	O
name	pointer
;	O
tp	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
buff	pointer
,	O
tp	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
pd_yylval	union
.	O
tz	pointer
.	O
name	pointer
=	O
tp	pointer
->	O
name	pointer
;	O
pd_yylval	union
.	O
tz	pointer
.	O
delta	int
=	O
tp	pointer
->	O
value	int
;	O
return	O
tp	pointer
->	O
type	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
buff	pointer
,	O
"dst"	pointer
)	O
==	O
0	int
)	O
return	O
T_DST	int
;	O
for	O
(	O
tp	pointer
=	O
units_tab	array
;	O
tp	pointer
->	O
name	pointer
;	O
tp	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
buff	pointer
,	O
tp	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
pd_yylval	union
.	O
number	int
=	O
tp	pointer
->	O
value	int
;	O
return	O
tp	pointer
->	O
type	int
;	O
}	O
i	int
=	O
strlen	function
(	O
buff	pointer
)	O
-	O
1	int
;	O
if	O
(	O
buff	pointer
[	O
i	int
]	O
==	O
's'	O
)	O
{	O
buff	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
tp	pointer
=	O
units_tab	array
;	O
tp	pointer
->	O
name	pointer
;	O
tp	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
buff	pointer
,	O
tp	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
pd_yylval	union
.	O
number	int
=	O
tp	pointer
->	O
value	int
;	O
return	O
tp	pointer
->	O
type	int
;	O
}	O
buff	pointer
[	O
i	int
]	O
=	O
's'	O
;	O
}	O
for	O
(	O
tp	pointer
=	O
other_tab	array
;	O
tp	pointer
->	O
name	pointer
;	O
tp	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
buff	pointer
,	O
tp	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
pd_yylval	union
.	O
number	int
=	O
tp	pointer
->	O
value	int
;	O
return	O
tp	pointer
->	O
type	int
;	O
}	O
if	O
(	O
buff	pointer
[	O
1	int
]	O
==	O
'\0'	O
&&	O
ISALPHA	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
buff	pointer
)	O
)	O
{	O
for	O
(	O
tp	pointer
=	O
mil_tz_tab	array
;	O
tp	pointer
->	O
name	pointer
;	O
tp	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
buff	pointer
,	O
tp	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
pd_yylval	union
.	O
tz	pointer
.	O
name	pointer
=	O
tp	pointer
->	O
name	pointer
;	O
pd_yylval	union
.	O
tz	pointer
.	O
delta	int
=	O
tp	pointer
->	O
value	int
;	O
return	O
tp	pointer
->	O
type	int
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
,	O
p	pointer
=	O
q	pointer
=	O
buff	pointer
;	O
*	O
q	pointer
;	O
q	pointer
++	O
)	O
if	O
(	O
*	O
q	pointer
!=	O
'.'	O
)	O
*	O
p	pointer
++	O
=	O
*	O
q	pointer
;	O
else	O
i	int
++	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
if	O
(	O
i	int
)	O
for	O
(	O
tp	pointer
=	O
tz_tab	array
;	O
tp	pointer
->	O
name	pointer
;	O
tp	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
buff	pointer
,	O
tp	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
pd_yylval	union
.	O
number	int
=	O
tp	pointer
->	O
value	int
;	O
return	O
tp	pointer
->	O
type	int
;	O
}	O
return	O
T_ID	int
;	O
}	O
static	O
int	O
pd_yylex	function
(	O
void	O
)	O
{	O
register	O
unsigned	O
char	O
c	int
;	O
register	O
char	O
*	O
p	pointer
;	O
char	O
buff	pointer
[	O
20	int
]	O
;	O
int	O
count	int
;	O
int	O
sign	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
ISSPACE	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
yyinput	pointer
)	O
)	O
yyinput	pointer
++	O
;	O
if	O
(	O
ISDIGIT	function
(	O
c	int
=	O
*	O
yyinput	pointer
)	O
||	O
c	int
==	O
'-'	O
||	O
c	int
==	O
'+'	O
)	O
{	O
if	O
(	O
c	int
==	O
'-'	O
||	O
c	int
==	O
'+'	O
)	O
{	O
sign	int
=	O
c	int
==	O
'-'	O
?	O
-	O
1	int
:	O
1	int
;	O
if	O
(	O
!	O
ISDIGIT	function
(	O
*	O
++	O
yyinput	pointer
)	O
)	O
continue	O
;	O
}	O
else	O
sign	int
=	O
0	int
;	O
for	O
(	O
pd_yylval	union
.	O
number	int
=	O
0	int
;	O
ISDIGIT	function
(	O
c	int
=	O
*	O
yyinput	pointer
++	O
)	O
;	O
)	O
pd_yylval	union
.	O
number	int
=	O
10	int
*	O
pd_yylval	union
.	O
number	int
+	O
c	int
-	O
'0'	O
;	O
yyinput	pointer
--	O
;	O
if	O
(	O
sign	int
<	O
0	int
)	O
pd_yylval	union
.	O
number	int
=	O
-	O
pd_yylval	union
.	O
number	int
;	O
return	O
sign	int
?	O
T_SNUMBER	int
:	O
T_UNUMBER	int
;	O
}	O
if	O
(	O
ISALPHA	O
(	O
c	int
)	O
)	O
{	O
for	O
(	O
p	pointer
=	O
buff	pointer
;	O
(	O
c	int
=	O
*	O
yyinput	pointer
++	O
,	O
ISALPHA	O
(	O
c	int
)	O
)	O
||	O
c	int
==	O
'.'	O
;	O
)	O
if	O
(	O
p	pointer
<	O
&	O
buff	pointer
[	O
sizeof	O
buff	pointer
-	O
1	int
]	O
)	O
*	O
p	pointer
++	O
=	O
c	int
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
yyinput	pointer
--	O
;	O
return	O
sym_lookup	function
(	O
buff	pointer
)	O
;	O
}	O
if	O
(	O
c	int
!=	O
'('	O
)	O
return	O
*	O
yyinput	pointer
++	O
;	O
count	int
=	O
0	int
;	O
do	O
{	O
c	int
=	O
*	O
yyinput	pointer
++	O
;	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
return	O
c	int
;	O
if	O
(	O
c	int
==	O
'('	O
)	O
count	int
++	O
;	O
else	O
if	O
(	O
c	int
==	O
')'	O
)	O
count	int
--	O
;	O
}	O
while	O
(	O
count	int
>	O
0	int
)	O
;	O
}	O
}	O
static	O
long	O
difftm	function
(	O
struct	O
tm	struct
*	O
a	pointer
,	O
struct	O
tm	struct
*	O
b	pointer
)	O
{	O
int	O
ay	int
=	O
a	pointer
->	O
tm_year	int
+	O
(	O
TM_YEAR_ORIGIN	int
-	O
1	int
)	O
;	O
int	O
by	int
=	O
b	pointer
->	O
tm_year	int
+	O
(	O
TM_YEAR_ORIGIN	int
-	O
1	int
)	O
;	O
long	O
days	long
=	O
(	O
a	pointer
->	O
tm_yday	int
-	O
b	pointer
->	O
tm_yday	int
+	O
(	O
(	O
ay	int
>>	O
2	int
)	O
-	O
(	O
by	int
>>	O
2	int
)	O
)	O
-	O
(	O
ay	int
/	O
100	int
-	O
by	int
/	O
100	int
)	O
+	O
(	O
(	O
ay	int
/	O
100	int
>>	O
2	int
)	O
-	O
(	O
by	int
/	O
100	int
>>	O
2	int
)	O
)	O
+	O
(	O
long	O
)	O
(	O
ay	int
-	O
by	int
)	O
*	O
365	int
)	O
;	O
return	O
(	O
60	int
*	O
(	O
60	int
*	O
(	O
24	int
*	O
days	long
+	O
(	O
a	pointer
->	O
tm_hour	int
-	O
b	pointer
->	O
tm_hour	int
)	O
)	O
+	O
(	O
a	pointer
->	O
tm_min	int
-	O
b	pointer
->	O
tm_min	int
)	O
)	O
+	O
(	O
a	pointer
->	O
tm_sec	int
-	O
b	pointer
->	O
tm_sec	int
)	O
)	O
;	O
}	O
int	O
mu_parse_date_dtl	function
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
time_t	long
*	O
now	pointer
,	O
time_t	long
*	O
rettime	pointer
,	O
struct	O
tm	struct
*	O
rettm	pointer
,	O
struct	O
mu_timezone	struct
*	O
rettz	pointer
,	O
int	O
*	O
retflags	pointer
)	O
{	O
struct	O
tm	struct
tm	struct
,	O
tm0	struct
,	O
*	O
tmp	pointer
;	O
time_t	long
start	long
;	O
yyinput	pointer
=	O
p	pointer
;	O
start	long
=	O
now	pointer
?	O
*	O
now	pointer
:	O
time	struct
(	O
(	O
time_t	long
*	O
)	O
NULL	O
)	O
;	O
tmp	pointer
=	O
localtime	function
(	O
&	O
start	long
)	O
;	O
if	O
(	O
!	O
tmp	pointer
)	O
return	O
-	O
1	int
;	O
memset	function
(	O
&	O
tm	struct
,	O
0	int
,	O
sizeof	O
tm	struct
)	O
;	O
tm	struct
.	O
tm_isdst	int
=	O
tmp	pointer
->	O
tm_isdst	int
;	O
if	O
(	O
pd_yyparse	function
(	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
MASK_IS_SET	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_YEAR	int
)	O
)	O
__SET_YEAR	O
(	O
pd	struct
.	O
date	struct
,	O
tmp	pointer
->	O
tm_year	int
+	O
TM_YEAR_ORIGIN	int
,	O
return	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
MASK_IS_SET	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_MONTH	int
)	O
)	O
__SET_MONTH	O
(	O
pd	struct
.	O
date	struct
,	O
tmp	pointer
->	O
tm_mon	int
+	O
1	int
,	O
return	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
MASK_IS_SET	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_DAY	int
)	O
)	O
__SET_DAY	O
(	O
pd	struct
.	O
date	struct
,	O
tmp	pointer
->	O
tm_mday	int
,	O
return	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
MASK_IS_SET	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_HOUR	int
)	O
)	O
__SET_HOUR	O
(	O
pd	struct
.	O
date	struct
,	O
tmp	pointer
->	O
tm_hour	int
,	O
return	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
MASK_IS_SET	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_MERIDIAN	int
)	O
)	O
__SET_MERIDIAN	O
(	O
pd	struct
.	O
date	struct
,	O
MER24	int
,	O
return	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
MASK_IS_SET	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_MINUTE	int
)	O
)	O
__SET_MINUTE	O
(	O
pd	struct
.	O
date	struct
,	O
tmp	pointer
->	O
tm_min	int
,	O
return	O
-	O
1	int
)	O
;	O
if	O
(	O
!	O
MASK_IS_SET	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_SECOND	int
)	O
)	O
__SET_SECOND	O
(	O
pd	struct
.	O
date	struct
,	O
tmp	pointer
->	O
tm_sec	int
,	O
return	O
-	O
1	int
)	O
;	O
tm	struct
.	O
tm_year	int
=	O
norm_year	function
(	O
pd	struct
.	O
date	struct
.	O
year	int
)	O
-	O
TM_YEAR_ORIGIN	int
+	O
pd	struct
.	O
rel	struct
.	O
year	int
;	O
tm	struct
.	O
tm_mon	int
=	O
pd	struct
.	O
date	struct
.	O
month	int
-	O
1	int
+	O
pd	struct
.	O
rel	struct
.	O
month	int
;	O
tm	struct
.	O
tm_mday	int
=	O
pd	struct
.	O
date	struct
.	O
day	int
+	O
pd	struct
.	O
rel	struct
.	O
day	int
;	O
if	O
(	O
MASK_TEST	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_TIME	O
)	O
||	O
(	O
pd	struct
.	O
rel	struct
.	O
mask	int
&&	O
!	O
MASK_TEST	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_DATE	O
)	O
&&	O
!	O
MASK_TEST	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_DOW	O
)	O
)	O
)	O
{	O
tm	struct
.	O
tm_hour	int
=	O
norm_hour	function
(	O
pd	struct
.	O
date	struct
.	O
hour	int
,	O
pd	struct
.	O
date	struct
.	O
meridian	enum
)	O
;	O
if	O
(	O
tm	struct
.	O
tm_hour	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
tm	struct
.	O
tm_min	int
=	O
pd	struct
.	O
date	struct
.	O
minute	int
;	O
tm	struct
.	O
tm_sec	int
=	O
pd	struct
.	O
date	struct
.	O
second	int
;	O
}	O
else	O
{	O
tm	struct
.	O
tm_hour	int
=	O
tm	struct
.	O
tm_min	int
=	O
tm	struct
.	O
tm_sec	int
=	O
0	int
;	O
}	O
tm	struct
.	O
tm_hour	int
+=	O
pd	struct
.	O
rel	struct
.	O
hour	int
;	O
tm	struct
.	O
tm_min	int
+=	O
pd	struct
.	O
rel	struct
.	O
minute	int
;	O
tm	struct
.	O
tm_sec	int
+=	O
pd	struct
.	O
rel	struct
.	O
second	int
;	O
if	O
(	O
MASK_TEST	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_DATE	O
|	O
MU_PD_MASK_DOW	O
|	O
MU_PD_MASK_TIME	O
)	O
||	O
MASK_TEST	O
(	O
pd	struct
.	O
rel	struct
.	O
mask	int
,	O
MU_PD_MASK_DOW	O
|	O
MU_PD_MASK_MONTH	int
|	O
MU_PD_MASK_YEAR	int
)	O
)	O
tm	struct
.	O
tm_isdst	int
=	O
-	O
1	int
;	O
tm0	struct
=	O
tm	struct
;	O
start	long
=	O
mktime	function
(	O
&	O
tm	struct
)	O
;	O
if	O
(	O
start	long
==	O
(	O
time_t	long
)	O
-	O
1	int
)	O
{	O
if	O
(	O
MASK_TEST	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_TZ	int
)	O
)	O
{	O
tm	struct
=	O
tm0	struct
;	O
if	O
(	O
tm	struct
.	O
tm_year	int
<=	O
EPOCH	int
-	O
TM_YEAR_ORIGIN	int
)	O
{	O
tm	struct
.	O
tm_mday	int
++	O
;	O
pd	struct
.	O
date	struct
.	O
tz	pointer
-=	O
24	int
*	O
60	int
;	O
}	O
else	O
{	O
tm	struct
.	O
tm_mday	int
--	O
;	O
pd	struct
.	O
date	struct
.	O
tz	pointer
+=	O
24	int
*	O
60	int
;	O
}	O
start	long
=	O
mktime	function
(	O
&	O
tm	struct
)	O
;	O
}	O
if	O
(	O
start	long
==	O
(	O
time_t	long
)	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
MASK_TEST	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_DOW	O
)	O
&&	O
!	O
MASK_TEST	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_DATE	O
)	O
)	O
{	O
tm	struct
.	O
tm_mday	int
+=	O
(	O
(	O
pd	struct
.	O
date	struct
.	O
number	int
-	O
tm	struct
.	O
tm_wday	int
+	O
7	int
)	O
%	O
7	int
+	O
7	int
*	O
(	O
pd	struct
.	O
date	struct
.	O
ordinal	int
-	O
(	O
0	int
<	O
pd	struct
.	O
date	struct
.	O
ordinal	int
)	O
)	O
)	O
;	O
start	long
=	O
mktime	function
(	O
&	O
tm	struct
)	O
;	O
if	O
(	O
start	long
==	O
(	O
time_t	long
)	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
MASK_TEST	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_TZ	int
)	O
)	O
{	O
long	O
delta	int
;	O
struct	O
tm	struct
*	O
gmt	pointer
=	O
gmtime	function
(	O
&	O
start	long
)	O
;	O
if	O
(	O
gmt	pointer
)	O
{	O
delta	int
=	O
pd	struct
.	O
date	struct
.	O
tz	pointer
*	O
60L	int
+	O
difftm	function
(	O
&	O
tm	struct
,	O
gmt	pointer
)	O
;	O
if	O
(	O
(	O
start	long
+	O
delta	int
<	O
start	long
)	O
!=	O
(	O
delta	int
<	O
0	int
)	O
)	O
return	O
-	O
1	int
;	O
start	long
+=	O
delta	int
;	O
}	O
}	O
if	O
(	O
MASK_TEST	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_TZ	int
)	O
)	O
{	O
pd	struct
.	O
date	struct
.	O
tz	pointer
=	O
-	O
pd	struct
.	O
date	struct
.	O
tz	pointer
*	O
60L	int
;	O
if	O
(	O
!	O
pd	struct
.	O
date	struct
.	O
tzname	array
)	O
pd	struct
.	O
date	struct
.	O
tzname	array
=	O
tm	struct
.	O
tm_isdst	int
!=	O
-	O
1	int
?	O
tzname	array
[	O
tm	struct
.	O
tm_isdst	int
]	O
:	O
NULL	O
;	O
tm	struct
.	O
tm_gmtoff	long
=	O
pd	struct
.	O
date	struct
.	O
tz	pointer
;	O
tm	struct
.	O
tm_zone	pointer
=	O
pd	struct
.	O
date	struct
.	O
tzname	array
;	O
}	O
if	O
(	O
rettime	pointer
)	O
*	O
rettime	pointer
=	O
start	long
;	O
if	O
(	O
rettm	pointer
)	O
*	O
rettm	pointer
=	O
tm	struct
;	O
if	O
(	O
rettz	pointer
)	O
{	O
if	O
(	O
MASK_TEST	O
(	O
pd	struct
.	O
date	struct
.	O
mask	int
,	O
MU_PD_MASK_TZ	int
)	O
)	O
{	O
rettz	pointer
->	O
utc_offset	int
=	O
pd	struct
.	O
date	struct
.	O
tz	pointer
;	O
rettz	pointer
->	O
tz_name	pointer
=	O
pd	struct
.	O
date	struct
.	O
tzname	array
;	O
}	O
else	O
{	O
mu_datetime_tz_local	function
(	O
rettz	pointer
)	O
;	O
}	O
}	O
if	O
(	O
retflags	pointer
)	O
*	O
retflags	pointer
=	O
pd	struct
.	O
date	struct
.	O
mask	int
;	O
return	O
0	int
;	O
}	O
int	O
mu_parse_date	function
(	O
const	O
char	O
*	O
p	pointer
,	O
time_t	long
*	O
rettime	pointer
,	O
const	O
time_t	long
*	O
now	pointer
)	O
{	O
return	O
mu_parse_date_dtl	function
(	O
p	pointer
,	O
now	pointer
,	O
rettime	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
