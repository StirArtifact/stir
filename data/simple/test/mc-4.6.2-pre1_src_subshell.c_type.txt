static	O
char	O
tcsh_fifo	array
[	O
128	int
]	O
;	O
static	O
void	O
init_raw_mode	function
(	O
void	O
)	O
;	O
static	O
int	O
feed_subshell	function
(	O
int	O
how	int
,	O
int	O
fail_on_error	int
)	O
;	O
static	O
void	O
synchronize	function
(	O
void	O
)	O
;	O
static	O
int	O
pty_open_master	function
(	O
char	O
*	O
pty_name	pointer
)	O
;	O
static	O
int	O
pty_open_slave	function
(	O
const	O
char	O
*	O
pty_name	pointer
)	O
;	O
static	O
int	O
resize_tty	function
(	O
int	O
fd	int
)	O
;	O
int	O
use_subshell	int
=	O
TRUE	O
;	O
int	O
subshell_pty	int
=	O
0	int
;	O
static	O
int	O
subshell_pty_slave	int
=	O
-	O
1	int
;	O
static	O
const	O
char	O
subshell_switch_key	char
=	O
XCTRL	O
(	O
'o'	O
)	O
&	O
255	int
;	O
enum	O
subshell_state_enum	enum
subshell_state	enum
;	O
char	O
*	O
subshell_prompt	pointer
=	O
NULL	O
;	O
enum	O
{	O
READ	int
=	O
0	int
,	O
WRITE	int
=	O
1	int
}	O
;	O
static	O
char	O
*	O
pty_buffer	pointer
;	O
static	O
int	O
pty_buffer_size	int
;	O
static	O
int	O
subshell_pipe	array
[	O
2	int
]	O
;	O
static	O
pid_t	int
subshell_pid	int
=	O
1	int
;	O
static	O
char	O
subshell_cwd	array
[	O
MC_MAXPATHLEN	O
+	O
1	int
]	O
;	O
static	O
enum	O
{	O
BASH	int
,	O
TCSH	int
,	O
ZSH	int
}	O
subshell_type	enum
;	O
static	O
int	O
subshell_ready	int
;	O
static	O
volatile	O
int	O
subshell_alive	int
,	O
subshell_stopped	int
;	O
static	O
struct	O
termios	struct
shell_mode	struct
;	O
static	O
struct	O
termios	struct
raw_mode	struct
;	O
static	O
int	O
prompt_pos	int
;	O
static	O
ssize_t	long
write_all	function
(	O
int	O
fd	int
,	O
const	O
void	O
*	O
buf	pointer
,	O
size_t	long
count	int
)	O
{	O
ssize_t	long
ret	long
;	O
ssize_t	long
written	long
=	O
0	int
;	O
while	O
(	O
count	int
>	O
0	int
)	O
{	O
ret	long
=	O
write	pointer
(	O
fd	int
,	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
buf	pointer
+	O
written	long
,	O
count	int
)	O
;	O
if	O
(	O
ret	long
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
{	O
continue	O
;	O
}	O
else	O
{	O
return	O
written	long
>	O
0	int
?	O
written	long
:	O
ret	long
;	O
}	O
}	O
count	int
-=	O
ret	long
;	O
written	long
+=	O
ret	long
;	O
}	O
return	O
written	long
;	O
}	O
static	O
void	O
init_subshell_child	function
(	O
const	O
char	O
*	O
pty_name	pointer
)	O
{	O
const	O
char	O
*	O
init_file	pointer
=	O
NULL	O
;	O
pid_t	int
mc_sid	int
;	O
setsid	function
(	O
)	O
;	O
ioctl	function
(	O
subshell_pty_slave	int
,	O
TIOCSCTTY	int
,	O
0	int
)	O
;	O
shell_mode	struct
.	O
c_lflag	short
|=	O
TOSTOP	int
;	O
if	O
(	O
tcsetattr	function
(	O
subshell_pty_slave	int
,	O
TCSANOW	int
,	O
&	O
shell_mode	struct
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot set pty terminal modes: %s\r\n"	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
_exit	function
(	O
FORK_FAILURE	int
)	O
;	O
}	O
resize_tty	function
(	O
subshell_pty_slave	int
)	O
;	O
chdir	function
(	O
home_dir	pointer
)	O
;	O
mc_sid	int
=	O
getsid	function
(	O
0	int
)	O
;	O
if	O
(	O
mc_sid	int
!=	O
-	O
1	int
)	O
{	O
char	O
sid_str	array
[	O
BUF_SMALL	int
]	O
;	O
g_snprintf	function
(	O
sid_str	array
,	O
sizeof	O
(	O
sid_str	array
)	O
,	O
"MC_SID=%ld"	pointer
,	O
(	O
long	O
)	O
mc_sid	int
)	O
;	O
putenv	function
(	O
g_strdup	function
(	O
sid_str	array
)	O
)	O
;	O
}	O
switch	O
(	O
subshell_type	enum
)	O
{	O
case	O
BASH	int
:	O
init_file	pointer
=	O
".mc/bashrc"	pointer
;	O
if	O
(	O
access	function
(	O
init_file	pointer
,	O
R_OK	int
)	O
==	O
-	O
1	int
)	O
init_file	pointer
=	O
".bashrc"	pointer
;	O
putenv	function
(	O
"HISTCONTROL=ignorespace"	pointer
)	O
;	O
if	O
(	O
access	function
(	O
".mc/inputrc"	pointer
,	O
R_OK	int
)	O
==	O
0	int
)	O
putenv	function
(	O
"INPUTRC=.mc/inputrc"	pointer
)	O
;	O
break	O
;	O
case	O
TCSH	int
:	O
case	O
ZSH	int
:	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
__FILE__	O
": unimplemented subshell type %d\r\n"	pointer
,	O
subshell_type	enum
)	O
;	O
_exit	function
(	O
FORK_FAILURE	int
)	O
;	O
}	O
dup2	function
(	O
subshell_pty_slave	int
,	O
STDIN_FILENO	int
)	O
;	O
dup2	function
(	O
subshell_pty_slave	int
,	O
STDOUT_FILENO	int
)	O
;	O
dup2	function
(	O
subshell_pty_slave	int
,	O
STDERR_FILENO	int
)	O
;	O
close	pointer
(	O
subshell_pipe	array
[	O
READ	int
]	O
)	O
;	O
close	pointer
(	O
subshell_pty_slave	int
)	O
;	O
close	pointer
(	O
subshell_pty	int
)	O
;	O
switch	O
(	O
subshell_type	enum
)	O
{	O
case	O
BASH	int
:	O
execl	function
(	O
shell	pointer
,	O
"bash"	pointer
,	O
"-rcfile"	pointer
,	O
init_file	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
case	O
TCSH	int
:	O
execl	function
(	O
shell	pointer
,	O
"tcsh"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
case	O
ZSH	int
:	O
execl	function
(	O
shell	pointer
,	O
"zsh"	pointer
,	O
"-Z"	pointer
,	O
"-g"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
}	O
_exit	function
(	O
FORK_FAILURE	int
)	O
;	O
}	O
static	O
int	O
check_sid	function
(	O
void	O
)	O
{	O
pid_t	int
my_sid	int
,	O
old_sid	int
;	O
const	O
char	O
*	O
sid_str	array
;	O
int	O
r	pointer
;	O
sid_str	array
=	O
getenv	function
(	O
"MC_SID"	pointer
)	O
;	O
if	O
(	O
!	O
sid_str	array
)	O
return	O
0	int
;	O
old_sid	int
=	O
(	O
pid_t	int
)	O
strtol	function
(	O
sid_str	array
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
old_sid	int
)	O
return	O
0	int
;	O
my_sid	int
=	O
getsid	function
(	O
0	int
)	O
;	O
if	O
(	O
my_sid	int
==	O
-	O
1	int
)	O
return	O
0	int
;	O
if	O
(	O
old_sid	int
!=	O
my_sid	int
)	O
return	O
0	int
;	O
r	pointer
=	O
query_dialog	function
(	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
"GNU Midnight Commander is already\n"	pointer
"running on this terminal.\n"	pointer
"Subshell support will be disabled."	pointer
)	O
,	O
D_ERROR	int
,	O
2	int
,	O
_	O
(	O
"&OK"	pointer
)	O
,	O
_	O
(	O
"&Quit"	pointer
)	O
)	O
;	O
if	O
(	O
r	pointer
!=	O
0	int
)	O
{	O
return	O
2	int
;	O
}	O
return	O
1	int
;	O
}	O
void	O
init_subshell	function
(	O
void	O
)	O
{	O
static	O
char	O
pty_name	pointer
[	O
BUF_SMALL	int
]	O
;	O
char	O
precmd	array
[	O
BUF_SMALL	int
]	O
;	O
switch	O
(	O
check_sid	function
(	O
)	O
)	O
{	O
case	O
1	int
:	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
case	O
2	int
:	O
use_subshell	int
=	O
FALSE	O
;	O
midnight_shutdown	int
=	O
1	int
;	O
return	O
;	O
}	O
init_raw_mode	function
(	O
)	O
;	O
if	O
(	O
subshell_pty	int
==	O
0	int
)	O
{	O
if	O
(	O
strstr	function
(	O
shell	pointer
,	O
"/zsh"	pointer
)	O
||	O
getenv	function
(	O
"ZSH_VERSION"	pointer
)	O
)	O
subshell_type	enum
=	O
ZSH	int
;	O
else	O
if	O
(	O
strstr	function
(	O
shell	pointer
,	O
"/tcsh"	pointer
)	O
)	O
subshell_type	enum
=	O
TCSH	int
;	O
else	O
if	O
(	O
strstr	function
(	O
shell	pointer
,	O
"/bash"	pointer
)	O
||	O
getenv	function
(	O
"BASH"	pointer
)	O
)	O
subshell_type	enum
=	O
BASH	int
;	O
else	O
{	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
subshell_pty	int
=	O
pty_open_master	function
(	O
pty_name	pointer
)	O
;	O
if	O
(	O
subshell_pty	int
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot open master side of pty: %s\r\n"	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
subshell_pty_slave	int
=	O
pty_open_slave	function
(	O
pty_name	pointer
)	O
;	O
if	O
(	O
subshell_pty_slave	int
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot open slave side of pty %s: %s\r\n"	pointer
,	O
pty_name	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
pty_buffer_size	int
=	O
INITIAL_PTY_BUFFER_SIZE	int
;	O
pty_buffer	pointer
=	O
g_malloc	function
(	O
pty_buffer_size	int
)	O
;	O
if	O
(	O
subshell_type	enum
==	O
TCSH	int
)	O
{	O
g_snprintf	function
(	O
tcsh_fifo	array
,	O
sizeof	O
(	O
tcsh_fifo	array
)	O
,	O
"%s/mc.pipe.%d"	pointer
,	O
mc_tmpdir	function
(	O
)	O
,	O
(	O
int	O
)	O
getpid	function
(	O
)	O
)	O
;	O
if	O
(	O
mkfifo	function
(	O
tcsh_fifo	array
,	O
0600	int
)	O
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"mkfifo(%s) failed: %s\r\n"	pointer
,	O
tcsh_fifo	array
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
subshell_pipe	array
[	O
READ	int
]	O
=	O
open	function
(	O
tcsh_fifo	array
,	O
O_RDWR	int
)	O
)	O
==	O
-	O
1	int
||	O
(	O
subshell_pipe	array
[	O
WRITE	int
]	O
=	O
open	function
(	O
tcsh_fifo	array
,	O
O_RDWR	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Cannot open named pipe %s\n"	pointer
)	O
,	O
tcsh_fifo	array
)	O
;	O
perror	function
(	O
__FILE__	O
": open"	pointer
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
pipe	function
(	O
subshell_pipe	array
)	O
)	O
{	O
perror	function
(	O
__FILE__	O
": couldn't create pipe"	pointer
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
}	O
subshell_alive	int
=	O
TRUE	O
;	O
subshell_stopped	int
=	O
FALSE	O
;	O
subshell_pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
subshell_pid	int
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot spawn the subshell process: %s\r\n"	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
subshell_pid	int
==	O
0	int
)	O
{	O
init_subshell_child	function
(	O
pty_name	pointer
)	O
;	O
}	O
switch	O
(	O
subshell_type	enum
)	O
{	O
case	O
BASH	int
:	O
g_snprintf	function
(	O
precmd	array
,	O
sizeof	O
(	O
precmd	array
)	O
,	O
" PROMPT_COMMAND='pwd>&%d;kill -STOP $$'\n"	pointer
,	O
subshell_pipe	array
[	O
WRITE	int
]	O
)	O
;	O
break	O
;	O
case	O
ZSH	int
:	O
g_snprintf	function
(	O
precmd	array
,	O
sizeof	O
(	O
precmd	array
)	O
,	O
" precmd(){ pwd>&%d;kill -STOP $$ }\n"	pointer
,	O
subshell_pipe	array
[	O
WRITE	int
]	O
)	O
;	O
break	O
;	O
case	O
TCSH	int
:	O
g_snprintf	function
(	O
precmd	array
,	O
sizeof	O
(	O
precmd	array
)	O
,	O
"set echo_style=both;"	pointer
"alias precmd 'echo $cwd:q >>%s;kill -STOP $$'\n"	pointer
,	O
tcsh_fifo	array
)	O
;	O
break	O
;	O
}	O
write_all	function
(	O
subshell_pty	int
,	O
precmd	array
,	O
strlen	function
(	O
precmd	array
)	O
)	O
;	O
subshell_state	enum
=	O
RUNNING_COMMAND	int
;	O
enable_interrupt_key	O
(	O
)	O
;	O
if	O
(	O
!	O
feed_subshell	function
(	O
QUIETLY	int
,	O
TRUE	O
)	O
)	O
{	O
use_subshell	int
=	O
FALSE	O
;	O
}	O
disable_interrupt_key	O
(	O
)	O
;	O
if	O
(	O
!	O
subshell_alive	int
)	O
use_subshell	int
=	O
FALSE	O
;	O
}	O
static	O
void	O
init_raw_mode	function
(	O
)	O
{	O
static	O
int	O
initialized	int
=	O
0	int
;	O
if	O
(	O
initialized	int
==	O
0	int
)	O
{	O
tcgetattr	function
(	O
STDOUT_FILENO	int
,	O
&	O
raw_mode	struct
)	O
;	O
raw_mode	struct
.	O
c_lflag	short
&=	O
~	O
ICANON	int
;	O
raw_mode	struct
.	O
c_lflag	short
&=	O
~	O
ISIG	int
;	O
raw_mode	struct
.	O
c_lflag	short
&=	O
~	O
ECHO	int
;	O
raw_mode	struct
.	O
c_iflag	short
&=	O
~	O
IXON	int
;	O
raw_mode	struct
.	O
c_iflag	short
&=	O
~	O
ICRNL	int
;	O
raw_mode	struct
.	O
c_oflag	short
&=	O
~	O
OPOST	int
;	O
raw_mode	struct
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
0	int
;	O
raw_mode	struct
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
1	int
;	O
initialized	int
=	O
1	int
;	O
}	O
}	O
int	O
invoke_subshell	function
(	O
const	O
char	O
*	O
command	pointer
,	O
int	O
how	int
,	O
char	O
*	O
*	O
new_dir	pointer
)	O
{	O
tcsetattr	function
(	O
STDOUT_FILENO	int
,	O
TCSANOW	int
,	O
&	O
raw_mode	struct
)	O
;	O
if	O
(	O
new_dir	pointer
)	O
do_subshell_chdir	function
(	O
current_panel	pointer
->	O
cwd	short
,	O
TRUE	O
,	O
1	int
)	O
;	O
if	O
(	O
command	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
subshell_state	enum
==	O
INACTIVE	int
)	O
{	O
subshell_state	enum
=	O
ACTIVE	int
;	O
write_all	function
(	O
subshell_pty	int
,	O
" \b"	pointer
,	O
2	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
how	int
==	O
QUIETLY	int
)	O
write_all	function
(	O
subshell_pty	int
,	O
" "	pointer
,	O
1	int
)	O
;	O
write_all	function
(	O
subshell_pty	int
,	O
command	pointer
,	O
strlen	function
(	O
command	pointer
)	O
)	O
;	O
write_all	function
(	O
subshell_pty	int
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
subshell_state	enum
=	O
RUNNING_COMMAND	int
;	O
subshell_ready	int
=	O
FALSE	O
;	O
}	O
feed_subshell	function
(	O
how	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
new_dir	pointer
&&	O
subshell_alive	int
&&	O
strcmp	function
(	O
subshell_cwd	array
,	O
current_panel	pointer
->	O
cwd	short
)	O
)	O
*	O
new_dir	pointer
=	O
subshell_cwd	array
;	O
while	O
(	O
!	O
subshell_alive	int
&&	O
!	O
quit	int
&&	O
use_subshell	int
)	O
init_subshell	function
(	O
)	O
;	O
prompt_pos	int
=	O
0	int
;	O
return	O
quit	int
;	O
}	O
int	O
read_subshell_prompt	function
(	O
void	O
)	O
{	O
static	O
int	O
prompt_size	int
=	O
INITIAL_PROMPT_SIZE	int
;	O
int	O
bytes	pointer
=	O
0	int
,	O
i	array
,	O
rc	pointer
=	O
0	int
;	O
struct	O
timeval	struct
timeleft	struct
=	O
{	O
0	int
,	O
0	int
}	O
;	O
fd_set	struct
tmp	struct
;	O
FD_ZERO	O
(	O
&	O
tmp	struct
)	O
;	O
FD_SET	O
(	O
subshell_pty	int
,	O
&	O
tmp	struct
)	O
;	O
if	O
(	O
subshell_prompt	pointer
==	O
NULL	O
)	O
{	O
subshell_prompt	pointer
=	O
g_malloc	function
(	O
prompt_size	int
)	O
;	O
*	O
subshell_prompt	pointer
=	O
'\0'	O
;	O
prompt_pos	int
=	O
0	int
;	O
}	O
while	O
(	O
subshell_alive	int
&&	O
(	O
rc	pointer
=	O
select	function
(	O
subshell_pty	int
+	O
1	int
,	O
&	O
tmp	struct
,	O
NULL	O
,	O
NULL	O
,	O
&	O
timeleft	struct
)	O
)	O
)	O
{	O
if	O
(	O
rc	pointer
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"select (FD_SETSIZE, &tmp...): %s\r\n"	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
bytes	pointer
=	O
read	pointer
(	O
subshell_pty	int
,	O
pty_buffer	pointer
,	O
pty_buffer_size	int
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
bytes	pointer
;	O
++	O
i	array
)	O
if	O
(	O
pty_buffer	pointer
[	O
i	array
]	O
==	O
'\n'	O
||	O
pty_buffer	pointer
[	O
i	array
]	O
==	O
'\r'	O
)	O
{	O
prompt_pos	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
pty_buffer	pointer
[	O
i	array
]	O
)	O
continue	O
;	O
subshell_prompt	pointer
[	O
prompt_pos	int
++	O
]	O
=	O
pty_buffer	pointer
[	O
i	array
]	O
;	O
if	O
(	O
prompt_pos	int
==	O
prompt_size	int
)	O
subshell_prompt	pointer
=	O
g_realloc	function
(	O
subshell_prompt	pointer
,	O
prompt_size	int
*=	O
2	int
)	O
;	O
}	O
subshell_prompt	pointer
[	O
prompt_pos	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
rc	pointer
==	O
0	int
&&	O
bytes	pointer
==	O
0	int
)	O
return	O
FALSE	O
;	O
return	O
TRUE	O
;	O
}	O
static	O
int	O
resize_tty	function
(	O
int	O
fd	int
)	O
{	O
struct	O
winsize	struct
tty_size	struct
;	O
tty_size	struct
.	O
ws_row	short
=	O
LINES	O
;	O
tty_size	struct
.	O
ws_col	short
=	O
COLS	O
;	O
tty_size	struct
.	O
ws_xpixel	short
=	O
tty_size	struct
.	O
ws_ypixel	short
=	O
0	int
;	O
return	O
ioctl	function
(	O
fd	int
,	O
TIOCSWINSZ	int
,	O
&	O
tty_size	struct
)	O
;	O
}	O
void	O
resize_subshell	function
(	O
void	O
)	O
{	O
if	O
(	O
use_subshell	int
==	O
0	int
)	O
return	O
;	O
resize_tty	function
(	O
subshell_pty	int
)	O
;	O
}	O
int	O
exit_subshell	function
(	O
void	O
)	O
{	O
int	O
quit	int
=	O
TRUE	O
;	O
if	O
(	O
subshell_state	enum
!=	O
INACTIVE	int
&&	O
subshell_alive	int
)	O
quit	int
=	O
!	O
query_dialog	function
(	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
" The shell is still active. Quit anyway? "	pointer
)	O
,	O
0	int
,	O
2	int
,	O
_	O
(	O
"&Yes"	pointer
)	O
,	O
_	O
(	O
"&No"	pointer
)	O
)	O
;	O
if	O
(	O
quit	int
)	O
{	O
if	O
(	O
subshell_type	enum
==	O
TCSH	int
)	O
{	O
if	O
(	O
unlink	function
(	O
tcsh_fifo	array
)	O
==	O
-	O
1	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot remove named pipe %s: %s\r\n"	pointer
,	O
tcsh_fifo	array
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
}	O
g_free	function
(	O
subshell_prompt	pointer
)	O
;	O
g_free	function
(	O
pty_buffer	pointer
)	O
;	O
subshell_prompt	pointer
=	O
NULL	O
;	O
pty_buffer	pointer
=	O
NULL	O
;	O
}	O
return	O
quit	int
;	O
}	O
static	O
char	O
*	O
subshell_name_quote	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
char	O
*	O
ret	long
,	O
*	O
d	double
;	O
const	O
char	O
quote_cmd_start	array
[	O
]	O
=	O
"\"`printf \"%b\" '"	pointer
;	O
const	O
char	O
quote_cmd_end	array
[	O
]	O
=	O
"'`\""	pointer
;	O
d	double
=	O
ret	long
=	O
g_malloc	function
(	O
1	int
+	O
(	O
5	int
*	O
strlen	function
(	O
s	pointer
)	O
)	O
+	O
(	O
sizeof	O
(	O
quote_cmd_start	array
)	O
-	O
1	int
)	O
+	O
(	O
sizeof	O
(	O
quote_cmd_end	array
)	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
d	double
)	O
return	O
NULL	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'-'	O
)	O
{	O
*	O
d	double
++	O
=	O
'.'	O
;	O
*	O
d	double
++	O
=	O
'/'	O
;	O
}	O
strcpy	function
(	O
d	double
,	O
quote_cmd_start	array
)	O
;	O
d	double
+=	O
sizeof	O
(	O
quote_cmd_start	array
)	O
-	O
1	int
;	O
for	O
(	O
;	O
*	O
s	pointer
;	O
s	pointer
++	O
)	O
{	O
if	O
(	O
isalnum	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
)	O
)	O
{	O
*	O
d	double
++	O
=	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
;	O
}	O
else	O
{	O
sprintf	function
(	O
d	double
,	O
"\\0%03o"	pointer
,	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
)	O
;	O
d	double
+=	O
5	int
;	O
}	O
}	O
strcpy	function
(	O
d	double
,	O
quote_cmd_end	array
)	O
;	O
return	O
ret	long
;	O
}	O
void	O
do_subshell_chdir	function
(	O
const	O
char	O
*	O
directory	enum
,	O
int	O
do_update	int
,	O
int	O
reset_prompt	int
)	O
{	O
if	O
(	O
!	O
(	O
subshell_state	enum
==	O
INACTIVE	int
&&	O
strcmp	function
(	O
subshell_cwd	array
,	O
current_panel	pointer
->	O
cwd	short
)	O
)	O
)	O
{	O
if	O
(	O
do_update	int
)	O
do_update_prompt	function
(	O
)	O
;	O
return	O
;	O
}	O
write_all	function
(	O
subshell_pty	int
,	O
" cd "	pointer
,	O
4	int
)	O
;	O
if	O
(	O
*	O
directory	enum
)	O
{	O
char	O
*	O
temp	pointer
=	O
subshell_name_quote	function
(	O
directory	enum
)	O
;	O
if	O
(	O
temp	pointer
)	O
{	O
write_all	function
(	O
subshell_pty	int
,	O
temp	pointer
,	O
strlen	function
(	O
temp	pointer
)	O
)	O
;	O
g_free	function
(	O
temp	pointer
)	O
;	O
}	O
else	O
{	O
write_all	function
(	O
subshell_pty	int
,	O
"."	pointer
,	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
write_all	function
(	O
subshell_pty	int
,	O
"/"	pointer
,	O
1	int
)	O
;	O
}	O
write_all	function
(	O
subshell_pty	int
,	O
"\n"	pointer
,	O
1	int
)	O
;	O
subshell_state	enum
=	O
RUNNING_COMMAND	int
;	O
feed_subshell	function
(	O
QUIETLY	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
subshell_alive	int
)	O
{	O
int	O
bPathNotEq	int
=	O
strcmp	function
(	O
subshell_cwd	array
,	O
current_panel	pointer
->	O
cwd	short
)	O
;	O
if	O
(	O
bPathNotEq	int
&&	O
subshell_type	enum
==	O
TCSH	int
)	O
{	O
char	O
rp_subshell_cwd	array
[	O
PATH_MAX	int
]	O
;	O
char	O
rp_current_panel_cwd	array
[	O
PATH_MAX	int
]	O
;	O
char	O
*	O
p_subshell_cwd	pointer
=	O
mc_realpath	function
(	O
subshell_cwd	array
,	O
rp_subshell_cwd	array
)	O
;	O
char	O
*	O
p_current_panel_cwd	pointer
=	O
mc_realpath	function
(	O
current_panel	pointer
->	O
cwd	short
,	O
rp_current_panel_cwd	array
)	O
;	O
if	O
(	O
p_subshell_cwd	pointer
==	O
NULL	O
)	O
p_subshell_cwd	pointer
=	O
subshell_cwd	array
;	O
if	O
(	O
p_current_panel_cwd	pointer
==	O
NULL	O
)	O
p_current_panel_cwd	pointer
=	O
current_panel	pointer
->	O
cwd	short
;	O
bPathNotEq	int
=	O
strcmp	function
(	O
p_subshell_cwd	pointer
,	O
p_current_panel_cwd	pointer
)	O
;	O
}	O
if	O
(	O
bPathNotEq	int
&&	O
strcmp	function
(	O
current_panel	pointer
->	O
cwd	short
,	O
"."	pointer
)	O
)	O
{	O
char	O
*	O
cwd	short
=	O
strip_password	function
(	O
g_strdup	function
(	O
current_panel	pointer
->	O
cwd	short
)	O
,	O
1	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Warning: Cannot change to %s.\n"	pointer
)	O
,	O
cwd	short
)	O
;	O
g_free	function
(	O
cwd	short
)	O
;	O
}	O
}	O
if	O
(	O
reset_prompt	int
)	O
prompt_pos	int
=	O
0	int
;	O
update_prompt	int
=	O
FALSE	O
;	O
}	O
void	O
subshell_get_console_attributes	function
(	O
void	O
)	O
{	O
if	O
(	O
tcgetattr	function
(	O
STDOUT_FILENO	int
,	O
&	O
shell_mode	struct
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot get terminal settings: %s\r\n"	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
use_subshell	int
=	O
FALSE	O
;	O
return	O
;	O
}	O
}	O
void	O
sigchld_handler	function
(	O
int	O
sig	int
)	O
{	O
int	O
status	int
;	O
pid_t	int
pid	int
;	O
(	O
void	O
)	O
sig	int
;	O
pid	int
=	O
waitpid	function
(	O
subshell_pid	int
,	O
&	O
status	int
,	O
WUNTRACED	int
|	O
WNOHANG	int
)	O
;	O
if	O
(	O
pid	int
==	O
subshell_pid	int
)	O
{	O
if	O
(	O
WIFSTOPPED	O
(	O
status	int
)	O
)	O
{	O
if	O
(	O
WSTOPSIG	O
(	O
status	int
)	O
==	O
SIGSTOP	int
)	O
{	O
subshell_stopped	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
kill	function
(	O
subshell_pid	int
,	O
SIGCONT	int
)	O
;	O
}	O
}	O
else	O
{	O
subshell_alive	int
=	O
FALSE	O
;	O
delete_select_channel	function
(	O
subshell_pty	int
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
status	int
)	O
&&	O
WEXITSTATUS	O
(	O
status	int
)	O
!=	O
FORK_FAILURE	int
)	O
quit	int
|=	O
SUBSHELL_EXIT	int
;	O
}	O
}	O
pid	int
=	O
waitpid	function
(	O
cons_saver_pid	int
,	O
&	O
status	int
,	O
WUNTRACED	int
|	O
WNOHANG	int
)	O
;	O
if	O
(	O
pid	int
==	O
cons_saver_pid	int
)	O
{	O
if	O
(	O
WIFSTOPPED	O
(	O
status	int
)	O
)	O
kill	function
(	O
pid	int
,	O
SIGCONT	int
)	O
;	O
else	O
{	O
handle_console	function
(	O
CONSOLE_DONE	int
)	O
;	O
console_flag	char
=	O
0	int
;	O
}	O
}	O
}	O
static	O
int	O
feed_subshell	function
(	O
int	O
how	int
,	O
int	O
fail_on_error	int
)	O
{	O
fd_set	struct
read_set	struct
;	O
int	O
maxfdp	int
;	O
int	O
bytes	pointer
;	O
int	O
i	array
;	O
struct	O
timeval	struct
wtime	struct
;	O
struct	O
timeval	struct
*	O
wptr	pointer
;	O
wtime	struct
.	O
tv_sec	long
=	O
10	int
;	O
wtime	struct
.	O
tv_usec	long
=	O
0	int
;	O
wptr	pointer
=	O
fail_on_error	int
?	O
&	O
wtime	struct
:	O
NULL	O
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
!	O
subshell_alive	int
)	O
return	O
FALSE	O
;	O
FD_ZERO	O
(	O
&	O
read_set	struct
)	O
;	O
FD_SET	O
(	O
subshell_pty	int
,	O
&	O
read_set	struct
)	O
;	O
FD_SET	O
(	O
subshell_pipe	array
[	O
READ	int
]	O
,	O
&	O
read_set	struct
)	O
;	O
maxfdp	int
=	O
max	long
(	O
subshell_pty	int
,	O
subshell_pipe	array
[	O
READ	int
]	O
)	O
;	O
if	O
(	O
how	int
==	O
VISIBLY	int
)	O
{	O
FD_SET	O
(	O
STDIN_FILENO	int
,	O
&	O
read_set	struct
)	O
;	O
maxfdp	int
=	O
max	long
(	O
maxfdp	int
,	O
STDIN_FILENO	int
)	O
;	O
}	O
if	O
(	O
select	function
(	O
maxfdp	int
+	O
1	int
,	O
&	O
read_set	struct
,	O
NULL	O
,	O
NULL	O
,	O
wptr	pointer
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
tcsetattr	function
(	O
STDOUT_FILENO	int
,	O
TCSANOW	int
,	O
&	O
shell_mode	struct
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"select (FD_SETSIZE, &read_set...): %s\r\n"	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
FD_ISSET	O
(	O
subshell_pty	int
,	O
&	O
read_set	struct
)	O
)	O
{	O
bytes	pointer
=	O
read	pointer
(	O
subshell_pty	int
,	O
pty_buffer	pointer
,	O
pty_buffer_size	int
)	O
;	O
if	O
(	O
bytes	pointer
==	O
-	O
1	int
&&	O
errno	O
==	O
EIO	int
&&	O
!	O
subshell_alive	int
)	O
return	O
FALSE	O
;	O
if	O
(	O
bytes	pointer
<=	O
0	int
)	O
{	O
tcsetattr	function
(	O
STDOUT_FILENO	int
,	O
TCSANOW	int
,	O
&	O
shell_mode	struct
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"read (subshell_pty...): %s\r\n"	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
how	int
==	O
VISIBLY	int
)	O
write_all	function
(	O
STDOUT_FILENO	int
,	O
pty_buffer	pointer
,	O
bytes	pointer
)	O
;	O
}	O
else	O
if	O
(	O
FD_ISSET	O
(	O
subshell_pipe	array
[	O
READ	int
]	O
,	O
&	O
read_set	struct
)	O
)	O
{	O
bytes	pointer
=	O
read	pointer
(	O
subshell_pipe	array
[	O
READ	int
]	O
,	O
subshell_cwd	array
,	O
MC_MAXPATHLEN	O
+	O
1	int
)	O
;	O
if	O
(	O
bytes	pointer
<=	O
0	int
)	O
{	O
tcsetattr	function
(	O
STDOUT_FILENO	int
,	O
TCSANOW	int
,	O
&	O
shell_mode	struct
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"read (subshell_pipe[READ]...): %s\r\n"	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
subshell_cwd	array
[	O
bytes	pointer
-	O
1	int
]	O
=	O
0	int
;	O
synchronize	function
(	O
)	O
;	O
subshell_ready	int
=	O
TRUE	O
;	O
if	O
(	O
subshell_state	enum
==	O
RUNNING_COMMAND	int
)	O
{	O
subshell_state	enum
=	O
INACTIVE	int
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
FD_ISSET	O
(	O
STDIN_FILENO	int
,	O
&	O
read_set	struct
)	O
)	O
{	O
bytes	pointer
=	O
read	pointer
(	O
STDIN_FILENO	int
,	O
pty_buffer	pointer
,	O
pty_buffer_size	int
)	O
;	O
if	O
(	O
bytes	pointer
<=	O
0	int
)	O
{	O
tcsetattr	function
(	O
STDOUT_FILENO	int
,	O
TCSANOW	int
,	O
&	O
shell_mode	struct
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"read (STDIN_FILENO, pty_buffer...): %s\r\n"	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
bytes	pointer
;	O
++	O
i	array
)	O
if	O
(	O
pty_buffer	pointer
[	O
i	array
]	O
==	O
subshell_switch_key	char
)	O
{	O
write_all	function
(	O
subshell_pty	int
,	O
pty_buffer	pointer
,	O
i	array
)	O
;	O
if	O
(	O
subshell_ready	int
)	O
subshell_state	enum
=	O
INACTIVE	int
;	O
return	O
TRUE	O
;	O
}	O
write_all	function
(	O
subshell_pty	int
,	O
pty_buffer	pointer
,	O
bytes	pointer
)	O
;	O
subshell_ready	int
=	O
FALSE	O
;	O
}	O
else	O
{	O
return	O
FALSE	O
;	O
}	O
}	O
}	O
static	O
void	O
synchronize	function
(	O
void	O
)	O
{	O
sigset_t	struct
sigchld_mask	struct
,	O
old_mask	struct
;	O
sigemptyset	function
(	O
&	O
sigchld_mask	struct
)	O
;	O
sigaddset	function
(	O
&	O
sigchld_mask	struct
,	O
SIGCHLD	int
)	O
;	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
sigchld_mask	struct
,	O
&	O
old_mask	struct
)	O
;	O
sigdelset	function
(	O
&	O
old_mask	struct
,	O
SIGCHLD	int
)	O
;	O
while	O
(	O
subshell_alive	int
&&	O
!	O
subshell_stopped	int
)	O
sigsuspend	function
(	O
&	O
old_mask	struct
)	O
;	O
if	O
(	O
subshell_state	enum
!=	O
ACTIVE	int
)	O
{	O
tcflush	function
(	O
subshell_pty_slave	int
,	O
TCIFLUSH	int
)	O
;	O
}	O
subshell_stopped	int
=	O
FALSE	O
;	O
kill	function
(	O
subshell_pid	int
,	O
SIGCONT	int
)	O
;	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
&	O
old_mask	struct
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
pty_open_master	function
(	O
char	O
*	O
pty_name	pointer
)	O
{	O
char	O
*	O
slave_name	pointer
;	O
int	O
pty_master	int
;	O
pty_master	int
=	O
posix_openpt	function
(	O
O_RDWR	int
)	O
;	O
if	O
(	O
pty_master	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
grantpt	function
(	O
pty_master	int
)	O
==	O
-	O
1	int
||	O
unlockpt	function
(	O
pty_master	int
)	O
==	O
-	O
1	int
||	O
!	O
(	O
slave_name	pointer
=	O
ptsname	function
(	O
pty_master	int
)	O
)	O
)	O
{	O
close	pointer
(	O
pty_master	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strcpy	function
(	O
pty_name	pointer
,	O
slave_name	pointer
)	O
;	O
return	O
pty_master	int
;	O
}	O
static	O
int	O
pty_open_slave	function
(	O
const	O
char	O
*	O
pty_name	pointer
)	O
{	O
int	O
pty_slave	int
=	O
open	function
(	O
pty_name	pointer
,	O
O_RDWR	int
)	O
;	O
if	O
(	O
pty_slave	int
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"open (%s, O_RDWR): %s\r\n"	pointer
,	O
pty_name	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
pty_slave	int
;	O
}	O
