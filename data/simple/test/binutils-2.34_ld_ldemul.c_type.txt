static	O
ld_emulation_xfer_type	struct
*	O
ld_emulation	pointer
;	O
void	O
ldemul_hll	function
(	O
char	O
*	O
name	pointer
)	O
{	O
ld_emulation	pointer
->	O
hll	pointer
(	O
name	pointer
)	O
;	O
}	O
void	O
ldemul_syslib	function
(	O
char	O
*	O
name	pointer
)	O
{	O
ld_emulation	pointer
->	O
syslib	pointer
(	O
name	pointer
)	O
;	O
}	O
void	O
ldemul_after_parse	function
(	O
void	O
)	O
{	O
ld_emulation	pointer
->	O
after_parse	pointer
(	O
)	O
;	O
}	O
void	O
ldemul_before_parse	function
(	O
void	O
)	O
{	O
ld_emulation	pointer
->	O
before_parse	pointer
(	O
)	O
;	O
}	O
void	O
ldemul_after_open	function
(	O
void	O
)	O
{	O
ld_emulation	pointer
->	O
after_open	pointer
(	O
)	O
;	O
}	O
void	O
ldemul_after_check_relocs	function
(	O
void	O
)	O
{	O
ld_emulation	pointer
->	O
after_check_relocs	pointer
(	O
)	O
;	O
}	O
void	O
ldemul_after_allocation	function
(	O
void	O
)	O
{	O
ld_emulation	pointer
->	O
after_allocation	pointer
(	O
)	O
;	O
}	O
void	O
ldemul_before_allocation	function
(	O
void	O
)	O
{	O
ld_emulation	pointer
->	O
before_allocation	pointer
(	O
)	O
;	O
}	O
void	O
ldemul_set_output_arch	function
(	O
void	O
)	O
{	O
ld_emulation	pointer
->	O
set_output_arch	pointer
(	O
)	O
;	O
}	O
void	O
ldemul_finish	function
(	O
void	O
)	O
{	O
ld_emulation	pointer
->	O
finish	pointer
(	O
)	O
;	O
}	O
void	O
ldemul_set_symbols	function
(	O
void	O
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
set_symbols	pointer
)	O
ld_emulation	pointer
->	O
set_symbols	pointer
(	O
)	O
;	O
}	O
void	O
ldemul_create_output_section_statements	function
(	O
void	O
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
create_output_section_statements	pointer
)	O
ld_emulation	pointer
->	O
create_output_section_statements	pointer
(	O
)	O
;	O
}	O
char	O
*	O
ldemul_get_script	function
(	O
int	O
*	O
isfile	pointer
)	O
{	O
return	O
ld_emulation	pointer
->	O
get_script	pointer
(	O
isfile	pointer
)	O
;	O
}	O
bfd_boolean	int
ldemul_open_dynamic_archive	function
(	O
const	O
char	O
*	O
arch	enum
,	O
search_dirs_type	struct
*	O
search	pointer
,	O
lang_input_statement_type	struct
*	O
entry	pointer
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
open_dynamic_archive	pointer
)	O
return	O
(	O
*	O
ld_emulation	pointer
->	O
open_dynamic_archive	pointer
)	O
(	O
arch	enum
,	O
search	pointer
,	O
entry	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
lang_output_section_statement_type	struct
*	O
ldemul_place_orphan	function
(	O
asection	struct
*	O
s	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
int	O
constraint	int
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
place_orphan	pointer
)	O
return	O
(	O
*	O
ld_emulation	pointer
->	O
place_orphan	pointer
)	O
(	O
s	pointer
,	O
name	pointer
,	O
constraint	int
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
ldemul_add_options	function
(	O
int	O
ns	int
,	O
char	O
*	O
*	O
shortopts	pointer
,	O
int	O
nl	int
,	O
struct	O
option	struct
*	O
*	O
longopts	pointer
,	O
int	O
nrl	int
,	O
struct	O
option	struct
*	O
*	O
really_longopts	pointer
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
add_options	pointer
)	O
(	O
*	O
ld_emulation	pointer
->	O
add_options	pointer
)	O
(	O
ns	int
,	O
shortopts	pointer
,	O
nl	int
,	O
longopts	pointer
,	O
nrl	int
,	O
really_longopts	pointer
)	O
;	O
}	O
bfd_boolean	int
ldemul_handle_option	function
(	O
int	O
optc	int
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
handle_option	pointer
)	O
return	O
(	O
*	O
ld_emulation	pointer
->	O
handle_option	pointer
)	O
(	O
optc	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
ldemul_parse_args	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
parse_args	pointer
)	O
return	O
(	O
*	O
ld_emulation	pointer
->	O
parse_args	pointer
)	O
(	O
argc	int
,	O
argv	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
ldemul_unrecognized_file	function
(	O
lang_input_statement_type	struct
*	O
entry	pointer
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
unrecognized_file	pointer
)	O
return	O
(	O
*	O
ld_emulation	pointer
->	O
unrecognized_file	pointer
)	O
(	O
entry	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
ldemul_recognized_file	function
(	O
lang_input_statement_type	struct
*	O
entry	pointer
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
recognized_file	pointer
)	O
return	O
(	O
*	O
ld_emulation	pointer
->	O
recognized_file	pointer
)	O
(	O
entry	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
char	O
*	O
ldemul_choose_target	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
return	O
ld_emulation	pointer
->	O
choose_target	pointer
(	O
argc	int
,	O
argv	pointer
)	O
;	O
}	O
char	O
*	O
ldemul_default_target	function
(	O
int	O
argc	int
ATTRIBUTE_UNUSED	O
,	O
char	O
*	O
*	O
argv	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
char	O
*	O
from_outside	pointer
=	O
getenv	function
(	O
TARGET_ENVIRON	pointer
)	O
;	O
if	O
(	O
from_outside	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
return	O
from_outside	pointer
;	O
return	O
ld_emulation	pointer
->	O
target_name	pointer
;	O
}	O
void	O
after_parse_default	function
(	O
void	O
)	O
{	O
if	O
(	O
entry_symbol	struct
.	O
name	pointer
!=	O
NULL	O
&&	O
(	O
bfd_link_executable	O
(	O
&	O
link_info	struct
)	O
||	O
entry_from_cmdline	int
)	O
)	O
{	O
bfd_boolean	int
is_vma	int
=	O
FALSE	int
;	O
if	O
(	O
entry_from_cmdline	int
)	O
{	O
const	O
char	O
*	O
send	pointer
;	O
bfd_scan_vma	function
(	O
entry_symbol	struct
.	O
name	pointer
,	O
&	O
send	pointer
,	O
0	int
)	O
;	O
is_vma	int
=	O
*	O
send	pointer
==	O
'\0'	O
;	O
}	O
if	O
(	O
!	O
is_vma	int
)	O
ldlang_add_undef	function
(	O
entry_symbol	struct
.	O
name	pointer
,	O
entry_from_cmdline	int
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
maxpagesize	long
==	O
0	int
)	O
config	struct
.	O
maxpagesize	long
=	O
bfd_emul_get_maxpagesize	function
(	O
default_target	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
commonpagesize	long
==	O
0	int
)	O
config	struct
.	O
commonpagesize	long
=	O
bfd_emul_get_commonpagesize	function
(	O
default_target	pointer
,	O
link_info	struct
.	O
relro	int
)	O
;	O
}	O
void	O
after_open_default	function
(	O
void	O
)	O
{	O
link_info	struct
.	O
big_endian	int
=	O
TRUE	int
;	O
if	O
(	O
bfd_big_endian	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
)	O
;	O
else	O
if	O
(	O
bfd_little_endian	function
(	O
link_info	struct
.	O
output_bfd	pointer
)	O
)	O
link_info	struct
.	O
big_endian	int
=	O
FALSE	int
;	O
else	O
{	O
if	O
(	O
command_line	struct
.	O
endian	enum
==	O
ENDIAN_BIG	int
)	O
;	O
else	O
if	O
(	O
command_line	struct
.	O
endian	enum
==	O
ENDIAN_LITTLE	int
)	O
link_info	struct
.	O
big_endian	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
command_line	struct
.	O
endian	enum
==	O
ENDIAN_UNSET	int
)	O
{	O
LANG_FOR_EACH_INPUT_STATEMENT	O
(	O
s	pointer
)	O
if	O
(	O
s	pointer
->	O
the_bfd	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
bfd_little_endian	function
(	O
s	pointer
->	O
the_bfd	pointer
)	O
)	O
link_info	struct
.	O
big_endian	int
=	O
FALSE	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
void	O
after_check_relocs_default	function
(	O
void	O
)	O
{	O
}	O
void	O
after_allocation_default	function
(	O
void	O
)	O
{	O
lang_relax_sections	function
(	O
FALSE	int
)	O
;	O
}	O
void	O
before_allocation_default	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
strip_excluded_output_sections	function
(	O
)	O
;	O
}	O
void	O
finish_default	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
_bfd_fix_excluded_sec_syms	function
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
&	O
link_info	struct
)	O
;	O
}	O
void	O
set_output_arch_default	function
(	O
void	O
)	O
{	O
bfd_set_arch_mach	O
(	O
link_info	struct
.	O
output_bfd	pointer
,	O
ldfile_output_architecture	enum
,	O
ldfile_output_machine	long
)	O
;	O
bfd_emul_set_maxpagesize	function
(	O
output_target	pointer
,	O
config	struct
.	O
maxpagesize	long
)	O
;	O
bfd_emul_set_commonpagesize	function
(	O
output_target	pointer
,	O
config	struct
.	O
commonpagesize	long
)	O
;	O
}	O
void	O
syslib_default	function
(	O
char	O
*	O
ignore	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
info_msg	function
(	O
_	O
(	O
"%pS SYSLIB ignored\n"	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
void	O
hll_default	function
(	O
char	O
*	O
ignore	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
info_msg	function
(	O
_	O
(	O
"%pS HLL ignored\n"	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
ld_emulation_xfer_type	struct
*	O
ld_emulations	array
[	O
]	O
=	O
{	O
EMULATION_LIST	O
}	O
;	O
void	O
ldemul_choose_mode	function
(	O
char	O
*	O
target	pointer
)	O
{	O
ld_emulation_xfer_type	struct
*	O
*	O
eptr	pointer
=	O
ld_emulations	array
;	O
if	O
(	O
target	pointer
[	O
0	int
]	O
==	O
'g'	O
&&	O
target	pointer
[	O
1	int
]	O
==	O
'l'	O
&&	O
target	pointer
[	O
2	int
]	O
==	O
'd'	O
)	O
target	pointer
+=	O
3	int
;	O
for	O
(	O
;	O
*	O
eptr	pointer
;	O
eptr	pointer
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
target	pointer
,	O
(	O
*	O
eptr	pointer
)	O
->	O
emulation_name	pointer
)	O
==	O
0	int
)	O
{	O
ld_emulation	pointer
=	O
*	O
eptr	pointer
;	O
return	O
;	O
}	O
}	O
einfo	pointer
(	O
_	O
(	O
"%P: unrecognised emulation mode: %s\n"	pointer
)	O
,	O
target	pointer
)	O
;	O
einfo	pointer
(	O
_	O
(	O
"Supported emulations: "	pointer
)	O
)	O
;	O
ldemul_list_emulations	function
(	O
stderr	pointer
)	O
;	O
einfo	pointer
(	O
"%F\n"	pointer
)	O
;	O
}	O
void	O
ldemul_list_emulations	function
(	O
FILE	struct
*	O
f	pointer
)	O
{	O
ld_emulation_xfer_type	struct
*	O
*	O
eptr	pointer
=	O
ld_emulations	array
;	O
bfd_boolean	int
first	int
=	O
TRUE	int
;	O
for	O
(	O
;	O
*	O
eptr	pointer
;	O
eptr	pointer
++	O
)	O
{	O
if	O
(	O
first	int
)	O
first	int
=	O
FALSE	int
;	O
else	O
fprintf	function
(	O
f	pointer
,	O
" "	pointer
)	O
;	O
fprintf	function
(	O
f	pointer
,	O
"%s"	pointer
,	O
(	O
*	O
eptr	pointer
)	O
->	O
emulation_name	pointer
)	O
;	O
}	O
}	O
void	O
ldemul_list_emulation_options	function
(	O
FILE	struct
*	O
f	pointer
)	O
{	O
ld_emulation_xfer_type	struct
*	O
*	O
eptr	pointer
;	O
int	O
options_found	int
=	O
0	int
;	O
for	O
(	O
eptr	pointer
=	O
ld_emulations	array
;	O
*	O
eptr	pointer
;	O
eptr	pointer
++	O
)	O
{	O
ld_emulation_xfer_type	struct
*	O
emul	pointer
=	O
*	O
eptr	pointer
;	O
if	O
(	O
emul	pointer
->	O
list_options	pointer
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"%s: \n"	pointer
,	O
emul	pointer
->	O
emulation_name	pointer
)	O
;	O
emul	pointer
->	O
list_options	pointer
(	O
f	pointer
)	O
;	O
options_found	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
options_found	int
)	O
fprintf	function
(	O
f	pointer
,	O
_	O
(	O
"  no emulation specific options.\n"	pointer
)	O
)	O
;	O
}	O
int	O
ldemul_find_potential_libraries	function
(	O
char	O
*	O
name	pointer
,	O
lang_input_statement_type	struct
*	O
entry	pointer
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
find_potential_libraries	pointer
)	O
return	O
ld_emulation	pointer
->	O
find_potential_libraries	pointer
(	O
name	pointer
,	O
entry	pointer
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
bfd_elf_version_expr	struct
*	O
ldemul_new_vers_pattern	function
(	O
struct	O
bfd_elf_version_expr	struct
*	O
entry	pointer
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
new_vers_pattern	pointer
)	O
entry	pointer
=	O
(	O
*	O
ld_emulation	pointer
->	O
new_vers_pattern	pointer
)	O
(	O
entry	pointer
)	O
;	O
return	O
entry	pointer
;	O
}	O
void	O
ldemul_extra_map_file_text	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
FILE	struct
*	O
mapf	pointer
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
extra_map_file_text	pointer
)	O
ld_emulation	pointer
->	O
extra_map_file_text	pointer
(	O
abfd	pointer
,	O
info	pointer
,	O
mapf	pointer
)	O
;	O
}	O
int	O
ldemul_emit_ctf_early	function
(	O
void	O
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
emit_ctf_early	pointer
)	O
return	O
ld_emulation	pointer
->	O
emit_ctf_early	pointer
(	O
)	O
;	O
return	O
1	int
;	O
}	O
void	O
ldemul_examine_strtab_for_ctf	function
(	O
struct	O
ctf_file	O
*	O
ctf_output	pointer
,	O
struct	O
elf_sym_strtab	O
*	O
syms	pointer
,	O
bfd_size_type	long
symcount	int
,	O
struct	O
elf_strtab_hash	O
*	O
symstrtab	pointer
)	O
{	O
if	O
(	O
ld_emulation	pointer
->	O
examine_strtab_for_ctf	pointer
)	O
ld_emulation	pointer
->	O
examine_strtab_for_ctf	pointer
(	O
ctf_output	pointer
,	O
syms	pointer
,	O
symcount	int
,	O
symstrtab	pointer
)	O
;	O
}	O
