extern	O
Sworld	struct
world	struct
;	O
extern	O
Suser	struct
user	struct
;	O
extern	O
struct	O
s_altitude_map	struct
altitude_map	array
[	O
]	O
;	O
extern	O
struct	O
s_desig_map	struct
desig_map	array
[	O
]	O
;	O
extern	O
int	O
(	O
*	O
wrapx	pointer
)	O
(	O
)	O
,	O
(	O
*	O
wrapy	pointer
)	O
(	O
)	O
;	O
void	O
wrap	function
(	O
Pt	struct
*	O
pp	pointer
)	O
{	O
pp	pointer
->	O
x	int
=	O
(	O
*	O
wrapx	pointer
)	O
(	O
pp	pointer
->	O
x	int
,	O
pp	pointer
->	O
y	int
)	O
;	O
pp	pointer
->	O
y	int
=	O
(	O
*	O
wrapy	pointer
)	O
(	O
pp	pointer
->	O
x	int
,	O
pp	pointer
->	O
y	int
)	O
;	O
}	O
int	O
torus_wrapx	function
(	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
if	O
(	O
x	int
>=	O
world	struct
.	O
xmax	int
)	O
{	O
return	O
x	int
%	O
world	struct
.	O
xmax	int
;	O
}	O
while	O
(	O
x	int
<	O
0	int
)	O
{	O
x	int
+=	O
world	struct
.	O
xmax	int
;	O
}	O
return	O
x	int
;	O
}	O
int	O
torus_wrapy	function
(	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
if	O
(	O
y	int
>=	O
world	struct
.	O
ymax	int
)	O
{	O
return	O
y	int
%	O
world	struct
.	O
ymax	int
;	O
}	O
while	O
(	O
y	int
<	O
0	int
)	O
{	O
y	int
+=	O
world	struct
.	O
ymax	int
;	O
}	O
return	O
y	int
;	O
}	O
int	O
latitude	function
(	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
float	O
angle	float
;	O
switch	O
(	O
world	struct
.	O
geo	struct
.	O
topology	int
)	O
{	O
case	O
TORUS	int
:	O
angle	float
=	O
torus_latitude	function
(	O
y	int
)	O
;	O
break	O
;	O
}	O
return	O
angle	float
;	O
}	O
int	O
torus_latitude	function
(	O
int	O
y	int
)	O
{	O
float	O
eq_dist	float
,	O
angle	float
;	O
eq_dist	float
=	O
y	int
-	O
(	O
world	struct
.	O
ymax	int
/	O
2.0	int
)	O
;	O
angle	float
=	O
90.0	int
*	O
(	O
eq_dist	float
/	O
(	O
world	struct
.	O
ymax	int
/	O
2.0	int
)	O
)	O
;	O
return	O
angle	float
;	O
}	O
int	O
map_alt	function
(	O
int	O
altitude	short
)	O
{	O
altitude	short
-=	O
altitude_map	array
[	O
0	int
]	O
.	O
value	int
;	O
return	O
altitude	short
;	O
}	O
int	O
xrel	function
(	O
int	O
x	int
,	O
int	O
y	int
,	O
Pt	struct
cap	struct
)	O
{	O
x	int
=	O
xdist	function
(	O
x	int
,	O
y	int
,	O
cap	struct
.	O
x	int
,	O
cap	struct
.	O
y	int
)	O
;	O
return	O
(	O
x	int
)	O
;	O
}	O
int	O
yrel	function
(	O
x	int
,	O
y	int
,	O
cap	struct
)	O
int	O
x	int
,	O
y	int
;	O
Pt	struct
cap	struct
;	O
{	O
y	int
=	O
ydist	function
(	O
x	int
,	O
y	int
,	O
cap	struct
.	O
x	int
,	O
cap	struct
.	O
y	int
)	O
;	O
return	O
(	O
y	int
)	O
;	O
}	O
int	O
xdist	function
(	O
int	O
x	int
,	O
int	O
y	int
,	O
int	O
x1	int
,	O
int	O
y1	int
)	O
{	O
switch	O
(	O
world	struct
.	O
geo	struct
.	O
topology	int
)	O
{	O
case	O
TORUS	int
:	O
x	int
=	O
x	int
-	O
x1	int
;	O
if	O
(	O
x	int
<=	O
(	O
0	int
-	O
world	struct
.	O
xmax	int
/	O
2	int
)	O
)	O
{	O
x	int
+=	O
world	struct
.	O
xmax	int
;	O
}	O
if	O
(	O
x	int
>	O
world	struct
.	O
xmax	int
/	O
2	int
)	O
{	O
x	int
=	O
x	int
-	O
world	struct
.	O
xmax	int
;	O
}	O
return	O
x	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
x	int
;	O
}	O
int	O
ydist	function
(	O
x	int
,	O
y	int
,	O
x1	int
,	O
y1	int
)	O
int	O
x	int
,	O
y	int
,	O
x1	int
,	O
y1	int
;	O
{	O
switch	O
(	O
world	struct
.	O
geo	struct
.	O
topology	int
)	O
{	O
case	O
TORUS	int
:	O
y	int
=	O
y	int
-	O
y1	int
;	O
if	O
(	O
y	int
<=	O
(	O
0	int
-	O
world	struct
.	O
ymax	int
/	O
2	int
)	O
)	O
{	O
y	int
+=	O
world	struct
.	O
ymax	int
;	O
}	O
if	O
(	O
y	int
>	O
world	struct
.	O
ymax	int
/	O
2	int
)	O
{	O
y	int
=	O
y	int
-	O
world	struct
.	O
ymax	int
;	O
}	O
return	O
y	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
y	int
;	O
}	O
int	O
sect_desire	function
(	O
Snation	struct
*	O
np	pointer
,	O
int	O
x	int
,	O
int	O
y	int
)	O
{	O
int	O
terrain_d	int
,	O
climate_d	int
,	O
altitude_d	int
,	O
total_d	int
;	O
terrain_d	int
=	O
abs	function
(	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
terrain	short
-	O
np	pointer
->	O
race	struct
.	O
pref_terrain	int
)	O
;	O
climate_d	int
=	O
abs	function
(	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
climate	short
-	O
np	pointer
->	O
race	struct
.	O
pref_climate	int
)	O
;	O
altitude_d	int
=	O
abs	function
(	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
altitude	short
-	O
np	pointer
->	O
race	struct
.	O
pref_alt	int
)	O
;	O
total_d	int
=	O
dom_max_int	function
(	O
0	int
,	O
230	int
-	O
(	O
terrain_d	int
*	O
terrain_d	int
)	O
*	O
10	int
)	O
;	O
total_d	int
+=	O
dom_max_int	function
(	O
0	int
,	O
250	int
-	O
(	O
climate_d	int
*	O
climate_d	int
)	O
*	O
10	int
)	O
;	O
total_d	int
+=	O
dom_max_int	function
(	O
0	int
,	O
250	int
-	O
(	O
altitude_d	int
*	O
altitude_d	int
)	O
*	O
20	int
)	O
;	O
if	O
(	O
user	struct
.	O
id	short
==	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
owner	int
)	O
{	O
switch	O
(	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
designation	short
)	O
{	O
case	O
D_FARM	int
:	O
total_d	int
+=	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
soil	short
*	O
9	int
;	O
break	O
;	O
case	O
D_METAL_MINE	int
:	O
total_d	int
+=	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
metal	int
*	O
11	int
;	O
break	O
;	O
case	O
D_JEWEL_MINE	int
:	O
total_d	int
+=	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
jewels	int
*	O
13	int
;	O
break	O
;	O
default	O
:	O
{	O
total_d	int
+=	O
37	int
;	O
total_d	int
+=	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
soil	short
;	O
total_d	int
+=	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
metal	int
;	O
total_d	int
+=	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
jewels	int
;	O
}	O
}	O
}	O
else	O
{	O
total_d	int
+=	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
soil	short
*	O
7	int
;	O
total_d	int
+=	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
metal	int
*	O
9	int
;	O
total_d	int
+=	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
jewels	int
*	O
11	int
;	O
}	O
return	O
total_d	int
;	O
}	O
int	O
are_patrols	function
(	O
Snation	struct
*	O
np	pointer
,	O
Sarmy	struct
*	O
moving_ap	pointer
,	O
Ssector	struct
*	O
sp	int
)	O
{	O
int	O
found	int
=	O
0	int
,	O
done	int
=	O
0	int
,	O
x	int
,	O
y	int
;	O
Sarmy	struct
*	O
ap	pointer
,	O
*	O
get_army	function
(	O
)	O
;	O
struct	O
armyid	struct
*	O
alist	pointer
;	O
if	O
(	O
moving_ap	pointer
&&	O
is_underground	O
(	O
moving_ap	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
for	O
(	O
x	int
=	O
sp	int
->	O
loc	struct
.	O
x	int
-	O
1	int
;	O
(	O
(	O
x	int
<=	O
sp	int
->	O
loc	struct
.	O
x	int
+	O
1	int
)	O
&&	O
(	O
done	int
==	O
0	int
)	O
)	O
;	O
x	int
++	O
)	O
{	O
for	O
(	O
y	int
=	O
sp	int
->	O
loc	struct
.	O
y	int
-	O
1	int
;	O
(	O
(	O
y	int
<=	O
sp	int
->	O
loc	struct
.	O
y	int
+	O
1	int
)	O
&&	O
(	O
done	int
==	O
0	int
)	O
)	O
;	O
y	int
++	O
)	O
{	O
done	int
=	O
0	int
;	O
if	O
(	O
np	pointer
->	O
cn_flag	int
||	O
user	struct
.	O
visible_sectors	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
x	int
,	O
y	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
x	int
,	O
y	int
)	O
]	O
&	O
SEE_ARMIES	int
)	O
{	O
alist	pointer
=	O
world	struct
.	O
map	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
x	int
,	O
y	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
x	int
,	O
y	int
)	O
]	O
.	O
alist	pointer
;	O
while	O
(	O
alist	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
alist	pointer
->	O
owner	int
==	O
sp	int
->	O
owner	int
)	O
{	O
ap	pointer
=	O
get_army	function
(	O
&	O
world	struct
.	O
nations	pointer
[	O
alist	pointer
->	O
owner	int
]	O
,	O
alist	pointer
->	O
id	short
)	O
;	O
if	O
(	O
(	O
ap	pointer
->	O
status	int
==	O
A_PATROL	int
||	O
ap	pointer
->	O
status	int
==	O
A_INTERCEPT	int
)	O
&&	O
(	O
!	O
(	O
moving_ap	pointer
&&	O
is_flight	O
(	O
moving_ap	pointer
)	O
)	O
||	O
is_missiles	O
(	O
ap	pointer
)	O
)	O
&&	O
(	O
moving_ap	pointer
&&	O
(	O
ap	pointer
->	O
owner	int
!=	O
moving_ap	pointer
->	O
owner	int
)	O
)	O
&&	O
(	O
get_diplo_status	function
(	O
user	struct
.	O
diplo_matrix	pointer
,	O
ap	pointer
->	O
owner	int
,	O
moving_ap	pointer
->	O
owner	int
)	O
!=	O
TREATY	int
)	O
)	O
{	O
alist	pointer
=	O
NULL	O
;	O
found	int
=	O
1	int
;	O
done	int
=	O
1	int
;	O
}	O
else	O
{	O
alist	pointer
=	O
alist	pointer
->	O
next	pointer
;	O
}	O
}	O
else	O
{	O
alist	pointer
=	O
alist	pointer
->	O
next	pointer
;	O
}	O
}	O
}	O
}	O
}	O
return	O
found	int
;	O
}	O
int	O
sect_is_patrolled	function
(	O
Ssector	struct
*	O
sp	int
,	O
int	O
flag	int
)	O
{	O
int	O
found	int
=	O
0	int
,	O
done	int
=	O
0	int
,	O
x	int
,	O
y	int
;	O
Sarmy	struct
*	O
ap	pointer
,	O
*	O
get_army	function
(	O
)	O
;	O
struct	O
armyid	struct
*	O
alist	pointer
;	O
for	O
(	O
x	int
=	O
sp	int
->	O
loc	struct
.	O
x	int
-	O
1	int
;	O
(	O
(	O
x	int
<=	O
sp	int
->	O
loc	struct
.	O
x	int
+	O
1	int
)	O
&&	O
(	O
done	int
==	O
0	int
)	O
)	O
;	O
x	int
++	O
)	O
{	O
for	O
(	O
y	int
=	O
sp	int
->	O
loc	struct
.	O
y	int
-	O
1	int
;	O
(	O
(	O
y	int
<=	O
sp	int
->	O
loc	struct
.	O
y	int
+	O
1	int
)	O
&&	O
(	O
done	int
==	O
0	int
)	O
)	O
;	O
y	int
++	O
)	O
{	O
done	int
=	O
0	int
;	O
alist	pointer
=	O
world	struct
.	O
map	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
x	int
,	O
y	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
x	int
,	O
y	int
)	O
]	O
.	O
alist	pointer
;	O
while	O
(	O
alist	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
alist	pointer
->	O
owner	int
==	O
sp	int
->	O
owner	int
)	O
{	O
ap	pointer
=	O
get_army	function
(	O
&	O
world	struct
.	O
nations	pointer
[	O
alist	pointer
->	O
owner	int
]	O
,	O
alist	pointer
->	O
id	short
)	O
;	O
if	O
(	O
(	O
(	O
flag	int
==	O
H_PATROL	int
||	O
flag	int
==	O
H_P_OR_I	int
)	O
&&	O
ap	pointer
->	O
status	int
==	O
A_PATROL	int
)	O
||	O
(	O
(	O
flag	int
==	O
H_INTERCEPT	int
||	O
flag	int
==	O
H_P_OR_I	int
)	O
&&	O
ap	pointer
->	O
status	int
==	O
A_INTERCEPT	int
)	O
)	O
{	O
alist	pointer
=	O
NULL	O
;	O
found	int
=	O
1	int
;	O
done	int
=	O
1	int
;	O
}	O
else	O
{	O
alist	pointer
=	O
alist	pointer
->	O
next	pointer
;	O
}	O
}	O
else	O
{	O
alist	pointer
=	O
alist	pointer
->	O
next	pointer
;	O
}	O
}	O
}	O
}	O
return	O
found	int
;	O
}	O
void	O
init_wrap	function
(	O
)	O
{	O
int	O
torus_wrapx	function
(	O
)	O
,	O
torus_wrapy	function
(	O
)	O
;	O
switch	O
(	O
world	struct
.	O
geo	struct
.	O
topology	int
)	O
{	O
case	O
TORUS	int
:	O
wrapx	pointer
=	O
torus_wrapx	function
;	O
wrapy	pointer
=	O
torus_wrapy	function
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"What world is this???\n"	pointer
)	O
;	O
wrapx	pointer
=	O
torus_wrapx	function
;	O
wrapy	pointer
=	O
torus_wrapy	function
;	O
break	O
;	O
}	O
}	O
int	O
is_coastal_sect	function
(	O
Snation	struct
*	O
np	pointer
,	O
Ssector	struct
*	O
sp	int
,	O
Sarmy	struct
*	O
ap	pointer
)	O
{	O
int	O
land	int
,	O
i	int
,	O
j	int
,	O
x	int
,	O
y	int
;	O
if	O
(	O
is_land	O
(	O
ap	pointer
)	O
&&	O
is_water	O
(	O
ap	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
is_land	O
(	O
ap	pointer
)	O
)	O
{	O
land	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
is_water	O
(	O
ap	pointer
)	O
)	O
{	O
land	int
=	O
0	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
land	int
&&	O
sp	int
->	O
altitude	short
<	O
SEA_LEVEL	int
)	O
{	O
for	O
(	O
i	int
=	O
sp	int
->	O
loc	struct
.	O
x	int
-	O
1	int
;	O
i	int
<=	O
sp	int
->	O
loc	struct
.	O
x	int
+	O
1	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
sp	int
->	O
loc	struct
.	O
y	int
-	O
1	int
;	O
j	int
<=	O
sp	int
->	O
loc	struct
.	O
y	int
+	O
1	int
;	O
++	O
j	int
)	O
{	O
x	int
=	O
wrapx	pointer
(	O
i	int
,	O
j	int
)	O
;	O
y	int
=	O
wrapy	pointer
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
altitude	short
>=	O
SEA_LEVEL	int
)	O
{	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
land	int
&&	O
sp	int
->	O
altitude	short
>=	O
SEA_LEVEL	int
)	O
{	O
for	O
(	O
i	int
=	O
sp	int
->	O
loc	struct
.	O
x	int
-	O
1	int
;	O
i	int
<=	O
sp	int
->	O
loc	struct
.	O
x	int
+	O
1	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
sp	int
->	O
loc	struct
.	O
y	int
-	O
1	int
;	O
j	int
<=	O
sp	int
->	O
loc	struct
.	O
y	int
+	O
1	int
;	O
++	O
j	int
)	O
{	O
x	int
=	O
wrapx	pointer
(	O
i	int
,	O
j	int
)	O
;	O
y	int
=	O
wrapy	pointer
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
.	O
altitude	short
<	O
SEA_LEVEL	int
)	O
{	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
is_active_ntn	function
(	O
Snation	struct
*	O
np	pointer
)	O
{	O
if	O
(	O
np	pointer
->	O
id	short
==	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
!	O
(	O
np	pointer
->	O
capital	struct
.	O
x	int
==	O
-	O
1	int
&&	O
np	pointer
->	O
capital	struct
.	O
y	int
==	O
-	O
1	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
