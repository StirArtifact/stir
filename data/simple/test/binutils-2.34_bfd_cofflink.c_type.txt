static	O
bfd_boolean	int
coff_link_add_object_symbols	function
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
)	O
;	O
static	O
bfd_boolean	int
coff_link_check_archive_element	function
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
,	O
struct	O
bfd_link_hash_entry	struct
*	O
,	O
const	O
char	O
*	O
,	O
bfd_boolean	int
*	O
)	O
;	O
static	O
bfd_boolean	int
coff_link_add_symbols	function
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
)	O
;	O
struct	O
bfd_hash_entry	struct
*	O
_bfd_coff_link_hash_newfunc	function
(	O
struct	O
bfd_hash_entry	struct
*	O
entry	pointer
,	O
struct	O
bfd_hash_table	struct
*	O
table	pointer
,	O
const	O
char	O
*	O
string	pointer
)	O
{	O
struct	O
coff_link_hash_entry	struct
*	O
ret	pointer
=	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
entry	pointer
;	O
if	O
(	O
ret	pointer
==	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
NULL	O
)	O
ret	pointer
=	O
(	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
bfd_hash_allocate	function
(	O
table	pointer
,	O
sizeof	O
(	O
struct	O
coff_link_hash_entry	struct
)	O
)	O
)	O
;	O
if	O
(	O
ret	pointer
==	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
NULL	O
)	O
return	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
ret	pointer
;	O
ret	pointer
=	O
(	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
_bfd_link_hash_newfunc	function
(	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
ret	pointer
,	O
table	pointer
,	O
string	pointer
)	O
)	O
;	O
if	O
(	O
ret	pointer
!=	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
NULL	O
)	O
{	O
ret	pointer
->	O
indx	long
=	O
-	O
1	int
;	O
ret	pointer
->	O
type	enum
=	O
T_NULL	int
;	O
ret	pointer
->	O
symbol_class	char
=	O
C_NULL	int
;	O
ret	pointer
->	O
numaux	char
=	O
0	int
;	O
ret	pointer
->	O
auxbfd	pointer
=	O
NULL	O
;	O
ret	pointer
->	O
aux	pointer
=	O
NULL	O
;	O
}	O
return	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
ret	pointer
;	O
}	O
bfd_boolean	int
_bfd_coff_link_hash_table_init	function
(	O
struct	O
coff_link_hash_table	struct
*	O
table	pointer
,	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_hash_entry	struct
*	O
(	O
*	O
newfunc	pointer
)	O
(	O
struct	O
bfd_hash_entry	struct
*	O
,	O
struct	O
bfd_hash_table	struct
*	O
,	O
const	O
char	O
*	O
)	O
,	O
unsigned	O
int	O
entsize	int
)	O
{	O
memset	function
(	O
&	O
table	pointer
->	O
stab_info	struct
,	O
0	int
,	O
sizeof	O
(	O
table	pointer
->	O
stab_info	struct
)	O
)	O
;	O
return	O
_bfd_link_hash_table_init	function
(	O
&	O
table	pointer
->	O
root	struct
,	O
abfd	pointer
,	O
newfunc	pointer
,	O
entsize	int
)	O
;	O
}	O
struct	O
bfd_link_hash_table	struct
*	O
_bfd_coff_link_hash_table_create	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
struct	O
coff_link_hash_table	struct
*	O
ret	pointer
;	O
bfd_size_type	long
amt	long
=	O
sizeof	O
(	O
struct	O
coff_link_hash_table	struct
)	O
;	O
ret	pointer
=	O
(	O
struct	O
coff_link_hash_table	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
ret	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
_bfd_coff_link_hash_table_init	function
(	O
ret	pointer
,	O
abfd	pointer
,	O
_bfd_coff_link_hash_newfunc	function
,	O
sizeof	O
(	O
struct	O
coff_link_hash_entry	struct
)	O
)	O
)	O
{	O
free	function
(	O
ret	pointer
)	O
;	O
return	O
(	O
struct	O
bfd_link_hash_table	struct
*	O
)	O
NULL	O
;	O
}	O
return	O
&	O
ret	pointer
->	O
root	struct
;	O
}	O
struct	O
bfd_hash_entry	struct
*	O
_bfd_coff_debug_merge_hash_newfunc	function
(	O
struct	O
bfd_hash_entry	struct
*	O
entry	pointer
,	O
struct	O
bfd_hash_table	struct
*	O
table	pointer
,	O
const	O
char	O
*	O
string	pointer
)	O
{	O
struct	O
coff_debug_merge_hash_entry	struct
*	O
ret	pointer
=	O
(	O
struct	O
coff_debug_merge_hash_entry	struct
*	O
)	O
entry	pointer
;	O
if	O
(	O
ret	pointer
==	O
(	O
struct	O
coff_debug_merge_hash_entry	struct
*	O
)	O
NULL	O
)	O
ret	pointer
=	O
(	O
(	O
struct	O
coff_debug_merge_hash_entry	struct
*	O
)	O
bfd_hash_allocate	function
(	O
table	pointer
,	O
sizeof	O
(	O
struct	O
coff_debug_merge_hash_entry	struct
)	O
)	O
)	O
;	O
if	O
(	O
ret	pointer
==	O
(	O
struct	O
coff_debug_merge_hash_entry	struct
*	O
)	O
NULL	O
)	O
return	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
ret	pointer
;	O
ret	pointer
=	O
(	O
(	O
struct	O
coff_debug_merge_hash_entry	struct
*	O
)	O
bfd_hash_newfunc	function
(	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
ret	pointer
,	O
table	pointer
,	O
string	pointer
)	O
)	O
;	O
if	O
(	O
ret	pointer
!=	O
(	O
struct	O
coff_debug_merge_hash_entry	struct
*	O
)	O
NULL	O
)	O
{	O
ret	pointer
->	O
types	pointer
=	O
NULL	O
;	O
}	O
return	O
(	O
struct	O
bfd_hash_entry	struct
*	O
)	O
ret	pointer
;	O
}	O
bfd_boolean	int
_bfd_coff_link_add_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
switch	O
(	O
bfd_get_format	function
(	O
abfd	pointer
)	O
)	O
{	O
case	O
bfd_object	int
:	O
return	O
coff_link_add_object_symbols	function
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
case	O
bfd_archive	int
:	O
return	O
_bfd_generic_link_add_archive_symbols	function
(	O
abfd	pointer
,	O
info	pointer
,	O
coff_link_check_archive_element	function
)	O
;	O
default	O
:	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
static	O
bfd_boolean	int
coff_link_add_object_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
if	O
(	O
!	O
_bfd_coff_get_external_symbols	function
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
coff_link_add_symbols	function
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
info	pointer
->	O
keep_memory	int
&&	O
!	O
_bfd_coff_free_symbols	function
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
coff_link_check_archive_element	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
struct	O
bfd_link_hash_entry	struct
*	O
h	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
bfd_boolean	int
*	O
pneeded	pointer
)	O
{	O
*	O
pneeded	pointer
=	O
FALSE	int
;	O
if	O
(	O
h	pointer
->	O
type	enum
!=	O
bfd_link_hash_undefined	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
bfd_family_coff	function
(	O
abfd	pointer
)	O
)	O
return	O
TRUE	int
;	O
if	O
(	O
!	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
add_archive_element	pointer
)	O
(	O
info	pointer
,	O
abfd	pointer
,	O
name	pointer
,	O
&	O
abfd	pointer
)	O
)	O
return	O
TRUE	int
;	O
*	O
pneeded	pointer
=	O
TRUE	int
;	O
return	O
bfd_link_add_symbols	O
(	O
abfd	pointer
,	O
info	pointer
)	O
;	O
}	O
static	O
bfd_boolean	int
coff_link_add_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
unsigned	O
int	O
n_tmask	int
=	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
local_n_tmask	int
;	O
unsigned	O
int	O
n_btshft	int
=	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
local_n_btshft	int
;	O
unsigned	O
int	O
n_btmask	int
=	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
local_n_btmask	int
;	O
bfd_boolean	int
keep_syms	int
;	O
bfd_boolean	int
default_copy	int
;	O
bfd_size_type	long
symcount	int
;	O
struct	O
coff_link_hash_entry	struct
*	O
*	O
sym_hash	pointer
;	O
bfd_size_type	long
symesz	long
;	O
bfd_byte	char
*	O
esym	pointer
;	O
bfd_byte	char
*	O
esym_end	pointer
;	O
bfd_size_type	long
amt	long
;	O
symcount	int
=	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
symcount	int
==	O
0	int
)	O
return	O
TRUE	int
;	O
keep_syms	int
=	O
obj_coff_keep_syms	O
(	O
abfd	pointer
)	O
;	O
obj_coff_keep_syms	O
(	O
abfd	pointer
)	O
=	O
TRUE	int
;	O
if	O
(	O
info	pointer
->	O
keep_memory	int
)	O
default_copy	int
=	O
FALSE	int
;	O
else	O
default_copy	int
=	O
TRUE	int
;	O
amt	long
=	O
symcount	int
*	O
sizeof	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
;	O
sym_hash	pointer
=	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
*	O
)	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
sym_hash	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
obj_coff_sym_hashes	O
(	O
abfd	pointer
)	O
=	O
sym_hash	pointer
;	O
symesz	long
=	O
bfd_coff_symesz	O
(	O
abfd	pointer
)	O
;	O
BFD_ASSERT	O
(	O
symesz	long
==	O
bfd_coff_auxesz	O
(	O
abfd	pointer
)	O
)	O
;	O
esym	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
obj_coff_external_syms	O
(	O
abfd	pointer
)	O
;	O
esym_end	pointer
=	O
esym	pointer
+	O
symcount	int
*	O
symesz	long
;	O
while	O
(	O
esym	pointer
<	O
esym_end	pointer
)	O
{	O
struct	O
internal_syment	struct
sym	pointer
;	O
enum	O
coff_symbol_classification	enum
classification	enum
;	O
bfd_boolean	int
copy	int
;	O
bfd_coff_swap_sym_in	O
(	O
abfd	pointer
,	O
esym	pointer
,	O
&	O
sym	pointer
)	O
;	O
classification	enum
=	O
bfd_coff_classify_symbol	O
(	O
abfd	pointer
,	O
&	O
sym	pointer
)	O
;	O
if	O
(	O
classification	enum
!=	O
COFF_SYMBOL_LOCAL	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
char	O
buf	pointer
[	O
SYMNMLEN	int
+	O
1	int
]	O
;	O
flagword	int
flags	int
;	O
asection	struct
*	O
section	pointer
;	O
bfd_vma	long
value	long
;	O
bfd_boolean	int
addit	int
;	O
name	pointer
=	O
_bfd_coff_internal_syment_name	function
(	O
abfd	pointer
,	O
&	O
sym	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
copy	int
=	O
default_copy	int
;	O
if	O
(	O
sym	pointer
.	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
!=	O
0	int
||	O
sym	pointer
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
==	O
0	int
)	O
copy	int
=	O
TRUE	int
;	O
value	long
=	O
sym	pointer
.	O
n_value	long
;	O
switch	O
(	O
classification	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
COFF_SYMBOL_GLOBAL	int
:	O
flags	int
=	O
BSF_EXPORT	O
|	O
BSF_GLOBAL	O
;	O
section	pointer
=	O
coff_section_from_bfd_index	function
(	O
abfd	pointer
,	O
sym	pointer
.	O
n_scnum	int
)	O
;	O
if	O
(	O
discarded_section	function
(	O
section	pointer
)	O
)	O
section	pointer
=	O
bfd_und_section_ptr	O
;	O
else	O
if	O
(	O
!	O
obj_pe	O
(	O
abfd	pointer
)	O
)	O
value	long
-=	O
section	pointer
->	O
vma	long
;	O
break	O
;	O
case	O
COFF_SYMBOL_UNDEFINED	int
:	O
flags	int
=	O
0	int
;	O
section	pointer
=	O
bfd_und_section_ptr	O
;	O
break	O
;	O
case	O
COFF_SYMBOL_COMMON	int
:	O
flags	int
=	O
BSF_GLOBAL	O
;	O
section	pointer
=	O
bfd_com_section_ptr	O
;	O
break	O
;	O
case	O
COFF_SYMBOL_PE_SECTION	int
:	O
flags	int
=	O
BSF_SECTION_SYM	O
|	O
BSF_GLOBAL	O
;	O
section	pointer
=	O
coff_section_from_bfd_index	function
(	O
abfd	pointer
,	O
sym	pointer
.	O
n_scnum	int
)	O
;	O
if	O
(	O
discarded_section	function
(	O
section	pointer
)	O
)	O
section	pointer
=	O
bfd_und_section_ptr	O
;	O
break	O
;	O
}	O
if	O
(	O
IS_WEAK_EXTERNAL	O
(	O
abfd	pointer
,	O
sym	pointer
)	O
)	O
flags	int
=	O
BSF_WEAK	O
;	O
addit	int
=	O
TRUE	int
;	O
if	O
(	O
obj_pe	O
(	O
abfd	pointer
)	O
&&	O
(	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
!=	O
0	int
)	O
{	O
*	O
sym_hash	pointer
=	O
coff_link_hash_lookup	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
name	pointer
,	O
FALSE	int
,	O
copy	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
*	O
sym_hash	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
(	O
*	O
sym_hash	pointer
)	O
->	O
coff_link_hash_flags	short
&	O
COFF_LINK_HASH_PE_SECTION_SYMBOL	O
)	O
==	O
0	int
&&	O
(	O
*	O
sym_hash	pointer
)	O
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefined	int
&&	O
(	O
*	O
sym_hash	pointer
)	O
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_undefweak	int
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: symbol `%s' is both section and non-section"	pointer
)	O
,	O
name	pointer
)	O
;	O
addit	int
=	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
obj_pe	O
(	O
abfd	pointer
)	O
&&	O
(	O
classification	enum
==	O
COFF_SYMBOL_GLOBAL	int
||	O
classification	enum
==	O
COFF_SYMBOL_PE_SECTION	int
)	O
&&	O
coff_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
!=	O
NULL	O
&&	O
coff_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
->	O
comdat	pointer
!=	O
NULL	O
&&	O
CONST_STRNEQ	O
(	O
name	pointer
,	O
"??_"	pointer
)	O
&&	O
strcmp	function
(	O
name	pointer
,	O
coff_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
->	O
comdat	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
*	O
sym_hash	pointer
==	O
NULL	O
)	O
*	O
sym_hash	pointer
=	O
coff_link_hash_lookup	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
name	pointer
,	O
FALSE	int
,	O
copy	int
,	O
FALSE	int
)	O
;	O
if	O
(	O
*	O
sym_hash	pointer
!=	O
NULL	O
&&	O
(	O
*	O
sym_hash	pointer
)	O
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
&&	O
coff_section_data	O
(	O
abfd	pointer
,	O
(	O
*	O
sym_hash	pointer
)	O
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
->	O
comdat	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
coff_section_data	O
(	O
abfd	pointer
,	O
(	O
*	O
sym_hash	pointer
)	O
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
)	O
->	O
comdat	pointer
->	O
name	pointer
,	O
coff_section_data	O
(	O
abfd	pointer
,	O
section	pointer
)	O
->	O
comdat	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
addit	int
=	O
FALSE	int
;	O
}	O
if	O
(	O
addit	int
)	O
{	O
if	O
(	O
!	O
(	O
bfd_coff_link_add_one_symbol	O
(	O
info	pointer
,	O
abfd	pointer
,	O
name	pointer
,	O
flags	int
,	O
section	pointer
,	O
value	long
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
copy	int
,	O
FALSE	int
,	O
(	O
struct	O
bfd_link_hash_entry	struct
*	O
*	O
)	O
sym_hash	pointer
)	O
)	O
)	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
obj_pe	O
(	O
abfd	pointer
)	O
&&	O
(	O
flags	int
&	O
BSF_SECTION_SYM	O
)	O
!=	O
0	int
)	O
(	O
*	O
sym_hash	pointer
)	O
->	O
coff_link_hash_flags	short
|=	O
COFF_LINK_HASH_PE_SECTION_SYMBOL	O
;	O
if	O
(	O
section	pointer
==	O
bfd_com_section_ptr	O
&&	O
(	O
*	O
sym_hash	pointer
)	O
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_common	int
&&	O
(	O
(	O
*	O
sym_hash	pointer
)	O
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
>	O
bfd_coff_default_section_alignment_power	O
(	O
abfd	pointer
)	O
)	O
)	O
(	O
*	O
sym_hash	pointer
)	O
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
p	pointer
->	O
alignment_power	int
=	O
bfd_coff_default_section_alignment_power	O
(	O
abfd	pointer
)	O
;	O
if	O
(	O
bfd_get_flavour	function
(	O
info	pointer
->	O
output_bfd	pointer
)	O
==	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
)	O
{	O
if	O
(	O
(	O
(	O
*	O
sym_hash	pointer
)	O
->	O
symbol_class	char
==	O
C_NULL	int
&&	O
(	O
*	O
sym_hash	pointer
)	O
->	O
type	enum
==	O
T_NULL	int
)	O
||	O
sym	pointer
.	O
n_scnum	int
!=	O
0	int
||	O
(	O
sym	pointer
.	O
n_value	long
!=	O
0	int
&&	O
(	O
*	O
sym_hash	pointer
)	O
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defined	int
&&	O
(	O
*	O
sym_hash	pointer
)	O
->	O
root	struct
.	O
type	enum
!=	O
bfd_link_hash_defweak	int
)	O
)	O
{	O
(	O
*	O
sym_hash	pointer
)	O
->	O
symbol_class	char
=	O
sym	pointer
.	O
n_sclass	char
;	O
if	O
(	O
sym	pointer
.	O
n_type	short
!=	O
T_NULL	int
)	O
{	O
if	O
(	O
(	O
*	O
sym_hash	pointer
)	O
->	O
type	enum
!=	O
T_NULL	int
&&	O
(	O
*	O
sym_hash	pointer
)	O
->	O
type	enum
!=	O
sym	pointer
.	O
n_type	short
&&	O
!	O
(	O
DTYPE	O
(	O
(	O
*	O
sym_hash	pointer
)	O
->	O
type	enum
)	O
==	O
DTYPE	O
(	O
sym	pointer
.	O
n_type	short
)	O
&&	O
(	O
BTYPE	O
(	O
(	O
*	O
sym_hash	pointer
)	O
->	O
type	enum
)	O
==	O
T_NULL	int
||	O
BTYPE	O
(	O
sym	pointer
.	O
n_type	short
)	O
==	O
T_NULL	int
)	O
)	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"warning: type of symbol `%s' changed"	pointer
" from %d to %d in %pB"	pointer
)	O
,	O
name	pointer
,	O
(	O
*	O
sym_hash	pointer
)	O
->	O
type	enum
,	O
sym	pointer
.	O
n_type	short
,	O
abfd	pointer
)	O
;	O
if	O
(	O
BTYPE	O
(	O
sym	pointer
.	O
n_type	short
)	O
!=	O
T_NULL	int
||	O
(	O
*	O
sym_hash	pointer
)	O
->	O
type	enum
==	O
T_NULL	int
)	O
(	O
*	O
sym_hash	pointer
)	O
->	O
type	enum
=	O
sym	pointer
.	O
n_type	short
;	O
}	O
(	O
*	O
sym_hash	pointer
)	O
->	O
auxbfd	pointer
=	O
abfd	pointer
;	O
if	O
(	O
sym	pointer
.	O
n_numaux	char
!=	O
0	int
)	O
{	O
union	O
internal_auxent	union
*	O
alloc	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
bfd_byte	char
*	O
eaux	pointer
;	O
union	O
internal_auxent	union
*	O
iaux	pointer
;	O
(	O
*	O
sym_hash	pointer
)	O
->	O
numaux	char
=	O
sym	pointer
.	O
n_numaux	char
;	O
alloc	pointer
=	O
(	O
(	O
union	O
internal_auxent	union
*	O
)	O
bfd_hash_allocate	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
(	O
sym	pointer
.	O
n_numaux	char
*	O
sizeof	O
(	O
*	O
alloc	pointer
)	O
)	O
)	O
)	O
;	O
if	O
(	O
alloc	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
for	O
(	O
i	pointer
=	O
0	int
,	O
eaux	pointer
=	O
esym	pointer
+	O
symesz	long
,	O
iaux	pointer
=	O
alloc	pointer
;	O
i	pointer
<	O
sym	pointer
.	O
n_numaux	char
;	O
i	pointer
++	O
,	O
eaux	pointer
+=	O
symesz	long
,	O
iaux	pointer
++	O
)	O
bfd_coff_swap_aux_in	O
(	O
abfd	pointer
,	O
eaux	pointer
,	O
sym	pointer
.	O
n_type	short
,	O
sym	pointer
.	O
n_sclass	char
,	O
(	O
int	O
)	O
i	pointer
,	O
sym	pointer
.	O
n_numaux	char
,	O
iaux	pointer
)	O
;	O
(	O
*	O
sym_hash	pointer
)	O
->	O
aux	pointer
=	O
alloc	pointer
;	O
}	O
}	O
}	O
if	O
(	O
classification	enum
==	O
COFF_SYMBOL_PE_SECTION	int
&&	O
(	O
*	O
sym_hash	pointer
)	O
->	O
numaux	char
!=	O
0	int
)	O
{	O
BFD_ASSERT	O
(	O
(	O
*	O
sym_hash	pointer
)	O
->	O
numaux	char
==	O
1	int
)	O
;	O
if	O
(	O
section	pointer
->	O
size	long
==	O
0	int
)	O
section	pointer
->	O
size	long
=	O
(	O
*	O
sym_hash	pointer
)	O
->	O
aux	pointer
[	O
0	int
]	O
.	O
x_scn	struct
.	O
x_scnlen	long
;	O
}	O
}	O
esym	pointer
+=	O
(	O
sym	pointer
.	O
n_numaux	char
+	O
1	int
)	O
*	O
symesz	long
;	O
sym_hash	pointer
+=	O
sym	pointer
.	O
n_numaux	char
+	O
1	int
;	O
}	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
!	O
info	pointer
->	O
traditional_format	int
&&	O
bfd_get_flavour	function
(	O
info	pointer
->	O
output_bfd	pointer
)	O
==	O
bfd_get_flavour	function
(	O
abfd	pointer
)	O
&&	O
(	O
info	pointer
->	O
strip	enum
!=	O
strip_all	int
&&	O
info	pointer
->	O
strip	enum
!=	O
strip_debugger	int
)	O
)	O
{	O
asection	struct
*	O
stabstr	pointer
;	O
stabstr	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".stabstr"	pointer
)	O
;	O
if	O
(	O
stabstr	pointer
!=	O
NULL	O
)	O
{	O
bfd_size_type	long
string_offset	long
=	O
0	int
;	O
asection	struct
*	O
stab	pointer
;	O
for	O
(	O
stab	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
stab	pointer
;	O
stab	pointer
=	O
stab	pointer
->	O
next	pointer
)	O
if	O
(	O
CONST_STRNEQ	O
(	O
stab	pointer
->	O
name	pointer
,	O
".stab"	pointer
)	O
&&	O
(	O
!	O
stab	pointer
->	O
name	pointer
[	O
5	int
]	O
||	O
(	O
stab	pointer
->	O
name	pointer
[	O
5	int
]	O
==	O
'.'	O
&&	O
ISDIGIT	O
(	O
stab	pointer
->	O
name	pointer
[	O
6	int
]	O
)	O
)	O
)	O
)	O
{	O
struct	O
coff_link_hash_table	struct
*	O
table	pointer
;	O
struct	O
coff_section_tdata	struct
*	O
secdata	pointer
=	O
coff_section_data	O
(	O
abfd	pointer
,	O
stab	pointer
)	O
;	O
if	O
(	O
secdata	pointer
==	O
NULL	O
)	O
{	O
amt	long
=	O
sizeof	O
(	O
struct	O
coff_section_tdata	struct
)	O
;	O
stab	pointer
->	O
used_by_bfd	pointer
=	O
bfd_zalloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
stab	pointer
->	O
used_by_bfd	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
secdata	pointer
=	O
coff_section_data	O
(	O
abfd	pointer
,	O
stab	pointer
)	O
;	O
}	O
table	pointer
=	O
coff_hash_table	O
(	O
info	pointer
)	O
;	O
if	O
(	O
!	O
_bfd_link_section_stabs	function
(	O
abfd	pointer
,	O
&	O
table	pointer
->	O
stab_info	struct
,	O
stab	pointer
,	O
stabstr	pointer
,	O
&	O
secdata	pointer
->	O
stab_info	struct
,	O
&	O
string_offset	long
)	O
)	O
goto	O
error_return	O
;	O
}	O
}	O
}	O
obj_coff_keep_syms	O
(	O
abfd	pointer
)	O
=	O
keep_syms	int
;	O
return	O
TRUE	int
;	O
error_return	O
:	O
obj_coff_keep_syms	O
(	O
abfd	pointer
)	O
=	O
keep_syms	int
;	O
return	O
FALSE	int
;	O
}	O
bfd_boolean	int
_bfd_coff_final_link	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
)	O
{	O
bfd_size_type	long
symesz	long
;	O
struct	O
coff_final_link_info	struct
flaginfo	struct
;	O
bfd_boolean	int
debug_merge_allocated	int
;	O
bfd_boolean	int
long_section_names	int
;	O
asection	struct
*	O
o	pointer
;	O
struct	O
bfd_link_order	struct
*	O
p	pointer
;	O
bfd_size_type	long
max_sym_count	long
;	O
bfd_size_type	long
max_lineno_count	long
;	O
bfd_size_type	long
max_reloc_count	long
;	O
bfd_size_type	long
max_output_reloc_count	long
;	O
bfd_size_type	long
max_contents_size	long
;	O
file_ptr	long
rel_filepos	long
;	O
unsigned	O
int	O
relsz	int
;	O
file_ptr	long
line_filepos	long
;	O
unsigned	O
int	O
linesz	int
;	O
bfd	struct
*	O
sub	pointer
;	O
bfd_byte	char
*	O
external_relocs	pointer
=	O
NULL	O
;	O
char	O
strbuf	array
[	O
STRING_SIZE_SIZE	int
]	O
;	O
bfd_size_type	long
amt	long
;	O
symesz	long
=	O
bfd_coff_symesz	O
(	O
abfd	pointer
)	O
;	O
flaginfo	struct
.	O
info	pointer
=	O
info	pointer
;	O
flaginfo	struct
.	O
output_bfd	pointer
=	O
abfd	pointer
;	O
flaginfo	struct
.	O
strtab	pointer
=	O
NULL	O
;	O
flaginfo	struct
.	O
section_info	pointer
=	O
NULL	O
;	O
flaginfo	struct
.	O
last_file_index	long
=	O
-	O
1	int
;	O
flaginfo	struct
.	O
last_bf_index	long
=	O
-	O
1	int
;	O
flaginfo	struct
.	O
internal_syms	pointer
=	O
NULL	O
;	O
flaginfo	struct
.	O
sec_ptrs	pointer
=	O
NULL	O
;	O
flaginfo	struct
.	O
sym_indices	pointer
=	O
NULL	O
;	O
flaginfo	struct
.	O
outsyms	pointer
=	O
NULL	O
;	O
flaginfo	struct
.	O
linenos	pointer
=	O
NULL	O
;	O
flaginfo	struct
.	O
contents	pointer
=	O
NULL	O
;	O
flaginfo	struct
.	O
external_relocs	pointer
=	O
NULL	O
;	O
flaginfo	struct
.	O
internal_relocs	pointer
=	O
NULL	O
;	O
flaginfo	struct
.	O
global_to_static	int
=	O
FALSE	int
;	O
debug_merge_allocated	int
=	O
FALSE	int
;	O
coff_data	O
(	O
abfd	pointer
)	O
->	O
link_info	pointer
=	O
info	pointer
;	O
flaginfo	struct
.	O
strtab	pointer
=	O
_bfd_stringtab_init	function
(	O
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
strtab	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
!	O
coff_debug_merge_hash_table_init	O
(	O
&	O
flaginfo	struct
.	O
debug_merge	struct
)	O
)	O
goto	O
error_return	O
;	O
debug_merge_allocated	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
abfd	pointer
->	O
output_has_begun	int
)	O
{	O
if	O
(	O
!	O
bfd_coff_compute_section_file_positions	O
(	O
abfd	pointer
)	O
)	O
goto	O
error_return	O
;	O
}	O
rel_filepos	long
=	O
obj_relocbase	O
(	O
abfd	pointer
)	O
;	O
relsz	int
=	O
bfd_coff_relsz	O
(	O
abfd	pointer
)	O
;	O
max_contents_size	long
=	O
0	int
;	O
max_lineno_count	long
=	O
0	int
;	O
max_reloc_count	long
=	O
0	int
;	O
long_section_names	int
=	O
FALSE	int
;	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
o	pointer
->	O
reloc_count	int
=	O
0	int
;	O
o	pointer
->	O
lineno_count	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
o	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_indirect_link_order	int
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
sec	pointer
=	O
p	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
;	O
sec	pointer
->	O
linker_mark	int
=	O
TRUE	int
;	O
if	O
(	O
info	pointer
->	O
strip	enum
==	O
strip_none	int
||	O
info	pointer
->	O
strip	enum
==	O
strip_some	int
)	O
o	pointer
->	O
lineno_count	int
+=	O
sec	pointer
->	O
lineno_count	int
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
o	pointer
->	O
reloc_count	int
+=	O
sec	pointer
->	O
reloc_count	int
;	O
if	O
(	O
sec	pointer
->	O
rawsize	long
>	O
max_contents_size	long
)	O
max_contents_size	long
=	O
sec	pointer
->	O
rawsize	long
;	O
if	O
(	O
sec	pointer
->	O
size	long
>	O
max_contents_size	long
)	O
max_contents_size	long
=	O
sec	pointer
->	O
size	long
;	O
if	O
(	O
sec	pointer
->	O
lineno_count	int
>	O
max_lineno_count	long
)	O
max_lineno_count	long
=	O
sec	pointer
->	O
lineno_count	int
;	O
if	O
(	O
sec	pointer
->	O
reloc_count	int
>	O
max_reloc_count	long
)	O
max_reloc_count	long
=	O
sec	pointer
->	O
reloc_count	int
;	O
}	O
else	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
||	O
p	pointer
->	O
type	enum
==	O
bfd_symbol_reloc_link_order	int
)	O
)	O
++	O
o	pointer
->	O
reloc_count	int
;	O
}	O
if	O
(	O
o	pointer
->	O
reloc_count	int
==	O
0	int
)	O
o	pointer
->	O
rel_filepos	long
=	O
0	int
;	O
else	O
{	O
o	pointer
->	O
flags	int
|=	O
SEC_RELOC	int
;	O
o	pointer
->	O
rel_filepos	long
=	O
rel_filepos	long
;	O
rel_filepos	long
+=	O
o	pointer
->	O
reloc_count	int
*	O
relsz	int
;	O
if	O
(	O
obj_pe	O
(	O
abfd	pointer
)	O
&&	O
o	pointer
->	O
reloc_count	int
>=	O
0xffff	int
)	O
rel_filepos	long
+=	O
relsz	int
;	O
}	O
if	O
(	O
bfd_coff_long_section_names	O
(	O
abfd	pointer
)	O
&&	O
strlen	function
(	O
o	pointer
->	O
name	pointer
)	O
>	O
SCNNMLEN	O
)	O
{	O
if	O
(	O
_bfd_stringtab_add	function
(	O
flaginfo	struct
.	O
strtab	pointer
,	O
o	pointer
->	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
==	O
(	O
bfd_size_type	long
)	O
-	O
1	int
)	O
goto	O
error_return	O
;	O
long_section_names	int
=	O
TRUE	int
;	O
}	O
}	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
amt	long
=	O
abfd	pointer
->	O
section_count	int
+	O
1	int
;	O
amt	long
*=	O
sizeof	O
(	O
struct	O
coff_link_section_info	struct
)	O
;	O
flaginfo	struct
.	O
section_info	pointer
=	O
(	O
struct	O
coff_link_section_info	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
section_info	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<=	O
abfd	pointer
->	O
section_count	int
;	O
i	pointer
++	O
)	O
{	O
flaginfo	struct
.	O
section_info	pointer
[	O
i	pointer
]	O
.	O
relocs	pointer
=	O
NULL	O
;	O
flaginfo	struct
.	O
section_info	pointer
[	O
i	pointer
]	O
.	O
rel_hashes	pointer
=	O
NULL	O
;	O
}	O
}	O
line_filepos	long
=	O
rel_filepos	long
;	O
linesz	int
=	O
bfd_coff_linesz	O
(	O
abfd	pointer
)	O
;	O
max_output_reloc_count	long
=	O
0	int
;	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
o	pointer
->	O
lineno_count	int
==	O
0	int
)	O
o	pointer
->	O
line_filepos	long
=	O
0	int
;	O
else	O
{	O
o	pointer
->	O
line_filepos	long
=	O
line_filepos	long
;	O
line_filepos	long
+=	O
o	pointer
->	O
lineno_count	int
*	O
linesz	int
;	O
}	O
if	O
(	O
o	pointer
->	O
reloc_count	int
!=	O
0	int
)	O
{	O
BFD_ASSERT	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
;	O
amt	long
=	O
o	pointer
->	O
reloc_count	int
;	O
amt	long
*=	O
sizeof	O
(	O
struct	O
internal_reloc	struct
)	O
;	O
flaginfo	struct
.	O
section_info	pointer
[	O
o	pointer
->	O
target_index	int
]	O
.	O
relocs	pointer
=	O
(	O
struct	O
internal_reloc	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
amt	long
=	O
o	pointer
->	O
reloc_count	int
;	O
amt	long
*=	O
sizeof	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
;	O
flaginfo	struct
.	O
section_info	pointer
[	O
o	pointer
->	O
target_index	int
]	O
.	O
rel_hashes	pointer
=	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
section_info	pointer
[	O
o	pointer
->	O
target_index	int
]	O
.	O
relocs	pointer
==	O
NULL	O
||	O
flaginfo	struct
.	O
section_info	pointer
[	O
o	pointer
->	O
target_index	int
]	O
.	O
rel_hashes	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
if	O
(	O
o	pointer
->	O
reloc_count	int
>	O
max_output_reloc_count	long
)	O
max_output_reloc_count	long
=	O
o	pointer
->	O
reloc_count	int
;	O
}	O
o	pointer
->	O
reloc_count	int
=	O
0	int
;	O
o	pointer
->	O
lineno_count	int
=	O
0	int
;	O
}	O
obj_sym_filepos	O
(	O
abfd	pointer
)	O
=	O
line_filepos	long
;	O
max_sym_count	long
=	O
0	int
;	O
for	O
(	O
sub	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
sub	pointer
!=	O
NULL	O
;	O
sub	pointer
=	O
sub	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
size_t	long
sz	long
;	O
sub	pointer
->	O
output_has_begun	int
=	O
FALSE	int
;	O
sz	long
=	O
bfd_family_coff	function
(	O
sub	pointer
)	O
?	O
obj_raw_syment_count	O
(	O
sub	pointer
)	O
:	O
2	int
;	O
if	O
(	O
sz	long
>	O
max_sym_count	long
)	O
max_sym_count	long
=	O
sz	long
;	O
}	O
amt	long
=	O
max_sym_count	long
*	O
sizeof	O
(	O
struct	O
internal_syment	struct
)	O
;	O
flaginfo	struct
.	O
internal_syms	pointer
=	O
(	O
struct	O
internal_syment	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
amt	long
=	O
max_sym_count	long
*	O
sizeof	O
(	O
asection	struct
*	O
)	O
;	O
flaginfo	struct
.	O
sec_ptrs	pointer
=	O
(	O
asection	struct
*	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
amt	long
=	O
max_sym_count	long
*	O
sizeof	O
(	O
long	O
)	O
;	O
flaginfo	struct
.	O
sym_indices	pointer
=	O
(	O
long	O
int	O
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
flaginfo	struct
.	O
outsyms	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
(	O
max_sym_count	long
+	O
1	int
)	O
*	O
symesz	long
)	O
;	O
amt	long
=	O
max_lineno_count	long
*	O
bfd_coff_linesz	O
(	O
abfd	pointer
)	O
;	O
flaginfo	struct
.	O
linenos	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
flaginfo	struct
.	O
contents	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
max_contents_size	long
)	O
;	O
amt	long
=	O
max_reloc_count	long
*	O
relsz	int
;	O
flaginfo	struct
.	O
external_relocs	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
{	O
amt	long
=	O
max_reloc_count	long
*	O
sizeof	O
(	O
struct	O
internal_reloc	struct
)	O
;	O
flaginfo	struct
.	O
internal_relocs	pointer
=	O
(	O
struct	O
internal_reloc	struct
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
}	O
if	O
(	O
(	O
flaginfo	struct
.	O
internal_syms	pointer
==	O
NULL	O
&&	O
max_sym_count	long
>	O
0	int
)	O
||	O
(	O
flaginfo	struct
.	O
sec_ptrs	pointer
==	O
NULL	O
&&	O
max_sym_count	long
>	O
0	int
)	O
||	O
(	O
flaginfo	struct
.	O
sym_indices	pointer
==	O
NULL	O
&&	O
max_sym_count	long
>	O
0	int
)	O
||	O
flaginfo	struct
.	O
outsyms	pointer
==	O
NULL	O
||	O
(	O
flaginfo	struct
.	O
linenos	pointer
==	O
NULL	O
&&	O
max_lineno_count	long
>	O
0	int
)	O
||	O
(	O
flaginfo	struct
.	O
contents	pointer
==	O
NULL	O
&&	O
max_contents_size	long
>	O
0	int
)	O
||	O
(	O
flaginfo	struct
.	O
external_relocs	pointer
==	O
NULL	O
&&	O
max_reloc_count	long
>	O
0	int
)	O
||	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
flaginfo	struct
.	O
internal_relocs	pointer
==	O
NULL	O
&&	O
max_reloc_count	long
>	O
0	int
)	O
)	O
goto	O
error_return	O
;	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
=	O
0	int
;	O
if	O
(	O
coff_backend_info	O
(	O
abfd	pointer
)	O
->	O
_bfd_coff_start_final_link	pointer
)	O
{	O
if	O
(	O
!	O
bfd_coff_start_final_link	O
(	O
abfd	pointer
,	O
info	pointer
)	O
)	O
goto	O
error_return	O
;	O
}	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
for	O
(	O
p	pointer
=	O
o	pointer
->	O
map_head	union
.	O
link_order	pointer
;	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_indirect_link_order	int
&&	O
bfd_family_coff	function
(	O
p	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
->	O
owner	pointer
)	O
)	O
{	O
sub	pointer
=	O
p	pointer
->	O
u	union
.	O
indirect	struct
.	O
section	pointer
->	O
owner	pointer
;	O
if	O
(	O
!	O
bfd_coff_link_output_has_begun	O
(	O
sub	pointer
,	O
&	O
flaginfo	struct
)	O
)	O
{	O
if	O
(	O
!	O
_bfd_coff_link_input_bfd	function
(	O
&	O
flaginfo	struct
,	O
sub	pointer
)	O
)	O
goto	O
error_return	O
;	O
sub	pointer
->	O
output_has_begun	int
=	O
TRUE	int
;	O
}	O
}	O
else	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
||	O
p	pointer
->	O
type	enum
==	O
bfd_symbol_reloc_link_order	int
)	O
{	O
if	O
(	O
!	O
_bfd_coff_reloc_link_order	function
(	O
abfd	pointer
,	O
&	O
flaginfo	struct
,	O
o	pointer
,	O
p	pointer
)	O
)	O
goto	O
error_return	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
_bfd_default_link_order	function
(	O
abfd	pointer
,	O
info	pointer
,	O
o	pointer
,	O
p	pointer
)	O
)	O
goto	O
error_return	O
;	O
}	O
}	O
}	O
if	O
(	O
flaginfo	struct
.	O
info	pointer
->	O
strip	enum
!=	O
strip_all	int
&&	O
flaginfo	struct
.	O
info	pointer
->	O
discard	enum
!=	O
discard_all	int
)	O
{	O
for	O
(	O
sub	pointer
=	O
info	pointer
->	O
input_bfds	pointer
;	O
sub	pointer
!=	O
NULL	O
;	O
sub	pointer
=	O
sub	pointer
->	O
link	function
.	O
next	pointer
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
if	O
(	O
bfd_family_coff	function
(	O
sub	pointer
)	O
||	O
!	O
bfd_get_outsymbols	function
(	O
sub	pointer
)	O
)	O
continue	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
bfd_get_symcount	function
(	O
sub	pointer
)	O
;	O
++	O
i	pointer
)	O
{	O
asymbol	struct
*	O
sym	pointer
=	O
bfd_get_outsymbols	function
(	O
sub	pointer
)	O
[	O
i	pointer
]	O
;	O
file_ptr	long
pos	long
;	O
struct	O
internal_syment	struct
isym	pointer
;	O
union	O
internal_auxent	union
iaux	pointer
;	O
bfd_size_type	long
string_size	long
=	O
0	int
,	O
indx	long
;	O
bfd_vma	long
written	long
=	O
0	int
;	O
bfd_boolean	int
rewrite	int
=	O
FALSE	int
,	O
hash	long
;	O
if	O
(	O
!	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_LOCAL	O
)	O
||	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
BSF_SECTION_SYM	O
|	O
BSF_DEBUGGING_RELOC	O
|	O
BSF_THREAD_LOCAL	O
|	O
BSF_RELC	O
|	O
BSF_SRELC	O
|	O
BSF_SYNTHETIC	O
)	O
)	O
||	O
(	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_DEBUGGING	O
)	O
&&	O
!	O
(	O
sym	pointer
->	O
flags	int
&	O
BSF_FILE	O
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
flaginfo	struct
.	O
info	pointer
->	O
strip	enum
==	O
strip_some	int
&&	O
(	O
bfd_hash_lookup	function
(	O
flaginfo	struct
.	O
info	pointer
->	O
keep_hash	pointer
,	O
bfd_asymbol_name	function
(	O
sym	pointer
)	O
,	O
FALSE	int
,	O
FALSE	int
)	O
==	O
NULL	O
)	O
)	O
||	O
(	O
(	O
(	O
flaginfo	struct
.	O
info	pointer
->	O
discard	enum
==	O
discard_sec_merge	int
&&	O
(	O
bfd_asymbol_section	function
(	O
sym	pointer
)	O
->	O
flags	int
&	O
SEC_MERGE	int
)	O
&&	O
!	O
bfd_link_relocatable	O
(	O
flaginfo	struct
.	O
info	pointer
)	O
)	O
||	O
flaginfo	struct
.	O
info	pointer
->	O
discard	enum
==	O
discard_l	int
)	O
&&	O
bfd_is_local_label_name	function
(	O
sub	pointer
,	O
bfd_asymbol_name	function
(	O
sym	pointer
)	O
)	O
)	O
)	O
continue	O
;	O
pos	long
=	O
obj_sym_filepos	O
(	O
abfd	pointer
)	O
+	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
*	O
symesz	long
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
goto	O
error_return	O
;	O
if	O
(	O
!	O
coff_write_alien_symbol	function
(	O
abfd	pointer
,	O
sym	pointer
,	O
&	O
isym	pointer
,	O
&	O
iaux	pointer
,	O
&	O
written	long
,	O
&	O
string_size	long
,	O
NULL	O
,	O
NULL	O
)	O
)	O
goto	O
error_return	O
;	O
hash	long
=	O
!	O
flaginfo	struct
.	O
info	pointer
->	O
traditional_format	int
;	O
if	O
(	O
string_size	long
>=	O
6	int
&&	O
isym	pointer
.	O
n_sclass	char
==	O
C_FILE	int
&&	O
!	O
isym	pointer
.	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
&&	O
isym	pointer
.	O
n_numaux	char
)	O
{	O
indx	long
=	O
_bfd_stringtab_add	function
(	O
flaginfo	struct
.	O
strtab	pointer
,	O
".file"	pointer
,	O
hash	long
,	O
FALSE	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
bfd_size_type	long
)	O
-	O
1	int
)	O
goto	O
error_return	O
;	O
isym	pointer
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
STRING_SIZE_SIZE	int
+	O
indx	long
;	O
bfd_coff_swap_sym_out	O
(	O
abfd	pointer
,	O
&	O
isym	pointer
,	O
flaginfo	struct
.	O
outsyms	pointer
)	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bwrite	function
(	O
flaginfo	struct
.	O
outsyms	pointer
,	O
symesz	long
,	O
abfd	pointer
)	O
!=	O
symesz	long
)	O
goto	O
error_return	O
;	O
string_size	long
-=	O
6	int
;	O
}	O
if	O
(	O
string_size	long
)	O
{	O
indx	long
=	O
_bfd_stringtab_add	function
(	O
flaginfo	struct
.	O
strtab	pointer
,	O
bfd_asymbol_name	function
(	O
sym	pointer
)	O
,	O
hash	long
,	O
FALSE	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
bfd_size_type	long
)	O
-	O
1	int
)	O
goto	O
error_return	O
;	O
if	O
(	O
isym	pointer
.	O
n_sclass	char
!=	O
C_FILE	int
)	O
{	O
isym	pointer
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
STRING_SIZE_SIZE	int
+	O
indx	long
;	O
bfd_coff_swap_sym_out	O
(	O
abfd	pointer
,	O
&	O
isym	pointer
,	O
flaginfo	struct
.	O
outsyms	pointer
)	O
;	O
rewrite	int
=	O
TRUE	int
;	O
}	O
else	O
{	O
BFD_ASSERT	O
(	O
isym	pointer
.	O
n_numaux	char
==	O
1	int
)	O
;	O
iaux	pointer
.	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
=	O
STRING_SIZE_SIZE	int
+	O
indx	long
;	O
bfd_coff_swap_aux_out	O
(	O
abfd	pointer
,	O
&	O
iaux	pointer
,	O
isym	pointer
.	O
n_type	short
,	O
C_FILE	int
,	O
0	int
,	O
1	int
,	O
flaginfo	struct
.	O
outsyms	pointer
+	O
symesz	long
)	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
pos	long
+	O
symesz	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bwrite	function
(	O
flaginfo	struct
.	O
outsyms	pointer
+	O
symesz	long
,	O
symesz	long
,	O
abfd	pointer
)	O
!=	O
symesz	long
)	O
goto	O
error_return	O
;	O
}	O
}	O
if	O
(	O
isym	pointer
.	O
n_sclass	char
==	O
C_FILE	int
)	O
{	O
if	O
(	O
flaginfo	struct
.	O
last_file_index	long
!=	O
-	O
1	int
)	O
{	O
flaginfo	struct
.	O
last_file	struct
.	O
n_value	long
=	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
;	O
bfd_coff_swap_sym_out	O
(	O
abfd	pointer
,	O
&	O
flaginfo	struct
.	O
last_file	struct
,	O
flaginfo	struct
.	O
outsyms	pointer
)	O
;	O
pos	long
=	O
obj_sym_filepos	O
(	O
abfd	pointer
)	O
+	O
flaginfo	struct
.	O
last_file_index	long
*	O
symesz	long
;	O
rewrite	int
=	O
TRUE	int
;	O
}	O
flaginfo	struct
.	O
last_file_index	long
=	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
;	O
flaginfo	struct
.	O
last_file	struct
=	O
isym	pointer
;	O
}	O
if	O
(	O
rewrite	int
&&	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bwrite	function
(	O
flaginfo	struct
.	O
outsyms	pointer
,	O
symesz	long
,	O
abfd	pointer
)	O
!=	O
symesz	long
)	O
)	O
goto	O
error_return	O
;	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
+=	O
written	long
;	O
}	O
}	O
}	O
if	O
(	O
!	O
bfd_coff_final_link_postscript	O
(	O
abfd	pointer
,	O
&	O
flaginfo	struct
)	O
)	O
goto	O
error_return	O
;	O
coff_debug_merge_hash_table_free	O
(	O
&	O
flaginfo	struct
.	O
debug_merge	struct
)	O
;	O
debug_merge_allocated	int
=	O
FALSE	int
;	O
if	O
(	O
flaginfo	struct
.	O
internal_syms	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
flaginfo	struct
.	O
internal_syms	pointer
)	O
;	O
flaginfo	struct
.	O
internal_syms	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
flaginfo	struct
.	O
sec_ptrs	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
flaginfo	struct
.	O
sec_ptrs	pointer
)	O
;	O
flaginfo	struct
.	O
sec_ptrs	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
flaginfo	struct
.	O
sym_indices	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
flaginfo	struct
.	O
sym_indices	pointer
)	O
;	O
flaginfo	struct
.	O
sym_indices	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
flaginfo	struct
.	O
linenos	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
flaginfo	struct
.	O
linenos	pointer
)	O
;	O
flaginfo	struct
.	O
linenos	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
flaginfo	struct
.	O
contents	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
flaginfo	struct
.	O
contents	pointer
)	O
;	O
flaginfo	struct
.	O
contents	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
flaginfo	struct
.	O
external_relocs	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
flaginfo	struct
.	O
external_relocs	pointer
)	O
;	O
flaginfo	struct
.	O
external_relocs	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
flaginfo	struct
.	O
internal_relocs	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
flaginfo	struct
.	O
internal_relocs	pointer
)	O
;	O
flaginfo	struct
.	O
internal_relocs	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
flaginfo	struct
.	O
last_file_index	long
!=	O
-	O
1	int
&&	O
(	O
unsigned	O
int	O
)	O
flaginfo	struct
.	O
last_file	struct
.	O
n_value	long
!=	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
)	O
{	O
file_ptr	long
pos	long
;	O
flaginfo	struct
.	O
last_file	struct
.	O
n_value	long
=	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
;	O
bfd_coff_swap_sym_out	O
(	O
abfd	pointer
,	O
&	O
flaginfo	struct
.	O
last_file	struct
,	O
flaginfo	struct
.	O
outsyms	pointer
)	O
;	O
pos	long
=	O
obj_sym_filepos	O
(	O
abfd	pointer
)	O
+	O
flaginfo	struct
.	O
last_file_index	long
*	O
symesz	long
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bwrite	function
(	O
flaginfo	struct
.	O
outsyms	pointer
,	O
symesz	long
,	O
abfd	pointer
)	O
!=	O
symesz	long
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
info	pointer
->	O
task_link	int
)	O
{	O
flaginfo	struct
.	O
failed	int
=	O
FALSE	int
;	O
coff_link_hash_traverse	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
,	O
_bfd_coff_write_task_globals	function
,	O
&	O
flaginfo	struct
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
failed	int
)	O
goto	O
error_return	O
;	O
}	O
flaginfo	struct
.	O
failed	int
=	O
FALSE	int
;	O
bfd_hash_traverse	function
(	O
&	O
info	pointer
->	O
hash	long
->	O
table	pointer
,	O
_bfd_coff_write_global_sym	function
,	O
&	O
flaginfo	struct
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
failed	int
)	O
goto	O
error_return	O
;	O
if	O
(	O
flaginfo	struct
.	O
outsyms	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
flaginfo	struct
.	O
outsyms	pointer
)	O
;	O
flaginfo	struct
.	O
outsyms	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
&&	O
max_output_reloc_count	long
>	O
0	int
)	O
{	O
amt	long
=	O
max_output_reloc_count	long
*	O
relsz	int
;	O
external_relocs	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
external_relocs	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
for	O
(	O
o	pointer
=	O
abfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
struct	O
internal_reloc	struct
*	O
irel	pointer
;	O
struct	O
internal_reloc	struct
*	O
irelend	pointer
;	O
struct	O
coff_link_hash_entry	struct
*	O
*	O
rel_hash	pointer
;	O
bfd_byte	char
*	O
erel	pointer
;	O
if	O
(	O
o	pointer
->	O
reloc_count	int
==	O
0	int
)	O
continue	O
;	O
irel	pointer
=	O
flaginfo	struct
.	O
section_info	pointer
[	O
o	pointer
->	O
target_index	int
]	O
.	O
relocs	pointer
;	O
irelend	pointer
=	O
irel	pointer
+	O
o	pointer
->	O
reloc_count	int
;	O
rel_hash	pointer
=	O
flaginfo	struct
.	O
section_info	pointer
[	O
o	pointer
->	O
target_index	int
]	O
.	O
rel_hashes	pointer
;	O
erel	pointer
=	O
external_relocs	pointer
;	O
for	O
(	O
;	O
irel	pointer
<	O
irelend	pointer
;	O
irel	pointer
++	O
,	O
rel_hash	pointer
++	O
,	O
erel	pointer
+=	O
relsz	int
)	O
{	O
if	O
(	O
*	O
rel_hash	pointer
!=	O
NULL	O
)	O
{	O
BFD_ASSERT	O
(	O
(	O
*	O
rel_hash	pointer
)	O
->	O
indx	long
>=	O
0	int
)	O
;	O
irel	pointer
->	O
r_symndx	long
=	O
(	O
*	O
rel_hash	pointer
)	O
->	O
indx	long
;	O
}	O
bfd_coff_swap_reloc_out	O
(	O
abfd	pointer
,	O
irel	pointer
,	O
erel	pointer
)	O
;	O
}	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
o	pointer
->	O
rel_filepos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
goto	O
error_return	O
;	O
if	O
(	O
obj_pe	O
(	O
abfd	pointer
)	O
&&	O
o	pointer
->	O
reloc_count	int
>=	O
0xffff	int
)	O
{	O
struct	O
internal_reloc	struct
incount	struct
;	O
bfd_byte	char
*	O
excount	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
relsz	int
)	O
;	O
memset	function
(	O
&	O
incount	struct
,	O
0	int
,	O
sizeof	O
(	O
incount	struct
)	O
)	O
;	O
incount	struct
.	O
r_vaddr	long
=	O
o	pointer
->	O
reloc_count	int
+	O
1	int
;	O
bfd_coff_swap_reloc_out	O
(	O
abfd	pointer
,	O
&	O
incount	struct
,	O
excount	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
excount	pointer
,	O
relsz	int
,	O
abfd	pointer
)	O
!=	O
relsz	int
)	O
goto	O
error_return	O
;	O
free	function
(	O
excount	pointer
)	O
;	O
}	O
if	O
(	O
bfd_bwrite	function
(	O
external_relocs	pointer
,	O
(	O
bfd_size_type	long
)	O
relsz	int
*	O
o	pointer
->	O
reloc_count	int
,	O
abfd	pointer
)	O
!=	O
(	O
bfd_size_type	long
)	O
relsz	int
*	O
o	pointer
->	O
reloc_count	int
)	O
goto	O
error_return	O
;	O
}	O
free	function
(	O
external_relocs	pointer
)	O
;	O
external_relocs	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
flaginfo	struct
.	O
section_info	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
abfd	pointer
->	O
section_count	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
flaginfo	struct
.	O
section_info	pointer
[	O
i	pointer
]	O
.	O
relocs	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
section_info	pointer
[	O
i	pointer
]	O
.	O
relocs	pointer
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
section_info	pointer
[	O
i	pointer
]	O
.	O
rel_hashes	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
section_info	pointer
[	O
i	pointer
]	O
.	O
rel_hashes	pointer
)	O
;	O
}	O
free	function
(	O
flaginfo	struct
.	O
section_info	pointer
)	O
;	O
flaginfo	struct
.	O
section_info	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
coff_hash_table	O
(	O
info	pointer
)	O
->	O
stab_info	struct
.	O
stabstr	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
_bfd_write_stab_strings	function
(	O
abfd	pointer
,	O
&	O
coff_hash_table	O
(	O
info	pointer
)	O
->	O
stab_info	struct
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
!=	O
0	int
||	O
long_section_names	int
)	O
{	O
file_ptr	long
pos	long
;	O
pos	long
=	O
obj_sym_filepos	O
(	O
abfd	pointer
)	O
+	O
obj_raw_syment_count	O
(	O
abfd	pointer
)	O
*	O
symesz	long
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
return	O
FALSE	int
;	O
H_PUT_32	O
(	O
abfd	pointer
,	O
_bfd_stringtab_size	function
(	O
flaginfo	struct
.	O
strtab	pointer
)	O
+	O
STRING_SIZE_SIZE	int
,	O
strbuf	array
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
strbuf	array
,	O
(	O
bfd_size_type	long
)	O
STRING_SIZE_SIZE	int
,	O
abfd	pointer
)	O
!=	O
STRING_SIZE_SIZE	int
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
_bfd_stringtab_emit	function
(	O
abfd	pointer
,	O
flaginfo	struct
.	O
strtab	pointer
)	O
)	O
return	O
FALSE	int
;	O
obj_coff_strings_written	O
(	O
abfd	pointer
)	O
=	O
TRUE	int
;	O
}	O
_bfd_stringtab_free	function
(	O
flaginfo	struct
.	O
strtab	pointer
)	O
;	O
abfd	pointer
->	O
symcount	int
=	O
0	int
;	O
return	O
TRUE	int
;	O
error_return	O
:	O
if	O
(	O
debug_merge_allocated	int
)	O
coff_debug_merge_hash_table_free	O
(	O
&	O
flaginfo	struct
.	O
debug_merge	struct
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
strtab	pointer
!=	O
NULL	O
)	O
_bfd_stringtab_free	function
(	O
flaginfo	struct
.	O
strtab	pointer
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
section_info	pointer
!=	O
NULL	O
)	O
{	O
unsigned	O
int	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
abfd	pointer
->	O
section_count	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
flaginfo	struct
.	O
section_info	pointer
[	O
i	pointer
]	O
.	O
relocs	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
section_info	pointer
[	O
i	pointer
]	O
.	O
relocs	pointer
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
section_info	pointer
[	O
i	pointer
]	O
.	O
rel_hashes	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
section_info	pointer
[	O
i	pointer
]	O
.	O
rel_hashes	pointer
)	O
;	O
}	O
free	function
(	O
flaginfo	struct
.	O
section_info	pointer
)	O
;	O
}	O
if	O
(	O
flaginfo	struct
.	O
internal_syms	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
internal_syms	pointer
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
sec_ptrs	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
sec_ptrs	pointer
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
sym_indices	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
sym_indices	pointer
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
outsyms	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
outsyms	pointer
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
linenos	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
linenos	pointer
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
contents	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
contents	pointer
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
external_relocs	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
external_relocs	pointer
)	O
;	O
if	O
(	O
flaginfo	struct
.	O
internal_relocs	pointer
!=	O
NULL	O
)	O
free	function
(	O
flaginfo	struct
.	O
internal_relocs	pointer
)	O
;	O
if	O
(	O
external_relocs	pointer
!=	O
NULL	O
)	O
free	function
(	O
external_relocs	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
char	O
*	O
dores_com	function
(	O
char	O
*	O
ptr	pointer
,	O
bfd	struct
*	O
output_bfd	pointer
,	O
int	O
heap	int
)	O
{	O
if	O
(	O
coff_data	O
(	O
output_bfd	pointer
)	O
->	O
pe	struct
)	O
{	O
int	O
val	array
=	O
strtoul	function
(	O
ptr	pointer
,	O
&	O
ptr	pointer
,	O
0	int
)	O
;	O
if	O
(	O
heap	int
)	O
pe_data	O
(	O
output_bfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
SizeOfHeapReserve	long
=	O
val	array
;	O
else	O
pe_data	O
(	O
output_bfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
SizeOfStackReserve	long
=	O
val	array
;	O
if	O
(	O
ptr	pointer
[	O
0	int
]	O
==	O
','	O
)	O
{	O
val	array
=	O
strtoul	function
(	O
ptr	pointer
+	O
1	int
,	O
&	O
ptr	pointer
,	O
0	int
)	O
;	O
if	O
(	O
heap	int
)	O
pe_data	O
(	O
output_bfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
SizeOfHeapCommit	long
=	O
val	array
;	O
else	O
pe_data	O
(	O
output_bfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
SizeOfStackCommit	long
=	O
val	array
;	O
}	O
}	O
return	O
ptr	pointer
;	O
}	O
static	O
char	O
*	O
get_name	function
(	O
char	O
*	O
ptr	pointer
,	O
char	O
*	O
*	O
dst	pointer
)	O
{	O
while	O
(	O
*	O
ptr	pointer
==	O
' '	O
)	O
ptr	pointer
++	O
;	O
*	O
dst	pointer
=	O
ptr	pointer
;	O
while	O
(	O
*	O
ptr	pointer
&&	O
*	O
ptr	pointer
!=	O
' '	O
)	O
ptr	pointer
++	O
;	O
*	O
ptr	pointer
=	O
0	int
;	O
return	O
ptr	pointer
+	O
1	int
;	O
}	O
static	O
int	O
process_embedded_commands	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
ATTRIBUTE_UNUSED	O
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
asection	struct
*	O
sec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
".drectve"	pointer
)	O
;	O
char	O
*	O
s	pointer
;	O
char	O
*	O
e	pointer
;	O
bfd_byte	char
*	O
copy	int
;	O
if	O
(	O
!	O
sec	pointer
)	O
return	O
1	int
;	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
sec	pointer
,	O
&	O
copy	int
)	O
)	O
{	O
if	O
(	O
copy	int
!=	O
NULL	O
)	O
free	function
(	O
copy	int
)	O
;	O
return	O
0	int
;	O
}	O
e	pointer
=	O
(	O
char	O
*	O
)	O
copy	int
+	O
sec	pointer
->	O
size	long
;	O
for	O
(	O
s	pointer
=	O
(	O
char	O
*	O
)	O
copy	int
;	O
s	pointer
<	O
e	pointer
;	O
)	O
{	O
if	O
(	O
s	pointer
[	O
0	int
]	O
!=	O
'-'	O
)	O
{	O
s	pointer
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
CONST_STRNEQ	O
(	O
s	pointer
,	O
"-attr"	pointer
)	O
)	O
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
attribs	pointer
;	O
asection	struct
*	O
asec	pointer
;	O
int	O
loop	int
=	O
1	int
;	O
int	O
had_write	int
=	O
0	int
;	O
int	O
had_exec	int
=	O
0	int
;	O
s	pointer
+=	O
5	int
;	O
s	pointer
=	O
get_name	function
(	O
s	pointer
,	O
&	O
name	pointer
)	O
;	O
s	pointer
=	O
get_name	function
(	O
s	pointer
,	O
&	O
attribs	pointer
)	O
;	O
while	O
(	O
loop	int
)	O
{	O
switch	O
(	O
*	O
attribs	pointer
++	O
)	O
{	O
case	O
'W'	O
:	O
had_write	int
=	O
1	int
;	O
break	O
;	O
case	O
'R'	O
:	O
break	O
;	O
case	O
'S'	O
:	O
break	O
;	O
case	O
'X'	O
:	O
had_exec	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
loop	int
=	O
0	int
;	O
}	O
}	O
asec	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
asec	pointer
)	O
{	O
if	O
(	O
had_exec	int
)	O
asec	pointer
->	O
flags	int
|=	O
SEC_CODE	int
;	O
if	O
(	O
!	O
had_write	int
)	O
asec	pointer
->	O
flags	int
|=	O
SEC_READONLY	int
;	O
}	O
}	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
s	pointer
,	O
"-heap"	pointer
)	O
)	O
s	pointer
=	O
dores_com	function
(	O
s	pointer
+	O
5	int
,	O
output_bfd	pointer
,	O
1	int
)	O
;	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
s	pointer
,	O
"-stack"	pointer
)	O
)	O
s	pointer
=	O
dores_com	function
(	O
s	pointer
+	O
6	int
,	O
output_bfd	pointer
,	O
0	int
)	O
;	O
else	O
if	O
(	O
CONST_STRNEQ	O
(	O
s	pointer
,	O
"-aligncomm:"	pointer
)	O
)	O
{	O
s	pointer
+=	O
11	int
;	O
}	O
else	O
s	pointer
++	O
;	O
}	O
free	function
(	O
copy	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
mark_relocs	function
(	O
struct	O
coff_final_link_info	struct
*	O
flaginfo	struct
,	O
bfd	struct
*	O
input_bfd	pointer
)	O
{	O
asection	struct
*	O
a	pointer
;	O
if	O
(	O
(	O
bfd_get_file_flags	function
(	O
input_bfd	pointer
)	O
&	O
HAS_SYMS	int
)	O
==	O
0	int
)	O
return	O
;	O
for	O
(	O
a	pointer
=	O
input_bfd	pointer
->	O
sections	pointer
;	O
a	pointer
!=	O
(	O
asection	struct
*	O
)	O
NULL	O
;	O
a	pointer
=	O
a	pointer
->	O
next	pointer
)	O
{	O
struct	O
internal_reloc	struct
*	O
internal_relocs	pointer
;	O
struct	O
internal_reloc	struct
*	O
irel	pointer
;	O
struct	O
internal_reloc	struct
*	O
irelend	pointer
;	O
if	O
(	O
(	O
a	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
==	O
0	int
||	O
a	pointer
->	O
reloc_count	int
<	O
1	int
||	O
a	pointer
->	O
linker_mark	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
a	pointer
->	O
output_section	pointer
==	O
bfd_abs_section_ptr	O
)	O
continue	O
;	O
internal_relocs	pointer
=	O
_bfd_coff_read_internal_relocs	function
(	O
input_bfd	pointer
,	O
a	pointer
,	O
FALSE	int
,	O
flaginfo	struct
->	O
external_relocs	pointer
,	O
bfd_link_relocatable	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
,	O
(	O
bfd_link_relocatable	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
?	O
(	O
flaginfo	struct
->	O
section_info	pointer
[	O
a	pointer
->	O
output_section	pointer
->	O
target_index	int
]	O
.	O
relocs	pointer
+	O
a	pointer
->	O
output_section	pointer
->	O
reloc_count	int
)	O
:	O
flaginfo	struct
->	O
internal_relocs	pointer
)	O
)	O
;	O
if	O
(	O
internal_relocs	pointer
==	O
NULL	O
)	O
continue	O
;	O
irel	pointer
=	O
internal_relocs	pointer
;	O
irelend	pointer
=	O
irel	pointer
+	O
a	pointer
->	O
reloc_count	int
;	O
for	O
(	O
;	O
irel	pointer
<	O
irelend	pointer
;	O
irel	pointer
++	O
)	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
irel	pointer
->	O
r_symndx	long
<	O
obj_raw_syment_count	O
(	O
input_bfd	pointer
)	O
)	O
flaginfo	struct
->	O
sym_indices	pointer
[	O
irel	pointer
->	O
r_symndx	long
]	O
=	O
-	O
1	int
;	O
}	O
}	O
bfd_boolean	int
_bfd_coff_link_input_bfd	function
(	O
struct	O
coff_final_link_info	struct
*	O
flaginfo	struct
,	O
bfd	struct
*	O
input_bfd	pointer
)	O
{	O
unsigned	O
int	O
n_tmask	int
=	O
coff_data	O
(	O
input_bfd	pointer
)	O
->	O
local_n_tmask	int
;	O
unsigned	O
int	O
n_btshft	int
=	O
coff_data	O
(	O
input_bfd	pointer
)	O
->	O
local_n_btshft	int
;	O
bfd_boolean	int
(	O
*	O
adjust_symndx	pointer
)	O
(	O
bfd	struct
*	O
,	O
struct	O
bfd_link_info	struct
*	O
,	O
bfd	struct
*	O
,	O
asection	struct
*	O
,	O
struct	O
internal_reloc	struct
*	O
,	O
bfd_boolean	int
*	O
)	O
;	O
bfd	struct
*	O
output_bfd	pointer
;	O
const	O
char	O
*	O
strings	pointer
;	O
bfd_size_type	long
syment_base	long
;	O
bfd_boolean	int
copy	int
,	O
hash	long
;	O
bfd_size_type	long
isymesz	long
;	O
bfd_size_type	long
osymesz	long
;	O
bfd_size_type	long
linesz	int
;	O
bfd_byte	char
*	O
esym	pointer
;	O
bfd_byte	char
*	O
esym_end	pointer
;	O
struct	O
internal_syment	struct
*	O
isymp	pointer
;	O
asection	struct
*	O
*	O
secpp	pointer
;	O
long	O
*	O
indexp	pointer
;	O
unsigned	O
long	O
output_index	long
;	O
bfd_byte	char
*	O
outsym	pointer
;	O
struct	O
coff_link_hash_entry	struct
*	O
*	O
sym_hash	pointer
;	O
asection	struct
*	O
o	pointer
;	O
output_bfd	pointer
=	O
flaginfo	struct
->	O
output_bfd	pointer
;	O
strings	pointer
=	O
NULL	O
;	O
syment_base	long
=	O
obj_raw_syment_count	O
(	O
output_bfd	pointer
)	O
;	O
isymesz	long
=	O
bfd_coff_symesz	O
(	O
input_bfd	pointer
)	O
;	O
osymesz	long
=	O
bfd_coff_symesz	O
(	O
output_bfd	pointer
)	O
;	O
linesz	int
=	O
bfd_coff_linesz	O
(	O
input_bfd	pointer
)	O
;	O
BFD_ASSERT	O
(	O
linesz	int
==	O
bfd_coff_linesz	O
(	O
output_bfd	pointer
)	O
)	O
;	O
copy	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
flaginfo	struct
->	O
info	pointer
->	O
keep_memory	int
)	O
copy	int
=	O
TRUE	int
;	O
hash	long
=	O
TRUE	int
;	O
if	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
traditional_format	int
)	O
hash	long
=	O
FALSE	int
;	O
if	O
(	O
!	O
_bfd_coff_get_external_symbols	function
(	O
input_bfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
esym	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
obj_coff_external_syms	O
(	O
input_bfd	pointer
)	O
;	O
esym_end	pointer
=	O
esym	pointer
+	O
obj_raw_syment_count	O
(	O
input_bfd	pointer
)	O
*	O
isymesz	long
;	O
isymp	pointer
=	O
flaginfo	struct
->	O
internal_syms	pointer
;	O
secpp	pointer
=	O
flaginfo	struct
->	O
sec_ptrs	pointer
;	O
indexp	pointer
=	O
flaginfo	struct
->	O
sym_indices	pointer
;	O
output_index	long
=	O
syment_base	long
;	O
outsym	pointer
=	O
flaginfo	struct
->	O
outsyms	pointer
;	O
if	O
(	O
coff_data	O
(	O
output_bfd	pointer
)	O
->	O
pe	struct
&&	O
!	O
process_embedded_commands	function
(	O
output_bfd	pointer
,	O
flaginfo	struct
->	O
info	pointer
,	O
input_bfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
strip	enum
!=	O
strip_none	int
||	O
flaginfo	struct
->	O
info	pointer
->	O
discard	enum
!=	O
discard_none	int
)	O
&&	O
bfd_link_relocatable	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
)	O
{	O
memset	function
(	O
indexp	pointer
,	O
0	int
,	O
obj_raw_syment_count	O
(	O
input_bfd	pointer
)	O
*	O
sizeof	O
*	O
indexp	pointer
)	O
;	O
mark_relocs	function
(	O
flaginfo	struct
,	O
input_bfd	pointer
)	O
;	O
}	O
while	O
(	O
esym	pointer
<	O
esym_end	pointer
)	O
{	O
struct	O
internal_syment	struct
isym	pointer
;	O
enum	O
coff_symbol_classification	enum
classification	enum
;	O
bfd_boolean	int
skip	int
;	O
bfd_boolean	int
global	int
;	O
bfd_boolean	int
dont_skip_symbol	int
;	O
int	O
add	int
;	O
bfd_coff_swap_sym_in	O
(	O
input_bfd	pointer
,	O
esym	pointer
,	O
isymp	pointer
)	O
;	O
isym	pointer
=	O
*	O
isymp	pointer
;	O
classification	enum
=	O
bfd_coff_classify_symbol	O
(	O
input_bfd	pointer
,	O
&	O
isym	pointer
)	O
;	O
switch	O
(	O
classification	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
COFF_SYMBOL_GLOBAL	int
:	O
case	O
COFF_SYMBOL_PE_SECTION	int
:	O
case	O
COFF_SYMBOL_LOCAL	int
:	O
*	O
secpp	pointer
=	O
coff_section_from_bfd_index	function
(	O
input_bfd	pointer
,	O
isym	pointer
.	O
n_scnum	int
)	O
;	O
break	O
;	O
case	O
COFF_SYMBOL_COMMON	int
:	O
*	O
secpp	pointer
=	O
bfd_com_section_ptr	O
;	O
break	O
;	O
case	O
COFF_SYMBOL_UNDEFINED	int
:	O
*	O
secpp	pointer
=	O
bfd_und_section_ptr	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
strip	enum
!=	O
strip_none	int
||	O
flaginfo	struct
->	O
info	pointer
->	O
discard	enum
!=	O
discard_none	int
)	O
&&	O
bfd_link_relocatable	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
)	O
dont_skip_symbol	int
=	O
*	O
indexp	pointer
;	O
else	O
dont_skip_symbol	int
=	O
FALSE	int
;	O
*	O
indexp	pointer
=	O
-	O
1	int
;	O
skip	int
=	O
FALSE	int
;	O
global	int
=	O
FALSE	int
;	O
add	int
=	O
1	int
+	O
isym	pointer
.	O
n_numaux	char
;	O
if	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
strip	enum
==	O
strip_all	int
&&	O
!	O
dont_skip_symbol	int
)	O
skip	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
skip	int
)	O
{	O
switch	O
(	O
classification	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
COFF_SYMBOL_GLOBAL	int
:	O
case	O
COFF_SYMBOL_COMMON	int
:	O
case	O
COFF_SYMBOL_PE_SECTION	int
:	O
global	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
ISFCN	O
(	O
isym	pointer
.	O
n_type	short
)	O
)	O
skip	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
COFF_SYMBOL_UNDEFINED	int
:	O
global	int
=	O
TRUE	int
;	O
skip	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
COFF_SYMBOL_LOCAL	int
:	O
if	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
discard	enum
==	O
discard_all	int
&&	O
!	O
dont_skip_symbol	int
)	O
skip	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
skip	int
&&	O
!	O
dont_skip_symbol	int
&&	O
isym	pointer
.	O
n_sclass	char
==	O
C_STAT	int
&&	O
isym	pointer
.	O
n_type	short
==	O
T_NULL	int
&&	O
isym	pointer
.	O
n_numaux	char
>	O
0	int
&&	O
(	O
(	O
*	O
secpp	pointer
)	O
->	O
output_section	pointer
==	O
bfd_abs_section_ptr	O
||	O
bfd_section_removed_from_list	function
(	O
output_bfd	pointer
,	O
(	O
*	O
secpp	pointer
)	O
->	O
output_section	pointer
)	O
)	O
)	O
skip	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
skip	int
&&	O
flaginfo	struct
->	O
info	pointer
->	O
strip	enum
==	O
strip_debugger	int
&&	O
!	O
dont_skip_symbol	int
&&	O
(	O
isym	pointer
.	O
n_scnum	int
==	O
N_DEBUG	O
||	O
(	O
isym	pointer
.	O
n_scnum	int
==	O
N_ABS	O
&&	O
(	O
isym	pointer
.	O
n_sclass	char
==	O
C_AUTO	int
||	O
isym	pointer
.	O
n_sclass	char
==	O
C_REG	int
||	O
isym	pointer
.	O
n_sclass	char
==	O
C_MOS	int
||	O
isym	pointer
.	O
n_sclass	char
==	O
C_MOE	int
||	O
isym	pointer
.	O
n_sclass	char
==	O
C_MOU	int
||	O
isym	pointer
.	O
n_sclass	char
==	O
C_ARG	int
||	O
isym	pointer
.	O
n_sclass	char
==	O
C_REGPARM	int
||	O
isym	pointer
.	O
n_sclass	char
==	O
C_FIELD	int
||	O
isym	pointer
.	O
n_sclass	char
==	O
C_EOS	int
)	O
)	O
)	O
)	O
skip	int
=	O
TRUE	int
;	O
if	O
(	O
!	O
skip	int
&&	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
strip	enum
==	O
strip_some	int
||	O
flaginfo	struct
->	O
info	pointer
->	O
discard	enum
==	O
discard_l	int
)	O
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
char	O
buf	pointer
[	O
SYMNMLEN	int
+	O
1	int
]	O
;	O
name	pointer
=	O
_bfd_coff_internal_syment_name	function
(	O
input_bfd	pointer
,	O
&	O
isym	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
dont_skip_symbol	int
&&	O
(	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
strip	enum
==	O
strip_some	int
&&	O
(	O
bfd_hash_lookup	function
(	O
flaginfo	struct
->	O
info	pointer
->	O
keep_hash	pointer
,	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
==	O
NULL	O
)	O
)	O
||	O
(	O
!	O
global	int
&&	O
flaginfo	struct
->	O
info	pointer
->	O
discard	enum
==	O
discard_l	int
&&	O
bfd_is_local_label_name	function
(	O
input_bfd	pointer
,	O
name	pointer
)	O
)	O
)	O
)	O
skip	int
=	O
TRUE	int
;	O
}	O
if	O
(	O
!	O
skip	int
&&	O
!	O
flaginfo	struct
->	O
info	pointer
->	O
traditional_format	int
&&	O
(	O
isym	pointer
.	O
n_sclass	char
==	O
C_ENTAG	int
||	O
isym	pointer
.	O
n_sclass	char
==	O
C_STRTAG	int
||	O
isym	pointer
.	O
n_sclass	char
==	O
C_UNTAG	int
)	O
&&	O
isym	pointer
.	O
n_numaux	char
==	O
1	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
char	O
buf	pointer
[	O
SYMNMLEN	int
+	O
1	int
]	O
;	O
struct	O
coff_debug_merge_hash_entry	struct
*	O
mh	pointer
;	O
struct	O
coff_debug_merge_type	struct
*	O
mt	pointer
;	O
union	O
internal_auxent	union
aux	pointer
;	O
struct	O
coff_debug_merge_element	struct
*	O
*	O
epp	pointer
;	O
bfd_byte	char
*	O
esl	pointer
,	O
*	O
eslend	pointer
;	O
struct	O
internal_syment	struct
*	O
islp	pointer
;	O
bfd_size_type	long
amt	long
;	O
name	pointer
=	O
_bfd_coff_internal_syment_name	function
(	O
input_bfd	pointer
,	O
&	O
isym	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
*	O
name	pointer
==	O
'~'	O
||	O
*	O
name	pointer
==	O
'.'	O
||	O
*	O
name	pointer
==	O
'$'	O
||	O
(	O
*	O
name	pointer
==	O
bfd_get_symbol_leading_char	function
(	O
input_bfd	pointer
)	O
&&	O
(	O
name	pointer
[	O
1	int
]	O
==	O
'~'	O
||	O
name	pointer
[	O
1	int
]	O
==	O
'.'	O
||	O
name	pointer
[	O
1	int
]	O
==	O
'$'	O
)	O
)	O
)	O
name	pointer
=	O
""	pointer
;	O
mh	pointer
=	O
coff_debug_merge_hash_lookup	O
(	O
&	O
flaginfo	struct
->	O
debug_merge	struct
,	O
name	pointer
,	O
TRUE	int
,	O
TRUE	int
)	O
;	O
if	O
(	O
mh	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
amt	long
=	O
sizeof	O
(	O
struct	O
coff_debug_merge_type	struct
)	O
;	O
mt	pointer
=	O
(	O
struct	O
coff_debug_merge_type	struct
*	O
)	O
bfd_alloc	function
(	O
input_bfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
mt	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
mt	pointer
->	O
type_class	int
=	O
isym	pointer
.	O
n_sclass	char
;	O
bfd_coff_swap_aux_in	O
(	O
input_bfd	pointer
,	O
(	O
esym	pointer
+	O
isymesz	long
)	O
,	O
isym	pointer
.	O
n_type	short
,	O
isym	pointer
.	O
n_sclass	char
,	O
0	int
,	O
isym	pointer
.	O
n_numaux	char
,	O
&	O
aux	pointer
)	O
;	O
epp	pointer
=	O
&	O
mt	pointer
->	O
elements	pointer
;	O
mt	pointer
->	O
elements	pointer
=	O
NULL	O
;	O
islp	pointer
=	O
isymp	pointer
+	O
2	int
;	O
esl	pointer
=	O
esym	pointer
+	O
2	int
*	O
isymesz	long
;	O
eslend	pointer
=	O
(	O
(	O
bfd_byte	char
*	O
)	O
obj_coff_external_syms	O
(	O
input_bfd	pointer
)	O
+	O
aux	pointer
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
*	O
isymesz	long
)	O
;	O
while	O
(	O
esl	pointer
<	O
eslend	pointer
)	O
{	O
const	O
char	O
*	O
elename	pointer
;	O
char	O
elebuf	array
[	O
SYMNMLEN	int
+	O
1	int
]	O
;	O
char	O
*	O
name_copy	pointer
;	O
bfd_coff_swap_sym_in	O
(	O
input_bfd	pointer
,	O
esl	pointer
,	O
islp	pointer
)	O
;	O
amt	long
=	O
sizeof	O
(	O
struct	O
coff_debug_merge_element	struct
)	O
;	O
*	O
epp	pointer
=	O
(	O
struct	O
coff_debug_merge_element	struct
*	O
)	O
bfd_alloc	function
(	O
input_bfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
*	O
epp	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
elename	pointer
=	O
_bfd_coff_internal_syment_name	function
(	O
input_bfd	pointer
,	O
islp	pointer
,	O
elebuf	array
)	O
;	O
if	O
(	O
elename	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
amt	long
=	O
strlen	function
(	O
elename	pointer
)	O
+	O
1	int
;	O
name_copy	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
input_bfd	pointer
,	O
amt	long
)	O
;	O
if	O
(	O
name_copy	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
strcpy	function
(	O
name_copy	pointer
,	O
elename	pointer
)	O
;	O
(	O
*	O
epp	pointer
)	O
->	O
name	pointer
=	O
name_copy	pointer
;	O
(	O
*	O
epp	pointer
)	O
->	O
type	enum
=	O
islp	pointer
->	O
n_type	short
;	O
(	O
*	O
epp	pointer
)	O
->	O
tagndx	long
=	O
0	int
;	O
if	O
(	O
islp	pointer
->	O
n_numaux	char
>=	O
1	int
&&	O
islp	pointer
->	O
n_type	short
!=	O
T_NULL	int
&&	O
islp	pointer
->	O
n_sclass	char
!=	O
C_EOS	int
)	O
{	O
union	O
internal_auxent	union
eleaux	union
;	O
long	O
indx	long
;	O
bfd_coff_swap_aux_in	O
(	O
input_bfd	pointer
,	O
(	O
esl	pointer
+	O
isymesz	long
)	O
,	O
islp	pointer
->	O
n_type	short
,	O
islp	pointer
->	O
n_sclass	char
,	O
0	int
,	O
islp	pointer
->	O
n_numaux	char
,	O
&	O
eleaux	union
)	O
;	O
indx	long
=	O
eleaux	union
.	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
;	O
if	O
(	O
indx	long
>	O
0	int
&&	O
(	O
indx	long
<	O
(	O
(	O
esym	pointer
-	O
(	O
bfd_byte	char
*	O
)	O
obj_coff_external_syms	O
(	O
input_bfd	pointer
)	O
)	O
/	O
(	O
long	O
)	O
isymesz	long
)	O
)	O
)	O
{	O
(	O
*	O
epp	pointer
)	O
->	O
tagndx	long
=	O
flaginfo	struct
->	O
sym_indices	pointer
[	O
indx	long
]	O
;	O
if	O
(	O
(	O
*	O
epp	pointer
)	O
->	O
tagndx	long
<	O
0	int
)	O
(	O
*	O
epp	pointer
)	O
->	O
tagndx	long
=	O
0	int
;	O
}	O
}	O
epp	pointer
=	O
&	O
(	O
*	O
epp	pointer
)	O
->	O
next	pointer
;	O
*	O
epp	pointer
=	O
NULL	O
;	O
esl	pointer
+=	O
(	O
islp	pointer
->	O
n_numaux	char
+	O
1	int
)	O
*	O
isymesz	long
;	O
islp	pointer
+=	O
islp	pointer
->	O
n_numaux	char
+	O
1	int
;	O
}	O
if	O
(	O
mt	pointer
->	O
elements	pointer
==	O
NULL	O
)	O
bfd_release	function
(	O
input_bfd	pointer
,	O
mt	pointer
)	O
;	O
else	O
{	O
struct	O
coff_debug_merge_type	struct
*	O
mtl	pointer
;	O
for	O
(	O
mtl	pointer
=	O
mh	pointer
->	O
types	pointer
;	O
mtl	pointer
!=	O
NULL	O
;	O
mtl	pointer
=	O
mtl	pointer
->	O
next	pointer
)	O
{	O
struct	O
coff_debug_merge_element	struct
*	O
me	pointer
,	O
*	O
mel	pointer
;	O
if	O
(	O
mtl	pointer
->	O
type_class	int
!=	O
mt	pointer
->	O
type_class	int
)	O
continue	O
;	O
for	O
(	O
me	pointer
=	O
mt	pointer
->	O
elements	pointer
,	O
mel	pointer
=	O
mtl	pointer
->	O
elements	pointer
;	O
me	pointer
!=	O
NULL	O
&&	O
mel	pointer
!=	O
NULL	O
;	O
me	pointer
=	O
me	pointer
->	O
next	pointer
,	O
mel	pointer
=	O
mel	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
me	pointer
->	O
name	pointer
,	O
mel	pointer
->	O
name	pointer
)	O
!=	O
0	int
||	O
me	pointer
->	O
type	enum
!=	O
mel	pointer
->	O
type	enum
||	O
me	pointer
->	O
tagndx	long
!=	O
mel	pointer
->	O
tagndx	long
)	O
break	O
;	O
}	O
if	O
(	O
me	pointer
==	O
NULL	O
&&	O
mel	pointer
==	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
mtl	pointer
==	O
NULL	O
||	O
(	O
bfd_size_type	long
)	O
mtl	pointer
->	O
indx	long
>=	O
syment_base	long
)	O
{	O
mt	pointer
->	O
indx	long
=	O
output_index	long
;	O
mt	pointer
->	O
next	pointer
=	O
mh	pointer
->	O
types	pointer
;	O
mh	pointer
->	O
types	pointer
=	O
mt	pointer
;	O
}	O
else	O
{	O
bfd_release	function
(	O
input_bfd	pointer
,	O
mt	pointer
)	O
;	O
*	O
indexp	pointer
=	O
mtl	pointer
->	O
indx	long
;	O
add	int
=	O
(	O
eslend	pointer
-	O
esym	pointer
)	O
/	O
isymesz	long
;	O
skip	int
=	O
TRUE	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
skip	int
)	O
{	O
if	O
(	O
isym	pointer
.	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
==	O
0	int
&&	O
isym	pointer
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
!=	O
0	int
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
bfd_size_type	long
indx	long
;	O
name	pointer
=	O
_bfd_coff_internal_syment_name	function
(	O
input_bfd	pointer
,	O
&	O
isym	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
indx	long
=	O
_bfd_stringtab_add	function
(	O
flaginfo	struct
->	O
strtab	pointer
,	O
name	pointer
,	O
hash	long
,	O
copy	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
bfd_size_type	long
)	O
-	O
1	int
)	O
return	O
FALSE	int
;	O
isym	pointer
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
STRING_SIZE_SIZE	int
+	O
indx	long
;	O
}	O
switch	O
(	O
isym	pointer
.	O
n_sclass	char
)	O
{	O
case	O
C_AUTO	int
:	O
case	O
C_MOS	int
:	O
case	O
C_EOS	int
:	O
case	O
C_MOE	int
:	O
case	O
C_MOU	int
:	O
case	O
C_UNTAG	int
:	O
case	O
C_STRTAG	int
:	O
case	O
C_ENTAG	int
:	O
case	O
C_TPDEF	int
:	O
case	O
C_ARG	int
:	O
case	O
C_USTATIC	int
:	O
case	O
C_REG	int
:	O
case	O
C_REGPARM	int
:	O
case	O
C_FIELD	int
:	O
break	O
;	O
case	O
C_FCN	int
:	O
if	O
(	O
obj_pe	O
(	O
input_bfd	pointer
)	O
&&	O
memcmp	function
(	O
isym	pointer
.	O
n_name	O
,	O
".bf"	pointer
,	O
sizeof	O
".bf"	pointer
)	O
!=	O
0	int
&&	O
isym	pointer
.	O
n_scnum	int
>	O
0	int
)	O
{	O
isym	pointer
.	O
n_scnum	int
=	O
(	O
*	O
secpp	pointer
)	O
->	O
output_section	pointer
->	O
target_index	int
;	O
break	O
;	O
}	O
default	O
:	O
case	O
C_LABEL	int
:	O
case	O
C_EXTDEF	int
:	O
case	O
C_BLOCK	int
:	O
case	O
C_EFCN	int
:	O
case	O
C_NULL	int
:	O
case	O
C_EXT	int
:	O
case	O
C_STAT	int
:	O
case	O
C_SECTION	int
:	O
case	O
C_NT_WEAK	int
:	O
if	O
(	O
isym	pointer
.	O
n_scnum	int
>	O
0	int
)	O
{	O
isym	pointer
.	O
n_scnum	int
=	O
(	O
*	O
secpp	pointer
)	O
->	O
output_section	pointer
->	O
target_index	int
;	O
isym	pointer
.	O
n_value	long
+=	O
(	O
*	O
secpp	pointer
)	O
->	O
output_offset	long
;	O
if	O
(	O
!	O
obj_pe	O
(	O
input_bfd	pointer
)	O
)	O
isym	pointer
.	O
n_value	long
-=	O
(	O
*	O
secpp	pointer
)	O
->	O
vma	long
;	O
if	O
(	O
!	O
obj_pe	O
(	O
flaginfo	struct
->	O
output_bfd	pointer
)	O
)	O
isym	pointer
.	O
n_value	long
+=	O
(	O
*	O
secpp	pointer
)	O
->	O
output_section	pointer
->	O
vma	long
;	O
}	O
break	O
;	O
case	O
C_FILE	int
:	O
if	O
(	O
flaginfo	struct
->	O
last_file_index	long
!=	O
-	O
1	int
&&	O
flaginfo	struct
->	O
last_file	struct
.	O
n_value	long
!=	O
(	O
bfd_vma	long
)	O
output_index	long
)	O
{	O
flaginfo	struct
->	O
last_file	struct
.	O
n_value	long
=	O
output_index	long
;	O
if	O
(	O
(	O
bfd_size_type	long
)	O
flaginfo	struct
->	O
last_file_index	long
>=	O
syment_base	long
)	O
{	O
bfd_coff_swap_sym_out	O
(	O
output_bfd	pointer
,	O
&	O
flaginfo	struct
->	O
last_file	struct
,	O
(	O
flaginfo	struct
->	O
outsyms	pointer
+	O
(	O
(	O
flaginfo	struct
->	O
last_file_index	long
-	O
syment_base	long
)	O
*	O
osymesz	long
)	O
)	O
)	O
;	O
}	O
else	O
{	O
file_ptr	long
pos	long
;	O
bfd_coff_swap_sym_out	O
(	O
output_bfd	pointer
,	O
&	O
flaginfo	struct
->	O
last_file	struct
,	O
outsym	pointer
)	O
;	O
pos	long
=	O
obj_sym_filepos	O
(	O
output_bfd	pointer
)	O
;	O
pos	long
+=	O
flaginfo	struct
->	O
last_file_index	long
*	O
osymesz	long
;	O
if	O
(	O
bfd_seek	function
(	O
output_bfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bwrite	function
(	O
outsym	pointer
,	O
osymesz	long
,	O
output_bfd	pointer
)	O
!=	O
osymesz	long
)	O
return	O
FALSE	int
;	O
}	O
}	O
flaginfo	struct
->	O
last_file_index	long
=	O
output_index	long
;	O
flaginfo	struct
->	O
last_file	struct
=	O
isym	pointer
;	O
break	O
;	O
}	O
if	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
task_link	int
&&	O
IS_EXTERNAL	O
(	O
input_bfd	pointer
,	O
isym	pointer
)	O
)	O
isym	pointer
.	O
n_sclass	char
=	O
C_STAT	int
;	O
bfd_coff_swap_sym_out	O
(	O
output_bfd	pointer
,	O
&	O
isym	pointer
,	O
outsym	pointer
)	O
;	O
*	O
indexp	pointer
=	O
output_index	long
;	O
if	O
(	O
global	int
)	O
{	O
long	O
indx	long
;	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
;	O
indx	long
=	O
(	O
(	O
esym	pointer
-	O
(	O
bfd_byte	char
*	O
)	O
obj_coff_external_syms	O
(	O
input_bfd	pointer
)	O
)	O
/	O
isymesz	long
)	O
;	O
h	pointer
=	O
obj_coff_sym_hashes	O
(	O
input_bfd	pointer
)	O
[	O
indx	long
]	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
h	pointer
->	O
indx	long
=	O
output_index	long
;	O
}	O
output_index	long
+=	O
add	int
;	O
outsym	pointer
+=	O
add	int
*	O
osymesz	long
;	O
}	O
esym	pointer
+=	O
add	int
*	O
isymesz	long
;	O
isymp	pointer
+=	O
add	int
;	O
++	O
secpp	pointer
;	O
++	O
indexp	pointer
;	O
for	O
(	O
--	O
add	int
;	O
add	int
>	O
0	int
;	O
--	O
add	int
)	O
{	O
*	O
secpp	pointer
++	O
=	O
NULL	O
;	O
*	O
indexp	pointer
++	O
=	O
-	O
1	int
;	O
}	O
}	O
esym	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
obj_coff_external_syms	O
(	O
input_bfd	pointer
)	O
;	O
esym_end	pointer
=	O
esym	pointer
+	O
obj_raw_syment_count	O
(	O
input_bfd	pointer
)	O
*	O
isymesz	long
;	O
isymp	pointer
=	O
flaginfo	struct
->	O
internal_syms	pointer
;	O
indexp	pointer
=	O
flaginfo	struct
->	O
sym_indices	pointer
;	O
sym_hash	pointer
=	O
obj_coff_sym_hashes	O
(	O
input_bfd	pointer
)	O
;	O
outsym	pointer
=	O
flaginfo	struct
->	O
outsyms	pointer
;	O
while	O
(	O
esym	pointer
<	O
esym_end	pointer
)	O
{	O
int	O
add	int
;	O
add	int
=	O
1	int
+	O
isymp	pointer
->	O
n_numaux	char
;	O
if	O
(	O
(	O
*	O
indexp	pointer
<	O
0	int
||	O
(	O
bfd_size_type	long
)	O
*	O
indexp	pointer
<	O
syment_base	long
)	O
&&	O
(	O
*	O
sym_hash	pointer
==	O
NULL	O
||	O
(	O
*	O
sym_hash	pointer
)	O
->	O
auxbfd	pointer
!=	O
input_bfd	pointer
)	O
)	O
esym	pointer
+=	O
add	int
*	O
isymesz	long
;	O
else	O
{	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
;	O
int	O
i	pointer
;	O
h	pointer
=	O
NULL	O
;	O
if	O
(	O
*	O
indexp	pointer
<	O
0	int
)	O
{	O
h	pointer
=	O
*	O
sym_hash	pointer
;	O
BFD_ASSERT	O
(	O
isymp	pointer
->	O
n_numaux	char
==	O
0	int
||	O
h	pointer
->	O
numaux	char
==	O
0	int
||	O
h	pointer
->	O
numaux	char
==	O
isymp	pointer
->	O
n_numaux	char
)	O
;	O
}	O
esym	pointer
+=	O
isymesz	long
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
outsym	pointer
+=	O
osymesz	long
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
isymp	pointer
->	O
n_numaux	char
&&	O
esym	pointer
<	O
esym_end	pointer
;	O
i	pointer
++	O
)	O
{	O
union	O
internal_auxent	union
aux	pointer
;	O
union	O
internal_auxent	union
*	O
auxp	pointer
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
&&	O
h	pointer
->	O
aux	pointer
!=	O
NULL	O
&&	O
(	O
h	pointer
->	O
numaux	char
>	O
i	pointer
)	O
)	O
auxp	pointer
=	O
h	pointer
->	O
aux	pointer
+	O
i	pointer
;	O
else	O
{	O
bfd_coff_swap_aux_in	O
(	O
input_bfd	pointer
,	O
esym	pointer
,	O
isymp	pointer
->	O
n_type	short
,	O
isymp	pointer
->	O
n_sclass	char
,	O
i	pointer
,	O
isymp	pointer
->	O
n_numaux	char
,	O
&	O
aux	pointer
)	O
;	O
auxp	pointer
=	O
&	O
aux	pointer
;	O
}	O
if	O
(	O
isymp	pointer
->	O
n_sclass	char
==	O
C_FILE	int
)	O
{	O
if	O
(	O
auxp	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_zeroes	long
==	O
0	int
&&	O
auxp	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
!=	O
0	int
)	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
bfd_size_type	long
indx	long
;	O
BFD_ASSERT	O
(	O
auxp	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
>=	O
STRING_SIZE_SIZE	int
)	O
;	O
if	O
(	O
strings	pointer
==	O
NULL	O
)	O
{	O
strings	pointer
=	O
_bfd_coff_read_string_table	function
(	O
input_bfd	pointer
)	O
;	O
if	O
(	O
strings	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
(	O
bfd_size_type	long
)	O
auxp	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
>=	O
obj_coff_strings_len	O
(	O
input_bfd	pointer
)	O
)	O
filename	pointer
=	O
_	O
(	O
"<corrupt>"	pointer
)	O
;	O
else	O
filename	pointer
=	O
strings	pointer
+	O
auxp	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
;	O
indx	long
=	O
_bfd_stringtab_add	function
(	O
flaginfo	struct
->	O
strtab	pointer
,	O
filename	pointer
,	O
hash	long
,	O
copy	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
bfd_size_type	long
)	O
-	O
1	int
)	O
return	O
FALSE	int
;	O
auxp	pointer
->	O
x_file	union
.	O
x_n	struct
.	O
x_offset	long
=	O
STRING_SIZE_SIZE	int
+	O
indx	long
;	O
}	O
}	O
else	O
if	O
(	O
(	O
isymp	pointer
->	O
n_sclass	char
!=	O
C_STAT	int
||	O
isymp	pointer
->	O
n_type	short
!=	O
T_NULL	int
)	O
&&	O
isymp	pointer
->	O
n_sclass	char
!=	O
C_NT_WEAK	int
)	O
{	O
unsigned	O
long	O
indx	long
;	O
if	O
(	O
ISFCN	O
(	O
isymp	pointer
->	O
n_type	short
)	O
||	O
ISTAG	O
(	O
isymp	pointer
->	O
n_sclass	char
)	O
||	O
isymp	pointer
->	O
n_sclass	char
==	O
C_BLOCK	int
||	O
isymp	pointer
->	O
n_sclass	char
==	O
C_FCN	int
)	O
{	O
indx	long
=	O
auxp	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
;	O
if	O
(	O
indx	long
>	O
0	int
&&	O
indx	long
<	O
obj_raw_syment_count	O
(	O
input_bfd	pointer
)	O
)	O
{	O
while	O
(	O
(	O
flaginfo	struct
->	O
sym_indices	pointer
[	O
indx	long
]	O
<	O
0	int
||	O
(	O
(	O
bfd_size_type	long
)	O
flaginfo	struct
->	O
sym_indices	pointer
[	O
indx	long
]	O
<	O
syment_base	long
)	O
)	O
&&	O
indx	long
<	O
obj_raw_syment_count	O
(	O
input_bfd	pointer
)	O
)	O
++	O
indx	long
;	O
if	O
(	O
indx	long
>=	O
obj_raw_syment_count	O
(	O
input_bfd	pointer
)	O
)	O
indx	long
=	O
output_index	long
;	O
else	O
indx	long
=	O
flaginfo	struct
->	O
sym_indices	pointer
[	O
indx	long
]	O
;	O
auxp	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
=	O
indx	long
;	O
}	O
}	O
indx	long
=	O
auxp	pointer
->	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
;	O
if	O
(	O
indx	long
>	O
0	int
&&	O
indx	long
<	O
obj_raw_syment_count	O
(	O
input_bfd	pointer
)	O
)	O
{	O
long	O
symindx	long
;	O
symindx	long
=	O
flaginfo	struct
->	O
sym_indices	pointer
[	O
indx	long
]	O
;	O
if	O
(	O
symindx	long
<	O
0	int
)	O
auxp	pointer
->	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
=	O
0	int
;	O
else	O
auxp	pointer
->	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
=	O
symindx	long
;	O
}	O
if	O
(	O
i	pointer
==	O
0	int
&&	O
h	pointer
==	O
NULL	O
&&	O
isymp	pointer
->	O
n_sclass	char
==	O
C_FCN	int
&&	O
(	O
isymp	pointer
->	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
!=	O
0	int
||	O
isymp	pointer
->	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
==	O
0	int
)	O
&&	O
isymp	pointer
->	O
_n	union
.	O
_n_name	array
[	O
0	int
]	O
==	O
'.'	O
&&	O
isymp	pointer
->	O
_n	union
.	O
_n_name	array
[	O
1	int
]	O
==	O
'b'	O
&&	O
isymp	pointer
->	O
_n	union
.	O
_n_name	array
[	O
2	int
]	O
==	O
'f'	O
&&	O
isymp	pointer
->	O
_n	union
.	O
_n_name	array
[	O
3	int
]	O
==	O
'\0'	O
)	O
{	O
if	O
(	O
flaginfo	struct
->	O
last_bf_index	long
!=	O
-	O
1	int
)	O
{	O
flaginfo	struct
->	O
last_bf	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
=	O
*	O
indexp	pointer
;	O
if	O
(	O
(	O
bfd_size_type	long
)	O
flaginfo	struct
->	O
last_bf_index	long
>=	O
syment_base	long
)	O
{	O
void	O
*	O
auxout	pointer
;	O
auxout	pointer
=	O
(	O
flaginfo	struct
->	O
outsyms	pointer
+	O
(	O
(	O
flaginfo	struct
->	O
last_bf_index	long
-	O
syment_base	long
)	O
*	O
osymesz	long
)	O
)	O
;	O
bfd_coff_swap_aux_out	O
(	O
output_bfd	pointer
,	O
&	O
flaginfo	struct
->	O
last_bf	union
,	O
isymp	pointer
->	O
n_type	short
,	O
isymp	pointer
->	O
n_sclass	char
,	O
0	int
,	O
isymp	pointer
->	O
n_numaux	char
,	O
auxout	pointer
)	O
;	O
}	O
else	O
{	O
file_ptr	long
pos	long
;	O
bfd_coff_swap_aux_out	O
(	O
output_bfd	pointer
,	O
&	O
flaginfo	struct
->	O
last_bf	union
,	O
isymp	pointer
->	O
n_type	short
,	O
isymp	pointer
->	O
n_sclass	char
,	O
0	int
,	O
isymp	pointer
->	O
n_numaux	char
,	O
outsym	pointer
)	O
;	O
pos	long
=	O
obj_sym_filepos	O
(	O
output_bfd	pointer
)	O
;	O
pos	long
+=	O
flaginfo	struct
->	O
last_bf_index	long
*	O
osymesz	long
;	O
if	O
(	O
bfd_seek	function
(	O
output_bfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
(	O
bfd_bwrite	function
(	O
outsym	pointer
,	O
osymesz	long
,	O
output_bfd	pointer
)	O
!=	O
osymesz	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
auxp	pointer
->	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_endndx	union
.	O
l	long
!=	O
0	int
)	O
flaginfo	struct
->	O
last_bf_index	long
=	O
-	O
1	int
;	O
else	O
{	O
flaginfo	struct
->	O
last_bf	union
=	O
*	O
auxp	pointer
;	O
flaginfo	struct
->	O
last_bf_index	long
=	O
(	O
(	O
(	O
outsym	pointer
-	O
flaginfo	struct
->	O
outsyms	pointer
)	O
/	O
osymesz	long
)	O
+	O
syment_base	long
)	O
;	O
}	O
}	O
}	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
bfd_coff_swap_aux_out	O
(	O
output_bfd	pointer
,	O
auxp	pointer
,	O
isymp	pointer
->	O
n_type	short
,	O
isymp	pointer
->	O
n_sclass	char
,	O
i	pointer
,	O
isymp	pointer
->	O
n_numaux	char
,	O
outsym	pointer
)	O
;	O
outsym	pointer
+=	O
osymesz	long
;	O
}	O
esym	pointer
+=	O
isymesz	long
;	O
}	O
}	O
indexp	pointer
+=	O
add	int
;	O
isymp	pointer
+=	O
add	int
;	O
sym_hash	pointer
+=	O
add	int
;	O
}	O
if	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
strip	enum
==	O
strip_none	int
||	O
flaginfo	struct
->	O
info	pointer
->	O
strip	enum
==	O
strip_some	int
)	O
{	O
for	O
(	O
o	pointer
=	O
input_bfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
bfd_vma	long
offset	long
;	O
bfd_byte	char
*	O
eline	pointer
;	O
bfd_byte	char
*	O
elineend	pointer
;	O
bfd_byte	char
*	O
oeline	pointer
;	O
bfd_boolean	int
skipping	int
;	O
file_ptr	long
pos	long
;	O
bfd_size_type	long
amt	long
;	O
if	O
(	O
o	pointer
->	O
lineno_count	int
==	O
0	int
||	O
(	O
o	pointer
->	O
output_section	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
bfd_seek	function
(	O
input_bfd	pointer
,	O
o	pointer
->	O
line_filepos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
flaginfo	struct
->	O
linenos	pointer
,	O
linesz	int
*	O
o	pointer
->	O
lineno_count	int
,	O
input_bfd	pointer
)	O
!=	O
linesz	int
*	O
o	pointer
->	O
lineno_count	int
)	O
return	O
FALSE	int
;	O
offset	long
=	O
o	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
o	pointer
->	O
output_offset	long
-	O
o	pointer
->	O
vma	long
;	O
eline	pointer
=	O
flaginfo	struct
->	O
linenos	pointer
;	O
oeline	pointer
=	O
flaginfo	struct
->	O
linenos	pointer
;	O
elineend	pointer
=	O
eline	pointer
+	O
linesz	int
*	O
o	pointer
->	O
lineno_count	int
;	O
skipping	int
=	O
FALSE	int
;	O
for	O
(	O
;	O
eline	pointer
<	O
elineend	pointer
;	O
eline	pointer
+=	O
linesz	int
)	O
{	O
struct	O
internal_lineno	struct
iline	struct
;	O
bfd_coff_swap_lineno_in	O
(	O
input_bfd	pointer
,	O
eline	pointer
,	O
&	O
iline	struct
)	O
;	O
if	O
(	O
iline	struct
.	O
l_lnno	long
!=	O
0	int
)	O
iline	struct
.	O
l_addr	union
.	O
l_paddr	long
+=	O
offset	long
;	O
else	O
if	O
(	O
iline	struct
.	O
l_addr	union
.	O
l_symndx	long
>=	O
0	int
&&	O
(	O
(	O
unsigned	O
long	O
)	O
iline	struct
.	O
l_addr	union
.	O
l_symndx	long
<	O
obj_raw_syment_count	O
(	O
input_bfd	pointer
)	O
)	O
)	O
{	O
long	O
indx	long
;	O
indx	long
=	O
flaginfo	struct
->	O
sym_indices	pointer
[	O
iline	struct
.	O
l_addr	union
.	O
l_symndx	long
]	O
;	O
if	O
(	O
indx	long
<	O
0	int
)	O
{	O
skipping	int
=	O
TRUE	int
;	O
}	O
else	O
{	O
struct	O
internal_syment	struct
is	struct
;	O
union	O
internal_auxent	union
ia	union
;	O
bfd_coff_swap_sym_in	O
(	O
output_bfd	pointer
,	O
(	O
flaginfo	struct
->	O
outsyms	pointer
+	O
(	O
(	O
indx	long
-	O
syment_base	long
)	O
*	O
osymesz	long
)	O
)	O
,	O
&	O
is	struct
)	O
;	O
if	O
(	O
(	O
ISFCN	O
(	O
is	struct
.	O
n_type	short
)	O
||	O
is	struct
.	O
n_sclass	char
==	O
C_BLOCK	int
)	O
&&	O
is	struct
.	O
n_numaux	char
>=	O
1	int
)	O
{	O
void	O
*	O
auxptr	pointer
;	O
auxptr	pointer
=	O
(	O
flaginfo	struct
->	O
outsyms	pointer
+	O
(	O
(	O
indx	long
-	O
syment_base	long
+	O
1	int
)	O
*	O
osymesz	long
)	O
)	O
;	O
bfd_coff_swap_aux_in	O
(	O
output_bfd	pointer
,	O
auxptr	pointer
,	O
is	struct
.	O
n_type	short
,	O
is	struct
.	O
n_sclass	char
,	O
0	int
,	O
is	struct
.	O
n_numaux	char
,	O
&	O
ia	union
)	O
;	O
ia	union
.	O
x_sym	struct
.	O
x_fcnary	union
.	O
x_fcn	struct
.	O
x_lnnoptr	long
=	O
(	O
o	pointer
->	O
output_section	pointer
->	O
line_filepos	long
+	O
o	pointer
->	O
output_section	pointer
->	O
lineno_count	int
*	O
linesz	int
+	O
eline	pointer
-	O
flaginfo	struct
->	O
linenos	pointer
)	O
;	O
bfd_coff_swap_aux_out	O
(	O
output_bfd	pointer
,	O
&	O
ia	union
,	O
is	struct
.	O
n_type	short
,	O
is	struct
.	O
n_sclass	char
,	O
0	int
,	O
is	struct
.	O
n_numaux	char
,	O
auxptr	pointer
)	O
;	O
}	O
skipping	int
=	O
FALSE	int
;	O
}	O
iline	struct
.	O
l_addr	union
.	O
l_symndx	long
=	O
indx	long
;	O
}	O
if	O
(	O
!	O
skipping	int
)	O
{	O
bfd_coff_swap_lineno_out	O
(	O
output_bfd	pointer
,	O
&	O
iline	struct
,	O
oeline	pointer
)	O
;	O
oeline	pointer
+=	O
linesz	int
;	O
}	O
}	O
pos	long
=	O
o	pointer
->	O
output_section	pointer
->	O
line_filepos	long
;	O
pos	long
+=	O
o	pointer
->	O
output_section	pointer
->	O
lineno_count	int
*	O
linesz	int
;	O
amt	long
=	O
oeline	pointer
-	O
flaginfo	struct
->	O
linenos	pointer
;	O
if	O
(	O
bfd_seek	function
(	O
output_bfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bwrite	function
(	O
flaginfo	struct
->	O
linenos	pointer
,	O
amt	long
,	O
output_bfd	pointer
)	O
!=	O
amt	long
)	O
return	O
FALSE	int
;	O
o	pointer
->	O
output_section	pointer
->	O
lineno_count	int
+=	O
amt	long
/	O
linesz	int
;	O
}	O
}	O
if	O
(	O
flaginfo	struct
->	O
last_file_index	long
!=	O
-	O
1	int
&&	O
(	O
bfd_size_type	long
)	O
flaginfo	struct
->	O
last_file_index	long
>=	O
syment_base	long
)	O
{	O
flaginfo	struct
->	O
last_file	struct
.	O
n_value	long
=	O
output_index	long
;	O
bfd_coff_swap_sym_out	O
(	O
output_bfd	pointer
,	O
&	O
flaginfo	struct
->	O
last_file	struct
,	O
(	O
flaginfo	struct
->	O
outsyms	pointer
+	O
(	O
(	O
flaginfo	struct
->	O
last_file_index	long
-	O
syment_base	long
)	O
*	O
osymesz	long
)	O
)	O
)	O
;	O
}	O
if	O
(	O
outsym	pointer
>	O
flaginfo	struct
->	O
outsyms	pointer
)	O
{	O
file_ptr	long
pos	long
;	O
bfd_size_type	long
amt	long
;	O
pos	long
=	O
obj_sym_filepos	O
(	O
output_bfd	pointer
)	O
+	O
syment_base	long
*	O
osymesz	long
;	O
amt	long
=	O
outsym	pointer
-	O
flaginfo	struct
->	O
outsyms	pointer
;	O
if	O
(	O
bfd_seek	function
(	O
output_bfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bwrite	function
(	O
flaginfo	struct
->	O
outsyms	pointer
,	O
amt	long
,	O
output_bfd	pointer
)	O
!=	O
amt	long
)	O
return	O
FALSE	int
;	O
BFD_ASSERT	O
(	O
(	O
obj_raw_syment_count	O
(	O
output_bfd	pointer
)	O
+	O
(	O
outsym	pointer
-	O
flaginfo	struct
->	O
outsyms	pointer
)	O
/	O
osymesz	long
)	O
==	O
output_index	long
)	O
;	O
obj_raw_syment_count	O
(	O
output_bfd	pointer
)	O
=	O
output_index	long
;	O
}	O
adjust_symndx	pointer
=	O
coff_backend_info	O
(	O
input_bfd	pointer
)	O
->	O
_bfd_coff_adjust_symndx	pointer
;	O
for	O
(	O
o	pointer
=	O
input_bfd	pointer
->	O
sections	pointer
;	O
o	pointer
!=	O
NULL	O
;	O
o	pointer
=	O
o	pointer
->	O
next	pointer
)	O
{	O
bfd_byte	char
*	O
contents	pointer
;	O
struct	O
coff_section_tdata	struct
*	O
secdata	pointer
;	O
if	O
(	O
!	O
o	pointer
->	O
linker_mark	int
)	O
continue	O
;	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_LINKER_CREATED	int
)	O
!=	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_HAS_CONTENTS	int
)	O
==	O
0	int
||	O
(	O
o	pointer
->	O
size	long
==	O
0	int
&&	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
==	O
0	int
)	O
)	O
{	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
!=	O
0	int
&&	O
o	pointer
->	O
reloc_count	int
!=	O
0	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: relocs in section `%pA', but it has no contents"	pointer
)	O
,	O
input_bfd	pointer
,	O
o	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_no_contents	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
continue	O
;	O
}	O
secdata	pointer
=	O
coff_section_data	O
(	O
input_bfd	pointer
,	O
o	pointer
)	O
;	O
if	O
(	O
secdata	pointer
!=	O
NULL	O
&&	O
secdata	pointer
->	O
contents	pointer
!=	O
NULL	O
)	O
contents	pointer
=	O
secdata	pointer
->	O
contents	pointer
;	O
else	O
{	O
contents	pointer
=	O
flaginfo	struct
->	O
contents	pointer
;	O
if	O
(	O
!	O
bfd_get_full_section_contents	function
(	O
input_bfd	pointer
,	O
o	pointer
,	O
&	O
contents	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
(	O
o	pointer
->	O
flags	int
&	O
SEC_RELOC	int
)	O
!=	O
0	int
)	O
{	O
int	O
target_index	int
;	O
struct	O
internal_reloc	struct
*	O
internal_relocs	pointer
;	O
struct	O
internal_reloc	struct
*	O
irel	pointer
;	O
target_index	int
=	O
o	pointer
->	O
output_section	pointer
->	O
target_index	int
;	O
internal_relocs	pointer
=	O
(	O
_bfd_coff_read_internal_relocs	function
(	O
input_bfd	pointer
,	O
o	pointer
,	O
FALSE	int
,	O
flaginfo	struct
->	O
external_relocs	pointer
,	O
bfd_link_relocatable	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
,	O
(	O
bfd_link_relocatable	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
?	O
(	O
flaginfo	struct
->	O
section_info	pointer
[	O
target_index	int
]	O
.	O
relocs	pointer
+	O
o	pointer
->	O
output_section	pointer
->	O
reloc_count	int
)	O
:	O
flaginfo	struct
->	O
internal_relocs	pointer
)	O
)	O
)	O
;	O
if	O
(	O
internal_relocs	pointer
==	O
NULL	O
&&	O
o	pointer
->	O
reloc_count	int
>	O
0	int
)	O
return	O
FALSE	int
;	O
irel	pointer
=	O
internal_relocs	pointer
;	O
for	O
(	O
;	O
irel	pointer
<	O
&	O
internal_relocs	pointer
[	O
o	pointer
->	O
reloc_count	int
]	O
;	O
irel	pointer
++	O
)	O
{	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
;	O
asection	struct
*	O
ps	pointer
=	O
NULL	O
;	O
long	O
symndx	long
=	O
irel	pointer
->	O
r_symndx	long
;	O
if	O
(	O
symndx	long
<	O
0	int
)	O
continue	O
;	O
h	pointer
=	O
obj_coff_sym_hashes	O
(	O
input_bfd	pointer
)	O
[	O
symndx	long
]	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
continue	O
;	O
while	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_indirect	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
ps	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
if	O
(	O
ps	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
ps	pointer
->	O
flags	int
&	O
SEC_EXCLUDE	int
)	O
(	O
*	O
flaginfo	struct
->	O
info	pointer
->	O
callbacks	pointer
->	O
einfo	pointer
)	O
(	O
_	O
(	O
"%X`%s' referenced in section `%pA' of %pB: "	pointer
"defined in discarded section `%pA' of %pB\n"	pointer
)	O
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
o	pointer
,	O
input_bfd	pointer
,	O
ps	pointer
,	O
ps	pointer
->	O
owner	pointer
)	O
;	O
}	O
if	O
(	O
!	O
bfd_coff_relocate_section	O
(	O
output_bfd	pointer
,	O
flaginfo	struct
->	O
info	pointer
,	O
input_bfd	pointer
,	O
o	pointer
,	O
contents	pointer
,	O
internal_relocs	pointer
,	O
flaginfo	struct
->	O
internal_syms	pointer
,	O
flaginfo	struct
->	O
sec_ptrs	pointer
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
)	O
{	O
bfd_vma	long
offset	long
;	O
struct	O
internal_reloc	struct
*	O
irelend	pointer
;	O
struct	O
coff_link_hash_entry	struct
*	O
*	O
rel_hash	pointer
;	O
offset	long
=	O
o	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
o	pointer
->	O
output_offset	long
-	O
o	pointer
->	O
vma	long
;	O
irel	pointer
=	O
internal_relocs	pointer
;	O
irelend	pointer
=	O
irel	pointer
+	O
o	pointer
->	O
reloc_count	int
;	O
rel_hash	pointer
=	O
(	O
flaginfo	struct
->	O
section_info	pointer
[	O
target_index	int
]	O
.	O
rel_hashes	pointer
+	O
o	pointer
->	O
output_section	pointer
->	O
reloc_count	int
)	O
;	O
for	O
(	O
;	O
irel	pointer
<	O
irelend	pointer
;	O
irel	pointer
++	O
,	O
rel_hash	pointer
++	O
)	O
{	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
;	O
bfd_boolean	int
adjusted	int
;	O
*	O
rel_hash	pointer
=	O
NULL	O
;	O
irel	pointer
->	O
r_vaddr	long
+=	O
offset	long
;	O
if	O
(	O
irel	pointer
->	O
r_symndx	long
==	O
-	O
1	int
)	O
continue	O
;	O
if	O
(	O
adjust_symndx	pointer
)	O
{	O
if	O
(	O
!	O
(	O
*	O
adjust_symndx	pointer
)	O
(	O
output_bfd	pointer
,	O
flaginfo	struct
->	O
info	pointer
,	O
input_bfd	pointer
,	O
o	pointer
,	O
irel	pointer
,	O
&	O
adjusted	int
)	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
adjusted	int
)	O
continue	O
;	O
}	O
h	pointer
=	O
obj_coff_sym_hashes	O
(	O
input_bfd	pointer
)	O
[	O
irel	pointer
->	O
r_symndx	long
]	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
h	pointer
->	O
indx	long
>=	O
0	int
)	O
irel	pointer
->	O
r_symndx	long
=	O
h	pointer
->	O
indx	long
;	O
else	O
{	O
*	O
rel_hash	pointer
=	O
h	pointer
;	O
h	pointer
->	O
indx	long
=	O
-	O
2	int
;	O
}	O
}	O
else	O
{	O
long	O
indx	long
;	O
indx	long
=	O
flaginfo	struct
->	O
sym_indices	pointer
[	O
irel	pointer
->	O
r_symndx	long
]	O
;	O
if	O
(	O
indx	long
!=	O
-	O
1	int
)	O
irel	pointer
->	O
r_symndx	long
=	O
indx	long
;	O
else	O
{	O
struct	O
internal_syment	struct
*	O
is	struct
;	O
const	O
char	O
*	O
name	pointer
;	O
char	O
buf	pointer
[	O
SYMNMLEN	int
+	O
1	int
]	O
;	O
is	struct
=	O
flaginfo	struct
->	O
internal_syms	pointer
+	O
irel	pointer
->	O
r_symndx	long
;	O
name	pointer
=	O
(	O
_bfd_coff_internal_syment_name	function
(	O
input_bfd	pointer
,	O
is	struct
,	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
(	O
*	O
flaginfo	struct
->	O
info	pointer
->	O
callbacks	pointer
->	O
unattached_reloc	pointer
)	O
(	O
flaginfo	struct
->	O
info	pointer
,	O
name	pointer
,	O
input_bfd	pointer
,	O
o	pointer
,	O
irel	pointer
->	O
r_vaddr	long
)	O
;	O
}	O
}	O
}	O
o	pointer
->	O
output_section	pointer
->	O
reloc_count	int
+=	O
o	pointer
->	O
reloc_count	int
;	O
}	O
}	O
if	O
(	O
secdata	pointer
==	O
NULL	O
||	O
secdata	pointer
->	O
stab_info	struct
==	O
NULL	O
)	O
{	O
file_ptr	long
loc	pointer
=	O
(	O
o	pointer
->	O
output_offset	long
*	O
bfd_octets_per_byte	function
(	O
output_bfd	pointer
,	O
o	pointer
)	O
)	O
;	O
if	O
(	O
!	O
bfd_set_section_contents	function
(	O
output_bfd	pointer
,	O
o	pointer
->	O
output_section	pointer
,	O
contents	pointer
,	O
loc	pointer
,	O
o	pointer
->	O
size	long
)	O
)	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
(	O
_bfd_write_section_stabs	function
(	O
output_bfd	pointer
,	O
&	O
coff_hash_table	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
->	O
stab_info	struct
,	O
o	pointer
,	O
&	O
secdata	pointer
->	O
stab_info	struct
,	O
contents	pointer
)	O
)	O
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
!	O
flaginfo	struct
->	O
info	pointer
->	O
keep_memory	int
&&	O
!	O
_bfd_coff_free_symbols	function
(	O
input_bfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_coff_write_global_sym	function
(	O
struct	O
bfd_hash_entry	struct
*	O
bh	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
=	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
bh	pointer
;	O
struct	O
coff_final_link_info	struct
*	O
flaginfo	struct
=	O
(	O
struct	O
coff_final_link_info	struct
*	O
)	O
data	pointer
;	O
bfd	struct
*	O
output_bfd	pointer
;	O
struct	O
internal_syment	struct
isym	pointer
;	O
bfd_size_type	long
symesz	long
;	O
unsigned	O
int	O
i	pointer
;	O
file_ptr	long
pos	long
;	O
output_bfd	pointer
=	O
flaginfo	struct
->	O
output_bfd	pointer
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
{	O
h	pointer
=	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_new	int
)	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
h	pointer
->	O
indx	long
>=	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
h	pointer
->	O
indx	long
!=	O
-	O
2	int
&&	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
strip	enum
==	O
strip_all	int
||	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
strip	enum
==	O
strip_some	int
&&	O
(	O
bfd_hash_lookup	function
(	O
flaginfo	struct
->	O
info	pointer
->	O
keep_hash	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
FALSE	int
,	O
FALSE	int
)	O
==	O
NULL	O
)	O
)	O
)	O
)	O
return	O
TRUE	int
;	O
switch	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
)	O
{	O
default	O
:	O
case	O
bfd_link_hash_new	int
:	O
case	O
bfd_link_hash_warning	int
:	O
abort	function
(	O
)	O
;	O
return	O
FALSE	int
;	O
case	O
bfd_link_hash_undefined	int
:	O
case	O
bfd_link_hash_undefweak	int
:	O
isym	pointer
.	O
n_scnum	int
=	O
N_UNDEF	O
;	O
isym	pointer
.	O
n_value	long
=	O
0	int
;	O
break	O
;	O
case	O
bfd_link_hash_defined	int
:	O
case	O
bfd_link_hash_defweak	int
:	O
{	O
asection	struct
*	O
sec	pointer
;	O
sec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
sec	pointer
)	O
)	O
isym	pointer
.	O
n_scnum	int
=	O
N_ABS	O
;	O
else	O
isym	pointer
.	O
n_scnum	int
=	O
sec	pointer
->	O
target_index	int
;	O
isym	pointer
.	O
n_value	long
=	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_offset	long
)	O
;	O
if	O
(	O
!	O
obj_pe	O
(	O
flaginfo	struct
->	O
output_bfd	pointer
)	O
)	O
isym	pointer
.	O
n_value	long
+=	O
sec	pointer
->	O
vma	long
;	O
}	O
break	O
;	O
case	O
bfd_link_hash_common	int
:	O
isym	pointer
.	O
n_scnum	int
=	O
N_UNDEF	O
;	O
isym	pointer
.	O
n_value	long
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
c	struct
.	O
size	long
;	O
break	O
;	O
case	O
bfd_link_hash_indirect	int
:	O
return	O
TRUE	int
;	O
}	O
if	O
(	O
strlen	function
(	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
)	O
<=	O
SYMNMLEN	int
)	O
strncpy	function
(	O
isym	pointer
.	O
_n	union
.	O
_n_name	array
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
SYMNMLEN	int
)	O
;	O
else	O
{	O
bfd_boolean	int
hash	long
;	O
bfd_size_type	long
indx	long
;	O
hash	long
=	O
TRUE	int
;	O
if	O
(	O
flaginfo	struct
->	O
info	pointer
->	O
traditional_format	int
)	O
hash	long
=	O
FALSE	int
;	O
indx	long
=	O
_bfd_stringtab_add	function
(	O
flaginfo	struct
->	O
strtab	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
hash	long
,	O
FALSE	int
)	O
;	O
if	O
(	O
indx	long
==	O
(	O
bfd_size_type	long
)	O
-	O
1	int
)	O
{	O
flaginfo	struct
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
isym	pointer
.	O
_n	union
.	O
_n_n	struct
.	O
_n_zeroes	long
=	O
0	int
;	O
isym	pointer
.	O
_n	union
.	O
_n_n	struct
.	O
_n_offset	long
=	O
STRING_SIZE_SIZE	int
+	O
indx	long
;	O
}	O
isym	pointer
.	O
n_sclass	char
=	O
h	pointer
->	O
symbol_class	char
;	O
isym	pointer
.	O
n_type	short
=	O
h	pointer
->	O
type	enum
;	O
if	O
(	O
isym	pointer
.	O
n_sclass	char
==	O
C_NULL	int
)	O
isym	pointer
.	O
n_sclass	char
=	O
C_EXT	int
;	O
if	O
(	O
flaginfo	struct
->	O
global_to_static	int
)	O
{	O
if	O
(	O
!	O
IS_EXTERNAL	O
(	O
output_bfd	pointer
,	O
isym	pointer
)	O
)	O
return	O
TRUE	int
;	O
isym	pointer
.	O
n_sclass	char
=	O
C_STAT	int
;	O
}	O
if	O
(	O
!	O
bfd_link_pic	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
&&	O
!	O
bfd_link_relocatable	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
&&	O
IS_WEAK_EXTERNAL	O
(	O
flaginfo	struct
->	O
output_bfd	pointer
,	O
isym	pointer
)	O
)	O
isym	pointer
.	O
n_sclass	char
=	O
C_EXT	int
;	O
isym	pointer
.	O
n_numaux	char
=	O
h	pointer
->	O
numaux	char
;	O
bfd_coff_swap_sym_out	O
(	O
output_bfd	pointer
,	O
&	O
isym	pointer
,	O
flaginfo	struct
->	O
outsyms	pointer
)	O
;	O
symesz	long
=	O
bfd_coff_symesz	O
(	O
output_bfd	pointer
)	O
;	O
pos	long
=	O
obj_sym_filepos	O
(	O
output_bfd	pointer
)	O
;	O
pos	long
+=	O
obj_raw_syment_count	O
(	O
output_bfd	pointer
)	O
*	O
symesz	long
;	O
if	O
(	O
bfd_seek	function
(	O
output_bfd	pointer
,	O
pos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bwrite	function
(	O
flaginfo	struct
->	O
outsyms	pointer
,	O
symesz	long
,	O
output_bfd	pointer
)	O
!=	O
symesz	long
)	O
{	O
flaginfo	struct
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
h	pointer
->	O
indx	long
=	O
obj_raw_syment_count	O
(	O
output_bfd	pointer
)	O
;	O
++	O
obj_raw_syment_count	O
(	O
output_bfd	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
isym	pointer
.	O
n_numaux	char
;	O
i	pointer
++	O
)	O
{	O
union	O
internal_auxent	union
*	O
auxp	pointer
;	O
auxp	pointer
=	O
h	pointer
->	O
aux	pointer
+	O
i	pointer
;	O
if	O
(	O
i	pointer
==	O
0	int
&&	O
(	O
isym	pointer
.	O
n_sclass	char
==	O
C_STAT	int
||	O
isym	pointer
.	O
n_sclass	char
==	O
C_HIDDEN	int
)	O
&&	O
isym	pointer
.	O
n_type	short
==	O
T_NULL	int
&&	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
)	O
{	O
asection	struct
*	O
sec	pointer
;	O
sec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
->	O
output_section	pointer
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
)	O
{	O
auxp	pointer
->	O
x_scn	struct
.	O
x_scnlen	long
=	O
sec	pointer
->	O
size	long
;	O
if	O
(	O
sec	pointer
->	O
reloc_count	int
>	O
0xffff	int
&&	O
(	O
!	O
obj_pe	O
(	O
output_bfd	pointer
)	O
||	O
bfd_link_relocatable	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
)	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: %pA: reloc overflow: %#x > 0xffff"	pointer
)	O
,	O
output_bfd	pointer
,	O
sec	pointer
,	O
sec	pointer
->	O
reloc_count	int
)	O
;	O
if	O
(	O
sec	pointer
->	O
lineno_count	int
>	O
0xffff	int
&&	O
(	O
!	O
obj_pe	O
(	O
output_bfd	pointer
)	O
||	O
bfd_link_relocatable	O
(	O
flaginfo	struct
->	O
info	pointer
)	O
)	O
)	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: warning: %pA: line number overflow: %#x > 0xffff"	pointer
)	O
,	O
output_bfd	pointer
,	O
sec	pointer
,	O
sec	pointer
->	O
lineno_count	int
)	O
;	O
auxp	pointer
->	O
x_scn	struct
.	O
x_nreloc	short
=	O
sec	pointer
->	O
reloc_count	int
;	O
auxp	pointer
->	O
x_scn	struct
.	O
x_nlinno	short
=	O
sec	pointer
->	O
lineno_count	int
;	O
auxp	pointer
->	O
x_scn	struct
.	O
x_checksum	long
=	O
0	int
;	O
auxp	pointer
->	O
x_scn	struct
.	O
x_associated	short
=	O
0	int
;	O
auxp	pointer
->	O
x_scn	struct
.	O
x_comdat	char
=	O
0	int
;	O
}	O
}	O
bfd_coff_swap_aux_out	O
(	O
output_bfd	pointer
,	O
auxp	pointer
,	O
isym	pointer
.	O
n_type	short
,	O
isym	pointer
.	O
n_sclass	char
,	O
(	O
int	O
)	O
i	pointer
,	O
isym	pointer
.	O
n_numaux	char
,	O
flaginfo	struct
->	O
outsyms	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
flaginfo	struct
->	O
outsyms	pointer
,	O
symesz	long
,	O
output_bfd	pointer
)	O
!=	O
symesz	long
)	O
{	O
flaginfo	struct
->	O
failed	int
=	O
TRUE	int
;	O
return	O
FALSE	int
;	O
}	O
++	O
obj_raw_syment_count	O
(	O
output_bfd	pointer
)	O
;	O
}	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_coff_write_task_globals	function
(	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
coff_final_link_info	struct
*	O
flaginfo	struct
=	O
(	O
struct	O
coff_final_link_info	struct
*	O
)	O
data	pointer
;	O
bfd_boolean	int
rtnval	int
=	O
TRUE	int
;	O
bfd_boolean	int
save_global_to_static	int
;	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_warning	int
)	O
h	pointer
=	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
i	pointer
.	O
link	function
;	O
if	O
(	O
h	pointer
->	O
indx	long
<	O
0	int
)	O
{	O
switch	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
)	O
{	O
case	O
bfd_link_hash_defined	int
:	O
case	O
bfd_link_hash_defweak	int
:	O
save_global_to_static	int
=	O
flaginfo	struct
->	O
global_to_static	int
;	O
flaginfo	struct
->	O
global_to_static	int
=	O
TRUE	int
;	O
rtnval	int
=	O
_bfd_coff_write_global_sym	function
(	O
&	O
h	pointer
->	O
root	struct
.	O
root	struct
,	O
data	pointer
)	O
;	O
flaginfo	struct
->	O
global_to_static	int
=	O
save_global_to_static	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
return	O
(	O
rtnval	int
)	O
;	O
}	O
bfd_boolean	int
_bfd_coff_reloc_link_order	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
coff_final_link_info	struct
*	O
flaginfo	struct
,	O
asection	struct
*	O
output_section	pointer
,	O
struct	O
bfd_link_order	struct
*	O
link_order	pointer
)	O
{	O
reloc_howto_type	struct
*	O
howto	pointer
;	O
struct	O
internal_reloc	struct
*	O
irel	pointer
;	O
struct	O
coff_link_hash_entry	struct
*	O
*	O
rel_hash_ptr	pointer
;	O
howto	pointer
=	O
bfd_reloc_type_lookup	function
(	O
output_bfd	pointer
,	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
reloc	enum
)	O
;	O
if	O
(	O
howto	pointer
==	O
NULL	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
addend	long
!=	O
0	int
)	O
{	O
bfd_size_type	long
size	long
;	O
bfd_byte	char
*	O
buf	pointer
;	O
bfd_reloc_status_type	enum
rstat	enum
;	O
bfd_boolean	int
ok	int
;	O
file_ptr	long
loc	pointer
;	O
size	long
=	O
bfd_get_reloc_size	function
(	O
howto	pointer
)	O
;	O
buf	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_zmalloc	function
(	O
size	long
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
&&	O
size	long
!=	O
0	int
)	O
return	O
FALSE	int
;	O
rstat	enum
=	O
_bfd_relocate_contents	function
(	O
howto	pointer
,	O
output_bfd	pointer
,	O
(	O
bfd_vma	long
)	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
addend	long
,	O
buf	pointer
)	O
;	O
switch	O
(	O
rstat	enum
)	O
{	O
case	O
bfd_reloc_ok	int
:	O
break	O
;	O
default	O
:	O
case	O
bfd_reloc_outofrange	int
:	O
abort	function
(	O
)	O
;	O
case	O
bfd_reloc_overflow	int
:	O
(	O
*	O
flaginfo	struct
->	O
info	pointer
->	O
callbacks	pointer
->	O
reloc_overflow	pointer
)	O
(	O
flaginfo	struct
->	O
info	pointer
,	O
NULL	O
,	O
(	O
link_order	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
?	O
bfd_section_name	function
(	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
section	pointer
)	O
:	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
name	pointer
)	O
,	O
howto	pointer
->	O
name	pointer
,	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
addend	long
,	O
(	O
bfd	struct
*	O
)	O
NULL	O
,	O
(	O
asection	struct
*	O
)	O
NULL	O
,	O
(	O
bfd_vma	long
)	O
0	int
)	O
;	O
break	O
;	O
}	O
loc	pointer
=	O
link_order	pointer
->	O
offset	long
*	O
bfd_octets_per_byte	function
(	O
output_bfd	pointer
,	O
output_section	pointer
)	O
;	O
ok	int
=	O
bfd_set_section_contents	function
(	O
output_bfd	pointer
,	O
output_section	pointer
,	O
buf	pointer
,	O
loc	pointer
,	O
size	long
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
ok	int
)	O
return	O
FALSE	int
;	O
}	O
irel	pointer
=	O
(	O
flaginfo	struct
->	O
section_info	pointer
[	O
output_section	pointer
->	O
target_index	int
]	O
.	O
relocs	pointer
+	O
output_section	pointer
->	O
reloc_count	int
)	O
;	O
rel_hash_ptr	pointer
=	O
(	O
flaginfo	struct
->	O
section_info	pointer
[	O
output_section	pointer
->	O
target_index	int
]	O
.	O
rel_hashes	pointer
+	O
output_section	pointer
->	O
reloc_count	int
)	O
;	O
memset	function
(	O
irel	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
internal_reloc	struct
)	O
)	O
;	O
*	O
rel_hash_ptr	pointer
=	O
NULL	O
;	O
irel	pointer
->	O
r_vaddr	long
=	O
output_section	pointer
->	O
vma	long
+	O
link_order	pointer
->	O
offset	long
;	O
if	O
(	O
link_order	pointer
->	O
type	enum
==	O
bfd_section_reloc_link_order	int
)	O
{	O
abort	function
(	O
)	O
;	O
*	O
rel_hash_ptr	pointer
=	O
NULL	O
;	O
irel	pointer
->	O
r_symndx	long
=	O
0	int
;	O
}	O
else	O
{	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
;	O
h	pointer
=	O
(	O
(	O
struct	O
coff_link_hash_entry	struct
*	O
)	O
bfd_wrapped_link_hash_lookup	function
(	O
output_bfd	pointer
,	O
flaginfo	struct
->	O
info	pointer
,	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
name	pointer
,	O
FALSE	int
,	O
FALSE	int
,	O
TRUE	int
)	O
)	O
;	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
h	pointer
->	O
indx	long
>=	O
0	int
)	O
irel	pointer
->	O
r_symndx	long
=	O
h	pointer
->	O
indx	long
;	O
else	O
{	O
h	pointer
->	O
indx	long
=	O
-	O
2	int
;	O
*	O
rel_hash_ptr	pointer
=	O
h	pointer
;	O
irel	pointer
->	O
r_symndx	long
=	O
0	int
;	O
}	O
}	O
else	O
{	O
(	O
*	O
flaginfo	struct
->	O
info	pointer
->	O
callbacks	pointer
->	O
unattached_reloc	pointer
)	O
(	O
flaginfo	struct
->	O
info	pointer
,	O
link_order	pointer
->	O
u	union
.	O
reloc	enum
.	O
p	pointer
->	O
u	union
.	O
name	pointer
,	O
(	O
bfd	struct
*	O
)	O
NULL	O
,	O
(	O
asection	struct
*	O
)	O
NULL	O
,	O
(	O
bfd_vma	long
)	O
0	int
)	O
;	O
irel	pointer
->	O
r_symndx	long
=	O
0	int
;	O
}	O
}	O
irel	pointer
->	O
r_type	int
=	O
howto	pointer
->	O
type	enum
;	O
++	O
output_section	pointer
->	O
reloc_count	int
;	O
return	O
TRUE	int
;	O
}	O
bfd_boolean	int
_bfd_coff_generic_relocate_section	function
(	O
bfd	struct
*	O
output_bfd	pointer
,	O
struct	O
bfd_link_info	struct
*	O
info	pointer
,	O
bfd	struct
*	O
input_bfd	pointer
,	O
asection	struct
*	O
input_section	pointer
,	O
bfd_byte	char
*	O
contents	pointer
,	O
struct	O
internal_reloc	struct
*	O
relocs	pointer
,	O
struct	O
internal_syment	struct
*	O
syms	pointer
,	O
asection	struct
*	O
*	O
sections	pointer
)	O
{	O
struct	O
internal_reloc	struct
*	O
rel	pointer
;	O
struct	O
internal_reloc	struct
*	O
relend	pointer
;	O
rel	pointer
=	O
relocs	pointer
;	O
relend	pointer
=	O
rel	pointer
+	O
input_section	pointer
->	O
reloc_count	int
;	O
for	O
(	O
;	O
rel	pointer
<	O
relend	pointer
;	O
rel	pointer
++	O
)	O
{	O
long	O
symndx	long
;	O
struct	O
coff_link_hash_entry	struct
*	O
h	pointer
;	O
struct	O
internal_syment	struct
*	O
sym	pointer
;	O
bfd_vma	long
addend	long
;	O
bfd_vma	long
val	array
;	O
asection	struct
*	O
sec	pointer
;	O
reloc_howto_type	struct
*	O
howto	pointer
;	O
bfd_reloc_status_type	enum
rstat	enum
;	O
symndx	long
=	O
rel	pointer
->	O
r_symndx	long
;	O
if	O
(	O
symndx	long
==	O
-	O
1	int
)	O
{	O
h	pointer
=	O
NULL	O
;	O
sym	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
symndx	long
<	O
0	int
||	O
(	O
unsigned	O
long	O
)	O
symndx	long
>=	O
obj_raw_syment_count	O
(	O
input_bfd	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: illegal symbol index %ld in relocs"	pointer
)	O
,	O
input_bfd	pointer
,	O
symndx	long
)	O
;	O
return	O
FALSE	int
;	O
}	O
else	O
{	O
h	pointer
=	O
obj_coff_sym_hashes	O
(	O
input_bfd	pointer
)	O
[	O
symndx	long
]	O
;	O
sym	pointer
=	O
syms	pointer
+	O
symndx	long
;	O
}	O
if	O
(	O
sym	pointer
!=	O
NULL	O
&&	O
sym	pointer
->	O
n_scnum	int
!=	O
0	int
)	O
addend	long
=	O
-	O
sym	pointer
->	O
n_value	long
;	O
else	O
addend	long
=	O
0	int
;	O
howto	pointer
=	O
bfd_coff_rtype_to_howto	O
(	O
input_bfd	pointer
,	O
input_section	pointer
,	O
rel	pointer
,	O
h	pointer
,	O
sym	pointer
,	O
&	O
addend	long
)	O
;	O
if	O
(	O
howto	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
howto	pointer
->	O
pc_relative	int
&&	O
howto	pointer
->	O
pcrel_offset	int
)	O
{	O
if	O
(	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
sym	pointer
!=	O
NULL	O
&&	O
sym	pointer
->	O
n_scnum	int
!=	O
0	int
)	O
addend	long
+=	O
sym	pointer
->	O
n_value	long
;	O
}	O
val	array
=	O
0	int
;	O
sec	pointer
=	O
NULL	O
;	O
if	O
(	O
h	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
symndx	long
==	O
-	O
1	int
)	O
{	O
sec	pointer
=	O
bfd_abs_section_ptr	O
;	O
val	array
=	O
0	int
;	O
}	O
else	O
{	O
sec	pointer
=	O
sections	pointer
[	O
symndx	long
]	O
;	O
if	O
(	O
bfd_is_abs_section	function
(	O
sec	pointer
)	O
)	O
continue	O
;	O
val	array
=	O
(	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
+	O
sym	pointer
->	O
n_value	long
)	O
;	O
if	O
(	O
!	O
obj_pe	O
(	O
input_bfd	pointer
)	O
)	O
val	array
-=	O
sec	pointer
->	O
vma	long
;	O
}	O
}	O
else	O
{	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defined	int
||	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_defweak	int
)	O
{	O
sec	pointer
=	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
val	array
=	O
(	O
h	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
)	O
;	O
}	O
else	O
if	O
(	O
h	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefweak	int
)	O
{	O
if	O
(	O
h	pointer
->	O
symbol_class	char
==	O
C_NT_WEAK	int
&&	O
h	pointer
->	O
numaux	char
==	O
1	int
)	O
{	O
struct	O
coff_link_hash_entry	struct
*	O
h2	pointer
=	O
h	pointer
->	O
auxbfd	pointer
->	O
tdata	union
.	O
coff_obj_data	pointer
->	O
sym_hashes	pointer
[	O
h	pointer
->	O
aux	pointer
->	O
x_sym	struct
.	O
x_tagndx	union
.	O
l	long
]	O
;	O
if	O
(	O
!	O
h2	pointer
||	O
h2	pointer
->	O
root	struct
.	O
type	enum
==	O
bfd_link_hash_undefined	int
)	O
{	O
sec	pointer
=	O
bfd_abs_section_ptr	O
;	O
val	array
=	O
0	int
;	O
}	O
else	O
{	O
sec	pointer
=	O
h2	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
section	pointer
;	O
val	array
=	O
h2	pointer
->	O
root	struct
.	O
u	union
.	O
def	struct
.	O
value	long
+	O
sec	pointer
->	O
output_section	pointer
->	O
vma	long
+	O
sec	pointer
->	O
output_offset	long
;	O
}	O
}	O
else	O
val	array
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
bfd_link_relocatable	O
(	O
info	pointer
)	O
)	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
undefined_symbol	pointer
)	O
(	O
info	pointer
,	O
h	pointer
->	O
root	struct
.	O
root	struct
.	O
string	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
rel	pointer
->	O
r_vaddr	long
-	O
input_section	pointer
->	O
vma	long
,	O
TRUE	int
)	O
;	O
}	O
if	O
(	O
sec	pointer
!=	O
NULL	O
&&	O
discarded_section	function
(	O
sec	pointer
)	O
)	O
{	O
_bfd_clear_contents	function
(	O
howto	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
contents	pointer
,	O
rel	pointer
->	O
r_vaddr	long
-	O
input_section	pointer
->	O
vma	long
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
info	pointer
->	O
base_file	pointer
)	O
{	O
if	O
(	O
sym	pointer
&&	O
pe_data	O
(	O
output_bfd	pointer
)	O
->	O
in_reloc_p	pointer
(	O
output_bfd	pointer
,	O
howto	pointer
)	O
)	O
{	O
bfd_vma	long
addr	pointer
=	O
(	O
rel	pointer
->	O
r_vaddr	long
-	O
input_section	pointer
->	O
vma	long
+	O
input_section	pointer
->	O
output_offset	long
+	O
input_section	pointer
->	O
output_section	pointer
->	O
vma	long
)	O
;	O
if	O
(	O
coff_data	O
(	O
output_bfd	pointer
)	O
->	O
pe	struct
)	O
addr	pointer
-=	O
pe_data	O
(	O
output_bfd	pointer
)	O
->	O
pe_opthdr	struct
.	O
ImageBase	long
;	O
if	O
(	O
fwrite	function
(	O
&	O
addr	pointer
,	O
1	int
,	O
sizeof	O
(	O
bfd_vma	long
)	O
,	O
(	O
FILE	struct
*	O
)	O
info	pointer
->	O
base_file	pointer
)	O
!=	O
sizeof	O
(	O
bfd_vma	long
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_system_call	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
}	O
}	O
rstat	enum
=	O
_bfd_final_link_relocate	function
(	O
howto	pointer
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
contents	pointer
,	O
rel	pointer
->	O
r_vaddr	long
-	O
input_section	pointer
->	O
vma	long
,	O
val	array
,	O
addend	long
)	O
;	O
switch	O
(	O
rstat	enum
)	O
{	O
default	O
:	O
abort	function
(	O
)	O
;	O
case	O
bfd_reloc_ok	int
:	O
break	O
;	O
case	O
bfd_reloc_outofrange	int
:	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB: bad reloc address %#"	pointer
PRIx64	O
" in section `%pA'"	pointer
)	O
,	O
input_bfd	pointer
,	O
(	O
uint64_t	long
)	O
rel	pointer
->	O
r_vaddr	long
,	O
input_section	pointer
)	O
;	O
return	O
FALSE	int
;	O
case	O
bfd_reloc_overflow	int
:	O
{	O
const	O
char	O
*	O
name	pointer
;	O
char	O
buf	pointer
[	O
SYMNMLEN	int
+	O
1	int
]	O
;	O
if	O
(	O
symndx	long
==	O
-	O
1	int
)	O
name	pointer
=	O
"*ABS*"	pointer
;	O
else	O
if	O
(	O
h	pointer
!=	O
NULL	O
)	O
name	pointer
=	O
NULL	O
;	O
else	O
{	O
name	pointer
=	O
_bfd_coff_internal_syment_name	function
(	O
input_bfd	pointer
,	O
sym	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
name	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
}	O
(	O
*	O
info	pointer
->	O
callbacks	pointer
->	O
reloc_overflow	pointer
)	O
(	O
info	pointer
,	O
(	O
h	pointer
?	O
&	O
h	pointer
->	O
root	struct
:	O
NULL	O
)	O
,	O
name	pointer
,	O
howto	pointer
->	O
name	pointer
,	O
(	O
bfd_vma	long
)	O
0	int
,	O
input_bfd	pointer
,	O
input_section	pointer
,	O
rel	pointer
->	O
r_vaddr	long
-	O
input_section	pointer
->	O
vma	long
)	O
;	O
}	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
