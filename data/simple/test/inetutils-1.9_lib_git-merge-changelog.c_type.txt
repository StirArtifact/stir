struct	O
entry	struct
{	O
char	O
*	O
string	pointer
;	O
size_t	long
length	pointer
;	O
bool	bool
hashcode_cached	bool
;	O
size_t	long
hashcode	long
;	O
}	O
;	O
static	O
struct	O
entry	struct
*	O
entry_create	function
(	O
char	O
*	O
string	pointer
,	O
size_t	long
length	pointer
)	O
{	O
struct	O
entry	struct
*	O
result	pointer
=	O
XMALLOC	O
(	O
struct	O
entry	struct
)	O
;	O
result	pointer
->	O
string	pointer
=	O
string	pointer
;	O
result	pointer
->	O
length	pointer
=	O
length	pointer
;	O
result	pointer
->	O
hashcode_cached	bool
=	O
false	int
;	O
return	O
result	pointer
;	O
}	O
static	O
bool	bool
entry_equals	function
(	O
const	O
void	O
*	O
elt1	pointer
,	O
const	O
void	O
*	O
elt2	pointer
)	O
{	O
const	O
struct	O
entry	struct
*	O
entry1	pointer
=	O
(	O
const	O
struct	O
entry	struct
*	O
)	O
elt1	pointer
;	O
const	O
struct	O
entry	struct
*	O
entry2	pointer
=	O
(	O
const	O
struct	O
entry	struct
*	O
)	O
elt2	pointer
;	O
return	O
entry1	pointer
->	O
length	pointer
==	O
entry2	pointer
->	O
length	pointer
&&	O
memcmp	function
(	O
entry1	pointer
->	O
string	pointer
,	O
entry2	pointer
->	O
string	pointer
,	O
entry1	pointer
->	O
length	pointer
)	O
==	O
0	int
;	O
}	O
static	O
size_t	long
entry_hashcode	function
(	O
const	O
void	O
*	O
elt	pointer
)	O
{	O
struct	O
entry	struct
*	O
entry	struct
=	O
(	O
struct	O
entry	struct
*	O
)	O
elt	pointer
;	O
if	O
(	O
!	O
entry	struct
->	O
hashcode_cached	bool
)	O
{	O
const	O
char	O
*	O
s	long
;	O
size_t	long
n	long
;	O
size_t	long
h	long
=	O
0	int
;	O
for	O
(	O
s	long
=	O
entry	struct
->	O
string	pointer
,	O
n	long
=	O
entry	struct
->	O
length	pointer
;	O
n	long
>	O
0	int
;	O
s	long
++	O
,	O
n	long
--	O
)	O
h	long
=	O
(	O
unsigned	O
char	O
)	O
*	O
s	long
+	O
(	O
(	O
h	long
<<	O
9	int
)	O
|	O
(	O
h	long
>>	O
(	O
sizeof	O
(	O
size_t	long
)	O
*	O
CHAR_BIT	O
-	O
9	int
)	O
)	O
)	O
;	O
entry	struct
->	O
hashcode	long
=	O
h	long
;	O
entry	struct
->	O
hashcode_cached	bool
=	O
true	int
;	O
}	O
return	O
entry	struct
->	O
hashcode	long
;	O
}	O
static	O
double	O
entry_fstrcmp	function
(	O
const	O
struct	O
entry	struct
*	O
entry1	pointer
,	O
const	O
struct	O
entry	struct
*	O
entry2	pointer
,	O
double	O
lower_bound	double
)	O
{	O
char	O
*	O
memory	pointer
;	O
double	O
similarity	double
;	O
if	O
(	O
memchr	function
(	O
entry1	pointer
->	O
string	pointer
,	O
'\0'	O
,	O
entry1	pointer
->	O
length	pointer
)	O
!=	O
NULL	O
)	O
return	O
0.0	int
;	O
if	O
(	O
memchr	function
(	O
entry2	pointer
->	O
string	pointer
,	O
'\0'	O
,	O
entry2	pointer
->	O
length	pointer
)	O
!=	O
NULL	O
)	O
return	O
0.0	int
;	O
memory	pointer
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
entry1	pointer
->	O
length	pointer
+	O
1	int
+	O
entry2	pointer
->	O
length	pointer
+	O
1	int
)	O
;	O
{	O
char	O
*	O
p	pointer
=	O
memory	pointer
;	O
memcpy	function
(	O
p	pointer
,	O
entry1	pointer
->	O
string	pointer
,	O
entry1	pointer
->	O
length	pointer
)	O
;	O
p	pointer
+=	O
entry1	pointer
->	O
length	pointer
;	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
memcpy	function
(	O
p	pointer
,	O
entry2	pointer
->	O
string	pointer
,	O
entry2	pointer
->	O
length	pointer
)	O
;	O
p	pointer
+=	O
entry2	pointer
->	O
length	pointer
;	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
}	O
similarity	double
=	O
fstrcmp_bounded	function
(	O
memory	pointer
,	O
memory	pointer
+	O
entry1	pointer
->	O
length	pointer
+	O
1	int
,	O
lower_bound	double
)	O
;	O
freea	function
(	O
memory	pointer
)	O
;	O
return	O
similarity	double
;	O
}	O
struct	O
changelog_file	struct
{	O
gl_list_t	pointer
entries_list	pointer
;	O
gl_list_t	pointer
entries_reversed	pointer
;	O
size_t	long
num_entries	long
;	O
struct	O
entry	struct
*	O
*	O
entries	pointer
;	O
}	O
;	O
static	O
void	O
read_changelog_file	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
struct	O
changelog_file	struct
*	O
result	pointer
)	O
{	O
size_t	long
length	pointer
;	O
char	O
*	O
contents	pointer
=	O
read_file	function
(	O
filename	pointer
,	O
&	O
length	pointer
)	O
;	O
if	O
(	O
contents	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"could not read file '%s'\n"	pointer
,	O
filename	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
result	pointer
->	O
entries_list	pointer
=	O
gl_list_create_empty	function
(	O
GL_LINKEDHASH_LIST	O
,	O
entry_equals	function
,	O
entry_hashcode	function
,	O
NULL	O
,	O
true	int
)	O
;	O
result	pointer
->	O
entries_reversed	pointer
=	O
gl_list_create_empty	function
(	O
GL_RBTREEHASH_LIST	O
,	O
entry_equals	function
,	O
entry_hashcode	function
,	O
NULL	O
,	O
true	int
)	O
;	O
{	O
char	O
*	O
contents_end	pointer
=	O
contents	pointer
+	O
length	pointer
;	O
char	O
*	O
start	pointer
=	O
contents	pointer
;	O
while	O
(	O
start	pointer
<	O
contents_end	pointer
)	O
{	O
char	O
*	O
ptr	pointer
=	O
start	pointer
;	O
struct	O
entry	struct
*	O
curr	pointer
;	O
while	O
(	O
ptr	pointer
<	O
contents_end	pointer
)	O
{	O
ptr	pointer
=	O
memchr	function
(	O
ptr	pointer
,	O
'\n'	O
,	O
contents_end	pointer
-	O
ptr	pointer
)	O
;	O
if	O
(	O
ptr	pointer
==	O
NULL	O
)	O
{	O
ptr	pointer
=	O
contents_end	pointer
;	O
break	O
;	O
}	O
ptr	pointer
++	O
;	O
if	O
(	O
contents_end	pointer
-	O
ptr	pointer
>=	O
2	int
&&	O
ptr	pointer
[	O
0	int
]	O
==	O
'\n'	O
&&	O
!	O
(	O
ptr	pointer
[	O
1	int
]	O
==	O
'\n'	O
||	O
ptr	pointer
[	O
1	int
]	O
==	O
'\t'	O
||	O
ptr	pointer
[	O
1	int
]	O
==	O
' '	O
)	O
)	O
{	O
ptr	pointer
++	O
;	O
break	O
;	O
}	O
}	O
curr	pointer
=	O
entry_create	function
(	O
start	pointer
,	O
ptr	pointer
-	O
start	pointer
)	O
;	O
gl_list_add_last	function
(	O
result	pointer
->	O
entries_list	pointer
,	O
curr	pointer
)	O
;	O
gl_list_add_first	function
(	O
result	pointer
->	O
entries_reversed	pointer
,	O
curr	pointer
)	O
;	O
start	pointer
=	O
ptr	pointer
;	O
}	O
}	O
result	pointer
->	O
num_entries	long
=	O
gl_list_size	function
(	O
result	pointer
->	O
entries_list	pointer
)	O
;	O
result	pointer
->	O
entries	pointer
=	O
XNMALLOC	O
(	O
result	pointer
->	O
num_entries	long
,	O
struct	O
entry	struct
*	O
)	O
;	O
{	O
size_t	long
index	function
=	O
0	int
;	O
gl_list_iterator_t	struct
iter	struct
=	O
gl_list_iterator	function
(	O
result	pointer
->	O
entries_list	pointer
)	O
;	O
const	O
void	O
*	O
elt	pointer
;	O
gl_list_node_t	pointer
node	pointer
;	O
while	O
(	O
gl_list_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
elt	pointer
,	O
&	O
node	pointer
)	O
)	O
result	pointer
->	O
entries	pointer
[	O
index	function
++	O
]	O
=	O
(	O
struct	O
entry	struct
*	O
)	O
elt	pointer
;	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
ASSERT	O
(	O
index	function
==	O
result	pointer
->	O
num_entries	long
)	O
;	O
}	O
}	O
struct	O
entries_mapping	struct
{	O
struct	O
changelog_file	struct
*	O
file1	pointer
;	O
struct	O
changelog_file	struct
*	O
file2	pointer
;	O
ssize_t	long
*	O
index_mapping	pointer
;	O
ssize_t	long
*	O
index_mapping_reverse	pointer
;	O
}	O
;	O
static	O
ssize_t	long
entries_mapping_get	function
(	O
struct	O
entries_mapping	struct
*	O
mapping	pointer
,	O
ssize_t	long
i	long
)	O
{	O
if	O
(	O
mapping	pointer
->	O
index_mapping	pointer
[	O
i	long
]	O
<	O
-	O
1	int
)	O
{	O
struct	O
changelog_file	struct
*	O
file1	pointer
=	O
mapping	pointer
->	O
file1	pointer
;	O
struct	O
changelog_file	struct
*	O
file2	pointer
=	O
mapping	pointer
->	O
file2	pointer
;	O
size_t	long
n1	long
=	O
file1	pointer
->	O
num_entries	long
;	O
size_t	long
n2	long
=	O
file2	pointer
->	O
num_entries	long
;	O
struct	O
entry	struct
*	O
entry_i	pointer
=	O
file1	pointer
->	O
entries	pointer
[	O
i	long
]	O
;	O
ssize_t	long
j	long
;	O
ssize_t	long
best_j	long
=	O
-	O
1	int
;	O
double	O
best_j_similarity	double
=	O
0.0	int
;	O
for	O
(	O
j	long
=	O
n2	long
-	O
1	int
;	O
j	long
>=	O
0	int
;	O
j	long
--	O
)	O
if	O
(	O
mapping	pointer
->	O
index_mapping_reverse	pointer
[	O
j	long
]	O
<	O
0	int
)	O
{	O
double	O
similarity	double
=	O
entry_fstrcmp	function
(	O
entry_i	pointer
,	O
file2	pointer
->	O
entries	pointer
[	O
j	long
]	O
,	O
best_j_similarity	double
)	O
;	O
if	O
(	O
similarity	double
>	O
best_j_similarity	double
)	O
{	O
best_j	long
=	O
j	long
;	O
best_j_similarity	double
=	O
similarity	double
;	O
}	O
}	O
if	O
(	O
best_j_similarity	double
>=	O
FSTRCMP_THRESHOLD	int
)	O
{	O
struct	O
entry	struct
*	O
entry_j	pointer
=	O
file2	pointer
->	O
entries	pointer
[	O
best_j	long
]	O
;	O
ssize_t	long
best_i	long
=	O
-	O
1	int
;	O
double	O
best_i_similarity	double
=	O
0.0	int
;	O
ssize_t	long
ii	long
;	O
for	O
(	O
ii	long
=	O
n1	long
-	O
1	int
;	O
ii	long
>=	O
0	int
;	O
ii	long
--	O
)	O
if	O
(	O
mapping	pointer
->	O
index_mapping	pointer
[	O
ii	long
]	O
<	O
0	int
)	O
{	O
double	O
similarity	double
=	O
entry_fstrcmp	function
(	O
file1	pointer
->	O
entries	pointer
[	O
ii	long
]	O
,	O
entry_j	pointer
,	O
best_i_similarity	double
)	O
;	O
if	O
(	O
similarity	double
>	O
best_i_similarity	double
)	O
{	O
best_i	long
=	O
ii	long
;	O
best_i_similarity	double
=	O
similarity	double
;	O
}	O
}	O
if	O
(	O
best_i_similarity	double
>=	O
FSTRCMP_THRESHOLD	int
&&	O
best_i	long
==	O
i	long
)	O
{	O
mapping	pointer
->	O
index_mapping	pointer
[	O
i	long
]	O
=	O
best_j	long
;	O
mapping	pointer
->	O
index_mapping_reverse	pointer
[	O
best_j	long
]	O
=	O
i	long
;	O
}	O
}	O
if	O
(	O
mapping	pointer
->	O
index_mapping	pointer
[	O
i	long
]	O
<	O
-	O
1	int
)	O
mapping	pointer
->	O
index_mapping	pointer
[	O
i	long
]	O
=	O
-	O
1	int
;	O
}	O
return	O
mapping	pointer
->	O
index_mapping	pointer
[	O
i	long
]	O
;	O
}	O
static	O
ssize_t	long
entries_mapping_reverse_get	function
(	O
struct	O
entries_mapping	struct
*	O
mapping	pointer
,	O
ssize_t	long
j	long
)	O
{	O
if	O
(	O
mapping	pointer
->	O
index_mapping_reverse	pointer
[	O
j	long
]	O
<	O
-	O
1	int
)	O
{	O
struct	O
changelog_file	struct
*	O
file1	pointer
=	O
mapping	pointer
->	O
file1	pointer
;	O
struct	O
changelog_file	struct
*	O
file2	pointer
=	O
mapping	pointer
->	O
file2	pointer
;	O
size_t	long
n1	long
=	O
file1	pointer
->	O
num_entries	long
;	O
size_t	long
n2	long
=	O
file2	pointer
->	O
num_entries	long
;	O
struct	O
entry	struct
*	O
entry_j	pointer
=	O
file2	pointer
->	O
entries	pointer
[	O
j	long
]	O
;	O
ssize_t	long
i	long
;	O
ssize_t	long
best_i	long
=	O
-	O
1	int
;	O
double	O
best_i_similarity	double
=	O
0.0	int
;	O
for	O
(	O
i	long
=	O
n1	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
if	O
(	O
mapping	pointer
->	O
index_mapping	pointer
[	O
i	long
]	O
<	O
0	int
)	O
{	O
double	O
similarity	double
=	O
entry_fstrcmp	function
(	O
file1	pointer
->	O
entries	pointer
[	O
i	long
]	O
,	O
entry_j	pointer
,	O
best_i_similarity	double
)	O
;	O
if	O
(	O
similarity	double
>	O
best_i_similarity	double
)	O
{	O
best_i	long
=	O
i	long
;	O
best_i_similarity	double
=	O
similarity	double
;	O
}	O
}	O
if	O
(	O
best_i_similarity	double
>=	O
FSTRCMP_THRESHOLD	int
)	O
{	O
struct	O
entry	struct
*	O
entry_i	pointer
=	O
file1	pointer
->	O
entries	pointer
[	O
best_i	long
]	O
;	O
ssize_t	long
best_j	long
=	O
-	O
1	int
;	O
double	O
best_j_similarity	double
=	O
0.0	int
;	O
ssize_t	long
jj	long
;	O
for	O
(	O
jj	long
=	O
n2	long
-	O
1	int
;	O
jj	long
>=	O
0	int
;	O
jj	long
--	O
)	O
if	O
(	O
mapping	pointer
->	O
index_mapping_reverse	pointer
[	O
jj	long
]	O
<	O
0	int
)	O
{	O
double	O
similarity	double
=	O
entry_fstrcmp	function
(	O
entry_i	pointer
,	O
file2	pointer
->	O
entries	pointer
[	O
jj	long
]	O
,	O
best_j_similarity	double
)	O
;	O
if	O
(	O
similarity	double
>	O
best_j_similarity	double
)	O
{	O
best_j	long
=	O
jj	long
;	O
best_j_similarity	double
=	O
similarity	double
;	O
}	O
}	O
if	O
(	O
best_j_similarity	double
>=	O
FSTRCMP_THRESHOLD	int
&&	O
best_j	long
==	O
j	long
)	O
{	O
mapping	pointer
->	O
index_mapping_reverse	pointer
[	O
j	long
]	O
=	O
best_i	long
;	O
mapping	pointer
->	O
index_mapping	pointer
[	O
best_i	long
]	O
=	O
j	long
;	O
}	O
}	O
if	O
(	O
mapping	pointer
->	O
index_mapping_reverse	pointer
[	O
j	long
]	O
<	O
-	O
1	int
)	O
mapping	pointer
->	O
index_mapping_reverse	pointer
[	O
j	long
]	O
=	O
-	O
1	int
;	O
}	O
return	O
mapping	pointer
->	O
index_mapping_reverse	pointer
[	O
j	long
]	O
;	O
}	O
static	O
void	O
compute_mapping	function
(	O
struct	O
changelog_file	struct
*	O
file1	pointer
,	O
struct	O
changelog_file	struct
*	O
file2	pointer
,	O
bool	bool
full	bool
,	O
struct	O
entries_mapping	struct
*	O
result	pointer
)	O
{	O
ssize_t	long
*	O
index_mapping	pointer
;	O
ssize_t	long
*	O
index_mapping_reverse	pointer
;	O
size_t	long
n1	long
=	O
file1	pointer
->	O
num_entries	long
;	O
size_t	long
n2	long
=	O
file2	pointer
->	O
num_entries	long
;	O
ssize_t	long
i	long
,	O
j	long
;	O
index_mapping	pointer
=	O
XNMALLOC	O
(	O
n1	long
,	O
ssize_t	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n1	long
;	O
i	long
++	O
)	O
index_mapping	pointer
[	O
i	long
]	O
=	O
-	O
2	int
;	O
index_mapping_reverse	pointer
=	O
XNMALLOC	O
(	O
n2	long
,	O
ssize_t	long
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n2	long
;	O
j	long
++	O
)	O
index_mapping_reverse	pointer
[	O
j	long
]	O
=	O
-	O
2	int
;	O
for	O
(	O
i	long
=	O
n1	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
if	O
(	O
index_mapping	pointer
[	O
i	long
]	O
<	O
-	O
1	int
)	O
{	O
struct	O
entry	struct
*	O
entry	struct
=	O
file1	pointer
->	O
entries	pointer
[	O
i	long
]	O
;	O
j	long
=	O
gl_list_indexof	function
(	O
file2	pointer
->	O
entries_reversed	pointer
,	O
entry	struct
)	O
;	O
if	O
(	O
j	long
>=	O
0	int
)	O
{	O
j	long
=	O
n2	long
-	O
1	int
-	O
j	long
;	O
if	O
(	O
index_mapping_reverse	pointer
[	O
j	long
]	O
<	O
0	int
)	O
{	O
index_mapping	pointer
[	O
i	long
]	O
=	O
j	long
;	O
index_mapping_reverse	pointer
[	O
j	long
]	O
=	O
i	long
;	O
{	O
ssize_t	long
curr_i	long
=	O
i	long
;	O
ssize_t	long
curr_j	long
=	O
j	long
;	O
for	O
(	O
;	O
;	O
)	O
{	O
ssize_t	long
next_i	long
;	O
ssize_t	long
next_j	long
;	O
next_i	long
=	O
gl_list_indexof_from	function
(	O
file1	pointer
->	O
entries_reversed	pointer
,	O
n1	long
-	O
curr_i	long
,	O
entry	struct
)	O
;	O
if	O
(	O
next_i	long
<	O
0	int
)	O
break	O
;	O
next_j	long
=	O
gl_list_indexof_from	function
(	O
file2	pointer
->	O
entries_reversed	pointer
,	O
n2	long
-	O
curr_j	long
,	O
entry	struct
)	O
;	O
if	O
(	O
next_j	long
<	O
0	int
)	O
break	O
;	O
curr_i	long
=	O
n1	long
-	O
1	int
-	O
next_i	long
;	O
curr_j	long
=	O
n2	long
-	O
1	int
-	O
next_j	long
;	O
ASSERT	O
(	O
index_mapping	pointer
[	O
curr_i	long
]	O
<	O
0	int
)	O
;	O
ASSERT	O
(	O
index_mapping_reverse	pointer
[	O
curr_j	long
]	O
<	O
0	int
)	O
;	O
index_mapping	pointer
[	O
curr_i	long
]	O
=	O
curr_j	long
;	O
index_mapping_reverse	pointer
[	O
curr_j	long
]	O
=	O
curr_i	long
;	O
}	O
}	O
}	O
}	O
}	O
result	pointer
->	O
file1	pointer
=	O
file1	pointer
;	O
result	pointer
->	O
file2	pointer
=	O
file2	pointer
;	O
result	pointer
->	O
index_mapping	pointer
=	O
index_mapping	pointer
;	O
result	pointer
->	O
index_mapping_reverse	pointer
=	O
index_mapping_reverse	pointer
;	O
if	O
(	O
full	bool
)	O
for	O
(	O
i	long
=	O
n1	long
-	O
1	int
;	O
i	long
>=	O
0	int
;	O
i	long
--	O
)	O
entries_mapping_get	function
(	O
result	pointer
,	O
i	long
)	O
;	O
}	O
enum	O
edit_type	enum
{	O
ADDITION	int
,	O
CHANGE	int
,	O
REMOVAL	int
}	O
;	O
struct	O
edit	struct
{	O
enum	O
edit_type	enum
type	enum
;	O
ssize_t	long
i1	long
,	O
i2	long
;	O
ssize_t	long
j1	long
,	O
j2	long
;	O
}	O
;	O
struct	O
differences	struct
{	O
ssize_t	long
*	O
index_mapping	pointer
;	O
ssize_t	long
*	O
index_mapping_reverse	pointer
;	O
size_t	long
num_edits	long
;	O
struct	O
edit	struct
*	O
*	O
edits	pointer
;	O
}	O
;	O
static	O
void	O
compute_differences	function
(	O
struct	O
changelog_file	struct
*	O
file1	pointer
,	O
struct	O
changelog_file	struct
*	O
file2	pointer
,	O
struct	O
differences	struct
*	O
result	pointer
)	O
{	O
struct	O
context	struct
ctxt	pointer
;	O
size_t	long
n1	long
=	O
file1	pointer
->	O
num_entries	long
;	O
size_t	long
n2	long
=	O
file2	pointer
->	O
num_entries	long
;	O
ssize_t	long
i	long
;	O
ssize_t	long
j	long
;	O
gl_list_t	pointer
edits	pointer
;	O
ctxt	pointer
.	O
xvec	pointer
=	O
file1	pointer
->	O
entries	pointer
;	O
ctxt	pointer
.	O
yvec	pointer
=	O
file2	pointer
->	O
entries	pointer
;	O
ctxt	pointer
.	O
index_mapping	pointer
=	O
XNMALLOC	O
(	O
n1	long
,	O
ssize_t	long
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n1	long
;	O
i	long
++	O
)	O
ctxt	pointer
.	O
index_mapping	pointer
[	O
i	long
]	O
=	O
0	int
;	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
=	O
XNMALLOC	O
(	O
n2	long
,	O
ssize_t	long
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n2	long
;	O
j	long
++	O
)	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
[	O
j	long
]	O
=	O
0	int
;	O
ctxt	pointer
.	O
fdiag	pointer
=	O
XNMALLOC	O
(	O
2	int
*	O
(	O
n1	long
+	O
n2	long
+	O
3	int
)	O
,	O
ssize_t	long
)	O
+	O
n2	long
+	O
1	int
;	O
ctxt	pointer
.	O
bdiag	pointer
=	O
ctxt	pointer
.	O
fdiag	pointer
+	O
n1	long
+	O
n2	long
+	O
3	int
;	O
ctxt	pointer
.	O
too_expensive	long
=	O
n1	long
+	O
n2	long
;	O
compareseq	function
(	O
0	int
,	O
n1	long
,	O
0	int
,	O
n2	long
,	O
0	int
,	O
&	O
ctxt	pointer
)	O
;	O
i	long
=	O
0	int
;	O
j	long
=	O
0	int
;	O
while	O
(	O
i	long
<	O
n1	long
||	O
j	long
<	O
n2	long
)	O
{	O
while	O
(	O
i	long
<	O
n1	long
&&	O
ctxt	pointer
.	O
index_mapping	pointer
[	O
i	long
]	O
<	O
0	int
)	O
i	long
++	O
;	O
while	O
(	O
j	long
<	O
n2	long
&&	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
[	O
j	long
]	O
<	O
0	int
)	O
j	long
++	O
;	O
ASSERT	O
(	O
(	O
i	long
<	O
n1	long
)	O
==	O
(	O
j	long
<	O
n2	long
)	O
)	O
;	O
if	O
(	O
i	long
==	O
n1	long
&&	O
j	long
==	O
n2	long
)	O
break	O
;	O
ctxt	pointer
.	O
index_mapping	pointer
[	O
i	long
]	O
=	O
j	long
;	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
[	O
j	long
]	O
=	O
i	long
;	O
i	long
++	O
;	O
j	long
++	O
;	O
}	O
edits	pointer
=	O
gl_list_create_empty	function
(	O
GL_ARRAY_LIST	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
true	int
)	O
;	O
i	long
=	O
0	int
;	O
j	long
=	O
0	int
;	O
while	O
(	O
i	long
<	O
n1	long
||	O
j	long
<	O
n2	long
)	O
{	O
if	O
(	O
i	long
==	O
n1	long
)	O
{	O
struct	O
edit	struct
*	O
e	pointer
;	O
ASSERT	O
(	O
j	long
<	O
n2	long
)	O
;	O
e	pointer
=	O
XMALLOC	O
(	O
struct	O
edit	struct
)	O
;	O
e	pointer
->	O
type	enum
=	O
ADDITION	int
;	O
e	pointer
->	O
j1	long
=	O
j	long
;	O
e	pointer
->	O
j2	long
=	O
n2	long
-	O
1	int
;	O
gl_list_add_last	function
(	O
edits	pointer
,	O
e	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
j	long
==	O
n2	long
)	O
{	O
struct	O
edit	struct
*	O
e	pointer
;	O
ASSERT	O
(	O
i	long
<	O
n1	long
)	O
;	O
e	pointer
=	O
XMALLOC	O
(	O
struct	O
edit	struct
)	O
;	O
e	pointer
->	O
type	enum
=	O
REMOVAL	int
;	O
e	pointer
->	O
i1	long
=	O
i	long
;	O
e	pointer
->	O
i2	long
=	O
n1	long
-	O
1	int
;	O
gl_list_add_last	function
(	O
edits	pointer
,	O
e	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ctxt	pointer
.	O
index_mapping	pointer
[	O
i	long
]	O
>=	O
0	int
)	O
{	O
if	O
(	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
[	O
j	long
]	O
>=	O
0	int
)	O
{	O
ASSERT	O
(	O
ctxt	pointer
.	O
index_mapping	pointer
[	O
i	long
]	O
==	O
j	long
)	O
;	O
ASSERT	O
(	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
[	O
j	long
]	O
==	O
i	long
)	O
;	O
i	long
++	O
;	O
j	long
++	O
;	O
}	O
else	O
{	O
struct	O
edit	struct
*	O
e	pointer
;	O
ASSERT	O
(	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
[	O
j	long
]	O
<	O
0	int
)	O
;	O
e	pointer
=	O
XMALLOC	O
(	O
struct	O
edit	struct
)	O
;	O
e	pointer
->	O
type	enum
=	O
ADDITION	int
;	O
e	pointer
->	O
j1	long
=	O
j	long
;	O
do	O
j	long
++	O
;	O
while	O
(	O
j	long
<	O
n2	long
&&	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
[	O
j	long
]	O
<	O
0	int
)	O
;	O
e	pointer
->	O
j2	long
=	O
j	long
-	O
1	int
;	O
gl_list_add_last	function
(	O
edits	pointer
,	O
e	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
[	O
j	long
]	O
>=	O
0	int
)	O
{	O
struct	O
edit	struct
*	O
e	pointer
;	O
ASSERT	O
(	O
ctxt	pointer
.	O
index_mapping	pointer
[	O
i	long
]	O
<	O
0	int
)	O
;	O
e	pointer
=	O
XMALLOC	O
(	O
struct	O
edit	struct
)	O
;	O
e	pointer
->	O
type	enum
=	O
REMOVAL	int
;	O
e	pointer
->	O
i1	long
=	O
i	long
;	O
do	O
i	long
++	O
;	O
while	O
(	O
i	long
<	O
n1	long
&&	O
ctxt	pointer
.	O
index_mapping	pointer
[	O
i	long
]	O
<	O
0	int
)	O
;	O
e	pointer
->	O
i2	long
=	O
i	long
-	O
1	int
;	O
gl_list_add_last	function
(	O
edits	pointer
,	O
e	pointer
)	O
;	O
}	O
else	O
{	O
struct	O
edit	struct
*	O
e	pointer
;	O
ASSERT	O
(	O
ctxt	pointer
.	O
index_mapping	pointer
[	O
i	long
]	O
<	O
0	int
)	O
;	O
ASSERT	O
(	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
[	O
j	long
]	O
<	O
0	int
)	O
;	O
e	pointer
=	O
XMALLOC	O
(	O
struct	O
edit	struct
)	O
;	O
e	pointer
->	O
type	enum
=	O
CHANGE	int
;	O
e	pointer
->	O
i1	long
=	O
i	long
;	O
do	O
i	long
++	O
;	O
while	O
(	O
i	long
<	O
n1	long
&&	O
ctxt	pointer
.	O
index_mapping	pointer
[	O
i	long
]	O
<	O
0	int
)	O
;	O
e	pointer
->	O
i2	long
=	O
i	long
-	O
1	int
;	O
e	pointer
->	O
j1	long
=	O
j	long
;	O
do	O
j	long
++	O
;	O
while	O
(	O
j	long
<	O
n2	long
&&	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
[	O
j	long
]	O
<	O
0	int
)	O
;	O
e	pointer
->	O
j2	long
=	O
j	long
-	O
1	int
;	O
gl_list_add_last	function
(	O
edits	pointer
,	O
e	pointer
)	O
;	O
}	O
}	O
}	O
result	pointer
->	O
index_mapping	pointer
=	O
ctxt	pointer
.	O
index_mapping	pointer
;	O
result	pointer
->	O
index_mapping_reverse	pointer
=	O
ctxt	pointer
.	O
index_mapping_reverse	pointer
;	O
result	pointer
->	O
num_edits	long
=	O
gl_list_size	function
(	O
edits	pointer
)	O
;	O
result	pointer
->	O
edits	pointer
=	O
XNMALLOC	O
(	O
result	pointer
->	O
num_edits	long
,	O
struct	O
edit	struct
*	O
)	O
;	O
{	O
size_t	long
index	function
=	O
0	int
;	O
gl_list_iterator_t	struct
iter	struct
=	O
gl_list_iterator	function
(	O
edits	pointer
)	O
;	O
const	O
void	O
*	O
elt	pointer
;	O
gl_list_node_t	pointer
node	pointer
;	O
while	O
(	O
gl_list_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
elt	pointer
,	O
&	O
node	pointer
)	O
)	O
result	pointer
->	O
edits	pointer
[	O
index	function
++	O
]	O
=	O
(	O
struct	O
edit	struct
*	O
)	O
elt	pointer
;	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
ASSERT	O
(	O
index	function
==	O
result	pointer
->	O
num_edits	long
)	O
;	O
}	O
}	O
static	O
struct	O
entry	struct
empty_entry	struct
=	O
{	O
NULL	O
,	O
0	int
}	O
;	O
static	O
size_t	long
find_paragraph_end	function
(	O
const	O
struct	O
entry	struct
*	O
entry	struct
,	O
size_t	long
offset	long
)	O
{	O
const	O
char	O
*	O
string	pointer
=	O
entry	struct
->	O
string	pointer
;	O
size_t	long
length	pointer
=	O
entry	struct
->	O
length	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
const	O
char	O
*	O
nl	pointer
=	O
memchr	function
(	O
string	pointer
+	O
offset	long
,	O
'\n'	O
,	O
length	pointer
-	O
offset	long
)	O
;	O
if	O
(	O
nl	pointer
==	O
NULL	O
)	O
return	O
length	pointer
;	O
offset	long
=	O
(	O
nl	pointer
-	O
string	pointer
)	O
+	O
1	int
;	O
if	O
(	O
offset	long
<	O
length	pointer
&&	O
string	pointer
[	O
offset	long
]	O
==	O
'\n'	O
)	O
return	O
offset	long
;	O
}	O
}	O
static	O
bool	bool
try_split_merged_entry	function
(	O
const	O
struct	O
entry	struct
*	O
old_entry	pointer
,	O
const	O
struct	O
entry	struct
*	O
new_entry	pointer
,	O
struct	O
entry	struct
*	O
new_split	array
[	O
2	int
]	O
)	O
{	O
size_t	long
old_title_len	long
=	O
find_paragraph_end	function
(	O
old_entry	pointer
,	O
0	int
)	O
;	O
size_t	long
new_title_len	long
=	O
find_paragraph_end	function
(	O
new_entry	pointer
,	O
0	int
)	O
;	O
struct	O
entry	struct
old_body	struct
;	O
struct	O
entry	struct
new_body	struct
;	O
size_t	long
best_split_offset	long
;	O
double	O
best_similarity	double
;	O
size_t	long
split_offset	long
;	O
if	O
(	O
!	O
(	O
old_title_len	long
==	O
new_title_len	long
&&	O
memcmp	function
(	O
old_entry	pointer
->	O
string	pointer
,	O
new_entry	pointer
->	O
string	pointer
,	O
old_title_len	long
)	O
==	O
0	int
)	O
)	O
return	O
false	int
;	O
old_body	struct
.	O
string	pointer
=	O
old_entry	pointer
->	O
string	pointer
+	O
old_title_len	long
;	O
old_body	struct
.	O
length	pointer
=	O
old_entry	pointer
->	O
length	pointer
-	O
old_title_len	long
;	O
best_split_offset	long
=	O
split_offset	long
=	O
new_title_len	long
;	O
best_similarity	double
=	O
0.0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
double	O
similarity	double
;	O
new_body	struct
.	O
string	pointer
=	O
new_entry	pointer
->	O
string	pointer
+	O
split_offset	long
;	O
new_body	struct
.	O
length	pointer
=	O
new_entry	pointer
->	O
length	pointer
-	O
split_offset	long
;	O
similarity	double
=	O
entry_fstrcmp	function
(	O
&	O
old_body	struct
,	O
&	O
new_body	struct
,	O
best_similarity	double
)	O
;	O
if	O
(	O
similarity	double
>	O
best_similarity	double
)	O
{	O
best_split_offset	long
=	O
split_offset	long
;	O
best_similarity	double
=	O
similarity	double
;	O
}	O
if	O
(	O
best_similarity	double
==	O
1.0	int
)	O
break	O
;	O
if	O
(	O
split_offset	long
<	O
new_entry	pointer
->	O
length	pointer
)	O
split_offset	long
=	O
find_paragraph_end	function
(	O
new_entry	pointer
,	O
split_offset	long
+	O
1	int
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
best_split_offset	long
==	O
new_entry	pointer
->	O
length	pointer
)	O
return	O
false	int
;	O
ASSERT	O
(	O
new_entry	pointer
->	O
string	pointer
[	O
best_split_offset	long
]	O
==	O
'\n'	O
)	O
;	O
if	O
(	O
best_similarity	double
<	O
FSTRCMP_STRICTER_THRESHOLD	int
)	O
return	O
false	int
;	O
new_split	array
[	O
0	int
]	O
=	O
entry_create	function
(	O
new_entry	pointer
->	O
string	pointer
,	O
best_split_offset	long
+	O
1	int
)	O
;	O
{	O
size_t	long
len1	long
=	O
new_title_len	long
;	O
size_t	long
len2	long
=	O
new_entry	pointer
->	O
length	pointer
-	O
best_split_offset	long
;	O
char	O
*	O
combined	pointer
=	O
XNMALLOC	O
(	O
len1	long
+	O
len2	long
,	O
char	O
)	O
;	O
memcpy	function
(	O
combined	pointer
,	O
new_entry	pointer
->	O
string	pointer
,	O
len1	long
)	O
;	O
memcpy	function
(	O
combined	pointer
+	O
len1	long
,	O
new_entry	pointer
->	O
string	pointer
+	O
best_split_offset	long
,	O
len2	long
)	O
;	O
new_split	array
[	O
1	int
]	O
=	O
entry_create	function
(	O
combined	pointer
,	O
len1	long
+	O
len2	long
)	O
;	O
}	O
return	O
true	int
;	O
}	O
static	O
void	O
entry_write	function
(	O
FILE	struct
*	O
fp	pointer
,	O
struct	O
entry	struct
*	O
entry	struct
)	O
{	O
if	O
(	O
entry	struct
->	O
length	pointer
>	O
0	int
)	O
fwrite	function
(	O
entry	struct
->	O
string	pointer
,	O
1	int
,	O
entry	struct
->	O
length	pointer
,	O
fp	pointer
)	O
;	O
}	O
struct	O
conflict	struct
{	O
size_t	long
num_old_entries	long
;	O
struct	O
entry	struct
*	O
*	O
old_entries	pointer
;	O
size_t	long
num_modified_entries	long
;	O
struct	O
entry	struct
*	O
*	O
modified_entries	pointer
;	O
}	O
;	O
static	O
void	O
conflict_write	function
(	O
FILE	struct
*	O
fp	pointer
,	O
struct	O
conflict	struct
*	O
c	long
)	O
{	O
size_t	long
i	long
;	O
fputs	function
(	O
"<<<<<<<\n"	pointer
,	O
fp	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
c	long
->	O
num_old_entries	long
;	O
i	long
++	O
)	O
entry_write	function
(	O
fp	pointer
,	O
c	long
->	O
old_entries	pointer
[	O
i	long
]	O
)	O
;	O
fputs	function
(	O
"=======\n"	pointer
,	O
fp	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
c	long
->	O
num_modified_entries	long
;	O
i	long
++	O
)	O
entry_write	function
(	O
fp	pointer
,	O
c	long
->	O
modified_entries	pointer
[	O
i	long
]	O
)	O
;	O
fputs	function
(	O
">>>>>>>\n"	pointer
,	O
fp	pointer
)	O
;	O
}	O
static	O
const	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"split-merged-entry"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
1	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Try `%s --help' for more information.\n"	pointer
,	O
program_name	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
"Usage: %s [OPTION] O-FILE-NAME A-FILE-NAME B-FILE-NAME\n"	pointer
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
"Merges independent modifications of a ChangeLog style file.\n"	pointer
)	O
;	O
printf	function
(	O
"O-FILE-NAME names the original file, the ancestor of the two others.\n"	pointer
)	O
;	O
printf	function
(	O
"A-FILE-NAME names the publicly modified file.\n"	pointer
)	O
;	O
printf	function
(	O
"B-FILE-NAME names the user-modified file.\n"	pointer
)	O
;	O
printf	function
(	O
"Writes the merged file into A-FILE-NAME.\n"	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
"Informative output:\n"	pointer
)	O
;	O
printf	function
(	O
"  -h, --help                  display this help and exit\n"	pointer
)	O
;	O
printf	function
(	O
"  -V, --version               output version information and exit\n"	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
fputs	function
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	pointer
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
status	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
optchar	int
;	O
bool	bool
do_help	bool
;	O
bool	bool
do_version	bool
;	O
bool	bool
split_merged_entry	bool
;	O
set_program_name	function
(	O
argv	array
[	O
0	int
]	O
)	O
;	O
do_help	bool
=	O
false	int
;	O
do_version	bool
=	O
false	int
;	O
split_merged_entry	bool
=	O
true	int
;	O
while	O
(	O
(	O
optchar	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	array
,	O
"hV"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
optchar	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
1	int
:	O
break	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	function
(	O
"%s\n"	pointer
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv2+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	pointer
,	O
"2008"	pointer
)	O
;	O
printf	function
(	O
"Written by %s.\n"	pointer
,	O
"Bruno Haible"	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
{	O
usage	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
optind	int
+	O
3	int
!=	O
argc	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"expected three arguments"	pointer
)	O
;	O
{	O
const	O
char	O
*	O
ancestor_file_name	pointer
;	O
const	O
char	O
*	O
destination_file_name	pointer
;	O
bool	bool
downstream	bool
;	O
const	O
char	O
*	O
other_file_name	pointer
;	O
const	O
char	O
*	O
mainstream_file_name	pointer
;	O
const	O
char	O
*	O
modified_file_name	pointer
;	O
struct	O
changelog_file	struct
ancestor_file	struct
;	O
struct	O
changelog_file	struct
mainstream_file	struct
;	O
struct	O
changelog_file	struct
modified_file	struct
;	O
struct	O
entries_mapping	struct
mapping	pointer
;	O
struct	O
differences	struct
diffs	struct
;	O
gl_list_node_t	pointer
*	O
result_entries_pointers	pointer
;	O
gl_list_t	pointer
result_entries	pointer
;	O
gl_list_t	pointer
result_conflicts	pointer
;	O
ancestor_file_name	pointer
=	O
argv	array
[	O
optind	int
]	O
;	O
destination_file_name	pointer
=	O
argv	array
[	O
optind	int
+	O
1	int
]	O
;	O
other_file_name	pointer
=	O
argv	array
[	O
optind	int
+	O
2	int
]	O
;	O
{	O
const	O
char	O
*	O
var	pointer
;	O
var	pointer
=	O
getenv	function
(	O
"GIT_DOWNSTREAM"	pointer
)	O
;	O
if	O
(	O
var	pointer
!=	O
NULL	O
&&	O
var	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
downstream	bool
=	O
true	int
;	O
else	O
{	O
var	pointer
=	O
getenv	function
(	O
"GIT_UPSTREAM"	pointer
)	O
;	O
if	O
(	O
var	pointer
!=	O
NULL	O
&&	O
var	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
downstream	bool
=	O
false	int
;	O
else	O
{	O
var	pointer
=	O
getenv	function
(	O
"GIT_REFLOG_ACTION"	pointer
)	O
;	O
if	O
(	O
var	pointer
!=	O
NULL	O
&&	O
(	O
(	O
strncmp	function
(	O
var	pointer
,	O
"pull"	pointer
,	O
4	int
)	O
==	O
0	int
&&	O
c_strstr	function
(	O
var	pointer
,	O
" --rebase"	pointer
)	O
==	O
NULL	O
)	O
||	O
strncmp	function
(	O
var	pointer
,	O
"merge origin"	pointer
,	O
12	int
)	O
==	O
0	int
)	O
)	O
downstream	bool
=	O
true	int
;	O
else	O
{	O
downstream	bool
=	O
false	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
downstream	bool
)	O
{	O
mainstream_file_name	pointer
=	O
other_file_name	pointer
;	O
modified_file_name	pointer
=	O
destination_file_name	pointer
;	O
}	O
else	O
{	O
mainstream_file_name	pointer
=	O
destination_file_name	pointer
;	O
modified_file_name	pointer
=	O
other_file_name	pointer
;	O
}	O
read_changelog_file	function
(	O
ancestor_file_name	pointer
,	O
&	O
ancestor_file	struct
)	O
;	O
read_changelog_file	function
(	O
mainstream_file_name	pointer
,	O
&	O
mainstream_file	struct
)	O
;	O
read_changelog_file	function
(	O
modified_file_name	pointer
,	O
&	O
modified_file	struct
)	O
;	O
compute_mapping	function
(	O
&	O
ancestor_file	struct
,	O
&	O
mainstream_file	struct
,	O
false	int
,	O
&	O
mapping	pointer
)	O
;	O
(	O
void	O
)	O
entries_mapping_reverse_get	function
;	O
compute_differences	function
(	O
&	O
ancestor_file	struct
,	O
&	O
modified_file	struct
,	O
&	O
diffs	struct
)	O
;	O
result_entries_pointers	pointer
=	O
XNMALLOC	O
(	O
mainstream_file	struct
.	O
num_entries	long
,	O
gl_list_node_t	pointer
)	O
;	O
result_entries	pointer
=	O
gl_list_create_empty	function
(	O
GL_LINKED_LIST	O
,	O
entry_equals	function
,	O
entry_hashcode	function
,	O
NULL	O
,	O
true	int
)	O
;	O
{	O
size_t	long
k	long
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
mainstream_file	struct
.	O
num_entries	long
;	O
k	long
++	O
)	O
result_entries_pointers	pointer
[	O
k	long
]	O
=	O
gl_list_add_last	function
(	O
result_entries	pointer
,	O
mainstream_file	struct
.	O
entries	pointer
[	O
k	long
]	O
)	O
;	O
}	O
result_conflicts	pointer
=	O
gl_list_create_empty	function
(	O
GL_ARRAY_LIST	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
true	int
)	O
;	O
{	O
size_t	long
e	pointer
;	O
for	O
(	O
e	pointer
=	O
0	int
;	O
e	pointer
<	O
diffs	struct
.	O
num_edits	long
;	O
e	pointer
++	O
)	O
{	O
struct	O
edit	struct
*	O
edit	struct
=	O
diffs	struct
.	O
edits	pointer
[	O
e	pointer
]	O
;	O
switch	O
(	O
edit	struct
->	O
type	enum
)	O
{	O
case	O
ADDITION	int
:	O
if	O
(	O
edit	struct
->	O
j1	long
==	O
0	int
)	O
{	O
ssize_t	long
j	long
;	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j2	long
;	O
j	long
>=	O
edit	struct
->	O
j1	long
;	O
j	long
--	O
)	O
{	O
struct	O
entry	struct
*	O
added_entry	pointer
=	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
;	O
gl_list_add_first	function
(	O
result_entries	pointer
,	O
added_entry	pointer
)	O
;	O
}	O
}	O
else	O
{	O
ssize_t	long
i_before	long
;	O
ssize_t	long
i_after	long
;	O
ssize_t	long
k_before	long
;	O
ssize_t	long
k_after	long
;	O
i_before	long
=	O
diffs	struct
.	O
index_mapping_reverse	pointer
[	O
edit	struct
->	O
j1	long
-	O
1	int
]	O
;	O
ASSERT	O
(	O
i_before	long
>=	O
0	int
)	O
;	O
i_after	long
=	O
(	O
edit	struct
->	O
j2	long
+	O
1	int
==	O
modified_file	struct
.	O
num_entries	long
?	O
ancestor_file	struct
.	O
num_entries	long
:	O
diffs	struct
.	O
index_mapping_reverse	pointer
[	O
edit	struct
->	O
j2	long
+	O
1	int
]	O
)	O
;	O
ASSERT	O
(	O
i_after	long
>=	O
0	int
)	O
;	O
ASSERT	O
(	O
i_after	long
==	O
i_before	long
+	O
1	int
)	O
;	O
k_before	long
=	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i_before	long
)	O
;	O
k_after	long
=	O
(	O
i_after	long
==	O
ancestor_file	struct
.	O
num_entries	long
?	O
mainstream_file	struct
.	O
num_entries	long
:	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i_after	long
)	O
)	O
;	O
if	O
(	O
k_before	long
>=	O
0	int
&&	O
k_after	long
>=	O
0	int
&&	O
k_after	long
==	O
k_before	long
+	O
1	int
)	O
{	O
if	O
(	O
k_after	long
==	O
mainstream_file	struct
.	O
num_entries	long
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j1	long
;	O
j	long
<=	O
edit	struct
->	O
j2	long
;	O
j	long
++	O
)	O
{	O
struct	O
entry	struct
*	O
added_entry	pointer
=	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
;	O
gl_list_add_last	function
(	O
result_entries	pointer
,	O
added_entry	pointer
)	O
;	O
}	O
}	O
else	O
{	O
gl_list_node_t	pointer
node_k_after	pointer
=	O
result_entries_pointers	pointer
[	O
k_after	long
]	O
;	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j1	long
;	O
j	long
<=	O
edit	struct
->	O
j2	long
;	O
j	long
++	O
)	O
{	O
struct	O
entry	struct
*	O
added_entry	pointer
=	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
;	O
gl_list_add_before	function
(	O
result_entries	pointer
,	O
node_k_after	pointer
,	O
added_entry	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
struct	O
conflict	struct
*	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct
)	O
;	O
size_t	long
j	long
;	O
c	long
->	O
num_old_entries	long
=	O
0	int
;	O
c	long
->	O
old_entries	pointer
=	O
NULL	O
;	O
c	long
->	O
num_modified_entries	long
=	O
edit	struct
->	O
j2	long
-	O
edit	struct
->	O
j1	long
+	O
1	int
;	O
c	long
->	O
modified_entries	pointer
=	O
XNMALLOC	O
(	O
c	long
->	O
num_modified_entries	long
,	O
struct	O
entry	struct
*	O
)	O
;	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j1	long
;	O
j	long
<=	O
edit	struct
->	O
j2	long
;	O
j	long
++	O
)	O
c	long
->	O
modified_entries	pointer
[	O
j	long
-	O
edit	struct
->	O
j1	long
]	O
=	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
;	O
gl_list_add_last	function
(	O
result_conflicts	pointer
,	O
c	long
)	O
;	O
}	O
}	O
break	O
;	O
case	O
REMOVAL	int
:	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
edit	struct
->	O
i1	long
;	O
i	long
<=	O
edit	struct
->	O
i2	long
;	O
i	long
++	O
)	O
{	O
struct	O
entry	struct
*	O
removed_entry	pointer
=	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
;	O
ssize_t	long
k	long
=	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i	long
)	O
;	O
if	O
(	O
k	long
>=	O
0	int
&&	O
entry_equals	function
(	O
removed_entry	pointer
,	O
mainstream_file	struct
.	O
entries	pointer
[	O
k	long
]	O
)	O
)	O
{	O
gl_list_node_set_value	function
(	O
result_entries	pointer
,	O
result_entries_pointers	pointer
[	O
k	long
]	O
,	O
&	O
empty_entry	struct
)	O
;	O
}	O
else	O
{	O
struct	O
conflict	struct
*	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct
)	O
;	O
c	long
->	O
num_old_entries	long
=	O
1	int
;	O
c	long
->	O
old_entries	pointer
=	O
XNMALLOC	O
(	O
c	long
->	O
num_old_entries	long
,	O
struct	O
entry	struct
*	O
)	O
;	O
c	long
->	O
old_entries	pointer
[	O
0	int
]	O
=	O
removed_entry	pointer
;	O
c	long
->	O
num_modified_entries	long
=	O
0	int
;	O
c	long
->	O
modified_entries	pointer
=	O
NULL	O
;	O
gl_list_add_last	function
(	O
result_conflicts	pointer
,	O
c	long
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
CHANGE	int
:	O
{	O
bool	bool
done	bool
=	O
false	int
;	O
if	O
(	O
split_merged_entry	bool
&&	O
edit	struct
->	O
j1	long
==	O
0	int
)	O
{	O
if	O
(	O
edit	struct
->	O
i2	long
-	O
edit	struct
->	O
i1	long
<=	O
edit	struct
->	O
j2	long
-	O
edit	struct
->	O
j1	long
)	O
{	O
struct	O
entry	struct
*	O
split	array
[	O
2	int
]	O
;	O
bool	bool
simple_merged	bool
=	O
try_split_merged_entry	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
edit	struct
->	O
i1	long
]	O
,	O
modified_file	struct
.	O
entries	pointer
[	O
edit	struct
->	O
i1	long
+	O
edit	struct
->	O
j2	long
-	O
edit	struct
->	O
i2	long
]	O
,	O
split	array
)	O
;	O
if	O
(	O
simple_merged	bool
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
edit	struct
->	O
i1	long
+	O
1	int
;	O
i	long
<=	O
edit	struct
->	O
i2	long
;	O
i	long
++	O
)	O
if	O
(	O
entry_fstrcmp	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
,	O
modified_file	struct
.	O
entries	pointer
[	O
i	long
+	O
edit	struct
->	O
j2	long
-	O
edit	struct
->	O
i2	long
]	O
,	O
FSTRCMP_THRESHOLD	int
)	O
<	O
FSTRCMP_THRESHOLD	int
)	O
{	O
simple_merged	bool
=	O
false	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
simple_merged	bool
)	O
{	O
size_t	long
num_changed	long
=	O
edit	struct
->	O
i2	long
-	O
edit	struct
->	O
i1	long
+	O
1	int
;	O
size_t	long
num_added	long
=	O
(	O
edit	struct
->	O
j2	long
-	O
edit	struct
->	O
j1	long
+	O
1	int
)	O
-	O
num_changed	long
;	O
ssize_t	long
j	long
;	O
gl_list_add_first	function
(	O
result_entries	pointer
,	O
split	array
[	O
0	int
]	O
)	O
;	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j1	long
+	O
num_added	long
-	O
1	int
;	O
j	long
>=	O
edit	struct
->	O
j1	long
;	O
j	long
--	O
)	O
{	O
struct	O
entry	struct
*	O
added_entry	pointer
=	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
;	O
gl_list_add_first	function
(	O
result_entries	pointer
,	O
added_entry	pointer
)	O
;	O
}	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j1	long
+	O
num_added	long
;	O
j	long
<=	O
edit	struct
->	O
j2	long
;	O
j	long
++	O
)	O
{	O
struct	O
entry	struct
*	O
changed_entry	pointer
=	O
(	O
j	long
==	O
edit	struct
->	O
j1	long
+	O
num_added	long
?	O
split	array
[	O
1	int
]	O
:	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
)	O
;	O
size_t	long
i	long
=	O
j	long
+	O
edit	struct
->	O
i2	long
-	O
edit	struct
->	O
j2	long
;	O
ssize_t	long
k	long
=	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i	long
)	O
;	O
if	O
(	O
k	long
>=	O
0	int
&&	O
entry_equals	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
,	O
mainstream_file	struct
.	O
entries	pointer
[	O
k	long
]	O
)	O
)	O
{	O
gl_list_node_set_value	function
(	O
result_entries	pointer
,	O
result_entries_pointers	pointer
[	O
k	long
]	O
,	O
changed_entry	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
entry_equals	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
,	O
changed_entry	pointer
)	O
)	O
{	O
struct	O
conflict	struct
*	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct
)	O
;	O
c	long
->	O
num_old_entries	long
=	O
1	int
;	O
c	long
->	O
old_entries	pointer
=	O
XNMALLOC	O
(	O
c	long
->	O
num_old_entries	long
,	O
struct	O
entry	struct
*	O
)	O
;	O
c	long
->	O
old_entries	pointer
[	O
0	int
]	O
=	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
;	O
c	long
->	O
num_modified_entries	long
=	O
1	int
;	O
c	long
->	O
modified_entries	pointer
=	O
XNMALLOC	O
(	O
c	long
->	O
num_modified_entries	long
,	O
struct	O
entry	struct
*	O
)	O
;	O
c	long
->	O
modified_entries	pointer
[	O
0	int
]	O
=	O
changed_entry	pointer
;	O
gl_list_add_last	function
(	O
result_conflicts	pointer
,	O
c	long
)	O
;	O
}	O
}	O
done	bool
=	O
true	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
done	bool
)	O
{	O
bool	bool
simple	bool
;	O
if	O
(	O
edit	struct
->	O
i2	long
-	O
edit	struct
->	O
i1	long
<=	O
edit	struct
->	O
j2	long
-	O
edit	struct
->	O
j1	long
)	O
{	O
size_t	long
i	long
;	O
simple	bool
=	O
true	int
;	O
for	O
(	O
i	long
=	O
edit	struct
->	O
i1	long
;	O
i	long
<=	O
edit	struct
->	O
i2	long
;	O
i	long
++	O
)	O
if	O
(	O
entry_fstrcmp	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
,	O
modified_file	struct
.	O
entries	pointer
[	O
i	long
+	O
edit	struct
->	O
j2	long
-	O
edit	struct
->	O
i2	long
]	O
,	O
FSTRCMP_THRESHOLD	int
)	O
<	O
FSTRCMP_THRESHOLD	int
)	O
{	O
simple	bool
=	O
false	int
;	O
break	O
;	O
}	O
}	O
else	O
simple	bool
=	O
false	int
;	O
if	O
(	O
simple	bool
)	O
{	O
size_t	long
num_changed	long
=	O
edit	struct
->	O
i2	long
-	O
edit	struct
->	O
i1	long
+	O
1	int
;	O
size_t	long
num_added	long
=	O
(	O
edit	struct
->	O
j2	long
-	O
edit	struct
->	O
j1	long
+	O
1	int
)	O
-	O
num_changed	long
;	O
if	O
(	O
edit	struct
->	O
j1	long
==	O
0	int
)	O
{	O
ssize_t	long
j	long
;	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j1	long
+	O
num_added	long
-	O
1	int
;	O
j	long
>=	O
edit	struct
->	O
j1	long
;	O
j	long
--	O
)	O
{	O
struct	O
entry	struct
*	O
added_entry	pointer
=	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
;	O
gl_list_add_first	function
(	O
result_entries	pointer
,	O
added_entry	pointer
)	O
;	O
}	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j1	long
+	O
num_added	long
;	O
j	long
<=	O
edit	struct
->	O
j2	long
;	O
j	long
++	O
)	O
{	O
struct	O
entry	struct
*	O
changed_entry	pointer
=	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
;	O
size_t	long
i	long
=	O
j	long
+	O
edit	struct
->	O
i2	long
-	O
edit	struct
->	O
j2	long
;	O
ssize_t	long
k	long
=	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i	long
)	O
;	O
if	O
(	O
k	long
>=	O
0	int
&&	O
entry_equals	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
,	O
mainstream_file	struct
.	O
entries	pointer
[	O
k	long
]	O
)	O
)	O
{	O
gl_list_node_set_value	function
(	O
result_entries	pointer
,	O
result_entries_pointers	pointer
[	O
k	long
]	O
,	O
changed_entry	pointer
)	O
;	O
}	O
else	O
{	O
struct	O
conflict	struct
*	O
c	long
;	O
ASSERT	O
(	O
!	O
entry_equals	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
,	O
changed_entry	pointer
)	O
)	O
;	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct
)	O
;	O
c	long
->	O
num_old_entries	long
=	O
1	int
;	O
c	long
->	O
old_entries	pointer
=	O
XNMALLOC	O
(	O
c	long
->	O
num_old_entries	long
,	O
struct	O
entry	struct
*	O
)	O
;	O
c	long
->	O
old_entries	pointer
[	O
0	int
]	O
=	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
;	O
c	long
->	O
num_modified_entries	long
=	O
1	int
;	O
c	long
->	O
modified_entries	pointer
=	O
XNMALLOC	O
(	O
c	long
->	O
num_modified_entries	long
,	O
struct	O
entry	struct
*	O
)	O
;	O
c	long
->	O
modified_entries	pointer
[	O
0	int
]	O
=	O
changed_entry	pointer
;	O
gl_list_add_last	function
(	O
result_conflicts	pointer
,	O
c	long
)	O
;	O
}	O
}	O
done	bool
=	O
true	int
;	O
}	O
else	O
{	O
ssize_t	long
i_before	long
;	O
ssize_t	long
k_before	long
;	O
bool	bool
linear	bool
;	O
i_before	long
=	O
diffs	struct
.	O
index_mapping_reverse	pointer
[	O
edit	struct
->	O
j1	long
-	O
1	int
]	O
;	O
ASSERT	O
(	O
i_before	long
>=	O
0	int
)	O
;	O
k_before	long
=	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i_before	long
)	O
;	O
linear	bool
=	O
(	O
k_before	long
>=	O
0	int
)	O
;	O
if	O
(	O
linear	bool
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
i_before	long
+	O
1	int
;	O
i	long
<=	O
i_before	long
+	O
num_changed	long
;	O
i	long
++	O
)	O
if	O
(	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i	long
)	O
!=	O
k_before	long
+	O
(	O
i	long
-	O
i_before	long
)	O
)	O
{	O
linear	bool
=	O
false	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
linear	bool
)	O
{	O
gl_list_node_t	pointer
node_for_insert	pointer
=	O
result_entries_pointers	pointer
[	O
k_before	long
+	O
1	int
]	O
;	O
ssize_t	long
j	long
;	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j1	long
+	O
num_added	long
-	O
1	int
;	O
j	long
>=	O
edit	struct
->	O
j1	long
;	O
j	long
--	O
)	O
{	O
struct	O
entry	struct
*	O
added_entry	pointer
=	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
;	O
gl_list_add_before	function
(	O
result_entries	pointer
,	O
node_for_insert	pointer
,	O
added_entry	pointer
)	O
;	O
}	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j1	long
+	O
num_added	long
;	O
j	long
<=	O
edit	struct
->	O
j2	long
;	O
j	long
++	O
)	O
{	O
struct	O
entry	struct
*	O
changed_entry	pointer
=	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
;	O
size_t	long
i	long
=	O
j	long
+	O
edit	struct
->	O
i2	long
-	O
edit	struct
->	O
j2	long
;	O
ssize_t	long
k	long
=	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i	long
)	O
;	O
ASSERT	O
(	O
k	long
>=	O
0	int
)	O
;	O
if	O
(	O
entry_equals	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
,	O
mainstream_file	struct
.	O
entries	pointer
[	O
k	long
]	O
)	O
)	O
{	O
gl_list_node_set_value	function
(	O
result_entries	pointer
,	O
result_entries_pointers	pointer
[	O
k	long
]	O
,	O
changed_entry	pointer
)	O
;	O
}	O
else	O
{	O
struct	O
conflict	struct
*	O
c	long
;	O
ASSERT	O
(	O
!	O
entry_equals	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
,	O
changed_entry	pointer
)	O
)	O
;	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct
)	O
;	O
c	long
->	O
num_old_entries	long
=	O
1	int
;	O
c	long
->	O
old_entries	pointer
=	O
XNMALLOC	O
(	O
c	long
->	O
num_old_entries	long
,	O
struct	O
entry	struct
*	O
)	O
;	O
c	long
->	O
old_entries	pointer
[	O
0	int
]	O
=	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
;	O
c	long
->	O
num_modified_entries	long
=	O
1	int
;	O
c	long
->	O
modified_entries	pointer
=	O
XNMALLOC	O
(	O
c	long
->	O
num_modified_entries	long
,	O
struct	O
entry	struct
*	O
)	O
;	O
c	long
->	O
modified_entries	pointer
[	O
0	int
]	O
=	O
changed_entry	pointer
;	O
gl_list_add_last	function
(	O
result_conflicts	pointer
,	O
c	long
)	O
;	O
}	O
}	O
done	bool
=	O
true	int
;	O
}	O
}	O
}	O
else	O
{	O
ssize_t	long
i_first	long
;	O
ssize_t	long
k_first	long
;	O
bool	bool
linear_unchanged	bool
;	O
i_first	long
=	O
edit	struct
->	O
i1	long
;	O
k_first	long
=	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i_first	long
)	O
;	O
linear_unchanged	bool
=	O
(	O
k_first	long
>=	O
0	int
&&	O
entry_equals	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
i_first	long
]	O
,	O
mainstream_file	struct
.	O
entries	pointer
[	O
k_first	long
]	O
)	O
)	O
;	O
if	O
(	O
linear_unchanged	bool
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
i_first	long
+	O
1	int
;	O
i	long
<=	O
edit	struct
->	O
i2	long
;	O
i	long
++	O
)	O
if	O
(	O
!	O
(	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i	long
)	O
==	O
k_first	long
+	O
(	O
i	long
-	O
i_first	long
)	O
&&	O
entry_equals	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
,	O
mainstream_file	struct
.	O
entries	pointer
[	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i	long
)	O
]	O
)	O
)	O
)	O
{	O
linear_unchanged	bool
=	O
false	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
linear_unchanged	bool
)	O
{	O
gl_list_node_t	pointer
node_for_insert	pointer
=	O
result_entries_pointers	pointer
[	O
k_first	long
]	O
;	O
ssize_t	long
j	long
;	O
size_t	long
i	long
;	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j2	long
;	O
j	long
>=	O
edit	struct
->	O
j1	long
;	O
j	long
--	O
)	O
{	O
struct	O
entry	struct
*	O
new_entry	pointer
=	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
;	O
gl_list_add_before	function
(	O
result_entries	pointer
,	O
node_for_insert	pointer
,	O
new_entry	pointer
)	O
;	O
}	O
for	O
(	O
i	long
=	O
edit	struct
->	O
i1	long
;	O
i	long
<=	O
edit	struct
->	O
i2	long
;	O
i	long
++	O
)	O
{	O
ssize_t	long
k	long
=	O
entries_mapping_get	function
(	O
&	O
mapping	pointer
,	O
i	long
)	O
;	O
ASSERT	O
(	O
k	long
>=	O
0	int
)	O
;	O
ASSERT	O
(	O
entry_equals	function
(	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
,	O
mainstream_file	struct
.	O
entries	pointer
[	O
k	long
]	O
)	O
)	O
;	O
gl_list_node_set_value	function
(	O
result_entries	pointer
,	O
result_entries_pointers	pointer
[	O
k	long
]	O
,	O
&	O
empty_entry	struct
)	O
;	O
}	O
done	bool
=	O
true	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
done	bool
)	O
{	O
struct	O
conflict	struct
*	O
c	long
=	O
XMALLOC	O
(	O
struct	O
conflict	struct
)	O
;	O
size_t	long
i	long
,	O
j	long
;	O
c	long
->	O
num_old_entries	long
=	O
edit	struct
->	O
i2	long
-	O
edit	struct
->	O
i1	long
+	O
1	int
;	O
c	long
->	O
old_entries	pointer
=	O
XNMALLOC	O
(	O
c	long
->	O
num_old_entries	long
,	O
struct	O
entry	struct
*	O
)	O
;	O
for	O
(	O
i	long
=	O
edit	struct
->	O
i1	long
;	O
i	long
<=	O
edit	struct
->	O
i2	long
;	O
i	long
++	O
)	O
c	long
->	O
old_entries	pointer
[	O
i	long
-	O
edit	struct
->	O
i1	long
]	O
=	O
ancestor_file	struct
.	O
entries	pointer
[	O
i	long
]	O
;	O
c	long
->	O
num_modified_entries	long
=	O
edit	struct
->	O
j2	long
-	O
edit	struct
->	O
j1	long
+	O
1	int
;	O
c	long
->	O
modified_entries	pointer
=	O
XNMALLOC	O
(	O
c	long
->	O
num_modified_entries	long
,	O
struct	O
entry	struct
*	O
)	O
;	O
for	O
(	O
j	long
=	O
edit	struct
->	O
j1	long
;	O
j	long
<=	O
edit	struct
->	O
j2	long
;	O
j	long
++	O
)	O
c	long
->	O
modified_entries	pointer
[	O
j	long
-	O
edit	struct
->	O
j1	long
]	O
=	O
modified_file	struct
.	O
entries	pointer
[	O
j	long
]	O
;	O
gl_list_add_last	function
(	O
result_conflicts	pointer
,	O
c	long
)	O
;	O
}	O
}	O
break	O
;	O
}	O
}	O
}	O
{	O
FILE	struct
*	O
fp	pointer
=	O
fopen	function
(	O
destination_file_name	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"could not write file '%s'\n"	pointer
,	O
destination_file_name	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
{	O
size_t	long
n	long
=	O
gl_list_size	function
(	O
result_conflicts	pointer
)	O
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	long
;	O
i	long
++	O
)	O
conflict_write	function
(	O
fp	pointer
,	O
(	O
struct	O
conflict	struct
*	O
)	O
gl_list_get_at	function
(	O
result_conflicts	pointer
,	O
i	long
)	O
)	O
;	O
}	O
{	O
gl_list_iterator_t	struct
iter	struct
=	O
gl_list_iterator	function
(	O
result_entries	pointer
)	O
;	O
const	O
void	O
*	O
elt	pointer
;	O
gl_list_node_t	pointer
node	pointer
;	O
while	O
(	O
gl_list_iterator_next	function
(	O
&	O
iter	struct
,	O
&	O
elt	pointer
,	O
&	O
node	pointer
)	O
)	O
entry_write	function
(	O
fp	pointer
,	O
(	O
struct	O
entry	struct
*	O
)	O
elt	pointer
)	O
;	O
gl_list_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
if	O
(	O
fwriteerror	function
(	O
fp	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error writing to file '%s'\n"	pointer
,	O
destination_file_name	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
exit	function
(	O
gl_list_size	function
(	O
result_conflicts	pointer
)	O
>	O
0	int
?	O
EXIT_FAILURE	int
:	O
EXIT_SUCCESS	int
)	O
;	O
}	O
}	O
