static	O
const	O
long	O
idraw_brush_pattern	array
[	O
PL_NUM_LINE_TYPES	int
]	O
=	O
{	O
0xffff	int
,	O
0x8888	int
,	O
0xfc30	int
,	O
0xf0f0	int
,	O
0xffc0	int
,	O
0xfccc	int
,	O
0xfdb6	int
}	O
;	O
static	O
const	O
int	O
ps_join_style	array
[	O
PL_NUM_JOIN_TYPES	int
]	O
=	O
{	O
PS_LINE_JOIN_MITER	int
,	O
PS_LINE_JOIN_ROUND	int
,	O
PS_LINE_JOIN_BEVEL	int
,	O
PS_LINE_JOIN_ROUND	int
}	O
;	O
static	O
const	O
int	O
ps_cap_style	array
[	O
PL_NUM_CAP_TYPES	int
]	O
=	O
{	O
PS_LINE_CAP_BUTT	int
,	O
PS_LINE_CAP_ROUND	int
,	O
PS_LINE_CAP_PROJECT	int
,	O
PS_LINE_CAP_ROUND	int
}	O
;	O
void	O
_pl_p_paint_path	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
double	O
granularity	double
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
==	O
0	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
==	O
0	int
)	O
return	O
;	O
{	O
double	O
norm	double
,	O
min_sing_val	pointer
,	O
max_sing_val	pointer
;	O
_matrix_sing_vals	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
,	O
&	O
min_sing_val	pointer
,	O
&	O
max_sing_val	pointer
)	O
;	O
norm	double
=	O
min_sing_val	pointer
;	O
granularity	double
=	O
norm	double
/	O
(	O
PS_MIN_RESOLUTION	int
)	O
;	O
}	O
if	O
(	O
granularity	double
==	O
0.0	int
)	O
return	O
;	O
switch	O
(	O
(	O
int	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
type	enum
)	O
{	O
case	O
(	O
int	O
)	O
PATH_SEGMENT_LIST	int
:	O
{	O
bool	enum
closed	enum
,	O
closed_int	enum
;	O
int	O
i	int
,	O
numpoints	int
,	O
index_start	int
,	O
index_increment	int
;	O
int	O
polyline_len	int
;	O
plIntPoint	struct
*	O
xarray	pointer
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
1	int
)	O
break	O
;	O
if	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
>=	O
3	int
)	O
&&	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
x	double
==	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
x	double
)	O
&&	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
y	double
==	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
y	double
)	O
)	O
closed	enum
=	O
true	int
;	O
else	O
closed	enum
=	O
false	int
;	O
xarray	pointer
=	O
(	O
plIntPoint	struct
*	O
)	O
_pl_xmalloc	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
*	O
sizeof	O
(	O
plIntPoint	struct
)	O
)	O
;	O
polyline_len	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
plPoint	struct
datapoint	struct
;	O
int	O
x_int	int
,	O
y_int	int
;	O
datapoint	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
;	O
x_int	int
=	O
IROUND	O
(	O
granularity	double
*	O
datapoint	struct
.	O
x	double
)	O
;	O
y_int	int
=	O
IROUND	O
(	O
granularity	double
*	O
datapoint	struct
.	O
y	double
)	O
;	O
if	O
(	O
(	O
polyline_len	int
==	O
0	int
)	O
||	O
(	O
x_int	int
!=	O
xarray	pointer
[	O
polyline_len	int
-	O
1	int
]	O
.	O
x	double
)	O
||	O
(	O
y_int	int
!=	O
xarray	pointer
[	O
polyline_len	int
-	O
1	int
]	O
.	O
y	double
)	O
)	O
{	O
xarray	pointer
[	O
polyline_len	int
]	O
.	O
x	double
=	O
x_int	int
;	O
xarray	pointer
[	O
polyline_len	int
]	O
.	O
y	double
=	O
y_int	int
;	O
polyline_len	int
++	O
;	O
}	O
}	O
if	O
(	O
polyline_len	int
==	O
1	int
)	O
{	O
xarray	pointer
[	O
1	int
]	O
=	O
xarray	pointer
[	O
0	int
]	O
;	O
polyline_len	int
=	O
2	int
;	O
}	O
if	O
(	O
polyline_len	int
==	O
2	int
)	O
closed_int	enum
=	O
false	int
;	O
else	O
closed_int	enum
=	O
closed	enum
;	O
numpoints	int
=	O
polyline_len	int
-	O
(	O
closed_int	enum
?	O
1	int
:	O
0	int
)	O
;	O
if	O
(	O
closed_int	enum
)	O
strcpy	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"Begin %I Poly\n"	pointer
)	O
;	O
else	O
strcpy	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"Begin %I MLine\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_pl_p_emit_common_attributes	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
strcpy	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%I t\n["	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
6	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
i	int
==	O
0	int
)	O
||	O
(	O
i	int
==	O
1	int
)	O
||	O
(	O
i	int
==	O
2	int
)	O
||	O
(	O
i	int
==	O
3	int
)	O
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.7g "	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
[	O
i	int
]	O
/	O
granularity	double
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.7g "	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
[	O
i	int
]	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
strcpy	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"] concat\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I %d\n"	pointer
,	O
numpoints	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
if	O
(	O
closed_int	enum
)	O
{	O
index_start	int
=	O
numpoints	int
-	O
1	int
;	O
index_increment	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
index_start	int
=	O
0	int
;	O
index_increment	int
=	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
index_start	int
;	O
i	int
>=	O
0	int
&&	O
i	int
<=	O
numpoints	int
-	O
1	int
;	O
i	int
+=	O
index_increment	int
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d %d\n"	pointer
,	O
xarray	pointer
[	O
i	int
]	O
.	O
x	double
,	O
xarray	pointer
[	O
i	int
]	O
.	O
y	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
if	O
(	O
closed_int	enum
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d Poly\nEnd\n\n"	pointer
,	O
numpoints	int
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d MLine\nEnd\n\n"	pointer
,	O
numpoints	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
free	function
(	O
xarray	pointer
)	O
;	O
numpoints	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
-	O
(	O
closed	enum
?	O
1	int
:	O
0	int
)	O
;	O
if	O
(	O
closed	enum
)	O
{	O
index_start	int
=	O
numpoints	int
-	O
1	int
;	O
index_increment	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
index_start	int
=	O
0	int
;	O
index_increment	int
=	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
index_start	int
;	O
i	int
>=	O
0	int
&&	O
i	int
<=	O
numpoints	int
-	O
1	int
;	O
i	int
+=	O
index_increment	int
)	O
{	O
if	O
(	O
!	O
closed	enum
&&	O
(	O
(	O
i	int
==	O
0	int
)	O
||	O
(	O
i	int
==	O
numpoints	int
-	O
1	int
)	O
)	O
)	O
{	O
int	O
j	int
;	O
j	int
=	O
(	O
i	int
==	O
0	int
?	O
1	int
:	O
numpoints	int
-	O
2	int
)	O
;	O
_set_line_end_bbox	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
.	O
p	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
j	int
]	O
.	O
p	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
j	int
]	O
.	O
p	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_width	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
cap_type	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
)	O
;	O
}	O
else	O
{	O
int	O
a	int
,	O
b	int
,	O
c	char
;	O
if	O
(	O
closed	enum
&&	O
i	int
==	O
0	int
)	O
{	O
a	int
=	O
numpoints	int
-	O
1	int
;	O
b	int
=	O
0	int
;	O
c	char
=	O
1	int
;	O
}	O
else	O
{	O
a	int
=	O
i	int
-	O
1	int
;	O
b	int
=	O
i	int
;	O
c	char
=	O
i	int
+	O
1	int
;	O
}	O
_set_line_join_bbox	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
a	int
]	O
.	O
p	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
a	int
]	O
.	O
p	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
b	int
]	O
.	O
p	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
b	int
]	O
.	O
p	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
c	char
]	O
.	O
p	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
c	char
]	O
.	O
p	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_width	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
miter_limit	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_BOX	int
:	O
{	O
int	O
i	int
;	O
strcpy	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"Begin %I Rect\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_pl_p_emit_common_attributes	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
strcpy	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%I t\n["	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
6	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
i	int
==	O
0	int
)	O
||	O
(	O
i	int
==	O
1	int
)	O
||	O
(	O
i	int
==	O
2	int
)	O
||	O
(	O
i	int
==	O
3	int
)	O
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.7g "	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
[	O
i	int
]	O
/	O
granularity	double
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.7g "	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
[	O
i	int
]	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
strcpy	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"] concat\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I\n%d %d %d %d Rect\nEnd\n\n"	pointer
,	O
IROUND	O
(	O
granularity	double
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
x	double
)	O
,	O
IROUND	O
(	O
granularity	double
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
y	double
)	O
,	O
IROUND	O
(	O
granularity	double
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
x	double
)	O
,	O
IROUND	O
(	O
granularity	double
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
y	double
)	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_set_line_join_bbox	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_width	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
miter_limit	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
)	O
;	O
_set_line_join_bbox	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_width	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
miter_limit	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
)	O
;	O
_set_line_join_bbox	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_width	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
miter_limit	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
)	O
;	O
_set_line_join_bbox	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
x	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
.	O
y	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_width	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
miter_limit	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_CIRCLE	int
:	O
{	O
plPoint	struct
pc	struct
;	O
double	O
radius	double
;	O
pc	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
;	O
radius	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
radius	double
;	O
_pl_p_fellipse_internal	function
(	O
R___	O
(	O
_plotter	pointer
)	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
,	O
radius	double
,	O
radius	double
,	O
0.0	int
,	O
true	int
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_ELLIPSE	int
:	O
{	O
double	O
x	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
.	O
x	double
;	O
double	O
y	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
.	O
y	double
;	O
double	O
rx	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
rx	double
;	O
double	O
ry	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
ry	double
;	O
double	O
angle	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
angle	double
;	O
_pl_p_fellipse_internal	function
(	O
R___	O
(	O
_plotter	pointer
)	O
x	double
,	O
y	double
,	O
rx	double
,	O
ry	double
,	O
angle	double
,	O
false	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
_pl_p_fellipse_internal	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
,	O
bool	enum
circlep	enum
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
||	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
)	O
{	O
double	O
granularity	double
;	O
double	O
costheta	double
,	O
sintheta	double
;	O
double	O
offcenter_rotation_matrix	array
[	O
6	int
]	O
;	O
double	O
ellipse_transformation_matrix	array
[	O
6	int
]	O
;	O
int	O
i	int
;	O
if	O
(	O
circlep	enum
)	O
strcpy	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"Begin %I Circ\n"	pointer
)	O
;	O
else	O
strcpy	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"Begin %I Elli\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
granularity	double
=	O
_pl_p_emit_common_attributes	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
costheta	double
=	O
cos	function
(	O
M_PI	int
*	O
angle	double
/	O
180.0	int
)	O
;	O
sintheta	double
=	O
sin	function
(	O
M_PI	int
*	O
angle	double
/	O
180.0	int
)	O
;	O
offcenter_rotation_matrix	array
[	O
0	int
]	O
=	O
costheta	double
;	O
offcenter_rotation_matrix	array
[	O
1	int
]	O
=	O
sintheta	double
;	O
offcenter_rotation_matrix	array
[	O
2	int
]	O
=	O
-	O
sintheta	double
;	O
offcenter_rotation_matrix	array
[	O
3	int
]	O
=	O
costheta	double
;	O
offcenter_rotation_matrix	array
[	O
4	int
]	O
=	O
x	double
*	O
(	O
1.0	int
-	O
costheta	double
)	O
+	O
y	double
*	O
sintheta	double
;	O
offcenter_rotation_matrix	array
[	O
5	int
]	O
=	O
y	double
*	O
(	O
1.0	int
-	O
costheta	double
)	O
-	O
x	double
*	O
sintheta	double
;	O
_matrix_product	function
(	O
offcenter_rotation_matrix	array
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
,	O
ellipse_transformation_matrix	array
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I t\n["	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
6	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
(	O
i	int
==	O
0	int
)	O
||	O
(	O
i	int
==	O
1	int
)	O
||	O
(	O
i	int
==	O
2	int
)	O
||	O
(	O
i	int
==	O
3	int
)	O
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.7g "	pointer
,	O
ellipse_transformation_matrix	array
[	O
i	int
]	O
/	O
granularity	double
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.7g "	pointer
,	O
ellipse_transformation_matrix	array
[	O
i	int
]	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"] concat\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
if	O
(	O
circlep	enum
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I\n%d %d %d Circ\nEnd\n\n"	pointer
,	O
IROUND	O
(	O
granularity	double
*	O
x	double
)	O
,	O
IROUND	O
(	O
granularity	double
*	O
y	double
)	O
,	O
IROUND	O
(	O
granularity	double
*	O
rx	double
)	O
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I\n%d %d %d %d Elli\nEnd\n\n"	pointer
,	O
IROUND	O
(	O
granularity	double
*	O
x	double
)	O
,	O
IROUND	O
(	O
granularity	double
*	O
y	double
)	O
,	O
IROUND	O
(	O
granularity	double
*	O
rx	double
)	O
,	O
IROUND	O
(	O
granularity	double
*	O
ry	double
)	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_set_ellipse_bbox	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
,	O
x	double
,	O
y	double
,	O
rx	double
,	O
ry	double
,	O
costheta	double
,	O
sintheta	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_width	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
)	O
;	O
}	O
}	O
double	O
_pl_p_emit_common_attributes	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
bool	enum
singular_map	enum
;	O
int	O
i	int
;	O
double	O
invnorm	double
=	O
0.0	int
,	O
granularity	double
=	O
1.0	int
;	O
double	O
linewidth_adjust	double
=	O
1.0	int
;	O
double	O
min_sing_val	pointer
,	O
max_sing_val	pointer
,	O
norm	double
;	O
_matrix_sing_vals	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
,	O
&	O
min_sing_val	pointer
,	O
&	O
max_sing_val	pointer
)	O
;	O
norm	double
=	O
min_sing_val	pointer
;	O
granularity	double
=	O
norm	double
/	O
(	O
PS_MIN_RESOLUTION	int
)	O
;	O
if	O
(	O
norm	double
!=	O
0.0	int
)	O
{	O
invnorm	double
=	O
1.0	int
/	O
norm	double
;	O
singular_map	enum
=	O
false	int
;	O
}	O
else	O
singular_map	enum
=	O
true	int
;	O
if	O
(	O
singular_map	enum
!=	O
true	int
)	O
{	O
int	O
integer_linewidth	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
quantized_device_line_width	int
;	O
double	O
double_linewidth	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
device_line_width	double
;	O
if	O
(	O
integer_linewidth	int
!=	O
0	int
)	O
linewidth_adjust	double
=	O
double_linewidth	double
/	O
integer_linewidth	int
;	O
else	O
linewidth_adjust	double
=	O
1.0	int
;	O
strcpy	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"["	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.7g "	pointer
,	O
linewidth_adjust	double
*	O
invnorm	double
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
[	O
i	int
]	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
strcpy	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"0 0 ] trueoriginalCTM originalCTM\nconcatmatrix pop\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
==	O
PL_JOIN_MITER	int
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d setlinecap %d setlinejoin %.4g setmiterlimit\n"	pointer
,	O
ps_cap_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
cap_type	int
]	O
,	O
ps_join_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
]	O
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
miter_limit	double
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d setlinecap %d setlinejoin\n"	pointer
,	O
ps_cap_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
cap_type	int
]	O
,	O
ps_join_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
]	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_rule_type	int
==	O
PL_FILL_NONZERO_WINDING	int
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"/eoFillRule false def\n"	pointer
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"/eoFillRule true def\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
!=	O
0	int
)	O
{	O
int	O
num_dashes	int
;	O
double	O
scale	double
;	O
double	O
*	O
dashbuf	pointer
,	O
dash_cycle_length	double
,	O
offset	array
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_in_effect	enum
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I b %ld\n"	pointer
,	O
(	O
long	O
int	O
)	O
0xffff	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
num_dashes	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_len	int
;	O
if	O
(	O
num_dashes	int
>	O
0	int
)	O
dashbuf	pointer
=	O
(	O
double	O
*	O
)	O
_pl_xmalloc	function
(	O
num_dashes	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
else	O
dashbuf	pointer
=	O
NULL	O
;	O
scale	double
=	O
norm	double
/	O
linewidth_adjust	double
;	O
dash_cycle_length	double
=	O
0.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
{	O
double	O
dashlen	double
;	O
dashlen	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
[	O
i	int
]	O
;	O
dash_cycle_length	double
+=	O
dashlen	double
;	O
dashbuf	pointer
[	O
i	int
]	O
=	O
scale	double
*	O
dashlen	double
;	O
}	O
if	O
(	O
dash_cycle_length	double
>	O
0.0	int
)	O
{	O
double	O
true_cycle_length	double
;	O
offset	array
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_offset	double
;	O
true_cycle_length	double
=	O
dash_cycle_length	double
*	O
(	O
num_dashes	int
%	O
2	int
==	O
1	int
?	O
2	int
:	O
1	int
)	O
;	O
while	O
(	O
offset	array
<	O
0.0	int
)	O
offset	array
+=	O
true_cycle_length	double
;	O
offset	array
=	O
fmod	function
(	O
offset	array
,	O
true_cycle_length	double
)	O
;	O
offset	array
*=	O
scale	double
;	O
}	O
else	O
offset	array
=	O
0.0	int
;	O
}	O
else	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I b %ld\n"	pointer
,	O
idraw_brush_pattern	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
]	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
==	O
PL_L_SOLID	int
)	O
{	O
num_dashes	int
=	O
0	int
;	O
dashbuf	pointer
=	O
NULL	O
;	O
offset	array
=	O
0.0	int
;	O
}	O
else	O
{	O
const	O
int	O
*	O
dash_array	pointer
;	O
double	O
display_size_in_points	double
,	O
min_dash_unit	double
;	O
dash_array	pointer
=	O
_pl_g_line_styles	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
]	O
.	O
dash_array	pointer
;	O
num_dashes	int
=	O
_pl_g_line_styles	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
]	O
.	O
dash_array_len	int
;	O
dashbuf	pointer
=	O
(	O
double	O
*	O
)	O
_pl_xmalloc	function
(	O
num_dashes	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
display_size_in_points	double
=	O
DMIN	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
xmax	double
-	O
_plotter	pointer
->	O
data	pointer
->	O
xmin	double
,	O
_plotter	pointer
->	O
data	pointer
->	O
ymax	double
-	O
_plotter	pointer
->	O
data	pointer
->	O
ymin	double
)	O
;	O
min_dash_unit	double
=	O
(	O
PL_MIN_DASH_UNIT_AS_FRACTION_OF_DISPLAY_SIZE	O
*	O
display_size_in_points	double
)	O
;	O
scale	double
=	O
DMAX	O
(	O
min_dash_unit	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
device_line_width	double
)	O
;	O
scale	double
/=	O
linewidth_adjust	double
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
dashbuf	pointer
[	O
i	int
]	O
=	O
scale	double
*	O
dash_array	pointer
[	O
i	int
]	O
;	O
offset	array
=	O
0.0	int
;	O
}	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d 0 0 [ "	pointer
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
quantized_device_line_width	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%.3g "	pointer
,	O
dashbuf	pointer
[	O
i	int
]	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"] %.3g SetB\n"	pointer
,	O
offset	array
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
free	function
(	O
dashbuf	pointer
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I b n\nnone SetB\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
_pl_p_set_pen_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I cfg %s\n%g %g %g SetCFg\n"	pointer
,	O
_pl_p_idraw_stdcolornames	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_idraw_fgcolor	int
]	O
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fgcolor_red	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fgcolor_green	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fgcolor_blue	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_pl_p_set_fill_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I cbg %s\n%g %g %g SetCBg\n"	pointer
,	O
_pl_p_idraw_stdcolornames	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_idraw_bgcolor	int
]	O
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_red	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_green	double
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_fillcolor_blue	double
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
==	O
0	int
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I p\nnone SetP\n"	pointer
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%%I p\n%f SetP\n"	pointer
,	O
_pl_p_idraw_stdshadings	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
ps_idraw_shading	int
]	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
return	O
granularity	double
;	O
}	O
bool	enum
_pl_p_paint_paths	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
return	O
false	int
;	O
}	O
