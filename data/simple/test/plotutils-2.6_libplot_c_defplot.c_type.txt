static	O
void	O
build_sdr_from_index	function
(	O
plOutbuf	struct
*	O
sdr_buffer	pointer
,	O
int	O
cgm_encoding	int
,	O
int	O
x	double
)	O
;	O
static	O
void	O
build_sdr_from_string	function
(	O
plOutbuf	struct
*	O
sdr_buffer	pointer
,	O
int	O
cgm_encoding	int
,	O
const	O
char	O
*	O
s	pointer
,	O
int	O
string_length	int
,	O
bool	enum
use_double_quotes	enum
)	O
;	O
static	O
void	O
build_sdr_from_ui8s	function
(	O
plOutbuf	struct
*	O
sdr_buffer	pointer
,	O
int	O
cgm_encoding	int
,	O
const	O
int	O
*	O
x	double
,	O
int	O
n	array
)	O
;	O
const	O
Plotter	struct
_pl_c_default_plotter	struct
=	O
{	O
_pl_c_initialize	function
,	O
_pl_c_terminate	function
,	O
_pl_c_begin_page	function
,	O
_pl_c_erase_page	function
,	O
_pl_c_end_page	function
,	O
_pl_g_push_state	function
,	O
_pl_g_pop_state	function
,	O
_pl_c_paint_path	function
,	O
_pl_c_paint_paths	function
,	O
_pl_g_path_is_flushable	function
,	O
_pl_g_maybe_prepaint_segments	function
,	O
_pl_c_paint_marker	function
,	O
_pl_c_paint_point	function
,	O
_pl_g_paint_text_string_with_escapes	function
,	O
_pl_c_paint_text_string	function
,	O
_pl_g_get_text_width	function
,	O
_pl_g_retrieve_font	function
,	O
_pl_g_flush_output	function
,	O
_pl_g_warning	function
,	O
_pl_g_error	function
,	O
}	O
;	O
void	O
_pl_c_initialize	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
_pl_g_initialize	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
type	enum
=	O
PL_CGM	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
output_model	enum
=	O
PL_OUTPUT_PAGES_ALL_AT_ONCE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_wide_lines	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_dash_array	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_solid_fill	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_odd_winding_fill	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_nonzero_winding_fill	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_settable_bg	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_escaped_string_support	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_ps_fonts	int
=	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_pcl_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_stick_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_extra_stick_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_other_fonts	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
default_font_type	int
=	O
PL_F_POSTSCRIPT	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
pcl_before_ps	enum
=	O
false	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_horizontal_justification	enum
=	O
true	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_vertical_justification	enum
=	O
true	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
issue_font_warning	enum
=	O
true	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_mixed_paths	enum
=	O
false	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_arc_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_ellarc_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_quad_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_cubic_scaling	enum
=	O
AS_NONE	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_box_scaling	enum
=	O
AS_AXES_PRESERVED	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_circle_scaling	enum
=	O
AS_UNIFORM	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_ellipse_scaling	enum
=	O
AS_ANY	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
display_model_type	int
=	O
(	O
int	O
)	O
DISP_MODEL_VIRTUAL	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
display_coors_type	int
=	O
(	O
int	O
)	O
DISP_DEVICE_COORS_INTEGER_NON_LIBXMI	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
flipped_y	enum
=	O
false	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
imin	int
=	O
-	O
(	O
(	O
1	int
<<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
-	O
3	int
)	O
)	O
-	O
1	int
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
=	O
(	O
1	int
<<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
-	O
3	int
)	O
)	O
-	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
=	O
-	O
(	O
(	O
1	int
<<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
-	O
3	int
)	O
)	O
-	O
1	int
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmax	int
=	O
(	O
1	int
<<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
-	O
3	int
)	O
)	O
-	O
1	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
xmin	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
xmax	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
ymin	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
ymax	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
page_data	pointer
=	O
(	O
plPageData	struct
*	O
)	O
NULL	O
;	O
_plotter	pointer
->	O
cgm_encoding	int
=	O
CGM_ENCODING_BINARY	int
;	O
_plotter	pointer
->	O
cgm_max_version	int
=	O
4	int
;	O
_plotter	pointer
->	O
cgm_version	int
=	O
1	int
;	O
_plotter	pointer
->	O
cgm_profile	int
=	O
CGM_PROFILE_WEB	int
;	O
_plotter	pointer
->	O
cgm_need_color	int
=	O
false	int
;	O
_plotter	pointer
->	O
cgm_page_version	int
=	O
1	int
;	O
_plotter	pointer
->	O
cgm_page_profile	int
=	O
CGM_PROFILE_WEB	int
;	O
_plotter	pointer
->	O
cgm_page_need_color	enum
=	O
false	int
;	O
_plotter	pointer
->	O
cgm_line_color	struct
.	O
red	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_line_color	struct
.	O
green	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_line_color	struct
.	O
blue	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_edge_color	struct
.	O
red	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_edge_color	struct
.	O
green	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_edge_color	struct
.	O
blue	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_fillcolor	struct
.	O
red	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_fillcolor	struct
.	O
green	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_fillcolor	struct
.	O
blue	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_marker_color	struct
.	O
red	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_marker_color	struct
.	O
green	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_marker_color	struct
.	O
blue	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_text_color	struct
.	O
red	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_text_color	struct
.	O
green	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_text_color	struct
.	O
blue	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_bgcolor	struct
.	O
red	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_bgcolor	struct
.	O
green	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_bgcolor	struct
.	O
blue	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_line_type	int
=	O
CGM_L_SOLID	int
;	O
_plotter	pointer
->	O
cgm_dash_offset	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
cgm_join_style	int
=	O
CGM_JOIN_UNSPEC	int
;	O
_plotter	pointer
->	O
cgm_cap_style	int
=	O
CGM_CAP_UNSPEC	int
;	O
_plotter	pointer
->	O
cgm_dash_cap_style	int
=	O
CGM_CAP_UNSPEC	int
;	O
_plotter	pointer
->	O
cgm_line_width	int
=	O
(	O
1	int
<<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
-	O
3	int
)	O
)	O
/	O
500	int
;	O
_plotter	pointer
->	O
cgm_interior_style	int
=	O
CGM_INT_STYLE_HOLLOW	int
;	O
_plotter	pointer
->	O
cgm_edge_type	int
=	O
CGM_L_SOLID	int
;	O
_plotter	pointer
->	O
cgm_edge_dash_offset	double
=	O
0.0	int
;	O
_plotter	pointer
->	O
cgm_edge_join_style	int
=	O
CGM_JOIN_UNSPEC	int
;	O
_plotter	pointer
->	O
cgm_edge_cap_style	int
=	O
CGM_CAP_UNSPEC	int
;	O
_plotter	pointer
->	O
cgm_edge_dash_cap_style	int
=	O
CGM_CAP_UNSPEC	int
;	O
_plotter	pointer
->	O
cgm_edge_width	int
=	O
(	O
1	int
<<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
-	O
3	int
)	O
)	O
/	O
500	int
;	O
_plotter	pointer
->	O
cgm_edge_is_visible	enum
=	O
false	int
;	O
_plotter	pointer
->	O
cgm_miter_limit	double
=	O
32767.0	int
;	O
_plotter	pointer
->	O
cgm_marker_type	int
=	O
CGM_M_ASTERISK	int
;	O
_plotter	pointer
->	O
cgm_marker_size	int
=	O
(	O
1	int
<<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
-	O
3	int
)	O
)	O
/	O
500	int
;	O
_plotter	pointer
->	O
cgm_char_height	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_char_base_vector_x	int
=	O
1	int
;	O
_plotter	pointer
->	O
cgm_char_base_vector_y	int
=	O
0	int
;	O
_plotter	pointer
->	O
cgm_char_up_vector_x	int
=	O
0	int
;	O
_plotter	pointer
->	O
cgm_char_up_vector_y	int
=	O
1	int
;	O
_plotter	pointer
->	O
cgm_horizontal_text_alignment	int
=	O
CGM_ALIGN_NORMAL_HORIZONTAL	int
;	O
_plotter	pointer
->	O
cgm_vertical_text_alignment	int
=	O
CGM_ALIGN_NORMAL_VERTICAL	int
;	O
_plotter	pointer
->	O
cgm_font_id	int
=	O
-	O
1	int
;	O
_plotter	pointer
->	O
cgm_charset_lower	int
=	O
0	int
;	O
_plotter	pointer
->	O
cgm_charset_upper	int
=	O
0	int
;	O
_plotter	pointer
->	O
cgm_restricted_text_type	int
=	O
CGM_RESTRICTED_TEXT_TYPE_BASIC	int
;	O
_set_page_type	function
(	O
_plotter	pointer
->	O
data	pointer
)	O
;	O
{	O
int	O
half_side	int
=	O
(	O
1	int
<<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
-	O
3	int
)	O
)	O
-	O
1	int
;	O
int	O
half_other_side	int
;	O
double	O
xsize	double
=	O
_plotter	pointer
->	O
data	pointer
->	O
viewport_xsize	double
;	O
double	O
ysize	double
=	O
_plotter	pointer
->	O
data	pointer
->	O
viewport_ysize	double
;	O
int	O
xsign	int
=	O
xsize	double
<	O
0.0	int
?	O
-	O
1	int
:	O
1	int
;	O
int	O
ysign	int
=	O
ysize	double
<	O
0.0	int
?	O
-	O
1	int
:	O
1	int
;	O
double	O
fraction	double
;	O
if	O
(	O
xsize	double
==	O
0.0	int
&&	O
ysize	double
==	O
0.0	int
)	O
{	O
_plotter	pointer
->	O
data	pointer
->	O
imin	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
=	O
0	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmax	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
FABS	O
(	O
ysize	double
)	O
>	O
FABS	O
(	O
xsize	double
)	O
)	O
{	O
fraction	double
=	O
FABS	O
(	O
xsize	double
)	O
/	O
FABS	O
(	O
ysize	double
)	O
;	O
half_other_side	int
=	O
IROUND	O
(	O
half_side	int
*	O
fraction	double
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
imin	int
=	O
-	O
xsign	int
*	O
half_other_side	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
=	O
xsign	int
*	O
half_other_side	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
=	O
-	O
ysign	int
*	O
half_side	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmax	int
=	O
ysign	int
*	O
half_side	int
;	O
}	O
else	O
{	O
fraction	double
=	O
FABS	O
(	O
ysize	double
)	O
/	O
FABS	O
(	O
xsize	double
)	O
;	O
half_other_side	int
=	O
IROUND	O
(	O
half_side	int
*	O
fraction	double
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
imin	int
=	O
-	O
xsign	int
*	O
half_side	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
=	O
xsign	int
*	O
half_side	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
=	O
-	O
ysign	int
*	O
half_other_side	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
jmax	int
=	O
ysign	int
*	O
half_other_side	int
;	O
}	O
}	O
_compute_ndc_to_device_map	function
(	O
_plotter	pointer
->	O
data	pointer
)	O
;	O
{	O
const	O
char	O
*	O
cgm_encoding_type	pointer
;	O
cgm_encoding_type	pointer
=	O
(	O
const	O
char	O
*	O
)	O
_get_plot_param	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"CGM_ENCODING"	pointer
)	O
;	O
if	O
(	O
cgm_encoding_type	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
cgm_encoding_type	pointer
,	O
"binary"	pointer
)	O
==	O
0	int
)	O
_plotter	pointer
->	O
cgm_encoding	int
=	O
CGM_ENCODING_BINARY	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
cgm_encoding_type	pointer
,	O
"clear text"	pointer
)	O
==	O
0	int
||	O
(	O
strcmp	function
(	O
cgm_encoding_type	pointer
,	O
"cleartext"	pointer
)	O
==	O
0	int
)	O
||	O
(	O
strcmp	function
(	O
cgm_encoding_type	pointer
,	O
"clear_text"	pointer
)	O
==	O
0	int
)	O
)	O
_plotter	pointer
->	O
cgm_encoding	int
=	O
CGM_ENCODING_CLEAR_TEXT	int
;	O
else	O
_plotter	pointer
->	O
cgm_encoding	int
=	O
CGM_ENCODING_BINARY	int
;	O
}	O
else	O
_plotter	pointer
->	O
cgm_encoding	int
=	O
CGM_ENCODING_BINARY	int
;	O
}	O
{	O
const	O
char	O
*	O
cgm_max_version_type	pointer
;	O
cgm_max_version_type	pointer
=	O
(	O
const	O
char	O
*	O
)	O
_get_plot_param	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
"CGM_MAX_VERSION"	pointer
)	O
;	O
if	O
(	O
cgm_max_version_type	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
cgm_max_version_type	pointer
,	O
"1"	pointer
)	O
==	O
0	int
)	O
_plotter	pointer
->	O
cgm_max_version	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
cgm_max_version_type	pointer
,	O
"2"	pointer
)	O
==	O
0	int
)	O
_plotter	pointer
->	O
cgm_max_version	int
=	O
2	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
cgm_max_version_type	pointer
,	O
"3"	pointer
)	O
==	O
0	int
)	O
_plotter	pointer
->	O
cgm_max_version	int
=	O
3	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
cgm_max_version_type	pointer
,	O
"4"	pointer
)	O
==	O
0	int
)	O
_plotter	pointer
->	O
cgm_max_version	int
=	O
4	int
;	O
else	O
_plotter	pointer
->	O
cgm_max_version	int
=	O
4	int
;	O
}	O
else	O
_plotter	pointer
->	O
cgm_max_version	int
=	O
4	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
cgm_max_version	int
>=	O
2	int
)	O
{	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_arc_scaling	enum
=	O
AS_UNIFORM	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_ellarc_scaling	enum
=	O
AS_ANY	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
cgm_max_version	int
>=	O
3	int
)	O
{	O
_plotter	pointer
->	O
data	pointer
->	O
allowed_cubic_scaling	enum
=	O
AS_ANY	int
;	O
_plotter	pointer
->	O
data	pointer
->	O
have_mixed_paths	enum
=	O
true	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
cgm_max_version	int
>=	O
3	int
)	O
_plotter	pointer
->	O
data	pointer
->	O
have_dash_array	int
=	O
1	int
;	O
}	O
typedef	O
struct	O
{	O
const	O
char	O
*	O
text_string	pointer
;	O
int	O
length	int
;	O
int	O
class_id	array
[	O
MAX_CGM_ELEMENT_LIST_LENGTH	int
]	O
;	O
int	O
element_id	array
[	O
MAX_CGM_ELEMENT_LIST_LENGTH	int
]	O
;	O
}	O
plCGMElementList	struct
;	O
static	O
const	O
plCGMElementList	struct
_metafile_element_list	array
[	O
4	int
]	O
=	O
{	O
{	O
"DRAWINGPLUS"	pointer
,	O
1	int
,	O
{	O
-	O
1	int
}	O
,	O
{	O
1	int
}	O
}	O
,	O
{	O
"VERSION2"	pointer
,	O
1	int
,	O
{	O
-	O
1	int
}	O
,	O
{	O
2	int
}	O
}	O
,	O
{	O
"VERSION3"	pointer
,	O
1	int
,	O
{	O
-	O
1	int
}	O
,	O
{	O
5	int
}	O
}	O
,	O
{	O
"VERSION4"	pointer
,	O
1	int
,	O
{	O
-	O
1	int
}	O
,	O
{	O
6	int
}	O
}	O
}	O
;	O
typedef	O
struct	O
{	O
int	O
type	enum
;	O
const	O
char	O
*	O
type_string	pointer
;	O
const	O
char	O
*	O
tail	pointer
;	O
}	O
plCGMCharset	struct
;	O
static	O
const	O
plCGMCharset	struct
_iso_latin_1_cgm_charset	array
[	O
2	int
]	O
=	O
{	O
{	O
0	int
,	O
"std94"	pointer
,	O
"4/2"	pointer
}	O
,	O
{	O
1	int
,	O
"std96"	pointer
,	O
"4/1"	pointer
}	O
}	O
;	O
static	O
const	O
plCGMCharset	struct
_symbol_cgm_charset	array
[	O
2	int
]	O
=	O
{	O
{	O
0	int
,	O
"std94"	pointer
,	O
"2/10 3/10"	pointer
}	O
,	O
{	O
0	int
,	O
"std94"	pointer
,	O
"2/6 3/10"	pointer
}	O
}	O
;	O
void	O
_pl_c_terminate	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
int	O
i	int
;	O
plOutbuf	struct
*	O
current_page	pointer
;	O
bool	enum
ps_font_used_in_doc	array
[	O
PL_NUM_PS_FONTS	int
]	O
;	O
bool	enum
symbol_font_used_in_doc	enum
;	O
bool	enum
cgm_font_id_used_in_doc	array
[	O
PL_NUM_PS_FONTS	int
]	O
;	O
bool	enum
doc_uses_fonts	enum
;	O
int	O
max_cgm_font_id	int
;	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
first_page	pointer
==	O
(	O
plOutbuf	struct
*	O
)	O
NULL	O
)	O
_plotter	pointer
->	O
cgm_profile	int
=	O
IMAX	O
(	O
_plotter	pointer
->	O
cgm_profile	int
,	O
CGM_PROFILE_NONE	int
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
{	O
plOutbuf	struct
*	O
doc_header	pointer
,	O
*	O
doc_trailer	pointer
;	O
int	O
byte_count	pointer
,	O
data_byte_count	pointer
,	O
data_len	int
,	O
string_length	int
;	O
doc_header	pointer
=	O
_new_outbuf	function
(	O
)	O
;	O
{	O
const	O
char	O
*	O
string_param	pointer
;	O
string_param	pointer
=	O
"CGM plot"	pointer
;	O
string_length	int
=	O
strlen	function
(	O
string_param	pointer
)	O
;	O
data_len	int
=	O
CGM_BINARY_BYTES_PER_STRING	O
(	O
string_length	int
)	O
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_DELIMITER_ELEMENT	int
,	O
1	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"BEGMF"	pointer
)	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
string_param	pointer
,	O
string_length	int
,	O
true	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
data_len	int
=	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
1	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"MFVERSION"	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_plotter	pointer
->	O
cgm_version	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
const	O
plCGMElementList	struct
*	O
element_list	pointer
=	O
&	O
(	O
_metafile_element_list	array
[	O
_plotter	pointer
->	O
cgm_version	int
-	O
1	int
]	O
)	O
;	O
int	O
length	int
=	O
element_list	pointer
->	O
length	int
;	O
int	O
k	int
;	O
data_len	int
=	O
CGM_BINARY_BYTES_PER_INTEGER	int
+	O
2	int
*	O
2	int
*	O
length	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
11	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"MFELEMLIST"	pointer
)	O
;	O
switch	O
(	O
_plotter	pointer
->	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
length	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
length	int
;	O
k	int
++	O
)	O
{	O
_cgm_emit_index	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
element_list	pointer
->	O
class_id	array
[	O
k	int
]	O
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_index	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
element_list	pointer
->	O
element_id	array
[	O
k	int
]	O
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
element_list	pointer
->	O
text_string	pointer
,	O
(	O
int	O
)	O
strlen	function
(	O
element_list	pointer
->	O
text_string	pointer
)	O
,	O
true	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
break	O
;	O
}	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
time_t	long
clock	function
;	O
const	O
char	O
*	O
profile_string	pointer
,	O
*	O
profile_edition_string	pointer
;	O
char	O
string_param	pointer
[	O
254	int
]	O
;	O
struct	O
tm	struct
*	O
local_time_struct_ptr	pointer
;	O
switch	O
(	O
_plotter	pointer
->	O
cgm_profile	int
)	O
{	O
case	O
CGM_PROFILE_WEB	int
:	O
profile_string	pointer
=	O
"WebCGM"	pointer
;	O
profile_edition_string	pointer
=	O
"1.0"	pointer
;	O
break	O
;	O
case	O
CGM_PROFILE_MODEL	int
:	O
profile_string	pointer
=	O
"Model-Profile"	pointer
;	O
profile_edition_string	pointer
=	O
"1"	pointer
;	O
break	O
;	O
case	O
CGM_PROFILE_NONE	int
:	O
default	O
:	O
profile_string	pointer
=	O
"None"	pointer
;	O
profile_edition_string	pointer
=	O
"0.0"	pointer
;	O
break	O
;	O
}	O
time	function
(	O
&	O
clock	function
)	O
;	O
local_time_struct_ptr	pointer
=	O
localtime	function
(	O
&	O
clock	function
)	O
;	O
sprintf	function
(	O
string_param	pointer
,	O
"\"ProfileId:%s\" \"ProfileEd:%s\" \"ColourClass:%s\" \"Source:GNU libplot %s\" \"Date:%04d%02d%02d\""	pointer
,	O
profile_string	pointer
,	O
profile_edition_string	pointer
,	O
_plotter	pointer
->	O
cgm_need_color	int
?	O
"colour"	pointer
:	O
"monochrome"	pointer
,	O
PL_LIBPLOT_VER_STRING	pointer
,	O
1900	int
+	O
local_time_struct_ptr	pointer
->	O
tm_year	int
,	O
1	int
+	O
local_time_struct_ptr	pointer
->	O
tm_mon	int
,	O
local_time_struct_ptr	pointer
->	O
tm_mday	int
)	O
;	O
string_length	int
=	O
strlen	function
(	O
string_param	pointer
)	O
;	O
data_len	int
=	O
CGM_BINARY_BYTES_PER_STRING	O
(	O
string_length	int
)	O
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
2	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"MFDESC"	pointer
)	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
string_param	pointer
,	O
string_length	int
,	O
false	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
3	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"VDCTYPE"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"integer"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
int	O
j	int
,	O
max_int	int
;	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
4	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"INTEGERPREC"	pointer
)	O
;	O
switch	O
(	O
_plotter	pointer
->	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
_cgm_emit_index	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
max_int	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
-	O
1	int
)	O
;	O
j	int
++	O
)	O
max_int	int
+=	O
(	O
1	int
<<	O
j	int
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
-	O
max_int	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
max_int	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
break	O
;	O
}	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
data_len	int
=	O
2	int
+	O
2	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
5	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"REALPREC"	pointer
)	O
;	O
switch	O
(	O
_plotter	pointer
->	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
_cgm_emit_enum	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"DUMMY"	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
16	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
16	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
_cgm_emit_real_fixed_point	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
-	O
32767.0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_real_fixed_point	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
32767.0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
4	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
break	O
;	O
}	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
int	O
j	int
;	O
unsigned	O
int	O
max_component	int
;	O
data_len	int
=	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
7	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"COLRPREC"	pointer
)	O
;	O
switch	O
(	O
_plotter	pointer
->	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
8	int
*	O
CGM_BINARY_BYTES_PER_COLOR_COMPONENT	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
max_component	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_COLOR_COMPONENT	int
)	O
;	O
j	int
++	O
)	O
max_component	int
+=	O
(	O
1	int
<<	O
j	int
)	O
;	O
_cgm_emit_unsigned_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
max_component	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
break	O
;	O
}	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
int	O
j	int
;	O
unsigned	O
int	O
max_component	int
;	O
data_len	int
=	O
6	int
*	O
CGM_BINARY_BYTES_PER_COLOR_COMPONENT	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
10	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"COLRVALUEEXT"	pointer
)	O
;	O
_cgm_emit_color_component	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
(	O
unsigned	O
int	O
)	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_color_component	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
(	O
unsigned	O
int	O
)	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_color_component	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
(	O
unsigned	O
int	O
)	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
max_component	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_COLOR_COMPONENT	int
)	O
;	O
j	int
++	O
)	O
max_component	int
+=	O
(	O
1	int
<<	O
j	int
)	O
;	O
_cgm_emit_color_component	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
max_component	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_color_component	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
max_component	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_color_component	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
max_component	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
current_page	pointer
=	O
_plotter	pointer
->	O
data	pointer
->	O
first_page	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
PL_NUM_PS_FONTS	int
;	O
i	int
++	O
)	O
ps_font_used_in_doc	array
[	O
i	int
]	O
=	O
false	int
;	O
while	O
(	O
current_page	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
PL_NUM_PS_FONTS	int
;	O
i	int
++	O
)	O
if	O
(	O
current_page	pointer
->	O
ps_font_used	array
[	O
i	int
]	O
)	O
ps_font_used_in_doc	array
[	O
i	int
]	O
=	O
true	int
;	O
current_page	pointer
=	O
current_page	pointer
->	O
next	pointer
;	O
}	O
}	O
symbol_font_used_in_doc	enum
=	O
false	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
PL_NUM_PS_FONTS	int
;	O
i	int
++	O
)	O
{	O
cgm_font_id_used_in_doc	array
[	O
_pl_g_ps_font_to_cgm_font_id	array
[	O
i	int
]	O
]	O
=	O
ps_font_used_in_doc	array
[	O
i	int
]	O
;	O
if	O
(	O
ps_font_used_in_doc	array
[	O
i	int
]	O
&&	O
strcmp	function
(	O
_pl_g_ps_font_info	array
[	O
i	int
]	O
.	O
ps_name	pointer
,	O
"Symbol"	pointer
)	O
==	O
0	int
)	O
symbol_font_used_in_doc	enum
=	O
true	int
;	O
}	O
max_cgm_font_id	int
=	O
0	int
;	O
doc_uses_fonts	enum
=	O
false	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
PL_NUM_PS_FONTS	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
cgm_font_id_used_in_doc	array
[	O
i	int
]	O
==	O
true	int
)	O
{	O
doc_uses_fonts	enum
=	O
true	int
;	O
max_cgm_font_id	int
=	O
i	int
;	O
}	O
}	O
if	O
(	O
doc_uses_fonts	enum
)	O
{	O
data_len	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
max_cgm_font_id	int
;	O
i	int
++	O
)	O
{	O
int	O
ps_font_index	int
;	O
int	O
font_name_length	int
,	O
encoded_font_name_length	int
;	O
ps_font_index	int
=	O
_pl_g_cgm_font_id_to_ps_font	array
[	O
i	int
]	O
;	O
font_name_length	int
=	O
(	O
int	O
)	O
strlen	function
(	O
_pl_g_ps_font_info	array
[	O
ps_font_index	int
]	O
.	O
ps_name	pointer
)	O
;	O
encoded_font_name_length	int
=	O
CGM_BINARY_BYTES_PER_STRING	O
(	O
font_name_length	int
)	O
;	O
data_len	int
+=	O
encoded_font_name_length	int
;	O
}	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
13	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"FONTLIST"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
max_cgm_font_id	int
;	O
i	int
++	O
)	O
{	O
int	O
ps_font_index	int
;	O
ps_font_index	int
=	O
_pl_g_cgm_font_id_to_ps_font	array
[	O
i	int
]	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_pl_g_ps_font_info	array
[	O
ps_font_index	int
]	O
.	O
ps_name	pointer
,	O
(	O
int	O
)	O
strlen	function
(	O
_pl_g_ps_font_info	array
[	O
ps_font_index	int
]	O
.	O
ps_name	pointer
)	O
,	O
true	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
cgm_version	int
>=	O
3	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
max_cgm_font_id	int
;	O
i	int
++	O
)	O
{	O
int	O
family_length	int
;	O
plOutbuf	struct
*	O
sdr_buffer	pointer
;	O
family_length	int
=	O
strlen	function
(	O
_pl_g_cgm_font_properties	array
[	O
i	int
]	O
.	O
family	pointer
)	O
;	O
data_len	int
=	O
(	O
14	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
+	O
48	int
+	O
CGM_BINARY_BYTES_PER_STRING	O
(	O
family_length	int
)	O
)	O
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
sdr_buffer	pointer
=	O
_new_outbuf	function
(	O
)	O
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
21	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"FONTPROP"	pointer
)	O
;	O
{	O
_cgm_emit_index	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_FONT_PROP_INDEX	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
build_sdr_from_index	function
(	O
sdr_buffer	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
i	int
+	O
1	int
)	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
sdr_buffer	pointer
->	O
base	pointer
,	O
(	O
int	O
)	O
(	O
sdr_buffer	pointer
->	O
contents	long
)	O
,	O
false	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_reset_outbuf	function
(	O
sdr_buffer	pointer
)	O
;	O
}	O
{	O
_cgm_emit_index	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_FONT_PROP_FAMILY	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
build_sdr_from_string	function
(	O
sdr_buffer	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_pl_g_cgm_font_properties	array
[	O
i	int
]	O
.	O
family	pointer
,	O
(	O
int	O
)	O
(	O
strlen	function
(	O
_pl_g_cgm_font_properties	array
[	O
i	int
]	O
.	O
family	pointer
)	O
)	O
,	O
true	int
)	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
sdr_buffer	pointer
->	O
base	pointer
,	O
(	O
int	O
)	O
(	O
sdr_buffer	pointer
->	O
contents	long
)	O
,	O
false	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_reset_outbuf	function
(	O
sdr_buffer	pointer
)	O
;	O
}	O
{	O
_cgm_emit_index	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_FONT_PROP_POSTURE	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
build_sdr_from_index	function
(	O
sdr_buffer	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_pl_g_cgm_font_properties	array
[	O
i	int
]	O
.	O
posture	int
)	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
sdr_buffer	pointer
->	O
base	pointer
,	O
(	O
int	O
)	O
(	O
sdr_buffer	pointer
->	O
contents	long
)	O
,	O
false	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_reset_outbuf	function
(	O
sdr_buffer	pointer
)	O
;	O
}	O
{	O
_cgm_emit_index	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_FONT_PROP_WEIGHT	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
build_sdr_from_index	function
(	O
sdr_buffer	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_pl_g_cgm_font_properties	array
[	O
i	int
]	O
.	O
weight	int
)	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
sdr_buffer	pointer
->	O
base	pointer
,	O
(	O
int	O
)	O
(	O
sdr_buffer	pointer
->	O
contents	long
)	O
,	O
false	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_reset_outbuf	function
(	O
sdr_buffer	pointer
)	O
;	O
}	O
{	O
_cgm_emit_index	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_FONT_PROP_WIDTH	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
build_sdr_from_index	function
(	O
sdr_buffer	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_pl_g_cgm_font_properties	array
[	O
i	int
]	O
.	O
proportionate_width	int
)	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
sdr_buffer	pointer
->	O
base	pointer
,	O
(	O
int	O
)	O
(	O
sdr_buffer	pointer
->	O
contents	long
)	O
,	O
false	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_reset_outbuf	function
(	O
sdr_buffer	pointer
)	O
;	O
}	O
{	O
_cgm_emit_index	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_FONT_PROP_DESIGN_GROUP	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
build_sdr_from_ui8s	function
(	O
sdr_buffer	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_pl_g_cgm_font_properties	array
[	O
i	int
]	O
.	O
design_group	array
,	O
3	int
)	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
sdr_buffer	pointer
->	O
base	pointer
,	O
(	O
int	O
)	O
(	O
sdr_buffer	pointer
->	O
contents	long
)	O
,	O
false	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_reset_outbuf	function
(	O
sdr_buffer	pointer
)	O
;	O
}	O
{	O
_cgm_emit_index	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_FONT_PROP_STRUCTURE	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
build_sdr_from_index	function
(	O
sdr_buffer	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_pl_g_cgm_font_properties	array
[	O
i	int
]	O
.	O
structure	int
)	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
sdr_buffer	pointer
->	O
base	pointer
,	O
(	O
int	O
)	O
(	O
sdr_buffer	pointer
->	O
contents	long
)	O
,	O
false	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_reset_outbuf	function
(	O
sdr_buffer	pointer
)	O
;	O
}	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
_delete_outbuf	function
(	O
sdr_buffer	pointer
)	O
;	O
}	O
}	O
data_len	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
int	O
tail_length	int
,	O
encoded_tail_length	int
;	O
data_len	int
+=	O
2	int
;	O
tail_length	int
=	O
strlen	function
(	O
_iso_latin_1_cgm_charset	array
[	O
i	int
]	O
.	O
tail	pointer
)	O
;	O
encoded_tail_length	int
=	O
CGM_BINARY_BYTES_PER_STRING	O
(	O
tail_length	int
)	O
;	O
data_len	int
+=	O
encoded_tail_length	int
;	O
}	O
if	O
(	O
symbol_font_used_in_doc	enum
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
int	O
tail_length	int
,	O
encoded_tail_length	int
;	O
data_len	int
+=	O
2	int
;	O
tail_length	int
=	O
(	O
int	O
)	O
strlen	function
(	O
_symbol_cgm_charset	array
[	O
i	int
]	O
.	O
tail	pointer
)	O
;	O
encoded_tail_length	int
=	O
CGM_BINARY_BYTES_PER_STRING	O
(	O
tail_length	int
)	O
;	O
data_len	int
+=	O
encoded_tail_length	int
;	O
}	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
14	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"CHARSETLIST"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
_cgm_emit_enum	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_iso_latin_1_cgm_charset	array
[	O
i	int
]	O
.	O
type	enum
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
_iso_latin_1_cgm_charset	array
[	O
i	int
]	O
.	O
type_string	pointer
)	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_iso_latin_1_cgm_charset	array
[	O
i	int
]	O
.	O
tail	pointer
,	O
(	O
int	O
)	O
strlen	function
(	O
_iso_latin_1_cgm_charset	array
[	O
i	int
]	O
.	O
tail	pointer
)	O
,	O
true	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
if	O
(	O
symbol_font_used_in_doc	enum
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
_cgm_emit_enum	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_symbol_cgm_charset	array
[	O
i	int
]	O
.	O
type	enum
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
_symbol_cgm_charset	array
[	O
i	int
]	O
.	O
type_string	pointer
)	O
;	O
_cgm_emit_string	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
_symbol_cgm_charset	array
[	O
i	int
]	O
.	O
tail	pointer
,	O
(	O
int	O
)	O
strlen	function
(	O
_symbol_cgm_charset	array
[	O
i	int
]	O
.	O
tail	pointer
)	O
,	O
true	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_METAFILE_DESCRIPTOR_ELEMENT	int
,	O
15	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"CHARCODING"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
doc_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"basic8bit"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
doc_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
_write_bytes	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
(	O
int	O
)	O
(	O
doc_header	pointer
->	O
contents	long
)	O
,	O
(	O
unsigned	O
char	O
*	O
)	O
doc_header	pointer
->	O
base	pointer
)	O
;	O
_delete_outbuf	function
(	O
doc_header	pointer
)	O
;	O
current_page	pointer
=	O
_plotter	pointer
->	O
data	pointer
->	O
first_page	pointer
;	O
i	int
=	O
1	int
;	O
while	O
(	O
current_page	pointer
)	O
{	O
plOutbuf	struct
*	O
next_page	pointer
;	O
plOutbuf	struct
*	O
current_page_header	pointer
,	O
*	O
current_page_trailer	pointer
;	O
current_page_header	pointer
=	O
_new_outbuf	function
(	O
)	O
;	O
{	O
char	O
picture	array
[	O
32	int
]	O
;	O
const	O
char	O
*	O
string_param	pointer
;	O
sprintf	function
(	O
picture	array
,	O
"picture_%d"	pointer
,	O
i	int
)	O
;	O
string_param	pointer
=	O
picture	array
;	O
string_length	int
=	O
strlen	function
(	O
string_param	pointer
)	O
;	O
data_len	int
=	O
CGM_BINARY_BYTES_PER_STRING	O
(	O
string_length	int
)	O
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_DELIMITER_ELEMENT	int
,	O
3	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"BEGPIC"	pointer
)	O
;	O
_cgm_emit_string	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
string_param	pointer
,	O
string_length	int
,	O
true	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
int	O
imin_true	int
,	O
imax_true	int
,	O
jmin_true	int
,	O
jmax_true	int
;	O
data_len	int
=	O
2	int
*	O
2	int
*	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_PICTURE_DESCRIPTOR_ELEMENT	int
,	O
6	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"VDCEXT"	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
<	O
_plotter	pointer
->	O
data	pointer
->	O
imin	int
)	O
{	O
imin_true	int
=	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
;	O
imax_true	int
=	O
_plotter	pointer
->	O
data	pointer
->	O
imin	int
;	O
}	O
else	O
{	O
imin_true	int
=	O
_plotter	pointer
->	O
data	pointer
->	O
imin	int
;	O
imax_true	int
=	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
jmax	int
<	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
)	O
{	O
jmin_true	int
=	O
_plotter	pointer
->	O
data	pointer
->	O
jmax	int
;	O
jmax_true	int
=	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
;	O
}	O
else	O
{	O
jmin_true	int
=	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
;	O
jmax_true	int
=	O
_plotter	pointer
->	O
data	pointer
->	O
jmax	int
;	O
}	O
_cgm_emit_index	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
imin_true	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_index	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
jmin_true	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_index	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
imax_true	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_index	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
jmax_true	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
int	O
irange	int
,	O
jrange	int
;	O
double	O
scaling_factor	double
;	O
data_len	int
=	O
6	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_PICTURE_DESCRIPTOR_ELEMENT	int
,	O
1	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"SCALEMODE"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"metric"	pointer
)	O
;	O
irange	int
=	O
_plotter	pointer
->	O
data	pointer
->	O
imax	int
-	O
_plotter	pointer
->	O
data	pointer
->	O
imin	int
;	O
jrange	int
=	O
_plotter	pointer
->	O
data	pointer
->	O
jmax	int
-	O
_plotter	pointer
->	O
data	pointer
->	O
jmin	int
;	O
if	O
(	O
irange	int
!=	O
0	int
)	O
scaling_factor	double
=	O
(	O
25.4	int
*	O
_plotter	pointer
->	O
data	pointer
->	O
viewport_xsize	double
)	O
/	O
irange	int
;	O
else	O
if	O
(	O
jrange	int
!=	O
0	int
)	O
scaling_factor	double
=	O
(	O
25.4	int
*	O
_plotter	pointer
->	O
data	pointer
->	O
viewport_ysize	double
)	O
/	O
jrange	int
;	O
else	O
scaling_factor	double
=	O
0.0	int
;	O
_cgm_emit_real_floating_point	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
scaling_factor	double
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_PICTURE_DESCRIPTOR_ELEMENT	int
,	O
3	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"LINEWIDTHMODE"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"abs"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_PICTURE_DESCRIPTOR_ELEMENT	int
,	O
5	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"EDGEWIDTHMODE"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"abs"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_PICTURE_DESCRIPTOR_ELEMENT	int
,	O
4	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"MARKERSIZEMODE"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
0	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"abs"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_PICTURE_DESCRIPTOR_ELEMENT	int
,	O
2	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"COLRMODE"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
1	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"direct"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
if	O
(	O
current_page	pointer
->	O
bg_color_suppressed	enum
==	O
false	int
)	O
{	O
data_len	int
=	O
3	int
*	O
CGM_BINARY_BYTES_PER_COLOR_COMPONENT	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_PICTURE_DESCRIPTOR_ELEMENT	int
,	O
7	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"BACKCOLR"	pointer
)	O
;	O
_cgm_emit_color_component	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
(	O
unsigned	O
int	O
)	O
current_page	pointer
->	O
bg_color	struct
.	O
red	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_color_component	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
(	O
unsigned	O
int	O
)	O
current_page	pointer
->	O
bg_color	struct
.	O
green	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_color_component	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
(	O
unsigned	O
int	O
)	O
current_page	pointer
->	O
bg_color	struct
.	O
blue	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
plCGMCustomLineType	struct
*	O
linetype_ptr	pointer
=	O
(	O
plCGMCustomLineType	struct
*	O
)	O
current_page	pointer
->	O
extra	pointer
;	O
int	O
linetype	int
=	O
0	int
;	O
while	O
(	O
linetype_ptr	pointer
)	O
{	O
int	O
k	int
,	O
cycle_length	int
,	O
dash_array_len	int
,	O
*	O
dash_array	pointer
;	O
linetype	int
--	O
;	O
dash_array_len	int
=	O
linetype_ptr	pointer
->	O
dash_array_len	int
;	O
dash_array	pointer
=	O
linetype_ptr	pointer
->	O
dashes	pointer
;	O
cycle_length	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
dash_array_len	int
;	O
k	int
++	O
)	O
cycle_length	int
+=	O
dash_array	pointer
[	O
k	int
]	O
;	O
data_len	int
=	O
2	int
+	O
(	O
1	int
+	O
dash_array_len	int
)	O
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_PICTURE_DESCRIPTOR_ELEMENT	int
,	O
17	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"LINEEDGETYPEDEF"	pointer
)	O
;	O
_cgm_emit_index	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
linetype	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
cycle_length	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
dash_array_len	int
;	O
k	int
++	O
)	O
_cgm_emit_integer	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
dash_array	pointer
[	O
k	int
]	O
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
linetype_ptr	pointer
=	O
linetype_ptr	pointer
->	O
next	pointer
;	O
}	O
}	O
{	O
data_len	int
=	O
0	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_DELIMITER_ELEMENT	int
,	O
4	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"BEGPICBODY"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
{	O
int	O
j	int
,	O
max_int	int
;	O
data_len	int
=	O
CGM_BINARY_BYTES_PER_INTEGER	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_CONTROL_ELEMENT	int
,	O
1	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"VDCINTEGERPREC"	pointer
)	O
;	O
switch	O
(	O
_plotter	pointer
->	O
cgm_encoding	int
)	O
{	O
case	O
CGM_ENCODING_BINARY	int
:	O
default	O
:	O
_cgm_emit_integer	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
break	O
;	O
case	O
CGM_ENCODING_CHARACTER	int
:	O
break	O
;	O
case	O
CGM_ENCODING_CLEAR_TEXT	int
:	O
max_int	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
(	O
8	int
*	O
CGM_BINARY_BYTES_PER_INTEGER	int
-	O
1	int
)	O
;	O
j	int
++	O
)	O
max_int	int
+=	O
(	O
1	int
<<	O
j	int
)	O
;	O
_cgm_emit_integer	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
-	O
max_int	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
_cgm_emit_integer	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
max_int	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
)	O
;	O
break	O
;	O
}	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
if	O
(	O
doc_uses_fonts	enum
)	O
{	O
data_len	int
=	O
2	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_ATTRIBUTE_ELEMENT	int
,	O
11	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"TEXTPREC"	pointer
)	O
;	O
_cgm_emit_enum	function
(	O
current_page_header	pointer
,	O
false	int
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
2	int
,	O
data_len	int
,	O
&	O
data_byte_count	pointer
,	O
&	O
byte_count	pointer
,	O
"stroke"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_header	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
_write_bytes	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
(	O
int	O
)	O
(	O
current_page_header	pointer
->	O
contents	long
)	O
,	O
(	O
unsigned	O
char	O
*	O
)	O
current_page_header	pointer
->	O
base	pointer
)	O
;	O
_delete_outbuf	function
(	O
current_page_header	pointer
)	O
;	O
_write_bytes	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
(	O
int	O
)	O
(	O
current_page	pointer
->	O
contents	long
)	O
,	O
(	O
unsigned	O
char	O
*	O
)	O
current_page	pointer
->	O
base	pointer
)	O
;	O
current_page_trailer	pointer
=	O
_new_outbuf	function
(	O
)	O
;	O
{	O
data_len	int
=	O
0	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
current_page_trailer	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_DELIMITER_ELEMENT	int
,	O
5	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"ENDPIC"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
current_page_trailer	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
_write_bytes	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
(	O
int	O
)	O
(	O
current_page_trailer	pointer
->	O
contents	long
)	O
,	O
(	O
unsigned	O
char	O
*	O
)	O
current_page_trailer	pointer
->	O
base	pointer
)	O
;	O
_delete_outbuf	function
(	O
current_page_trailer	pointer
)	O
;	O
next_page	pointer
=	O
current_page	pointer
->	O
next	pointer
;	O
current_page	pointer
=	O
next_page	pointer
;	O
i	int
++	O
;	O
}	O
doc_trailer	pointer
=	O
_new_outbuf	function
(	O
)	O
;	O
{	O
data_len	int
=	O
0	int
;	O
byte_count	pointer
=	O
data_byte_count	pointer
=	O
0	int
;	O
_cgm_emit_command_header	function
(	O
doc_trailer	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
CGM_DELIMITER_ELEMENT	int
,	O
2	int
,	O
data_len	int
,	O
&	O
byte_count	pointer
,	O
"ENDMF"	pointer
)	O
;	O
_cgm_emit_command_terminator	function
(	O
doc_trailer	pointer
,	O
_plotter	pointer
->	O
cgm_encoding	int
,	O
&	O
byte_count	pointer
)	O
;	O
}	O
_write_bytes	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
(	O
int	O
)	O
(	O
doc_trailer	pointer
->	O
contents	long
)	O
,	O
(	O
unsigned	O
char	O
*	O
)	O
doc_trailer	pointer
->	O
base	pointer
)	O
;	O
_delete_outbuf	function
(	O
doc_trailer	pointer
)	O
;	O
}	O
current_page	pointer
=	O
_plotter	pointer
->	O
data	pointer
->	O
first_page	pointer
;	O
while	O
(	O
current_page	pointer
)	O
{	O
plOutbuf	struct
*	O
next_page	pointer
;	O
next_page	pointer
=	O
current_page	pointer
->	O
next	pointer
;	O
if	O
(	O
current_page	pointer
->	O
extra	pointer
)	O
{	O
plCGMCustomLineType	struct
*	O
linetype_ptr	pointer
=	O
(	O
plCGMCustomLineType	struct
*	O
)	O
current_page	pointer
->	O
extra	pointer
;	O
plCGMCustomLineType	struct
*	O
old_linetype_ptr	pointer
;	O
while	O
(	O
linetype_ptr	pointer
)	O
{	O
if	O
(	O
linetype_ptr	pointer
->	O
dash_array_len	int
>	O
0	int
&&	O
linetype_ptr	pointer
->	O
dashes	pointer
)	O
free	function
(	O
linetype_ptr	pointer
->	O
dashes	pointer
)	O
;	O
old_linetype_ptr	pointer
=	O
linetype_ptr	pointer
;	O
linetype_ptr	pointer
=	O
linetype_ptr	pointer
->	O
next	pointer
;	O
free	function
(	O
old_linetype_ptr	pointer
)	O
;	O
}	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
extra	pointer
=	O
(	O
void	O
*	O
)	O
NULL	O
;	O
}	O
_delete_outbuf	function
(	O
current_page	pointer
)	O
;	O
current_page	pointer
=	O
next_page	pointer
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
{	O
if	O
(	O
fflush	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
outfp	pointer
)	O
<	O
0	int
)	O
_plotter	pointer
->	O
error	pointer
(	O
R___	O
(	O
_plotter	pointer
)	O
"the output stream is jammed"	pointer
)	O
;	O
}	O
_pl_g_terminate	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
}	O
static	O
void	O
build_sdr_from_index	function
(	O
plOutbuf	struct
*	O
sdr_buffer	pointer
,	O
int	O
cgm_encoding	int
,	O
int	O
x	double
)	O
{	O
int	O
dummy_data_len	int
,	O
dummy_data_byte_count	int
,	O
dummy_byte_count	int
;	O
dummy_data_len	int
=	O
dummy_data_byte_count	int
=	O
dummy_byte_count	int
=	O
0	int
;	O
_cgm_emit_index	function
(	O
sdr_buffer	pointer
,	O
true	int
,	O
cgm_encoding	int
,	O
CGM_SDR_DATATYPE_INDEX	int
,	O
dummy_data_len	int
,	O
&	O
dummy_data_byte_count	int
,	O
&	O
dummy_byte_count	int
)	O
;	O
_cgm_emit_integer	function
(	O
sdr_buffer	pointer
,	O
true	int
,	O
cgm_encoding	int
,	O
1	int
,	O
dummy_data_len	int
,	O
&	O
dummy_data_byte_count	int
,	O
&	O
dummy_byte_count	int
)	O
;	O
_cgm_emit_index	function
(	O
sdr_buffer	pointer
,	O
true	int
,	O
cgm_encoding	int
,	O
x	double
,	O
dummy_data_len	int
,	O
&	O
dummy_data_byte_count	int
,	O
&	O
dummy_byte_count	int
)	O
;	O
}	O
static	O
void	O
build_sdr_from_string	function
(	O
plOutbuf	struct
*	O
sdr_buffer	pointer
,	O
int	O
cgm_encoding	int
,	O
const	O
char	O
*	O
s	pointer
,	O
int	O
string_length	int
,	O
bool	enum
use_double_quotes	enum
)	O
{	O
int	O
dummy_data_len	int
,	O
dummy_data_byte_count	int
,	O
dummy_byte_count	int
;	O
dummy_data_len	int
=	O
dummy_data_byte_count	int
=	O
dummy_byte_count	int
=	O
0	int
;	O
_cgm_emit_index	function
(	O
sdr_buffer	pointer
,	O
true	int
,	O
cgm_encoding	int
,	O
CGM_SDR_DATATYPE_STRING_FIXED	int
,	O
dummy_data_len	int
,	O
&	O
dummy_data_byte_count	int
,	O
&	O
dummy_byte_count	int
)	O
;	O
_cgm_emit_integer	function
(	O
sdr_buffer	pointer
,	O
true	int
,	O
cgm_encoding	int
,	O
1	int
,	O
dummy_data_len	int
,	O
&	O
dummy_data_byte_count	int
,	O
&	O
dummy_byte_count	int
)	O
;	O
_cgm_emit_string	function
(	O
sdr_buffer	pointer
,	O
true	int
,	O
cgm_encoding	int
,	O
s	pointer
,	O
string_length	int
,	O
use_double_quotes	enum
,	O
dummy_data_len	int
,	O
&	O
dummy_data_byte_count	int
,	O
&	O
dummy_byte_count	int
)	O
;	O
}	O
static	O
void	O
build_sdr_from_ui8s	function
(	O
plOutbuf	struct
*	O
sdr_buffer	pointer
,	O
int	O
cgm_encoding	int
,	O
const	O
int	O
*	O
x	double
,	O
int	O
n	array
)	O
{	O
int	O
i	int
,	O
dummy_data_len	int
,	O
dummy_data_byte_count	int
,	O
dummy_byte_count	int
;	O
dummy_data_len	int
=	O
dummy_data_byte_count	int
=	O
dummy_byte_count	int
=	O
0	int
;	O
_cgm_emit_index	function
(	O
sdr_buffer	pointer
,	O
true	int
,	O
cgm_encoding	int
,	O
CGM_SDR_DATATYPE_UNSIGNED_INTEGER_8BIT	int
,	O
dummy_data_len	int
,	O
&	O
dummy_data_byte_count	int
,	O
&	O
dummy_byte_count	int
)	O
;	O
_cgm_emit_integer	function
(	O
sdr_buffer	pointer
,	O
true	int
,	O
cgm_encoding	int
,	O
n	array
,	O
dummy_data_len	int
,	O
&	O
dummy_data_byte_count	int
,	O
&	O
dummy_byte_count	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	array
;	O
i	int
++	O
)	O
_cgm_emit_unsigned_integer_8bit	function
(	O
sdr_buffer	pointer
,	O
true	int
,	O
cgm_encoding	int
,	O
(	O
unsigned	O
int	O
)	O
(	O
x	double
[	O
i	int
]	O
)	O
,	O
dummy_data_len	int
,	O
&	O
dummy_data_byte_count	int
,	O
&	O
dummy_byte_count	int
)	O
;	O
}	O
