static	O
int	O
debug_flag	int
=	O
0	int
;	O
static	O
int	O
debug_error	int
=	O
0	int
;	O
static	O
char	O
*	O
menu	pointer
=	O
NULL	O
;	O
int	O
check_format_view	function
(	O
const	O
char	O
*	O
p	pointer
)	O
{	O
const	O
char	O
*	O
q	pointer
=	O
p	pointer
;	O
if	O
(	O
!	O
strncmp	function
(	O
p	pointer
,	O
"view"	pointer
,	O
4	int
)	O
)	O
{	O
q	pointer
+=	O
4	int
;	O
if	O
(	O
*	O
q	pointer
==	O
'{'	O
)	O
{	O
for	O
(	O
q	pointer
++	O
;	O
*	O
q	pointer
&&	O
*	O
q	pointer
!=	O
'}'	O
;	O
q	pointer
++	O
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
q	pointer
,	O
"ascii"	pointer
,	O
5	int
)	O
)	O
{	O
default_hex_mode	int
=	O
0	int
;	O
q	pointer
+=	O
4	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
q	pointer
,	O
"hex"	pointer
,	O
3	int
)	O
)	O
{	O
default_hex_mode	int
=	O
1	int
;	O
q	pointer
+=	O
2	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
q	pointer
,	O
"nroff"	pointer
,	O
5	int
)	O
)	O
{	O
default_nroff_flag	int
=	O
1	int
;	O
q	pointer
+=	O
4	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
q	pointer
,	O
"unform"	pointer
,	O
6	int
)	O
)	O
{	O
default_nroff_flag	int
=	O
0	int
;	O
q	pointer
+=	O
5	int
;	O
}	O
}	O
if	O
(	O
*	O
q	pointer
==	O
'}'	O
)	O
q	pointer
++	O
;	O
}	O
return	O
q	pointer
-	O
p	pointer
;	O
}	O
return	O
0	int
;	O
}	O
int	O
check_format_cd	function
(	O
const	O
char	O
*	O
p	pointer
)	O
{	O
return	O
(	O
strncmp	function
(	O
p	pointer
,	O
"cd"	pointer
,	O
2	int
)	O
)	O
?	O
0	int
:	O
3	int
;	O
}	O
int	O
check_format_var	function
(	O
const	O
char	O
*	O
p	pointer
,	O
char	O
*	O
*	O
v	pointer
)	O
{	O
const	O
char	O
*	O
q	pointer
=	O
p	pointer
;	O
char	O
*	O
var_name	pointer
;	O
const	O
char	O
*	O
value	pointer
;	O
const	O
char	O
*	O
dots	pointer
=	O
0	int
;	O
*	O
v	pointer
=	O
0	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
p	pointer
,	O
"var{"	pointer
,	O
4	int
)	O
)	O
{	O
for	O
(	O
q	pointer
+=	O
4	int
;	O
*	O
q	pointer
&&	O
*	O
q	pointer
!=	O
'}'	O
;	O
q	pointer
++	O
)	O
{	O
if	O
(	O
*	O
q	pointer
==	O
':'	O
)	O
dots	pointer
=	O
q	pointer
+	O
1	int
;	O
}	O
if	O
(	O
!	O
*	O
q	pointer
)	O
return	O
0	int
;	O
if	O
(	O
!	O
dots	pointer
||	O
dots	pointer
==	O
q	pointer
+	O
5	int
)	O
{	O
message	pointer
(	O
1	int
,	O
_	O
(	O
" Format error on file Extensions File "	pointer
)	O
,	O
!	O
dots	pointer
?	O
_	O
(	O
" The %%var macro has no default "	pointer
)	O
:	O
_	O
(	O
" The %%var macro has no variable "	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
var_name	pointer
=	O
g_strndup	function
(	O
p	pointer
+	O
4	int
,	O
dots	pointer
-	O
2	int
-	O
(	O
p	pointer
+	O
3	int
)	O
)	O
;	O
value	pointer
=	O
getenv	function
(	O
var_name	pointer
)	O
;	O
g_free	function
(	O
var_name	pointer
)	O
;	O
if	O
(	O
value	pointer
)	O
{	O
*	O
v	pointer
=	O
g_strdup	function
(	O
value	pointer
)	O
;	O
return	O
q	pointer
-	O
p	pointer
;	O
}	O
var_name	pointer
=	O
g_strndup	function
(	O
dots	pointer
,	O
q	pointer
-	O
dots	pointer
)	O
;	O
*	O
v	pointer
=	O
var_name	pointer
;	O
return	O
q	pointer
-	O
p	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
strip_ext	function
(	O
char	O
*	O
ss	pointer
)	O
{	O
register	O
char	O
*	O
s	pointer
=	O
ss	pointer
;	O
char	O
*	O
e	pointer
=	O
NULL	O
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
'.'	O
)	O
e	pointer
=	O
s	pointer
;	O
if	O
(	O
*	O
s	pointer
==	O
PATH_SEP	char
&&	O
e	pointer
)	O
e	pointer
=	O
NULL	O
;	O
s	pointer
++	O
;	O
}	O
if	O
(	O
e	pointer
)	O
*	O
e	pointer
=	O
0	int
;	O
return	O
ss	pointer
;	O
}	O
char	O
*	O
expand_format	function
(	O
struct	O
WEdit	struct
*	O
edit_widget	pointer
,	O
char	O
c	int
,	O
int	O
quote	int
)	O
{	O
WPanel	struct
*	O
panel	pointer
=	O
NULL	O
;	O
char	O
*	O
(	O
*	O
quote_func	pointer
)	O
(	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
char	O
*	O
fname	pointer
;	O
char	O
*	O
result	long
;	O
char	O
c_lc	char
;	O
if	O
(	O
c	int
==	O
'%'	O
)	O
return	O
g_strdup	function
(	O
"%"	pointer
)	O
;	O
if	O
(	O
edit_one_file	pointer
!=	O
NULL	O
)	O
fname	pointer
=	O
edit_widget	pointer
->	O
filename	pointer
;	O
else	O
{	O
if	O
(	O
islower	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
)	O
panel	pointer
=	O
current_panel	pointer
;	O
else	O
{	O
if	O
(	O
get_other_type	function
(	O
)	O
!=	O
view_listing	int
)	O
return	O
g_strdup	function
(	O
""	pointer
)	O
;	O
panel	pointer
=	O
other_panel	O
;	O
}	O
fname	pointer
=	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
panel	pointer
->	O
selected	int
]	O
.	O
fname	pointer
;	O
}	O
if	O
(	O
quote	int
)	O
quote_func	pointer
=	O
name_quote	function
;	O
else	O
quote_func	pointer
=	O
fake_name_quote	function
;	O
c_lc	char
=	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
c	int
)	O
;	O
switch	O
(	O
c_lc	char
)	O
{	O
case	O
'f'	O
:	O
case	O
'p'	O
:	O
return	O
(	O
*	O
quote_func	pointer
)	O
(	O
fname	pointer
,	O
0	int
)	O
;	O
case	O
'x'	O
:	O
return	O
(	O
*	O
quote_func	pointer
)	O
(	O
extension	function
(	O
fname	pointer
)	O
,	O
0	int
)	O
;	O
case	O
'd'	O
:	O
{	O
char	O
*	O
cwd	short
;	O
char	O
*	O
qstr	pointer
;	O
cwd	short
=	O
g_malloc	function
(	O
MC_MAXPATHLEN	O
+	O
1	int
)	O
;	O
if	O
(	O
panel	pointer
)	O
g_strlcpy	function
(	O
cwd	short
,	O
panel	pointer
->	O
cwd	short
,	O
MC_MAXPATHLEN	O
+	O
1	int
)	O
;	O
else	O
mc_get_current_wd	function
(	O
cwd	short
,	O
MC_MAXPATHLEN	O
+	O
1	int
)	O
;	O
qstr	pointer
=	O
(	O
*	O
quote_func	pointer
)	O
(	O
cwd	short
,	O
0	int
)	O
;	O
g_free	function
(	O
cwd	short
)	O
;	O
return	O
qstr	pointer
;	O
}	O
case	O
'i'	O
:	O
if	O
(	O
edit_widget	pointer
)	O
return	O
g_strnfill	function
(	O
edit_widget	pointer
->	O
curs_col	long
,	O
' '	O
)	O
;	O
break	O
;	O
case	O
'y'	O
:	O
if	O
(	O
edit_widget	pointer
&&	O
edit_widget	pointer
->	O
syntax_type	pointer
)	O
return	O
g_strdup	function
(	O
edit_widget	pointer
->	O
syntax_type	pointer
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
case	O
'b'	O
:	O
{	O
if	O
(	O
edit_widget	pointer
)	O
{	O
char	O
*	O
file	pointer
=	O
g_strconcat	function
(	O
home_dir	pointer
,	O
PATH_SEP_STR	pointer
BLOCK_FILE	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
fname	pointer
=	O
(	O
*	O
quote_func	pointer
)	O
(	O
file	pointer
,	O
0	int
)	O
;	O
g_free	function
(	O
file	pointer
)	O
;	O
return	O
fname	pointer
;	O
}	O
else	O
if	O
(	O
c_lc	char
==	O
'b'	O
)	O
{	O
return	O
strip_ext	function
(	O
(	O
*	O
quote_func	pointer
)	O
(	O
fname	pointer
,	O
0	int
)	O
)	O
;	O
}	O
break	O
;	O
}	O
case	O
'n'	O
:	O
if	O
(	O
edit_widget	pointer
)	O
return	O
strip_ext	function
(	O
(	O
*	O
quote_func	pointer
)	O
(	O
fname	pointer
,	O
0	int
)	O
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
if	O
(	O
menu	pointer
)	O
return	O
(	O
*	O
quote_func	pointer
)	O
(	O
menu	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
!	O
panel	pointer
||	O
!	O
panel	pointer
->	O
marked	int
)	O
return	O
(	O
*	O
quote_func	pointer
)	O
(	O
fname	pointer
,	O
0	int
)	O
;	O
case	O
't'	O
:	O
case	O
'u'	O
:	O
{	O
int	O
length	int
=	O
2	int
,	O
i	array
;	O
char	O
*	O
block	int
,	O
*	O
tmp	pointer
;	O
if	O
(	O
!	O
panel	pointer
)	O
return	O
g_strdup	function
(	O
""	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
panel	pointer
->	O
count	int
;	O
i	array
++	O
)	O
if	O
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
)	O
length	int
+=	O
strlen	function
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
)	O
+	O
1	int
;	O
block	int
=	O
g_malloc	function
(	O
length	int
*	O
2	int
+	O
1	int
)	O
;	O
*	O
block	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
panel	pointer
->	O
count	int
;	O
i	array
++	O
)	O
if	O
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
)	O
{	O
strcat	function
(	O
block	int
,	O
tmp	pointer
=	O
(	O
*	O
quote_func	pointer
)	O
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
,	O
0	int
)	O
)	O
;	O
g_free	function
(	O
tmp	pointer
)	O
;	O
strcat	function
(	O
block	int
,	O
" "	pointer
)	O
;	O
if	O
(	O
c_lc	char
==	O
'u'	O
)	O
do_file_mark	function
(	O
panel	pointer
,	O
i	array
,	O
0	int
)	O
;	O
}	O
return	O
block	int
;	O
}	O
}	O
result	long
=	O
g_strdup	function
(	O
"% "	pointer
)	O
;	O
result	long
[	O
1	int
]	O
=	O
c	int
;	O
return	O
result	long
;	O
}	O
static	O
char	O
*	O
check_patterns	function
(	O
char	O
*	O
p	pointer
)	O
{	O
static	O
const	O
char	O
def_name	array
[	O
]	O
=	O
"shell_patterns="	pointer
;	O
char	O
*	O
p0	pointer
=	O
p	pointer
;	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
def_name	array
,	O
sizeof	O
(	O
def_name	array
)	O
-	O
1	int
)	O
!=	O
0	int
)	O
return	O
p0	pointer
;	O
p	pointer
+=	O
sizeof	O
(	O
def_name	array
)	O
-	O
1	int
;	O
if	O
(	O
*	O
p	pointer
==	O
'1'	O
)	O
easy_patterns	int
=	O
1	int
;	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'0'	O
)	O
easy_patterns	int
=	O
0	int
;	O
else	O
return	O
p0	pointer
;	O
p	pointer
++	O
;	O
while	O
(	O
*	O
p	pointer
==	O
'\n'	O
||	O
*	O
p	pointer
==	O
'\t'	O
||	O
*	O
p	pointer
==	O
' '	O
)	O
p	pointer
++	O
;	O
return	O
p	pointer
;	O
}	O
static	O
char	O
*	O
extract_arg	function
(	O
char	O
*	O
p	pointer
,	O
char	O
*	O
arg	pointer
,	O
int	O
size	long
)	O
{	O
while	O
(	O
*	O
p	pointer
&&	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
)	O
p	pointer
++	O
;	O
while	O
(	O
size	long
>	O
1	int
&&	O
*	O
p	pointer
&&	O
(	O
*	O
p	pointer
!=	O
' '	O
||	O
*	O
(	O
p	pointer
-	O
1	int
)	O
==	O
'\\'	O
)	O
&&	O
*	O
p	pointer
!=	O
'\t'	O
&&	O
*	O
p	pointer
!=	O
'\n'	O
)	O
{	O
*	O
arg	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
size	long
--	O
;	O
}	O
*	O
arg	pointer
=	O
0	int
;	O
if	O
(	O
!	O
*	O
p	pointer
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
p	pointer
--	O
;	O
return	O
p	pointer
;	O
}	O
static	O
int	O
test_type	function
(	O
WPanel	struct
*	O
panel	pointer
,	O
char	O
*	O
arg	pointer
)	O
{	O
int	O
result	long
=	O
0	int
;	O
int	O
st_mode	int
=	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
panel	pointer
->	O
selected	int
]	O
.	O
st	pointer
.	O
st_mode	int
;	O
for	O
(	O
;	O
*	O
arg	pointer
!=	O
0	int
;	O
arg	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
arg	pointer
)	O
{	O
case	O
'n'	O
:	O
result	long
|=	O
!	O
S_ISDIR	O
(	O
st_mode	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
result	long
|=	O
S_ISREG	O
(	O
st_mode	int
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
result	long
|=	O
S_ISDIR	O
(	O
st_mode	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
result	long
|=	O
S_ISLNK	O
(	O
st_mode	int
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
result	long
|=	O
S_ISCHR	O
(	O
st_mode	int
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
result	long
|=	O
S_ISBLK	O
(	O
st_mode	int
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
result	long
|=	O
S_ISFIFO	O
(	O
st_mode	int
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
result	long
|=	O
S_ISSOCK	O
(	O
st_mode	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
result	long
|=	O
(	O
st_mode	int
&	O
0111	int
)	O
?	O
1	int
:	O
0	int
;	O
break	O
;	O
case	O
't'	O
:	O
result	long
|=	O
panel	pointer
->	O
marked	int
?	O
1	int
:	O
0	int
;	O
break	O
;	O
default	O
:	O
debug_error	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
return	O
result	long
;	O
}	O
static	O
char	O
*	O
test_condition	function
(	O
WEdit	struct
*	O
edit_widget	pointer
,	O
char	O
*	O
p	pointer
,	O
int	O
*	O
condition	enum
)	O
{	O
WPanel	struct
*	O
panel	pointer
;	O
char	O
arg	pointer
[	O
256	int
]	O
;	O
for	O
(	O
;	O
*	O
p	pointer
!=	O
'\n'	O
&&	O
*	O
p	pointer
!=	O
'&'	O
&&	O
*	O
p	pointer
!=	O
'|'	O
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
(	O
*	O
p	pointer
==	O
' '	O
&&	O
*	O
(	O
p	pointer
-	O
1	int
)	O
!=	O
'\\'	O
)	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
continue	O
;	O
if	O
(	O
*	O
p	pointer
>=	O
'a'	O
)	O
panel	pointer
=	O
current_panel	pointer
;	O
else	O
{	O
if	O
(	O
get_other_type	function
(	O
)	O
==	O
view_listing	int
)	O
panel	pointer
=	O
other_panel	O
;	O
else	O
panel	pointer
=	O
NULL	O
;	O
}	O
*	O
p	pointer
|=	O
0x20	int
;	O
switch	O
(	O
*	O
p	pointer
++	O
)	O
{	O
case	O
'!'	O
:	O
p	pointer
=	O
test_condition	function
(	O
edit_widget	pointer
,	O
p	pointer
,	O
condition	enum
)	O
;	O
*	O
condition	enum
=	O
!	O
*	O
condition	enum
;	O
p	pointer
--	O
;	O
break	O
;	O
case	O
'f'	O
:	O
p	pointer
=	O
extract_arg	function
(	O
p	pointer
,	O
arg	pointer
,	O
sizeof	O
(	O
arg	pointer
)	O
)	O
;	O
*	O
condition	enum
=	O
panel	pointer
&&	O
regexp_match	function
(	O
arg	pointer
,	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
panel	pointer
->	O
selected	int
]	O
.	O
fname	pointer
,	O
match_file	int
)	O
;	O
break	O
;	O
case	O
'y'	O
:	O
if	O
(	O
edit_widget	pointer
&&	O
edit_widget	pointer
->	O
syntax_type	pointer
)	O
{	O
p	pointer
=	O
extract_arg	function
(	O
p	pointer
,	O
arg	pointer
,	O
sizeof	O
(	O
arg	pointer
)	O
)	O
;	O
*	O
condition	enum
=	O
panel	pointer
&&	O
regexp_match	function
(	O
arg	pointer
,	O
edit_widget	pointer
->	O
syntax_type	pointer
,	O
match_normal	int
)	O
;	O
}	O
break	O
;	O
case	O
'd'	O
:	O
p	pointer
=	O
extract_arg	function
(	O
p	pointer
,	O
arg	pointer
,	O
sizeof	O
(	O
arg	pointer
)	O
)	O
;	O
*	O
condition	enum
=	O
panel	pointer
&&	O
regexp_match	function
(	O
arg	pointer
,	O
panel	pointer
->	O
cwd	short
,	O
match_file	int
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
p	pointer
=	O
extract_arg	function
(	O
p	pointer
,	O
arg	pointer
,	O
sizeof	O
(	O
arg	pointer
)	O
)	O
;	O
*	O
condition	enum
=	O
panel	pointer
&&	O
test_type	function
(	O
panel	pointer
,	O
arg	pointer
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
{	O
struct	O
stat	struct
status	int
;	O
p	pointer
=	O
extract_arg	function
(	O
p	pointer
,	O
arg	pointer
,	O
sizeof	O
(	O
arg	pointer
)	O
)	O
;	O
if	O
(	O
stat	struct
(	O
arg	pointer
,	O
&	O
status	int
)	O
==	O
0	int
)	O
*	O
condition	enum
=	O
is_exe	function
(	O
status	int
.	O
st_mode	int
)	O
;	O
else	O
*	O
condition	enum
=	O
0	int
;	O
break	O
;	O
}	O
default	O
:	O
debug_error	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
return	O
p	pointer
;	O
}	O
static	O
void	O
debug_out	function
(	O
char	O
*	O
start	pointer
,	O
char	O
*	O
end	pointer
,	O
int	O
cond	pointer
)	O
{	O
static	O
char	O
*	O
msg	pointer
;	O
int	O
len	int
;	O
if	O
(	O
start	pointer
==	O
NULL	O
&&	O
end	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
debug_flag	int
&&	O
msg	pointer
)	O
{	O
len	int
=	O
strlen	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
len	int
)	O
msg	pointer
[	O
len	int
-	O
1	int
]	O
=	O
0	int
;	O
message	pointer
(	O
0	int
,	O
_	O
(	O
" Debug "	pointer
)	O
,	O
"%s"	pointer
,	O
msg	pointer
)	O
;	O
}	O
debug_flag	int
=	O
0	int
;	O
g_free	function
(	O
msg	pointer
)	O
;	O
msg	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
const	O
char	O
*	O
type	enum
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
!	O
debug_flag	int
)	O
return	O
;	O
if	O
(	O
debug_error	int
)	O
{	O
type	enum
=	O
_	O
(	O
" ERROR: "	pointer
)	O
;	O
debug_error	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
cond	pointer
)	O
type	enum
=	O
_	O
(	O
" True:  "	pointer
)	O
;	O
else	O
type	enum
=	O
_	O
(	O
" False: "	pointer
)	O
;	O
if	O
(	O
end	pointer
==	O
NULL	O
)	O
p	pointer
=	O
g_strdup_printf	function
(	O
"%s%s%c \n"	pointer
,	O
msg	pointer
?	O
msg	pointer
:	O
""	pointer
,	O
type	enum
,	O
*	O
start	pointer
)	O
;	O
else	O
p	pointer
=	O
g_strdup_printf	function
(	O
"%s%s%.*s \n"	pointer
,	O
msg	pointer
?	O
msg	pointer
:	O
""	pointer
,	O
type	enum
,	O
(	O
int	O
)	O
(	O
end	pointer
-	O
start	pointer
)	O
,	O
start	pointer
)	O
;	O
g_free	function
(	O
msg	pointer
)	O
;	O
msg	pointer
=	O
p	pointer
;	O
}	O
}	O
static	O
char	O
*	O
test_line	function
(	O
WEdit	struct
*	O
edit_widget	pointer
,	O
char	O
*	O
p	pointer
,	O
int	O
*	O
result	long
)	O
{	O
int	O
condition	enum
;	O
char	O
operator	char
;	O
char	O
*	O
debug_start	pointer
,	O
*	O
debug_end	pointer
;	O
while	O
(	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
'\n'	O
)	O
{	O
while	O
(	O
(	O
*	O
p	pointer
==	O
' '	O
&&	O
*	O
(	O
p	pointer
-	O
1	int
)	O
!=	O
'\\'	O
)	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
!	O
*	O
p	pointer
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
break	O
;	O
operator	char
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'?'	O
)	O
{	O
debug_flag	int
=	O
1	int
;	O
p	pointer
++	O
;	O
}	O
while	O
(	O
(	O
*	O
p	pointer
==	O
' '	O
&&	O
*	O
(	O
p	pointer
-	O
1	int
)	O
!=	O
'\\'	O
)	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
!	O
*	O
p	pointer
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
break	O
;	O
condition	enum
=	O
1	int
;	O
debug_start	pointer
=	O
p	pointer
;	O
p	pointer
=	O
test_condition	function
(	O
edit_widget	pointer
,	O
p	pointer
,	O
&	O
condition	enum
)	O
;	O
debug_end	pointer
=	O
p	pointer
;	O
debug_out	function
(	O
debug_start	pointer
,	O
debug_end	pointer
,	O
condition	enum
)	O
;	O
switch	O
(	O
operator	char
)	O
{	O
case	O
'+'	O
:	O
case	O
'='	O
:	O
*	O
result	long
=	O
condition	enum
;	O
break	O
;	O
case	O
'&'	O
:	O
*	O
result	long
&=	O
condition	enum
;	O
break	O
;	O
case	O
'|'	O
:	O
*	O
result	long
|=	O
condition	enum
;	O
break	O
;	O
default	O
:	O
debug_error	int
=	O
1	int
;	O
break	O
;	O
}	O
debug_out	function
(	O
&	O
operator	char
,	O
NULL	O
,	O
*	O
result	long
)	O
;	O
}	O
debug_out	function
(	O
NULL	O
,	O
NULL	O
,	O
1	int
)	O
;	O
if	O
(	O
!	O
*	O
p	pointer
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
p	pointer
--	O
;	O
return	O
p	pointer
;	O
}	O
static	O
void	O
execute_menu_command	function
(	O
WEdit	struct
*	O
edit_widget	pointer
,	O
const	O
char	O
*	O
commands	pointer
)	O
{	O
FILE	struct
*	O
cmd_file	pointer
;	O
int	O
cmd_file_fd	int
;	O
int	O
expand_prefix_found	int
=	O
0	int
;	O
char	O
*	O
parameter	pointer
=	O
0	int
;	O
int	O
do_quote	int
=	O
0	int
;	O
char	O
prompt	pointer
[	O
80	int
]	O
;	O
int	O
col	int
;	O
char	O
*	O
file_name	pointer
;	O
int	O
run_view	int
=	O
0	int
;	O
commands	pointer
=	O
strchr	function
(	O
commands	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
!	O
commands	pointer
)	O
{	O
return	O
;	O
}	O
cmd_file_fd	int
=	O
mc_mkstemps	function
(	O
&	O
file_name	pointer
,	O
"mcusr"	pointer
,	O
SCRIPT_SUFFIX	pointer
)	O
;	O
if	O
(	O
cmd_file_fd	int
==	O
-	O
1	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot create temporary command file \n %s "	pointer
)	O
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
return	O
;	O
}	O
cmd_file	pointer
=	O
fdopen	function
(	O
cmd_file_fd	int
,	O
"w"	pointer
)	O
;	O
fputs	function
(	O
"#! /bin/sh\n"	pointer
,	O
cmd_file	pointer
)	O
;	O
commands	pointer
++	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
*	O
commands	pointer
;	O
commands	pointer
++	O
)	O
{	O
if	O
(	O
col	int
==	O
0	int
)	O
{	O
if	O
(	O
*	O
commands	pointer
!=	O
' '	O
&&	O
*	O
commands	pointer
!=	O
'\t'	O
)	O
break	O
;	O
while	O
(	O
*	O
commands	pointer
==	O
' '	O
||	O
*	O
commands	pointer
==	O
'\t'	O
)	O
commands	pointer
++	O
;	O
if	O
(	O
*	O
commands	pointer
==	O
0	int
)	O
break	O
;	O
}	O
col	int
++	O
;	O
if	O
(	O
*	O
commands	pointer
==	O
'\n'	O
)	O
col	int
=	O
0	int
;	O
if	O
(	O
parameter	pointer
)	O
{	O
if	O
(	O
*	O
commands	pointer
==	O
'}'	O
)	O
{	O
char	O
*	O
tmp	pointer
;	O
*	O
parameter	pointer
=	O
0	int
;	O
parameter	pointer
=	O
input_dialog	function
(	O
_	O
(	O
" Parameter "	pointer
)	O
,	O
prompt	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
!	O
parameter	pointer
||	O
!	O
*	O
parameter	pointer
)	O
{	O
fclose	function
(	O
cmd_file	pointer
)	O
;	O
unlink	function
(	O
file_name	pointer
)	O
;	O
g_free	function
(	O
file_name	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
do_quote	int
)	O
{	O
fputs	function
(	O
tmp	pointer
=	O
name_quote	function
(	O
parameter	pointer
,	O
0	int
)	O
,	O
cmd_file	pointer
)	O
;	O
g_free	function
(	O
tmp	pointer
)	O
;	O
}	O
else	O
fputs	function
(	O
parameter	pointer
,	O
cmd_file	pointer
)	O
;	O
g_free	function
(	O
parameter	pointer
)	O
;	O
parameter	pointer
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
parameter	pointer
<	O
&	O
prompt	pointer
[	O
sizeof	O
(	O
prompt	pointer
)	O
-	O
1	int
]	O
)	O
{	O
*	O
parameter	pointer
++	O
=	O
*	O
commands	pointer
;	O
}	O
}	O
}	O
else	O
if	O
(	O
expand_prefix_found	int
)	O
{	O
expand_prefix_found	int
=	O
0	int
;	O
if	O
(	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
commands	pointer
)	O
)	O
{	O
do_quote	int
=	O
atoi	function
(	O
commands	pointer
)	O
;	O
while	O
(	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
commands	pointer
)	O
)	O
commands	pointer
++	O
;	O
}	O
if	O
(	O
*	O
commands	pointer
==	O
'{'	O
)	O
parameter	pointer
=	O
prompt	pointer
;	O
else	O
{	O
char	O
*	O
text	pointer
=	O
expand_format	function
(	O
edit_widget	pointer
,	O
*	O
commands	pointer
,	O
do_quote	int
)	O
;	O
fputs	function
(	O
text	pointer
,	O
cmd_file	pointer
)	O
;	O
g_free	function
(	O
text	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
commands	pointer
==	O
'%'	O
)	O
{	O
int	O
i	array
=	O
check_format_view	function
(	O
commands	pointer
+	O
1	int
)	O
;	O
if	O
(	O
i	array
)	O
{	O
commands	pointer
+=	O
i	array
;	O
run_view	int
=	O
1	int
;	O
}	O
else	O
{	O
do_quote	int
=	O
1	int
;	O
expand_prefix_found	int
=	O
1	int
;	O
}	O
}	O
else	O
fputc	function
(	O
*	O
commands	pointer
,	O
cmd_file	pointer
)	O
;	O
}	O
}	O
fclose	function
(	O
cmd_file	pointer
)	O
;	O
chmod	function
(	O
file_name	pointer
,	O
S_IRWXU	O
)	O
;	O
if	O
(	O
run_view	int
)	O
{	O
run_view	int
=	O
0	int
;	O
mc_internal_viewer	function
(	O
file_name	pointer
,	O
NULL	O
,	O
&	O
run_view	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
cmd	pointer
=	O
g_strconcat	function
(	O
"/bin/sh "	pointer
,	O
file_name	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
shell_execute	function
(	O
cmd	pointer
,	O
EXECUTE_HIDE	O
)	O
;	O
g_free	function
(	O
cmd	pointer
)	O
;	O
}	O
unlink	function
(	O
file_name	pointer
)	O
;	O
g_free	function
(	O
file_name	pointer
)	O
;	O
}	O
static	O
int	O
menu_file_own	function
(	O
char	O
*	O
path	pointer
)	O
{	O
struct	O
stat	struct
st	pointer
;	O
if	O
(	O
stat	struct
(	O
path	pointer
,	O
&	O
st	pointer
)	O
==	O
0	int
&&	O
(	O
!	O
st	pointer
.	O
st_uid	int
||	O
(	O
st	pointer
.	O
st_uid	int
==	O
geteuid	function
(	O
)	O
)	O
)	O
&&	O
(	O
(	O
st	pointer
.	O
st_mode	int
&	O
(	O
S_IWGRP	O
|	O
S_IWOTH	O
)	O
)	O
==	O
0	int
)	O
)	O
{	O
return	O
1	int
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
message	pointer
(	O
0	int
,	O
_	O
(	O
" Warning -- ignoring file "	pointer
)	O
,	O
_	O
(	O
"File %s is not owned by root or you or is world writable.\n"	pointer
"Using it may compromise your security"	pointer
)	O
,	O
path	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
user_menu_cmd	function
(	O
struct	O
WEdit	struct
*	O
edit_widget	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
char	O
*	O
data	pointer
,	O
*	O
*	O
entries	pointer
;	O
int	O
max_cols	int
,	O
menu_lines	int
,	O
menu_limit	int
;	O
int	O
col	int
,	O
i	array
,	O
accept_entry	int
=	O
1	int
;	O
int	O
selected	int
,	O
old_patterns	int
;	O
Listbox	struct
*	O
listbox	pointer
;	O
if	O
(	O
!	O
vfs_current_is_local	function
(	O
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot execute commands on non-local filesystems"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
menu	pointer
=	O
g_strdup	function
(	O
edit_widget	pointer
?	O
CEDIT_LOCAL_MENU	pointer
:	O
MC_LOCAL_MENU	pointer
)	O
;	O
if	O
(	O
!	O
exist_file	function
(	O
menu	pointer
)	O
||	O
!	O
menu_file_own	function
(	O
menu	pointer
)	O
)	O
{	O
g_free	function
(	O
menu	pointer
)	O
;	O
menu	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
edit_widget	pointer
?	O
CEDIT_HOME_MENU	pointer
:	O
MC_HOME_MENU	pointer
)	O
;	O
if	O
(	O
!	O
exist_file	function
(	O
menu	pointer
)	O
)	O
{	O
g_free	function
(	O
menu	pointer
)	O
;	O
menu	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
edit_widget	pointer
?	O
CEDIT_GLOBAL_MENU	pointer
:	O
MC_GLOBAL_MENU	pointer
)	O
;	O
}	O
}	O
if	O
(	O
(	O
data	pointer
=	O
load_file	function
(	O
menu	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot open file %s \n %s "	pointer
)	O
,	O
menu	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
g_free	function
(	O
menu	pointer
)	O
;	O
menu	pointer
=	O
NULL	O
;	O
return	O
;	O
}	O
max_cols	int
=	O
0	int
;	O
selected	int
=	O
0	int
;	O
menu_limit	int
=	O
0	int
;	O
entries	pointer
=	O
0	int
;	O
old_patterns	int
=	O
easy_patterns	int
;	O
p	pointer
=	O
check_patterns	function
(	O
data	pointer
)	O
;	O
for	O
(	O
menu_lines	int
=	O
col	int
=	O
0	int
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
menu_lines	int
>=	O
menu_limit	int
)	O
{	O
char	O
*	O
*	O
new_entries	pointer
;	O
menu_limit	int
+=	O
MAX_ENTRIES	int
;	O
new_entries	pointer
=	O
g_realloc	function
(	O
entries	pointer
,	O
sizeof	O
(	O
new_entries	pointer
[	O
0	int
]	O
)	O
*	O
menu_limit	int
)	O
;	O
if	O
(	O
new_entries	pointer
==	O
0	int
)	O
break	O
;	O
entries	pointer
=	O
new_entries	pointer
;	O
new_entries	pointer
+=	O
menu_limit	int
;	O
while	O
(	O
--	O
new_entries	pointer
>=	O
&	O
entries	pointer
[	O
menu_lines	int
]	O
)	O
*	O
new_entries	pointer
=	O
0	int
;	O
}	O
if	O
(	O
col	int
==	O
0	int
&&	O
!	O
entries	pointer
[	O
menu_lines	int
]	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'#'	O
)	O
{	O
accept_entry	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'+'	O
)	O
{	O
if	O
(	O
*	O
(	O
p	pointer
+	O
1	int
)	O
==	O
'='	O
)	O
{	O
p	pointer
=	O
test_line	function
(	O
edit_widget	pointer
,	O
p	pointer
+	O
1	int
,	O
&	O
accept_entry	int
)	O
;	O
if	O
(	O
selected	int
==	O
0	int
&&	O
accept_entry	int
)	O
selected	int
=	O
menu_lines	int
;	O
}	O
else	O
{	O
p	pointer
=	O
test_line	function
(	O
edit_widget	pointer
,	O
p	pointer
,	O
&	O
accept_entry	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'='	O
)	O
{	O
if	O
(	O
*	O
(	O
p	pointer
+	O
1	int
)	O
==	O
'+'	O
)	O
{	O
p	pointer
=	O
test_line	function
(	O
edit_widget	pointer
,	O
p	pointer
+	O
1	int
,	O
&	O
accept_entry	int
)	O
;	O
if	O
(	O
selected	int
==	O
0	int
&&	O
accept_entry	int
)	O
selected	int
=	O
menu_lines	int
;	O
}	O
else	O
{	O
i	array
=	O
1	int
;	O
p	pointer
=	O
test_line	function
(	O
edit_widget	pointer
,	O
p	pointer
,	O
&	O
i	array
)	O
;	O
if	O
(	O
selected	int
==	O
0	int
&&	O
i	array
)	O
selected	int
=	O
menu_lines	int
;	O
}	O
}	O
else	O
if	O
(	O
*	O
p	pointer
!=	O
' '	O
&&	O
*	O
p	pointer
!=	O
'\t'	O
&&	O
is_printable	function
(	O
*	O
p	pointer
)	O
)	O
{	O
if	O
(	O
accept_entry	int
)	O
entries	pointer
[	O
menu_lines	int
]	O
=	O
p	pointer
;	O
else	O
accept_entry	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
)	O
{	O
if	O
(	O
entries	pointer
[	O
menu_lines	int
]	O
)	O
{	O
menu_lines	int
++	O
;	O
accept_entry	int
=	O
1	int
;	O
}	O
max_cols	int
=	O
max	long
(	O
max_cols	int
,	O
col	int
)	O
;	O
col	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\t'	O
)	O
*	O
p	pointer
=	O
' '	O
;	O
col	int
++	O
;	O
}	O
}	O
if	O
(	O
menu_lines	int
==	O
0	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" No suitable entries found in %s "	pointer
)	O
,	O
menu	pointer
)	O
;	O
}	O
else	O
{	O
max_cols	int
=	O
min	long
(	O
max	long
(	O
max_cols	int
,	O
col	int
)	O
,	O
MAX_ENTRY_LEN	int
)	O
;	O
listbox	pointer
=	O
create_listbox_window	function
(	O
max_cols	int
+	O
2	int
,	O
menu_lines	int
,	O
_	O
(	O
" User menu "	pointer
)	O
,	O
"[Menu File Edit]"	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
menu_lines	int
;	O
i	array
++	O
)	O
{	O
p	pointer
=	O
entries	pointer
[	O
i	array
]	O
;	O
LISTBOX_APPEND_TEXT	O
(	O
listbox	pointer
,	O
(	O
unsigned	O
char	O
)	O
p	pointer
[	O
0	int
]	O
,	O
extract_line	function
(	O
p	pointer
,	O
p	pointer
+	O
MAX_ENTRY_LEN	int
)	O
,	O
p	pointer
)	O
;	O
}	O
listbox_select_by_number	function
(	O
listbox	pointer
->	O
list	pointer
,	O
selected	int
)	O
;	O
selected	int
=	O
run_listbox	function
(	O
listbox	pointer
)	O
;	O
if	O
(	O
selected	int
>=	O
0	int
)	O
execute_menu_command	function
(	O
edit_widget	pointer
,	O
entries	pointer
[	O
selected	int
]	O
)	O
;	O
do_refresh	function
(	O
)	O
;	O
}	O
easy_patterns	int
=	O
old_patterns	int
;	O
g_free	function
(	O
menu	pointer
)	O
;	O
menu	pointer
=	O
NULL	O
;	O
g_free	function
(	O
entries	pointer
)	O
;	O
g_free	function
(	O
data	pointer
)	O
;	O
}	O
