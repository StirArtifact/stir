extern	O
char	O
*	O
dap_dapname	pointer
;	O
extern	O
DFILE	struct
*	O
dap_in	array
[	O
2	int
]	O
;	O
extern	O
DFILE	struct
*	O
dap_out	array
[	O
2	int
]	O
;	O
extern	O
dataobs	struct
dap_obs	array
[	O
]	O
;	O
extern	O
dataobs	struct
dap_prev	array
[	O
]	O
;	O
extern	O
int	O
dap_ono	int
;	O
extern	O
FILE	struct
*	O
dap_lst	pointer
;	O
extern	O
FILE	struct
*	O
dap_err	pointer
;	O
extern	O
FILE	struct
*	O
dap_log	pointer
;	O
extern	O
char	O
*	O
dap_title	pointer
;	O
extern	O
int	O
dap_maxlines	int
;	O
static	O
int	O
*	O
startmem	pointer
;	O
static	O
int	O
*	O
start	array
[	O
2	int
]	O
;	O
static	O
void	O
sortparse	function
(	O
char	O
line	array
[	O
]	O
,	O
int	O
which	int
)	O
{	O
int	O
v	int
;	O
int	O
l	int
;	O
int	O
newfield	int
;	O
for	O
(	O
v	int
=	O
0	int
,	O
l	int
=	O
0	int
,	O
newfield	int
=	O
1	int
;	O
line	array
[	O
l	int
]	O
&&	O
line	array
[	O
l	int
]	O
!=	O
'\n'	O
;	O
l	int
++	O
)	O
{	O
if	O
(	O
newfield	int
)	O
start	array
[	O
which	int
]	O
[	O
v	int
++	O
]	O
=	O
l	int
;	O
newfield	int
=	O
(	O
line	array
[	O
l	int
]	O
==	O
SETDELIM	char
)	O
;	O
}	O
}	O
static	O
char	O
*	O
mod	pointer
;	O
static	O
int	O
nmods	int
;	O
static	O
int	O
*	O
varv	array
;	O
static	O
int	O
nvar	int
;	O
static	O
int	O
fieldcmp	function
(	O
char	O
f1	array
[	O
]	O
,	O
char	O
f2	double
[	O
]	O
)	O
{	O
int	O
f	pointer
;	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f1	array
[	O
f	pointer
]	O
&&	O
f1	array
[	O
f	pointer
]	O
!=	O
SETDELIM	char
&&	O
f1	array
[	O
f	pointer
]	O
!=	O
'\n'	O
&&	O
f1	array
[	O
f	pointer
]	O
==	O
f2	double
[	O
f	pointer
]	O
;	O
f	pointer
++	O
)	O
;	O
if	O
(	O
f1	array
[	O
f	pointer
]	O
==	O
f2	double
[	O
f	pointer
]	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
f1	array
[	O
f	pointer
]	O
||	O
f1	array
[	O
f	pointer
]	O
==	O
SETDELIM	char
||	O
f1	array
[	O
f	pointer
]	O
==	O
'\n'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
f2	double
[	O
f	pointer
]	O
||	O
f2	double
[	O
f	pointer
]	O
==	O
SETDELIM	char
||	O
f2	double
[	O
f	pointer
]	O
==	O
'\n'	O
)	O
return	O
1	int
;	O
return	O
f1	array
[	O
f	pointer
]	O
-	O
f2	double
[	O
f	pointer
]	O
;	O
}	O
static	O
int	O
sortcmp	function
(	O
char	O
*	O
*	O
e0	pointer
,	O
char	O
*	O
*	O
e1	pointer
)	O
{	O
int	O
v	int
;	O
int	O
cmp	int
;	O
cmp	int
=	O
0	int
;	O
sortparse	function
(	O
*	O
e0	pointer
,	O
0	int
)	O
;	O
sortparse	function
(	O
*	O
e1	pointer
,	O
1	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
cmp	int
=	O
fieldcmp	function
(	O
*	O
e0	pointer
+	O
start	array
[	O
0	int
]	O
[	O
varv	array
[	O
v	int
]	O
]	O
,	O
*	O
e1	pointer
+	O
start	array
[	O
1	int
]	O
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
cmp	int
)	O
break	O
;	O
}	O
if	O
(	O
nmods	int
&&	O
mod	pointer
[	O
v	int
]	O
==	O
'd'	O
)	O
cmp	int
=	O
-	O
cmp	int
;	O
return	O
cmp	int
;	O
}	O
static	O
int	O
linediff	function
(	O
char	O
l1	array
[	O
]	O
,	O
char	O
l2	array
[	O
]	O
)	O
{	O
int	O
l	int
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l1	array
[	O
l	int
]	O
&&	O
l1	array
[	O
l	int
]	O
!=	O
'\n'	O
&&	O
l1	array
[	O
l	int
]	O
==	O
l2	array
[	O
l	int
]	O
;	O
l	int
++	O
)	O
;	O
return	O
l1	array
[	O
l	int
]	O
!=	O
l2	array
[	O
l	int
]	O
;	O
}	O
static	O
void	O
dsort	function
(	O
char	O
*	O
origset	pointer
,	O
char	O
*	O
sortset	pointer
,	O
int	O
sortvar	array
[	O
]	O
,	O
int	O
nfields	int
,	O
int	O
unique	int
,	O
char	O
*	O
mod	pointer
,	O
int	O
nmods	int
)	O
;	O
void	O
sort	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
varlist	array
,	O
char	O
*	O
modifiers	array
)	O
{	O
static	O
int	O
sortinit	int
=	O
0	int
;	O
int	O
unique	int
;	O
int	O
lastun	int
;	O
int	O
l	int
;	O
int	O
i	int
;	O
int	O
v	int
;	O
int	O
vn	int
;	O
char	O
*	O
dsrt0	pointer
;	O
char	O
*	O
dsrt	pointer
;	O
char	O
*	O
dfile	pointer
;	O
static	O
char	O
*	O
*	O
line	array
;	O
int	O
newline	int
;	O
int	O
nlines	int
;	O
char	O
*	O
c	int
;	O
int	O
flen	int
;	O
int	O
(	O
*	O
scmp	pointer
)	O
(	O
)	O
;	O
if	O
(	O
!	O
sortinit	int
)	O
{	O
sortinit	int
=	O
1	int
;	O
line	array
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxlines	int
,	O
""	pointer
)	O
;	O
startmem	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
2	int
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
start	array
[	O
0	int
]	O
=	O
startmem	pointer
;	O
start	array
[	O
1	int
]	O
=	O
startmem	pointer
+	O
dap_maxvar	int
;	O
mod	pointer
=	O
dap_malloc	function
(	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
varv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
}	O
if	O
(	O
!	O
fname	array
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"%s:sort: no dataset name given\n"	pointer
,	O
dap_dapname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
scmp	pointer
=	O
&	O
sortcmp	function
;	O
unique	int
=	O
0	int
;	O
if	O
(	O
modifiers	array
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
modifiers	array
[	O
l	int
]	O
==	O
' '	O
;	O
l	int
++	O
)	O
;	O
for	O
(	O
nmods	int
=	O
0	int
,	O
unique	int
=	O
0	int
;	O
modifiers	array
[	O
l	int
]	O
;	O
)	O
{	O
if	O
(	O
modifiers	array
[	O
l	int
]	O
==	O
'u'	O
)	O
{	O
unique	int
=	O
1	int
;	O
l	int
++	O
;	O
}	O
else	O
if	O
(	O
modifiers	array
[	O
l	int
]	O
==	O
'i'	O
||	O
modifiers	array
[	O
l	int
]	O
==	O
'd'	O
)	O
{	O
while	O
(	O
modifiers	array
[	O
l	int
]	O
==	O
'i'	O
||	O
modifiers	array
[	O
l	int
]	O
==	O
'd'	O
)	O
mod	pointer
[	O
nmods	int
++	O
]	O
=	O
modifiers	array
[	O
l	int
++	O
]	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(sort) Bad modifier(s): %s\n"	pointer
,	O
modifiers	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
modifiers	array
[	O
l	int
]	O
==	O
' '	O
)	O
l	int
++	O
;	O
}	O
}	O
else	O
nmods	int
=	O
0	int
;	O
dsrt0	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
dap_suffix	function
(	O
dsrt0	pointer
,	O
fname	array
,	O
".srt"	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
outset	function
(	O
dsrt0	pointer
,	O
""	pointer
)	O
;	O
nvar	int
=	O
dap_list	function
(	O
varlist	array
,	O
varv	array
,	O
dap_maxvar	int
)	O
;	O
if	O
(	O
nmods	int
&&	O
(	O
nvar	int
!=	O
nmods	int
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(sort) Number of modifiers %d does not equal number of sort variables %d.\n"	pointer
,	O
nmods	int
,	O
nvar	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fname	array
[	O
0	int
]	O
==	O
'<'	O
)	O
{	O
for	O
(	O
nlines	int
=	O
0	int
,	O
i	int
=	O
dap_ftell	function
(	O
dap_in	array
[	O
0	int
]	O
)	O
,	O
newline	int
=	O
1	int
;	O
i	int
<	O
dap_in	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_end	pointer
-	O
dap_in	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
;	O
i	int
++	O
)	O
{	O
if	O
(	O
newline	int
)	O
{	O
if	O
(	O
nlines	int
<	O
dap_maxlines	int
)	O
line	array
[	O
nlines	int
++	O
]	O
=	O
dap_in	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
+	O
i	int
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(sort) Too many lines in ramfile %s\n"	pointer
,	O
fname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
newline	int
=	O
(	O
dap_in	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
[	O
i	int
]	O
==	O
'\n'	O
)	O
;	O
}	O
qsort	function
(	O
line	array
,	O
nlines	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
scmp	pointer
)	O
;	O
for	O
(	O
l	int
=	O
0	int
,	O
lastun	int
=	O
-	O
1	int
;	O
l	int
<	O
nlines	int
;	O
l	int
++	O
)	O
{	O
if	O
(	O
!	O
unique	int
||	O
lastun	int
<	O
0	int
||	O
linediff	function
(	O
line	array
[	O
lastun	int
]	O
,	O
line	array
[	O
l	int
]	O
)	O
)	O
{	O
for	O
(	O
c	int
=	O
line	array
[	O
l	int
]	O
;	O
c	int
<	O
dap_in	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_end	pointer
&&	O
*	O
c	int
!=	O
'\n'	O
;	O
c	int
++	O
)	O
dap_putc	function
(	O
*	O
c	int
,	O
dap_out	array
[	O
0	int
]	O
)	O
;	O
dap_putc	function
(	O
'\n'	O
,	O
dap_out	array
[	O
0	int
]	O
)	O
;	O
lastun	int
=	O
l	int
;	O
}	O
else	O
{	O
for	O
(	O
c	int
=	O
line	array
[	O
l	int
]	O
;	O
c	int
<	O
dap_in	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_end	pointer
&&	O
*	O
c	int
!=	O
'\n'	O
;	O
c	int
++	O
)	O
;	O
}	O
}	O
flen	int
=	O
dap_out	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_end	pointer
-	O
dap_out	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
;	O
memcpy	function
(	O
dap_in	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
,	O
dap_out	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
,	O
flen	int
)	O
;	O
dap_in	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_end	pointer
=	O
dap_in	array
[	O
0	int
]	O
->	O
dfile_ram	pointer
->	O
rfile_str	pointer
+	O
flen	int
;	O
}	O
else	O
{	O
inset	function
(	O
NULL	O
)	O
;	O
dfile	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
strlen	function
(	O
dap_setdir	pointer
)	O
+	O
2	int
,	O
""	pointer
)	O
;	O
dap_name	function
(	O
dfile	pointer
,	O
fname	array
)	O
;	O
dsrt	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
dsrt0	pointer
)	O
+	O
strlen	function
(	O
dap_setdir	pointer
)	O
+	O
2	int
,	O
""	pointer
)	O
;	O
dap_name	function
(	O
dsrt	pointer
,	O
dsrt0	pointer
)	O
;	O
dsort	function
(	O
dfile	pointer
,	O
dsrt	pointer
,	O
varv	array
,	O
nvar	int
,	O
unique	int
,	O
mod	pointer
,	O
nmods	int
)	O
;	O
dap_free	function
(	O
dsrt	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
dfile	pointer
,	O
""	pointer
)	O
;	O
}	O
dap_free	function
(	O
dsrt0	pointer
,	O
""	pointer
)	O
;	O
}	O
static	O
void	O
printhead	function
(	O
char	O
*	O
*	O
formstr	pointer
,	O
int	O
space	int
,	O
char	O
*	O
fname	array
,	O
int	O
*	O
varv	array
,	O
int	O
nvar	int
)	O
{	O
int	O
v	int
;	O
int	O
d	int
;	O
char	O
*	O
ttext	pointer
;	O
int	O
wastitle	int
;	O
ttext	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
11	int
,	O
""	pointer
)	O
;	O
if	O
(	O
dap_title	pointer
)	O
wastitle	int
=	O
1	int
;	O
else	O
{	O
wastitle	int
=	O
0	int
;	O
strcpy	function
(	O
ttext	pointer
,	O
"Printing: "	pointer
)	O
;	O
strcat	function
(	O
ttext	pointer
,	O
fname	array
)	O
;	O
title	function
(	O
ttext	pointer
)	O
;	O
}	O
dap_head	function
(	O
(	O
int	O
*	O
)	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
space	int
==	O
' '	O
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
"  Obs "	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
space	int
!=	O
' '	O
&&	O
!	O
strcmp	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
,	O
"_type_"	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
<=	O
0	int
)	O
{	O
if	O
(	O
space	int
==	O
' '	O
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%12s"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
else	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%s"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
}	O
else	O
fprintf	function
(	O
dap_lst	pointer
,	O
formstr	pointer
[	O
v	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
v	int
<	O
nvar	int
-	O
1	int
)	O
putc	function
(	O
space	int
,	O
dap_lst	pointer
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
if	O
(	O
space	int
==	O
' '	O
)	O
{	O
fprintf	function
(	O
dap_lst	pointer
,	O
"----- "	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
[	O
d	int
]	O
;	O
d	int
++	O
)	O
putc	function
(	O
'-'	O
,	O
dap_lst	pointer
)	O
;	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
<=	O
0	int
)	O
{	O
while	O
(	O
d	int
<	O
12	int
)	O
{	O
putc	function
(	O
'-'	O
,	O
dap_lst	pointer
)	O
;	O
d	int
++	O
;	O
}	O
}	O
else	O
{	O
while	O
(	O
d	int
<	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
{	O
putc	function
(	O
'-'	O
,	O
dap_lst	pointer
)	O
;	O
d	int
++	O
;	O
}	O
}	O
putc	function
(	O
' '	O
,	O
dap_lst	pointer
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
if	O
(	O
!	O
wastitle	int
)	O
title	function
(	O
NULL	O
)	O
;	O
dap_free	function
(	O
ttext	pointer
,	O
""	pointer
)	O
;	O
}	O
void	O
print	function
(	O
char	O
fname	array
[	O
]	O
,	O
char	O
*	O
varlist	array
)	O
{	O
char	O
*	O
varlist1	pointer
;	O
int	O
space	int
;	O
int	O
*	O
varv	array
;	O
int	O
nvar	int
;	O
int	O
typen	int
;	O
char	O
*	O
formmem	pointer
;	O
char	O
*	O
*	O
formstr	pointer
;	O
int	O
v	int
;	O
int	O
lenstr	int
;	O
int	O
obn	int
;	O
varv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
space	int
=	O
' '	O
;	O
if	O
(	O
varlist	array
&&	O
varlist	array
[	O
0	int
]	O
)	O
{	O
varlist1	pointer
=	O
(	O
char	O
*	O
)	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
varlist	array
[	O
v	int
]	O
;	O
v	int
++	O
)	O
{	O
if	O
(	O
varlist	array
[	O
v	int
]	O
==	O
'\t'	O
||	O
varlist	array
[	O
v	int
]	O
==	O
','	O
)	O
{	O
varlist1	pointer
[	O
v	int
]	O
=	O
' '	O
;	O
if	O
(	O
space	int
==	O
' '	O
)	O
space	int
=	O
varlist	array
[	O
v	int
]	O
;	O
else	O
if	O
(	O
space	int
!=	O
varlist	array
[	O
v	int
]	O
)	O
{	O
fputs	function
(	O
"(print) variable list contains more than one type of separator\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
varlist1	pointer
[	O
v	int
]	O
=	O
varlist	array
[	O
v	int
]	O
;	O
}	O
varlist1	pointer
[	O
v	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
varv	array
[	O
0	int
]	O
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fputs	function
(	O
"(print) Missing _type_ variable.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
typen	int
=	O
varv	array
[	O
0	int
]	O
;	O
nvar	int
=	O
1	int
+	O
dap_list	function
(	O
varlist1	pointer
,	O
varv	array
+	O
1	int
,	O
dap_maxvar	int
-	O
1	int
)	O
;	O
if	O
(	O
nvar	int
==	O
1	int
)	O
{	O
nvar	int
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nvar	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
varv	array
[	O
v	int
]	O
=	O
v	int
;	O
}	O
dap_free	function
(	O
varlist1	pointer
,	O
""	pointer
)	O
;	O
}	O
else	O
{	O
nvar	int
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nvar	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
varv	array
[	O
v	int
]	O
=	O
v	int
;	O
}	O
formmem	pointer
=	O
dap_malloc	function
(	O
nvar	int
*	O
10	int
,	O
""	pointer
)	O
;	O
formstr	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
formstr	pointer
[	O
v	int
]	O
=	O
formmem	pointer
+	O
10	int
*	O
v	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
{	O
lenstr	int
=	O
strlen	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
lenstr	int
<	O
12	int
)	O
lenstr	int
=	O
12	int
;	O
if	O
(	O
space	int
!=	O
' '	O
)	O
lenstr	int
=	O
0	int
;	O
sprintf	function
(	O
formstr	pointer
[	O
v	int
]	O
,	O
"%%%dd"	pointer
,	O
lenstr	int
)	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
{	O
lenstr	int
=	O
strlen	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
lenstr	int
<	O
12	int
)	O
lenstr	int
=	O
12	int
;	O
if	O
(	O
space	int
!=	O
' '	O
)	O
lenstr	int
=	O
0	int
;	O
sprintf	function
(	O
formstr	pointer
[	O
v	int
]	O
,	O
"%%%dg"	pointer
,	O
lenstr	int
)	O
;	O
}	O
else	O
{	O
lenstr	int
=	O
strlen	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
lenstr	int
<	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
lenstr	int
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
;	O
if	O
(	O
space	int
!=	O
' '	O
)	O
lenstr	int
=	O
0	int
;	O
sprintf	function
(	O
formstr	pointer
[	O
v	int
]	O
,	O
"%%-%ds"	pointer
,	O
lenstr	int
)	O
;	O
}	O
}	O
printhead	function
(	O
formstr	pointer
,	O
space	int
,	O
fname	array
,	O
varv	array
,	O
nvar	int
)	O
;	O
for	O
(	O
obn	int
=	O
1	int
;	O
step	function
(	O
)	O
;	O
)	O
{	O
if	O
(	O
space	int
==	O
' '	O
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%5d "	pointer
,	O
obn	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
space	int
!=	O
' '	O
&&	O
varv	array
[	O
v	int
]	O
==	O
typen	int
)	O
continue	O
;	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
==	O
INT	int
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
formstr	pointer
[	O
v	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
==	O
DBL	O
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
formstr	pointer
[	O
v	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
else	O
fprintf	function
(	O
dap_lst	pointer
,	O
formstr	pointer
[	O
v	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
if	O
(	O
v	int
<	O
nvar	int
-	O
1	int
)	O
putc	function
(	O
space	int
,	O
dap_lst	pointer
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
obn	int
++	O
;	O
}	O
fflush	function
(	O
dap_lst	pointer
)	O
;	O
dap_free	function
(	O
varv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
formmem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
formstr	pointer
,	O
""	pointer
)	O
;	O
}	O
int	O
dap_mnsparse	function
(	O
char	O
*	O
varlist	array
,	O
char	O
*	O
outlist	pointer
,	O
int	O
*	O
varv	array
,	O
int	O
*	O
wtvar	pointer
,	O
int	O
stats	array
[	O
]	O
)	O
{	O
int	O
v	int
;	O
int	O
i	int
;	O
int	O
j	int
;	O
int	O
k	int
;	O
char	O
*	O
vname	array
;	O
char	O
*	O
tmplist	pointer
;	O
int	O
vn	int
;	O
int	O
wn	int
;	O
int	O
nvar	int
;	O
int	O
s	int
;	O
int	O
nonly	int
;	O
if	O
(	O
!	O
varlist	array
)	O
{	O
fputs	function
(	O
"(meansparse) Missing variable list.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
vname	array
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
6	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
varlist	array
[	O
v	int
]	O
;	O
v	int
++	O
)	O
;	O
for	O
(	O
--	O
v	int
;	O
v	int
>=	O
0	int
&&	O
varlist	array
[	O
v	int
]	O
==	O
' '	O
;	O
--	O
v	int
)	O
;	O
nvar	int
=	O
0	int
;	O
tmplist	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
tmplist	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
wn	int
=	O
-	O
1	int
;	O
for	O
(	O
nonly	int
=	O
0	int
;	O
v	int
>=	O
0	int
;	O
)	O
{	O
for	O
(	O
i	int
=	O
v	int
;	O
i	int
>=	O
0	int
&&	O
varlist	array
[	O
i	int
]	O
!=	O
' '	O
&&	O
varlist	array
[	O
i	int
]	O
!=	O
'*'	O
;	O
--	O
i	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
v	int
-	O
i	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
<	O
dap_namelen	int
)	O
vname	array
[	O
j	int
]	O
=	O
varlist	array
[	O
i	int
+	O
j	int
+	O
1	int
]	O
;	O
else	O
{	O
vname	array
[	O
j	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(meansparse) Variable name too long: %s\n"	pointer
,	O
vname	array
)	O
;	O
}	O
}	O
vname	array
[	O
j	int
]	O
=	O
'\0'	O
;	O
while	O
(	O
i	int
>=	O
0	int
&&	O
varlist	array
[	O
i	int
]	O
==	O
' '	O
)	O
--	O
i	int
;	O
if	O
(	O
(	O
vn	int
=	O
dap_varnum	function
(	O
vname	array
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
vn	int
]	O
==	O
DBL	O
)	O
{	O
if	O
(	O
tmplist	pointer
[	O
0	int
]	O
)	O
strcat	function
(	O
tmplist	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
tmplist	pointer
,	O
vname	array
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(meansparse) Variable must be double: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
NSTATS	O
;	O
s	int
++	O
)	O
{	O
if	O
(	O
s	int
!=	O
N	int
&&	O
stats	array
[	O
s	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(meansparse) Statistics other than N requested for unknown variable %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
strcpy	function
(	O
tmplist	pointer
,	O
vname	array
)	O
;	O
strcat	function
(	O
vname	array
,	O
" -1"	pointer
)	O
;	O
vn	int
=	O
dap_vd	function
(	O
vname	array
,	O
0	int
)	O
;	O
nonly	int
=	O
1	int
;	O
}	O
v	int
=	O
i	int
;	O
if	O
(	O
v	int
>=	O
0	int
&&	O
varlist	array
[	O
v	int
]	O
==	O
'*'	O
)	O
{	O
wn	int
=	O
vn	int
;	O
for	O
(	O
--	O
v	int
;	O
v	int
>=	O
0	int
&&	O
varlist	array
[	O
v	int
]	O
==	O
' '	O
;	O
--	O
v	int
)	O
;	O
}	O
else	O
{	O
wtvar	pointer
[	O
nvar	int
]	O
=	O
wn	int
;	O
varv	array
[	O
nvar	int
++	O
]	O
=	O
vn	int
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
tmplist	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
for	O
(	O
--	O
i	int
;	O
i	int
>=	O
0	int
&&	O
tmplist	pointer
[	O
i	int
]	O
==	O
' '	O
;	O
--	O
i	int
)	O
;	O
for	O
(	O
outlist	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
i	int
>=	O
0	int
;	O
)	O
{	O
for	O
(	O
j	int
=	O
i	int
;	O
j	int
>	O
0	int
&&	O
tmplist	pointer
[	O
j	int
-	O
1	int
]	O
!=	O
' '	O
;	O
--	O
j	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
i	int
-	O
j	int
;	O
k	int
++	O
)	O
vname	array
[	O
k	int
]	O
=	O
tmplist	pointer
[	O
j	int
+	O
k	int
]	O
;	O
vname	array
[	O
k	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
outlist	pointer
[	O
0	int
]	O
)	O
strcat	function
(	O
outlist	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
outlist	pointer
,	O
vname	array
)	O
;	O
for	O
(	O
i	int
=	O
j	int
-	O
1	int
;	O
i	int
>=	O
0	int
&&	O
tmplist	pointer
[	O
i	int
]	O
==	O
' '	O
;	O
--	O
i	int
)	O
;	O
}	O
dap_free	function
(	O
vname	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
tmplist	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
nonly	int
)	O
return	O
-	O
nvar	int
;	O
return	O
nvar	int
;	O
}	O
char	O
dap_sttnm	array
[	O
NSTATS	O
]	O
[	O
STATLEN	int
+	O
1	int
]	O
=	O
{	O
"N"	pointer
,	O
"SUM"	pointer
,	O
"SUMWT"	pointer
,	O
"MEAN"	pointer
,	O
"MIN"	pointer
,	O
"MAX"	pointer
,	O
"RANGE"	pointer
,	O
"STEPXXXX"	pointer
,	O
"VAR"	pointer
,	O
"VARM"	pointer
,	O
"SD"	pointer
,	O
"SEM"	pointer
,	O
"VARFREQ"	pointer
,	O
"VARMFREQ"	pointer
,	O
"SDFREQ"	pointer
,	O
"SEMFREQ"	pointer
,	O
"T"	pointer
,	O
"TPROB"	pointer
,	O
"QRANGE"	pointer
,	O
"SIGN"	pointer
,	O
"SPROB"	pointer
,	O
"SRANK"	pointer
,	O
"SRPROB"	pointer
,	O
"NORMAL"	pointer
,	O
"NPROB"	pointer
,	O
"P1"	pointer
,	O
"P5"	pointer
,	O
"P10"	pointer
,	O
"Q1"	pointer
,	O
"MED"	pointer
,	O
"Q3"	pointer
,	O
"P90"	pointer
,	O
"P95"	pointer
,	O
"P99"	pointer
,	O
"PXXXXX"	pointer
,	O
"PXXXXX"	pointer
,	O
"PXXXXX"	pointer
}	O
;	O
void	O
dap_stats	function
(	O
char	O
*	O
statlist	array
,	O
int	O
*	O
stats	array
)	O
{	O
int	O
s	int
;	O
int	O
i	int
;	O
char	O
*	O
stat	struct
;	O
int	O
sn	int
;	O
double	O
pctpt	double
;	O
int	O
pctptn	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
NSTATS	O
;	O
s	int
++	O
)	O
stats	array
[	O
s	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
statlist	array
)	O
return	O
;	O
if	O
(	O
!	O
stats	array
)	O
{	O
fputs	function
(	O
"(dap_stats) Missing statistics index list.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
s	int
=	O
0	int
;	O
statlist	array
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
stat	struct
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
pctptn	int
=	O
0	int
;	O
statlist	array
[	O
s	int
]	O
;	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
statlist	array
[	O
s	int
+	O
i	int
]	O
&&	O
statlist	array
[	O
s	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
stat	struct
[	O
i	int
]	O
=	O
statlist	array
[	O
s	int
+	O
i	int
]	O
;	O
else	O
{	O
stat	struct
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_stats) Statistic name too long: %s\n"	pointer
,	O
stat	struct
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
stat	struct
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
stat	struct
,	O
"STD"	pointer
)	O
)	O
strcpy	function
(	O
stat	struct
,	O
"SD"	pointer
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	struct
,	O
"STDERR"	pointer
)	O
)	O
strcpy	function
(	O
stat	struct
,	O
"SEM"	pointer
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	struct
,	O
"PRT"	pointer
)	O
)	O
strcpy	function
(	O
stat	struct
,	O
"TPROB"	pointer
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
stat	struct
,	O
"MEDIAN"	pointer
)	O
)	O
strcpy	function
(	O
stat	struct
,	O
"MED"	pointer
)	O
;	O
for	O
(	O
sn	int
=	O
0	int
;	O
sn	int
<	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pctptn	int
;	O
sn	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
stat	struct
,	O
dap_sttnm	array
[	O
sn	int
]	O
)	O
)	O
{	O
stats	array
[	O
sn	int
]	O
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
sn	int
==	O
NSTATS	O
-	O
MAXPCTPT	int
+	O
pctptn	int
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
stat	struct
,	O
"STEP"	pointer
,	O
4	int
)	O
)	O
{	O
stat	struct
[	O
8	int
]	O
=	O
'\0'	O
;	O
strcpy	function
(	O
dap_sttnm	array
[	O
STEP	O
]	O
,	O
stat	struct
)	O
;	O
stats	array
[	O
STEP	O
]	O
=	O
1	int
;	O
}	O
else	O
if	O
(	O
stat	struct
[	O
0	int
]	O
==	O
'P'	O
&&	O
sscanf	function
(	O
stat	struct
+	O
1	int
,	O
"%lf"	pointer
,	O
&	O
pctpt	double
)	O
==	O
1	int
)	O
{	O
if	O
(	O
pctptn	int
++	O
<	O
MAXPCTPT	int
)	O
{	O
stats	array
[	O
sn	int
]	O
=	O
1	int
;	O
strcpy	function
(	O
dap_sttnm	array
[	O
sn	int
++	O
]	O
,	O
stat	struct
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_stats) Too many user-defined statistics: %s\n"	pointer
,	O
stat	struct
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_stats) Invalid statistic name: %s\n"	pointer
,	O
stat	struct
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
s	int
+=	O
i	int
;	O
while	O
(	O
statlist	array
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
}	O
dap_free	function
(	O
stat	struct
,	O
""	pointer
)	O
;	O
}	O
static	O
void	O
meansout	function
(	O
int	O
varv	array
[	O
]	O
,	O
int	O
nvar	int
,	O
int	O
nobs	array
[	O
]	O
,	O
double	O
sum	array
[	O
]	O
,	O
double	O
sumwt	array
[	O
]	O
,	O
double	O
min	array
[	O
]	O
,	O
double	O
max	array
[	O
]	O
,	O
double	O
ss	array
[	O
]	O
,	O
int	O
stats	array
[	O
]	O
)	O
{	O
double	O
*	O
dn	pointer
;	O
int	O
typevar	int
;	O
int	O
v	int
;	O
int	O
nsteps	int
;	O
int	O
step	function
;	O
double	O
*	O
range	pointer
;	O
double	O
fract	double
;	O
dap_swap	function
(	O
)	O
;	O
dn	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dn	pointer
[	O
v	int
]	O
=	O
(	O
double	O
)	O
nobs	array
[	O
v	int
]	O
;	O
if	O
(	O
(	O
typevar	int
=	O
dap_varnum	function
(	O
"_type_"	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(meansout) Missing _type_ variable\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
N	int
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"N"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
dn	pointer
[	O
v	int
]	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
SUM	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"SUM"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
sum	array
[	O
v	int
]	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
SUMWT	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"SUMWT"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
sumwt	array
[	O
v	int
]	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
MEAN	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"MEAN"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
sum	array
[	O
v	int
]	O
/	O
sumwt	array
[	O
v	int
]	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
MIN	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"MIN"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
min	array
[	O
v	int
]	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
MAX	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"MAX"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
max	array
[	O
v	int
]	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
RANGE	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"RANGE"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array
[	O
v	int
]	O
>=	O
1	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
max	array
[	O
v	int
]	O
-	O
min	array
[	O
v	int
]	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
VAR	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"VAR"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dn	pointer
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
ss	array
[	O
v	int
]	O
/	O
(	O
dn	pointer
[	O
v	int
]	O
-	O
1.0	int
)	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
SD	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"SD"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dn	pointer
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
sqrt	function
(	O
ss	array
[	O
v	int
]	O
/	O
(	O
dn	pointer
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
SEM	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"SEM"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dn	pointer
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
sqrt	function
(	O
ss	array
[	O
v	int
]	O
/	O
(	O
dn	pointer
[	O
v	int
]	O
*	O
(	O
dn	pointer
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
)	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
VARM	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"VARM"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
dn	pointer
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
ss	array
[	O
v	int
]	O
/	O
(	O
dn	pointer
[	O
v	int
]	O
*	O
(	O
dn	pointer
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
VARFREQ	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"VARFREQ"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
ss	array
[	O
v	int
]	O
/	O
(	O
sumwt	array
[	O
v	int
]	O
-	O
1.0	int
)	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
SDFREQ	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"SDFREQ"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
sqrt	function
(	O
ss	array
[	O
v	int
]	O
/	O
(	O
sumwt	array
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
SEMFREQ	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"SEMFREQ"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
sqrt	function
(	O
ss	array
[	O
v	int
]	O
/	O
(	O
sumwt	array
[	O
v	int
]	O
*	O
(	O
sumwt	array
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
)	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
VARMFREQ	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"SEMFREQ"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array
[	O
v	int
]	O
>	O
1.0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
ss	array
[	O
v	int
]	O
/	O
(	O
sumwt	array
[	O
v	int
]	O
*	O
(	O
sumwt	array
[	O
v	int
]	O
-	O
1.0	int
)	O
)	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
STEP	O
]	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
dap_sttnm	array
[	O
STEP	O
]	O
+	O
4	int
,	O
"%d"	pointer
,	O
&	O
nsteps	int
)	O
==	O
1	int
)	O
{	O
range	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"STEP"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nobs	array
[	O
v	int
]	O
>=	O
1	int
)	O
range	pointer
[	O
v	int
]	O
=	O
max	array
[	O
v	int
]	O
-	O
min	array
[	O
v	int
]	O
;	O
else	O
range	pointer
[	O
v	int
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
for	O
(	O
step	function
=	O
0	int
;	O
step	function
<=	O
nsteps	int
;	O
step	function
++	O
)	O
{	O
fract	double
=	O
(	O
(	O
double	O
)	O
step	function
)	O
/	O
(	O
(	O
double	O
)	O
nsteps	int
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
min	array
[	O
v	int
]	O
+	O
range	pointer
[	O
v	int
]	O
*	O
fract	double
;	O
output	function
(	O
)	O
;	O
}	O
dap_free	function
(	O
range	pointer
,	O
""	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(meansout) Bad number of steps: %s\n"	pointer
,	O
dap_sttnm	array
[	O
STEP	O
]	O
+	O
4	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
stats	array
[	O
T	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"T"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array
[	O
v	int
]	O
>	O
0.0	int
&&	O
ss	array
[	O
v	int
]	O
>	O
0.0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
(	O
sum	array
[	O
v	int
]	O
/	O
sumwt	array
[	O
v	int
]	O
)	O
*	O
sqrt	function
(	O
sumwt	array
[	O
v	int
]	O
*	O
(	O
dn	pointer
[	O
v	int
]	O
-	O
1.0	int
)	O
/	O
ss	array
[	O
v	int
]	O
)	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
if	O
(	O
stats	array
[	O
TPROB	O
]	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
typevar	int
]	O
,	O
"TPROB"	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
sumwt	array
[	O
v	int
]	O
>	O
0.0	int
&&	O
ss	array
[	O
v	int
]	O
>	O
0.0	int
)	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
2.0	int
*	O
probt	function
(	O
fabs	function
(	O
(	O
sum	array
[	O
v	int
]	O
/	O
sumwt	array
[	O
v	int
]	O
)	O
*	O
sqrt	function
(	O
sumwt	array
[	O
v	int
]	O
*	O
(	O
dn	pointer
[	O
v	int
]	O
-	O
1.0	int
)	O
/	O
ss	array
[	O
v	int
]	O
)	O
)	O
,	O
nobs	array
[	O
v	int
]	O
-	O
1	int
)	O
;	O
else	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
=	O
0.0	int
/	O
0.0	int
;	O
}	O
output	function
(	O
)	O
;	O
}	O
dap_swap	function
(	O
)	O
;	O
dap_free	function
(	O
dn	pointer
,	O
""	pointer
)	O
;	O
}	O
int	O
dap_list	function
(	O
char	O
*	O
varlist	array
,	O
int	O
*	O
varv	array
,	O
int	O
maxvars	int
)	O
{	O
int	O
nvars	int
;	O
int	O
m	int
;	O
int	O
i	int
;	O
char	O
*	O
mname	pointer
;	O
if	O
(	O
!	O
varlist	array
)	O
return	O
0	int
;	O
if	O
(	O
!	O
varv	array
)	O
{	O
fputs	function
(	O
"(dap_list) Missing variable index list.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
m	int
=	O
0	int
;	O
varlist	array
[	O
m	int
]	O
==	O
' '	O
;	O
m	int
++	O
)	O
;	O
mname	pointer
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
nvars	int
=	O
0	int
;	O
varlist	array
[	O
m	int
]	O
;	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
varlist	array
[	O
m	int
+	O
i	int
]	O
&&	O
varlist	array
[	O
m	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
mname	pointer
[	O
i	int
]	O
=	O
varlist	array
[	O
m	int
+	O
i	int
]	O
;	O
else	O
{	O
mname	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_list) variable name too long: %s\n"	pointer
,	O
mname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
mname	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
nvars	int
>=	O
maxvars	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_list) More than %d variables: %s\n"	pointer
,	O
maxvars	int
,	O
varlist	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
varv	array
[	O
nvars	int
++	O
]	O
=	O
dap_varnum	function
(	O
mname	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dap_list) variable unknown: %s\n"	pointer
,	O
mname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
m	int
+=	O
i	int
;	O
while	O
(	O
varlist	array
[	O
m	int
]	O
==	O
' '	O
)	O
m	int
++	O
;	O
}	O
dap_free	function
(	O
mname	pointer
,	O
""	pointer
)	O
;	O
return	O
nvars	int
;	O
}	O
int	O
dap_newpart	function
(	O
int	O
markv	array
[	O
]	O
,	O
int	O
nmark	int
)	O
{	O
int	O
marked	int
;	O
int	O
m	int
;	O
marked	int
=	O
0	int
;	O
if	O
(	O
dap_prev	array
[	O
0	int
]	O
.	O
do_valid	int
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_valid	int
)	O
{	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
nmark	int
;	O
m	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv	array
[	O
m	int
]	O
]	O
>	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
dap_prev	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
markv	array
[	O
m	int
]	O
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
markv	array
[	O
m	int
]	O
]	O
)	O
)	O
marked	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
markv	array
[	O
m	int
]	O
]	O
==	O
INT	int
)	O
{	O
if	O
(	O
dap_prev	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
markv	array
[	O
m	int
]	O
]	O
!=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
markv	array
[	O
m	int
]	O
]	O
)	O
marked	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
dap_prev	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
markv	array
[	O
m	int
]	O
]	O
!=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
markv	array
[	O
m	int
]	O
]	O
)	O
marked	int
=	O
1	int
;	O
}	O
}	O
}	O
else	O
marked	int
=	O
1	int
;	O
}	O
return	O
marked	int
;	O
}	O
void	O
means	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
varlist	array
,	O
char	O
*	O
statlist	array
,	O
char	O
*	O
marks	array
)	O
{	O
char	O
*	O
outname	pointer
;	O
int	O
stats	array
[	O
NSTATS	O
]	O
;	O
int	O
nonly	int
;	O
int	O
*	O
varv	array
;	O
int	O
*	O
markv	array
;	O
int	O
nvar	int
;	O
int	O
nmark	int
;	O
int	O
*	O
nobs	array
;	O
char	O
*	O
outlist	pointer
;	O
int	O
*	O
wtvar	pointer
;	O
double	O
*	O
sum	array
;	O
double	O
*	O
sumwt	array
;	O
double	O
*	O
ss	array
;	O
double	O
*	O
min	array
;	O
double	O
*	O
max	array
;	O
int	O
v	int
;	O
double	O
wt	double
;	O
double	O
vtmp	double
;	O
double	O
tmp	double
;	O
int	O
*	O
nnan	pointer
;	O
int	O
more	int
;	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(means) Missing input dataset name.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
outname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
dap_suffix	function
(	O
outname	pointer
,	O
fname	array
,	O
".mns"	pointer
)	O
;	O
varv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
markv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
wtvar	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
outlist	pointer
=	O
dap_malloc	function
(	O
dap_listlen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
dap_stats	function
(	O
statlist	array
,	O
stats	array
)	O
;	O
nvar	int
=	O
dap_mnsparse	function
(	O
varlist	array
,	O
outlist	pointer
,	O
varv	array
,	O
wtvar	pointer
,	O
stats	array
)	O
;	O
if	O
(	O
(	O
nonly	int
=	O
(	O
nvar	int
<	O
0	int
)	O
)	O
)	O
nvar	int
=	O
-	O
nvar	int
;	O
nobs	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
nnan	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
if	O
(	O
marks	array
&&	O
marks	array
[	O
0	int
]	O
)	O
{	O
strcat	function
(	O
outlist	pointer
,	O
" "	pointer
)	O
;	O
strcat	function
(	O
outlist	pointer
,	O
marks	array
)	O
;	O
}	O
outset	function
(	O
outname	pointer
,	O
outlist	pointer
)	O
;	O
nmark	int
=	O
dap_list	function
(	O
marks	array
,	O
markv	array
,	O
dap_maxvar	int
)	O
;	O
sum	array
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
sumwt	array
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
ss	array
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
min	array
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
max	array
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
double	O
)	O
*	O
nvar	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
sum	array
[	O
v	int
]	O
=	O
0.0	int
;	O
sumwt	array
[	O
v	int
]	O
=	O
0.0	int
;	O
ss	array
[	O
v	int
]	O
=	O
0.0	int
;	O
nobs	array
[	O
v	int
]	O
=	O
0	int
;	O
nnan	pointer
[	O
v	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
meansout	function
(	O
varv	array
,	O
nvar	int
,	O
nobs	array
,	O
sum	array
,	O
sumwt	array
,	O
min	array
,	O
max	array
,	O
ss	array
,	O
stats	array
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
nnan	pointer
[	O
v	int
]	O
)	O
{	O
dap_swap	function
(	O
)	O
;	O
fprintf	function
(	O
dap_log	pointer
,	O
"(means) %d NaNs for %s\n"	pointer
,	O
nnan	pointer
[	O
v	int
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
)	O
;	O
dap_swap	function
(	O
)	O
;	O
}	O
sum	array
[	O
v	int
]	O
=	O
0.0	int
;	O
sumwt	array
[	O
v	int
]	O
=	O
0.0	int
;	O
ss	array
[	O
v	int
]	O
=	O
0.0	int
;	O
nobs	array
[	O
v	int
]	O
=	O
0	int
;	O
nnan	pointer
[	O
v	int
]	O
=	O
0	int
;	O
}	O
}	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
nvar	int
;	O
v	int
++	O
)	O
{	O
vtmp	double
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
varv	array
[	O
v	int
]	O
]	O
;	O
if	O
(	O
wtvar	pointer
[	O
v	int
]	O
>=	O
0	int
)	O
wt	double
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
wtvar	pointer
[	O
v	int
]	O
]	O
;	O
else	O
wt	double
=	O
1.0	int
;	O
if	O
(	O
finite	function
(	O
vtmp	double
)	O
&&	O
finite	function
(	O
wt	double
)	O
)	O
{	O
if	O
(	O
!	O
nobs	array
[	O
v	int
]	O
)	O
{	O
min	array
[	O
v	int
]	O
=	O
vtmp	double
;	O
max	array
[	O
v	int
]	O
=	O
vtmp	double
;	O
}	O
else	O
{	O
if	O
(	O
vtmp	double
<	O
min	array
[	O
v	int
]	O
)	O
min	array
[	O
v	int
]	O
=	O
vtmp	double
;	O
if	O
(	O
vtmp	double
>	O
max	array
[	O
v	int
]	O
)	O
max	array
[	O
v	int
]	O
=	O
vtmp	double
;	O
tmp	double
=	O
sum	array
[	O
v	int
]	O
-	O
sumwt	array
[	O
v	int
]	O
*	O
vtmp	double
;	O
ss	array
[	O
v	int
]	O
+=	O
tmp	double
*	O
tmp	double
*	O
wt	double
/	O
(	O
sumwt	array
[	O
v	int
]	O
*	O
(	O
sumwt	array
[	O
v	int
]	O
+	O
wt	double
)	O
)	O
;	O
}	O
sumwt	array
[	O
v	int
]	O
+=	O
wt	double
;	O
sum	array
[	O
v	int
]	O
+=	O
vtmp	double
*	O
wt	double
;	O
nobs	array
[	O
v	int
]	O
++	O
;	O
}	O
else	O
if	O
(	O
nonly	int
)	O
nobs	array
[	O
v	int
]	O
++	O
;	O
else	O
nnan	pointer
[	O
v	int
]	O
++	O
;	O
}	O
}	O
dap_free	function
(	O
outname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
markv	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
nobs	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
outlist	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
wtvar	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
sum	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
sumwt	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
ss	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
min	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
max	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
nnan	pointer
,	O
""	pointer
)	O
;	O
}	O
typedef	O
struct	O
{	O
char	O
*	O
lab	pointer
;	O
int	O
labd	int
;	O
int	O
laba	int
;	O
int	O
labc	int
;	O
}	O
labnode	struct
;	O
static	O
char	O
tabform	array
[	O
7	int
]	O
;	O
static	O
char	O
emptyform	array
[	O
5	int
]	O
;	O
static	O
int	O
cellwidth	int
;	O
static	O
double	O
*	O
tabvalmem	pointer
;	O
static	O
double	O
*	O
*	O
tableval	pointer
;	O
static	O
int	O
*	O
valsetmem	pointer
;	O
static	O
int	O
*	O
*	O
valset	pointer
;	O
static	O
int	O
nrows	int
,	O
ncols	int
;	O
static	O
labnode	struct
*	O
collabel	pointer
;	O
static	O
int	O
labroot	int
;	O
static	O
int	O
nextclab	int
;	O
static	O
char	O
*	O
rlabmem	pointer
;	O
static	O
char	O
*	O
*	O
rlptrmem	pointer
;	O
static	O
char	O
*	O
*	O
*	O
rowlabel	pointer
;	O
static	O
int	O
rtitlesp	int
;	O
static	O
int	O
*	O
rowvar	pointer
;	O
static	O
int	O
nrowvar	int
;	O
static	O
int	O
*	O
colvar	pointer
;	O
static	O
int	O
ncolvar	int
;	O
static	O
int	O
colsort	int
;	O
static	O
int	O
newlab	function
(	O
char	O
lname	array
[	O
]	O
)	O
{	O
if	O
(	O
nextclab	int
==	O
dap_maxclab	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(newlab) too many column labels: %s\n"	pointer
,	O
lname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
strcpy	function
(	O
collabel	pointer
[	O
nextclab	int
]	O
.	O
lab	pointer
,	O
lname	array
)	O
;	O
collabel	pointer
[	O
nextclab	int
]	O
.	O
labd	int
=	O
-	O
1	int
;	O
collabel	pointer
[	O
nextclab	int
]	O
.	O
laba	int
=	O
-	O
1	int
;	O
collabel	pointer
[	O
nextclab	int
]	O
.	O
labc	int
=	O
-	O
1	int
;	O
return	O
nextclab	int
++	O
;	O
}	O
static	O
int	O
nodecnt	function
(	O
int	O
clab	int
)	O
{	O
int	O
across	int
;	O
int	O
totalcnt	int
;	O
if	O
(	O
collabel	pointer
[	O
clab	int
]	O
.	O
labd	int
<	O
0	int
)	O
return	O
1	int
;	O
for	O
(	O
across	int
=	O
collabel	pointer
[	O
clab	int
]	O
.	O
labd	int
,	O
totalcnt	int
=	O
0	int
;	O
across	int
>=	O
0	int
;	O
across	int
=	O
collabel	pointer
[	O
across	int
]	O
.	O
laba	int
)	O
totalcnt	int
+=	O
nodecnt	function
(	O
across	int
)	O
;	O
return	O
totalcnt	int
;	O
}	O
static	O
void	O
labelprint	function
(	O
char	O
name	array
[	O
]	O
,	O
int	O
width	int
)	O
{	O
static	O
char	O
*	O
label	pointer
=	O
NULL	O
;	O
int	O
c	int
;	O
if	O
(	O
!	O
label	pointer
)	O
label	pointer
=	O
dap_malloc	function
(	O
dap_strlen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
label	pointer
,	O
name	array
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
label	pointer
[	O
c	int
]	O
&&	O
c	int
<	O
width	int
;	O
c	int
++	O
)	O
;	O
while	O
(	O
c	int
<	O
width	int
)	O
label	pointer
[	O
c	int
++	O
]	O
=	O
' '	O
;	O
label	pointer
[	O
c	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_lst	pointer
,	O
"%s"	pointer
,	O
label	pointer
)	O
;	O
}	O
static	O
void	O
divider	function
(	O
int	O
left	int
,	O
int	O
conn	int
,	O
int	O
sep	int
,	O
int	O
right	int
,	O
int	O
nblank	int
)	O
{	O
int	O
col	int
;	O
int	O
c	int
;	O
int	O
connect	int
;	O
putc	function
(	O
left	int
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
nrowvar	int
;	O
col	int
++	O
)	O
{	O
if	O
(	O
col	int
<	O
nblank	int
)	O
connect	int
=	O
' '	O
;	O
else	O
connect	int
=	O
conn	int
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
rtitlesp	int
;	O
c	int
++	O
)	O
putc	function
(	O
connect	int
,	O
dap_lst	pointer
)	O
;	O
if	O
(	O
col	int
<	O
nrowvar	int
-	O
1	int
)	O
{	O
if	O
(	O
col	int
<	O
nblank	int
)	O
putc	function
(	O
left	int
,	O
dap_lst	pointer
)	O
;	O
else	O
putc	function
(	O
sep	int
,	O
dap_lst	pointer
)	O
;	O
}	O
else	O
putc	function
(	O
right	int
,	O
dap_lst	pointer
)	O
;	O
}	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
ncols	int
;	O
col	int
++	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
cellwidth	int
;	O
c	int
++	O
)	O
putc	function
(	O
conn	int
,	O
dap_lst	pointer
)	O
;	O
if	O
(	O
col	int
<	O
ncols	int
-	O
1	int
)	O
putc	function
(	O
sep	int
,	O
dap_lst	pointer
)	O
;	O
else	O
putc	function
(	O
right	int
,	O
dap_lst	pointer
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
static	O
void	O
tableline	function
(	O
int	O
start	array
,	O
int	O
depth	int
)	O
{	O
int	O
across	int
;	O
int	O
cnt	int
;	O
int	O
c	int
;	O
for	O
(	O
across	int
=	O
start	array
;	O
across	int
>=	O
0	int
;	O
across	int
=	O
collabel	pointer
[	O
across	int
]	O
.	O
laba	int
)	O
{	O
if	O
(	O
!	O
depth	int
)	O
{	O
labelprint	function
(	O
collabel	pointer
[	O
across	int
]	O
.	O
lab	pointer
,	O
cellwidth	int
)	O
;	O
cnt	int
=	O
nodecnt	function
(	O
across	int
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
(	O
cnt	int
-	O
1	int
)	O
*	O
(	O
cellwidth	int
+	O
1	int
)	O
;	O
c	int
++	O
)	O
putc	function
(	O
' '	O
,	O
dap_lst	pointer
)	O
;	O
putc	function
(	O
'|'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
else	O
tableline	function
(	O
collabel	pointer
[	O
across	int
]	O
.	O
labd	int
,	O
depth	int
-	O
1	int
)	O
;	O
}	O
}	O
static	O
void	O
tablehead	function
(	O
)	O
{	O
int	O
row	int
,	O
col	int
;	O
int	O
c	int
;	O
putc	function
(	O
' '	O
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
nrowvar	int
;	O
col	int
++	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
rtitlesp	int
+	O
1	int
;	O
c	int
++	O
)	O
putc	function
(	O
' '	O
,	O
dap_lst	pointer
)	O
;	O
}	O
fputs	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
colvar	pointer
[	O
ncolvar	int
-	O
1	int
]	O
]	O
,	O
dap_lst	pointer
)	O
;	O
if	O
(	O
colvar	pointer
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
fputs	function
(	O
" for "	pointer
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
ncolvar	int
-	O
1	int
;	O
col	int
++	O
)	O
{	O
fprintf	function
(	O
dap_lst	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
colvar	pointer
[	O
col	int
]	O
]	O
)	O
;	O
if	O
(	O
col	int
<	O
ncolvar	int
-	O
2	int
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
" / "	pointer
)	O
;	O
}	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
divider	function
(	O
'='	O
,	O
'='	O
,	O
'='	O
,	O
'='	O
,	O
0	int
)	O
;	O
for	O
(	O
row	int
=	O
0	int
;	O
row	int
<	O
ncolvar	int
-	O
1	int
;	O
row	int
++	O
)	O
{	O
if	O
(	O
row	int
<	O
ncolvar	int
-	O
2	int
)	O
{	O
putc	function
(	O
'|'	O
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
nrowvar	int
;	O
col	int
++	O
)	O
{	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
rtitlesp	int
;	O
c	int
++	O
)	O
putc	function
(	O
' '	O
,	O
dap_lst	pointer
)	O
;	O
if	O
(	O
col	int
<	O
nrowvar	int
-	O
1	int
)	O
putc	function
(	O
' '	O
,	O
dap_lst	pointer
)	O
;	O
else	O
putc	function
(	O
'|'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
}	O
else	O
{	O
putc	function
(	O
'|'	O
,	O
dap_lst	pointer
)	O
;	O
for	O
(	O
col	int
=	O
0	int
;	O
col	int
<	O
nrowvar	int
;	O
col	int
++	O
)	O
{	O
labelprint	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_nam	pointer
[	O
rowvar	pointer
[	O
col	int
]	O
]	O
,	O
rtitlesp	int
)	O
;	O
putc	function
(	O
'|'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
}	O
tableline	function
(	O
labroot	int
,	O
row	int
)	O
;	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
if	O
(	O
row	int
<	O
ncolvar	int
-	O
2	int
)	O
divider	function
(	O
'|'	O
,	O
'-'	O
,	O
'+'	O
,	O
'|'	O
,	O
0	int
)	O
;	O
}	O
divider	function
(	O
'|'	O
,	O
'='	O
,	O
'|'	O
,	O
'|'	O
,	O
0	int
)	O
;	O
}	O
static	O
void	O
valprint	function
(	O
int	O
row	int
,	O
int	O
node	int
)	O
{	O
while	O
(	O
node	int
>=	O
0	int
)	O
{	O
if	O
(	O
collabel	pointer
[	O
node	int
]	O
.	O
labd	int
>=	O
0	int
)	O
valprint	function
(	O
row	int
,	O
collabel	pointer
[	O
node	int
]	O
.	O
labd	int
)	O
;	O
else	O
{	O
if	O
(	O
valset	pointer
[	O
row	int
]	O
[	O
collabel	pointer
[	O
node	int
]	O
.	O
labc	int
]	O
)	O
fprintf	function
(	O
dap_lst	pointer
,	O
tabform	array
,	O
tableval	pointer
[	O
row	int
]	O
[	O
collabel	pointer
[	O
node	int
]	O
.	O
labc	int
]	O
)	O
;	O
else	O
fprintf	function
(	O
dap_lst	pointer
,	O
emptyform	array
,	O
""	pointer
)	O
;	O
putc	function
(	O
'|'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
node	int
=	O
collabel	pointer
[	O
node	int
]	O
.	O
laba	int
;	O
}	O
}	O
static	O
void	O
tableprint	function
(	O
)	O
{	O
int	O
row	int
,	O
col	int
;	O
int	O
isblank	int
;	O
int	O
nextblank	int
;	O
int	O
nblank	int
;	O
int	O
nextnblank	int
;	O
for	O
(	O
row	int
=	O
0	int
;	O
row	int
<=	O
nrows	int
;	O
row	int
++	O
)	O
{	O
putc	function
(	O
'|'	O
,	O
dap_lst	pointer
)	O
;	O
nblank	int
=	O
0	int
;	O
nextnblank	int
=	O
0	int
;	O
for	O
(	O
col	int
=	O
0	int
,	O
isblank	int
=	O
1	int
,	O
nextblank	int
=	O
1	int
;	O
col	int
<	O
nrowvar	int
;	O
col	int
++	O
)	O
{	O
if	O
(	O
isblank	int
&&	O
rowlabel	pointer
[	O
row	int
]	O
[	O
col	int
]	O
[	O
0	int
]	O
)	O
{	O
nblank	int
=	O
col	int
;	O
isblank	int
=	O
0	int
;	O
}	O
if	O
(	O
nextblank	int
&&	O
row	int
<=	O
nrows	int
-	O
1	int
&&	O
rowlabel	pointer
[	O
row	int
+	O
1	int
]	O
[	O
col	int
]	O
[	O
0	int
]	O
)	O
{	O
nextnblank	int
=	O
col	int
;	O
nextblank	int
=	O
0	int
;	O
}	O
labelprint	function
(	O
rowlabel	pointer
[	O
row	int
]	O
[	O
col	int
]	O
,	O
rtitlesp	int
)	O
;	O
putc	function
(	O
'|'	O
,	O
dap_lst	pointer
)	O
;	O
}	O
valprint	function
(	O
row	int
,	O
labroot	int
)	O
;	O
putc	function
(	O
'\n'	O
,	O
dap_lst	pointer
)	O
;	O
if	O
(	O
nextnblank	int
!=	O
nblank	int
)	O
nblank	int
=	O
nextnblank	int
;	O
if	O
(	O
row	int
<=	O
nrows	int
-	O
1	int
)	O
divider	function
(	O
'|'	O
,	O
'-'	O
,	O
'+'	O
,	O
'|'	O
,	O
nblank	int
)	O
;	O
else	O
divider	function
(	O
'-'	O
,	O
'-'	O
,	O
'-'	O
,	O
'-'	O
,	O
0	int
)	O
;	O
}	O
}	O
static	O
int	O
findcol	function
(	O
)	O
{	O
int	O
varn	int
;	O
int	O
node	int
,	O
prevnode	int
,	O
nextnode	int
;	O
int	O
upnode	int
;	O
int	O
cmp	int
;	O
char	O
*	O
label	pointer
;	O
nextnode	int
=	O
-	O
1	int
;	O
if	O
(	O
colsort	int
&&	O
colvar	pointer
[	O
0	int
]	O
>=	O
0	int
)	O
{	O
for	O
(	O
node	int
=	O
labroot	int
,	O
varn	int
=	O
0	int
,	O
upnode	int
=	O
-	O
1	int
;	O
varn	int
<	O
ncolvar	int
-	O
1	int
;	O
varn	int
++	O
)	O
{	O
if	O
(	O
node	int
>=	O
0	int
)	O
{	O
for	O
(	O
nextnode	int
=	O
collabel	pointer
[	O
node	int
]	O
.	O
laba	int
;	O
nextnode	int
>=	O
0	int
&&	O
strcmp	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
varn	int
]	O
]	O
,	O
collabel	pointer
[	O
nextnode	int
]	O
.	O
lab	pointer
)	O
>=	O
0	int
;	O
)	O
{	O
node	int
=	O
nextnode	int
;	O
nextnode	int
=	O
collabel	pointer
[	O
nextnode	int
]	O
.	O
laba	int
;	O
}	O
cmp	int
=	O
strcmp	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
varn	int
]	O
]	O
,	O
collabel	pointer
[	O
node	int
]	O
.	O
lab	pointer
)	O
;	O
}	O
else	O
cmp	int
=	O
-	O
1	int
;	O
if	O
(	O
cmp	int
<	O
0	int
)	O
{	O
if	O
(	O
upnode	int
>=	O
0	int
)	O
{	O
nextnode	int
=	O
node	int
;	O
node	int
=	O
newlab	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
varn	int
]	O
]	O
)	O
;	O
collabel	pointer
[	O
upnode	int
]	O
.	O
labd	int
=	O
node	int
;	O
collabel	pointer
[	O
node	int
]	O
.	O
laba	int
=	O
nextnode	int
;	O
}	O
else	O
{	O
labroot	int
=	O
newlab	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
varn	int
]	O
]	O
)	O
;	O
collabel	pointer
[	O
labroot	int
]	O
.	O
laba	int
=	O
node	int
;	O
node	int
=	O
labroot	int
;	O
}	O
}	O
else	O
if	O
(	O
cmp	int
>	O
0	int
)	O
{	O
collabel	pointer
[	O
node	int
]	O
.	O
laba	int
=	O
newlab	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
varn	int
]	O
]	O
)	O
;	O
node	int
=	O
collabel	pointer
[	O
node	int
]	O
.	O
laba	int
;	O
collabel	pointer
[	O
node	int
]	O
.	O
laba	int
=	O
nextnode	int
;	O
}	O
upnode	int
=	O
node	int
;	O
node	int
=	O
collabel	pointer
[	O
node	int
]	O
.	O
labd	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
node	int
=	O
labroot	int
,	O
varn	int
=	O
0	int
,	O
upnode	int
=	O
-	O
1	int
;	O
varn	int
<	O
ncolvar	int
-	O
1	int
;	O
varn	int
++	O
)	O
{	O
if	O
(	O
colvar	pointer
[	O
0	int
]	O
>=	O
0	int
)	O
label	pointer
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
varn	int
]	O
]	O
;	O
else	O
label	pointer
=	O
""	pointer
;	O
for	O
(	O
prevnode	int
=	O
-	O
1	int
;	O
node	int
>=	O
0	int
&&	O
strcmp	function
(	O
label	pointer
,	O
collabel	pointer
[	O
node	int
]	O
.	O
lab	pointer
)	O
;	O
)	O
{	O
prevnode	int
=	O
node	int
;	O
node	int
=	O
collabel	pointer
[	O
node	int
]	O
.	O
laba	int
;	O
}	O
if	O
(	O
node	int
<	O
0	int
)	O
{	O
node	int
=	O
newlab	function
(	O
label	pointer
)	O
;	O
if	O
(	O
prevnode	int
>=	O
0	int
)	O
collabel	pointer
[	O
prevnode	int
]	O
.	O
laba	int
=	O
node	int
;	O
else	O
if	O
(	O
upnode	int
>=	O
0	int
)	O
collabel	pointer
[	O
upnode	int
]	O
.	O
labd	int
=	O
node	int
;	O
else	O
labroot	int
=	O
node	int
;	O
}	O
upnode	int
=	O
node	int
;	O
node	int
=	O
collabel	pointer
[	O
node	int
]	O
.	O
labd	int
;	O
}	O
}	O
if	O
(	O
collabel	pointer
[	O
upnode	int
]	O
.	O
labc	int
<	O
0	int
)	O
{	O
if	O
(	O
ncols	int
>=	O
dap_maxcols	int
)	O
{	O
fputs	function
(	O
"(findcol) too many columns in table\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
collabel	pointer
[	O
upnode	int
]	O
.	O
labc	int
=	O
ncols	int
++	O
;	O
}	O
return	O
collabel	pointer
[	O
upnode	int
]	O
.	O
labc	int
;	O
}	O
static	O
void	O
tableform	function
(	O
char	O
tform	array
[	O
]	O
)	O
{	O
char	O
width	int
[	O
7	int
]	O
;	O
int	O
w	int
;	O
int	O
forg	int
;	O
strcpy	function
(	O
width	int
,	O
tform	array
)	O
;	O
for	O
(	O
w	int
=	O
0	int
;	O
width	int
[	O
w	int
]	O
&&	O
width	int
[	O
w	int
]	O
!=	O
'.'	O
;	O
w	int
++	O
)	O
;	O
if	O
(	O
width	int
[	O
w	int
]	O
==	O
'.'	O
)	O
forg	int
=	O
'f'	O
;	O
else	O
forg	int
=	O
'g'	O
;	O
width	int
[	O
w	int
]	O
=	O
'\0'	O
;	O
cellwidth	int
=	O
atoi	function
(	O
width	int
)	O
;	O
strcpy	function
(	O
tabform	array
,	O
"%"	pointer
)	O
;	O
if	O
(	O
forg	int
==	O
'f'	O
)	O
{	O
strcat	function
(	O
tabform	array
,	O
tform	array
)	O
;	O
strcat	function
(	O
tabform	array
,	O
"f"	pointer
)	O
;	O
}	O
else	O
{	O
strcat	function
(	O
tabform	array
,	O
width	int
)	O
;	O
strcat	function
(	O
tabform	array
,	O
"g"	pointer
)	O
;	O
}	O
sprintf	function
(	O
emptyform	array
,	O
"%%%ds"	pointer
,	O
cellwidth	int
)	O
;	O
}	O
static	O
void	O
specparse	function
(	O
char	O
rowvars	array
[	O
]	O
,	O
char	O
colvars	array
[	O
]	O
,	O
char	O
format	array
[	O
]	O
)	O
{	O
int	O
t	int
;	O
int	O
i	int
;	O
int	O
sp	int
;	O
char	O
*	O
vname	array
;	O
int	O
v	int
;	O
vname	array
=	O
dap_malloc	function
(	O
dap_namelen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
nrowvar	int
=	O
0	int
;	O
ncolvar	int
=	O
0	int
;	O
for	O
(	O
t	int
=	O
0	int
;	O
rowvars	array
[	O
t	int
]	O
==	O
' '	O
;	O
t	int
++	O
)	O
;	O
while	O
(	O
rowvars	array
[	O
t	int
]	O
)	O
{	O
while	O
(	O
rowvars	array
[	O
t	int
]	O
==	O
' '	O
)	O
t	int
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
rowvars	array
[	O
t	int
+	O
i	int
]	O
&&	O
rowvars	array
[	O
t	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
vname	array
[	O
i	int
]	O
=	O
rowvars	array
[	O
t	int
+	O
i	int
]	O
;	O
else	O
{	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(specparse) Row variable name too long: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
vname	array
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
nrowvar	int
<	O
dap_maxrowv	int
)	O
rowvar	pointer
[	O
nrowvar	int
++	O
]	O
=	O
v	int
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(specparse) Too many row variables: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(specparse) Unknown row variable: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
t	int
+=	O
i	int
;	O
while	O
(	O
rowvars	array
[	O
t	int
]	O
==	O
' '	O
)	O
t	int
++	O
;	O
}	O
for	O
(	O
t	int
=	O
0	int
;	O
colvars	array
[	O
t	int
]	O
==	O
' '	O
;	O
t	int
++	O
)	O
;	O
while	O
(	O
colvars	array
[	O
t	int
]	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
colvars	array
[	O
t	int
+	O
i	int
]	O
&&	O
colvars	array
[	O
t	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
vname	array
[	O
i	int
]	O
=	O
colvars	array
[	O
t	int
+	O
i	int
]	O
;	O
else	O
{	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(specparse) Column variable name too long: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
(	O
v	int
=	O
dap_varnum	function
(	O
vname	array
)	O
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
ncolvar	int
<	O
dap_maxcolv	int
)	O
colvar	pointer
[	O
ncolvar	int
++	O
]	O
=	O
v	int
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(specparse) Too many column variables: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(specparse) Unknown column variable: %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
t	int
+=	O
i	int
;	O
while	O
(	O
colvars	array
[	O
t	int
]	O
==	O
' '	O
)	O
t	int
++	O
;	O
}	O
for	O
(	O
t	int
=	O
0	int
;	O
format	array
[	O
t	int
]	O
==	O
' '	O
;	O
t	int
++	O
)	O
;	O
if	O
(	O
format	array
[	O
t	int
]	O
==	O
's'	O
)	O
{	O
colsort	int
=	O
1	int
;	O
for	O
(	O
t	int
++	O
;	O
format	array
[	O
t	int
]	O
==	O
' '	O
;	O
t	int
++	O
)	O
;	O
}	O
else	O
colsort	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
format	array
[	O
t	int
+	O
i	int
]	O
&&	O
format	array
[	O
t	int
+	O
i	int
]	O
!=	O
' '	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
<	O
dap_namelen	int
)	O
vname	array
[	O
i	int
]	O
=	O
format	array
[	O
t	int
+	O
i	int
]	O
;	O
else	O
{	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(specparse) Format too long %s\n"	pointer
,	O
vname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
vname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
tableform	function
(	O
vname	array
)	O
;	O
for	O
(	O
t	int
+=	O
i	int
;	O
format	array
[	O
t	int
]	O
==	O
' '	O
;	O
t	int
++	O
)	O
;	O
if	O
(	O
format	array
[	O
t	int
]	O
)	O
{	O
for	O
(	O
sp	int
=	O
0	int
;	O
'0'	O
<=	O
format	array
[	O
t	int
]	O
&&	O
format	array
[	O
t	int
]	O
<=	O
'9'	O
;	O
t	int
++	O
)	O
sp	int
=	O
10	int
*	O
sp	int
+	O
format	array
[	O
t	int
]	O
-	O
'0'	O
;	O
if	O
(	O
format	array
[	O
t	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(specparse) Extra character(s) at end of format: %s\n"	pointer
,	O
format	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
rtitlesp	int
=	O
(	O
sp	int
-	O
1	int
)	O
/	O
nrowvar	int
;	O
}	O
if	O
(	O
!	O
tabform	array
[	O
0	int
]	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(specparse) No format\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
ncolvar	int
)	O
{	O
fputs	function
(	O
"(specparse) No column or analysis variable(s) specified.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
ncolvar	int
<	O
2	int
)	O
{	O
colvar	pointer
[	O
1	int
]	O
=	O
colvar	pointer
[	O
0	int
]	O
;	O
colvar	pointer
[	O
0	int
]	O
=	O
-	O
1	int
;	O
ncolvar	int
=	O
2	int
;	O
}	O
dap_free	function
(	O
vname	array
,	O
""	pointer
)	O
;	O
}	O
void	O
table	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
rowvars	array
,	O
char	O
*	O
colvars	array
,	O
char	O
*	O
format	array
,	O
char	O
*	O
marks	array
)	O
{	O
static	O
int	O
tabinit	int
=	O
0	int
;	O
static	O
char	O
*	O
prevmem	pointer
;	O
static	O
char	O
*	O
*	O
prev	pointer
;	O
int	O
r	double
;	O
int	O
s	int
;	O
int	O
c	int
;	O
int	O
v	int
;	O
static	O
int	O
*	O
markv	array
;	O
int	O
nmark	int
;	O
int	O
more	int
;	O
static	O
char	O
*	O
nstring	pointer
;	O
if	O
(	O
!	O
tabinit	int
)	O
{	O
tabinit	int
=	O
1	int
;	O
valsetmem	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
dap_maxrows	int
*	O
dap_maxcols	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
""	pointer
)	O
;	O
valset	pointer
=	O
(	O
int	O
*	O
*	O
)	O
dap_malloc	function
(	O
dap_maxrows	int
*	O
sizeof	O
(	O
int	O
*	O
)	O
,	O
""	pointer
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
dap_maxrows	int
;	O
r	double
++	O
)	O
valset	pointer
[	O
r	double
]	O
=	O
valsetmem	pointer
+	O
dap_maxcols	int
*	O
r	double
;	O
tabvalmem	pointer
=	O
(	O
double	O
*	O
)	O
dap_malloc	function
(	O
dap_maxrows	int
*	O
dap_maxcols	int
*	O
sizeof	O
(	O
double	O
)	O
,	O
""	pointer
)	O
;	O
tableval	pointer
=	O
(	O
double	O
*	O
*	O
)	O
dap_malloc	function
(	O
dap_maxrows	int
*	O
sizeof	O
(	O
double	O
*	O
)	O
,	O
""	pointer
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
dap_maxrows	int
;	O
r	double
++	O
)	O
tableval	pointer
[	O
r	double
]	O
=	O
tabvalmem	pointer
+	O
dap_maxcols	int
*	O
r	double
;	O
collabel	pointer
=	O
(	O
labnode	struct
*	O
)	O
dap_malloc	function
(	O
dap_maxclab	int
*	O
sizeof	O
(	O
labnode	struct
)	O
,	O
""	pointer
)	O
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
dap_maxclab	int
;	O
c	int
++	O
)	O
collabel	pointer
[	O
c	int
]	O
.	O
lab	pointer
=	O
dap_malloc	function
(	O
dap_lablen	int
+	O
1	int
,	O
""	pointer
)	O
;	O
rowvar	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
colvar	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
rlabmem	pointer
=	O
dap_malloc	function
(	O
dap_maxrows	int
*	O
dap_maxrowv	int
*	O
(	O
dap_lablen	int
+	O
1	int
)	O
,	O
""	pointer
)	O
;	O
rlptrmem	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxrows	int
*	O
dap_maxrowv	int
,	O
""	pointer
)	O
;	O
rowlabel	pointer
=	O
(	O
char	O
*	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
*	O
)	O
*	O
dap_maxrows	int
,	O
""	pointer
)	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
dap_maxrows	int
;	O
r	double
++	O
)	O
{	O
rowlabel	pointer
[	O
r	double
]	O
=	O
rlptrmem	pointer
+	O
r	double
*	O
dap_maxrowv	int
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxrowv	int
;	O
v	int
++	O
)	O
rowlabel	pointer
[	O
r	double
]	O
[	O
v	int
]	O
=	O
rlabmem	pointer
+	O
r	double
*	O
(	O
dap_maxrowv	int
*	O
(	O
dap_lablen	int
+	O
1	int
)	O
)	O
+	O
v	int
*	O
(	O
dap_lablen	int
+	O
1	int
)	O
;	O
}	O
prevmem	pointer
=	O
dap_malloc	function
(	O
dap_maxrowv	int
*	O
(	O
dap_lablen	int
+	O
1	int
)	O
,	O
""	pointer
)	O
;	O
prev	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
dap_maxrowv	int
,	O
""	pointer
)	O
;	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
dap_maxrowv	int
;	O
v	int
++	O
)	O
prev	pointer
[	O
v	int
]	O
=	O
prevmem	pointer
+	O
v	int
*	O
(	O
dap_lablen	int
+	O
1	int
)	O
;	O
markv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
dap_maxvar	int
,	O
""	pointer
)	O
;	O
nstring	pointer
=	O
dap_malloc	function
(	O
dap_strlen	int
+	O
1	int
,	O
"dap_strlen"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
fname	array
)	O
{	O
fputs	function
(	O
"(table) no dataset name given\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
inset	function
(	O
fname	array
)	O
;	O
tabform	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
rtitlesp	int
=	O
8	int
;	O
if	O
(	O
!	O
rowvars	array
||	O
!	O
colvars	array
)	O
{	O
fputs	function
(	O
"(table) no row and/or column variables specified\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
format	array
)	O
{	O
fputs	function
(	O
"(table) no format given\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
specparse	function
(	O
rowvars	array
,	O
colvars	array
,	O
format	array
)	O
;	O
nmark	int
=	O
dap_list	function
(	O
marks	array
,	O
markv	array
,	O
dap_maxvar	int
)	O
;	O
nextclab	int
=	O
0	int
;	O
labroot	int
=	O
-	O
1	int
;	O
ncols	int
=	O
0	int
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nrowvar	int
;	O
r	double
++	O
)	O
{	O
prev	pointer
[	O
r	double
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
<=	O
0	int
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
)	O
dap_free	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
,	O
""	pointer
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
=	O
dap_malloc	function
(	O
rtitlesp	int
+	O
1	int
,	O
""	pointer
)	O
;	O
}	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
ncolvar	int
-	O
1	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
<=	O
0	int
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
)	O
dap_free	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
,	O
""	pointer
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
=	O
dap_malloc	function
(	O
rtitlesp	int
+	O
1	int
,	O
""	pointer
)	O
;	O
}	O
}	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
dap_maxrows	int
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
dap_maxcols	int
;	O
c	int
++	O
)	O
valset	pointer
[	O
r	double
]	O
[	O
c	int
]	O
=	O
0	int
;	O
for	O
(	O
nrows	int
=	O
-	O
1	int
,	O
more	int
=	O
1	int
;	O
more	int
;	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
markv	array
,	O
nmark	int
)	O
)	O
{	O
dap_swap	function
(	O
)	O
;	O
dap_head	function
(	O
markv	array
,	O
nmark	int
)	O
;	O
tablehead	function
(	O
)	O
;	O
tableprint	function
(	O
)	O
;	O
dap_swap	function
(	O
)	O
;	O
nextclab	int
=	O
0	int
;	O
labroot	int
=	O
-	O
1	int
;	O
ncols	int
=	O
0	int
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nrowvar	int
;	O
r	double
++	O
)	O
prev	pointer
[	O
r	double
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
dap_maxrows	int
;	O
r	double
++	O
)	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
dap_maxcols	int
;	O
c	int
++	O
)	O
valset	pointer
[	O
r	double
]	O
[	O
c	int
]	O
=	O
0	int
;	O
nrows	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nrowvar	int
;	O
r	double
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
==	O
INT	int
)	O
{	O
sprintf	function
(	O
nstring	pointer
,	O
"%d"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
)	O
;	O
strncpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
,	O
nstring	pointer
,	O
rtitlesp	int
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
[	O
rtitlesp	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
==	O
DBL	O
)	O
{	O
sprintf	function
(	O
nstring	pointer
,	O
"%g"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
)	O
;	O
strncpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
,	O
nstring	pointer
,	O
rtitlesp	int
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
[	O
rtitlesp	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
for	O
(	O
r	double
=	O
0	int
;	O
r	double
<	O
nrowvar	int
;	O
r	double
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
,	O
prev	pointer
[	O
r	double
]	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
r	double
<	O
nrowvar	int
)	O
{	O
nrows	int
++	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
r	double
;	O
s	int
++	O
)	O
rowlabel	pointer
[	O
nrows	int
]	O
[	O
s	int
]	O
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
;	O
r	double
<	O
nrowvar	int
;	O
r	double
++	O
)	O
{	O
strcpy	function
(	O
prev	pointer
[	O
r	double
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
)	O
;	O
strcpy	function
(	O
rowlabel	pointer
[	O
nrows	int
]	O
[	O
r	double
]	O
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
rowvar	pointer
[	O
r	double
]	O
]	O
)	O
;	O
}	O
}	O
if	O
(	O
nrows	int
<	O
0	int
)	O
{	O
fputs	function
(	O
"(table) No rows.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
ncolvar	int
-	O
1	int
;	O
c	int
++	O
)	O
{	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
==	O
INT	int
)	O
{	O
sprintf	function
(	O
nstring	pointer
,	O
"%d"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_int	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
)	O
;	O
strncpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
,	O
nstring	pointer
,	O
rtitlesp	int
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
[	O
rtitlesp	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_len	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
==	O
DBL	O
)	O
{	O
sprintf	function
(	O
nstring	pointer
,	O
"%g"	pointer
,	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
)	O
;	O
strncpy	function
(	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
,	O
nstring	pointer
,	O
rtitlesp	int
)	O
;	O
dap_obs	array
[	O
0	int
]	O
.	O
do_str	pointer
[	O
colvar	pointer
[	O
c	int
]	O
]	O
[	O
rtitlesp	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
c	int
=	O
findcol	function
(	O
)	O
;	O
tableval	pointer
[	O
nrows	int
]	O
[	O
c	int
]	O
=	O
dap_obs	array
[	O
0	int
]	O
.	O
do_dbl	pointer
[	O
colvar	pointer
[	O
ncolvar	int
-	O
1	int
]	O
]	O
;	O
valset	pointer
[	O
nrows	int
]	O
[	O
c	int
]	O
=	O
1	int
;	O
}	O
}	O
void	O
split	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
varlist	array
,	O
char	O
*	O
classvalvars	pointer
)	O
{	O
char	O
*	O
skiplist	pointer
;	O
char	O
*	O
outname	pointer
;	O
char	O
*	O
classvar	pointer
;	O
char	O
*	O
valuevar	pointer
;	O
int	O
s	int
,	O
t	int
;	O
char	O
*	O
varname	pointer
;	O
int	O
maxname	int
;	O
int	O
*	O
var	pointer
;	O
int	O
nv	int
;	O
int	O
vv	int
;	O
int	O
vlen	int
;	O
int	O
prevlen	int
;	O
int	O
classv	int
,	O
valuev	int
;	O
classvar	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
6	int
,	O
""	pointer
)	O
;	O
valuevar	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
6	int
,	O
""	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
classvalvars	pointer
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
classvalvars	pointer
[	O
s	int
]	O
&&	O
classvalvars	pointer
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
classvar	pointer
[	O
t	int
++	O
]	O
=	O
classvalvars	pointer
[	O
s	int
++	O
]	O
;	O
classvar	pointer
[	O
t	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
t	int
)	O
{	O
fputs	function
(	O
"(split) No classification variable specified.\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
classvalvars	pointer
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
classvalvars	pointer
[	O
s	int
]	O
&&	O
classvalvars	pointer
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
valuevar	pointer
[	O
t	int
++	O
]	O
=	O
classvalvars	pointer
[	O
s	int
++	O
]	O
;	O
valuevar	pointer
[	O
t	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
t	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(split) No value variable specified: %s\n"	pointer
,	O
classvalvars	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
var	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
)	O
*	O
(	O
(	O
strlen	function
(	O
varlist	array
)	O
+	O
1	int
)	O
/	O
2	int
)	O
,	O
""	pointer
)	O
;	O
varname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
1	int
,	O
""	pointer
)	O
;	O
skiplist	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
varlist	array
)	O
+	O
2	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
skiplist	pointer
,	O
"!"	pointer
)	O
;	O
strcat	function
(	O
skiplist	pointer
,	O
varlist	array
)	O
;	O
outname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
outname	pointer
,	O
fname	array
)	O
;	O
strcat	function
(	O
outname	pointer
,	O
".spl"	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
varlist	array
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
nv	int
=	O
0	int
,	O
prevlen	int
=	O
DBL	O
-	O
1	int
,	O
maxname	int
=	O
0	int
;	O
varlist	array
[	O
s	int
]	O
;	O
nv	int
++	O
)	O
{	O
for	O
(	O
t	int
=	O
0	int
;	O
varlist	array
[	O
s	int
]	O
&&	O
varlist	array
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
varname	pointer
[	O
t	int
++	O
]	O
=	O
varlist	array
[	O
s	int
++	O
]	O
;	O
varname	pointer
[	O
t	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
t	int
>	O
maxname	int
)	O
maxname	int
=	O
t	int
;	O
if	O
(	O
(	O
var	pointer
[	O
nv	int
]	O
=	O
dap_varnum	function
(	O
varname	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(split) Unknown variable: %s\n"	pointer
,	O
varname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
vlen	int
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
var	pointer
[	O
nv	int
]	O
]	O
;	O
if	O
(	O
prevlen	int
<	O
DBL	O
)	O
prevlen	int
=	O
vlen	int
;	O
else	O
if	O
(	O
prevlen	int
!=	O
vlen	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(split) Length of %s (%d) differs from that of previous variables (%d)\n"	pointer
,	O
varname	pointer
,	O
vlen	int
,	O
prevlen	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
while	O
(	O
varlist	array
[	O
s	int
]	O
==	O
' '	O
)	O
s	int
++	O
;	O
}	O
sprintf	function
(	O
classvar	pointer
+	O
strlen	function
(	O
classvar	pointer
)	O
,	O
" %d"	pointer
,	O
maxname	int
)	O
;	O
classv	int
=	O
dap_vd	function
(	O
classvar	pointer
,	O
0	int
)	O
;	O
sprintf	function
(	O
valuevar	pointer
+	O
strlen	function
(	O
valuevar	pointer
)	O
,	O
" %d"	pointer
,	O
vlen	int
)	O
;	O
valuev	int
=	O
dap_vd	function
(	O
valuevar	pointer
,	O
0	int
)	O
;	O
outset	function
(	O
outname	pointer
,	O
skiplist	pointer
)	O
;	O
while	O
(	O
step	function
(	O
)	O
)	O
{	O
for	O
(	O
vv	int
=	O
0	int
;	O
vv	int
<	O
nv	int
;	O
vv	int
++	O
)	O
{	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
classv	int
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
var	pointer
[	O
vv	int
]	O
]	O
)	O
;	O
if	O
(	O
vlen	int
==	O
DBL	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
valuev	int
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
var	pointer
[	O
vv	int
]	O
]	O
;	O
else	O
if	O
(	O
vlen	int
==	O
INT	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
valuev	int
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
var	pointer
[	O
vv	int
]	O
]	O
;	O
else	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
valuev	int
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
var	pointer
[	O
vv	int
]	O
]	O
)	O
;	O
output	function
(	O
)	O
;	O
}	O
}	O
dap_free	function
(	O
classvar	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
valuevar	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
var	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
skiplist	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
outname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varname	pointer
,	O
""	pointer
)	O
;	O
}	O
void	O
join	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
partvars	pointer
,	O
char	O
*	O
valuevar	pointer
)	O
{	O
char	O
*	O
partvars1	pointer
;	O
int	O
npart	int
;	O
char	O
*	O
classvar	pointer
;	O
int	O
s	int
,	O
t	int
;	O
char	O
*	O
outname	pointer
;	O
char	O
*	O
skiplist	pointer
;	O
int	O
cv	int
;	O
int	O
vv	int
;	O
int	O
nnew	int
;	O
int	O
nv	int
;	O
int	O
vlen	int
;	O
int	O
*	O
partv	array
;	O
int	O
*	O
newv	pointer
;	O
int	O
valv	int
;	O
int	O
vallen	int
;	O
char	O
*	O
varspec	array
;	O
int	O
more	int
;	O
int	O
np	int
;	O
outname	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
fname	array
)	O
+	O
5	int
,	O
""	pointer
)	O
;	O
strcpy	function
(	O
outname	pointer
,	O
fname	array
)	O
;	O
strcat	function
(	O
outname	pointer
,	O
".joi"	pointer
)	O
;	O
newv	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
dap_maxvar	int
,	O
"dap_maxvar"	pointer
)	O
;	O
partvars1	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
partvars	pointer
)	O
+	O
1	int
,	O
""	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
partvars	pointer
[	O
s	int
]	O
==	O
' '	O
;	O
s	int
++	O
)	O
;	O
for	O
(	O
npart	int
=	O
0	int
;	O
partvars	pointer
[	O
s	int
]	O
;	O
)	O
{	O
for	O
(	O
t	int
=	O
s	int
;	O
partvars	pointer
[	O
t	int
]	O
&&	O
partvars	pointer
[	O
t	int
]	O
!=	O
' '	O
;	O
t	int
++	O
)	O
;	O
while	O
(	O
partvars	pointer
[	O
t	int
]	O
==	O
' '	O
)	O
t	int
++	O
;	O
if	O
(	O
partvars	pointer
[	O
t	int
]	O
)	O
{	O
s	int
=	O
t	int
;	O
npart	int
++	O
;	O
}	O
else	O
break	O
;	O
}	O
strncpy	function
(	O
partvars1	pointer
,	O
partvars	pointer
,	O
s	int
)	O
;	O
partvars1	pointer
[	O
s	int
]	O
=	O
'\0'	O
;	O
classvar	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
partvars	pointer
)	O
-	O
s	int
+	O
2	int
,	O
""	pointer
)	O
;	O
for	O
(	O
t	int
=	O
0	int
;	O
partvars	pointer
[	O
s	int
]	O
&&	O
partvars	pointer
[	O
s	int
]	O
!=	O
' '	O
;	O
)	O
classvar	pointer
[	O
t	int
++	O
]	O
=	O
partvars	pointer
[	O
s	int
++	O
]	O
;	O
classvar	pointer
[	O
t	int
]	O
=	O
'\0'	O
;	O
skiplist	pointer
=	O
dap_malloc	function
(	O
strlen	function
(	O
classvar	pointer
)	O
+	O
strlen	function
(	O
valuevar	pointer
)	O
+	O
3	int
,	O
""	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
classvar	pointer
,	O
"_type_"	pointer
)	O
)	O
sprintf	function
(	O
skiplist	pointer
,	O
"!%s %s"	pointer
,	O
classvar	pointer
,	O
valuevar	pointer
)	O
;	O
else	O
sprintf	function
(	O
skiplist	pointer
,	O
"!%s"	pointer
,	O
valuevar	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
if	O
(	O
(	O
cv	int
=	O
dap_varnum	function
(	O
classvar	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(join) Unknown variable: %s\n"	pointer
,	O
classvar	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
valv	int
=	O
dap_varnum	function
(	O
valuevar	pointer
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(join) Unknown variable: %s\n"	pointer
,	O
valuevar	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
vallen	int
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
valv	int
]	O
;	O
vlen	int
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_len	pointer
[	O
cv	int
]	O
;	O
varspec	array
=	O
dap_malloc	function
(	O
vlen	int
+	O
5	int
,	O
""	pointer
)	O
;	O
if	O
(	O
vlen	int
<=	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(join) Variable %s not string variable (%d)\n"	pointer
,	O
classvar	pointer
,	O
vlen	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
dap_mark	function
(	O
)	O
;	O
partv	array
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
sizeof	O
(	O
int	O
*	O
)	O
*	O
npart	int
,	O
""	pointer
)	O
;	O
dap_list	function
(	O
partvars1	pointer
,	O
partv	array
,	O
npart	int
)	O
;	O
for	O
(	O
nnew	int
=	O
0	int
;	O
step	function
(	O
)	O
;	O
nnew	int
++	O
)	O
{	O
if	O
(	O
dap_newpart	function
(	O
partv	array
,	O
npart	int
)	O
)	O
break	O
;	O
strcpy	function
(	O
varspec	array
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
cv	int
]	O
)	O
;	O
sprintf	function
(	O
varspec	array
+	O
strlen	function
(	O
varspec	array
)	O
,	O
" %d"	pointer
,	O
vallen	int
)	O
;	O
newv	pointer
[	O
nnew	int
]	O
=	O
dap_vd	function
(	O
varspec	array
,	O
0	int
)	O
;	O
}	O
dap_rewind	function
(	O
)	O
;	O
outset	function
(	O
outname	pointer
,	O
skiplist	pointer
)	O
;	O
for	O
(	O
more	int
=	O
1	int
,	O
nv	int
=	O
0	int
;	O
more	int
;	O
nv	int
++	O
)	O
{	O
more	int
=	O
step	function
(	O
)	O
;	O
if	O
(	O
dap_newpart	function
(	O
partv	array
,	O
npart	int
)	O
)	O
{	O
if	O
(	O
nv	int
<	O
nnew	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(join) Too few lines in part:"	pointer
)	O
;	O
for	O
(	O
np	int
=	O
0	int
;	O
np	int
<	O
npart	int
;	O
np	int
++	O
)	O
{	O
putc	function
(	O
' '	O
,	O
dap_err	pointer
)	O
;	O
fputs	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
partv	array
[	O
np	int
]	O
]	O
,	O
dap_err	pointer
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
dap_swap	function
(	O
)	O
;	O
output	function
(	O
)	O
;	O
dap_swap	function
(	O
)	O
;	O
nv	int
=	O
0	int
;	O
}	O
if	O
(	O
more	int
)	O
{	O
if	O
(	O
nv	int
>=	O
nnew	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(join) Too many lines at %s\n"	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
cv	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_nam	pointer
[	O
newv	pointer
[	O
nv	int
]	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
cv	int
]	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(join) Missing or extra lines at %s\n"	pointer
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
cv	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
vallen	int
==	O
DBL	O
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
newv	pointer
[	O
nv	int
]	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_dbl	pointer
[	O
valv	int
]	O
;	O
else	O
if	O
(	O
vallen	int
==	O
INT	int
)	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
newv	pointer
[	O
nv	int
]	O
]	O
=	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_int	pointer
[	O
valv	int
]	O
;	O
else	O
strcpy	function
(	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
newv	pointer
[	O
nv	int
]	O
]	O
,	O
dap_obs	array
[	O
dap_ono	int
]	O
.	O
do_str	pointer
[	O
valv	int
]	O
)	O
;	O
}	O
}	O
dap_free	function
(	O
outname	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
newv	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
partvars1	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
classvar	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
skiplist	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
varspec	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
partv	array
,	O
""	pointer
)	O
;	O
}	O
static	O
int	O
*	O
fieldstart	pointer
;	O
static	O
int	O
*	O
fieldlen	pointer
;	O
static	O
int	O
*	O
unfield	pointer
;	O
static	O
int	O
linelen	int
;	O
static	O
int	O
keylen	int
;	O
static	O
int	O
*	O
keyend	pointer
;	O
static	O
int	O
*	O
sortord	pointer
;	O
static	O
int	O
*	O
keymap	pointer
;	O
static	O
int	O
nvars	int
;	O
static	O
char	O
*	O
mem1	pointer
;	O
static	O
char	O
*	O
mem2	pointer
;	O
static	O
int	O
maxlines	int
;	O
static	O
char	O
*	O
*	O
line	array
;	O
static	O
int	O
*	O
field	pointer
;	O
static	O
int	O
nfields	int
;	O
static	O
int	O
unique	int
;	O
static	O
char	O
tmplate	array
[	O
]	O
=	O
TMPLATE	pointer
;	O
static	O
unsigned	O
long	O
int	O
fpos	long
;	O
static	O
int	O
strtoi	function
(	O
char	O
*	O
s	int
,	O
int	O
*	O
pi	pointer
,	O
int	O
*	O
ps	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
'0'	O
<=	O
*	O
s	int
&&	O
*	O
s	int
<=	O
'9'	O
;	O
s	int
++	O
)	O
i	int
=	O
10	int
*	O
i	int
+	O
*	O
s	int
-	O
'0'	O
;	O
*	O
pi	pointer
=	O
i	int
;	O
if	O
(	O
*	O
s	int
==	O
'd'	O
)	O
{	O
*	O
ps	pointer
=	O
0	int
;	O
s	int
++	O
;	O
}	O
else	O
*	O
ps	pointer
=	O
1	int
;	O
return	O
!	O
*	O
s	int
;	O
}	O
static	O
void	O
cleanup	function
(	O
int	O
nseg	int
)	O
{	O
int	O
s	int
;	O
char	O
segname	array
[	O
]	O
=	O
TMPLATE	pointer
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
nseg	int
;	O
s	int
++	O
)	O
{	O
strcpy	function
(	O
segname	array
,	O
tmplate	array
)	O
;	O
sprintf	function
(	O
segname	array
+	O
18	int
,	O
"%06d"	pointer
,	O
s	int
)	O
;	O
unlink	function
(	O
segname	array
)	O
;	O
}	O
}	O
static	O
int	O
linecmp	function
(	O
char	O
*	O
*	O
s1	pointer
,	O
char	O
*	O
*	O
s2	pointer
)	O
{	O
char	O
*	O
t1	double
,	O
*	O
t2	pointer
;	O
char	O
*	O
e1	pointer
;	O
for	O
(	O
e1	pointer
=	O
*	O
s1	pointer
+	O
keylen	int
-	O
1	int
,	O
t1	double
=	O
*	O
s1	pointer
,	O
t2	pointer
=	O
*	O
s2	pointer
;	O
t1	double
<	O
e1	pointer
&&	O
*	O
t1	double
==	O
*	O
t2	pointer
;	O
t1	double
++	O
,	O
t2	pointer
++	O
)	O
;	O
return	O
(	O
keymap	pointer
[	O
t1	double
-	O
*	O
s1	pointer
]	O
?	O
*	O
t1	double
-	O
*	O
t2	pointer
:	O
*	O
t2	pointer
-	O
*	O
t1	double
)	O
;	O
}	O
static	O
int	O
sortseg	function
(	O
int	O
orig	int
,	O
int	O
s	int
)	O
{	O
char	O
segname	array
[	O
]	O
=	O
TMPLATE	pointer
;	O
ssize_t	long
nread	long
;	O
int	O
seg	int
;	O
char	O
*	O
m1	pointer
,	O
*	O
m2	pointer
;	O
int	O
nlines	int
;	O
char	O
*	O
lstart1	pointer
,	O
*	O
lstart2	pointer
;	O
int	O
f	pointer
;	O
int	O
last	int
;	O
int	O
l	int
;	O
char	O
*	O
lp	pointer
;	O
char	O
*	O
mp	pointer
;	O
int	O
newfield	int
;	O
int	O
(	O
*	O
cmp	int
)	O
(	O
)	O
;	O
cmp	int
=	O
&	O
linecmp	function
;	O
nread	long
=	O
read	function
(	O
orig	int
,	O
mem1	pointer
,	O
dap_maxmem	int
)	O
;	O
if	O
(	O
!	O
nread	long
)	O
return	O
0	int
;	O
strcpy	function
(	O
segname	array
,	O
tmplate	array
)	O
;	O
sprintf	function
(	O
segname	array
+	O
18	int
,	O
"%06d"	pointer
,	O
s	int
)	O
;	O
if	O
(	O
(	O
seg	int
=	O
open	function
(	O
segname	array
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dsort) can't write %s\n"	pointer
,	O
segname	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
lstart1	pointer
=	O
mem1	pointer
,	O
lstart2	pointer
=	O
mem2	pointer
,	O
nlines	int
=	O
0	int
;	O
lstart1	pointer
<	O
mem1	pointer
+	O
nread	long
&&	O
lstart2	pointer
+	O
linelen	int
<	O
mem2	pointer
+	O
dap_maxmem	int
;	O
lstart1	pointer
=	O
m1	pointer
,	O
lstart2	pointer
+=	O
linelen	int
)	O
{	O
if	O
(	O
nlines	int
<	O
maxlines	int
)	O
line	array
[	O
nlines	int
++	O
]	O
=	O
lstart2	pointer
;	O
else	O
break	O
;	O
for	O
(	O
f	pointer
=	O
0	int
,	O
m1	pointer
=	O
lstart1	pointer
,	O
last	int
=	O
'\0'	O
;	O
f	pointer
<	O
nvars	int
;	O
f	pointer
++	O
)	O
{	O
for	O
(	O
m2	pointer
=	O
lstart2	pointer
+	O
fieldstart	pointer
[	O
unfield	pointer
[	O
f	pointer
]	O
]	O
;	O
m1	pointer
<	O
mem1	pointer
+	O
nread	long
&&	O
*	O
m1	pointer
!=	O
'|'	O
&&	O
*	O
m1	pointer
!=	O
'\n'	O
;	O
)	O
*	O
m2	pointer
++	O
=	O
*	O
m1	pointer
++	O
;	O
last	int
=	O
*	O
m1	pointer
++	O
;	O
while	O
(	O
m2	pointer
<	O
lstart2	pointer
+	O
fieldstart	pointer
[	O
unfield	pointer
[	O
f	pointer
]	O
+	O
1	int
]	O
)	O
*	O
m2	pointer
++	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
last	int
!=	O
'\n'	O
)	O
break	O
;	O
}	O
if	O
(	O
last	int
!=	O
'\n'	O
)	O
--	O
nlines	int
;	O
nread	long
=	O
lstart1	pointer
-	O
mem1	pointer
;	O
if	O
(	O
!	O
nread	long
)	O
{	O
fputs	function
(	O
"(dsort) line longer than buffer\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
fpos	long
+=	O
nread	long
;	O
qsort	function
(	O
line	array
,	O
nlines	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
cmp	int
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
nlines	int
;	O
l	int
++	O
)	O
memcpy	function
(	O
mem1	pointer
+	O
l	int
*	O
linelen	int
,	O
line	array
[	O
l	int
]	O
,	O
linelen	int
)	O
;	O
write	function
(	O
seg	int
,	O
mem1	pointer
,	O
nlines	int
*	O
linelen	int
)	O
;	O
close	function
(	O
seg	int
)	O
;	O
return	O
nread	long
;	O
}	O
static	O
char	O
*	O
*	O
nextline	pointer
;	O
static	O
int	O
nextlinecmp	function
(	O
int	O
*	O
s1	pointer
,	O
int	O
*	O
s2	pointer
)	O
{	O
return	O
linecmp	function
(	O
nextline	pointer
+	O
*	O
s1	pointer
,	O
nextline	pointer
+	O
*	O
s2	pointer
)	O
;	O
}	O
static	O
void	O
merge	function
(	O
int	O
nseg	int
,	O
int	O
out	int
)	O
{	O
int	O
s	int
,	O
s1	pointer
,	O
s2	pointer
;	O
int	O
c	int
;	O
int	O
l	int
;	O
int	O
f	pointer
;	O
char	O
*	O
segnamemem	pointer
;	O
char	O
*	O
*	O
segname	array
;	O
int	O
segfile	int
;	O
int	O
chunksize	int
;	O
int	O
*	O
chunkread	pointer
;	O
char	O
*	O
prevline	pointer
;	O
unsigned	O
long	O
int	O
*	O
spos	pointer
;	O
int	O
nmore	int
;	O
unsigned	O
int	O
outpos	int
;	O
int	O
*	O
segord	pointer
;	O
int	O
(	O
*	O
scmp	pointer
)	O
(	O
)	O
;	O
scmp	pointer
=	O
&	O
nextlinecmp	function
;	O
nextline	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
nseg	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
"nextline"	pointer
)	O
;	O
prevline	pointer
=	O
NULL	O
;	O
segnamemem	pointer
=	O
(	O
char	O
*	O
)	O
dap_malloc	function
(	O
nseg	int
*	O
(	O
strlen	function
(	O
TMPLATE	pointer
)	O
+	O
1	int
)	O
,	O
"segnamemem"	pointer
)	O
;	O
segname	array
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
nseg	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
"segname"	pointer
)	O
;	O
spos	pointer
=	O
(	O
unsigned	O
long	O
int	O
*	O
)	O
dap_malloc	function
(	O
nseg	int
*	O
sizeof	O
(	O
unsigned	O
long	O
int	O
)	O
,	O
"spos"	pointer
)	O
;	O
segord	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
nseg	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"segord"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
chunksize	int
=	O
dap_maxmem	int
/	O
(	O
nseg	int
*	O
linelen	int
)	O
*	O
linelen	int
)	O
)	O
{	O
fputs	function
(	O
"(dsort) insufficient memory\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
chunkread	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
nseg	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"chunkread"	pointer
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
nseg	int
;	O
s	int
++	O
)	O
{	O
segname	array
[	O
s	int
]	O
=	O
segnamemem	pointer
+	O
s	int
*	O
(	O
strlen	function
(	O
TMPLATE	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
segname	array
[	O
s	int
]	O
,	O
tmplate	array
)	O
;	O
sprintf	function
(	O
segname	array
[	O
s	int
]	O
+	O
18	int
,	O
"%06d"	pointer
,	O
s	int
)	O
;	O
nextline	pointer
[	O
s	int
]	O
=	O
mem1	pointer
+	O
s	int
*	O
chunksize	int
;	O
spos	pointer
[	O
s	int
]	O
=	O
0	int
;	O
chunkread	pointer
[	O
s	int
]	O
=	O
0	int
;	O
segord	pointer
[	O
s	int
]	O
=	O
s	int
;	O
}	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
nseg	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
(	O
segfile	int
=	O
open	function
(	O
segname	array
[	O
s	int
]	O
,	O
O_RDONLY	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dsort) can't read %s\n"	pointer
,	O
segname	array
[	O
s	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
chunkread	pointer
[	O
s	int
]	O
=	O
read	function
(	O
segfile	int
,	O
mem1	pointer
+	O
s	int
*	O
chunksize	int
,	O
chunksize	int
)	O
)	O
>	O
0	int
)	O
spos	pointer
[	O
s	int
]	O
+=	O
chunkread	pointer
[	O
s	int
]	O
;	O
else	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dsort) bad initial read of %s\n"	pointer
,	O
segname	array
[	O
s	int
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
close	function
(	O
segfile	int
)	O
;	O
}	O
qsort	function
(	O
segord	pointer
,	O
nseg	int
,	O
sizeof	O
(	O
int	O
)	O
,	O
scmp	pointer
)	O
;	O
for	O
(	O
nmore	int
=	O
nseg	int
,	O
outpos	int
=	O
0	int
;	O
nmore	int
;	O
)	O
{	O
if	O
(	O
unique	int
)	O
{	O
if	O
(	O
!	O
prevline	pointer
)	O
prevline	pointer
=	O
(	O
char	O
*	O
)	O
dap_malloc	function
(	O
linelen	int
,	O
"prevline"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
unique	int
||	O
(	O
prevline	pointer
&&	O
linecmp	function
(	O
nextline	pointer
+	O
segord	pointer
[	O
0	int
]	O
,	O
&	O
prevline	pointer
)	O
)	O
)	O
{	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
nvars	int
;	O
f	pointer
++	O
)	O
{	O
for	O
(	O
l	int
=	O
fieldstart	pointer
[	O
unfield	pointer
[	O
f	pointer
]	O
]	O
;	O
l	int
<	O
fieldstart	pointer
[	O
unfield	pointer
[	O
f	pointer
]	O
+	O
1	int
]	O
;	O
l	int
++	O
)	O
{	O
if	O
(	O
outpos	int
==	O
dap_maxmem	int
)	O
{	O
write	function
(	O
out	int
,	O
mem2	pointer
,	O
outpos	int
)	O
;	O
outpos	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
(	O
mem2	pointer
[	O
outpos	int
]	O
=	O
nextline	pointer
[	O
segord	pointer
[	O
0	int
]	O
]	O
[	O
l	int
]	O
)	O
)	O
break	O
;	O
outpos	int
++	O
;	O
}	O
if	O
(	O
outpos	int
==	O
dap_maxmem	int
)	O
{	O
write	function
(	O
out	int
,	O
mem2	pointer
,	O
outpos	int
)	O
;	O
outpos	int
=	O
0	int
;	O
}	O
if	O
(	O
f	pointer
<	O
nvars	int
-	O
1	int
)	O
mem2	pointer
[	O
outpos	int
++	O
]	O
=	O
'|'	O
;	O
else	O
mem2	pointer
[	O
outpos	int
++	O
]	O
=	O
'\n'	O
;	O
}	O
}	O
if	O
(	O
unique	int
)	O
{	O
if	O
(	O
!	O
prevline	pointer
)	O
prevline	pointer
=	O
(	O
char	O
*	O
)	O
dap_malloc	function
(	O
linelen	int
,	O
"prevline"	pointer
)	O
;	O
memcpy	function
(	O
prevline	pointer
,	O
nextline	pointer
[	O
segord	pointer
[	O
0	int
]	O
]	O
,	O
linelen	int
)	O
;	O
}	O
if	O
(	O
(	O
nextline	pointer
[	O
segord	pointer
[	O
0	int
]	O
]	O
+=	O
linelen	int
)	O
>=	O
mem1	pointer
+	O
segord	pointer
[	O
0	int
]	O
*	O
chunksize	int
+	O
chunkread	pointer
[	O
segord	pointer
[	O
0	int
]	O
]	O
)	O
{	O
if	O
(	O
(	O
segfile	int
=	O
open	function
(	O
segname	array
[	O
segord	pointer
[	O
0	int
]	O
]	O
,	O
O_RDONLY	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dsort) can't read %s\n"	pointer
,	O
segname	array
[	O
segord	pointer
[	O
0	int
]	O
]	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
lseek	function
(	O
segfile	int
,	O
spos	pointer
[	O
segord	pointer
[	O
0	int
]	O
]	O
,	O
SEEK_CUR	int
)	O
>	O
0	int
)	O
{	O
if	O
(	O
(	O
chunkread	pointer
[	O
segord	pointer
[	O
0	int
]	O
]	O
=	O
read	function
(	O
segfile	int
,	O
mem1	pointer
+	O
segord	pointer
[	O
0	int
]	O
*	O
chunksize	int
,	O
chunksize	int
)	O
)	O
>	O
0	int
)	O
{	O
spos	pointer
[	O
segord	pointer
[	O
0	int
]	O
]	O
+=	O
chunkread	pointer
[	O
segord	pointer
[	O
0	int
]	O
]	O
;	O
nextline	pointer
[	O
segord	pointer
[	O
0	int
]	O
]	O
=	O
mem1	pointer
+	O
segord	pointer
[	O
0	int
]	O
*	O
chunksize	int
;	O
}	O
else	O
--	O
nmore	int
;	O
}	O
else	O
{	O
chunkread	pointer
[	O
segord	pointer
[	O
0	int
]	O
]	O
=	O
0	int
;	O
--	O
nmore	int
;	O
}	O
close	function
(	O
segfile	int
)	O
;	O
}	O
if	O
(	O
chunkread	pointer
[	O
segord	pointer
[	O
0	int
]	O
]	O
<=	O
0	int
)	O
{	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
nmore	int
;	O
s	int
++	O
)	O
segord	pointer
[	O
s	int
]	O
=	O
segord	pointer
[	O
s	int
+	O
1	int
]	O
;	O
}	O
else	O
{	O
for	O
(	O
s1	pointer
=	O
1	int
;	O
s1	pointer
<	O
nmore	int
;	O
s1	pointer
++	O
)	O
{	O
if	O
(	O
linecmp	function
(	O
nextline	pointer
+	O
segord	pointer
[	O
0	int
]	O
,	O
nextline	pointer
+	O
segord	pointer
[	O
s1	pointer
]	O
)	O
<=	O
0	int
)	O
break	O
;	O
}	O
s2	pointer
=	O
segord	pointer
[	O
0	int
]	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
s1	pointer
-	O
1	int
;	O
s	int
++	O
)	O
segord	pointer
[	O
s	int
]	O
=	O
segord	pointer
[	O
s	int
+	O
1	int
]	O
;	O
segord	pointer
[	O
s	int
]	O
=	O
s2	pointer
;	O
}	O
}	O
if	O
(	O
outpos	int
)	O
write	function
(	O
out	int
,	O
mem2	pointer
,	O
outpos	int
)	O
;	O
dap_free	function
(	O
nextline	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
prevline	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
segnamemem	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
segname	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
spos	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
chunkread	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
segord	pointer
,	O
""	pointer
)	O
;	O
}	O
static	O
int	O
fieldfix	function
(	O
int	O
code	array
)	O
{	O
switch	O
(	O
code	array
)	O
{	O
case	O
DBL	O
:	O
return	O
12	int
;	O
case	O
INT	int
:	O
return	O
6	int
;	O
default	O
:	O
return	O
code	array
;	O
}	O
}	O
static	O
int	O
fixheader	function
(	O
char	O
*	O
header	pointer
,	O
int	O
srt	int
)	O
{	O
int	O
headerlen	int
;	O
int	O
nspaces	int
;	O
int	O
v	int
;	O
int	O
gotsign	int
;	O
int	O
sign	int
;	O
int	O
h	int
;	O
char	O
*	O
h1	pointer
;	O
int	O
newfield	int
;	O
int	O
fieldlen1	int
;	O
int	O
f	pointer
,	O
f1	array
,	O
f2	double
;	O
int	O
k	int
,	O
k1	int
;	O
char	O
*	O
*	O
headerfield	pointer
;	O
headerfield	pointer
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
dap_maxvar	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
"headerfield"	pointer
)	O
;	O
fieldstart	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
(	O
dap_maxvar	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
int	O
)	O
,	O
"fieldstart"	pointer
)	O
;	O
fieldstart	pointer
[	O
0	int
]	O
=	O
0	int
;	O
fieldlen	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
(	O
dap_maxvar	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
int	O
)	O
,	O
"fieldlen"	pointer
)	O
;	O
for	O
(	O
headerlen	int
=	O
0	int
,	O
nspaces	int
=	O
0	int
,	O
nvars	int
=	O
0	int
,	O
newfield	int
=	O
1	int
,	O
linelen	int
=	O
0	int
;	O
headerlen	int
<	O
dap_linelen	int
&&	O
header	pointer
[	O
headerlen	int
]	O
!=	O
'\n'	O
;	O
headerlen	int
++	O
)	O
{	O
if	O
(	O
newfield	int
)	O
{	O
if	O
(	O
nvars	int
)	O
linelen	int
+=	O
(	O
fieldlen	pointer
[	O
nvars	int
-	O
1	int
]	O
=	O
fieldfix	function
(	O
sign	int
*	O
fieldlen1	int
)	O
)	O
;	O
headerfield	pointer
[	O
nvars	int
++	O
]	O
=	O
header	pointer
+	O
headerlen	int
;	O
newfield	int
=	O
0	int
;	O
}	O
if	O
(	O
header	pointer
[	O
headerlen	int
]	O
==	O
' '	O
)	O
{	O
if	O
(	O
++	O
nspaces	int
==	O
1	int
)	O
{	O
fieldlen1	int
=	O
0	int
;	O
gotsign	int
=	O
0	int
;	O
}	O
else	O
{	O
nspaces	int
=	O
0	int
;	O
newfield	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
nspaces	int
==	O
1	int
&&	O
header	pointer
[	O
headerlen	int
]	O
!=	O
' '	O
)	O
{	O
if	O
(	O
!	O
gotsign	int
)	O
{	O
if	O
(	O
header	pointer
[	O
headerlen	int
]	O
==	O
'-'	O
)	O
sign	int
=	O
-	O
1	int
;	O
else	O
{	O
sign	int
=	O
1	int
;	O
gotsign	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
gotsign	int
)	O
fieldlen1	int
=	O
10	int
*	O
fieldlen1	int
+	O
header	pointer
[	O
headerlen	int
]	O
-	O
'0'	O
;	O
gotsign	int
=	O
1	int
;	O
}	O
}	O
linelen	int
+=	O
(	O
fieldlen	pointer
[	O
nvars	int
-	O
1	int
]	O
=	O
fieldfix	function
(	O
sign	int
*	O
fieldlen1	int
)	O
)	O
;	O
maxlines	int
=	O
dap_maxmem	int
/	O
linelen	int
;	O
line	array
=	O
(	O
char	O
*	O
*	O
)	O
dap_malloc	function
(	O
maxlines	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
"line"	pointer
)	O
;	O
if	O
(	O
headerlen	int
==	O
dap_linelen	int
)	O
{	O
header	pointer
[	O
dap_linelen	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dsort) header line too long %s\n"	pointer
,	O
header	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
f	pointer
=	O
0	int
,	O
f2	double
=	O
nfields	int
;	O
f	pointer
<	O
nvars	int
;	O
f	pointer
++	O
)	O
{	O
for	O
(	O
f1	array
=	O
0	int
;	O
f1	array
<	O
nfields	int
;	O
f1	array
++	O
)	O
{	O
if	O
(	O
field	pointer
[	O
f1	array
]	O
==	O
f	pointer
)	O
break	O
;	O
}	O
if	O
(	O
f1	array
==	O
nfields	int
)	O
field	pointer
[	O
f2	double
++	O
]	O
=	O
f	pointer
;	O
}	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
nvars	int
;	O
f	pointer
++	O
)	O
unfield	pointer
[	O
field	pointer
[	O
f	pointer
]	O
]	O
=	O
f	pointer
;	O
for	O
(	O
fieldstart	pointer
[	O
0	int
]	O
=	O
0	int
,	O
f	pointer
=	O
1	int
;	O
f	pointer
<=	O
nvars	int
;	O
f	pointer
++	O
)	O
fieldstart	pointer
[	O
f	pointer
]	O
=	O
fieldstart	pointer
[	O
f	pointer
-	O
1	int
]	O
+	O
fieldlen	pointer
[	O
field	pointer
[	O
f	pointer
-	O
1	int
]	O
]	O
;	O
keyend	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
nfields	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"keyend"	pointer
)	O
;	O
for	O
(	O
f	pointer
=	O
0	int
,	O
keylen	int
=	O
0	int
;	O
f	pointer
<	O
nfields	int
;	O
f	pointer
++	O
)	O
{	O
keylen	int
+=	O
fieldlen	pointer
[	O
field	pointer
[	O
f	pointer
]	O
]	O
;	O
keyend	pointer
[	O
f	pointer
]	O
=	O
keylen	int
;	O
}	O
keymap	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
keylen	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"keymap"	pointer
)	O
;	O
for	O
(	O
f	pointer
=	O
0	int
,	O
k	int
=	O
0	int
;	O
f	pointer
<	O
nfields	int
;	O
f	pointer
++	O
)	O
{	O
for	O
(	O
k1	int
=	O
0	int
;	O
k1	int
<	O
fieldlen	pointer
[	O
field	pointer
[	O
f	pointer
]	O
]	O
;	O
k1	int
++	O
)	O
keymap	pointer
[	O
k	int
++	O
]	O
=	O
sortord	pointer
[	O
f	pointer
]	O
;	O
}	O
write	function
(	O
srt	int
,	O
header	pointer
,	O
headerlen	int
+	O
1	int
)	O
;	O
dap_free	function
(	O
headerfield	pointer
,	O
""	pointer
)	O
;	O
return	O
headerlen	int
+	O
1	int
;	O
}	O
static	O
void	O
dsort	function
(	O
char	O
*	O
origset	pointer
,	O
char	O
*	O
sortset	pointer
,	O
int	O
sortvar	array
[	O
]	O
,	O
int	O
nsort	int
,	O
int	O
uniq	int
,	O
char	O
*	O
mod	pointer
,	O
int	O
nmods	int
)	O
{	O
int	O
f	pointer
;	O
int	O
orig	int
;	O
int	O
nseg	int
;	O
int	O
srt	int
;	O
char	O
*	O
header	pointer
;	O
int	O
c	int
;	O
struct	O
stat	struct
statbuf	struct
;	O
header	pointer
=	O
(	O
char	O
*	O
)	O
dap_malloc	function
(	O
dap_linelen	int
,	O
"header"	pointer
)	O
;	O
field	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
dap_maxvar	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"field"	pointer
)	O
;	O
unfield	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
dap_maxvar	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"unfield"	pointer
)	O
;	O
sortord	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
dap_maxvar	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"dsortord"	pointer
)	O
;	O
nfields	int
=	O
nsort	int
;	O
if	O
(	O
!	O
nmods	int
)	O
{	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
nfields	int
;	O
f	pointer
++	O
)	O
mod	pointer
[	O
f	pointer
]	O
=	O
'i'	O
;	O
}	O
else	O
if	O
(	O
nmods	int
!=	O
nfields	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dsort) nmods (%d) != nfields (%d)\n"	pointer
,	O
nmods	int
,	O
nfields	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
unique	int
=	O
uniq	int
;	O
for	O
(	O
f	pointer
=	O
0	int
;	O
f	pointer
<	O
nfields	int
;	O
f	pointer
++	O
)	O
{	O
sortord	pointer
[	O
f	pointer
]	O
=	O
(	O
mod	pointer
[	O
f	pointer
]	O
==	O
'i'	O
?	O
1	int
:	O
0	int
)	O
;	O
field	pointer
[	O
f	pointer
]	O
=	O
sortvar	array
[	O
f	pointer
]	O
;	O
}	O
if	O
(	O
stat	struct
(	O
dap_tmpdir	pointer
,	O
&	O
statbuf	struct
)	O
<	O
0	int
)	O
{	O
if	O
(	O
mkdir	function
(	O
dap_tmpdir	pointer
,	O
(	O
mode_t	int
)	O
0700	int
)	O
<	O
0	int
)	O
{	O
perror	function
(	O
dap_dapname	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
(	O
statbuf	struct
.	O
st_mode	int
&	O
S_IFDIR	O
)	O
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"%s: non-directory file exists: %s\n"	pointer
,	O
dap_dapname	pointer
,	O
dap_tmpdir	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
mem1	pointer
=	O
(	O
char	O
*	O
)	O
dap_malloc	function
(	O
2	int
*	O
dap_maxmem	int
,	O
"mem1"	pointer
)	O
;	O
mem2	pointer
=	O
mem1	pointer
+	O
dap_maxmem	int
;	O
if	O
(	O
!	O
nfields	int
)	O
{	O
fputs	function
(	O
"(dsort) no fields specified for sorting\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
orig	int
=	O
open	function
(	O
origset	pointer
,	O
O_RDONLY	int
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dsort) can't read %s\n"	pointer
,	O
origset	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
srt	int
=	O
open	function
(	O
sortset	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
)	O
<	O
0	int
)	O
{	O
fprintf	function
(	O
dap_err	pointer
,	O
"(dsort) can't write %s\n"	pointer
,	O
sortset	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
read	function
(	O
orig	int
,	O
header	pointer
,	O
dap_linelen	int
)	O
<	O
0	int
)	O
{	O
fputs	function
(	O
"(dsort) can't read header\n"	pointer
,	O
dap_err	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
fpos	long
=	O
fixheader	function
(	O
header	pointer
,	O
srt	int
)	O
;	O
lseek	function
(	O
orig	int
,	O
fpos	long
,	O
SEEK_SET	int
)	O
;	O
sprintf	function
(	O
tmplate	array
+	O
12	int
,	O
"%06d"	pointer
,	O
getpid	function
(	O
)	O
%	O
1000000	int
)	O
;	O
for	O
(	O
nseg	int
=	O
0	int
;	O
sortseg	function
(	O
orig	int
,	O
nseg	int
)	O
;	O
nseg	int
++	O
)	O
lseek	function
(	O
orig	int
,	O
fpos	long
,	O
SEEK_SET	int
)	O
;	O
merge	function
(	O
nseg	int
,	O
srt	int
)	O
;	O
cleanup	function
(	O
nseg	int
)	O
;	O
dap_free	function
(	O
header	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
mem1	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
fieldstart	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
line	array
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
field	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
unfield	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
fieldlen	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
sortord	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
keyend	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
keymap	pointer
,	O
""	pointer
)	O
;	O
}	O
int	O
*	O
bubblesort	function
(	O
int	O
*	O
list	pointer
,	O
int	O
n	int
,	O
int	O
order	int
)	O
{	O
int	O
*	O
returndata	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
n	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"return"	pointer
)	O
;	O
int	O
i	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
returndata	pointer
[	O
i	int
]	O
=	O
list	pointer
[	O
i	int
]	O
;	O
}	O
int	O
swappedcount	int
=	O
0	int
;	O
int	O
swapped	int
=	O
0	int
;	O
do	O
{	O
swapped	int
=	O
0	int
;	O
i	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
order	int
>	O
0	int
)	O
{	O
if	O
(	O
returndata	pointer
[	O
i	int
-	O
1	int
]	O
>	O
returndata	pointer
[	O
i	int
]	O
)	O
{	O
int	O
act	int
=	O
returndata	pointer
[	O
i	int
]	O
;	O
returndata	pointer
[	O
i	int
]	O
=	O
returndata	pointer
[	O
i	int
-	O
1	int
]	O
;	O
returndata	pointer
[	O
i	int
-	O
1	int
]	O
=	O
act	int
;	O
swapped	int
=	O
1	int
;	O
swappedcount	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
returndata	pointer
[	O
i	int
-	O
1	int
]	O
<	O
returndata	pointer
[	O
i	int
]	O
)	O
{	O
int	O
act	int
=	O
returndata	pointer
[	O
i	int
]	O
;	O
returndata	pointer
[	O
i	int
]	O
=	O
returndata	pointer
[	O
i	int
-	O
1	int
]	O
;	O
returndata	pointer
[	O
i	int
-	O
1	int
]	O
=	O
act	int
;	O
swapped	int
=	O
1	int
;	O
swappedcount	int
++	O
;	O
}	O
}	O
}	O
}	O
while	O
(	O
swapped	int
)	O
;	O
printf	function
(	O
"nb swapped =%d\n"	pointer
,	O
swappedcount	int
)	O
;	O
return	O
returndata	pointer
;	O
}	O
void	O
surveyselect	function
(	O
char	O
*	O
fname	array
,	O
char	O
*	O
outname	pointer
,	O
char	O
*	O
method	pointer
,	O
int	O
tirage	int
)	O
{	O
inset	function
(	O
fname	array
)	O
;	O
int	O
nbLines	int
=	O
0	int
;	O
while	O
(	O
step	function
(	O
)	O
)	O
{	O
nbLines	int
++	O
;	O
}	O
printf	function
(	O
"nblines to read = %d, nb selected = %d\n"	pointer
,	O
nbLines	int
,	O
tirage	int
)	O
;	O
int	O
*	O
list	pointer
=	O
(	O
int	O
*	O
)	O
dap_malloc	function
(	O
tirage	int
*	O
sizeof	O
(	O
int	O
)	O
,	O
"list"	pointer
)	O
;	O
int	O
i	int
=	O
0	int
;	O
int	O
sysrand	int
=	O
rand	function
(	O
)	O
%	O
(	O
nbLines	int
/	O
tirage	int
)	O
;	O
printf	function
(	O
"reload data\n"	pointer
)	O
;	O
printf	function
(	O
"create index list based on method\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tirage	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
method	pointer
,	O
"SRS"	pointer
)	O
==	O
0	int
)	O
{	O
int	O
notalone	int
=	O
0	int
;	O
int	O
choice	int
=	O
0	int
;	O
do	O
{	O
choice	int
=	O
rand	function
(	O
)	O
%	O
nbLines	int
;	O
int	O
j	int
=	O
0	int
;	O
notalone	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
i	int
;	O
j	int
++	O
)	O
if	O
(	O
list	pointer
[	O
j	int
]	O
==	O
choice	int
)	O
notalone	int
=	O
1	int
;	O
}	O
while	O
(	O
notalone	int
==	O
1	int
)	O
;	O
list	pointer
[	O
i	int
]	O
=	O
choice	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
method	pointer
,	O
"SYS"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
list	pointer
[	O
i	int
]	O
=	O
sysrand	int
;	O
}	O
else	O
{	O
list	pointer
[	O
i	int
]	O
=	O
list	pointer
[	O
i	int
-	O
1	int
]	O
+	O
nbLines	int
/	O
tirage	int
;	O
}	O
}	O
}	O
printf	function
(	O
"sort values\n"	pointer
)	O
;	O
int	O
*	O
listsorted	pointer
=	O
bubblesort	function
(	O
list	pointer
,	O
tirage	int
,	O
1	int
)	O
;	O
int	O
counter	int
=	O
0	int
;	O
int	O
index	function
=	O
0	int
;	O
printf	function
(	O
"set output\n"	pointer
)	O
;	O
inset	function
(	O
fname	array
)	O
;	O
outset	function
(	O
outname	pointer
,	O
""	pointer
)	O
;	O
while	O
(	O
step	function
(	O
)	O
)	O
{	O
int	O
founded	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tirage	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
listsorted	pointer
[	O
i	int
]	O
==	O
counter	int
)	O
founded	int
=	O
1	int
;	O
}	O
if	O
(	O
founded	int
)	O
{	O
output	function
(	O
)	O
;	O
index	function
++	O
;	O
}	O
counter	int
++	O
;	O
}	O
dap_free	function
(	O
list	pointer
,	O
""	pointer
)	O
;	O
dap_free	function
(	O
listsorted	pointer
,	O
""	pointer
)	O
;	O
}	O
