static	O
const	O
char	O
copyright	array
[	O
]	O
=	O
"@(#) Copyright (c) 1980, 1993\n"	pointer
"The Regents of the University of California.  All rights reserved.\n"	pointer
"@(#) Copyright (c) 1998\n"	pointer
"Free Software Foundation, Inc.  All rights reserved.\n"	pointer
;	O
static	O
const	O
char	O
filever	array
[	O
]	O
=	O
"$Id: sccs.c,v 1.44 2007/12/19 00:21:14 jay Exp $"	pointer
;	O
typedef	O
char	O
bool	char
;	O
struct	O
sccsprog	struct
{	O
const	O
char	O
*	O
sccsname	pointer
;	O
short	O
sccsoper	short
;	O
short	O
sccsflags	short
;	O
const	O
char	O
*	O
sccspath	pointer
;	O
int	O
clean_mode	int
;	O
}	O
;	O
const	O
struct	O
sccsprog	struct
SccsProg	array
[	O
]	O
=	O
{	O
{	O
"admin"	pointer
,	O
PROG	int
,	O
REALUSER	int
,	O
_PATH_SCCSADMIN	O
,	O
0	int
}	O
,	O
{	O
"cdc"	pointer
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSCDC	O
,	O
0	int
}	O
,	O
{	O
"comb"	pointer
,	O
PROG	int
,	O
WARN_MISSING	int
,	O
_PATH_SCCSCOMB	O
,	O
0	int
}	O
,	O
{	O
"delta"	pointer
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSDELTA	O
,	O
0	int
}	O
,	O
{	O
"get"	pointer
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSGET	O
,	O
0	int
}	O
,	O
{	O
"unget"	pointer
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSUNGET	O
,	O
0	int
}	O
,	O
{	O
"help"	pointer
,	O
PROG	int
,	O
NO_HELP_HERE	int
|	O
NO_SDOT	int
,	O
_PATH_SCCSHELP	O
,	O
0	int
}	O
,	O
{	O
"prs"	pointer
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSPRS	O
,	O
0	int
}	O
,	O
{	O
"prt"	pointer
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSPRT	O
,	O
0	int
}	O
,	O
{	O
"rmdel"	pointer
,	O
PROG	int
,	O
REALUSER	int
,	O
_PATH_SCCSRMDEL	O
,	O
0	int
}	O
,	O
{	O
"val"	pointer
,	O
PROG	int
,	O
0	int
,	O
_PATH_SCCSVAL	O
,	O
0	int
}	O
,	O
{	O
"what"	pointer
,	O
PROG	int
,	O
NO_SDOT	int
,	O
_PATH_SCCSWHAT	O
,	O
0	int
}	O
,	O
{	O
"sccsdiff"	pointer
,	O
PROG	int
,	O
REALUSER	int
,	O
_PATH_SCCSDIFF	O
,	O
0	int
}	O
,	O
{	O
"edit"	pointer
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"get -e"	pointer
,	O
0	int
}	O
,	O
{	O
"delget"	pointer
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"delta:mysrp/get:ixbeskcl -t"	pointer
,	O
0	int
}	O
,	O
{	O
"deledit"	pointer
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"delta:mysrp -n/get:ixbskcl -e -t -g"	pointer
,	O
0	int
}	O
,	O
{	O
"fix"	pointer
,	O
FIX	int
,	O
NO_SDOT	int
,	O
NULL	O
,	O
0	int
}	O
,	O
{	O
"clean"	pointer
,	O
CLEAN	int
,	O
REALUSER	int
|	O
NO_SDOT	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
CLEANC	int
}	O
,	O
{	O
"info"	pointer
,	O
CLEAN	int
,	O
REALUSER	int
|	O
NO_SDOT	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
INFOC	int
}	O
,	O
{	O
"check"	pointer
,	O
CLEAN	int
,	O
REALUSER	int
|	O
NO_SDOT	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
CHECKC	int
}	O
,	O
{	O
"tell"	pointer
,	O
CLEAN	int
,	O
REALUSER	int
|	O
NO_SDOT	int
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
TELLC	int
}	O
,	O
{	O
"unedit"	pointer
,	O
UNEDIT	int
,	O
NO_SDOT	int
,	O
NULL	O
,	O
0	int
}	O
,	O
{	O
"diffs"	pointer
,	O
DIFFS	int
,	O
NO_SDOT	int
|	O
REALUSER	int
,	O
NULL	O
,	O
0	int
}	O
,	O
{	O
"-diff"	pointer
,	O
DODIFF	int
,	O
NO_SDOT	int
|	O
REALUSER	int
,	O
_PATH_SCCSBDIFF	O
,	O
0	int
}	O
,	O
{	O
"print"	pointer
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"prs -e/get -p -m -s"	pointer
,	O
0	int
}	O
,	O
{	O
"branch"	pointer
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"get:ixrc -e -b/delta: -s -n -ybranch-place-holder/get:pl -e -t -g"	pointer
,	O
0	int
}	O
,	O
{	O
"enter"	pointer
,	O
ENTER	int
,	O
NO_SDOT	int
,	O
NULL	O
,	O
0	int
}	O
,	O
{	O
"create"	pointer
,	O
CMACRO	int
,	O
NO_SDOT	int
,	O
"enter/get:ixeskcl -t"	pointer
,	O
0	int
}	O
,	O
{	O
NULL	O
,	O
-	O
1	int
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
,	O
}	O
;	O
struct	O
pfile	struct
{	O
char	O
*	O
p_osid	pointer
;	O
char	O
*	O
p_nsid	pointer
;	O
char	O
*	O
p_user	pointer
;	O
char	O
*	O
p_date	pointer
;	O
char	O
*	O
p_time	pointer
;	O
char	O
*	O
p_aux	pointer
;	O
}	O
;	O
const	O
char	O
*	O
SccsPath	pointer
=	O
SCCSPATH	pointer
;	O
const	O
char	O
*	O
SccsDir	pointer
=	O
""	pointer
;	O
char	O
*	O
subprogram_exec_prefix	pointer
=	O
NULL	O
;	O
int	O
OutFile	int
=	O
-	O
1	int
;	O
bool	char
RealUser	char
;	O
bool	char
Debug	char
=	O
0	int
;	O
static	O
bool	char
TrustEnvironment	char
=	O
0	int
;	O
void	O
syserr	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
;	O
void	O
usrerr	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
;	O
int	O
command	function
(	O
char	O
*	O
argv	array
[	O
]	O
,	O
bool	char
forkflag	char
,	O
const	O
char	O
*	O
arg0	pointer
)	O
;	O
int	O
callprog	function
(	O
const	O
char	O
*	O
progpath	pointer
,	O
short	O
flags	short
,	O
char	O
*	O
const	O
argv	array
[	O
]	O
,	O
bool	char
forkflag	char
)	O
;	O
int	O
clean	function
(	O
int	O
mode	int
,	O
char	O
*	O
const	O
argv	array
[	O
]	O
)	O
;	O
int	O
dodiff	function
(	O
char	O
*	O
getv	array
[	O
]	O
,	O
const	O
char	O
*	O
gfile	pointer
)	O
;	O
int	O
isbranch	function
(	O
const	O
char	O
*	O
sid	pointer
)	O
;	O
void	O
putpfent	function
(	O
register	O
const	O
struct	O
pfile	struct
*	O
pf	pointer
,	O
register	O
FILE	struct
*	O
f	pointer
)	O
;	O
bool	char
safepath	function
(	O
register	O
const	O
char	O
*	O
p	pointer
)	O
;	O
bool	char
isdir	function
(	O
const	O
char	O
*	O
name	pointer
)	O
;	O
const	O
struct	O
sccsprog	struct
*	O
lookup	function
(	O
const	O
char	O
*	O
name	pointer
)	O
;	O
bool	char
unedit	function
(	O
const	O
char	O
*	O
fn	pointer
)	O
;	O
char	O
*	O
makefile	function
(	O
const	O
char	O
*	O
name	pointer
)	O
;	O
const	O
char	O
*	O
tail	function
(	O
register	O
const	O
char	O
*	O
fn	pointer
)	O
;	O
char	O
*	O
tail_nc	function
(	O
register	O
char	O
*	O
fn	pointer
)	O
;	O
const	O
struct	O
pfile	struct
*	O
getpfent	function
(	O
FILE	struct
*	O
pfp	pointer
)	O
;	O
const	O
char	O
*	O
username	function
(	O
void	O
)	O
;	O
char	O
*	O
nextfield	function
(	O
register	O
char	O
*	O
p	pointer
)	O
;	O
char	O
*	O
my_rindex	function
(	O
const	O
char	O
*	O
s	pointer
,	O
int	O
ch	int
)	O
;	O
char	O
*	O
my_index	function
(	O
const	O
char	O
*	O
s	pointer
,	O
int	O
ch	int
)	O
;	O
static	O
char	O
*	O
gstrcat	function
(	O
char	O
*	O
to	pointer
,	O
const	O
char	O
*	O
from	pointer
,	O
size_t	long
length	long
)	O
;	O
static	O
char	O
*	O
gstrncat	function
(	O
char	O
*	O
to	pointer
,	O
const	O
char	O
*	O
from	pointer
,	O
size_t	long
n	long
,	O
size_t	long
length	long
)	O
;	O
static	O
char	O
*	O
gstrcpy	function
(	O
char	O
*	O
to	pointer
,	O
const	O
char	O
*	O
from	pointer
,	O
size_t	long
length	long
)	O
;	O
static	O
void	O
gstrbotch	function
(	O
const	O
char	O
*	O
str1	pointer
,	O
const	O
char	O
*	O
str2	pointer
)	O
;	O
static	O
void	O
gstrbotchn	function
(	O
int	O
avail	int
,	O
const	O
char	O
*	O
,	O
int	O
,	O
const	O
char	O
*	O
,	O
int	O
)	O
;	O
static	O
int	O
absolute_pathname	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
char	O
*	O
str_dup	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
childwait	function
(	O
int	O
pid	int
,	O
int	O
*	O
status_ptr	pointer
,	O
int	O
ignoreintr	int
)	O
;	O
static	O
void	O
show_version	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s from GNU CSSC %s\n%s\n"	pointer
,	O
program_name	pointer
,	O
(	O
VERSION	pointer
)	O
,	O
filever	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"SccsPath = '%s'\nSccsDir = '%s'\n"	pointer
,	O
SccsPath	pointer
,	O
SccsDir	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Default prefix for SCCS subcommands is '%s'\n"	pointer
,	O
(	O
PREFIX	O
)	O
)	O
;	O
}	O
static	O
void	O
oom	function
(	O
void	O
)	O
{	O
perror	function
(	O
"malloc failed"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_TEMPFAIL	int
)	O
;	O
}	O
static	O
void	O
set_prefix	function
(	O
const	O
char	O
*	O
pfx	pointer
)	O
{	O
if	O
(	O
TrustEnvironment	char
)	O
{	O
char	O
*	O
p	pointer
=	O
malloc	function
(	O
1	int
+	O
strlen	function
(	O
pfx	pointer
)	O
)	O
;	O
if	O
(	O
Debug	char
)	O
printf	function
(	O
"set_prefix: setting execution prefix to '%s'\n"	pointer
,	O
pfx	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
free	function
(	O
subprogram_exec_prefix	pointer
)	O
;	O
strcpy	function
(	O
p	pointer
,	O
pfx	pointer
)	O
;	O
subprogram_exec_prefix	pointer
=	O
p	pointer
;	O
}	O
else	O
{	O
oom	function
(	O
)	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s"	pointer
,	O
"Option --prefix is incompatible with setuid "	pointer
"execution.  Sorry.\n"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
}	O
static	O
void	O
setuid_warn	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
str	pointer
=	O
"If you want to install this program set-user-id or set-group-id, you\n"	pointer
"must compile it with the SCCSDIR macro defined, in order to\n"	pointer
"prevent abuse.  Even so, abuse is probably not impossible.  This\n"	pointer
"is not a recommended mode of operation for this program.\n"	pointer
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s"	pointer
,	O
str	pointer
)	O
;	O
}	O
static	O
void	O
drop_privs	function
(	O
void	O
)	O
{	O
if	O
(	O
0	int
!=	O
setgroups	function
(	O
0	int
,	O
NULL	O
)	O
&&	O
errno	O
!=	O
EPERM	int
)	O
{	O
perror	function
(	O
"setgroups"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_NOPERM	int
)	O
;	O
}	O
if	O
(	O
0	int
!=	O
setgid	function
(	O
getgid	function
(	O
)	O
)	O
)	O
{	O
perror	function
(	O
"setgid"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_NOPERM	int
)	O
;	O
}	O
if	O
(	O
0	int
!=	O
setuid	function
(	O
getuid	function
(	O
)	O
)	O
)	O
{	O
perror	function
(	O
"setuid"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_NOPERM	int
)	O
;	O
}	O
RealUser	char
++	O
;	O
}	O
static	O
void	O
check_data_integrity	function
(	O
)	O
{	O
}	O
static	O
void	O
cleanup_environment	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
binary_support	pointer
=	O
"CSSC_BINARY_SUPPORT"	pointer
;	O
const	O
char	O
*	O
max_line_len	pointer
=	O
"CSSC_MAX_LINE_LENGTH"	pointer
;	O
unsetenv	function
(	O
binary_support	pointer
)	O
;	O
unsetenv	function
(	O
max_line_len	pointer
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
void	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Usage: %s [flags] command [flags]\n"	pointer
,	O
program_name	pointer
)	O
;	O
}	O
char	O
*	O
my_rindex	function
(	O
const	O
char	O
*	O
p	pointer
,	O
int	O
ch	int
)	O
{	O
return	O
strrchr	function
(	O
p	pointer
,	O
ch	int
)	O
;	O
}	O
char	O
*	O
my_index	function
(	O
const	O
char	O
*	O
p	pointer
,	O
int	O
ch	int
)	O
{	O
return	O
strchr	function
(	O
p	pointer
,	O
ch	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	array
)	O
{	O
register	O
char	O
*	O
p	pointer
;	O
register	O
int	O
i	int
;	O
int	O
hadver	int
=	O
0	int
;	O
(	O
void	O
)	O
&	O
copyright	array
;	O
set_program_name	function
(	O
argv	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
absolute_pathname	function
(	O
PREFIX	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Compiled-in program name prefix %s is not absolute.\n"	pointer
"Please recompile this program using an absolute path.\n"	pointer
,	O
PREFIX	O
)	O
;	O
exit	function
(	O
CSSC_EX_CONFIG	int
)	O
;	O
}	O
if	O
(	O
(	O
getuid	function
(	O
)	O
!=	O
geteuid	function
(	O
)	O
)	O
||	O
(	O
getgid	function
(	O
)	O
!=	O
getegid	function
(	O
)	O
)	O
)	O
{	O
TrustEnvironment	char
=	O
0	int
;	O
setuid_warn	function
(	O
)	O
;	O
exit	function
(	O
CSSC_EX_NOPERM	int
)	O
;	O
cleanup_environment	function
(	O
)	O
;	O
}	O
else	O
{	O
TrustEnvironment	char
=	O
1	int
;	O
}	O
if	O
(	O
TrustEnvironment	char
)	O
{	O
if	O
(	O
NULL	O
==	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
)	O
{	O
perror	function
(	O
"Error setting locale"	pointer
)	O
;	O
}	O
}	O
check_data_integrity	function
(	O
)	O
;	O
p	pointer
=	O
getenv	function
(	O
"PROJECTDIR"	pointer
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
&&	O
p	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
{	O
register	O
struct	O
passwd	struct
*	O
pw	pointer
;	O
extern	O
struct	O
passwd	struct
*	O
getpwnam	function
(	O
)	O
;	O
char	O
buf	array
[	O
FBUFSIZ	O
]	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
SccsDir	pointer
=	O
p	pointer
;	O
else	O
{	O
pw	pointer
=	O
getpwnam	function
(	O
p	pointer
)	O
;	O
if	O
(	O
pw	pointer
==	O
NULL	O
)	O
{	O
usrerr	function
(	O
"user %s does not exist"	pointer
,	O
p	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
gstrcpy	function
(	O
buf	array
,	O
pw	pointer
->	O
pw_dir	pointer
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
gstrcat	function
(	O
buf	array
,	O
"/src"	pointer
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
if	O
(	O
access	function
(	O
buf	array
,	O
0	int
)	O
<	O
0	int
)	O
{	O
gstrcpy	function
(	O
buf	array
,	O
pw	pointer
->	O
pw_dir	pointer
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
gstrcat	function
(	O
buf	array
,	O
"/source"	pointer
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
if	O
(	O
access	function
(	O
buf	array
,	O
0	int
)	O
<	O
0	int
)	O
{	O
usrerr	function
(	O
"project %s has no source!"	pointer
,	O
p	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
}	O
SccsDir	pointer
=	O
buf	array
;	O
}	O
}	O
if	O
(	O
argc	int
<	O
2	int
)	O
{	O
usage	function
(	O
)	O
;	O
exit	function
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
argv	array
[	O
argc	int
]	O
=	O
NULL	O
;	O
if	O
(	O
lookup	function
(	O
argv	array
[	O
0	int
]	O
)	O
==	O
NULL	O
)	O
{	O
while	O
(	O
(	O
p	pointer
=	O
*	O
++	O
argv	array
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
*	O
p	pointer
!=	O
'-'	O
)	O
break	O
;	O
switch	O
(	O
*	O
++	O
p	pointer
)	O
{	O
case	O
'-'	O
:	O
++	O
p	pointer
;	O
if	O
(	O
0	int
==	O
*	O
p	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s"	pointer
,	O
"End-of-arguments option \"--\" not "	pointer
"supported, sorry.\n"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strncmp	function
(	O
p	pointer
,	O
"prefix="	pointer
,	O
7	int
)	O
)	O
{	O
set_prefix	function
(	O
p	pointer
+	O
7	int
)	O
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
p	pointer
,	O
"cssc"	pointer
)	O
)	O
{	O
printf	function
(	O
"%s\n"	pointer
,	O
"yes"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_OK	int
)	O
;	O
}	O
else	O
if	O
(	O
0	int
==	O
strcmp	function
(	O
p	pointer
,	O
"version"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
hadver	int
)	O
show_version	function
(	O
)	O
;	O
hadver	int
=	O
1	int
;	O
if	O
(	O
2	int
==	O
argc	int
)	O
return	O
0	int
;	O
}	O
else	O
{	O
usrerr	function
(	O
"unknown option --%s"	pointer
,	O
p	pointer
)	O
;	O
usage	function
(	O
)	O
;	O
exit	function
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
break	O
;	O
case	O
'V'	O
:	O
if	O
(	O
!	O
hadver	int
)	O
show_version	function
(	O
)	O
;	O
hadver	int
=	O
1	int
;	O
if	O
(	O
2	int
==	O
argc	int
)	O
return	O
0	int
;	O
break	O
;	O
case	O
'r'	O
:	O
drop_privs	function
(	O
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
SccsPath	pointer
=	O
++	O
p	pointer
;	O
if	O
(	O
SccsPath	pointer
[	O
0	int
]	O
==	O
'\0'	O
&&	O
argv	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
SccsPath	pointer
=	O
*	O
++	O
argv	array
;	O
break	O
;	O
case	O
'd'	O
:	O
SccsDir	pointer
=	O
++	O
p	pointer
;	O
if	O
(	O
SccsDir	pointer
[	O
0	int
]	O
==	O
'\0'	O
&&	O
argv	array
[	O
1	int
]	O
!=	O
NULL	O
)	O
SccsDir	pointer
=	O
*	O
++	O
argv	array
;	O
break	O
;	O
case	O
'T'	O
:	O
Debug	char
++	O
;	O
break	O
;	O
default	O
:	O
usrerr	function
(	O
"unknown option -%s"	pointer
,	O
p	pointer
)	O
;	O
usage	function
(	O
)	O
;	O
exit	function
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
}	O
if	O
(	O
SccsPath	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
SccsPath	pointer
=	O
"."	pointer
;	O
}	O
if	O
(	O
NULL	O
==	O
argv	array
[	O
0	int
]	O
)	O
{	O
if	O
(	O
!	O
hadver	int
)	O
{	O
usage	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
i	int
=	O
command	function
(	O
argv	array
,	O
FALSE	int
,	O
""	pointer
)	O
;	O
return	O
i	int
;	O
}	O
}	O
char	O
*	O
*	O
do_enter	function
(	O
char	O
*	O
argv	array
[	O
]	O
,	O
char	O
*	O
*	O
np	pointer
,	O
char	O
*	O
*	O
ap	pointer
,	O
int	O
*	O
rval	pointer
)	O
{	O
char	O
buf2	array
[	O
FBUFSIZ	O
]	O
;	O
char	O
*	O
argv_tmp	pointer
;	O
for	O
(	O
np	pointer
=	O
&	O
ap	pointer
[	O
1	int
]	O
;	O
*	O
np	pointer
!=	O
NULL	O
&&	O
*	O
*	O
np	pointer
==	O
'-'	O
;	O
np	pointer
++	O
)	O
continue	O
;	O
argv	array
=	O
np	pointer
;	O
argv_tmp	pointer
=	O
argv	array
[	O
1	int
]	O
;	O
while	O
(	O
np	pointer
[	O
0	int
]	O
!=	O
NULL	O
)	O
{	O
printf	function
(	O
"\n%s:\n"	pointer
,	O
*	O
np	pointer
)	O
;	O
strcpy	function
(	O
buf2	array
,	O
"-i"	pointer
)	O
;	O
gstrcat	function
(	O
buf2	array
,	O
np	pointer
[	O
0	int
]	O
,	O
sizeof	O
(	O
buf2	array
)	O
)	O
;	O
ap	pointer
[	O
0	int
]	O
=	O
buf2	array
;	O
argv	array
[	O
0	int
]	O
=	O
tail_nc	function
(	O
np	pointer
[	O
0	int
]	O
)	O
;	O
argv	array
[	O
1	int
]	O
=	O
NULL	O
;	O
*	O
rval	pointer
=	O
command	function
(	O
ap	pointer
,	O
TRUE	int
,	O
"admin"	pointer
)	O
;	O
argv	array
[	O
1	int
]	O
=	O
argv_tmp	pointer
;	O
if	O
(	O
*	O
rval	pointer
==	O
0	int
)	O
{	O
strcpy	function
(	O
buf2	array
,	O
","	pointer
)	O
;	O
gstrcat	function
(	O
buf2	array
,	O
tail	function
(	O
np	pointer
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
buf2	array
)	O
)	O
;	O
if	O
(	O
link	function
(	O
np	pointer
[	O
0	int
]	O
,	O
buf2	array
)	O
>=	O
0	int
)	O
unlink	function
(	O
np	pointer
[	O
0	int
]	O
)	O
;	O
}	O
np	pointer
++	O
;	O
}	O
return	O
np	pointer
;	O
}	O
static	O
int	O
absolute_pathname	function
(	O
const	O
char	O
*	O
p	pointer
)	O
{	O
return	O
'/'	O
==	O
p	pointer
[	O
0	int
]	O
;	O
}	O
static	O
void	O
try_to_exec	function
(	O
const	O
char	O
*	O
prog	pointer
,	O
char	O
*	O
const	O
argv	array
[	O
]	O
)	O
{	O
char	O
*	O
newprog	pointer
;	O
const	O
char	O
*	O
prefix	pointer
;	O
size_t	long
len	long
;	O
if	O
(	O
Debug	char
)	O
printf	function
(	O
"try_to_exec: %s\n"	pointer
,	O
prog	pointer
)	O
;	O
if	O
(	O
subprogram_exec_prefix	pointer
)	O
{	O
prefix	pointer
=	O
subprogram_exec_prefix	pointer
;	O
if	O
(	O
Debug	char
)	O
printf	function
(	O
"try_to_exec: Using user prefix '%s'\n"	pointer
,	O
prefix	pointer
)	O
;	O
}	O
else	O
{	O
prefix	pointer
=	O
(	O
PREFIX	O
)	O
;	O
if	O
(	O
Debug	char
)	O
printf	function
(	O
"try_to_exec: Using default prefix '%s'\n"	pointer
,	O
prefix	pointer
)	O
;	O
if	O
(	O
TrustEnvironment	char
||	O
RealUser	char
)	O
execvp	function
(	O
prog	pointer
,	O
argv	array
)	O
;	O
}	O
if	O
(	O
absolute_pathname	function
(	O
prog	pointer
)	O
)	O
{	O
execv	function
(	O
prog	pointer
,	O
argv	array
)	O
;	O
perror	function
(	O
prog	pointer
)	O
;	O
}	O
else	O
{	O
len	long
=	O
strlen	function
(	O
prefix	pointer
)	O
+	O
strlen	function
(	O
prog	pointer
)	O
;	O
newprog	pointer
=	O
malloc	function
(	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
NULL	O
==	O
newprog	pointer
)	O
{	O
oom	function
(	O
)	O
;	O
exit	function
(	O
CSSC_EX_TEMPFAIL	int
)	O
;	O
}	O
sprintf	function
(	O
newprog	pointer
,	O
"%s%s"	pointer
,	O
prefix	pointer
,	O
prog	pointer
)	O
;	O
prog	pointer
=	O
newprog	pointer
;	O
if	O
(	O
Debug	char
)	O
printf	function
(	O
"try_to_exec: %s\n"	pointer
,	O
prog	pointer
)	O
;	O
execv	function
(	O
prog	pointer
,	O
argv	array
)	O
;	O
perror	function
(	O
prog	pointer
)	O
;	O
}	O
if	O
(	O
Debug	char
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"try_to_exec: exec failed.\n"	pointer
)	O
;	O
}	O
}	O
int	O
command	function
(	O
char	O
*	O
argv	array
[	O
]	O
,	O
bool	char
forkflag	char
,	O
const	O
char	O
*	O
arg0	pointer
)	O
{	O
const	O
struct	O
sccsprog	struct
*	O
cmd	pointer
;	O
char	O
buf	array
[	O
FBUFSIZ	O
]	O
;	O
char	O
*	O
nav	array
[	O
1000	int
]	O
;	O
char	O
*	O
*	O
np	pointer
;	O
char	O
*	O
*	O
ap	pointer
;	O
int	O
rval	pointer
=	O
0	int
;	O
if	O
(	O
Debug	char
)	O
{	O
int	O
i	int
;	O
printf	function
(	O
"command:\n\t\"%s\"\n"	pointer
,	O
arg0	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
argv	array
[	O
i	int
]	O
!=	O
NULL	O
;	O
++	O
i	int
)	O
printf	function
(	O
"\t\"%s\"\n"	pointer
,	O
argv	array
[	O
i	int
]	O
)	O
;	O
}	O
np	pointer
=	O
ap	pointer
=	O
&	O
nav	array
[	O
1	int
]	O
;	O
if	O
(	O
1	int
)	O
{	O
char	O
*	O
editchs	pointer
;	O
editchs	pointer
=	O
NULL	O
;	O
if	O
(	O
1	int
)	O
{	O
char	O
*	O
q	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
arg0	pointer
,	O
q	pointer
=	O
buf	array
;	O
*	O
p	pointer
!=	O
'\0'	O
&&	O
*	O
p	pointer
!=	O
'/'	O
;	O
)	O
{	O
*	O
np	pointer
++	O
=	O
q	pointer
;	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
)	O
p	pointer
++	O
;	O
while	O
(	O
*	O
p	pointer
!=	O
' '	O
&&	O
*	O
p	pointer
!=	O
'\0'	O
&&	O
*	O
p	pointer
!=	O
'/'	O
&&	O
*	O
p	pointer
!=	O
':'	O
)	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
*	O
q	pointer
++	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
p	pointer
==	O
':'	O
)	O
{	O
editchs	pointer
=	O
q	pointer
;	O
while	O
(	O
*	O
++	O
p	pointer
!=	O
'\0'	O
&&	O
*	O
p	pointer
!=	O
'/'	O
&&	O
*	O
p	pointer
!=	O
' '	O
)	O
*	O
q	pointer
++	O
=	O
*	O
p	pointer
;	O
*	O
q	pointer
++	O
=	O
'\0'	O
;	O
}	O
}	O
}	O
*	O
np	pointer
=	O
NULL	O
;	O
if	O
(	O
*	O
ap	pointer
==	O
NULL	O
)	O
*	O
np	pointer
++	O
=	O
*	O
argv	array
++	O
;	O
cmd	pointer
=	O
lookup	function
(	O
*	O
ap	pointer
)	O
;	O
if	O
(	O
cmd	pointer
==	O
NULL	O
)	O
{	O
usrerr	function
(	O
"Unknown command \"%s\""	pointer
,	O
*	O
ap	pointer
)	O
;	O
usage	function
(	O
)	O
;	O
return	O
(	O
CSSC_EX_USAGE	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
cmd	pointer
->	O
sccsflags	short
&	O
WARN_MISSING	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: the \"%s\" command is not yet implemented.\n"	pointer
,	O
*	O
ap	pointer
)	O
;	O
}	O
if	O
(	O
cmd	pointer
->	O
sccsflags	short
&	O
NO_HELP_HERE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"GNU CSSC does not provide the \"%s\" command;\n"	pointer
"please see the relevant entry in the GNU CSSC manual\n"	pointer
"and the \"Missing Features and other Problems\" chapter\n"	pointer
"in particular.\n\n"	pointer
,	O
*	O
ap	pointer
)	O
;	O
}	O
}	O
for	O
(	O
;	O
*	O
argv	array
!=	O
NULL	O
;	O
argv	array
++	O
)	O
{	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
*	O
argv	array
;	O
if	O
(	O
*	O
p	pointer
==	O
'-'	O
)	O
{	O
if	O
(	O
p	pointer
[	O
1	int
]	O
==	O
'\0'	O
||	O
editchs	pointer
==	O
NULL	O
||	O
my_index	function
(	O
editchs	pointer
,	O
p	pointer
[	O
1	int
]	O
)	O
!=	O
NULL	O
)	O
*	O
np	pointer
++	O
=	O
p	pointer
;	O
}	O
else	O
{	O
if	O
(	O
!	O
bitset	O
(	O
NO_SDOT	int
,	O
cmd	pointer
->	O
sccsflags	short
)	O
)	O
p	pointer
=	O
makefile	function
(	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
*	O
np	pointer
++	O
=	O
p	pointer
;	O
}	O
}	O
*	O
np	pointer
=	O
NULL	O
;	O
}	O
switch	O
(	O
cmd	pointer
->	O
sccsoper	short
)	O
{	O
case	O
PROG	int
:	O
{	O
rval	pointer
=	O
callprog	function
(	O
cmd	pointer
->	O
sccspath	pointer
,	O
cmd	pointer
->	O
sccsflags	short
,	O
ap	pointer
,	O
forkflag	char
)	O
;	O
}	O
break	O
;	O
case	O
CMACRO	int
:	O
{	O
const	O
char	O
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
cmd	pointer
->	O
sccspath	pointer
;	O
*	O
s	pointer
!=	O
'\0'	O
;	O
s	pointer
++	O
)	O
{	O
const	O
char	O
*	O
qq	pointer
=	O
s	pointer
;	O
while	O
(	O
*	O
s	pointer
!=	O
'\0'	O
&&	O
*	O
s	pointer
!=	O
'/'	O
)	O
s	pointer
++	O
;	O
rval	pointer
=	O
command	function
(	O
&	O
ap	pointer
[	O
1	int
]	O
,	O
*	O
s	pointer
!=	O
'\0'	O
,	O
qq	pointer
)	O
;	O
if	O
(	O
rval	pointer
!=	O
0	int
)	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
FIX	int
:	O
{	O
if	O
(	O
ap	pointer
[	O
1	int
]	O
==	O
0	int
||	O
strncmp	function
(	O
ap	pointer
[	O
1	int
]	O
,	O
"-r"	pointer
,	O
2	int
)	O
!=	O
0	int
)	O
{	O
usrerr	function
(	O
"-r flag needed for fix command"	pointer
)	O
;	O
rval	pointer
=	O
CSSC_EX_USAGE	int
;	O
break	O
;	O
}	O
rval	pointer
=	O
command	function
(	O
&	O
ap	pointer
[	O
1	int
]	O
,	O
TRUE	int
,	O
"get -k"	pointer
)	O
;	O
if	O
(	O
rval	pointer
==	O
0	int
)	O
rval	pointer
=	O
command	function
(	O
&	O
ap	pointer
[	O
1	int
]	O
,	O
TRUE	int
,	O
"rmdel:r"	pointer
)	O
;	O
if	O
(	O
rval	pointer
==	O
0	int
)	O
rval	pointer
=	O
command	function
(	O
&	O
ap	pointer
[	O
2	int
]	O
,	O
FALSE	int
,	O
"get -e -g"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
CLEAN	int
:	O
{	O
rval	pointer
=	O
clean	function
(	O
cmd	pointer
->	O
clean_mode	int
,	O
ap	pointer
)	O
;	O
}	O
break	O
;	O
case	O
UNEDIT	int
:	O
{	O
for	O
(	O
argv	array
=	O
np	pointer
=	O
&	O
ap	pointer
[	O
1	int
]	O
;	O
*	O
argv	array
!=	O
NULL	O
;	O
argv	array
++	O
)	O
{	O
if	O
(	O
unedit	function
(	O
*	O
argv	array
)	O
)	O
*	O
np	pointer
++	O
=	O
*	O
argv	array
;	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
*	O
np	pointer
=	O
NULL	O
;	O
if	O
(	O
np	pointer
>	O
&	O
ap	pointer
[	O
1	int
]	O
)	O
rval	pointer
=	O
command	function
(	O
&	O
ap	pointer
[	O
1	int
]	O
,	O
TRUE	int
,	O
"get"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
DIFFS	int
:	O
{	O
char	O
*	O
s	pointer
;	O
for	O
(	O
np	pointer
=	O
&	O
ap	pointer
[	O
1	int
]	O
;	O
*	O
np	pointer
!=	O
NULL	O
&&	O
*	O
*	O
np	pointer
==	O
'-'	O
;	O
np	pointer
++	O
)	O
continue	O
;	O
argv	array
=	O
np	pointer
;	O
s	pointer
=	O
argv	array
[	O
1	int
]	O
;	O
while	O
(	O
*	O
np	pointer
!=	O
NULL	O
)	O
{	O
int	O
this_ret	int
;	O
*	O
argv	array
=	O
*	O
np	pointer
++	O
;	O
argv	array
[	O
1	int
]	O
=	O
NULL	O
;	O
this_ret	int
=	O
dodiff	function
(	O
ap	pointer
,	O
tail	function
(	O
*	O
argv	array
)	O
)	O
;	O
if	O
(	O
rval	pointer
==	O
0	int
)	O
rval	pointer
=	O
this_ret	int
;	O
argv	array
[	O
1	int
]	O
=	O
s	pointer
;	O
}	O
}	O
break	O
;	O
case	O
DODIFF	int
:	O
{	O
drop_privs	function
(	O
)	O
;	O
for	O
(	O
np	pointer
=	O
ap	pointer
;	O
*	O
np	pointer
!=	O
NULL	O
;	O
np	pointer
++	O
)	O
{	O
if	O
(	O
(	O
*	O
np	pointer
)	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
(	O
*	O
np	pointer
)	O
[	O
1	int
]	O
==	O
'C'	O
)	O
(	O
*	O
np	pointer
)	O
[	O
1	int
]	O
=	O
'c'	O
;	O
}	O
np	pointer
[	O
1	int
]	O
=	O
NULL	O
;	O
np	pointer
[	O
0	int
]	O
=	O
np	pointer
[	O
-	O
1	int
]	O
;	O
np	pointer
[	O
-	O
1	int
]	O
=	O
"-"	pointer
;	O
if	O
(	O
TrustEnvironment	char
)	O
execvp	function
(	O
"diff"	pointer
,	O
ap	pointer
)	O
;	O
try_to_exec	function
(	O
cmd	pointer
->	O
sccspath	pointer
,	O
argv	array
)	O
;	O
exit	function
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
break	O
;	O
case	O
ENTER	int
:	O
np	pointer
=	O
do_enter	function
(	O
argv	array
,	O
np	pointer
,	O
ap	pointer
,	O
&	O
rval	pointer
)	O
;	O
break	O
;	O
default	O
:	O
{	O
syserr	function
(	O
"Unexpected oper %d"	pointer
,	O
cmd	pointer
->	O
sccsoper	short
)	O
;	O
exit	function
(	O
CSSC_EX_SOFTWARE	int
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
Debug	char
)	O
printf	function
(	O
"command: rval=%d\n"	pointer
,	O
rval	pointer
)	O
;	O
return	O
rval	pointer
;	O
}	O
const	O
struct	O
sccsprog	struct
*	O
lookup	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
register	O
const	O
struct	O
sccsprog	struct
*	O
cmd	pointer
;	O
for	O
(	O
cmd	pointer
=	O
SccsProg	array
;	O
cmd	pointer
->	O
sccsname	pointer
!=	O
NULL	O
;	O
cmd	pointer
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
->	O
sccsname	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
cmd	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
childwait	function
(	O
int	O
pid	int
,	O
int	O
*	O
status_ptr	pointer
,	O
int	O
ignoreintr	int
)	O
{	O
struct	O
sigaction	struct
sa	struct
,	O
osa	struct
;	O
int	O
ret	int
;	O
memset	function
(	O
&	O
sa	struct
,	O
0	int
,	O
sizeof	O
(	O
sa	struct
)	O
)	O
;	O
if	O
(	O
ignoreintr	int
)	O
{	O
sa	struct
.	O
sa_handler	pointer
=	O
SIG_IGN	O
;	O
sigemptyset	function
(	O
&	O
sa	struct
.	O
sa_mask	struct
)	O
;	O
sa	struct
.	O
sa_flags	int
=	O
0	int
;	O
ret	int
=	O
sigaction	struct
(	O
SIGINT	int
,	O
&	O
sa	struct
,	O
&	O
osa	struct
)	O
;	O
}	O
while	O
(	O
-	O
1	int
==	O
waitpid	function
(	O
pid	int
,	O
status_ptr	pointer
,	O
0	int
)	O
&&	O
EINTR	int
==	O
errno	O
)	O
errno	O
=	O
0	int
;	O
if	O
(	O
ignoreintr	int
&&	O
0	int
==	O
ret	int
)	O
sigaction	struct
(	O
SIGINT	int
,	O
&	O
osa	struct
,	O
NULL	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
get_sig_name	function
(	O
unsigned	O
int	O
sig	int
,	O
char	O
sigmsgbuf	array
[	O
11	int
]	O
)	O
{	O
if	O
(	O
sig	int
>	O
999	int
)	O
sig	int
=	O
999	int
;	O
sprintf	function
(	O
sigmsgbuf	array
,	O
"Signal %u"	pointer
,	O
sig	int
)	O
;	O
return	O
sigmsgbuf	array
;	O
}	O
static	O
pid_t	int
do_fork	function
(	O
void	O
)	O
{	O
return	O
fork	function
(	O
)	O
;	O
}	O
int	O
callprog	function
(	O
const	O
char	O
*	O
progpath	pointer
,	O
short	O
flags	short
,	O
char	O
*	O
const	O
argv	array
[	O
]	O
,	O
bool	char
forkflag	char
)	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
Debug	char
)	O
{	O
printf	function
(	O
"%s\n"	pointer
,	O
"callprog:"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
argv	array
[	O
i	int
]	O
!=	O
NULL	O
;	O
i	int
++	O
)	O
printf	function
(	O
"\t\"%s\"\n"	pointer
,	O
argv	array
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
*	O
argv	array
==	O
NULL	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
forkflag	char
)	O
{	O
if	O
(	O
Debug	char
)	O
printf	function
(	O
"%s"	pointer
,	O
"Forking\n"	pointer
)	O
;	O
i	int
=	O
do_fork	function
(	O
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
syserr	function
(	O
"cannot fork"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
else	O
if	O
(	O
i	int
>	O
0	int
)	O
{	O
int	O
st	int
;	O
childwait	function
(	O
i	int
,	O
&	O
st	int
,	O
0	int
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
st	int
)	O
)	O
{	O
st	int
=	O
WEXITSTATUS	O
(	O
st	int
)	O
;	O
}	O
else	O
{	O
int	O
sigcode	int
=	O
WTERMSIG	O
(	O
st	int
)	O
;	O
if	O
(	O
sigcode	int
!=	O
SIGINT	int
&&	O
sigcode	int
!=	O
SIGPIPE	int
)	O
{	O
char	O
sigmsgbuf	array
[	O
11	int
]	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s: %s%s\n"	pointer
,	O
program_name	pointer
,	O
argv	array
[	O
0	int
]	O
,	O
get_sig_name	function
(	O
sigcode	int
,	O
sigmsgbuf	array
)	O
,	O
(	O
WCOREDUMP	O
(	O
st	int
)	O
?	O
" (core dumped)"	pointer
:	O
""	pointer
)	O
)	O
;	O
}	O
st	int
=	O
CSSC_EX_SOFTWARE	int
;	O
}	O
if	O
(	O
OutFile	int
>=	O
0	int
)	O
{	O
close	pointer
(	O
OutFile	int
)	O
;	O
OutFile	int
=	O
-	O
1	int
;	O
}	O
return	O
(	O
st	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
OutFile	int
>=	O
0	int
)	O
{	O
syserr	function
(	O
"callprog: setting stdout without forking"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_SOFTWARE	int
)	O
;	O
}	O
if	O
(	O
bitset	O
(	O
REALUSER	int
,	O
flags	short
)	O
)	O
{	O
drop_privs	function
(	O
)	O
;	O
RealUser	char
=	O
1	int
;	O
if	O
(	O
Debug	char
)	O
printf	function
(	O
"callprog: gave up privileges.\n"	pointer
)	O
;	O
}	O
if	O
(	O
OutFile	int
>=	O
0	int
)	O
{	O
close	pointer
(	O
1	int
)	O
;	O
dup	function
(	O
OutFile	int
)	O
;	O
close	pointer
(	O
OutFile	int
)	O
;	O
}	O
try_to_exec	function
(	O
progpath	pointer
,	O
argv	array
)	O
;	O
exit	function
(	O
CSSC_EX_UNAVAILABLE	int
)	O
;	O
}	O
static	O
char	O
*	O
str_dup	function
(	O
const	O
char	O
*	O
s	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
s	pointer
)	O
+	O
1u	int
;	O
p	pointer
=	O
malloc	function
(	O
len	long
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
memcpy	function
(	O
p	pointer
,	O
s	pointer
,	O
len	long
)	O
;	O
}	O
else	O
{	O
perror	function
(	O
"Sccs: no mem"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_TEMPFAIL	int
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
char	O
*	O
makefile	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
register	O
const	O
char	O
*	O
p	pointer
;	O
char	O
buf	array
[	O
3	int
*	O
FBUFSIZ	O
]	O
;	O
register	O
char	O
*	O
q	pointer
;	O
size_t	long
left	long
;	O
p	pointer
=	O
my_rindex	function
(	O
name	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
p	pointer
=	O
name	pointer
;	O
else	O
p	pointer
++	O
;	O
if	O
(	O
SccsDir	pointer
[	O
0	int
]	O
==	O
'/'	O
&&	O
!	O
safepath	function
(	O
name	pointer
)	O
)	O
return	O
(	O
NULL	O
)	O
;	O
if	O
(	O
SccsDir	pointer
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
name	pointer
[	O
0	int
]	O
!=	O
'/'	O
&&	O
strncmp	function
(	O
name	pointer
,	O
"./"	pointer
,	O
2	int
)	O
!=	O
0	int
)	O
{	O
gstrcpy	function
(	O
buf	array
,	O
SccsDir	pointer
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
gstrcat	function
(	O
buf	array
,	O
"/"	pointer
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
}	O
else	O
{	O
gstrcpy	function
(	O
buf	array
,	O
""	pointer
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
}	O
gstrncat	function
(	O
buf	array
,	O
name	pointer
,	O
p	pointer
-	O
name	pointer
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
q	pointer
=	O
&	O
buf	array
[	O
strlen	function
(	O
buf	array
)	O
]	O
;	O
left	long
=	O
sizeof	O
(	O
buf	array
)	O
-	O
strlen	function
(	O
buf	array
)	O
;	O
gstrcpy	function
(	O
q	pointer
,	O
p	pointer
,	O
left	long
)	O
;	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
"s."	pointer
,	O
2	int
)	O
!=	O
0	int
&&	O
!	O
isdir	function
(	O
buf	array
)	O
)	O
{	O
gstrcpy	function
(	O
q	pointer
,	O
SccsPath	pointer
,	O
left	long
)	O
;	O
gstrcat	function
(	O
buf	array
,	O
"/s."	pointer
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
gstrcat	function
(	O
buf	array
,	O
p	pointer
,	O
sizeof	O
(	O
buf	array
)	O
)	O
;	O
}	O
return	O
str_dup	function
(	O
buf	array
)	O
;	O
}	O
bool	char
isdir	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
stat	struct
stbuf	struct
;	O
return	O
(	O
stat	struct
(	O
name	pointer
,	O
&	O
stbuf	struct
)	O
>=	O
0	int
)	O
&&	O
S_ISDIR	O
(	O
stbuf	struct
.	O
st_mode	int
)	O
;	O
}	O
bool	char
safepath	function
(	O
register	O
const	O
char	O
*	O
p	pointer
)	O
{	O
const	O
char	O
*	O
arg	pointer
=	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
!=	O
'/'	O
)	O
{	O
while	O
(	O
strncmp	function
(	O
p	pointer
,	O
"../"	pointer
,	O
3	int
)	O
!=	O
0	int
&&	O
strcmp	function
(	O
p	pointer
,	O
".."	pointer
)	O
!=	O
0	int
)	O
{	O
p	pointer
=	O
my_index	function
(	O
p	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
TRUE	int
;	O
p	pointer
++	O
;	O
}	O
}	O
printf	function
(	O
"You may not use full pathnames or \"..\" but you specifed '%s'\n"	pointer
,	O
arg	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
void	O
form_gname	function
(	O
char	O
*	O
buf	array
,	O
size_t	long
bufsize	long
,	O
struct	O
dirent	struct
*	O
dir	pointer
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
dir	pointer
->	O
d_name	array
)	O
;	O
size_t	long
gname_len	long
=	O
len	long
-	O
2u	int
;	O
if	O
(	O
gname_len	long
>=	O
bufsize	long
)	O
{	O
gstrbotchn	function
(	O
bufsize	long
,	O
dir	pointer
->	O
d_name	array
,	O
len	long
,	O
(	O
char	O
*	O
)	O
0	int
,	O
0	int
)	O
;	O
}	O
else	O
{	O
memcpy	function
(	O
buf	array
,	O
dir	pointer
->	O
d_name	array
+	O
2	int
,	O
gname_len	long
)	O
;	O
buf	array
[	O
gname_len	long
]	O
=	O
0	int
;	O
}	O
}	O
int	O
do_clean	function
(	O
int	O
mode	int
,	O
char	O
*	O
const	O
*	O
argv	array
,	O
char	O
buf	array
[	O
FBUFSIZ	O
]	O
)	O
{	O
struct	O
dirent	struct
*	O
dir	pointer
;	O
register	O
DIR	struct
*	O
dirp	pointer
;	O
char	O
*	O
bufend	pointer
;	O
register	O
char	O
*	O
basefile	pointer
;	O
bool	char
gotedit	char
;	O
bool	char
gotpfent	char
;	O
FILE	struct
*	O
pfp	pointer
;	O
bool	char
nobranch	char
=	O
FALSE	int
;	O
register	O
const	O
struct	O
pfile	struct
*	O
pf	pointer
;	O
register	O
char	O
*	O
const	O
*	O
ap	pointer
;	O
const	O
char	O
*	O
usernm	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
subdir	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
cmdname	pointer
;	O
cmdname	pointer
=	O
*	O
argv	array
;	O
for	O
(	O
ap	pointer
=	O
argv	array
;	O
*	O
++	O
ap	pointer
!=	O
NULL	O
;	O
)	O
{	O
if	O
(	O
*	O
*	O
ap	pointer
==	O
'-'	O
)	O
{	O
switch	O
(	O
(	O
*	O
ap	pointer
)	O
[	O
1	int
]	O
)	O
{	O
case	O
'b'	O
:	O
nobranch	char
=	O
TRUE	int
;	O
break	O
;	O
case	O
'u'	O
:	O
if	O
(	O
(	O
*	O
ap	pointer
)	O
[	O
2	int
]	O
!=	O
'\0'	O
)	O
usernm	pointer
=	O
&	O
(	O
*	O
ap	pointer
)	O
[	O
2	int
]	O
;	O
else	O
if	O
(	O
ap	pointer
[	O
1	int
]	O
!=	O
NULL	O
&&	O
ap	pointer
[	O
1	int
]	O
[	O
0	int
]	O
!=	O
'-'	O
)	O
usernm	pointer
=	O
*	O
++	O
ap	pointer
;	O
else	O
usernm	pointer
=	O
username	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
subdir	pointer
!=	O
NULL	O
)	O
usrerr	function
(	O
"too many args"	pointer
)	O
;	O
else	O
subdir	pointer
=	O
*	O
ap	pointer
;	O
}	O
}	O
gstrcpy	function
(	O
buf	array
,	O
SccsDir	pointer
,	O
FBUFSIZ	O
)	O
;	O
if	O
(	O
buf	array
[	O
0	int
]	O
!=	O
'\0'	O
)	O
gstrcat	function
(	O
buf	array
,	O
"/"	pointer
,	O
FBUFSIZ	O
)	O
;	O
if	O
(	O
subdir	pointer
!=	O
NULL	O
)	O
{	O
gstrcat	function
(	O
buf	array
,	O
subdir	pointer
,	O
FBUFSIZ	O
)	O
;	O
gstrcat	function
(	O
buf	array
,	O
"/"	pointer
,	O
FBUFSIZ	O
)	O
;	O
}	O
gstrcat	function
(	O
buf	array
,	O
SccsPath	pointer
,	O
FBUFSIZ	O
)	O
;	O
bufend	pointer
=	O
&	O
buf	array
[	O
strlen	function
(	O
buf	array
)	O
]	O
;	O
dirp	pointer
=	O
opendir	function
(	O
buf	array
)	O
;	O
if	O
(	O
dirp	pointer
==	O
NULL	O
)	O
{	O
usrerr	function
(	O
"cannot open %s"	pointer
,	O
buf	array
)	O
;	O
return	O
(	O
CSSC_EX_NOINPUT	int
)	O
;	O
}	O
gotedit	char
=	O
FALSE	int
;	O
while	O
(	O
NULL	O
!=	O
(	O
dir	pointer
=	O
readdir	function
(	O
dirp	pointer
)	O
)	O
)	O
{	O
if	O
(	O
's'	O
!=	O
dir	pointer
->	O
d_name	array
[	O
0	int
]	O
||	O
'.'	O
!=	O
dir	pointer
->	O
d_name	array
[	O
1	int
]	O
||	O
0	int
==	O
dir	pointer
->	O
d_name	array
[	O
2	int
]	O
)	O
continue	O
;	O
gstrcat	function
(	O
buf	array
,	O
"/p."	pointer
,	O
FBUFSIZ	O
)	O
;	O
basefile	pointer
=	O
bufend	pointer
+	O
3	int
;	O
form_gname	function
(	O
basefile	pointer
,	O
FBUFSIZ	O
-	O
strlen	function
(	O
buf	array
)	O
,	O
dir	pointer
)	O
;	O
pfp	pointer
=	O
fopen	function
(	O
buf	array
,	O
"r"	pointer
)	O
;	O
gotpfent	char
=	O
FALSE	int
;	O
if	O
(	O
pfp	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
(	O
pf	pointer
=	O
getpfent	function
(	O
pfp	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
nobranch	char
&&	O
isbranch	function
(	O
pf	pointer
->	O
p_nsid	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
usernm	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
usernm	pointer
,	O
pf	pointer
->	O
p_user	pointer
)	O
!=	O
0	int
&&	O
mode	int
!=	O
CLEANC	int
)	O
continue	O
;	O
gotedit	char
=	O
TRUE	int
;	O
gotpfent	char
=	O
TRUE	int
;	O
if	O
(	O
mode	int
==	O
TELLC	int
)	O
{	O
printf	function
(	O
"%s\n"	pointer
,	O
basefile	pointer
)	O
;	O
break	O
;	O
}	O
printf	function
(	O
"%12s: being edited: "	pointer
,	O
basefile	pointer
)	O
;	O
putpfent	function
(	O
pf	pointer
,	O
stdout	pointer
)	O
;	O
}	O
fclose	function
(	O
pfp	pointer
)	O
;	O
}	O
if	O
(	O
mode	int
==	O
CLEANC	int
&&	O
!	O
gotpfent	char
)	O
{	O
char	O
unlinkbuf	array
[	O
FBUFSIZ	O
]	O
;	O
form_gname	function
(	O
unlinkbuf	array
,	O
FBUFSIZ	O
,	O
dir	pointer
)	O
;	O
unlink	function
(	O
unlinkbuf	array
)	O
;	O
}	O
}	O
closedir	function
(	O
dirp	pointer
)	O
;	O
if	O
(	O
!	O
gotedit	char
&&	O
mode	int
==	O
INFOC	int
)	O
{	O
printf	function
(	O
"Nothing being edited"	pointer
)	O
;	O
if	O
(	O
nobranch	char
)	O
printf	function
(	O
" (on trunk)"	pointer
)	O
;	O
if	O
(	O
usernm	pointer
==	O
NULL	O
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
else	O
printf	function
(	O
" by %s\n"	pointer
,	O
usernm	pointer
)	O
;	O
}	O
if	O
(	O
mode	int
==	O
CHECKC	int
)	O
exit	function
(	O
gotedit	char
)	O
;	O
return	O
(	O
CSSC_EX_OK	int
)	O
;	O
}	O
int	O
clean	function
(	O
int	O
mode	int
,	O
char	O
*	O
const	O
*	O
argv	array
)	O
{	O
int	O
retval	int
=	O
CSSC_EX_OK	int
;	O
char	O
*	O
buf	array
=	O
malloc	function
(	O
FBUFSIZ	O
)	O
;	O
if	O
(	O
NULL	O
==	O
buf	array
)	O
{	O
oom	function
(	O
)	O
;	O
}	O
else	O
{	O
retval	int
=	O
do_clean	function
(	O
mode	int
,	O
argv	array
,	O
buf	array
)	O
;	O
free	function
(	O
buf	array
)	O
;	O
}	O
return	O
retval	int
;	O
}	O
int	O
isbranch	function
(	O
const	O
char	O
*	O
sid	pointer
)	O
{	O
register	O
const	O
char	O
*	O
p	pointer
;	O
int	O
dots	int
;	O
dots	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
sid	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'.'	O
)	O
dots	int
++	O
;	O
if	O
(	O
dots	int
>	O
1	int
)	O
return	O
TRUE	int
;	O
}	O
return	O
FALSE	int
;	O
}	O
bool	char
unedit	function
(	O
const	O
char	O
*	O
fn	pointer
)	O
{	O
register	O
FILE	struct
*	O
pfp	pointer
;	O
const	O
char	O
*	O
cp	pointer
;	O
char	O
*	O
pfn	pointer
;	O
FILE	struct
*	O
tfp	pointer
;	O
register	O
char	O
*	O
q	pointer
;	O
bool	char
delete	char
=	O
FALSE	int
;	O
bool	char
others	char
=	O
FALSE	int
;	O
const	O
char	O
*	O
myname	pointer
;	O
const	O
struct	O
pfile	struct
*	O
pent	pointer
;	O
char	O
buf	array
[	O
PFILELG	int
]	O
;	O
pfn	pointer
=	O
makefile	function
(	O
fn	pointer
)	O
;	O
if	O
(	O
pfn	pointer
==	O
NULL	O
)	O
return	O
(	O
FALSE	int
)	O
;	O
q	pointer
=	O
my_rindex	function
(	O
pfn	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
q	pointer
==	O
NULL	O
)	O
q	pointer
=	O
&	O
pfn	pointer
[	O
-	O
1	int
]	O
;	O
if	O
(	O
q	pointer
[	O
1	int
]	O
!=	O
's'	O
||	O
q	pointer
[	O
2	int
]	O
!=	O
'.'	O
)	O
{	O
usrerr	function
(	O
"bad file name \"%s\""	pointer
,	O
fn	pointer
)	O
;	O
free	function
(	O
pfn	pointer
)	O
;	O
return	O
(	O
FALSE	int
)	O
;	O
}	O
*	O
++	O
q	pointer
=	O
'p'	O
;	O
pfp	pointer
=	O
fopen	function
(	O
pfn	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
pfp	pointer
==	O
NULL	O
)	O
{	O
printf	function
(	O
"%12s: not being edited\n"	pointer
,	O
fn	pointer
)	O
;	O
free	function
(	O
pfn	pointer
)	O
;	O
return	O
(	O
FALSE	int
)	O
;	O
}	O
tfp	pointer
=	O
tmpfile	function
(	O
)	O
;	O
if	O
(	O
tfp	pointer
==	O
NULL	O
)	O
{	O
usrerr	function
(	O
"cannot create temporary file"	pointer
)	O
;	O
fclose	function
(	O
pfp	pointer
)	O
;	O
free	function
(	O
pfn	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
myname	pointer
=	O
username	function
(	O
)	O
;	O
while	O
(	O
(	O
pent	pointer
=	O
getpfent	function
(	O
pfp	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
pent	pointer
->	O
p_user	pointer
,	O
myname	pointer
)	O
==	O
0	int
)	O
{	O
delete	char
=	O
TRUE	int
;	O
}	O
else	O
{	O
putpfent	function
(	O
pent	pointer
,	O
tfp	pointer
)	O
;	O
others	char
++	O
;	O
}	O
}	O
if	O
(	O
delete	char
)	O
{	O
extern	O
int	O
errno	O
;	O
cp	pointer
=	O
tail	function
(	O
pfn	pointer
)	O
;	O
if	O
(	O
'p'	O
==	O
cp	pointer
[	O
0	int
]	O
&&	O
'.'	O
==	O
cp	pointer
[	O
1	int
]	O
)	O
{	O
cp	pointer
+=	O
2	int
;	O
}	O
errno	O
=	O
0	int
;	O
if	O
(	O
access	function
(	O
cp	pointer
,	O
0	int
)	O
<	O
0	int
&&	O
errno	O
!=	O
ENOENT	int
)	O
goto	O
bad	O
;	O
if	O
(	O
errno	O
==	O
0	int
)	O
if	O
(	O
access	function
(	O
"."	pointer
,	O
2	int
)	O
<	O
0	int
)	O
{	O
bad	O
:	O
printf	function
(	O
"%12s: can't remove\n"	pointer
,	O
cp	pointer
)	O
;	O
fclose	function
(	O
tfp	pointer
)	O
;	O
fclose	function
(	O
pfp	pointer
)	O
;	O
free	function
(	O
pfn	pointer
)	O
;	O
return	O
(	O
FALSE	int
)	O
;	O
}	O
}	O
if	O
(	O
others	char
)	O
{	O
rewind	function
(	O
tfp	pointer
)	O
;	O
if	O
(	O
freopen	function
(	O
pfn	pointer
,	O
"w"	pointer
,	O
pfp	pointer
)	O
==	O
NULL	O
)	O
{	O
usrerr	function
(	O
"cannot create \"%s\""	pointer
,	O
pfn	pointer
)	O
;	O
free	function
(	O
pfn	pointer
)	O
;	O
return	O
(	O
FALSE	int
)	O
;	O
}	O
while	O
(	O
fgets	function
(	O
buf	array
,	O
sizeof	O
buf	array
,	O
tfp	pointer
)	O
!=	O
NULL	O
)	O
fputs	function
(	O
buf	array
,	O
pfp	pointer
)	O
;	O
}	O
else	O
{	O
unlink	function
(	O
pfn	pointer
)	O
;	O
}	O
fclose	function
(	O
tfp	pointer
)	O
;	O
fclose	function
(	O
pfp	pointer
)	O
;	O
if	O
(	O
delete	char
)	O
{	O
if	O
(	O
unlink	function
(	O
cp	pointer
)	O
>=	O
0	int
)	O
printf	function
(	O
"%12s: removed\n"	pointer
,	O
cp	pointer
)	O
;	O
free	function
(	O
pfn	pointer
)	O
;	O
return	O
(	O
TRUE	int
)	O
;	O
}	O
else	O
{	O
printf	function
(	O
"%12s: not being edited by you\n"	pointer
,	O
fn	pointer
)	O
;	O
free	function
(	O
pfn	pointer
)	O
;	O
return	O
(	O
FALSE	int
)	O
;	O
}	O
}	O
int	O
dodiff	function
(	O
char	O
*	O
getv	array
[	O
]	O
,	O
const	O
char	O
*	O
gfile	pointer
)	O
{	O
int	O
pipev	array
[	O
2	int
]	O
;	O
int	O
rval	pointer
;	O
register	O
int	O
pid	int
;	O
auto	O
int	O
st	int
;	O
extern	O
int	O
errno	O
;	O
printf	function
(	O
"\n------- %s -------\n"	pointer
,	O
gfile	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
pipe	function
(	O
pipev	array
)	O
<	O
0	int
)	O
{	O
syserr	function
(	O
"dodiff: pipe failed"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
if	O
(	O
(	O
pid	int
=	O
do_fork	function
(	O
)	O
)	O
<	O
0	int
)	O
{	O
syserr	function
(	O
"dodiff: fork failed"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
else	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
OutFile	int
=	O
pipev	array
[	O
1	int
]	O
;	O
close	pointer
(	O
pipev	array
[	O
0	int
]	O
)	O
;	O
rval	pointer
=	O
command	function
(	O
&	O
getv	array
[	O
1	int
]	O
,	O
TRUE	int
,	O
"get:rcixt -s -k -p"	pointer
)	O
;	O
childwait	function
(	O
pid	int
,	O
&	O
st	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
close	pointer
(	O
pipev	array
[	O
1	int
]	O
)	O
<	O
0	int
||	O
close	pointer
(	O
0	int
)	O
<	O
0	int
||	O
dup	function
(	O
pipev	array
[	O
0	int
]	O
)	O
!=	O
0	int
||	O
close	pointer
(	O
pipev	array
[	O
0	int
]	O
)	O
<	O
0	int
)	O
{	O
syserr	function
(	O
"dodiff: failed to set up the 'diff' end of the pipe"	pointer
)	O
;	O
exit	function
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
command	function
(	O
&	O
getv	array
[	O
1	int
]	O
,	O
FALSE	int
,	O
"-diff:elsfhbCunaBdHpqsvwyD"	pointer
)	O
;	O
}	O
return	O
rval	pointer
;	O
}	O
const	O
char	O
*	O
tail	function
(	O
register	O
const	O
char	O
*	O
fn	pointer
)	O
{	O
register	O
const	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
fn	pointer
;	O
*	O
p	pointer
!=	O
0	int
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
==	O
'/'	O
&&	O
p	pointer
[	O
1	int
]	O
!=	O
'\0'	O
&&	O
p	pointer
[	O
1	int
]	O
!=	O
'/'	O
)	O
fn	pointer
=	O
&	O
p	pointer
[	O
1	int
]	O
;	O
return	O
fn	pointer
;	O
}	O
char	O
*	O
tail_nc	function
(	O
register	O
char	O
*	O
fn	pointer
)	O
{	O
register	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
fn	pointer
;	O
*	O
p	pointer
!=	O
0	int
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
==	O
'/'	O
&&	O
p	pointer
[	O
1	int
]	O
!=	O
'\0'	O
&&	O
p	pointer
[	O
1	int
]	O
!=	O
'/'	O
)	O
fn	pointer
=	O
&	O
p	pointer
[	O
1	int
]	O
;	O
return	O
fn	pointer
;	O
}	O
const	O
struct	O
pfile	struct
*	O
getpfent	function
(	O
FILE	struct
*	O
pfp	pointer
)	O
{	O
static	O
struct	O
pfile	struct
ent	struct
;	O
static	O
char	O
buf	array
[	O
PFILELG	int
]	O
;	O
register	O
char	O
*	O
p	pointer
;	O
if	O
(	O
fgets	function
(	O
buf	array
,	O
sizeof	O
buf	array
,	O
pfp	pointer
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
ent	struct
.	O
p_osid	pointer
=	O
p	pointer
=	O
buf	array
;	O
ent	struct
.	O
p_nsid	pointer
=	O
p	pointer
=	O
nextfield	function
(	O
p	pointer
)	O
;	O
ent	struct
.	O
p_user	pointer
=	O
p	pointer
=	O
nextfield	function
(	O
p	pointer
)	O
;	O
ent	struct
.	O
p_date	pointer
=	O
p	pointer
=	O
nextfield	function
(	O
p	pointer
)	O
;	O
ent	struct
.	O
p_time	pointer
=	O
p	pointer
=	O
nextfield	function
(	O
p	pointer
)	O
;	O
ent	struct
.	O
p_aux	pointer
=	O
p	pointer
=	O
nextfield	function
(	O
p	pointer
)	O
;	O
return	O
&	O
ent	struct
;	O
}	O
char	O
*	O
nextfield	function
(	O
register	O
char	O
*	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
==	O
NULL	O
||	O
*	O
p	pointer
==	O
'\0'	O
)	O
return	O
NULL	O
;	O
while	O
(	O
*	O
p	pointer
!=	O
' '	O
&&	O
*	O
p	pointer
!=	O
'\n'	O
&&	O
*	O
p	pointer
!=	O
'\0'	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
||	O
*	O
p	pointer
==	O
'\0'	O
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
NULL	O
;	O
}	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
return	O
p	pointer
;	O
}	O
void	O
putpfent	function
(	O
register	O
const	O
struct	O
pfile	struct
*	O
pf	pointer
,	O
register	O
FILE	struct
*	O
f	pointer
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"%s %s %s %s %s"	pointer
,	O
pf	pointer
->	O
p_osid	pointer
,	O
pf	pointer
->	O
p_nsid	pointer
,	O
pf	pointer
->	O
p_user	pointer
,	O
pf	pointer
->	O
p_date	pointer
,	O
pf	pointer
->	O
p_time	pointer
)	O
;	O
if	O
(	O
pf	pointer
->	O
p_aux	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
f	pointer
,	O
" %s"	pointer
,	O
pf	pointer
->	O
p_aux	pointer
)	O
;	O
else	O
fprintf	function
(	O
f	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
void	O
usrerr	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	pointer
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n%s: "	pointer
,	O
program_name	pointer
)	O
;	O
va_start	O
(	O
ap	pointer
,	O
fmt	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	pointer
)	O
;	O
va_end	O
(	O
ap	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
void	O
syserr	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
extern	O
int	O
errno	O
;	O
va_list	array
ap	pointer
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n%s SYSERR: "	pointer
,	O
program_name	pointer
)	O
;	O
va_start	O
(	O
ap	pointer
,	O
fmt	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	pointer
)	O
;	O
va_end	O
(	O
ap	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
if	O
(	O
errno	O
==	O
0	int
)	O
{	O
exit	function
(	O
CSSC_EX_SOFTWARE	int
)	O
;	O
}	O
else	O
{	O
perror	function
(	O
NULL	O
)	O
;	O
exit	function
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
}	O
const	O
char	O
*	O
username	function
(	O
void	O
)	O
{	O
const	O
struct	O
passwd	struct
*	O
pw	pointer
;	O
pw	pointer
=	O
getpwuid	function
(	O
getuid	function
(	O
)	O
)	O
;	O
if	O
(	O
pw	pointer
==	O
NULL	O
)	O
{	O
syserr	function
(	O
"Who are you?\n"	pointer
"You don't seem to have an entry in the user database "	pointer
"(/etc/passwd) (uid=%d)"	pointer
,	O
(	O
int	O
)	O
getuid	function
(	O
)	O
)	O
;	O
exit	function
(	O
CSSC_EX_OSERR	int
)	O
;	O
}	O
return	O
(	O
pw	pointer
->	O
pw_name	pointer
)	O
;	O
}	O
static	O
char	O
*	O
gstrcat	function
(	O
char	O
*	O
to	pointer
,	O
const	O
char	O
*	O
from	pointer
,	O
size_t	long
length	long
)	O
{	O
if	O
(	O
strlen	function
(	O
from	pointer
)	O
+	O
strlen	function
(	O
to	pointer
)	O
>=	O
length	long
)	O
{	O
gstrbotch	function
(	O
to	pointer
,	O
from	pointer
)	O
;	O
}	O
return	O
(	O
strcat	function
(	O
to	pointer
,	O
from	pointer
)	O
)	O
;	O
}	O
static	O
char	O
*	O
gstrncat	function
(	O
char	O
*	O
to	pointer
,	O
const	O
char	O
*	O
from	pointer
,	O
size_t	long
n	long
,	O
size_t	long
length	long
)	O
{	O
if	O
(	O
n	long
+	O
strlen	function
(	O
to	pointer
)	O
>=	O
length	long
)	O
{	O
gstrbotch	function
(	O
to	pointer
,	O
from	pointer
)	O
;	O
}	O
return	O
strncat	function
(	O
to	pointer
,	O
from	pointer
,	O
n	long
)	O
;	O
}	O
static	O
char	O
*	O
gstrcpy	function
(	O
char	O
*	O
to	pointer
,	O
const	O
char	O
*	O
from	pointer
,	O
size_t	long
length	long
)	O
{	O
if	O
(	O
strlen	function
(	O
from	pointer
)	O
>=	O
length	long
)	O
{	O
gstrbotch	function
(	O
from	pointer
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
return	O
strcpy	function
(	O
to	pointer
,	O
from	pointer
)	O
;	O
}	O
static	O
void	O
gstrbotch	function
(	O
const	O
char	O
*	O
str1	pointer
,	O
const	O
char	O
*	O
str2	pointer
)	O
{	O
usrerr	function
(	O
"Filename(s) too long: %s %s"	pointer
,	O
(	O
str1	pointer
?	O
str1	pointer
:	O
""	pointer
)	O
,	O
(	O
str2	pointer
?	O
str2	pointer
:	O
""	pointer
)	O
)	O
;	O
exit	function
(	O
CSSC_EX_SOFTWARE	int
)	O
;	O
}	O
static	O
void	O
gstrbotchn	function
(	O
int	O
navail	int
,	O
const	O
char	O
*	O
str1	pointer
,	O
int	O
len1	int
,	O
const	O
char	O
*	O
str2	pointer
,	O
int	O
len2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Filename%s too long: "	pointer
,	O
(	O
str1	pointer
&&	O
str2	pointer
)	O
?	O
"s"	pointer
:	O
""	pointer
)	O
;	O
if	O
(	O
str1	pointer
)	O
{	O
fwrite	function
(	O
str1	pointer
,	O
len1	int
,	O
1	int
,	O
stderr	pointer
)	O
;	O
putc	function
(	O
' '	O
,	O
stderr	pointer
)	O
;	O
}	O
if	O
(	O
str2	pointer
)	O
{	O
fwrite	function
(	O
str2	pointer
,	O
len2	int
,	O
1	int
,	O
stderr	pointer
)	O
;	O
}	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Only %d characters available.\n"	pointer
,	O
navail	int
)	O
;	O
exit	function
(	O
CSSC_EX_SOFTWARE	int
)	O
;	O
}	O
