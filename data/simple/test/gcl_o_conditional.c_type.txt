object	O
sLotherwise	int
;	O
static	O
void	O
FFN	function
(	O
Fif	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
||	O
endp	function
(	O
MMcdr	function
(	O
form	int
)	O
)	O
)	O
FEtoo_few_argumentsF	function
(	O
form	int
)	O
;	O
if	O
(	O
!	O
endp	function
(	O
MMcddr	function
(	O
form	int
)	O
)	O
&&	O
!	O
endp	function
(	O
MMcdddr	function
(	O
form	int
)	O
)	O
)	O
FEtoo_many_argumentsF	function
(	O
form	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
form	int
)	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
==	O
Cnil	O
)	O
if	O
(	O
endp	function
(	O
MMcddr	function
(	O
form	int
)	O
)	O
)	O
{	O
vs_top	O
=	O
vs_base	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcaddr	function
(	O
form	int
)	O
)	O
;	O
}	O
else	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcadr	function
(	O
form	int
)	O
)	O
;	O
}	O
}	O
static	O
void	O
FFN	function
(	O
Fcond	int
)	O
(	O
object	O
args	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
object	O
clause	O
;	O
object	O
conseq	O
;	O
while	O
(	O
!	O
endp	function
(	O
args	int
)	O
)	O
{	O
clause	O
=	O
MMcar	function
(	O
args	int
)	O
;	O
if	O
(	O
type_of	function
(	O
clause	O
)	O
!=	O
t_cons	O
)	O
FEerror	function
(	O
"~S is an illegal COND clause."	pointer
,	O
1	int
,	O
clause	O
)	O
;	O
eval	function
(	O
MMcar	function
(	O
clause	O
)	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
!=	O
Cnil	O
)	O
{	O
conseq	O
=	O
MMcdr	function
(	O
clause	O
)	O
;	O
if	O
(	O
endp	function
(	O
conseq	O
)	O
)	O
{	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
return	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
conseq	O
)	O
)	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcar	function
(	O
conseq	O
)	O
)	O
;	O
conseq	O
=	O
MMcdr	function
(	O
conseq	O
)	O
;	O
}	O
return	O
;	O
}	O
vs_top	O
=	O
top	O
;	O
args	int
=	O
MMcdr	function
(	O
args	int
)	O
;	O
}	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fcase	int
)	O
(	O
object	O
arg	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
object	O
clause	O
;	O
object	O
key	O
;	O
object	O
conseq	O
;	O
if	O
(	O
endp	function
(	O
arg	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
arg	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
arg	int
)	O
)	O
;	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
arg	int
=	O
MMcdr	function
(	O
arg	int
)	O
;	O
while	O
(	O
!	O
endp	function
(	O
arg	int
)	O
)	O
{	O
clause	O
=	O
MMcar	function
(	O
arg	int
)	O
;	O
if	O
(	O
type_of	function
(	O
clause	O
)	O
!=	O
t_cons	O
)	O
FEerror	function
(	O
"~S is an illegal CASE clause."	pointer
,	O
1	int
,	O
clause	O
)	O
;	O
key	O
=	O
MMcar	function
(	O
clause	O
)	O
;	O
conseq	O
=	O
MMcdr	function
(	O
clause	O
)	O
;	O
if	O
(	O
type_of	function
(	O
key	O
)	O
==	O
t_cons	O
)	O
do	O
{	O
if	O
(	O
eql	function
(	O
MMcar	function
(	O
key	O
)	O
,	O
top	O
[	O
0	int
]	O
)	O
)	O
goto	O
FOUND	O
;	O
key	O
=	O
MMcdr	function
(	O
key	O
)	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
key	O
)	O
)	O
;	O
else	O
if	O
(	O
key	O
==	O
Cnil	O
)	O
;	O
else	O
if	O
(	O
key	O
==	O
Ct	O
||	O
key	O
==	O
sLotherwise	int
||	O
eql	function
(	O
key	O
,	O
top	O
[	O
0	int
]	O
)	O
)	O
goto	O
FOUND	O
;	O
arg	int
=	O
MMcdr	function
(	O
arg	int
)	O
;	O
}	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
return	O
;	O
FOUND	O
:	O
if	O
(	O
endp	function
(	O
conseq	O
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcar	function
(	O
conseq	O
)	O
)	O
;	O
conseq	O
=	O
MMcdr	function
(	O
conseq	O
)	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
conseq	O
)	O
)	O
;	O
return	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fwhen	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
form	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
form	int
)	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
==	O
Cnil	O
)	O
{	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
{	O
form	int
=	O
MMcdr	function
(	O
form	int
)	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcar	function
(	O
form	int
)	O
)	O
;	O
form	int
=	O
MMcdr	function
(	O
form	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
form	int
)	O
)	O
;	O
}	O
}	O
static	O
void	O
FFN	function
(	O
Funless	int
)	O
(	O
object	O
form	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
FEtoo_few_argumentsF	function
(	O
form	int
)	O
;	O
eval	function
(	O
MMcar	function
(	O
form	int
)	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
==	O
Cnil	O
)	O
{	O
vs_top	O
=	O
top	O
;	O
form	int
=	O
MMcdr	function
(	O
form	int
)	O
;	O
if	O
(	O
endp	function
(	O
form	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
else	O
do	O
{	O
vs_top	O
=	O
top	O
;	O
eval	function
(	O
MMcar	function
(	O
form	int
)	O
)	O
;	O
form	int
=	O
MMcdr	function
(	O
form	int
)	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
form	int
)	O
)	O
;	O
}	O
else	O
{	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
}	O
void	O
gcl_init_conditional	function
(	O
void	O
)	O
{	O
make_special_form	function
(	O
"IF"	pointer
,	O
Fif	int
)	O
;	O
make_special_form	function
(	O
"COND"	pointer
,	O
Fcond	int
)	O
;	O
make_special_form	function
(	O
"CASE"	pointer
,	O
Fcase	int
)	O
;	O
make_special_form	function
(	O
"WHEN"	pointer
,	O
Fwhen	int
)	O
;	O
make_special_form	function
(	O
"UNLESS"	pointer
,	O
Funless	int
)	O
;	O
sLotherwise	int
=	O
make_ordinary	function
(	O
"OTHERWISE"	pointer
)	O
;	O
enter_mark_origin	function
(	O
&	O
sLotherwise	int
)	O
;	O
}	O
