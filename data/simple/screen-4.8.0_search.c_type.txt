extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
struct	O
win	struct
*	O
fore	pointer
;	O
int	O
search_ic	int
;	O
static	O
int	O
matchword	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
searchend	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
backsearchend	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
void	O
Search	function
(	O
dir	pointer
)	O
int	O
dir	pointer
;	O
{	O
struct	O
markdata	struct
*	O
markdata	struct
;	O
if	O
(	O
dir	pointer
==	O
0	int
)	O
{	O
markdata	struct
=	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
if	O
(	O
markdata	struct
->	O
isdir	int
>	O
0	int
)	O
searchend	function
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
else	O
if	O
(	O
markdata	struct
->	O
isdir	int
<	O
0	int
)	O
backsearchend	function
(	O
0	int
,	O
0	int
,	O
NULL	O
)	O
;	O
else	O
LMsg	function
(	O
0	int
,	O
"No previous pattern"	pointer
)	O
;	O
}	O
else	O
Input	function
(	O
(	O
dir	pointer
>	O
0	int
?	O
"/"	pointer
:	O
"?"	pointer
)	O
,	O
sizeof	O
(	O
markdata	struct
->	O
isstr	array
)	O
-	O
1	int
,	O
INP_COOKED	int
,	O
(	O
dir	pointer
>	O
0	int
?	O
searchend	function
:	O
backsearchend	function
)	O
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
static	O
void	O
searchend	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
int	O
x	int
=	O
0	int
,	O
sx	int
,	O
ex	int
,	O
y	int
;	O
struct	O
markdata	struct
*	O
markdata	struct
;	O
struct	O
win	struct
*	O
p	pointer
;	O
markdata	struct
=	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
p	pointer
=	O
markdata	struct
->	O
md_window	pointer
;	O
markdata	struct
->	O
isdir	int
=	O
1	int
;	O
if	O
(	O
len	int
)	O
strcpy	function
(	O
markdata	struct
->	O
isstr	array
,	O
buf	pointer
)	O
;	O
sx	int
=	O
markdata	struct
->	O
cx	int
+	O
1	int
;	O
ex	int
=	O
flayer	pointer
->	O
l_width	int
-	O
1	int
;	O
for	O
(	O
y	int
=	O
markdata	struct
->	O
cy	int
;	O
y	int
<	O
p	pointer
->	O
w_histheight	int
+	O
flayer	pointer
->	O
l_height	int
;	O
y	int
++	O
,	O
sx	int
=	O
0	int
)	O
{	O
if	O
(	O
(	O
x	int
=	O
matchword	function
(	O
markdata	struct
->	O
isstr	array
,	O
y	int
,	O
sx	int
,	O
ex	int
)	O
)	O
>=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
y	int
>=	O
p	pointer
->	O
w_histheight	int
+	O
flayer	pointer
->	O
l_height	int
)	O
{	O
LGotoPos	function
(	O
flayer	pointer
,	O
markdata	struct
->	O
cx	int
,	O
W2D	O
(	O
markdata	struct
->	O
cy	int
)	O
)	O
;	O
LMsg	function
(	O
0	int
,	O
"Pattern not found"	pointer
)	O
;	O
}	O
else	O
revto	function
(	O
x	int
,	O
y	int
)	O
;	O
}	O
static	O
void	O
backsearchend	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
int	O
sx	int
,	O
ex	int
,	O
x	int
=	O
-	O
1	int
,	O
y	int
;	O
struct	O
markdata	struct
*	O
markdata	struct
;	O
markdata	struct
=	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
markdata	struct
->	O
isdir	int
=	O
-	O
1	int
;	O
if	O
(	O
len	int
)	O
strcpy	function
(	O
markdata	struct
->	O
isstr	array
,	O
buf	pointer
)	O
;	O
ex	int
=	O
markdata	struct
->	O
cx	int
-	O
1	int
;	O
for	O
(	O
y	int
=	O
markdata	struct
->	O
cy	int
;	O
y	int
>=	O
0	int
;	O
y	int
--	O
,	O
ex	int
=	O
flayer	pointer
->	O
l_width	int
-	O
1	int
)	O
{	O
sx	int
=	O
0	int
;	O
while	O
(	O
(	O
sx	int
=	O
matchword	function
(	O
markdata	struct
->	O
isstr	array
,	O
y	int
,	O
sx	int
,	O
ex	int
)	O
)	O
>=	O
0	int
)	O
x	int
=	O
sx	int
++	O
;	O
if	O
(	O
x	int
>=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
y	int
<	O
0	int
)	O
{	O
LGotoPos	function
(	O
flayer	pointer
,	O
markdata	struct
->	O
cx	int
,	O
W2D	O
(	O
markdata	struct
->	O
cy	int
)	O
)	O
;	O
LMsg	function
(	O
0	int
,	O
"Pattern not found"	pointer
)	O
;	O
}	O
else	O
revto	function
(	O
x	int
,	O
y	int
)	O
;	O
}	O
static	O
int	O
matchword	function
(	O
pattern	pointer
,	O
y	int
,	O
sx	int
,	O
ex	int
)	O
char	O
*	O
pattern	pointer
;	O
int	O
y	int
,	O
sx	int
,	O
ex	int
;	O
{	O
unsigned	O
char	O
*	O
ip	pointer
,	O
*	O
cp	pointer
,	O
*	O
pp	pointer
,	O
*	O
cpe	pointer
;	O
int	O
cy	int
;	O
fore	pointer
=	O
(	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
)	O
->	O
md_window	pointer
;	O
for	O
(	O
;	O
sx	int
<=	O
ex	int
;	O
sx	int
++	O
)	O
{	O
cy	int
=	O
y	int
;	O
cp	pointer
=	O
WIN	O
(	O
cy	int
)	O
->	O
image	char
+	O
sx	int
;	O
cpe	pointer
=	O
WIN	O
(	O
cy	int
)	O
->	O
image	char
+	O
flayer	pointer
->	O
l_width	int
;	O
pp	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
pattern	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
*	O
cp	pointer
!=	O
*	O
pp	pointer
)	O
if	O
(	O
!	O
search_ic	int
||	O
(	O
(	O
*	O
cp	pointer
^	O
*	O
pp	pointer
)	O
&	O
0xdf	int
)	O
||	O
(	O
*	O
cp	pointer
|	O
0x20	int
)	O
<	O
'a'	O
||	O
(	O
*	O
cp	pointer
|	O
0x20	int
)	O
>	O
'z'	O
)	O
break	O
;	O
cp	pointer
++	O
;	O
pp	pointer
++	O
;	O
if	O
(	O
*	O
pp	pointer
==	O
0	int
)	O
return	O
sx	int
;	O
if	O
(	O
cp	pointer
==	O
cpe	pointer
)	O
{	O
if	O
(	O
*	O
cp	pointer
==	O
' '	O
||	O
cy	int
>=	O
fore	pointer
->	O
w_histheight	int
+	O
flayer	pointer
->	O
l_height	int
-	O
1	int
)	O
break	O
;	O
cy	int
++	O
;	O
cp	pointer
=	O
WIN	O
(	O
cy	int
)	O
->	O
image	char
;	O
cpe	pointer
=	O
WIN	O
(	O
cy	int
)	O
->	O
image	char
+	O
flayer	pointer
->	O
l_width	int
;	O
}	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
char	O
*	O
isprompts	array
[	O
]	O
=	O
{	O
"I-search backward: "	pointer
,	O
"failing I-search backward: "	pointer
,	O
"I-search: "	pointer
,	O
"failing I-search: "	pointer
}	O
;	O
static	O
int	O
is_redo	function
__P	O
(	O
(	O
struct	O
markdata	struct
*	O
)	O
)	O
;	O
static	O
void	O
is_process	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
is_bm	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
is_bm	function
(	O
str	pointer
,	O
l	int
,	O
p	pointer
,	O
end	int
,	O
dir	pointer
)	O
char	O
*	O
str	pointer
;	O
int	O
l	int
,	O
p	pointer
,	O
end	int
,	O
dir	pointer
;	O
{	O
int	O
tab	array
[	O
256	int
]	O
;	O
int	O
i	int
,	O
q	int
;	O
unsigned	O
char	O
*	O
s	pointer
,	O
c	char
;	O
int	O
w	int
=	O
flayer	pointer
->	O
l_width	int
;	O
fore	pointer
=	O
(	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_next	pointer
->	O
l_data	pointer
)	O
->	O
md_window	pointer
;	O
debug2	O
(	O
"is_bm: searching for %s len %d\n"	pointer
,	O
str	pointer
,	O
l	int
)	O
;	O
debug3	O
(	O
"start at %d end %d dir %d\n"	pointer
,	O
p	pointer
,	O
end	int
,	O
dir	pointer
)	O
;	O
if	O
(	O
p	pointer
<	O
0	int
||	O
p	pointer
+	O
l	int
>	O
end	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
l	int
==	O
0	int
)	O
return	O
p	pointer
;	O
if	O
(	O
dir	pointer
<	O
0	int
)	O
str	pointer
+=	O
l	int
-	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
tab	array
[	O
i	int
]	O
=	O
l	int
*	O
dir	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
l	int
-	O
1	int
;	O
i	int
++	O
,	O
str	pointer
+=	O
dir	pointer
)	O
{	O
q	int
=	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
str	pointer
;	O
tab	array
[	O
q	int
]	O
=	O
(	O
l	int
-	O
1	int
-	O
i	int
)	O
*	O
dir	pointer
;	O
if	O
(	O
search_ic	int
&&	O
(	O
q	int
|	O
0x20	int
)	O
>=	O
'a'	O
&&	O
(	O
(	O
q	int
|	O
0x20	int
)	O
<=	O
'z'	O
)	O
)	O
tab	array
[	O
q	int
^	O
0x20	int
]	O
=	O
(	O
l	int
-	O
1	int
-	O
i	int
)	O
*	O
dir	pointer
;	O
}	O
if	O
(	O
dir	pointer
>	O
0	int
)	O
p	pointer
+=	O
l	int
-	O
1	int
;	O
debug1	O
(	O
"first char to match: %c\n"	pointer
,	O
*	O
str	pointer
)	O
;	O
while	O
(	O
p	pointer
>=	O
0	int
&&	O
p	pointer
<	O
end	int
)	O
{	O
q	int
=	O
p	pointer
;	O
s	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
str	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
;	O
)	O
{	O
c	char
=	O
(	O
WIN	O
(	O
q	int
/	O
w	int
)	O
)	O
->	O
image	char
[	O
q	int
%	O
w	int
]	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
p	pointer
+=	O
tab	array
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
c	char
]	O
;	O
if	O
(	O
c	char
!=	O
*	O
s	pointer
)	O
if	O
(	O
!	O
search_ic	int
||	O
(	O
(	O
c	char
^	O
*	O
s	pointer
)	O
&	O
0xdf	int
)	O
||	O
(	O
c	char
|	O
0x20	int
)	O
<	O
'a'	O
||	O
(	O
c	char
|	O
0x20	int
)	O
>	O
'z'	O
)	O
break	O
;	O
q	int
-=	O
dir	pointer
;	O
s	pointer
-=	O
dir	pointer
;	O
if	O
(	O
++	O
i	int
==	O
l	int
)	O
return	O
q	int
+	O
(	O
dir	pointer
>	O
0	int
?	O
1	int
:	O
-	O
l	int
)	O
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
is_process	function
(	O
p	pointer
,	O
n	int
,	O
data	pointer
)	O
char	O
*	O
p	pointer
;	O
int	O
n	int
;	O
char	O
*	O
data	pointer
;	O
{	O
int	O
pos	int
,	O
x	int
,	O
y	int
,	O
dir	pointer
;	O
struct	O
markdata	struct
*	O
markdata	struct
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
ASSERT	O
(	O
p	pointer
)	O
;	O
markdata	struct
=	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_next	pointer
->	O
l_data	pointer
;	O
pos	int
=	O
markdata	struct
->	O
cx	int
+	O
markdata	struct
->	O
cy	int
*	O
flayer	pointer
->	O
l_width	int
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
markdata	struct
->	O
cx	int
,	O
W2D	O
(	O
markdata	struct
->	O
cy	int
)	O
)	O
;	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'\007'	O
:	O
pos	int
=	O
markdata	struct
->	O
isstartpos	int
;	O
case	O
'\033'	O
:	O
*	O
p	pointer
=	O
0	int
;	O
break	O
;	O
case	O
'\013'	O
:	O
case	O
'\027'	O
:	O
markdata	struct
->	O
isistrl	int
=	O
1	int
;	O
case	O
'\b'	O
:	O
case	O
'\177'	O
:	O
if	O
(	O
markdata	struct
->	O
isistrl	int
==	O
0	int
)	O
return	O
;	O
markdata	struct
->	O
isistrl	int
--	O
;	O
pos	int
=	O
is_redo	function
(	O
markdata	struct
)	O
;	O
*	O
p	pointer
=	O
'\b'	O
;	O
break	O
;	O
case	O
'\023'	O
:	O
case	O
'\022'	O
:	O
if	O
(	O
markdata	struct
->	O
isistrl	int
>=	O
(	O
int	O
)	O
sizeof	O
(	O
markdata	struct
->	O
isistr	array
)	O
)	O
return	O
;	O
dir	pointer
=	O
(	O
*	O
p	pointer
==	O
'\023'	O
)	O
?	O
1	int
:	O
-	O
1	int
;	O
pos	int
+=	O
dir	pointer
;	O
if	O
(	O
markdata	struct
->	O
isdir	int
==	O
dir	pointer
&&	O
markdata	struct
->	O
isistrl	int
==	O
0	int
)	O
{	O
strcpy	function
(	O
markdata	struct
->	O
isistr	array
,	O
markdata	struct
->	O
isstr	array
)	O
;	O
markdata	struct
->	O
isistrl	int
=	O
markdata	struct
->	O
isstrl	int
=	O
strlen	function
(	O
markdata	struct
->	O
isstr	array
)	O
;	O
break	O
;	O
}	O
markdata	struct
->	O
isdir	int
=	O
dir	pointer
;	O
markdata	struct
->	O
isistr	array
[	O
markdata	struct
->	O
isistrl	int
++	O
]	O
=	O
*	O
p	pointer
;	O
break	O
;	O
default	O
:	O
if	O
(	O
*	O
p	pointer
<	O
' '	O
||	O
markdata	struct
->	O
isistrl	int
>=	O
(	O
int	O
)	O
sizeof	O
(	O
markdata	struct
->	O
isistr	array
)	O
||	O
markdata	struct
->	O
isstrl	int
>=	O
(	O
int	O
)	O
sizeof	O
(	O
markdata	struct
->	O
isstr	array
)	O
-	O
1	int
)	O
return	O
;	O
markdata	struct
->	O
isstr	array
[	O
markdata	struct
->	O
isstrl	int
++	O
]	O
=	O
*	O
p	pointer
;	O
markdata	struct
->	O
isistr	array
[	O
markdata	struct
->	O
isistrl	int
++	O
]	O
=	O
*	O
p	pointer
;	O
markdata	struct
->	O
isstr	array
[	O
markdata	struct
->	O
isstrl	int
]	O
=	O
0	int
;	O
debug2	O
(	O
"New char: %c - left %d\n"	pointer
,	O
*	O
p	pointer
,	O
(	O
int	O
)	O
sizeof	O
(	O
markdata	struct
->	O
isistr	array
)	O
-	O
markdata	struct
->	O
isistrl	int
)	O
;	O
}	O
if	O
(	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
'\b'	O
)	O
pos	int
=	O
is_bm	function
(	O
markdata	struct
->	O
isstr	array
,	O
markdata	struct
->	O
isstrl	int
,	O
pos	int
,	O
flayer	pointer
->	O
l_width	int
*	O
(	O
markdata	struct
->	O
md_window	pointer
->	O
w_histheight	int
+	O
flayer	pointer
->	O
l_height	int
)	O
,	O
markdata	struct
->	O
isdir	int
)	O
;	O
if	O
(	O
pos	int
>=	O
0	int
)	O
{	O
x	int
=	O
pos	int
%	O
flayer	pointer
->	O
l_width	int
;	O
y	int
=	O
pos	int
/	O
flayer	pointer
->	O
l_width	int
;	O
LAY_CALL_UP	O
(	O
LayRedisplayLine	O
(	O
INPUTLINE	O
,	O
0	int
,	O
flayer	pointer
->	O
l_width	int
-	O
1	int
,	O
0	int
)	O
;	O
revto	function
(	O
x	int
,	O
y	int
)	O
;	O
if	O
(	O
W2D	O
(	O
markdata	struct
->	O
cy	int
)	O
==	O
INPUTLINE	O
)	O
revto_line	function
(	O
markdata	struct
->	O
cx	int
,	O
markdata	struct
->	O
cy	int
,	O
INPUTLINE	O
>	O
0	int
?	O
INPUTLINE	O
-	O
1	int
:	O
1	int
)	O
;	O
)	O
;	O
}	O
if	O
(	O
*	O
p	pointer
)	O
inp_setprompt	function
(	O
isprompts	array
[	O
markdata	struct
->	O
isdir	int
+	O
(	O
pos	int
<	O
0	int
)	O
+	O
1	int
]	O
,	O
markdata	struct
->	O
isstrl	int
?	O
markdata	struct
->	O
isstr	array
:	O
""	pointer
)	O
;	O
flayer	pointer
->	O
l_x	int
=	O
markdata	struct
->	O
cx	int
;	O
flayer	pointer
->	O
l_y	int
=	O
W2D	O
(	O
markdata	struct
->	O
cy	int
)	O
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
flayer	pointer
->	O
l_x	int
,	O
flayer	pointer
->	O
l_y	int
)	O
;	O
if	O
(	O
!	O
*	O
p	pointer
)	O
{	O
flayer	pointer
->	O
l_next	pointer
->	O
l_x	int
=	O
markdata	struct
->	O
cx	int
;	O
flayer	pointer
->	O
l_next	pointer
->	O
l_y	int
=	O
W2D	O
(	O
markdata	struct
->	O
cy	int
)	O
;	O
}	O
}	O
static	O
int	O
is_redo	function
(	O
markdata	struct
)	O
struct	O
markdata	struct
*	O
markdata	struct
;	O
{	O
int	O
i	int
,	O
pos	int
,	O
npos	int
,	O
dir	pointer
;	O
char	O
c	char
;	O
npos	int
=	O
pos	int
=	O
markdata	struct
->	O
isstartpos	int
;	O
dir	pointer
=	O
markdata	struct
->	O
isstartdir	int
;	O
markdata	struct
->	O
isstrl	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
markdata	struct
->	O
isistrl	int
;	O
i	int
++	O
)	O
{	O
c	char
=	O
markdata	struct
->	O
isistr	array
[	O
i	int
]	O
;	O
if	O
(	O
c	char
==	O
'\022'	O
)	O
pos	int
+=	O
(	O
dir	pointer
=	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
c	char
==	O
'\023'	O
)	O
pos	int
+=	O
(	O
dir	pointer
=	O
1	int
)	O
;	O
else	O
markdata	struct
->	O
isstr	array
[	O
markdata	struct
->	O
isstrl	int
++	O
]	O
=	O
c	char
;	O
if	O
(	O
pos	int
>=	O
0	int
)	O
{	O
npos	int
=	O
is_bm	function
(	O
markdata	struct
->	O
isstr	array
,	O
markdata	struct
->	O
isstrl	int
,	O
pos	int
,	O
flayer	pointer
->	O
l_width	int
*	O
(	O
markdata	struct
->	O
md_window	pointer
->	O
w_histheight	int
+	O
flayer	pointer
->	O
l_height	int
)	O
,	O
dir	pointer
)	O
;	O
if	O
(	O
npos	int
>=	O
0	int
)	O
pos	int
=	O
npos	int
;	O
}	O
}	O
markdata	struct
->	O
isstr	array
[	O
markdata	struct
->	O
isstrl	int
]	O
=	O
0	int
;	O
markdata	struct
->	O
isdir	int
=	O
dir	pointer
;	O
return	O
npos	int
;	O
}	O
void	O
ISearch	function
(	O
dir	pointer
)	O
int	O
dir	pointer
;	O
{	O
struct	O
markdata	struct
*	O
markdata	struct
;	O
markdata	struct
=	O
(	O
struct	O
markdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
markdata	struct
->	O
isdir	int
=	O
markdata	struct
->	O
isstartdir	int
=	O
dir	pointer
;	O
markdata	struct
->	O
isstartpos	int
=	O
markdata	struct
->	O
cx	int
+	O
markdata	struct
->	O
cy	int
*	O
flayer	pointer
->	O
l_width	int
;	O
markdata	struct
->	O
isistrl	int
=	O
markdata	struct
->	O
isstrl	int
=	O
0	int
;	O
if	O
(	O
W2D	O
(	O
markdata	struct
->	O
cy	int
)	O
==	O
INPUTLINE	O
)	O
revto_line	function
(	O
markdata	struct
->	O
cx	int
,	O
markdata	struct
->	O
cy	int
,	O
INPUTLINE	O
>	O
0	int
?	O
INPUTLINE	O
-	O
1	int
:	O
1	int
)	O
;	O
Input	function
(	O
isprompts	array
[	O
dir	pointer
+	O
1	int
]	O
,	O
sizeof	O
(	O
markdata	struct
->	O
isstr	array
)	O
-	O
1	int
,	O
INP_RAW	int
,	O
is_process	function
,	O
NULL	O
,	O
0	int
)	O
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
markdata	struct
->	O
cx	int
,	O
W2D	O
(	O
markdata	struct
->	O
cy	int
)	O
)	O
;	O
flayer	pointer
->	O
l_x	int
=	O
markdata	struct
->	O
cx	int
;	O
flayer	pointer
->	O
l_y	int
=	O
W2D	O
(	O
markdata	struct
->	O
cy	int
)	O
;	O
}	O
