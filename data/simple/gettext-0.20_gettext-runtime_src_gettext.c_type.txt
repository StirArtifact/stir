static	O
bool	bool
add_newline	bool
;	O
static	O
bool	bool
do_expand	bool
;	O
static	O
const	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"context"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
{	O
"domain"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"shell-script"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
const	O
char	O
*	O
expand_escape	function
(	O
const	O
char	O
*	O
str	pointer
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
optchar	int
;	O
const	O
char	O
*	O
msgid	pointer
;	O
bool	bool
do_help	bool
=	O
false	int
;	O
bool	bool
do_shell	bool
=	O
false	int
;	O
bool	bool
do_version	bool
=	O
false	int
;	O
const	O
char	O
*	O
domain	pointer
=	O
getenv	function
(	O
"TEXTDOMAIN"	pointer
)	O
;	O
const	O
char	O
*	O
domaindir	pointer
=	O
getenv	function
(	O
"TEXTDOMAINDIR"	pointer
)	O
;	O
const	O
char	O
*	O
context	pointer
=	O
NULL	O
;	O
add_newline	bool
=	O
true	int
;	O
do_expand	bool
=	O
false	int
;	O
set_program_name	function
(	O
argv	array
[	O
0	int
]	O
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
relocate	O
(	O
LOCALEDIR	O
)	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
atexit	function
(	O
close_stdout	function
)	O
;	O
while	O
(	O
(	O
optchar	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	array
,	O
"+c:d:eEhnsV"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
optchar	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'c'	O
:	O
context	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'd'	O
:	O
domain	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'e'	O
:	O
do_expand	bool
=	O
true	int
;	O
break	O
;	O
case	O
'E'	O
:	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'n'	O
:	O
add_newline	bool
=	O
false	int
;	O
break	O
;	O
case	O
's'	O
:	O
do_shell	bool
=	O
true	int
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	function
(	O
"%s (GNU %s) %s\n"	pointer
,	O
basename	function
(	O
program_name	pointer
)	O
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	pointer
)	O
,	O
"1995-2019"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Written by %s.\n"	pointer
)	O
,	O
proper_name	function
(	O
"Ulrich Drepper"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
usage	function
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
!	O
do_shell	bool
)	O
{	O
switch	O
(	O
argc	int
-	O
optind	int
)	O
{	O
default	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"too many arguments"	pointer
)	O
)	O
;	O
case	O
2	int
:	O
domain	pointer
=	O
argv	array
[	O
optind	int
++	O
]	O
;	O
case	O
1	int
:	O
break	O
;	O
case	O
0	int
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"missing arguments"	pointer
)	O
)	O
;	O
}	O
msgid	pointer
=	O
argv	array
[	O
optind	int
++	O
]	O
;	O
if	O
(	O
do_expand	bool
)	O
msgid	pointer
=	O
expand_escape	function
(	O
msgid	pointer
)	O
;	O
if	O
(	O
domain	pointer
==	O
NULL	O
||	O
domain	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
fputs	function
(	O
msgid	pointer
,	O
stdout	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
domaindir	pointer
!=	O
NULL	O
&&	O
domaindir	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
bindtextdomain	function
(	O
domain	pointer
,	O
domaindir	pointer
)	O
;	O
fputs	function
(	O
(	O
context	pointer
!=	O
NULL	O
?	O
dpgettext_expr	O
(	O
domain	pointer
,	O
context	pointer
,	O
msgid	pointer
)	O
:	O
dgettext	function
(	O
domain	pointer
,	O
msgid	pointer
)	O
)	O
,	O
stdout	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
if	O
(	O
domain	pointer
==	O
NULL	O
||	O
domain	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
domain	pointer
=	O
NULL	O
;	O
else	O
if	O
(	O
domaindir	pointer
!=	O
NULL	O
&&	O
domaindir	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
bindtextdomain	function
(	O
domain	pointer
,	O
domaindir	pointer
)	O
;	O
do	O
{	O
msgid	pointer
=	O
argv	array
[	O
optind	int
++	O
]	O
;	O
if	O
(	O
do_expand	bool
)	O
msgid	pointer
=	O
expand_escape	function
(	O
msgid	pointer
)	O
;	O
fputs	function
(	O
(	O
domain	pointer
==	O
NULL	O
?	O
msgid	pointer
:	O
context	pointer
!=	O
NULL	O
?	O
dpgettext_expr	O
(	O
domain	pointer
,	O
context	pointer
,	O
msgid	pointer
)	O
:	O
dgettext	function
(	O
domain	pointer
,	O
msgid	pointer
)	O
)	O
,	O
stdout	pointer
)	O
;	O
if	O
(	O
optind	int
<	O
argc	int
)	O
fputc	function
(	O
' '	O
,	O
stdout	pointer
)	O
;	O
}	O
while	O
(	O
optind	int
<	O
argc	int
)	O
;	O
}	O
if	O
(	O
add_newline	bool
)	O
fputc	function
(	O
'\n'	O
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION] [[TEXTDOMAIN] MSGID]\nor:    %s [OPTION] -s [MSGID]...\n"	pointer
)	O
,	O
program_name	pointer
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Display native language translation of a textual message.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  -d, --domain=TEXTDOMAIN   retrieve translated messages from TEXTDOMAIN\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -c, --context=CONTEXT     specify context for MSGID\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -e                        enable expansion of some escape sequences\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -n                        suppress trailing newline\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -E                        (ignored for compatibility)\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  [TEXTDOMAIN] MSGID        retrieve translated message corresponding\n                            to MSGID from TEXTDOMAIN\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Informative output:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -h, --help                display this help and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -V, --version             display version information and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"If the TEXTDOMAIN parameter is not given, the domain is determined from the\nenvironment variable TEXTDOMAIN.  If the message catalog is not found in the\nregular directory, another location can be specified with the environment\nvariable TEXTDOMAINDIR.\nWhen used with the -s option the program behaves like the 'echo' command.\nBut it does not simply copy its arguments to stdout.  Instead those messages\nfound in the selected catalog are translated.\nStandard search directory: %s\n"	pointer
)	O
,	O
getenv	function
(	O
"IN_HELP2MAN"	pointer
)	O
==	O
NULL	O
?	O
LOCALEDIR	O
:	O
"@localedir@"	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
expand_escape	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
retval	pointer
,	O
*	O
rp	pointer
;	O
const	O
char	O
*	O
cp	pointer
=	O
str	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
cp	pointer
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
cp	pointer
[	O
0	int
]	O
!=	O
'\\'	O
)	O
++	O
cp	pointer
;	O
if	O
(	O
cp	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
str	pointer
;	O
if	O
(	O
cp	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
return	O
str	pointer
;	O
if	O
(	O
strchr	function
(	O
"abcfnrtv\\01234567"	pointer
,	O
cp	pointer
[	O
1	int
]	O
)	O
!=	O
NULL	O
)	O
break	O
;	O
++	O
cp	pointer
;	O
}	O
retval	pointer
=	O
XNMALLOC	O
(	O
strlen	function
(	O
str	pointer
)	O
,	O
char	O
)	O
;	O
rp	pointer
=	O
retval	pointer
+	O
(	O
cp	pointer
-	O
str	pointer
)	O
;	O
memcpy	function
(	O
retval	pointer
,	O
str	pointer
,	O
cp	pointer
-	O
str	pointer
)	O
;	O
do	O
{	O
switch	O
(	O
*	O
++	O
cp	pointer
)	O
{	O
case	O
'a'	O
:	O
*	O
rp	pointer
++	O
=	O
'\a'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'b'	O
:	O
*	O
rp	pointer
++	O
=	O
'\b'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'c'	O
:	O
add_newline	bool
=	O
false	int
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'f'	O
:	O
*	O
rp	pointer
++	O
=	O
'\f'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'n'	O
:	O
*	O
rp	pointer
++	O
=	O
'\n'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
rp	pointer
++	O
=	O
'\r'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
rp	pointer
++	O
=	O
'\t'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'v'	O
:	O
*	O
rp	pointer
++	O
=	O
'\v'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'\\'	O
:	O
*	O
rp	pointer
=	O
'\\'	O
;	O
++	O
cp	pointer
;	O
break	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
{	O
int	O
ch	int
=	O
*	O
cp	pointer
++	O
-	O
'0'	O
;	O
if	O
(	O
*	O
cp	pointer
>=	O
'0'	O
&&	O
*	O
cp	pointer
<=	O
'7'	O
)	O
{	O
ch	int
*=	O
8	int
;	O
ch	int
+=	O
*	O
cp	pointer
++	O
-	O
'0'	O
;	O
if	O
(	O
*	O
cp	pointer
>=	O
'0'	O
&&	O
*	O
cp	pointer
<=	O
'7'	O
)	O
{	O
ch	int
*=	O
8	int
;	O
ch	int
+=	O
*	O
cp	pointer
++	O
-	O
'0'	O
;	O
}	O
}	O
*	O
rp	pointer
=	O
ch	int
;	O
}	O
break	O
;	O
default	O
:	O
*	O
rp	pointer
=	O
'\\'	O
;	O
break	O
;	O
}	O
while	O
(	O
cp	pointer
[	O
0	int
]	O
!=	O
'\0'	O
&&	O
cp	pointer
[	O
0	int
]	O
!=	O
'\\'	O
)	O
*	O
rp	pointer
++	O
=	O
*	O
cp	pointer
++	O
;	O
}	O
while	O
(	O
cp	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
;	O
*	O
rp	pointer
=	O
'\0'	O
;	O
return	O
(	O
const	O
char	O
*	O
)	O
retval	pointer
;	O
}	O
