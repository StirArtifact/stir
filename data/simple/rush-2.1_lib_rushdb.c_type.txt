mode_t	int
rushdb_umask	int
=	O
022	int
;	O
mode_t	int
rushdb_dir_mode	int
=	O
0777	int
;	O
mode_t	int
rushdb_file_mode	int
=	O
0666	int
;	O
static	O
char	O
rushdb_error_buffer	array
[	O
ERROR_BUFFER_SIZE	int
]	O
;	O
char	O
*	O
rushdb_error_string	pointer
=	O
rushdb_error_buffer	array
;	O
static	O
void	O
format_error	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
RUSH_PRINTFLIKE	O
(	O
1	int
,	O
2	int
)	O
;	O
static	O
void	O
format_error	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vsnprintf	function
(	O
rushdb_error_buffer	array
,	O
sizeof	O
(	O
rushdb_error_buffer	array
)	O
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
static	O
char	O
*	O
mkname	function
(	O
const	O
char	O
*	O
dir	enum
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
s	long
=	O
malloc	function
(	O
strlen	function
(	O
dir	enum
)	O
+	O
1	int
+	O
strlen	function
(	O
file	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
s	long
)	O
{	O
strcpy	function
(	O
s	long
,	O
dir	enum
)	O
;	O
strcat	function
(	O
s	long
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
s	long
,	O
file	pointer
)	O
;	O
}	O
return	O
s	long
;	O
}	O
static	O
enum	O
rushdb_result	enum
rushdb_open_internal	function
(	O
const	O
char	O
*	O
dbdir	pointer
,	O
int	O
rw	int
)	O
{	O
char	O
*	O
fname	pointer
;	O
int	O
rc	int
;	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
stat	struct
(	O
dbdir	pointer
,	O
&	O
st	struct
)	O
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
if	O
(	O
!	O
rw	int
)	O
return	O
rushdb_result_eof	int
;	O
if	O
(	O
mkdir	function
(	O
dbdir	pointer
,	O
rushdb_dir_mode	int
)	O
)	O
{	O
format_error	function
(	O
_	O
(	O
"cannot create directory %s: %s"	pointer
)	O
,	O
dbdir	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
rushdb_result_fail	int
;	O
}	O
}	O
else	O
{	O
format_error	function
(	O
_	O
(	O
"cannot stat directory %s: %s"	pointer
)	O
,	O
dbdir	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
rushdb_result_fail	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
S_ISDIR	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
format_error	function
(	O
_	O
(	O
"%s is not a directory"	pointer
)	O
,	O
dbdir	pointer
)	O
;	O
return	O
rushdb_result_fail	int
;	O
}	O
fname	pointer
=	O
mkname	function
(	O
dbdir	pointer
,	O
RUSH_UTMP_NAME	pointer
)	O
;	O
if	O
(	O
!	O
fname	pointer
)	O
{	O
format_error	function
(	O
"%s"	pointer
,	O
gettext	function
(	O
strerror	function
(	O
ENOMEM	int
)	O
)	O
)	O
;	O
return	O
rushdb_result_fail	int
;	O
}	O
rc	int
=	O
rush_utmp_open	function
(	O
fname	pointer
,	O
rw	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
format_error	function
(	O
_	O
(	O
"cannot open file %s: %s"	pointer
)	O
,	O
fname	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
free	function
(	O
fname	pointer
)	O
;	O
return	O
rushdb_result_fail	int
;	O
}	O
free	function
(	O
fname	pointer
)	O
;	O
fname	pointer
=	O
mkname	function
(	O
dbdir	pointer
,	O
RUSH_WTMP_NAME	pointer
)	O
;	O
if	O
(	O
!	O
fname	pointer
)	O
{	O
format_error	function
(	O
"%s"	pointer
,	O
gettext	function
(	O
strerror	function
(	O
ENOMEM	int
)	O
)	O
)	O
;	O
return	O
rushdb_result_fail	int
;	O
}	O
rc	int
=	O
rush_wtmp_open	function
(	O
fname	pointer
,	O
rw	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
format_error	function
(	O
_	O
(	O
"cannot open file %s: %s"	pointer
)	O
,	O
fname	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
free	function
(	O
fname	pointer
)	O
;	O
return	O
rushdb_result_fail	int
;	O
}	O
free	function
(	O
fname	pointer
)	O
;	O
return	O
rushdb_result_ok	int
;	O
}	O
enum	O
rushdb_result	enum
rushdb_open	function
(	O
const	O
char	O
*	O
dbdir	pointer
,	O
int	O
rw	int
)	O
{	O
mode_t	int
um	int
=	O
umask	function
(	O
rushdb_umask	int
)	O
;	O
enum	O
rushdb_result	enum
res	enum
=	O
rushdb_open_internal	function
(	O
dbdir	pointer
,	O
rw	int
)	O
;	O
umask	function
(	O
um	int
)	O
;	O
return	O
res	enum
;	O
}	O
int	O
rushdb_close	function
(	O
)	O
{	O
return	O
rush_wtmp_close	function
(	O
)	O
||	O
rush_utmp_close	function
(	O
)	O
;	O
}	O
void	O
rushdb_backward_direction	function
(	O
)	O
{	O
rush_wtmp_set_dir	function
(	O
rush_wtmp_backward	int
)	O
;	O
}	O
static	O
int	O
lock_typetab	array
[	O
]	O
=	O
{	O
F_RDLCK	int
,	O
F_WRLCK	int
}	O
;	O
int	O
rushdb_lock	function
(	O
int	O
fd	int
,	O
size_t	long
size	long
,	O
off_t	long
offset	long
,	O
int	O
whence	int
,	O
int	O
type	enum
)	O
{	O
struct	O
flock	struct
fl	struct
;	O
if	O
(	O
type	enum
<	O
0	int
||	O
type	enum
>	O
1	int
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
fl	struct
.	O
l_type	short
=	O
lock_typetab	array
[	O
type	enum
]	O
;	O
fl	struct
.	O
l_whence	short
=	O
whence	int
;	O
fl	struct
.	O
l_start	long
=	O
offset	long
;	O
fl	struct
.	O
l_len	long
=	O
size	long
;	O
return	O
fcntl	function
(	O
fd	int
,	O
F_SETLKW	int
,	O
&	O
fl	struct
)	O
;	O
}	O
int	O
rushdb_unlock	function
(	O
int	O
fd	int
,	O
size_t	long
size	long
,	O
off_t	long
offset	long
,	O
int	O
whence	int
)	O
{	O
struct	O
flock	struct
fl	struct
;	O
fl	struct
.	O
l_type	short
=	O
F_UNLCK	int
;	O
fl	struct
.	O
l_whence	short
=	O
whence	int
;	O
fl	struct
.	O
l_start	long
=	O
offset	long
;	O
fl	struct
.	O
l_len	long
=	O
size	long
;	O
return	O
fcntl	function
(	O
fd	int
,	O
F_SETLKW	int
,	O
&	O
fl	struct
)	O
;	O
}	O
struct	O
format_key	struct
{	O
struct	O
format_key	struct
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
char	O
*	O
value	pointer
;	O
}	O
;	O
typedef	O
int	O
(	O
*	O
rushdb_format_fp	pointer
)	O
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
struct	O
format_key	struct
*	O
key	pointer
,	O
struct	O
rush_wtmp	struct
*	O
)	O
;	O
struct	O
rushdb_format	struct
{	O
rushdb_format_t	pointer
next	pointer
;	O
int	O
type	enum
;	O
struct	O
format_key	struct
*	O
key	pointer
;	O
union	O
{	O
struct	O
{	O
rushdb_format_fp	pointer
fun	pointer
;	O
int	O
width	int
;	O
char	O
*	O
header	pointer
;	O
}	O
fh	struct
;	O
char	O
*	O
string	pointer
;	O
int	O
tabstop	int
;	O
int	O
nl	int
;	O
}	O
v	union
;	O
}	O
;	O
char	O
*	O
rushdb_date_format	pointer
=	O
"%a %H:%M"	pointer
;	O
static	O
void	O
format_key_free	function
(	O
struct	O
format_key	struct
*	O
key	pointer
)	O
{	O
struct	O
format_key	struct
*	O
next	pointer
;	O
while	O
(	O
key	pointer
)	O
{	O
next	pointer
=	O
key	pointer
->	O
next	pointer
;	O
free	function
(	O
key	pointer
->	O
name	pointer
)	O
;	O
free	function
(	O
key	pointer
->	O
value	pointer
)	O
;	O
free	function
(	O
key	pointer
)	O
;	O
key	pointer
=	O
next	pointer
;	O
}	O
}	O
static	O
char	O
*	O
format_key_lookup	function
(	O
struct	O
format_key	struct
*	O
key	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
for	O
(	O
;	O
key	pointer
;	O
key	pointer
=	O
key	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
key	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
key	pointer
->	O
value	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
form_free	function
(	O
struct	O
rushdb_format	struct
*	O
form	pointer
)	O
{	O
struct	O
rushdb_format	struct
*	O
next	pointer
;	O
while	O
(	O
form	pointer
)	O
{	O
next	pointer
=	O
form	pointer
->	O
next	pointer
;	O
format_key_free	function
(	O
form	pointer
->	O
key	pointer
)	O
;	O
switch	O
(	O
form	pointer
->	O
type	enum
)	O
{	O
case	O
FDATA_STRING	int
:	O
free	function
(	O
form	pointer
->	O
v	union
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
FDATA_FH	int
:	O
free	function
(	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
header	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
free	function
(	O
form	pointer
)	O
;	O
form	pointer
=	O
next	pointer
;	O
}	O
}	O
static	O
int	O
key_align	function
(	O
struct	O
format_key	struct
*	O
key	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
format_key_lookup	function
(	O
key	pointer
,	O
"right"	pointer
)	O
;	O
return	O
p	pointer
?	O
ALIGN_RIGHT	int
:	O
ALIGN_LEFT	int
;	O
}	O
static	O
int	O
output_string	function
(	O
char	O
*	O
string	pointer
,	O
int	O
width	int
,	O
int	O
align	int
)	O
{	O
if	O
(	O
width	int
==	O
0	int
)	O
width	int
=	O
printf	function
(	O
"%s"	pointer
,	O
string	pointer
)	O
;	O
else	O
if	O
(	O
align	int
==	O
ALIGN_LEFT	int
)	O
width	int
=	O
printf	function
(	O
"%-*.*s"	pointer
,	O
width	int
,	O
width	int
,	O
string	pointer
)	O
;	O
else	O
width	int
=	O
printf	function
(	O
"%*.*s"	pointer
,	O
width	int
,	O
width	int
,	O
string	pointer
)	O
;	O
return	O
width	int
;	O
}	O
static	O
int	O
output_string_key	function
(	O
char	O
*	O
string	pointer
,	O
int	O
width	int
,	O
struct	O
format_key	struct
*	O
key	pointer
)	O
{	O
if	O
(	O
strlen	function
(	O
string	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	pointer
=	O
format_key_lookup	function
(	O
key	pointer
,	O
"empty"	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
string	pointer
=	O
p	pointer
;	O
}	O
return	O
output_string	function
(	O
string	pointer
,	O
width	int
,	O
key_align	function
(	O
key	pointer
)	O
)	O
;	O
}	O
static	O
int	O
output_tab	function
(	O
int	O
column	int
,	O
int	O
tabstop	int
)	O
{	O
int	O
goal	int
=	O
(	O
(	O
(	O
column	int
+	O
TAB_SIZE	int
-	O
1	int
)	O
/	O
TAB_SIZE	int
)	O
+	O
tabstop	int
)	O
*	O
TAB_SIZE	int
;	O
for	O
(	O
;	O
column	int
<	O
goal	int
;	O
column	int
++	O
)	O
putchar	function
(	O
' '	O
)	O
;	O
return	O
column	int
;	O
}	O
static	O
int	O
output_duration	function
(	O
time_t	long
t	long
,	O
int	O
width	int
,	O
struct	O
format_key	struct
*	O
key	pointer
)	O
{	O
unsigned	O
d	int
,	O
h	int
,	O
m	int
,	O
s	long
;	O
unsigned	O
outbytes	int
;	O
char	O
dbuf	array
[	O
INT_BUFSIZE_BOUND	O
(	O
unsigned	O
)	O
+	O
1	int
]	O
;	O
char	O
*	O
dptr	pointer
=	O
NULL	O
;	O
unsigned	O
fullwidth	int
,	O
dlen	int
;	O
d	int
=	O
t	long
/	O
86400	int
;	O
t	long
%=	O
86400	int
;	O
s	long
=	O
t	long
%	O
60	int
;	O
m	int
=	O
t	long
/	O
60	int
;	O
if	O
(	O
m	int
>	O
59	int
)	O
{	O
h	int
=	O
m	int
/	O
60	int
;	O
m	int
-=	O
h	int
*	O
60	int
;	O
}	O
else	O
h	int
=	O
0	int
;	O
fullwidth	int
=	O
8	int
;	O
if	O
(	O
d	int
)	O
{	O
dptr	pointer
=	O
uinttostr	function
(	O
d	int
,	O
dbuf	array
)	O
;	O
dlen	int
=	O
strlen	function
(	O
dptr	pointer
)	O
;	O
fullwidth	int
+=	O
dlen	int
+	O
1	int
;	O
}	O
if	O
(	O
d	int
)	O
{	O
if	O
(	O
width	int
>=	O
fullwidth	int
)	O
outbytes	int
=	O
printf	function
(	O
"%*s+%02u:%02u:%02u"	pointer
,	O
width	int
-	O
fullwidth	int
,	O
dptr	pointer
,	O
h	int
,	O
m	int
,	O
s	long
)	O
;	O
else	O
if	O
(	O
width	int
>=	O
fullwidth	int
-	O
3	int
)	O
outbytes	int
=	O
printf	function
(	O
"%*sd%02uh%02u"	pointer
,	O
width	int
-	O
(	O
dlen	int
+	O
5	int
)	O
,	O
dptr	pointer
,	O
h	int
,	O
m	int
)	O
;	O
else	O
if	O
(	O
width	int
>=	O
fullwidth	int
-	O
5	int
)	O
outbytes	int
=	O
printf	function
(	O
"%*sd%02uh"	pointer
,	O
width	int
-	O
(	O
dlen	int
+	O
3	int
)	O
,	O
dptr	pointer
,	O
h	int
)	O
;	O
else	O
if	O
(	O
width	int
>=	O
dlen	int
+	O
1	int
)	O
outbytes	int
=	O
printf	function
(	O
"%*sd"	pointer
,	O
width	int
-	O
1	int
,	O
dptr	pointer
)	O
;	O
else	O
{	O
outbytes	int
=	O
width	int
;	O
while	O
(	O
width	int
--	O
)	O
putchar	function
(	O
'>'	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
width	int
>=	O
8	int
)	O
outbytes	int
=	O
printf	function
(	O
"%*s%02u:%02u:%02u"	pointer
,	O
width	int
-	O
8	int
,	O
""	pointer
,	O
h	int
,	O
m	int
,	O
s	long
)	O
;	O
else	O
if	O
(	O
width	int
>=	O
5	int
)	O
{	O
if	O
(	O
h	int
)	O
outbytes	int
=	O
printf	function
(	O
"%*s%02uh%02u"	pointer
,	O
width	int
-	O
5	int
,	O
""	pointer
,	O
h	int
,	O
m	int
)	O
;	O
else	O
outbytes	int
=	O
printf	function
(	O
"%*s%02u:%02u"	pointer
,	O
width	int
-	O
5	int
,	O
""	pointer
,	O
m	int
,	O
s	long
)	O
;	O
}	O
else	O
if	O
(	O
h	int
)	O
{	O
dptr	pointer
=	O
uinttostr	function
(	O
h	int
,	O
dbuf	array
)	O
;	O
dlen	int
=	O
strlen	function
(	O
dptr	pointer
)	O
;	O
if	O
(	O
width	int
>=	O
dlen	int
+	O
1	int
)	O
outbytes	int
=	O
printf	function
(	O
"%*sh"	pointer
,	O
width	int
-	O
1	int
,	O
dptr	pointer
)	O
;	O
else	O
{	O
outbytes	int
=	O
width	int
;	O
while	O
(	O
width	int
--	O
)	O
putchar	function
(	O
'>'	O
)	O
;	O
}	O
}	O
else	O
{	O
dptr	pointer
=	O
uinttostr	function
(	O
s	long
,	O
dbuf	array
)	O
;	O
dlen	int
=	O
strlen	function
(	O
dptr	pointer
)	O
;	O
if	O
(	O
width	int
>=	O
dlen	int
)	O
outbytes	int
=	O
printf	function
(	O
"%*s"	pointer
,	O
width	int
,	O
dptr	pointer
)	O
;	O
else	O
{	O
dptr	pointer
=	O
uinttostr	function
(	O
m	int
,	O
dbuf	array
)	O
;	O
dlen	int
=	O
strlen	function
(	O
dptr	pointer
)	O
;	O
if	O
(	O
width	int
>=	O
dlen	int
+	O
1	int
)	O
outbytes	int
=	O
printf	function
(	O
"%*sm"	pointer
,	O
width	int
-	O
1	int
,	O
dptr	pointer
)	O
;	O
else	O
{	O
outbytes	int
=	O
width	int
;	O
while	O
(	O
width	int
--	O
)	O
putchar	function
(	O
'>'	O
)	O
;	O
}	O
}	O
}	O
}	O
return	O
outbytes	int
;	O
}	O
static	O
int	O
output_time	function
(	O
struct	O
timeval	struct
*	O
tv	pointer
,	O
int	O
width	int
,	O
struct	O
format_key	struct
*	O
key	pointer
)	O
{	O
struct	O
tm	struct
*	O
tm	struct
=	O
localtime	function
(	O
&	O
tv	pointer
->	O
tv_sec	long
)	O
;	O
char	O
*	O
fmt	pointer
=	O
format_key_lookup	function
(	O
key	pointer
,	O
"format"	pointer
)	O
;	O
return	O
fprintftime	function
(	O
stdout	pointer
,	O
fmt	pointer
?	O
fmt	pointer
:	O
rushdb_date_format	pointer
,	O
tm	struct
,	O
0	int
,	O
tv	pointer
->	O
tv_usec	long
*	O
1000	int
)	O
;	O
}	O
static	O
int	O
format_user	function
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
struct	O
format_key	struct
*	O
key	pointer
,	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
)	O
{	O
return	O
output_string_key	function
(	O
wtmp	pointer
->	O
user	pointer
,	O
width	int
,	O
key	pointer
)	O
;	O
}	O
static	O
int	O
format_rule	function
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
struct	O
format_key	struct
*	O
key	pointer
,	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
)	O
{	O
return	O
output_string_key	function
(	O
wtmp	pointer
->	O
rule	pointer
,	O
width	int
,	O
key	pointer
)	O
;	O
}	O
static	O
int	O
format_command	function
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
struct	O
format_key	struct
*	O
key	pointer
,	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
)	O
{	O
return	O
output_string_key	function
(	O
wtmp	pointer
->	O
command	pointer
,	O
width	int
,	O
key	pointer
)	O
;	O
}	O
static	O
int	O
format_pid	function
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
struct	O
format_key	struct
*	O
key	pointer
,	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
)	O
{	O
char	O
buf	array
[	O
INT_BUFSIZE_BOUND	O
(	O
uintmax_t	long
)	O
]	O
;	O
return	O
output_string_key	function
(	O
umaxtostr	function
(	O
wtmp	pointer
->	O
pid	int
,	O
buf	array
)	O
,	O
width	int
,	O
key	pointer
)	O
;	O
}	O
static	O
int	O
format_duration	function
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
struct	O
format_key	struct
*	O
key	pointer
,	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
)	O
{	O
time_t	long
end	long
=	O
wtmp	pointer
->	O
stop	struct
.	O
tv_sec	long
;	O
time_t	long
x	long
=	O
(	O
end	long
?	O
end	long
:	O
time	struct
(	O
NULL	O
)	O
)	O
-	O
wtmp	pointer
->	O
start	struct
.	O
tv_sec	long
;	O
return	O
output_duration	function
(	O
x	long
,	O
width	int
,	O
key	pointer
)	O
;	O
}	O
static	O
int	O
format_start	function
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
struct	O
format_key	struct
*	O
key	pointer
,	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
)	O
{	O
return	O
output_time	function
(	O
&	O
wtmp	pointer
->	O
start	struct
,	O
width	int
,	O
key	pointer
)	O
;	O
}	O
static	O
int	O
format_stop	function
(	O
int	O
outbytes	int
,	O
int	O
width	int
,	O
struct	O
format_key	struct
*	O
key	pointer
,	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
)	O
{	O
if	O
(	O
wtmp	pointer
->	O
stop	struct
.	O
tv_sec	long
==	O
0	int
&&	O
wtmp	pointer
->	O
stop	struct
.	O
tv_usec	long
==	O
0	int
)	O
return	O
output_string_key	function
(	O
"running"	pointer
,	O
width	int
,	O
key	pointer
)	O
;	O
else	O
return	O
output_time	function
(	O
&	O
wtmp	pointer
->	O
stop	struct
,	O
width	int
,	O
key	pointer
)	O
;	O
}	O
struct	O
format_tab	struct
{	O
char	O
*	O
name	pointer
;	O
rushdb_format_fp	pointer
fun	pointer
;	O
}	O
;	O
static	O
struct	O
format_tab	struct
handlers	array
[	O
]	O
=	O
{	O
{	O
"user"	pointer
,	O
format_user	function
}	O
,	O
{	O
"rule"	pointer
,	O
format_rule	function
}	O
,	O
{	O
"command"	pointer
,	O
format_command	function
}	O
,	O
{	O
"pid"	pointer
,	O
format_pid	function
}	O
,	O
{	O
"duration"	pointer
,	O
format_duration	function
}	O
,	O
{	O
"time"	pointer
,	O
format_start	function
}	O
,	O
{	O
"start-time"	pointer
,	O
format_start	function
}	O
,	O
{	O
"stop-time"	pointer
,	O
format_stop	function
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
rushdb_format_fp	pointer
_lookup	function
(	O
char	O
*	O
name	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
handlers	array
[	O
i	int
]	O
.	O
name	pointer
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
handlers	array
[	O
i	int
]	O
.	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
handlers	array
[	O
i	int
]	O
.	O
fun	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
slist_t	pointer
slist	pointer
;	O
static	O
char	O
*	O
collect_sequence	function
(	O
char	O
*	O
fmt	pointer
,	O
int	O
(	O
*	O
cond	pointer
)	O
(	O
void	O
*	O
,	O
char	O
*	O
)	O
,	O
void	O
*	O
closure	pointer
)	O
{	O
char	O
c	int
;	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
fmt	pointer
;	O
*	O
p	pointer
&&	O
(	O
*	O
cond	pointer
)	O
(	O
closure	pointer
,	O
p	pointer
)	O
==	O
0	int
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\\'	O
)	O
{	O
switch	O
(	O
*	O
++	O
p	pointer
)	O
{	O
case	O
'a'	O
:	O
c	int
=	O
'\a'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
c	int
=	O
'\b'	O
;	O
break	O
;	O
case	O
'e'	O
:	O
c	int
=	O
'\033'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
c	int
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
c	int
=	O
'\n'	O
;	O
break	O
;	O
case	O
't'	O
:	O
c	int
=	O
'\t'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
c	int
=	O
'\r'	O
;	O
break	O
;	O
case	O
'v'	O
:	O
c	int
=	O
'\v'	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
continue	O
;	O
default	O
:	O
c	int
=	O
*	O
p	pointer
;	O
}	O
slist_append	function
(	O
slist	pointer
,	O
&	O
c	int
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
)	O
;	O
else	O
slist_append	function
(	O
slist	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
static	O
char	O
*	O
parse_string_fmt	function
(	O
char	O
*	O
fmt	pointer
,	O
rushdb_format_t	pointer
form	pointer
,	O
int	O
(	O
*	O
cond	pointer
)	O
(	O
void	O
*	O
,	O
char	O
*	O
)	O
,	O
void	O
*	O
closure	pointer
)	O
{	O
char	O
c	int
;	O
char	O
*	O
endp	pointer
=	O
collect_sequence	function
(	O
fmt	pointer
,	O
cond	pointer
,	O
closure	pointer
)	O
;	O
c	int
=	O
0	int
;	O
slist_append	function
(	O
slist	pointer
,	O
&	O
c	int
,	O
1	int
)	O
;	O
slist_reduce	function
(	O
slist	pointer
,	O
&	O
form	pointer
->	O
v	union
.	O
string	pointer
,	O
NULL	O
)	O
;	O
form	pointer
->	O
type	enum
=	O
FDATA_STRING	int
;	O
return	O
endp	pointer
;	O
}	O
static	O
int	O
_is_closing_quote	function
(	O
void	O
*	O
closure	pointer
,	O
char	O
*	O
p	pointer
)	O
{	O
return	O
*	O
(	O
char	O
*	O
)	O
closure	pointer
==	O
*	O
p	pointer
;	O
}	O
static	O
int	O
parse_quote	function
(	O
char	O
*	O
*	O
fmtp	pointer
,	O
struct	O
rushdb_format	struct
*	O
form	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
parse_string_fmt	function
(	O
*	O
fmtp	pointer
+	O
1	int
,	O
form	pointer
,	O
_is_closing_quote	function
,	O
*	O
fmtp	pointer
)	O
;	O
if	O
(	O
!	O
*	O
p	pointer
)	O
{	O
format_error	function
(	O
_	O
(	O
"missing closing quote in string started "	pointer
"near `%s'"	pointer
)	O
,	O
*	O
fmtp	pointer
)	O
;	O
return	O
1	int
;	O
}	O
*	O
fmtp	pointer
=	O
p	pointer
+	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_is_open_brace	function
(	O
void	O
*	O
closure	pointer
,	O
char	O
*	O
p	pointer
)	O
{	O
return	O
*	O
p	pointer
==	O
'('	O
;	O
}	O
static	O
int	O
parse_string	function
(	O
char	O
*	O
*	O
fmtp	pointer
,	O
struct	O
rushdb_format	struct
*	O
form	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
parse_string_fmt	function
(	O
*	O
fmtp	pointer
,	O
form	pointer
,	O
_is_open_brace	function
,	O
NULL	O
)	O
;	O
*	O
fmtp	pointer
=	O
p	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_is_delim	function
(	O
void	O
*	O
closure	pointer
,	O
char	O
*	O
p	pointer
)	O
{	O
return	O
c_isspace	function
(	O
*	O
p	pointer
)	O
||	O
*	O
p	pointer
==	O
')'	O
;	O
}	O
static	O
char	O
*	O
get_token	function
(	O
char	O
*	O
*	O
fmtp	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
char	O
c	int
;	O
while	O
(	O
*	O
*	O
fmtp	pointer
&&	O
c_isspace	function
(	O
*	O
*	O
fmtp	pointer
)	O
)	O
++	O
*	O
fmtp	pointer
;	O
p	pointer
=	O
*	O
fmtp	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
')'	O
)	O
{	O
slist_append	function
(	O
slist	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
++	O
*	O
fmtp	pointer
;	O
}	O
else	O
{	O
if	O
(	O
*	O
*	O
fmtp	pointer
==	O
'"'	O
||	O
*	O
*	O
fmtp	pointer
==	O
'\''	O
)	O
{	O
p	pointer
=	O
collect_sequence	function
(	O
*	O
fmtp	pointer
+	O
1	int
,	O
_is_closing_quote	function
,	O
*	O
fmtp	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
*	O
*	O
fmtp	pointer
)	O
p	pointer
++	O
;	O
*	O
fmtp	pointer
=	O
p	pointer
;	O
}	O
else	O
*	O
fmtp	pointer
=	O
collect_sequence	function
(	O
*	O
fmtp	pointer
,	O
_is_delim	function
,	O
NULL	O
)	O
;	O
}	O
c	int
=	O
0	int
;	O
slist_append	function
(	O
slist	pointer
,	O
&	O
c	int
,	O
1	int
)	O
;	O
return	O
slist_reduce	function
(	O
slist	pointer
,	O
&	O
p	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
is_time_function	function
(	O
rushdb_format_fp	pointer
fh	struct
)	O
{	O
return	O
fh	struct
==	O
format_start	function
||	O
fh	struct
==	O
format_stop	function
;	O
}	O
static	O
int	O
time_width	function
(	O
struct	O
rushdb_format	struct
*	O
form	pointer
)	O
{	O
time_t	long
t	long
=	O
0	int
;	O
struct	O
tm	struct
*	O
tm	struct
=	O
localtime	function
(	O
&	O
t	long
)	O
;	O
char	O
*	O
fmt	pointer
=	O
format_key_lookup	function
(	O
form	pointer
->	O
key	pointer
,	O
"format"	pointer
)	O
;	O
return	O
nstrftime	function
(	O
NULL	O
,	O
-	O
1	int
,	O
fmt	pointer
?	O
fmt	pointer
:	O
rushdb_date_format	pointer
,	O
tm	struct
,	O
0	int
,	O
0	int
)	O
;	O
}	O
static	O
int	O
parse_form	function
(	O
char	O
*	O
*	O
fmtp	pointer
,	O
struct	O
rushdb_format	struct
*	O
form	pointer
)	O
{	O
char	O
*	O
formname	pointer
,	O
*	O
p	pointer
;	O
struct	O
format_key	struct
*	O
key_head	pointer
,	O
*	O
key_tail	pointer
;	O
++	O
*	O
fmtp	pointer
;	O
formname	pointer
=	O
get_token	function
(	O
fmtp	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
formname	pointer
,	O
"newline"	pointer
)	O
==	O
0	int
)	O
{	O
form	pointer
->	O
type	enum
=	O
FDATA_NEWLINE	int
;	O
p	pointer
=	O
get_token	function
(	O
fmtp	pointer
)	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
!=	O
')'	O
)	O
{	O
form	pointer
->	O
v	union
.	O
nl	int
=	O
strtol	function
(	O
p	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
p	pointer
=	O
get_token	function
(	O
fmtp	pointer
)	O
;	O
}	O
else	O
form	pointer
->	O
v	union
.	O
nl	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
formname	pointer
,	O
"tab"	pointer
)	O
==	O
0	int
)	O
{	O
form	pointer
->	O
type	enum
=	O
FDATA_TAB	int
;	O
p	pointer
=	O
get_token	function
(	O
fmtp	pointer
)	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
!=	O
')'	O
)	O
{	O
form	pointer
->	O
v	union
.	O
tabstop	int
=	O
strtol	function
(	O
p	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
p	pointer
=	O
get_token	function
(	O
fmtp	pointer
)	O
;	O
}	O
else	O
form	pointer
->	O
v	union
.	O
tabstop	int
=	O
1	int
;	O
}	O
else	O
{	O
rushdb_format_fp	pointer
fh	struct
;	O
int	O
arg	int
;	O
fh	struct
=	O
_lookup	function
(	O
formname	pointer
)	O
;	O
if	O
(	O
!	O
fh	struct
)	O
{	O
format_error	function
(	O
"error in format spec: unknown format %s"	pointer
,	O
formname	pointer
)	O
;	O
return	O
1	int
;	O
}	O
form	pointer
->	O
type	enum
=	O
FDATA_FH	int
;	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
fun	pointer
=	O
fh	struct
;	O
arg	int
=	O
0	int
;	O
while	O
(	O
(	O
p	pointer
=	O
get_token	function
(	O
fmtp	pointer
)	O
)	O
!=	O
NULL	O
&&	O
!	O
(	O
p	pointer
[	O
0	int
]	O
==	O
':'	O
||	O
p	pointer
[	O
0	int
]	O
==	O
')'	O
)	O
)	O
{	O
arg	int
++	O
;	O
switch	O
(	O
arg	int
)	O
{	O
case	O
1	int
:	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
width	int
=	O
strtol	function
(	O
p	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
2	int
:	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
header	pointer
=	O
xstrdup	function
(	O
p	pointer
)	O
;	O
break	O
;	O
default	O
:	O
format_error	function
(	O
"wrong number of arguments "	pointer
"to form %s"	pointer
,	O
formname	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
key_head	pointer
=	O
NULL	O
;	O
while	O
(	O
p	pointer
&&	O
p	pointer
[	O
0	int
]	O
==	O
':'	O
)	O
{	O
struct	O
format_key	struct
*	O
key	pointer
=	O
xzalloc	function
(	O
sizeof	O
(	O
*	O
key	pointer
)	O
)	O
;	O
if	O
(	O
!	O
key_head	pointer
)	O
key_head	pointer
=	O
key	pointer
;	O
else	O
key_tail	pointer
->	O
next	pointer
=	O
key	pointer
;	O
key_tail	pointer
=	O
key	pointer
;	O
key	pointer
->	O
name	pointer
=	O
xstrdup	function
(	O
p	pointer
+	O
1	int
)	O
;	O
p	pointer
=	O
get_token	function
(	O
fmtp	pointer
)	O
;	O
if	O
(	O
p	pointer
[	O
0	int
]	O
==	O
')'	O
||	O
p	pointer
[	O
0	int
]	O
==	O
':'	O
)	O
key	pointer
->	O
value	pointer
=	O
xstrdup	function
(	O
"t"	pointer
)	O
;	O
else	O
{	O
key	pointer
->	O
value	pointer
=	O
xstrdup	function
(	O
p	pointer
)	O
;	O
p	pointer
=	O
get_token	function
(	O
fmtp	pointer
)	O
;	O
}	O
}	O
form	pointer
->	O
key	pointer
=	O
key_head	pointer
;	O
if	O
(	O
is_time_function	function
(	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
fun	pointer
)	O
)	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
width	int
=	O
time_width	function
(	O
form	pointer
)	O
;	O
}	O
if	O
(	O
p	pointer
[	O
0	int
]	O
!=	O
')'	O
)	O
{	O
format_error	function
(	O
"form `%s' not closed"	pointer
,	O
formname	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
rushdb_format_t	pointer
rushdb_compile_format	function
(	O
char	O
*	O
fmt	pointer
)	O
{	O
struct	O
rushdb_format	struct
*	O
form_head	pointer
=	O
NULL	O
,	O
*	O
form_tail	pointer
;	O
slist	pointer
=	O
slist_create	function
(	O
)	O
;	O
while	O
(	O
*	O
fmt	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
rushdb_format	struct
*	O
form	pointer
=	O
xzalloc	function
(	O
sizeof	O
(	O
*	O
form	pointer
)	O
)	O
;	O
if	O
(	O
!	O
form_head	pointer
)	O
form_head	pointer
=	O
form	pointer
;	O
else	O
form_tail	pointer
->	O
next	pointer
=	O
form	pointer
;	O
form_tail	pointer
=	O
form	pointer
;	O
if	O
(	O
*	O
fmt	pointer
==	O
'('	O
)	O
rc	int
=	O
parse_form	function
(	O
&	O
fmt	pointer
,	O
form	pointer
)	O
;	O
else	O
if	O
(	O
*	O
fmt	pointer
==	O
'"'	O
||	O
*	O
fmt	pointer
==	O
'\''	O
)	O
rc	int
=	O
parse_quote	function
(	O
&	O
fmt	pointer
,	O
form	pointer
)	O
;	O
else	O
rc	int
=	O
parse_string	function
(	O
&	O
fmt	pointer
,	O
form	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
form_free	function
(	O
form_head	pointer
)	O
;	O
form_head	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
slist_free	function
(	O
slist	pointer
)	O
;	O
return	O
form_head	pointer
;	O
}	O
int	O
rushdb_print	function
(	O
rushdb_format_t	pointer
form	pointer
,	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
,	O
int	O
newline	int
)	O
{	O
int	O
i	int
;	O
int	O
outbytes	int
=	O
0	int
;	O
for	O
(	O
;	O
form	pointer
;	O
form	pointer
=	O
form	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
form	pointer
->	O
type	enum
)	O
{	O
case	O
FDATA_FH	int
:	O
outbytes	int
+=	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
fun	pointer
(	O
outbytes	int
,	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
width	int
,	O
form	pointer
->	O
key	pointer
,	O
wtmp	pointer
)	O
;	O
break	O
;	O
case	O
FDATA_STRING	int
:	O
outbytes	int
+=	O
output_string	function
(	O
form	pointer
->	O
v	union
.	O
string	pointer
,	O
0	int
,	O
ALIGN_LEFT	int
)	O
;	O
break	O
;	O
case	O
FDATA_TAB	int
:	O
outbytes	int
+=	O
output_tab	function
(	O
outbytes	int
,	O
form	pointer
->	O
v	union
.	O
tabstop	int
)	O
;	O
break	O
;	O
case	O
FDATA_NEWLINE	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
form	pointer
->	O
v	union
.	O
nl	int
;	O
i	int
++	O
)	O
putchar	function
(	O
'\n'	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
newline	int
)	O
putchar	function
(	O
'\n'	O
)	O
;	O
return	O
outbytes	int
;	O
}	O
void	O
rushdb_print_header	function
(	O
rushdb_format_t	pointer
form	pointer
)	O
{	O
int	O
i	int
,	O
outbytes	int
=	O
0	int
;	O
rushdb_format_t	pointer
p	pointer
;	O
for	O
(	O
p	pointer
=	O
form	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
p	pointer
->	O
type	enum
==	O
FDATA_NEWLINE	int
)	O
return	O
;	O
for	O
(	O
;	O
form	pointer
;	O
form	pointer
=	O
form	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
form	pointer
->	O
type	enum
)	O
{	O
case	O
FDATA_FH	int
:	O
if	O
(	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
header	pointer
)	O
outbytes	int
+=	O
output_string	function
(	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
header	pointer
,	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
width	int
,	O
ALIGN_LEFT	int
)	O
;	O
else	O
outbytes	int
+=	O
output_string	function
(	O
""	pointer
,	O
form	pointer
->	O
v	union
.	O
fh	struct
.	O
width	int
,	O
ALIGN_LEFT	int
)	O
;	O
break	O
;	O
case	O
FDATA_STRING	int
:	O
outbytes	int
+=	O
output_string	function
(	O
form	pointer
->	O
v	union
.	O
string	pointer
,	O
strlen	function
(	O
form	pointer
->	O
v	union
.	O
string	pointer
)	O
,	O
ALIGN_LEFT	int
)	O
;	O
break	O
;	O
case	O
FDATA_TAB	int
:	O
outbytes	int
+=	O
output_tab	function
(	O
outbytes	int
,	O
form	pointer
->	O
v	union
.	O
tabstop	int
)	O
;	O
break	O
;	O
case	O
FDATA_NEWLINE	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
form	pointer
->	O
v	union
.	O
nl	int
;	O
i	int
++	O
)	O
putchar	function
(	O
'\n'	O
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
putchar	function
(	O
'\n'	O
)	O
;	O
}	O
int	O
rushdb_start	function
(	O
struct	O
rush_wtmp	struct
*	O
wtmp	pointer
)	O
{	O
int	O
status	int
;	O
enum	O
rushdb_result	enum
result	enum
;	O
int	O
rc	int
;	O
rush_utmp_lock_all	function
(	O
RUSH_LOCK_WRITE	int
)	O
;	O
result	enum
=	O
rush_utmp_read	function
(	O
RUSH_STATUS_MAP_BIT	O
(	O
RUSH_STATUS_AVAIL	int
)	O
,	O
&	O
status	int
,	O
NULL	O
)	O
;	O
if	O
(	O
result	enum
==	O
rushdb_result_fail	int
)	O
rc	int
=	O
1	int
;	O
else	O
{	O
gettimeofday	function
(	O
&	O
wtmp	pointer
->	O
start	struct
,	O
NULL	O
)	O
;	O
memset	function
(	O
&	O
wtmp	pointer
->	O
stop	struct
,	O
0	int
,	O
sizeof	O
(	O
wtmp	pointer
->	O
stop	struct
)	O
)	O
;	O
rc	int
=	O
rush_utmp_write	function
(	O
wtmp	pointer
)	O
;	O
}	O
rush_utmp_unlock_all	function
(	O
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
rushdb_stop	function
(	O
)	O
{	O
struct	O
timeval	struct
tv	pointer
;	O
if	O
(	O
rush_utmp_chstatus	function
(	O
RUSH_STATUS_AVAIL	int
)	O
)	O
return	O
1	int
;	O
gettimeofday	function
(	O
&	O
tv	pointer
,	O
NULL	O
)	O
;	O
return	O
rush_wtmp_update	function
(	O
&	O
tv	pointer
)	O
;	O
}	O
