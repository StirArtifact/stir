extern	O
struct	O
display	struct
*	O
displays	pointer
,	O
*	O
display	struct
;	O
extern	O
struct	O
win	struct
*	O
windows	pointer
,	O
*	O
fore	pointer
,	O
*	O
console_window	pointer
;	O
extern	O
char	O
*	O
ShellArgs	array
[	O
]	O
;	O
extern	O
char	O
*	O
ShellProg	pointer
;	O
extern	O
char	O
screenterm	array
[	O
]	O
;	O
extern	O
char	O
*	O
screenlogfile	pointer
;	O
extern	O
char	O
HostName	array
[	O
]	O
;	O
extern	O
int	O
TtyMode	int
;	O
extern	O
int	O
SilenceWait	int
;	O
extern	O
int	O
ServerSocket	int
;	O
extern	O
int	O
real_uid	int
,	O
real_gid	int
,	O
eff_uid	int
,	O
eff_gid	int
;	O
extern	O
char	O
Termcap	array
[	O
]	O
;	O
extern	O
char	O
*	O
*	O
NewEnv	pointer
;	O
extern	O
int	O
visual_bell	int
,	O
maxwin	int
;	O
extern	O
struct	O
event	struct
logflushev	struct
;	O
extern	O
int	O
log_flush	int
,	O
logtstamp_after	int
;	O
extern	O
int	O
ZombieKey_destroy	int
,	O
ZombieKey_resurrect	int
,	O
ZombieKey_onerror	int
;	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
int	O
maxusercount	int
;	O
extern	O
int	O
pty_preopen	int
;	O
extern	O
int	O
zmodem_mode	int
;	O
extern	O
struct	O
mchar	struct
mchar_blank	struct
;	O
extern	O
char	O
*	O
zmodem_sendcmd	pointer
;	O
extern	O
char	O
*	O
zmodem_recvcmd	pointer
;	O
extern	O
struct	O
winsize	struct
glwz	struct
;	O
extern	O
int	O
separate_sids	int
;	O
static	O
void	O
WinProcess	function
__P	O
(	O
(	O
char	O
*	O
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
void	O
WinRedisplayLine	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
WinClearLine	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
WinRewrite	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
struct	O
mchar	struct
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
WinResize	function
__P	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
WinRestore	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
DoAutolf	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
ZombieProcess	function
__P	O
(	O
(	O
char	O
*	O
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
void	O
win_readev_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
win_writeev_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
win_resurrect_zombie_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
muchpending	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
struct	O
event	struct
*	O
)	O
)	O
;	O
static	O
void	O
paste_slowev_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
pseu_readev_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
pseu_writeev_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
win_silenceev_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
win_destroyev_fn	function
__P	O
(	O
(	O
struct	O
event	struct
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
ForkWindow	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
char	O
*	O
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
zmodem_found	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
int	O
,	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
zmodem_fin	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
zmodem_parse	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
struct	O
win	struct
*	O
*	O
wtab	pointer
;	O
int	O
VerboseCreate	int
=	O
0	int
;	O
char	O
DefaultShell	array
[	O
]	O
=	O
"/bin/sh"	pointer
;	O
struct	O
NewWindow	struct
nwin_undef	struct
=	O
{	O
-	O
1	int
,	O
(	O
char	O
*	O
)	O
0	int
,	O
(	O
char	O
*	O
*	O
)	O
0	int
,	O
(	O
char	O
*	O
)	O
0	int
,	O
(	O
char	O
*	O
)	O
0	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
-	O
1	int
,	O
(	O
char	O
*	O
)	O
0	int
,	O
(	O
char	O
*	O
)	O
0	int
,	O
0	int
}	O
;	O
struct	O
NewWindow	struct
nwin_default	struct
=	O
{	O
0	int
,	O
0	int
,	O
ShellArgs	array
,	O
0	int
,	O
screenterm	array
,	O
0	int
,	O
1	int
,	O
1	int
*	O
FLOW_NOW	O
,	O
LOGINDEFAULT	int
,	O
DEFAULTHISTHEIGHT	int
,	O
MON_OFF	int
,	O
WLOCK_OFF	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
0	int
,	O
(	O
char	O
*	O
)	O
0	int
}	O
;	O
struct	O
NewWindow	struct
nwin_options	struct
;	O
static	O
int	O
const_IOSIZE	int
=	O
IOSIZE	int
;	O
static	O
int	O
const_one	int
=	O
1	int
;	O
void	O
nwin_compose	function
(	O
def	pointer
,	O
new	pointer
,	O
res	pointer
)	O
struct	O
NewWindow	struct
*	O
def	pointer
,	O
*	O
new	pointer
,	O
*	O
res	pointer
;	O
{	O
COMPOSE	O
(	O
StartAt	int
)	O
;	O
COMPOSE	O
(	O
aka	pointer
)	O
;	O
COMPOSE	O
(	O
args	pointer
)	O
;	O
COMPOSE	O
(	O
dir	pointer
)	O
;	O
COMPOSE	O
(	O
term	struct
)	O
;	O
COMPOSE	O
(	O
aflag	int
)	O
;	O
COMPOSE	O
(	O
dynamicaka	int
)	O
;	O
COMPOSE	O
(	O
flowflag	int
)	O
;	O
COMPOSE	O
(	O
lflag	int
)	O
;	O
COMPOSE	O
(	O
histheight	int
)	O
;	O
COMPOSE	O
(	O
monitor	int
)	O
;	O
COMPOSE	O
(	O
wlock	int
)	O
;	O
COMPOSE	O
(	O
silence	int
)	O
;	O
COMPOSE	O
(	O
wrap	int
)	O
;	O
COMPOSE	O
(	O
Lflag	int
)	O
;	O
COMPOSE	O
(	O
slow	int
)	O
;	O
COMPOSE	O
(	O
gr	int
)	O
;	O
COMPOSE	O
(	O
c1	int
)	O
;	O
COMPOSE	O
(	O
bce	int
)	O
;	O
COMPOSE	O
(	O
encoding	int
)	O
;	O
COMPOSE	O
(	O
hstatus	pointer
)	O
;	O
COMPOSE	O
(	O
charset	pointer
)	O
;	O
COMPOSE	O
(	O
poll_zombie_timeout	int
)	O
;	O
}	O
struct	O
LayFuncs	struct
WinLf	struct
=	O
{	O
WinProcess	function
,	O
0	int
,	O
WinRedisplayLine	function
,	O
WinClearLine	function
,	O
WinRewrite	function
,	O
WinResize	function
,	O
WinRestore	function
,	O
0	int
}	O
;	O
static	O
int	O
DoAutolf	function
(	O
buf	pointer
,	O
lenp	pointer
,	O
fr	int
)	O
char	O
*	O
buf	pointer
;	O
int	O
*	O
lenp	pointer
;	O
int	O
fr	int
;	O
{	O
char	O
*	O
p	pointer
;	O
int	O
len	int
=	O
*	O
lenp	pointer
;	O
int	O
trunc	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
buf	pointer
;	O
len	int
>	O
0	int
;	O
p	pointer
++	O
,	O
len	int
--	O
)	O
{	O
if	O
(	O
*	O
p	pointer
!=	O
'\r'	O
)	O
continue	O
;	O
if	O
(	O
fr	int
--	O
<=	O
0	int
)	O
{	O
trunc	int
++	O
;	O
len	int
--	O
;	O
}	O
if	O
(	O
len	int
==	O
0	int
)	O
break	O
;	O
bcopy	function
(	O
p	pointer
,	O
p	pointer
+	O
1	int
,	O
len	int
++	O
)	O
;	O
p	pointer
[	O
1	int
]	O
=	O
'\n'	O
;	O
}	O
*	O
lenp	pointer
=	O
p	pointer
-	O
buf	pointer
;	O
return	O
trunc	int
;	O
}	O
static	O
void	O
WinProcess	function
(	O
bufpp	pointer
,	O
lenp	pointer
)	O
char	O
*	O
*	O
bufpp	pointer
;	O
int	O
*	O
lenp	pointer
;	O
{	O
int	O
l2	int
=	O
0	int
,	O
f	int
,	O
*	O
ilen	pointer
,	O
l	int
=	O
*	O
lenp	pointer
,	O
trunc	int
;	O
char	O
*	O
ibuf	pointer
;	O
debug1	O
(	O
"WinProcess: %d bytes\n"	pointer
,	O
*	O
lenp	pointer
)	O
;	O
fore	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
if	O
(	O
fore	pointer
->	O
w_type	int
==	O
W_TYPE_GROUP	int
)	O
{	O
*	O
bufpp	pointer
+=	O
*	O
lenp	pointer
;	O
*	O
lenp	pointer
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
fore	pointer
->	O
w_ptyfd	int
<	O
0	int
)	O
{	O
ZombieProcess	function
(	O
bufpp	pointer
,	O
lenp	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
display	struct
&&	O
fore	pointer
->	O
w_wlock	int
==	O
WLOCK_AUTO	int
&&	O
!	O
fore	pointer
->	O
w_wlockuser	pointer
&&	O
!	O
AclCheckPermWin	function
(	O
D_user	O
,	O
ACL_WRITE	int
,	O
fore	pointer
)	O
)	O
{	O
fore	pointer
->	O
w_wlockuser	pointer
=	O
D_user	O
;	O
debug2	O
(	O
"window %d: pending writelock grabbed by user %s\n"	pointer
,	O
fore	pointer
->	O
w_number	int
,	O
fore	pointer
->	O
w_wlockuser	pointer
->	O
u_name	array
)	O
;	O
}	O
if	O
(	O
display	struct
&&	O
(	O
(	O
fore	pointer
->	O
w_wlock	int
==	O
WLOCK_OFF	int
)	O
?	O
AclCheckPermWin	function
(	O
D_user	O
,	O
ACL_WRITE	int
,	O
fore	pointer
)	O
:	O
(	O
D_user	O
!=	O
fore	pointer
->	O
w_wlockuser	pointer
)	O
)	O
)	O
{	O
debug2	O
(	O
"window %d, user %s: "	pointer
,	O
fore	pointer
->	O
w_number	int
,	O
D_user	O
->	O
u_name	array
)	O
;	O
debug2	O
(	O
"writelock %d (wlockuser %s)\n"	pointer
,	O
fore	pointer
->	O
w_wlock	int
,	O
fore	pointer
->	O
w_wlockuser	pointer
?	O
fore	pointer
->	O
w_wlockuser	pointer
->	O
u_name	array
:	O
"NULL"	pointer
)	O
;	O
Msg	function
(	O
0	int
,	O
"write: permission denied (user %s)"	pointer
,	O
D_user	O
->	O
u_name	array
)	O
;	O
*	O
bufpp	pointer
+=	O
*	O
lenp	pointer
;	O
*	O
lenp	pointer
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
W_UWP	O
(	O
fore	pointer
)	O
)	O
{	O
ibuf	pointer
=	O
fore	pointer
->	O
w_pwin	pointer
->	O
p_inbuf	array
;	O
ilen	pointer
=	O
&	O
fore	pointer
->	O
w_pwin	pointer
->	O
p_inlen	int
;	O
f	int
=	O
sizeof	O
(	O
fore	pointer
->	O
w_pwin	pointer
->	O
p_inbuf	array
)	O
-	O
*	O
ilen	pointer
;	O
}	O
else	O
{	O
ibuf	pointer
=	O
fore	pointer
->	O
w_inbuf	array
;	O
ilen	pointer
=	O
&	O
fore	pointer
->	O
w_inlen	int
;	O
f	int
=	O
sizeof	O
(	O
fore	pointer
->	O
w_inbuf	array
)	O
-	O
*	O
ilen	pointer
;	O
}	O
if	O
(	O
l	int
>	O
f	int
)	O
l	int
=	O
f	int
;	O
if	O
(	O
l	int
>	O
0	int
)	O
{	O
l2	int
=	O
l	int
;	O
bcopy	function
(	O
*	O
bufpp	pointer
,	O
ibuf	pointer
+	O
*	O
ilen	pointer
,	O
l2	int
)	O
;	O
if	O
(	O
fore	pointer
->	O
w_autolf	int
&&	O
(	O
trunc	int
=	O
DoAutolf	function
(	O
ibuf	pointer
+	O
*	O
ilen	pointer
,	O
&	O
l2	int
,	O
f	int
-	O
l2	int
)	O
)	O
)	O
l	int
-=	O
trunc	int
;	O
*	O
ilen	pointer
+=	O
l2	int
;	O
*	O
bufpp	pointer
+=	O
l	int
;	O
*	O
lenp	pointer
-=	O
l	int
;	O
return	O
;	O
}	O
}	O
static	O
void	O
ZombieProcess	function
(	O
bufpp	pointer
,	O
lenp	pointer
)	O
char	O
*	O
*	O
bufpp	pointer
;	O
int	O
*	O
lenp	pointer
;	O
{	O
int	O
l	int
=	O
*	O
lenp	pointer
;	O
char	O
*	O
buf	pointer
=	O
*	O
bufpp	pointer
,	O
b1	array
[	O
10	int
]	O
,	O
b2	array
[	O
10	int
]	O
;	O
debug1	O
(	O
"ZombieProcess: %d bytes\n"	pointer
,	O
*	O
lenp	pointer
)	O
;	O
fore	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
ASSERT	O
(	O
fore	pointer
->	O
w_ptyfd	int
<	O
0	int
)	O
;	O
*	O
bufpp	pointer
+=	O
*	O
lenp	pointer
;	O
*	O
lenp	pointer
=	O
0	int
;	O
for	O
(	O
;	O
l	int
--	O
>	O
0	int
;	O
buf	pointer
++	O
)	O
{	O
if	O
(	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
==	O
ZombieKey_destroy	int
)	O
{	O
debug1	O
(	O
"Turning undead: %d\n"	pointer
,	O
fore	pointer
->	O
w_number	int
)	O
;	O
KillWindow	function
(	O
fore	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
==	O
ZombieKey_resurrect	int
)	O
{	O
debug1	O
(	O
"Resurrecting Zombie: %d\n"	pointer
,	O
fore	pointer
->	O
w_number	int
)	O
;	O
WriteString	function
(	O
fore	pointer
,	O
"\r\n"	pointer
,	O
2	int
)	O
;	O
RemakeWindow	function
(	O
fore	pointer
)	O
;	O
return	O
;	O
}	O
}	O
b1	array
[	O
AddXChar	function
(	O
b1	array
,	O
ZombieKey_destroy	int
)	O
]	O
=	O
'\0'	O
;	O
b2	array
[	O
AddXChar	function
(	O
b2	array
,	O
ZombieKey_resurrect	int
)	O
]	O
=	O
'\0'	O
;	O
Msg	function
(	O
0	int
,	O
"Press %s to destroy or %s to resurrect window"	pointer
,	O
b1	array
,	O
b2	array
)	O
;	O
}	O
static	O
void	O
WinRedisplayLine	function
(	O
y	int
,	O
from	int
,	O
to	int
,	O
isblank	int
)	O
int	O
y	int
,	O
from	int
,	O
to	int
,	O
isblank	int
;	O
{	O
debug3	O
(	O
"WinRedisplayLine %d %d %d\n"	pointer
,	O
y	int
,	O
from	int
,	O
to	int
)	O
;	O
if	O
(	O
y	int
<	O
0	int
)	O
return	O
;	O
fore	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
if	O
(	O
from	int
==	O
0	int
&&	O
y	int
>	O
0	int
&&	O
fore	pointer
->	O
w_mlines	pointer
[	O
y	int
-	O
1	int
]	O
.	O
image	char
[	O
fore	pointer
->	O
w_width	O
]	O
==	O
0	int
)	O
LCDisplayLineWrap	function
(	O
&	O
fore	pointer
->	O
w_layer	struct
,	O
&	O
fore	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
,	O
y	int
,	O
from	int
,	O
to	int
,	O
isblank	int
)	O
;	O
else	O
LCDisplayLine	function
(	O
&	O
fore	pointer
->	O
w_layer	struct
,	O
&	O
fore	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
,	O
y	int
,	O
from	int
,	O
to	int
,	O
isblank	int
)	O
;	O
}	O
static	O
int	O
WinRewrite	function
(	O
y	int
,	O
x1	int
,	O
x2	int
,	O
rend	pointer
,	O
doit	int
)	O
int	O
y	int
,	O
x1	int
,	O
x2	int
,	O
doit	int
;	O
struct	O
mchar	struct
*	O
rend	pointer
;	O
{	O
register	O
int	O
cost	int
,	O
dx	int
;	O
register	O
unsigned	O
char	O
*	O
p	pointer
,	O
*	O
i	pointer
;	O
register	O
unsigned	O
char	O
*	O
f	int
;	O
register	O
unsigned	O
char	O
*	O
fx	pointer
;	O
register	O
unsigned	O
char	O
*	O
c	pointer
;	O
debug3	O
(	O
"WinRewrite %d, %d-%d\n"	pointer
,	O
y	int
,	O
x1	int
,	O
x2	int
)	O
;	O
fore	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
dx	int
=	O
x2	int
-	O
x1	int
+	O
1	int
;	O
if	O
(	O
doit	int
)	O
{	O
i	pointer
=	O
fore	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
.	O
image	char
+	O
x1	int
;	O
while	O
(	O
dx	int
--	O
>	O
0	int
)	O
PUTCHAR	function
(	O
*	O
i	pointer
++	O
)	O
;	O
return	O
0	int
;	O
}	O
p	pointer
=	O
fore	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
.	O
attr	char
+	O
x1	int
;	O
f	int
=	O
fore	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
.	O
font	char
+	O
x1	int
;	O
fx	pointer
=	O
fore	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
.	O
fontx	char
+	O
x1	int
;	O
if	O
(	O
is_dw_font	O
(	O
rend	pointer
->	O
font	char
)	O
)	O
return	O
EXPENSIVE	int
;	O
if	O
(	O
fore	pointer
->	O
w_encoding	O
&&	O
fore	pointer
->	O
w_encoding	O
!=	O
UTF8	int
&&	O
D_encoding	O
==	O
UTF8	int
&&	O
ContainsSpecialDeffont	function
(	O
fore	pointer
->	O
w_mlines	pointer
+	O
y	int
,	O
x1	int
,	O
x2	int
,	O
fore	pointer
->	O
w_encoding	O
)	O
)	O
return	O
EXPENSIVE	int
;	O
c	pointer
=	O
fore	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
.	O
color	char
+	O
x1	int
;	O
cost	int
=	O
dx	int
=	O
x2	int
-	O
x1	int
+	O
1	int
;	O
while	O
(	O
dx	int
--	O
>	O
0	int
)	O
{	O
if	O
(	O
*	O
p	pointer
++	O
!=	O
rend	pointer
->	O
attr	char
)	O
return	O
EXPENSIVE	int
;	O
if	O
(	O
*	O
f	int
++	O
!=	O
rend	pointer
->	O
font	char
)	O
return	O
EXPENSIVE	int
;	O
if	O
(	O
*	O
fx	pointer
++	O
!=	O
rend	pointer
->	O
fontx	char
)	O
return	O
EXPENSIVE	int
;	O
if	O
(	O
*	O
c	pointer
++	O
!=	O
rend	pointer
->	O
color	char
)	O
return	O
EXPENSIVE	int
;	O
}	O
return	O
cost	int
;	O
}	O
static	O
void	O
WinClearLine	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
bce	int
)	O
int	O
y	int
,	O
xs	int
,	O
xe	int
,	O
bce	int
;	O
{	O
fore	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
debug3	O
(	O
"WinClearLine %d %d-%d\n"	pointer
,	O
y	int
,	O
xs	int
,	O
xe	int
)	O
;	O
LClearLine	function
(	O
flayer	pointer
,	O
y	int
,	O
xs	int
,	O
xe	int
,	O
bce	int
,	O
&	O
fore	pointer
->	O
w_mlines	pointer
[	O
y	int
]	O
)	O
;	O
}	O
static	O
int	O
WinResize	function
(	O
wi	int
,	O
he	int
)	O
int	O
wi	int
,	O
he	int
;	O
{	O
fore	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
ChangeWindowSize	function
(	O
fore	pointer
,	O
wi	int
,	O
he	int
,	O
fore	pointer
->	O
w_histheight	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
WinRestore	function
(	O
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
fore	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
debug1	O
(	O
"WinRestore: win %p\n"	pointer
,	O
fore	pointer
)	O
;	O
for	O
(	O
cv	pointer
=	O
flayer	pointer
->	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
cv	pointer
!=	O
D_forecv	O
)	O
continue	O
;	O
KeypadMode	function
(	O
fore	pointer
->	O
w_keypad	int
)	O
;	O
CursorkeysMode	function
(	O
fore	pointer
->	O
w_cursorkeys	int
)	O
;	O
SetFlow	function
(	O
fore	pointer
->	O
w_flow	int
&	O
FLOW_NOW	O
)	O
;	O
InsertMode	function
(	O
fore	pointer
->	O
w_insert	int
)	O
;	O
ReverseVideo	function
(	O
fore	pointer
->	O
w_revvid	int
)	O
;	O
CursorVisibility	function
(	O
fore	pointer
->	O
w_curinv	int
?	O
-	O
1	int
:	O
fore	pointer
->	O
w_curvvis	int
)	O
;	O
MouseMode	function
(	O
fore	pointer
->	O
w_mouse	int
)	O
;	O
ExtMouseMode	function
(	O
fore	pointer
->	O
w_extmouse	int
)	O
;	O
}	O
}	O
int	O
DoStartLog	function
(	O
w	pointer
,	O
buf	pointer
,	O
bufsize	int
)	O
struct	O
win	struct
*	O
w	pointer
;	O
char	O
*	O
buf	pointer
;	O
int	O
bufsize	int
;	O
{	O
int	O
n	int
;	O
if	O
(	O
!	O
w	pointer
||	O
!	O
buf	pointer
)	O
return	O
-	O
1	int
;	O
strncpy	function
(	O
buf	pointer
,	O
MakeWinMsg	function
(	O
screenlogfile	pointer
,	O
w	pointer
,	O
'%'	O
)	O
,	O
bufsize	int
-	O
1	int
)	O
;	O
buf	pointer
[	O
bufsize	int
-	O
1	int
]	O
=	O
0	int
;	O
debug2	O
(	O
"DoStartLog: win %d, file %s\n"	pointer
,	O
w	pointer
->	O
w_number	int
,	O
buf	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
w_log	pointer
!=	O
NULL	O
)	O
logfclose	function
(	O
w	pointer
->	O
w_log	pointer
)	O
;	O
if	O
(	O
(	O
w	pointer
->	O
w_log	pointer
=	O
logfopen	function
(	O
buf	pointer
,	O
islogfile	function
(	O
buf	pointer
)	O
?	O
NULL	O
:	O
secfopen	function
(	O
buf	pointer
,	O
"a"	pointer
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
-	O
2	int
;	O
if	O
(	O
!	O
logflushev	struct
.	O
queued	int
)	O
{	O
n	int
=	O
log_flush	int
?	O
log_flush	int
:	O
(	O
logtstamp_after	int
+	O
4	int
)	O
/	O
5	int
;	O
if	O
(	O
n	int
)	O
{	O
SetTimeout	function
(	O
&	O
logflushev	struct
,	O
n	int
*	O
1000	int
)	O
;	O
evenq	function
(	O
&	O
logflushev	struct
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
MakeWindow	function
(	O
newwin	pointer
)	O
struct	O
NewWindow	struct
*	O
newwin	pointer
;	O
{	O
register	O
struct	O
win	struct
*	O
*	O
pp	pointer
,	O
*	O
p	pointer
;	O
register	O
int	O
n	int
,	O
i	pointer
;	O
int	O
f	int
=	O
-	O
1	int
;	O
struct	O
NewWindow	struct
nwin	struct
;	O
int	O
type	enum
,	O
startat	int
;	O
char	O
*	O
TtyName	pointer
;	O
extern	O
struct	O
acluser	struct
*	O
users	pointer
;	O
if	O
(	O
!	O
wtab	pointer
)	O
{	O
if	O
(	O
!	O
maxwin	int
)	O
maxwin	int
=	O
MAXWIN	int
;	O
wtab	pointer
=	O
calloc	function
(	O
maxwin	int
,	O
sizeof	O
(	O
struct	O
win	struct
*	O
)	O
)	O
;	O
}	O
debug1	O
(	O
"NewWindow: StartAt %d\n"	pointer
,	O
newwin	pointer
->	O
StartAt	int
)	O
;	O
debug1	O
(	O
"NewWindow: aka     %s\n"	pointer
,	O
newwin	pointer
->	O
aka	pointer
?	O
newwin	pointer
->	O
aka	pointer
:	O
"NULL"	pointer
)	O
;	O
debug1	O
(	O
"NewWindow: dir     %s\n"	pointer
,	O
newwin	pointer
->	O
dir	pointer
?	O
newwin	pointer
->	O
dir	pointer
:	O
"NULL"	pointer
)	O
;	O
debug1	O
(	O
"NewWindow: term    %s\n"	pointer
,	O
newwin	pointer
->	O
term	struct
?	O
newwin	pointer
->	O
term	struct
:	O
"NULL"	pointer
)	O
;	O
nwin_compose	function
(	O
&	O
nwin_default	struct
,	O
newwin	pointer
,	O
&	O
nwin	struct
)	O
;	O
debug1	O
(	O
"NWin: aka     %s\n"	pointer
,	O
nwin	struct
.	O
aka	pointer
?	O
nwin	struct
.	O
aka	pointer
:	O
"NULL"	pointer
)	O
;	O
debug1	O
(	O
"NWin: wlock   %d\n"	pointer
,	O
nwin	struct
.	O
wlock	int
)	O
;	O
debug1	O
(	O
"NWin: Lflag   %d\n"	pointer
,	O
nwin	struct
.	O
Lflag	int
)	O
;	O
startat	int
=	O
nwin	struct
.	O
StartAt	int
<	O
maxwin	int
?	O
nwin	struct
.	O
StartAt	int
:	O
0	int
;	O
pp	pointer
=	O
wtab	pointer
+	O
startat	int
;	O
do	O
{	O
if	O
(	O
*	O
pp	pointer
==	O
0	int
)	O
break	O
;	O
if	O
(	O
++	O
pp	pointer
==	O
wtab	pointer
+	O
maxwin	int
)	O
pp	pointer
=	O
wtab	pointer
;	O
}	O
while	O
(	O
pp	pointer
!=	O
wtab	pointer
+	O
startat	int
)	O
;	O
if	O
(	O
*	O
pp	pointer
)	O
{	O
Msg	function
(	O
0	int
,	O
"No more windows."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
n	int
=	O
pp	pointer
-	O
wtab	pointer
;	O
debug1	O
(	O
"Makewin creating %d\n"	pointer
,	O
n	int
)	O
;	O
if	O
(	O
(	O
f	int
=	O
OpenDevice	function
(	O
nwin	struct
.	O
args	pointer
,	O
nwin	struct
.	O
lflag	int
,	O
&	O
type	enum
,	O
&	O
TtyName	pointer
)	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
type	enum
==	O
W_TYPE_GROUP	int
)	O
f	int
=	O
-	O
1	int
;	O
if	O
(	O
(	O
p	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
win	struct
)	O
)	O
)	O
==	O
0	int
)	O
{	O
close	pointer
(	O
f	int
)	O
;	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
type	enum
!=	O
W_TYPE_PTY	int
)	O
nwin	struct
.	O
lflag	int
=	O
0	int
;	O
p	pointer
->	O
w_type	int
=	O
type	enum
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
nwin	struct
.	O
args	pointer
[	O
i	pointer
]	O
&&	O
i	pointer
<	O
MAXARGS	int
-	O
1	int
;	O
i	pointer
++	O
)	O
p	pointer
->	O
w_cmdargs	array
[	O
i	pointer
]	O
=	O
SaveStr	function
(	O
nwin	struct
.	O
args	pointer
[	O
i	pointer
]	O
)	O
;	O
p	pointer
->	O
w_cmdargs	array
[	O
i	pointer
]	O
=	O
0	int
;	O
if	O
(	O
nwin	struct
.	O
dir	pointer
)	O
p	pointer
->	O
w_dir	pointer
=	O
SaveStr	function
(	O
nwin	struct
.	O
dir	pointer
)	O
;	O
if	O
(	O
nwin	struct
.	O
term	struct
)	O
p	pointer
->	O
w_term	pointer
=	O
SaveStr	function
(	O
nwin	struct
.	O
term	struct
)	O
;	O
p	pointer
->	O
w_number	int
=	O
n	int
;	O
p	pointer
->	O
w_group	pointer
=	O
0	int
;	O
if	O
(	O
fore	pointer
&&	O
fore	pointer
->	O
w_type	int
==	O
W_TYPE_GROUP	int
)	O
p	pointer
->	O
w_group	pointer
=	O
fore	pointer
;	O
else	O
if	O
(	O
fore	pointer
&&	O
fore	pointer
->	O
w_group	pointer
)	O
p	pointer
->	O
w_group	pointer
=	O
fore	pointer
->	O
w_group	pointer
;	O
if	O
(	O
NewWindowAcl	function
(	O
p	pointer
,	O
display	struct
?	O
D_user	O
:	O
users	pointer
)	O
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
p	pointer
)	O
;	O
close	pointer
(	O
f	int
)	O
;	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
p	pointer
->	O
w_layer	struct
.	O
l_next	pointer
=	O
0	int
;	O
p	pointer
->	O
w_layer	struct
.	O
l_bottom	pointer
=	O
&	O
p	pointer
->	O
w_layer	struct
;	O
p	pointer
->	O
w_layer	struct
.	O
l_layfn	pointer
=	O
&	O
WinLf	struct
;	O
p	pointer
->	O
w_layer	struct
.	O
l_data	pointer
=	O
(	O
char	O
*	O
)	O
p	pointer
;	O
p	pointer
->	O
w_savelayer	pointer
=	O
&	O
p	pointer
->	O
w_layer	struct
;	O
p	pointer
->	O
w_pdisplay	pointer
=	O
0	int
;	O
p	pointer
->	O
w_lastdisp	pointer
=	O
0	int
;	O
if	O
(	O
display	struct
&&	O
!	O
AclCheckPermWin	function
(	O
D_user	O
,	O
ACL_WRITE	int
,	O
p	pointer
)	O
)	O
p	pointer
->	O
w_wlockuser	pointer
=	O
D_user	O
;	O
p	pointer
->	O
w_wlock	int
=	O
nwin	struct
.	O
wlock	int
;	O
p	pointer
->	O
w_ptyfd	int
=	O
f	int
;	O
p	pointer
->	O
w_aflag	int
=	O
nwin	struct
.	O
aflag	int
;	O
p	pointer
->	O
w_dynamicaka	int
=	O
nwin	struct
.	O
dynamicaka	int
;	O
p	pointer
->	O
w_flow	int
=	O
nwin	struct
.	O
flowflag	int
|	O
(	O
(	O
nwin	struct
.	O
flowflag	int
&	O
FLOW_AUTOFLAG	O
)	O
?	O
(	O
FLOW_AUTO	O
|	O
FLOW_NOW	O
)	O
:	O
FLOW_AUTO	O
)	O
;	O
if	O
(	O
!	O
nwin	struct
.	O
aka	pointer
)	O
nwin	struct
.	O
aka	pointer
=	O
Filename	function
(	O
nwin	struct
.	O
args	pointer
[	O
0	int
]	O
)	O
;	O
strncpy	function
(	O
p	pointer
->	O
w_akabuf	array
,	O
nwin	struct
.	O
aka	pointer
,	O
sizeof	O
(	O
p	pointer
->	O
w_akabuf	array
)	O
-	O
1	int
)	O
;	O
if	O
(	O
(	O
nwin	struct
.	O
aka	pointer
=	O
rindex	function
(	O
p	pointer
->	O
w_akabuf	array
,	O
'|'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
p	pointer
->	O
w_autoaka	int
=	O
0	int
;	O
*	O
nwin	struct
.	O
aka	pointer
++	O
=	O
0	int
;	O
p	pointer
->	O
w_title	pointer
=	O
nwin	struct
.	O
aka	pointer
;	O
p	pointer
->	O
w_akachange	pointer
=	O
nwin	struct
.	O
aka	pointer
+	O
strlen	function
(	O
nwin	struct
.	O
aka	pointer
)	O
;	O
}	O
else	O
p	pointer
->	O
w_title	pointer
=	O
p	pointer
->	O
w_akachange	pointer
=	O
p	pointer
->	O
w_akabuf	array
;	O
if	O
(	O
nwin	struct
.	O
hstatus	pointer
)	O
p	pointer
->	O
w_hstatus	pointer
=	O
SaveStr	function
(	O
nwin	struct
.	O
hstatus	pointer
)	O
;	O
p	pointer
->	O
w_monitor	int
=	O
nwin	struct
.	O
monitor	int
;	O
if	O
(	O
p	pointer
->	O
w_monitor	int
==	O
MON_ON	int
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
maxusercount	int
;	O
i	pointer
++	O
)	O
ACLBYTE	O
(	O
p	pointer
->	O
w_mon_notify	pointer
,	O
i	pointer
)	O
|=	O
ACLBIT	O
(	O
i	pointer
)	O
;	O
}	O
p	pointer
->	O
w_silence	int
=	O
nwin	struct
.	O
silence	int
;	O
p	pointer
->	O
w_silencewait	int
=	O
SilenceWait	int
;	O
if	O
(	O
p	pointer
->	O
w_silence	int
==	O
SILENCE_ON	int
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
maxusercount	int
;	O
i	pointer
++	O
)	O
ACLBYTE	O
(	O
p	pointer
->	O
w_lio_notify	pointer
,	O
i	pointer
)	O
|=	O
ACLBIT	O
(	O
i	pointer
)	O
;	O
}	O
p	pointer
->	O
w_slowpaste	int
=	O
nwin	struct
.	O
slow	int
;	O
p	pointer
->	O
w_norefresh	char
=	O
0	int
;	O
strncpy	function
(	O
p	pointer
->	O
w_tty	array
,	O
TtyName	pointer
,	O
MAXSTR	int
-	O
1	int
)	O
;	O
if	O
(	O
ChangeWindowSize	function
(	O
p	pointer
,	O
display	struct
?	O
D_forecv	O
->	O
c_xe	int
-	O
D_forecv	O
->	O
c_xs	int
+	O
1	int
:	O
80	int
,	O
display	struct
?	O
D_forecv	O
->	O
c_ye	int
-	O
D_forecv	O
->	O
c_ys	int
+	O
1	int
:	O
24	int
,	O
nwin	struct
.	O
histheight	int
)	O
)	O
{	O
FreeWindow	function
(	O
p	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
p	pointer
->	O
w_encoding	O
=	O
nwin	struct
.	O
encoding	int
;	O
ResetWindow	function
(	O
p	pointer
)	O
;	O
if	O
(	O
nwin	struct
.	O
charset	pointer
)	O
SetCharsets	function
(	O
p	pointer
,	O
nwin	struct
.	O
charset	pointer
)	O
;	O
if	O
(	O
VerboseCreate	int
&&	O
type	enum
!=	O
W_TYPE_GROUP	int
)	O
{	O
struct	O
display	struct
*	O
d	int
=	O
display	struct
;	O
WriteString	function
(	O
p	pointer
,	O
":screen ("	pointer
,	O
9	int
)	O
;	O
WriteString	function
(	O
p	pointer
,	O
p	pointer
->	O
w_title	pointer
,	O
strlen	function
(	O
p	pointer
->	O
w_title	pointer
)	O
)	O
;	O
WriteString	function
(	O
p	pointer
,	O
"):"	pointer
,	O
2	int
)	O
;	O
for	O
(	O
f	int
=	O
0	int
;	O
p	pointer
->	O
w_cmdargs	array
[	O
f	int
]	O
;	O
f	int
++	O
)	O
{	O
WriteString	function
(	O
p	pointer
,	O
" "	pointer
,	O
1	int
)	O
;	O
WriteString	function
(	O
p	pointer
,	O
p	pointer
->	O
w_cmdargs	array
[	O
f	int
]	O
,	O
strlen	function
(	O
p	pointer
->	O
w_cmdargs	array
[	O
f	int
]	O
)	O
)	O
;	O
}	O
WriteString	function
(	O
p	pointer
,	O
"\r\n"	pointer
,	O
2	int
)	O
;	O
display	struct
=	O
d	int
;	O
}	O
p	pointer
->	O
w_deadpid	int
=	O
0	int
;	O
p	pointer
->	O
w_pid	int
=	O
0	int
;	O
p	pointer
->	O
w_pwin	pointer
=	O
0	int
;	O
if	O
(	O
type	enum
==	O
W_TYPE_PTY	int
)	O
{	O
p	pointer
->	O
w_pid	int
=	O
ForkWindow	function
(	O
p	pointer
,	O
nwin	struct
.	O
args	pointer
,	O
TtyName	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
w_pid	int
<	O
0	int
)	O
{	O
FreeWindow	function
(	O
p	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
display	struct
&&	O
D_fore	O
)	O
D_other	O
=	O
D_fore	O
;	O
*	O
pp	pointer
=	O
p	pointer
;	O
p	pointer
->	O
w_next	pointer
=	O
windows	pointer
;	O
windows	pointer
=	O
p	pointer
;	O
if	O
(	O
type	enum
==	O
W_TYPE_GROUP	int
)	O
{	O
SetForeWindow	function
(	O
p	pointer
)	O
;	O
Activate	function
(	O
p	pointer
->	O
w_norefresh	char
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'w'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'W'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
0	int
)	O
;	O
return	O
n	int
;	O
}	O
p	pointer
->	O
w_lflag	int
=	O
nwin	struct
.	O
lflag	int
;	O
p	pointer
->	O
w_slot	pointer
=	O
(	O
slot_t	pointer
)	O
-	O
1	int
;	O
debug1	O
(	O
"MakeWindow will %slog in.\n"	pointer
,	O
nwin	struct
.	O
lflag	int
?	O
""	pointer
:	O
"not "	pointer
)	O
;	O
if	O
(	O
nwin	struct
.	O
lflag	int
&	O
1	int
)	O
{	O
p	pointer
->	O
w_slot	pointer
=	O
(	O
slot_t	pointer
)	O
0	int
;	O
if	O
(	O
display	struct
||	O
(	O
p	pointer
->	O
w_lflag	int
&	O
2	int
)	O
)	O
SetUtmp	function
(	O
p	pointer
)	O
;	O
}	O
if	O
(	O
nwin	struct
.	O
Lflag	int
)	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
DoStartLog	function
(	O
p	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
}	O
if	O
(	O
nwin	struct
.	O
poll_zombie_timeout	int
)	O
p	pointer
->	O
w_poll_zombie_timeout	int
=	O
nwin	struct
.	O
poll_zombie_timeout	int
;	O
p	pointer
->	O
w_zombieev	struct
.	O
type	enum
=	O
EV_TIMEOUT	int
;	O
p	pointer
->	O
w_zombieev	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
p	pointer
;	O
p	pointer
->	O
w_zombieev	struct
.	O
handler	pointer
=	O
win_resurrect_zombie_fn	function
;	O
p	pointer
->	O
w_readev	struct
.	O
fd	int
=	O
p	pointer
->	O
w_writeev	struct
.	O
fd	int
=	O
p	pointer
->	O
w_ptyfd	int
;	O
p	pointer
->	O
w_readev	struct
.	O
type	enum
=	O
EV_READ	int
;	O
p	pointer
->	O
w_writeev	struct
.	O
type	enum
=	O
EV_WRITE	int
;	O
p	pointer
->	O
w_readev	struct
.	O
data	pointer
=	O
p	pointer
->	O
w_writeev	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
p	pointer
;	O
p	pointer
->	O
w_readev	struct
.	O
handler	pointer
=	O
win_readev_fn	function
;	O
p	pointer
->	O
w_writeev	struct
.	O
handler	pointer
=	O
win_writeev_fn	function
;	O
p	pointer
->	O
w_writeev	struct
.	O
condpos	pointer
=	O
&	O
p	pointer
->	O
w_inlen	int
;	O
evenq	function
(	O
&	O
p	pointer
->	O
w_readev	struct
)	O
;	O
evenq	function
(	O
&	O
p	pointer
->	O
w_writeev	struct
)	O
;	O
p	pointer
->	O
w_paster	struct
.	O
pa_slowev	struct
.	O
type	enum
=	O
EV_TIMEOUT	int
;	O
p	pointer
->	O
w_paster	struct
.	O
pa_slowev	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
&	O
p	pointer
->	O
w_paster	struct
;	O
p	pointer
->	O
w_paster	struct
.	O
pa_slowev	struct
.	O
handler	pointer
=	O
paste_slowev_fn	function
;	O
p	pointer
->	O
w_silenceev	struct
.	O
type	enum
=	O
EV_TIMEOUT	int
;	O
p	pointer
->	O
w_silenceev	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
p	pointer
;	O
p	pointer
->	O
w_silenceev	struct
.	O
handler	pointer
=	O
win_silenceev_fn	function
;	O
if	O
(	O
p	pointer
->	O
w_silence	int
>	O
0	int
)	O
{	O
debug	O
(	O
"New window has silence enabled.\n"	pointer
)	O
;	O
SetTimeout	function
(	O
&	O
p	pointer
->	O
w_silenceev	struct
,	O
p	pointer
->	O
w_silencewait	int
*	O
1000	int
)	O
;	O
evenq	function
(	O
&	O
p	pointer
->	O
w_silenceev	struct
)	O
;	O
}	O
p	pointer
->	O
w_destroyev	struct
.	O
type	enum
=	O
EV_TIMEOUT	int
;	O
p	pointer
->	O
w_destroyev	struct
.	O
data	pointer
=	O
0	int
;	O
p	pointer
->	O
w_destroyev	struct
.	O
handler	pointer
=	O
win_destroyev_fn	function
;	O
SetForeWindow	function
(	O
p	pointer
)	O
;	O
Activate	function
(	O
p	pointer
->	O
w_norefresh	char
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'w'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'W'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
0	int
)	O
;	O
return	O
n	int
;	O
}	O
int	O
RemakeWindow	function
(	O
p	pointer
)	O
struct	O
win	struct
*	O
p	pointer
;	O
{	O
char	O
*	O
TtyName	pointer
;	O
int	O
lflag	int
,	O
f	int
;	O
lflag	int
=	O
nwin_default	struct
.	O
lflag	int
;	O
if	O
(	O
(	O
f	int
=	O
OpenDevice	function
(	O
p	pointer
->	O
w_cmdargs	array
,	O
lflag	int
,	O
&	O
p	pointer
->	O
w_type	int
,	O
&	O
TtyName	pointer
)	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
evdeq	function
(	O
&	O
p	pointer
->	O
w_destroyev	struct
)	O
;	O
strncpy	function
(	O
p	pointer
->	O
w_tty	array
,	O
*	O
TtyName	pointer
?	O
TtyName	pointer
:	O
p	pointer
->	O
w_title	pointer
,	O
MAXSTR	int
-	O
1	int
)	O
;	O
p	pointer
->	O
w_ptyfd	int
=	O
f	int
;	O
p	pointer
->	O
w_readev	struct
.	O
fd	int
=	O
f	int
;	O
p	pointer
->	O
w_writeev	struct
.	O
fd	int
=	O
f	int
;	O
evenq	function
(	O
&	O
p	pointer
->	O
w_readev	struct
)	O
;	O
evenq	function
(	O
&	O
p	pointer
->	O
w_writeev	struct
)	O
;	O
if	O
(	O
VerboseCreate	int
)	O
{	O
struct	O
display	struct
*	O
d	int
=	O
display	struct
;	O
WriteString	function
(	O
p	pointer
,	O
":screen ("	pointer
,	O
9	int
)	O
;	O
WriteString	function
(	O
p	pointer
,	O
p	pointer
->	O
w_title	pointer
,	O
strlen	function
(	O
p	pointer
->	O
w_title	pointer
)	O
)	O
;	O
WriteString	function
(	O
p	pointer
,	O
"):"	pointer
,	O
2	int
)	O
;	O
for	O
(	O
f	int
=	O
0	int
;	O
p	pointer
->	O
w_cmdargs	array
[	O
f	int
]	O
;	O
f	int
++	O
)	O
{	O
WriteString	function
(	O
p	pointer
,	O
" "	pointer
,	O
1	int
)	O
;	O
WriteString	function
(	O
p	pointer
,	O
p	pointer
->	O
w_cmdargs	array
[	O
f	int
]	O
,	O
strlen	function
(	O
p	pointer
->	O
w_cmdargs	array
[	O
f	int
]	O
)	O
)	O
;	O
}	O
WriteString	function
(	O
p	pointer
,	O
"\r\n"	pointer
,	O
2	int
)	O
;	O
display	struct
=	O
d	int
;	O
}	O
p	pointer
->	O
w_deadpid	int
=	O
0	int
;	O
p	pointer
->	O
w_pid	int
=	O
0	int
;	O
if	O
(	O
p	pointer
->	O
w_type	int
==	O
W_TYPE_PTY	int
)	O
{	O
p	pointer
->	O
w_pid	int
=	O
ForkWindow	function
(	O
p	pointer
,	O
p	pointer
->	O
w_cmdargs	array
,	O
TtyName	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
w_pid	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
p	pointer
->	O
w_slot	pointer
==	O
(	O
slot_t	pointer
)	O
0	int
&&	O
(	O
display	struct
||	O
(	O
p	pointer
->	O
w_lflag	int
&	O
2	int
)	O
)	O
)	O
SetUtmp	function
(	O
p	pointer
)	O
;	O
WindowChanged	function
(	O
p	pointer
,	O
'f'	O
)	O
;	O
return	O
p	pointer
->	O
w_number	int
;	O
}	O
void	O
CloseDevice	function
(	O
wp	pointer
)	O
struct	O
win	struct
*	O
wp	pointer
;	O
{	O
if	O
(	O
wp	pointer
->	O
w_ptyfd	int
<	O
0	int
)	O
return	O
;	O
if	O
(	O
wp	pointer
->	O
w_type	int
==	O
W_TYPE_PTY	int
)	O
{	O
(	O
void	O
)	O
chmod	function
(	O
wp	pointer
->	O
w_tty	array
,	O
0666	int
)	O
;	O
(	O
void	O
)	O
chown	function
(	O
wp	pointer
->	O
w_tty	array
,	O
0	int
,	O
0	int
)	O
;	O
}	O
close	pointer
(	O
wp	pointer
->	O
w_ptyfd	int
)	O
;	O
wp	pointer
->	O
w_ptyfd	int
=	O
-	O
1	int
;	O
wp	pointer
->	O
w_tty	array
[	O
0	int
]	O
=	O
0	int
;	O
evdeq	function
(	O
&	O
wp	pointer
->	O
w_readev	struct
)	O
;	O
evdeq	function
(	O
&	O
wp	pointer
->	O
w_writeev	struct
)	O
;	O
wp	pointer
->	O
w_readev	struct
.	O
fd	int
=	O
wp	pointer
->	O
w_writeev	struct
.	O
fd	int
=	O
-	O
1	int
;	O
}	O
void	O
FreeWindow	function
(	O
wp	pointer
)	O
struct	O
win	struct
*	O
wp	pointer
;	O
{	O
struct	O
display	struct
*	O
d	int
;	O
int	O
i	pointer
;	O
struct	O
canvas	struct
*	O
cv	pointer
,	O
*	O
ncv	pointer
;	O
struct	O
layer	struct
*	O
l	int
;	O
debug1	O
(	O
"FreeWindow %d\n"	pointer
,	O
wp	pointer
?	O
wp	pointer
->	O
w_number	int
:	O
-	O
1	int
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_pwin	pointer
)	O
FreePseudowin	function
(	O
wp	pointer
)	O
;	O
RemoveUtmp	function
(	O
wp	pointer
)	O
;	O
CloseDevice	function
(	O
wp	pointer
)	O
;	O
if	O
(	O
wp	pointer
==	O
console_window	pointer
)	O
{	O
TtyGrabConsole	function
(	O
-	O
1	int
,	O
-	O
1	int
,	O
"free"	pointer
)	O
;	O
console_window	pointer
=	O
0	int
;	O
}	O
if	O
(	O
wp	pointer
->	O
w_log	pointer
!=	O
NULL	O
)	O
logfclose	function
(	O
wp	pointer
->	O
w_log	pointer
)	O
;	O
ChangeWindowSize	function
(	O
wp	pointer
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_type	int
==	O
W_TYPE_GROUP	int
)	O
{	O
struct	O
win	struct
*	O
win	struct
;	O
for	O
(	O
win	struct
=	O
windows	pointer
;	O
win	struct
;	O
win	struct
=	O
win	struct
->	O
w_next	pointer
)	O
if	O
(	O
win	struct
->	O
w_group	pointer
==	O
wp	pointer
)	O
win	struct
->	O
w_group	pointer
=	O
wp	pointer
->	O
w_group	pointer
;	O
}	O
if	O
(	O
wp	pointer
->	O
w_hstatus	pointer
)	O
free	function
(	O
wp	pointer
->	O
w_hstatus	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
wp	pointer
->	O
w_cmdargs	array
[	O
i	pointer
]	O
;	O
i	pointer
++	O
)	O
free	function
(	O
wp	pointer
->	O
w_cmdargs	array
[	O
i	pointer
]	O
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_dir	pointer
)	O
free	function
(	O
wp	pointer
->	O
w_dir	pointer
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_term	pointer
)	O
free	function
(	O
wp	pointer
->	O
w_term	pointer
)	O
;	O
for	O
(	O
d	int
=	O
displays	pointer
;	O
d	int
;	O
d	int
=	O
d	int
->	O
d_next	pointer
)	O
{	O
if	O
(	O
d	int
->	O
d_other	pointer
==	O
wp	pointer
)	O
d	int
->	O
d_other	pointer
=	O
d	int
->	O
d_fore	pointer
&&	O
d	int
->	O
d_fore	pointer
->	O
w_next	pointer
!=	O
wp	pointer
?	O
d	int
->	O
d_fore	pointer
->	O
w_next	pointer
:	O
wp	pointer
->	O
w_next	pointer
;	O
if	O
(	O
d	int
->	O
d_fore	pointer
==	O
wp	pointer
)	O
d	int
->	O
d_fore	pointer
=	O
NULL	O
;	O
for	O
(	O
cv	pointer
=	O
d	int
->	O
d_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
for	O
(	O
l	int
=	O
cv	pointer
->	O
c_layer	pointer
;	O
l	int
;	O
l	int
=	O
l	int
->	O
l_next	pointer
)	O
if	O
(	O
l	int
->	O
l_layfn	pointer
==	O
&	O
WinLf	struct
)	O
break	O
;	O
if	O
(	O
!	O
l	int
)	O
continue	O
;	O
if	O
(	O
(	O
struct	O
win	struct
*	O
)	O
l	int
->	O
l_data	pointer
!=	O
wp	pointer
)	O
continue	O
;	O
if	O
(	O
cv	pointer
->	O
c_layer	pointer
==	O
wp	pointer
->	O
w_savelayer	pointer
)	O
wp	pointer
->	O
w_savelayer	pointer
=	O
0	int
;	O
KillLayerChain	function
(	O
cv	pointer
->	O
c_layer	pointer
)	O
;	O
}	O
}	O
if	O
(	O
wp	pointer
->	O
w_savelayer	pointer
)	O
KillLayerChain	function
(	O
wp	pointer
->	O
w_savelayer	pointer
)	O
;	O
for	O
(	O
cv	pointer
=	O
wp	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
ncv	pointer
)	O
{	O
ncv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
;	O
cv	pointer
->	O
c_layer	pointer
=	O
&	O
cv	pointer
->	O
c_blank	struct
;	O
cv	pointer
->	O
c_blank	struct
.	O
l_cvlist	pointer
=	O
cv	pointer
;	O
cv	pointer
->	O
c_lnext	pointer
=	O
0	int
;	O
cv	pointer
->	O
c_xoff	int
=	O
cv	pointer
->	O
c_xs	int
;	O
cv	pointer
->	O
c_yoff	int
=	O
cv	pointer
->	O
c_ys	int
;	O
RethinkViewportOffsets	function
(	O
cv	pointer
)	O
;	O
}	O
wp	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
=	O
0	int
;	O
if	O
(	O
flayer	pointer
==	O
&	O
wp	pointer
->	O
w_layer	struct
)	O
flayer	pointer
=	O
0	int
;	O
LayerCleanupMemory	function
(	O
&	O
wp	pointer
->	O
w_layer	struct
)	O
;	O
FreeWindowAcl	function
(	O
wp	pointer
)	O
;	O
evdeq	function
(	O
&	O
wp	pointer
->	O
w_readev	struct
)	O
;	O
evdeq	function
(	O
&	O
wp	pointer
->	O
w_writeev	struct
)	O
;	O
evdeq	function
(	O
&	O
wp	pointer
->	O
w_silenceev	struct
)	O
;	O
evdeq	function
(	O
&	O
wp	pointer
->	O
w_zombieev	struct
)	O
;	O
evdeq	function
(	O
&	O
wp	pointer
->	O
w_destroyev	struct
)	O
;	O
FreePaster	function
(	O
&	O
wp	pointer
->	O
w_paster	struct
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
wp	pointer
)	O
;	O
}	O
int	O
OpenDevice	function
(	O
args	pointer
,	O
lflag	int
,	O
typep	pointer
,	O
namep	pointer
)	O
char	O
*	O
*	O
args	pointer
;	O
int	O
lflag	int
;	O
int	O
*	O
typep	pointer
;	O
char	O
*	O
*	O
namep	pointer
;	O
{	O
char	O
*	O
arg	pointer
=	O
args	pointer
[	O
0	int
]	O
;	O
struct	O
stat	struct
st	pointer
;	O
int	O
f	int
;	O
if	O
(	O
!	O
arg	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
strcmp	function
(	O
arg	pointer
,	O
"//group"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
typep	pointer
=	O
W_TYPE_GROUP	int
;	O
*	O
namep	pointer
=	O
"telnet"	pointer
;	O
return	O
0	int
;	O
}	O
if	O
(	O
strncmp	function
(	O
arg	pointer
,	O
"//"	pointer
,	O
2	int
)	O
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Invalid argument '%s'"	pointer
,	O
arg	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
stat	struct
(	O
arg	pointer
,	O
&	O
st	pointer
)	O
)	O
==	O
0	int
&&	O
S_ISCHR	O
(	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
access	function
(	O
arg	pointer
,	O
R_OK	int
|	O
W_OK	int
)	O
==	O
-	O
1	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"Cannot access line '%s' for R/W"	pointer
,	O
arg	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
debug	O
(	O
"OpenDevice: OpenTTY\n"	pointer
)	O
;	O
if	O
(	O
(	O
f	int
=	O
OpenTTY	function
(	O
arg	pointer
,	O
args	pointer
[	O
1	int
]	O
)	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
lflag	int
=	O
0	int
;	O
*	O
typep	pointer
=	O
W_TYPE_PLAIN	int
;	O
*	O
namep	pointer
=	O
arg	pointer
;	O
}	O
else	O
{	O
*	O
typep	pointer
=	O
W_TYPE_PTY	int
;	O
f	int
=	O
OpenPTY	function
(	O
namep	pointer
)	O
;	O
if	O
(	O
f	int
==	O
-	O
1	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"No more PTYs."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
{	O
int	O
flag	int
=	O
1	int
;	O
if	O
(	O
ioctl	function
(	O
f	int
,	O
TIOCPKT	int
,	O
(	O
char	O
*	O
)	O
&	O
flag	int
)	O
)	O
{	O
Msg	function
(	O
errno	O
,	O
"TIOCPKT ioctl"	pointer
)	O
;	O
close	pointer
(	O
f	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
debug1	O
(	O
"fcntl(%d, F_SETFL, FNBLOCK)\n"	pointer
,	O
f	int
)	O
;	O
(	O
void	O
)	O
fcntl	function
(	O
f	int
,	O
F_SETFL	int
,	O
FNBLOCK	O
)	O
;	O
if	O
(	O
*	O
typep	pointer
==	O
W_TYPE_PTY	int
||	O
*	O
typep	pointer
==	O
W_TYPE_PLAIN	int
)	O
tcflush	function
(	O
f	int
,	O
TCIOFLUSH	int
)	O
;	O
if	O
(	O
*	O
typep	pointer
!=	O
W_TYPE_PTY	int
)	O
return	O
f	int
;	O
if	O
(	O
chown	function
(	O
*	O
namep	pointer
,	O
real_uid	int
,	O
PTYGROUP	int
)	O
&&	O
!	O
eff_uid	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"chown tty"	pointer
)	O
;	O
close	pointer
(	O
f	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
chmod	function
(	O
*	O
namep	pointer
,	O
lflag	int
?	O
TtyMode	int
:	O
(	O
TtyMode	int
&	O
~	O
022	int
)	O
)	O
&&	O
!	O
eff_uid	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"chmod tty"	pointer
)	O
;	O
close	pointer
(	O
f	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
f	int
;	O
}	O
static	O
int	O
ForkWindow	function
(	O
win	struct
,	O
args	pointer
,	O
ttyn	pointer
)	O
struct	O
win	struct
*	O
win	struct
;	O
char	O
*	O
*	O
args	pointer
,	O
*	O
ttyn	pointer
;	O
{	O
int	O
pid	int
;	O
char	O
tebuf	array
[	O
MAXTERMLEN	int
+	O
5	int
+	O
1	int
]	O
;	O
char	O
ebuf	array
[	O
20	int
]	O
;	O
char	O
shellbuf	array
[	O
7	int
+	O
MAXPATHLEN	O
]	O
;	O
char	O
*	O
proc	pointer
;	O
int	O
newfd	int
;	O
int	O
w	pointer
=	O
win	struct
->	O
w_width	O
;	O
int	O
h	int
=	O
win	struct
->	O
w_height	O
;	O
int	O
i	pointer
,	O
pat	int
,	O
wfdused	int
;	O
struct	O
pseudowin	struct
*	O
pwin	pointer
=	O
win	struct
->	O
w_pwin	pointer
;	O
int	O
slave	int
=	O
-	O
1	int
;	O
if	O
(	O
pty_preopen	int
)	O
{	O
debug	O
(	O
"pre-opening slave...\n"	pointer
)	O
;	O
if	O
(	O
(	O
slave	int
=	O
open	function
(	O
ttyn	pointer
,	O
O_RDWR	int
|	O
O_NOCTTY	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
Msg	function
(	O
errno	O
,	O
"ttyn"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
debug	O
(	O
"forking...\n"	pointer
)	O
;	O
proc	pointer
=	O
*	O
args	pointer
;	O
if	O
(	O
proc	pointer
==	O
0	int
)	O
{	O
args	pointer
=	O
ShellArgs	array
;	O
proc	pointer
=	O
*	O
args	pointer
;	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
switch	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
{	O
case	O
-	O
1	int
:	O
Msg	function
(	O
errno	O
,	O
"fork"	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
signal	function
(	O
SIGHUP	int
,	O
SIG_DFL	O
)	O
;	O
signal	function
(	O
SIGINT	int
,	O
SIG_DFL	O
)	O
;	O
signal	function
(	O
SIGQUIT	int
,	O
SIG_DFL	O
)	O
;	O
signal	function
(	O
SIGTERM	int
,	O
SIG_DFL	O
)	O
;	O
signal	function
(	O
SIGTTIN	int
,	O
SIG_DFL	O
)	O
;	O
signal	function
(	O
SIGTTOU	int
,	O
SIG_DFL	O
)	O
;	O
signal	function
(	O
SIGPIPE	int
,	O
SIG_DFL	O
)	O
;	O
signal	function
(	O
SIGXFSZ	int
,	O
SIG_DFL	O
)	O
;	O
displays	pointer
=	O
0	int
;	O
ServerSocket	int
=	O
-	O
1	int
;	O
if	O
(	O
setgid	function
(	O
real_gid	int
)	O
||	O
setuid	function
(	O
real_uid	int
)	O
)	O
Panic	function
(	O
errno	O
,	O
"Setuid/gid"	pointer
)	O
;	O
eff_uid	int
=	O
real_uid	int
;	O
eff_gid	int
=	O
real_gid	int
;	O
if	O
(	O
!	O
pwin	pointer
)	O
if	O
(	O
win	struct
->	O
w_dir	pointer
&&	O
*	O
win	struct
->	O
w_dir	pointer
&&	O
chdir	function
(	O
win	struct
->	O
w_dir	pointer
)	O
)	O
Panic	function
(	O
errno	O
,	O
"Cannot chdir to %s"	pointer
,	O
win	struct
->	O
w_dir	pointer
)	O
;	O
if	O
(	O
display	struct
)	O
{	O
brktty	function
(	O
D_userfd	O
)	O
;	O
freetty	function
(	O
)	O
;	O
}	O
else	O
brktty	function
(	O
-	O
1	int
)	O
;	O
if	O
(	O
slave	int
!=	O
-	O
1	int
)	O
{	O
close	pointer
(	O
0	int
)	O
;	O
dup	function
(	O
slave	int
)	O
;	O
close	pointer
(	O
slave	int
)	O
;	O
closeallfiles	function
(	O
win	struct
->	O
w_ptyfd	int
)	O
;	O
slave	int
=	O
dup	function
(	O
0	int
)	O
;	O
}	O
else	O
closeallfiles	function
(	O
win	struct
->	O
w_ptyfd	int
)	O
;	O
close	pointer
(	O
0	int
)	O
;	O
close	pointer
(	O
1	int
)	O
;	O
close	pointer
(	O
2	int
)	O
;	O
newfd	int
=	O
-	O
1	int
;	O
pat	int
=	O
pwin	pointer
?	O
pwin	pointer
->	O
p_fdpat	int
:	O
(	O
(	O
F_PFRONT	int
<<	O
(	O
F_PSHIFT	int
*	O
2	int
)	O
)	O
|	O
(	O
F_PFRONT	int
<<	O
F_PSHIFT	int
)	O
|	O
F_PFRONT	int
)	O
;	O
debug1	O
(	O
"Using window pattern 0x%x\n"	pointer
,	O
pat	int
)	O
;	O
wfdused	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
3	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
pat	int
&	O
F_PFRONT	int
<<	O
F_PSHIFT	int
*	O
i	pointer
)	O
{	O
if	O
(	O
newfd	int
<	O
0	int
)	O
{	O
if	O
(	O
separate_sids	int
)	O
newfd	int
=	O
open	function
(	O
ttyn	pointer
,	O
O_RDWR	int
)	O
;	O
else	O
newfd	int
=	O
open	function
(	O
ttyn	pointer
,	O
O_RDWR	int
|	O
O_NOCTTY	int
)	O
;	O
if	O
(	O
newfd	int
<	O
0	int
)	O
Panic	function
(	O
errno	O
,	O
"Cannot open %s"	pointer
,	O
ttyn	pointer
)	O
;	O
}	O
else	O
dup	function
(	O
newfd	int
)	O
;	O
}	O
else	O
{	O
dup	function
(	O
win	struct
->	O
w_ptyfd	int
)	O
;	O
wfdused	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
wfdused	int
)	O
{	O
debug1	O
(	O
"Clearing NBLOCK on window-fd(%d)\n"	pointer
,	O
win	struct
->	O
w_ptyfd	int
)	O
;	O
if	O
(	O
fcntl	function
(	O
win	struct
->	O
w_ptyfd	int
,	O
F_SETFL	int
,	O
0	int
)	O
)	O
Msg	function
(	O
errno	O
,	O
"Warning: clear NBLOCK fcntl failed"	pointer
)	O
;	O
}	O
close	pointer
(	O
win	struct
->	O
w_ptyfd	int
)	O
;	O
if	O
(	O
slave	int
!=	O
-	O
1	int
)	O
close	pointer
(	O
slave	int
)	O
;	O
if	O
(	O
newfd	int
>=	O
0	int
)	O
{	O
struct	O
mode	struct
fakemode	struct
,	O
*	O
modep	pointer
;	O
InitPTY	function
(	O
newfd	int
)	O
;	O
if	O
(	O
fgtty	function
(	O
newfd	int
)	O
)	O
Msg	function
(	O
errno	O
,	O
"fgtty"	pointer
)	O
;	O
if	O
(	O
display	struct
)	O
{	O
debug	O
(	O
"ForkWindow: using display tty mode for new child.\n"	pointer
)	O
;	O
modep	pointer
=	O
&	O
D_OldMode	O
;	O
}	O
else	O
{	O
debug	O
(	O
"No display - creating tty setting\n"	pointer
)	O
;	O
modep	pointer
=	O
&	O
fakemode	struct
;	O
InitTTY	function
(	O
modep	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
pwin	pointer
&&	O
(	O
!	O
(	O
pat	int
&	O
F_UWP	int
)	O
||	O
(	O
pat	int
&	O
F_PBACK	int
<<	O
F_PSHIFT	int
)	O
)	O
)	O
{	O
debug1	O
(	O
"clearing echo on pseudywin fd (pat %x)\n"	pointer
,	O
pat	int
)	O
;	O
modep	pointer
->	O
tio	struct
.	O
c_lflag	short
&=	O
~	O
ECHO	int
;	O
modep	pointer
->	O
tio	struct
.	O
c_iflag	short
&=	O
~	O
ICRNL	int
;	O
}	O
SetTTY	function
(	O
newfd	int
,	O
modep	pointer
)	O
;	O
glwz	struct
.	O
ws_col	short
=	O
w	pointer
;	O
glwz	struct
.	O
ws_row	short
=	O
h	int
;	O
(	O
void	O
)	O
ioctl	function
(	O
newfd	int
,	O
TIOCSWINSZ	int
,	O
(	O
char	O
*	O
)	O
&	O
glwz	struct
)	O
;	O
(	O
void	O
)	O
fcntl	function
(	O
newfd	int
,	O
F_SETFL	int
,	O
0	int
)	O
;	O
}	O
NewEnv	pointer
[	O
2	int
]	O
=	O
MakeTermcap	function
(	O
display	struct
==	O
0	int
||	O
win	struct
->	O
w_aflag	int
)	O
;	O
strcpy	function
(	O
shellbuf	array
,	O
"SHELL="	pointer
)	O
;	O
strncpy	function
(	O
shellbuf	array
+	O
6	int
,	O
ShellProg	pointer
+	O
(	O
*	O
ShellProg	pointer
==	O
'-'	O
)	O
,	O
sizeof	O
(	O
shellbuf	array
)	O
-	O
7	int
)	O
;	O
shellbuf	array
[	O
sizeof	O
(	O
shellbuf	array
)	O
-	O
1	int
]	O
=	O
0	int
;	O
NewEnv	pointer
[	O
4	int
]	O
=	O
shellbuf	array
;	O
debug1	O
(	O
"ForkWindow: NewEnv[4] = '%s'\n"	pointer
,	O
shellbuf	array
)	O
;	O
if	O
(	O
win	struct
->	O
w_term	pointer
&&	O
*	O
win	struct
->	O
w_term	pointer
&&	O
strcmp	function
(	O
screenterm	array
,	O
win	struct
->	O
w_term	pointer
)	O
&&	O
(	O
strlen	function
(	O
win	struct
->	O
w_term	pointer
)	O
<	O
MAXTERMLEN	int
)	O
)	O
{	O
char	O
*	O
s1	pointer
,	O
*	O
s2	pointer
,	O
tl	char
;	O
snprintf	function
(	O
tebuf	array
,	O
sizeof	O
(	O
tebuf	array
)	O
,	O
"TERM=%s"	pointer
,	O
win	struct
->	O
w_term	pointer
)	O
;	O
debug2	O
(	O
"Makewindow %d with %s\n"	pointer
,	O
win	struct
->	O
w_number	int
,	O
tebuf	array
)	O
;	O
tl	char
=	O
strlen	function
(	O
win	struct
->	O
w_term	pointer
)	O
;	O
NewEnv	pointer
[	O
1	int
]	O
=	O
tebuf	array
;	O
if	O
(	O
(	O
s1	pointer
=	O
index	function
(	O
NewEnv	pointer
[	O
2	int
]	O
,	O
'|'	O
)	O
)	O
)	O
{	O
if	O
(	O
(	O
s2	pointer
=	O
index	function
(	O
++	O
s1	pointer
,	O
'|'	O
)	O
)	O
)	O
{	O
if	O
(	O
strlen	function
(	O
NewEnv	pointer
[	O
2	int
]	O
)	O
-	O
(	O
s2	pointer
-	O
s1	pointer
)	O
+	O
tl	char
<	O
1024	int
)	O
{	O
bcopy	function
(	O
s2	pointer
,	O
s1	pointer
+	O
tl	char
,	O
strlen	function
(	O
s2	pointer
)	O
+	O
1	int
)	O
;	O
bcopy	function
(	O
win	struct
->	O
w_term	pointer
,	O
s1	pointer
,	O
tl	char
)	O
;	O
}	O
}	O
}	O
}	O
snprintf	function
(	O
ebuf	array
,	O
sizeof	O
(	O
ebuf	array
)	O
,	O
"WINDOW=%d"	pointer
,	O
win	struct
->	O
w_number	int
)	O
;	O
NewEnv	pointer
[	O
3	int
]	O
=	O
ebuf	array
;	O
if	O
(	O
*	O
proc	pointer
==	O
'-'	O
)	O
proc	pointer
++	O
;	O
if	O
(	O
!	O
*	O
proc	pointer
)	O
proc	pointer
=	O
DefaultShell	array
;	O
debug1	O
(	O
"calling execvpe %s\n"	pointer
,	O
proc	pointer
)	O
;	O
execvpe	function
(	O
proc	pointer
,	O
args	pointer
,	O
NewEnv	pointer
)	O
;	O
debug1	O
(	O
"exec error: %d\n"	pointer
,	O
errno	O
)	O
;	O
Panic	function
(	O
errno	O
,	O
"Cannot exec '%s'"	pointer
,	O
proc	pointer
)	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
slave	int
!=	O
-	O
1	int
)	O
close	pointer
(	O
slave	int
)	O
;	O
return	O
pid	int
;	O
}	O
int	O
winexec	function
(	O
av	pointer
)	O
char	O
*	O
*	O
av	pointer
;	O
{	O
char	O
*	O
*	O
pp	pointer
;	O
char	O
*	O
p	pointer
,	O
*	O
s	pointer
,	O
*	O
t	pointer
;	O
int	O
i	pointer
,	O
r	int
=	O
0	int
,	O
l	int
=	O
0	int
;	O
struct	O
win	struct
*	O
w	pointer
;	O
extern	O
struct	O
display	struct
*	O
display	struct
;	O
extern	O
struct	O
win	struct
*	O
windows	pointer
;	O
struct	O
pseudowin	struct
*	O
pwin	pointer
;	O
int	O
type	enum
;	O
if	O
(	O
(	O
w	pointer
=	O
display	struct
?	O
fore	pointer
:	O
windows	pointer
)	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
*	O
av	pointer
||	O
w	pointer
->	O
w_pwin	pointer
)	O
{	O
Msg	function
(	O
0	int
,	O
"Filter running: %s"	pointer
,	O
w	pointer
->	O
w_pwin	pointer
?	O
w	pointer
->	O
w_pwin	pointer
->	O
p_cmd	array
:	O
"(none)"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
w	pointer
->	O
w_ptyfd	int
<	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"You feel dead inside."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
(	O
pwin	pointer
=	O
(	O
struct	O
pseudowin	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
pseudowin	struct
)	O
)	O
)	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
for	O
(	O
s	pointer
=	O
*	O
av	pointer
;	O
*	O
s	pointer
==	O
' '	O
;	O
s	pointer
++	O
)	O
;	O
for	O
(	O
p	pointer
=	O
s	pointer
;	O
*	O
p	pointer
==	O
':'	O
||	O
*	O
p	pointer
==	O
'.'	O
||	O
*	O
p	pointer
==	O
'!'	O
;	O
p	pointer
++	O
)	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
'|'	O
)	O
while	O
(	O
*	O
p	pointer
&&	O
p	pointer
>	O
s	pointer
&&	O
p	pointer
[	O
-	O
1	int
]	O
==	O
'.'	O
)	O
p	pointer
--	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'|'	O
)	O
{	O
l	int
=	O
F_UWP	int
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
*	O
p	pointer
)	O
av	pointer
[	O
0	int
]	O
=	O
p	pointer
;	O
else	O
av	pointer
++	O
;	O
t	pointer
=	O
pwin	pointer
->	O
p_cmd	array
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
3	int
;	O
i	pointer
++	O
)	O
{	O
*	O
t	pointer
=	O
(	O
s	pointer
<	O
p	pointer
)	O
?	O
*	O
s	pointer
++	O
:	O
'.'	O
;	O
switch	O
(	O
*	O
t	pointer
++	O
)	O
{	O
case	O
'.'	O
:	O
case	O
'|'	O
:	O
l	int
|=	O
F_PFRONT	int
<<	O
(	O
i	pointer
*	O
F_PSHIFT	int
)	O
;	O
break	O
;	O
case	O
'!'	O
:	O
l	int
|=	O
F_PBACK	int
<<	O
(	O
i	pointer
*	O
F_PSHIFT	int
)	O
;	O
break	O
;	O
case	O
':'	O
:	O
l	int
|=	O
F_PBOTH	O
<<	O
(	O
i	pointer
*	O
F_PSHIFT	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
l	int
&	O
F_UWP	int
)	O
{	O
*	O
t	pointer
++	O
=	O
'|'	O
;	O
if	O
(	O
(	O
l	int
&	O
F_PMASK	int
)	O
==	O
F_PFRONT	int
)	O
{	O
*	O
pwin	pointer
->	O
p_cmd	array
=	O
'!'	O
;	O
l	int
^=	O
F_PFRONT	int
|	O
F_PBACK	int
;	O
}	O
}	O
if	O
(	O
!	O
(	O
l	int
&	O
F_PBACK	int
)	O
)	O
l	int
|=	O
F_UWP	int
;	O
*	O
t	pointer
++	O
=	O
' '	O
;	O
pwin	pointer
->	O
p_fdpat	int
=	O
l	int
;	O
debug1	O
(	O
"winexec: '%#x'\n"	pointer
,	O
pwin	pointer
->	O
p_fdpat	int
)	O
;	O
l	int
=	O
MAXSTR	int
-	O
4	int
;	O
for	O
(	O
pp	pointer
=	O
av	pointer
;	O
*	O
pp	pointer
;	O
pp	pointer
++	O
)	O
{	O
p	pointer
=	O
*	O
pp	pointer
;	O
while	O
(	O
*	O
p	pointer
&&	O
l	int
--	O
>	O
0	int
)	O
*	O
t	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
l	int
<=	O
0	int
)	O
break	O
;	O
*	O
t	pointer
++	O
=	O
' '	O
;	O
}	O
*	O
--	O
t	pointer
=	O
'\0'	O
;	O
debug1	O
(	O
"%s\n"	pointer
,	O
pwin	pointer
->	O
p_cmd	array
)	O
;	O
if	O
(	O
(	O
pwin	pointer
->	O
p_ptyfd	int
=	O
OpenDevice	function
(	O
av	pointer
,	O
0	int
,	O
&	O
type	enum
,	O
&	O
t	pointer
)	O
)	O
<	O
0	int
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
pwin	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
strncpy	function
(	O
pwin	pointer
->	O
p_tty	array
,	O
t	pointer
,	O
MAXSTR	int
-	O
1	int
)	O
;	O
w	pointer
->	O
w_pwin	pointer
=	O
pwin	pointer
;	O
if	O
(	O
type	enum
!=	O
W_TYPE_PTY	int
)	O
{	O
FreePseudowin	function
(	O
w	pointer
)	O
;	O
Msg	function
(	O
0	int
,	O
"Cannot only use commands as pseudo win."	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
(	O
pwin	pointer
->	O
p_fdpat	int
&	O
F_PFRONT	int
)	O
)	O
evdeq	function
(	O
&	O
w	pointer
->	O
w_readev	struct
)	O
;	O
{	O
int	O
flag	int
=	O
0	int
;	O
if	O
(	O
ioctl	function
(	O
pwin	pointer
->	O
p_ptyfd	int
,	O
TIOCPKT	int
,	O
(	O
char	O
*	O
)	O
&	O
flag	int
)	O
)	O
{	O
Msg	function
(	O
errno	O
,	O
"TIOCPKT pwin ioctl"	pointer
)	O
;	O
FreePseudowin	function
(	O
w	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
w	pointer
->	O
w_type	int
==	O
W_TYPE_PTY	int
&&	O
!	O
(	O
pwin	pointer
->	O
p_fdpat	int
&	O
F_PFRONT	int
)	O
)	O
{	O
if	O
(	O
ioctl	function
(	O
w	pointer
->	O
w_ptyfd	int
,	O
TIOCPKT	int
,	O
(	O
char	O
*	O
)	O
&	O
flag	int
)	O
)	O
{	O
Msg	function
(	O
errno	O
,	O
"TIOCPKT win ioctl"	pointer
)	O
;	O
FreePseudowin	function
(	O
w	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
pwin	pointer
->	O
p_readev	struct
.	O
fd	int
=	O
pwin	pointer
->	O
p_writeev	struct
.	O
fd	int
=	O
pwin	pointer
->	O
p_ptyfd	int
;	O
pwin	pointer
->	O
p_readev	struct
.	O
type	enum
=	O
EV_READ	int
;	O
pwin	pointer
->	O
p_writeev	struct
.	O
type	enum
=	O
EV_WRITE	int
;	O
pwin	pointer
->	O
p_readev	struct
.	O
data	pointer
=	O
pwin	pointer
->	O
p_writeev	struct
.	O
data	pointer
=	O
(	O
char	O
*	O
)	O
w	pointer
;	O
pwin	pointer
->	O
p_readev	struct
.	O
handler	pointer
=	O
pseu_readev_fn	function
;	O
pwin	pointer
->	O
p_writeev	struct
.	O
handler	pointer
=	O
pseu_writeev_fn	function
;	O
pwin	pointer
->	O
p_writeev	struct
.	O
condpos	pointer
=	O
&	O
pwin	pointer
->	O
p_inlen	int
;	O
if	O
(	O
pwin	pointer
->	O
p_fdpat	int
&	O
(	O
F_PFRONT	int
<<	O
F_PSHIFT	int
*	O
2	int
|	O
F_PFRONT	int
<<	O
F_PSHIFT	int
)	O
)	O
evenq	function
(	O
&	O
pwin	pointer
->	O
p_readev	struct
)	O
;	O
evenq	function
(	O
&	O
pwin	pointer
->	O
p_writeev	struct
)	O
;	O
r	int
=	O
pwin	pointer
->	O
p_pid	int
=	O
ForkWindow	function
(	O
w	pointer
,	O
av	pointer
,	O
t	pointer
)	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
FreePseudowin	function
(	O
w	pointer
)	O
;	O
return	O
r	int
;	O
}	O
void	O
FreePseudowin	function
(	O
w	pointer
)	O
struct	O
win	struct
*	O
w	pointer
;	O
{	O
struct	O
pseudowin	struct
*	O
pwin	pointer
=	O
w	pointer
->	O
w_pwin	pointer
;	O
ASSERT	O
(	O
pwin	pointer
)	O
;	O
if	O
(	O
fcntl	function
(	O
w	pointer
->	O
w_ptyfd	int
,	O
F_SETFL	int
,	O
FNBLOCK	O
)	O
)	O
Msg	function
(	O
errno	O
,	O
"Warning: FreePseudowin: NBLOCK fcntl failed"	pointer
)	O
;	O
if	O
(	O
w	pointer
->	O
w_type	int
==	O
W_TYPE_PTY	int
&&	O
!	O
(	O
pwin	pointer
->	O
p_fdpat	int
&	O
F_PFRONT	int
)	O
)	O
{	O
int	O
flag	int
=	O
1	int
;	O
if	O
(	O
ioctl	function
(	O
w	pointer
->	O
w_ptyfd	int
,	O
TIOCPKT	int
,	O
(	O
char	O
*	O
)	O
&	O
flag	int
)	O
)	O
Msg	function
(	O
errno	O
,	O
"Warning: FreePseudowin: TIOCPKT win ioctl"	pointer
)	O
;	O
}	O
(	O
void	O
)	O
chmod	function
(	O
pwin	pointer
->	O
p_tty	array
,	O
0666	int
)	O
;	O
(	O
void	O
)	O
chown	function
(	O
pwin	pointer
->	O
p_tty	array
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
pwin	pointer
->	O
p_ptyfd	int
>=	O
0	int
)	O
close	pointer
(	O
pwin	pointer
->	O
p_ptyfd	int
)	O
;	O
evdeq	function
(	O
&	O
pwin	pointer
->	O
p_readev	struct
)	O
;	O
evdeq	function
(	O
&	O
pwin	pointer
->	O
p_writeev	struct
)	O
;	O
if	O
(	O
w	pointer
->	O
w_readev	struct
.	O
condneg	pointer
==	O
&	O
pwin	pointer
->	O
p_inlen	int
)	O
w	pointer
->	O
w_readev	struct
.	O
condpos	pointer
=	O
w	pointer
->	O
w_readev	struct
.	O
condneg	pointer
=	O
0	int
;	O
evenq	function
(	O
&	O
w	pointer
->	O
w_readev	struct
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
pwin	pointer
)	O
;	O
w	pointer
->	O
w_pwin	pointer
=	O
NULL	O
;	O
}	O
int	O
ReleaseAutoWritelock	function
(	O
dis	pointer
,	O
w	pointer
)	O
struct	O
display	struct
*	O
dis	pointer
;	O
struct	O
win	struct
*	O
w	pointer
;	O
{	O
debug2	O
(	O
"ReleaseAutoWritelock: user %s, window %d\n"	pointer
,	O
dis	pointer
->	O
d_user	pointer
->	O
u_name	array
,	O
w	pointer
->	O
w_number	int
)	O
;	O
if	O
(	O
w	pointer
->	O
w_wlock	int
==	O
WLOCK_AUTO	int
&&	O
w	pointer
->	O
w_wlockuser	pointer
==	O
dis	pointer
->	O
d_user	pointer
)	O
{	O
struct	O
display	struct
*	O
d	int
;	O
for	O
(	O
d	int
=	O
displays	pointer
;	O
d	int
;	O
d	int
=	O
d	int
->	O
d_next	pointer
)	O
if	O
(	O
(	O
d	int
!=	O
dis	pointer
)	O
&&	O
(	O
d	int
->	O
d_fore	pointer
==	O
w	pointer
)	O
&&	O
(	O
d	int
->	O
d_user	pointer
==	O
dis	pointer
->	O
d_user	pointer
)	O
)	O
break	O
;	O
debug3	O
(	O
"%s %s autolock on win %d\n"	pointer
,	O
dis	pointer
->	O
d_user	pointer
->	O
u_name	array
,	O
d	int
?	O
"keeps"	pointer
:	O
"releases"	pointer
,	O
w	pointer
->	O
w_number	int
)	O
;	O
if	O
(	O
!	O
d	int
)	O
{	O
w	pointer
->	O
w_wlockuser	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
int	O
ObtainAutoWritelock	function
(	O
d	int
,	O
w	pointer
)	O
struct	O
display	struct
*	O
d	int
;	O
struct	O
win	struct
*	O
w	pointer
;	O
{	O
if	O
(	O
(	O
w	pointer
->	O
w_wlock	int
==	O
WLOCK_AUTO	int
)	O
&&	O
!	O
AclCheckPermWin	function
(	O
d	int
->	O
d_user	pointer
,	O
ACL_WRITE	int
,	O
w	pointer
)	O
&&	O
!	O
w	pointer
->	O
w_wlockuser	pointer
)	O
{	O
debug2	O
(	O
"%s obtained auto writelock for exported window %d\n"	pointer
,	O
d	int
->	O
d_user	pointer
->	O
u_name	array
,	O
w	pointer
->	O
w_number	int
)	O
;	O
w	pointer
->	O
w_wlockuser	pointer
=	O
d	int
->	O
d_user	pointer
;	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
paste_slowev_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
paster	struct
*	O
pa	pointer
=	O
(	O
struct	O
paster	struct
*	O
)	O
data	pointer
;	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
l	int
=	O
1	int
;	O
flayer	pointer
=	O
pa	pointer
->	O
pa_pastelayer	pointer
;	O
if	O
(	O
!	O
flayer	pointer
)	O
pa	pointer
->	O
pa_pastelen	int
=	O
0	int
;	O
if	O
(	O
!	O
pa	pointer
->	O
pa_pastelen	int
)	O
return	O
;	O
p	pointer
=	O
Layer2Window	O
(	O
flayer	pointer
)	O
;	O
DoProcess	function
(	O
p	pointer
,	O
&	O
pa	pointer
->	O
pa_pasteptr	pointer
,	O
&	O
l	int
,	O
pa	pointer
)	O
;	O
pa	pointer
->	O
pa_pastelen	int
-=	O
1	int
-	O
l	int
;	O
if	O
(	O
pa	pointer
->	O
pa_pastelen	int
>	O
0	int
)	O
{	O
SetTimeout	function
(	O
&	O
pa	pointer
->	O
pa_slowev	struct
,	O
p	pointer
->	O
w_slowpaste	int
)	O
;	O
evenq	function
(	O
&	O
pa	pointer
->	O
pa_slowev	struct
)	O
;	O
}	O
}	O
static	O
int	O
muchpending	function
(	O
p	pointer
,	O
ev	pointer
)	O
struct	O
win	struct
*	O
p	pointer
;	O
struct	O
event	struct
*	O
ev	pointer
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
for	O
(	O
cv	pointer
=	O
p	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_lnext	pointer
)	O
{	O
display	struct
=	O
cv	pointer
->	O
c_display	pointer
;	O
if	O
(	O
D_status	O
==	O
STATUS_ON_WIN	int
&&	O
!	O
D_status_bell	O
)	O
{	O
debug	O
(	O
"BLOCKING because of status\n"	pointer
)	O
;	O
ev	pointer
->	O
condpos	pointer
=	O
&	O
const_one	int
;	O
ev	pointer
->	O
condneg	pointer
=	O
&	O
D_status	O
;	O
return	O
1	int
;	O
}	O
debug2	O
(	O
"muchpending %s %d: "	pointer
,	O
D_usertty	O
,	O
D_blocked	O
)	O
;	O
debug3	O
(	O
"%d %d %d\n"	pointer
,	O
D_obufp	O
-	O
D_obuf	O
,	O
D_obufmax	O
,	O
D_blocked_fuzz	O
)	O
;	O
if	O
(	O
D_blocked	O
)	O
continue	O
;	O
if	O
(	O
D_obufp	O
-	O
D_obuf	O
>	O
D_obufmax	O
+	O
D_blocked_fuzz	O
)	O
{	O
if	O
(	O
D_nonblock	O
==	O
0	int
)	O
{	O
debug1	O
(	O
"obuf is full, stopping output to display %s\n"	pointer
,	O
D_usertty	O
)	O
;	O
D_blocked	O
=	O
1	int
;	O
continue	O
;	O
}	O
debug	O
(	O
"BLOCKING because of full obuf\n"	pointer
)	O
;	O
ev	pointer
->	O
condpos	pointer
=	O
&	O
D_obuffree	O
;	O
ev	pointer
->	O
condneg	pointer
=	O
&	O
D_obuflenmax	O
;	O
if	O
(	O
D_nonblock	O
>	O
0	int
&&	O
!	O
D_blockedev	O
.	O
queued	int
)	O
{	O
debug1	O
(	O
"created timeout of %g secs\n"	pointer
,	O
D_nonblock	O
/	O
1000.	int
)	O
;	O
SetTimeout	function
(	O
&	O
D_blockedev	O
,	O
D_nonblock	O
)	O
;	O
evenq	function
(	O
&	O
D_blockedev	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
win_readev_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
data	pointer
;	O
char	O
buf	pointer
[	O
IOSIZE	int
]	O
,	O
*	O
bp	pointer
;	O
int	O
size	int
,	O
len	int
;	O
int	O
wtop	int
;	O
bp	pointer
=	O
buf	pointer
;	O
size	int
=	O
IOSIZE	int
;	O
wtop	int
=	O
p	pointer
->	O
w_pwin	pointer
&&	O
W_WTOP	O
(	O
p	pointer
)	O
;	O
if	O
(	O
wtop	int
)	O
{	O
ASSERT	O
(	O
sizeof	O
(	O
p	pointer
->	O
w_pwin	pointer
->	O
p_inbuf	array
)	O
==	O
IOSIZE	int
)	O
;	O
size	int
=	O
IOSIZE	int
-	O
p	pointer
->	O
w_pwin	pointer
->	O
p_inlen	int
;	O
if	O
(	O
size	int
<=	O
0	int
)	O
{	O
ev	pointer
->	O
condpos	pointer
=	O
&	O
const_IOSIZE	int
;	O
ev	pointer
->	O
condneg	pointer
=	O
&	O
p	pointer
->	O
w_pwin	pointer
->	O
p_inlen	int
;	O
return	O
;	O
}	O
}	O
if	O
(	O
p	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
&&	O
muchpending	function
(	O
p	pointer
,	O
ev	pointer
)	O
)	O
return	O
;	O
if	O
(	O
!	O
p	pointer
->	O
w_zdisplay	pointer
)	O
if	O
(	O
p	pointer
->	O
w_blocked	int
)	O
{	O
ev	pointer
->	O
condpos	pointer
=	O
&	O
const_one	int
;	O
ev	pointer
->	O
condneg	pointer
=	O
&	O
p	pointer
->	O
w_blocked	int
;	O
return	O
;	O
}	O
if	O
(	O
ev	pointer
->	O
condpos	pointer
)	O
ev	pointer
->	O
condpos	pointer
=	O
ev	pointer
->	O
condneg	pointer
=	O
0	int
;	O
if	O
(	O
(	O
len	int
=	O
p	pointer
->	O
w_outlen	int
)	O
)	O
{	O
p	pointer
->	O
w_outlen	int
=	O
0	int
;	O
WriteString	function
(	O
p	pointer
,	O
p	pointer
->	O
w_outbuf	array
,	O
len	int
)	O
;	O
return	O
;	O
}	O
debug1	O
(	O
"going to read from window fd %d\n"	pointer
,	O
ev	pointer
->	O
fd	int
)	O
;	O
if	O
(	O
(	O
len	int
=	O
read	pointer
(	O
ev	pointer
->	O
fd	int
,	O
buf	pointer
,	O
size	int
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
||	O
errno	O
==	O
EAGAIN	int
)	O
return	O
;	O
debug2	O
(	O
"Window %d: read error (errno %d) - killing window\n"	pointer
,	O
p	pointer
->	O
w_number	int
,	O
errno	O
)	O
;	O
WindowDied	function
(	O
p	pointer
,	O
0	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
len	int
==	O
0	int
)	O
{	O
debug1	O
(	O
"Window %d: EOF - killing window\n"	pointer
,	O
p	pointer
->	O
w_number	int
)	O
;	O
WindowDied	function
(	O
p	pointer
,	O
0	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
debug1	O
(	O
" -> %d bytes\n"	pointer
,	O
len	int
)	O
;	O
if	O
(	O
p	pointer
->	O
w_type	int
==	O
W_TYPE_PTY	int
)	O
{	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
)	O
{	O
debug1	O
(	O
"PAKET %x\n"	pointer
,	O
buf	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
&	O
TIOCPKT_NOSTOP	int
)	O
WNewAutoFlow	function
(	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
&	O
TIOCPKT_DOSTOP	int
)	O
WNewAutoFlow	function
(	O
p	pointer
,	O
1	int
)	O
;	O
}	O
bp	pointer
++	O
;	O
len	int
--	O
;	O
}	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
zmodem_mode	int
&&	O
zmodem_parse	function
(	O
p	pointer
,	O
bp	pointer
,	O
len	int
)	O
)	O
return	O
;	O
if	O
(	O
wtop	int
)	O
{	O
debug	O
(	O
"sending input to pwin\n"	pointer
)	O
;	O
bcopy	function
(	O
bp	pointer
,	O
p	pointer
->	O
w_pwin	pointer
->	O
p_inbuf	array
+	O
p	pointer
->	O
w_pwin	pointer
->	O
p_inlen	int
,	O
len	int
)	O
;	O
p	pointer
->	O
w_pwin	pointer
->	O
p_inlen	int
+=	O
len	int
;	O
}	O
LayPause	function
(	O
&	O
p	pointer
->	O
w_layer	struct
,	O
1	int
)	O
;	O
WriteString	function
(	O
p	pointer
,	O
bp	pointer
,	O
len	int
)	O
;	O
LayPause	function
(	O
&	O
p	pointer
->	O
w_layer	struct
,	O
0	int
)	O
;	O
return	O
;	O
}	O
static	O
void	O
win_resurrect_zombie_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
data	pointer
;	O
debug2	O
(	O
"Try to resurrecting Zombie event: %d [%s]\n"	pointer
,	O
p	pointer
->	O
w_number	int
,	O
p	pointer
->	O
w_title	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
w_deadpid	int
!=	O
p	pointer
->	O
w_pid	int
)	O
return	O
;	O
debug1	O
(	O
"Resurrecting Zombie: %d\n"	pointer
,	O
p	pointer
->	O
w_number	int
)	O
;	O
WriteString	function
(	O
p	pointer
,	O
"\r\n"	pointer
,	O
2	int
)	O
;	O
RemakeWindow	function
(	O
p	pointer
)	O
;	O
}	O
static	O
void	O
win_writeev_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
data	pointer
;	O
int	O
len	int
;	O
if	O
(	O
p	pointer
->	O
w_inlen	int
)	O
{	O
debug2	O
(	O
"writing %d bytes to win %d\n"	pointer
,	O
p	pointer
->	O
w_inlen	int
,	O
p	pointer
->	O
w_number	int
)	O
;	O
if	O
(	O
(	O
len	int
=	O
write	pointer
(	O
ev	pointer
->	O
fd	int
,	O
p	pointer
->	O
w_inbuf	array
,	O
p	pointer
->	O
w_inlen	int
)	O
)	O
<=	O
0	int
)	O
len	int
=	O
p	pointer
->	O
w_inlen	int
;	O
if	O
(	O
(	O
p	pointer
->	O
w_inlen	int
-=	O
len	int
)	O
)	O
bcopy	function
(	O
p	pointer
->	O
w_inbuf	array
+	O
len	int
,	O
p	pointer
->	O
w_inbuf	array
,	O
p	pointer
->	O
w_inlen	int
)	O
;	O
}	O
if	O
(	O
p	pointer
->	O
w_paster	struct
.	O
pa_pastelen	int
&&	O
!	O
p	pointer
->	O
w_slowpaste	int
)	O
{	O
struct	O
paster	struct
*	O
pa	pointer
=	O
&	O
p	pointer
->	O
w_paster	struct
;	O
flayer	pointer
=	O
pa	pointer
->	O
pa_pastelayer	pointer
;	O
if	O
(	O
flayer	pointer
)	O
DoProcess	function
(	O
p	pointer
,	O
&	O
pa	pointer
->	O
pa_pasteptr	pointer
,	O
&	O
pa	pointer
->	O
pa_pastelen	int
,	O
pa	pointer
)	O
;	O
}	O
return	O
;	O
}	O
static	O
void	O
pseu_readev_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
data	pointer
;	O
char	O
buf	pointer
[	O
IOSIZE	int
]	O
;	O
int	O
size	int
,	O
ptow	int
,	O
len	int
;	O
size	int
=	O
IOSIZE	int
;	O
ptow	int
=	O
W_PTOW	O
(	O
p	pointer
)	O
;	O
if	O
(	O
ptow	int
)	O
{	O
ASSERT	O
(	O
sizeof	O
(	O
p	pointer
->	O
w_inbuf	array
)	O
==	O
IOSIZE	int
)	O
;	O
size	int
=	O
IOSIZE	int
-	O
p	pointer
->	O
w_inlen	int
;	O
if	O
(	O
size	int
<=	O
0	int
)	O
{	O
ev	pointer
->	O
condpos	pointer
=	O
&	O
const_IOSIZE	int
;	O
ev	pointer
->	O
condneg	pointer
=	O
&	O
p	pointer
->	O
w_inlen	int
;	O
return	O
;	O
}	O
}	O
if	O
(	O
p	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
&&	O
muchpending	function
(	O
p	pointer
,	O
ev	pointer
)	O
)	O
return	O
;	O
if	O
(	O
p	pointer
->	O
w_blocked	int
)	O
{	O
ev	pointer
->	O
condpos	pointer
=	O
&	O
const_one	int
;	O
ev	pointer
->	O
condneg	pointer
=	O
&	O
p	pointer
->	O
w_blocked	int
;	O
return	O
;	O
}	O
if	O
(	O
ev	pointer
->	O
condpos	pointer
)	O
ev	pointer
->	O
condpos	pointer
=	O
ev	pointer
->	O
condneg	pointer
=	O
0	int
;	O
if	O
(	O
(	O
len	int
=	O
p	pointer
->	O
w_outlen	int
)	O
)	O
{	O
p	pointer
->	O
w_outlen	int
=	O
0	int
;	O
WriteString	function
(	O
p	pointer
,	O
p	pointer
->	O
w_outbuf	array
,	O
len	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
len	int
=	O
read	pointer
(	O
ev	pointer
->	O
fd	int
,	O
buf	pointer
,	O
size	int
)	O
)	O
<=	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
||	O
errno	O
==	O
EAGAIN	int
)	O
return	O
;	O
debug2	O
(	O
"Window %d: pseudowin read error (errno %d) -- removing pseudowin\n"	pointer
,	O
p	pointer
->	O
w_number	int
,	O
len	int
?	O
errno	O
:	O
0	int
)	O
;	O
FreePseudowin	function
(	O
p	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ptow	int
)	O
{	O
bcopy	function
(	O
buf	pointer
,	O
p	pointer
->	O
w_inbuf	array
+	O
p	pointer
->	O
w_inlen	int
,	O
len	int
)	O
;	O
p	pointer
->	O
w_inlen	int
+=	O
len	int
;	O
}	O
WriteString	function
(	O
p	pointer
,	O
buf	pointer
,	O
len	int
)	O
;	O
return	O
;	O
}	O
static	O
void	O
pseu_writeev_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
data	pointer
;	O
struct	O
pseudowin	struct
*	O
pw	pointer
=	O
p	pointer
->	O
w_pwin	pointer
;	O
int	O
len	int
;	O
ASSERT	O
(	O
pw	pointer
)	O
;	O
if	O
(	O
pw	pointer
->	O
p_inlen	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
(	O
len	int
=	O
write	pointer
(	O
ev	pointer
->	O
fd	int
,	O
pw	pointer
->	O
p_inbuf	array
,	O
pw	pointer
->	O
p_inlen	int
)	O
)	O
<=	O
0	int
)	O
len	int
=	O
pw	pointer
->	O
p_inlen	int
;	O
if	O
(	O
(	O
p	pointer
->	O
w_pwin	pointer
->	O
p_inlen	int
-=	O
len	int
)	O
)	O
bcopy	function
(	O
p	pointer
->	O
w_pwin	pointer
->	O
p_inbuf	array
+	O
len	int
,	O
p	pointer
->	O
w_pwin	pointer
->	O
p_inbuf	array
,	O
p	pointer
->	O
w_pwin	pointer
->	O
p_inlen	int
)	O
;	O
}	O
static	O
void	O
win_silenceev_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
data	pointer
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
debug1	O
(	O
"FOUND silence win %d\n"	pointer
,	O
p	pointer
->	O
w_number	int
)	O
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
if	O
(	O
cv	pointer
->	O
c_layer	pointer
->	O
l_bottom	pointer
==	O
&	O
p	pointer
->	O
w_layer	struct
)	O
break	O
;	O
if	O
(	O
cv	pointer
)	O
continue	O
;	O
if	O
(	O
!	O
(	O
ACLBYTE	O
(	O
p	pointer
->	O
w_lio_notify	pointer
,	O
D_user	O
->	O
u_id	int
)	O
&	O
ACLBIT	O
(	O
D_user	O
->	O
u_id	int
)	O
)	O
)	O
continue	O
;	O
Msg	function
(	O
0	int
,	O
"Window %d: silence for %d seconds"	pointer
,	O
p	pointer
->	O
w_number	int
,	O
p	pointer
->	O
w_silencewait	int
)	O
;	O
p	pointer
->	O
w_silence	int
=	O
SILENCE_FOUND	int
;	O
WindowChanged	function
(	O
p	pointer
,	O
'f'	O
)	O
;	O
}	O
}	O
static	O
void	O
win_destroyev_fn	function
(	O
ev	pointer
,	O
data	pointer
)	O
struct	O
event	struct
*	O
ev	pointer
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
=	O
(	O
struct	O
win	struct
*	O
)	O
ev	pointer
->	O
data	pointer
;	O
WindowDied	function
(	O
p	pointer
,	O
p	pointer
->	O
w_exitstatus	int
,	O
1	int
)	O
;	O
}	O
static	O
int	O
zmodem_parse	function
(	O
p	pointer
,	O
bp	pointer
,	O
len	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
char	O
*	O
bp	pointer
;	O
int	O
len	int
;	O
{	O
int	O
i	pointer
;	O
char	O
*	O
b2	array
=	O
bp	pointer
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
len	int
;	O
i	pointer
++	O
,	O
b2	array
++	O
)	O
{	O
if	O
(	O
p	pointer
->	O
w_zauto	int
==	O
0	int
)	O
{	O
for	O
(	O
;	O
i	pointer
<	O
len	int
;	O
i	pointer
++	O
,	O
b2	array
++	O
)	O
if	O
(	O
*	O
b2	array
==	O
030	int
)	O
break	O
;	O
if	O
(	O
i	pointer
==	O
len	int
)	O
break	O
;	O
if	O
(	O
i	pointer
>	O
1	int
&&	O
b2	array
[	O
-	O
1	int
]	O
==	O
'*'	O
&&	O
b2	array
[	O
-	O
2	int
]	O
==	O
'*'	O
)	O
p	pointer
->	O
w_zauto	int
=	O
3	int
;	O
continue	O
;	O
}	O
if	O
(	O
p	pointer
->	O
w_zauto	int
>	O
5	int
||	O
*	O
b2	array
==	O
"**\030B00"	pointer
[	O
p	pointer
->	O
w_zauto	int
]	O
||	O
(	O
p	pointer
->	O
w_zauto	int
==	O
5	int
&&	O
*	O
b2	array
==	O
'1'	O
)	O
||	O
(	O
p	pointer
->	O
w_zauto	int
==	O
5	int
&&	O
p	pointer
->	O
w_zdisplay	pointer
&&	O
*	O
b2	array
==	O
'8'	O
)	O
)	O
{	O
if	O
(	O
++	O
p	pointer
->	O
w_zauto	int
<	O
6	int
)	O
continue	O
;	O
if	O
(	O
p	pointer
->	O
w_zauto	int
==	O
6	int
)	O
p	pointer
->	O
w_zauto	int
=	O
0	int
;	O
if	O
(	O
!	O
p	pointer
->	O
w_zdisplay	pointer
)	O
{	O
if	O
(	O
i	pointer
>	O
6	int
)	O
WriteString	function
(	O
p	pointer
,	O
bp	pointer
,	O
i	pointer
+	O
1	int
-	O
6	int
)	O
;	O
WriteString	function
(	O
p	pointer
,	O
"\r\n"	pointer
,	O
2	int
)	O
;	O
zmodem_found	function
(	O
p	pointer
,	O
*	O
b2	array
==	O
'1'	O
,	O
b2	array
+	O
1	int
,	O
len	int
-	O
i	pointer
-	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
w_zauto	int
==	O
7	int
||	O
*	O
b2	array
==	O
'8'	O
)	O
{	O
int	O
se	int
=	O
p	pointer
->	O
w_zdisplay	pointer
->	O
d_blocked	int
==	O
2	int
?	O
'O'	O
:	O
'\212'	O
;	O
for	O
(	O
;	O
i	pointer
<	O
len	int
;	O
i	pointer
++	O
,	O
b2	array
++	O
)	O
if	O
(	O
*	O
b2	array
==	O
se	int
)	O
break	O
;	O
if	O
(	O
i	pointer
<	O
len	int
)	O
{	O
zmodem_abort	function
(	O
p	pointer
,	O
0	int
)	O
;	O
D_blocked	O
=	O
0	int
;	O
D_readev	O
.	O
condpos	pointer
=	O
D_readev	O
.	O
condneg	pointer
=	O
0	int
;	O
while	O
(	O
len	int
--	O
>	O
0	int
)	O
AddChar	O
(	O
*	O
bp	pointer
++	O
)	O
;	O
Flush	function
(	O
0	int
)	O
;	O
Activate	function
(	O
D_fore	O
?	O
D_fore	O
->	O
w_norefresh	char
:	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
p	pointer
->	O
w_zauto	int
=	O
6	int
;	O
}	O
}	O
else	O
p	pointer
->	O
w_zauto	int
=	O
*	O
b2	array
==	O
'*'	O
?	O
(	O
p	pointer
->	O
w_zauto	int
==	O
2	int
?	O
2	int
:	O
1	int
)	O
:	O
0	int
;	O
}	O
if	O
(	O
p	pointer
->	O
w_zauto	int
==	O
0	int
&&	O
bp	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'*'	O
)	O
p	pointer
->	O
w_zauto	int
=	O
len	int
>	O
1	int
&&	O
bp	pointer
[	O
len	int
-	O
2	int
]	O
==	O
'*'	O
?	O
2	int
:	O
1	int
;	O
if	O
(	O
p	pointer
->	O
w_zdisplay	pointer
)	O
{	O
display	struct
=	O
p	pointer
->	O
w_zdisplay	pointer
;	O
while	O
(	O
len	int
--	O
>	O
0	int
)	O
AddChar	O
(	O
*	O
bp	pointer
++	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
zmodem_fin	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
char	O
*	O
s	pointer
;	O
int	O
n	int
;	O
if	O
(	O
len	int
)	O
RcLine	function
(	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
+	O
1	int
)	O
;	O
else	O
{	O
s	pointer
=	O
"\030\030\030\030\030\030\030\030\030\030"	pointer
;	O
n	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
LayProcess	O
(	O
&	O
s	pointer
,	O
&	O
n	int
)	O
;	O
}	O
}	O
static	O
void	O
zmodem_found	function
(	O
p	pointer
,	O
send	int
,	O
bp	pointer
,	O
len	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
send	int
;	O
char	O
*	O
bp	pointer
;	O
int	O
len	int
;	O
{	O
char	O
*	O
s	pointer
;	O
int	O
i	pointer
,	O
n	int
;	O
extern	O
int	O
zmodem_mode	int
;	O
n	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
len	int
;	O
i	pointer
++	O
)	O
if	O
(	O
bp	pointer
[	O
i	pointer
]	O
!=	O
030	int
)	O
n	int
=	O
0	int
;	O
else	O
if	O
(	O
++	O
n	int
>	O
4	int
)	O
return	O
;	O
if	O
(	O
zmodem_mode	int
==	O
3	int
||	O
(	O
zmodem_mode	int
==	O
1	int
&&	O
p	pointer
->	O
w_type	int
!=	O
W_TYPE_PLAIN	int
)	O
)	O
{	O
struct	O
display	struct
*	O
d	int
,	O
*	O
olddisplay	pointer
;	O
olddisplay	pointer
=	O
display	struct
;	O
d	int
=	O
p	pointer
->	O
w_lastdisp	pointer
;	O
if	O
(	O
!	O
d	int
||	O
d	int
->	O
d_fore	pointer
!=	O
p	pointer
)	O
for	O
(	O
d	int
=	O
displays	pointer
;	O
d	int
;	O
d	int
=	O
d	int
->	O
d_next	pointer
)	O
if	O
(	O
d	int
->	O
d_fore	pointer
==	O
p	pointer
)	O
break	O
;	O
if	O
(	O
!	O
d	int
&&	O
p	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
)	O
d	int
=	O
p	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
->	O
c_display	pointer
;	O
if	O
(	O
!	O
d	int
)	O
d	int
=	O
displays	pointer
;	O
if	O
(	O
!	O
d	int
)	O
return	O
;	O
display	struct
=	O
d	int
;	O
RemoveStatus	function
(	O
)	O
;	O
p	pointer
->	O
w_zdisplay	pointer
=	O
display	struct
;	O
D_blocked	O
=	O
2	int
+	O
send	int
;	O
flayer	pointer
=	O
&	O
p	pointer
->	O
w_layer	struct
;	O
ZmodemPage	function
(	O
)	O
;	O
display	struct
=	O
d	int
;	O
evdeq	function
(	O
&	O
D_blockedev	O
)	O
;	O
D_readev	O
.	O
condpos	pointer
=	O
&	O
const_IOSIZE	int
;	O
D_readev	O
.	O
condneg	pointer
=	O
&	O
p	pointer
->	O
w_inlen	int
;	O
ClearAll	function
(	O
)	O
;	O
GotoPos	function
(	O
0	int
,	O
0	int
)	O
;	O
SetRendition	function
(	O
&	O
mchar_blank	struct
)	O
;	O
AddStr	function
(	O
"Zmodem active\r\n\r\n"	pointer
)	O
;	O
AddStr	function
(	O
send	int
?	O
"**\030B01"	pointer
:	O
"**\030B00"	pointer
)	O
;	O
while	O
(	O
len	int
--	O
>	O
0	int
)	O
AddChar	O
(	O
*	O
bp	pointer
++	O
)	O
;	O
display	struct
=	O
olddisplay	pointer
;	O
return	O
;	O
}	O
flayer	pointer
=	O
&	O
p	pointer
->	O
w_layer	struct
;	O
Input	function
(	O
":"	pointer
,	O
MAXSTR	int
,	O
INP_COOKED	int
,	O
zmodem_fin	function
,	O
NULL	O
,	O
0	int
)	O
;	O
s	pointer
=	O
send	int
?	O
zmodem_sendcmd	pointer
:	O
zmodem_recvcmd	pointer
;	O
n	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
LayProcess	O
(	O
&	O
s	pointer
,	O
&	O
n	int
)	O
;	O
}	O
void	O
zmodem_abort	function
(	O
p	pointer
,	O
d	int
)	O
struct	O
win	struct
*	O
p	pointer
;	O
struct	O
display	struct
*	O
d	int
;	O
{	O
struct	O
display	struct
*	O
olddisplay	pointer
=	O
display	struct
;	O
struct	O
layer	struct
*	O
oldflayer	pointer
=	O
flayer	pointer
;	O
if	O
(	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
w_savelayer	pointer
&&	O
p	pointer
->	O
w_savelayer	pointer
->	O
l_next	pointer
)	O
{	O
if	O
(	O
oldflayer	pointer
==	O
p	pointer
->	O
w_savelayer	pointer
)	O
oldflayer	pointer
=	O
flayer	pointer
->	O
l_next	pointer
;	O
flayer	pointer
=	O
p	pointer
->	O
w_savelayer	pointer
;	O
ExitOverlayPage	function
(	O
)	O
;	O
}	O
p	pointer
->	O
w_zdisplay	pointer
=	O
0	int
;	O
p	pointer
->	O
w_zauto	int
=	O
0	int
;	O
LRefreshAll	function
(	O
&	O
p	pointer
->	O
w_layer	struct
,	O
0	int
)	O
;	O
}	O
if	O
(	O
d	int
)	O
{	O
display	struct
=	O
d	int
;	O
D_blocked	O
=	O
0	int
;	O
D_readev	O
.	O
condpos	pointer
=	O
D_readev	O
.	O
condneg	pointer
=	O
0	int
;	O
Activate	function
(	O
D_fore	O
?	O
D_fore	O
->	O
w_norefresh	char
:	O
0	int
)	O
;	O
}	O
display	struct
=	O
olddisplay	pointer
;	O
flayer	pointer
=	O
oldflayer	pointer
;	O
}	O
int	O
WindowChangeNumber	function
(	O
int	O
old	int
,	O
int	O
dest	int
)	O
{	O
struct	O
win	struct
*	O
p	pointer
,	O
*	O
win_old	pointer
;	O
if	O
(	O
dest	int
<	O
0	int
||	O
dest	int
>=	O
maxwin	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Given window position is invalid."	pointer
)	O
;	O
return	O
0	int
;	O
}	O
win_old	pointer
=	O
wtab	pointer
[	O
old	int
]	O
;	O
p	pointer
=	O
wtab	pointer
[	O
dest	int
]	O
;	O
wtab	pointer
[	O
dest	int
]	O
=	O
win_old	pointer
;	O
win_old	pointer
->	O
w_number	int
=	O
dest	int
;	O
wtab	pointer
[	O
old	int
]	O
=	O
p	pointer
;	O
if	O
(	O
p	pointer
)	O
p	pointer
->	O
w_number	int
=	O
old	int
;	O
AclWinSwap	function
(	O
old	int
,	O
dest	int
)	O
;	O
if	O
(	O
(	O
win_old	pointer
->	O
w_slot	pointer
!=	O
(	O
slot_t	pointer
)	O
-	O
1	int
)	O
&&	O
(	O
win_old	pointer
->	O
w_slot	pointer
!=	O
(	O
slot_t	pointer
)	O
0	int
)	O
)	O
{	O
RemoveUtmp	function
(	O
win_old	pointer
)	O
;	O
SetUtmp	function
(	O
win_old	pointer
)	O
;	O
}	O
if	O
(	O
p	pointer
&&	O
(	O
p	pointer
->	O
w_slot	pointer
!=	O
(	O
slot_t	pointer
)	O
-	O
1	int
)	O
&&	O
(	O
p	pointer
->	O
w_slot	pointer
!=	O
(	O
slot_t	pointer
)	O
0	int
)	O
)	O
{	O
display	struct
=	O
win_old	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
?	O
win_old	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
->	O
c_display	pointer
:	O
0	int
;	O
RemoveUtmp	function
(	O
p	pointer
)	O
;	O
SetUtmp	function
(	O
p	pointer
)	O
;	O
}	O
WindowChanged	function
(	O
win_old	pointer
,	O
'n'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'w'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'W'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
0	int
)	O
;	O
return	O
1	int
;	O
}	O
