static	O
int	O
unpack_Q1	function
(	O
gsl_matrix	struct
*	O
Q	pointer
)	O
;	O
static	O
int	O
unpack_Q2	function
(	O
const	O
gsl_matrix	struct
*	O
QR	pointer
,	O
const	O
gsl_matrix	struct
*	O
T	pointer
,	O
gsl_matrix	struct
*	O
Q	pointer
)	O
;	O
static	O
int	O
aux_ULT	function
(	O
const	O
gsl_matrix	struct
*	O
L	pointer
,	O
gsl_matrix	struct
*	O
U	pointer
)	O
;	O
static	O
int	O
aux_mLU	function
(	O
gsl_matrix	struct
*	O
A	pointer
)	O
;	O
static	O
int	O
aux_ApUBT	function
(	O
const	O
gsl_matrix	struct
*	O
U	pointer
,	O
const	O
gsl_matrix	struct
*	O
B	pointer
,	O
gsl_matrix	struct
*	O
A	pointer
)	O
;	O
int	O
gsl_linalg_QR_decomp_r	function
(	O
gsl_matrix	struct
*	O
A	pointer
,	O
gsl_matrix	struct
*	O
T	pointer
)	O
{	O
const	O
size_t	long
M	int
=	O
A	pointer
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	pointer
->	O
size2	long
;	O
if	O
(	O
M	int
<	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"M must be >= N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
T	pointer
->	O
size1	long
!=	O
T	pointer
->	O
size2	long
)	O
{	O
GSL_ERROR	O
(	O
"T matrix must be square"	pointer
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
T	pointer
->	O
size1	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"T matrix does not match dimensions of A"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
==	O
1	int
)	O
{	O
double	O
*	O
T00	pointer
=	O
gsl_matrix_ptr	function
(	O
T	pointer
,	O
0	int
,	O
0	int
)	O
;	O
gsl_vector_view	struct
v	pointer
=	O
gsl_matrix_column	function
(	O
A	pointer
,	O
0	int
)	O
;	O
*	O
T00	pointer
=	O
gsl_linalg_householder_transform	function
(	O
&	O
v	pointer
.	O
vector	struct
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
status	int
;	O
const	O
size_t	long
N1	long
=	O
N	int
/	O
2	int
;	O
const	O
size_t	long
N2	long
=	O
N	int
-	O
N1	long
;	O
const	O
size_t	long
M2	long
=	O
M	int
-	O
N1	long
;	O
gsl_matrix_view	struct
A11	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
0	int
,	O
0	int
,	O
N1	long
,	O
N1	long
)	O
;	O
gsl_matrix_view	struct
A12	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
0	int
,	O
N1	long
,	O
N1	long
,	O
N2	long
)	O
;	O
gsl_matrix_view	struct
A21	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
N1	long
,	O
0	int
,	O
M2	long
,	O
N1	long
)	O
;	O
gsl_matrix_view	struct
A22	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
N1	long
,	O
N1	long
,	O
M2	long
,	O
N2	long
)	O
;	O
gsl_matrix_view	struct
T11	struct
=	O
gsl_matrix_submatrix	function
(	O
T	pointer
,	O
0	int
,	O
0	int
,	O
N1	long
,	O
N1	long
)	O
;	O
gsl_matrix_view	struct
T12	struct
=	O
gsl_matrix_submatrix	function
(	O
T	pointer
,	O
0	int
,	O
N1	long
,	O
N1	long
,	O
N2	long
)	O
;	O
gsl_matrix_view	struct
T22	struct
=	O
gsl_matrix_submatrix	function
(	O
T	pointer
,	O
N1	long
,	O
N1	long
,	O
N2	long
,	O
N2	long
)	O
;	O
gsl_matrix_view	struct
m	pointer
;	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
0	int
,	O
0	int
,	O
M	int
,	O
N1	long
)	O
;	O
status	int
=	O
gsl_linalg_QR_decomp_r	function
(	O
&	O
m	pointer
.	O
matrix	struct
,	O
&	O
T11	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
gsl_matrix_memcpy	function
(	O
&	O
T12	struct
.	O
matrix	struct
,	O
&	O
A12	struct
.	O
matrix	struct
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasLeft	int
,	O
CblasLower	int
,	O
CblasTrans	int
,	O
CblasUnit	int
,	O
1.0	int
,	O
&	O
A11	struct
.	O
matrix	struct
,	O
&	O
T12	struct
.	O
matrix	struct
)	O
;	O
gsl_blas_dgemm	function
(	O
CblasTrans	int
,	O
CblasNoTrans	int
,	O
1.0	int
,	O
&	O
A21	struct
.	O
matrix	struct
,	O
&	O
A22	struct
.	O
matrix	struct
,	O
1.0	int
,	O
&	O
T12	struct
.	O
matrix	struct
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasLeft	int
,	O
CblasUpper	int
,	O
CblasTrans	int
,	O
CblasNonUnit	int
,	O
1.0	int
,	O
&	O
T11	struct
.	O
matrix	struct
,	O
&	O
T12	struct
.	O
matrix	struct
)	O
;	O
gsl_blas_dgemm	function
(	O
CblasNoTrans	int
,	O
CblasNoTrans	int
,	O
-	O
1.0	int
,	O
&	O
A21	struct
.	O
matrix	struct
,	O
&	O
T12	struct
.	O
matrix	struct
,	O
1.0	int
,	O
&	O
A22	struct
.	O
matrix	struct
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasLeft	int
,	O
CblasLower	int
,	O
CblasNoTrans	int
,	O
CblasUnit	int
,	O
1.0	int
,	O
&	O
A11	struct
.	O
matrix	struct
,	O
&	O
T12	struct
.	O
matrix	struct
)	O
;	O
gsl_matrix_sub	function
(	O
&	O
A12	struct
.	O
matrix	struct
,	O
&	O
T12	struct
.	O
matrix	struct
)	O
;	O
status	int
=	O
gsl_linalg_QR_decomp_r	function
(	O
&	O
A22	struct
.	O
matrix	struct
,	O
&	O
T22	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
&	O
A21	struct
.	O
matrix	struct
,	O
0	int
,	O
0	int
,	O
N2	long
,	O
N1	long
)	O
;	O
gsl_matrix_transpose_memcpy	function
(	O
&	O
T12	struct
.	O
matrix	struct
,	O
&	O
m	pointer
.	O
matrix	struct
)	O
;	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
N1	long
,	O
N1	long
,	O
N2	long
,	O
N2	long
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasRight	int
,	O
CblasLower	int
,	O
CblasNoTrans	int
,	O
CblasUnit	int
,	O
1.0	int
,	O
&	O
m	pointer
.	O
matrix	struct
,	O
&	O
T12	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
M	int
>	O
N	int
)	O
{	O
gsl_matrix_view	struct
V31	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
N	int
,	O
0	int
,	O
M	int
-	O
N	int
,	O
N1	long
)	O
;	O
gsl_matrix_view	struct
V32	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
N	int
,	O
N1	long
,	O
M	int
-	O
N	int
,	O
N2	long
)	O
;	O
gsl_blas_dgemm	function
(	O
CblasTrans	int
,	O
CblasNoTrans	int
,	O
1.0	int
,	O
&	O
V31	struct
.	O
matrix	struct
,	O
&	O
V32	struct
.	O
matrix	struct
,	O
1.0	int
,	O
&	O
T12	struct
.	O
matrix	struct
)	O
;	O
}	O
gsl_blas_dtrmm	function
(	O
CblasLeft	int
,	O
CblasUpper	int
,	O
CblasNoTrans	int
,	O
CblasNonUnit	int
,	O
-	O
1.0	int
,	O
&	O
T11	struct
.	O
matrix	struct
,	O
&	O
T12	struct
.	O
matrix	struct
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasRight	int
,	O
CblasUpper	int
,	O
CblasNoTrans	int
,	O
CblasNonUnit	int
,	O
1.0	int
,	O
&	O
T22	struct
.	O
matrix	struct
,	O
&	O
T12	struct
.	O
matrix	struct
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_linalg_QR_solve_r	function
(	O
const	O
gsl_matrix	struct
*	O
QR	pointer
,	O
const	O
gsl_matrix	struct
*	O
T	pointer
,	O
const	O
gsl_vector	struct
*	O
b	pointer
,	O
gsl_vector	struct
*	O
x	long double
)	O
{	O
const	O
size_t	long
N	int
=	O
QR	pointer
->	O
size2	long
;	O
if	O
(	O
QR	pointer
->	O
size1	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"QR matrix must be square"	pointer
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
T	pointer
->	O
size1	long
!=	O
QR	pointer
->	O
size1	long
||	O
T	pointer
->	O
size2	long
!=	O
QR	pointer
->	O
size2	long
)	O
{	O
GSL_ERROR	O
(	O
"T matrix must be N-by-N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
b	pointer
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix size must match b size"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
x	long double
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix size must match solution size"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
size_t	long
i	long
;	O
gsl_vector_memcpy	function
(	O
x	long double
,	O
b	pointer
)	O
;	O
gsl_blas_dtrmv	function
(	O
CblasLower	int
,	O
CblasTrans	int
,	O
CblasUnit	int
,	O
QR	pointer
,	O
x	long double
)	O
;	O
gsl_blas_dtrmv	function
(	O
CblasUpper	int
,	O
CblasTrans	int
,	O
CblasNonUnit	int
,	O
T	pointer
,	O
x	long double
)	O
;	O
gsl_blas_dtrmv	function
(	O
CblasLower	int
,	O
CblasNoTrans	int
,	O
CblasUnit	int
,	O
QR	pointer
,	O
x	long double
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
N	int
;	O
++	O
i	long
)	O
{	O
double	O
*	O
xi	pointer
=	O
gsl_vector_ptr	function
(	O
x	long double
,	O
i	long
)	O
;	O
double	O
bi	double
=	O
gsl_vector_get	function
(	O
b	pointer
,	O
i	long
)	O
;	O
*	O
xi	pointer
=	O
bi	double
-	O
(	O
*	O
xi	pointer
)	O
;	O
}	O
gsl_blas_dtrsv	function
(	O
CblasUpper	int
,	O
CblasNoTrans	int
,	O
CblasNonUnit	int
,	O
QR	pointer
,	O
x	long double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_linalg_QR_lssolve_r	function
(	O
const	O
gsl_matrix	struct
*	O
QR	pointer
,	O
const	O
gsl_matrix	struct
*	O
T	pointer
,	O
const	O
gsl_vector	struct
*	O
b	pointer
,	O
gsl_vector	struct
*	O
x	long double
,	O
gsl_vector	struct
*	O
work	pointer
)	O
{	O
const	O
size_t	long
M	int
=	O
QR	pointer
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
QR	pointer
->	O
size2	long
;	O
if	O
(	O
M	int
<	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"QR matrix must have M >= N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
T	pointer
->	O
size1	long
!=	O
N	int
||	O
T	pointer
->	O
size2	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"T matrix must be N-by-N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
M	int
!=	O
b	pointer
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix size must match b size"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
M	int
!=	O
x	long double
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix size must match solution size"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
!=	O
work	pointer
->	O
size	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix size must match work size"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
gsl_matrix_const_view	struct
R	pointer
=	O
gsl_matrix_const_submatrix	function
(	O
QR	pointer
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
gsl_vector_view	struct
x1	double
=	O
gsl_vector_subvector	function
(	O
x	long double
,	O
0	int
,	O
N	int
)	O
;	O
gsl_vector_memcpy	function
(	O
x	long double
,	O
b	pointer
)	O
;	O
gsl_linalg_QR_QTvec_r	function
(	O
QR	pointer
,	O
T	pointer
,	O
x	long double
,	O
work	pointer
)	O
;	O
gsl_blas_dtrsv	function
(	O
CblasUpper	int
,	O
CblasNoTrans	int
,	O
CblasNonUnit	int
,	O
&	O
R	pointer
.	O
matrix	struct
,	O
&	O
x1	double
.	O
vector	struct
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_linalg_QR_unpack_r	function
(	O
const	O
gsl_matrix	struct
*	O
QR	pointer
,	O
const	O
gsl_matrix	struct
*	O
T	pointer
,	O
gsl_matrix	struct
*	O
Q	pointer
,	O
gsl_matrix	struct
*	O
R	pointer
)	O
{	O
const	O
size_t	long
M	int
=	O
QR	pointer
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
QR	pointer
->	O
size2	long
;	O
if	O
(	O
M	int
<	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"M must be >= N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
Q	pointer
->	O
size1	long
!=	O
M	int
||	O
Q	pointer
->	O
size2	long
!=	O
M	int
)	O
{	O
GSL_ERROR	O
(	O
"Q matrix must be M-by-M"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
R	pointer
->	O
size1	long
!=	O
N	int
||	O
R	pointer
->	O
size2	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"R matrix must be N-by-N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
T	pointer
->	O
size1	long
!=	O
N	int
||	O
T	pointer
->	O
size2	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"T matrix must be N-by-N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
gsl_matrix_const_view	struct
RV	struct
=	O
gsl_matrix_const_submatrix	function
(	O
QR	pointer
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
gsl_matrix_view	struct
Q1	struct
=	O
gsl_matrix_submatrix	function
(	O
Q	pointer
,	O
0	int
,	O
0	int
,	O
M	int
,	O
N	int
)	O
;	O
gsl_matrix_view	struct
m	pointer
;	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
Q	pointer
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
gsl_matrix_tricpy	function
(	O
CblasUpper	int
,	O
CblasNonUnit	int
,	O
&	O
m	pointer
.	O
matrix	struct
,	O
T	pointer
)	O
;	O
gsl_matrix_tricpy	function
(	O
CblasLower	int
,	O
CblasUnit	int
,	O
&	O
m	pointer
.	O
matrix	struct
,	O
&	O
RV	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
M	int
>	O
N	int
)	O
{	O
gsl_matrix_const_view	struct
tmp	struct
=	O
gsl_matrix_const_submatrix	function
(	O
QR	pointer
,	O
N	int
,	O
0	int
,	O
M	int
-	O
N	int
,	O
N	int
)	O
;	O
m	pointer
=	O
gsl_matrix_submatrix	function
(	O
Q	pointer
,	O
N	int
,	O
0	int
,	O
M	int
-	O
N	int
,	O
N	int
)	O
;	O
gsl_matrix_memcpy	function
(	O
&	O
m	pointer
.	O
matrix	struct
,	O
&	O
tmp	struct
.	O
matrix	struct
)	O
;	O
}	O
unpack_Q1	function
(	O
&	O
Q1	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
M	int
>	O
N	int
)	O
{	O
gsl_matrix_view	struct
Q2	struct
=	O
gsl_matrix_submatrix	function
(	O
Q	pointer
,	O
0	int
,	O
N	int
,	O
M	int
,	O
M	int
-	O
N	int
)	O
;	O
unpack_Q2	function
(	O
QR	pointer
,	O
T	pointer
,	O
&	O
Q2	struct
.	O
matrix	struct
)	O
;	O
}	O
gsl_matrix_tricpy	function
(	O
CblasUpper	int
,	O
CblasNonUnit	int
,	O
R	pointer
,	O
&	O
RV	struct
.	O
matrix	struct
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_linalg_QR_QTvec_r	function
(	O
const	O
gsl_matrix	struct
*	O
QR	pointer
,	O
const	O
gsl_matrix	struct
*	O
T	pointer
,	O
gsl_vector	struct
*	O
b	pointer
,	O
gsl_vector	struct
*	O
work	pointer
)	O
{	O
const	O
size_t	long
M	int
=	O
QR	pointer
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
QR	pointer
->	O
size2	long
;	O
if	O
(	O
M	int
<	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"M must be >= N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
T	pointer
->	O
size1	long
!=	O
N	int
||	O
T	pointer
->	O
size2	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"T matrix must be N-by-N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
b	pointer
->	O
size	long
!=	O
M	int
)	O
{	O
GSL_ERROR	O
(	O
"b vector must have length M"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
work	pointer
->	O
size	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"workspace must be length N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
gsl_matrix_const_view	struct
V1	struct
=	O
gsl_matrix_const_submatrix	function
(	O
QR	pointer
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
gsl_vector_view	struct
b1	pointer
=	O
gsl_vector_subvector	function
(	O
b	pointer
,	O
0	int
,	O
N	int
)	O
;	O
gsl_vector_view	struct
b2	float
;	O
gsl_vector_memcpy	function
(	O
work	pointer
,	O
&	O
b1	pointer
.	O
vector	struct
)	O
;	O
gsl_blas_dtrmv	function
(	O
CblasLower	int
,	O
CblasTrans	int
,	O
CblasUnit	int
,	O
&	O
V1	struct
.	O
matrix	struct
,	O
work	pointer
)	O
;	O
if	O
(	O
M	int
>	O
N	int
)	O
{	O
gsl_matrix_const_view	struct
V2	struct
=	O
gsl_matrix_const_submatrix	function
(	O
QR	pointer
,	O
N	int
,	O
0	int
,	O
M	int
-	O
N	int
,	O
N	int
)	O
;	O
b2	float
=	O
gsl_vector_subvector	function
(	O
b	pointer
,	O
N	int
,	O
M	int
-	O
N	int
)	O
;	O
gsl_blas_dgemv	function
(	O
CblasTrans	int
,	O
1.0	int
,	O
&	O
V2	struct
.	O
matrix	struct
,	O
&	O
b2	float
.	O
vector	struct
,	O
1.0	int
,	O
work	pointer
)	O
;	O
}	O
gsl_blas_dtrmv	function
(	O
CblasUpper	int
,	O
CblasTrans	int
,	O
CblasNonUnit	int
,	O
T	pointer
,	O
work	pointer
)	O
;	O
if	O
(	O
M	int
>	O
N	int
)	O
{	O
gsl_matrix_const_view	struct
V2	struct
=	O
gsl_matrix_const_submatrix	function
(	O
QR	pointer
,	O
N	int
,	O
0	int
,	O
M	int
-	O
N	int
,	O
N	int
)	O
;	O
gsl_blas_dgemv	function
(	O
CblasNoTrans	int
,	O
-	O
1.0	int
,	O
&	O
V2	struct
.	O
matrix	struct
,	O
work	pointer
,	O
1.0	int
,	O
&	O
b2	float
.	O
vector	struct
)	O
;	O
}	O
gsl_blas_dtrmv	function
(	O
CblasLower	int
,	O
CblasNoTrans	int
,	O
CblasUnit	int
,	O
&	O
V1	struct
.	O
matrix	struct
,	O
work	pointer
)	O
;	O
gsl_vector_sub	function
(	O
&	O
b1	pointer
.	O
vector	struct
,	O
work	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_linalg_QR_QTmat_r	function
(	O
const	O
gsl_matrix	struct
*	O
QR	pointer
,	O
const	O
gsl_matrix	struct
*	O
T	pointer
,	O
gsl_matrix	struct
*	O
B	pointer
,	O
gsl_matrix	struct
*	O
work	pointer
)	O
{	O
const	O
size_t	long
M	int
=	O
QR	pointer
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
QR	pointer
->	O
size2	long
;	O
const	O
size_t	long
K	int
=	O
B	pointer
->	O
size2	long
;	O
if	O
(	O
M	int
<	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"M must be >= N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
T	pointer
->	O
size1	long
!=	O
N	int
||	O
T	pointer
->	O
size2	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"T matrix must be N-by-N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
B	pointer
->	O
size1	long
!=	O
M	int
)	O
{	O
GSL_ERROR	O
(	O
"B matrix must have M rows"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
work	pointer
->	O
size1	long
!=	O
N	int
||	O
work	pointer
->	O
size2	long
!=	O
K	int
)	O
{	O
GSL_ERROR	O
(	O
"workspace must be N-by-K"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
gsl_matrix_const_view	struct
V1	struct
=	O
gsl_matrix_const_submatrix	function
(	O
QR	pointer
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
gsl_matrix_view	struct
B1	struct
=	O
gsl_matrix_submatrix	function
(	O
B	pointer
,	O
0	int
,	O
0	int
,	O
N	int
,	O
K	int
)	O
;	O
gsl_matrix_view	struct
B2	struct
;	O
gsl_matrix_memcpy	function
(	O
work	pointer
,	O
&	O
B1	struct
.	O
matrix	struct
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasLeft	int
,	O
CblasLower	int
,	O
CblasTrans	int
,	O
CblasUnit	int
,	O
1.0	int
,	O
&	O
V1	struct
.	O
matrix	struct
,	O
work	pointer
)	O
;	O
if	O
(	O
M	int
>	O
N	int
)	O
{	O
gsl_matrix_const_view	struct
V2	struct
=	O
gsl_matrix_const_submatrix	function
(	O
QR	pointer
,	O
N	int
,	O
0	int
,	O
M	int
-	O
N	int
,	O
N	int
)	O
;	O
B2	struct
=	O
gsl_matrix_submatrix	function
(	O
B	pointer
,	O
N	int
,	O
0	int
,	O
M	int
-	O
N	int
,	O
K	int
)	O
;	O
gsl_blas_dgemm	function
(	O
CblasTrans	int
,	O
CblasNoTrans	int
,	O
1.0	int
,	O
&	O
V2	struct
.	O
matrix	struct
,	O
&	O
B2	struct
.	O
matrix	struct
,	O
1.0	int
,	O
work	pointer
)	O
;	O
}	O
gsl_blas_dtrmm	function
(	O
CblasLeft	int
,	O
CblasUpper	int
,	O
CblasTrans	int
,	O
CblasNonUnit	int
,	O
1.0	int
,	O
T	pointer
,	O
work	pointer
)	O
;	O
if	O
(	O
M	int
>	O
N	int
)	O
{	O
gsl_matrix_const_view	struct
V2	struct
=	O
gsl_matrix_const_submatrix	function
(	O
QR	pointer
,	O
N	int
,	O
0	int
,	O
M	int
-	O
N	int
,	O
N	int
)	O
;	O
gsl_blas_dgemm	function
(	O
CblasNoTrans	int
,	O
CblasNoTrans	int
,	O
-	O
1.0	int
,	O
&	O
V2	struct
.	O
matrix	struct
,	O
work	pointer
,	O
1.0	int
,	O
&	O
B2	struct
.	O
matrix	struct
)	O
;	O
}	O
gsl_blas_dtrmm	function
(	O
CblasLeft	int
,	O
CblasLower	int
,	O
CblasNoTrans	int
,	O
CblasUnit	int
,	O
1.0	int
,	O
&	O
V1	struct
.	O
matrix	struct
,	O
work	pointer
)	O
;	O
gsl_matrix_sub	function
(	O
&	O
B1	struct
.	O
matrix	struct
,	O
work	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
unpack_Q1	function
(	O
gsl_matrix	struct
*	O
Q	pointer
)	O
{	O
int	O
status	int
;	O
const	O
size_t	long
M	int
=	O
Q	pointer
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
Q	pointer
->	O
size2	long
;	O
gsl_matrix_view	struct
Q1	struct
=	O
gsl_matrix_submatrix	function
(	O
Q	pointer
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
gsl_vector_view	struct
diag	pointer
=	O
gsl_matrix_diagonal	function
(	O
&	O
Q1	struct
.	O
matrix	struct
)	O
;	O
status	int
=	O
aux_ULT	function
(	O
&	O
Q1	struct
.	O
matrix	struct
,	O
&	O
Q1	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
M	int
>	O
N	int
)	O
{	O
gsl_matrix_view	struct
V2	struct
=	O
gsl_matrix_submatrix	function
(	O
Q	pointer
,	O
N	int
,	O
0	int
,	O
M	int
-	O
N	int
,	O
N	int
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasRight	int
,	O
CblasUpper	int
,	O
CblasNoTrans	int
,	O
CblasNonUnit	int
,	O
-	O
1.0	int
,	O
&	O
Q1	struct
.	O
matrix	struct
,	O
&	O
V2	struct
.	O
matrix	struct
)	O
;	O
}	O
status	int
=	O
aux_mLU	function
(	O
&	O
Q1	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
gsl_vector_add_constant	function
(	O
&	O
diag	pointer
.	O
vector	struct
,	O
1.0	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
unpack_Q2	function
(	O
const	O
gsl_matrix	struct
*	O
QR	pointer
,	O
const	O
gsl_matrix	struct
*	O
T	pointer
,	O
gsl_matrix	struct
*	O
Q	pointer
)	O
{	O
const	O
size_t	long
M	int
=	O
QR	pointer
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
QR	pointer
->	O
size2	long
;	O
if	O
(	O
M	int
<=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"M must be > N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
T	pointer
->	O
size1	long
!=	O
N	int
||	O
T	pointer
->	O
size2	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"T matrix must be N-by-N"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
Q	pointer
->	O
size1	long
!=	O
M	int
||	O
Q	pointer
->	O
size2	long
!=	O
(	O
M	int
-	O
N	int
)	O
)	O
{	O
GSL_ERROR	O
(	O
"Q matrix must be M-by-(M-N)"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
{	O
gsl_matrix_const_view	struct
V1	struct
=	O
gsl_matrix_const_submatrix	function
(	O
QR	pointer
,	O
0	int
,	O
0	int
,	O
N	int
,	O
N	int
)	O
;	O
gsl_matrix_const_view	struct
V2	struct
=	O
gsl_matrix_const_submatrix	function
(	O
QR	pointer
,	O
N	int
,	O
0	int
,	O
M	int
-	O
N	int
,	O
N	int
)	O
;	O
gsl_matrix_view	struct
Q1	struct
=	O
gsl_matrix_submatrix	function
(	O
Q	pointer
,	O
0	int
,	O
0	int
,	O
N	int
,	O
M	int
-	O
N	int
)	O
;	O
gsl_matrix_view	struct
Q2	struct
=	O
gsl_matrix_submatrix	function
(	O
Q	pointer
,	O
N	int
,	O
0	int
,	O
M	int
-	O
N	int
,	O
M	int
-	O
N	int
)	O
;	O
gsl_vector_view	struct
diag	pointer
=	O
gsl_matrix_diagonal	function
(	O
&	O
Q2	struct
.	O
matrix	struct
)	O
;	O
gsl_matrix_transpose_memcpy	function
(	O
&	O
Q1	struct
.	O
matrix	struct
,	O
&	O
V2	struct
.	O
matrix	struct
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasLeft	int
,	O
CblasUpper	int
,	O
CblasNoTrans	int
,	O
CblasNonUnit	int
,	O
-	O
1.0	int
,	O
T	pointer
,	O
&	O
Q1	struct
.	O
matrix	struct
)	O
;	O
gsl_blas_dgemm	function
(	O
CblasNoTrans	int
,	O
CblasNoTrans	int
,	O
1.0	int
,	O
&	O
V2	struct
.	O
matrix	struct
,	O
&	O
Q1	struct
.	O
matrix	struct
,	O
0.0	int
,	O
&	O
Q2	struct
.	O
matrix	struct
)	O
;	O
gsl_vector_add_constant	function
(	O
&	O
diag	pointer
.	O
vector	struct
,	O
1.0	int
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasLeft	int
,	O
CblasLower	int
,	O
CblasNoTrans	int
,	O
CblasUnit	int
,	O
1.0	int
,	O
&	O
V1	struct
.	O
matrix	struct
,	O
&	O
Q1	struct
.	O
matrix	struct
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
aux_ULT	function
(	O
const	O
gsl_matrix	struct
*	O
L	pointer
,	O
gsl_matrix	struct
*	O
U	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
L	pointer
->	O
size1	long
;	O
if	O
(	O
N	int
!=	O
L	pointer
->	O
size2	long
)	O
{	O
GSL_ERROR	O
(	O
"L matrix must be square"	pointer
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
U	pointer
->	O
size1	long
!=	O
N	int
||	O
U	pointer
->	O
size2	long
!=	O
N	int
)	O
{	O
GSL_ERROR	O
(	O
"U matrix must be same size as L"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
==	O
1	int
)	O
{	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
status	int
;	O
const	O
size_t	long
N1	long
=	O
N	int
/	O
2	int
;	O
const	O
size_t	long
N2	long
=	O
N	int
-	O
N1	long
;	O
gsl_matrix_const_view	struct
L11	struct
=	O
gsl_matrix_const_submatrix	function
(	O
L	pointer
,	O
0	int
,	O
0	int
,	O
N1	long
,	O
N1	long
)	O
;	O
gsl_matrix_const_view	struct
L21	struct
=	O
gsl_matrix_const_submatrix	function
(	O
L	pointer
,	O
N1	long
,	O
0	int
,	O
N2	long
,	O
N1	long
)	O
;	O
gsl_matrix_const_view	struct
L22	struct
=	O
gsl_matrix_const_submatrix	function
(	O
L	pointer
,	O
N1	long
,	O
N1	long
,	O
N2	long
,	O
N2	long
)	O
;	O
gsl_matrix_view	struct
U11	struct
=	O
gsl_matrix_submatrix	function
(	O
U	pointer
,	O
0	int
,	O
0	int
,	O
N1	long
,	O
N1	long
)	O
;	O
gsl_matrix_view	struct
U12	struct
=	O
gsl_matrix_submatrix	function
(	O
U	pointer
,	O
0	int
,	O
N1	long
,	O
N1	long
,	O
N2	long
)	O
;	O
gsl_matrix_view	struct
U22	struct
=	O
gsl_matrix_submatrix	function
(	O
U	pointer
,	O
N1	long
,	O
N1	long
,	O
N2	long
,	O
N2	long
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasRight	int
,	O
CblasLower	int
,	O
CblasTrans	int
,	O
CblasUnit	int
,	O
1.0	int
,	O
&	O
L22	struct
.	O
matrix	struct
,	O
&	O
U12	struct
.	O
matrix	struct
)	O
;	O
status	int
=	O
aux_ApUBT	function
(	O
&	O
U11	struct
.	O
matrix	struct
,	O
&	O
L21	struct
.	O
matrix	struct
,	O
&	O
U12	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
aux_ULT	function
(	O
&	O
L11	struct
.	O
matrix	struct
,	O
&	O
U11	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
aux_ULT	function
(	O
&	O
L22	struct
.	O
matrix	struct
,	O
&	O
U22	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
aux_mLU	function
(	O
gsl_matrix	struct
*	O
A	pointer
)	O
{	O
const	O
size_t	long
N	int
=	O
A	pointer
->	O
size1	long
;	O
if	O
(	O
N	int
!=	O
A	pointer
->	O
size2	long
)	O
{	O
GSL_ERROR	O
(	O
"matrix must be square"	pointer
,	O
GSL_ENOTSQR	int
)	O
;	O
}	O
else	O
if	O
(	O
N	int
==	O
1	int
)	O
{	O
double	O
*	O
A00	pointer
=	O
gsl_matrix_ptr	function
(	O
A	pointer
,	O
0	int
,	O
0	int
)	O
;	O
*	O
A00	pointer
=	O
-	O
(	O
*	O
A00	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
status	int
;	O
const	O
size_t	long
N1	long
=	O
N	int
/	O
2	int
;	O
const	O
size_t	long
N2	long
=	O
N	int
-	O
N1	long
;	O
gsl_matrix_view	struct
A11	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
0	int
,	O
0	int
,	O
N1	long
,	O
N1	long
)	O
;	O
gsl_matrix_view	struct
A12	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
0	int
,	O
N1	long
,	O
N1	long
,	O
N2	long
)	O
;	O
gsl_matrix_view	struct
A21	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
N1	long
,	O
0	int
,	O
N2	long
,	O
N1	long
)	O
;	O
gsl_matrix_view	struct
A22	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
N1	long
,	O
N1	long
,	O
N2	long
,	O
N2	long
)	O
;	O
status	int
=	O
aux_mLU	function
(	O
&	O
A22	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
gsl_blas_dgemm	function
(	O
CblasNoTrans	int
,	O
CblasNoTrans	int
,	O
-	O
1.0	int
,	O
&	O
A21	struct
.	O
matrix	struct
,	O
&	O
A12	struct
.	O
matrix	struct
,	O
1.0	int
,	O
&	O
A22	struct
.	O
matrix	struct
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasLeft	int
,	O
CblasLower	int
,	O
CblasNoTrans	int
,	O
CblasUnit	int
,	O
-	O
1.0	int
,	O
&	O
A11	struct
.	O
matrix	struct
,	O
&	O
A12	struct
.	O
matrix	struct
)	O
;	O
gsl_blas_dtrmm	function
(	O
CblasRight	int
,	O
CblasUpper	int
,	O
CblasNoTrans	int
,	O
CblasNonUnit	int
,	O
-	O
1.0	int
,	O
&	O
A11	struct
.	O
matrix	struct
,	O
&	O
A21	struct
.	O
matrix	struct
)	O
;	O
status	int
=	O
aux_mLU	function
(	O
&	O
A11	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
aux_ApUBT	function
(	O
const	O
gsl_matrix	struct
*	O
U	pointer
,	O
const	O
gsl_matrix	struct
*	O
B	pointer
,	O
gsl_matrix	struct
*	O
A	pointer
)	O
{	O
const	O
size_t	long
M	int
=	O
A	pointer
->	O
size1	long
;	O
const	O
size_t	long
N	int
=	O
A	pointer
->	O
size2	long
;	O
if	O
(	O
U	pointer
->	O
size1	long
!=	O
M	int
||	O
U	pointer
->	O
size2	long
!=	O
M	int
)	O
{	O
GSL_ERROR	O
(	O
"U matrix has wrong dimensions"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
B	pointer
->	O
size1	long
!=	O
N	int
||	O
B	pointer
->	O
size2	long
!=	O
M	int
)	O
{	O
GSL_ERROR	O
(	O
"B matrix has wrong dimensions"	pointer
,	O
GSL_EBADLEN	int
)	O
;	O
}	O
else	O
if	O
(	O
M	int
==	O
1	int
&&	O
N	int
==	O
1	int
)	O
{	O
double	O
*	O
aptr	pointer
=	O
gsl_matrix_ptr	function
(	O
A	pointer
,	O
0	int
,	O
0	int
)	O
;	O
const	O
double	O
*	O
uptr	pointer
=	O
gsl_matrix_const_ptr	function
(	O
U	pointer
,	O
0	int
,	O
0	int
)	O
;	O
const	O
double	O
*	O
bptr	pointer
=	O
gsl_matrix_const_ptr	function
(	O
B	pointer
,	O
0	int
,	O
0	int
)	O
;	O
*	O
aptr	pointer
+=	O
(	O
*	O
uptr	pointer
)	O
*	O
(	O
*	O
bptr	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
M	int
==	O
1	int
)	O
{	O
double	O
U00	double
=	O
gsl_matrix_get	function
(	O
U	pointer
,	O
0	int
,	O
0	int
)	O
;	O
gsl_vector_view	struct
v	pointer
=	O
gsl_matrix_row	function
(	O
A	pointer
,	O
0	int
)	O
;	O
gsl_vector_const_view	struct
w	pointer
=	O
gsl_matrix_const_column	function
(	O
B	pointer
,	O
0	int
)	O
;	O
gsl_blas_daxpy	function
(	O
U00	double
,	O
&	O
w	pointer
.	O
vector	struct
,	O
&	O
v	pointer
.	O
vector	struct
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
N	int
==	O
1	int
)	O
{	O
int	O
status	int
;	O
const	O
size_t	long
M1	long
=	O
M	int
/	O
2	int
;	O
const	O
size_t	long
M2	long
=	O
M	int
-	O
M1	long
;	O
gsl_matrix_view	struct
A11	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
0	int
,	O
0	int
,	O
M1	long
,	O
1	int
)	O
;	O
gsl_matrix_view	struct
A21	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
M1	long
,	O
0	int
,	O
M2	long
,	O
1	int
)	O
;	O
gsl_vector_view	struct
a1	struct
=	O
gsl_matrix_subcolumn	function
(	O
A	pointer
,	O
0	int
,	O
0	int
,	O
M1	long
)	O
;	O
gsl_matrix_const_view	struct
U11	struct
=	O
gsl_matrix_const_submatrix	function
(	O
U	pointer
,	O
0	int
,	O
0	int
,	O
M1	long
,	O
M1	long
)	O
;	O
gsl_matrix_const_view	struct
U12	struct
=	O
gsl_matrix_const_submatrix	function
(	O
U	pointer
,	O
0	int
,	O
M1	long
,	O
M1	long
,	O
M2	long
)	O
;	O
gsl_matrix_const_view	struct
U22	struct
=	O
gsl_matrix_const_submatrix	function
(	O
U	pointer
,	O
M1	long
,	O
M1	long
,	O
M2	long
,	O
M2	long
)	O
;	O
gsl_matrix_const_view	struct
B11	struct
=	O
gsl_matrix_const_submatrix	function
(	O
B	pointer
,	O
0	int
,	O
0	int
,	O
1	int
,	O
M1	long
)	O
;	O
gsl_matrix_const_view	struct
B12	struct
=	O
gsl_matrix_const_submatrix	function
(	O
B	pointer
,	O
0	int
,	O
M1	long
,	O
1	int
,	O
M2	long
)	O
;	O
gsl_vector_const_view	struct
b2	float
=	O
gsl_matrix_const_subrow	function
(	O
B	pointer
,	O
0	int
,	O
M1	long
,	O
M2	long
)	O
;	O
gsl_blas_dgemv	function
(	O
CblasNoTrans	int
,	O
1.0	int
,	O
&	O
U12	struct
.	O
matrix	struct
,	O
&	O
b2	float
.	O
vector	struct
,	O
1.0	int
,	O
&	O
a1	struct
.	O
vector	struct
)	O
;	O
status	int
=	O
aux_ApUBT	function
(	O
&	O
U11	struct
.	O
matrix	struct
,	O
&	O
B11	struct
.	O
matrix	struct
,	O
&	O
A11	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
aux_ApUBT	function
(	O
&	O
U22	struct
.	O
matrix	struct
,	O
&	O
B12	struct
.	O
matrix	struct
,	O
&	O
A21	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
status	int
;	O
const	O
size_t	long
M1	long
=	O
M	int
/	O
2	int
;	O
const	O
size_t	long
M2	long
=	O
M	int
-	O
M1	long
;	O
const	O
size_t	long
N1	long
=	O
N	int
/	O
2	int
;	O
const	O
size_t	long
N2	long
=	O
N	int
-	O
N1	long
;	O
gsl_matrix_view	struct
A11	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
0	int
,	O
0	int
,	O
M1	long
,	O
N1	long
)	O
;	O
gsl_matrix_view	struct
A12	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
0	int
,	O
N1	long
,	O
M1	long
,	O
N2	long
)	O
;	O
gsl_matrix_view	struct
A21	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
M1	long
,	O
0	int
,	O
M2	long
,	O
N1	long
)	O
;	O
gsl_matrix_view	struct
A22	struct
=	O
gsl_matrix_submatrix	function
(	O
A	pointer
,	O
M1	long
,	O
N1	long
,	O
M2	long
,	O
N2	long
)	O
;	O
gsl_matrix_const_view	struct
U11	struct
=	O
gsl_matrix_const_submatrix	function
(	O
U	pointer
,	O
0	int
,	O
0	int
,	O
M1	long
,	O
M1	long
)	O
;	O
gsl_matrix_const_view	struct
U12	struct
=	O
gsl_matrix_const_submatrix	function
(	O
U	pointer
,	O
0	int
,	O
M1	long
,	O
M1	long
,	O
M2	long
)	O
;	O
gsl_matrix_const_view	struct
U22	struct
=	O
gsl_matrix_const_submatrix	function
(	O
U	pointer
,	O
M1	long
,	O
M1	long
,	O
M2	long
,	O
M2	long
)	O
;	O
gsl_matrix_const_view	struct
B11	struct
=	O
gsl_matrix_const_submatrix	function
(	O
B	pointer
,	O
0	int
,	O
0	int
,	O
N1	long
,	O
M1	long
)	O
;	O
gsl_matrix_const_view	struct
B12	struct
=	O
gsl_matrix_const_submatrix	function
(	O
B	pointer
,	O
0	int
,	O
M1	long
,	O
N1	long
,	O
M2	long
)	O
;	O
gsl_matrix_const_view	struct
B21	struct
=	O
gsl_matrix_const_submatrix	function
(	O
B	pointer
,	O
N1	long
,	O
0	int
,	O
N2	long
,	O
M1	long
)	O
;	O
gsl_matrix_const_view	struct
B22	struct
=	O
gsl_matrix_const_submatrix	function
(	O
B	pointer
,	O
N1	long
,	O
M1	long
,	O
N2	long
,	O
M2	long
)	O
;	O
status	int
=	O
aux_ApUBT	function
(	O
&	O
U11	struct
.	O
matrix	struct
,	O
&	O
B11	struct
.	O
matrix	struct
,	O
&	O
A11	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
gsl_blas_dgemm	function
(	O
CblasNoTrans	int
,	O
CblasTrans	int
,	O
1.0	int
,	O
&	O
U12	struct
.	O
matrix	struct
,	O
&	O
B12	struct
.	O
matrix	struct
,	O
1.0	int
,	O
&	O
A11	struct
.	O
matrix	struct
)	O
;	O
status	int
=	O
aux_ApUBT	function
(	O
&	O
U11	struct
.	O
matrix	struct
,	O
&	O
B21	struct
.	O
matrix	struct
,	O
&	O
A12	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
gsl_blas_dgemm	function
(	O
CblasNoTrans	int
,	O
CblasTrans	int
,	O
1.0	int
,	O
&	O
U12	struct
.	O
matrix	struct
,	O
&	O
B22	struct
.	O
matrix	struct
,	O
1.0	int
,	O
&	O
A12	struct
.	O
matrix	struct
)	O
;	O
status	int
=	O
aux_ApUBT	function
(	O
&	O
U22	struct
.	O
matrix	struct
,	O
&	O
B12	struct
.	O
matrix	struct
,	O
&	O
A21	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
aux_ApUBT	function
(	O
&	O
U22	struct
.	O
matrix	struct
,	O
&	O
B22	struct
.	O
matrix	struct
,	O
&	O
A22	struct
.	O
matrix	struct
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
