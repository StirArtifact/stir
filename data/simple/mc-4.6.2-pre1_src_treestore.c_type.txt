static	O
struct	O
TreeStore	struct
ts	struct
;	O
static	O
tree_entry	struct
*	O
tree_store_add_entry	function
(	O
const	O
char	O
*	O
name	pointer
)	O
;	O
static	O
void	O
tree_store_dirty	function
(	O
int	O
state	pointer
)	O
{	O
ts	struct
.	O
dirty	int
=	O
state	pointer
;	O
}	O
static	O
size_t	long
str_common	function
(	O
const	O
char	O
*	O
s1	pointer
,	O
const	O
char	O
*	O
s2	pointer
)	O
{	O
size_t	long
result	long
=	O
0	int
;	O
while	O
(	O
*	O
s1	pointer
!=	O
'\0'	O
&&	O
*	O
s2	pointer
!=	O
'\0'	O
&&	O
*	O
s1	pointer
++	O
==	O
*	O
s2	pointer
++	O
)	O
result	long
++	O
;	O
return	O
result	long
;	O
}	O
static	O
int	O
pathcmp	function
(	O
const	O
char	O
*	O
p1	pointer
,	O
const	O
char	O
*	O
p2	pointer
)	O
{	O
for	O
(	O
;	O
*	O
p1	pointer
==	O
*	O
p2	pointer
;	O
p1	pointer
++	O
,	O
p2	pointer
++	O
)	O
if	O
(	O
*	O
p1	pointer
==	O
'\0'	O
)	O
return	O
0	int
;	O
if	O
(	O
*	O
p1	pointer
==	O
'\0'	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
p2	pointer
==	O
'\0'	O
)	O
return	O
1	int
;	O
if	O
(	O
*	O
p1	pointer
==	O
PATH_SEP	char
)	O
return	O
-	O
1	int
;	O
if	O
(	O
*	O
p2	pointer
==	O
PATH_SEP	char
)	O
return	O
1	int
;	O
return	O
(	O
*	O
p1	pointer
-	O
*	O
p2	pointer
)	O
;	O
}	O
tree_entry	struct
*	O
tree_store_whereis	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
tree_entry	struct
*	O
current	pointer
=	O
ts	struct
.	O
tree_first	pointer
;	O
int	O
flag	int
=	O
-	O
1	int
;	O
while	O
(	O
current	pointer
&&	O
(	O
flag	int
=	O
pathcmp	function
(	O
current	pointer
->	O
name	pointer
,	O
name	pointer
)	O
)	O
<	O
0	int
)	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
if	O
(	O
flag	int
==	O
0	int
)	O
return	O
current	pointer
;	O
else	O
return	O
NULL	O
;	O
}	O
struct	O
TreeStore	struct
*	O
tree_store_get	function
(	O
void	O
)	O
{	O
return	O
&	O
ts	struct
;	O
}	O
static	O
char	O
*	O
decode	function
(	O
char	O
*	O
buffer	pointer
)	O
{	O
char	O
*	O
res	pointer
=	O
g_strdup	function
(	O
buffer	pointer
)	O
;	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
for	O
(	O
p	pointer
=	O
q	pointer
=	O
res	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
,	O
q	pointer
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
)	O
{	O
*	O
q	pointer
=	O
0	int
;	O
return	O
res	pointer
;	O
}	O
if	O
(	O
*	O
p	pointer
!=	O
'\\'	O
)	O
{	O
*	O
q	pointer
=	O
*	O
p	pointer
;	O
continue	O
;	O
}	O
p	pointer
++	O
;	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'n'	O
:	O
*	O
q	pointer
=	O
'\n'	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
*	O
q	pointer
=	O
'\\'	O
;	O
break	O
;	O
}	O
}	O
*	O
q	pointer
=	O
*	O
p	pointer
;	O
return	O
res	pointer
;	O
}	O
static	O
int	O
tree_store_load_from	function
(	O
char	O
*	O
name	pointer
)	O
{	O
FILE	struct
*	O
file	pointer
;	O
char	O
buffer	pointer
[	O
MC_MAXPATHLEN	O
+	O
20	int
]	O
,	O
oldname	array
[	O
MC_MAXPATHLEN	O
]	O
;	O
char	O
*	O
different	pointer
;	O
int	O
len	int
,	O
common	int
;	O
int	O
do_load	int
;	O
g_return_val_if_fail	O
(	O
name	pointer
!=	O
NULL	O
,	O
FALSE	O
)	O
;	O
if	O
(	O
ts	struct
.	O
loaded	int
)	O
return	O
TRUE	O
;	O
file	pointer
=	O
fopen	function
(	O
name	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
file	pointer
)	O
{	O
fgets	function
(	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
file	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
buffer	pointer
,	O
TREE_SIGNATURE	pointer
,	O
strlen	function
(	O
TREE_SIGNATURE	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
fclose	function
(	O
file	pointer
)	O
;	O
do_load	int
=	O
FALSE	O
;	O
}	O
else	O
do_load	int
=	O
TRUE	O
;	O
}	O
else	O
do_load	int
=	O
FALSE	O
;	O
if	O
(	O
do_load	int
)	O
{	O
ts	struct
.	O
loaded	int
=	O
TRUE	O
;	O
oldname	array
[	O
0	int
]	O
=	O
0	int
;	O
while	O
(	O
fgets	function
(	O
buffer	pointer
,	O
MC_MAXPATHLEN	O
,	O
file	pointer
)	O
)	O
{	O
tree_entry	struct
*	O
e	pointer
;	O
int	O
scanned	int
;	O
char	O
*	O
name	pointer
;	O
if	O
(	O
(	O
buffer	pointer
[	O
0	int
]	O
!=	O
'0'	O
&&	O
buffer	pointer
[	O
0	int
]	O
!=	O
'1'	O
)	O
)	O
continue	O
;	O
if	O
(	O
buffer	pointer
[	O
1	int
]	O
!=	O
':'	O
)	O
continue	O
;	O
scanned	int
=	O
buffer	pointer
[	O
0	int
]	O
==	O
'1'	O
;	O
name	pointer
=	O
decode	function
(	O
buffer	pointer
+	O
2	int
)	O
;	O
len	int
=	O
strlen	function
(	O
name	pointer
)	O
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
!=	O
PATH_SEP	char
)	O
{	O
char	O
*	O
s	pointer
=	O
strtok	function
(	O
name	pointer
,	O
" "	pointer
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
common	int
=	O
atoi	function
(	O
s	pointer
)	O
;	O
different	pointer
=	O
strtok	function
(	O
NULL	O
,	O
""	pointer
)	O
;	O
if	O
(	O
different	pointer
)	O
{	O
strcpy	function
(	O
oldname	array
+	O
common	int
,	O
different	pointer
)	O
;	O
if	O
(	O
vfs_file_is_local	function
(	O
oldname	array
)	O
)	O
{	O
e	pointer
=	O
tree_store_add_entry	function
(	O
oldname	array
)	O
;	O
e	pointer
->	O
scanned	int
=	O
scanned	int
;	O
}	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
vfs_file_is_local	function
(	O
name	pointer
)	O
)	O
{	O
e	pointer
=	O
tree_store_add_entry	function
(	O
name	pointer
)	O
;	O
e	pointer
->	O
scanned	int
=	O
scanned	int
;	O
}	O
strcpy	function
(	O
oldname	array
,	O
name	pointer
)	O
;	O
}	O
g_free	function
(	O
name	pointer
)	O
;	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
}	O
if	O
(	O
!	O
ts	struct
.	O
tree_first	pointer
)	O
{	O
tree_store_add_entry	function
(	O
PATH_SEP_STR	pointer
)	O
;	O
tree_store_rescan	function
(	O
PATH_SEP_STR	pointer
)	O
;	O
ts	struct
.	O
loaded	int
=	O
TRUE	O
;	O
}	O
return	O
TRUE	O
;	O
}	O
int	O
tree_store_load	function
(	O
void	O
)	O
{	O
char	O
*	O
name	pointer
;	O
int	O
retval	pointer
;	O
name	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
MC_TREE	pointer
)	O
;	O
retval	pointer
=	O
tree_store_load_from	function
(	O
name	pointer
)	O
;	O
g_free	function
(	O
name	pointer
)	O
;	O
return	O
retval	pointer
;	O
}	O
static	O
char	O
*	O
encode	function
(	O
const	O
char	O
*	O
string	pointer
)	O
{	O
int	O
special_chars	int
;	O
const	O
char	O
*	O
p	pointer
;	O
char	O
*	O
q	pointer
;	O
char	O
*	O
res	pointer
;	O
for	O
(	O
special_chars	int
=	O
0	int
,	O
p	pointer
=	O
string	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
||	O
*	O
p	pointer
==	O
'\\'	O
)	O
special_chars	int
++	O
;	O
}	O
res	pointer
=	O
g_malloc	function
(	O
p	pointer
-	O
string	pointer
+	O
special_chars	int
+	O
1	int
)	O
;	O
for	O
(	O
p	pointer
=	O
string	pointer
,	O
q	pointer
=	O
res	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
,	O
q	pointer
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
!=	O
'\n'	O
&&	O
*	O
p	pointer
!=	O
'\\'	O
)	O
{	O
*	O
q	pointer
=	O
*	O
p	pointer
;	O
continue	O
;	O
}	O
*	O
q	pointer
++	O
=	O
'\\'	O
;	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'\n'	O
:	O
*	O
q	pointer
=	O
'n'	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
*	O
q	pointer
=	O
'\\'	O
;	O
break	O
;	O
}	O
}	O
*	O
q	pointer
=	O
0	int
;	O
return	O
res	pointer
;	O
}	O
static	O
int	O
tree_store_save_to	function
(	O
char	O
*	O
name	pointer
)	O
{	O
tree_entry	struct
*	O
current	pointer
;	O
FILE	struct
*	O
file	pointer
;	O
file	pointer
=	O
fopen	function
(	O
name	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
return	O
errno	O
;	O
fprintf	function
(	O
file	pointer
,	O
"%s\n"	pointer
,	O
TREE_SIGNATURE	pointer
)	O
;	O
current	pointer
=	O
ts	struct
.	O
tree_first	pointer
;	O
while	O
(	O
current	pointer
)	O
{	O
int	O
i	array
,	O
common	int
;	O
if	O
(	O
vfs_file_is_local	function
(	O
current	pointer
->	O
name	pointer
)	O
)	O
{	O
if	O
(	O
current	pointer
->	O
prev	pointer
&&	O
(	O
common	int
=	O
str_common	function
(	O
current	pointer
->	O
prev	pointer
->	O
name	pointer
,	O
current	pointer
->	O
name	pointer
)	O
)	O
>	O
2	int
)	O
{	O
char	O
*	O
encoded	pointer
=	O
encode	function
(	O
current	pointer
->	O
name	pointer
+	O
common	int
)	O
;	O
i	array
=	O
fprintf	function
(	O
file	pointer
,	O
"%d:%d %s\n"	pointer
,	O
current	pointer
->	O
scanned	int
,	O
common	int
,	O
encoded	pointer
)	O
;	O
g_free	function
(	O
encoded	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
encoded	pointer
=	O
encode	function
(	O
current	pointer
->	O
name	pointer
)	O
;	O
i	array
=	O
fprintf	function
(	O
file	pointer
,	O
"%d:%s\n"	pointer
,	O
current	pointer
->	O
scanned	int
,	O
encoded	pointer
)	O
;	O
g_free	function
(	O
encoded	pointer
)	O
;	O
}	O
if	O
(	O
i	array
==	O
EOF	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Cannot write to the %s file:\n%s\n"	pointer
)	O
,	O
name	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
break	O
;	O
}	O
}	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
}	O
tree_store_dirty	function
(	O
FALSE	O
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
tree_store_save	function
(	O
void	O
)	O
{	O
char	O
*	O
tmp	pointer
;	O
char	O
*	O
name	pointer
;	O
int	O
retval	pointer
;	O
tmp	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
MC_TREE_TMP	pointer
)	O
;	O
retval	pointer
=	O
tree_store_save_to	function
(	O
tmp	pointer
)	O
;	O
if	O
(	O
retval	pointer
)	O
{	O
g_free	function
(	O
tmp	pointer
)	O
;	O
return	O
retval	pointer
;	O
}	O
name	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
MC_TREE	pointer
)	O
;	O
retval	pointer
=	O
rename	function
(	O
tmp	pointer
,	O
name	pointer
)	O
;	O
g_free	function
(	O
tmp	pointer
)	O
;	O
g_free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
retval	pointer
)	O
return	O
errno	O
;	O
else	O
return	O
0	int
;	O
}	O
static	O
tree_entry	struct
*	O
tree_store_add_entry	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
int	O
flag	int
=	O
-	O
1	int
;	O
tree_entry	struct
*	O
current	pointer
=	O
ts	struct
.	O
tree_first	pointer
;	O
tree_entry	struct
*	O
old	pointer
=	O
NULL	O
;	O
tree_entry	struct
*	O
new	pointer
;	O
int	O
i	array
,	O
len	int
;	O
int	O
submask	long
=	O
0	int
;	O
if	O
(	O
ts	struct
.	O
tree_last	pointer
&&	O
ts	struct
.	O
tree_last	pointer
->	O
next	pointer
)	O
abort	function
(	O
)	O
;	O
while	O
(	O
current	pointer
&&	O
(	O
flag	int
=	O
pathcmp	function
(	O
current	pointer
->	O
name	pointer
,	O
name	pointer
)	O
)	O
<	O
0	int
)	O
{	O
old	pointer
=	O
current	pointer
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
flag	int
==	O
0	int
)	O
return	O
current	pointer
;	O
new	pointer
=	O
g_new0	O
(	O
tree_entry	struct
,	O
1	int
)	O
;	O
if	O
(	O
!	O
current	pointer
)	O
{	O
if	O
(	O
!	O
ts	struct
.	O
tree_first	pointer
)	O
{	O
ts	struct
.	O
tree_first	pointer
=	O
new	pointer
;	O
new	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
old	pointer
->	O
next	pointer
=	O
new	pointer
;	O
new	pointer
->	O
prev	pointer
=	O
old	pointer
;	O
}	O
new	pointer
->	O
next	pointer
=	O
NULL	O
;	O
ts	struct
.	O
tree_last	pointer
=	O
new	pointer
;	O
}	O
else	O
{	O
new	pointer
->	O
prev	pointer
=	O
old	pointer
;	O
if	O
(	O
old	pointer
)	O
{	O
new	pointer
->	O
next	pointer
=	O
old	pointer
->	O
next	pointer
;	O
old	pointer
->	O
next	pointer
=	O
new	pointer
;	O
}	O
else	O
{	O
new	pointer
->	O
next	pointer
=	O
ts	struct
.	O
tree_first	pointer
;	O
ts	struct
.	O
tree_first	pointer
=	O
new	pointer
;	O
}	O
new	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
new	pointer
;	O
}	O
new	pointer
->	O
name	pointer
=	O
g_strdup	function
(	O
name	pointer
)	O
;	O
len	int
=	O
strlen	function
(	O
new	pointer
->	O
name	pointer
)	O
;	O
new	pointer
->	O
sublevel	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
len	int
;	O
i	array
++	O
)	O
if	O
(	O
new	pointer
->	O
name	pointer
[	O
i	array
]	O
==	O
PATH_SEP	char
)	O
{	O
new	pointer
->	O
sublevel	int
++	O
;	O
new	pointer
->	O
subname	pointer
=	O
new	pointer
->	O
name	pointer
+	O
i	array
+	O
1	int
;	O
}	O
if	O
(	O
new	pointer
->	O
next	pointer
)	O
submask	long
=	O
new	pointer
->	O
next	pointer
->	O
submask	long
;	O
else	O
submask	long
=	O
0	int
;	O
submask	long
|=	O
1	int
<<	O
new	pointer
->	O
sublevel	int
;	O
submask	long
&=	O
(	O
2	int
<<	O
new	pointer
->	O
sublevel	int
)	O
-	O
1	int
;	O
new	pointer
->	O
submask	long
=	O
submask	long
;	O
new	pointer
->	O
mark	int
=	O
0	int
;	O
current	pointer
=	O
new	pointer
->	O
prev	pointer
;	O
while	O
(	O
current	pointer
&&	O
current	pointer
->	O
sublevel	int
>	O
new	pointer
->	O
sublevel	int
)	O
{	O
current	pointer
->	O
submask	long
|=	O
1	int
<<	O
new	pointer
->	O
sublevel	int
;	O
current	pointer
=	O
current	pointer
->	O
prev	pointer
;	O
}	O
if	O
(	O
new	pointer
->	O
sublevel	int
>	O
1	int
)	O
{	O
char	O
*	O
parent	pointer
=	O
g_strdup	function
(	O
new	pointer
->	O
name	pointer
)	O
;	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
strlen	function
(	O
parent	pointer
)	O
-	O
1	int
;	O
i	array
>	O
1	int
;	O
i	array
--	O
)	O
{	O
if	O
(	O
parent	pointer
[	O
i	array
]	O
==	O
PATH_SEP	char
)	O
{	O
parent	pointer
[	O
i	array
]	O
=	O
0	int
;	O
tree_store_add_entry	function
(	O
parent	pointer
)	O
;	O
break	O
;	O
}	O
}	O
g_free	function
(	O
parent	pointer
)	O
;	O
}	O
tree_store_dirty	function
(	O
TRUE	O
)	O
;	O
return	O
new	pointer
;	O
}	O
static	O
Hook	struct
*	O
remove_entry_hooks	pointer
;	O
void	O
tree_store_add_entry_remove_hook	function
(	O
tree_store_remove_fn	pointer
callback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
add_hook	function
(	O
&	O
remove_entry_hooks	pointer
,	O
(	O
void	O
(	O
*	O
)	O
(	O
void	O
*	O
)	O
)	O
callback	pointer
,	O
data	pointer
)	O
;	O
}	O
void	O
tree_store_remove_entry_remove_hook	function
(	O
tree_store_remove_fn	pointer
callback	pointer
)	O
{	O
delete_hook	function
(	O
&	O
remove_entry_hooks	pointer
,	O
(	O
void	O
(	O
*	O
)	O
(	O
void	O
*	O
)	O
)	O
callback	pointer
)	O
;	O
}	O
static	O
void	O
tree_store_notify_remove	function
(	O
tree_entry	struct
*	O
entry	pointer
)	O
{	O
Hook	struct
*	O
p	pointer
=	O
remove_entry_hooks	pointer
;	O
tree_store_remove_fn	pointer
r	pointer
;	O
while	O
(	O
p	pointer
)	O
{	O
r	pointer
=	O
(	O
tree_store_remove_fn	pointer
)	O
p	pointer
->	O
hook_fn	pointer
;	O
r	pointer
(	O
entry	pointer
,	O
p	pointer
->	O
hook_data	pointer
)	O
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
;	O
}	O
}	O
static	O
tree_entry	struct
*	O
remove_entry	function
(	O
tree_entry	struct
*	O
entry	pointer
)	O
{	O
tree_entry	struct
*	O
current	pointer
=	O
entry	pointer
->	O
prev	pointer
;	O
long	O
submask	long
=	O
0	int
;	O
tree_entry	struct
*	O
ret	pointer
=	O
NULL	O
;	O
tree_store_notify_remove	function
(	O
entry	pointer
)	O
;	O
if	O
(	O
entry	pointer
->	O
next	pointer
)	O
submask	long
=	O
entry	pointer
->	O
next	pointer
->	O
submask	long
;	O
while	O
(	O
current	pointer
&&	O
current	pointer
->	O
sublevel	int
>	O
entry	pointer
->	O
sublevel	int
)	O
{	O
submask	long
|=	O
1	int
<<	O
current	pointer
->	O
sublevel	int
;	O
submask	long
&=	O
(	O
2	int
<<	O
current	pointer
->	O
sublevel	int
)	O
-	O
1	int
;	O
current	pointer
->	O
submask	long
=	O
submask	long
;	O
current	pointer
=	O
current	pointer
->	O
prev	pointer
;	O
}	O
if	O
(	O
entry	pointer
->	O
prev	pointer
)	O
entry	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
entry	pointer
->	O
next	pointer
;	O
else	O
ts	struct
.	O
tree_first	pointer
=	O
entry	pointer
->	O
next	pointer
;	O
if	O
(	O
entry	pointer
->	O
next	pointer
)	O
entry	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
entry	pointer
->	O
prev	pointer
;	O
else	O
ts	struct
.	O
tree_last	pointer
=	O
entry	pointer
->	O
prev	pointer
;	O
g_free	function
(	O
entry	pointer
->	O
name	pointer
)	O
;	O
g_free	function
(	O
entry	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
void	O
tree_store_remove_entry	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
tree_entry	struct
*	O
current	pointer
,	O
*	O
base	int
,	O
*	O
old	pointer
;	O
int	O
len	int
;	O
g_return_if_fail	O
(	O
name	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
PATH_SEP	char
&&	O
name	pointer
[	O
1	int
]	O
==	O
0	int
)	O
return	O
;	O
base	int
=	O
tree_store_whereis	function
(	O
name	pointer
)	O
;	O
if	O
(	O
!	O
base	int
)	O
return	O
;	O
len	int
=	O
strlen	function
(	O
base	int
->	O
name	pointer
)	O
;	O
current	pointer
=	O
base	int
->	O
next	pointer
;	O
while	O
(	O
current	pointer
&&	O
strncmp	function
(	O
current	pointer
->	O
name	pointer
,	O
base	int
->	O
name	pointer
,	O
len	int
)	O
==	O
0	int
&&	O
(	O
current	pointer
->	O
name	pointer
[	O
len	int
]	O
==	O
'\0'	O
||	O
current	pointer
->	O
name	pointer
[	O
len	int
]	O
==	O
PATH_SEP	char
)	O
)	O
{	O
old	pointer
=	O
current	pointer
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
remove_entry	function
(	O
old	pointer
)	O
;	O
}	O
remove_entry	function
(	O
base	int
)	O
;	O
tree_store_dirty	function
(	O
TRUE	O
)	O
;	O
return	O
;	O
}	O
void	O
tree_store_mark_checked	function
(	O
const	O
char	O
*	O
subname	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
tree_entry	struct
*	O
current	pointer
,	O
*	O
base	int
;	O
int	O
flag	int
=	O
1	int
,	O
len	int
;	O
if	O
(	O
!	O
ts	struct
.	O
loaded	int
)	O
return	O
;	O
if	O
(	O
ts	struct
.	O
check_name	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
subname	pointer
[	O
0	int
]	O
==	O
'.'	O
&&	O
(	O
subname	pointer
[	O
1	int
]	O
==	O
0	int
||	O
(	O
subname	pointer
[	O
1	int
]	O
==	O
'.'	O
&&	O
subname	pointer
[	O
2	int
]	O
==	O
0	int
)	O
)	O
)	O
return	O
;	O
if	O
(	O
ts	struct
.	O
check_name	pointer
[	O
0	int
]	O
==	O
PATH_SEP	char
&&	O
ts	struct
.	O
check_name	pointer
[	O
1	int
]	O
==	O
0	int
)	O
name	pointer
=	O
g_strconcat	function
(	O
PATH_SEP_STR	pointer
,	O
subname	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
else	O
name	pointer
=	O
concat_dir_and_file	function
(	O
ts	struct
.	O
check_name	pointer
,	O
subname	pointer
)	O
;	O
current	pointer
=	O
ts	struct
.	O
check_start	pointer
;	O
while	O
(	O
current	pointer
&&	O
(	O
flag	int
=	O
pathcmp	function
(	O
current	pointer
->	O
name	pointer
,	O
name	pointer
)	O
)	O
<	O
0	int
)	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
if	O
(	O
flag	int
!=	O
0	int
)	O
{	O
current	pointer
=	O
tree_store_add_entry	function
(	O
name	pointer
)	O
;	O
ts	struct
.	O
add_queue	pointer
=	O
g_list_prepend	function
(	O
ts	struct
.	O
add_queue	pointer
,	O
g_strdup	function
(	O
name	pointer
)	O
)	O
;	O
}	O
g_free	function
(	O
name	pointer
)	O
;	O
base	int
=	O
current	pointer
;	O
if	O
(	O
base	int
)	O
{	O
len	int
=	O
strlen	function
(	O
base	int
->	O
name	pointer
)	O
;	O
base	int
->	O
mark	int
=	O
0	int
;	O
current	pointer
=	O
base	int
->	O
next	pointer
;	O
while	O
(	O
current	pointer
&&	O
strncmp	function
(	O
current	pointer
->	O
name	pointer
,	O
base	int
->	O
name	pointer
,	O
len	int
)	O
==	O
0	int
&&	O
(	O
current	pointer
->	O
name	pointer
[	O
len	int
]	O
==	O
'\0'	O
||	O
current	pointer
->	O
name	pointer
[	O
len	int
]	O
==	O
PATH_SEP	char
||	O
len	int
==	O
1	int
)	O
)	O
{	O
current	pointer
->	O
mark	int
=	O
0	int
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
}	O
}	O
}	O
tree_entry	struct
*	O
tree_store_start_check	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
tree_entry	struct
*	O
current	pointer
,	O
*	O
retval	pointer
;	O
int	O
len	int
;	O
if	O
(	O
!	O
ts	struct
.	O
loaded	int
)	O
return	O
NULL	O
;	O
g_return_val_if_fail	O
(	O
ts	struct
.	O
check_name	pointer
==	O
NULL	O
,	O
NULL	O
)	O
;	O
ts	struct
.	O
check_start	pointer
=	O
NULL	O
;	O
current	pointer
=	O
tree_store_whereis	function
(	O
path	pointer
)	O
;	O
if	O
(	O
!	O
current	pointer
)	O
{	O
struct	O
stat	struct
s	pointer
;	O
if	O
(	O
mc_stat	function
(	O
path	pointer
,	O
&	O
s	pointer
)	O
==	O
-	O
1	int
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
S_ISDIR	O
(	O
s	pointer
.	O
st_mode	int
)	O
)	O
return	O
NULL	O
;	O
current	pointer
=	O
tree_store_add_entry	function
(	O
path	pointer
)	O
;	O
ts	struct
.	O
check_name	pointer
=	O
g_strdup	function
(	O
path	pointer
)	O
;	O
return	O
current	pointer
;	O
}	O
ts	struct
.	O
check_name	pointer
=	O
g_strdup	function
(	O
path	pointer
)	O
;	O
retval	pointer
=	O
current	pointer
;	O
ts	struct
.	O
check_start	pointer
=	O
current	pointer
->	O
next	pointer
;	O
len	int
=	O
strlen	function
(	O
ts	struct
.	O
check_name	pointer
)	O
;	O
current	pointer
=	O
ts	struct
.	O
check_start	pointer
;	O
while	O
(	O
current	pointer
&&	O
strncmp	function
(	O
current	pointer
->	O
name	pointer
,	O
ts	struct
.	O
check_name	pointer
,	O
len	int
)	O
==	O
0	int
&&	O
(	O
current	pointer
->	O
name	pointer
[	O
len	int
]	O
==	O
'\0'	O
||	O
current	pointer
->	O
name	pointer
[	O
len	int
]	O
==	O
PATH_SEP	char
||	O
len	int
==	O
1	int
)	O
)	O
{	O
current	pointer
->	O
mark	int
=	O
1	int
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
}	O
return	O
retval	pointer
;	O
}	O
void	O
tree_store_end_check	function
(	O
void	O
)	O
{	O
tree_entry	struct
*	O
current	pointer
,	O
*	O
old	pointer
;	O
int	O
len	int
;	O
GList	struct
*	O
the_queue	pointer
,	O
*	O
l	pointer
;	O
if	O
(	O
!	O
ts	struct
.	O
loaded	int
)	O
return	O
;	O
g_return_if_fail	O
(	O
ts	struct
.	O
check_name	pointer
!=	O
NULL	O
)	O
;	O
len	int
=	O
strlen	function
(	O
ts	struct
.	O
check_name	pointer
)	O
;	O
current	pointer
=	O
ts	struct
.	O
check_start	pointer
;	O
while	O
(	O
current	pointer
&&	O
strncmp	function
(	O
current	pointer
->	O
name	pointer
,	O
ts	struct
.	O
check_name	pointer
,	O
len	int
)	O
==	O
0	int
&&	O
(	O
current	pointer
->	O
name	pointer
[	O
len	int
]	O
==	O
'\0'	O
||	O
current	pointer
->	O
name	pointer
[	O
len	int
]	O
==	O
PATH_SEP	char
||	O
len	int
==	O
1	int
)	O
)	O
{	O
old	pointer
=	O
current	pointer
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
if	O
(	O
old	pointer
->	O
mark	int
)	O
remove_entry	function
(	O
old	pointer
)	O
;	O
}	O
ts	struct
.	O
add_queue	pointer
=	O
g_list_reverse	function
(	O
ts	struct
.	O
add_queue	pointer
)	O
;	O
the_queue	pointer
=	O
ts	struct
.	O
add_queue	pointer
;	O
ts	struct
.	O
add_queue	pointer
=	O
NULL	O
;	O
g_free	function
(	O
ts	struct
.	O
check_name	pointer
)	O
;	O
ts	struct
.	O
check_name	pointer
=	O
NULL	O
;	O
for	O
(	O
l	pointer
=	O
the_queue	pointer
;	O
l	pointer
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
{	O
g_free	function
(	O
l	pointer
->	O
data	pointer
)	O
;	O
}	O
g_list_free	function
(	O
the_queue	pointer
)	O
;	O
}	O
static	O
void	O
process_special_dirs	function
(	O
GList	struct
*	O
*	O
special_dirs	pointer
,	O
char	O
*	O
file	pointer
)	O
{	O
char	O
*	O
token	enum
;	O
char	O
*	O
buffer	pointer
=	O
g_malloc	function
(	O
4096	int
)	O
;	O
char	O
*	O
s	pointer
;	O
GetPrivateProfileString	function
(	O
"Special dirs"	pointer
,	O
"list"	pointer
,	O
""	pointer
,	O
buffer	pointer
,	O
4096	int
,	O
file	pointer
)	O
;	O
s	pointer
=	O
buffer	pointer
;	O
while	O
(	O
(	O
token	enum
=	O
strtok	function
(	O
s	pointer
,	O
","	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
*	O
special_dirs	pointer
=	O
g_list_prepend	function
(	O
*	O
special_dirs	pointer
,	O
g_strdup	function
(	O
token	enum
)	O
)	O
;	O
s	pointer
=	O
NULL	O
;	O
}	O
g_free	function
(	O
buffer	pointer
)	O
;	O
}	O
static	O
gboolean	int
should_skip_directory	function
(	O
const	O
char	O
*	O
dir	pointer
)	O
{	O
static	O
GList	struct
*	O
special_dirs	pointer
;	O
GList	struct
*	O
l	pointer
;	O
static	O
int	O
loaded	int
;	O
if	O
(	O
loaded	int
==	O
0	int
)	O
{	O
loaded	int
=	O
1	int
;	O
setup_init	function
(	O
)	O
;	O
process_special_dirs	function
(	O
&	O
special_dirs	pointer
,	O
profile_name	pointer
)	O
;	O
process_special_dirs	function
(	O
&	O
special_dirs	pointer
,	O
global_profile_name	pointer
)	O
;	O
}	O
for	O
(	O
l	pointer
=	O
special_dirs	pointer
;	O
l	pointer
;	O
l	pointer
=	O
l	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
strncmp	function
(	O
dir	pointer
,	O
l	pointer
->	O
data	pointer
,	O
strlen	function
(	O
l	pointer
->	O
data	pointer
)	O
)	O
==	O
0	int
)	O
return	O
TRUE	O
;	O
}	O
return	O
FALSE	O
;	O
}	O
tree_entry	struct
*	O
tree_store_rescan	function
(	O
const	O
char	O
*	O
dir	pointer
)	O
{	O
DIR	struct
*	O
dirp	pointer
;	O
struct	O
dirent	struct
*	O
dp	pointer
;	O
struct	O
stat	struct
buf	pointer
;	O
tree_entry	struct
*	O
entry	pointer
;	O
if	O
(	O
should_skip_directory	function
(	O
dir	pointer
)	O
)	O
{	O
entry	pointer
=	O
tree_store_add_entry	function
(	O
dir	pointer
)	O
;	O
entry	pointer
->	O
scanned	int
=	O
1	int
;	O
return	O
entry	pointer
;	O
}	O
entry	pointer
=	O
tree_store_start_check	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
!	O
entry	pointer
)	O
return	O
NULL	O
;	O
dirp	pointer
=	O
mc_opendir	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
dirp	pointer
)	O
{	O
for	O
(	O
dp	pointer
=	O
mc_readdir	function
(	O
dirp	pointer
)	O
;	O
dp	pointer
;	O
dp	pointer
=	O
mc_readdir	function
(	O
dirp	pointer
)	O
)	O
{	O
char	O
*	O
full_name	pointer
;	O
if	O
(	O
dp	pointer
->	O
d_name	array
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
if	O
(	O
dp	pointer
->	O
d_name	array
[	O
1	int
]	O
==	O
0	int
||	O
(	O
dp	pointer
->	O
d_name	array
[	O
1	int
]	O
==	O
'.'	O
&&	O
dp	pointer
->	O
d_name	array
[	O
2	int
]	O
==	O
0	int
)	O
)	O
continue	O
;	O
}	O
full_name	pointer
=	O
concat_dir_and_file	function
(	O
dir	pointer
,	O
dp	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
mc_lstat	function
(	O
full_name	pointer
,	O
&	O
buf	pointer
)	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
buf	pointer
.	O
st_mode	int
)	O
)	O
tree_store_mark_checked	function
(	O
dp	pointer
->	O
d_name	array
)	O
;	O
}	O
g_free	function
(	O
full_name	pointer
)	O
;	O
}	O
mc_closedir	function
(	O
dirp	pointer
)	O
;	O
}	O
tree_store_end_check	function
(	O
)	O
;	O
entry	pointer
->	O
scanned	int
=	O
1	int
;	O
return	O
entry	pointer
;	O
}	O
