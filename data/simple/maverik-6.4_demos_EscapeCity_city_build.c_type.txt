char	O
*	O
strdup	function
(	O
const	O
char	O
*	O
s1	pointer
)	O
;	O
int	O
vcb_main	function
(	O
int	O
num_seeds	int
,	O
int	O
num_cells	int
)	O
;	O
void	O
Init_Warp_Grid	function
(	O
void	O
)	O
;	O
MAV_vector	O
Calc_Grid_Position	function
(	O
float	O
u	float
,	O
float	O
v	float
)	O
;	O
void	O
Add_Composite	function
(	O
MAV_cityCell	struct
*	O
cell	pointer
,	O
int	O
index	function
,	O
MAV_matrix	O
*	O
matrix	int
)	O
;	O
void	O
Add_Feature	function
(	O
MAV_cityCell	struct
*	O
cell	pointer
,	O
int	O
index	function
,	O
MAV_matrix	O
*	O
matrix	int
)	O
;	O
extern	O
int	O
num_cells	int
;	O
extern	O
MAV_class	O
*	O
mav_class_citycell	pointer
;	O
extern	O
MAV_class	O
*	O
mav_class_occluder	pointer
;	O
extern	O
MAV_class	O
*	O
mav_class_billboard	pointer
;	O
extern	O
int	O
cells	array
[	O
RUN_LENGTH	int
]	O
[	O
4	int
]	O
;	O
extern	O
int	O
total_objects	int
;	O
MAV_list	O
*	O
list_of_objects	pointer
;	O
int	O
num_polys	int
=	O
0	int
;	O
int	O
size	int
;	O
float	O
road_width	float
;	O
Block	struct
*	O
city_scape	pointer
;	O
float	O
*	O
building_heights	pointer
;	O
int	O
num_billboards	int
=	O
0	int
;	O
MAV_cityCell	struct
*	O
bounce_cell	pointer
=	O
NULL	O
;	O
char	O
street_endings	array
[	O
]	O
[	O
3	int
]	O
=	O
{	O
"St."	pointer
,	O
"Av."	pointer
,	O
"Rd."	pointer
,	O
"Cl."	pointer
,	O
"Bl."	pointer
,	O
"Pl."	pointer
}	O
;	O
char	O
street_names	array
[	O
]	O
[	O
13	int
]	O
=	O
{	O
"Adrian"	pointer
,	O
"Alan"	pointer
,	O
"Applet"	pointer
,	O
"Blancmange"	pointer
,	O
"Crocodile"	pointer
,	O
"Condensation"	pointer
,	O
"Dan"	pointer
,	O
"Deva"	pointer
,	O
"Dodecahedron"	pointer
,	O
"Dogger"	pointer
,	O
"eSCAPE"	pointer
,	O
"Essential"	pointer
,	O
"Fisher"	pointer
,	O
"Fountain"	pointer
,	O
"Frog"	pointer
,	O
"Flange"	pointer
,	O
"James"	pointer
,	O
"Janet"	pointer
,	O
"Jon"	pointer
,	O
"Karlsruhe"	pointer
,	O
"Kettleofish"	pointer
,	O
"Martin"	pointer
,	O
"Maverik"	pointer
,	O
"Mel"	pointer
,	O
"Money"	pointer
,	O
"Nonetheless"	pointer
,	O
"Plethora"	pointer
,	O
"Plinth"	pointer
,	O
"Plum"	pointer
,	O
"Polygon"	pointer
,	O
"Roger"	pointer
,	O
"Scarborough"	pointer
,	O
"Simon"	pointer
,	O
"Steve"	pointer
,	O
"Suitcase"	pointer
,	O
"Telly"	pointer
,	O
"Tubby"	pointer
,	O
"Theodolite"	pointer
,	O
"Tim"	pointer
,	O
"Toby"	pointer
,	O
"1st"	pointer
,	O
"2nd"	pointer
,	O
"3rd"	pointer
,	O
"4th"	pointer
,	O
"5th"	pointer
,	O
"6th"	pointer
,	O
"7th"	pointer
,	O
"8th"	pointer
,	O
"9th"	pointer
,	O
"10th"	pointer
,	O
"11th"	pointer
,	O
"12th"	pointer
,	O
"13th"	pointer
,	O
"14th"	pointer
,	O
"15th"	pointer
,	O
"16th"	pointer
,	O
"17th"	pointer
,	O
"18th"	pointer
,	O
"19th"	pointer
,	O
"20th"	pointer
,	O
"21st"	pointer
,	O
"22nd"	pointer
,	O
"23rd"	pointer
,	O
"24th"	pointer
,	O
"25th"	pointer
,	O
"26th"	pointer
,	O
"27th"	pointer
,	O
"28th"	pointer
,	O
"29th"	pointer
,	O
"30th"	pointer
,	O
"31st"	pointer
,	O
"32nd"	pointer
,	O
"33rd"	pointer
,	O
"34th"	pointer
,	O
"35th"	pointer
,	O
"36th"	pointer
,	O
"37th"	pointer
,	O
"38th"	pointer
,	O
"39th"	pointer
,	O
"40th"	pointer
}	O
;	O
static	O
void	O
Add_Poly	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
int	O
num	char
,	O
int	O
material	int
,	O
int	O
texture	int
,	O
float	O
*	O
vx	pointer
,	O
float	O
*	O
vy	pointer
,	O
float	O
*	O
vz	pointer
,	O
float	O
*	O
tu	pointer
,	O
float	O
*	O
tv	pointer
)	O
{	O
int	O
i	int
;	O
Poly	struct
*	O
p	int
;	O
MAV_vector	O
r1	O
,	O
r2	O
;	O
if	O
(	O
num	char
>	O
4	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"Warning(): can't have polygon with > 4 vertices\n"	pointer
)	O
;	O
return	O
;	O
}	O
p	int
=	O
mav_malloc	function
(	O
sizeof	O
(	O
Poly	struct
)	O
)	O
;	O
p	int
->	O
next	pointer
=	O
c	pointer
->	O
polys	pointer
;	O
c	pointer
->	O
polys	pointer
=	O
p	int
;	O
c	pointer
->	O
num_polys	int
++	O
;	O
num_polys	int
++	O
;	O
p	int
->	O
num	char
=	O
(	O
unsigned	O
char	O
)	O
4	int
;	O
if	O
(	O
texture	int
==	O
-	O
1	int
)	O
p	int
->	O
sp	int
.	O
mode	O
=	O
MAV_MATERIAL	O
;	O
else	O
if	O
(	O
material	int
==	O
-	O
1	int
)	O
p	int
->	O
sp	int
.	O
mode	O
=	O
MAV_TEXTURE	O
;	O
else	O
p	int
->	O
sp	int
.	O
mode	O
=	O
MAV_LIT_TEXTURE	O
;	O
p	int
->	O
sp	int
.	O
material	int
=	O
material	int
;	O
p	int
->	O
sp	int
.	O
texture	int
=	O
texture	int
;	O
r1	O
.	O
x	array
=	O
vx	pointer
[	O
2	int
]	O
-	O
vx	pointer
[	O
1	int
]	O
;	O
r1	O
.	O
y	array
=	O
vy	pointer
[	O
2	int
]	O
-	O
vy	pointer
[	O
1	int
]	O
;	O
r1	O
.	O
z	array
=	O
vz	pointer
[	O
2	int
]	O
-	O
vz	pointer
[	O
1	int
]	O
;	O
r2	O
.	O
x	array
=	O
vx	pointer
[	O
0	int
]	O
-	O
vx	pointer
[	O
1	int
]	O
;	O
r2	O
.	O
y	array
=	O
vy	pointer
[	O
0	int
]	O
-	O
vy	pointer
[	O
1	int
]	O
;	O
r2	O
.	O
z	array
=	O
vz	pointer
[	O
0	int
]	O
-	O
vz	pointer
[	O
1	int
]	O
;	O
r1	O
=	O
mav_vectorNormalize	function
(	O
r1	O
)	O
;	O
r2	O
=	O
mav_vectorNormalize	function
(	O
r2	O
)	O
;	O
p	int
->	O
normal	int
=	O
mav_vectorCrossProduct	function
(	O
r1	O
,	O
r2	O
)	O
;	O
p	int
->	O
normal	int
=	O
mav_vectorNormalize	function
(	O
p	int
->	O
normal	int
)	O
;	O
p	int
->	O
normal	int
.	O
x	array
=	O
-	O
p	int
->	O
normal	int
.	O
x	array
;	O
p	int
->	O
normal	int
.	O
y	array
=	O
-	O
p	int
->	O
normal	int
.	O
y	array
;	O
p	int
->	O
normal	int
.	O
z	array
=	O
-	O
p	int
->	O
normal	int
.	O
z	array
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	char
;	O
i	int
++	O
)	O
{	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
x	array
=	O
vx	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
y	array
=	O
vy	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
z	array
=	O
vz	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
if	O
(	O
texture	int
!=	O
-	O
1	int
)	O
{	O
p	int
->	O
texcoords	array
[	O
i	int
]	O
.	O
s	pointer
=	O
tu	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
p	int
->	O
texcoords	array
[	O
i	int
]	O
.	O
t	O
=	O
tv	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
}	O
}	O
if	O
(	O
num	char
==	O
3	int
)	O
{	O
p	int
->	O
verts	array
[	O
3	int
]	O
.	O
x	array
=	O
vx	pointer
[	O
0	int
]	O
;	O
p	int
->	O
verts	array
[	O
3	int
]	O
.	O
y	array
=	O
vy	pointer
[	O
0	int
]	O
;	O
p	int
->	O
verts	array
[	O
3	int
]	O
.	O
z	array
=	O
vz	pointer
[	O
0	int
]	O
;	O
if	O
(	O
texture	int
!=	O
-	O
1	int
)	O
{	O
p	int
->	O
texcoords	array
[	O
3	int
]	O
.	O
s	pointer
=	O
tu	pointer
[	O
0	int
]	O
;	O
p	int
->	O
texcoords	array
[	O
3	int
]	O
.	O
t	O
=	O
tv	pointer
[	O
0	int
]	O
;	O
}	O
}	O
}	O
static	O
void	O
Add_Lod_Poly	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
int	O
num	char
,	O
int	O
material	int
,	O
int	O
texture	int
,	O
float	O
*	O
vx	pointer
,	O
float	O
*	O
vy	pointer
,	O
float	O
*	O
vz	pointer
,	O
float	O
*	O
tu	pointer
,	O
float	O
*	O
tv	pointer
)	O
{	O
int	O
i	int
;	O
Poly	struct
*	O
p	int
;	O
MAV_vector	O
r1	O
,	O
r2	O
;	O
if	O
(	O
num	char
>	O
4	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"Warning(): can't have polygon with > 4 vertices\n"	pointer
)	O
;	O
return	O
;	O
}	O
p	int
=	O
mav_malloc	function
(	O
sizeof	O
(	O
Poly	struct
)	O
)	O
;	O
p	int
->	O
next	pointer
=	O
c	pointer
->	O
lod_polys	pointer
;	O
c	pointer
->	O
lod_polys	pointer
=	O
p	int
;	O
c	pointer
->	O
num_lod_polys	int
++	O
;	O
p	int
->	O
num	char
=	O
(	O
unsigned	O
char	O
)	O
4	int
;	O
if	O
(	O
texture	int
==	O
-	O
1	int
)	O
p	int
->	O
sp	int
.	O
mode	O
=	O
MAV_MATERIAL	O
;	O
else	O
if	O
(	O
material	int
==	O
-	O
1	int
)	O
p	int
->	O
sp	int
.	O
mode	O
=	O
MAV_TEXTURE	O
;	O
else	O
p	int
->	O
sp	int
.	O
mode	O
=	O
MAV_LIT_TEXTURE	O
;	O
p	int
->	O
sp	int
.	O
material	int
=	O
material	int
;	O
p	int
->	O
sp	int
.	O
texture	int
=	O
texture	int
;	O
r1	O
.	O
x	array
=	O
vx	pointer
[	O
2	int
]	O
-	O
vx	pointer
[	O
1	int
]	O
;	O
r1	O
.	O
y	array
=	O
vy	pointer
[	O
2	int
]	O
-	O
vy	pointer
[	O
1	int
]	O
;	O
r1	O
.	O
z	array
=	O
vz	pointer
[	O
2	int
]	O
-	O
vz	pointer
[	O
1	int
]	O
;	O
r2	O
.	O
x	array
=	O
vx	pointer
[	O
0	int
]	O
-	O
vx	pointer
[	O
1	int
]	O
;	O
r2	O
.	O
y	array
=	O
vy	pointer
[	O
0	int
]	O
-	O
vy	pointer
[	O
1	int
]	O
;	O
r2	O
.	O
z	array
=	O
vz	pointer
[	O
0	int
]	O
-	O
vz	pointer
[	O
1	int
]	O
;	O
r1	O
=	O
mav_vectorNormalize	function
(	O
r1	O
)	O
;	O
r2	O
=	O
mav_vectorNormalize	function
(	O
r2	O
)	O
;	O
p	int
->	O
normal	int
=	O
mav_vectorCrossProduct	function
(	O
r1	O
,	O
r2	O
)	O
;	O
p	int
->	O
normal	int
=	O
mav_vectorNormalize	function
(	O
p	int
->	O
normal	int
)	O
;	O
p	int
->	O
normal	int
.	O
x	array
=	O
-	O
p	int
->	O
normal	int
.	O
x	array
;	O
p	int
->	O
normal	int
.	O
y	array
=	O
-	O
p	int
->	O
normal	int
.	O
y	array
;	O
p	int
->	O
normal	int
.	O
z	array
=	O
-	O
p	int
->	O
normal	int
.	O
z	array
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	char
;	O
i	int
++	O
)	O
{	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
x	array
=	O
vx	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
y	array
=	O
vy	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
z	array
=	O
vz	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
if	O
(	O
texture	int
!=	O
-	O
1	int
)	O
{	O
p	int
->	O
texcoords	array
[	O
i	int
]	O
.	O
s	pointer
=	O
tu	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
p	int
->	O
texcoords	array
[	O
i	int
]	O
.	O
t	O
=	O
tv	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
}	O
}	O
if	O
(	O
num	char
==	O
3	int
)	O
{	O
p	int
->	O
verts	array
[	O
3	int
]	O
.	O
x	array
=	O
vx	pointer
[	O
0	int
]	O
;	O
p	int
->	O
verts	array
[	O
3	int
]	O
.	O
y	array
=	O
vy	pointer
[	O
0	int
]	O
;	O
p	int
->	O
verts	array
[	O
3	int
]	O
.	O
z	array
=	O
vz	pointer
[	O
0	int
]	O
;	O
if	O
(	O
texture	int
!=	O
-	O
1	int
)	O
{	O
p	int
->	O
texcoords	array
[	O
3	int
]	O
.	O
s	pointer
=	O
tu	pointer
[	O
0	int
]	O
;	O
p	int
->	O
texcoords	array
[	O
3	int
]	O
.	O
t	O
=	O
tv	pointer
[	O
0	int
]	O
;	O
}	O
}	O
}	O
static	O
void	O
Add_Relative_Poly	function
(	O
float	O
sx	float
,	O
float	O
sy	float
,	O
float	O
sz	float
,	O
MAV_cityCell	struct
*	O
c	pointer
,	O
int	O
num	char
,	O
int	O
material	int
,	O
int	O
texture	int
,	O
float	O
*	O
vx	pointer
,	O
float	O
*	O
vy	pointer
,	O
float	O
*	O
vz	pointer
,	O
float	O
*	O
tu	pointer
,	O
float	O
*	O
tv	pointer
)	O
{	O
int	O
i	int
;	O
Poly	struct
*	O
p	int
;	O
MAV_vector	O
r1	O
,	O
r2	O
;	O
if	O
(	O
num	char
>	O
4	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"Warning(): can't have polygon with > 4 vertices\n"	pointer
)	O
;	O
return	O
;	O
}	O
p	int
=	O
mav_malloc	function
(	O
sizeof	O
(	O
Poly	struct
)	O
)	O
;	O
p	int
->	O
next	pointer
=	O
c	pointer
->	O
polys	pointer
;	O
c	pointer
->	O
polys	pointer
=	O
p	int
;	O
c	pointer
->	O
num_polys	int
++	O
;	O
num_polys	int
++	O
;	O
p	int
->	O
num	char
=	O
(	O
unsigned	O
char	O
)	O
num	char
;	O
if	O
(	O
texture	int
==	O
-	O
1	int
)	O
p	int
->	O
sp	int
.	O
mode	O
=	O
MAV_MATERIAL	O
;	O
else	O
if	O
(	O
material	int
==	O
-	O
1	int
)	O
p	int
->	O
sp	int
.	O
mode	O
=	O
MAV_TEXTURE	O
;	O
else	O
p	int
->	O
sp	int
.	O
mode	O
=	O
MAV_LIT_TEXTURE	O
;	O
p	int
->	O
sp	int
.	O
material	int
=	O
material	int
;	O
p	int
->	O
sp	int
.	O
texture	int
=	O
texture	int
;	O
r1	O
.	O
x	array
=	O
vx	pointer
[	O
2	int
]	O
-	O
vx	pointer
[	O
1	int
]	O
;	O
r1	O
.	O
y	array
=	O
vy	pointer
[	O
2	int
]	O
-	O
vy	pointer
[	O
1	int
]	O
;	O
r1	O
.	O
z	array
=	O
vz	pointer
[	O
2	int
]	O
-	O
vz	pointer
[	O
1	int
]	O
;	O
r2	O
.	O
x	array
=	O
vx	pointer
[	O
0	int
]	O
-	O
vx	pointer
[	O
1	int
]	O
;	O
r2	O
.	O
y	array
=	O
vy	pointer
[	O
0	int
]	O
-	O
vy	pointer
[	O
1	int
]	O
;	O
r2	O
.	O
z	array
=	O
vz	pointer
[	O
0	int
]	O
-	O
vz	pointer
[	O
1	int
]	O
;	O
r1	O
=	O
mav_vectorNormalize	function
(	O
r1	O
)	O
;	O
r2	O
=	O
mav_vectorNormalize	function
(	O
r2	O
)	O
;	O
p	int
->	O
normal	int
=	O
mav_vectorCrossProduct	function
(	O
r1	O
,	O
r2	O
)	O
;	O
p	int
->	O
normal	int
=	O
mav_vectorNormalize	function
(	O
p	int
->	O
normal	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	char
;	O
i	int
++	O
)	O
{	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
x	array
=	O
sx	float
+	O
vx	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
y	array
=	O
sy	float
+	O
vy	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
z	array
=	O
sz	float
+	O
vz	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
if	O
(	O
texture	int
!=	O
-	O
1	int
)	O
{	O
p	int
->	O
texcoords	array
[	O
i	int
]	O
.	O
s	pointer
=	O
tu	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
p	int
->	O
texcoords	array
[	O
i	int
]	O
.	O
t	O
=	O
tv	pointer
[	O
num	char
-	O
1	int
-	O
i	int
]	O
;	O
}	O
}	O
if	O
(	O
num	char
==	O
3	int
)	O
{	O
p	int
->	O
verts	array
[	O
3	int
]	O
.	O
x	array
=	O
sx	float
+	O
vx	pointer
[	O
0	int
]	O
;	O
p	int
->	O
verts	array
[	O
3	int
]	O
.	O
y	array
=	O
sx	float
+	O
vy	pointer
[	O
0	int
]	O
;	O
p	int
->	O
verts	array
[	O
3	int
]	O
.	O
z	array
=	O
sx	float
+	O
vz	pointer
[	O
0	int
]	O
;	O
if	O
(	O
texture	int
!=	O
-	O
1	int
)	O
{	O
p	int
->	O
texcoords	array
[	O
3	int
]	O
.	O
s	pointer
=	O
tu	pointer
[	O
0	int
]	O
;	O
p	int
->	O
texcoords	array
[	O
3	int
]	O
.	O
t	O
=	O
tv	pointer
[	O
0	int
]	O
;	O
}	O
}	O
}	O
static	O
void	O
Add_Billboard	function
(	O
int	O
texture	int
,	O
float	O
px	float
,	O
float	O
py	float
,	O
float	O
pz	float
,	O
float	O
width	float
,	O
float	O
height	float
,	O
float	O
rotx	float
,	O
float	O
roty	float
,	O
float	O
rotz	float
)	O
{	O
MAV_billboard	struct
*	O
bb	int
;	O
if	O
(	O
num_billboards	int
>=	O
MAX_BILLBOARDS	int
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"Add_Billboard(): maximum number of billboards exceeded (%d)\n"	pointer
,	O
num_billboards	int
)	O
;	O
return	O
;	O
}	O
bb	int
=	O
mav_malloc	function
(	O
sizeof	O
(	O
MAV_billboard	struct
)	O
)	O
;	O
num_billboards	int
++	O
;	O
num_polys	int
++	O
;	O
bb	int
->	O
sp	int
.	O
mode	O
=	O
MAV_TEXTURE	O
;	O
bb	int
->	O
sp	int
.	O
texture	int
=	O
texture	int
;	O
bb	int
->	O
width	float
=	O
width	float
;	O
bb	int
->	O
height	float
=	O
height	float
;	O
bb	int
->	O
rot	int
.	O
x	array
=	O
rotx	float
;	O
bb	int
->	O
rot	int
.	O
y	array
=	O
roty	float
;	O
bb	int
->	O
rot	int
.	O
z	array
=	O
rotz	float
;	O
bb	int
->	O
bb	int
.	O
min	O
.	O
x	array
=	O
-	O
width	float
/	O
2.0	int
;	O
bb	int
->	O
bb	int
.	O
min	O
.	O
y	array
=	O
0.0	int
;	O
bb	int
->	O
bb	int
.	O
min	O
.	O
z	array
=	O
-	O
width	float
/	O
2.0	int
;	O
bb	int
->	O
bb	int
.	O
max	O
.	O
x	array
=	O
width	float
/	O
2.0	int
;	O
bb	int
->	O
bb	int
.	O
max	O
.	O
y	array
=	O
height	float
;	O
bb	int
->	O
bb	int
.	O
max	O
.	O
z	array
=	O
width	float
/	O
2.0	int
;	O
bb	int
->	O
matrix	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
px	float
,	O
py	float
,	O
pz	float
)	O
;	O
mav_listItemAdd	function
(	O
list_of_objects	pointer
,	O
(	O
void	O
*	O
)	O
mav_objectNew	function
(	O
mav_class_billboard	pointer
,	O
bb	int
)	O
)	O
;	O
total_objects	int
++	O
;	O
}	O
static	O
void	O
Add_Pavement	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
,	O
int	O
type	int
)	O
{	O
float	O
x	array
[	O
4	int
]	O
,	O
y	array
[	O
4	int
]	O
,	O
z	array
[	O
4	int
]	O
;	O
float	O
tu	pointer
[	O
4	int
]	O
,	O
tv	pointer
[	O
4	int
]	O
;	O
if	O
(	O
type	int
&	O
1	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
c	pointer
->	O
nw	int
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
c	pointer
->	O
nw	int
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
if	O
(	O
type	int
&	O
2	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
if	O
(	O
type	int
&	O
4	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
c	pointer
->	O
ne	int
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
c	pointer
->	O
ne	int
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
if	O
(	O
type	int
&	O
8	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
if	O
(	O
type	int
&	O
16	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
c	pointer
->	O
se	int
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
c	pointer
->	O
se	int
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
if	O
(	O
type	int
&	O
32	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
if	O
(	O
type	int
&	O
64	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
c	pointer
->	O
sw	int
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
c	pointer
->	O
sw	int
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
if	O
(	O
type	int
&	O
128	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
0.0	int
;	O
z	array
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
0.0	int
;	O
z	array
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
}	O
static	O
void	O
Add_Relative_Box	function
(	O
float	O
sx	float
,	O
float	O
sy	float
,	O
float	O
sz	float
,	O
MAV_cityCell	struct
*	O
c	pointer
,	O
int	O
material	int
,	O
int	O
texture	int
,	O
float	O
blx	float
,	O
float	O
bly	float
,	O
float	O
blz	float
,	O
float	O
trx	float
,	O
float	O
try	float
,	O
float	O
trz	float
,	O
float	O
scale	float
)	O
{	O
float	O
x	array
[	O
4	int
]	O
,	O
y	array
[	O
4	int
]	O
,	O
z	array
[	O
4	int
]	O
;	O
float	O
tu	pointer
[	O
4	int
]	O
,	O
tv	pointer
[	O
4	int
]	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
blz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
y	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
y	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
y	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
y	array
[	O
3	int
]	O
;	O
}	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
blz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
z	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
y	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
z	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
y	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
z	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
y	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
z	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
y	array
[	O
3	int
]	O
;	O
}	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
0	int
]	O
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
y	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
1	int
]	O
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
y	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
2	int
]	O
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
y	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
3	int
]	O
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
y	array
[	O
3	int
]	O
;	O
}	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
(	O
-	O
z	array
[	O
0	int
]	O
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
y	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
(	O
-	O
z	array
[	O
1	int
]	O
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
y	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
(	O
-	O
z	array
[	O
2	int
]	O
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
y	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
(	O
-	O
z	array
[	O
3	int
]	O
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
y	array
[	O
3	int
]	O
;	O
}	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
z	array
[	O
3	int
]	O
;	O
}	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
blz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
0	int
]	O
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
1	int
]	O
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
2	int
]	O
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
3	int
]	O
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
z	array
[	O
3	int
]	O
;	O
}	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
static	O
void	O
Add_Relative_Lod_Box	function
(	O
float	O
sx	float
,	O
float	O
sy	float
,	O
float	O
sz	float
,	O
MAV_cityCell	struct
*	O
c	pointer
,	O
int	O
material	int
,	O
int	O
texture	int
,	O
float	O
blx	float
,	O
float	O
bly	float
,	O
float	O
blz	float
,	O
float	O
trx	float
,	O
float	O
try	float
,	O
float	O
trz	float
,	O
float	O
scale	float
)	O
{	O
float	O
x	array
[	O
4	int
]	O
,	O
y	array
[	O
4	int
]	O
,	O
z	array
[	O
4	int
]	O
;	O
float	O
tu	pointer
[	O
4	int
]	O
,	O
tv	pointer
[	O
4	int
]	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
blz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
y	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
y	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
y	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
y	array
[	O
3	int
]	O
;	O
}	O
Add_Lod_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
blz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
z	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
y	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
z	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
y	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
z	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
y	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
z	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
y	array
[	O
3	int
]	O
;	O
}	O
Add_Lod_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
0	int
]	O
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
y	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
1	int
]	O
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
y	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
2	int
]	O
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
y	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
3	int
]	O
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
y	array
[	O
3	int
]	O
;	O
}	O
Add_Lod_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
(	O
-	O
z	array
[	O
0	int
]	O
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
y	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
(	O
-	O
z	array
[	O
1	int
]	O
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
y	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
(	O
-	O
z	array
[	O
2	int
]	O
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
y	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
(	O
-	O
z	array
[	O
3	int
]	O
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
y	array
[	O
3	int
]	O
;	O
}	O
Add_Lod_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
try	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
z	array
[	O
3	int
]	O
;	O
}	O
Add_Lod_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
bly	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
blz	float
;	O
if	O
(	O
texture	int
>	O
-	O
1	int
)	O
{	O
tu	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
0	int
]	O
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
1	int
]	O
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
2	int
]	O
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
(	O
-	O
x	array
[	O
3	int
]	O
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
z	array
[	O
3	int
]	O
;	O
}	O
Add_Lod_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
static	O
void	O
Map_Coords	function
(	O
MAV_vector	O
cent	int
,	O
MAV_vector	O
dru	int
,	O
MAV_vector	O
drv	int
,	O
float	O
u	float
,	O
float	O
v	float
,	O
float	O
*	O
vx	pointer
,	O
float	O
*	O
vy	pointer
,	O
float	O
*	O
vz	pointer
)	O
{	O
*	O
vx	pointer
=	O
cent	int
.	O
x	array
+	O
dru	int
.	O
x	array
*	O
u	float
+	O
drv	int
.	O
x	array
*	O
v	float
;	O
*	O
vy	pointer
=	O
DELTA_HEIGHT	int
;	O
*	O
vz	pointer
=	O
cent	int
.	O
z	array
+	O
dru	int
.	O
z	array
*	O
u	float
+	O
drv	int
.	O
z	array
*	O
v	float
;	O
}	O
static	O
void	O
Add_Horizontal_Crossing	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
float	O
len	float
;	O
MAV_vector	O
c0	O
,	O
c1	O
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
u	float
;	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
pos	int
[	O
6	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
x	array
+	O
pos	int
[	O
7	int
]	O
.	O
x	array
)	O
;	O
cent	int
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
y	array
+	O
pos	int
[	O
7	int
]	O
.	O
y	array
)	O
;	O
cent	int
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
z	array
+	O
pos	int
[	O
7	int
]	O
.	O
z	array
)	O
;	O
len	float
=	O
2.0	int
*	O
road_width	float
/	O
10.0	int
;	O
u	float
=	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
10	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
0.5	int
*	O
PAVE_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
0.5	int
*	O
PAVE_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
-	O
0.5	int
*	O
PAVE_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
-	O
0.5	int
*	O
PAVE_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
u	float
+=	O
len	float
;	O
}	O
}	O
static	O
void	O
Add_Vertical_Crossing	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
float	O
len	float
;	O
MAV_vector	O
c0	O
,	O
c1	O
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
v	float
;	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
pos	int
[	O
5	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
x	array
+	O
pos	int
[	O
4	int
]	O
.	O
x	array
)	O
;	O
cent	int
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
y	array
+	O
pos	int
[	O
4	int
]	O
.	O
y	array
)	O
;	O
cent	int
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
z	array
+	O
pos	int
[	O
4	int
]	O
.	O
z	array
)	O
;	O
len	float
=	O
2.0	int
*	O
road_width	float
/	O
10.0	int
;	O
v	float
=	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
10	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
PAVE_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
PAVE_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
PAVE_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
PAVE_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
v	float
+=	O
len	float
;	O
}	O
}	O
static	O
void	O
Add_Vertical_Marks	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
float	O
len	float
;	O
MAV_vector	O
c0	O
,	O
c1	O
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
v	float
;	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
pos	int
[	O
5	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
v	float
=	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
v	float
+=	O
len	float
;	O
}	O
}	O
static	O
void	O
Add_Horizontal_Marks	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
float	O
len	float
;	O
MAV_vector	O
c0	O
,	O
c1	O
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
u	float
;	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
pos	int
[	O
6	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
u	float
=	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
u	float
+=	O
len	float
;	O
}	O
}	O
static	O
void	O
Add_Vertical_CMarks	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
float	O
len	float
;	O
MAV_vector	O
c0	O
,	O
c1	O
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
v	float
;	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
pos	int
[	O
5	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
v	float
=	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
0	int
||	O
i	int
==	O
3	int
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
v	float
+=	O
len	float
;	O
}	O
}	O
static	O
void	O
Add_Horizontal_CMarks	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
float	O
len	float
;	O
MAV_vector	O
c0	O
,	O
c1	O
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
u	float
;	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
pos	int
[	O
6	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
u	float
=	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
0	int
||	O
i	int
==	O
3	int
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
u	float
+=	O
len	float
;	O
}	O
}	O
static	O
void	O
Add_West_North_Marks	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
float	O
len	float
;	O
MAV_vector	O
c0	O
,	O
c1	O
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
u	float
,	O
v	float
;	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
pos	int
[	O
5	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
v	float
=	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
v	float
+=	O
len	float
;	O
}	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
pos	int
[	O
6	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
u	float
=	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
u	float
+=	O
len	float
;	O
}	O
}	O
static	O
void	O
Add_East_North_Marks	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
float	O
len	float
;	O
MAV_vector	O
c0	O
,	O
c1	O
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
u	float
,	O
v	float
;	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
pos	int
[	O
5	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
v	float
=	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
v	float
+=	O
len	float
;	O
}	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
pos	int
[	O
6	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
u	float
=	O
2.0	int
*	O
len	float
+	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
u	float
+=	O
len	float
;	O
}	O
}	O
static	O
void	O
Add_West_South_Marks	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
float	O
len	float
;	O
MAV_vector	O
c0	O
,	O
c1	O
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
u	float
,	O
v	float
;	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
pos	int
[	O
5	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
v	float
=	O
2.0	int
*	O
len	float
+	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
v	float
+=	O
len	float
;	O
}	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
pos	int
[	O
6	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
u	float
=	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
u	float
+=	O
len	float
;	O
}	O
}	O
static	O
void	O
Add_East_South_Marks	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
float	O
len	float
;	O
MAV_vector	O
c0	O
,	O
c1	O
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
u	float
,	O
v	float
;	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
pos	int
[	O
5	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
v	float
=	O
2.0	int
*	O
len	float
+	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
+	O
len	float
/	O
2.0	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
v	float
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
v	float
+=	O
len	float
;	O
}	O
c0	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
;	O
c0	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
;	O
c0	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
;	O
c1	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
c1	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
c1	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
dru	int
.	O
x	array
=	O
c1	O
.	O
x	array
-	O
c0	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
c1	O
.	O
y	array
-	O
c0	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
c1	O
.	O
z	array
-	O
c0	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
-	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
drv	int
.	O
y	array
=	O
pos	int
[	O
6	int
]	O
.	O
y	array
-	O
pos	int
[	O
2	int
]	O
.	O
y	array
;	O
drv	int
.	O
z	array
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
-	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
=	O
c0	O
;	O
len	float
=	O
sqrt	function
(	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
*	O
(	O
c0	O
.	O
x	array
-	O
c1	O
.	O
x	array
)	O
+	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
*	O
(	O
c0	O
.	O
y	array
-	O
c1	O
.	O
y	array
)	O
+	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
*	O
(	O
c0	O
.	O
z	array
-	O
c1	O
.	O
z	array
)	O
)	O
/	O
4.0	int
;	O
u	float
=	O
2.0	int
*	O
len	float
+	O
len	float
/	O
4.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
len	float
/	O
2.0	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
u	float
+=	O
len	float
;	O
}	O
}	O
static	O
void	O
Add_South_Junction	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
,	O
int	O
lgt	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
MAV_matrix	O
transform	O
,	O
shift	O
;	O
float	O
len	float
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
u	float
;	O
float	O
angle	float
;	O
dru	int
.	O
x	array
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
-	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
pos	int
[	O
10	int
]	O
.	O
y	array
-	O
pos	int
[	O
6	int
]	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
-	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
drv	int
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
drv	int
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
9	int
]	O
.	O
x	array
+	O
pos	int
[	O
7	int
]	O
.	O
x	array
)	O
;	O
cent	int
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
9	int
]	O
.	O
y	array
+	O
pos	int
[	O
7	int
]	O
.	O
y	array
)	O
;	O
cent	int
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
9	int
]	O
.	O
z	array
+	O
pos	int
[	O
7	int
]	O
.	O
z	array
)	O
;	O
len	float
=	O
road_width	float
/	O
3.0	int
;	O
u	float
=	O
0.5	int
*	O
MARK_WIDTH	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
3	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
3.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
4.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
4.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
3.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
u	float
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
u	float
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
(	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
)	O
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
(	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
)	O
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
u	float
+=	O
len	float
;	O
}	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
MARK_LENGTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
MARK_LENGTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
lgt	int
||	O
mav_random	function
(	O
)	O
<	O
0.5	int
)	O
{	O
angle	float
=	O
180.0	int
/	O
MAV_PI	O
*	O
acos	function
(	O
dru	int
.	O
x	array
)	O
;	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
angle	float
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
shift	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
pos	int
[	O
9	int
]	O
.	O
x	array
+	O
0.5	int
,	O
0.0	int
,	O
pos	int
[	O
9	int
]	O
.	O
z	array
-	O
0.5	int
)	O
;	O
transform	O
=	O
mav_matrixMult	function
(	O
shift	O
,	O
transform	O
)	O
;	O
Add_Composite	function
(	O
c	pointer
,	O
COMP_TRAFFICLIGHT	int
,	O
&	O
transform	O
)	O
;	O
}	O
}	O
static	O
void	O
Add_North_Junction	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
,	O
int	O
lgt	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
MAV_matrix	O
transform	O
,	O
shift	O
;	O
float	O
len	float
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
u	float
;	O
float	O
angle	float
;	O
dru	int
.	O
x	array
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
-	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
pos	int
[	O
2	int
]	O
.	O
y	array
-	O
pos	int
[	O
5	int
]	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
-	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
drv	int
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
drv	int
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
x	array
+	O
pos	int
[	O
4	int
]	O
.	O
x	array
)	O
;	O
cent	int
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
y	array
+	O
pos	int
[	O
4	int
]	O
.	O
y	array
)	O
;	O
cent	int
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
z	array
+	O
pos	int
[	O
4	int
]	O
.	O
z	array
)	O
;	O
len	float
=	O
road_width	float
/	O
3.0	int
;	O
u	float
=	O
0.5	int
*	O
MARK_WIDTH	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
3	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
3.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
4.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
4.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
3.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
u	float
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
u	float
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
(	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
)	O
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
(	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
)	O
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
u	float
+=	O
len	float
;	O
}	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
MARK_LENGTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
MARK_LENGTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
lgt	int
||	O
mav_random	function
(	O
)	O
<	O
0.5	int
)	O
{	O
angle	float
=	O
180.0	int
/	O
MAV_PI	O
*	O
acos	function
(	O
dru	int
.	O
x	array
)	O
;	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
angle	float
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
shift	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
pos	int
[	O
1	int
]	O
.	O
x	array
-	O
0.5	int
,	O
0.0	int
,	O
pos	int
[	O
1	int
]	O
.	O
z	array
+	O
0.5	int
)	O
;	O
transform	O
=	O
mav_matrixMult	function
(	O
shift	O
,	O
transform	O
)	O
;	O
Add_Composite	function
(	O
c	pointer
,	O
COMP_TRAFFICLIGHT	int
,	O
&	O
transform	O
)	O
;	O
}	O
}	O
static	O
void	O
Add_West_Junction	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
,	O
int	O
lgt	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
MAV_matrix	O
transform	O
,	O
shift	O
;	O
float	O
len	float
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
u	float
;	O
float	O
angle	float
;	O
dru	int
.	O
x	array
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
-	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
pos	int
[	O
8	int
]	O
.	O
y	array
-	O
pos	int
[	O
0	int
]	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
-	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
drv	int
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
drv	int
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
x	array
+	O
pos	int
[	O
7	int
]	O
.	O
x	array
)	O
;	O
cent	int
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
y	array
+	O
pos	int
[	O
7	int
]	O
.	O
y	array
)	O
;	O
cent	int
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
1	int
]	O
.	O
z	array
+	O
pos	int
[	O
7	int
]	O
.	O
z	array
)	O
;	O
len	float
=	O
road_width	float
/	O
3.0	int
;	O
u	float
=	O
0.5	int
*	O
MARK_WIDTH	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
3	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
3.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
4.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
4.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
3.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
u	float
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
u	float
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
(	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
)	O
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
(	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
)	O
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
u	float
+=	O
len	float
;	O
}	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
MARK_LENGTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
MARK_LENGTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
lgt	int
||	O
mav_random	function
(	O
)	O
<	O
0.5	int
)	O
{	O
angle	float
=	O
180.0	int
/	O
MAV_PI	O
*	O
acos	function
(	O
dru	int
.	O
x	array
)	O
;	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
-	O
angle	float
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
shift	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
pos	int
[	O
7	int
]	O
.	O
x	array
-	O
0.5	int
,	O
0.0	int
,	O
pos	int
[	O
7	int
]	O
.	O
z	array
-	O
0.5	int
)	O
;	O
transform	O
=	O
mav_matrixMult	function
(	O
shift	O
,	O
transform	O
)	O
;	O
Add_Composite	function
(	O
c	pointer
,	O
COMP_TRAFFICLIGHT	int
,	O
&	O
transform	O
)	O
;	O
}	O
}	O
static	O
void	O
Add_East_Junction	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
,	O
int	O
lgt	int
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
int	O
i	int
;	O
MAV_matrix	O
transform	O
,	O
shift	O
;	O
float	O
len	float
;	O
MAV_vector	O
dru	int
,	O
drv	int
;	O
MAV_vector	O
cent	int
;	O
float	O
u	float
;	O
float	O
angle	float
;	O
dru	int
.	O
x	array
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
-	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
dru	int
.	O
y	array
=	O
pos	int
[	O
3	int
]	O
.	O
y	array
-	O
pos	int
[	O
11	int
]	O
.	O
y	array
;	O
dru	int
.	O
z	array
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
-	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
dru	int
=	O
mav_vectorNormalize	function
(	O
dru	int
)	O
;	O
drv	int
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
;	O
drv	int
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
;	O
drv	int
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
cent	int
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
4	int
]	O
.	O
x	array
+	O
pos	int
[	O
9	int
]	O
.	O
x	array
)	O
;	O
cent	int
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
4	int
]	O
.	O
y	array
+	O
pos	int
[	O
9	int
]	O
.	O
y	array
)	O
;	O
cent	int
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
4	int
]	O
.	O
z	array
+	O
pos	int
[	O
9	int
]	O
.	O
z	array
)	O
;	O
len	float
=	O
road_width	float
/	O
3.0	int
;	O
u	float
=	O
0.5	int
*	O
MARK_WIDTH	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
3	int
;	O
i	int
++	O
)	O
{	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
3.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
,	O
4.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
4.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
,	O
3.0	int
*	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
u	float
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
u	float
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
(	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
)	O
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
(	O
u	float
+	O
2.0	int
*	O
len	float
/	O
3.0	int
)	O
,	O
JUNC_WIDTH	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
u	float
+=	O
len	float
;	O
}	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
0	int
]	O
,	O
&	O
vy	pointer
[	O
0	int
]	O
,	O
&	O
vz	pointer
[	O
0	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
-	O
0.5	int
*	O
MARK_WIDTH	int
,	O
MARK_LENGTH	int
,	O
&	O
vx	pointer
[	O
1	int
]	O
,	O
&	O
vy	pointer
[	O
1	int
]	O
,	O
&	O
vz	pointer
[	O
1	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
MARK_LENGTH	int
,	O
&	O
vx	pointer
[	O
2	int
]	O
,	O
&	O
vy	pointer
[	O
2	int
]	O
,	O
&	O
vz	pointer
[	O
2	int
]	O
)	O
;	O
Map_Coords	function
(	O
cent	int
,	O
dru	int
,	O
drv	int
,	O
0.5	int
*	O
MARK_WIDTH	int
,	O
0.0	int
,	O
&	O
vx	pointer
[	O
3	int
]	O
,	O
&	O
vy	pointer
[	O
3	int
]	O
,	O
&	O
vz	pointer
[	O
3	int
]	O
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_MARK	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
lgt	int
||	O
mav_random	function
(	O
)	O
<	O
0.5	int
)	O
{	O
angle	float
=	O
180.0	int
/	O
MAV_PI	O
*	O
acos	function
(	O
dru	int
.	O
x	array
)	O
;	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
angle	float
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
shift	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
pos	int
[	O
4	int
]	O
.	O
x	array
+	O
0.5	int
,	O
0.0	int
,	O
pos	int
[	O
4	int
]	O
.	O
z	array
+	O
0.5	int
)	O
;	O
transform	O
=	O
mav_matrixMult	function
(	O
shift	O
,	O
transform	O
)	O
;	O
Add_Composite	function
(	O
c	pointer
,	O
COMP_TRAFFICLIGHT	int
,	O
&	O
transform	O
)	O
;	O
}	O
}	O
static	O
void	O
Add_Top_Lights	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
MAV_matrix	O
transform	O
,	O
shift	O
;	O
MAV_vector	O
cent	int
,	O
drv	int
;	O
float	O
angle	float
;	O
cent	int
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
2	int
]	O
.	O
x	array
+	O
pos	int
[	O
5	int
]	O
.	O
x	array
)	O
;	O
cent	int
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
2	int
]	O
.	O
y	array
+	O
pos	int
[	O
5	int
]	O
.	O
y	array
)	O
;	O
cent	int
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
2	int
]	O
.	O
z	array
+	O
pos	int
[	O
5	int
]	O
.	O
z	array
)	O
;	O
drv	int
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
drv	int
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
drv	int
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
angle	float
=	O
180.0	int
/	O
MAV_PI	O
*	O
acos	function
(	O
drv	int
.	O
x	array
)	O
;	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
angle	float
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
shift	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
cent	int
.	O
z	array
)	O
;	O
transform	O
=	O
mav_matrixMult	function
(	O
shift	O
,	O
transform	O
)	O
;	O
Add_Composite	function
(	O
c	pointer
,	O
COMP_STREETLIGHT	int
,	O
&	O
transform	O
)	O
;	O
}	O
static	O
void	O
Add_Bottom_Lights	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
MAV_matrix	O
transform	O
,	O
shift	O
;	O
MAV_vector	O
cent	int
,	O
drv	int
;	O
float	O
angle	float
;	O
cent	int
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
10	int
]	O
.	O
x	array
+	O
pos	int
[	O
6	int
]	O
.	O
x	array
)	O
;	O
cent	int
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
10	int
]	O
.	O
y	array
+	O
pos	int
[	O
6	int
]	O
.	O
y	array
)	O
;	O
cent	int
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
10	int
]	O
.	O
z	array
+	O
pos	int
[	O
6	int
]	O
.	O
z	array
)	O
;	O
drv	int
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
drv	int
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
drv	int
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
angle	float
=	O
180.0	int
/	O
MAV_PI	O
*	O
acos	function
(	O
drv	int
.	O
x	array
)	O
;	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
-	O
angle	float
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
shift	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
cent	int
.	O
z	array
)	O
;	O
transform	O
=	O
mav_matrixMult	function
(	O
shift	O
,	O
transform	O
)	O
;	O
Add_Composite	function
(	O
c	pointer
,	O
COMP_STREETLIGHT	int
,	O
&	O
transform	O
)	O
;	O
}	O
static	O
void	O
Add_Left_Lights	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
MAV_matrix	O
transform	O
,	O
shift	O
;	O
MAV_vector	O
cent	int
,	O
drv	int
;	O
float	O
angle	float
;	O
cent	int
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
0	int
]	O
.	O
x	array
+	O
pos	int
[	O
8	int
]	O
.	O
x	array
)	O
;	O
cent	int
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
0	int
]	O
.	O
y	array
+	O
pos	int
[	O
8	int
]	O
.	O
y	array
)	O
;	O
cent	int
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
0	int
]	O
.	O
z	array
+	O
pos	int
[	O
8	int
]	O
.	O
z	array
)	O
;	O
drv	int
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
drv	int
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
drv	int
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
angle	float
=	O
180.0	int
/	O
MAV_PI	O
*	O
acos	function
(	O
drv	int
.	O
x	array
)	O
;	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
-	O
angle	float
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
shift	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
cent	int
.	O
z	array
)	O
;	O
transform	O
=	O
mav_matrixMult	function
(	O
shift	O
,	O
transform	O
)	O
;	O
Add_Composite	function
(	O
c	pointer
,	O
COMP_STREETLIGHT	int
,	O
&	O
transform	O
)	O
;	O
}	O
static	O
void	O
Add_Right_Lights	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
MAV_matrix	O
transform	O
,	O
shift	O
;	O
MAV_vector	O
cent	int
,	O
drv	int
;	O
float	O
angle	float
;	O
cent	int
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
11	int
]	O
.	O
x	array
+	O
pos	int
[	O
3	int
]	O
.	O
x	array
)	O
;	O
cent	int
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
11	int
]	O
.	O
y	array
+	O
pos	int
[	O
3	int
]	O
.	O
y	array
)	O
;	O
cent	int
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
11	int
]	O
.	O
z	array
+	O
pos	int
[	O
3	int
]	O
.	O
z	array
)	O
;	O
drv	int
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
;	O
drv	int
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
;	O
drv	int
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
ne	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
;	O
drv	int
=	O
mav_vectorNormalize	function
(	O
drv	int
)	O
;	O
angle	float
=	O
180.0	int
/	O
MAV_PI	O
*	O
acos	function
(	O
drv	int
.	O
x	array
)	O
;	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
-	O
angle	float
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
shift	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
cent	int
.	O
z	array
)	O
;	O
transform	O
=	O
mav_matrixMult	function
(	O
shift	O
,	O
transform	O
)	O
;	O
Add_Composite	function
(	O
c	pointer
,	O
COMP_STREETLIGHT	int
,	O
&	O
transform	O
)	O
;	O
}	O
static	O
void	O
Generate_Waste	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
float	O
x	array
[	O
4	int
]	O
,	O
y	array
[	O
4	int
]	O
,	O
z	array
[	O
4	int
]	O
;	O
float	O
tu	pointer
[	O
4	int
]	O
,	O
tv	pointer
[	O
4	int
]	O
;	O
x	array
[	O
0	int
]	O
=	O
c	pointer
->	O
nw	int
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
0	int
]	O
=	O
c	pointer
->	O
nw	int
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
c	pointer
->	O
sw	int
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
1	int
]	O
=	O
c	pointer
->	O
sw	int
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
c	pointer
->	O
se	int
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
c	pointer
->	O
se	int
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
c	pointer
->	O
ne	int
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
c	pointer
->	O
ne	int
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.0625	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.0625	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.0625	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.0625	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.0625	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0625	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.0625	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.0625	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_DIRT	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
static	O
void	O
Map	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
MAV_vector	O
*	O
pos	int
)	O
{	O
MAV_vector	O
dr0	O
,	O
dr1	O
,	O
dr2	O
,	O
dr3	O
;	O
dr0	O
.	O
x	array
=	O
c	pointer
->	O
nw	int
.	O
x	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
dr0	O
.	O
y	array
=	O
c	pointer
->	O
nw	int
.	O
y	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
dr0	O
.	O
z	array
=	O
c	pointer
->	O
nw	int
.	O
z	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
dr0	O
=	O
mav_vectorNormalize	function
(	O
dr0	O
)	O
;	O
dr1	O
.	O
x	array
=	O
c	pointer
->	O
sw	int
.	O
x	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
;	O
dr1	O
.	O
y	array
=	O
c	pointer
->	O
sw	int
.	O
y	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
;	O
dr1	O
.	O
z	array
=	O
c	pointer
->	O
sw	int
.	O
z	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
;	O
dr1	O
=	O
mav_vectorNormalize	function
(	O
dr1	O
)	O
;	O
dr2	O
.	O
x	array
=	O
c	pointer
->	O
se	int
.	O
x	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
)	O
;	O
dr2	O
.	O
y	array
=	O
c	pointer
->	O
se	int
.	O
y	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
)	O
;	O
dr2	O
.	O
z	array
=	O
c	pointer
->	O
se	int
.	O
z	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
)	O
;	O
dr2	O
=	O
mav_vectorNormalize	function
(	O
dr2	O
)	O
;	O
dr3	O
.	O
x	array
=	O
c	pointer
->	O
ne	int
.	O
x	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
;	O
dr3	O
.	O
y	array
=	O
c	pointer
->	O
ne	int
.	O
y	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
;	O
dr3	O
.	O
z	array
=	O
c	pointer
->	O
ne	int
.	O
z	array
-	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
;	O
dr3	O
=	O
mav_vectorNormalize	function
(	O
dr3	O
)	O
;	O
pos	int
[	O
0	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
+	O
road_width	float
*	O
dr0	O
.	O
x	array
;	O
pos	int
[	O
0	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
+	O
road_width	float
*	O
dr0	O
.	O
y	array
;	O
pos	int
[	O
0	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
+	O
road_width	float
*	O
dr0	O
.	O
z	array
;	O
pos	int
[	O
3	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
-	O
road_width	float
*	O
dr0	O
.	O
x	array
;	O
pos	int
[	O
3	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
-	O
road_width	float
*	O
dr0	O
.	O
y	array
;	O
pos	int
[	O
3	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
-	O
road_width	float
*	O
dr0	O
.	O
z	array
;	O
pos	int
[	O
2	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
-	O
road_width	float
*	O
dr1	O
.	O
x	array
;	O
pos	int
[	O
2	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
-	O
road_width	float
*	O
dr1	O
.	O
y	array
;	O
pos	int
[	O
2	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
-	O
road_width	float
*	O
dr1	O
.	O
z	array
;	O
pos	int
[	O
6	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
+	O
road_width	float
*	O
dr1	O
.	O
x	array
;	O
pos	int
[	O
6	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
+	O
road_width	float
*	O
dr1	O
.	O
y	array
;	O
pos	int
[	O
6	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
+	O
road_width	float
*	O
dr1	O
.	O
z	array
;	O
pos	int
[	O
8	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
-	O
road_width	float
*	O
dr2	O
.	O
x	array
;	O
pos	int
[	O
8	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
-	O
road_width	float
*	O
dr2	O
.	O
y	array
;	O
pos	int
[	O
8	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
-	O
road_width	float
*	O
dr2	O
.	O
z	array
;	O
pos	int
[	O
11	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
)	O
+	O
road_width	float
*	O
dr2	O
.	O
x	array
;	O
pos	int
[	O
11	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
)	O
+	O
road_width	float
*	O
dr2	O
.	O
y	array
;	O
pos	int
[	O
11	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
)	O
+	O
road_width	float
*	O
dr2	O
.	O
z	array
;	O
pos	int
[	O
5	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
+	O
road_width	float
*	O
dr3	O
.	O
x	array
;	O
pos	int
[	O
5	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
+	O
road_width	float
*	O
dr3	O
.	O
y	array
;	O
pos	int
[	O
5	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
+	O
road_width	float
*	O
dr3	O
.	O
z	array
;	O
pos	int
[	O
10	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
-	O
road_width	float
*	O
dr3	O
.	O
x	array
;	O
pos	int
[	O
10	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
-	O
road_width	float
*	O
dr3	O
.	O
y	array
;	O
pos	int
[	O
10	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
-	O
road_width	float
*	O
dr3	O
.	O
z	array
;	O
dr0	O
.	O
x	array
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
5	int
]	O
.	O
x	array
+	O
pos	int
[	O
2	int
]	O
.	O
x	array
)	O
;	O
dr0	O
.	O
y	array
=	O
pos	int
[	O
2	int
]	O
.	O
y	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
5	int
]	O
.	O
y	array
+	O
pos	int
[	O
2	int
]	O
.	O
y	array
)	O
;	O
dr0	O
.	O
z	array
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
5	int
]	O
.	O
z	array
+	O
pos	int
[	O
2	int
]	O
.	O
z	array
)	O
;	O
dr0	O
=	O
mav_vectorNormalize	function
(	O
dr0	O
)	O
;	O
dr1	O
.	O
x	array
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
8	int
]	O
.	O
x	array
+	O
pos	int
[	O
0	int
]	O
.	O
x	array
)	O
;	O
dr1	O
.	O
y	array
=	O
pos	int
[	O
8	int
]	O
.	O
y	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
8	int
]	O
.	O
y	array
+	O
pos	int
[	O
0	int
]	O
.	O
y	array
)	O
;	O
dr1	O
.	O
z	array
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
8	int
]	O
.	O
z	array
+	O
pos	int
[	O
0	int
]	O
.	O
z	array
)	O
;	O
dr1	O
=	O
mav_vectorNormalize	function
(	O
dr1	O
)	O
;	O
dr2	O
.	O
x	array
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
10	int
]	O
.	O
x	array
+	O
pos	int
[	O
6	int
]	O
.	O
x	array
)	O
;	O
dr2	O
.	O
y	array
=	O
pos	int
[	O
10	int
]	O
.	O
y	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
10	int
]	O
.	O
y	array
+	O
pos	int
[	O
6	int
]	O
.	O
y	array
)	O
;	O
dr2	O
.	O
z	array
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
10	int
]	O
.	O
z	array
+	O
pos	int
[	O
6	int
]	O
.	O
z	array
)	O
;	O
dr2	O
=	O
mav_vectorNormalize	function
(	O
dr2	O
)	O
;	O
dr3	O
.	O
x	array
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
11	int
]	O
.	O
x	array
+	O
pos	int
[	O
3	int
]	O
.	O
x	array
)	O
;	O
dr3	O
.	O
y	array
=	O
pos	int
[	O
3	int
]	O
.	O
y	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
11	int
]	O
.	O
y	array
+	O
pos	int
[	O
3	int
]	O
.	O
y	array
)	O
;	O
dr3	O
.	O
z	array
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
-	O
0.5	int
*	O
(	O
pos	int
[	O
11	int
]	O
.	O
z	array
+	O
pos	int
[	O
3	int
]	O
.	O
z	array
)	O
;	O
dr3	O
=	O
mav_vectorNormalize	function
(	O
dr3	O
)	O
;	O
pos	int
[	O
1	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
2	int
]	O
.	O
x	array
+	O
pos	int
[	O
5	int
]	O
.	O
x	array
)	O
+	O
road_width	float
*	O
dr0	O
.	O
x	array
;	O
pos	int
[	O
1	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
2	int
]	O
.	O
y	array
+	O
pos	int
[	O
5	int
]	O
.	O
y	array
)	O
+	O
road_width	float
*	O
dr0	O
.	O
y	array
;	O
pos	int
[	O
1	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
2	int
]	O
.	O
z	array
+	O
pos	int
[	O
5	int
]	O
.	O
z	array
)	O
+	O
road_width	float
*	O
dr0	O
.	O
z	array
;	O
pos	int
[	O
4	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
2	int
]	O
.	O
x	array
+	O
pos	int
[	O
5	int
]	O
.	O
x	array
)	O
-	O
road_width	float
*	O
dr0	O
.	O
x	array
;	O
pos	int
[	O
4	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
2	int
]	O
.	O
y	array
+	O
pos	int
[	O
5	int
]	O
.	O
y	array
)	O
-	O
road_width	float
*	O
dr0	O
.	O
y	array
;	O
pos	int
[	O
4	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
2	int
]	O
.	O
z	array
+	O
pos	int
[	O
5	int
]	O
.	O
z	array
)	O
-	O
road_width	float
*	O
dr0	O
.	O
z	array
;	O
pos	int
[	O
7	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
0	int
]	O
.	O
x	array
+	O
pos	int
[	O
8	int
]	O
.	O
x	array
)	O
+	O
road_width	float
*	O
dr1	O
.	O
x	array
;	O
pos	int
[	O
7	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
0	int
]	O
.	O
y	array
+	O
pos	int
[	O
8	int
]	O
.	O
y	array
)	O
+	O
road_width	float
*	O
dr1	O
.	O
y	array
;	O
pos	int
[	O
7	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
0	int
]	O
.	O
z	array
+	O
pos	int
[	O
8	int
]	O
.	O
z	array
)	O
+	O
road_width	float
*	O
dr1	O
.	O
z	array
;	O
pos	int
[	O
9	int
]	O
.	O
x	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
6	int
]	O
.	O
x	array
+	O
pos	int
[	O
10	int
]	O
.	O
x	array
)	O
+	O
road_width	float
*	O
dr2	O
.	O
x	array
;	O
pos	int
[	O
9	int
]	O
.	O
y	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
6	int
]	O
.	O
y	array
+	O
pos	int
[	O
10	int
]	O
.	O
y	array
)	O
+	O
road_width	float
*	O
dr2	O
.	O
y	array
;	O
pos	int
[	O
9	int
]	O
.	O
z	array
=	O
0.5	int
*	O
(	O
pos	int
[	O
6	int
]	O
.	O
z	array
+	O
pos	int
[	O
10	int
]	O
.	O
z	array
)	O
+	O
road_width	float
*	O
dr2	O
.	O
z	array
;	O
}	O
static	O
void	O
Pave_Cell	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
int	O
material	int
,	O
int	O
texture	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
MAV_vector	O
nw	int
,	O
sw	int
,	O
se	int
,	O
ne	int
;	O
float	O
x	array
[	O
4	int
]	O
,	O
y	array
[	O
4	int
]	O
,	O
z	array
[	O
4	int
]	O
,	O
tu	pointer
[	O
4	int
]	O
,	O
tv	pointer
[	O
4	int
]	O
;	O
for	O
(	O
j	int
=	O
c	pointer
->	O
miny	int
;	O
j	int
<=	O
c	pointer
->	O
maxy	int
;	O
j	int
++	O
)	O
for	O
(	O
i	int
=	O
c	pointer
->	O
minx	int
;	O
i	int
<=	O
c	pointer
->	O
maxx	int
;	O
i	int
++	O
)	O
{	O
nw	int
=	O
Calc_Grid_Position	function
(	O
i	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
j	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
sw	int
=	O
Calc_Grid_Position	function
(	O
i	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
j	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
se	int
=	O
Calc_Grid_Position	function
(	O
(	O
i	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
j	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
ne	int
=	O
Calc_Grid_Position	function
(	O
(	O
i	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
j	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
nw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
nw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
nw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
sw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
sw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
sw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
se	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
se	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
se	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
ne	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
ne	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
ne	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
x	array
[	O
0	int
]	O
=	O
nw	int
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
0	int
]	O
=	O
nw	int
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
sw	int
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
1	int
]	O
=	O
sw	int
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
se	int
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
se	int
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
ne	int
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
ne	int
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
)	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.5	int
*	O
(	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
material	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
}	O
static	O
void	O
Generate_Type_0	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
Pave_Cell	function
(	O
c	pointer
,	O
MAT_WHITE	int
,	O
TEX_PAVEMENT	int
)	O
;	O
}	O
static	O
void	O
Generate_Type_1	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
float	O
tu	pointer
[	O
4	int
]	O
,	O
tv	pointer
[	O
4	int
]	O
;	O
MAV_vector	O
pos	int
[	O
12	int
]	O
;	O
Map	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
switch	O
(	O
c	pointer
->	O
type	int
)	O
{	O
case	O
1	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
128	int
+	O
64	int
+	O
32	int
+	O
16	int
+	O
8	int
+	O
4	int
)	O
;	O
break	O
;	O
case	O
2	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
4	int
+	O
2	int
+	O
1	int
+	O
128	int
+	O
64	int
+	O
32	int
+	O
16	int
)	O
;	O
break	O
;	O
case	O
4	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
64	int
+	O
128	int
+	O
1	int
+	O
2	int
+	O
4	int
+	O
8	int
+	O
16	int
)	O
;	O
break	O
;	O
case	O
8	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
2	int
+	O
4	int
+	O
8	int
+	O
16	int
+	O
32	int
+	O
64	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
Generate_Type_2	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
float	O
tu	pointer
[	O
4	int
]	O
,	O
tv	pointer
[	O
4	int
]	O
;	O
MAV_vector	O
pos	int
[	O
12	int
]	O
;	O
Map	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
switch	O
(	O
c	pointer
->	O
type	int
)	O
{	O
case	O
5	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Left_Lights	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
Add_Right_Lights	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
if	O
(	O
mav_random	function
(	O
)	O
<	O
0.5	int
)	O
{	O
Add_Horizontal_Crossing	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
Add_Vertical_CMarks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
}	O
else	O
Add_Vertical_Marks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
128	int
+	O
64	int
+	O
4	int
+	O
8	int
+	O
16	int
)	O
;	O
break	O
;	O
case	O
10	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Top_Lights	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
Add_Bottom_Lights	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
if	O
(	O
mav_random	function
(	O
)	O
<	O
0.5	int
)	O
{	O
Add_Vertical_Crossing	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
Add_Horizontal_CMarks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
}	O
else	O
Add_Horizontal_Marks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
2	int
+	O
4	int
+	O
16	int
+	O
32	int
+	O
64	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
Generate_Type_3	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
float	O
tu	pointer
[	O
4	int
]	O
,	O
tv	pointer
[	O
4	int
]	O
;	O
MAV_vector	O
pos	int
[	O
12	int
]	O
;	O
Map	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
switch	O
(	O
c	pointer
->	O
type	int
)	O
{	O
case	O
3	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
128	int
+	O
64	int
+	O
32	int
+	O
16	int
+	O
4	int
)	O
;	O
Add_East_North_Marks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
6	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
2	int
+	O
4	int
+	O
128	int
+	O
64	int
+	O
16	int
)	O
;	O
Add_East_South_Marks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
9	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
4	int
+	O
8	int
+	O
16	int
+	O
32	int
+	O
64	int
)	O
;	O
Add_West_North_Marks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
12	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_West_South_Marks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
2	int
+	O
4	int
+	O
8	int
+	O
16	int
+	O
64	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
Generate_Type_4	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
float	O
tu	pointer
[	O
4	int
]	O
,	O
tv	pointer
[	O
4	int
]	O
;	O
MAV_vector	O
pos	int
[	O
12	int
]	O
;	O
Map	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
switch	O
(	O
c	pointer
->	O
type	int
)	O
{	O
case	O
7	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
128	int
+	O
64	int
+	O
4	int
+	O
16	int
)	O
;	O
Add_Vertical_Marks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
Add_East_Junction	function
(	O
c	pointer
,	O
pos	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
11	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
4	int
+	O
64	int
+	O
32	int
+	O
16	int
)	O
;	O
Add_Horizontal_Marks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
Add_North_Junction	function
(	O
c	pointer
,	O
pos	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
13	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
64	int
+	O
4	int
+	O
8	int
+	O
16	int
)	O
;	O
Add_Vertical_Marks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
Add_West_Junction	function
(	O
c	pointer
,	O
pos	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
14	int
:	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
2	int
+	O
4	int
+	O
16	int
+	O
64	int
)	O
;	O
Add_Horizontal_Marks	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
Add_South_Junction	function
(	O
c	pointer
,	O
pos	int
,	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
Generate_Type_5	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
float	O
tu	pointer
[	O
4	int
]	O
,	O
tv	pointer
[	O
4	int
]	O
;	O
MAV_vector	O
pos	int
[	O
12	int
]	O
;	O
Map	function
(	O
c	pointer
,	O
pos	int
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
2	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
6	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
10	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
5	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
0	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
1	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
4	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
3	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
0	int
]	O
=	O
pos	int
[	O
7	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
1	int
]	O
=	O
pos	int
[	O
8	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
2	int
]	O
=	O
pos	int
[	O
11	int
]	O
.	O
z	array
;	O
vx	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
x	array
;	O
vy	pointer
[	O
3	int
]	O
=	O
0.0	int
;	O
vz	pointer
[	O
3	int
]	O
=	O
pos	int
[	O
9	int
]	O
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
vx	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
vz	pointer
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
vx	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
vz	pointer
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
vx	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
vz	pointer
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
vx	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
vz	pointer
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_ASPHALT	O
,	O
TEX_ASPHALT	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
Add_Pavement	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
+	O
4	int
+	O
16	int
+	O
64	int
)	O
;	O
Add_South_Junction	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
)	O
;	O
Add_North_Junction	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
)	O
;	O
Add_West_Junction	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
)	O
;	O
Add_East_Junction	function
(	O
c	pointer
,	O
pos	int
,	O
1	int
)	O
;	O
}	O
static	O
void	O
Generate_Street_Polys	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
switch	O
(	O
c	pointer
->	O
type	int
)	O
{	O
case	O
0	int
:	O
Generate_Type_0	function
(	O
c	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
case	O
8	int
:	O
case	O
4	int
:	O
case	O
2	int
:	O
Generate_Type_1	function
(	O
c	pointer
)	O
;	O
break	O
;	O
case	O
5	int
:	O
case	O
10	int
:	O
Generate_Type_2	function
(	O
c	pointer
)	O
;	O
break	O
;	O
case	O
12	int
:	O
case	O
6	int
:	O
case	O
9	int
:	O
case	O
3	int
:	O
Generate_Type_3	function
(	O
c	pointer
)	O
;	O
break	O
;	O
case	O
14	int
:	O
case	O
13	int
:	O
case	O
11	int
:	O
case	O
7	int
:	O
Generate_Type_4	function
(	O
c	pointer
)	O
;	O
break	O
;	O
case	O
15	int
:	O
Generate_Type_5	function
(	O
c	pointer
)	O
;	O
break	O
;	O
case	O
99	int
:	O
Generate_Waste	function
(	O
c	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
Create_Occluder	function
(	O
float	O
blx	float
,	O
float	O
bly	float
,	O
float	O
blz	float
,	O
float	O
trx	float
,	O
float	O
try	float
,	O
float	O
trz	float
)	O
{	O
MAV_occluder	struct
*	O
o	pointer
;	O
o	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
MAV_occluder	struct
)	O
)	O
;	O
o	pointer
->	O
occluder	int
.	O
min	O
.	O
x	array
=	O
blx	float
;	O
o	pointer
->	O
occluder	int
.	O
min	O
.	O
y	array
=	O
bly	float
;	O
o	pointer
->	O
occluder	int
.	O
min	O
.	O
z	array
=	O
blz	float
;	O
o	pointer
->	O
occluder	int
.	O
max	O
.	O
x	array
=	O
trx	float
;	O
o	pointer
->	O
occluder	int
.	O
max	O
.	O
y	array
=	O
try	float
;	O
o	pointer
->	O
occluder	int
.	O
max	O
.	O
z	array
=	O
trz	float
;	O
o	pointer
->	O
matrix	int
=	O
MAV_ID_MATRIX	O
;	O
o	pointer
->	O
num_vertices	int
=	O
0	int
;	O
mav_listItemAdd	function
(	O
list_of_objects	pointer
,	O
(	O
void	O
*	O
)	O
mav_objectNew	function
(	O
mav_class_occluder	pointer
,	O
o	pointer
)	O
)	O
;	O
total_objects	int
++	O
;	O
}	O
static	O
void	O
Generate_Park_Features	function
(	O
void	O
)	O
{	O
MAV_cityCell	struct
*	O
c	pointer
;	O
MAV_object	O
*	O
obj	pointer
;	O
int	O
num_parks	int
=	O
0	int
;	O
int	O
sthenge_id	int
;	O
int	O
red_fountain_id	int
;	O
int	O
door_id	int
;	O
int	O
easter_id	int
;	O
int	O
ok	int
;	O
int	O
i	int
,	O
j	int
,	O
n	int
;	O
float	O
rnd	float
;	O
MAV_matrix	O
transform	O
;	O
MAV_vector	O
pt	O
;	O
float	O
scale	float
,	O
u	float
,	O
v	float
;	O
MAV_vector	O
r1	O
,	O
r2	O
,	O
r3	O
,	O
r4	O
;	O
MAV_vector	O
nw	int
,	O
sw	int
,	O
se	int
,	O
ne	int
;	O
int	O
num	char
;	O
MAV_vector	O
cent	int
;	O
mav_listPointerReset	function
(	O
list_of_objects	pointer
)	O
;	O
while	O
(	O
mav_listItemNext	function
(	O
list_of_objects	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
obj	pointer
)	O
)	O
{	O
if	O
(	O
obj	pointer
->	O
the_class	O
==	O
mav_class_citycell	pointer
)	O
{	O
c	pointer
=	O
(	O
MAV_cityCell	struct
*	O
)	O
obj	pointer
->	O
the_data	O
;	O
if	O
(	O
c	pointer
->	O
building	int
==	O
1	int
&&	O
c	pointer
->	O
type	int
==	O
5	int
)	O
num_parks	int
+=	O
(	O
c	pointer
->	O
maxx	int
-	O
c	pointer
->	O
minx	int
+	O
1	int
)	O
*	O
(	O
c	pointer
->	O
maxy	int
-	O
c	pointer
->	O
miny	int
+	O
1	int
)	O
;	O
}	O
}	O
easter_id	int
=	O
(	O
int	O
)	O
(	O
num_parks	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
sthenge_id	int
=	O
(	O
int	O
)	O
(	O
num_parks	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
red_fountain_id	int
=	O
(	O
int	O
)	O
(	O
num_parks	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
door_id	int
=	O
(	O
int	O
)	O
(	O
num_parks	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
easter_id	int
=	O
5	int
;	O
sthenge_id	int
=	O
13	int
;	O
red_fountain_id	int
=	O
29	int
;	O
door_id	int
=	O
41	int
;	O
ok	int
=	O
1	int
;	O
num_parks	int
=	O
0	int
;	O
mav_listPointerReset	function
(	O
list_of_objects	pointer
)	O
;	O
while	O
(	O
ok	int
&&	O
mav_listItemNext	function
(	O
list_of_objects	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
obj	pointer
)	O
)	O
{	O
if	O
(	O
obj	pointer
->	O
the_class	O
==	O
mav_class_citycell	pointer
)	O
{	O
c	pointer
=	O
(	O
MAV_cityCell	struct
*	O
)	O
obj	pointer
->	O
the_data	O
;	O
if	O
(	O
c	pointer
->	O
building	int
==	O
1	int
&&	O
c	pointer
->	O
type	int
==	O
5	int
)	O
{	O
for	O
(	O
j	int
=	O
c	pointer
->	O
miny	int
;	O
j	int
<=	O
c	pointer
->	O
maxy	int
;	O
j	int
++	O
)	O
for	O
(	O
i	int
=	O
c	pointer
->	O
minx	int
;	O
i	int
<=	O
c	pointer
->	O
maxx	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
num_parks	int
==	O
sthenge_id	int
)	O
{	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
360.0	int
*	O
mav_random	function
(	O
)	O
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
PAVE_HEIGHT	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Feature	function
(	O
c	pointer
,	O
COMP_STHENGE	int
,	O
&	O
transform	O
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"sthenge at %d,%d\n"	pointer
,	O
i	int
,	O
j	int
)	O
;	O
}	O
else	O
if	O
(	O
num_parks	int
==	O
easter_id	int
)	O
{	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
360.0	int
*	O
mav_random	function
(	O
)	O
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
PAVE_HEIGHT	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Feature	function
(	O
c	pointer
,	O
COMP_EASTER	int
,	O
&	O
transform	O
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"easter at %d,%d\n"	pointer
,	O
i	int
,	O
j	int
)	O
;	O
}	O
else	O
if	O
(	O
num_parks	int
==	O
red_fountain_id	int
)	O
{	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
360.0	int
*	O
mav_random	function
(	O
)	O
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
PAVE_HEIGHT	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Feature	function
(	O
c	pointer
,	O
COMP_RED_FOUNTAIN	int
,	O
&	O
transform	O
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"red fountain at %d,%d\n"	pointer
,	O
i	int
,	O
j	int
)	O
;	O
}	O
else	O
if	O
(	O
num_parks	int
==	O
door_id	int
)	O
{	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
360.0	int
*	O
mav_random	function
(	O
)	O
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
PAVE_HEIGHT	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
Add_Feature	function
(	O
c	pointer
,	O
COMP_DOOR	int
,	O
&	O
transform	O
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"door at %d,%d\n"	pointer
,	O
i	int
,	O
j	int
)	O
;	O
}	O
else	O
{	O
rnd	float
=	O
mav_random	function
(	O
)	O
;	O
if	O
(	O
rnd	float
<	O
0.9	int
)	O
{	O
nw	int
=	O
Calc_Grid_Position	function
(	O
i	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
j	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
sw	int
=	O
Calc_Grid_Position	function
(	O
i	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
j	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
se	int
=	O
Calc_Grid_Position	function
(	O
(	O
i	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
j	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
ne	int
=	O
Calc_Grid_Position	function
(	O
(	O
i	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
j	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
nw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
nw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
nw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
sw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
sw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
sw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
se	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
se	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
se	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
ne	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
ne	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
ne	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
r1	O
.	O
x	array
=	O
c	pointer
->	O
cent	int
.	O
x	array
+	O
nw	int
.	O
x	array
;	O
r1	O
.	O
y	array
=	O
c	pointer
->	O
cent	int
.	O
y	array
+	O
nw	int
.	O
y	array
;	O
r1	O
.	O
z	array
=	O
c	pointer
->	O
cent	int
.	O
z	array
+	O
nw	int
.	O
z	array
;	O
r2	O
.	O
x	array
=	O
ne	int
.	O
x	array
-	O
nw	int
.	O
x	array
;	O
r2	O
.	O
y	array
=	O
ne	int
.	O
y	array
-	O
nw	int
.	O
y	array
;	O
r2	O
.	O
z	array
=	O
ne	int
.	O
z	array
-	O
nw	int
.	O
z	array
;	O
r3	O
.	O
x	array
=	O
sw	int
.	O
x	array
-	O
nw	int
.	O
x	array
;	O
r3	O
.	O
y	array
=	O
sw	int
.	O
y	array
-	O
nw	int
.	O
y	array
;	O
r3	O
.	O
z	array
=	O
sw	int
.	O
z	array
-	O
nw	int
.	O
z	array
;	O
r4	O
.	O
x	array
=	O
se	int
.	O
x	array
-	O
ne	int
.	O
x	array
;	O
r4	O
.	O
y	array
=	O
se	int
.	O
y	array
-	O
ne	int
.	O
y	array
;	O
r4	O
.	O
z	array
=	O
se	int
.	O
z	array
-	O
ne	int
.	O
z	array
;	O
num	char
=	O
(	O
int	O
)	O
(	O
4.0	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
num	char
;	O
n	int
++	O
)	O
{	O
scale	float
=	O
0.5	int
+	O
0.5	int
*	O
mav_random	function
(	O
)	O
;	O
u	float
=	O
0.1	int
+	O
0.8	int
*	O
mav_random	function
(	O
)	O
;	O
v	float
=	O
0.1	int
+	O
0.8	int
*	O
mav_random	function
(	O
)	O
;	O
PAR_TO_WOR	O
(	O
u	float
,	O
v	float
,	O
r1	O
,	O
r2	O
,	O
r3	O
,	O
r4	O
,	O
pt	O
)	O
;	O
rnd	float
=	O
mav_random	function
(	O
)	O
;	O
if	O
(	O
rnd	float
<	O
0.5	int
)	O
Add_Billboard	function
(	O
TEX_TREE1	int
,	O
pt	O
.	O
x	array
,	O
PAVE_HEIGHT	int
,	O
pt	O
.	O
z	array
,	O
6.66	int
*	O
scale	float
,	O
10.0	int
*	O
scale	float
,	O
0.0	int
,	O
1.0	int
,	O
0.0	int
)	O
;	O
else	O
Add_Billboard	function
(	O
TEX_TREE3	int
,	O
pt	O
.	O
x	array
,	O
PAVE_HEIGHT	int
,	O
pt	O
.	O
z	array
,	O
6.66	int
*	O
scale	float
,	O
10.0	int
*	O
scale	float
,	O
0.0	int
,	O
1.0	int
,	O
0.0	int
)	O
;	O
}	O
}	O
else	O
{	O
nw	int
=	O
Calc_Grid_Position	function
(	O
i	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
j	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
sw	int
=	O
Calc_Grid_Position	function
(	O
i	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
j	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
se	int
=	O
Calc_Grid_Position	function
(	O
(	O
i	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
j	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
ne	int
=	O
Calc_Grid_Position	function
(	O
(	O
i	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
j	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
cent	int
.	O
x	array
=	O
0.25	int
*	O
(	O
nw	int
.	O
x	array
+	O
sw	int
.	O
x	array
+	O
se	int
.	O
x	array
+	O
ne	int
.	O
x	array
)	O
;	O
cent	int
.	O
y	array
=	O
0.25	int
*	O
(	O
nw	int
.	O
y	array
+	O
sw	int
.	O
y	array
+	O
se	int
.	O
y	array
+	O
ne	int
.	O
y	array
)	O
;	O
cent	int
.	O
z	array
=	O
0.25	int
*	O
(	O
nw	int
.	O
z	array
+	O
sw	int
.	O
z	array
+	O
se	int
.	O
z	array
+	O
ne	int
.	O
z	array
)	O
;	O
rnd	float
=	O
mav_random	function
(	O
)	O
;	O
if	O
(	O
rnd	float
<	O
0.5	int
)	O
{	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
360.0	int
*	O
mav_random	function
(	O
)	O
,	O
cent	int
.	O
x	array
,	O
PAVE_HEIGHT	int
,	O
cent	int
.	O
z	array
)	O
;	O
Add_Feature	function
(	O
c	pointer
,	O
COMP_FOUNTAIN	int
,	O
&	O
transform	O
)	O
;	O
}	O
else	O
{	O
transform	O
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
360.0	int
*	O
mav_random	function
(	O
)	O
,	O
cent	int
.	O
x	array
,	O
PAVE_HEIGHT	int
,	O
cent	int
.	O
z	array
)	O
;	O
Add_Feature	function
(	O
c	pointer
,	O
COMP_GAZEBO	int
,	O
&	O
transform	O
)	O
;	O
}	O
}	O
}	O
num_parks	int
++	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
Generate_Park	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
MAV_vector	O
nw	int
,	O
sw	int
,	O
se	int
,	O
ne	int
;	O
float	O
x	array
[	O
4	int
]	O
,	O
y	array
[	O
4	int
]	O
,	O
z	array
[	O
4	int
]	O
,	O
tu	pointer
[	O
4	int
]	O
,	O
tv	pointer
[	O
4	int
]	O
;	O
for	O
(	O
j	int
=	O
c	pointer
->	O
miny	int
;	O
j	int
<=	O
c	pointer
->	O
maxy	int
;	O
j	int
++	O
)	O
for	O
(	O
i	int
=	O
c	pointer
->	O
minx	int
;	O
i	int
<=	O
c	pointer
->	O
maxx	int
;	O
i	int
++	O
)	O
{	O
nw	int
=	O
Calc_Grid_Position	function
(	O
i	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
j	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
sw	int
=	O
Calc_Grid_Position	function
(	O
i	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
j	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
se	int
=	O
Calc_Grid_Position	function
(	O
(	O
i	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
j	int
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
ne	int
=	O
Calc_Grid_Position	function
(	O
(	O
i	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
j	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
nw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
nw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
nw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
sw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
sw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
sw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
se	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
se	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
se	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
ne	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
ne	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
ne	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
x	array
[	O
0	int
]	O
=	O
nw	int
.	O
x	array
;	O
y	array
[	O
0	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
0	int
]	O
=	O
nw	int
.	O
z	array
;	O
x	array
[	O
1	int
]	O
=	O
sw	int
.	O
x	array
;	O
y	array
[	O
1	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
1	int
]	O
=	O
sw	int
.	O
z	array
;	O
x	array
[	O
2	int
]	O
=	O
se	int
.	O
x	array
;	O
y	array
[	O
2	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
2	int
]	O
=	O
se	int
.	O
z	array
;	O
x	array
[	O
3	int
]	O
=	O
ne	int
.	O
x	array
;	O
y	array
[	O
3	int
]	O
=	O
PAVE_HEIGHT	int
;	O
z	array
[	O
3	int
]	O
=	O
ne	int
.	O
z	array
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
tu	pointer
[	O
3	int
]	O
=	O
x	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
tv	pointer
[	O
3	int
]	O
=	O
z	array
[	O
3	int
]	O
+	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_GRASS	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
}	O
static	O
int	O
Pick_Texture	function
(	O
float	O
*	O
tu	pointer
,	O
float	O
*	O
tv	pointer
,	O
float	O
wid	float
,	O
float	O
hei	float
)	O
{	O
float	O
rnd	float
;	O
int	O
texture	int
;	O
int	O
numx	int
,	O
numz	int
;	O
rnd	float
=	O
mav_random	function
(	O
)	O
;	O
if	O
(	O
rnd	float
<	O
1.0	int
/	O
6.0	int
)	O
{	O
texture	int
=	O
TEX_BUILDING_SIDE1	int
;	O
numx	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
wid	float
/	O
2.0	int
)	O
)	O
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
0	int
]	O
=	O
1.0	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
2	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
3	int
]	O
=	O
1.0	int
;	O
}	O
else	O
if	O
(	O
rnd	float
<	O
2.0	int
/	O
6.0	int
)	O
{	O
texture	int
=	O
TEX_BUILDING_SIDE2	int
;	O
numx	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
wid	float
/	O
4.0	int
)	O
)	O
;	O
numz	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
hei	float
/	O
2.0	int
)	O
)	O
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
0	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
2	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
}	O
else	O
if	O
(	O
rnd	float
<	O
3.0	int
/	O
6.0	int
)	O
{	O
texture	int
=	O
TEX_BUILDING_SIDE3	int
;	O
numx	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
wid	float
/	O
3.0	int
)	O
)	O
;	O
numz	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
hei	float
/	O
2.0	int
)	O
)	O
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
0	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
2	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
}	O
else	O
if	O
(	O
rnd	float
<	O
4.0	int
/	O
6.0	int
)	O
{	O
texture	int
=	O
TEX_BUILDING_SIDE4	int
;	O
numx	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
wid	float
/	O
4.0	int
)	O
)	O
;	O
numz	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
hei	float
/	O
3.0	int
)	O
)	O
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
0	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
2	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
}	O
else	O
if	O
(	O
rnd	float
<	O
5.0	int
/	O
6.0	int
)	O
{	O
texture	int
=	O
TEX_BUILDING_SIDE5	int
;	O
numx	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
wid	float
/	O
3.0	int
)	O
)	O
;	O
numz	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
hei	float
/	O
2.0	int
)	O
)	O
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
0	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
2	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
}	O
else	O
{	O
texture	int
=	O
TEX_BUILDING_SIDE6	int
;	O
numx	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
wid	float
/	O
3.0	int
)	O
)	O
;	O
numz	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
hei	float
/	O
2.0	int
)	O
)	O
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
0	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
2	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
}	O
return	O
texture	int
;	O
}	O
static	O
void	O
Generate_Textured_Building	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
float	O
sx	float
,	O
sy	float
,	O
sz	float
;	O
float	O
wid	float
,	O
len	float
,	O
hei	float
;	O
float	O
owid	float
,	O
olen	float
;	O
float	O
x	array
[	O
5	int
]	O
,	O
y	array
[	O
5	int
]	O
,	O
z	array
[	O
5	int
]	O
;	O
float	O
tu	pointer
[	O
5	int
]	O
,	O
tv	pointer
[	O
5	int
]	O
;	O
float	O
blx	float
,	O
blz	float
,	O
trx	float
,	O
trz	float
;	O
float	O
rnd	float
;	O
int	O
texture	int
;	O
float	O
scx	float
,	O
scz	float
;	O
int	O
roofx	int
,	O
roofz	int
=	O
0	int
;	O
float	O
roof_hei	float
;	O
int	O
col	int
;	O
float	O
ex	float
,	O
ez	float
;	O
sx	float
=	O
c	pointer
->	O
nw	int
.	O
x	array
>	O
c	pointer
->	O
sw	int
.	O
x	array
?	O
c	pointer
->	O
nw	int
.	O
x	array
:	O
c	pointer
->	O
sw	int
.	O
x	array
;	O
sy	float
=	O
PAVE_HEIGHT	int
;	O
sz	float
=	O
c	pointer
->	O
sw	int
.	O
z	array
>	O
c	pointer
->	O
se	int
.	O
z	array
?	O
c	pointer
->	O
sw	int
.	O
z	array
:	O
c	pointer
->	O
se	int
.	O
z	array
;	O
ex	float
=	O
c	pointer
->	O
ne	int
.	O
x	array
<	O
c	pointer
->	O
se	int
.	O
x	array
?	O
c	pointer
->	O
ne	int
.	O
x	array
:	O
c	pointer
->	O
se	int
.	O
x	array
;	O
ez	float
=	O
c	pointer
->	O
ne	int
.	O
z	array
<	O
c	pointer
->	O
nw	int
.	O
z	array
?	O
c	pointer
->	O
ne	int
.	O
z	array
:	O
c	pointer
->	O
nw	int
.	O
z	array
;	O
owid	float
=	O
wid	float
=	O
ex	float
-	O
sx	float
;	O
olen	float
=	O
len	float
=	O
ez	float
-	O
sz	float
;	O
hei	float
=	O
c	pointer
->	O
height	float
;	O
if	O
(	O
c	pointer
->	O
maxx	int
-	O
c	pointer
->	O
minx	int
==	O
0	int
&&	O
c	pointer
->	O
maxy	int
-	O
c	pointer
->	O
miny	int
>	O
0	int
)	O
roofx	int
=	O
mav_random	function
(	O
)	O
<	O
0.5	int
?	O
1	int
:	O
0	int
;	O
else	O
if	O
(	O
c	pointer
->	O
maxx	int
-	O
c	pointer
->	O
minx	int
>	O
0	int
&&	O
c	pointer
->	O
maxy	int
-	O
c	pointer
->	O
miny	int
==	O
0	int
)	O
roofx	int
=	O
mav_random	function
(	O
)	O
<	O
0.5	int
?	O
1	int
:	O
0	int
;	O
else	O
roofx	int
=	O
roofz	int
=	O
mav_random	function
(	O
)	O
<	O
0.5	int
?	O
1	int
:	O
0	int
;	O
roof_hei	float
=	O
hei	float
*	O
(	O
0.1	int
+	O
0.1	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
rnd	float
=	O
mav_random	function
(	O
)	O
;	O
if	O
(	O
rnd	float
<	O
0.3	int
)	O
col	int
=	O
MAT_WHITE	int
;	O
else	O
if	O
(	O
rnd	float
<	O
0.6	int
)	O
col	int
=	O
MAT_WHITE2	int
;	O
else	O
col	int
=	O
MAT_WHITE3	int
;	O
scx	float
=	O
0.6	int
+	O
0.4	int
*	O
mav_random	function
(	O
)	O
;	O
scz	float
=	O
0.6	int
+	O
0.4	int
*	O
mav_random	function
(	O
)	O
;	O
wid	float
=	O
(	O
wid	float
-	O
3.0	int
)	O
*	O
scx	float
;	O
len	float
=	O
(	O
len	float
-	O
3.0	int
)	O
*	O
scz	float
;	O
blx	float
=	O
1.5	int
+	O
(	O
(	O
owid	float
-	O
3.0	int
)	O
-	O
wid	float
)	O
*	O
mav_random	function
(	O
)	O
;	O
blz	float
=	O
1.5	int
+	O
(	O
(	O
olen	float
-	O
3.0	int
)	O
-	O
len	float
)	O
*	O
mav_random	function
(	O
)	O
;	O
trx	float
=	O
blx	float
+	O
wid	float
;	O
trz	float
=	O
blz	float
+	O
len	float
;	O
Add_Relative_Lod_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
col	int
,	O
-	O
1	int
,	O
blx	float
,	O
0.0	int
,	O
blz	float
,	O
trx	float
,	O
(	O
roofx	int
||	O
roofz	int
)	O
?	O
(	O
hei	float
+	O
roof_hei	float
)	O
:	O
hei	float
,	O
trz	float
,	O
1.0	int
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
blz	float
;	O
texture	int
=	O
Pick_Texture	function
(	O
tu	pointer
,	O
tv	pointer
,	O
trx	float
-	O
blx	float
,	O
hei	float
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
col	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
if	O
(	O
roofx	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
roof_hei	float
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
col	int
,	O
TEX_BUILDING_SIDE7	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
texture	int
=	O
Pick_Texture	function
(	O
tu	pointer
,	O
tv	pointer
,	O
trz	float
-	O
blz	float
,	O
hei	float
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
col	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
if	O
(	O
roofz	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
roof_hei	float
;	O
tu	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
col	int
,	O
TEX_BUILDING_SIDE7	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
texture	int
=	O
Pick_Texture	function
(	O
tu	pointer
,	O
tv	pointer
,	O
trx	float
-	O
blx	float
,	O
hei	float
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
col	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
if	O
(	O
roofx	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
roof_hei	float
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
col	int
,	O
TEX_BUILDING_SIDE7	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
blz	float
;	O
texture	int
=	O
Pick_Texture	function
(	O
tu	pointer
,	O
tv	pointer
,	O
trz	float
-	O
blz	float
,	O
hei	float
)	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
col	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
if	O
(	O
roofz	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
roof_hei	float
;	O
tu	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
col	int
,	O
TEX_BUILDING_SIDE7	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
if	O
(	O
!	O
roofx	int
&&	O
!	O
roofz	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
z	array
[	O
3	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
else	O
if	O
(	O
roofx	int
&&	O
!	O
roofz	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
z	array
[	O
3	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
z	array
[	O
3	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
else	O
if	O
(	O
roofz	int
&&	O
!	O
roofx	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
z	array
[	O
3	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
z	array
[	O
3	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
else	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_WHITE	int
,	O
TEX_BUILDING_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
Create_Occluder	function
(	O
c	pointer
->	O
cent	int
.	O
x	array
+	O
sx	float
+	O
blx	float
,	O
sy	float
,	O
c	pointer
->	O
cent	int
.	O
z	array
+	O
sz	float
+	O
blz	float
,	O
c	pointer
->	O
cent	int
.	O
x	array
+	O
sx	float
+	O
trx	float
,	O
sy	float
+	O
hei	float
,	O
c	pointer
->	O
cent	int
.	O
z	array
+	O
sz	float
+	O
trz	float
)	O
;	O
}	O
static	O
void	O
Generate_Textured_Building2	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
float	O
sx	float
,	O
sy	float
,	O
sz	float
;	O
float	O
wid	float
,	O
len	float
,	O
hei	float
;	O
float	O
owid	float
,	O
olen	float
;	O
float	O
x	array
[	O
5	int
]	O
,	O
y	array
[	O
5	int
]	O
,	O
z	array
[	O
5	int
]	O
;	O
float	O
tu	pointer
[	O
5	int
]	O
,	O
tv	pointer
[	O
5	int
]	O
;	O
float	O
blx	float
,	O
blz	float
,	O
trx	float
,	O
trz	float
;	O
float	O
scx	float
,	O
scz	float
;	O
int	O
roofx	int
,	O
roofz	int
;	O
float	O
roof_hei	float
;	O
int	O
numx	int
,	O
numz	int
;	O
int	O
texture	int
=	O
mav_random	function
(	O
)	O
<	O
0.5	int
?	O
TEX_WINDOW	int
:	O
TEX_WINDOW2	int
;	O
float	O
ex	float
,	O
ez	float
;	O
sx	float
=	O
c	pointer
->	O
nw	int
.	O
x	array
>	O
c	pointer
->	O
sw	int
.	O
x	array
?	O
c	pointer
->	O
nw	int
.	O
x	array
:	O
c	pointer
->	O
sw	int
.	O
x	array
;	O
sy	float
=	O
PAVE_HEIGHT	int
;	O
sz	float
=	O
c	pointer
->	O
sw	int
.	O
z	array
>	O
c	pointer
->	O
se	int
.	O
z	array
?	O
c	pointer
->	O
sw	int
.	O
z	array
:	O
c	pointer
->	O
se	int
.	O
z	array
;	O
ex	float
=	O
c	pointer
->	O
ne	int
.	O
x	array
<	O
c	pointer
->	O
se	int
.	O
x	array
?	O
c	pointer
->	O
ne	int
.	O
x	array
:	O
c	pointer
->	O
se	int
.	O
x	array
;	O
ez	float
=	O
c	pointer
->	O
ne	int
.	O
z	array
<	O
c	pointer
->	O
nw	int
.	O
z	array
?	O
c	pointer
->	O
ne	int
.	O
z	array
:	O
c	pointer
->	O
nw	int
.	O
z	array
;	O
owid	float
=	O
wid	float
=	O
ex	float
-	O
sx	float
;	O
olen	float
=	O
len	float
=	O
ez	float
-	O
sz	float
;	O
hei	float
=	O
c	pointer
->	O
height	float
;	O
roofx	int
=	O
roofz	int
=	O
1	int
;	O
roof_hei	float
=	O
1.0	int
;	O
scx	float
=	O
0.6	int
+	O
0.4	int
*	O
mav_random	function
(	O
)	O
;	O
scz	float
=	O
0.6	int
+	O
0.4	int
*	O
mav_random	function
(	O
)	O
;	O
wid	float
=	O
(	O
wid	float
-	O
3.0	int
)	O
*	O
scx	float
;	O
len	float
=	O
(	O
len	float
-	O
3.0	int
)	O
*	O
scz	float
;	O
blx	float
=	O
1.5	int
+	O
(	O
(	O
owid	float
-	O
3.0	int
)	O
-	O
wid	float
)	O
*	O
mav_random	function
(	O
)	O
;	O
blz	float
=	O
1.5	int
+	O
(	O
(	O
olen	float
-	O
3.0	int
)	O
-	O
len	float
)	O
*	O
mav_random	function
(	O
)	O
;	O
trx	float
=	O
blx	float
+	O
wid	float
;	O
trz	float
=	O
blz	float
+	O
len	float
;	O
Add_Relative_Lod_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
blx	float
,	O
0.0	int
,	O
blz	float
,	O
trx	float
,	O
(	O
roofx	int
||	O
roofz	int
)	O
?	O
(	O
hei	float
+	O
roof_hei	float
)	O
:	O
hei	float
,	O
trz	float
,	O
1.0	int
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
blz	float
;	O
numx	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
(	O
trx	float
-	O
blx	float
)	O
/	O
2.0	int
)	O
)	O
;	O
numz	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
hei	float
/	O
2.0	int
)	O
)	O
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
0	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
2	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_NOTEX	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
if	O
(	O
roofx	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
roof_hei	float
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
numx	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
(	O
trz	float
-	O
blz	float
)	O
/	O
2.0	int
)	O
)	O
;	O
numz	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
hei	float
/	O
2.0	int
)	O
)	O
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
0	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
2	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_NOTEX	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
if	O
(	O
roofz	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
roof_hei	float
;	O
tu	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
numx	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
(	O
trx	float
-	O
blx	float
)	O
/	O
2.0	int
)	O
)	O
;	O
numz	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
hei	float
/	O
2.0	int
)	O
)	O
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
0	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
2	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_NOTEX	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
if	O
(	O
roofx	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
roof_hei	float
;	O
tu	pointer
[	O
2	int
]	O
=	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
blz	float
;	O
numx	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
(	O
trz	float
-	O
blz	float
)	O
/	O
2.0	int
)	O
)	O
;	O
numz	int
=	O
(	O
int	O
)	O
(	O
ceil	function
(	O
hei	float
/	O
2.0	int
)	O
)	O
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
0	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
2	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numx	int
;	O
tv	pointer
[	O
3	int
]	O
=	O
(	O
float	O
)	O
numz	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_NOTEX	int
,	O
texture	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
if	O
(	O
roofz	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
z	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tu	pointer
[	O
1	int
]	O
=	O
z	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
roof_hei	float
;	O
tu	pointer
[	O
2	int
]	O
=	O
z	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.0	int
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_TOP	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
if	O
(	O
!	O
roofx	int
&&	O
!	O
roofz	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.25	int
*	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.25	int
*	O
z	array
[	O
3	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
else	O
if	O
(	O
roofx	int
&&	O
!	O
roofz	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.25	int
*	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.25	int
*	O
z	array
[	O
3	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
(	O
trx	float
+	O
blx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.25	int
*	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.25	int
*	O
z	array
[	O
3	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
else	O
if	O
(	O
roofz	int
&&	O
!	O
roofx	int
)	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.25	int
*	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.25	int
*	O
z	array
[	O
3	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
3	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
3	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
3	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
tu	pointer
[	O
3	int
]	O
=	O
0.25	int
*	O
x	array
[	O
3	int
]	O
;	O
tv	pointer
[	O
3	int
]	O
=	O
0.25	int
*	O
z	array
[	O
3	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
4	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
else	O
{	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
trz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
trz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
trx	float
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
x	array
[	O
0	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
0	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
0	int
]	O
=	O
sz	float
+	O
blz	float
;	O
x	array
[	O
1	int
]	O
=	O
sx	float
+	O
(	O
blx	float
+	O
trx	float
)	O
/	O
2.0	int
;	O
y	array
[	O
1	int
]	O
=	O
sy	float
+	O
hei	float
+	O
roof_hei	float
;	O
z	array
[	O
1	int
]	O
=	O
sz	float
+	O
(	O
blz	float
+	O
trz	float
)	O
/	O
2.0	int
;	O
x	array
[	O
2	int
]	O
=	O
sx	float
+	O
blx	float
;	O
y	array
[	O
2	int
]	O
=	O
sy	float
+	O
hei	float
;	O
z	array
[	O
2	int
]	O
=	O
sz	float
+	O
blz	float
;	O
tu	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
x	array
[	O
0	int
]	O
;	O
tv	pointer
[	O
0	int
]	O
=	O
0.25	int
*	O
z	array
[	O
0	int
]	O
;	O
tu	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
x	array
[	O
1	int
]	O
;	O
tv	pointer
[	O
1	int
]	O
=	O
0.25	int
*	O
z	array
[	O
1	int
]	O
;	O
tu	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
x	array
[	O
2	int
]	O
;	O
tv	pointer
[	O
2	int
]	O
=	O
0.25	int
*	O
z	array
[	O
2	int
]	O
;	O
Add_Poly	function
(	O
c	pointer
,	O
3	int
,	O
MAT_NOTEX	int
,	O
TEX_WINDOW_ROOF	int
,	O
x	array
,	O
y	array
,	O
z	array
,	O
tu	pointer
,	O
tv	pointer
)	O
;	O
}	O
Create_Occluder	function
(	O
c	pointer
->	O
cent	int
.	O
x	array
+	O
sx	float
+	O
blx	float
,	O
sy	float
,	O
c	pointer
->	O
cent	int
.	O
z	array
+	O
sz	float
+	O
blz	float
,	O
c	pointer
->	O
cent	int
.	O
x	array
+	O
sx	float
+	O
trx	float
,	O
sy	float
+	O
hei	float
,	O
c	pointer
->	O
cent	int
.	O
z	array
+	O
sz	float
+	O
trz	float
)	O
;	O
}	O
static	O
void	O
Generate_Small_Building	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
float	O
sx	float
,	O
sy	float
,	O
sz	float
;	O
float	O
wid	float
,	O
len	float
,	O
hei	float
;	O
float	O
ex	float
,	O
ez	float
;	O
float	O
scale	float
;	O
sx	float
=	O
c	pointer
->	O
nw	int
.	O
x	array
>	O
c	pointer
->	O
sw	int
.	O
x	array
?	O
c	pointer
->	O
nw	int
.	O
x	array
:	O
c	pointer
->	O
sw	int
.	O
x	array
;	O
sy	float
=	O
PAVE_HEIGHT	int
;	O
sz	float
=	O
c	pointer
->	O
sw	int
.	O
z	array
>	O
c	pointer
->	O
se	int
.	O
z	array
?	O
c	pointer
->	O
sw	int
.	O
z	array
:	O
c	pointer
->	O
se	int
.	O
z	array
;	O
ex	float
=	O
c	pointer
->	O
ne	int
.	O
x	array
<	O
c	pointer
->	O
se	int
.	O
x	array
?	O
c	pointer
->	O
ne	int
.	O
x	array
:	O
c	pointer
->	O
se	int
.	O
x	array
;	O
ez	float
=	O
c	pointer
->	O
ne	int
.	O
z	array
<	O
c	pointer
->	O
nw	int
.	O
z	array
?	O
c	pointer
->	O
ne	int
.	O
z	array
:	O
c	pointer
->	O
nw	int
.	O
z	array
;	O
wid	float
=	O
ex	float
-	O
sx	float
;	O
len	float
=	O
ez	float
-	O
sz	float
;	O
hei	float
=	O
c	pointer
->	O
height	float
;	O
scale	float
=	O
wid	float
/	O
(	O
float	O
)	O
(	O
(	O
c	pointer
->	O
maxx	int
-	O
c	pointer
->	O
minx	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
1.5	int
,	O
0.0	int
,	O
scale	float
*	O
1.5	int
,	O
wid	float
-	O
scale	float
*	O
1.5	int
,	O
hei	float
,	O
len	float
-	O
scale	float
*	O
1.5	int
,	O
1.0	int
)	O
;	O
Create_Occluder	function
(	O
c	pointer
->	O
cent	int
.	O
x	array
+	O
sx	float
+	O
scale	float
*	O
1.5	int
,	O
sy	float
,	O
c	pointer
->	O
cent	int
.	O
z	array
+	O
sz	float
+	O
scale	float
*	O
1.5	int
,	O
c	pointer
->	O
cent	int
.	O
x	array
+	O
sx	float
+	O
wid	float
-	O
scale	float
*	O
1.5	int
,	O
sy	float
+	O
hei	float
,	O
c	pointer
->	O
cent	int
.	O
z	array
+	O
sz	float
+	O
len	float
-	O
scale	float
*	O
1.5	int
)	O
;	O
}	O
static	O
void	O
Generate_Parametrised_Building	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
float	O
wid	float
,	O
len	float
,	O
hei	float
;	O
float	O
lump_width	float
;	O
float	O
window_width	float
;	O
float	O
window_height	float
;	O
float	O
window_gap	float
;	O
float	O
window_bar	float
;	O
float	O
first_len_end	float
=	O
0	int
,	O
last_len_end	float
;	O
float	O
first_wid_end	float
=	O
0	int
,	O
last_wid_end	float
;	O
float	O
x	array
,	O
y	array
;	O
float	O
sx	float
,	O
sy	float
,	O
sz	float
;	O
int	O
num	char
,	O
numy	int
;	O
int	O
i	int
,	O
j	int
;	O
float	O
vx	pointer
[	O
4	int
]	O
,	O
vy	pointer
[	O
4	int
]	O
,	O
vz	pointer
[	O
4	int
]	O
;	O
float	O
ex	float
,	O
ez	float
;	O
float	O
scale	float
;	O
sx	float
=	O
c	pointer
->	O
nw	int
.	O
x	array
>	O
c	pointer
->	O
sw	int
.	O
x	array
?	O
c	pointer
->	O
nw	int
.	O
x	array
:	O
c	pointer
->	O
sw	int
.	O
x	array
;	O
sy	float
=	O
PAVE_HEIGHT	int
;	O
sz	float
=	O
c	pointer
->	O
sw	int
.	O
z	array
>	O
c	pointer
->	O
se	int
.	O
z	array
?	O
c	pointer
->	O
sw	int
.	O
z	array
:	O
c	pointer
->	O
se	int
.	O
z	array
;	O
ex	float
=	O
c	pointer
->	O
ne	int
.	O
x	array
<	O
c	pointer
->	O
se	int
.	O
x	array
?	O
c	pointer
->	O
ne	int
.	O
x	array
:	O
c	pointer
->	O
se	int
.	O
x	array
;	O
ez	float
=	O
c	pointer
->	O
ne	int
.	O
z	array
<	O
c	pointer
->	O
nw	int
.	O
z	array
?	O
c	pointer
->	O
ne	int
.	O
z	array
:	O
c	pointer
->	O
nw	int
.	O
z	array
;	O
wid	float
=	O
ez	float
-	O
sz	float
;	O
len	float
=	O
ex	float
-	O
sx	float
;	O
hei	float
=	O
c	pointer
->	O
height	float
;	O
scale	float
=	O
wid	float
/	O
(	O
float	O
)	O
(	O
(	O
c	pointer
->	O
maxx	int
-	O
c	pointer
->	O
minx	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
)	O
;	O
scale	float
=	O
1.0	int
;	O
lump_width	float
=	O
0.5	int
;	O
window_width	float
=	O
1.0	int
;	O
window_height	float
=	O
1.0	int
;	O
window_gap	float
=	O
1.0	int
;	O
window_bar	float
=	O
0.5	int
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
0.0	int
,	O
hei	float
-	O
1.0	int
,	O
0.0	int
,	O
len	float
,	O
hei	float
,	O
scale	float
*	O
0.5	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
0.0	int
,	O
hei	float
-	O
1.0	int
,	O
scale	float
*	O
0.5	int
,	O
scale	float
*	O
0.5	int
,	O
hei	float
,	O
wid	float
-	O
scale	float
*	O
0.5	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
0.0	int
,	O
hei	float
-	O
1.0	int
,	O
wid	float
-	O
scale	float
*	O
0.5	int
,	O
len	float
,	O
hei	float
,	O
wid	float
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
len	float
-	O
scale	float
*	O
0.5	int
,	O
hei	float
-	O
scale	float
*	O
1.0	int
,	O
scale	float
*	O
0.5	int
,	O
len	float
,	O
hei	float
,	O
wid	float
-	O
scale	float
*	O
0.5	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.2	int
,	O
hei	float
-	O
scale	float
*	O
1.7	int
,	O
scale	float
*	O
0.2	int
,	O
len	float
-	O
scale	float
*	O
0.2	int
,	O
hei	float
-	O
scale	float
*	O
1.0	int
,	O
wid	float
-	O
scale	float
*	O
0.2	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.4	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
,	O
scale	float
*	O
0.4	int
,	O
len	float
-	O
scale	float
*	O
0.4	int
,	O
hei	float
-	O
scale	float
*	O
1.7	int
,	O
wid	float
-	O
scale	float
*	O
0.4	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
1.7	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
,	O
scale	float
*	O
0.7	int
,	O
len	float
-	O
scale	float
*	O
1.7	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
scale	float
*	O
window_height	float
,	O
wid	float
-	O
scale	float
*	O
0.7	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.7	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
,	O
scale	float
*	O
1.7	int
,	O
len	float
-	O
scale	float
*	O
0.7	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
scale	float
*	O
window_height	float
,	O
wid	float
-	O
scale	float
*	O
1.7	int
,	O
1.0	int
)	O
;	O
num	char
=	O
(	O
int	O
)	O
(	O
(	O
len	float
-	O
scale	float
*	O
0.8	int
)	O
/	O
(	O
3	int
*	O
lump_width	float
)	O
)	O
;	O
x	array
=	O
scale	float
*	O
0.4	int
+	O
(	O
(	O
len	float
-	O
scale	float
*	O
0.8	int
)	O
-	O
num	char
*	O
3	int
*	O
lump_width	float
)	O
/	O
2.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	char
;	O
i	int
++	O
)	O
{	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
x	array
+	O
lump_width	float
,	O
hei	float
-	O
scale	float
*	O
1.7	int
-	O
lump_width	float
,	O
scale	float
*	O
0.4	int
-	O
lump_width	float
/	O
2.0	int
,	O
x	array
+	O
2.0	int
*	O
lump_width	float
,	O
hei	float
-	O
scale	float
*	O
1.7	int
,	O
wid	float
-	O
scale	float
*	O
0.4	int
+	O
lump_width	float
/	O
2.0	int
,	O
1.0	int
)	O
;	O
x	array
+=	O
3.0	int
*	O
lump_width	float
;	O
}	O
num	char
=	O
(	O
int	O
)	O
(	O
(	O
wid	float
-	O
scale	float
*	O
0.8	int
)	O
/	O
(	O
3	int
*	O
lump_width	float
)	O
)	O
;	O
x	array
=	O
scale	float
*	O
0.4	int
+	O
(	O
(	O
wid	float
-	O
scale	float
*	O
0.8	int
)	O
-	O
num	char
*	O
3	int
*	O
lump_width	float
)	O
/	O
2.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num	char
;	O
i	int
++	O
)	O
{	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.4	int
-	O
lump_width	float
/	O
2.0	int
,	O
hei	float
-	O
scale	float
*	O
1.7	int
-	O
lump_width	float
,	O
x	array
+	O
lump_width	float
,	O
len	float
-	O
scale	float
*	O
0.4	int
+	O
lump_width	float
/	O
2.0	int
,	O
hei	float
-	O
scale	float
*	O
1.7	int
,	O
x	array
+	O
2.0	int
*	O
lump_width	float
,	O
1.0	int
)	O
;	O
x	array
+=	O
3.0	int
*	O
lump_width	float
;	O
}	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
1.6	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
,	O
scale	float
*	O
0.6	int
,	O
len	float
-	O
scale	float
*	O
1.6	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
,	O
wid	float
-	O
scale	float
*	O
0.6	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.6	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
,	O
scale	float
*	O
1.6	int
,	O
len	float
-	O
scale	float
*	O
0.6	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
,	O
wid	float
-	O
scale	float
*	O
1.6	int
,	O
1.0	int
)	O
;	O
num	char
=	O
(	O
int	O
)	O
(	O
(	O
len	float
-	O
scale	float
*	O
3.2	int
)	O
/	O
(	O
window_width	float
+	O
window_gap	float
)	O
)	O
;	O
x	array
=	O
scale	float
*	O
1.6	int
+	O
(	O
(	O
len	float
-	O
scale	float
*	O
3.2	int
)	O
-	O
num	char
*	O
(	O
window_width	float
+	O
window_gap	float
)	O
)	O
/	O
2.0	int
;	O
numy	int
=	O
(	O
int	O
)	O
(	O
(	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
-	O
scale	float
*	O
3.5	int
)	O
/	O
(	O
window_height	float
+	O
window_bar	float
)	O
)	O
;	O
y	array
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
1.65	int
,	O
scale	float
*	O
3.5	int
,	O
scale	float
*	O
0.65	int
,	O
x	array
+	O
window_gap	float
/	O
2.0	int
,	O
hei	float
-	O
2.7	int
-	O
window_gap	float
,	O
wid	float
-	O
scale	float
*	O
0.65	int
,	O
1.0	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
num	char
;	O
i	int
++	O
)	O
{	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
,	O
scale	float
*	O
3.5	int
,	O
scale	float
*	O
0.65	int
,	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
+	O
window_gap	float
,	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
,	O
wid	float
-	O
scale	float
*	O
0.65	int
,	O
1.0	int
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
1	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
2	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
3	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
y	array
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numy	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
1	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
y	array
-=	O
window_height	float
+	O
window_bar	float
;	O
}	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
1	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
i	int
==	O
1	int
)	O
first_len_end	float
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
+	O
window_gap	float
;	O
x	array
+=	O
window_width	float
+	O
window_gap	float
;	O
}	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
,	O
scale	float
*	O
3.5	int
,	O
scale	float
*	O
0.65	int
,	O
len	float
-	O
scale	float
*	O
1.6	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
,	O
wid	float
-	O
scale	float
*	O
0.65	int
,	O
1.0	int
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
1	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
2	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
3	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
y	array
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numy	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
1	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
y	array
-=	O
window_height	float
+	O
window_bar	float
;	O
}	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
1	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
wid	float
-	O
scale	float
*	O
0.8	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
last_len_end	float
=	O
x	array
-	O
window_gap	float
/	O
2.0	int
;	O
y	array
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numy	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_STRUTS	int
,	O
-	O
1	int
,	O
first_len_end	float
-	O
window_gap	float
-	O
window_width	float
,	O
y	array
-	O
window_height	float
-	O
window_bar	float
,	O
scale	float
*	O
0.7	int
,	O
last_len_end	float
+	O
window_gap	float
+	O
window_width	float
,	O
y	array
-	O
window_height	float
,	O
wid	float
-	O
scale	float
*	O
0.7	int
,	O
1.0	int
)	O
;	O
y	array
-=	O
window_height	float
+	O
window_bar	float
;	O
}	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
first_len_end	float
-	O
window_gap	float
-	O
window_width	float
,	O
scale	float
*	O
2.5	int
,	O
scale	float
*	O
0.6	int
,	O
last_len_end	float
+	O
window_gap	float
+	O
window_width	float
,	O
y	array
-	O
window_height	float
,	O
wid	float
-	O
scale	float
*	O
0.6	int
,	O
1.0	int
)	O
;	O
num	char
=	O
(	O
int	O
)	O
(	O
(	O
wid	float
-	O
scale	float
*	O
3.2	int
)	O
/	O
(	O
window_width	float
+	O
window_gap	float
)	O
)	O
;	O
x	array
=	O
scale	float
*	O
1.6	int
+	O
(	O
(	O
wid	float
-	O
scale	float
*	O
3.2	int
)	O
-	O
num	char
*	O
(	O
window_width	float
+	O
window_gap	float
)	O
)	O
/	O
2.0	int
;	O
numy	int
=	O
(	O
int	O
)	O
(	O
(	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
-	O
scale	float
*	O
3.5	int
)	O
/	O
(	O
window_height	float
+	O
window_bar	float
)	O
)	O
;	O
y	array
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.65	int
,	O
scale	float
*	O
3.5	int
,	O
scale	float
*	O
1.65	int
,	O
len	float
-	O
scale	float
*	O
0.65	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
,	O
x	array
+	O
window_gap	float
/	O
2.0	int
,	O
1.0	int
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
num	char
;	O
i	int
++	O
)	O
{	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.65	int
,	O
scale	float
*	O
3.5	int
,	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
,	O
len	float
-	O
scale	float
*	O
0.65	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
,	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
+	O
window_gap	float
,	O
1.0	int
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
2	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
y	array
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numy	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
vx	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
2	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
y	array
-=	O
window_height	float
+	O
window_bar	float
;	O
}	O
vx	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
2	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
i	int
==	O
1	int
)	O
first_wid_end	float
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
+	O
window_gap	float
;	O
x	array
+=	O
window_width	float
+	O
window_gap	float
;	O
}	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.6	int
,	O
scale	float
*	O
3.5	int
,	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
,	O
len	float
-	O
scale	float
*	O
0.6	int
,	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
,	O
wid	float
-	O
scale	float
*	O
1.6	int
,	O
1.0	int
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
2	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
window_gap	float
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
y	array
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numy	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
vx	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
2	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
y	array
-=	O
window_height	float
+	O
window_bar	float
;	O
}	O
vx	pointer
[	O
0	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
2	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
vx	pointer
[	O
0	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
0	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
0	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
1	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
1	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
1	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
+	O
window_width	float
;	O
vx	pointer
[	O
2	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
2	int
]	O
=	O
y	array
;	O
vz	pointer
[	O
2	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
vx	pointer
[	O
3	int
]	O
=	O
len	float
-	O
scale	float
*	O
0.8	int
;	O
vy	pointer
[	O
3	int
]	O
=	O
y	array
-	O
window_height	float
;	O
vz	pointer
[	O
3	int
]	O
=	O
x	array
+	O
window_gap	float
/	O
2.0	int
;	O
Add_Relative_Poly	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
4	int
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
vx	pointer
,	O
vy	pointer
,	O
vz	pointer
,	O
NULL	O
,	O
NULL	O
)	O
;	O
last_wid_end	float
=	O
x	array
-	O
window_gap	float
/	O
2.0	int
;	O
y	array
=	O
hei	float
-	O
scale	float
*	O
2.7	int
-	O
2.0	int
*	O
window_gap	float
-	O
window_height	float
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
numy	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_STRUTS	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.7	int
,	O
y	array
-	O
window_height	float
-	O
window_bar	float
,	O
first_wid_end	float
-	O
window_gap	float
-	O
window_width	float
,	O
len	float
-	O
scale	float
*	O
0.7	int
,	O
y	array
-	O
window_height	float
,	O
last_wid_end	float
+	O
window_gap	float
+	O
window_width	float
,	O
1.0	int
)	O
;	O
y	array
-=	O
window_height	float
+	O
window_bar	float
;	O
}	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.6	int
,	O
scale	float
*	O
2.5	int
,	O
first_wid_end	float
-	O
window_gap	float
-	O
window_width	float
,	O
len	float
-	O
scale	float
*	O
0.6	int
,	O
y	array
-	O
window_height	float
,	O
last_wid_end	float
+	O
window_gap	float
+	O
window_width	float
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
first_len_end	float
+	O
window_gap	float
/	O
2.0	int
,	O
scale	float
*	O
2.5	int
,	O
first_wid_end	float
+	O
window_gap	float
/	O
2.0	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
last_len_end	float
-	O
window_gap	float
/	O
2.0	int
,	O
0.0	int
,	O
0.0	int
,	O
len	float
,	O
scale	float
*	O
2.5	int
,	O
first_wid_end	float
+	O
window_gap	float
/	O
2.0	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
0.0	int
,	O
0.0	int
,	O
last_wid_end	float
-	O
window_gap	float
/	O
2.0	int
,	O
first_len_end	float
+	O
window_gap	float
/	O
2.0	int
,	O
scale	float
*	O
2.5	int
,	O
wid	float
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
last_len_end	float
-	O
window_gap	float
/	O
2.0	int
,	O
0.0	int
,	O
last_wid_end	float
-	O
window_gap	float
/	O
2.0	int
,	O
len	float
,	O
scale	float
*	O
2.5	int
,	O
wid	float
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.65	int
,	O
0.0	int
,	O
scale	float
*	O
0.65	int
,	O
first_len_end	float
+	O
window_width	float
+	O
window_gap	float
,	O
scale	float
*	O
3.5	int
,	O
first_wid_end	float
+	O
window_width	float
+	O
window_gap	float
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
last_len_end	float
-	O
window_width	float
-	O
window_gap	float
,	O
0.0	int
,	O
scale	float
*	O
0.65	int
,	O
len	float
-	O
scale	float
*	O
0.65	int
,	O
scale	float
*	O
3.5	int
,	O
first_wid_end	float
+	O
window_width	float
+	O
window_gap	float
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.65	int
,	O
0.0	int
,	O
last_wid_end	float
-	O
window_width	float
-	O
window_gap	float
,	O
first_len_end	float
+	O
window_width	float
+	O
window_gap	float
,	O
scale	float
*	O
3.5	int
,	O
wid	float
-	O
scale	float
*	O
0.65	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
last_len_end	float
-	O
window_width	float
-	O
window_gap	float
,	O
0.0	int
,	O
last_wid_end	float
-	O
window_width	float
-	O
window_gap	float
,	O
len	float
-	O
scale	float
*	O
0.65	int
,	O
scale	float
*	O
3.5	int
,	O
wid	float
-	O
scale	float
*	O
0.65	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
first_len_end	float
+	O
window_width	float
+	O
window_gap	float
,	O
0.0	int
,	O
scale	float
*	O
0.7	int
,	O
last_len_end	float
-	O
window_width	float
-	O
window_gap	float
,	O
scale	float
*	O
2.5	int
,	O
wid	float
-	O
scale	float
*	O
0.7	int
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_GLASS	int
,	O
-	O
1	int
,	O
scale	float
*	O
0.7	int
,	O
0.0	int
,	O
first_wid_end	float
+	O
window_width	float
+	O
window_gap	float
,	O
len	float
-	O
scale	float
*	O
0.7	int
,	O
scale	float
*	O
2.5	int
,	O
last_wid_end	float
-	O
window_width	float
-	O
window_gap	float
,	O
1.0	int
)	O
;	O
Add_Relative_Lod_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
1.5	int
,	O
PAVE_HEIGHT	int
,	O
scale	float
*	O
1.5	int
,	O
len	float
-	O
scale	float
*	O
1.5	int
,	O
hei	float
,	O
wid	float
-	O
scale	float
*	O
1.5	int
,	O
0.0	int
)	O
;	O
Create_Occluder	function
(	O
c	pointer
->	O
cent	int
.	O
x	array
+	O
sx	float
+	O
scale	float
*	O
1.6	int
,	O
sy	float
,	O
c	pointer
->	O
cent	int
.	O
z	array
+	O
sz	float
+	O
scale	float
*	O
1.6	int
,	O
c	pointer
->	O
cent	int
.	O
x	array
+	O
sx	float
+	O
len	float
-	O
scale	float
*	O
1.6	int
,	O
sy	float
+	O
hei	float
,	O
c	pointer
->	O
cent	int
.	O
z	array
+	O
sz	float
+	O
wid	float
-	O
scale	float
*	O
1.6	int
)	O
;	O
}	O
static	O
void	O
Generate_Skyscraper	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
float	O
sx	float
,	O
sy	float
,	O
sz	float
;	O
float	O
ex	float
,	O
ez	float
;	O
float	O
wid	float
,	O
len	float
,	O
hei	float
;	O
int	O
type	int
;	O
int	O
i	int
;	O
float	O
bw	float
;	O
float	O
scale	float
;	O
if	O
(	O
c	pointer
->	O
maxx	int
-	O
c	pointer
->	O
minx	int
>	O
0	int
||	O
c	pointer
->	O
maxy	int
-	O
c	pointer
->	O
miny	int
>	O
0	int
)	O
Generate_Parametrised_Building	function
(	O
c	pointer
)	O
;	O
else	O
{	O
sx	float
=	O
c	pointer
->	O
nw	int
.	O
x	array
>	O
c	pointer
->	O
sw	int
.	O
x	array
?	O
c	pointer
->	O
nw	int
.	O
x	array
:	O
c	pointer
->	O
sw	int
.	O
x	array
;	O
sy	float
=	O
PAVE_HEIGHT	int
;	O
sz	float
=	O
c	pointer
->	O
sw	int
.	O
z	array
>	O
c	pointer
->	O
se	int
.	O
z	array
?	O
c	pointer
->	O
sw	int
.	O
z	array
:	O
c	pointer
->	O
se	int
.	O
z	array
;	O
ex	float
=	O
c	pointer
->	O
ne	int
.	O
x	array
<	O
c	pointer
->	O
se	int
.	O
x	array
?	O
c	pointer
->	O
ne	int
.	O
x	array
:	O
c	pointer
->	O
se	int
.	O
x	array
;	O
ez	float
=	O
c	pointer
->	O
ne	int
.	O
z	array
<	O
c	pointer
->	O
nw	int
.	O
z	array
?	O
c	pointer
->	O
ne	int
.	O
z	array
:	O
c	pointer
->	O
nw	int
.	O
z	array
;	O
wid	float
=	O
ez	float
-	O
sz	float
;	O
len	float
=	O
ex	float
-	O
sx	float
;	O
hei	float
=	O
c	pointer
->	O
height	float
;	O
scale	float
=	O
len	float
/	O
BLOCK_WIDTH	int
;	O
type	int
=	O
(	O
int	O
)	O
(	O
4	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
0	int
:	O
case	O
1	int
:	O
case	O
2	int
:	O
case	O
3	int
:	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
1.5	int
*	O
scale	float
,	O
PAVE_HEIGHT	int
,	O
1.5	int
*	O
scale	float
,	O
len	float
-	O
1.5	int
*	O
scale	float
,	O
hei	float
,	O
wid	float
-	O
1.5	int
*	O
scale	float
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
3.5	int
*	O
scale	float
,	O
hei	float
,	O
3.5	int
*	O
scale	float
,	O
len	float
-	O
3.5	int
*	O
scale	float
,	O
hei	float
+	O
2.0	int
,	O
wid	float
-	O
3.5	int
*	O
scale	float
,	O
1.0	int
)	O
;	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
1.2	int
*	O
scale	float
,	O
0.0	int
,	O
1.2	int
*	O
scale	float
,	O
len	float
-	O
1.2	int
*	O
scale	float
,	O
4.0	int
,	O
wid	float
-	O
1.2	int
*	O
scale	float
,	O
1.0	int
)	O
;	O
bw	float
=	O
(	O
len	float
-	O
3.0	int
)	O
/	O
15.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
15	int
;	O
i	int
++	O
)	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
1.5	int
*	O
scale	float
+	O
i	int
*	O
bw	float
+	O
bw	float
/	O
4.0	int
,	O
4.0	int
,	O
1.25	int
*	O
scale	float
,	O
1.5	int
*	O
scale	float
+	O
i	int
*	O
bw	float
+	O
bw	float
/	O
4.0	int
+	O
bw	float
/	O
2.0	int
,	O
hei	float
-	O
0.5	int
,	O
wid	float
-	O
1.25	int
*	O
scale	float
,	O
1.0	int
)	O
;	O
bw	float
=	O
(	O
wid	float
-	O
3.0	int
)	O
/	O
15.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
15	int
;	O
i	int
++	O
)	O
Add_Relative_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
1.25	int
*	O
scale	float
,	O
4.0	int
,	O
1.5	int
+	O
i	int
*	O
bw	float
+	O
bw	float
/	O
4.0	int
,	O
len	float
-	O
1.25	int
*	O
scale	float
,	O
hei	float
-	O
0.5	int
,	O
1.5	int
*	O
scale	float
+	O
i	int
*	O
bw	float
+	O
bw	float
/	O
4.0	int
+	O
bw	float
/	O
2.0	int
,	O
1.0	int
)	O
;	O
Create_Occluder	function
(	O
c	pointer
->	O
cent	int
.	O
x	array
+	O
sx	float
+	O
scale	float
*	O
1.5	int
,	O
sy	float
,	O
c	pointer
->	O
cent	int
.	O
z	array
+	O
sz	float
+	O
scale	float
*	O
1.5	int
,	O
c	pointer
->	O
cent	int
.	O
x	array
+	O
sx	float
+	O
len	float
-	O
scale	float
*	O
1.5	int
,	O
sy	float
+	O
hei	float
,	O
c	pointer
->	O
cent	int
.	O
z	array
+	O
sz	float
+	O
wid	float
-	O
scale	float
*	O
1.5	int
)	O
;	O
Add_Relative_Lod_Box	function
(	O
sx	float
,	O
sy	float
,	O
sz	float
,	O
c	pointer
,	O
MAT_CONCRETE	int
,	O
-	O
1	int
,	O
scale	float
*	O
1.5	int
,	O
PAVE_HEIGHT	int
,	O
scale	float
*	O
1.5	int
,	O
len	float
-	O
scale	float
*	O
1.5	int
,	O
hei	float
,	O
wid	float
-	O
scale	float
*	O
1.5	int
,	O
0.0	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
Classify_Building	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
if	O
(	O
c	pointer
->	O
height	float
>	O
20.0	int
)	O
{	O
c	pointer
->	O
type	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
mav_random	function
(	O
)	O
<	O
0.25	int
)	O
c	pointer
->	O
type	int
=	O
5	int
;	O
else	O
{	O
c	pointer
->	O
type	int
=	O
2	int
+	O
(	O
int	O
)	O
(	O
3.0	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
if	O
(	O
c	pointer
->	O
type	int
==	O
4	int
&&	O
c	pointer
->	O
height	float
>	O
6.0	int
)	O
c	pointer
->	O
type	int
=	O
2	int
+	O
(	O
int	O
)	O
(	O
2.0	int
*	O
mav_random	function
(	O
)	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
Find_Cell_BBox	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
Poly	struct
*	O
p	int
;	O
MAV_object	O
*	O
obj	pointer
;	O
MAV_BB	O
bb	int
;	O
MAV_composite	O
*	O
comp	O
;	O
int	O
i	int
;	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
x	array
=	O
10000000.0	int
;	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
y	array
=	O
10000000.0	int
;	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
z	array
=	O
10000000.0	int
;	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
x	array
=	O
-	O
10000000.0	int
;	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
y	array
=	O
-	O
10000000.0	int
;	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
z	array
=	O
-	O
10000000.0	int
;	O
p	int
=	O
c	pointer
->	O
polys	pointer
;	O
while	O
(	O
p	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
p	int
->	O
num	char
;	O
i	int
++	O
)	O
{	O
if	O
(	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
x	array
<	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
x	array
)	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
x	array
=	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
x	array
;	O
if	O
(	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
y	array
<	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
y	array
)	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
y	array
=	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
y	array
;	O
if	O
(	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
z	array
<	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
z	array
)	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
z	array
=	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
z	array
;	O
if	O
(	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
x	array
>	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
x	array
)	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
x	array
=	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
x	array
;	O
if	O
(	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
y	array
>	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
y	array
)	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
y	array
=	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
y	array
;	O
if	O
(	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
z	array
>	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
z	array
)	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
z	array
=	O
p	int
->	O
verts	array
[	O
i	int
]	O
.	O
z	array
;	O
}	O
p	int
=	O
p	int
->	O
next	pointer
;	O
}	O
mav_listPointerReset	function
(	O
c	pointer
->	O
composites	pointer
)	O
;	O
while	O
(	O
mav_listItemNext	function
(	O
c	pointer
->	O
composites	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
obj	pointer
)	O
)	O
{	O
comp	O
=	O
(	O
MAV_composite	O
*	O
)	O
obj	pointer
->	O
the_data	O
;	O
mav_compositeCalcBB	function
(	O
comp	O
)	O
;	O
mav_callbackBBExec	function
(	O
mav_win_current	O
,	O
obj	pointer
,	O
&	O
bb	int
)	O
;	O
if	O
(	O
comp	O
->	O
bb	int
.	O
min	O
.	O
x	array
<	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
x	array
)	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
x	array
=	O
comp	O
->	O
bb	int
.	O
min	O
.	O
x	array
;	O
if	O
(	O
comp	O
->	O
bb	int
.	O
min	O
.	O
y	array
<	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
y	array
)	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
y	array
=	O
comp	O
->	O
bb	int
.	O
min	O
.	O
y	array
;	O
if	O
(	O
comp	O
->	O
bb	int
.	O
min	O
.	O
z	array
<	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
z	array
)	O
c	pointer
->	O
bb	int
.	O
min	O
.	O
z	array
=	O
comp	O
->	O
bb	int
.	O
min	O
.	O
z	array
;	O
if	O
(	O
comp	O
->	O
bb	int
.	O
max	O
.	O
x	array
>	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
x	array
)	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
x	array
=	O
comp	O
->	O
bb	int
.	O
max	O
.	O
x	array
;	O
if	O
(	O
comp	O
->	O
bb	int
.	O
max	O
.	O
y	array
>	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
y	array
)	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
y	array
=	O
comp	O
->	O
bb	int
.	O
max	O
.	O
y	array
;	O
if	O
(	O
comp	O
->	O
bb	int
.	O
max	O
.	O
z	array
>	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
z	array
)	O
c	pointer
->	O
bb	int
.	O
max	O
.	O
z	array
=	O
comp	O
->	O
bb	int
.	O
max	O
.	O
z	array
;	O
}	O
}	O
static	O
void	O
Sort_Cell_Polys	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
Poly	struct
*	O
*	O
polys	pointer
)	O
{	O
Poly	struct
*	O
p	int
,	O
*	O
pnext	pointer
,	O
*	O
plast	pointer
;	O
Poly	struct
*	O
newp	pointer
;	O
int	O
ptr	int
;	O
int	O
current_texture	int
,	O
current_material	int
;	O
int	O
num_polys_left	int
;	O
int	O
num_textured_polys_left	int
;	O
int	O
num_textured_lit_polys_left	int
;	O
p	int
=	O
*	O
polys	pointer
;	O
num_polys_left	int
=	O
0	int
;	O
num_textured_polys_left	int
=	O
0	int
;	O
num_textured_lit_polys_left	int
=	O
0	int
;	O
while	O
(	O
p	int
)	O
{	O
num_polys_left	int
++	O
;	O
if	O
(	O
p	int
->	O
sp	int
.	O
texture	int
>	O
-	O
1	int
)	O
{	O
if	O
(	O
p	int
->	O
sp	int
.	O
material	int
>	O
-	O
1	int
)	O
num_textured_lit_polys_left	int
++	O
;	O
else	O
num_textured_polys_left	int
++	O
;	O
}	O
p	int
->	O
drawn	char
=	O
0	int
;	O
p	int
=	O
p	int
->	O
next	pointer
;	O
}	O
newp	pointer
=	O
mav_malloc	function
(	O
num_polys_left	int
*	O
sizeof	O
(	O
Poly	struct
)	O
)	O
;	O
ptr	int
=	O
0	int
;	O
while	O
(	O
num_polys_left	int
>	O
0	int
)	O
{	O
current_texture	int
=	O
-	O
1	int
;	O
current_material	int
=	O
-	O
1	int
;	O
p	int
=	O
*	O
polys	pointer
;	O
while	O
(	O
p	int
)	O
{	O
if	O
(	O
current_texture	int
==	O
-	O
1	int
&&	O
current_material	int
==	O
-	O
1	int
&&	O
p	int
->	O
drawn	char
==	O
0	int
)	O
{	O
if	O
(	O
(	O
num_textured_polys_left	int
>	O
0	int
&&	O
p	int
->	O
sp	int
.	O
texture	int
>	O
-	O
1	int
)	O
||	O
(	O
num_textured_lit_polys_left	int
>	O
0	int
&&	O
p	int
->	O
sp	int
.	O
texture	int
>	O
-	O
1	int
&&	O
p	int
->	O
sp	int
.	O
material	int
>	O
-	O
1	int
)	O
||	O
num_polys_left	int
>	O
0	int
)	O
{	O
current_texture	int
=	O
p	int
->	O
sp	int
.	O
texture	int
;	O
current_material	int
=	O
p	int
->	O
sp	int
.	O
material	int
;	O
}	O
}	O
if	O
(	O
p	int
->	O
drawn	char
==	O
0	int
&&	O
p	int
->	O
sp	int
.	O
texture	int
==	O
current_texture	int
&&	O
p	int
->	O
sp	int
.	O
material	int
==	O
current_material	int
)	O
{	O
num_polys_left	int
--	O
;	O
if	O
(	O
p	int
->	O
sp	int
.	O
texture	int
>	O
-	O
1	int
)	O
{	O
if	O
(	O
p	int
->	O
sp	int
.	O
material	int
>	O
-	O
1	int
)	O
num_textured_lit_polys_left	int
--	O
;	O
else	O
num_textured_polys_left	int
--	O
;	O
}	O
p	int
->	O
drawn	char
=	O
1	int
;	O
memcpy	function
(	O
(	O
void	O
*	O
)	O
&	O
newp	pointer
[	O
ptr	int
]	O
,	O
(	O
void	O
*	O
)	O
p	int
,	O
sizeof	O
(	O
Poly	struct
)	O
)	O
;	O
newp	pointer
[	O
ptr	int
]	O
.	O
drawn	char
=	O
0	int
;	O
newp	pointer
[	O
ptr	int
]	O
.	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
ptr	int
>	O
0	int
)	O
newp	pointer
[	O
ptr	int
-	O
1	int
]	O
.	O
next	pointer
=	O
&	O
newp	pointer
[	O
ptr	int
]	O
;	O
ptr	int
++	O
;	O
}	O
p	int
=	O
p	int
->	O
next	pointer
;	O
}	O
}	O
p	int
=	O
*	O
polys	pointer
;	O
while	O
(	O
p	int
)	O
{	O
pnext	pointer
=	O
p	int
->	O
next	pointer
;	O
free	function
(	O
p	int
)	O
;	O
p	int
=	O
pnext	pointer
;	O
}	O
*	O
polys	pointer
=	O
&	O
newp	pointer
[	O
0	int
]	O
;	O
p	int
=	O
*	O
polys	pointer
;	O
plast	pointer
=	O
NULL	O
;	O
current_texture	int
=	O
p	int
->	O
sp	int
.	O
texture	int
;	O
current_material	int
=	O
p	int
->	O
sp	int
.	O
material	int
;	O
while	O
(	O
p	int
)	O
{	O
if	O
(	O
p	int
->	O
sp	int
.	O
texture	int
!=	O
current_texture	int
||	O
p	int
->	O
sp	int
.	O
material	int
!=	O
current_material	int
)	O
{	O
if	O
(	O
plast	pointer
)	O
plast	pointer
->	O
drawn	char
=	O
1	int
;	O
current_texture	int
=	O
p	int
->	O
sp	int
.	O
texture	int
;	O
current_material	int
=	O
p	int
->	O
sp	int
.	O
material	int
;	O
}	O
plast	pointer
=	O
p	int
;	O
p	int
=	O
p	int
->	O
next	pointer
;	O
}	O
}	O
static	O
void	O
Add_Waste_Ground	function
(	O
int	O
x	array
,	O
int	O
y	array
)	O
{	O
MAV_cityCell	struct
*	O
c	pointer
;	O
int	O
okay	int
=	O
0	int
;	O
if	O
(	O
x	array
>	O
0	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
y	array
*	O
size	int
+	O
x	array
-	O
1	int
]	O
.	O
type	int
!=	O
-	O
1	int
)	O
okay	int
=	O
1	int
;	O
if	O
(	O
y	array
>	O
0	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
(	O
y	array
-	O
1	int
)	O
*	O
size	int
+	O
x	array
-	O
1	int
]	O
.	O
type	int
!=	O
-	O
1	int
)	O
okay	int
=	O
1	int
;	O
}	O
if	O
(	O
y	array
<	O
size	int
-	O
1	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
(	O
y	array
+	O
1	int
)	O
*	O
size	int
+	O
x	array
-	O
1	int
]	O
.	O
type	int
!=	O
-	O
1	int
)	O
okay	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
x	array
<	O
size	int
-	O
1	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
y	array
*	O
size	int
+	O
x	array
+	O
1	int
]	O
.	O
type	int
!=	O
-	O
1	int
)	O
okay	int
=	O
1	int
;	O
if	O
(	O
y	array
>	O
0	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
(	O
y	array
-	O
1	int
)	O
*	O
size	int
+	O
x	array
+	O
1	int
]	O
.	O
type	int
!=	O
-	O
1	int
)	O
okay	int
=	O
1	int
;	O
}	O
if	O
(	O
y	array
<	O
size	int
-	O
1	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
(	O
y	array
+	O
1	int
)	O
*	O
size	int
+	O
x	array
+	O
1	int
]	O
.	O
type	int
!=	O
-	O
1	int
)	O
okay	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
y	array
>	O
0	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
(	O
y	array
-	O
1	int
)	O
*	O
size	int
+	O
x	array
]	O
.	O
type	int
!=	O
-	O
1	int
)	O
okay	int
=	O
1	int
;	O
}	O
if	O
(	O
y	array
<	O
size	int
-	O
1	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
(	O
y	array
+	O
1	int
)	O
*	O
size	int
+	O
x	array
]	O
.	O
type	int
!=	O
-	O
1	int
)	O
okay	int
=	O
1	int
;	O
}	O
if	O
(	O
okay	int
)	O
{	O
c	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
MAV_cityCell	struct
)	O
)	O
;	O
c	pointer
->	O
id	int
=	O
++	O
num_cells	int
;	O
c	pointer
->	O
building	int
=	O
0	int
;	O
c	pointer
->	O
type	int
=	O
99	int
;	O
c	pointer
->	O
num_polys	int
=	O
c	pointer
->	O
num_lod_polys	int
=	O
0	int
;	O
c	pointer
->	O
polys	pointer
=	O
c	pointer
->	O
lod_polys	pointer
=	O
NULL	O
;	O
c	pointer
->	O
composites	pointer
=	O
mav_listNew	function
(	O
)	O
;	O
c	pointer
->	O
features	pointer
=	O
mav_listNew	function
(	O
)	O
;	O
c	pointer
->	O
minx	int
=	O
c	pointer
->	O
maxx	int
=	O
x	array
;	O
c	pointer
->	O
miny	int
=	O
c	pointer
->	O
maxy	int
=	O
y	array
;	O
c	pointer
->	O
nw	int
=	O
Calc_Grid_Position	function
(	O
x	array
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
y	array
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
sw	int
=	O
Calc_Grid_Position	function
(	O
x	array
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
y	array
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
se	int
=	O
Calc_Grid_Position	function
(	O
(	O
x	array
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
y	array
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
ne	int
=	O
Calc_Grid_Position	function
(	O
(	O
x	array
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
y	array
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
cent	int
.	O
x	array
=	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
/	O
4.0	int
;	O
c	pointer
->	O
cent	int
.	O
y	array
=	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
/	O
4.0	int
;	O
c	pointer
->	O
cent	int
.	O
z	array
=	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
/	O
4.0	int
;	O
c	pointer
->	O
nw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
nw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
nw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
sw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
sw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
sw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
se	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
se	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
se	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
ne	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
ne	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
ne	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
height	float
=	O
0.0	int
;	O
c	pointer
->	O
matrix	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
mav_listItemAdd	function
(	O
list_of_objects	pointer
,	O
(	O
void	O
*	O
)	O
mav_objectNew	function
(	O
mav_class_citycell	pointer
,	O
c	pointer
)	O
)	O
;	O
total_objects	int
++	O
;	O
}	O
}	O
static	O
void	O
Add_Street	function
(	O
int	O
x	array
,	O
int	O
y	array
)	O
{	O
MAV_cityCell	struct
*	O
c	pointer
;	O
c	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
MAV_cityCell	struct
)	O
)	O
;	O
c	pointer
->	O
id	int
=	O
++	O
num_cells	int
;	O
c	pointer
->	O
building	int
=	O
0	int
;	O
c	pointer
->	O
type	int
=	O
0	int
;	O
c	pointer
->	O
num_polys	int
=	O
c	pointer
->	O
num_lod_polys	int
=	O
0	int
;	O
c	pointer
->	O
polys	pointer
=	O
c	pointer
->	O
lod_polys	pointer
=	O
NULL	O
;	O
c	pointer
->	O
composites	pointer
=	O
mav_listNew	function
(	O
)	O
;	O
c	pointer
->	O
features	pointer
=	O
mav_listNew	function
(	O
)	O
;	O
c	pointer
->	O
minx	int
=	O
c	pointer
->	O
maxx	int
=	O
x	array
;	O
c	pointer
->	O
miny	int
=	O
c	pointer
->	O
maxy	int
=	O
y	array
;	O
c	pointer
->	O
nw	int
=	O
Calc_Grid_Position	function
(	O
x	array
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
y	array
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
sw	int
=	O
Calc_Grid_Position	function
(	O
x	array
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
y	array
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
se	int
=	O
Calc_Grid_Position	function
(	O
(	O
x	array
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
y	array
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
ne	int
=	O
Calc_Grid_Position	function
(	O
(	O
x	array
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
y	array
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
cent	int
.	O
x	array
=	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
/	O
4.0	int
;	O
c	pointer
->	O
cent	int
.	O
y	array
=	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
/	O
4.0	int
;	O
c	pointer
->	O
cent	int
.	O
z	array
=	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
/	O
4.0	int
;	O
c	pointer
->	O
nw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
nw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
nw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
sw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
sw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
sw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
se	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
se	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
se	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
ne	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
ne	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
ne	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
height	float
=	O
0.0	int
;	O
c	pointer
->	O
matrix	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
mav_listItemAdd	function
(	O
list_of_objects	pointer
,	O
(	O
void	O
*	O
)	O
mav_objectNew	function
(	O
mav_class_citycell	pointer
,	O
c	pointer
)	O
)	O
;	O
total_objects	int
++	O
;	O
}	O
static	O
void	O
Classify_Street_Cell	function
(	O
MAV_cityCell	struct
*	O
c	pointer
,	O
int	O
x	array
,	O
int	O
y	array
)	O
{	O
c	pointer
->	O
type	int
=	O
0	int
;	O
if	O
(	O
city_scape	pointer
[	O
y	array
*	O
size	int
+	O
x	array
]	O
.	O
type	int
==	O
1	int
)	O
return	O
;	O
if	O
(	O
y	array
<	O
size	int
-	O
1	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
(	O
y	array
+	O
1	int
)	O
*	O
size	int
+	O
x	array
]	O
.	O
type	int
==	O
0	int
)	O
c	pointer
->	O
type	int
+=	O
1	int
;	O
}	O
if	O
(	O
x	array
<	O
size	int
-	O
1	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
y	array
*	O
size	int
+	O
x	array
+	O
1	int
]	O
.	O
type	int
==	O
0	int
)	O
c	pointer
->	O
type	int
+=	O
2	int
;	O
}	O
if	O
(	O
y	array
>	O
0	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
(	O
y	array
-	O
1	int
)	O
*	O
size	int
+	O
x	array
]	O
.	O
type	int
==	O
0	int
)	O
c	pointer
->	O
type	int
+=	O
4	int
;	O
}	O
if	O
(	O
x	array
>	O
0	int
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
y	array
*	O
size	int
+	O
x	array
-	O
1	int
]	O
.	O
type	int
==	O
0	int
)	O
c	pointer
->	O
type	int
+=	O
8	int
;	O
}	O
}	O
static	O
void	O
Add_Street_Signs	function
(	O
MAV_cityCell	struct
*	O
c	pointer
)	O
{	O
return	O
;	O
}	O
static	O
int	O
Add_Building	function
(	O
int	O
sx	float
,	O
int	O
sy	float
,	O
int	O
ex	float
,	O
int	O
ey	int
,	O
int	O
*	O
type	int
)	O
{	O
MAV_cityCell	struct
*	O
c	pointer
;	O
int	O
i	int
,	O
j	int
;	O
c	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
MAV_cityCell	struct
)	O
)	O
;	O
c	pointer
->	O
id	int
=	O
++	O
num_cells	int
;	O
c	pointer
->	O
building	int
=	O
1	int
;	O
c	pointer
->	O
type	int
=	O
0	int
;	O
c	pointer
->	O
num_polys	int
=	O
c	pointer
->	O
num_lod_polys	int
=	O
0	int
;	O
c	pointer
->	O
polys	pointer
=	O
c	pointer
->	O
lod_polys	pointer
=	O
NULL	O
;	O
c	pointer
->	O
composites	pointer
=	O
mav_listNew	function
(	O
)	O
;	O
c	pointer
->	O
features	pointer
=	O
mav_listNew	function
(	O
)	O
;	O
c	pointer
->	O
minx	int
=	O
sx	float
;	O
c	pointer
->	O
miny	int
=	O
sy	float
;	O
c	pointer
->	O
maxx	int
=	O
ex	float
;	O
c	pointer
->	O
maxy	int
=	O
ey	int
;	O
c	pointer
->	O
nw	int
=	O
Calc_Grid_Position	function
(	O
sx	float
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
ey	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
sw	int
=	O
Calc_Grid_Position	function
(	O
sx	float
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
sy	float
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
se	int
=	O
Calc_Grid_Position	function
(	O
(	O
ex	float
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
sy	float
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
ne	int
=	O
Calc_Grid_Position	function
(	O
(	O
ex	float
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
,	O
(	O
ey	int
+	O
1	int
)	O
*	O
BLOCK_WIDTH	int
/	O
(	O
size	int
*	O
BLOCK_WIDTH	int
)	O
)	O
;	O
c	pointer
->	O
cent	int
.	O
x	array
=	O
(	O
c	pointer
->	O
nw	int
.	O
x	array
+	O
c	pointer
->	O
sw	int
.	O
x	array
+	O
c	pointer
->	O
se	int
.	O
x	array
+	O
c	pointer
->	O
ne	int
.	O
x	array
)	O
/	O
4.0	int
;	O
c	pointer
->	O
cent	int
.	O
y	array
=	O
(	O
c	pointer
->	O
nw	int
.	O
y	array
+	O
c	pointer
->	O
sw	int
.	O
y	array
+	O
c	pointer
->	O
se	int
.	O
y	array
+	O
c	pointer
->	O
ne	int
.	O
y	array
)	O
/	O
4.0	int
;	O
c	pointer
->	O
cent	int
.	O
z	array
=	O
(	O
c	pointer
->	O
nw	int
.	O
z	array
+	O
c	pointer
->	O
sw	int
.	O
z	array
+	O
c	pointer
->	O
se	int
.	O
z	array
+	O
c	pointer
->	O
ne	int
.	O
z	array
)	O
/	O
4.0	int
;	O
c	pointer
->	O
nw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
nw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
nw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
sw	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
sw	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
sw	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
se	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
se	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
se	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
ne	int
.	O
x	array
-=	O
c	pointer
->	O
cent	int
.	O
x	array
;	O
c	pointer
->	O
ne	int
.	O
y	array
-=	O
c	pointer
->	O
cent	int
.	O
y	array
;	O
c	pointer
->	O
ne	int
.	O
z	array
-=	O
c	pointer
->	O
cent	int
.	O
z	array
;	O
c	pointer
->	O
height	float
=	O
0.0	int
;	O
for	O
(	O
j	int
=	O
sy	float
;	O
j	int
<=	O
ey	int
;	O
j	int
++	O
)	O
for	O
(	O
i	int
=	O
sx	float
;	O
i	int
<=	O
ex	float
;	O
i	int
++	O
)	O
{	O
if	O
(	O
building_heights	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
>	O
c	pointer
->	O
height	float
)	O
c	pointer
->	O
height	float
=	O
building_heights	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
;	O
}	O
Classify_Building	function
(	O
c	pointer
)	O
;	O
c	pointer
->	O
matrix	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
x	array
,	O
0.0	int
,	O
c	pointer
->	O
cent	int
.	O
z	array
)	O
;	O
mav_listItemAdd	function
(	O
list_of_objects	pointer
,	O
(	O
void	O
*	O
)	O
mav_objectNew	function
(	O
mav_class_citycell	pointer
,	O
c	pointer
)	O
)	O
;	O
total_objects	int
++	O
;	O
*	O
type	int
=	O
c	pointer
->	O
type	int
;	O
return	O
(	O
c	pointer
->	O
id	int
)	O
;	O
}	O
static	O
void	O
Output_Cityscape	function
(	O
void	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
for	O
(	O
j	int
=	O
size	int
-	O
1	int
;	O
j	int
>=	O
0	int
;	O
j	int
--	O
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"%2d: "	pointer
,	O
j	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
type	int
==	O
0	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"S"	pointer
)	O
;	O
else	O
if	O
(	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
type	int
==	O
1	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"B"	pointer
)	O
;	O
else	O
fprintf	function
(	O
stdout	pointer
,	O
"."	pointer
)	O
;	O
}	O
fprintf	function
(	O
stdout	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
}	O
void	O
Build_Cityscape	function
(	O
void	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
n	int
;	O
int	O
x	array
,	O
y	array
;	O
int	O
okay	int
;	O
int	O
startx	int
,	O
starty	int
;	O
int	O
new_starty	int
;	O
int	O
endx	int
,	O
endy	int
;	O
MAV_cityCell	struct
*	O
s	pointer
;	O
float	O
hgt	float
;	O
int	O
id	int
;	O
MAV_object	O
*	O
obj	pointer
;	O
int	O
type	int
;	O
road_width	float
=	O
(	O
BLOCK_WIDTH	int
-	O
2.0	int
*	O
PAVE_WIDTH	int
)	O
/	O
2.0	int
;	O
n	int
=	O
vcb_main	function
(	O
3	int
,	O
500	int
)	O
;	O
size	int
=	O
SPACE_SIZE	int
;	O
Init_Warp_Grid	function
(	O
)	O
;	O
list_of_objects	pointer
=	O
mav_listNew	function
(	O
)	O
;	O
city_scape	pointer
=	O
mav_malloc	function
(	O
size	int
*	O
size	int
*	O
sizeof	O
(	O
Block	struct
)	O
)	O
;	O
building_heights	pointer
=	O
mav_malloc	function
(	O
size	int
*	O
size	int
*	O
sizeof	O
(	O
float	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
size	int
;	O
j	int
++	O
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
{	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
type	int
=	O
-	O
1	int
;	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
id	int
=	O
-	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
n	int
;	O
i	int
++	O
)	O
{	O
city_scape	pointer
[	O
cells	array
[	O
i	int
]	O
[	O
1	int
]	O
*	O
size	int
+	O
cells	array
[	O
i	int
]	O
[	O
0	int
]	O
]	O
.	O
type	int
=	O
0	int
;	O
city_scape	pointer
[	O
cells	array
[	O
i	int
]	O
[	O
3	int
]	O
*	O
size	int
+	O
cells	array
[	O
i	int
]	O
[	O
2	int
]	O
]	O
.	O
type	int
=	O
1	int
;	O
city_scape	pointer
[	O
cells	array
[	O
i	int
]	O
[	O
1	int
]	O
*	O
size	int
+	O
cells	array
[	O
i	int
]	O
[	O
0	int
]	O
]	O
.	O
id	int
=	O
-	O
1	int
;	O
city_scape	pointer
[	O
cells	array
[	O
i	int
]	O
[	O
3	int
]	O
*	O
size	int
+	O
cells	array
[	O
i	int
]	O
[	O
2	int
]	O
]	O
.	O
id	int
=	O
-	O
1	int
;	O
building_heights	pointer
[	O
cells	array
[	O
i	int
]	O
[	O
3	int
]	O
*	O
size	int
+	O
cells	array
[	O
i	int
]	O
[	O
2	int
]	O
]	O
=	O
5.0	int
+	O
pow	function
(	O
(	O
float	O
)	O
(	O
n	int
-	O
i	int
)	O
/	O
(	O
float	O
)	O
(	O
n	int
-	O
1	int
)	O
,	O
3.0	int
)	O
*	O
35.0	int
;	O
}	O
for	O
(	O
y	array
=	O
0	int
;	O
y	array
<	O
size	int
;	O
y	array
++	O
)	O
for	O
(	O
x	array
=	O
0	int
;	O
x	array
<	O
size	int
;	O
x	array
++	O
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
y	array
*	O
size	int
+	O
x	array
]	O
.	O
type	int
==	O
1	int
&&	O
city_scape	pointer
[	O
y	array
*	O
size	int
+	O
x	array
]	O
.	O
id	int
==	O
-	O
1	int
)	O
{	O
startx	int
=	O
endx	int
=	O
x	array
;	O
starty	int
=	O
endy	int
=	O
y	array
;	O
hgt	float
=	O
building_heights	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
;	O
okay	int
=	O
1	int
;	O
while	O
(	O
okay	int
&&	O
city_scape	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
.	O
type	int
==	O
1	int
&&	O
city_scape	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
.	O
id	int
==	O
-	O
1	int
&&	O
(	O
fabs	function
(	O
building_heights	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
-	O
hgt	float
)	O
<=	O
MAX_HEIGHT_DIFF	int
)	O
&&	O
endx	int
-	O
startx	int
<=	O
MAX_BUILDING_LEN	int
)	O
{	O
endx	int
++	O
;	O
if	O
(	O
endx	int
==	O
size	int
||	O
city_scape	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
.	O
type	int
!=	O
1	int
||	O
city_scape	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
.	O
id	int
!=	O
-	O
1	int
||	O
(	O
fabs	function
(	O
building_heights	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
-	O
hgt	float
)	O
>	O
MAX_HEIGHT_DIFF	int
)	O
||	O
endx	int
-	O
startx	int
>	O
MAX_BUILDING_LEN	int
)	O
{	O
endx	int
--	O
;	O
okay	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
endx	int
-	O
startx	int
>=	O
1	int
)	O
{	O
okay	int
=	O
1	int
;	O
for	O
(	O
j	int
=	O
starty	int
;	O
okay	int
&&	O
j	int
<=	O
starty	int
+	O
MAX_BUILDING_LEN	int
;	O
j	int
++	O
)	O
{	O
okay	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
startx	int
;	O
okay	int
&&	O
i	int
<=	O
endx	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
type	int
!=	O
1	int
||	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
id	int
!=	O
-	O
1	int
||	O
(	O
fabs	function
(	O
building_heights	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
-	O
hgt	float
)	O
>	O
MAX_HEIGHT_DIFF	int
)	O
)	O
okay	int
=	O
0	int
;	O
}	O
if	O
(	O
okay	int
)	O
endy	int
=	O
j	int
;	O
if	O
(	O
j	int
==	O
size	int
-	O
1	int
)	O
okay	int
=	O
0	int
;	O
}	O
okay	int
=	O
1	int
;	O
new_starty	int
=	O
starty	int
;	O
for	O
(	O
j	int
=	O
starty	int
;	O
okay	int
&&	O
j	int
>	O
endy	int
-	O
MAX_BUILDING_LEN	int
;	O
j	int
--	O
)	O
{	O
okay	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
startx	int
;	O
okay	int
&&	O
i	int
<=	O
endx	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
type	int
!=	O
1	int
||	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
id	int
!=	O
-	O
1	int
||	O
(	O
fabs	function
(	O
building_heights	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
-	O
hgt	float
)	O
>	O
MAX_HEIGHT_DIFF	int
)	O
)	O
okay	int
=	O
0	int
;	O
}	O
if	O
(	O
okay	int
)	O
new_starty	int
=	O
j	int
;	O
if	O
(	O
endy	int
-	O
new_starty	int
>	O
MAX_BUILDING_LEN	int
||	O
new_starty	int
==	O
0	int
)	O
okay	int
=	O
0	int
;	O
}	O
starty	int
=	O
new_starty	int
;	O
if	O
(	O
endy	int
-	O
starty	int
>=	O
1	int
)	O
{	O
id	int
=	O
Add_Building	function
(	O
startx	int
,	O
starty	int
,	O
endx	int
,	O
endy	int
,	O
&	O
type	int
)	O
;	O
for	O
(	O
j	int
=	O
starty	int
;	O
j	int
<=	O
endy	int
;	O
j	int
++	O
)	O
for	O
(	O
i	int
=	O
startx	int
;	O
i	int
<=	O
endx	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
type	int
!=	O
5	int
)	O
Add_Street	function
(	O
i	int
,	O
j	int
)	O
;	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
id	int
=	O
id	int
;	O
}	O
}	O
}	O
}	O
}	O
okay	int
=	O
1	int
;	O
while	O
(	O
okay	int
)	O
{	O
okay	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
okay	int
==	O
0	int
&&	O
j	int
<	O
size	int
;	O
j	int
++	O
)	O
for	O
(	O
i	int
=	O
0	int
;	O
okay	int
==	O
0	int
&&	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
type	int
==	O
1	int
&&	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
id	int
==	O
-	O
1	int
)	O
okay	int
=	O
1	int
;	O
}	O
if	O
(	O
okay	int
)	O
{	O
startx	int
=	O
endx	int
=	O
i	int
-	O
1	int
;	O
starty	int
=	O
endy	int
=	O
j	int
-	O
1	int
;	O
hgt	float
=	O
building_heights	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
;	O
okay	int
=	O
1	int
;	O
while	O
(	O
okay	int
&&	O
city_scape	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
.	O
type	int
==	O
1	int
&&	O
city_scape	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
.	O
id	int
==	O
-	O
1	int
&&	O
(	O
fabs	function
(	O
building_heights	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
-	O
hgt	float
)	O
<=	O
MAX_HEIGHT_DIFF	int
)	O
&&	O
endx	int
-	O
startx	int
<=	O
MAX_BUILDING_LEN	int
)	O
{	O
endx	int
++	O
;	O
if	O
(	O
endx	int
==	O
size	int
||	O
city_scape	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
.	O
type	int
!=	O
1	int
||	O
city_scape	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
.	O
id	int
!=	O
-	O
1	int
||	O
(	O
fabs	function
(	O
building_heights	pointer
[	O
starty	int
*	O
size	int
+	O
endx	int
]	O
-	O
hgt	float
)	O
>	O
MAX_HEIGHT_DIFF	int
)	O
||	O
endx	int
-	O
startx	int
>	O
MAX_BUILDING_LEN	int
)	O
{	O
endx	int
--	O
;	O
okay	int
=	O
0	int
;	O
}	O
}	O
okay	int
=	O
1	int
;	O
for	O
(	O
j	int
=	O
starty	int
;	O
okay	int
&&	O
j	int
<=	O
starty	int
+	O
MAX_BUILDING_LEN	int
;	O
j	int
++	O
)	O
{	O
okay	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
startx	int
;	O
okay	int
&&	O
i	int
<=	O
endx	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
type	int
!=	O
1	int
||	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
id	int
!=	O
-	O
1	int
||	O
(	O
fabs	function
(	O
building_heights	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
-	O
hgt	float
)	O
>	O
MAX_HEIGHT_DIFF	int
)	O
)	O
okay	int
=	O
0	int
;	O
}	O
if	O
(	O
okay	int
)	O
endy	int
=	O
j	int
;	O
if	O
(	O
j	int
==	O
size	int
-	O
1	int
)	O
okay	int
=	O
0	int
;	O
}	O
id	int
=	O
Add_Building	function
(	O
startx	int
,	O
starty	int
,	O
endx	int
,	O
endy	int
,	O
&	O
type	int
)	O
;	O
for	O
(	O
j	int
=	O
starty	int
;	O
j	int
<=	O
endy	int
;	O
j	int
++	O
)	O
for	O
(	O
i	int
=	O
startx	int
;	O
i	int
<=	O
endx	int
;	O
i	int
++	O
)	O
{	O
city_scape	pointer
[	O
j	int
*	O
size	int
+	O
i	int
]	O
.	O
id	int
=	O
id	int
;	O
if	O
(	O
type	int
!=	O
5	int
)	O
Add_Street	function
(	O
i	int
,	O
j	int
)	O
;	O
}	O
okay	int
=	O
1	int
;	O
}	O
}	O
for	O
(	O
y	array
=	O
0	int
;	O
y	array
<	O
size	int
;	O
y	array
++	O
)	O
for	O
(	O
x	array
=	O
0	int
;	O
x	array
<	O
size	int
;	O
x	array
++	O
)	O
{	O
if	O
(	O
city_scape	pointer
[	O
y	array
*	O
size	int
+	O
x	array
]	O
.	O
type	int
==	O
0	int
)	O
Add_Street	function
(	O
x	array
,	O
y	array
)	O
;	O
else	O
if	O
(	O
city_scape	pointer
[	O
y	array
*	O
size	int
+	O
x	array
]	O
.	O
type	int
==	O
-	O
1	int
)	O
Add_Waste_Ground	function
(	O
x	array
,	O
y	array
)	O
;	O
}	O
Output_Cityscape	function
(	O
)	O
;	O
mav_listPointerReset	function
(	O
list_of_objects	pointer
)	O
;	O
while	O
(	O
mav_listItemNext	function
(	O
list_of_objects	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
obj	pointer
)	O
)	O
{	O
if	O
(	O
obj	pointer
->	O
the_class	O
==	O
mav_class_citycell	pointer
)	O
{	O
s	pointer
=	O
(	O
MAV_cityCell	struct
*	O
)	O
obj	pointer
->	O
the_data	O
;	O
if	O
(	O
s	pointer
->	O
building	int
==	O
0	int
&&	O
s	pointer
->	O
type	int
!=	O
99	int
)	O
Classify_Street_Cell	function
(	O
s	pointer
,	O
s	pointer
->	O
minx	int
,	O
s	pointer
->	O
miny	int
)	O
;	O
}	O
}	O
mav_listPointerReset	function
(	O
list_of_objects	pointer
)	O
;	O
while	O
(	O
mav_listItemNext	function
(	O
list_of_objects	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
obj	pointer
)	O
)	O
{	O
if	O
(	O
obj	pointer
->	O
the_class	O
==	O
mav_class_citycell	pointer
)	O
{	O
s	pointer
=	O
(	O
MAV_cityCell	struct
*	O
)	O
obj	pointer
->	O
the_data	O
;	O
if	O
(	O
s	pointer
->	O
building	int
==	O
0	int
)	O
{	O
Generate_Street_Polys	function
(	O
s	pointer
)	O
;	O
Add_Street_Signs	function
(	O
s	pointer
)	O
;	O
if	O
(	O
bounce_cell	pointer
==	O
NULL	O
)	O
{	O
bounce_cell	pointer
=	O
s	pointer
;	O
fprintf	function
(	O
stdout	pointer
,	O
"bounce_cell= %d\n"	pointer
,	O
s	pointer
->	O
id	int
)	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
s	pointer
->	O
type	int
)	O
{	O
case	O
1	int
:	O
Generate_Skyscraper	function
(	O
s	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
Generate_Textured_Building	function
(	O
s	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
Generate_Textured_Building2	function
(	O
s	pointer
)	O
;	O
break	O
;	O
case	O
4	int
:	O
Generate_Small_Building	function
(	O
s	pointer
)	O
;	O
break	O
;	O
case	O
5	int
:	O
Generate_Park	function
(	O
s	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
Find_Cell_BBox	function
(	O
s	pointer
)	O
;	O
Sort_Cell_Polys	function
(	O
s	pointer
,	O
&	O
s	pointer
->	O
polys	pointer
)	O
;	O
if	O
(	O
s	pointer
->	O
lod_polys	pointer
)	O
Sort_Cell_Polys	function
(	O
s	pointer
,	O
&	O
s	pointer
->	O
lod_polys	pointer
)	O
;	O
}	O
}	O
Generate_Park_Features	function
(	O
)	O
;	O
}	O
