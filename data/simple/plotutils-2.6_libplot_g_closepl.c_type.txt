int	O
_API_closepl	O
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
bool	enum
emit_not_just_the_first_page	enum
=	O
true	int
;	O
bool	enum
retval1	enum
;	O
int	O
retval2	int
=	O
0	int
;	O
if	O
(	O
!	O
_plotter	pointer
->	O
data	pointer
->	O
open	enum
)	O
{	O
_plotter	pointer
->	O
error	pointer
(	O
R___	O
(	O
_plotter	pointer
)	O
"closepl: invalid operation"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
_API_endpath	O
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
previous	pointer
!=	O
NULL	O
)	O
{	O
while	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
previous	pointer
)	O
_API_restorestate	O
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
}	O
retval1	enum
=	O
_plotter	pointer
->	O
end_page	pointer
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_pl_g_delete_first_drawing_state	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
switch	O
(	O
(	O
int	O
)	O
_plotter	pointer
->	O
data	pointer
->	O
output_model	enum
)	O
{	O
case	O
(	O
int	O
)	O
PL_OUTPUT_NONE	int
:	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
_delete_outbuf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
=	O
(	O
plOutbuf	struct
*	O
)	O
NULL	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
PL_OUTPUT_ONE_PAGE	int
:	O
emit_not_just_the_first_page	enum
=	O
false	int
;	O
case	O
(	O
int	O
)	O
PL_OUTPUT_ONE_PAGE_AT_A_TIME	int
:	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
&&	O
(	O
emit_not_just_the_first_page	enum
||	O
_plotter	pointer
->	O
data	pointer
->	O
page_number	int
==	O
1	int
)	O
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
header	pointer
&&	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
header	pointer
->	O
len	long
>	O
0	int
)	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
header	pointer
->	O
base	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
&&	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
len	long
>	O
0	int
)	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
base	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
trailer	pointer
&&	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
trailer	pointer
->	O
len	long
>	O
0	int
)	O
_write_string	function
(	O
_plotter	pointer
->	O
data	pointer
,	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
trailer	pointer
->	O
base	pointer
)	O
;	O
retval2	int
=	O
_API_flushpl	O
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
}	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
header	pointer
)	O
_delete_outbuf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
header	pointer
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
header	pointer
=	O
(	O
plOutbuf	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
trailer	pointer
)	O
_delete_outbuf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
trailer	pointer
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
trailer	pointer
=	O
(	O
plOutbuf	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
_delete_outbuf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
=	O
(	O
plOutbuf	struct
*	O
)	O
NULL	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
PL_OUTPUT_PAGES_ALL_AT_ONCE	int
:	O
break	O
;	O
case	O
(	O
int	O
)	O
PL_OUTPUT_VIA_CUSTOM_ROUTINES	int
:	O
case	O
(	O
int	O
)	O
PL_OUTPUT_VIA_CUSTOM_ROUTINES_IN_REAL_TIME	int
:	O
retval2	int
=	O
_API_flushpl	O
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
break	O
;	O
case	O
(	O
int	O
)	O
PL_OUTPUT_VIA_CUSTOM_ROUTINES_TO_NON_STREAM	int
:	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
_plotter	pointer
->	O
data	pointer
->	O
open	enum
=	O
false	int
;	O
if	O
(	O
retval1	enum
==	O
false	int
||	O
retval2	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
else	O
return	O
0	int
;	O
}	O
bool	enum
_pl_g_end_page	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
return	O
true	int
;	O
}	O
void	O
_pl_g_delete_first_drawing_state	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
free	function
(	O
(	O
char	O
*	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_rule	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_mode	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_mode	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
cap_mode	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
true_font_name	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
font_name	pointer
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_len	int
>	O
0	int
)	O
free	function
(	O
(	O
double	O
*	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
)	O
;	O
free	function
(	O
_plotter	pointer
->	O
drawstate	pointer
)	O
;	O
_plotter	pointer
->	O
drawstate	pointer
=	O
NULL	O
;	O
}	O
