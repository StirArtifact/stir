static	O
void	O
discard_confusing_lines	function
(	O
struct	O
file_data	struct
filevec	array
[	O
]	O
)	O
{	O
int	O
f	int
;	O
lin	long
i	long
;	O
char	O
*	O
discarded	array
[	O
2	int
]	O
;	O
lin	long
*	O
equiv_count	array
[	O
2	int
]	O
;	O
lin	long
*	O
p	pointer
;	O
p	pointer
=	O
xmalloc	function
(	O
(	O
filevec	array
[	O
0	int
]	O
.	O
buffered_lines	long
+	O
filevec	array
[	O
1	int
]	O
.	O
buffered_lines	long
)	O
*	O
(	O
2	int
*	O
sizeof	O
*	O
p	pointer
)	O
)	O
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
{	O
filevec	array
[	O
f	int
]	O
.	O
undiscarded	pointer
=	O
p	pointer
;	O
p	pointer
+=	O
filevec	array
[	O
f	int
]	O
.	O
buffered_lines	long
;	O
filevec	array
[	O
f	int
]	O
.	O
realindexes	pointer
=	O
p	pointer
;	O
p	pointer
+=	O
filevec	array
[	O
f	int
]	O
.	O
buffered_lines	long
;	O
}	O
p	pointer
=	O
zalloc	function
(	O
filevec	array
[	O
0	int
]	O
.	O
equiv_max	long
*	O
(	O
2	int
*	O
sizeof	O
*	O
p	pointer
)	O
)	O
;	O
equiv_count	array
[	O
0	int
]	O
=	O
p	pointer
;	O
equiv_count	array
[	O
1	int
]	O
=	O
p	pointer
+	O
filevec	array
[	O
0	int
]	O
.	O
equiv_max	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
filevec	array
[	O
0	int
]	O
.	O
buffered_lines	long
;	O
++	O
i	long
)	O
++	O
equiv_count	array
[	O
0	int
]	O
[	O
filevec	array
[	O
0	int
]	O
.	O
equivs	pointer
[	O
i	long
]	O
]	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
filevec	array
[	O
1	int
]	O
.	O
buffered_lines	long
;	O
++	O
i	long
)	O
++	O
equiv_count	array
[	O
1	int
]	O
[	O
filevec	array
[	O
1	int
]	O
.	O
equivs	pointer
[	O
i	long
]	O
]	O
;	O
discarded	array
[	O
0	int
]	O
=	O
zalloc	function
(	O
filevec	array
[	O
0	int
]	O
.	O
buffered_lines	long
+	O
filevec	array
[	O
1	int
]	O
.	O
buffered_lines	long
)	O
;	O
discarded	array
[	O
1	int
]	O
=	O
discarded	array
[	O
0	int
]	O
+	O
filevec	array
[	O
0	int
]	O
.	O
buffered_lines	long
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
{	O
size_t	long
end	pointer
=	O
filevec	array
[	O
f	int
]	O
.	O
buffered_lines	long
;	O
char	O
*	O
discards	pointer
=	O
discarded	array
[	O
f	int
]	O
;	O
lin	long
*	O
counts	pointer
=	O
equiv_count	array
[	O
1	int
-	O
f	int
]	O
;	O
lin	long
*	O
equivs	pointer
=	O
filevec	array
[	O
f	int
]	O
.	O
equivs	pointer
;	O
size_t	long
many	long
=	O
5	int
;	O
size_t	long
tem	long
=	O
end	pointer
/	O
64	int
;	O
while	O
(	O
(	O
tem	long
=	O
tem	long
>>	O
2	int
)	O
>	O
0	int
)	O
many	long
*=	O
2	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
end	pointer
;	O
i	long
++	O
)	O
{	O
lin	long
nmatch	long
;	O
if	O
(	O
equivs	pointer
[	O
i	long
]	O
==	O
0	int
)	O
continue	O
;	O
nmatch	long
=	O
counts	pointer
[	O
equivs	pointer
[	O
i	long
]	O
]	O
;	O
if	O
(	O
nmatch	long
==	O
0	int
)	O
discards	pointer
[	O
i	long
]	O
=	O
1	int
;	O
else	O
if	O
(	O
nmatch	long
>	O
many	long
)	O
discards	pointer
[	O
i	long
]	O
=	O
2	int
;	O
}	O
}	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
{	O
lin	long
end	pointer
=	O
filevec	array
[	O
f	int
]	O
.	O
buffered_lines	long
;	O
register	O
char	O
*	O
discards	pointer
=	O
discarded	array
[	O
f	int
]	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
end	pointer
;	O
i	long
++	O
)	O
{	O
if	O
(	O
discards	pointer
[	O
i	long
]	O
==	O
2	int
)	O
discards	pointer
[	O
i	long
]	O
=	O
0	int
;	O
else	O
if	O
(	O
discards	pointer
[	O
i	long
]	O
!=	O
0	int
)	O
{	O
register	O
lin	long
j	long
;	O
lin	long
length	long
;	O
lin	long
provisional	long
=	O
0	int
;	O
for	O
(	O
j	long
=	O
i	long
;	O
j	long
<	O
end	pointer
;	O
j	long
++	O
)	O
{	O
if	O
(	O
discards	pointer
[	O
j	long
]	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
discards	pointer
[	O
j	long
]	O
==	O
2	int
)	O
++	O
provisional	long
;	O
}	O
while	O
(	O
j	long
>	O
i	long
&&	O
discards	pointer
[	O
j	long
-	O
1	int
]	O
==	O
2	int
)	O
discards	pointer
[	O
--	O
j	long
]	O
=	O
0	int
,	O
--	O
provisional	long
;	O
length	long
=	O
j	long
-	O
i	long
;	O
if	O
(	O
provisional	long
*	O
4	int
>	O
length	long
)	O
{	O
while	O
(	O
j	long
>	O
i	long
)	O
if	O
(	O
discards	pointer
[	O
--	O
j	long
]	O
==	O
2	int
)	O
discards	pointer
[	O
j	long
]	O
=	O
0	int
;	O
}	O
else	O
{	O
register	O
lin	long
consec	long
;	O
lin	long
minimum	long
=	O
1	int
;	O
lin	long
tem	long
=	O
length	long
>>	O
2	int
;	O
while	O
(	O
0	int
<	O
(	O
tem	long
>>=	O
2	int
)	O
)	O
minimum	long
<<=	O
1	int
;	O
minimum	long
++	O
;	O
for	O
(	O
j	long
=	O
0	int
,	O
consec	long
=	O
0	int
;	O
j	long
<	O
length	long
;	O
j	long
++	O
)	O
if	O
(	O
discards	pointer
[	O
i	long
+	O
j	long
]	O
!=	O
2	int
)	O
consec	long
=	O
0	int
;	O
else	O
if	O
(	O
minimum	long
==	O
++	O
consec	long
)	O
j	long
-=	O
consec	long
;	O
else	O
if	O
(	O
minimum	long
<	O
consec	long
)	O
discards	pointer
[	O
i	long
+	O
j	long
]	O
=	O
0	int
;	O
for	O
(	O
j	long
=	O
0	int
,	O
consec	long
=	O
0	int
;	O
j	long
<	O
length	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
j	long
>=	O
8	int
&&	O
discards	pointer
[	O
i	long
+	O
j	long
]	O
==	O
1	int
)	O
break	O
;	O
if	O
(	O
discards	pointer
[	O
i	long
+	O
j	long
]	O
==	O
2	int
)	O
consec	long
=	O
0	int
,	O
discards	pointer
[	O
i	long
+	O
j	long
]	O
=	O
0	int
;	O
else	O
if	O
(	O
discards	pointer
[	O
i	long
+	O
j	long
]	O
==	O
0	int
)	O
consec	long
=	O
0	int
;	O
else	O
consec	long
++	O
;	O
if	O
(	O
consec	long
==	O
3	int
)	O
break	O
;	O
}	O
i	long
+=	O
length	long
-	O
1	int
;	O
for	O
(	O
j	long
=	O
0	int
,	O
consec	long
=	O
0	int
;	O
j	long
<	O
length	long
;	O
j	long
++	O
)	O
{	O
if	O
(	O
j	long
>=	O
8	int
&&	O
discards	pointer
[	O
i	long
-	O
j	long
]	O
==	O
1	int
)	O
break	O
;	O
if	O
(	O
discards	pointer
[	O
i	long
-	O
j	long
]	O
==	O
2	int
)	O
consec	long
=	O
0	int
,	O
discards	pointer
[	O
i	long
-	O
j	long
]	O
=	O
0	int
;	O
else	O
if	O
(	O
discards	pointer
[	O
i	long
-	O
j	long
]	O
==	O
0	int
)	O
consec	long
=	O
0	int
;	O
else	O
consec	long
++	O
;	O
if	O
(	O
consec	long
==	O
3	int
)	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
{	O
char	O
*	O
discards	pointer
=	O
discarded	array
[	O
f	int
]	O
;	O
lin	long
end	pointer
=	O
filevec	array
[	O
f	int
]	O
.	O
buffered_lines	long
;	O
lin	long
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
end	pointer
;	O
++	O
i	long
)	O
if	O
(	O
minimal	bool
||	O
discards	pointer
[	O
i	long
]	O
==	O
0	int
)	O
{	O
filevec	array
[	O
f	int
]	O
.	O
undiscarded	pointer
[	O
j	long
]	O
=	O
filevec	array
[	O
f	int
]	O
.	O
equivs	pointer
[	O
i	long
]	O
;	O
filevec	array
[	O
f	int
]	O
.	O
realindexes	pointer
[	O
j	long
++	O
]	O
=	O
i	long
;	O
}	O
else	O
filevec	array
[	O
f	int
]	O
.	O
changed	pointer
[	O
i	long
]	O
=	O
1	int
;	O
filevec	array
[	O
f	int
]	O
.	O
nondiscarded_lines	long
=	O
j	long
;	O
}	O
free	function
(	O
discarded	array
[	O
0	int
]	O
)	O
;	O
free	function
(	O
equiv_count	array
[	O
0	int
]	O
)	O
;	O
}	O
static	O
void	O
shift_boundaries	function
(	O
struct	O
file_data	struct
filevec	array
[	O
]	O
)	O
{	O
int	O
f	int
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
{	O
char	O
*	O
changed	pointer
=	O
filevec	array
[	O
f	int
]	O
.	O
changed	pointer
;	O
char	O
*	O
other_changed	pointer
=	O
filevec	array
[	O
1	int
-	O
f	int
]	O
.	O
changed	pointer
;	O
lin	long
const	O
*	O
equivs	pointer
=	O
filevec	array
[	O
f	int
]	O
.	O
equivs	pointer
;	O
lin	long
i	long
=	O
0	int
;	O
lin	long
j	long
=	O
0	int
;	O
lin	long
i_end	long
=	O
filevec	array
[	O
f	int
]	O
.	O
buffered_lines	long
;	O
while	O
(	O
1	int
)	O
{	O
lin	long
runlength	long
,	O
start	pointer
,	O
corresponding	long
;	O
while	O
(	O
i	long
<	O
i_end	long
&&	O
!	O
changed	pointer
[	O
i	long
]	O
)	O
{	O
while	O
(	O
other_changed	pointer
[	O
j	long
++	O
]	O
)	O
continue	O
;	O
i	long
++	O
;	O
}	O
if	O
(	O
i	long
==	O
i_end	long
)	O
break	O
;	O
start	pointer
=	O
i	long
;	O
while	O
(	O
changed	pointer
[	O
++	O
i	long
]	O
)	O
continue	O
;	O
while	O
(	O
other_changed	pointer
[	O
j	long
]	O
)	O
j	long
++	O
;	O
do	O
{	O
runlength	long
=	O
i	long
-	O
start	pointer
;	O
while	O
(	O
start	pointer
&&	O
equivs	pointer
[	O
start	pointer
-	O
1	int
]	O
==	O
equivs	pointer
[	O
i	long
-	O
1	int
]	O
)	O
{	O
changed	pointer
[	O
--	O
start	pointer
]	O
=	O
1	int
;	O
changed	pointer
[	O
--	O
i	long
]	O
=	O
0	int
;	O
while	O
(	O
changed	pointer
[	O
start	pointer
-	O
1	int
]	O
)	O
start	pointer
--	O
;	O
while	O
(	O
other_changed	pointer
[	O
--	O
j	long
]	O
)	O
continue	O
;	O
}	O
corresponding	long
=	O
other_changed	pointer
[	O
j	long
-	O
1	int
]	O
?	O
i	long
:	O
i_end	long
;	O
while	O
(	O
i	long
!=	O
i_end	long
&&	O
equivs	pointer
[	O
start	pointer
]	O
==	O
equivs	pointer
[	O
i	long
]	O
)	O
{	O
changed	pointer
[	O
start	pointer
++	O
]	O
=	O
0	int
;	O
changed	pointer
[	O
i	long
++	O
]	O
=	O
1	int
;	O
while	O
(	O
changed	pointer
[	O
i	long
]	O
)	O
i	long
++	O
;	O
while	O
(	O
other_changed	pointer
[	O
++	O
j	long
]	O
)	O
corresponding	long
=	O
i	long
;	O
}	O
}	O
while	O
(	O
runlength	long
!=	O
i	long
-	O
start	pointer
)	O
;	O
while	O
(	O
corresponding	long
<	O
i	long
)	O
{	O
changed	pointer
[	O
--	O
start	pointer
]	O
=	O
1	int
;	O
changed	pointer
[	O
--	O
i	long
]	O
=	O
0	int
;	O
while	O
(	O
other_changed	pointer
[	O
--	O
j	long
]	O
)	O
continue	O
;	O
}	O
}	O
}	O
}	O
static	O
struct	O
change	struct
*	O
add_change	function
(	O
lin	long
line0	long
,	O
lin	long
line1	long
,	O
lin	long
deleted	long
,	O
lin	long
inserted	long
,	O
struct	O
change	struct
*	O
old	pointer
)	O
{	O
struct	O
change	struct
*	O
new	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
new	pointer
)	O
;	O
new	pointer
->	O
line0	long
=	O
line0	long
;	O
new	pointer
->	O
line1	long
=	O
line1	long
;	O
new	pointer
->	O
inserted	long
=	O
inserted	long
;	O
new	pointer
->	O
deleted	long
=	O
deleted	long
;	O
new	pointer
->	O
link	function
=	O
old	pointer
;	O
return	O
new	pointer
;	O
}	O
static	O
struct	O
change	struct
*	O
build_reverse_script	function
(	O
struct	O
file_data	struct
const	O
filevec	array
[	O
]	O
)	O
{	O
struct	O
change	struct
*	O
script	pointer
=	O
0	int
;	O
char	O
*	O
changed0	pointer
=	O
filevec	array
[	O
0	int
]	O
.	O
changed	pointer
;	O
char	O
*	O
changed1	pointer
=	O
filevec	array
[	O
1	int
]	O
.	O
changed	pointer
;	O
lin	long
len0	long
=	O
filevec	array
[	O
0	int
]	O
.	O
buffered_lines	long
;	O
lin	long
len1	long
=	O
filevec	array
[	O
1	int
]	O
.	O
buffered_lines	long
;	O
lin	long
i0	long
=	O
0	int
,	O
i1	long
=	O
0	int
;	O
while	O
(	O
i0	long
<	O
len0	long
||	O
i1	long
<	O
len1	long
)	O
{	O
if	O
(	O
changed0	pointer
[	O
i0	long
]	O
|	O
changed1	pointer
[	O
i1	long
]	O
)	O
{	O
lin	long
line0	long
=	O
i0	long
,	O
line1	long
=	O
i1	long
;	O
while	O
(	O
changed0	pointer
[	O
i0	long
]	O
)	O
++	O
i0	long
;	O
while	O
(	O
changed1	pointer
[	O
i1	long
]	O
)	O
++	O
i1	long
;	O
script	pointer
=	O
add_change	function
(	O
line0	long
,	O
line1	long
,	O
i0	long
-	O
line0	long
,	O
i1	long
-	O
line1	long
,	O
script	pointer
)	O
;	O
}	O
i0	long
++	O
,	O
i1	long
++	O
;	O
}	O
return	O
script	pointer
;	O
}	O
static	O
struct	O
change	struct
*	O
build_script	function
(	O
struct	O
file_data	struct
const	O
filevec	array
[	O
]	O
)	O
{	O
struct	O
change	struct
*	O
script	pointer
=	O
0	int
;	O
char	O
*	O
changed0	pointer
=	O
filevec	array
[	O
0	int
]	O
.	O
changed	pointer
;	O
char	O
*	O
changed1	pointer
=	O
filevec	array
[	O
1	int
]	O
.	O
changed	pointer
;	O
lin	long
i0	long
=	O
filevec	array
[	O
0	int
]	O
.	O
buffered_lines	long
,	O
i1	long
=	O
filevec	array
[	O
1	int
]	O
.	O
buffered_lines	long
;	O
while	O
(	O
i0	long
>=	O
0	int
||	O
i1	long
>=	O
0	int
)	O
{	O
if	O
(	O
changed0	pointer
[	O
i0	long
-	O
1	int
]	O
|	O
changed1	pointer
[	O
i1	long
-	O
1	int
]	O
)	O
{	O
lin	long
line0	long
=	O
i0	long
,	O
line1	long
=	O
i1	long
;	O
while	O
(	O
changed0	pointer
[	O
i0	long
-	O
1	int
]	O
)	O
--	O
i0	long
;	O
while	O
(	O
changed1	pointer
[	O
i1	long
-	O
1	int
]	O
)	O
--	O
i1	long
;	O
script	pointer
=	O
add_change	function
(	O
i0	long
,	O
i1	long
,	O
line0	long
-	O
i0	long
,	O
line1	long
-	O
i1	long
,	O
script	pointer
)	O
;	O
}	O
i0	long
--	O
,	O
i1	long
--	O
;	O
}	O
return	O
script	pointer
;	O
}	O
static	O
int	O
briefly_report	function
(	O
int	O
changes	enum
,	O
struct	O
file_data	struct
const	O
filevec	array
[	O
]	O
)	O
{	O
if	O
(	O
changes	enum
)	O
{	O
char	O
const	O
*	O
label0	pointer
=	O
file_label	array
[	O
0	int
]	O
?	O
file_label	array
[	O
0	int
]	O
:	O
filevec	array
[	O
0	int
]	O
.	O
name	pointer
;	O
char	O
const	O
*	O
label1	pointer
=	O
file_label	array
[	O
1	int
]	O
?	O
file_label	array
[	O
1	int
]	O
:	O
filevec	array
[	O
1	int
]	O
.	O
name	pointer
;	O
if	O
(	O
brief	bool
)	O
message	function
(	O
"Files %s and %s differ\n"	pointer
,	O
label0	pointer
,	O
label1	pointer
)	O
;	O
else	O
{	O
message	function
(	O
"Binary files %s and %s differ\n"	pointer
,	O
label0	pointer
,	O
label1	pointer
)	O
;	O
changes	enum
=	O
2	int
;	O
}	O
}	O
return	O
changes	enum
;	O
}	O
int	O
diff_2_files	function
(	O
struct	O
comparison	struct
*	O
cmp	pointer
)	O
{	O
int	O
f	int
;	O
struct	O
change	struct
*	O
e	pointer
,	O
*	O
p	pointer
;	O
struct	O
change	struct
*	O
script	pointer
;	O
int	O
changes	enum
;	O
if	O
(	O
read_files	function
(	O
cmp	pointer
->	O
file	array
,	O
files_can_be_treated_as_binary	bool
)	O
)	O
{	O
if	O
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
stat	struct
.	O
st_size	long
!=	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
stat	struct
.	O
st_size	long
&&	O
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
desc	int
<	O
0	int
||	O
S_ISREG	O
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
stat	struct
.	O
st_mode	int
)	O
)	O
&&	O
(	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
desc	int
<	O
0	int
||	O
S_ISREG	O
(	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
stat	struct
.	O
st_mode	int
)	O
)	O
)	O
changes	enum
=	O
1	int
;	O
else	O
if	O
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
desc	int
==	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
desc	int
)	O
changes	enum
=	O
0	int
;	O
else	O
{	O
size_t	long
lcm_max	long
=	O
PTRDIFF_MAX	O
-	O
1	int
;	O
size_t	long
buffer_size	long
=	O
buffer_lcm	function
(	O
sizeof	O
(	O
word	O
)	O
,	O
buffer_lcm	function
(	O
STAT_BLOCKSIZE	O
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
stat	struct
)	O
,	O
STAT_BLOCKSIZE	O
(	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
stat	struct
)	O
,	O
lcm_max	long
)	O
,	O
lcm_max	long
)	O
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
cmp	pointer
->	O
file	array
[	O
f	int
]	O
.	O
buffer	pointer
=	O
xrealloc	function
(	O
cmp	pointer
->	O
file	array
[	O
f	int
]	O
.	O
buffer	pointer
,	O
buffer_size	long
)	O
;	O
for	O
(	O
;	O
;	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
buffered	long
=	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
buffered	long
=	O
0	int
)	O
{	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
if	O
(	O
0	int
<=	O
cmp	pointer
->	O
file	array
[	O
f	int
]	O
.	O
desc	int
)	O
file_block_read	function
(	O
&	O
cmp	pointer
->	O
file	array
[	O
f	int
]	O
,	O
buffer_size	long
-	O
cmp	pointer
->	O
file	array
[	O
f	int
]	O
.	O
buffered	long
)	O
;	O
if	O
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
buffered	long
!=	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
buffered	long
||	O
memcmp	function
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
buffer	pointer
,	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
buffer	pointer
,	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
buffered	long
)	O
)	O
{	O
changes	enum
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
buffered	long
!=	O
buffer_size	long
)	O
{	O
changes	enum
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
changes	enum
=	O
briefly_report	function
(	O
changes	enum
,	O
cmp	pointer
->	O
file	array
)	O
;	O
}	O
else	O
{	O
struct	O
context	long
ctxt	pointer
;	O
lin	long
diags	long
;	O
lin	long
too_expensive	long
;	O
size_t	long
s	long
=	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
buffered_lines	long
+	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
buffered_lines	long
+	O
4	int
;	O
char	O
*	O
flag_space	pointer
=	O
zalloc	function
(	O
s	long
)	O
;	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
changed	pointer
=	O
flag_space	pointer
+	O
1	int
;	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
changed	pointer
=	O
flag_space	pointer
+	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
buffered_lines	long
+	O
3	int
;	O
discard_confusing_lines	function
(	O
cmp	pointer
->	O
file	array
)	O
;	O
ctxt	pointer
.	O
xvec	pointer
=	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
undiscarded	pointer
;	O
ctxt	pointer
.	O
yvec	pointer
=	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
undiscarded	pointer
;	O
diags	long
=	O
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
nondiscarded_lines	long
+	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
nondiscarded_lines	long
+	O
3	int
)	O
;	O
ctxt	pointer
.	O
fdiag	pointer
=	O
xmalloc	function
(	O
diags	long
*	O
(	O
2	int
*	O
sizeof	O
*	O
ctxt	pointer
.	O
fdiag	pointer
)	O
)	O
;	O
ctxt	pointer
.	O
bdiag	pointer
=	O
ctxt	pointer
.	O
fdiag	pointer
+	O
diags	long
;	O
ctxt	pointer
.	O
fdiag	pointer
+=	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
nondiscarded_lines	long
+	O
1	int
;	O
ctxt	pointer
.	O
bdiag	pointer
+=	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
nondiscarded_lines	long
+	O
1	int
;	O
ctxt	pointer
.	O
heuristic	bool
=	O
speed_large_files	bool
;	O
too_expensive	long
=	O
1	int
;	O
for	O
(	O
;	O
diags	long
!=	O
0	int
;	O
diags	long
>>=	O
2	int
)	O
too_expensive	long
<<=	O
1	int
;	O
ctxt	pointer
.	O
too_expensive	long
=	O
MAX	O
(	O
256	int
,	O
too_expensive	long
)	O
;	O
files	array
[	O
0	int
]	O
=	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
;	O
files	array
[	O
1	int
]	O
=	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
;	O
compareseq	function
(	O
0	int
,	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
nondiscarded_lines	long
,	O
0	int
,	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
nondiscarded_lines	long
,	O
minimal	bool
,	O
&	O
ctxt	pointer
)	O
;	O
free	function
(	O
ctxt	pointer
.	O
fdiag	pointer
-	O
(	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
nondiscarded_lines	long
+	O
1	int
)	O
)	O
;	O
shift_boundaries	function
(	O
cmp	pointer
->	O
file	array
)	O
;	O
if	O
(	O
output_style	enum
==	O
OUTPUT_ED	int
)	O
script	pointer
=	O
build_reverse_script	function
(	O
cmp	pointer
->	O
file	array
)	O
;	O
else	O
script	pointer
=	O
build_script	function
(	O
cmp	pointer
->	O
file	array
)	O
;	O
if	O
(	O
ignore_blank_lines	bool
||	O
ignore_regexp	struct
.	O
fastmap	pointer
)	O
{	O
struct	O
change	struct
*	O
next	pointer
=	O
script	pointer
;	O
changes	enum
=	O
0	int
;	O
while	O
(	O
next	pointer
&&	O
changes	enum
==	O
0	int
)	O
{	O
struct	O
change	struct
*	O
this	pointer
,	O
*	O
end	pointer
;	O
lin	long
first0	long
,	O
last0	long
,	O
first1	long
,	O
last1	long
;	O
this	pointer
=	O
next	pointer
;	O
end	pointer
=	O
find_change	function
(	O
next	pointer
)	O
;	O
next	pointer
=	O
end	pointer
->	O
link	function
;	O
end	pointer
->	O
link	function
=	O
0	int
;	O
if	O
(	O
analyze_hunk	function
(	O
this	pointer
,	O
&	O
first0	long
,	O
&	O
last0	long
,	O
&	O
first1	long
,	O
&	O
last1	long
)	O
)	O
changes	enum
=	O
1	int
;	O
end	pointer
->	O
link	function
=	O
next	pointer
;	O
}	O
}	O
else	O
changes	enum
=	O
(	O
script	pointer
!=	O
0	int
)	O
;	O
if	O
(	O
brief	bool
)	O
changes	enum
=	O
briefly_report	function
(	O
changes	enum
,	O
cmp	pointer
->	O
file	array
)	O
;	O
else	O
{	O
if	O
(	O
changes	enum
||	O
!	O
no_diff_means_no_output	bool
)	O
{	O
setup_output	function
(	O
file_label	array
[	O
0	int
]	O
?	O
file_label	array
[	O
0	int
]	O
:	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
name	pointer
,	O
file_label	array
[	O
1	int
]	O
?	O
file_label	array
[	O
1	int
]	O
:	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
name	pointer
,	O
cmp	pointer
->	O
parent	pointer
!=	O
0	int
)	O
;	O
switch	O
(	O
output_style	enum
)	O
{	O
case	O
OUTPUT_CONTEXT	int
:	O
print_context_script	function
(	O
script	pointer
,	O
false	int
)	O
;	O
break	O
;	O
case	O
OUTPUT_UNIFIED	int
:	O
print_context_script	function
(	O
script	pointer
,	O
true	int
)	O
;	O
break	O
;	O
case	O
OUTPUT_ED	int
:	O
print_ed_script	function
(	O
script	pointer
)	O
;	O
break	O
;	O
case	O
OUTPUT_FORWARD_ED	int
:	O
pr_forward_ed_script	function
(	O
script	pointer
)	O
;	O
break	O
;	O
case	O
OUTPUT_RCS	int
:	O
print_rcs_script	function
(	O
script	pointer
)	O
;	O
break	O
;	O
case	O
OUTPUT_NORMAL	int
:	O
print_normal_script	function
(	O
script	pointer
)	O
;	O
break	O
;	O
case	O
OUTPUT_IFDEF	int
:	O
print_ifdef_script	function
(	O
script	pointer
)	O
;	O
break	O
;	O
case	O
OUTPUT_SDIFF	int
:	O
print_sdiff_script	function
(	O
script	pointer
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
finish_output	function
(	O
)	O
;	O
}	O
}	O
free	function
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
undiscarded	pointer
)	O
;	O
free	function
(	O
flag_space	pointer
)	O
;	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
f	int
++	O
)	O
{	O
free	function
(	O
cmp	pointer
->	O
file	array
[	O
f	int
]	O
.	O
equivs	pointer
)	O
;	O
free	function
(	O
cmp	pointer
->	O
file	array
[	O
f	int
]	O
.	O
linbuf	pointer
+	O
cmp	pointer
->	O
file	array
[	O
f	int
]	O
.	O
linbuf_base	long
)	O
;	O
}	O
for	O
(	O
e	pointer
=	O
script	pointer
;	O
e	pointer
;	O
e	pointer
=	O
p	pointer
)	O
{	O
p	pointer
=	O
e	pointer
->	O
link	function
;	O
free	function
(	O
e	pointer
)	O
;	O
}	O
if	O
(	O
!	O
ROBUST_OUTPUT_STYLE	O
(	O
output_style	enum
)	O
)	O
for	O
(	O
f	int
=	O
0	int
;	O
f	int
<	O
2	int
;	O
++	O
f	int
)	O
if	O
(	O
cmp	pointer
->	O
file	array
[	O
f	int
]	O
.	O
missing_newline	bool
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
"%s: %s\n"	pointer
,	O
file_label	array
[	O
f	int
]	O
?	O
file_label	array
[	O
f	int
]	O
:	O
cmp	pointer
->	O
file	array
[	O
f	int
]	O
.	O
name	pointer
,	O
_	O
(	O
"No newline at end of file"	pointer
)	O
)	O
;	O
changes	enum
=	O
2	int
;	O
}	O
}	O
if	O
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
buffer	pointer
!=	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
buffer	pointer
)	O
free	function
(	O
cmp	pointer
->	O
file	array
[	O
0	int
]	O
.	O
buffer	pointer
)	O
;	O
free	function
(	O
cmp	pointer
->	O
file	array
[	O
1	int
]	O
.	O
buffer	pointer
)	O
;	O
return	O
changes	enum
;	O
}	O
