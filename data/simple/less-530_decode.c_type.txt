extern	O
int	O
erase_char	int
,	O
erase2_char	int
,	O
kill_char	int
;	O
extern	O
int	O
secure	int
;	O
static	O
unsigned	O
char	O
cmdtable	array
[	O
]	O
=	O
{	O
'\r'	O
,	O
0	int
,	O
A_F_LINE	int
,	O
'\n'	O
,	O
0	int
,	O
A_F_LINE	int
,	O
'e'	O
,	O
0	int
,	O
A_F_LINE	int
,	O
'j'	O
,	O
0	int
,	O
A_F_LINE	int
,	O
SK	O
(	O
SK_DOWN_ARROW	int
)	O
,	O
0	int
,	O
A_F_LINE	int
,	O
CONTROL	O
(	O
'E'	O
)	O
,	O
0	int
,	O
A_F_LINE	int
,	O
CONTROL	O
(	O
'N'	O
)	O
,	O
0	int
,	O
A_F_LINE	int
,	O
'k'	O
,	O
0	int
,	O
A_B_LINE	int
,	O
'y'	O
,	O
0	int
,	O
A_B_LINE	int
,	O
CONTROL	O
(	O
'Y'	O
)	O
,	O
0	int
,	O
A_B_LINE	int
,	O
SK	O
(	O
SK_CONTROL_K	int
)	O
,	O
0	int
,	O
A_B_LINE	int
,	O
CONTROL	O
(	O
'P'	O
)	O
,	O
0	int
,	O
A_B_LINE	int
,	O
SK	O
(	O
SK_UP_ARROW	int
)	O
,	O
0	int
,	O
A_B_LINE	int
,	O
'J'	O
,	O
0	int
,	O
A_FF_LINE	int
,	O
'K'	O
,	O
0	int
,	O
A_BF_LINE	int
,	O
'Y'	O
,	O
0	int
,	O
A_BF_LINE	int
,	O
'd'	O
,	O
0	int
,	O
A_F_SCROLL	int
,	O
CONTROL	O
(	O
'D'	O
)	O
,	O
0	int
,	O
A_F_SCROLL	int
,	O
'u'	O
,	O
0	int
,	O
A_B_SCROLL	int
,	O
CONTROL	O
(	O
'U'	O
)	O
,	O
0	int
,	O
A_B_SCROLL	int
,	O
' '	O
,	O
0	int
,	O
A_F_SCREEN	int
,	O
'f'	O
,	O
0	int
,	O
A_F_SCREEN	int
,	O
CONTROL	O
(	O
'F'	O
)	O
,	O
0	int
,	O
A_F_SCREEN	int
,	O
CONTROL	O
(	O
'V'	O
)	O
,	O
0	int
,	O
A_F_SCREEN	int
,	O
SK	O
(	O
SK_PAGE_DOWN	int
)	O
,	O
0	int
,	O
A_F_SCREEN	int
,	O
'b'	O
,	O
0	int
,	O
A_B_SCREEN	int
,	O
CONTROL	O
(	O
'B'	O
)	O
,	O
0	int
,	O
A_B_SCREEN	int
,	O
ESC	O
,	O
'v'	O
,	O
0	int
,	O
A_B_SCREEN	int
,	O
SK	O
(	O
SK_PAGE_UP	int
)	O
,	O
0	int
,	O
A_B_SCREEN	int
,	O
'z'	O
,	O
0	int
,	O
A_F_WINDOW	int
,	O
'w'	O
,	O
0	int
,	O
A_B_WINDOW	int
,	O
ESC	O
,	O
' '	O
,	O
0	int
,	O
A_FF_SCREEN	int
,	O
'F'	O
,	O
0	int
,	O
A_F_FOREVER	int
,	O
ESC	O
,	O
'F'	O
,	O
0	int
,	O
A_F_UNTIL_HILITE	int
,	O
'R'	O
,	O
0	int
,	O
A_FREPAINT	int
,	O
'r'	O
,	O
0	int
,	O
A_REPAINT	int
,	O
CONTROL	O
(	O
'R'	O
)	O
,	O
0	int
,	O
A_REPAINT	int
,	O
CONTROL	O
(	O
'L'	O
)	O
,	O
0	int
,	O
A_REPAINT	int
,	O
ESC	O
,	O
'u'	O
,	O
0	int
,	O
A_UNDO_SEARCH	int
,	O
'g'	O
,	O
0	int
,	O
A_GOLINE	int
,	O
SK	O
(	O
SK_HOME	int
)	O
,	O
0	int
,	O
A_GOLINE	int
,	O
'<'	O
,	O
0	int
,	O
A_GOLINE	int
,	O
ESC	O
,	O
'<'	O
,	O
0	int
,	O
A_GOLINE	int
,	O
'p'	O
,	O
0	int
,	O
A_PERCENT	int
,	O
'%'	O
,	O
0	int
,	O
A_PERCENT	int
,	O
ESC	O
,	O
'['	O
,	O
0	int
,	O
A_LSHIFT	int
,	O
ESC	O
,	O
']'	O
,	O
0	int
,	O
A_RSHIFT	int
,	O
ESC	O
,	O
'('	O
,	O
0	int
,	O
A_LSHIFT	int
,	O
ESC	O
,	O
')'	O
,	O
0	int
,	O
A_RSHIFT	int
,	O
ESC	O
,	O
'{'	O
,	O
0	int
,	O
A_LLSHIFT	int
,	O
ESC	O
,	O
'}'	O
,	O
0	int
,	O
A_RRSHIFT	int
,	O
SK	O
(	O
SK_RIGHT_ARROW	int
)	O
,	O
0	int
,	O
A_RSHIFT	int
,	O
SK	O
(	O
SK_LEFT_ARROW	int
)	O
,	O
0	int
,	O
A_LSHIFT	int
,	O
SK	O
(	O
SK_CTL_RIGHT_ARROW	int
)	O
,	O
0	int
,	O
A_RRSHIFT	int
,	O
SK	O
(	O
SK_CTL_LEFT_ARROW	int
)	O
,	O
0	int
,	O
A_LLSHIFT	int
,	O
'{'	O
,	O
0	int
,	O
A_F_BRACKET	int
|	O
A_EXTRA	int
,	O
'{'	O
,	O
'}'	O
,	O
0	int
,	O
'}'	O
,	O
0	int
,	O
A_B_BRACKET	int
|	O
A_EXTRA	int
,	O
'{'	O
,	O
'}'	O
,	O
0	int
,	O
'('	O
,	O
0	int
,	O
A_F_BRACKET	int
|	O
A_EXTRA	int
,	O
'('	O
,	O
')'	O
,	O
0	int
,	O
')'	O
,	O
0	int
,	O
A_B_BRACKET	int
|	O
A_EXTRA	int
,	O
'('	O
,	O
')'	O
,	O
0	int
,	O
'['	O
,	O
0	int
,	O
A_F_BRACKET	int
|	O
A_EXTRA	int
,	O
'['	O
,	O
']'	O
,	O
0	int
,	O
']'	O
,	O
0	int
,	O
A_B_BRACKET	int
|	O
A_EXTRA	int
,	O
'['	O
,	O
']'	O
,	O
0	int
,	O
ESC	O
,	O
CONTROL	O
(	O
'F'	O
)	O
,	O
0	int
,	O
A_F_BRACKET	int
,	O
ESC	O
,	O
CONTROL	O
(	O
'B'	O
)	O
,	O
0	int
,	O
A_B_BRACKET	int
,	O
'G'	O
,	O
0	int
,	O
A_GOEND	int
,	O
ESC	O
,	O
'G'	O
,	O
0	int
,	O
A_GOEND_BUF	int
,	O
ESC	O
,	O
'>'	O
,	O
0	int
,	O
A_GOEND	int
,	O
'>'	O
,	O
0	int
,	O
A_GOEND	int
,	O
SK	O
(	O
SK_END	int
)	O
,	O
0	int
,	O
A_GOEND	int
,	O
'P'	O
,	O
0	int
,	O
A_GOPOS	int
,	O
'0'	O
,	O
0	int
,	O
A_DIGIT	int
,	O
'1'	O
,	O
0	int
,	O
A_DIGIT	int
,	O
'2'	O
,	O
0	int
,	O
A_DIGIT	int
,	O
'3'	O
,	O
0	int
,	O
A_DIGIT	int
,	O
'4'	O
,	O
0	int
,	O
A_DIGIT	int
,	O
'5'	O
,	O
0	int
,	O
A_DIGIT	int
,	O
'6'	O
,	O
0	int
,	O
A_DIGIT	int
,	O
'7'	O
,	O
0	int
,	O
A_DIGIT	int
,	O
'8'	O
,	O
0	int
,	O
A_DIGIT	int
,	O
'9'	O
,	O
0	int
,	O
A_DIGIT	int
,	O
'.'	O
,	O
0	int
,	O
A_DIGIT	int
,	O
'='	O
,	O
0	int
,	O
A_STAT	int
,	O
CONTROL	O
(	O
'G'	O
)	O
,	O
0	int
,	O
A_STAT	int
,	O
':'	O
,	O
'f'	O
,	O
0	int
,	O
A_STAT	int
,	O
'/'	O
,	O
0	int
,	O
A_F_SEARCH	int
,	O
'?'	O
,	O
0	int
,	O
A_B_SEARCH	int
,	O
ESC	O
,	O
'/'	O
,	O
0	int
,	O
A_F_SEARCH	int
|	O
A_EXTRA	int
,	O
'*'	O
,	O
0	int
,	O
ESC	O
,	O
'?'	O
,	O
0	int
,	O
A_B_SEARCH	int
|	O
A_EXTRA	int
,	O
'*'	O
,	O
0	int
,	O
'n'	O
,	O
0	int
,	O
A_AGAIN_SEARCH	int
,	O
ESC	O
,	O
'n'	O
,	O
0	int
,	O
A_T_AGAIN_SEARCH	int
,	O
'N'	O
,	O
0	int
,	O
A_REVERSE_SEARCH	int
,	O
ESC	O
,	O
'N'	O
,	O
0	int
,	O
A_T_REVERSE_SEARCH	int
,	O
'&'	O
,	O
0	int
,	O
A_FILTER	int
,	O
'm'	O
,	O
0	int
,	O
A_SETMARK	int
,	O
'M'	O
,	O
0	int
,	O
A_SETMARKBOT	int
,	O
ESC	O
,	O
'm'	O
,	O
0	int
,	O
A_CLRMARK	int
,	O
'\''	O
,	O
0	int
,	O
A_GOMARK	int
,	O
CONTROL	O
(	O
'X'	O
)	O
,	O
CONTROL	O
(	O
'X'	O
)	O
,	O
0	int
,	O
A_GOMARK	int
,	O
'E'	O
,	O
0	int
,	O
A_EXAMINE	int
,	O
':'	O
,	O
'e'	O
,	O
0	int
,	O
A_EXAMINE	int
,	O
CONTROL	O
(	O
'X'	O
)	O
,	O
CONTROL	O
(	O
'V'	O
)	O
,	O
0	int
,	O
A_EXAMINE	int
,	O
':'	O
,	O
'n'	O
,	O
0	int
,	O
A_NEXT_FILE	int
,	O
':'	O
,	O
'p'	O
,	O
0	int
,	O
A_PREV_FILE	int
,	O
't'	O
,	O
0	int
,	O
A_NEXT_TAG	int
,	O
'T'	O
,	O
0	int
,	O
A_PREV_TAG	int
,	O
':'	O
,	O
'x'	O
,	O
0	int
,	O
A_INDEX_FILE	int
,	O
':'	O
,	O
'd'	O
,	O
0	int
,	O
A_REMOVE_FILE	int
,	O
'-'	O
,	O
0	int
,	O
A_OPT_TOGGLE	int
,	O
':'	O
,	O
't'	O
,	O
0	int
,	O
A_OPT_TOGGLE	int
|	O
A_EXTRA	int
,	O
't'	O
,	O
0	int
,	O
's'	O
,	O
0	int
,	O
A_OPT_TOGGLE	int
|	O
A_EXTRA	int
,	O
'o'	O
,	O
0	int
,	O
'_'	O
,	O
0	int
,	O
A_DISP_OPTION	int
,	O
'|'	O
,	O
0	int
,	O
A_PIPE	int
,	O
'v'	O
,	O
0	int
,	O
A_VISUAL	int
,	O
'!'	O
,	O
0	int
,	O
A_SHELL	int
,	O
'+'	O
,	O
0	int
,	O
A_FIRSTCMD	int
,	O
'H'	O
,	O
0	int
,	O
A_HELP	int
,	O
'h'	O
,	O
0	int
,	O
A_HELP	int
,	O
SK	O
(	O
SK_F1	int
)	O
,	O
0	int
,	O
A_HELP	int
,	O
'V'	O
,	O
0	int
,	O
A_VERSION	int
,	O
'q'	O
,	O
0	int
,	O
A_QUIT	int
,	O
'Q'	O
,	O
0	int
,	O
A_QUIT	int
,	O
':'	O
,	O
'q'	O
,	O
0	int
,	O
A_QUIT	int
,	O
':'	O
,	O
'Q'	O
,	O
0	int
,	O
A_QUIT	int
,	O
'Z'	O
,	O
'Z'	O
,	O
0	int
,	O
A_QUIT	int
}	O
;	O
static	O
unsigned	O
char	O
edittable	array
[	O
]	O
=	O
{	O
'\t'	O
,	O
0	int
,	O
EC_F_COMPLETE	int
,	O
'\17'	O
,	O
0	int
,	O
EC_B_COMPLETE	int
,	O
SK	O
(	O
SK_BACKTAB	int
)	O
,	O
0	int
,	O
EC_B_COMPLETE	int
,	O
ESC	O
,	O
'\t'	O
,	O
0	int
,	O
EC_B_COMPLETE	int
,	O
CONTROL	O
(	O
'L'	O
)	O
,	O
0	int
,	O
EC_EXPAND	int
,	O
CONTROL	O
(	O
'V'	O
)	O
,	O
0	int
,	O
EC_LITERAL	int
,	O
CONTROL	O
(	O
'A'	O
)	O
,	O
0	int
,	O
EC_LITERAL	int
,	O
ESC	O
,	O
'l'	O
,	O
0	int
,	O
EC_RIGHT	int
,	O
SK	O
(	O
SK_RIGHT_ARROW	int
)	O
,	O
0	int
,	O
EC_RIGHT	int
,	O
ESC	O
,	O
'h'	O
,	O
0	int
,	O
EC_LEFT	int
,	O
SK	O
(	O
SK_LEFT_ARROW	int
)	O
,	O
0	int
,	O
EC_LEFT	int
,	O
ESC	O
,	O
'b'	O
,	O
0	int
,	O
EC_W_LEFT	int
,	O
ESC	O
,	O
SK	O
(	O
SK_LEFT_ARROW	int
)	O
,	O
0	int
,	O
EC_W_LEFT	int
,	O
SK	O
(	O
SK_CTL_LEFT_ARROW	int
)	O
,	O
0	int
,	O
EC_W_LEFT	int
,	O
ESC	O
,	O
'w'	O
,	O
0	int
,	O
EC_W_RIGHT	int
,	O
ESC	O
,	O
SK	O
(	O
SK_RIGHT_ARROW	int
)	O
,	O
0	int
,	O
EC_W_RIGHT	int
,	O
SK	O
(	O
SK_CTL_RIGHT_ARROW	int
)	O
,	O
0	int
,	O
EC_W_RIGHT	int
,	O
ESC	O
,	O
'i'	O
,	O
0	int
,	O
EC_INSERT	int
,	O
SK	O
(	O
SK_INSERT	int
)	O
,	O
0	int
,	O
EC_INSERT	int
,	O
ESC	O
,	O
'x'	O
,	O
0	int
,	O
EC_DELETE	int
,	O
SK	O
(	O
SK_DELETE	int
)	O
,	O
0	int
,	O
EC_DELETE	int
,	O
ESC	O
,	O
'X'	O
,	O
0	int
,	O
EC_W_DELETE	int
,	O
ESC	O
,	O
SK	O
(	O
SK_DELETE	int
)	O
,	O
0	int
,	O
EC_W_DELETE	int
,	O
SK	O
(	O
SK_CTL_DELETE	int
)	O
,	O
0	int
,	O
EC_W_DELETE	int
,	O
SK	O
(	O
SK_CTL_BACKSPACE	int
)	O
,	O
0	int
,	O
EC_W_BACKSPACE	int
,	O
ESC	O
,	O
'\b'	O
,	O
0	int
,	O
EC_W_BACKSPACE	int
,	O
ESC	O
,	O
'0'	O
,	O
0	int
,	O
EC_HOME	int
,	O
SK	O
(	O
SK_HOME	int
)	O
,	O
0	int
,	O
EC_HOME	int
,	O
ESC	O
,	O
'$'	O
,	O
0	int
,	O
EC_END	int
,	O
SK	O
(	O
SK_END	int
)	O
,	O
0	int
,	O
EC_END	int
,	O
ESC	O
,	O
'k'	O
,	O
0	int
,	O
EC_UP	int
,	O
SK	O
(	O
SK_UP_ARROW	int
)	O
,	O
0	int
,	O
EC_UP	int
,	O
ESC	O
,	O
'j'	O
,	O
0	int
,	O
EC_DOWN	int
,	O
SK	O
(	O
SK_DOWN_ARROW	int
)	O
,	O
0	int
,	O
EC_DOWN	int
,	O
CONTROL	O
(	O
'G'	O
)	O
,	O
0	int
,	O
EC_ABORT	int
,	O
}	O
;	O
struct	O
tablelist	struct
{	O
struct	O
tablelist	struct
*	O
t_next	pointer
;	O
char	O
*	O
t_start	pointer
;	O
char	O
*	O
t_end	pointer
;	O
}	O
;	O
static	O
struct	O
tablelist	struct
*	O
list_fcmd_tables	pointer
=	O
NULL	O
;	O
static	O
struct	O
tablelist	struct
*	O
list_ecmd_tables	pointer
=	O
NULL	O
;	O
static	O
struct	O
tablelist	struct
*	O
list_var_tables	pointer
=	O
NULL	O
;	O
static	O
struct	O
tablelist	struct
*	O
list_sysvar_tables	pointer
=	O
NULL	O
;	O
static	O
void	O
expand_special_keys	function
(	O
table	pointer
,	O
len	int
)	O
char	O
*	O
table	pointer
;	O
int	O
len	int
;	O
{	O
char	O
*	O
fm	pointer
;	O
char	O
*	O
to	pointer
;	O
int	O
a	int
;	O
char	O
*	O
repl	pointer
;	O
int	O
klen	int
;	O
for	O
(	O
fm	pointer
=	O
table	pointer
;	O
fm	pointer
<	O
table	pointer
+	O
len	int
;	O
)	O
{	O
for	O
(	O
to	pointer
=	O
fm	pointer
;	O
*	O
fm	pointer
!=	O
'\0'	O
;	O
)	O
{	O
if	O
(	O
*	O
fm	pointer
!=	O
SK_SPECIAL_KEY	O
)	O
{	O
*	O
to	pointer
++	O
=	O
*	O
fm	pointer
++	O
;	O
continue	O
;	O
}	O
repl	pointer
=	O
special_key_str	function
(	O
fm	pointer
[	O
1	int
]	O
)	O
;	O
klen	int
=	O
fm	pointer
[	O
2	int
]	O
&	O
0377	int
;	O
fm	pointer
+=	O
klen	int
;	O
if	O
(	O
repl	pointer
==	O
NULL	O
||	O
(	O
int	O
)	O
strlen	function
(	O
repl	pointer
)	O
>	O
klen	int
)	O
repl	pointer
=	O
"\377"	pointer
;	O
while	O
(	O
*	O
repl	pointer
!=	O
'\0'	O
)	O
*	O
to	pointer
++	O
=	O
*	O
repl	pointer
++	O
;	O
}	O
*	O
to	pointer
++	O
=	O
'\0'	O
;	O
while	O
(	O
to	pointer
<=	O
fm	pointer
)	O
*	O
to	pointer
++	O
=	O
A_SKIP	int
;	O
fm	pointer
++	O
;	O
a	int
=	O
*	O
fm	pointer
++	O
&	O
0377	int
;	O
if	O
(	O
a	int
&	O
A_EXTRA	int
)	O
{	O
while	O
(	O
*	O
fm	pointer
++	O
!=	O
'\0'	O
)	O
continue	O
;	O
}	O
}	O
}	O
static	O
void	O
expand_cmd_table	function
(	O
tlist	pointer
)	O
struct	O
tablelist	struct
*	O
tlist	pointer
;	O
{	O
struct	O
tablelist	struct
*	O
t	pointer
;	O
for	O
(	O
t	pointer
=	O
tlist	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
t_next	pointer
)	O
{	O
expand_special_keys	function
(	O
t	pointer
->	O
t_start	pointer
,	O
t	pointer
->	O
t_end	pointer
-	O
t	pointer
->	O
t_start	pointer
)	O
;	O
}	O
}	O
public	O
void	O
expand_cmd_tables	function
(	O
)	O
{	O
expand_cmd_table	function
(	O
list_fcmd_tables	pointer
)	O
;	O
expand_cmd_table	function
(	O
list_ecmd_tables	pointer
)	O
;	O
expand_cmd_table	function
(	O
list_var_tables	pointer
)	O
;	O
expand_cmd_table	function
(	O
list_sysvar_tables	pointer
)	O
;	O
}	O
public	O
void	O
init_cmds	function
(	O
)	O
{	O
add_fcmd_table	function
(	O
(	O
char	O
*	O
)	O
cmdtable	array
,	O
sizeof	O
(	O
cmdtable	array
)	O
)	O
;	O
add_ecmd_table	function
(	O
(	O
char	O
*	O
)	O
edittable	array
,	O
sizeof	O
(	O
edittable	array
)	O
)	O
;	O
add_hometable	function
(	O
NULL	O
,	O
BINDIR	O
"/.sysless"	pointer
,	O
1	int
)	O
;	O
add_hometable	function
(	O
"LESSKEY_SYSTEM"	pointer
,	O
LESSKEYFILE_SYS	O
,	O
1	int
)	O
;	O
add_hometable	function
(	O
"LESSKEY"	pointer
,	O
LESSKEYFILE	pointer
,	O
0	int
)	O
;	O
}	O
static	O
int	O
add_cmd_table	function
(	O
tlist	pointer
,	O
buf	pointer
,	O
len	int
)	O
struct	O
tablelist	struct
*	O
*	O
tlist	pointer
;	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
{	O
struct	O
tablelist	struct
*	O
t	pointer
;	O
if	O
(	O
len	int
==	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
(	O
t	pointer
=	O
(	O
struct	O
tablelist	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
tablelist	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
t	pointer
->	O
t_start	pointer
=	O
buf	pointer
;	O
t	pointer
->	O
t_end	pointer
=	O
buf	pointer
+	O
len	int
;	O
t	pointer
->	O
t_next	pointer
=	O
*	O
tlist	pointer
;	O
*	O
tlist	pointer
=	O
t	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
public	O
void	O
add_fcmd_table	function
(	O
buf	pointer
,	O
len	int
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
{	O
if	O
(	O
add_cmd_table	function
(	O
&	O
list_fcmd_tables	pointer
,	O
buf	pointer
,	O
len	int
)	O
<	O
0	int
)	O
error	function
(	O
"Warning: some commands disabled"	pointer
,	O
NULL_PARG	O
)	O
;	O
}	O
public	O
void	O
add_ecmd_table	function
(	O
buf	pointer
,	O
len	int
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
{	O
if	O
(	O
add_cmd_table	function
(	O
&	O
list_ecmd_tables	pointer
,	O
buf	pointer
,	O
len	int
)	O
<	O
0	int
)	O
error	function
(	O
"Warning: some edit commands disabled"	pointer
,	O
NULL_PARG	O
)	O
;	O
}	O
static	O
void	O
add_var_table	function
(	O
tlist	pointer
,	O
buf	pointer
,	O
len	int
)	O
struct	O
tablelist	struct
*	O
*	O
tlist	pointer
;	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
{	O
if	O
(	O
add_cmd_table	function
(	O
tlist	pointer
,	O
buf	pointer
,	O
len	int
)	O
<	O
0	int
)	O
error	function
(	O
"Warning: environment variables from lesskey file unavailable"	pointer
,	O
NULL_PARG	O
)	O
;	O
}	O
static	O
int	O
cmd_search	function
(	O
cmd	pointer
,	O
table	pointer
,	O
endtable	pointer
,	O
sp	pointer
)	O
char	O
*	O
cmd	pointer
;	O
char	O
*	O
table	pointer
;	O
char	O
*	O
endtable	pointer
;	O
char	O
*	O
*	O
sp	pointer
;	O
{	O
char	O
*	O
p	pointer
;	O
char	O
*	O
q	pointer
;	O
int	O
a	int
;	O
*	O
sp	pointer
=	O
NULL	O
;	O
for	O
(	O
p	pointer
=	O
table	pointer
,	O
q	pointer
=	O
cmd	pointer
;	O
p	pointer
<	O
endtable	pointer
;	O
p	pointer
++	O
,	O
q	pointer
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
*	O
q	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
{	O
a	int
=	O
*	O
++	O
p	pointer
&	O
0377	int
;	O
while	O
(	O
a	int
==	O
A_SKIP	int
)	O
a	int
=	O
*	O
++	O
p	pointer
&	O
0377	int
;	O
if	O
(	O
a	int
==	O
A_END_LIST	int
)	O
{	O
return	O
(	O
A_UINVALID	int
)	O
;	O
}	O
if	O
(	O
a	int
&	O
A_EXTRA	int
)	O
{	O
*	O
sp	pointer
=	O
++	O
p	pointer
;	O
a	int
&=	O
~	O
A_EXTRA	int
;	O
}	O
return	O
(	O
a	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
q	pointer
==	O
'\0'	O
)	O
{	O
return	O
(	O
A_PREFIX	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
&&	O
p	pointer
[	O
1	int
]	O
==	O
A_END_LIST	int
)	O
{	O
return	O
(	O
A_UINVALID	int
)	O
;	O
}	O
while	O
(	O
*	O
p	pointer
++	O
!=	O
'\0'	O
)	O
continue	O
;	O
while	O
(	O
*	O
p	pointer
==	O
A_SKIP	int
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
&	O
A_EXTRA	int
)	O
while	O
(	O
*	O
++	O
p	pointer
!=	O
'\0'	O
)	O
continue	O
;	O
q	pointer
=	O
cmd	pointer
-	O
1	int
;	O
}	O
}	O
return	O
(	O
A_INVALID	int
)	O
;	O
}	O
static	O
int	O
cmd_decode	function
(	O
tlist	pointer
,	O
cmd	pointer
,	O
sp	pointer
)	O
struct	O
tablelist	struct
*	O
tlist	pointer
;	O
char	O
*	O
cmd	pointer
;	O
char	O
*	O
*	O
sp	pointer
;	O
{	O
struct	O
tablelist	struct
*	O
t	pointer
;	O
int	O
action	int
=	O
A_INVALID	int
;	O
for	O
(	O
t	pointer
=	O
tlist	pointer
;	O
t	pointer
!=	O
NULL	O
;	O
t	pointer
=	O
t	pointer
->	O
t_next	pointer
)	O
{	O
action	int
=	O
cmd_search	function
(	O
cmd	pointer
,	O
t	pointer
->	O
t_start	pointer
,	O
t	pointer
->	O
t_end	pointer
,	O
sp	pointer
)	O
;	O
if	O
(	O
action	int
!=	O
A_INVALID	int
)	O
break	O
;	O
}	O
if	O
(	O
action	int
==	O
A_UINVALID	int
)	O
action	int
=	O
A_INVALID	int
;	O
return	O
(	O
action	int
)	O
;	O
}	O
public	O
int	O
fcmd_decode	function
(	O
cmd	pointer
,	O
sp	pointer
)	O
char	O
*	O
cmd	pointer
;	O
char	O
*	O
*	O
sp	pointer
;	O
{	O
return	O
(	O
cmd_decode	function
(	O
list_fcmd_tables	pointer
,	O
cmd	pointer
,	O
sp	pointer
)	O
)	O
;	O
}	O
public	O
int	O
ecmd_decode	function
(	O
cmd	pointer
,	O
sp	pointer
)	O
char	O
*	O
cmd	pointer
;	O
char	O
*	O
*	O
sp	pointer
;	O
{	O
return	O
(	O
cmd_decode	function
(	O
list_ecmd_tables	pointer
,	O
cmd	pointer
,	O
sp	pointer
)	O
)	O
;	O
}	O
public	O
char	O
*	O
lgetenv	function
(	O
var	pointer
)	O
char	O
*	O
var	pointer
;	O
{	O
int	O
a	int
;	O
char	O
*	O
s	pointer
;	O
a	int
=	O
cmd_decode	function
(	O
list_var_tables	pointer
,	O
var	pointer
,	O
&	O
s	pointer
)	O
;	O
if	O
(	O
a	int
==	O
EV_OK	int
)	O
return	O
(	O
s	pointer
)	O
;	O
s	pointer
=	O
getenv	function
(	O
var	pointer
)	O
;	O
if	O
(	O
s	pointer
!=	O
NULL	O
&&	O
*	O
s	pointer
!=	O
'\0'	O
)	O
return	O
(	O
s	pointer
)	O
;	O
a	int
=	O
cmd_decode	function
(	O
list_sysvar_tables	pointer
,	O
var	pointer
,	O
&	O
s	pointer
)	O
;	O
if	O
(	O
a	int
==	O
EV_OK	int
)	O
return	O
(	O
s	pointer
)	O
;	O
return	O
(	O
NULL	O
)	O
;	O
}	O
static	O
int	O
gint	function
(	O
sp	pointer
)	O
char	O
*	O
*	O
sp	pointer
;	O
{	O
int	O
n	int
;	O
n	int
=	O
*	O
(	O
*	O
sp	pointer
)	O
++	O
;	O
n	int
+=	O
*	O
(	O
*	O
sp	pointer
)	O
++	O
*	O
KRADIX	int
;	O
return	O
(	O
n	int
)	O
;	O
}	O
static	O
int	O
old_lesskey	function
(	O
buf	pointer
,	O
len	int
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
{	O
if	O
(	O
buf	pointer
[	O
len	int
-	O
1	int
]	O
!=	O
'\0'	O
&&	O
buf	pointer
[	O
len	int
-	O
2	int
]	O
!=	O
'\0'	O
)	O
return	O
(	O
-	O
1	int
)	O
;	O
add_fcmd_table	function
(	O
buf	pointer
,	O
len	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
new_lesskey	function
(	O
buf	pointer
,	O
len	int
,	O
sysvar	int
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
int	O
sysvar	int
;	O
{	O
char	O
*	O
p	pointer
;	O
int	O
c	int
;	O
int	O
n	int
;	O
if	O
(	O
buf	pointer
[	O
len	int
-	O
3	int
]	O
!=	O
C0_END_LESSKEY_MAGIC	char
||	O
buf	pointer
[	O
len	int
-	O
2	int
]	O
!=	O
C1_END_LESSKEY_MAGIC	char
||	O
buf	pointer
[	O
len	int
-	O
1	int
]	O
!=	O
C2_END_LESSKEY_MAGIC	char
)	O
return	O
(	O
-	O
1	int
)	O
;	O
p	pointer
=	O
buf	pointer
+	O
4	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
c	int
=	O
*	O
p	pointer
++	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
CMD_SECTION	char
:	O
n	int
=	O
gint	function
(	O
&	O
p	pointer
)	O
;	O
add_fcmd_table	function
(	O
p	pointer
,	O
n	int
)	O
;	O
p	pointer
+=	O
n	int
;	O
break	O
;	O
case	O
EDIT_SECTION	char
:	O
n	int
=	O
gint	function
(	O
&	O
p	pointer
)	O
;	O
add_ecmd_table	function
(	O
p	pointer
,	O
n	int
)	O
;	O
p	pointer
+=	O
n	int
;	O
break	O
;	O
case	O
VAR_SECTION	char
:	O
n	int
=	O
gint	function
(	O
&	O
p	pointer
)	O
;	O
add_var_table	function
(	O
(	O
sysvar	int
)	O
?	O
&	O
list_sysvar_tables	pointer
:	O
&	O
list_var_tables	pointer
,	O
p	pointer
,	O
n	int
)	O
;	O
p	pointer
+=	O
n	int
;	O
break	O
;	O
case	O
END_SECTION	char
:	O
return	O
(	O
0	int
)	O
;	O
default	O
:	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
}	O
}	O
public	O
int	O
lesskey	function
(	O
filename	pointer
,	O
sysvar	int
)	O
char	O
*	O
filename	pointer
;	O
int	O
sysvar	int
;	O
{	O
char	O
*	O
buf	pointer
;	O
POSITION	long
len	int
;	O
long	O
n	int
;	O
int	O
f	int
;	O
if	O
(	O
secure	int
)	O
return	O
(	O
1	int
)	O
;	O
f	int
=	O
open	function
(	O
filename	pointer
,	O
OPEN_READ	O
)	O
;	O
if	O
(	O
f	int
<	O
0	int
)	O
return	O
(	O
1	int
)	O
;	O
len	int
=	O
filesize	function
(	O
f	int
)	O
;	O
if	O
(	O
len	int
==	O
NULL_POSITION	O
||	O
len	int
<	O
3	int
)	O
{	O
close	function
(	O
f	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
calloc	function
(	O
(	O
int	O
)	O
len	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
close	function
(	O
f	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
lseek	function
(	O
f	int
,	O
(	O
off_t	long
)	O
0	int
,	O
SEEK_SET	int
)	O
==	O
BAD_LSEEK	O
)	O
{	O
free	function
(	O
buf	pointer
)	O
;	O
close	function
(	O
f	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
n	int
=	O
read	function
(	O
f	int
,	O
buf	pointer
,	O
(	O
unsigned	O
int	O
)	O
len	int
)	O
;	O
close	function
(	O
f	int
)	O
;	O
if	O
(	O
n	int
!=	O
len	int
)	O
{	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
!=	O
C0_LESSKEY_MAGIC	char
||	O
buf	pointer
[	O
1	int
]	O
!=	O
C1_LESSKEY_MAGIC	char
||	O
buf	pointer
[	O
2	int
]	O
!=	O
C2_LESSKEY_MAGIC	char
||	O
buf	pointer
[	O
3	int
]	O
!=	O
C3_LESSKEY_MAGIC	char
)	O
return	O
(	O
old_lesskey	function
(	O
buf	pointer
,	O
(	O
int	O
)	O
len	int
)	O
)	O
;	O
return	O
(	O
new_lesskey	function
(	O
buf	pointer
,	O
(	O
int	O
)	O
len	int
,	O
sysvar	int
)	O
)	O
;	O
}	O
public	O
void	O
add_hometable	function
(	O
envname	pointer
,	O
def_filename	pointer
,	O
sysvar	int
)	O
char	O
*	O
envname	pointer
;	O
char	O
*	O
def_filename	pointer
;	O
int	O
sysvar	int
;	O
{	O
char	O
*	O
filename	pointer
;	O
PARG	union
parg	union
;	O
if	O
(	O
envname	pointer
!=	O
NULL	O
&&	O
(	O
filename	pointer
=	O
lgetenv	function
(	O
envname	pointer
)	O
)	O
!=	O
NULL	O
)	O
filename	pointer
=	O
save	function
(	O
filename	pointer
)	O
;	O
else	O
if	O
(	O
sysvar	int
)	O
filename	pointer
=	O
save	function
(	O
def_filename	pointer
)	O
;	O
else	O
filename	pointer
=	O
homefile	function
(	O
def_filename	pointer
)	O
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
lesskey	function
(	O
filename	pointer
,	O
sysvar	int
)	O
<	O
0	int
)	O
{	O
parg	union
.	O
p_string	pointer
=	O
filename	pointer
;	O
error	function
(	O
"Cannot use lesskey file \"%s\""	pointer
,	O
&	O
parg	union
)	O
;	O
}	O
free	function
(	O
filename	pointer
)	O
;	O
}	O
public	O
int	O
editchar	function
(	O
c	int
,	O
flags	int
)	O
int	O
c	int
;	O
int	O
flags	int
;	O
{	O
int	O
action	int
;	O
int	O
nch	int
;	O
char	O
*	O
s	pointer
;	O
char	O
usercmd	array
[	O
MAX_CMDLEN	int
+	O
1	int
]	O
;	O
if	O
(	O
c	int
==	O
erase_char	int
||	O
c	int
==	O
erase2_char	int
)	O
return	O
(	O
EC_BACKSPACE	int
)	O
;	O
if	O
(	O
c	int
==	O
kill_char	int
)	O
return	O
(	O
EC_LINEKILL	int
)	O
;	O
nch	int
=	O
0	int
;	O
do	O
{	O
if	O
(	O
nch	int
>	O
0	int
)	O
c	int
=	O
getcc	function
(	O
)	O
;	O
usercmd	array
[	O
nch	int
]	O
=	O
c	int
;	O
usercmd	array
[	O
nch	int
+	O
1	int
]	O
=	O
'\0'	O
;	O
nch	int
++	O
;	O
action	int
=	O
ecmd_decode	function
(	O
usercmd	array
,	O
&	O
s	pointer
)	O
;	O
}	O
while	O
(	O
action	int
==	O
A_PREFIX	int
)	O
;	O
if	O
(	O
flags	int
&	O
EC_NORIGHTLEFT	int
)	O
{	O
switch	O
(	O
action	int
)	O
{	O
case	O
EC_RIGHT	int
:	O
case	O
EC_LEFT	int
:	O
action	int
=	O
A_INVALID	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
flags	int
&	O
EC_NOHISTORY	int
)	O
{	O
switch	O
(	O
action	int
)	O
{	O
case	O
EC_UP	int
:	O
case	O
EC_DOWN	int
:	O
action	int
=	O
A_INVALID	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
flags	int
&	O
EC_NOCOMPLETE	int
)	O
{	O
switch	O
(	O
action	int
)	O
{	O
case	O
EC_F_COMPLETE	int
:	O
case	O
EC_B_COMPLETE	int
:	O
case	O
EC_EXPAND	int
:	O
action	int
=	O
A_INVALID	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
flags	int
&	O
EC_PEEK	int
)	O
||	O
action	int
==	O
A_INVALID	int
)	O
{	O
while	O
(	O
nch	int
>	O
1	int
)	O
{	O
ungetcc	function
(	O
usercmd	array
[	O
--	O
nch	int
]	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
s	pointer
!=	O
NULL	O
)	O
ungetsc	function
(	O
s	pointer
)	O
;	O
}	O
return	O
action	int
;	O
}	O
