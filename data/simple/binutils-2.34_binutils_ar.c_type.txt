static	O
void	O
mri_emul	function
(	O
void	O
)	O
;	O
static	O
const	O
char	O
*	O
normalize	function
(	O
const	O
char	O
*	O
,	O
bfd	struct
*	O
)	O
;	O
static	O
void	O
remove_output	function
(	O
void	O
)	O
;	O
static	O
void	O
map_over_members	function
(	O
bfd	struct
*	O
,	O
void	O
(	O
*	O
)	O
(	O
bfd	struct
*	O
)	O
,	O
char	O
*	O
*	O
,	O
int	O
)	O
;	O
static	O
void	O
print_contents	function
(	O
bfd	struct
*	O
member	pointer
)	O
;	O
static	O
void	O
delete_members	function
(	O
bfd	struct
*	O
,	O
char	O
*	O
*	O
files_to_delete	pointer
)	O
;	O
static	O
void	O
move_members	function
(	O
bfd	struct
*	O
,	O
char	O
*	O
*	O
files_to_move	pointer
)	O
;	O
static	O
void	O
replace_members	function
(	O
bfd	struct
*	O
,	O
char	O
*	O
*	O
files_to_replace	pointer
,	O
bfd_boolean	int
quick	int
)	O
;	O
static	O
void	O
print_descr	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
;	O
static	O
void	O
write_archive	function
(	O
bfd	struct
*	O
)	O
;	O
static	O
int	O
ranlib_only	function
(	O
const	O
char	O
*	O
archname	pointer
)	O
;	O
static	O
int	O
ranlib_touch	function
(	O
const	O
char	O
*	O
archname	pointer
)	O
;	O
static	O
void	O
usage	function
(	O
int	O
)	O
;	O
static	O
int	O
mri_mode	int
;	O
extern	O
int	O
is_ranlib	int
;	O
int	O
silent_create	int
=	O
0	int
;	O
int	O
verbose	int
=	O
0	int
;	O
int	O
display_offsets	int
=	O
0	int
;	O
int	O
preserve_dates	int
=	O
0	int
;	O
int	O
newer_only	int
=	O
0	int
;	O
int	O
write_armap	pointer
=	O
0	int
;	O
int	O
deterministic	int
=	O
-	O
1	int
;	O
char	O
*	O
posname	pointer
=	O
NULL	O
;	O
enum	O
pos	long
{	O
pos_default	int
,	O
pos_before	int
,	O
pos_after	int
,	O
pos_end	int
}	O
postype	enum
=	O
pos_default	int
;	O
enum	O
operations	enum
{	O
none	int
=	O
0	int
,	O
del	int
,	O
replace	int
,	O
print_table	int
,	O
print_files	int
,	O
extract	int
,	O
move	int
,	O
quick_append	int
}	O
operation	pointer
=	O
none	int
;	O
static	O
bfd	struct
*	O
*	O
get_pos_bfd	function
(	O
bfd	struct
*	O
*	O
,	O
enum	O
pos	long
,	O
const	O
char	O
*	O
)	O
;	O
static	O
bfd_boolean	int
counted_name_mode	int
=	O
0	int
;	O
static	O
int	O
counted_name_counter	int
=	O
0	int
;	O
static	O
bfd_boolean	int
ar_truncate	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
full_pathname	int
=	O
FALSE	int
;	O
static	O
bfd_boolean	int
make_thin_archive	int
=	O
FALSE	int
;	O
static	O
int	O
show_version	int
=	O
0	int
;	O
static	O
int	O
show_help	int
=	O
0	int
;	O
static	O
const	O
char	O
*	O
plugin_target	pointer
=	O
"plugin"	pointer
;	O
static	O
const	O
char	O
*	O
target	pointer
=	O
NULL	O
;	O
enum	O
long_option_numbers	enum
{	O
OPTION_PLUGIN	int
=	O
201	int
,	O
OPTION_TARGET	int
,	O
OPTION_OUTPUT	int
}	O
;	O
static	O
const	O
char	O
*	O
output_dir	pointer
=	O
NULL	O
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
&	O
show_help	int
,	O
1	int
}	O
,	O
{	O
"plugin"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_PLUGIN	int
}	O
,	O
{	O
"target"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_TARGET	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
&	O
show_version	int
,	O
1	int
}	O
,	O
{	O
"output"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_OUTPUT	int
}	O
,	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
int	O
interactive	int
=	O
0	int
;	O
static	O
void	O
mri_emul	function
(	O
void	O
)	O
{	O
interactive	int
=	O
isatty	function
(	O
fileno	function
(	O
stdin	pointer
)	O
)	O
;	O
yyparse	function
(	O
)	O
;	O
}	O
static	O
void	O
map_over_members	function
(	O
bfd	struct
*	O
arch	enum
,	O
void	O
(	O
*	O
function	pointer
)	O
(	O
bfd	struct
*	O
)	O
,	O
char	O
*	O
*	O
files	pointer
,	O
int	O
count	int
)	O
{	O
bfd	struct
*	O
head	pointer
;	O
int	O
match_count	int
;	O
if	O
(	O
count	int
==	O
0	int
)	O
{	O
for	O
(	O
head	pointer
=	O
arch	enum
->	O
archive_next	pointer
;	O
head	pointer
;	O
head	pointer
=	O
head	pointer
->	O
archive_next	pointer
)	O
{	O
PROGRESS	O
(	O
1	int
)	O
;	O
function	pointer
(	O
head	pointer
)	O
;	O
}	O
return	O
;	O
}	O
for	O
(	O
head	pointer
=	O
arch	enum
->	O
archive_next	pointer
;	O
head	pointer
;	O
head	pointer
=	O
head	pointer
->	O
archive_next	pointer
)	O
head	pointer
->	O
archive_pass	int
=	O
0	int
;	O
for	O
(	O
;	O
count	int
>	O
0	int
;	O
files	pointer
++	O
,	O
count	int
--	O
)	O
{	O
bfd_boolean	int
found	int
=	O
FALSE	int
;	O
match_count	int
=	O
0	int
;	O
for	O
(	O
head	pointer
=	O
arch	enum
->	O
archive_next	pointer
;	O
head	pointer
;	O
head	pointer
=	O
head	pointer
->	O
archive_next	pointer
)	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
PROGRESS	O
(	O
1	int
)	O
;	O
if	O
(	O
head	pointer
->	O
archive_pass	int
)	O
continue	O
;	O
filename	pointer
=	O
head	pointer
->	O
filename	pointer
;	O
if	O
(	O
filename	pointer
==	O
NULL	O
)	O
{	O
struct	O
stat	struct
buf	pointer
;	O
bfd_stat_arch_elt	O
(	O
head	pointer
,	O
&	O
buf	pointer
)	O
;	O
}	O
else	O
if	O
(	O
bfd_is_thin_archive	function
(	O
arch	enum
)	O
)	O
{	O
filename	pointer
=	O
normalize	function
(	O
filename	pointer
,	O
arch	enum
)	O
;	O
}	O
if	O
(	O
filename	pointer
!=	O
NULL	O
&&	O
!	O
FILENAME_CMP	O
(	O
normalize	function
(	O
*	O
files	pointer
,	O
arch	enum
)	O
,	O
filename	pointer
)	O
)	O
{	O
++	O
match_count	int
;	O
if	O
(	O
counted_name_mode	int
&&	O
match_count	int
!=	O
counted_name_counter	int
)	O
{	O
continue	O
;	O
}	O
found	int
=	O
TRUE	int
;	O
function	pointer
(	O
head	pointer
)	O
;	O
head	pointer
->	O
archive_pass	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
found	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"no entry %s in archive\n"	pointer
)	O
,	O
*	O
files	pointer
)	O
;	O
}	O
}	O
bfd_boolean	int
operation_alters_arch	int
=	O
FALSE	int
;	O
static	O
void	O
usage	function
(	O
int	O
help	int
)	O
{	O
FILE	struct
*	O
s	pointer
;	O
const	O
char	O
*	O
command_line	pointer
=	O
_	O
(	O
"Usage: %s [emulation options] [-]{dmpqrstx}[abcDfilMNoOPsSTuvV]"	pointer
" [--plugin <name>] [member-name] [count] archive-file file...\n"	pointer
)	O
;	O
s	pointer
=	O
help	int
?	O
stdout	pointer
:	O
stderr	pointer
;	O
fprintf	function
(	O
s	pointer
,	O
command_line	pointer
,	O
program_name	pointer
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"       %s -M [<mri-script]\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
" commands:\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  d            - delete file(s) from the archive\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  m[ab]        - move file(s) in the archive\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  p            - print file(s) found in the archive\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  q[f]         - quick append file(s) to the archive\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  r[ab][f][u]  - replace existing or insert new file(s) into the archive\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  s            - act as ranlib\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  t[O][v]      - display contents of the archive\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  x[o]         - extract file(s) from the archive\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
" command specific modifiers:\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [a]          - put file(s) after [member-name]\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [b]          - put file(s) before [member-name] (same as [i])\n"	pointer
)	O
)	O
;	O
if	O
(	O
DEFAULT_AR_DETERMINISTIC	int
)	O
{	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [D]          - use zero for timestamps and uids/gids (default)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [U]          - use actual timestamps and uids/gids\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [D]          - use zero for timestamps and uids/gids\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [U]          - use actual timestamps and uids/gids (default)\n"	pointer
)	O
)	O
;	O
}	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [N]          - use instance [count] of name\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [f]          - truncate inserted file names\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [P]          - use full path names when matching\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [o]          - preserve original dates\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [O]          - display offsets of files in the archive\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [u]          - only replace files that are newer than current archive contents\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
" generic modifiers:\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [c]          - do not warn if the library had to be created\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [s]          - create an archive index (cf. ranlib)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [S]          - do not build a symbol table\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [T]          - make a thin archive\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [v]          - be verbose\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  [V]          - display the version number\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  @<file>      - read options from <file>\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  --target=BFDNAME - specify the target object format as BFDNAME\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  --output=DIRNAME - specify the output directory for extraction operations\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
" optional:\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  --plugin <p> - load the specified plugin\n"	pointer
)	O
)	O
;	O
ar_emul_usage	function
(	O
s	pointer
)	O
;	O
list_supported_targets	function
(	O
program_name	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	pointer
[	O
0	int
]	O
&&	O
help	int
)	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"Report bugs to %s\n"	pointer
)	O
,	O
REPORT_BUGS_TO	pointer
)	O
;	O
xexit	function
(	O
help	int
?	O
0	int
:	O
1	int
)	O
;	O
}	O
static	O
void	O
ranlib_usage	function
(	O
int	O
help	int
)	O
{	O
FILE	struct
*	O
s	pointer
;	O
s	pointer
=	O
help	int
?	O
stdout	pointer
:	O
stderr	pointer
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"Usage: %s [options] archive\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
" Generate an index to speed access to archives\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
" The options are:\n  @<file>                      Read options from <file>\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  --plugin <name>              Load the specified plugin\n"	pointer
)	O
)	O
;	O
if	O
(	O
DEFAULT_AR_DETERMINISTIC	int
)	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  -D                           Use zero for symbol map timestamp (default)\n  -U                           Use an actual symbol map timestamp\n"	pointer
)	O
)	O
;	O
else	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  -D                           Use zero for symbol map timestamp\n  -U                           Use actual symbol map timestamp (default)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"  -t                           Update the archive's symbol map timestamp\n  -h --help                    Print this help message\n  -v --version                 Print version information\n"	pointer
)	O
)	O
;	O
list_supported_targets	function
(	O
program_name	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	pointer
[	O
0	int
]	O
&&	O
help	int
)	O
fprintf	function
(	O
s	pointer
,	O
_	O
(	O
"Report bugs to %s\n"	pointer
)	O
,	O
REPORT_BUGS_TO	pointer
)	O
;	O
xexit	function
(	O
help	int
?	O
0	int
:	O
1	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
normalize	function
(	O
const	O
char	O
*	O
file	pointer
,	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
full_pathname	int
)	O
return	O
file	pointer
;	O
filename	pointer
=	O
lbasename	function
(	O
file	pointer
)	O
;	O
if	O
(	O
ar_truncate	int
&&	O
abfd	pointer
!=	O
NULL	O
&&	O
strlen	function
(	O
filename	pointer
)	O
>	O
abfd	pointer
->	O
xvec	pointer
->	O
ar_max_namelen	char
)	O
{	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
abfd	pointer
->	O
xvec	pointer
->	O
ar_max_namelen	char
+	O
1	int
)	O
;	O
memcpy	function
(	O
s	pointer
,	O
filename	pointer
,	O
abfd	pointer
->	O
xvec	pointer
->	O
ar_max_namelen	char
)	O
;	O
s	pointer
[	O
abfd	pointer
->	O
xvec	pointer
->	O
ar_max_namelen	char
]	O
=	O
'\0'	O
;	O
filename	pointer
=	O
s	pointer
;	O
}	O
return	O
filename	pointer
;	O
}	O
static	O
const	O
char	O
*	O
output_filename	pointer
=	O
NULL	O
;	O
static	O
FILE	struct
*	O
output_file	pointer
=	O
NULL	O
;	O
static	O
bfd	struct
*	O
output_bfd	pointer
=	O
NULL	O
;	O
static	O
void	O
remove_output	function
(	O
void	O
)	O
{	O
if	O
(	O
output_filename	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
output_bfd	pointer
!=	O
NULL	O
)	O
bfd_cache_close	function
(	O
output_bfd	pointer
)	O
;	O
if	O
(	O
output_file	pointer
!=	O
NULL	O
)	O
fclose	function
(	O
output_file	pointer
)	O
;	O
unlink_if_ordinary	function
(	O
output_filename	pointer
)	O
;	O
}	O
}	O
static	O
char	O
*	O
*	O
decode_options	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
c	int
;	O
restart	O
:	O
if	O
(	O
argc	int
>	O
1	int
&&	O
argv	pointer
[	O
1	int
]	O
[	O
0	int
]	O
!=	O
'-'	O
)	O
{	O
int	O
new_argc	int
;	O
char	O
*	O
*	O
new_argv	pointer
;	O
char	O
*	O
const	O
*	O
in	pointer
;	O
char	O
*	O
*	O
out	pointer
;	O
const	O
char	O
*	O
letter	pointer
;	O
char	O
buffer	array
[	O
3	int
]	O
;	O
buffer	array
[	O
0	int
]	O
=	O
'-'	O
;	O
buffer	array
[	O
2	int
]	O
=	O
'\0'	O
;	O
new_argc	int
=	O
argc	int
-	O
1	int
+	O
strlen	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
new_argv	pointer
=	O
xmalloc	function
(	O
(	O
new_argc	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
argv	pointer
)	O
)	O
;	O
in	pointer
=	O
argv	pointer
;	O
out	pointer
=	O
new_argv	pointer
;	O
*	O
out	pointer
++	O
=	O
*	O
in	pointer
++	O
;	O
for	O
(	O
letter	pointer
=	O
*	O
in	pointer
++	O
;	O
*	O
letter	pointer
;	O
letter	pointer
++	O
)	O
{	O
buffer	array
[	O
1	int
]	O
=	O
*	O
letter	pointer
;	O
*	O
out	pointer
++	O
=	O
xstrdup	function
(	O
buffer	array
)	O
;	O
}	O
while	O
(	O
in	pointer
<	O
argv	pointer
+	O
argc	int
)	O
*	O
out	pointer
++	O
=	O
*	O
in	pointer
++	O
;	O
*	O
out	pointer
=	O
NULL	O
;	O
argc	int
=	O
new_argc	int
;	O
argv	pointer
=	O
new_argv	pointer
;	O
}	O
while	O
(	O
(	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"hdmpqrtxlcoOVsSuvabiMNfPTDU"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'd'	O
:	O
case	O
'm'	O
:	O
case	O
'p'	O
:	O
case	O
'q'	O
:	O
case	O
'r'	O
:	O
case	O
't'	O
:	O
case	O
'x'	O
:	O
if	O
(	O
operation	pointer
!=	O
none	int
)	O
fatal	function
(	O
_	O
(	O
"two different operation options specified"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
c	int
)	O
{	O
case	O
'h'	O
:	O
show_help	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
operation	pointer
=	O
del	int
;	O
operation_alters_arch	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'm'	O
:	O
operation	pointer
=	O
move	int
;	O
operation_alters_arch	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'p'	O
:	O
operation	pointer
=	O
print_files	int
;	O
break	O
;	O
case	O
'q'	O
:	O
operation	pointer
=	O
quick_append	int
;	O
operation_alters_arch	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'r'	O
:	O
operation	pointer
=	O
replace	int
;	O
operation_alters_arch	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
't'	O
:	O
operation	pointer
=	O
print_table	int
;	O
break	O
;	O
case	O
'x'	O
:	O
operation	pointer
=	O
extract	int
;	O
break	O
;	O
case	O
'l'	O
:	O
break	O
;	O
case	O
'c'	O
:	O
silent_create	int
=	O
1	int
;	O
break	O
;	O
case	O
'o'	O
:	O
preserve_dates	int
=	O
1	int
;	O
break	O
;	O
case	O
'O'	O
:	O
display_offsets	int
=	O
1	int
;	O
break	O
;	O
case	O
'V'	O
:	O
show_version	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
's'	O
:	O
write_armap	pointer
=	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
write_armap	pointer
=	O
-	O
1	int
;	O
break	O
;	O
case	O
'u'	O
:	O
newer_only	int
=	O
1	int
;	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
=	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
postype	enum
=	O
pos_after	int
;	O
break	O
;	O
case	O
'b'	O
:	O
postype	enum
=	O
pos_before	int
;	O
break	O
;	O
case	O
'i'	O
:	O
postype	enum
=	O
pos_before	int
;	O
break	O
;	O
case	O
'M'	O
:	O
mri_mode	int
=	O
1	int
;	O
break	O
;	O
case	O
'N'	O
:	O
counted_name_mode	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'f'	O
:	O
ar_truncate	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'P'	O
:	O
full_pathname	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'T'	O
:	O
make_thin_archive	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'D'	O
:	O
deterministic	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'U'	O
:	O
deterministic	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_PLUGIN	int
:	O
bfd_plugin_set_plugin	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_TARGET	int
:	O
target	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
OPTION_OUTPUT	int
:	O
output_dir	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
usage	function
(	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
operation	pointer
==	O
none	int
&&	O
write_armap	pointer
!=	O
1	int
&&	O
!	O
mri_mode	int
&&	O
optind	int
>	O
0	int
&&	O
optind	int
<	O
argc	int
)	O
{	O
argv	pointer
+=	O
(	O
optind	int
-	O
1	int
)	O
;	O
argc	int
-=	O
(	O
optind	int
-	O
1	int
)	O
;	O
optind	int
=	O
0	int
;	O
goto	O
restart	O
;	O
}	O
return	O
&	O
argv	pointer
[	O
optind	int
]	O
;	O
}	O
static	O
void	O
default_deterministic	function
(	O
void	O
)	O
{	O
if	O
(	O
deterministic	int
<	O
0	int
)	O
deterministic	int
=	O
DEFAULT_AR_DETERMINISTIC	int
;	O
}	O
static	O
void	O
ranlib_main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
arg_index	int
,	O
status	int
=	O
0	int
;	O
bfd_boolean	int
touch	int
=	O
FALSE	int
;	O
int	O
c	int
;	O
while	O
(	O
(	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"DhHUvVt"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'D'	O
:	O
deterministic	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'U'	O
:	O
deterministic	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'h'	O
:	O
case	O
'H'	O
:	O
show_help	int
=	O
1	int
;	O
break	O
;	O
case	O
't'	O
:	O
touch	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'v'	O
:	O
case	O
'V'	O
:	O
show_version	int
=	O
1	int
;	O
break	O
;	O
case	O
OPTION_PLUGIN	int
:	O
bfd_plugin_set_plugin	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
argc	int
<	O
2	int
)	O
ranlib_usage	function
(	O
0	int
)	O
;	O
if	O
(	O
show_help	int
)	O
ranlib_usage	function
(	O
1	int
)	O
;	O
if	O
(	O
show_version	int
)	O
print_version	function
(	O
"ranlib"	pointer
)	O
;	O
default_deterministic	function
(	O
)	O
;	O
arg_index	int
=	O
optind	int
;	O
while	O
(	O
arg_index	int
<	O
argc	int
)	O
{	O
if	O
(	O
!	O
touch	int
)	O
status	int
|=	O
ranlib_only	function
(	O
argv	pointer
[	O
arg_index	int
]	O
)	O
;	O
else	O
status	int
|=	O
ranlib_touch	function
(	O
argv	pointer
[	O
arg_index	int
]	O
)	O
;	O
++	O
arg_index	int
;	O
}	O
xexit	function
(	O
status	int
)	O
;	O
}	O
int	O
main	function
(	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
arg_index	int
;	O
char	O
*	O
*	O
files	pointer
;	O
int	O
file_count	int
;	O
char	O
*	O
inarch_filename	pointer
;	O
int	O
i	pointer
;	O
setlocale	function
(	O
LC_MESSAGES	O
,	O
""	pointer
)	O
;	O
setlocale	function
(	O
LC_CTYPE	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
program_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
xmalloc_set_program_name	function
(	O
program_name	pointer
)	O
;	O
bfd_set_error_program_name	function
(	O
program_name	pointer
)	O
;	O
bfd_plugin_set_program_name	function
(	O
program_name	pointer
)	O
;	O
expandargv	function
(	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
if	O
(	O
is_ranlib	int
<	O
0	int
)	O
{	O
const	O
char	O
*	O
temp	pointer
=	O
lbasename	function
(	O
program_name	pointer
)	O
;	O
if	O
(	O
strlen	function
(	O
temp	pointer
)	O
>=	O
6	int
&&	O
FILENAME_CMP	O
(	O
temp	pointer
+	O
strlen	function
(	O
temp	pointer
)	O
-	O
6	int
,	O
"ranlib"	pointer
)	O
==	O
0	int
)	O
is_ranlib	int
=	O
1	int
;	O
else	O
is_ranlib	int
=	O
0	int
;	O
}	O
START_PROGRESS	O
(	O
program_name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
bfd_init	function
(	O
)	O
!=	O
BFD_INIT_MAGIC	O
)	O
fatal	function
(	O
_	O
(	O
"fatal error: libbfd ABI mismatch"	pointer
)	O
)	O
;	O
set_default_bfd_target	function
(	O
)	O
;	O
xatexit	function
(	O
remove_output	function
)	O
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
argc	int
;	O
i	pointer
++	O
)	O
if	O
(	O
!	O
ar_emul_parse_arg	function
(	O
argv	pointer
[	O
i	pointer
]	O
)	O
)	O
break	O
;	O
argv	pointer
+=	O
(	O
i	pointer
-	O
1	int
)	O
;	O
argc	int
-=	O
(	O
i	pointer
-	O
1	int
)	O
;	O
if	O
(	O
is_ranlib	int
)	O
ranlib_main	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
usage	function
(	O
0	int
)	O
;	O
argv	pointer
=	O
decode_options	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
if	O
(	O
show_help	int
)	O
usage	function
(	O
1	int
)	O
;	O
if	O
(	O
show_version	int
)	O
print_version	function
(	O
"ar"	pointer
)	O
;	O
arg_index	int
=	O
0	int
;	O
if	O
(	O
mri_mode	int
)	O
{	O
default_deterministic	function
(	O
)	O
;	O
mri_emul	function
(	O
)	O
;	O
}	O
else	O
{	O
bfd	struct
*	O
arch	enum
;	O
if	O
(	O
argv	pointer
[	O
arg_index	int
]	O
==	O
NULL	O
)	O
usage	function
(	O
0	int
)	O
;	O
if	O
(	O
operation	pointer
==	O
quick_append	int
&&	O
write_armap	pointer
)	O
operation	pointer
=	O
replace	int
;	O
if	O
(	O
(	O
operation	pointer
==	O
none	int
||	O
operation	pointer
==	O
print_table	int
)	O
&&	O
write_armap	pointer
==	O
1	int
)	O
xexit	function
(	O
ranlib_only	function
(	O
argv	pointer
[	O
arg_index	int
]	O
)	O
)	O
;	O
if	O
(	O
operation	pointer
==	O
none	int
)	O
fatal	function
(	O
_	O
(	O
"no operation specified"	pointer
)	O
)	O
;	O
if	O
(	O
newer_only	int
&&	O
operation	pointer
!=	O
replace	int
)	O
fatal	function
(	O
_	O
(	O
"`u' is only meaningful with the `r' option."	pointer
)	O
)	O
;	O
if	O
(	O
newer_only	int
&&	O
deterministic	int
>	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"`u' is not meaningful with the `D' option."	pointer
)	O
)	O
;	O
if	O
(	O
newer_only	int
&&	O
deterministic	int
<	O
0	int
&&	O
DEFAULT_AR_DETERMINISTIC	int
)	O
non_fatal	function
(	O
_	O
(	O
"`u' modifier ignored since `D' is the default (see `U')"	pointer
)	O
)	O
;	O
default_deterministic	function
(	O
)	O
;	O
if	O
(	O
postype	enum
!=	O
pos_default	int
)	O
{	O
posname	pointer
=	O
argv	pointer
[	O
arg_index	int
++	O
]	O
;	O
if	O
(	O
posname	pointer
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"missing position arg."	pointer
)	O
)	O
;	O
}	O
if	O
(	O
counted_name_mode	int
)	O
{	O
if	O
(	O
operation	pointer
!=	O
extract	int
&&	O
operation	pointer
!=	O
del	int
)	O
fatal	function
(	O
_	O
(	O
"`N' is only meaningful with the `x' and `d' options."	pointer
)	O
)	O
;	O
if	O
(	O
argv	pointer
[	O
arg_index	int
]	O
==	O
NULL	O
)	O
fatal	function
(	O
_	O
(	O
"`N' missing value."	pointer
)	O
)	O
;	O
counted_name_counter	int
=	O
atoi	function
(	O
argv	pointer
[	O
arg_index	int
++	O
]	O
)	O
;	O
if	O
(	O
counted_name_counter	int
<=	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"Value for `N' must be positive."	pointer
)	O
)	O
;	O
}	O
inarch_filename	pointer
=	O
argv	pointer
[	O
arg_index	int
++	O
]	O
;	O
if	O
(	O
inarch_filename	pointer
==	O
NULL	O
)	O
usage	function
(	O
0	int
)	O
;	O
for	O
(	O
file_count	int
=	O
0	int
;	O
argv	pointer
[	O
arg_index	int
+	O
file_count	int
]	O
!=	O
NULL	O
;	O
file_count	int
++	O
)	O
continue	O
;	O
files	pointer
=	O
(	O
file_count	int
>	O
0	int
)	O
?	O
argv	pointer
+	O
arg_index	int
:	O
NULL	O
;	O
arch	enum
=	O
open_inarch	function
(	O
inarch_filename	pointer
,	O
files	pointer
==	O
NULL	O
?	O
(	O
char	O
*	O
)	O
NULL	O
:	O
files	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
operation	pointer
==	O
extract	int
&&	O
bfd_is_thin_archive	function
(	O
arch	enum
)	O
)	O
fatal	function
(	O
_	O
(	O
"`x' cannot be used on thin archives."	pointer
)	O
)	O
;	O
switch	O
(	O
operation	pointer
)	O
{	O
case	O
print_table	int
:	O
map_over_members	function
(	O
arch	enum
,	O
print_descr	function
,	O
files	pointer
,	O
file_count	int
)	O
;	O
break	O
;	O
case	O
print_files	int
:	O
map_over_members	function
(	O
arch	enum
,	O
print_contents	function
,	O
files	pointer
,	O
file_count	int
)	O
;	O
break	O
;	O
case	O
extract	int
:	O
map_over_members	function
(	O
arch	enum
,	O
extract_file	function
,	O
files	pointer
,	O
file_count	int
)	O
;	O
break	O
;	O
case	O
del	int
:	O
if	O
(	O
files	pointer
!=	O
NULL	O
)	O
delete_members	function
(	O
arch	enum
,	O
files	pointer
)	O
;	O
else	O
output_filename	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
move	int
:	O
if	O
(	O
!	O
silent_create	int
)	O
{	O
if	O
(	O
files	pointer
!=	O
NULL	O
)	O
move_members	function
(	O
arch	enum
,	O
files	pointer
)	O
;	O
else	O
output_filename	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
case	O
replace	int
:	O
case	O
quick_append	int
:	O
if	O
(	O
files	pointer
!=	O
NULL	O
||	O
write_armap	pointer
>	O
0	int
)	O
replace_members	function
(	O
arch	enum
,	O
files	pointer
,	O
operation	pointer
==	O
quick_append	int
)	O
;	O
else	O
output_filename	pointer
=	O
NULL	O
;	O
break	O
;	O
default	O
:	O
fatal	function
(	O
_	O
(	O
"internal error -- this option not implemented"	pointer
)	O
)	O
;	O
}	O
}	O
END_PROGRESS	O
(	O
program_name	pointer
)	O
;	O
xexit	function
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
bfd	struct
*	O
open_inarch	function
(	O
const	O
char	O
*	O
archive_filename	pointer
,	O
const	O
char	O
*	O
file	pointer
)	O
{	O
bfd	struct
*	O
*	O
last_one	pointer
;	O
bfd	struct
*	O
next_one	pointer
;	O
struct	O
stat	struct
sbuf	struct
;	O
bfd	struct
*	O
arch	enum
;	O
char	O
*	O
*	O
matching	pointer
;	O
bfd_set_error	function
(	O
bfd_error_no_error	int
)	O
;	O
if	O
(	O
target	pointer
==	O
NULL	O
)	O
target	pointer
=	O
plugin_target	pointer
;	O
if	O
(	O
stat	struct
(	O
archive_filename	pointer
,	O
&	O
sbuf	struct
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
bfd_fatal	function
(	O
archive_filename	pointer
)	O
;	O
if	O
(	O
!	O
operation_alters_arch	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
;	O
perror	function
(	O
archive_filename	pointer
)	O
;	O
maybequit	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
target	pointer
==	O
NULL	O
&&	O
file	pointer
!=	O
NULL	O
)	O
{	O
bfd	struct
*	O
obj	pointer
;	O
obj	pointer
=	O
bfd_openr	function
(	O
file	pointer
,	O
target	pointer
)	O
;	O
if	O
(	O
obj	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
bfd_check_format	function
(	O
obj	pointer
,	O
bfd_object	int
)	O
)	O
target	pointer
=	O
bfd_get_target	function
(	O
obj	pointer
)	O
;	O
(	O
void	O
)	O
bfd_close	function
(	O
obj	pointer
)	O
;	O
}	O
}	O
arch	enum
=	O
bfd_openw	function
(	O
archive_filename	pointer
,	O
target	pointer
)	O
;	O
if	O
(	O
arch	enum
==	O
NULL	O
||	O
!	O
bfd_set_format	function
(	O
arch	enum
,	O
bfd_archive	int
)	O
||	O
!	O
bfd_close	function
(	O
arch	enum
)	O
)	O
bfd_fatal	function
(	O
archive_filename	pointer
)	O
;	O
else	O
if	O
(	O
!	O
silent_create	int
)	O
non_fatal	function
(	O
_	O
(	O
"creating %s"	pointer
)	O
,	O
archive_filename	pointer
)	O
;	O
output_filename	pointer
=	O
archive_filename	pointer
;	O
}	O
arch	enum
=	O
bfd_openr	function
(	O
archive_filename	pointer
,	O
target	pointer
)	O
;	O
if	O
(	O
arch	enum
==	O
NULL	O
)	O
{	O
bloser	O
:	O
bfd_fatal	function
(	O
archive_filename	pointer
)	O
;	O
}	O
if	O
(	O
!	O
bfd_check_format_matches	function
(	O
arch	enum
,	O
bfd_archive	int
,	O
&	O
matching	pointer
)	O
)	O
{	O
bfd_nonfatal	function
(	O
archive_filename	pointer
)	O
;	O
if	O
(	O
bfd_get_error	function
(	O
)	O
==	O
bfd_error_file_ambiguously_recognized	int
)	O
{	O
list_matching_formats	function
(	O
matching	pointer
)	O
;	O
free	function
(	O
matching	pointer
)	O
;	O
}	O
xexit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
operation	pointer
==	O
replace	int
||	O
operation	pointer
==	O
quick_append	int
)	O
&&	O
bfd_openr_next_archived_file	function
(	O
arch	enum
,	O
NULL	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
make_thin_archive	int
&&	O
!	O
bfd_is_thin_archive	function
(	O
arch	enum
)	O
)	O
{	O
fatal	function
(	O
_	O
(	O
"Cannot convert existing library %s to thin format"	pointer
)	O
,	O
bfd_get_filename	function
(	O
arch	enum
)	O
)	O
;	O
goto	O
bloser	O
;	O
}	O
else	O
if	O
(	O
!	O
make_thin_archive	int
&&	O
bfd_is_thin_archive	function
(	O
arch	enum
)	O
)	O
{	O
fatal	function
(	O
_	O
(	O
"Cannot convert existing thin library %s to normal format"	pointer
)	O
,	O
bfd_get_filename	function
(	O
arch	enum
)	O
)	O
;	O
goto	O
bloser	O
;	O
}	O
}	O
last_one	pointer
=	O
&	O
(	O
arch	enum
->	O
archive_next	pointer
)	O
;	O
for	O
(	O
next_one	pointer
=	O
bfd_openr_next_archived_file	function
(	O
arch	enum
,	O
NULL	O
)	O
;	O
next_one	pointer
;	O
next_one	pointer
=	O
bfd_openr_next_archived_file	function
(	O
arch	enum
,	O
next_one	pointer
)	O
)	O
{	O
PROGRESS	O
(	O
1	int
)	O
;	O
*	O
last_one	pointer
=	O
next_one	pointer
;	O
last_one	pointer
=	O
&	O
next_one	pointer
->	O
archive_next	pointer
;	O
}	O
*	O
last_one	pointer
=	O
(	O
bfd	struct
*	O
)	O
NULL	O
;	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_no_more_archived_files	int
)	O
goto	O
bloser	O
;	O
return	O
arch	enum
;	O
}	O
static	O
void	O
print_contents	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_size_type	long
ncopied	long
=	O
0	int
;	O
bfd_size_type	long
size	int
;	O
char	O
*	O
cbuf	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
BUFSIZE	int
)	O
;	O
struct	O
stat	struct
buf	pointer
;	O
if	O
(	O
bfd_stat_arch_elt	O
(	O
abfd	pointer
,	O
&	O
buf	pointer
)	O
!=	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"internal stat error on %s"	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
"\n<%s>\n\n"	pointer
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
bfd_seek	function
(	O
abfd	pointer
,	O
(	O
file_ptr	long
)	O
0	int
,	O
SEEK_SET	int
)	O
;	O
size	int
=	O
buf	pointer
.	O
st_size	long
;	O
while	O
(	O
ncopied	long
<	O
size	int
)	O
{	O
bfd_size_type	long
nread	long
;	O
bfd_size_type	long
tocopy	long
=	O
size	int
-	O
ncopied	long
;	O
if	O
(	O
tocopy	long
>	O
BUFSIZE	int
)	O
tocopy	long
=	O
BUFSIZE	int
;	O
nread	long
=	O
bfd_bread	function
(	O
cbuf	pointer
,	O
tocopy	long
,	O
abfd	pointer
)	O
;	O
if	O
(	O
nread	long
!=	O
tocopy	long
)	O
fatal	function
(	O
_	O
(	O
"%s is not a valid archive"	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
->	O
my_archive	pointer
)	O
)	O
;	O
if	O
(	O
(	O
bfd_size_type	long
)	O
fwrite	function
(	O
cbuf	pointer
,	O
1	int
,	O
nread	long
,	O
stdout	pointer
)	O
!=	O
nread	long
)	O
fatal	function
(	O
"stdout: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
ncopied	long
+=	O
tocopy	long
;	O
}	O
free	function
(	O
cbuf	pointer
)	O
;	O
}	O
static	O
FILE	struct
*	O
open_output_file	function
(	O
bfd	struct
*	O
)	O
ATTRIBUTE_RETURNS_NONNULL	O
;	O
static	O
FILE	struct
*	O
open_output_file	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
output_filename	pointer
=	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
!	O
is_valid_archive_path	function
(	O
output_filename	pointer
)	O
)	O
{	O
char	O
*	O
base	int
=	O
(	O
char	O
*	O
)	O
lbasename	function
(	O
output_filename	pointer
)	O
;	O
non_fatal	function
(	O
_	O
(	O
"illegal output pathname for archive member: %s, using '%s' instead"	pointer
)	O
,	O
output_filename	pointer
,	O
base	int
)	O
;	O
output_filename	pointer
=	O
base	int
;	O
}	O
if	O
(	O
output_dir	pointer
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
output_dir	pointer
)	O
;	O
if	O
(	O
len	long
>	O
0	int
)	O
{	O
if	O
(	O
IS_DIR_SEPARATOR	O
(	O
output_dir	pointer
[	O
len	long
-	O
1	int
]	O
)	O
)	O
output_filename	pointer
=	O
concat	function
(	O
output_dir	pointer
,	O
output_filename	pointer
,	O
NULL	O
)	O
;	O
else	O
output_filename	pointer
=	O
concat	function
(	O
output_dir	pointer
,	O
"/"	pointer
,	O
output_filename	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
"x - %s\n"	pointer
,	O
output_filename	pointer
)	O
;	O
FILE	struct
*	O
ostream	pointer
=	O
fopen	function
(	O
output_filename	pointer
,	O
FOPEN_WB	pointer
)	O
;	O
if	O
(	O
ostream	pointer
==	O
NULL	O
)	O
{	O
perror	function
(	O
output_filename	pointer
)	O
;	O
xexit	function
(	O
1	int
)	O
;	O
}	O
return	O
ostream	pointer
;	O
}	O
void	O
extract_file	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
bfd_size_type	long
size	int
;	O
struct	O
stat	struct
buf	pointer
;	O
if	O
(	O
bfd_stat_arch_elt	O
(	O
abfd	pointer
,	O
&	O
buf	pointer
)	O
!=	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"internal stat error on %s"	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
)	O
)	O
;	O
size	int
=	O
buf	pointer
.	O
st_size	long
;	O
bfd_seek	function
(	O
abfd	pointer
,	O
(	O
file_ptr	long
)	O
0	int
,	O
SEEK_SET	int
)	O
;	O
output_file	pointer
=	O
NULL	O
;	O
if	O
(	O
size	int
==	O
0	int
)	O
{	O
output_file	pointer
=	O
open_output_file	function
(	O
abfd	pointer
)	O
;	O
}	O
else	O
{	O
bfd_size_type	long
ncopied	long
=	O
0	int
;	O
char	O
*	O
cbuf	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
BUFSIZE	int
)	O
;	O
while	O
(	O
ncopied	long
<	O
size	int
)	O
{	O
bfd_size_type	long
nread	long
,	O
tocopy	long
;	O
tocopy	long
=	O
size	int
-	O
ncopied	long
;	O
if	O
(	O
tocopy	long
>	O
BUFSIZE	int
)	O
tocopy	long
=	O
BUFSIZE	int
;	O
nread	long
=	O
bfd_bread	function
(	O
cbuf	pointer
,	O
tocopy	long
,	O
abfd	pointer
)	O
;	O
if	O
(	O
nread	long
!=	O
tocopy	long
)	O
fatal	function
(	O
_	O
(	O
"%s is not a valid archive"	pointer
)	O
,	O
bfd_get_filename	function
(	O
abfd	pointer
->	O
my_archive	pointer
)	O
)	O
;	O
if	O
(	O
output_file	pointer
==	O
NULL	O
)	O
output_file	pointer
=	O
open_output_file	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
(	O
bfd_size_type	long
)	O
fwrite	function
(	O
cbuf	pointer
,	O
1	int
,	O
nread	long
,	O
output_file	pointer
)	O
!=	O
nread	long
)	O
fatal	function
(	O
"%s: %s"	pointer
,	O
output_filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
ncopied	long
+=	O
tocopy	long
;	O
}	O
free	function
(	O
cbuf	pointer
)	O
;	O
}	O
fclose	function
(	O
output_file	pointer
)	O
;	O
output_file	pointer
=	O
NULL	O
;	O
chmod	function
(	O
output_filename	pointer
,	O
buf	pointer
.	O
st_mode	int
)	O
;	O
if	O
(	O
preserve_dates	int
)	O
{	O
buf	pointer
.	O
st_atime	O
=	O
buf	pointer
.	O
st_mtime	O
;	O
set_times	function
(	O
output_filename	pointer
,	O
&	O
buf	pointer
)	O
;	O
}	O
output_filename	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
write_archive	function
(	O
bfd	struct
*	O
iarch	pointer
)	O
{	O
bfd	struct
*	O
obfd	pointer
;	O
char	O
*	O
old_name	pointer
,	O
*	O
new_name	pointer
;	O
bfd	struct
*	O
contents_head	pointer
=	O
iarch	pointer
->	O
archive_next	pointer
;	O
old_name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
bfd_get_filename	function
(	O
iarch	pointer
)	O
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
old_name	pointer
,	O
bfd_get_filename	function
(	O
iarch	pointer
)	O
)	O
;	O
new_name	pointer
=	O
make_tempname	function
(	O
old_name	pointer
)	O
;	O
if	O
(	O
new_name	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
_	O
(	O
"could not create temporary file whilst writing archive"	pointer
)	O
)	O
;	O
output_filename	pointer
=	O
new_name	pointer
;	O
obfd	pointer
=	O
bfd_openw	function
(	O
new_name	pointer
,	O
bfd_get_target	function
(	O
iarch	pointer
)	O
)	O
;	O
if	O
(	O
obfd	pointer
==	O
NULL	O
)	O
bfd_fatal	function
(	O
old_name	pointer
)	O
;	O
output_bfd	pointer
=	O
obfd	pointer
;	O
bfd_set_format	function
(	O
obfd	pointer
,	O
bfd_archive	int
)	O
;	O
obfd	pointer
->	O
has_armap	int
=	O
write_armap	pointer
>=	O
0	int
;	O
if	O
(	O
ar_truncate	int
)	O
{	O
obfd	pointer
->	O
flags	int
|=	O
BFD_TRADITIONAL_FORMAT	int
;	O
}	O
if	O
(	O
deterministic	int
)	O
obfd	pointer
->	O
flags	int
|=	O
BFD_DETERMINISTIC_OUTPUT	int
;	O
if	O
(	O
full_pathname	int
)	O
obfd	pointer
->	O
flags	int
|=	O
BFD_ARCHIVE_FULL_PATH	int
;	O
if	O
(	O
make_thin_archive	int
||	O
bfd_is_thin_archive	function
(	O
iarch	pointer
)	O
)	O
bfd_set_thin_archive	function
(	O
obfd	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
!	O
bfd_set_archive_head	function
(	O
obfd	pointer
,	O
contents_head	pointer
)	O
)	O
bfd_fatal	function
(	O
old_name	pointer
)	O
;	O
if	O
(	O
!	O
bfd_close	function
(	O
obfd	pointer
)	O
)	O
bfd_fatal	function
(	O
old_name	pointer
)	O
;	O
output_bfd	pointer
=	O
NULL	O
;	O
output_filename	pointer
=	O
NULL	O
;	O
bfd_close	function
(	O
iarch	pointer
)	O
;	O
if	O
(	O
smart_rename	function
(	O
new_name	pointer
,	O
old_name	pointer
,	O
0	int
)	O
!=	O
0	int
)	O
xexit	function
(	O
1	int
)	O
;	O
free	function
(	O
old_name	pointer
)	O
;	O
free	function
(	O
new_name	pointer
)	O
;	O
}	O
static	O
bfd	struct
*	O
*	O
get_pos_bfd	function
(	O
bfd	struct
*	O
*	O
contents	pointer
,	O
enum	O
pos	long
default_pos	enum
,	O
const	O
char	O
*	O
default_posname	pointer
)	O
{	O
bfd	struct
*	O
*	O
after_bfd	pointer
=	O
contents	pointer
;	O
enum	O
pos	long
realpos	enum
;	O
const	O
char	O
*	O
realposname	pointer
;	O
if	O
(	O
postype	enum
==	O
pos_default	int
)	O
{	O
realpos	enum
=	O
default_pos	enum
;	O
realposname	pointer
=	O
default_posname	pointer
;	O
}	O
else	O
{	O
realpos	enum
=	O
postype	enum
;	O
realposname	pointer
=	O
posname	pointer
;	O
}	O
if	O
(	O
realpos	enum
==	O
pos_end	int
)	O
{	O
while	O
(	O
*	O
after_bfd	pointer
)	O
after_bfd	pointer
=	O
&	O
(	O
(	O
*	O
after_bfd	pointer
)	O
->	O
archive_next	pointer
)	O
;	O
}	O
else	O
{	O
for	O
(	O
;	O
*	O
after_bfd	pointer
;	O
after_bfd	pointer
=	O
&	O
(	O
*	O
after_bfd	pointer
)	O
->	O
archive_next	pointer
)	O
if	O
(	O
FILENAME_CMP	O
(	O
(	O
*	O
after_bfd	pointer
)	O
->	O
filename	pointer
,	O
realposname	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
realpos	enum
==	O
pos_after	int
)	O
after_bfd	pointer
=	O
&	O
(	O
*	O
after_bfd	pointer
)	O
->	O
archive_next	pointer
;	O
break	O
;	O
}	O
}	O
return	O
after_bfd	pointer
;	O
}	O
static	O
void	O
delete_members	function
(	O
bfd	struct
*	O
arch	enum
,	O
char	O
*	O
*	O
files_to_delete	pointer
)	O
{	O
bfd	struct
*	O
*	O
current_ptr_ptr	pointer
;	O
bfd_boolean	int
found	int
;	O
bfd_boolean	int
something_changed	int
=	O
FALSE	int
;	O
int	O
match_count	int
;	O
for	O
(	O
;	O
*	O
files_to_delete	pointer
!=	O
NULL	O
;	O
++	O
files_to_delete	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
files_to_delete	pointer
,	O
"__.SYMDEF"	pointer
)	O
)	O
{	O
arch	enum
->	O
has_armap	int
=	O
FALSE	int
;	O
write_armap	pointer
=	O
-	O
1	int
;	O
continue	O
;	O
}	O
found	int
=	O
FALSE	int
;	O
match_count	int
=	O
0	int
;	O
current_ptr_ptr	pointer
=	O
&	O
(	O
arch	enum
->	O
archive_next	pointer
)	O
;	O
while	O
(	O
*	O
current_ptr_ptr	pointer
)	O
{	O
if	O
(	O
FILENAME_CMP	O
(	O
normalize	function
(	O
*	O
files_to_delete	pointer
,	O
arch	enum
)	O
,	O
(	O
*	O
current_ptr_ptr	pointer
)	O
->	O
filename	pointer
)	O
==	O
0	int
)	O
{	O
++	O
match_count	int
;	O
if	O
(	O
counted_name_mode	int
&&	O
match_count	int
!=	O
counted_name_counter	int
)	O
{	O
}	O
else	O
{	O
found	int
=	O
TRUE	int
;	O
something_changed	int
=	O
TRUE	int
;	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
"d - %s\n"	pointer
,	O
*	O
files_to_delete	pointer
)	O
;	O
*	O
current_ptr_ptr	pointer
=	O
(	O
(	O
*	O
current_ptr_ptr	pointer
)	O
->	O
archive_next	pointer
)	O
;	O
goto	O
next_file	O
;	O
}	O
}	O
current_ptr_ptr	pointer
=	O
&	O
(	O
(	O
*	O
current_ptr_ptr	pointer
)	O
->	O
archive_next	pointer
)	O
;	O
}	O
if	O
(	O
verbose	int
&&	O
!	O
found	int
)	O
{	O
printf	function
(	O
_	O
(	O
"No member named `%s'\n"	pointer
)	O
,	O
*	O
files_to_delete	pointer
)	O
;	O
}	O
next_file	O
:	O
;	O
}	O
if	O
(	O
something_changed	int
)	O
write_archive	function
(	O
arch	enum
)	O
;	O
else	O
output_filename	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
move_members	function
(	O
bfd	struct
*	O
arch	enum
,	O
char	O
*	O
*	O
files_to_move	pointer
)	O
{	O
bfd	struct
*	O
*	O
after_bfd	pointer
;	O
bfd	struct
*	O
*	O
current_ptr_ptr	pointer
;	O
for	O
(	O
;	O
*	O
files_to_move	pointer
;	O
++	O
files_to_move	pointer
)	O
{	O
current_ptr_ptr	pointer
=	O
&	O
(	O
arch	enum
->	O
archive_next	pointer
)	O
;	O
while	O
(	O
*	O
current_ptr_ptr	pointer
)	O
{	O
bfd	struct
*	O
current_ptr	pointer
=	O
*	O
current_ptr_ptr	pointer
;	O
if	O
(	O
FILENAME_CMP	O
(	O
normalize	function
(	O
*	O
files_to_move	pointer
,	O
arch	enum
)	O
,	O
current_ptr	pointer
->	O
filename	pointer
)	O
==	O
0	int
)	O
{	O
bfd	struct
*	O
link_bfd	pointer
;	O
*	O
current_ptr_ptr	pointer
=	O
current_ptr	pointer
->	O
archive_next	pointer
;	O
after_bfd	pointer
=	O
get_pos_bfd	function
(	O
&	O
arch	enum
->	O
archive_next	pointer
,	O
pos_end	int
,	O
NULL	O
)	O
;	O
link_bfd	pointer
=	O
*	O
after_bfd	pointer
;	O
*	O
after_bfd	pointer
=	O
current_ptr	pointer
;	O
current_ptr	pointer
->	O
archive_next	pointer
=	O
link_bfd	pointer
;	O
if	O
(	O
verbose	int
)	O
printf	function
(	O
"m - %s\n"	pointer
,	O
*	O
files_to_move	pointer
)	O
;	O
goto	O
next_file	O
;	O
}	O
current_ptr_ptr	pointer
=	O
&	O
(	O
(	O
*	O
current_ptr_ptr	pointer
)	O
->	O
archive_next	pointer
)	O
;	O
}	O
fatal	function
(	O
_	O
(	O
"no entry %s in archive %s!"	pointer
)	O
,	O
*	O
files_to_move	pointer
,	O
arch	enum
->	O
filename	pointer
)	O
;	O
next_file	O
:	O
;	O
}	O
write_archive	function
(	O
arch	enum
)	O
;	O
}	O
static	O
void	O
replace_members	function
(	O
bfd	struct
*	O
arch	enum
,	O
char	O
*	O
*	O
files_to_move	pointer
,	O
bfd_boolean	int
quick	int
)	O
{	O
bfd_boolean	int
changed	int
=	O
FALSE	int
;	O
bfd	struct
*	O
*	O
after_bfd	pointer
;	O
bfd	struct
*	O
current	pointer
;	O
bfd	struct
*	O
*	O
current_ptr	pointer
;	O
while	O
(	O
files_to_move	pointer
&&	O
*	O
files_to_move	pointer
)	O
{	O
if	O
(	O
!	O
quick	int
)	O
{	O
current_ptr	pointer
=	O
&	O
arch	enum
->	O
archive_next	pointer
;	O
while	O
(	O
*	O
current_ptr	pointer
)	O
{	O
current	pointer
=	O
*	O
current_ptr	pointer
;	O
if	O
(	O
FILENAME_CMP	O
(	O
normalize	function
(	O
*	O
files_to_move	pointer
,	O
arch	enum
)	O
,	O
normalize	function
(	O
current	pointer
->	O
filename	pointer
,	O
arch	enum
)	O
)	O
==	O
0	int
&&	O
current	pointer
->	O
arelt_data	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
newer_only	int
)	O
{	O
struct	O
stat	struct
fsbuf	struct
,	O
asbuf	struct
;	O
if	O
(	O
stat	struct
(	O
*	O
files_to_move	pointer
,	O
&	O
fsbuf	struct
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
bfd_fatal	function
(	O
*	O
files_to_move	pointer
)	O
;	O
goto	O
next_file	O
;	O
}	O
if	O
(	O
bfd_stat_arch_elt	O
(	O
current	pointer
,	O
&	O
asbuf	struct
)	O
!=	O
0	int
)	O
fatal	function
(	O
_	O
(	O
"internal stat error on %s"	pointer
)	O
,	O
current	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
fsbuf	struct
.	O
st_mtime	O
<=	O
asbuf	struct
.	O
st_mtime	O
)	O
goto	O
next_file	O
;	O
}	O
after_bfd	pointer
=	O
get_pos_bfd	function
(	O
&	O
arch	enum
->	O
archive_next	pointer
,	O
pos_after	int
,	O
current	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
ar_emul_replace	function
(	O
after_bfd	pointer
,	O
*	O
files_to_move	pointer
,	O
target	pointer
,	O
verbose	int
)	O
)	O
{	O
*	O
current_ptr	pointer
=	O
(	O
*	O
current_ptr	pointer
)	O
->	O
archive_next	pointer
;	O
changed	int
=	O
TRUE	int
;	O
}	O
goto	O
next_file	O
;	O
}	O
current_ptr	pointer
=	O
&	O
(	O
current	pointer
->	O
archive_next	pointer
)	O
;	O
}	O
}	O
after_bfd	pointer
=	O
get_pos_bfd	function
(	O
&	O
arch	enum
->	O
archive_next	pointer
,	O
pos_end	int
,	O
NULL	O
)	O
;	O
if	O
(	O
ar_emul_append	function
(	O
after_bfd	pointer
,	O
*	O
files_to_move	pointer
,	O
target	pointer
,	O
verbose	int
,	O
make_thin_archive	int
)	O
)	O
changed	int
=	O
TRUE	int
;	O
next_file	O
:	O
;	O
files_to_move	pointer
++	O
;	O
}	O
if	O
(	O
changed	int
)	O
write_archive	function
(	O
arch	enum
)	O
;	O
else	O
output_filename	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
ranlib_only	function
(	O
const	O
char	O
*	O
archname	pointer
)	O
{	O
bfd	struct
*	O
arch	enum
;	O
if	O
(	O
get_file_size	function
(	O
archname	pointer
)	O
<	O
1	int
)	O
return	O
1	int
;	O
write_armap	pointer
=	O
1	int
;	O
arch	enum
=	O
open_inarch	function
(	O
archname	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
arch	enum
==	O
NULL	O
)	O
xexit	function
(	O
1	int
)	O
;	O
write_archive	function
(	O
arch	enum
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ranlib_touch	function
(	O
const	O
char	O
*	O
archname	pointer
)	O
{	O
int	O
f	int
;	O
bfd	struct
*	O
arch	enum
;	O
char	O
*	O
*	O
matching	pointer
;	O
if	O
(	O
get_file_size	function
(	O
archname	pointer
)	O
<	O
1	int
)	O
return	O
1	int
;	O
f	int
=	O
open	function
(	O
archname	pointer
,	O
O_RDWR	int
|	O
O_BINARY	int
,	O
0	int
)	O
;	O
if	O
(	O
f	int
<	O
0	int
)	O
{	O
bfd_set_error	function
(	O
bfd_error_system_call	int
)	O
;	O
bfd_fatal	function
(	O
archname	pointer
)	O
;	O
}	O
arch	enum
=	O
bfd_fdopenr	function
(	O
archname	pointer
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
f	int
)	O
;	O
if	O
(	O
arch	enum
==	O
NULL	O
)	O
bfd_fatal	function
(	O
archname	pointer
)	O
;	O
if	O
(	O
!	O
bfd_check_format_matches	function
(	O
arch	enum
,	O
bfd_archive	int
,	O
&	O
matching	pointer
)	O
)	O
{	O
bfd_nonfatal	function
(	O
archname	pointer
)	O
;	O
if	O
(	O
bfd_get_error	function
(	O
)	O
==	O
bfd_error_file_ambiguously_recognized	int
)	O
{	O
list_matching_formats	function
(	O
matching	pointer
)	O
;	O
free	function
(	O
matching	pointer
)	O
;	O
}	O
xexit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
bfd_has_map	function
(	O
arch	enum
)	O
)	O
fatal	function
(	O
_	O
(	O
"%s: no archive map to update"	pointer
)	O
,	O
archname	pointer
)	O
;	O
if	O
(	O
deterministic	int
)	O
arch	enum
->	O
flags	int
|=	O
BFD_DETERMINISTIC_OUTPUT	int
;	O
bfd_update_armap_timestamp	O
(	O
arch	enum
)	O
;	O
if	O
(	O
!	O
bfd_close	function
(	O
arch	enum
)	O
)	O
bfd_fatal	function
(	O
archname	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
print_descr	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
print_arelt_descr	function
(	O
stdout	pointer
,	O
abfd	pointer
,	O
verbose	int
,	O
display_offsets	int
)	O
;	O
}	O
