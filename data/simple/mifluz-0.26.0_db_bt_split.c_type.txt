static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: bt_split.c,v 1.7 2014/04/17 20:27:25 sebdiaz Exp $"	pointer
;	O
static	O
int	O
__bam_broot	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
PAGE	struct
*	O
,	O
PAGE	struct
*	O
,	O
PAGE	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_page	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
EPG	struct
*	O
,	O
EPG	struct
*	O
)	O
)	O
;	O
static	O
int	O
__bam_pinsert	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
EPG	struct
*	O
,	O
PAGE	struct
*	O
,	O
PAGE	struct
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
__bam_psplit	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
EPG	struct
*	O
,	O
PAGE	struct
*	O
,	O
PAGE	struct
*	O
,	O
db_indx_t	short
*	O
)	O
)	O
;	O
static	O
int	O
__bam_root	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
EPG	struct
*	O
)	O
)	O
;	O
static	O
int	O
__ram_root	function
__P	O
(	O
(	O
DBC	struct
*	O
,	O
PAGE	struct
*	O
,	O
PAGE	struct
*	O
,	O
PAGE	struct
*	O
)	O
)	O
;	O
int	O
CDB___bam_split	function
(	O
dbc	pointer
,	O
arg	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
void	O
*	O
arg	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
enum	O
{	O
UP	int
,	O
DOWN	int
}	O
dir	enum
;	O
db_pgno_t	int
root_pgno	int
;	O
int	O
exact	int
,	O
level	char
,	O
ret	int
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
root_pgno	int
=	O
cp	pointer
->	O
root	int
;	O
for	O
(	O
dir	enum
=	O
UP	int
,	O
level	char
=	O
LEAFLEVEL	int
;	O
;	O
dir	enum
==	O
UP	int
?	O
++	O
level	char
:	O
--	O
level	char
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
(	O
dbc	pointer
->	O
dbtype	enum
==	O
DB_BTREE	int
?	O
CDB___bam_search	function
(	O
dbc	pointer
,	O
arg	pointer
,	O
S_WRPAIR	O
,	O
level	char
,	O
NULL	O
,	O
&	O
exact	int
)	O
:	O
CDB___bam_rsearch	function
(	O
dbc	pointer
,	O
(	O
db_recno_t	int
*	O
)	O
arg	pointer
,	O
S_WRPAIR	O
,	O
level	char
,	O
&	O
exact	int
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
cp	pointer
->	O
ovflsize	short
*	O
2	int
<=	O
(	O
db_indx_t	short
)	O
P_FREESPACE	O
(	O
cp	pointer
->	O
csp	pointer
[	O
0	int
]	O
.	O
page	pointer
)	O
)	O
{	O
CDB___bam_stkrel	function
(	O
dbc	pointer
,	O
STK_NOLOCK	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
ret	int
=	O
cp	pointer
->	O
csp	pointer
[	O
0	int
]	O
.	O
page	pointer
->	O
pgno	int
==	O
root_pgno	int
?	O
__bam_root	function
(	O
dbc	pointer
,	O
&	O
cp	pointer
->	O
csp	pointer
[	O
0	int
]	O
)	O
:	O
__bam_page	function
(	O
dbc	pointer
,	O
&	O
cp	pointer
->	O
csp	pointer
[	O
-	O
1	int
]	O
,	O
&	O
cp	pointer
->	O
csp	pointer
[	O
0	int
]	O
)	O
;	O
BT_STK_CLR	O
(	O
cp	pointer
)	O
;	O
switch	O
(	O
ret	int
)	O
{	O
case	O
0	int
:	O
if	O
(	O
level	char
==	O
LEAFLEVEL	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
dir	enum
==	O
UP	int
)	O
dir	enum
=	O
DOWN	int
;	O
break	O
;	O
case	O
DB_NEEDSPLIT	O
:	O
if	O
(	O
dir	enum
==	O
DOWN	int
)	O
dir	enum
=	O
UP	int
;	O
break	O
;	O
default	O
:	O
return	O
(	O
ret	int
)	O
;	O
}	O
}	O
}	O
static	O
int	O
__bam_root	function
(	O
dbc	pointer
,	O
cp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
EPG	struct
*	O
cp	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
log_dbt	struct
;	O
DB_LSN	struct
log_lsn	struct
;	O
PAGE	struct
*	O
lp	pointer
,	O
*	O
rp	pointer
;	O
db_indx_t	short
split	short
;	O
u_int32_t	int
opflags	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
if	O
(	O
cp	pointer
->	O
page	pointer
->	O
level	char
>=	O
MAXBTREELEVEL	int
)	O
{	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"Too many btree levels: %d"	pointer
,	O
cp	pointer
->	O
page	pointer
->	O
level	char
)	O
;	O
ret	int
=	O
ENOSPC	int
;	O
goto	O
err	pointer
;	O
}	O
lp	pointer
=	O
rp	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_new	function
(	O
dbc	pointer
,	O
TYPE_TAGS	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
&	O
lp	pointer
)	O
)	O
!=	O
0	int
||	O
(	O
ret	int
=	O
CDB___db_new	function
(	O
dbc	pointer
,	O
TYPE_TAGS	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
&	O
rp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
P_INIT	O
(	O
lp	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
lp	pointer
->	O
pgno	int
,	O
PGNO_INVALID	int
,	O
ISINTERNAL	O
(	O
cp	pointer
->	O
page	pointer
)	O
?	O
PGNO_INVALID	int
:	O
rp	pointer
->	O
pgno	int
,	O
cp	pointer
->	O
page	pointer
->	O
level	char
,	O
TYPE	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
TAGS	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
;	O
P_INIT	O
(	O
rp	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
rp	pointer
->	O
pgno	int
,	O
ISINTERNAL	O
(	O
cp	pointer
->	O
page	pointer
)	O
?	O
PGNO_INVALID	int
:	O
lp	pointer
->	O
pgno	int
,	O
PGNO_INVALID	int
,	O
cp	pointer
->	O
page	pointer
->	O
level	char
,	O
TYPE	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
TAGS	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__bam_psplit	function
(	O
dbc	pointer
,	O
cp	pointer
,	O
lp	pointer
,	O
rp	pointer
,	O
&	O
split	short
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
memset	function
(	O
&	O
log_dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
log_dbt	struct
)	O
)	O
;	O
log_dbt	struct
.	O
data	pointer
=	O
cp	pointer
->	O
page	pointer
;	O
log_dbt	struct
.	O
size	int
=	O
dbp	pointer
->	O
pgsize	int
;	O
ZERO_LSN	O
(	O
log_lsn	struct
)	O
;	O
opflags	int
=	O
F_ISSET	O
(	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
,	O
C_RECNUM	int
)	O
?	O
SPL_NRECS	int
:	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_split_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
lp	pointer
)	O
,	O
&	O
LSN	O
(	O
lp	pointer
)	O
,	O
PGNO	O
(	O
rp	pointer
)	O
,	O
&	O
LSN	O
(	O
rp	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
NUM_ENT	O
(	O
lp	pointer
)	O
,	O
0	int
,	O
&	O
log_lsn	struct
,	O
dbc	pointer
->	O
internal	pointer
->	O
root	int
,	O
&	O
log_dbt	struct
,	O
opflags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
LSN	O
(	O
lp	pointer
)	O
=	O
LSN	O
(	O
rp	pointer
)	O
=	O
LSN	O
(	O
cp	pointer
->	O
page	pointer
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
(	O
dbc	pointer
->	O
dbtype	enum
==	O
DB_RECNO	int
?	O
__ram_root	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
lp	pointer
,	O
rp	pointer
)	O
:	O
__bam_broot	function
(	O
dbc	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
lp	pointer
,	O
rp	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
CDB___bam_ca_split	function
(	O
dbp	pointer
,	O
cp	pointer
->	O
page	pointer
->	O
pgno	int
,	O
lp	pointer
->	O
pgno	int
,	O
rp	pointer
->	O
pgno	int
,	O
split	short
,	O
1	int
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
lp	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
rp	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
lp	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB___db_free	function
(	O
dbc	pointer
,	O
lp	pointer
)	O
;	O
if	O
(	O
rp	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB___db_free	function
(	O
dbc	pointer
,	O
rp	pointer
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
0	int
)	O
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_page	function
(	O
dbc	pointer
,	O
pp	pointer
,	O
cp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
EPG	struct
*	O
pp	pointer
,	O
*	O
cp	pointer
;	O
{	O
BTREE_CURSOR	struct
*	O
bc	pointer
;	O
DBT	struct
log_dbt	struct
;	O
DB_LSN	struct
log_lsn	struct
;	O
DB	struct
*	O
dbp	pointer
;	O
DB_LOCK	struct
tplock	struct
;	O
DB_LSN	struct
save_lsn	struct
;	O
PAGE	struct
*	O
lp	pointer
,	O
*	O
rp	pointer
,	O
*	O
alloc_rp	pointer
,	O
*	O
tp	pointer
;	O
db_indx_t	short
split	short
;	O
u_int32_t	int
opflags	int
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
alloc_rp	pointer
=	O
lp	pointer
=	O
rp	pointer
=	O
tp	pointer
=	O
NULL	O
;	O
tplock	struct
.	O
off	long
=	O
LOCK_INVALID	O
;	O
ret	int
=	O
-	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
NULL	O
,	O
&	O
rp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
P_INIT	O
(	O
rp	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
0	int
,	O
ISINTERNAL	O
(	O
cp	pointer
->	O
page	pointer
)	O
?	O
PGNO_INVALID	int
:	O
PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
ISINTERNAL	O
(	O
cp	pointer
->	O
page	pointer
)	O
?	O
PGNO_INVALID	int
:	O
NEXT_PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
cp	pointer
->	O
page	pointer
->	O
level	char
,	O
TYPE	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
TAGS	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
NULL	O
,	O
&	O
lp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
P_INIT	O
(	O
lp	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
ISINTERNAL	O
(	O
cp	pointer
->	O
page	pointer
)	O
?	O
PGNO_INVALID	int
:	O
PREV_PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
ISINTERNAL	O
(	O
cp	pointer
->	O
page	pointer
)	O
?	O
PGNO_INVALID	int
:	O
0	int
,	O
cp	pointer
->	O
page	pointer
->	O
level	char
,	O
TYPE	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
TAGS	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__bam_psplit	function
(	O
dbc	pointer
,	O
cp	pointer
,	O
lp	pointer
,	O
rp	pointer
,	O
&	O
split	short
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__bam_pinsert	function
(	O
dbc	pointer
,	O
pp	pointer
,	O
lp	pointer
,	O
rp	pointer
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
ISLEAF	O
(	O
cp	pointer
->	O
page	pointer
)	O
&&	O
NEXT_PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
!=	O
PGNO_INVALID	int
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_lget	function
(	O
dbc	pointer
,	O
0	int
,	O
NEXT_PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
DB_LOCK_WRITE	int
,	O
0	int
,	O
&	O
tplock	struct
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB_memp_fget	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
&	O
NEXT_PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
0	int
,	O
&	O
tp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_new	function
(	O
dbc	pointer
,	O
TYPE_TAGS	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
&	O
alloc_rp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
PGNO	O
(	O
rp	pointer
)	O
=	O
NEXT_PGNO	O
(	O
lp	pointer
)	O
=	O
PGNO	O
(	O
alloc_rp	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__bam_pinsert	function
(	O
dbc	pointer
,	O
pp	pointer
,	O
lp	pointer
,	O
rp	pointer
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
bc	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
)	O
{	O
memset	function
(	O
&	O
log_dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
log_dbt	struct
)	O
)	O
;	O
log_dbt	struct
.	O
data	pointer
=	O
cp	pointer
->	O
page	pointer
;	O
log_dbt	struct
.	O
size	int
=	O
dbp	pointer
->	O
pgsize	int
;	O
if	O
(	O
tp	pointer
==	O
NULL	O
)	O
ZERO_LSN	O
(	O
log_lsn	struct
)	O
;	O
opflags	int
=	O
F_ISSET	O
(	O
bc	pointer
,	O
C_RECNUM	int
)	O
?	O
SPL_NRECS	int
:	O
0	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_split_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
&	O
LSN	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
PGNO	O
(	O
alloc_rp	pointer
)	O
,	O
&	O
LSN	O
(	O
alloc_rp	pointer
)	O
,	O
(	O
u_int32_t	int
)	O
NUM_ENT	O
(	O
lp	pointer
)	O
,	O
tp	pointer
==	O
NULL	O
?	O
0	int
:	O
PGNO	O
(	O
tp	pointer
)	O
,	O
tp	pointer
==	O
NULL	O
?	O
&	O
log_lsn	struct
:	O
&	O
LSN	O
(	O
tp	pointer
)	O
,	O
bc	pointer
->	O
root	int
,	O
&	O
log_dbt	struct
,	O
opflags	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
LSN	O
(	O
alloc_rp	pointer
)	O
=	O
LSN	O
(	O
lp	pointer
)	O
=	O
LSN	O
(	O
rp	pointer
)	O
=	O
LSN	O
(	O
cp	pointer
->	O
page	pointer
)	O
;	O
if	O
(	O
tp	pointer
!=	O
NULL	O
)	O
LSN	O
(	O
tp	pointer
)	O
=	O
LSN	O
(	O
cp	pointer
->	O
page	pointer
)	O
;	O
}	O
save_lsn	struct
=	O
alloc_rp	pointer
->	O
lsn	struct
;	O
memcpy	function
(	O
alloc_rp	pointer
,	O
rp	pointer
,	O
LOFFSET	O
(	O
rp	pointer
)	O
)	O
;	O
memcpy	function
(	O
(	O
u_int8_t	char
*	O
)	O
alloc_rp	pointer
+	O
HOFFSET	O
(	O
rp	pointer
)	O
,	O
(	O
u_int8_t	char
*	O
)	O
rp	pointer
+	O
HOFFSET	O
(	O
rp	pointer
)	O
,	O
dbp	pointer
->	O
pgsize	int
-	O
HOFFSET	O
(	O
rp	pointer
)	O
)	O
;	O
alloc_rp	pointer
->	O
lsn	struct
=	O
save_lsn	struct
;	O
save_lsn	struct
=	O
cp	pointer
->	O
page	pointer
->	O
lsn	struct
;	O
memcpy	function
(	O
cp	pointer
->	O
page	pointer
,	O
lp	pointer
,	O
LOFFSET	O
(	O
lp	pointer
)	O
)	O
;	O
memcpy	function
(	O
(	O
u_int8_t	char
*	O
)	O
cp	pointer
->	O
page	pointer
+	O
HOFFSET	O
(	O
lp	pointer
)	O
,	O
(	O
u_int8_t	char
*	O
)	O
lp	pointer
+	O
HOFFSET	O
(	O
lp	pointer
)	O
,	O
dbp	pointer
->	O
pgsize	int
-	O
HOFFSET	O
(	O
lp	pointer
)	O
)	O
;	O
cp	pointer
->	O
page	pointer
->	O
lsn	struct
=	O
save_lsn	struct
;	O
if	O
(	O
tp	pointer
!=	O
NULL	O
)	O
PREV_PGNO	O
(	O
tp	pointer
)	O
=	O
PGNO	O
(	O
rp	pointer
)	O
;	O
CDB___bam_ca_split	function
(	O
dbp	pointer
,	O
PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
PGNO	O
(	O
cp	pointer
->	O
page	pointer
)	O
,	O
PGNO	O
(	O
rp	pointer
)	O
,	O
split	short
,	O
0	int
)	O
;	O
CDB___os_free	function
(	O
lp	pointer
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
CDB___os_free	function
(	O
rp	pointer
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
alloc_rp	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
pp	pointer
->	O
page	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
pp	pointer
->	O
lock	struct
)	O
;	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
;	O
if	O
(	O
tp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
t_ret	int
=	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
tp	pointer
,	O
DB_MPOOL_DIRTY	int
)	O
)	O
!=	O
0	int
&&	O
ret	int
==	O
0	int
)	O
ret	int
=	O
t_ret	int
;	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
tplock	struct
)	O
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
err	pointer
:	O
if	O
(	O
lp	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
lp	pointer
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
if	O
(	O
rp	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
rp	pointer
,	O
dbp	pointer
->	O
pgsize	int
)	O
;	O
if	O
(	O
alloc_rp	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB___db_free	function
(	O
dbc	pointer
,	O
alloc_rp	pointer
)	O
;	O
if	O
(	O
tp	pointer
!=	O
NULL	O
)	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
tp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
tplock	struct
.	O
off	long
!=	O
LOCK_INVALID	O
)	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
tplock	struct
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
pp	pointer
->	O
page	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ret	int
==	O
DB_NEEDSPLIT	O
)	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
pp	pointer
->	O
lock	struct
)	O
;	O
else	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
pp	pointer
->	O
lock	struct
)	O
;	O
(	O
void	O
)	O
CDB_memp_fput	function
(	O
dbp	pointer
->	O
mpf	pointer
,	O
cp	pointer
->	O
page	pointer
,	O
0	int
)	O
;	O
if	O
(	O
ret	int
==	O
DB_NEEDSPLIT	O
)	O
(	O
void	O
)	O
__LPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
;	O
else	O
(	O
void	O
)	O
__TLPUT	O
(	O
dbc	pointer
,	O
cp	pointer
->	O
lock	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__bam_broot	function
(	O
dbc	pointer
,	O
rootp	pointer
,	O
lp	pointer
,	O
rp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
PAGE	struct
*	O
rootp	pointer
,	O
*	O
lp	pointer
,	O
*	O
rp	pointer
;	O
{	O
BINTERNAL	struct
bi	struct
,	O
*	O
child_bi	pointer
;	O
BKEYDATA	struct
*	O
child_bk	pointer
;	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
hdr	struct
,	O
data	pointer
;	O
db_pgno_t	int
root_pgno	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
root_pgno	int
=	O
cp	pointer
->	O
root	int
;	O
P_INIT	O
(	O
rootp	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
root_pgno	int
,	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
lp	pointer
->	O
level	char
+	O
1	int
,	O
P_IBTREE	int
,	O
TAGS	O
(	O
lp	pointer
)	O
)	O
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
memset	function
(	O
&	O
hdr	struct
,	O
0	int
,	O
sizeof	O
(	O
hdr	struct
)	O
)	O
;	O
memset	function
(	O
&	O
bi	struct
,	O
0	int
,	O
sizeof	O
(	O
bi	struct
)	O
)	O
;	O
bi	struct
.	O
len	short
=	O
0	int
;	O
B_TSET	O
(	O
bi	struct
.	O
type	enum
,	O
B_KEYDATA	int
,	O
0	int
)	O
;	O
bi	struct
.	O
pgno	int
=	O
lp	pointer
->	O
pgno	int
;	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
)	O
{	O
bi	struct
.	O
nrecs	int
=	O
CDB___bam_total	function
(	O
lp	pointer
)	O
;	O
RE_NREC_SET	O
(	O
rootp	pointer
,	O
bi	struct
.	O
nrecs	int
)	O
;	O
}	O
hdr	struct
.	O
data	pointer
=	O
&	O
bi	struct
;	O
hdr	struct
.	O
size	int
=	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
rootp	pointer
,	O
0	int
,	O
BINTERNAL_SIZE	O
(	O
0	int
)	O
,	O
&	O
hdr	struct
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
switch	O
(	O
TYPE	O
(	O
rp	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
child_bi	pointer
=	O
GET_BINTERNAL	O
(	O
rp	pointer
,	O
0	int
)	O
;	O
bi	struct
.	O
len	short
=	O
child_bi	pointer
->	O
len	short
;	O
B_TSET	O
(	O
bi	struct
.	O
type	enum
,	O
child_bi	pointer
->	O
type	enum
,	O
0	int
)	O
;	O
bi	struct
.	O
pgno	int
=	O
rp	pointer
->	O
pgno	int
;	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
)	O
{	O
bi	struct
.	O
nrecs	int
=	O
CDB___bam_total	function
(	O
rp	pointer
)	O
;	O
RE_NREC_ADJ	O
(	O
rootp	pointer
,	O
bi	struct
.	O
nrecs	int
)	O
;	O
}	O
hdr	struct
.	O
data	pointer
=	O
&	O
bi	struct
;	O
hdr	struct
.	O
size	int
=	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
;	O
data	pointer
.	O
data	pointer
=	O
child_bi	pointer
->	O
data	pointer
;	O
data	pointer
.	O
size	int
=	O
child_bi	pointer
->	O
len	short
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
rootp	pointer
,	O
1	int
,	O
BINTERNAL_SIZE	O
(	O
child_bi	pointer
->	O
len	short
)	O
,	O
&	O
hdr	struct
,	O
&	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
child_bi	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ovref	function
(	O
dbc	pointer
,	O
(	O
(	O
BOVERFLOW	struct
*	O
)	O
(	O
child_bi	pointer
->	O
data	pointer
)	O
)	O
->	O
pgno	int
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
case	O
P_LDUP	int
:	O
case	O
P_LBTREE	int
:	O
child_bk	pointer
=	O
GET_BKEYDATA	O
(	O
rp	pointer
,	O
0	int
)	O
;	O
switch	O
(	O
B_TYPE	O
(	O
child_bk	pointer
->	O
type	enum
)	O
)	O
{	O
case	O
B_KEYDATA	int
:	O
bi	struct
.	O
len	short
=	O
child_bk	pointer
->	O
len	short
;	O
B_TSET	O
(	O
bi	struct
.	O
type	enum
,	O
child_bk	pointer
->	O
type	enum
,	O
0	int
)	O
;	O
bi	struct
.	O
pgno	int
=	O
rp	pointer
->	O
pgno	int
;	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
)	O
{	O
bi	struct
.	O
nrecs	int
=	O
CDB___bam_total	function
(	O
rp	pointer
)	O
;	O
RE_NREC_ADJ	O
(	O
rootp	pointer
,	O
bi	struct
.	O
nrecs	int
)	O
;	O
}	O
hdr	struct
.	O
data	pointer
=	O
&	O
bi	struct
;	O
hdr	struct
.	O
size	int
=	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
;	O
data	pointer
.	O
data	pointer
=	O
child_bk	pointer
->	O
data	pointer
;	O
data	pointer
.	O
size	int
=	O
child_bk	pointer
->	O
len	short
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
rootp	pointer
,	O
1	int
,	O
BINTERNAL_SIZE	O
(	O
child_bk	pointer
->	O
len	short
)	O
,	O
&	O
hdr	struct
,	O
&	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
case	O
B_DUPLICATE	int
:	O
case	O
B_OVERFLOW	int
:	O
bi	struct
.	O
len	short
=	O
BOVERFLOW_SIZE	O
;	O
B_TSET	O
(	O
bi	struct
.	O
type	enum
,	O
child_bk	pointer
->	O
type	enum
,	O
0	int
)	O
;	O
bi	struct
.	O
pgno	int
=	O
rp	pointer
->	O
pgno	int
;	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
)	O
{	O
bi	struct
.	O
nrecs	int
=	O
CDB___bam_total	function
(	O
rp	pointer
)	O
;	O
RE_NREC_ADJ	O
(	O
rootp	pointer
,	O
bi	struct
.	O
nrecs	int
)	O
;	O
}	O
hdr	struct
.	O
data	pointer
=	O
&	O
bi	struct
;	O
hdr	struct
.	O
size	int
=	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
;	O
data	pointer
.	O
data	pointer
=	O
child_bk	pointer
;	O
data	pointer
.	O
size	int
=	O
BOVERFLOW_SIZE	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
rootp	pointer
,	O
1	int
,	O
BINTERNAL_SIZE	O
(	O
BOVERFLOW_SIZE	O
)	O
,	O
&	O
hdr	struct
,	O
&	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
child_bk	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ovref	function
(	O
dbc	pointer
,	O
(	O
(	O
BOVERFLOW	struct
*	O
)	O
child_bk	pointer
)	O
->	O
pgno	int
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
rp	pointer
->	O
pgno	int
)	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
rp	pointer
->	O
pgno	int
)	O
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__ram_root	function
(	O
dbc	pointer
,	O
rootp	pointer
,	O
lp	pointer
,	O
rp	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
PAGE	struct
*	O
rootp	pointer
,	O
*	O
lp	pointer
,	O
*	O
rp	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
hdr	struct
;	O
RINTERNAL	struct
ri	struct
;	O
db_pgno_t	int
root_pgno	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
root_pgno	int
=	O
dbc	pointer
->	O
internal	pointer
->	O
root	int
;	O
P_INIT	O
(	O
rootp	pointer
,	O
dbp	pointer
->	O
pgsize	int
,	O
root_pgno	int
,	O
PGNO_INVALID	int
,	O
PGNO_INVALID	int
,	O
lp	pointer
->	O
level	char
+	O
1	int
,	O
P_IRECNO	int
,	O
TAGS	O
(	O
lp	pointer
)	O
)	O
;	O
memset	function
(	O
&	O
hdr	struct
,	O
0	int
,	O
sizeof	O
(	O
hdr	struct
)	O
)	O
;	O
hdr	struct
.	O
data	pointer
=	O
&	O
ri	struct
;	O
hdr	struct
.	O
size	int
=	O
RINTERNAL_SIZE	O
;	O
ri	struct
.	O
pgno	int
=	O
lp	pointer
->	O
pgno	int
;	O
ri	struct
.	O
nrecs	int
=	O
CDB___bam_total	function
(	O
lp	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
rootp	pointer
,	O
0	int
,	O
RINTERNAL_SIZE	O
,	O
&	O
hdr	struct
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
RE_NREC_SET	O
(	O
rootp	pointer
,	O
ri	struct
.	O
nrecs	int
)	O
;	O
ri	struct
.	O
pgno	int
=	O
rp	pointer
->	O
pgno	int
;	O
ri	struct
.	O
nrecs	int
=	O
CDB___bam_total	function
(	O
rp	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
rootp	pointer
,	O
1	int
,	O
RINTERNAL_SIZE	O
,	O
&	O
hdr	struct
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
RE_NREC_ADJ	O
(	O
rootp	pointer
,	O
ri	struct
.	O
nrecs	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__bam_pinsert	function
(	O
dbc	pointer
,	O
parent	pointer
,	O
lchild	pointer
,	O
rchild	pointer
,	O
space_check	int
)	O
DBC	struct
*	O
dbc	pointer
;	O
EPG	struct
*	O
parent	pointer
;	O
PAGE	struct
*	O
lchild	pointer
,	O
*	O
rchild	pointer
;	O
int	O
space_check	int
;	O
{	O
BINTERNAL	struct
bi	struct
,	O
*	O
child_bi	pointer
;	O
BKEYDATA	struct
*	O
child_bk	pointer
,	O
*	O
tmp_bk	pointer
;	O
BTREE	struct
*	O
t	pointer
;	O
BTREE_CURSOR	struct
*	O
cp	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
DBT	struct
a	struct
,	O
b	struct
,	O
hdr	struct
,	O
data	pointer
;	O
PAGE	struct
*	O
ppage	pointer
;	O
RINTERNAL	struct
ri	struct
;	O
db_indx_t	short
off	long
;	O
db_recno_t	int
nrecs	int
;	O
size_t	long
(	O
*	O
func	pointer
)	O
__P	O
(	O
(	O
const	O
DBT	struct
*	O
,	O
const	O
DBT	struct
*	O
)	O
)	O
;	O
u_int32_t	int
n	int
,	O
nbytes	long
,	O
nksize	int
;	O
int	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
cp	pointer
=	O
(	O
BTREE_CURSOR	struct
*	O
)	O
dbc	pointer
->	O
internal	pointer
;	O
t	pointer
=	O
dbp	pointer
->	O
bt_internal	pointer
;	O
ppage	pointer
=	O
parent	pointer
->	O
page	pointer
;	O
nrecs	int
=	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
&&	O
!	O
space_check	int
?	O
CDB___bam_total	function
(	O
rchild	pointer
)	O
:	O
0	int
;	O
off	long
=	O
parent	pointer
->	O
indx	short
+	O
O_INDX	int
;	O
switch	O
(	O
TYPE	O
(	O
rchild	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
child_bi	pointer
=	O
GET_BINTERNAL	O
(	O
rchild	pointer
,	O
0	int
)	O
;	O
nbytes	long
=	O
BINTERNAL_PSIZE	O
(	O
child_bi	pointer
->	O
len	short
)	O
;	O
if	O
(	O
P_FREESPACE	O
(	O
ppage	pointer
)	O
<	O
nbytes	long
)	O
return	O
(	O
DB_NEEDSPLIT	O
)	O
;	O
if	O
(	O
space_check	int
)	O
return	O
(	O
0	int
)	O
;	O
memset	function
(	O
&	O
bi	struct
,	O
0	int
,	O
sizeof	O
(	O
bi	struct
)	O
)	O
;	O
bi	struct
.	O
len	short
=	O
child_bi	pointer
->	O
len	short
;	O
B_TSET	O
(	O
bi	struct
.	O
type	enum
,	O
child_bi	pointer
->	O
type	enum
,	O
0	int
)	O
;	O
bi	struct
.	O
pgno	int
=	O
rchild	pointer
->	O
pgno	int
;	O
bi	struct
.	O
nrecs	int
=	O
nrecs	int
;	O
memset	function
(	O
&	O
hdr	struct
,	O
0	int
,	O
sizeof	O
(	O
hdr	struct
)	O
)	O
;	O
hdr	struct
.	O
data	pointer
=	O
&	O
bi	struct
;	O
hdr	struct
.	O
size	int
=	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
data	pointer
.	O
data	pointer
=	O
child_bi	pointer
->	O
data	pointer
;	O
data	pointer
.	O
size	int
=	O
child_bi	pointer
->	O
len	short
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
ppage	pointer
,	O
off	long
,	O
BINTERNAL_SIZE	O
(	O
child_bi	pointer
->	O
len	short
)	O
,	O
&	O
hdr	struct
,	O
&	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
child_bi	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ovref	function
(	O
dbc	pointer
,	O
(	O
(	O
BOVERFLOW	struct
*	O
)	O
(	O
child_bi	pointer
->	O
data	pointer
)	O
)	O
->	O
pgno	int
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
case	O
P_LDUP	int
:	O
case	O
P_LBTREE	int
:	O
child_bk	pointer
=	O
GET_BKEYDATA	O
(	O
rchild	pointer
,	O
0	int
)	O
;	O
switch	O
(	O
B_TYPE	O
(	O
child_bk	pointer
->	O
type	enum
)	O
)	O
{	O
case	O
B_KEYDATA	int
:	O
if	O
(	O
F_ISSET	O
(	O
dbc	pointer
,	O
DBC_OPD	int
)	O
)	O
{	O
if	O
(	O
dbp	pointer
->	O
dup_compare	pointer
==	O
CDB___bam_defcmp	function
)	O
func	pointer
=	O
CDB___bam_defpfx	function
;	O
else	O
func	pointer
=	O
NULL	O
;	O
}	O
else	O
func	pointer
=	O
t	pointer
->	O
bt_prefix	pointer
;	O
nbytes	long
=	O
BINTERNAL_PSIZE	O
(	O
child_bk	pointer
->	O
len	short
)	O
;	O
nksize	int
=	O
child_bk	pointer
->	O
len	short
;	O
if	O
(	O
func	pointer
==	O
NULL	O
)	O
goto	O
noprefix	O
;	O
if	O
(	O
ppage	pointer
->	O
prev_pgno	int
==	O
PGNO_INVALID	int
&&	O
off	long
<=	O
1	int
)	O
goto	O
noprefix	O
;	O
tmp_bk	pointer
=	O
GET_BKEYDATA	O
(	O
lchild	pointer
,	O
NUM_ENT	O
(	O
lchild	pointer
)	O
-	O
(	O
TYPE	O
(	O
lchild	pointer
)	O
==	O
P_LDUP	int
?	O
O_INDX	int
:	O
P_INDX	int
)	O
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
tmp_bk	pointer
->	O
type	enum
)	O
!=	O
B_KEYDATA	int
)	O
goto	O
noprefix	O
;	O
memset	function
(	O
&	O
a	struct
,	O
0	int
,	O
sizeof	O
(	O
a	struct
)	O
)	O
;	O
a	struct
.	O
size	int
=	O
tmp_bk	pointer
->	O
len	short
;	O
a	struct
.	O
data	pointer
=	O
tmp_bk	pointer
->	O
data	pointer
;	O
memset	function
(	O
&	O
b	struct
,	O
0	int
,	O
sizeof	O
(	O
b	struct
)	O
)	O
;	O
b	struct
.	O
size	int
=	O
child_bk	pointer
->	O
len	short
;	O
b	struct
.	O
data	pointer
=	O
child_bk	pointer
->	O
data	pointer
;	O
nksize	int
=	O
func	pointer
(	O
&	O
a	struct
,	O
&	O
b	struct
)	O
;	O
if	O
(	O
(	O
n	int
=	O
BINTERNAL_PSIZE	O
(	O
nksize	int
)	O
)	O
<	O
nbytes	long
)	O
nbytes	long
=	O
n	int
;	O
else	O
noprefix	O
:	O
nksize	int
=	O
child_bk	pointer
->	O
len	short
;	O
if	O
(	O
P_FREESPACE	O
(	O
ppage	pointer
)	O
<	O
nbytes	long
)	O
return	O
(	O
DB_NEEDSPLIT	O
)	O
;	O
if	O
(	O
space_check	int
)	O
return	O
(	O
0	int
)	O
;	O
memset	function
(	O
&	O
bi	struct
,	O
0	int
,	O
sizeof	O
(	O
bi	struct
)	O
)	O
;	O
bi	struct
.	O
len	short
=	O
nksize	int
;	O
B_TSET	O
(	O
bi	struct
.	O
type	enum
,	O
child_bk	pointer
->	O
type	enum
,	O
0	int
)	O
;	O
bi	struct
.	O
pgno	int
=	O
rchild	pointer
->	O
pgno	int
;	O
bi	struct
.	O
nrecs	int
=	O
nrecs	int
;	O
memset	function
(	O
&	O
hdr	struct
,	O
0	int
,	O
sizeof	O
(	O
hdr	struct
)	O
)	O
;	O
hdr	struct
.	O
data	pointer
=	O
&	O
bi	struct
;	O
hdr	struct
.	O
size	int
=	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
data	pointer
.	O
data	pointer
=	O
child_bk	pointer
->	O
data	pointer
;	O
data	pointer
.	O
size	int
=	O
nksize	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
ppage	pointer
,	O
off	long
,	O
BINTERNAL_SIZE	O
(	O
nksize	int
)	O
,	O
&	O
hdr	struct
,	O
&	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
case	O
B_DUPLICATE	int
:	O
case	O
B_OVERFLOW	int
:	O
nbytes	long
=	O
BINTERNAL_PSIZE	O
(	O
BOVERFLOW_SIZE	O
)	O
;	O
if	O
(	O
P_FREESPACE	O
(	O
ppage	pointer
)	O
<	O
nbytes	long
)	O
return	O
(	O
DB_NEEDSPLIT	O
)	O
;	O
if	O
(	O
space_check	int
)	O
return	O
(	O
0	int
)	O
;	O
memset	function
(	O
&	O
bi	struct
,	O
0	int
,	O
sizeof	O
(	O
bi	struct
)	O
)	O
;	O
bi	struct
.	O
len	short
=	O
BOVERFLOW_SIZE	O
;	O
B_TSET	O
(	O
bi	struct
.	O
type	enum
,	O
child_bk	pointer
->	O
type	enum
,	O
0	int
)	O
;	O
bi	struct
.	O
pgno	int
=	O
rchild	pointer
->	O
pgno	int
;	O
bi	struct
.	O
nrecs	int
=	O
nrecs	int
;	O
memset	function
(	O
&	O
hdr	struct
,	O
0	int
,	O
sizeof	O
(	O
hdr	struct
)	O
)	O
;	O
hdr	struct
.	O
data	pointer
=	O
&	O
bi	struct
;	O
hdr	struct
.	O
size	int
=	O
SSZA	O
(	O
BINTERNAL	struct
,	O
data	pointer
)	O
;	O
memset	function
(	O
&	O
data	pointer
,	O
0	int
,	O
sizeof	O
(	O
data	pointer
)	O
)	O
;	O
data	pointer
.	O
data	pointer
=	O
child_bk	pointer
;	O
data	pointer
.	O
size	int
=	O
BOVERFLOW_SIZE	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
ppage	pointer
,	O
off	long
,	O
BINTERNAL_SIZE	O
(	O
BOVERFLOW_SIZE	O
)	O
,	O
&	O
hdr	struct
,	O
&	O
data	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
B_TYPE	O
(	O
child_bk	pointer
->	O
type	enum
)	O
==	O
B_OVERFLOW	int
)	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_ovref	function
(	O
dbc	pointer
,	O
(	O
(	O
BOVERFLOW	struct
*	O
)	O
child_bk	pointer
)	O
->	O
pgno	int
,	O
1	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
rchild	pointer
->	O
pgno	int
)	O
)	O
;	O
}	O
break	O
;	O
case	O
P_IRECNO	int
:	O
case	O
P_LRECNO	int
:	O
nbytes	long
=	O
RINTERNAL_PSIZE	O
;	O
if	O
(	O
P_FREESPACE	O
(	O
ppage	pointer
)	O
<	O
nbytes	long
)	O
return	O
(	O
DB_NEEDSPLIT	O
)	O
;	O
if	O
(	O
space_check	int
)	O
return	O
(	O
0	int
)	O
;	O
memset	function
(	O
&	O
hdr	struct
,	O
0	int
,	O
sizeof	O
(	O
hdr	struct
)	O
)	O
;	O
hdr	struct
.	O
data	pointer
=	O
&	O
ri	struct
;	O
hdr	struct
.	O
size	int
=	O
RINTERNAL_SIZE	O
;	O
ri	struct
.	O
pgno	int
=	O
rchild	pointer
->	O
pgno	int
;	O
ri	struct
.	O
nrecs	int
=	O
nrecs	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_pitem	function
(	O
dbc	pointer
,	O
ppage	pointer
,	O
off	long
,	O
RINTERNAL_SIZE	O
,	O
&	O
hdr	struct
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
rchild	pointer
->	O
pgno	int
)	O
)	O
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
cp	pointer
,	O
C_RECNUM	int
)	O
)	O
{	O
if	O
(	O
DB_LOGGING	O
(	O
dbc	pointer
)	O
&&	O
(	O
ret	int
=	O
CDB___bam_cadjust_log	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
dbc	pointer
->	O
txn	pointer
,	O
&	O
LSN	O
(	O
ppage	pointer
)	O
,	O
0	int
,	O
dbp	pointer
->	O
log_fileid	int
,	O
PGNO	O
(	O
ppage	pointer
)	O
,	O
&	O
LSN	O
(	O
ppage	pointer
)	O
,	O
parent	pointer
->	O
indx	short
,	O
-	O
(	O
int32_t	int
)	O
nrecs	int
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
dbc	pointer
->	O
dbtype	enum
==	O
DB_RECNO	int
)	O
GET_RINTERNAL	O
(	O
ppage	pointer
,	O
parent	pointer
->	O
indx	short
)	O
->	O
nrecs	int
-=	O
nrecs	int
;	O
else	O
GET_BINTERNAL	O
(	O
ppage	pointer
,	O
parent	pointer
->	O
indx	short
)	O
->	O
nrecs	int
-=	O
nrecs	int
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__bam_psplit	function
(	O
dbc	pointer
,	O
cp	pointer
,	O
lp	pointer
,	O
rp	pointer
,	O
splitret	pointer
)	O
DBC	struct
*	O
dbc	pointer
;	O
EPG	struct
*	O
cp	pointer
;	O
PAGE	struct
*	O
lp	pointer
,	O
*	O
rp	pointer
;	O
db_indx_t	short
*	O
splitret	pointer
;	O
{	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
pp	pointer
;	O
db_indx_t	short
half	short
,	O
nbytes	long
,	O
off	long
,	O
splitp	short
,	O
top	short
;	O
int	O
adjust	int
,	O
cnt	int
,	O
iflag	int
,	O
isbigkey	int
,	O
ret	int
;	O
dbp	pointer
=	O
dbc	pointer
->	O
dbp	pointer
;	O
pp	pointer
=	O
cp	pointer
->	O
page	pointer
;	O
adjust	int
=	O
TYPE	O
(	O
pp	pointer
)	O
==	O
P_LBTREE	int
?	O
P_INDX	int
:	O
O_INDX	int
;	O
off	long
=	O
0	int
;	O
if	O
(	O
NEXT_PGNO	O
(	O
pp	pointer
)	O
==	O
PGNO_INVALID	int
&&	O
(	O
(	O
ISINTERNAL	O
(	O
pp	pointer
)	O
&&	O
cp	pointer
->	O
indx	short
==	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
-	O
1	int
)	O
||	O
(	O
!	O
ISINTERNAL	O
(	O
pp	pointer
)	O
&&	O
cp	pointer
->	O
indx	short
==	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
)	O
)	O
)	O
off	long
=	O
NUM_ENT	O
(	O
cp	pointer
->	O
page	pointer
)	O
-	O
adjust	int
;	O
else	O
if	O
(	O
PREV_PGNO	O
(	O
pp	pointer
)	O
==	O
PGNO_INVALID	int
&&	O
cp	pointer
->	O
indx	short
==	O
0	int
)	O
off	long
=	O
adjust	int
;	O
if	O
(	O
off	long
!=	O
0	int
)	O
goto	O
sort	O
;	O
top	short
=	O
NUM_ENT	O
(	O
pp	pointer
)	O
-	O
adjust	int
;	O
half	short
=	O
(	O
dbp	pointer
->	O
pgsize	int
-	O
HOFFSET	O
(	O
pp	pointer
)	O
)	O
/	O
2	int
;	O
for	O
(	O
nbytes	long
=	O
0	int
,	O
off	long
=	O
0	int
;	O
off	long
<	O
top	short
&&	O
nbytes	long
<	O
half	short
;	O
++	O
off	long
)	O
switch	O
(	O
TYPE	O
(	O
pp	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
if	O
(	O
B_TYPE	O
(	O
GET_BINTERNAL	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
type	enum
)	O
==	O
B_KEYDATA	int
)	O
nbytes	long
+=	O
BINTERNAL_SIZE	O
(	O
GET_BINTERNAL	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
len	short
)	O
;	O
else	O
nbytes	long
+=	O
BINTERNAL_SIZE	O
(	O
BOVERFLOW_SIZE	O
)	O
;	O
break	O
;	O
case	O
P_LBTREE	int
:	O
if	O
(	O
B_TYPE	O
(	O
GET_BKEYDATA	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
type	enum
)	O
==	O
B_KEYDATA	int
)	O
nbytes	long
+=	O
BKEYDATA_SIZE	O
(	O
GET_BKEYDATA	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
len	short
)	O
;	O
else	O
nbytes	long
+=	O
BOVERFLOW_SIZE	O
;	O
++	O
off	long
;	O
case	O
P_LDUP	int
:	O
case	O
P_LRECNO	int
:	O
if	O
(	O
B_TYPE	O
(	O
GET_BKEYDATA	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
type	enum
)	O
==	O
B_KEYDATA	int
)	O
nbytes	long
+=	O
BKEYDATA_SIZE	O
(	O
GET_BKEYDATA	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
len	short
)	O
;	O
else	O
nbytes	long
+=	O
BOVERFLOW_SIZE	O
;	O
break	O
;	O
case	O
P_IRECNO	int
:	O
nbytes	long
+=	O
RINTERNAL_SIZE	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
pp	pointer
->	O
pgno	int
)	O
)	O
;	O
}	O
sort	O
:	O
splitp	short
=	O
off	long
;	O
switch	O
(	O
TYPE	O
(	O
pp	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
iflag	int
=	O
1	int
;	O
isbigkey	int
=	O
B_TYPE	O
(	O
GET_BINTERNAL	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
type	enum
)	O
!=	O
B_KEYDATA	int
;	O
break	O
;	O
case	O
P_LBTREE	int
:	O
case	O
P_LDUP	int
:	O
iflag	int
=	O
0	int
;	O
isbigkey	int
=	O
B_TYPE	O
(	O
GET_BKEYDATA	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
type	enum
)	O
!=	O
B_KEYDATA	int
;	O
break	O
;	O
default	O
:	O
iflag	int
=	O
isbigkey	int
=	O
0	int
;	O
}	O
if	O
(	O
isbigkey	int
)	O
for	O
(	O
cnt	int
=	O
1	int
;	O
cnt	int
<=	O
3	int
;	O
++	O
cnt	int
)	O
{	O
off	long
=	O
splitp	short
+	O
cnt	int
*	O
adjust	int
;	O
if	O
(	O
off	long
<	O
(	O
db_indx_t	short
)	O
NUM_ENT	O
(	O
pp	pointer
)	O
&&	O
(	O
(	O
iflag	int
&&	O
B_TYPE	O
(	O
GET_BINTERNAL	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
type	enum
)	O
==	O
B_KEYDATA	int
)	O
||	O
B_TYPE	O
(	O
GET_BKEYDATA	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
type	enum
)	O
==	O
B_KEYDATA	int
)	O
)	O
{	O
splitp	short
=	O
off	long
;	O
break	O
;	O
}	O
if	O
(	O
splitp	short
<=	O
(	O
db_indx_t	short
)	O
(	O
cnt	int
*	O
adjust	int
)	O
)	O
continue	O
;	O
off	long
=	O
splitp	short
-	O
cnt	int
*	O
adjust	int
;	O
if	O
(	O
iflag	int
?	O
B_TYPE	O
(	O
GET_BINTERNAL	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
type	enum
)	O
==	O
B_KEYDATA	int
:	O
B_TYPE	O
(	O
GET_BKEYDATA	O
(	O
pp	pointer
,	O
off	long
)	O
->	O
type	enum
)	O
==	O
B_KEYDATA	int
)	O
{	O
splitp	short
=	O
off	long
;	O
break	O
;	O
}	O
}	O
if	O
(	O
TYPE	O
(	O
pp	pointer
)	O
==	O
P_LBTREE	int
&&	O
pp	pointer
->	O
inp	array
[	O
splitp	short
]	O
==	O
pp	pointer
->	O
inp	array
[	O
splitp	short
-	O
adjust	int
]	O
)	O
for	O
(	O
cnt	int
=	O
1	int
;	O
;	O
++	O
cnt	int
)	O
{	O
off	long
=	O
splitp	short
+	O
cnt	int
*	O
adjust	int
;	O
if	O
(	O
off	long
<	O
NUM_ENT	O
(	O
pp	pointer
)	O
&&	O
pp	pointer
->	O
inp	array
[	O
splitp	short
]	O
!=	O
pp	pointer
->	O
inp	array
[	O
off	long
]	O
)	O
{	O
splitp	short
=	O
off	long
;	O
break	O
;	O
}	O
if	O
(	O
splitp	short
<=	O
(	O
db_indx_t	short
)	O
(	O
cnt	int
*	O
adjust	int
)	O
)	O
continue	O
;	O
off	long
=	O
splitp	short
-	O
cnt	int
*	O
adjust	int
;	O
if	O
(	O
pp	pointer
->	O
inp	array
[	O
splitp	short
]	O
!=	O
pp	pointer
->	O
inp	array
[	O
off	long
]	O
)	O
{	O
splitp	short
=	O
off	long
+	O
adjust	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_copy	function
(	O
dbp	pointer
,	O
pp	pointer
,	O
lp	pointer
,	O
0	int
,	O
splitp	short
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___bam_copy	function
(	O
dbp	pointer
,	O
pp	pointer
,	O
rp	pointer
,	O
splitp	short
,	O
NUM_ENT	O
(	O
pp	pointer
)	O
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
*	O
splitret	pointer
=	O
splitp	short
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
CDB___bam_copy	function
(	O
dbp	pointer
,	O
pp	pointer
,	O
cp	pointer
,	O
nxt	int
,	O
stop	int
)	O
DB	struct
*	O
dbp	pointer
;	O
PAGE	struct
*	O
pp	pointer
,	O
*	O
cp	pointer
;	O
u_int32_t	int
nxt	int
,	O
stop	int
;	O
{	O
db_indx_t	short
nbytes	long
,	O
off	long
;	O
for	O
(	O
off	long
=	O
0	int
;	O
nxt	int
<	O
stop	int
;	O
++	O
nxt	int
,	O
++	O
NUM_ENT	O
(	O
cp	pointer
)	O
,	O
++	O
off	long
)	O
{	O
switch	O
(	O
TYPE	O
(	O
pp	pointer
)	O
)	O
{	O
case	O
P_IBTREE	int
:	O
if	O
(	O
B_TYPE	O
(	O
GET_BINTERNAL	O
(	O
pp	pointer
,	O
nxt	int
)	O
->	O
type	enum
)	O
==	O
B_KEYDATA	int
)	O
nbytes	long
=	O
BINTERNAL_SIZE	O
(	O
GET_BINTERNAL	O
(	O
pp	pointer
,	O
nxt	int
)	O
->	O
len	short
)	O
;	O
else	O
nbytes	long
=	O
BINTERNAL_SIZE	O
(	O
BOVERFLOW_SIZE	O
)	O
;	O
break	O
;	O
case	O
P_LBTREE	int
:	O
if	O
(	O
off	long
!=	O
0	int
&&	O
(	O
nxt	int
%	O
P_INDX	int
)	O
==	O
0	int
&&	O
pp	pointer
->	O
inp	array
[	O
nxt	int
]	O
==	O
pp	pointer
->	O
inp	array
[	O
nxt	int
-	O
P_INDX	int
]	O
)	O
{	O
cp	pointer
->	O
inp	array
[	O
off	long
]	O
=	O
cp	pointer
->	O
inp	array
[	O
off	long
-	O
P_INDX	int
]	O
;	O
continue	O
;	O
}	O
case	O
P_LDUP	int
:	O
case	O
P_LRECNO	int
:	O
if	O
(	O
B_TYPE	O
(	O
GET_BKEYDATA	O
(	O
pp	pointer
,	O
nxt	int
)	O
->	O
type	enum
)	O
==	O
B_KEYDATA	int
)	O
nbytes	long
=	O
BKEYDATA_SIZE	O
(	O
GET_BKEYDATA	O
(	O
pp	pointer
,	O
nxt	int
)	O
->	O
len	short
)	O
;	O
else	O
nbytes	long
=	O
BOVERFLOW_SIZE	O
;	O
break	O
;	O
case	O
P_IRECNO	int
:	O
nbytes	long
=	O
RINTERNAL_SIZE	O
;	O
break	O
;	O
default	O
:	O
return	O
(	O
CDB___db_pgfmt	function
(	O
dbp	pointer
,	O
pp	pointer
->	O
pgno	int
)	O
)	O
;	O
}	O
cp	pointer
->	O
inp	array
[	O
off	long
]	O
=	O
HOFFSET	O
(	O
cp	pointer
)	O
-=	O
nbytes	long
;	O
memcpy	function
(	O
P_ENTRY	O
(	O
cp	pointer
,	O
off	long
)	O
,	O
P_ENTRY	O
(	O
pp	pointer
,	O
nxt	int
)	O
,	O
nbytes	long
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
