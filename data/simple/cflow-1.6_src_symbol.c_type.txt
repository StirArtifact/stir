static	O
Hash_table	struct
*	O
symbol_table	pointer
;	O
static	O
struct	O
linked_list	struct
*	O
static_symbol_list	pointer
;	O
static	O
struct	O
linked_list	struct
*	O
auto_symbol_list	pointer
;	O
static	O
struct	O
linked_list	struct
*	O
static_func_list	pointer
;	O
static	O
struct	O
linked_list	struct
*	O
unit_local_list	pointer
;	O
static	O
void	O
append_symbol	function
(	O
struct	O
linked_list	struct
*	O
*	O
plist	pointer
,	O
Symbol	struct
*	O
sp	pointer
)	O
{	O
if	O
(	O
sp	pointer
->	O
entry	pointer
)	O
{	O
linked_list_unlink	function
(	O
sp	pointer
->	O
entry	pointer
->	O
list	pointer
,	O
sp	pointer
->	O
entry	pointer
)	O
;	O
sp	pointer
->	O
entry	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
data_in_list	function
(	O
sp	pointer
,	O
*	O
plist	pointer
)	O
)	O
{	O
linked_list_append	function
(	O
plist	pointer
,	O
sp	pointer
)	O
;	O
sp	pointer
->	O
entry	pointer
=	O
(	O
*	O
plist	pointer
)	O
->	O
tail	pointer
;	O
}	O
}	O
struct	O
table_entry	struct
{	O
Symbol	struct
*	O
sym	pointer
;	O
}	O
;	O
static	O
size_t	long
hash_symbol_hasher	function
(	O
void	O
const	O
*	O
data	pointer
,	O
size_t	long
n_buckets	long
)	O
{	O
struct	O
table_entry	struct
const	O
*	O
t	pointer
=	O
data	pointer
;	O
if	O
(	O
!	O
t	pointer
->	O
sym	pointer
)	O
return	O
(	O
(	O
size_t	long
)	O
data	pointer
)	O
%	O
n_buckets	long
;	O
return	O
hash_string	function
(	O
t	pointer
->	O
sym	pointer
->	O
name	pointer
,	O
n_buckets	long
)	O
;	O
}	O
static	O
bool	bool
hash_symbol_compare	function
(	O
void	O
const	O
*	O
data1	pointer
,	O
void	O
const	O
*	O
data2	pointer
)	O
{	O
struct	O
table_entry	struct
const	O
*	O
t1	pointer
=	O
data1	pointer
;	O
struct	O
table_entry	struct
const	O
*	O
t2	pointer
=	O
data2	pointer
;	O
return	O
t1	pointer
->	O
sym	pointer
&&	O
t2	pointer
->	O
sym	pointer
&&	O
strcmp	function
(	O
t1	pointer
->	O
sym	pointer
->	O
name	pointer
,	O
t2	pointer
->	O
sym	pointer
->	O
name	pointer
)	O
==	O
0	int
;	O
}	O
Symbol	struct
*	O
lookup	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
Symbol	struct
s	long
,	O
*	O
sym	pointer
;	O
struct	O
table_entry	struct
t	pointer
,	O
*	O
tp	pointer
;	O
if	O
(	O
!	O
symbol_table	pointer
)	O
return	O
NULL	O
;	O
s	long
.	O
name	pointer
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
t	pointer
.	O
sym	pointer
=	O
&	O
s	long
;	O
tp	pointer
=	O
hash_lookup	function
(	O
symbol_table	pointer
,	O
&	O
t	pointer
)	O
;	O
if	O
(	O
tp	pointer
)	O
{	O
sym	pointer
=	O
tp	pointer
->	O
sym	pointer
;	O
while	O
(	O
sym	pointer
->	O
type	enum
==	O
SymToken	int
&&	O
sym	pointer
->	O
flag	pointer
==	O
symbol_alias	int
)	O
sym	pointer
=	O
sym	pointer
->	O
alias	pointer
;	O
}	O
else	O
sym	pointer
=	O
NULL	O
;	O
return	O
sym	pointer
;	O
}	O
Symbol	struct
*	O
install	function
(	O
char	O
*	O
name	pointer
,	O
int	O
flags	int
)	O
{	O
Symbol	struct
*	O
sym	pointer
;	O
struct	O
table_entry	struct
*	O
tp	pointer
,	O
*	O
ret	pointer
;	O
sym	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
sym	pointer
)	O
)	O
;	O
memset	function
(	O
sym	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
sym	pointer
)	O
)	O
;	O
sym	pointer
->	O
type	enum
=	O
SymUndefined	int
;	O
sym	pointer
->	O
name	pointer
=	O
name	pointer
;	O
tp	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
tp	pointer
)	O
)	O
;	O
tp	pointer
->	O
sym	pointer
=	O
sym	pointer
;	O
if	O
(	O
(	O
(	O
flags	int
&	O
INSTALL_CHECK_LOCAL	int
)	O
&&	O
canonical_filename	pointer
&&	O
strcmp	function
(	O
filename	pointer
,	O
canonical_filename	pointer
)	O
)	O
||	O
(	O
flags	int
&	O
INSTALL_UNIT_LOCAL	int
)	O
)	O
{	O
sym	pointer
->	O
flag	pointer
=	O
symbol_local	int
;	O
append_symbol	function
(	O
&	O
static_symbol_list	pointer
,	O
sym	pointer
)	O
;	O
}	O
else	O
sym	pointer
->	O
flag	pointer
=	O
symbol_none	int
;	O
if	O
(	O
!	O
(	O
(	O
symbol_table	pointer
||	O
(	O
symbol_table	pointer
=	O
hash_initialize	function
(	O
0	int
,	O
0	int
,	O
hash_symbol_hasher	function
,	O
hash_symbol_compare	function
,	O
0	int
)	O
)	O
)	O
&&	O
(	O
ret	pointer
=	O
hash_insert	function
(	O
symbol_table	pointer
,	O
tp	pointer
)	O
)	O
)	O
)	O
xalloc_die	function
(	O
)	O
;	O
if	O
(	O
ret	pointer
!=	O
tp	pointer
)	O
{	O
if	O
(	O
flags	int
&	O
INSTALL_OVERWRITE	int
)	O
{	O
free	function
(	O
sym	pointer
)	O
;	O
free	function
(	O
tp	pointer
)	O
;	O
return	O
ret	pointer
->	O
sym	pointer
;	O
}	O
if	O
(	O
ret	pointer
->	O
sym	pointer
->	O
type	enum
!=	O
SymUndefined	int
)	O
sym	pointer
->	O
next	pointer
=	O
ret	pointer
->	O
sym	pointer
;	O
ret	pointer
->	O
sym	pointer
=	O
sym	pointer
;	O
free	function
(	O
tp	pointer
)	O
;	O
}	O
sym	pointer
->	O
owner	pointer
=	O
ret	pointer
;	O
return	O
sym	pointer
;	O
}	O
void	O
ident_change_storage	function
(	O
Symbol	struct
*	O
sp	pointer
,	O
enum	O
storage	enum
storage	enum
)	O
{	O
if	O
(	O
sp	pointer
->	O
storage	enum
==	O
storage	enum
)	O
return	O
;	O
if	O
(	O
sp	pointer
->	O
storage	enum
==	O
StaticStorage	int
)	O
;	O
switch	O
(	O
storage	enum
)	O
{	O
case	O
StaticStorage	int
:	O
append_symbol	function
(	O
&	O
static_symbol_list	pointer
,	O
sp	pointer
)	O
;	O
break	O
;	O
case	O
AutoStorage	int
:	O
append_symbol	function
(	O
&	O
auto_symbol_list	pointer
,	O
sp	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
sp	pointer
->	O
storage	enum
=	O
storage	enum
;	O
}	O
Symbol	struct
*	O
install_ident	function
(	O
char	O
*	O
name	pointer
,	O
enum	O
storage	enum
storage	enum
)	O
{	O
Symbol	struct
*	O
sp	pointer
;	O
sp	pointer
=	O
install	function
(	O
name	pointer
,	O
storage	enum
!=	O
AutoStorage	int
?	O
INSTALL_CHECK_LOCAL	int
:	O
INSTALL_DEFAULT	int
)	O
;	O
sp	pointer
->	O
type	enum
=	O
SymIdentifier	int
;	O
sp	pointer
->	O
arity	int
=	O
-	O
1	int
;	O
sp	pointer
->	O
storage	enum
=	O
ExternStorage	int
;	O
sp	pointer
->	O
decl	pointer
=	O
NULL	O
;	O
sp	pointer
->	O
source	pointer
=	O
NULL	O
;	O
sp	pointer
->	O
def_line	int
=	O
-	O
1	int
;	O
sp	pointer
->	O
ref_line	pointer
=	O
NULL	O
;	O
sp	pointer
->	O
caller	pointer
=	O
sp	pointer
->	O
callee	pointer
=	O
NULL	O
;	O
sp	pointer
->	O
level	int
=	O
-	O
1	int
;	O
ident_change_storage	function
(	O
sp	pointer
,	O
storage	enum
)	O
;	O
return	O
sp	pointer
;	O
}	O
static	O
void	O
unlink_symbol	function
(	O
Symbol	struct
*	O
sym	pointer
)	O
{	O
Symbol	struct
*	O
s	long
,	O
*	O
prev	pointer
=	O
NULL	O
;	O
struct	O
table_entry	struct
*	O
tp	pointer
=	O
sym	pointer
->	O
owner	pointer
;	O
for	O
(	O
s	long
=	O
tp	pointer
->	O
sym	pointer
;	O
s	long
;	O
)	O
{	O
Symbol	struct
*	O
next	pointer
=	O
s	long
->	O
next	pointer
;	O
if	O
(	O
s	long
==	O
sym	pointer
)	O
{	O
if	O
(	O
prev	pointer
)	O
prev	pointer
->	O
next	pointer
=	O
next	pointer
;	O
else	O
tp	pointer
->	O
sym	pointer
=	O
next	pointer
;	O
break	O
;	O
}	O
else	O
prev	pointer
=	O
s	long
;	O
s	long
=	O
next	pointer
;	O
}	O
sym	pointer
->	O
owner	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
delete_symbol	function
(	O
Symbol	struct
*	O
sym	pointer
)	O
{	O
unlink_symbol	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
sym	pointer
->	O
ref_line	pointer
==	O
NULL	O
&&	O
!	O
(	O
reverse_tree	int
&&	O
sym	pointer
->	O
callee	pointer
)	O
)	O
{	O
linked_list_destroy	function
(	O
&	O
sym	pointer
->	O
ref_line	pointer
)	O
;	O
linked_list_destroy	function
(	O
&	O
sym	pointer
->	O
caller	pointer
)	O
;	O
linked_list_destroy	function
(	O
&	O
sym	pointer
->	O
callee	pointer
)	O
;	O
free	function
(	O
sym	pointer
)	O
;	O
}	O
}	O
static	O
void	O
static_free	function
(	O
void	O
*	O
data	pointer
)	O
{	O
Symbol	struct
*	O
sym	pointer
=	O
data	pointer
;	O
struct	O
table_entry	struct
*	O
t	pointer
=	O
sym	pointer
->	O
owner	pointer
;	O
if	O
(	O
!	O
t	pointer
)	O
return	O
;	O
if	O
(	O
sym	pointer
->	O
flag	pointer
==	O
symbol_local	int
)	O
{	O
if	O
(	O
print_option	int
==	O
PRINT_XREF	int
&&	O
include_symbol	function
(	O
sym	pointer
)	O
)	O
{	O
unlink_symbol	function
(	O
sym	pointer
)	O
;	O
linked_list_append	function
(	O
&	O
unit_local_list	pointer
,	O
sym	pointer
)	O
;	O
}	O
else	O
{	O
delete_symbol	function
(	O
sym	pointer
)	O
;	O
}	O
}	O
else	O
{	O
unlink_symbol	function
(	O
sym	pointer
)	O
;	O
if	O
(	O
symbol_is_function	function
(	O
sym	pointer
)	O
)	O
linked_list_append	function
(	O
&	O
static_func_list	pointer
,	O
sym	pointer
)	O
;	O
}	O
}	O
void	O
delete_statics	function
(	O
)	O
{	O
if	O
(	O
static_symbol_list	pointer
)	O
{	O
static_symbol_list	pointer
->	O
free_data	pointer
=	O
static_free	function
;	O
linked_list_destroy	function
(	O
&	O
static_symbol_list	pointer
)	O
;	O
}	O
}	O
int	O
delete_level_autos	function
(	O
void	O
*	O
data	pointer
,	O
void	O
*	O
call_data	pointer
)	O
{	O
int	O
level	int
=	O
*	O
(	O
int	O
*	O
)	O
call_data	pointer
;	O
Symbol	struct
*	O
s	long
=	O
data	pointer
;	O
if	O
(	O
s	long
->	O
level	int
==	O
level	int
)	O
{	O
delete_symbol	function
(	O
s	long
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
delete_level_statics	function
(	O
void	O
*	O
data	pointer
,	O
void	O
*	O
call_data	pointer
)	O
{	O
int	O
level	int
=	O
*	O
(	O
int	O
*	O
)	O
call_data	pointer
;	O
Symbol	struct
*	O
s	long
=	O
data	pointer
;	O
if	O
(	O
s	long
->	O
level	int
==	O
level	int
)	O
{	O
unlink_symbol	function
(	O
s	long
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
delete_autos	function
(	O
int	O
level	int
)	O
{	O
linked_list_iterate	function
(	O
&	O
auto_symbol_list	pointer
,	O
delete_level_autos	function
,	O
&	O
level	int
)	O
;	O
linked_list_iterate	function
(	O
&	O
static_symbol_list	pointer
,	O
delete_level_statics	function
,	O
&	O
level	int
)	O
;	O
}	O
struct	O
collect_data	struct
{	O
Symbol	struct
*	O
*	O
sym	pointer
;	O
int	O
(	O
*	O
sel	pointer
)	O
(	O
Symbol	struct
*	O
p	pointer
)	O
;	O
size_t	long
index	function
;	O
}	O
;	O
static	O
bool	bool
collect_processor	function
(	O
void	O
*	O
data	pointer
,	O
void	O
*	O
proc_data	pointer
)	O
{	O
struct	O
table_entry	struct
*	O
t	pointer
=	O
data	pointer
;	O
struct	O
collect_data	struct
*	O
cd	pointer
=	O
proc_data	pointer
;	O
Symbol	struct
*	O
s	long
;	O
for	O
(	O
s	long
=	O
t	pointer
->	O
sym	pointer
;	O
s	long
;	O
s	long
=	O
s	long
->	O
next	pointer
)	O
{	O
if	O
(	O
cd	pointer
->	O
sel	pointer
(	O
s	long
)	O
)	O
{	O
if	O
(	O
cd	pointer
->	O
sym	pointer
)	O
cd	pointer
->	O
sym	pointer
[	O
cd	pointer
->	O
index	function
]	O
=	O
s	long
;	O
cd	pointer
->	O
index	function
++	O
;	O
}	O
}	O
return	O
true	int
;	O
}	O
static	O
int	O
collect_list_entry	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
proc_data	pointer
)	O
{	O
Symbol	struct
*	O
s	long
=	O
item	pointer
;	O
struct	O
collect_data	struct
*	O
cd	pointer
=	O
proc_data	pointer
;	O
if	O
(	O
cd	pointer
->	O
sel	pointer
(	O
s	long
)	O
)	O
{	O
cd	pointer
->	O
sym	pointer
[	O
cd	pointer
->	O
index	function
]	O
=	O
s	long
;	O
cd	pointer
->	O
index	function
++	O
;	O
}	O
return	O
0	int
;	O
}	O
size_t	long
collect_symbols	function
(	O
Symbol	struct
*	O
*	O
*	O
return_sym	pointer
,	O
int	O
(	O
*	O
sel	pointer
)	O
(	O
Symbol	struct
*	O
p	pointer
)	O
,	O
size_t	long
reserved_slots	long
)	O
{	O
struct	O
collect_data	struct
cdata	struct
;	O
size_t	long
size	long
;	O
size	long
=	O
hash_get_n_entries	function
(	O
symbol_table	pointer
)	O
+	O
linked_list_size	function
(	O
static_func_list	pointer
)	O
+	O
linked_list_size	function
(	O
unit_local_list	pointer
)	O
;	O
cdata	struct
.	O
sym	pointer
=	O
xcalloc	function
(	O
size	long
+	O
reserved_slots	long
,	O
sizeof	O
(	O
*	O
cdata	struct
.	O
sym	pointer
)	O
)	O
;	O
cdata	struct
.	O
index	function
=	O
0	int
;	O
cdata	struct
.	O
sel	pointer
=	O
sel	pointer
;	O
hash_do_for_each	function
(	O
symbol_table	pointer
,	O
collect_processor	function
,	O
&	O
cdata	struct
)	O
;	O
linked_list_iterate	function
(	O
&	O
static_func_list	pointer
,	O
collect_list_entry	function
,	O
&	O
cdata	struct
)	O
;	O
linked_list_iterate	function
(	O
&	O
unit_local_list	pointer
,	O
collect_list_entry	function
,	O
&	O
cdata	struct
)	O
;	O
cdata	struct
.	O
sym	pointer
=	O
xrealloc	function
(	O
cdata	struct
.	O
sym	pointer
,	O
(	O
cdata	struct
.	O
index	function
+	O
reserved_slots	long
)	O
*	O
sizeof	O
(	O
*	O
cdata	struct
.	O
sym	pointer
)	O
)	O
;	O
*	O
return_sym	pointer
=	O
cdata	struct
.	O
sym	pointer
;	O
return	O
cdata	struct
.	O
index	function
;	O
}	O
size_t	long
collect_functions	function
(	O
Symbol	struct
*	O
*	O
*	O
return_sym	pointer
)	O
{	O
Symbol	struct
*	O
*	O
symbols	pointer
;	O
size_t	long
num	long
,	O
snum	long
;	O
struct	O
linked_list_entry	struct
*	O
p	pointer
;	O
snum	long
=	O
linked_list_size	function
(	O
static_func_list	pointer
)	O
;	O
num	long
=	O
collect_symbols	function
(	O
&	O
symbols	pointer
,	O
symbol_is_function	function
,	O
snum	long
)	O
;	O
if	O
(	O
snum	long
)	O
for	O
(	O
p	pointer
=	O
linked_list_head	O
(	O
static_func_list	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
symbols	pointer
[	O
num	long
++	O
]	O
=	O
p	pointer
->	O
data	pointer
;	O
*	O
return_sym	pointer
=	O
symbols	pointer
;	O
return	O
num	long
;	O
}	O
int	O
delete_parms_itr	function
(	O
void	O
*	O
data	pointer
,	O
void	O
*	O
call_data	pointer
)	O
{	O
int	O
level	int
=	O
*	O
(	O
int	O
*	O
)	O
call_data	pointer
;	O
Symbol	struct
*	O
s	long
=	O
data	pointer
;	O
struct	O
table_entry	struct
*	O
t	pointer
=	O
s	long
->	O
owner	pointer
;	O
if	O
(	O
!	O
t	pointer
)	O
return	O
1	int
;	O
if	O
(	O
s	long
->	O
type	enum
==	O
SymIdentifier	int
&&	O
s	long
->	O
storage	enum
==	O
AutoStorage	int
&&	O
s	long
->	O
flag	pointer
==	O
symbol_parm	int
&&	O
s	long
->	O
level	int
>	O
level	int
)	O
{	O
delete_symbol	function
(	O
s	long
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
delete_parms	function
(	O
int	O
level	int
)	O
{	O
linked_list_iterate	function
(	O
&	O
auto_symbol_list	pointer
,	O
delete_parms_itr	function
,	O
&	O
level	int
)	O
;	O
}	O
void	O
move_parms	function
(	O
int	O
level	int
)	O
{	O
struct	O
linked_list_entry	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
linked_list_head	O
(	O
auto_symbol_list	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
{	O
Symbol	struct
*	O
s	long
=	O
p	pointer
->	O
data	pointer
;	O
if	O
(	O
s	long
->	O
type	enum
==	O
SymIdentifier	int
&&	O
s	long
->	O
storage	enum
==	O
AutoStorage	int
&&	O
s	long
->	O
flag	pointer
==	O
symbol_parm	int
)	O
{	O
s	long
->	O
level	int
=	O
level	int
;	O
s	long
->	O
flag	pointer
=	O
symbol_none	int
;	O
}	O
}	O
}	O
