struct	O
editstuff	struct
{	O
struct	O
fro	struct
*	O
fedit	pointer
;	O
char	O
const	O
*	O
filename	pointer
;	O
size_t	long
script_lno	long
;	O
long	O
lcount	long
;	O
long	O
corr	long
;	O
char	O
*	O
*	O
line	pointer
;	O
size_t	long
gap	long
,	O
gapsize	long
,	O
lim	pointer
;	O
struct	O
sff	struct
*	O
sff	struct
;	O
}	O
;	O
struct	O
editstuff	struct
*	O
make_editstuff	function
(	O
void	O
)	O
{	O
return	O
ZLLOC	O
(	O
1	int
,	O
struct	O
editstuff	struct
)	O
;	O
}	O
void	O
unmake_editstuff	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
)	O
{	O
free	function
(	O
es	pointer
->	O
line	pointer
)	O
;	O
memset	function
(	O
es	pointer
,	O
0	int
,	O
sizeof	O
(	O
struct	O
editstuff	struct
)	O
)	O
;	O
}	O
static	O
void	O
*	O
okalloc	function
(	O
void	O
*	O
p	pointer
)	O
{	O
if	O
(	O
!	O
p	pointer
)	O
oom	function
(	O
)	O
;	O
return	O
p	pointer
;	O
}	O
static	O
void	O
*	O
testalloc	function
(	O
size_t	long
size	long
)	O
{	O
return	O
okalloc	function
(	O
malloc	function
(	O
size	long
)	O
)	O
;	O
}	O
static	O
void	O
*	O
testrealloc	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
)	O
{	O
return	O
okalloc	function
(	O
realloc	function
(	O
ptr	pointer
,	O
size	long
)	O
)	O
;	O
}	O
static	O
bool	bool
nfs_NOENT_p	function
(	O
void	O
)	O
{	O
return	O
has_NFS	int
&&	O
ENOENT	int
==	O
errno	O
;	O
}	O
int	O
un_link	function
(	O
char	O
const	O
*	O
s	pointer
)	O
{	O
int	O
rv	int
=	O
unlink	function
(	O
s	pointer
)	O
;	O
if	O
(	O
!	O
PROB	O
(	O
rv	int
)	O
)	O
;	O
else	O
{	O
if	O
(	O
BAD_UNLINK	int
)	O
{	O
int	O
e	pointer
=	O
errno	O
;	O
if	O
(	O
PROB	O
(	O
chmod	function
(	O
s	pointer
,	O
S_IWUSR	O
)	O
)	O
)	O
{	O
errno	O
=	O
e	pointer
;	O
rv	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
nfs_NOENT_p	function
(	O
)	O
)	O
rv	int
=	O
0	int
;	O
}	O
return	O
rv	int
;	O
}	O
static	O
void	O
insertline	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
unsigned	O
long	O
n	int
,	O
char	O
*	O
l	pointer
)	O
{	O
if	O
(	O
es	pointer
->	O
lim	pointer
-	O
es	pointer
->	O
gapsize	long
<	O
n	int
)	O
EDIT_SCRIPT_OVERFLOW	O
(	O
)	O
;	O
if	O
(	O
!	O
es	pointer
->	O
gapsize	long
)	O
es	pointer
->	O
line	pointer
=	O
!	O
es	pointer
->	O
lim	pointer
?	O
testalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
es	pointer
->	O
lim	pointer
=	O
es	pointer
->	O
gapsize	long
=	O
1024	int
)	O
)	O
:	O
(	O
es	pointer
->	O
gap	long
=	O
es	pointer
->	O
gapsize	long
=	O
es	pointer
->	O
lim	pointer
,	O
testrealloc	function
(	O
es	pointer
->	O
line	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
es	pointer
->	O
lim	pointer
<<=	O
1	int
)	O
)	O
)	O
;	O
if	O
(	O
n	int
<	O
es	pointer
->	O
gap	long
)	O
movelines	O
(	O
es	pointer
->	O
line	pointer
+	O
n	int
+	O
es	pointer
->	O
gapsize	long
,	O
es	pointer
->	O
line	pointer
+	O
n	int
,	O
es	pointer
->	O
gap	long
-	O
n	int
)	O
;	O
else	O
if	O
(	O
es	pointer
->	O
gap	long
<	O
n	int
)	O
movelines	O
(	O
es	pointer
->	O
line	pointer
+	O
es	pointer
->	O
gap	long
,	O
es	pointer
->	O
line	pointer
+	O
es	pointer
->	O
gap	long
+	O
es	pointer
->	O
gapsize	long
,	O
n	int
-	O
es	pointer
->	O
gap	long
)	O
;	O
es	pointer
->	O
line	pointer
[	O
n	int
]	O
=	O
l	pointer
;	O
es	pointer
->	O
gap	long
=	O
n	int
+	O
1	int
;	O
es	pointer
->	O
gapsize	long
--	O
;	O
}	O
static	O
void	O
deletelines	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
unsigned	O
long	O
n	int
,	O
unsigned	O
long	O
nlines	long
)	O
{	O
unsigned	O
long	O
l	pointer
=	O
n	int
+	O
nlines	long
;	O
if	O
(	O
es	pointer
->	O
lim	pointer
-	O
es	pointer
->	O
gapsize	long
<	O
l	pointer
||	O
l	pointer
<	O
n	int
)	O
EDIT_SCRIPT_OVERFLOW	O
(	O
)	O
;	O
if	O
(	O
l	pointer
<	O
es	pointer
->	O
gap	long
)	O
movelines	O
(	O
es	pointer
->	O
line	pointer
+	O
l	pointer
+	O
es	pointer
->	O
gapsize	long
,	O
es	pointer
->	O
line	pointer
+	O
l	pointer
,	O
es	pointer
->	O
gap	long
-	O
l	pointer
)	O
;	O
else	O
if	O
(	O
es	pointer
->	O
gap	long
<	O
n	int
)	O
movelines	O
(	O
es	pointer
->	O
line	pointer
+	O
es	pointer
->	O
gap	long
,	O
es	pointer
->	O
line	pointer
+	O
es	pointer
->	O
gap	long
+	O
es	pointer
->	O
gapsize	long
,	O
n	int
-	O
es	pointer
->	O
gap	long
)	O
;	O
es	pointer
->	O
gap	long
=	O
n	int
;	O
es	pointer
->	O
gapsize	long
+=	O
nlines	long
;	O
}	O
static	O
void	O
snapshotline	function
(	O
register	O
FILE	struct
*	O
f	pointer
,	O
register	O
char	O
*	O
l	pointer
)	O
{	O
register	O
int	O
c	int
;	O
do	O
{	O
if	O
(	O
(	O
c	int
=	O
*	O
l	pointer
++	O
)	O
==	O
SDELIM	char
&&	O
*	O
l	pointer
++	O
!=	O
SDELIM	char
)	O
return	O
;	O
aputc	O
(	O
c	int
,	O
f	pointer
)	O
;	O
}	O
while	O
(	O
c	int
!=	O
'\n'	O
)	O
;	O
}	O
static	O
void	O
snapshotedit_fast	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
FILE	struct
*	O
f	pointer
)	O
{	O
register	O
char	O
*	O
*	O
p	pointer
,	O
*	O
*	O
lim	pointer
,	O
*	O
*	O
l	pointer
=	O
es	pointer
->	O
line	pointer
;	O
for	O
(	O
p	pointer
=	O
l	pointer
,	O
lim	pointer
=	O
l	pointer
+	O
es	pointer
->	O
gap	long
;	O
p	pointer
<	O
lim	pointer
;	O
)	O
snapshotline	function
(	O
f	pointer
,	O
*	O
p	pointer
++	O
)	O
;	O
for	O
(	O
p	pointer
+=	O
es	pointer
->	O
gapsize	long
,	O
lim	pointer
=	O
l	pointer
+	O
es	pointer
->	O
lim	pointer
;	O
p	pointer
<	O
lim	pointer
;	O
)	O
snapshotline	function
(	O
f	pointer
,	O
*	O
p	pointer
++	O
)	O
;	O
}	O
struct	O
finctx	struct
{	O
struct	O
expctx	struct
ctx	pointer
;	O
size_t	long
script_lno	long
;	O
}	O
;	O
static	O
void	O
finisheditline	function
(	O
struct	O
finctx	struct
*	O
finctx	struct
,	O
char	O
*	O
l	pointer
)	O
{	O
struct	O
expctx	struct
*	O
ctx	pointer
=	O
&	O
finctx	struct
->	O
ctx	pointer
;	O
ctx	pointer
->	O
from	pointer
->	O
ptr	pointer
=	O
l	pointer
;	O
if	O
(	O
expandline	function
(	O
ctx	pointer
)	O
<	O
0	int
)	O
PFATAL	O
(	O
"%s:%zu: error expanding keywords while applying delta %s"	pointer
,	O
REPO	O
(	O
filename	pointer
)	O
,	O
finctx	struct
->	O
script_lno	long
,	O
ctx	pointer
->	O
delta	struct
->	O
num	pointer
)	O
;	O
}	O
static	O
void	O
finishedit_fast	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
struct	O
delta	struct
const	O
*	O
delta	struct
,	O
FILE	struct
*	O
outfile	pointer
,	O
bool	bool
done	bool
)	O
{	O
if	O
(	O
done	bool
)	O
{	O
openfcopy	function
(	O
outfile	pointer
)	O
;	O
outfile	pointer
=	O
FLOW	O
(	O
res	pointer
)	O
;	O
if	O
(	O
!	O
delta	struct
)	O
snapshotedit_fast	function
(	O
es	pointer
,	O
outfile	pointer
)	O
;	O
else	O
{	O
register	O
char	O
*	O
*	O
p	pointer
,	O
*	O
*	O
lim	pointer
,	O
*	O
*	O
l	pointer
=	O
es	pointer
->	O
line	pointer
;	O
register	O
struct	O
fro	struct
*	O
fin	pointer
=	O
FLOW	O
(	O
from	pointer
)	O
;	O
char	O
*	O
here	pointer
=	O
fin	pointer
->	O
ptr	pointer
;	O
struct	O
finctx	struct
finctx	struct
=	O
{	O
.	O
ctx	pointer
=	O
EXPCTX_1OUT	O
(	O
outfile	pointer
,	O
fin	pointer
,	O
true	int
,	O
true	int
)	O
,	O
.	O
script_lno	long
=	O
es	pointer
->	O
script_lno	long
}	O
;	O
for	O
(	O
p	pointer
=	O
l	pointer
,	O
lim	pointer
=	O
l	pointer
+	O
es	pointer
->	O
gap	long
;	O
p	pointer
<	O
lim	pointer
;	O
)	O
finisheditline	function
(	O
&	O
finctx	struct
,	O
*	O
p	pointer
++	O
)	O
;	O
for	O
(	O
p	pointer
+=	O
es	pointer
->	O
gapsize	long
,	O
lim	pointer
=	O
l	pointer
+	O
es	pointer
->	O
lim	pointer
;	O
p	pointer
<	O
lim	pointer
;	O
)	O
finisheditline	function
(	O
&	O
finctx	struct
,	O
*	O
p	pointer
++	O
)	O
;	O
fin	pointer
->	O
ptr	pointer
=	O
here	pointer
;	O
FINISH_EXPCTX	O
(	O
&	O
finctx	struct
.	O
ctx	pointer
)	O
;	O
}	O
}	O
}	O
static	O
FILE	struct
*	O
fopen_update_truncate	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
if	O
(	O
!	O
STDIO_P	O
(	O
FLOW	O
(	O
from	pointer
)	O
)	O
)	O
return	O
fopen_safer	function
(	O
name	pointer
,	O
FOPEN_W_WORK	pointer
)	O
;	O
else	O
{	O
if	O
(	O
BAD_FOPEN_WPLUS	int
&&	O
PROB	O
(	O
un_link	function
(	O
name	pointer
)	O
)	O
)	O
fatal_sys	function
(	O
name	pointer
)	O
;	O
return	O
fopen_safer	function
(	O
name	pointer
,	O
FOPEN_WPLUS_WORK	pointer
)	O
;	O
}	O
}	O
void	O
openfcopy	function
(	O
FILE	struct
*	O
f	pointer
)	O
{	O
if	O
(	O
!	O
(	O
FLOW	O
(	O
res	pointer
)	O
=	O
f	pointer
)	O
)	O
{	O
if	O
(	O
!	O
FLOW	O
(	O
result	pointer
)	O
)	O
FLOW	O
(	O
result	pointer
)	O
=	O
maketemp	function
(	O
2	int
)	O
;	O
if	O
(	O
!	O
(	O
FLOW	O
(	O
res	pointer
)	O
=	O
fopen_update_truncate	function
(	O
FLOW	O
(	O
result	pointer
)	O
)	O
)	O
)	O
fatal_sys	function
(	O
FLOW	O
(	O
result	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
swapeditfiles	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
FILE	struct
*	O
outfile	pointer
)	O
{	O
char	O
const	O
*	O
tmpptr	pointer
;	O
FILE	struct
*	O
stream	pointer
=	O
FLOW	O
(	O
res	pointer
)	O
;	O
struct	O
fro	struct
*	O
f	pointer
=	O
es	pointer
->	O
fedit	pointer
;	O
es	pointer
->	O
lcount	long
=	O
0	int
;	O
es	pointer
->	O
corr	long
=	O
0	int
;	O
if	O
(	O
!	O
f	pointer
)	O
{	O
f	pointer
=	O
es	pointer
->	O
fedit	pointer
=	O
FZLLOC	O
(	O
struct	O
fro	struct
)	O
;	O
f	pointer
->	O
rm	enum
=	O
RM_STDIO	int
;	O
}	O
f	pointer
->	O
stream	pointer
=	O
stream	pointer
;	O
f	pointer
->	O
end	pointer
=	O
ftello	function
(	O
stream	pointer
)	O
;	O
rewind	function
(	O
stream	pointer
)	O
;	O
tmpptr	pointer
=	O
es	pointer
->	O
filename	pointer
;	O
es	pointer
->	O
filename	pointer
=	O
FLOW	O
(	O
result	pointer
)	O
;	O
FLOW	O
(	O
result	pointer
)	O
=	O
tmpptr	pointer
;	O
openfcopy	function
(	O
outfile	pointer
)	O
;	O
}	O
static	O
void	O
finishedit_slow	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
struct	O
delta	struct
const	O
*	O
delta	struct
,	O
FILE	struct
*	O
outfile	pointer
,	O
bool	bool
done	bool
)	O
{	O
register	O
struct	O
fro	struct
*	O
fe	pointer
;	O
register	O
FILE	struct
*	O
fc	pointer
;	O
fe	pointer
=	O
es	pointer
->	O
fedit	pointer
;	O
if	O
(	O
fe	pointer
)	O
{	O
fc	pointer
=	O
FLOW	O
(	O
res	pointer
)	O
;	O
if	O
(	O
delta	struct
)	O
{	O
struct	O
expctx	struct
ctx	pointer
=	O
EXPCTX_1OUT	O
(	O
fc	pointer
,	O
fe	pointer
,	O
false	int
,	O
true	int
)	O
;	O
while	O
(	O
1	int
<	O
expandline	function
(	O
&	O
ctx	pointer
)	O
)	O
;	O
FINISH_EXPCTX	O
(	O
&	O
ctx	pointer
)	O
;	O
}	O
else	O
{	O
VERBATIM	O
(	O
fe	pointer
,	O
ftello	function
(	O
fe	pointer
->	O
stream	pointer
)	O
)	O
;	O
fro_spew	function
(	O
fe	pointer
,	O
fc	pointer
)	O
;	O
}	O
fro_close	function
(	O
fe	pointer
)	O
;	O
}	O
if	O
(	O
!	O
done	bool
)	O
swapeditfiles	function
(	O
es	pointer
,	O
outfile	pointer
)	O
;	O
}	O
static	O
void	O
snapshotedit_slow	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
FILE	struct
*	O
f	pointer
)	O
{	O
finishedit_slow	function
(	O
es	pointer
,	O
NULL	O
,	O
NULL	O
,	O
false	int
)	O
;	O
fro_spew	function
(	O
es	pointer
->	O
fedit	pointer
,	O
f	pointer
)	O
;	O
fro_bob	O
(	O
es	pointer
->	O
fedit	pointer
)	O
;	O
}	O
void	O
finishedit	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
struct	O
delta	struct
const	O
*	O
delta	struct
,	O
FILE	struct
*	O
outfile	pointer
,	O
bool	bool
done	bool
)	O
{	O
(	O
!	O
STDIO_P	O
(	O
FLOW	O
(	O
from	pointer
)	O
)	O
?	O
finishedit_fast	function
:	O
finishedit_slow	function
)	O
(	O
es	pointer
,	O
delta	struct
,	O
outfile	pointer
,	O
done	bool
)	O
;	O
}	O
void	O
snapshotedit	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
FILE	struct
*	O
f	pointer
)	O
{	O
(	O
!	O
STDIO_P	O
(	O
FLOW	O
(	O
from	pointer
)	O
)	O
?	O
snapshotedit_fast	function
:	O
snapshotedit_slow	function
)	O
(	O
es	pointer
,	O
f	pointer
)	O
;	O
}	O
static	O
void	O
copylines	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
register	O
long	O
upto	long
,	O
struct	O
delta	struct
const	O
*	O
delta	struct
)	O
{	O
if	O
(	O
!	O
STDIO_P	O
(	O
FLOW	O
(	O
from	pointer
)	O
)	O
)	O
es	pointer
->	O
lcount	long
=	O
upto	long
;	O
else	O
{	O
int	O
c	int
;	O
register	O
FILE	struct
*	O
fc	pointer
;	O
register	O
struct	O
fro	struct
*	O
fe	pointer
;	O
if	O
(	O
upto	long
<	O
es	pointer
->	O
lcount	long
)	O
{	O
finishedit_slow	function
(	O
es	pointer
,	O
NULL	O
,	O
NULL	O
,	O
false	int
)	O
;	O
}	O
fe	pointer
=	O
es	pointer
->	O
fedit	pointer
;	O
fc	pointer
=	O
FLOW	O
(	O
res	pointer
)	O
;	O
if	O
(	O
es	pointer
->	O
lcount	long
<	O
upto	long
)	O
{	O
struct	O
expctx	struct
ctx	pointer
=	O
EXPCTX_1OUT	O
(	O
fc	pointer
,	O
fe	pointer
,	O
false	int
,	O
true	int
)	O
;	O
if	O
(	O
delta	struct
)	O
do	O
{	O
if	O
(	O
expandline	function
(	O
&	O
ctx	pointer
)	O
<=	O
1	int
)	O
EDIT_SCRIPT_OVERFLOW	O
(	O
)	O
;	O
}	O
while	O
(	O
++	O
es	pointer
->	O
lcount	long
<	O
upto	long
)	O
;	O
else	O
{	O
do	O
{	O
do	O
{	O
GETCHAR_OR	O
(	O
c	int
,	O
fe	pointer
,	O
EDIT_SCRIPT_OVERFLOW	O
(	O
)	O
)	O
;	O
aputc	O
(	O
c	int
,	O
fc	pointer
)	O
;	O
}	O
while	O
(	O
c	int
!=	O
'\n'	O
)	O
;	O
}	O
while	O
(	O
++	O
es	pointer
->	O
lcount	long
<	O
upto	long
)	O
;	O
}	O
FINISH_EXPCTX	O
(	O
&	O
ctx	pointer
)	O
;	O
}	O
}	O
}	O
void	O
copystring	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
struct	O
atat	pointer
*	O
atat	pointer
)	O
{	O
atat_display	function
(	O
FLOW	O
(	O
res	pointer
)	O
,	O
atat	pointer
,	O
false	int
)	O
;	O
if	O
(	O
FLOW	O
(	O
to	pointer
)	O
)	O
atat_put	function
(	O
FLOW	O
(	O
to	pointer
)	O
,	O
atat	pointer
)	O
;	O
es	pointer
->	O
lcount	long
+=	O
atat	pointer
->	O
line_count	long
;	O
}	O
void	O
enterstring	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
struct	O
atat	pointer
*	O
atat	pointer
)	O
{	O
if	O
(	O
STDIO_P	O
(	O
FLOW	O
(	O
from	pointer
)	O
)	O
)	O
{	O
char	O
const	O
*	O
filename	pointer
;	O
es	pointer
->	O
filename	pointer
=	O
NULL	O
;	O
es	pointer
->	O
fedit	pointer
=	O
NULL	O
;	O
es	pointer
->	O
lcount	long
=	O
es	pointer
->	O
corr	long
=	O
0	int
;	O
FLOW	O
(	O
result	pointer
)	O
=	O
filename	pointer
=	O
maketemp	function
(	O
1	int
)	O
;	O
if	O
(	O
!	O
(	O
FLOW	O
(	O
res	pointer
)	O
=	O
fopen_update_truncate	function
(	O
filename	pointer
)	O
)	O
)	O
fatal_sys	function
(	O
filename	pointer
)	O
;	O
copystring	function
(	O
es	pointer
,	O
atat	pointer
)	O
;	O
}	O
else	O
{	O
int	O
c	int
;	O
register	O
FILE	struct
*	O
frew	pointer
;	O
register	O
long	O
e	pointer
,	O
oe	long
;	O
register	O
bool	bool
amidline	bool
,	O
oamidline	bool
;	O
register	O
char	O
*	O
optr	pointer
;	O
register	O
struct	O
fro	struct
*	O
fin	pointer
;	O
e	pointer
=	O
0	int
;	O
es	pointer
->	O
gap	long
=	O
0	int
;	O
es	pointer
->	O
gapsize	long
=	O
es	pointer
->	O
lim	pointer
;	O
fin	pointer
=	O
FLOW	O
(	O
from	pointer
)	O
;	O
fro_trundling	function
(	O
false	int
,	O
fin	pointer
)	O
;	O
frew	pointer
=	O
FLOW	O
(	O
to	pointer
)	O
;	O
GETCHAR	O
(	O
c	int
,	O
fin	pointer
)	O
;	O
if	O
(	O
frew	pointer
)	O
afputc	function
(	O
c	int
,	O
frew	pointer
)	O
;	O
amidline	bool
=	O
false	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
optr	pointer
=	O
fin	pointer
->	O
ptr	pointer
;	O
TEECHAR	O
(	O
)	O
;	O
oamidline	bool
=	O
amidline	bool
;	O
oe	long
=	O
e	pointer
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\n'	O
:	O
++	O
e	pointer
;	O
amidline	bool
=	O
false	int
;	O
break	O
;	O
case	O
SDELIM	char
:	O
TEECHAR	O
(	O
)	O
;	O
if	O
(	O
c	int
!=	O
SDELIM	char
)	O
{	O
es	pointer
->	O
lcount	long
=	O
e	pointer
+	O
amidline	bool
;	O
es	pointer
->	O
corr	long
=	O
0	int
;	O
return	O
;	O
}	O
default	O
:	O
amidline	bool
=	O
true	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
oamidline	bool
)	O
insertline	function
(	O
es	pointer
,	O
oe	long
,	O
optr	pointer
)	O
;	O
}	O
}	O
}	O
void	O
editstring	function
(	O
struct	O
editstuff	struct
*	O
es	pointer
,	O
struct	O
atat	pointer
const	O
*	O
script	pointer
,	O
struct	O
delta	struct
const	O
*	O
delta	struct
)	O
{	O
int	O
ed	int
;	O
int	O
c	int
;	O
register	O
FILE	struct
*	O
frew	pointer
;	O
register	O
FILE	struct
*	O
f	pointer
=	O
NULL	O
;	O
long	O
line_lim	long
=	O
LONG_MAX	O
;	O
register	O
struct	O
fro	struct
*	O
fe	pointer
;	O
register	O
long	O
i	int
;	O
register	O
struct	O
fro	struct
*	O
fin	pointer
;	O
register	O
long	O
j	long
=	O
0	int
;	O
struct	O
diffcmd	struct
dc	pointer
;	O
es	pointer
->	O
script_lno	long
=	O
script	pointer
->	O
lno	long
;	O
es	pointer
->	O
lcount	long
+=	O
es	pointer
->	O
corr	long
;	O
es	pointer
->	O
corr	long
=	O
0	int
;	O
frew	pointer
=	O
FLOW	O
(	O
to	pointer
)	O
;	O
fin	pointer
=	O
FLOW	O
(	O
from	pointer
)	O
;	O
GETCHAR	O
(	O
c	int
,	O
fin	pointer
)	O
;	O
if	O
(	O
frew	pointer
)	O
afputc	function
(	O
c	int
,	O
frew	pointer
)	O
;	O
initdiffcmd	function
(	O
&	O
dc	pointer
)	O
;	O
while	O
(	O
0	int
<=	O
(	O
ed	int
=	O
getdiffcmd	function
(	O
fin	pointer
,	O
true	int
,	O
frew	pointer
,	O
&	O
dc	pointer
)	O
)	O
)	O
if	O
(	O
STDIO_P	O
(	O
fin	pointer
)	O
&&	O
line_lim	long
<=	O
dc	pointer
.	O
line1	long
)	O
EDIT_SCRIPT_OVERFLOW	O
(	O
)	O
;	O
else	O
if	O
(	O
!	O
ed	int
)	O
{	O
copylines	function
(	O
es	pointer
,	O
dc	pointer
.	O
line1	long
-	O
1	int
,	O
delta	struct
)	O
;	O
i	int
=	O
dc	pointer
.	O
nlines	long
;	O
es	pointer
->	O
corr	long
-=	O
i	int
;	O
es	pointer
->	O
lcount	long
+=	O
i	int
;	O
if	O
(	O
!	O
STDIO_P	O
(	O
fin	pointer
)	O
)	O
deletelines	function
(	O
es	pointer
,	O
es	pointer
->	O
lcount	long
+	O
es	pointer
->	O
corr	long
,	O
i	int
)	O
;	O
else	O
{	O
fe	pointer
=	O
es	pointer
->	O
fedit	pointer
;	O
do	O
{	O
do	O
GETCHAR_OR	O
(	O
c	int
,	O
fe	pointer
,	O
{	O
if	O
(	O
i	int
!=	O
1	int
)	O
EDIT_SCRIPT_OVERFLOW	O
(	O
)	O
;	O
line_lim	long
=	O
dc	pointer
.	O
dafter	long
;	O
goto	O
done	bool
;	O
}	O
)	O
;	O
while	O
(	O
c	int
!=	O
'\n'	O
)	O
;	O
done	bool
:	O
;	O
}	O
while	O
(	O
--	O
i	int
)	O
;	O
}	O
es	pointer
->	O
script_lno	long
++	O
;	O
}	O
else	O
{	O
copylines	function
(	O
es	pointer
,	O
dc	pointer
.	O
line1	long
,	O
delta	struct
)	O
;	O
i	int
=	O
dc	pointer
.	O
nlines	long
;	O
if	O
(	O
!	O
STDIO_P	O
(	O
fin	pointer
)	O
)	O
j	long
=	O
es	pointer
->	O
lcount	long
+	O
es	pointer
->	O
corr	long
;	O
es	pointer
->	O
corr	long
+=	O
i	int
;	O
if	O
(	O
STDIO_P	O
(	O
fin	pointer
)	O
&&	O
(	O
f	pointer
=	O
FLOW	O
(	O
res	pointer
)	O
,	O
delta	struct
)	O
)	O
{	O
struct	O
expctx	struct
ctx	pointer
=	O
EXPCTX	O
(	O
f	pointer
,	O
frew	pointer
,	O
fin	pointer
,	O
true	int
,	O
true	int
)	O
;	O
do	O
{	O
switch	O
(	O
expandline	function
(	O
&	O
ctx	pointer
)	O
)	O
{	O
case	O
0	int
:	O
case	O
1	int
:	O
if	O
(	O
i	int
==	O
1	int
)	O
return	O
;	O
case	O
-	O
1	int
:	O
EDIT_SCRIPT_SHORT	O
(	O
)	O
;	O
}	O
}	O
while	O
(	O
--	O
i	int
)	O
;	O
FINISH_EXPCTX	O
(	O
&	O
ctx	pointer
)	O
;	O
}	O
else	O
{	O
do	O
{	O
if	O
(	O
!	O
STDIO_P	O
(	O
fin	pointer
)	O
)	O
insertline	function
(	O
es	pointer
,	O
j	long
++	O
,	O
fin	pointer
->	O
ptr	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
TEECHAR	O
(	O
)	O
;	O
if	O
(	O
c	int
==	O
SDELIM	char
)	O
{	O
TEECHAR	O
(	O
)	O
;	O
if	O
(	O
c	int
!=	O
SDELIM	char
)	O
{	O
if	O
(	O
--	O
i	int
)	O
EDIT_SCRIPT_SHORT	O
(	O
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
STDIO_P	O
(	O
fin	pointer
)	O
)	O
aputc	O
(	O
c	int
,	O
f	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
}	O
}	O
while	O
(	O
--	O
i	int
)	O
;	O
}	O
es	pointer
->	O
script_lno	long
+=	O
1	int
+	O
dc	pointer
.	O
nlines	long
;	O
}	O
}	O
static	O
int	O
naturalize	function
(	O
struct	O
maybe	struct
*	O
m	pointer
,	O
bool	bool
*	O
symbolicp	pointer
)	O
{	O
int	O
e	pointer
;	O
ssize_t	long
r	pointer
;	O
int	O
linkcount	int
=	O
_POSIX_SYMLOOP_MAX	int
;	O
struct	O
cbuf	struct
*	O
fn	pointer
=	O
&	O
m	pointer
->	O
tentative	struct
;	O
struct	O
divvy	struct
*	O
space	pointer
=	O
m	pointer
->	O
space	pointer
;	O
size_t	long
len	char
=	O
SIZEABLE_FILENAME_LEN	O
;	O
char	O
*	O
chased	pointer
=	O
alloc	function
(	O
space	pointer
,	O
"chased"	pointer
,	O
len	char
)	O
;	O
char	O
const	O
*	O
orig	pointer
=	O
fn	pointer
->	O
string	pointer
;	O
while	O
(	O
(	O
r	pointer
=	O
readlink	function
(	O
fn	pointer
->	O
string	pointer
,	O
chased	pointer
,	O
len	char
)	O
)	O
!=	O
-	O
1	int
)	O
if	O
(	O
len	char
==	O
(	O
size_t	long
)	O
r	pointer
)	O
{	O
len	char
<<=	O
1	int
;	O
chased	pointer
=	O
alloc	function
(	O
space	pointer
,	O
"chased"	pointer
,	O
len	char
)	O
;	O
}	O
else	O
if	O
(	O
!	O
linkcount	int
--	O
)	O
{	O
errno	O
=	O
ELOOP	int
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
chased	pointer
[	O
r	pointer
]	O
=	O
'\0'	O
;	O
if	O
(	O
ABSFNAME	O
(	O
chased	pointer
)	O
)	O
{	O
fn	pointer
->	O
string	pointer
=	O
chased	pointer
;	O
fn	pointer
->	O
size	long
=	O
r	pointer
;	O
}	O
else	O
{	O
char	O
const	O
*	O
s	pointer
=	O
fn	pointer
->	O
string	pointer
;	O
accumulate_range	function
(	O
space	pointer
,	O
s	pointer
,	O
basefilename	function
(	O
s	pointer
)	O
)	O
;	O
accs	O
(	O
space	pointer
,	O
chased	pointer
)	O
;	O
fn	pointer
->	O
string	pointer
=	O
finish_string	function
(	O
space	pointer
,	O
&	O
fn	pointer
->	O
size	long
)	O
;	O
}	O
}	O
e	pointer
=	O
errno	O
;	O
*	O
symbolicp	pointer
=	O
fn	pointer
->	O
string	pointer
!=	O
orig	pointer
;	O
errno	O
=	O
e	pointer
;	O
switch	O
(	O
e	pointer
)	O
{	O
case	O
EINVAL	int
:	O
return	O
1	int
;	O
case	O
ENOENT	int
:	O
return	O
0	int
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
struct	O
fro	struct
*	O
rcswriteopen	function
(	O
struct	O
maybe	struct
*	O
m	pointer
)	O
{	O
struct	O
cbuf	struct
*	O
RCSbuf	pointer
=	O
&	O
m	pointer
->	O
tentative	struct
;	O
register	O
char	O
*	O
tp	pointer
;	O
register	O
char	O
const	O
*	O
sp	pointer
,	O
*	O
repofn	pointer
,	O
*	O
x	pointer
;	O
struct	O
fro	struct
*	O
f	pointer
;	O
size_t	long
len	char
;	O
int	O
e	pointer
,	O
exists	int
,	O
fdesc	int
,	O
fdescSafer	int
,	O
r	pointer
;	O
bool	bool
waslocked	bool
;	O
struct	O
stat	struct
statbuf	struct
;	O
bool	bool
symbolicp	pointer
=	O
false	int
;	O
char	O
*	O
lfn	pointer
;	O
struct	O
sff	struct
*	O
sff	struct
=	O
BE	O
(	O
sff	struct
)	O
;	O
waslocked	bool
=	O
0	int
<=	O
REPO	O
(	O
fd_lock	int
)	O
;	O
exists	int
=	O
naturalize	function
(	O
m	pointer
,	O
&	O
symbolicp	pointer
)	O
;	O
if	O
(	O
exists	int
<	O
(	O
m	pointer
->	O
mustread	bool
|	O
waslocked	bool
)	O
)	O
return	O
NULL	O
;	O
repofn	pointer
=	O
RCSbuf	pointer
->	O
string	pointer
;	O
accs	O
(	O
m	pointer
->	O
space	pointer
,	O
RCSbuf	pointer
->	O
string	pointer
)	O
;	O
lfn	pointer
=	O
finish_string	function
(	O
m	pointer
->	O
space	pointer
,	O
&	O
len	char
)	O
;	O
sp	pointer
=	O
basefilename	function
(	O
lfn	pointer
)	O
;	O
x	pointer
=	O
rcssuffix	function
(	O
repofn	pointer
)	O
;	O
if	O
(	O
!	O
x	pointer
&&	O
symbolicp	pointer
)	O
{	O
PERR	O
(	O
"symbolic link to non RCS file `%s'"	pointer
,	O
repofn	pointer
)	O
;	O
errno	O
=	O
EINVAL	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
*	O
sp	pointer
==	O
*	O
x	pointer
)	O
{	O
PERR	O
(	O
"RCS filename `%s' incompatible with suffix `%s'"	pointer
,	O
sp	pointer
,	O
x	pointer
)	O
;	O
errno	O
=	O
EINVAL	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
*	O
x	pointer
)	O
{	O
tp	pointer
=	O
lfn	pointer
+	O
len	char
;	O
*	O
tp	pointer
--	O
=	O
'\0'	O
;	O
while	O
(	O
sp	pointer
<	O
tp	pointer
)	O
{	O
*	O
tp	pointer
=	O
tp	pointer
[	O
-	O
1	int
]	O
;	O
tp	pointer
--	O
;	O
}	O
*	O
tp	pointer
=	O
*	O
x	pointer
;	O
}	O
else	O
{	O
tp	pointer
=	O
lfn	pointer
+	O
len	char
-	O
1	int
;	O
if	O
(	O
'_'	O
==	O
*	O
tp	pointer
)	O
{	O
PERR	O
(	O
"RCS filename `%s' ends with `%c'"	pointer
,	O
repofn	pointer
,	O
*	O
tp	pointer
)	O
;	O
errno	O
=	O
EINVAL	int
;	O
return	O
NULL	O
;	O
}	O
*	O
tp	pointer
=	O
'_'	O
;	O
}	O
sff	struct
[	O
waslocked	bool
]	O
.	O
filename	pointer
=	O
intern	function
(	O
SINGLE	O
,	O
lfn	pointer
,	O
len	char
)	O
;	O
f	pointer
=	O
NULL	O
;	O
ISR_DO	O
(	O
CATCHINTS	O
)	O
;	O
IGNOREINTS	O
(	O
)	O
;	O
seteid	function
(	O
)	O
;	O
fdesc	int
=	O
create	O
(	O
lfn	pointer
)	O
;	O
fdescSafer	int
=	O
fd_safer	function
(	O
fdesc	int
)	O
;	O
e	pointer
=	O
errno	O
;	O
setrid	function
(	O
)	O
;	O
if	O
(	O
0	int
<=	O
fdesc	int
)	O
sff	struct
[	O
SFFI_LOCKDIR	int
]	O
.	O
disposition	enum
=	O
effective	int
;	O
if	O
(	O
PROB	O
(	O
fdescSafer	int
)	O
)	O
{	O
if	O
(	O
e	pointer
==	O
EACCES	int
&&	O
!	O
PROB	O
(	O
stat	struct
(	O
lfn	pointer
,	O
&	O
statbuf	struct
)	O
)	O
)	O
e	pointer
=	O
EEXIST	int
;	O
}	O
else	O
{	O
e	pointer
=	O
ENOENT	int
;	O
if	O
(	O
exists	int
)	O
{	O
f	pointer
=	O
fro_open	function
(	O
repofn	pointer
,	O
FOPEN_RB	pointer
,	O
m	pointer
->	O
status	int
)	O
;	O
e	pointer
=	O
errno	O
;	O
if	O
(	O
f	pointer
&&	O
waslocked	bool
)	O
{	O
ORCSclose	function
(	O
)	O
;	O
seteid	function
(	O
)	O
;	O
r	pointer
=	O
un_link	function
(	O
lockname	O
)	O
;	O
e	pointer
=	O
errno	O
;	O
setrid	function
(	O
)	O
;	O
errno	O
=	O
e	pointer
;	O
if	O
(	O
PROB	O
(	O
r	pointer
)	O
)	O
fatal_sys	function
(	O
lockname	O
)	O
;	O
sff	struct
[	O
SFFI_LOCKDIR	int
]	O
.	O
filename	pointer
=	O
lfn	pointer
;	O
}	O
}	O
REPO	O
(	O
fd_lock	int
)	O
=	O
fdescSafer	int
;	O
}	O
RESTOREINTS	O
(	O
)	O
;	O
errno	O
=	O
e	pointer
;	O
return	O
f	pointer
;	O
}	O
int	O
chnamemod	function
(	O
FILE	struct
*	O
*	O
fromp	pointer
,	O
char	O
const	O
*	O
from	pointer
,	O
char	O
const	O
*	O
to	pointer
,	O
int	O
set_mode	int
,	O
mode_t	int
mode	int
,	O
time_t	long
mtime	long
)	O
{	O
mode_t	int
mode_while_renaming	int
=	O
mode	int
;	O
int	O
fchmod_set_mode	int
=	O
0	int
;	O
if	O
(	O
0	int
<	O
set_mode	int
&&	O
!	O
PROB	O
(	O
change_mode	function
(	O
fileno	function
(	O
*	O
fromp	pointer
)	O
,	O
mode_while_renaming	int
)	O
)	O
)	O
fchmod_set_mode	int
=	O
set_mode	int
;	O
Ozclose	function
(	O
fromp	pointer
)	O
;	O
if	O
(	O
fchmod_set_mode	int
<	O
set_mode	int
&&	O
PROB	O
(	O
chmod	function
(	O
from	pointer
,	O
mode_while_renaming	int
)	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
PROB	O
(	O
setmtime	function
(	O
from	pointer
,	O
mtime	long
)	O
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
PROB	O
(	O
rename	function
(	O
from	pointer
,	O
to	pointer
)	O
)	O
&&	O
!	O
nfs_NOENT_p	function
(	O
)	O
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
setmtime	function
(	O
char	O
const	O
*	O
file	pointer
,	O
time_t	long
mtime	long
)	O
{	O
struct	O
utimbuf	struct
amtime	struct
;	O
if	O
(	O
mtime	long
==	O
-	O
1	int
)	O
return	O
0	int
;	O
amtime	struct
.	O
actime	long
=	O
BE	O
(	O
now	long
)	O
;	O
amtime	struct
.	O
modtime	long
=	O
mtime	long
;	O
return	O
utime	function
(	O
file	pointer
,	O
&	O
amtime	struct
)	O
;	O
}	O
int	O
findlock	function
(	O
bool	bool
delete	bool
,	O
struct	O
delta	struct
*	O
*	O
target	pointer
)	O
{	O
struct	O
rcslock	struct
const	O
*	O
rl	pointer
;	O
struct	O
link	function
box	pointer
,	O
*	O
found	pointer
;	O
char	O
const	O
*	O
me	pointer
=	O
getcaller	function
(	O
)	O
;	O
if	O
(	O
!	O
(	O
box	pointer
.	O
next	pointer
=	O
GROK	O
(	O
locks	pointer
)	O
)	O
||	O
!	O
(	O
found	pointer
=	O
lock_login_memq	O
(	O
&	O
box	pointer
,	O
me	pointer
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
lock_login_memq	O
(	O
found	pointer
->	O
next	pointer
,	O
me	pointer
)	O
)	O
{	O
RERR	O
(	O
"multiple revisions locked by %s; please specify one"	pointer
,	O
me	pointer
)	O
;	O
return	O
2	int
;	O
}	O
rl	pointer
=	O
found	pointer
->	O
next	pointer
->	O
entry	pointer
;	O
*	O
target	pointer
=	O
rl	pointer
->	O
delta	struct
;	O
if	O
(	O
delete	bool
)	O
lock_drop	function
(	O
&	O
box	pointer
,	O
found	pointer
)	O
;	O
return	O
1	int
;	O
}	O
int	O
addsymbol	function
(	O
char	O
const	O
*	O
num	pointer
,	O
char	O
const	O
*	O
name	pointer
,	O
bool	bool
rebind	bool
)	O
{	O
struct	O
link	function
box	pointer
,	O
*	O
tp	pointer
;	O
struct	O
symdef	struct
*	O
d	pointer
;	O
box	pointer
.	O
next	pointer
=	O
GROK	O
(	O
symbols	pointer
)	O
;	O
for	O
(	O
tp	pointer
=	O
&	O
box	pointer
;	O
tp	pointer
->	O
next	pointer
;	O
tp	pointer
=	O
tp	pointer
->	O
next	pointer
)	O
{	O
struct	O
symdef	struct
const	O
*	O
dk	pointer
=	O
tp	pointer
->	O
next	pointer
->	O
entry	pointer
;	O
if	O
(	O
STR_SAME	O
(	O
name	pointer
,	O
dk	pointer
->	O
meaningful	pointer
)	O
)	O
{	O
if	O
(	O
STR_SAME	O
(	O
dk	pointer
->	O
underlying	pointer
,	O
num	pointer
)	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
rebind	bool
)	O
{	O
MAKEDEF	O
(	O
)	O
;	O
tp	pointer
->	O
next	pointer
=	O
prepend	function
(	O
d	pointer
,	O
tp	pointer
->	O
next	pointer
->	O
next	pointer
,	O
SINGLE	O
)	O
;	O
goto	O
ok	O
;	O
}	O
else	O
{	O
RERR	O
(	O
"symbolic name %s already bound to %s"	pointer
,	O
name	pointer
,	O
dk	pointer
->	O
underlying	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
MAKEDEF	O
(	O
)	O
;	O
box	pointer
.	O
next	pointer
=	O
prepend	function
(	O
d	pointer
,	O
box	pointer
.	O
next	pointer
,	O
SINGLE	O
)	O
;	O
ok	O
:	O
GROK	O
(	O
symbols	pointer
)	O
=	O
box	pointer
.	O
next	pointer
;	O
return	O
1	int
;	O
}	O
bool	bool
checkaccesslist	function
(	O
void	O
)	O
{	O
struct	O
link	function
*	O
ls	pointer
=	O
GROK	O
(	O
access	pointer
)	O
;	O
if	O
(	O
!	O
ls	pointer
||	O
stat_mine_p	function
(	O
&	O
REPO	O
(	O
stat	struct
)	O
)	O
||	O
caller_login_p	function
(	O
"root"	pointer
)	O
)	O
return	O
true	int
;	O
for	O
(	O
;	O
ls	pointer
;	O
ls	pointer
=	O
ls	pointer
->	O
next	pointer
)	O
if	O
(	O
caller_login_p	function
(	O
ls	pointer
->	O
entry	pointer
)	O
)	O
return	O
true	int
;	O
RERR	O
(	O
"user %s not on the access list"	pointer
,	O
getcaller	function
(	O
)	O
)	O
;	O
return	O
false	int
;	O
}	O
int	O
dorewrite	function
(	O
bool	bool
lockflag	bool
,	O
int	O
changed	int
)	O
{	O
int	O
r	pointer
=	O
0	int
,	O
e	pointer
;	O
if	O
(	O
lockflag	bool
)	O
{	O
if	O
(	O
changed	int
)	O
{	O
FILE	struct
*	O
frew	pointer
;	O
if	O
(	O
changed	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
putadmin	function
(	O
)	O
;	O
frew	pointer
=	O
FLOW	O
(	O
rewr	pointer
)	O
;	O
puttree	function
(	O
REPO	O
(	O
tip	pointer
)	O
,	O
frew	pointer
)	O
;	O
aprintf	function
(	O
frew	pointer
,	O
"\n\n%s\n"	pointer
,	O
TINYKS	O
(	O
desc	pointer
)	O
)	O
;	O
FLOW	O
(	O
to	pointer
)	O
=	O
frew	pointer
;	O
}	O
else	O
{	O
ORCSclose	function
(	O
)	O
;	O
seteid	function
(	O
)	O
;	O
IGNOREINTS	O
(	O
)	O
;	O
r	pointer
=	O
un_link	function
(	O
lockname	O
)	O
;	O
e	pointer
=	O
errno	O
;	O
keepdirtemp	function
(	O
lockname	O
)	O
;	O
RESTOREINTS	O
(	O
)	O
;	O
setrid	function
(	O
)	O
;	O
if	O
(	O
PROB	O
(	O
r	pointer
)	O
)	O
syserror	function
(	O
e	pointer
,	O
lockname	O
)	O
;	O
}	O
}	O
return	O
r	pointer
;	O
}	O
int	O
donerewrite	function
(	O
int	O
changed	int
,	O
time_t	long
newRCStime	long
)	O
{	O
int	O
r	pointer
=	O
0	int
,	O
e	pointer
=	O
0	int
;	O
if	O
(	O
changed	int
&&	O
!	O
FLOW	O
(	O
erroneousp	bool
)	O
)	O
{	O
struct	O
stat	struct
*	O
repo_stat	pointer
=	O
&	O
REPO	O
(	O
stat	struct
)	O
;	O
char	O
const	O
*	O
repo_filename	pointer
=	O
REPO	O
(	O
filename	pointer
)	O
;	O
struct	O
fro	struct
*	O
from	pointer
=	O
FLOW	O
(	O
from	pointer
)	O
;	O
FILE	struct
*	O
frew	pointer
=	O
FLOW	O
(	O
rewr	pointer
)	O
;	O
if	O
(	O
from	pointer
)	O
{	O
fro_spew	function
(	O
from	pointer
,	O
frew	pointer
)	O
;	O
fro_zclose	function
(	O
&	O
FLOW	O
(	O
from	pointer
)	O
)	O
;	O
}	O
if	O
(	O
1	int
<	O
repo_stat	pointer
->	O
st_nlink	long
)	O
RWARN	O
(	O
"breaking hard link"	pointer
)	O
;	O
aflush	function
(	O
frew	pointer
)	O
;	O
seteid	function
(	O
)	O
;	O
IGNOREINTS	O
(	O
)	O
;	O
r	pointer
=	O
chnamemod	function
(	O
&	O
FLOW	O
(	O
rewr	pointer
)	O
,	O
newRCSname	O
,	O
repo_filename	pointer
,	O
changed	int
,	O
repo_stat	pointer
->	O
st_mode	int
&	O
(	O
mode_t	int
)	O
~	O
(	O
S_IWUSR	O
|	O
S_IWGRP	O
|	O
S_IWOTH	O
)	O
,	O
newRCStime	long
)	O
;	O
frew	pointer
=	O
FLOW	O
(	O
rewr	pointer
)	O
;	O
e	pointer
=	O
errno	O
;	O
keepdirtemp	function
(	O
newRCSname	O
)	O
;	O
RESTOREINTS	O
(	O
)	O
;	O
setrid	function
(	O
)	O
;	O
if	O
(	O
PROB	O
(	O
r	pointer
)	O
)	O
{	O
syserror	function
(	O
e	pointer
,	O
repo_filename	pointer
)	O
;	O
PERR	O
(	O
"saved in %s"	pointer
,	O
newRCSname	O
)	O
;	O
}	O
}	O
return	O
r	pointer
;	O
}	O
void	O
ORCSclose	function
(	O
void	O
)	O
{	O
int	O
repo_fd_lock	int
=	O
REPO	O
(	O
fd_lock	int
)	O
;	O
if	O
(	O
0	int
<=	O
repo_fd_lock	int
)	O
{	O
if	O
(	O
PROB	O
(	O
close	pointer
(	O
repo_fd_lock	int
)	O
)	O
)	O
fatal_sys	function
(	O
lockname	O
)	O
;	O
REPO	O
(	O
fd_lock	int
)	O
=	O
-	O
1	int
;	O
}	O
Ozclose	function
(	O
&	O
FLOW	O
(	O
rewr	pointer
)	O
)	O
;	O
}	O
void	O
ORCSerror	function
(	O
void	O
)	O
{	O
int	O
repo_fd_lock	int
=	O
REPO	O
(	O
fd_lock	int
)	O
;	O
if	O
(	O
0	int
<=	O
repo_fd_lock	int
)	O
close	pointer
(	O
repo_fd_lock	int
)	O
;	O
if	O
(	O
FLOW	O
(	O
rewr	pointer
)	O
)	O
close	pointer
(	O
fileno	function
(	O
FLOW	O
(	O
rewr	pointer
)	O
)	O
)	O
;	O
}	O
void	O
unexpected_EOF	function
(	O
void	O
)	O
{	O
RFATAL	O
(	O
"unexpected EOF in diff output"	pointer
)	O
;	O
}	O
void	O
initdiffcmd	function
(	O
register	O
struct	O
diffcmd	struct
*	O
dc	pointer
)	O
{	O
dc	pointer
->	O
adprev	long
=	O
0	int
;	O
dc	pointer
->	O
dafter	long
=	O
0	int
;	O
}	O
static	O
void	O
badDiffOutput	function
(	O
char	O
const	O
*	O
buf	pointer
)	O
{	O
RFATAL	O
(	O
"bad diff output line: %s"	pointer
,	O
buf	pointer
)	O
;	O
}	O
static	O
void	O
diffLineNumberTooLarge	function
(	O
char	O
const	O
*	O
buf	pointer
)	O
{	O
RFATAL	O
(	O
"diff line number too large: %s"	pointer
,	O
buf	pointer
)	O
;	O
}	O
int	O
getdiffcmd	function
(	O
struct	O
fro	struct
*	O
finfile	pointer
,	O
bool	bool
delimiter	bool
,	O
FILE	struct
*	O
foutfile	pointer
,	O
struct	O
diffcmd	struct
*	O
dc	pointer
)	O
{	O
int	O
c	int
;	O
register	O
FILE	struct
*	O
fout	pointer
;	O
register	O
char	O
*	O
p	pointer
;	O
register	O
struct	O
fro	struct
*	O
fin	pointer
;	O
long	O
line1	long
,	O
nlines	long
,	O
t	long
;	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
fin	pointer
=	O
finfile	pointer
;	O
fout	pointer
=	O
foutfile	pointer
;	O
GETCHAR_OR	O
(	O
c	int
,	O
fin	pointer
,	O
{	O
if	O
(	O
delimiter	bool
)	O
unexpected_EOF	function
(	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
)	O
;	O
if	O
(	O
delimiter	bool
)	O
{	O
if	O
(	O
c	int
==	O
SDELIM	char
)	O
{	O
GETCHAR	O
(	O
c	int
,	O
fin	pointer
)	O
;	O
if	O
(	O
c	int
==	O
SDELIM	char
)	O
{	O
buf	pointer
[	O
0	int
]	O
=	O
c	int
;	O
buf	pointer
[	O
1	int
]	O
=	O
0	int
;	O
badDiffOutput	function
(	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
fout	pointer
)	O
aprintf	function
(	O
fout	pointer
,	O
"%c%c"	pointer
,	O
SDELIM	char
,	O
c	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
p	pointer
=	O
buf	pointer
;	O
do	O
{	O
if	O
(	O
buf	pointer
+	O
BUFSIZ	int
-	O
2	int
<=	O
p	pointer
)	O
{	O
RFATAL	O
(	O
"diff output command line too long"	pointer
)	O
;	O
}	O
*	O
p	pointer
++	O
=	O
c	int
;	O
GETCHAR_OR	O
(	O
c	int
,	O
fin	pointer
,	O
unexpected_EOF	function
(	O
)	O
)	O
;	O
}	O
while	O
(	O
c	int
!=	O
'\n'	O
)	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
for	O
(	O
p	pointer
=	O
buf	pointer
+	O
1	int
;	O
(	O
c	int
=	O
*	O
p	pointer
++	O
)	O
==	O
' '	O
;	O
)	O
continue	O
;	O
line1	long
=	O
0	int
;	O
while	O
(	O
isdigit	function
(	O
c	int
)	O
)	O
{	O
if	O
(	O
LONG_MAX	O
/	O
10	int
<	O
line1	long
||	O
(	O
t	long
=	O
line1	long
*	O
10	int
,	O
(	O
line1	long
=	O
t	long
+	O
(	O
c	int
-	O
'0'	O
)	O
)	O
<	O
t	long
)	O
)	O
diffLineNumberTooLarge	function
(	O
buf	pointer
)	O
;	O
c	int
=	O
*	O
p	pointer
++	O
;	O
}	O
while	O
(	O
c	int
==	O
' '	O
)	O
c	int
=	O
*	O
p	pointer
++	O
;	O
nlines	long
=	O
0	int
;	O
while	O
(	O
isdigit	function
(	O
c	int
)	O
)	O
{	O
if	O
(	O
LONG_MAX	O
/	O
10	int
<	O
nlines	long
||	O
(	O
t	long
=	O
nlines	long
*	O
10	int
,	O
(	O
nlines	long
=	O
t	long
+	O
(	O
c	int
-	O
'0'	O
)	O
)	O
<	O
t	long
)	O
)	O
diffLineNumberTooLarge	function
(	O
buf	pointer
)	O
;	O
c	int
=	O
*	O
p	pointer
++	O
;	O
}	O
if	O
(	O
c	int
==	O
'\r'	O
)	O
c	int
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
c	int
||	O
!	O
nlines	long
)	O
{	O
badDiffOutput	function
(	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
line1	long
+	O
nlines	long
<	O
line1	long
)	O
diffLineNumberTooLarge	function
(	O
buf	pointer
)	O
;	O
switch	O
(	O
buf	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'a'	O
:	O
if	O
(	O
line1	long
<	O
dc	pointer
->	O
adprev	long
)	O
{	O
RFATAL	O
(	O
"backward insertion in diff output: %s"	pointer
,	O
buf	pointer
)	O
;	O
}	O
dc	pointer
->	O
adprev	long
=	O
line1	long
+	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
line1	long
<	O
dc	pointer
->	O
adprev	long
||	O
line1	long
<	O
dc	pointer
->	O
dafter	long
)	O
{	O
RFATAL	O
(	O
"backward deletion in diff output: %s"	pointer
,	O
buf	pointer
)	O
;	O
}	O
dc	pointer
->	O
adprev	long
=	O
line1	long
;	O
dc	pointer
->	O
dafter	long
=	O
line1	long
+	O
nlines	long
;	O
break	O
;	O
default	O
:	O
badDiffOutput	function
(	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
fout	pointer
)	O
{	O
aprintf	function
(	O
fout	pointer
,	O
"%s\n"	pointer
,	O
buf	pointer
)	O
;	O
}	O
dc	pointer
->	O
line1	long
=	O
line1	long
;	O
dc	pointer
->	O
nlines	long
=	O
nlines	long
;	O
return	O
buf	pointer
[	O
0	int
]	O
==	O
'a'	O
;	O
}	O
