static	O
void	O
show_copyright	function
(	O
void	O
)	O
;	O
static	O
void	O
show_version	function
(	O
void	O
)	O
;	O
static	O
void	O
show_help	function
(	O
void	O
)	O
;	O
static	O
void	O
show_debug_help	function
(	O
void	O
)	O
;	O
static	O
void	O
show_debug_flags	function
(	O
void	O
)	O
;	O
static	O
void	O
socket_connect_to	function
(	O
const	O
char	O
*	O
host_name	pointer
,	O
unsigned	O
int	O
port	int
,	O
FILE	struct
*	O
*	O
input_file	pointer
,	O
FILE	struct
*	O
*	O
output_file	pointer
)	O
;	O
static	O
void	O
socket_listen_at	function
(	O
const	O
char	O
*	O
host_name	pointer
,	O
unsigned	O
int	O
port	int
,	O
FILE	struct
*	O
*	O
input_file	pointer
,	O
FILE	struct
*	O
*	O
output_file	pointer
)	O
;	O
static	O
void	O
socket_close_connection	function
(	O
FILE	struct
*	O
input_file	pointer
,	O
FILE	struct
*	O
output_file	pointer
)	O
;	O
static	O
void	O
socket_stop_listening	function
(	O
FILE	struct
*	O
input_file	pointer
,	O
FILE	struct
*	O
output_file	pointer
)	O
;	O
enum	O
{	O
OPT_BOARDSIZE	int
=	O
127	int
,	O
OPT_HANDICAPSTONES	int
,	O
OPT_COLOR	int
,	O
OPT_KOMI	int
,	O
OPT_CLOCK_TIME	int
,	O
OPT_CLOCK_BYO_TIME	int
,	O
OPT_CLOCK_BYO_PERIOD	int
,	O
OPT_AUTOLEVEL	int
,	O
OPT_MODE	int
,	O
OPT_INFILE	int
,	O
OPT_OUTFILE	int
,	O
OPT_QUIET	int
,	O
OPT_GTP_INPUT	int
,	O
OPT_GTP_CONNECT	int
,	O
OPT_GTP_LISTEN	int
,	O
OPT_GTP_DUMP_COMMANDS	int
,	O
OPT_GTP_INITIAL_ORIENTATION	int
,	O
OPT_GTP_VERSION	int
,	O
OPT_SHOWCOPYRIGHT	int
,	O
OPT_REPLAY_GAME	int
,	O
OPT_DECIDE_STRING	int
,	O
OPT_DECIDE_CONNECTION	int
,	O
OPT_DECIDE_OWL	int
,	O
OPT_DECIDE_DRAGON_DATA	int
,	O
OPT_DECIDE_SEMEAI	int
,	O
OPT_DECIDE_SURROUNDED	int
,	O
OPT_DECIDE_TACTICAL_SEMEAI	int
,	O
OPT_DECIDE_ORACLE	int
,	O
OPT_EXPERIMENTAL_SEMEAI	int
,	O
OPT_EXPERIMENTAL_OWL_EXT	int
,	O
OPT_SEMEAI_NODE_LIMIT	int
,	O
OPT_EXPERIMENTAL_CONNECTIONS	int
,	O
OPT_ALTERNATE_CONNECTIONS	int
,	O
OPT_WITH_BREAK_IN	int
,	O
OPT_WITHOUT_BREAK_IN	int
,	O
OPT_COSMIC_GNUGO	int
,	O
OPT_NO_COSMIC_GNUGO	int
,	O
OPT_LARGE_SCALE	int
,	O
OPT_NO_LARGE_SCALE	int
,	O
OPT_OPTIONS	int
,	O
OPT_STANDARD_SEMEAI	int
,	O
OPT_STANDARD_CONNECTIONS	int
,	O
OPT_PRINT_LEVELS	int
,	O
OPT_DECIDE_POSITION	int
,	O
OPT_DECIDE_EYE	int
,	O
OPT_DECIDE_COMBINATION	int
,	O
OPT_BRANCH_DEPTH	int
,	O
OPT_BACKFILL2_DEPTH	int
,	O
OPT_BREAK_CHAIN_DEPTH	int
,	O
OPT_SUPERSTRING_DEPTH	int
,	O
OPT_AA_DEPTH	int
,	O
OPT_DEBUG_FLAGS	int
,	O
OPT_OWL_DISTRUST	int
,	O
OPT_OWL_BRANCH	int
,	O
OPT_OWL_READING	int
,	O
OPT_OWL_NODE_LIMIT	int
,	O
OPT_NOFUSEKIDB	int
,	O
OPT_NOFUSEKI	int
,	O
OPT_NOJOSEKIDB	int
,	O
OPT_LEVEL	int
,	O
OPT_MIN_LEVEL	int
,	O
OPT_MAX_LEVEL	int
,	O
OPT_LIMIT_SEARCH	int
,	O
OPT_SHOWTIME	int
,	O
OPT_SHOWSCORE	int
,	O
OPT_DEBUG_INFLUENCE	int
,	O
OPT_SCORE	int
,	O
OPT_PRINTSGF	int
,	O
OPT_PROFILE_PATTERNS	int
,	O
OPT_CHINESE_RULES	int
,	O
OPT_OWL_THREATS	int
,	O
OPT_NO_OWL_THREATS	int
,	O
OPT_JAPANESE_RULES	int
,	O
OPT_FORBID_SUICIDE	int
,	O
OPT_ALLOW_SUICIDE	int
,	O
OPT_ALLOW_ALL_SUICIDE	int
,	O
OPT_SIMPLE_KO	int
,	O
OPT_NO_KO	int
,	O
OPT_POSITIONAL_SUPERKO	int
,	O
OPT_SITUATIONAL_SUPERKO	int
,	O
OPT_CAPTURE_ALL_DEAD	int
,	O
OPT_PLAY_OUT_AFTERMATH	int
,	O
OPT_MIRROR	int
,	O
OPT_MIRROR_LIMIT	int
,	O
OPT_METAMACHINE	int
,	O
OPT_RESIGN_ALLOWED	int
,	O
OPT_NEVER_RESIGN	int
,	O
OPT_MONTE_CARLO	int
,	O
OPT_MC_GAMES_PER_LEVEL	int
,	O
OPT_MC_PATTERNS	int
,	O
OPT_MC_LIST_PATTERNS	int
,	O
OPT_MC_LOAD_PATTERNS	int
}	O
;	O
enum	O
mode	enum
{	O
MODE_UNKNOWN	int
=	O
0	int
,	O
MODE_ASCII	int
,	O
MODE_GTP	int
,	O
MODE_GMP	int
,	O
MODE_SGMP	int
,	O
MODE_SGF	int
,	O
MODE_LOAD_AND_ANALYZE	int
,	O
MODE_LOAD_AND_SCORE	int
,	O
MODE_LOAD_AND_PRINT	int
,	O
MODE_SOLO	int
,	O
MODE_REPLAY	int
,	O
MODE_DECIDE_STRING	int
,	O
MODE_DECIDE_CONNECTION	int
,	O
MODE_DECIDE_OWL	int
,	O
MODE_DECIDE_DRAGON_DATA	int
,	O
MODE_DECIDE_SEMEAI	int
,	O
MODE_DECIDE_TACTICAL_SEMEAI	int
,	O
MODE_DECIDE_POSITION	int
,	O
MODE_DECIDE_EYE	int
,	O
MODE_DECIDE_COMBINATION	int
,	O
MODE_DECIDE_SURROUNDED	int
,	O
MODE_DECIDE_ORACLE	int
}	O
;	O
static	O
struct	O
gg_option	struct
const	O
long_options	array
[	O
]	O
=	O
{	O
{	O
"mode"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_MODE	int
}	O
,	O
{	O
"replay"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_REPLAY_GAME	int
}	O
,	O
{	O
"quiet"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_QUIET	int
}	O
,	O
{	O
"silent"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_QUIET	int
}	O
,	O
{	O
"gtp-input"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_INPUT	int
}	O
,	O
{	O
"gtp-connect"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_CONNECT	int
}	O
,	O
{	O
"gtp-listen"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_LISTEN	int
}	O
,	O
{	O
"gtp-dump-commands"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_DUMP_COMMANDS	int
}	O
,	O
{	O
"orientation"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_INITIAL_ORIENTATION	int
}	O
,	O
{	O
"gtp-initial-orientation"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_INITIAL_ORIENTATION	int
}	O
,	O
{	O
"gtp-version"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_GTP_VERSION	int
}	O
,	O
{	O
"infile"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'l'	O
}	O
,	O
{	O
"until"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'L'	O
}	O
,	O
{	O
"outfile"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'o'	O
}	O
,	O
{	O
"output-flags"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'O'	O
}	O
,	O
{	O
"boardsize"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_BOARDSIZE	int
}	O
,	O
{	O
"color"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_COLOR	int
}	O
,	O
{	O
"handicap"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_HANDICAPSTONES	int
}	O
,	O
{	O
"komi"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_KOMI	int
}	O
,	O
{	O
"help"	pointer
,	O
optional_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"copyright"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_SHOWCOPYRIGHT	int
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'v'	O
}	O
,	O
{	O
"allpats"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'a'	O
}	O
,	O
{	O
"printboard"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'T'	O
}	O
,	O
{	O
"printeyes"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'E'	O
}	O
,	O
{	O
"debug"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"debug-flags"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_DEBUG_FLAGS	int
}	O
,	O
{	O
"depth"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'D'	O
}	O
,	O
{	O
"backfill-depth"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'B'	O
}	O
,	O
{	O
"branch-depth"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_BRANCH_DEPTH	int
}	O
,	O
{	O
"backfill2-depth"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_BACKFILL2_DEPTH	int
}	O
,	O
{	O
"break-chain-depth"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_BREAK_CHAIN_DEPTH	int
}	O
,	O
{	O
"superstring-depth"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_SUPERSTRING_DEPTH	int
}	O
,	O
{	O
"fourlib-depth"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"ko-depth"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'K'	O
}	O
,	O
{	O
"aa-depth"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_AA_DEPTH	int
}	O
,	O
{	O
"owl-distrust"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_OWL_DISTRUST	int
}	O
,	O
{	O
"owl-branch"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_OWL_BRANCH	int
}	O
,	O
{	O
"owl-reading"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_OWL_READING	int
}	O
,	O
{	O
"owl-node-limit"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_OWL_NODE_LIMIT	int
}	O
,	O
{	O
"print-levels"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_PRINT_LEVELS	int
}	O
,	O
{	O
"level"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_LEVEL	int
}	O
,	O
{	O
"min-level"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_MIN_LEVEL	int
}	O
,	O
{	O
"max-level"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_MAX_LEVEL	int
}	O
,	O
{	O
"limit-search"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_LIMIT_SEARCH	int
}	O
,	O
{	O
"clock"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_CLOCK_TIME	int
}	O
,	O
{	O
"byo-time"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_CLOCK_BYO_TIME	int
}	O
,	O
{	O
"byo-period"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_CLOCK_BYO_PERIOD	int
}	O
,	O
{	O
"autolevel"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_AUTOLEVEL	int
}	O
,	O
{	O
"chinese-rules"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_CHINESE_RULES	int
}	O
,	O
{	O
"japanese-rules"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_JAPANESE_RULES	int
}	O
,	O
{	O
"experimental-semeai"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_EXPERIMENTAL_SEMEAI	int
}	O
,	O
{	O
"experimental-owl-ext"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_EXPERIMENTAL_OWL_EXT	int
}	O
,	O
{	O
"semeai-node-limit"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_SEMEAI_NODE_LIMIT	int
}	O
,	O
{	O
"experimental-connections"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_EXPERIMENTAL_CONNECTIONS	int
}	O
,	O
{	O
"standard-connections"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_STANDARD_CONNECTIONS	int
}	O
,	O
{	O
"standard-semeai"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_STANDARD_SEMEAI	int
}	O
,	O
{	O
"alternate-connections"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_ALTERNATE_CONNECTIONS	int
}	O
,	O
{	O
"with-break-in"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_WITH_BREAK_IN	int
}	O
,	O
{	O
"without-break-in"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_WITHOUT_BREAK_IN	int
}	O
,	O
{	O
"cosmic-gnugo"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_COSMIC_GNUGO	int
}	O
,	O
{	O
"no-cosmic-gnugo"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_NO_COSMIC_GNUGO	int
}	O
,	O
{	O
"large-scale"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_LARGE_SCALE	int
}	O
,	O
{	O
"no-large-scale"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_NO_LARGE_SCALE	int
}	O
,	O
{	O
"options"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_OPTIONS	int
}	O
,	O
{	O
"forbid-suicide"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_FORBID_SUICIDE	int
}	O
,	O
{	O
"allow-suicide"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_ALLOW_SUICIDE	int
}	O
,	O
{	O
"allow-all-suicide"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_ALLOW_ALL_SUICIDE	int
}	O
,	O
{	O
"simple-ko"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_SIMPLE_KO	int
}	O
,	O
{	O
"no-ko"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_NO_KO	int
}	O
,	O
{	O
"positional-superko"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_POSITIONAL_SUPERKO	int
}	O
,	O
{	O
"situational-superko"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_SITUATIONAL_SUPERKO	int
}	O
,	O
{	O
"capture-all-dead"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_CAPTURE_ALL_DEAD	int
}	O
,	O
{	O
"play-out-aftermath"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_PLAY_OUT_AFTERMATH	int
}	O
,	O
{	O
"cache-size"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'M'	O
}	O
,	O
{	O
"worms"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'w'	O
}	O
,	O
{	O
"moyo"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'm'	O
}	O
,	O
{	O
"benchmark"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'b'	O
}	O
,	O
{	O
"statistics"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"trace"	pointer
,	O
no_argument	int
,	O
0	int
,	O
't'	O
}	O
,	O
{	O
"seed"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'r'	O
}	O
,	O
{	O
"decide-string"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_STRING	int
}	O
,	O
{	O
"decide-connection"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_CONNECTION	int
}	O
,	O
{	O
"decide-dragon"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_OWL	int
}	O
,	O
{	O
"decide-owl"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_OWL	int
}	O
,	O
{	O
"decide-dragon-data"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_DRAGON_DATA	int
}	O
,	O
{	O
"decide-semeai"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_SEMEAI	int
}	O
,	O
{	O
"decide-tactical-semeai"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_TACTICAL_SEMEAI	int
}	O
,	O
{	O
"decide-position"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_DECIDE_POSITION	int
}	O
,	O
{	O
"decide-surrounded"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_SURROUNDED	int
}	O
,	O
{	O
"decide-eye"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_DECIDE_EYE	int
}	O
,	O
{	O
"decide-combination"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_DECIDE_COMBINATION	int
}	O
,	O
{	O
"decide-oracle"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_DECIDE_ORACLE	int
}	O
,	O
{	O
"nofusekidb"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_NOFUSEKIDB	int
}	O
,	O
{	O
"nofuseki"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_NOFUSEKI	int
}	O
,	O
{	O
"nojosekidb"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_NOJOSEKIDB	int
}	O
,	O
{	O
"debug-influence"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_DEBUG_INFLUENCE	int
}	O
,	O
{	O
"showtime"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_SHOWTIME	int
}	O
,	O
{	O
"showscore"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_SHOWSCORE	int
}	O
,	O
{	O
"score"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_SCORE	int
}	O
,	O
{	O
"printsgf"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_PRINTSGF	int
}	O
,	O
{	O
"profile-patterns"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_PROFILE_PATTERNS	int
}	O
,	O
{	O
"mirror"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_MIRROR	int
}	O
,	O
{	O
"mirror-limit"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_MIRROR_LIMIT	int
}	O
,	O
{	O
"metamachine"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_METAMACHINE	int
}	O
,	O
{	O
"resign-allowed"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_RESIGN_ALLOWED	int
}	O
,	O
{	O
"never-resign"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_NEVER_RESIGN	int
}	O
,	O
{	O
"monte-carlo"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_MONTE_CARLO	int
}	O
,	O
{	O
"mc-games-per-level"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_MC_GAMES_PER_LEVEL	int
}	O
,	O
{	O
"mc-patterns"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_MC_PATTERNS	int
}	O
,	O
{	O
"mc-list-patterns"	pointer
,	O
no_argument	int
,	O
0	int
,	O
OPT_MC_LIST_PATTERNS	int
}	O
,	O
{	O
"mc-load-patterns"	pointer
,	O
required_argument	int
,	O
0	int
,	O
OPT_MC_LOAD_PATTERNS	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
Gameinfo	struct
gameinfo	pointer
;	O
SGFTree	struct
sgftree	struct
;	O
int	O
i	int
;	O
int	O
mandated_color	int
=	O
EMPTY	int
;	O
enum	O
mode	enum
playmode	enum
=	O
MODE_UNKNOWN	int
;	O
int	O
replay_color	int
=	O
EMPTY	int
;	O
char	O
*	O
infilename	pointer
=	O
NULL	O
;	O
char	O
*	O
untilstring	pointer
=	O
NULL	O
;	O
char	O
*	O
scoringmode	pointer
=	O
NULL	O
;	O
char	O
*	O
outfile	pointer
=	O
NULL	O
;	O
char	O
*	O
outflags	pointer
=	O
NULL	O
;	O
char	O
*	O
gtpfile	pointer
=	O
NULL	O
;	O
char	O
*	O
gtp_dump_commands_file	pointer
=	O
NULL	O
;	O
int	O
gtp_tcp_ip_mode	int
=	O
0	int
;	O
char	O
*	O
gtp_tcp_ip_address	pointer
=	O
NULL	O
;	O
char	O
*	O
printsgffile	pointer
=	O
NULL	O
;	O
char	O
decide_this	array
[	O
8	int
]	O
;	O
char	O
*	O
decide_that	pointer
=	O
NULL	O
;	O
char	O
debuginfluence_move	array
[	O
4	int
]	O
=	O
"\0"	pointer
;	O
int	O
benchmark	int
=	O
0	int
;	O
FILE	struct
*	O
output_check	pointer
;	O
int	O
orientation	int
=	O
0	int
;	O
char	O
mc_pattern_name	array
[	O
40	int
]	O
=	O
""	pointer
;	O
char	O
mc_pattern_filename	array
[	O
320	int
]	O
=	O
""	pointer
;	O
float	O
memory	float
=	O
(	O
float	O
)	O
DEFAULT_MEMORY	O
;	O
int	O
seed	int
=	O
0	int
;	O
int	O
seed_specified	int
=	O
0	int
;	O
int	O
requested_boardsize	int
=	O
-	O
1	int
;	O
sgftree_clear	function
(	O
&	O
sgftree	struct
)	O
;	O
gameinfo_clear	function
(	O
&	O
gameinfo	pointer
)	O
;	O
while	O
(	O
(	O
i	int
=	O
gg_getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"-ab:B:d:D:EF:gh::K:l:L:M:m:o:O:p:r:fsStTvw"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
{	O
switch	O
(	O
i	int
)	O
{	O
case	O
'T'	O
:	O
printboard	int
++	O
;	O
break	O
;	O
case	O
't'	O
:	O
++	O
verbose	int
;	O
break	O
;	O
case	O
'a'	O
:	O
allpats	int
=	O
1	int
;	O
break	O
;	O
case	O
1	int
:	O
case	O
'l'	O
:	O
infilename	pointer
=	O
gg_optarg	pointer
;	O
break	O
;	O
case	O
'b'	O
:	O
benchmark	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
playmode	enum
=	O
MODE_SOLO	int
;	O
break	O
;	O
case	O
'r'	O
:	O
seed	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
seed_specified	int
=	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
showstatistics	int
=	O
1	int
;	O
break	O
;	O
case	O
'w'	O
:	O
printworms	int
=	O
1	int
;	O
break	O
;	O
case	O
'm'	O
:	O
printmoyo	int
=	O
strtol	function
(	O
gg_optarg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
debug	int
^=	O
strtol	function
(	O
gg_optarg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
mandated_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
memory	float
=	O
atof	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
printboard	int
=	O
2	int
;	O
break	O
;	O
case	O
'B'	O
:	O
mandated_backfill_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
mandated_fourlib_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
'K'	O
:	O
mandated_ko_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
untilstring	pointer
=	O
gg_optarg	pointer
;	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>=	O
sizeof	O
(	O
outfilename	array
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Too long filename given as value to -o option.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
outfile	pointer
=	O
gg_optarg	pointer
;	O
strcpy	function
(	O
outfilename	array
,	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
'O'	O
:	O
outflags	pointer
=	O
gg_optarg	pointer
;	O
output_flags	int
=	O
0	int
;	O
if	O
(	O
outflags	pointer
)	O
while	O
(	O
*	O
outflags	pointer
)	O
{	O
switch	O
(	O
*	O
outflags	pointer
)	O
{	O
case	O
'd'	O
:	O
output_flags	int
|=	O
OUTPUT_MARKDRAGONS	int
;	O
break	O
;	O
case	O
'v'	O
:	O
output_flags	int
|=	O
OUTPUT_MOVEVALUES	int
;	O
break	O
;	O
}	O
outflags	pointer
++	O
;	O
}	O
break	O
;	O
case	O
OPT_QUIET	int
:	O
quiet	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_GTP_INPUT	int
:	O
case	O
OPT_GTP_CONNECT	int
:	O
case	O
OPT_GTP_LISTEN	int
:	O
if	O
(	O
gtp_tcp_ip_mode	int
!=	O
0	int
||	O
gtpfile	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
(	O
"Options `--gtp-input', `--gtp-connect' and `--gtp-listen' "	pointer
"are mutually-exclusive\n"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
i	int
==	O
OPT_GTP_INPUT	int
)	O
gtpfile	pointer
=	O
gg_optarg	pointer
;	O
else	O
{	O
gtp_tcp_ip_mode	int
=	O
i	int
;	O
gtp_tcp_ip_address	pointer
=	O
gg_optarg	pointer
;	O
}	O
break	O
;	O
case	O
OPT_GTP_DUMP_COMMANDS	int
:	O
gtp_dump_commands_file	pointer
=	O
gg_optarg	pointer
;	O
break	O
;	O
case	O
OPT_GTP_INITIAL_ORIENTATION	int
:	O
orientation	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
if	O
(	O
orientation	int
<	O
0	int
||	O
orientation	int
>	O
7	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid orientation: %d.\n"	pointer
,	O
orientation	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Try `gnugo --help' for more information.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_GTP_VERSION	int
:	O
gtp_version	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_OPTIONS	int
:	O
if	O
(	O
USE_BREAK_IN	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"configure option enabled: experimental break-ins\n"	pointer
)	O
;	O
if	O
(	O
COSMIC_GNUGO	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"configure option enabled: cosmic GNU Go \n"	pointer
)	O
;	O
if	O
(	O
LARGE_SCALE	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"configure option enabled: large scale captures \n"	pointer
)	O
;	O
if	O
(	O
EXPERIMENTAL_CONNECTIONS	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"configure option enabled: experimental connections\n"	pointer
)	O
;	O
if	O
(	O
ALTERNATE_CONNECTIONS	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"configure option enabled: alternate connections\n"	pointer
)	O
;	O
if	O
(	O
EXPERIMENTAL_OWL_EXT	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"configure option enabled: experimental GAIN/LOSS codes\n"	pointer
)	O
;	O
if	O
(	O
OWL_THREATS	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"configure option enabled: owl threats\n"	pointer
)	O
;	O
if	O
(	O
RESIGNATION_ALLOWED	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"configure option enabled: resignation allowed\n"	pointer
)	O
;	O
if	O
(	O
ORACLE	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"configure option enabled: oracle\n"	pointer
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"Owl node limit: %d\n"	pointer
,	O
OWL_NODE_LIMIT	int
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"Semeai node limit: %d\n"	pointer
,	O
SEMEAI_NODE_LIMIT	int
)	O
;	O
if	O
(	O
DEFAULT_MEMORY	O
==	O
-	O
1	int
)	O
fprintf	function
(	O
stdout	pointer
,	O
"Cache size: %d MB (special default value)\n"	pointer
,	O
DEFAULT_MEMORY	O
)	O
;	O
else	O
fprintf	function
(	O
stdout	pointer
,	O
"Cache size: %d MB\n"	pointer
,	O
DEFAULT_MEMORY	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
OPT_SHOWTIME	int
:	O
showtime	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_SHOWSCORE	int
:	O
showscore	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_HANDICAPSTONES	int
:	O
{	O
int	O
requested_handicap	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
if	O
(	O
requested_handicap	int
<	O
0	int
||	O
requested_handicap	int
>	O
MAX_HANDICAP	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Unsupported handicap: %d.\n"	pointer
,	O
requested_handicap	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Try `gnugo --help' for more information.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
gameinfo	pointer
.	O
handicap	int
=	O
requested_handicap	int
;	O
}	O
break	O
;	O
case	O
OPT_BOARDSIZE	int
:	O
requested_boardsize	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_KOMI	int
:	O
if	O
(	O
sscanf	function
(	O
gg_optarg	pointer
,	O
"%f"	pointer
,	O
&	O
komi	float
)	O
!=	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid komi selection: %s\n"	pointer
,	O
gg_optarg	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Try `gnugo --help' for more information.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_CHINESE_RULES	int
:	O
chinese_rules	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_OWL_THREATS	int
:	O
owl_threats	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_OWL_THREATS	int
:	O
owl_threats	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_METAMACHINE	int
:	O
metamachine	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_JAPANESE_RULES	int
:	O
chinese_rules	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_EXPERIMENTAL_OWL_EXT	int
:	O
experimental_owl_ext	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_SEMEAI_NODE_LIMIT	int
:	O
mandated_semeai_node_limit	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_EXPERIMENTAL_CONNECTIONS	int
:	O
experimental_connections	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_STANDARD_CONNECTIONS	int
:	O
experimental_connections	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_ALTERNATE_CONNECTIONS	int
:	O
alternate_connections	int
=	O
!	O
alternate_connections	int
;	O
break	O
;	O
case	O
OPT_WITH_BREAK_IN	int
:	O
experimental_break_in	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_WITHOUT_BREAK_IN	int
:	O
experimental_break_in	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_COSMIC_GNUGO	int
:	O
cosmic_gnugo	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_COSMIC_GNUGO	int
:	O
cosmic_gnugo	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_LARGE_SCALE	int
:	O
large_scale	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NO_LARGE_SCALE	int
:	O
large_scale	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_FORBID_SUICIDE	int
:	O
suicide_rule	enum
=	O
FORBIDDEN	int
;	O
break	O
;	O
case	O
OPT_ALLOW_SUICIDE	int
:	O
suicide_rule	enum
=	O
ALLOWED	int
;	O
break	O
;	O
case	O
OPT_ALLOW_ALL_SUICIDE	int
:	O
suicide_rule	enum
=	O
ALL_ALLOWED	int
;	O
break	O
;	O
case	O
OPT_SIMPLE_KO	int
:	O
ko_rule	enum
=	O
SIMPLE	int
;	O
break	O
;	O
case	O
OPT_NO_KO	int
:	O
ko_rule	enum
=	O
NONE	int
;	O
break	O
;	O
case	O
OPT_POSITIONAL_SUPERKO	int
:	O
ko_rule	enum
=	O
PSK	int
;	O
break	O
;	O
case	O
OPT_SITUATIONAL_SUPERKO	int
:	O
ko_rule	enum
=	O
SSK	int
;	O
break	O
;	O
case	O
OPT_CAPTURE_ALL_DEAD	int
:	O
capture_all_dead	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_PLAY_OUT_AFTERMATH	int
:	O
play_out_aftermath	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_RESIGN_ALLOWED	int
:	O
resign_allowed	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NEVER_RESIGN	int
:	O
resign_allowed	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_MONTE_CARLO	int
:	O
use_monte_carlo_genmove	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_MC_GAMES_PER_LEVEL	int
:	O
mc_games_per_level	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_MC_PATTERNS	int
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>=	O
sizeof	O
(	O
mc_pattern_name	array
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Too long name given as value to --mc-patterns option.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	function
(	O
mc_pattern_name	array
,	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_MC_LIST_PATTERNS	int
:	O
list_mc_patterns	function
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
OPT_MC_LOAD_PATTERNS	int
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>=	O
sizeof	O
(	O
mc_pattern_filename	array
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Too long name given as value to --mc-load-patterns option.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	function
(	O
mc_pattern_filename	array
,	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_MODE	int
:	O
if	O
(	O
strcmp	function
(	O
gg_optarg	pointer
,	O
"ascii"	pointer
)	O
==	O
0	int
)	O
playmode	enum
=	O
MODE_ASCII	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
gg_optarg	pointer
,	O
"gtp"	pointer
)	O
==	O
0	int
)	O
playmode	enum
=	O
MODE_GTP	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
gg_optarg	pointer
,	O
"gmp"	pointer
)	O
==	O
0	int
)	O
playmode	enum
=	O
MODE_GMP	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
gg_optarg	pointer
,	O
"sgmp"	pointer
)	O
==	O
0	int
)	O
playmode	enum
=	O
MODE_SGMP	int
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid mode selection: %s\n"	pointer
,	O
gg_optarg	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Try `gnugo --help' for more information.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_DECIDE_STRING	int
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>	O
3	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid board coordinate: %s\n"	pointer
,	O
gg_optarg	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	function
(	O
decide_this	array
,	O
gg_optarg	pointer
)	O
;	O
playmode	enum
=	O
MODE_DECIDE_STRING	int
;	O
break	O
;	O
case	O
OPT_DECIDE_CONNECTION	int
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>	O
7	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-connection [first string]/[second string]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
strcpy	function
(	O
decide_this	array
,	O
gg_optarg	pointer
)	O
;	O
strtok	function
(	O
decide_this	array
,	O
"/"	pointer
)	O
;	O
decide_that	pointer
=	O
strtok	function
(	O
NULL	O
,	O
"/"	pointer
)	O
;	O
if	O
(	O
!	O
decide_that	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-connection [first string]/[second string]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
playmode	enum
=	O
MODE_DECIDE_CONNECTION	int
;	O
break	O
;	O
case	O
OPT_DECIDE_OWL	int
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>	O
3	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid board coordinate: %s\n"	pointer
,	O
gg_optarg	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	function
(	O
decide_this	array
,	O
gg_optarg	pointer
)	O
;	O
playmode	enum
=	O
MODE_DECIDE_OWL	int
;	O
break	O
;	O
case	O
OPT_DECIDE_DRAGON_DATA	int
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>	O
3	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid board coordinate: %s\n"	pointer
,	O
gg_optarg	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	function
(	O
decide_this	array
,	O
gg_optarg	pointer
)	O
;	O
playmode	enum
=	O
MODE_DECIDE_DRAGON_DATA	int
;	O
break	O
;	O
case	O
OPT_DECIDE_SEMEAI	int
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>	O
7	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-semeai [first dragon]/[second dragon]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
strcpy	function
(	O
decide_this	array
,	O
gg_optarg	pointer
)	O
;	O
strtok	function
(	O
decide_this	array
,	O
"/"	pointer
)	O
;	O
decide_that	pointer
=	O
strtok	function
(	O
NULL	O
,	O
"/"	pointer
)	O
;	O
if	O
(	O
!	O
decide_that	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-semeai [first dragon]/[second dragon]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
playmode	enum
=	O
MODE_DECIDE_SEMEAI	int
;	O
break	O
;	O
case	O
OPT_DECIDE_TACTICAL_SEMEAI	int
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>	O
7	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-tactical-semeai [first dragon]/[second dragon]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
strcpy	function
(	O
decide_this	array
,	O
gg_optarg	pointer
)	O
;	O
strtok	function
(	O
decide_this	array
,	O
"/"	pointer
)	O
;	O
decide_that	pointer
=	O
strtok	function
(	O
NULL	O
,	O
"/"	pointer
)	O
;	O
if	O
(	O
!	O
decide_that	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-tactical-semeai [first dragon]/[second dragon]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
playmode	enum
=	O
MODE_DECIDE_TACTICAL_SEMEAI	int
;	O
break	O
;	O
case	O
OPT_DECIDE_POSITION	int
:	O
playmode	enum
=	O
MODE_DECIDE_POSITION	int
;	O
break	O
;	O
case	O
OPT_DECIDE_EYE	int
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>	O
3	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid board coordinate: %s\n"	pointer
,	O
gg_optarg	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	function
(	O
decide_this	array
,	O
gg_optarg	pointer
)	O
;	O
playmode	enum
=	O
MODE_DECIDE_EYE	int
;	O
break	O
;	O
case	O
OPT_DECIDE_COMBINATION	int
:	O
playmode	enum
=	O
MODE_DECIDE_COMBINATION	int
;	O
break	O
;	O
case	O
OPT_DECIDE_SURROUNDED	int
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>	O
3	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid board coordinate: %s\n"	pointer
,	O
gg_optarg	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	function
(	O
decide_this	array
,	O
gg_optarg	pointer
)	O
;	O
playmode	enum
=	O
MODE_DECIDE_SURROUNDED	int
;	O
break	O
;	O
case	O
OPT_DECIDE_ORACLE	int
:	O
playmode	enum
=	O
MODE_DECIDE_ORACLE	int
;	O
break	O
;	O
case	O
OPT_BRANCH_DEPTH	int
:	O
mandated_branch_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_BACKFILL2_DEPTH	int
:	O
mandated_backfill2_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_BREAK_CHAIN_DEPTH	int
:	O
mandated_break_chain_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_SUPERSTRING_DEPTH	int
:	O
mandated_superstring_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_AA_DEPTH	int
:	O
mandated_aa_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_OWL_DISTRUST	int
:	O
mandated_owl_distrust_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_OWL_BRANCH	int
:	O
mandated_owl_branch_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_OWL_READING	int
:	O
mandated_owl_reading_depth	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_OWL_NODE_LIMIT	int
:	O
mandated_owl_node_limit	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_NOFUSEKIDB	int
:	O
fusekidb	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_NOFUSEKI	int
:	O
disable_fuseki	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_NOJOSEKIDB	int
:	O
josekidb	int
=	O
0	int
;	O
break	O
;	O
case	O
OPT_LEVEL	int
:	O
set_level	function
(	O
atoi	function
(	O
gg_optarg	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPT_MIN_LEVEL	int
:	O
set_min_level	function
(	O
atoi	function
(	O
gg_optarg	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPT_MAX_LEVEL	int
:	O
set_max_level	function
(	O
atoi	function
(	O
gg_optarg	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPT_LIMIT_SEARCH	int
:	O
{	O
int	O
pos	int
=	O
string_to_location	function
(	O
board_size	int
,	O
gg_optarg	pointer
)	O
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: use --limit-search <pos>\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
set_search_diamond	function
(	O
pos	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_CLOCK_TIME	int
:	O
clock_settings	function
(	O
atoi	function
(	O
gg_optarg	pointer
)	O
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
OPT_CLOCK_BYO_TIME	int
:	O
clock_settings	function
(	O
-	O
1	int
,	O
atoi	function
(	O
gg_optarg	pointer
)	O
,	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
OPT_CLOCK_BYO_PERIOD	int
:	O
clock_settings	function
(	O
-	O
1	int
,	O
-	O
1	int
,	O
atoi	function
(	O
gg_optarg	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPT_AUTOLEVEL	int
:	O
autolevel_on	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_DEBUG_INFLUENCE	int
:	O
if	O
(	O
strlen	function
(	O
gg_optarg	pointer
)	O
>	O
3	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid board coordinate: %s\n"	pointer
,	O
gg_optarg	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
strcpy	function
(	O
debuginfluence_move	array
,	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPT_REPLAY_GAME	int
:	O
playmode	enum
=	O
MODE_REPLAY	int
;	O
if	O
(	O
strcmp	function
(	O
gg_optarg	pointer
,	O
"white"	pointer
)	O
==	O
0	int
)	O
replay_color	int
=	O
WHITE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
gg_optarg	pointer
,	O
"black"	pointer
)	O
==	O
0	int
)	O
replay_color	int
=	O
BLACK	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
gg_optarg	pointer
,	O
"both"	pointer
)	O
==	O
0	int
)	O
replay_color	int
=	O
GRAY	int
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid replay color: %s\n"	pointer
,	O
gg_optarg	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Try `gnugo --help' for more information.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_SCORE	int
:	O
scoringmode	pointer
=	O
gg_optarg	pointer
;	O
if	O
(	O
playmode	enum
==	O
MODE_UNKNOWN	int
)	O
playmode	enum
=	O
MODE_LOAD_AND_SCORE	int
;	O
break	O
;	O
case	O
OPT_PRINTSGF	int
:	O
playmode	enum
=	O
MODE_LOAD_AND_PRINT	int
;	O
printsgffile	pointer
=	O
gg_optarg	pointer
;	O
break	O
;	O
case	O
OPT_PROFILE_PATTERNS	int
:	O
profile_patterns	int
=	O
1	int
;	O
prepare_pattern_profiling	function
(	O
)	O
;	O
break	O
;	O
case	O
OPT_COLOR	int
:	O
if	O
(	O
strcmp	function
(	O
gg_optarg	pointer
,	O
"white"	pointer
)	O
==	O
0	int
)	O
mandated_color	int
=	O
WHITE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
gg_optarg	pointer
,	O
"black"	pointer
)	O
==	O
0	int
)	O
mandated_color	int
=	O
BLACK	int
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Invalid color selection: %s\n"	pointer
,	O
gg_optarg	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Try `gnugo --help' for more information.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
break	O
;	O
case	O
OPT_SHOWCOPYRIGHT	int
:	O
show_copyright	function
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
OPT_MIRROR	int
:	O
play_mirror_go	int
=	O
1	int
;	O
break	O
;	O
case	O
OPT_MIRROR_LIMIT	int
:	O
mirror_stones_limit	int
=	O
atoi	function
(	O
gg_optarg	pointer
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
show_version	function
(	O
)	O
;	O
show_copyright	function
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
'h'	O
:	O
show_version	function
(	O
)	O
;	O
if	O
(	O
gg_optarg	pointer
)	O
{	O
if	O
(	O
strncmp	function
(	O
gg_optarg	pointer
,	O
"debug"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
show_debug_help	function
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
gg_optind	int
<	O
argc	int
)	O
{	O
if	O
(	O
strncmp	function
(	O
argv	pointer
[	O
gg_optind	int
]	O
,	O
"debug"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
show_debug_help	function
(	O
)	O
;	O
}	O
else	O
show_help	function
(	O
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
OPT_DEBUG_FLAGS	int
:	O
show_debug_flags	function
(	O
)	O
;	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
OPT_PRINT_LEVELS	int
:	O
{	O
int	O
lev	int
;	O
for	O
(	O
lev	int
=	O
12	int
;	O
lev	int
>=	O
0	int
;	O
lev	int
--	O
)	O
set_depth_values	function
(	O
lev	int
,	O
1	int
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
break	O
;	O
case	O
'?'	O
:	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Try `gnugo --help' for more information.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
if	O
(	O
requested_boardsize	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
!	O
check_boardsize	function
(	O
requested_boardsize	int
,	O
stderr	pointer
)	O
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
gnugo_clear_board	function
(	O
requested_boardsize	int
)	O
;	O
}	O
if	O
(	O
!	O
seed_specified	int
)	O
seed	int
=	O
time	function
(	O
0	int
)	O
;	O
init_gnugo	function
(	O
memory	float
,	O
seed	int
)	O
;	O
if	O
(	O
strlen	function
(	O
mc_pattern_filename	array
)	O
>	O
0	int
)	O
{	O
if	O
(	O
!	O
mc_load_patterns_from_db	function
(	O
mc_pattern_filename	array
,	O
NULL	O
)	O
)	O
return	O
EXIT_FAILURE	int
;	O
}	O
else	O
if	O
(	O
strlen	function
(	O
mc_pattern_name	array
)	O
>	O
0	int
)	O
{	O
if	O
(	O
!	O
choose_mc_patterns	function
(	O
mc_pattern_name	array
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Unknown Monte Carlo pattern database name %s.\n"	pointer
,	O
mc_pattern_name	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Use \"--mc-list-patterns\" to list the available databases.\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
if	O
(	O
infilename	pointer
)	O
{	O
if	O
(	O
!	O
sgftree_readfile	function
(	O
&	O
sgftree	struct
,	O
infilename	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot open or parse '%s'\n"	pointer
,	O
infilename	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
gameinfo_play_sgftree_rot	function
(	O
&	O
gameinfo	pointer
,	O
&	O
sgftree	struct
,	O
untilstring	pointer
,	O
orientation	int
)	O
==	O
EMPTY	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot load '%s'\n"	pointer
,	O
infilename	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
else	O
sgftreeCreateHeaderNode	function
(	O
&	O
sgftree	struct
,	O
board_size	int
,	O
komi	float
,	O
handicap	int
)	O
;	O
gameinfo	pointer
.	O
game_record	struct
=	O
sgftree	struct
;	O
if	O
(	O
debuginfluence_move	array
[	O
0	int
]	O
)	O
{	O
int	O
pos	int
=	O
string_to_location	function
(	O
board_size	int
,	O
debuginfluence_move	array
)	O
;	O
debug_influence_move	function
(	O
pos	int
)	O
;	O
}	O
if	O
(	O
playmode	enum
==	O
MODE_UNKNOWN	int
)	O
{	O
if	O
(	O
infilename	pointer
)	O
playmode	enum
=	O
MODE_LOAD_AND_ANALYZE	int
;	O
else	O
playmode	enum
=	O
(	O
isatty	function
(	O
0	int
)	O
)	O
?	O
MODE_ASCII	int
:	O
MODE_GMP	int
;	O
}	O
if	O
(	O
outfile	pointer
&&	O
playmode	enum
!=	O
MODE_LOAD_AND_PRINT	int
)	O
{	O
output_check	pointer
=	O
fopen	function
(	O
outfile	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
output_check	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: could not open '%s' for writing\n"	pointer
,	O
outfile	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
fclose	function
(	O
output_check	pointer
)	O
;	O
}	O
switch	O
(	O
playmode	enum
)	O
{	O
case	O
MODE_GMP	int
:	O
case	O
MODE_SGMP	int
:	O
resign_allowed	int
=	O
0	int
;	O
gameinfo	pointer
.	O
computer_player	int
=	O
mandated_color	int
;	O
play_gmp	function
(	O
&	O
gameinfo	pointer
,	O
playmode	enum
==	O
MODE_SGMP	int
)	O
;	O
break	O
;	O
case	O
MODE_SOLO	int
:	O
play_solo	function
(	O
&	O
gameinfo	pointer
,	O
benchmark	int
)	O
;	O
break	O
;	O
case	O
MODE_REPLAY	int
:	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"You must use -l infile with replay mode.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
play_replay	function
(	O
&	O
sgftree	struct
,	O
replay_color	int
)	O
;	O
break	O
;	O
case	O
MODE_LOAD_AND_ANALYZE	int
:	O
if	O
(	O
mandated_color	int
!=	O
EMPTY	int
)	O
gameinfo	pointer
.	O
to_move	int
=	O
mandated_color	int
;	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"You must use -l infile with load and analyze mode.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
load_and_analyze_sgf_file	function
(	O
&	O
gameinfo	pointer
)	O
;	O
break	O
;	O
case	O
MODE_LOAD_AND_SCORE	int
:	O
if	O
(	O
mandated_color	int
!=	O
EMPTY	int
)	O
gameinfo	pointer
.	O
to_move	int
=	O
mandated_color	int
;	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --score must be used with -l\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
load_and_score_sgf_file	function
(	O
&	O
sgftree	struct
,	O
&	O
gameinfo	pointer
,	O
scoringmode	pointer
)	O
;	O
break	O
;	O
case	O
MODE_LOAD_AND_PRINT	int
:	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --printsgf must be used with -l\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
mandated_color	int
!=	O
EMPTY	int
)	O
gameinfo	pointer
.	O
to_move	int
=	O
mandated_color	int
;	O
sgffile_printsgf	function
(	O
gameinfo	pointer
.	O
to_move	int
,	O
printsgffile	pointer
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_STRING	int
:	O
{	O
int	O
str	int
;	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-string must be used with -l\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
str	int
=	O
string_to_location	function
(	O
board_size	int
,	O
decide_this	array
)	O
;	O
if	O
(	O
str	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-string: strange coordinate \n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_string	function
(	O
str	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_CONNECTION	int
:	O
{	O
int	O
str1	int
,	O
str2	int
;	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-connection must be used with -l\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
str1	int
=	O
string_to_location	function
(	O
board_size	int
,	O
decide_this	array
)	O
;	O
if	O
(	O
str1	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-connection [first string]/[second string]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
str2	int
=	O
string_to_location	function
(	O
board_size	int
,	O
decide_that	pointer
)	O
;	O
if	O
(	O
str2	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-connection [first string]/[second string]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_connection	function
(	O
str1	int
,	O
str2	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_OWL	int
:	O
{	O
int	O
pos	int
;	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-dragon must be used with -l\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos	int
=	O
string_to_location	function
(	O
board_size	int
,	O
decide_this	array
)	O
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-dragon: strange coordinate \n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_owl	function
(	O
pos	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_DRAGON_DATA	int
:	O
{	O
int	O
pos	int
;	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-dragon-data must be used with -l\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos	int
=	O
string_to_location	function
(	O
board_size	int
,	O
decide_this	array
)	O
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-dragon-data: strange coordinate \n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_dragon_data	function
(	O
pos	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_SEMEAI	int
:	O
{	O
int	O
pos1	int
,	O
pos2	int
;	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-semeai must be used with -l\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos1	int
=	O
string_to_location	function
(	O
board_size	int
,	O
decide_this	array
)	O
;	O
if	O
(	O
pos1	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-semeai [first dragon]/[second dragon]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos2	int
=	O
string_to_location	function
(	O
board_size	int
,	O
decide_that	pointer
)	O
;	O
if	O
(	O
pos2	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-semeai [first dragon]/[second dragon]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_semeai	function
(	O
pos1	int
,	O
pos2	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_TACTICAL_SEMEAI	int
:	O
{	O
int	O
pos1	int
,	O
pos2	int
;	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-tactical-semeai must be used with -l\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos1	int
=	O
string_to_location	function
(	O
board_size	int
,	O
decide_this	array
)	O
;	O
if	O
(	O
pos1	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-tactical-semeai [first dragon]/[second dragon]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos2	int
=	O
string_to_location	function
(	O
board_size	int
,	O
decide_that	pointer
)	O
;	O
if	O
(	O
pos2	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-tactical-semeai [first dragon]/[second dragon]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_tactical_semeai	function
(	O
pos1	int
,	O
pos2	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_POSITION	int
:	O
{	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-position must be used with -l\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_position	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_EYE	int
:	O
{	O
int	O
pos	int
;	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-eye must be used with -l\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
pos	int
=	O
string_to_location	function
(	O
board_size	int
,	O
decide_this	array
)	O
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-eye: strange coordinate \n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_eye	function
(	O
pos	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_COMBINATION	int
:	O
{	O
int	O
color	int
;	O
if	O
(	O
!	O
infilename	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: --decide-combination must be used with -l\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
color	int
=	O
gameinfo	pointer
.	O
to_move	int
;	O
if	O
(	O
mandated_color	int
!=	O
EMPTY	int
)	O
color	int
=	O
mandated_color	int
;	O
decide_combination	function
(	O
color	int
)	O
;	O
}	O
break	O
;	O
case	O
MODE_DECIDE_SURROUNDED	int
:	O
{	O
int	O
pos	int
=	O
string_to_location	function
(	O
board_size	int
,	O
decide_this	array
)	O
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: --decide-surrounded [pos]\n"	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
decide_surrounded	function
(	O
pos	int
)	O
;	O
break	O
;	O
}	O
case	O
MODE_GTP	int
:	O
{	O
FILE	struct
*	O
gtp_input_FILE	pointer
=	O
stdin	pointer
;	O
FILE	struct
*	O
gtp_output_FILE	pointer
=	O
stdout	pointer
;	O
FILE	struct
*	O
gtp_dump_commands_FILE	pointer
=	O
NULL	O
;	O
if	O
(	O
gtpfile	pointer
!=	O
NULL	O
)	O
{	O
gtp_input_FILE	pointer
=	O
fopen	function
(	O
gtpfile	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
gtp_input_FILE	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: Cannot open file %s\n"	pointer
,	O
gtpfile	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
else	O
if	O
(	O
gtp_tcp_ip_mode	int
!=	O
0	int
)	O
{	O
unsigned	O
int	O
port	int
=	O
65536	int
;	O
char	O
*	O
port_string	pointer
=	O
strchr	function
(	O
gtp_tcp_ip_address	pointer
,	O
':'	O
)	O
;	O
const	O
char	O
*	O
host_name	pointer
=	O
NULL	O
;	O
if	O
(	O
port_string	pointer
)	O
{	O
host_name	pointer
=	O
gtp_tcp_ip_address	pointer
;	O
*	O
port_string	pointer
++	O
=	O
0	int
;	O
sscanf	function
(	O
port_string	pointer
,	O
"%u"	pointer
,	O
&	O
port	int
)	O
;	O
}	O
else	O
sscanf	function
(	O
gtp_tcp_ip_address	pointer
,	O
"%u"	pointer
,	O
&	O
port	int
)	O
;	O
if	O
(	O
port	int
>	O
65535	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"A valid TCP/IP port number expected\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
gtp_tcp_ip_mode	int
==	O
OPT_GTP_CONNECT	int
)	O
{	O
socket_connect_to	function
(	O
host_name	pointer
,	O
port	int
,	O
&	O
gtp_input_FILE	pointer
,	O
&	O
gtp_output_FILE	pointer
)	O
;	O
}	O
else	O
{	O
socket_listen_at	function
(	O
host_name	pointer
,	O
port	int
,	O
&	O
gtp_input_FILE	pointer
,	O
&	O
gtp_output_FILE	pointer
)	O
;	O
}	O
}	O
if	O
(	O
gtp_dump_commands_file	pointer
!=	O
NULL	O
)	O
{	O
gtp_dump_commands_FILE	pointer
=	O
fopen	function
(	O
gtp_dump_commands_file	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
gtp_dump_commands_FILE	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"gnugo: Cannot open file %s\n"	pointer
,	O
gtp_dump_commands_file	pointer
)	O
;	O
return	O
EXIT_FAILURE	int
;	O
}	O
}	O
play_gtp	function
(	O
gtp_input_FILE	pointer
,	O
gtp_output_FILE	pointer
,	O
gtp_dump_commands_FILE	pointer
,	O
orientation	int
)	O
;	O
if	O
(	O
gtp_dump_commands_FILE	pointer
)	O
fclose	function
(	O
gtp_dump_commands_FILE	pointer
)	O
;	O
if	O
(	O
gtp_tcp_ip_mode	int
==	O
OPT_GTP_CONNECT	int
)	O
socket_close_connection	function
(	O
gtp_input_FILE	pointer
,	O
gtp_output_FILE	pointer
)	O
;	O
else	O
if	O
(	O
gtp_tcp_ip_mode	int
==	O
OPT_GTP_LISTEN	int
)	O
socket_stop_listening	function
(	O
gtp_input_FILE	pointer
,	O
gtp_output_FILE	pointer
)	O
;	O
}	O
break	O
;	O
case	O
MODE_ASCII	int
:	O
default	O
:	O
if	O
(	O
mandated_color	int
!=	O
EMPTY	int
)	O
gameinfo	pointer
.	O
computer_player	int
=	O
OTHER_COLOR	O
(	O
mandated_color	int
)	O
;	O
if	O
(	O
!	O
quiet	int
)	O
{	O
show_version	function
(	O
)	O
;	O
show_copyright	function
(	O
)	O
;	O
}	O
play_ascii	function
(	O
&	O
sgftree	struct
,	O
&	O
gameinfo	pointer
,	O
infilename	pointer
,	O
untilstring	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
profile_patterns	int
)	O
report_pattern_profiling	function
(	O
)	O
;	O
sgfFreeNode	function
(	O
sgftree	struct
.	O
root	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
show_version	function
(	O
void	O
)	O
{	O
printf	function
(	O
"GNU Go %s\n"	pointer
,	O
VERSION	pointer
)	O
;	O
}	O
static	O
void	O
show_help	function
(	O
void	O
)	O
{	O
printf	function
(	O
USAGE	pointer
,	O
DEFAULT_LEVEL	int
)	O
;	O
printf	function
(	O
USAGE1	pointer
,	O
MIN_BOARD	int
,	O
MAX_BOARD	int
,	O
MAX_HANDICAP	int
)	O
;	O
printf	function
(	O
USAGE2	pointer
,	O
DEFAULT_MEMORY	O
<=	O
0	int
?	O
reading_cache_default_size	function
(	O
)	O
:	O
(	O
float	O
)	O
DEFAULT_MEMORY	O
)	O
;	O
}	O
static	O
void	O
show_debug_help	function
(	O
void	O
)	O
{	O
set_depth_values	function
(	O
DEFAULT_LEVEL	int
,	O
0	int
)	O
;	O
printf	function
(	O
USAGE_DEBUG	pointer
USAGE_DEBUG2	pointer
,	O
DEFAULT_LEVEL	int
,	O
depth	int
,	O
backfill_depth	int
,	O
fourlib_depth	int
,	O
ko_depth	int
,	O
branch_depth	int
,	O
backfill2_depth	int
,	O
break_chain_depth	int
,	O
superstring_depth	int
,	O
aa_depth	int
,	O
owl_distrust_depth	int
,	O
owl_branch_depth	int
,	O
owl_reading_depth	int
,	O
owl_node_limit	int
,	O
semeai_node_limit	int
)	O
;	O
}	O
static	O
void	O
show_debug_flags	function
(	O
void	O
)	O
{	O
printf	function
(	O
DEBUG_FLAGS	pointer
)	O
;	O
}	O
static	O
void	O
show_copyright	function
(	O
void	O
)	O
{	O
printf	function
(	O
COPYRIGHT	pointer
)	O
;	O
}	O
static	O
void	O
socket_connect_to	function
(	O
const	O
char	O
*	O
host_name	pointer
,	O
unsigned	O
int	O
port	int
,	O
FILE	struct
*	O
*	O
input_file	pointer
,	O
FILE	struct
*	O
*	O
output_file	pointer
)	O
{	O
struct	O
sockaddr_in	struct
address	struct
;	O
int	O
connection_socket	int
;	O
struct	O
hostent	struct
*	O
host_data	pointer
;	O
char	O
*	O
*	O
address_pointer	pointer
;	O
init_sockets	O
(	O
)	O
;	O
if	O
(	O
!	O
host_name	pointer
)	O
host_name	pointer
=	O
"127.0.0.1"	pointer
;	O
host_data	pointer
=	O
gethostbyname	function
(	O
host_name	pointer
)	O
;	O
if	O
(	O
!	O
host_data	pointer
||	O
host_data	pointer
->	O
h_addrtype	int
!=	O
AF_INET	O
||	O
host_data	pointer
->	O
h_length	int
!=	O
sizeof	O
address	struct
.	O
sin_addr	struct
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to resolve host name `%s'\n"	pointer
,	O
host_name	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
connection_socket	int
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
connection_socket	int
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Unexpected error: failed to create a socket\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
address	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
address	struct
.	O
sin_port	short
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
port	int
)	O
;	O
for	O
(	O
address_pointer	pointer
=	O
host_data	pointer
->	O
h_addr_list	pointer
;	O
*	O
address_pointer	pointer
;	O
address_pointer	pointer
++	O
)	O
{	O
memcpy	function
(	O
&	O
address	struct
.	O
sin_addr	struct
,	O
*	O
address_pointer	pointer
,	O
sizeof	O
address	struct
.	O
sin_addr	struct
)	O
;	O
if	O
(	O
connect	function
(	O
connection_socket	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
address	struct
,	O
sizeof	O
address	struct
)	O
!=	O
-	O
1	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
*	O
address_pointer	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to connect to %s:%u\n"	pointer
,	O
host_data	pointer
->	O
h_name	pointer
,	O
port	int
)	O
;	O
closesocket	O
(	O
connection_socket	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
*	O
input_file	pointer
=	O
fdopen	function
(	O
connection_socket	int
,	O
"r"	pointer
)	O
;	O
*	O
output_file	pointer
=	O
fdopen	function
(	O
dup	function
(	O
connection_socket	int
)	O
,	O
"w"	pointer
)	O
;	O
}	O
static	O
void	O
socket_listen_at	function
(	O
const	O
char	O
*	O
host_name	pointer
,	O
unsigned	O
int	O
port	int
,	O
FILE	struct
*	O
*	O
input_file	pointer
,	O
FILE	struct
*	O
*	O
output_file	pointer
)	O
{	O
struct	O
sockaddr_in	struct
address	struct
;	O
int	O
listening_socket	int
;	O
int	O
connection_socket	int
;	O
init_sockets	O
(	O
)	O
;	O
if	O
(	O
host_name	pointer
)	O
{	O
struct	O
hostent	struct
*	O
host_data	pointer
;	O
host_data	pointer
=	O
gethostbyname	function
(	O
host_name	pointer
)	O
;	O
if	O
(	O
!	O
host_data	pointer
||	O
host_data	pointer
->	O
h_addrtype	int
!=	O
AF_INET	O
||	O
host_data	pointer
->	O
h_length	int
!=	O
sizeof	O
address	struct
.	O
sin_addr	struct
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to resolve host name `%s'\n"	pointer
,	O
host_name	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
host_name	pointer
=	O
host_data	pointer
->	O
h_name	pointer
;	O
memcpy	function
(	O
&	O
address	struct
.	O
sin_addr	struct
,	O
host_data	pointer
->	O
h_addr_list	pointer
[	O
0	int
]	O
,	O
sizeof	O
address	struct
.	O
sin_addr	struct
)	O
;	O
}	O
else	O
address	struct
.	O
sin_addr	struct
.	O
s_addr	int
=	O
htonl	function
(	O
INADDR_ANY	O
)	O
;	O
listening_socket	int
=	O
socket	function
(	O
PF_INET	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
;	O
if	O
(	O
listening_socket	int
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Unexpected error: failed to create a socket\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
address	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
address	struct
.	O
sin_port	short
=	O
htons	function
(	O
(	O
unsigned	O
short	O
)	O
port	int
)	O
;	O
if	O
(	O
verbose	int
)	O
{	O
if	O
(	O
host_name	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Waiting for a connection on %s:%u...\n"	pointer
,	O
host_name	pointer
,	O
port	int
)	O
;	O
}	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"Waiting for a connection on port %u...\n"	pointer
,	O
port	int
)	O
;	O
}	O
if	O
(	O
bind	function
(	O
listening_socket	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
address	struct
,	O
sizeof	O
address	struct
)	O
==	O
-	O
1	int
||	O
listen	function
(	O
listening_socket	int
,	O
0	int
)	O
==	O
-	O
1	int
||	O
(	O
connection_socket	int
=	O
accept	function
(	O
listening_socket	int
,	O
NULL	O
,	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
host_name	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to listen on %s:%u\n"	pointer
,	O
host_name	pointer
,	O
port	int
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"Failed to listen on port %u\n"	pointer
,	O
port	int
)	O
;	O
closesocket	O
(	O
listening_socket	int
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
closesocket	O
(	O
listening_socket	int
)	O
;	O
*	O
input_file	pointer
=	O
fdopen	function
(	O
connection_socket	int
,	O
"r"	pointer
)	O
;	O
*	O
output_file	pointer
=	O
fdopen	function
(	O
dup	function
(	O
connection_socket	int
)	O
,	O
"w"	pointer
)	O
;	O
}	O
static	O
void	O
socket_close_connection	function
(	O
FILE	struct
*	O
input_file	pointer
,	O
FILE	struct
*	O
output_file	pointer
)	O
{	O
fclose	function
(	O
input_file	pointer
)	O
;	O
fclose	function
(	O
output_file	pointer
)	O
;	O
}	O
static	O
void	O
socket_stop_listening	function
(	O
FILE	struct
*	O
input_file	pointer
,	O
FILE	struct
*	O
output_file	pointer
)	O
{	O
int	O
buffer	array
[	O
0x1000	int
]	O
;	O
if	O
(	O
verbose	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Waiting for the client to disconnect...\n"	pointer
)	O
;	O
do	O
fread	function
(	O
buffer	array
,	O
sizeof	O
buffer	array
,	O
1	int
,	O
input_file	pointer
)	O
;	O
while	O
(	O
!	O
feof	function
(	O
input_file	pointer
)	O
)	O
;	O
fclose	function
(	O
input_file	pointer
)	O
;	O
fclose	function
(	O
output_file	pointer
)	O
;	O
}	O
