static	O
const	O
ctf_dmodel_t	struct
_libctf_models	array
[	O
]	O
=	O
{	O
{	O
"ILP32"	pointer
,	O
CTF_MODEL_ILP32	int
,	O
4	int
,	O
1	int
,	O
2	int
,	O
4	int
,	O
4	int
}	O
,	O
{	O
"LP64"	pointer
,	O
CTF_MODEL_LP64	int
,	O
8	int
,	O
1	int
,	O
2	int
,	O
4	int
,	O
8	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
const	O
char	O
_CTF_SECTION	array
[	O
]	O
=	O
".ctf"	pointer
;	O
const	O
char	O
_CTF_NULLSTR	array
[	O
]	O
=	O
""	pointer
;	O
static	O
uint32_t	int
get_kind_v1	function
(	O
uint32_t	int
info	pointer
)	O
{	O
return	O
(	O
CTF_V1_INFO_KIND	O
(	O
info	pointer
)	O
)	O
;	O
}	O
static	O
uint32_t	int
get_root_v1	function
(	O
uint32_t	int
info	pointer
)	O
{	O
return	O
(	O
CTF_V1_INFO_ISROOT	O
(	O
info	pointer
)	O
)	O
;	O
}	O
static	O
uint32_t	int
get_vlen_v1	function
(	O
uint32_t	int
info	pointer
)	O
{	O
return	O
(	O
CTF_V1_INFO_VLEN	O
(	O
info	pointer
)	O
)	O
;	O
}	O
static	O
uint32_t	int
get_kind_v2	function
(	O
uint32_t	int
info	pointer
)	O
{	O
return	O
(	O
CTF_V2_INFO_KIND	O
(	O
info	pointer
)	O
)	O
;	O
}	O
static	O
uint32_t	int
get_root_v2	function
(	O
uint32_t	int
info	pointer
)	O
{	O
return	O
(	O
CTF_V2_INFO_ISROOT	O
(	O
info	pointer
)	O
)	O
;	O
}	O
static	O
uint32_t	int
get_vlen_v2	function
(	O
uint32_t	int
info	pointer
)	O
{	O
return	O
(	O
CTF_V2_INFO_VLEN	O
(	O
info	pointer
)	O
)	O
;	O
}	O
static	O
inline	O
ssize_t	long
get_ctt_size_common	function
(	O
const	O
ctf_file_t	struct
*	O
fp	pointer
_libctf_unused_	O
,	O
const	O
ctf_type_t	struct
*	O
tp	pointer
_libctf_unused_	O
,	O
ssize_t	long
*	O
sizep	pointer
,	O
ssize_t	long
*	O
incrementp	pointer
,	O
size_t	long
lsize	long
,	O
size_t	long
csize	long
,	O
size_t	long
ctf_type_size	function
,	O
size_t	long
ctf_stype_size	long
,	O
size_t	long
ctf_lsize_sent	long
)	O
{	O
ssize_t	long
size	long
,	O
increment	long
;	O
if	O
(	O
csize	long
==	O
ctf_lsize_sent	long
)	O
{	O
size	long
=	O
lsize	long
;	O
increment	long
=	O
ctf_type_size	function
;	O
}	O
else	O
{	O
size	long
=	O
csize	long
;	O
increment	long
=	O
ctf_stype_size	long
;	O
}	O
if	O
(	O
sizep	pointer
)	O
*	O
sizep	pointer
=	O
size	long
;	O
if	O
(	O
incrementp	pointer
)	O
*	O
incrementp	pointer
=	O
increment	long
;	O
return	O
size	long
;	O
}	O
static	O
ssize_t	long
get_ctt_size_v1	function
(	O
const	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
ctf_type_t	struct
*	O
tp	pointer
,	O
ssize_t	long
*	O
sizep	pointer
,	O
ssize_t	long
*	O
incrementp	pointer
)	O
{	O
ctf_type_v1_t	struct
*	O
t1p	pointer
=	O
(	O
ctf_type_v1_t	struct
*	O
)	O
tp	pointer
;	O
return	O
(	O
get_ctt_size_common	function
(	O
fp	pointer
,	O
tp	pointer
,	O
sizep	pointer
,	O
incrementp	pointer
,	O
CTF_TYPE_LSIZE	O
(	O
t1p	pointer
)	O
,	O
t1p	pointer
->	O
ctt_size	short
,	O
sizeof	O
(	O
ctf_type_v1_t	struct
)	O
,	O
sizeof	O
(	O
ctf_stype_v1_t	O
)	O
,	O
CTF_LSIZE_SENT_V1	int
)	O
)	O
;	O
}	O
static	O
ssize_t	long
get_ctt_size_v2_unconverted	function
(	O
const	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
ctf_type_t	struct
*	O
tp	pointer
,	O
ssize_t	long
*	O
sizep	pointer
,	O
ssize_t	long
*	O
incrementp	pointer
)	O
{	O
ctf_type_v1_t	struct
*	O
t1p	pointer
=	O
(	O
ctf_type_v1_t	struct
*	O
)	O
tp	pointer
;	O
return	O
(	O
get_ctt_size_common	function
(	O
fp	pointer
,	O
tp	pointer
,	O
sizep	pointer
,	O
incrementp	pointer
,	O
CTF_TYPE_LSIZE	O
(	O
t1p	pointer
)	O
,	O
t1p	pointer
->	O
ctt_size	short
,	O
sizeof	O
(	O
ctf_type_t	struct
)	O
,	O
sizeof	O
(	O
ctf_stype_t	O
)	O
,	O
CTF_LSIZE_SENT	int
)	O
)	O
;	O
}	O
static	O
ssize_t	long
get_ctt_size_v2	function
(	O
const	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
ctf_type_t	struct
*	O
tp	pointer
,	O
ssize_t	long
*	O
sizep	pointer
,	O
ssize_t	long
*	O
incrementp	pointer
)	O
{	O
return	O
(	O
get_ctt_size_common	function
(	O
fp	pointer
,	O
tp	pointer
,	O
sizep	pointer
,	O
incrementp	pointer
,	O
CTF_TYPE_LSIZE	O
(	O
tp	pointer
)	O
,	O
tp	pointer
->	O
ctt_size	short
,	O
sizeof	O
(	O
ctf_type_t	struct
)	O
,	O
sizeof	O
(	O
ctf_stype_t	O
)	O
,	O
CTF_LSIZE_SENT	int
)	O
)	O
;	O
}	O
static	O
ssize_t	long
get_vbytes_common	function
(	O
unsigned	O
short	O
kind	short
,	O
ssize_t	long
size	long
_libctf_unused_	O
,	O
size_t	long
vlen	long
)	O
{	O
switch	O
(	O
kind	short
)	O
{	O
case	O
CTF_K_INTEGER	int
:	O
case	O
CTF_K_FLOAT	int
:	O
return	O
(	O
sizeof	O
(	O
uint32_t	int
)	O
)	O
;	O
case	O
CTF_K_SLICE	int
:	O
return	O
(	O
sizeof	O
(	O
ctf_slice_t	struct
)	O
)	O
;	O
case	O
CTF_K_ENUM	int
:	O
return	O
(	O
sizeof	O
(	O
ctf_enum_t	struct
)	O
*	O
vlen	long
)	O
;	O
case	O
CTF_K_FORWARD	int
:	O
case	O
CTF_K_UNKNOWN	int
:	O
case	O
CTF_K_POINTER	int
:	O
case	O
CTF_K_TYPEDEF	int
:	O
case	O
CTF_K_VOLATILE	int
:	O
case	O
CTF_K_CONST	int
:	O
case	O
CTF_K_RESTRICT	int
:	O
return	O
0	int
;	O
default	O
:	O
ctf_dprintf	function
(	O
"detected invalid CTF kind -- %x\n"	pointer
,	O
kind	short
)	O
;	O
return	O
ECTF_CORRUPT	int
;	O
}	O
}	O
static	O
ssize_t	long
get_vbytes_v1	function
(	O
unsigned	O
short	O
kind	short
,	O
ssize_t	long
size	long
,	O
size_t	long
vlen	long
)	O
{	O
switch	O
(	O
kind	short
)	O
{	O
case	O
CTF_K_ARRAY	int
:	O
return	O
(	O
sizeof	O
(	O
ctf_array_v1_t	struct
)	O
)	O
;	O
case	O
CTF_K_FUNCTION	int
:	O
return	O
(	O
sizeof	O
(	O
unsigned	O
short	O
)	O
*	O
(	O
vlen	long
+	O
(	O
vlen	long
&	O
1	int
)	O
)	O
)	O
;	O
case	O
CTF_K_STRUCT	int
:	O
case	O
CTF_K_UNION	int
:	O
if	O
(	O
size	long
<	O
CTF_LSTRUCT_THRESH_V1	int
)	O
return	O
(	O
sizeof	O
(	O
ctf_member_v1_t	struct
)	O
*	O
vlen	long
)	O
;	O
else	O
return	O
(	O
sizeof	O
(	O
ctf_lmember_v1_t	struct
)	O
*	O
vlen	long
)	O
;	O
}	O
return	O
(	O
get_vbytes_common	function
(	O
kind	short
,	O
size	long
,	O
vlen	long
)	O
)	O
;	O
}	O
static	O
ssize_t	long
get_vbytes_v2	function
(	O
unsigned	O
short	O
kind	short
,	O
ssize_t	long
size	long
,	O
size_t	long
vlen	long
)	O
{	O
switch	O
(	O
kind	short
)	O
{	O
case	O
CTF_K_ARRAY	int
:	O
return	O
(	O
sizeof	O
(	O
ctf_array_t	struct
)	O
)	O
;	O
case	O
CTF_K_FUNCTION	int
:	O
return	O
(	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
vlen	long
+	O
(	O
vlen	long
&	O
1	int
)	O
)	O
)	O
;	O
case	O
CTF_K_STRUCT	int
:	O
case	O
CTF_K_UNION	int
:	O
if	O
(	O
size	long
<	O
CTF_LSTRUCT_THRESH	int
)	O
return	O
(	O
sizeof	O
(	O
ctf_member_t	struct
)	O
*	O
vlen	long
)	O
;	O
else	O
return	O
(	O
sizeof	O
(	O
ctf_lmember_t	struct
)	O
*	O
vlen	long
)	O
;	O
}	O
return	O
(	O
get_vbytes_common	function
(	O
kind	short
,	O
size	long
,	O
vlen	long
)	O
)	O
;	O
}	O
static	O
const	O
ctf_fileops_t	struct
ctf_fileops	struct
[	O
]	O
=	O
{	O
{	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
,	O
{	O
get_kind_v1	function
,	O
get_root_v1	function
,	O
get_vlen_v1	function
,	O
get_ctt_size_v1	function
,	O
get_vbytes_v1	function
}	O
,	O
{	O
get_kind_v2	function
,	O
get_root_v2	function
,	O
get_vlen_v2	function
,	O
get_ctt_size_v2	function
,	O
get_vbytes_v2	function
}	O
,	O
{	O
get_kind_v2	function
,	O
get_root_v2	function
,	O
get_vlen_v2	function
,	O
get_ctt_size_v2	function
,	O
get_vbytes_v2	function
}	O
,	O
{	O
get_kind_v2	function
,	O
get_root_v2	function
,	O
get_vlen_v2	function
,	O
get_ctt_size_v2	function
,	O
get_vbytes_v2	function
}	O
,	O
}	O
;	O
static	O
int	O
init_symtab	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
ctf_header_t	struct
*	O
hp	pointer
,	O
const	O
ctf_sect_t	struct
*	O
sp	pointer
,	O
const	O
ctf_sect_t	struct
*	O
strp	pointer
)	O
{	O
const	O
unsigned	O
char	O
*	O
symp	pointer
=	O
sp	pointer
->	O
cts_data	pointer
;	O
uint32_t	int
*	O
xp	pointer
=	O
fp	pointer
->	O
ctf_sxlate	pointer
;	O
uint32_t	int
*	O
xend	pointer
=	O
xp	pointer
+	O
fp	pointer
->	O
ctf_nsyms	long
;	O
uint32_t	int
objtoff	int
=	O
hp	pointer
->	O
cth_objtoff	int
;	O
uint32_t	int
funcoff	int
=	O
hp	pointer
->	O
cth_funcoff	int
;	O
uint32_t	int
info	pointer
,	O
vlen	long
;	O
Elf64_Sym	struct
sym	pointer
,	O
*	O
gsp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
for	O
(	O
;	O
xp	pointer
<	O
xend	pointer
;	O
xp	pointer
++	O
,	O
symp	pointer
+=	O
sp	pointer
->	O
cts_entsize	long
)	O
{	O
if	O
(	O
sp	pointer
->	O
cts_entsize	long
==	O
sizeof	O
(	O
Elf32_Sym	struct
)	O
)	O
gsp	pointer
=	O
ctf_sym_to_elf64	function
(	O
(	O
Elf32_Sym	struct
*	O
)	O
(	O
uintptr_t	long
)	O
symp	pointer
,	O
&	O
sym	pointer
)	O
;	O
else	O
gsp	pointer
=	O
(	O
Elf64_Sym	struct
*	O
)	O
(	O
uintptr_t	long
)	O
symp	pointer
;	O
if	O
(	O
gsp	pointer
->	O
st_name	pointer
<	O
strp	pointer
->	O
cts_size	long
)	O
name	pointer
=	O
(	O
const	O
char	O
*	O
)	O
strp	pointer
->	O
cts_data	pointer
+	O
gsp	pointer
->	O
st_name	pointer
;	O
else	O
name	pointer
=	O
_CTF_NULLSTR	array
;	O
if	O
(	O
gsp	pointer
->	O
st_name	pointer
==	O
0	int
||	O
gsp	pointer
->	O
st_shndx	int
==	O
SHN_UNDEF	int
||	O
strcmp	function
(	O
name	pointer
,	O
"_START_"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
name	pointer
,	O
"_END_"	pointer
)	O
==	O
0	int
)	O
{	O
*	O
xp	pointer
=	O
-	O
1u	int
;	O
continue	O
;	O
}	O
switch	O
(	O
ELF64_ST_TYPE	O
(	O
gsp	pointer
->	O
st_info	array
)	O
)	O
{	O
case	O
STT_OBJECT	int
:	O
if	O
(	O
objtoff	int
>=	O
hp	pointer
->	O
cth_funcoff	int
||	O
(	O
gsp	pointer
->	O
st_shndx	int
==	O
SHN_EXTABS	int
&&	O
gsp	pointer
->	O
st_value	int
==	O
0	int
)	O
)	O
{	O
*	O
xp	pointer
=	O
-	O
1u	int
;	O
break	O
;	O
}	O
*	O
xp	pointer
=	O
objtoff	int
;	O
objtoff	int
+=	O
sizeof	O
(	O
uint32_t	int
)	O
;	O
break	O
;	O
case	O
STT_FUNC	int
:	O
if	O
(	O
funcoff	int
>=	O
hp	pointer
->	O
cth_objtidxoff	int
)	O
{	O
*	O
xp	pointer
=	O
-	O
1u	int
;	O
break	O
;	O
}	O
*	O
xp	pointer
=	O
funcoff	int
;	O
info	pointer
=	O
*	O
(	O
uint32_t	int
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
fp	pointer
->	O
ctf_buf	pointer
+	O
funcoff	int
)	O
;	O
vlen	long
=	O
LCTF_INFO_VLEN	O
(	O
fp	pointer
,	O
info	pointer
)	O
;	O
if	O
(	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
info	pointer
)	O
==	O
CTF_K_UNKNOWN	int
&&	O
vlen	long
==	O
0	int
)	O
funcoff	int
+=	O
sizeof	O
(	O
uint32_t	int
)	O
;	O
else	O
funcoff	int
+=	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
vlen	long
+	O
2	int
)	O
;	O
break	O
;	O
default	O
:	O
*	O
xp	pointer
=	O
-	O
1u	int
;	O
break	O
;	O
}	O
}	O
ctf_dprintf	function
(	O
"loaded %lu symtab entries\n"	pointer
,	O
fp	pointer
->	O
ctf_nsyms	long
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
ctf_set_base	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
ctf_header_t	struct
*	O
hp	pointer
,	O
unsigned	O
char	O
*	O
base	pointer
)	O
{	O
fp	pointer
->	O
ctf_buf	pointer
=	O
base	pointer
+	O
(	O
fp	pointer
->	O
ctf_buf	pointer
-	O
fp	pointer
->	O
ctf_base	pointer
)	O
;	O
fp	pointer
->	O
ctf_base	pointer
=	O
base	pointer
;	O
fp	pointer
->	O
ctf_vars	pointer
=	O
(	O
ctf_varent_t	struct
*	O
)	O
(	O
(	O
const	O
char	O
*	O
)	O
fp	pointer
->	O
ctf_buf	pointer
+	O
hp	pointer
->	O
cth_varoff	int
)	O
;	O
fp	pointer
->	O
ctf_nvars	long
=	O
(	O
hp	pointer
->	O
cth_typeoff	int
-	O
hp	pointer
->	O
cth_varoff	int
)	O
/	O
sizeof	O
(	O
ctf_varent_t	struct
)	O
;	O
fp	pointer
->	O
ctf_str	array
[	O
CTF_STRTAB_0	int
]	O
.	O
cts_strs	pointer
=	O
(	O
const	O
char	O
*	O
)	O
fp	pointer
->	O
ctf_buf	pointer
+	O
hp	pointer
->	O
cth_stroff	int
;	O
fp	pointer
->	O
ctf_str	array
[	O
CTF_STRTAB_0	int
]	O
.	O
cts_len	long
=	O
hp	pointer
->	O
cth_strlen	int
;	O
if	O
(	O
hp	pointer
->	O
cth_parlabel	int
!=	O
0	int
)	O
fp	pointer
->	O
ctf_parlabel	pointer
=	O
ctf_strptr	function
(	O
fp	pointer
,	O
hp	pointer
->	O
cth_parlabel	int
)	O
;	O
if	O
(	O
hp	pointer
->	O
cth_parname	int
!=	O
0	int
)	O
fp	pointer
->	O
ctf_parname	pointer
=	O
ctf_strptr	function
(	O
fp	pointer
,	O
hp	pointer
->	O
cth_parname	int
)	O
;	O
if	O
(	O
hp	pointer
->	O
cth_cuname	int
!=	O
0	int
)	O
fp	pointer
->	O
ctf_cuname	function
=	O
ctf_strptr	function
(	O
fp	pointer
,	O
hp	pointer
->	O
cth_cuname	int
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_cuname	function
)	O
ctf_dprintf	function
(	O
"ctf_set_base: CU name %s\n"	pointer
,	O
fp	pointer
->	O
ctf_cuname	function
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_parname	pointer
)	O
ctf_dprintf	function
(	O
"ctf_set_base: parent name %s (label %s)\n"	pointer
,	O
fp	pointer
->	O
ctf_parname	pointer
,	O
fp	pointer
->	O
ctf_parlabel	pointer
?	O
fp	pointer
->	O
ctf_parlabel	pointer
:	O
"<NULL>"	pointer
)	O
;	O
}	O
static	O
void	O
ctf_set_version	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_header_t	struct
*	O
cth	pointer
,	O
int	O
ctf_version	function
)	O
{	O
fp	pointer
->	O
ctf_version	function
=	O
ctf_version	function
;	O
cth	pointer
->	O
cth_version	O
=	O
ctf_version	function
;	O
fp	pointer
->	O
ctf_fileops	struct
=	O
&	O
ctf_fileops	struct
[	O
ctf_version	function
]	O
;	O
}	O
static	O
void	O
upgrade_header	function
(	O
ctf_header_t	struct
*	O
hp	pointer
)	O
{	O
ctf_header_v2_t	struct
*	O
oldhp	pointer
=	O
(	O
ctf_header_v2_t	struct
*	O
)	O
hp	pointer
;	O
hp	pointer
->	O
cth_strlen	int
=	O
oldhp	pointer
->	O
cth_strlen	int
;	O
hp	pointer
->	O
cth_stroff	int
=	O
oldhp	pointer
->	O
cth_stroff	int
;	O
hp	pointer
->	O
cth_typeoff	int
=	O
oldhp	pointer
->	O
cth_typeoff	int
;	O
hp	pointer
->	O
cth_varoff	int
=	O
oldhp	pointer
->	O
cth_varoff	int
;	O
hp	pointer
->	O
cth_funcidxoff	int
=	O
hp	pointer
->	O
cth_varoff	int
;	O
hp	pointer
->	O
cth_objtidxoff	int
=	O
hp	pointer
->	O
cth_funcidxoff	int
;	O
hp	pointer
->	O
cth_funcoff	int
=	O
oldhp	pointer
->	O
cth_funcoff	int
;	O
hp	pointer
->	O
cth_objtoff	int
=	O
oldhp	pointer
->	O
cth_objtoff	int
;	O
hp	pointer
->	O
cth_lbloff	int
=	O
oldhp	pointer
->	O
cth_lbloff	int
;	O
hp	pointer
->	O
cth_cuname	int
=	O
0	int
;	O
}	O
static	O
int	O
upgrade_types_v1	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_header_t	struct
*	O
cth	pointer
)	O
{	O
const	O
ctf_type_v1_t	struct
*	O
tbuf	pointer
;	O
const	O
ctf_type_v1_t	struct
*	O
tend	pointer
;	O
unsigned	O
char	O
*	O
ctf_base	pointer
,	O
*	O
old_ctf_base	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
fp	pointer
->	O
ctf_dynbase	pointer
;	O
ctf_type_t	struct
*	O
t2buf	pointer
;	O
ssize_t	long
increase	long
=	O
0	int
,	O
size	long
,	O
increment	long
,	O
v2increment	long
,	O
vbytes	long
,	O
v2bytes	long
;	O
const	O
ctf_type_v1_t	struct
*	O
tp	pointer
;	O
ctf_type_t	struct
*	O
t2p	pointer
;	O
tbuf	pointer
=	O
(	O
ctf_type_v1_t	struct
*	O
)	O
(	O
fp	pointer
->	O
ctf_buf	pointer
+	O
cth	pointer
->	O
cth_typeoff	int
)	O
;	O
tend	pointer
=	O
(	O
ctf_type_v1_t	struct
*	O
)	O
(	O
fp	pointer
->	O
ctf_buf	pointer
+	O
cth	pointer
->	O
cth_stroff	int
)	O
;	O
for	O
(	O
tp	pointer
=	O
tbuf	pointer
;	O
tp	pointer
<	O
tend	pointer
;	O
tp	pointer
=	O
(	O
ctf_type_v1_t	struct
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
tp	pointer
+	O
increment	long
+	O
vbytes	long
)	O
)	O
{	O
unsigned	O
short	O
kind	short
=	O
CTF_V1_INFO_KIND	O
(	O
tp	pointer
->	O
ctt_info	short
)	O
;	O
unsigned	O
long	O
vlen	long
=	O
CTF_V1_INFO_VLEN	O
(	O
tp	pointer
->	O
ctt_info	short
)	O
;	O
size	long
=	O
get_ctt_size_v1	function
(	O
fp	pointer
,	O
(	O
const	O
ctf_type_t	struct
*	O
)	O
tp	pointer
,	O
NULL	O
,	O
&	O
increment	long
)	O
;	O
vbytes	long
=	O
get_vbytes_v1	function
(	O
kind	short
,	O
size	long
,	O
vlen	long
)	O
;	O
get_ctt_size_v2_unconverted	function
(	O
fp	pointer
,	O
(	O
const	O
ctf_type_t	struct
*	O
)	O
tp	pointer
,	O
NULL	O
,	O
&	O
v2increment	long
)	O
;	O
v2bytes	long
=	O
get_vbytes_v2	function
(	O
kind	short
,	O
size	long
,	O
vlen	long
)	O
;	O
if	O
(	O
(	O
vbytes	long
<	O
0	int
)	O
||	O
(	O
size	long
<	O
0	int
)	O
)	O
return	O
ECTF_CORRUPT	int
;	O
increase	long
+=	O
v2increment	long
-	O
increment	long
;	O
increase	long
+=	O
v2bytes	long
-	O
vbytes	long
;	O
}	O
if	O
(	O
(	O
ctf_base	pointer
=	O
malloc	function
(	O
fp	pointer
->	O
ctf_size	long
+	O
increase	long
)	O
)	O
==	O
NULL	O
)	O
return	O
ECTF_ZALLOC	int
;	O
memcpy	function
(	O
ctf_base	pointer
,	O
fp	pointer
->	O
ctf_buf	pointer
,	O
cth	pointer
->	O
cth_typeoff	int
)	O
;	O
memcpy	function
(	O
ctf_base	pointer
+	O
cth	pointer
->	O
cth_stroff	int
+	O
increase	long
,	O
fp	pointer
->	O
ctf_buf	pointer
+	O
cth	pointer
->	O
cth_stroff	int
,	O
cth	pointer
->	O
cth_strlen	int
)	O
;	O
memset	function
(	O
ctf_base	pointer
+	O
cth	pointer
->	O
cth_typeoff	int
,	O
0	int
,	O
cth	pointer
->	O
cth_stroff	int
-	O
cth	pointer
->	O
cth_typeoff	int
+	O
increase	long
)	O
;	O
cth	pointer
->	O
cth_stroff	int
+=	O
increase	long
;	O
fp	pointer
->	O
ctf_size	long
+=	O
increase	long
;	O
assert	O
(	O
cth	pointer
->	O
cth_stroff	int
>=	O
cth	pointer
->	O
cth_typeoff	int
)	O
;	O
fp	pointer
->	O
ctf_base	pointer
=	O
ctf_base	pointer
;	O
fp	pointer
->	O
ctf_buf	pointer
=	O
ctf_base	pointer
;	O
fp	pointer
->	O
ctf_dynbase	pointer
=	O
ctf_base	pointer
;	O
ctf_set_base	function
(	O
fp	pointer
,	O
cth	pointer
,	O
ctf_base	pointer
)	O
;	O
t2buf	pointer
=	O
(	O
ctf_type_t	struct
*	O
)	O
(	O
fp	pointer
->	O
ctf_buf	pointer
+	O
cth	pointer
->	O
cth_typeoff	int
)	O
;	O
for	O
(	O
tp	pointer
=	O
tbuf	pointer
,	O
t2p	pointer
=	O
t2buf	pointer
;	O
tp	pointer
<	O
tend	pointer
;	O
tp	pointer
=	O
(	O
ctf_type_v1_t	struct
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
tp	pointer
+	O
increment	long
+	O
vbytes	long
)	O
,	O
t2p	pointer
=	O
(	O
ctf_type_t	struct
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
t2p	pointer
+	O
v2increment	long
+	O
v2bytes	long
)	O
)	O
{	O
unsigned	O
short	O
kind	short
=	O
CTF_V1_INFO_KIND	O
(	O
tp	pointer
->	O
ctt_info	short
)	O
;	O
int	O
isroot	int
=	O
CTF_V1_INFO_ISROOT	O
(	O
tp	pointer
->	O
ctt_info	short
)	O
;	O
unsigned	O
long	O
vlen	long
=	O
CTF_V1_INFO_VLEN	O
(	O
tp	pointer
->	O
ctt_info	short
)	O
;	O
ssize_t	long
v2size	long
;	O
void	O
*	O
vdata	pointer
,	O
*	O
v2data	pointer
;	O
size	long
=	O
get_ctt_size_v1	function
(	O
fp	pointer
,	O
(	O
const	O
ctf_type_t	struct
*	O
)	O
tp	pointer
,	O
NULL	O
,	O
&	O
increment	long
)	O
;	O
vbytes	long
=	O
get_vbytes_v1	function
(	O
kind	short
,	O
size	long
,	O
vlen	long
)	O
;	O
t2p	pointer
->	O
ctt_name	int
=	O
tp	pointer
->	O
ctt_name	int
;	O
t2p	pointer
->	O
ctt_info	short
=	O
CTF_TYPE_INFO	O
(	O
kind	short
,	O
isroot	int
,	O
vlen	long
)	O
;	O
switch	O
(	O
kind	short
)	O
{	O
case	O
CTF_K_FUNCTION	int
:	O
case	O
CTF_K_FORWARD	int
:	O
case	O
CTF_K_TYPEDEF	int
:	O
case	O
CTF_K_POINTER	int
:	O
case	O
CTF_K_VOLATILE	int
:	O
case	O
CTF_K_CONST	int
:	O
case	O
CTF_K_RESTRICT	int
:	O
t2p	pointer
->	O
ctt_type	short
=	O
tp	pointer
->	O
ctt_type	short
;	O
break	O
;	O
case	O
CTF_K_INTEGER	int
:	O
case	O
CTF_K_FLOAT	int
:	O
case	O
CTF_K_ARRAY	int
:	O
case	O
CTF_K_STRUCT	int
:	O
case	O
CTF_K_UNION	int
:	O
case	O
CTF_K_ENUM	int
:	O
case	O
CTF_K_UNKNOWN	int
:	O
if	O
(	O
(	O
size_t	long
)	O
size	long
<=	O
CTF_MAX_SIZE	int
)	O
t2p	pointer
->	O
ctt_size	short
=	O
size	long
;	O
else	O
{	O
t2p	pointer
->	O
ctt_lsizehi	O
=	O
CTF_SIZE_TO_LSIZE_HI	O
(	O
size	long
)	O
;	O
t2p	pointer
->	O
ctt_lsizelo	int
=	O
CTF_SIZE_TO_LSIZE_LO	O
(	O
size	long
)	O
;	O
}	O
break	O
;	O
}	O
v2size	long
=	O
get_ctt_size_v2	function
(	O
fp	pointer
,	O
t2p	pointer
,	O
NULL	O
,	O
&	O
v2increment	long
)	O
;	O
v2bytes	long
=	O
get_vbytes_v2	function
(	O
kind	short
,	O
v2size	long
,	O
vlen	long
)	O
;	O
assert	O
(	O
size	long
==	O
v2size	long
)	O
;	O
vdata	pointer
=	O
(	O
void	O
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
tp	pointer
+	O
increment	long
)	O
;	O
v2data	pointer
=	O
(	O
void	O
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
t2p	pointer
+	O
v2increment	long
)	O
;	O
switch	O
(	O
kind	short
)	O
{	O
case	O
CTF_K_ARRAY	int
:	O
{	O
const	O
ctf_array_v1_t	struct
*	O
ap	pointer
=	O
(	O
const	O
ctf_array_v1_t	struct
*	O
)	O
vdata	pointer
;	O
ctf_array_t	struct
*	O
a2p	pointer
=	O
(	O
ctf_array_t	struct
*	O
)	O
v2data	pointer
;	O
a2p	pointer
->	O
cta_contents	short
=	O
ap	pointer
->	O
cta_contents	short
;	O
a2p	pointer
->	O
cta_index	short
=	O
ap	pointer
->	O
cta_index	short
;	O
a2p	pointer
->	O
cta_nelems	int
=	O
ap	pointer
->	O
cta_nelems	int
;	O
break	O
;	O
}	O
case	O
CTF_K_STRUCT	int
:	O
case	O
CTF_K_UNION	int
:	O
{	O
ctf_member_t	struct
tmp	struct
;	O
const	O
ctf_member_v1_t	struct
*	O
m1	pointer
=	O
(	O
const	O
ctf_member_v1_t	struct
*	O
)	O
vdata	pointer
;	O
const	O
ctf_lmember_v1_t	struct
*	O
lm1	pointer
=	O
(	O
const	O
ctf_lmember_v1_t	struct
*	O
)	O
m1	pointer
;	O
ctf_member_t	struct
*	O
m2	pointer
=	O
(	O
ctf_member_t	struct
*	O
)	O
v2data	pointer
;	O
ctf_lmember_t	struct
*	O
lm2	pointer
=	O
(	O
ctf_lmember_t	struct
*	O
)	O
m2	pointer
;	O
unsigned	O
long	O
i	pointer
;	O
for	O
(	O
i	pointer
=	O
vlen	long
;	O
i	pointer
!=	O
0	int
;	O
i	pointer
--	O
,	O
m1	pointer
++	O
,	O
lm1	pointer
++	O
,	O
m2	pointer
++	O
,	O
lm2	pointer
++	O
)	O
{	O
size_t	long
offset	long
;	O
if	O
(	O
size	long
<	O
CTF_LSTRUCT_THRESH_V1	int
)	O
{	O
offset	long
=	O
m1	pointer
->	O
ctm_offset	short
;	O
tmp	struct
.	O
ctm_name	int
=	O
m1	pointer
->	O
ctm_name	int
;	O
tmp	struct
.	O
ctm_type	short
=	O
m1	pointer
->	O
ctm_type	short
;	O
}	O
else	O
{	O
offset	long
=	O
CTF_LMEM_OFFSET	O
(	O
lm1	pointer
)	O
;	O
tmp	struct
.	O
ctm_name	int
=	O
lm1	pointer
->	O
ctlm_name	int
;	O
tmp	struct
.	O
ctm_type	short
=	O
lm1	pointer
->	O
ctlm_type	short
;	O
}	O
if	O
(	O
size	long
<	O
CTF_LSTRUCT_THRESH	int
)	O
{	O
m2	pointer
->	O
ctm_name	int
=	O
tmp	struct
.	O
ctm_name	int
;	O
m2	pointer
->	O
ctm_type	short
=	O
tmp	struct
.	O
ctm_type	short
;	O
m2	pointer
->	O
ctm_offset	short
=	O
offset	long
;	O
}	O
else	O
{	O
lm2	pointer
->	O
ctlm_name	int
=	O
tmp	struct
.	O
ctm_name	int
;	O
lm2	pointer
->	O
ctlm_type	short
=	O
tmp	struct
.	O
ctm_type	short
;	O
lm2	pointer
->	O
ctlm_offsethi	int
=	O
CTF_OFFSET_TO_LMEMHI	O
(	O
offset	long
)	O
;	O
lm2	pointer
->	O
ctlm_offsetlo	int
=	O
CTF_OFFSET_TO_LMEMLO	O
(	O
offset	long
)	O
;	O
}	O
}	O
break	O
;	O
}	O
case	O
CTF_K_FUNCTION	int
:	O
{	O
unsigned	O
long	O
i	pointer
;	O
unsigned	O
short	O
*	O
a1	pointer
=	O
(	O
unsigned	O
short	O
*	O
)	O
vdata	pointer
;	O
uint32_t	int
*	O
a2	pointer
=	O
(	O
uint32_t	int
*	O
)	O
v2data	pointer
;	O
for	O
(	O
i	pointer
=	O
vlen	long
;	O
i	pointer
!=	O
0	int
;	O
i	pointer
--	O
,	O
a1	pointer
++	O
,	O
a2	pointer
++	O
)	O
*	O
a2	pointer
=	O
*	O
a1	pointer
;	O
}	O
default	O
:	O
assert	O
(	O
vbytes	long
==	O
v2bytes	long
)	O
;	O
memcpy	function
(	O
v2data	pointer
,	O
vdata	pointer
,	O
vbytes	long
)	O
;	O
}	O
}	O
assert	O
(	O
(	O
size_t	long
)	O
t2p	pointer
-	O
(	O
size_t	long
)	O
fp	pointer
->	O
ctf_buf	pointer
==	O
cth	pointer
->	O
cth_stroff	int
)	O
;	O
ctf_set_version	function
(	O
fp	pointer
,	O
cth	pointer
,	O
CTF_VERSION_1_UPGRADED_3	int
)	O
;	O
free	function
(	O
old_ctf_base	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
upgrade_types	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_header_t	struct
*	O
cth	pointer
)	O
{	O
switch	O
(	O
cth	pointer
->	O
cth_version	O
)	O
{	O
case	O
CTF_VERSION_1	int
:	O
upgrade_types_v1	function
(	O
fp	pointer
,	O
cth	pointer
)	O
;	O
case	O
CTF_VERSION_1_UPGRADED_3	int
:	O
fp	pointer
->	O
ctf_parmax	int
=	O
CTF_MAX_PTYPE_V1	int
;	O
case	O
CTF_VERSION_2	int
:	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
init_types	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_header_t	struct
*	O
cth	pointer
)	O
{	O
const	O
ctf_type_t	struct
*	O
tbuf	pointer
;	O
const	O
ctf_type_t	struct
*	O
tend	pointer
;	O
unsigned	O
long	O
pop	array
[	O
CTF_K_MAX	int
+	O
1	int
]	O
=	O
{	O
0	int
}	O
;	O
const	O
ctf_type_t	struct
*	O
tp	pointer
;	O
uint32_t	int
id	int
,	O
dst	pointer
;	O
uint32_t	int
*	O
xp	pointer
;	O
int	O
child	int
=	O
cth	pointer
->	O
cth_parname	int
!=	O
0	int
;	O
int	O
nlstructs	int
=	O
0	int
,	O
nlunions	int
=	O
0	int
;	O
int	O
err	long
;	O
assert	O
(	O
!	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
)	O
;	O
if	O
(	O
_libctf_unlikely_	O
(	O
fp	pointer
->	O
ctf_version	function
==	O
CTF_VERSION_1	int
)	O
)	O
{	O
int	O
err	long
;	O
if	O
(	O
(	O
err	long
=	O
upgrade_types	function
(	O
fp	pointer
,	O
cth	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
err	long
;	O
}	O
tbuf	pointer
=	O
(	O
ctf_type_t	struct
*	O
)	O
(	O
fp	pointer
->	O
ctf_buf	pointer
+	O
cth	pointer
->	O
cth_typeoff	int
)	O
;	O
tend	pointer
=	O
(	O
ctf_type_t	struct
*	O
)	O
(	O
fp	pointer
->	O
ctf_buf	pointer
+	O
cth	pointer
->	O
cth_stroff	int
)	O
;	O
for	O
(	O
tp	pointer
=	O
tbuf	pointer
;	O
tp	pointer
<	O
tend	pointer
;	O
fp	pointer
->	O
ctf_typemax	long
++	O
)	O
{	O
unsigned	O
short	O
kind	short
=	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_info	short
)	O
;	O
unsigned	O
long	O
vlen	long
=	O
LCTF_INFO_VLEN	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_info	short
)	O
;	O
ssize_t	long
size	long
,	O
increment	long
,	O
vbytes	long
;	O
(	O
void	O
)	O
ctf_get_ctt_size	function
(	O
fp	pointer
,	O
tp	pointer
,	O
&	O
size	long
,	O
&	O
increment	long
)	O
;	O
vbytes	long
=	O
LCTF_VBYTES	O
(	O
fp	pointer
,	O
kind	short
,	O
size	long
,	O
vlen	long
)	O
;	O
if	O
(	O
vbytes	long
<	O
0	int
)	O
return	O
ECTF_CORRUPT	int
;	O
if	O
(	O
kind	short
==	O
CTF_K_FORWARD	int
)	O
{	O
if	O
(	O
tp	pointer
->	O
ctt_type	short
==	O
CTF_K_UNKNOWN	int
||	O
tp	pointer
->	O
ctt_type	short
>=	O
CTF_K_MAX	int
)	O
pop	array
[	O
CTF_K_STRUCT	int
]	O
++	O
;	O
else	O
pop	array
[	O
tp	pointer
->	O
ctt_type	short
]	O
++	O
;	O
}	O
tp	pointer
=	O
(	O
ctf_type_t	struct
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
tp	pointer
+	O
increment	long
+	O
vbytes	long
)	O
;	O
pop	array
[	O
kind	short
]	O
++	O
;	O
}	O
if	O
(	O
child	int
)	O
{	O
ctf_dprintf	function
(	O
"CTF container %p is a child\n"	pointer
,	O
(	O
void	O
*	O
)	O
fp	pointer
)	O
;	O
fp	pointer
->	O
ctf_flags	int
|=	O
LCTF_CHILD	int
;	O
}	O
else	O
ctf_dprintf	function
(	O
"CTF container %p is a parent\n"	pointer
,	O
(	O
void	O
*	O
)	O
fp	pointer
)	O
;	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_structs	struct
.	O
ctn_readonly	pointer
=	O
ctf_hash_create	function
(	O
pop	array
[	O
CTF_K_STRUCT	int
]	O
,	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
)	O
)	O
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_unions	struct
.	O
ctn_readonly	pointer
=	O
ctf_hash_create	function
(	O
pop	array
[	O
CTF_K_UNION	int
]	O
,	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
)	O
)	O
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_enums	struct
.	O
ctn_readonly	pointer
=	O
ctf_hash_create	function
(	O
pop	array
[	O
CTF_K_ENUM	int
]	O
,	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
)	O
)	O
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_names	struct
.	O
ctn_readonly	pointer
=	O
ctf_hash_create	function
(	O
pop	array
[	O
CTF_K_INTEGER	int
]	O
+	O
pop	array
[	O
CTF_K_FLOAT	int
]	O
+	O
pop	array
[	O
CTF_K_FUNCTION	int
]	O
+	O
pop	array
[	O
CTF_K_TYPEDEF	int
]	O
+	O
pop	array
[	O
CTF_K_POINTER	int
]	O
+	O
pop	array
[	O
CTF_K_VOLATILE	int
]	O
+	O
pop	array
[	O
CTF_K_CONST	int
]	O
+	O
pop	array
[	O
CTF_K_RESTRICT	int
]	O
,	O
ctf_hash_string	function
,	O
ctf_hash_eq_string	function
)	O
)	O
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
fp	pointer
->	O
ctf_txlate	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
fp	pointer
->	O
ctf_typemax	long
+	O
1	int
)	O
)	O
;	O
fp	pointer
->	O
ctf_ptrtab_len	long
=	O
fp	pointer
->	O
ctf_typemax	long
+	O
1	int
;	O
fp	pointer
->	O
ctf_ptrtab	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
fp	pointer
->	O
ctf_ptrtab_len	long
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_txlate	pointer
==	O
NULL	O
||	O
fp	pointer
->	O
ctf_ptrtab	pointer
==	O
NULL	O
)	O
return	O
ENOMEM	int
;	O
xp	pointer
=	O
fp	pointer
->	O
ctf_txlate	pointer
;	O
*	O
xp	pointer
++	O
=	O
0	int
;	O
memset	function
(	O
fp	pointer
->	O
ctf_txlate	pointer
,	O
0	int
,	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
fp	pointer
->	O
ctf_typemax	long
+	O
1	int
)	O
)	O
;	O
memset	function
(	O
fp	pointer
->	O
ctf_ptrtab	pointer
,	O
0	int
,	O
sizeof	O
(	O
uint32_t	int
)	O
*	O
(	O
fp	pointer
->	O
ctf_typemax	long
+	O
1	int
)	O
)	O
;	O
for	O
(	O
id	int
=	O
1	int
,	O
tp	pointer
=	O
tbuf	pointer
;	O
tp	pointer
<	O
tend	pointer
;	O
xp	pointer
++	O
,	O
id	int
++	O
)	O
{	O
unsigned	O
short	O
kind	short
=	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_info	short
)	O
;	O
unsigned	O
short	O
flag	int
=	O
LCTF_INFO_ISROOT	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_info	short
)	O
;	O
unsigned	O
long	O
vlen	long
=	O
LCTF_INFO_VLEN	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_info	short
)	O
;	O
ssize_t	long
size	long
,	O
increment	long
,	O
vbytes	long
;	O
const	O
char	O
*	O
name	pointer
;	O
(	O
void	O
)	O
ctf_get_ctt_size	function
(	O
fp	pointer
,	O
tp	pointer
,	O
&	O
size	long
,	O
&	O
increment	long
)	O
;	O
name	pointer
=	O
ctf_strptr	function
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_name	int
)	O
;	O
vbytes	long
=	O
LCTF_VBYTES	O
(	O
fp	pointer
,	O
kind	short
,	O
size	long
,	O
vlen	long
)	O
;	O
switch	O
(	O
kind	short
)	O
{	O
case	O
CTF_K_INTEGER	int
:	O
case	O
CTF_K_FLOAT	int
:	O
if	O
(	O
(	O
(	O
ctf_hash_lookup_type	function
(	O
fp	pointer
->	O
ctf_names	struct
.	O
ctn_readonly	pointer
,	O
fp	pointer
,	O
name	pointer
)	O
)	O
==	O
0	int
)	O
||	O
(	O
flag	int
&	O
CTF_ADD_ROOT	int
)	O
)	O
{	O
err	long
=	O
ctf_hash_define_type	function
(	O
fp	pointer
->	O
ctf_names	struct
.	O
ctn_readonly	pointer
,	O
fp	pointer
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	pointer
,	O
id	int
,	O
child	int
)	O
,	O
tp	pointer
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
}	O
break	O
;	O
case	O
CTF_K_ARRAY	int
:	O
case	O
CTF_K_SLICE	int
:	O
break	O
;	O
case	O
CTF_K_FUNCTION	int
:	O
err	long
=	O
ctf_hash_insert_type	function
(	O
fp	pointer
->	O
ctf_names	struct
.	O
ctn_readonly	pointer
,	O
fp	pointer
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	pointer
,	O
id	int
,	O
child	int
)	O
,	O
tp	pointer
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
break	O
;	O
case	O
CTF_K_STRUCT	int
:	O
err	long
=	O
ctf_hash_define_type	function
(	O
fp	pointer
->	O
ctf_structs	struct
.	O
ctn_readonly	pointer
,	O
fp	pointer
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	pointer
,	O
id	int
,	O
child	int
)	O
,	O
tp	pointer
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
if	O
(	O
size	long
>=	O
CTF_LSTRUCT_THRESH	int
)	O
nlstructs	int
++	O
;	O
break	O
;	O
case	O
CTF_K_UNION	int
:	O
err	long
=	O
ctf_hash_define_type	function
(	O
fp	pointer
->	O
ctf_unions	struct
.	O
ctn_readonly	pointer
,	O
fp	pointer
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	pointer
,	O
id	int
,	O
child	int
)	O
,	O
tp	pointer
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
if	O
(	O
size	long
>=	O
CTF_LSTRUCT_THRESH	int
)	O
nlunions	int
++	O
;	O
break	O
;	O
case	O
CTF_K_ENUM	int
:	O
err	long
=	O
ctf_hash_define_type	function
(	O
fp	pointer
->	O
ctf_enums	struct
.	O
ctn_readonly	pointer
,	O
fp	pointer
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	pointer
,	O
id	int
,	O
child	int
)	O
,	O
tp	pointer
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
break	O
;	O
case	O
CTF_K_TYPEDEF	int
:	O
err	long
=	O
ctf_hash_insert_type	function
(	O
fp	pointer
->	O
ctf_names	struct
.	O
ctn_readonly	pointer
,	O
fp	pointer
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	pointer
,	O
id	int
,	O
child	int
)	O
,	O
tp	pointer
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
break	O
;	O
case	O
CTF_K_FORWARD	int
:	O
{	O
ctf_names_t	struct
*	O
np	pointer
=	O
ctf_name_table	function
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_type	short
)	O
;	O
if	O
(	O
ctf_hash_lookup_type	function
(	O
np	pointer
->	O
ctn_readonly	pointer
,	O
fp	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
err	long
=	O
ctf_hash_insert_type	function
(	O
np	pointer
->	O
ctn_readonly	pointer
,	O
fp	pointer
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	pointer
,	O
id	int
,	O
child	int
)	O
,	O
tp	pointer
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
}	O
break	O
;	O
}	O
case	O
CTF_K_POINTER	int
:	O
if	O
(	O
LCTF_TYPE_ISCHILD	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_type	short
)	O
==	O
child	int
&&	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_type	short
)	O
<=	O
fp	pointer
->	O
ctf_typemax	long
)	O
fp	pointer
->	O
ctf_ptrtab	pointer
[	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_type	short
)	O
]	O
=	O
id	int
;	O
case	O
CTF_K_VOLATILE	int
:	O
case	O
CTF_K_CONST	int
:	O
case	O
CTF_K_RESTRICT	int
:	O
err	long
=	O
ctf_hash_insert_type	function
(	O
fp	pointer
->	O
ctf_names	struct
.	O
ctn_readonly	pointer
,	O
fp	pointer
,	O
LCTF_INDEX_TO_TYPE	O
(	O
fp	pointer
,	O
id	int
,	O
child	int
)	O
,	O
tp	pointer
->	O
ctt_name	int
)	O
;	O
if	O
(	O
err	long
!=	O
0	int
)	O
return	O
err	long
;	O
break	O
;	O
default	O
:	O
ctf_dprintf	function
(	O
"unhandled CTF kind in endianness conversion -- %x\n"	pointer
,	O
kind	short
)	O
;	O
return	O
ECTF_CORRUPT	int
;	O
}	O
*	O
xp	pointer
=	O
(	O
uint32_t	int
)	O
(	O
(	O
uintptr_t	long
)	O
tp	pointer
-	O
(	O
uintptr_t	long
)	O
fp	pointer
->	O
ctf_buf	pointer
)	O
;	O
tp	pointer
=	O
(	O
ctf_type_t	struct
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
tp	pointer
+	O
increment	long
+	O
vbytes	long
)	O
;	O
}	O
ctf_dprintf	function
(	O
"%lu total types processed\n"	pointer
,	O
fp	pointer
->	O
ctf_typemax	long
)	O
;	O
ctf_dprintf	function
(	O
"%u enum names hashed\n"	pointer
,	O
ctf_hash_size	function
(	O
fp	pointer
->	O
ctf_enums	struct
.	O
ctn_readonly	pointer
)	O
)	O
;	O
ctf_dprintf	function
(	O
"%u struct names hashed (%d long)\n"	pointer
,	O
ctf_hash_size	function
(	O
fp	pointer
->	O
ctf_structs	struct
.	O
ctn_readonly	pointer
)	O
,	O
nlstructs	int
)	O
;	O
ctf_dprintf	function
(	O
"%u union names hashed (%d long)\n"	pointer
,	O
ctf_hash_size	function
(	O
fp	pointer
->	O
ctf_unions	struct
.	O
ctn_readonly	pointer
)	O
,	O
nlunions	int
)	O
;	O
ctf_dprintf	function
(	O
"%u base type names hashed\n"	pointer
,	O
ctf_hash_size	function
(	O
fp	pointer
->	O
ctf_names	struct
.	O
ctn_readonly	pointer
)	O
)	O
;	O
for	O
(	O
id	int
=	O
1	int
;	O
id	int
<=	O
fp	pointer
->	O
ctf_typemax	long
;	O
id	int
++	O
)	O
{	O
if	O
(	O
(	O
dst	pointer
=	O
fp	pointer
->	O
ctf_ptrtab	pointer
[	O
id	int
]	O
)	O
!=	O
0	int
)	O
{	O
tp	pointer
=	O
LCTF_INDEX_TO_TYPEPTR	O
(	O
fp	pointer
,	O
id	int
)	O
;	O
if	O
(	O
LCTF_INFO_KIND	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_info	short
)	O
==	O
CTF_K_TYPEDEF	int
&&	O
strcmp	function
(	O
ctf_strptr	function
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_name	int
)	O
,	O
""	pointer
)	O
==	O
0	int
&&	O
LCTF_TYPE_ISCHILD	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_type	short
)	O
==	O
child	int
&&	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_type	short
)	O
<=	O
fp	pointer
->	O
ctf_typemax	long
)	O
fp	pointer
->	O
ctf_ptrtab	pointer
[	O
LCTF_TYPE_TO_INDEX	O
(	O
fp	pointer
,	O
tp	pointer
->	O
ctt_type	short
)	O
]	O
=	O
dst	pointer
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
flip_header	function
(	O
ctf_header_t	struct
*	O
cth	pointer
)	O
{	O
swap_thing	O
(	O
cth	pointer
->	O
cth_preamble	struct
.	O
ctp_magic	short
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_preamble	struct
.	O
ctp_version	char
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_preamble	struct
.	O
ctp_flags	char
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_parlabel	int
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_parname	int
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_cuname	int
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_objtoff	int
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_funcoff	int
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_objtidxoff	int
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_funcidxoff	int
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_varoff	int
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_typeoff	int
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_stroff	int
)	O
;	O
swap_thing	O
(	O
cth	pointer
->	O
cth_strlen	int
)	O
;	O
}	O
static	O
void	O
flip_lbls	function
(	O
void	O
*	O
start	pointer
,	O
size_t	long
len	int
)	O
{	O
ctf_lblent_t	struct
*	O
lbl	pointer
=	O
start	pointer
;	O
ssize_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
len	int
/	O
sizeof	O
(	O
struct	O
ctf_lblent	struct
)	O
;	O
i	pointer
>	O
0	int
;	O
lbl	pointer
++	O
,	O
i	pointer
--	O
)	O
{	O
swap_thing	O
(	O
lbl	pointer
->	O
ctl_label	int
)	O
;	O
swap_thing	O
(	O
lbl	pointer
->	O
ctl_type	int
)	O
;	O
}	O
}	O
static	O
void	O
flip_objts	function
(	O
void	O
*	O
start	pointer
,	O
size_t	long
len	int
)	O
{	O
uint32_t	int
*	O
obj	pointer
=	O
start	pointer
;	O
ssize_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
len	int
/	O
sizeof	O
(	O
uint32_t	int
)	O
;	O
i	pointer
>	O
0	int
;	O
obj	pointer
++	O
,	O
i	pointer
--	O
)	O
swap_thing	O
(	O
*	O
obj	pointer
)	O
;	O
}	O
static	O
void	O
flip_vars	function
(	O
void	O
*	O
start	pointer
,	O
size_t	long
len	int
)	O
{	O
ctf_varent_t	struct
*	O
var	pointer
=	O
start	pointer
;	O
ssize_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
len	int
/	O
sizeof	O
(	O
struct	O
ctf_varent	struct
)	O
;	O
i	pointer
>	O
0	int
;	O
var	pointer
++	O
,	O
i	pointer
--	O
)	O
{	O
swap_thing	O
(	O
var	pointer
->	O
ctv_name	int
)	O
;	O
swap_thing	O
(	O
var	pointer
->	O
ctv_type	int
)	O
;	O
}	O
}	O
static	O
int	O
flip_types	function
(	O
void	O
*	O
start	pointer
,	O
size_t	long
len	int
)	O
{	O
ctf_type_t	struct
*	O
t	pointer
=	O
start	pointer
;	O
while	O
(	O
(	O
uintptr_t	long
)	O
t	pointer
<	O
(	O
(	O
uintptr_t	long
)	O
start	pointer
)	O
+	O
len	int
)	O
{	O
swap_thing	O
(	O
t	pointer
->	O
ctt_name	int
)	O
;	O
swap_thing	O
(	O
t	pointer
->	O
ctt_info	short
)	O
;	O
swap_thing	O
(	O
t	pointer
->	O
ctt_size	short
)	O
;	O
uint32_t	int
kind	short
=	O
CTF_V2_INFO_KIND	O
(	O
t	pointer
->	O
ctt_info	short
)	O
;	O
size_t	long
size	long
=	O
t	pointer
->	O
ctt_size	short
;	O
uint32_t	int
vlen	long
=	O
CTF_V2_INFO_VLEN	O
(	O
t	pointer
->	O
ctt_info	short
)	O
;	O
size_t	long
vbytes	long
=	O
get_vbytes_v2	function
(	O
kind	short
,	O
size	long
,	O
vlen	long
)	O
;	O
if	O
(	O
_libctf_unlikely_	O
(	O
size	long
==	O
CTF_LSIZE_SENT	int
)	O
)	O
{	O
swap_thing	O
(	O
t	pointer
->	O
ctt_lsizehi	O
)	O
;	O
swap_thing	O
(	O
t	pointer
->	O
ctt_lsizelo	int
)	O
;	O
size	long
=	O
CTF_TYPE_LSIZE	O
(	O
t	pointer
)	O
;	O
t	pointer
=	O
(	O
ctf_type_t	struct
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
t	pointer
+	O
sizeof	O
(	O
ctf_type_t	struct
)	O
)	O
;	O
}	O
else	O
t	pointer
=	O
(	O
ctf_type_t	struct
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
t	pointer
+	O
sizeof	O
(	O
ctf_stype_t	O
)	O
)	O
;	O
switch	O
(	O
kind	short
)	O
{	O
case	O
CTF_K_FORWARD	int
:	O
case	O
CTF_K_UNKNOWN	int
:	O
case	O
CTF_K_POINTER	int
:	O
case	O
CTF_K_TYPEDEF	int
:	O
case	O
CTF_K_VOLATILE	int
:	O
case	O
CTF_K_CONST	int
:	O
case	O
CTF_K_RESTRICT	int
:	O
assert	O
(	O
vbytes	long
==	O
0	int
)	O
;	O
break	O
;	O
case	O
CTF_K_INTEGER	int
:	O
case	O
CTF_K_FLOAT	int
:	O
{	O
uint32_t	int
*	O
item	pointer
=	O
(	O
uint32_t	int
*	O
)	O
t	pointer
;	O
swap_thing	O
(	O
*	O
item	pointer
)	O
;	O
break	O
;	O
}	O
case	O
CTF_K_FUNCTION	int
:	O
{	O
uint32_t	int
*	O
item	pointer
=	O
(	O
uint32_t	int
*	O
)	O
t	pointer
;	O
ssize_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
vlen	long
;	O
i	pointer
>	O
0	int
;	O
item	pointer
++	O
,	O
i	pointer
--	O
)	O
swap_thing	O
(	O
*	O
item	pointer
)	O
;	O
break	O
;	O
}	O
case	O
CTF_K_ARRAY	int
:	O
{	O
ctf_array_t	struct
*	O
a	pointer
=	O
(	O
ctf_array_t	struct
*	O
)	O
t	pointer
;	O
assert	O
(	O
vbytes	long
==	O
sizeof	O
(	O
ctf_array_t	struct
)	O
)	O
;	O
swap_thing	O
(	O
a	pointer
->	O
cta_contents	short
)	O
;	O
swap_thing	O
(	O
a	pointer
->	O
cta_index	short
)	O
;	O
swap_thing	O
(	O
a	pointer
->	O
cta_nelems	int
)	O
;	O
break	O
;	O
}	O
case	O
CTF_K_SLICE	int
:	O
{	O
ctf_slice_t	struct
*	O
s	pointer
=	O
(	O
ctf_slice_t	struct
*	O
)	O
t	pointer
;	O
assert	O
(	O
vbytes	long
==	O
sizeof	O
(	O
ctf_slice_t	struct
)	O
)	O
;	O
swap_thing	O
(	O
s	pointer
->	O
cts_type	int
)	O
;	O
swap_thing	O
(	O
s	pointer
->	O
cts_offset	short
)	O
;	O
swap_thing	O
(	O
s	pointer
->	O
cts_bits	short
)	O
;	O
break	O
;	O
}	O
case	O
CTF_K_STRUCT	int
:	O
case	O
CTF_K_UNION	int
:	O
{	O
if	O
(	O
_libctf_unlikely_	O
(	O
size	long
>=	O
CTF_LSTRUCT_THRESH	int
)	O
)	O
{	O
ctf_lmember_t	struct
*	O
lm	pointer
=	O
(	O
ctf_lmember_t	struct
*	O
)	O
t	pointer
;	O
ssize_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
vlen	long
;	O
i	pointer
>	O
0	int
;	O
i	pointer
--	O
,	O
lm	pointer
++	O
)	O
{	O
swap_thing	O
(	O
lm	pointer
->	O
ctlm_name	int
)	O
;	O
swap_thing	O
(	O
lm	pointer
->	O
ctlm_offsethi	int
)	O
;	O
swap_thing	O
(	O
lm	pointer
->	O
ctlm_type	short
)	O
;	O
swap_thing	O
(	O
lm	pointer
->	O
ctlm_offsetlo	int
)	O
;	O
}	O
}	O
else	O
{	O
ctf_member_t	struct
*	O
m	pointer
=	O
(	O
ctf_member_t	struct
*	O
)	O
t	pointer
;	O
ssize_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
vlen	long
;	O
i	pointer
>	O
0	int
;	O
i	pointer
--	O
,	O
m	pointer
++	O
)	O
{	O
swap_thing	O
(	O
m	pointer
->	O
ctm_name	int
)	O
;	O
swap_thing	O
(	O
m	pointer
->	O
ctm_offset	short
)	O
;	O
swap_thing	O
(	O
m	pointer
->	O
ctm_type	short
)	O
;	O
}	O
}	O
break	O
;	O
}	O
case	O
CTF_K_ENUM	int
:	O
{	O
ctf_enum_t	struct
*	O
item	pointer
=	O
(	O
ctf_enum_t	struct
*	O
)	O
t	pointer
;	O
ssize_t	long
i	pointer
;	O
for	O
(	O
i	pointer
=	O
vlen	long
;	O
i	pointer
>	O
0	int
;	O
item	pointer
++	O
,	O
i	pointer
--	O
)	O
{	O
swap_thing	O
(	O
item	pointer
->	O
cte_name	int
)	O
;	O
swap_thing	O
(	O
item	pointer
->	O
cte_value	int
)	O
;	O
}	O
break	O
;	O
}	O
default	O
:	O
ctf_dprintf	function
(	O
"unhandled CTF kind in endianness conversion -- %x\n"	pointer
,	O
kind	short
)	O
;	O
return	O
ECTF_CORRUPT	int
;	O
}	O
t	pointer
=	O
(	O
ctf_type_t	struct
*	O
)	O
(	O
(	O
uintptr_t	long
)	O
t	pointer
+	O
vbytes	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
flip_ctf	function
(	O
ctf_header_t	struct
*	O
cth	pointer
,	O
unsigned	O
char	O
*	O
buf	pointer
)	O
{	O
flip_lbls	function
(	O
buf	pointer
+	O
cth	pointer
->	O
cth_lbloff	int
,	O
cth	pointer
->	O
cth_objtoff	int
-	O
cth	pointer
->	O
cth_lbloff	int
)	O
;	O
flip_objts	function
(	O
buf	pointer
+	O
cth	pointer
->	O
cth_objtoff	int
,	O
cth	pointer
->	O
cth_funcoff	int
-	O
cth	pointer
->	O
cth_objtoff	int
)	O
;	O
flip_objts	function
(	O
buf	pointer
+	O
cth	pointer
->	O
cth_funcoff	int
,	O
cth	pointer
->	O
cth_objtidxoff	int
-	O
cth	pointer
->	O
cth_funcoff	int
)	O
;	O
flip_objts	function
(	O
buf	pointer
+	O
cth	pointer
->	O
cth_objtidxoff	int
,	O
cth	pointer
->	O
cth_funcidxoff	int
-	O
cth	pointer
->	O
cth_objtidxoff	int
)	O
;	O
flip_objts	function
(	O
buf	pointer
+	O
cth	pointer
->	O
cth_funcidxoff	int
,	O
cth	pointer
->	O
cth_varoff	int
-	O
cth	pointer
->	O
cth_funcidxoff	int
)	O
;	O
flip_vars	function
(	O
buf	pointer
+	O
cth	pointer
->	O
cth_varoff	int
,	O
cth	pointer
->	O
cth_typeoff	int
-	O
cth	pointer
->	O
cth_varoff	int
)	O
;	O
return	O
flip_types	function
(	O
buf	pointer
+	O
cth	pointer
->	O
cth_typeoff	int
,	O
cth	pointer
->	O
cth_stroff	int
-	O
cth	pointer
->	O
cth_typeoff	int
)	O
;	O
}	O
void	O
ctf_set_ctl_hashes	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
fp	pointer
->	O
ctf_lookups	array
[	O
0	int
]	O
.	O
ctl_prefix	pointer
=	O
"struct"	pointer
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
0	int
]	O
.	O
ctl_len	long
=	O
strlen	function
(	O
fp	pointer
->	O
ctf_lookups	array
[	O
0	int
]	O
.	O
ctl_prefix	pointer
)	O
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
0	int
]	O
.	O
ctl_hash	pointer
=	O
&	O
fp	pointer
->	O
ctf_structs	struct
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
1	int
]	O
.	O
ctl_prefix	pointer
=	O
"union"	pointer
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
1	int
]	O
.	O
ctl_len	long
=	O
strlen	function
(	O
fp	pointer
->	O
ctf_lookups	array
[	O
1	int
]	O
.	O
ctl_prefix	pointer
)	O
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
1	int
]	O
.	O
ctl_hash	pointer
=	O
&	O
fp	pointer
->	O
ctf_unions	struct
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
2	int
]	O
.	O
ctl_prefix	pointer
=	O
"enum"	pointer
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
2	int
]	O
.	O
ctl_len	long
=	O
strlen	function
(	O
fp	pointer
->	O
ctf_lookups	array
[	O
2	int
]	O
.	O
ctl_prefix	pointer
)	O
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
2	int
]	O
.	O
ctl_hash	pointer
=	O
&	O
fp	pointer
->	O
ctf_enums	struct
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
3	int
]	O
.	O
ctl_prefix	pointer
=	O
_CTF_NULLSTR	array
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
3	int
]	O
.	O
ctl_len	long
=	O
strlen	function
(	O
fp	pointer
->	O
ctf_lookups	array
[	O
3	int
]	O
.	O
ctl_prefix	pointer
)	O
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
3	int
]	O
.	O
ctl_hash	pointer
=	O
&	O
fp	pointer
->	O
ctf_names	struct
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
4	int
]	O
.	O
ctl_prefix	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
4	int
]	O
.	O
ctl_len	long
=	O
0	int
;	O
fp	pointer
->	O
ctf_lookups	array
[	O
4	int
]	O
.	O
ctl_hash	pointer
=	O
NULL	O
;	O
}	O
ctf_file_t	struct
*	O
ctf_simple_open	function
(	O
const	O
char	O
*	O
ctfsect	pointer
,	O
size_t	long
ctfsect_size	long
,	O
const	O
char	O
*	O
symsect	pointer
,	O
size_t	long
symsect_size	long
,	O
size_t	long
symsect_entsize	long
,	O
const	O
char	O
*	O
strsect	pointer
,	O
size_t	long
strsect_size	long
,	O
int	O
*	O
errp	pointer
)	O
{	O
return	O
ctf_simple_open_internal	function
(	O
ctfsect	pointer
,	O
ctfsect_size	long
,	O
symsect	pointer
,	O
symsect_size	long
,	O
symsect_entsize	long
,	O
strsect	pointer
,	O
strsect_size	long
,	O
NULL	O
,	O
0	int
,	O
errp	pointer
)	O
;	O
}	O
ctf_file_t	struct
*	O
ctf_simple_open_internal	function
(	O
const	O
char	O
*	O
ctfsect	pointer
,	O
size_t	long
ctfsect_size	long
,	O
const	O
char	O
*	O
symsect	pointer
,	O
size_t	long
symsect_size	long
,	O
size_t	long
symsect_entsize	long
,	O
const	O
char	O
*	O
strsect	pointer
,	O
size_t	long
strsect_size	long
,	O
ctf_dynhash_t	struct
*	O
syn_strtab	pointer
,	O
int	O
writable	int
,	O
int	O
*	O
errp	pointer
)	O
{	O
ctf_sect_t	struct
skeleton	struct
;	O
ctf_sect_t	struct
ctf_sect	struct
,	O
sym_sect	struct
,	O
str_sect	struct
;	O
ctf_sect_t	struct
*	O
ctfsectp	pointer
=	O
NULL	O
;	O
ctf_sect_t	struct
*	O
symsectp	pointer
=	O
NULL	O
;	O
ctf_sect_t	struct
*	O
strsectp	pointer
=	O
NULL	O
;	O
skeleton	struct
.	O
cts_name	pointer
=	O
_CTF_SECTION	array
;	O
skeleton	struct
.	O
cts_entsize	long
=	O
1	int
;	O
if	O
(	O
ctfsect	pointer
)	O
{	O
memcpy	function
(	O
&	O
ctf_sect	struct
,	O
&	O
skeleton	struct
,	O
sizeof	O
(	O
struct	O
ctf_sect	struct
)	O
)	O
;	O
ctf_sect	struct
.	O
cts_data	pointer
=	O
ctfsect	pointer
;	O
ctf_sect	struct
.	O
cts_size	long
=	O
ctfsect_size	long
;	O
ctfsectp	pointer
=	O
&	O
ctf_sect	struct
;	O
}	O
if	O
(	O
symsect	pointer
)	O
{	O
memcpy	function
(	O
&	O
sym_sect	struct
,	O
&	O
skeleton	struct
,	O
sizeof	O
(	O
struct	O
ctf_sect	struct
)	O
)	O
;	O
sym_sect	struct
.	O
cts_data	pointer
=	O
symsect	pointer
;	O
sym_sect	struct
.	O
cts_size	long
=	O
symsect_size	long
;	O
sym_sect	struct
.	O
cts_entsize	long
=	O
symsect_entsize	long
;	O
symsectp	pointer
=	O
&	O
sym_sect	struct
;	O
}	O
if	O
(	O
strsect	pointer
)	O
{	O
memcpy	function
(	O
&	O
str_sect	struct
,	O
&	O
skeleton	struct
,	O
sizeof	O
(	O
struct	O
ctf_sect	struct
)	O
)	O
;	O
str_sect	struct
.	O
cts_data	pointer
=	O
strsect	pointer
;	O
str_sect	struct
.	O
cts_size	long
=	O
strsect_size	long
;	O
strsectp	pointer
=	O
&	O
str_sect	struct
;	O
}	O
return	O
ctf_bufopen_internal	function
(	O
ctfsectp	pointer
,	O
symsectp	pointer
,	O
strsectp	pointer
,	O
syn_strtab	pointer
,	O
writable	int
,	O
errp	pointer
)	O
;	O
}	O
ctf_file_t	struct
*	O
ctf_bufopen	function
(	O
const	O
ctf_sect_t	struct
*	O
ctfsect	pointer
,	O
const	O
ctf_sect_t	struct
*	O
symsect	pointer
,	O
const	O
ctf_sect_t	struct
*	O
strsect	pointer
,	O
int	O
*	O
errp	pointer
)	O
{	O
return	O
ctf_bufopen_internal	function
(	O
ctfsect	pointer
,	O
symsect	pointer
,	O
strsect	pointer
,	O
NULL	O
,	O
0	int
,	O
errp	pointer
)	O
;	O
}	O
ctf_file_t	struct
*	O
ctf_bufopen_internal	function
(	O
const	O
ctf_sect_t	struct
*	O
ctfsect	pointer
,	O
const	O
ctf_sect_t	struct
*	O
symsect	pointer
,	O
const	O
ctf_sect_t	struct
*	O
strsect	pointer
,	O
ctf_dynhash_t	struct
*	O
syn_strtab	pointer
,	O
int	O
writable	int
,	O
int	O
*	O
errp	pointer
)	O
{	O
const	O
ctf_preamble_t	struct
*	O
pp	pointer
;	O
size_t	long
hdrsz	long
=	O
sizeof	O
(	O
ctf_header_t	struct
)	O
;	O
ctf_header_t	struct
*	O
hp	pointer
;	O
ctf_file_t	struct
*	O
fp	pointer
;	O
int	O
foreign_endian	int
=	O
0	int
;	O
int	O
err	long
;	O
libctf_init_debug	function
(	O
)	O
;	O
if	O
(	O
(	O
ctfsect	pointer
==	O
NULL	O
)	O
||	O
(	O
(	O
symsect	pointer
!=	O
NULL	O
)	O
&&	O
(	O
(	O
strsect	pointer
==	O
NULL	O
)	O
&&	O
syn_strtab	pointer
==	O
NULL	O
)	O
)	O
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
if	O
(	O
symsect	pointer
!=	O
NULL	O
&&	O
symsect	pointer
->	O
cts_entsize	long
!=	O
sizeof	O
(	O
Elf32_Sym	struct
)	O
&&	O
symsect	pointer
->	O
cts_entsize	long
!=	O
sizeof	O
(	O
Elf64_Sym	struct
)	O
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_SYMTAB	int
)	O
)	O
;	O
if	O
(	O
symsect	pointer
!=	O
NULL	O
&&	O
symsect	pointer
->	O
cts_data	pointer
==	O
NULL	O
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_SYMBAD	int
)	O
)	O
;	O
if	O
(	O
strsect	pointer
!=	O
NULL	O
&&	O
strsect	pointer
->	O
cts_data	pointer
==	O
NULL	O
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_STRBAD	int
)	O
)	O
;	O
if	O
(	O
ctfsect	pointer
->	O
cts_size	long
<	O
sizeof	O
(	O
ctf_preamble_t	struct
)	O
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_NOCTFBUF	int
)	O
)	O
;	O
pp	pointer
=	O
(	O
const	O
ctf_preamble_t	struct
*	O
)	O
ctfsect	pointer
->	O
cts_data	pointer
;	O
ctf_dprintf	function
(	O
"ctf_bufopen: magic=0x%x version=%u\n"	pointer
,	O
pp	pointer
->	O
ctp_magic	short
,	O
pp	pointer
->	O
ctp_version	char
)	O
;	O
if	O
(	O
_libctf_unlikely_	O
(	O
pp	pointer
->	O
ctp_magic	short
!=	O
CTF_MAGIC	int
)	O
)	O
{	O
if	O
(	O
pp	pointer
->	O
ctp_magic	short
==	O
bswap_16	O
(	O
CTF_MAGIC	int
)	O
)	O
{	O
if	O
(	O
pp	pointer
->	O
ctp_version	char
!=	O
CTF_VERSION_3	int
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_CTFVERS	int
)	O
)	O
;	O
foreign_endian	int
=	O
1	int
;	O
}	O
else	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_NOCTFBUF	int
)	O
)	O
;	O
}	O
if	O
(	O
_libctf_unlikely_	O
(	O
(	O
pp	pointer
->	O
ctp_version	char
<	O
CTF_VERSION_1	int
)	O
||	O
(	O
pp	pointer
->	O
ctp_version	char
>	O
CTF_VERSION_3	int
)	O
)	O
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_CTFVERS	int
)	O
)	O
;	O
if	O
(	O
(	O
symsect	pointer
!=	O
NULL	O
)	O
&&	O
(	O
pp	pointer
->	O
ctp_version	char
<	O
CTF_VERSION_2	int
)	O
)	O
{	O
ctf_dprintf	function
(	O
"ctf_bufopen: CTF version %d symsect not "	pointer
"supported\n"	pointer
,	O
pp	pointer
->	O
ctp_version	char
)	O
;	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_NOTSUP	int
)	O
)	O
;	O
}	O
if	O
(	O
pp	pointer
->	O
ctp_version	char
<	O
CTF_VERSION_3	int
)	O
hdrsz	long
=	O
sizeof	O
(	O
ctf_header_v2_t	struct
)	O
;	O
if	O
(	O
ctfsect	pointer
->	O
cts_size	long
<	O
hdrsz	long
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_NOCTFBUF	int
)	O
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
ctf_file_t	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ENOMEM	int
)	O
)	O
;	O
memset	function
(	O
fp	pointer
,	O
0	int
,	O
sizeof	O
(	O
ctf_file_t	struct
)	O
)	O
;	O
if	O
(	O
writable	int
)	O
fp	pointer
->	O
ctf_flags	int
|=	O
LCTF_RDWR	int
;	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_header	struct
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
ctf_header	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
free	function
(	O
fp	pointer
)	O
;	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ENOMEM	int
)	O
)	O
;	O
}	O
hp	pointer
=	O
fp	pointer
->	O
ctf_header	struct
;	O
memcpy	function
(	O
hp	pointer
,	O
ctfsect	pointer
->	O
cts_data	pointer
,	O
hdrsz	long
)	O
;	O
if	O
(	O
pp	pointer
->	O
ctp_version	char
<	O
CTF_VERSION_3	int
)	O
upgrade_header	function
(	O
hp	pointer
)	O
;	O
if	O
(	O
foreign_endian	int
)	O
flip_header	function
(	O
hp	pointer
)	O
;	O
fp	pointer
->	O
ctf_openflags	char
=	O
hp	pointer
->	O
cth_flags	O
;	O
fp	pointer
->	O
ctf_size	long
=	O
hp	pointer
->	O
cth_stroff	int
+	O
hp	pointer
->	O
cth_strlen	int
;	O
ctf_dprintf	function
(	O
"ctf_bufopen: uncompressed size=%lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
fp	pointer
->	O
ctf_size	long
)	O
;	O
if	O
(	O
hp	pointer
->	O
cth_lbloff	int
>	O
fp	pointer
->	O
ctf_size	long
||	O
hp	pointer
->	O
cth_objtoff	int
>	O
fp	pointer
->	O
ctf_size	long
||	O
hp	pointer
->	O
cth_funcoff	int
>	O
fp	pointer
->	O
ctf_size	long
||	O
hp	pointer
->	O
cth_objtidxoff	int
>	O
fp	pointer
->	O
ctf_size	long
||	O
hp	pointer
->	O
cth_funcidxoff	int
>	O
fp	pointer
->	O
ctf_size	long
||	O
hp	pointer
->	O
cth_typeoff	int
>	O
fp	pointer
->	O
ctf_size	long
||	O
hp	pointer
->	O
cth_stroff	int
>	O
fp	pointer
->	O
ctf_size	long
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_CORRUPT	int
)	O
)	O
;	O
if	O
(	O
hp	pointer
->	O
cth_lbloff	int
>	O
hp	pointer
->	O
cth_objtoff	int
||	O
hp	pointer
->	O
cth_objtoff	int
>	O
hp	pointer
->	O
cth_funcoff	int
||	O
hp	pointer
->	O
cth_funcoff	int
>	O
hp	pointer
->	O
cth_typeoff	int
||	O
hp	pointer
->	O
cth_funcoff	int
>	O
hp	pointer
->	O
cth_objtidxoff	int
||	O
hp	pointer
->	O
cth_objtidxoff	int
>	O
hp	pointer
->	O
cth_funcidxoff	int
||	O
hp	pointer
->	O
cth_funcidxoff	int
>	O
hp	pointer
->	O
cth_varoff	int
||	O
hp	pointer
->	O
cth_varoff	int
>	O
hp	pointer
->	O
cth_typeoff	int
||	O
hp	pointer
->	O
cth_typeoff	int
>	O
hp	pointer
->	O
cth_stroff	int
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_CORRUPT	int
)	O
)	O
;	O
if	O
(	O
(	O
hp	pointer
->	O
cth_lbloff	int
&	O
3	int
)	O
||	O
(	O
hp	pointer
->	O
cth_objtoff	int
&	O
2	int
)	O
||	O
(	O
hp	pointer
->	O
cth_funcoff	int
&	O
2	int
)	O
||	O
(	O
hp	pointer
->	O
cth_objtidxoff	int
&	O
2	int
)	O
||	O
(	O
hp	pointer
->	O
cth_funcidxoff	int
&	O
2	int
)	O
||	O
(	O
hp	pointer
->	O
cth_varoff	int
&	O
3	int
)	O
||	O
(	O
hp	pointer
->	O
cth_typeoff	int
&	O
3	int
)	O
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_CORRUPT	int
)	O
)	O
;	O
if	O
(	O
hp	pointer
->	O
cth_flags	O
&	O
CTF_F_COMPRESS	int
)	O
{	O
size_t	long
srclen	long
;	O
uLongf	long
dstlen	long
;	O
const	O
void	O
*	O
src	pointer
;	O
int	O
rc	int
=	O
Z_OK	int
;	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_base	pointer
=	O
malloc	function
(	O
fp	pointer
->	O
ctf_size	long
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
ECTF_ZALLOC	int
;	O
goto	O
bad	O
;	O
}	O
fp	pointer
->	O
ctf_dynbase	pointer
=	O
fp	pointer
->	O
ctf_base	pointer
;	O
hp	pointer
->	O
cth_flags	O
&=	O
~	O
CTF_F_COMPRESS	int
;	O
src	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
ctfsect	pointer
->	O
cts_data	pointer
+	O
hdrsz	long
;	O
srclen	long
=	O
ctfsect	pointer
->	O
cts_size	long
-	O
hdrsz	long
;	O
dstlen	long
=	O
fp	pointer
->	O
ctf_size	long
;	O
fp	pointer
->	O
ctf_buf	pointer
=	O
fp	pointer
->	O
ctf_base	pointer
;	O
if	O
(	O
(	O
rc	int
=	O
uncompress	function
(	O
fp	pointer
->	O
ctf_base	pointer
,	O
&	O
dstlen	long
,	O
src	pointer
,	O
srclen	long
)	O
)	O
!=	O
Z_OK	int
)	O
{	O
ctf_dprintf	function
(	O
"zlib inflate err: %s\n"	pointer
,	O
zError	function
(	O
rc	int
)	O
)	O
;	O
err	long
=	O
ECTF_DECOMPRESS	int
;	O
goto	O
bad	O
;	O
}	O
if	O
(	O
(	O
size_t	long
)	O
dstlen	long
!=	O
fp	pointer
->	O
ctf_size	long
)	O
{	O
ctf_dprintf	function
(	O
"zlib inflate short -- got %lu of %lu "	pointer
"bytes\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
dstlen	long
,	O
(	O
unsigned	O
long	O
)	O
fp	pointer
->	O
ctf_size	long
)	O
;	O
err	long
=	O
ECTF_CORRUPT	int
;	O
goto	O
bad	O
;	O
}	O
}	O
else	O
if	O
(	O
foreign_endian	int
)	O
{	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_base	pointer
=	O
malloc	function
(	O
fp	pointer
->	O
ctf_size	long
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
ECTF_ZALLOC	int
;	O
goto	O
bad	O
;	O
}	O
fp	pointer
->	O
ctf_dynbase	pointer
=	O
fp	pointer
->	O
ctf_base	pointer
;	O
memcpy	function
(	O
fp	pointer
->	O
ctf_base	pointer
,	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
ctfsect	pointer
->	O
cts_data	pointer
)	O
+	O
hdrsz	long
,	O
fp	pointer
->	O
ctf_size	long
)	O
;	O
fp	pointer
->	O
ctf_buf	pointer
=	O
fp	pointer
->	O
ctf_base	pointer
;	O
}	O
else	O
{	O
fp	pointer
->	O
ctf_base	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
ctfsect	pointer
->	O
cts_data	pointer
;	O
fp	pointer
->	O
ctf_dynbase	pointer
=	O
NULL	O
;	O
fp	pointer
->	O
ctf_buf	pointer
=	O
fp	pointer
->	O
ctf_base	pointer
+	O
hdrsz	long
;	O
}	O
ctf_set_version	function
(	O
fp	pointer
,	O
hp	pointer
,	O
hp	pointer
->	O
cth_version	O
)	O
;	O
ctf_str_create_atoms	function
(	O
fp	pointer
)	O
;	O
fp	pointer
->	O
ctf_parmax	int
=	O
CTF_MAX_PTYPE	int
;	O
memcpy	function
(	O
&	O
fp	pointer
->	O
ctf_data	struct
,	O
ctfsect	pointer
,	O
sizeof	O
(	O
ctf_sect_t	struct
)	O
)	O
;	O
if	O
(	O
symsect	pointer
!=	O
NULL	O
)	O
{	O
memcpy	function
(	O
&	O
fp	pointer
->	O
ctf_symtab	struct
,	O
symsect	pointer
,	O
sizeof	O
(	O
ctf_sect_t	struct
)	O
)	O
;	O
memcpy	function
(	O
&	O
fp	pointer
->	O
ctf_strtab	struct
,	O
strsect	pointer
,	O
sizeof	O
(	O
ctf_sect_t	struct
)	O
)	O
;	O
}	O
if	O
(	O
fp	pointer
->	O
ctf_data	struct
.	O
cts_name	pointer
!=	O
NULL	O
)	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_data	struct
.	O
cts_name	pointer
=	O
strdup	function
(	O
fp	pointer
->	O
ctf_data	struct
.	O
cts_name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
ENOMEM	int
;	O
goto	O
bad	O
;	O
}	O
if	O
(	O
fp	pointer
->	O
ctf_symtab	struct
.	O
cts_name	pointer
!=	O
NULL	O
)	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_symtab	struct
.	O
cts_name	pointer
=	O
strdup	function
(	O
fp	pointer
->	O
ctf_symtab	struct
.	O
cts_name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
ENOMEM	int
;	O
goto	O
bad	O
;	O
}	O
if	O
(	O
fp	pointer
->	O
ctf_strtab	struct
.	O
cts_name	pointer
!=	O
NULL	O
)	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_strtab	struct
.	O
cts_name	pointer
=	O
strdup	function
(	O
fp	pointer
->	O
ctf_strtab	struct
.	O
cts_name	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
err	long
=	O
ENOMEM	int
;	O
goto	O
bad	O
;	O
}	O
if	O
(	O
fp	pointer
->	O
ctf_data	struct
.	O
cts_name	pointer
==	O
NULL	O
)	O
fp	pointer
->	O
ctf_data	struct
.	O
cts_name	pointer
=	O
_CTF_NULLSTR	array
;	O
if	O
(	O
fp	pointer
->	O
ctf_symtab	struct
.	O
cts_name	pointer
==	O
NULL	O
)	O
fp	pointer
->	O
ctf_symtab	struct
.	O
cts_name	pointer
=	O
_CTF_NULLSTR	array
;	O
if	O
(	O
fp	pointer
->	O
ctf_strtab	struct
.	O
cts_name	pointer
==	O
NULL	O
)	O
fp	pointer
->	O
ctf_strtab	struct
.	O
cts_name	pointer
=	O
_CTF_NULLSTR	array
;	O
if	O
(	O
strsect	pointer
!=	O
NULL	O
)	O
{	O
fp	pointer
->	O
ctf_str	array
[	O
CTF_STRTAB_1	int
]	O
.	O
cts_strs	pointer
=	O
strsect	pointer
->	O
cts_data	pointer
;	O
fp	pointer
->	O
ctf_str	array
[	O
CTF_STRTAB_1	int
]	O
.	O
cts_len	long
=	O
strsect	pointer
->	O
cts_size	long
;	O
}	O
fp	pointer
->	O
ctf_syn_ext_strtab	pointer
=	O
syn_strtab	pointer
;	O
if	O
(	O
foreign_endian	int
&&	O
(	O
err	long
=	O
flip_ctf	function
(	O
hp	pointer
,	O
fp	pointer
->	O
ctf_buf	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
ctf_set_base	function
(	O
fp	pointer
,	O
hp	pointer
,	O
fp	pointer
->	O
ctf_base	pointer
)	O
;	O
goto	O
bad	O
;	O
}	O
ctf_set_base	function
(	O
fp	pointer
,	O
hp	pointer
,	O
fp	pointer
->	O
ctf_base	pointer
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
{	O
fp	pointer
->	O
ctf_refcnt	int
=	O
1	int
;	O
return	O
fp	pointer
;	O
}	O
if	O
(	O
(	O
err	long
=	O
init_types	function
(	O
fp	pointer
,	O
hp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
bad	O
;	O
if	O
(	O
symsect	pointer
!=	O
NULL	O
)	O
{	O
fp	pointer
->	O
ctf_nsyms	long
=	O
symsect	pointer
->	O
cts_size	long
/	O
symsect	pointer
->	O
cts_entsize	long
;	O
fp	pointer
->	O
ctf_sxlate	pointer
=	O
malloc	function
(	O
fp	pointer
->	O
ctf_nsyms	long
*	O
sizeof	O
(	O
uint32_t	int
)	O
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_sxlate	pointer
==	O
NULL	O
)	O
{	O
err	long
=	O
ENOMEM	int
;	O
goto	O
bad	O
;	O
}	O
if	O
(	O
(	O
err	long
=	O
init_symtab	function
(	O
fp	pointer
,	O
hp	pointer
,	O
symsect	pointer
,	O
strsect	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
bad	O
;	O
}	O
ctf_set_ctl_hashes	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
symsect	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
symsect	pointer
->	O
cts_entsize	long
==	O
sizeof	O
(	O
Elf64_Sym	struct
)	O
)	O
(	O
void	O
)	O
ctf_setmodel	function
(	O
fp	pointer
,	O
CTF_MODEL_LP64	int
)	O
;	O
else	O
(	O
void	O
)	O
ctf_setmodel	function
(	O
fp	pointer
,	O
CTF_MODEL_ILP32	int
)	O
;	O
}	O
else	O
(	O
void	O
)	O
ctf_setmodel	function
(	O
fp	pointer
,	O
CTF_MODEL_NATIVE	O
)	O
;	O
fp	pointer
->	O
ctf_refcnt	int
=	O
1	int
;	O
return	O
fp	pointer
;	O
bad	O
:	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
err	long
)	O
;	O
ctf_file_close	function
(	O
fp	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
ctf_file_close	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
ctf_dtdef_t	struct
*	O
dtd	pointer
,	O
*	O
ntd	pointer
;	O
ctf_dvdef_t	struct
*	O
dvd	pointer
,	O
*	O
nvd	pointer
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
return	O
;	O
ctf_dprintf	function
(	O
"ctf_file_close(%p) refcnt=%u\n"	pointer
,	O
(	O
void	O
*	O
)	O
fp	pointer
,	O
fp	pointer
->	O
ctf_refcnt	int
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_refcnt	int
>	O
1	int
)	O
{	O
fp	pointer
->	O
ctf_refcnt	int
--	O
;	O
return	O
;	O
}	O
free	function
(	O
fp	pointer
->	O
ctf_dyncuname	pointer
)	O
;	O
free	function
(	O
fp	pointer
->	O
ctf_dynparname	pointer
)	O
;	O
ctf_file_close	function
(	O
fp	pointer
->	O
ctf_parent	pointer
)	O
;	O
for	O
(	O
dtd	pointer
=	O
ctf_list_next	O
(	O
&	O
fp	pointer
->	O
ctf_dtdefs	struct
)	O
;	O
dtd	pointer
!=	O
NULL	O
;	O
dtd	pointer
=	O
ntd	pointer
)	O
{	O
ntd	pointer
=	O
ctf_list_next	O
(	O
dtd	pointer
)	O
;	O
ctf_dtd_delete	function
(	O
fp	pointer
,	O
dtd	pointer
)	O
;	O
}	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_dthash	pointer
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_flags	int
&	O
LCTF_RDWR	int
)	O
{	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_structs	struct
.	O
ctn_writable	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_unions	struct
.	O
ctn_writable	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_enums	struct
.	O
ctn_writable	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_names	struct
.	O
ctn_writable	pointer
)	O
;	O
}	O
else	O
{	O
ctf_hash_destroy	function
(	O
fp	pointer
->	O
ctf_structs	struct
.	O
ctn_readonly	pointer
)	O
;	O
ctf_hash_destroy	function
(	O
fp	pointer
->	O
ctf_unions	struct
.	O
ctn_readonly	pointer
)	O
;	O
ctf_hash_destroy	function
(	O
fp	pointer
->	O
ctf_enums	struct
.	O
ctn_readonly	pointer
)	O
;	O
ctf_hash_destroy	function
(	O
fp	pointer
->	O
ctf_names	struct
.	O
ctn_readonly	pointer
)	O
;	O
}	O
for	O
(	O
dvd	pointer
=	O
ctf_list_next	O
(	O
&	O
fp	pointer
->	O
ctf_dvdefs	struct
)	O
;	O
dvd	pointer
!=	O
NULL	O
;	O
dvd	pointer
=	O
nvd	pointer
)	O
{	O
nvd	pointer
=	O
ctf_list_next	O
(	O
dvd	pointer
)	O
;	O
ctf_dvd_delete	function
(	O
fp	pointer
,	O
dvd	pointer
)	O
;	O
}	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_dvhash	pointer
)	O
;	O
ctf_str_free_atoms	function
(	O
fp	pointer
)	O
;	O
free	function
(	O
fp	pointer
->	O
ctf_tmp_typeslice	pointer
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_data	struct
.	O
cts_name	pointer
!=	O
_CTF_NULLSTR	array
)	O
free	function
(	O
(	O
char	O
*	O
)	O
fp	pointer
->	O
ctf_data	struct
.	O
cts_name	pointer
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_symtab	struct
.	O
cts_name	pointer
!=	O
_CTF_NULLSTR	array
)	O
free	function
(	O
(	O
char	O
*	O
)	O
fp	pointer
->	O
ctf_symtab	struct
.	O
cts_name	pointer
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_strtab	struct
.	O
cts_name	pointer
!=	O
_CTF_NULLSTR	array
)	O
free	function
(	O
(	O
char	O
*	O
)	O
fp	pointer
->	O
ctf_strtab	struct
.	O
cts_name	pointer
)	O
;	O
else	O
if	O
(	O
fp	pointer
->	O
ctf_data_mmapped	pointer
)	O
ctf_munmap	function
(	O
fp	pointer
->	O
ctf_data_mmapped	pointer
,	O
fp	pointer
->	O
ctf_data_mmapped_len	long
)	O
;	O
free	function
(	O
fp	pointer
->	O
ctf_dynbase	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_syn_ext_strtab	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_link_inputs	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_link_outputs	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_link_type_mapping	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_link_cu_mapping	pointer
)	O
;	O
ctf_dynhash_destroy	function
(	O
fp	pointer
->	O
ctf_add_processing	pointer
)	O
;	O
free	function
(	O
fp	pointer
->	O
ctf_sxlate	pointer
)	O
;	O
free	function
(	O
fp	pointer
->	O
ctf_txlate	pointer
)	O
;	O
free	function
(	O
fp	pointer
->	O
ctf_ptrtab	pointer
)	O
;	O
free	function
(	O
fp	pointer
->	O
ctf_header	struct
)	O
;	O
free	function
(	O
fp	pointer
)	O
;	O
}	O
void	O
ctf_close	function
(	O
ctf_archive_t	struct
*	O
arc	pointer
)	O
{	O
ctf_arc_close	function
(	O
arc	pointer
)	O
;	O
}	O
ctf_archive_t	struct
*	O
ctf_get_arc	function
(	O
const	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
return	O
fp	pointer
->	O
ctf_archive	struct
;	O
}	O
ctf_sect_t	struct
ctf_getdatasect	function
(	O
const	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
return	O
fp	pointer
->	O
ctf_data	struct
;	O
}	O
ctf_file_t	struct
*	O
ctf_parent_file	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
return	O
fp	pointer
->	O
ctf_parent	pointer
;	O
}	O
const	O
char	O
*	O
ctf_parent_name	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
return	O
fp	pointer
->	O
ctf_parname	pointer
;	O
}	O
int	O
ctf_parent_name_set	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
fp	pointer
->	O
ctf_dynparname	pointer
!=	O
NULL	O
)	O
free	function
(	O
fp	pointer
->	O
ctf_dynparname	pointer
)	O
;	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_dynparname	pointer
=	O
strdup	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
)	O
;	O
fp	pointer
->	O
ctf_parname	pointer
=	O
fp	pointer
->	O
ctf_dynparname	pointer
;	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
ctf_cuname	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
return	O
fp	pointer
->	O
ctf_cuname	function
;	O
}	O
int	O
ctf_cuname_set	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
if	O
(	O
fp	pointer
->	O
ctf_dyncuname	pointer
!=	O
NULL	O
)	O
free	function
(	O
fp	pointer
->	O
ctf_dyncuname	pointer
)	O
;	O
if	O
(	O
(	O
fp	pointer
->	O
ctf_dyncuname	pointer
=	O
strdup	function
(	O
name	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ENOMEM	int
)	O
)	O
;	O
fp	pointer
->	O
ctf_cuname	function
=	O
fp	pointer
->	O
ctf_dyncuname	pointer
;	O
return	O
0	int
;	O
}	O
int	O
ctf_import	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
ctf_file_t	struct
*	O
pfp	pointer
)	O
{	O
if	O
(	O
fp	pointer
==	O
NULL	O
||	O
fp	pointer
==	O
pfp	pointer
||	O
(	O
pfp	pointer
!=	O
NULL	O
&&	O
pfp	pointer
->	O
ctf_refcnt	int
==	O
0	int
)	O
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
if	O
(	O
pfp	pointer
!=	O
NULL	O
&&	O
pfp	pointer
->	O
ctf_dmodel	struct
!=	O
fp	pointer
->	O
ctf_dmodel	struct
)	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
ECTF_DMODEL	int
)	O
)	O
;	O
if	O
(	O
fp	pointer
->	O
ctf_parent	pointer
!=	O
NULL	O
)	O
{	O
fp	pointer
->	O
ctf_parent	pointer
->	O
ctf_refcnt	int
--	O
;	O
ctf_file_close	function
(	O
fp	pointer
->	O
ctf_parent	pointer
)	O
;	O
fp	pointer
->	O
ctf_parent	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
pfp	pointer
!=	O
NULL	O
)	O
{	O
int	O
err	long
;	O
if	O
(	O
fp	pointer
->	O
ctf_parname	pointer
==	O
NULL	O
)	O
if	O
(	O
(	O
err	long
=	O
ctf_parent_name_set	function
(	O
fp	pointer
,	O
"PARENT"	pointer
)	O
)	O
<	O
0	int
)	O
return	O
err	long
;	O
fp	pointer
->	O
ctf_flags	int
|=	O
LCTF_CHILD	int
;	O
pfp	pointer
->	O
ctf_refcnt	int
++	O
;	O
}	O
fp	pointer
->	O
ctf_parent	pointer
=	O
pfp	pointer
;	O
return	O
0	int
;	O
}	O
int	O
ctf_setmodel	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
int	O
model	int
)	O
{	O
const	O
ctf_dmodel_t	struct
*	O
dp	pointer
;	O
for	O
(	O
dp	pointer
=	O
_libctf_models	array
;	O
dp	pointer
->	O
ctd_name	pointer
!=	O
NULL	O
;	O
dp	pointer
++	O
)	O
{	O
if	O
(	O
dp	pointer
->	O
ctd_code	int
==	O
model	int
)	O
{	O
fp	pointer
->	O
ctf_dmodel	struct
=	O
dp	pointer
;	O
return	O
0	int
;	O
}	O
}	O
return	O
(	O
ctf_set_errno	function
(	O
fp	pointer
,	O
EINVAL	int
)	O
)	O
;	O
}	O
int	O
ctf_getmodel	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
return	O
fp	pointer
->	O
ctf_dmodel	struct
->	O
ctd_code	int
;	O
}	O
void	O
ctf_setspecific	function
(	O
ctf_file_t	struct
*	O
fp	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
fp	pointer
->	O
ctf_specific	pointer
=	O
data	pointer
;	O
}	O
void	O
*	O
ctf_getspecific	function
(	O
ctf_file_t	struct
*	O
fp	pointer
)	O
{	O
return	O
fp	pointer
->	O
ctf_specific	pointer
;	O
}	O
