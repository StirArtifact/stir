extern	O
int	O
tputs	function
PROTO	O
(	O
(	O
const	O
char	O
*	O
__string	pointer
,	O
int	O
__nlines	int
,	O
int	O
(	O
*	O
outfun	pointer
)	O
(	O
)	O
)	O
)	O
;	O
extern	O
int	O
tgetent	function
PROTO	O
(	O
(	O
void	O
*	O
__buffer	pointer
,	O
const	O
char	O
*	O
__termtype	pointer
)	O
)	O
;	O
extern	O
char	O
*	O
tgetstr	function
PROTO	O
(	O
(	O
const	O
char	O
*	O
__name	pointer
,	O
char	O
*	O
*	O
__area	pointer
)	O
)	O
;	O
extern	O
int	O
tgetnum	function
PROTO	O
(	O
(	O
const	O
char	O
*	O
__name	pointer
)	O
)	O
;	O
extern	O
int	O
tgetflag	function
PROTO	O
(	O
(	O
const	O
char	O
*	O
__name	pointer
)	O
)	O
;	O
extern	O
char	O
*	O
tgoto	function
PROTO	O
(	O
(	O
const	O
char	O
*	O
__cstring	pointer
,	O
int	O
__hpos	int
,	O
int	O
__vpos	int
)	O
)	O
;	O
static	O
int	O
vcs_read_ok	int
;	O
static	O
int	O
vcs_is_monochrome	int
;	O
static	O
int	O
tty_kbdmode	int
;	O
static	O
struct	O
termios	struct
old_term	struct
;	O
static	O
struct	O
termios	struct
new_term	struct
;	O
int	O
tty_lines	int
;	O
int	O
tty_columns	int
;	O
char	O
*	O
tty_device	pointer
;	O
static	O
unsigned	O
char	O
*	O
tty_key_seq	pointer
;	O
static	O
int	O
tty_device_length	int
;	O
static	O
int	O
tty_last_char_flag	int
;	O
static	O
int	O
tty_cursor_x	int
;	O
static	O
int	O
tty_cursor_y	int
;	O
static	O
unsigned	O
char	O
tty_current_attribute	char
;	O
static	O
unsigned	O
char	O
tty_io_current_attribute	char
;	O
static	O
int	O
tty_interrupt_char	int
=	O
key_INTERRUPT	O
;	O
static	O
int	O
fg_cache	int
=	O
INVALID_CACHE	int
;	O
static	O
int	O
bg_cache	int
=	O
INVALID_CACHE	int
;	O
static	O
int	O
br_cache	int
=	O
INVALID_CACHE	int
;	O
static	O
int	O
rv_cache	int
=	O
INVALID_CACHE	int
;	O
static	O
unsigned	O
char	O
*	O
tty_scr	pointer
;	O
static	O
unsigned	O
char	O
*	O
tty_atr	pointer
;	O
static	O
unsigned	O
char	O
*	O
tty_prev_scr	pointer
;	O
static	O
unsigned	O
char	O
*	O
tty_prev_atr	pointer
;	O
static	O
char	O
ansi_foreground	array
[	O
]	O
=	O
{	O
0x1b	int
,	O
'['	O
,	O
'3'	O
,	O
'0'	O
,	O
'm'	O
}	O
;	O
static	O
char	O
ansi_background	array
[	O
]	O
=	O
{	O
0x1b	int
,	O
'['	O
,	O
'4'	O
,	O
'0'	O
,	O
'm'	O
}	O
;	O
static	O
char	O
ansi_defaults	array
[	O
]	O
=	O
{	O
0x1b	int
,	O
'['	O
,	O
'0'	O
,	O
'm'	O
}	O
;	O
extern	O
int	O
AnsiColors	int
;	O
int	O
LinuxConsole	int
;	O
tty_key_t	struct
*	O
key_list_head	pointer
;	O
tty_key_t	struct
*	O
current_key	pointer
;	O
tty_key_t	struct
default_key	struct
;	O
static	O
char	O
tty_cache	array
[	O
TTY_CACHE_SIZE	int
]	O
;	O
static	O
int	O
tty_index	int
;	O
static	O
char	O
vt100	array
[	O
]	O
=	O
"vt100"	pointer
;	O
int	O
tty_mode	int
=	O
TTY_CANONIC	int
;	O
char	O
*	O
tty_type	pointer
;	O
char	O
PC	char
;	O
char	O
*	O
BC	pointer
;	O
char	O
*	O
UP	pointer
;	O
speed_t	int
ospeed	int
;	O
typedef	O
struct	O
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
string	pointer
;	O
int	O
integer	int
;	O
int	O
required	int
;	O
char	O
*	O
symbol	pointer
;	O
}	O
tty_capability_t	struct
;	O
static	O
tty_capability_t	struct
tty_capability	array
[	O
TTY_CAPABILITIES_USED	int
]	O
=	O
{	O
{	O
"me"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"mr"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"md"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"vi"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"ve"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"cl"	pointer
,	O
NULL	O
,	O
0	int
,	O
1	int
,	O
NULL	O
}	O
,	O
{	O
"cm"	pointer
,	O
NULL	O
,	O
0	int
,	O
1	int
,	O
NULL	O
}	O
,	O
{	O
"pc"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"up"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"le"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"so"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"sg"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"ms"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"co"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"li"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"ti"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"te"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
,	O
{	O
"ku"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"UP"	pointer
}	O
,	O
{	O
"kd"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"DOWN"	pointer
}	O
,	O
{	O
"kr"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"RIGHT"	pointer
}	O
,	O
{	O
"kl"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"LEFT"	pointer
}	O
,	O
{	O
"kI"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"INS"	pointer
}	O
,	O
{	O
"kD"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"DEL"	pointer
}	O
,	O
{	O
"kh"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"HOME"	pointer
}	O
,	O
{	O
"@7"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"END"	pointer
}	O
,	O
{	O
"kP"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"PGUP"	pointer
}	O
,	O
{	O
"kN"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"PGDOWN"	pointer
}	O
,	O
{	O
"k0"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F0"	pointer
}	O
,	O
{	O
"k1"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F1"	pointer
}	O
,	O
{	O
"k2"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F2"	pointer
}	O
,	O
{	O
"k3"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F3"	pointer
}	O
,	O
{	O
"k4"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F4"	pointer
}	O
,	O
{	O
"k5"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F5"	pointer
}	O
,	O
{	O
"k6"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F6"	pointer
}	O
,	O
{	O
"k7"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F7"	pointer
}	O
,	O
{	O
"k8"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F8"	pointer
}	O
,	O
{	O
"k9"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F9"	pointer
}	O
,	O
{	O
"k;"	pointer
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
"F10"	pointer
}	O
,	O
}	O
;	O
static	O
char	O
term_database	array
[	O
]	O
=	O
"terminfo"	pointer
;	O
static	O
char	O
term_env	array
[	O
]	O
=	O
"TERMINFO"	pointer
;	O
static	O
void	O
tty_io_goto	function
PROTO	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
tty_io_foreground	function
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
tty_io_background	function
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
tty_io_brightness	function
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
tty_io_reversevid	function
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
tty_io_colors	function
PROTO	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
tty_is_xterm	function
PROTO	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
extern	O
void	O
fatal	function
PROTO	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
colors	array
[	O
10	int
]	O
=	O
{	O
"BLACK"	pointer
,	O
"RED"	pointer
,	O
"GREEN"	pointer
,	O
"YELLOW"	pointer
,	O
"BLUE"	pointer
,	O
"MAGENTA"	pointer
,	O
"CYAN"	pointer
,	O
"WHITE"	pointer
,	O
"OFF"	pointer
,	O
"ON"	pointer
}	O
;	O
unsigned	O
char	O
key_ctrl_table	array
[	O
0x5f	int
]	O
=	O
{	O
0x20	int
,	O
0x21	int
,	O
0x22	int
,	O
0x23	int
,	O
0xff	int
,	O
0x25	int
,	O
0x26	int
,	O
0x07	int
,	O
0x28	int
,	O
0x29	int
,	O
0x2a	int
,	O
0x2b	int
,	O
0x2c	int
,	O
0x2d	int
,	O
0x2e	int
,	O
0x2f	int
,	O
0x20	int
,	O
0x20	int
,	O
0xff	int
,	O
0x1b	int
,	O
0x1c	int
,	O
0x1d	int
,	O
0x1e	int
,	O
0x1f	int
,	O
0x7f	int
,	O
0x39	int
,	O
0x3a	int
,	O
0x3b	int
,	O
0x3c	int
,	O
0x20	int
,	O
0x3e	int
,	O
0x20	int
,	O
0x20	int
,	O
0x01	int
,	O
0x02	int
,	O
0x03	int
,	O
0x04	int
,	O
0x05	int
,	O
0x06	int
,	O
0x07	int
,	O
0x08	int
,	O
0x09	int
,	O
0x0a	int
,	O
0x0b	int
,	O
0x0c	int
,	O
0x0d	int
,	O
0x0e	int
,	O
0x0f	int
,	O
0x10	int
,	O
0x11	int
,	O
0x12	int
,	O
0x13	int
,	O
0x14	int
,	O
0x15	int
,	O
0x16	int
,	O
0x17	int
,	O
0x18	int
,	O
0x19	int
,	O
0x1a	int
,	O
0x1b	int
,	O
0x1c	int
,	O
0x1d	int
,	O
0x5e	int
,	O
0x7f	int
,	O
0x20	int
,	O
0x01	int
,	O
0x02	int
,	O
0x03	int
,	O
0x04	int
,	O
0x05	int
,	O
0x06	int
,	O
0x07	int
,	O
0x08	int
,	O
0x09	int
,	O
0x0a	int
,	O
0x0b	int
,	O
0x0c	int
,	O
0x0d	int
,	O
0x0e	int
,	O
0x0f	int
,	O
0x10	int
,	O
0x11	int
,	O
0x12	int
,	O
0x13	int
,	O
0x14	int
,	O
0x15	int
,	O
0x16	int
,	O
0x17	int
,	O
0x18	int
,	O
0x19	int
,	O
0x1a	int
,	O
0x20	int
,	O
0x20	int
,	O
0x20	int
,	O
0x20	int
,	O
}	O
;	O
static	O
int	O
keyno	int
=	O
0	int
;	O
static	O
int	O
keyindex	int
=	O
0	int
;	O
static	O
char	O
keybuf	array
[	O
1024	int
]	O
;	O
static	O
unsigned	O
char	O
keystr	array
[	O
MAX_KEY_LENGTH	int
*	O
20	int
]	O
;	O
static	O
int	O
partial	int
=	O
0	int
;	O
static	O
int	O
key_on_display	int
=	O
0	int
;	O
void	O
(	O
*	O
tty_enter_idle_hook	pointer
)	O
(	O
)	O
;	O
void	O
(	O
*	O
tty_exit_idle_hook	pointer
)	O
(	O
)	O
;	O
void	O
tty_set_last_char_flag	function
(	O
last_char_flag	int
)	O
int	O
last_char_flag	int
;	O
{	O
tty_last_char_flag	int
=	O
last_char_flag	int
;	O
}	O
void	O
tty_set_mode	function
(	O
mode	int
)	O
int	O
mode	int
;	O
{	O
if	O
(	O
mode	int
==	O
TTY_NONCANONIC	int
)	O
{	O
new_term	struct
=	O
old_term	struct
;	O
new_term	struct
.	O
c_iflag	short
&=	O
~	O
(	O
IXON	int
|	O
ICRNL	int
|	O
IGNCR	int
|	O
INLCR	int
|	O
IGNBRK	int
|	O
BRKINT	int
)	O
;	O
new_term	struct
.	O
c_oflag	short
&=	O
~	O
OPOST	int
;	O
new_term	struct
.	O
c_lflag	short
|=	O
ISIG	int
|	O
NOFLSH	int
;	O
new_term	struct
.	O
c_lflag	short
&=	O
~	O
(	O
ICANON	int
|	O
ECHO	int
)	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
=	O
key_INTERRUPT	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VQUIT	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VSTART	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VSTOP	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VMIN	int
]	O
=	O
1	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VTIME	int
]	O
=	O
0	int
;	O
new_term	struct
.	O
c_cc	array
[	O
VERASE	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VKILL	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VEOL	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VEOL2	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VSUSP	int
]	O
=	O
key_SUSPEND	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VREPRINT	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VDISCARD	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VWERASE	int
]	O
=	O
CDISABLE	O
;	O
new_term	struct
.	O
c_cc	array
[	O
VLNEXT	int
]	O
=	O
CDISABLE	O
;	O
tcsetattr	function
(	O
TTY_OUTPUT	int
,	O
TCSADRAIN	int
,	O
&	O
new_term	struct
)	O
;	O
ospeed	int
=	O
cfgetospeed	function
(	O
&	O
new_term	struct
)	O
;	O
ioctl	function
(	O
TTY_OUTPUT	int
,	O
TCXONC	int
,	O
1	int
)	O
;	O
tcflow	function
(	O
TTY_OUTPUT	int
,	O
TCOON	int
)	O
;	O
tty_set_interrupt_char	function
(	O
tty_interrupt_char	int
)	O
;	O
}	O
else	O
{	O
tcsetattr	function
(	O
TTY_OUTPUT	int
,	O
TCSADRAIN	int
,	O
&	O
old_term	struct
)	O
;	O
}	O
tty_mode	int
=	O
mode	int
;	O
}	O
int	O
tty_get_mode	function
(	O
)	O
{	O
return	O
tty_mode	int
;	O
}	O
void	O
tty_set_interrupt_char	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
struct	O
termios	struct
current_term	struct
;	O
tcgetattr	function
(	O
TTY_OUTPUT	int
,	O
&	O
current_term	struct
)	O
;	O
current_term	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
=	O
c	int
;	O
current_term	struct
.	O
c_cc	array
[	O
VQUIT	int
]	O
=	O
CDISABLE	O
;	O
tcsetattr	function
(	O
TTY_OUTPUT	int
,	O
TCSADRAIN	int
,	O
&	O
current_term	struct
)	O
;	O
tty_interrupt_char	int
=	O
c	int
;	O
}	O
void	O
tty_flush	function
(	O
)	O
{	O
int	O
bytes_transferred	int
=	O
0	int
;	O
while	O
(	O
bytes_transferred	int
<	O
tty_index	int
)	O
{	O
int	O
count	int
=	O
xwrite	function
(	O
TTY_OUTPUT	int
,	O
tty_cache	array
+	O
bytes_transferred	int
,	O
tty_index	int
-	O
bytes_transferred	int
)	O
;	O
if	O
(	O
count	int
<	O
0	int
)	O
break	O
;	O
bytes_transferred	int
+=	O
count	int
;	O
}	O
tty_index	int
=	O
0	int
;	O
}	O
int	O
tty_writec	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
if	O
(	O
tty_index	int
==	O
TTY_CACHE_SIZE	int
)	O
tty_flush	function
(	O
)	O
;	O
tty_cache	array
[	O
tty_index	int
++	O
]	O
=	O
(	O
char	O
)	O
c	int
;	O
return	O
1	int
;	O
}	O
void	O
tty_io_clear	function
(	O
)	O
{	O
tputs	function
(	O
TTY_CLEAR_SCREEN	O
,	O
tty_lines	int
,	O
tty_writec	function
)	O
;	O
tty_flush	function
(	O
)	O
;	O
}	O
void	O
tty_start_cursorapp	function
(	O
)	O
{	O
tputs	function
(	O
TTY_START_CURSORAPP	O
,	O
tty_lines	int
-	O
1	int
,	O
tty_writec	function
)	O
;	O
tty_flush	function
(	O
)	O
;	O
}	O
void	O
tty_end_cursorapp	function
(	O
)	O
{	O
tty_io_clear	function
(	O
)	O
;	O
tputs	function
(	O
TTY_END_CURSORAPP	O
,	O
tty_lines	int
-	O
1	int
,	O
tty_writec	function
)	O
;	O
tty_flush	function
(	O
)	O
;	O
}	O
void	O
tty_end	function
(	O
screen	pointer
)	O
char	O
*	O
screen	pointer
;	O
{	O
if	O
(	O
tty_mode	int
==	O
TTY_NONCANONIC	int
)	O
tty_set_mode	function
(	O
TTY_CANONIC	int
)	O
;	O
tty_defaults	function
(	O
)	O
;	O
if	O
(	O
screen	pointer
&&	O
LinuxConsole	int
)	O
tty_put_screen	function
(	O
screen	pointer
)	O
;	O
tty_end_cursorapp	function
(	O
)	O
;	O
tty_io_goto	function
(	O
tty_lines	int
,	O
0	int
)	O
;	O
tty_flush	function
(	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
char	O
*	O
tty_key_human2machine	function
(	O
key_seq	pointer
)	O
unsigned	O
char	O
*	O
key_seq	pointer
;	O
{	O
unsigned	O
char	O
*	O
first	pointer
;	O
unsigned	O
char	O
*	O
second	pointer
;	O
first	pointer
=	O
second	pointer
=	O
key_seq	pointer
;	O
if	O
(	O
tty_kbdmode	int
==	O
TTY_RESTRICTED_INPUT	int
&&	O
*	O
key_seq	pointer
!=	O
'^'	O
)	O
return	O
NULL	O
;	O
while	O
(	O
*	O
second	pointer
)	O
{	O
if	O
(	O
*	O
second	pointer
==	O
'^'	O
)	O
{	O
if	O
(	O
*	O
++	O
second	pointer
)	O
{	O
if	O
(	O
toupper	function
(	O
*	O
second	pointer
)	O
==	O
'G'	O
||	O
toupper	function
(	O
*	O
second	pointer
)	O
==	O
'Z'	O
)	O
return	O
NULL	O
;	O
*	O
first	pointer
++	O
=	O
key_ctrl_table	array
[	O
(	O
*	O
second	pointer
++	O
&	O
0x7F	int
)	O
-	O
' '	O
]	O
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
else	O
*	O
first	pointer
++	O
=	O
*	O
second	pointer
++	O
;	O
}	O
*	O
first	pointer
=	O
0	int
;	O
return	O
(	O
char	O
*	O
)	O
key_seq	pointer
;	O
}	O
unsigned	O
char	O
*	O
tty_key_machine2human	function
(	O
key_seq	pointer
)	O
char	O
*	O
key_seq	pointer
;	O
{	O
unsigned	O
char	O
*	O
ptr	pointer
;	O
keystr	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
ptr	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	pointer
;	O
*	O
ptr	pointer
;	O
ptr	pointer
++	O
)	O
{	O
if	O
(	O
ptr	pointer
!=	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	pointer
)	O
strcat	function
(	O
(	O
char	O
*	O
)	O
keystr	array
,	O
" "	pointer
)	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
key_ESC	int
)	O
strcat	function
(	O
(	O
char	O
*	O
)	O
keystr	array
,	O
"escape"	pointer
)	O
;	O
else	O
if	O
(	O
*	O
ptr	pointer
==	O
' '	O
)	O
strcat	function
(	O
(	O
char	O
*	O
)	O
keystr	array
,	O
"space"	pointer
)	O
;	O
else	O
if	O
(	O
*	O
ptr	pointer
==	O
key_BACKSPACE	int
)	O
strcat	function
(	O
(	O
char	O
*	O
)	O
keystr	array
,	O
"backspace"	pointer
)	O
;	O
else	O
if	O
(	O
*	O
ptr	pointer
==	O
key_CTRL_SPACE	int
)	O
strcat	function
(	O
(	O
char	O
*	O
)	O
keystr	array
,	O
"^space"	pointer
)	O
;	O
else	O
if	O
(	O
iscntrl	function
(	O
*	O
ptr	pointer
)	O
)	O
{	O
char	O
x	int
[	O
3	int
]	O
;	O
x	int
[	O
0	int
]	O
=	O
'^'	O
;	O
x	int
[	O
1	int
]	O
=	O
*	O
ptr	pointer
+	O
'A'	O
-	O
1	int
;	O
x	int
[	O
2	int
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
(	O
char	O
*	O
)	O
keystr	array
,	O
x	int
)	O
;	O
}	O
else	O
{	O
char	O
x	int
[	O
2	int
]	O
;	O
x	int
[	O
0	int
]	O
=	O
*	O
ptr	pointer
;	O
x	int
[	O
1	int
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
(	O
char	O
*	O
)	O
keystr	array
,	O
x	int
)	O
;	O
}	O
}	O
return	O
(	O
unsigned	O
char	O
*	O
)	O
keystr	array
;	O
}	O
void	O
tty_update	function
(	O
)	O
{	O
int	O
pos	int
,	O
x	int
,	O
y	int
;	O
int	O
tty_io_cursor_x	int
=	O
-	O
1	int
;	O
int	O
tty_io_cursor_y	int
=	O
-	O
1	int
;	O
int	O
last_pos	int
=	O
tty_columns	int
*	O
tty_lines	int
;	O
if	O
(	O
tty_last_char_flag	int
==	O
OFF	int
)	O
last_pos	int
--	O
;	O
tty_cursor	function
(	O
OFF	int
)	O
;	O
for	O
(	O
pos	int
=	O
0	int
;	O
pos	int
<	O
last_pos	int
;	O
pos	int
++	O
)	O
if	O
(	O
tty_scr	pointer
[	O
pos	int
]	O
!=	O
tty_prev_scr	pointer
[	O
pos	int
]	O
||	O
tty_atr	pointer
[	O
pos	int
]	O
!=	O
tty_prev_atr	pointer
[	O
pos	int
]	O
)	O
{	O
y	int
=	O
pos	int
/	O
tty_columns	int
;	O
x	int
=	O
pos	int
%	O
tty_columns	int
;	O
if	O
(	O
x	int
!=	O
tty_io_cursor_x	int
||	O
y	int
!=	O
tty_io_cursor_y	int
)	O
tty_io_goto	function
(	O
tty_io_cursor_y	int
=	O
y	int
,	O
tty_io_cursor_x	int
=	O
x	int
)	O
;	O
tty_io_colors	function
(	O
tty_atr	pointer
[	O
pos	int
]	O
)	O
;	O
tty_writec	function
(	O
tty_scr	pointer
[	O
pos	int
]	O
)	O
;	O
if	O
(	O
++	O
tty_io_cursor_x	int
==	O
tty_columns	int
)	O
{	O
tty_io_cursor_x	int
=	O
0	int
;	O
tty_io_cursor_y	int
=	O
-	O
1	int
;	O
}	O
}	O
tty_io_goto	function
(	O
tty_cursor_y	int
,	O
tty_cursor_x	int
)	O
;	O
tty_cursor	function
(	O
ON	int
)	O
;	O
if	O
(	O
tty_index	int
)	O
tty_flush	function
(	O
)	O
;	O
memcpy	function
(	O
tty_prev_scr	pointer
,	O
tty_scr	pointer
,	O
tty_columns	int
*	O
tty_lines	int
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
memcpy	function
(	O
tty_prev_atr	pointer
,	O
tty_atr	pointer
,	O
tty_columns	int
*	O
tty_lines	int
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
}	O
static	O
int	O
tty_writes	function
(	O
s	long
,	O
len	int
)	O
char	O
*	O
s	long
;	O
int	O
len	int
;	O
{	O
if	O
(	O
tty_index	int
+	O
len	int
>=	O
TTY_CACHE_SIZE	int
)	O
tty_flush	function
(	O
)	O
;	O
memcpy	function
(	O
tty_cache	array
+	O
tty_index	int
,	O
s	long
,	O
len	int
)	O
;	O
tty_index	int
+=	O
len	int
;	O
return	O
len	int
;	O
}	O
int	O
tty_puts	function
(	O
buf	pointer
,	O
length	int
)	O
char	O
*	O
buf	pointer
;	O
int	O
length	int
;	O
{	O
int	O
tty_offset	int
;	O
int	O
x	int
=	O
tty_cursor_x	int
;	O
tty_cursor_x	int
+=	O
length	int
;	O
if	O
(	O
x	int
>=	O
tty_columns	int
)	O
return	O
0	int
;	O
if	O
(	O
tty_cursor_y	int
>=	O
tty_lines	int
)	O
return	O
0	int
;	O
if	O
(	O
x	int
+	O
length	int
>	O
tty_columns	int
)	O
length	int
=	O
tty_columns	int
-	O
x	int
;	O
tty_offset	int
=	O
(	O
tty_cursor_y	int
*	O
tty_columns	int
)	O
+	O
x	int
;	O
memcpy	function
(	O
tty_scr	pointer
+	O
tty_offset	int
,	O
buf	pointer
,	O
length	int
)	O
;	O
memset	function
(	O
tty_atr	pointer
+	O
tty_offset	int
,	O
tty_current_attribute	char
,	O
length	int
)	O
;	O
return	O
length	int
;	O
}	O
int	O
tty_putc	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
char	O
character	char
=	O
c	int
;	O
return	O
tty_puts	function
(	O
&	O
character	char
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
}	O
int	O
tty_read	function
(	O
buf	pointer
,	O
length	int
)	O
char	O
*	O
buf	pointer
;	O
int	O
length	int
;	O
{	O
int	O
bytes	int
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
tty_enter_idle_hook	pointer
)	O
(	O
*	O
tty_enter_idle_hook	pointer
)	O
(	O
)	O
;	O
bytes	int
=	O
xread	function
(	O
TTY_INPUT	int
,	O
buf	pointer
,	O
length	int
)	O
;	O
if	O
(	O
tty_exit_idle_hook	pointer
)	O
(	O
*	O
tty_exit_idle_hook	pointer
)	O
(	O
)	O
;	O
return	O
bytes	int
;	O
}	O
void	O
tty_clear	function
(	O
)	O
{	O
tty_io_clear	function
(	O
)	O
;	O
memset	function
(	O
tty_scr	pointer
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
memset	function
(	O
tty_atr	pointer
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
memset	function
(	O
tty_prev_scr	pointer
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
memset	function
(	O
tty_prev_atr	pointer
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
tty_cursor_x	int
=	O
0	int
;	O
tty_cursor_y	int
=	O
0	int
;	O
}	O
void	O
tty_fill	function
(	O
)	O
{	O
memset	function
(	O
tty_scr	pointer
,	O
' '	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
memset	function
(	O
tty_atr	pointer
,	O
tty_current_attribute	char
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
tty_touch	function
(	O
)	O
;	O
}	O
void	O
tty_touch	function
(	O
)	O
{	O
memset	function
(	O
tty_prev_scr	pointer
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
}	O
static	O
void	O
tty_io_goto	function
(	O
y	int
,	O
x	int
)	O
int	O
y	int
,	O
x	int
;	O
{	O
if	O
(	O
TTY_MS_FLAG	O
==	O
0	int
)	O
tty_defaults	function
(	O
)	O
;	O
if	O
(	O
x	int
<	O
0	int
||	O
x	int
>=	O
tty_columns	int
||	O
y	int
<	O
0	int
||	O
y	int
>=	O
tty_lines	int
)	O
tputs	function
(	O
tgoto	function
(	O
TTY_CURSOR_MOVE	O
,	O
tty_columns	int
-	O
1	int
,	O
tty_lines	int
-	O
1	int
)	O
,	O
1	int
,	O
tty_writec	function
)	O
;	O
else	O
tputs	function
(	O
tgoto	function
(	O
TTY_CURSOR_MOVE	O
,	O
x	int
,	O
y	int
)	O
,	O
1	int
,	O
tty_writec	function
)	O
;	O
}	O
static	O
void	O
tty_io_foreground	function
(	O
color	int
)	O
int	O
color	int
;	O
{	O
char	O
str	pointer
[	O
16	int
]	O
;	O
if	O
(	O
fg_cache	int
==	O
VALID_CACHE	int
&&	O
color	int
==	O
TTY_IO_FOREGROUND	O
)	O
return	O
;	O
if	O
(	O
AnsiColors	int
==	O
ON	int
)	O
{	O
memcpy	function
(	O
str	pointer
,	O
ansi_foreground	array
,	O
sizeof	O
(	O
ansi_foreground	array
)	O
)	O
;	O
str	pointer
[	O
3	int
]	O
+=	O
color	int
;	O
tty_writes	function
(	O
str	pointer
,	O
sizeof	O
(	O
ansi_foreground	array
)	O
)	O
;	O
}	O
else	O
tty_io_reversevid	function
(	O
color	int
!=	O
WHITE	int
)	O
;	O
fg_cache	int
=	O
VALID_CACHE	int
;	O
TTY_IO_SET_FOREGROUND	O
(	O
color	int
)	O
;	O
}	O
static	O
void	O
tty_io_background	function
(	O
color	int
)	O
int	O
color	int
;	O
{	O
char	O
str	pointer
[	O
16	int
]	O
;	O
if	O
(	O
bg_cache	int
==	O
VALID_CACHE	int
&&	O
color	int
==	O
TTY_IO_BACKGROUND	O
)	O
return	O
;	O
if	O
(	O
AnsiColors	int
==	O
ON	int
)	O
{	O
memcpy	function
(	O
str	pointer
,	O
ansi_background	array
,	O
sizeof	O
(	O
ansi_background	array
)	O
)	O
;	O
str	pointer
[	O
3	int
]	O
+=	O
color	int
;	O
tty_writes	function
(	O
str	pointer
,	O
sizeof	O
(	O
ansi_background	array
)	O
)	O
;	O
}	O
else	O
tty_io_reversevid	function
(	O
color	int
!=	O
BLACK	int
)	O
;	O
bg_cache	int
=	O
VALID_CACHE	int
;	O
TTY_IO_SET_BACKGROUND	O
(	O
color	int
)	O
;	O
}	O
static	O
void	O
tty_io_brightness	function
(	O
status	int
)	O
int	O
status	int
;	O
{	O
if	O
(	O
br_cache	int
==	O
VALID_CACHE	int
&&	O
status	int
==	O
TTY_IO_BRIGHTNESS	O
)	O
return	O
;	O
if	O
(	O
status	int
==	O
ON	int
)	O
{	O
if	O
(	O
TTY_BRIGHT_ON	O
)	O
tputs	function
(	O
TTY_BRIGHT_ON	O
,	O
1	int
,	O
tty_writec	function
)	O
;	O
}	O
else	O
{	O
if	O
(	O
TTY_ATTRIBUTES_OFF	O
)	O
tputs	function
(	O
TTY_ATTRIBUTES_OFF	O
,	O
1	int
,	O
tty_writec	function
)	O
;	O
fg_cache	int
=	O
INVALID_CACHE	int
;	O
bg_cache	int
=	O
INVALID_CACHE	int
;	O
TTY_IO_SET_BRIGHTNESS	O
(	O
OFF	int
)	O
;	O
if	O
(	O
TTY_IO_REVERSEVID	O
==	O
ON	int
)	O
{	O
rv_cache	int
=	O
INVALID_CACHE	int
;	O
tty_io_reversevid	function
(	O
ON	int
)	O
;	O
}	O
}	O
br_cache	int
=	O
VALID_CACHE	int
;	O
TTY_IO_SET_BRIGHTNESS	O
(	O
status	int
)	O
;	O
}	O
static	O
void	O
tty_io_reversevid	function
(	O
status	int
)	O
int	O
status	int
;	O
{	O
if	O
(	O
rv_cache	int
==	O
VALID_CACHE	int
&&	O
status	int
==	O
TTY_IO_REVERSEVID	O
)	O
return	O
;	O
if	O
(	O
status	int
==	O
ON	int
)	O
{	O
if	O
(	O
TTY_REVERSE_ON	O
)	O
tputs	function
(	O
TTY_REVERSE_ON	O
,	O
1	int
,	O
tty_writec	function
)	O
;	O
}	O
else	O
{	O
if	O
(	O
TTY_ATTRIBUTES_OFF	O
)	O
tputs	function
(	O
TTY_ATTRIBUTES_OFF	O
,	O
1	int
,	O
tty_writec	function
)	O
;	O
fg_cache	int
=	O
INVALID_CACHE	int
;	O
bg_cache	int
=	O
INVALID_CACHE	int
;	O
TTY_IO_SET_REVERSEVID	O
(	O
OFF	int
)	O
;	O
if	O
(	O
TTY_IO_BRIGHTNESS	O
==	O
ON	int
)	O
{	O
br_cache	int
=	O
INVALID_CACHE	int
;	O
tty_io_brightness	function
(	O
ON	int
)	O
;	O
}	O
}	O
rv_cache	int
=	O
VALID_CACHE	int
;	O
TTY_IO_SET_REVERSEVID	O
(	O
status	int
)	O
;	O
}	O
static	O
void	O
tty_io_colors	function
(	O
attributes	int
)	O
int	O
attributes	int
;	O
{	O
tty_io_brightness	function
(	O
_TTY_BRIGHTNESS	O
(	O
attributes	int
)	O
)	O
;	O
tty_io_foreground	function
(	O
_TTY_FOREGROUND	O
(	O
attributes	int
)	O
)	O
;	O
tty_io_background	function
(	O
_TTY_BACKGROUND	O
(	O
attributes	int
)	O
)	O
;	O
}	O
void	O
tty_goto	function
(	O
y	int
,	O
x	int
)	O
int	O
y	int
,	O
x	int
;	O
{	O
tty_cursor_y	int
=	O
y	int
;	O
tty_cursor_x	int
=	O
x	int
;	O
}	O
void	O
tty_get_cursor	function
(	O
y	int
,	O
x	int
)	O
int	O
*	O
y	int
,	O
*	O
x	int
;	O
{	O
*	O
y	int
=	O
tty_cursor_y	int
;	O
*	O
x	int
=	O
tty_cursor_x	int
;	O
}	O
void	O
tty_foreground	function
(	O
color	int
)	O
int	O
color	int
;	O
{	O
TTY_SET_FOREGROUND	O
(	O
color	int
)	O
;	O
}	O
void	O
tty_background	function
(	O
color	int
)	O
int	O
color	int
;	O
{	O
TTY_SET_BACKGROUND	O
(	O
color	int
)	O
;	O
}	O
void	O
tty_brightness	function
(	O
status	int
)	O
int	O
status	int
;	O
{	O
TTY_SET_BRIGHTNESS	O
(	O
status	int
)	O
;	O
}	O
void	O
tty_reversevid	function
(	O
status	int
)	O
int	O
status	int
;	O
{	O
TTY_SET_REVERSEVID	O
(	O
status	int
)	O
;	O
}	O
void	O
tty_colors	function
(	O
brightness	int
,	O
foreground	int
,	O
background	int
)	O
int	O
brightness	int
,	O
foreground	int
,	O
background	int
;	O
{	O
tty_brightness	function
(	O
brightness	int
)	O
;	O
tty_foreground	function
(	O
foreground	int
)	O
;	O
tty_background	function
(	O
background	int
)	O
;	O
}	O
void	O
tty_beep	function
(	O
)	O
{	O
tty_writec	function
(	O
7	int
)	O
;	O
tty_flush	function
(	O
)	O
;	O
}	O
void	O
tty_cursor	function
(	O
status	int
)	O
int	O
status	int
;	O
{	O
if	O
(	O
status	int
)	O
{	O
if	O
(	O
TTY_CURSOR_ON	O
)	O
tputs	function
(	O
TTY_CURSOR_ON	O
,	O
1	int
,	O
tty_writec	function
)	O
;	O
}	O
else	O
{	O
if	O
(	O
TTY_CURSOR_OFF	O
)	O
tputs	function
(	O
TTY_CURSOR_OFF	O
,	O
1	int
,	O
tty_writec	function
)	O
;	O
}	O
}	O
void	O
tty_save	function
(	O
status	int
)	O
tty_status_t	char
*	O
status	int
;	O
{	O
*	O
status	int
=	O
tty_current_attribute	char
;	O
}	O
void	O
tty_restore	function
(	O
status	int
)	O
tty_status_t	char
*	O
status	int
;	O
{	O
tty_current_attribute	char
=	O
*	O
status	int
;	O
}	O
void	O
tty_defaults	function
(	O
)	O
{	O
if	O
(	O
AnsiColors	int
==	O
ON	int
)	O
tty_writes	function
(	O
ansi_defaults	array
,	O
sizeof	O
(	O
ansi_defaults	array
)	O
)	O
;	O
if	O
(	O
TTY_ATTRIBUTES_OFF	O
)	O
tputs	function
(	O
TTY_ATTRIBUTES_OFF	O
,	O
1	int
,	O
tty_writec	function
)	O
;	O
fg_cache	int
=	O
INVALID_CACHE	int
;	O
bg_cache	int
=	O
INVALID_CACHE	int
;	O
br_cache	int
=	O
INVALID_CACHE	int
;	O
rv_cache	int
=	O
INVALID_CACHE	int
;	O
}	O
static	O
int	O
tty_extract_key	function
(	O
)	O
{	O
int	O
key	int
=	O
keybuf	array
[	O
keyindex	int
]	O
;	O
if	O
(	O
key	int
&	O
0x80	int
)	O
{	O
keybuf	array
[	O
keyindex	int
]	O
&=	O
0x7F	int
;	O
return	O
key_ESC	int
;	O
}	O
keyno	int
--	O
;	O
keyindex	int
++	O
;	O
return	O
key	int
;	O
}	O
int	O
tty_getc	function
(	O
)	O
{	O
service_pending_signals	function
(	O
)	O
;	O
if	O
(	O
keyno	int
)	O
return	O
tty_extract_key	function
(	O
)	O
;	O
tty_set_interrupt_char	function
(	O
-	O
1	int
)	O
;	O
signals	function
(	O
ON	int
)	O
;	O
keyindex	int
=	O
0	int
;	O
while	O
(	O
(	O
keyno	int
=	O
tty_read	function
(	O
keybuf	array
,	O
1024	int
)	O
)	O
<	O
0	int
)	O
;	O
signals	function
(	O
OFF	int
)	O
;	O
tty_set_interrupt_char	function
(	O
key_INTERRUPT	O
)	O
;	O
return	O
keyno	int
?	O
tty_extract_key	function
(	O
)	O
:	O
-	O
1	int
;	O
}	O
void	O
tty_key_list_insert_sequence	function
(	O
key	int
,	O
key_seq	pointer
,	O
aux_data	pointer
)	O
tty_key_t	struct
*	O
*	O
key	int
;	O
unsigned	O
char	O
*	O
key_seq	pointer
;	O
void	O
*	O
aux_data	pointer
;	O
{	O
tty_key_t	struct
*	O
new_key	pointer
;	O
new_key	pointer
=	O
(	O
tty_key_t	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
tty_key_t	struct
)	O
)	O
;	O
new_key	pointer
->	O
key_seq	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
xstrdup	function
(	O
(	O
char	O
*	O
)	O
key_seq	pointer
)	O
;	O
new_key	pointer
->	O
aux_data	pointer
=	O
aux_data	pointer
;	O
new_key	pointer
->	O
next	pointer
=	O
*	O
key	int
;	O
*	O
key	int
=	O
new_key	pointer
;	O
}	O
void	O
tty_key_list_insert	function
(	O
key_seq	pointer
,	O
aux_data	pointer
)	O
unsigned	O
char	O
*	O
key_seq	pointer
;	O
void	O
*	O
aux_data	pointer
;	O
{	O
static	O
tty_key_t	struct
*	O
*	O
key	int
=	O
NULL	O
;	O
if	O
(	O
*	O
key_seq	pointer
==	O
0	int
)	O
return	O
;	O
if	O
(	O
key	int
==	O
NULL	O
||	O
strcmp	function
(	O
(	O
char	O
*	O
)	O
key_seq	pointer
,	O
(	O
char	O
*	O
)	O
(	O
*	O
key	int
)	O
->	O
key_seq	pointer
)	O
<=	O
0	int
)	O
key	int
=	O
&	O
key_list_head	pointer
;	O
for	O
(	O
;	O
*	O
key	int
;	O
key	int
=	O
&	O
(	O
*	O
key	int
)	O
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
(	O
char	O
*	O
)	O
key_seq	pointer
,	O
(	O
char	O
*	O
)	O
(	O
*	O
key	int
)	O
->	O
key_seq	pointer
)	O
<=	O
0	int
)	O
{	O
tty_key_list_insert_sequence	function
(	O
key	int
,	O
key_seq	pointer
,	O
aux_data	pointer
)	O
;	O
return	O
;	O
}	O
tty_key_list_insert_sequence	function
(	O
key	int
,	O
key_seq	pointer
,	O
aux_data	pointer
)	O
;	O
}	O
void	O
tty_key_search_restart	function
(	O
)	O
{	O
current_key	pointer
=	O
key_list_head	pointer
;	O
}	O
tty_key_t	struct
*	O
tty_key_search	function
(	O
key_seq	pointer
)	O
char	O
*	O
key_seq	pointer
;	O
{	O
int	O
cmp	int
;	O
if	O
(	O
current_key	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
for	O
(	O
;	O
current_key	pointer
;	O
current_key	pointer
=	O
current_key	pointer
->	O
next	pointer
)	O
{	O
cmp	int
=	O
strcmp	function
(	O
key_seq	pointer
,	O
(	O
char	O
*	O
)	O
current_key	pointer
->	O
key_seq	pointer
)	O
;	O
if	O
(	O
cmp	int
==	O
0	int
)	O
return	O
current_key	pointer
;	O
if	O
(	O
cmp	int
<	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
current_key	pointer
==	O
NULL	O
||	O
strncmp	function
(	O
key_seq	pointer
,	O
(	O
char	O
*	O
)	O
current_key	pointer
->	O
key_seq	pointer
,	O
strlen	function
(	O
key_seq	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
tty_key_t	struct
*	O
)	O
-	O
1	int
;	O
else	O
return	O
NULL	O
;	O
}	O
void	O
tty_key_print	function
(	O
key_seq	pointer
)	O
char	O
*	O
key_seq	pointer
;	O
{	O
tty_status_t	char
tty_status	char
;	O
char	O
*	O
typed	pointer
=	O
"Keys typed so far: "	pointer
;	O
char	O
*	O
incomplete	pointer
=	O
" "	pointer
;	O
char	O
*	O
spaces	pointer
;	O
tty_save	function
(	O
&	O
tty_status	char
)	O
;	O
tty_goto	function
(	O
tty_lines	int
-	O
1	int
,	O
0	int
)	O
;	O
tty_background	function
(	O
WHITE	int
)	O
;	O
tty_foreground	function
(	O
BLACK	int
)	O
;	O
spaces	pointer
=	O
xmalloc	function
(	O
tty_columns	int
+	O
1	int
)	O
;	O
memset	function
(	O
spaces	pointer
,	O
' '	O
,	O
tty_columns	int
)	O
;	O
spaces	pointer
[	O
tty_columns	int
]	O
=	O
'\0'	O
;	O
tty_puts	function
(	O
spaces	pointer
,	O
tty_columns	int
)	O
;	O
xfree	function
(	O
spaces	pointer
)	O
;	O
tty_goto	function
(	O
tty_lines	int
-	O
1	int
,	O
0	int
)	O
;	O
tty_key_machine2human	function
(	O
key_seq	pointer
)	O
;	O
tty_puts	function
(	O
typed	pointer
,	O
strlen	function
(	O
typed	pointer
)	O
)	O
;	O
tty_puts	function
(	O
(	O
char	O
*	O
)	O
keystr	array
,	O
strlen	function
(	O
(	O
char	O
*	O
)	O
keystr	array
)	O
)	O
;	O
tty_puts	function
(	O
incomplete	pointer
,	O
strlen	function
(	O
incomplete	pointer
)	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
tty_restore	function
(	O
&	O
tty_status	char
)	O
;	O
}	O
tty_key_t	struct
*	O
tty_get_key	function
(	O
repeat_count	pointer
)	O
int	O
*	O
repeat_count	pointer
;	O
{	O
int	O
i	int
,	O
c	int
;	O
tty_key_t	struct
*	O
key	int
=	O
NULL	O
;	O
while	O
(	O
(	O
c	int
=	O
tty_getc	function
(	O
)	O
)	O
==	O
-	O
1	int
)	O
;	O
if	O
(	O
repeat_count	pointer
)	O
*	O
repeat_count	pointer
=	O
1	int
;	O
if	O
(	O
c	int
==	O
0	int
)	O
c	int
=	O
0xff	int
;	O
if	O
(	O
tty_kbdmode	int
==	O
TTY_RESTRICTED_INPUT	int
)	O
{	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
c	int
==	O
'\r'	O
)	O
c	int
=	O
key_ENTER	int
;	O
if	O
(	O
isprint	function
(	O
c	int
)	O
||	O
c	int
==	O
key_INTERRUPT	O
)	O
{	O
default_key	struct
.	O
key_seq	pointer
[	O
0	int
]	O
=	O
c	int
;	O
default_key	struct
.	O
key_seq	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
&	O
default_key	struct
;	O
}	O
}	O
partial	int
=	O
0	int
;	O
key_on_display	int
=	O
0	int
;	O
tty_key_search_restart	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_KEY_LENGTH	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
c	int
==	O
0	int
)	O
c	int
=	O
0xff	int
;	O
tty_key_seq	pointer
[	O
i	int
]	O
=	O
c	int
;	O
tty_key_seq	pointer
[	O
i	int
+	O
1	int
]	O
=	O
0	int
;	O
key	int
=	O
tty_key_search	function
(	O
(	O
char	O
*	O
)	O
tty_key_seq	pointer
)	O
;	O
if	O
(	O
key	int
==	O
(	O
tty_key_t	struct
*	O
)	O
-	O
1	int
)	O
{	O
alarm	function
(	O
1	int
)	O
;	O
partial	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
key	int
)	O
{	O
if	O
(	O
partial	int
)	O
{	O
}	O
break	O
;	O
}	O
if	O
(	O
keyno	int
==	O
0	int
)	O
{	O
if	O
(	O
key_on_display	int
)	O
tty_key_print	function
(	O
(	O
char	O
*	O
)	O
tty_key_seq	pointer
)	O
;	O
else	O
alarm	function
(	O
1	int
)	O
;	O
partial	int
=	O
1	int
;	O
}	O
while	O
(	O
(	O
c	int
=	O
tty_getc	function
(	O
)	O
)	O
==	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
i	int
==	O
MAX_KEY_LENGTH	int
)	O
{	O
alarm	function
(	O
1	int
)	O
;	O
partial	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
repeat_count	pointer
)	O
while	O
(	O
keyno	int
>	O
i	int
&&	O
(	O
memcmp	function
(	O
tty_key_seq	pointer
,	O
&	O
keybuf	array
[	O
keyindex	int
]	O
,	O
i	int
+	O
1	int
)	O
==	O
0	int
)	O
)	O
{	O
keyindex	int
+=	O
i	int
+	O
1	int
;	O
keyno	int
-=	O
i	int
+	O
1	int
;	O
(	O
*	O
repeat_count	pointer
)	O
++	O
;	O
}	O
alarm	function
(	O
1	int
)	O
;	O
partial	int
=	O
0	int
;	O
return	O
key	int
;	O
}	O
void	O
tty_key_print_async	function
(	O
)	O
{	O
if	O
(	O
partial	int
)	O
{	O
tty_key_print	function
(	O
(	O
char	O
*	O
)	O
tty_key_seq	pointer
)	O
;	O
key_on_display	int
=	O
1	int
;	O
}	O
}	O
char	O
*	O
tty_get_previous_key_seq	function
(	O
)	O
{	O
return	O
(	O
char	O
*	O
)	O
tty_key_seq	pointer
;	O
}	O
void	O
tty_resize	function
(	O
)	O
{	O
char	O
*	O
env	pointer
;	O
char	O
buf	pointer
[	O
32	int
]	O
;	O
int	O
shell_lines	int
=	O
0	int
,	O
shell_columns	int
=	O
0	int
;	O
int	O
termcap_lines	int
=	O
0	int
,	O
termcap_columns	int
=	O
0	int
;	O
struct	O
winsize	struct
winsz	struct
;	O
int	O
winsz_lines	int
=	O
0	int
,	O
winsz_columns	int
=	O
0	int
;	O
if	O
(	O
ioctl	function
(	O
TTY_OUTPUT	int
,	O
TIOCGWINSZ	int
,	O
&	O
winsz	struct
)	O
==	O
0	int
)	O
if	O
(	O
winsz	struct
.	O
ws_col	short
&&	O
winsz	struct
.	O
ws_row	short
)	O
{	O
winsz_columns	int
=	O
winsz	struct
.	O
ws_col	short
;	O
winsz_lines	int
=	O
winsz	struct
.	O
ws_row	short
;	O
}	O
if	O
(	O
(	O
env	pointer
=	O
getenv	function
(	O
"COLUMNS"	pointer
)	O
)	O
)	O
sscanf	function
(	O
env	pointer
,	O
"%d"	pointer
,	O
&	O
shell_columns	int
)	O
;	O
if	O
(	O
(	O
env	pointer
=	O
getenv	function
(	O
"LINES"	pointer
)	O
)	O
)	O
sscanf	function
(	O
env	pointer
,	O
"%d"	pointer
,	O
&	O
shell_lines	int
)	O
;	O
termcap_columns	int
=	O
TTY_COLUMNS	O
;	O
termcap_lines	int
=	O
TTY_LINES	O
;	O
if	O
(	O
columns_ok	O
(	O
winsz_columns	int
)	O
)	O
tty_columns	int
=	O
winsz_columns	int
;	O
else	O
{	O
if	O
(	O
columns_ok	O
(	O
shell_columns	int
)	O
)	O
tty_columns	int
=	O
shell_columns	int
;	O
else	O
if	O
(	O
columns_ok	O
(	O
termcap_columns	int
)	O
)	O
tty_columns	int
=	O
termcap_columns	int
;	O
else	O
tty_columns	int
=	O
80	int
;	O
}	O
if	O
(	O
lines_ok	O
(	O
winsz_lines	int
)	O
)	O
tty_lines	int
=	O
winsz_lines	int
;	O
else	O
{	O
if	O
(	O
lines_ok	O
(	O
shell_lines	int
)	O
)	O
tty_lines	int
=	O
shell_lines	int
;	O
else	O
if	O
(	O
lines_ok	O
(	O
termcap_lines	int
)	O
)	O
tty_lines	int
=	O
termcap_lines	int
;	O
else	O
tty_lines	int
=	O
24	int
;	O
}	O
assert	O
(	O
tty_lines	int
!=	O
0	int
)	O
;	O
assert	O
(	O
tty_columns	int
!=	O
0	int
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%d"	pointer
,	O
tty_lines	int
)	O
;	O
xsetenv	function
(	O
"LINES"	pointer
,	O
buf	pointer
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%d"	pointer
,	O
tty_columns	int
)	O
;	O
xsetenv	function
(	O
"COLUMNS"	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
tty_scr	pointer
)	O
xfree	function
(	O
tty_scr	pointer
)	O
;	O
if	O
(	O
tty_atr	pointer
)	O
xfree	function
(	O
tty_atr	pointer
)	O
;	O
if	O
(	O
tty_prev_scr	pointer
)	O
xfree	function
(	O
tty_prev_scr	pointer
)	O
;	O
if	O
(	O
tty_prev_atr	pointer
)	O
xfree	function
(	O
tty_prev_atr	pointer
)	O
;	O
tty_scr	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
xcalloc	function
(	O
tty_columns	int
*	O
tty_lines	int
,	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
tty_atr	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
xcalloc	function
(	O
tty_columns	int
*	O
tty_lines	int
,	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
tty_prev_scr	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
xcalloc	function
(	O
tty_columns	int
*	O
tty_lines	int
,	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
tty_prev_atr	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
xcalloc	function
(	O
tty_columns	int
*	O
tty_lines	int
,	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
}	O
int	O
vcs_io	function
(	O
buf	pointer
,	O
op	int
)	O
char	O
*	O
buf	pointer
;	O
int	O
op	int
;	O
{	O
ssize_t	long
(	O
*	O
fn	pointer
)	O
(	O
)	O
;	O
int	O
vcsfd	int
,	O
flag	int
;	O
char	O
vcs_name	array
[	O
16	int
]	O
;	O
char	O
vcsa_name	array
[	O
16	int
]	O
;	O
strcpy	function
(	O
vcs_name	array
,	O
"/dev/vcsXX"	pointer
)	O
;	O
strcpy	function
(	O
vcsa_name	array
,	O
"/dev/vcsaXX"	pointer
)	O
;	O
if	O
(	O
op	int
==	O
VCS_READ	int
)	O
{	O
flag	int
=	O
O_RDONLY	int
;	O
fn	pointer
=	O
read	pointer
;	O
}	O
else	O
{	O
flag	int
=	O
O_WRONLY	int
;	O
fn	pointer
=	O
write	pointer
;	O
if	O
(	O
vcs_is_monochrome	int
)	O
goto	O
monochrome	O
;	O
}	O
vcs_is_monochrome	int
=	O
0	int
;	O
vcsa_name	array
[	O
9	int
]	O
=	O
tty_device	pointer
[	O
8	int
]	O
;	O
vcsa_name	array
[	O
10	int
]	O
=	O
tty_device	pointer
[	O
9	int
]	O
;	O
vcsfd	int
=	O
open	function
(	O
vcsa_name	array
,	O
flag	int
)	O
;	O
if	O
(	O
vcsfd	int
!=	O
-	O
1	int
)	O
{	O
vcsa_label	O
:	O
(	O
*	O
fn	pointer
)	O
(	O
vcsfd	int
,	O
buf	pointer
,	O
4	int
+	O
tty_lines	int
*	O
tty_columns	int
*	O
2	int
)	O
;	O
close	pointer
(	O
vcsfd	int
)	O
;	O
if	O
(	O
op	int
==	O
VCS_WRITE	int
)	O
{	O
tty_io_goto	function
(	O
buf	pointer
[	O
3	int
]	O
,	O
buf	pointer
[	O
2	int
]	O
)	O
;	O
tty_flush	function
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
vcsa_name	array
[	O
9	int
]	O
=	O
'0'	O
;	O
vcsa_name	array
[	O
10	int
]	O
=	O
'\0'	O
;	O
vcsfd	int
=	O
open	function
(	O
vcsa_name	array
,	O
flag	int
)	O
;	O
if	O
(	O
vcsfd	int
!=	O
-	O
1	int
)	O
goto	O
vcsa_label	O
;	O
monochrome	O
:	O
vcs_is_monochrome	int
=	O
1	int
;	O
if	O
(	O
op	int
==	O
VCS_WRITE	int
)	O
tty_clear	function
(	O
)	O
;	O
vcs_name	array
[	O
8	int
]	O
=	O
tty_device	pointer
[	O
8	int
]	O
;	O
vcs_name	array
[	O
9	int
]	O
=	O
tty_device	pointer
[	O
9	int
]	O
;	O
vcsfd	int
=	O
open	function
(	O
vcs_name	array
,	O
flag	int
)	O
;	O
if	O
(	O
vcsfd	int
!=	O
-	O
1	int
)	O
{	O
vcs_label	O
:	O
(	O
*	O
fn	pointer
)	O
(	O
vcsfd	int
,	O
buf	pointer
,	O
4	int
+	O
tty_lines	int
*	O
tty_columns	int
)	O
;	O
close	pointer
(	O
vcsfd	int
)	O
;	O
if	O
(	O
op	int
==	O
VCS_WRITE	int
)	O
{	O
tty_io_goto	function
(	O
tty_lines	int
-	O
1	int
,	O
0	int
)	O
;	O
tty_flush	function
(	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
vcs_name	array
[	O
8	int
]	O
=	O
'0'	O
;	O
vcs_name	array
[	O
9	int
]	O
=	O
'\0'	O
;	O
vcsfd	int
=	O
open	function
(	O
vcs_name	array
,	O
flag	int
)	O
;	O
if	O
(	O
vcsfd	int
!=	O
-	O
1	int
)	O
goto	O
vcs_label	O
;	O
return	O
0	int
;	O
}	O
void	O
tty_get_screen	function
(	O
buf	pointer
)	O
char	O
*	O
buf	pointer
;	O
{	O
if	O
(	O
LinuxConsole	int
)	O
vcs_read_ok	int
=	O
vcs_io	function
(	O
buf	pointer
,	O
VCS_READ	int
)	O
;	O
}	O
void	O
tty_put_screen	function
(	O
buf	pointer
)	O
char	O
*	O
buf	pointer
;	O
{	O
tty_defaults	function
(	O
)	O
;	O
if	O
(	O
LinuxConsole	int
)	O
{	O
if	O
(	O
vcs_read_ok	int
)	O
{	O
tty_touch	function
(	O
)	O
;	O
if	O
(	O
vcs_io	function
(	O
buf	pointer
,	O
VCS_WRITE	int
)	O
==	O
0	int
)	O
tty_clear	function
(	O
)	O
;	O
else	O
memset	function
(	O
tty_scr	pointer
,	O
'\0'	O
,	O
tty_lines	int
*	O
tty_columns	int
*	O
sizeof	O
(	O
unsigned	O
char	O
)	O
)	O
;	O
}	O
else	O
tty_clear	function
(	O
)	O
;	O
}	O
else	O
tty_clear	function
(	O
)	O
;	O
}	O
int	O
tty_get_color_index	function
(	O
colorname	pointer
)	O
char	O
*	O
colorname	pointer
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
10	int
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
colors	array
[	O
i	int
]	O
,	O
colorname	pointer
)	O
==	O
0	int
)	O
return	O
(	O
i	int
<	O
8	int
)	O
?	O
i	int
:	O
(	O
i	int
-	O
8	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
char	O
*	O
tty_get_symbol_key_seq	function
(	O
symbol	pointer
)	O
char	O
*	O
symbol	pointer
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
TTY_FIRST_SYMBOL_KEY	int
;	O
i	int
<	O
TTY_CAPABILITIES_USED	int
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
tty_capability	array
[	O
i	int
]	O
.	O
symbol	pointer
,	O
symbol	pointer
)	O
==	O
0	int
)	O
return	O
tty_capability	array
[	O
i	int
]	O
.	O
string	pointer
;	O
return	O
NULL	O
;	O
}	O
void	O
tty_get_capabilities	function
(	O
)	O
{	O
struct	O
stat	struct
statbuf	struct
;	O
char	O
*	O
capability_buf	pointer
,	O
*	O
tmp	pointer
;	O
int	O
err	long
,	O
i	int
,	O
term_errors	int
=	O
0	int
;	O
char	O
*	O
termtype	pointer
=	O
getenv	function
(	O
"TERM"	pointer
)	O
;	O
fstat	function
(	O
TTY_OUTPUT	int
,	O
&	O
statbuf	struct
)	O
;	O
if	O
(	O
(	O
statbuf	struct
.	O
st_rdev	long
>>	O
8	int
)	O
==	O
LINUX_VC_MAJOR	int
)	O
LinuxConsole	int
=	O
1	int
;	O
else	O
LinuxConsole	int
=	O
0	int
;	O
if	O
(	O
termtype	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: can't find the TERM environment variable, "	pointer
,	O
g_program	pointer
)	O
;	O
goto	O
switch_to_vt100	O
;	O
}	O
if	O
(	O
strlen	function
(	O
termtype	pointer
)	O
>	O
63	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: the TERM environment variable is too long, "	pointer
,	O
g_program	pointer
)	O
;	O
switch_to_vt100	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"trying vt100 ...\n"	pointer
)	O
;	O
termtype	pointer
=	O
vt100	array
;	O
}	O
retry	O
:	O
err	long
=	O
tgetent	function
(	O
NULL	O
,	O
termtype	pointer
)	O
;	O
if	O
(	O
err	long
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: can't find the %s database.\n"	pointer
,	O
g_program	pointer
,	O
term_database	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: check your %s environment variable ...\n"	pointer
,	O
g_program	pointer
,	O
term_env	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
err	long
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: can't find the terminal type %s in the %s database.\n"	pointer
,	O
g_program	pointer
,	O
termtype	pointer
,	O
term_database	array
)	O
;	O
if	O
(	O
strcmp	function
(	O
termtype	pointer
,	O
"iris-ansi"	pointer
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: trying ansi...\n"	pointer
,	O
g_program	pointer
)	O
;	O
termtype	pointer
=	O
"ansi"	pointer
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
tty_is_xterm	function
(	O
termtype	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: trying xterm...\n"	pointer
,	O
g_program	pointer
)	O
;	O
termtype	pointer
=	O
"xterm"	pointer
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
termtype	pointer
,	O
"vt220"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
termtype	pointer
,	O
"vt320"	pointer
)	O
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: trying vt100...\n"	pointer
,	O
g_program	pointer
)	O
;	O
termtype	pointer
=	O
"ansi"	pointer
;	O
goto	O
retry	O
;	O
}	O
exit	function
(	O
1	int
)	O
;	O
}	O
tty_type	pointer
=	O
xstrdup	function
(	O
termtype	pointer
)	O
;	O
capability_buf	pointer
=	O
xmalloc	function
(	O
2048	int
)	O
;	O
tmp	pointer
=	O
tgetstr	function
(	O
TTY_PAD_CHAR_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
PC	char
=	O
tmp	pointer
?	O
*	O
tmp	pointer
:	O
0	int
;	O
BC	pointer
=	O
tgetstr	function
(	O
TTY_LEFT_ONE_SPACE_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
UP	pointer
=	O
tgetstr	function
(	O
TTY_UP_ONE_LINE_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
if	O
(	O
BC	pointer
==	O
NULL	O
||	O
UP	pointer
==	O
NULL	O
)	O
BC	pointer
=	O
UP	pointer
=	O
NULL	O
;	O
TTY_ATTRIBUTES_OFF	O
=	O
tgetstr	function
(	O
TTY_ATTRIBUTES_OFF_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
TTY_BRIGHT_ON	O
=	O
tgetstr	function
(	O
TTY_BRIGHT_ON_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
TTY_REVERSE_ON	O
=	O
tgetstr	function
(	O
TTY_REVERSE_ON_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
if	O
(	O
TTY_ATTRIBUTES_OFF	O
==	O
NULL	O
)	O
TTY_REVERSE_ON	O
=	O
TTY_BRIGHT_ON	O
=	O
NULL	O
;	O
TTY_STANDOUT_ON	O
=	O
tgetstr	function
(	O
TTY_STANDOUT_ON_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
if	O
(	O
TTY_STANDOUT_ON	O
==	O
NULL	O
)	O
{	O
TTY_STANDOUT_ON	O
=	O
NULL	O
;	O
TTY_MS_FLAG	O
=	O
0	int
;	O
}	O
else	O
{	O
TTY_REVERSE_ON	O
=	O
TTY_STANDOUT_ON	O
;	O
TTY_MS_FLAG	O
=	O
tgetflag	function
(	O
TTY_MS_FLAG_NAME	O
)	O
;	O
}	O
TTY_MAGIC_COOKIE	O
=	O
tgetnum	function
(	O
TTY_MAGIC_COOKIE_NAME	O
)	O
;	O
if	O
(	O
TTY_MAGIC_COOKIE	O
>=	O
0	int
)	O
TTY_ATTRIBUTES_OFF	O
=	O
TTY_REVERSE_ON	O
=	O
TTY_BRIGHT_ON	O
=	O
NULL	O
;	O
TTY_COLUMNS	O
=	O
tgetnum	function
(	O
TTY_COLUMNS_NAME	O
)	O
;	O
TTY_LINES	O
=	O
tgetnum	function
(	O
TTY_LINES_NAME	O
)	O
;	O
TTY_CURSOR_OFF	O
=	O
tgetstr	function
(	O
TTY_CURSOR_OFF_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
TTY_CURSOR_ON	O
=	O
tgetstr	function
(	O
TTY_CURSOR_ON_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
if	O
(	O
TTY_CURSOR_OFF	O
==	O
NULL	O
||	O
TTY_CURSOR_ON	O
==	O
NULL	O
)	O
TTY_CURSOR_ON	O
=	O
TTY_CURSOR_OFF	O
=	O
NULL	O
;	O
TTY_CLEAR_SCREEN	O
=	O
tgetstr	function
(	O
TTY_CLEAR_SCREEN_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
TTY_CURSOR_MOVE	O
=	O
tgetstr	function
(	O
TTY_CURSOR_MOVE_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
TTY_START_CURSORAPP	O
=	O
tgetstr	function
(	O
TTY_START_CURSORAPP_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
TTY_END_CURSORAPP	O
=	O
tgetstr	function
(	O
TTY_END_CURSORAPP_NAME	O
,	O
&	O
capability_buf	pointer
)	O
;	O
for	O
(	O
i	int
=	O
TTY_FIRST_SYMBOL_KEY	int
;	O
i	int
<	O
TTY_CAPABILITIES_USED	int
;	O
i	int
++	O
)	O
tty_capability	array
[	O
i	int
]	O
.	O
string	pointer
=	O
tgetstr	function
(	O
tty_capability	array
[	O
i	int
]	O
.	O
name	pointer
,	O
&	O
capability_buf	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
TTY_CAPABILITIES_USED	int
;	O
i	int
++	O
)	O
if	O
(	O
tty_capability	array
[	O
i	int
]	O
.	O
string	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
tty_capability	array
[	O
i	int
]	O
.	O
required	int
)	O
{	O
term_errors	int
++	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: can't find the '%s' terminal capability.\n"	pointer
,	O
g_program	pointer
,	O
tty_capability	array
[	O
i	int
]	O
.	O
name	pointer
)	O
;	O
}	O
else	O
{	O
tty_capability	array
[	O
i	int
]	O
.	O
string	pointer
=	O
""	pointer
;	O
}	O
}	O
if	O
(	O
term_errors	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %d errors. Your terminal is too dumb :-< .\n"	pointer
,	O
g_program	pointer
,	O
term_errors	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
tty_init	function
(	O
kbd_mode	int
)	O
int	O
kbd_mode	int
;	O
{	O
if	O
(	O
!	O
isatty	function
(	O
TTY_INPUT	int
)	O
||	O
!	O
isatty	function
(	O
TTY_OUTPUT	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: only stderr can be redirected.\n"	pointer
,	O
g_program	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
tty_device	pointer
=	O
ttyname	function
(	O
1	int
)	O
)	O
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: can't get terminal name.\n"	pointer
,	O
g_program	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
tcgetattr	function
(	O
TTY_OUTPUT	int
,	O
&	O
old_term	struct
)	O
;	O
default_key	struct
.	O
key_seq	pointer
=	O
tty_key_seq	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
xmalloc	function
(	O
64	int
)	O
;	O
default_key	struct
.	O
aux_data	pointer
=	O
NULL	O
;	O
default_key	struct
.	O
next	pointer
=	O
NULL	O
;	O
tty_kbdmode	int
=	O
kbd_mode	int
;	O
tty_device_length	int
=	O
strlen	function
(	O
tty_device	pointer
)	O
;	O
tty_get_capabilities	function
(	O
)	O
;	O
}	O
void	O
tty_update_title	function
(	O
string	pointer
)	O
char	O
*	O
string	pointer
;	O
{	O
if	O
(	O
tty_is_xterm	function
(	O
tty_type	pointer
)	O
)	O
{	O
size_t	long
len	int
=	O
strlen	function
(	O
string	pointer
)	O
;	O
char	O
*	O
temp	pointer
=	O
xmalloc	function
(	O
128	int
+	O
len	int
+	O
1	int
)	O
;	O
char	O
*	O
printable_string	pointer
=	O
xstrdup	function
(	O
string	pointer
)	O
;	O
toprintable	function
(	O
printable_string	pointer
,	O
len	int
)	O
;	O
sprintf	function
(	O
temp	pointer
,	O
"%c]2;%s - %s%c"	pointer
,	O
0x1b	int
,	O
PRODUCT	pointer
,	O
printable_string	pointer
,	O
0x07	int
)	O
;	O
if	O
(	O
128	int
+	O
(	O
int	O
)	O
len	int
>	O
2	int
*	O
tty_columns	int
)	O
{	O
temp	pointer
[	O
2	int
*	O
tty_columns	int
]	O
=	O
0x07	int
;	O
temp	pointer
[	O
2	int
*	O
tty_columns	int
+	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
xwrite	function
(	O
TTY_OUTPUT	int
,	O
temp	pointer
,	O
strlen	function
(	O
temp	pointer
)	O
)	O
;	O
xfree	function
(	O
printable_string	pointer
)	O
;	O
xfree	function
(	O
temp	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
}	O
static	O
int	O
tty_is_xterm	function
(	O
term	pointer
)	O
char	O
*	O
term	pointer
;	O
{	O
if	O
(	O
strncmp	function
(	O
term	pointer
,	O
"xterm"	pointer
,	O
5	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
term	pointer
,	O
"rxvt"	pointer
,	O
4	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
term	pointer
,	O
"iris-ansi"	pointer
,	O
9	int
)	O
==	O
0	int
||	O
strcmp	function
(	O
term	pointer
,	O
"aixterm"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
term	pointer
,	O
"Eterm"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
term	pointer
,	O
"dtterm"	pointer
)	O
==	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
