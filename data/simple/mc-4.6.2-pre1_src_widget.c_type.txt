struct	O
WButtonBar	struct
{	O
Widget	struct
widget	pointer
;	O
int	O
visible	int
;	O
struct	O
{	O
char	O
*	O
text	pointer
;	O
enum	O
{	O
BBFUNC_NONE	int
,	O
BBFUNC_VOID	int
,	O
BBFUNC_PTR	int
}	O
tag	int
;	O
union	O
{	O
voidfn	pointer
fn_void	pointer
;	O
buttonbarfn	pointer
fn_ptr	pointer
;	O
}	O
u	union
;	O
void	O
*	O
data	pointer
;	O
}	O
labels	array
[	O
10	int
]	O
;	O
}	O
;	O
static	O
int	O
button_event	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
)	O
;	O
int	O
quote	int
=	O
0	int
;	O
static	O
void	O
widget_selectcolor	function
(	O
Widget	struct
*	O
w	pointer
,	O
gboolean	int
focused	int
,	O
gboolean	int
hotkey	int
)	O
{	O
Dlg_head	struct
*	O
h	pointer
=	O
w	pointer
->	O
parent	pointer
;	O
attrset	function
(	O
hotkey	int
?	O
(	O
focused	int
?	O
DLG_HOT_FOCUSC	O
(	O
h	pointer
)	O
:	O
DLG_HOT_NORMALC	O
(	O
h	pointer
)	O
)	O
:	O
(	O
focused	int
?	O
DLG_FOCUSC	O
(	O
h	pointer
)	O
:	O
DLG_NORMALC	O
(	O
h	pointer
)	O
)	O
)	O
;	O
}	O
static	O
cb_ret_t	enum
button_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
WButton	struct
*	O
b	pointer
=	O
(	O
WButton	struct
*	O
)	O
w	pointer
;	O
char	O
buf	pointer
[	O
BUF_SMALL	int
]	O
;	O
int	O
stop	int
=	O
0	int
;	O
int	O
off	int
=	O
0	int
;	O
Dlg_head	struct
*	O
h	pointer
=	O
b	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
WIDGET_HOTKEY	int
:	O
if	O
(	O
parm	int
==	O
'\n'	O
&&	O
h	pointer
->	O
current	pointer
==	O
&	O
b	pointer
->	O
widget	pointer
)	O
{	O
button_callback	function
(	O
w	pointer
,	O
WIDGET_KEY	int
,	O
' '	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
parm	int
==	O
'\n'	O
&&	O
b	pointer
->	O
flags	enum
==	O
DEFPUSH_BUTTON	int
)	O
{	O
button_callback	function
(	O
w	pointer
,	O
WIDGET_KEY	int
,	O
' '	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
b	pointer
->	O
hotkey	int
==	O
tolower	function
(	O
parm	int
)	O
)	O
{	O
button_callback	function
(	O
w	pointer
,	O
WIDGET_KEY	int
,	O
' '	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
WIDGET_KEY	int
:	O
if	O
(	O
parm	int
!=	O
' '	O
&&	O
parm	int
!=	O
'\n'	O
)	O
return	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
b	pointer
->	O
callback	pointer
)	O
stop	int
=	O
(	O
*	O
b	pointer
->	O
callback	pointer
)	O
(	O
b	pointer
->	O
action	int
)	O
;	O
if	O
(	O
!	O
b	pointer
->	O
callback	pointer
||	O
stop	int
)	O
{	O
h	pointer
->	O
ret_value	int
=	O
b	pointer
->	O
action	int
;	O
dlg_stop	function
(	O
h	pointer
)	O
;	O
}	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_CURSOR	int
:	O
switch	O
(	O
b	pointer
->	O
flags	enum
)	O
{	O
case	O
DEFPUSH_BUTTON	int
:	O
off	int
=	O
3	int
;	O
break	O
;	O
case	O
NORMAL_BUTTON	int
:	O
off	int
=	O
2	int
;	O
break	O
;	O
case	O
NARROW_BUTTON	int
:	O
off	int
=	O
1	int
;	O
break	O
;	O
case	O
HIDDEN_BUTTON	int
:	O
default	O
:	O
off	int
=	O
0	int
;	O
break	O
;	O
}	O
widget_move	O
(	O
&	O
b	pointer
->	O
widget	pointer
,	O
0	int
,	O
b	pointer
->	O
hotpos	int
+	O
off	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_UNFOCUS	int
:	O
case	O
WIDGET_FOCUS	int
:	O
case	O
WIDGET_DRAW	int
:	O
if	O
(	O
msg	pointer
==	O
WIDGET_UNFOCUS	int
)	O
b	pointer
->	O
selected	int
=	O
0	int
;	O
else	O
if	O
(	O
msg	pointer
==	O
WIDGET_FOCUS	int
)	O
b	pointer
->	O
selected	int
=	O
1	int
;	O
switch	O
(	O
b	pointer
->	O
flags	enum
)	O
{	O
case	O
DEFPUSH_BUTTON	int
:	O
g_snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"[< %s >]"	pointer
,	O
b	pointer
->	O
text	pointer
)	O
;	O
off	int
=	O
3	int
;	O
break	O
;	O
case	O
NORMAL_BUTTON	int
:	O
g_snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"[ %s ]"	pointer
,	O
b	pointer
->	O
text	pointer
)	O
;	O
off	int
=	O
2	int
;	O
break	O
;	O
case	O
NARROW_BUTTON	int
:	O
g_snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"[%s]"	pointer
,	O
b	pointer
->	O
text	pointer
)	O
;	O
off	int
=	O
1	int
;	O
break	O
;	O
case	O
HIDDEN_BUTTON	int
:	O
default	O
:	O
buf	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
off	int
=	O
0	int
;	O
break	O
;	O
}	O
widget_selectcolor	function
(	O
w	pointer
,	O
b	pointer
->	O
selected	int
,	O
FALSE	O
)	O
;	O
widget_move	O
(	O
w	pointer
,	O
0	int
,	O
0	int
)	O
;	O
addstr	O
(	O
buf	pointer
)	O
;	O
if	O
(	O
b	pointer
->	O
hotpos	int
>=	O
0	int
)	O
{	O
widget_selectcolor	function
(	O
w	pointer
,	O
b	pointer
->	O
selected	int
,	O
TRUE	O
)	O
;	O
widget_move	O
(	O
w	pointer
,	O
0	int
,	O
b	pointer
->	O
hotpos	int
+	O
off	int
)	O
;	O
addch	O
(	O
(	O
unsigned	O
char	O
)	O
b	pointer
->	O
text	pointer
[	O
b	pointer
->	O
hotpos	int
]	O
)	O
;	O
}	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_DESTROY	int
:	O
g_free	function
(	O
b	pointer
->	O
text	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
int	O
button_event	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
WButton	struct
*	O
b	pointer
=	O
data	pointer
;	O
if	O
(	O
event	pointer
->	O
type	enum
&	O
(	O
GPM_DOWN	int
|	O
GPM_UP	int
)	O
)	O
{	O
Dlg_head	struct
*	O
h	pointer
=	O
b	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
dlg_select_widget	function
(	O
b	pointer
)	O
;	O
if	O
(	O
event	pointer
->	O
type	enum
&	O
GPM_UP	int
)	O
{	O
button_callback	function
(	O
(	O
Widget	struct
*	O
)	O
data	pointer
,	O
WIDGET_KEY	int
,	O
' '	O
)	O
;	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_POST_KEY	int
,	O
' '	O
)	O
;	O
return	O
MOU_NORMAL	int
;	O
}	O
}	O
return	O
MOU_NORMAL	int
;	O
}	O
static	O
int	O
button_len	function
(	O
const	O
char	O
*	O
text	pointer
,	O
unsigned	O
int	O
flags	enum
)	O
{	O
int	O
ret	int
=	O
strlen	function
(	O
text	pointer
)	O
;	O
switch	O
(	O
flags	enum
)	O
{	O
case	O
DEFPUSH_BUTTON	int
:	O
ret	int
+=	O
6	int
;	O
break	O
;	O
case	O
NORMAL_BUTTON	int
:	O
ret	int
+=	O
4	int
;	O
break	O
;	O
case	O
NARROW_BUTTON	int
:	O
ret	int
+=	O
2	int
;	O
break	O
;	O
case	O
HIDDEN_BUTTON	int
:	O
default	O
:	O
return	O
0	int
;	O
}	O
return	O
ret	int
;	O
}	O
static	O
void	O
button_scan_hotkey	function
(	O
WButton	struct
*	O
b	pointer
)	O
{	O
char	O
*	O
cp	pointer
=	O
strchr	function
(	O
b	pointer
->	O
text	pointer
,	O
'&'	O
)	O
;	O
if	O
(	O
cp	pointer
!=	O
NULL	O
&&	O
cp	pointer
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
g_strlcpy	function
(	O
cp	pointer
,	O
cp	pointer
+	O
1	int
,	O
strlen	function
(	O
cp	pointer
)	O
)	O
;	O
b	pointer
->	O
hotkey	int
=	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
)	O
;	O
b	pointer
->	O
hotpos	int
=	O
cp	pointer
-	O
b	pointer
->	O
text	pointer
;	O
}	O
}	O
WButton	struct
*	O
button_new	function
(	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
action	int
,	O
int	O
flags	enum
,	O
const	O
char	O
*	O
text	pointer
,	O
bcback	pointer
callback	pointer
)	O
{	O
WButton	struct
*	O
b	pointer
=	O
g_new	O
(	O
WButton	struct
,	O
1	int
)	O
;	O
init_widget	function
(	O
&	O
b	pointer
->	O
widget	pointer
,	O
y	short
,	O
x	array
,	O
1	int
,	O
button_len	function
(	O
text	pointer
,	O
flags	enum
)	O
,	O
button_callback	function
,	O
button_event	function
)	O
;	O
b	pointer
->	O
action	int
=	O
action	int
;	O
b	pointer
->	O
flags	enum
=	O
flags	enum
;	O
b	pointer
->	O
selected	int
=	O
0	int
;	O
b	pointer
->	O
text	pointer
=	O
g_strdup	function
(	O
text	pointer
)	O
;	O
b	pointer
->	O
callback	pointer
=	O
callback	pointer
;	O
widget_want_hotkey	O
(	O
b	pointer
->	O
widget	pointer
,	O
1	int
)	O
;	O
b	pointer
->	O
hotkey	int
=	O
0	int
;	O
b	pointer
->	O
hotpos	int
=	O
-	O
1	int
;	O
button_scan_hotkey	function
(	O
b	pointer
)	O
;	O
return	O
b	pointer
;	O
}	O
const	O
char	O
*	O
button_get_text	function
(	O
WButton	struct
*	O
b	pointer
)	O
{	O
return	O
b	pointer
->	O
text	pointer
;	O
}	O
void	O
button_set_text	function
(	O
WButton	struct
*	O
b	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
g_free	function
(	O
b	pointer
->	O
text	pointer
)	O
;	O
b	pointer
->	O
text	pointer
=	O
g_strdup	function
(	O
text	pointer
)	O
;	O
b	pointer
->	O
widget	pointer
.	O
cols	int
=	O
button_len	function
(	O
text	pointer
,	O
b	pointer
->	O
flags	enum
)	O
;	O
button_scan_hotkey	function
(	O
b	pointer
)	O
;	O
dlg_redraw	function
(	O
b	pointer
->	O
widget	pointer
.	O
parent	pointer
)	O
;	O
}	O
static	O
int	O
radio_event	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
)	O
;	O
static	O
cb_ret_t	enum
radio_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
WRadio	struct
*	O
r	pointer
=	O
(	O
WRadio	struct
*	O
)	O
w	pointer
;	O
int	O
i	array
;	O
Dlg_head	struct
*	O
h	pointer
=	O
r	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
WIDGET_HOTKEY	int
:	O
{	O
int	O
i	array
,	O
lp	int
=	O
tolower	function
(	O
parm	int
)	O
;	O
const	O
char	O
*	O
cp	pointer
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
r	pointer
->	O
count	int
;	O
i	array
++	O
)	O
{	O
cp	pointer
=	O
strchr	function
(	O
r	pointer
->	O
texts	pointer
[	O
i	array
]	O
,	O
'&'	O
)	O
;	O
if	O
(	O
cp	pointer
!=	O
NULL	O
&&	O
cp	pointer
[	O
1	int
]	O
!=	O
'\0'	O
)	O
{	O
int	O
c	int
=	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
cp	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
c	int
!=	O
lp	int
)	O
continue	O
;	O
r	pointer
->	O
pos	pointer
=	O
i	array
;	O
radio_callback	function
(	O
w	pointer
,	O
WIDGET_KEY	int
,	O
' '	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
}	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
WIDGET_KEY	int
:	O
switch	O
(	O
parm	int
)	O
{	O
case	O
' '	O
:	O
r	pointer
->	O
sel	int
=	O
r	pointer
->	O
pos	pointer
;	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_ACTION	int
,	O
0	int
)	O
;	O
radio_callback	function
(	O
w	pointer
,	O
WIDGET_FOCUS	int
,	O
' '	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
KEY_UP	int
:	O
case	O
KEY_LEFT	int
:	O
if	O
(	O
r	pointer
->	O
pos	pointer
>	O
0	int
)	O
{	O
r	pointer
->	O
pos	pointer
--	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
KEY_DOWN	int
:	O
case	O
KEY_RIGHT	int
:	O
if	O
(	O
r	pointer
->	O
count	int
-	O
1	int
>	O
r	pointer
->	O
pos	pointer
)	O
{	O
r	pointer
->	O
pos	pointer
++	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
WIDGET_CURSOR	int
:	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_ACTION	int
,	O
0	int
)	O
;	O
radio_callback	function
(	O
w	pointer
,	O
WIDGET_FOCUS	int
,	O
' '	O
)	O
;	O
widget_move	O
(	O
&	O
r	pointer
->	O
widget	pointer
,	O
r	pointer
->	O
pos	pointer
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_UNFOCUS	int
:	O
case	O
WIDGET_FOCUS	int
:	O
case	O
WIDGET_DRAW	int
:	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
r	pointer
->	O
count	int
;	O
i	array
++	O
)	O
{	O
register	O
const	O
char	O
*	O
cp	pointer
;	O
const	O
gboolean	int
focused	int
=	O
(	O
i	array
==	O
r	pointer
->	O
pos	pointer
&&	O
msg	pointer
==	O
WIDGET_FOCUS	int
)	O
;	O
widget_selectcolor	function
(	O
w	pointer
,	O
focused	int
,	O
FALSE	O
)	O
;	O
widget_move	O
(	O
&	O
r	pointer
->	O
widget	pointer
,	O
i	array
,	O
0	int
)	O
;	O
tty_printf	function
(	O
"(%c) "	pointer
,	O
(	O
r	pointer
->	O
sel	int
==	O
i	array
)	O
?	O
'*'	O
:	O
' '	O
)	O
;	O
for	O
(	O
cp	pointer
=	O
r	pointer
->	O
texts	pointer
[	O
i	array
]	O
;	O
*	O
cp	pointer
;	O
cp	pointer
++	O
)	O
{	O
if	O
(	O
*	O
cp	pointer
==	O
'&'	O
)	O
{	O
widget_selectcolor	function
(	O
w	pointer
,	O
focused	int
,	O
TRUE	O
)	O
;	O
addch	O
(	O
*	O
++	O
cp	pointer
)	O
;	O
widget_selectcolor	function
(	O
w	pointer
,	O
focused	int
,	O
FALSE	O
)	O
;	O
}	O
else	O
addch	O
(	O
*	O
cp	pointer
)	O
;	O
}	O
}	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
int	O
radio_event	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
WRadio	struct
*	O
r	pointer
=	O
data	pointer
;	O
Widget	struct
*	O
w	pointer
=	O
data	pointer
;	O
if	O
(	O
event	pointer
->	O
type	enum
&	O
(	O
GPM_DOWN	int
|	O
GPM_UP	int
)	O
)	O
{	O
Dlg_head	struct
*	O
h	pointer
=	O
r	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
r	pointer
->	O
pos	pointer
=	O
event	pointer
->	O
y	short
-	O
1	int
;	O
dlg_select_widget	function
(	O
r	pointer
)	O
;	O
if	O
(	O
event	pointer
->	O
type	enum
&	O
GPM_UP	int
)	O
{	O
radio_callback	function
(	O
w	pointer
,	O
WIDGET_KEY	int
,	O
' '	O
)	O
;	O
radio_callback	function
(	O
w	pointer
,	O
WIDGET_FOCUS	int
,	O
0	int
)	O
;	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_POST_KEY	int
,	O
' '	O
)	O
;	O
return	O
MOU_NORMAL	int
;	O
}	O
}	O
return	O
MOU_NORMAL	int
;	O
}	O
WRadio	struct
*	O
radio_new	function
(	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
count	int
,	O
const	O
char	O
*	O
*	O
texts	pointer
)	O
{	O
WRadio	struct
*	O
r	pointer
=	O
g_new	O
(	O
WRadio	struct
,	O
1	int
)	O
;	O
int	O
i	array
,	O
max	long
,	O
m	int
;	O
max	long
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
count	int
;	O
i	array
++	O
)	O
{	O
m	int
=	O
strlen	function
(	O
texts	pointer
[	O
i	array
]	O
)	O
;	O
if	O
(	O
m	int
>	O
max	long
)	O
max	long
=	O
m	int
;	O
}	O
init_widget	function
(	O
&	O
r	pointer
->	O
widget	pointer
,	O
y	short
,	O
x	array
,	O
count	int
,	O
max	long
,	O
radio_callback	function
,	O
radio_event	function
)	O
;	O
r	pointer
->	O
state	pointer
=	O
1	int
;	O
r	pointer
->	O
pos	pointer
=	O
0	int
;	O
r	pointer
->	O
sel	int
=	O
0	int
;	O
r	pointer
->	O
count	int
=	O
count	int
;	O
r	pointer
->	O
texts	pointer
=	O
texts	pointer
;	O
widget_want_hotkey	O
(	O
r	pointer
->	O
widget	pointer
,	O
1	int
)	O
;	O
return	O
r	pointer
;	O
}	O
static	O
int	O
check_event	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
)	O
;	O
static	O
cb_ret_t	enum
check_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
WCheck	struct
*	O
c	int
=	O
(	O
WCheck	struct
*	O
)	O
w	pointer
;	O
Dlg_head	struct
*	O
h	pointer
=	O
c	int
->	O
widget	pointer
.	O
parent	pointer
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
WIDGET_HOTKEY	int
:	O
if	O
(	O
c	int
->	O
hotkey	int
==	O
parm	int
||	O
(	O
c	int
->	O
hotkey	int
>=	O
'a'	O
&&	O
c	int
->	O
hotkey	int
<=	O
'z'	O
&&	O
c	int
->	O
hotkey	int
-	O
32	int
==	O
parm	int
)	O
)	O
{	O
check_callback	function
(	O
w	pointer
,	O
WIDGET_KEY	int
,	O
' '	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
WIDGET_KEY	int
:	O
if	O
(	O
parm	int
!=	O
' '	O
)	O
return	O
MSG_NOT_HANDLED	int
;	O
c	int
->	O
state	pointer
^=	O
C_BOOL	int
;	O
c	int
->	O
state	pointer
^=	O
C_CHANGE	int
;	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_ACTION	int
,	O
0	int
)	O
;	O
check_callback	function
(	O
w	pointer
,	O
WIDGET_FOCUS	int
,	O
' '	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_CURSOR	int
:	O
widget_move	O
(	O
&	O
c	int
->	O
widget	pointer
,	O
0	int
,	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_FOCUS	int
:	O
case	O
WIDGET_UNFOCUS	int
:	O
case	O
WIDGET_DRAW	int
:	O
widget_selectcolor	function
(	O
w	pointer
,	O
msg	pointer
==	O
WIDGET_FOCUS	int
,	O
FALSE	O
)	O
;	O
widget_move	O
(	O
&	O
c	int
->	O
widget	pointer
,	O
0	int
,	O
0	int
)	O
;	O
tty_printf	function
(	O
"[%c] %s"	pointer
,	O
(	O
c	int
->	O
state	pointer
&	O
C_BOOL	int
)	O
?	O
'x'	O
:	O
' '	O
,	O
c	int
->	O
text	pointer
)	O
;	O
if	O
(	O
c	int
->	O
hotpos	int
>=	O
0	int
)	O
{	O
widget_selectcolor	function
(	O
w	pointer
,	O
msg	pointer
==	O
WIDGET_FOCUS	int
,	O
TRUE	O
)	O
;	O
widget_move	O
(	O
&	O
c	int
->	O
widget	pointer
,	O
0	int
,	O
+	O
c	int
->	O
hotpos	int
+	O
4	int
)	O
;	O
addch	O
(	O
(	O
unsigned	O
char	O
)	O
c	int
->	O
text	pointer
[	O
c	int
->	O
hotpos	int
]	O
)	O
;	O
}	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_DESTROY	int
:	O
g_free	function
(	O
c	int
->	O
text	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
int	O
check_event	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
WCheck	struct
*	O
c	int
=	O
data	pointer
;	O
Widget	struct
*	O
w	pointer
=	O
data	pointer
;	O
if	O
(	O
event	pointer
->	O
type	enum
&	O
(	O
GPM_DOWN	int
|	O
GPM_UP	int
)	O
)	O
{	O
Dlg_head	struct
*	O
h	pointer
=	O
c	int
->	O
widget	pointer
.	O
parent	pointer
;	O
dlg_select_widget	function
(	O
c	int
)	O
;	O
if	O
(	O
event	pointer
->	O
type	enum
&	O
GPM_UP	int
)	O
{	O
check_callback	function
(	O
w	pointer
,	O
WIDGET_KEY	int
,	O
' '	O
)	O
;	O
check_callback	function
(	O
w	pointer
,	O
WIDGET_FOCUS	int
,	O
0	int
)	O
;	O
(	O
*	O
h	pointer
->	O
callback	pointer
)	O
(	O
h	pointer
,	O
DLG_POST_KEY	int
,	O
' '	O
)	O
;	O
return	O
MOU_NORMAL	int
;	O
}	O
}	O
return	O
MOU_NORMAL	int
;	O
}	O
WCheck	struct
*	O
check_new	function
(	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
state	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
WCheck	struct
*	O
c	int
=	O
g_new	O
(	O
WCheck	struct
,	O
1	int
)	O
;	O
const	O
char	O
*	O
s	pointer
;	O
char	O
*	O
t	long
;	O
init_widget	function
(	O
&	O
c	int
->	O
widget	pointer
,	O
y	short
,	O
x	array
,	O
1	int
,	O
strlen	function
(	O
text	pointer
)	O
,	O
check_callback	function
,	O
check_event	function
)	O
;	O
c	int
->	O
state	pointer
=	O
state	pointer
?	O
C_BOOL	int
:	O
0	int
;	O
c	int
->	O
text	pointer
=	O
g_strdup	function
(	O
text	pointer
)	O
;	O
c	int
->	O
hotkey	int
=	O
0	int
;	O
c	int
->	O
hotpos	int
=	O
-	O
1	int
;	O
widget_want_hotkey	O
(	O
c	int
->	O
widget	pointer
,	O
1	int
)	O
;	O
for	O
(	O
s	pointer
=	O
text	pointer
,	O
t	long
=	O
c	int
->	O
text	pointer
;	O
*	O
s	pointer
;	O
s	pointer
++	O
,	O
t	long
++	O
)	O
{	O
if	O
(	O
*	O
s	pointer
!=	O
'&'	O
)	O
{	O
*	O
t	long
=	O
*	O
s	pointer
;	O
continue	O
;	O
}	O
s	pointer
++	O
;	O
if	O
(	O
*	O
s	pointer
)	O
{	O
c	int
->	O
hotkey	int
=	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
)	O
;	O
c	int
->	O
hotpos	int
=	O
t	long
-	O
c	int
->	O
text	pointer
;	O
}	O
*	O
t	long
=	O
*	O
s	pointer
;	O
}	O
*	O
t	long
=	O
0	int
;	O
return	O
c	int
;	O
}	O
static	O
cb_ret_t	enum
label_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
WLabel	struct
*	O
l	pointer
=	O
(	O
WLabel	struct
*	O
)	O
w	pointer
;	O
Dlg_head	struct
*	O
h	pointer
=	O
l	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
WIDGET_INIT	int
:	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_FOCUS	int
:	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
WIDGET_DRAW	int
:	O
{	O
char	O
*	O
p	pointer
=	O
l	pointer
->	O
text	pointer
,	O
*	O
q	pointer
,	O
c	int
=	O
0	int
;	O
int	O
y	short
=	O
0	int
;	O
if	O
(	O
!	O
l	pointer
->	O
text	pointer
)	O
return	O
MSG_HANDLED	int
;	O
if	O
(	O
l	pointer
->	O
transparent	int
)	O
attrset	function
(	O
DEFAULT_COLOR	O
)	O
;	O
else	O
attrset	function
(	O
DLG_NORMALC	O
(	O
h	pointer
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
xlen	int
;	O
q	pointer
=	O
strchr	function
(	O
p	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
q	pointer
)	O
{	O
c	int
=	O
*	O
q	pointer
;	O
*	O
q	pointer
=	O
0	int
;	O
}	O
widget_move	O
(	O
&	O
l	pointer
->	O
widget	pointer
,	O
y	short
,	O
0	int
)	O
;	O
tty_printf	function
(	O
"%s"	pointer
,	O
p	pointer
)	O
;	O
xlen	int
=	O
l	pointer
->	O
widget	pointer
.	O
cols	int
-	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
xlen	int
>	O
0	int
)	O
tty_printf	function
(	O
"%*s"	pointer
,	O
xlen	int
,	O
" "	pointer
)	O
;	O
if	O
(	O
!	O
q	pointer
)	O
break	O
;	O
*	O
q	pointer
=	O
c	int
;	O
p	pointer
=	O
q	pointer
+	O
1	int
;	O
y	short
++	O
;	O
}	O
return	O
MSG_HANDLED	int
;	O
}	O
case	O
WIDGET_DESTROY	int
:	O
g_free	function
(	O
l	pointer
->	O
text	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
void	O
label_set_text	function
(	O
WLabel	struct
*	O
label	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
int	O
newcols	int
=	O
label	pointer
->	O
widget	pointer
.	O
cols	int
;	O
if	O
(	O
label	pointer
->	O
text	pointer
&&	O
text	pointer
&&	O
!	O
strcmp	function
(	O
label	pointer
->	O
text	pointer
,	O
text	pointer
)	O
)	O
return	O
;	O
g_free	function
(	O
label	pointer
->	O
text	pointer
)	O
;	O
if	O
(	O
text	pointer
)	O
{	O
label	pointer
->	O
text	pointer
=	O
g_strdup	function
(	O
text	pointer
)	O
;	O
if	O
(	O
label	pointer
->	O
auto_adjust_cols	int
)	O
{	O
newcols	int
=	O
strlen	function
(	O
text	pointer
)	O
;	O
if	O
(	O
newcols	int
>	O
label	pointer
->	O
widget	pointer
.	O
cols	int
)	O
label	pointer
->	O
widget	pointer
.	O
cols	int
=	O
newcols	int
;	O
}	O
}	O
else	O
label	pointer
->	O
text	pointer
=	O
0	int
;	O
if	O
(	O
label	pointer
->	O
widget	pointer
.	O
parent	pointer
)	O
label_callback	function
(	O
(	O
Widget	struct
*	O
)	O
label	pointer
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
if	O
(	O
newcols	int
<	O
label	pointer
->	O
widget	pointer
.	O
cols	int
)	O
label	pointer
->	O
widget	pointer
.	O
cols	int
=	O
newcols	int
;	O
}	O
WLabel	struct
*	O
label_new	function
(	O
int	O
y	short
,	O
int	O
x	array
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
WLabel	struct
*	O
l	pointer
;	O
int	O
width	int
;	O
if	O
(	O
!	O
text	pointer
||	O
strchr	function
(	O
text	pointer
,	O
'\n'	O
)	O
)	O
width	int
=	O
1	int
;	O
else	O
width	int
=	O
strlen	function
(	O
text	pointer
)	O
;	O
l	pointer
=	O
g_new	O
(	O
WLabel	struct
,	O
1	int
)	O
;	O
init_widget	function
(	O
&	O
l	pointer
->	O
widget	pointer
,	O
y	short
,	O
x	array
,	O
1	int
,	O
width	int
,	O
label_callback	function
,	O
NULL	O
)	O
;	O
l	pointer
->	O
text	pointer
=	O
text	pointer
?	O
g_strdup	function
(	O
text	pointer
)	O
:	O
0	int
;	O
l	pointer
->	O
auto_adjust_cols	int
=	O
1	int
;	O
l	pointer
->	O
transparent	int
=	O
0	int
;	O
widget_want_cursor	O
(	O
l	pointer
->	O
widget	pointer
,	O
0	int
)	O
;	O
return	O
l	pointer
;	O
}	O
static	O
cb_ret_t	enum
gauge_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
WGauge	struct
*	O
g	pointer
=	O
(	O
WGauge	struct
*	O
)	O
w	pointer
;	O
Dlg_head	struct
*	O
h	pointer
=	O
g	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
if	O
(	O
msg	pointer
==	O
WIDGET_INIT	int
)	O
return	O
MSG_HANDLED	int
;	O
if	O
(	O
msg	pointer
==	O
WIDGET_FOCUS	int
)	O
return	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
msg	pointer
==	O
WIDGET_DRAW	int
)	O
{	O
widget_move	O
(	O
&	O
g	pointer
->	O
widget	pointer
,	O
0	int
,	O
0	int
)	O
;	O
attrset	function
(	O
DLG_NORMALC	O
(	O
h	pointer
)	O
)	O
;	O
if	O
(	O
!	O
g	pointer
->	O
shown	int
)	O
tty_printf	function
(	O
"%*s"	pointer
,	O
gauge_len	int
,	O
""	pointer
)	O
;	O
else	O
{	O
int	O
percentage	int
,	O
columns	pointer
;	O
long	O
total	double
=	O
g	pointer
->	O
max	long
,	O
done	long
=	O
g	pointer
->	O
current	pointer
;	O
if	O
(	O
total	double
<=	O
0	int
||	O
done	long
<	O
0	int
)	O
{	O
done	long
=	O
0	int
;	O
total	double
=	O
100	int
;	O
}	O
if	O
(	O
done	long
>	O
total	double
)	O
done	long
=	O
total	double
;	O
while	O
(	O
total	double
>	O
65535	int
)	O
{	O
total	double
/=	O
256	int
;	O
done	long
/=	O
256	int
;	O
}	O
percentage	int
=	O
(	O
200	int
*	O
done	long
/	O
total	double
+	O
1	int
)	O
/	O
2	int
;	O
columns	pointer
=	O
(	O
2	int
*	O
(	O
gauge_len	int
-	O
7	int
)	O
*	O
done	long
/	O
total	double
+	O
1	int
)	O
/	O
2	int
;	O
addch	O
(	O
'['	O
)	O
;	O
attrset	function
(	O
GAUGE_COLOR	O
)	O
;	O
tty_printf	function
(	O
"%*s"	pointer
,	O
(	O
int	O
)	O
columns	pointer
,	O
""	pointer
)	O
;	O
attrset	function
(	O
DLG_NORMALC	O
(	O
h	pointer
)	O
)	O
;	O
tty_printf	function
(	O
"%*s] %3d%%"	pointer
,	O
(	O
int	O
)	O
(	O
gauge_len	int
-	O
7	int
-	O
columns	pointer
)	O
,	O
""	pointer
,	O
(	O
int	O
)	O
percentage	int
)	O
;	O
}	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
void	O
gauge_set_value	function
(	O
WGauge	struct
*	O
g	pointer
,	O
int	O
max	long
,	O
int	O
current	pointer
)	O
{	O
if	O
(	O
g	pointer
->	O
current	pointer
==	O
current	pointer
&&	O
g	pointer
->	O
max	long
==	O
max	long
)	O
return	O
;	O
if	O
(	O
max	long
==	O
0	int
)	O
max	long
=	O
1	int
;	O
g	pointer
->	O
current	pointer
=	O
current	pointer
;	O
g	pointer
->	O
max	long
=	O
max	long
;	O
gauge_callback	function
(	O
(	O
Widget	struct
*	O
)	O
g	pointer
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
}	O
void	O
gauge_show	function
(	O
WGauge	struct
*	O
g	pointer
,	O
int	O
shown	int
)	O
{	O
if	O
(	O
g	pointer
->	O
shown	int
==	O
shown	int
)	O
return	O
;	O
g	pointer
->	O
shown	int
=	O
shown	int
;	O
gauge_callback	function
(	O
(	O
Widget	struct
*	O
)	O
g	pointer
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
}	O
WGauge	struct
*	O
gauge_new	function
(	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
shown	int
,	O
int	O
max	long
,	O
int	O
current	pointer
)	O
{	O
WGauge	struct
*	O
g	pointer
=	O
g_new	O
(	O
WGauge	struct
,	O
1	int
)	O
;	O
init_widget	function
(	O
&	O
g	pointer
->	O
widget	pointer
,	O
y	short
,	O
x	array
,	O
1	int
,	O
gauge_len	int
,	O
gauge_callback	function
,	O
NULL	O
)	O
;	O
g	pointer
->	O
shown	int
=	O
shown	int
;	O
if	O
(	O
max	long
==	O
0	int
)	O
max	long
=	O
1	int
;	O
g	pointer
->	O
max	long
=	O
max	long
;	O
g	pointer
->	O
current	pointer
=	O
current	pointer
;	O
widget_want_cursor	O
(	O
g	pointer
->	O
widget	pointer
,	O
0	int
)	O
;	O
return	O
g	pointer
;	O
}	O
static	O
void	O
draw_history_button	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
char	O
c	int
;	O
c	int
=	O
in	pointer
->	O
history	pointer
->	O
next	pointer
?	O
(	O
in	pointer
->	O
history	pointer
->	O
prev	pointer
?	O
'|'	O
:	O
'v'	O
)	O
:	O
'^'	O
;	O
widget_move	O
(	O
&	O
in	pointer
->	O
widget	pointer
,	O
0	int
,	O
in	pointer
->	O
field_len	int
-	O
HISTORY_BUTTON_WIDTH	int
)	O
;	O
{	O
Dlg_head	struct
*	O
h	pointer
;	O
h	pointer
=	O
in	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
attrset	function
(	O
NORMAL_COLOR	O
)	O
;	O
addstr	O
(	O
"[ ]"	pointer
)	O
;	O
widget_move	O
(	O
&	O
in	pointer
->	O
widget	pointer
,	O
0	int
,	O
in	pointer
->	O
field_len	int
-	O
HISTORY_BUTTON_WIDTH	int
+	O
1	int
)	O
;	O
addch	O
(	O
c	int
)	O
;	O
}	O
}	O
static	O
char	O
*	O
kill_buffer	pointer
=	O
0	int
;	O
void	O
update_input	function
(	O
WInput	struct
*	O
in	pointer
,	O
int	O
clear_first	int
)	O
{	O
int	O
has_history	int
=	O
0	int
;	O
int	O
i	array
,	O
j	int
;	O
unsigned	O
char	O
c	int
;	O
int	O
buf_len	int
=	O
strlen	function
(	O
in	pointer
->	O
buffer	pointer
)	O
;	O
if	O
(	O
should_show_history_button	O
(	O
in	pointer
)	O
)	O
has_history	int
=	O
HISTORY_BUTTON_WIDTH	int
;	O
if	O
(	O
in	pointer
->	O
disable_update	int
)	O
return	O
;	O
if	O
(	O
(	O
in	pointer
->	O
point	int
<	O
in	pointer
->	O
first_shown	int
)	O
||	O
(	O
in	pointer
->	O
point	int
>=	O
in	pointer
->	O
first_shown	int
+	O
in	pointer
->	O
field_len	int
-	O
has_history	int
)	O
)	O
{	O
in	pointer
->	O
first_shown	int
=	O
in	pointer
->	O
point	int
-	O
(	O
in	pointer
->	O
field_len	int
/	O
3	int
)	O
;	O
if	O
(	O
in	pointer
->	O
first_shown	int
<	O
0	int
)	O
in	pointer
->	O
first_shown	int
=	O
0	int
;	O
}	O
if	O
(	O
in	pointer
->	O
mark	int
>	O
buf_len	int
)	O
in	pointer
->	O
mark	int
=	O
buf_len	int
;	O
if	O
(	O
has_history	int
)	O
draw_history_button	function
(	O
in	pointer
)	O
;	O
attrset	function
(	O
in	pointer
->	O
color	short
)	O
;	O
widget_move	O
(	O
&	O
in	pointer
->	O
widget	pointer
,	O
0	int
,	O
0	int
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
in	pointer
->	O
field_len	int
-	O
has_history	int
;	O
i	array
++	O
)	O
addch	O
(	O
' '	O
)	O
;	O
widget_move	O
(	O
&	O
in	pointer
->	O
widget	pointer
,	O
0	int
,	O
0	int
)	O
;	O
for	O
(	O
i	array
=	O
0	int
,	O
j	int
=	O
in	pointer
->	O
first_shown	int
;	O
i	array
<	O
in	pointer
->	O
field_len	int
-	O
has_history	int
&&	O
in	pointer
->	O
buffer	pointer
[	O
j	int
]	O
;	O
i	array
++	O
)	O
{	O
c	int
=	O
in	pointer
->	O
buffer	pointer
[	O
j	int
++	O
]	O
;	O
c	int
=	O
is_printable	function
(	O
c	int
)	O
?	O
c	int
:	O
'.'	O
;	O
if	O
(	O
in	pointer
->	O
is_password	int
)	O
c	int
=	O
'*'	O
;	O
addch	O
(	O
c	int
)	O
;	O
}	O
widget_move	O
(	O
&	O
in	pointer
->	O
widget	pointer
,	O
0	int
,	O
in	pointer
->	O
point	int
-	O
in	pointer
->	O
first_shown	int
)	O
;	O
if	O
(	O
clear_first	int
)	O
in	pointer
->	O
first	pointer
=	O
0	int
;	O
}	O
void	O
winput_set_origin	function
(	O
WInput	struct
*	O
in	pointer
,	O
int	O
x	array
,	O
int	O
field_len	int
)	O
{	O
in	pointer
->	O
widget	pointer
.	O
x	array
=	O
x	array
;	O
in	pointer
->	O
field_len	int
=	O
in	pointer
->	O
widget	pointer
.	O
cols	int
=	O
field_len	int
;	O
update_input	function
(	O
in	pointer
,	O
0	int
)	O
;	O
}	O
int	O
num_history_items_recorded	int
=	O
60	int
;	O
GList	struct
*	O
history_get	function
(	O
const	O
char	O
*	O
input_name	pointer
)	O
{	O
int	O
i	array
;	O
GList	struct
*	O
hist	pointer
;	O
char	O
*	O
profile	pointer
;	O
hist	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
num_history_items_recorded	int
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
input_name	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
*	O
input_name	pointer
)	O
return	O
NULL	O
;	O
profile	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
HISTORY_FILE_NAME	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
;	O
i	array
++	O
)	O
{	O
char	O
key_name	pointer
[	O
BUF_TINY	int
]	O
;	O
char	O
this_entry	array
[	O
BUF_LARGE	O
]	O
;	O
g_snprintf	function
(	O
key_name	pointer
,	O
sizeof	O
(	O
key_name	pointer
)	O
,	O
"%d"	pointer
,	O
i	array
)	O
;	O
GetPrivateProfileString	function
(	O
input_name	pointer
,	O
key_name	pointer
,	O
""	pointer
,	O
this_entry	array
,	O
sizeof	O
(	O
this_entry	array
)	O
,	O
profile	pointer
)	O
;	O
if	O
(	O
!	O
*	O
this_entry	array
)	O
break	O
;	O
hist	pointer
=	O
list_append_unique	function
(	O
hist	pointer
,	O
g_strdup	function
(	O
this_entry	array
)	O
)	O
;	O
}	O
g_free	function
(	O
profile	pointer
)	O
;	O
hist	pointer
=	O
g_list_last	function
(	O
hist	pointer
)	O
;	O
return	O
hist	pointer
;	O
}	O
void	O
history_put	function
(	O
const	O
char	O
*	O
input_name	pointer
,	O
GList	struct
*	O
h	pointer
)	O
{	O
int	O
i	array
;	O
char	O
*	O
profile	pointer
;	O
if	O
(	O
!	O
input_name	pointer
)	O
return	O
;	O
if	O
(	O
!	O
*	O
input_name	pointer
)	O
return	O
;	O
if	O
(	O
!	O
h	pointer
)	O
return	O
;	O
if	O
(	O
!	O
num_history_items_recorded	int
)	O
return	O
;	O
profile	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
HISTORY_FILE_NAME	pointer
)	O
;	O
if	O
(	O
(	O
i	array
=	O
open	function
(	O
profile	pointer
,	O
O_CREAT	int
|	O
O_EXCL	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
)	O
!=	O
-	O
1	int
)	O
close	pointer
(	O
i	array
)	O
;	O
if	O
(	O
chmod	function
(	O
profile	pointer
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
==	O
-	O
1	int
&&	O
errno	O
!=	O
ENOENT	int
)	O
{	O
g_free	function
(	O
profile	pointer
)	O
;	O
return	O
;	O
}	O
h	pointer
=	O
g_list_last	function
(	O
h	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
num_history_items_recorded	int
-	O
1	int
&&	O
h	pointer
->	O
prev	pointer
;	O
i	array
++	O
)	O
h	pointer
=	O
g_list_previous	O
(	O
h	pointer
)	O
;	O
if	O
(	O
input_name	pointer
)	O
profile_clean_section	function
(	O
input_name	pointer
,	O
profile	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
h	pointer
;	O
h	pointer
=	O
g_list_next	O
(	O
h	pointer
)	O
)	O
{	O
char	O
*	O
text	pointer
;	O
text	pointer
=	O
(	O
char	O
*	O
)	O
h	pointer
->	O
data	pointer
;	O
if	O
(	O
text	pointer
&&	O
*	O
text	pointer
)	O
{	O
char	O
key_name	pointer
[	O
BUF_TINY	int
]	O
;	O
g_snprintf	function
(	O
key_name	pointer
,	O
sizeof	O
(	O
key_name	pointer
)	O
,	O
"%d"	pointer
,	O
i	array
++	O
)	O
;	O
WritePrivateProfileString	function
(	O
input_name	pointer
,	O
key_name	pointer
,	O
text	pointer
,	O
profile	pointer
)	O
;	O
}	O
}	O
g_free	function
(	O
profile	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
i18n_htitle	function
(	O
void	O
)	O
{	O
static	O
const	O
char	O
*	O
history_title	pointer
=	O
NULL	O
;	O
if	O
(	O
history_title	pointer
==	O
NULL	O
)	O
history_title	pointer
=	O
_	O
(	O
" History "	pointer
)	O
;	O
return	O
history_title	pointer
;	O
}	O
static	O
WLEntry	struct
*	O
listbox_select_pos	function
(	O
WListbox	struct
*	O
l	pointer
,	O
WLEntry	struct
*	O
base	int
,	O
int	O
pos	pointer
)	O
;	O
static	O
inline	O
cb_ret_t	enum
listbox_fwd	function
(	O
WListbox	struct
*	O
l	pointer
)	O
{	O
if	O
(	O
l	pointer
->	O
current	pointer
!=	O
l	pointer
->	O
list	pointer
->	O
prev	pointer
)	O
{	O
listbox_select_entry	function
(	O
l	pointer
,	O
listbox_select_pos	function
(	O
l	pointer
,	O
l	pointer
->	O
list	pointer
,	O
l	pointer
->	O
pos	pointer
+	O
1	int
)	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
char	O
*	O
show_hist	function
(	O
GList	struct
*	O
history	pointer
,	O
int	O
widget_x	int
,	O
int	O
widget_y	int
)	O
{	O
GList	struct
*	O
hi	pointer
,	O
*	O
z	pointer
;	O
size_t	long
maxlen	long
=	O
strlen	function
(	O
i18n_htitle	function
(	O
)	O
)	O
,	O
i	array
,	O
count	int
=	O
0	int
;	O
int	O
x	array
,	O
y	short
,	O
w	pointer
,	O
h	pointer
;	O
char	O
*	O
q	pointer
,	O
*	O
r	pointer
=	O
0	int
;	O
Dlg_head	struct
*	O
query_dlg	pointer
;	O
WListbox	struct
*	O
query_list	pointer
;	O
z	pointer
=	O
history	pointer
;	O
if	O
(	O
!	O
z	pointer
)	O
return	O
NULL	O
;	O
z	pointer
=	O
g_list_first	function
(	O
history	pointer
)	O
;	O
hi	pointer
=	O
z	pointer
;	O
while	O
(	O
hi	pointer
)	O
{	O
if	O
(	O
(	O
i	array
=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
hi	pointer
->	O
data	pointer
)	O
)	O
>	O
maxlen	long
)	O
maxlen	long
=	O
i	array
;	O
count	int
++	O
;	O
hi	pointer
=	O
g_list_next	O
(	O
hi	pointer
)	O
;	O
}	O
y	short
=	O
widget_y	int
;	O
h	pointer
=	O
count	int
+	O
2	int
;	O
if	O
(	O
h	pointer
<=	O
y	short
||	O
y	short
>	O
LINES	O
-	O
6	int
)	O
{	O
h	pointer
=	O
min	long
(	O
h	pointer
,	O
y	short
-	O
1	int
)	O
;	O
y	short
-=	O
h	pointer
;	O
}	O
else	O
{	O
y	short
++	O
;	O
h	pointer
=	O
min	long
(	O
h	pointer
,	O
LINES	O
-	O
y	short
)	O
;	O
}	O
if	O
(	O
widget_x	int
>	O
2	int
)	O
x	array
=	O
widget_x	int
-	O
2	int
;	O
else	O
x	array
=	O
0	int
;	O
if	O
(	O
(	O
w	pointer
=	O
maxlen	long
+	O
4	int
)	O
+	O
x	array
>	O
COLS	O
)	O
{	O
w	pointer
=	O
min	long
(	O
w	pointer
,	O
COLS	O
)	O
;	O
x	array
=	O
COLS	O
-	O
w	pointer
;	O
}	O
query_dlg	pointer
=	O
create_dlg	function
(	O
y	short
,	O
x	array
,	O
h	pointer
,	O
w	pointer
,	O
dialog_colors	array
,	O
NULL	O
,	O
"[History-query]"	pointer
,	O
i18n_htitle	function
(	O
)	O
,	O
DLG_COMPACT	O
)	O
;	O
query_list	pointer
=	O
listbox_new	function
(	O
1	int
,	O
1	int
,	O
w	pointer
-	O
2	int
,	O
h	pointer
-	O
2	int
,	O
0	int
)	O
;	O
add_widget	function
(	O
query_dlg	pointer
,	O
query_list	pointer
)	O
;	O
hi	pointer
=	O
z	pointer
;	O
if	O
(	O
y	short
<	O
widget_y	int
)	O
{	O
while	O
(	O
hi	pointer
)	O
{	O
listbox_add_item	function
(	O
query_list	pointer
,	O
0	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
hi	pointer
->	O
data	pointer
,	O
NULL	O
)	O
;	O
hi	pointer
=	O
g_list_next	O
(	O
hi	pointer
)	O
;	O
}	O
while	O
(	O
listbox_fwd	function
(	O
query_list	pointer
)	O
)	O
;	O
}	O
else	O
{	O
hi	pointer
=	O
g_list_last	function
(	O
history	pointer
)	O
;	O
while	O
(	O
hi	pointer
)	O
{	O
listbox_add_item	function
(	O
query_list	pointer
,	O
0	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
hi	pointer
->	O
data	pointer
,	O
NULL	O
)	O
;	O
hi	pointer
=	O
g_list_previous	O
(	O
hi	pointer
)	O
;	O
}	O
}	O
run_dlg	function
(	O
query_dlg	pointer
)	O
;	O
q	pointer
=	O
NULL	O
;	O
if	O
(	O
query_dlg	pointer
->	O
ret_value	int
!=	O
B_CANCEL	int
)	O
{	O
listbox_get_current	function
(	O
query_list	pointer
,	O
&	O
q	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
q	pointer
)	O
r	pointer
=	O
g_strdup	function
(	O
q	pointer
)	O
;	O
}	O
destroy_dlg	function
(	O
query_dlg	pointer
)	O
;	O
return	O
r	pointer
;	O
}	O
static	O
void	O
do_show_hist	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
char	O
*	O
r	pointer
;	O
r	pointer
=	O
show_hist	function
(	O
in	pointer
->	O
history	pointer
,	O
in	pointer
->	O
widget	pointer
.	O
x	array
,	O
in	pointer
->	O
widget	pointer
.	O
y	short
)	O
;	O
if	O
(	O
r	pointer
)	O
{	O
assign_text	function
(	O
in	pointer
,	O
r	pointer
)	O
;	O
g_free	function
(	O
r	pointer
)	O
;	O
}	O
}	O
static	O
void	O
input_destroy	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
if	O
(	O
!	O
in	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Internal error: null Input *\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
new_input	function
(	O
in	pointer
)	O
;	O
if	O
(	O
in	pointer
->	O
history	pointer
)	O
{	O
if	O
(	O
!	O
in	pointer
->	O
is_password	int
)	O
history_put	function
(	O
in	pointer
->	O
history_name	pointer
,	O
in	pointer
->	O
history	pointer
)	O
;	O
in	pointer
->	O
history	pointer
=	O
g_list_first	function
(	O
in	pointer
->	O
history	pointer
)	O
;	O
g_list_foreach	function
(	O
in	pointer
->	O
history	pointer
,	O
(	O
GFunc	pointer
)	O
g_free	function
,	O
NULL	O
)	O
;	O
g_list_free	function
(	O
in	pointer
->	O
history	pointer
)	O
;	O
}	O
g_free	function
(	O
in	pointer
->	O
buffer	pointer
)	O
;	O
free_completions	function
(	O
in	pointer
)	O
;	O
g_free	function
(	O
in	pointer
->	O
history_name	pointer
)	O
;	O
}	O
void	O
input_disable_update	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
in	pointer
->	O
disable_update	int
++	O
;	O
}	O
void	O
input_enable_update	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
in	pointer
->	O
disable_update	int
--	O
;	O
update_input	function
(	O
in	pointer
,	O
0	int
)	O
;	O
}	O
int	O
push_history	function
(	O
WInput	struct
*	O
in	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
static	O
int	O
i18n	int
;	O
static	O
const	O
char	O
*	O
password_input_fields	array
[	O
]	O
=	O
{	O
N_	O
(	O
" Link to a remote machine "	pointer
)	O
,	O
N_	O
(	O
" FTP to machine "	pointer
)	O
,	O
N_	O
(	O
" SMB link to machine "	pointer
)	O
}	O
;	O
char	O
*	O
t	long
;	O
const	O
char	O
*	O
p	pointer
;	O
size_t	long
i	array
;	O
if	O
(	O
!	O
i18n	int
)	O
{	O
i18n	int
=	O
1	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
ELEMENTS	O
(	O
password_input_fields	array
)	O
;	O
i	array
++	O
)	O
password_input_fields	array
[	O
i	array
]	O
=	O
_	O
(	O
password_input_fields	array
[	O
i	array
]	O
)	O
;	O
}	O
for	O
(	O
p	pointer
=	O
text	pointer
;	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
;	O
p	pointer
++	O
)	O
;	O
if	O
(	O
!	O
*	O
p	pointer
)	O
return	O
0	int
;	O
if	O
(	O
in	pointer
->	O
history	pointer
)	O
{	O
in	pointer
->	O
history	pointer
=	O
g_list_last	function
(	O
in	pointer
->	O
history	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
(	O
char	O
*	O
)	O
in	pointer
->	O
history	pointer
->	O
data	pointer
,	O
text	pointer
)	O
)	O
return	O
1	int
;	O
}	O
t	long
=	O
g_strdup	function
(	O
text	pointer
)	O
;	O
if	O
(	O
in	pointer
->	O
history_name	pointer
)	O
{	O
p	pointer
=	O
in	pointer
->	O
history_name	pointer
+	O
3	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
ELEMENTS	O
(	O
password_input_fields	array
)	O
;	O
i	array
++	O
)	O
if	O
(	O
strcmp	function
(	O
p	pointer
,	O
password_input_fields	array
[	O
i	array
]	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	array
<	O
ELEMENTS	O
(	O
password_input_fields	array
)	O
)	O
strip_password	function
(	O
t	long
,	O
0	int
)	O
;	O
else	O
strip_password	function
(	O
t	long
,	O
1	int
)	O
;	O
}	O
in	pointer
->	O
history	pointer
=	O
list_append_unique	function
(	O
in	pointer
->	O
history	pointer
,	O
t	long
)	O
;	O
in	pointer
->	O
need_push	int
=	O
0	int
;	O
return	O
2	int
;	O
}	O
void	O
new_input	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
if	O
(	O
in	pointer
->	O
buffer	pointer
)	O
push_history	function
(	O
in	pointer
,	O
in	pointer
->	O
buffer	pointer
)	O
;	O
in	pointer
->	O
need_push	int
=	O
1	int
;	O
in	pointer
->	O
buffer	pointer
[	O
0	int
]	O
=	O
0	int
;	O
in	pointer
->	O
point	int
=	O
0	int
;	O
in	pointer
->	O
mark	int
=	O
0	int
;	O
free_completions	function
(	O
in	pointer
)	O
;	O
update_input	function
(	O
in	pointer
,	O
0	int
)	O
;	O
}	O
static	O
cb_ret_t	enum
insert_char	function
(	O
WInput	struct
*	O
in	pointer
,	O
int	O
c_code	int
)	O
{	O
size_t	long
i	array
;	O
if	O
(	O
c_code	int
==	O
-	O
1	int
)	O
return	O
MSG_NOT_HANDLED	int
;	O
in	pointer
->	O
need_push	int
=	O
1	int
;	O
if	O
(	O
strlen	function
(	O
in	pointer
->	O
buffer	pointer
)	O
+	O
1	int
==	O
(	O
size_t	long
)	O
in	pointer
->	O
current_max_len	int
)	O
{	O
char	O
*	O
narea	pointer
=	O
g_realloc	function
(	O
in	pointer
->	O
buffer	pointer
,	O
in	pointer
->	O
current_max_len	int
+	O
in	pointer
->	O
field_len	int
)	O
;	O
if	O
(	O
narea	pointer
)	O
{	O
in	pointer
->	O
buffer	pointer
=	O
narea	pointer
;	O
in	pointer
->	O
current_max_len	int
+=	O
in	pointer
->	O
field_len	int
;	O
}	O
}	O
if	O
(	O
strlen	function
(	O
in	pointer
->	O
buffer	pointer
)	O
+	O
1	int
<	O
(	O
size_t	long
)	O
in	pointer
->	O
current_max_len	int
)	O
{	O
size_t	long
l	pointer
=	O
strlen	function
(	O
&	O
in	pointer
->	O
buffer	pointer
[	O
in	pointer
->	O
point	int
]	O
)	O
;	O
for	O
(	O
i	array
=	O
l	pointer
+	O
1	int
;	O
i	array
>	O
0	int
;	O
i	array
--	O
)	O
in	pointer
->	O
buffer	pointer
[	O
in	pointer
->	O
point	int
+	O
i	array
]	O
=	O
in	pointer
->	O
buffer	pointer
[	O
in	pointer
->	O
point	int
+	O
i	array
-	O
1	int
]	O
;	O
in	pointer
->	O
buffer	pointer
[	O
in	pointer
->	O
point	int
]	O
=	O
c_code	int
;	O
in	pointer
->	O
point	int
++	O
;	O
}	O
return	O
MSG_HANDLED	int
;	O
}	O
static	O
void	O
beginning_of_line	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
in	pointer
->	O
point	int
=	O
0	int
;	O
}	O
static	O
void	O
end_of_line	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
in	pointer
->	O
point	int
=	O
strlen	function
(	O
in	pointer
->	O
buffer	pointer
)	O
;	O
}	O
static	O
void	O
backward_char	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
if	O
(	O
in	pointer
->	O
point	int
)	O
in	pointer
->	O
point	int
--	O
;	O
}	O
static	O
void	O
forward_char	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
if	O
(	O
in	pointer
->	O
buffer	pointer
[	O
in	pointer
->	O
point	int
]	O
)	O
in	pointer
->	O
point	int
++	O
;	O
}	O
static	O
void	O
forward_word	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
in	pointer
->	O
buffer	pointer
+	O
in	pointer
->	O
point	int
;	O
while	O
(	O
*	O
p	pointer
&&	O
(	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
||	O
ispunct	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
)	O
)	O
p	pointer
++	O
;	O
while	O
(	O
*	O
p	pointer
&&	O
isalnum	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
)	O
p	pointer
++	O
;	O
in	pointer
->	O
point	int
=	O
p	pointer
-	O
in	pointer
->	O
buffer	pointer
;	O
}	O
static	O
void	O
backward_word	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
in	pointer
->	O
buffer	pointer
+	O
in	pointer
->	O
point	int
;	O
while	O
(	O
p	pointer
-	O
1	int
>	O
in	pointer
->	O
buffer	pointer
-	O
1	int
&&	O
(	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
(	O
p	pointer
-	O
1	int
)	O
)	O
||	O
ispunct	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
(	O
p	pointer
-	O
1	int
)	O
)	O
)	O
)	O
p	pointer
--	O
;	O
while	O
(	O
p	pointer
-	O
1	int
>	O
in	pointer
->	O
buffer	pointer
-	O
1	int
&&	O
isalnum	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
(	O
p	pointer
-	O
1	int
)	O
)	O
)	O
p	pointer
--	O
;	O
in	pointer
->	O
point	int
=	O
p	pointer
-	O
in	pointer
->	O
buffer	pointer
;	O
}	O
static	O
void	O
key_left	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
backward_char	function
(	O
in	pointer
)	O
;	O
}	O
static	O
void	O
key_ctrl_left	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
backward_word	function
(	O
in	pointer
)	O
;	O
}	O
static	O
void	O
key_right	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
forward_char	function
(	O
in	pointer
)	O
;	O
}	O
static	O
void	O
key_ctrl_right	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
forward_word	function
(	O
in	pointer
)	O
;	O
}	O
static	O
void	O
backward_delete	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
int	O
i	array
;	O
if	O
(	O
!	O
in	pointer
->	O
point	int
)	O
return	O
;	O
for	O
(	O
i	array
=	O
in	pointer
->	O
point	int
;	O
in	pointer
->	O
buffer	pointer
[	O
i	array
-	O
1	int
]	O
;	O
i	array
++	O
)	O
in	pointer
->	O
buffer	pointer
[	O
i	array
-	O
1	int
]	O
=	O
in	pointer
->	O
buffer	pointer
[	O
i	array
]	O
;	O
in	pointer
->	O
need_push	int
=	O
1	int
;	O
in	pointer
->	O
point	int
--	O
;	O
}	O
static	O
void	O
delete_char	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
in	pointer
->	O
point	int
;	O
in	pointer
->	O
buffer	pointer
[	O
i	array
]	O
;	O
i	array
++	O
)	O
in	pointer
->	O
buffer	pointer
[	O
i	array
]	O
=	O
in	pointer
->	O
buffer	pointer
[	O
i	array
+	O
1	int
]	O
;	O
in	pointer
->	O
need_push	int
=	O
1	int
;	O
}	O
static	O
void	O
copy_region	function
(	O
WInput	struct
*	O
in	pointer
,	O
int	O
x_first	int
,	O
int	O
x_last	int
)	O
{	O
int	O
first	pointer
=	O
min	long
(	O
x_first	int
,	O
x_last	int
)	O
;	O
int	O
last	int
=	O
max	long
(	O
x_first	int
,	O
x_last	int
)	O
;	O
if	O
(	O
last	int
==	O
first	pointer
)	O
return	O
;	O
g_free	function
(	O
kill_buffer	pointer
)	O
;	O
kill_buffer	pointer
=	O
g_strndup	function
(	O
in	pointer
->	O
buffer	pointer
+	O
first	pointer
,	O
last	int
-	O
first	pointer
)	O
;	O
}	O
static	O
void	O
delete_region	function
(	O
WInput	struct
*	O
in	pointer
,	O
int	O
x_first	int
,	O
int	O
x_last	int
)	O
{	O
int	O
first	pointer
=	O
min	long
(	O
x_first	int
,	O
x_last	int
)	O
;	O
int	O
last	int
=	O
max	long
(	O
x_first	int
,	O
x_last	int
)	O
;	O
size_t	long
len	int
=	O
strlen	function
(	O
&	O
in	pointer
->	O
buffer	pointer
[	O
last	int
]	O
)	O
+	O
1	int
;	O
in	pointer
->	O
point	int
=	O
first	pointer
;	O
in	pointer
->	O
mark	int
=	O
first	pointer
;	O
memmove	function
(	O
&	O
in	pointer
->	O
buffer	pointer
[	O
first	pointer
]	O
,	O
&	O
in	pointer
->	O
buffer	pointer
[	O
last	int
]	O
,	O
len	int
)	O
;	O
in	pointer
->	O
need_push	int
=	O
1	int
;	O
}	O
static	O
void	O
kill_word	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
int	O
old_point	int
=	O
in	pointer
->	O
point	int
;	O
int	O
new_point	int
;	O
forward_word	function
(	O
in	pointer
)	O
;	O
new_point	int
=	O
in	pointer
->	O
point	int
;	O
in	pointer
->	O
point	int
=	O
old_point	int
;	O
copy_region	function
(	O
in	pointer
,	O
old_point	int
,	O
new_point	int
)	O
;	O
delete_region	function
(	O
in	pointer
,	O
old_point	int
,	O
new_point	int
)	O
;	O
in	pointer
->	O
need_push	int
=	O
1	int
;	O
}	O
static	O
void	O
back_kill_word	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
int	O
old_point	int
=	O
in	pointer
->	O
point	int
;	O
int	O
new_point	int
;	O
backward_word	function
(	O
in	pointer
)	O
;	O
new_point	int
=	O
in	pointer
->	O
point	int
;	O
in	pointer
->	O
point	int
=	O
old_point	int
;	O
copy_region	function
(	O
in	pointer
,	O
old_point	int
,	O
new_point	int
)	O
;	O
delete_region	function
(	O
in	pointer
,	O
old_point	int
,	O
new_point	int
)	O
;	O
in	pointer
->	O
need_push	int
=	O
1	int
;	O
}	O
static	O
void	O
set_mark	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
in	pointer
->	O
mark	int
=	O
in	pointer
->	O
point	int
;	O
}	O
static	O
void	O
kill_save	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
copy_region	function
(	O
in	pointer
,	O
in	pointer
->	O
mark	int
,	O
in	pointer
->	O
point	int
)	O
;	O
}	O
static	O
void	O
kill_region	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
kill_save	function
(	O
in	pointer
)	O
;	O
delete_region	function
(	O
in	pointer
,	O
in	pointer
->	O
point	int
,	O
in	pointer
->	O
mark	int
)	O
;	O
}	O
static	O
void	O
yank	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
!	O
kill_buffer	pointer
)	O
return	O
;	O
for	O
(	O
p	pointer
=	O
kill_buffer	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
insert_char	function
(	O
in	pointer
,	O
*	O
p	pointer
)	O
;	O
}	O
static	O
void	O
kill_line	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
g_free	function
(	O
kill_buffer	pointer
)	O
;	O
kill_buffer	pointer
=	O
g_strdup	function
(	O
&	O
in	pointer
->	O
buffer	pointer
[	O
in	pointer
->	O
point	int
]	O
)	O
;	O
in	pointer
->	O
buffer	pointer
[	O
in	pointer
->	O
point	int
]	O
=	O
0	int
;	O
}	O
void	O
assign_text	function
(	O
WInput	struct
*	O
in	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
free_completions	function
(	O
in	pointer
)	O
;	O
g_free	function
(	O
in	pointer
->	O
buffer	pointer
)	O
;	O
in	pointer
->	O
buffer	pointer
=	O
g_strdup	function
(	O
text	pointer
)	O
;	O
in	pointer
->	O
current_max_len	int
=	O
strlen	function
(	O
in	pointer
->	O
buffer	pointer
)	O
+	O
1	int
;	O
in	pointer
->	O
point	int
=	O
strlen	function
(	O
in	pointer
->	O
buffer	pointer
)	O
;	O
in	pointer
->	O
mark	int
=	O
0	int
;	O
in	pointer
->	O
need_push	int
=	O
1	int
;	O
}	O
static	O
void	O
hist_prev	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
if	O
(	O
!	O
in	pointer
->	O
history	pointer
)	O
return	O
;	O
if	O
(	O
in	pointer
->	O
need_push	int
)	O
{	O
switch	O
(	O
push_history	function
(	O
in	pointer
,	O
in	pointer
->	O
buffer	pointer
)	O
)	O
{	O
case	O
2	int
:	O
in	pointer
->	O
history	pointer
=	O
g_list_previous	O
(	O
in	pointer
->	O
history	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
in	pointer
->	O
history	pointer
->	O
prev	pointer
)	O
in	pointer
->	O
history	pointer
=	O
g_list_previous	O
(	O
in	pointer
->	O
history	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
in	pointer
->	O
history	pointer
->	O
prev	pointer
)	O
in	pointer
->	O
history	pointer
=	O
g_list_previous	O
(	O
in	pointer
->	O
history	pointer
)	O
;	O
else	O
return	O
;	O
assign_text	function
(	O
in	pointer
,	O
(	O
char	O
*	O
)	O
in	pointer
->	O
history	pointer
->	O
data	pointer
)	O
;	O
in	pointer
->	O
need_push	int
=	O
0	int
;	O
}	O
static	O
void	O
hist_next	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
if	O
(	O
in	pointer
->	O
need_push	int
)	O
{	O
switch	O
(	O
push_history	function
(	O
in	pointer
,	O
in	pointer
->	O
buffer	pointer
)	O
)	O
{	O
case	O
2	int
:	O
assign_text	function
(	O
in	pointer
,	O
""	pointer
)	O
;	O
return	O
;	O
case	O
0	int
:	O
return	O
;	O
}	O
}	O
if	O
(	O
!	O
in	pointer
->	O
history	pointer
)	O
return	O
;	O
if	O
(	O
!	O
in	pointer
->	O
history	pointer
->	O
next	pointer
)	O
{	O
assign_text	function
(	O
in	pointer
,	O
""	pointer
)	O
;	O
return	O
;	O
}	O
in	pointer
->	O
history	pointer
=	O
g_list_next	O
(	O
in	pointer
->	O
history	pointer
)	O
;	O
assign_text	function
(	O
in	pointer
,	O
(	O
char	O
*	O
)	O
in	pointer
->	O
history	pointer
->	O
data	pointer
)	O
;	O
in	pointer
->	O
need_push	int
=	O
0	int
;	O
}	O
static	O
const	O
struct	O
{	O
int	O
key_code	int
;	O
void	O
(	O
*	O
fn	pointer
)	O
(	O
WInput	struct
*	O
in	pointer
)	O
;	O
}	O
input_map	array
[	O
]	O
=	O
{	O
{	O
XCTRL	O
(	O
'a'	O
)	O
,	O
beginning_of_line	function
}	O
,	O
{	O
KEY_HOME	int
,	O
beginning_of_line	function
}	O
,	O
{	O
KEY_A1	int
,	O
beginning_of_line	function
}	O
,	O
{	O
ALT	O
(	O
'<'	O
)	O
,	O
beginning_of_line	function
}	O
,	O
{	O
XCTRL	O
(	O
'e'	O
)	O
,	O
end_of_line	function
}	O
,	O
{	O
KEY_END	int
,	O
end_of_line	function
}	O
,	O
{	O
KEY_C1	int
,	O
end_of_line	function
}	O
,	O
{	O
ALT	O
(	O
'>'	O
)	O
,	O
end_of_line	function
}	O
,	O
{	O
KEY_LEFT	int
,	O
key_left	function
}	O
,	O
{	O
KEY_LEFT	int
|	O
KEY_M_CTRL	int
,	O
key_ctrl_left	function
}	O
,	O
{	O
XCTRL	O
(	O
'b'	O
)	O
,	O
backward_char	function
}	O
,	O
{	O
ALT	O
(	O
'b'	O
)	O
,	O
backward_word	function
}	O
,	O
{	O
KEY_RIGHT	int
,	O
key_right	function
}	O
,	O
{	O
KEY_RIGHT	int
|	O
KEY_M_CTRL	int
,	O
key_ctrl_right	function
}	O
,	O
{	O
XCTRL	O
(	O
'f'	O
)	O
,	O
forward_char	function
}	O
,	O
{	O
ALT	O
(	O
'f'	O
)	O
,	O
forward_word	function
}	O
,	O
{	O
KEY_BACKSPACE	int
,	O
backward_delete	function
}	O
,	O
{	O
KEY_DC	int
,	O
delete_char	function
}	O
,	O
{	O
ALT	O
(	O
'd'	O
)	O
,	O
kill_word	function
}	O
,	O
{	O
ALT	O
(	O
KEY_BACKSPACE	int
)	O
,	O
back_kill_word	function
}	O
,	O
{	O
0	int
,	O
set_mark	function
}	O
,	O
{	O
XCTRL	O
(	O
'w'	O
)	O
,	O
kill_region	function
}	O
,	O
{	O
ALT	O
(	O
'w'	O
)	O
,	O
kill_save	function
}	O
,	O
{	O
XCTRL	O
(	O
'y'	O
)	O
,	O
yank	function
}	O
,	O
{	O
XCTRL	O
(	O
'k'	O
)	O
,	O
kill_line	function
}	O
,	O
{	O
ALT	O
(	O
'p'	O
)	O
,	O
hist_prev	function
}	O
,	O
{	O
ALT	O
(	O
'n'	O
)	O
,	O
hist_next	function
}	O
,	O
{	O
ALT	O
(	O
'h'	O
)	O
,	O
do_show_hist	function
}	O
,	O
{	O
ALT	O
(	O
'\t'	O
)	O
,	O
complete	function
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
int	O
is_in_input_map	function
(	O
WInput	struct
*	O
in	pointer
,	O
int	O
c_code	int
)	O
{	O
int	O
i	array
;	O
(	O
void	O
)	O
in	pointer
;	O
for	O
(	O
i	array
=	O
0	int
;	O
input_map	array
[	O
i	array
]	O
.	O
fn	pointer
;	O
i	array
++	O
)	O
if	O
(	O
c_code	int
==	O
input_map	array
[	O
i	array
]	O
.	O
key_code	int
)	O
{	O
if	O
(	O
input_map	array
[	O
i	array
]	O
.	O
fn	pointer
==	O
complete	function
)	O
return	O
2	int
;	O
else	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
port_region_marked_for_delete	function
(	O
WInput	struct
*	O
in	pointer
)	O
{	O
*	O
in	pointer
->	O
buffer	pointer
=	O
0	int
;	O
in	pointer
->	O
point	int
=	O
0	int
;	O
in	pointer
->	O
first	pointer
=	O
0	int
;	O
}	O
cb_ret_t	enum
handle_char	function
(	O
WInput	struct
*	O
in	pointer
,	O
int	O
c_code	int
)	O
{	O
cb_ret_t	enum
v	pointer
;	O
int	O
i	array
;	O
v	pointer
=	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
quote	int
)	O
{	O
free_completions	function
(	O
in	pointer
)	O
;	O
v	pointer
=	O
insert_char	function
(	O
in	pointer
,	O
c_code	int
)	O
;	O
update_input	function
(	O
in	pointer
,	O
1	int
)	O
;	O
quote	int
=	O
0	int
;	O
return	O
v	pointer
;	O
}	O
for	O
(	O
i	array
=	O
0	int
;	O
input_map	array
[	O
i	array
]	O
.	O
fn	pointer
;	O
i	array
++	O
)	O
{	O
if	O
(	O
c_code	int
==	O
input_map	array
[	O
i	array
]	O
.	O
key_code	int
)	O
{	O
if	O
(	O
input_map	array
[	O
i	array
]	O
.	O
fn	pointer
!=	O
complete	function
)	O
free_completions	function
(	O
in	pointer
)	O
;	O
(	O
*	O
input_map	array
[	O
i	array
]	O
.	O
fn	pointer
)	O
(	O
in	pointer
)	O
;	O
v	pointer
=	O
MSG_HANDLED	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
input_map	array
[	O
i	array
]	O
.	O
fn	pointer
)	O
{	O
if	O
(	O
c_code	int
>	O
255	int
||	O
!	O
is_printable	function
(	O
c_code	int
)	O
)	O
return	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
in	pointer
->	O
first	pointer
)	O
{	O
port_region_marked_for_delete	function
(	O
in	pointer
)	O
;	O
}	O
free_completions	function
(	O
in	pointer
)	O
;	O
v	pointer
=	O
insert_char	function
(	O
in	pointer
,	O
c_code	int
)	O
;	O
}	O
update_input	function
(	O
in	pointer
,	O
1	int
)	O
;	O
return	O
v	pointer
;	O
}	O
void	O
stuff	function
(	O
WInput	struct
*	O
in	pointer
,	O
const	O
char	O
*	O
text	pointer
,	O
int	O
insert_extra_space	int
)	O
{	O
input_disable_update	function
(	O
in	pointer
)	O
;	O
while	O
(	O
*	O
text	pointer
)	O
handle_char	function
(	O
in	pointer
,	O
*	O
text	pointer
++	O
)	O
;	O
if	O
(	O
insert_extra_space	int
)	O
handle_char	function
(	O
in	pointer
,	O
' '	O
)	O
;	O
input_enable_update	function
(	O
in	pointer
)	O
;	O
update_input	function
(	O
in	pointer
,	O
1	int
)	O
;	O
}	O
void	O
input_set_point	function
(	O
WInput	struct
*	O
in	pointer
,	O
int	O
pos	pointer
)	O
{	O
if	O
(	O
pos	pointer
>	O
in	pointer
->	O
current_max_len	int
)	O
pos	pointer
=	O
in	pointer
->	O
current_max_len	int
;	O
if	O
(	O
pos	pointer
!=	O
in	pointer
->	O
point	int
)	O
free_completions	function
(	O
in	pointer
)	O
;	O
in	pointer
->	O
point	int
=	O
pos	pointer
;	O
update_input	function
(	O
in	pointer
,	O
1	int
)	O
;	O
}	O
cb_ret_t	enum
input_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
WInput	struct
*	O
in	pointer
=	O
(	O
WInput	struct
*	O
)	O
w	pointer
;	O
cb_ret_t	enum
v	pointer
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
WIDGET_KEY	int
:	O
if	O
(	O
parm	int
==	O
XCTRL	O
(	O
'q'	O
)	O
)	O
{	O
quote	int
=	O
1	int
;	O
v	pointer
=	O
handle_char	function
(	O
in	pointer
,	O
ascii_alpha_to_cntrl	function
(	O
mi_getch	function
(	O
)	O
)	O
)	O
;	O
quote	int
=	O
0	int
;	O
return	O
v	pointer
;	O
}	O
if	O
(	O
parm	int
==	O
KEY_UP	int
||	O
parm	int
==	O
KEY_DOWN	int
||	O
parm	int
==	O
ESC_CHAR	char
||	O
parm	int
==	O
KEY_F	O
(	O
10	int
)	O
||	O
parm	int
==	O
XCTRL	O
(	O
'g'	O
)	O
||	O
parm	int
==	O
'\n'	O
)	O
return	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
(	O
parm	int
&	O
~	O
KEY_M_MASK	int
)	O
==	O
'\n'	O
)	O
{	O
quote	int
=	O
1	int
;	O
v	pointer
=	O
handle_char	function
(	O
in	pointer
,	O
'\n'	O
)	O
;	O
quote	int
=	O
0	int
;	O
return	O
v	pointer
;	O
}	O
return	O
handle_char	function
(	O
in	pointer
,	O
parm	int
)	O
;	O
case	O
WIDGET_FOCUS	int
:	O
case	O
WIDGET_UNFOCUS	int
:	O
case	O
WIDGET_DRAW	int
:	O
update_input	function
(	O
in	pointer
,	O
0	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_CURSOR	int
:	O
widget_move	O
(	O
&	O
in	pointer
->	O
widget	pointer
,	O
0	int
,	O
in	pointer
->	O
point	int
-	O
in	pointer
->	O
first_shown	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_DESTROY	int
:	O
input_destroy	function
(	O
in	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
int	O
input_event	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
WInput	struct
*	O
in	pointer
=	O
data	pointer
;	O
if	O
(	O
event	pointer
->	O
type	enum
&	O
(	O
GPM_DOWN	int
|	O
GPM_DRAG	int
)	O
)	O
{	O
dlg_select_widget	function
(	O
in	pointer
)	O
;	O
if	O
(	O
event	pointer
->	O
x	array
>=	O
in	pointer
->	O
field_len	int
-	O
HISTORY_BUTTON_WIDTH	int
+	O
1	int
&&	O
should_show_history_button	O
(	O
in	pointer
)	O
)	O
{	O
do_show_hist	function
(	O
in	pointer
)	O
;	O
}	O
else	O
{	O
in	pointer
->	O
point	int
=	O
strlen	function
(	O
in	pointer
->	O
buffer	pointer
)	O
;	O
if	O
(	O
event	pointer
->	O
x	array
-	O
in	pointer
->	O
first_shown	int
-	O
1	int
<	O
in	pointer
->	O
point	int
)	O
in	pointer
->	O
point	int
=	O
event	pointer
->	O
x	array
-	O
in	pointer
->	O
first_shown	int
-	O
1	int
;	O
if	O
(	O
in	pointer
->	O
point	int
<	O
0	int
)	O
in	pointer
->	O
point	int
=	O
0	int
;	O
}	O
update_input	function
(	O
in	pointer
,	O
1	int
)	O
;	O
}	O
return	O
MOU_NORMAL	int
;	O
}	O
WInput	struct
*	O
input_new	function
(	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
color	short
,	O
int	O
len	int
,	O
const	O
char	O
*	O
def_text	pointer
,	O
const	O
char	O
*	O
histname	pointer
)	O
{	O
WInput	struct
*	O
in	pointer
=	O
g_new	O
(	O
WInput	struct
,	O
1	int
)	O
;	O
int	O
initial_buffer_len	int
;	O
init_widget	function
(	O
&	O
in	pointer
->	O
widget	pointer
,	O
y	short
,	O
x	array
,	O
1	int
,	O
len	int
,	O
input_callback	function
,	O
input_event	function
)	O
;	O
in	pointer
->	O
history	pointer
=	O
NULL	O
;	O
in	pointer
->	O
history_name	pointer
=	O
0	int
;	O
if	O
(	O
histname	pointer
)	O
{	O
if	O
(	O
*	O
histname	pointer
)	O
{	O
in	pointer
->	O
history_name	pointer
=	O
g_strdup	function
(	O
histname	pointer
)	O
;	O
in	pointer
->	O
history	pointer
=	O
history_get	function
(	O
histname	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
def_text	pointer
)	O
def_text	pointer
=	O
""	pointer
;	O
if	O
(	O
def_text	pointer
==	O
INPUT_LAST_TEXT	O
)	O
{	O
def_text	pointer
=	O
""	pointer
;	O
if	O
(	O
in	pointer
->	O
history	pointer
)	O
if	O
(	O
in	pointer
->	O
history	pointer
->	O
data	pointer
)	O
def_text	pointer
=	O
(	O
char	O
*	O
)	O
in	pointer
->	O
history	pointer
->	O
data	pointer
;	O
}	O
initial_buffer_len	int
=	O
1	int
+	O
max	long
(	O
(	O
size_t	long
)	O
len	int
,	O
strlen	function
(	O
def_text	pointer
)	O
)	O
;	O
in	pointer
->	O
widget	pointer
.	O
options	int
|=	O
W_IS_INPUT	O
;	O
in	pointer
->	O
completions	pointer
=	O
NULL	O
;	O
in	pointer
->	O
completion_flags	int
=	O
INPUT_COMPLETE_FILENAMES	int
|	O
INPUT_COMPLETE_HOSTNAMES	int
|	O
INPUT_COMPLETE_VARIABLES	int
|	O
INPUT_COMPLETE_USERNAMES	int
;	O
in	pointer
->	O
current_max_len	int
=	O
initial_buffer_len	int
;	O
in	pointer
->	O
buffer	pointer
=	O
g_malloc	function
(	O
initial_buffer_len	int
)	O
;	O
in	pointer
->	O
color	short
=	O
color	short
;	O
in	pointer
->	O
field_len	int
=	O
len	int
;	O
in	pointer
->	O
first	pointer
=	O
1	int
;	O
in	pointer
->	O
first_shown	int
=	O
0	int
;	O
in	pointer
->	O
disable_update	int
=	O
0	int
;	O
in	pointer
->	O
mark	int
=	O
0	int
;	O
in	pointer
->	O
need_push	int
=	O
1	int
;	O
in	pointer
->	O
is_password	int
=	O
0	int
;	O
strcpy	function
(	O
in	pointer
->	O
buffer	pointer
,	O
def_text	pointer
)	O
;	O
in	pointer
->	O
point	int
=	O
strlen	function
(	O
in	pointer
->	O
buffer	pointer
)	O
;	O
return	O
in	pointer
;	O
}	O
static	O
int	O
listbox_cdiff	function
(	O
WLEntry	struct
*	O
s	pointer
,	O
WLEntry	struct
*	O
e	pointer
)	O
;	O
static	O
void	O
listbox_drawscroll	function
(	O
WListbox	struct
*	O
l	pointer
)	O
{	O
int	O
line	int
;	O
int	O
i	array
,	O
top	pointer
;	O
int	O
max_line	int
=	O
l	pointer
->	O
height	int
-	O
1	int
;	O
widget_move	O
(	O
&	O
l	pointer
->	O
widget	pointer
,	O
0	int
,	O
l	pointer
->	O
width	int
)	O
;	O
if	O
(	O
l	pointer
->	O
list	pointer
==	O
l	pointer
->	O
top	pointer
)	O
one_vline	O
(	O
)	O
;	O
else	O
addch	O
(	O
'^'	O
)	O
;	O
widget_move	O
(	O
&	O
l	pointer
->	O
widget	pointer
,	O
max_line	int
,	O
l	pointer
->	O
width	int
)	O
;	O
top	pointer
=	O
listbox_cdiff	function
(	O
l	pointer
->	O
list	pointer
,	O
l	pointer
->	O
top	pointer
)	O
;	O
if	O
(	O
(	O
top	pointer
+	O
l	pointer
->	O
height	int
==	O
l	pointer
->	O
count	int
)	O
||	O
l	pointer
->	O
height	int
>=	O
l	pointer
->	O
count	int
)	O
one_vline	O
(	O
)	O
;	O
else	O
addch	O
(	O
'v'	O
)	O
;	O
if	O
(	O
l	pointer
->	O
count	int
)	O
line	int
=	O
1	int
+	O
(	O
(	O
l	pointer
->	O
pos	pointer
*	O
(	O
l	pointer
->	O
height	int
-	O
2	int
)	O
)	O
/	O
l	pointer
->	O
count	int
)	O
;	O
else	O
line	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
1	int
;	O
i	array
<	O
max_line	int
;	O
i	array
++	O
)	O
{	O
widget_move	O
(	O
&	O
l	pointer
->	O
widget	pointer
,	O
i	array
,	O
l	pointer
->	O
width	int
)	O
;	O
if	O
(	O
i	array
!=	O
line	int
)	O
one_vline	O
(	O
)	O
;	O
else	O
addch	O
(	O
'*'	O
)	O
;	O
}	O
}	O
static	O
void	O
listbox_draw	function
(	O
WListbox	struct
*	O
l	pointer
,	O
int	O
focused	int
)	O
{	O
WLEntry	struct
*	O
e	pointer
;	O
int	O
i	array
;	O
int	O
sel_line	int
;	O
Dlg_head	struct
*	O
h	pointer
=	O
l	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
int	O
normalc	int
=	O
DLG_NORMALC	O
(	O
h	pointer
)	O
;	O
int	O
selc	int
;	O
const	O
char	O
*	O
text	pointer
;	O
if	O
(	O
focused	int
)	O
{	O
selc	int
=	O
DLG_FOCUSC	O
(	O
h	pointer
)	O
;	O
}	O
else	O
{	O
selc	int
=	O
DLG_HOT_FOCUSC	O
(	O
h	pointer
)	O
;	O
}	O
sel_line	int
=	O
-	O
1	int
;	O
for	O
(	O
e	pointer
=	O
l	pointer
->	O
top	pointer
,	O
i	array
=	O
0	int
;	O
(	O
i	array
<	O
l	pointer
->	O
height	int
)	O
;	O
i	array
++	O
)	O
{	O
if	O
(	O
e	pointer
==	O
l	pointer
->	O
current	pointer
&&	O
sel_line	int
==	O
-	O
1	int
)	O
{	O
sel_line	int
=	O
i	array
;	O
attrset	function
(	O
selc	int
)	O
;	O
}	O
else	O
attrset	function
(	O
normalc	int
)	O
;	O
widget_move	O
(	O
&	O
l	pointer
->	O
widget	pointer
,	O
i	array
,	O
0	int
)	O
;	O
if	O
(	O
(	O
i	array
>	O
0	int
&&	O
e	pointer
==	O
l	pointer
->	O
list	pointer
)	O
||	O
!	O
l	pointer
->	O
list	pointer
)	O
text	pointer
=	O
""	pointer
;	O
else	O
{	O
text	pointer
=	O
e	pointer
->	O
text	pointer
;	O
e	pointer
=	O
e	pointer
->	O
next	pointer
;	O
}	O
tty_printf	function
(	O
" %-*s "	pointer
,	O
l	pointer
->	O
width	int
-	O
2	int
,	O
name_trunc	function
(	O
text	pointer
,	O
l	pointer
->	O
width	int
-	O
2	int
)	O
)	O
;	O
}	O
l	pointer
->	O
cursor_y	int
=	O
sel_line	int
;	O
if	O
(	O
!	O
l	pointer
->	O
scrollbar	int
)	O
return	O
;	O
attrset	function
(	O
normalc	int
)	O
;	O
listbox_drawscroll	function
(	O
l	pointer
)	O
;	O
}	O
static	O
int	O
listbox_cdiff	function
(	O
WLEntry	struct
*	O
s	pointer
,	O
WLEntry	struct
*	O
e	pointer
)	O
{	O
int	O
count	int
;	O
for	O
(	O
count	int
=	O
0	int
;	O
s	pointer
!=	O
e	pointer
;	O
count	int
++	O
)	O
s	pointer
=	O
s	pointer
->	O
next	pointer
;	O
return	O
count	int
;	O
}	O
static	O
WLEntry	struct
*	O
listbox_check_hotkey	function
(	O
WListbox	struct
*	O
l	pointer
,	O
int	O
key	pointer
)	O
{	O
int	O
i	array
;	O
WLEntry	struct
*	O
e	pointer
;	O
i	array
=	O
0	int
;	O
e	pointer
=	O
l	pointer
->	O
list	pointer
;	O
if	O
(	O
!	O
e	pointer
)	O
return	O
NULL	O
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
i	array
&&	O
e	pointer
==	O
l	pointer
->	O
list	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
e	pointer
->	O
hotkey	int
==	O
key	pointer
)	O
return	O
e	pointer
;	O
i	array
++	O
;	O
e	pointer
=	O
e	pointer
->	O
next	pointer
;	O
}	O
}	O
void	O
listbox_select_last	function
(	O
WListbox	struct
*	O
l	pointer
,	O
int	O
set_top	int
)	O
{	O
if	O
(	O
l	pointer
->	O
list	pointer
)	O
{	O
l	pointer
->	O
current	pointer
=	O
l	pointer
->	O
list	pointer
->	O
prev	pointer
;	O
l	pointer
->	O
pos	pointer
=	O
l	pointer
->	O
count	int
-	O
1	int
;	O
if	O
(	O
set_top	int
)	O
l	pointer
->	O
top	pointer
=	O
l	pointer
->	O
list	pointer
->	O
prev	pointer
;	O
}	O
}	O
void	O
listbox_remove_list	function
(	O
WListbox	struct
*	O
l	pointer
)	O
{	O
WLEntry	struct
*	O
p	pointer
,	O
*	O
q	pointer
;	O
if	O
(	O
!	O
l	pointer
->	O
count	int
)	O
return	O
;	O
p	pointer
=	O
l	pointer
->	O
list	pointer
;	O
while	O
(	O
l	pointer
->	O
count	int
--	O
)	O
{	O
q	pointer
=	O
p	pointer
->	O
next	pointer
;	O
g_free	function
(	O
p	pointer
->	O
text	pointer
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
p	pointer
=	O
q	pointer
;	O
}	O
l	pointer
->	O
pos	pointer
=	O
l	pointer
->	O
count	int
=	O
0	int
;	O
l	pointer
->	O
list	pointer
=	O
l	pointer
->	O
top	pointer
=	O
l	pointer
->	O
current	pointer
=	O
0	int
;	O
}	O
void	O
listbox_remove_current	function
(	O
WListbox	struct
*	O
l	pointer
,	O
int	O
force	int
)	O
{	O
WLEntry	struct
*	O
p	pointer
;	O
if	O
(	O
!	O
force	int
&&	O
(	O
!	O
l	pointer
->	O
count	int
||	O
l	pointer
->	O
count	int
==	O
1	int
)	O
)	O
return	O
;	O
l	pointer
->	O
count	int
--	O
;	O
p	pointer
=	O
l	pointer
->	O
current	pointer
;	O
if	O
(	O
l	pointer
->	O
count	int
)	O
{	O
l	pointer
->	O
current	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
l	pointer
->	O
current	pointer
->	O
prev	pointer
;	O
l	pointer
->	O
current	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
l	pointer
->	O
current	pointer
->	O
next	pointer
;	O
if	O
(	O
p	pointer
->	O
next	pointer
==	O
l	pointer
->	O
list	pointer
)	O
{	O
l	pointer
->	O
current	pointer
=	O
p	pointer
->	O
prev	pointer
;	O
l	pointer
->	O
pos	pointer
--	O
;	O
}	O
else	O
l	pointer
->	O
current	pointer
=	O
p	pointer
->	O
next	pointer
;	O
if	O
(	O
p	pointer
==	O
l	pointer
->	O
list	pointer
)	O
l	pointer
->	O
list	pointer
=	O
l	pointer
->	O
top	pointer
=	O
p	pointer
->	O
next	pointer
;	O
}	O
else	O
{	O
l	pointer
->	O
pos	pointer
=	O
0	int
;	O
l	pointer
->	O
list	pointer
=	O
l	pointer
->	O
top	pointer
=	O
l	pointer
->	O
current	pointer
=	O
0	int
;	O
}	O
g_free	function
(	O
p	pointer
->	O
text	pointer
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
void	O
listbox_select_entry	function
(	O
WListbox	struct
*	O
l	pointer
,	O
WLEntry	struct
*	O
dest	pointer
)	O
{	O
WLEntry	struct
*	O
e	pointer
;	O
int	O
pos	pointer
;	O
int	O
top_seen	int
;	O
top_seen	int
=	O
0	int
;	O
for	O
(	O
pos	pointer
=	O
0	int
,	O
e	pointer
=	O
l	pointer
->	O
list	pointer
;	O
pos	pointer
<	O
l	pointer
->	O
count	int
;	O
e	pointer
=	O
e	pointer
->	O
next	pointer
,	O
pos	pointer
++	O
)	O
{	O
if	O
(	O
e	pointer
==	O
l	pointer
->	O
top	pointer
)	O
top_seen	int
=	O
1	int
;	O
if	O
(	O
e	pointer
==	O
dest	pointer
)	O
{	O
l	pointer
->	O
current	pointer
=	O
e	pointer
;	O
if	O
(	O
top_seen	int
)	O
{	O
while	O
(	O
listbox_cdiff	function
(	O
l	pointer
->	O
top	pointer
,	O
l	pointer
->	O
current	pointer
)	O
>=	O
l	pointer
->	O
height	int
)	O
l	pointer
->	O
top	pointer
=	O
l	pointer
->	O
top	pointer
->	O
next	pointer
;	O
}	O
else	O
{	O
l	pointer
->	O
top	pointer
=	O
l	pointer
->	O
current	pointer
;	O
}	O
l	pointer
->	O
pos	pointer
=	O
pos	pointer
;	O
return	O
;	O
}	O
}	O
l	pointer
->	O
current	pointer
=	O
l	pointer
->	O
top	pointer
=	O
l	pointer
->	O
list	pointer
;	O
l	pointer
->	O
pos	pointer
=	O
0	int
;	O
}	O
static	O
WLEntry	struct
*	O
listbox_select_pos	function
(	O
WListbox	struct
*	O
l	pointer
,	O
WLEntry	struct
*	O
base	int
,	O
int	O
pos	pointer
)	O
{	O
WLEntry	struct
*	O
last	int
=	O
l	pointer
->	O
list	pointer
->	O
prev	pointer
;	O
if	O
(	O
base	int
==	O
last	int
)	O
return	O
last	int
;	O
while	O
(	O
pos	pointer
--	O
)	O
{	O
base	int
=	O
base	int
->	O
next	pointer
;	O
if	O
(	O
base	int
==	O
last	int
)	O
break	O
;	O
}	O
return	O
base	int
;	O
}	O
static	O
inline	O
cb_ret_t	enum
listbox_back	function
(	O
WListbox	struct
*	O
l	pointer
)	O
{	O
if	O
(	O
l	pointer
->	O
pos	pointer
)	O
{	O
listbox_select_entry	function
(	O
l	pointer
,	O
listbox_select_pos	function
(	O
l	pointer
,	O
l	pointer
->	O
list	pointer
,	O
l	pointer
->	O
pos	pointer
-	O
1	int
)	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
static	O
cb_ret_t	enum
listbox_key	function
(	O
WListbox	struct
*	O
l	pointer
,	O
int	O
key	pointer
)	O
{	O
int	O
i	array
;	O
int	O
j	int
=	O
0	int
;	O
if	O
(	O
!	O
l	pointer
->	O
list	pointer
)	O
return	O
MSG_NOT_HANDLED	int
;	O
switch	O
(	O
key	pointer
)	O
{	O
case	O
KEY_HOME	int
:	O
case	O
KEY_A1	int
:	O
case	O
ALT	O
(	O
'<'	O
)	O
:	O
l	pointer
->	O
current	pointer
=	O
l	pointer
->	O
top	pointer
=	O
l	pointer
->	O
list	pointer
;	O
l	pointer
->	O
pos	pointer
=	O
0	int
;	O
return	O
MSG_HANDLED	int
;	O
case	O
KEY_END	int
:	O
case	O
KEY_C1	int
:	O
case	O
ALT	O
(	O
'>'	O
)	O
:	O
l	pointer
->	O
current	pointer
=	O
l	pointer
->	O
top	pointer
=	O
l	pointer
->	O
list	pointer
->	O
prev	pointer
;	O
for	O
(	O
i	array
=	O
min	long
(	O
l	pointer
->	O
height	int
-	O
1	int
,	O
l	pointer
->	O
count	int
-	O
1	int
)	O
;	O
i	array
;	O
i	array
--	O
)	O
l	pointer
->	O
top	pointer
=	O
l	pointer
->	O
top	pointer
->	O
prev	pointer
;	O
l	pointer
->	O
pos	pointer
=	O
l	pointer
->	O
count	int
-	O
1	int
;	O
return	O
MSG_HANDLED	int
;	O
case	O
XCTRL	O
(	O
'p'	O
)	O
:	O
case	O
KEY_UP	int
:	O
listbox_back	function
(	O
l	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
XCTRL	O
(	O
'n'	O
)	O
:	O
case	O
KEY_DOWN	int
:	O
listbox_fwd	function
(	O
l	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
KEY_NPAGE	int
:	O
case	O
XCTRL	O
(	O
'v'	O
)	O
:	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
l	pointer
->	O
height	int
-	O
1	int
;	O
i	array
++	O
)	O
j	int
|=	O
listbox_fwd	function
(	O
l	pointer
)	O
;	O
return	O
(	O
j	int
>	O
0	int
)	O
?	O
MSG_HANDLED	int
:	O
MSG_NOT_HANDLED	int
;	O
case	O
KEY_PPAGE	int
:	O
case	O
ALT	O
(	O
'v'	O
)	O
:	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
l	pointer
->	O
height	int
-	O
1	int
;	O
i	array
++	O
)	O
j	int
|=	O
listbox_back	function
(	O
l	pointer
)	O
;	O
return	O
(	O
j	int
>	O
0	int
)	O
?	O
MSG_HANDLED	int
:	O
MSG_NOT_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
static	O
void	O
listbox_destroy	function
(	O
WListbox	struct
*	O
l	pointer
)	O
{	O
WLEntry	struct
*	O
n	long
,	O
*	O
p	pointer
=	O
l	pointer
->	O
list	pointer
;	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
l	pointer
->	O
count	int
;	O
i	array
++	O
)	O
{	O
n	long
=	O
p	pointer
->	O
next	pointer
;	O
g_free	function
(	O
p	pointer
->	O
text	pointer
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
p	pointer
=	O
n	long
;	O
}	O
}	O
static	O
cb_ret_t	enum
listbox_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
WListbox	struct
*	O
l	pointer
=	O
(	O
WListbox	struct
*	O
)	O
w	pointer
;	O
cb_ret_t	enum
ret_code	enum
;	O
WLEntry	struct
*	O
e	pointer
;	O
Dlg_head	struct
*	O
h	pointer
=	O
l	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
WIDGET_INIT	int
:	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_HOTKEY	int
:	O
if	O
(	O
(	O
e	pointer
=	O
listbox_check_hotkey	function
(	O
l	pointer
,	O
parm	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
int	O
action	int
;	O
listbox_select_entry	function
(	O
l	pointer
,	O
e	pointer
)	O
;	O
if	O
(	O
l	pointer
->	O
cback	pointer
)	O
action	int
=	O
(	O
*	O
l	pointer
->	O
cback	pointer
)	O
(	O
l	pointer
)	O
;	O
else	O
action	int
=	O
LISTBOX_DONE	int
;	O
if	O
(	O
action	int
==	O
LISTBOX_DONE	int
)	O
{	O
h	pointer
->	O
ret_value	int
=	O
B_ENTER	int
;	O
dlg_stop	function
(	O
h	pointer
)	O
;	O
}	O
return	O
MSG_HANDLED	int
;	O
}	O
else	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
WIDGET_KEY	int
:	O
if	O
(	O
(	O
ret_code	enum
=	O
listbox_key	function
(	O
l	pointer
,	O
parm	int
)	O
)	O
)	O
listbox_draw	function
(	O
l	pointer
,	O
1	int
)	O
;	O
return	O
ret_code	enum
;	O
case	O
WIDGET_CURSOR	int
:	O
widget_move	O
(	O
&	O
l	pointer
->	O
widget	pointer
,	O
l	pointer
->	O
cursor_y	int
,	O
0	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_FOCUS	int
:	O
case	O
WIDGET_UNFOCUS	int
:	O
case	O
WIDGET_DRAW	int
:	O
listbox_draw	function
(	O
l	pointer
,	O
msg	pointer
!=	O
WIDGET_UNFOCUS	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_DESTROY	int
:	O
listbox_destroy	function
(	O
l	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
int	O
listbox_event	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
WListbox	struct
*	O
l	pointer
=	O
data	pointer
;	O
Widget	struct
*	O
w	pointer
=	O
data	pointer
;	O
int	O
i	array
;	O
Dlg_head	struct
*	O
h	pointer
=	O
l	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
if	O
(	O
event	pointer
->	O
type	enum
&	O
GPM_DOWN	int
)	O
dlg_select_widget	function
(	O
l	pointer
)	O
;	O
if	O
(	O
!	O
l	pointer
->	O
list	pointer
)	O
return	O
MOU_NORMAL	int
;	O
if	O
(	O
event	pointer
->	O
type	enum
&	O
(	O
GPM_DOWN	int
|	O
GPM_DRAG	int
)	O
)	O
{	O
if	O
(	O
event	pointer
->	O
x	array
<	O
0	int
||	O
event	pointer
->	O
x	array
>=	O
l	pointer
->	O
width	int
)	O
return	O
MOU_REPEAT	int
;	O
if	O
(	O
event	pointer
->	O
y	short
<	O
1	int
)	O
for	O
(	O
i	array
=	O
-	O
event	pointer
->	O
y	short
;	O
i	array
>=	O
0	int
;	O
i	array
--	O
)	O
listbox_back	function
(	O
l	pointer
)	O
;	O
else	O
if	O
(	O
event	pointer
->	O
y	short
>	O
l	pointer
->	O
height	int
)	O
for	O
(	O
i	array
=	O
event	pointer
->	O
y	short
-	O
l	pointer
->	O
height	int
;	O
i	array
>	O
0	int
;	O
i	array
--	O
)	O
listbox_fwd	function
(	O
l	pointer
)	O
;	O
else	O
listbox_select_entry	function
(	O
l	pointer
,	O
listbox_select_pos	function
(	O
l	pointer
,	O
l	pointer
->	O
top	pointer
,	O
event	pointer
->	O
y	short
-	O
1	int
)	O
)	O
;	O
listbox_callback	function
(	O
w	pointer
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
return	O
MOU_REPEAT	int
;	O
}	O
if	O
(	O
(	O
event	pointer
->	O
type	enum
&	O
(	O
GPM_DOUBLE	int
|	O
GPM_UP	int
)	O
)	O
==	O
(	O
GPM_UP	int
|	O
GPM_DOUBLE	int
)	O
)	O
{	O
int	O
action	int
;	O
if	O
(	O
event	pointer
->	O
x	array
<	O
0	int
||	O
event	pointer
->	O
x	array
>=	O
l	pointer
->	O
width	int
)	O
return	O
MOU_NORMAL	int
;	O
if	O
(	O
event	pointer
->	O
y	short
<	O
1	int
||	O
event	pointer
->	O
y	short
>	O
l	pointer
->	O
height	int
)	O
return	O
MOU_NORMAL	int
;	O
dlg_select_widget	function
(	O
l	pointer
)	O
;	O
listbox_select_entry	function
(	O
l	pointer
,	O
listbox_select_pos	function
(	O
l	pointer
,	O
l	pointer
->	O
top	pointer
,	O
event	pointer
->	O
y	short
-	O
1	int
)	O
)	O
;	O
if	O
(	O
l	pointer
->	O
cback	pointer
)	O
action	int
=	O
(	O
*	O
l	pointer
->	O
cback	pointer
)	O
(	O
l	pointer
)	O
;	O
else	O
action	int
=	O
LISTBOX_DONE	int
;	O
if	O
(	O
action	int
==	O
LISTBOX_DONE	int
)	O
{	O
h	pointer
->	O
ret_value	int
=	O
B_ENTER	int
;	O
dlg_stop	function
(	O
h	pointer
)	O
;	O
return	O
MOU_NORMAL	int
;	O
}	O
}	O
return	O
MOU_NORMAL	int
;	O
}	O
WListbox	struct
*	O
listbox_new	function
(	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
width	int
,	O
int	O
height	int
,	O
lcback	pointer
callback	pointer
)	O
{	O
WListbox	struct
*	O
l	pointer
=	O
g_new	O
(	O
WListbox	struct
,	O
1	int
)	O
;	O
init_widget	function
(	O
&	O
l	pointer
->	O
widget	pointer
,	O
y	short
,	O
x	array
,	O
height	int
,	O
width	int
,	O
listbox_callback	function
,	O
listbox_event	function
)	O
;	O
l	pointer
->	O
list	pointer
=	O
l	pointer
->	O
top	pointer
=	O
l	pointer
->	O
current	pointer
=	O
0	int
;	O
l	pointer
->	O
pos	pointer
=	O
0	int
;	O
l	pointer
->	O
width	int
=	O
width	int
;	O
if	O
(	O
height	int
<=	O
0	int
)	O
l	pointer
->	O
height	int
=	O
1	int
;	O
else	O
l	pointer
->	O
height	int
=	O
height	int
;	O
l	pointer
->	O
count	int
=	O
0	int
;	O
l	pointer
->	O
top	pointer
=	O
0	int
;	O
l	pointer
->	O
current	pointer
=	O
0	int
;	O
l	pointer
->	O
cback	pointer
=	O
callback	pointer
;	O
l	pointer
->	O
allow_duplicates	int
=	O
1	int
;	O
l	pointer
->	O
scrollbar	int
=	O
slow_terminal	int
?	O
0	int
:	O
1	int
;	O
widget_want_hotkey	O
(	O
l	pointer
->	O
widget	pointer
,	O
1	int
)	O
;	O
return	O
l	pointer
;	O
}	O
static	O
void	O
listbox_append_item	function
(	O
WListbox	struct
*	O
l	pointer
,	O
WLEntry	struct
*	O
e	pointer
,	O
enum	O
append_pos	enum
pos	pointer
)	O
{	O
if	O
(	O
!	O
l	pointer
->	O
list	pointer
)	O
{	O
l	pointer
->	O
list	pointer
=	O
e	pointer
;	O
l	pointer
->	O
top	pointer
=	O
e	pointer
;	O
l	pointer
->	O
current	pointer
=	O
e	pointer
;	O
e	pointer
->	O
next	pointer
=	O
l	pointer
->	O
list	pointer
;	O
e	pointer
->	O
prev	pointer
=	O
l	pointer
->	O
list	pointer
;	O
}	O
else	O
if	O
(	O
pos	pointer
==	O
LISTBOX_APPEND_AT_END	int
)	O
{	O
e	pointer
->	O
next	pointer
=	O
l	pointer
->	O
list	pointer
;	O
e	pointer
->	O
prev	pointer
=	O
l	pointer
->	O
list	pointer
->	O
prev	pointer
;	O
l	pointer
->	O
list	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
e	pointer
;	O
l	pointer
->	O
list	pointer
->	O
prev	pointer
=	O
e	pointer
;	O
}	O
else	O
if	O
(	O
pos	pointer
==	O
LISTBOX_APPEND_BEFORE	int
)	O
{	O
e	pointer
->	O
next	pointer
=	O
l	pointer
->	O
current	pointer
;	O
e	pointer
->	O
prev	pointer
=	O
l	pointer
->	O
current	pointer
->	O
prev	pointer
;	O
l	pointer
->	O
current	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
e	pointer
;	O
l	pointer
->	O
current	pointer
->	O
prev	pointer
=	O
e	pointer
;	O
if	O
(	O
l	pointer
->	O
list	pointer
==	O
l	pointer
->	O
current	pointer
)	O
{	O
l	pointer
->	O
list	pointer
=	O
e	pointer
;	O
l	pointer
->	O
top	pointer
=	O
e	pointer
;	O
}	O
}	O
else	O
if	O
(	O
pos	pointer
==	O
LISTBOX_APPEND_AFTER	int
)	O
{	O
e	pointer
->	O
prev	pointer
=	O
l	pointer
->	O
current	pointer
;	O
e	pointer
->	O
next	pointer
=	O
l	pointer
->	O
current	pointer
->	O
next	pointer
;	O
l	pointer
->	O
current	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
e	pointer
;	O
l	pointer
->	O
current	pointer
->	O
next	pointer
=	O
e	pointer
;	O
}	O
l	pointer
->	O
count	int
++	O
;	O
}	O
char	O
*	O
listbox_add_item	function
(	O
WListbox	struct
*	O
l	pointer
,	O
enum	O
append_pos	enum
pos	pointer
,	O
int	O
hotkey	int
,	O
const	O
char	O
*	O
text	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
WLEntry	struct
*	O
entry	pointer
;	O
if	O
(	O
!	O
l	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
l	pointer
->	O
allow_duplicates	int
)	O
if	O
(	O
listbox_search_text	function
(	O
l	pointer
,	O
text	pointer
)	O
)	O
return	O
NULL	O
;	O
entry	pointer
=	O
g_new	O
(	O
WLEntry	struct
,	O
1	int
)	O
;	O
entry	pointer
->	O
text	pointer
=	O
g_strdup	function
(	O
text	pointer
)	O
;	O
entry	pointer
->	O
data	pointer
=	O
data	pointer
;	O
entry	pointer
->	O
hotkey	int
=	O
hotkey	int
;	O
listbox_append_item	function
(	O
l	pointer
,	O
entry	pointer
,	O
pos	pointer
)	O
;	O
return	O
entry	pointer
->	O
text	pointer
;	O
}	O
void	O
listbox_select_by_number	function
(	O
WListbox	struct
*	O
l	pointer
,	O
int	O
n	long
)	O
{	O
listbox_select_entry	function
(	O
l	pointer
,	O
listbox_select_pos	function
(	O
l	pointer
,	O
l	pointer
->	O
list	pointer
,	O
n	long
)	O
)	O
;	O
}	O
WLEntry	struct
*	O
listbox_search_text	function
(	O
WListbox	struct
*	O
l	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
WLEntry	struct
*	O
e	pointer
;	O
e	pointer
=	O
l	pointer
->	O
list	pointer
;	O
if	O
(	O
!	O
e	pointer
)	O
return	O
NULL	O
;	O
do	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
e	pointer
->	O
text	pointer
,	O
text	pointer
)	O
)	O
return	O
e	pointer
;	O
e	pointer
=	O
e	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
e	pointer
!=	O
l	pointer
->	O
list	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
void	O
listbox_get_current	function
(	O
WListbox	struct
*	O
l	pointer
,	O
char	O
*	O
*	O
string	pointer
,	O
char	O
*	O
*	O
extra	pointer
)	O
{	O
if	O
(	O
!	O
l	pointer
->	O
current	pointer
)	O
{	O
*	O
string	pointer
=	O
0	int
;	O
*	O
extra	pointer
=	O
0	int
;	O
}	O
if	O
(	O
string	pointer
&&	O
l	pointer
->	O
current	pointer
)	O
*	O
string	pointer
=	O
l	pointer
->	O
current	pointer
->	O
text	pointer
;	O
if	O
(	O
extra	pointer
&&	O
l	pointer
->	O
current	pointer
)	O
*	O
extra	pointer
=	O
l	pointer
->	O
current	pointer
->	O
data	pointer
;	O
}	O
static	O
gboolean	int
buttonbar_call	function
(	O
WButtonBar	struct
*	O
bb	pointer
,	O
int	O
i	array
)	O
{	O
switch	O
(	O
bb	pointer
->	O
labels	array
[	O
i	array
]	O
.	O
tag	int
)	O
{	O
case	O
BBFUNC_NONE	int
:	O
break	O
;	O
case	O
BBFUNC_VOID	int
:	O
bb	pointer
->	O
labels	array
[	O
i	array
]	O
.	O
u	union
.	O
fn_void	pointer
(	O
)	O
;	O
return	O
TRUE	O
;	O
case	O
BBFUNC_PTR	int
:	O
bb	pointer
->	O
labels	array
[	O
i	array
]	O
.	O
u	union
.	O
fn_ptr	pointer
(	O
bb	pointer
->	O
labels	array
[	O
i	array
]	O
.	O
data	pointer
)	O
;	O
return	O
TRUE	O
;	O
}	O
return	O
FALSE	O
;	O
}	O
static	O
cb_ret_t	enum
buttonbar_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
WButtonBar	struct
*	O
bb	pointer
=	O
(	O
WButtonBar	struct
*	O
)	O
w	pointer
;	O
int	O
i	array
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
WIDGET_FOCUS	int
:	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
WIDGET_HOTKEY	int
:	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
10	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
parm	int
==	O
KEY_F	O
(	O
i	array
+	O
1	int
)	O
&&	O
buttonbar_call	function
(	O
bb	pointer
,	O
i	array
)	O
)	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
WIDGET_DRAW	int
:	O
if	O
(	O
!	O
bb	pointer
->	O
visible	int
)	O
return	O
MSG_HANDLED	int
;	O
widget_move	O
(	O
&	O
bb	pointer
->	O
widget	pointer
,	O
0	int
,	O
0	int
)	O
;	O
attrset	function
(	O
DEFAULT_COLOR	O
)	O
;	O
tty_printf	function
(	O
"%-*s"	pointer
,	O
bb	pointer
->	O
widget	pointer
.	O
cols	int
,	O
""	pointer
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
COLS	O
/	O
8	int
&&	O
i	array
<	O
10	int
;	O
i	array
++	O
)	O
{	O
widget_move	O
(	O
&	O
bb	pointer
->	O
widget	pointer
,	O
0	int
,	O
i	array
*	O
8	int
)	O
;	O
attrset	function
(	O
DEFAULT_COLOR	O
)	O
;	O
tty_printf	function
(	O
"%d"	pointer
,	O
i	array
+	O
1	int
)	O
;	O
attrset	function
(	O
SELECTED_COLOR	O
)	O
;	O
tty_printf	function
(	O
"%-*s"	pointer
,	O
(	O
(	O
i	array
+	O
1	int
)	O
*	O
8	int
==	O
COLS	O
?	O
5	int
:	O
6	int
)	O
,	O
bb	pointer
->	O
labels	array
[	O
i	array
]	O
.	O
text	pointer
?	O
bb	pointer
->	O
labels	array
[	O
i	array
]	O
.	O
text	pointer
:	O
""	pointer
)	O
;	O
attrset	function
(	O
DEFAULT_COLOR	O
)	O
;	O
}	O
attrset	function
(	O
SELECTED_COLOR	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_DESTROY	int
:	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
10	int
;	O
i	array
++	O
)	O
g_free	function
(	O
bb	pointer
->	O
labels	array
[	O
i	array
]	O
.	O
text	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
int	O
buttonbar_event	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
WButtonBar	struct
*	O
bb	pointer
=	O
data	pointer
;	O
int	O
button	int
;	O
if	O
(	O
!	O
(	O
event	pointer
->	O
type	enum
&	O
GPM_UP	int
)	O
)	O
return	O
MOU_NORMAL	int
;	O
if	O
(	O
event	pointer
->	O
y	short
==	O
2	int
)	O
return	O
MOU_NORMAL	int
;	O
button	int
=	O
event	pointer
->	O
x	array
/	O
8	int
;	O
if	O
(	O
button	int
<	O
10	int
)	O
buttonbar_call	function
(	O
bb	pointer
,	O
button	int
)	O
;	O
return	O
MOU_NORMAL	int
;	O
}	O
WButtonBar	struct
*	O
buttonbar_new	function
(	O
int	O
visible	int
)	O
{	O
int	O
i	array
;	O
WButtonBar	struct
*	O
bb	pointer
=	O
g_new	O
(	O
WButtonBar	struct
,	O
1	int
)	O
;	O
init_widget	function
(	O
&	O
bb	pointer
->	O
widget	pointer
,	O
LINES	O
-	O
1	int
,	O
0	int
,	O
1	int
,	O
COLS	O
,	O
buttonbar_callback	function
,	O
buttonbar_event	function
)	O
;	O
bb	pointer
->	O
visible	int
=	O
visible	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
10	int
;	O
i	array
++	O
)	O
{	O
bb	pointer
->	O
labels	array
[	O
i	array
]	O
.	O
text	pointer
=	O
NULL	O
;	O
bb	pointer
->	O
labels	array
[	O
i	array
]	O
.	O
tag	int
=	O
BBFUNC_NONE	int
;	O
}	O
widget_want_hotkey	O
(	O
bb	pointer
->	O
widget	pointer
,	O
1	int
)	O
;	O
widget_want_cursor	O
(	O
bb	pointer
->	O
widget	pointer
,	O
0	int
)	O
;	O
return	O
bb	pointer
;	O
}	O
static	O
void	O
set_label_text	function
(	O
WButtonBar	struct
*	O
bb	pointer
,	O
int	O
index	function
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
g_free	function
(	O
bb	pointer
->	O
labels	array
[	O
index	function
-	O
1	int
]	O
.	O
text	pointer
)	O
;	O
bb	pointer
->	O
labels	array
[	O
index	function
-	O
1	int
]	O
.	O
text	pointer
=	O
g_strdup	function
(	O
text	pointer
)	O
;	O
}	O
WButtonBar	struct
*	O
find_buttonbar	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
WButtonBar	struct
*	O
bb	pointer
;	O
bb	pointer
=	O
(	O
WButtonBar	struct
*	O
)	O
find_widget_type	function
(	O
h	pointer
,	O
buttonbar_callback	function
)	O
;	O
return	O
bb	pointer
;	O
}	O
void	O
buttonbar_clear_label	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
idx	int
)	O
{	O
WButtonBar	struct
*	O
bb	pointer
=	O
find_buttonbar	function
(	O
h	pointer
)	O
;	O
if	O
(	O
!	O
bb	pointer
)	O
return	O
;	O
set_label_text	function
(	O
bb	pointer
,	O
idx	int
,	O
""	pointer
)	O
;	O
bb	pointer
->	O
labels	array
[	O
idx	int
-	O
1	int
]	O
.	O
tag	int
=	O
BBFUNC_NONE	int
;	O
}	O
void	O
buttonbar_set_label_data	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
idx	int
,	O
const	O
char	O
*	O
text	pointer
,	O
buttonbarfn	pointer
cback	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
WButtonBar	struct
*	O
bb	pointer
=	O
find_buttonbar	function
(	O
h	pointer
)	O
;	O
if	O
(	O
!	O
bb	pointer
)	O
return	O
;	O
assert	O
(	O
cback	pointer
!=	O
(	O
buttonbarfn	pointer
)	O
0	int
)	O
;	O
set_label_text	function
(	O
bb	pointer
,	O
idx	int
,	O
text	pointer
)	O
;	O
bb	pointer
->	O
labels	array
[	O
idx	int
-	O
1	int
]	O
.	O
tag	int
=	O
BBFUNC_PTR	int
;	O
bb	pointer
->	O
labels	array
[	O
idx	int
-	O
1	int
]	O
.	O
u	union
.	O
fn_ptr	pointer
=	O
cback	pointer
;	O
bb	pointer
->	O
labels	array
[	O
idx	int
-	O
1	int
]	O
.	O
data	pointer
=	O
data	pointer
;	O
}	O
void	O
buttonbar_set_label	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
idx	int
,	O
const	O
char	O
*	O
text	pointer
,	O
voidfn	pointer
cback	pointer
)	O
{	O
WButtonBar	struct
*	O
bb	pointer
=	O
find_buttonbar	function
(	O
h	pointer
)	O
;	O
if	O
(	O
!	O
bb	pointer
)	O
return	O
;	O
assert	O
(	O
cback	pointer
!=	O
(	O
voidfn	pointer
)	O
0	int
)	O
;	O
set_label_text	function
(	O
bb	pointer
,	O
idx	int
,	O
text	pointer
)	O
;	O
bb	pointer
->	O
labels	array
[	O
idx	int
-	O
1	int
]	O
.	O
tag	int
=	O
BBFUNC_VOID	int
;	O
bb	pointer
->	O
labels	array
[	O
idx	int
-	O
1	int
]	O
.	O
u	union
.	O
fn_void	pointer
=	O
cback	pointer
;	O
}	O
void	O
buttonbar_set_visible	function
(	O
WButtonBar	struct
*	O
bb	pointer
,	O
gboolean	int
visible	int
)	O
{	O
bb	pointer
->	O
visible	int
=	O
visible	int
;	O
}	O
void	O
buttonbar_redraw	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
WButtonBar	struct
*	O
bb	pointer
=	O
find_buttonbar	function
(	O
h	pointer
)	O
;	O
if	O
(	O
!	O
bb	pointer
)	O
return	O
;	O
send_message	function
(	O
(	O
Widget	struct
*	O
)	O
bb	pointer
,	O
WIDGET_DRAW	int
,	O
0	int
)	O
;	O
}	O
static	O
cb_ret_t	enum
groupbox_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
WGroupbox	struct
*	O
g	pointer
=	O
(	O
WGroupbox	struct
*	O
)	O
w	pointer
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
WIDGET_INIT	int
:	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_FOCUS	int
:	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
WIDGET_DRAW	int
:	O
attrset	function
(	O
COLOR_NORMAL	O
)	O
;	O
draw_box	function
(	O
g	pointer
->	O
widget	pointer
.	O
parent	pointer
,	O
g	pointer
->	O
widget	pointer
.	O
y	short
-	O
g	pointer
->	O
widget	pointer
.	O
parent	pointer
->	O
y	short
,	O
g	pointer
->	O
widget	pointer
.	O
x	array
-	O
g	pointer
->	O
widget	pointer
.	O
parent	pointer
->	O
x	array
,	O
g	pointer
->	O
widget	pointer
.	O
lines	pointer
,	O
g	pointer
->	O
widget	pointer
.	O
cols	int
)	O
;	O
attrset	function
(	O
COLOR_HOT_NORMAL	O
)	O
;	O
dlg_move	O
(	O
g	pointer
->	O
widget	pointer
.	O
parent	pointer
,	O
g	pointer
->	O
widget	pointer
.	O
y	short
-	O
g	pointer
->	O
widget	pointer
.	O
parent	pointer
->	O
y	short
,	O
g	pointer
->	O
widget	pointer
.	O
x	array
-	O
g	pointer
->	O
widget	pointer
.	O
parent	pointer
->	O
x	array
+	O
1	int
)	O
;	O
addstr	O
(	O
g	pointer
->	O
title	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_DESTROY	int
:	O
g_free	function
(	O
g	pointer
->	O
title	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
WGroupbox	struct
*	O
groupbox_new	function
(	O
int	O
x	array
,	O
int	O
y	short
,	O
int	O
width	int
,	O
int	O
height	int
,	O
const	O
char	O
*	O
title	pointer
)	O
{	O
WGroupbox	struct
*	O
g	pointer
=	O
g_new	O
(	O
WGroupbox	struct
,	O
1	int
)	O
;	O
init_widget	function
(	O
&	O
g	pointer
->	O
widget	pointer
,	O
y	short
,	O
x	array
,	O
height	int
,	O
width	int
,	O
groupbox_callback	function
,	O
NULL	O
)	O
;	O
g	pointer
->	O
widget	pointer
.	O
options	int
&=	O
~	O
W_WANT_CURSOR	O
;	O
widget_want_hotkey	O
(	O
g	pointer
->	O
widget	pointer
,	O
0	int
)	O
;	O
if	O
(	O
title	pointer
)	O
{	O
char	O
*	O
t	long
;	O
t	long
=	O
g_strstrip	O
(	O
g_strdup	function
(	O
title	pointer
)	O
)	O
;	O
g	pointer
->	O
title	pointer
=	O
g_strconcat	function
(	O
" "	pointer
,	O
t	long
,	O
" "	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
g_free	function
(	O
t	long
)	O
;	O
}	O
return	O
g	pointer
;	O
}	O
