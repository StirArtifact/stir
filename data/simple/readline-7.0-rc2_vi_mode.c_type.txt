int	O
_rl_vi_last_command	int
=	O
'i'	O
;	O
_rl_vimotion_cxt	struct
*	O
_rl_vimvcxt	pointer
=	O
0	int
;	O
int	O
_rl_vi_redoing	int
;	O
static	O
int	O
_rl_vi_doing_insert	int
;	O
static	O
const	O
char	O
*	O
const	O
vi_motion	pointer
=	O
" hl^$0ftFT;,%wbeWBE|`"	pointer
;	O
static	O
Keymap	pointer
vi_replace_map	pointer
;	O
static	O
int	O
vi_replace_count	int
;	O
static	O
int	O
vi_continued_command	int
;	O
static	O
char	O
*	O
vi_insert_buffer	pointer
;	O
static	O
int	O
vi_insert_buffer_size	int
;	O
static	O
int	O
_rl_vi_last_repeat	int
=	O
1	int
;	O
static	O
int	O
_rl_vi_last_arg_sign	int
=	O
1	int
;	O
static	O
int	O
_rl_vi_last_motion	int
;	O
static	O
char	O
_rl_vi_last_search_mbchar	array
[	O
MB_LEN_MAX	int
]	O
;	O
static	O
int	O
_rl_vi_last_search_mblen	int
;	O
static	O
int	O
_rl_vi_last_replacement	int
;	O
static	O
int	O
_rl_vi_last_key_before_insert	int
;	O
static	O
const	O
char	O
*	O
const	O
vi_textmod	pointer
=	O
"_*\\AaIiCcDdPpYyRrSsXx~"	pointer
;	O
static	O
int	O
vi_mark_chars	array
[	O
'z'	O
-	O
'a'	O
+	O
1	int
]	O
;	O
static	O
void	O
_rl_vi_replace_insert	function
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
_rl_vi_save_replace	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
_rl_vi_stuff_insert	function
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
_rl_vi_save_insert	function
PARAMS	O
(	O
(	O
UNDO_LIST	struct
*	O
)	O
)	O
;	O
static	O
void	O
vi_save_insert_buffer	function
PARAMS	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
_rl_vi_backup	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_arg_dispatch	function
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
rl_digit_loop1	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_set_mark	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_goto_mark	function
PARAMS	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
_rl_vi_append_forward	function
PARAMS	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_callback_getchar	function
PARAMS	O
(	O
(	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_callback_set_mark	function
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct
*	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_callback_goto_mark	function
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct
*	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_callback_change_char	function
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct
*	O
)	O
)	O
;	O
static	O
int	O
_rl_vi_callback_char_search	function
PARAMS	O
(	O
(	O
_rl_callback_generic_arg	struct
*	O
)	O
)	O
;	O
static	O
int	O
rl_domove_read_callback	function
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct
*	O
)	O
)	O
;	O
static	O
int	O
rl_domove_motion_callback	function
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct
*	O
)	O
)	O
;	O
static	O
int	O
rl_vi_domove_getchar	function
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct
*	O
)	O
)	O
;	O
static	O
int	O
vi_change_dispatch	function
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct
*	O
)	O
)	O
;	O
static	O
int	O
vi_delete_dispatch	function
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct
*	O
)	O
)	O
;	O
static	O
int	O
vi_yank_dispatch	function
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct
*	O
)	O
)	O
;	O
static	O
int	O
vidomove_dispatch	function
PARAMS	O
(	O
(	O
_rl_vimotion_cxt	struct
*	O
)	O
)	O
;	O
void	O
_rl_vi_initialize_line	function
(	O
)	O
{	O
register	O
int	O
i	int
,	O
n	int
;	O
n	int
=	O
sizeof	O
(	O
vi_mark_chars	array
)	O
/	O
sizeof	O
(	O
vi_mark_chars	array
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
vi_mark_chars	array
[	O
i	int
]	O
=	O
-	O
1	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_VICMDONCE	int
)	O
;	O
}	O
void	O
_rl_vi_reset_last	function
(	O
)	O
{	O
_rl_vi_last_command	int
=	O
'i'	O
;	O
_rl_vi_last_repeat	int
=	O
1	int
;	O
_rl_vi_last_arg_sign	int
=	O
1	int
;	O
_rl_vi_last_motion	int
=	O
0	int
;	O
}	O
void	O
_rl_vi_set_last	function
(	O
key	int
,	O
repeat	int
,	O
sign	int
)	O
int	O
key	int
,	O
repeat	int
,	O
sign	int
;	O
{	O
_rl_vi_last_command	int
=	O
key	int
;	O
_rl_vi_last_repeat	int
=	O
repeat	int
;	O
_rl_vi_last_arg_sign	int
=	O
sign	int
;	O
}	O
void	O
rl_vi_start_inserting	function
(	O
key	int
,	O
repeat	int
,	O
sign	int
)	O
int	O
key	int
,	O
repeat	int
,	O
sign	int
;	O
{	O
_rl_vi_set_last	function
(	O
key	int
,	O
repeat	int
,	O
sign	int
)	O
;	O
rl_vi_insertion_mode	function
(	O
1	int
,	O
key	int
)	O
;	O
}	O
int	O
_rl_vi_textmod_command	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
return	O
(	O
member	O
(	O
c	int
,	O
vi_textmod	pointer
)	O
)	O
;	O
}	O
int	O
_rl_vi_motion_command	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
return	O
(	O
member	O
(	O
c	int
,	O
vi_motion	pointer
)	O
)	O
;	O
}	O
static	O
void	O
_rl_vi_replace_insert	function
(	O
count	int
)	O
int	O
count	int
;	O
{	O
int	O
nchars	int
;	O
nchars	int
=	O
strlen	function
(	O
vi_insert_buffer	pointer
)	O
;	O
rl_begin_undo_group	function
(	O
)	O
;	O
while	O
(	O
count	int
--	O
)	O
_rl_replace_text	function
(	O
vi_insert_buffer	pointer
,	O
rl_point	int
,	O
rl_point	int
+	O
nchars	int
-	O
1	int
)	O
;	O
rl_end_undo_group	function
(	O
)	O
;	O
}	O
static	O
void	O
_rl_vi_stuff_insert	function
(	O
count	int
)	O
int	O
count	int
;	O
{	O
rl_begin_undo_group	function
(	O
)	O
;	O
while	O
(	O
count	int
--	O
)	O
rl_insert_text	function
(	O
vi_insert_buffer	pointer
)	O
;	O
rl_end_undo_group	function
(	O
)	O
;	O
}	O
int	O
rl_vi_redo	function
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
int	O
r	int
;	O
if	O
(	O
rl_explicit_arg	int
==	O
0	int
)	O
{	O
rl_numeric_arg	int
=	O
_rl_vi_last_repeat	int
;	O
rl_arg_sign	int
=	O
_rl_vi_last_arg_sign	int
;	O
}	O
r	int
=	O
0	int
;	O
_rl_vi_redoing	int
=	O
1	int
;	O
if	O
(	O
_rl_vi_last_command	int
==	O
'i'	O
&&	O
vi_insert_buffer	pointer
&&	O
*	O
vi_insert_buffer	pointer
)	O
{	O
_rl_vi_stuff_insert	function
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
_rl_vi_backup	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_last_command	int
==	O
'R'	O
&&	O
vi_insert_buffer	pointer
&&	O
*	O
vi_insert_buffer	pointer
)	O
{	O
_rl_vi_replace_insert	function
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
_rl_vi_backup	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_last_command	int
==	O
'I'	O
&&	O
vi_insert_buffer	pointer
&&	O
*	O
vi_insert_buffer	pointer
)	O
{	O
rl_beg_of_line	function
(	O
1	int
,	O
'I'	O
)	O
;	O
_rl_vi_stuff_insert	function
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
_rl_vi_backup	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_last_command	int
==	O
'a'	O
&&	O
vi_insert_buffer	pointer
&&	O
*	O
vi_insert_buffer	pointer
)	O
{	O
_rl_vi_append_forward	function
(	O
'a'	O
)	O
;	O
_rl_vi_stuff_insert	function
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
_rl_vi_backup	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_last_command	int
==	O
'A'	O
&&	O
vi_insert_buffer	pointer
&&	O
*	O
vi_insert_buffer	pointer
)	O
{	O
rl_end_of_line	function
(	O
1	int
,	O
'A'	O
)	O
;	O
_rl_vi_stuff_insert	function
(	O
count	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
_rl_vi_backup	function
(	O
)	O
;	O
}	O
else	O
r	int
=	O
_rl_dispatch	function
(	O
_rl_vi_last_command	int
,	O
_rl_keymap	pointer
)	O
;	O
_rl_vi_redoing	int
=	O
0	int
;	O
return	O
(	O
r	int
)	O
;	O
}	O
int	O
rl_vi_undo	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_undo_command	function
(	O
count	int
,	O
key	int
)	O
)	O
;	O
}	O
int	O
rl_vi_yank_arg	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_explicit_arg	int
)	O
rl_yank_nth_arg	function
(	O
count	int
-	O
1	int
,	O
0	int
)	O
;	O
else	O
rl_yank_nth_arg	function
(	O
'$'	O
,	O
0	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_fetch_history	function
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
int	O
wanted	int
;	O
if	O
(	O
rl_explicit_arg	int
)	O
{	O
wanted	int
=	O
history_base	int
+	O
where_history	function
(	O
)	O
-	O
count	int
;	O
if	O
(	O
wanted	int
<=	O
0	int
)	O
rl_beginning_of_history	function
(	O
0	int
,	O
0	int
)	O
;	O
else	O
rl_get_previous_history	function
(	O
wanted	int
,	O
c	int
)	O
;	O
}	O
else	O
rl_beginning_of_history	function
(	O
count	int
,	O
0	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_search_again	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'n'	O
:	O
rl_noninc_reverse_search_again	function
(	O
count	int
,	O
key	int
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
rl_noninc_forward_search_again	function
(	O
count	int
,	O
key	int
)	O
;	O
break	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_search	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'?'	O
:	O
_rl_free_saved_history_line	function
(	O
)	O
;	O
rl_noninc_forward_search	function
(	O
count	int
,	O
key	int
)	O
;	O
break	O
;	O
case	O
'/'	O
:	O
_rl_free_saved_history_line	function
(	O
)	O
;	O
rl_noninc_reverse_search	function
(	O
count	int
,	O
key	int
)	O
;	O
break	O
;	O
default	O
:	O
rl_ding	function
(	O
)	O
;	O
break	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_complete	function
(	O
ignore	int
,	O
key	int
)	O
int	O
ignore	int
,	O
key	int
;	O
{	O
if	O
(	O
(	O
rl_point	int
<	O
rl_end	int
)	O
&&	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
+	O
1	int
]	O
)	O
)	O
rl_vi_end_word	function
(	O
1	int
,	O
'E'	O
)	O
;	O
rl_point	int
++	O
;	O
}	O
if	O
(	O
key	int
==	O
'*'	O
)	O
rl_complete_internal	function
(	O
'*'	O
)	O
;	O
else	O
if	O
(	O
key	int
==	O
'='	O
)	O
rl_complete_internal	function
(	O
'?'	O
)	O
;	O
else	O
if	O
(	O
key	int
==	O
'\\'	O
)	O
rl_complete_internal	function
(	O
TAB	char
)	O
;	O
else	O
rl_complete	function
(	O
0	int
,	O
key	int
)	O
;	O
if	O
(	O
key	int
==	O
'*'	O
||	O
key	int
==	O
'\\'	O
)	O
rl_vi_start_inserting	function
(	O
key	int
,	O
1	int
,	O
rl_arg_sign	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_tilde_expand	function
(	O
ignore	int
,	O
key	int
)	O
int	O
ignore	int
,	O
key	int
;	O
{	O
rl_tilde_expand	function
(	O
0	int
,	O
key	int
)	O
;	O
rl_vi_start_inserting	function
(	O
key	int
,	O
1	int
,	O
rl_arg_sign	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_prev_word	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_vi_next_word	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
_rl_uppercase_p	function
(	O
key	int
)	O
)	O
rl_vi_bWord	function
(	O
count	int
,	O
key	int
)	O
;	O
else	O
rl_vi_bword	function
(	O
count	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_next_word	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_vi_prev_word	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_point	int
>=	O
(	O
rl_end	int
-	O
1	int
)	O
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
if	O
(	O
_rl_uppercase_p	function
(	O
key	int
)	O
)	O
rl_vi_fWord	function
(	O
count	int
,	O
key	int
)	O
;	O
else	O
rl_vi_fword	function
(	O
count	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_end_word	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
<	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
_rl_uppercase_p	function
(	O
key	int
)	O
)	O
rl_vi_eWord	function
(	O
count	int
,	O
key	int
)	O
;	O
else	O
rl_vi_eword	function
(	O
count	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_fWord	function
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
(	O
rl_end	int
-	O
1	int
)	O
)	O
{	O
while	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
rl_point	int
++	O
;	O
while	O
(	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
rl_point	int
++	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_bWord	function
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
>	O
0	int
)	O
{	O
if	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
while	O
(	O
rl_point	int
>	O
0	int
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
{	O
while	O
(	O
--	O
rl_point	int
>=	O
0	int
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
;	O
rl_point	int
++	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_eWord	function
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
(	O
rl_end	int
-	O
1	int
)	O
)	O
{	O
if	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
if	O
(	O
rl_point	int
&&	O
rl_point	int
<	O
rl_end	int
)	O
{	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
rl_point	int
--	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_fword	function
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
(	O
rl_end	int
-	O
1	int
)	O
)	O
{	O
if	O
(	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
{	O
while	O
(	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
rl_point	int
++	O
;	O
}	O
else	O
{	O
while	O
(	O
!	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
rl_point	int
++	O
;	O
}	O
while	O
(	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
rl_point	int
++	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_bword	function
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
>	O
0	int
)	O
{	O
int	O
last_is_ident	int
;	O
if	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
last_is_ident	int
=	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
-	O
1	int
]	O
)	O
;	O
if	O
(	O
(	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
!	O
last_is_ident	int
)	O
||	O
(	O
!	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
last_is_ident	int
)	O
)	O
rl_point	int
--	O
;	O
while	O
(	O
rl_point	int
>	O
0	int
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
{	O
if	O
(	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
while	O
(	O
--	O
rl_point	int
>=	O
0	int
&&	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
;	O
else	O
while	O
(	O
--	O
rl_point	int
>=	O
0	int
&&	O
!	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
;	O
rl_point	int
++	O
;	O
}	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_eword	function
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
rl_end	int
-	O
1	int
)	O
{	O
if	O
(	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
if	O
(	O
rl_point	int
<	O
rl_end	int
)	O
{	O
if	O
(	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
while	O
(	O
++	O
rl_point	int
<	O
rl_end	int
&&	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
;	O
else	O
while	O
(	O
++	O
rl_point	int
<	O
rl_end	int
&&	O
!	O
_rl_isident	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
;	O
}	O
rl_point	int
--	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_insert_beg	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_beg_of_line	function
(	O
1	int
,	O
key	int
)	O
;	O
rl_vi_insert_mode	function
(	O
1	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_rl_vi_append_forward	function
(	O
key	int
)	O
int	O
key	int
;	O
{	O
int	O
point	int
;	O
if	O
(	O
rl_point	int
<	O
rl_end	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
rl_point	int
++	O
;	O
else	O
{	O
point	int
=	O
rl_point	int
;	O
rl_point	int
=	O
_rl_forward_char_internal	function
(	O
1	int
)	O
;	O
if	O
(	O
point	int
==	O
rl_point	int
)	O
rl_point	int
=	O
rl_end	int
;	O
}	O
}	O
}	O
int	O
rl_vi_append_mode	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
_rl_vi_append_forward	function
(	O
key	int
)	O
;	O
rl_vi_start_inserting	function
(	O
key	int
,	O
1	int
,	O
rl_arg_sign	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_append_eol	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_end_of_line	function
(	O
1	int
,	O
key	int
)	O
;	O
rl_vi_append_mode	function
(	O
1	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_eof_maybe	function
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
return	O
(	O
rl_newline	function
(	O
1	int
,	O
'\n'	O
)	O
)	O
;	O
}	O
int	O
rl_vi_insertion_mode	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
_rl_keymap	pointer
=	O
vi_insertion_keymap	array
;	O
_rl_vi_last_key_before_insert	int
=	O
key	int
;	O
if	O
(	O
_rl_show_mode_in_prompt	int
)	O
_rl_reset_prompt	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_insert_mode	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_vi_start_inserting	function
(	O
key	int
,	O
1	int
,	O
rl_arg_sign	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
vi_save_insert_buffer	function
(	O
start	int
,	O
len	int
)	O
int	O
start	int
,	O
len	int
;	O
{	O
if	O
(	O
len	int
>=	O
vi_insert_buffer_size	int
)	O
{	O
vi_insert_buffer_size	int
+=	O
(	O
len	int
+	O
32	int
)	O
-	O
(	O
len	int
%	O
32	int
)	O
;	O
vi_insert_buffer	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
vi_insert_buffer	pointer
,	O
vi_insert_buffer_size	int
)	O
;	O
}	O
strncpy	function
(	O
vi_insert_buffer	pointer
,	O
rl_line_buffer	pointer
+	O
start	int
,	O
len	int
-	O
1	int
)	O
;	O
vi_insert_buffer	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
static	O
void	O
_rl_vi_save_replace	function
(	O
)	O
{	O
int	O
len	int
,	O
start	int
,	O
end	int
;	O
UNDO_LIST	struct
*	O
up	pointer
;	O
up	pointer
=	O
rl_undo_list	pointer
;	O
if	O
(	O
up	pointer
==	O
0	int
||	O
up	pointer
->	O
what	enum
!=	O
UNDO_END	int
||	O
vi_replace_count	int
<=	O
0	int
)	O
{	O
if	O
(	O
vi_insert_buffer_size	int
>=	O
1	int
)	O
vi_insert_buffer	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
;	O
}	O
end	int
=	O
rl_point	int
;	O
start	int
=	O
end	int
-	O
vi_replace_count	int
+	O
1	int
;	O
len	int
=	O
vi_replace_count	int
+	O
1	int
;	O
vi_save_insert_buffer	function
(	O
start	int
,	O
len	int
)	O
;	O
}	O
static	O
void	O
_rl_vi_save_insert	function
(	O
up	pointer
)	O
UNDO_LIST	struct
*	O
up	pointer
;	O
{	O
int	O
len	int
,	O
start	int
,	O
end	int
;	O
if	O
(	O
up	pointer
==	O
0	int
||	O
up	pointer
->	O
what	enum
!=	O
UNDO_INSERT	int
)	O
{	O
if	O
(	O
vi_insert_buffer_size	int
>=	O
1	int
)	O
vi_insert_buffer	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
return	O
;	O
}	O
start	int
=	O
up	pointer
->	O
start	int
;	O
end	int
=	O
up	pointer
->	O
end	int
;	O
len	int
=	O
end	int
-	O
start	int
+	O
1	int
;	O
vi_save_insert_buffer	function
(	O
start	int
,	O
len	int
)	O
;	O
}	O
void	O
_rl_vi_done_inserting	function
(	O
)	O
{	O
if	O
(	O
_rl_vi_doing_insert	int
)	O
{	O
rl_end_undo_group	function
(	O
)	O
;	O
_rl_vi_doing_insert	int
=	O
0	int
;	O
if	O
(	O
_rl_vi_last_key_before_insert	int
==	O
'R'	O
)	O
_rl_vi_save_replace	function
(	O
)	O
;	O
else	O
_rl_vi_save_insert	function
(	O
rl_undo_list	pointer
->	O
next	pointer
)	O
;	O
vi_continued_command	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
rl_undo_list	pointer
&&	O
(	O
_rl_vi_last_key_before_insert	int
==	O
'i'	O
||	O
_rl_vi_last_key_before_insert	int
==	O
'a'	O
||	O
_rl_vi_last_key_before_insert	int
==	O
'I'	O
||	O
_rl_vi_last_key_before_insert	int
==	O
'A'	O
)	O
)	O
_rl_vi_save_insert	function
(	O
rl_undo_list	pointer
)	O
;	O
else	O
if	O
(	O
_rl_vi_last_key_before_insert	int
==	O
'C'	O
)	O
rl_end_undo_group	function
(	O
)	O
;	O
while	O
(	O
_rl_undo_group_level	int
>	O
0	int
)	O
rl_end_undo_group	function
(	O
)	O
;	O
vi_continued_command	int
=	O
0	int
;	O
}	O
}	O
int	O
rl_vi_movement_mode	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
rl_point	int
>	O
0	int
)	O
rl_backward_char	function
(	O
1	int
,	O
key	int
)	O
;	O
_rl_keymap	pointer
=	O
vi_movement_keymap	array
;	O
_rl_vi_done_inserting	function
(	O
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_VICMDONCE	int
)	O
==	O
0	int
)	O
rl_free_undo_list	function
(	O
)	O
;	O
if	O
(	O
_rl_show_mode_in_prompt	int
)	O
_rl_reset_prompt	function
(	O
)	O
;	O
RL_SETSTATE	O
(	O
RL_STATE_VICMDONCE	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_arg_digit	function
(	O
count	int
,	O
c	int
)	O
int	O
count	int
,	O
c	int
;	O
{	O
if	O
(	O
c	int
==	O
'0'	O
&&	O
rl_numeric_arg	int
==	O
1	int
&&	O
!	O
rl_explicit_arg	int
)	O
return	O
(	O
rl_beg_of_line	function
(	O
1	int
,	O
c	int
)	O
)	O
;	O
else	O
return	O
(	O
rl_digit_argument	function
(	O
count	int
,	O
c	int
)	O
)	O
;	O
}	O
static	O
int	O
_rl_vi_change_mbchar_case	function
(	O
count	int
)	O
int	O
count	int
;	O
{	O
wchar_t	int
wc	int
;	O
char	O
mb	array
[	O
MB_LEN_MAX	int
+	O
1	int
]	O
;	O
int	O
mlen	int
,	O
p	int
;	O
size_t	long
m	long
;	O
mbstate_t	struct
ps	struct
;	O
memset	function
(	O
&	O
ps	struct
,	O
0	int
,	O
sizeof	O
(	O
mbstate_t	struct
)	O
)	O
;	O
if	O
(	O
_rl_adjust_point	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
&	O
ps	struct
)	O
>	O
0	int
)	O
count	int
--	O
;	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
{	O
m	long
=	O
mbrtowc	function
(	O
&	O
wc	int
,	O
rl_line_buffer	pointer
+	O
rl_point	int
,	O
rl_end	int
-	O
rl_point	int
,	O
&	O
ps	struct
)	O
;	O
if	O
(	O
MB_INVALIDCH	O
(	O
m	long
)	O
)	O
wc	int
=	O
(	O
wchar_t	int
)	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
;	O
else	O
if	O
(	O
MB_NULLWCH	O
(	O
m	long
)	O
)	O
wc	int
=	O
L'\0'	O
;	O
if	O
(	O
iswupper	function
(	O
wc	int
)	O
)	O
wc	int
=	O
towlower	function
(	O
wc	int
)	O
;	O
else	O
if	O
(	O
iswlower	function
(	O
wc	int
)	O
)	O
wc	int
=	O
towupper	function
(	O
wc	int
)	O
;	O
else	O
{	O
rl_forward_char	function
(	O
1	int
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
wc	int
)	O
{	O
p	int
=	O
rl_point	int
;	O
mlen	int
=	O
wcrtomb	function
(	O
mb	array
,	O
wc	int
,	O
&	O
ps	struct
)	O
;	O
if	O
(	O
mlen	int
>=	O
0	int
)	O
mb	array
[	O
mlen	int
]	O
=	O
'\0'	O
;	O
rl_begin_undo_group	function
(	O
)	O
;	O
rl_vi_delete	function
(	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
rl_point	int
<	O
p	int
)	O
rl_point	int
++	O
;	O
rl_insert_text	function
(	O
mb	array
)	O
;	O
rl_end_undo_group	function
(	O
)	O
;	O
rl_vi_check	function
(	O
)	O
;	O
}	O
else	O
rl_forward_char	function
(	O
1	int
,	O
0	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_vi_change_case	function
(	O
count	int
,	O
ignore	int
)	O
int	O
count	int
,	O
ignore	int
;	O
{	O
int	O
c	int
,	O
p	int
;	O
if	O
(	O
rl_point	int
>=	O
rl_end	int
)	O
return	O
(	O
0	int
)	O
;	O
c	int
=	O
0	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
return	O
(	O
_rl_vi_change_mbchar_case	function
(	O
count	int
)	O
)	O
;	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
{	O
if	O
(	O
_rl_uppercase_p	function
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
c	int
=	O
_rl_to_lower	function
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
;	O
else	O
if	O
(	O
_rl_lowercase_p	function
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
c	int
=	O
_rl_to_upper	function
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
;	O
else	O
{	O
rl_forward_char	function
(	O
1	int
,	O
c	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
)	O
{	O
p	int
=	O
rl_point	int
;	O
rl_begin_undo_group	function
(	O
)	O
;	O
rl_vi_delete	function
(	O
1	int
,	O
c	int
)	O
;	O
if	O
(	O
rl_point	int
<	O
p	int
)	O
rl_point	int
++	O
;	O
_rl_insert_char	function
(	O
1	int
,	O
c	int
)	O
;	O
rl_end_undo_group	function
(	O
)	O
;	O
rl_vi_check	function
(	O
)	O
;	O
}	O
else	O
rl_forward_char	function
(	O
1	int
,	O
c	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_put	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
!	O
_rl_uppercase_p	function
(	O
key	int
)	O
&&	O
(	O
rl_point	int
+	O
1	int
<=	O
rl_end	int
)	O
)	O
rl_point	int
=	O
_rl_find_next_mbchar	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
1	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
while	O
(	O
count	int
--	O
)	O
rl_yank	function
(	O
1	int
,	O
key	int
)	O
;	O
rl_backward_char	function
(	O
1	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_rl_vi_backup	function
(	O
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_point	int
=	O
_rl_find_prev_mbchar	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
else	O
rl_point	int
--	O
;	O
}	O
int	O
rl_vi_check	function
(	O
)	O
{	O
if	O
(	O
rl_point	int
&&	O
rl_point	int
==	O
rl_end	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_point	int
=	O
_rl_find_prev_mbchar	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
else	O
rl_point	int
--	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_column	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
count	int
>	O
rl_end	int
)	O
rl_end_of_line	function
(	O
1	int
,	O
key	int
)	O
;	O
else	O
rl_point	int
=	O
count	int
-	O
1	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
_rl_vi_arg_dispatch	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
int	O
key	int
;	O
key	int
=	O
c	int
;	O
if	O
(	O
c	int
>=	O
0	int
&&	O
_rl_keymap	pointer
[	O
c	int
]	O
.	O
type	char
==	O
ISFUNC	int
&&	O
_rl_keymap	pointer
[	O
c	int
]	O
.	O
function	pointer
==	O
rl_universal_argument	function
)	O
{	O
rl_numeric_arg	int
*=	O
4	int
;	O
return	O
1	int
;	O
}	O
c	int
=	O
UNMETA	O
(	O
c	int
)	O
;	O
if	O
(	O
_rl_digit_p	function
(	O
c	int
)	O
)	O
{	O
if	O
(	O
rl_explicit_arg	int
)	O
rl_numeric_arg	int
=	O
(	O
rl_numeric_arg	int
*	O
10	int
)	O
+	O
_rl_digit_value	function
(	O
c	int
)	O
;	O
else	O
rl_numeric_arg	int
=	O
_rl_digit_value	function
(	O
c	int
)	O
;	O
rl_explicit_arg	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
else	O
{	O
rl_clear_message	function
(	O
)	O
;	O
rl_stuff_char	function
(	O
key	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
static	O
int	O
rl_digit_loop1	function
(	O
)	O
{	O
int	O
c	int
,	O
r	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
_rl_arg_overflow	function
(	O
)	O
)	O
return	O
1	int
;	O
c	int
=	O
_rl_arg_getchar	function
(	O
)	O
;	O
r	int
=	O
_rl_vi_arg_dispatch	function
(	O
c	int
)	O
;	O
if	O
(	O
r	int
<=	O
0	int
)	O
break	O
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
void	O
_rl_mvcxt_init	function
(	O
m	long
,	O
op	int
,	O
key	int
)	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
int	O
op	int
,	O
key	int
;	O
{	O
m	long
->	O
op	int
=	O
op	int
;	O
m	long
->	O
state	pointer
=	O
m	long
->	O
flags	int
=	O
0	int
;	O
m	long
->	O
ncxt	int
=	O
0	int
;	O
m	long
->	O
numeric_arg	int
=	O
-	O
1	int
;	O
m	long
->	O
start	int
=	O
rl_point	int
;	O
m	long
->	O
end	int
=	O
rl_end	int
;	O
m	long
->	O
key	int
=	O
key	int
;	O
m	long
->	O
motion	int
=	O
-	O
1	int
;	O
}	O
static	O
_rl_vimotion_cxt	struct
*	O
_rl_mvcxt_alloc	function
(	O
op	int
,	O
key	int
)	O
int	O
op	int
,	O
key	int
;	O
{	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
m	long
=	O
xmalloc	function
(	O
sizeof	O
(	O
_rl_vimotion_cxt	struct
)	O
)	O
;	O
_rl_mvcxt_init	function
(	O
m	long
,	O
op	int
,	O
key	int
)	O
;	O
return	O
m	long
;	O
}	O
static	O
void	O
_rl_mvcxt_dispose	function
(	O
m	long
)	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
{	O
xfree	function
(	O
m	long
)	O
;	O
}	O
static	O
int	O
rl_domove_motion_callback	function
(	O
m	long
)	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
{	O
int	O
c	int
;	O
_rl_vi_last_motion	int
=	O
c	int
=	O
m	long
->	O
motion	int
;	O
rl_line_buffer	pointer
[	O
rl_end	int
++	O
]	O
=	O
' '	O
;	O
rl_line_buffer	pointer
[	O
rl_end	int
]	O
=	O
'\0'	O
;	O
_rl_dispatch	function
(	O
c	int
,	O
_rl_keymap	pointer
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CHARSEARCH	int
)	O
)	O
return	O
0	int
;	O
else	O
return	O
(	O
_rl_vi_domove_motion_cleanup	function
(	O
c	int
,	O
m	long
)	O
)	O
;	O
}	O
return	O
(	O
_rl_vi_domove_motion_cleanup	function
(	O
c	int
,	O
m	long
)	O
)	O
;	O
}	O
int	O
_rl_vi_domove_motion_cleanup	function
(	O
c	int
,	O
m	long
)	O
int	O
c	int
;	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
{	O
int	O
r	int
;	O
rl_end	int
=	O
m	long
->	O
end	int
;	O
rl_line_buffer	pointer
[	O
rl_end	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
rl_point	int
>	O
rl_end	int
)	O
rl_point	int
=	O
rl_end	int
;	O
if	O
(	O
rl_mark	int
==	O
rl_point	int
)	O
{	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
_rl_to_upper	function
(	O
c	int
)	O
==	O
'W'	O
)	O
&&	O
rl_point	int
<	O
rl_end	int
&&	O
rl_point	int
>	O
rl_mark	int
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
if	O
(	O
m	long
->	O
key	int
==	O
'c'	O
&&	O
rl_point	int
>=	O
rl_mark	int
&&	O
(	O
_rl_to_upper	function
(	O
c	int
)	O
==	O
'W'	O
)	O
)	O
{	O
while	O
(	O
rl_point	int
>	O
rl_mark	int
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
if	O
(	O
rl_point	int
==	O
rl_mark	int
)	O
rl_point	int
++	O
;	O
else	O
{	O
if	O
(	O
rl_point	int
>=	O
0	int
&&	O
rl_point	int
<	O
(	O
rl_end	int
-	O
1	int
)	O
&&	O
!	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
}	O
}	O
if	O
(	O
rl_mark	int
<	O
rl_point	int
)	O
SWAP	O
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
(	O
*	O
rl_redisplay_function	pointer
)	O
(	O
)	O
;	O
r	int
=	O
vidomove_dispatch	function
(	O
m	long
)	O
;	O
return	O
(	O
r	int
)	O
;	O
}	O
static	O
int	O
rl_domove_read_callback	function
(	O
m	long
)	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
{	O
int	O
c	int
,	O
save	int
;	O
c	int
=	O
m	long
->	O
motion	int
;	O
if	O
(	O
member	O
(	O
c	int
,	O
vi_motion	pointer
)	O
)	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
&&	O
RL_VIMOVENUMARG	O
(	O
)	O
)	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
return	O
(	O
rl_domove_motion_callback	function
(	O
m	long
)	O
)	O
;	O
}	O
else	O
if	O
(	O
m	long
->	O
key	int
==	O
c	int
&&	O
(	O
m	long
->	O
key	int
==	O
'd'	O
||	O
m	long
->	O
key	int
==	O
'y'	O
||	O
m	long
->	O
key	int
==	O
'c'	O
)	O
)	O
{	O
rl_mark	int
=	O
rl_end	int
;	O
rl_beg_of_line	function
(	O
1	int
,	O
c	int
)	O
;	O
_rl_vi_last_motion	int
=	O
c	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
(	O
vidomove_dispatch	function
(	O
m	long
)	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_digit_p	function
(	O
c	int
)	O
&&	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
&&	O
RL_VIMOVENUMARG	O
(	O
)	O
)	O
{	O
return	O
(	O
_rl_vi_arg_dispatch	function
(	O
c	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_digit_p	function
(	O
c	int
)	O
&&	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
&&	O
RL_ISSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
&&	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
==	O
0	int
)	O
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
return	O
(	O
_rl_vi_arg_dispatch	function
(	O
c	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
_rl_digit_p	function
(	O
c	int
)	O
)	O
{	O
save	int
=	O
rl_numeric_arg	int
;	O
rl_numeric_arg	int
=	O
_rl_digit_value	function
(	O
c	int
)	O
;	O
rl_explicit_arg	int
=	O
1	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
rl_digit_loop1	function
(	O
)	O
;	O
rl_numeric_arg	int
*=	O
save	int
;	O
c	int
=	O
rl_vi_domove_getchar	function
(	O
m	long
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
{	O
m	long
->	O
motion	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
m	long
->	O
motion	int
=	O
c	int
;	O
return	O
(	O
rl_domove_motion_callback	function
(	O
m	long
)	O
)	O
;	O
}	O
else	O
{	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_NUMERICARG	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
}	O
static	O
int	O
rl_vi_domove_getchar	function
(	O
m	long
)	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
{	O
int	O
c	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
c	int
=	O
rl_read_key	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
return	O
c	int
;	O
}	O
int	O
_rl_vi_domove_callback	function
(	O
m	long
)	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
{	O
int	O
c	int
,	O
r	int
;	O
m	long
->	O
motion	int
=	O
c	int
=	O
rl_vi_domove_getchar	function
(	O
m	long
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
1	int
;	O
r	int
=	O
rl_domove_read_callback	function
(	O
m	long
)	O
;	O
return	O
(	O
(	O
r	int
==	O
0	int
)	O
?	O
r	int
:	O
1	int
)	O
;	O
}	O
int	O
rl_vi_domove	function
(	O
x	int
,	O
ignore	int
)	O
int	O
x	int
,	O
*	O
ignore	int
;	O
{	O
int	O
r	int
;	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
m	long
=	O
_rl_vimvcxt	pointer
;	O
*	O
ignore	int
=	O
m	long
->	O
motion	int
=	O
rl_vi_domove_getchar	function
(	O
m	long
)	O
;	O
if	O
(	O
m	long
->	O
motion	int
<	O
0	int
)	O
{	O
m	long
->	O
motion	int
=	O
0	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
(	O
rl_domove_read_callback	function
(	O
m	long
)	O
)	O
;	O
}	O
static	O
int	O
vi_delete_dispatch	function
(	O
m	long
)	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
{	O
if	O
(	O
(	O
(	O
strchr	function
(	O
" l|h^0bBFT`"	pointer
,	O
m	long
->	O
motion	int
)	O
==	O
0	int
)	O
&&	O
(	O
rl_point	int
>=	O
m	long
->	O
start	int
)	O
)	O
&&	O
(	O
rl_mark	int
<	O
rl_end	int
)	O
)	O
rl_mark	int
++	O
;	O
rl_kill_text	function
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_delete_to	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
,	O
r	int
;	O
_rl_vimvcxt	pointer
=	O
_rl_mvcxt_alloc	function
(	O
VIM_DELETE	int
,	O
key	int
)	O
;	O
_rl_vimvcxt	pointer
->	O
start	int
=	O
rl_point	int
;	O
rl_mark	int
=	O
rl_point	int
;	O
if	O
(	O
_rl_uppercase_p	function
(	O
key	int
)	O
)	O
{	O
_rl_vimvcxt	pointer
->	O
motion	int
=	O
'$'	O
;	O
r	int
=	O
rl_domove_motion_callback	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
&&	O
_rl_vi_last_motion	int
!=	O
'd'	O
)	O
{	O
_rl_vimvcxt	pointer
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
r	int
=	O
rl_domove_motion_callback	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
_rl_vimvcxt	pointer
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
rl_mark	int
=	O
rl_end	int
;	O
rl_beg_of_line	function
(	O
1	int
,	O
key	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
r	int
=	O
vidomove_dispatch	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
r	int
=	O
rl_vi_domove	function
(	O
key	int
,	O
&	O
c	int
)	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
r	int
=	O
-	O
1	int
;	O
}	O
_rl_mvcxt_dispose	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
_rl_vimvcxt	pointer
=	O
0	int
;	O
return	O
r	int
;	O
}	O
static	O
int	O
vi_change_dispatch	function
(	O
m	long
)	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
{	O
if	O
(	O
(	O
(	O
strchr	function
(	O
" l|hwW^0bBFT`"	pointer
,	O
m	long
->	O
motion	int
)	O
==	O
0	int
)	O
&&	O
(	O
rl_point	int
>=	O
m	long
->	O
start	int
)	O
)	O
&&	O
(	O
rl_mark	int
<	O
rl_end	int
)	O
)	O
rl_mark	int
++	O
;	O
if	O
(	O
(	O
_rl_to_upper	function
(	O
m	long
->	O
motion	int
)	O
==	O
'W'	O
)	O
&&	O
rl_point	int
<	O
m	long
->	O
start	int
)	O
rl_point	int
=	O
m	long
->	O
start	int
;	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
if	O
(	O
vi_insert_buffer	pointer
&&	O
*	O
vi_insert_buffer	pointer
)	O
rl_begin_undo_group	function
(	O
)	O
;	O
rl_delete_text	function
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
if	O
(	O
vi_insert_buffer	pointer
&&	O
*	O
vi_insert_buffer	pointer
)	O
{	O
rl_insert_text	function
(	O
vi_insert_buffer	pointer
)	O
;	O
rl_end_undo_group	function
(	O
)	O
;	O
}	O
}	O
else	O
{	O
rl_begin_undo_group	function
(	O
)	O
;	O
rl_kill_text	function
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
if	O
(	O
_rl_uppercase_p	function
(	O
m	long
->	O
key	int
)	O
==	O
0	int
)	O
_rl_vi_doing_insert	int
=	O
1	int
;	O
rl_vi_start_inserting	function
(	O
m	long
->	O
key	int
,	O
rl_numeric_arg	int
,	O
rl_arg_sign	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_change_to	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
,	O
r	int
;	O
_rl_vimvcxt	pointer
=	O
_rl_mvcxt_alloc	function
(	O
VIM_CHANGE	int
,	O
key	int
)	O
;	O
_rl_vimvcxt	pointer
->	O
start	int
=	O
rl_point	int
;	O
rl_mark	int
=	O
rl_point	int
;	O
if	O
(	O
_rl_uppercase_p	function
(	O
key	int
)	O
)	O
{	O
_rl_vimvcxt	pointer
->	O
motion	int
=	O
'$'	O
;	O
r	int
=	O
rl_domove_motion_callback	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
&&	O
_rl_vi_last_motion	int
!=	O
'c'	O
)	O
{	O
_rl_vimvcxt	pointer
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
r	int
=	O
rl_domove_motion_callback	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
_rl_vimvcxt	pointer
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
rl_mark	int
=	O
rl_end	int
;	O
rl_beg_of_line	function
(	O
1	int
,	O
key	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
r	int
=	O
vidomove_dispatch	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
r	int
=	O
rl_vi_domove	function
(	O
key	int
,	O
&	O
c	int
)	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
r	int
=	O
-	O
1	int
;	O
}	O
_rl_mvcxt_dispose	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
_rl_vimvcxt	pointer
=	O
0	int
;	O
return	O
r	int
;	O
}	O
static	O
int	O
vi_yank_dispatch	function
(	O
m	long
)	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
{	O
if	O
(	O
(	O
(	O
strchr	function
(	O
" l|h^0%bBFT`"	pointer
,	O
m	long
->	O
motion	int
)	O
==	O
0	int
)	O
&&	O
(	O
rl_point	int
>=	O
m	long
->	O
start	int
)	O
)	O
&&	O
(	O
rl_mark	int
<	O
rl_end	int
)	O
)	O
rl_mark	int
++	O
;	O
rl_begin_undo_group	function
(	O
)	O
;	O
rl_kill_text	function
(	O
rl_point	int
,	O
rl_mark	int
)	O
;	O
rl_end_undo_group	function
(	O
)	O
;	O
rl_do_undo	function
(	O
)	O
;	O
rl_point	int
=	O
m	long
->	O
start	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_yank_to	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
,	O
r	int
;	O
_rl_vimvcxt	pointer
=	O
_rl_mvcxt_alloc	function
(	O
VIM_YANK	int
,	O
key	int
)	O
;	O
_rl_vimvcxt	pointer
->	O
start	int
=	O
rl_point	int
;	O
rl_mark	int
=	O
rl_point	int
;	O
if	O
(	O
_rl_uppercase_p	function
(	O
key	int
)	O
)	O
{	O
_rl_vimvcxt	pointer
->	O
motion	int
=	O
'$'	O
;	O
r	int
=	O
rl_domove_motion_callback	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
&&	O
_rl_vi_last_motion	int
!=	O
'y'	O
)	O
{	O
_rl_vimvcxt	pointer
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
r	int
=	O
rl_domove_motion_callback	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
}	O
else	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
_rl_vimvcxt	pointer
->	O
motion	int
=	O
_rl_vi_last_motion	int
;	O
rl_mark	int
=	O
rl_end	int
;	O
rl_beg_of_line	function
(	O
1	int
,	O
key	int
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
r	int
=	O
vidomove_dispatch	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
RL_SETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
r	int
=	O
rl_vi_domove	function
(	O
key	int
,	O
&	O
c	int
)	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
r	int
=	O
-	O
1	int
;	O
}	O
_rl_mvcxt_dispose	function
(	O
_rl_vimvcxt	pointer
)	O
;	O
_rl_vimvcxt	pointer
=	O
0	int
;	O
return	O
r	int
;	O
}	O
static	O
int	O
vidomove_dispatch	function
(	O
m	long
)	O
_rl_vimotion_cxt	struct
*	O
m	long
;	O
{	O
int	O
r	int
;	O
switch	O
(	O
m	long
->	O
op	int
)	O
{	O
case	O
VIM_DELETE	int
:	O
r	int
=	O
vi_delete_dispatch	function
(	O
m	long
)	O
;	O
break	O
;	O
case	O
VIM_CHANGE	int
:	O
r	int
=	O
vi_change_dispatch	function
(	O
m	long
)	O
;	O
break	O
;	O
case	O
VIM_YANK	int
:	O
r	int
=	O
vi_yank_dispatch	function
(	O
m	long
)	O
;	O
break	O
;	O
default	O
:	O
_rl_errmsg	function
(	O
"vidomove_dispatch: unknown operator %d"	pointer
,	O
m	long
->	O
op	int
)	O
;	O
r	int
=	O
1	int
;	O
break	O
;	O
}	O
RL_UNSETSTATE	O
(	O
RL_STATE_VIMOTION	int
)	O
;	O
return	O
r	int
;	O
}	O
int	O
rl_vi_rubout	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
opoint	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_vi_delete	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
opoint	int
=	O
rl_point	int
;	O
if	O
(	O
count	int
>	O
1	int
&&	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_backward_char	function
(	O
count	int
,	O
key	int
)	O
;	O
else	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_point	int
=	O
_rl_find_prev_mbchar	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
else	O
rl_point	int
-=	O
count	int
;	O
if	O
(	O
rl_point	int
<	O
0	int
)	O
rl_point	int
=	O
0	int
;	O
rl_kill_text	function
(	O
rl_point	int
,	O
opoint	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_delete	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
end	int
;	O
if	O
(	O
count	int
<	O
0	int
)	O
return	O
(	O
rl_vi_rubout	function
(	O
-	O
count	int
,	O
key	int
)	O
)	O
;	O
if	O
(	O
rl_end	int
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
end	int
=	O
_rl_find_next_mbchar	function
(	O
rl_line_buffer	pointer
,	O
rl_point	int
,	O
count	int
,	O
MB_FIND_NONZERO	int
)	O
;	O
else	O
end	int
=	O
rl_point	int
+	O
count	int
;	O
if	O
(	O
end	int
>=	O
rl_end	int
)	O
end	int
=	O
rl_end	int
;	O
rl_kill_text	function
(	O
rl_point	int
,	O
end	int
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
&&	O
rl_point	int
==	O
rl_end	int
)	O
rl_backward_char	function
(	O
1	int
,	O
key	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_unix_word_rubout	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
orig_point	int
;	O
if	O
(	O
rl_point	int
==	O
0	int
)	O
rl_ding	function
(	O
)	O
;	O
else	O
{	O
orig_point	int
=	O
rl_point	int
;	O
if	O
(	O
count	int
<=	O
0	int
)	O
count	int
=	O
1	int
;	O
while	O
(	O
count	int
--	O
)	O
{	O
if	O
(	O
rl_point	int
>	O
0	int
&&	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
==	O
0	int
)	O
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
while	O
(	O
--	O
rl_point	int
>	O
0	int
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
&&	O
(	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
==	O
0	int
)	O
&&	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
if	O
(	O
rl_point	int
>	O
0	int
&&	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
while	O
(	O
rl_point	int
&&	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
-	O
1	int
]	O
)	O
)	O
rl_point	int
--	O
;	O
else	O
if	O
(	O
rl_point	int
>	O
0	int
&&	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
==	O
0	int
)	O
while	O
(	O
rl_point	int
&&	O
(	O
vi_unix_word_boundary	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
-	O
1	int
]	O
)	O
==	O
0	int
)	O
)	O
rl_point	int
--	O
;	O
}	O
rl_kill_text	function
(	O
orig_point	int
,	O
rl_point	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
rl_vi_back_to_indent	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
rl_beg_of_line	function
(	O
1	int
,	O
key	int
)	O
;	O
while	O
(	O
rl_point	int
<	O
rl_end	int
&&	O
whitespace	O
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
rl_point	int
++	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_first_print	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
return	O
(	O
rl_vi_back_to_indent	function
(	O
1	int
,	O
key	int
)	O
)	O
;	O
}	O
static	O
int	O
_rl_cs_dir	int
,	O
_rl_cs_orig_dir	int
;	O
static	O
int	O
_rl_vi_callback_char_search	function
(	O
data	pointer
)	O
_rl_callback_generic_arg	struct
*	O
data	pointer
;	O
{	O
int	O
c	int
;	O
c	int
=	O
_rl_vi_last_search_mblen	int
=	O
_rl_read_mbchar	function
(	O
_rl_vi_last_search_mbchar	array
,	O
MB_LEN_MAX	int
)	O
;	O
if	O
(	O
c	int
<=	O
0	int
)	O
{	O
RL_UNSETSTATE	O
(	O
RL_STATE_CHARSEARCH	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
_rl_callback_func	pointer
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_CHARSEARCH	int
)	O
;	O
return	O
(	O
_rl_char_search_internal	function
(	O
data	pointer
->	O
count	int
,	O
_rl_cs_dir	int
,	O
_rl_vi_last_search_mbchar	array
,	O
_rl_vi_last_search_mblen	int
)	O
)	O
;	O
}	O
int	O
rl_vi_char_search	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
;	O
static	O
char	O
*	O
target	pointer
;	O
static	O
int	O
tlen	int
;	O
if	O
(	O
key	int
==	O
';'	O
||	O
key	int
==	O
','	O
)	O
{	O
if	O
(	O
_rl_cs_orig_dir	int
==	O
0	int
)	O
return	O
1	int
;	O
if	O
(	O
_rl_vi_last_search_mblen	int
==	O
0	int
)	O
return	O
1	int
;	O
_rl_cs_dir	int
=	O
(	O
key	int
==	O
';'	O
)	O
?	O
_rl_cs_orig_dir	int
:	O
-	O
_rl_cs_orig_dir	int
;	O
}	O
else	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
't'	O
:	O
_rl_cs_orig_dir	int
=	O
_rl_cs_dir	int
=	O
FTO	int
;	O
break	O
;	O
case	O
'T'	O
:	O
_rl_cs_orig_dir	int
=	O
_rl_cs_dir	int
=	O
BTO	O
;	O
break	O
;	O
case	O
'f'	O
:	O
_rl_cs_orig_dir	int
=	O
_rl_cs_dir	int
=	O
FFIND	int
;	O
break	O
;	O
case	O
'F'	O
:	O
_rl_cs_orig_dir	int
=	O
_rl_cs_dir	int
=	O
BFIND	O
;	O
break	O
;	O
}	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	pointer
=	O
_rl_callback_data_alloc	function
(	O
count	int
)	O
;	O
_rl_callback_data	pointer
->	O
i1	int
=	O
_rl_cs_dir	int
;	O
_rl_callback_data	pointer
->	O
i2	int
=	O
key	int
;	O
_rl_callback_func	pointer
=	O
_rl_vi_callback_char_search	function
;	O
RL_SETSTATE	O
(	O
RL_STATE_CHARSEARCH	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
c	int
=	O
_rl_read_mbchar	function
(	O
_rl_vi_last_search_mbchar	array
,	O
MB_LEN_MAX	int
)	O
;	O
if	O
(	O
c	int
<=	O
0	int
)	O
return	O
-	O
1	int
;	O
_rl_vi_last_search_mblen	int
=	O
c	int
;	O
}	O
}	O
target	pointer
=	O
_rl_vi_last_search_mbchar	array
;	O
tlen	int
=	O
_rl_vi_last_search_mblen	int
;	O
return	O
(	O
_rl_char_search_internal	function
(	O
count	int
,	O
_rl_cs_dir	int
,	O
target	pointer
,	O
tlen	int
)	O
)	O
;	O
}	O
int	O
rl_vi_match	function
(	O
ignore	int
,	O
key	int
)	O
int	O
ignore	int
,	O
key	int
;	O
{	O
int	O
count	int
=	O
1	int
,	O
brack	int
,	O
pos	int
,	O
tmp	int
,	O
pre	int
;	O
pos	int
=	O
rl_point	int
;	O
if	O
(	O
(	O
brack	int
=	O
rl_vi_bracktype	function
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
{	O
while	O
(	O
(	O
brack	int
=	O
rl_vi_bracktype	function
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
pre	int
=	O
rl_point	int
;	O
rl_forward_char	function
(	O
1	int
,	O
key	int
)	O
;	O
if	O
(	O
pre	int
==	O
rl_point	int
)	O
break	O
;	O
}	O
}	O
else	O
while	O
(	O
(	O
brack	int
=	O
rl_vi_bracktype	function
(	O
rl_line_buffer	pointer
[	O
rl_point	int
]	O
)	O
)	O
==	O
0	int
&&	O
rl_point	int
<	O
rl_end	int
-	O
1	int
)	O
rl_forward_char	function
(	O
1	int
,	O
key	int
)	O
;	O
if	O
(	O
brack	int
<=	O
0	int
)	O
{	O
rl_point	int
=	O
pos	int
;	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
pos	int
=	O
rl_point	int
;	O
if	O
(	O
brack	int
<	O
0	int
)	O
{	O
while	O
(	O
count	int
)	O
{	O
tmp	int
=	O
pos	int
;	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
pos	int
--	O
;	O
else	O
{	O
pos	int
=	O
_rl_find_prev_mbchar	function
(	O
rl_line_buffer	pointer
,	O
pos	int
,	O
MB_FIND_ANY	int
)	O
;	O
if	O
(	O
tmp	int
==	O
pos	int
)	O
pos	int
--	O
;	O
}	O
if	O
(	O
pos	int
>=	O
0	int
)	O
{	O
int	O
b	int
=	O
rl_vi_bracktype	function
(	O
rl_line_buffer	pointer
[	O
pos	int
]	O
)	O
;	O
if	O
(	O
b	int
==	O
-	O
brack	int
)	O
count	int
--	O
;	O
else	O
if	O
(	O
b	int
==	O
brack	int
)	O
count	int
++	O
;	O
}	O
else	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
else	O
{	O
while	O
(	O
count	int
)	O
{	O
if	O
(	O
MB_CUR_MAX	O
==	O
1	int
||	O
rl_byte_oriented	int
)	O
pos	int
++	O
;	O
else	O
pos	int
=	O
_rl_find_next_mbchar	function
(	O
rl_line_buffer	pointer
,	O
pos	int
,	O
1	int
,	O
MB_FIND_ANY	int
)	O
;	O
if	O
(	O
pos	int
<	O
rl_end	int
)	O
{	O
int	O
b	int
=	O
rl_vi_bracktype	function
(	O
rl_line_buffer	pointer
[	O
pos	int
]	O
)	O
;	O
if	O
(	O
b	int
==	O
-	O
brack	int
)	O
count	int
--	O
;	O
else	O
if	O
(	O
b	int
==	O
brack	int
)	O
count	int
++	O
;	O
}	O
else	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
rl_point	int
=	O
pos	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_bracktype	function
(	O
c	int
)	O
int	O
c	int
;	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'('	O
:	O
return	O
1	int
;	O
case	O
')'	O
:	O
return	O
-	O
1	int
;	O
case	O
'['	O
:	O
return	O
2	int
;	O
case	O
']'	O
:	O
return	O
-	O
2	int
;	O
case	O
'{'	O
:	O
return	O
3	int
;	O
case	O
'}'	O
:	O
return	O
-	O
3	int
;	O
default	O
:	O
return	O
0	int
;	O
}	O
}	O
static	O
int	O
_rl_vi_change_char	function
(	O
count	int
,	O
c	int
,	O
mb	array
)	O
int	O
count	int
,	O
c	int
;	O
char	O
*	O
mb	array
;	O
{	O
int	O
p	int
;	O
if	O
(	O
c	int
==	O
'\033'	O
||	O
c	int
==	O
CTRL	O
(	O
'C'	O
)	O
)	O
return	O
-	O
1	int
;	O
rl_begin_undo_group	function
(	O
)	O
;	O
while	O
(	O
count	int
--	O
&&	O
rl_point	int
<	O
rl_end	int
)	O
{	O
p	int
=	O
rl_point	int
;	O
rl_vi_delete	function
(	O
1	int
,	O
c	int
)	O
;	O
if	O
(	O
rl_point	int
<	O
p	int
)	O
rl_point	int
++	O
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
rl_insert_text	function
(	O
mb	array
)	O
;	O
else	O
_rl_insert_char	function
(	O
1	int
,	O
c	int
)	O
;	O
}	O
rl_backward_char	function
(	O
1	int
,	O
c	int
)	O
;	O
rl_end_undo_group	function
(	O
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
_rl_vi_callback_getchar	function
(	O
mb	array
,	O
mlen	int
)	O
char	O
*	O
mb	array
;	O
int	O
mlen	int
;	O
{	O
int	O
c	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
c	int
=	O
rl_read_key	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
MB_CUR_MAX	O
>	O
1	int
&&	O
rl_byte_oriented	int
==	O
0	int
)	O
c	int
=	O
_rl_read_mbstring	function
(	O
c	int
,	O
mb	array
,	O
mlen	int
)	O
;	O
return	O
c	int
;	O
}	O
static	O
int	O
_rl_vi_callback_change_char	function
(	O
data	pointer
)	O
_rl_callback_generic_arg	struct
*	O
data	pointer
;	O
{	O
int	O
c	int
;	O
char	O
mb	array
[	O
MB_LEN_MAX	int
]	O
;	O
_rl_vi_last_replacement	int
=	O
c	int
=	O
_rl_vi_callback_getchar	function
(	O
mb	array
,	O
MB_LEN_MAX	int
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
_rl_callback_func	pointer
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
return	O
(	O
_rl_vi_change_char	function
(	O
data	pointer
->	O
count	int
,	O
c	int
,	O
mb	array
)	O
)	O
;	O
}	O
int	O
rl_vi_change_char	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
c	int
;	O
char	O
mb	array
[	O
MB_LEN_MAX	int
]	O
;	O
if	O
(	O
_rl_vi_redoing	int
)	O
{	O
c	int
=	O
_rl_vi_last_replacement	int
;	O
mb	array
[	O
0	int
]	O
=	O
c	int
;	O
mb	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	pointer
=	O
_rl_callback_data_alloc	function
(	O
count	int
)	O
;	O
_rl_callback_func	pointer
=	O
_rl_vi_callback_change_char	function
;	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
_rl_vi_last_replacement	int
=	O
c	int
=	O
_rl_vi_callback_getchar	function
(	O
mb	array
,	O
MB_LEN_MAX	int
)	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
(	O
_rl_vi_change_char	function
(	O
count	int
,	O
c	int
,	O
mb	array
)	O
)	O
;	O
}	O
int	O
rl_vi_subst	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
_rl_vi_redoing	int
==	O
0	int
)	O
rl_stuff_char	function
(	O
(	O
key	int
==	O
'S'	O
)	O
?	O
'c'	O
:	O
'l'	O
)	O
;	O
return	O
(	O
rl_vi_change_to	function
(	O
count	int
,	O
'c'	O
)	O
)	O
;	O
}	O
int	O
rl_vi_overstrike	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
_rl_vi_doing_insert	int
==	O
0	int
)	O
{	O
_rl_vi_doing_insert	int
=	O
1	int
;	O
rl_begin_undo_group	function
(	O
)	O
;	O
}	O
if	O
(	O
count	int
>	O
0	int
)	O
{	O
_rl_overwrite_char	function
(	O
count	int
,	O
key	int
)	O
;	O
vi_replace_count	int
+=	O
count	int
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_overstrike_delete	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
i	int
,	O
s	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
count	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
vi_replace_count	int
==	O
0	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
break	O
;	O
}	O
s	int
=	O
rl_point	int
;	O
if	O
(	O
rl_do_undo	function
(	O
)	O
)	O
vi_replace_count	int
--	O
;	O
if	O
(	O
rl_point	int
==	O
s	int
)	O
rl_backward_char	function
(	O
1	int
,	O
key	int
)	O
;	O
}	O
if	O
(	O
vi_replace_count	int
==	O
0	int
&&	O
_rl_vi_doing_insert	int
)	O
{	O
rl_end_undo_group	function
(	O
)	O
;	O
rl_do_undo	function
(	O
)	O
;	O
_rl_vi_doing_insert	int
=	O
0	int
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
int	O
rl_vi_replace	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
int	O
i	int
;	O
vi_replace_count	int
=	O
0	int
;	O
if	O
(	O
vi_replace_map	pointer
==	O
0	int
)	O
{	O
vi_replace_map	pointer
=	O
rl_make_bare_keymap	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
' '	O
;	O
i	int
++	O
)	O
if	O
(	O
vi_insertion_keymap	array
[	O
i	int
]	O
.	O
type	char
==	O
ISFUNC	int
)	O
vi_replace_map	pointer
[	O
i	int
]	O
.	O
function	pointer
=	O
vi_insertion_keymap	array
[	O
i	int
]	O
.	O
function	pointer
;	O
for	O
(	O
i	int
=	O
' '	O
;	O
i	int
<	O
KEYMAP_SIZE	int
;	O
i	int
++	O
)	O
vi_replace_map	pointer
[	O
i	int
]	O
.	O
function	pointer
=	O
rl_vi_overstrike	function
;	O
vi_replace_map	pointer
[	O
RUBOUT	int
]	O
.	O
function	pointer
=	O
rl_vi_overstrike_delete	function
;	O
vi_replace_map	pointer
[	O
ESC	O
]	O
.	O
function	pointer
=	O
rl_vi_movement_mode	function
;	O
vi_replace_map	pointer
[	O
RETURN	O
]	O
.	O
function	pointer
=	O
rl_newline	function
;	O
vi_replace_map	pointer
[	O
NEWLINE	char
]	O
.	O
function	pointer
=	O
rl_newline	function
;	O
if	O
(	O
vi_insertion_keymap	array
[	O
CTRL	O
(	O
'H'	O
)	O
]	O
.	O
type	char
==	O
ISFUNC	int
&&	O
vi_insertion_keymap	array
[	O
CTRL	O
(	O
'H'	O
)	O
]	O
.	O
function	pointer
==	O
rl_rubout	function
)	O
vi_replace_map	pointer
[	O
CTRL	O
(	O
'H'	O
)	O
]	O
.	O
function	pointer
=	O
rl_vi_overstrike_delete	function
;	O
}	O
rl_vi_start_inserting	function
(	O
key	int
,	O
1	int
,	O
rl_arg_sign	int
)	O
;	O
_rl_vi_last_key_before_insert	int
=	O
key	int
;	O
_rl_keymap	pointer
=	O
vi_replace_map	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
_rl_vi_set_mark	function
(	O
)	O
{	O
int	O
ch	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
ch	int
=	O
rl_read_key	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
ch	int
<	O
0	int
||	O
ch	int
<	O
'a'	O
||	O
ch	int
>	O
'z'	O
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
ch	int
-=	O
'a'	O
;	O
vi_mark_chars	array
[	O
ch	int
]	O
=	O
rl_point	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_rl_vi_callback_set_mark	function
(	O
data	pointer
)	O
_rl_callback_generic_arg	struct
*	O
data	pointer
;	O
{	O
_rl_callback_func	pointer
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
return	O
(	O
_rl_vi_set_mark	function
(	O
)	O
)	O
;	O
}	O
int	O
rl_vi_set_mark	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	pointer
=	O
0	int
;	O
_rl_callback_func	pointer
=	O
_rl_vi_callback_set_mark	function
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
_rl_vi_set_mark	function
(	O
)	O
)	O
;	O
}	O
static	O
int	O
_rl_vi_goto_mark	function
(	O
)	O
{	O
int	O
ch	int
;	O
RL_SETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
ch	int
=	O
rl_read_key	function
(	O
)	O
;	O
RL_UNSETSTATE	O
(	O
RL_STATE_MOREINPUT	int
)	O
;	O
if	O
(	O
ch	int
==	O
'`'	O
)	O
{	O
rl_point	int
=	O
rl_mark	int
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
ch	int
<	O
0	int
||	O
ch	int
<	O
'a'	O
||	O
ch	int
>	O
'z'	O
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
ch	int
-=	O
'a'	O
;	O
if	O
(	O
vi_mark_chars	array
[	O
ch	int
]	O
==	O
-	O
1	int
)	O
{	O
rl_ding	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
rl_point	int
=	O
vi_mark_chars	array
[	O
ch	int
]	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_rl_vi_callback_goto_mark	function
(	O
data	pointer
)	O
_rl_callback_generic_arg	struct
*	O
data	pointer
;	O
{	O
_rl_callback_func	pointer
=	O
0	int
;	O
_rl_want_redisplay	int
=	O
1	int
;	O
return	O
(	O
_rl_vi_goto_mark	function
(	O
)	O
)	O
;	O
}	O
int	O
rl_vi_goto_mark	function
(	O
count	int
,	O
key	int
)	O
int	O
count	int
,	O
key	int
;	O
{	O
if	O
(	O
RL_ISSTATE	O
(	O
RL_STATE_CALLBACK	int
)	O
)	O
{	O
_rl_callback_data	pointer
=	O
0	int
;	O
_rl_callback_func	pointer
=	O
_rl_vi_callback_goto_mark	function
;	O
return	O
(	O
0	int
)	O
;	O
}	O
return	O
(	O
_rl_vi_goto_mark	function
(	O
)	O
)	O
;	O
}	O
