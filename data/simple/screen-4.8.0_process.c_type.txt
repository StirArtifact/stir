extern	O
struct	O
comm	struct
comms	array
[	O
]	O
;	O
extern	O
char	O
*	O
rc_name	pointer
;	O
extern	O
char	O
*	O
RcFileName	pointer
,	O
*	O
home	pointer
;	O
extern	O
char	O
*	O
BellString	pointer
,	O
*	O
ActivityString	pointer
,	O
*	O
ShellProg	pointer
,	O
*	O
ShellArgs	array
[	O
]	O
;	O
extern	O
char	O
*	O
hstatusstring	pointer
,	O
*	O
captionstring	pointer
,	O
*	O
timestring	pointer
;	O
extern	O
char	O
*	O
wliststr	pointer
,	O
*	O
wlisttit	pointer
;	O
extern	O
int	O
captionalways	int
;	O
extern	O
int	O
queryflag	int
;	O
extern	O
char	O
*	O
hardcopydir	pointer
,	O
*	O
screenlogfile	pointer
,	O
*	O
logtstamp_string	pointer
;	O
extern	O
int	O
log_flush	int
,	O
logtstamp_on	int
,	O
logtstamp_after	int
;	O
extern	O
char	O
*	O
VisualBellString	pointer
;	O
extern	O
int	O
VBellWait	int
,	O
MsgWait	int
,	O
MsgMinWait	int
,	O
SilenceWait	int
;	O
extern	O
char	O
SockPath	array
[	O
]	O
,	O
*	O
SockName	pointer
;	O
extern	O
int	O
TtyMode	int
,	O
auto_detach	int
,	O
use_altscreen	int
;	O
extern	O
int	O
iflag	int
,	O
maxwin	int
;	O
extern	O
int	O
focusminwidth	int
,	O
focusminheight	int
;	O
extern	O
int	O
use_hardstatus	int
,	O
visual_bell	int
;	O
extern	O
int	O
attr2color	array
[	O
]	O
[	O
4	int
]	O
;	O
extern	O
int	O
nattr2color	int
;	O
extern	O
int	O
hardstatusemu	int
;	O
extern	O
char	O
*	O
printcmd	pointer
;	O
extern	O
int	O
default_startup	int
;	O
extern	O
int	O
defobuflimit	int
;	O
extern	O
int	O
defnonblock	int
;	O
extern	O
int	O
defmousetrack	int
;	O
extern	O
int	O
ZombieKey_destroy	int
;	O
extern	O
int	O
ZombieKey_resurrect	int
;	O
extern	O
int	O
ZombieKey_onerror	int
;	O
extern	O
int	O
defautonuke	int
;	O
extern	O
int	O
separate_sids	int
;	O
extern	O
struct	O
NewWindow	struct
nwin_default	struct
,	O
nwin_undef	struct
;	O
extern	O
int	O
join_with_cr	int
;	O
extern	O
int	O
compacthist	int
;	O
extern	O
int	O
search_ic	int
;	O
extern	O
int	O
pastefont	int
;	O
extern	O
unsigned	O
char	O
mark_key_tab	array
[	O
]	O
;	O
extern	O
char	O
*	O
BufferFile	pointer
;	O
extern	O
char	O
*	O
BufferFile	pointer
,	O
*	O
PowDetachString	pointer
;	O
extern	O
struct	O
acluser	struct
*	O
EffectiveAclUser	pointer
;	O
extern	O
struct	O
term	struct
term	struct
[	O
]	O
;	O
extern	O
char	O
*	O
kmapdef	array
[	O
]	O
;	O
extern	O
char	O
*	O
kmapadef	array
[	O
]	O
;	O
extern	O
char	O
*	O
kmapmdef	array
[	O
]	O
;	O
extern	O
struct	O
mchar	struct
mchar_so	struct
,	O
mchar_null	struct
;	O
extern	O
int	O
renditions	array
[	O
]	O
;	O
extern	O
int	O
VerboseCreate	int
;	O
extern	O
char	O
*	O
screenencodings	pointer
;	O
extern	O
int	O
cjkwidth	int
;	O
static	O
int	O
CheckArgNum	function
__P	O
(	O
(	O
int	O
,	O
char	O
*	O
*	O
)	O
)	O
;	O
static	O
void	O
ClearAction	function
__P	O
(	O
(	O
struct	O
action	struct
*	O
)	O
)	O
;	O
static	O
void	O
SaveAction	function
__P	O
(	O
(	O
struct	O
action	struct
*	O
,	O
int	O
,	O
char	O
*	O
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
NextWindow	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
PreviousWindow	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
MoreWindows	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
CollapseWindowlist	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
LogToggle	function
__P	O
(	O
(	O
int	O
)	O
)	O
;	O
static	O
void	O
ShowInfo	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
ShowDInfo	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
struct	O
win	struct
*	O
WindowByName	function
__P	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
WindowByNumber	function
__P	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
ParseOnOff	function
__P	O
(	O
(	O
struct	O
action	struct
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
ParseWinNum	function
__P	O
(	O
(	O
struct	O
action	struct
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
int	O
ParseBase	function
__P	O
(	O
(	O
struct	O
action	struct
*	O
,	O
char	O
*	O
,	O
int	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
ParseNum1000	function
__P	O
(	O
(	O
struct	O
action	struct
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
*	O
SaveArgs	function
__P	O
(	O
(	O
char	O
*	O
*	O
)	O
)	O
;	O
static	O
int	O
IsNum	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
Colonfin	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
InputSelect	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
InputSetenv	function
__P	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
InputAKA	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
int	O
InputSu	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
,	O
struct	O
acluser	struct
*	O
*	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
su_fin	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
AKAfin	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
copy_reg_fn	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
ins_reg_fn	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
process_fn	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
pass1	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
pass2	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
pow_detach_fn	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
digraph_fn	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
digraph_find	function
__P	O
(	O
(	O
const	O
char	O
*	O
buf	pointer
)	O
)	O
;	O
static	O
void	O
confirm_fn	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
IsOnDisplay	function
__P	O
(	O
(	O
struct	O
win	struct
*	O
)	O
)	O
;	O
static	O
void	O
ResizeRegions	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
ResizeFin	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
struct	O
action	struct
*	O
FindKtab	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
SelectFin	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
SelectLayoutFin	function
__P	O
(	O
(	O
char	O
*	O
,	O
int	O
,	O
char	O
*	O
)	O
)	O
;	O
static	O
void	O
ShowWindowsX	function
__P	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
struct	O
display	struct
*	O
display	struct
,	O
*	O
displays	pointer
;	O
extern	O
struct	O
win	struct
*	O
fore	pointer
,	O
*	O
console_window	pointer
,	O
*	O
windows	pointer
;	O
extern	O
struct	O
acluser	struct
*	O
users	pointer
;	O
extern	O
struct	O
layout	struct
*	O
layouts	pointer
,	O
*	O
layout_attach	pointer
,	O
layout_last_marker	struct
;	O
extern	O
struct	O
layout	struct
*	O
laytab	array
[	O
]	O
;	O
extern	O
char	O
screenterm	array
[	O
]	O
,	O
HostName	array
[	O
]	O
,	O
version	array
[	O
]	O
;	O
extern	O
struct	O
NewWindow	struct
nwin_undef	struct
,	O
nwin_default	struct
;	O
extern	O
struct	O
LayFuncs	struct
WinLf	struct
,	O
MarkLf	struct
;	O
extern	O
const	O
int	O
Z0width	int
,	O
Z1width	int
;	O
extern	O
int	O
real_uid	int
,	O
real_gid	int
;	O
extern	O
int	O
nethackflag	int
;	O
extern	O
struct	O
win	struct
*	O
*	O
wtab	pointer
;	O
extern	O
char	O
*	O
multi	pointer
;	O
extern	O
int	O
maxusercount	int
;	O
char	O
NullStr	array
[	O
]	O
=	O
""	pointer
;	O
struct	O
plop	struct
plop_tab	array
[	O
MAX_PLOP_DEFS	int
]	O
;	O
int	O
TtyMode	int
=	O
PTYMODE	int
;	O
int	O
hardcopy_append	int
=	O
0	int
;	O
int	O
all_norefresh	int
=	O
0	int
;	O
int	O
zmodem_mode	int
=	O
0	int
;	O
char	O
*	O
zmodem_sendcmd	pointer
;	O
char	O
*	O
zmodem_recvcmd	pointer
;	O
static	O
char	O
*	O
zmodes	array
[	O
4	int
]	O
=	O
{	O
"off"	pointer
,	O
"auto"	pointer
,	O
"catch"	pointer
,	O
"pass"	pointer
}	O
;	O
int	O
idletimo	int
;	O
struct	O
action	struct
idleaction	struct
;	O
char	O
*	O
*	O
blankerprg	pointer
;	O
struct	O
action	struct
ktab	array
[	O
256	int
+	O
KMAP_KEYS	O
]	O
;	O
struct	O
kclass	struct
{	O
struct	O
kclass	struct
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
struct	O
action	struct
ktab	array
[	O
256	int
+	O
KMAP_KEYS	O
]	O
;	O
}	O
;	O
struct	O
kclass	struct
*	O
kclasses	pointer
;	O
struct	O
action	struct
umtab	array
[	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
]	O
;	O
struct	O
action	struct
dmtab	array
[	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
]	O
;	O
struct	O
action	struct
mmtab	array
[	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
]	O
;	O
struct	O
kmap_ext	struct
*	O
kmap_exts	pointer
;	O
int	O
kmap_extn	int
;	O
static	O
int	O
maptimeout	int
=	O
300	int
;	O
struct	O
digraph	struct
{	O
unsigned	O
char	O
d	int
[	O
2	int
]	O
;	O
int	O
value	int
;	O
}	O
;	O
static	O
struct	O
digraph	struct
digraphs	array
[	O
MAX_DIGRAPH	int
+	O
1	int
]	O
=	O
{	O
{	O
{	O
' '	O
,	O
' '	O
}	O
,	O
160	int
}	O
,	O
{	O
{	O
'N'	O
,	O
'S'	O
}	O
,	O
160	int
}	O
,	O
{	O
{	O
'~'	O
,	O
'!'	O
}	O
,	O
161	int
}	O
,	O
{	O
{	O
'!'	O
,	O
'!'	O
}	O
,	O
161	int
}	O
,	O
{	O
{	O
'!'	O
,	O
'I'	O
}	O
,	O
161	int
}	O
,	O
{	O
{	O
'c'	O
,	O
'|'	O
}	O
,	O
162	int
}	O
,	O
{	O
{	O
'c'	O
,	O
't'	O
}	O
,	O
162	int
}	O
,	O
{	O
{	O
'$'	O
,	O
'$'	O
}	O
,	O
163	int
}	O
,	O
{	O
{	O
'P'	O
,	O
'd'	O
}	O
,	O
163	int
}	O
,	O
{	O
{	O
'o'	O
,	O
'x'	O
}	O
,	O
164	int
}	O
,	O
{	O
{	O
'C'	O
,	O
'u'	O
}	O
,	O
164	int
}	O
,	O
{	O
{	O
'C'	O
,	O
'u'	O
}	O
,	O
164	int
}	O
,	O
{	O
{	O
'E'	O
,	O
'u'	O
}	O
,	O
164	int
}	O
,	O
{	O
{	O
'Y'	O
,	O
'-'	O
}	O
,	O
165	int
}	O
,	O
{	O
{	O
'Y'	O
,	O
'e'	O
}	O
,	O
165	int
}	O
,	O
{	O
{	O
'|'	O
,	O
'|'	O
}	O
,	O
166	int
}	O
,	O
{	O
{	O
'B'	O
,	O
'B'	O
}	O
,	O
166	int
}	O
,	O
{	O
{	O
'p'	O
,	O
'a'	O
}	O
,	O
167	int
}	O
,	O
{	O
{	O
'S'	O
,	O
'E'	O
}	O
,	O
167	int
}	O
,	O
{	O
{	O
'"'	O
,	O
'"'	O
}	O
,	O
168	int
}	O
,	O
{	O
{	O
'\''	O
,	O
':'	O
}	O
,	O
168	int
}	O
,	O
{	O
{	O
'c'	O
,	O
'O'	O
}	O
,	O
169	int
}	O
,	O
{	O
{	O
'C'	O
,	O
'o'	O
}	O
,	O
169	int
}	O
,	O
{	O
{	O
'a'	O
,	O
'-'	O
}	O
,	O
170	int
}	O
,	O
{	O
{	O
'<'	O
,	O
'<'	O
}	O
,	O
171	int
}	O
,	O
{	O
{	O
'-'	O
,	O
','	O
}	O
,	O
172	int
}	O
,	O
{	O
{	O
'N'	O
,	O
'O'	O
}	O
,	O
172	int
}	O
,	O
{	O
{	O
'-'	O
,	O
'-'	O
}	O
,	O
173	int
}	O
,	O
{	O
{	O
'r'	O
,	O
'O'	O
}	O
,	O
174	int
}	O
,	O
{	O
{	O
'R'	O
,	O
'g'	O
}	O
,	O
174	int
}	O
,	O
{	O
{	O
'-'	O
,	O
'='	O
}	O
,	O
175	int
}	O
,	O
{	O
{	O
'\''	O
,	O
'm'	O
}	O
,	O
175	int
}	O
,	O
{	O
{	O
'~'	O
,	O
'o'	O
}	O
,	O
176	int
}	O
,	O
{	O
{	O
'D'	O
,	O
'G'	O
}	O
,	O
176	int
}	O
,	O
{	O
{	O
'+'	O
,	O
'-'	O
}	O
,	O
177	int
}	O
,	O
{	O
{	O
'2'	O
,	O
'2'	O
}	O
,	O
178	int
}	O
,	O
{	O
{	O
'2'	O
,	O
'S'	O
}	O
,	O
178	int
}	O
,	O
{	O
{	O
'3'	O
,	O
'3'	O
}	O
,	O
179	int
}	O
,	O
{	O
{	O
'3'	O
,	O
'S'	O
}	O
,	O
179	int
}	O
,	O
{	O
{	O
'\''	O
,	O
'\''	O
}	O
,	O
180	int
}	O
,	O
{	O
{	O
'j'	O
,	O
'u'	O
}	O
,	O
181	int
}	O
,	O
{	O
{	O
'M'	O
,	O
'y'	O
}	O
,	O
181	int
}	O
,	O
{	O
{	O
'p'	O
,	O
'p'	O
}	O
,	O
182	int
}	O
,	O
{	O
{	O
'P'	O
,	O
'I'	O
}	O
,	O
182	int
}	O
,	O
{	O
{	O
'~'	O
,	O
'.'	O
}	O
,	O
183	int
}	O
,	O
{	O
{	O
'.'	O
,	O
'M'	O
}	O
,	O
183	int
}	O
,	O
{	O
{	O
','	O
,	O
','	O
}	O
,	O
184	int
}	O
,	O
{	O
{	O
'\''	O
,	O
','	O
}	O
,	O
184	int
}	O
,	O
{	O
{	O
'1'	O
,	O
'1'	O
}	O
,	O
185	int
}	O
,	O
{	O
{	O
'1'	O
,	O
'S'	O
}	O
,	O
185	int
}	O
,	O
{	O
{	O
'o'	O
,	O
'-'	O
}	O
,	O
186	int
}	O
,	O
{	O
{	O
'>'	O
,	O
'>'	O
}	O
,	O
187	int
}	O
,	O
{	O
{	O
'1'	O
,	O
'4'	O
}	O
,	O
188	int
}	O
,	O
{	O
{	O
'1'	O
,	O
'2'	O
}	O
,	O
189	int
}	O
,	O
{	O
{	O
'3'	O
,	O
'4'	O
}	O
,	O
190	int
}	O
,	O
{	O
{	O
'~'	O
,	O
'?'	O
}	O
,	O
191	int
}	O
,	O
{	O
{	O
'?'	O
,	O
'?'	O
}	O
,	O
191	int
}	O
,	O
{	O
{	O
'?'	O
,	O
'I'	O
}	O
,	O
191	int
}	O
,	O
{	O
{	O
'A'	O
,	O
'`'	O
}	O
,	O
192	int
}	O
,	O
{	O
{	O
'A'	O
,	O
'!'	O
}	O
,	O
192	int
}	O
,	O
{	O
{	O
'A'	O
,	O
'\''	O
}	O
,	O
193	int
}	O
,	O
{	O
{	O
'A'	O
,	O
'^'	O
}	O
,	O
194	int
}	O
,	O
{	O
{	O
'A'	O
,	O
'>'	O
}	O
,	O
194	int
}	O
,	O
{	O
{	O
'A'	O
,	O
'~'	O
}	O
,	O
195	int
}	O
,	O
{	O
{	O
'A'	O
,	O
'?'	O
}	O
,	O
195	int
}	O
,	O
{	O
{	O
'A'	O
,	O
'"'	O
}	O
,	O
196	int
}	O
,	O
{	O
{	O
'A'	O
,	O
':'	O
}	O
,	O
196	int
}	O
,	O
{	O
{	O
'A'	O
,	O
'@'	O
}	O
,	O
197	int
}	O
,	O
{	O
{	O
'A'	O
,	O
'A'	O
}	O
,	O
197	int
}	O
,	O
{	O
{	O
'A'	O
,	O
'E'	O
}	O
,	O
198	int
}	O
,	O
{	O
{	O
'C'	O
,	O
','	O
}	O
,	O
199	int
}	O
,	O
{	O
{	O
'E'	O
,	O
'`'	O
}	O
,	O
200	int
}	O
,	O
{	O
{	O
'E'	O
,	O
'!'	O
}	O
,	O
200	int
}	O
,	O
{	O
{	O
'E'	O
,	O
'\''	O
}	O
,	O
201	int
}	O
,	O
{	O
{	O
'E'	O
,	O
'^'	O
}	O
,	O
202	int
}	O
,	O
{	O
{	O
'E'	O
,	O
'>'	O
}	O
,	O
202	int
}	O
,	O
{	O
{	O
'E'	O
,	O
'"'	O
}	O
,	O
203	int
}	O
,	O
{	O
{	O
'E'	O
,	O
':'	O
}	O
,	O
203	int
}	O
,	O
{	O
{	O
'I'	O
,	O
'`'	O
}	O
,	O
204	int
}	O
,	O
{	O
{	O
'I'	O
,	O
'!'	O
}	O
,	O
204	int
}	O
,	O
{	O
{	O
'I'	O
,	O
'\''	O
}	O
,	O
205	int
}	O
,	O
{	O
{	O
'I'	O
,	O
'^'	O
}	O
,	O
206	int
}	O
,	O
{	O
{	O
'I'	O
,	O
'>'	O
}	O
,	O
206	int
}	O
,	O
{	O
{	O
'I'	O
,	O
'"'	O
}	O
,	O
207	int
}	O
,	O
{	O
{	O
'I'	O
,	O
':'	O
}	O
,	O
207	int
}	O
,	O
{	O
{	O
'D'	O
,	O
'-'	O
}	O
,	O
208	int
}	O
,	O
{	O
{	O
'N'	O
,	O
'~'	O
}	O
,	O
209	int
}	O
,	O
{	O
{	O
'N'	O
,	O
'?'	O
}	O
,	O
209	int
}	O
,	O
{	O
{	O
'O'	O
,	O
'`'	O
}	O
,	O
210	int
}	O
,	O
{	O
{	O
'O'	O
,	O
'!'	O
}	O
,	O
210	int
}	O
,	O
{	O
{	O
'O'	O
,	O
'\''	O
}	O
,	O
211	int
}	O
,	O
{	O
{	O
'O'	O
,	O
'^'	O
}	O
,	O
212	int
}	O
,	O
{	O
{	O
'O'	O
,	O
'>'	O
}	O
,	O
212	int
}	O
,	O
{	O
{	O
'O'	O
,	O
'~'	O
}	O
,	O
213	int
}	O
,	O
{	O
{	O
'O'	O
,	O
'?'	O
}	O
,	O
213	int
}	O
,	O
{	O
{	O
'O'	O
,	O
'"'	O
}	O
,	O
214	int
}	O
,	O
{	O
{	O
'O'	O
,	O
':'	O
}	O
,	O
214	int
}	O
,	O
{	O
{	O
'/'	O
,	O
'\\'	O
}	O
,	O
215	int
}	O
,	O
{	O
{	O
'*'	O
,	O
'x'	O
}	O
,	O
215	int
}	O
,	O
{	O
{	O
'O'	O
,	O
'/'	O
}	O
,	O
216	int
}	O
,	O
{	O
{	O
'U'	O
,	O
'`'	O
}	O
,	O
217	int
}	O
,	O
{	O
{	O
'U'	O
,	O
'!'	O
}	O
,	O
217	int
}	O
,	O
{	O
{	O
'U'	O
,	O
'\''	O
}	O
,	O
218	int
}	O
,	O
{	O
{	O
'U'	O
,	O
'^'	O
}	O
,	O
219	int
}	O
,	O
{	O
{	O
'U'	O
,	O
'>'	O
}	O
,	O
219	int
}	O
,	O
{	O
{	O
'U'	O
,	O
'"'	O
}	O
,	O
220	int
}	O
,	O
{	O
{	O
'U'	O
,	O
':'	O
}	O
,	O
220	int
}	O
,	O
{	O
{	O
'Y'	O
,	O
'\''	O
}	O
,	O
221	int
}	O
,	O
{	O
{	O
'I'	O
,	O
'p'	O
}	O
,	O
222	int
}	O
,	O
{	O
{	O
'T'	O
,	O
'H'	O
}	O
,	O
222	int
}	O
,	O
{	O
{	O
's'	O
,	O
's'	O
}	O
,	O
223	int
}	O
,	O
{	O
{	O
's'	O
,	O
'"'	O
}	O
,	O
223	int
}	O
,	O
{	O
{	O
'a'	O
,	O
'`'	O
}	O
,	O
224	int
}	O
,	O
{	O
{	O
'a'	O
,	O
'!'	O
}	O
,	O
224	int
}	O
,	O
{	O
{	O
'a'	O
,	O
'\''	O
}	O
,	O
225	int
}	O
,	O
{	O
{	O
'a'	O
,	O
'^'	O
}	O
,	O
226	int
}	O
,	O
{	O
{	O
'a'	O
,	O
'>'	O
}	O
,	O
226	int
}	O
,	O
{	O
{	O
'a'	O
,	O
'~'	O
}	O
,	O
227	int
}	O
,	O
{	O
{	O
'a'	O
,	O
'?'	O
}	O
,	O
227	int
}	O
,	O
{	O
{	O
'a'	O
,	O
'"'	O
}	O
,	O
228	int
}	O
,	O
{	O
{	O
'a'	O
,	O
':'	O
}	O
,	O
228	int
}	O
,	O
{	O
{	O
'a'	O
,	O
'a'	O
}	O
,	O
229	int
}	O
,	O
{	O
{	O
'a'	O
,	O
'e'	O
}	O
,	O
230	int
}	O
,	O
{	O
{	O
'c'	O
,	O
','	O
}	O
,	O
231	int
}	O
,	O
{	O
{	O
'e'	O
,	O
'`'	O
}	O
,	O
232	int
}	O
,	O
{	O
{	O
'e'	O
,	O
'!'	O
}	O
,	O
232	int
}	O
,	O
{	O
{	O
'e'	O
,	O
'\''	O
}	O
,	O
233	int
}	O
,	O
{	O
{	O
'e'	O
,	O
'^'	O
}	O
,	O
234	int
}	O
,	O
{	O
{	O
'e'	O
,	O
'>'	O
}	O
,	O
234	int
}	O
,	O
{	O
{	O
'e'	O
,	O
'"'	O
}	O
,	O
235	int
}	O
,	O
{	O
{	O
'e'	O
,	O
':'	O
}	O
,	O
235	int
}	O
,	O
{	O
{	O
'i'	O
,	O
'`'	O
}	O
,	O
236	int
}	O
,	O
{	O
{	O
'i'	O
,	O
'!'	O
}	O
,	O
236	int
}	O
,	O
{	O
{	O
'i'	O
,	O
'\''	O
}	O
,	O
237	int
}	O
,	O
{	O
{	O
'i'	O
,	O
'^'	O
}	O
,	O
238	int
}	O
,	O
{	O
{	O
'i'	O
,	O
'>'	O
}	O
,	O
238	int
}	O
,	O
{	O
{	O
'i'	O
,	O
'"'	O
}	O
,	O
239	int
}	O
,	O
{	O
{	O
'i'	O
,	O
':'	O
}	O
,	O
239	int
}	O
,	O
{	O
{	O
'd'	O
,	O
'-'	O
}	O
,	O
240	int
}	O
,	O
{	O
{	O
'n'	O
,	O
'~'	O
}	O
,	O
241	int
}	O
,	O
{	O
{	O
'n'	O
,	O
'?'	O
}	O
,	O
241	int
}	O
,	O
{	O
{	O
'o'	O
,	O
'`'	O
}	O
,	O
242	int
}	O
,	O
{	O
{	O
'o'	O
,	O
'!'	O
}	O
,	O
242	int
}	O
,	O
{	O
{	O
'o'	O
,	O
'\''	O
}	O
,	O
243	int
}	O
,	O
{	O
{	O
'o'	O
,	O
'^'	O
}	O
,	O
244	int
}	O
,	O
{	O
{	O
'o'	O
,	O
'>'	O
}	O
,	O
244	int
}	O
,	O
{	O
{	O
'o'	O
,	O
'~'	O
}	O
,	O
245	int
}	O
,	O
{	O
{	O
'o'	O
,	O
'?'	O
}	O
,	O
245	int
}	O
,	O
{	O
{	O
'o'	O
,	O
'"'	O
}	O
,	O
246	int
}	O
,	O
{	O
{	O
'o'	O
,	O
':'	O
}	O
,	O
246	int
}	O
,	O
{	O
{	O
':'	O
,	O
'-'	O
}	O
,	O
247	int
}	O
,	O
{	O
{	O
'o'	O
,	O
'/'	O
}	O
,	O
248	int
}	O
,	O
{	O
{	O
'u'	O
,	O
'`'	O
}	O
,	O
249	int
}	O
,	O
{	O
{	O
'u'	O
,	O
'!'	O
}	O
,	O
249	int
}	O
,	O
{	O
{	O
'u'	O
,	O
'\''	O
}	O
,	O
250	int
}	O
,	O
{	O
{	O
'u'	O
,	O
'^'	O
}	O
,	O
251	int
}	O
,	O
{	O
{	O
'u'	O
,	O
'>'	O
}	O
,	O
251	int
}	O
,	O
{	O
{	O
'u'	O
,	O
'"'	O
}	O
,	O
252	int
}	O
,	O
{	O
{	O
'u'	O
,	O
':'	O
}	O
,	O
252	int
}	O
,	O
{	O
{	O
'y'	O
,	O
'\''	O
}	O
,	O
253	int
}	O
,	O
{	O
{	O
'i'	O
,	O
'p'	O
}	O
,	O
254	int
}	O
,	O
{	O
{	O
't'	O
,	O
'h'	O
}	O
,	O
254	int
}	O
,	O
{	O
{	O
'y'	O
,	O
'"'	O
}	O
,	O
255	int
}	O
,	O
{	O
{	O
'y'	O
,	O
':'	O
}	O
,	O
255	int
}	O
,	O
{	O
{	O
'"'	O
,	O
'['	O
}	O
,	O
196	int
}	O
,	O
{	O
{	O
'"'	O
,	O
'\\'	O
}	O
,	O
214	int
}	O
,	O
{	O
{	O
'"'	O
,	O
']'	O
}	O
,	O
220	int
}	O
,	O
{	O
{	O
'"'	O
,	O
'{'	O
}	O
,	O
228	int
}	O
,	O
{	O
{	O
'"'	O
,	O
'|'	O
}	O
,	O
246	int
}	O
,	O
{	O
{	O
'"'	O
,	O
'}'	O
}	O
,	O
252	int
}	O
,	O
{	O
{	O
'"'	O
,	O
'~'	O
}	O
,	O
223	int
}	O
}	O
;	O
static	O
char	O
*	O
resizeprompts	array
[	O
]	O
=	O
{	O
"resize # lines: "	pointer
,	O
"resize -h # lines: "	pointer
,	O
"resize -v # lines: "	pointer
,	O
"resize -b # lines: "	pointer
,	O
"resize -l # lines: "	pointer
,	O
"resize -l -h # lines: "	pointer
,	O
"resize -l -v # lines: "	pointer
,	O
"resize -l -b # lines: "	pointer
,	O
}	O
;	O
static	O
int	O
parse_input_int	function
(	O
buf	pointer
,	O
len	int
,	O
val	array
)	O
const	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
int	O
*	O
val	array
;	O
{	O
int	O
x	int
=	O
0	int
,	O
i	int
;	O
if	O
(	O
len	int
>=	O
1	int
&&	O
(	O
(	O
*	O
buf	pointer
==	O
'U'	O
&&	O
buf	pointer
[	O
1	int
]	O
==	O
'+'	O
)	O
||	O
(	O
*	O
buf	pointer
==	O
'0'	O
&&	O
(	O
buf	pointer
[	O
1	int
]	O
==	O
'x'	O
||	O
buf	pointer
[	O
1	int
]	O
==	O
'X'	O
)	O
)	O
)	O
)	O
{	O
x	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
buf	pointer
[	O
i	int
]	O
>=	O
'0'	O
&&	O
buf	pointer
[	O
i	int
]	O
<=	O
'9'	O
)	O
x	int
=	O
x	int
*	O
16	int
|	O
(	O
buf	pointer
[	O
i	int
]	O
-	O
'0'	O
)	O
;	O
else	O
if	O
(	O
buf	pointer
[	O
i	int
]	O
>=	O
'a'	O
&&	O
buf	pointer
[	O
i	int
]	O
<=	O
'f'	O
)	O
x	int
=	O
x	int
*	O
16	int
|	O
(	O
buf	pointer
[	O
i	int
]	O
-	O
(	O
'a'	O
-	O
10	int
)	O
)	O
;	O
else	O
if	O
(	O
buf	pointer
[	O
i	int
]	O
>=	O
'A'	O
&&	O
buf	pointer
[	O
i	int
]	O
<=	O
'F'	O
)	O
x	int
=	O
x	int
*	O
16	int
|	O
(	O
buf	pointer
[	O
i	int
]	O
-	O
(	O
'A'	O
-	O
10	int
)	O
)	O
;	O
else	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
==	O
'0'	O
)	O
{	O
x	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
len	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
buf	pointer
[	O
i	int
]	O
<	O
'0'	O
||	O
buf	pointer
[	O
i	int
]	O
>	O
'7'	O
)	O
return	O
0	int
;	O
x	int
=	O
x	int
*	O
8	int
|	O
(	O
buf	pointer
[	O
i	int
]	O
-	O
'0'	O
)	O
;	O
}	O
}	O
else	O
return	O
0	int
;	O
*	O
val	array
=	O
x	int
;	O
return	O
1	int
;	O
}	O
char	O
*	O
noargs	array
[	O
1	int
]	O
;	O
int	O
enter_window_name_mode	int
=	O
0	int
;	O
void	O
InitKeytab	function
(	O
)	O
{	O
register	O
unsigned	O
int	O
i	int
;	O
char	O
*	O
argarr	array
[	O
2	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
ktab	array
)	O
/	O
sizeof	O
(	O
*	O
ktab	array
)	O
;	O
i	int
++	O
)	O
{	O
ktab	array
[	O
i	int
]	O
.	O
nr	int
=	O
RC_ILLEGAL	O
;	O
ktab	array
[	O
i	int
]	O
.	O
args	pointer
=	O
noargs	array
;	O
ktab	array
[	O
i	int
]	O
.	O
argl	pointer
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
;	O
i	int
++	O
)	O
{	O
umtab	array
[	O
i	int
]	O
.	O
nr	int
=	O
RC_ILLEGAL	O
;	O
umtab	array
[	O
i	int
]	O
.	O
args	pointer
=	O
noargs	array
;	O
umtab	array
[	O
i	int
]	O
.	O
argl	pointer
=	O
0	int
;	O
dmtab	array
[	O
i	int
]	O
.	O
nr	int
=	O
RC_ILLEGAL	O
;	O
dmtab	array
[	O
i	int
]	O
.	O
args	pointer
=	O
noargs	array
;	O
dmtab	array
[	O
i	int
]	O
.	O
argl	pointer
=	O
0	int
;	O
mmtab	array
[	O
i	int
]	O
.	O
nr	int
=	O
RC_ILLEGAL	O
;	O
mmtab	array
[	O
i	int
]	O
.	O
args	pointer
=	O
noargs	array
;	O
mmtab	array
[	O
i	int
]	O
.	O
argl	pointer
=	O
0	int
;	O
}	O
argarr	array
[	O
1	int
]	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NKMAPDEF	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
+	O
KMAPDEFSTART	int
<	O
T_CAPS	int
)	O
continue	O
;	O
if	O
(	O
i	int
+	O
KMAPDEFSTART	int
>=	O
T_CAPS	int
+	O
KMAP_KEYS	O
)	O
continue	O
;	O
if	O
(	O
kmapdef	array
[	O
i	int
]	O
==	O
0	int
)	O
continue	O
;	O
argarr	array
[	O
0	int
]	O
=	O
kmapdef	array
[	O
i	int
]	O
;	O
SaveAction	function
(	O
dmtab	array
+	O
i	int
+	O
(	O
KMAPDEFSTART	int
-	O
T_CAPS	int
)	O
,	O
RC_STUFF	int
,	O
argarr	array
,	O
0	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NKMAPADEF	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
+	O
KMAPADEFSTART	int
<	O
T_CURSOR	int
)	O
continue	O
;	O
if	O
(	O
i	int
+	O
KMAPADEFSTART	int
>=	O
T_CURSOR	int
+	O
KMAP_AKEYS	O
)	O
continue	O
;	O
if	O
(	O
kmapadef	array
[	O
i	int
]	O
==	O
0	int
)	O
continue	O
;	O
argarr	array
[	O
0	int
]	O
=	O
kmapadef	array
[	O
i	int
]	O
;	O
SaveAction	function
(	O
dmtab	array
+	O
i	int
+	O
(	O
KMAPADEFSTART	int
-	O
T_CURSOR	int
+	O
KMAP_KEYS	O
)	O
,	O
RC_STUFF	int
,	O
argarr	array
,	O
0	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NKMAPMDEF	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
+	O
KMAPMDEFSTART	int
<	O
T_CAPS	int
)	O
continue	O
;	O
if	O
(	O
i	int
+	O
KMAPMDEFSTART	int
>=	O
T_CAPS	int
+	O
KMAP_KEYS	O
)	O
continue	O
;	O
if	O
(	O
kmapmdef	array
[	O
i	int
]	O
==	O
0	int
)	O
continue	O
;	O
argarr	array
[	O
0	int
]	O
=	O
kmapmdef	array
[	O
i	int
]	O
;	O
argarr	array
[	O
1	int
]	O
=	O
0	int
;	O
SaveAction	function
(	O
mmtab	array
+	O
i	int
+	O
(	O
KMAPMDEFSTART	int
-	O
T_CAPS	int
)	O
,	O
RC_STUFF	int
,	O
argarr	array
,	O
0	int
)	O
;	O
}	O
ktab	array
[	O
'h'	O
]	O
.	O
nr	int
=	O
RC_HARDCOPY	int
;	O
ktab	array
[	O
'z'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'z'	O
)	O
]	O
.	O
nr	int
=	O
RC_SUSPEND	int
;	O
ktab	array
[	O
'c'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'c'	O
)	O
]	O
.	O
nr	int
=	O
RC_SCREEN	int
;	O
ktab	array
[	O
' '	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
' '	O
)	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
'n'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'n'	O
)	O
]	O
.	O
nr	int
=	O
RC_NEXT	int
;	O
ktab	array
[	O
'N'	O
]	O
.	O
nr	int
=	O
RC_NUMBER	int
;	O
ktab	array
[	O
Ctrl	O
(	O
'h'	O
)	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
0177	int
]	O
.	O
nr	int
=	O
ktab	array
[	O
'p'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'p'	O
)	O
]	O
.	O
nr	int
=	O
RC_PREV	int
;	O
ktab	array
[	O
'k'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'k'	O
)	O
]	O
.	O
nr	int
=	O
RC_KILL	int
;	O
ktab	array
[	O
'l'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'l'	O
)	O
]	O
.	O
nr	int
=	O
RC_REDISPLAY	int
;	O
ktab	array
[	O
'w'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'w'	O
)	O
]	O
.	O
nr	int
=	O
RC_WINDOWS	int
;	O
ktab	array
[	O
'v'	O
]	O
.	O
nr	int
=	O
RC_VERSION	int
;	O
ktab	array
[	O
Ctrl	O
(	O
'v'	O
)	O
]	O
.	O
nr	int
=	O
RC_DIGRAPH	int
;	O
ktab	array
[	O
'q'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'q'	O
)	O
]	O
.	O
nr	int
=	O
RC_XON	int
;	O
ktab	array
[	O
's'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
's'	O
)	O
]	O
.	O
nr	int
=	O
RC_XOFF	int
;	O
ktab	array
[	O
't'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
't'	O
)	O
]	O
.	O
nr	int
=	O
RC_TIME	int
;	O
ktab	array
[	O
'i'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'i'	O
)	O
]	O
.	O
nr	int
=	O
RC_INFO	int
;	O
ktab	array
[	O
'm'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'm'	O
)	O
]	O
.	O
nr	int
=	O
RC_LASTMSG	int
;	O
ktab	array
[	O
'A'	O
]	O
.	O
nr	int
=	O
RC_TITLE	int
;	O
ktab	array
[	O
'L'	O
]	O
.	O
nr	int
=	O
RC_LOGIN	int
;	O
ktab	array
[	O
','	O
]	O
.	O
nr	int
=	O
RC_LICENSE	int
;	O
ktab	array
[	O
'W'	O
]	O
.	O
nr	int
=	O
RC_WIDTH	int
;	O
ktab	array
[	O
'.'	O
]	O
.	O
nr	int
=	O
RC_DUMPTERMCAP	int
;	O
ktab	array
[	O
Ctrl	O
(	O
'\\'	O
)	O
]	O
.	O
nr	int
=	O
RC_QUIT	int
;	O
ktab	array
[	O
'd'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'd'	O
)	O
]	O
.	O
nr	int
=	O
RC_DETACH	int
;	O
ktab	array
[	O
'D'	O
]	O
.	O
nr	int
=	O
RC_POW_DETACH	int
;	O
ktab	array
[	O
'r'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'r'	O
)	O
]	O
.	O
nr	int
=	O
RC_WRAP	int
;	O
ktab	array
[	O
'f'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'f'	O
)	O
]	O
.	O
nr	int
=	O
RC_FLOW	int
;	O
ktab	array
[	O
'C'	O
]	O
.	O
nr	int
=	O
RC_CLEAR	int
;	O
ktab	array
[	O
'Z'	O
]	O
.	O
nr	int
=	O
RC_RESET	int
;	O
ktab	array
[	O
'H'	O
]	O
.	O
nr	int
=	O
RC_LOG	int
;	O
ktab	array
[	O
'M'	O
]	O
.	O
nr	int
=	O
RC_MONITOR	int
;	O
ktab	array
[	O
'?'	O
]	O
.	O
nr	int
=	O
RC_HELP	int
;	O
ktab	array
[	O
'*'	O
]	O
.	O
nr	int
=	O
RC_DISPLAYS	int
;	O
{	O
char	O
*	O
args	pointer
[	O
2	int
]	O
;	O
args	pointer
[	O
0	int
]	O
=	O
"-"	pointer
;	O
args	pointer
[	O
1	int
]	O
=	O
NULL	O
;	O
SaveAction	function
(	O
ktab	array
+	O
'-'	O
,	O
RC_SELECT	int
,	O
args	pointer
,	O
0	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
(	O
maxwin	int
&&	O
maxwin	int
<	O
10	int
)	O
?	O
maxwin	int
:	O
10	int
)	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
args	pointer
[	O
2	int
]	O
,	O
arg1	array
[	O
10	int
]	O
;	O
args	pointer
[	O
0	int
]	O
=	O
arg1	array
;	O
args	pointer
[	O
1	int
]	O
=	O
0	int
;	O
sprintf	function
(	O
arg1	array
,	O
"%d"	pointer
,	O
i	int
)	O
;	O
SaveAction	function
(	O
ktab	array
+	O
'0'	O
+	O
i	int
,	O
RC_SELECT	int
,	O
args	pointer
,	O
0	int
)	O
;	O
}	O
ktab	array
[	O
'\''	O
]	O
.	O
nr	int
=	O
RC_SELECT	int
;	O
{	O
char	O
*	O
args	pointer
[	O
2	int
]	O
;	O
args	pointer
[	O
0	int
]	O
=	O
"-b"	pointer
;	O
args	pointer
[	O
1	int
]	O
=	O
0	int
;	O
SaveAction	function
(	O
ktab	array
+	O
'"'	O
,	O
RC_WINDOWLIST	int
,	O
args	pointer
,	O
0	int
)	O
;	O
}	O
ktab	array
[	O
Ctrl	O
(	O
'G'	O
)	O
]	O
.	O
nr	int
=	O
RC_VBELL	int
;	O
ktab	array
[	O
':'	O
]	O
.	O
nr	int
=	O
RC_COLON	int
;	O
ktab	array
[	O
'['	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'['	O
)	O
]	O
.	O
nr	int
=	O
RC_COPY	int
;	O
{	O
char	O
*	O
args	pointer
[	O
2	int
]	O
;	O
args	pointer
[	O
0	int
]	O
=	O
"."	pointer
;	O
args	pointer
[	O
1	int
]	O
=	O
0	int
;	O
SaveAction	function
(	O
ktab	array
+	O
']'	O
,	O
RC_PASTE	int
,	O
args	pointer
,	O
0	int
)	O
;	O
SaveAction	function
(	O
ktab	array
+	O
Ctrl	O
(	O
']'	O
)	O
,	O
RC_PASTE	int
,	O
args	pointer
,	O
0	int
)	O
;	O
}	O
ktab	array
[	O
'{'	O
]	O
.	O
nr	int
=	O
RC_HISTORY	int
;	O
ktab	array
[	O
'}'	O
]	O
.	O
nr	int
=	O
RC_HISTORY	int
;	O
ktab	array
[	O
'>'	O
]	O
.	O
nr	int
=	O
RC_WRITEBUF	int
;	O
ktab	array
[	O
'<'	O
]	O
.	O
nr	int
=	O
RC_READBUF	int
;	O
ktab	array
[	O
'='	O
]	O
.	O
nr	int
=	O
RC_REMOVEBUF	int
;	O
ktab	array
[	O
'D'	O
]	O
.	O
nr	int
=	O
RC_POW_DETACH	int
;	O
ktab	array
[	O
'x'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'x'	O
)	O
]	O
.	O
nr	int
=	O
RC_LOCKSCREEN	int
;	O
ktab	array
[	O
'b'	O
]	O
.	O
nr	int
=	O
ktab	array
[	O
Ctrl	O
(	O
'b'	O
)	O
]	O
.	O
nr	int
=	O
RC_BREAK	int
;	O
ktab	array
[	O
'B'	O
]	O
.	O
nr	int
=	O
RC_POW_BREAK	int
;	O
ktab	array
[	O
'_'	O
]	O
.	O
nr	int
=	O
RC_SILENCE	int
;	O
ktab	array
[	O
'S'	O
]	O
.	O
nr	int
=	O
RC_SPLIT	int
;	O
ktab	array
[	O
'Q'	O
]	O
.	O
nr	int
=	O
RC_ONLY	int
;	O
ktab	array
[	O
'X'	O
]	O
.	O
nr	int
=	O
RC_REMOVE	int
;	O
ktab	array
[	O
'F'	O
]	O
.	O
nr	int
=	O
RC_FIT	int
;	O
ktab	array
[	O
'\t'	O
]	O
.	O
nr	int
=	O
RC_FOCUS	int
;	O
{	O
char	O
*	O
args	pointer
[	O
2	int
]	O
;	O
args	pointer
[	O
0	int
]	O
=	O
"prev"	pointer
;	O
args	pointer
[	O
1	int
]	O
=	O
0	int
;	O
SaveAction	function
(	O
ktab	array
+	O
T_BACKTAB	int
-	O
T_CAPS	int
+	O
256	int
,	O
RC_FOCUS	int
,	O
args	pointer
,	O
0	int
)	O
;	O
}	O
{	O
char	O
*	O
args	pointer
[	O
2	int
]	O
;	O
args	pointer
[	O
0	int
]	O
=	O
"-v"	pointer
;	O
args	pointer
[	O
1	int
]	O
=	O
0	int
;	O
SaveAction	function
(	O
ktab	array
+	O
'|'	O
,	O
RC_SPLIT	int
,	O
args	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
DefaultEsc	int
>=	O
0	int
)	O
{	O
ClearAction	function
(	O
&	O
ktab	array
[	O
DefaultEsc	int
]	O
)	O
;	O
ktab	array
[	O
DefaultEsc	int
]	O
.	O
nr	int
=	O
RC_OTHER	int
;	O
}	O
if	O
(	O
DefaultMetaEsc	int
>=	O
0	int
)	O
{	O
ClearAction	function
(	O
&	O
ktab	array
[	O
DefaultMetaEsc	int
]	O
)	O
;	O
ktab	array
[	O
DefaultMetaEsc	int
]	O
.	O
nr	int
=	O
RC_META	int
;	O
}	O
idleaction	struct
.	O
nr	int
=	O
RC_BLANKER	int
;	O
idleaction	struct
.	O
args	pointer
=	O
noargs	array
;	O
idleaction	struct
.	O
argl	pointer
=	O
0	int
;	O
}	O
static	O
struct	O
action	struct
*	O
FindKtab	function
(	O
class	pointer
,	O
create	struct
)	O
char	O
*	O
class	pointer
;	O
int	O
create	struct
;	O
{	O
struct	O
kclass	struct
*	O
kp	pointer
,	O
*	O
*	O
kpp	pointer
;	O
int	O
i	int
;	O
if	O
(	O
class	pointer
==	O
0	int
)	O
return	O
ktab	array
;	O
for	O
(	O
kpp	pointer
=	O
&	O
kclasses	pointer
;	O
(	O
kp	pointer
=	O
*	O
kpp	pointer
)	O
!=	O
0	int
;	O
kpp	pointer
=	O
&	O
kp	pointer
->	O
next	pointer
)	O
if	O
(	O
!	O
strcmp	function
(	O
kp	pointer
->	O
name	pointer
,	O
class	pointer
)	O
)	O
break	O
;	O
if	O
(	O
kp	pointer
==	O
0	int
)	O
{	O
if	O
(	O
!	O
create	struct
)	O
return	O
0	int
;	O
if	O
(	O
strlen	function
(	O
class	pointer
)	O
>	O
80	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Command class name too long."	pointer
)	O
;	O
return	O
0	int
;	O
}	O
kp	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
kp	pointer
)	O
)	O
;	O
if	O
(	O
kp	pointer
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
return	O
0	int
;	O
}	O
kp	pointer
->	O
name	pointer
=	O
SaveStr	function
(	O
class	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
kp	pointer
->	O
ktab	array
)	O
/	O
sizeof	O
(	O
*	O
kp	pointer
->	O
ktab	array
)	O
)	O
;	O
i	int
++	O
)	O
{	O
kp	pointer
->	O
ktab	array
[	O
i	int
]	O
.	O
nr	int
=	O
RC_ILLEGAL	O
;	O
kp	pointer
->	O
ktab	array
[	O
i	int
]	O
.	O
args	pointer
=	O
noargs	array
;	O
kp	pointer
->	O
ktab	array
[	O
i	int
]	O
.	O
argl	pointer
=	O
0	int
;	O
kp	pointer
->	O
ktab	array
[	O
i	int
]	O
.	O
quiet	int
=	O
0	int
;	O
}	O
kp	pointer
->	O
next	pointer
=	O
0	int
;	O
*	O
kpp	pointer
=	O
kp	pointer
;	O
}	O
return	O
kp	pointer
->	O
ktab	array
;	O
}	O
static	O
void	O
ClearAction	function
(	O
act	pointer
)	O
struct	O
action	struct
*	O
act	pointer
;	O
{	O
char	O
*	O
*	O
p	pointer
;	O
if	O
(	O
act	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
return	O
;	O
act	pointer
->	O
nr	int
=	O
RC_ILLEGAL	O
;	O
if	O
(	O
act	pointer
->	O
args	pointer
==	O
noargs	array
)	O
return	O
;	O
for	O
(	O
p	pointer
=	O
act	pointer
->	O
args	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
free	function
(	O
*	O
p	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
act	pointer
->	O
args	pointer
)	O
;	O
act	pointer
->	O
args	pointer
=	O
noargs	array
;	O
act	pointer
->	O
argl	pointer
=	O
0	int
;	O
}	O
void	O
ProcessInput	function
(	O
ibuf	pointer
,	O
ilen	int
)	O
char	O
*	O
ibuf	pointer
;	O
int	O
ilen	int
;	O
{	O
int	O
ch	int
,	O
slen	int
;	O
unsigned	O
char	O
*	O
s	pointer
,	O
*	O
q	pointer
;	O
int	O
i	int
,	O
l	int
;	O
char	O
*	O
p	pointer
;	O
debug1	O
(	O
"ProcessInput: %d bytes\n"	pointer
,	O
ilen	int
)	O
;	O
if	O
(	O
display	struct
==	O
0	int
||	O
ilen	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
D_seql	O
)	O
evdeq	function
(	O
&	O
D_mapev	O
)	O
;	O
slen	int
=	O
ilen	int
;	O
s	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
ibuf	pointer
;	O
while	O
(	O
ilen	int
--	O
>	O
0	int
)	O
{	O
ch	int
=	O
*	O
s	pointer
++	O
;	O
if	O
(	O
D_dontmap	O
||	O
!	O
D_nseqs	O
)	O
{	O
D_dontmap	O
=	O
0	int
;	O
continue	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
debug3	O
(	O
"cmp %c %c[%d]\n"	pointer
,	O
ch	int
,	O
*	O
D_seqp	O
,	O
D_seqp	O
-	O
D_kmaps	O
)	O
;	O
if	O
(	O
*	O
D_seqp	O
!=	O
ch	int
)	O
{	O
l	int
=	O
D_seqp	O
[	O
D_seqp	O
[	O
-	O
D_seql	O
-	O
1	int
]	O
+	O
1	int
]	O
;	O
if	O
(	O
l	int
)	O
{	O
D_seqp	O
+=	O
l	int
*	O
2	int
+	O
4	int
;	O
debug1	O
(	O
"miss %d\n"	pointer
,	O
D_seqp	O
-	O
D_kmaps	O
)	O
;	O
continue	O
;	O
}	O
debug	O
(	O
"complete miss\n"	pointer
)	O
;	O
D_mapdefault	O
=	O
0	int
;	O
l	int
=	O
D_seql	O
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
D_seqp	O
-	O
l	int
;	O
D_seql	O
=	O
0	int
;	O
D_seqp	O
=	O
D_kmaps	O
+	O
3	int
;	O
if	O
(	O
l	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
q	pointer
=	O
D_seqh	O
)	O
!=	O
0	int
)	O
{	O
D_seqh	O
=	O
0	int
;	O
i	int
=	O
q	pointer
[	O
0	int
]	O
<<	O
8	int
|	O
q	pointer
[	O
1	int
]	O
;	O
i	int
&=	O
~	O
KMAP_NOTIMEOUT	int
;	O
debug1	O
(	O
"Mapping former hit #%d - "	pointer
,	O
i	int
)	O
;	O
debug2	O
(	O
"%d(%s) - "	pointer
,	O
q	pointer
[	O
2	int
]	O
,	O
q	pointer
+	O
3	int
)	O
;	O
if	O
(	O
StuffKey	function
(	O
i	int
)	O
)	O
ProcessInput2	function
(	O
(	O
char	O
*	O
)	O
q	pointer
+	O
3	int
,	O
q	pointer
[	O
2	int
]	O
)	O
;	O
if	O
(	O
display	struct
==	O
0	int
)	O
return	O
;	O
l	int
-=	O
q	pointer
[	O
2	int
]	O
;	O
p	pointer
+=	O
q	pointer
[	O
2	int
]	O
;	O
}	O
else	O
D_dontmap	O
=	O
1	int
;	O
debug1	O
(	O
"flush old %d\n"	pointer
,	O
l	int
)	O
;	O
ProcessInput	function
(	O
p	pointer
,	O
l	int
)	O
;	O
if	O
(	O
display	struct
==	O
0	int
)	O
return	O
;	O
evdeq	function
(	O
&	O
D_mapev	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
D_seql	O
++	O
==	O
0	int
)	O
{	O
slen	int
-=	O
ilen	int
+	O
1	int
;	O
debug1	O
(	O
"finish old %d\n"	pointer
,	O
slen	int
)	O
;	O
if	O
(	O
slen	int
)	O
ProcessInput2	function
(	O
ibuf	pointer
,	O
slen	int
)	O
;	O
if	O
(	O
display	struct
==	O
0	int
)	O
return	O
;	O
D_seqh	O
=	O
0	int
;	O
}	O
ibuf	pointer
=	O
(	O
char	O
*	O
)	O
s	pointer
;	O
slen	int
=	O
ilen	int
;	O
D_seqp	O
++	O
;	O
l	int
=	O
D_seql	O
;	O
debug2	O
(	O
"length am %d, want %d\n"	pointer
,	O
l	int
,	O
D_seqp	O
[	O
-	O
l	int
-	O
1	int
]	O
)	O
;	O
if	O
(	O
l	int
==	O
D_seqp	O
[	O
-	O
l	int
-	O
1	int
]	O
)	O
{	O
if	O
(	O
D_seqp	O
[	O
l	int
]	O
!=	O
l	int
)	O
{	O
q	pointer
=	O
D_seqp	O
+	O
1	int
+	O
l	int
;	O
if	O
(	O
D_kmaps	O
+	O
D_nseqs	O
>	O
q	pointer
&&	O
q	pointer
[	O
2	int
]	O
>	O
l	int
&&	O
!	O
bcmp	function
(	O
D_seqp	O
-	O
l	int
,	O
q	pointer
+	O
3	int
,	O
l	int
)	O
)	O
{	O
debug1	O
(	O
"have another mapping (%s), delay execution\n"	pointer
,	O
q	pointer
+	O
3	int
)	O
;	O
D_seqh	O
=	O
D_seqp	O
-	O
3	int
-	O
l	int
;	O
D_seqp	O
=	O
q	pointer
+	O
3	int
+	O
l	int
;	O
break	O
;	O
}	O
}	O
i	int
=	O
D_seqp	O
[	O
-	O
l	int
-	O
3	int
]	O
<<	O
8	int
|	O
D_seqp	O
[	O
-	O
l	int
-	O
2	int
]	O
;	O
i	int
&=	O
~	O
KMAP_NOTIMEOUT	int
;	O
debug1	O
(	O
"Mapping #%d - "	pointer
,	O
i	int
)	O
;	O
p	pointer
=	O
(	O
char	O
*	O
)	O
D_seqp	O
-	O
l	int
;	O
debug2	O
(	O
"%d(%s) - "	pointer
,	O
l	int
,	O
p	pointer
)	O
;	O
D_seql	O
=	O
0	int
;	O
D_seqp	O
=	O
D_kmaps	O
+	O
3	int
;	O
D_seqh	O
=	O
0	int
;	O
if	O
(	O
StuffKey	function
(	O
i	int
)	O
)	O
ProcessInput2	function
(	O
p	pointer
,	O
l	int
)	O
;	O
if	O
(	O
display	struct
==	O
0	int
)	O
return	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
D_seql	O
)	O
{	O
debug	O
(	O
"am in sequence -> check for timeout\n"	pointer
)	O
;	O
l	int
=	O
D_seql	O
;	O
for	O
(	O
s	pointer
=	O
D_seqp	O
;	O
;	O
s	pointer
+=	O
i	int
*	O
2	int
+	O
4	int
)	O
{	O
if	O
(	O
s	pointer
[	O
-	O
l	int
-	O
3	int
]	O
&	O
KMAP_NOTIMEOUT	int
>>	O
8	int
)	O
break	O
;	O
if	O
(	O
(	O
i	int
=	O
s	pointer
[	O
s	pointer
[	O
-	O
l	int
-	O
1	int
]	O
+	O
1	int
]	O
)	O
==	O
0	int
)	O
{	O
SetTimeout	function
(	O
&	O
D_mapev	O
,	O
maptimeout	int
)	O
;	O
evenq	function
(	O
&	O
D_mapev	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
ProcessInput2	function
(	O
ibuf	pointer
,	O
slen	int
)	O
;	O
}	O
void	O
ProcessInput2	function
(	O
ibuf	pointer
,	O
ilen	int
)	O
char	O
*	O
ibuf	pointer
;	O
int	O
ilen	int
;	O
{	O
char	O
*	O
s	pointer
;	O
int	O
ch	int
,	O
slen	int
;	O
struct	O
action	struct
*	O
ktabp	pointer
;	O
debug1	O
(	O
"ProcessInput2: %d bytes\n"	pointer
,	O
ilen	int
)	O
;	O
while	O
(	O
ilen	int
&&	O
display	struct
)	O
{	O
debug1	O
(	O
" - ilen now %d bytes\n"	pointer
,	O
ilen	int
)	O
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
fore	pointer
=	O
D_fore	O
;	O
slen	int
=	O
ilen	int
;	O
s	pointer
=	O
ibuf	pointer
;	O
if	O
(	O
!	O
D_ESCseen	O
)	O
{	O
while	O
(	O
ilen	int
>	O
0	int
)	O
{	O
if	O
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
++	O
==	O
D_user	O
->	O
u_Esc	int
)	O
break	O
;	O
ilen	int
--	O
;	O
}	O
slen	int
-=	O
ilen	int
;	O
if	O
(	O
slen	int
)	O
DoProcess	function
(	O
fore	pointer
,	O
&	O
ibuf	pointer
,	O
&	O
slen	int
,	O
0	int
)	O
;	O
if	O
(	O
--	O
ilen	int
==	O
0	int
)	O
{	O
D_ESCseen	O
=	O
ktab	array
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'E'	O
)	O
;	O
}	O
}	O
if	O
(	O
ilen	int
<=	O
0	int
)	O
return	O
;	O
ktabp	pointer
=	O
D_ESCseen	O
?	O
D_ESCseen	O
:	O
ktab	array
;	O
if	O
(	O
D_ESCseen	O
)	O
{	O
D_ESCseen	O
=	O
0	int
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'E'	O
)	O
;	O
}	O
ch	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
;	O
if	O
(	O
ch	int
==	O
D_user	O
->	O
u_Esc	int
)	O
ch	int
=	O
DefaultEsc	int
;	O
else	O
if	O
(	O
ch	int
==	O
D_user	O
->	O
u_MetaEsc	int
)	O
ch	int
=	O
DefaultMetaEsc	int
;	O
if	O
(	O
ch	int
>=	O
0	int
)	O
DoAction	function
(	O
&	O
ktabp	pointer
[	O
ch	int
]	O
,	O
ch	int
)	O
;	O
ibuf	pointer
=	O
(	O
char	O
*	O
)	O
(	O
s	pointer
+	O
1	int
)	O
;	O
ilen	int
--	O
;	O
}	O
}	O
void	O
DoProcess	function
(	O
p	pointer
,	O
bufp	pointer
,	O
lenp	pointer
,	O
pa	pointer
)	O
struct	O
win	struct
*	O
p	pointer
;	O
char	O
*	O
*	O
bufp	pointer
;	O
int	O
*	O
lenp	pointer
;	O
struct	O
paster	struct
*	O
pa	pointer
;	O
{	O
int	O
oldlen	int
;	O
struct	O
display	struct
*	O
d	int
=	O
display	struct
;	O
if	O
(	O
pa	pointer
&&	O
*	O
lenp	pointer
>	O
1	int
&&	O
p	pointer
&&	O
p	pointer
->	O
w_slowpaste	int
)	O
{	O
SetTimeout	function
(	O
&	O
p	pointer
->	O
w_paster	struct
.	O
pa_slowev	struct
,	O
p	pointer
->	O
w_slowpaste	int
)	O
;	O
evenq	function
(	O
&	O
p	pointer
->	O
w_paster	struct
.	O
pa_slowev	struct
)	O
;	O
return	O
;	O
}	O
while	O
(	O
flayer	pointer
&&	O
*	O
lenp	pointer
)	O
{	O
if	O
(	O
!	O
pa	pointer
&&	O
p	pointer
&&	O
p	pointer
->	O
w_paster	struct
.	O
pa_pastelen	int
&&	O
flayer	pointer
==	O
p	pointer
->	O
w_paster	struct
.	O
pa_pastelayer	pointer
)	O
{	O
debug	O
(	O
"layer is busy - beep!\n"	pointer
)	O
;	O
WBell	function
(	O
p	pointer
,	O
visual_bell	int
)	O
;	O
*	O
bufp	pointer
+=	O
*	O
lenp	pointer
;	O
*	O
lenp	pointer
=	O
0	int
;	O
display	struct
=	O
d	int
;	O
return	O
;	O
}	O
oldlen	int
=	O
*	O
lenp	pointer
;	O
LayProcess	O
(	O
bufp	pointer
,	O
lenp	pointer
)	O
;	O
if	O
(	O
pa	pointer
&&	O
!	O
pa	pointer
->	O
pa_pastelayer	pointer
)	O
break	O
;	O
if	O
(	O
*	O
lenp	pointer
==	O
oldlen	int
)	O
{	O
if	O
(	O
pa	pointer
)	O
{	O
display	struct
=	O
d	int
;	O
return	O
;	O
}	O
debug	O
(	O
"layer is full - beep!\n"	pointer
)	O
;	O
WBell	function
(	O
p	pointer
,	O
visual_bell	int
)	O
;	O
break	O
;	O
}	O
}	O
*	O
bufp	pointer
+=	O
*	O
lenp	pointer
;	O
*	O
lenp	pointer
=	O
0	int
;	O
display	struct
=	O
d	int
;	O
if	O
(	O
pa	pointer
&&	O
pa	pointer
->	O
pa_pastelen	int
==	O
0	int
)	O
FreePaster	function
(	O
pa	pointer
)	O
;	O
}	O
int	O
FindCommnr	function
(	O
str	pointer
)	O
const	O
char	O
*	O
str	pointer
;	O
{	O
int	O
x	int
,	O
m	union
,	O
l	int
=	O
0	int
,	O
r	int
=	O
RC_LAST	int
;	O
while	O
(	O
l	int
<=	O
r	int
)	O
{	O
m	union
=	O
(	O
l	int
+	O
r	int
)	O
/	O
2	int
;	O
x	int
=	O
strcmp	function
(	O
str	pointer
,	O
comms	array
[	O
m	union
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
x	int
>	O
0	int
)	O
l	int
=	O
m	union
+	O
1	int
;	O
else	O
if	O
(	O
x	int
<	O
0	int
)	O
r	int
=	O
m	union
-	O
1	int
;	O
else	O
return	O
m	union
;	O
}	O
return	O
RC_ILLEGAL	O
;	O
}	O
static	O
int	O
CheckArgNum	function
(	O
nr	int
,	O
args	pointer
)	O
int	O
nr	int
;	O
char	O
*	O
*	O
args	pointer
;	O
{	O
int	O
i	int
,	O
n	int
;	O
static	O
char	O
*	O
argss	array
[	O
]	O
=	O
{	O
"no"	pointer
,	O
"one"	pointer
,	O
"two"	pointer
,	O
"three"	pointer
,	O
"four"	pointer
,	O
"OOPS"	pointer
}	O
;	O
static	O
char	O
*	O
orformat	array
[	O
]	O
=	O
{	O
"%s: %s: %s argument%s required"	pointer
,	O
"%s: %s: %s or %s argument%s required"	pointer
,	O
"%s: %s: %s, %s or %s argument%s required"	pointer
,	O
"%s: %s: %s, %s, %s or %s argument%s required"	pointer
}	O
;	O
n	int
=	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_MASK	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
args	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_ORMORE	O
)	O
{	O
if	O
(	O
i	int
<	O
n	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: at least %s argument%s required"	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
,	O
argss	array
[	O
n	int
]	O
,	O
n	int
!=	O
1	int
?	O
"s"	pointer
:	O
""	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS1	O
)	O
&&	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS2	O
)	O
&&	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS3	O
)	O
)	O
{	O
if	O
(	O
i	int
!=	O
n	int
&&	O
i	int
!=	O
n	int
+	O
1	int
&&	O
i	int
!=	O
n	int
+	O
2	int
&&	O
i	int
!=	O
n	int
+	O
3	int
)	O
{	O
Msg	function
(	O
0	int
,	O
orformat	array
[	O
3	int
]	O
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
,	O
argss	array
[	O
n	int
]	O
,	O
argss	array
[	O
n	int
+	O
1	int
]	O
,	O
argss	array
[	O
n	int
+	O
2	int
]	O
,	O
argss	array
[	O
n	int
+	O
3	int
]	O
,	O
""	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS1	O
)	O
&&	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS2	O
)	O
)	O
{	O
if	O
(	O
i	int
!=	O
n	int
&&	O
i	int
!=	O
n	int
+	O
1	int
&&	O
i	int
!=	O
n	int
+	O
2	int
)	O
{	O
Msg	function
(	O
0	int
,	O
orformat	array
[	O
2	int
]	O
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
,	O
argss	array
[	O
n	int
]	O
,	O
argss	array
[	O
n	int
+	O
1	int
]	O
,	O
argss	array
[	O
n	int
+	O
2	int
]	O
,	O
""	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS1	O
)	O
&&	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS3	O
)	O
)	O
{	O
if	O
(	O
i	int
!=	O
n	int
&&	O
i	int
!=	O
n	int
+	O
1	int
&&	O
i	int
!=	O
n	int
+	O
3	int
)	O
{	O
Msg	function
(	O
0	int
,	O
orformat	array
[	O
2	int
]	O
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
,	O
argss	array
[	O
n	int
]	O
,	O
argss	array
[	O
n	int
+	O
1	int
]	O
,	O
argss	array
[	O
n	int
+	O
3	int
]	O
,	O
""	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS2	O
)	O
&&	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS3	O
)	O
)	O
{	O
if	O
(	O
i	int
!=	O
n	int
&&	O
i	int
!=	O
n	int
+	O
2	int
&&	O
i	int
!=	O
n	int
+	O
3	int
)	O
{	O
Msg	function
(	O
0	int
,	O
orformat	array
[	O
2	int
]	O
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
,	O
argss	array
[	O
n	int
]	O
,	O
argss	array
[	O
n	int
+	O
2	int
]	O
,	O
argss	array
[	O
n	int
+	O
3	int
]	O
,	O
""	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS1	O
)	O
{	O
if	O
(	O
i	int
!=	O
n	int
&&	O
i	int
!=	O
n	int
+	O
1	int
)	O
{	O
Msg	function
(	O
0	int
,	O
orformat	array
[	O
1	int
]	O
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
,	O
argss	array
[	O
n	int
]	O
,	O
argss	array
[	O
n	int
+	O
1	int
]	O
,	O
n	int
!=	O
0	int
?	O
"s"	pointer
:	O
""	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS2	O
)	O
{	O
if	O
(	O
i	int
!=	O
n	int
&&	O
i	int
!=	O
n	int
+	O
2	int
)	O
{	O
Msg	function
(	O
0	int
,	O
orformat	array
[	O
1	int
]	O
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
,	O
argss	array
[	O
n	int
]	O
,	O
argss	array
[	O
n	int
+	O
2	int
]	O
,	O
"s"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
&	O
ARGS_PLUS3	O
)	O
{	O
if	O
(	O
i	int
!=	O
n	int
&&	O
i	int
!=	O
n	int
+	O
3	int
)	O
{	O
Msg	function
(	O
0	int
,	O
orformat	array
[	O
1	int
]	O
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
,	O
argss	array
[	O
n	int
]	O
,	O
argss	array
[	O
n	int
+	O
3	int
]	O
,	O
""	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
i	int
!=	O
n	int
)	O
{	O
Msg	function
(	O
0	int
,	O
orformat	array
[	O
0	int
]	O
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
,	O
argss	array
[	O
n	int
]	O
,	O
n	int
!=	O
1	int
?	O
"s"	pointer
:	O
""	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
i	int
;	O
}	O
static	O
void	O
StuffFin	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
if	O
(	O
!	O
flayer	pointer
)	O
return	O
;	O
while	O
(	O
len	int
)	O
LayProcess	O
(	O
&	O
buf	pointer
,	O
&	O
len	int
)	O
;	O
}	O
void	O
DoAction	function
(	O
act	pointer
,	O
key	int
)	O
struct	O
action	struct
*	O
act	pointer
;	O
int	O
key	int
;	O
{	O
int	O
nr	int
=	O
act	pointer
->	O
nr	int
;	O
char	O
*	O
*	O
args	pointer
=	O
act	pointer
->	O
args	pointer
;	O
int	O
*	O
argl	pointer
=	O
act	pointer
->	O
argl	pointer
;	O
struct	O
win	struct
*	O
p	pointer
;	O
int	O
argc	int
,	O
i	int
,	O
n	int
,	O
msgok	int
;	O
char	O
*	O
s	pointer
;	O
char	O
ch	int
;	O
struct	O
display	struct
*	O
odisplay	pointer
=	O
display	struct
;	O
struct	O
acluser	struct
*	O
user	pointer
;	O
user	pointer
=	O
display	struct
?	O
D_user	O
:	O
users	pointer
;	O
if	O
(	O
nr	int
==	O
RC_ILLEGAL	O
)	O
{	O
debug1	O
(	O
"key '%c': No action\n"	pointer
,	O
key	int
)	O
;	O
return	O
;	O
}	O
n	int
=	O
comms	array
[	O
nr	int
]	O
.	O
flags	int
;	O
if	O
(	O
!	O
(	O
n	int
&	O
CAN_QUERY	O
)	O
&&	O
queryflag	int
>=	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s command cannot be queried."	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
n	int
&	O
NEED_DISPLAY	O
)	O
&&	O
display	struct
==	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: %s: display required"	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
n	int
&	O
NEED_FORE	O
)	O
&&	O
fore	pointer
==	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: %s: window required"	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
n	int
&	O
NEED_LAYER	O
)	O
&&	O
flayer	pointer
==	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: %s: display or window required"	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
argc	int
=	O
CheckArgNum	function
(	O
nr	int
,	O
args	pointer
)	O
)	O
<	O
0	int
)	O
return	O
;	O
if	O
(	O
display	struct
)	O
{	O
if	O
(	O
AclCheckPermCmd	function
(	O
D_user	O
,	O
ACL_EXEC	int
,	O
&	O
comms	array
[	O
nr	int
]	O
)	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: %s: permission denied (user %s)"	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
,	O
(	O
EffectiveAclUser	pointer
?	O
EffectiveAclUser	pointer
:	O
D_user	O
)	O
->	O
u_name	array
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
}	O
msgok	int
=	O
display	struct
&&	O
!	O
*	O
rc_name	pointer
;	O
switch	O
(	O
nr	int
)	O
{	O
case	O
RC_SELECT	int
:	O
if	O
(	O
!	O
*	O
args	pointer
)	O
InputSelect	function
(	O
)	O
;	O
else	O
if	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
!	O
args	pointer
[	O
0	int
]	O
[	O
1	int
]	O
)	O
{	O
SetForeWindow	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
)	O
;	O
Activate	function
(	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'.'	O
&&	O
!	O
args	pointer
[	O
0	int
]	O
[	O
1	int
]	O
)	O
{	O
if	O
(	O
!	O
fore	pointer
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"select . needs a window"	pointer
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
SetForeWindow	function
(	O
fore	pointer
)	O
;	O
Activate	function
(	O
0	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
ParseWinNum	function
(	O
act	pointer
,	O
&	O
n	int
)	O
==	O
0	int
)	O
SwitchWindow	function
(	O
n	int
)	O
;	O
else	O
if	O
(	O
queryflag	int
>=	O
0	int
)	O
queryflag	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
RC_DEFAUTONUKE	int
:	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
defautonuke	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Default autonuke turned %s"	pointer
,	O
defautonuke	int
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
if	O
(	O
display	struct
&&	O
*	O
rc_name	pointer
)	O
D_auto_nuke	O
=	O
defautonuke	int
;	O
break	O
;	O
case	O
RC_AUTONUKE	int
:	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
D_auto_nuke	O
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Autonuke turned %s"	pointer
,	O
D_auto_nuke	O
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
break	O
;	O
case	O
RC_DEFOBUFLIMIT	int
:	O
if	O
(	O
ParseNum	function
(	O
act	pointer
,	O
&	O
defobuflimit	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Default limit set to %d"	pointer
,	O
defobuflimit	int
)	O
;	O
if	O
(	O
display	struct
&&	O
*	O
rc_name	pointer
)	O
{	O
D_obufmax	O
=	O
defobuflimit	int
;	O
D_obuflenmax	O
=	O
D_obuflen	O
-	O
D_obufmax	O
;	O
}	O
break	O
;	O
case	O
RC_OBUFLIMIT	int
:	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Limit is %d, current buffer size is %d"	pointer
,	O
D_obufmax	O
,	O
D_obuflen	O
)	O
;	O
else	O
if	O
(	O
ParseNum	function
(	O
act	pointer
,	O
&	O
D_obufmax	O
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Limit set to %d"	pointer
,	O
D_obufmax	O
)	O
;	O
D_obuflenmax	O
=	O
D_obuflen	O
-	O
D_obufmax	O
;	O
break	O
;	O
case	O
RC_DUMPTERMCAP	int
:	O
WriteFile	function
(	O
user	pointer
,	O
(	O
char	O
*	O
)	O
0	int
,	O
DUMP_TERMCAP	int
)	O
;	O
break	O
;	O
case	O
RC_HARDCOPY	int
:	O
{	O
int	O
mode	struct
=	O
DUMP_HARDCOPY	int
;	O
char	O
*	O
file	pointer
=	O
NULL	O
;	O
if	O
(	O
args	pointer
[	O
0	int
]	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-h"	pointer
)	O
)	O
{	O
mode	struct
=	O
DUMP_SCROLLBACK	int
;	O
file	pointer
=	O
args	pointer
[	O
1	int
]	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"--"	pointer
)	O
&&	O
args	pointer
[	O
1	int
]	O
)	O
file	pointer
=	O
args	pointer
[	O
1	int
]	O
;	O
else	O
file	pointer
=	O
args	pointer
[	O
0	int
]	O
;	O
}	O
if	O
(	O
args	pointer
[	O
0	int
]	O
&&	O
file	pointer
==	O
args	pointer
[	O
0	int
]	O
&&	O
args	pointer
[	O
1	int
]	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: hardcopy: too many arguments"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
WriteFile	function
(	O
user	pointer
,	O
file	pointer
,	O
mode	struct
)	O
;	O
}	O
break	O
;	O
case	O
RC_DEFLOG	int
:	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
Lflag	int
)	O
;	O
break	O
;	O
case	O
RC_LOG	int
:	O
n	int
=	O
fore	pointer
->	O
w_log	pointer
?	O
1	int
:	O
0	int
;	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
n	int
)	O
;	O
LogToggle	function
(	O
n	int
)	O
;	O
break	O
;	O
case	O
RC_SUSPEND	int
:	O
Detach	function
(	O
D_STOP	int
)	O
;	O
break	O
;	O
case	O
RC_NEXT	int
:	O
if	O
(	O
MoreWindows	function
(	O
)	O
)	O
SwitchWindow	function
(	O
NextWindow	function
(	O
)	O
)	O
;	O
break	O
;	O
case	O
RC_PREV	int
:	O
if	O
(	O
MoreWindows	function
(	O
)	O
)	O
SwitchWindow	function
(	O
PreviousWindow	function
(	O
)	O
)	O
;	O
break	O
;	O
case	O
RC_KILL	int
:	O
{	O
char	O
*	O
name	pointer
;	O
if	O
(	O
key	int
>=	O
0	int
)	O
{	O
Input	function
(	O
fore	pointer
->	O
w_pwin	pointer
?	O
"Really kill this filter [y/n]"	pointer
:	O
"Really kill this window [y/n]"	pointer
,	O
1	int
,	O
INP_RAW	int
,	O
confirm_fn	function
,	O
NULL	O
,	O
RC_KILL	int
)	O
;	O
break	O
;	O
}	O
n	int
=	O
fore	pointer
->	O
w_number	int
;	O
if	O
(	O
fore	pointer
->	O
w_pwin	pointer
)	O
{	O
FreePseudowin	function
(	O
fore	pointer
)	O
;	O
OutputMsg	O
(	O
0	int
,	O
"Filter removed."	pointer
)	O
;	O
break	O
;	O
}	O
name	pointer
=	O
SaveStr	function
(	O
fore	pointer
->	O
w_title	pointer
)	O
;	O
KillWindow	function
(	O
fore	pointer
)	O
;	O
OutputMsg	O
(	O
0	int
,	O
"Window %d (%s) killed."	pointer
,	O
n	int
,	O
name	pointer
)	O
;	O
if	O
(	O
name	pointer
)	O
free	function
(	O
name	pointer
)	O
;	O
break	O
;	O
}	O
case	O
RC_QUIT	int
:	O
if	O
(	O
key	int
>=	O
0	int
)	O
{	O
Input	function
(	O
"Really quit and kill all your windows [y/n]"	pointer
,	O
1	int
,	O
INP_RAW	int
,	O
confirm_fn	function
,	O
NULL	O
,	O
RC_QUIT	int
)	O
;	O
break	O
;	O
}	O
Finit	function
(	O
0	int
)	O
;	O
case	O
RC_DETACH	int
:	O
if	O
(	O
*	O
args	pointer
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-h"	pointer
)	O
)	O
Hangup	function
(	O
)	O
;	O
else	O
Detach	function
(	O
D_DETACH	int
)	O
;	O
break	O
;	O
case	O
RC_POW_DETACH	int
:	O
if	O
(	O
key	int
>=	O
0	int
)	O
{	O
static	O
char	O
buf	pointer
[	O
2	int
]	O
;	O
buf	pointer
[	O
0	int
]	O
=	O
key	int
;	O
Input	function
(	O
buf	pointer
,	O
1	int
,	O
INP_RAW	int
,	O
pow_detach_fn	function
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
else	O
Detach	function
(	O
D_POWER	int
)	O
;	O
break	O
;	O
case	O
RC_DEBUG	int
:	O
if	O
(	O
*	O
args	pointer
==	O
0	int
||	O
strcmp	function
(	O
"off"	pointer
,	O
*	O
args	pointer
)	O
)	O
OutputMsg	O
(	O
0	int
,	O
"Sorry, screen was compiled without -DDEBUG option."	pointer
)	O
;	O
break	O
;	O
case	O
RC_ZMODEM	int
:	O
if	O
(	O
*	O
args	pointer
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"sendcmd"	pointer
)	O
)	O
{	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
free	function
(	O
zmodem_sendcmd	pointer
)	O
;	O
zmodem_sendcmd	pointer
=	O
SaveStr	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"zmodem sendcmd: %s"	pointer
,	O
zmodem_sendcmd	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
args	pointer
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"recvcmd"	pointer
)	O
)	O
{	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
free	function
(	O
zmodem_recvcmd	pointer
)	O
;	O
zmodem_recvcmd	pointer
=	O
SaveStr	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"zmodem recvcmd: %s"	pointer
,	O
zmodem_recvcmd	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
args	pointer
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
strcmp	function
(	O
zmodes	array
[	O
i	int
]	O
,	O
*	O
args	pointer
)	O
)	O
break	O
;	O
if	O
(	O
i	int
==	O
4	int
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"on"	pointer
)	O
)	O
i	int
=	O
1	int
;	O
if	O
(	O
i	int
==	O
4	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"usage: zmodem off|auto|catch|pass"	pointer
)	O
;	O
break	O
;	O
}	O
zmodem_mode	int
=	O
i	int
;	O
}	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"zmodem mode is %s"	pointer
,	O
zmodes	array
[	O
zmodem_mode	int
]	O
)	O
;	O
break	O
;	O
case	O
RC_UNBINDALL	int
:	O
{	O
register	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
ktab	array
)	O
/	O
sizeof	O
(	O
*	O
ktab	array
)	O
;	O
i	int
++	O
)	O
ClearAction	function
(	O
&	O
ktab	array
[	O
i	int
]	O
)	O
;	O
OutputMsg	O
(	O
0	int
,	O
"Unbound all keys."	pointer
)	O
;	O
break	O
;	O
}	O
case	O
RC_ZOMBIE	int
:	O
{	O
if	O
(	O
!	O
(	O
s	pointer
=	O
*	O
args	pointer
)	O
)	O
{	O
ZombieKey_destroy	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
*	O
argl	pointer
==	O
0	int
||	O
*	O
argl	pointer
>	O
2	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s:zombie: one or two characters expected."	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
1	int
]	O
,	O
"onerror"	pointer
)	O
)	O
{	O
ZombieKey_onerror	int
=	O
1	int
;	O
}	O
else	O
{	O
OutputMsg	O
(	O
0	int
,	O
"usage: zombie [keys [onerror]]"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
else	O
ZombieKey_onerror	int
=	O
0	int
;	O
ZombieKey_destroy	int
=	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
;	O
ZombieKey_resurrect	int
=	O
*	O
argl	pointer
==	O
2	int
?	O
args	pointer
[	O
0	int
]	O
[	O
1	int
]	O
:	O
0	int
;	O
}	O
break	O
;	O
case	O
RC_WALL	int
:	O
s	pointer
=	O
D_user	O
->	O
u_name	array
;	O
{	O
struct	O
display	struct
*	O
olddisplay	pointer
=	O
display	struct
;	O
display	struct
=	O
0	int
;	O
OutputMsg	O
(	O
0	int
,	O
"%s: %s"	pointer
,	O
s	pointer
,	O
*	O
args	pointer
)	O
;	O
display	struct
=	O
olddisplay	pointer
;	O
}	O
break	O
;	O
case	O
RC_AT	int
:	O
if	O
(	O
!	O
user	pointer
)	O
break	O
;	O
s	pointer
=	O
SaveStr	function
(	O
user	pointer
->	O
u_name	array
)	O
;	O
EffectiveAclUser	pointer
=	O
user	pointer
;	O
n	int
=	O
strlen	function
(	O
args	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
n	int
)	O
n	int
--	O
;	O
switch	O
(	O
args	pointer
[	O
0	int
]	O
[	O
n	int
]	O
)	O
{	O
case	O
'*'	O
:	O
{	O
struct	O
display	struct
*	O
nd	pointer
;	O
struct	O
acluser	struct
*	O
u	pointer
;	O
if	O
(	O
!	O
n	int
)	O
u	pointer
=	O
user	pointer
;	O
else	O
{	O
for	O
(	O
u	pointer
=	O
users	pointer
;	O
u	pointer
;	O
u	pointer
=	O
u	pointer
->	O
u_next	pointer
)	O
{	O
debug3	O
(	O
"strncmp('%s', '%s', %d)\n"	pointer
,	O
*	O
args	pointer
,	O
u	pointer
->	O
u_name	array
,	O
n	int
)	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
*	O
args	pointer
,	O
u	pointer
->	O
u_name	array
,	O
n	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
!	O
u	pointer
)	O
{	O
args	pointer
[	O
0	int
]	O
[	O
n	int
]	O
=	O
'\0'	O
;	O
OutputMsg	O
(	O
0	int
,	O
"Did not find any user matching '%s'"	pointer
,	O
args	pointer
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
debug1	O
(	O
"at all displays of user %s\n"	pointer
,	O
u	pointer
->	O
u_name	array
)	O
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
nd	pointer
)	O
{	O
nd	pointer
=	O
display	struct
->	O
d_next	pointer
;	O
if	O
(	O
D_forecv	O
==	O
0	int
)	O
continue	O
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
fore	pointer
=	O
D_fore	O
;	O
if	O
(	O
D_user	O
!=	O
u	pointer
)	O
continue	O
;	O
debug1	O
(	O
"AT display %s\n"	pointer
,	O
D_usertty	O
)	O
;	O
DoCommand	function
(	O
args	pointer
+	O
1	int
,	O
argl	pointer
+	O
1	int
)	O
;	O
if	O
(	O
display	struct
)	O
OutputMsg	O
(	O
0	int
,	O
"command from %s: %s %s"	pointer
,	O
s	pointer
,	O
args	pointer
[	O
1	int
]	O
,	O
args	pointer
[	O
2	int
]	O
?	O
args	pointer
[	O
2	int
]	O
:	O
""	pointer
)	O
;	O
display	struct
=	O
NULL	O
;	O
flayer	pointer
=	O
0	int
;	O
fore	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
}	O
case	O
'%'	O
:	O
{	O
struct	O
display	struct
*	O
nd	pointer
;	O
debug1	O
(	O
"at display matching '%s'\n"	pointer
,	O
args	pointer
[	O
0	int
]	O
)	O
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
nd	pointer
)	O
{	O
nd	pointer
=	O
display	struct
->	O
d_next	pointer
;	O
if	O
(	O
D_forecv	O
==	O
0	int
)	O
continue	O
;	O
fore	pointer
=	O
D_fore	O
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
if	O
(	O
strncmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
D_usertty	O
,	O
n	int
)	O
&&	O
(	O
strncmp	function
(	O
"/dev/"	pointer
,	O
D_usertty	O
,	O
5	int
)	O
||	O
strncmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
D_usertty	O
+	O
5	int
,	O
n	int
)	O
)	O
&&	O
(	O
strncmp	function
(	O
"/dev/tty"	pointer
,	O
D_usertty	O
,	O
8	int
)	O
||	O
strncmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
D_usertty	O
+	O
8	int
,	O
n	int
)	O
)	O
)	O
continue	O
;	O
debug1	O
(	O
"AT display %s\n"	pointer
,	O
D_usertty	O
)	O
;	O
DoCommand	function
(	O
args	pointer
+	O
1	int
,	O
argl	pointer
+	O
1	int
)	O
;	O
if	O
(	O
display	struct
)	O
OutputMsg	O
(	O
0	int
,	O
"command from %s: %s %s"	pointer
,	O
s	pointer
,	O
args	pointer
[	O
1	int
]	O
,	O
args	pointer
[	O
2	int
]	O
?	O
args	pointer
[	O
2	int
]	O
:	O
""	pointer
)	O
;	O
display	struct
=	O
NULL	O
;	O
fore	pointer
=	O
NULL	O
;	O
flayer	pointer
=	O
0	int
;	O
}	O
break	O
;	O
}	O
case	O
'#'	O
:	O
n	int
--	O
;	O
default	O
:	O
{	O
struct	O
win	struct
*	O
nw	pointer
;	O
int	O
ch	int
;	O
n	int
++	O
;	O
ch	int
=	O
args	pointer
[	O
0	int
]	O
[	O
n	int
]	O
;	O
args	pointer
[	O
0	int
]	O
[	O
n	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
*	O
args	pointer
[	O
0	int
]	O
||	O
(	O
i	int
=	O
WindowByNumber	function
(	O
args	pointer
[	O
0	int
]	O
)	O
)	O
<	O
0	int
)	O
{	O
args	pointer
[	O
0	int
]	O
[	O
n	int
]	O
=	O
ch	int
;	O
for	O
(	O
fore	pointer
=	O
windows	pointer
;	O
fore	pointer
;	O
fore	pointer
=	O
nw	pointer
)	O
{	O
nw	pointer
=	O
fore	pointer
->	O
w_next	pointer
;	O
if	O
(	O
strncmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
fore	pointer
->	O
w_title	pointer
,	O
n	int
)	O
)	O
continue	O
;	O
debug2	O
(	O
"AT window %d(%s)\n"	pointer
,	O
fore	pointer
->	O
w_number	int
,	O
fore	pointer
->	O
w_title	pointer
)	O
;	O
i	int
=	O
0	int
;	O
if	O
(	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
)	O
display	struct
=	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
->	O
c_display	pointer
;	O
flayer	pointer
=	O
fore	pointer
->	O
w_savelayer	pointer
?	O
fore	pointer
->	O
w_savelayer	pointer
:	O
&	O
fore	pointer
->	O
w_layer	struct
;	O
DoCommand	function
(	O
args	pointer
+	O
1	int
,	O
argl	pointer
+	O
1	int
)	O
;	O
if	O
(	O
fore	pointer
&&	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
)	O
{	O
display	struct
=	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
->	O
c_display	pointer
;	O
OutputMsg	O
(	O
0	int
,	O
"command from %s: %s %s"	pointer
,	O
s	pointer
,	O
args	pointer
[	O
1	int
]	O
,	O
args	pointer
[	O
2	int
]	O
?	O
args	pointer
[	O
2	int
]	O
:	O
""	pointer
)	O
;	O
}	O
}	O
display	struct
=	O
NULL	O
;	O
fore	pointer
=	O
NULL	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
OutputMsg	O
(	O
0	int
,	O
"%s: at '%s': no such window.\n"	pointer
,	O
rc_name	pointer
,	O
args	pointer
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
i	int
<	O
maxwin	int
&&	O
(	O
fore	pointer
=	O
wtab	pointer
[	O
i	int
]	O
)	O
)	O
{	O
args	pointer
[	O
0	int
]	O
[	O
n	int
]	O
=	O
ch	int
;	O
debug2	O
(	O
"AT window %d (%s)\n"	pointer
,	O
fore	pointer
->	O
w_number	int
,	O
fore	pointer
->	O
w_title	pointer
)	O
;	O
if	O
(	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
)	O
display	struct
=	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
->	O
c_display	pointer
;	O
flayer	pointer
=	O
fore	pointer
->	O
w_savelayer	pointer
?	O
fore	pointer
->	O
w_savelayer	pointer
:	O
&	O
fore	pointer
->	O
w_layer	struct
;	O
DoCommand	function
(	O
args	pointer
+	O
1	int
,	O
argl	pointer
+	O
1	int
)	O
;	O
if	O
(	O
fore	pointer
&&	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
)	O
{	O
display	struct
=	O
fore	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
->	O
c_display	pointer
;	O
OutputMsg	O
(	O
0	int
,	O
"command from %s: %s %s"	pointer
,	O
s	pointer
,	O
args	pointer
[	O
1	int
]	O
,	O
args	pointer
[	O
2	int
]	O
?	O
args	pointer
[	O
2	int
]	O
:	O
""	pointer
)	O
;	O
}	O
display	struct
=	O
NULL	O
;	O
fore	pointer
=	O
NULL	O
;	O
}	O
else	O
OutputMsg	O
(	O
0	int
,	O
"%s: at [identifier][%%|*|#] command [args]"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
}	O
free	function
(	O
s	pointer
)	O
;	O
EffectiveAclUser	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
RC_READREG	int
:	O
i	int
=	O
fore	pointer
?	O
fore	pointer
->	O
w_encoding	O
:	O
display	struct
?	O
display	struct
->	O
d_encoding	int
:	O
0	int
;	O
if	O
(	O
args	pointer
[	O
0	int
]	O
&&	O
args	pointer
[	O
1	int
]	O
&&	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"-e"	pointer
)	O
)	O
{	O
i	int
=	O
FindEncoding	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
i	int
==	O
-	O
1	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: readreg: unknown encoding"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
args	pointer
+=	O
2	int
;	O
}	O
if	O
(	O
(	O
s	pointer
=	O
*	O
args	pointer
)	O
==	O
NULL	O
)	O
{	O
Input	function
(	O
"Copy to register:"	pointer
,	O
1	int
,	O
INP_RAW	int
,	O
copy_reg_fn	function
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
argl	pointer
!=	O
1	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: copyreg: character, ^x, or (octal) \\032 expected."	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
ch	int
=	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
;	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
args	pointer
[	O
2	int
]	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: readreg: too many arguments"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
s	pointer
=	O
ReadFile	function
(	O
args	pointer
[	O
1	int
]	O
,	O
&	O
n	int
)	O
)	O
)	O
{	O
struct	O
plop	struct
*	O
pp	pointer
=	O
plop_tab	array
+	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
ch	int
;	O
if	O
(	O
pp	pointer
->	O
buf	pointer
)	O
free	function
(	O
pp	pointer
->	O
buf	pointer
)	O
;	O
pp	pointer
->	O
buf	pointer
=	O
s	pointer
;	O
pp	pointer
->	O
len	int
=	O
n	int
;	O
pp	pointer
->	O
enc	int
=	O
i	int
;	O
}	O
}	O
else	O
copy_reg_fn	function
(	O
&	O
ch	int
,	O
0	int
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
RC_REGISTER	int
:	O
i	int
=	O
fore	pointer
?	O
fore	pointer
->	O
w_encoding	O
:	O
display	struct
?	O
display	struct
->	O
d_encoding	int
:	O
0	int
;	O
if	O
(	O
args	pointer
[	O
0	int
]	O
&&	O
args	pointer
[	O
1	int
]	O
&&	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"-e"	pointer
)	O
)	O
{	O
i	int
=	O
FindEncoding	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
i	int
==	O
-	O
1	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: register: unknown encoding"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
args	pointer
+=	O
2	int
;	O
argc	int
-=	O
2	int
;	O
}	O
if	O
(	O
argc	int
!=	O
2	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: register: illegal number of arguments."	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
argl	pointer
!=	O
1	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: register: character, ^x, or (octal) \\032 expected."	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
ch	int
=	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
;	O
if	O
(	O
ch	int
==	O
'.'	O
)	O
{	O
if	O
(	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
!=	O
NULL	O
)	O
UserFreeCopyBuffer	function
(	O
user	pointer
)	O
;	O
if	O
(	O
args	pointer
[	O
1	int
]	O
&&	O
args	pointer
[	O
1	int
]	O
[	O
0	int
]	O
)	O
{	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
=	O
SaveStrn	function
(	O
args	pointer
[	O
1	int
]	O
,	O
argl	pointer
[	O
1	int
]	O
)	O
;	O
user	pointer
->	O
u_plop	struct
.	O
len	int
=	O
argl	pointer
[	O
1	int
]	O
;	O
user	pointer
->	O
u_plop	struct
.	O
enc	int
=	O
i	int
;	O
}	O
}	O
else	O
{	O
struct	O
plop	struct
*	O
plp	pointer
=	O
plop_tab	array
+	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
ch	int
;	O
if	O
(	O
plp	pointer
->	O
buf	pointer
)	O
free	function
(	O
plp	pointer
->	O
buf	pointer
)	O
;	O
plp	pointer
->	O
buf	pointer
=	O
SaveStrn	function
(	O
args	pointer
[	O
1	int
]	O
,	O
argl	pointer
[	O
1	int
]	O
)	O
;	O
plp	pointer
->	O
len	int
=	O
argl	pointer
[	O
1	int
]	O
;	O
plp	pointer
->	O
enc	int
=	O
i	int
;	O
}	O
break	O
;	O
case	O
RC_PROCESS	int
:	O
if	O
(	O
(	O
s	pointer
=	O
*	O
args	pointer
)	O
==	O
NULL	O
)	O
{	O
Input	function
(	O
"Process register:"	pointer
,	O
1	int
,	O
INP_RAW	int
,	O
process_fn	function
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
argl	pointer
!=	O
1	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: process: character, ^x, or (octal) \\032 expected."	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
ch	int
=	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
;	O
process_fn	function
(	O
&	O
ch	int
,	O
0	int
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
RC_STUFF	int
:	O
s	pointer
=	O
*	O
args	pointer
;	O
if	O
(	O
!	O
args	pointer
[	O
0	int
]	O
)	O
{	O
Input	function
(	O
"Stuff:"	pointer
,	O
100	int
,	O
INP_COOKED	int
,	O
StuffFin	function
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
}	O
n	int
=	O
*	O
argl	pointer
;	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
s	pointer
,	O
"-k"	pointer
)	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: stuff: invalid option %s"	pointer
,	O
rc_name	pointer
,	O
s	pointer
)	O
;	O
break	O
;	O
}	O
s	pointer
=	O
args	pointer
[	O
1	int
]	O
;	O
for	O
(	O
i	int
=	O
T_CAPS	int
;	O
i	int
<	O
T_OCAPS	int
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
term	struct
[	O
i	int
]	O
.	O
tcname	pointer
,	O
s	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	int
==	O
T_OCAPS	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: stuff: unknown key '%s'"	pointer
,	O
rc_name	pointer
,	O
s	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
StuffKey	function
(	O
i	int
-	O
T_CAPS	int
)	O
==	O
0	int
)	O
break	O
;	O
s	pointer
=	O
display	struct
?	O
D_tcs	O
[	O
i	int
]	O
.	O
str	pointer
:	O
0	int
;	O
if	O
(	O
s	pointer
==	O
0	int
)	O
break	O
;	O
n	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
}	O
while	O
(	O
n	int
)	O
LayProcess	O
(	O
&	O
s	pointer
,	O
&	O
n	int
)	O
;	O
break	O
;	O
case	O
RC_REDISPLAY	int
:	O
Activate	function
(	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
RC_WINDOWS	int
:	O
if	O
(	O
args	pointer
[	O
0	int
]	O
)	O
{	O
ShowWindowsX	function
(	O
args	pointer
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
ShowWindows	function
(	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
RC_VERSION	int
:	O
OutputMsg	O
(	O
0	int
,	O
"screen %s"	pointer
,	O
version	array
)	O
;	O
break	O
;	O
case	O
RC_TIME	int
:	O
if	O
(	O
*	O
args	pointer
)	O
{	O
timestring	pointer
=	O
SaveStr	function
(	O
*	O
args	pointer
)	O
;	O
break	O
;	O
}	O
OutputMsg	O
(	O
0	int
,	O
"%s"	pointer
,	O
MakeWinMsg	function
(	O
timestring	pointer
,	O
fore	pointer
,	O
'%'	O
)	O
)	O
;	O
break	O
;	O
case	O
RC_INFO	int
:	O
ShowInfo	function
(	O
)	O
;	O
break	O
;	O
case	O
RC_DINFO	int
:	O
ShowDInfo	function
(	O
)	O
;	O
break	O
;	O
case	O
RC_COMMAND	int
:	O
{	O
struct	O
action	struct
*	O
ktabp	pointer
=	O
ktab	array
;	O
if	O
(	O
argc	int
==	O
2	int
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-c"	pointer
)	O
)	O
{	O
if	O
(	O
(	O
ktabp	pointer
=	O
FindKtab	function
(	O
args	pointer
[	O
1	int
]	O
,	O
0	int
)	O
)	O
==	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"Unknown command class '%s'"	pointer
,	O
args	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
D_ESCseen	O
!=	O
ktab	array
||	O
ktabp	pointer
!=	O
ktab	array
)	O
{	O
if	O
(	O
D_ESCseen	O
!=	O
ktabp	pointer
)	O
{	O
D_ESCseen	O
=	O
ktabp	pointer
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'E'	O
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
D_ESCseen	O
)	O
{	O
D_ESCseen	O
=	O
0	int
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'E'	O
)	O
;	O
}	O
}	O
case	O
RC_OTHER	int
:	O
if	O
(	O
MoreWindows	function
(	O
)	O
)	O
SwitchWindow	function
(	O
display	struct
&&	O
D_other	O
?	O
D_other	O
->	O
w_number	int
:	O
NextWindow	function
(	O
)	O
)	O
;	O
break	O
;	O
case	O
RC_META	int
:	O
if	O
(	O
user	pointer
->	O
u_Esc	int
==	O
-	O
1	int
)	O
break	O
;	O
ch	int
=	O
user	pointer
->	O
u_Esc	int
;	O
s	pointer
=	O
&	O
ch	int
;	O
n	int
=	O
1	int
;	O
LayProcess	O
(	O
&	O
s	pointer
,	O
&	O
n	int
)	O
;	O
break	O
;	O
case	O
RC_XON	int
:	O
ch	int
=	O
Ctrl	O
(	O
'q'	O
)	O
;	O
s	pointer
=	O
&	O
ch	int
;	O
n	int
=	O
1	int
;	O
LayProcess	O
(	O
&	O
s	pointer
,	O
&	O
n	int
)	O
;	O
break	O
;	O
case	O
RC_XOFF	int
:	O
ch	int
=	O
Ctrl	O
(	O
's'	O
)	O
;	O
s	pointer
=	O
&	O
ch	int
;	O
n	int
=	O
1	int
;	O
LayProcess	O
(	O
&	O
s	pointer
,	O
&	O
n	int
)	O
;	O
break	O
;	O
case	O
RC_DEFBREAKTYPE	int
:	O
case	O
RC_BREAKTYPE	int
:	O
{	O
static	O
char	O
*	O
types	array
[	O
]	O
=	O
{	O
"TIOCSBRK"	pointer
,	O
"TCSBRK"	pointer
,	O
"tcsendbreak"	pointer
,	O
NULL	O
}	O
;	O
extern	O
int	O
breaktype	int
;	O
if	O
(	O
*	O
args	pointer
)	O
{	O
if	O
(	O
ParseNum	function
(	O
act	pointer
,	O
&	O
n	int
)	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
types	array
)	O
/	O
sizeof	O
(	O
*	O
types	array
)	O
)	O
;	O
n	int
++	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
ch	int
=	O
args	pointer
[	O
0	int
]	O
[	O
i	int
]	O
;	O
if	O
(	O
ch	int
>=	O
'a'	O
&&	O
ch	int
<=	O
'z'	O
)	O
ch	int
-=	O
'a'	O
-	O
'A'	O
;	O
if	O
(	O
ch	int
!=	O
types	array
[	O
n	int
]	O
[	O
i	int
]	O
&&	O
(	O
ch	int
+	O
(	O
'a'	O
-	O
'A'	O
)	O
)	O
!=	O
types	array
[	O
n	int
]	O
[	O
i	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
4	int
)	O
break	O
;	O
}	O
if	O
(	O
n	int
<	O
0	int
||	O
n	int
>=	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
types	array
)	O
/	O
sizeof	O
(	O
*	O
types	array
)	O
)	O
)	O
OutputMsg	O
(	O
0	int
,	O
"%s invalid, chose one of %s, %s or %s"	pointer
,	O
*	O
args	pointer
,	O
types	array
[	O
0	int
]	O
,	O
types	array
[	O
1	int
]	O
,	O
types	array
[	O
2	int
]	O
)	O
;	O
else	O
{	O
breaktype	int
=	O
n	int
;	O
OutputMsg	O
(	O
0	int
,	O
"breaktype set to (%d) %s"	pointer
,	O
n	int
,	O
types	array
[	O
n	int
]	O
)	O
;	O
}	O
}	O
else	O
OutputMsg	O
(	O
0	int
,	O
"breaktype is (%d) %s"	pointer
,	O
breaktype	int
,	O
types	array
[	O
breaktype	int
]	O
)	O
;	O
}	O
break	O
;	O
case	O
RC_POW_BREAK	int
:	O
case	O
RC_BREAK	int
:	O
n	int
=	O
0	int
;	O
if	O
(	O
*	O
args	pointer
&&	O
ParseNum	function
(	O
act	pointer
,	O
&	O
n	int
)	O
)	O
break	O
;	O
SendBreak	function
(	O
fore	pointer
,	O
n	int
,	O
nr	int
==	O
RC_POW_BREAK	int
)	O
;	O
break	O
;	O
case	O
RC_LOCKSCREEN	int
:	O
Detach	function
(	O
D_LOCK	int
)	O
;	O
break	O
;	O
case	O
RC_WIDTH	int
:	O
case	O
RC_HEIGHT	int
:	O
{	O
int	O
w	int
,	O
h	int
;	O
int	O
what	int
=	O
0	int
;	O
i	int
=	O
1	int
;	O
if	O
(	O
*	O
args	pointer
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-w"	pointer
)	O
)	O
what	int
=	O
1	int
;	O
else	O
if	O
(	O
*	O
args	pointer
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-d"	pointer
)	O
)	O
what	int
=	O
2	int
;	O
if	O
(	O
what	int
)	O
args	pointer
++	O
;	O
if	O
(	O
what	int
==	O
0	int
&&	O
flayer	pointer
&&	O
!	O
display	struct
)	O
what	int
=	O
1	int
;	O
if	O
(	O
what	int
==	O
1	int
)	O
{	O
if	O
(	O
!	O
flayer	pointer
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: %s: window required"	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
break	O
;	O
}	O
w	int
=	O
flayer	pointer
->	O
l_width	int
;	O
h	int
=	O
flayer	pointer
->	O
l_height	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
display	struct
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: %s: display required"	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
break	O
;	O
}	O
w	int
=	O
D_width	O
;	O
h	int
=	O
D_height	O
;	O
}	O
if	O
(	O
*	O
args	pointer
&&	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: %s: unknown option %s"	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
,	O
*	O
args	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
nr	int
==	O
RC_HEIGHT	int
)	O
{	O
if	O
(	O
!	O
*	O
args	pointer
)	O
{	O
if	O
(	O
h	int
==	O
H0height	int
)	O
h	int
=	O
H1height	int
;	O
else	O
if	O
(	O
h	int
==	O
H1height	int
)	O
h	int
=	O
H0height	int
;	O
else	O
if	O
(	O
h	int
>	O
(	O
H0height	int
+	O
H1height	int
)	O
/	O
2	int
)	O
h	int
=	O
H0height	int
;	O
else	O
h	int
=	O
H1height	int
;	O
}	O
else	O
{	O
h	int
=	O
atoi	function
(	O
*	O
args	pointer
)	O
;	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
w	int
=	O
atoi	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
*	O
args	pointer
)	O
{	O
if	O
(	O
w	int
==	O
Z0width	int
)	O
w	int
=	O
Z1width	int
;	O
else	O
if	O
(	O
w	int
==	O
Z1width	int
)	O
w	int
=	O
Z0width	int
;	O
else	O
if	O
(	O
w	int
>	O
(	O
Z0width	int
+	O
Z1width	int
)	O
/	O
2	int
)	O
w	int
=	O
Z0width	int
;	O
else	O
w	int
=	O
Z1width	int
;	O
}	O
else	O
{	O
w	int
=	O
atoi	function
(	O
*	O
args	pointer
)	O
;	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
h	int
=	O
atoi	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
*	O
args	pointer
&&	O
args	pointer
[	O
1	int
]	O
&&	O
args	pointer
[	O
2	int
]	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: %s: too many arguments"	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
w	int
<=	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"Illegal width"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
h	int
<=	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"Illegal height"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
what	int
==	O
1	int
)	O
{	O
if	O
(	O
flayer	pointer
->	O
l_width	int
==	O
w	int
&&	O
flayer	pointer
->	O
l_height	int
==	O
h	int
)	O
break	O
;	O
ResizeLayer	function
(	O
flayer	pointer
,	O
w	int
,	O
h	int
,	O
(	O
struct	O
display	struct
*	O
)	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
D_width	O
==	O
w	int
&&	O
D_height	O
==	O
h	int
)	O
break	O
;	O
if	O
(	O
what	int
==	O
2	int
)	O
{	O
ChangeScreenSize	function
(	O
w	int
,	O
h	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
ResizeDisplay	function
(	O
w	int
,	O
h	int
)	O
==	O
0	int
)	O
{	O
Activate	function
(	O
D_fore	O
?	O
D_fore	O
->	O
w_norefresh	char
:	O
0	int
)	O
;	O
ResizeLayer	function
(	O
D_forecv	O
->	O
c_layer	pointer
,	O
D_forecv	O
->	O
c_xe	int
-	O
D_forecv	O
->	O
c_xs	int
+	O
1	int
,	O
D_forecv	O
->	O
c_ye	int
-	O
D_forecv	O
->	O
c_ys	int
+	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
h	int
==	O
D_height	O
)	O
OutputMsg	O
(	O
0	int
,	O
"Your termcap does not specify how to change the terminal's width to %d."	pointer
,	O
w	int
)	O
;	O
else	O
if	O
(	O
w	int
==	O
D_width	O
)	O
OutputMsg	O
(	O
0	int
,	O
"Your termcap does not specify how to change the terminal's height to %d."	pointer
,	O
h	int
)	O
;	O
else	O
OutputMsg	O
(	O
0	int
,	O
"Your termcap does not specify how to change the terminal's resolution to %dx%d."	pointer
,	O
w	int
,	O
h	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
RC_DEFDYNAMICTITLE	int
:	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
dynamicaka	int
)	O
;	O
break	O
;	O
case	O
RC_DYNAMICTITLE	int
:	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
fore	pointer
->	O
w_dynamicaka	int
)	O
;	O
break	O
;	O
case	O
RC_TITLE	int
:	O
if	O
(	O
queryflag	int
>=	O
0	int
)	O
{	O
if	O
(	O
fore	pointer
)	O
OutputMsg	O
(	O
0	int
,	O
"%s"	pointer
,	O
fore	pointer
->	O
w_title	pointer
)	O
;	O
else	O
queryflag	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
InputAKA	function
(	O
)	O
;	O
else	O
ChangeAKA	function
(	O
fore	pointer
,	O
*	O
args	pointer
,	O
strlen	function
(	O
*	O
args	pointer
)	O
)	O
;	O
break	O
;	O
case	O
RC_COLON	int
:	O
Input	function
(	O
":"	pointer
,	O
MAXSTR	int
,	O
INP_EVERY	int
,	O
Colonfin	function
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
*	O
args	pointer
&&	O
*	O
*	O
args	pointer
)	O
{	O
s	pointer
=	O
*	O
args	pointer
;	O
n	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
LayProcess	O
(	O
&	O
s	pointer
,	O
&	O
n	int
)	O
;	O
}	O
break	O
;	O
case	O
RC_LASTMSG	int
:	O
if	O
(	O
D_status_lastmsg	O
)	O
OutputMsg	O
(	O
0	int
,	O
"%s"	pointer
,	O
D_status_lastmsg	O
)	O
;	O
break	O
;	O
case	O
RC_SCREEN	int
:	O
DoScreen	function
(	O
"key"	pointer
,	O
args	pointer
)	O
;	O
break	O
;	O
case	O
RC_WRAP	int
:	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
fore	pointer
->	O
w_wrap	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"%cwrap"	pointer
,	O
fore	pointer
->	O
w_wrap	int
?	O
'+'	O
:	O
'-'	O
)	O
;	O
break	O
;	O
case	O
RC_FLOW	int
:	O
if	O
(	O
*	O
args	pointer
)	O
{	O
if	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'a'	O
)	O
{	O
fore	pointer
->	O
w_flow	int
=	O
(	O
fore	pointer
->	O
w_flow	int
&	O
FLOW_AUTO	O
)	O
?	O
FLOW_AUTOFLAG	O
|	O
FLOW_AUTO	O
|	O
FLOW_NOW	O
:	O
FLOW_AUTOFLAG	O
;	O
}	O
else	O
{	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
n	int
)	O
)	O
break	O
;	O
fore	pointer
->	O
w_flow	int
=	O
(	O
fore	pointer
->	O
w_flow	int
&	O
FLOW_AUTO	O
)	O
|	O
n	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
fore	pointer
->	O
w_flow	int
&	O
FLOW_AUTOFLAG	O
)	O
fore	pointer
->	O
w_flow	int
=	O
(	O
fore	pointer
->	O
w_flow	int
&	O
FLOW_AUTO	O
)	O
|	O
FLOW_NOW	O
;	O
else	O
if	O
(	O
fore	pointer
->	O
w_flow	int
&	O
FLOW_NOW	O
)	O
fore	pointer
->	O
w_flow	int
&=	O
~	O
FLOW_NOW	O
;	O
else	O
fore	pointer
->	O
w_flow	int
=	O
fore	pointer
->	O
w_flow	int
?	O
FLOW_AUTOFLAG	O
|	O
FLOW_AUTO	O
|	O
FLOW_NOW	O
:	O
FLOW_AUTOFLAG	O
;	O
}	O
SetFlow	function
(	O
fore	pointer
->	O
w_flow	int
&	O
FLOW_NOW	O
)	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"%cflow%s"	pointer
,	O
(	O
fore	pointer
->	O
w_flow	int
&	O
FLOW_NOW	O
)	O
?	O
'+'	O
:	O
'-'	O
,	O
(	O
fore	pointer
->	O
w_flow	int
&	O
FLOW_AUTOFLAG	O
)	O
?	O
"(auto)"	pointer
:	O
""	pointer
)	O
;	O
break	O
;	O
case	O
RC_DEFWRITELOCK	int
:	O
if	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'a'	O
)	O
nwin_default	struct
.	O
wlock	int
=	O
WLOCK_AUTO	int
;	O
else	O
{	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
n	int
)	O
)	O
break	O
;	O
nwin_default	struct
.	O
wlock	int
=	O
n	int
?	O
WLOCK_ON	int
:	O
WLOCK_OFF	int
;	O
}	O
break	O
;	O
case	O
RC_WRITELOCK	int
:	O
if	O
(	O
*	O
args	pointer
)	O
{	O
if	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'a'	O
)	O
{	O
fore	pointer
->	O
w_wlock	int
=	O
WLOCK_AUTO	int
;	O
}	O
else	O
{	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
n	int
)	O
)	O
break	O
;	O
fore	pointer
->	O
w_wlock	int
=	O
n	int
?	O
WLOCK_ON	int
:	O
WLOCK_OFF	int
;	O
}	O
if	O
(	O
!	O
AclCheckPermWin	function
(	O
D_user	O
,	O
ACL_WRITE	int
,	O
fore	pointer
)	O
)	O
fore	pointer
->	O
w_wlockuser	pointer
=	O
D_user	O
;	O
}	O
OutputMsg	O
(	O
0	int
,	O
"writelock %s"	pointer
,	O
(	O
fore	pointer
->	O
w_wlock	int
==	O
WLOCK_AUTO	int
)	O
?	O
"auto"	pointer
:	O
(	O
(	O
fore	pointer
->	O
w_wlock	int
==	O
WLOCK_OFF	int
)	O
?	O
"off"	pointer
:	O
"on"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
RC_CLEAR	int
:	O
ResetAnsiState	function
(	O
fore	pointer
)	O
;	O
WriteString	function
(	O
fore	pointer
,	O
"\033[H\033[J"	pointer
,	O
6	int
)	O
;	O
break	O
;	O
case	O
RC_RESET	int
:	O
ResetAnsiState	function
(	O
fore	pointer
)	O
;	O
if	O
(	O
fore	pointer
->	O
w_zdisplay	pointer
)	O
zmodem_abort	function
(	O
fore	pointer
,	O
fore	pointer
->	O
w_zdisplay	pointer
)	O
;	O
WriteString	function
(	O
fore	pointer
,	O
"\033c"	pointer
,	O
2	int
)	O
;	O
break	O
;	O
case	O
RC_MONITOR	int
:	O
n	int
=	O
fore	pointer
->	O
w_monitor	int
!=	O
MON_OFF	int
;	O
if	O
(	O
display	struct
)	O
n	int
=	O
n	int
&&	O
(	O
ACLBYTE	O
(	O
fore	pointer
->	O
w_mon_notify	pointer
,	O
D_user	O
->	O
u_id	int
)	O
&	O
ACLBIT	O
(	O
D_user	O
->	O
u_id	int
)	O
)	O
;	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
n	int
)	O
)	O
break	O
;	O
if	O
(	O
n	int
)	O
{	O
if	O
(	O
display	struct
)	O
ACLBYTE	O
(	O
fore	pointer
->	O
w_mon_notify	pointer
,	O
D_user	O
->	O
u_id	int
)	O
|=	O
ACLBIT	O
(	O
D_user	O
->	O
u_id	int
)	O
;	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
maxusercount	int
;	O
i	int
++	O
)	O
ACLBYTE	O
(	O
fore	pointer
->	O
w_mon_notify	pointer
,	O
i	int
)	O
|=	O
ACLBIT	O
(	O
i	int
)	O
;	O
if	O
(	O
fore	pointer
->	O
w_monitor	int
==	O
MON_OFF	int
)	O
fore	pointer
->	O
w_monitor	int
=	O
MON_ON	int
;	O
OutputMsg	O
(	O
0	int
,	O
"Window %d (%s) is now being monitored for all activity."	pointer
,	O
fore	pointer
->	O
w_number	int
,	O
fore	pointer
->	O
w_title	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
display	struct
)	O
ACLBYTE	O
(	O
fore	pointer
->	O
w_mon_notify	pointer
,	O
D_user	O
->	O
u_id	int
)	O
&=	O
~	O
ACLBIT	O
(	O
D_user	O
->	O
u_id	int
)	O
;	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
maxusercount	int
;	O
i	int
++	O
)	O
ACLBYTE	O
(	O
fore	pointer
->	O
w_mon_notify	pointer
,	O
i	int
)	O
&=	O
~	O
ACLBIT	O
(	O
i	int
)	O
;	O
for	O
(	O
i	int
=	O
maxusercount	int
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
ACLBYTE	O
(	O
fore	pointer
->	O
w_mon_notify	pointer
,	O
i	int
)	O
)	O
break	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
fore	pointer
->	O
w_monitor	int
=	O
MON_OFF	int
;	O
OutputMsg	O
(	O
0	int
,	O
"Window %d (%s) is no longer being monitored for activity."	pointer
,	O
fore	pointer
->	O
w_number	int
,	O
fore	pointer
->	O
w_title	pointer
)	O
;	O
}	O
break	O
;	O
case	O
RC_DISPLAYS	int
:	O
display_displays	function
(	O
)	O
;	O
break	O
;	O
case	O
RC_WINDOWLIST	int
:	O
if	O
(	O
!	O
*	O
args	pointer
)	O
display_windows	function
(	O
0	int
,	O
WLIST_NUM	int
,	O
(	O
struct	O
win	struct
*	O
)	O
0	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"string"	pointer
)	O
)	O
{	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
wliststr	pointer
)	O
free	function
(	O
wliststr	pointer
)	O
;	O
wliststr	pointer
=	O
SaveStr	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"windowlist string is '%s'"	pointer
,	O
wliststr	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"title"	pointer
)	O
)	O
{	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
wlisttit	pointer
)	O
free	function
(	O
wlisttit	pointer
)	O
;	O
wlisttit	pointer
=	O
SaveStr	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"windowlist title is '%s'"	pointer
,	O
wlisttit	pointer
)	O
;	O
}	O
else	O
{	O
int	O
flag	int
=	O
0	int
;	O
int	O
blank	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
args	pointer
[	O
i	int
]	O
)	O
continue	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
i	int
]	O
,	O
"-m"	pointer
)	O
)	O
flag	int
|=	O
WLIST_MRU	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
i	int
]	O
,	O
"-b"	pointer
)	O
)	O
blank	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
i	int
]	O
,	O
"-g"	pointer
)	O
)	O
flag	int
|=	O
WLIST_NESTED	int
;	O
else	O
{	O
OutputMsg	O
(	O
0	int
,	O
"usage: windowlist [-b] [-g] [-m] [string [string] | title [title]]"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
argc	int
)	O
display_windows	function
(	O
blank	int
,	O
flag	int
,	O
(	O
struct	O
win	struct
*	O
)	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
RC_HELP	int
:	O
if	O
(	O
argc	int
==	O
2	int
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-c"	pointer
)	O
)	O
{	O
struct	O
action	struct
*	O
ktabp	pointer
;	O
if	O
(	O
(	O
ktabp	pointer
=	O
FindKtab	function
(	O
args	pointer
[	O
1	int
]	O
,	O
0	int
)	O
)	O
==	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"Unknown command class '%s'"	pointer
,	O
args	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
display_help	function
(	O
args	pointer
[	O
1	int
]	O
,	O
ktabp	pointer
)	O
;	O
}	O
else	O
display_help	function
(	O
(	O
char	O
*	O
)	O
0	int
,	O
ktab	array
)	O
;	O
break	O
;	O
case	O
RC_LICENSE	int
:	O
display_copyright	function
(	O
)	O
;	O
break	O
;	O
case	O
RC_COPY	int
:	O
if	O
(	O
flayer	pointer
->	O
l_layfn	pointer
!=	O
&	O
WinLf	struct
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"Must be on a window layer"	pointer
)	O
;	O
break	O
;	O
}	O
MarkRoutine	function
(	O
)	O
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'P'	O
)	O
;	O
break	O
;	O
case	O
RC_HISTORY	int
:	O
{	O
static	O
char	O
*	O
pasteargs	array
[	O
]	O
=	O
{	O
"."	pointer
,	O
0	int
}	O
;	O
static	O
int	O
pasteargl	array
[	O
]	O
=	O
{	O
1	int
}	O
;	O
if	O
(	O
flayer	pointer
->	O
l_layfn	pointer
!=	O
&	O
WinLf	struct
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"Must be on a window layer"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
GetHistory	function
(	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
==	O
NULL	O
)	O
break	O
;	O
args	pointer
=	O
pasteargs	array
;	O
argl	pointer
=	O
pasteargl	array
;	O
}	O
case	O
RC_PASTE	int
:	O
{	O
char	O
*	O
ss	pointer
,	O
*	O
dbuf	pointer
,	O
dch	char
;	O
int	O
l	int
=	O
0	int
;	O
int	O
enc	int
=	O
-	O
1	int
;	O
if	O
(	O
(	O
s	pointer
=	O
*	O
args	pointer
)	O
==	O
NULL	O
)	O
{	O
Input	function
(	O
"Paste from register:"	pointer
,	O
1	int
,	O
INP_RAW	int
,	O
ins_reg_fn	function
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
args	pointer
[	O
1	int
]	O
==	O
0	int
&&	O
!	O
fore	pointer
)	O
break	O
;	O
if	O
(	O
args	pointer
[	O
1	int
]	O
&&	O
argl	pointer
[	O
1	int
]	O
!=	O
1	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: paste destination: character, ^x, or (octal) \\032 expected."	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
fore	pointer
)	O
enc	int
=	O
fore	pointer
->	O
w_encoding	O
;	O
for	O
(	O
ss	pointer
=	O
s	pointer
=	O
*	O
args	pointer
;	O
(	O
ch	int
=	O
*	O
ss	pointer
)	O
;	O
ss	pointer
++	O
)	O
{	O
if	O
(	O
ch	int
==	O
'.'	O
)	O
{	O
if	O
(	O
enc	int
==	O
-	O
1	int
)	O
enc	int
=	O
user	pointer
->	O
u_plop	struct
.	O
enc	int
;	O
if	O
(	O
enc	int
!=	O
user	pointer
->	O
u_plop	struct
.	O
enc	int
)	O
l	int
+=	O
RecodeBuf	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
,	O
user	pointer
->	O
u_plop	struct
.	O
len	int
,	O
user	pointer
->	O
u_plop	struct
.	O
enc	int
,	O
enc	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
0	int
)	O
;	O
else	O
l	int
+=	O
user	pointer
->	O
u_plop	struct
.	O
len	int
;	O
}	O
else	O
{	O
if	O
(	O
enc	int
==	O
-	O
1	int
)	O
enc	int
=	O
plop_tab	array
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
ch	int
]	O
.	O
enc	int
;	O
if	O
(	O
enc	int
!=	O
plop_tab	array
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
ch	int
]	O
.	O
enc	int
)	O
l	int
+=	O
RecodeBuf	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
plop_tab	array
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
ch	int
]	O
.	O
buf	pointer
,	O
plop_tab	array
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
ch	int
]	O
.	O
len	int
,	O
plop_tab	array
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
ch	int
]	O
.	O
enc	int
,	O
enc	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
0	int
)	O
;	O
else	O
l	int
+=	O
plop_tab	array
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
ch	int
]	O
.	O
len	int
;	O
}	O
}	O
if	O
(	O
l	int
==	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"empty buffer"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
s	pointer
[	O
1	int
]	O
==	O
0	int
&&	O
args	pointer
[	O
1	int
]	O
==	O
0	int
)	O
if	O
(	O
enc	int
==	O
(	O
*	O
s	pointer
==	O
'.'	O
?	O
user	pointer
->	O
u_plop	struct
.	O
enc	int
:	O
plop_tab	array
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
]	O
.	O
enc	int
)	O
)	O
{	O
MakePaster	function
(	O
&	O
fore	pointer
->	O
w_paster	struct
,	O
*	O
s	pointer
==	O
'.'	O
?	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
:	O
plop_tab	array
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
]	O
.	O
buf	pointer
,	O
l	int
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
dbuf	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
l	int
)	O
)	O
==	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
break	O
;	O
}	O
l	int
=	O
0	int
;	O
for	O
(	O
ss	pointer
=	O
s	pointer
;	O
(	O
ch	int
=	O
*	O
ss	pointer
)	O
;	O
ss	pointer
++	O
)	O
{	O
struct	O
plop	struct
*	O
pp	pointer
=	O
(	O
ch	int
==	O
'.'	O
?	O
&	O
user	pointer
->	O
u_plop	struct
:	O
&	O
plop_tab	array
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
ch	int
]	O
)	O
;	O
if	O
(	O
pp	pointer
->	O
enc	int
!=	O
enc	int
)	O
{	O
l	int
+=	O
RecodeBuf	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
pp	pointer
->	O
buf	pointer
,	O
pp	pointer
->	O
len	int
,	O
pp	pointer
->	O
enc	int
,	O
enc	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
dbuf	pointer
+	O
l	int
)	O
;	O
continue	O
;	O
}	O
bcopy	function
(	O
pp	pointer
->	O
buf	pointer
,	O
dbuf	pointer
+	O
l	int
,	O
pp	pointer
->	O
len	int
)	O
;	O
l	int
+=	O
pp	pointer
->	O
len	int
;	O
}	O
if	O
(	O
args	pointer
[	O
1	int
]	O
==	O
0	int
)	O
{	O
MakePaster	function
(	O
&	O
fore	pointer
->	O
w_paster	struct
,	O
dbuf	pointer
,	O
l	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
dch	char
=	O
args	pointer
[	O
1	int
]	O
[	O
0	int
]	O
;	O
if	O
(	O
dch	char
==	O
'.'	O
)	O
{	O
if	O
(	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
!=	O
NULL	O
)	O
UserFreeCopyBuffer	function
(	O
user	pointer
)	O
;	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
=	O
dbuf	pointer
;	O
user	pointer
->	O
u_plop	struct
.	O
len	int
=	O
l	int
;	O
user	pointer
->	O
u_plop	struct
.	O
enc	int
=	O
enc	int
;	O
}	O
else	O
{	O
struct	O
plop	struct
*	O
pp	pointer
=	O
plop_tab	array
+	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
dch	char
;	O
if	O
(	O
pp	pointer
->	O
buf	pointer
)	O
free	function
(	O
pp	pointer
->	O
buf	pointer
)	O
;	O
pp	pointer
->	O
buf	pointer
=	O
dbuf	pointer
;	O
pp	pointer
->	O
len	int
=	O
l	int
;	O
pp	pointer
->	O
enc	int
=	O
enc	int
;	O
}	O
}	O
break	O
;	O
}	O
case	O
RC_WRITEBUF	int
:	O
if	O
(	O
!	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"empty buffer"	pointer
)	O
;	O
break	O
;	O
}	O
{	O
struct	O
plop	struct
oldplop	struct
;	O
oldplop	struct
=	O
user	pointer
->	O
u_plop	struct
;	O
if	O
(	O
args	pointer
[	O
0	int
]	O
&&	O
args	pointer
[	O
1	int
]	O
&&	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"-e"	pointer
)	O
)	O
{	O
int	O
enc	int
,	O
l	int
;	O
char	O
*	O
newbuf	pointer
;	O
enc	int
=	O
FindEncoding	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
enc	int
==	O
-	O
1	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: writebuf: unknown encoding"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
enc	int
!=	O
oldplop	struct
.	O
enc	int
)	O
{	O
l	int
=	O
RecodeBuf	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
oldplop	struct
.	O
buf	pointer
,	O
oldplop	struct
.	O
len	int
,	O
oldplop	struct
.	O
enc	int
,	O
enc	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
0	int
)	O
;	O
newbuf	pointer
=	O
malloc	function
(	O
l	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
newbuf	pointer
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
break	O
;	O
}	O
user	pointer
->	O
u_plop	struct
.	O
len	int
=	O
RecodeBuf	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
oldplop	struct
.	O
buf	pointer
,	O
oldplop	struct
.	O
len	int
,	O
oldplop	struct
.	O
enc	int
,	O
enc	int
,	O
(	O
unsigned	O
char	O
*	O
)	O
newbuf	pointer
)	O
;	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
=	O
newbuf	pointer
;	O
user	pointer
->	O
u_plop	struct
.	O
enc	int
=	O
enc	int
;	O
}	O
args	pointer
+=	O
2	int
;	O
}	O
if	O
(	O
args	pointer
[	O
0	int
]	O
&&	O
args	pointer
[	O
1	int
]	O
)	O
OutputMsg	O
(	O
0	int
,	O
"%s: writebuf: too many arguments"	pointer
,	O
rc_name	pointer
)	O
;	O
else	O
WriteFile	function
(	O
user	pointer
,	O
args	pointer
[	O
0	int
]	O
,	O
DUMP_EXCHANGE	int
)	O
;	O
if	O
(	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
!=	O
oldplop	struct
.	O
buf	pointer
)	O
free	function
(	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
)	O
;	O
user	pointer
->	O
u_plop	struct
=	O
oldplop	struct
;	O
}	O
break	O
;	O
case	O
RC_READBUF	int
:	O
i	int
=	O
fore	pointer
?	O
fore	pointer
->	O
w_encoding	O
:	O
display	struct
?	O
display	struct
->	O
d_encoding	int
:	O
0	int
;	O
if	O
(	O
args	pointer
[	O
0	int
]	O
&&	O
args	pointer
[	O
1	int
]	O
&&	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"-e"	pointer
)	O
)	O
{	O
i	int
=	O
FindEncoding	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
i	int
==	O
-	O
1	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: readbuf: unknown encoding"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
args	pointer
+=	O
2	int
;	O
}	O
if	O
(	O
args	pointer
[	O
0	int
]	O
&&	O
args	pointer
[	O
1	int
]	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: readbuf: too many arguments"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
s	pointer
=	O
ReadFile	function
(	O
args	pointer
[	O
0	int
]	O
?	O
args	pointer
[	O
0	int
]	O
:	O
BufferFile	pointer
,	O
&	O
n	int
)	O
)	O
)	O
{	O
if	O
(	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
)	O
UserFreeCopyBuffer	function
(	O
user	pointer
)	O
;	O
user	pointer
->	O
u_plop	struct
.	O
len	int
=	O
n	int
;	O
user	pointer
->	O
u_plop	struct
.	O
buf	pointer
=	O
s	pointer
;	O
user	pointer
->	O
u_plop	struct
.	O
enc	int
=	O
i	int
;	O
}	O
break	O
;	O
case	O
RC_REMOVEBUF	int
:	O
KillBuffers	function
(	O
)	O
;	O
break	O
;	O
case	O
RC_IGNORECASE	int
:	O
(	O
void	O
)	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
search_ic	int
)	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Will %signore case in searches"	pointer
,	O
search_ic	int
?	O
""	pointer
:	O
"not "	pointer
)	O
;	O
break	O
;	O
case	O
RC_ESCAPE	int
:	O
if	O
(	O
*	O
argl	pointer
==	O
0	int
)	O
SetEscape	function
(	O
user	pointer
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
*	O
argl	pointer
==	O
2	int
)	O
SetEscape	function
(	O
user	pointer
,	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
,	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
args	pointer
[	O
0	int
]	O
[	O
1	int
]	O
)	O
;	O
else	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: two characters required after escape."	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
display	struct
&&	O
user	pointer
!=	O
users	pointer
)	O
break	O
;	O
case	O
RC_DEFESCAPE	int
:	O
if	O
(	O
*	O
argl	pointer
==	O
0	int
)	O
SetEscape	function
(	O
NULL	O
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
*	O
argl	pointer
==	O
2	int
)	O
SetEscape	function
(	O
NULL	O
,	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
,	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
args	pointer
[	O
0	int
]	O
[	O
1	int
]	O
)	O
;	O
else	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: two characters required after defescape."	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
CheckEscape	function
(	O
)	O
;	O
break	O
;	O
case	O
RC_CHDIR	int
:	O
s	pointer
=	O
*	O
args	pointer
?	O
*	O
args	pointer
:	O
home	pointer
;	O
if	O
(	O
chdir	function
(	O
s	pointer
)	O
==	O
-	O
1	int
)	O
OutputMsg	O
(	O
errno	O
,	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
break	O
;	O
case	O
RC_SHELL	int
:	O
case	O
RC_DEFSHELL	int
:	O
if	O
(	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
ShellProg	pointer
)	O
==	O
0	int
)	O
ShellArgs	array
[	O
0	int
]	O
=	O
ShellProg	pointer
;	O
break	O
;	O
case	O
RC_HARDCOPYDIR	int
:	O
if	O
(	O
*	O
args	pointer
)	O
(	O
void	O
)	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
hardcopydir	pointer
)	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"hardcopydir is %s\n"	pointer
,	O
hardcopydir	pointer
&&	O
*	O
hardcopydir	pointer
?	O
hardcopydir	pointer
:	O
"<cwd>"	pointer
)	O
;	O
break	O
;	O
case	O
RC_LOGFILE	int
:	O
if	O
(	O
*	O
args	pointer
)	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
if	O
(	O
args	pointer
[	O
1	int
]	O
&&	O
!	O
(	O
strcmp	function
(	O
*	O
args	pointer
,	O
"flush"	pointer
)	O
)	O
)	O
{	O
log_flush	int
=	O
atoi	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"log flush timeout set to %ds\n"	pointer
,	O
log_flush	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
screenlogfile	pointer
)	O
)	O
break	O
;	O
if	O
(	O
fore	pointer
&&	O
fore	pointer
->	O
w_log	pointer
)	O
if	O
(	O
DoStartLog	function
(	O
fore	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
OutputMsg	O
(	O
0	int
,	O
"Error opening logfile \"%s\""	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
msgok	int
)	O
break	O
;	O
}	O
OutputMsg	O
(	O
0	int
,	O
"logfile is '%s'"	pointer
,	O
screenlogfile	pointer
)	O
;	O
break	O
;	O
case	O
RC_LOGTSTAMP	int
:	O
if	O
(	O
!	O
*	O
args	pointer
||	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"on"	pointer
)	O
||	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"off"	pointer
)	O
)	O
{	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
logtstamp_on	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"timestamps turned %s"	pointer
,	O
logtstamp_on	int
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"string"	pointer
)	O
)	O
{	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
logtstamp_string	pointer
)	O
free	function
(	O
logtstamp_string	pointer
)	O
;	O
logtstamp_string	pointer
=	O
SaveStr	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"logfile timestamp is '%s'"	pointer
,	O
logtstamp_string	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"after"	pointer
)	O
)	O
{	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
logtstamp_after	int
=	O
atoi	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
msgok	int
)	O
break	O
;	O
}	O
OutputMsg	O
(	O
0	int
,	O
"timestamp printed after %ds\n"	pointer
,	O
logtstamp_after	int
)	O
;	O
}	O
else	O
OutputMsg	O
(	O
0	int
,	O
"usage: logtstamp [after [n]|string [str]|on|off]"	pointer
)	O
;	O
break	O
;	O
case	O
RC_SHELLTITLE	int
:	O
(	O
void	O
)	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
aka	pointer
)	O
;	O
break	O
;	O
case	O
RC_TERMCAP	int
:	O
case	O
RC_TERMCAPINFO	int
:	O
case	O
RC_TERMINFO	int
:	O
if	O
(	O
!	O
rc_name	pointer
||	O
!	O
*	O
rc_name	pointer
)	O
OutputMsg	O
(	O
0	int
,	O
"Sorry, too late now. Place that in your .screenrc file."	pointer
)	O
;	O
break	O
;	O
case	O
RC_SLEEP	int
:	O
break	O
;	O
case	O
RC_TERM	int
:	O
s	pointer
=	O
NULL	O
;	O
if	O
(	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
s	pointer
)	O
)	O
break	O
;	O
if	O
(	O
strlen	function
(	O
s	pointer
)	O
>	O
MAXTERMLEN	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: term: argument too long ( < %d)"	pointer
,	O
rc_name	pointer
,	O
MAXTERMLEN	int
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
break	O
;	O
}	O
strncpy	function
(	O
screenterm	array
,	O
s	pointer
,	O
MAXTERMLEN	int
)	O
;	O
screenterm	array
[	O
MAXTERMLEN	int
]	O
=	O
'\0'	O
;	O
free	function
(	O
s	pointer
)	O
;	O
debug1	O
(	O
"screenterm set to %s\n"	pointer
,	O
screenterm	array
)	O
;	O
MakeTermcap	function
(	O
(	O
display	struct
==	O
0	int
)	O
)	O
;	O
debug	O
(	O
"new termcap made\n"	pointer
)	O
;	O
break	O
;	O
case	O
RC_ECHO	int
:	O
if	O
(	O
!	O
msgok	int
&&	O
(	O
!	O
rc_name	pointer
||	O
strcmp	function
(	O
rc_name	pointer
,	O
"-X"	pointer
)	O
)	O
)	O
break	O
;	O
if	O
(	O
argc	int
>	O
1	int
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-n"	pointer
)	O
)	O
{	O
args	pointer
++	O
;	O
argc	int
--	O
;	O
}	O
s	pointer
=	O
*	O
args	pointer
;	O
if	O
(	O
argc	int
>	O
1	int
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-p"	pointer
)	O
)	O
{	O
args	pointer
++	O
;	O
argc	int
--	O
;	O
s	pointer
=	O
*	O
args	pointer
;	O
if	O
(	O
s	pointer
)	O
s	pointer
=	O
MakeWinMsg	function
(	O
s	pointer
,	O
fore	pointer
,	O
'%'	O
)	O
;	O
}	O
if	O
(	O
s	pointer
)	O
OutputMsg	O
(	O
0	int
,	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
else	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: 'echo [-n] [-p] \"string\"' expected."	pointer
,	O
rc_name	pointer
)	O
;	O
queryflag	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
RC_BELL	int
:	O
case	O
RC_BELL_MSG	int
:	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
AddXChars	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
BellString	pointer
)	O
;	O
OutputMsg	O
(	O
0	int
,	O
"bell_msg is '%s'"	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
}	O
(	O
void	O
)	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
BellString	pointer
)	O
;	O
break	O
;	O
case	O
RC_BUFFERFILE	int
:	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
BufferFile	pointer
=	O
SaveStr	function
(	O
DEFAULT_BUFFERFILE	pointer
)	O
;	O
else	O
if	O
(	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
BufferFile	pointer
)	O
)	O
break	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Bufferfile is now '%s'"	pointer
,	O
BufferFile	pointer
)	O
;	O
break	O
;	O
case	O
RC_ACTIVITY	int
:	O
(	O
void	O
)	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
ActivityString	pointer
)	O
;	O
break	O
;	O
case	O
RC_POW_DETACH_MSG	int
:	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
AddXChars	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
PowDetachString	pointer
)	O
;	O
OutputMsg	O
(	O
0	int
,	O
"pow_detach_msg is '%s'"	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
}	O
(	O
void	O
)	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
PowDetachString	pointer
)	O
;	O
break	O
;	O
case	O
RC_LOGIN	int
:	O
n	int
=	O
fore	pointer
->	O
w_slot	pointer
!=	O
(	O
slot_t	pointer
)	O
-	O
1	int
;	O
if	O
(	O
*	O
args	pointer
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"always"	pointer
)	O
)	O
{	O
fore	pointer
->	O
w_lflag	int
=	O
3	int
;	O
if	O
(	O
!	O
displays	pointer
&&	O
n	int
)	O
SlotToggle	function
(	O
n	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
args	pointer
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"attached"	pointer
)	O
)	O
{	O
fore	pointer
->	O
w_lflag	int
=	O
1	int
;	O
if	O
(	O
!	O
displays	pointer
&&	O
n	int
)	O
SlotToggle	function
(	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
n	int
)	O
==	O
0	int
)	O
SlotToggle	function
(	O
n	int
)	O
;	O
break	O
;	O
case	O
RC_DEFLOGIN	int
:	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"always"	pointer
)	O
)	O
nwin_default	struct
.	O
lflag	int
|=	O
2	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"attached"	pointer
)	O
)	O
nwin_default	struct
.	O
lflag	int
&=	O
~	O
2	int
;	O
else	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
lflag	int
)	O
;	O
break	O
;	O
case	O
RC_DEFFLOW	int
:	O
if	O
(	O
args	pointer
[	O
0	int
]	O
&&	O
args	pointer
[	O
1	int
]	O
&&	O
args	pointer
[	O
1	int
]	O
[	O
0	int
]	O
==	O
'i'	O
)	O
{	O
iflag	int
=	O
1	int
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
if	O
(	O
!	O
D_flow	O
)	O
continue	O
;	O
D_NewMode	O
.	O
tio	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
=	O
D_OldMode	O
.	O
tio	struct
.	O
c_cc	array
[	O
VINTR	int
]	O
;	O
D_NewMode	O
.	O
tio	struct
.	O
c_lflag	short
|=	O
ISIG	int
;	O
SetTTY	function
(	O
D_userfd	O
,	O
&	O
D_NewMode	O
)	O
;	O
}	O
}	O
if	O
(	O
args	pointer
[	O
0	int
]	O
&&	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'a'	O
)	O
nwin_default	struct
.	O
flowflag	int
=	O
FLOW_AUTOFLAG	O
;	O
else	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
flowflag	int
)	O
;	O
break	O
;	O
case	O
RC_DEFWRAP	int
:	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
wrap	int
)	O
;	O
break	O
;	O
case	O
RC_DEFC1	int
:	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
c1	int
)	O
;	O
break	O
;	O
case	O
RC_DEFBCE	int
:	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
bce	int
)	O
;	O
break	O
;	O
case	O
RC_DEFGR	int
:	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
gr	int
)	O
;	O
break	O
;	O
case	O
RC_DEFMONITOR	int
:	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
n	int
)	O
==	O
0	int
)	O
nwin_default	struct
.	O
monitor	int
=	O
(	O
n	int
==	O
0	int
)	O
?	O
MON_OFF	int
:	O
MON_ON	int
;	O
break	O
;	O
case	O
RC_DEFMOUSETRACK	int
:	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
n	int
)	O
==	O
0	int
)	O
defmousetrack	int
=	O
(	O
n	int
==	O
0	int
)	O
?	O
0	int
:	O
1000	int
;	O
break	O
;	O
case	O
RC_MOUSETRACK	int
:	O
if	O
(	O
!	O
args	pointer
[	O
0	int
]	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"Mouse tracking for this display is turned %s"	pointer
,	O
D_mousetrack	O
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
n	int
)	O
==	O
0	int
)	O
{	O
D_mousetrack	O
=	O
n	int
==	O
0	int
?	O
0	int
:	O
1000	int
;	O
if	O
(	O
D_fore	O
)	O
MouseMode	function
(	O
D_fore	O
->	O
w_mouse	int
)	O
;	O
}	O
break	O
;	O
case	O
RC_DEFSILENCE	int
:	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
n	int
)	O
==	O
0	int
)	O
nwin_default	struct
.	O
silence	int
=	O
(	O
n	int
==	O
0	int
)	O
?	O
SILENCE_OFF	int
:	O
SILENCE_ON	int
;	O
break	O
;	O
case	O
RC_VERBOSE	int
:	O
if	O
(	O
!	O
*	O
args	pointer
)	O
OutputMsg	O
(	O
0	int
,	O
"W%s echo command when creating windows."	pointer
,	O
VerboseCreate	int
?	O
"ill"	pointer
:	O
"on't"	pointer
)	O
;	O
else	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
n	int
)	O
==	O
0	int
)	O
VerboseCreate	int
=	O
n	int
;	O
break	O
;	O
case	O
RC_HARDSTATUS	int
:	O
if	O
(	O
display	struct
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s"	pointer
,	O
""	pointer
)	O
;	O
RemoveStatus	function
(	O
)	O
;	O
}	O
if	O
(	O
args	pointer
[	O
0	int
]	O
&&	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"on"	pointer
)	O
&&	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"off"	pointer
)	O
)	O
{	O
struct	O
display	struct
*	O
olddisplay	pointer
=	O
display	struct
;	O
int	O
old_use	int
,	O
new_use	int
=	O
-	O
1	int
;	O
s	pointer
=	O
args	pointer
[	O
0	int
]	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
"always"	pointer
,	O
6	int
)	O
)	O
s	pointer
+=	O
6	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"firstline"	pointer
)	O
)	O
new_use	int
=	O
HSTATUS_FIRSTLINE	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"lastline"	pointer
)	O
)	O
new_use	int
=	O
HSTATUS_LASTLINE	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"ignore"	pointer
)	O
)	O
new_use	int
=	O
HSTATUS_IGNORE	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
,	O
"message"	pointer
)	O
)	O
new_use	int
=	O
HSTATUS_MESSAGE	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"string"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
AddXChars	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
hstatusstring	pointer
)	O
;	O
OutputMsg	O
(	O
0	int
,	O
"hardstatus string is '%s'"	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: usage: hardstatus [always]lastline|ignore|message|string [string]"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
new_use	int
!=	O
-	O
1	int
)	O
{	O
hardstatusemu	int
=	O
new_use	int
|	O
(	O
s	pointer
==	O
args	pointer
[	O
0	int
]	O
?	O
0	int
:	O
HSTATUS_ALWAYS	O
)	O
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
RemoveStatus	function
(	O
)	O
;	O
new_use	int
=	O
hardstatusemu	int
&	O
~	O
HSTATUS_ALWAYS	O
;	O
if	O
(	O
D_HS	O
&&	O
s	pointer
==	O
args	pointer
[	O
0	int
]	O
)	O
new_use	int
=	O
HSTATUS_HS	int
;	O
ShowHStatus	function
(	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
old_use	int
=	O
D_has_hstatus	O
;	O
D_has_hstatus	O
=	O
new_use	int
;	O
if	O
(	O
(	O
new_use	int
==	O
HSTATUS_LASTLINE	int
&&	O
old_use	int
!=	O
HSTATUS_LASTLINE	int
)	O
||	O
(	O
new_use	int
!=	O
HSTATUS_LASTLINE	int
&&	O
old_use	int
==	O
HSTATUS_LASTLINE	int
)	O
)	O
ChangeScreenSize	function
(	O
D_width	O
,	O
D_height	O
,	O
1	int
)	O
;	O
if	O
(	O
(	O
new_use	int
==	O
HSTATUS_FIRSTLINE	int
&&	O
old_use	int
!=	O
HSTATUS_FIRSTLINE	int
)	O
||	O
(	O
new_use	int
!=	O
HSTATUS_FIRSTLINE	int
&&	O
old_use	int
==	O
HSTATUS_FIRSTLINE	int
)	O
)	O
ChangeScreenSize	function
(	O
D_width	O
,	O
D_height	O
,	O
1	int
)	O
;	O
RefreshHStatus	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
hstatusstring	pointer
)	O
free	function
(	O
hstatusstring	pointer
)	O
;	O
hstatusstring	pointer
=	O
SaveStr	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
RefreshHStatus	function
(	O
)	O
;	O
}	O
display	struct
=	O
olddisplay	pointer
;	O
break	O
;	O
}	O
(	O
void	O
)	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
use_hardstatus	int
)	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"messages displayed on %s"	pointer
,	O
use_hardstatus	int
?	O
"hardstatus line"	pointer
:	O
"window"	pointer
)	O
;	O
break	O
;	O
case	O
RC_CAPTION	int
:	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"always"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"splitonly"	pointer
)	O
==	O
0	int
)	O
{	O
struct	O
display	struct
*	O
olddisplay	pointer
=	O
display	struct
;	O
captionalways	int
=	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'a'	O
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
ChangeScreenSize	function
(	O
D_width	O
,	O
D_height	O
,	O
1	int
)	O
;	O
display	struct
=	O
olddisplay	pointer
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"string"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
AddXChars	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
captionstring	pointer
)	O
;	O
OutputMsg	O
(	O
0	int
,	O
"caption string is '%s'"	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: usage: caption always|splitonly|string <string>"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
break	O
;	O
if	O
(	O
captionstring	pointer
)	O
free	function
(	O
captionstring	pointer
)	O
;	O
captionstring	pointer
=	O
SaveStr	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
RedisplayDisplays	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
RC_CONSOLE	int
:	O
n	int
=	O
(	O
console_window	pointer
!=	O
0	int
)	O
;	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
n	int
)	O
)	O
break	O
;	O
if	O
(	O
TtyGrabConsole	function
(	O
fore	pointer
->	O
w_ptyfd	int
,	O
n	int
,	O
rc_name	pointer
)	O
)	O
break	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
OutputMsg	O
(	O
0	int
,	O
"%s: releasing console %s"	pointer
,	O
rc_name	pointer
,	O
HostName	array
)	O
;	O
else	O
if	O
(	O
console_window	pointer
)	O
OutputMsg	O
(	O
0	int
,	O
"%s: stealing console %s from window %d (%s)"	pointer
,	O
rc_name	pointer
,	O
HostName	array
,	O
console_window	pointer
->	O
w_number	int
,	O
console_window	pointer
->	O
w_title	pointer
)	O
;	O
else	O
OutputMsg	O
(	O
0	int
,	O
"%s: grabbing console %s"	pointer
,	O
rc_name	pointer
,	O
HostName	array
)	O
;	O
console_window	pointer
=	O
n	int
?	O
fore	pointer
:	O
0	int
;	O
break	O
;	O
case	O
RC_ALLPARTIAL	int
:	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
all_norefresh	int
)	O
)	O
break	O
;	O
if	O
(	O
!	O
all_norefresh	int
&&	O
fore	pointer
)	O
Activate	function
(	O
-	O
1	int
)	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
all_norefresh	int
?	O
"No refresh on window change!\n"	pointer
:	O
"Window specific refresh\n"	pointer
)	O
;	O
break	O
;	O
case	O
RC_PARTIAL	int
:	O
(	O
void	O
)	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
n	int
)	O
;	O
fore	pointer
->	O
w_norefresh	char
=	O
n	int
;	O
break	O
;	O
case	O
RC_VBELL	int
:	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
visual_bell	int
)	O
||	O
!	O
msgok	int
)	O
break	O
;	O
if	O
(	O
visual_bell	int
==	O
0	int
)	O
OutputMsg	O
(	O
0	int
,	O
"switched to audible bell."	pointer
)	O
;	O
else	O
OutputMsg	O
(	O
0	int
,	O
"switched to visual bell."	pointer
)	O
;	O
break	O
;	O
case	O
RC_VBELLWAIT	int
:	O
if	O
(	O
ParseNum1000	function
(	O
act	pointer
,	O
&	O
VBellWait	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"vbellwait set to %.10g seconds"	pointer
,	O
VBellWait	int
/	O
1000.	int
)	O
;	O
break	O
;	O
case	O
RC_MSGWAIT	int
:	O
if	O
(	O
ParseNum1000	function
(	O
act	pointer
,	O
&	O
MsgWait	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"msgwait set to %.10g seconds"	pointer
,	O
MsgWait	int
/	O
1000.	int
)	O
;	O
break	O
;	O
case	O
RC_MSGMINWAIT	int
:	O
if	O
(	O
ParseNum1000	function
(	O
act	pointer
,	O
&	O
MsgMinWait	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"msgminwait set to %.10g seconds"	pointer
,	O
MsgMinWait	int
/	O
1000.	int
)	O
;	O
break	O
;	O
case	O
RC_SILENCEWAIT	int
:	O
if	O
(	O
ParseNum	function
(	O
act	pointer
,	O
&	O
SilenceWait	int
)	O
)	O
break	O
;	O
if	O
(	O
SilenceWait	int
<	O
1	int
)	O
SilenceWait	int
=	O
1	int
;	O
for	O
(	O
p	pointer
=	O
windows	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
w_next	pointer
)	O
p	pointer
->	O
w_silencewait	int
=	O
SilenceWait	int
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"silencewait set to %d seconds"	pointer
,	O
SilenceWait	int
)	O
;	O
break	O
;	O
case	O
RC_BUMPRIGHT	int
:	O
if	O
(	O
fore	pointer
->	O
w_number	int
<	O
NextWindow	function
(	O
)	O
)	O
WindowChangeNumber	function
(	O
fore	pointer
->	O
w_number	int
,	O
NextWindow	function
(	O
)	O
)	O
;	O
break	O
;	O
case	O
RC_BUMPLEFT	int
:	O
if	O
(	O
fore	pointer
->	O
w_number	int
>	O
PreviousWindow	function
(	O
)	O
)	O
WindowChangeNumber	function
(	O
fore	pointer
->	O
w_number	int
,	O
PreviousWindow	function
(	O
)	O
)	O
;	O
break	O
;	O
case	O
RC_COLLAPSE	int
:	O
CollapseWindowlist	function
(	O
)	O
;	O
break	O
;	O
case	O
RC_NUMBER	int
:	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
OutputMsg	O
(	O
0	int
,	O
queryflag	int
>=	O
0	int
?	O
"%d (%s)"	pointer
:	O
"This is window %d (%s)."	pointer
,	O
fore	pointer
->	O
w_number	int
,	O
fore	pointer
->	O
w_title	pointer
)	O
;	O
else	O
{	O
int	O
old	int
=	O
fore	pointer
->	O
w_number	int
;	O
int	O
rel	int
=	O
0	int
,	O
parse	int
;	O
if	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'+'	O
)	O
rel	int
=	O
1	int
;	O
else	O
if	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
rel	int
=	O
-	O
1	int
;	O
if	O
(	O
rel	int
)	O
++	O
act	pointer
->	O
args	pointer
[	O
0	int
]	O
;	O
parse	int
=	O
ParseNum	function
(	O
act	pointer
,	O
&	O
n	int
)	O
;	O
if	O
(	O
rel	int
)	O
--	O
act	pointer
->	O
args	pointer
[	O
0	int
]	O
;	O
if	O
(	O
parse	int
)	O
break	O
;	O
if	O
(	O
rel	int
>	O
0	int
)	O
n	int
+=	O
old	int
;	O
else	O
if	O
(	O
rel	int
<	O
0	int
)	O
n	int
=	O
old	int
-	O
n	int
;	O
if	O
(	O
!	O
WindowChangeNumber	function
(	O
old	int
,	O
n	int
)	O
)	O
{	O
queryflag	int
=	O
-	O
1	int
;	O
return	O
;	O
}	O
}	O
break	O
;	O
case	O
RC_ZOMBIE_TIMEOUT	int
:	O
if	O
(	O
argc	int
!=	O
1	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Setting zombie polling needs a timeout arg\n"	pointer
)	O
;	O
break	O
;	O
}	O
nwin_default	struct
.	O
poll_zombie_timeout	int
=	O
atoi	function
(	O
args	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
fore	pointer
)	O
fore	pointer
->	O
w_poll_zombie_timeout	int
=	O
nwin_default	struct
.	O
poll_zombie_timeout	int
;	O
debug1	O
(	O
"Setting zombie polling to %d\n"	pointer
,	O
nwin_default	struct
.	O
poll_zombie_timeout	int
)	O
;	O
break	O
;	O
case	O
RC_SORT	int
:	O
if	O
(	O
fore	pointer
)	O
{	O
Msg	function
(	O
0	int
,	O
"Sorting inside a window is not allowed. Push CTRL-a \" "	pointer
"and try again\n"	pointer
)	O
;	O
break	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
maxwin	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
wtab	pointer
[	O
i	int
]	O
==	O
NULL	O
)	O
continue	O
;	O
n	int
=	O
i	int
;	O
for	O
(	O
nr	int
=	O
i	int
+	O
1	int
;	O
nr	int
<	O
maxwin	int
;	O
nr	int
++	O
)	O
{	O
if	O
(	O
wtab	pointer
[	O
nr	int
]	O
==	O
NULL	O
)	O
continue	O
;	O
debug2	O
(	O
"Testing window %d and %d.\n"	pointer
,	O
nr	int
,	O
n	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
wtab	pointer
[	O
nr	int
]	O
->	O
w_title	pointer
,	O
wtab	pointer
[	O
n	int
]	O
->	O
w_title	pointer
)	O
<	O
0	int
)	O
n	int
=	O
nr	int
;	O
}	O
if	O
(	O
n	int
!=	O
i	int
)	O
{	O
debug2	O
(	O
"Exchange window %d and %d.\n"	pointer
,	O
i	int
,	O
n	int
)	O
;	O
p	pointer
=	O
wtab	pointer
[	O
n	int
]	O
;	O
wtab	pointer
[	O
n	int
]	O
=	O
wtab	pointer
[	O
i	int
]	O
;	O
wtab	pointer
[	O
i	int
]	O
=	O
p	pointer
;	O
wtab	pointer
[	O
n	int
]	O
->	O
w_number	int
=	O
n	int
;	O
wtab	pointer
[	O
i	int
]	O
->	O
w_number	int
=	O
i	int
;	O
AclWinSwap	function
(	O
i	int
,	O
n	int
)	O
;	O
}	O
}	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
RC_SILENCE	int
:	O
n	int
=	O
fore	pointer
->	O
w_silence	int
!=	O
0	int
;	O
i	int
=	O
fore	pointer
->	O
w_silencewait	int
;	O
if	O
(	O
args	pointer
[	O
0	int
]	O
&&	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'-'	O
||	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
>=	O
'0'	O
&&	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
<=	O
'9'	O
)	O
)	O
)	O
{	O
if	O
(	O
ParseNum	function
(	O
act	pointer
,	O
&	O
i	int
)	O
)	O
break	O
;	O
n	int
=	O
i	int
>	O
0	int
;	O
}	O
else	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
n	int
)	O
)	O
break	O
;	O
if	O
(	O
n	int
)	O
{	O
if	O
(	O
display	struct
)	O
ACLBYTE	O
(	O
fore	pointer
->	O
w_lio_notify	pointer
,	O
D_user	O
->	O
u_id	int
)	O
|=	O
ACLBIT	O
(	O
D_user	O
->	O
u_id	int
)	O
;	O
else	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
maxusercount	int
;	O
n	int
++	O
)	O
ACLBYTE	O
(	O
fore	pointer
->	O
w_lio_notify	pointer
,	O
n	int
)	O
|=	O
ACLBIT	O
(	O
n	int
)	O
;	O
fore	pointer
->	O
w_silencewait	int
=	O
i	int
;	O
fore	pointer
->	O
w_silence	int
=	O
SILENCE_ON	int
;	O
SetTimeout	function
(	O
&	O
fore	pointer
->	O
w_silenceev	struct
,	O
fore	pointer
->	O
w_silencewait	int
*	O
1000	int
)	O
;	O
evenq	function
(	O
&	O
fore	pointer
->	O
w_silenceev	struct
)	O
;	O
if	O
(	O
!	O
msgok	int
)	O
break	O
;	O
OutputMsg	O
(	O
0	int
,	O
"The window is now being monitored for %d sec. silence."	pointer
,	O
fore	pointer
->	O
w_silencewait	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
display	struct
)	O
ACLBYTE	O
(	O
fore	pointer
->	O
w_lio_notify	pointer
,	O
D_user	O
->	O
u_id	int
)	O
&=	O
~	O
ACLBIT	O
(	O
D_user	O
->	O
u_id	int
)	O
;	O
else	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
maxusercount	int
;	O
n	int
++	O
)	O
ACLBYTE	O
(	O
fore	pointer
->	O
w_lio_notify	pointer
,	O
n	int
)	O
&=	O
~	O
ACLBIT	O
(	O
n	int
)	O
;	O
for	O
(	O
i	int
=	O
maxusercount	int
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
ACLBYTE	O
(	O
fore	pointer
->	O
w_lio_notify	pointer
,	O
i	int
)	O
)	O
break	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
fore	pointer
->	O
w_silence	int
=	O
SILENCE_OFF	int
;	O
evdeq	function
(	O
&	O
fore	pointer
->	O
w_silenceev	struct
)	O
;	O
}	O
if	O
(	O
!	O
msgok	int
)	O
break	O
;	O
OutputMsg	O
(	O
0	int
,	O
"The window is no longer being monitored for silence."	pointer
)	O
;	O
}	O
break	O
;	O
case	O
RC_DEFSCROLLBACK	int
:	O
(	O
void	O
)	O
ParseNum	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
histheight	int
)	O
;	O
break	O
;	O
case	O
RC_SCROLLBACK	int
:	O
if	O
(	O
flayer	pointer
->	O
l_layfn	pointer
==	O
&	O
MarkLf	struct
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"Cannot resize scrollback buffer in copy/scrollback mode."	pointer
)	O
;	O
break	O
;	O
}	O
(	O
void	O
)	O
ParseNum	function
(	O
act	pointer
,	O
&	O
n	int
)	O
;	O
ChangeWindowSize	function
(	O
fore	pointer
,	O
fore	pointer
->	O
w_width	O
,	O
fore	pointer
->	O
w_height	O
,	O
n	int
)	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"scrollback set to %d"	pointer
,	O
fore	pointer
->	O
w_histheight	int
)	O
;	O
break	O
;	O
case	O
RC_SESSIONNAME	int
:	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
OutputMsg	O
(	O
0	int
,	O
"This session is named '%s'\n"	pointer
,	O
SockName	pointer
)	O
;	O
else	O
{	O
char	O
buf	pointer
[	O
MAXPATHLEN	O
]	O
;	O
s	pointer
=	O
0	int
;	O
if	O
(	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
s	pointer
)	O
)	O
break	O
;	O
if	O
(	O
!	O
*	O
s	pointer
||	O
strlen	function
(	O
s	pointer
)	O
+	O
(	O
SockName	pointer
-	O
SockPath	array
)	O
>	O
MAXPATHLEN	O
-	O
13	int
||	O
index	function
(	O
s	pointer
,	O
'/'	O
)	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: bad session name '%s'\n"	pointer
,	O
rc_name	pointer
,	O
s	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
break	O
;	O
}	O
strncpy	function
(	O
buf	pointer
,	O
SockPath	array
,	O
SockName	pointer
-	O
SockPath	array
)	O
;	O
sprintf	function
(	O
buf	pointer
+	O
(	O
SockName	pointer
-	O
SockPath	array
)	O
,	O
"%d.%s"	pointer
,	O
(	O
int	O
)	O
getpid	function
(	O
)	O
,	O
s	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
if	O
(	O
(	O
access	function
(	O
buf	pointer
,	O
F_OK	int
)	O
==	O
0	int
)	O
||	O
(	O
errno	O
!=	O
ENOENT	int
)	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: inappropriate path: '%s'."	pointer
,	O
rc_name	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
rename	function
(	O
SockPath	array
,	O
buf	pointer
)	O
)	O
{	O
OutputMsg	O
(	O
errno	O
,	O
"%s: failed to rename(%s, %s)"	pointer
,	O
rc_name	pointer
,	O
SockPath	array
,	O
buf	pointer
)	O
;	O
break	O
;	O
}	O
debug2	O
(	O
"rename(%s, %s) done\n"	pointer
,	O
SockPath	array
,	O
buf	pointer
)	O
;	O
strcpy	function
(	O
SockPath	array
,	O
buf	pointer
)	O
;	O
MakeNewEnv	function
(	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'S'	O
)	O
;	O
}	O
break	O
;	O
case	O
RC_SETENV	int
:	O
if	O
(	O
!	O
args	pointer
[	O
0	int
]	O
||	O
!	O
args	pointer
[	O
1	int
]	O
)	O
{	O
debug1	O
(	O
"RC_SETENV arguments missing: %s\n"	pointer
,	O
args	pointer
[	O
0	int
]	O
?	O
args	pointer
[	O
0	int
]	O
:	O
""	pointer
)	O
;	O
InputSetenv	function
(	O
args	pointer
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
xsetenv	function
(	O
args	pointer
[	O
0	int
]	O
,	O
args	pointer
[	O
1	int
]	O
)	O
;	O
MakeNewEnv	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
RC_UNSETENV	int
:	O
unsetenv	function
(	O
*	O
args	pointer
)	O
;	O
MakeNewEnv	function
(	O
)	O
;	O
break	O
;	O
case	O
RC_DEFSLOWPASTE	int
:	O
(	O
void	O
)	O
ParseNum	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
slow	int
)	O
;	O
break	O
;	O
case	O
RC_SLOWPASTE	int
:	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
OutputMsg	O
(	O
0	int
,	O
fore	pointer
->	O
w_slowpaste	int
?	O
"Slowpaste in window %d is %d milliseconds."	pointer
:	O
"Slowpaste in window %d is unset."	pointer
,	O
fore	pointer
->	O
w_number	int
,	O
fore	pointer
->	O
w_slowpaste	int
)	O
;	O
else	O
if	O
(	O
ParseNum	function
(	O
act	pointer
,	O
&	O
fore	pointer
->	O
w_slowpaste	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
fore	pointer
->	O
w_slowpaste	int
?	O
"Slowpaste in window %d set to %d milliseconds."	pointer
:	O
"Slowpaste in window %d now unset."	pointer
,	O
fore	pointer
->	O
w_number	int
,	O
fore	pointer
->	O
w_slowpaste	int
)	O
;	O
break	O
;	O
case	O
RC_MARKKEYS	int
:	O
if	O
(	O
CompileKeys	function
(	O
*	O
args	pointer
,	O
*	O
argl	pointer
,	O
mark_key_tab	array
)	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: markkeys: syntax error."	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
debug1	O
(	O
"markkeys %s\n"	pointer
,	O
*	O
args	pointer
)	O
;	O
break	O
;	O
case	O
RC_PASTEFONT	int
:	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
pastefont	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Will %spaste font settings"	pointer
,	O
pastefont	int
?	O
""	pointer
:	O
"not "	pointer
)	O
;	O
break	O
;	O
case	O
RC_CRLF	int
:	O
(	O
void	O
)	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
join_with_cr	int
)	O
;	O
break	O
;	O
case	O
RC_COMPACTHIST	int
:	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
compacthist	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"%scompacting history lines"	pointer
,	O
compacthist	int
?	O
""	pointer
:	O
"not "	pointer
)	O
;	O
break	O
;	O
case	O
RC_NETHACK	int
:	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
nethackflag	int
)	O
;	O
break	O
;	O
case	O
RC_HARDCOPY_APPEND	int
:	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
hardcopy_append	int
)	O
;	O
break	O
;	O
case	O
RC_VBELL_MSG	int
:	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
AddXChars	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
VisualBellString	pointer
)	O
;	O
OutputMsg	O
(	O
0	int
,	O
"vbell_msg is '%s'"	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
}	O
(	O
void	O
)	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
VisualBellString	pointer
)	O
;	O
debug1	O
(	O
" new vbellstr '%s'\n"	pointer
,	O
VisualBellString	pointer
)	O
;	O
break	O
;	O
case	O
RC_DEFMODE	int
:	O
if	O
(	O
ParseBase	function
(	O
act	pointer
,	O
*	O
args	pointer
,	O
&	O
n	int
,	O
8	int
,	O
"octal"	pointer
)	O
)	O
break	O
;	O
if	O
(	O
n	int
<	O
0	int
||	O
n	int
>	O
0777	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: mode: Invalid tty mode %o"	pointer
,	O
rc_name	pointer
,	O
n	int
)	O
;	O
break	O
;	O
}	O
TtyMode	int
=	O
n	int
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Ttymode set to %03o"	pointer
,	O
TtyMode	int
)	O
;	O
break	O
;	O
case	O
RC_AUTODETACH	int
:	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
auto_detach	int
)	O
;	O
break	O
;	O
case	O
RC_STARTUP_MESSAGE	int
:	O
(	O
void	O
)	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
default_startup	int
)	O
;	O
break	O
;	O
case	O
RC_PASSWORD	int
:	O
if	O
(	O
*	O
args	pointer
)	O
{	O
n	int
=	O
(	O
*	O
user	pointer
->	O
u_password	pointer
)	O
?	O
1	int
:	O
0	int
;	O
if	O
(	O
user	pointer
->	O
u_password	pointer
!=	O
NullStr	array
)	O
free	function
(	O
(	O
char	O
*	O
)	O
user	pointer
->	O
u_password	pointer
)	O
;	O
user	pointer
->	O
u_password	pointer
=	O
SaveStr	function
(	O
*	O
args	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
user	pointer
->	O
u_password	pointer
,	O
"none"	pointer
)	O
)	O
{	O
if	O
(	O
n	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Password checking disabled"	pointer
)	O
;	O
free	function
(	O
user	pointer
->	O
u_password	pointer
)	O
;	O
user	pointer
->	O
u_password	pointer
=	O
NullStr	array
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
fore	pointer
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: password: window required"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
Input	function
(	O
"New screen password:"	pointer
,	O
100	int
,	O
INP_NOECHO	int
,	O
pass1	function
,	O
display	struct
?	O
(	O
char	O
*	O
)	O
D_user	O
:	O
(	O
char	O
*	O
)	O
users	pointer
,	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
RC_BIND	int
:	O
{	O
struct	O
action	struct
*	O
ktabp	pointer
=	O
ktab	array
;	O
int	O
kflag	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
argc	int
>	O
2	int
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-c"	pointer
)	O
)	O
{	O
ktabp	pointer
=	O
FindKtab	function
(	O
args	pointer
[	O
1	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
ktabp	pointer
==	O
0	int
)	O
break	O
;	O
args	pointer
+=	O
2	int
;	O
argl	pointer
+=	O
2	int
;	O
argc	int
-=	O
2	int
;	O
}	O
else	O
if	O
(	O
argc	int
>	O
1	int
&&	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-k"	pointer
)	O
)	O
{	O
kflag	int
=	O
1	int
;	O
args	pointer
++	O
;	O
argl	pointer
++	O
;	O
argc	int
--	O
;	O
}	O
else	O
break	O
;	O
}	O
if	O
(	O
kflag	int
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
KMAP_KEYS	O
;	O
n	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
term	struct
[	O
n	int
+	O
T_CAPS	int
]	O
.	O
tcname	pointer
,	O
*	O
args	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
n	int
==	O
KMAP_KEYS	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: bind: unknown key '%s'"	pointer
,	O
rc_name	pointer
,	O
*	O
args	pointer
)	O
;	O
break	O
;	O
}	O
n	int
+=	O
256	int
;	O
}	O
else	O
if	O
(	O
*	O
argl	pointer
!=	O
1	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: bind: character, ^x, or (octal) \\032 expected."	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
else	O
n	int
=	O
(	O
unsigned	O
char	O
)	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
;	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
(	O
i	int
=	O
FindCommnr	function
(	O
args	pointer
[	O
1	int
]	O
)	O
)	O
==	O
RC_ILLEGAL	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: bind: unknown command '%s'"	pointer
,	O
rc_name	pointer
,	O
args	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
CheckArgNum	function
(	O
i	int
,	O
args	pointer
+	O
2	int
)	O
<	O
0	int
)	O
break	O
;	O
ClearAction	function
(	O
&	O
ktabp	pointer
[	O
n	int
]	O
)	O
;	O
SaveAction	function
(	O
ktabp	pointer
+	O
n	int
,	O
i	int
,	O
args	pointer
+	O
2	int
,	O
argl	pointer
+	O
2	int
)	O
;	O
}	O
else	O
ClearAction	function
(	O
&	O
ktabp	pointer
[	O
n	int
]	O
)	O
;	O
}	O
break	O
;	O
case	O
RC_BINDKEY	int
:	O
{	O
struct	O
action	struct
*	O
newact	pointer
;	O
int	O
newnr	int
,	O
fl	int
=	O
0	int
,	O
kf	int
=	O
0	int
,	O
af	int
=	O
0	int
,	O
df	int
=	O
0	int
,	O
mf	int
=	O
0	int
;	O
struct	O
display	struct
*	O
odisp	pointer
=	O
display	struct
;	O
int	O
used	int
=	O
0	int
;	O
struct	O
kmap_ext	struct
*	O
kme	pointer
=	O
NULL	O
;	O
for	O
(	O
;	O
*	O
args	pointer
&&	O
*	O
*	O
args	pointer
==	O
'-'	O
;	O
args	pointer
++	O
,	O
argl	pointer
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-t"	pointer
)	O
==	O
0	int
)	O
fl	int
=	O
KMAP_NOTIMEOUT	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-k"	pointer
)	O
==	O
0	int
)	O
kf	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-a"	pointer
)	O
==	O
0	int
)	O
af	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-d"	pointer
)	O
==	O
0	int
)	O
df	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-m"	pointer
)	O
==	O
0	int
)	O
mf	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
*	O
args	pointer
,	O
"--"	pointer
)	O
==	O
0	int
)	O
{	O
args	pointer
++	O
;	O
argl	pointer
++	O
;	O
break	O
;	O
}	O
else	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: bindkey: invalid option %s"	pointer
,	O
rc_name	pointer
,	O
*	O
args	pointer
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
df	int
&&	O
mf	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: bindkey: -d does not work with -m"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
{	O
if	O
(	O
mf	int
)	O
display_bindkey	function
(	O
"Edit mode"	pointer
,	O
mmtab	array
)	O
;	O
else	O
if	O
(	O
df	int
)	O
display_bindkey	function
(	O
"Default"	pointer
,	O
dmtab	array
)	O
;	O
else	O
display_bindkey	function
(	O
"User"	pointer
,	O
umtab	array
)	O
;	O
break	O
;	O
}	O
if	O
(	O
kf	int
==	O
0	int
)	O
{	O
if	O
(	O
af	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: bindkey: -a only works with -k"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
argl	pointer
==	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: bindkey: empty string makes no sense"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
,	O
kme	pointer
=	O
kmap_exts	pointer
;	O
i	int
<	O
kmap_extn	int
;	O
i	int
++	O
,	O
kme	pointer
++	O
)	O
if	O
(	O
kme	pointer
->	O
str	pointer
==	O
0	int
)	O
{	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
*	O
argl	pointer
==	O
(	O
kme	pointer
->	O
fl	int
&	O
~	O
KMAP_NOTIMEOUT	int
)	O
&&	O
bcmp	function
(	O
kme	pointer
->	O
str	pointer
,	O
*	O
args	pointer
,	O
*	O
argl	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	int
==	O
kmap_extn	int
)	O
{	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: bindkey: keybinding not found"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
kmap_extn	int
+=	O
8	int
;	O
kmap_exts	pointer
=	O
(	O
struct	O
kmap_ext	struct
*	O
)	O
xrealloc	function
(	O
(	O
char	O
*	O
)	O
kmap_exts	pointer
,	O
kmap_extn	int
*	O
sizeof	O
(	O
*	O
kmap_exts	pointer
)	O
)	O
;	O
kme	pointer
=	O
kmap_exts	pointer
+	O
i	int
;	O
bzero	function
(	O
(	O
char	O
*	O
)	O
kme	pointer
,	O
8	int
*	O
sizeof	O
(	O
*	O
kmap_exts	pointer
)	O
)	O
;	O
for	O
(	O
;	O
i	int
<	O
kmap_extn	int
;	O
i	int
++	O
,	O
kme	pointer
++	O
)	O
{	O
kme	pointer
->	O
str	pointer
=	O
0	int
;	O
kme	pointer
->	O
dm	struct
.	O
nr	int
=	O
kme	pointer
->	O
mm	struct
.	O
nr	int
=	O
kme	pointer
->	O
um	struct
.	O
nr	int
=	O
RC_ILLEGAL	O
;	O
kme	pointer
->	O
dm	struct
.	O
args	pointer
=	O
kme	pointer
->	O
mm	struct
.	O
args	pointer
=	O
kme	pointer
->	O
um	struct
.	O
args	pointer
=	O
noargs	array
;	O
kme	pointer
->	O
dm	struct
.	O
argl	pointer
=	O
kme	pointer
->	O
mm	struct
.	O
argl	pointer
=	O
kme	pointer
->	O
um	struct
.	O
argl	pointer
=	O
0	int
;	O
}	O
i	int
-=	O
8	int
;	O
kme	pointer
-=	O
8	int
;	O
}	O
if	O
(	O
df	int
==	O
0	int
&&	O
kme	pointer
->	O
dm	struct
.	O
nr	int
!=	O
RC_ILLEGAL	O
)	O
used	int
=	O
1	int
;	O
if	O
(	O
mf	int
==	O
0	int
&&	O
kme	pointer
->	O
mm	struct
.	O
nr	int
!=	O
RC_ILLEGAL	O
)	O
used	int
=	O
1	int
;	O
if	O
(	O
(	O
df	int
||	O
mf	int
)	O
&&	O
kme	pointer
->	O
um	struct
.	O
nr	int
!=	O
RC_ILLEGAL	O
)	O
used	int
=	O
1	int
;	O
i	int
+=	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
;	O
newact	pointer
=	O
df	int
?	O
&	O
kme	pointer
->	O
dm	struct
:	O
mf	int
?	O
&	O
kme	pointer
->	O
mm	struct
:	O
&	O
kme	pointer
->	O
um	struct
;	O
}	O
else	O
{	O
for	O
(	O
i	int
=	O
T_CAPS	int
;	O
i	int
<	O
T_OCAPS	int
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
term	struct
[	O
i	int
]	O
.	O
tcname	pointer
,	O
*	O
args	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	int
==	O
T_OCAPS	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: bindkey: unknown key '%s'"	pointer
,	O
rc_name	pointer
,	O
*	O
args	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
af	int
&&	O
i	int
>=	O
T_CURSOR	int
&&	O
i	int
<	O
T_OCAPS	int
)	O
i	int
-=	O
T_CURSOR	int
-	O
KMAP_KEYS	O
;	O
else	O
i	int
-=	O
T_CAPS	int
;	O
newact	pointer
=	O
df	int
?	O
&	O
dmtab	array
[	O
i	int
]	O
:	O
mf	int
?	O
&	O
mmtab	array
[	O
i	int
]	O
:	O
&	O
umtab	array
[	O
i	int
]	O
;	O
}	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
(	O
newnr	int
=	O
FindCommnr	function
(	O
args	pointer
[	O
1	int
]	O
)	O
)	O
==	O
RC_ILLEGAL	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: bindkey: unknown command '%s'"	pointer
,	O
rc_name	pointer
,	O
args	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
CheckArgNum	function
(	O
newnr	int
,	O
args	pointer
+	O
2	int
)	O
<	O
0	int
)	O
break	O
;	O
ClearAction	function
(	O
newact	pointer
)	O
;	O
SaveAction	function
(	O
newact	pointer
,	O
newnr	int
,	O
args	pointer
+	O
2	int
,	O
argl	pointer
+	O
2	int
)	O
;	O
if	O
(	O
kf	int
==	O
0	int
&&	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
kme	pointer
->	O
str	pointer
)	O
free	function
(	O
kme	pointer
->	O
str	pointer
)	O
;	O
kme	pointer
->	O
str	pointer
=	O
SaveStrn	function
(	O
*	O
args	pointer
,	O
*	O
argl	pointer
)	O
;	O
kme	pointer
->	O
fl	int
=	O
fl	int
|	O
*	O
argl	pointer
;	O
}	O
}	O
else	O
ClearAction	function
(	O
newact	pointer
)	O
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
remap	function
(	O
i	int
,	O
args	pointer
[	O
1	int
]	O
?	O
1	int
:	O
0	int
)	O
;	O
if	O
(	O
kf	int
==	O
0	int
&&	O
!	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
!	O
used	int
&&	O
kme	pointer
->	O
str	pointer
)	O
{	O
free	function
(	O
kme	pointer
->	O
str	pointer
)	O
;	O
kme	pointer
->	O
str	pointer
=	O
0	int
;	O
kme	pointer
->	O
fl	int
=	O
0	int
;	O
}	O
}	O
display	struct
=	O
odisp	pointer
;	O
}	O
break	O
;	O
case	O
RC_MAPTIMEOUT	int
:	O
if	O
(	O
*	O
args	pointer
)	O
{	O
if	O
(	O
ParseNum	function
(	O
act	pointer
,	O
&	O
n	int
)	O
)	O
break	O
;	O
if	O
(	O
n	int
<	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: maptimeout: illegal time %d"	pointer
,	O
rc_name	pointer
,	O
n	int
)	O
;	O
break	O
;	O
}	O
maptimeout	int
=	O
n	int
;	O
}	O
if	O
(	O
*	O
args	pointer
==	O
0	int
||	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"maptimeout is %dms"	pointer
,	O
maptimeout	int
)	O
;	O
break	O
;	O
case	O
RC_MAPNOTNEXT	int
:	O
D_dontmap	O
=	O
1	int
;	O
break	O
;	O
case	O
RC_MAPDEFAULT	int
:	O
D_mapdefault	O
=	O
1	int
;	O
break	O
;	O
case	O
RC_ACLCHG	int
:	O
case	O
RC_ACLADD	int
:	O
case	O
RC_ADDACL	int
:	O
case	O
RC_CHACL	int
:	O
UsersAcl	function
(	O
NULL	O
,	O
argc	int
,	O
args	pointer
)	O
;	O
break	O
;	O
case	O
RC_ACLDEL	int
:	O
if	O
(	O
UserDel	function
(	O
args	pointer
[	O
0	int
]	O
,	O
NULL	O
)	O
)	O
break	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"%s removed from acl database"	pointer
,	O
args	pointer
[	O
0	int
]	O
)	O
;	O
break	O
;	O
case	O
RC_ACLGRP	int
:	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
1	int
]	O
,	O
"none"	pointer
)	O
)	O
{	O
if	O
(	O
AclLinkUser	function
(	O
args	pointer
[	O
0	int
]	O
,	O
args	pointer
[	O
1	int
]	O
)	O
)	O
break	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"User %s joined acl-group %s"	pointer
,	O
args	pointer
[	O
0	int
]	O
,	O
args	pointer
[	O
1	int
]	O
)	O
;	O
}	O
else	O
{	O
struct	O
acluser	struct
*	O
u	pointer
;	O
struct	O
aclusergroup	struct
*	O
g	pointer
;	O
if	O
(	O
!	O
(	O
u	pointer
=	O
*	O
FindUserPtr	function
(	O
args	pointer
[	O
0	int
]	O
)	O
)	O
)	O
break	O
;	O
while	O
(	O
(	O
g	pointer
=	O
u	pointer
->	O
u_group	pointer
)	O
)	O
{	O
u	pointer
->	O
u_group	pointer
=	O
g	pointer
->	O
next	pointer
;	O
free	function
(	O
(	O
char	O
*	O
)	O
g	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
,	O
*	O
p	pointer
=	O
buf	pointer
;	O
int	O
ngroups	int
=	O
0	int
;	O
struct	O
acluser	struct
*	O
u	pointer
;	O
struct	O
aclusergroup	struct
*	O
g	pointer
;	O
if	O
(	O
!	O
(	O
u	pointer
=	O
*	O
FindUserPtr	function
(	O
args	pointer
[	O
0	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"User %s does not exist."	pointer
,	O
args	pointer
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
g	pointer
=	O
u	pointer
->	O
u_group	pointer
;	O
while	O
(	O
g	pointer
)	O
{	O
ngroups	int
++	O
;	O
sprintf	function
(	O
p	pointer
,	O
"%s "	pointer
,	O
g	pointer
->	O
u	pointer
->	O
u_name	array
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
>	O
buf	pointer
+	O
200	int
)	O
break	O
;	O
g	pointer
=	O
g	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
ngroups	int
)	O
*	O
(	O
--	O
p	pointer
)	O
=	O
'\0'	O
;	O
OutputMsg	O
(	O
0	int
,	O
"%s's group%s: %s."	pointer
,	O
args	pointer
[	O
0	int
]	O
,	O
(	O
ngroups	int
==	O
1	int
)	O
?	O
""	pointer
:	O
"s"	pointer
,	O
(	O
ngroups	int
==	O
0	int
)	O
?	O
"none"	pointer
:	O
buf	pointer
)	O
;	O
}	O
break	O
;	O
case	O
RC_ACLUMASK	int
:	O
case	O
RC_UMASK	int
:	O
while	O
(	O
(	O
s	pointer
=	O
*	O
args	pointer
++	O
)	O
)	O
{	O
char	O
*	O
err	long
=	O
0	int
;	O
if	O
(	O
AclUmask	function
(	O
display	struct
?	O
D_user	O
:	O
users	pointer
,	O
s	pointer
,	O
&	O
err	long
)	O
)	O
OutputMsg	O
(	O
0	int
,	O
"umask: %s\n"	pointer
,	O
err	long
)	O
;	O
}	O
break	O
;	O
case	O
RC_MULTIUSER	int
:	O
if	O
(	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
n	int
)	O
)	O
break	O
;	O
multi	pointer
=	O
n	int
?	O
""	pointer
:	O
0	int
;	O
chsock	function
(	O
)	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Multiuser mode %s"	pointer
,	O
multi	pointer
?	O
"enabled"	pointer
:	O
"disabled"	pointer
)	O
;	O
break	O
;	O
case	O
RC_EXEC	int
:	O
winexec	function
(	O
args	pointer
)	O
;	O
break	O
;	O
case	O
RC_NONBLOCK	int
:	O
i	int
=	O
D_nonblock	O
>=	O
0	int
;	O
if	O
(	O
*	O
args	pointer
&&	O
(	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
>=	O
'0'	O
&&	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
<=	O
'9'	O
)	O
||	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'.'	O
)	O
)	O
{	O
if	O
(	O
ParseNum1000	function
(	O
act	pointer
,	O
&	O
i	int
)	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
i	int
)	O
)	O
i	int
=	O
i	int
==	O
0	int
?	O
-	O
1	int
:	O
1000	int
;	O
else	O
break	O
;	O
if	O
(	O
msgok	int
&&	O
i	int
==	O
-	O
1	int
)	O
OutputMsg	O
(	O
0	int
,	O
"display set to blocking mode"	pointer
)	O
;	O
else	O
if	O
(	O
msgok	int
&&	O
i	int
==	O
0	int
)	O
OutputMsg	O
(	O
0	int
,	O
"display set to nonblocking mode, no timeout"	pointer
)	O
;	O
else	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"display set to nonblocking mode, %.10gs timeout"	pointer
,	O
i	int
/	O
1000.	int
)	O
;	O
D_nonblock	O
=	O
i	int
;	O
if	O
(	O
D_nonblock	O
<=	O
0	int
)	O
evdeq	function
(	O
&	O
D_blockedev	O
)	O
;	O
break	O
;	O
case	O
RC_DEFNONBLOCK	int
:	O
if	O
(	O
*	O
args	pointer
&&	O
(	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
>=	O
'0'	O
&&	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
<=	O
'9'	O
)	O
||	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'.'	O
)	O
)	O
{	O
if	O
(	O
ParseNum1000	function
(	O
act	pointer
,	O
&	O
defnonblock	int
)	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
ParseOnOff	function
(	O
act	pointer
,	O
&	O
defnonblock	int
)	O
)	O
defnonblock	int
=	O
defnonblock	int
==	O
0	int
?	O
-	O
1	int
:	O
1000	int
;	O
else	O
break	O
;	O
if	O
(	O
display	struct
&&	O
*	O
rc_name	pointer
)	O
{	O
D_nonblock	O
=	O
defnonblock	int
;	O
if	O
(	O
D_nonblock	O
<=	O
0	int
)	O
evdeq	function
(	O
&	O
D_blockedev	O
)	O
;	O
}	O
break	O
;	O
case	O
RC_GR	int
:	O
if	O
(	O
fore	pointer
->	O
w_gr	int
==	O
2	int
)	O
fore	pointer
->	O
w_gr	int
=	O
0	int
;	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
fore	pointer
->	O
w_gr	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Will %suse GR"	pointer
,	O
fore	pointer
->	O
w_gr	int
?	O
""	pointer
:	O
"not "	pointer
)	O
;	O
if	O
(	O
fore	pointer
->	O
w_gr	int
==	O
0	int
&&	O
fore	pointer
->	O
w_FontE	char
)	O
fore	pointer
->	O
w_gr	int
=	O
2	int
;	O
break	O
;	O
case	O
RC_C1	int
:	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
fore	pointer
->	O
w_c1	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Will %suse C1"	pointer
,	O
fore	pointer
->	O
w_c1	int
?	O
""	pointer
:	O
"not "	pointer
)	O
;	O
break	O
;	O
case	O
RC_BCE	int
:	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
fore	pointer
->	O
w_bce	int
)	O
==	O
0	int
&&	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Will %serase with background color"	pointer
,	O
fore	pointer
->	O
w_bce	int
?	O
""	pointer
:	O
"not "	pointer
)	O
;	O
break	O
;	O
case	O
RC_KANJI	int
:	O
case	O
RC_ENCODING	int
:	O
if	O
(	O
*	O
args	pointer
&&	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"-d"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
OutputMsg	O
(	O
0	int
,	O
"encodings directory is %s"	pointer
,	O
screenencodings	pointer
?	O
screenencodings	pointer
:	O
"<unset>"	pointer
)	O
;	O
else	O
{	O
free	function
(	O
screenencodings	pointer
)	O
;	O
screenencodings	pointer
=	O
SaveStr	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
*	O
args	pointer
&&	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"-l"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
OutputMsg	O
(	O
0	int
,	O
"encoding: -l: argument required"	pointer
)	O
;	O
else	O
if	O
(	O
LoadFontTranslation	function
(	O
-	O
1	int
,	O
args	pointer
[	O
1	int
]	O
)	O
)	O
OutputMsg	O
(	O
0	int
,	O
"encoding: could not load utf8 encoding file"	pointer
)	O
;	O
else	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"encoding: utf8 encoding file loaded"	pointer
)	O
;	O
break	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
args	pointer
[	O
i	int
]	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
i	int
]	O
,	O
"."	pointer
)	O
)	O
continue	O
;	O
n	int
=	O
FindEncoding	function
(	O
args	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
n	int
==	O
-	O
1	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"encoding: unknown encoding '%s'"	pointer
,	O
args	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
0	int
&&	O
fore	pointer
)	O
{	O
WinSwitchEncoding	function
(	O
fore	pointer
,	O
n	int
)	O
;	O
ResetCharsets	function
(	O
fore	pointer
)	O
;	O
}	O
else	O
if	O
(	O
i	int
&&	O
display	struct
)	O
D_encoding	O
=	O
n	int
;	O
}	O
break	O
;	O
case	O
RC_DEFKANJI	int
:	O
case	O
RC_DEFENCODING	int
:	O
n	int
=	O
FindEncoding	function
(	O
*	O
args	pointer
)	O
;	O
if	O
(	O
n	int
==	O
-	O
1	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"defencoding: unknown encoding '%s'"	pointer
,	O
*	O
args	pointer
)	O
;	O
break	O
;	O
}	O
nwin_default	struct
.	O
encoding	int
=	O
n	int
;	O
break	O
;	O
case	O
RC_DEFUTF8	int
:	O
n	int
=	O
nwin_default	struct
.	O
encoding	int
==	O
UTF8	int
;	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
n	int
)	O
==	O
0	int
)	O
{	O
nwin_default	struct
.	O
encoding	int
=	O
n	int
?	O
UTF8	int
:	O
0	int
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Will %suse UTF-8 encoding for new windows"	pointer
,	O
n	int
?	O
""	pointer
:	O
"not "	pointer
)	O
;	O
}	O
break	O
;	O
case	O
RC_UTF8	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
&&	O
args	pointer
[	O
i	int
]	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
args	pointer
[	O
i	int
]	O
==	O
0	int
)	O
n	int
=	O
fore	pointer
->	O
w_encoding	O
!=	O
UTF8	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
i	int
]	O
,	O
"off"	pointer
)	O
==	O
0	int
)	O
n	int
=	O
0	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
i	int
]	O
,	O
"on"	pointer
)	O
==	O
0	int
)	O
n	int
=	O
1	int
;	O
else	O
{	O
OutputMsg	O
(	O
0	int
,	O
"utf8: illegal argument (%s)"	pointer
,	O
args	pointer
[	O
i	int
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
WinSwitchEncoding	function
(	O
fore	pointer
,	O
n	int
?	O
UTF8	int
:	O
0	int
)	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Will %suse UTF-8 encoding"	pointer
,	O
n	int
?	O
""	pointer
:	O
"not "	pointer
)	O
;	O
}	O
else	O
if	O
(	O
display	struct
)	O
D_encoding	O
=	O
n	int
?	O
UTF8	int
:	O
0	int
;	O
if	O
(	O
args	pointer
[	O
i	int
]	O
==	O
0	int
)	O
break	O
;	O
}	O
break	O
;	O
case	O
RC_PRINTCMD	int
:	O
if	O
(	O
*	O
args	pointer
)	O
{	O
if	O
(	O
printcmd	pointer
)	O
free	function
(	O
printcmd	pointer
)	O
;	O
printcmd	pointer
=	O
0	int
;	O
if	O
(	O
*	O
*	O
args	pointer
)	O
printcmd	pointer
=	O
SaveStr	function
(	O
*	O
args	pointer
)	O
;	O
}	O
if	O
(	O
*	O
args	pointer
==	O
0	int
||	O
msgok	int
)	O
{	O
if	O
(	O
printcmd	pointer
)	O
OutputMsg	O
(	O
0	int
,	O
"using '%s' as print command"	pointer
,	O
printcmd	pointer
)	O
;	O
else	O
OutputMsg	O
(	O
0	int
,	O
"using termcap entries for printing"	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
RC_DIGRAPH	int
:	O
if	O
(	O
argl	pointer
&&	O
argl	pointer
[	O
0	int
]	O
>	O
0	int
&&	O
args	pointer
[	O
1	int
]	O
&&	O
argl	pointer
[	O
1	int
]	O
>	O
0	int
)	O
{	O
if	O
(	O
argl	pointer
[	O
0	int
]	O
!=	O
2	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"Two characters expected to define a digraph"	pointer
)	O
;	O
break	O
;	O
}	O
i	int
=	O
digraph_find	function
(	O
args	pointer
[	O
0	int
]	O
)	O
;	O
digraphs	array
[	O
i	int
]	O
.	O
d	int
[	O
0	int
]	O
=	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
;	O
digraphs	array
[	O
i	int
]	O
.	O
d	int
[	O
1	int
]	O
=	O
args	pointer
[	O
0	int
]	O
[	O
1	int
]	O
;	O
if	O
(	O
!	O
parse_input_int	function
(	O
args	pointer
[	O
1	int
]	O
,	O
argl	pointer
[	O
1	int
]	O
,	O
&	O
digraphs	array
[	O
i	int
]	O
.	O
value	int
)	O
)	O
{	O
if	O
(	O
!	O
(	O
digraphs	array
[	O
i	int
]	O
.	O
value	int
=	O
atoi	function
(	O
args	pointer
[	O
1	int
]	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
[	O
1	int
]	O
)	O
digraphs	array
[	O
i	int
]	O
.	O
value	int
=	O
(	O
int	O
)	O
args	pointer
[	O
1	int
]	O
[	O
0	int
]	O
;	O
else	O
{	O
int	O
t	int
;	O
unsigned	O
char	O
*	O
s	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
args	pointer
[	O
1	int
]	O
;	O
digraphs	array
[	O
i	int
]	O
.	O
value	int
=	O
0	int
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
t	int
=	O
FromUtf8	function
(	O
*	O
s	pointer
++	O
,	O
&	O
digraphs	array
[	O
i	int
]	O
.	O
value	int
)	O
;	O
if	O
(	O
t	int
==	O
-	O
1	int
)	O
continue	O
;	O
if	O
(	O
t	int
==	O
-	O
2	int
)	O
digraphs	array
[	O
i	int
]	O
.	O
value	int
=	O
0	int
;	O
else	O
digraphs	array
[	O
i	int
]	O
.	O
value	int
=	O
t	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
break	O
;	O
}	O
Input	function
(	O
"Enter digraph: "	pointer
,	O
10	int
,	O
INP_EVERY	int
,	O
digraph_fn	function
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
*	O
args	pointer
&&	O
*	O
*	O
args	pointer
)	O
{	O
s	pointer
=	O
*	O
args	pointer
;	O
n	int
=	O
strlen	function
(	O
s	pointer
)	O
;	O
LayProcess	O
(	O
&	O
s	pointer
,	O
&	O
n	int
)	O
;	O
}	O
break	O
;	O
case	O
RC_DEFHSTATUS	int
:	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
*	O
buf	pointer
=	O
0	int
;	O
if	O
(	O
nwin_default	struct
.	O
hstatus	pointer
)	O
AddXChars	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
nwin_default	struct
.	O
hstatus	pointer
)	O
;	O
OutputMsg	O
(	O
0	int
,	O
"default hstatus is '%s'"	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
}	O
(	O
void	O
)	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
nwin_default	struct
.	O
hstatus	pointer
)	O
;	O
if	O
(	O
*	O
nwin_default	struct
.	O
hstatus	pointer
==	O
0	int
)	O
{	O
free	function
(	O
nwin_default	struct
.	O
hstatus	pointer
)	O
;	O
nwin_default	struct
.	O
hstatus	pointer
=	O
0	int
;	O
}	O
break	O
;	O
case	O
RC_HSTATUS	int
:	O
(	O
void	O
)	O
ParseSaveStr	function
(	O
act	pointer
,	O
&	O
fore	pointer
->	O
w_hstatus	pointer
)	O
;	O
if	O
(	O
*	O
fore	pointer
->	O
w_hstatus	pointer
==	O
0	int
)	O
{	O
free	function
(	O
fore	pointer
->	O
w_hstatus	pointer
)	O
;	O
fore	pointer
->	O
w_hstatus	pointer
=	O
0	int
;	O
}	O
WindowChanged	function
(	O
fore	pointer
,	O
'h'	O
)	O
;	O
break	O
;	O
case	O
RC_DEFCHARSET	int
:	O
case	O
RC_CHARSET	int
:	O
if	O
(	O
*	O
args	pointer
==	O
0	int
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
*	O
buf	pointer
=	O
0	int
;	O
if	O
(	O
nwin_default	struct
.	O
charset	pointer
)	O
AddXChars	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
nwin_default	struct
.	O
charset	pointer
)	O
;	O
OutputMsg	O
(	O
0	int
,	O
"default charset is '%s'"	pointer
,	O
buf	pointer
)	O
;	O
break	O
;	O
}	O
n	int
=	O
strlen	function
(	O
*	O
args	pointer
)	O
;	O
if	O
(	O
n	int
==	O
0	int
||	O
n	int
>	O
6	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: %s: string has illegal size."	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
n	int
>	O
4	int
&&	O
(	O
(	O
(	O
args	pointer
[	O
0	int
]	O
[	O
4	int
]	O
<	O
'0'	O
||	O
args	pointer
[	O
0	int
]	O
[	O
4	int
]	O
>	O
'3'	O
)	O
&&	O
args	pointer
[	O
0	int
]	O
[	O
4	int
]	O
!=	O
'.'	O
)	O
||	O
(	O
(	O
args	pointer
[	O
0	int
]	O
[	O
5	int
]	O
<	O
'0'	O
||	O
args	pointer
[	O
0	int
]	O
[	O
5	int
]	O
>	O
'3'	O
)	O
&&	O
args	pointer
[	O
0	int
]	O
[	O
5	int
]	O
&&	O
args	pointer
[	O
0	int
]	O
[	O
5	int
]	O
!=	O
'.'	O
)	O
)	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: %s: illegal mapping number."	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
nr	int
==	O
RC_CHARSET	int
)	O
{	O
SetCharsets	function
(	O
fore	pointer
,	O
*	O
args	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
nwin_default	struct
.	O
charset	pointer
)	O
free	function
(	O
nwin_default	struct
.	O
charset	pointer
)	O
;	O
nwin_default	struct
.	O
charset	pointer
=	O
SaveStr	function
(	O
*	O
args	pointer
)	O
;	O
break	O
;	O
case	O
RC_ATTRCOLOR	int
:	O
s	pointer
=	O
args	pointer
[	O
0	int
]	O
;	O
if	O
(	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'9'	O
)	O
i	int
=	O
*	O
s	pointer
-	O
'0'	O
;	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
8	int
;	O
i	int
++	O
)	O
if	O
(	O
*	O
s	pointer
==	O
"dubrsBiI"	pointer
[	O
i	int
]	O
)	O
break	O
;	O
s	pointer
++	O
;	O
nr	int
=	O
0	int
;	O
if	O
(	O
*	O
s	pointer
&&	O
s	pointer
[	O
1	int
]	O
&&	O
!	O
s	pointer
[	O
2	int
]	O
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
'd'	O
&&	O
s	pointer
[	O
1	int
]	O
==	O
'd'	O
)	O
nr	int
=	O
3	int
;	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'.'	O
&&	O
s	pointer
[	O
1	int
]	O
==	O
'd'	O
)	O
nr	int
=	O
2	int
;	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'd'	O
&&	O
s	pointer
[	O
1	int
]	O
==	O
'.'	O
)	O
nr	int
=	O
1	int
;	O
else	O
if	O
(	O
*	O
s	pointer
!=	O
'.'	O
||	O
s	pointer
[	O
1	int
]	O
!=	O
'.'	O
)	O
s	pointer
--	O
;	O
s	pointer
+=	O
2	int
;	O
}	O
if	O
(	O
*	O
s	pointer
||	O
i	int
<	O
0	int
||	O
i	int
>=	O
8	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: attrcolor: unknown attribute '%s'."	pointer
,	O
rc_name	pointer
,	O
args	pointer
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
n	int
=	O
0	int
;	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
n	int
=	O
ParseAttrColor	function
(	O
args	pointer
[	O
1	int
]	O
,	O
args	pointer
[	O
2	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
n	int
==	O
-	O
1	int
)	O
break	O
;	O
attr2color	array
[	O
i	int
]	O
[	O
nr	int
]	O
=	O
n	int
;	O
n	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
8	int
;	O
i	int
++	O
)	O
if	O
(	O
attr2color	array
[	O
i	int
]	O
[	O
0	int
]	O
||	O
attr2color	array
[	O
i	int
]	O
[	O
1	int
]	O
||	O
attr2color	array
[	O
i	int
]	O
[	O
2	int
]	O
||	O
attr2color	array
[	O
i	int
]	O
[	O
3	int
]	O
)	O
n	int
|=	O
1	int
<<	O
i	int
;	O
nattr2color	int
=	O
n	int
;	O
break	O
;	O
case	O
RC_RENDITION	int
:	O
i	int
=	O
-	O
1	int
;	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"bell"	pointer
)	O
==	O
0	int
)	O
{	O
i	int
=	O
REND_BELL	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"monitor"	pointer
)	O
==	O
0	int
)	O
{	O
i	int
=	O
REND_MONITOR	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"silence"	pointer
)	O
==	O
0	int
)	O
{	O
i	int
=	O
REND_SILENCE	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"so"	pointer
)	O
!=	O
0	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"Invalid option '%s' for rendition"	pointer
,	O
args	pointer
[	O
0	int
]	O
)	O
;	O
break	O
;	O
}	O
++	O
args	pointer
;	O
++	O
argl	pointer
;	O
if	O
(	O
i	int
!=	O
-	O
1	int
)	O
{	O
renditions	array
[	O
i	int
]	O
=	O
ParseAttrColor	function
(	O
args	pointer
[	O
0	int
]	O
,	O
args	pointer
[	O
1	int
]	O
,	O
1	int
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'w'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'W'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
}	O
case	O
RC_SORENDITION	int
:	O
i	int
=	O
0	int
;	O
if	O
(	O
*	O
args	pointer
)	O
{	O
i	int
=	O
ParseAttrColor	function
(	O
*	O
args	pointer
,	O
args	pointer
[	O
1	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
i	int
==	O
-	O
1	int
)	O
break	O
;	O
ApplyAttrColor	function
(	O
i	int
,	O
&	O
mchar_so	struct
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
0	int
)	O
;	O
debug2	O
(	O
"--> %x %x\n"	pointer
,	O
mchar_so	struct
.	O
attr	char
,	O
mchar_so	struct
.	O
color	char
)	O
;	O
}	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Standout attributes 0x%02x  color 0x%02x"	pointer
,	O
(	O
unsigned	O
char	O
)	O
mchar_so	struct
.	O
attr	char
,	O
0x99	int
^	O
(	O
unsigned	O
char	O
)	O
mchar_so	struct
.	O
color	char
)	O
;	O
break	O
;	O
case	O
RC_SOURCE	int
:	O
do_source	function
(	O
*	O
args	pointer
)	O
;	O
break	O
;	O
case	O
RC_SU	int
:	O
s	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
*	O
args	pointer
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s:%s screen login"	pointer
,	O
HostName	array
,	O
SockPath	array
)	O
;	O
InputSu	function
(	O
D_fore	O
,	O
&	O
D_user	O
,	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
InputSu	function
(	O
D_fore	O
,	O
&	O
D_user	O
,	O
args	pointer
[	O
0	int
]	O
)	O
;	O
else	O
if	O
(	O
!	O
args	pointer
[	O
2	int
]	O
)	O
s	pointer
=	O
DoSu	function
(	O
&	O
D_user	O
,	O
args	pointer
[	O
0	int
]	O
,	O
args	pointer
[	O
1	int
]	O
,	O
"\377"	pointer
)	O
;	O
else	O
s	pointer
=	O
DoSu	function
(	O
&	O
D_user	O
,	O
args	pointer
[	O
0	int
]	O
,	O
args	pointer
[	O
1	int
]	O
,	O
args	pointer
[	O
2	int
]	O
)	O
;	O
if	O
(	O
s	pointer
)	O
OutputMsg	O
(	O
0	int
,	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
break	O
;	O
case	O
RC_SPLIT	int
:	O
s	pointer
=	O
args	pointer
[	O
0	int
]	O
;	O
if	O
(	O
s	pointer
&&	O
!	O
strcmp	function
(	O
s	pointer
,	O
"-v"	pointer
)	O
)	O
AddCanvas	function
(	O
SLICE_HORI	O
)	O
;	O
else	O
AddCanvas	function
(	O
SLICE_VERT	O
)	O
;	O
Activate	function
(	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
RC_REMOVE	int
:	O
RemCanvas	function
(	O
)	O
;	O
Activate	function
(	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
RC_ONLY	int
:	O
OneCanvas	function
(	O
)	O
;	O
Activate	function
(	O
-	O
1	int
)	O
;	O
break	O
;	O
case	O
RC_FIT	int
:	O
D_forecv	O
->	O
c_xoff	int
=	O
D_forecv	O
->	O
c_xs	int
;	O
D_forecv	O
->	O
c_yoff	int
=	O
D_forecv	O
->	O
c_ys	int
;	O
RethinkViewportOffsets	function
(	O
D_forecv	O
)	O
;	O
ResizeLayer	function
(	O
D_forecv	O
->	O
c_layer	pointer
,	O
D_forecv	O
->	O
c_xe	int
-	O
D_forecv	O
->	O
c_xs	int
+	O
1	int
,	O
D_forecv	O
->	O
c_ye	int
-	O
D_forecv	O
->	O
c_ys	int
+	O
1	int
,	O
0	int
)	O
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
LaySetCursor	O
(	O
)	O
;	O
break	O
;	O
case	O
RC_FOCUS	int
:	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
=	O
0	int
;	O
if	O
(	O
!	O
*	O
args	pointer
||	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"next"	pointer
)	O
)	O
cv	pointer
=	O
D_forecv	O
->	O
c_next	pointer
?	O
D_forecv	O
->	O
c_next	pointer
:	O
D_cvlist	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"prev"	pointer
)	O
)	O
{	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
->	O
c_next	pointer
&&	O
cv	pointer
->	O
c_next	pointer
!=	O
D_forecv	O
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"top"	pointer
)	O
)	O
cv	pointer
=	O
D_cvlist	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"bottom"	pointer
)	O
)	O
{	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
->	O
c_next	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"up"	pointer
)	O
)	O
cv	pointer
=	O
FindCanvas	function
(	O
D_forecv	O
->	O
c_xs	int
,	O
D_forecv	O
->	O
c_ys	int
-	O
1	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"down"	pointer
)	O
)	O
cv	pointer
=	O
FindCanvas	function
(	O
D_forecv	O
->	O
c_xs	int
,	O
D_forecv	O
->	O
c_ye	int
+	O
2	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"left"	pointer
)	O
)	O
cv	pointer
=	O
FindCanvas	function
(	O
D_forecv	O
->	O
c_xs	int
-	O
1	int
,	O
D_forecv	O
->	O
c_ys	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"right"	pointer
)	O
)	O
cv	pointer
=	O
FindCanvas	function
(	O
D_forecv	O
->	O
c_xe	int
+	O
1	int
,	O
D_forecv	O
->	O
c_ys	int
)	O
;	O
else	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: usage: focus [next|prev|up|down|left|right|top|bottom]"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
SetForeCanvas	function
(	O
display	struct
,	O
cv	pointer
)	O
;	O
}	O
break	O
;	O
case	O
RC_RESIZE	int
:	O
i	int
=	O
0	int
;	O
if	O
(	O
D_forecv	O
->	O
c_slorient	int
==	O
SLICE_UNKN	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"resize: need more than one region"	pointer
)	O
;	O
break	O
;	O
}	O
for	O
(	O
;	O
*	O
args	pointer
;	O
args	pointer
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-h"	pointer
)	O
)	O
i	int
|=	O
RESIZE_FLAG_H	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-v"	pointer
)	O
)	O
i	int
|=	O
RESIZE_FLAG_V	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-b"	pointer
)	O
)	O
i	int
|=	O
RESIZE_FLAG_H	int
|	O
RESIZE_FLAG_V	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-p"	pointer
)	O
)	O
i	int
|=	O
D_forecv	O
->	O
c_slorient	int
==	O
SLICE_VERT	O
?	O
RESIZE_FLAG_H	int
:	O
RESIZE_FLAG_V	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"-l"	pointer
)	O
)	O
i	int
|=	O
RESIZE_FLAG_L	int
;	O
else	O
break	O
;	O
}	O
if	O
(	O
*	O
args	pointer
&&	O
args	pointer
[	O
1	int
]	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: usage: resize [-h] [-v] [-l] [num]\n"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
args	pointer
)	O
ResizeRegions	function
(	O
*	O
args	pointer
,	O
i	int
)	O
;	O
else	O
Input	function
(	O
resizeprompts	array
[	O
i	int
]	O
,	O
20	int
,	O
INP_EVERY	int
,	O
ResizeFin	function
,	O
(	O
char	O
*	O
)	O
0	int
,	O
i	int
)	O
;	O
break	O
;	O
case	O
RC_SETSID	int
:	O
(	O
void	O
)	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
separate_sids	int
)	O
;	O
break	O
;	O
case	O
RC_EVAL	int
:	O
args	pointer
=	O
SaveArgs	function
(	O
args	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
args	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
args	pointer
[	O
i	int
]	O
[	O
0	int
]	O
)	O
Colonfin	function
(	O
args	pointer
[	O
i	int
]	O
,	O
strlen	function
(	O
args	pointer
[	O
i	int
]	O
)	O
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
free	function
(	O
args	pointer
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
args	pointer
)	O
;	O
break	O
;	O
case	O
RC_ALTSCREEN	int
:	O
(	O
void	O
)	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
use_altscreen	int
)	O
;	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Will %sdo alternate screen switching"	pointer
,	O
use_altscreen	int
?	O
""	pointer
:	O
"not "	pointer
)	O
;	O
break	O
;	O
case	O
RC_MAXWIN	int
:	O
if	O
(	O
!	O
args	pointer
[	O
0	int
]	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"maximum windows allowed: %d"	pointer
,	O
maxwin	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ParseNum	function
(	O
act	pointer
,	O
&	O
n	int
)	O
)	O
break	O
;	O
if	O
(	O
n	int
<	O
1	int
)	O
OutputMsg	O
(	O
0	int
,	O
"illegal maxwin number specified"	pointer
)	O
;	O
else	O
if	O
(	O
n	int
>	O
2048	int
)	O
OutputMsg	O
(	O
0	int
,	O
"maximum 2048 windows allowed"	pointer
)	O
;	O
else	O
if	O
(	O
n	int
>	O
maxwin	int
&&	O
windows	pointer
)	O
OutputMsg	O
(	O
0	int
,	O
"may increase maxwin only when there's no window"	pointer
)	O
;	O
else	O
{	O
if	O
(	O
!	O
windows	pointer
)	O
{	O
wtab	pointer
=	O
realloc	function
(	O
wtab	pointer
,	O
n	int
*	O
sizeof	O
(	O
struct	O
win	struct
*	O
)	O
)	O
;	O
bzero	function
(	O
wtab	pointer
,	O
n	int
*	O
sizeof	O
(	O
struct	O
win	struct
*	O
)	O
)	O
;	O
}	O
maxwin	int
=	O
n	int
;	O
}	O
break	O
;	O
case	O
RC_BACKTICK	int
:	O
if	O
(	O
ParseBase	function
(	O
act	pointer
,	O
*	O
args	pointer
,	O
&	O
n	int
,	O
10	int
,	O
"decimal"	pointer
)	O
)	O
break	O
;	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
setbacktick	function
(	O
n	int
,	O
0	int
,	O
0	int
,	O
(	O
char	O
*	O
*	O
)	O
0	int
)	O
;	O
else	O
{	O
int	O
lifespan	int
,	O
tick	long
;	O
if	O
(	O
argc	int
<	O
4	int
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: usage: backtick num [lifespan tick cmd args...]"	pointer
,	O
rc_name	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
ParseBase	function
(	O
act	pointer
,	O
args	pointer
[	O
1	int
]	O
,	O
&	O
lifespan	int
,	O
10	int
,	O
"decimal"	pointer
)	O
)	O
break	O
;	O
if	O
(	O
ParseBase	function
(	O
act	pointer
,	O
args	pointer
[	O
2	int
]	O
,	O
&	O
tick	long
,	O
10	int
,	O
"decimal"	pointer
)	O
)	O
break	O
;	O
setbacktick	function
(	O
n	int
,	O
lifespan	int
,	O
tick	long
,	O
SaveArgs	function
(	O
args	pointer
+	O
3	int
)	O
)	O
;	O
}	O
WindowChanged	function
(	O
0	int
,	O
'`'	O
)	O
;	O
break	O
;	O
case	O
RC_BLANKER	int
:	O
if	O
(	O
blankerprg	pointer
)	O
{	O
RunBlanker	function
(	O
blankerprg	pointer
)	O
;	O
break	O
;	O
}	O
ClearAll	function
(	O
)	O
;	O
CursorVisibility	function
(	O
-	O
1	int
)	O
;	O
D_blocked	O
=	O
4	int
;	O
break	O
;	O
case	O
RC_BLANKERPRG	int
:	O
if	O
(	O
!	O
args	pointer
[	O
0	int
]	O
)	O
{	O
if	O
(	O
blankerprg	pointer
)	O
{	O
char	O
path	array
[	O
MAXPATHLEN	O
]	O
;	O
char	O
*	O
p	pointer
=	O
path	array
,	O
*	O
*	O
pp	pointer
;	O
for	O
(	O
pp	pointer
=	O
blankerprg	pointer
;	O
*	O
pp	pointer
;	O
pp	pointer
++	O
)	O
p	pointer
+=	O
snprintf	function
(	O
p	pointer
,	O
sizeof	O
(	O
path	array
)	O
-	O
(	O
p	pointer
-	O
path	array
)	O
-	O
1	int
,	O
"%s "	pointer
,	O
*	O
pp	pointer
)	O
;	O
*	O
(	O
p	pointer
-	O
1	int
)	O
=	O
'\0'	O
;	O
OutputMsg	O
(	O
0	int
,	O
"blankerprg: %s"	pointer
,	O
path	array
)	O
;	O
}	O
else	O
OutputMsg	O
(	O
0	int
,	O
"No blankerprg set."	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
blankerprg	pointer
)	O
{	O
char	O
*	O
*	O
pp	pointer
;	O
for	O
(	O
pp	pointer
=	O
blankerprg	pointer
;	O
*	O
pp	pointer
;	O
pp	pointer
++	O
)	O
free	function
(	O
*	O
pp	pointer
)	O
;	O
free	function
(	O
blankerprg	pointer
)	O
;	O
blankerprg	pointer
=	O
0	int
;	O
}	O
if	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
blankerprg	pointer
=	O
SaveArgs	function
(	O
args	pointer
)	O
;	O
break	O
;	O
case	O
RC_IDLE	int
:	O
if	O
(	O
*	O
args	pointer
)	O
{	O
struct	O
display	struct
*	O
olddisplay	pointer
=	O
display	struct
;	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
args	pointer
,	O
"off"	pointer
)	O
)	O
idletimo	int
=	O
0	int
;	O
else	O
if	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
idletimo	int
=	O
atoi	function
(	O
*	O
args	pointer
)	O
*	O
1000	int
;	O
if	O
(	O
argc	int
>	O
1	int
)	O
{	O
if	O
(	O
(	O
i	int
=	O
FindCommnr	function
(	O
args	pointer
[	O
1	int
]	O
)	O
)	O
==	O
RC_ILLEGAL	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"%s: idle: unknown command '%s'"	pointer
,	O
rc_name	pointer
,	O
args	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
CheckArgNum	function
(	O
i	int
,	O
args	pointer
+	O
2	int
)	O
<	O
0	int
)	O
break	O
;	O
ClearAction	function
(	O
&	O
idleaction	struct
)	O
;	O
SaveAction	function
(	O
&	O
idleaction	struct
,	O
i	int
,	O
args	pointer
+	O
2	int
,	O
argl	pointer
+	O
2	int
)	O
;	O
}	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
ResetIdle	function
(	O
)	O
;	O
display	struct
=	O
olddisplay	pointer
;	O
}	O
if	O
(	O
msgok	int
)	O
{	O
if	O
(	O
idletimo	int
)	O
OutputMsg	O
(	O
0	int
,	O
"idle timeout %ds, %s"	pointer
,	O
idletimo	int
/	O
1000	int
,	O
comms	array
[	O
idleaction	struct
.	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
else	O
OutputMsg	O
(	O
0	int
,	O
"idle off"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
RC_FOCUSMINSIZE	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
&&	O
args	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
i	int
]	O
,	O
"max"	pointer
)	O
||	O
!	O
strcmp	function
(	O
args	pointer
[	O
i	int
]	O
,	O
"_"	pointer
)	O
)	O
n	int
=	O
-	O
1	int
;	O
else	O
n	int
=	O
atoi	function
(	O
args	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
focusminwidth	int
=	O
n	int
;	O
else	O
focusminheight	int
=	O
n	int
;	O
}	O
if	O
(	O
msgok	int
)	O
{	O
char	O
b	array
[	O
2	int
]	O
[	O
20	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
n	int
=	O
i	int
==	O
0	int
?	O
focusminwidth	int
:	O
focusminheight	int
;	O
if	O
(	O
n	int
==	O
-	O
1	int
)	O
strcpy	function
(	O
b	array
[	O
i	int
]	O
,	O
"max"	pointer
)	O
;	O
else	O
sprintf	function
(	O
b	array
[	O
i	int
]	O
,	O
"%d"	pointer
,	O
n	int
)	O
;	O
}	O
OutputMsg	O
(	O
0	int
,	O
"focus min size is %s %s\n"	pointer
,	O
b	array
[	O
0	int
]	O
,	O
b	array
[	O
1	int
]	O
)	O
;	O
}	O
break	O
;	O
case	O
RC_GROUP	int
:	O
if	O
(	O
*	O
args	pointer
)	O
{	O
fore	pointer
->	O
w_group	pointer
=	O
0	int
;	O
if	O
(	O
args	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
{	O
fore	pointer
->	O
w_group	pointer
=	O
WindowByName	function
(	O
*	O
args	pointer
)	O
;	O
if	O
(	O
fore	pointer
->	O
w_group	pointer
==	O
fore	pointer
||	O
(	O
fore	pointer
->	O
w_group	pointer
&&	O
fore	pointer
->	O
w_group	pointer
->	O
w_type	int
!=	O
W_TYPE_GROUP	int
)	O
)	O
fore	pointer
->	O
w_group	pointer
=	O
0	int
;	O
}	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'w'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'W'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
msgok	int
)	O
{	O
if	O
(	O
fore	pointer
->	O
w_group	pointer
)	O
OutputMsg	O
(	O
0	int
,	O
"window group is %d (%s)\n"	pointer
,	O
fore	pointer
->	O
w_group	pointer
->	O
w_number	int
,	O
fore	pointer
->	O
w_group	pointer
->	O
w_title	pointer
)	O
;	O
else	O
OutputMsg	O
(	O
0	int
,	O
"window belongs to no group"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
RC_LAYOUT	int
:	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"title"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
display	struct
)	O
{	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
break	O
;	O
if	O
(	O
!	O
layout_attach	pointer
||	O
layout_attach	pointer
==	O
&	O
layout_last_marker	struct
)	O
layout_attach	pointer
=	O
CreateLayout	function
(	O
args	pointer
[	O
1	int
]	O
,	O
0	int
)	O
;	O
else	O
RenameLayout	function
(	O
layout_attach	pointer
,	O
args	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
D_layout	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"not on a layout"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"current layout is %d (%s)"	pointer
,	O
D_layout	O
->	O
lay_number	int
,	O
D_layout	O
->	O
lay_title	pointer
)	O
;	O
break	O
;	O
}	O
RenameLayout	function
(	O
D_layout	O
,	O
args	pointer
[	O
1	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"number"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
display	struct
)	O
{	O
if	O
(	O
args	pointer
[	O
1	int
]	O
&&	O
layout_attach	pointer
&&	O
layout_attach	pointer
!=	O
&	O
layout_last_marker	struct
)	O
RenumberLayout	function
(	O
layout_attach	pointer
,	O
atoi	function
(	O
args	pointer
[	O
1	int
]	O
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
D_layout	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"not on a layout"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"This is layout %d (%s).\n"	pointer
,	O
D_layout	O
->	O
lay_number	int
,	O
D_layout	O
->	O
lay_title	pointer
)	O
;	O
break	O
;	O
}	O
RenumberLayout	function
(	O
D_layout	O
,	O
atoi	function
(	O
args	pointer
[	O
1	int
]	O
)	O
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"autosave"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
display	struct
)	O
{	O
if	O
(	O
args	pointer
[	O
1	int
]	O
&&	O
layout_attach	pointer
&&	O
layout_attach	pointer
!=	O
&	O
layout_last_marker	struct
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
1	int
]	O
,	O
"on"	pointer
)	O
)	O
layout_attach	pointer
->	O
lay_autosave	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
1	int
]	O
,	O
"off"	pointer
)	O
)	O
layout_attach	pointer
->	O
lay_autosave	int
=	O
0	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
!	O
D_layout	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"not on a layout"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
1	int
]	O
,	O
"on"	pointer
)	O
)	O
D_layout	O
->	O
lay_autosave	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
1	int
]	O
,	O
"off"	pointer
)	O
)	O
D_layout	O
->	O
lay_autosave	int
=	O
0	int
;	O
else	O
{	O
OutputMsg	O
(	O
0	int
,	O
"invalid argument. Give 'on' or 'off"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"autosave is %s"	pointer
,	O
D_layout	O
->	O
lay_autosave	int
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"new"	pointer
)	O
)	O
{	O
char	O
*	O
t	int
=	O
args	pointer
[	O
1	int
]	O
;	O
n	int
=	O
0	int
;	O
if	O
(	O
t	int
)	O
{	O
while	O
(	O
*	O
t	int
>=	O
'0'	O
&&	O
*	O
t	int
<=	O
'9'	O
)	O
t	int
++	O
;	O
if	O
(	O
t	int
!=	O
args	pointer
[	O
1	int
]	O
&&	O
(	O
!	O
*	O
t	int
||	O
*	O
t	int
==	O
':'	O
)	O
)	O
{	O
n	int
=	O
atoi	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
*	O
t	int
)	O
t	int
++	O
;	O
}	O
else	O
t	int
=	O
args	pointer
[	O
1	int
]	O
;	O
}	O
if	O
(	O
!	O
t	int
||	O
!	O
*	O
t	int
)	O
t	int
=	O
"layout"	pointer
;	O
NewLayout	function
(	O
t	int
,	O
n	int
)	O
;	O
Activate	function
(	O
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"save"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"usage: layout save <name>"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
display	struct
)	O
SaveLayout	function
(	O
args	pointer
[	O
1	int
]	O
,	O
&	O
D_canvas	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"select"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
display	struct
)	O
{	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
layout_attach	pointer
=	O
FindLayout	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
{	O
Input	function
(	O
"Switch to layout: "	pointer
,	O
20	int
,	O
INP_COOKED	int
,	O
SelectLayoutFin	function
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
}	O
SelectLayoutFin	function
(	O
args	pointer
[	O
1	int
]	O
,	O
strlen	function
(	O
args	pointer
[	O
1	int
]	O
)	O
,	O
(	O
char	O
*	O
)	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"next"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
display	struct
)	O
{	O
if	O
(	O
layout_attach	pointer
&&	O
layout_attach	pointer
!=	O
&	O
layout_last_marker	struct
)	O
layout_attach	pointer
=	O
layout_attach	pointer
->	O
lay_next	pointer
?	O
layout_attach	pointer
->	O
lay_next	pointer
:	O
layouts	pointer
;	O
;	O
break	O
;	O
}	O
struct	O
layout	struct
*	O
lay	pointer
=	O
D_layout	O
;	O
if	O
(	O
lay	pointer
)	O
lay	pointer
=	O
lay	pointer
->	O
lay_next	pointer
?	O
lay	pointer
->	O
lay_next	pointer
:	O
layouts	pointer
;	O
else	O
lay	pointer
=	O
layouts	pointer
;	O
if	O
(	O
!	O
lay	pointer
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"no layout defined"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
lay	pointer
==	O
D_layout	O
)	O
break	O
;	O
LoadLayout	function
(	O
lay	pointer
,	O
&	O
D_canvas	O
)	O
;	O
Activate	function
(	O
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"prev"	pointer
)	O
)	O
{	O
struct	O
layout	struct
*	O
lay	pointer
=	O
display	struct
?	O
D_layout	O
:	O
layout_attach	pointer
;	O
struct	O
layout	struct
*	O
target	pointer
=	O
lay	pointer
;	O
if	O
(	O
lay	pointer
)	O
{	O
for	O
(	O
lay	pointer
=	O
layouts	pointer
;	O
lay	pointer
->	O
lay_next	pointer
&&	O
lay	pointer
->	O
lay_next	pointer
!=	O
target	pointer
;	O
lay	pointer
=	O
lay	pointer
->	O
lay_next	pointer
)	O
;	O
}	O
else	O
lay	pointer
=	O
layouts	pointer
;	O
if	O
(	O
!	O
display	struct
)	O
{	O
layout_attach	pointer
=	O
lay	pointer
;	O
break	O
;	O
}	O
if	O
(	O
!	O
lay	pointer
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"no layout defined"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
lay	pointer
==	O
D_layout	O
)	O
break	O
;	O
LoadLayout	function
(	O
lay	pointer
,	O
&	O
D_canvas	O
)	O
;	O
Activate	function
(	O
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"attach"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
)	O
{	O
if	O
(	O
!	O
layout_attach	pointer
)	O
OutputMsg	O
(	O
0	int
,	O
"no attach layout set"	pointer
)	O
;	O
else	O
if	O
(	O
layout_attach	pointer
==	O
&	O
layout_last_marker	struct
)	O
OutputMsg	O
(	O
0	int
,	O
"will attach to last layout"	pointer
)	O
;	O
else	O
OutputMsg	O
(	O
0	int
,	O
"will attach to layout %d (%s)"	pointer
,	O
layout_attach	pointer
->	O
lay_number	int
,	O
layout_attach	pointer
->	O
lay_title	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
1	int
]	O
,	O
":last"	pointer
)	O
)	O
layout_attach	pointer
=	O
&	O
layout_last_marker	struct
;	O
else	O
if	O
(	O
!	O
args	pointer
[	O
1	int
]	O
[	O
0	int
]	O
)	O
layout_attach	pointer
=	O
0	int
;	O
else	O
{	O
struct	O
layout	struct
*	O
lay	pointer
;	O
lay	pointer
=	O
FindLayout	function
(	O
args	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
lay	pointer
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"unknown layout '%s'"	pointer
,	O
args	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
layout_attach	pointer
=	O
lay	pointer
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"show"	pointer
)	O
)	O
{	O
ShowLayouts	function
(	O
-	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"remove"	pointer
)	O
)	O
{	O
struct	O
layout	struct
*	O
lay	pointer
=	O
display	struct
?	O
D_layout	O
:	O
layouts	pointer
;	O
if	O
(	O
args	pointer
[	O
1	int
]	O
)	O
{	O
lay	pointer
=	O
layouts	pointer
?	O
FindLayout	function
(	O
args	pointer
[	O
1	int
]	O
)	O
:	O
(	O
struct	O
layout	struct
*	O
)	O
0	int
;	O
if	O
(	O
!	O
lay	pointer
)	O
{	O
OutputMsg	O
(	O
0	int
,	O
"unknown layout '%s'"	pointer
,	O
args	pointer
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
lay	pointer
)	O
RemoveLayout	function
(	O
lay	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"dump"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
display	struct
)	O
OutputMsg	O
(	O
0	int
,	O
"Must have a display for 'layout dump'."	pointer
)	O
;	O
else	O
if	O
(	O
!	O
LayoutDumpCanvas	function
(	O
&	O
D_canvas	O
,	O
args	pointer
[	O
1	int
]	O
?	O
args	pointer
[	O
1	int
]	O
:	O
"layout-dump"	pointer
)	O
)	O
OutputMsg	O
(	O
errno	O
,	O
"Error dumping layout."	pointer
)	O
;	O
else	O
OutputMsg	O
(	O
0	int
,	O
"Layout dumped to \"%s\""	pointer
,	O
args	pointer
[	O
1	int
]	O
?	O
args	pointer
[	O
1	int
]	O
:	O
"layout-dump"	pointer
)	O
;	O
}	O
else	O
OutputMsg	O
(	O
0	int
,	O
"unknown layout subcommand"	pointer
)	O
;	O
break	O
;	O
case	O
RC_CJKWIDTH	int
:	O
if	O
(	O
ParseSwitch	function
(	O
act	pointer
,	O
&	O
cjkwidth	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
msgok	int
)	O
OutputMsg	O
(	O
0	int
,	O
"Treat ambiguous width characters as %s width"	pointer
,	O
cjkwidth	int
?	O
"full"	pointer
:	O
"half"	pointer
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
display	struct
!=	O
odisplay	pointer
)	O
{	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
if	O
(	O
display	struct
==	O
odisplay	pointer
)	O
break	O
;	O
}	O
}	O
void	O
CollapseWindowlist	function
(	O
)	O
{	O
int	O
pos	int
,	O
moveto	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
1	int
;	O
pos	int
<	O
MAXWIN	int
;	O
pos	int
++	O
)	O
if	O
(	O
wtab	pointer
[	O
pos	int
]	O
)	O
for	O
(	O
;	O
moveto	int
<	O
pos	int
;	O
moveto	int
++	O
)	O
if	O
(	O
!	O
wtab	pointer
[	O
moveto	int
]	O
)	O
{	O
WindowChangeNumber	function
(	O
pos	int
,	O
moveto	int
)	O
;	O
break	O
;	O
}	O
}	O
void	O
DoCommand	function
(	O
argv	pointer
,	O
argl	pointer
)	O
char	O
*	O
*	O
argv	pointer
;	O
int	O
*	O
argl	pointer
;	O
{	O
struct	O
action	struct
act	pointer
;	O
const	O
char	O
*	O
cmd	array
=	O
*	O
argv	pointer
;	O
act	pointer
.	O
quiet	int
=	O
0	int
;	O
if	O
(	O
*	O
cmd	array
==	O
'@'	O
)	O
{	O
act	pointer
.	O
quiet	int
|=	O
0x01	int
;	O
cmd	array
++	O
;	O
}	O
if	O
(	O
*	O
cmd	array
==	O
'-'	O
)	O
{	O
act	pointer
.	O
quiet	int
|=	O
0x02	int
;	O
cmd	array
++	O
;	O
}	O
if	O
(	O
(	O
act	pointer
.	O
nr	int
=	O
FindCommnr	function
(	O
cmd	array
)	O
)	O
==	O
RC_ILLEGAL	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: unknown command '%s'"	pointer
,	O
rc_name	pointer
,	O
cmd	array
)	O
;	O
return	O
;	O
}	O
act	pointer
.	O
args	pointer
=	O
argv	pointer
+	O
1	int
;	O
act	pointer
.	O
argl	pointer
=	O
argl	pointer
+	O
1	int
;	O
DoAction	function
(	O
&	O
act	pointer
,	O
-	O
1	int
)	O
;	O
}	O
static	O
void	O
SaveAction	function
(	O
act	pointer
,	O
nr	int
,	O
args	pointer
,	O
argl	pointer
)	O
struct	O
action	struct
*	O
act	pointer
;	O
int	O
nr	int
;	O
char	O
*	O
*	O
args	pointer
;	O
int	O
*	O
argl	pointer
;	O
{	O
register	O
int	O
argc	int
=	O
0	int
;	O
char	O
*	O
*	O
pp	pointer
;	O
int	O
*	O
lp	pointer
;	O
if	O
(	O
args	pointer
)	O
while	O
(	O
args	pointer
[	O
argc	int
]	O
)	O
argc	int
++	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
act	pointer
->	O
nr	int
=	O
nr	int
;	O
act	pointer
->	O
args	pointer
=	O
noargs	array
;	O
act	pointer
->	O
argl	pointer
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
pp	pointer
=	O
(	O
char	O
*	O
*	O
)	O
malloc	function
(	O
(	O
unsigned	O
)	O
(	O
argc	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
)	O
==	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
if	O
(	O
(	O
lp	pointer
=	O
(	O
int	O
*	O
)	O
malloc	function
(	O
(	O
unsigned	O
)	O
(	O
argc	int
)	O
*	O
sizeof	O
(	O
int	O
)	O
)	O
)	O
==	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
act	pointer
->	O
nr	int
=	O
nr	int
;	O
act	pointer
->	O
args	pointer
=	O
pp	pointer
;	O
act	pointer
->	O
argl	pointer
=	O
lp	pointer
;	O
while	O
(	O
argc	int
--	O
)	O
{	O
*	O
lp	pointer
=	O
argl	pointer
?	O
*	O
argl	pointer
++	O
:	O
(	O
int	O
)	O
strlen	function
(	O
*	O
args	pointer
)	O
;	O
*	O
pp	pointer
++	O
=	O
SaveStrn	function
(	O
*	O
args	pointer
++	O
,	O
*	O
lp	pointer
++	O
)	O
;	O
}	O
*	O
pp	pointer
=	O
0	int
;	O
}	O
static	O
char	O
*	O
*	O
SaveArgs	function
(	O
args	pointer
)	O
char	O
*	O
*	O
args	pointer
;	O
{	O
register	O
char	O
*	O
*	O
ap	pointer
,	O
*	O
*	O
pp	pointer
;	O
register	O
int	O
argc	int
=	O
0	int
;	O
while	O
(	O
args	pointer
[	O
argc	int
]	O
)	O
argc	int
++	O
;	O
if	O
(	O
(	O
pp	pointer
=	O
ap	pointer
=	O
(	O
char	O
*	O
*	O
)	O
malloc	function
(	O
(	O
unsigned	O
)	O
(	O
argc	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
*	O
)	O
)	O
)	O
==	O
0	int
)	O
Panic	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
while	O
(	O
argc	int
--	O
)	O
*	O
pp	pointer
++	O
=	O
SaveStr	function
(	O
*	O
args	pointer
++	O
)	O
;	O
*	O
pp	pointer
=	O
0	int
;	O
return	O
ap	pointer
;	O
}	O
int	O
Parse	function
(	O
buf	pointer
,	O
bufl	int
,	O
args	pointer
,	O
argl	pointer
)	O
char	O
*	O
buf	pointer
,	O
*	O
*	O
args	pointer
;	O
int	O
bufl	int
,	O
*	O
argl	pointer
;	O
{	O
register	O
char	O
*	O
p	pointer
=	O
buf	pointer
,	O
*	O
*	O
ap	pointer
=	O
args	pointer
,	O
*	O
pp	pointer
;	O
register	O
int	O
delim	int
,	O
argc	int
;	O
int	O
*	O
lp	pointer
=	O
argl	pointer
;	O
debug2	O
(	O
"Parse %d %s\n"	pointer
,	O
bufl	int
,	O
buf	pointer
)	O
;	O
argc	int
=	O
0	int
;	O
pp	pointer
=	O
buf	pointer
;	O
delim	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
*	O
lp	pointer
=	O
0	int
;	O
while	O
(	O
*	O
p	pointer
&&	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
)	O
)	O
++	O
p	pointer
;	O
if	O
(	O
argc	int
==	O
0	int
&&	O
*	O
p	pointer
==	O
'!'	O
)	O
{	O
*	O
ap	pointer
++	O
=	O
"exec"	pointer
;	O
*	O
lp	pointer
++	O
=	O
4	int
;	O
p	pointer
++	O
;	O
argc	int
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
||	O
*	O
p	pointer
==	O
'#'	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
{	O
*	O
p	pointer
=	O
'\0'	O
;	O
for	O
(	O
delim	int
=	O
0	int
;	O
delim	int
<	O
argc	int
;	O
delim	int
++	O
)	O
debug1	O
(	O
"-- %s\n"	pointer
,	O
args	pointer
[	O
delim	int
]	O
)	O
;	O
args	pointer
[	O
argc	int
]	O
=	O
0	int
;	O
return	O
argc	int
;	O
}	O
if	O
(	O
++	O
argc	int
>=	O
MAXARGS	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: too many tokens."	pointer
,	O
rc_name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
*	O
ap	pointer
++	O
=	O
pp	pointer
;	O
debug1	O
(	O
"- new arg %s\n"	pointer
,	O
p	pointer
)	O
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
delim	int
)	O
delim	int
=	O
0	int
;	O
else	O
if	O
(	O
delim	int
!=	O
'\''	O
&&	O
*	O
p	pointer
==	O
'\\'	O
&&	O
(	O
p	pointer
[	O
1	int
]	O
==	O
'n'	O
||	O
p	pointer
[	O
1	int
]	O
==	O
'r'	O
||	O
p	pointer
[	O
1	int
]	O
==	O
't'	O
||	O
p	pointer
[	O
1	int
]	O
==	O
'\''	O
||	O
p	pointer
[	O
1	int
]	O
==	O
'"'	O
||	O
p	pointer
[	O
1	int
]	O
==	O
'\\'	O
||	O
p	pointer
[	O
1	int
]	O
==	O
'$'	O
||	O
p	pointer
[	O
1	int
]	O
==	O
'#'	O
||	O
p	pointer
[	O
1	int
]	O
==	O
'^'	O
||	O
(	O
p	pointer
[	O
1	int
]	O
>=	O
'0'	O
&&	O
p	pointer
[	O
1	int
]	O
<=	O
'7'	O
)	O
)	O
)	O
{	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
>=	O
'0'	O
&&	O
*	O
p	pointer
<=	O
'7'	O
)	O
{	O
*	O
pp	pointer
=	O
*	O
p	pointer
-	O
'0'	O
;	O
if	O
(	O
p	pointer
[	O
1	int
]	O
>=	O
'0'	O
&&	O
p	pointer
[	O
1	int
]	O
<=	O
'7'	O
)	O
{	O
p	pointer
++	O
;	O
*	O
pp	pointer
=	O
(	O
*	O
pp	pointer
<<	O
3	int
)	O
|	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
if	O
(	O
p	pointer
[	O
1	int
]	O
>=	O
'0'	O
&&	O
p	pointer
[	O
1	int
]	O
<=	O
'7'	O
)	O
{	O
p	pointer
++	O
;	O
*	O
pp	pointer
=	O
(	O
*	O
pp	pointer
<<	O
3	int
)	O
|	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
}	O
}	O
pp	pointer
++	O
;	O
}	O
else	O
{	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'n'	O
:	O
*	O
pp	pointer
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
*	O
pp	pointer
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
*	O
pp	pointer
=	O
'\t'	O
;	O
break	O
;	O
default	O
:	O
*	O
pp	pointer
=	O
*	O
p	pointer
;	O
break	O
;	O
}	O
pp	pointer
++	O
;	O
}	O
}	O
else	O
if	O
(	O
delim	int
!=	O
'\''	O
&&	O
*	O
p	pointer
==	O
'$'	O
&&	O
(	O
p	pointer
[	O
1	int
]	O
==	O
'{'	O
||	O
p	pointer
[	O
1	int
]	O
==	O
':'	O
||	O
(	O
p	pointer
[	O
1	int
]	O
>=	O
'a'	O
&&	O
p	pointer
[	O
1	int
]	O
<=	O
'z'	O
)	O
||	O
(	O
p	pointer
[	O
1	int
]	O
>=	O
'A'	O
&&	O
p	pointer
[	O
1	int
]	O
<=	O
'Z'	O
)	O
||	O
(	O
p	pointer
[	O
1	int
]	O
>=	O
'0'	O
&&	O
p	pointer
[	O
1	int
]	O
<=	O
'9'	O
)	O
||	O
p	pointer
[	O
1	int
]	O
==	O
'_'	O
)	O
)	O
{	O
char	O
*	O
ps	pointer
,	O
*	O
pe	pointer
,	O
op	char
,	O
*	O
v	pointer
,	O
xbuf	array
[	O
11	int
]	O
,	O
path	array
[	O
MAXPATHLEN	O
]	O
;	O
int	O
vl	int
;	O
ps	pointer
=	O
++	O
p	pointer
;	O
debug1	O
(	O
"- var %s\n"	pointer
,	O
ps	pointer
)	O
;	O
p	pointer
++	O
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
if	O
(	O
*	O
ps	pointer
==	O
'{'	O
&&	O
*	O
p	pointer
==	O
'}'	O
)	O
break	O
;	O
if	O
(	O
*	O
ps	pointer
==	O
':'	O
&&	O
*	O
p	pointer
==	O
':'	O
)	O
break	O
;	O
if	O
(	O
*	O
ps	pointer
!=	O
'{'	O
&&	O
*	O
ps	pointer
!=	O
':'	O
&&	O
(	O
*	O
p	pointer
<	O
'a'	O
||	O
*	O
p	pointer
>	O
'z'	O
)	O
&&	O
(	O
*	O
p	pointer
<	O
'A'	O
||	O
*	O
p	pointer
>	O
'Z'	O
)	O
&&	O
(	O
*	O
p	pointer
<	O
'0'	O
||	O
*	O
p	pointer
>	O
'9'	O
)	O
&&	O
*	O
p	pointer
!=	O
'_'	O
)	O
break	O
;	O
p	pointer
++	O
;	O
}	O
pe	pointer
=	O
p	pointer
;	O
if	O
(	O
*	O
ps	pointer
==	O
'{'	O
||	O
*	O
ps	pointer
==	O
':'	O
)	O
{	O
if	O
(	O
!	O
*	O
p	pointer
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: bad variable name."	pointer
,	O
rc_name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
p	pointer
++	O
;	O
}	O
op	char
=	O
*	O
pe	pointer
;	O
*	O
pe	pointer
=	O
0	int
;	O
debug1	O
(	O
"- var is '%s'\n"	pointer
,	O
ps	pointer
)	O
;	O
if	O
(	O
*	O
ps	pointer
==	O
':'	O
)	O
v	pointer
=	O
gettermcapstring	function
(	O
ps	pointer
+	O
1	int
)	O
;	O
else	O
{	O
if	O
(	O
*	O
ps	pointer
==	O
'{'	O
)	O
ps	pointer
++	O
;	O
v	pointer
=	O
xbuf	array
;	O
if	O
(	O
!	O
strcmp	function
(	O
ps	pointer
,	O
"TERM"	pointer
)	O
)	O
v	pointer
=	O
display	struct
?	O
D_termname	O
:	O
"unknown"	pointer
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
ps	pointer
,	O
"COLUMNS"	pointer
)	O
)	O
sprintf	function
(	O
xbuf	array
,	O
"%d"	pointer
,	O
display	struct
?	O
D_width	O
:	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
ps	pointer
,	O
"LINES"	pointer
)	O
)	O
sprintf	function
(	O
xbuf	array
,	O
"%d"	pointer
,	O
display	struct
?	O
D_height	O
:	O
-	O
1	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
ps	pointer
,	O
"PID"	pointer
)	O
)	O
sprintf	function
(	O
xbuf	array
,	O
"%d"	pointer
,	O
getpid	function
(	O
)	O
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
ps	pointer
,	O
"PWD"	pointer
)	O
)	O
{	O
if	O
(	O
getcwd	function
(	O
path	array
,	O
sizeof	O
(	O
path	array
)	O
-	O
1	int
)	O
==	O
0	int
)	O
v	pointer
=	O
"?"	pointer
;	O
else	O
v	pointer
=	O
path	array
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
ps	pointer
,	O
"STY"	pointer
)	O
)	O
{	O
if	O
(	O
(	O
v	pointer
=	O
strchr	function
(	O
SockName	pointer
,	O
'.'	O
)	O
)	O
)	O
v	pointer
++	O
;	O
else	O
v	pointer
=	O
SockName	pointer
;	O
}	O
else	O
v	pointer
=	O
getenv	function
(	O
ps	pointer
)	O
;	O
}	O
*	O
pe	pointer
=	O
op	char
;	O
vl	int
=	O
v	pointer
?	O
strlen	function
(	O
v	pointer
)	O
:	O
0	int
;	O
if	O
(	O
vl	int
)	O
{	O
debug1	O
(	O
"- sub is '%s'\n"	pointer
,	O
v	pointer
)	O
;	O
if	O
(	O
p	pointer
-	O
pp	pointer
<	O
vl	int
)	O
{	O
int	O
right	pointer
=	O
buf	pointer
+	O
bufl	int
-	O
(	O
p	pointer
+	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
right	pointer
>	O
0	int
)	O
{	O
bcopy	function
(	O
p	pointer
,	O
p	pointer
+	O
right	pointer
,	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
)	O
;	O
p	pointer
+=	O
right	pointer
;	O
}	O
}	O
if	O
(	O
p	pointer
-	O
pp	pointer
<	O
vl	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: no space left for variable expansion."	pointer
,	O
rc_name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
bcopy	function
(	O
v	pointer
,	O
pp	pointer
,	O
vl	int
)	O
;	O
pp	pointer
+=	O
vl	int
;	O
}	O
continue	O
;	O
}	O
else	O
if	O
(	O
delim	int
!=	O
'\''	O
&&	O
*	O
p	pointer
==	O
'^'	O
&&	O
p	pointer
[	O
1	int
]	O
)	O
{	O
p	pointer
++	O
;	O
*	O
pp	pointer
++	O
=	O
*	O
p	pointer
==	O
'?'	O
?	O
'\177'	O
:	O
*	O
p	pointer
&	O
0x1f	int
;	O
}	O
else	O
if	O
(	O
delim	int
==	O
0	int
&&	O
(	O
*	O
p	pointer
==	O
'\''	O
||	O
*	O
p	pointer
==	O
'"'	O
)	O
)	O
delim	int
=	O
*	O
p	pointer
;	O
else	O
if	O
(	O
delim	int
==	O
0	int
&&	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\t'	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
)	O
break	O
;	O
else	O
*	O
pp	pointer
++	O
=	O
*	O
p	pointer
;	O
p	pointer
++	O
;	O
}	O
if	O
(	O
delim	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: Missing %c quote."	pointer
,	O
rc_name	pointer
,	O
delim	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
*	O
p	pointer
)	O
p	pointer
++	O
;	O
*	O
pp	pointer
=	O
0	int
;	O
debug2	O
(	O
"- arg done, '%s' rest %s\n"	pointer
,	O
ap	pointer
[	O
-	O
1	int
]	O
,	O
p	pointer
)	O
;	O
*	O
lp	pointer
++	O
=	O
pp	pointer
-	O
ap	pointer
[	O
-	O
1	int
]	O
;	O
pp	pointer
++	O
;	O
}	O
}	O
void	O
SetEscape	function
(	O
u	pointer
,	O
e	int
,	O
me	int
)	O
struct	O
acluser	struct
*	O
u	pointer
;	O
int	O
e	int
,	O
me	int
;	O
{	O
if	O
(	O
u	pointer
)	O
{	O
u	pointer
->	O
u_Esc	int
=	O
e	int
;	O
u	pointer
->	O
u_MetaEsc	int
=	O
me	int
;	O
}	O
else	O
{	O
if	O
(	O
users	pointer
)	O
{	O
if	O
(	O
DefaultEsc	int
>=	O
0	int
)	O
ClearAction	function
(	O
&	O
ktab	array
[	O
DefaultEsc	int
]	O
)	O
;	O
if	O
(	O
DefaultMetaEsc	int
>=	O
0	int
)	O
ClearAction	function
(	O
&	O
ktab	array
[	O
DefaultMetaEsc	int
]	O
)	O
;	O
}	O
DefaultEsc	int
=	O
e	int
;	O
DefaultMetaEsc	int
=	O
me	int
;	O
if	O
(	O
users	pointer
)	O
{	O
if	O
(	O
DefaultEsc	int
>=	O
0	int
)	O
{	O
ClearAction	function
(	O
&	O
ktab	array
[	O
DefaultEsc	int
]	O
)	O
;	O
ktab	array
[	O
DefaultEsc	int
]	O
.	O
nr	int
=	O
RC_OTHER	int
;	O
}	O
if	O
(	O
DefaultMetaEsc	int
>=	O
0	int
)	O
{	O
ClearAction	function
(	O
&	O
ktab	array
[	O
DefaultMetaEsc	int
]	O
)	O
;	O
ktab	array
[	O
DefaultMetaEsc	int
]	O
.	O
nr	int
=	O
RC_META	int
;	O
}	O
}	O
}	O
}	O
int	O
ParseSwitch	function
(	O
act	pointer
,	O
var	pointer
)	O
struct	O
action	struct
*	O
act	pointer
;	O
int	O
*	O
var	pointer
;	O
{	O
if	O
(	O
*	O
act	pointer
->	O
args	pointer
==	O
0	int
)	O
{	O
*	O
var	pointer
^=	O
1	int
;	O
return	O
0	int
;	O
}	O
return	O
ParseOnOff	function
(	O
act	pointer
,	O
var	pointer
)	O
;	O
}	O
static	O
int	O
ParseOnOff	function
(	O
act	pointer
,	O
var	pointer
)	O
struct	O
action	struct
*	O
act	pointer
;	O
int	O
*	O
var	pointer
;	O
{	O
register	O
int	O
num	int
=	O
-	O
1	int
;	O
char	O
*	O
*	O
args	pointer
=	O
act	pointer
->	O
args	pointer
;	O
if	O
(	O
args	pointer
[	O
1	int
]	O
==	O
0	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"on"	pointer
)	O
==	O
0	int
)	O
num	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
args	pointer
[	O
0	int
]	O
,	O
"off"	pointer
)	O
==	O
0	int
)	O
num	int
=	O
0	int
;	O
}	O
if	O
(	O
num	int
<	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: invalid argument. Give 'on' or 'off'"	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
*	O
var	pointer
=	O
num	int
;	O
return	O
0	int
;	O
}	O
int	O
ParseSaveStr	function
(	O
act	pointer
,	O
var	pointer
)	O
struct	O
action	struct
*	O
act	pointer
;	O
char	O
*	O
*	O
var	pointer
;	O
{	O
char	O
*	O
*	O
args	pointer
=	O
act	pointer
->	O
args	pointer
;	O
if	O
(	O
*	O
args	pointer
==	O
0	int
||	O
args	pointer
[	O
1	int
]	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: one argument required."	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
*	O
var	pointer
)	O
free	function
(	O
*	O
var	pointer
)	O
;	O
*	O
var	pointer
=	O
SaveStr	function
(	O
*	O
args	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
ParseNum	function
(	O
act	pointer
,	O
var	pointer
)	O
struct	O
action	struct
*	O
act	pointer
;	O
int	O
*	O
var	pointer
;	O
{	O
int	O
i	int
;	O
char	O
*	O
p	pointer
,	O
*	O
*	O
args	pointer
=	O
act	pointer
->	O
args	pointer
;	O
p	pointer
=	O
*	O
args	pointer
;	O
if	O
(	O
p	pointer
==	O
0	int
||	O
*	O
p	pointer
==	O
0	int
||	O
args	pointer
[	O
1	int
]	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: invalid argument. Give one argument."	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
>=	O
'0'	O
&&	O
*	O
p	pointer
<=	O
'9'	O
)	O
i	int
=	O
10	int
*	O
i	int
+	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
else	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: invalid argument. Give numeric argument."	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
p	pointer
++	O
;	O
}	O
debug1	O
(	O
"ParseNum got %d\n"	pointer
,	O
i	int
)	O
;	O
*	O
var	pointer
=	O
i	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ParseNum1000	function
(	O
act	pointer
,	O
var	pointer
)	O
struct	O
action	struct
*	O
act	pointer
;	O
int	O
*	O
var	pointer
;	O
{	O
int	O
i	int
;	O
char	O
*	O
p	pointer
,	O
*	O
*	O
args	pointer
=	O
act	pointer
->	O
args	pointer
;	O
int	O
dig	int
=	O
0	int
;	O
p	pointer
=	O
*	O
args	pointer
;	O
if	O
(	O
p	pointer
==	O
0	int
||	O
*	O
p	pointer
==	O
0	int
||	O
args	pointer
[	O
1	int
]	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: invalid argument. Give one argument."	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
p	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
>=	O
'0'	O
&&	O
*	O
p	pointer
<=	O
'9'	O
)	O
{	O
if	O
(	O
dig	int
<	O
4	int
)	O
i	int
=	O
10	int
*	O
i	int
+	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
else	O
if	O
(	O
dig	int
==	O
4	int
&&	O
*	O
p	pointer
>=	O
'5'	O
)	O
i	int
++	O
;	O
if	O
(	O
dig	int
)	O
dig	int
++	O
;	O
}	O
else	O
if	O
(	O
*	O
p	pointer
==	O
'.'	O
&&	O
!	O
dig	int
)	O
dig	int
++	O
;	O
else	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: invalid argument. Give floating point argument."	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
p	pointer
++	O
;	O
}	O
if	O
(	O
dig	int
==	O
0	int
)	O
i	int
*=	O
1000	int
;	O
else	O
while	O
(	O
dig	int
++	O
<	O
4	int
)	O
i	int
*=	O
10	int
;	O
if	O
(	O
i	int
<	O
0	int
)	O
i	int
=	O
(	O
int	O
)	O
(	O
(	O
unsigned	O
int	O
)	O
~	O
0	int
>>	O
1	int
)	O
;	O
debug1	O
(	O
"ParseNum1000 got %d\n"	pointer
,	O
i	int
)	O
;	O
*	O
var	pointer
=	O
i	int
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
win	struct
*	O
WindowByName	function
(	O
s	pointer
)	O
char	O
*	O
s	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
windows	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
w_next	pointer
)	O
if	O
(	O
!	O
strcmp	function
(	O
p	pointer
->	O
w_title	pointer
,	O
s	pointer
)	O
)	O
return	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
windows	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
w_next	pointer
)	O
if	O
(	O
!	O
strncmp	function
(	O
p	pointer
->	O
w_title	pointer
,	O
s	pointer
,	O
strlen	function
(	O
s	pointer
)	O
)	O
)	O
return	O
p	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
WindowByNumber	function
(	O
str	pointer
)	O
char	O
*	O
str	pointer
;	O
{	O
int	O
i	int
;	O
char	O
*	O
s	pointer
;	O
for	O
(	O
i	int
=	O
0	int
,	O
s	pointer
=	O
str	pointer
;	O
*	O
s	pointer
;	O
s	pointer
++	O
)	O
{	O
if	O
(	O
*	O
s	pointer
<	O
'0'	O
||	O
*	O
s	pointer
>	O
'9'	O
)	O
break	O
;	O
i	int
=	O
i	int
*	O
10	int
+	O
(	O
*	O
s	pointer
-	O
'0'	O
)	O
;	O
}	O
return	O
*	O
s	pointer
?	O
-	O
1	int
:	O
i	int
;	O
}	O
int	O
WindowByNoN	function
(	O
str	pointer
)	O
char	O
*	O
str	pointer
;	O
{	O
int	O
i	int
;	O
struct	O
win	struct
*	O
p	pointer
;	O
if	O
(	O
(	O
i	int
=	O
WindowByNumber	function
(	O
str	pointer
)	O
)	O
<	O
0	int
||	O
i	int
>=	O
maxwin	int
)	O
{	O
if	O
(	O
(	O
p	pointer
=	O
WindowByName	function
(	O
str	pointer
)	O
)	O
)	O
return	O
p	pointer
->	O
w_number	int
;	O
return	O
-	O
1	int
;	O
}	O
return	O
i	int
;	O
}	O
static	O
int	O
ParseWinNum	function
(	O
act	pointer
,	O
var	pointer
)	O
struct	O
action	struct
*	O
act	pointer
;	O
int	O
*	O
var	pointer
;	O
{	O
char	O
*	O
*	O
args	pointer
=	O
act	pointer
->	O
args	pointer
;	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
*	O
args	pointer
==	O
0	int
||	O
args	pointer
[	O
1	int
]	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: one argument required."	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
i	int
=	O
WindowByNoN	function
(	O
*	O
args	pointer
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: invalid argument. Give window number or name."	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
debug1	O
(	O
"ParseWinNum got %d\n"	pointer
,	O
i	int
)	O
;	O
*	O
var	pointer
=	O
i	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ParseBase	function
(	O
act	pointer
,	O
p	pointer
,	O
var	pointer
,	O
base	int
,	O
bname	pointer
)	O
struct	O
action	struct
*	O
act	pointer
;	O
char	O
*	O
p	pointer
;	O
int	O
*	O
var	pointer
;	O
int	O
base	int
;	O
char	O
*	O
bname	pointer
;	O
{	O
int	O
i	int
=	O
0	int
;	O
int	O
c	int
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: empty argument."	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
while	O
(	O
(	O
c	int
=	O
*	O
p	pointer
++	O
)	O
)	O
{	O
if	O
(	O
c	int
>=	O
'a'	O
&&	O
c	int
<=	O
'z'	O
)	O
c	int
-=	O
'a'	O
-	O
'A'	O
;	O
if	O
(	O
c	int
>=	O
'A'	O
&&	O
c	int
<=	O
'Z'	O
)	O
c	int
-=	O
'A'	O
-	O
(	O
'0'	O
+	O
10	int
)	O
;	O
c	int
-=	O
'0'	O
;	O
if	O
(	O
c	int
<	O
0	int
||	O
c	int
>=	O
base	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: %s: argument is not %s."	pointer
,	O
rc_name	pointer
,	O
comms	array
[	O
act	pointer
->	O
nr	int
]	O
.	O
name	pointer
,	O
bname	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
i	int
=	O
base	int
*	O
i	int
+	O
c	int
;	O
}	O
debug1	O
(	O
"ParseBase got %d\n"	pointer
,	O
i	int
)	O
;	O
*	O
var	pointer
=	O
i	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
IsNum	function
(	O
s	pointer
,	O
base	int
)	O
register	O
char	O
*	O
s	pointer
;	O
register	O
int	O
base	int
;	O
{	O
for	O
(	O
base	int
+=	O
'0'	O
;	O
*	O
s	pointer
;	O
++	O
s	pointer
)	O
if	O
(	O
*	O
s	pointer
<	O
'0'	O
||	O
*	O
s	pointer
>	O
base	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
int	O
IsNumColon	function
(	O
s	pointer
,	O
base	int
,	O
p	pointer
,	O
psize	int
)	O
int	O
base	int
,	O
psize	int
;	O
char	O
*	O
s	pointer
,	O
*	O
p	pointer
;	O
{	O
char	O
*	O
q	pointer
;	O
if	O
(	O
(	O
q	pointer
=	O
rindex	function
(	O
s	pointer
,	O
':'	O
)	O
)	O
!=	O
0	int
)	O
{	O
strncpy	function
(	O
p	pointer
,	O
q	pointer
+	O
1	int
,	O
psize	int
-	O
1	int
)	O
;	O
p	pointer
[	O
psize	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
*	O
q	pointer
=	O
'\0'	O
;	O
}	O
else	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
IsNum	function
(	O
s	pointer
,	O
base	int
)	O
;	O
}	O
void	O
SwitchWindow	function
(	O
n	int
)	O
int	O
n	int
;	O
{	O
struct	O
win	struct
*	O
p	pointer
;	O
debug1	O
(	O
"SwitchWindow %d\n"	pointer
,	O
n	int
)	O
;	O
if	O
(	O
n	int
<	O
0	int
||	O
n	int
>=	O
maxwin	int
)	O
{	O
ShowWindows	function
(	O
-	O
1	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
p	pointer
=	O
wtab	pointer
[	O
n	int
]	O
)	O
==	O
0	int
)	O
{	O
ShowWindows	function
(	O
n	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
display	struct
==	O
0	int
)	O
{	O
fore	pointer
=	O
p	pointer
;	O
return	O
;	O
}	O
if	O
(	O
p	pointer
==	O
D_fore	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"This IS window %d (%s)."	pointer
,	O
n	int
,	O
p	pointer
->	O
w_title	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
AclCheckPermWin	function
(	O
D_user	O
,	O
ACL_READ	int
,	O
p	pointer
)	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"Access to window %d denied."	pointer
,	O
p	pointer
->	O
w_number	int
)	O
;	O
return	O
;	O
}	O
SetForeWindow	function
(	O
p	pointer
)	O
;	O
Activate	function
(	O
fore	pointer
->	O
w_norefresh	char
)	O
;	O
}	O
void	O
SetForeWindow	function
(	O
wi	pointer
)	O
struct	O
win	struct
*	O
wi	pointer
;	O
{	O
struct	O
win	struct
*	O
p	pointer
;	O
if	O
(	O
display	struct
==	O
0	int
)	O
{	O
fore	pointer
=	O
wi	pointer
;	O
return	O
;	O
}	O
p	pointer
=	O
Layer2Window	O
(	O
D_forecv	O
->	O
c_layer	pointer
)	O
;	O
SetCanvasWindow	function
(	O
D_forecv	O
,	O
wi	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
WindowChanged	function
(	O
p	pointer
,	O
'u'	O
)	O
;	O
if	O
(	O
wi	pointer
)	O
WindowChanged	function
(	O
wi	pointer
,	O
'u'	O
)	O
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
}	O
void	O
Activate	function
(	O
norefresh	int
)	O
int	O
norefresh	int
;	O
{	O
debug1	O
(	O
"Activate(%d)\n"	pointer
,	O
norefresh	int
)	O
;	O
if	O
(	O
display	struct
==	O
0	int
)	O
return	O
;	O
if	O
(	O
D_status	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
""	pointer
)	O
;	O
RemoveStatus	function
(	O
)	O
;	O
}	O
if	O
(	O
MayResizeLayer	function
(	O
D_forecv	O
->	O
c_layer	pointer
)	O
)	O
ResizeLayer	function
(	O
D_forecv	O
->	O
c_layer	pointer
,	O
D_forecv	O
->	O
c_xe	int
-	O
D_forecv	O
->	O
c_xs	int
+	O
1	int
,	O
D_forecv	O
->	O
c_ye	int
-	O
D_forecv	O
->	O
c_ys	int
+	O
1	int
,	O
display	struct
)	O
;	O
fore	pointer
=	O
D_fore	O
;	O
if	O
(	O
fore	pointer
)	O
{	O
if	O
(	O
fore	pointer
->	O
w_monitor	int
!=	O
MON_OFF	int
)	O
fore	pointer
->	O
w_monitor	int
=	O
MON_ON	int
;	O
fore	pointer
->	O
w_bell	int
=	O
BELL_ON	int
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'f'	O
)	O
;	O
}	O
Redisplay	function
(	O
norefresh	int
+	O
all_norefresh	int
)	O
;	O
}	O
static	O
int	O
NextWindow	function
(	O
)	O
{	O
register	O
struct	O
win	struct
*	O
*	O
pp	pointer
;	O
int	O
n	int
=	O
fore	pointer
?	O
fore	pointer
->	O
w_number	int
:	O
maxwin	int
;	O
struct	O
win	struct
*	O
group	pointer
=	O
fore	pointer
?	O
fore	pointer
->	O
w_group	pointer
:	O
0	int
;	O
for	O
(	O
pp	pointer
=	O
fore	pointer
?	O
wtab	pointer
+	O
n	int
+	O
1	int
:	O
wtab	pointer
;	O
pp	pointer
!=	O
wtab	pointer
+	O
n	int
;	O
pp	pointer
++	O
)	O
{	O
if	O
(	O
pp	pointer
==	O
wtab	pointer
+	O
maxwin	int
)	O
pp	pointer
=	O
wtab	pointer
;	O
if	O
(	O
*	O
pp	pointer
)	O
{	O
if	O
(	O
!	O
fore	pointer
||	O
group	pointer
==	O
(	O
*	O
pp	pointer
)	O
->	O
w_group	pointer
)	O
break	O
;	O
}	O
}	O
if	O
(	O
pp	pointer
==	O
wtab	pointer
+	O
n	int
)	O
return	O
-	O
1	int
;	O
return	O
pp	pointer
-	O
wtab	pointer
;	O
}	O
static	O
int	O
PreviousWindow	function
(	O
)	O
{	O
register	O
struct	O
win	struct
*	O
*	O
pp	pointer
;	O
int	O
n	int
=	O
fore	pointer
?	O
fore	pointer
->	O
w_number	int
:	O
-	O
1	int
;	O
struct	O
win	struct
*	O
group	pointer
=	O
fore	pointer
?	O
fore	pointer
->	O
w_group	pointer
:	O
0	int
;	O
for	O
(	O
pp	pointer
=	O
wtab	pointer
+	O
n	int
-	O
1	int
;	O
pp	pointer
!=	O
wtab	pointer
+	O
n	int
;	O
pp	pointer
--	O
)	O
{	O
if	O
(	O
pp	pointer
==	O
wtab	pointer
-	O
1	int
)	O
pp	pointer
=	O
wtab	pointer
+	O
maxwin	int
-	O
1	int
;	O
if	O
(	O
*	O
pp	pointer
)	O
{	O
if	O
(	O
!	O
fore	pointer
||	O
group	pointer
==	O
(	O
*	O
pp	pointer
)	O
->	O
w_group	pointer
)	O
break	O
;	O
}	O
}	O
if	O
(	O
pp	pointer
==	O
wtab	pointer
+	O
n	int
)	O
return	O
-	O
1	int
;	O
return	O
pp	pointer
-	O
wtab	pointer
;	O
}	O
static	O
int	O
MoreWindows	function
(	O
)	O
{	O
char	O
*	O
m	union
=	O
"No other window."	pointer
;	O
if	O
(	O
windows	pointer
&&	O
(	O
fore	pointer
==	O
0	int
||	O
windows	pointer
->	O
w_next	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
fore	pointer
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"No window available"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
Msg	function
(	O
0	int
,	O
m	union
,	O
fore	pointer
->	O
w_number	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
KillWindow	function
(	O
wi	pointer
)	O
struct	O
win	struct
*	O
wi	pointer
;	O
{	O
struct	O
win	struct
*	O
*	O
pp	pointer
,	O
*	O
p	pointer
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
int	O
gotone	int
;	O
struct	O
layout	struct
*	O
lay	pointer
;	O
for	O
(	O
pp	pointer
=	O
&	O
windows	pointer
;	O
(	O
p	pointer
=	O
*	O
pp	pointer
)	O
;	O
pp	pointer
=	O
&	O
p	pointer
->	O
w_next	pointer
)	O
if	O
(	O
p	pointer
==	O
wi	pointer
)	O
break	O
;	O
ASSERT	O
(	O
p	pointer
)	O
;	O
*	O
pp	pointer
=	O
p	pointer
->	O
w_next	pointer
;	O
wi	pointer
->	O
w_inlen	int
=	O
0	int
;	O
wtab	pointer
[	O
wi	pointer
->	O
w_number	int
]	O
=	O
0	int
;	O
if	O
(	O
windows	pointer
==	O
0	int
)	O
{	O
FreeWindow	function
(	O
wi	pointer
)	O
;	O
Finit	function
(	O
0	int
)	O
;	O
}	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
gotone	int
=	O
0	int
;	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
{	O
if	O
(	O
Layer2Window	O
(	O
cv	pointer
->	O
c_layer	pointer
)	O
!=	O
wi	pointer
)	O
continue	O
;	O
SetCanvasWindow	function
(	O
cv	pointer
,	O
FindNiceWindow	function
(	O
D_other	O
,	O
0	int
)	O
)	O
;	O
gotone	int
=	O
1	int
;	O
}	O
if	O
(	O
gotone	int
)	O
{	O
if	O
(	O
wi	pointer
->	O
w_zdisplay	pointer
==	O
display	struct
)	O
{	O
D_blocked	O
=	O
0	int
;	O
D_readev	O
.	O
condpos	pointer
=	O
D_readev	O
.	O
condneg	pointer
=	O
0	int
;	O
}	O
Activate	function
(	O
-	O
1	int
)	O
;	O
}	O
}	O
for	O
(	O
lay	pointer
=	O
layouts	pointer
;	O
lay	pointer
;	O
lay	pointer
=	O
lay	pointer
->	O
lay_next	pointer
)	O
UpdateLayoutCanvas	function
(	O
&	O
lay	pointer
->	O
lay_canvas	struct
,	O
wi	pointer
)	O
;	O
FreeWindow	function
(	O
wi	pointer
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'w'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
'W'	O
)	O
;	O
WindowChanged	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
,	O
0	int
)	O
;	O
}	O
static	O
void	O
LogToggle	function
(	O
on	int
)	O
int	O
on	int
;	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
if	O
(	O
(	O
fore	pointer
->	O
w_log	pointer
!=	O
0	int
)	O
==	O
on	int
)	O
{	O
if	O
(	O
display	struct
&&	O
!	O
*	O
rc_name	pointer
)	O
Msg	function
(	O
0	int
,	O
"You are %s logging."	pointer
,	O
on	int
?	O
"already"	pointer
:	O
"not"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
fore	pointer
->	O
w_log	pointer
!=	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Logfile \"%s\" closed."	pointer
,	O
fore	pointer
->	O
w_log	pointer
->	O
name	pointer
)	O
;	O
logfclose	function
(	O
fore	pointer
->	O
w_log	pointer
)	O
;	O
fore	pointer
->	O
w_log	pointer
=	O
0	int
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'f'	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
DoStartLog	function
(	O
fore	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
{	O
Msg	function
(	O
errno	O
,	O
"Error opening logfile \"%s\""	pointer
,	O
buf	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ftell	function
(	O
fore	pointer
->	O
w_log	pointer
->	O
fp	pointer
)	O
==	O
0	int
)	O
Msg	function
(	O
0	int
,	O
"Creating logfile \"%s\"."	pointer
,	O
fore	pointer
->	O
w_log	pointer
->	O
name	pointer
)	O
;	O
else	O
Msg	function
(	O
0	int
,	O
"Appending to logfile \"%s\"."	pointer
,	O
fore	pointer
->	O
w_log	pointer
->	O
name	pointer
)	O
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'f'	O
)	O
;	O
}	O
char	O
*	O
AddWindows	function
(	O
buf	pointer
,	O
len	int
,	O
flags	int
,	O
where	int
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
int	O
flags	int
;	O
int	O
where	int
;	O
{	O
register	O
char	O
*	O
s	pointer
,	O
*	O
ss	pointer
;	O
register	O
struct	O
win	struct
*	O
*	O
pp	pointer
,	O
*	O
p	pointer
;	O
register	O
char	O
*	O
cmd	array
;	O
int	O
l	int
;	O
s	pointer
=	O
ss	pointer
=	O
buf	pointer
;	O
if	O
(	O
(	O
flags	int
&	O
8	int
)	O
&&	O
where	int
<	O
0	int
)	O
{	O
*	O
s	pointer
=	O
0	int
;	O
return	O
ss	pointer
;	O
}	O
for	O
(	O
pp	pointer
=	O
(	O
(	O
flags	int
&	O
4	int
)	O
&&	O
where	int
>=	O
0	int
)	O
?	O
wtab	pointer
+	O
where	int
+	O
1	int
:	O
wtab	pointer
;	O
pp	pointer
<	O
wtab	pointer
+	O
maxwin	int
;	O
pp	pointer
++	O
)	O
{	O
int	O
rend	int
=	O
-	O
1	int
;	O
if	O
(	O
pp	pointer
-	O
wtab	pointer
==	O
where	int
&&	O
ss	pointer
==	O
buf	pointer
)	O
ss	pointer
=	O
s	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
*	O
pp	pointer
)	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
(	O
flags	int
&	O
1	int
)	O
&&	O
display	struct
&&	O
p	pointer
==	O
D_fore	O
)	O
continue	O
;	O
if	O
(	O
display	struct
&&	O
D_fore	O
&&	O
D_fore	O
->	O
w_group	pointer
!=	O
p	pointer
->	O
w_group	pointer
)	O
continue	O
;	O
cmd	array
=	O
p	pointer
->	O
w_title	pointer
;	O
l	int
=	O
strlen	function
(	O
cmd	array
)	O
;	O
if	O
(	O
l	int
>	O
20	int
)	O
l	int
=	O
20	int
;	O
if	O
(	O
s	pointer
-	O
buf	pointer
+	O
l	int
>	O
len	int
-	O
24	int
)	O
break	O
;	O
if	O
(	O
s	pointer
>	O
buf	pointer
||	O
(	O
flags	int
&	O
4	int
)	O
)	O
{	O
*	O
s	pointer
++	O
=	O
' '	O
;	O
*	O
s	pointer
++	O
=	O
' '	O
;	O
}	O
if	O
(	O
p	pointer
->	O
w_number	int
==	O
where	int
)	O
{	O
ss	pointer
=	O
s	pointer
;	O
if	O
(	O
flags	int
&	O
8	int
)	O
break	O
;	O
}	O
if	O
(	O
!	O
(	O
flags	int
&	O
4	int
)	O
||	O
where	int
<	O
0	int
||	O
(	O
(	O
flags	int
&	O
4	int
)	O
&&	O
where	int
<	O
p	pointer
->	O
w_number	int
)	O
)	O
{	O
if	O
(	O
p	pointer
->	O
w_monitor	int
==	O
MON_DONE	int
&&	O
renditions	array
[	O
REND_MONITOR	int
]	O
!=	O
-	O
1	int
)	O
rend	int
=	O
renditions	array
[	O
REND_MONITOR	int
]	O
;	O
else	O
if	O
(	O
(	O
p	pointer
->	O
w_bell	int
==	O
BELL_DONE	int
||	O
p	pointer
->	O
w_bell	int
==	O
BELL_FOUND	int
)	O
&&	O
renditions	array
[	O
REND_BELL	int
]	O
!=	O
-	O
1	int
)	O
rend	int
=	O
renditions	array
[	O
REND_BELL	int
]	O
;	O
else	O
if	O
(	O
(	O
p	pointer
->	O
w_silence	int
==	O
SILENCE_FOUND	int
||	O
p	pointer
->	O
w_silence	int
==	O
SILENCE_DONE	int
)	O
&&	O
renditions	array
[	O
REND_SILENCE	int
]	O
!=	O
-	O
1	int
)	O
rend	int
=	O
renditions	array
[	O
REND_SILENCE	int
]	O
;	O
}	O
if	O
(	O
rend	int
!=	O
-	O
1	int
)	O
AddWinMsgRend	function
(	O
s	pointer
,	O
rend	int
)	O
;	O
sprintf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
p	pointer
->	O
w_number	int
)	O
;	O
s	pointer
+=	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
display	struct
&&	O
p	pointer
==	O
D_fore	O
)	O
*	O
s	pointer
++	O
=	O
'*'	O
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
2	int
)	O
)	O
{	O
if	O
(	O
display	struct
&&	O
p	pointer
==	O
D_other	O
)	O
*	O
s	pointer
++	O
=	O
'-'	O
;	O
s	pointer
=	O
AddWindowFlags	function
(	O
s	pointer
,	O
len	int
,	O
p	pointer
)	O
;	O
}	O
*	O
s	pointer
++	O
=	O
' '	O
;	O
strncpy	function
(	O
s	pointer
,	O
cmd	array
,	O
l	int
)	O
;	O
s	pointer
+=	O
l	int
;	O
if	O
(	O
rend	int
!=	O
-	O
1	int
)	O
AddWinMsgRend	function
(	O
s	pointer
,	O
-	O
1	int
)	O
;	O
}	O
*	O
s	pointer
=	O
0	int
;	O
return	O
ss	pointer
;	O
}	O
char	O
*	O
AddWindowFlags	function
(	O
buf	pointer
,	O
len	int
,	O
p	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
struct	O
win	struct
*	O
p	pointer
;	O
{	O
char	O
*	O
s	pointer
=	O
buf	pointer
;	O
if	O
(	O
p	pointer
==	O
0	int
||	O
len	int
<	O
12	int
)	O
{	O
*	O
s	pointer
=	O
0	int
;	O
return	O
s	pointer
;	O
}	O
if	O
(	O
p	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
&&	O
p	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
->	O
c_lnext	pointer
)	O
*	O
s	pointer
++	O
=	O
'&'	O
;	O
if	O
(	O
p	pointer
->	O
w_monitor	int
==	O
MON_DONE	int
&&	O
display	struct
&&	O
(	O
ACLBYTE	O
(	O
p	pointer
->	O
w_mon_notify	pointer
,	O
D_user	O
->	O
u_id	int
)	O
&	O
ACLBIT	O
(	O
D_user	O
->	O
u_id	int
)	O
)	O
)	O
*	O
s	pointer
++	O
=	O
'@'	O
;	O
if	O
(	O
p	pointer
->	O
w_bell	int
==	O
BELL_DONE	int
)	O
*	O
s	pointer
++	O
=	O
'!'	O
;	O
if	O
(	O
p	pointer
->	O
w_slot	pointer
!=	O
(	O
slot_t	pointer
)	O
0	int
&&	O
p	pointer
->	O
w_slot	pointer
!=	O
(	O
slot_t	pointer
)	O
-	O
1	int
)	O
*	O
s	pointer
++	O
=	O
'$'	O
;	O
if	O
(	O
p	pointer
->	O
w_log	pointer
!=	O
0	int
)	O
{	O
strcpy	function
(	O
s	pointer
,	O
"(L)"	pointer
)	O
;	O
s	pointer
+=	O
3	int
;	O
}	O
if	O
(	O
p	pointer
->	O
w_ptyfd	int
<	O
0	int
&&	O
p	pointer
->	O
w_type	int
!=	O
W_TYPE_GROUP	int
)	O
*	O
s	pointer
++	O
=	O
'Z'	O
;	O
*	O
s	pointer
=	O
0	int
;	O
return	O
s	pointer
;	O
}	O
char	O
*	O
AddOtherUsers	function
(	O
buf	pointer
,	O
len	int
,	O
p	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
struct	O
win	struct
*	O
p	pointer
;	O
{	O
struct	O
display	struct
*	O
d	int
,	O
*	O
olddisplay	pointer
=	O
display	struct
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
char	O
*	O
s	pointer
;	O
int	O
l	int
;	O
s	pointer
=	O
buf	pointer
;	O
for	O
(	O
display	struct
=	O
displays	pointer
;	O
display	struct
;	O
display	struct
=	O
display	struct
->	O
d_next	pointer
)	O
{	O
if	O
(	O
olddisplay	pointer
&&	O
D_user	O
==	O
olddisplay	pointer
->	O
d_user	pointer
)	O
continue	O
;	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
if	O
(	O
Layer2Window	O
(	O
cv	pointer
->	O
c_layer	pointer
)	O
==	O
p	pointer
)	O
break	O
;	O
if	O
(	O
!	O
cv	pointer
)	O
continue	O
;	O
for	O
(	O
d	int
=	O
displays	pointer
;	O
d	int
&&	O
d	int
!=	O
display	struct
;	O
d	int
=	O
d	int
->	O
d_next	pointer
)	O
if	O
(	O
D_user	O
==	O
d	int
->	O
d_user	pointer
)	O
break	O
;	O
if	O
(	O
d	int
&&	O
d	int
!=	O
display	struct
)	O
continue	O
;	O
if	O
(	O
len	int
>	O
1	int
&&	O
s	pointer
!=	O
buf	pointer
)	O
{	O
*	O
s	pointer
++	O
=	O
','	O
;	O
len	int
--	O
;	O
}	O
l	int
=	O
strlen	function
(	O
D_user	O
->	O
u_name	array
)	O
;	O
if	O
(	O
l	int
+	O
1	int
>	O
len	int
)	O
break	O
;	O
strcpy	function
(	O
s	pointer
,	O
D_user	O
->	O
u_name	array
)	O
;	O
s	pointer
+=	O
l	int
;	O
len	int
-=	O
l	int
;	O
}	O
*	O
s	pointer
=	O
0	int
;	O
display	struct
=	O
olddisplay	pointer
;	O
return	O
s	pointer
;	O
}	O
void	O
ShowWindows	function
(	O
where	int
)	O
int	O
where	int
;	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
char	O
*	O
s	pointer
,	O
*	O
ss	pointer
;	O
if	O
(	O
display	struct
&&	O
where	int
==	O
-	O
1	int
&&	O
D_fore	O
)	O
where	int
=	O
D_fore	O
->	O
w_number	int
;	O
ss	pointer
=	O
AddWindows	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
0	int
,	O
where	int
)	O
;	O
s	pointer
=	O
buf	pointer
+	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
display	struct
&&	O
ss	pointer
-	O
buf	pointer
>	O
D_width	O
/	O
2	int
)	O
{	O
ss	pointer
-=	O
D_width	O
/	O
2	int
;	O
if	O
(	O
s	pointer
-	O
ss	pointer
<	O
D_width	O
)	O
{	O
ss	pointer
=	O
s	pointer
-	O
D_width	O
;	O
if	O
(	O
ss	pointer
<	O
buf	pointer
)	O
ss	pointer
=	O
buf	pointer
;	O
}	O
}	O
else	O
ss	pointer
=	O
buf	pointer
;	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
ss	pointer
)	O
;	O
}	O
static	O
void	O
ShowWindowsX	function
(	O
str	pointer
)	O
char	O
*	O
str	pointer
;	O
{	O
int	O
i	int
;	O
debug1	O
(	O
"ShowWindowsX: string [%s]"	pointer
,	O
str	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
maxwin	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
wtab	pointer
[	O
i	int
]	O
)	O
continue	O
;	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
MakeWinMsg	function
(	O
str	pointer
,	O
wtab	pointer
[	O
i	int
]	O
,	O
'%'	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
ShowInfo	function
(	O
)	O
{	O
char	O
buf	pointer
[	O
512	int
]	O
,	O
*	O
p	pointer
;	O
register	O
struct	O
win	struct
*	O
wp	pointer
=	O
fore	pointer
;	O
register	O
int	O
i	int
;	O
if	O
(	O
wp	pointer
==	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"(%d,%d)/(%d,%d) no window"	pointer
,	O
D_x	O
+	O
1	int
,	O
D_y	O
+	O
1	int
,	O
D_width	O
,	O
D_height	O
)	O
;	O
return	O
;	O
}	O
p	pointer
=	O
buf	pointer
;	O
if	O
(	O
buf	pointer
<	O
(	O
p	pointer
+=	O
GetAnsiStatus	function
(	O
wp	pointer
,	O
p	pointer
)	O
)	O
)	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
sprintf	function
(	O
p	pointer
,	O
"(%d,%d)/(%d,%d)"	pointer
,	O
wp	pointer
->	O
w_x	O
+	O
1	int
,	O
wp	pointer
->	O
w_y	O
+	O
1	int
,	O
wp	pointer
->	O
w_width	O
,	O
wp	pointer
->	O
w_height	O
)	O
;	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
"+%d"	pointer
,	O
wp	pointer
->	O
w_histheight	int
)	O
;	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
" %c%sflow"	pointer
,	O
(	O
wp	pointer
->	O
w_flow	int
&	O
FLOW_NOW	O
)	O
?	O
'+'	O
:	O
'-'	O
,	O
(	O
wp	pointer
->	O
w_flow	int
&	O
FLOW_AUTOFLAG	O
)	O
?	O
""	pointer
:	O
(	O
(	O
wp	pointer
->	O
w_flow	int
&	O
FLOW_AUTO	O
)	O
?	O
"(+)"	pointer
:	O
"(-)"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
wp	pointer
->	O
w_wrap	int
)	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
" -wrap"	pointer
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_insert	int
)	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
" ins"	pointer
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_origin	int
)	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
" org"	pointer
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_keypad	int
)	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
" app"	pointer
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_log	pointer
)	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
" log"	pointer
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_monitor	int
!=	O
MON_OFF	int
&&	O
(	O
ACLBYTE	O
(	O
wp	pointer
->	O
w_mon_notify	pointer
,	O
D_user	O
->	O
u_id	int
)	O
&	O
ACLBIT	O
(	O
D_user	O
->	O
u_id	int
)	O
)	O
)	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
" mon"	pointer
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_mouse	int
)	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
" mouse"	pointer
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_bce	int
)	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
" bce"	pointer
)	O
;	O
if	O
(	O
!	O
wp	pointer
->	O
w_c1	int
)	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
" -c1"	pointer
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_norefresh	char
)	O
sprintf	function
(	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
,	O
" nored"	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_encoding	O
&&	O
(	O
display	struct
==	O
0	int
||	O
D_encoding	O
!=	O
wp	pointer
->	O
w_encoding	O
||	O
EncodingDefFont	function
(	O
wp	pointer
->	O
w_encoding	O
)	O
<=	O
0	int
)	O
)	O
{	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
strcpy	function
(	O
p	pointer
,	O
EncodingName	function
(	O
wp	pointer
->	O
w_encoding	O
)	O
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
}	O
if	O
(	O
wp	pointer
->	O
w_encoding	O
!=	O
UTF8	int
)	O
if	O
(	O
display	struct
&&	O
(	O
D_CC0	O
||	O
(	O
D_CS0	O
&&	O
*	O
D_CS0	O
)	O
)	O
)	O
{	O
if	O
(	O
wp	pointer
->	O
w_gr	int
==	O
2	int
)	O
{	O
sprintf	function
(	O
p	pointer
,	O
" G%c"	pointer
,	O
wp	pointer
->	O
w_Charset	int
+	O
'0'	O
)	O
;	O
if	O
(	O
wp	pointer
->	O
w_FontE	char
>=	O
' '	O
)	O
p	pointer
[	O
3	int
]	O
=	O
wp	pointer
->	O
w_FontE	char
;	O
else	O
{	O
p	pointer
[	O
3	int
]	O
=	O
'^'	O
;	O
p	pointer
[	O
4	int
]	O
=	O
wp	pointer
->	O
w_FontE	char
^	O
0x40	int
;	O
p	pointer
++	O
;	O
}	O
p	pointer
[	O
4	int
]	O
=	O
'['	O
;	O
p	pointer
++	O
;	O
}	O
else	O
if	O
(	O
wp	pointer
->	O
w_gr	int
)	O
sprintf	function
(	O
p	pointer
++	O
,	O
" G%c%c["	pointer
,	O
wp	pointer
->	O
w_Charset	int
+	O
'0'	O
,	O
wp	pointer
->	O
w_CharsetR	int
+	O
'0'	O
)	O
;	O
else	O
sprintf	function
(	O
p	pointer
,	O
" G%c["	pointer
,	O
wp	pointer
->	O
w_Charset	int
+	O
'0'	O
)	O
;	O
p	pointer
+=	O
4	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
wp	pointer
->	O
w_charsets	array
[	O
i	int
]	O
==	O
ASCII	int
)	O
*	O
p	pointer
++	O
=	O
'B'	O
;	O
else	O
if	O
(	O
wp	pointer
->	O
w_charsets	array
[	O
i	int
]	O
>=	O
' '	O
)	O
*	O
p	pointer
++	O
=	O
wp	pointer
->	O
w_charsets	array
[	O
i	int
]	O
;	O
else	O
{	O
*	O
p	pointer
++	O
=	O
'^'	O
;	O
*	O
p	pointer
++	O
=	O
wp	pointer
->	O
w_charsets	array
[	O
i	int
]	O
^	O
0x40	int
;	O
}	O
}	O
*	O
p	pointer
++	O
=	O
']'	O
;	O
*	O
p	pointer
=	O
0	int
;	O
}	O
if	O
(	O
wp	pointer
->	O
w_type	int
==	O
W_TYPE_PLAIN	int
)	O
{	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
TtyGetModemStatus	function
(	O
wp	pointer
->	O
w_ptyfd	int
,	O
p	pointer
)	O
;	O
}	O
Msg	function
(	O
0	int
,	O
"%s %d(%s)"	pointer
,	O
buf	pointer
,	O
wp	pointer
->	O
w_number	int
,	O
wp	pointer
->	O
w_title	pointer
)	O
;	O
}	O
static	O
void	O
ShowDInfo	function
(	O
)	O
{	O
char	O
buf	pointer
[	O
512	int
]	O
,	O
*	O
p	pointer
;	O
if	O
(	O
display	struct
==	O
0	int
)	O
return	O
;	O
p	pointer
=	O
buf	pointer
;	O
sprintf	function
(	O
p	pointer
,	O
"(%d,%d)"	pointer
,	O
D_width	O
,	O
D_height	O
)	O
,	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
if	O
(	O
D_encoding	O
)	O
{	O
*	O
p	pointer
++	O
=	O
' '	O
;	O
strcpy	function
(	O
p	pointer
,	O
EncodingName	function
(	O
D_encoding	O
)	O
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
}	O
if	O
(	O
D_CXT	O
)	O
{	O
strcpy	function
(	O
p	pointer
,	O
" xterm"	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
}	O
if	O
(	O
D_hascolor	O
)	O
{	O
strcpy	function
(	O
p	pointer
,	O
" color"	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
}	O
if	O
(	O
D_CG0	O
)	O
{	O
strcpy	function
(	O
p	pointer
,	O
" iso2022"	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
}	O
else	O
if	O
(	O
D_CS0	O
&&	O
*	O
D_CS0	O
)	O
{	O
strcpy	function
(	O
p	pointer
,	O
" altchar"	pointer
)	O
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
;	O
}	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
buf	pointer
)	O
;	O
}	O
static	O
void	O
AKAfin	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
len	int
&&	O
fore	pointer
)	O
ChangeAKA	function
(	O
fore	pointer
,	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
enter_window_name_mode	int
=	O
0	int
;	O
}	O
static	O
void	O
InputAKA	function
(	O
)	O
{	O
char	O
*	O
s	pointer
,	O
*	O
ss	pointer
;	O
int	O
n	int
;	O
if	O
(	O
enter_window_name_mode	int
==	O
1	int
)	O
return	O
;	O
enter_window_name_mode	int
=	O
1	int
;	O
Input	function
(	O
"Set window's title to: "	pointer
,	O
sizeof	O
(	O
fore	pointer
->	O
w_akabuf	array
)	O
-	O
1	int
,	O
INP_COOKED	int
,	O
AKAfin	function
,	O
NULL	O
,	O
0	int
)	O
;	O
s	pointer
=	O
fore	pointer
->	O
w_title	pointer
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
;	O
for	O
(	O
;	O
*	O
s	pointer
;	O
s	pointer
++	O
)	O
{	O
if	O
(	O
(	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
s	pointer
&	O
0x7f	int
)	O
<	O
0x20	int
||	O
*	O
s	pointer
==	O
0x7f	int
)	O
continue	O
;	O
ss	pointer
=	O
s	pointer
;	O
n	int
=	O
1	int
;	O
LayProcess	O
(	O
&	O
ss	pointer
,	O
&	O
n	int
)	O
;	O
}	O
}	O
static	O
void	O
Colonfin	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
char	O
mbuf	array
[	O
256	int
]	O
;	O
RemoveStatus	function
(	O
)	O
;	O
if	O
(	O
buf	pointer
[	O
len	int
]	O
==	O
'\t'	O
)	O
{	O
int	O
m	union
,	O
x	int
;	O
int	O
l	int
=	O
0	int
,	O
r	int
=	O
RC_LAST	int
;	O
int	O
showmessage	int
=	O
0	int
;	O
char	O
*	O
s	pointer
=	O
buf	pointer
;	O
while	O
(	O
*	O
s	pointer
&&	O
s	pointer
-	O
buf	pointer
<	O
len	int
)	O
if	O
(	O
*	O
s	pointer
++	O
==	O
' '	O
)	O
return	O
;	O
if	O
(	O
display	struct
&&	O
(	O
captionalways	int
||	O
D_has_hstatus	O
==	O
HSTATUS_LASTLINE	int
||	O
(	O
D_canvas	O
.	O
c_slperp	pointer
&&	O
D_canvas	O
.	O
c_slperp	pointer
->	O
c_slnext	pointer
)	O
)	O
)	O
showmessage	int
=	O
1	int
;	O
while	O
(	O
l	int
<=	O
r	int
)	O
{	O
m	union
=	O
(	O
l	int
+	O
r	int
)	O
/	O
2	int
;	O
x	int
=	O
strncmp	function
(	O
buf	pointer
,	O
comms	array
[	O
m	union
]	O
.	O
name	pointer
,	O
len	int
)	O
;	O
if	O
(	O
x	int
>	O
0	int
)	O
l	int
=	O
m	union
+	O
1	int
;	O
else	O
if	O
(	O
x	int
<	O
0	int
)	O
r	int
=	O
m	union
-	O
1	int
;	O
else	O
{	O
s	pointer
=	O
mbuf	array
;	O
for	O
(	O
l	int
=	O
m	union
-	O
1	int
;	O
l	int
>=	O
0	int
&&	O
strncmp	function
(	O
buf	pointer
,	O
comms	array
[	O
l	int
]	O
.	O
name	pointer
,	O
len	int
)	O
==	O
0	int
;	O
l	int
--	O
)	O
;	O
for	O
(	O
m	union
=	O
++	O
l	int
;	O
m	union
<=	O
r	int
&&	O
strncmp	function
(	O
buf	pointer
,	O
comms	array
[	O
m	union
]	O
.	O
name	pointer
,	O
len	int
)	O
==	O
0	int
&&	O
s	pointer
-	O
mbuf	array
<	O
sizeof	O
(	O
mbuf	array
)	O
;	O
m	union
++	O
)	O
s	pointer
+=	O
snprintf	function
(	O
s	pointer
,	O
sizeof	O
(	O
mbuf	array
)	O
-	O
(	O
s	pointer
-	O
mbuf	array
)	O
,	O
" %s"	pointer
,	O
comms	array
[	O
m	union
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
l	int
<	O
m	union
-	O
1	int
)	O
{	O
if	O
(	O
showmessage	int
)	O
Msg	function
(	O
0	int
,	O
"Possible commands:%s"	pointer
,	O
mbuf	array
)	O
;	O
}	O
else	O
{	O
s	pointer
=	O
mbuf	array
;	O
len	int
=	O
snprintf	function
(	O
mbuf	array
,	O
sizeof	O
(	O
mbuf	array
)	O
,	O
"%s \t"	pointer
,	O
comms	array
[	O
l	int
]	O
.	O
name	pointer
+	O
len	int
)	O
;	O
if	O
(	O
len	int
>	O
0	int
&&	O
len	int
<	O
sizeof	O
(	O
mbuf	array
)	O
)	O
LayProcess	O
(	O
&	O
s	pointer
,	O
&	O
len	int
)	O
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
l	int
>	O
r	int
&&	O
showmessage	int
)	O
Msg	function
(	O
0	int
,	O
"No commands matching '%*s'"	pointer
,	O
len	int
,	O
buf	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
len	int
||	O
buf	pointer
[	O
len	int
]	O
)	O
return	O
;	O
len	int
=	O
strlen	function
(	O
buf	pointer
)	O
+	O
1	int
;	O
if	O
(	O
len	int
>	O
(	O
int	O
)	O
sizeof	O
(	O
mbuf	array
)	O
)	O
RcLine	function
(	O
buf	pointer
,	O
len	int
)	O
;	O
else	O
{	O
bcopy	function
(	O
buf	pointer
,	O
mbuf	array
,	O
len	int
)	O
;	O
RcLine	function
(	O
mbuf	array
,	O
sizeof	O
mbuf	array
)	O
;	O
}	O
}	O
static	O
void	O
SelectFin	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
int	O
n	int
;	O
if	O
(	O
!	O
len	int
||	O
!	O
display	struct
)	O
return	O
;	O
if	O
(	O
len	int
==	O
1	int
&&	O
*	O
buf	pointer
==	O
'-'	O
)	O
{	O
SetForeWindow	function
(	O
(	O
struct	O
win	struct
*	O
)	O
0	int
)	O
;	O
Activate	function
(	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
n	int
=	O
WindowByNoN	function
(	O
buf	pointer
)	O
)	O
<	O
0	int
)	O
return	O
;	O
SwitchWindow	function
(	O
n	int
)	O
;	O
}	O
static	O
void	O
SelectLayoutFin	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
layout	struct
*	O
lay	pointer
;	O
if	O
(	O
!	O
len	int
||	O
!	O
display	struct
)	O
return	O
;	O
if	O
(	O
len	int
==	O
1	int
&&	O
*	O
buf	pointer
==	O
'-'	O
)	O
{	O
LoadLayout	function
(	O
(	O
struct	O
layout	struct
*	O
)	O
0	int
,	O
(	O
struct	O
canvas	struct
*	O
)	O
0	int
)	O
;	O
Activate	function
(	O
0	int
)	O
;	O
return	O
;	O
}	O
lay	pointer
=	O
FindLayout	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
!	O
lay	pointer
)	O
Msg	function
(	O
0	int
,	O
"No such layout\n"	pointer
)	O
;	O
else	O
if	O
(	O
lay	pointer
==	O
D_layout	O
)	O
Msg	function
(	O
0	int
,	O
"This IS layout %d (%s).\n"	pointer
,	O
lay	pointer
->	O
lay_number	int
,	O
lay	pointer
->	O
lay_title	pointer
)	O
;	O
else	O
{	O
LoadLayout	function
(	O
lay	pointer
,	O
&	O
D_canvas	O
)	O
;	O
Activate	function
(	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
InputSelect	function
(	O
)	O
{	O
Input	function
(	O
"Switch to window: "	pointer
,	O
20	int
,	O
INP_COOKED	int
,	O
SelectFin	function
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
static	O
char	O
setenv_var	array
[	O
31	int
]	O
;	O
static	O
void	O
SetenvFin1	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
if	O
(	O
!	O
len	int
||	O
!	O
display	struct
)	O
return	O
;	O
InputSetenv	function
(	O
buf	pointer
)	O
;	O
}	O
static	O
void	O
SetenvFin2	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
if	O
(	O
!	O
len	int
||	O
!	O
display	struct
)	O
return	O
;	O
debug2	O
(	O
"SetenvFin2: setenv '%s' '%s'\n"	pointer
,	O
setenv_var	array
,	O
buf	pointer
)	O
;	O
xsetenv	function
(	O
setenv_var	array
,	O
buf	pointer
)	O
;	O
MakeNewEnv	function
(	O
)	O
;	O
}	O
static	O
void	O
InputSetenv	function
(	O
arg	pointer
)	O
char	O
*	O
arg	pointer
;	O
{	O
static	O
char	O
setenv_buf	array
[	O
50	int
+	O
sizeof	O
(	O
setenv_var	array
)	O
]	O
;	O
if	O
(	O
arg	pointer
)	O
{	O
strncpy	function
(	O
setenv_var	array
,	O
arg	pointer
,	O
sizeof	O
(	O
setenv_var	array
)	O
-	O
1	int
)	O
;	O
sprintf	function
(	O
setenv_buf	array
,	O
"Enter value for %s: "	pointer
,	O
setenv_var	array
)	O
;	O
Input	function
(	O
setenv_buf	array
,	O
30	int
,	O
INP_COOKED	int
,	O
SetenvFin2	function
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
else	O
Input	function
(	O
"Setenv: Enter variable name: "	pointer
,	O
30	int
,	O
INP_COOKED	int
,	O
SetenvFin1	function
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
void	O
DoScreen	function
(	O
fn	pointer
,	O
av	pointer
)	O
char	O
*	O
fn	pointer
,	O
*	O
*	O
av	pointer
;	O
{	O
struct	O
NewWindow	struct
nwin	struct
;	O
register	O
int	O
num	int
;	O
char	O
buf	pointer
[	O
20	int
]	O
;	O
nwin	struct
=	O
nwin_undef	struct
;	O
while	O
(	O
av	pointer
&&	O
*	O
av	pointer
&&	O
av	pointer
[	O
0	int
]	O
[	O
0	int
]	O
==	O
'-'	O
)	O
{	O
if	O
(	O
av	pointer
[	O
0	int
]	O
[	O
1	int
]	O
==	O
'-'	O
)	O
{	O
av	pointer
++	O
;	O
break	O
;	O
}	O
switch	O
(	O
av	pointer
[	O
0	int
]	O
[	O
1	int
]	O
)	O
{	O
case	O
'f'	O
:	O
switch	O
(	O
av	pointer
[	O
0	int
]	O
[	O
2	int
]	O
)	O
{	O
case	O
'n'	O
:	O
case	O
'0'	O
:	O
nwin	struct
.	O
flowflag	int
=	O
FLOW_NOW	O
*	O
0	int
;	O
break	O
;	O
case	O
'y'	O
:	O
case	O
'1'	O
:	O
case	O
'\0'	O
:	O
nwin	struct
.	O
flowflag	int
=	O
FLOW_NOW	O
*	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
nwin	struct
.	O
flowflag	int
=	O
FLOW_AUTOFLAG	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
't'	O
:	O
if	O
(	O
av	pointer
[	O
0	int
]	O
[	O
2	int
]	O
)	O
nwin	struct
.	O
aka	pointer
=	O
&	O
av	pointer
[	O
0	int
]	O
[	O
2	int
]	O
;	O
else	O
if	O
(	O
*	O
++	O
av	pointer
)	O
nwin	struct
.	O
aka	pointer
=	O
*	O
av	pointer
;	O
else	O
--	O
av	pointer
;	O
break	O
;	O
case	O
'T'	O
:	O
if	O
(	O
av	pointer
[	O
0	int
]	O
[	O
2	int
]	O
)	O
nwin	struct
.	O
term	struct
=	O
&	O
av	pointer
[	O
0	int
]	O
[	O
2	int
]	O
;	O
else	O
if	O
(	O
*	O
++	O
av	pointer
)	O
nwin	struct
.	O
term	struct
=	O
*	O
av	pointer
;	O
else	O
--	O
av	pointer
;	O
break	O
;	O
case	O
'h'	O
:	O
if	O
(	O
av	pointer
[	O
0	int
]	O
[	O
2	int
]	O
)	O
nwin	struct
.	O
histheight	int
=	O
atoi	function
(	O
av	pointer
[	O
0	int
]	O
+	O
2	int
)	O
;	O
else	O
if	O
(	O
*	O
++	O
av	pointer
)	O
nwin	struct
.	O
histheight	int
=	O
atoi	function
(	O
*	O
av	pointer
)	O
;	O
else	O
--	O
av	pointer
;	O
break	O
;	O
case	O
'l'	O
:	O
switch	O
(	O
av	pointer
[	O
0	int
]	O
[	O
2	int
]	O
)	O
{	O
case	O
'n'	O
:	O
case	O
'0'	O
:	O
nwin	struct
.	O
lflag	int
=	O
0	int
;	O
break	O
;	O
case	O
'y'	O
:	O
case	O
'1'	O
:	O
case	O
'\0'	O
:	O
nwin	struct
.	O
lflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
nwin	struct
.	O
lflag	int
=	O
3	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
case	O
'a'	O
:	O
nwin	struct
.	O
aflag	int
=	O
1	int
;	O
break	O
;	O
case	O
'M'	O
:	O
nwin	struct
.	O
monitor	int
=	O
MON_ON	int
;	O
break	O
;	O
case	O
'L'	O
:	O
nwin	struct
.	O
Lflag	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
Msg	function
(	O
0	int
,	O
"%s: screen: invalid option -%c."	pointer
,	O
fn	pointer
,	O
av	pointer
[	O
0	int
]	O
[	O
1	int
]	O
)	O
;	O
break	O
;	O
}	O
++	O
av	pointer
;	O
}	O
if	O
(	O
av	pointer
&&	O
*	O
av	pointer
&&	O
IsNumColon	function
(	O
*	O
av	pointer
,	O
10	int
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
)	O
{	O
if	O
(	O
*	O
buf	pointer
!=	O
'\0'	O
)	O
nwin	struct
.	O
aka	pointer
=	O
buf	pointer
;	O
num	int
=	O
atoi	function
(	O
*	O
av	pointer
)	O
;	O
if	O
(	O
num	int
<	O
0	int
||	O
(	O
maxwin	int
&&	O
num	int
>	O
maxwin	int
-	O
1	int
)	O
||	O
(	O
!	O
maxwin	int
&&	O
num	int
>	O
MAXWIN	int
-	O
1	int
)	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s: illegal screen number %d."	pointer
,	O
fn	pointer
,	O
num	int
)	O
;	O
num	int
=	O
0	int
;	O
}	O
nwin	struct
.	O
StartAt	int
=	O
num	int
;	O
++	O
av	pointer
;	O
}	O
if	O
(	O
av	pointer
&&	O
*	O
av	pointer
)	O
{	O
nwin	struct
.	O
args	pointer
=	O
av	pointer
;	O
if	O
(	O
!	O
nwin	struct
.	O
aka	pointer
)	O
nwin	struct
.	O
aka	pointer
=	O
Filename	function
(	O
*	O
av	pointer
)	O
;	O
}	O
MakeWindow	function
(	O
&	O
nwin	struct
)	O
;	O
}	O
int	O
CompileKeys	function
(	O
s	pointer
,	O
sl	int
,	O
array	pointer
)	O
char	O
*	O
s	pointer
;	O
int	O
sl	int
;	O
unsigned	O
char	O
*	O
array	pointer
;	O
{	O
int	O
i	int
;	O
unsigned	O
char	O
key	int
,	O
value	int
;	O
if	O
(	O
sl	int
==	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
256	int
;	O
i	int
++	O
)	O
array	pointer
[	O
i	int
]	O
=	O
i	int
;	O
return	O
0	int
;	O
}	O
debug1	O
(	O
"CompileKeys: '%s'\n"	pointer
,	O
s	pointer
)	O
;	O
while	O
(	O
sl	int
)	O
{	O
key	int
=	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
s	pointer
++	O
;	O
if	O
(	O
*	O
s	pointer
!=	O
'='	O
||	O
sl	int
<	O
3	int
)	O
return	O
-	O
1	int
;	O
sl	int
--	O
;	O
do	O
{	O
s	pointer
++	O
;	O
sl	int
-=	O
2	int
;	O
value	int
=	O
*	O
(	O
unsigned	O
char	O
*	O
)	O
s	pointer
++	O
;	O
array	pointer
[	O
value	int
]	O
=	O
key	int
;	O
}	O
while	O
(	O
*	O
s	pointer
==	O
'='	O
&&	O
sl	int
>=	O
2	int
)	O
;	O
if	O
(	O
sl	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
*	O
s	pointer
++	O
!=	O
':'	O
)	O
return	O
-	O
1	int
;	O
sl	int
--	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
pow_detach_fn	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
debug	O
(	O
"pow_detach_fn called\n"	pointer
)	O
;	O
if	O
(	O
len	int
)	O
{	O
memset	function
(	O
buf	pointer
,	O
0	int
,	O
len	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ktab	array
[	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
*	O
buf	pointer
]	O
.	O
nr	int
!=	O
RC_POW_DETACH	int
)	O
{	O
if	O
(	O
display	struct
)	O
write	pointer
(	O
D_userfd	O
,	O
"\007"	pointer
,	O
1	int
)	O
;	O
Msg	function
(	O
0	int
,	O
"Detach aborted."	pointer
)	O
;	O
}	O
else	O
Detach	function
(	O
D_POWER	int
)	O
;	O
}	O
static	O
void	O
copy_reg_fn	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
plop	struct
*	O
pp	pointer
=	O
plop_tab	array
+	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
*	O
buf	pointer
;	O
if	O
(	O
len	int
)	O
{	O
memset	function
(	O
buf	pointer
,	O
0	int
,	O
len	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
pp	pointer
->	O
buf	pointer
)	O
free	function
(	O
pp	pointer
->	O
buf	pointer
)	O
;	O
pp	pointer
->	O
buf	pointer
=	O
0	int
;	O
pp	pointer
->	O
len	int
=	O
0	int
;	O
if	O
(	O
D_user	O
->	O
u_plop	struct
.	O
len	int
)	O
{	O
if	O
(	O
(	O
pp	pointer
->	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
D_user	O
->	O
u_plop	struct
.	O
len	int
)	O
)	O
==	O
NULL	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
return	O
;	O
}	O
bcopy	function
(	O
D_user	O
->	O
u_plop	struct
.	O
buf	pointer
,	O
pp	pointer
->	O
buf	pointer
,	O
D_user	O
->	O
u_plop	struct
.	O
len	int
)	O
;	O
}	O
pp	pointer
->	O
len	int
=	O
D_user	O
->	O
u_plop	struct
.	O
len	int
;	O
pp	pointer
->	O
enc	int
=	O
D_user	O
->	O
u_plop	struct
.	O
enc	int
;	O
Msg	function
(	O
0	int
,	O
"Copied %d characters into register %c"	pointer
,	O
D_user	O
->	O
u_plop	struct
.	O
len	int
,	O
*	O
buf	pointer
)	O
;	O
}	O
static	O
void	O
ins_reg_fn	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
plop	struct
*	O
pp	pointer
=	O
plop_tab	array
+	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
*	O
buf	pointer
;	O
if	O
(	O
len	int
)	O
{	O
memset	function
(	O
buf	pointer
,	O
0	int
,	O
len	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
fore	pointer
)	O
return	O
;	O
if	O
(	O
*	O
buf	pointer
==	O
'.'	O
)	O
Msg	function
(	O
0	int
,	O
"ins_reg_fn: Warning: pasting real register '.'!"	pointer
)	O
;	O
if	O
(	O
pp	pointer
->	O
buf	pointer
)	O
{	O
MakePaster	function
(	O
&	O
fore	pointer
->	O
w_paster	struct
,	O
pp	pointer
->	O
buf	pointer
,	O
pp	pointer
->	O
len	int
,	O
0	int
)	O
;	O
return	O
;	O
}	O
Msg	function
(	O
0	int
,	O
"Empty register."	pointer
)	O
;	O
}	O
static	O
void	O
process_fn	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
plop	struct
*	O
pp	pointer
=	O
plop_tab	array
+	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
*	O
buf	pointer
;	O
if	O
(	O
len	int
)	O
{	O
memset	function
(	O
buf	pointer
,	O
0	int
,	O
len	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
pp	pointer
->	O
buf	pointer
)	O
{	O
ProcessInput	function
(	O
pp	pointer
->	O
buf	pointer
,	O
pp	pointer
->	O
len	int
)	O
;	O
return	O
;	O
}	O
Msg	function
(	O
0	int
,	O
"Empty register."	pointer
)	O
;	O
}	O
static	O
void	O
confirm_fn	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
action	struct
act	pointer
;	O
if	O
(	O
len	int
||	O
(	O
*	O
buf	pointer
!=	O
'y'	O
&&	O
*	O
buf	pointer
!=	O
'Y'	O
)	O
)	O
{	O
memset	function
(	O
buf	pointer
,	O
0	int
,	O
len	int
)	O
;	O
return	O
;	O
}	O
act	pointer
.	O
nr	int
=	O
*	O
(	O
int	O
*	O
)	O
data	pointer
;	O
act	pointer
.	O
args	pointer
=	O
noargs	array
;	O
act	pointer
.	O
argl	pointer
=	O
0	int
;	O
act	pointer
.	O
quiet	int
=	O
0	int
;	O
DoAction	function
(	O
&	O
act	pointer
,	O
-	O
1	int
)	O
;	O
}	O
struct	O
inputsu	struct
{	O
struct	O
acluser	struct
*	O
*	O
up	pointer
;	O
char	O
name	pointer
[	O
24	int
]	O
;	O
char	O
pw1	array
[	O
130	int
]	O
;	O
char	O
pw2	array
[	O
130	int
]	O
;	O
}	O
;	O
static	O
void	O
su_fin	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
inputsu	struct
*	O
i	int
=	O
(	O
struct	O
inputsu	struct
*	O
)	O
data	pointer
;	O
char	O
*	O
p	pointer
;	O
int	O
l	int
;	O
if	O
(	O
!	O
*	O
i	int
->	O
name	pointer
)	O
{	O
p	pointer
=	O
i	int
->	O
name	pointer
;	O
l	int
=	O
sizeof	O
(	O
i	int
->	O
name	pointer
)	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
*	O
i	int
->	O
pw1	array
)	O
{	O
strcpy	function
(	O
p	pointer
=	O
i	int
->	O
pw1	array
,	O
"\377"	pointer
)	O
;	O
l	int
=	O
sizeof	O
(	O
i	int
->	O
pw1	array
)	O
-	O
1	int
;	O
}	O
else	O
{	O
strcpy	function
(	O
p	pointer
=	O
i	int
->	O
pw2	array
,	O
"\377"	pointer
)	O
;	O
l	int
=	O
sizeof	O
(	O
i	int
->	O
pw2	array
)	O
-	O
1	int
;	O
}	O
if	O
(	O
buf	pointer
&&	O
len	int
)	O
strncpy	function
(	O
p	pointer
,	O
buf	pointer
,	O
1	int
+	O
(	O
(	O
l	int
<	O
len	int
)	O
?	O
l	int
:	O
len	int
)	O
)	O
;	O
if	O
(	O
!	O
*	O
i	int
->	O
name	pointer
)	O
Input	function
(	O
"Screen User: "	pointer
,	O
sizeof	O
(	O
i	int
->	O
name	pointer
)	O
-	O
1	int
,	O
INP_COOKED	int
,	O
su_fin	function
,	O
(	O
char	O
*	O
)	O
i	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
!	O
*	O
i	int
->	O
pw1	array
)	O
Input	function
(	O
"User's UNIX Password: "	pointer
,	O
sizeof	O
(	O
i	int
->	O
pw1	array
)	O
-	O
1	int
,	O
INP_COOKED	int
|	O
INP_NOECHO	int
,	O
su_fin	function
,	O
(	O
char	O
*	O
)	O
i	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
!	O
*	O
i	int
->	O
pw2	array
)	O
Input	function
(	O
"User's Screen Password: "	pointer
,	O
sizeof	O
(	O
i	int
->	O
pw2	array
)	O
-	O
1	int
,	O
INP_COOKED	int
|	O
INP_NOECHO	int
,	O
su_fin	function
,	O
(	O
char	O
*	O
)	O
i	int
,	O
0	int
)	O
;	O
else	O
{	O
if	O
(	O
(	O
p	pointer
=	O
DoSu	function
(	O
i	int
->	O
up	pointer
,	O
i	int
->	O
name	pointer
,	O
i	int
->	O
pw2	array
,	O
i	int
->	O
pw1	array
)	O
)	O
)	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
p	pointer
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
i	int
)	O
;	O
}	O
}	O
static	O
int	O
InputSu	function
(	O
w	int
,	O
up	pointer
,	O
name	pointer
)	O
struct	O
win	struct
*	O
w	int
;	O
struct	O
acluser	struct
*	O
*	O
up	pointer
;	O
char	O
*	O
name	pointer
;	O
{	O
struct	O
inputsu	struct
*	O
i	int
;	O
if	O
(	O
!	O
(	O
i	int
=	O
(	O
struct	O
inputsu	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
inputsu	struct
)	O
)	O
)	O
)	O
return	O
-	O
1	int
;	O
i	int
->	O
up	pointer
=	O
up	pointer
;	O
if	O
(	O
name	pointer
&&	O
*	O
name	pointer
)	O
su_fin	function
(	O
name	pointer
,	O
(	O
int	O
)	O
strlen	function
(	O
name	pointer
)	O
,	O
(	O
char	O
*	O
)	O
i	int
)	O
;	O
else	O
su_fin	function
(	O
(	O
char	O
*	O
)	O
0	int
,	O
0	int
,	O
(	O
char	O
*	O
)	O
i	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
pass1	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
struct	O
acluser	struct
*	O
u	pointer
=	O
(	O
struct	O
acluser	struct
*	O
)	O
data	pointer
;	O
if	O
(	O
!	O
*	O
buf	pointer
)	O
return	O
;	O
ASSERT	O
(	O
u	pointer
)	O
;	O
if	O
(	O
u	pointer
->	O
u_password	pointer
!=	O
NullStr	array
)	O
free	function
(	O
(	O
char	O
*	O
)	O
u	pointer
->	O
u_password	pointer
)	O
;	O
u	pointer
->	O
u_password	pointer
=	O
SaveStr	function
(	O
buf	pointer
)	O
;	O
bzero	function
(	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
Input	function
(	O
"Retype new password:"	pointer
,	O
100	int
,	O
INP_NOECHO	int
,	O
pass2	function
,	O
data	pointer
,	O
0	int
)	O
;	O
}	O
static	O
void	O
pass2	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
int	O
st	pointer
;	O
char	O
salt	array
[	O
3	int
]	O
;	O
struct	O
acluser	struct
*	O
u	pointer
=	O
(	O
struct	O
acluser	struct
*	O
)	O
data	pointer
;	O
ASSERT	O
(	O
u	pointer
)	O
;	O
if	O
(	O
!	O
buf	pointer
||	O
strcmp	function
(	O
u	pointer
->	O
u_password	pointer
,	O
buf	pointer
)	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"[ Passwords don't match - checking turned off ]"	pointer
)	O
;	O
if	O
(	O
u	pointer
->	O
u_password	pointer
!=	O
NullStr	array
)	O
{	O
bzero	function
(	O
u	pointer
->	O
u_password	pointer
,	O
strlen	function
(	O
u	pointer
->	O
u_password	pointer
)	O
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
u	pointer
->	O
u_password	pointer
)	O
;	O
}	O
u	pointer
->	O
u_password	pointer
=	O
NullStr	array
;	O
}	O
else	O
if	O
(	O
u	pointer
->	O
u_password	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"[ No password - no secure ]"	pointer
)	O
;	O
if	O
(	O
buf	pointer
)	O
bzero	function
(	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
if	O
(	O
u	pointer
->	O
u_password	pointer
!=	O
NullStr	array
)	O
{	O
for	O
(	O
st	pointer
=	O
0	int
;	O
st	pointer
<	O
2	int
;	O
st	pointer
++	O
)	O
salt	array
[	O
st	pointer
]	O
=	O
'A'	O
+	O
(	O
int	O
)	O
(	O
(	O
time	struct
(	O
0	int
)	O
>>	O
6	int
*	O
st	pointer
)	O
%	O
26	int
)	O
;	O
salt	array
[	O
2	int
]	O
=	O
0	int
;	O
buf	pointer
=	O
crypt	function
(	O
u	pointer
->	O
u_password	pointer
,	O
salt	array
)	O
;	O
bzero	function
(	O
u	pointer
->	O
u_password	pointer
,	O
strlen	function
(	O
u	pointer
->	O
u_password	pointer
)	O
)	O
;	O
free	function
(	O
(	O
char	O
*	O
)	O
u	pointer
->	O
u_password	pointer
)	O
;	O
if	O
(	O
!	O
buf	pointer
)	O
{	O
Msg	function
(	O
0	int
,	O
"[ crypt() error - no secure ]"	pointer
)	O
;	O
u	pointer
->	O
u_password	pointer
=	O
NullStr	array
;	O
return	O
;	O
}	O
u	pointer
->	O
u_password	pointer
=	O
SaveStr	function
(	O
buf	pointer
)	O
;	O
bzero	function
(	O
buf	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
u	pointer
->	O
u_plop	struct
.	O
buf	pointer
)	O
UserFreeCopyBuffer	function
(	O
u	pointer
)	O
;	O
u	pointer
->	O
u_plop	struct
.	O
len	int
=	O
strlen	function
(	O
u	pointer
->	O
u_password	pointer
)	O
;	O
u	pointer
->	O
u_plop	struct
.	O
enc	int
=	O
0	int
;	O
if	O
(	O
!	O
(	O
u	pointer
->	O
u_plop	struct
.	O
buf	pointer
=	O
SaveStr	function
(	O
u	pointer
->	O
u_password	pointer
)	O
)	O
)	O
{	O
Msg	function
(	O
0	int
,	O
"%s"	pointer
,	O
strnomem	array
)	O
;	O
D_user	O
->	O
u_plop	struct
.	O
len	int
=	O
0	int
;	O
}	O
else	O
Msg	function
(	O
0	int
,	O
"[ Password moved into copybuffer ]"	pointer
)	O
;	O
}	O
}	O
static	O
int	O
digraph_find	function
(	O
buf	pointer
)	O
const	O
char	O
*	O
buf	pointer
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_DIGRAPH	int
&&	O
digraphs	array
[	O
i	int
]	O
.	O
d	int
[	O
0	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
(	O
digraphs	array
[	O
i	int
]	O
.	O
d	int
[	O
0	int
]	O
==	O
(	O
unsigned	O
char	O
)	O
buf	pointer
[	O
0	int
]	O
&&	O
digraphs	array
[	O
i	int
]	O
.	O
d	int
[	O
1	int
]	O
==	O
(	O
unsigned	O
char	O
)	O
buf	pointer
[	O
1	int
]	O
)	O
||	O
(	O
digraphs	array
[	O
i	int
]	O
.	O
d	int
[	O
0	int
]	O
==	O
(	O
unsigned	O
char	O
)	O
buf	pointer
[	O
1	int
]	O
&&	O
digraphs	array
[	O
i	int
]	O
.	O
d	int
[	O
1	int
]	O
==	O
(	O
unsigned	O
char	O
)	O
buf	pointer
[	O
0	int
]	O
)	O
)	O
break	O
;	O
return	O
i	int
;	O
}	O
static	O
void	O
digraph_fn	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
int	O
ch	int
,	O
i	int
,	O
x	int
;	O
ch	int
=	O
buf	pointer
[	O
len	int
]	O
;	O
if	O
(	O
ch	int
)	O
{	O
buf	pointer
[	O
len	int
+	O
1	int
]	O
=	O
ch	int
;	O
if	O
(	O
ch	int
<	O
' '	O
||	O
ch	int
==	O
'\177'	O
)	O
return	O
;	O
if	O
(	O
len	int
>=	O
1	int
&&	O
(	O
(	O
*	O
buf	pointer
==	O
'U'	O
&&	O
buf	pointer
[	O
1	int
]	O
==	O
'+'	O
)	O
||	O
(	O
*	O
buf	pointer
==	O
'0'	O
&&	O
(	O
buf	pointer
[	O
1	int
]	O
==	O
'x'	O
||	O
buf	pointer
[	O
1	int
]	O
==	O
'X'	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
len	int
==	O
1	int
)	O
return	O
;	O
if	O
(	O
(	O
ch	int
<	O
'0'	O
||	O
ch	int
>	O
'9'	O
)	O
&&	O
(	O
ch	int
<	O
'a'	O
||	O
ch	int
>	O
'f'	O
)	O
&&	O
(	O
ch	int
<	O
'A'	O
||	O
ch	int
>	O
'F'	O
)	O
)	O
{	O
buf	pointer
[	O
len	int
]	O
=	O
'\034'	O
;	O
return	O
;	O
}	O
if	O
(	O
len	int
==	O
(	O
*	O
buf	pointer
==	O
'U'	O
?	O
5	int
:	O
3	int
)	O
)	O
buf	pointer
[	O
len	int
]	O
=	O
'\n'	O
;	O
return	O
;	O
}	O
if	O
(	O
len	int
&&	O
*	O
buf	pointer
==	O
'0'	O
)	O
{	O
if	O
(	O
ch	int
<	O
'0'	O
||	O
ch	int
>	O
'7'	O
)	O
{	O
buf	pointer
[	O
len	int
]	O
=	O
'\034'	O
;	O
return	O
;	O
}	O
if	O
(	O
len	int
==	O
3	int
)	O
buf	pointer
[	O
len	int
]	O
=	O
'\n'	O
;	O
return	O
;	O
}	O
if	O
(	O
len	int
==	O
1	int
)	O
buf	pointer
[	O
len	int
]	O
=	O
'\n'	O
;	O
return	O
;	O
}	O
if	O
(	O
len	int
<	O
1	int
)	O
return	O
;	O
if	O
(	O
buf	pointer
[	O
len	int
+	O
1	int
]	O
)	O
{	O
buf	pointer
[	O
len	int
]	O
=	O
buf	pointer
[	O
len	int
+	O
1	int
]	O
;	O
len	int
++	O
;	O
}	O
if	O
(	O
len	int
<	O
2	int
)	O
return	O
;	O
if	O
(	O
!	O
parse_input_int	function
(	O
buf	pointer
,	O
len	int
,	O
&	O
x	int
)	O
)	O
{	O
i	int
=	O
digraph_find	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
(	O
x	int
=	O
digraphs	array
[	O
i	int
]	O
.	O
value	int
)	O
<=	O
0	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"Unknown digraph"	pointer
)	O
;	O
return	O
;	O
}	O
}	O
i	int
=	O
1	int
;	O
*	O
buf	pointer
=	O
x	int
;	O
if	O
(	O
flayer	pointer
->	O
l_encoding	int
==	O
UTF8	int
)	O
i	int
=	O
ToUtf8	function
(	O
buf	pointer
,	O
x	int
)	O
;	O
while	O
(	O
i	int
)	O
LayProcess	O
(	O
&	O
buf	pointer
,	O
&	O
i	int
)	O
;	O
}	O
int	O
StuffKey	function
(	O
i	int
)	O
int	O
i	int
;	O
{	O
struct	O
action	struct
*	O
act	pointer
;	O
int	O
discard	int
=	O
0	int
;	O
int	O
keyno	int
=	O
i	int
;	O
debug1	O
(	O
"StuffKey #%d"	pointer
,	O
i	int
)	O
;	O
if	O
(	O
i	int
<	O
KMAP_KEYS	O
&&	O
D_ESCseen	O
)	O
{	O
struct	O
action	struct
*	O
act	pointer
=	O
&	O
D_ESCseen	O
[	O
i	int
+	O
256	int
]	O
;	O
if	O
(	O
act	pointer
->	O
nr	int
!=	O
RC_ILLEGAL	O
)	O
{	O
D_ESCseen	O
=	O
0	int
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'E'	O
)	O
;	O
DoAction	function
(	O
act	pointer
,	O
i	int
+	O
256	int
)	O
;	O
return	O
0	int
;	O
}	O
discard	int
=	O
1	int
;	O
}	O
if	O
(	O
i	int
>=	O
T_CURSOR	int
-	O
T_CAPS	int
&&	O
i	int
<	O
T_KEYPAD	int
-	O
T_CAPS	int
&&	O
D_cursorkeys	O
)	O
i	int
+=	O
T_OCAPS	int
-	O
T_CURSOR	int
;	O
else	O
if	O
(	O
i	int
>=	O
T_KEYPAD	int
-	O
T_CAPS	int
&&	O
i	int
<	O
T_OCAPS	int
-	O
T_CAPS	int
&&	O
D_keypad	O
)	O
i	int
+=	O
T_OCAPS	int
-	O
T_CURSOR	int
;	O
debug1	O
(	O
" - action %d\n"	pointer
,	O
i	int
)	O
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
fore	pointer
=	O
D_fore	O
;	O
act	pointer
=	O
0	int
;	O
if	O
(	O
flayer	pointer
&&	O
flayer	pointer
->	O
l_mode	int
==	O
1	int
)	O
act	pointer
=	O
i	int
<	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
?	O
&	O
mmtab	array
[	O
i	int
]	O
:	O
&	O
kmap_exts	pointer
[	O
i	int
-	O
(	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
)	O
]	O
.	O
mm	struct
;	O
if	O
(	O
(	O
!	O
act	pointer
||	O
act	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
&&	O
!	O
D_mapdefault	O
)	O
act	pointer
=	O
i	int
<	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
?	O
&	O
umtab	array
[	O
i	int
]	O
:	O
&	O
kmap_exts	pointer
[	O
i	int
-	O
(	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
)	O
]	O
.	O
um	struct
;	O
if	O
(	O
!	O
act	pointer
||	O
act	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
act	pointer
=	O
i	int
<	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
?	O
&	O
dmtab	array
[	O
i	int
]	O
:	O
&	O
kmap_exts	pointer
[	O
i	int
-	O
(	O
KMAP_KEYS	O
+	O
KMAP_AKEYS	O
)	O
]	O
.	O
dm	struct
;	O
if	O
(	O
discard	int
&&	O
(	O
!	O
act	pointer
||	O
act	pointer
->	O
nr	int
!=	O
RC_COMMAND	int
)	O
)	O
{	O
if	O
(	O
D_tcs	O
[	O
keyno	int
+	O
T_CAPS	int
]	O
.	O
str	pointer
&&	O
strlen	function
(	O
D_tcs	O
[	O
keyno	int
+	O
T_CAPS	int
]	O
.	O
str	pointer
)	O
==	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
D_ESCseen	O
)	O
{	O
D_ESCseen	O
=	O
0	int
;	O
WindowChanged	function
(	O
fore	pointer
,	O
'E'	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
D_mapdefault	O
=	O
0	int
;	O
if	O
(	O
act	pointer
==	O
0	int
||	O
act	pointer
->	O
nr	int
==	O
RC_ILLEGAL	O
)	O
return	O
-	O
1	int
;	O
DoAction	function
(	O
act	pointer
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
IsOnDisplay	function
(	O
wi	pointer
)	O
struct	O
win	struct
*	O
wi	pointer
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
for	O
(	O
cv	pointer
=	O
D_cvlist	O
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_next	pointer
)	O
if	O
(	O
Layer2Window	O
(	O
cv	pointer
->	O
c_layer	pointer
)	O
==	O
wi	pointer
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
struct	O
win	struct
*	O
FindNiceWindow	function
(	O
wi	pointer
,	O
presel	pointer
)	O
struct	O
win	struct
*	O
wi	pointer
;	O
char	O
*	O
presel	pointer
;	O
{	O
int	O
i	int
;	O
debug2	O
(	O
"FindNiceWindow %d %s\n"	pointer
,	O
wi	pointer
?	O
wi	pointer
->	O
w_number	int
:	O
-	O
1	int
,	O
presel	pointer
?	O
presel	pointer
:	O
"NULL"	pointer
)	O
;	O
if	O
(	O
presel	pointer
)	O
{	O
i	int
=	O
WindowByNoN	function
(	O
presel	pointer
)	O
;	O
if	O
(	O
i	int
>=	O
0	int
)	O
wi	pointer
=	O
wtab	pointer
[	O
i	int
]	O
;	O
}	O
if	O
(	O
!	O
display	struct
)	O
return	O
wi	pointer
;	O
if	O
(	O
wi	pointer
&&	O
AclCheckPermWin	function
(	O
D_user	O
,	O
ACL_READ	int
,	O
wi	pointer
)	O
)	O
wi	pointer
=	O
0	int
;	O
if	O
(	O
!	O
wi	pointer
||	O
(	O
IsOnDisplay	function
(	O
wi	pointer
)	O
&&	O
!	O
presel	pointer
)	O
)	O
{	O
wi	pointer
=	O
0	int
;	O
for	O
(	O
wi	pointer
=	O
windows	pointer
;	O
wi	pointer
;	O
wi	pointer
=	O
wi	pointer
->	O
w_next	pointer
)	O
if	O
(	O
!	O
wi	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
&&	O
!	O
AclCheckPermWin	function
(	O
D_user	O
,	O
ACL_WRITE	int
,	O
wi	pointer
)	O
)	O
break	O
;	O
if	O
(	O
!	O
wi	pointer
)	O
for	O
(	O
wi	pointer
=	O
windows	pointer
;	O
wi	pointer
;	O
wi	pointer
=	O
wi	pointer
->	O
w_next	pointer
)	O
if	O
(	O
wi	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
&&	O
!	O
IsOnDisplay	function
(	O
wi	pointer
)	O
&&	O
!	O
AclCheckPermWin	function
(	O
D_user	O
,	O
ACL_WRITE	int
,	O
wi	pointer
)	O
)	O
break	O
;	O
if	O
(	O
!	O
wi	pointer
)	O
for	O
(	O
wi	pointer
=	O
windows	pointer
;	O
wi	pointer
;	O
wi	pointer
=	O
wi	pointer
->	O
w_next	pointer
)	O
if	O
(	O
!	O
wi	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
&&	O
!	O
AclCheckPermWin	function
(	O
D_user	O
,	O
ACL_READ	int
,	O
wi	pointer
)	O
)	O
break	O
;	O
if	O
(	O
!	O
wi	pointer
)	O
for	O
(	O
wi	pointer
=	O
windows	pointer
;	O
wi	pointer
;	O
wi	pointer
=	O
wi	pointer
->	O
w_next	pointer
)	O
if	O
(	O
wi	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
&&	O
!	O
IsOnDisplay	function
(	O
wi	pointer
)	O
&&	O
!	O
AclCheckPermWin	function
(	O
D_user	O
,	O
ACL_READ	int
,	O
wi	pointer
)	O
)	O
break	O
;	O
if	O
(	O
!	O
wi	pointer
)	O
for	O
(	O
wi	pointer
=	O
windows	pointer
;	O
wi	pointer
;	O
wi	pointer
=	O
wi	pointer
->	O
w_next	pointer
)	O
if	O
(	O
!	O
wi	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
)	O
break	O
;	O
if	O
(	O
!	O
wi	pointer
)	O
for	O
(	O
wi	pointer
=	O
windows	pointer
;	O
wi	pointer
;	O
wi	pointer
=	O
wi	pointer
->	O
w_next	pointer
)	O
if	O
(	O
wi	pointer
->	O
w_layer	struct
.	O
l_cvlist	pointer
&&	O
!	O
IsOnDisplay	function
(	O
wi	pointer
)	O
)	O
break	O
;	O
}	O
if	O
(	O
wi	pointer
&&	O
AclCheckPermWin	function
(	O
D_user	O
,	O
ACL_READ	int
,	O
wi	pointer
)	O
)	O
wi	pointer
=	O
0	int
;	O
return	O
wi	pointer
;	O
}	O
static	O
int	O
CalcSlicePercent	function
(	O
cv	pointer
,	O
percent	int
)	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
int	O
percent	int
;	O
{	O
int	O
w	int
,	O
wsum	int
,	O
up	pointer
;	O
if	O
(	O
!	O
cv	pointer
||	O
!	O
cv	pointer
->	O
c_slback	pointer
)	O
return	O
percent	int
;	O
up	pointer
=	O
CalcSlicePercent	function
(	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slback	pointer
,	O
percent	int
)	O
;	O
w	int
=	O
cv	pointer
->	O
c_slweight	int
;	O
for	O
(	O
cv	pointer
=	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
,	O
wsum	int
=	O
0	int
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
)	O
wsum	int
+=	O
cv	pointer
->	O
c_slweight	int
;	O
if	O
(	O
wsum	int
==	O
0	int
)	O
return	O
0	int
;	O
return	O
(	O
up	pointer
*	O
w	int
)	O
/	O
wsum	int
;	O
}	O
static	O
int	O
ChangeCanvasSize	function
(	O
fcv	pointer
,	O
abs	function
,	O
diff	int
,	O
gflag	int
,	O
percent	int
)	O
struct	O
canvas	struct
*	O
fcv	pointer
;	O
int	O
abs	function
;	O
int	O
diff	int
;	O
int	O
gflag	int
;	O
int	O
percent	int
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
int	O
done	int
,	O
have	int
,	O
m	union
,	O
dir	pointer
;	O
debug3	O
(	O
"ChangeCanvasSize abs %d diff %d percent=%d\n"	pointer
,	O
abs	function
,	O
diff	int
,	O
percent	int
)	O
;	O
if	O
(	O
abs	function
==	O
0	int
&&	O
diff	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
abs	function
==	O
2	int
)	O
{	O
if	O
(	O
diff	int
==	O
0	int
)	O
fcv	pointer
->	O
c_slweight	int
=	O
0	int
;	O
else	O
{	O
for	O
(	O
cv	pointer
=	O
fcv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
)	O
cv	pointer
->	O
c_slweight	int
=	O
0	int
;	O
fcv	pointer
->	O
c_slweight	int
=	O
1	int
;	O
cv	pointer
=	O
fcv	pointer
->	O
c_slback	pointer
->	O
c_slback	pointer
;	O
if	O
(	O
gflag	int
&&	O
cv	pointer
&&	O
cv	pointer
->	O
c_slback	pointer
)	O
ChangeCanvasSize	function
(	O
cv	pointer
,	O
abs	function
,	O
diff	int
,	O
gflag	int
,	O
percent	int
)	O
;	O
}	O
return	O
diff	int
;	O
}	O
if	O
(	O
abs	function
)	O
{	O
if	O
(	O
diff	int
<	O
0	int
)	O
diff	int
=	O
0	int
;	O
if	O
(	O
percent	int
&&	O
diff	int
>	O
percent	int
)	O
diff	int
=	O
percent	int
;	O
}	O
if	O
(	O
percent	int
)	O
{	O
int	O
wsum	int
,	O
up	pointer
;	O
for	O
(	O
cv	pointer
=	O
fcv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
,	O
wsum	int
=	O
0	int
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
)	O
wsum	int
+=	O
cv	pointer
->	O
c_slweight	int
;	O
if	O
(	O
wsum	int
)	O
{	O
up	pointer
=	O
gflag	int
?	O
CalcSlicePercent	function
(	O
fcv	pointer
->	O
c_slback	pointer
->	O
c_slback	pointer
,	O
percent	int
)	O
:	O
percent	int
;	O
debug3	O
(	O
"up=%d, wsum=%d percent=%d\n"	pointer
,	O
up	pointer
,	O
wsum	int
,	O
percent	int
)	O
;	O
if	O
(	O
wsum	int
<	O
1000	int
)	O
{	O
int	O
scale	int
=	O
wsum	int
<	O
10	int
?	O
1000	int
:	O
100	int
;	O
for	O
(	O
cv	pointer
=	O
fcv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
)	O
cv	pointer
->	O
c_slweight	int
*=	O
scale	int
;	O
wsum	int
*=	O
scale	int
;	O
debug1	O
(	O
"scaled wsum to %d\n"	pointer
,	O
wsum	int
)	O
;	O
}	O
for	O
(	O
cv	pointer
=	O
fcv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
)	O
{	O
if	O
(	O
cv	pointer
->	O
c_slweight	int
)	O
{	O
cv	pointer
->	O
c_slweight	int
=	O
(	O
cv	pointer
->	O
c_slweight	int
*	O
up	pointer
)	O
/	O
percent	int
;	O
if	O
(	O
cv	pointer
->	O
c_slweight	int
==	O
0	int
)	O
cv	pointer
->	O
c_slweight	int
=	O
1	int
;	O
}	O
debug1	O
(	O
"  - weight %d\n"	pointer
,	O
cv	pointer
->	O
c_slweight	int
)	O
;	O
}	O
diff	int
=	O
(	O
diff	int
*	O
wsum	int
)	O
/	O
percent	int
;	O
percent	int
=	O
wsum	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
abs	function
&&	O
diff	int
==	O
(	O
fcv	pointer
->	O
c_slorient	int
==	O
SLICE_VERT	O
?	O
fcv	pointer
->	O
c_ye	int
-	O
fcv	pointer
->	O
c_ys	int
+	O
2	int
:	O
fcv	pointer
->	O
c_xe	int
-	O
fcv	pointer
->	O
c_xs	int
+	O
2	int
)	O
)	O
return	O
0	int
;	O
for	O
(	O
cv	pointer
=	O
fcv	pointer
->	O
c_slback	pointer
->	O
c_slperp	pointer
;	O
cv	pointer
;	O
cv	pointer
=	O
cv	pointer
->	O
c_slnext	pointer
)	O
{	O
cv	pointer
->	O
c_slweight	int
=	O
cv	pointer
->	O
c_slorient	int
==	O
SLICE_VERT	O
?	O
cv	pointer
->	O
c_ye	int
-	O
cv	pointer
->	O
c_ys	int
+	O
2	int
:	O
cv	pointer
->	O
c_xe	int
-	O
cv	pointer
->	O
c_xs	int
+	O
2	int
;	O
debug1	O
(	O
"  - weight %d\n"	pointer
,	O
cv	pointer
->	O
c_slweight	int
)	O
;	O
}	O
}	O
if	O
(	O
abs	function
)	O
diff	int
=	O
diff	int
-	O
fcv	pointer
->	O
c_slweight	int
;	O
debug1	O
(	O
"diff = %d\n"	pointer
,	O
diff	int
)	O
;	O
if	O
(	O
diff	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
diff	int
<	O
0	int
)	O
{	O
cv	pointer
=	O
fcv	pointer
->	O
c_slnext	pointer
?	O
fcv	pointer
->	O
c_slnext	pointer
:	O
fcv	pointer
->	O
c_slprev	pointer
;	O
fcv	pointer
->	O
c_slweight	int
+=	O
diff	int
;	O
cv	pointer
->	O
c_slweight	int
-=	O
diff	int
;	O
return	O
diff	int
;	O
}	O
done	int
=	O
0	int
;	O
dir	pointer
=	O
1	int
;	O
for	O
(	O
cv	pointer
=	O
fcv	pointer
->	O
c_slnext	pointer
;	O
diff	int
>	O
0	int
;	O
cv	pointer
=	O
dir	pointer
>	O
0	int
?	O
cv	pointer
->	O
c_slnext	pointer
:	O
cv	pointer
->	O
c_slprev	pointer
)	O
{	O
if	O
(	O
!	O
cv	pointer
)	O
{	O
debug1	O
(	O
"reached end, dir is %d\n"	pointer
,	O
dir	pointer
)	O
;	O
if	O
(	O
dir	pointer
==	O
-	O
1	int
)	O
break	O
;	O
dir	pointer
=	O
-	O
1	int
;	O
cv	pointer
=	O
fcv	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
percent	int
)	O
m	union
=	O
1	int
;	O
else	O
m	union
=	O
cv	pointer
->	O
c_slperp	pointer
?	O
CountCanvasPerp	function
(	O
cv	pointer
)	O
*	O
2	int
:	O
2	int
;	O
debug2	O
(	O
"min is %d, have %d\n"	pointer
,	O
m	union
,	O
cv	pointer
->	O
c_slweight	int
)	O
;	O
if	O
(	O
cv	pointer
->	O
c_slweight	int
>	O
m	union
)	O
{	O
have	int
=	O
cv	pointer
->	O
c_slweight	int
-	O
m	union
;	O
if	O
(	O
have	int
>	O
diff	int
)	O
have	int
=	O
diff	int
;	O
debug1	O
(	O
"subtract %d\n"	pointer
,	O
have	int
)	O
;	O
cv	pointer
->	O
c_slweight	int
-=	O
have	int
;	O
done	int
+=	O
have	int
;	O
diff	int
-=	O
have	int
;	O
}	O
}	O
if	O
(	O
diff	int
&&	O
gflag	int
)	O
{	O
cv	pointer
=	O
fcv	pointer
->	O
c_slback	pointer
->	O
c_slback	pointer
;	O
if	O
(	O
cv	pointer
&&	O
cv	pointer
->	O
c_slback	pointer
)	O
done	int
+=	O
ChangeCanvasSize	function
(	O
fcv	pointer
->	O
c_slback	pointer
->	O
c_slback	pointer
,	O
0	int
,	O
diff	int
,	O
gflag	int
,	O
percent	int
)	O
;	O
}	O
fcv	pointer
->	O
c_slweight	int
+=	O
done	int
;	O
debug1	O
(	O
"ChangeCanvasSize returns %d\n"	pointer
,	O
done	int
)	O
;	O
return	O
done	int
;	O
}	O
static	O
void	O
ResizeRegions	function
(	O
arg	pointer
,	O
flags	int
)	O
char	O
*	O
arg	pointer
;	O
int	O
flags	int
;	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
int	O
diff	int
,	O
l	int
;	O
int	O
gflag	int
=	O
0	int
,	O
abs	function
=	O
0	int
,	O
percent	int
=	O
0	int
;	O
int	O
orient	int
=	O
0	int
;	O
ASSERT	O
(	O
display	struct
)	O
;	O
if	O
(	O
!	O
*	O
arg	pointer
)	O
return	O
;	O
if	O
(	O
D_forecv	O
->	O
c_slorient	int
==	O
SLICE_UNKN	int
)	O
{	O
Msg	function
(	O
0	int
,	O
"resize: need more than one region"	pointer
)	O
;	O
return	O
;	O
}	O
gflag	int
=	O
flags	int
&	O
RESIZE_FLAG_L	int
?	O
0	int
:	O
1	int
;	O
orient	int
|=	O
flags	int
&	O
RESIZE_FLAG_H	int
?	O
SLICE_HORI	O
:	O
0	int
;	O
orient	int
|=	O
flags	int
&	O
RESIZE_FLAG_V	int
?	O
SLICE_VERT	O
:	O
0	int
;	O
if	O
(	O
orient	int
==	O
0	int
)	O
orient	int
=	O
D_forecv	O
->	O
c_slorient	int
;	O
l	int
=	O
strlen	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
*	O
arg	pointer
==	O
'='	O
)	O
{	O
struct	O
canvas	struct
*	O
cv	pointer
=	O
gflag	int
?	O
&	O
D_canvas	O
:	O
D_forecv	O
->	O
c_slback	pointer
;	O
if	O
(	O
cv	pointer
->	O
c_slperp	pointer
->	O
c_slorient	int
&	O
orient	int
)	O
EqualizeCanvas	function
(	O
cv	pointer
->	O
c_slperp	pointer
,	O
gflag	int
)	O
;	O
if	O
(	O
(	O
cv	pointer
->	O
c_slperp	pointer
->	O
c_slorient	int
^	O
(	O
SLICE_HORI	O
^	O
SLICE_VERT	O
)	O
)	O
&	O
orient	int
)	O
{	O
if	O
(	O
cv	pointer
->	O
c_slback	pointer
)	O
{	O
cv	pointer
=	O
cv	pointer
->	O
c_slback	pointer
;	O
EqualizeCanvas	function
(	O
cv	pointer
->	O
c_slperp	pointer
,	O
gflag	int
)	O
;	O
}	O
else	O
EqualizeCanvas	function
(	O
cv	pointer
,	O
gflag	int
)	O
;	O
}	O
ResizeCanvas	function
(	O
cv	pointer
)	O
;	O
RecreateCanvasChain	function
(	O
)	O
;	O
RethinkDisplayViewports	function
(	O
)	O
;	O
ResizeLayersToCanvases	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
strcmp	function
(	O
arg	pointer
,	O
"min"	pointer
)	O
||	O
!	O
strcmp	function
(	O
arg	pointer
,	O
"0"	pointer
)	O
)	O
{	O
abs	function
=	O
2	int
;	O
diff	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
arg	pointer
,	O
"max"	pointer
)	O
||	O
!	O
strcmp	function
(	O
arg	pointer
,	O
"_"	pointer
)	O
)	O
{	O
abs	function
=	O
2	int
;	O
diff	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
l	int
>	O
0	int
&&	O
arg	pointer
[	O
l	int
-	O
1	int
]	O
==	O
'%'	O
)	O
percent	int
=	O
1000	int
;	O
if	O
(	O
*	O
arg	pointer
==	O
'+'	O
)	O
diff	int
=	O
atoi	function
(	O
arg	pointer
+	O
1	int
)	O
;	O
else	O
if	O
(	O
*	O
arg	pointer
==	O
'-'	O
)	O
diff	int
=	O
-	O
atoi	function
(	O
arg	pointer
+	O
1	int
)	O
;	O
else	O
{	O
diff	int
=	O
atoi	function
(	O
arg	pointer
)	O
;	O
if	O
(	O
diff	int
<	O
0	int
)	O
diff	int
=	O
0	int
;	O
abs	function
=	O
diff	int
==	O
0	int
?	O
2	int
:	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
abs	function
&&	O
!	O
diff	int
)	O
return	O
;	O
if	O
(	O
percent	int
)	O
diff	int
=	O
diff	int
*	O
percent	int
/	O
100	int
;	O
cv	pointer
=	O
D_forecv	O
;	O
if	O
(	O
cv	pointer
->	O
c_slorient	int
&	O
orient	int
)	O
ChangeCanvasSize	function
(	O
cv	pointer
,	O
abs	function
,	O
diff	int
,	O
gflag	int
,	O
percent	int
)	O
;	O
if	O
(	O
cv	pointer
->	O
c_slback	pointer
->	O
c_slorient	int
&	O
orient	int
)	O
ChangeCanvasSize	function
(	O
cv	pointer
->	O
c_slback	pointer
,	O
abs	function
,	O
diff	int
,	O
gflag	int
,	O
percent	int
)	O
;	O
ResizeCanvas	function
(	O
&	O
D_canvas	O
)	O
;	O
RecreateCanvasChain	function
(	O
)	O
;	O
RethinkDisplayViewports	function
(	O
)	O
;	O
ResizeLayersToCanvases	function
(	O
)	O
;	O
return	O
;	O
}	O
static	O
void	O
ResizeFin	function
(	O
buf	pointer
,	O
len	int
,	O
data	pointer
)	O
char	O
*	O
buf	pointer
;	O
int	O
len	int
;	O
char	O
*	O
data	pointer
;	O
{	O
int	O
ch	int
;	O
int	O
flags	int
=	O
*	O
(	O
int	O
*	O
)	O
data	pointer
;	O
ch	int
=	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
buf	pointer
)	O
[	O
len	int
]	O
;	O
if	O
(	O
ch	int
==	O
0	int
)	O
{	O
ResizeRegions	function
(	O
buf	pointer
,	O
flags	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ch	int
==	O
'h'	O
)	O
flags	int
^=	O
RESIZE_FLAG_H	int
;	O
else	O
if	O
(	O
ch	int
==	O
'v'	O
)	O
flags	int
^=	O
RESIZE_FLAG_V	int
;	O
else	O
if	O
(	O
ch	int
==	O
'b'	O
)	O
flags	int
|=	O
RESIZE_FLAG_H	int
|	O
RESIZE_FLAG_V	int
;	O
else	O
if	O
(	O
ch	int
==	O
'p'	O
)	O
flags	int
^=	O
D_forecv	O
->	O
c_slorient	int
==	O
SLICE_VERT	O
?	O
RESIZE_FLAG_H	int
:	O
RESIZE_FLAG_V	int
;	O
else	O
if	O
(	O
ch	int
==	O
'l'	O
)	O
flags	int
^=	O
RESIZE_FLAG_L	int
;	O
else	O
return	O
;	O
inp_setprompt	function
(	O
resizeprompts	array
[	O
flags	int
]	O
,	O
NULL	O
)	O
;	O
*	O
(	O
int	O
*	O
)	O
data	pointer
=	O
flags	int
;	O
buf	pointer
[	O
len	int
]	O
=	O
'\034'	O
;	O
}	O
void	O
SetForeCanvas	function
(	O
d	int
,	O
cv	pointer
)	O
struct	O
display	struct
*	O
d	int
;	O
struct	O
canvas	struct
*	O
cv	pointer
;	O
{	O
struct	O
display	struct
*	O
odisplay	pointer
=	O
display	struct
;	O
if	O
(	O
d	int
->	O
d_forecv	pointer
==	O
cv	pointer
)	O
return	O
;	O
display	struct
=	O
d	int
;	O
D_forecv	O
=	O
cv	pointer
;	O
if	O
(	O
(	O
focusminwidth	int
&&	O
(	O
focusminwidth	int
<	O
0	int
||	O
D_forecv	O
->	O
c_xe	int
-	O
D_forecv	O
->	O
c_xs	int
+	O
1	int
<	O
focusminwidth	int
)	O
)	O
||	O
(	O
focusminheight	int
&&	O
(	O
focusminheight	int
<	O
0	int
||	O
D_forecv	O
->	O
c_ye	int
-	O
D_forecv	O
->	O
c_ys	int
+	O
1	int
<	O
focusminheight	int
)	O
)	O
)	O
{	O
ResizeCanvas	function
(	O
&	O
D_canvas	O
)	O
;	O
RecreateCanvasChain	function
(	O
)	O
;	O
RethinkDisplayViewports	function
(	O
)	O
;	O
ResizeLayersToCanvases	function
(	O
)	O
;	O
}	O
fore	pointer
=	O
D_fore	O
=	O
Layer2Window	O
(	O
D_forecv	O
->	O
c_layer	pointer
)	O
;	O
if	O
(	O
D_other	O
==	O
fore	pointer
)	O
D_other	O
=	O
0	int
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
{	O
RefreshHStatus	function
(	O
)	O
;	O
flayer	pointer
=	O
D_forecv	O
->	O
c_layer	pointer
;	O
CV_CALL	O
(	O
D_forecv	O
,	O
LayRestore	O
(	O
)	O
;	O
LaySetCursor	O
(	O
)	O
)	O
;	O
WindowChanged	function
(	O
0	int
,	O
'F'	O
)	O
;	O
}	O
display	struct
=	O
odisplay	pointer
;	O
}	O
int	O
ParseAttrColor	function
(	O
s1	pointer
,	O
s2	pointer
,	O
msgok	int
)	O
char	O
*	O
s1	pointer
,	O
*	O
s2	pointer
;	O
int	O
msgok	int
;	O
{	O
int	O
i	int
,	O
n	int
;	O
char	O
*	O
s	pointer
,	O
*	O
ss	pointer
;	O
int	O
r	int
=	O
0	int
;	O
s	pointer
=	O
s1	pointer
;	O
while	O
(	O
*	O
s	pointer
==	O
' '	O
)	O
s	pointer
++	O
;	O
ss	pointer
=	O
s	pointer
;	O
while	O
(	O
*	O
ss	pointer
&&	O
*	O
ss	pointer
!=	O
' '	O
)	O
ss	pointer
++	O
;	O
while	O
(	O
*	O
ss	pointer
==	O
' '	O
)	O
ss	pointer
++	O
;	O
if	O
(	O
*	O
s	pointer
&&	O
(	O
s2	pointer
||	O
*	O
ss	pointer
||	O
!	O
(	O
(	O
*	O
s	pointer
>=	O
'a'	O
&&	O
*	O
s	pointer
<=	O
'z'	O
)	O
||	O
(	O
*	O
s	pointer
>=	O
'A'	O
&&	O
*	O
s	pointer
<=	O
'Z'	O
)	O
||	O
*	O
s	pointer
==	O
'.'	O
)	O
)	O
)	O
{	O
int	O
mode	struct
=	O
0	int
,	O
n	int
=	O
0	int
;	O
if	O
(	O
*	O
s	pointer
==	O
'+'	O
)	O
{	O
mode	struct
=	O
1	int
;	O
s	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'-'	O
)	O
{	O
mode	struct
=	O
-	O
1	int
;	O
s	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'!'	O
)	O
{	O
mode	struct
=	O
2	int
;	O
s	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'='	O
)	O
s	pointer
++	O
;	O
if	O
(	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'9'	O
)	O
{	O
n	int
=	O
*	O
s	pointer
++	O
-	O
'0'	O
;	O
if	O
(	O
*	O
s	pointer
>=	O
'0'	O
&&	O
*	O
s	pointer
<=	O
'9'	O
)	O
n	int
=	O
n	int
*	O
16	int
+	O
(	O
*	O
s	pointer
++	O
-	O
'0'	O
)	O
;	O
else	O
if	O
(	O
*	O
s	pointer
>=	O
'a'	O
&&	O
*	O
s	pointer
<=	O
'f'	O
)	O
n	int
=	O
n	int
*	O
16	int
+	O
(	O
*	O
s	pointer
++	O
-	O
(	O
'a'	O
-	O
10	int
)	O
)	O
;	O
else	O
if	O
(	O
*	O
s	pointer
>=	O
'A'	O
&&	O
*	O
s	pointer
<=	O
'F'	O
)	O
n	int
=	O
n	int
*	O
16	int
+	O
(	O
*	O
s	pointer
++	O
-	O
(	O
'A'	O
-	O
10	int
)	O
)	O
;	O
else	O
if	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
!=	O
' '	O
)	O
{	O
if	O
(	O
msgok	int
)	O
Msg	function
(	O
0	int
,	O
"Illegal attribute hexchar '%c'"	pointer
,	O
*	O
s	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
else	O
{	O
while	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
!=	O
' '	O
)	O
{	O
if	O
(	O
*	O
s	pointer
==	O
'd'	O
)	O
n	int
|=	O
A_DI	O
;	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'u'	O
)	O
n	int
|=	O
A_US	O
;	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'b'	O
)	O
n	int
|=	O
A_BD	O
;	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'r'	O
)	O
n	int
|=	O
A_RV	O
;	O
else	O
if	O
(	O
*	O
s	pointer
==	O
's'	O
)	O
n	int
|=	O
A_SO	O
;	O
else	O
if	O
(	O
*	O
s	pointer
==	O
'B'	O
)	O
n	int
|=	O
A_BL	O
;	O
else	O
{	O
if	O
(	O
msgok	int
)	O
Msg	function
(	O
0	int
,	O
"Illegal attribute specifier '%c'"	pointer
,	O
*	O
s	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
s	pointer
++	O
;	O
}	O
}	O
if	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
!=	O
' '	O
)	O
{	O
if	O
(	O
msgok	int
)	O
Msg	function
(	O
0	int
,	O
"junk after attribute description: '%c'"	pointer
,	O
*	O
s	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
mode	struct
==	O
-	O
1	int
)	O
r	int
=	O
n	int
<<	O
8	int
|	O
n	int
;	O
else	O
if	O
(	O
mode	struct
==	O
1	int
)	O
r	int
=	O
n	int
<<	O
8	int
;	O
else	O
if	O
(	O
mode	struct
==	O
2	int
)	O
r	int
=	O
n	int
;	O
else	O
if	O
(	O
mode	struct
==	O
0	int
)	O
r	int
=	O
0xffff	int
^	O
n	int
;	O
}	O
while	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
==	O
' '	O
)	O
s	pointer
++	O
;	O
if	O
(	O
s2	pointer
)	O
{	O
if	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
msgok	int
)	O
Msg	function
(	O
0	int
,	O
"junk after description: '%c'"	pointer
,	O
*	O
s	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
s	pointer
=	O
s2	pointer
;	O
while	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
==	O
' '	O
)	O
s	pointer
++	O
;	O
}	O
if	O
(	O
*	O
s	pointer
)	O
{	O
static	O
char	O
costr	array
[	O
]	O
=	O
"krgybmcw d    i.01234567 9     f               FKRGYBMCW      I "	pointer
;	O
int	O
numco	int
=	O
0	int
,	O
j	int
;	O
n	int
=	O
0	int
;	O
if	O
(	O
*	O
s	pointer
==	O
'.'	O
)	O
{	O
numco	int
++	O
;	O
n	int
=	O
0x0f	int
;	O
s	pointer
++	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
2	int
&&	O
*	O
s	pointer
&&	O
*	O
s	pointer
!=	O
' '	O
;	O
j	int
++	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
costr	array
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
*	O
s	pointer
==	O
costr	array
[	O
i	int
]	O
)	O
break	O
;	O
if	O
(	O
!	O
costr	array
[	O
i	int
]	O
)	O
{	O
if	O
(	O
msgok	int
)	O
Msg	function
(	O
0	int
,	O
"illegal color descriptor: '%c'"	pointer
,	O
*	O
s	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
numco	int
++	O
;	O
n	int
=	O
n	int
<<	O
4	int
|	O
(	O
i	int
&	O
15	int
)	O
;	O
if	O
(	O
i	int
>=	O
48	int
)	O
n	int
=	O
(	O
n	int
&	O
0x20ff	int
)	O
|	O
0x200	int
;	O
s	pointer
++	O
;	O
}	O
if	O
(	O
(	O
n	int
&	O
0xf00	int
)	O
==	O
0xf00	int
)	O
n	int
^=	O
0xf00	int
;	O
if	O
(	O
n	int
&	O
0x2000	int
)	O
n	int
^=	O
0x2400	int
;	O
if	O
(	O
numco	int
==	O
1	int
)	O
n	int
|=	O
0xf0	int
;	O
if	O
(	O
numco	int
!=	O
2	int
&&	O
n	int
!=	O
0xff	int
)	O
n	int
|=	O
0x100	int
;	O
if	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
!=	O
' '	O
)	O
{	O
if	O
(	O
msgok	int
)	O
Msg	function
(	O
0	int
,	O
"junk after color description: '%c'"	pointer
,	O
*	O
s	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
n	int
^=	O
0xff	int
;	O
r	int
|=	O
n	int
<<	O
16	int
;	O
}	O
while	O
(	O
*	O
s	pointer
&&	O
*	O
s	pointer
==	O
' '	O
)	O
s	pointer
++	O
;	O
if	O
(	O
*	O
s	pointer
)	O
{	O
if	O
(	O
msgok	int
)	O
Msg	function
(	O
0	int
,	O
"junk after description: '%c'"	pointer
,	O
*	O
s	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
debug1	O
(	O
"ParseAttrColor %06x\n"	pointer
,	O
r	int
)	O
;	O
return	O
r	int
;	O
}	O
void	O
ApplyAttrColor	function
(	O
i	int
,	O
mc	pointer
)	O
int	O
i	int
;	O
struct	O
mchar	struct
*	O
mc	pointer
;	O
{	O
debug1	O
(	O
"ApplyAttrColor %06x\n"	pointer
,	O
i	int
)	O
;	O
mc	pointer
->	O
attr	char
|=	O
i	int
>>	O
8	int
&	O
255	int
;	O
mc	pointer
->	O
attr	char
^=	O
i	int
&	O
255	int
;	O
i	int
=	O
(	O
i	int
>>	O
16	int
)	O
^	O
0xff	int
;	O
if	O
(	O
(	O
i	int
&	O
0x100	int
)	O
!=	O
0	int
)	O
{	O
i	int
&=	O
0xeff	int
;	O
if	O
(	O
mc	pointer
->	O
attr	char
&	O
(	O
A_SO	O
|	O
A_RV	O
)	O
)	O
i	int
=	O
(	O
(	O
i	int
&	O
0x0f	int
)	O
<<	O
4	int
)	O
|	O
(	O
(	O
i	int
&	O
0xf0	int
)	O
>>	O
4	int
)	O
|	O
(	O
(	O
i	int
&	O
0x200	int
)	O
<<	O
1	int
)	O
|	O
(	O
(	O
i	int
&	O
0x400	int
)	O
>>	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
i	int
&	O
0x0f	int
)	O
!=	O
0x0f	int
)	O
mc	pointer
->	O
attr	char
=	O
(	O
mc	pointer
->	O
attr	char
&	O
0xbf	int
)	O
|	O
(	O
(	O
i	int
>>	O
3	int
)	O
&	O
0x40	int
)	O
;	O
if	O
(	O
(	O
i	int
&	O
0xf0	int
)	O
!=	O
0xf0	int
)	O
mc	pointer
->	O
attr	char
=	O
(	O
mc	pointer
->	O
attr	char
&	O
0x7f	int
)	O
|	O
(	O
(	O
i	int
>>	O
3	int
)	O
&	O
0x80	int
)	O
;	O
mc	pointer
->	O
color	char
=	O
0x99	int
^	O
mc	pointer
->	O
color	char
;	O
if	O
(	O
(	O
i	int
&	O
0x0e	int
)	O
==	O
0x0e	int
)	O
i	int
=	O
(	O
i	int
&	O
0xf0	int
)	O
|	O
(	O
mc	pointer
->	O
color	char
&	O
0x0f	int
)	O
;	O
if	O
(	O
(	O
i	int
&	O
0xe0	int
)	O
==	O
0xe0	int
)	O
i	int
=	O
(	O
i	int
&	O
0x0f	int
)	O
|	O
(	O
mc	pointer
->	O
color	char
&	O
0xf0	int
)	O
;	O
mc	pointer
->	O
color	char
=	O
0x99	int
^	O
i	int
;	O
debug2	O
(	O
"ApplyAttrColor - %02x %02x\n"	pointer
,	O
mc	pointer
->	O
attr	char
,	O
i	int
)	O
;	O
}	O
