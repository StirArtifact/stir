static	O
double	O
solve_cubic	function
(	O
double	O
c2	double
,	O
double	O
c1	double
,	O
double	O
c0	double
)	O
;	O
static	O
double	O
ceer	function
(	O
int	O
order	enum
,	O
double	O
qq	double
,	O
double	O
aa	pointer
,	O
int	O
nterms	int
)	O
{	O
double	O
term	double
,	O
term1	double
;	O
int	O
ii	int
,	O
n1	long
;	O
if	O
(	O
order	enum
==	O
0	int
)	O
term	double
=	O
0.0	int
;	O
else	O
{	O
term	double
=	O
2.0	int
*	O
qq	double
*	O
qq	double
/	O
aa	pointer
;	O
if	O
(	O
order	enum
!=	O
2	int
)	O
{	O
n1	long
=	O
order	enum
/	O
2	int
-	O
1	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
n1	long
;	O
ii	int
++	O
)	O
term	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	pointer
-	O
4.0	int
*	O
(	O
ii	int
+	O
1	int
)	O
*	O
(	O
ii	int
+	O
1	int
)	O
-	O
term	double
)	O
;	O
}	O
}	O
term	double
+=	O
order	enum
*	O
order	enum
;	O
term1	double
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
nterms	int
;	O
ii	int
++	O
)	O
term1	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	pointer
-	O
(	O
order	enum
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
*	O
(	O
order	enum
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
-	O
term1	double
)	O
;	O
if	O
(	O
order	enum
==	O
0	int
)	O
term1	double
*=	O
2.0	int
;	O
return	O
(	O
term	double
+	O
term1	double
-	O
aa	pointer
)	O
;	O
}	O
static	O
double	O
ceor	function
(	O
int	O
order	enum
,	O
double	O
qq	double
,	O
double	O
aa	pointer
,	O
int	O
nterms	int
)	O
{	O
double	O
term	double
,	O
term1	double
;	O
int	O
ii	int
,	O
n1	long
;	O
term	double
=	O
qq	double
;	O
n1	long
=	O
(	O
int	O
)	O
(	O
(	O
float	O
)	O
order	enum
/	O
2.0	int
-	O
0.5	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
n1	long
;	O
ii	int
++	O
)	O
term	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	pointer
-	O
(	O
2.0	int
*	O
ii	int
+	O
1.0	int
)	O
*	O
(	O
2.0	int
*	O
ii	int
+	O
1.0	int
)	O
-	O
term	double
)	O
;	O
term	double
+=	O
order	enum
*	O
order	enum
;	O
term1	double
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
nterms	int
;	O
ii	int
++	O
)	O
term1	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	pointer
-	O
(	O
order	enum
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
*	O
(	O
order	enum
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
-	O
term1	double
)	O
;	O
return	O
(	O
term	double
+	O
term1	double
-	O
aa	pointer
)	O
;	O
}	O
static	O
double	O
seer	function
(	O
int	O
order	enum
,	O
double	O
qq	double
,	O
double	O
aa	pointer
,	O
int	O
nterms	int
)	O
{	O
double	O
term	double
,	O
term1	double
;	O
int	O
ii	int
,	O
n1	long
;	O
term	double
=	O
0.0	int
;	O
n1	long
=	O
order	enum
/	O
2	int
-	O
1	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
n1	long
;	O
ii	int
++	O
)	O
term	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	pointer
-	O
4.0	int
*	O
(	O
ii	int
+	O
1	int
)	O
*	O
(	O
ii	int
+	O
1	int
)	O
-	O
term	double
)	O
;	O
term	double
+=	O
order	enum
*	O
order	enum
;	O
term1	double
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
nterms	int
;	O
ii	int
++	O
)	O
term1	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	pointer
-	O
(	O
order	enum
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
*	O
(	O
order	enum
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
-	O
term1	double
)	O
;	O
return	O
(	O
term	double
+	O
term1	double
-	O
aa	pointer
)	O
;	O
}	O
static	O
double	O
seor	function
(	O
int	O
order	enum
,	O
double	O
qq	double
,	O
double	O
aa	pointer
,	O
int	O
nterms	int
)	O
{	O
double	O
term	double
,	O
term1	double
;	O
int	O
ii	int
,	O
n1	long
;	O
term	double
=	O
-	O
1.0	int
*	O
qq	double
;	O
n1	long
=	O
(	O
int	O
)	O
(	O
(	O
float	O
)	O
order	enum
/	O
2.0	int
-	O
0.5	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
n1	long
;	O
ii	int
++	O
)	O
term	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	pointer
-	O
(	O
2.0	int
*	O
ii	int
+	O
1.0	int
)	O
*	O
(	O
2.0	int
*	O
ii	int
+	O
1.0	int
)	O
-	O
term	double
)	O
;	O
term	double
+=	O
order	enum
*	O
order	enum
;	O
term1	double
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
nterms	int
;	O
ii	int
++	O
)	O
term1	double
=	O
qq	double
*	O
qq	double
/	O
(	O
aa	pointer
-	O
(	O
order	enum
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
*	O
(	O
order	enum
+	O
2.0	int
*	O
(	O
nterms	int
-	O
ii	int
)	O
)	O
-	O
term1	double
)	O
;	O
return	O
(	O
term	double
+	O
term1	double
-	O
aa	pointer
)	O
;	O
}	O
static	O
double	O
asymptotic	function
(	O
int	O
order	enum
,	O
double	O
qq	double
)	O
{	O
double	O
asymp	double
;	O
double	O
nn	long
,	O
n2	long
,	O
n4	double
,	O
n6	double
;	O
double	O
hh	double
,	O
ah	double
,	O
ah2	double
,	O
ah3	double
,	O
ah4	double
,	O
ah5	double
;	O
nn	long
=	O
2	int
*	O
order	enum
+	O
1	int
;	O
n2	long
=	O
nn	long
*	O
nn	long
;	O
n4	double
=	O
n2	long
*	O
n2	long
;	O
n6	double
=	O
n4	double
*	O
n2	long
;	O
hh	double
=	O
2	int
*	O
sqrt	function
(	O
qq	double
)	O
;	O
ah	double
=	O
16	int
*	O
hh	double
;	O
ah2	double
=	O
ah	double
*	O
ah	double
;	O
ah3	double
=	O
ah2	double
*	O
ah	double
;	O
ah4	double
=	O
ah3	double
*	O
ah	double
;	O
ah5	double
=	O
ah4	double
*	O
ah	double
;	O
asymp	double
=	O
-	O
2	int
*	O
qq	double
+	O
nn	long
*	O
hh	double
-	O
0.125	int
*	O
(	O
n2	long
+	O
1	int
)	O
;	O
asymp	double
-=	O
0.25	int
*	O
nn	long
*	O
(	O
n2	long
+	O
3	int
)	O
/	O
ah	double
;	O
asymp	double
-=	O
0.25	int
*	O
(	O
5	int
*	O
n4	double
+	O
34	int
*	O
n2	long
+	O
9	int
)	O
/	O
ah2	double
;	O
asymp	double
-=	O
0.25	int
*	O
nn	long
*	O
(	O
33	int
*	O
n4	double
+	O
410	int
*	O
n2	long
+	O
405	int
)	O
/	O
ah3	double
;	O
asymp	double
-=	O
(	O
63	int
*	O
n6	double
+	O
1260	int
*	O
n4	double
+	O
2943	int
*	O
n2	long
+	O
486	int
)	O
/	O
ah4	double
;	O
asymp	double
-=	O
nn	long
*	O
(	O
527	int
*	O
n6	double
+	O
15617	int
*	O
n4	double
+	O
69001	int
*	O
n2	long
+	O
41607	int
)	O
/	O
ah5	double
;	O
return	O
asymp	double
;	O
}	O
static	O
double	O
solve_cubic	function
(	O
double	O
c2	double
,	O
double	O
c1	double
,	O
double	O
c0	double
)	O
{	O
double	O
qq	double
,	O
rr	double
,	O
ww	double
,	O
ss	double
,	O
tt	pointer
;	O
qq	double
=	O
(	O
3	int
*	O
c1	double
-	O
c2	double
*	O
c2	double
)	O
/	O
9	int
;	O
rr	double
=	O
(	O
9	int
*	O
c2	double
*	O
c1	double
-	O
27	int
*	O
c0	double
-	O
2	int
*	O
c2	double
*	O
c2	double
*	O
c2	double
)	O
/	O
54	int
;	O
ww	double
=	O
qq	double
*	O
qq	double
*	O
qq	double
+	O
rr	double
*	O
rr	double
;	O
if	O
(	O
ww	double
>=	O
0	int
)	O
{	O
double	O
t1	double
=	O
rr	double
+	O
sqrt	function
(	O
ww	double
)	O
;	O
ss	double
=	O
fabs	function
(	O
t1	double
)	O
/	O
t1	double
*	O
pow	function
(	O
fabs	function
(	O
t1	double
)	O
,	O
1	int
/	O
3.	int
)	O
;	O
t1	double
=	O
rr	double
-	O
sqrt	function
(	O
ww	double
)	O
;	O
tt	pointer
=	O
fabs	function
(	O
t1	double
)	O
/	O
t1	double
*	O
pow	function
(	O
fabs	function
(	O
t1	double
)	O
,	O
1	int
/	O
3.	int
)	O
;	O
}	O
else	O
{	O
double	O
theta	double
=	O
acos	function
(	O
rr	double
/	O
sqrt	function
(	O
-	O
qq	double
*	O
qq	double
*	O
qq	double
)	O
)	O
;	O
ss	double
=	O
2	int
*	O
sqrt	function
(	O
-	O
qq	double
)	O
*	O
cos	function
(	O
(	O
theta	double
+	O
4	int
*	O
M_PI	int
)	O
/	O
3.	int
)	O
;	O
tt	pointer
=	O
0.0	int
;	O
}	O
return	O
(	O
ss	double
+	O
tt	pointer
-	O
c2	double
/	O
3	int
)	O
;	O
}	O
static	O
double	O
approx_c	function
(	O
int	O
order	enum
,	O
double	O
qq	double
)	O
{	O
double	O
approx	double
;	O
double	O
c0	double
,	O
c1	double
,	O
c2	double
;	O
if	O
(	O
order	enum
<	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"Undefined order for Mathieu function"	pointer
,	O
GSL_EINVAL	int
,	O
0.0	int
)	O
;	O
}	O
switch	O
(	O
order	enum
)	O
{	O
case	O
0	int
:	O
if	O
(	O
qq	double
<=	O
4	int
)	O
return	O
(	O
2	int
-	O
sqrt	function
(	O
4	int
+	O
2	int
*	O
qq	double
*	O
qq	double
)	O
)	O
;	O
else	O
return	O
asymptotic	function
(	O
order	enum
,	O
qq	double
)	O
;	O
break	O
;	O
case	O
1	int
:	O
if	O
(	O
qq	double
<=	O
4	int
)	O
return	O
(	O
5	int
+	O
0.5	int
*	O
(	O
qq	double
-	O
sqrt	function
(	O
5	int
*	O
qq	double
*	O
qq	double
-	O
16	int
*	O
qq	double
+	O
64	int
)	O
)	O
)	O
;	O
else	O
return	O
asymptotic	function
(	O
order	enum
,	O
qq	double
)	O
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
qq	double
<=	O
3	int
)	O
{	O
c2	double
=	O
-	O
8.0	int
;	O
c1	double
=	O
-	O
48	int
-	O
3	int
*	O
qq	double
*	O
qq	double
;	O
c0	double
=	O
20	int
*	O
qq	double
*	O
qq	double
;	O
}	O
else	O
return	O
asymptotic	function
(	O
order	enum
,	O
qq	double
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
qq	double
<=	O
6.25	int
)	O
{	O
c2	double
=	O
-	O
qq	double
-	O
8	int
;	O
c1	double
=	O
16	int
*	O
qq	double
-	O
128	int
-	O
2	int
*	O
qq	double
*	O
qq	double
;	O
c0	double
=	O
qq	double
*	O
qq	double
*	O
(	O
qq	double
+	O
8	int
)	O
;	O
}	O
else	O
return	O
asymptotic	function
(	O
order	enum
,	O
qq	double
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
order	enum
<	O
70	int
)	O
{	O
if	O
(	O
1.7	int
*	O
order	enum
>	O
2	int
*	O
sqrt	function
(	O
qq	double
)	O
)	O
{	O
double	O
n2	long
=	O
(	O
double	O
)	O
(	O
order	enum
*	O
order	enum
)	O
;	O
double	O
n22	double
=	O
(	O
double	O
)	O
(	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
1	int
)	O
)	O
;	O
double	O
q2	double
=	O
qq	double
*	O
qq	double
;	O
double	O
q4	double
=	O
q2	double
*	O
q2	double
;	O
approx	double
=	O
n2	long
+	O
0.5	int
*	O
q2	double
/	O
(	O
n2	long
-	O
1	int
)	O
;	O
approx	double
+=	O
(	O
5	int
*	O
n2	long
+	O
7	int
)	O
*	O
q4	double
/	O
(	O
32	int
*	O
n22	double
*	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
4	int
)	O
)	O
;	O
approx	double
+=	O
(	O
9	int
*	O
n2	long
*	O
n2	long
+	O
58	int
*	O
n2	long
+	O
29	int
)	O
*	O
q4	double
*	O
q2	double
/	O
(	O
64	int
*	O
n22	double
*	O
n22	double
*	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
4	int
)	O
*	O
(	O
n2	long
-	O
9	int
)	O
)	O
;	O
if	O
(	O
1.4	int
*	O
order	enum
<	O
2	int
*	O
sqrt	function
(	O
qq	double
)	O
)	O
{	O
approx	double
+=	O
asymptotic	function
(	O
order	enum
,	O
qq	double
)	O
;	O
approx	double
*=	O
0.5	int
;	O
}	O
}	O
else	O
approx	double
=	O
asymptotic	function
(	O
order	enum
,	O
qq	double
)	O
;	O
return	O
approx	double
;	O
}	O
else	O
return	O
order	enum
*	O
order	enum
;	O
}	O
approx	double
=	O
solve_cubic	function
(	O
c2	double
,	O
c1	double
,	O
c0	double
)	O
;	O
if	O
(	O
approx	double
<	O
0	int
&&	O
sqrt	function
(	O
qq	double
)	O
>	O
0.1	int
*	O
order	enum
)	O
return	O
asymptotic	function
(	O
order	enum
-	O
1	int
,	O
qq	double
)	O
;	O
else	O
return	O
(	O
order	enum
*	O
order	enum
+	O
fabs	function
(	O
approx	double
)	O
)	O
;	O
}	O
static	O
double	O
approx_s	function
(	O
int	O
order	enum
,	O
double	O
qq	double
)	O
{	O
double	O
approx	double
;	O
double	O
c0	double
,	O
c1	double
,	O
c2	double
;	O
if	O
(	O
order	enum
<	O
1	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"Undefined order for Mathieu function"	pointer
,	O
GSL_EINVAL	int
,	O
0.0	int
)	O
;	O
}	O
switch	O
(	O
order	enum
)	O
{	O
case	O
1	int
:	O
if	O
(	O
qq	double
<=	O
4	int
)	O
return	O
(	O
5	int
-	O
0.5	int
*	O
(	O
qq	double
+	O
sqrt	function
(	O
5	int
*	O
qq	double
*	O
qq	double
+	O
16	int
*	O
qq	double
+	O
64	int
)	O
)	O
)	O
;	O
else	O
return	O
asymptotic	function
(	O
order	enum
-	O
1	int
,	O
qq	double
)	O
;	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
qq	double
<=	O
5	int
)	O
return	O
(	O
10	int
-	O
sqrt	function
(	O
36	int
+	O
qq	double
*	O
qq	double
)	O
)	O
;	O
else	O
return	O
asymptotic	function
(	O
order	enum
-	O
1	int
,	O
qq	double
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
qq	double
<=	O
6.25	int
)	O
{	O
c2	double
=	O
qq	double
-	O
8	int
;	O
c1	double
=	O
-	O
128	int
-	O
16	int
*	O
qq	double
-	O
2	int
*	O
qq	double
*	O
qq	double
;	O
c0	double
=	O
qq	double
*	O
qq	double
*	O
(	O
8	int
-	O
qq	double
)	O
;	O
}	O
else	O
return	O
asymptotic	function
(	O
order	enum
-	O
1	int
,	O
qq	double
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
order	enum
<	O
70	int
)	O
{	O
if	O
(	O
1.7	int
*	O
order	enum
>	O
2	int
*	O
sqrt	function
(	O
qq	double
)	O
)	O
{	O
double	O
n2	long
=	O
(	O
double	O
)	O
(	O
order	enum
*	O
order	enum
)	O
;	O
double	O
n22	double
=	O
(	O
double	O
)	O
(	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
1	int
)	O
)	O
;	O
double	O
q2	double
=	O
qq	double
*	O
qq	double
;	O
double	O
q4	double
=	O
q2	double
*	O
q2	double
;	O
approx	double
=	O
n2	long
+	O
0.5	int
*	O
q2	double
/	O
(	O
n2	long
-	O
1	int
)	O
;	O
approx	double
+=	O
(	O
5	int
*	O
n2	long
+	O
7	int
)	O
*	O
q4	double
/	O
(	O
32	int
*	O
n22	double
*	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
4	int
)	O
)	O
;	O
approx	double
+=	O
(	O
9	int
*	O
n2	long
*	O
n2	long
+	O
58	int
*	O
n2	long
+	O
29	int
)	O
*	O
q4	double
*	O
q2	double
/	O
(	O
64	int
*	O
n22	double
*	O
n22	double
*	O
(	O
n2	long
-	O
1	int
)	O
*	O
(	O
n2	long
-	O
4	int
)	O
*	O
(	O
n2	long
-	O
9	int
)	O
)	O
;	O
if	O
(	O
1.4	int
*	O
order	enum
<	O
2	int
*	O
sqrt	function
(	O
qq	double
)	O
)	O
{	O
approx	double
+=	O
asymptotic	function
(	O
order	enum
-	O
1	int
,	O
qq	double
)	O
;	O
approx	double
*=	O
0.5	int
;	O
}	O
}	O
else	O
approx	double
=	O
asymptotic	function
(	O
order	enum
-	O
1	int
,	O
qq	double
)	O
;	O
return	O
approx	double
;	O
}	O
else	O
return	O
order	enum
*	O
order	enum
;	O
}	O
approx	double
=	O
solve_cubic	function
(	O
c2	double
,	O
c1	double
,	O
c0	double
)	O
;	O
if	O
(	O
approx	double
<	O
0	int
&&	O
sqrt	function
(	O
qq	double
)	O
>	O
0.1	int
*	O
order	enum
)	O
return	O
asymptotic	function
(	O
order	enum
-	O
1	int
,	O
qq	double
)	O
;	O
else	O
return	O
(	O
order	enum
*	O
order	enum
+	O
fabs	function
(	O
approx	double
)	O
)	O
;	O
}	O
int	O
gsl_sf_mathieu_a_e	function
(	O
int	O
order	enum
,	O
double	O
qq	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
int	O
even_odd	int
,	O
nterms	int
=	O
50	int
,	O
ii	int
,	O
counter	int
=	O
0	int
,	O
maxcount	int
=	O
1000	int
;	O
int	O
dir	int
=	O
0	int
;	O
double	O
a1	double
,	O
a2	double
,	O
fa	double
,	O
fa1	double
,	O
dela	double
,	O
aa_orig	double
,	O
da	double
=	O
0.025	int
,	O
aa	pointer
;	O
double	O
aa_approx	double
;	O
even_odd	int
=	O
0	int
;	O
if	O
(	O
order	enum
%	O
2	int
!=	O
0	int
)	O
even_odd	int
=	O
1	int
;	O
if	O
(	O
qq	double
==	O
0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
order	enum
*	O
order	enum
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
if	O
(	O
order	enum
<	O
0	int
)	O
order	enum
*=	O
-	O
1	int
;	O
if	O
(	O
qq	double
<	O
0.0	int
)	O
{	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
return	O
gsl_sf_mathieu_a_e	function
(	O
order	enum
,	O
-	O
qq	double
,	O
result	pointer
)	O
;	O
else	O
return	O
gsl_sf_mathieu_b_e	function
(	O
order	enum
,	O
-	O
qq	double
,	O
result	pointer
)	O
;	O
}	O
aa_approx	double
=	O
approx_c	function
(	O
order	enum
,	O
qq	double
)	O
;	O
aa_orig	double
=	O
aa	pointer
=	O
aa_approx	double
;	O
while	O
(	O
counter	int
<	O
maxcount	int
)	O
{	O
a1	double
=	O
aa	pointer
+	O
0.001	int
;	O
ii	int
=	O
0	int
;	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
fa1	double
=	O
ceer	function
(	O
order	enum
,	O
qq	double
,	O
a1	double
,	O
nterms	int
)	O
;	O
else	O
fa1	double
=	O
ceor	function
(	O
order	enum
,	O
qq	double
,	O
a1	double
,	O
nterms	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
fa	double
=	O
ceer	function
(	O
order	enum
,	O
qq	double
,	O
aa	pointer
,	O
nterms	int
)	O
;	O
else	O
fa	double
=	O
ceor	function
(	O
order	enum
,	O
qq	double
,	O
aa	pointer
,	O
nterms	int
)	O
;	O
a2	double
=	O
a1	double
;	O
a1	double
=	O
aa	pointer
;	O
if	O
(	O
fa	double
==	O
fa1	double
)	O
{	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
break	O
;	O
}	O
aa	pointer
-=	O
(	O
aa	pointer
-	O
a2	double
)	O
/	O
(	O
fa	double
-	O
fa1	double
)	O
*	O
fa	double
;	O
dela	double
=	O
fabs	function
(	O
aa	pointer
-	O
a2	double
)	O
;	O
if	O
(	O
dela	double
<	O
GSL_DBL_EPSILON	int
)	O
{	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
break	O
;	O
}	O
if	O
(	O
ii	int
>	O
40	int
)	O
{	O
result	pointer
->	O
err	double
=	O
dela	double
;	O
break	O
;	O
}	O
fa1	double
=	O
fa	double
;	O
ii	int
++	O
;	O
}	O
if	O
(	O
fabs	function
(	O
aa	pointer
-	O
aa_orig	double
)	O
>	O
(	O
3	int
+	O
0.01	int
*	O
order	enum
*	O
fabs	function
(	O
aa_orig	double
)	O
)	O
||	O
(	O
order	enum
>	O
10	int
&&	O
fabs	function
(	O
aa	pointer
-	O
aa_orig	double
)	O
>	O
1.5	int
*	O
order	enum
)	O
)	O
{	O
counter	int
++	O
;	O
if	O
(	O
counter	int
==	O
maxcount	int
)	O
{	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
aa	pointer
-	O
aa_orig	double
)	O
;	O
break	O
;	O
}	O
if	O
(	O
aa	pointer
>	O
aa_orig	double
)	O
{	O
if	O
(	O
dir	int
==	O
1	int
)	O
da	double
/=	O
2	int
;	O
dir	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
dir	int
==	O
-	O
1	int
)	O
da	double
/=	O
2	int
;	O
dir	int
=	O
1	int
;	O
}	O
aa_approx	double
+=	O
dir	int
*	O
da	double
*	O
counter	int
;	O
aa	pointer
=	O
aa_approx	double
;	O
continue	O
;	O
}	O
else	O
break	O
;	O
}	O
result	pointer
->	O
val	double
=	O
aa	pointer
;	O
if	O
(	O
counter	int
==	O
maxcount	int
)	O
{	O
GSL_ERROR	O
(	O
"Wrong characteristic Mathieu value"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_mathieu_b_e	function
(	O
int	O
order	enum
,	O
double	O
qq	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
int	O
even_odd	int
,	O
nterms	int
=	O
50	int
,	O
ii	int
,	O
counter	int
=	O
0	int
,	O
maxcount	int
=	O
1000	int
;	O
int	O
dir	int
=	O
0	int
;	O
double	O
a1	double
,	O
a2	double
,	O
fa	double
,	O
fa1	double
,	O
dela	double
,	O
aa_orig	double
,	O
da	double
=	O
0.025	int
,	O
aa	pointer
;	O
double	O
aa_approx	double
;	O
even_odd	int
=	O
0	int
;	O
if	O
(	O
order	enum
%	O
2	int
!=	O
0	int
)	O
even_odd	int
=	O
1	int
;	O
if	O
(	O
order	enum
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"Characteristic value undefined for order 0"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
if	O
(	O
qq	double
==	O
0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
order	enum
*	O
order	enum
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
if	O
(	O
order	enum
<	O
0	int
)	O
order	enum
*=	O
-	O
1	int
;	O
if	O
(	O
qq	double
<	O
0.0	int
)	O
{	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
return	O
gsl_sf_mathieu_b_e	function
(	O
order	enum
,	O
-	O
qq	double
,	O
result	pointer
)	O
;	O
else	O
return	O
gsl_sf_mathieu_a_e	function
(	O
order	enum
,	O
-	O
qq	double
,	O
result	pointer
)	O
;	O
}	O
aa_approx	double
=	O
approx_s	function
(	O
order	enum
,	O
qq	double
)	O
;	O
aa_orig	double
=	O
aa	pointer
=	O
aa_approx	double
;	O
while	O
(	O
counter	int
<	O
maxcount	int
)	O
{	O
a1	double
=	O
aa	pointer
+	O
0.001	int
;	O
ii	int
=	O
0	int
;	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
fa1	double
=	O
seer	function
(	O
order	enum
,	O
qq	double
,	O
a1	double
,	O
nterms	int
)	O
;	O
else	O
fa1	double
=	O
seor	function
(	O
order	enum
,	O
qq	double
,	O
a1	double
,	O
nterms	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
even_odd	int
==	O
0	int
)	O
fa	double
=	O
seer	function
(	O
order	enum
,	O
qq	double
,	O
aa	pointer
,	O
nterms	int
)	O
;	O
else	O
fa	double
=	O
seor	function
(	O
order	enum
,	O
qq	double
,	O
aa	pointer
,	O
nterms	int
)	O
;	O
a2	double
=	O
a1	double
;	O
a1	double
=	O
aa	pointer
;	O
if	O
(	O
fa	double
==	O
fa1	double
)	O
{	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
break	O
;	O
}	O
aa	pointer
-=	O
(	O
aa	pointer
-	O
a2	double
)	O
/	O
(	O
fa	double
-	O
fa1	double
)	O
*	O
fa	double
;	O
dela	double
=	O
fabs	function
(	O
aa	pointer
-	O
a2	double
)	O
;	O
if	O
(	O
dela	double
<	O
1e-18	int
)	O
{	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
;	O
break	O
;	O
}	O
if	O
(	O
ii	int
>	O
40	int
)	O
{	O
result	pointer
->	O
err	double
=	O
dela	double
;	O
break	O
;	O
}	O
fa1	double
=	O
fa	double
;	O
ii	int
++	O
;	O
}	O
if	O
(	O
fabs	function
(	O
aa	pointer
-	O
aa_orig	double
)	O
>	O
(	O
3	int
+	O
0.01	int
*	O
order	enum
*	O
fabs	function
(	O
aa_orig	double
)	O
)	O
||	O
(	O
order	enum
>	O
10	int
&&	O
fabs	function
(	O
aa	pointer
-	O
aa_orig	double
)	O
>	O
1.5	int
*	O
order	enum
)	O
)	O
{	O
counter	int
++	O
;	O
if	O
(	O
counter	int
==	O
maxcount	int
)	O
{	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
aa	pointer
-	O
aa_orig	double
)	O
;	O
break	O
;	O
}	O
if	O
(	O
aa	pointer
>	O
aa_orig	double
)	O
{	O
if	O
(	O
dir	int
==	O
1	int
)	O
da	double
/=	O
2	int
;	O
dir	int
=	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
dir	int
==	O
-	O
1	int
)	O
da	double
/=	O
2	int
;	O
dir	int
=	O
1	int
;	O
}	O
aa_approx	double
+=	O
dir	int
*	O
da	double
*	O
counter	int
;	O
aa	pointer
=	O
aa_approx	double
;	O
continue	O
;	O
}	O
else	O
break	O
;	O
}	O
result	pointer
->	O
val	double
=	O
aa	pointer
;	O
if	O
(	O
counter	int
==	O
maxcount	int
)	O
{	O
GSL_ERROR	O
(	O
"Wrong characteristic Mathieu value"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
figi	function
(	O
int	O
nn	long
,	O
double	O
*	O
tt	pointer
,	O
double	O
*	O
dd	pointer
,	O
double	O
*	O
ee	pointer
,	O
double	O
*	O
e2	pointer
)	O
{	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
nn	long
;	O
ii	int
++	O
)	O
{	O
if	O
(	O
ii	int
!=	O
0	int
)	O
{	O
e2	pointer
[	O
ii	int
]	O
=	O
tt	pointer
[	O
3	int
*	O
ii	int
]	O
*	O
tt	pointer
[	O
3	int
*	O
(	O
ii	int
-	O
1	int
)	O
+	O
2	int
]	O
;	O
if	O
(	O
e2	pointer
[	O
ii	int
]	O
<	O
0.0	int
)	O
{	O
return	O
(	O
nn	long
+	O
ii	int
)	O
;	O
}	O
if	O
(	O
e2	pointer
[	O
ii	int
]	O
==	O
0.0	int
&&	O
(	O
tt	pointer
[	O
3	int
*	O
ii	int
]	O
!=	O
0.0	int
||	O
tt	pointer
[	O
3	int
*	O
(	O
ii	int
-	O
1	int
)	O
+	O
2	int
]	O
!=	O
0.0	int
)	O
)	O
{	O
return	O
(	O
-	O
1	int
*	O
(	O
3	int
*	O
nn	long
+	O
ii	int
)	O
)	O
;	O
}	O
ee	pointer
[	O
ii	int
]	O
=	O
sqrt	function
(	O
e2	pointer
[	O
ii	int
]	O
)	O
;	O
}	O
dd	pointer
[	O
ii	int
]	O
=	O
tt	pointer
[	O
3	int
*	O
ii	int
+	O
1	int
]	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
gsl_sf_mathieu_a_array	function
(	O
int	O
order_min	int
,	O
int	O
order_max	int
,	O
double	O
qq	double
,	O
gsl_sf_mathieu_workspace	struct
*	O
work	pointer
,	O
double	O
result_array	array
[	O
]	O
)	O
{	O
unsigned	O
int	O
even_order	long
=	O
work	pointer
->	O
even_order	long
,	O
odd_order	long
=	O
work	pointer
->	O
odd_order	long
,	O
extra_values	int
=	O
work	pointer
->	O
extra_values	int
,	O
ii	int
,	O
jj	int
;	O
int	O
status	int
;	O
double	O
*	O
tt	pointer
=	O
work	pointer
->	O
tt	pointer
,	O
*	O
dd	pointer
=	O
work	pointer
->	O
dd	pointer
,	O
*	O
ee	pointer
=	O
work	pointer
->	O
ee	pointer
,	O
*	O
e2	pointer
=	O
work	pointer
->	O
e2	pointer
,	O
*	O
zz	pointer
=	O
work	pointer
->	O
zz	pointer
,	O
*	O
aa	pointer
=	O
work	pointer
->	O
aa	pointer
;	O
gsl_matrix_view	struct
mat	struct
,	O
evec	pointer
;	O
gsl_vector_view	struct
eval	pointer
;	O
gsl_eigen_symmv_workspace	struct
*	O
wmat	pointer
=	O
work	pointer
->	O
wmat	pointer
;	O
if	O
(	O
order_max	int
>	O
work	pointer
->	O
size	long
||	O
order_max	int
<=	O
order_min	int
||	O
order_min	int
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid range [order_min,order_max]"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
tt	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
tt	pointer
[	O
1	int
]	O
=	O
0.0	int
;	O
tt	pointer
[	O
2	int
]	O
=	O
qq	double
;	O
for	O
(	O
ii	int
=	O
1	int
;	O
ii	int
<	O
even_order	long
-	O
1	int
;	O
ii	int
++	O
)	O
{	O
tt	pointer
[	O
3	int
*	O
ii	int
]	O
=	O
qq	double
;	O
tt	pointer
[	O
3	int
*	O
ii	int
+	O
1	int
]	O
=	O
4	int
*	O
ii	int
*	O
ii	int
;	O
tt	pointer
[	O
3	int
*	O
ii	int
+	O
2	int
]	O
=	O
qq	double
;	O
}	O
tt	pointer
[	O
3	int
*	O
even_order	long
-	O
3	int
]	O
=	O
qq	double
;	O
tt	pointer
[	O
3	int
*	O
even_order	long
-	O
2	int
]	O
=	O
4	int
*	O
(	O
even_order	long
-	O
1	int
)	O
*	O
(	O
even_order	long
-	O
1	int
)	O
;	O
tt	pointer
[	O
3	int
*	O
even_order	long
-	O
1	int
]	O
=	O
0.0	int
;	O
tt	pointer
[	O
3	int
]	O
*=	O
2	int
;	O
status	int
=	O
figi	function
(	O
(	O
signed	O
int	O
)	O
even_order	long
,	O
tt	pointer
,	O
dd	pointer
,	O
ee	pointer
,	O
e2	pointer
)	O
;	O
if	O
(	O
status	int
)	O
{	O
GSL_ERROR	O
(	O
"Internal error in tridiagonal Mathieu matrix"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
even_order	long
*	O
even_order	long
;	O
ii	int
++	O
)	O
zz	pointer
[	O
ii	int
]	O
=	O
0.0	int
;	O
zz	pointer
[	O
0	int
]	O
=	O
dd	pointer
[	O
0	int
]	O
;	O
zz	pointer
[	O
1	int
]	O
=	O
ee	pointer
[	O
1	int
]	O
;	O
for	O
(	O
ii	int
=	O
1	int
;	O
ii	int
<	O
even_order	long
-	O
1	int
;	O
ii	int
++	O
)	O
{	O
zz	pointer
[	O
ii	int
*	O
even_order	long
+	O
ii	int
-	O
1	int
]	O
=	O
ee	pointer
[	O
ii	int
]	O
;	O
zz	pointer
[	O
ii	int
*	O
even_order	long
+	O
ii	int
]	O
=	O
dd	pointer
[	O
ii	int
]	O
;	O
zz	pointer
[	O
ii	int
*	O
even_order	long
+	O
ii	int
+	O
1	int
]	O
=	O
ee	pointer
[	O
ii	int
+	O
1	int
]	O
;	O
}	O
zz	pointer
[	O
even_order	long
*	O
(	O
even_order	long
-	O
1	int
)	O
+	O
even_order	long
-	O
2	int
]	O
=	O
ee	pointer
[	O
even_order	long
-	O
1	int
]	O
;	O
zz	pointer
[	O
even_order	long
*	O
even_order	long
-	O
1	int
]	O
=	O
dd	pointer
[	O
even_order	long
-	O
1	int
]	O
;	O
mat	struct
=	O
gsl_matrix_view_array	function
(	O
zz	pointer
,	O
even_order	long
,	O
even_order	long
)	O
;	O
eval	pointer
=	O
gsl_vector_subvector	function
(	O
work	pointer
->	O
eval	pointer
,	O
0	int
,	O
even_order	long
)	O
;	O
evec	pointer
=	O
gsl_matrix_submatrix	function
(	O
work	pointer
->	O
evec	pointer
,	O
0	int
,	O
0	int
,	O
even_order	long
,	O
even_order	long
)	O
;	O
gsl_eigen_symmv	function
(	O
&	O
mat	struct
.	O
matrix	struct
,	O
&	O
eval	pointer
.	O
vector	struct
,	O
&	O
evec	pointer
.	O
matrix	struct
,	O
wmat	pointer
)	O
;	O
gsl_eigen_symmv_sort	function
(	O
&	O
eval	pointer
.	O
vector	struct
,	O
&	O
evec	pointer
.	O
matrix	struct
,	O
GSL_EIGEN_SORT_VAL_ASC	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
even_order	long
-	O
extra_values	int
;	O
ii	int
++	O
)	O
aa	pointer
[	O
2	int
*	O
ii	int
]	O
=	O
gsl_vector_get	function
(	O
&	O
eval	pointer
.	O
vector	struct
,	O
ii	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
*	O
odd_order	long
;	O
ii	int
++	O
)	O
zz	pointer
[	O
ii	int
]	O
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
;	O
ii	int
++	O
)	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
odd_order	long
;	O
jj	int
++	O
)	O
{	O
if	O
(	O
ii	int
==	O
jj	int
)	O
zz	pointer
[	O
ii	int
*	O
odd_order	long
+	O
jj	int
]	O
=	O
(	O
2	int
*	O
ii	int
+	O
1	int
)	O
*	O
(	O
2	int
*	O
ii	int
+	O
1	int
)	O
;	O
else	O
if	O
(	O
ii	int
==	O
jj	int
+	O
1	int
||	O
ii	int
+	O
1	int
==	O
jj	int
)	O
zz	pointer
[	O
ii	int
*	O
odd_order	long
+	O
jj	int
]	O
=	O
qq	double
;	O
}	O
zz	pointer
[	O
0	int
]	O
+=	O
qq	double
;	O
mat	struct
=	O
gsl_matrix_view_array	function
(	O
zz	pointer
,	O
odd_order	long
,	O
odd_order	long
)	O
;	O
eval	pointer
=	O
gsl_vector_subvector	function
(	O
work	pointer
->	O
eval	pointer
,	O
0	int
,	O
odd_order	long
)	O
;	O
evec	pointer
=	O
gsl_matrix_submatrix	function
(	O
work	pointer
->	O
evec	pointer
,	O
0	int
,	O
0	int
,	O
odd_order	long
,	O
odd_order	long
)	O
;	O
gsl_eigen_symmv	function
(	O
&	O
mat	struct
.	O
matrix	struct
,	O
&	O
eval	pointer
.	O
vector	struct
,	O
&	O
evec	pointer
.	O
matrix	struct
,	O
wmat	pointer
)	O
;	O
gsl_eigen_symmv_sort	function
(	O
&	O
eval	pointer
.	O
vector	struct
,	O
&	O
evec	pointer
.	O
matrix	struct
,	O
GSL_EIGEN_SORT_VAL_ASC	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
-	O
extra_values	int
;	O
ii	int
++	O
)	O
aa	pointer
[	O
2	int
*	O
ii	int
+	O
1	int
]	O
=	O
gsl_vector_get	function
(	O
&	O
eval	pointer
.	O
vector	struct
,	O
ii	int
)	O
;	O
for	O
(	O
ii	int
=	O
order_min	int
;	O
ii	int
<=	O
order_max	int
;	O
ii	int
++	O
)	O
{	O
result_array	array
[	O
ii	int
-	O
order_min	int
]	O
=	O
aa	pointer
[	O
ii	int
]	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_mathieu_b_array	function
(	O
int	O
order_min	int
,	O
int	O
order_max	int
,	O
double	O
qq	double
,	O
gsl_sf_mathieu_workspace	struct
*	O
work	pointer
,	O
double	O
result_array	array
[	O
]	O
)	O
{	O
unsigned	O
int	O
even_order	long
=	O
work	pointer
->	O
even_order	long
-	O
1	int
,	O
odd_order	long
=	O
work	pointer
->	O
odd_order	long
,	O
extra_values	int
=	O
work	pointer
->	O
extra_values	int
,	O
ii	int
,	O
jj	int
;	O
double	O
*	O
zz	pointer
=	O
work	pointer
->	O
zz	pointer
,	O
*	O
bb	pointer
=	O
work	pointer
->	O
bb	pointer
;	O
gsl_matrix_view	struct
mat	struct
,	O
evec	pointer
;	O
gsl_vector_view	struct
eval	pointer
;	O
gsl_eigen_symmv_workspace	struct
*	O
wmat	pointer
=	O
work	pointer
->	O
wmat	pointer
;	O
if	O
(	O
order_max	int
>	O
work	pointer
->	O
size	long
||	O
order_max	int
<=	O
order_min	int
||	O
order_min	int
<	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"invalid range [order_min,order_max]"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
even_order	long
*	O
even_order	long
;	O
ii	int
++	O
)	O
zz	pointer
[	O
ii	int
]	O
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
even_order	long
;	O
ii	int
++	O
)	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
even_order	long
;	O
jj	int
++	O
)	O
{	O
if	O
(	O
ii	int
==	O
jj	int
)	O
zz	pointer
[	O
ii	int
*	O
even_order	long
+	O
jj	int
]	O
=	O
4	int
*	O
(	O
ii	int
+	O
1	int
)	O
*	O
(	O
ii	int
+	O
1	int
)	O
;	O
else	O
if	O
(	O
ii	int
==	O
jj	int
+	O
1	int
||	O
ii	int
+	O
1	int
==	O
jj	int
)	O
zz	pointer
[	O
ii	int
*	O
even_order	long
+	O
jj	int
]	O
=	O
qq	double
;	O
}	O
mat	struct
=	O
gsl_matrix_view_array	function
(	O
zz	pointer
,	O
even_order	long
,	O
even_order	long
)	O
;	O
eval	pointer
=	O
gsl_vector_subvector	function
(	O
work	pointer
->	O
eval	pointer
,	O
0	int
,	O
even_order	long
)	O
;	O
evec	pointer
=	O
gsl_matrix_submatrix	function
(	O
work	pointer
->	O
evec	pointer
,	O
0	int
,	O
0	int
,	O
even_order	long
,	O
even_order	long
)	O
;	O
gsl_eigen_symmv	function
(	O
&	O
mat	struct
.	O
matrix	struct
,	O
&	O
eval	pointer
.	O
vector	struct
,	O
&	O
evec	pointer
.	O
matrix	struct
,	O
wmat	pointer
)	O
;	O
gsl_eigen_symmv_sort	function
(	O
&	O
eval	pointer
.	O
vector	struct
,	O
&	O
evec	pointer
.	O
matrix	struct
,	O
GSL_EIGEN_SORT_VAL_ASC	int
)	O
;	O
bb	pointer
[	O
0	int
]	O
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
even_order	long
-	O
extra_values	int
;	O
ii	int
++	O
)	O
bb	pointer
[	O
2	int
*	O
(	O
ii	int
+	O
1	int
)	O
]	O
=	O
gsl_vector_get	function
(	O
&	O
eval	pointer
.	O
vector	struct
,	O
ii	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
*	O
odd_order	long
;	O
ii	int
++	O
)	O
zz	pointer
[	O
ii	int
]	O
=	O
0.0	int
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
;	O
ii	int
++	O
)	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
odd_order	long
;	O
jj	int
++	O
)	O
{	O
if	O
(	O
ii	int
==	O
jj	int
)	O
zz	pointer
[	O
ii	int
*	O
odd_order	long
+	O
jj	int
]	O
=	O
(	O
2	int
*	O
ii	int
+	O
1	int
)	O
*	O
(	O
2	int
*	O
ii	int
+	O
1	int
)	O
;	O
else	O
if	O
(	O
ii	int
==	O
jj	int
+	O
1	int
||	O
ii	int
+	O
1	int
==	O
jj	int
)	O
zz	pointer
[	O
ii	int
*	O
odd_order	long
+	O
jj	int
]	O
=	O
qq	double
;	O
}	O
zz	pointer
[	O
0	int
]	O
-=	O
qq	double
;	O
mat	struct
=	O
gsl_matrix_view_array	function
(	O
zz	pointer
,	O
odd_order	long
,	O
odd_order	long
)	O
;	O
eval	pointer
=	O
gsl_vector_subvector	function
(	O
work	pointer
->	O
eval	pointer
,	O
0	int
,	O
odd_order	long
)	O
;	O
evec	pointer
=	O
gsl_matrix_submatrix	function
(	O
work	pointer
->	O
evec	pointer
,	O
0	int
,	O
0	int
,	O
odd_order	long
,	O
odd_order	long
)	O
;	O
gsl_eigen_symmv	function
(	O
&	O
mat	struct
.	O
matrix	struct
,	O
&	O
eval	pointer
.	O
vector	struct
,	O
&	O
evec	pointer
.	O
matrix	struct
,	O
wmat	pointer
)	O
;	O
gsl_eigen_symmv_sort	function
(	O
&	O
eval	pointer
.	O
vector	struct
,	O
&	O
evec	pointer
.	O
matrix	struct
,	O
GSL_EIGEN_SORT_VAL_ASC	int
)	O
;	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
odd_order	long
-	O
extra_values	int
;	O
ii	int
++	O
)	O
bb	pointer
[	O
2	int
*	O
ii	int
+	O
1	int
]	O
=	O
gsl_vector_get	function
(	O
&	O
eval	pointer
.	O
vector	struct
,	O
ii	int
)	O
;	O
for	O
(	O
ii	int
=	O
order_min	int
;	O
ii	int
<=	O
order_max	int
;	O
ii	int
++	O
)	O
{	O
result_array	array
[	O
ii	int
-	O
order_min	int
]	O
=	O
bb	pointer
[	O
ii	int
]	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
double	O
gsl_sf_mathieu_a	function
(	O
int	O
order	enum
,	O
double	O
qq	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_mathieu_a_e	function
(	O
order	enum
,	O
qq	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_mathieu_b	function
(	O
int	O
order	enum
,	O
double	O
qq	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_mathieu_b_e	function
(	O
order	enum
,	O
qq	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
