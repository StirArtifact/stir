bool	bool
debug	bool
=	O
false	int
;	O
int	O
nsock	int
,	O
maxsock	int
;	O
fd_set	struct
allsock	struct
;	O
int	O
options	pointer
;	O
int	O
timingout	int
;	O
int	O
toomany	int
=	O
TOOMANY	int
;	O
char	O
*	O
*	O
Argv	pointer
;	O
char	O
*	O
LastArg	pointer
;	O
char	O
*	O
*	O
config_files	pointer
;	O
static	O
bool	bool
env_option	bool
=	O
false	int
;	O
static	O
bool	bool
resolve_option	bool
=	O
false	int
;	O
static	O
bool	bool
pidfile_option	bool
=	O
true	int
;	O
static	O
const	O
char	O
*	O
pid_file	pointer
=	O
PATH_INETDPID	O
;	O
const	O
char	O
args_doc	pointer
[	O
]	O
=	O
"[CONF-FILE [CONF-DIR]]..."	pointer
;	O
const	O
char	O
doc	pointer
[	O
]	O
=	O
"Internet super-server."	pointer
;	O
enum	O
{	O
OPT_ENVIRON	int
=	O
256	int
,	O
OPT_RESOLVE	int
}	O
;	O
const	O
char	O
*	O
program_authors	array
[	O
]	O
=	O
{	O
"Alain Magloire"	pointer
,	O
"Alfred M. Szmidt"	pointer
,	O
"Debarshi Ray"	pointer
,	O
"Jakob 'sparky' Kaivo"	pointer
,	O
"Jeff Bailey"	pointer
,	O
"Jeroen Dekkers"	pointer
,	O
"Marcus Brinkmann"	pointer
,	O
"Sergey Poznyakoff"	pointer
,	O
"others"	pointer
,	O
NULL	O
}	O
;	O
static	O
struct	O
argp_option	struct
argp_options	array
[	O
]	O
=	O
{	O
{	O
"debug"	pointer
,	O
'd'	O
,	O
NULL	O
,	O
0	int
,	O
"turn on debugging, run in foreground mode"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"environment"	pointer
,	O
OPT_ENVIRON	int
,	O
NULL	O
,	O
0	int
,	O
"pass local and remote socket information in environment variables"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"pidfile"	pointer
,	O
'p'	O
,	O
"PIDFILE"	pointer
,	O
OPTION_ARG_OPTIONAL	int
,	O
"override pidfile (default: \""	pointer
PATH_INETDPID	O
"\")"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"rate"	pointer
,	O
'R'	O
,	O
"NUMBER"	pointer
,	O
0	int
,	O
"maximum invocation rate (per minute)"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
"resolve"	pointer
,	O
OPT_RESOLVE	int
,	O
NULL	O
,	O
0	int
,	O
"resolve IP addresses when setting environment variables "	pointer
"(see --environment)"	pointer
,	O
GRP	int
+	O
1	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
error_t	int
parse_opt	function
(	O
int	O
key	int
,	O
char	O
*	O
arg	pointer
,	O
struct	O
argp_state	struct
*	O
state	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
int	O
number	int
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
'd'	O
:	O
debug	bool
=	O
true	int
;	O
options	pointer
|=	O
SO_DEBUG	int
;	O
break	O
;	O
case	O
OPT_ENVIRON	int
:	O
env_option	bool
=	O
true	int
;	O
break	O
;	O
case	O
'p'	O
:	O
if	O
(	O
arg	pointer
&&	O
strlen	function
(	O
arg	pointer
)	O
)	O
pid_file	pointer
=	O
arg	pointer
;	O
else	O
pidfile_option	bool
=	O
false	int
;	O
break	O
;	O
case	O
'R'	O
:	O
number	int
=	O
strtol	function
(	O
arg	pointer
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
number	int
<	O
1	int
||	O
*	O
p	pointer
)	O
syslog	function
(	O
LOG_ERR	int
,	O
"-R %s: bad value for service invocation rate"	pointer
,	O
arg	pointer
)	O
;	O
else	O
toomany	int
=	O
number	int
;	O
break	O
;	O
case	O
OPT_RESOLVE	int
:	O
resolve_option	bool
=	O
true	int
;	O
break	O
;	O
default	O
:	O
return	O
ARGP_ERR_UNKNOWN	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
argp	struct
argp	struct
=	O
{	O
argp_options	array
,	O
parse_opt	function
,	O
args_doc	pointer
,	O
doc	pointer
}	O
;	O
struct	O
servtab	struct
{	O
const	O
char	O
*	O
se_file	pointer
;	O
int	O
se_line	int
;	O
char	O
*	O
se_node	pointer
;	O
char	O
*	O
se_service	pointer
;	O
int	O
se_socktype	int
;	O
char	O
*	O
se_proto	pointer
;	O
pid_t	int
se_wait	int
;	O
unsigned	O
se_max	int
;	O
short	O
se_checked	short
;	O
char	O
*	O
se_user	pointer
;	O
struct	O
biltin	struct
*	O
se_bi	pointer
;	O
char	O
*	O
se_server	pointer
;	O
char	O
*	O
*	O
se_argv	pointer
;	O
size_t	long
se_argc	long
;	O
int	O
se_fd	int
;	O
int	O
se_type	int
;	O
sa_family_t	short
se_family	short
;	O
char	O
se_v4mapped	char
;	O
struct	O
sockaddr_storage	struct
se_ctrladdr	struct
;	O
socklen_t	int
se_addrlen	int
;	O
unsigned	O
se_refcnt	int
;	O
int	O
se_count	int
;	O
struct	O
timeval	struct
se_time	struct
;	O
struct	O
servtab	struct
*	O
se_next	pointer
;	O
}	O
*	O
servtab	struct
;	O
void	O
chargen_dg	function
(	O
int	O
,	O
struct	O
servtab	struct
*	O
)	O
;	O
void	O
chargen_stream	function
(	O
int	O
,	O
struct	O
servtab	struct
*	O
)	O
;	O
void	O
daytime_dg	function
(	O
int	O
,	O
struct	O
servtab	struct
*	O
)	O
;	O
void	O
daytime_stream	function
(	O
int	O
,	O
struct	O
servtab	struct
*	O
)	O
;	O
void	O
discard_dg	function
(	O
int	O
,	O
struct	O
servtab	struct
*	O
)	O
;	O
void	O
discard_stream	function
(	O
int	O
,	O
struct	O
servtab	struct
*	O
)	O
;	O
void	O
echo_dg	function
(	O
int	O
,	O
struct	O
servtab	struct
*	O
)	O
;	O
void	O
echo_stream	function
(	O
int	O
,	O
struct	O
servtab	struct
*	O
)	O
;	O
void	O
machtime_dg	function
(	O
int	O
,	O
struct	O
servtab	struct
*	O
)	O
;	O
void	O
machtime_stream	function
(	O
int	O
,	O
struct	O
servtab	struct
*	O
)	O
;	O
void	O
tcpmux	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
;	O
struct	O
biltin	struct
{	O
const	O
char	O
*	O
bi_service	pointer
;	O
int	O
bi_socktype	int
;	O
short	O
bi_fork	short
;	O
short	O
bi_wait	short
;	O
void	O
(	O
*	O
bi_fn	pointer
)	O
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
)	O
;	O
}	O
biltins	array
[	O
]	O
=	O
{	O
{	O
"echo"	pointer
,	O
SOCK_STREAM	int
,	O
1	int
,	O
0	int
,	O
echo_stream	function
}	O
,	O
{	O
"echo"	pointer
,	O
SOCK_DGRAM	int
,	O
0	int
,	O
0	int
,	O
echo_dg	function
}	O
,	O
{	O
"discard"	pointer
,	O
SOCK_STREAM	int
,	O
1	int
,	O
0	int
,	O
discard_stream	function
}	O
,	O
{	O
"discard"	pointer
,	O
SOCK_DGRAM	int
,	O
0	int
,	O
0	int
,	O
discard_dg	function
}	O
,	O
{	O
"time"	pointer
,	O
SOCK_STREAM	int
,	O
0	int
,	O
0	int
,	O
machtime_stream	function
}	O
,	O
{	O
"time"	pointer
,	O
SOCK_DGRAM	int
,	O
0	int
,	O
0	int
,	O
machtime_dg	function
}	O
,	O
{	O
"daytime"	pointer
,	O
SOCK_STREAM	int
,	O
0	int
,	O
0	int
,	O
daytime_stream	function
}	O
,	O
{	O
"daytime"	pointer
,	O
SOCK_DGRAM	int
,	O
0	int
,	O
0	int
,	O
daytime_dg	function
}	O
,	O
{	O
"chargen"	pointer
,	O
SOCK_STREAM	int
,	O
1	int
,	O
0	int
,	O
chargen_stream	function
}	O
,	O
{	O
"chargen"	pointer
,	O
SOCK_DGRAM	int
,	O
0	int
,	O
0	int
,	O
chargen_dg	function
}	O
,	O
{	O
"tcpmux"	pointer
,	O
SOCK_STREAM	int
,	O
1	int
,	O
0	int
,	O
tcpmux	function
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NULL	O
}	O
}	O
;	O
struct	O
biltin	struct
*	O
bi_lookup	function
(	O
const	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
struct	O
biltin	struct
*	O
bi	pointer
;	O
for	O
(	O
bi	pointer
=	O
biltins	array
;	O
bi	pointer
->	O
bi_service	pointer
;	O
bi	pointer
++	O
)	O
if	O
(	O
bi	pointer
->	O
bi_socktype	int
==	O
sep	pointer
->	O
se_socktype	int
&&	O
strcmp	function
(	O
bi	pointer
->	O
bi_service	pointer
,	O
sep	pointer
->	O
se_service	pointer
)	O
==	O
0	int
)	O
return	O
bi	pointer
;	O
return	O
NULL	O
;	O
}	O
void	O
signal_set_handler	function
(	O
int	O
signo	int
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
)	O
)	O
{	O
struct	O
sigaction	struct
sa	struct
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
&	O
sa	struct
,	O
0	int
,	O
sizeof	O
(	O
sa	struct
)	O
)	O
;	O
sigemptyset	function
(	O
&	O
sa	struct
.	O
sa_mask	struct
)	O
;	O
sigaddset	function
(	O
&	O
sa	struct
.	O
sa_mask	struct
,	O
signo	int
)	O
;	O
sa	struct
.	O
sa_flags	int
=	O
SA_RESTART	int
;	O
sa	struct
.	O
sa_handler	pointer
=	O
handler	pointer
;	O
sigaction	struct
(	O
signo	int
,	O
&	O
sa	struct
,	O
NULL	O
)	O
;	O
}	O
void	O
signal_block	function
(	O
SIGSTATUS	O
*	O
old_status	pointer
)	O
{	O
sigset_t	struct
sigs	struct
;	O
sigemptyset	function
(	O
&	O
sigs	struct
)	O
;	O
sigaddset	function
(	O
&	O
sigs	struct
,	O
SIGCHLD	int
)	O
;	O
sigaddset	function
(	O
&	O
sigs	struct
,	O
SIGHUP	int
)	O
;	O
sigaddset	function
(	O
&	O
sigs	struct
,	O
SIGALRM	int
)	O
;	O
sigprocmask	function
(	O
SIG_BLOCK	int
,	O
&	O
sigs	struct
,	O
old_status	pointer
)	O
;	O
}	O
void	O
signal_unblock	function
(	O
SIGSTATUS	O
*	O
status	int
)	O
{	O
if	O
(	O
status	int
)	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
status	int
,	O
0	int
)	O
;	O
else	O
{	O
sigset_t	struct
empty	struct
;	O
sigemptyset	function
(	O
&	O
empty	struct
)	O
;	O
sigprocmask	function
(	O
SIG_SETMASK	int
,	O
&	O
empty	struct
,	O
0	int
)	O
;	O
}	O
}	O
void	O
run_service	function
(	O
int	O
ctrl	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pwd	pointer
;	O
char	O
buf	array
[	O
50	int
]	O
;	O
if	O
(	O
sep	pointer
->	O
se_bi	pointer
)	O
{	O
(	O
*	O
sep	pointer
->	O
se_bi	pointer
->	O
bi_fn	pointer
)	O
(	O
ctrl	int
,	O
sep	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%d execl %s\n"	pointer
,	O
getpid	function
(	O
)	O
,	O
sep	pointer
->	O
se_server	pointer
)	O
;	O
dup2	function
(	O
ctrl	int
,	O
0	int
)	O
;	O
close	pointer
(	O
ctrl	int
)	O
;	O
dup2	function
(	O
0	int
,	O
1	int
)	O
;	O
dup2	function
(	O
0	int
,	O
2	int
)	O
;	O
if	O
(	O
(	O
pwd	pointer
=	O
getpwnam	function
(	O
sep	pointer
->	O
se_user	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s/%s: %s: No such user"	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
sep	pointer
->	O
se_proto	pointer
,	O
sep	pointer
->	O
se_user	pointer
)	O
;	O
if	O
(	O
sep	pointer
->	O
se_socktype	int
!=	O
SOCK_STREAM	int
)	O
recv	function
(	O
0	int
,	O
buf	array
,	O
sizeof	O
buf	array
,	O
0	int
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
pwd	pointer
->	O
pw_uid	int
)	O
{	O
if	O
(	O
setgid	function
(	O
pwd	pointer
->	O
pw_gid	int
)	O
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s: can't set gid %d: %m"	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
pwd	pointer
->	O
pw_gid	int
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
initgroups	function
(	O
pwd	pointer
->	O
pw_name	pointer
,	O
pwd	pointer
->	O
pw_gid	int
)	O
;	O
if	O
(	O
setuid	function
(	O
pwd	pointer
->	O
pw_uid	int
)	O
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s: can't set uid %d: %m"	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
pwd	pointer
->	O
pw_uid	int
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
}	O
execv	function
(	O
sep	pointer
->	O
se_server	pointer
,	O
sep	pointer
->	O
se_argv	pointer
)	O
;	O
if	O
(	O
sep	pointer
->	O
se_socktype	int
!=	O
SOCK_STREAM	int
)	O
recv	function
(	O
0	int
,	O
buf	array
,	O
sizeof	O
buf	array
,	O
0	int
)	O
;	O
syslog	function
(	O
LOG_ERR	int
,	O
"cannot execute %s: %m"	pointer
,	O
sep	pointer
->	O
se_server	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
}	O
void	O
reapchild	function
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
int	O
status	int
;	O
pid_t	int
pid	int
;	O
struct	O
servtab	struct
*	O
sep	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
pid	int
=	O
wait3	function
(	O
&	O
status	int
,	O
WNOHANG	int
,	O
NULL	O
)	O
;	O
if	O
(	O
pid	int
<=	O
0	int
)	O
break	O
;	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%d reaped, status %#x\n"	pointer
,	O
pid	int
,	O
status	int
)	O
;	O
for	O
(	O
sep	pointer
=	O
servtab	struct
;	O
sep	pointer
;	O
sep	pointer
=	O
sep	pointer
->	O
se_next	pointer
)	O
if	O
(	O
sep	pointer
->	O
se_wait	int
==	O
pid	int
)	O
{	O
if	O
(	O
status	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"%s: exit status 0x%x"	pointer
,	O
sep	pointer
->	O
se_server	pointer
,	O
status	int
)	O
;	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"restored %s, fd %d\n"	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
sep	pointer
->	O
se_fd	int
)	O
;	O
FD_SET	O
(	O
sep	pointer
->	O
se_fd	int
,	O
&	O
allsock	struct
)	O
;	O
nsock	int
++	O
;	O
sep	pointer
->	O
se_wait	int
=	O
1	int
;	O
}	O
}	O
}	O
char	O
*	O
newstr	function
(	O
const	O
char	O
*	O
cp	pointer
)	O
{	O
char	O
*	O
s	int
;	O
if	O
(	O
(	O
s	int
=	O
strdup	function
(	O
cp	pointer
?	O
cp	pointer
:	O
""	pointer
)	O
)	O
)	O
return	O
s	int
;	O
syslog	function
(	O
LOG_ERR	int
,	O
"strdup: %m"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
void	O
dupmem	function
(	O
void	O
*	O
*	O
pptr	pointer
,	O
size_t	long
size	long
)	O
{	O
void	O
*	O
ptr	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
!	O
ptr	pointer
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"dupmem: %m"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
memcpy	function
(	O
ptr	pointer
,	O
*	O
pptr	pointer
,	O
size	long
)	O
;	O
*	O
pptr	pointer
=	O
ptr	pointer
;	O
}	O
void	O
dupstr	function
(	O
char	O
*	O
*	O
pstr	pointer
)	O
{	O
if	O
(	O
*	O
pstr	pointer
)	O
dupmem	function
(	O
(	O
void	O
*	O
*	O
)	O
pstr	pointer
,	O
strlen	function
(	O
*	O
pstr	pointer
)	O
+	O
1	int
)	O
;	O
}	O
void	O
print_service	function
(	O
const	O
char	O
*	O
action	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:%d: %s: %s:%s proto=%s, wait=%d, max=%u, user=%s builtin=%s server=%s\n"	pointer
,	O
sep	pointer
->	O
se_file	pointer
,	O
sep	pointer
->	O
se_line	int
,	O
action	int
,	O
ISMUX	O
(	O
sep	pointer
)	O
?	O
(	O
ISMUXPLUS	O
(	O
sep	pointer
)	O
?	O
"tcpmuxplus"	pointer
:	O
"tcpmux"	pointer
)	O
:	O
(	O
sep	pointer
->	O
se_node	pointer
?	O
sep	pointer
->	O
se_node	pointer
:	O
"*"	pointer
)	O
,	O
sep	pointer
->	O
se_service	pointer
,	O
sep	pointer
->	O
se_proto	pointer
,	O
sep	pointer
->	O
se_wait	int
,	O
sep	pointer
->	O
se_max	int
,	O
sep	pointer
->	O
se_user	pointer
,	O
sep	pointer
->	O
se_bi	pointer
?	O
sep	pointer
->	O
se_bi	pointer
->	O
bi_service	pointer
:	O
"no"	pointer
,	O
sep	pointer
->	O
se_server	pointer
)	O
;	O
}	O
int	O
setup	function
(	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
int	O
err	long
;	O
int	O
on	int
=	O
1	int
;	O
tryagain	O
:	O
sep	pointer
->	O
se_fd	int
=	O
socket	function
(	O
sep	pointer
->	O
se_family	short
,	O
sep	pointer
->	O
se_socktype	int
,	O
0	int
)	O
;	O
if	O
(	O
sep	pointer
->	O
se_fd	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EAFNOSUPPORT	int
&&	O
sep	pointer
->	O
se_family	short
==	O
AF_INET6	O
&&	O
sep	pointer
->	O
se_v4mapped	char
)	O
{	O
sep	pointer
->	O
se_family	short
=	O
AF_INET	O
;	O
goto	O
tryagain	O
;	O
}	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"socket failed on %s/%s: %s\n"	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
sep	pointer
->	O
se_proto	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s/%s: socket: %m"	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
sep	pointer
->	O
se_proto	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
sep	pointer
->	O
se_family	short
==	O
AF_INET6	O
)	O
{	O
int	O
val	array
=	O
sep	pointer
->	O
se_v4mapped	char
?	O
0	int
:	O
1	int
;	O
if	O
(	O
setsockopt	function
(	O
sep	pointer
->	O
se_fd	int
,	O
IPPROTO_IPV6	int
,	O
IPV6_V6ONLY	int
,	O
(	O
char	O
*	O
)	O
&	O
val	array
,	O
sizeof	O
(	O
val	array
)	O
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_ERR	int
,	O
"setsockopt (IPV6_V6ONLY): %m"	pointer
)	O
;	O
}	O
if	O
(	O
strncmp	function
(	O
sep	pointer
->	O
se_proto	pointer
,	O
"tcp"	pointer
,	O
3	int
)	O
==	O
0	int
&&	O
(	O
options	pointer
&	O
SO_DEBUG	int
)	O
)	O
{	O
if	O
(	O
setsockopt	function
(	O
sep	pointer
->	O
se_fd	int
,	O
SOL_SOCKET	int
,	O
SO_DEBUG	int
,	O
(	O
char	O
*	O
)	O
&	O
on	int
,	O
sizeof	O
(	O
on	int
)	O
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_ERR	int
,	O
"setsockopt (SO_DEBUG): %m"	pointer
)	O
;	O
}	O
err	long
=	O
setsockopt	function
(	O
sep	pointer
->	O
se_fd	int
,	O
SOL_SOCKET	int
,	O
SO_REUSEADDR	int
,	O
(	O
char	O
*	O
)	O
&	O
on	int
,	O
sizeof	O
(	O
on	int
)	O
)	O
;	O
if	O
(	O
err	long
<	O
0	int
)	O
syslog	function
(	O
LOG_ERR	int
,	O
"setsockopt (SO_REUSEADDR): %m"	pointer
)	O
;	O
err	long
=	O
bind	function
(	O
sep	pointer
->	O
se_fd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sep	pointer
->	O
se_ctrladdr	struct
,	O
sep	pointer
->	O
se_addrlen	int
)	O
;	O
if	O
(	O
err	long
<	O
0	int
)	O
{	O
if	O
(	O
(	O
errno	O
==	O
EADDRNOTAVAIL	int
||	O
errno	O
==	O
EAFNOSUPPORT	int
)	O
&&	O
sep	pointer
->	O
se_family	short
==	O
AF_INET6	O
&&	O
sep	pointer
->	O
se_v4mapped	char
)	O
{	O
sep	pointer
->	O
se_family	short
=	O
AF_INET	O
;	O
close	pointer
(	O
sep	pointer
->	O
se_fd	int
)	O
;	O
goto	O
tryagain	O
;	O
}	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"bind failed on %s/%s: %s\n"	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
sep	pointer
->	O
se_proto	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s/%s: bind: %m"	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
sep	pointer
->	O
se_proto	pointer
)	O
;	O
close	pointer
(	O
sep	pointer
->	O
se_fd	int
)	O
;	O
sep	pointer
->	O
se_fd	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
timingout	int
)	O
{	O
timingout	int
=	O
1	int
;	O
alarm	function
(	O
RETRYTIME	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
servent_setup	function
(	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
sep	pointer
->	O
se_checked	short
=	O
1	int
;	O
if	O
(	O
sep	pointer
->	O
se_fd	int
==	O
-	O
1	int
&&	O
setup	function
(	O
sep	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
sep	pointer
->	O
se_socktype	int
==	O
SOCK_STREAM	int
)	O
listen	function
(	O
sep	pointer
->	O
se_fd	int
,	O
10	int
)	O
;	O
FD_SET	O
(	O
sep	pointer
->	O
se_fd	int
,	O
&	O
allsock	struct
)	O
;	O
nsock	int
++	O
;	O
if	O
(	O
sep	pointer
->	O
se_fd	int
>	O
maxsock	int
)	O
maxsock	int
=	O
sep	pointer
->	O
se_fd	int
;	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"registered %s on %d\n"	pointer
,	O
sep	pointer
->	O
se_server	pointer
,	O
sep	pointer
->	O
se_fd	int
)	O
;	O
}	O
}	O
void	O
retry	function
(	O
int	O
signo	int
_GL_UNUSED_PARAMETER	O
)	O
{	O
struct	O
servtab	struct
*	O
sep	pointer
;	O
timingout	int
=	O
0	int
;	O
for	O
(	O
sep	pointer
=	O
servtab	struct
;	O
sep	pointer
;	O
sep	pointer
=	O
sep	pointer
->	O
se_next	pointer
)	O
if	O
(	O
sep	pointer
->	O
se_fd	int
==	O
-	O
1	int
&&	O
!	O
ISMUX	O
(	O
sep	pointer
)	O
)	O
setup	function
(	O
sep	pointer
)	O
;	O
}	O
void	O
close_sep	function
(	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
if	O
(	O
sep	pointer
->	O
se_fd	int
>=	O
0	int
)	O
{	O
nsock	int
--	O
;	O
FD_CLR	O
(	O
sep	pointer
->	O
se_fd	int
,	O
&	O
allsock	struct
)	O
;	O
close	pointer
(	O
sep	pointer
->	O
se_fd	int
)	O
;	O
sep	pointer
->	O
se_fd	int
=	O
-	O
1	int
;	O
}	O
sep	pointer
->	O
se_count	int
=	O
0	int
;	O
if	O
(	O
sep	pointer
->	O
se_wait	int
>	O
1	int
)	O
sep	pointer
->	O
se_wait	int
=	O
1	int
;	O
}	O
struct	O
servtab	struct
*	O
enter	function
(	O
struct	O
servtab	struct
*	O
cp	pointer
)	O
{	O
struct	O
servtab	struct
*	O
sep	pointer
;	O
SIGSTATUS	O
sigstatus	struct
;	O
int	O
i	int
;	O
for	O
(	O
sep	pointer
=	O
servtab	struct
;	O
sep	pointer
;	O
sep	pointer
=	O
sep	pointer
->	O
se_next	pointer
)	O
if	O
(	O
memcmp	function
(	O
&	O
sep	pointer
->	O
se_ctrladdr	struct
,	O
&	O
cp	pointer
->	O
se_ctrladdr	struct
,	O
sizeof	O
(	O
sep	pointer
->	O
se_ctrladdr	struct
)	O
)	O
==	O
0	int
&&	O
strcmp	function
(	O
sep	pointer
->	O
se_service	pointer
,	O
cp	pointer
->	O
se_service	pointer
)	O
==	O
0	int
&&	O
strcmp	function
(	O
sep	pointer
->	O
se_proto	pointer
,	O
cp	pointer
->	O
se_proto	pointer
)	O
==	O
0	int
&&	O
ISMUX	O
(	O
sep	pointer
)	O
==	O
ISMUX	O
(	O
cp	pointer
)	O
)	O
break	O
;	O
if	O
(	O
sep	pointer
!=	O
0	int
)	O
{	O
signal_block	function
(	O
&	O
sigstatus	struct
)	O
;	O
if	O
(	O
cp	pointer
->	O
se_bi	pointer
==	O
0	int
&&	O
(	O
sep	pointer
->	O
se_wait	int
==	O
1	int
||	O
cp	pointer
->	O
se_wait	int
==	O
0	int
)	O
)	O
sep	pointer
->	O
se_wait	int
=	O
cp	pointer
->	O
se_wait	int
;	O
if	O
(	O
cp	pointer
->	O
se_user	pointer
)	O
SWAP	O
(	O
sep	pointer
->	O
se_user	pointer
,	O
cp	pointer
->	O
se_user	pointer
)	O
;	O
if	O
(	O
cp	pointer
->	O
se_server	pointer
)	O
SWAP	O
(	O
sep	pointer
->	O
se_server	pointer
,	O
cp	pointer
->	O
se_server	pointer
)	O
;	O
argcv_free	function
(	O
sep	pointer
->	O
se_argc	long
,	O
sep	pointer
->	O
se_argv	pointer
)	O
;	O
sep	pointer
->	O
se_argc	long
=	O
cp	pointer
->	O
se_argc	long
;	O
sep	pointer
->	O
se_argv	pointer
=	O
cp	pointer
->	O
se_argv	pointer
;	O
cp	pointer
->	O
se_argc	long
=	O
0	int
;	O
cp	pointer
->	O
se_argv	pointer
=	O
NULL	O
;	O
sep	pointer
->	O
se_checked	short
=	O
1	int
;	O
signal_unblock	function
(	O
&	O
sigstatus	struct
)	O
;	O
if	O
(	O
debug	bool
)	O
print_service	function
(	O
"REDO"	pointer
,	O
sep	pointer
)	O
;	O
return	O
sep	pointer
;	O
}	O
if	O
(	O
debug	bool
)	O
print_service	function
(	O
"ADD "	pointer
,	O
cp	pointer
)	O
;	O
sep	pointer
=	O
(	O
struct	O
servtab	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
*	O
sep	pointer
)	O
)	O
;	O
if	O
(	O
sep	pointer
==	O
NULL	O
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"Out of memory."	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
*	O
sep	pointer
=	O
*	O
cp	pointer
;	O
dupstr	function
(	O
&	O
sep	pointer
->	O
se_node	pointer
)	O
;	O
dupstr	function
(	O
&	O
sep	pointer
->	O
se_service	pointer
)	O
;	O
dupstr	function
(	O
&	O
sep	pointer
->	O
se_proto	pointer
)	O
;	O
dupstr	function
(	O
&	O
sep	pointer
->	O
se_user	pointer
)	O
;	O
dupstr	function
(	O
&	O
sep	pointer
->	O
se_server	pointer
)	O
;	O
dupmem	function
(	O
(	O
void	O
*	O
*	O
)	O
&	O
sep	pointer
->	O
se_argv	pointer
,	O
sep	pointer
->	O
se_argc	long
*	O
sizeof	O
(	O
sep	pointer
->	O
se_argv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sep	pointer
->	O
se_argc	long
;	O
i	int
++	O
)	O
dupstr	function
(	O
&	O
sep	pointer
->	O
se_argv	pointer
[	O
i	int
]	O
)	O
;	O
sep	pointer
->	O
se_fd	int
=	O
-	O
1	int
;	O
signal_block	function
(	O
&	O
sigstatus	struct
)	O
;	O
sep	pointer
->	O
se_next	pointer
=	O
servtab	struct
;	O
servtab	struct
=	O
sep	pointer
;	O
signal_unblock	function
(	O
&	O
sigstatus	struct
)	O
;	O
return	O
sep	pointer
;	O
}	O
int	O
inetd_getaddrinfo	function
(	O
struct	O
servtab	struct
*	O
sep	pointer
,	O
int	O
proto	int
,	O
struct	O
addrinfo	struct
*	O
*	O
result	pointer
)	O
{	O
struct	O
addrinfo	struct
hints	struct
;	O
bool	bool
numeric_address	bool
=	O
false	int
;	O
if	O
(	O
sep	pointer
->	O
se_node	pointer
&&	O
(	O
strspn	function
(	O
sep	pointer
->	O
se_node	pointer
,	O
IPV4_NUMCHARS	pointer
)	O
==	O
strlen	function
(	O
sep	pointer
->	O
se_node	pointer
)	O
||	O
(	O
strchr	function
(	O
sep	pointer
->	O
se_node	pointer
,	O
':'	O
)	O
&&	O
strspn	function
(	O
sep	pointer
->	O
se_node	pointer
,	O
IPV6_NUMCHARS	pointer
)	O
)	O
)	O
)	O
numeric_address	bool
=	O
true	int
;	O
else	O
if	O
(	O
debug	bool
&&	O
sep	pointer
->	O
se_node	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Resolving address: %s\n"	pointer
,	O
sep	pointer
->	O
se_node	pointer
)	O
;	O
memset	function
(	O
&	O
hints	struct
,	O
0	int
,	O
sizeof	O
(	O
hints	struct
)	O
)	O
;	O
hints	struct
.	O
ai_flags	int
=	O
AI_PASSIVE	int
;	O
if	O
(	O
sep	pointer
->	O
se_v4mapped	char
&&	O
(	O
sep	pointer
->	O
se_family	short
!=	O
AF_INET	O
)	O
)	O
hints	struct
.	O
ai_flags	int
|=	O
AI_V4MAPPED	int
;	O
if	O
(	O
numeric_address	bool
)	O
hints	struct
.	O
ai_flags	int
|=	O
AI_NUMERICHOST	int
;	O
hints	struct
.	O
ai_family	int
=	O
sep	pointer
->	O
se_family	short
;	O
hints	struct
.	O
ai_socktype	int
=	O
sep	pointer
->	O
se_socktype	int
;	O
hints	struct
.	O
ai_protocol	int
=	O
proto	int
;	O
return	O
getaddrinfo	function
(	O
sep	pointer
->	O
se_node	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
&	O
hints	struct
,	O
result	pointer
)	O
;	O
}	O
int	O
expand_enter	function
(	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
int	O
err	long
;	O
struct	O
addrinfo	struct
*	O
result	pointer
,	O
*	O
rp	pointer
;	O
struct	O
protoent	struct
*	O
proto	int
;	O
struct	O
servtab	struct
*	O
cp	pointer
;	O
if	O
(	O
strncmp	function
(	O
sep	pointer
->	O
se_proto	pointer
,	O
"tcp"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
proto	int
=	O
getprotobyname	function
(	O
"tcp"	pointer
)	O
;	O
else	O
if	O
(	O
strncmp	function
(	O
sep	pointer
->	O
se_proto	pointer
,	O
"udp"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
proto	int
=	O
getprotobyname	function
(	O
"udp"	pointer
)	O
;	O
else	O
proto	int
=	O
getprotobyname	function
(	O
sep	pointer
->	O
se_proto	pointer
)	O
;	O
if	O
(	O
!	O
proto	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s: Unknown protocol"	pointer
,	O
sep	pointer
->	O
se_proto	pointer
)	O
;	O
return	O
1	int
;	O
}	O
err	long
=	O
inetd_getaddrinfo	function
(	O
sep	pointer
,	O
proto	int
->	O
p_proto	int
,	O
&	O
result	pointer
)	O
;	O
if	O
(	O
err	long
==	O
EAI_ADDRFAMILY	O
&&	O
sep	pointer
->	O
se_family	short
==	O
AF_INET6	O
&&	O
sep	pointer
->	O
se_v4mapped	char
)	O
{	O
sep	pointer
->	O
se_family	short
=	O
AF_INET	O
;	O
err	long
=	O
inetd_getaddrinfo	function
(	O
sep	pointer
,	O
proto	int
->	O
p_proto	int
,	O
&	O
result	pointer
)	O
;	O
}	O
if	O
(	O
err	long
)	O
{	O
const	O
char	O
*	O
errmsg	pointer
;	O
if	O
(	O
err	long
==	O
EAI_SYSTEM	O
)	O
errmsg	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
else	O
errmsg	pointer
=	O
gai_strerror	function
(	O
err	long
)	O
;	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s/%s: getaddrinfo: %s"	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
sep	pointer
->	O
se_proto	pointer
,	O
errmsg	pointer
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
rp	pointer
=	O
result	pointer
;	O
rp	pointer
!=	O
NULL	O
;	O
rp	pointer
=	O
rp	pointer
->	O
ai_next	pointer
)	O
{	O
memset	function
(	O
&	O
sep	pointer
->	O
se_ctrladdr	struct
,	O
0	int
,	O
sizeof	O
(	O
sep	pointer
->	O
se_ctrladdr	struct
)	O
)	O
;	O
memcpy	function
(	O
&	O
sep	pointer
->	O
se_ctrladdr	struct
,	O
rp	pointer
->	O
ai_addr	pointer
,	O
rp	pointer
->	O
ai_addrlen	int
)	O
;	O
sep	pointer
->	O
se_addrlen	int
=	O
rp	pointer
->	O
ai_addrlen	int
;	O
cp	pointer
=	O
enter	function
(	O
sep	pointer
)	O
;	O
servent_setup	function
(	O
cp	pointer
)	O
;	O
}	O
freeaddrinfo	function
(	O
result	pointer
)	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
global_serv_node	pointer
;	O
char	O
*	O
serv_node	pointer
;	O
size_t	long
serv_node_offset	long
;	O
char	O
*	O
linebuf	pointer
=	O
NULL	O
;	O
size_t	long
linebufsize	long
=	O
0	int
;	O
FILE	struct
*	O
setconfig	function
(	O
const	O
char	O
*	O
file	pointer
)	O
{	O
return	O
fopen	function
(	O
file	pointer
,	O
"r"	pointer
)	O
;	O
}	O
void	O
endconfig	function
(	O
FILE	struct
*	O
fconfig	pointer
)	O
{	O
if	O
(	O
fconfig	pointer
)	O
fclose	function
(	O
fconfig	pointer
)	O
;	O
}	O
void	O
freeconfig	function
(	O
struct	O
servtab	struct
*	O
cp	pointer
)	O
{	O
free	function
(	O
cp	pointer
->	O
se_node	pointer
)	O
;	O
free	function
(	O
cp	pointer
->	O
se_service	pointer
)	O
;	O
free	function
(	O
cp	pointer
->	O
se_proto	pointer
)	O
;	O
free	function
(	O
cp	pointer
->	O
se_user	pointer
)	O
;	O
free	function
(	O
cp	pointer
->	O
se_server	pointer
)	O
;	O
argcv_free	function
(	O
cp	pointer
->	O
se_argc	long
,	O
cp	pointer
->	O
se_argv	pointer
)	O
;	O
}	O
struct	O
servtab	struct
*	O
next_node_sep	function
(	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
if	O
(	O
serv_node	pointer
)	O
{	O
size_t	long
i	int
=	O
strcspn	function
(	O
serv_node	pointer
+	O
serv_node_offset	long
,	O
","	pointer
)	O
;	O
sep	pointer
->	O
se_node	pointer
=	O
malloc	function
(	O
i	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
sep	pointer
->	O
se_node	pointer
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"malloc: %m"	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
memcpy	function
(	O
sep	pointer
->	O
se_node	pointer
,	O
serv_node	pointer
+	O
serv_node_offset	long
,	O
i	int
)	O
;	O
sep	pointer
->	O
se_node	pointer
[	O
i	int
]	O
=	O
0	int
;	O
serv_node_offset	long
+=	O
i	int
;	O
if	O
(	O
serv_node	pointer
[	O
serv_node_offset	long
]	O
)	O
serv_node_offset	long
++	O
;	O
else	O
{	O
free	function
(	O
serv_node	pointer
)	O
;	O
serv_node	pointer
=	O
NULL	O
;	O
}	O
}	O
return	O
sep	pointer
;	O
}	O
struct	O
servtab	struct
*	O
getconfigent	function
(	O
FILE	struct
*	O
fconfig	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
size_t	long
*	O
line	pointer
)	O
{	O
static	O
struct	O
servtab	struct
serv	struct
;	O
struct	O
servtab	struct
*	O
sep	pointer
=	O
&	O
serv	struct
;	O
int	O
argc	int
=	O
0	int
;	O
size_t	long
i	int
;	O
char	O
*	O
*	O
argv	pointer
=	O
NULL	O
;	O
char	O
*	O
node	pointer
,	O
*	O
service	pointer
;	O
static	O
char	O
TCPMUX_TOKEN	array
[	O
]	O
=	O
"tcpmux/"	pointer
;	O
if	O
(	O
serv_node	pointer
)	O
return	O
next_node_sep	function
(	O
sep	pointer
)	O
;	O
memset	function
(	O
(	O
caddr_t	pointer
)	O
sep	pointer
,	O
0	int
,	O
sizeof	O
*	O
sep	pointer
)	O
;	O
while	O
(	O
1	int
)	O
{	O
argcv_free	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
freeconfig	function
(	O
sep	pointer
)	O
;	O
memset	function
(	O
(	O
caddr_t	pointer
)	O
sep	pointer
,	O
0	int
,	O
sizeof	O
*	O
sep	pointer
)	O
;	O
do	O
{	O
ssize_t	long
n	long
=	O
getline	function
(	O
&	O
linebuf	pointer
,	O
&	O
linebufsize	long
,	O
fconfig	pointer
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
n	long
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
linebuf	pointer
[	O
n	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
linebuf	pointer
[	O
n	long
-	O
1	int
]	O
=	O
0	int
;	O
++	O
*	O
line	pointer
;	O
}	O
while	O
(	O
*	O
linebuf	pointer
==	O
'#'	O
||	O
*	O
linebuf	pointer
==	O
0	int
)	O
;	O
if	O
(	O
argcv_get	function
(	O
linebuf	pointer
,	O
""	pointer
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
argc	int
<	O
INETD_FIELDS_MIN	int
)	O
{	O
if	O
(	O
argc	int
==	O
1	int
&&	O
argv	pointer
[	O
0	int
]	O
[	O
strlen	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
-	O
1	int
]	O
==	O
':'	O
)	O
{	O
argv	pointer
[	O
0	int
]	O
[	O
strlen	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
-	O
1	int
]	O
=	O
0	int
;	O
free	function
(	O
global_serv_node	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
"*"	pointer
)	O
)	O
global_serv_node	pointer
=	O
newstr	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
}	O
else	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s:%lu: not enough fields"	pointer
,	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
*	O
line	pointer
)	O
;	O
continue	O
;	O
}	O
sep	pointer
->	O
se_file	pointer
=	O
file	pointer
;	O
sep	pointer
->	O
se_line	int
=	O
*	O
line	pointer
;	O
node	pointer
=	O
argv	pointer
[	O
INETD_SERVICE	int
]	O
;	O
service	pointer
=	O
strrchr	function
(	O
node	pointer
,	O
':'	O
)	O
;	O
if	O
(	O
!	O
service	pointer
)	O
{	O
if	O
(	O
global_serv_node	pointer
)	O
{	O
node	pointer
=	O
global_serv_node	pointer
;	O
serv_node	pointer
=	O
newstr	function
(	O
node	pointer
)	O
;	O
serv_node_offset	long
=	O
0	int
;	O
}	O
else	O
node	pointer
=	O
NULL	O
;	O
service	pointer
=	O
argv	pointer
[	O
INETD_SERVICE	int
]	O
;	O
}	O
else	O
{	O
*	O
service	pointer
++	O
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
node	pointer
,	O
"*"	pointer
)	O
==	O
0	int
)	O
node	pointer
=	O
NULL	O
;	O
else	O
{	O
serv_node	pointer
=	O
newstr	function
(	O
node	pointer
)	O
;	O
serv_node_offset	long
=	O
0	int
;	O
}	O
}	O
if	O
(	O
strncmp	function
(	O
service	pointer
,	O
TCPMUX_TOKEN	array
,	O
MUX_LEN	O
)	O
==	O
0	int
)	O
{	O
char	O
*	O
c	pointer
=	O
service	pointer
+	O
MUX_LEN	O
;	O
if	O
(	O
*	O
c	pointer
==	O
'+'	O
)	O
{	O
sep	pointer
->	O
se_type	int
=	O
MUXPLUS_TYPE	int
;	O
c	pointer
++	O
;	O
}	O
else	O
sep	pointer
->	O
se_type	int
=	O
MUX_TYPE	int
;	O
sep	pointer
->	O
se_service	pointer
=	O
newstr	function
(	O
c	pointer
)	O
;	O
}	O
else	O
{	O
sep	pointer
->	O
se_service	pointer
=	O
newstr	function
(	O
service	pointer
)	O
;	O
sep	pointer
->	O
se_type	int
=	O
NORM_TYPE	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
INETD_SOCKET	int
]	O
,	O
"stream"	pointer
)	O
==	O
0	int
)	O
sep	pointer
->	O
se_socktype	int
=	O
SOCK_STREAM	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
INETD_SOCKET	int
]	O
,	O
"dgram"	pointer
)	O
==	O
0	int
)	O
sep	pointer
->	O
se_socktype	int
=	O
SOCK_DGRAM	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
INETD_SOCKET	int
]	O
,	O
"rdm"	pointer
)	O
==	O
0	int
)	O
sep	pointer
->	O
se_socktype	int
=	O
SOCK_RDM	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
INETD_SOCKET	int
]	O
,	O
"seqpacket"	pointer
)	O
==	O
0	int
)	O
sep	pointer
->	O
se_socktype	int
=	O
SOCK_SEQPACKET	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
INETD_SOCKET	int
]	O
,	O
"raw"	pointer
)	O
==	O
0	int
)	O
sep	pointer
->	O
se_socktype	int
=	O
SOCK_RAW	int
;	O
else	O
{	O
syslog	function
(	O
LOG_WARNING	int
,	O
"%s:%lu: bad socket type"	pointer
,	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
*	O
line	pointer
)	O
;	O
sep	pointer
->	O
se_socktype	int
=	O
-	O
1	int
;	O
}	O
sep	pointer
->	O
se_proto	pointer
=	O
newstr	function
(	O
argv	pointer
[	O
INETD_PROTOCOL	int
]	O
)	O
;	O
sep	pointer
->	O
se_family	short
=	O
AF_INET	O
;	O
sep	pointer
->	O
se_v4mapped	char
=	O
1	int
;	O
if	O
(	O
(	O
strncmp	function
(	O
sep	pointer
->	O
se_proto	pointer
,	O
"tcp"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
||	O
(	O
strncmp	function
(	O
sep	pointer
->	O
se_proto	pointer
,	O
"udp"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
)	O
{	O
if	O
(	O
sep	pointer
->	O
se_proto	pointer
[	O
3	int
]	O
==	O
'6'	O
)	O
{	O
sep	pointer
->	O
se_family	short
=	O
AF_INET6	O
;	O
sep	pointer
->	O
se_v4mapped	char
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
&	O
sep	pointer
->	O
se_proto	pointer
[	O
3	int
]	O
,	O
"6only"	pointer
)	O
==	O
0	int
)	O
sep	pointer
->	O
se_v4mapped	char
=	O
0	int
;	O
}	O
else	O
if	O
(	O
sep	pointer
->	O
se_proto	pointer
[	O
3	int
]	O
==	O
'4'	O
)	O
{	O
sep	pointer
->	O
se_family	short
=	O
AF_INET	O
;	O
}	O
}	O
{	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
p	pointer
=	O
strchr	function
(	O
argv	pointer
[	O
INETD_WAIT	int
]	O
,	O
'.'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
*	O
p	pointer
++	O
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
INETD_WAIT	int
]	O
,	O
"wait"	pointer
)	O
==	O
0	int
)	O
sep	pointer
->	O
se_wait	int
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
INETD_WAIT	int
]	O
,	O
"nowait"	pointer
)	O
==	O
0	int
)	O
sep	pointer
->	O
se_wait	int
=	O
0	int
;	O
else	O
{	O
syslog	function
(	O
LOG_WARNING	int
,	O
"%s:%lu: bad wait type"	pointer
,	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
*	O
line	pointer
)	O
;	O
}	O
if	O
(	O
p	pointer
)	O
{	O
sep	pointer
->	O
se_max	int
=	O
strtoul	function
(	O
p	pointer
,	O
&	O
q	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
q	pointer
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"%s:%lu: invalid number (%s)"	pointer
,	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
*	O
line	pointer
,	O
p	pointer
)	O
;	O
}	O
}	O
if	O
(	O
ISMUX	O
(	O
sep	pointer
)	O
)	O
{	O
sep	pointer
->	O
se_wait	int
=	O
0	int
;	O
if	O
(	O
strncmp	function
(	O
sep	pointer
->	O
se_proto	pointer
,	O
"tcp"	pointer
,	O
3	int
)	O
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s:%lu: bad protocol for tcpmux service %s"	pointer
,	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
*	O
line	pointer
,	O
sep	pointer
->	O
se_service	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
sep	pointer
->	O
se_socktype	int
!=	O
SOCK_STREAM	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s:%lu: bad socket type for tcpmux service %s"	pointer
,	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
*	O
line	pointer
,	O
sep	pointer
->	O
se_service	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
sep	pointer
->	O
se_user	pointer
=	O
newstr	function
(	O
argv	pointer
[	O
INETD_USER	int
]	O
)	O
;	O
sep	pointer
->	O
se_server	pointer
=	O
newstr	function
(	O
argv	pointer
[	O
INETD_SERVER_PATH	int
]	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
sep	pointer
->	O
se_server	pointer
,	O
"internal"	pointer
)	O
==	O
0	int
)	O
{	O
sep	pointer
->	O
se_bi	pointer
=	O
bi_lookup	function
(	O
sep	pointer
)	O
;	O
if	O
(	O
!	O
sep	pointer
->	O
se_bi	pointer
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s:%lu: internal service %s unknown"	pointer
,	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
*	O
line	pointer
,	O
sep	pointer
->	O
se_service	pointer
)	O
;	O
continue	O
;	O
}	O
sep	pointer
->	O
se_wait	int
=	O
sep	pointer
->	O
se_bi	pointer
->	O
bi_wait	short
;	O
}	O
else	O
sep	pointer
->	O
se_bi	pointer
=	O
NULL	O
;	O
sep	pointer
->	O
se_argc	long
=	O
argc	int
-	O
INETD_FIELDS_MIN	int
+	O
1	int
;	O
sep	pointer
->	O
se_argv	pointer
=	O
calloc	function
(	O
sep	pointer
->	O
se_argc	long
+	O
1	int
,	O
sizeof	O
sep	pointer
->	O
se_argv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
sep	pointer
->	O
se_argv	pointer
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s:%lu: Out of memory."	pointer
,	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
*	O
line	pointer
)	O
;	O
exit	function
(	O
-	O
1	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sep	pointer
->	O
se_argc	long
;	O
i	int
++	O
)	O
{	O
sep	pointer
->	O
se_argv	pointer
[	O
i	int
]	O
=	O
argv	pointer
[	O
INETD_SERVER_ARGS	int
+	O
i	int
]	O
;	O
argv	pointer
[	O
INETD_SERVER_ARGS	int
+	O
i	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
sep	pointer
->	O
se_argc	long
==	O
1	int
)	O
{	O
const	O
char	O
*	O
argv0	pointer
=	O
strrchr	function
(	O
sep	pointer
->	O
se_server	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
argv0	pointer
)	O
argv0	pointer
++	O
;	O
else	O
argv0	pointer
=	O
sep	pointer
->	O
se_server	pointer
;	O
sep	pointer
->	O
se_argv	pointer
[	O
0	int
]	O
=	O
newstr	function
(	O
argv0	pointer
)	O
;	O
}	O
sep	pointer
->	O
se_argv	pointer
[	O
i	int
]	O
=	O
NULL	O
;	O
break	O
;	O
}	O
argcv_free	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
return	O
next_node_sep	function
(	O
sep	pointer
)	O
;	O
}	O
void	O
nextconfig	function
(	O
const	O
char	O
*	O
file	pointer
)	O
{	O
struct	O
servtab	struct
*	O
sep	pointer
,	O
*	O
*	O
sepp	pointer
;	O
struct	O
passwd	struct
*	O
pwd	pointer
;	O
FILE	struct
*	O
fconfig	pointer
;	O
SIGSTATUS	O
sigstatus	struct
;	O
size_t	long
line	pointer
=	O
0	int
;	O
fconfig	pointer
=	O
setconfig	function
(	O
file	pointer
)	O
;	O
if	O
(	O
!	O
fconfig	pointer
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s: %m"	pointer
,	O
file	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
(	O
sep	pointer
=	O
getconfigent	function
(	O
fconfig	pointer
,	O
file	pointer
,	O
&	O
line	pointer
)	O
)	O
)	O
{	O
if	O
(	O
(	O
pwd	pointer
=	O
getpwnam	function
(	O
sep	pointer
->	O
se_user	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s/%s: No such user '%s', service ignored"	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
sep	pointer
->	O
se_proto	pointer
,	O
sep	pointer
->	O
se_user	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
ISMUX	O
(	O
sep	pointer
)	O
)	O
{	O
sep	pointer
->	O
se_fd	int
=	O
-	O
1	int
;	O
sep	pointer
->	O
se_checked	short
=	O
1	int
;	O
enter	function
(	O
sep	pointer
)	O
;	O
}	O
else	O
expand_enter	function
(	O
sep	pointer
)	O
;	O
if	O
(	O
serv_node	pointer
)	O
free	function
(	O
sep	pointer
->	O
se_node	pointer
)	O
;	O
else	O
freeconfig	function
(	O
sep	pointer
)	O
;	O
}	O
endconfig	function
(	O
fconfig	pointer
)	O
;	O
signal_block	function
(	O
&	O
sigstatus	struct
)	O
;	O
sepp	pointer
=	O
&	O
servtab	struct
;	O
while	O
(	O
(	O
sep	pointer
=	O
*	O
sepp	pointer
)	O
)	O
{	O
if	O
(	O
sep	pointer
->	O
se_checked	short
)	O
{	O
sepp	pointer
=	O
&	O
sep	pointer
->	O
se_next	pointer
;	O
continue	O
;	O
}	O
*	O
sepp	pointer
=	O
sep	pointer
->	O
se_next	pointer
;	O
if	O
(	O
sep	pointer
->	O
se_fd	int
>=	O
0	int
)	O
close_sep	function
(	O
sep	pointer
)	O
;	O
if	O
(	O
debug	bool
)	O
print_service	function
(	O
"FREE"	pointer
,	O
sep	pointer
)	O
;	O
freeconfig	function
(	O
sep	pointer
)	O
;	O
free	function
(	O
sep	pointer
)	O
;	O
}	O
signal_unblock	function
(	O
&	O
sigstatus	struct
)	O
;	O
}	O
void	O
fix_tcpmux	function
(	O
void	O
)	O
{	O
struct	O
servtab	struct
*	O
sep	pointer
;	O
int	O
need_tcpmux	int
=	O
0	int
;	O
int	O
has_tcpmux	int
=	O
0	int
;	O
for	O
(	O
sep	pointer
=	O
servtab	struct
;	O
sep	pointer
;	O
sep	pointer
=	O
sep	pointer
->	O
se_next	pointer
)	O
{	O
if	O
(	O
sep	pointer
->	O
se_checked	short
)	O
{	O
if	O
(	O
ISMUX	O
(	O
sep	pointer
)	O
)	O
{	O
if	O
(	O
has_tcpmux	int
)	O
return	O
;	O
need_tcpmux	int
=	O
1	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
sep	pointer
->	O
se_service	pointer
,	O
"tcpmux"	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
need_tcpmux	int
)	O
return	O
;	O
has_tcpmux	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
need_tcpmux	int
&&	O
!	O
has_tcpmux	int
)	O
{	O
struct	O
servtab	struct
serv	struct
;	O
memset	function
(	O
&	O
serv	struct
,	O
0	int
,	O
sizeof	O
(	O
serv	struct
)	O
)	O
;	O
serv	struct
.	O
se_file	pointer
=	O
"fix_tcpmux"	pointer
;	O
serv	struct
.	O
se_service	pointer
=	O
newstr	function
(	O
"tcpmux"	pointer
)	O
;	O
serv	struct
.	O
se_socktype	int
=	O
SOCK_STREAM	int
;	O
serv	struct
.	O
se_checked	short
=	O
1	int
;	O
serv	struct
.	O
se_user	pointer
=	O
newstr	function
(	O
"root"	pointer
)	O
;	O
serv	struct
.	O
se_bi	pointer
=	O
bi_lookup	function
(	O
&	O
serv	struct
)	O
;	O
if	O
(	O
!	O
serv	struct
.	O
se_bi	pointer
)	O
{	O
freeconfig	function
(	O
&	O
serv	struct
)	O
;	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"INTERNAL ERROR: could not find tcpmux built-in"	pointer
)	O
;	O
syslog	function
(	O
LOG_ERR	int
,	O
"INTERNAL ERROR: could not find tcpmux built-in"	pointer
)	O
;	O
return	O
;	O
}	O
serv	struct
.	O
se_wait	int
=	O
serv	struct
.	O
se_bi	pointer
->	O
bi_wait	short
;	O
serv	struct
.	O
se_server	pointer
=	O
newstr	function
(	O
"internal"	pointer
)	O
;	O
serv	struct
.	O
se_fd	int
=	O
-	O
1	int
;	O
serv	struct
.	O
se_type	int
=	O
NORM_TYPE	int
;	O
serv	struct
.	O
se_proto	pointer
=	O
newstr	function
(	O
"tcp6"	pointer
)	O
;	O
serv	struct
.	O
se_family	short
=	O
AF_INET6	O
;	O
serv	struct
.	O
se_v4mapped	char
=	O
1	int
;	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"inserting default tcpmux entry\n"	pointer
)	O
;	O
syslog	function
(	O
LOG_INFO	int
,	O
"inserting default tcpmux entry"	pointer
)	O
;	O
expand_enter	function
(	O
&	O
serv	struct
)	O
;	O
}	O
}	O
void	O
config	function
(	O
int	O
signo	int
)	O
{	O
int	O
i	int
;	O
struct	O
stat	struct
stats	struct
;	O
struct	O
servtab	struct
*	O
sep	pointer
;	O
for	O
(	O
sep	pointer
=	O
servtab	struct
;	O
sep	pointer
;	O
sep	pointer
=	O
sep	pointer
->	O
se_next	pointer
)	O
sep	pointer
->	O
se_checked	short
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
config_files	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
struct	O
stat	struct
statbuf	struct
;	O
if	O
(	O
stat	struct
(	O
config_files	pointer
[	O
i	int
]	O
,	O
&	O
statbuf	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
statbuf	struct
.	O
st_mode	int
)	O
)	O
{	O
DIR	struct
*	O
dirp	pointer
=	O
opendir	function
(	O
config_files	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
dirp	pointer
)	O
{	O
struct	O
dirent	struct
*	O
dp	pointer
;	O
while	O
(	O
(	O
dp	pointer
=	O
readdir	function
(	O
dirp	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
path	pointer
=	O
calloc	function
(	O
strlen	function
(	O
config_files	pointer
[	O
i	int
]	O
)	O
+	O
strlen	function
(	O
dp	pointer
->	O
d_name	array
)	O
+	O
2	int
,	O
1	int
)	O
;	O
if	O
(	O
path	pointer
)	O
{	O
sprintf	function
(	O
path	pointer
,	O
"%s/%s"	pointer
,	O
config_files	pointer
[	O
i	int
]	O
,	O
dp	pointer
->	O
d_name	array
)	O
;	O
if	O
(	O
stat	struct
(	O
path	pointer
,	O
&	O
stats	struct
)	O
==	O
0	int
&&	O
S_ISREG	O
(	O
stats	struct
.	O
st_mode	int
)	O
)	O
{	O
nextconfig	function
(	O
path	pointer
)	O
;	O
}	O
free	function
(	O
path	pointer
)	O
;	O
}	O
}	O
closedir	function
(	O
dirp	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
S_ISREG	O
(	O
statbuf	struct
.	O
st_mode	int
)	O
)	O
{	O
nextconfig	function
(	O
config_files	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
signo	int
==	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"inetd: %s, %s\n"	pointer
,	O
config_files	pointer
[	O
i	int
]	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
else	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s: %m"	pointer
,	O
config_files	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
free	function
(	O
linebuf	pointer
)	O
;	O
linebuf	pointer
=	O
NULL	O
;	O
linebufsize	long
=	O
0	int
;	O
fix_tcpmux	function
(	O
)	O
;	O
}	O
void	O
set_proc_title	function
(	O
char	O
*	O
a	pointer
,	O
int	O
s	int
)	O
{	O
socklen_t	int
size	long
;	O
char	O
*	O
cp	pointer
;	O
struct	O
sockaddr_storage	struct
saddr	struct
;	O
char	O
buf	array
[	O
80	int
]	O
;	O
cp	pointer
=	O
Argv	pointer
[	O
0	int
]	O
;	O
size	long
=	O
sizeof	O
saddr	struct
;	O
if	O
(	O
getpeername	function
(	O
s	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
saddr	struct
,	O
&	O
size	long
)	O
==	O
0	int
)	O
{	O
int	O
err	long
;	O
char	O
buf2	array
[	O
80	int
]	O
;	O
err	long
=	O
getnameinfo	function
(	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
saddr	struct
,	O
sizeof	O
(	O
saddr	struct
)	O
,	O
buf2	array
,	O
sizeof	O
(	O
buf2	array
)	O
,	O
NULL	O
,	O
0	int
,	O
NI_NUMERICHOST	int
)	O
;	O
if	O
(	O
!	O
err	long
)	O
snprintf	function
(	O
buf	array
,	O
sizeof	O
buf	array
,	O
"-%s [%s]"	pointer
,	O
a	pointer
,	O
buf2	array
)	O
;	O
else	O
snprintf	function
(	O
buf	array
,	O
sizeof	O
buf	array
,	O
"-%s"	pointer
,	O
a	pointer
)	O
;	O
}	O
else	O
snprintf	function
(	O
buf	array
,	O
sizeof	O
buf	array
,	O
"-%s"	pointer
,	O
a	pointer
)	O
;	O
strncpy	function
(	O
cp	pointer
,	O
buf	array
,	O
LastArg	pointer
-	O
cp	pointer
)	O
;	O
cp	pointer
+=	O
strlen	function
(	O
cp	pointer
)	O
;	O
while	O
(	O
cp	pointer
<	O
LastArg	pointer
)	O
*	O
cp	pointer
++	O
=	O
' '	O
;	O
}	O
void	O
echo_stream	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
char	O
buffer	array
[	O
BUFSIZE	int
]	O
;	O
int	O
i	int
;	O
set_proc_title	function
(	O
sep	pointer
->	O
se_service	pointer
,	O
s	int
)	O
;	O
while	O
(	O
(	O
i	int
=	O
read	pointer
(	O
s	int
,	O
buffer	array
,	O
sizeof	O
buffer	array
)	O
)	O
>	O
0	int
&&	O
write	pointer
(	O
s	int
,	O
buffer	array
,	O
i	int
)	O
>	O
0	int
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
echo_dg	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
char	O
buffer	array
[	O
BUFSIZE	int
]	O
;	O
int	O
i	int
;	O
socklen_t	int
size	long
;	O
struct	O
sockaddr_storage	struct
sa	struct
;	O
size	long
=	O
sizeof	O
sa	struct
;	O
i	int
=	O
recvfrom	function
(	O
s	int
,	O
buffer	array
,	O
sizeof	O
buffer	array
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa	struct
,	O
&	O
size	long
)	O
;	O
if	O
(	O
i	int
<	O
0	int
)	O
return	O
;	O
sendto	function
(	O
s	int
,	O
buffer	array
,	O
i	int
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa	struct
,	O
sizeof	O
sa	struct
)	O
;	O
}	O
void	O
discard_stream	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
int	O
ret	int
;	O
char	O
buffer	array
[	O
BUFSIZE	int
]	O
;	O
set_proc_title	function
(	O
sep	pointer
->	O
se_service	pointer
,	O
s	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
(	O
ret	int
=	O
read	pointer
(	O
s	int
,	O
buffer	array
,	O
sizeof	O
buffer	array
)	O
)	O
>	O
0	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
||	O
errno	O
!=	O
EINTR	int
)	O
break	O
;	O
}	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
discard_dg	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
char	O
buffer	array
[	O
BUFSIZE	int
]	O
;	O
read	pointer
(	O
s	int
,	O
buffer	array
,	O
sizeof	O
buffer	array
)	O
;	O
}	O
char	O
ring	array
[	O
128	int
]	O
;	O
char	O
*	O
endring	pointer
;	O
void	O
initring	function
(	O
void	O
)	O
{	O
int	O
i	int
;	O
endring	pointer
=	O
ring	array
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
128	int
;	O
++	O
i	int
)	O
if	O
(	O
isprint	function
(	O
i	int
)	O
)	O
*	O
endring	pointer
++	O
=	O
i	int
;	O
}	O
void	O
chargen_stream	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
int	O
len	int
;	O
char	O
*	O
rs	pointer
,	O
text	array
[	O
LINESIZ	int
+	O
2	int
]	O
;	O
set_proc_title	function
(	O
sep	pointer
->	O
se_service	pointer
,	O
s	int
)	O
;	O
if	O
(	O
!	O
endring	pointer
)	O
{	O
initring	function
(	O
)	O
;	O
rs	pointer
=	O
ring	array
;	O
}	O
text	array
[	O
LINESIZ	int
]	O
=	O
'\r'	O
;	O
text	array
[	O
LINESIZ	int
+	O
1	int
]	O
=	O
'\n'	O
;	O
for	O
(	O
rs	pointer
=	O
ring	array
;	O
;	O
)	O
{	O
if	O
(	O
(	O
len	int
=	O
endring	pointer
-	O
rs	pointer
)	O
>=	O
LINESIZ	int
)	O
memmove	function
(	O
text	array
,	O
rs	pointer
,	O
LINESIZ	int
)	O
;	O
else	O
{	O
memmove	function
(	O
text	array
,	O
rs	pointer
,	O
len	int
)	O
;	O
memmove	function
(	O
text	array
+	O
len	int
,	O
ring	array
,	O
LINESIZ	int
-	O
len	int
)	O
;	O
}	O
if	O
(	O
++	O
rs	pointer
==	O
endring	pointer
)	O
rs	pointer
=	O
ring	array
;	O
if	O
(	O
write	pointer
(	O
s	int
,	O
text	array
,	O
sizeof	O
text	array
)	O
!=	O
sizeof	O
text	array
)	O
break	O
;	O
}	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
chargen_dg	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
struct	O
sockaddr_storage	struct
sa	struct
;	O
static	O
char	O
*	O
rs	pointer
;	O
int	O
len	int
;	O
socklen_t	int
size	long
;	O
char	O
text	array
[	O
LINESIZ	int
+	O
2	int
]	O
;	O
if	O
(	O
endring	pointer
==	O
0	int
)	O
{	O
initring	function
(	O
)	O
;	O
rs	pointer
=	O
ring	array
;	O
}	O
size	long
=	O
sizeof	O
sa	struct
;	O
if	O
(	O
recvfrom	function
(	O
s	int
,	O
text	array
,	O
sizeof	O
text	array
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa	struct
,	O
&	O
size	long
)	O
<	O
0	int
)	O
return	O
;	O
if	O
(	O
(	O
len	int
=	O
endring	pointer
-	O
rs	pointer
)	O
>=	O
LINESIZ	int
)	O
memmove	function
(	O
text	array
,	O
rs	pointer
,	O
LINESIZ	int
)	O
;	O
else	O
{	O
memmove	function
(	O
text	array
,	O
rs	pointer
,	O
len	int
)	O
;	O
memmove	function
(	O
text	array
+	O
len	int
,	O
ring	array
,	O
LINESIZ	int
-	O
len	int
)	O
;	O
}	O
if	O
(	O
++	O
rs	pointer
==	O
endring	pointer
)	O
rs	pointer
=	O
ring	array
;	O
text	array
[	O
LINESIZ	int
]	O
=	O
'\r'	O
;	O
text	array
[	O
LINESIZ	int
+	O
1	int
]	O
=	O
'\n'	O
;	O
sendto	function
(	O
s	int
,	O
text	array
,	O
sizeof	O
text	array
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa	struct
,	O
sizeof	O
sa	struct
)	O
;	O
}	O
long	O
machtime	function
(	O
void	O
)	O
{	O
struct	O
timeval	struct
tv	struct
;	O
if	O
(	O
gettimeofday	function
(	O
&	O
tv	struct
,	O
NULL	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Unable to get time of day\n"	pointer
)	O
;	O
return	O
0L	int
;	O
}	O
return	O
(	O
htonl	function
(	O
(	O
long	O
)	O
(	O
tv	struct
.	O
tv_sec	long
+	O
OFFSET	O
)	O
)	O
)	O
;	O
}	O
void	O
machtime_stream	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
long	O
result	pointer
;	O
result	pointer
=	O
machtime	function
(	O
)	O
;	O
write	pointer
(	O
s	int
,	O
(	O
char	O
*	O
)	O
&	O
result	pointer
,	O
sizeof	O
result	pointer
)	O
;	O
}	O
void	O
machtime_dg	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
long	O
result	pointer
;	O
struct	O
sockaddr_storage	struct
sa	struct
;	O
socklen_t	int
size	long
;	O
size	long
=	O
sizeof	O
sa	struct
;	O
if	O
(	O
recvfrom	function
(	O
s	int
,	O
(	O
char	O
*	O
)	O
&	O
result	pointer
,	O
sizeof	O
result	pointer
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa	struct
,	O
&	O
size	long
)	O
<	O
0	int
)	O
return	O
;	O
result	pointer
=	O
machtime	function
(	O
)	O
;	O
sendto	function
(	O
s	int
,	O
(	O
char	O
*	O
)	O
&	O
result	pointer
,	O
sizeof	O
result	pointer
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa	struct
,	O
sizeof	O
sa	struct
)	O
;	O
}	O
void	O
daytime_stream	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
char	O
buffer	array
[	O
256	int
]	O
;	O
time_t	long
lclock	long
;	O
lclock	long
=	O
time	struct
(	O
(	O
time_t	long
*	O
)	O
0	int
)	O
;	O
sprintf	function
(	O
buffer	array
,	O
"%.24s\r\n"	pointer
,	O
ctime	function
(	O
&	O
lclock	long
)	O
)	O
;	O
write	pointer
(	O
s	int
,	O
buffer	array
,	O
strlen	function
(	O
buffer	array
)	O
)	O
;	O
}	O
void	O
daytime_dg	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
char	O
buffer	array
[	O
256	int
]	O
;	O
time_t	long
lclock	long
;	O
struct	O
sockaddr_storage	struct
sa	struct
;	O
socklen_t	int
size	long
;	O
lclock	long
=	O
time	struct
(	O
(	O
time_t	long
*	O
)	O
0	int
)	O
;	O
size	long
=	O
sizeof	O
sa	struct
;	O
if	O
(	O
recvfrom	function
(	O
s	int
,	O
buffer	array
,	O
sizeof	O
buffer	array
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa	struct
,	O
&	O
size	long
)	O
<	O
0	int
)	O
return	O
;	O
sprintf	function
(	O
buffer	array
,	O
"%.24s\r\n"	pointer
,	O
ctime	function
(	O
&	O
lclock	long
)	O
)	O
;	O
sendto	function
(	O
s	int
,	O
buffer	array
,	O
strlen	function
(	O
buffer	array
)	O
,	O
0	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa	struct
,	O
sizeof	O
sa	struct
)	O
;	O
}	O
static	O
int	O
fd_getline	function
(	O
int	O
fd	int
,	O
char	O
*	O
buf	array
,	O
int	O
len	int
)	O
{	O
int	O
count	int
=	O
0	int
,	O
n	long
;	O
do	O
{	O
n	long
=	O
read	pointer
(	O
fd	int
,	O
buf	array
,	O
len	int
-	O
count	int
)	O
;	O
if	O
(	O
n	long
==	O
0	int
)	O
return	O
count	int
;	O
if	O
(	O
n	long
<	O
0	int
)	O
return	O
-	O
1	int
;	O
while	O
(	O
--	O
n	long
>=	O
0	int
)	O
{	O
if	O
(	O
*	O
buf	array
==	O
'\r'	O
||	O
*	O
buf	array
==	O
'\n'	O
||	O
*	O
buf	array
==	O
'\0'	O
)	O
return	O
count	int
;	O
count	int
++	O
;	O
buf	array
++	O
;	O
}	O
}	O
while	O
(	O
count	int
<	O
len	int
)	O
;	O
return	O
count	int
;	O
}	O
void	O
tcpmux	function
(	O
int	O
s	int
,	O
struct	O
servtab	struct
*	O
sep	pointer
)	O
{	O
char	O
service	pointer
[	O
MAX_SERV_LEN	O
+	O
1	int
]	O
;	O
int	O
len	int
;	O
if	O
(	O
(	O
len	int
=	O
fd_getline	function
(	O
s	int
,	O
service	pointer
,	O
MAX_SERV_LEN	O
)	O
)	O
<	O
0	int
)	O
{	O
strwrite	O
(	O
s	int
,	O
"-Error reading service name\r\n"	pointer
)	O
;	O
_exit	function
(	O
1	int
)	O
;	O
}	O
service	pointer
[	O
len	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"tcpmux: someone wants %s\n"	pointer
,	O
service	pointer
)	O
;	O
if	O
(	O
!	O
strcasecmp	function
(	O
service	pointer
,	O
"help"	pointer
)	O
)	O
{	O
for	O
(	O
sep	pointer
=	O
servtab	struct
;	O
sep	pointer
;	O
sep	pointer
=	O
sep	pointer
->	O
se_next	pointer
)	O
{	O
if	O
(	O
!	O
ISMUX	O
(	O
sep	pointer
)	O
)	O
continue	O
;	O
write	pointer
(	O
s	int
,	O
sep	pointer
->	O
se_service	pointer
,	O
strlen	function
(	O
sep	pointer
->	O
se_service	pointer
)	O
)	O
;	O
strwrite	O
(	O
s	int
,	O
"\r\n"	pointer
)	O
;	O
}	O
_exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
sep	pointer
=	O
servtab	struct
;	O
sep	pointer
;	O
sep	pointer
=	O
sep	pointer
->	O
se_next	pointer
)	O
{	O
if	O
(	O
ISMUX	O
(	O
sep	pointer
)	O
&&	O
!	O
strcasecmp	function
(	O
service	pointer
,	O
sep	pointer
->	O
se_service	pointer
)	O
)	O
{	O
if	O
(	O
ISMUXPLUS	O
(	O
sep	pointer
)	O
)	O
{	O
strwrite	O
(	O
s	int
,	O
"+Go\r\n"	pointer
)	O
;	O
}	O
run_service	function
(	O
s	int
,	O
sep	pointer
)	O
;	O
return	O
;	O
}	O
}	O
strwrite	O
(	O
s	int
,	O
"-Service not available\r\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
void	O
prepenv	function
(	O
int	O
ctrl	int
,	O
struct	O
sockaddr	struct
*	O
sa_client	pointer
,	O
socklen_t	int
sa_len	int
)	O
{	O
char	O
str	array
[	O
16	int
]	O
;	O
char	O
ip	array
[	O
4	int
*	O
INET6_ADDRSTRLEN	int
]	O
;	O
int	O
ret	int
;	O
struct	O
sockaddr_storage	struct
sa_server	struct
;	O
socklen_t	int
len	int
=	O
sizeof	O
(	O
sa_server	struct
)	O
;	O
setenv	function
(	O
"PROTO"	pointer
,	O
"TCP"	pointer
,	O
1	int
)	O
;	O
unsetenv	function
(	O
"TCPLOCALIP"	pointer
)	O
;	O
unsetenv	function
(	O
"TCPLOCALHOST"	pointer
)	O
;	O
unsetenv	function
(	O
"TCPLOCALPORT"	pointer
)	O
;	O
unsetenv	function
(	O
"TCPREMOTEIP"	pointer
)	O
;	O
unsetenv	function
(	O
"TCPREMOTEPORT"	pointer
)	O
;	O
unsetenv	function
(	O
"TCPREMOTEHOST"	pointer
)	O
;	O
if	O
(	O
getsockname	function
(	O
ctrl	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa_server	struct
,	O
&	O
len	int
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"getsockname(): %m"	pointer
)	O
;	O
else	O
{	O
ret	int
=	O
getnameinfo	function
(	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa_server	struct
,	O
len	int
,	O
ip	array
,	O
sizeof	O
(	O
ip	array
)	O
,	O
str	array
,	O
sizeof	O
(	O
str	array
)	O
,	O
NI_NUMERICHOST	int
|	O
NI_NUMERICSERV	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
if	O
(	O
setenv	function
(	O
"TCPLOCALIP"	pointer
,	O
ip	array
,	O
1	int
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setenv (TCPLOCALIP): %m"	pointer
)	O
;	O
else	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Assigned TCPLOCALIP = %s\n"	pointer
,	O
ip	array
)	O
;	O
if	O
(	O
setenv	function
(	O
"TCPLOCALPORT"	pointer
,	O
str	array
,	O
1	int
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setenv (TCPLOCALPORT): %m"	pointer
)	O
;	O
}	O
else	O
syslog	function
(	O
LOG_WARNING	int
,	O
"getnameinfo: %s"	pointer
,	O
gai_strerror	function
(	O
ret	int
)	O
)	O
;	O
if	O
(	O
resolve_option	bool
)	O
{	O
ret	int
=	O
getnameinfo	function
(	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa_server	struct
,	O
len	int
,	O
ip	array
,	O
sizeof	O
(	O
ip	array
)	O
,	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"getnameinfo: %s"	pointer
,	O
gai_strerror	function
(	O
ret	int
)	O
)	O
;	O
else	O
if	O
(	O
setenv	function
(	O
"TCPLOCALHOST"	pointer
,	O
ip	array
,	O
1	int
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setenv(TCPLOCALHOST): %m"	pointer
)	O
;	O
}	O
}	O
ret	int
=	O
getnameinfo	function
(	O
sa_client	pointer
,	O
sa_len	int
,	O
ip	array
,	O
sizeof	O
(	O
ip	array
)	O
,	O
str	array
,	O
sizeof	O
(	O
str	array
)	O
,	O
NI_NUMERICHOST	int
|	O
NI_NUMERICSERV	int
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
if	O
(	O
setenv	function
(	O
"TCPREMOTEIP"	pointer
,	O
ip	array
,	O
1	int
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setenv(TCPREMOTEIP): %m"	pointer
)	O
;	O
else	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Assigned TCPREMOTEIP = %s\n"	pointer
,	O
ip	array
)	O
;	O
if	O
(	O
setenv	function
(	O
"TCPREMOTEPORT"	pointer
,	O
str	array
,	O
1	int
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setenv(TCPREMOTEPORT): %m"	pointer
)	O
;	O
if	O
(	O
resolve_option	bool
)	O
{	O
ret	int
=	O
getnameinfo	function
(	O
sa_client	pointer
,	O
sa_len	int
,	O
ip	array
,	O
sizeof	O
(	O
ip	array
)	O
,	O
NULL	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"getnameinfo: %s"	pointer
,	O
gai_strerror	function
(	O
ret	int
)	O
)	O
;	O
else	O
if	O
(	O
setenv	function
(	O
"TCPREMOTEHOST"	pointer
,	O
ip	array
,	O
1	int
)	O
<	O
0	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"setenv(TCPREMOTEHOST): %m"	pointer
)	O
;	O
else	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Assigned TCPREMOTEHOST = %s\n"	pointer
,	O
ip	array
)	O
;	O
}	O
}	O
else	O
syslog	function
(	O
LOG_WARNING	int
,	O
"getnameinfo: %s"	pointer
,	O
gai_strerror	function
(	O
ret	int
)	O
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	pointer
[	O
]	O
,	O
char	O
*	O
envp	array
[	O
]	O
)	O
{	O
int	O
index	function
;	O
struct	O
servtab	struct
*	O
sep	pointer
;	O
int	O
dofork	int
;	O
pid_t	int
pid	int
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
Argv	pointer
=	O
argv	pointer
;	O
if	O
(	O
envp	array
==	O
0	int
||	O
*	O
envp	array
==	O
0	int
)	O
envp	array
=	O
argv	pointer
;	O
while	O
(	O
*	O
envp	array
)	O
envp	array
++	O
;	O
LastArg	pointer
=	O
envp	array
[	O
-	O
1	int
]	O
+	O
strlen	function
(	O
envp	array
[	O
-	O
1	int
]	O
)	O
;	O
iu_argp_init	O
(	O
"inetd"	pointer
,	O
program_authors	array
)	O
;	O
argp_parse	function
(	O
&	O
argp	struct
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
&	O
index	function
,	O
NULL	O
)	O
;	O
if	O
(	O
resolve_option	bool
)	O
env_option	bool
=	O
true	int
;	O
if	O
(	O
index	function
<	O
argc	int
)	O
{	O
int	O
i	int
;	O
config_files	pointer
=	O
calloc	function
(	O
argc	int
-	O
index	function
+	O
1	int
,	O
sizeof	O
(	O
*	O
config_files	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
index	function
<	O
argc	int
;	O
index	function
++	O
,	O
i	int
++	O
)	O
{	O
config_files	pointer
[	O
i	int
]	O
=	O
strdup	function
(	O
argv	pointer
[	O
index	function
]	O
)	O
;	O
}	O
}	O
else	O
{	O
config_files	pointer
=	O
calloc	function
(	O
3	int
,	O
sizeof	O
(	O
*	O
config_files	pointer
)	O
)	O
;	O
config_files	pointer
[	O
0	int
]	O
=	O
newstr	function
(	O
PATH_INETDCONF	O
)	O
;	O
config_files	pointer
[	O
1	int
]	O
=	O
newstr	function
(	O
PATH_INETDDIR	O
)	O
;	O
}	O
if	O
(	O
!	O
debug	bool
)	O
{	O
daemon	function
(	O
0	int
,	O
0	int
)	O
;	O
}	O
openlog	function
(	O
"inetd"	pointer
,	O
LOG_PID	int
|	O
LOG_NOWAIT	int
,	O
LOG_DAEMON	O
)	O
;	O
if	O
(	O
pidfile_option	bool
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
fopen	function
(	O
pid_file	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
fp	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Using pid-file at \"%s\".\n"	pointer
,	O
pid_file	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%d\n"	pointer
,	O
getpid	function
(	O
)	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
else	O
syslog	function
(	O
LOG_CRIT	int
,	O
"can't open %s: %s\n"	pointer
,	O
pid_file	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
signal_set_handler	function
(	O
SIGALRM	int
,	O
retry	function
)	O
;	O
config	function
(	O
0	int
)	O
;	O
signal_set_handler	function
(	O
SIGHUP	int
,	O
config	function
)	O
;	O
signal_set_handler	function
(	O
SIGCHLD	int
,	O
reapchild	function
)	O
;	O
signal_set_handler	function
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
{	O
char	O
dummy	array
[	O
DUMMYSIZE	int
]	O
;	O
memset	function
(	O
dummy	array
,	O
'x'	O
,	O
DUMMYSIZE	int
-	O
1	int
)	O
;	O
dummy	array
[	O
DUMMYSIZE	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
setenv	function
(	O
"inetd_dummy"	pointer
,	O
dummy	array
,	O
1	int
)	O
;	O
}	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
n	long
,	O
ctrl	int
;	O
fd_set	struct
readable	struct
;	O
if	O
(	O
nsock	int
==	O
0	int
)	O
{	O
SIGSTATUS	O
stat	struct
;	O
sigstatus_empty	O
(	O
stat	struct
)	O
;	O
signal_block	function
(	O
NULL	O
)	O
;	O
while	O
(	O
nsock	int
==	O
0	int
)	O
inetd_pause	O
(	O
stat	struct
)	O
;	O
signal_unblock	function
(	O
NULL	O
)	O
;	O
}	O
readable	struct
=	O
allsock	struct
;	O
if	O
(	O
(	O
n	long
=	O
select	function
(	O
maxsock	int
+	O
1	int
,	O
&	O
readable	struct
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
<=	O
0	int
)	O
{	O
if	O
(	O
n	long
<	O
0	int
&&	O
errno	O
!=	O
EINTR	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"select: %m"	pointer
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
sep	pointer
=	O
servtab	struct
;	O
n	long
&&	O
sep	pointer
;	O
sep	pointer
=	O
sep	pointer
->	O
se_next	pointer
)	O
if	O
(	O
sep	pointer
->	O
se_fd	int
!=	O
-	O
1	int
&&	O
FD_ISSET	O
(	O
sep	pointer
->	O
se_fd	int
,	O
&	O
readable	struct
)	O
)	O
{	O
n	long
--	O
;	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"someone wants %s\n"	pointer
,	O
sep	pointer
->	O
se_service	pointer
)	O
;	O
if	O
(	O
!	O
sep	pointer
->	O
se_wait	int
&&	O
sep	pointer
->	O
se_socktype	int
==	O
SOCK_STREAM	int
)	O
{	O
struct	O
sockaddr_storage	struct
sa_client	pointer
;	O
socklen_t	int
len	int
=	O
sizeof	O
(	O
sa_client	pointer
)	O
;	O
ctrl	int
=	O
accept	function
(	O
sep	pointer
->	O
se_fd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa_client	pointer
,	O
&	O
len	int
)	O
;	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"accept, ctrl %d\n"	pointer
,	O
ctrl	int
)	O
;	O
if	O
(	O
ctrl	int
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
!=	O
EINTR	int
)	O
syslog	function
(	O
LOG_WARNING	int
,	O
"accept (for %s): %m"	pointer
,	O
sep	pointer
->	O
se_service	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
env_option	bool
)	O
prepenv	function
(	O
ctrl	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sa_client	pointer
,	O
len	int
)	O
;	O
}	O
else	O
ctrl	int
=	O
sep	pointer
->	O
se_fd	int
;	O
signal_block	function
(	O
NULL	O
)	O
;	O
pid	int
=	O
0	int
;	O
dofork	int
=	O
(	O
sep	pointer
->	O
se_bi	pointer
==	O
0	int
||	O
sep	pointer
->	O
se_bi	pointer
->	O
bi_fork	short
)	O
;	O
if	O
(	O
dofork	int
)	O
{	O
if	O
(	O
sep	pointer
->	O
se_count	int
++	O
==	O
0	int
)	O
gettimeofday	function
(	O
&	O
sep	pointer
->	O
se_time	struct
,	O
NULL	O
)	O
;	O
else	O
if	O
(	O
(	O
sep	pointer
->	O
se_max	int
&&	O
sep	pointer
->	O
se_count	int
>	O
sep	pointer
->	O
se_max	int
)	O
||	O
sep	pointer
->	O
se_count	int
>=	O
toomany	int
)	O
{	O
struct	O
timeval	struct
now	struct
;	O
gettimeofday	function
(	O
&	O
now	struct
,	O
NULL	O
)	O
;	O
if	O
(	O
now	struct
.	O
tv_sec	long
-	O
sep	pointer
->	O
se_time	struct
.	O
tv_sec	long
>	O
CNT_INTVL	int
)	O
{	O
sep	pointer
->	O
se_time	struct
=	O
now	struct
;	O
sep	pointer
->	O
se_count	int
=	O
1	int
;	O
}	O
else	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"%s/%s server failing (looping), service terminated"	pointer
,	O
sep	pointer
->	O
se_service	pointer
,	O
sep	pointer
->	O
se_proto	pointer
)	O
;	O
close_sep	function
(	O
sep	pointer
)	O
;	O
if	O
(	O
!	O
sep	pointer
->	O
se_wait	int
&&	O
sep	pointer
->	O
se_socktype	int
==	O
SOCK_STREAM	int
)	O
close	pointer
(	O
ctrl	int
)	O
;	O
signal_unblock	function
(	O
NULL	O
)	O
;	O
if	O
(	O
!	O
timingout	int
)	O
{	O
timingout	int
=	O
1	int
;	O
alarm	function
(	O
RETRYTIME	O
)	O
;	O
}	O
continue	O
;	O
}	O
}	O
pid	int
=	O
fork	function
(	O
)	O
;	O
}	O
if	O
(	O
pid	int
<	O
0	int
)	O
{	O
syslog	function
(	O
LOG_ERR	int
,	O
"fork: %m"	pointer
)	O
;	O
if	O
(	O
!	O
sep	pointer
->	O
se_wait	int
&&	O
sep	pointer
->	O
se_socktype	int
==	O
SOCK_STREAM	int
)	O
close	pointer
(	O
ctrl	int
)	O
;	O
signal_unblock	function
(	O
NULL	O
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
pid	int
&&	O
sep	pointer
->	O
se_wait	int
)	O
{	O
sep	pointer
->	O
se_wait	int
=	O
pid	int
;	O
if	O
(	O
sep	pointer
->	O
se_fd	int
>=	O
0	int
)	O
{	O
FD_CLR	O
(	O
sep	pointer
->	O
se_fd	int
,	O
&	O
allsock	struct
)	O
;	O
nsock	int
--	O
;	O
}	O
}	O
signal_unblock	function
(	O
NULL	O
)	O
;	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
if	O
(	O
debug	bool
&&	O
dofork	int
)	O
setsid	function
(	O
)	O
;	O
if	O
(	O
dofork	int
)	O
{	O
int	O
sock	int
;	O
if	O
(	O
debug	bool
)	O
fprintf	function
(	O
stderr	pointer
,	O
"+ Closing from %d\n"	pointer
,	O
maxsock	int
)	O
;	O
for	O
(	O
sock	int
=	O
maxsock	int
;	O
sock	int
>	O
2	int
;	O
sock	int
--	O
)	O
if	O
(	O
sock	int
!=	O
ctrl	int
)	O
close	pointer
(	O
sock	int
)	O
;	O
}	O
run_service	function
(	O
ctrl	int
,	O
sep	pointer
)	O
;	O
}	O
if	O
(	O
!	O
sep	pointer
->	O
se_wait	int
&&	O
sep	pointer
->	O
se_socktype	int
==	O
SOCK_STREAM	int
)	O
close	pointer
(	O
ctrl	int
)	O
;	O
}	O
}	O
}	O
