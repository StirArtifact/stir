static	O
char	O
*	O
data	pointer
;	O
static	O
int	O
help_lines	int
;	O
static	O
int	O
history_ptr	int
;	O
static	O
const	O
char	O
*	O
main_node	pointer
;	O
static	O
const	O
char	O
*	O
last_shown	pointer
=	O
NULL	O
;	O
static	O
int	O
end_of_node	int
=	O
0	int
;	O
static	O
const	O
char	O
*	O
currentpoint	pointer
;	O
static	O
const	O
char	O
*	O
selected_item	pointer
;	O
static	O
Dlg_head	struct
*	O
whelp	pointer
;	O
static	O
struct	O
{	O
const	O
char	O
*	O
page	pointer
;	O
const	O
char	O
*	O
link	function
;	O
}	O
history	pointer
[	O
HISTORY_SIZE	int
]	O
;	O
typedef	O
struct	O
Link_Area	struct
{	O
int	O
x1	int
,	O
y1	int
,	O
x2	int
,	O
y2	int
;	O
const	O
char	O
*	O
link_name	pointer
;	O
struct	O
Link_Area	struct
*	O
next	pointer
;	O
}	O
Link_Area	struct
;	O
static	O
Link_Area	struct
*	O
link_area	pointer
=	O
NULL	O
;	O
static	O
int	O
inside_link_area	int
=	O
0	int
;	O
static	O
cb_ret_t	enum
help_callback	function
(	O
struct	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
,	O
int	O
parm	int
)	O
;	O
static	O
const	O
char	O
*	O
search_string	function
(	O
const	O
char	O
*	O
start	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
const	O
char	O
*	O
result	long
=	O
NULL	O
;	O
char	O
*	O
local_text	pointer
=	O
g_strdup	function
(	O
text	pointer
)	O
;	O
char	O
*	O
d	double
=	O
local_text	pointer
;	O
const	O
char	O
*	O
e	pointer
=	O
start	pointer
;	O
while	O
(	O
*	O
d	double
)	O
{	O
if	O
(	O
*	O
d	double
==	O
'\n'	O
)	O
*	O
d	double
=	O
' '	O
;	O
d	double
++	O
;	O
}	O
for	O
(	O
d	double
=	O
local_text	pointer
;	O
*	O
e	pointer
;	O
e	pointer
++	O
)	O
{	O
if	O
(	O
*	O
d	double
==	O
*	O
e	pointer
)	O
d	double
++	O
;	O
else	O
d	double
=	O
local_text	pointer
;	O
if	O
(	O
!	O
*	O
d	double
)	O
{	O
result	long
=	O
e	pointer
+	O
1	int
;	O
goto	O
cleanup	O
;	O
}	O
}	O
cleanup	O
:	O
g_free	function
(	O
local_text	pointer
)	O
;	O
return	O
result	long
;	O
}	O
static	O
const	O
char	O
*	O
search_string_node	function
(	O
const	O
char	O
*	O
start	pointer
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
const	O
char	O
*	O
d	double
=	O
text	pointer
;	O
const	O
char	O
*	O
e	pointer
=	O
start	pointer
;	O
if	O
(	O
!	O
start	pointer
)	O
return	O
0	int
;	O
for	O
(	O
;	O
*	O
e	pointer
&&	O
*	O
e	pointer
!=	O
CHAR_NODE_END	char
;	O
e	pointer
++	O
)	O
{	O
if	O
(	O
*	O
d	double
==	O
*	O
e	pointer
)	O
d	double
++	O
;	O
else	O
d	double
=	O
text	pointer
;	O
if	O
(	O
!	O
*	O
d	double
)	O
return	O
e	pointer
+	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
search_char_node	function
(	O
const	O
char	O
*	O
start	pointer
,	O
char	O
the_char	char
,	O
int	O
direction	int
)	O
{	O
const	O
char	O
*	O
e	pointer
;	O
e	pointer
=	O
start	pointer
;	O
for	O
(	O
;	O
*	O
e	pointer
&&	O
(	O
*	O
e	pointer
!=	O
CHAR_NODE_END	char
)	O
;	O
e	pointer
+=	O
direction	int
)	O
{	O
if	O
(	O
*	O
e	pointer
==	O
the_char	char
)	O
return	O
e	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
move_forward2	function
(	O
const	O
char	O
*	O
c	int
,	O
int	O
lines	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
int	O
line	int
;	O
currentpoint	pointer
=	O
c	int
;	O
for	O
(	O
line	int
=	O
0	int
,	O
p	pointer
=	O
currentpoint	pointer
;	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
CHAR_NODE_END	char
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
line	int
==	O
lines	pointer
)	O
return	O
currentpoint	pointer
=	O
p	pointer
;	O
if	O
(	O
*	O
p	pointer
==	O
'\n'	O
)	O
line	int
++	O
;	O
}	O
return	O
currentpoint	pointer
=	O
c	int
;	O
}	O
static	O
const	O
char	O
*	O
move_backward2	function
(	O
const	O
char	O
*	O
c	int
,	O
int	O
lines	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
int	O
line	int
;	O
currentpoint	pointer
=	O
c	int
;	O
for	O
(	O
line	int
=	O
0	int
,	O
p	pointer
=	O
currentpoint	pointer
;	O
*	O
p	pointer
&&	O
p	pointer
>=	O
data	pointer
;	O
p	pointer
--	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
CHAR_NODE_END	char
)	O
{	O
while	O
(	O
*	O
p	pointer
!=	O
']'	O
)	O
p	pointer
++	O
;	O
return	O
currentpoint	pointer
=	O
p	pointer
+	O
2	int
;	O
}	O
if	O
(	O
*	O
(	O
p	pointer
-	O
1	int
)	O
==	O
'\n'	O
)	O
line	int
++	O
;	O
if	O
(	O
line	int
==	O
lines	pointer
)	O
return	O
currentpoint	pointer
=	O
p	pointer
;	O
}	O
return	O
currentpoint	pointer
=	O
c	int
;	O
}	O
static	O
void	O
move_forward	function
(	O
int	O
i	array
)	O
{	O
if	O
(	O
end_of_node	int
)	O
return	O
;	O
currentpoint	pointer
=	O
move_forward2	function
(	O
currentpoint	pointer
,	O
i	array
)	O
;	O
}	O
static	O
void	O
move_backward	function
(	O
int	O
i	array
)	O
{	O
currentpoint	pointer
=	O
move_backward2	function
(	O
currentpoint	pointer
,	O
++	O
i	array
)	O
;	O
}	O
static	O
void	O
move_to_top	function
(	O
void	O
)	O
{	O
while	O
(	O
currentpoint	pointer
>	O
data	pointer
&&	O
*	O
currentpoint	pointer
!=	O
CHAR_NODE_END	char
)	O
currentpoint	pointer
--	O
;	O
while	O
(	O
*	O
currentpoint	pointer
!=	O
']'	O
)	O
currentpoint	pointer
++	O
;	O
currentpoint	pointer
=	O
currentpoint	pointer
+	O
2	int
;	O
selected_item	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
move_to_bottom	function
(	O
void	O
)	O
{	O
while	O
(	O
*	O
currentpoint	pointer
&&	O
*	O
currentpoint	pointer
!=	O
CHAR_NODE_END	char
)	O
currentpoint	pointer
++	O
;	O
currentpoint	pointer
--	O
;	O
move_backward	function
(	O
help_lines	int
-	O
1	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
help_follow_link	function
(	O
const	O
char	O
*	O
start	pointer
,	O
const	O
char	O
*	O
selected_item	pointer
)	O
{	O
char	O
link_name	pointer
[	O
MAXLINKNAME	int
]	O
;	O
const	O
char	O
*	O
p	pointer
;	O
int	O
i	array
=	O
0	int
;	O
if	O
(	O
!	O
selected_item	pointer
)	O
return	O
start	pointer
;	O
for	O
(	O
p	pointer
=	O
selected_item	pointer
;	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
CHAR_NODE_END	char
&&	O
*	O
p	pointer
!=	O
CHAR_LINK_POINTER	char
;	O
p	pointer
++	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
CHAR_LINK_POINTER	char
)	O
{	O
link_name	pointer
[	O
0	int
]	O
=	O
'['	O
;	O
for	O
(	O
i	array
=	O
1	int
;	O
*	O
p	pointer
!=	O
CHAR_LINK_END	char
&&	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
CHAR_NODE_END	char
&&	O
i	array
<	O
MAXLINKNAME	int
-	O
3	int
;	O
)	O
link_name	pointer
[	O
i	array
++	O
]	O
=	O
*	O
++	O
p	pointer
;	O
link_name	pointer
[	O
i	array
-	O
1	int
]	O
=	O
']'	O
;	O
link_name	pointer
[	O
i	array
]	O
=	O
0	int
;	O
p	pointer
=	O
search_string	function
(	O
data	pointer
,	O
link_name	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
p	pointer
+=	O
1	int
;	O
return	O
p	pointer
;	O
}	O
}	O
return	O
_	O
(	O
" Help file format error\n"	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
select_next_link	function
(	O
const	O
char	O
*	O
current_link	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
if	O
(	O
!	O
current_link	pointer
)	O
return	O
0	int
;	O
p	pointer
=	O
search_string_node	function
(	O
current_link	pointer
,	O
STRING_LINK_END	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
NULL	O
;	O
p	pointer
=	O
search_string_node	function
(	O
p	pointer
,	O
STRING_LINK_START	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
NULL	O
;	O
return	O
p	pointer
-	O
1	int
;	O
}	O
static	O
const	O
char	O
*	O
select_prev_link	function
(	O
const	O
char	O
*	O
current_link	pointer
)	O
{	O
if	O
(	O
!	O
current_link	pointer
)	O
return	O
0	int
;	O
return	O
search_char_node	function
(	O
current_link	pointer
-	O
1	int
,	O
CHAR_LINK_START	char
,	O
-	O
1	int
)	O
;	O
}	O
static	O
void	O
start_link_area	function
(	O
int	O
x	array
,	O
int	O
y	short
,	O
const	O
char	O
*	O
link_name	pointer
)	O
{	O
Link_Area	struct
*	O
new	pointer
;	O
if	O
(	O
inside_link_area	int
)	O
message	pointer
(	O
0	int
,	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
" Internal bug: Double start of link area "	pointer
)	O
)	O
;	O
new	pointer
=	O
g_new	O
(	O
Link_Area	struct
,	O
1	int
)	O
;	O
new	pointer
->	O
next	pointer
=	O
link_area	pointer
;	O
link_area	pointer
=	O
new	pointer
;	O
link_area	pointer
->	O
x1	int
=	O
x	array
;	O
link_area	pointer
->	O
y1	int
=	O
y	short
;	O
link_area	pointer
->	O
link_name	pointer
=	O
link_name	pointer
;	O
inside_link_area	int
=	O
1	int
;	O
}	O
static	O
void	O
end_link_area	function
(	O
int	O
x	array
,	O
int	O
y	short
)	O
{	O
if	O
(	O
inside_link_area	int
)	O
{	O
link_area	pointer
->	O
x2	int
=	O
x	array
;	O
link_area	pointer
->	O
y2	int
=	O
y	short
;	O
inside_link_area	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
clear_link_areas	function
(	O
void	O
)	O
{	O
Link_Area	struct
*	O
current	pointer
;	O
while	O
(	O
link_area	pointer
)	O
{	O
current	pointer
=	O
link_area	pointer
;	O
link_area	pointer
=	O
current	pointer
->	O
next	pointer
;	O
g_free	function
(	O
current	pointer
)	O
;	O
}	O
inside_link_area	int
=	O
0	int
;	O
}	O
static	O
void	O
help_show	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
const	O
char	O
*	O
paint_start	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
int	O
col	int
,	O
line	int
,	O
c	int
;	O
int	O
painting	int
=	O
1	int
;	O
int	O
acs	int
;	O
int	O
repeat_paint	int
;	O
int	O
active_col	int
,	O
active_line	int
;	O
attrset	function
(	O
HELP_NORMAL_COLOR	O
)	O
;	O
do	O
{	O
line	int
=	O
col	int
=	O
acs	int
=	O
active_col	int
=	O
active_line	int
=	O
repeat_paint	int
=	O
0	int
;	O
clear_link_areas	function
(	O
)	O
;	O
if	O
(	O
selected_item	pointer
<	O
paint_start	pointer
)	O
selected_item	pointer
=	O
NULL	O
;	O
for	O
(	O
p	pointer
=	O
paint_start	pointer
;	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
CHAR_NODE_END	char
&&	O
line	int
<	O
help_lines	int
;	O
p	pointer
++	O
)	O
{	O
c	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
CHAR_LINK_START	char
:	O
if	O
(	O
selected_item	pointer
==	O
NULL	O
)	O
selected_item	pointer
=	O
p	pointer
;	O
if	O
(	O
p	pointer
==	O
selected_item	pointer
)	O
{	O
attrset	function
(	O
HELP_SLINK_COLOR	O
)	O
;	O
active_col	int
=	O
col	int
+	O
2	int
;	O
active_line	int
=	O
line	int
+	O
2	int
;	O
}	O
else	O
attrset	function
(	O
HELP_LINK_COLOR	O
)	O
;	O
start_link_area	function
(	O
col	int
,	O
line	int
,	O
p	pointer
)	O
;	O
break	O
;	O
case	O
CHAR_LINK_POINTER	char
:	O
painting	int
=	O
0	int
;	O
end_link_area	function
(	O
col	int
-	O
1	int
,	O
line	int
)	O
;	O
break	O
;	O
case	O
CHAR_LINK_END	char
:	O
painting	int
=	O
1	int
;	O
attrset	function
(	O
HELP_NORMAL_COLOR	O
)	O
;	O
break	O
;	O
case	O
CHAR_ALTERNATE	char
:	O
acs	int
=	O
1	int
;	O
break	O
;	O
case	O
CHAR_NORMAL	char
:	O
acs	int
=	O
0	int
;	O
break	O
;	O
case	O
CHAR_VERSION	char
:	O
dlg_move	O
(	O
h	pointer
,	O
line	int
+	O
2	int
,	O
col	int
+	O
2	int
)	O
;	O
addstr	O
(	O
VERSION	pointer
)	O
;	O
col	int
+=	O
strlen	function
(	O
VERSION	pointer
)	O
;	O
break	O
;	O
case	O
CHAR_FONT_BOLD	char
:	O
attrset	function
(	O
HELP_BOLD_COLOR	O
)	O
;	O
break	O
;	O
case	O
CHAR_FONT_ITALIC	char
:	O
attrset	function
(	O
HELP_ITALIC_COLOR	O
)	O
;	O
break	O
;	O
case	O
CHAR_FONT_NORMAL	char
:	O
attrset	function
(	O
HELP_NORMAL_COLOR	O
)	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
line	int
++	O
;	O
col	int
=	O
0	int
;	O
break	O
;	O
case	O
'\t'	O
:	O
col	int
=	O
(	O
col	int
/	O
8	int
+	O
1	int
)	O
*	O
8	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
!	O
painting	int
)	O
continue	O
;	O
if	O
(	O
col	int
>	O
HELP_WINDOW_WIDTH	O
-	O
1	int
)	O
continue	O
;	O
dlg_move	O
(	O
h	pointer
,	O
line	int
+	O
2	int
,	O
col	int
+	O
2	int
)	O
;	O
if	O
(	O
acs	int
)	O
{	O
if	O
(	O
c	int
==	O
' '	O
||	O
c	int
==	O
'.'	O
)	O
addch	O
(	O
c	int
)	O
;	O
else	O
SLsmg_draw_object	function
(	O
h	pointer
->	O
y	short
+	O
line	int
+	O
2	int
,	O
h	pointer
->	O
x	array
+	O
col	int
+	O
2	int
,	O
c	int
)	O
;	O
}	O
else	O
addch	O
(	O
c	int
)	O
;	O
col	int
++	O
;	O
break	O
;	O
}	O
}	O
last_shown	pointer
=	O
p	pointer
;	O
end_of_node	int
=	O
line	int
<	O
help_lines	int
;	O
attrset	function
(	O
HELP_NORMAL_COLOR	O
)	O
;	O
if	O
(	O
selected_item	pointer
>=	O
last_shown	pointer
)	O
{	O
if	O
(	O
link_area	pointer
!=	O
NULL	O
)	O
{	O
selected_item	pointer
=	O
link_area	pointer
->	O
link_name	pointer
;	O
repeat_paint	int
=	O
1	int
;	O
}	O
else	O
selected_item	pointer
=	O
NULL	O
;	O
}	O
}	O
while	O
(	O
repeat_paint	int
)	O
;	O
if	O
(	O
active_col	int
)	O
dlg_move	O
(	O
h	pointer
,	O
active_line	int
,	O
active_col	int
)	O
;	O
}	O
static	O
int	O
help_event	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
vp	pointer
)	O
{	O
Widget	struct
*	O
w	pointer
=	O
vp	pointer
;	O
Link_Area	struct
*	O
current_area	pointer
;	O
if	O
(	O
!	O
(	O
event	pointer
->	O
type	enum
&	O
GPM_UP	int
)	O
)	O
return	O
0	int
;	O
event	pointer
->	O
x	array
-=	O
2	int
;	O
event	pointer
->	O
y	short
-=	O
2	int
;	O
if	O
(	O
event	pointer
->	O
buttons	int
&	O
GPM_B_RIGHT	O
)	O
{	O
currentpoint	pointer
=	O
history	pointer
[	O
history_ptr	int
]	O
.	O
page	pointer
;	O
selected_item	pointer
=	O
history	pointer
[	O
history_ptr	int
]	O
.	O
link	function
;	O
history_ptr	int
--	O
;	O
if	O
(	O
history_ptr	int
<	O
0	int
)	O
history_ptr	int
=	O
HISTORY_SIZE	int
-	O
1	int
;	O
help_callback	function
(	O
w	pointer
->	O
parent	pointer
,	O
DLG_DRAW	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
current_area	pointer
=	O
link_area	pointer
;	O
while	O
(	O
current_area	pointer
)	O
{	O
if	O
(	O
event	pointer
->	O
y	short
==	O
current_area	pointer
->	O
y1	int
&&	O
event	pointer
->	O
x	array
>=	O
current_area	pointer
->	O
x1	int
&&	O
event	pointer
->	O
y	short
==	O
current_area	pointer
->	O
y2	int
&&	O
event	pointer
->	O
x	array
<=	O
current_area	pointer
->	O
x2	int
)	O
break	O
;	O
if	O
(	O
current_area	pointer
->	O
y1	int
+	O
1	int
==	O
current_area	pointer
->	O
y2	int
)	O
{	O
if	O
(	O
event	pointer
->	O
y	short
==	O
current_area	pointer
->	O
y1	int
&&	O
event	pointer
->	O
x	array
>=	O
current_area	pointer
->	O
x1	int
)	O
break	O
;	O
if	O
(	O
event	pointer
->	O
y	short
==	O
current_area	pointer
->	O
y2	int
&&	O
event	pointer
->	O
x	array
<=	O
current_area	pointer
->	O
x2	int
)	O
break	O
;	O
}	O
current_area	pointer
=	O
current_area	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
current_area	pointer
)	O
{	O
history_ptr	int
=	O
(	O
history_ptr	int
+	O
1	int
)	O
%	O
HISTORY_SIZE	int
;	O
history	pointer
[	O
history_ptr	int
]	O
.	O
page	pointer
=	O
currentpoint	pointer
;	O
history	pointer
[	O
history_ptr	int
]	O
.	O
link	function
=	O
current_area	pointer
->	O
link_name	pointer
;	O
currentpoint	pointer
=	O
help_follow_link	function
(	O
currentpoint	pointer
,	O
current_area	pointer
->	O
link_name	pointer
)	O
;	O
selected_item	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
event	pointer
->	O
y	short
<	O
0	int
)	O
move_backward	function
(	O
help_lines	int
-	O
1	int
)	O
;	O
else	O
if	O
(	O
event	pointer
->	O
y	short
>=	O
help_lines	int
)	O
move_forward	function
(	O
help_lines	int
-	O
1	int
)	O
;	O
else	O
if	O
(	O
event	pointer
->	O
y	short
<	O
help_lines	int
/	O
2	int
)	O
move_backward	function
(	O
1	int
)	O
;	O
else	O
move_forward	function
(	O
1	int
)	O
;	O
}	O
help_callback	function
(	O
w	pointer
->	O
parent	pointer
,	O
DLG_DRAW	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
help_help_cmd	function
(	O
void	O
*	O
vp	pointer
)	O
{	O
Dlg_head	struct
*	O
h	pointer
=	O
vp	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
history_ptr	int
=	O
(	O
history_ptr	int
+	O
1	int
)	O
%	O
HISTORY_SIZE	int
;	O
history	pointer
[	O
history_ptr	int
]	O
.	O
page	pointer
=	O
currentpoint	pointer
;	O
history	pointer
[	O
history_ptr	int
]	O
.	O
link	function
=	O
selected_item	pointer
;	O
p	pointer
=	O
search_string	function
(	O
data	pointer
,	O
"[How to use help]"	pointer
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
;	O
currentpoint	pointer
=	O
p	pointer
+	O
1	int
;	O
selected_item	pointer
=	O
NULL	O
;	O
help_callback	function
(	O
h	pointer
,	O
DLG_DRAW	int
,	O
0	int
)	O
;	O
}	O
static	O
void	O
help_index_cmd	function
(	O
void	O
*	O
vp	pointer
)	O
{	O
Dlg_head	struct
*	O
h	pointer
=	O
vp	pointer
;	O
const	O
char	O
*	O
new_item	pointer
;	O
if	O
(	O
!	O
(	O
new_item	pointer
=	O
search_string	function
(	O
data	pointer
,	O
"[Contents]"	pointer
)	O
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot find node %s in help file "	pointer
)	O
,	O
"[Contents]"	pointer
)	O
;	O
return	O
;	O
}	O
history_ptr	int
=	O
(	O
history_ptr	int
+	O
1	int
)	O
%	O
HISTORY_SIZE	int
;	O
history	pointer
[	O
history_ptr	int
]	O
.	O
page	pointer
=	O
currentpoint	pointer
;	O
history	pointer
[	O
history_ptr	int
]	O
.	O
link	function
=	O
selected_item	pointer
;	O
currentpoint	pointer
=	O
new_item	pointer
+	O
1	int
;	O
selected_item	pointer
=	O
NULL	O
;	O
help_callback	function
(	O
h	pointer
,	O
DLG_DRAW	int
,	O
0	int
)	O
;	O
}	O
static	O
void	O
help_quit_cmd	function
(	O
void	O
*	O
vp	pointer
)	O
{	O
dlg_stop	function
(	O
(	O
Dlg_head	struct
*	O
)	O
vp	pointer
)	O
;	O
}	O
static	O
void	O
prev_node_cmd	function
(	O
void	O
*	O
vp	pointer
)	O
{	O
Dlg_head	struct
*	O
h	pointer
=	O
vp	pointer
;	O
currentpoint	pointer
=	O
history	pointer
[	O
history_ptr	int
]	O
.	O
page	pointer
;	O
selected_item	pointer
=	O
history	pointer
[	O
history_ptr	int
]	O
.	O
link	function
;	O
history_ptr	int
--	O
;	O
if	O
(	O
history_ptr	int
<	O
0	int
)	O
history_ptr	int
=	O
HISTORY_SIZE	int
-	O
1	int
;	O
help_callback	function
(	O
h	pointer
,	O
DLG_DRAW	int
,	O
0	int
)	O
;	O
}	O
static	O
cb_ret_t	enum
md_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
(	O
void	O
)	O
w	pointer
;	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
static	O
Widget	struct
*	O
mousedispatch_new	function
(	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
yl	int
,	O
int	O
xl	int
)	O
{	O
Widget	struct
*	O
w	pointer
=	O
g_new	O
(	O
Widget	struct
,	O
1	int
)	O
;	O
init_widget	function
(	O
w	pointer
,	O
y	short
,	O
x	array
,	O
yl	int
,	O
xl	int
,	O
md_callback	function
,	O
help_event	function
)	O
;	O
return	O
w	pointer
;	O
}	O
static	O
void	O
help_cmk_move_backward	function
(	O
void	O
*	O
vp	pointer
,	O
int	O
lines	pointer
)	O
{	O
(	O
void	O
)	O
&	O
vp	pointer
;	O
move_backward	function
(	O
lines	pointer
)	O
;	O
}	O
static	O
void	O
help_cmk_move_forward	function
(	O
void	O
*	O
vp	pointer
,	O
int	O
lines	pointer
)	O
{	O
(	O
void	O
)	O
&	O
vp	pointer
;	O
move_forward	function
(	O
lines	pointer
)	O
;	O
}	O
static	O
void	O
help_cmk_moveto_top	function
(	O
void	O
*	O
vp	pointer
,	O
int	O
lines	pointer
)	O
{	O
(	O
void	O
)	O
&	O
vp	pointer
;	O
(	O
void	O
)	O
&	O
lines	pointer
;	O
move_to_top	function
(	O
)	O
;	O
}	O
static	O
void	O
help_cmk_moveto_bottom	function
(	O
void	O
*	O
vp	pointer
,	O
int	O
lines	pointer
)	O
{	O
(	O
void	O
)	O
&	O
vp	pointer
;	O
(	O
void	O
)	O
&	O
lines	pointer
;	O
move_to_bottom	function
(	O
)	O
;	O
}	O
static	O
cb_ret_t	enum
help_handle_key	function
(	O
struct	O
Dlg_head	struct
*	O
h	pointer
,	O
int	O
c	int
)	O
{	O
const	O
char	O
*	O
new_item	pointer
;	O
if	O
(	O
c	int
!=	O
KEY_UP	int
&&	O
c	int
!=	O
KEY_DOWN	int
&&	O
check_movement_keys	function
(	O
c	int
,	O
help_lines	int
,	O
NULL	O
,	O
help_cmk_move_backward	function
,	O
help_cmk_move_forward	function
,	O
help_cmk_moveto_top	function
,	O
help_cmk_moveto_bottom	function
)	O
)	O
{	O
;	O
}	O
else	O
switch	O
(	O
c	int
)	O
{	O
case	O
'l'	O
:	O
case	O
KEY_LEFT	int
:	O
prev_node_cmd	function
(	O
h	pointer
)	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
case	O
KEY_RIGHT	int
:	O
if	O
(	O
!	O
selected_item	pointer
)	O
{	O
}	O
else	O
{	O
history_ptr	int
=	O
(	O
history_ptr	int
+	O
1	int
)	O
%	O
HISTORY_SIZE	int
;	O
history	pointer
[	O
history_ptr	int
]	O
.	O
page	pointer
=	O
currentpoint	pointer
;	O
history	pointer
[	O
history_ptr	int
]	O
.	O
link	function
=	O
selected_item	pointer
;	O
currentpoint	pointer
=	O
help_follow_link	function
(	O
currentpoint	pointer
,	O
selected_item	pointer
)	O
;	O
}	O
selected_item	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
KEY_DOWN	int
:	O
case	O
'\t'	O
:	O
new_item	pointer
=	O
select_next_link	function
(	O
selected_item	pointer
)	O
;	O
if	O
(	O
new_item	pointer
)	O
{	O
selected_item	pointer
=	O
new_item	pointer
;	O
if	O
(	O
selected_item	pointer
>=	O
last_shown	pointer
)	O
{	O
if	O
(	O
c	int
==	O
KEY_DOWN	int
)	O
move_forward	function
(	O
1	int
)	O
;	O
else	O
selected_item	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
KEY_DOWN	int
)	O
move_forward	function
(	O
1	int
)	O
;	O
else	O
selected_item	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
KEY_UP	int
:	O
case	O
ALT	O
(	O
'\t'	O
)	O
:	O
new_item	pointer
=	O
select_prev_link	function
(	O
selected_item	pointer
)	O
;	O
selected_item	pointer
=	O
new_item	pointer
;	O
if	O
(	O
selected_item	pointer
==	O
NULL	O
||	O
selected_item	pointer
<	O
currentpoint	pointer
)	O
{	O
if	O
(	O
c	int
==	O
KEY_UP	int
)	O
move_backward	function
(	O
1	int
)	O
;	O
else	O
{	O
if	O
(	O
link_area	pointer
!=	O
NULL	O
)	O
selected_item	pointer
=	O
link_area	pointer
->	O
link_name	pointer
;	O
else	O
selected_item	pointer
=	O
NULL	O
;	O
}	O
}	O
break	O
;	O
case	O
'n'	O
:	O
new_item	pointer
=	O
currentpoint	pointer
;	O
while	O
(	O
*	O
new_item	pointer
&&	O
*	O
new_item	pointer
!=	O
CHAR_NODE_END	char
)	O
new_item	pointer
++	O
;	O
if	O
(	O
*	O
++	O
new_item	pointer
==	O
'['	O
)	O
{	O
while	O
(	O
*	O
++	O
new_item	pointer
)	O
{	O
if	O
(	O
*	O
new_item	pointer
==	O
']'	O
&&	O
*	O
++	O
new_item	pointer
&&	O
*	O
++	O
new_item	pointer
)	O
{	O
currentpoint	pointer
=	O
new_item	pointer
;	O
selected_item	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
'p'	O
:	O
new_item	pointer
=	O
currentpoint	pointer
;	O
while	O
(	O
new_item	pointer
>	O
data	pointer
+	O
1	int
&&	O
*	O
new_item	pointer
!=	O
CHAR_NODE_END	char
)	O
new_item	pointer
--	O
;	O
new_item	pointer
--	O
;	O
while	O
(	O
new_item	pointer
>	O
data	pointer
&&	O
*	O
new_item	pointer
!=	O
CHAR_NODE_END	char
)	O
new_item	pointer
--	O
;	O
while	O
(	O
*	O
new_item	pointer
!=	O
']'	O
)	O
new_item	pointer
++	O
;	O
currentpoint	pointer
=	O
new_item	pointer
+	O
2	int
;	O
selected_item	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
'c'	O
:	O
help_index_cmd	function
(	O
h	pointer
)	O
;	O
break	O
;	O
case	O
ESC_CHAR	char
:	O
case	O
XCTRL	O
(	O
'g'	O
)	O
:	O
dlg_stop	function
(	O
h	pointer
)	O
;	O
break	O
;	O
default	O
:	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
help_callback	function
(	O
h	pointer
,	O
DLG_DRAW	int
,	O
0	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
static	O
cb_ret_t	enum
help_callback	function
(	O
struct	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
DLG_DRAW	int
:	O
common_dialog_repaint	function
(	O
h	pointer
)	O
;	O
help_show	function
(	O
h	pointer
,	O
currentpoint	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
DLG_KEY	int
:	O
return	O
help_handle_key	function
(	O
h	pointer
,	O
parm	int
)	O
;	O
default	O
:	O
return	O
default_dlg_callback	function
(	O
h	pointer
,	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
void	O
interactive_display_finish	function
(	O
void	O
)	O
{	O
clear_link_areas	function
(	O
)	O
;	O
g_free	function
(	O
data	pointer
)	O
;	O
}	O
void	O
interactive_display	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
node	pointer
)	O
{	O
WButtonBar	struct
*	O
help_bar	pointer
;	O
Widget	struct
*	O
md	pointer
;	O
char	O
*	O
hlpfile	pointer
=	O
NULL	O
;	O
if	O
(	O
filename	pointer
)	O
data	pointer
=	O
load_file	function
(	O
filename	pointer
)	O
;	O
else	O
data	pointer
=	O
load_mc_home_file	function
(	O
"mc.hlp"	pointer
,	O
&	O
hlpfile	pointer
)	O
;	O
if	O
(	O
data	pointer
==	O
NULL	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot open file %s \n %s "	pointer
)	O
,	O
filename	pointer
?	O
filename	pointer
:	O
hlpfile	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
filename	pointer
)	O
g_free	function
(	O
hlpfile	pointer
)	O
;	O
if	O
(	O
!	O
data	pointer
)	O
return	O
;	O
if	O
(	O
!	O
node	pointer
||	O
!	O
*	O
node	pointer
)	O
node	pointer
=	O
"[main]"	pointer
;	O
if	O
(	O
!	O
(	O
main_node	pointer
=	O
search_string	function
(	O
data	pointer
,	O
node	pointer
)	O
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot find node %s in help file "	pointer
)	O
,	O
node	pointer
)	O
;	O
main_node	pointer
=	O
search_string	function
(	O
data	pointer
,	O
"[main]"	pointer
)	O
;	O
if	O
(	O
!	O
main_node	pointer
)	O
{	O
interactive_display_finish	function
(	O
)	O
;	O
return	O
;	O
}	O
}	O
help_lines	int
=	O
min	long
(	O
LINES	O
-	O
4	int
,	O
max	long
(	O
2	int
*	O
LINES	O
/	O
3	int
,	O
18	int
)	O
)	O
;	O
whelp	pointer
=	O
create_dlg	function
(	O
0	int
,	O
0	int
,	O
help_lines	int
+	O
4	int
,	O
HELP_WINDOW_WIDTH	O
+	O
4	int
,	O
dialog_colors	array
,	O
help_callback	function
,	O
"[Help]"	pointer
,	O
_	O
(	O
"Help"	pointer
)	O
,	O
DLG_TRYUP	O
|	O
DLG_CENTER	O
|	O
DLG_WANT_TAB	O
)	O
;	O
selected_item	pointer
=	O
search_string_node	function
(	O
main_node	pointer
,	O
STRING_LINK_START	pointer
)	O
-	O
1	int
;	O
currentpoint	pointer
=	O
main_node	pointer
+	O
1	int
;	O
for	O
(	O
history_ptr	int
=	O
HISTORY_SIZE	int
;	O
history_ptr	int
;	O
)	O
{	O
history_ptr	int
--	O
;	O
history	pointer
[	O
history_ptr	int
]	O
.	O
page	pointer
=	O
currentpoint	pointer
;	O
history	pointer
[	O
history_ptr	int
]	O
.	O
link	function
=	O
selected_item	pointer
;	O
}	O
help_bar	pointer
=	O
buttonbar_new	function
(	O
1	int
)	O
;	O
(	O
(	O
Widget	struct
*	O
)	O
help_bar	pointer
)	O
->	O
y	short
-=	O
whelp	pointer
->	O
y	short
;	O
(	O
(	O
Widget	struct
*	O
)	O
help_bar	pointer
)	O
->	O
x	array
-=	O
whelp	pointer
->	O
x	array
;	O
md	pointer
=	O
mousedispatch_new	function
(	O
1	int
,	O
1	int
,	O
help_lines	int
,	O
HELP_WINDOW_WIDTH	O
-	O
2	int
)	O
;	O
add_widget	function
(	O
whelp	pointer
,	O
md	pointer
)	O
;	O
add_widget	function
(	O
whelp	pointer
,	O
help_bar	pointer
)	O
;	O
buttonbar_set_label_data	function
(	O
whelp	pointer
,	O
1	int
,	O
_	O
(	O
"Help"	pointer
)	O
,	O
help_help_cmd	function
,	O
whelp	pointer
)	O
;	O
buttonbar_set_label_data	function
(	O
whelp	pointer
,	O
2	int
,	O
_	O
(	O
"Index"	pointer
)	O
,	O
help_index_cmd	function
,	O
whelp	pointer
)	O
;	O
buttonbar_set_label_data	function
(	O
whelp	pointer
,	O
3	int
,	O
_	O
(	O
"Prev"	pointer
)	O
,	O
prev_node_cmd	function
,	O
whelp	pointer
)	O
;	O
buttonbar_clear_label	function
(	O
whelp	pointer
,	O
4	int
)	O
;	O
buttonbar_clear_label	function
(	O
whelp	pointer
,	O
5	int
)	O
;	O
buttonbar_clear_label	function
(	O
whelp	pointer
,	O
6	int
)	O
;	O
buttonbar_clear_label	function
(	O
whelp	pointer
,	O
7	int
)	O
;	O
buttonbar_clear_label	function
(	O
whelp	pointer
,	O
8	int
)	O
;	O
buttonbar_clear_label	function
(	O
whelp	pointer
,	O
9	int
)	O
;	O
buttonbar_set_label_data	function
(	O
whelp	pointer
,	O
10	int
,	O
_	O
(	O
"Quit"	pointer
)	O
,	O
help_quit_cmd	function
,	O
whelp	pointer
)	O
;	O
run_dlg	function
(	O
whelp	pointer
)	O
;	O
interactive_display_finish	function
(	O
)	O
;	O
destroy_dlg	function
(	O
whelp	pointer
)	O
;	O
}	O
