static	O
void	O
InpProcess	function
__P	O
(	O
(	O
char	O
*	O
*	O
,	O
int	O
*	O
)	O
)	O
;	O
static	O
void	O
InpAbort	function
__P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
void	O
InpRedisplayLine	function
__P	O
(	O
(	O
int	O
,	O
int	O
,	O
int	O
,	O
int	O
)	O
)	O
;	O
extern	O
struct	O
layer	struct
*	O
flayer	pointer
;	O
extern	O
struct	O
display	struct
*	O
display	struct
;	O
extern	O
struct	O
mchar	struct
mchar_blank	struct
,	O
mchar_so	struct
;	O
struct	O
inpline	struct
{	O
char	O
buf	pointer
[	O
MAXSTR	int
+	O
1	int
]	O
;	O
int	O
len	int
;	O
int	O
pos	int
;	O
struct	O
inpline	struct
*	O
next	pointer
,	O
*	O
prev	pointer
;	O
}	O
;	O
static	O
struct	O
inpline	struct
inphist	struct
;	O
struct	O
inpdata	struct
{	O
struct	O
inpline	struct
inp	struct
;	O
int	O
inpmaxlen	int
;	O
char	O
*	O
inpstring	pointer
;	O
int	O
inpstringlen	int
;	O
int	O
inpmode	int
;	O
void	O
(	O
*	O
inpfinfunc	pointer
)	O
__P	O
(	O
(	O
char	O
*	O
buf	pointer
,	O
int	O
len	int
,	O
char	O
*	O
priv	pointer
)	O
)	O
;	O
char	O
*	O
priv	pointer
;	O
int	O
privdata	int
;	O
char	O
*	O
search	pointer
;	O
}	O
;	O
static	O
struct	O
LayFuncs	struct
InpLf	struct
=	O
{	O
InpProcess	function
,	O
InpAbort	function
,	O
InpRedisplayLine	function
,	O
DefClearLine	function
,	O
DefRewrite	function
,	O
DefResize	function
,	O
DefRestore	function
,	O
0	int
}	O
;	O
void	O
inp_setprompt	function
(	O
p	pointer
,	O
s	pointer
)	O
char	O
*	O
p	pointer
,	O
*	O
s	pointer
;	O
{	O
struct	O
inpdata	struct
*	O
inpdata	struct
;	O
inpdata	struct
=	O
(	O
struct	O
inpdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
if	O
(	O
p	pointer
)	O
{	O
inpdata	struct
->	O
inpstringlen	int
=	O
strlen	function
(	O
p	pointer
)	O
;	O
inpdata	struct
->	O
inpstring	pointer
=	O
p	pointer
;	O
}	O
if	O
(	O
s	pointer
)	O
{	O
if	O
(	O
s	pointer
!=	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
)	O
strncpy	function
(	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
,	O
s	pointer
,	O
sizeof	O
(	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
)	O
-	O
1	int
)	O
;	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
[	O
sizeof	O
(	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
)	O
-	O
1	int
]	O
=	O
0	int
;	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
=	O
inpdata	struct
->	O
inp	struct
.	O
len	int
=	O
strlen	function
(	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
)	O
;	O
}	O
InpRedisplayLine	function
(	O
INPUTLINE	O
,	O
0	int
,	O
flayer	pointer
->	O
l_width	int
-	O
1	int
,	O
0	int
)	O
;	O
flayer	pointer
->	O
l_x	int
=	O
inpdata	struct
->	O
inpstringlen	int
+	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_NOECHO	int
?	O
0	int
:	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
)	O
;	O
flayer	pointer
->	O
l_y	int
=	O
INPUTLINE	O
;	O
}	O
void	O
Input	function
(	O
istr	pointer
,	O
len	int
,	O
mode	struct
,	O
finfunc	pointer
,	O
priv	pointer
,	O
data	pointer
)	O
char	O
*	O
istr	pointer
;	O
int	O
len	int
;	O
int	O
mode	struct
;	O
void	O
(	O
*	O
finfunc	pointer
)	O
__P	O
(	O
(	O
char	O
*	O
buf	pointer
,	O
int	O
len	int
,	O
char	O
*	O
priv	pointer
)	O
)	O
;	O
char	O
*	O
priv	pointer
;	O
int	O
data	pointer
;	O
{	O
int	O
maxlen	int
;	O
struct	O
inpdata	struct
*	O
inpdata	struct
;	O
if	O
(	O
!	O
flayer	pointer
)	O
return	O
;	O
if	O
(	O
len	int
>	O
MAXSTR	int
)	O
len	int
=	O
MAXSTR	int
;	O
if	O
(	O
!	O
(	O
mode	struct
&	O
INP_NOECHO	int
)	O
)	O
{	O
maxlen	int
=	O
flayer	pointer
->	O
l_width	int
-	O
1	int
-	O
strlen	function
(	O
istr	pointer
)	O
;	O
if	O
(	O
len	int
>	O
maxlen	int
)	O
len	int
=	O
maxlen	int
;	O
}	O
if	O
(	O
len	int
<	O
0	int
)	O
{	O
LMsg	function
(	O
0	int
,	O
"Width %d chars too small"	pointer
,	O
-	O
len	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
InitOverlayPage	function
(	O
sizeof	O
(	O
*	O
inpdata	struct
)	O
,	O
&	O
InpLf	struct
,	O
1	int
)	O
)	O
return	O
;	O
flayer	pointer
->	O
l_mode	int
=	O
1	int
;	O
inpdata	struct
=	O
(	O
struct	O
inpdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
inpdata	struct
->	O
inpmaxlen	int
=	O
len	int
;	O
inpdata	struct
->	O
inpfinfunc	pointer
=	O
finfunc	pointer
;	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
=	O
inpdata	struct
->	O
inp	struct
.	O
len	int
=	O
0	int
;	O
inpdata	struct
->	O
inp	struct
.	O
prev	pointer
=	O
inphist	struct
.	O
prev	pointer
;	O
inpdata	struct
->	O
inpmode	int
=	O
mode	struct
;	O
inpdata	struct
->	O
privdata	int
=	O
data	pointer
;	O
if	O
(	O
!	O
priv	pointer
)	O
priv	pointer
=	O
(	O
char	O
*	O
)	O
&	O
inpdata	struct
->	O
privdata	int
;	O
inpdata	struct
->	O
priv	pointer
=	O
priv	pointer
;	O
inpdata	struct
->	O
inpstringlen	int
=	O
0	int
;	O
inpdata	struct
->	O
inpstring	pointer
=	O
NULL	O
;	O
inpdata	struct
->	O
search	pointer
=	O
NULL	O
;	O
if	O
(	O
istr	pointer
)	O
inp_setprompt	function
(	O
istr	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
static	O
void	O
erase_chars	function
(	O
inpdata	struct
,	O
from	pointer
,	O
to	pointer
,	O
x	int
,	O
mv	int
)	O
struct	O
inpdata	struct
*	O
inpdata	struct
;	O
char	O
*	O
from	pointer
;	O
char	O
*	O
to	pointer
;	O
int	O
x	int
;	O
int	O
mv	int
;	O
{	O
int	O
chng	int
;	O
ASSERT	O
(	O
from	pointer
<	O
to	pointer
)	O
;	O
if	O
(	O
inpdata	struct
->	O
inp	struct
.	O
len	int
>	O
to	pointer
-	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
)	O
bcopy	function
(	O
to	pointer
,	O
from	pointer
,	O
inpdata	struct
->	O
inp	struct
.	O
len	int
-	O
(	O
to	pointer
-	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
)	O
)	O
;	O
chng	int
=	O
to	pointer
-	O
from	pointer
;	O
if	O
(	O
mv	int
)	O
{	O
x	int
-=	O
chng	int
;	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
-=	O
chng	int
;	O
}	O
inpdata	struct
->	O
inp	struct
.	O
len	int
-=	O
chng	int
;	O
if	O
(	O
!	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_NOECHO	int
)	O
)	O
{	O
struct	O
mchar	struct
mc	struct
;	O
char	O
*	O
s	pointer
=	O
from	pointer
<	O
to	pointer
?	O
from	pointer
:	O
to	pointer
;	O
mc	struct
=	O
mchar_so	struct
;	O
while	O
(	O
s	pointer
<	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
+	O
inpdata	struct
->	O
inp	struct
.	O
len	int
)	O
{	O
mc	struct
.	O
image	char
=	O
*	O
s	pointer
++	O
;	O
LPutChar	function
(	O
flayer	pointer
,	O
&	O
mc	struct
,	O
x	int
++	O
,	O
INPUTLINE	O
)	O
;	O
}	O
while	O
(	O
chng	int
--	O
)	O
LPutChar	function
(	O
flayer	pointer
,	O
&	O
mchar_blank	struct
,	O
x	int
++	O
,	O
INPUTLINE	O
)	O
;	O
x	int
=	O
inpdata	struct
->	O
inpstringlen	int
+	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
x	int
,	O
INPUTLINE	O
)	O
;	O
}	O
}	O
static	O
void	O
InpProcess	function
(	O
ppbuf	pointer
,	O
plen	pointer
)	O
char	O
*	O
*	O
ppbuf	pointer
;	O
int	O
*	O
plen	pointer
;	O
{	O
int	O
len	int
,	O
x	int
;	O
char	O
*	O
pbuf	pointer
;	O
char	O
ch	char
;	O
struct	O
inpdata	struct
*	O
inpdata	struct
;	O
struct	O
display	struct
*	O
inpdisplay	pointer
;	O
int	O
prev	pointer
,	O
next	pointer
,	O
search	pointer
=	O
0	int
;	O
inpdata	struct
=	O
(	O
struct	O
inpdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
inpdisplay	pointer
=	O
display	struct
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
inpdata	struct
->	O
inpstringlen	int
+	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_NOECHO	int
?	O
0	int
:	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
)	O
,	O
INPUTLINE	O
)	O
;	O
if	O
(	O
ppbuf	pointer
==	O
0	int
)	O
{	O
InpAbort	function
(	O
)	O
;	O
return	O
;	O
}	O
x	int
=	O
inpdata	struct
->	O
inpstringlen	int
+	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
;	O
len	int
=	O
*	O
plen	pointer
;	O
pbuf	pointer
=	O
*	O
ppbuf	pointer
;	O
while	O
(	O
len	int
)	O
{	O
char	O
*	O
p	pointer
=	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
+	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
;	O
ch	char
=	O
*	O
pbuf	pointer
++	O
;	O
len	int
--	O
;	O
if	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_EVERY	int
)	O
{	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
[	O
inpdata	struct
->	O
inp	struct
.	O
len	int
]	O
=	O
ch	char
;	O
if	O
(	O
ch	char
)	O
{	O
display	struct
=	O
inpdisplay	pointer
;	O
(	O
*	O
inpdata	struct
->	O
inpfinfunc	pointer
)	O
(	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
,	O
inpdata	struct
->	O
inp	struct
.	O
len	int
,	O
inpdata	struct
->	O
priv	pointer
)	O
;	O
ch	char
=	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
[	O
inpdata	struct
->	O
inp	struct
.	O
len	int
]	O
;	O
}	O
}	O
else	O
if	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_RAW	int
)	O
{	O
display	struct
=	O
inpdisplay	pointer
;	O
(	O
*	O
inpdata	struct
->	O
inpfinfunc	pointer
)	O
(	O
&	O
ch	char
,	O
1	int
,	O
inpdata	struct
->	O
priv	pointer
)	O
;	O
if	O
(	O
ch	char
)	O
continue	O
;	O
}	O
if	O
(	O
(	O
(	O
unsigned	O
char	O
)	O
ch	char
&	O
0177	int
)	O
>=	O
' '	O
&&	O
ch	char
!=	O
0177	int
&&	O
inpdata	struct
->	O
inp	struct
.	O
len	int
<	O
inpdata	struct
->	O
inpmaxlen	int
)	O
{	O
if	O
(	O
inpdata	struct
->	O
inp	struct
.	O
len	int
>	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
)	O
bcopy	function
(	O
p	pointer
,	O
p	pointer
+	O
1	int
,	O
inpdata	struct
->	O
inp	struct
.	O
len	int
-	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
)	O
;	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
[	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
++	O
]	O
=	O
ch	char
;	O
inpdata	struct
->	O
inp	struct
.	O
len	int
++	O
;	O
if	O
(	O
!	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_NOECHO	int
)	O
)	O
{	O
struct	O
mchar	struct
mc	struct
;	O
mc	struct
=	O
mchar_so	struct
;	O
mc	struct
.	O
image	char
=	O
*	O
p	pointer
++	O
;	O
LPutChar	function
(	O
flayer	pointer
,	O
&	O
mc	struct
,	O
x	int
,	O
INPUTLINE	O
)	O
;	O
x	int
++	O
;	O
if	O
(	O
p	pointer
<	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
+	O
inpdata	struct
->	O
inp	struct
.	O
len	int
)	O
{	O
while	O
(	O
p	pointer
<	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
+	O
inpdata	struct
->	O
inp	struct
.	O
len	int
)	O
{	O
mc	struct
.	O
image	char
=	O
*	O
p	pointer
++	O
;	O
LPutChar	function
(	O
flayer	pointer
,	O
&	O
mc	struct
,	O
x	int
++	O
,	O
INPUTLINE	O
)	O
;	O
}	O
x	int
=	O
inpdata	struct
->	O
inpstringlen	int
+	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
x	int
,	O
INPUTLINE	O
)	O
;	O
}	O
}	O
RESET_SEARCH	O
;	O
}	O
else	O
if	O
(	O
(	O
ch	char
==	O
'\b'	O
||	O
ch	char
==	O
0177	int
)	O
&&	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
>	O
0	int
)	O
{	O
erase_chars	function
(	O
inpdata	struct
,	O
p	pointer
-	O
1	int
,	O
p	pointer
,	O
x	int
,	O
1	int
)	O
;	O
RESET_SEARCH	O
;	O
}	O
else	O
if	O
(	O
ch	char
==	O
'\025'	O
)	O
{	O
x	int
=	O
inpdata	struct
->	O
inpstringlen	int
;	O
if	O
(	O
inpdata	struct
->	O
inp	struct
.	O
len	int
&&	O
!	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_NOECHO	int
)	O
)	O
{	O
LClearArea	function
(	O
flayer	pointer
,	O
x	int
,	O
INPUTLINE	O
,	O
x	int
+	O
inpdata	struct
->	O
inp	struct
.	O
len	int
-	O
1	int
,	O
INPUTLINE	O
,	O
0	int
,	O
0	int
)	O
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
x	int
,	O
INPUTLINE	O
)	O
;	O
}	O
inpdata	struct
->	O
inp	struct
.	O
len	int
=	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ch	char
==	O
'\013'	O
)	O
{	O
x	int
=	O
inpdata	struct
->	O
inpstringlen	int
+	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
;	O
if	O
(	O
inpdata	struct
->	O
inp	struct
.	O
len	int
>	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
&&	O
!	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_NOECHO	int
)	O
)	O
{	O
LClearArea	function
(	O
flayer	pointer
,	O
x	int
,	O
INPUTLINE	O
,	O
x	int
+	O
inpdata	struct
->	O
inp	struct
.	O
len	int
-	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
-	O
1	int
,	O
INPUTLINE	O
,	O
0	int
,	O
0	int
)	O
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
x	int
,	O
INPUTLINE	O
)	O
;	O
}	O
inpdata	struct
->	O
inp	struct
.	O
len	int
=	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
;	O
}	O
else	O
if	O
(	O
ch	char
==	O
'\027'	O
&&	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
>	O
0	int
)	O
{	O
char	O
*	O
oldp	pointer
=	O
p	pointer
--	O
;	O
while	O
(	O
p	pointer
>	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
&&	O
*	O
p	pointer
==	O
' '	O
)	O
p	pointer
--	O
;	O
while	O
(	O
p	pointer
>	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
&&	O
*	O
(	O
p	pointer
-	O
1	int
)	O
!=	O
' '	O
)	O
p	pointer
--	O
;	O
erase_chars	function
(	O
inpdata	struct
,	O
p	pointer
,	O
oldp	pointer
,	O
x	int
,	O
1	int
)	O
;	O
RESET_SEARCH	O
;	O
}	O
else	O
if	O
(	O
ch	char
==	O
'\004'	O
&&	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
<	O
inpdata	struct
->	O
inp	struct
.	O
len	int
)	O
{	O
erase_chars	function
(	O
inpdata	struct
,	O
p	pointer
,	O
p	pointer
+	O
1	int
,	O
x	int
,	O
0	int
)	O
;	O
RESET_SEARCH	O
;	O
}	O
else	O
if	O
(	O
ch	char
==	O
'\001'	O
||	O
(	O
unsigned	O
char	O
)	O
ch	char
==	O
0201	int
)	O
{	O
LGotoPos	function
(	O
flayer	pointer
,	O
x	int
-=	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
,	O
INPUTLINE	O
)	O
;	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
ch	char
==	O
'\002'	O
||	O
(	O
unsigned	O
char	O
)	O
ch	char
==	O
0202	int
)	O
&&	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
>	O
0	int
)	O
{	O
LGotoPos	function
(	O
flayer	pointer
,	O
--	O
x	int
,	O
INPUTLINE	O
)	O
;	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
--	O
;	O
}	O
else	O
if	O
(	O
ch	char
==	O
'\005'	O
||	O
(	O
unsigned	O
char	O
)	O
ch	char
==	O
0205	int
)	O
{	O
LGotoPos	function
(	O
flayer	pointer
,	O
x	int
+=	O
inpdata	struct
->	O
inp	struct
.	O
len	int
-	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
,	O
INPUTLINE	O
)	O
;	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
=	O
inpdata	struct
->	O
inp	struct
.	O
len	int
;	O
}	O
else	O
if	O
(	O
(	O
ch	char
==	O
'\006'	O
||	O
(	O
unsigned	O
char	O
)	O
ch	char
==	O
0206	int
)	O
&&	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
<	O
inpdata	struct
->	O
inp	struct
.	O
len	int
)	O
{	O
LGotoPos	function
(	O
flayer	pointer
,	O
++	O
x	int
,	O
INPUTLINE	O
)	O
;	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
++	O
;	O
}	O
else	O
if	O
(	O
(	O
prev	pointer
=	O
(	O
(	O
ch	char
==	O
'\020'	O
||	O
(	O
unsigned	O
char	O
)	O
ch	char
==	O
0220	int
)	O
&&	O
inpdata	struct
->	O
inp	struct
.	O
prev	pointer
)	O
)	O
||	O
(	O
next	pointer
=	O
(	O
(	O
ch	char
==	O
'\016'	O
||	O
(	O
unsigned	O
char	O
)	O
ch	char
==	O
0216	int
)	O
&&	O
inpdata	struct
->	O
inp	struct
.	O
next	pointer
)	O
)	O
||	O
(	O
search	pointer
=	O
(	O
(	O
ch	char
==	O
'\022'	O
||	O
(	O
unsigned	O
char	O
)	O
ch	char
==	O
0222	int
)	O
&&	O
inpdata	struct
->	O
inp	struct
.	O
prev	pointer
)	O
)	O
)	O
{	O
struct	O
mchar	struct
mc	struct
;	O
struct	O
inpline	struct
*	O
sel	pointer
;	O
int	O
pos	int
=	O
-	O
1	int
;	O
mc	struct
=	O
mchar_so	struct
;	O
if	O
(	O
prev	pointer
)	O
sel	pointer
=	O
inpdata	struct
->	O
inp	struct
.	O
prev	pointer
;	O
else	O
if	O
(	O
next	pointer
)	O
sel	pointer
=	O
inpdata	struct
->	O
inp	struct
.	O
next	pointer
;	O
else	O
{	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
[	O
inpdata	struct
->	O
inp	struct
.	O
len	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
inpdata	struct
->	O
search	pointer
)	O
inpdata	struct
->	O
search	pointer
=	O
SaveStr	function
(	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
)	O
;	O
for	O
(	O
sel	pointer
=	O
inpdata	struct
->	O
inp	struct
.	O
prev	pointer
;	O
sel	pointer
;	O
sel	pointer
=	O
sel	pointer
->	O
prev	pointer
)	O
{	O
char	O
*	O
f	pointer
;	O
if	O
(	O
(	O
f	pointer
=	O
strstr	function
(	O
sel	pointer
->	O
buf	pointer
,	O
inpdata	struct
->	O
search	pointer
)	O
)	O
)	O
{	O
pos	int
=	O
f	pointer
-	O
sel	pointer
->	O
buf	pointer
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
sel	pointer
)	O
continue	O
;	O
}	O
if	O
(	O
inpdata	struct
->	O
inp	struct
.	O
len	int
&&	O
!	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_NOECHO	int
)	O
)	O
LClearArea	function
(	O
flayer	pointer
,	O
inpdata	struct
->	O
inpstringlen	int
,	O
INPUTLINE	O
,	O
inpdata	struct
->	O
inpstringlen	int
+	O
inpdata	struct
->	O
inp	struct
.	O
len	int
-	O
1	int
,	O
INPUTLINE	O
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
(	O
prev	pointer
||	O
search	pointer
)	O
&&	O
!	O
inpdata	struct
->	O
inp	struct
.	O
next	pointer
)	O
inphist	struct
=	O
inpdata	struct
->	O
inp	struct
;	O
memcpy	function
(	O
&	O
inpdata	struct
->	O
inp	struct
,	O
sel	pointer
,	O
sizeof	O
(	O
struct	O
inpline	struct
)	O
)	O
;	O
if	O
(	O
pos	int
!=	O
-	O
1	int
)	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
=	O
pos	int
;	O
if	O
(	O
inpdata	struct
->	O
inp	struct
.	O
len	int
>	O
inpdata	struct
->	O
inpmaxlen	int
)	O
inpdata	struct
->	O
inp	struct
.	O
len	int
=	O
inpdata	struct
->	O
inpmaxlen	int
;	O
if	O
(	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
>	O
inpdata	struct
->	O
inp	struct
.	O
len	int
)	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
=	O
inpdata	struct
->	O
inp	struct
.	O
len	int
;	O
x	int
=	O
inpdata	struct
->	O
inpstringlen	int
;	O
p	pointer
=	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
;	O
if	O
(	O
!	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_NOECHO	int
)	O
)	O
{	O
while	O
(	O
p	pointer
<	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
+	O
inpdata	struct
->	O
inp	struct
.	O
len	int
)	O
{	O
mc	struct
.	O
image	char
=	O
*	O
p	pointer
++	O
;	O
LPutChar	function
(	O
flayer	pointer
,	O
&	O
mc	struct
,	O
x	int
++	O
,	O
INPUTLINE	O
)	O
;	O
}	O
}	O
x	int
=	O
inpdata	struct
->	O
inpstringlen	int
+	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
;	O
LGotoPos	function
(	O
flayer	pointer
,	O
x	int
,	O
INPUTLINE	O
)	O
;	O
}	O
else	O
if	O
(	O
ch	char
==	O
'\003'	O
||	O
ch	char
==	O
'\007'	O
||	O
ch	char
==	O
'\033'	O
||	O
ch	char
==	O
'\000'	O
||	O
ch	char
==	O
'\n'	O
||	O
ch	char
==	O
'\r'	O
)	O
{	O
if	O
(	O
ch	char
!=	O
'\n'	O
&&	O
ch	char
!=	O
'\r'	O
)	O
inpdata	struct
->	O
inp	struct
.	O
len	int
=	O
0	int
;	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
[	O
inpdata	struct
->	O
inp	struct
.	O
len	int
]	O
=	O
0	int
;	O
if	O
(	O
inpdata	struct
->	O
inp	struct
.	O
len	int
&&	O
!	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
(	O
INP_NOECHO	int
|	O
INP_RAW	int
)	O
)	O
)	O
{	O
struct	O
inpline	struct
*	O
store	pointer
;	O
for	O
(	O
store	pointer
=	O
inphist	struct
.	O
prev	pointer
;	O
store	pointer
;	O
store	pointer
=	O
store	pointer
->	O
prev	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
store	pointer
->	O
buf	pointer
,	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
store	pointer
->	O
next	pointer
)	O
store	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
store	pointer
->	O
prev	pointer
;	O
if	O
(	O
store	pointer
->	O
prev	pointer
)	O
store	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
store	pointer
->	O
next	pointer
;	O
store	pointer
->	O
pos	int
=	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
store	pointer
)	O
{	O
store	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
inpline	struct
)	O
)	O
;	O
memcpy	function
(	O
store	pointer
,	O
&	O
inpdata	struct
->	O
inp	struct
,	O
sizeof	O
(	O
struct	O
inpline	struct
)	O
)	O
;	O
}	O
store	pointer
->	O
next	pointer
=	O
&	O
inphist	struct
;	O
store	pointer
->	O
prev	pointer
=	O
inphist	struct
.	O
prev	pointer
;	O
if	O
(	O
inphist	struct
.	O
prev	pointer
)	O
inphist	struct
.	O
prev	pointer
->	O
next	pointer
=	O
store	pointer
;	O
inphist	struct
.	O
prev	pointer
=	O
store	pointer
;	O
}	O
flayer	pointer
->	O
l_data	pointer
=	O
0	int
;	O
InpAbort	function
(	O
)	O
;	O
*	O
ppbuf	pointer
=	O
pbuf	pointer
;	O
*	O
plen	pointer
=	O
len	int
;	O
display	struct
=	O
inpdisplay	pointer
;	O
if	O
(	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_RAW	int
)	O
==	O
0	int
)	O
(	O
*	O
inpdata	struct
->	O
inpfinfunc	pointer
)	O
(	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
,	O
inpdata	struct
->	O
inp	struct
.	O
len	int
,	O
inpdata	struct
->	O
priv	pointer
)	O
;	O
else	O
(	O
*	O
inpdata	struct
->	O
inpfinfunc	pointer
)	O
(	O
pbuf	pointer
-	O
1	int
,	O
0	int
,	O
inpdata	struct
->	O
priv	pointer
)	O
;	O
if	O
(	O
inpdata	struct
->	O
search	pointer
)	O
free	function
(	O
inpdata	struct
->	O
search	pointer
)	O
;	O
free	function
(	O
inpdata	struct
)	O
;	O
return	O
;	O
}	O
else	O
{	O
RESET_SEARCH	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_RAW	int
)	O
)	O
{	O
flayer	pointer
->	O
l_x	int
=	O
inpdata	struct
->	O
inpstringlen	int
+	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_NOECHO	int
?	O
0	int
:	O
inpdata	struct
->	O
inp	struct
.	O
pos	int
)	O
;	O
flayer	pointer
->	O
l_y	int
=	O
INPUTLINE	O
;	O
}	O
*	O
ppbuf	pointer
=	O
pbuf	pointer
;	O
*	O
plen	pointer
=	O
len	int
;	O
}	O
static	O
void	O
InpAbort	function
(	O
)	O
{	O
LAY_CALL_UP	O
(	O
LayRedisplayLine	O
(	O
INPUTLINE	O
,	O
0	int
,	O
flayer	pointer
->	O
l_width	int
-	O
1	int
,	O
0	int
)	O
)	O
;	O
ExitOverlayPage	function
(	O
)	O
;	O
}	O
static	O
void	O
InpRedisplayLine	function
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
isblank	int
)	O
int	O
y	int
,	O
xs	int
,	O
xe	int
,	O
isblank	int
;	O
{	O
int	O
q	int
,	O
r	int
,	O
s	pointer
,	O
l	int
,	O
v	int
;	O
struct	O
inpdata	struct
*	O
inpdata	struct
;	O
inpdata	struct
=	O
(	O
struct	O
inpdata	struct
*	O
)	O
flayer	pointer
->	O
l_data	pointer
;	O
if	O
(	O
y	int
!=	O
INPUTLINE	O
)	O
{	O
LAY_CALL_UP	O
(	O
LayRedisplayLine	O
(	O
y	int
,	O
xs	int
,	O
xe	int
,	O
isblank	int
)	O
)	O
;	O
return	O
;	O
}	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
[	O
inpdata	struct
->	O
inp	struct
.	O
len	int
]	O
=	O
0	int
;	O
q	int
=	O
xs	int
;	O
v	int
=	O
xe	int
-	O
xs	int
+	O
1	int
;	O
s	pointer
=	O
0	int
;	O
r	int
=	O
inpdata	struct
->	O
inpstringlen	int
;	O
if	O
(	O
v	int
>	O
0	int
&&	O
q	int
<	O
r	int
)	O
{	O
l	int
=	O
v	int
;	O
if	O
(	O
l	int
>	O
r	int
-	O
q	int
)	O
l	int
=	O
r	int
-	O
q	int
;	O
LPutStr	function
(	O
flayer	pointer
,	O
inpdata	struct
->	O
inpstring	pointer
+	O
q	int
-	O
s	pointer
,	O
l	int
,	O
&	O
mchar_so	struct
,	O
q	int
,	O
y	int
)	O
;	O
q	int
+=	O
l	int
;	O
v	int
-=	O
l	int
;	O
}	O
s	pointer
=	O
r	int
;	O
r	int
+=	O
inpdata	struct
->	O
inp	struct
.	O
len	int
;	O
if	O
(	O
!	O
(	O
inpdata	struct
->	O
inpmode	int
&	O
INP_NOECHO	int
)	O
&&	O
v	int
>	O
0	int
&&	O
q	int
<	O
r	int
)	O
{	O
l	int
=	O
v	int
;	O
if	O
(	O
l	int
>	O
r	int
-	O
q	int
)	O
l	int
=	O
r	int
-	O
q	int
;	O
LPutStr	function
(	O
flayer	pointer
,	O
inpdata	struct
->	O
inp	struct
.	O
buf	pointer
+	O
q	int
-	O
s	pointer
,	O
l	int
,	O
&	O
mchar_so	struct
,	O
q	int
,	O
y	int
)	O
;	O
q	int
+=	O
l	int
;	O
v	int
-=	O
l	int
;	O
}	O
s	pointer
=	O
r	int
;	O
r	int
=	O
flayer	pointer
->	O
l_width	int
;	O
if	O
(	O
!	O
isblank	int
&&	O
v	int
>	O
0	int
&&	O
q	int
<	O
r	int
)	O
{	O
l	int
=	O
v	int
;	O
if	O
(	O
l	int
>	O
r	int
-	O
q	int
)	O
l	int
=	O
r	int
-	O
q	int
;	O
LClearArea	function
(	O
flayer	pointer
,	O
q	int
,	O
y	int
,	O
q	int
+	O
l	int
-	O
1	int
,	O
y	int
,	O
0	int
,	O
0	int
)	O
;	O
q	int
+=	O
l	int
;	O
}	O
}	O
