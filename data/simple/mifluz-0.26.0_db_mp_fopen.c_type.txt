static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: mp_fopen.c,v 1.6 2000/06/28 16:47:02 loic Exp $"	pointer
;	O
static	O
int	O
__memp_mf_open	function
__P	O
(	O
(	O
DB_MPOOL	struct
*	O
,	O
const	O
char	O
*	O
,	O
size_t	long
,	O
db_pgno_t	int
,	O
DB_MPOOL_FINFO	struct
*	O
,	O
u_int32_t	int
,	O
MPOOLFILE	struct
*	O
*	O
)	O
)	O
;	O
int	O
CDB_memp_fopen	function
(	O
dbenv	pointer
,	O
path	pointer
,	O
flags	int
,	O
mode	enum
,	O
pagesize	long
,	O
finfop	pointer
,	O
retp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
const	O
char	O
*	O
path	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
mode	enum
;	O
size_t	long
pagesize	long
;	O
DB_MPOOL_FINFO	struct
*	O
finfop	pointer
;	O
DB_MPOOLFILE	struct
*	O
*	O
retp	pointer
;	O
{	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
int	O
ret	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
mp_handle	pointer
,	O
DB_INIT_MPOOL	int
)	O
;	O
dbmp	pointer
=	O
dbenv	pointer
->	O
mp_handle	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_fchk	function
(	O
dbenv	pointer
,	O
"CDB_memp_fopen"	pointer
,	O
flags	int
,	O
DB_CREATE	int
|	O
DB_COMPRESS	int
|	O
DB_NOMMAP	int
|	O
DB_ODDFILESIZE	int
|	O
DB_RDONLY	int
|	O
DB_TRUNCATE	int
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_COMPRESS	int
)	O
)	O
LF_SET	O
(	O
DB_NOMMAP	int
)	O
;	O
if	O
(	O
pagesize	long
==	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_memp_fopen: pagesize not specified"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
finfop	pointer
!=	O
NULL	O
&&	O
finfop	pointer
->	O
clear_len	int
>	O
pagesize	long
)	O
return	O
(	O
EINVAL	int
)	O
;	O
return	O
(	O
CDB___memp_fopen	function
(	O
dbmp	pointer
,	O
NULL	O
,	O
path	pointer
,	O
flags	int
,	O
mode	enum
,	O
pagesize	long
,	O
1	int
,	O
finfop	pointer
,	O
retp	pointer
)	O
)	O
;	O
}	O
int	O
CDB___memp_fopen	function
(	O
dbmp	pointer
,	O
mfp	pointer
,	O
path	pointer
,	O
flags	int
,	O
mode	enum
,	O
pagesize	long
,	O
needlock	int
,	O
finfop	pointer
,	O
retp	pointer
)	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
const	O
char	O
*	O
path	pointer
;	O
u_int32_t	int
flags	int
;	O
int	O
mode	enum
,	O
needlock	int
;	O
size_t	long
pagesize	long
;	O
DB_MPOOL_FINFO	struct
*	O
finfop	pointer
;	O
DB_MPOOLFILE	struct
*	O
*	O
retp	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
DB_MPOOL_FINFO	struct
finfo	struct
;	O
db_pgno_t	int
last_pgno	int
;	O
size_t	long
maxmap	long
;	O
u_int32_t	int
mbytes	int
,	O
bytes	long
,	O
oflags	int
;	O
int	O
ret	int
;	O
u_int8_t	char
idbuf	array
[	O
DB_FILE_ID_LEN	int
]	O
;	O
char	O
*	O
rpath	pointer
;	O
dbenv	pointer
=	O
dbmp	pointer
->	O
dbenv	pointer
;	O
ret	int
=	O
0	int
;	O
rpath	pointer
=	O
NULL	O
;	O
if	O
(	O
finfop	pointer
==	O
NULL	O
)	O
{	O
memset	function
(	O
&	O
finfo	struct
,	O
0	int
,	O
sizeof	O
(	O
finfo	struct
)	O
)	O
;	O
if	O
(	O
mfp	pointer
!=	O
NULL	O
)	O
{	O
finfo	struct
.	O
ftype	int
=	O
mfp	pointer
->	O
ftype	int
;	O
finfo	struct
.	O
pgcookie	pointer
=	O
NULL	O
;	O
finfo	struct
.	O
fileid	array
=	O
NULL	O
;	O
finfo	struct
.	O
lsn_offset	int
=	O
mfp	pointer
->	O
lsn_off	int
;	O
finfo	struct
.	O
clear_len	int
=	O
mfp	pointer
->	O
clear_len	int
;	O
}	O
else	O
{	O
finfo	struct
.	O
ftype	int
=	O
0	int
;	O
finfo	struct
.	O
pgcookie	pointer
=	O
NULL	O
;	O
finfo	struct
.	O
fileid	array
=	O
NULL	O
;	O
finfo	struct
.	O
lsn_offset	int
=	O
-	O
1	int
;	O
finfo	struct
.	O
clear_len	int
=	O
0	int
;	O
}	O
finfop	pointer
=	O
&	O
finfo	struct
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_calloc	function
(	O
dbenv	pointer
,	O
1	int
,	O
sizeof	O
(	O
DB_MPOOLFILE	struct
)	O
,	O
&	O
dbmfp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
dbmfp	pointer
->	O
dbmp	pointer
=	O
dbmp	pointer
;	O
dbmfp	pointer
->	O
ref	int
=	O
1	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_RDONLY	int
)	O
)	O
F_SET	O
(	O
dbmfp	pointer
,	O
MP_READONLY	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_COMPRESS	int
)	O
)	O
F_SET	O
(	O
dbmfp	pointer
,	O
MP_CMPR	int
)	O
;	O
if	O
(	O
path	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
DB_RDONLY	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_memp_fopen: temporary files can't be readonly"	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
LF_ISSET	O
(	O
DB_COMPRESS	int
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_memp_fopen: temporary files can't be compressed"	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
last_pgno	int
=	O
PGNO_BASE_MD	int
;	O
}	O
else	O
{	O
size_t	long
disk_pagesize	long
=	O
F_ISSET	O
(	O
dbmfp	pointer
,	O
MP_CMPR	int
)	O
?	O
DB_CMPR_DIVIDE	O
(	O
dbenv	pointer
,	O
pagesize	long
)	O
:	O
pagesize	long
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_appname	function
(	O
dbenv	pointer
,	O
DB_APP_DATA	int
,	O
NULL	O
,	O
path	pointer
,	O
0	int
,	O
NULL	O
,	O
&	O
rpath	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
oflags	int
=	O
0	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_CREATE	int
)	O
)	O
oflags	int
|=	O
DB_OSO_CREATE	int
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_RDONLY	int
)	O
)	O
oflags	int
|=	O
DB_OSO_RDONLY	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_open	function
(	O
dbenv	pointer
,	O
rpath	pointer
,	O
oflags	int
,	O
mode	enum
,	O
&	O
dbmfp	pointer
->	O
fh	struct
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
rpath	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_ioinfo	function
(	O
dbenv	pointer
,	O
rpath	pointer
,	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
&	O
mbytes	int
,	O
&	O
bytes	long
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
rpath	pointer
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
goto	O
err	pointer
;	O
}	O
if	O
(	O
bytes	long
%	O
disk_pagesize	long
!=	O
0	int
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
DB_ODDFILESIZE	int
)	O
)	O
bytes	long
-=	O
(	O
bytes	long
%	O
disk_pagesize	long
)	O
;	O
else	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: file size not a multiple of the pagesize"	pointer
,	O
rpath	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
err	pointer
;	O
}	O
}	O
last_pgno	int
=	O
mbytes	int
*	O
(	O
MEGABYTE	int
/	O
disk_pagesize	long
)	O
;	O
last_pgno	int
+=	O
bytes	long
/	O
disk_pagesize	long
;	O
if	O
(	O
last_pgno	int
!=	O
0	int
)	O
--	O
last_pgno	int
;	O
else	O
last_pgno	int
=	O
PGNO_BASE_MD	int
;	O
if	O
(	O
finfop	pointer
->	O
fileid	array
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_fileid	function
(	O
dbenv	pointer
,	O
rpath	pointer
,	O
0	int
,	O
idbuf	array
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
finfop	pointer
->	O
fileid	array
=	O
idbuf	array
;	O
}	O
}	O
if	O
(	O
needlock	int
)	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
ret	int
=	O
mfp	pointer
==	O
NULL	O
?	O
__memp_mf_open	function
(	O
dbmp	pointer
,	O
path	pointer
,	O
pagesize	long
,	O
last_pgno	int
,	O
finfop	pointer
,	O
flags	int
,	O
&	O
mfp	pointer
)	O
:	O
0	int
;	O
if	O
(	O
needlock	int
)	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_THREAD	int
)	O
)	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_mutex_alloc	function
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
,	O
&	O
dbmfp	pointer
->	O
mutexp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
(	O
ret	int
=	O
__db_mutex_init	O
(	O
dbenv	pointer
,	O
dbmfp	pointer
->	O
mutexp	pointer
,	O
0	int
,	O
MUTEX_THREAD	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
dbmfp	pointer
->	O
mfp	pointer
=	O
mfp	pointer
;	O
if	O
(	O
F_ISSET	O
(	O
mfp	pointer
,	O
MP_CAN_MMAP	int
)	O
)	O
{	O
if	O
(	O
!	O
F_ISSET	O
(	O
dbmfp	pointer
,	O
MP_READONLY	int
)	O
)	O
F_CLR	O
(	O
mfp	pointer
,	O
MP_CAN_MMAP	int
)	O
;	O
if	O
(	O
path	pointer
==	O
NULL	O
)	O
F_CLR	O
(	O
mfp	pointer
,	O
MP_CAN_MMAP	int
)	O
;	O
if	O
(	O
finfop	pointer
->	O
ftype	int
!=	O
0	int
)	O
F_CLR	O
(	O
mfp	pointer
,	O
MP_CAN_MMAP	int
)	O
;	O
if	O
(	O
LF_ISSET	O
(	O
DB_NOMMAP	int
)	O
||	O
F_ISSET	O
(	O
dbenv	pointer
,	O
DB_ENV_NOMMAP	int
)	O
)	O
F_CLR	O
(	O
mfp	pointer
,	O
MP_CAN_MMAP	int
)	O
;	O
maxmap	long
=	O
dbenv	pointer
->	O
mp_mmapsize	long
==	O
0	int
?	O
DB_MAXMMAPSIZE	O
:	O
dbenv	pointer
->	O
mp_mmapsize	long
;	O
if	O
(	O
mbytes	int
>	O
maxmap	long
/	O
MEGABYTE	int
||	O
(	O
mbytes	int
==	O
maxmap	long
/	O
MEGABYTE	int
&&	O
bytes	long
>=	O
maxmap	long
%	O
MEGABYTE	int
)	O
)	O
F_CLR	O
(	O
mfp	pointer
,	O
MP_CAN_MMAP	int
)	O
;	O
}	O
dbmfp	pointer
->	O
addr	pointer
=	O
NULL	O
;	O
if	O
(	O
F_ISSET	O
(	O
mfp	pointer
,	O
MP_CAN_MMAP	int
)	O
)	O
{	O
dbmfp	pointer
->	O
len	short
=	O
(	O
size_t	long
)	O
mbytes	int
*	O
MEGABYTE	int
+	O
bytes	long
;	O
if	O
(	O
CDB___os_mapfile	function
(	O
dbenv	pointer
,	O
rpath	pointer
,	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
dbmfp	pointer
->	O
len	short
,	O
1	int
,	O
&	O
dbmfp	pointer
->	O
addr	pointer
)	O
!=	O
0	int
)	O
{	O
dbmfp	pointer
->	O
addr	pointer
=	O
NULL	O
;	O
F_CLR	O
(	O
mfp	pointer
,	O
MP_CAN_MMAP	int
)	O
;	O
}	O
}	O
if	O
(	O
rpath	pointer
!=	O
NULL	O
)	O
CDB___os_freestr	function
(	O
rpath	pointer
)	O
;	O
MUTEX_THREAD_LOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
TAILQ_INSERT_TAIL	O
(	O
&	O
dbmp	pointer
->	O
dbmfq	struct
,	O
dbmfp	pointer
,	O
q	struct
)	O
;	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
*	O
retp	pointer
=	O
dbmfp	pointer
;	O
return	O
(	O
0	int
)	O
;	O
err	pointer
:	O
if	O
(	O
rpath	pointer
!=	O
NULL	O
)	O
CDB___os_freestr	function
(	O
rpath	pointer
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
DB_FH_VALID	int
)	O
)	O
(	O
void	O
)	O
CDB___os_closehandle	function
(	O
&	O
dbmfp	pointer
->	O
fh	struct
)	O
;	O
if	O
(	O
dbmfp	pointer
!=	O
NULL	O
)	O
CDB___os_free	function
(	O
dbmfp	pointer
,	O
sizeof	O
(	O
DB_MPOOLFILE	struct
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
MPOOL	struct
*	O
mp	pointer
;	O
static	O
int	O
__memp_mf_open	function
(	O
dbmp	pointer
,	O
path	pointer
,	O
pagesize	long
,	O
last_pgno	int
,	O
finfop	pointer
,	O
flags	int
,	O
retp	pointer
)	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
const	O
char	O
*	O
path	pointer
;	O
size_t	long
pagesize	long
;	O
db_pgno_t	int
last_pgno	int
;	O
DB_MPOOL_FINFO	struct
*	O
finfop	pointer
;	O
u_int32_t	int
flags	int
;	O
MPOOLFILE	struct
*	O
*	O
retp	pointer
;	O
{	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
int	O
ret	int
;	O
void	O
*	O
p	pointer
;	O
if	O
(	O
!	O
ISTEMPORARY	O
)	O
{	O
mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
primary	int
;	O
for	O
(	O
mfp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
mp	pointer
->	O
mpfq	struct
,	O
__mpoolfile	struct
)	O
;	O
mfp	pointer
!=	O
NULL	O
;	O
mfp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
mfp	pointer
,	O
q	struct
,	O
__mpoolfile	struct
)	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
mfp	pointer
,	O
MP_DEADFILE	int
|	O
MP_TEMP	int
)	O
)	O
continue	O
;	O
if	O
(	O
memcmp	function
(	O
finfop	pointer
->	O
fileid	array
,	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mfp	pointer
->	O
fileid_off	int
)	O
,	O
DB_FILE_ID_LEN	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
LF_ISSET	O
(	O
DB_TRUNCATE	int
)	O
)	O
{	O
MEMP_FREMOVE	O
(	O
mfp	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
finfop	pointer
->	O
clear_len	int
!=	O
mfp	pointer
->	O
clear_len	int
||	O
pagesize	long
!=	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
)	O
{	O
CDB___db_err	function
(	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"%s: page size or clear length changed"	pointer
,	O
path	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
finfop	pointer
->	O
ftype	int
!=	O
0	int
)	O
mfp	pointer
->	O
ftype	int
=	O
finfop	pointer
->	O
ftype	int
;	O
++	O
mfp	pointer
->	O
ref_cnt	int
;	O
*	O
retp	pointer
=	O
mfp	pointer
;	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_alloc	function
(	O
dbmp	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
,	O
NULL	O
,	O
sizeof	O
(	O
MPOOLFILE	struct
)	O
,	O
NULL	O
,	O
&	O
mfp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
*	O
retp	pointer
=	O
mfp	pointer
;	O
memset	function
(	O
mfp	pointer
,	O
0	int
,	O
sizeof	O
(	O
MPOOLFILE	struct
)	O
)	O
;	O
mfp	pointer
->	O
ref_cnt	int
=	O
1	int
;	O
mfp	pointer
->	O
ftype	int
=	O
finfop	pointer
->	O
ftype	int
;	O
mfp	pointer
->	O
lsn_off	int
=	O
finfop	pointer
->	O
lsn_offset	int
;	O
mfp	pointer
->	O
clear_len	int
=	O
finfop	pointer
->	O
clear_len	int
;	O
mfp	pointer
->	O
cmpr_free	int
=	O
PGNO_INVALID	int
;	O
mfp	pointer
->	O
stat	pointer
.	O
st_pagesize	long
=	O
pagesize	long
;	O
mfp	pointer
->	O
orig_last_pgno	int
=	O
mfp	pointer
->	O
last_pgno	int
=	O
last_pgno	int
;	O
if	O
(	O
ISTEMPORARY	O
)	O
F_SET	O
(	O
mfp	pointer
,	O
MP_TEMP	int
)	O
;	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_alloc	function
(	O
dbmp	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
,	O
NULL	O
,	O
strlen	function
(	O
path	pointer
)	O
+	O
1	int
,	O
&	O
mfp	pointer
->	O
path_off	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
memcpy	function
(	O
p	pointer
,	O
path	pointer
,	O
strlen	function
(	O
path	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_alloc	function
(	O
dbmp	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
,	O
NULL	O
,	O
DB_FILE_ID_LEN	int
,	O
&	O
mfp	pointer
->	O
fileid_off	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
memcpy	function
(	O
p	pointer
,	O
finfop	pointer
->	O
fileid	array
,	O
DB_FILE_ID_LEN	int
)	O
;	O
F_SET	O
(	O
mfp	pointer
,	O
MP_CAN_MMAP	int
)	O
;	O
}	O
if	O
(	O
finfop	pointer
->	O
pgcookie	pointer
==	O
NULL	O
||	O
finfop	pointer
->	O
pgcookie	pointer
->	O
size	int
==	O
0	int
)	O
{	O
mfp	pointer
->	O
pgcookie_len	int
=	O
0	int
;	O
mfp	pointer
->	O
pgcookie_off	int
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_alloc	function
(	O
dbmp	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
,	O
NULL	O
,	O
finfop	pointer
->	O
pgcookie	pointer
->	O
size	int
,	O
&	O
mfp	pointer
->	O
pgcookie_off	int
,	O
&	O
p	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
memcpy	function
(	O
p	pointer
,	O
finfop	pointer
->	O
pgcookie	pointer
->	O
data	pointer
,	O
finfop	pointer
->	O
pgcookie	pointer
->	O
size	int
)	O
;	O
mfp	pointer
->	O
pgcookie_len	int
=	O
finfop	pointer
->	O
pgcookie	pointer
->	O
size	int
;	O
}	O
mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
primary	int
;	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
mp	pointer
->	O
mpfq	struct
,	O
mfp	pointer
,	O
q	struct
,	O
__mpoolfile	struct
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___memp_cmpr_open	function
(	O
dbmp	pointer
->	O
dbenv	pointer
,	O
mfp	pointer
,	O
path	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
0	int
)	O
{	O
err	pointer
:	O
if	O
(	O
mfp	pointer
->	O
path_off	int
!=	O
0	int
)	O
CDB___db_shalloc_free	function
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
addr	pointer
,	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mfp	pointer
->	O
path_off	int
)	O
)	O
;	O
if	O
(	O
mfp	pointer
->	O
fileid_off	int
!=	O
0	int
)	O
CDB___db_shalloc_free	function
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
addr	pointer
,	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mfp	pointer
->	O
fileid_off	int
)	O
)	O
;	O
if	O
(	O
mfp	pointer
!=	O
NULL	O
)	O
CDB___db_shalloc_free	function
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
addr	pointer
,	O
mfp	pointer
)	O
;	O
mem_err	O
:	O
CDB___db_err	function
(	O
dbmp	pointer
->	O
dbenv	pointer
,	O
"Unable to allocate memory for mpool file"	pointer
)	O
;	O
}	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB_memp_fclose	function
(	O
dbmfp	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
int	O
ret	int
,	O
t_ret	int
;	O
dbmp	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
;	O
dbenv	pointer
=	O
dbmp	pointer
->	O
dbenv	pointer
;	O
ret	int
=	O
0	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
MUTEX_THREAD_LOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
dbmfp	pointer
->	O
ref	int
==	O
1	int
)	O
{	O
TAILQ_REMOVE	O
(	O
&	O
dbmp	pointer
->	O
dbmfq	struct
,	O
dbmfp	pointer
,	O
q	struct
)	O
;	O
break	O
;	O
}	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
(	O
void	O
)	O
CDB___os_sleep	function
(	O
dbenv	pointer
,	O
1	int
,	O
0	int
)	O
;	O
}	O
MUTEX_THREAD_UNLOCK	O
(	O
dbmp	pointer
->	O
mutexp	pointer
)	O
;	O
if	O
(	O
dbmfp	pointer
->	O
pinref	int
!=	O
0	int
)	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: close: %lu blocks left pinned"	pointer
,	O
CDB___memp_fn	function
(	O
dbmfp	pointer
)	O
,	O
(	O
u_long	long
)	O
dbmfp	pointer
->	O
pinref	int
)	O
;	O
if	O
(	O
dbmfp	pointer
->	O
addr	pointer
!=	O
NULL	O
&&	O
(	O
ret	int
=	O
CDB___os_unmapfile	function
(	O
dbenv	pointer
,	O
dbmfp	pointer
->	O
addr	pointer
,	O
dbmfp	pointer
->	O
len	short
)	O
)	O
!=	O
0	int
)	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
CDB___memp_fn	function
(	O
dbmfp	pointer
)	O
,	O
CDB_db_strerror	function
(	O
ret	int
)	O
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
DB_FH_VALID	int
)	O
&&	O
(	O
t_ret	int
=	O
CDB___os_closehandle	function
(	O
&	O
dbmfp	pointer
->	O
fh	struct
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: %s"	pointer
,	O
CDB___memp_fn	function
(	O
dbmfp	pointer
)	O
,	O
CDB_db_strerror	function
(	O
t_ret	int
)	O
)	O
;	O
if	O
(	O
ret	int
!=	O
0	int
)	O
t_ret	int
=	O
ret	int
;	O
}	O
if	O
(	O
dbmfp	pointer
->	O
mutexp	pointer
!=	O
NULL	O
)	O
CDB___db_mutex_free	function
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
,	O
dbmfp	pointer
->	O
mutexp	pointer
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
mfp	pointer
=	O
dbmfp	pointer
->	O
mfp	pointer
;	O
if	O
(	O
--	O
mfp	pointer
->	O
ref_cnt	int
==	O
0	int
)	O
CDB___memp_mf_discard	function
(	O
dbmp	pointer
,	O
mfp	pointer
)	O
;	O
else	O
if	O
(	O
F_ISSET	O
(	O
mfp	pointer
,	O
MP_TEMP	int
)	O
)	O
MEMP_FREMOVE	O
(	O
mfp	pointer
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
CDB___os_free	function
(	O
dbmfp	pointer
,	O
sizeof	O
(	O
DB_MPOOLFILE	struct
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
void	O
CDB___memp_mf_discard	function
(	O
dbmp	pointer
,	O
mfp	pointer
)	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
{	O
MPOOL	struct
*	O
mp	pointer
;	O
mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
primary	int
;	O
SH_TAILQ_REMOVE	O
(	O
&	O
mp	pointer
->	O
mpfq	struct
,	O
mfp	pointer
,	O
q	struct
,	O
__mpoolfile	struct
)	O
;	O
if	O
(	O
mfp	pointer
->	O
path_off	int
!=	O
0	int
)	O
CDB___db_shalloc_free	function
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
addr	pointer
,	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mfp	pointer
->	O
path_off	int
)	O
)	O
;	O
if	O
(	O
mfp	pointer
->	O
fileid_off	int
!=	O
0	int
)	O
CDB___db_shalloc_free	function
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
addr	pointer
,	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mfp	pointer
->	O
fileid_off	int
)	O
)	O
;	O
if	O
(	O
mfp	pointer
->	O
pgcookie_off	int
!=	O
0	int
)	O
CDB___db_shalloc_free	function
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
addr	pointer
,	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mfp	pointer
->	O
pgcookie_off	int
)	O
)	O
;	O
CDB___db_shalloc_free	function
(	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
addr	pointer
,	O
mfp	pointer
)	O
;	O
}	O
int	O
CDB___memp_fremove	function
(	O
dbmfp	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
dbmp	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
;	O
dbenv	pointer
=	O
dbmp	pointer
->	O
dbenv	pointer
;	O
mfp	pointer
=	O
dbmfp	pointer
->	O
mfp	pointer
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
MEMP_FREMOVE	O
(	O
mfp	pointer
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
char	O
*	O
CDB___memp_fn	function
(	O
dbmfp	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
{	O
return	O
(	O
CDB___memp_fns	function
(	O
dbmfp	pointer
->	O
dbmp	pointer
,	O
dbmfp	pointer
->	O
mfp	pointer
)	O
)	O
;	O
}	O
char	O
*	O
CDB___memp_fns	function
(	O
dbmp	pointer
,	O
mfp	pointer
)	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
{	O
if	O
(	O
mfp	pointer
->	O
path_off	int
==	O
0	int
)	O
return	O
(	O
(	O
char	O
*	O
)	O
"temporary"	pointer
)	O
;	O
return	O
(	O
(	O
char	O
*	O
)	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
mfp	pointer
->	O
path_off	int
)	O
)	O
;	O
}	O
