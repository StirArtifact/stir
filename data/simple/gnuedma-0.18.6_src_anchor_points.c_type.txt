OBJID	long
EDMAPROC	O
edma_apply_classpath	function
(	O
OBJID	long
IdObj	long
,	O
EPChar	pointer
classpath	pointer
)	O
{	O
return	O
edma_parse_classpath	function
(	O
IdObj	long
,	O
classpath	pointer
,	O
strlen	function
(	O
classpath	pointer
)	O
,	O
0	int
)	O
;	O
}	O
OBJID	long
EDMAPROC	O
edma_parse_classpath	function
(	O
OBJID	long
IdObj	long
,	O
EPChar	pointer
eclass_path	pointer
,	O
ESint32	long
len	long
,	O
ESint32	long
ex	long
)	O
{	O
OBJID	long
id	long
,	O
casted_id	long
;	O
OBJID	long
aux_id	long
;	O
ESint32	long
l	long
,	O
pos	long
;	O
ESint32	long
op	pointer
;	O
EPChar	pointer
current	pointer
,	O
next	long
;	O
EPChar	pointer
iclass_path	pointer
;	O
EPChar	pointer
dyn_class_id	pointer
;	O
EPChar	pointer
apoint1	pointer
,	O
apoint2	pointer
;	O
CLASSID	long
temp_id	long
;	O
EChar	char
ex_msg	array
[	O
1024	int
]	O
;	O
if	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_parse_classpath"	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
eclass_path	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
l	long
=	O
len	long
+	O
2	int
;	O
current	pointer
=	O
next	long
=	O
iclass_path	pointer
=	O
strdup	function
(	O
eclass_path	pointer
)	O
;	O
pos	long
=	O
0	int
;	O
op	pointer
=	O
EDMA_CP_OP_ADD	int
;	O
id	long
=	O
IdObj	long
;	O
while	O
(	O
pos	long
<	O
l	long
)	O
{	O
if	O
(	O
(	O
*	O
next	long
==	O
0	int
)	O
&&	O
(	O
current	pointer
!=	O
next	long
)	O
)	O
{	O
if	O
(	O
(	O
casted_id	long
=	O
edma_cast_obj	function
(	O
id	long
,	O
current	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] '%s' "	pointer
"Anchor Point/ClassName"	pointer
" not found in classpath"	pointer
,	O
current	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
if	O
(	O
ex	long
)	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
else	O
return	O
-	O
1	int
;	O
}	O
id	long
=	O
casted_id	long
;	O
next	long
++	O
;	O
current	pointer
=	O
next	long
;	O
pos	long
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
next	long
==	O
'>'	O
)	O
{	O
*	O
next	long
=	O
0	int
;	O
_edma_parse_classpath_items	function
(	O
current	pointer
,	O
&	O
dyn_class_id	pointer
,	O
&	O
apoint1	pointer
,	O
&	O
apoint2	pointer
,	O
&	O
op	pointer
)	O
;	O
if	O
(	O
(	O
casted_id	long
=	O
edma_upcast_obj	function
(	O
id	long
,	O
(	O
apoint1	pointer
==	O
NULL	O
)	O
?	O
dyn_class_id	pointer
:	O
apoint1	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
Final	char
)	O
||	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Final	char
)	O
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] "	pointer
"Object %ld is final. "	pointer
"Can't add superclass %s"	pointer
,	O
id	long
,	O
current	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
if	O
(	O
(	O
temp_id	long
=	O
edma_get_class_id	function
(	O
dyn_class_id	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Class '%s' "	pointer
"don't exist."	pointer
"'%s' Anchor Point/Class not found in classpath"	pointer
,	O
dyn_class_id	pointer
,	O
current	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
if	O
(	O
(	O
casted_id	long
=	O
edma_add_superclass	function
(	O
id	long
,	O
temp_id	long
,	O
apoint1	pointer
,	O
apoint2	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Can't add "	pointer
"superclass "	pointer
"for '%s' classpath item"	pointer
,	O
current	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
apoint1	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
temp_id	long
=	O
edma_get_class_id	function
(	O
dyn_class_id	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
switch	O
(	O
op	pointer
)	O
{	O
case	O
EDMA_CP_OP_ADD	int
:	O
{	O
if	O
(	O
gObj	O
[	O
casted_id	long
]	O
->	O
IdClass	long
!=	O
temp_id	long
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Can't override existing"	pointer
"subobject %ld at '%s'. Superobject at %ld of class"	pointer
"'%s' not '%s"	pointer
,	O
casted_id	long
,	O
apoint1	pointer
,	O
casted_id	long
,	O
gClass	O
[	O
gObj	O
[	O
casted_id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array
,	O
gClass	O
[	O
temp_id	long
]	O
->	O
ClassName	array
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
}	O
case	O
EDMA_CP_OP_VERTICAL_INSERT	int
:	O
{	O
if	O
(	O
(	O
casted_id	long
=	O
edma_insert_superclass	function
(	O
id	long
,	O
temp_id	long
,	O
apoint1	pointer
,	O
apoint2	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Can't insert superclass"	pointer
" %s at anchor point %s"	pointer
,	O
dyn_class_id	pointer
,	O
apoint1	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
break	O
;	O
}	O
case	O
EDMA_CP_OP_OVERWRITE	int
:	O
{	O
edma_remove_superclass_ap	function
(	O
id	long
,	O
apoint1	pointer
)	O
;	O
edma_free_obj	function
(	O
casted_id	long
)	O
;	O
if	O
(	O
(	O
casted_id	long
=	O
edma_add_superclass	function
(	O
id	long
,	O
temp_id	long
,	O
apoint1	pointer
,	O
apoint2	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Can't overwrite superclass"	pointer
" %s at anchor point %s"	pointer
,	O
dyn_class_id	pointer
,	O
apoint1	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
break	O
;	O
}	O
default	O
:	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Opertation %ld still"	pointer
" not implemented. Classpath: %s"	pointer
,	O
op	pointer
,	O
current	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
}	O
}	O
else	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_class_path] Class '%s' "	pointer
"in classpath '%s' doesn't exists"	pointer
,	O
dyn_class_id	pointer
,	O
eclass_path	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
}	O
}	O
id	long
=	O
casted_id	long
;	O
next	long
++	O
;	O
current	pointer
=	O
next	long
;	O
pos	long
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
*	O
next	long
==	O
'<'	O
)	O
{	O
*	O
next	long
=	O
0	int
;	O
_edma_parse_classpath_items	function
(	O
current	pointer
,	O
&	O
dyn_class_id	pointer
,	O
&	O
apoint1	pointer
,	O
&	O
apoint2	pointer
,	O
&	O
op	pointer
)	O
;	O
if	O
(	O
(	O
casted_id	long
=	O
edma_downcast_obj	function
(	O
id	long
,	O
(	O
apoint1	pointer
==	O
NULL	O
)	O
?	O
dyn_class_id	pointer
:	O
apoint1	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
Final	char
)	O
||	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Final	char
)	O
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Object %ld "	pointer
"is final. "	pointer
"Can't add subclass %s"	pointer
,	O
id	long
,	O
current	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
if	O
(	O
(	O
temp_id	long
=	O
edma_get_class_id	function
(	O
dyn_class_id	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Class '%s' "	pointer
"don't exist."	pointer
"'%s' Anchor Point/Class not found in classpath"	pointer
,	O
dyn_class_id	pointer
,	O
current	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
if	O
(	O
(	O
casted_id	long
=	O
edma_add_subclass	function
(	O
id	long
,	O
temp_id	long
,	O
apoint1	pointer
,	O
apoint2	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_class_path] Can't add "	pointer
"subclass for '%s' "	pointer
"classpath item"	pointer
,	O
current	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
apoint1	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
temp_id	long
=	O
edma_get_class_id	function
(	O
dyn_class_id	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
switch	O
(	O
op	pointer
)	O
{	O
case	O
EDMA_CP_OP_ADD	int
:	O
{	O
if	O
(	O
gObj	O
[	O
casted_id	long
]	O
->	O
IdClass	long
!=	O
temp_id	long
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Can't override existing"	pointer
"subobject %ld at '%s'. Superobject at %ld of class"	pointer
"'%s' not '%s"	pointer
,	O
casted_id	long
,	O
apoint1	pointer
,	O
casted_id	long
,	O
gClass	O
[	O
gObj	O
[	O
casted_id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array
,	O
gClass	O
[	O
temp_id	long
]	O
->	O
ClassName	array
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
}	O
case	O
EDMA_CP_OP_VERTICAL_INSERT	int
:	O
{	O
edma_printf	function
(	O
"[%s] Inserting up: %s @ %s | %s"	pointer
,	O
__FUNCTION__	O
,	O
gClass	O
[	O
temp_id	long
]	O
->	O
ClassName	array
,	O
apoint1	pointer
,	O
apoint2	pointer
)	O
;	O
if	O
(	O
(	O
casted_id	long
=	O
edma_insert_subclass	function
(	O
id	long
,	O
temp_id	long
,	O
apoint1	pointer
,	O
apoint2	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Can't insert superclass"	pointer
" %s at anchor point %s"	pointer
,	O
dyn_class_id	pointer
,	O
apoint1	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
break	O
;	O
}	O
case	O
EDMA_CP_OP_OVERWRITE	int
:	O
{	O
edma_remove_subclass_ap	function
(	O
id	long
,	O
apoint1	pointer
)	O
;	O
edma_free_obj	function
(	O
casted_id	long
)	O
;	O
aux_id	long
=	O
_edma_new_obj	function
(	O
dyn_class_id	pointer
,	O
id	long
,	O
NULL	O
)	O
;	O
if	O
(	O
(	O
casted_id	long
=	O
edma_add_subobject	function
(	O
id	long
,	O
aux_id	long
,	O
apoint1	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Can't overwrite superclass"	pointer
" %s at anchor point %s"	pointer
,	O
dyn_class_id	pointer
,	O
apoint1	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
edma_add_superobject	function
(	O
aux_id	long
,	O
id	long
,	O
apoint2	pointer
)	O
;	O
gObj	O
[	O
aux_id	long
]	O
->	O
Father	long
=	O
id	long
;	O
gObj	O
[	O
aux_id	long
]	O
->	O
PseudiFather	long
=	O
id	long
;	O
casted_id	long
=	O
aux_id	long
;	O
break	O
;	O
}	O
default	O
:	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Opertation %ld still"	pointer
" not implemented. Classpath: %s"	pointer
,	O
op	pointer
,	O
current	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
}	O
}	O
else	O
{	O
snprintf	function
(	O
ex_msg	array
,	O
1024	int
,	O
"[edma_parse_classpath] Class '%s' in "	pointer
"classpath '%s' doesn't exists"	pointer
,	O
dyn_class_id	pointer
,	O
eclass_path	pointer
)	O
;	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
ex_msg	array
)	O
;	O
}	O
}	O
}	O
id	long
=	O
casted_id	long
;	O
next	long
++	O
;	O
current	pointer
=	O
next	long
;	O
pos	long
++	O
;	O
continue	O
;	O
}	O
pos	long
++	O
;	O
next	long
++	O
;	O
}	O
free	function
(	O
iclass_path	pointer
)	O
;	O
return	O
id	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_parse_classpath_items	function
(	O
EPChar	pointer
id	long
,	O
EPChar	pointer
*	O
classname	pointer
,	O
EPChar	pointer
*	O
apoint1	pointer
,	O
EPChar	pointer
*	O
apoint2	pointer
,	O
EPSint32	pointer
op	pointer
)	O
{	O
EPChar	pointer
p_ap	pointer
,	O
p_ap_sep	pointer
;	O
*	O
classname	pointer
=	O
id	long
;	O
*	O
apoint1	pointer
=	O
*	O
apoint2	pointer
=	O
NULL	O
;	O
*	O
op	pointer
=	O
EDMA_CP_OP_ADD	int
;	O
if	O
(	O
(	O
p_ap	pointer
=	O
strchr	function
(	O
id	long
,	O
'@'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
*	O
p_ap	pointer
=	O
0	int
;	O
p_ap	pointer
++	O
;	O
switch	O
(	O
p_ap	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'!'	O
:	O
{	O
*	O
op	pointer
=	O
EDMA_CP_OP_OVERWRITE	int
;	O
*	O
p_ap	pointer
=	O
0	int
;	O
p_ap	pointer
++	O
;	O
break	O
;	O
}	O
case	O
'*'	O
:	O
{	O
*	O
op	pointer
=	O
EDMA_CP_OP_VERTICAL_INSERT	int
;	O
*	O
p_ap	pointer
=	O
0	int
;	O
p_ap	pointer
++	O
;	O
break	O
;	O
}	O
case	O
'-'	O
:	O
{	O
*	O
op	pointer
=	O
EDMA_CP_OP_HORIZONTAL_INSERT	int
;	O
*	O
p_ap	pointer
=	O
0	int
;	O
p_ap	pointer
++	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
(	O
p_ap_sep	pointer
=	O
strchr	function
(	O
p_ap	pointer
,	O
'|'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
*	O
apoint2	pointer
=	O
strdup	function
(	O
p_ap_sep	pointer
+	O
1	int
)	O
;	O
*	O
p_ap_sep	pointer
=	O
0	int
;	O
}	O
*	O
apoint1	pointer
=	O
strdup	function
(	O
p_ap	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_query_subclass_ap	function
(	O
OBJID	long
id	long
,	O
EPChar	pointer
anchor_point	pointer
,	O
OBJID	long
*	O
obj	pointer
,	O
CLASSID	long
*	O
cid	long
)	O
{	O
if	O
(	O
!	O
edma_check_obj_id	function
(	O
id	long
,	O
"edma_query_subclass_ap"	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
anchor_point	pointer
==	O
NULL	O
)	O
{	O
edma_printf	function
(	O
"%s"	pointer
,	O
"[edma_query_subclass_ap] No anchot point provided"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
_edma_query_subclass_ap	function
(	O
id	long
,	O
anchor_point	pointer
,	O
obj	pointer
,	O
cid	long
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_query_subclass_ap	function
(	O
OBJID	long
id	long
,	O
EPChar	pointer
anchor_point	pointer
,	O
OBJID	long
*	O
obj	pointer
,	O
CLASSID	long
*	O
cid	long
)	O
{	O
ESint32	long
i	long
,	O
n	long
;	O
n	long
=	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
*	O
obj	pointer
=	O
-	O
1	int
;	O
*	O
cid	long
=	O
-	O
1	int
;	O
return	O
_edma_system_exception	function
(	O
"[_edma_query_subclass_ap] Object %d hasn't subobjects"	pointer
,	O
id	long
)	O
;	O
}	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_downlink_by_name	function
(	O
id	long
,	O
anchor_point	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
*	O
obj	pointer
=	O
-	O
1	int
;	O
*	O
cid	long
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
obj	pointer
=	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
[	O
i	long
]	O
.	O
Obj	long
;	O
*	O
cid	long
=	O
gObj	O
[	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
[	O
i	long
]	O
.	O
Obj	long
]	O
->	O
IdClass	long
;	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_query_superclass_ap	function
(	O
OBJID	long
id	long
,	O
EPChar	pointer
anchor_point	pointer
,	O
OBJID	long
*	O
obj	pointer
,	O
CLASSID	long
*	O
cid	long
)	O
{	O
if	O
(	O
!	O
edma_check_obj_id	function
(	O
id	long
,	O
"edma_query_superclass_ap"	pointer
)	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
anchor_point	pointer
==	O
NULL	O
)	O
{	O
edma_printf	function
(	O
"%s"	pointer
,	O
"[edma_query_superclass_ap] No anchot point provided"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
_edma_query_superclass_ap	function
(	O
id	long
,	O
anchor_point	pointer
,	O
obj	pointer
,	O
cid	long
)	O
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_query_superclass_ap	function
(	O
OBJID	long
id	long
,	O
EPChar	pointer
anchor_point	pointer
,	O
OBJID	long
*	O
obj	pointer
,	O
CLASSID	long
*	O
cid	long
)	O
{	O
ESint32	long
i	long
,	O
n	long
;	O
n	long
=	O
gObj	O
[	O
id	long
]	O
->	O
nUpTable	long
;	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
*	O
obj	pointer
=	O
-	O
1	int
;	O
*	O
cid	long
=	O
-	O
1	int
;	O
return	O
_edma_system_exception	function
(	O
"[_edma_query_superclass_ap] Object %d hasn't subobjects"	pointer
,	O
id	long
)	O
;	O
}	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_uplink_by_name	function
(	O
id	long
,	O
anchor_point	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
*	O
obj	pointer
=	O
-	O
1	int
;	O
*	O
cid	long
=	O
-	O
1	int
;	O
return	O
-	O
1	int
;	O
}	O
*	O
obj	pointer
=	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
;	O
*	O
cid	long
=	O
gObj	O
[	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
]	O
->	O
IdClass	long
;	O
return	O
i	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_rename_superclass_ap	function
(	O
OBJID	long
IdObj	long
,	O
EPChar	pointer
old_name	pointer
,	O
EPChar	pointer
new_name	pointer
)	O
{	O
POBJ	pointer
pObj	pointer
;	O
ESint32	long
i	long
;	O
if	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_rename_superclass_ap"	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
old_name	pointer
==	O
0	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_rename_superclass_ap] No 'OldName' provided for"	pointer
" object %ld"	pointer
,	O
IdObj	long
)	O
;	O
if	O
(	O
new_name	pointer
==	O
NULL	O
)	O
return	O
_edma_system_exception	function
(	O
"[edma_rename_superclass_ap] No 'NewName' provided for"	pointer
" object %ld"	pointer
,	O
IdObj	long
)	O
;	O
pObj	pointer
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_uplink_by_name	function
(	O
IdObj	long
,	O
old_name	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	function
(	O
"[edma_rename_superclass_ap] '%s' anchor point doesn't exist "	pointer
"in object %ld"	pointer
,	O
old_name	pointer
,	O
IdObj	long
)	O
;	O
}	O
strncpy	function
(	O
pObj	pointer
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Id	long
,	O
new_name	pointer
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_rename_subclass_ap	function
(	O
OBJID	long
IdObj	long
,	O
EPChar	pointer
old_name	pointer
,	O
EPChar	pointer
new_name	pointer
)	O
{	O
POBJ	pointer
pObj	pointer
;	O
ESint32	long
i	long
;	O
if	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_rename_subclass_ap"	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
old_name	pointer
==	O
0	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_rename_subclass_ap] No OldName provided for"	pointer
" object %ld"	pointer
,	O
IdObj	long
)	O
;	O
if	O
(	O
new_name	pointer
==	O
0	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_rename_subclass_ap] No NewName provided for"	pointer
" object %ld"	pointer
,	O
IdObj	long
)	O
;	O
pObj	pointer
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_downlink_by_name	function
(	O
IdObj	long
,	O
old_name	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	function
(	O
"[edma_rename_subclass_ap] %s anchor point "	pointer
"doesn't exist in object %ld"	pointer
,	O
old_name	pointer
,	O
IdObj	long
)	O
;	O
}	O
strncpy	function
(	O
pObj	pointer
->	O
DownTable	pointer
[	O
i	long
]	O
.	O
Id	long
,	O
new_name	pointer
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_remove_superclass_ap	function
(	O
OBJID	long
IdObj	long
,	O
EPChar	pointer
anchor_point	pointer
)	O
{	O
POBJ	pointer
pObj	pointer
,	O
pObj_father	pointer
;	O
ESint32	long
i	long
,	O
indx1	long
,	O
indx2	long
;	O
if	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_remove_superclass_ap"	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
anchor_point	pointer
==	O
NULL	O
)	O
{	O
edma_printf	function
(	O
"%s"	pointer
,	O
"[edma_remove_superclass_ap] No anchot point provided"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
pObj	pointer
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_uplink_by_name	function
(	O
IdObj	long
,	O
anchor_point	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	function
(	O
"[edma_remove_superclass_ap] %s anchor point "	pointer
"doesn't exist in object %ld"	pointer
,	O
anchor_point	pointer
,	O
IdObj	long
)	O
;	O
}	O
indx1	long
=	O
i	long
;	O
pObj_father	pointer
=	O
gObj	O
[	O
pObj	pointer
->	O
UpTable	pointer
[	O
indx1	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
(	O
indx2	long
=	O
_edma_locate_downlink_by_pobj	function
(	O
pObj_father	pointer
,	O
pObj	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_remove_superclass_ap] %s anchor point "	pointer
"doesn't exist in superobject %ld"	pointer
,	O
anchor_point	pointer
,	O
(	O
POBJ	pointer
)	O
pObj_father	pointer
->	O
IdObj	long
)	O
;	O
memset	function
(	O
pObj	pointer
->	O
UpTable	pointer
+	O
indx1	long
,	O
0	int
,	O
sizeof	O
(	O
SC_ID	struct
)	O
)	O
;	O
memset	function
(	O
pObj_father	pointer
->	O
DownTable	pointer
+	O
indx2	long
,	O
0	int
,	O
sizeof	O
(	O
SC_ID	struct
)	O
)	O
;	O
pObj	pointer
->	O
nUpTable	long
--	O
;	O
if	O
(	O
pObj	pointer
->	O
nUpTable	long
==	O
0	int
)	O
{	O
edma_pfree	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
=	O
NULL	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
=	O
0	int
;	O
}	O
else	O
memcpy	function
(	O
pObj	pointer
->	O
UpTable	pointer
+	O
indx1	long
,	O
pObj	pointer
->	O
UpTable	pointer
+	O
(	O
indx1	long
+	O
1	int
)	O
,	O
sizeof	O
(	O
SC_ID	struct
)	O
*	O
(	O
pObj	pointer
->	O
nUpTable	long
-	O
indx1	long
)	O
)	O
;	O
pObj_father	pointer
->	O
nDownTable	long
--	O
;	O
if	O
(	O
pObj_father	pointer
->	O
nDownTable	long
<	O
0	int
)	O
{	O
edma_pfree	function
(	O
pObj_father	pointer
->	O
SysObj	struct
.	O
hDownTable	long
,	O
pObj_father	pointer
->	O
DownTable	pointer
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	pointer
=	O
NULL	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hDownTable	long
=	O
0	int
;	O
}	O
else	O
memcpy	function
(	O
pObj_father	pointer
->	O
DownTable	pointer
+	O
indx2	long
,	O
pObj_father	pointer
->	O
DownTable	pointer
+	O
(	O
indx2	long
+	O
1	int
)	O
,	O
sizeof	O
(	O
SC_ID	struct
)	O
*	O
(	O
pObj_father	pointer
->	O
nDownTable	long
-	O
indx2	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
edma_remove_subclass_ap	function
(	O
OBJID	long
IdObj	long
,	O
EPChar	pointer
anchor_point	pointer
)	O
{	O
POBJ	pointer
pObj	pointer
,	O
pObj_father	pointer
;	O
ESint32	long
i	long
,	O
indx1	long
,	O
indx2	long
;	O
if	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_remove_subclass_ap"	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
anchor_point	pointer
==	O
NULL	O
)	O
{	O
edma_printf	function
(	O
"%s"	pointer
,	O
"[edma_remove_subclass_ap] No anchot point provided"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
indx1	long
=	O
indx2	long
=	O
0	int
;	O
pObj	pointer
=	O
gObj	O
[	O
IdObj	long
]	O
;	O
if	O
(	O
(	O
i	long
=	O
_edma_locate_downlink_by_name	function
(	O
IdObj	long
,	O
anchor_point	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	function
(	O
"[edma_remove_subclass_ap] %s anchor point "	pointer
"doesn't exist in object %ld"	pointer
,	O
anchor_point	pointer
,	O
IdObj	long
)	O
;	O
}	O
indx1	long
=	O
i	long
;	O
pObj_father	pointer
=	O
gObj	O
[	O
pObj	pointer
->	O
DownTable	pointer
[	O
indx1	long
]	O
.	O
Obj	long
]	O
;	O
if	O
(	O
(	O
indx2	long
=	O
_edma_locate_uplink_by_pobj	function
(	O
pObj_father	pointer
,	O
pObj	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_remove_subclass_ap] %s anchor point "	pointer
"doesn't exist in superobject %ld"	pointer
,	O
anchor_point	pointer
,	O
(	O
POBJ	pointer
)	O
pObj_father	pointer
->	O
IdObj	long
)	O
;	O
memset	function
(	O
pObj	pointer
->	O
DownTable	pointer
+	O
indx1	long
,	O
0	int
,	O
sizeof	O
(	O
SC_ID	struct
)	O
)	O
;	O
memset	function
(	O
pObj_father	pointer
->	O
UpTable	pointer
+	O
indx2	long
,	O
0	int
,	O
sizeof	O
(	O
SC_ID	struct
)	O
)	O
;	O
pObj	pointer
->	O
nDownTable	long
--	O
;	O
if	O
(	O
pObj	pointer
->	O
nDownTable	long
==	O
0	int
)	O
{	O
edma_pfree	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hDownTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	pointer
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	pointer
=	O
NULL	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hDownTable	long
=	O
0	int
;	O
}	O
else	O
memcpy	function
(	O
pObj	pointer
->	O
DownTable	pointer
+	O
indx1	long
,	O
pObj	pointer
->	O
DownTable	pointer
+	O
(	O
indx1	long
+	O
1	int
)	O
,	O
sizeof	O
(	O
SC_ID	struct
)	O
*	O
(	O
pObj	pointer
->	O
nDownTable	long
-	O
indx1	long
)	O
)	O
;	O
pObj_father	pointer
->	O
nUpTable	long
--	O
;	O
if	O
(	O
pObj_father	pointer
->	O
nUpTable	long
==	O
0	int
)	O
{	O
edma_pfree	function
(	O
pObj_father	pointer
->	O
SysObj	struct
.	O
hUpTable	long
,	O
pObj_father	pointer
->	O
UpTable	pointer
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
=	O
NULL	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
=	O
0	int
;	O
}	O
else	O
memcpy	function
(	O
pObj_father	pointer
->	O
UpTable	pointer
+	O
indx2	long
,	O
pObj_father	pointer
->	O
UpTable	pointer
+	O
(	O
indx2	long
+	O
1	int
)	O
,	O
sizeof	O
(	O
SC_ID	struct
)	O
*	O
(	O
pObj_father	pointer
->	O
nUpTable	long
-	O
indx2	long
)	O
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_add_super_ap	function
(	O
OBJID	long
id	long
,	O
EPChar	pointer
apoint	pointer
,	O
CLASSID	long
cid	long
,	O
OBJID	long
superid	long
,	O
ESint32	long
flags	long
)	O
{	O
ESint32	long
n	long
;	O
if	O
(	O
apoint	pointer
)	O
{	O
if	O
(	O
_edma_locate_uplink_by_name	function
(	O
id	long
,	O
apoint	pointer
)	O
!=	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_add_super_ap] Anchor point %s "	pointer
"already exists on object %ld [%s]"	pointer
,	O
apoint	pointer
,	O
id	long
,	O
gClass	O
[	O
gObj	O
[	O
id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
n	long
=	O
gObj	O
[	O
id	long
]	O
->	O
nUpTable	long
;	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
=	O
edma_prealloc	function
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
,	O
sizeof	O
(	O
SC_ID	struct
)	O
*	O
(	O
n	long
+	O
1	int
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_add_super_ap] Can't realloc "	pointer
"object superclass table. Not enough memory"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	pointer
=	O
edma_pget	function
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_add_superobject] Can't realloc "	pointer
"object superclass table. Not enough memory"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
gObj	O
[	O
id	long
]	O
->	O
nUpTable	long
=	O
n	long
+	O
1	int
;	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	pointer
[	O
n	long
]	O
.	O
IdClass	long
=	O
cid	long
;	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	pointer
[	O
n	long
]	O
.	O
Obj	long
=	O
superid	long
;	O
strncpy	function
(	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	pointer
[	O
n	long
]	O
.	O
Id	long
,	O
apoint	pointer
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_add_sub_ap	function
(	O
OBJID	long
id	long
,	O
EPChar	pointer
apoint	pointer
,	O
CLASSID	long
cid	long
,	O
OBJID	long
subid	long
,	O
ESint32	long
flags	long
)	O
{	O
ESint32	long
n	long
;	O
if	O
(	O
apoint	pointer
)	O
{	O
if	O
(	O
_edma_locate_downlink_by_name	function
(	O
id	long
,	O
apoint	pointer
)	O
!=	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_add_sub_ap] Anchor point %s "	pointer
"already exists on object %ld [%s]"	pointer
,	O
apoint	pointer
,	O
id	long
,	O
gClass	O
[	O
gObj	O
[	O
id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
n	long
=	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
;	O
if	O
(	O
n	long
<	O
0	int
)	O
edma_printf_err	function
(	O
"[edma_add_sub_ap] Number of entries in downlink table is < 0: %d"	pointer
,	O
n	long
)	O
;	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct
.	O
hDownTable	long
=	O
edma_prealloc	function
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct
.	O
hDownTable	long
,	O
sizeof	O
(	O
SC_ID	struct
)	O
*	O
(	O
n	long
+	O
1	int
)	O
)	O
)	O
==	O
0	int
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_add_sub_ap] Can't realloc "	pointer
"object subclass table. Not enough memory"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
=	O
edma_pget	function
(	O
gObj	O
[	O
id	long
]	O
->	O
SysObj	struct
.	O
hDownTable	long
)	O
)	O
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_add_superobject] Can't realloc "	pointer
"object subclass table. Not enough memory"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
=	O
n	long
+	O
1	int
;	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
[	O
n	long
]	O
.	O
IdClass	long
=	O
cid	long
;	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
[	O
n	long
]	O
.	O
Obj	long
=	O
subid	long
;	O
strncpy	function
(	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
[	O
n	long
]	O
.	O
Id	long
,	O
apoint	pointer
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
return	O
0	int
;	O
}	O
OBJID	long
EDMAPROC	O
edma_set_super_ap	function
(	O
OBJID	long
id	long
,	O
EPChar	pointer
apoint	pointer
,	O
OBJID	long
new_id	long
)	O
{	O
ESint32	long
indx	long
,	O
temp_indx	long
;	O
OBJID	long
old_id	long
;	O
if	O
(	O
!	O
apoint	pointer
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_set_super_ap] Invalid anchor point (NULL)"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
indx	long
=	O
_edma_locate_uplink_by_name	function
(	O
id	long
,	O
apoint	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_set_super_ap] Anchor point %s "	pointer
"doesn't exist on object %ld [%s]"	pointer
,	O
apoint	pointer
,	O
id	long
,	O
gClass	O
[	O
gObj	O
[	O
id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
old_id	long
=	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	pointer
[	O
indx	long
]	O
.	O
Obj	long
;	O
if	O
(	O
(	O
edma_cast_obj	function
(	O
new_id	long
,	O
gClass	O
[	O
gObj	O
[	O
old_id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf	function
(	O
"%s"	pointer
,	O
"[edma_set_super_ap] New object type doesn't match Anchor Point Type"	pointer
)	O
;	O
}	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	pointer
[	O
indx	long
]	O
.	O
IdClass	long
=	O
gObj	O
[	O
new_id	long
]	O
->	O
IdClass	long
;	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	pointer
[	O
indx	long
]	O
.	O
Obj	long
=	O
new_id	long
;	O
if	O
(	O
(	O
temp_indx	long
=	O
_edma_locate_downlink_by_obj	function
(	O
old_id	long
,	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[WARNNING] SuperObject %d bad linkage to object %d. No anchor point found"	pointer
,	O
old_id	long
,	O
id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
gObj	O
[	O
old_id	long
]	O
->	O
nDownTable	long
>	O
1	int
)	O
memcpy	function
(	O
gObj	O
[	O
old_id	long
]	O
->	O
DownTable	pointer
+	O
temp_indx	long
,	O
gObj	O
[	O
old_id	long
]	O
->	O
DownTable	pointer
+	O
temp_indx	long
+	O
1	int
,	O
gObj	O
[	O
old_id	long
]	O
->	O
nDownTable	long
-	O
temp_indx	long
)	O
;	O
gObj	O
[	O
old_id	long
]	O
->	O
nDownTable	long
--	O
;	O
if	O
(	O
gObj	O
[	O
old_id	long
]	O
->	O
nDownTable	long
<=	O
0	int
)	O
{	O
edma_pfree	function
(	O
gObj	O
[	O
old_id	long
]	O
->	O
SysObj	struct
.	O
hDownTable	long
,	O
gObj	O
[	O
old_id	long
]	O
->	O
DownTable	pointer
)	O
;	O
}	O
return	O
old_id	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_set_sub_ap	function
(	O
OBJID	long
id	long
,	O
EPChar	pointer
apoint	pointer
,	O
OBJID	long
new_id	long
)	O
{	O
ESint32	long
indx	long
,	O
temp_indx	long
;	O
OBJID	long
old_id	long
;	O
if	O
(	O
!	O
apoint	pointer
)	O
{	O
edma_printf_err	function
(	O
"%s"	pointer
,	O
"[edma_set_sub_ap] Invalid anchor point (NULL)"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
indx	long
=	O
_edma_locate_downlink_by_name	function
(	O
id	long
,	O
apoint	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_set_sub_ap] Anchor point %s "	pointer
"doesn't exists on object %ld [%s]"	pointer
,	O
apoint	pointer
,	O
id	long
,	O
gClass	O
[	O
gObj	O
[	O
id	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array
)	O
;	O
return	O
-	O
1	int
;	O
}	O
old_id	long
=	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
[	O
indx	long
]	O
.	O
Obj	long
;	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
[	O
indx	long
]	O
.	O
IdClass	long
=	O
gObj	O
[	O
new_id	long
]	O
->	O
IdClass	long
;	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
[	O
indx	long
]	O
.	O
Obj	long
=	O
new_id	long
;	O
if	O
(	O
(	O
temp_indx	long
=	O
_edma_locate_uplink_by_obj	function
(	O
old_id	long
,	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_set_sub_ap] ** WARNNING** SuperObject %d bad linkage to object %d. "	pointer
"No anchor point found"	pointer
,	O
old_id	long
,	O
id	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
memcpy	function
(	O
gObj	O
[	O
old_id	long
]	O
->	O
UpTable	pointer
+	O
temp_indx	long
,	O
gObj	O
[	O
old_id	long
]	O
->	O
UpTable	pointer
+	O
temp_indx	long
+	O
1	int
,	O
gObj	O
[	O
old_id	long
]	O
->	O
nUpTable	long
-	O
temp_indx	long
)	O
;	O
gObj	O
[	O
old_id	long
]	O
->	O
nUpTable	long
--	O
;	O
if	O
(	O
gObj	O
[	O
old_id	long
]	O
->	O
nUpTable	long
<=	O
0	int
)	O
{	O
edma_pfree	function
(	O
gObj	O
[	O
old_id	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
,	O
gObj	O
[	O
old_id	long
]	O
->	O
UpTable	pointer
)	O
;	O
}	O
return	O
old_id	long
;	O
}	O
