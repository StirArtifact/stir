struct	O
obstack	struct
lang_args_obstack	struct
;	O
struct	O
lang_args	struct
*	O
lang_args_default	pointer
=	O
0	int
;	O
struct	O
lang_args	struct
*	O
lang_args_list	pointer
=	O
0	int
;	O
struct	O
obstack	struct
tokens_obstack	struct
;	O
int	O
log_8_member_files	int
=	O
0	int
;	O
extern	O
void	O
usage	function
(	O
void	O
)	O
;	O
extern	O
char	O
*	O
program_name	pointer
;	O
struct	O
lang_args	struct
*	O
*	O
parse_language_map_file	function
(	O
char	O
const	O
*	O
file_name	pointer
,	O
struct	O
lang_args	struct
*	O
*	O
next_ptr	pointer
)	O
;	O
char	O
*	O
read_language_map_file	function
(	O
char	O
const	O
*	O
file_name	pointer
)	O
;	O
void	O
tokenize_args_string	function
(	O
char	O
*	O
args_string	pointer
,	O
int	O
*	O
argcp	pointer
,	O
char	O
*	O
*	O
*	O
argvp	pointer
)	O
;	O
static	O
struct	O
token	struct
*	O
get_token_c	function
(	O
FILE	struct
*	O
in_FILE	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
int	O
*	O
flags	pointer
)	O
;	O
static	O
void	O
*	O
parse_args_c	function
(	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
argc	int
)	O
;	O
static	O
void	O
help_me_c	function
(	O
void	O
)	O
;	O
static	O
void	O
help_me_cpp	function
(	O
void	O
)	O
;	O
static	O
void	O
help_me_java	function
(	O
void	O
)	O
;	O
static	O
struct	O
token	struct
*	O
get_token_asm	function
(	O
FILE	struct
*	O
in_FILE	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
int	O
*	O
flags	pointer
)	O
;	O
static	O
void	O
*	O
parse_args_asm	function
(	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
argc	int
)	O
;	O
static	O
void	O
help_me_asm	function
(	O
void	O
)	O
;	O
static	O
struct	O
token	struct
*	O
get_token_text	function
(	O
FILE	struct
*	O
in_FILE	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
int	O
*	O
flags	pointer
)	O
;	O
static	O
void	O
*	O
parse_args_text	function
(	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
argc	int
)	O
;	O
static	O
void	O
help_me_text	function
(	O
void	O
)	O
;	O
static	O
struct	O
token	struct
*	O
get_token_perl	function
(	O
FILE	struct
*	O
in_FILE	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
int	O
*	O
flags	pointer
)	O
;	O
static	O
void	O
*	O
parse_args_perl	function
(	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
argc	int
)	O
;	O
static	O
void	O
help_me_perl	function
(	O
void	O
)	O
;	O
static	O
struct	O
token	struct
*	O
get_token_lisp	function
(	O
FILE	struct
*	O
in_FILE	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
int	O
*	O
flags	pointer
)	O
;	O
static	O
void	O
*	O
parse_args_lisp	function
(	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
argc	int
)	O
;	O
static	O
void	O
help_me_lisp	function
(	O
void	O
)	O
;	O
struct	O
language	struct
languages_0	array
[	O
]	O
=	O
{	O
{	O
"C"	pointer
,	O
parse_args_c	function
,	O
get_token_c	function
,	O
help_me_c	function
}	O
,	O
{	O
"C++"	pointer
,	O
parse_args_c	function
,	O
get_token_c	function
,	O
help_me_cpp	function
}	O
,	O
{	O
"Java"	pointer
,	O
parse_args_c	function
,	O
get_token_c	function
,	O
help_me_java	function
}	O
,	O
{	O
"asm"	pointer
,	O
parse_args_asm	function
,	O
get_token_asm	function
,	O
help_me_asm	function
}	O
,	O
{	O
"text"	pointer
,	O
parse_args_text	function
,	O
get_token_text	function
,	O
help_me_text	function
}	O
,	O
{	O
"perl"	pointer
,	O
parse_args_perl	function
,	O
get_token_perl	function
,	O
help_me_perl	function
}	O
,	O
{	O
"lisp"	pointer
,	O
parse_args_lisp	function
,	O
get_token_lisp	function
,	O
help_me_lisp	function
}	O
}	O
;	O
struct	O
language	struct
const	O
*	O
languages_N	pointer
=	O
&	O
languages_0	array
[	O
cardinalityof	O
(	O
languages_0	array
)	O
]	O
;	O
void	O
language_help_me	function
(	O
void	O
)	O
{	O
struct	O
language	struct
*	O
lang	pointer
;	O
for	O
(	O
lang	pointer
=	O
languages_0	array
;	O
lang	pointer
<	O
languages_N	pointer
;	O
lang	pointer
++	O
)	O
{	O
putchar	function
(	O
'\n'	O
)	O
;	O
(	O
*	O
lang	pointer
->	O
lg_help_me	pointer
)	O
(	O
)	O
;	O
}	O
}	O
void	O
language_save_arg	function
(	O
char	O
*	O
arg	pointer
)	O
{	O
static	O
char	O
horizontal_space	array
[	O
]	O
=	O
" \t"	pointer
;	O
char	O
*	O
lang_name	pointer
=	O
strsep	function
(	O
&	O
arg	pointer
,	O
":"	pointer
)	O
;	O
struct	O
language	struct
*	O
lang	pointer
=	O
get_language	function
(	O
lang_name	pointer
)	O
;	O
if	O
(	O
lang	pointer
==	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"unrecognized language: `%s'"	pointer
)	O
,	O
lang_name	pointer
)	O
;	O
usage	function
(	O
)	O
;	O
}	O
if	O
(	O
lang	pointer
->	O
lg_argc	int
==	O
0	int
)	O
lang	pointer
->	O
lg_argv	array
[	O
lang	pointer
->	O
lg_argc	int
++	O
]	O
=	O
program_name	pointer
;	O
lang	pointer
->	O
lg_argv	array
[	O
lang	pointer
->	O
lg_argc	int
++	O
]	O
=	O
strsep	function
(	O
&	O
arg	pointer
,	O
horizontal_space	array
)	O
;	O
}	O
void	O
language_getopt	function
(	O
void	O
)	O
{	O
struct	O
language	struct
*	O
lang	pointer
;	O
for	O
(	O
lang	pointer
=	O
languages_0	array
;	O
lang	pointer
<	O
languages_N	pointer
;	O
lang	pointer
++	O
)	O
if	O
(	O
lang	pointer
->	O
lg_argc	int
)	O
lang	pointer
->	O
lg_parse_args	pointer
(	O
lang	pointer
->	O
lg_argv	array
,	O
lang	pointer
->	O
lg_argc	int
)	O
;	O
}	O
struct	O
language	struct
*	O
get_language	function
(	O
char	O
const	O
*	O
lang_name	pointer
)	O
{	O
struct	O
language	struct
*	O
lang	pointer
;	O
for	O
(	O
lang	pointer
=	O
languages_0	array
;	O
lang	pointer
<	O
languages_N	pointer
;	O
lang	pointer
++	O
)	O
if	O
(	O
strequ	O
(	O
lang_name	pointer
,	O
lang	pointer
->	O
lg_name	pointer
)	O
)	O
{	O
DEBUG	O
(	O
(	O
"lang=%s"	pointer
,	O
lang_name	pointer
)	O
)	O
;	O
return	O
lang	pointer
;	O
}	O
DEBUG	O
(	O
(	O
"!lang=%s"	pointer
,	O
lang_name	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
lang_args_index	int
=	O
0	int
;	O
void	O
set_default_language	function
(	O
char	O
const	O
*	O
lang_name	pointer
)	O
{	O
}	O
void	O
parse_language_map	function
(	O
char	O
const	O
*	O
file_name	pointer
)	O
{	O
if	O
(	O
obstack_init	O
(	O
&	O
lang_args_obstack	struct
)	O
==	O
0	int
)	O
error	function
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"can't allocate language args obstack: memory exhausted"	pointer
)	O
)	O
;	O
if	O
(	O
file_name	pointer
==	O
0	int
)	O
file_name	pointer
=	O
LANGUAGE_MAP_FILE	O
;	O
parse_language_map_file	function
(	O
file_name	pointer
,	O
&	O
lang_args_list	pointer
)	O
;	O
}	O
struct	O
lang_args	struct
*	O
*	O
parse_language_map_file	function
(	O
char	O
const	O
*	O
file_name	pointer
,	O
struct	O
lang_args	struct
*	O
*	O
next_ptr	pointer
)	O
{	O
static	O
char	O
white_space	array
[	O
]	O
=	O
" \t\r\n\v\f"	pointer
;	O
static	O
char	O
horizontal_space	array
[	O
]	O
=	O
" \t"	pointer
;	O
static	O
char	O
vertical_space	array
[	O
]	O
=	O
"\r\n\v\f"	pointer
;	O
char	O
*	O
lang_map_buffer	pointer
;	O
char	O
*	O
lmp	pointer
;	O
lmp	pointer
=	O
lang_map_buffer	pointer
=	O
read_language_map_file	function
(	O
file_name	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
lang_args	struct
*	O
new_args	pointer
;	O
struct	O
language	struct
const	O
*	O
lang	pointer
;	O
int	O
pattern_size	int
;	O
char	O
*	O
lang_name	pointer
;	O
int	O
space	int
;	O
while	O
(	O
*	O
lmp	pointer
)	O
{	O
lmp	pointer
+=	O
strspn	function
(	O
lmp	pointer
,	O
white_space	array
)	O
;	O
if	O
(	O
*	O
lmp	pointer
!=	O
'#'	O
)	O
break	O
;	O
lmp	pointer
+=	O
strcspn	function
(	O
lmp	pointer
,	O
vertical_space	array
)	O
;	O
}	O
if	O
(	O
*	O
lmp	pointer
==	O
'\0'	O
)	O
break	O
;	O
pattern_size	int
=	O
strcspn	function
(	O
lmp	pointer
,	O
white_space	array
)	O
;	O
if	O
(	O
pattern_size	int
==	O
3	int
&&	O
strnequ	O
(	O
lmp	pointer
,	O
"***"	pointer
,	O
3	int
)	O
)	O
{	O
lmp	pointer
+=	O
pattern_size	int
;	O
lmp	pointer
+=	O
strspn	function
(	O
lmp	pointer
,	O
horizontal_space	array
)	O
;	O
if	O
(	O
isspace	function
(	O
*	O
lmp	pointer
)	O
)	O
next_ptr	pointer
=	O
parse_language_map_file	function
(	O
LANGUAGE_MAP_FILE	O
,	O
next_ptr	pointer
)	O
;	O
else	O
{	O
char	O
*	O
end	pointer
=	O
lmp	pointer
+	O
strcspn	function
(	O
lmp	pointer
,	O
white_space	array
)	O
;	O
*	O
end	pointer
=	O
'\0'	O
;	O
next_ptr	pointer
=	O
parse_language_map_file	function
(	O
lmp	pointer
,	O
next_ptr	pointer
)	O
;	O
lmp	pointer
=	O
end	pointer
+	O
1	int
;	O
}	O
continue	O
;	O
}	O
new_args	pointer
=	O
obstack_alloc	O
(	O
&	O
lang_args_obstack	struct
,	O
sizeof	O
(	O
struct	O
lang_args	struct
)	O
*	O
1	int
)	O
;	O
if	O
(	O
new_args	pointer
==	O
0	int
)	O
error	function
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"can't allocate language args: memory exhausted"	pointer
)	O
)	O
;	O
new_args	pointer
->	O
la_pattern	pointer
=	O
obstack_copy0	O
(	O
&	O
lang_args_obstack	struct
,	O
lmp	pointer
,	O
pattern_size	int
)	O
;	O
new_args	pointer
->	O
la_args_string	pointer
=	O
0	int
;	O
new_args	pointer
->	O
la_next	pointer
=	O
0	int
;	O
lmp	pointer
+=	O
pattern_size	int
;	O
lmp	pointer
+=	O
strspn	function
(	O
lmp	pointer
,	O
horizontal_space	array
)	O
;	O
if	O
(	O
isspace	function
(	O
*	O
lmp	pointer
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"language name expected following `%s' in file `%s'"	pointer
)	O
,	O
new_args	pointer
->	O
la_pattern	pointer
,	O
file_name	pointer
)	O
;	O
obstack_free	function
(	O
&	O
lang_args_obstack	struct
,	O
new_args	pointer
)	O
;	O
continue	O
;	O
}	O
lang_name	pointer
=	O
lmp	pointer
;	O
lmp	pointer
+=	O
strcspn	function
(	O
lmp	pointer
,	O
white_space	array
)	O
;	O
space	int
=	O
*	O
lmp	pointer
;	O
*	O
lmp	pointer
++	O
=	O
'\0'	O
;	O
lmp	pointer
+=	O
strspn	function
(	O
lmp	pointer
,	O
horizontal_space	array
)	O
;	O
lang	pointer
=	O
new_args	pointer
->	O
la_language	pointer
=	O
get_language	function
(	O
lang_name	pointer
)	O
;	O
if	O
(	O
*	O
lmp	pointer
==	O
'#'	O
)	O
lmp	pointer
+=	O
strcspn	function
(	O
lmp	pointer
,	O
vertical_space	array
)	O
;	O
else	O
if	O
(	O
!	O
isspace	function
(	O
*	O
lmp	pointer
)	O
&&	O
(	O
space	int
==	O
' '	O
||	O
space	int
==	O
'\t'	O
)	O
)	O
{	O
int	O
args_size	int
=	O
strcspn	function
(	O
lmp	pointer
,	O
vertical_space	array
)	O
;	O
new_args	pointer
->	O
la_args_string	pointer
=	O
obstack_copy0	O
(	O
&	O
lang_args_obstack	struct
,	O
lmp	pointer
,	O
args_size	int
)	O
;	O
lmp	pointer
+=	O
args_size	int
;	O
}	O
new_args	pointer
->	O
la_args_digested	pointer
=	O
(	O
lang	pointer
?	O
lang	pointer
->	O
lg_parse_args	pointer
(	O
&	O
new_args	pointer
->	O
la_args_string	pointer
,	O
0	int
)	O
:	O
0	int
)	O
;	O
if	O
(	O
pattern_size	int
==	O
2	int
&&	O
strnequ	O
(	O
new_args	pointer
->	O
la_pattern	pointer
,	O
"**"	pointer
,	O
2	int
)	O
)	O
{	O
if	O
(	O
lang_args_default	pointer
)	O
{	O
obstack_free	function
(	O
&	O
lang_args_obstack	struct
,	O
new_args	pointer
)	O
;	O
continue	O
;	O
}	O
lang_args_default	pointer
=	O
new_args	pointer
;	O
DEBUG	O
(	O
(	O
", <default>"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
new_args	pointer
->	O
la_index	int
=	O
lang_args_index	int
++	O
;	O
*	O
next_ptr	pointer
=	O
new_args	pointer
;	O
next_ptr	pointer
=	O
&	O
new_args	pointer
->	O
la_next	pointer
;	O
}	O
DEBUG	O
(	O
(	O
", pat=%s\n"	pointer
,	O
new_args	pointer
->	O
la_pattern	pointer
)	O
)	O
;	O
}	O
free	function
(	O
lang_map_buffer	pointer
)	O
;	O
return	O
next_ptr	pointer
;	O
}	O
char	O
*	O
read_language_map_file	function
(	O
char	O
const	O
*	O
file_name	pointer
)	O
{	O
int	O
map_fd	int
;	O
char	O
*	O
lang_map_buffer	pointer
;	O
struct	O
stat	struct
st	struct
;	O
int	O
bytes	int
;	O
map_fd	int
=	O
open	function
(	O
file_name	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
map_fd	int
<	O
0	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't open language map file `%s'"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
if	O
(	O
fstat	function
(	O
map_fd	int
,	O
&	O
st	struct
)	O
<	O
0	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't get size of map file `%s'"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
lang_map_buffer	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
)	O
*	O
(	O
st	struct
.	O
st_size	long
+	O
2	int
)	O
)	O
;	O
if	O
(	O
lang_map_buffer	pointer
==	O
0	int
)	O
error	function
(	O
1	int
,	O
0	int
,	O
_	O
(	O
"can't allocate language args: memory exhausted"	pointer
)	O
)	O
;	O
lang_map_buffer	pointer
[	O
st	struct
.	O
st_size	long
]	O
=	O
'\n'	O
;	O
lang_map_buffer	pointer
[	O
st	struct
.	O
st_size	long
+	O
1	int
]	O
=	O
'\0'	O
;	O
bytes	int
=	O
read	pointer
(	O
map_fd	int
,	O
lang_map_buffer	pointer
,	O
st	struct
.	O
st_size	long
)	O
;	O
if	O
(	O
bytes	int
<	O
0	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't read language map file `%s'"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
if	O
(	O
bytes	int
!=	O
st	struct
.	O
st_size	long
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't read entire language map file `%s'"	pointer
)	O
,	O
file_name	pointer
)	O
;	O
close	pointer
(	O
map_fd	int
)	O
;	O
return	O
lang_map_buffer	pointer
;	O
}	O
void	O
tokenize_args_string	function
(	O
char	O
*	O
args_string	pointer
,	O
int	O
*	O
argcp	pointer
,	O
char	O
*	O
*	O
*	O
argvp	pointer
)	O
{	O
static	O
char	O
horizontal_space	array
[	O
]	O
=	O
" \t"	pointer
;	O
char	O
*	O
*	O
argv_0	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
strlen	function
(	O
args_string	pointer
)	O
/	O
2	int
)	O
;	O
char	O
*	O
*	O
argv	pointer
=	O
argv_0	pointer
;	O
char	O
*	O
arg	pointer
;	O
*	O
argv	pointer
++	O
=	O
program_name	pointer
;	O
arg	pointer
=	O
strsep	function
(	O
&	O
args_string	pointer
,	O
horizontal_space	array
)	O
;	O
while	O
(	O
arg	pointer
)	O
{	O
*	O
argv	pointer
++	O
=	O
arg	pointer
;	O
arg	pointer
=	O
strsep	function
(	O
&	O
args_string	pointer
,	O
horizontal_space	array
)	O
;	O
}	O
*	O
argcp	pointer
=	O
argv	pointer
-	O
argv_0	pointer
;	O
*	O
argvp	pointer
=	O
xrealloc	function
(	O
argv_0	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
*	O
argcp	pointer
)	O
)	O
;	O
}	O
static	O
void	O
set_ushort_ctype	function
(	O
unsigned	O
short	O
*	O
ctype	pointer
,	O
char	O
const	O
*	O
chars	pointer
,	O
int	O
type	enum
)	O
{	O
unsigned	O
short	O
*	O
rct	pointer
=	O
&	O
ctype	pointer
[	O
1	int
]	O
;	O
unsigned	O
char	O
const	O
*	O
uc	pointer
=	O
(	O
unsigned	O
char	O
const	O
*	O
)	O
chars	pointer
;	O
while	O
(	O
*	O
uc	pointer
)	O
rct	pointer
[	O
*	O
uc	pointer
++	O
]	O
|=	O
type	enum
;	O
}	O
static	O
void	O
clear_ushort_ctype	function
(	O
unsigned	O
short	O
*	O
ctype	pointer
,	O
char	O
const	O
*	O
chars	pointer
,	O
int	O
type	enum
)	O
{	O
unsigned	O
short	O
*	O
rct	pointer
=	O
&	O
ctype	pointer
[	O
1	int
]	O
;	O
unsigned	O
char	O
const	O
*	O
uc	pointer
=	O
(	O
unsigned	O
char	O
const	O
*	O
)	O
chars	pointer
;	O
while	O
(	O
*	O
uc	pointer
)	O
rct	pointer
[	O
*	O
uc	pointer
++	O
]	O
&=	O
~	O
type	enum
;	O
}	O
static	O
void	O
set_uchar_ctype	function
(	O
unsigned	O
char	O
*	O
ctype	pointer
,	O
char	O
const	O
*	O
chars	pointer
,	O
int	O
type	enum
)	O
{	O
unsigned	O
char	O
*	O
rct	pointer
;	O
unsigned	O
char	O
const	O
*	O
uc	pointer
;	O
rct	pointer
=	O
&	O
ctype	pointer
[	O
1	int
]	O
;	O
uc	pointer
=	O
(	O
unsigned	O
char	O
const	O
*	O
)	O
chars	pointer
;	O
while	O
(	O
*	O
uc	pointer
)	O
rct	pointer
[	O
*	O
uc	pointer
++	O
]	O
|=	O
type	enum
;	O
}	O
static	O
void	O
clear_uchar_ctype	function
(	O
unsigned	O
char	O
*	O
ctype	pointer
,	O
char	O
const	O
*	O
chars	pointer
,	O
int	O
type	enum
)	O
{	O
unsigned	O
char	O
*	O
rct	pointer
;	O
unsigned	O
char	O
const	O
*	O
uc	pointer
;	O
rct	pointer
=	O
&	O
ctype	pointer
[	O
1	int
]	O
;	O
uc	pointer
=	O
(	O
unsigned	O
char	O
const	O
*	O
)	O
chars	pointer
;	O
while	O
(	O
*	O
uc	pointer
)	O
rct	pointer
[	O
*	O
uc	pointer
++	O
]	O
&=	O
~	O
type	enum
;	O
}	O
static	O
unsigned	O
short	O
ctype_c	array
[	O
257	int
]	O
=	O
{	O
EF	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NL	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
Q2	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
Q1	int
,	O
0	int
,	O
0	int
,	O
C2	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NM	int
,	O
C1	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
ES	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
}	O
;	O
struct	O
args_c	struct
{	O
int	O
strip_underscore	int
;	O
unsigned	O
short	O
*	O
ctype	pointer
;	O
}	O
;	O
static	O
struct	O
args_c	struct
args_c	struct
=	O
{	O
0	int
,	O
ctype_c	array
}	O
;	O
static	O
struct	O
option	struct
const	O
long_options_c	array
[	O
]	O
=	O
{	O
{	O
"keep"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"ignore"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"strip-underscore"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
void	O
help_me_c	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"C language:\n  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the result\n  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the result\n  -u,--strip-underscore  Strip a leading underscore from single-token strings\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
help_me_cpp	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"C++ language:\n  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the result\n  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the result\n  -u,--strip-underscore  Strip a leading underscore from single-token strings\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
help_me_java	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Java language:\n  -k,--keep=CHARS        Allow CHARS in single-token strings, keep the result\n  -i,--ignore=CHARS      Allow CHARS in single-token strings, toss the result\n  -u,--strip-underscore  Strip a leading underscore from single-token strings\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
*	O
parse_args_c	function
(	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
argc	int
)	O
{	O
char	O
*	O
tmp_string	pointer
=	O
0	int
;	O
struct	O
args_c	struct
*	O
args	pointer
;	O
if	O
(	O
argv	pointer
==	O
0	int
||	O
*	O
argv	pointer
==	O
0	int
)	O
return	O
&	O
args_c	struct
;	O
if	O
(	O
argc	int
)	O
args	pointer
=	O
&	O
args_c	struct
;	O
else	O
{	O
tmp_string	pointer
=	O
strdup	function
(	O
*	O
argv	pointer
)	O
;	O
tokenize_args_string	function
(	O
tmp_string	pointer
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
args	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
args_c	struct
)	O
*	O
1	int
)	O
;	O
args	pointer
->	O
strip_underscore	int
=	O
0	int
;	O
args	pointer
->	O
ctype	pointer
=	O
ctype_c	array
;	O
}	O
optind	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"k:i:u"	pointer
,	O
long_options_c	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
optc	int
==	O
'k'	O
||	O
optc	int
==	O
'i'	O
)	O
&&	O
args	pointer
->	O
ctype	pointer
==	O
ctype_c	array
)	O
args	pointer
->	O
ctype	pointer
=	O
CLONE	O
(	O
ctype_c	array
,	O
unsigned	O
short	O
,	O
cardinalityof	O
(	O
ctype_c	array
)	O
)	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'k'	O
:	O
set_ushort_ctype	function
(	O
args	pointer
->	O
ctype	pointer
,	O
optarg	pointer
,	O
SK	int
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
clear_ushort_ctype	function
(	O
args	pointer
->	O
ctype	pointer
,	O
optarg	pointer
,	O
SK	int
)	O
;	O
break	O
;	O
case	O
'u'	O
:	O
args	pointer
->	O
strip_underscore	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
tmp_string	pointer
)	O
{	O
free	function
(	O
argv	pointer
)	O
;	O
free	function
(	O
tmp_string	pointer
)	O
;	O
}	O
return	O
args	pointer
;	O
}	O
unsigned	O
char	O
*	O
scanner_buffer	pointer
;	O
static	O
struct	O
token	struct
*	O
get_token_c	function
(	O
FILE	struct
*	O
in_FILE	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
int	O
*	O
flags	pointer
)	O
{	O
static	O
int	O
new_line	int
=	O
1	int
;	O
unsigned	O
short	O
const	O
*	O
rct	pointer
=	O
&	O
ARGS	O
->	O
ctype	pointer
[	O
1	int
]	O
;	O
unsigned	O
char	O
*	O
id	pointer
=	O
scanner_buffer	pointer
;	O
int	O
c	int
;	O
int	O
d	int
;	O
obstack_blank	O
(	O
&	O
tokens_obstack	struct
,	O
OFFSETOF_TOKEN_NAME	O
)	O
;	O
top	O
:	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
new_line	int
)	O
SCAN_CPP_DIRECTIVE	O
;	O
next	O
:	O
while	O
(	O
ISBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'"'	O
:	O
id	pointer
=	O
scanner_buffer	pointer
;	O
*	O
id	pointer
++	O
=	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
ISQ2BORING	O
(	O
c	int
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
*	O
id	pointer
++	O
=	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
c	int
!=	O
'"'	O
)	O
goto	O
next	O
;	O
break	O
;	O
}	O
*	O
--	O
id	pointer
=	O
'\0'	O
;	O
id	pointer
=	O
scanner_buffer	pointer
;	O
while	O
(	O
ISSTRKEEP	O
(	O
d	int
=	O
*	O
id	pointer
)	O
)	O
id	pointer
++	O
;	O
if	O
(	O
*	O
id	pointer
||	O
id	pointer
==	O
scanner_buffer	pointer
)	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
goto	O
next	O
;	O
}	O
*	O
flags	pointer
=	O
TOK_STRING	int
;	O
if	O
(	O
ARGS	O
->	O
strip_underscore	int
&&	O
scanner_buffer	pointer
[	O
0	int
]	O
==	O
'_'	O
&&	O
scanner_buffer	pointer
[	O
1	int
]	O
)	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct
,	O
scanner_buffer	pointer
+	O
1	int
,	O
id	pointer
-	O
scanner_buffer	pointer
-	O
1	int
)	O
;	O
else	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct
,	O
scanner_buffer	pointer
,	O
id	pointer
-	O
scanner_buffer	pointer
)	O
;	O
return	O
(	O
struct	O
token	struct
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
;	O
case	O
'\''	O
:	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
ISQ1BORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\''	O
)	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
goto	O
next	O
;	O
}	O
case	O
'/'	O
:	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'/'	O
)	O
{	O
while	O
(	O
ISCCBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
new_line	int
=	O
1	int
;	O
goto	O
top	O
;	O
}	O
else	O
if	O
(	O
c	int
!=	O
'*'	O
)	O
goto	O
next	O
;	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
ISCBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'/'	O
)	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
goto	O
next	O
;	O
}	O
else	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
new_line	int
=	O
1	int
;	O
obstack_free	function
(	O
&	O
tokens_obstack	struct
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
case	O
'\n'	O
:	O
new_line	int
=	O
1	int
;	O
goto	O
top	O
;	O
default	O
:	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
new_line	int
=	O
1	int
;	O
obstack_free	function
(	O
&	O
tokens_obstack	struct
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
)	O
;	O
return	O
0	int
;	O
}	O
id	pointer
=	O
scanner_buffer	pointer
;	O
*	O
id	pointer
++	O
=	O
c	int
;	O
if	O
(	O
ISID1ST	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	pointer
=	O
TOK_NAME	int
;	O
while	O
(	O
ISIDREST	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
}	O
else	O
if	O
(	O
ISDIGIT	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	pointer
=	O
TOK_NUMBER	int
;	O
while	O
(	O
ISNUMBER	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
}	O
else	O
{	O
if	O
(	O
isprint	function
(	O
c	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"junk: `%c'"	pointer
)	O
,	O
c	int
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"junk: `\\%03o'"	pointer
)	O
,	O
c	int
)	O
;	O
}	O
ungetc	function
(	O
c	int
,	O
in_FILE	pointer
)	O
;	O
*	O
flags	pointer
|=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct
,	O
scanner_buffer	pointer
,	O
id	pointer
-	O
scanner_buffer	pointer
)	O
;	O
return	O
(	O
struct	O
token	struct
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
;	O
}	O
}	O
static	O
unsigned	O
char	O
ctype_asm	array
[	O
257	int
]	O
=	O
{	O
EF	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NL	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
C2	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
C1	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
}	O
;	O
struct	O
args_asm	struct
{	O
int	O
handle_cpp	int
;	O
int	O
strip_underscore	int
;	O
unsigned	O
char	O
*	O
ctype	pointer
;	O
}	O
;	O
static	O
struct	O
args_asm	struct
args_asm	struct
=	O
{	O
1	int
,	O
0	int
,	O
ctype_asm	array
}	O
;	O
static	O
struct	O
option	struct
const	O
long_options_asm	array
[	O
]	O
=	O
{	O
{	O
"comment"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"keep"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"ignore"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"strip-underscore"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'u'	O
}	O
,	O
{	O
"no-cpp"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'n'	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
void	O
help_me_asm	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Assembly language:\n  -c,--comment=CHARS     Any of CHARS starts a comment until end-of-line\n  -k,--keep=CHARS        Allow CHARS in tokens, and keep the result\n  -i,--ignore=CHARS      Allow CHARS in tokens, and toss the result\n  -u,--strip-underscore  Strip a leading underscore from tokens\n  -n,--no-cpp            Don't handle C pre-processor directives\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
*	O
parse_args_asm	function
(	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
argc	int
)	O
{	O
char	O
*	O
tmp_string	pointer
=	O
0	int
;	O
struct	O
args_asm	struct
*	O
args	pointer
;	O
if	O
(	O
argv	pointer
==	O
0	int
||	O
*	O
argv	pointer
==	O
0	int
)	O
return	O
&	O
args_asm	struct
;	O
if	O
(	O
argc	int
)	O
args	pointer
=	O
&	O
args_asm	struct
;	O
else	O
{	O
tmp_string	pointer
=	O
strdup	function
(	O
*	O
argv	pointer
)	O
;	O
tokenize_args_string	function
(	O
tmp_string	pointer
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
args	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
args_asm	struct
)	O
*	O
1	int
)	O
;	O
args	pointer
->	O
strip_underscore	int
=	O
0	int
;	O
args	pointer
->	O
ctype	pointer
=	O
ctype_asm	array
;	O
args	pointer
->	O
handle_cpp	int
=	O
1	int
;	O
}	O
optind	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"c:k:i:un"	pointer
,	O
long_options_asm	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
optc	int
==	O
'k'	O
||	O
optc	int
==	O
'i'	O
||	O
optc	int
==	O
'c'	O
)	O
&&	O
args	pointer
->	O
ctype	pointer
==	O
ctype_asm	array
)	O
args	pointer
->	O
ctype	pointer
=	O
CLONE	O
(	O
ctype_asm	array
,	O
unsigned	O
char	O
,	O
cardinalityof	O
(	O
ctype_asm	array
)	O
)	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'c'	O
:	O
set_uchar_ctype	function
(	O
args	pointer
->	O
ctype	pointer
,	O
optarg	pointer
,	O
CM	int
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
set_uchar_ctype	function
(	O
args	pointer
->	O
ctype	pointer
,	O
optarg	pointer
,	O
I1	int
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
set_uchar_ctype	function
(	O
args	pointer
->	O
ctype	pointer
,	O
optarg	pointer
,	O
I1	int
|	O
IG	int
)	O
;	O
break	O
;	O
case	O
'u'	O
:	O
args	pointer
->	O
strip_underscore	int
=	O
1	int
;	O
break	O
;	O
case	O
'n'	O
:	O
args	pointer
->	O
handle_cpp	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
tmp_string	pointer
)	O
{	O
free	function
(	O
argv	pointer
)	O
;	O
free	function
(	O
tmp_string	pointer
)	O
;	O
}	O
return	O
args	pointer
;	O
}	O
static	O
struct	O
token	struct
*	O
get_token_asm	function
(	O
FILE	struct
*	O
in_FILE	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
int	O
*	O
flags	pointer
)	O
{	O
static	O
int	O
new_line	int
=	O
1	int
;	O
unsigned	O
char	O
const	O
*	O
rct	pointer
=	O
&	O
ARGS	O
->	O
ctype	pointer
[	O
1	int
]	O
;	O
unsigned	O
char	O
*	O
id	pointer
=	O
scanner_buffer	pointer
;	O
int	O
c	int
,	O
d	int
;	O
obstack_blank	O
(	O
&	O
tokens_obstack	struct
,	O
OFFSETOF_TOKEN_NAME	O
)	O
;	O
top	O
:	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
ARGS	O
->	O
handle_cpp	int
>	O
0	int
&&	O
new_line	int
)	O
SCAN_CPP_DIRECTIVE	O
;	O
next	O
:	O
while	O
(	O
ISBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
ISCOMMENT	O
(	O
c	int
)	O
)	O
{	O
while	O
(	O
ISCBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
new_line	int
=	O
1	int
;	O
}	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
new_line	int
=	O
1	int
;	O
obstack_free	function
(	O
&	O
tokens_obstack	struct
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
new_line	int
=	O
1	int
;	O
goto	O
top	O
;	O
}	O
if	O
(	O
c	int
==	O
'/'	O
)	O
{	O
if	O
(	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
!=	O
'*'	O
)	O
goto	O
next	O
;	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
ISCCBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'/'	O
)	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
new_line	int
=	O
1	int
;	O
obstack_free	function
(	O
&	O
tokens_obstack	struct
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
goto	O
next	O
;	O
}	O
id	pointer
=	O
scanner_buffer	pointer
;	O
if	O
(	O
ARGS	O
->	O
strip_underscore	int
&&	O
c	int
==	O
'_'	O
&&	O
!	O
ISID1ST	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
{	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct
,	O
"_"	pointer
,	O
1	int
)	O
;	O
return	O
(	O
struct	O
token	struct
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
;	O
}	O
*	O
id	pointer
++	O
=	O
c	int
;	O
if	O
(	O
ISID1ST	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	pointer
=	O
TOK_NAME	int
;	O
while	O
(	O
ISIDREST	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
}	O
else	O
if	O
(	O
ISNUMBER	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	pointer
=	O
TOK_NUMBER	int
;	O
while	O
(	O
ISNUMBER	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
}	O
else	O
{	O
if	O
(	O
isprint	function
(	O
c	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"junk: `%c'"	pointer
)	O
,	O
c	int
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"junk: `\\%03o'"	pointer
)	O
,	O
c	int
)	O
;	O
goto	O
next	O
;	O
}	O
*	O
id	pointer
=	O
'\0'	O
;	O
for	O
(	O
id	pointer
=	O
scanner_buffer	pointer
;	O
*	O
id	pointer
;	O
id	pointer
++	O
)	O
if	O
(	O
ISIGNORE	O
(	O
d	int
=	O
*	O
id	pointer
)	O
)	O
goto	O
next	O
;	O
ungetc	function
(	O
c	int
,	O
in_FILE	pointer
)	O
;	O
*	O
flags	pointer
|=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct
,	O
scanner_buffer	pointer
,	O
id	pointer
-	O
scanner_buffer	pointer
)	O
;	O
return	O
(	O
struct	O
token	struct
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
;	O
}	O
static	O
unsigned	O
char	O
ctype_text	array
[	O
257	int
]	O
=	O
{	O
EF	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
}	O
;	O
struct	O
args_text	struct
{	O
unsigned	O
char	O
*	O
ctype	pointer
;	O
}	O
;	O
static	O
struct	O
args_text	struct
args_text	struct
=	O
{	O
ctype_text	array
}	O
;	O
static	O
struct	O
option	struct
const	O
long_options_text	array
[	O
]	O
=	O
{	O
{	O
"include"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"exclude"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
void	O
help_me_text	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Text language:\n  -i,--include=CHAR-CLASS  Treat characters of CHAR-CLASS as token constituents\n  -x,--exclude=CHAR-CLASS  Treat characters of CHAR-CLASS as token delimiters\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
*	O
parse_args_text	function
(	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
argc	int
)	O
{	O
char	O
*	O
tmp_string	pointer
=	O
0	int
;	O
struct	O
args_text	struct
*	O
args	pointer
;	O
if	O
(	O
argv	pointer
==	O
0	int
||	O
*	O
argv	pointer
==	O
0	int
)	O
return	O
&	O
args_text	struct
;	O
if	O
(	O
argc	int
)	O
args	pointer
=	O
&	O
args_text	struct
;	O
else	O
{	O
tmp_string	pointer
=	O
strdup	function
(	O
*	O
argv	pointer
)	O
;	O
tokenize_args_string	function
(	O
tmp_string	pointer
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
args	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
args_text	struct
)	O
*	O
1	int
)	O
;	O
args	pointer
->	O
ctype	pointer
=	O
ctype_text	array
;	O
}	O
optind	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"i:x:"	pointer
,	O
long_options_text	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
optc	int
==	O
'x'	O
||	O
optc	int
==	O
'i'	O
)	O
&&	O
args	pointer
->	O
ctype	pointer
==	O
ctype_text	array
)	O
args	pointer
->	O
ctype	pointer
=	O
CLONE	O
(	O
ctype_text	array
,	O
unsigned	O
char	O
,	O
cardinalityof	O
(	O
ctype_text	array
)	O
)	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'i'	O
:	O
set_uchar_ctype	function
(	O
args	pointer
->	O
ctype	pointer
,	O
optarg	pointer
,	O
I1	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
clear_uchar_ctype	function
(	O
args	pointer
->	O
ctype	pointer
,	O
optarg	pointer
,	O
I1	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
tmp_string	pointer
)	O
{	O
free	function
(	O
argv	pointer
)	O
;	O
free	function
(	O
tmp_string	pointer
)	O
;	O
}	O
return	O
args	pointer
;	O
}	O
static	O
struct	O
token	struct
*	O
get_token_text	function
(	O
FILE	struct
*	O
in_FILE	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
int	O
*	O
flags	pointer
)	O
{	O
unsigned	O
char	O
const	O
*	O
rct	pointer
=	O
&	O
ARGS	O
->	O
ctype	pointer
[	O
1	int
]	O
;	O
int	O
c	int
;	O
unsigned	O
char	O
*	O
id	pointer
=	O
scanner_buffer	pointer
;	O
obstack_blank	O
(	O
&	O
tokens_obstack	struct
,	O
OFFSETOF_TOKEN_NAME	O
)	O
;	O
top	O
:	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
while	O
(	O
ISBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
obstack_free	function
(	O
&	O
tokens_obstack	struct
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
)	O
;	O
return	O
0	int
;	O
}	O
id	pointer
=	O
scanner_buffer	pointer
;	O
*	O
id	pointer
++	O
=	O
c	int
;	O
if	O
(	O
ISID1ST	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	pointer
=	O
TOK_NAME	int
;	O
while	O
(	O
ISIDREST	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
if	O
(	O
!	O
ISIDSQUEEZE	O
(	O
c	int
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
}	O
else	O
if	O
(	O
ISNUMBER	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	pointer
=	O
TOK_NUMBER	int
;	O
while	O
(	O
ISNUMBER	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
}	O
else	O
{	O
if	O
(	O
isprint	function
(	O
c	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"junk: `%c'"	pointer
)	O
,	O
c	int
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"junk: `\\%03o'"	pointer
)	O
,	O
c	int
)	O
;	O
goto	O
top	O
;	O
}	O
ungetc	function
(	O
c	int
,	O
in_FILE	pointer
)	O
;	O
*	O
flags	pointer
|=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct
,	O
scanner_buffer	pointer
,	O
id	pointer
-	O
scanner_buffer	pointer
)	O
;	O
return	O
(	O
struct	O
token	struct
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
;	O
}	O
static	O
unsigned	O
short	O
ctype_perl	array
[	O
257	int
]	O
=	O
{	O
EF	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NL	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
Q2	int
,	O
CM	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
Q1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
NM	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
EQ	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
ES	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
|	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
}	O
;	O
struct	O
args_perl	struct
{	O
int	O
exclude_dtags	int
;	O
unsigned	O
short	O
*	O
ctype	pointer
;	O
}	O
;	O
static	O
struct	O
args_perl	struct
args_perl	struct
=	O
{	O
1	int
,	O
ctype_perl	array
}	O
;	O
static	O
struct	O
option	struct
const	O
long_options_perl	array
[	O
]	O
=	O
{	O
{	O
"include"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'i'	O
}	O
,	O
{	O
"exclude"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'x'	O
}	O
,	O
{	O
"dtags"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
0	int
}	O
}	O
;	O
static	O
void	O
help_me_perl	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Perl language:\n  -i,--include=CHAR-CLASS  Treat characters of CHAR-CLASS as token constituents\n  -x,--exclude=CHAR-CLASS  Treat characters of CHAR-CLASS as token delimiters\n  -d,--dtags  Include documentation tags\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
*	O
parse_args_perl	function
(	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
argc	int
)	O
{	O
char	O
*	O
tmp_string	pointer
=	O
0	int
;	O
struct	O
args_perl	struct
*	O
args	pointer
;	O
if	O
(	O
argv	pointer
==	O
0	int
||	O
*	O
argv	pointer
==	O
0	int
)	O
return	O
&	O
args_perl	struct
;	O
if	O
(	O
argc	int
)	O
args	pointer
=	O
&	O
args_perl	struct
;	O
else	O
{	O
tmp_string	pointer
=	O
strdup	function
(	O
*	O
argv	pointer
)	O
;	O
tokenize_args_string	function
(	O
tmp_string	pointer
,	O
&	O
argc	int
,	O
&	O
argv	pointer
)	O
;	O
args	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
args_perl	struct
)	O
)	O
;	O
args	pointer
->	O
exclude_dtags	int
=	O
1	int
;	O
args	pointer
->	O
ctype	pointer
=	O
ctype_perl	array
;	O
}	O
optind	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"i:x:d"	pointer
,	O
long_options_perl	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
optc	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
optc	int
==	O
'x'	O
||	O
optc	int
==	O
'i'	O
)	O
&&	O
args	pointer
->	O
ctype	pointer
==	O
ctype_perl	array
)	O
args	pointer
->	O
ctype	pointer
=	O
CLONE	O
(	O
ctype_perl	array
,	O
unsigned	O
short	O
,	O
cardinalityof	O
(	O
ctype_perl	array
)	O
)	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'd'	O
:	O
args	pointer
->	O
exclude_dtags	int
=	O
0	int
;	O
break	O
;	O
case	O
'i'	O
:	O
set_ushort_ctype	function
(	O
args	pointer
->	O
ctype	pointer
,	O
optarg	pointer
,	O
I1	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
clear_ushort_ctype	function
(	O
args	pointer
->	O
ctype	pointer
,	O
optarg	pointer
,	O
I1	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
tmp_string	pointer
)	O
{	O
free	function
(	O
argv	pointer
)	O
;	O
free	function
(	O
tmp_string	pointer
)	O
;	O
}	O
return	O
args	pointer
;	O
}	O
static	O
struct	O
token	struct
*	O
get_token_perl	function
(	O
FILE	struct
*	O
in_FILE	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
int	O
*	O
flags	pointer
)	O
{	O
static	O
int	O
new_line	int
=	O
1	int
;	O
unsigned	O
short	O
const	O
*	O
rct	pointer
=	O
&	O
ARGS	O
->	O
ctype	pointer
[	O
1	int
]	O
;	O
int	O
c	int
,	O
state	pointer
=	O
0	int
,	O
skip_doc	int
=	O
0	int
;	O
unsigned	O
char	O
*	O
id	pointer
=	O
scanner_buffer	pointer
;	O
obstack_blank	O
(	O
&	O
tokens_obstack	struct
,	O
OFFSETOF_TOKEN_NAME	O
)	O
;	O
top	O
:	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
while	O
(	O
ISBORING	O
(	O
c	int
)	O
)	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'\n'	O
:	O
state	pointer
&=	O
~	O
CM	int
;	O
new_line	int
=	O
1	int
;	O
goto	O
top	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
new_line	int
=	O
0	int
;	O
goto	O
top	O
;	O
break	O
;	O
case	O
'#'	O
:	O
if	O
(	O
!	O
(	O
state	pointer
&	O
Q1	int
)	O
&&	O
!	O
(	O
state	pointer
&	O
Q2	int
)	O
)	O
state	pointer
|=	O
CM	int
;	O
break	O
;	O
case	O
'\''	O
:	O
if	O
(	O
!	O
skip_doc	int
)	O
if	O
(	O
!	O
(	O
state	pointer
&	O
CM	int
)	O
&&	O
!	O
(	O
state	pointer
&	O
Q2	int
)	O
)	O
state	pointer
^=	O
Q1	int
;	O
break	O
;	O
case	O
'\"'	O
:	O
if	O
(	O
!	O
skip_doc	int
)	O
if	O
(	O
!	O
(	O
state	pointer
&	O
CM	int
)	O
&&	O
!	O
(	O
state	pointer
&	O
Q1	int
)	O
)	O
state	pointer
^=	O
Q2	int
;	O
break	O
;	O
case	O
'='	O
:	O
if	O
(	O
new_line	int
&&	O
ARGS	O
->	O
exclude_dtags	int
)	O
{	O
skip_doc	int
=	O
1	int
;	O
state	pointer
&=	O
~	O
EQ	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
ISEOF	O
(	O
c	int
)	O
)	O
{	O
new_line	int
=	O
1	int
;	O
obstack_free	function
(	O
&	O
tokens_obstack	struct
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
)	O
;	O
return	O
0	int
;	O
}	O
break	O
;	O
}	O
new_line	int
=	O
0	int
;	O
if	O
(	O
ISCOMMENT	O
(	O
c	int
)	O
||	O
ISQUOTE1	O
(	O
c	int
)	O
||	O
ISQUOTE2	O
(	O
c	int
)	O
||	O
ISNEWLINE	O
(	O
c	int
)	O
||	O
ISEQUALS	O
(	O
c	int
)	O
||	O
state	pointer
)	O
goto	O
top	O
;	O
id	pointer
=	O
scanner_buffer	pointer
;	O
*	O
id	pointer
++	O
=	O
c	int
;	O
if	O
(	O
ISID1ST	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	pointer
=	O
TOK_NAME	int
;	O
while	O
(	O
ISIDREST	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
if	O
(	O
!	O
ISIDSQUEEZE	O
(	O
c	int
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
}	O
else	O
if	O
(	O
ISNUMBER	O
(	O
c	int
)	O
)	O
{	O
*	O
flags	pointer
=	O
TOK_NUMBER	int
;	O
while	O
(	O
ISNUMBER	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
ungetc	function
(	O
c	int
,	O
in_FILE	pointer
)	O
;	O
goto	O
top	O
;	O
}	O
else	O
{	O
if	O
(	O
isprint	function
(	O
c	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"junk: `%c'"	pointer
)	O
,	O
c	int
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"junk: `\\%03o'"	pointer
)	O
,	O
c	int
)	O
;	O
goto	O
top	O
;	O
}	O
ungetc	function
(	O
c	int
,	O
in_FILE	pointer
)	O
;	O
*	O
id	pointer
=	O
'\0'	O
;	O
if	O
(	O
skip_doc	int
)	O
{	O
if	O
(	O
strequ	O
(	O
scanner_buffer	pointer
,	O
"cut"	pointer
)	O
)	O
{	O
skip_doc	int
=	O
0	int
;	O
}	O
else	O
{	O
state	pointer
|=	O
EQ	int
;	O
}	O
goto	O
top	O
;	O
}	O
if	O
(	O
strequ	O
(	O
scanner_buffer	pointer
,	O
"_"	pointer
)	O
)	O
{	O
goto	O
top	O
;	O
}	O
*	O
flags	pointer
|=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct
,	O
scanner_buffer	pointer
,	O
id	pointer
-	O
scanner_buffer	pointer
)	O
;	O
return	O
(	O
struct	O
token	struct
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
;	O
}	O
static	O
unsigned	O
char	O
ctype_lisp	array
[	O
257	int
]	O
=	O
{	O
EF	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
,	O
NM	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
Id	int
,	O
0	int
,	O
Id	int
|	O
NM	int
,	O
Id	int
|	O
NM	int
,	O
I1	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
DG	int
,	O
I1	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
I1	int
,	O
Id	int
|	O
NM	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
I1	int
,	O
0	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
NM	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
,	O
LT	int
|	O
RA	int
,	O
LT	int
,	O
LT	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
I1	int
,	O
0	int
}	O
;	O
static	O
void	O
help_me_lisp	function
(	O
void	O
)	O
{	O
printf	function
(	O
_	O
(	O
"Lisp language:\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
*	O
parse_args_lisp	function
(	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
argc	int
)	O
{	O
return	O
NULL	O
;	O
}	O
static	O
struct	O
token	struct
*	O
get_token_lisp	function
(	O
FILE	struct
*	O
in_FILE	pointer
,	O
void	O
const	O
*	O
args	pointer
,	O
int	O
*	O
flags	pointer
)	O
{	O
unsigned	O
char	O
const	O
*	O
rct	pointer
=	O
&	O
ctype_lisp	array
[	O
1	int
]	O
;	O
unsigned	O
char	O
*	O
id	pointer
=	O
scanner_buffer	pointer
;	O
int	O
c	int
;	O
obstack_blank	O
(	O
&	O
tokens_obstack	struct
,	O
OFFSETOF_TOKEN_NAME	O
)	O
;	O
top	O
:	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
recheck	O
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
EOF	O
:	O
obstack_free	function
(	O
&	O
tokens_obstack	struct
,	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
)	O
;	O
return	O
0	int
;	O
case	O
'('	O
:	O
case	O
')'	O
:	O
case	O
'\''	O
:	O
case	O
'`'	O
:	O
goto	O
top	O
;	O
case	O
','	O
:	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'@'	O
)	O
goto	O
top	O
;	O
goto	O
recheck	O
;	O
case	O
';'	O
:	O
do	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
}	O
while	O
(	O
(	O
c	int
!=	O
EOF	O
)	O
&&	O
(	O
c	int
!=	O
'\n'	O
)	O
)	O
;	O
goto	O
top	O
;	O
case	O
'"'	O
:	O
string	O
:	O
do	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
goto	O
string	O
;	O
}	O
}	O
while	O
(	O
(	O
c	int
!=	O
EOF	O
)	O
&&	O
(	O
c	int
!=	O
'"'	O
)	O
)	O
;	O
goto	O
top	O
;	O
case	O
'?'	O
:	O
cconstant	O
:	O
do	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
goto	O
cconstant	O
;	O
}	O
}	O
while	O
(	O
c	int
!=	O
EOF	O
&&	O
is_IDENT	O
(	O
c	int
)	O
)	O
;	O
goto	O
top	O
;	O
case	O
'.'	O
:	O
case	O
'+'	O
:	O
case	O
'-'	O
:	O
id	pointer
=	O
scanner_buffer	pointer
;	O
*	O
id	pointer
++	O
=	O
c	int
;	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
is_DIGIT	O
(	O
c	int
)	O
||	O
(	O
scanner_buffer	pointer
[	O
0	int
]	O
!=	O
'.'	O
&&	O
(	O
c	int
==	O
'.'	O
||	O
c	int
==	O
'i'	O
||	O
c	int
==	O
'I'	O
)	O
)	O
)	O
goto	O
number	O
;	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	function
(	O
c	int
,	O
in_FILE	pointer
)	O
;	O
goto	O
ident	O
;	O
case	O
'#'	O
:	O
id	pointer
=	O
scanner_buffer	pointer
;	O
*	O
id	pointer
++	O
=	O
c	int
;	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
goto	O
top	O
;	O
else	O
if	O
(	O
is_RADIX	O
(	O
c	int
)	O
)	O
goto	O
number	O
;	O
else	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
*	O
id	pointer
++	O
=	O
c	int
;	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
*	O
id	pointer
++	O
=	O
c	int
;	O
if	O
(	O
is_LETTER	O
(	O
c	int
)	O
)	O
{	O
while	O
(	O
is_LETTER	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	function
(	O
c	int
,	O
in_FILE	pointer
)	O
;	O
}	O
*	O
flags	pointer
=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct
,	O
scanner_buffer	pointer
,	O
id	pointer
-	O
scanner_buffer	pointer
)	O
;	O
return	O
(	O
struct	O
token	struct
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'('	O
)	O
goto	O
top	O
;	O
else	O
if	O
(	O
c	int
==	O
'"'	O
)	O
goto	O
string	O
;	O
else	O
if	O
(	O
c	int
==	O
'!'	O
)	O
{	O
while	O
(	O
is_LETTER	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	function
(	O
c	int
,	O
in_FILE	pointer
)	O
;	O
*	O
flags	pointer
=	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct
,	O
scanner_buffer	pointer
,	O
id	pointer
-	O
scanner_buffer	pointer
)	O
;	O
return	O
(	O
struct	O
token	struct
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'|'	O
)	O
{	O
do	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
c	int
==	O
'|'	O
)	O
{	O
while	O
(	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
==	O
'|'	O
)	O
;	O
if	O
(	O
c	int
==	O
'#'	O
)	O
break	O
;	O
}	O
}	O
while	O
(	O
c	int
!=	O
EOF	O
)	O
;	O
goto	O
top	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'@'	O
)	O
{	O
do	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
}	O
while	O
(	O
(	O
c	int
!=	O
EOF	O
)	O
&&	O
(	O
c	int
!=	O
'\037'	O
)	O
)	O
;	O
goto	O
top	O
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'['	O
)	O
goto	O
top	O
;	O
goto	O
top	O
;	O
case	O
'['	O
:	O
case	O
']'	O
:	O
goto	O
top	O
;	O
default	O
:	O
if	O
(	O
is_IDENT1	O
(	O
c	int
)	O
)	O
{	O
id	pointer
=	O
scanner_buffer	pointer
;	O
*	O
id	pointer
++	O
=	O
c	int
;	O
ident	O
:	O
while	O
(	O
is_IDENT	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
if	O
(	O
c	int
==	O
'['	O
)	O
{	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
;	O
if	O
(	O
c	int
==	O
']'	O
)	O
{	O
*	O
id	pointer
++	O
=	O
'['	O
;	O
*	O
id	pointer
++	O
=	O
']'	O
;	O
goto	O
ident	O
;	O
}	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	function
(	O
c	int
,	O
in_FILE	pointer
)	O
;	O
ungetc	function
(	O
'['	O
,	O
in_FILE	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	function
(	O
c	int
,	O
in_FILE	pointer
)	O
;	O
}	O
*	O
flags	pointer
=	O
TOK_NAME	int
|	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct
,	O
scanner_buffer	pointer
,	O
id	pointer
-	O
scanner_buffer	pointer
)	O
;	O
return	O
(	O
struct	O
token	struct
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
;	O
}	O
else	O
if	O
(	O
is_DIGIT	O
(	O
c	int
)	O
)	O
{	O
id	pointer
=	O
scanner_buffer	pointer
;	O
number	O
:	O
*	O
id	pointer
++	O
=	O
c	int
;	O
while	O
(	O
is_NUMBER	O
(	O
c	int
=	O
getc	function
(	O
in_FILE	pointer
)	O
)	O
)	O
*	O
id	pointer
++	O
=	O
c	int
;	O
if	O
(	O
c	int
!=	O
EOF	O
)	O
ungetc	function
(	O
c	int
,	O
in_FILE	pointer
)	O
;	O
*	O
flags	pointer
=	O
TOK_NUMBER	int
|	O
TOK_LITERAL	int
;	O
obstack_grow0	O
(	O
&	O
tokens_obstack	struct
,	O
scanner_buffer	pointer
,	O
id	pointer
-	O
scanner_buffer	pointer
)	O
;	O
return	O
(	O
struct	O
token	struct
*	O
)	O
obstack_finish	O
(	O
&	O
tokens_obstack	struct
)	O
;	O
}	O
}	O
goto	O
top	O
;	O
}	O
