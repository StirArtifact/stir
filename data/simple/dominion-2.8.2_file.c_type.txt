extern	O
int	O
debug	int
,	O
compressed_world	int
,	O
slow_flag	int
;	O
extern	O
struct	O
race_list	struct
*	O
races	pointer
;	O
extern	O
Suser	struct
user	struct
;	O
void	O
read_world	function
(	O
Sworld	struct
*	O
wp	pointer
,	O
char	O
fname	array
[	O
]	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
FILE	struct
*	O
fp	pointer
,	O
*	O
fopen	function
(	O
)	O
;	O
char	O
cmd	array
[	O
200	int
]	O
;	O
load_world_options	function
(	O
)	O
;	O
compressed_world	int
=	O
check_compressed_world	function
(	O
fname	array
)	O
;	O
if	O
(	O
compressed_world	int
)	O
{	O
sprintf	function
(	O
cmd	array
,	O
"zcat %s"	pointer
,	O
fname	array
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
popen	function
(	O
cmd	array
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
printf	function
(	O
"\r\ncannot open pipe <%s> for reading\r\n"	pointer
,	O
cmd	array
)	O
;	O
clean_exit	function
(	O
1	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
fname	array
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
printf	function
(	O
"\r\ncannot open file <%s> for reading\r\n"	pointer
,	O
fname	array
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
printf	function
(	O
"Reading world data file '%s'"	pointer
,	O
fname	array
)	O
;	O
read_int	function
(	O
fp	pointer
,	O
&	O
wp	pointer
->	O
turn	int
)	O
;	O
read_int	function
(	O
fp	pointer
,	O
&	O
wp	pointer
->	O
xmax	int
)	O
;	O
read_int	function
(	O
fp	pointer
,	O
&	O
wp	pointer
->	O
ymax	int
)	O
;	O
if	O
(	O
debug	int
>=	O
3	int
)	O
{	O
printf	function
(	O
"File position is %ld\n"	pointer
,	O
ftell	function
(	O
fp	pointer
)	O
)	O
;	O
}	O
if	O
(	O
debug	int
>=	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"World size is %dx%d\n"	pointer
,	O
wp	pointer
->	O
xmax	int
,	O
wp	pointer
->	O
ymax	int
)	O
;	O
}	O
wp	pointer
->	O
map	pointer
=	O
(	O
Ssector	struct
*	O
*	O
)	O
malloc	function
(	O
wp	pointer
->	O
xmax	int
*	O
sizeof	O
(	O
Ssector	struct
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
wp	pointer
->	O
xmax	int
;	O
++	O
i	int
)	O
{	O
wp	pointer
->	O
map	pointer
[	O
i	int
]	O
=	O
(	O
Ssector	struct
*	O
)	O
malloc	function
(	O
wp	pointer
->	O
ymax	int
*	O
sizeof	O
(	O
Ssector	struct
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
wp	pointer
->	O
xmax	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
wp	pointer
->	O
ymax	int
;	O
++	O
j	int
)	O
{	O
if	O
(	O
debug	int
>=	O
3	int
)	O
{	O
printf	function
(	O
"File position is %ld\n"	pointer
,	O
ftell	function
(	O
fp	pointer
)	O
)	O
;	O
}	O
read_sector	function
(	O
fp	pointer
,	O
&	O
wp	pointer
->	O
map	pointer
[	O
i	int
]	O
[	O
j	int
]	O
)	O
;	O
wp	pointer
->	O
map	pointer
[	O
i	int
]	O
[	O
j	int
]	O
.	O
alist	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
i	int
%	O
(	O
wp	pointer
->	O
xmax	int
/	O
8	int
)	O
==	O
0	int
)	O
{	O
printf	function
(	O
"."	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
if	O
(	O
slow_flag	int
&&	O
(	O
(	O
4	int
*	O
i	int
)	O
%	O
wp	pointer
->	O
xmax	int
<	O
4	int
)	O
)	O
{	O
printf	function
(	O
"[p]"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
debug	int
>=	O
3	int
)	O
{	O
printf	function
(	O
"File position is %ld\n"	pointer
,	O
ftell	function
(	O
fp	pointer
)	O
)	O
;	O
}	O
read_geo	function
(	O
fp	pointer
,	O
&	O
wp	pointer
->	O
geo	struct
)	O
;	O
printf	function
(	O
"."	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
read_int	function
(	O
fp	pointer
,	O
&	O
wp	pointer
->	O
n_nations	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\nReading in %d nations"	pointer
,	O
wp	pointer
->	O
n_nations	int
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
wp	pointer
->	O
nations	pointer
=	O
(	O
Snation	struct
*	O
)	O
malloc	function
(	O
wp	pointer
->	O
n_nations	int
*	O
sizeof	O
(	O
Snation	struct
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
wp	pointer
->	O
n_nations	int
;	O
++	O
i	int
)	O
{	O
read_nation	function
(	O
&	O
wp	pointer
->	O
nations	pointer
[	O
i	int
]	O
,	O
fp	pointer
,	O
wp	pointer
)	O
;	O
load_options	function
(	O
&	O
wp	pointer
->	O
nations	pointer
[	O
i	int
]	O
)	O
;	O
load_bonds	function
(	O
&	O
wp	pointer
->	O
nations	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
slow_flag	int
&&	O
(	O
(	O
4	int
*	O
i	int
)	O
%	O
wp	pointer
->	O
n_nations	int
<	O
4	int
)	O
)	O
{	O
printf	function
(	O
"[p]"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"."	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
if	O
(	O
compressed_world	int
)	O
{	O
pclose	function
(	O
fp	pointer
)	O
;	O
}	O
else	O
{	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
init_wrap	function
(	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
void	O
write_world	function
(	O
Sworld	struct
*	O
wp	pointer
,	O
char	O
fname	array
[	O
]	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
FILE	struct
*	O
fp	pointer
,	O
*	O
fopen	function
(	O
)	O
;	O
char	O
cmd	array
[	O
200	int
]	O
;	O
if	O
(	O
compressed_world	int
)	O
{	O
sprintf	function
(	O
cmd	array
,	O
"gzip > %s.gz"	pointer
,	O
fname	array
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
popen	function
(	O
cmd	array
,	O
"w"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
printf	function
(	O
"\r\ncannot open pipe <%s> for writing\r\n"	pointer
,	O
cmd	array
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
fname	array
,	O
"w"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
printf	function
(	O
"cannot open file <%s> for writing\n"	pointer
,	O
fname	array
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
critical	function
(	O
)	O
;	O
write_int	function
(	O
fp	pointer
,	O
wp	pointer
->	O
turn	int
)	O
;	O
write_int	function
(	O
fp	pointer
,	O
wp	pointer
->	O
xmax	int
)	O
;	O
write_int	function
(	O
fp	pointer
,	O
wp	pointer
->	O
ymax	int
)	O
;	O
if	O
(	O
debug	int
>=	O
3	int
)	O
{	O
printf	function
(	O
"File position is %ld\n"	pointer
,	O
ftell	function
(	O
fp	pointer
)	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
wp	pointer
->	O
xmax	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
wp	pointer
->	O
ymax	int
;	O
++	O
j	int
)	O
{	O
write_sector	function
(	O
fp	pointer
,	O
&	O
wp	pointer
->	O
map	pointer
[	O
i	int
]	O
[	O
j	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
debug	int
>=	O
3	int
)	O
{	O
printf	function
(	O
"File position is %ld\n"	pointer
,	O
ftell	function
(	O
fp	pointer
)	O
)	O
;	O
}	O
write_geo	function
(	O
fp	pointer
,	O
&	O
(	O
wp	pointer
->	O
geo	struct
)	O
)	O
;	O
printf	function
(	O
"writing out %d nation%c\n"	pointer
,	O
wp	pointer
->	O
n_nations	int
,	O
wp	pointer
->	O
n_nations	int
==	O
1	int
?	O
' '	O
:	O
's'	O
)	O
;	O
write_int	function
(	O
fp	pointer
,	O
wp	pointer
->	O
n_nations	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
wp	pointer
->	O
n_nations	int
;	O
++	O
i	int
)	O
{	O
write_nation	function
(	O
&	O
wp	pointer
->	O
nations	pointer
[	O
i	int
]	O
,	O
fp	pointer
)	O
;	O
if	O
(	O
debug	int
)	O
{	O
putchar	function
(	O
'.'	O
)	O
;	O
}	O
}	O
if	O
(	O
compressed_world	int
)	O
{	O
pclose	function
(	O
fp	pointer
)	O
;	O
}	O
else	O
{	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
noncritical	function
(	O
)	O
;	O
}	O
void	O
write_nation	function
(	O
Snation	struct
*	O
np	pointer
,	O
FILE	struct
*	O
fp	pointer
)	O
{	O
int	O
i	int
;	O
Sarmy	struct
*	O
ap	pointer
;	O
struct	O
pt_list	struct
*	O
pp	pointer
;	O
write_nation_struct	function
(	O
fp	pointer
,	O
np	pointer
)	O
;	O
ap	pointer
=	O
np	pointer
->	O
armies	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
np	pointer
->	O
n_armies	int
;	O
++	O
i	int
)	O
{	O
write_army	function
(	O
fp	pointer
,	O
ap	pointer
)	O
;	O
if	O
(	O
debug	int
>=	O
3	int
)	O
{	O
putchar	function
(	O
'a'	O
)	O
;	O
}	O
ap	pointer
=	O
ap	pointer
->	O
next	pointer
;	O
}	O
pp	pointer
=	O
np	pointer
->	O
ptlist	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
np	pointer
->	O
n_sects	int
;	O
++	O
i	int
)	O
{	O
write_point_list	function
(	O
fp	pointer
,	O
pp	pointer
)	O
;	O
if	O
(	O
debug	int
>=	O
3	int
)	O
{	O
putchar	function
(	O
's'	O
)	O
;	O
}	O
pp	pointer
=	O
pp	pointer
->	O
next	pointer
;	O
}	O
}	O
void	O
read_nation	function
(	O
Snation	struct
*	O
np	pointer
,	O
FILE	struct
*	O
fp	pointer
,	O
Sworld	struct
*	O
wp	pointer
)	O
{	O
int	O
i	int
,	O
x	int
,	O
y	int
;	O
Ssector	struct
*	O
sp	int
;	O
Sarmy	struct
army	int
;	O
struct	O
pt_list	struct
*	O
pp	pointer
;	O
read_nation_struct	function
(	O
fp	pointer
,	O
np	pointer
)	O
;	O
np	pointer
->	O
cur_mag_r_d	int
=	O
np	pointer
->	O
cur_mag_r_d_jewels	int
=	O
0	int
;	O
np	pointer
->	O
cur_tech_r_d	int
=	O
np	pointer
->	O
cur_tech_r_d_metal	int
=	O
0	int
;	O
np	pointer
->	O
cur_spy_r_d	int
=	O
0	int
;	O
np	pointer
->	O
armies	pointer
=	O
NULL	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
np	pointer
->	O
n_armies	int
;	O
++	O
i	int
)	O
{	O
read_army	function
(	O
fp	pointer
,	O
&	O
army	int
)	O
;	O
army	int
.	O
next	pointer
=	O
NULL	O
;	O
x	int
=	O
army	int
.	O
pos	struct
.	O
x	int
;	O
y	int
=	O
army	int
.	O
pos	struct
.	O
y	int
;	O
sp	int
=	O
&	O
(	O
wp	pointer
->	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
)	O
;	O
if	O
(	O
i	int
==	O
0	int
)	O
{	O
np	pointer
->	O
armies	pointer
=	O
(	O
Sarmy	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
Sarmy	struct
)	O
)	O
;	O
*	O
(	O
np	pointer
->	O
armies	pointer
)	O
=	O
army	int
;	O
np	pointer
->	O
armies	pointer
->	O
next	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
insert_army_nation	function
(	O
np	pointer
,	O
&	O
army	int
,	O
army	int
.	O
id	short
)	O
;	O
}	O
insert_army_sector	function
(	O
sp	int
,	O
&	O
army	int
)	O
;	O
}	O
if	O
(	O
np	pointer
->	O
n_sects	int
>	O
0	int
)	O
{	O
np	pointer
->	O
ptlist	pointer
=	O
(	O
struct	O
pt_list	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
pt_list	struct
)	O
)	O
;	O
read_point_list	function
(	O
fp	pointer
,	O
np	pointer
->	O
ptlist	pointer
)	O
;	O
np	pointer
->	O
ptlist	pointer
->	O
next	pointer
=	O
NULL	O
;	O
pp	pointer
=	O
np	pointer
->	O
ptlist	pointer
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
np	pointer
->	O
n_sects	int
;	O
++	O
i	int
)	O
{	O
pp	pointer
->	O
next	pointer
=	O
(	O
struct	O
pt_list	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
pt_list	struct
)	O
)	O
;	O
read_point_list	function
(	O
fp	pointer
,	O
pp	pointer
->	O
next	pointer
)	O
;	O
pp	pointer
=	O
pp	pointer
->	O
next	pointer
;	O
pp	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
debug	int
>=	O
3	int
)	O
{	O
putchar	function
(	O
's'	O
)	O
;	O
}	O
}	O
}	O
void	O
read_races	function
(	O
)	O
{	O
FILE	struct
*	O
fp	pointer
,	O
*	O
fopen	function
(	O
)	O
;	O
char	O
s	array
[	O
200	int
]	O
;	O
int	O
i	int
,	O
n_races	int
;	O
Srace	struct
tmp_race	struct
;	O
struct	O
race_list	struct
*	O
rlp	pointer
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
RACES_FILE	pointer
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
printf	function
(	O
"cannot open races file.  you might have the wrong directory..\n"	pointer
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
races	pointer
=	O
(	O
struct	O
race_list	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
race_list	struct
)	O
)	O
;	O
strcpy	function
(	O
races	pointer
->	O
race	struct
.	O
name	array
,	O
"Master"	pointer
)	O
;	O
races	pointer
->	O
race	struct
.	O
mark	char
=	O
'C'	O
;	O
races	pointer
->	O
race	struct
.	O
strength	int
=	O
0	int
;	O
races	pointer
->	O
race	struct
.	O
repro	int
=	O
0	int
;	O
races	pointer
->	O
race	struct
.	O
mortality	int
=	O
0	int
;	O
races	pointer
->	O
race	struct
.	O
intel	int
=	O
0	int
;	O
races	pointer
->	O
race	struct
.	O
speed	int
=	O
0	int
;	O
races	pointer
->	O
race	struct
.	O
stealth	int
=	O
0	int
;	O
races	pointer
->	O
race	struct
.	O
pref_alt	int
=	O
0	int
;	O
races	pointer
->	O
race	struct
.	O
pref_terrain	int
=	O
0	int
;	O
races	pointer
->	O
race	struct
.	O
pref_climate	int
=	O
0	int
;	O
races	pointer
->	O
race	struct
.	O
mag_apt	int
=	O
0	int
;	O
races	pointer
->	O
race	struct
.	O
farming	int
=	O
0	int
;	O
races	pointer
->	O
race	struct
.	O
mining	int
=	O
0	int
;	O
races	pointer
->	O
next	pointer
=	O
NULL	O
;	O
rlp	pointer
=	O
races	pointer
;	O
fgets	function
(	O
s	array
,	O
180	int
,	O
fp	pointer
)	O
;	O
while	O
(	O
s	array
[	O
0	int
]	O
==	O
'#'	O
)	O
{	O
fgets	function
(	O
s	array
,	O
180	int
,	O
fp	pointer
)	O
;	O
}	O
sscanf	function
(	O
s	array
,	O
"%d"	pointer
,	O
&	O
n_races	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n_races	int
;	O
)	O
{	O
fgets	function
(	O
s	array
,	O
180	int
,	O
fp	pointer
)	O
;	O
s	array
[	O
strlen	function
(	O
s	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
s	array
[	O
0	int
]	O
!=	O
'#'	O
)	O
{	O
++	O
i	int
;	O
sscanf	function
(	O
s	array
,	O
"%s : %1s : %d : %d : %d : %d : %d : %d : %d : %d : %d : %d : %d : %d"	pointer
,	O
tmp_race	struct
.	O
name	array
,	O
&	O
tmp_race	struct
.	O
mark	char
,	O
&	O
tmp_race	struct
.	O
strength	int
,	O
&	O
tmp_race	struct
.	O
repro	int
,	O
&	O
tmp_race	struct
.	O
mortality	int
,	O
&	O
tmp_race	struct
.	O
intel	int
,	O
&	O
tmp_race	struct
.	O
speed	int
,	O
&	O
tmp_race	struct
.	O
stealth	int
,	O
&	O
tmp_race	struct
.	O
pref_alt	int
,	O
&	O
tmp_race	struct
.	O
pref_terrain	int
,	O
&	O
tmp_race	struct
.	O
pref_climate	int
,	O
&	O
tmp_race	struct
.	O
mag_apt	int
,	O
&	O
tmp_race	struct
.	O
farming	int
,	O
&	O
tmp_race	struct
.	O
mining	int
)	O
;	O
rlp	pointer
->	O
next	pointer
=	O
(	O
struct	O
race_list	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
struct	O
race_list	struct
)	O
)	O
;	O
rlp	pointer
=	O
rlp	pointer
->	O
next	pointer
;	O
rlp	pointer
->	O
race	struct
=	O
tmp_race	struct
;	O
rlp	pointer
->	O
next	pointer
=	O
NULL	O
;	O
}	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
int	O
check_compressed_world	function
(	O
char	O
fname	array
[	O
]	O
)	O
{	O
char	O
Zname	array
[	O
200	int
]	O
;	O
FILE	struct
*	O
fopen	function
(	O
)	O
,	O
*	O
fp	pointer
;	O
strcpy	function
(	O
Zname	array
,	O
fname	array
)	O
;	O
strcat	function
(	O
Zname	array
,	O
".gz"	pointer
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
Zname	array
,	O
"r"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
set_master_lock	function
(	O
)	O
{	O
close	function
(	O
creat	function
(	O
"lock.master"	pointer
,	O
0600	int
)	O
)	O
;	O
}	O
void	O
set_lock	function
(	O
int	O
id	short
)	O
{	O
char	O
fname	array
[	O
PATHLEN	int
]	O
,	O
host	array
[	O
NAMELEN	int
]	O
;	O
FILE	struct
*	O
fp	pointer
,	O
*	O
fopen	function
(	O
)	O
;	O
extern	O
Sworld	struct
world	struct
;	O
extern	O
int	O
ruid	int
;	O
long	O
now_secs	long
;	O
sprintf	function
(	O
fname	array
,	O
"lock.%d"	pointer
,	O
id	short
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
fname	array
,	O
"w"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
printf	function
(	O
"cannot open the lock file file <%s> for writing\n"	pointer
,	O
fname	array
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
now_secs	long
=	O
time	function
(	O
0L	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"Nation %s; real uid %d; pid: %ld; time: %s"	pointer
,	O
world	struct
.	O
nations	pointer
[	O
id	short
]	O
.	O
name	array
,	O
ruid	int
,	O
(	O
long	O
int	O
)	O
getpid	function
(	O
)	O
,	O
asctime	function
(	O
localtime	function
(	O
&	O
now_secs	long
)	O
)	O
)	O
;	O
gethostname	function
(	O
host	array
,	O
NAMELEN	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"machine: %s\n"	pointer
,	O
host	array
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
void	O
del_lock	function
(	O
int	O
id	short
)	O
{	O
char	O
fname	array
[	O
PATHLEN	int
]	O
;	O
sprintf	function
(	O
fname	array
,	O
"lock.%d"	pointer
,	O
id	short
)	O
;	O
unlink	function
(	O
fname	array
)	O
;	O
}	O
void	O
del_master_lock	function
(	O
)	O
{	O
unlink	function
(	O
"lock.master"	pointer
)	O
;	O
}	O
FILE	struct
*	O
is_locked	function
(	O
id	short
)	O
int	O
id	short
;	O
{	O
FILE	struct
*	O
fopen	function
(	O
)	O
;	O
char	O
fname	array
[	O
PATHLEN	int
]	O
;	O
sprintf	function
(	O
fname	array
,	O
"lock.%d"	pointer
,	O
id	short
)	O
;	O
return	O
fopen	function
(	O
fname	array
,	O
"r"	pointer
)	O
;	O
}	O
int	O
is_any_lock	function
(	O
)	O
{	O
int	O
i	int
;	O
FILE	struct
*	O
fp	pointer
;	O
extern	O
Sworld	struct
world	struct
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
world	struct
.	O
n_nations	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
(	O
fp	pointer
=	O
is_locked	function
(	O
i	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
is_master_lock	function
(	O
)	O
{	O
FILE	struct
*	O
fp	pointer
,	O
*	O
fopen	function
(	O
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
"lock.master"	pointer
,	O
"r"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
set_update_time	function
(	O
)	O
{	O
char	O
fname	array
[	O
PATHLEN	int
]	O
;	O
FILE	struct
*	O
fp	pointer
,	O
*	O
fopen	function
(	O
)	O
;	O
long	O
now_secs	long
;	O
sprintf	function
(	O
fname	array
,	O
UPDATE_FILE	pointer
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
fname	array
,	O
"w"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
printf	function
(	O
"cannot open the update time file <%s> for writing\n"	pointer
,	O
fname	array
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
now_secs	long
=	O
time	function
(	O
0L	int
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%ld; time: %s"	pointer
,	O
now_secs	long
,	O
ctime	function
(	O
&	O
now_secs	long
)	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
char	O
*	O
get_update_time	function
(	O
)	O
{	O
char	O
fname	array
[	O
PATHLEN	int
]	O
;	O
FILE	struct
*	O
fp	pointer
,	O
*	O
fopen	function
(	O
)	O
;	O
char	O
s	array
[	O
300	int
]	O
,	O
*	O
rtvl	pointer
,	O
*	O
tmp	pointer
;	O
sprintf	function
(	O
fname	array
,	O
UPDATE_FILE	pointer
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
fname	array
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
set_update_time	function
(	O
)	O
;	O
}	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
fname	array
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
printf	function
(	O
"cannot open update time file <%s> for reading\n"	pointer
,	O
fname	array
)	O
;	O
clean_exit	function
(	O
1	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
fgets	function
(	O
s	array
,	O
299	int
,	O
fp	pointer
)	O
;	O
if	O
(	O
(	O
rtvl	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
strlen	function
(	O
s	array
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
mem_error	function
(	O
)	O
;	O
}	O
tmp	pointer
=	O
strchr	function
(	O
s	array
,	O
(	O
int	O
)	O
':'	O
)	O
;	O
strcpy	function
(	O
rtvl	pointer
,	O
(	O
tmp	pointer
+	O
1	int
)	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
return	O
rtvl	pointer
;	O
}	O
void	O
mem_error	function
(	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: Couldn't allocate requested memory"	pointer
)	O
;	O
cleanup	function
(	O
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
void	O
load_options	function
(	O
Snation	struct
*	O
np	pointer
)	O
{	O
char	O
opt_file	array
[	O
PATHLEN	int
]	O
,	O
opt_line	array
[	O
100	int
]	O
;	O
FILE	struct
*	O
fopt	pointer
;	O
int	O
len	int
;	O
init_options	function
(	O
np	pointer
)	O
;	O
sprintf	function
(	O
opt_file	array
,	O
"%s/opt.%d"	pointer
,	O
OPT_DIR	pointer
,	O
np	pointer
->	O
id	short
)	O
;	O
if	O
(	O
(	O
fopt	pointer
=	O
fopen	function
(	O
opt_file	array
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
save_options	function
(	O
np	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
fgets	function
(	O
opt_line	array
,	O
99	int
,	O
fopt	pointer
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"EXPERT_MODE: "	pointer
)	O
)	O
{	O
np	pointer
->	O
opts	pointer
->	O
expert_mode	int
=	O
atoi	function
(	O
&	O
(	O
opt_line	array
[	O
13	int
]	O
)	O
)	O
;	O
user	struct
.	O
xmode	int
=	O
np	pointer
->	O
opts	pointer
->	O
expert_mode	int
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"CIV_MOVEMODE: "	pointer
)	O
)	O
{	O
np	pointer
->	O
opts	pointer
->	O
civ_movemode	int
=	O
atoi	function
(	O
&	O
(	O
opt_line	array
[	O
14	int
]	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"NEWS_FORWARD: "	pointer
)	O
)	O
{	O
if	O
(	O
opt_line	array
[	O
14	int
]	O
==	O
'\n'	O
)	O
{	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
=	O
NULL	O
;	O
continue	O
;	O
}	O
len	int
=	O
strlen	function
(	O
&	O
(	O
opt_line	array
[	O
14	int
]	O
)	O
)	O
;	O
if	O
(	O
(	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
len	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
mem_error	function
(	O
)	O
;	O
}	O
strcpy	function
(	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
,	O
&	O
(	O
opt_line	array
[	O
14	int
]	O
)	O
)	O
;	O
len	int
=	O
strlen	function
(	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
)	O
;	O
if	O
(	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"MAIL_FORWARD: "	pointer
)	O
)	O
{	O
if	O
(	O
opt_line	array
[	O
14	int
]	O
==	O
'\n'	O
)	O
{	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
=	O
NULL	O
;	O
continue	O
;	O
}	O
len	int
=	O
strlen	function
(	O
&	O
(	O
opt_line	array
[	O
14	int
]	O
)	O
)	O
;	O
if	O
(	O
(	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
len	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
mem_error	function
(	O
)	O
;	O
}	O
strcpy	function
(	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
,	O
&	O
(	O
opt_line	array
[	O
14	int
]	O
)	O
)	O
;	O
len	int
=	O
strlen	function
(	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
)	O
;	O
if	O
(	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"MAIL_READER: "	pointer
)	O
)	O
{	O
if	O
(	O
opt_line	array
[	O
13	int
]	O
==	O
'\n'	O
)	O
{	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
=	O
NULL	O
;	O
continue	O
;	O
}	O
len	int
=	O
strlen	function
(	O
&	O
(	O
opt_line	array
[	O
13	int
]	O
)	O
)	O
;	O
if	O
(	O
(	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
len	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
mem_error	function
(	O
)	O
;	O
}	O
strcpy	function
(	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
,	O
&	O
(	O
opt_line	array
[	O
13	int
]	O
)	O
)	O
;	O
len	int
=	O
strlen	function
(	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
)	O
;	O
if	O
(	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"OPTS_EDITOR: "	pointer
)	O
)	O
{	O
if	O
(	O
opt_line	array
[	O
13	int
]	O
==	O
'\n'	O
)	O
{	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
=	O
NULL	O
;	O
continue	O
;	O
}	O
len	int
=	O
strlen	function
(	O
&	O
(	O
opt_line	array
[	O
13	int
]	O
)	O
)	O
;	O
if	O
(	O
(	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
len	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
mem_error	function
(	O
)	O
;	O
}	O
strcpy	function
(	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
,	O
&	O
(	O
opt_line	array
[	O
13	int
]	O
)	O
)	O
;	O
len	int
=	O
strlen	function
(	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
)	O
;	O
if	O
(	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: Bad Option %s\n"	pointer
,	O
opt_line	array
)	O
;	O
}	O
}	O
fclose	function
(	O
fopt	pointer
)	O
;	O
}	O
void	O
save_options	function
(	O
Snation	struct
*	O
np	pointer
)	O
{	O
FILE	struct
*	O
fopt	pointer
;	O
char	O
opt_file	array
[	O
PATHLEN	int
]	O
;	O
sprintf	function
(	O
opt_file	array
,	O
"%s/opt.%d"	pointer
,	O
OPT_DIR	pointer
,	O
np	pointer
->	O
id	short
)	O
;	O
if	O
(	O
(	O
fopt	pointer
=	O
fopen	function
(	O
opt_file	array
,	O
"w"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
clean_exit	function
(	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: Cannot Open Options File %s\n"	pointer
,	O
opt_file	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
fprintf	function
(	O
fopt	pointer
,	O
"EXPERT_MODE: %d\n"	pointer
,	O
np	pointer
->	O
opts	pointer
->	O
expert_mode	int
)	O
;	O
fprintf	function
(	O
fopt	pointer
,	O
"CIV_MOVEMODE: %d\n"	pointer
,	O
np	pointer
->	O
opts	pointer
->	O
civ_movemode	int
)	O
;	O
if	O
(	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
fopt	pointer
,	O
"NEWS_FORWARD: \n"	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
fopt	pointer
,	O
"NEWS_FORWARD: %s\n"	pointer
,	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
)	O
;	O
}	O
if	O
(	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
fopt	pointer
,	O
"MAIL_FORWARD: \n"	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
fopt	pointer
,	O
"MAIL_FORWARD: %s\n"	pointer
,	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
)	O
;	O
}	O
if	O
(	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
fopt	pointer
,	O
"MAIL_READER: \n"	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
fopt	pointer
,	O
"MAIL_READER: %s\n"	pointer
,	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
)	O
;	O
}	O
if	O
(	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
fopt	pointer
,	O
"OPTS_EDITOR: \n"	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
fopt	pointer
,	O
"OPTS_EDITOR: %s\n"	pointer
,	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
)	O
;	O
}	O
fclose	function
(	O
fopt	pointer
)	O
;	O
}	O
void	O
init_options	function
(	O
Snation	struct
*	O
np	pointer
)	O
{	O
if	O
(	O
(	O
np	pointer
->	O
opts	pointer
=	O
(	O
Soptions	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
Soptions	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
mem_error	function
(	O
)	O
;	O
}	O
np	pointer
->	O
opts	pointer
->	O
expert_mode	int
=	O
0	int
;	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
=	O
NULL	O
;	O
np	pointer
->	O
opts	pointer
->	O
civ_movemode	int
=	O
2	int
;	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
=	O
NULL	O
;	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
=	O
NULL	O
;	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
=	O
NULL	O
;	O
}	O
int	O
assign_race	function
(	O
Snation	struct
*	O
np	pointer
,	O
char	O
racename	array
[	O
]	O
)	O
{	O
struct	O
race_list	struct
*	O
rlp	pointer
=	O
races	pointer
;	O
while	O
(	O
rlp	pointer
&&	O
(	O
strcmp	function
(	O
rlp	pointer
->	O
race	struct
.	O
name	array
,	O
racename	array
)	O
!=	O
0	int
)	O
)	O
{	O
rlp	pointer
=	O
rlp	pointer
->	O
next	pointer
;	O
}	O
if	O
(	O
!	O
rlp	pointer
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
rlp	pointer
->	O
race	struct
.	O
name	array
,	O
racename	array
)	O
!=	O
0	int
)	O
{	O
return	O
0	int
;	O
}	O
printf	function
(	O
"%s ->> %s\n"	pointer
,	O
np	pointer
->	O
name	array
,	O
rlp	pointer
->	O
race	struct
.	O
name	array
)	O
;	O
np	pointer
->	O
race	struct
=	O
rlp	pointer
->	O
race	struct
;	O
np	pointer
->	O
farm_skill	int
=	O
np	pointer
->	O
race	struct
.	O
farming	int
;	O
np	pointer
->	O
mine_skill	int
=	O
np	pointer
->	O
race	struct
.	O
mining	int
;	O
return	O
1	int
;	O
}	O
int	O
extract_int_opt	function
(	O
string	pointer
)	O
char	O
*	O
string	pointer
;	O
{	O
int	O
rtvl	pointer
=	O
0	int
;	O
char	O
*	O
pos	struct
=	O
strchr	function
(	O
string	pointer
,	O
':'	O
)	O
;	O
pos	struct
++	O
;	O
sscanf	function
(	O
pos	struct
,	O
"%d"	pointer
,	O
&	O
rtvl	pointer
)	O
;	O
return	O
rtvl	pointer
;	O
}	O
double	O
extract_double_opt	function
(	O
string	pointer
)	O
char	O
*	O
string	pointer
;	O
{	O
double	O
rtvl	pointer
=	O
0.0	int
;	O
char	O
*	O
pos	struct
=	O
strchr	function
(	O
string	pointer
,	O
':'	O
)	O
;	O
pos	struct
++	O
;	O
sscanf	function
(	O
pos	struct
,	O
"%lf"	pointer
,	O
&	O
rtvl	pointer
)	O
;	O
return	O
rtvl	pointer
;	O
}	O
void	O
load_world_options	function
(	O
)	O
{	O
char	O
opt_line	array
[	O
200	int
]	O
;	O
FILE	struct
*	O
fopt	pointer
;	O
int	O
did	int
=	O
0	int
;	O
if	O
(	O
debug	int
>=	O
1	int
)	O
{	O
printf	function
(	O
"Checking for world options in %s: "	pointer
,	O
WORLD_OPTIONS	pointer
)	O
;	O
}	O
if	O
(	O
(	O
fopt	pointer
=	O
fopen	function
(	O
WORLD_OPTIONS	pointer
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
debug	int
>=	O
1	int
)	O
{	O
printf	function
(	O
"not found\n"	pointer
)	O
;	O
}	O
return	O
;	O
}	O
if	O
(	O
debug	int
>=	O
1	int
)	O
{	O
printf	function
(	O
"found!\n"	pointer
)	O
;	O
}	O
while	O
(	O
fgets	function
(	O
opt_line	array
,	O
199	int
,	O
fopt	pointer
)	O
)	O
{	O
switch	O
(	O
opt_line	array
[	O
0	int
]	O
)	O
{	O
case	O
'A'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"ARMY_SIGHT"	pointer
)	O
)	O
{	O
ARMY_SIGHT	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"ARMY_OVERHEAD"	pointer
)	O
)	O
{	O
ARMY_OVERHEAD	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'B'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"BUBBLE_COST_METAL"	pointer
)	O
)	O
{	O
BUBBLE_COST_METAL	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"BUBBLE_COST"	pointer
)	O
)	O
{	O
BUBBLE_COST	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"BATTLE_INTENSITY"	pointer
)	O
)	O
{	O
BATTLE_INTENSITY	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'C'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"CARAVAN_CAPACITY"	pointer
)	O
)	O
{	O
CARAVAN_CAPACITY	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'D'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"DISBAND_RETURN"	pointer
)	O
)	O
{	O
DISBAND_RETURN	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"DESTROY_METAL_REC"	pointer
)	O
)	O
{	O
DESTROY_METAL_REC	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"DESTROY_MONEY_COST"	pointer
)	O
)	O
{	O
DESTROY_MONEY_COST	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'E'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"EAT"	pointer
)	O
)	O
{	O
EAT	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'F'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"FORT_COST_MONEY"	pointer
)	O
)	O
{	O
FORT_COST_MONEY	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"FORT_COST_METAL"	pointer
)	O
)	O
{	O
FORT_COST_METAL	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"FORT_BONUS_INCREASE"	pointer
)	O
)	O
{	O
FORT_BONUS_INCREASE	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"FOOD_WEIGHT"	pointer
)	O
)	O
{	O
FOOD_WEIGHT	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"FOOD_PROD"	pointer
)	O
)	O
{	O
FOOD_PROD	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'G'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"GEOGRAPHY_BONUS"	pointer
)	O
)	O
{	O
GEOGRAPHY_BONUS	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'H'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"HOSPITAL_MAINT_COST"	pointer
)	O
)	O
{	O
HOSPITAL_MAINT_COST	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'I'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"INITIATION_JEWELS"	pointer
)	O
)	O
{	O
INITIATION_JEWELS	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'J'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"JEWEL_WEIGHT"	pointer
)	O
)	O
{	O
JEWEL_WEIGHT	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'L'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"LAND_SIGHT"	pointer
)	O
)	O
{	O
LAND_SIGHT	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'M'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"MEN_PER_MACHINE"	pointer
)	O
)	O
{	O
MEN_PER_MACHINE	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"MAGE_MOVE_FACTOR"	pointer
)	O
)	O
{	O
MAGE_MOVE_FACTOR	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"MAGE_JEWELS_MAINT"	pointer
)	O
)	O
{	O
MAGE_JEWELS_MAINT	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"MAG_JEWEL_FACTOR"	pointer
)	O
)	O
{	O
MAG_JEWEL_FACTOR	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"MAG_MONEY_FACTOR"	pointer
)	O
)	O
{	O
MAG_MONEY_FACTOR	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"METAL_WEIGHT"	pointer
)	O
)	O
{	O
METAL_WEIGHT	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"MONEY_WEIGHT"	pointer
)	O
)	O
{	O
MONEY_WEIGHT	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"MIN_STOP_CIV"	pointer
)	O
)	O
{	O
MIN_STOP_CIV	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'O'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"OCCUPYING_SOLDIERS"	pointer
)	O
)	O
{	O
OCCUPYING_SOLDIERS	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'R'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"REFINERY_FACT"	pointer
)	O
)	O
{	O
REFINERY_FACT	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"ROADS_COST_METAL"	pointer
)	O
)	O
{	O
ROADS_COST_METAL	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"ROADS_COST_MONEY"	pointer
)	O
)	O
{	O
ROADS_COST_MONEY	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"REFINE_COST_METAL"	pointer
)	O
)	O
{	O
REFINE_COST_METAL	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"REFINE_COST"	pointer
)	O
)	O
{	O
REFINE_COST	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'S'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"SORCERER_MOVE_FACTOR"	pointer
)	O
)	O
{	O
SORCERER_MOVE_FACTOR	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"SPY_SECRECY_FACTOR"	pointer
)	O
)	O
{	O
SPY_SECRECY_FACTOR	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"SPY_MONEY_FACTOR"	pointer
)	O
)	O
{	O
SPY_MONEY_FACTOR	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"SOLD_EAT_FACTOR"	pointer
)	O
)	O
{	O
SOLD_EAT_FACTOR	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"SACRIFICED_FRACT"	pointer
)	O
)	O
{	O
SACRIFICED_FRACT	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'T'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"TECH_METAL_FACTOR"	pointer
)	O
)	O
{	O
TECH_METAL_FACTOR	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"TECH_MONEY_FACTOR"	pointer
)	O
)	O
{	O
TECH_MONEY_FACTOR	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'U'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"UNIV_MAINT_COST"	pointer
)	O
)	O
{	O
UNIV_MAINT_COST	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'V'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"VAMPIRE_FRACT"	pointer
)	O
)	O
{	O
VAMPIRE_FRACT	double
=	O
extract_double_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
'W'	O
:	O
{	O
if	O
(	O
is_option	O
(	O
opt_line	array
,	O
"WATER_SIGHT"	pointer
)	O
)	O
{	O
WATER_SIGHT	int
=	O
extract_int_opt	function
(	O
opt_line	array
)	O
;	O
}	O
else	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
default	O
:	O
{	O
did	int
=	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
did	int
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: Bad Option %s\n"	pointer
,	O
opt_line	array
)	O
;	O
}	O
did	int
=	O
0	int
;	O
}	O
fclose	function
(	O
fopt	pointer
)	O
;	O
}	O
int	O
read_int	function
(	O
FILE	struct
*	O
fp	pointer
,	O
int	O
*	O
valp	pointer
)	O
{	O
long	O
long_val	long
;	O
int	O
ret_value	int
;	O
ret_value	int
=	O
fread	function
(	O
&	O
long_val	long
,	O
sizeof	O
(	O
long_val	long
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
*	O
valp	pointer
=	O
(	O
int	O
)	O
ntohl	function
(	O
long_val	long
)	O
;	O
return	O
ret_value	int
;	O
}	O
int	O
write_int	function
(	O
FILE	struct
*	O
fp	pointer
,	O
int	O
value	int
)	O
{	O
unsigned	O
long	O
send	function
=	O
htonl	function
(	O
(	O
long	O
)	O
value	int
)	O
;	O
return	O
fwrite	function
(	O
&	O
send	function
,	O
sizeof	O
(	O
unsigned	O
long	O
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
}	O
int	O
read_short	function
(	O
fp	pointer
,	O
value	int
)	O
FILE	struct
*	O
fp	pointer
;	O
unsigned	O
short	O
*	O
value	int
;	O
{	O
int	O
rtvl	pointer
;	O
rtvl	pointer
=	O
fread	function
(	O
value	int
,	O
sizeof	O
(	O
unsigned	O
short	O
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
*	O
value	int
=	O
ntohs	function
(	O
*	O
value	int
)	O
;	O
return	O
rtvl	pointer
;	O
}	O
int	O
write_short	function
(	O
fp	pointer
,	O
value	int
)	O
FILE	struct
*	O
fp	pointer
;	O
unsigned	O
short	O
value	int
;	O
{	O
unsigned	O
short	O
send	function
=	O
htons	function
(	O
value	int
)	O
;	O
return	O
fwrite	function
(	O
&	O
send	function
,	O
sizeof	O
(	O
unsigned	O
short	O
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
}	O
void	O
write_diplo	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Sdiplo	struct
*	O
dm	pointer
)	O
{	O
Sdiplo	struct
send	function
;	O
send	function
.	O
self_id	int
=	O
htonl	function
(	O
dm	pointer
->	O
self_id	int
)	O
;	O
send	function
.	O
neighbor_id	int
=	O
htonl	function
(	O
dm	pointer
->	O
neighbor_id	int
)	O
;	O
send	function
.	O
status	int
=	O
htonl	function
(	O
dm	pointer
->	O
status	int
)	O
;	O
fwrite	function
(	O
&	O
send	function
,	O
sizeof	O
(	O
Sdiplo	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
}	O
void	O
read_diplo_item	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Sdiplo	struct
*	O
dm	pointer
)	O
{	O
fread	function
(	O
dm	pointer
,	O
sizeof	O
(	O
Sdiplo	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
dm	pointer
->	O
self_id	int
=	O
ntohl	function
(	O
dm	pointer
->	O
self_id	int
)	O
;	O
dm	pointer
->	O
neighbor_id	int
=	O
ntohl	function
(	O
dm	pointer
->	O
neighbor_id	int
)	O
;	O
dm	pointer
->	O
status	int
=	O
ntohl	function
(	O
dm	pointer
->	O
status	int
)	O
;	O
}	O
void	O
convert_point_to_net	function
(	O
Pt	struct
*	O
to	pointer
,	O
Pt	struct
*	O
from	pointer
)	O
{	O
to	pointer
->	O
x	int
=	O
htonl	function
(	O
from	pointer
->	O
x	int
)	O
;	O
to	pointer
->	O
y	int
=	O
htonl	function
(	O
from	pointer
->	O
y	int
)	O
;	O
}	O
void	O
convert_cargo_to_net	function
(	O
Scargo	struct
*	O
to	pointer
,	O
Scargo	struct
*	O
from	pointer
)	O
{	O
to	pointer
->	O
money	int
=	O
htonl	function
(	O
from	pointer
->	O
money	int
)	O
;	O
to	pointer
->	O
metal	int
=	O
htonl	function
(	O
from	pointer
->	O
metal	int
)	O
;	O
to	pointer
->	O
jewels	int
=	O
htonl	function
(	O
from	pointer
->	O
jewels	int
)	O
;	O
to	pointer
->	O
food	int
=	O
htonl	function
(	O
from	pointer
->	O
food	int
)	O
;	O
to	pointer
->	O
people	int
=	O
htonl	function
(	O
from	pointer
->	O
people	int
)	O
;	O
to	pointer
->	O
army	int
=	O
htonl	function
(	O
from	pointer
->	O
army	int
)	O
;	O
convert_point_to_net	function
(	O
&	O
(	O
to	pointer
->	O
title	struct
)	O
,	O
&	O
(	O
from	pointer
->	O
title	struct
)	O
)	O
;	O
}	O
void	O
convert_point_to_host	function
(	O
Pt	struct
*	O
to	pointer
,	O
Pt	struct
*	O
from	pointer
)	O
{	O
to	pointer
->	O
x	int
=	O
ntohl	function
(	O
from	pointer
->	O
x	int
)	O
;	O
to	pointer
->	O
y	int
=	O
ntohl	function
(	O
from	pointer
->	O
y	int
)	O
;	O
}	O
void	O
convert_cargo_to_host	function
(	O
Scargo	struct
*	O
to	pointer
,	O
Scargo	struct
*	O
from	pointer
)	O
{	O
to	pointer
->	O
money	int
=	O
ntohl	function
(	O
from	pointer
->	O
money	int
)	O
;	O
to	pointer
->	O
metal	int
=	O
ntohl	function
(	O
from	pointer
->	O
metal	int
)	O
;	O
to	pointer
->	O
jewels	int
=	O
ntohl	function
(	O
from	pointer
->	O
jewels	int
)	O
;	O
to	pointer
->	O
food	int
=	O
ntohl	function
(	O
from	pointer
->	O
food	int
)	O
;	O
to	pointer
->	O
people	int
=	O
ntohl	function
(	O
from	pointer
->	O
people	int
)	O
;	O
to	pointer
->	O
army	int
=	O
ntohl	function
(	O
from	pointer
->	O
army	int
)	O
;	O
convert_point_to_net	function
(	O
&	O
(	O
to	pointer
->	O
title	struct
)	O
,	O
&	O
(	O
from	pointer
->	O
title	struct
)	O
)	O
;	O
}	O
int	O
write_army	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Sarmy	struct
*	O
ap	pointer
)	O
{	O
Sarmy	struct
send	function
;	O
strcpy	function
(	O
send	function
.	O
type	array
,	O
ap	pointer
->	O
type	array
)	O
;	O
strcpy	function
(	O
send	function
.	O
name	array
,	O
ap	pointer
->	O
name	array
)	O
;	O
send	function
.	O
n_soldiers	int
=	O
htonl	function
(	O
ap	pointer
->	O
n_soldiers	int
)	O
;	O
send	function
.	O
status	int
=	O
htonl	function
(	O
ap	pointer
->	O
status	int
)	O
;	O
send	function
.	O
id	short
=	O
htonl	function
(	O
ap	pointer
->	O
id	short
)	O
;	O
send	function
.	O
owner	int
=	O
htonl	function
(	O
ap	pointer
->	O
owner	int
)	O
;	O
send	function
.	O
mvpts	int
=	O
htonl	function
(	O
ap	pointer
->	O
mvpts	int
)	O
;	O
send	function
.	O
mvratio	int
=	O
htonl	function
(	O
ap	pointer
->	O
mvratio	int
)	O
;	O
send	function
.	O
flags	long
=	O
htonl	function
(	O
ap	pointer
->	O
flags	long
)	O
;	O
send	function
.	O
sp_bonus	int
=	O
htonl	function
(	O
ap	pointer
->	O
sp_bonus	int
)	O
;	O
send	function
.	O
money_maint	int
=	O
htonl	function
(	O
ap	pointer
->	O
money_maint	int
)	O
;	O
send	function
.	O
metal_maint	int
=	O
htonl	function
(	O
ap	pointer
->	O
metal_maint	int
)	O
;	O
send	function
.	O
jewel_maint	int
=	O
htonl	function
(	O
ap	pointer
->	O
jewel_maint	int
)	O
;	O
send	function
.	O
spell_pts_maint	int
=	O
htonl	function
(	O
ap	pointer
->	O
spell_pts_maint	int
)	O
;	O
convert_point_to_net	function
(	O
&	O
(	O
send	function
.	O
pos	struct
)	O
,	O
&	O
(	O
ap	pointer
->	O
pos	struct
)	O
)	O
;	O
convert_cargo_to_net	function
(	O
&	O
(	O
send	function
.	O
cargo	struct
)	O
,	O
&	O
(	O
ap	pointer
->	O
cargo	struct
)	O
)	O
;	O
send	function
.	O
next	pointer
=	O
ap	pointer
->	O
next	pointer
;	O
return	O
fwrite	function
(	O
&	O
send	function
,	O
sizeof	O
(	O
Sarmy	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
}	O
int	O
read_army	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Sarmy	struct
*	O
ap	pointer
)	O
{	O
int	O
rtvl	pointer
;	O
fread	function
(	O
ap	pointer
,	O
sizeof	O
(	O
Sarmy	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
ap	pointer
->	O
n_soldiers	int
=	O
ntohl	function
(	O
ap	pointer
->	O
n_soldiers	int
)	O
;	O
ap	pointer
->	O
status	int
=	O
ntohl	function
(	O
ap	pointer
->	O
status	int
)	O
;	O
ap	pointer
->	O
id	short
=	O
ntohl	function
(	O
ap	pointer
->	O
id	short
)	O
;	O
ap	pointer
->	O
owner	int
=	O
ntohl	function
(	O
ap	pointer
->	O
owner	int
)	O
;	O
ap	pointer
->	O
mvpts	int
=	O
ntohl	function
(	O
ap	pointer
->	O
mvpts	int
)	O
;	O
ap	pointer
->	O
mvratio	int
=	O
ntohl	function
(	O
ap	pointer
->	O
mvratio	int
)	O
;	O
ap	pointer
->	O
flags	long
=	O
ntohl	function
(	O
ap	pointer
->	O
flags	long
)	O
;	O
ap	pointer
->	O
sp_bonus	int
=	O
ntohl	function
(	O
ap	pointer
->	O
sp_bonus	int
)	O
;	O
ap	pointer
->	O
money_maint	int
=	O
ntohl	function
(	O
ap	pointer
->	O
money_maint	int
)	O
;	O
ap	pointer
->	O
metal_maint	int
=	O
ntohl	function
(	O
ap	pointer
->	O
metal_maint	int
)	O
;	O
ap	pointer
->	O
jewel_maint	int
=	O
ntohl	function
(	O
ap	pointer
->	O
jewel_maint	int
)	O
;	O
ap	pointer
->	O
spell_pts_maint	int
=	O
ntohl	function
(	O
ap	pointer
->	O
spell_pts_maint	int
)	O
;	O
convert_point_to_host	function
(	O
&	O
(	O
ap	pointer
->	O
pos	struct
)	O
,	O
&	O
(	O
ap	pointer
->	O
pos	struct
)	O
)	O
;	O
convert_cargo_to_host	function
(	O
&	O
(	O
ap	pointer
->	O
cargo	struct
)	O
,	O
&	O
(	O
ap	pointer
->	O
cargo	struct
)	O
)	O
;	O
return	O
rtvl	pointer
;	O
}	O
int	O
write_cargo	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Scargo	struct
*	O
cargo	struct
)	O
{	O
Scargo	struct
send	function
;	O
convert_cargo_to_net	function
(	O
&	O
send	function
,	O
cargo	struct
)	O
;	O
return	O
fwrite	function
(	O
&	O
send	function
,	O
sizeof	O
(	O
Scargo	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
}	O
int	O
read_cargo	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Scargo	struct
*	O
cargo	struct
)	O
{	O
int	O
rtvl	pointer
;	O
rtvl	pointer
=	O
fread	function
(	O
cargo	struct
,	O
sizeof	O
(	O
Scargo	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
convert_cargo_to_host	function
(	O
cargo	struct
,	O
cargo	struct
)	O
;	O
return	O
rtvl	pointer
;	O
}	O
int	O
write_point_list	function
(	O
FILE	struct
*	O
fp	pointer
,	O
struct	O
pt_list	struct
*	O
plist	pointer
)	O
{	O
struct	O
pt_list	struct
send	function
;	O
convert_point_to_net	function
(	O
&	O
(	O
send	function
.	O
pt	struct
)	O
,	O
&	O
(	O
plist	pointer
->	O
pt	struct
)	O
)	O
;	O
send	function
.	O
next	pointer
=	O
plist	pointer
->	O
next	pointer
;	O
return	O
fwrite	function
(	O
&	O
send	function
,	O
sizeof	O
(	O
struct	O
pt_list	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
}	O
void	O
read_point_list	function
(	O
FILE	struct
*	O
fp	pointer
,	O
struct	O
pt_list	struct
*	O
plist	pointer
)	O
{	O
fread	function
(	O
plist	pointer
,	O
sizeof	O
(	O
struct	O
pt_list	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
convert_point_to_net	function
(	O
&	O
(	O
plist	pointer
->	O
pt	struct
)	O
,	O
&	O
(	O
plist	pointer
->	O
pt	struct
)	O
)	O
;	O
}	O
void	O
write_geo	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Sgeo	struct
*	O
geo	struct
)	O
{	O
int	O
x	int
;	O
write_int	function
(	O
fp	pointer
,	O
geo	struct
->	O
topology	int
)	O
;	O
write_int	function
(	O
fp	pointer
,	O
geo	struct
->	O
pwater	int
)	O
;	O
x	int
=	O
geo	struct
->	O
metal_avg	double
*	O
GEOMULTCONST	int
;	O
write_int	function
(	O
fp	pointer
,	O
x	int
)	O
;	O
x	int
=	O
geo	struct
->	O
jewel_avg	double
*	O
GEOMULTCONST	int
;	O
write_int	function
(	O
fp	pointer
,	O
x	int
)	O
;	O
x	int
=	O
geo	struct
->	O
soil_avg	double
*	O
GEOMULTCONST	int
;	O
write_int	function
(	O
fp	pointer
,	O
x	int
)	O
;	O
}	O
void	O
read_geo	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Sgeo	struct
*	O
geo	struct
)	O
{	O
int	O
x	int
;	O
if	O
(	O
debug	int
>=	O
1	int
)	O
{	O
printf	function
(	O
"\nReading geography"	pointer
)	O
;	O
}	O
read_int	function
(	O
fp	pointer
,	O
&	O
geo	struct
->	O
topology	int
)	O
;	O
read_int	function
(	O
fp	pointer
,	O
&	O
geo	struct
->	O
pwater	int
)	O
;	O
read_int	function
(	O
fp	pointer
,	O
&	O
x	int
)	O
;	O
geo	struct
->	O
metal_avg	double
=	O
(	O
double	O
)	O
x	int
/	O
(	O
double	O
)	O
GEOMULTCONST	int
;	O
read_int	function
(	O
fp	pointer
,	O
&	O
x	int
)	O
;	O
geo	struct
->	O
jewel_avg	double
=	O
(	O
double	O
)	O
x	int
/	O
(	O
double	O
)	O
GEOMULTCONST	int
;	O
read_int	function
(	O
fp	pointer
,	O
&	O
x	int
)	O
;	O
geo	struct
->	O
soil_avg	double
=	O
(	O
double	O
)	O
x	int
/	O
(	O
double	O
)	O
GEOMULTCONST	int
;	O
}	O
void	O
write_sector	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Ssector	struct
*	O
sp	int
)	O
{	O
Ssector	struct
send	function
;	O
convert_point_to_net	function
(	O
&	O
send	function
.	O
loc	struct
,	O
&	O
sp	int
->	O
loc	struct
)	O
;	O
send	function
.	O
terrain	short
=	O
htons	function
(	O
sp	int
->	O
terrain	short
)	O
;	O
send	function
.	O
altitude	short
=	O
htons	function
(	O
sp	int
->	O
altitude	short
)	O
;	O
send	function
.	O
climate	short
=	O
htons	function
(	O
sp	int
->	O
climate	short
)	O
;	O
send	function
.	O
designation	short
=	O
htons	function
(	O
sp	int
->	O
designation	short
)	O
;	O
send	function
.	O
soil	short
=	O
htons	function
(	O
sp	int
->	O
soil	short
)	O
;	O
send	function
.	O
metal	int
=	O
htons	function
(	O
sp	int
->	O
metal	int
)	O
;	O
send	function
.	O
jewels	int
=	O
htons	function
(	O
sp	int
->	O
jewels	int
)	O
;	O
send	function
.	O
defense	short
=	O
htons	function
(	O
sp	int
->	O
defense	short
)	O
;	O
send	function
.	O
roads	short
=	O
htons	function
(	O
sp	int
->	O
roads	short
)	O
;	O
send	function
.	O
owner	int
=	O
htons	function
(	O
sp	int
->	O
owner	int
)	O
;	O
send	function
.	O
n_people	int
=	O
htonl	function
(	O
sp	int
->	O
n_people	int
)	O
;	O
send	function
.	O
flags	long
=	O
htonl	function
(	O
sp	int
->	O
flags	long
)	O
;	O
send	function
.	O
alist	pointer
=	O
sp	int
->	O
alist	pointer
;	O
send	function
.	O
name	array
=	O
sp	int
->	O
name	array
;	O
fwrite	function
(	O
&	O
send	function
,	O
sizeof	O
(	O
Ssector	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
if	O
(	O
sp	int
->	O
name	array
!=	O
NULL	O
)	O
{	O
fwrite	function
(	O
sp	int
->	O
name	array
,	O
strlen	function
(	O
sp	int
->	O
name	array
)	O
+	O
1	int
,	O
1	int
,	O
fp	pointer
)	O
;	O
}	O
}	O
void	O
read_sector	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Ssector	struct
*	O
sp	int
)	O
{	O
char	O
tmp_name	array
[	O
NAMELEN	int
]	O
;	O
char	O
form_str	array
[	O
100	int
]	O
;	O
sprintf	function
(	O
form_str	array
,	O
"%%[%c-%c]"	pointer
,	O
1	int
,	O
255	int
)	O
;	O
fread	function
(	O
sp	int
,	O
sizeof	O
(	O
Ssector	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
if	O
(	O
sp	int
->	O
name	array
!=	O
NULL	O
)	O
{	O
fscanf	function
(	O
fp	pointer
,	O
form_str	array
,	O
tmp_name	array
)	O
;	O
sp	int
->	O
name	array
=	O
malloc	function
(	O
strlen	function
(	O
tmp_name	array
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
sp	int
->	O
name	array
,	O
tmp_name	array
)	O
;	O
(	O
void	O
)	O
fgetc	function
(	O
fp	pointer
)	O
;	O
}	O
convert_point_to_host	function
(	O
&	O
sp	int
->	O
loc	struct
,	O
&	O
sp	int
->	O
loc	struct
)	O
;	O
sp	int
->	O
terrain	short
=	O
ntohs	function
(	O
sp	int
->	O
terrain	short
)	O
;	O
sp	int
->	O
altitude	short
=	O
ntohs	function
(	O
sp	int
->	O
altitude	short
)	O
;	O
sp	int
->	O
climate	short
=	O
ntohs	function
(	O
sp	int
->	O
climate	short
)	O
;	O
sp	int
->	O
designation	short
=	O
ntohs	function
(	O
sp	int
->	O
designation	short
)	O
;	O
sp	int
->	O
soil	short
=	O
ntohs	function
(	O
sp	int
->	O
soil	short
)	O
;	O
sp	int
->	O
metal	int
=	O
ntohs	function
(	O
sp	int
->	O
metal	int
)	O
;	O
sp	int
->	O
jewels	int
=	O
ntohs	function
(	O
sp	int
->	O
jewels	int
)	O
;	O
sp	int
->	O
defense	short
=	O
ntohs	function
(	O
sp	int
->	O
defense	short
)	O
;	O
sp	int
->	O
roads	short
=	O
ntohs	function
(	O
sp	int
->	O
roads	short
)	O
;	O
sp	int
->	O
owner	int
=	O
ntohs	function
(	O
sp	int
->	O
owner	int
)	O
;	O
sp	int
->	O
n_people	int
=	O
ntohl	function
(	O
sp	int
->	O
n_people	int
)	O
;	O
sp	int
->	O
flags	long
=	O
ntohl	function
(	O
sp	int
->	O
flags	long
)	O
;	O
}	O
void	O
convert_race_to_net	function
(	O
Srace	struct
*	O
to	pointer
,	O
Srace	struct
*	O
from	pointer
)	O
{	O
strcpy	function
(	O
to	pointer
->	O
name	array
,	O
from	pointer
->	O
name	array
)	O
;	O
to	pointer
->	O
mark	char
=	O
from	pointer
->	O
mark	char
;	O
to	pointer
->	O
strength	int
=	O
htonl	function
(	O
from	pointer
->	O
strength	int
)	O
;	O
to	pointer
->	O
repro	int
=	O
htonl	function
(	O
from	pointer
->	O
repro	int
)	O
;	O
to	pointer
->	O
mortality	int
=	O
htonl	function
(	O
from	pointer
->	O
mortality	int
)	O
;	O
to	pointer
->	O
intel	int
=	O
htonl	function
(	O
from	pointer
->	O
intel	int
)	O
;	O
to	pointer
->	O
speed	int
=	O
htonl	function
(	O
from	pointer
->	O
speed	int
)	O
;	O
to	pointer
->	O
stealth	int
=	O
htonl	function
(	O
from	pointer
->	O
stealth	int
)	O
;	O
to	pointer
->	O
pref_alt	int
=	O
htonl	function
(	O
from	pointer
->	O
pref_alt	int
)	O
;	O
to	pointer
->	O
pref_terrain	int
=	O
htonl	function
(	O
from	pointer
->	O
pref_terrain	int
)	O
;	O
to	pointer
->	O
pref_climate	int
=	O
htonl	function
(	O
from	pointer
->	O
pref_climate	int
)	O
;	O
to	pointer
->	O
mag_apt	int
=	O
htonl	function
(	O
from	pointer
->	O
mag_apt	int
)	O
;	O
to	pointer
->	O
farming	int
=	O
htonl	function
(	O
from	pointer
->	O
farming	int
)	O
;	O
to	pointer
->	O
mining	int
=	O
htonl	function
(	O
from	pointer
->	O
mining	int
)	O
;	O
}	O
void	O
convert_race_to_host	function
(	O
Srace	struct
*	O
to	pointer
,	O
Srace	struct
*	O
from	pointer
)	O
{	O
strcpy	function
(	O
to	pointer
->	O
name	array
,	O
from	pointer
->	O
name	array
)	O
;	O
to	pointer
->	O
mark	char
=	O
from	pointer
->	O
mark	char
;	O
to	pointer
->	O
strength	int
=	O
ntohl	function
(	O
from	pointer
->	O
strength	int
)	O
;	O
to	pointer
->	O
repro	int
=	O
ntohl	function
(	O
from	pointer
->	O
repro	int
)	O
;	O
to	pointer
->	O
mortality	int
=	O
ntohl	function
(	O
from	pointer
->	O
mortality	int
)	O
;	O
to	pointer
->	O
intel	int
=	O
ntohl	function
(	O
from	pointer
->	O
intel	int
)	O
;	O
to	pointer
->	O
speed	int
=	O
ntohl	function
(	O
from	pointer
->	O
speed	int
)	O
;	O
to	pointer
->	O
stealth	int
=	O
ntohl	function
(	O
from	pointer
->	O
stealth	int
)	O
;	O
to	pointer
->	O
pref_alt	int
=	O
ntohl	function
(	O
from	pointer
->	O
pref_alt	int
)	O
;	O
to	pointer
->	O
pref_terrain	int
=	O
ntohl	function
(	O
from	pointer
->	O
pref_terrain	int
)	O
;	O
to	pointer
->	O
pref_climate	int
=	O
ntohl	function
(	O
from	pointer
->	O
pref_climate	int
)	O
;	O
to	pointer
->	O
mag_apt	int
=	O
ntohl	function
(	O
from	pointer
->	O
mag_apt	int
)	O
;	O
to	pointer
->	O
farming	int
=	O
ntohl	function
(	O
from	pointer
->	O
farming	int
)	O
;	O
to	pointer
->	O
mining	int
=	O
ntohl	function
(	O
from	pointer
->	O
mining	int
)	O
;	O
}	O
void	O
convert_const_to_net	function
(	O
to	pointer
,	O
from	pointer
)	O
Sconstruction	struct
*	O
to	pointer
,	O
*	O
from	pointer
;	O
{	O
to	pointer
->	O
roads	short
=	O
htons	function
(	O
from	pointer
->	O
roads	short
)	O
;	O
to	pointer
->	O
forts	short
=	O
htons	function
(	O
from	pointer
->	O
forts	short
)	O
;	O
to	pointer
->	O
reserved	short
=	O
htons	function
(	O
from	pointer
->	O
reserved	short
)	O
;	O
to	pointer
->	O
flags	long
=	O
htonl	function
(	O
from	pointer
->	O
flags	long
)	O
;	O
}	O
void	O
convert_const_to_host	function
(	O
to	pointer
,	O
from	pointer
)	O
Sconstruction	struct
*	O
to	pointer
,	O
*	O
from	pointer
;	O
{	O
to	pointer
->	O
roads	short
=	O
ntohs	function
(	O
from	pointer
->	O
roads	short
)	O
;	O
to	pointer
->	O
forts	short
=	O
ntohs	function
(	O
from	pointer
->	O
forts	short
)	O
;	O
to	pointer
->	O
reserved	short
=	O
ntohs	function
(	O
from	pointer
->	O
reserved	short
)	O
;	O
to	pointer
->	O
flags	long
=	O
ntohl	function
(	O
from	pointer
->	O
flags	long
)	O
;	O
}	O
void	O
write_nation_struct	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Snation	struct
*	O
np	pointer
)	O
{	O
Snation	struct
send	function
;	O
strcpy	function
(	O
send	function
.	O
name	array
,	O
np	pointer
->	O
name	array
)	O
;	O
strcpy	function
(	O
send	function
.	O
leader	array
,	O
np	pointer
->	O
leader	array
)	O
;	O
strcpy	function
(	O
send	function
.	O
passwd	array
,	O
np	pointer
->	O
passwd	array
)	O
;	O
strcpy	function
(	O
send	function
.	O
mag_order	array
,	O
np	pointer
->	O
mag_order	array
)	O
;	O
convert_point_to_net	function
(	O
&	O
send	function
.	O
capital	struct
,	O
&	O
np	pointer
->	O
capital	struct
)	O
;	O
convert_race_to_net	function
(	O
&	O
send	function
.	O
race	struct
,	O
&	O
np	pointer
->	O
race	struct
)	O
;	O
convert_const_to_net	function
(	O
&	O
send	function
.	O
consts	struct
,	O
&	O
np	pointer
->	O
consts	struct
)	O
;	O
send	function
.	O
mark	char
=	O
np	pointer
->	O
mark	char
;	O
send	function
.	O
id	short
=	O
htonl	function
(	O
np	pointer
->	O
id	short
)	O
;	O
send	function
.	O
taxes	int
=	O
htonl	function
(	O
np	pointer
->	O
taxes	int
)	O
;	O
send	function
.	O
taxtype	int
=	O
htonl	function
(	O
np	pointer
->	O
taxtype	int
)	O
;	O
send	function
.	O
charity	int
=	O
htonl	function
(	O
np	pointer
->	O
charity	int
)	O
;	O
send	function
.	O
money	int
=	O
htonl	function
(	O
np	pointer
->	O
money	int
)	O
;	O
send	function
.	O
jewels	int
=	O
htonl	function
(	O
np	pointer
->	O
jewels	int
)	O
;	O
send	function
.	O
metal	int
=	O
htonl	function
(	O
np	pointer
->	O
metal	int
)	O
;	O
send	function
.	O
food	int
=	O
htonl	function
(	O
np	pointer
->	O
food	int
)	O
;	O
send	function
.	O
n_sects	int
=	O
htonl	function
(	O
np	pointer
->	O
n_sects	int
)	O
;	O
send	function
.	O
tech_r_d	int
=	O
htonl	function
(	O
np	pointer
->	O
tech_r_d	int
)	O
;	O
send	function
.	O
tech_r_d_metal	int
=	O
htonl	function
(	O
np	pointer
->	O
tech_r_d_metal	int
)	O
;	O
send	function
.	O
mag_r_d	int
=	O
htonl	function
(	O
np	pointer
->	O
mag_r_d	int
)	O
;	O
send	function
.	O
mag_r_d_jewels	int
=	O
htonl	function
(	O
np	pointer
->	O
mag_r_d_jewels	int
)	O
;	O
send	function
.	O
spy_r_d	int
=	O
htonl	function
(	O
np	pointer
->	O
spy_r_d	int
)	O
;	O
send	function
.	O
cn_flag	int
=	O
htonl	function
(	O
np	pointer
->	O
cn_flag	int
)	O
;	O
send	function
.	O
tech_skill	int
=	O
htonl	function
(	O
np	pointer
->	O
tech_skill	int
)	O
;	O
send	function
.	O
mag_skill	int
=	O
htonl	function
(	O
np	pointer
->	O
mag_skill	int
)	O
;	O
send	function
.	O
farm_skill	int
=	O
htonl	function
(	O
np	pointer
->	O
farm_skill	int
)	O
;	O
send	function
.	O
mine_skill	int
=	O
htonl	function
(	O
np	pointer
->	O
mine_skill	int
)	O
;	O
send	function
.	O
spell_pts	int
=	O
htonl	function
(	O
np	pointer
->	O
spell_pts	int
)	O
;	O
send	function
.	O
combat_bonus	int
=	O
htonl	function
(	O
np	pointer
->	O
combat_bonus	int
)	O
;	O
send	function
.	O
spy	int
=	O
htonl	function
(	O
np	pointer
->	O
spy	int
)	O
;	O
send	function
.	O
secrecy	int
=	O
htonl	function
(	O
np	pointer
->	O
secrecy	int
)	O
;	O
send	function
.	O
n_armies	int
=	O
htonl	function
(	O
np	pointer
->	O
n_armies	int
)	O
;	O
send	function
.	O
cur_mag_r_d	int
=	O
htonl	function
(	O
np	pointer
->	O
cur_mag_r_d	int
)	O
;	O
send	function
.	O
cur_mag_r_d_jewels	int
=	O
htonl	function
(	O
np	pointer
->	O
cur_mag_r_d_jewels	int
)	O
;	O
send	function
.	O
cur_tech_r_d	int
=	O
htonl	function
(	O
np	pointer
->	O
cur_tech_r_d	int
)	O
;	O
send	function
.	O
cur_tech_r_d_metal	int
=	O
htonl	function
(	O
np	pointer
->	O
cur_tech_r_d_metal	int
)	O
;	O
send	function
.	O
cur_spy_r_d	int
=	O
htonl	function
(	O
np	pointer
->	O
cur_spy_r_d	int
)	O
;	O
send	function
.	O
armies	pointer
=	O
np	pointer
->	O
armies	pointer
;	O
send	function
.	O
ptlist	pointer
=	O
np	pointer
->	O
ptlist	pointer
;	O
send	function
.	O
opts	pointer
=	O
np	pointer
->	O
opts	pointer
;	O
send	function
.	O
cn_params	pointer
=	O
np	pointer
->	O
cn_params	pointer
;	O
fwrite	function
(	O
&	O
send	function
,	O
sizeof	O
(	O
Snation	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
}	O
void	O
read_nation_struct	function
(	O
FILE	struct
*	O
fp	pointer
,	O
Snation	struct
*	O
np	pointer
)	O
{	O
int	O
rtvl	pointer
;	O
rtvl	pointer
=	O
fread	function
(	O
np	pointer
,	O
sizeof	O
(	O
Snation	struct
)	O
,	O
1	int
,	O
fp	pointer
)	O
;	O
convert_point_to_host	function
(	O
&	O
np	pointer
->	O
capital	struct
,	O
&	O
np	pointer
->	O
capital	struct
)	O
;	O
convert_race_to_host	function
(	O
&	O
np	pointer
->	O
race	struct
,	O
&	O
np	pointer
->	O
race	struct
)	O
;	O
convert_const_to_host	function
(	O
&	O
np	pointer
->	O
consts	struct
,	O
&	O
np	pointer
->	O
consts	struct
)	O
;	O
np	pointer
->	O
id	short
=	O
ntohl	function
(	O
np	pointer
->	O
id	short
)	O
;	O
np	pointer
->	O
taxes	int
=	O
ntohl	function
(	O
np	pointer
->	O
taxes	int
)	O
;	O
np	pointer
->	O
taxtype	int
=	O
ntohl	function
(	O
np	pointer
->	O
taxtype	int
)	O
;	O
np	pointer
->	O
charity	int
=	O
ntohl	function
(	O
np	pointer
->	O
charity	int
)	O
;	O
np	pointer
->	O
money	int
=	O
ntohl	function
(	O
np	pointer
->	O
money	int
)	O
;	O
np	pointer
->	O
jewels	int
=	O
ntohl	function
(	O
np	pointer
->	O
jewels	int
)	O
;	O
np	pointer
->	O
metal	int
=	O
ntohl	function
(	O
np	pointer
->	O
metal	int
)	O
;	O
np	pointer
->	O
food	int
=	O
ntohl	function
(	O
np	pointer
->	O
food	int
)	O
;	O
np	pointer
->	O
n_sects	int
=	O
ntohl	function
(	O
np	pointer
->	O
n_sects	int
)	O
;	O
np	pointer
->	O
tech_r_d	int
=	O
ntohl	function
(	O
np	pointer
->	O
tech_r_d	int
)	O
;	O
np	pointer
->	O
tech_r_d_metal	int
=	O
ntohl	function
(	O
np	pointer
->	O
tech_r_d_metal	int
)	O
;	O
np	pointer
->	O
mag_r_d	int
=	O
ntohl	function
(	O
np	pointer
->	O
mag_r_d	int
)	O
;	O
np	pointer
->	O
mag_r_d_jewels	int
=	O
ntohl	function
(	O
np	pointer
->	O
mag_r_d_jewels	int
)	O
;	O
np	pointer
->	O
spy_r_d	int
=	O
ntohl	function
(	O
np	pointer
->	O
spy_r_d	int
)	O
;	O
np	pointer
->	O
cn_flag	int
=	O
ntohl	function
(	O
np	pointer
->	O
cn_flag	int
)	O
;	O
np	pointer
->	O
tech_skill	int
=	O
ntohl	function
(	O
np	pointer
->	O
tech_skill	int
)	O
;	O
np	pointer
->	O
mag_skill	int
=	O
ntohl	function
(	O
np	pointer
->	O
mag_skill	int
)	O
;	O
np	pointer
->	O
farm_skill	int
=	O
ntohl	function
(	O
np	pointer
->	O
farm_skill	int
)	O
;	O
np	pointer
->	O
mine_skill	int
=	O
ntohl	function
(	O
np	pointer
->	O
mine_skill	int
)	O
;	O
np	pointer
->	O
spell_pts	int
=	O
ntohl	function
(	O
np	pointer
->	O
spell_pts	int
)	O
;	O
np	pointer
->	O
combat_bonus	int
=	O
ntohl	function
(	O
np	pointer
->	O
combat_bonus	int
)	O
;	O
np	pointer
->	O
spy	int
=	O
ntohl	function
(	O
np	pointer
->	O
spy	int
)	O
;	O
np	pointer
->	O
secrecy	int
=	O
ntohl	function
(	O
np	pointer
->	O
secrecy	int
)	O
;	O
np	pointer
->	O
n_armies	int
=	O
ntohl	function
(	O
np	pointer
->	O
n_armies	int
)	O
;	O
np	pointer
->	O
cur_mag_r_d	int
=	O
ntohl	function
(	O
np	pointer
->	O
cur_mag_r_d	int
)	O
;	O
np	pointer
->	O
cur_mag_r_d_jewels	int
=	O
ntohl	function
(	O
np	pointer
->	O
cur_mag_r_d_jewels	int
)	O
;	O
np	pointer
->	O
cur_tech_r_d	int
=	O
ntohl	function
(	O
np	pointer
->	O
cur_tech_r_d	int
)	O
;	O
np	pointer
->	O
cur_tech_r_d_metal	int
=	O
ntohl	function
(	O
np	pointer
->	O
cur_tech_r_d_metal	int
)	O
;	O
np	pointer
->	O
cur_spy_r_d	int
=	O
ntohl	function
(	O
np	pointer
->	O
cur_spy_r_d	int
)	O
;	O
}	O
