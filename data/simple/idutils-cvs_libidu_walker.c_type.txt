int	O
walker_verbose_flag	int
=	O
0	int
;	O
off_t	long
largest_member_file	long
=	O
0	int
;	O
int	O
walk_dir	function
(	O
struct	O
file_link	struct
*	O
dir_link	pointer
)	O
;	O
struct	O
member_file	struct
*	O
get_member_file	function
(	O
struct	O
file_link	struct
*	O
flink	pointer
)	O
;	O
struct	O
lang_args	struct
*	O
get_lang_args	function
(	O
struct	O
file_link	struct
const	O
*	O
flink	pointer
)	O
;	O
void	O
print_member_file	function
(	O
struct	O
member_file	struct
*	O
member	pointer
)	O
;	O
int	O
walk_sub_dirs	function
(	O
struct	O
dynvec	struct
*	O
sub_dirs_vec	pointer
)	O
;	O
void	O
reparent_children	function
(	O
struct	O
file_link	struct
*	O
dlink	pointer
,	O
struct	O
file_link	struct
*	O
slink	pointer
)	O
;	O
int	O
classify_link	function
(	O
struct	O
file_link	struct
*	O
flink	pointer
,	O
struct	O
stat	struct
*	O
stp	pointer
)	O
;	O
struct	O
file_link	struct
*	O
get_link_from_dirent	function
(	O
struct	O
dirent	struct
*	O
dirent	struct
,	O
struct	O
file_link	struct
*	O
parent	pointer
)	O
;	O
struct	O
file_link	struct
*	O
make_link_from_dirent	function
(	O
struct	O
dirent	struct
*	O
dirent	struct
,	O
struct	O
file_link	struct
*	O
parent	pointer
)	O
;	O
struct	O
file_link	struct
*	O
get_link_from_string	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
parent	pointer
)	O
;	O
struct	O
file_link	struct
*	O
make_link_from_string	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
parent	pointer
)	O
;	O
int	O
lang_wanted	function
(	O
char	O
const	O
*	O
lang_name	pointer
)	O
;	O
char	O
*	O
*	O
append_strings_to_vector	function
(	O
char	O
*	O
*	O
vector_0	pointer
,	O
char	O
*	O
string	pointer
,	O
char	O
const	O
*	O
delimiter_class	pointer
)	O
;	O
int	O
vector_length	function
(	O
char	O
*	O
*	O
vector	pointer
)	O
;	O
int	O
string_in_vector	function
(	O
char	O
const	O
*	O
string	pointer
,	O
char	O
*	O
*	O
vector	pointer
)	O
;	O
static	O
int	O
same_as_dot	function
(	O
char	O
const	O
*	O
cwd	pointer
)	O
;	O
struct	O
file_link	struct
const	O
*	O
*	O
fill_link_vector	function
(	O
struct	O
file_link	struct
const	O
*	O
*	O
vec_buf	pointer
,	O
struct	O
file_link	struct
const	O
*	O
flink	pointer
)	O
;	O
struct	O
file_link	struct
const	O
*	O
*	O
fill_link_vector_1	function
(	O
struct	O
file_link	struct
const	O
*	O
*	O
vec_buf	pointer
,	O
struct	O
file_link	struct
const	O
*	O
flink	pointer
)	O
;	O
char	O
*	O
fill_dot_dots	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
levels	int
)	O
;	O
static	O
char	O
*	O
absolute_file_name_1	function
(	O
char	O
*	O
buffer	pointer
,	O
struct	O
file_link	struct
const	O
*	O
flink	pointer
)	O
;	O
unsigned	O
long	O
member_file_hash_1	function
(	O
void	O
const	O
*	O
key	pointer
)	O
;	O
unsigned	O
long	O
member_file_hash_2	function
(	O
void	O
const	O
*	O
key	pointer
)	O
;	O
int	O
member_file_hash_compare	function
(	O
void	O
const	O
*	O
x	pointer
,	O
void	O
const	O
*	O
y	pointer
)	O
;	O
unsigned	O
long	O
file_link_hash_1	function
(	O
void	O
const	O
*	O
key	pointer
)	O
;	O
unsigned	O
long	O
file_link_hash_2	function
(	O
void	O
const	O
*	O
key	pointer
)	O
;	O
int	O
file_link_hash_compare	function
(	O
void	O
const	O
*	O
x	pointer
,	O
void	O
const	O
*	O
y	pointer
)	O
;	O
unsigned	O
long	O
dev_ino_hash_1	function
(	O
void	O
const	O
*	O
key	pointer
)	O
;	O
unsigned	O
long	O
dev_ino_hash_2	function
(	O
void	O
const	O
*	O
key	pointer
)	O
;	O
int	O
dev_ino_hash_compare	function
(	O
void	O
const	O
*	O
x	pointer
,	O
void	O
const	O
*	O
y	pointer
)	O
;	O
int	O
symlink_ancestry	function
(	O
struct	O
file_link	struct
*	O
flink	pointer
)	O
;	O
struct	O
file_link	struct
*	O
find_alias_link	function
(	O
struct	O
file_link	struct
*	O
flink	pointer
,	O
struct	O
stat	struct
*	O
stp	pointer
)	O
;	O
struct	O
member_file	struct
*	O
maybe_get_member_file	function
(	O
struct	O
file_link	struct
*	O
flink	pointer
,	O
struct	O
stat	struct
*	O
stp	pointer
)	O
;	O
static	O
struct	O
file_link	struct
*	O
current_dir_link	pointer
=	O
0	int
;	O
static	O
char	O
const	O
white_space	array
[	O
]	O
=	O
" \t\r\n\v\f"	pointer
;	O
char	O
*	O
xgetcwd	function
(	O
void	O
)	O
;	O
int	O
walk_dir	function
(	O
struct	O
file_link	struct
*	O
dir_link	pointer
)	O
{	O
int	O
scannable_files	int
;	O
struct	O
dynvec	struct
*	O
sub_dirs_vec	pointer
;	O
DIR	struct
*	O
dirp	pointer
;	O
if	O
(	O
!	O
chdir_to_link	function
(	O
dir_link	pointer
)	O
)	O
return	O
0	int
;	O
dirp	pointer
=	O
opendir	function
(	O
"."	pointer
)	O
;	O
if	O
(	O
dirp	pointer
==	O
0	int
)	O
{	O
char	O
*	O
file_name	pointer
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
absolute_file_name	function
(	O
file_name	pointer
,	O
dir_link	pointer
)	O
;	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't read directory `%s' (`.' from `%s')"	pointer
)	O
,	O
file_name	pointer
,	O
xgetcwd	function
(	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
sub_dirs_vec	pointer
=	O
make_dynvec	function
(	O
32	int
)	O
;	O
scannable_files	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
file_link	struct
*	O
flink	pointer
;	O
struct	O
dirent	struct
*	O
dirent	struct
=	O
readdir	function
(	O
dirp	pointer
)	O
;	O
if	O
(	O
dirent	struct
==	O
0	int
)	O
break	O
;	O
if	O
(	O
IS_DOT_or_DOT_DOT	O
(	O
dirent	struct
->	O
d_name	array
)	O
)	O
continue	O
;	O
flink	pointer
=	O
get_link_from_dirent	function
(	O
dirent	struct
,	O
dir_link	pointer
)	O
;	O
if	O
(	O
!	O
(	O
flink	pointer
->	O
fl_flags	char
&	O
FL_PRUNE	O
)	O
)	O
walk_flink	function
(	O
flink	pointer
,	O
sub_dirs_vec	pointer
)	O
;	O
}	O
closedir	function
(	O
dirp	pointer
)	O
;	O
scannable_files	int
+=	O
walk_sub_dirs	function
(	O
sub_dirs_vec	pointer
)	O
;	O
dynvec_free	function
(	O
sub_dirs_vec	pointer
)	O
;	O
return	O
scannable_files	int
;	O
}	O
int	O
walk_sub_dirs	function
(	O
struct	O
dynvec	struct
*	O
sub_dirs_vec	pointer
)	O
{	O
struct	O
file_link	struct
*	O
*	O
sub_dirs	pointer
;	O
struct	O
file_link	struct
*	O
*	O
sub_dirs_end	pointer
;	O
int	O
total_scannable_files	int
=	O
0	int
;	O
dynvec_freeze	function
(	O
sub_dirs_vec	pointer
)	O
;	O
sub_dirs_end	pointer
=	O
(	O
struct	O
file_link	struct
*	O
*	O
)	O
&	O
sub_dirs_vec	pointer
->	O
dv_vec	pointer
[	O
sub_dirs_vec	pointer
->	O
dv_fill	int
]	O
;	O
sub_dirs	pointer
=	O
(	O
struct	O
file_link	struct
*	O
*	O
)	O
sub_dirs_vec	pointer
->	O
dv_vec	pointer
;	O
for	O
(	O
;	O
sub_dirs	pointer
<	O
sub_dirs_end	pointer
;	O
sub_dirs	pointer
++	O
)	O
{	O
struct	O
file_link	struct
*	O
sub_dir_link	pointer
=	O
*	O
sub_dirs	pointer
;	O
int	O
scannable_files	int
=	O
walk_dir	function
(	O
sub_dir_link	pointer
)	O
;	O
if	O
(	O
scannable_files	int
)	O
total_scannable_files	int
+=	O
scannable_files	int
;	O
}	O
return	O
total_scannable_files	int
;	O
}	O
void	O
walk_flink	function
(	O
struct	O
file_link	struct
*	O
flink	pointer
,	O
struct	O
dynvec	struct
*	O
sub_dirs_vec	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
unsigned	O
int	O
old_flags	int
;	O
unsigned	O
int	O
new_flags	int
;	O
new_flags	int
=	O
classify_link	function
(	O
flink	pointer
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
new_flags	int
==	O
0	int
)	O
return	O
;	O
old_flags	int
=	O
flink	pointer
->	O
fl_flags	char
;	O
if	O
(	O
(	O
old_flags	int
&	O
FL_TYPE_MASK	O
)	O
&&	O
(	O
old_flags	int
&	O
FL_TYPE_MASK	O
)	O
!=	O
(	O
new_flags	int
&	O
FL_TYPE_MASK	O
)	O
)	O
{	O
char	O
*	O
file_name	pointer
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
absolute_file_name	function
(	O
file_name	pointer
,	O
flink	pointer
)	O
;	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"notice: `%s' was a %s, but is now a %s!"	pointer
)	O
,	O
file_name	pointer
,	O
(	O
FL_IS_FILE	O
(	O
old_flags	int
)	O
?	O
_	O
(	O
"file"	pointer
)	O
:	O
_	O
(	O
"directory"	pointer
)	O
)	O
,	O
(	O
FL_IS_FILE	O
(	O
new_flags	int
)	O
?	O
_	O
(	O
"file"	pointer
)	O
:	O
_	O
(	O
"directory"	pointer
)	O
)	O
)	O
;	O
}	O
flink	pointer
->	O
fl_flags	char
=	O
(	O
old_flags	int
&	O
~	O
(	O
FL_TYPE_MASK	O
|	O
FL_SYM_LINK	O
)	O
)	O
|	O
new_flags	int
;	O
if	O
(	O
FL_IS_DIR	O
(	O
new_flags	int
)	O
)	O
{	O
struct	O
file_link	struct
*	O
alias_link	pointer
;	O
alias_link	pointer
=	O
find_alias_link	function
(	O
flink	pointer
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
alias_link	pointer
)	O
{	O
if	O
(	O
!	O
(	O
new_flags	int
&	O
FL_SYM_LINK	O
)	O
)	O
reparent_children	function
(	O
flink	pointer
,	O
alias_link	pointer
)	O
;	O
}	O
else	O
if	O
(	O
sub_dirs_vec	pointer
==	O
0	int
)	O
walk_dir	function
(	O
flink	pointer
)	O
;	O
else	O
dynvec_append	function
(	O
sub_dirs_vec	pointer
,	O
flink	pointer
)	O
;	O
}	O
else	O
{	O
struct	O
member_file	struct
*	O
member	pointer
;	O
member	pointer
=	O
maybe_get_member_file	function
(	O
flink	pointer
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
member	pointer
)	O
{	O
if	O
(	O
st	struct
.	O
st_size	long
>	O
largest_member_file	long
)	O
largest_member_file	long
=	O
st	struct
.	O
st_size	long
;	O
if	O
(	O
walker_verbose_flag	int
)	O
print_member_file	function
(	O
member	pointer
)	O
;	O
}	O
}	O
}	O
void	O
reparent_children	function
(	O
struct	O
file_link	struct
*	O
dlink	pointer
,	O
struct	O
file_link	struct
*	O
slink	pointer
)	O
{	O
void	O
*	O
*	O
slot	pointer
=	O
idh	struct
.	O
idh_file_link_table	struct
.	O
ht_vec	pointer
;	O
void	O
*	O
*	O
end	pointer
=	O
&	O
idh	struct
.	O
idh_file_link_table	struct
.	O
ht_vec	pointer
[	O
idh	struct
.	O
idh_file_link_table	struct
.	O
ht_size	long
]	O
;	O
for	O
(	O
;	O
slot	pointer
<	O
end	pointer
;	O
slot	pointer
++	O
)	O
{	O
if	O
(	O
!	O
HASH_VACANT	O
(	O
*	O
slot	pointer
)	O
)	O
{	O
struct	O
file_link	struct
*	O
child	pointer
=	O
(	O
struct	O
file_link	struct
*	O
)	O
*	O
slot	pointer
;	O
if	O
(	O
child	pointer
->	O
fl_parent	O
==	O
slink	pointer
)	O
{	O
void	O
*	O
*	O
new_slot	pointer
;	O
*	O
slot	pointer
=	O
hash_deleted_item	pointer
;	O
child	pointer
->	O
fl_parent	O
=	O
dlink	pointer
;	O
new_slot	pointer
=	O
hash_find_slot	function
(	O
&	O
idh	struct
.	O
idh_file_link_table	struct
,	O
child	pointer
)	O
;	O
*	O
new_slot	pointer
=	O
child	pointer
;	O
}	O
}	O
}	O
}	O
void	O
mark_member_file_links	function
(	O
struct	O
idhead	struct
*	O
idhp	pointer
)	O
{	O
struct	O
member_file	struct
*	O
*	O
members_0	pointer
=	O
(	O
struct	O
member_file	struct
*	O
*	O
)	O
hash_dump	function
(	O
&	O
idhp	pointer
->	O
idh_member_file_table	struct
,	O
0	int
,	O
member_file_qsort_compare	function
)	O
;	O
struct	O
member_file	struct
*	O
*	O
end	pointer
=	O
&	O
members_0	pointer
[	O
idhp	pointer
->	O
idh_member_file_table	struct
.	O
ht_fill	long
]	O
;	O
struct	O
member_file	struct
*	O
*	O
members	pointer
;	O
long	O
new_index	long
=	O
0	int
;	O
for	O
(	O
members	pointer
=	O
members_0	pointer
;	O
members	pointer
<	O
end	pointer
;	O
members	pointer
++	O
)	O
{	O
struct	O
member_file	struct
*	O
member	pointer
=	O
*	O
members	pointer
;	O
struct	O
file_link	struct
*	O
flink	pointer
;	O
member	pointer
->	O
mf_index	long
=	O
new_index	long
++	O
;	O
for	O
(	O
flink	pointer
=	O
member	pointer
->	O
mf_link	pointer
;	O
!	O
(	O
flink	pointer
->	O
fl_flags	char
&	O
FL_USED	O
)	O
;	O
flink	pointer
=	O
flink	pointer
->	O
fl_parent	O
)	O
flink	pointer
->	O
fl_flags	char
|=	O
FL_USED	O
;	O
}	O
free	function
(	O
members_0	pointer
)	O
;	O
}	O
struct	O
member_file	struct
*	O
maybe_get_member_file	function
(	O
struct	O
file_link	struct
*	O
flink	pointer
,	O
struct	O
stat	struct
*	O
stp	pointer
)	O
{	O
struct	O
file_link	struct
*	O
alias_link	pointer
;	O
struct	O
member_file	struct
*	O
member	pointer
;	O
struct	O
member_file	struct
*	O
alias_member	pointer
=	O
0	int
;	O
member	pointer
=	O
get_member_file	function
(	O
flink	pointer
)	O
;	O
alias_link	pointer
=	O
find_alias_link	function
(	O
flink	pointer
,	O
stp	pointer
)	O
;	O
if	O
(	O
alias_link	pointer
)	O
alias_member	pointer
=	O
find_member_file	function
(	O
alias_link	pointer
)	O
;	O
if	O
(	O
member	pointer
&&	O
alias_member	pointer
)	O
{	O
int	O
ancestry	int
=	O
symlink_ancestry	function
(	O
flink	pointer
)	O
;	O
int	O
alias_ancestry	int
=	O
symlink_ancestry	function
(	O
alias_link	pointer
)	O
;	O
if	O
(	O
member	pointer
->	O
mf_lang_args	pointer
!=	O
alias_member	pointer
->	O
mf_lang_args	pointer
)	O
{	O
char	O
*	O
file_name	pointer
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
char	O
*	O
alias_file_name	pointer
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
absolute_file_name	function
(	O
file_name	pointer
,	O
flink	pointer
)	O
;	O
absolute_file_name	function
(	O
alias_file_name	pointer
,	O
alias_link	pointer
)	O
;	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: `%s' and `%s' are the same file, but yield different scans!"	pointer
)	O
,	O
file_name	pointer
,	O
alias_file_name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
alias_ancestry	int
>	O
ancestry	int
)	O
{	O
hash_delete	function
(	O
&	O
idh	struct
.	O
idh_member_file_table	struct
,	O
member	pointer
)	O
;	O
member	pointer
->	O
mf_link	pointer
->	O
fl_flags	char
&=	O
~	O
FL_MEMBER	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
hash_delete	function
(	O
&	O
idh	struct
.	O
idh_member_file_table	struct
,	O
alias_member	pointer
)	O
;	O
alias_member	pointer
->	O
mf_link	pointer
->	O
fl_flags	char
&=	O
~	O
FL_MEMBER	O
;	O
}	O
}	O
return	O
member	pointer
;	O
}	O
struct	O
file_link	struct
*	O
find_alias_link	function
(	O
struct	O
file_link	struct
*	O
flink	pointer
,	O
struct	O
stat	struct
*	O
stp	pointer
)	O
{	O
struct	O
dev_ino	struct
*	O
dev_ino	struct
;	O
struct	O
dev_ino	struct
*	O
*	O
slot	pointer
;	O
dev_ino	struct
=	O
(	O
struct	O
dev_ino	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
idh	struct
.	O
idh_dev_ino_obstack	struct
,	O
sizeof	O
(	O
struct	O
dev_ino	struct
)	O
)	O
;	O
dev_ino	struct
->	O
di_dev	long
=	O
stp	pointer
->	O
st_dev	long
;	O
dev_ino	struct
->	O
di_ino	long
=	O
stp	pointer
->	O
st_ino	long
;	O
slot	pointer
=	O
(	O
struct	O
dev_ino	struct
*	O
*	O
)	O
hash_find_slot	function
(	O
&	O
idh	struct
.	O
idh_dev_ino_table	struct
,	O
dev_ino	struct
)	O
;	O
if	O
(	O
HASH_VACANT	O
(	O
*	O
slot	pointer
)	O
)	O
{	O
dev_ino	struct
->	O
di_link	pointer
=	O
flink	pointer
;	O
hash_insert_at	function
(	O
&	O
idh	struct
.	O
idh_dev_ino_table	struct
,	O
dev_ino	struct
,	O
slot	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
obstack_free	function
(	O
&	O
idh	struct
.	O
idh_dev_ino_obstack	struct
,	O
dev_ino	struct
)	O
;	O
return	O
(	O
*	O
slot	pointer
)	O
->	O
di_link	pointer
;	O
}	O
}	O
int	O
symlink_ancestry	function
(	O
struct	O
file_link	struct
*	O
flink	pointer
)	O
{	O
int	O
ancestry	int
=	O
0	int
;	O
while	O
(	O
!	O
IS_ROOT_FILE_LINK	O
(	O
flink	pointer
)	O
)	O
{	O
if	O
(	O
flink	pointer
->	O
fl_flags	char
&	O
FL_SYM_LINK	O
)	O
return	O
ancestry	int
;	O
ancestry	int
++	O
;	O
flink	pointer
=	O
flink	pointer
->	O
fl_parent	O
;	O
}	O
return	O
PATH_MAX	int
;	O
}	O
struct	O
member_file	struct
*	O
get_member_file	function
(	O
struct	O
file_link	struct
*	O
flink	pointer
)	O
{	O
struct	O
member_file	struct
*	O
member	pointer
;	O
struct	O
member_file	struct
*	O
*	O
slot	pointer
;	O
struct	O
lang_args	struct
const	O
*	O
args	pointer
;	O
args	pointer
=	O
get_lang_args	function
(	O
flink	pointer
)	O
;	O
if	O
(	O
args	pointer
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
lang_wanted	function
(	O
args	pointer
->	O
la_language	pointer
->	O
lg_name	pointer
)	O
)	O
return	O
0	int
;	O
member	pointer
=	O
(	O
struct	O
member_file	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
idh	struct
.	O
idh_member_file_obstack	struct
,	O
sizeof	O
(	O
struct	O
member_file	struct
)	O
)	O
;	O
member	pointer
->	O
mf_link	pointer
=	O
flink	pointer
;	O
slot	pointer
=	O
(	O
struct	O
member_file	struct
*	O
*	O
)	O
hash_find_slot	function
(	O
&	O
idh	struct
.	O
idh_member_file_table	struct
,	O
member	pointer
)	O
;	O
if	O
(	O
HASH_VACANT	O
(	O
*	O
slot	pointer
)	O
)	O
{	O
member	pointer
->	O
mf_index	long
=	O
-	O
1	int
;	O
hash_insert_at	function
(	O
&	O
idh	struct
.	O
idh_member_file_table	struct
,	O
member	pointer
,	O
slot	pointer
)	O
;	O
flink	pointer
->	O
fl_flags	char
|=	O
FL_MEMBER	O
;	O
}	O
else	O
{	O
obstack_free	function
(	O
&	O
idh	struct
.	O
idh_member_file_obstack	struct
,	O
member	pointer
)	O
;	O
member	pointer
=	O
*	O
slot	pointer
;	O
}	O
member	pointer
->	O
mf_lang_args	pointer
=	O
args	pointer
;	O
return	O
member	pointer
;	O
}	O
struct	O
member_file	struct
*	O
find_member_file	function
(	O
struct	O
file_link	struct
const	O
*	O
flink	pointer
)	O
{	O
struct	O
member_file	struct
key	pointer
;	O
struct	O
member_file	struct
*	O
*	O
slot	pointer
;	O
key	pointer
.	O
mf_link	pointer
=	O
(	O
struct	O
file_link	struct
*	O
)	O
flink	pointer
;	O
slot	pointer
=	O
(	O
struct	O
member_file	struct
*	O
*	O
)	O
hash_find_slot	function
(	O
&	O
idh	struct
.	O
idh_member_file_table	struct
,	O
&	O
key	pointer
)	O
;	O
if	O
(	O
HASH_VACANT	O
(	O
*	O
slot	pointer
)	O
)	O
return	O
0	int
;	O
return	O
*	O
slot	pointer
;	O
}	O
struct	O
lang_args	struct
*	O
get_lang_args	function
(	O
struct	O
file_link	struct
const	O
*	O
flink	pointer
)	O
{	O
struct	O
lang_args	struct
*	O
args	pointer
=	O
lang_args_list	pointer
;	O
char	O
*	O
file_name	pointer
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
while	O
(	O
args	pointer
)	O
{	O
if	O
(	O
strchr	function
(	O
args	pointer
->	O
la_pattern	pointer
,	O
SLASH_CHAR	char
)	O
)	O
{	O
absolute_file_name	function
(	O
file_name	pointer
,	O
flink	pointer
)	O
;	O
if	O
(	O
fnmatch	function
(	O
args	pointer
->	O
la_pattern	pointer
,	O
file_name	pointer
,	O
MAYBE_FNM_CASEFOLD	int
|	O
FNM_FILE_NAME	O
)	O
==	O
0	int
)	O
return	O
(	O
args	pointer
->	O
la_language	pointer
?	O
args	pointer
:	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
fnmatch	function
(	O
args	pointer
->	O
la_pattern	pointer
,	O
flink	pointer
->	O
fl_name	array
,	O
MAYBE_FNM_CASEFOLD	int
)	O
==	O
0	int
)	O
return	O
(	O
args	pointer
->	O
la_language	pointer
?	O
args	pointer
:	O
0	int
)	O
;	O
}	O
args	pointer
=	O
args	pointer
->	O
la_next	pointer
;	O
}	O
return	O
(	O
(	O
lang_args_default	pointer
&&	O
lang_args_default	pointer
->	O
la_language	pointer
)	O
?	O
lang_args_default	pointer
:	O
0	int
)	O
;	O
}	O
void	O
print_member_file	function
(	O
struct	O
member_file	struct
*	O
member	pointer
)	O
{	O
char	O
*	O
file_name	pointer
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
absolute_file_name	function
(	O
file_name	pointer
,	O
member	pointer
->	O
mf_link	pointer
)	O
;	O
printf	function
(	O
"%ld: %s: %s\n"	pointer
,	O
idh	struct
.	O
idh_member_file_table	struct
.	O
ht_fill	long
-	O
1	int
,	O
member	pointer
->	O
mf_lang_args	pointer
->	O
la_language	pointer
->	O
lg_name	pointer
,	O
file_name	pointer
)	O
;	O
}	O
static	O
char	O
*	O
*	O
langs_included	pointer
;	O
static	O
char	O
*	O
*	O
langs_excluded	pointer
;	O
int	O
lang_wanted	function
(	O
char	O
const	O
*	O
lang_name	pointer
)	O
{	O
if	O
(	O
langs_excluded	pointer
)	O
return	O
!	O
string_in_vector	function
(	O
lang_name	pointer
,	O
langs_excluded	pointer
)	O
;	O
else	O
if	O
(	O
langs_included	pointer
)	O
return	O
string_in_vector	function
(	O
lang_name	pointer
,	O
langs_included	pointer
)	O
;	O
else	O
return	O
1	int
;	O
}	O
void	O
include_languages	function
(	O
char	O
*	O
lang_names	pointer
)	O
{	O
if	O
(	O
langs_excluded	pointer
)	O
error	function
(	O
1	int
,	O
0	int
,	O
"can't mix --include and --exclude options"	pointer
)	O
;	O
langs_included	pointer
=	O
append_strings_to_vector	function
(	O
langs_included	pointer
,	O
lang_names	pointer
,	O
white_space	array
)	O
;	O
}	O
void	O
exclude_languages	function
(	O
char	O
*	O
lang_names	pointer
)	O
{	O
if	O
(	O
langs_excluded	pointer
)	O
error	function
(	O
1	int
,	O
0	int
,	O
"can't mix --include and --exclude options"	pointer
)	O
;	O
langs_excluded	pointer
=	O
append_strings_to_vector	function
(	O
langs_excluded	pointer
,	O
lang_names	pointer
,	O
white_space	array
)	O
;	O
}	O
char	O
*	O
*	O
append_strings_to_vector	function
(	O
char	O
*	O
*	O
vector_0	pointer
,	O
char	O
*	O
string	pointer
,	O
char	O
const	O
*	O
delimiter_class	pointer
)	O
{	O
char	O
*	O
*	O
vector	pointer
;	O
if	O
(	O
vector_0	pointer
)	O
{	O
int	O
length	int
=	O
vector_length	function
(	O
vector_0	pointer
)	O
;	O
vector_0	pointer
=	O
xrealloc	function
(	O
vector_0	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
length	int
+	O
2	int
+	O
strlen	function
(	O
string	pointer
)	O
/	O
2	int
)	O
)	O
;	O
vector	pointer
=	O
&	O
vector_0	pointer
[	O
length	int
]	O
;	O
}	O
else	O
vector	pointer
=	O
vector_0	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
2	int
+	O
strlen	function
(	O
string	pointer
)	O
/	O
2	int
)	O
)	O
;	O
do	O
*	O
vector	pointer
=	O
strsep	function
(	O
&	O
string	pointer
,	O
delimiter_class	pointer
)	O
;	O
while	O
(	O
*	O
vector	pointer
++	O
)	O
;	O
return	O
xrealloc	function
(	O
vector_0	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
vector	pointer
-	O
vector_0	pointer
)	O
)	O
;	O
}	O
int	O
vector_length	function
(	O
char	O
*	O
*	O
vector	pointer
)	O
{	O
int	O
length	int
=	O
0	int
;	O
while	O
(	O
*	O
vector	pointer
++	O
)	O
length	int
++	O
;	O
return	O
length	int
;	O
}	O
int	O
string_in_vector	function
(	O
char	O
const	O
*	O
string	pointer
,	O
char	O
*	O
*	O
vector	pointer
)	O
{	O
while	O
(	O
*	O
vector	pointer
)	O
if	O
(	O
strequ	O
(	O
string	pointer
,	O
*	O
vector	pointer
++	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
struct	O
file_link	struct
*	O
parse_file_name	function
(	O
char	O
*	O
file_name	pointer
,	O
struct	O
file_link	struct
*	O
relative_dir_link	pointer
)	O
{	O
struct	O
file_link	struct
*	O
flink	pointer
;	O
char	O
*	O
*	O
links_0	pointer
;	O
char	O
*	O
*	O
links	pointer
;	O
if	O
(	O
IS_ABSOLUTE	O
(	O
file_name	pointer
)	O
)	O
{	O
flink	pointer
=	O
get_link_from_string	function
(	O
SLASH_STRING	pointer
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
relative_dir_link	pointer
)	O
flink	pointer
=	O
relative_dir_link	pointer
;	O
else	O
if	O
(	O
current_dir_link	pointer
)	O
flink	pointer
=	O
current_dir_link	pointer
;	O
else	O
flink	pointer
=	O
get_current_dir_link	function
(	O
)	O
;	O
links	pointer
=	O
links_0	pointer
=	O
vectorize_string	function
(	O
file_name	pointer
,	O
SLASH_STRING	pointer
)	O
;	O
while	O
(	O
*	O
links	pointer
)	O
{	O
char	O
const	O
*	O
link_name	pointer
=	O
*	O
links	pointer
++	O
;	O
if	O
(	O
*	O
link_name	pointer
==	O
'\0'	O
||	O
IS_DOT	O
(	O
link_name	pointer
)	O
)	O
;	O
else	O
if	O
(	O
IS_DOT_DOT	O
(	O
link_name	pointer
)	O
)	O
flink	pointer
=	O
flink	pointer
->	O
fl_parent	O
;	O
else	O
{	O
struct	O
stat	struct
st	struct
;	O
flink	pointer
=	O
get_link_from_string	function
(	O
link_name	pointer
,	O
flink	pointer
)	O
;	O
if	O
(	O
!	O
flink	pointer
->	O
fl_flags	char
)	O
{	O
flink	pointer
->	O
fl_flags	char
=	O
classify_link	function
(	O
flink	pointer
,	O
&	O
st	struct
)	O
;	O
if	O
(	O
!	O
flink	pointer
->	O
fl_flags	char
)	O
return	O
0	int
;	O
}	O
}	O
}	O
free	function
(	O
links_0	pointer
)	O
;	O
return	O
flink	pointer
;	O
}	O
struct	O
file_link	struct
*	O
get_current_dir_link	function
(	O
void	O
)	O
{	O
struct	O
file_link	struct
*	O
dir_link	pointer
;	O
char	O
*	O
cwd_0	pointer
;	O
char	O
*	O
cwd	pointer
;	O
char	O
*	O
xcwd	pointer
=	O
0	int
;	O
char	O
*	O
*	O
links_0	pointer
;	O
char	O
*	O
*	O
links	pointer
;	O
if	O
(	O
current_dir_link	pointer
)	O
return	O
current_dir_link	pointer
;	O
cwd_0	pointer
=	O
"."	pointer
;	O
if	O
(	O
cwd_0	pointer
)	O
cwd_0	pointer
=	O
strdup	function
(	O
cwd_0	pointer
)	O
;	O
if	O
(	O
!	O
same_as_dot	function
(	O
cwd_0	pointer
)	O
)	O
cwd_0	pointer
=	O
xcwd	pointer
=	O
xgetcwd	function
(	O
)	O
;	O
if	O
(	O
cwd_0	pointer
==	O
0	int
)	O
error	function
(	O
1	int
,	O
errno	O
,	O
_	O
(	O
"can't get working directory"	pointer
)	O
)	O
;	O
cwd	pointer
=	O
cwd_0	pointer
;	O
dir_link	pointer
=	O
get_link_from_string	function
(	O
SLASH_STRING	pointer
,	O
0	int
)	O
;	O
dir_link	pointer
->	O
fl_flags	char
=	O
(	O
dir_link	pointer
->	O
fl_flags	char
&	O
~	O
FL_TYPE_MASK	O
)	O
|	O
FL_TYPE_DIR	O
;	O
links	pointer
=	O
links_0	pointer
=	O
vectorize_string	function
(	O
cwd	pointer
,	O
SLASH_STRING	pointer
)	O
;	O
while	O
(	O
*	O
links	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
char	O
const	O
*	O
link_name	pointer
=	O
*	O
links	pointer
++	O
;	O
dir_link	pointer
=	O
get_link_from_string	function
(	O
link_name	pointer
,	O
dir_link	pointer
)	O
;	O
if	O
(	O
!	O
dir_link	pointer
->	O
fl_flags	char
)	O
dir_link	pointer
->	O
fl_flags	char
=	O
classify_link	function
(	O
dir_link	pointer
,	O
&	O
st	struct
)	O
;	O
}	O
chdir_to_link	function
(	O
dir_link	pointer
)	O
;	O
free	function
(	O
links_0	pointer
)	O
;	O
if	O
(	O
xcwd	pointer
)	O
free	function
(	O
xcwd	pointer
)	O
;	O
current_dir_link	pointer
=	O
dir_link	pointer
;	O
return	O
dir_link	pointer
;	O
}	O
static	O
int	O
same_as_dot	function
(	O
char	O
const	O
*	O
cwd	pointer
)	O
{	O
struct	O
stat	struct
cwd_st	struct
;	O
struct	O
stat	struct
dot_st	struct
;	O
if	O
(	O
cwd	pointer
==	O
0	int
||	O
*	O
cwd	pointer
!=	O
'/'	O
||	O
stat	struct
(	O
cwd	pointer
,	O
&	O
cwd_st	struct
)	O
<	O
0	int
||	O
stat	struct
(	O
"."	pointer
,	O
&	O
dot_st	struct
)	O
<	O
0	int
)	O
return	O
0	int
;	O
return	O
(	O
(	O
cwd_st	struct
.	O
st_ino	long
==	O
dot_st	struct
.	O
st_ino	long
)	O
&&	O
(	O
cwd_st	struct
.	O
st_dev	long
==	O
dot_st	struct
.	O
st_dev	long
)	O
)	O
;	O
}	O
int	O
chdir_to_link	function
(	O
struct	O
file_link	struct
*	O
dir_link	pointer
)	O
{	O
char	O
*	O
to_dir_name	pointer
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
if	O
(	O
current_dir_link	pointer
==	O
dir_link	pointer
)	O
return	O
1	int
;	O
if	O
(	O
current_dir_link	pointer
)	O
maybe_relative_file_name	function
(	O
to_dir_name	pointer
,	O
dir_link	pointer
,	O
current_dir_link	pointer
)	O
;	O
else	O
absolute_file_name	function
(	O
to_dir_name	pointer
,	O
dir_link	pointer
)	O
;	O
if	O
(	O
chdir	function
(	O
to_dir_name	pointer
)	O
<	O
0	int
)	O
{	O
if	O
(	O
IS_ABSOLUTE	O
(	O
to_dir_name	pointer
)	O
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't chdir to `%s'"	pointer
)	O
,	O
to_dir_name	pointer
)	O
;	O
else	O
{	O
char	O
*	O
from_dir_name	pointer
=	O
alloca	O
(	O
PATH_MAX	int
)	O
;	O
absolute_file_name	function
(	O
from_dir_name	pointer
,	O
current_dir_link	pointer
)	O
;	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't chdir to `%s' from `%s'"	pointer
)	O
,	O
to_dir_name	pointer
,	O
from_dir_name	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
else	O
{	O
current_dir_link	pointer
=	O
dir_link	pointer
;	O
return	O
1	int
;	O
}	O
}	O
char	O
*	O
*	O
vectorize_string	function
(	O
char	O
*	O
string	pointer
,	O
char	O
const	O
*	O
delimiter_class	pointer
)	O
{	O
char	O
*	O
*	O
vector_0	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
2	int
+	O
strlen	function
(	O
string	pointer
)	O
/	O
2	int
)	O
)	O
;	O
char	O
*	O
*	O
vector	pointer
=	O
vector_0	pointer
;	O
*	O
vector	pointer
++	O
=	O
strsep	function
(	O
&	O
string	pointer
,	O
delimiter_class	pointer
)	O
;	O
if	O
(	O
vector	pointer
[	O
-	O
1	int
]	O
)	O
{	O
if	O
(	O
vector	pointer
[	O
-	O
1	int
]	O
[	O
0	int
]	O
==	O
'\0'	O
)	O
vector	pointer
--	O
;	O
do	O
*	O
vector	pointer
=	O
strsep	function
(	O
&	O
string	pointer
,	O
delimiter_class	pointer
)	O
;	O
while	O
(	O
*	O
vector	pointer
++	O
)	O
;	O
}	O
return	O
xrealloc	function
(	O
vector_0	pointer
,	O
sizeof	O
(	O
char	O
*	O
)	O
*	O
(	O
vector	pointer
-	O
vector_0	pointer
)	O
)	O
;	O
}	O
void	O
prune_file_names	function
(	O
char	O
*	O
str	pointer
,	O
struct	O
file_link	struct
*	O
from_link	pointer
)	O
{	O
char	O
*	O
*	O
file_names_0	pointer
=	O
vectorize_string	function
(	O
str	pointer
,	O
white_space	array
)	O
;	O
char	O
*	O
*	O
file_names	pointer
=	O
file_names_0	pointer
;	O
while	O
(	O
*	O
file_names	pointer
)	O
{	O
struct	O
file_link	struct
*	O
flink	pointer
=	O
parse_file_name	function
(	O
*	O
file_names	pointer
++	O
,	O
from_link	pointer
)	O
;	O
if	O
(	O
flink	pointer
)	O
flink	pointer
->	O
fl_flags	char
|=	O
FL_PRUNE	O
;	O
}	O
free	function
(	O
file_names_0	pointer
)	O
;	O
}	O
int	O
classify_link	function
(	O
struct	O
file_link	struct
*	O
flink	pointer
,	O
struct	O
stat	struct
*	O
stp	pointer
)	O
{	O
unsigned	O
int	O
flags	pointer
=	O
0	int
;	O
if	O
(	O
!	O
chdir_to_link	function
(	O
flink	pointer
->	O
fl_parent	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
lstat	function
(	O
flink	pointer
->	O
fl_name	array
,	O
stp	pointer
)	O
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't lstat `%s' from `%s'"	pointer
)	O
,	O
flink	pointer
->	O
fl_name	array
,	O
xgetcwd	function
(	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
S_ISLNK	O
(	O
stp	pointer
->	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
stat	struct
(	O
flink	pointer
->	O
fl_name	array
,	O
stp	pointer
)	O
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"can't stat `%s' from `%s'"	pointer
)	O
,	O
flink	pointer
->	O
fl_name	array
,	O
xgetcwd	function
(	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
flags	pointer
|=	O
FL_SYM_LINK	O
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
stp	pointer
->	O
st_mode	int
)	O
)	O
flags	pointer
|=	O
FL_TYPE_DIR	O
;	O
else	O
if	O
(	O
stp	pointer
->	O
st_size	long
==	O
0	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
S_ISREG	O
(	O
stp	pointer
->	O
st_mode	int
)	O
)	O
flags	pointer
|=	O
FL_TYPE_FILE	O
;	O
else	O
return	O
0	int
;	O
return	O
flags	pointer
;	O
}	O
struct	O
file_link	struct
*	O
get_link_from_dirent	function
(	O
struct	O
dirent	struct
*	O
dirent	struct
,	O
struct	O
file_link	struct
*	O
parent	pointer
)	O
{	O
struct	O
file_link	struct
*	O
*	O
slot	pointer
;	O
struct	O
file_link	struct
*	O
new_link	pointer
;	O
new_link	pointer
=	O
make_link_from_dirent	function
(	O
dirent	struct
,	O
parent	pointer
)	O
;	O
slot	pointer
=	O
(	O
struct	O
file_link	struct
*	O
*	O
)	O
hash_find_slot	function
(	O
&	O
idh	struct
.	O
idh_file_link_table	struct
,	O
new_link	pointer
)	O
;	O
if	O
(	O
HASH_VACANT	O
(	O
*	O
slot	pointer
)	O
)	O
slot	pointer
=	O
(	O
struct	O
file_link	struct
*	O
*	O
)	O
hash_insert_at	function
(	O
&	O
idh	struct
.	O
idh_file_link_table	struct
,	O
new_link	pointer
,	O
slot	pointer
)	O
;	O
else	O
obstack_free	function
(	O
&	O
idh	struct
.	O
idh_file_link_obstack	struct
,	O
new_link	pointer
)	O
;	O
return	O
*	O
slot	pointer
;	O
}	O
struct	O
file_link	struct
*	O
get_link_from_string	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
parent	pointer
)	O
{	O
struct	O
file_link	struct
*	O
*	O
slot	pointer
;	O
struct	O
file_link	struct
*	O
new_link	pointer
;	O
new_link	pointer
=	O
make_link_from_string	function
(	O
name	pointer
,	O
parent	pointer
)	O
;	O
slot	pointer
=	O
(	O
struct	O
file_link	struct
*	O
*	O
)	O
hash_find_slot	function
(	O
&	O
idh	struct
.	O
idh_file_link_table	struct
,	O
new_link	pointer
)	O
;	O
if	O
(	O
HASH_VACANT	O
(	O
*	O
slot	pointer
)	O
)	O
slot	pointer
=	O
(	O
struct	O
file_link	struct
*	O
*	O
)	O
hash_insert_at	function
(	O
&	O
idh	struct
.	O
idh_file_link_table	struct
,	O
new_link	pointer
,	O
slot	pointer
)	O
;	O
else	O
obstack_free	function
(	O
&	O
idh	struct
.	O
idh_file_link_obstack	struct
,	O
new_link	pointer
)	O
;	O
return	O
*	O
slot	pointer
;	O
}	O
struct	O
file_link	struct
*	O
make_link_from_dirent	function
(	O
struct	O
dirent	struct
*	O
dirent	struct
,	O
struct	O
file_link	struct
*	O
parent	pointer
)	O
{	O
struct	O
file_link	struct
*	O
flink	pointer
;	O
flink	pointer
=	O
(	O
struct	O
file_link	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
idh	struct
.	O
idh_file_link_obstack	struct
,	O
sizeof	O
(	O
struct	O
file_link	struct
)	O
+	O
strlen	function
(	O
dirent	struct
->	O
d_name	array
)	O
)	O
;	O
strcpy	function
(	O
flink	pointer
->	O
fl_name	array
,	O
dirent	struct
->	O
d_name	array
)	O
;	O
flink	pointer
->	O
fl_parent	O
=	O
parent	pointer
?	O
parent	pointer
:	O
flink	pointer
;	O
flink	pointer
->	O
fl_flags	char
=	O
0	int
;	O
return	O
flink	pointer
;	O
}	O
struct	O
file_link	struct
*	O
make_link_from_string	function
(	O
char	O
const	O
*	O
name	pointer
,	O
struct	O
file_link	struct
*	O
parent	pointer
)	O
{	O
struct	O
file_link	struct
*	O
flink	pointer
;	O
flink	pointer
=	O
(	O
struct	O
file_link	struct
*	O
)	O
obstack_alloc	O
(	O
&	O
idh	struct
.	O
idh_file_link_obstack	struct
,	O
sizeof	O
(	O
struct	O
file_link	struct
)	O
+	O
strlen	function
(	O
name	pointer
)	O
)	O
;	O
strcpy	function
(	O
flink	pointer
->	O
fl_name	array
,	O
name	pointer
)	O
;	O
flink	pointer
->	O
fl_parent	O
=	O
parent	pointer
?	O
parent	pointer
:	O
flink	pointer
;	O
flink	pointer
->	O
fl_flags	char
=	O
0	int
;	O
return	O
flink	pointer
;	O
}	O
struct	O
file_link	struct
const	O
*	O
*	O
fill_link_vector	function
(	O
struct	O
file_link	struct
const	O
*	O
*	O
vec_buf	pointer
,	O
struct	O
file_link	struct
const	O
*	O
flink	pointer
)	O
{	O
vec_buf	pointer
=	O
fill_link_vector_1	function
(	O
vec_buf	pointer
,	O
flink	pointer
)	O
;	O
*	O
vec_buf	pointer
=	O
0	int
;	O
return	O
vec_buf	pointer
;	O
}	O
struct	O
file_link	struct
const	O
*	O
*	O
fill_link_vector_1	function
(	O
struct	O
file_link	struct
const	O
*	O
*	O
vec_buf	pointer
,	O
struct	O
file_link	struct
const	O
*	O
flink	pointer
)	O
{	O
if	O
(	O
!	O
IS_ROOT_FILE_LINK	O
(	O
flink	pointer
)	O
)	O
vec_buf	pointer
=	O
fill_link_vector_1	function
(	O
vec_buf	pointer
,	O
flink	pointer
->	O
fl_parent	O
)	O
;	O
*	O
vec_buf	pointer
++	O
=	O
flink	pointer
;	O
return	O
vec_buf	pointer
;	O
}	O
char	O
*	O
maybe_relative_file_name	function
(	O
char	O
*	O
buf_0	pointer
,	O
struct	O
file_link	struct
const	O
*	O
to_link	pointer
,	O
struct	O
file_link	struct
const	O
*	O
from_link	pointer
)	O
{	O
struct	O
file_link	struct
const	O
*	O
*	O
to_link_vec_0	pointer
=	O
alloca	O
(	O
sizeof	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
*	O
(	O
PATH_MAX	int
/	O
2	int
)	O
)	O
;	O
struct	O
file_link	struct
const	O
*	O
*	O
from_link_vec_0	pointer
=	O
alloca	O
(	O
sizeof	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
*	O
(	O
PATH_MAX	int
/	O
2	int
)	O
)	O
;	O
struct	O
file_link	struct
const	O
*	O
*	O
to_link_vec	pointer
=	O
to_link_vec_0	pointer
;	O
struct	O
file_link	struct
const	O
*	O
*	O
from_link_vec	pointer
=	O
from_link_vec_0	pointer
;	O
struct	O
file_link	struct
const	O
*	O
*	O
from_link_end	pointer
;	O
struct	O
file_link	struct
const	O
*	O
*	O
from_links	pointer
;	O
int	O
alloc_me	int
=	O
(	O
buf_0	pointer
==	O
0	int
)	O
;	O
char	O
*	O
buf	pointer
;	O
int	O
levels	int
;	O
if	O
(	O
from_link	pointer
==	O
0	int
)	O
from_link	pointer
=	O
current_dir_link	pointer
;	O
if	O
(	O
alloc_me	int
)	O
buf_0	pointer
=	O
xmalloc	function
(	O
PATH_MAX	int
)	O
;	O
if	O
(	O
to_link	pointer
==	O
from_link	pointer
)	O
strcpy	function
(	O
buf_0	pointer
,	O
"."	pointer
)	O
;	O
else	O
if	O
(	O
to_link	pointer
->	O
fl_parent	O
==	O
from_link	pointer
)	O
strcpy	function
(	O
buf_0	pointer
,	O
to_link	pointer
->	O
fl_name	array
)	O
;	O
else	O
if	O
(	O
from_link	pointer
->	O
fl_flags	char
&	O
FL_SYM_LINK	O
)	O
absolute_file_name	function
(	O
buf_0	pointer
,	O
to_link	pointer
)	O
;	O
else	O
if	O
(	O
to_link	pointer
==	O
from_link	pointer
->	O
fl_parent	O
)	O
strcpy	function
(	O
buf_0	pointer
,	O
".."	pointer
)	O
;	O
else	O
if	O
(	O
to_link	pointer
->	O
fl_parent	O
==	O
from_link	pointer
->	O
fl_parent	O
)	O
{	O
strcpy	function
(	O
buf_0	pointer
,	O
DOT_DOT_SLASH	pointer
)	O
;	O
strcpy	function
(	O
&	O
buf_0	pointer
[	O
3	int
]	O
,	O
to_link	pointer
->	O
fl_name	array
)	O
;	O
}	O
else	O
{	O
from_link_end	pointer
=	O
fill_link_vector	function
(	O
from_link_vec	pointer
,	O
from_link	pointer
)	O
;	O
fill_link_vector	function
(	O
to_link_vec	pointer
,	O
to_link	pointer
)	O
;	O
while	O
(	O
*	O
to_link_vec	pointer
==	O
*	O
from_link_vec	pointer
)	O
{	O
if	O
(	O
*	O
to_link_vec	pointer
==	O
0	int
)	O
{	O
strcpy	function
(	O
buf_0	pointer
,	O
"."	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
to_link_vec	pointer
++	O
;	O
from_link_vec	pointer
++	O
;	O
}	O
levels	int
=	O
from_link_end	pointer
-	O
from_link_vec	pointer
;	O
if	O
(	O
levels	int
>=	O
(	O
from_link_vec	pointer
-	O
from_link_vec_0	pointer
)	O
)	O
{	O
absolute_file_name	function
(	O
buf_0	pointer
,	O
to_link	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
for	O
(	O
from_links	pointer
=	O
from_link_vec	pointer
;	O
*	O
from_links	pointer
;	O
from_links	pointer
++	O
)	O
if	O
(	O
(	O
*	O
from_links	pointer
)	O
->	O
fl_flags	char
&	O
FL_SYM_LINK	O
)	O
{	O
absolute_file_name	function
(	O
buf_0	pointer
,	O
to_link	pointer
)	O
;	O
goto	O
out	O
;	O
}	O
buf	pointer
=	O
fill_dot_dots	function
(	O
buf_0	pointer
,	O
levels	int
)	O
;	O
if	O
(	O
*	O
to_link_vec	pointer
==	O
0	int
)	O
*	O
--	O
buf	pointer
=	O
'\0'	O
;	O
else	O
{	O
do	O
{	O
strcpy	function
(	O
buf	pointer
,	O
(	O
*	O
to_link_vec	pointer
)	O
->	O
fl_name	array
)	O
;	O
buf	pointer
+=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
(	O
*	O
to_link_vec	pointer
)	O
->	O
fl_name	array
[	O
0	int
]	O
!=	O
SLASH_CHAR	char
&&	O
*	O
++	O
to_link_vec	pointer
)	O
*	O
buf	pointer
++	O
=	O
SLASH_CHAR	char
;	O
}	O
while	O
(	O
*	O
to_link_vec	pointer
)	O
;	O
}	O
}	O
out	O
:	O
if	O
(	O
alloc_me	int
)	O
buf_0	pointer
=	O
xrealloc	function
(	O
buf_0	pointer
,	O
(	O
1	int
+	O
strlen	function
(	O
buf_0	pointer
)	O
)	O
)	O
;	O
return	O
buf_0	pointer
;	O
}	O
char	O
*	O
fill_dot_dots	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
levels	int
)	O
{	O
while	O
(	O
levels	int
--	O
)	O
{	O
strcpy	function
(	O
buf	pointer
,	O
DOT_DOT_SLASH	pointer
)	O
;	O
buf	pointer
+=	O
3	int
;	O
}	O
return	O
buf	pointer
;	O
}	O
char	O
*	O
absolute_file_name	function
(	O
char	O
*	O
buf_0	pointer
,	O
struct	O
file_link	struct
const	O
*	O
flink	pointer
)	O
{	O
char	O
*	O
end	pointer
;	O
int	O
alloc_me	int
=	O
(	O
buf_0	pointer
==	O
0	int
)	O
;	O
if	O
(	O
alloc_me	int
)	O
buf_0	pointer
=	O
xmalloc	function
(	O
PATH_MAX	int
)	O
;	O
end	pointer
=	O
absolute_file_name_1	function
(	O
buf_0	pointer
,	O
flink	pointer
)	O
;	O
if	O
(	O
end	pointer
>	O
&	O
buf_0	pointer
[	O
1	int
]	O
)	O
end	pointer
--	O
;	O
*	O
end	pointer
++	O
=	O
'\0'	O
;	O
if	O
(	O
alloc_me	int
)	O
buf_0	pointer
=	O
xrealloc	function
(	O
buf_0	pointer
,	O
(	O
size_t	long
)	O
(	O
end	pointer
-	O
buf_0	pointer
)	O
)	O
;	O
return	O
buf_0	pointer
;	O
}	O
static	O
char	O
*	O
absolute_file_name_1	function
(	O
char	O
*	O
buf	pointer
,	O
struct	O
file_link	struct
const	O
*	O
flink	pointer
)	O
{	O
char	O
*	O
end	pointer
;	O
if	O
(	O
IS_ROOT_FILE_LINK	O
(	O
flink	pointer
)	O
)	O
end	pointer
=	O
buf	pointer
;	O
else	O
end	pointer
=	O
absolute_file_name_1	function
(	O
buf	pointer
,	O
flink	pointer
->	O
fl_parent	O
)	O
;	O
strcpy	function
(	O
end	pointer
,	O
flink	pointer
->	O
fl_name	array
)	O
;	O
if	O
(	O
*	O
end	pointer
==	O
SLASH_CHAR	char
)	O
end	pointer
++	O
;	O
else	O
{	O
end	pointer
+=	O
strlen	function
(	O
end	pointer
)	O
;	O
*	O
end	pointer
++	O
=	O
SLASH_CHAR	char
;	O
}	O
return	O
end	pointer
;	O
}	O
unsigned	O
long	O
member_file_hash_1	function
(	O
void	O
const	O
*	O
key	pointer
)	O
{	O
return_ADDRESS_HASH_1	O
(	O
(	O
(	O
struct	O
member_file	struct
const	O
*	O
)	O
key	pointer
)	O
->	O
mf_link	pointer
)	O
;	O
}	O
unsigned	O
long	O
member_file_hash_2	function
(	O
void	O
const	O
*	O
key	pointer
)	O
{	O
return_ADDRESS_HASH_2	O
(	O
(	O
(	O
struct	O
member_file	struct
const	O
*	O
)	O
key	pointer
)	O
->	O
mf_link	pointer
)	O
;	O
}	O
int	O
member_file_hash_compare	function
(	O
void	O
const	O
*	O
x	pointer
,	O
void	O
const	O
*	O
y	pointer
)	O
{	O
return_ADDRESS_COMPARE	O
(	O
(	O
(	O
struct	O
member_file	struct
const	O
*	O
)	O
x	pointer
)	O
->	O
mf_link	pointer
,	O
(	O
(	O
struct	O
member_file	struct
const	O
*	O
)	O
y	pointer
)	O
->	O
mf_link	pointer
)	O
;	O
}	O
int	O
member_file_qsort_compare	function
(	O
void	O
const	O
*	O
x	pointer
,	O
void	O
const	O
*	O
y	pointer
)	O
{	O
struct	O
member_file	struct
const	O
*	O
mfx	pointer
=	O
*	O
(	O
struct	O
member_file	struct
const	O
*	O
const	O
*	O
)	O
x	pointer
;	O
struct	O
member_file	struct
const	O
*	O
mfy	pointer
=	O
*	O
(	O
struct	O
member_file	struct
const	O
*	O
const	O
*	O
)	O
y	pointer
;	O
int	O
result	long
;	O
INTEGER_COMPARE	O
(	O
mfx	pointer
->	O
mf_lang_args	pointer
->	O
la_index	int
,	O
mfy	pointer
->	O
mf_lang_args	pointer
->	O
la_index	int
,	O
result	long
)	O
;	O
if	O
(	O
result	long
)	O
return	O
result	long
;	O
else	O
{	O
struct	O
file_link	struct
const	O
*	O
flx	pointer
=	O
mfx	pointer
->	O
mf_link	pointer
;	O
struct	O
file_link	struct
const	O
*	O
fly	pointer
=	O
mfy	pointer
->	O
mf_link	pointer
;	O
if	O
(	O
flx	pointer
->	O
fl_parent	O
==	O
fly	pointer
->	O
fl_parent	O
)	O
return	O
strcmp	function
(	O
flx	pointer
->	O
fl_name	array
,	O
fly	pointer
->	O
fl_name	array
)	O
;	O
result	long
=	O
(	O
links_depth	function
(	O
flx	pointer
)	O
-	O
links_depth	function
(	O
fly	pointer
)	O
)	O
;	O
if	O
(	O
result	long
)	O
return	O
result	long
;	O
while	O
(	O
flx	pointer
->	O
fl_parent	O
!=	O
fly	pointer
->	O
fl_parent	O
)	O
{	O
flx	pointer
=	O
flx	pointer
->	O
fl_parent	O
;	O
fly	pointer
=	O
fly	pointer
->	O
fl_parent	O
;	O
}	O
return	O
strcmp	function
(	O
flx	pointer
->	O
fl_name	array
,	O
fly	pointer
->	O
fl_name	array
)	O
;	O
}	O
}	O
unsigned	O
long	O
file_link_hash_1	function
(	O
void	O
const	O
*	O
key	pointer
)	O
{	O
unsigned	O
long	O
result	long
=	O
0	int
;	O
struct	O
file_link	struct
const	O
*	O
parent	pointer
=	O
(	O
IS_ROOT_FILE_LINK	O
(	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
key	pointer
)	O
)	O
?	O
0	int
:	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
key	pointer
)	O
->	O
fl_parent	O
)	O
;	O
STRING_HASH_1	O
(	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
key	pointer
)	O
->	O
fl_name	array
,	O
result	long
)	O
;	O
ADDRESS_HASH_1	O
(	O
parent	pointer
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
unsigned	O
long	O
file_link_hash_2	function
(	O
void	O
const	O
*	O
key	pointer
)	O
{	O
unsigned	O
long	O
result	long
=	O
0	int
;	O
struct	O
file_link	struct
const	O
*	O
parent	pointer
=	O
(	O
IS_ROOT_FILE_LINK	O
(	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
key	pointer
)	O
)	O
?	O
0	int
:	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
key	pointer
)	O
->	O
fl_parent	O
)	O
;	O
STRING_HASH_2	O
(	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
key	pointer
)	O
->	O
fl_name	array
,	O
result	long
)	O
;	O
ADDRESS_HASH_2	O
(	O
parent	pointer
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
int	O
file_link_hash_compare	function
(	O
void	O
const	O
*	O
x	pointer
,	O
void	O
const	O
*	O
y	pointer
)	O
{	O
int	O
result	long
;	O
struct	O
file_link	struct
const	O
*	O
x_parent	pointer
=	O
(	O
IS_ROOT_FILE_LINK	O
(	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
x	pointer
)	O
)	O
?	O
0	int
:	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
x	pointer
)	O
->	O
fl_parent	O
)	O
;	O
struct	O
file_link	struct
const	O
*	O
y_parent	pointer
=	O
(	O
IS_ROOT_FILE_LINK	O
(	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
y	pointer
)	O
)	O
?	O
0	int
:	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
y	pointer
)	O
->	O
fl_parent	O
)	O
;	O
ADDRESS_COMPARE	O
(	O
x_parent	pointer
,	O
y_parent	pointer
,	O
result	long
)	O
;	O
if	O
(	O
result	long
)	O
return	O
result	long
;	O
STRING_COMPARE	O
(	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
x	pointer
)	O
->	O
fl_name	array
,	O
(	O
(	O
struct	O
file_link	struct
const	O
*	O
)	O
y	pointer
)	O
->	O
fl_name	array
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
int	O
links_depth	function
(	O
struct	O
file_link	struct
const	O
*	O
flink	pointer
)	O
{	O
int	O
depth	int
=	O
0	int
;	O
while	O
(	O
!	O
IS_ROOT_FILE_LINK	O
(	O
flink	pointer
)	O
)	O
{	O
depth	int
++	O
;	O
flink	pointer
=	O
flink	pointer
->	O
fl_parent	O
;	O
}	O
return	O
depth	int
;	O
}	O
unsigned	O
long	O
dev_ino_hash_1	function
(	O
void	O
const	O
*	O
key	pointer
)	O
{	O
unsigned	O
long	O
result	long
=	O
0	int
;	O
INTEGER_HASH_1	O
(	O
(	O
(	O
struct	O
dev_ino	struct
const	O
*	O
)	O
key	pointer
)	O
->	O
di_dev	long
,	O
result	long
)	O
;	O
INTEGER_HASH_1	O
(	O
(	O
(	O
struct	O
dev_ino	struct
const	O
*	O
)	O
key	pointer
)	O
->	O
di_ino	long
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
unsigned	O
long	O
dev_ino_hash_2	function
(	O
void	O
const	O
*	O
key	pointer
)	O
{	O
unsigned	O
long	O
result	long
=	O
0	int
;	O
INTEGER_HASH_2	O
(	O
(	O
(	O
struct	O
dev_ino	struct
const	O
*	O
)	O
key	pointer
)	O
->	O
di_dev	long
,	O
result	long
)	O
;	O
INTEGER_HASH_2	O
(	O
(	O
(	O
struct	O
dev_ino	struct
const	O
*	O
)	O
key	pointer
)	O
->	O
di_ino	long
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
int	O
dev_ino_hash_compare	function
(	O
void	O
const	O
*	O
x	pointer
,	O
void	O
const	O
*	O
y	pointer
)	O
{	O
int	O
result	long
;	O
INTEGER_COMPARE	O
(	O
(	O
(	O
struct	O
dev_ino	struct
const	O
*	O
)	O
x	pointer
)	O
->	O
di_ino	long
,	O
(	O
(	O
struct	O
dev_ino	struct
const	O
*	O
)	O
y	pointer
)	O
->	O
di_ino	long
,	O
result	long
)	O
;	O
if	O
(	O
result	long
)	O
return	O
result	long
;	O
INTEGER_COMPARE	O
(	O
(	O
(	O
struct	O
dev_ino	struct
const	O
*	O
)	O
x	pointer
)	O
->	O
di_dev	long
,	O
(	O
(	O
struct	O
dev_ino	struct
const	O
*	O
)	O
y	pointer
)	O
->	O
di_dev	long
,	O
result	long
)	O
;	O
return	O
result	long
;	O
}	O
struct	O
file_link	struct
*	O
init_walker	function
(	O
struct	O
idhead	struct
*	O
idhp	pointer
)	O
{	O
init_idh_obstacks	function
(	O
idhp	pointer
)	O
;	O
init_idh_tables	function
(	O
idhp	pointer
)	O
;	O
return	O
get_current_dir_link	function
(	O
)	O
;	O
}	O
void	O
init_idh_obstacks	function
(	O
struct	O
idhead	struct
*	O
idhp	pointer
)	O
{	O
obstack_init	O
(	O
&	O
idhp	pointer
->	O
idh_member_file_obstack	struct
)	O
;	O
obstack_init	O
(	O
&	O
idhp	pointer
->	O
idh_file_link_obstack	struct
)	O
;	O
obstack_init	O
(	O
&	O
idhp	pointer
->	O
idh_dev_ino_obstack	struct
)	O
;	O
}	O
void	O
init_idh_tables	function
(	O
struct	O
idhead	struct
*	O
idhp	pointer
)	O
{	O
hash_init	function
(	O
&	O
idhp	pointer
->	O
idh_member_file_table	struct
,	O
16	int
*	O
1024	int
,	O
member_file_hash_1	function
,	O
member_file_hash_2	function
,	O
member_file_hash_compare	function
)	O
;	O
hash_init	function
(	O
&	O
idhp	pointer
->	O
idh_file_link_table	struct
,	O
16	int
*	O
1024	int
,	O
file_link_hash_1	function
,	O
file_link_hash_2	function
,	O
file_link_hash_compare	function
)	O
;	O
hash_init	function
(	O
&	O
idhp	pointer
->	O
idh_dev_ino_table	struct
,	O
16	int
*	O
1024	int
,	O
dev_ino_hash_1	function
,	O
dev_ino_hash_2	function
,	O
dev_ino_hash_compare	function
)	O
;	O
}	O
