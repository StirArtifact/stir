typedef	O
struct	O
{	O
int	O
n	int
;	O
int	O
flags	int
;	O
SLsmg_Char_Type	struct
*	O
old	pointer
,	O
*	O
neew	pointer
;	O
unsigned	O
long	O
old_hash	long
,	O
new_hash	long
;	O
}	O
Screen_Type	struct
;	O
static	O
int	O
Screen_Trashed	int
;	O
static	O
Screen_Type	struct
SL_Screen	array
[	O
SLTT_MAX_SCREEN_ROWS	int
]	O
;	O
static	O
int	O
Start_Col	int
,	O
Start_Row	int
;	O
static	O
unsigned	O
int	O
Screen_Cols	int
,	O
Screen_Rows	int
;	O
static	O
int	O
This_Row	int
,	O
This_Col	int
;	O
static	O
SLsmg_Color_Type	short
This_Color	short
;	O
static	O
int	O
UTF8_Mode	int
=	O
-	O
1	int
;	O
static	O
int	O
Bce_Color_Offset	int
;	O
int	O
SLsmg_Newline_Behavior	int
=	O
SLSMG_NEWLINE_IGNORED	int
;	O
int	O
SLsmg_Backspace_Moves	int
=	O
0	int
;	O
static	O
int	O
Embedded_Escape_Mode	int
=	O
0	int
;	O
int	O
SLsmg_embedded_escape_mode	function
(	O
int	O
mode	int
)	O
{	O
int	O
old_mode	int
=	O
Embedded_Escape_Mode	int
;	O
Embedded_Escape_Mode	int
=	O
mode	int
;	O
return	O
old_mode	int
;	O
}	O
static	O
int	O
parse_embedded_escape	function
(	O
SLuchar_Type	char
*	O
u	pointer
,	O
SLuchar_Type	char
*	O
umax	pointer
,	O
SLsmg_Color_Type	short
default_color	short
,	O
SLuchar_Type	char
*	O
*	O
up	pointer
,	O
SLsmg_Color_Type	short
*	O
colorp	pointer
)	O
{	O
unsigned	O
int	O
val	int
;	O
SLuchar_Type	char
ch	int
;	O
if	O
(	O
(	O
u	pointer
<	O
umax	pointer
)	O
&&	O
(	O
*	O
u	pointer
!=	O
'['	O
)	O
)	O
return	O
-	O
1	int
;	O
u	pointer
++	O
;	O
if	O
(	O
(	O
u	pointer
<	O
umax	pointer
)	O
&&	O
(	O
(	O
*	O
u	pointer
==	O
'm'	O
)	O
||	O
(	O
*	O
u	pointer
==	O
']'	O
)	O
)	O
)	O
{	O
*	O
colorp	pointer
=	O
default_color	short
;	O
*	O
up	pointer
=	O
u	pointer
+	O
1	int
;	O
return	O
0	int
;	O
}	O
val	int
=	O
0	int
;	O
while	O
(	O
(	O
u	pointer
<	O
umax	pointer
)	O
&&	O
(	O
(	O
(	O
ch	int
=	O
*	O
u	pointer
)	O
>=	O
'0'	O
)	O
&&	O
(	O
ch	int
<=	O
'9'	O
)	O
)	O
)	O
{	O
val	int
=	O
10	int
*	O
val	int
+	O
(	O
ch	int
-	O
'0'	O
)	O
;	O
u	pointer
++	O
;	O
}	O
if	O
(	O
(	O
u	pointer
<	O
umax	pointer
)	O
&&	O
(	O
(	O
*	O
u	pointer
==	O
'm'	O
)	O
||	O
(	O
*	O
u	pointer
==	O
']'	O
)	O
)	O
&&	O
(	O
val	int
<=	O
SLSMG_MAX_COLORS	int
)	O
)	O
{	O
val	int
+=	O
Bce_Color_Offset	int
;	O
*	O
colorp	pointer
=	O
(	O
SLsmg_Color_Type	short
)	O
val	int
;	O
*	O
up	pointer
=	O
u	pointer
+	O
1	int
;	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
parse_embedded_set_color	function
(	O
SLuchar_Type	char
*	O
u	pointer
,	O
SLuchar_Type	char
*	O
umax	pointer
,	O
SLsmg_Color_Type	short
default_color	short
)	O
{	O
SLsmg_Color_Type	short
color	short
=	O
default_color	short
;	O
while	O
(	O
u	pointer
<	O
umax	pointer
)	O
{	O
if	O
(	O
*	O
u	pointer
++	O
==	O
033	int
)	O
(	O
void	O
)	O
parse_embedded_escape	function
(	O
u	pointer
,	O
umax	pointer
,	O
default_color	short
,	O
&	O
u	pointer
,	O
&	O
color	short
)	O
;	O
}	O
if	O
(	O
color	short
==	O
default_color	short
)	O
return	O
;	O
color	short
-=	O
Bce_Color_Offset	int
;	O
SLsmg_set_color	function
(	O
color	short
)	O
;	O
}	O
static	O
int	O
*	O
tt_Screen_Rows	pointer
=	O
NULL	O
;	O
static	O
int	O
*	O
tt_Screen_Cols	pointer
=	O
NULL	O
;	O
static	O
int	O
*	O
tt_unicode_ok	pointer
;	O
static	O
void	O
(	O
*	O
tt_normal_video	pointer
)	O
(	O
void	O
)	O
;	O
static	O
void	O
(	O
*	O
tt_goto_rc	pointer
)	O
(	O
int	O
,	O
int	O
)	O
;	O
static	O
void	O
(	O
*	O
tt_cls	pointer
)	O
(	O
void	O
)	O
;	O
static	O
void	O
(	O
*	O
tt_del_eol	pointer
)	O
(	O
void	O
)	O
;	O
static	O
void	O
(	O
*	O
tt_smart_puts	pointer
)	O
(	O
SLsmg_Char_Type	struct
*	O
,	O
SLsmg_Char_Type	struct
*	O
,	O
int	O
,	O
int	O
)	O
;	O
static	O
int	O
(	O
*	O
tt_flush_output	pointer
)	O
(	O
void	O
)	O
;	O
static	O
int	O
(	O
*	O
tt_reset_video	pointer
)	O
(	O
void	O
)	O
;	O
static	O
int	O
(	O
*	O
tt_init_video	pointer
)	O
(	O
void	O
)	O
;	O
static	O
void	O
(	O
*	O
tt_set_scroll_region	pointer
)	O
(	O
int	O
,	O
int	O
)	O
;	O
static	O
void	O
(	O
*	O
tt_reverse_index	pointer
)	O
(	O
int	O
)	O
;	O
static	O
void	O
(	O
*	O
tt_reset_scroll_region	pointer
)	O
(	O
void	O
)	O
;	O
static	O
void	O
(	O
*	O
tt_delete_nlines	pointer
)	O
(	O
int	O
)	O
;	O
static	O
int	O
*	O
tt_Term_Cannot_Scroll	pointer
;	O
static	O
int	O
*	O
tt_Has_Alt_Charset	pointer
;	O
static	O
char	O
*	O
*	O
tt_Graphics_Char_Pairs	pointer
;	O
static	O
int	O
Smg_Inited	int
;	O
static	O
void	O
init_tt_symbols	function
(	O
void	O
)	O
{	O
tt_Screen_Rows	pointer
=	O
&	O
SLtt_Screen_Rows	int
;	O
tt_Screen_Cols	pointer
=	O
&	O
SLtt_Screen_Cols	int
;	O
tt_unicode_ok	pointer
=	O
&	O
_pSLtt_UTF8_Mode	int
;	O
tt_normal_video	pointer
=	O
SLtt_normal_video	function
;	O
tt_goto_rc	pointer
=	O
SLtt_goto_rc	function
;	O
tt_cls	pointer
=	O
SLtt_cls	function
;	O
tt_del_eol	pointer
=	O
SLtt_del_eol	function
;	O
tt_smart_puts	pointer
=	O
SLtt_smart_puts	function
;	O
tt_flush_output	pointer
=	O
SLtt_flush_output	function
;	O
tt_reset_video	pointer
=	O
SLtt_reset_video	function
;	O
tt_init_video	pointer
=	O
SLtt_init_video	function
;	O
tt_set_scroll_region	pointer
=	O
SLtt_set_scroll_region	function
;	O
tt_reverse_index	pointer
=	O
SLtt_reverse_index	function
;	O
tt_reset_scroll_region	pointer
=	O
SLtt_reset_scroll_region	function
;	O
tt_delete_nlines	pointer
=	O
SLtt_delete_nlines	function
;	O
tt_Term_Cannot_Scroll	pointer
=	O
&	O
SLtt_Term_Cannot_Scroll	int
;	O
tt_Has_Alt_Charset	pointer
=	O
&	O
SLtt_Has_Alt_Charset	int
;	O
tt_Graphics_Char_Pairs	pointer
=	O
&	O
SLtt_Graphics_Char_Pairs	pointer
;	O
}	O
static	O
SLwchar_Type	int
ACS_Map	array
[	O
128	int
]	O
;	O
typedef	O
struct	O
{	O
unsigned	O
char	O
vt100_char	char
;	O
unsigned	O
char	O
ascii	char
;	O
SLwchar_Type	int
unicode	int
;	O
}	O
ACS_Def_Type	struct
;	O
static	O
SLCONST	O
ACS_Def_Type	struct
UTF8_ACS_Map	array
[	O
]	O
=	O
{	O
{	O
'+'	O
,	O
'>'	O
,	O
0x2192	int
}	O
,	O
{	O
','	O
,	O
'<'	O
,	O
0x2190	int
}	O
,	O
{	O
'-'	O
,	O
'^'	O
,	O
0x2191	int
}	O
,	O
{	O
'.'	O
,	O
'v'	O
,	O
0x2193	int
}	O
,	O
{	O
'0'	O
,	O
'#'	O
,	O
0x25AE	int
}	O
,	O
{	O
'`'	O
,	O
'+'	O
,	O
0x25C6	int
}	O
,	O
{	O
'a'	O
,	O
':'	O
,	O
0x2592	int
}	O
,	O
{	O
'f'	O
,	O
'\''	O
,	O
0x00B0	int
}	O
,	O
{	O
'g'	O
,	O
'#'	O
,	O
0x00B1	int
}	O
,	O
{	O
'h'	O
,	O
'#'	O
,	O
0x2592	int
}	O
,	O
{	O
'i'	O
,	O
'#'	O
,	O
0x2603	int
}	O
,	O
{	O
'j'	O
,	O
'+'	O
,	O
0x2518	int
}	O
,	O
{	O
'k'	O
,	O
'+'	O
,	O
0x2510	int
}	O
,	O
{	O
'l'	O
,	O
'+'	O
,	O
0x250c	int
}	O
,	O
{	O
'm'	O
,	O
'+'	O
,	O
0x2514	int
}	O
,	O
{	O
'n'	O
,	O
'+'	O
,	O
0x253C	int
}	O
,	O
{	O
'o'	O
,	O
'~'	O
,	O
0x23BA	int
}	O
,	O
{	O
'p'	O
,	O
'-'	O
,	O
0x23BB	int
}	O
,	O
{	O
'q'	O
,	O
'-'	O
,	O
0x2500	int
}	O
,	O
{	O
'r'	O
,	O
'-'	O
,	O
0x23BC	int
}	O
,	O
{	O
's'	O
,	O
'_'	O
,	O
0x23BD	int
}	O
,	O
{	O
't'	O
,	O
'+'	O
,	O
0x251C	int
}	O
,	O
{	O
'u'	O
,	O
'+'	O
,	O
0x2524	int
}	O
,	O
{	O
'v'	O
,	O
'+'	O
,	O
0x2534	int
}	O
,	O
{	O
'w'	O
,	O
'+'	O
,	O
0x252C	int
}	O
,	O
{	O
'x'	O
,	O
'|'	O
,	O
0x2502	int
}	O
,	O
{	O
'y'	O
,	O
'<'	O
,	O
0x2264	int
}	O
,	O
{	O
'z'	O
,	O
'>'	O
,	O
0x2265	int
}	O
,	O
{	O
'{'	O
,	O
'*'	O
,	O
0x03C0	int
}	O
,	O
{	O
'|'	O
,	O
'!'	O
,	O
0x2260	int
}	O
,	O
{	O
'}'	O
,	O
'f'	O
,	O
0x00A3	int
}	O
,	O
{	O
'~'	O
,	O
'o'	O
,	O
0x00B7	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
int	O
Current_ACS_Mode	int
=	O
ACS_MODE_NONE	O
;	O
static	O
void	O
init_acs	function
(	O
int	O
mode	int
)	O
{	O
unsigned	O
int	O
i	array
;	O
SLCONST	O
ACS_Def_Type	struct
*	O
acs	pointer
;	O
if	O
(	O
Current_ACS_Mode	int
==	O
mode	int
)	O
return	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
0x80	int
;	O
i	array
++	O
)	O
ACS_Map	array
[	O
i	array
]	O
=	O
' '	O
;	O
if	O
(	O
mode	int
==	O
ACS_MODE_AUTO	int
)	O
{	O
if	O
(	O
UTF8_Mode	int
&&	O
(	O
tt_unicode_ok	pointer
!=	O
NULL	O
)	O
&&	O
(	O
*	O
tt_unicode_ok	pointer
>	O
0	int
)	O
)	O
mode	int
=	O
ACS_MODE_UNICODE	int
;	O
else	O
mode	int
=	O
ACS_MODE_TERMINFO	int
;	O
}	O
switch	O
(	O
mode	int
)	O
{	O
case	O
ACS_MODE_UNICODE	int
:	O
SLsmg_Display_Eight_Bit	int
=	O
0xA0	int
;	O
acs	pointer
=	O
UTF8_ACS_Map	array
;	O
while	O
(	O
acs	pointer
->	O
vt100_char	char
!=	O
0	int
)	O
{	O
ACS_Map	array
[	O
acs	pointer
->	O
vt100_char	char
]	O
=	O
acs	pointer
->	O
unicode	int
;	O
acs	pointer
++	O
;	O
}	O
break	O
;	O
case	O
ACS_MODE_TERMINFO	int
:	O
if	O
(	O
(	O
tt_Has_Alt_Charset	pointer
!=	O
NULL	O
)	O
&&	O
*	O
tt_Has_Alt_Charset	pointer
&&	O
(	O
tt_Graphics_Char_Pairs	pointer
!=	O
NULL	O
)	O
&&	O
(	O
*	O
tt_Graphics_Char_Pairs	pointer
!=	O
NULL	O
)	O
)	O
{	O
unsigned	O
char	O
*	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
*	O
tt_Graphics_Char_Pairs	pointer
;	O
unsigned	O
char	O
*	O
pmax	pointer
=	O
p	pointer
+	O
strlen	function
(	O
(	O
char	O
*	O
)	O
p	pointer
)	O
;	O
while	O
(	O
p	pointer
<	O
pmax	pointer
)	O
{	O
unsigned	O
char	O
ch	int
=	O
*	O
p	pointer
++	O
;	O
ACS_Map	array
[	O
ch	int
&	O
0x7F	int
]	O
=	O
*	O
p	pointer
++	O
;	O
}	O
break	O
;	O
}	O
mode	int
=	O
ACS_MODE_ASCII	int
;	O
case	O
ACS_MODE_ASCII	int
:	O
default	O
:	O
acs	pointer
=	O
UTF8_ACS_Map	array
;	O
while	O
(	O
acs	pointer
->	O
vt100_char	char
!=	O
0	int
)	O
{	O
ACS_Map	array
[	O
acs	pointer
->	O
vt100_char	char
]	O
=	O
acs	pointer
->	O
ascii	char
;	O
acs	pointer
++	O
;	O
}	O
break	O
;	O
}	O
Current_ACS_Mode	int
=	O
mode	int
;	O
}	O
static	O
void	O
blank_line	function
(	O
SLsmg_Char_Type	struct
*	O
c	int
,	O
unsigned	O
int	O
n	int
,	O
SLwchar_Type	int
wch	int
)	O
{	O
SLsmg_Char_Type	struct
*	O
cmax	pointer
=	O
c	int
+	O
n	int
;	O
SLsmg_Color_Type	short
color	short
=	O
This_Color	short
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
c	int
,	O
0	int
,	O
n	int
*	O
sizeof	O
(	O
SLsmg_Char_Type	struct
)	O
)	O
;	O
while	O
(	O
c	int
<	O
cmax	pointer
)	O
{	O
c	int
->	O
nchars	int
=	O
1	int
;	O
c	int
->	O
wchars	array
[	O
0	int
]	O
=	O
wch	int
;	O
c	int
->	O
color	short
=	O
color	short
;	O
c	int
++	O
;	O
}	O
}	O
static	O
void	O
clear_region	function
(	O
int	O
row	int
,	O
int	O
n	int
,	O
SLwchar_Type	int
ch	int
)	O
{	O
int	O
i	array
;	O
int	O
imax	int
=	O
row	int
+	O
n	int
;	O
if	O
(	O
imax	int
>	O
(	O
int	O
)	O
Screen_Rows	int
)	O
imax	int
=	O
(	O
int	O
)	O
Screen_Rows	int
;	O
if	O
(	O
row	int
<	O
0	int
)	O
row	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
row	int
;	O
i	array
<	O
imax	int
;	O
i	array
++	O
)	O
{	O
blank_line	function
(	O
SL_Screen	array
[	O
i	array
]	O
.	O
neew	pointer
,	O
Screen_Cols	int
,	O
ch	int
)	O
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
flags	int
|=	O
TOUCHED	int
;	O
}	O
}	O
void	O
SLsmg_erase_eol	function
(	O
void	O
)	O
{	O
int	O
r	pointer
,	O
c	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
c	int
=	O
This_Col	int
-	O
Start_Col	int
;	O
r	pointer
=	O
This_Row	int
-	O
Start_Row	int
;	O
if	O
(	O
(	O
r	pointer
<	O
0	int
)	O
||	O
(	O
r	pointer
>=	O
(	O
int	O
)	O
Screen_Rows	int
)	O
)	O
return	O
;	O
if	O
(	O
c	int
<	O
0	int
)	O
c	int
=	O
0	int
;	O
else	O
if	O
(	O
c	int
>=	O
(	O
int	O
)	O
Screen_Cols	int
)	O
return	O
;	O
blank_line	function
(	O
SL_Screen	array
[	O
This_Row	int
]	O
.	O
neew	pointer
+	O
c	int
,	O
Screen_Cols	int
-	O
c	int
,	O
0x20	int
)	O
;	O
SL_Screen	array
[	O
This_Row	int
]	O
.	O
flags	int
|=	O
TOUCHED	int
;	O
}	O
static	O
void	O
scroll_up	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
i	array
,	O
imax	int
;	O
SLsmg_Char_Type	struct
*	O
neew	pointer
;	O
neew	pointer
=	O
SL_Screen	array
[	O
0	int
]	O
.	O
neew	pointer
;	O
imax	int
=	O
Screen_Rows	int
-	O
1	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
imax	int
;	O
i	array
++	O
)	O
{	O
SL_Screen	array
[	O
i	array
]	O
.	O
neew	pointer
=	O
SL_Screen	array
[	O
i	array
+	O
1	int
]	O
.	O
neew	pointer
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
flags	int
|=	O
TOUCHED	int
;	O
}	O
SL_Screen	array
[	O
i	array
]	O
.	O
neew	pointer
=	O
neew	pointer
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
flags	int
|=	O
TOUCHED	int
;	O
blank_line	function
(	O
neew	pointer
,	O
Screen_Cols	int
,	O
0x20	int
)	O
;	O
This_Row	int
--	O
;	O
}	O
void	O
SLsmg_gotorc	function
(	O
int	O
r	pointer
,	O
int	O
c	int
)	O
{	O
This_Row	int
=	O
r	pointer
;	O
This_Col	int
=	O
c	int
;	O
}	O
int	O
SLsmg_get_row	function
(	O
void	O
)	O
{	O
return	O
This_Row	int
;	O
}	O
int	O
SLsmg_get_column	function
(	O
void	O
)	O
{	O
return	O
This_Col	int
;	O
}	O
void	O
SLsmg_erase_eos	function
(	O
void	O
)	O
{	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
SLsmg_erase_eol	function
(	O
)	O
;	O
clear_region	function
(	O
This_Row	int
+	O
1	int
,	O
(	O
int	O
)	O
Screen_Rows	int
,	O
0x20	int
)	O
;	O
}	O
static	O
int	O
This_Alt_Char	int
;	O
void	O
SLsmg_set_char_set	function
(	O
int	O
i	array
)	O
{	O
if	O
(	O
i	array
!=	O
0	int
)	O
This_Alt_Char	int
=	O
SLSMG_ACS_MASK	int
;	O
else	O
This_Alt_Char	int
=	O
0	int
;	O
This_Color	short
&=	O
SLSMG_COLOR_MASK	int
;	O
This_Color	short
|=	O
This_Alt_Char	int
;	O
}	O
void	O
SLsmg_set_color	function
(	O
SLsmg_Color_Type	short
color	short
)	O
{	O
color	short
+=	O
Bce_Color_Offset	int
;	O
This_Color	short
=	O
color	short
|	O
This_Alt_Char	int
;	O
}	O
void	O
SLsmg_reverse_video	function
(	O
void	O
)	O
{	O
SLsmg_set_color	function
(	O
1	int
)	O
;	O
}	O
void	O
SLsmg_normal_video	function
(	O
void	O
)	O
{	O
SLsmg_set_color	function
(	O
0	int
)	O
;	O
}	O
static	O
int	O
point_visible	function
(	O
int	O
col_too	int
)	O
{	O
return	O
(	O
(	O
This_Row	int
>=	O
Start_Row	int
)	O
&&	O
(	O
This_Row	int
<	O
Start_Row	int
+	O
(	O
int	O
)	O
Screen_Rows	int
)	O
&&	O
(	O
(	O
col_too	int
==	O
0	int
)	O
||	O
(	O
(	O
This_Col	int
>=	O
Start_Col	int
)	O
&&	O
(	O
This_Col	int
<	O
Start_Col	int
+	O
(	O
int	O
)	O
Screen_Cols	int
)	O
)	O
)	O
)	O
;	O
}	O
void	O
SLsmg_write_chars	function
(	O
unsigned	O
char	O
*	O
u	pointer
,	O
unsigned	O
char	O
*	O
umax	pointer
)	O
{	O
SLsmg_Char_Type	struct
*	O
p	pointer
,	O
*	O
pmax	pointer
;	O
SLsmg_Color_Type	short
color	short
;	O
int	O
flags	int
;	O
int	O
col	int
,	O
start_col	int
,	O
max_col	int
;	O
int	O
newline_flag	int
;	O
int	O
utf8_mode	int
=	O
UTF8_Mode	int
;	O
unsigned	O
char	O
display_8bit	char
;	O
int	O
last_was_double_width	int
=	O
0	int
;	O
int	O
alt_char_set_flag	int
;	O
unsigned	O
int	O
i	array
;	O
SLsmg_Color_Type	short
default_color	short
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
display_8bit	char
=	O
(	O
unsigned	O
char	O
)	O
SLsmg_Display_Eight_Bit	int
;	O
if	O
(	O
utf8_mode	int
)	O
display_8bit	char
=	O
0xA0	int
;	O
color	short
=	O
This_Color	short
;	O
alt_char_set_flag	int
=	O
(	O
color	short
&	O
SLSMG_ACS_MASK	int
)	O
;	O
if	O
(	O
Current_ACS_Mode	int
==	O
ACS_MODE_UNICODE	int
)	O
color	short
=	O
color	short
&	O
~	O
SLSMG_ACS_MASK	int
;	O
default_color	short
=	O
color	short
;	O
top	O
:	O
newline_flag	int
=	O
0	int
;	O
start_col	int
=	O
Start_Col	int
;	O
if	O
(	O
point_visible	function
(	O
0	int
)	O
==	O
0	int
)	O
return	O
;	O
col	int
=	O
This_Col	int
;	O
max_col	int
=	O
start_col	int
+	O
Screen_Cols	int
;	O
p	pointer
=	O
SL_Screen	array
[	O
This_Row	int
-	O
Start_Row	int
]	O
.	O
neew	pointer
;	O
pmax	pointer
=	O
p	pointer
+	O
Screen_Cols	int
;	O
if	O
(	O
col	int
>=	O
start_col	int
)	O
{	O
p	pointer
+=	O
(	O
col	int
-	O
start_col	int
)	O
;	O
if	O
(	O
(	O
p	pointer
<	O
pmax	pointer
)	O
&&	O
(	O
p	pointer
->	O
nchars	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
col	int
>	O
start_col	int
)	O
{	O
p	pointer
--	O
;	O
p	pointer
->	O
nchars	int
=	O
1	int
;	O
p	pointer
->	O
wchars	array
[	O
0	int
]	O
=	O
' '	O
;	O
p	pointer
++	O
;	O
}	O
}	O
}	O
flags	int
=	O
SL_Screen	array
[	O
This_Row	int
-	O
Start_Row	int
]	O
.	O
flags	int
;	O
i	array
=	O
0	int
;	O
while	O
(	O
u	pointer
<	O
umax	pointer
)	O
{	O
SLwchar_Type	int
wc	int
;	O
unsigned	O
int	O
width	int
,	O
nconsumed	int
;	O
if	O
(	O
*	O
u	pointer
<	O
(	O
SLuchar_Type	char
)	O
0x80	int
)	O
{	O
unsigned	O
char	O
ch	int
;	O
ch	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
u	pointer
++	O
;	O
if	O
(	O
alt_char_set_flag	int
)	O
{	O
wc	int
=	O
ACS_Map	array
[	O
ch	int
]	O
;	O
ADD_CHAR_OR_BREAK	O
(	O
wc	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ch	int
>=	O
(	O
SLuchar_Type	char
)	O
0x20	int
)	O
&&	O
(	O
ch	int
<	O
(	O
SLuchar_Type	char
)	O
0x7F	int
)	O
)	O
{	O
ADD_CHAR_OR_BREAK	O
(	O
ch	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ch	int
==	O
'\t'	O
)	O
&&	O
(	O
SLsmg_Tab_Width	int
>	O
0	int
)	O
)	O
{	O
do	O
{	O
if	O
(	O
col	int
<	O
start_col	int
)	O
col	int
++	O
;	O
else	O
{	O
ADD_CHAR_OR_BREAK	O
(	O
' '	O
)	O
;	O
NEXT_CHAR_CELL	O
;	O
}	O
}	O
while	O
(	O
col	int
%	O
SLsmg_Tab_Width	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ch	int
==	O
'\n'	O
)	O
&&	O
(	O
SLsmg_Newline_Behavior	int
!=	O
SLSMG_NEWLINE_PRINTABLE	int
)	O
)	O
{	O
newline_flag	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
ch	int
==	O
0x8	int
)	O
&&	O
SLsmg_Backspace_Moves	int
)	O
{	O
if	O
(	O
col	int
!=	O
0	int
)	O
{	O
if	O
(	O
i	array
!=	O
0	int
)	O
{	O
NEXT_CHAR_CELL	O
;	O
col	int
--	O
;	O
p	pointer
--	O
;	O
}	O
col	int
--	O
;	O
p	pointer
--	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
(	O
ch	int
==	O
033	int
)	O
&&	O
Embedded_Escape_Mode	int
)	O
{	O
SLsmg_Color_Type	short
next_color	short
;	O
if	O
(	O
0	int
==	O
parse_embedded_escape	function
(	O
u	pointer
,	O
umax	pointer
,	O
default_color	short
,	O
&	O
u	pointer
,	O
&	O
next_color	short
)	O
)	O
{	O
if	O
(	O
i	array
!=	O
0	int
)	O
NEXT_CHAR_CELL	O
;	O
color	short
=	O
next_color	short
;	O
continue	O
;	O
}	O
}	O
ADD_CHAR_OR_BREAK	O
(	O
'^'	O
)	O
;	O
if	O
(	O
ch	int
==	O
127	int
)	O
ch	int
=	O
'?'	O
;	O
else	O
ch	int
=	O
ch	int
+	O
'@'	O
;	O
ADD_CHAR_OR_BREAK	O
(	O
ch	int
)	O
;	O
continue	O
;	O
}	O
nconsumed	int
=	O
1	int
;	O
if	O
(	O
(	O
utf8_mode	int
==	O
0	int
)	O
||	O
(	O
NULL	O
==	O
SLutf8_decode	function
(	O
u	pointer
,	O
umax	pointer
,	O
&	O
wc	int
,	O
&	O
nconsumed	int
)	O
)	O
)	O
{	O
unsigned	O
int	O
ii	int
,	O
jj	int
;	O
unsigned	O
char	O
hexbuf	array
[	O
8	int
]	O
;	O
if	O
(	O
(	O
utf8_mode	int
==	O
0	int
)	O
&&	O
display_8bit	char
&&	O
(	O
*	O
u	pointer
>=	O
display_8bit	char
)	O
)	O
{	O
ADD_CHAR_OR_BREAK	O
(	O
*	O
u	pointer
)	O
;	O
}	O
else	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
nconsumed	int
;	O
ii	int
++	O
)	O
{	O
sprintf	function
(	O
(	O
char	O
*	O
)	O
hexbuf	array
,	O
"<%02X>"	pointer
,	O
u	pointer
[	O
ii	int
]	O
)	O
;	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
4	int
;	O
jj	int
++	O
)	O
{	O
ADD_CHAR_OR_BREAK	O
(	O
hexbuf	array
[	O
jj	int
]	O
)	O
;	O
}	O
}	O
u	pointer
+=	O
nconsumed	int
;	O
continue	O
;	O
}	O
u	pointer
+=	O
nconsumed	int
;	O
if	O
(	O
wc	int
<	O
(	O
SLwchar_Type	int
)	O
display_8bit	char
)	O
{	O
unsigned	O
char	O
hexbuf	array
[	O
8	int
]	O
;	O
unsigned	O
int	O
jj	int
;	O
sprintf	function
(	O
(	O
char	O
*	O
)	O
hexbuf	array
,	O
"<%02X>"	pointer
,	O
(	O
unsigned	O
char	O
)	O
wc	int
)	O
;	O
for	O
(	O
jj	int
=	O
0	int
;	O
jj	int
<	O
4	int
;	O
jj	int
++	O
)	O
{	O
ADD_CHAR_OR_BREAK	O
(	O
hexbuf	array
[	O
jj	int
]	O
)	O
;	O
}	O
continue	O
;	O
}	O
width	int
=	O
SLwchar_wcwidth	function
(	O
wc	int
)	O
;	O
if	O
(	O
width	int
==	O
0	int
)	O
{	O
if	O
(	O
i	array
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
i	array
<	O
SLSMG_MAX_CHARS_PER_CELL	int
)	O
{	O
ADD_TO_CHAR_CELL	O
(	O
wc	int
)	O
;	O
}	O
continue	O
;	O
}	O
if	O
(	O
width	int
==	O
2	int
)	O
{	O
if	O
(	O
col	int
+	O
2	int
<=	O
start_col	int
)	O
{	O
col	int
+=	O
2	int
;	O
continue	O
;	O
}	O
if	O
(	O
col	int
+	O
2	int
>	O
max_col	int
)	O
{	O
ADD_CHAR_OR_BREAK	O
(	O
'>'	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
col	int
==	O
start_col	int
-	O
1	int
)	O
{	O
col	int
++	O
;	O
ADD_CHAR_OR_BREAK	O
(	O
'<'	O
)	O
;	O
continue	O
;	O
}	O
ADD_CHAR_OR_BREAK	O
(	O
wc	int
)	O
;	O
last_was_double_width	int
=	O
1	int
;	O
continue	O
;	O
}	O
ADD_CHAR_OR_BREAK	O
(	O
wc	int
)	O
;	O
}	O
if	O
(	O
i	array
!=	O
0	int
)	O
{	O
NEXT_CHAR_CELL	O
;	O
}	O
if	O
(	O
last_was_double_width	int
)	O
{	O
if	O
(	O
col	int
<	O
max_col	int
)	O
NEXT_CHAR_CELL	O
;	O
last_was_double_width	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
col	int
<	O
max_col	int
)	O
&&	O
(	O
p	pointer
->	O
nchars	int
==	O
0	int
)	O
)	O
{	O
p	pointer
->	O
nchars	int
=	O
1	int
;	O
p	pointer
->	O
wchars	array
[	O
0	int
]	O
=	O
' '	O
;	O
}	O
SL_Screen	array
[	O
This_Row	int
-	O
Start_Row	int
]	O
.	O
flags	int
=	O
flags	int
;	O
This_Col	int
=	O
col	int
;	O
if	O
(	O
SLsmg_Newline_Behavior	int
==	O
SLSMG_NEWLINE_IGNORED	int
)	O
{	O
if	O
(	O
Embedded_Escape_Mode	int
&&	O
(	O
u	pointer
!=	O
NULL	O
)	O
)	O
parse_embedded_set_color	function
(	O
u	pointer
,	O
umax	pointer
,	O
default_color	short
)	O
;	O
return	O
;	O
}	O
if	O
(	O
newline_flag	int
==	O
0	int
)	O
{	O
SLuchar_Type	char
*	O
usave	pointer
=	O
u	pointer
;	O
if	O
(	O
u	pointer
==	O
NULL	O
)	O
return	O
;	O
while	O
(	O
u	pointer
<	O
umax	pointer
)	O
{	O
if	O
(	O
*	O
u	pointer
==	O
'\n'	O
)	O
break	O
;	O
u	pointer
++	O
;	O
}	O
if	O
(	O
u	pointer
>=	O
umax	pointer
)	O
{	O
if	O
(	O
Embedded_Escape_Mode	int
)	O
parse_embedded_set_color	function
(	O
usave	pointer
,	O
umax	pointer
,	O
default_color	short
)	O
;	O
return	O
;	O
}	O
u	pointer
++	O
;	O
}	O
This_Row	int
++	O
;	O
This_Col	int
=	O
0	int
;	O
if	O
(	O
This_Row	int
==	O
Start_Row	int
+	O
(	O
int	O
)	O
Screen_Rows	int
)	O
{	O
if	O
(	O
SLsmg_Newline_Behavior	int
==	O
SLSMG_NEWLINE_SCROLLS	int
)	O
scroll_up	function
(	O
)	O
;	O
}	O
goto	O
top	O
;	O
}	O
void	O
SLsmg_write_nchars	function
(	O
char	O
*	O
str	pointer
,	O
unsigned	O
int	O
len	int
)	O
{	O
SLsmg_write_chars	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
str	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
str	pointer
+	O
len	int
)	O
;	O
}	O
void	O
SLsmg_write_string	function
(	O
char	O
*	O
str	pointer
)	O
{	O
SLsmg_write_chars	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
str	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
str	pointer
+	O
strlen	function
(	O
str	pointer
)	O
)	O
;	O
}	O
void	O
SLsmg_write_nstring	function
(	O
char	O
*	O
str	pointer
,	O
unsigned	O
int	O
n	int
)	O
{	O
unsigned	O
int	O
width	int
;	O
unsigned	O
char	O
*	O
blank	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
" "	pointer
;	O
unsigned	O
char	O
*	O
u	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
str	pointer
;	O
if	O
(	O
(	O
int	O
)	O
n	int
<	O
0	int
)	O
return	O
;	O
if	O
(	O
u	pointer
==	O
NULL	O
)	O
width	int
=	O
0	int
;	O
else	O
{	O
unsigned	O
char	O
*	O
umax	pointer
;	O
width	int
=	O
strlen	function
(	O
(	O
char	O
*	O
)	O
u	pointer
)	O
;	O
if	O
(	O
UTF8_Mode	int
)	O
umax	pointer
=	O
SLutf8_skip_chars	function
(	O
u	pointer
,	O
u	pointer
+	O
width	int
,	O
n	int
,	O
&	O
width	int
,	O
0	int
)	O
;	O
else	O
{	O
if	O
(	O
width	int
>	O
n	int
)	O
width	int
=	O
n	int
;	O
umax	pointer
=	O
u	pointer
+	O
width	int
;	O
}	O
SLsmg_write_chars	function
(	O
u	pointer
,	O
umax	pointer
)	O
;	O
}	O
while	O
(	O
width	int
++	O
<	O
n	int
)	O
SLsmg_write_chars	function
(	O
blank	pointer
,	O
blank	pointer
+	O
1	int
)	O
;	O
}	O
void	O
SLsmg_write_wrapped_string	function
(	O
SLuchar_Type	char
*	O
u	pointer
,	O
int	O
r	pointer
,	O
int	O
c	int
,	O
unsigned	O
int	O
dr	int
,	O
unsigned	O
int	O
dc	int
,	O
int	O
fill	int
)	O
{	O
int	O
maxc	int
=	O
(	O
int	O
)	O
dc	int
;	O
unsigned	O
char	O
*	O
p	pointer
,	O
*	O
pmax	pointer
;	O
int	O
utf8_mode	int
=	O
UTF8_Mode	int
;	O
if	O
(	O
(	O
dr	int
==	O
0	int
)	O
||	O
(	O
dc	int
==	O
0	int
)	O
)	O
return	O
;	O
p	pointer
=	O
u	pointer
;	O
pmax	pointer
=	O
u	pointer
+	O
strlen	function
(	O
(	O
char	O
*	O
)	O
u	pointer
)	O
;	O
dc	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
unsigned	O
char	O
ch	int
=	O
*	O
p	pointer
;	O
if	O
(	O
(	O
ch	int
==	O
0	int
)	O
||	O
(	O
ch	int
==	O
'\n'	O
)	O
)	O
{	O
int	O
diff	int
;	O
diff	int
=	O
maxc	int
-	O
(	O
int	O
)	O
dc	int
;	O
SLsmg_gotorc	function
(	O
r	pointer
,	O
c	int
)	O
;	O
SLsmg_write_chars	function
(	O
u	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
fill	int
&&	O
(	O
diff	int
>	O
0	int
)	O
)	O
{	O
unsigned	O
char	O
*	O
blank	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
" "	pointer
;	O
while	O
(	O
diff	int
--	O
)	O
SLsmg_write_chars	function
(	O
blank	pointer
,	O
blank	pointer
+	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
ch	int
==	O
0	int
)	O
||	O
(	O
dr	int
==	O
1	int
)	O
)	O
break	O
;	O
r	pointer
++	O
;	O
dc	int
=	O
0	int
;	O
dr	int
--	O
;	O
p	pointer
++	O
;	O
u	pointer
=	O
p	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
int	O
)	O
dc	int
==	O
maxc	int
)	O
{	O
SLsmg_gotorc	function
(	O
r	pointer
,	O
c	int
)	O
;	O
SLsmg_write_chars	function
(	O
u	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
dr	int
==	O
1	int
)	O
break	O
;	O
r	pointer
++	O
;	O
dc	int
=	O
0	int
;	O
dr	int
--	O
;	O
u	pointer
=	O
p	pointer
;	O
continue	O
;	O
}	O
dc	int
++	O
;	O
if	O
(	O
utf8_mode	int
)	O
p	pointer
=	O
SLutf8_skip_chars	function
(	O
p	pointer
,	O
pmax	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
else	O
p	pointer
++	O
;	O
}	O
}	O
int	O
SLsmg_Tab_Width	int
=	O
8	int
;	O
int	O
SLsmg_Display_Eight_Bit	int
=	O
160	int
;	O
void	O
SLsmg_write_char	function
(	O
SLwchar_Type	int
ch	int
)	O
{	O
unsigned	O
char	O
u	pointer
[	O
SLUTF8_MAX_MBLEN	int
]	O
;	O
unsigned	O
char	O
*	O
umax	pointer
;	O
if	O
(	O
(	O
ch	int
<	O
0x80	int
)	O
||	O
(	O
UTF8_Mode	int
==	O
0	int
)	O
)	O
{	O
u	pointer
[	O
0	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
ch	int
;	O
SLsmg_write_chars	function
(	O
u	pointer
,	O
u	pointer
+	O
1	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
NULL	O
==	O
(	O
umax	pointer
=	O
SLutf8_encode	function
(	O
ch	int
,	O
u	pointer
,	O
SLUTF8_MAX_MBLEN	int
)	O
)	O
)	O
return	O
;	O
SLsmg_write_chars	function
(	O
u	pointer
,	O
umax	pointer
)	O
;	O
}	O
static	O
int	O
Cls_Flag	int
;	O
void	O
SLsmg_cls	function
(	O
void	O
)	O
{	O
int	O
tac	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
tac	int
=	O
This_Alt_Char	int
;	O
This_Alt_Char	int
=	O
0	int
;	O
SLsmg_set_color	function
(	O
0	int
)	O
;	O
clear_region	function
(	O
0	int
,	O
(	O
int	O
)	O
Screen_Rows	int
,	O
0x20	int
)	O
;	O
This_Alt_Char	int
=	O
tac	int
;	O
SLsmg_set_color	function
(	O
0	int
)	O
;	O
Cls_Flag	int
=	O
1	int
;	O
}	O
int	O
SLsmg_Scroll_Hash_Border	int
=	O
0	int
;	O
static	O
unsigned	O
long	O
compute_hash	function
(	O
SLsmg_Char_Type	struct
*	O
c	int
,	O
unsigned	O
int	O
n	int
)	O
{	O
SLsmg_Char_Type	struct
*	O
csave	pointer
,	O
*	O
cmax	pointer
;	O
int	O
is_blank	int
=	O
2	int
;	O
c	int
+=	O
SLsmg_Scroll_Hash_Border	int
;	O
csave	pointer
=	O
c	int
;	O
cmax	pointer
=	O
c	int
+	O
(	O
n	int
-	O
SLsmg_Scroll_Hash_Border	int
)	O
;	O
while	O
(	O
(	O
c	int
<	O
cmax	pointer
)	O
&&	O
is_blank	int
)	O
{	O
if	O
(	O
(	O
c	int
->	O
wchars	array
[	O
0	int
]	O
!=	O
32	int
)	O
||	O
(	O
c	int
->	O
nchars	int
!=	O
1	int
)	O
)	O
is_blank	int
--	O
;	O
c	int
++	O
;	O
}	O
if	O
(	O
is_blank	int
)	O
return	O
0	int
;	O
return	O
_pSLstring_hash	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
csave	pointer
,	O
(	O
unsigned	O
char	O
*	O
)	O
cmax	pointer
)	O
;	O
}	O
static	O
unsigned	O
long	O
Blank_Hash	long
;	O
static	O
int	O
try_scroll_down	function
(	O
int	O
rmin	int
,	O
int	O
rmax	int
)	O
{	O
int	O
i	array
,	O
r1	int
,	O
r2	int
,	O
di	int
,	O
j	int
;	O
unsigned	O
long	O
hash	long
;	O
int	O
did_scroll	int
;	O
SLsmg_Color_Type	short
color	short
;	O
SLsmg_Char_Type	struct
*	O
tmp	pointer
;	O
int	O
ignore	int
;	O
did_scroll	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
rmax	int
;	O
i	array
>	O
rmin	int
;	O
i	array
--	O
)	O
{	O
hash	long
=	O
SL_Screen	array
[	O
i	array
]	O
.	O
new_hash	long
;	O
if	O
(	O
hash	long
==	O
Blank_Hash	long
)	O
continue	O
;	O
if	O
(	O
(	O
hash	long
==	O
SL_Screen	array
[	O
i	array
]	O
.	O
old_hash	long
)	O
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
i	array
-	O
1	int
;	O
j	int
>=	O
rmin	int
;	O
j	int
--	O
)	O
{	O
if	O
(	O
hash	long
==	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
)	O
break	O
;	O
}	O
if	O
(	O
j	int
<	O
rmin	int
)	O
continue	O
;	O
r2	int
=	O
i	array
;	O
di	int
=	O
i	array
-	O
j	int
;	O
j	int
--	O
;	O
ignore	int
=	O
0	int
;	O
while	O
(	O
(	O
j	int
>=	O
rmin	int
)	O
&&	O
(	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
==	O
SL_Screen	array
[	O
j	int
+	O
di	int
]	O
.	O
new_hash	long
)	O
)	O
{	O
if	O
(	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
==	O
Blank_Hash	long
)	O
ignore	int
++	O
;	O
j	int
--	O
;	O
}	O
r1	int
=	O
j	int
+	O
1	int
;	O
if	O
(	O
(	O
di	int
>	O
1	int
)	O
&&	O
(	O
r1	int
+	O
di	int
+	O
ignore	int
==	O
r2	int
)	O
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
r1	int
;	O
j	int
<=	O
r2	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
(	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
!=	O
Blank_Hash	long
)	O
&&	O
(	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
==	O
SL_Screen	array
[	O
j	int
]	O
.	O
new_hash	long
)	O
)	O
{	O
if	O
(	O
(	O
j	int
+	O
di	int
>	O
r2	int
)	O
||	O
(	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
!=	O
SL_Screen	array
[	O
j	int
+	O
di	int
]	O
.	O
new_hash	long
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
j	int
<=	O
r2	int
)	O
continue	O
;	O
color	short
=	O
This_Color	short
;	O
This_Color	short
=	O
0	int
;	O
did_scroll	int
=	O
1	int
;	O
(	O
*	O
tt_normal_video	pointer
)	O
(	O
)	O
;	O
(	O
*	O
tt_set_scroll_region	pointer
)	O
(	O
r1	int
,	O
r2	int
)	O
;	O
(	O
*	O
tt_goto_rc	pointer
)	O
(	O
0	int
,	O
0	int
)	O
;	O
(	O
*	O
tt_reverse_index	pointer
)	O
(	O
di	int
)	O
;	O
(	O
*	O
tt_reset_scroll_region	pointer
)	O
(	O
)	O
;	O
for	O
(	O
j	int
=	O
r1	int
;	O
j	int
<=	O
r2	int
;	O
j	int
++	O
)	O
SL_Screen	array
[	O
j	int
]	O
.	O
flags	int
=	O
TOUCHED	int
;	O
while	O
(	O
di	int
--	O
)	O
{	O
tmp	pointer
=	O
SL_Screen	array
[	O
r2	int
]	O
.	O
old	pointer
;	O
for	O
(	O
j	int
=	O
r2	int
;	O
j	int
>	O
r1	int
;	O
j	int
--	O
)	O
{	O
SL_Screen	array
[	O
j	int
]	O
.	O
old	pointer
=	O
SL_Screen	array
[	O
j	int
-	O
1	int
]	O
.	O
old	pointer
;	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
=	O
SL_Screen	array
[	O
j	int
-	O
1	int
]	O
.	O
old_hash	long
;	O
}	O
SL_Screen	array
[	O
r1	int
]	O
.	O
old	pointer
=	O
tmp	pointer
;	O
blank_line	function
(	O
SL_Screen	array
[	O
r1	int
]	O
.	O
old	pointer
,	O
Screen_Cols	int
,	O
0x20	int
)	O
;	O
SL_Screen	array
[	O
r1	int
]	O
.	O
old_hash	long
=	O
Blank_Hash	long
;	O
r1	int
++	O
;	O
}	O
This_Color	short
=	O
color	short
;	O
}	O
return	O
did_scroll	int
;	O
}	O
static	O
int	O
try_scroll_up	function
(	O
int	O
rmin	int
,	O
int	O
rmax	int
)	O
{	O
int	O
i	array
,	O
r1	int
,	O
r2	int
,	O
di	int
,	O
j	int
;	O
unsigned	O
long	O
hash	long
;	O
int	O
did_scroll	int
;	O
SLsmg_Color_Type	short
color	short
;	O
SLsmg_Char_Type	struct
*	O
tmp	pointer
;	O
int	O
ignore	int
;	O
did_scroll	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
rmin	int
;	O
i	array
<	O
rmax	int
;	O
i	array
++	O
)	O
{	O
hash	long
=	O
SL_Screen	array
[	O
i	array
]	O
.	O
new_hash	long
;	O
if	O
(	O
hash	long
==	O
Blank_Hash	long
)	O
continue	O
;	O
if	O
(	O
hash	long
==	O
SL_Screen	array
[	O
i	array
]	O
.	O
old_hash	long
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
i	array
+	O
1	int
;	O
j	int
<=	O
rmax	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
hash	long
==	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
)	O
break	O
;	O
}	O
if	O
(	O
j	int
>	O
rmax	int
)	O
continue	O
;	O
r1	int
=	O
i	array
;	O
di	int
=	O
j	int
-	O
i	array
;	O
j	int
++	O
;	O
ignore	int
=	O
0	int
;	O
while	O
(	O
(	O
j	int
<=	O
rmax	int
)	O
&&	O
(	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
==	O
SL_Screen	array
[	O
j	int
-	O
di	int
]	O
.	O
new_hash	long
)	O
)	O
{	O
if	O
(	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
==	O
Blank_Hash	long
)	O
ignore	int
++	O
;	O
j	int
++	O
;	O
}	O
r2	int
=	O
j	int
-	O
1	int
;	O
if	O
(	O
(	O
di	int
>	O
1	int
)	O
&&	O
(	O
r1	int
+	O
di	int
+	O
ignore	int
==	O
r2	int
)	O
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
r1	int
;	O
j	int
<=	O
r2	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
(	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
!=	O
Blank_Hash	long
)	O
&&	O
(	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
==	O
SL_Screen	array
[	O
j	int
]	O
.	O
new_hash	long
)	O
)	O
{	O
if	O
(	O
(	O
j	int
-	O
di	int
<	O
r1	int
)	O
||	O
(	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
!=	O
SL_Screen	array
[	O
j	int
-	O
di	int
]	O
.	O
new_hash	long
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
j	int
<=	O
r2	int
)	O
continue	O
;	O
did_scroll	int
=	O
1	int
;	O
color	short
=	O
This_Color	short
;	O
This_Color	short
=	O
0	int
;	O
(	O
*	O
tt_normal_video	pointer
)	O
(	O
)	O
;	O
(	O
*	O
tt_set_scroll_region	pointer
)	O
(	O
r1	int
,	O
r2	int
)	O
;	O
(	O
*	O
tt_goto_rc	pointer
)	O
(	O
0	int
,	O
0	int
)	O
;	O
(	O
*	O
tt_delete_nlines	pointer
)	O
(	O
di	int
)	O
;	O
(	O
*	O
tt_reset_scroll_region	pointer
)	O
(	O
)	O
;	O
for	O
(	O
j	int
=	O
r1	int
;	O
j	int
<=	O
r2	int
;	O
j	int
++	O
)	O
SL_Screen	array
[	O
j	int
]	O
.	O
flags	int
=	O
TOUCHED	int
;	O
while	O
(	O
di	int
--	O
)	O
{	O
tmp	pointer
=	O
SL_Screen	array
[	O
r1	int
]	O
.	O
old	pointer
;	O
for	O
(	O
j	int
=	O
r1	int
;	O
j	int
<	O
r2	int
;	O
j	int
++	O
)	O
{	O
SL_Screen	array
[	O
j	int
]	O
.	O
old	pointer
=	O
SL_Screen	array
[	O
j	int
+	O
1	int
]	O
.	O
old	pointer
;	O
SL_Screen	array
[	O
j	int
]	O
.	O
old_hash	long
=	O
SL_Screen	array
[	O
j	int
+	O
1	int
]	O
.	O
old_hash	long
;	O
}	O
SL_Screen	array
[	O
r2	int
]	O
.	O
old	pointer
=	O
tmp	pointer
;	O
blank_line	function
(	O
SL_Screen	array
[	O
r2	int
]	O
.	O
old	pointer
,	O
Screen_Cols	int
,	O
' '	O
)	O
;	O
SL_Screen	array
[	O
r2	int
]	O
.	O
old_hash	long
=	O
Blank_Hash	long
;	O
r2	int
--	O
;	O
}	O
This_Color	short
=	O
color	short
;	O
}	O
return	O
did_scroll	int
;	O
}	O
static	O
void	O
try_scroll	function
(	O
void	O
)	O
{	O
int	O
r1	int
,	O
rmin	int
,	O
rmax	int
;	O
int	O
num_up	int
,	O
num_down	int
;	O
for	O
(	O
rmax	int
=	O
Screen_Rows	int
-	O
1	int
;	O
rmax	int
>	O
0	int
;	O
rmax	int
--	O
)	O
{	O
if	O
(	O
SL_Screen	array
[	O
rmax	int
]	O
.	O
new_hash	long
!=	O
SL_Screen	array
[	O
rmax	int
]	O
.	O
old_hash	long
)	O
{	O
r1	int
=	O
rmax	int
-	O
1	int
;	O
if	O
(	O
(	O
r1	int
==	O
0	int
)	O
||	O
(	O
SL_Screen	array
[	O
r1	int
]	O
.	O
new_hash	long
!=	O
SL_Screen	array
[	O
r1	int
]	O
.	O
old_hash	long
)	O
)	O
break	O
;	O
rmax	int
=	O
r1	int
;	O
}	O
}	O
for	O
(	O
rmin	int
=	O
0	int
;	O
rmin	int
<	O
rmax	int
;	O
rmin	int
++	O
)	O
{	O
if	O
(	O
SL_Screen	array
[	O
rmin	int
]	O
.	O
new_hash	long
!=	O
SL_Screen	array
[	O
rmin	int
]	O
.	O
old_hash	long
)	O
{	O
r1	int
=	O
rmin	int
+	O
1	int
;	O
if	O
(	O
(	O
r1	int
==	O
rmax	int
)	O
||	O
(	O
SL_Screen	array
[	O
r1	int
]	O
.	O
new_hash	long
!=	O
SL_Screen	array
[	O
r1	int
]	O
.	O
old_hash	long
)	O
)	O
break	O
;	O
rmin	int
=	O
r1	int
;	O
}	O
}	O
num_up	int
=	O
0	int
;	O
for	O
(	O
r1	int
=	O
rmin	int
;	O
r1	int
<	O
rmax	int
;	O
r1	int
++	O
)	O
{	O
if	O
(	O
SL_Screen	array
[	O
r1	int
]	O
.	O
new_hash	long
==	O
SL_Screen	array
[	O
r1	int
+	O
1	int
]	O
.	O
old_hash	long
)	O
num_up	int
++	O
;	O
}	O
num_down	int
=	O
0	int
;	O
for	O
(	O
r1	int
=	O
rmax	int
;	O
r1	int
>	O
rmin	int
;	O
r1	int
--	O
)	O
{	O
if	O
(	O
SL_Screen	array
[	O
r1	int
-	O
1	int
]	O
.	O
old_hash	long
==	O
SL_Screen	array
[	O
r1	int
]	O
.	O
new_hash	long
)	O
num_down	int
++	O
;	O
}	O
if	O
(	O
num_up	int
>	O
num_down	int
)	O
{	O
if	O
(	O
try_scroll_up	function
(	O
rmin	int
,	O
rmax	int
)	O
)	O
return	O
;	O
(	O
void	O
)	O
try_scroll_down	function
(	O
rmin	int
,	O
rmax	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
try_scroll_down	function
(	O
rmin	int
,	O
rmax	int
)	O
)	O
return	O
;	O
(	O
void	O
)	O
try_scroll_up	function
(	O
rmin	int
,	O
rmax	int
)	O
;	O
}	O
}	O
static	O
void	O
adjust_colors	function
(	O
void	O
)	O
{	O
int	O
bce	int
;	O
unsigned	O
int	O
i	array
;	O
bce	int
=	O
Bce_Color_Offset	int
;	O
Bce_Color_Offset	int
=	O
_pSLtt_get_bce_color_offset	function
(	O
)	O
;	O
if	O
(	O
bce	int
==	O
Bce_Color_Offset	int
)	O
return	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
Screen_Rows	int
;	O
i	array
++	O
)	O
{	O
SLsmg_Char_Type	struct
*	O
s	pointer
,	O
*	O
smax	pointer
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
flags	int
|=	O
TRASHED	int
;	O
s	pointer
=	O
SL_Screen	array
[	O
i	array
]	O
.	O
neew	pointer
;	O
smax	pointer
=	O
s	pointer
+	O
Screen_Cols	int
;	O
while	O
(	O
s	pointer
<	O
smax	pointer
)	O
{	O
SLsmg_Color_Type	short
color	short
=	O
s	pointer
->	O
color	short
;	O
int	O
acs	pointer
=	O
color	short
&	O
SLSMG_ACS_MASK	int
;	O
color	short
=	O
(	O
color	short
&	O
SLSMG_COLOR_MASK	int
)	O
+	O
(	O
Bce_Color_Offset	int
-	O
bce	int
)	O
;	O
if	O
(	O
color	short
<	O
SLSMG_MAX_COLORS	int
)	O
s	pointer
->	O
color	short
=	O
color	short
|	O
acs	pointer
;	O
s	pointer
++	O
;	O
}	O
}	O
}	O
void	O
SLsmg_refresh	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
i	array
;	O
int	O
trashed	int
=	O
0	int
;	O
int	O
r	pointer
,	O
c	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
Screen_Trashed	int
)	O
{	O
Cls_Flag	int
=	O
1	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
Screen_Rows	int
;	O
i	array
++	O
)	O
SL_Screen	array
[	O
i	array
]	O
.	O
flags	int
|=	O
TRASHED	int
;	O
adjust_colors	function
(	O
)	O
;	O
}	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
Screen_Rows	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
SL_Screen	array
[	O
i	array
]	O
.	O
flags	int
==	O
0	int
)	O
continue	O
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
new_hash	long
=	O
compute_hash	function
(	O
SL_Screen	array
[	O
i	array
]	O
.	O
neew	pointer
,	O
Screen_Cols	int
)	O
;	O
trashed	int
=	O
1	int
;	O
}	O
if	O
(	O
Cls_Flag	int
)	O
{	O
(	O
*	O
tt_normal_video	pointer
)	O
(	O
)	O
;	O
(	O
*	O
tt_cls	pointer
)	O
(	O
)	O
;	O
}	O
else	O
if	O
(	O
trashed	int
&&	O
(	O
*	O
tt_Term_Cannot_Scroll	pointer
==	O
0	int
)	O
)	O
try_scroll	function
(	O
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
Screen_Rows	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
SL_Screen	array
[	O
i	array
]	O
.	O
flags	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
Cls_Flag	int
||	O
SL_Screen	array
[	O
i	array
]	O
.	O
flags	int
&	O
TRASHED	int
)	O
{	O
SLsmg_Color_Type	short
color	short
=	O
This_Color	short
;	O
if	O
(	O
Cls_Flag	int
==	O
0	int
)	O
{	O
(	O
*	O
tt_goto_rc	pointer
)	O
(	O
i	array
,	O
0	int
)	O
;	O
(	O
*	O
tt_del_eol	pointer
)	O
(	O
)	O
;	O
}	O
This_Color	short
=	O
0	int
;	O
blank_line	function
(	O
SL_Screen	array
[	O
i	array
]	O
.	O
old	pointer
,	O
Screen_Cols	int
,	O
0x20	int
)	O
;	O
This_Color	short
=	O
color	short
;	O
}	O
(	O
*	O
tt_smart_puts	pointer
)	O
(	O
SL_Screen	array
[	O
i	array
]	O
.	O
neew	pointer
,	O
SL_Screen	array
[	O
i	array
]	O
.	O
old	pointer
,	O
Screen_Cols	int
,	O
i	array
)	O
;	O
memcpy	function
(	O
(	O
char	O
*	O
)	O
SL_Screen	array
[	O
i	array
]	O
.	O
old	pointer
,	O
(	O
char	O
*	O
)	O
SL_Screen	array
[	O
i	array
]	O
.	O
neew	pointer
,	O
Screen_Cols	int
*	O
sizeof	O
(	O
SLsmg_Char_Type	struct
)	O
)	O
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
flags	int
=	O
0	int
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
old_hash	long
=	O
SL_Screen	array
[	O
i	array
]	O
.	O
new_hash	long
;	O
}	O
r	pointer
=	O
This_Row	int
-	O
Start_Row	int
;	O
c	int
=	O
This_Col	int
-	O
Start_Col	int
;	O
if	O
(	O
r	pointer
<	O
0	int
)	O
{	O
r	pointer
=	O
0	int
;	O
c	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
r	pointer
>=	O
(	O
int	O
)	O
Screen_Rows	int
)	O
{	O
r	pointer
=	O
(	O
int	O
)	O
Screen_Rows	int
;	O
c	int
=	O
(	O
int	O
)	O
Screen_Cols	int
-	O
1	int
;	O
}	O
if	O
(	O
c	int
<	O
0	int
)	O
c	int
=	O
0	int
;	O
else	O
if	O
(	O
c	int
>=	O
(	O
int	O
)	O
Screen_Cols	int
)	O
c	int
=	O
(	O
int	O
)	O
Screen_Cols	int
-	O
1	int
;	O
(	O
*	O
tt_goto_rc	pointer
)	O
(	O
r	pointer
,	O
c	int
)	O
;	O
(	O
void	O
)	O
(	O
*	O
tt_flush_output	pointer
)	O
(	O
)	O
;	O
Cls_Flag	int
=	O
0	int
;	O
Screen_Trashed	int
=	O
0	int
;	O
}	O
static	O
int	O
compute_clip	function
(	O
int	O
row	int
,	O
int	O
n	int
,	O
int	O
box_start	int
,	O
int	O
box_end	int
,	O
int	O
*	O
rmin	int
,	O
int	O
*	O
rmax	int
)	O
{	O
int	O
row_max	int
;	O
if	O
(	O
n	int
<	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
row	int
>=	O
box_end	int
)	O
return	O
0	int
;	O
row_max	int
=	O
row	int
+	O
n	int
;	O
if	O
(	O
row_max	int
<=	O
box_start	int
)	O
return	O
0	int
;	O
if	O
(	O
row	int
<	O
box_start	int
)	O
row	int
=	O
box_start	int
;	O
if	O
(	O
row_max	int
>=	O
box_end	int
)	O
row_max	int
=	O
box_end	int
;	O
*	O
rmin	int
=	O
row	int
;	O
*	O
rmax	int
=	O
row_max	int
;	O
return	O
1	int
;	O
}	O
void	O
SLsmg_touch_lines	function
(	O
int	O
row	int
,	O
unsigned	O
int	O
n	int
)	O
{	O
int	O
i	array
;	O
int	O
r1	int
,	O
r2	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
0	int
==	O
compute_clip	function
(	O
row	int
,	O
(	O
int	O
)	O
n	int
,	O
Start_Row	int
,	O
Start_Row	int
+	O
Screen_Rows	int
,	O
&	O
r1	int
,	O
&	O
r2	int
)	O
)	O
return	O
;	O
r1	int
-=	O
Start_Row	int
;	O
r2	int
-=	O
Start_Row	int
;	O
for	O
(	O
i	array
=	O
r1	int
;	O
i	array
<	O
r2	int
;	O
i	array
++	O
)	O
{	O
SL_Screen	array
[	O
i	array
]	O
.	O
flags	int
|=	O
TRASHED	int
;	O
}	O
}	O
void	O
SLsmg_touch_screen	function
(	O
void	O
)	O
{	O
Screen_Trashed	int
=	O
1	int
;	O
}	O
static	O
int	O
Smg_Suspended	int
;	O
int	O
SLsmg_suspend_smg	function
(	O
void	O
)	O
{	O
BLOCK_SIGNALS	O
;	O
if	O
(	O
Smg_Suspended	int
==	O
0	int
)	O
{	O
(	O
*	O
tt_reset_video	pointer
)	O
(	O
)	O
;	O
Smg_Suspended	int
=	O
1	int
;	O
}	O
UNBLOCK_SIGNALS	O
;	O
return	O
0	int
;	O
}	O
int	O
SLsmg_resume_smg	function
(	O
void	O
)	O
{	O
BLOCK_SIGNALS	O
;	O
if	O
(	O
Smg_Suspended	int
==	O
0	int
)	O
{	O
UNBLOCK_SIGNALS	O
;	O
return	O
0	int
;	O
}	O
Smg_Suspended	int
=	O
0	int
;	O
if	O
(	O
-	O
1	int
==	O
(	O
*	O
tt_init_video	pointer
)	O
(	O
)	O
)	O
{	O
UNBLOCK_SIGNALS	O
;	O
return	O
-	O
1	int
;	O
}	O
Cls_Flag	int
=	O
1	int
;	O
SLsmg_touch_screen	function
(	O
)	O
;	O
SLsmg_refresh	function
(	O
)	O
;	O
UNBLOCK_SIGNALS	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
reset_smg	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
i	array
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
Screen_Rows	int
;	O
i	array
++	O
)	O
{	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
SL_Screen	array
[	O
i	array
]	O
.	O
old	pointer
)	O
;	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
SL_Screen	array
[	O
i	array
]	O
.	O
neew	pointer
)	O
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
old	pointer
=	O
SL_Screen	array
[	O
i	array
]	O
.	O
neew	pointer
=	O
NULL	O
;	O
}	O
This_Alt_Char	int
=	O
This_Color	short
=	O
0	int
;	O
Smg_Inited	int
=	O
0	int
;	O
}	O
static	O
int	O
init_smg	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
i	array
,	O
len	int
;	O
SLsmg_Char_Type	struct
*	O
old	pointer
,	O
*	O
neew	pointer
;	O
Smg_Inited	int
=	O
0	int
;	O
Bce_Color_Offset	int
=	O
_pSLtt_get_bce_color_offset	function
(	O
)	O
;	O
Screen_Rows	int
=	O
*	O
tt_Screen_Rows	pointer
;	O
if	O
(	O
Screen_Rows	int
>	O
SLTT_MAX_SCREEN_ROWS	int
)	O
Screen_Rows	int
=	O
SLTT_MAX_SCREEN_ROWS	int
;	O
Screen_Cols	int
=	O
*	O
tt_Screen_Cols	pointer
;	O
This_Col	int
=	O
This_Row	int
=	O
Start_Col	int
=	O
Start_Row	int
=	O
0	int
;	O
This_Alt_Char	int
=	O
0	int
;	O
SLsmg_set_color	function
(	O
0	int
)	O
;	O
Cls_Flag	int
=	O
1	int
;	O
init_acs	function
(	O
ACS_MODE_AUTO	int
)	O
;	O
len	int
=	O
Screen_Cols	int
+	O
3	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
Screen_Rows	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
(	O
NULL	O
==	O
(	O
old	pointer
=	O
(	O
SLsmg_Char_Type	struct
*	O
)	O
SLmalloc	O
(	O
sizeof	O
(	O
SLsmg_Char_Type	struct
)	O
*	O
len	int
)	O
)	O
)	O
||	O
(	O
(	O
NULL	O
==	O
(	O
neew	pointer
=	O
(	O
SLsmg_Char_Type	struct
*	O
)	O
SLmalloc	O
(	O
sizeof	O
(	O
SLsmg_Char_Type	struct
)	O
*	O
len	int
)	O
)	O
)	O
)	O
)	O
{	O
SLfree	O
(	O
(	O
char	O
*	O
)	O
old	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
blank_line	function
(	O
old	pointer
,	O
len	int
,	O
' '	O
)	O
;	O
blank_line	function
(	O
neew	pointer
,	O
len	int
,	O
' '	O
)	O
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
old	pointer
=	O
old	pointer
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
neew	pointer
=	O
neew	pointer
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
flags	int
=	O
0	int
;	O
Blank_Hash	long
=	O
compute_hash	function
(	O
old	pointer
,	O
Screen_Cols	int
)	O
;	O
SL_Screen	array
[	O
i	array
]	O
.	O
new_hash	long
=	O
SL_Screen	array
[	O
i	array
]	O
.	O
old_hash	long
=	O
Blank_Hash	long
;	O
}	O
_pSLtt_color_changed_hook	pointer
=	O
SLsmg_touch_screen	function
;	O
Screen_Trashed	int
=	O
1	int
;	O
Smg_Inited	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
SLsmg_init_smg	function
(	O
void	O
)	O
{	O
int	O
ret	int
;	O
BLOCK_SIGNALS	O
;	O
if	O
(	O
tt_Screen_Rows	pointer
==	O
NULL	O
)	O
init_tt_symbols	function
(	O
)	O
;	O
if	O
(	O
Smg_Inited	int
)	O
SLsmg_reset_smg	function
(	O
)	O
;	O
if	O
(	O
UTF8_Mode	int
==	O
-	O
1	int
)	O
UTF8_Mode	int
=	O
_pSLutf8_mode	int
;	O
if	O
(	O
-	O
1	int
==	O
(	O
*	O
tt_init_video	pointer
)	O
(	O
)	O
)	O
{	O
UNBLOCK_SIGNALS	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
-	O
1	int
==	O
(	O
ret	int
=	O
init_smg	function
(	O
)	O
)	O
)	O
(	O
void	O
)	O
(	O
*	O
tt_reset_video	pointer
)	O
(	O
)	O
;	O
UNBLOCK_SIGNALS	O
;	O
return	O
ret	int
;	O
}	O
int	O
SLsmg_reinit_smg	function
(	O
void	O
)	O
{	O
int	O
ret	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
SLsmg_init_smg	function
(	O
)	O
;	O
BLOCK_SIGNALS	O
;	O
reset_smg	function
(	O
)	O
;	O
ret	int
=	O
init_smg	function
(	O
)	O
;	O
UNBLOCK_SIGNALS	O
;	O
return	O
ret	int
;	O
}	O
void	O
SLsmg_reset_smg	function
(	O
void	O
)	O
{	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
BLOCK_SIGNALS	O
;	O
reset_smg	function
(	O
)	O
;	O
(	O
*	O
tt_reset_video	pointer
)	O
(	O
)	O
;	O
UNBLOCK_SIGNALS	O
;	O
}	O
void	O
SLsmg_vprintf	function
(	O
char	O
*	O
fmt	pointer
,	O
va_list	array
ap	array
)	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
(	O
void	O
)	O
SLvsnprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
SLsmg_write_string	function
(	O
buf	pointer
)	O
;	O
}	O
void	O
SLsmg_printf	function
(	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
char	O
*	O
f	float
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
f	float
=	O
fmt	pointer
;	O
while	O
(	O
*	O
f	float
&&	O
(	O
*	O
f	float
!=	O
'%'	O
)	O
)	O
f	float
++	O
;	O
if	O
(	O
f	float
!=	O
fmt	pointer
)	O
SLsmg_write_chars	function
(	O
(	O
SLuchar_Type	char
*	O
)	O
fmt	pointer
,	O
(	O
SLuchar_Type	char
*	O
)	O
f	float
)	O
;	O
if	O
(	O
*	O
f	float
!=	O
0	int
)	O
SLsmg_vprintf	function
(	O
f	float
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
void	O
SLsmg_set_screen_start	function
(	O
int	O
*	O
r	pointer
,	O
int	O
*	O
c	int
)	O
{	O
int	O
orow	int
=	O
Start_Row	int
,	O
oc	int
=	O
Start_Col	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
c	int
==	O
NULL	O
)	O
Start_Col	int
=	O
0	int
;	O
else	O
{	O
Start_Col	int
=	O
*	O
c	int
;	O
*	O
c	int
=	O
oc	int
;	O
}	O
if	O
(	O
r	pointer
==	O
NULL	O
)	O
Start_Row	int
=	O
0	int
;	O
else	O
{	O
Start_Row	int
=	O
*	O
r	pointer
;	O
*	O
r	pointer
=	O
orow	int
;	O
}	O
}	O
void	O
SLsmg_draw_object	function
(	O
int	O
r	pointer
,	O
int	O
c	int
,	O
SLwchar_Type	int
object	int
)	O
{	O
This_Row	int
=	O
r	pointer
;	O
This_Col	int
=	O
c	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
point_visible	function
(	O
1	int
)	O
)	O
{	O
int	O
color	short
=	O
This_Color	short
;	O
This_Color	short
|=	O
SLSMG_ACS_MASK	int
;	O
SLsmg_write_char	function
(	O
object	int
)	O
;	O
This_Color	short
=	O
color	short
;	O
}	O
This_Col	int
=	O
c	int
+	O
1	int
;	O
}	O
void	O
SLsmg_draw_hline	function
(	O
unsigned	O
int	O
n	int
)	O
{	O
static	O
unsigned	O
char	O
hbuf	array
[	O
16	int
]	O
;	O
int	O
cmin	int
,	O
cmax	pointer
;	O
int	O
final_col	int
=	O
This_Col	int
+	O
(	O
int	O
)	O
n	int
;	O
int	O
save_color	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
(	O
This_Row	int
<	O
Start_Row	int
)	O
||	O
(	O
This_Row	int
>=	O
Start_Row	int
+	O
(	O
int	O
)	O
Screen_Rows	int
)	O
||	O
(	O
0	int
==	O
compute_clip	function
(	O
This_Col	int
,	O
n	int
,	O
Start_Col	int
,	O
Start_Col	int
+	O
(	O
int	O
)	O
Screen_Cols	int
,	O
&	O
cmin	int
,	O
&	O
cmax	pointer
)	O
)	O
)	O
{	O
This_Col	int
=	O
final_col	int
;	O
return	O
;	O
}	O
n	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
cmax	pointer
-	O
cmin	int
)	O
;	O
save_color	int
=	O
This_Color	short
;	O
This_Color	short
|=	O
SLSMG_ACS_MASK	int
;	O
This_Col	int
=	O
cmin	int
;	O
if	O
(	O
hbuf	array
[	O
0	int
]	O
==	O
0	int
)	O
{	O
SLMEMSET	O
(	O
(	O
char	O
*	O
)	O
hbuf	array
,	O
SLSMG_HLINE_CHAR	O
,	O
16	int
)	O
;	O
}	O
while	O
(	O
n	int
)	O
{	O
SLsmg_write_char	function
(	O
SLSMG_HLINE_CHAR	O
)	O
;	O
n	int
--	O
;	O
}	O
This_Color	short
=	O
save_color	int
;	O
This_Col	int
=	O
final_col	int
;	O
}	O
void	O
SLsmg_draw_vline	function
(	O
int	O
n	int
)	O
{	O
int	O
c	int
=	O
This_Col	int
,	O
rmin	int
,	O
rmax	int
;	O
int	O
final_row	int
=	O
This_Row	int
+	O
n	int
;	O
int	O
save_color	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
(	O
(	O
c	int
<	O
Start_Col	int
)	O
||	O
(	O
c	int
>=	O
Start_Col	int
+	O
(	O
int	O
)	O
Screen_Cols	int
)	O
)	O
||	O
(	O
0	int
==	O
compute_clip	function
(	O
This_Row	int
,	O
n	int
,	O
Start_Row	int
,	O
Start_Row	int
+	O
(	O
int	O
)	O
Screen_Rows	int
,	O
&	O
rmin	int
,	O
&	O
rmax	int
)	O
)	O
)	O
{	O
This_Row	int
=	O
final_row	int
;	O
return	O
;	O
}	O
save_color	int
=	O
This_Color	short
;	O
This_Color	short
|=	O
SLSMG_ACS_MASK	int
;	O
for	O
(	O
This_Row	int
=	O
rmin	int
;	O
This_Row	int
<	O
rmax	int
;	O
This_Row	int
++	O
)	O
{	O
This_Col	int
=	O
c	int
;	O
SLsmg_write_char	function
(	O
SLSMG_VLINE_CHAR	O
)	O
;	O
}	O
This_Col	int
=	O
c	int
;	O
This_Row	int
=	O
final_row	int
;	O
This_Color	short
=	O
save_color	int
;	O
}	O
void	O
SLsmg_draw_box	function
(	O
int	O
r	pointer
,	O
int	O
c	int
,	O
unsigned	O
int	O
dr	int
,	O
unsigned	O
int	O
dc	int
)	O
{	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
dr	int
||	O
!	O
dc	int
)	O
return	O
;	O
This_Row	int
=	O
r	pointer
;	O
This_Col	int
=	O
c	int
;	O
dr	int
--	O
;	O
dc	int
--	O
;	O
SLsmg_draw_hline	function
(	O
dc	int
)	O
;	O
SLsmg_draw_vline	function
(	O
dr	int
)	O
;	O
This_Row	int
=	O
r	pointer
;	O
This_Col	int
=	O
c	int
;	O
SLsmg_draw_vline	function
(	O
dr	int
)	O
;	O
SLsmg_draw_hline	function
(	O
dc	int
)	O
;	O
SLsmg_draw_object	function
(	O
r	pointer
,	O
c	int
,	O
SLSMG_ULCORN_CHAR	O
)	O
;	O
SLsmg_draw_object	function
(	O
r	pointer
,	O
c	int
+	O
(	O
int	O
)	O
dc	int
,	O
SLSMG_URCORN_CHAR	O
)	O
;	O
SLsmg_draw_object	function
(	O
r	pointer
+	O
(	O
int	O
)	O
dr	int
,	O
c	int
,	O
SLSMG_LLCORN_CHAR	O
)	O
;	O
SLsmg_draw_object	function
(	O
r	pointer
+	O
(	O
int	O
)	O
dr	int
,	O
c	int
+	O
(	O
int	O
)	O
dc	int
,	O
SLSMG_LRCORN_CHAR	O
)	O
;	O
This_Row	int
=	O
r	pointer
;	O
This_Col	int
=	O
c	int
;	O
}	O
void	O
SLsmg_fill_region	function
(	O
int	O
r	pointer
,	O
int	O
c	int
,	O
unsigned	O
int	O
dr	int
,	O
unsigned	O
int	O
dc	int
,	O
SLwchar_Type	int
wch	int
)	O
{	O
static	O
unsigned	O
char	O
buf	pointer
[	O
16	int
]	O
;	O
unsigned	O
char	O
ubuf	array
[	O
16	int
*	O
SLUTF8_MAX_MBLEN	int
]	O
;	O
unsigned	O
char	O
*	O
b	pointer
,	O
*	O
bmax	pointer
;	O
int	O
count	int
;	O
int	O
dcmax	int
,	O
rmax	int
;	O
unsigned	O
int	O
wchlen	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
SLsmg_gotorc	function
(	O
r	pointer
,	O
c	int
)	O
;	O
r	pointer
=	O
This_Row	int
;	O
c	int
=	O
This_Col	int
;	O
dcmax	int
=	O
Screen_Cols	int
-	O
This_Col	int
;	O
if	O
(	O
dcmax	int
<	O
0	int
)	O
return	O
;	O
if	O
(	O
dc	int
>	O
(	O
unsigned	O
int	O
)	O
dcmax	int
)	O
dc	int
=	O
(	O
unsigned	O
int	O
)	O
dcmax	int
;	O
rmax	int
=	O
This_Row	int
+	O
(	O
int	O
)	O
dr	int
;	O
if	O
(	O
rmax	int
>	O
(	O
int	O
)	O
Screen_Rows	int
)	O
rmax	int
=	O
(	O
int	O
)	O
Screen_Rows	int
;	O
if	O
(	O
(	O
wch	int
<	O
0x80	int
)	O
||	O
(	O
UTF8_Mode	int
==	O
0	int
)	O
)	O
{	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
!=	O
(	O
unsigned	O
char	O
)	O
wch	int
)	O
memset	function
(	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
(	O
unsigned	O
char	O
)	O
wch	int
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
b	pointer
=	O
buf	pointer
;	O
bmax	pointer
=	O
buf	pointer
+	O
sizeof	O
(	O
buf	pointer
)	O
;	O
wchlen	int
=	O
1	int
;	O
}	O
else	O
{	O
unsigned	O
int	O
i	array
;	O
b	pointer
=	O
ubuf	array
;	O
bmax	pointer
=	O
SLutf8_encode	function
(	O
wch	int
,	O
b	pointer
,	O
SLUTF8_MAX_MBLEN	int
)	O
;	O
if	O
(	O
bmax	pointer
==	O
NULL	O
)	O
{	O
bmax	pointer
=	O
ubuf	array
;	O
*	O
bmax	pointer
++	O
=	O
'?'	O
;	O
}	O
wchlen	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
bmax	pointer
-	O
b	pointer
)	O
;	O
for	O
(	O
i	array
=	O
1	int
;	O
i	array
<	O
16	int
;	O
i	array
++	O
)	O
{	O
memcpy	function
(	O
bmax	pointer
,	O
b	pointer
,	O
wchlen	int
)	O
;	O
bmax	pointer
+=	O
wchlen	int
;	O
}	O
}	O
for	O
(	O
This_Row	int
=	O
r	pointer
;	O
This_Row	int
<	O
rmax	int
;	O
This_Row	int
++	O
)	O
{	O
This_Col	int
=	O
c	int
;	O
count	int
=	O
dc	int
/	O
16	int
;	O
SLsmg_write_chars	function
(	O
b	pointer
,	O
b	pointer
+	O
wchlen	int
*	O
(	O
dc	int
%	O
16	int
)	O
)	O
;	O
while	O
(	O
count	int
--	O
>	O
0	int
)	O
{	O
SLsmg_write_chars	function
(	O
b	pointer
,	O
bmax	pointer
)	O
;	O
}	O
}	O
This_Row	int
=	O
r	pointer
;	O
}	O
void	O
SLsmg_forward	function
(	O
int	O
n	int
)	O
{	O
This_Col	int
+=	O
n	int
;	O
}	O
void	O
SLsmg_set_color_in_region	function
(	O
int	O
color	short
,	O
int	O
r	pointer
,	O
int	O
c	int
,	O
unsigned	O
int	O
dr	int
,	O
unsigned	O
int	O
dc	int
)	O
{	O
int	O
cmax	pointer
,	O
rmax	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
;	O
c	int
-=	O
Start_Col	int
;	O
r	pointer
-=	O
Start_Row	int
;	O
cmax	pointer
=	O
c	int
+	O
(	O
int	O
)	O
dc	int
;	O
rmax	int
=	O
r	pointer
+	O
(	O
int	O
)	O
dr	int
;	O
if	O
(	O
cmax	pointer
>	O
(	O
int	O
)	O
Screen_Cols	int
)	O
cmax	pointer
=	O
(	O
int	O
)	O
Screen_Cols	int
;	O
if	O
(	O
rmax	int
>	O
(	O
int	O
)	O
Screen_Rows	int
)	O
rmax	int
=	O
(	O
int	O
)	O
Screen_Rows	int
;	O
if	O
(	O
c	int
<	O
0	int
)	O
c	int
=	O
0	int
;	O
if	O
(	O
r	pointer
<	O
0	int
)	O
r	pointer
=	O
0	int
;	O
if	O
(	O
Bce_Color_Offset	int
)	O
color	short
+=	O
Bce_Color_Offset	int
;	O
while	O
(	O
r	pointer
<	O
rmax	int
)	O
{	O
SLsmg_Char_Type	struct
*	O
cell	pointer
,	O
*	O
cell_max	pointer
;	O
SL_Screen	array
[	O
r	pointer
]	O
.	O
flags	int
|=	O
TOUCHED	int
;	O
cell	pointer
=	O
SL_Screen	array
[	O
r	pointer
]	O
.	O
neew	pointer
;	O
cell_max	pointer
=	O
cell	pointer
+	O
cmax	pointer
;	O
cell	pointer
+=	O
c	int
;	O
while	O
(	O
cell	pointer
<	O
cell_max	pointer
)	O
{	O
int	O
acs	pointer
=	O
cell	pointer
->	O
color	short
&	O
SLSMG_ACS_MASK	int
;	O
cell	pointer
->	O
color	short
=	O
color	short
|	O
acs	pointer
;	O
cell	pointer
++	O
;	O
}	O
r	pointer
++	O
;	O
}	O
}	O
void	O
SLsmg_set_terminal_info	function
(	O
SLsmg_Term_Type	struct
*	O
tt	pointer
)	O
{	O
if	O
(	O
tt	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
(	O
tt	pointer
->	O
tt_normal_video	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_goto_rc	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_cls	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_del_eol	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_smart_puts	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_flush_output	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_reset_video	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_init_video	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_set_scroll_region	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_reverse_index	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_reset_scroll_region	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_delete_nlines	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_term_cannot_scroll	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_has_alt_charset	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_screen_cols	pointer
==	O
NULL	O
)	O
||	O
(	O
tt	pointer
->	O
tt_screen_rows	pointer
==	O
NULL	O
)	O
)	O
SLang_exit_error	function
(	O
"The Terminal not powerful enough for S-Lang's SLsmg interface"	pointer
)	O
;	O
tt_normal_video	pointer
=	O
tt	pointer
->	O
tt_normal_video	pointer
;	O
tt_goto_rc	pointer
=	O
tt	pointer
->	O
tt_goto_rc	pointer
;	O
tt_cls	pointer
=	O
tt	pointer
->	O
tt_cls	pointer
;	O
tt_del_eol	pointer
=	O
tt	pointer
->	O
tt_del_eol	pointer
;	O
tt_smart_puts	pointer
=	O
tt	pointer
->	O
tt_smart_puts	pointer
;	O
tt_flush_output	pointer
=	O
tt	pointer
->	O
tt_flush_output	pointer
;	O
tt_reset_video	pointer
=	O
tt	pointer
->	O
tt_reset_video	pointer
;	O
tt_init_video	pointer
=	O
tt	pointer
->	O
tt_init_video	pointer
;	O
tt_set_scroll_region	pointer
=	O
tt	pointer
->	O
tt_set_scroll_region	pointer
;	O
tt_reverse_index	pointer
=	O
tt	pointer
->	O
tt_reverse_index	pointer
;	O
tt_reset_scroll_region	pointer
=	O
tt	pointer
->	O
tt_reset_scroll_region	pointer
;	O
tt_delete_nlines	pointer
=	O
tt	pointer
->	O
tt_delete_nlines	pointer
;	O
tt_Term_Cannot_Scroll	pointer
=	O
tt	pointer
->	O
tt_term_cannot_scroll	pointer
;	O
tt_Has_Alt_Charset	pointer
=	O
tt	pointer
->	O
tt_has_alt_charset	pointer
;	O
tt_Screen_Cols	pointer
=	O
tt	pointer
->	O
tt_screen_cols	pointer
;	O
tt_Screen_Rows	pointer
=	O
tt	pointer
->	O
tt_screen_rows	pointer
;	O
tt_unicode_ok	pointer
=	O
tt	pointer
->	O
unicode_ok	pointer
;	O
}	O
void	O
SLsmg_write_color_chars	function
(	O
SLsmg_Char_Type	struct
*	O
s	pointer
,	O
unsigned	O
int	O
len	int
)	O
{	O
SLsmg_write_raw	function
(	O
s	pointer
,	O
len	int
)	O
;	O
}	O
unsigned	O
int	O
SLsmg_strwidth	function
(	O
SLuchar_Type	char
*	O
u	pointer
,	O
SLuchar_Type	char
*	O
umax	pointer
)	O
{	O
unsigned	O
char	O
display_8bit	char
;	O
int	O
utf8_mode	int
=	O
UTF8_Mode	int
;	O
int	O
col	int
;	O
if	O
(	O
u	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
display_8bit	char
=	O
(	O
unsigned	O
char	O
)	O
SLsmg_Display_Eight_Bit	int
;	O
if	O
(	O
utf8_mode	int
)	O
display_8bit	char
=	O
0xA0	int
;	O
col	int
=	O
This_Col	int
;	O
while	O
(	O
u	pointer
<	O
umax	pointer
)	O
{	O
SLuchar_Type	char
ch	int
;	O
unsigned	O
int	O
nconsumed	int
;	O
SLwchar_Type	int
wc	int
;	O
ch	int
=	O
*	O
u	pointer
;	O
if	O
(	O
ch	int
<	O
0x80	int
)	O
{	O
u	pointer
++	O
;	O
if	O
(	O
(	O
ch	int
>=	O
0x20	int
)	O
&&	O
(	O
ch	int
!=	O
0x7F	int
)	O
)	O
{	O
col	int
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ch	int
==	O
'\t'	O
)	O
&&	O
(	O
SLsmg_Tab_Width	int
>	O
0	int
)	O
)	O
{	O
if	O
(	O
col	int
>=	O
0	int
)	O
col	int
=	O
(	O
1	int
+	O
col	int
/	O
SLsmg_Tab_Width	int
)	O
*	O
SLsmg_Tab_Width	int
;	O
else	O
col	int
=	O
(	O
(	O
col	int
+	O
1	int
)	O
/	O
SLsmg_Tab_Width	int
)	O
*	O
SLsmg_Tab_Width	int
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ch	int
==	O
'\n'	O
)	O
&&	O
(	O
SLsmg_Newline_Behavior	int
!=	O
SLSMG_NEWLINE_PRINTABLE	int
)	O
)	O
break	O
;	O
if	O
(	O
(	O
ch	int
==	O
0x8	int
)	O
&&	O
SLsmg_Backspace_Moves	int
)	O
{	O
col	int
--	O
;	O
continue	O
;	O
}	O
if	O
(	O
(	O
ch	int
==	O
033	int
)	O
&&	O
Embedded_Escape_Mode	int
)	O
{	O
SLsmg_Color_Type	short
color	short
;	O
if	O
(	O
0	int
==	O
parse_embedded_escape	function
(	O
u	pointer
,	O
umax	pointer
,	O
0	int
,	O
&	O
u	pointer
,	O
&	O
color	short
)	O
)	O
continue	O
;	O
}	O
col	int
+=	O
2	int
;	O
continue	O
;	O
}	O
nconsumed	int
=	O
1	int
;	O
if	O
(	O
(	O
utf8_mode	int
==	O
0	int
)	O
||	O
(	O
NULL	O
==	O
SLutf8_decode	function
(	O
u	pointer
,	O
umax	pointer
,	O
&	O
wc	int
,	O
&	O
nconsumed	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
utf8_mode	int
==	O
0	int
)	O
&&	O
(	O
display_8bit	char
&&	O
(	O
*	O
u	pointer
>=	O
display_8bit	char
)	O
)	O
)	O
col	int
++	O
;	O
else	O
col	int
+=	O
4	int
*	O
nconsumed	int
;	O
u	pointer
+=	O
nconsumed	int
;	O
continue	O
;	O
}	O
u	pointer
+=	O
nconsumed	int
;	O
if	O
(	O
wc	int
<	O
(	O
SLwchar_Type	int
)	O
display_8bit	char
)	O
{	O
col	int
+=	O
4	int
;	O
continue	O
;	O
}	O
col	int
+=	O
SLwchar_wcwidth	function
(	O
wc	int
)	O
;	O
}	O
if	O
(	O
col	int
<	O
This_Col	int
)	O
return	O
0	int
;	O
return	O
(	O
unsigned	O
int	O
)	O
(	O
col	int
-	O
This_Col	int
)	O
;	O
}	O
unsigned	O
int	O
SLsmg_strbytes	function
(	O
SLuchar_Type	char
*	O
u	pointer
,	O
SLuchar_Type	char
*	O
umax	pointer
,	O
unsigned	O
int	O
width	int
)	O
{	O
SLuchar_Type	char
*	O
ustart	pointer
;	O
unsigned	O
char	O
display_8bit	char
;	O
int	O
utf8_mode	int
=	O
UTF8_Mode	int
;	O
int	O
col	int
,	O
col_max	int
;	O
if	O
(	O
u	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
display_8bit	char
=	O
(	O
unsigned	O
char	O
)	O
SLsmg_Display_Eight_Bit	int
;	O
if	O
(	O
utf8_mode	int
)	O
display_8bit	char
=	O
0xA0	int
;	O
col	int
=	O
This_Col	int
;	O
col_max	int
=	O
col	int
+	O
width	int
;	O
ustart	pointer
=	O
u	pointer
;	O
while	O
(	O
u	pointer
<	O
umax	pointer
)	O
{	O
SLuchar_Type	char
ch	int
;	O
SLwchar_Type	int
wc	int
;	O
unsigned	O
int	O
nconsumed	int
=	O
1	int
;	O
ch	int
=	O
*	O
u	pointer
;	O
if	O
(	O
ch	int
<	O
0x80	int
)	O
{	O
if	O
(	O
(	O
ch	int
>=	O
0x20	int
)	O
&&	O
(	O
ch	int
!=	O
0x7F	int
)	O
)	O
col	int
++	O
;	O
else	O
if	O
(	O
(	O
ch	int
==	O
'\t'	O
)	O
&&	O
(	O
SLsmg_Tab_Width	int
>	O
0	int
)	O
)	O
{	O
if	O
(	O
col	int
>=	O
0	int
)	O
col	int
=	O
(	O
1	int
+	O
col	int
/	O
SLsmg_Tab_Width	int
)	O
*	O
SLsmg_Tab_Width	int
;	O
else	O
col	int
=	O
(	O
(	O
col	int
+	O
1	int
)	O
/	O
SLsmg_Tab_Width	int
)	O
*	O
SLsmg_Tab_Width	int
;	O
}	O
else	O
if	O
(	O
(	O
ch	int
==	O
'\n'	O
)	O
&&	O
(	O
SLsmg_Newline_Behavior	int
!=	O
SLSMG_NEWLINE_PRINTABLE	int
)	O
)	O
break	O
;	O
else	O
if	O
(	O
(	O
ch	int
==	O
0x8	int
)	O
&&	O
SLsmg_Backspace_Moves	int
)	O
col	int
--	O
;	O
else	O
if	O
(	O
(	O
ch	int
==	O
033	int
)	O
&&	O
Embedded_Escape_Mode	int
)	O
{	O
SLsmg_Color_Type	short
color	short
;	O
SLuchar_Type	char
*	O
u1	pointer
=	O
u	pointer
+	O
1	int
;	O
if	O
(	O
-	O
1	int
==	O
parse_embedded_escape	function
(	O
u1	pointer
,	O
umax	pointer
,	O
0	int
,	O
&	O
u1	pointer
,	O
&	O
color	short
)	O
)	O
col	int
+=	O
2	int
;	O
nconsumed	int
=	O
(	O
u1	pointer
-	O
u	pointer
)	O
;	O
}	O
else	O
col	int
+=	O
2	int
;	O
}	O
else	O
if	O
(	O
(	O
utf8_mode	int
==	O
0	int
)	O
||	O
(	O
NULL	O
==	O
SLutf8_decode	function
(	O
u	pointer
,	O
umax	pointer
,	O
&	O
wc	int
,	O
&	O
nconsumed	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
utf8_mode	int
==	O
0	int
)	O
&&	O
(	O
display_8bit	char
&&	O
(	O
*	O
u	pointer
>=	O
display_8bit	char
)	O
)	O
)	O
col	int
++	O
;	O
else	O
col	int
+=	O
4	int
*	O
nconsumed	int
;	O
}	O
else	O
if	O
(	O
wc	int
<	O
(	O
SLwchar_Type	int
)	O
display_8bit	char
)	O
col	int
+=	O
4	int
;	O
else	O
col	int
+=	O
SLwchar_wcwidth	function
(	O
wc	int
)	O
;	O
if	O
(	O
col	int
>=	O
col_max	int
)	O
break	O
;	O
u	pointer
+=	O
nconsumed	int
;	O
}	O
return	O
(	O
unsigned	O
int	O
)	O
(	O
u	pointer
-	O
ustart	pointer
)	O
;	O
}	O
unsigned	O
int	O
SLsmg_read_raw	function
(	O
SLsmg_Char_Type	struct
*	O
buf	pointer
,	O
unsigned	O
int	O
len	int
)	O
{	O
unsigned	O
int	O
r	pointer
,	O
c	int
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
0	int
==	O
point_visible	function
(	O
1	int
)	O
)	O
return	O
0	int
;	O
r	pointer
=	O
(	O
unsigned	O
int	O
)	O
(	O
This_Row	int
-	O
Start_Row	int
)	O
;	O
c	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
This_Col	int
-	O
Start_Col	int
)	O
;	O
if	O
(	O
c	int
+	O
len	int
>	O
(	O
unsigned	O
int	O
)	O
Screen_Cols	int
)	O
len	int
=	O
(	O
unsigned	O
int	O
)	O
Screen_Cols	int
-	O
c	int
;	O
memcpy	function
(	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
(	O
char	O
*	O
)	O
(	O
SL_Screen	array
[	O
r	pointer
]	O
.	O
neew	pointer
+	O
c	int
)	O
,	O
len	int
*	O
sizeof	O
(	O
SLsmg_Char_Type	struct
)	O
)	O
;	O
return	O
len	int
;	O
}	O
unsigned	O
int	O
SLsmg_write_raw	function
(	O
SLsmg_Char_Type	struct
*	O
buf	pointer
,	O
unsigned	O
int	O
len	int
)	O
{	O
unsigned	O
int	O
r	pointer
,	O
c	int
;	O
SLsmg_Char_Type	struct
*	O
dest	pointer
;	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
0	int
==	O
point_visible	function
(	O
1	int
)	O
)	O
return	O
0	int
;	O
r	pointer
=	O
(	O
unsigned	O
int	O
)	O
(	O
This_Row	int
-	O
Start_Row	int
)	O
;	O
c	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
This_Col	int
-	O
Start_Col	int
)	O
;	O
if	O
(	O
c	int
+	O
len	int
>	O
(	O
unsigned	O
int	O
)	O
Screen_Cols	int
)	O
len	int
=	O
(	O
unsigned	O
int	O
)	O
Screen_Cols	int
-	O
c	int
;	O
dest	pointer
=	O
SL_Screen	array
[	O
r	pointer
]	O
.	O
neew	pointer
+	O
c	int
;	O
if	O
(	O
0	int
!=	O
memcmp	function
(	O
(	O
char	O
*	O
)	O
dest	pointer
,	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
len	int
*	O
sizeof	O
(	O
SLsmg_Char_Type	struct
)	O
)	O
)	O
{	O
memcpy	function
(	O
(	O
char	O
*	O
)	O
dest	pointer
,	O
(	O
char	O
*	O
)	O
buf	pointer
,	O
len	int
*	O
sizeof	O
(	O
SLsmg_Char_Type	struct
)	O
)	O
;	O
SL_Screen	array
[	O
r	pointer
]	O
.	O
flags	int
|=	O
TOUCHED	int
;	O
}	O
return	O
len	int
;	O
}	O
int	O
SLsmg_char_at	function
(	O
SLsmg_Char_Type	struct
*	O
cp	pointer
)	O
{	O
if	O
(	O
Smg_Inited	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
point_visible	function
(	O
1	int
)	O
)	O
{	O
SLsmg_Char_Type	struct
*	O
c	int
=	O
&	O
SL_Screen	array
[	O
This_Row	int
-	O
Start_Row	int
]	O
.	O
neew	pointer
[	O
This_Col	int
-	O
Start_Col	int
]	O
;	O
if	O
(	O
c	int
->	O
nchars	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
*	O
cp	pointer
=	O
*	O
c	int
;	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
SLsmg_utf8_enable	function
(	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
==	O
-	O
1	int
)	O
mode	int
=	O
_pSLutf8_mode	int
;	O
return	O
UTF8_Mode	int
=	O
mode	int
;	O
}	O
int	O
SLsmg_is_utf8_mode	function
(	O
void	O
)	O
{	O
int	O
mode	int
=	O
UTF8_Mode	int
;	O
if	O
(	O
mode	int
==	O
-	O
1	int
)	O
mode	int
=	O
_pSLutf8_mode	int
;	O
return	O
mode	int
;	O
}	O
