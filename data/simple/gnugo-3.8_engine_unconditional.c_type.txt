static	O
int	O
capture_non_invincible_strings	function
(	O
int	O
color	int
,	O
int	O
exceptions	array
[	O
BOARDMAX	O
]	O
,	O
int	O
*	O
none_invincible	pointer
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
something_captured	int
=	O
1	int
;	O
int	O
string_found	int
=	O
0	int
;	O
int	O
moves_played	int
=	O
0	int
;	O
int	O
save_moves	int
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	pointer
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
while	O
(	O
something_captured	int
)	O
{	O
something_captured	int
=	O
0	int
;	O
string_found	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
color	int
||	O
find_origin	function
(	O
pos	int
)	O
!=	O
pos	int
)	O
continue	O
;	O
if	O
(	O
exceptions	array
&&	O
exceptions	array
[	O
pos	int
]	O
)	O
continue	O
;	O
string_found	int
=	O
1	int
;	O
liberties	pointer
=	O
findlib	function
(	O
pos	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
save_moves	int
=	O
moves_played	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
other	int
,	O
"unconditional_life"	pointer
,	O
pos	int
)	O
)	O
moves_played	int
++	O
;	O
}	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
something_captured	int
=	O
1	int
;	O
else	O
if	O
(	O
findlib	function
(	O
pos	int
,	O
2	int
,	O
libs	pointer
)	O
==	O
1	int
)	O
{	O
int	O
success	int
=	O
tryko	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
other	int
,	O
"unconditional_life"	pointer
)	O
;	O
gg_assert	O
(	O
success	int
)	O
;	O
moves_played	int
++	O
;	O
something_captured	int
=	O
1	int
;	O
}	O
else	O
while	O
(	O
moves_played	int
>	O
save_moves	int
)	O
{	O
popgo	function
(	O
)	O
;	O
moves_played	int
--	O
;	O
}	O
}	O
}	O
if	O
(	O
none_invincible	pointer
)	O
*	O
none_invincible	pointer
=	O
!	O
string_found	int
;	O
return	O
moves_played	int
;	O
}	O
void	O
unconditional_life	function
(	O
int	O
unconditional_territory	array
[	O
BOARDMAX	O
]	O
,	O
int	O
color	int
)	O
{	O
int	O
found_one	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	pointer
;	O
int	O
pos	int
;	O
int	O
k	int
,	O
r	int
;	O
int	O
moves_played	int
;	O
int	O
potential_sekis	array
[	O
BOARDMAX	O
]	O
;	O
int	O
none_invincible	pointer
;	O
memset	function
(	O
unconditional_territory	array
,	O
0	int
,	O
sizeof	O
(	O
unconditional_territory	array
[	O
0	int
]	O
)	O
*	O
BOARDMAX	O
)	O
;	O
memset	function
(	O
potential_sekis	array
,	O
0	int
,	O
sizeof	O
(	O
potential_sekis	array
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
isolated	int
=	O
1	int
;	O
int	O
stones	pointer
[	O
2	int
]	O
;	O
int	O
pos2	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
color	int
||	O
find_origin	function
(	O
pos	int
)	O
!=	O
pos	int
||	O
countstones	function
(	O
pos	int
)	O
!=	O
2	int
)	O
continue	O
;	O
findstones	function
(	O
pos	int
,	O
2	int
,	O
stones	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
&&	O
isolated	int
;	O
k	int
++	O
)	O
{	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
8	int
&&	O
isolated	int
;	O
r	int
++	O
)	O
{	O
pos2	int
=	O
stones	pointer
[	O
k	int
]	O
+	O
delta	array
[	O
r	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos2	int
)	O
||	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
color	int
&&	O
!	O
same_string	function
(	O
pos	int
,	O
pos2	int
)	O
)	O
)	O
isolated	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
isolated	int
)	O
{	O
potential_sekis	array
[	O
stones	pointer
[	O
0	int
]	O
]	O
=	O
1	int
;	O
potential_sekis	array
[	O
stones	pointer
[	O
1	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
moves_played	int
=	O
capture_non_invincible_strings	function
(	O
color	int
,	O
potential_sekis	array
,	O
&	O
none_invincible	pointer
)	O
;	O
if	O
(	O
none_invincible	pointer
)	O
{	O
while	O
(	O
moves_played	int
>	O
0	int
)	O
{	O
popgo	function
(	O
)	O
;	O
moves_played	int
--	O
;	O
}	O
return	O
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
color	int
||	O
potential_sekis	array
[	O
pos	int
]	O
||	O
find_origin	function
(	O
pos	int
)	O
!=	O
pos	int
)	O
continue	O
;	O
liberties	pointer
=	O
findlib	function
(	O
pos	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
other	int
,	O
"unconditional_life"	pointer
,	O
pos	int
)	O
)	O
moves_played	int
++	O
;	O
}	O
}	O
found_one	int
=	O
1	int
;	O
while	O
(	O
found_one	int
)	O
{	O
found_one	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
other	int
||	O
countlib	function
(	O
pos	int
)	O
>	O
1	int
)	O
continue	O
;	O
findlib	function
(	O
pos	int
,	O
1	int
,	O
libs	pointer
)	O
;	O
if	O
(	O
trymove	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
other	int
,	O
"unconditional_life"	pointer
,	O
pos	int
)	O
)	O
{	O
moves_played	int
++	O
;	O
found_one	int
=	O
1	int
;	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
potential_sekis	array
[	O
pos	int
]	O
||	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
find_origin	function
(	O
pos	int
)	O
!=	O
pos	int
)	O
continue	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
int	O
up	int
=	O
delta	array
[	O
r	int
]	O
;	O
int	O
right	int
=	O
delta	array
[	O
(	O
r	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
int	O
locally_played_moves	int
=	O
0	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
up	int
]	O
!=	O
color	int
||	O
board	pointer
[	O
pos	int
+	O
up	int
+	O
up	int
]	O
!=	O
EMPTY	int
||	O
board	pointer
[	O
pos	int
-	O
up	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
k	int
==	O
1	int
)	O
right	int
=	O
-	O
right	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
right	int
]	O
!=	O
EMPTY	int
||	O
board	pointer
[	O
pos	int
+	O
up	int
-	O
right	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
-	O
right	int
]	O
==	O
EMPTY	int
&&	O
trymove	function
(	O
pos	int
-	O
right	int
,	O
other	int
,	O
"unconditional_life"	pointer
,	O
pos	int
)	O
)	O
locally_played_moves	int
++	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
up	int
+	O
right	int
]	O
==	O
EMPTY	int
&&	O
trymove	function
(	O
pos	int
+	O
up	int
+	O
right	int
,	O
other	int
,	O
"unconditional_life"	pointer
,	O
pos	int
)	O
)	O
locally_played_moves	int
++	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
-	O
right	int
]	O
==	O
other	int
&&	O
board	pointer
[	O
pos	int
+	O
up	int
+	O
right	int
]	O
==	O
other	int
&&	O
same_string	function
(	O
pos	int
-	O
right	int
,	O
pos	int
+	O
up	int
+	O
right	int
)	O
)	O
{	O
while	O
(	O
locally_played_moves	int
>	O
0	int
)	O
{	O
popgo	function
(	O
)	O
;	O
locally_played_moves	int
--	O
;	O
}	O
trymove	function
(	O
pos	int
-	O
up	int
,	O
color	int
,	O
"unconditional_life"	pointer
,	O
pos	int
)	O
;	O
moves_played	int
++	O
;	O
break	O
;	O
}	O
else	O
{	O
while	O
(	O
locally_played_moves	int
>	O
0	int
)	O
{	O
popgo	function
(	O
)	O
;	O
locally_played_moves	int
--	O
;	O
}	O
}	O
}	O
if	O
(	O
countstones	function
(	O
pos	int
)	O
>	O
2	int
)	O
break	O
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
potential_sekis	array
[	O
pos	int
]	O
||	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
continue	O
;	O
liberties	pointer
=	O
findlib	function
(	O
pos	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
{	O
if	O
(	O
trymove	function
(	O
libs	pointer
[	O
k	int
]	O
,	O
other	int
,	O
"unconditional_life"	pointer
,	O
pos	int
)	O
)	O
moves_played	int
++	O
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
apos	int
;	O
int	O
bpos	int
;	O
int	O
aopen	int
,	O
bopen	int
;	O
int	O
alib	int
,	O
blib	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
other	int
||	O
countlib	function
(	O
pos	int
)	O
!=	O
2	int
)	O
continue	O
;	O
findlib	function
(	O
pos	int
,	O
2	int
,	O
libs	pointer
)	O
;	O
apos	int
=	O
libs	pointer
[	O
0	int
]	O
;	O
bpos	int
=	O
libs	pointer
[	O
1	int
]	O
;	O
if	O
(	O
abs	function
(	O
I	O
(	O
apos	int
)	O
-	O
I	O
(	O
bpos	int
)	O
)	O
+	O
abs	function
(	O
J	O
(	O
apos	int
)	O
-	O
J	O
(	O
bpos	int
)	O
)	O
!=	O
1	int
)	O
continue	O
;	O
aopen	int
=	O
approxlib	function
(	O
apos	int
,	O
color	int
,	O
4	int
,	O
NULL	O
)	O
;	O
bopen	int
=	O
approxlib	function
(	O
bpos	int
,	O
color	int
,	O
4	int
,	O
NULL	O
)	O
;	O
alib	int
=	O
approxlib	function
(	O
apos	int
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
;	O
blib	int
=	O
approxlib	function
(	O
bpos	int
,	O
other	int
,	O
4	int
,	O
NULL	O
)	O
;	O
if	O
(	O
aopen	int
>	O
bopen	int
||	O
(	O
aopen	int
==	O
bopen	int
&&	O
alib	int
>=	O
blib	int
)	O
)	O
{	O
trymove	function
(	O
apos	int
,	O
other	int
,	O
"unconditional_life"	pointer
,	O
pos	int
)	O
;	O
moves_played	int
++	O
;	O
}	O
else	O
{	O
trymove	function
(	O
bpos	int
,	O
other	int
,	O
"unconditional_life"	pointer
,	O
pos	int
)	O
;	O
moves_played	int
++	O
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
!	O
potential_sekis	array
[	O
pos	int
]	O
)	O
{	O
unconditional_territory	array
[	O
pos	int
]	O
=	O
1	int
;	O
if	O
(	O
find_origin	function
(	O
pos	int
)	O
==	O
pos	int
)	O
{	O
liberties	pointer
=	O
findlib	function
(	O
pos	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
liberties	pointer
;	O
k	int
++	O
)	O
unconditional_territory	array
[	O
libs	pointer
[	O
k	int
]	O
]	O
=	O
2	int
;	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
countlib	function
(	O
pos	int
)	O
==	O
1	int
)	O
{	O
unconditional_territory	array
[	O
pos	int
]	O
=	O
2	int
;	O
findlib	function
(	O
pos	int
,	O
1	int
,	O
libs	pointer
)	O
;	O
unconditional_territory	array
[	O
libs	pointer
[	O
0	int
]	O
]	O
=	O
2	int
;	O
}	O
}	O
while	O
(	O
moves_played	int
>	O
0	int
)	O
{	O
popgo	function
(	O
)	O
;	O
moves_played	int
--	O
;	O
}	O
}	O
void	O
find_unconditionally_meaningless_moves	function
(	O
int	O
unconditional_territory	array
[	O
BOARDMAX	O
]	O
,	O
int	O
color	int
)	O
{	O
int	O
*	O
meaningless_moves	pointer
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
friendly_unconditional	array
[	O
BOARDMAX	O
]	O
;	O
int	O
opponent_unconditional	array
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
int	O
pos2	int
;	O
gg_assert	O
(	O
color	int
==	O
BLACK	int
||	O
color	int
==	O
WHITE	int
)	O
;	O
if	O
(	O
color	int
==	O
BLACK	int
)	O
meaningless_moves	pointer
=	O
meaningless_black_moves	array
;	O
else	O
meaningless_moves	pointer
=	O
meaningless_white_moves	array
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
unconditional_territory	array
[	O
pos	int
]	O
)	O
meaningless_moves	pointer
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
else	O
meaningless_moves	pointer
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
||	O
meaningless_moves	pointer
[	O
pos	int
]	O
!=	O
-	O
1	int
)	O
continue	O
;	O
if	O
(	O
!	O
tryko	function
(	O
pos	int
,	O
color	int
,	O
"find_unconditionally_meaningless_moves"	pointer
)	O
)	O
continue	O
;	O
unconditional_life	function
(	O
opponent_unconditional	array
,	O
other	int
)	O
;	O
if	O
(	O
opponent_unconditional	array
[	O
pos	int
]	O
)	O
{	O
meaningless_moves	pointer
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
}	O
else	O
{	O
unconditional_life	function
(	O
friendly_unconditional	array
,	O
color	int
)	O
;	O
if	O
(	O
friendly_unconditional	array
[	O
pos	int
]	O
)	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
&&	O
meaningless_moves	pointer
[	O
pos2	int
]	O
==	O
-	O
1	int
&&	O
friendly_unconditional	array
[	O
pos2	int
]	O
)	O
{	O
meaningless_moves	pointer
[	O
pos2	int
]	O
=	O
pos	int
;	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
meaningless_moves	pointer
[	O
pos	int
]	O
>	O
0	int
)	O
while	O
(	O
meaningless_moves	pointer
[	O
meaningless_moves	pointer
[	O
pos	int
]	O
]	O
>	O
0	int
)	O
meaningless_moves	pointer
[	O
pos	int
]	O
=	O
meaningless_moves	pointer
[	O
meaningless_moves	pointer
[	O
pos	int
]	O
]	O
;	O
}	O
int	O
unconditionally_meaningless_move	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
*	O
replacement_move	pointer
)	O
{	O
if	O
(	O
color	int
==	O
WHITE	int
&&	O
meaningless_white_moves	array
[	O
pos	int
]	O
!=	O
-	O
1	int
)	O
{	O
*	O
replacement_move	pointer
=	O
meaningless_white_moves	array
[	O
pos	int
]	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
color	int
==	O
BLACK	int
&&	O
meaningless_black_moves	array
[	O
pos	int
]	O
!=	O
-	O
1	int
)	O
{	O
*	O
replacement_move	pointer
=	O
meaningless_black_moves	array
[	O
pos	int
]	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
clear_unconditionally_meaningless_moves	function
(	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
meaningless_black_moves	array
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
meaningless_white_moves	array
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
}	O
}	O
void	O
unconditional_move_reasons	function
(	O
int	O
color	int
)	O
{	O
int	O
replacement_move	pointer
;	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
unconditionally_meaningless_move	function
(	O
pos	int
,	O
color	int
,	O
&	O
replacement_move	pointer
)	O
)	O
{	O
if	O
(	O
replacement_move	pointer
==	O
NO_MOVE	O
)	O
{	O
TRACE	O
(	O
"%1m unconditional antisuji.\n"	pointer
,	O
pos	int
)	O
;	O
add_antisuji_move	function
(	O
pos	int
)	O
;	O
}	O
else	O
{	O
TRACE	O
(	O
"%1m unconditionally replaced to %1m.\n"	pointer
,	O
pos	int
,	O
replacement_move	pointer
)	O
;	O
add_replacement_move	function
(	O
pos	int
,	O
replacement_move	pointer
,	O
color	int
)	O
;	O
}	O
}	O
}	O
