typedef	O
struct	O
_FDSTACK_s	struct
{	O
FDIO_t	pointer
io	pointer
;	O
void	O
*	O
fp	pointer
;	O
int	O
fdno	int
;	O
}	O
FDSTACK_t	struct
;	O
typedef	O
struct	O
{	O
int	O
count	long
;	O
off_t	long
bytes	long
;	O
time_t	long
msecs	long
;	O
}	O
OPSTAT_t	struct
;	O
typedef	O
struct	O
{	O
struct	O
timeval	struct
create	struct
;	O
struct	O
timeval	struct
begin	struct
;	O
OPSTAT_t	struct
ops	array
[	O
4	int
]	O
;	O
}	O
FDSTAT_t	struct
;	O
struct	O
_FD_s	struct
{	O
int	O
nrefs	int
;	O
int	O
flags	int
;	O
int	O
magic	array
;	O
int	O
nfps	int
;	O
FDSTACK_t	struct
fps	array
[	O
8	int
]	O
;	O
int	O
urlType	int
;	O
void	O
*	O
url	pointer
;	O
int	O
rd_timeoutsecs	int
;	O
ssize_t	long
bytesRemain	long
;	O
ssize_t	long
contentLength	long
;	O
int	O
persist	int
;	O
int	O
wr_chunked	int
;	O
int	O
syserrno	int
;	O
const	O
void	O
*	O
errcookie	pointer
;	O
FDSTAT_t	struct
*	O
stats	pointer
;	O
int	O
ftpFileDoneNeeded	int
;	O
unsigned	O
int	O
firstFree	int
;	O
long	O
int	O
fileSize	long
;	O
long	O
int	O
fd_cpioPos	long
;	O
}	O
;	O
int	O
noLibio	int
=	O
1	int
;	O
static	O
int	O
ftpTimeoutSecs	int
=	O
TIMEOUT_SECS	int
;	O
static	O
int	O
httpTimeoutSecs	int
=	O
TIMEOUT_SECS	int
;	O
int	O
_ftp_debug	int
=	O
0	int
;	O
int	O
_rpmio_debug	int
=	O
0	int
;	O
const	O
FDIO_t	pointer
fdGetIo	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
return	O
fd	pointer
->	O
fps	array
[	O
fd	pointer
->	O
nfps	int
]	O
.	O
io	pointer
;	O
}	O
void	O
fdSetIo	function
(	O
FD_t	pointer
fd	pointer
,	O
FDIO_t	pointer
io	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
fd	pointer
->	O
fps	array
[	O
fd	pointer
->	O
nfps	int
]	O
.	O
io	pointer
=	O
io	pointer
;	O
return	O
;	O
}	O
inline	O
void	O
*	O
fdGetFp	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
return	O
fd	pointer
->	O
fps	array
[	O
fd	pointer
->	O
nfps	int
]	O
.	O
fp	pointer
;	O
}	O
static	O
inline	O
void	O
fdSetFp	function
(	O
FD_t	pointer
fd	pointer
,	O
void	O
*	O
fp	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
fd	pointer
->	O
fps	array
[	O
fd	pointer
->	O
nfps	int
]	O
.	O
fp	pointer
=	O
fp	pointer
;	O
}	O
static	O
inline	O
int	O
fdGetFdno	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
return	O
fd	pointer
->	O
fps	array
[	O
fd	pointer
->	O
nfps	int
]	O
.	O
fdno	int
;	O
}	O
void	O
fdSetFdno	function
(	O
FD_t	pointer
fd	pointer
,	O
int	O
fdno	int
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
fd	pointer
->	O
fps	array
[	O
fd	pointer
->	O
nfps	int
]	O
.	O
fdno	int
=	O
fdno	int
;	O
}	O
void	O
fdSetContentLength	function
(	O
FD_t	pointer
fd	pointer
,	O
ssize_t	long
contentLength	long
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
fd	pointer
->	O
contentLength	long
=	O
fd	pointer
->	O
bytesRemain	long
=	O
contentLength	long
;	O
}	O
static	O
const	O
char	O
*	O
fdbg	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
static	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
char	O
*	O
be	pointer
=	O
buf	pointer
;	O
int	O
i	int
;	O
if	O
(	O
fd	pointer
->	O
bytesRemain	long
!=	O
-	O
1	int
)	O
{	O
sprintf	function
(	O
be	pointer
,	O
" clen %d"	pointer
,	O
fd	pointer
->	O
bytesRemain	long
)	O
;	O
be	pointer
+=	O
strlen	function
(	O
be	pointer
)	O
;	O
}	O
if	O
(	O
fd	pointer
->	O
wr_chunked	int
)	O
{	O
strcpy	function
(	O
be	pointer
,	O
" chunked"	pointer
)	O
;	O
be	pointer
+=	O
strlen	function
(	O
be	pointer
)	O
;	O
}	O
*	O
be	pointer
++	O
=	O
'\t'	O
;	O
for	O
(	O
i	int
=	O
fd	pointer
->	O
nfps	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
{	O
FDSTACK_t	struct
*	O
fps	array
=	O
&	O
fd	pointer
->	O
fps	array
[	O
i	int
]	O
;	O
if	O
(	O
i	int
!=	O
fd	pointer
->	O
nfps	int
)	O
*	O
be	pointer
++	O
=	O
' '	O
;	O
*	O
be	pointer
++	O
=	O
'|'	O
;	O
*	O
be	pointer
++	O
=	O
' '	O
;	O
if	O
(	O
fps	array
->	O
io	pointer
==	O
fdio	pointer
)	O
{	O
sprintf	function
(	O
be	pointer
,	O
"FD %d fp %p"	pointer
,	O
fps	array
->	O
fdno	int
,	O
fps	array
->	O
fp	pointer
)	O
;	O
}	O
else	O
if	O
(	O
fps	array
->	O
io	pointer
==	O
ufdio	pointer
)	O
{	O
sprintf	function
(	O
be	pointer
,	O
"UFD %d fp %p"	pointer
,	O
fps	array
->	O
fdno	int
,	O
fps	array
->	O
fp	pointer
)	O
;	O
}	O
else	O
if	O
(	O
fps	array
->	O
io	pointer
==	O
fadio	pointer
)	O
{	O
sprintf	function
(	O
be	pointer
,	O
"FAD %d fp %p"	pointer
,	O
fps	array
->	O
fdno	int
,	O
fps	array
->	O
fp	pointer
)	O
;	O
}	O
else	O
if	O
(	O
fps	array
->	O
io	pointer
==	O
fpio	pointer
)	O
{	O
sprintf	function
(	O
be	pointer
,	O
"%s %p(%d) fdno %d"	pointer
,	O
(	O
fps	array
->	O
fdno	int
<	O
0	int
?	O
"LIBIO"	pointer
:	O
"FP"	pointer
)	O
,	O
fps	array
->	O
fp	pointer
,	O
fileno	function
(	O
(	O
(	O
FILE	struct
*	O
)	O
fps	array
->	O
fp	pointer
)	O
)	O
,	O
fps	array
->	O
fdno	int
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
be	pointer
,	O
"??? io %p fp %p fdno %d ???"	pointer
,	O
fps	array
->	O
io	pointer
,	O
fps	array
->	O
fp	pointer
,	O
fps	array
->	O
fdno	int
)	O
;	O
}	O
be	pointer
+=	O
strlen	function
(	O
be	pointer
)	O
;	O
*	O
be	pointer
=	O
'\0'	O
;	O
}	O
return	O
buf	pointer
;	O
}	O
inline	O
void	O
fdPush	function
(	O
FD_t	pointer
fd	pointer
,	O
FDIO_t	pointer
io	pointer
,	O
void	O
*	O
fp	pointer
,	O
int	O
fdno	int
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
if	O
(	O
fd	pointer
->	O
nfps	int
>=	O
(	O
sizeof	O
(	O
fd	pointer
->	O
fps	array
)	O
/	O
sizeof	O
(	O
fd	pointer
->	O
fps	array
[	O
0	int
]	O
)	O
-	O
1	int
)	O
)	O
return	O
;	O
fd	pointer
->	O
nfps	int
++	O
;	O
fdSetIo	function
(	O
fd	pointer
,	O
io	pointer
)	O
;	O
fdSetFp	function
(	O
fd	pointer
,	O
fp	pointer
)	O
;	O
fdSetFdno	function
(	O
fd	pointer
,	O
fdno	int
)	O
;	O
DBGIO	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
"==>\tfdPush(%p,%p,%p,%d) lvl %d %s\n"	pointer
,	O
fd	pointer
,	O
io	pointer
,	O
fp	pointer
,	O
fdno	int
,	O
fd	pointer
->	O
nfps	int
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
}	O
inline	O
void	O
fdPop	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
if	O
(	O
fd	pointer
->	O
nfps	int
<	O
0	int
)	O
return	O
;	O
DBGIO	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
"==>\tfdPop(%p) lvl %d io %p fp %p fdno %d %s\n"	pointer
,	O
fd	pointer
,	O
fd	pointer
->	O
nfps	int
,	O
fdGetIo	function
(	O
fd	pointer
)	O
,	O
fdGetFp	function
(	O
fd	pointer
)	O
,	O
fdGetFdno	function
(	O
fd	pointer
)	O
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
fdSetIo	function
(	O
fd	pointer
,	O
NULL	O
)	O
;	O
fdSetFp	function
(	O
fd	pointer
,	O
NULL	O
)	O
;	O
fdSetFdno	function
(	O
fd	pointer
,	O
-	O
1	int
)	O
;	O
fd	pointer
->	O
nfps	int
--	O
;	O
}	O
static	O
inline	O
void	O
fdstat_enter	function
(	O
FD_t	pointer
fd	pointer
,	O
int	O
opx	int
)	O
{	O
if	O
(	O
fd	pointer
->	O
stats	pointer
==	O
NULL	O
)	O
return	O
;	O
fd	pointer
->	O
stats	pointer
->	O
ops	array
[	O
opx	int
]	O
.	O
count	long
++	O
;	O
gettimeofday	function
(	O
&	O
fd	pointer
->	O
stats	pointer
->	O
begin	struct
,	O
NULL	O
)	O
;	O
}	O
static	O
inline	O
time_t	long
tvsub	function
(	O
struct	O
timeval	struct
*	O
etv	pointer
,	O
struct	O
timeval	struct
*	O
btv	pointer
)	O
{	O
time_t	long
secs	int
,	O
usecs	long
;	O
if	O
(	O
!	O
(	O
etv	pointer
&&	O
btv	pointer
)	O
)	O
return	O
0	int
;	O
secs	int
=	O
etv	pointer
->	O
tv_sec	long
-	O
btv	pointer
->	O
tv_sec	long
;	O
usecs	long
=	O
etv	pointer
->	O
tv_usec	long
-	O
btv	pointer
->	O
tv_usec	long
;	O
while	O
(	O
usecs	long
<	O
0	int
)	O
{	O
secs	int
++	O
;	O
usecs	long
+=	O
1000000	int
;	O
}	O
return	O
(	O
(	O
secs	int
*	O
1000	int
)	O
+	O
(	O
usecs	long
/	O
1000	int
)	O
)	O
;	O
}	O
static	O
inline	O
void	O
fdstat_exit	function
(	O
FD_t	pointer
fd	pointer
,	O
int	O
opx	int
,	O
ssize_t	long
rc	long
)	O
{	O
struct	O
timeval	struct
end	struct
;	O
if	O
(	O
rc	long
==	O
-	O
1	int
)	O
fd	pointer
->	O
syserrno	int
=	O
errno	O
;	O
if	O
(	O
fd	pointer
->	O
stats	pointer
==	O
NULL	O
)	O
return	O
;	O
gettimeofday	function
(	O
&	O
end	struct
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	long
>=	O
0	int
)	O
{	O
switch	O
(	O
opx	int
)	O
{	O
case	O
FDSTAT_SEEK	int
:	O
fd	pointer
->	O
stats	pointer
->	O
ops	array
[	O
opx	int
]	O
.	O
bytes	long
=	O
rc	long
;	O
break	O
;	O
default	O
:	O
fd	pointer
->	O
stats	pointer
->	O
ops	array
[	O
opx	int
]	O
.	O
bytes	long
+=	O
rc	long
;	O
if	O
(	O
fd	pointer
->	O
bytesRemain	long
>	O
0	int
)	O
fd	pointer
->	O
bytesRemain	long
-=	O
rc	long
;	O
break	O
;	O
}	O
}	O
fd	pointer
->	O
stats	pointer
->	O
ops	array
[	O
opx	int
]	O
.	O
msecs	long
+=	O
tvsub	function
(	O
&	O
end	struct
,	O
&	O
fd	pointer
->	O
stats	pointer
->	O
begin	struct
)	O
;	O
fd	pointer
->	O
stats	pointer
->	O
begin	struct
=	O
end	struct
;	O
}	O
static	O
void	O
fdstat_print	function
(	O
FD_t	pointer
fd	pointer
,	O
const	O
char	O
*	O
msg	pointer
,	O
FILE	struct
*	O
fp	pointer
)	O
{	O
int	O
opx	int
;	O
if	O
(	O
fd	pointer
->	O
stats	pointer
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
opx	int
=	O
0	int
;	O
opx	int
<	O
4	int
;	O
opx	int
++	O
)	O
{	O
OPSTAT_t	struct
*	O
ops	array
=	O
&	O
fd	pointer
->	O
stats	pointer
->	O
ops	array
[	O
opx	int
]	O
;	O
if	O
(	O
ops	array
->	O
count	long
<=	O
0	int
)	O
continue	O
;	O
switch	O
(	O
opx	int
)	O
{	O
case	O
FDSTAT_READ	int
:	O
if	O
(	O
msg	pointer
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s:"	pointer
,	O
msg	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%8d reads, %8ld total bytes in %d.%03d secs\n"	pointer
,	O
ops	array
->	O
count	long
,	O
(	O
long	O
)	O
ops	array
->	O
bytes	long
,	O
(	O
int	O
)	O
(	O
ops	array
->	O
msecs	long
/	O
1000	int
)	O
,	O
(	O
int	O
)	O
(	O
ops	array
->	O
msecs	long
%	O
1000	int
)	O
)	O
;	O
break	O
;	O
case	O
FDSTAT_WRITE	int
:	O
if	O
(	O
msg	pointer
)	O
fprintf	function
(	O
fp	pointer
,	O
"%s:"	pointer
,	O
msg	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"%8d writes, %8ld total bytes in %d.%03d secs\n"	pointer
,	O
ops	array
->	O
count	long
,	O
(	O
long	O
)	O
ops	array
->	O
bytes	long
,	O
(	O
int	O
)	O
(	O
ops	array
->	O
msecs	long
/	O
1000	int
)	O
,	O
(	O
int	O
)	O
(	O
ops	array
->	O
msecs	long
%	O
1000	int
)	O
)	O
;	O
break	O
;	O
case	O
FDSTAT_SEEK	int
:	O
break	O
;	O
case	O
FDSTAT_CLOSE	int
:	O
break	O
;	O
}	O
}	O
}	O
off_t	long
fdSize	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
struct	O
stat	struct
sb	struct
;	O
off_t	long
rc	long
=	O
-	O
1	int
;	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
if	O
(	O
fd	pointer
->	O
contentLength	long
>=	O
0	int
)	O
rc	long
=	O
fd	pointer
->	O
contentLength	long
;	O
else	O
switch	O
(	O
fd	pointer
->	O
urlType	int
)	O
{	O
case	O
URL_IS_PATH	int
:	O
case	O
URL_IS_UNKNOWN	int
:	O
if	O
(	O
fstat	function
(	O
Fileno	function
(	O
fd	pointer
)	O
,	O
&	O
sb	struct
)	O
==	O
0	int
)	O
rc	long
=	O
sb	struct
.	O
st_size	long
;	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_DASH	int
:	O
break	O
;	O
}	O
return	O
rc	long
;	O
}	O
void	O
fdSetSyserrno	function
(	O
FD_t	pointer
fd	pointer
,	O
int	O
syserrno	int
,	O
const	O
void	O
*	O
errcookie	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
fd	pointer
->	O
syserrno	int
=	O
syserrno	int
;	O
fd	pointer
->	O
errcookie	pointer
=	O
errcookie	pointer
;	O
}	O
int	O
fdGetRdTimeoutSecs	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
return	O
fd	pointer
->	O
rd_timeoutsecs	int
;	O
}	O
long	O
int	O
fdGetCpioPos	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
return	O
fd	pointer
->	O
fd_cpioPos	long
;	O
}	O
void	O
fdSetCpioPos	function
(	O
FD_t	pointer
fd	pointer
,	O
long	O
int	O
cpioPos	long
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
fd	pointer
->	O
fd_cpioPos	long
=	O
cpioPos	long
;	O
}	O
FD_t	pointer
fdDup	function
(	O
int	O
fdno	int
)	O
{	O
FD_t	pointer
fd	pointer
;	O
int	O
nfdno	int
;	O
if	O
(	O
(	O
nfdno	int
=	O
dup	function
(	O
fdno	int
)	O
)	O
<	O
0	int
)	O
return	O
NULL	O
;	O
fd	pointer
=	O
fdNew	O
(	O
"open (fdDup)"	pointer
)	O
;	O
fdSetFdno	function
(	O
fd	pointer
,	O
nfdno	int
)	O
;	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==> fdDup(%d) fd %p %s\n"	pointer
,	O
fdno	int
,	O
fd	pointer
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
return	O
fd	pointer
;	O
}	O
static	O
inline	O
FD_t	pointer
c2f	function
(	O
void	O
*	O
cookie	pointer
)	O
{	O
FD_t	pointer
fd	pointer
=	O
(	O
FD_t	pointer
)	O
cookie	pointer
;	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
return	O
fd	pointer
;	O
}	O
static	O
inline	O
int	O
fdSeekNot	function
(	O
void	O
*	O
cookie	pointer
,	O
off_t	long
pos	long
,	O
int	O
whence	int
)	O
{	O
FD_t	pointer
fd	pointer
=	O
c2f	function
(	O
cookie	pointer
)	O
;	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
static	O
inline	O
FD_t	pointer
XfdLink	function
(	O
void	O
*	O
cookie	pointer
,	O
const	O
char	O
*	O
msg	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
unsigned	O
line	int
)	O
{	O
FD_t	pointer
fd	pointer
;	O
if	O
(	O
cookie	pointer
==	O
NULL	O
)	O
DBGREFS	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
"--> fd  %p ++ %d %s at %s:%u\n"	pointer
,	O
cookie	pointer
,	O
FDNREFS	O
(	O
cookie	pointer
)	O
+	O
1	int
,	O
msg	pointer
,	O
file	pointer
,	O
line	int
)	O
)	O
;	O
fd	pointer
=	O
c2f	function
(	O
cookie	pointer
)	O
;	O
if	O
(	O
fd	pointer
)	O
{	O
fd	pointer
->	O
nrefs	int
++	O
;	O
DBGREFS	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"--> fd  %p ++ %d %s at %s:%u %s\n"	pointer
,	O
fd	pointer
,	O
fd	pointer
->	O
nrefs	int
,	O
msg	pointer
,	O
file	pointer
,	O
line	int
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
}	O
return	O
fd	pointer
;	O
}	O
static	O
inline	O
FD_t	pointer
XfdFree	function
(	O
FD_t	pointer
fd	pointer
,	O
const	O
char	O
*	O
msg	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
unsigned	O
line	int
)	O
{	O
if	O
(	O
fd	pointer
==	O
NULL	O
)	O
DBGREFS	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
"--> fd  %p -- %d %s at %s:%u\n"	pointer
,	O
fd	pointer
,	O
FDNREFS	O
(	O
fd	pointer
)	O
,	O
msg	pointer
,	O
file	pointer
,	O
line	int
)	O
)	O
;	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
if	O
(	O
fd	pointer
)	O
{	O
DBGREFS	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"--> fd  %p -- %d %s at %s:%u %s\n"	pointer
,	O
fd	pointer
,	O
fd	pointer
->	O
nrefs	int
,	O
msg	pointer
,	O
file	pointer
,	O
line	int
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
if	O
(	O
--	O
fd	pointer
->	O
nrefs	int
>	O
0	int
)	O
return	O
fd	pointer
;	O
if	O
(	O
fd	pointer
->	O
stats	pointer
)	O
free	function
(	O
fd	pointer
->	O
stats	pointer
)	O
;	O
free	function
(	O
fd	pointer
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
inline	O
FD_t	pointer
XfdNew	function
(	O
const	O
char	O
*	O
msg	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
unsigned	O
line	int
)	O
{	O
FD_t	pointer
fd	pointer
=	O
(	O
FD_t	pointer
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
_FD_s	struct
)	O
)	O
;	O
if	O
(	O
fd	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
fd	pointer
->	O
nrefs	int
=	O
0	int
;	O
fd	pointer
->	O
flags	int
=	O
0	int
;	O
fd	pointer
->	O
magic	array
=	O
FDMAGIC	int
;	O
fd	pointer
->	O
urlType	int
=	O
URL_IS_UNKNOWN	int
;	O
fd	pointer
->	O
nfps	int
=	O
0	int
;	O
memset	function
(	O
fd	pointer
->	O
fps	array
,	O
0	int
,	O
sizeof	O
(	O
fd	pointer
->	O
fps	array
)	O
)	O
;	O
fd	pointer
->	O
fps	array
[	O
0	int
]	O
.	O
io	pointer
=	O
fdio	pointer
;	O
fd	pointer
->	O
fps	array
[	O
0	int
]	O
.	O
fp	pointer
=	O
NULL	O
;	O
fd	pointer
->	O
fps	array
[	O
0	int
]	O
.	O
fdno	int
=	O
-	O
1	int
;	O
fd	pointer
->	O
url	pointer
=	O
NULL	O
;	O
fd	pointer
->	O
rd_timeoutsecs	int
=	O
1	int
;	O
fd	pointer
->	O
contentLength	long
=	O
fd	pointer
->	O
bytesRemain	long
=	O
-	O
1	int
;	O
fd	pointer
->	O
wr_chunked	int
=	O
0	int
;	O
fd	pointer
->	O
syserrno	int
=	O
0	int
;	O
fd	pointer
->	O
errcookie	pointer
=	O
NULL	O
;	O
fd	pointer
->	O
stats	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
FDSTAT_t	struct
)	O
)	O
;	O
gettimeofday	function
(	O
&	O
fd	pointer
->	O
stats	pointer
->	O
create	struct
,	O
NULL	O
)	O
;	O
fd	pointer
->	O
stats	pointer
->	O
begin	struct
=	O
fd	pointer
->	O
stats	pointer
->	O
create	struct
;	O
fd	pointer
->	O
ftpFileDoneNeeded	int
=	O
0	int
;	O
fd	pointer
->	O
firstFree	int
=	O
0	int
;	O
fd	pointer
->	O
fileSize	long
=	O
0	int
;	O
fd	pointer
->	O
fd_cpioPos	long
=	O
0	int
;	O
return	O
XfdLink	function
(	O
fd	pointer
,	O
msg	pointer
,	O
file	pointer
,	O
line	int
)	O
;	O
}	O
int	O
fdFileno	function
(	O
void	O
*	O
cookie	pointer
)	O
{	O
FD_t	pointer
fd	pointer
;	O
if	O
(	O
cookie	pointer
==	O
NULL	O
)	O
return	O
-	O
2	int
;	O
fd	pointer
=	O
c2f	function
(	O
cookie	pointer
)	O
;	O
return	O
fd	pointer
->	O
fps	array
[	O
0	int
]	O
.	O
fdno	int
;	O
}	O
ssize_t	long
fdRead	function
(	O
void	O
*	O
cookie	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
count	long
)	O
{	O
FD_t	pointer
fd	pointer
=	O
c2f	function
(	O
cookie	pointer
)	O
;	O
ssize_t	long
rc	long
;	O
if	O
(	O
fd	pointer
->	O
bytesRemain	long
==	O
0	int
)	O
return	O
0	int
;	O
fdstat_enter	function
(	O
fd	pointer
,	O
FDSTAT_READ	int
)	O
;	O
rc	long
=	O
read	pointer
(	O
fdFileno	function
(	O
fd	pointer
)	O
,	O
buf	pointer
,	O
(	O
count	long
>	O
fd	pointer
->	O
bytesRemain	long
?	O
fd	pointer
->	O
bytesRemain	long
:	O
count	long
)	O
)	O
;	O
fdstat_exit	function
(	O
fd	pointer
,	O
FDSTAT_READ	int
,	O
rc	long
)	O
;	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==>\tfdRead(%p,%p,%ld) rc %ld %s\n"	pointer
,	O
cookie	pointer
,	O
buf	pointer
,	O
(	O
long	O
)	O
count	long
,	O
(	O
long	O
)	O
rc	long
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
return	O
rc	long
;	O
}	O
ssize_t	long
fdWrite	function
(	O
void	O
*	O
cookie	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
size_t	long
count	long
)	O
{	O
FD_t	pointer
fd	pointer
=	O
c2f	function
(	O
cookie	pointer
)	O
;	O
int	O
fdno	int
=	O
fdFileno	function
(	O
fd	pointer
)	O
;	O
ssize_t	long
rc	long
;	O
if	O
(	O
fd	pointer
->	O
bytesRemain	long
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
fd	pointer
->	O
wr_chunked	int
)	O
{	O
char	O
chunksize	array
[	O
20	int
]	O
;	O
sprintf	function
(	O
chunksize	array
,	O
"%x\r\n"	pointer
,	O
count	long
)	O
;	O
rc	long
=	O
write	pointer
(	O
fdno	int
,	O
chunksize	array
,	O
strlen	function
(	O
chunksize	array
)	O
)	O
;	O
if	O
(	O
rc	long
==	O
-	O
1	int
)	O
fd	pointer
->	O
syserrno	int
=	O
errno	O
;	O
}	O
if	O
(	O
count	long
==	O
0	int
)	O
return	O
0	int
;	O
fdstat_enter	function
(	O
fd	pointer
,	O
FDSTAT_WRITE	int
)	O
;	O
rc	long
=	O
write	pointer
(	O
fdno	int
,	O
buf	pointer
,	O
(	O
count	long
>	O
fd	pointer
->	O
bytesRemain	long
?	O
fd	pointer
->	O
bytesRemain	long
:	O
count	long
)	O
)	O
;	O
fdstat_exit	function
(	O
fd	pointer
,	O
FDSTAT_WRITE	int
,	O
rc	long
)	O
;	O
if	O
(	O
fd	pointer
->	O
wr_chunked	int
)	O
{	O
int	O
ec	int
;	O
ec	int
=	O
write	pointer
(	O
fdno	int
,	O
"\r\n"	pointer
,	O
sizeof	O
(	O
"\r\n"	pointer
)	O
-	O
1	int
)	O
;	O
if	O
(	O
ec	int
==	O
-	O
1	int
)	O
fd	pointer
->	O
syserrno	int
=	O
errno	O
;	O
}	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==>\tfdWrite(%p,%p,%ld) rc %ld %s\n"	pointer
,	O
cookie	pointer
,	O
buf	pointer
,	O
(	O
long	O
)	O
count	long
,	O
(	O
long	O
)	O
rc	long
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
return	O
rc	long
;	O
}	O
static	O
inline	O
int	O
fdSeek	function
(	O
void	O
*	O
cookie	pointer
,	O
off_t	long
pos	long
,	O
int	O
whence	int
)	O
{	O
FD_t	pointer
fd	pointer
=	O
c2f	function
(	O
cookie	pointer
)	O
;	O
off_t	long
rc	long
;	O
assert	O
(	O
fd	pointer
->	O
bytesRemain	long
==	O
-	O
1	int
)	O
;	O
fdstat_enter	function
(	O
fd	pointer
,	O
FDSTAT_SEEK	int
)	O
;	O
rc	long
=	O
lseek	function
(	O
fdFileno	function
(	O
fd	pointer
)	O
,	O
pos	long
,	O
whence	int
)	O
;	O
fdstat_exit	function
(	O
fd	pointer
,	O
FDSTAT_SEEK	int
,	O
rc	long
)	O
;	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==>\tfdSeek(%p,%ld,%d) rc %lx %s\n"	pointer
,	O
cookie	pointer
,	O
pos	long
,	O
whence	int
,	O
(	O
long	O
)	O
rc	long
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
return	O
rc	long
;	O
}	O
int	O
fdClose	function
(	O
void	O
*	O
cookie	pointer
)	O
{	O
FD_t	pointer
fd	pointer
;	O
int	O
fdno	int
;	O
int	O
rc	long
;	O
if	O
(	O
cookie	pointer
==	O
NULL	O
)	O
return	O
-	O
2	int
;	O
fd	pointer
=	O
c2f	function
(	O
cookie	pointer
)	O
;	O
fdno	int
=	O
fdFileno	function
(	O
fd	pointer
)	O
;	O
fdSetFdno	function
(	O
fd	pointer
,	O
-	O
1	int
)	O
;	O
fdstat_enter	function
(	O
fd	pointer
,	O
FDSTAT_CLOSE	int
)	O
;	O
rc	long
=	O
(	O
(	O
fdno	int
>=	O
0	int
)	O
?	O
close	pointer
(	O
fdno	int
)	O
:	O
-	O
2	int
)	O
;	O
fdstat_exit	function
(	O
fd	pointer
,	O
FDSTAT_CLOSE	int
,	O
rc	long
)	O
;	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==>\tfdClose(%p) rc %lx %s\n"	pointer
,	O
fd	pointer
,	O
(	O
long	O
)	O
rc	long
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
fd	pointer
=	O
fdFree	O
(	O
fd	pointer
,	O
"open (fdClose)"	pointer
)	O
;	O
return	O
rc	long
;	O
}	O
FD_t	pointer
fdOpen	function
(	O
const	O
char	O
*	O
path	pointer
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
)	O
{	O
FD_t	pointer
fd	pointer
;	O
int	O
fdno	int
;	O
fdno	int
=	O
open	function
(	O
path	pointer
,	O
flags	int
,	O
mode	int
)	O
;	O
if	O
(	O
fdno	int
<	O
0	int
)	O
return	O
NULL	O
;	O
fd	pointer
=	O
fdNew	O
(	O
"open (fdOpen)"	pointer
)	O
;	O
fdSetFdno	function
(	O
fd	pointer
,	O
fdno	int
)	O
;	O
fd	pointer
->	O
flags	int
=	O
flags	int
;	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==>\tfdOpen(\"%s\",%x,0%o) %s\n"	pointer
,	O
path	pointer
,	O
flags	int
,	O
(	O
unsigned	O
)	O
mode	int
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
return	O
fd	pointer
;	O
}	O
static	O
struct	O
FDIO_s	struct
fdio_s	struct
=	O
{	O
fdRead	function
,	O
fdWrite	function
,	O
fdSeek	function
,	O
fdClose	function
,	O
XfdLink	function
,	O
XfdFree	function
,	O
XfdNew	function
,	O
fdFileno	function
,	O
fdOpen	function
,	O
NULL	O
,	O
fdGetFp	function
,	O
NULL	O
,	O
mkdir	function
,	O
chdir	function
,	O
rmdir	function
,	O
rename	function
,	O
unlink	function
}	O
;	O
FDIO_t	pointer
fdio	pointer
=	O
&	O
fdio_s	struct
;	O
int	O
fdWritable	function
(	O
FD_t	pointer
fd	pointer
,	O
int	O
secs	int
)	O
{	O
int	O
fdno	int
;	O
fd_set	struct
wrfds	struct
;	O
struct	O
timeval	struct
timeout	struct
,	O
*	O
tvp	pointer
=	O
(	O
secs	int
>=	O
0	int
?	O
&	O
timeout	struct
:	O
NULL	O
)	O
;	O
int	O
rc	long
;	O
if	O
(	O
(	O
fdno	int
=	O
fdFileno	function
(	O
fd	pointer
)	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
FD_ZERO	O
(	O
&	O
wrfds	struct
)	O
;	O
do	O
{	O
FD_SET	O
(	O
fdno	int
,	O
&	O
wrfds	struct
)	O
;	O
if	O
(	O
tvp	pointer
)	O
{	O
tvp	pointer
->	O
tv_sec	long
=	O
secs	int
;	O
tvp	pointer
->	O
tv_usec	long
=	O
0	int
;	O
}	O
errno	O
=	O
0	int
;	O
rc	long
=	O
select	function
(	O
fdno	int
+	O
1	int
,	O
NULL	O
,	O
&	O
wrfds	struct
,	O
NULL	O
,	O
tvp	pointer
)	O
;	O
if	O
(	O
_rpmio_debug	int
&&	O
!	O
(	O
rc	long
==	O
1	int
&&	O
errno	O
==	O
0	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** fdWritable fdno %d rc %d %s\n"	pointer
,	O
fdno	int
,	O
rc	long
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
{	O
switch	O
(	O
errno	O
)	O
{	O
case	O
EINTR	int
:	O
continue	O
;	O
break	O
;	O
default	O
:	O
return	O
rc	long
;	O
break	O
;	O
}	O
}	O
return	O
rc	long
;	O
}	O
while	O
(	O
1	int
)	O
;	O
}	O
int	O
fdReadable	function
(	O
FD_t	pointer
fd	pointer
,	O
int	O
secs	int
)	O
{	O
int	O
fdno	int
;	O
fd_set	struct
rdfds	struct
;	O
struct	O
timeval	struct
timeout	struct
,	O
*	O
tvp	pointer
=	O
(	O
secs	int
>=	O
0	int
?	O
&	O
timeout	struct
:	O
NULL	O
)	O
;	O
int	O
rc	long
;	O
if	O
(	O
(	O
fdno	int
=	O
fdFileno	function
(	O
fd	pointer
)	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
FD_ZERO	O
(	O
&	O
rdfds	struct
)	O
;	O
do	O
{	O
FD_SET	O
(	O
fdno	int
,	O
&	O
rdfds	struct
)	O
;	O
if	O
(	O
tvp	pointer
)	O
{	O
tvp	pointer
->	O
tv_sec	long
=	O
secs	int
;	O
tvp	pointer
->	O
tv_usec	long
=	O
0	int
;	O
}	O
errno	O
=	O
0	int
;	O
rc	long
=	O
select	function
(	O
fdno	int
+	O
1	int
,	O
&	O
rdfds	struct
,	O
NULL	O
,	O
NULL	O
,	O
tvp	pointer
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
{	O
switch	O
(	O
errno	O
)	O
{	O
case	O
EINTR	int
:	O
continue	O
;	O
break	O
;	O
default	O
:	O
return	O
rc	long
;	O
break	O
;	O
}	O
}	O
return	O
rc	long
;	O
}	O
while	O
(	O
1	int
)	O
;	O
}	O
static	O
int	O
fdFgets	function
(	O
FD_t	pointer
fd	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	long
)	O
{	O
int	O
fdno	int
;	O
int	O
secs	int
=	O
fd	pointer
->	O
rd_timeoutsecs	int
;	O
size_t	long
nb	long
=	O
0	int
;	O
int	O
ec	int
=	O
0	int
;	O
char	O
lastchar	char
=	O
'\0'	O
;	O
if	O
(	O
(	O
fdno	int
=	O
fdFileno	function
(	O
fd	pointer
)	O
)	O
<	O
0	int
)	O
return	O
0	int
;	O
do	O
{	O
int	O
rc	long
;	O
rc	long
=	O
fdReadable	function
(	O
fd	pointer
,	O
secs	int
)	O
;	O
switch	O
(	O
rc	long
)	O
{	O
case	O
-	O
1	int
:	O
ec	int
=	O
-	O
1	int
;	O
continue	O
;	O
break	O
;	O
case	O
0	int
:	O
ec	int
=	O
-	O
1	int
;	O
continue	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
errno	O
=	O
0	int
;	O
rc	long
=	O
read	pointer
(	O
fdFileno	function
(	O
fd	pointer
)	O
,	O
buf	pointer
+	O
nb	long
,	O
1	int
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
{	O
fd	pointer
->	O
syserrno	int
=	O
errno	O
;	O
switch	O
(	O
errno	O
)	O
{	O
case	O
EWOULDBLOCK	O
:	O
continue	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** read: fd %p rc %d errno %d %s \"%s\"\n"	pointer
,	O
fd	pointer
,	O
rc	long
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
,	O
buf	pointer
)	O
;	O
ec	int
=	O
-	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
rc	long
==	O
0	int
)	O
{	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** read: fd %p rc %d EOF errno %d %s \"%s\"\n"	pointer
,	O
fd	pointer
,	O
rc	long
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
,	O
buf	pointer
)	O
;	O
break	O
;	O
}	O
else	O
{	O
nb	long
+=	O
rc	long
;	O
buf	pointer
[	O
nb	long
]	O
=	O
'\0'	O
;	O
lastchar	char
=	O
buf	pointer
[	O
nb	long
-	O
1	int
]	O
;	O
}	O
}	O
while	O
(	O
ec	int
==	O
0	int
&&	O
nb	long
<	O
len	long
&&	O
lastchar	char
!=	O
'\n'	O
)	O
;	O
return	O
(	O
ec	int
>=	O
0	int
?	O
nb	long
:	O
ec	int
)	O
;	O
}	O
const	O
char	O
*	O
const	O
ftpStrerror	function
(	O
int	O
errorNumber	int
)	O
{	O
switch	O
(	O
errorNumber	int
)	O
{	O
case	O
0	int
:	O
return	O
_	O
(	O
"Success"	pointer
)	O
;	O
case	O
FTPERR_BAD_SERVER_RESPONSE	O
:	O
return	O
_	O
(	O
"Bad server response"	pointer
)	O
;	O
case	O
FTPERR_SERVER_IO_ERROR	O
:	O
return	O
_	O
(	O
"Server IO error"	pointer
)	O
;	O
case	O
FTPERR_SERVER_TIMEOUT	O
:	O
return	O
_	O
(	O
"Server timeout"	pointer
)	O
;	O
case	O
FTPERR_BAD_HOST_ADDR	O
:	O
return	O
_	O
(	O
"Unable to lookup server host address"	pointer
)	O
;	O
case	O
FTPERR_BAD_HOSTNAME	O
:	O
return	O
_	O
(	O
"Unable to lookup server host name"	pointer
)	O
;	O
case	O
FTPERR_FAILED_CONNECT	O
:	O
return	O
_	O
(	O
"Failed to connect to server"	pointer
)	O
;	O
case	O
FTPERR_FAILED_DATA_CONNECT	O
:	O
return	O
_	O
(	O
"Failed to establish data connection to server"	pointer
)	O
;	O
case	O
FTPERR_FILE_IO_ERROR	O
:	O
return	O
_	O
(	O
"IO error to local file"	pointer
)	O
;	O
case	O
FTPERR_PASSIVE_ERROR	O
:	O
return	O
_	O
(	O
"Error setting remote server to passive mode"	pointer
)	O
;	O
case	O
FTPERR_FILE_NOT_FOUND	O
:	O
return	O
_	O
(	O
"File not found on server"	pointer
)	O
;	O
case	O
FTPERR_NIC_ABORT_IN_PROGRESS	O
:	O
return	O
_	O
(	O
"Abort in progress"	pointer
)	O
;	O
case	O
FTPERR_UNKNOWN	O
:	O
default	O
:	O
return	O
_	O
(	O
"Unknown or unexpected error"	pointer
)	O
;	O
}	O
}	O
const	O
char	O
*	O
urlStrerror	function
(	O
const	O
char	O
*	O
url	pointer
)	O
{	O
const	O
char	O
*	O
retstr	pointer
;	O
switch	O
(	O
urlIsURL	function
(	O
url	pointer
)	O
)	O
{	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_HTTP	int
:	O
{	O
urlinfo	struct
u	union
;	O
if	O
(	O
urlSplit	function
(	O
url	pointer
,	O
&	O
u	union
)	O
==	O
0	int
)	O
{	O
retstr	pointer
=	O
ftpStrerror	function
(	O
u	union
->	O
openError	int
)	O
;	O
}	O
else	O
retstr	pointer
=	O
"Malformed URL"	pointer
;	O
}	O
break	O
;	O
default	O
:	O
retstr	pointer
=	O
strerror	function
(	O
errno	O
)	O
;	O
break	O
;	O
}	O
return	O
retstr	pointer
;	O
}	O
static	O
int	O
mygethostbyname	function
(	O
const	O
char	O
*	O
host	pointer
,	O
struct	O
in_addr	struct
*	O
address	pointer
)	O
{	O
struct	O
hostent	struct
*	O
hostinfo	pointer
;	O
hostinfo	pointer
=	O
gethostbyname	function
(	O
host	pointer
)	O
;	O
if	O
(	O
!	O
hostinfo	pointer
)	O
return	O
1	int
;	O
memcpy	function
(	O
address	pointer
,	O
hostinfo	pointer
->	O
h_addr_list	pointer
[	O
0	int
]	O
,	O
sizeof	O
(	O
*	O
address	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
getHostAddress	function
(	O
const	O
char	O
*	O
host	pointer
,	O
struct	O
in_addr	struct
*	O
address	pointer
)	O
{	O
if	O
(	O
isdigit	function
(	O
host	pointer
[	O
0	int
]	O
)	O
)	O
{	O
if	O
(	O
!	O
inet_aton	function
(	O
host	pointer
,	O
address	pointer
)	O
)	O
{	O
return	O
FTPERR_BAD_HOST_ADDR	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mygethostbyname	function
(	O
host	pointer
,	O
address	pointer
)	O
)	O
{	O
errno	O
=	O
h_errno	O
;	O
return	O
FTPERR_BAD_HOSTNAME	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
tcpConnect	function
(	O
FD_t	pointer
ctrl	pointer
,	O
const	O
char	O
*	O
host	pointer
,	O
int	O
port	int
)	O
{	O
struct	O
sockaddr_in	struct
sin	struct
;	O
int	O
fdno	int
=	O
-	O
1	int
;	O
int	O
rc	long
;	O
sin	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
sin	struct
.	O
sin_port	short
=	O
htons	function
(	O
port	int
)	O
;	O
sin	struct
.	O
sin_addr	struct
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
do	O
{	O
if	O
(	O
(	O
rc	long
=	O
getHostAddress	function
(	O
host	pointer
,	O
&	O
sin	struct
.	O
sin_addr	struct
)	O
)	O
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
fdno	int
=	O
socket	function
(	O
sin	struct
.	O
sin_family	short
,	O
SOCK_STREAM	int
,	O
IPPROTO_IP	int
)	O
)	O
<	O
0	int
)	O
{	O
rc	long
=	O
FTPERR_FAILED_CONNECT	O
;	O
break	O
;	O
}	O
if	O
(	O
connect	function
(	O
fdno	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sin	struct
,	O
sizeof	O
(	O
sin	struct
)	O
)	O
)	O
{	O
rc	long
=	O
FTPERR_FAILED_CONNECT	O
;	O
break	O
;	O
}	O
}	O
while	O
(	O
0	int
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
goto	O
errxit	O
;	O
if	O
(	O
_ftp_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"++ connect %s:%d on fdno %d\n"	pointer
,	O
inet_ntoa	function
(	O
sin	struct
.	O
sin_addr	struct
)	O
,	O
ntohs	function
(	O
sin	struct
.	O
sin_port	short
)	O
,	O
fdno	int
)	O
;	O
fdSetFdno	function
(	O
ctrl	pointer
,	O
(	O
fdno	int
>=	O
0	int
?	O
fdno	int
:	O
-	O
1	int
)	O
)	O
;	O
return	O
0	int
;	O
errxit	O
:	O
fdSetSyserrno	function
(	O
ctrl	pointer
,	O
errno	O
,	O
ftpStrerror	function
(	O
rc	long
)	O
)	O
;	O
if	O
(	O
fdno	int
>=	O
0	int
)	O
close	pointer
(	O
fdno	int
)	O
;	O
return	O
rc	long
;	O
}	O
static	O
int	O
checkResponse	function
(	O
void	O
*	O
uu	pointer
,	O
FD_t	pointer
ctrl	pointer
,	O
int	O
*	O
ecp	pointer
,	O
char	O
*	O
*	O
str	pointer
)	O
{	O
urlinfo	struct
u	union
=	O
uu	pointer
;	O
char	O
*	O
buf	pointer
;	O
size_t	long
bufAlloced	int
;	O
int	O
bufLength	int
=	O
0	int
;	O
const	O
char	O
*	O
s	pointer
;	O
char	O
*	O
se	pointer
;	O
int	O
ec	int
=	O
0	int
;	O
int	O
moretodo	int
=	O
1	int
;	O
char	O
errorCode	array
[	O
4	int
]	O
;	O
URLSANE	O
(	O
u	union
)	O
;	O
if	O
(	O
u	union
->	O
bufAlloced	int
==	O
0	int
||	O
u	union
->	O
buf	pointer
==	O
NULL	O
)	O
{	O
u	union
->	O
bufAlloced	int
=	O
url_iobuf_size	int
;	O
u	union
->	O
buf	pointer
=	O
xcalloc	function
(	O
u	union
->	O
bufAlloced	int
,	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
}	O
buf	pointer
=	O
u	union
->	O
buf	pointer
;	O
bufAlloced	int
=	O
u	union
->	O
bufAlloced	int
;	O
*	O
buf	pointer
=	O
'\0'	O
;	O
errorCode	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
do	O
{	O
int	O
rc	long
;	O
se	pointer
=	O
buf	pointer
+	O
bufLength	int
;	O
*	O
se	pointer
=	O
'\0'	O
;	O
rc	long
=	O
fdFgets	function
(	O
ctrl	pointer
,	O
se	pointer
,	O
(	O
bufAlloced	int
-	O
bufLength	int
)	O
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
{	O
ec	int
=	O
FTPERR_BAD_SERVER_RESPONSE	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
rc	long
==	O
0	int
||	O
fdWritable	function
(	O
ctrl	pointer
,	O
0	int
)	O
<	O
1	int
)	O
moretodo	int
=	O
0	int
;	O
for	O
(	O
s	pointer
=	O
se	pointer
;	O
*	O
s	pointer
!=	O
'\0'	O
;	O
s	pointer
=	O
se	pointer
)	O
{	O
const	O
char	O
*	O
e	pointer
;	O
while	O
(	O
*	O
se	pointer
&&	O
*	O
se	pointer
!=	O
'\n'	O
)	O
se	pointer
++	O
;	O
if	O
(	O
se	pointer
>	O
s	pointer
&&	O
se	pointer
[	O
-	O
1	int
]	O
==	O
'\r'	O
)	O
se	pointer
[	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
se	pointer
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
_ftp_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"<- %s\n"	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'\0'	O
)	O
{	O
moretodo	int
=	O
0	int
;	O
break	O
;	O
}	O
*	O
se	pointer
++	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
"HTTP"	pointer
,	O
sizeof	O
(	O
"HTTP"	pointer
)	O
-	O
1	int
)	O
)	O
{	O
ctrl	pointer
->	O
contentLength	long
=	O
-	O
1	int
;	O
if	O
(	O
(	O
e	pointer
=	O
strchr	function
(	O
s	pointer
,	O
'.'	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
e	pointer
++	O
;	O
u	union
->	O
httpVersion	int
=	O
*	O
e	pointer
-	O
'0'	O
;	O
if	O
(	O
u	union
->	O
httpVersion	int
<	O
1	int
||	O
u	union
->	O
httpVersion	int
>	O
2	int
)	O
ctrl	pointer
->	O
persist	int
=	O
u	union
->	O
httpVersion	int
=	O
0	int
;	O
else	O
ctrl	pointer
->	O
persist	int
=	O
1	int
;	O
}	O
if	O
(	O
(	O
e	pointer
=	O
strchr	function
(	O
s	pointer
,	O
' '	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
e	pointer
++	O
;	O
if	O
(	O
strchr	function
(	O
"0123456789"	pointer
,	O
*	O
e	pointer
)	O
)	O
strncpy	function
(	O
errorCode	array
,	O
e	pointer
,	O
3	int
)	O
;	O
errorCode	array
[	O
3	int
]	O
=	O
'\0'	O
;	O
}	O
continue	O
;	O
}	O
for	O
(	O
e	pointer
=	O
s	pointer
;	O
*	O
e	pointer
&&	O
!	O
(	O
*	O
e	pointer
==	O
' '	O
||	O
*	O
e	pointer
==	O
':'	O
)	O
;	O
e	pointer
++	O
)	O
;	O
if	O
(	O
e	pointer
>	O
s	pointer
&&	O
*	O
e	pointer
++	O
==	O
':'	O
)	O
{	O
size_t	long
ne	long
=	O
(	O
e	pointer
-	O
s	pointer
)	O
;	O
while	O
(	O
*	O
e	pointer
&&	O
*	O
e	pointer
==	O
' '	O
)	O
e	pointer
++	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
"Accept-Ranges:"	pointer
,	O
ne	long
)	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
e	pointer
,	O
"bytes"	pointer
)	O
)	O
u	union
->	O
httpHasRange	int
=	O
1	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
e	pointer
,	O
"none"	pointer
)	O
)	O
u	union
->	O
httpHasRange	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
"Content-Length:"	pointer
,	O
ne	long
)	O
)	O
{	O
if	O
(	O
strchr	function
(	O
"0123456789"	pointer
,	O
*	O
e	pointer
)	O
)	O
ctrl	pointer
->	O
contentLength	long
=	O
atoi	function
(	O
e	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
"Connection:"	pointer
,	O
ne	long
)	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
e	pointer
,	O
"close"	pointer
)	O
)	O
ctrl	pointer
->	O
persist	int
=	O
0	int
;	O
}	O
else	O
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
"<TITLE>"	pointer
,	O
sizeof	O
(	O
"<TITLE>"	pointer
)	O
-	O
1	int
)	O
)	O
s	pointer
+=	O
sizeof	O
(	O
"<TITLE>"	pointer
)	O
-	O
1	int
;	O
if	O
(	O
strchr	function
(	O
"0123456789"	pointer
,	O
*	O
s	pointer
)	O
)	O
{	O
if	O
(	O
errorCode	array
[	O
0	int
]	O
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
errorCode	array
,	O
sizeof	O
(	O
"123"	pointer
)	O
-	O
1	int
)	O
&&	O
s	pointer
[	O
3	int
]	O
==	O
' '	O
)	O
moretodo	int
=	O
0	int
;	O
}	O
else	O
{	O
strncpy	function
(	O
errorCode	array
,	O
s	pointer
,	O
sizeof	O
(	O
"123"	pointer
)	O
-	O
1	int
)	O
;	O
errorCode	array
[	O
3	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
s	pointer
[	O
3	int
]	O
!=	O
'-'	O
)	O
moretodo	int
=	O
0	int
;	O
}	O
}	O
}	O
if	O
(	O
moretodo	int
&&	O
se	pointer
>	O
s	pointer
)	O
{	O
bufLength	int
=	O
se	pointer
-	O
s	pointer
-	O
1	int
;	O
if	O
(	O
s	pointer
!=	O
buf	pointer
)	O
memmove	function
(	O
buf	pointer
,	O
s	pointer
,	O
bufLength	int
)	O
;	O
}	O
else	O
{	O
bufLength	int
=	O
0	int
;	O
}	O
}	O
while	O
(	O
moretodo	int
&&	O
ec	int
==	O
0	int
)	O
;	O
if	O
(	O
str	pointer
)	O
*	O
str	pointer
=	O
buf	pointer
;	O
if	O
(	O
ecp	pointer
)	O
*	O
ecp	pointer
=	O
atoi	function
(	O
errorCode	array
)	O
;	O
return	O
ec	int
;	O
}	O
static	O
int	O
ftpCheckResponse	function
(	O
urlinfo	struct
u	union
,	O
char	O
*	O
*	O
str	pointer
)	O
{	O
int	O
ec	int
=	O
0	int
;	O
int	O
rc	long
;	O
URLSANE	O
(	O
u	union
)	O
;	O
rc	long
=	O
checkResponse	function
(	O
u	union
,	O
u	union
->	O
ctrl	pointer
,	O
&	O
ec	int
,	O
str	pointer
)	O
;	O
switch	O
(	O
ec	int
)	O
{	O
case	O
550	int
:	O
return	O
FTPERR_FILE_NOT_FOUND	O
;	O
break	O
;	O
case	O
552	int
:	O
return	O
FTPERR_NIC_ABORT_IN_PROGRESS	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
ec	int
>=	O
400	int
&&	O
ec	int
<=	O
599	int
)	O
{	O
return	O
FTPERR_BAD_SERVER_RESPONSE	O
;	O
}	O
break	O
;	O
}	O
return	O
rc	long
;	O
}	O
static	O
int	O
ftpCommand	function
(	O
urlinfo	struct
u	union
,	O
char	O
*	O
*	O
str	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
len	long
=	O
0	int
;	O
const	O
char	O
*	O
s	pointer
,	O
*	O
t	pointer
;	O
char	O
*	O
te	pointer
;	O
int	O
rc	long
;	O
URLSANE	O
(	O
u	union
)	O
;	O
va_start	O
(	O
ap	array
,	O
str	pointer
)	O
;	O
while	O
(	O
(	O
s	pointer
=	O
va_arg	O
(	O
ap	array
,	O
const	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
len	long
)	O
len	long
++	O
;	O
len	long
+=	O
strlen	function
(	O
s	pointer
)	O
;	O
}	O
len	long
+=	O
sizeof	O
(	O
"\r\n"	pointer
)	O
-	O
1	int
;	O
va_end	O
(	O
ap	array
)	O
;	O
t	pointer
=	O
te	pointer
=	O
alloca	function
(	O
len	long
+	O
1	int
)	O
;	O
va_start	O
(	O
ap	array
,	O
str	pointer
)	O
;	O
while	O
(	O
(	O
s	pointer
=	O
va_arg	O
(	O
ap	array
,	O
const	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
te	pointer
>	O
t	pointer
)	O
*	O
te	pointer
++	O
=	O
' '	O
;	O
te	pointer
=	O
rpm_stpcpy	function
(	O
te	pointer
,	O
s	pointer
)	O
;	O
}	O
te	pointer
=	O
rpm_stpcpy	function
(	O
te	pointer
,	O
"\r\n"	pointer
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
if	O
(	O
_ftp_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"-> %s"	pointer
,	O
t	pointer
)	O
;	O
if	O
(	O
fdWrite	function
(	O
u	union
->	O
ctrl	pointer
,	O
t	pointer
,	O
(	O
te	pointer
-	O
t	pointer
)	O
)	O
!=	O
(	O
te	pointer
-	O
t	pointer
)	O
)	O
return	O
FTPERR_SERVER_IO_ERROR	O
;	O
rc	long
=	O
ftpCheckResponse	function
(	O
u	union
,	O
str	pointer
)	O
;	O
return	O
rc	long
;	O
}	O
static	O
int	O
ftpLogin	function
(	O
urlinfo	struct
u	union
)	O
{	O
const	O
char	O
*	O
host	pointer
;	O
const	O
char	O
*	O
user	pointer
;	O
const	O
char	O
*	O
password	pointer
;	O
int	O
port	int
;	O
int	O
rc	long
;	O
URLSANE	O
(	O
u	union
)	O
;	O
u	union
->	O
ctrl	pointer
=	O
fdLink	O
(	O
u	union
->	O
ctrl	pointer
,	O
"open ctrl"	pointer
)	O
;	O
if	O
(	O
(	O
(	O
host	pointer
=	O
(	O
u	union
->	O
proxyh	pointer
?	O
u	union
->	O
proxyh	pointer
:	O
u	union
->	O
host	pointer
)	O
)	O
==	O
NULL	O
)	O
)	O
{	O
rc	long
=	O
FTPERR_BAD_HOSTNAME	O
;	O
goto	O
errxit	O
;	O
}	O
if	O
(	O
(	O
port	int
=	O
(	O
u	union
->	O
proxyp	int
>	O
0	int
?	O
u	union
->	O
proxyp	int
:	O
u	union
->	O
port	int
)	O
)	O
<	O
0	int
)	O
port	int
=	O
IPPORT_FTP	int
;	O
if	O
(	O
(	O
user	pointer
=	O
(	O
u	union
->	O
proxyu	pointer
?	O
u	union
->	O
proxyu	pointer
:	O
u	union
->	O
user	pointer
)	O
)	O
==	O
NULL	O
)	O
user	pointer
=	O
"anonymous"	pointer
;	O
if	O
(	O
(	O
password	pointer
=	O
u	union
->	O
password	pointer
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
getuid	function
(	O
)	O
)	O
{	O
struct	O
passwd	struct
*	O
pw	pointer
=	O
getpwuid	function
(	O
getuid	function
(	O
)	O
)	O
;	O
char	O
*	O
myp	pointer
=	O
alloca	function
(	O
strlen	function
(	O
pw	pointer
->	O
pw_name	pointer
)	O
+	O
sizeof	O
(	O
"@"	pointer
)	O
)	O
;	O
strcpy	function
(	O
myp	pointer
,	O
pw	pointer
->	O
pw_name	pointer
)	O
;	O
strcat	function
(	O
myp	pointer
,	O
"@"	pointer
)	O
;	O
password	pointer
=	O
myp	pointer
;	O
}	O
else	O
{	O
password	pointer
=	O
"root@"	pointer
;	O
}	O
}	O
if	O
(	O
fdFileno	function
(	O
u	union
->	O
ctrl	pointer
)	O
>=	O
0	int
&&	O
fdWritable	function
(	O
u	union
->	O
ctrl	pointer
,	O
0	int
)	O
<	O
1	int
)	O
fdClose	function
(	O
u	union
->	O
ctrl	pointer
)	O
;	O
if	O
(	O
fdFileno	function
(	O
u	union
->	O
ctrl	pointer
)	O
<	O
0	int
)	O
{	O
rc	long
=	O
tcpConnect	function
(	O
u	union
->	O
ctrl	pointer
,	O
host	pointer
,	O
port	int
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
goto	O
errxit2	O
;	O
}	O
if	O
(	O
(	O
rc	long
=	O
ftpCheckResponse	function
(	O
u	union
,	O
NULL	O
)	O
)	O
)	O
goto	O
errxit	O
;	O
if	O
(	O
(	O
rc	long
=	O
ftpCommand	function
(	O
u	union
,	O
NULL	O
,	O
"USER"	pointer
,	O
user	pointer
,	O
NULL	O
)	O
)	O
)	O
goto	O
errxit	O
;	O
if	O
(	O
(	O
rc	long
=	O
ftpCommand	function
(	O
u	union
,	O
NULL	O
,	O
"PASS"	pointer
,	O
password	pointer
,	O
NULL	O
)	O
)	O
)	O
goto	O
errxit	O
;	O
if	O
(	O
(	O
rc	long
=	O
ftpCommand	function
(	O
u	union
,	O
NULL	O
,	O
"TYPE"	pointer
,	O
"I"	pointer
,	O
NULL	O
)	O
)	O
)	O
goto	O
errxit	O
;	O
return	O
0	int
;	O
errxit	O
:	O
fdSetSyserrno	function
(	O
u	union
->	O
ctrl	pointer
,	O
errno	O
,	O
ftpStrerror	function
(	O
rc	long
)	O
)	O
;	O
errxit2	O
:	O
if	O
(	O
fdFileno	function
(	O
u	union
->	O
ctrl	pointer
)	O
>=	O
0	int
)	O
fdClose	function
(	O
u	union
->	O
ctrl	pointer
)	O
;	O
return	O
rc	long
;	O
}	O
static	O
int	O
ftpReq	function
(	O
FD_t	pointer
data	pointer
,	O
const	O
char	O
*	O
ftpCmd	pointer
,	O
const	O
char	O
*	O
ftpArg	pointer
)	O
{	O
urlinfo	struct
u	union
=	O
data	pointer
->	O
url	pointer
;	O
struct	O
sockaddr_in	struct
dataAddress	struct
;	O
char	O
*	O
cmd	pointer
;	O
int	O
cmdlen	int
;	O
char	O
*	O
passReply	pointer
;	O
char	O
*	O
chptr	pointer
;	O
int	O
rc	long
;	O
URLSANE	O
(	O
u	union
)	O
;	O
if	O
(	O
ftpCmd	pointer
==	O
NULL	O
)	O
return	O
FTPERR_UNKNOWN	O
;	O
cmdlen	int
=	O
strlen	function
(	O
ftpCmd	pointer
)	O
+	O
(	O
ftpArg	pointer
?	O
1	int
+	O
strlen	function
(	O
ftpArg	pointer
)	O
:	O
0	int
)	O
+	O
sizeof	O
(	O
"\r\n"	pointer
)	O
;	O
chptr	pointer
=	O
cmd	pointer
=	O
alloca	function
(	O
cmdlen	int
)	O
;	O
chptr	pointer
=	O
rpm_stpcpy	function
(	O
chptr	pointer
,	O
ftpCmd	pointer
)	O
;	O
if	O
(	O
ftpArg	pointer
)	O
{	O
*	O
chptr	pointer
++	O
=	O
' '	O
;	O
chptr	pointer
=	O
rpm_stpcpy	function
(	O
chptr	pointer
,	O
ftpArg	pointer
)	O
;	O
}	O
chptr	pointer
=	O
rpm_stpcpy	function
(	O
chptr	pointer
,	O
"\r\n"	pointer
)	O
;	O
cmdlen	int
=	O
chptr	pointer
-	O
cmd	pointer
;	O
if	O
(	O
!	O
strncmp	function
(	O
cmd	pointer
,	O
"RETR"	pointer
,	O
4	int
)	O
)	O
{	O
unsigned	O
cl	int
;	O
passReply	pointer
=	O
NULL	O
;	O
rc	long
=	O
ftpCommand	function
(	O
u	union
,	O
&	O
passReply	pointer
,	O
"SIZE"	pointer
,	O
ftpArg	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	long
)	O
goto	O
errxit	O
;	O
if	O
(	O
sscanf	function
(	O
passReply	pointer
,	O
"%d %u"	pointer
,	O
&	O
rc	long
,	O
&	O
cl	int
)	O
!=	O
2	int
)	O
{	O
rc	long
=	O
FTPERR_BAD_SERVER_RESPONSE	O
;	O
goto	O
errxit	O
;	O
}	O
rc	long
=	O
0	int
;	O
data	pointer
->	O
contentLength	long
=	O
cl	int
;	O
}	O
passReply	pointer
=	O
NULL	O
;	O
rc	long
=	O
ftpCommand	function
(	O
u	union
,	O
&	O
passReply	pointer
,	O
"PASV"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	long
)	O
{	O
rc	long
=	O
FTPERR_PASSIVE_ERROR	O
;	O
goto	O
errxit	O
;	O
}	O
chptr	pointer
=	O
passReply	pointer
;	O
while	O
(	O
*	O
chptr	pointer
&&	O
*	O
chptr	pointer
!=	O
'('	O
)	O
chptr	pointer
++	O
;	O
if	O
(	O
*	O
chptr	pointer
!=	O
'('	O
)	O
return	O
FTPERR_PASSIVE_ERROR	O
;	O
chptr	pointer
++	O
;	O
passReply	pointer
=	O
chptr	pointer
;	O
while	O
(	O
*	O
chptr	pointer
&&	O
*	O
chptr	pointer
!=	O
')'	O
)	O
chptr	pointer
++	O
;	O
if	O
(	O
*	O
chptr	pointer
!=	O
')'	O
)	O
return	O
FTPERR_PASSIVE_ERROR	O
;	O
*	O
chptr	pointer
--	O
=	O
'\0'	O
;	O
while	O
(	O
*	O
chptr	pointer
&&	O
*	O
chptr	pointer
!=	O
','	O
)	O
chptr	pointer
--	O
;	O
if	O
(	O
*	O
chptr	pointer
!=	O
','	O
)	O
return	O
FTPERR_PASSIVE_ERROR	O
;	O
chptr	pointer
--	O
;	O
while	O
(	O
*	O
chptr	pointer
&&	O
*	O
chptr	pointer
!=	O
','	O
)	O
chptr	pointer
--	O
;	O
if	O
(	O
*	O
chptr	pointer
!=	O
','	O
)	O
return	O
FTPERR_PASSIVE_ERROR	O
;	O
*	O
chptr	pointer
++	O
=	O
'\0'	O
;	O
{	O
int	O
i	int
,	O
j	int
;	O
dataAddress	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
if	O
(	O
sscanf	function
(	O
chptr	pointer
,	O
"%d,%d"	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
!=	O
2	int
)	O
{	O
rc	long
=	O
FTPERR_PASSIVE_ERROR	O
;	O
goto	O
errxit	O
;	O
}	O
dataAddress	struct
.	O
sin_port	short
=	O
htons	function
(	O
(	O
(	O
(	O
unsigned	O
)	O
i	int
)	O
<<	O
8	int
)	O
+	O
j	int
)	O
;	O
}	O
chptr	pointer
=	O
passReply	pointer
;	O
while	O
(	O
*	O
chptr	pointer
++	O
)	O
{	O
if	O
(	O
*	O
chptr	pointer
==	O
','	O
)	O
*	O
chptr	pointer
=	O
'.'	O
;	O
}	O
if	O
(	O
!	O
inet_aton	function
(	O
passReply	pointer
,	O
&	O
dataAddress	struct
.	O
sin_addr	struct
)	O
)	O
{	O
rc	long
=	O
FTPERR_PASSIVE_ERROR	O
;	O
goto	O
errxit	O
;	O
}	O
rc	long
=	O
socket	function
(	O
AF_INET	O
,	O
SOCK_STREAM	int
,	O
IPPROTO_IP	int
)	O
;	O
fdSetFdno	function
(	O
data	pointer
,	O
(	O
rc	long
>=	O
0	int
?	O
rc	long
:	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
{	O
rc	long
=	O
FTPERR_FAILED_CONNECT	O
;	O
goto	O
errxit	O
;	O
}	O
data	pointer
=	O
fdLink	O
(	O
data	pointer
,	O
"open data (ftpReq)"	pointer
)	O
;	O
while	O
(	O
connect	function
(	O
fdFileno	function
(	O
data	pointer
)	O
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
dataAddress	struct
,	O
sizeof	O
(	O
dataAddress	struct
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
continue	O
;	O
rc	long
=	O
FTPERR_FAILED_DATA_CONNECT	O
;	O
goto	O
errxit	O
;	O
}	O
if	O
(	O
_ftp_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"-> %s"	pointer
,	O
cmd	pointer
)	O
;	O
if	O
(	O
fdWrite	function
(	O
u	union
->	O
ctrl	pointer
,	O
cmd	pointer
,	O
cmdlen	int
)	O
!=	O
cmdlen	int
)	O
{	O
rc	long
=	O
FTPERR_SERVER_IO_ERROR	O
;	O
goto	O
errxit	O
;	O
}	O
if	O
(	O
(	O
rc	long
=	O
ftpCheckResponse	function
(	O
u	union
,	O
NULL	O
)	O
)	O
)	O
{	O
goto	O
errxit	O
;	O
}	O
data	pointer
->	O
ftpFileDoneNeeded	int
=	O
1	int
;	O
u	union
->	O
ctrl	pointer
=	O
fdLink	O
(	O
u	union
->	O
ctrl	pointer
,	O
"grab data (ftpReq)"	pointer
)	O
;	O
u	union
->	O
ctrl	pointer
=	O
fdLink	O
(	O
u	union
->	O
ctrl	pointer
,	O
"open data (ftpReq)"	pointer
)	O
;	O
return	O
0	int
;	O
errxit	O
:	O
fdSetSyserrno	function
(	O
u	union
->	O
ctrl	pointer
,	O
errno	O
,	O
ftpStrerror	function
(	O
rc	long
)	O
)	O
;	O
if	O
(	O
fdFileno	function
(	O
data	pointer
)	O
>=	O
0	int
)	O
fdClose	function
(	O
data	pointer
)	O
;	O
return	O
rc	long
;	O
}	O
static	O
int	O
urlConnect	function
(	O
const	O
char	O
*	O
url	pointer
,	O
urlinfo	struct
*	O
uret	pointer
)	O
{	O
urlinfo	struct
u	union
;	O
int	O
rc	long
=	O
0	int
;	O
if	O
(	O
urlSplit	function
(	O
url	pointer
,	O
&	O
u	union
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
u	union
->	O
urltype	enum
==	O
URL_IS_FTP	int
)	O
{	O
FD_t	pointer
fd	pointer
;	O
if	O
(	O
(	O
fd	pointer
=	O
u	union
->	O
ctrl	pointer
)	O
==	O
NULL	O
)	O
{	O
fd	pointer
=	O
u	union
->	O
ctrl	pointer
=	O
fdNew	O
(	O
"persist ctrl (urlConnect FTP)"	pointer
)	O
;	O
fdSetIo	function
(	O
u	union
->	O
ctrl	pointer
,	O
ufdio	pointer
)	O
;	O
}	O
fd	pointer
->	O
rd_timeoutsecs	int
=	O
ftpTimeoutSecs	int
;	O
fd	pointer
->	O
contentLength	long
=	O
fd	pointer
->	O
bytesRemain	long
=	O
-	O
1	int
;	O
fd	pointer
->	O
url	pointer
=	O
NULL	O
;	O
fd	pointer
->	O
ftpFileDoneNeeded	int
=	O
0	int
;	O
fd	pointer
=	O
fdLink	O
(	O
fd	pointer
,	O
"grab ctrl (urlConnect FTP)"	pointer
)	O
;	O
if	O
(	O
fdFileno	function
(	O
u	union
->	O
ctrl	pointer
)	O
<	O
0	int
)	O
{	O
rpmMessage	function
(	O
RPMMESS_DEBUG	int
,	O
_	O
(	O
"logging into %s as %s, pw %s\n"	pointer
)	O
,	O
u	union
->	O
host	pointer
,	O
u	union
->	O
user	pointer
?	O
u	union
->	O
user	pointer
:	O
"ftp"	pointer
,	O
u	union
->	O
password	pointer
?	O
u	union
->	O
password	pointer
:	O
"(username)"	pointer
)	O
;	O
if	O
(	O
(	O
rc	long
=	O
ftpLogin	function
(	O
u	union
)	O
)	O
<	O
0	int
)	O
{	O
u	union
->	O
ctrl	pointer
=	O
fdFree	O
(	O
fd	pointer
,	O
"grab ctrl (urlConnect FTP)"	pointer
)	O
;	O
u	union
->	O
openError	int
=	O
rc	long
;	O
}	O
}	O
}	O
if	O
(	O
uret	pointer
!=	O
NULL	O
)	O
*	O
uret	pointer
=	O
urlLink	function
(	O
u	union
,	O
"urlConnect"	pointer
)	O
;	O
u	union
=	O
urlFree	function
(	O
u	union
,	O
"urlSplit (urlConnect)"	pointer
)	O
;	O
return	O
rc	long
;	O
}	O
static	O
rpmCallbackFunction	pointer
urlNotify	pointer
=	O
NULL	O
;	O
static	O
void	O
*	O
urlNotifyData	pointer
=	O
NULL	O
;	O
static	O
int	O
urlNotifyCount	int
=	O
-	O
1	int
;	O
void	O
urlSetCallback	function
(	O
rpmCallbackFunction	pointer
notify	pointer
,	O
void	O
*	O
notifyData	pointer
,	O
int	O
notifyCount	int
)	O
{	O
urlNotify	pointer
=	O
notify	pointer
;	O
urlNotifyData	pointer
=	O
notifyData	pointer
;	O
urlNotifyCount	int
=	O
(	O
notifyCount	int
>=	O
0	int
)	O
?	O
notifyCount	int
:	O
4096	int
;	O
}	O
int	O
ufdCopy	function
(	O
FD_t	pointer
sfd	pointer
,	O
FD_t	pointer
tfd	pointer
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
int	O
itemsRead	int
;	O
int	O
itemsCopied	int
=	O
0	int
;	O
int	O
rc	long
=	O
0	int
;	O
int	O
notifier	int
=	O
-	O
1	int
;	O
if	O
(	O
urlNotify	pointer
)	O
{	O
(	O
void	O
)	O
(	O
*	O
urlNotify	pointer
)	O
(	O
NULL	O
,	O
RPMCALLBACK_INST_OPEN_FILE	int
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
urlNotifyData	pointer
)	O
;	O
}	O
while	O
(	O
1	int
)	O
{	O
rc	long
=	O
Fread	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
sfd	pointer
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
break	O
;	O
else	O
if	O
(	O
rc	long
==	O
0	int
)	O
{	O
rc	long
=	O
itemsCopied	int
;	O
break	O
;	O
}	O
itemsRead	int
=	O
rc	long
;	O
rc	long
=	O
Fwrite	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
[	O
0	int
]	O
)	O
,	O
itemsRead	int
,	O
tfd	pointer
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
break	O
;	O
if	O
(	O
rc	long
!=	O
itemsRead	int
)	O
{	O
rc	long
=	O
FTPERR_FILE_IO_ERROR	O
;	O
break	O
;	O
}	O
itemsCopied	int
+=	O
itemsRead	int
;	O
if	O
(	O
urlNotify	pointer
&&	O
urlNotifyCount	int
>	O
0	int
)	O
{	O
int	O
n	int
=	O
itemsCopied	int
/	O
urlNotifyCount	int
;	O
if	O
(	O
n	int
!=	O
notifier	int
)	O
{	O
(	O
void	O
)	O
(	O
*	O
urlNotify	pointer
)	O
(	O
NULL	O
,	O
RPMCALLBACK_INST_PROGRESS	int
,	O
itemsCopied	int
,	O
0	int
,	O
NULL	O
,	O
urlNotifyData	pointer
)	O
;	O
notifier	int
=	O
n	int
;	O
}	O
}	O
}	O
DBGIO	O
(	O
sfd	pointer
,	O
(	O
stderr	pointer
,	O
"++ copied %d bytes: %s\n"	pointer
,	O
itemsCopied	int
,	O
ftpStrerror	function
(	O
rc	long
)	O
)	O
)	O
;	O
if	O
(	O
urlNotify	pointer
)	O
{	O
(	O
void	O
)	O
(	O
*	O
urlNotify	pointer
)	O
(	O
NULL	O
,	O
RPMCALLBACK_INST_OPEN_FILE	int
,	O
itemsCopied	int
,	O
itemsCopied	int
,	O
NULL	O
,	O
urlNotifyData	pointer
)	O
;	O
}	O
return	O
rc	long
;	O
}	O
int	O
ufdGetFile	function
(	O
FD_t	pointer
sfd	pointer
,	O
FD_t	pointer
tfd	pointer
)	O
{	O
int	O
rc	long
;	O
FDSANE	O
(	O
sfd	pointer
)	O
;	O
FDSANE	O
(	O
tfd	pointer
)	O
;	O
rc	long
=	O
ufdCopy	function
(	O
sfd	pointer
,	O
tfd	pointer
)	O
;	O
Fclose	function
(	O
sfd	pointer
)	O
;	O
if	O
(	O
rc	long
>	O
0	int
)	O
rc	long
=	O
0	int
;	O
return	O
rc	long
;	O
}	O
static	O
int	O
ftpCmd	pointer
(	O
const	O
char	O
*	O
cmd	pointer
,	O
const	O
char	O
*	O
url	pointer
,	O
const	O
char	O
*	O
arg2	pointer
)	O
{	O
urlinfo	struct
u	union
;	O
int	O
rc	long
;	O
const	O
char	O
*	O
path	pointer
;	O
if	O
(	O
urlConnect	function
(	O
url	pointer
,	O
&	O
u	union
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
(	O
void	O
)	O
urlPath	function
(	O
url	pointer
,	O
&	O
path	pointer
)	O
;	O
rc	long
=	O
ftpCommand	function
(	O
u	union
,	O
NULL	O
,	O
cmd	pointer
,	O
path	pointer
,	O
arg2	pointer
,	O
NULL	O
)	O
;	O
u	union
->	O
ctrl	pointer
=	O
fdFree	O
(	O
u	union
->	O
ctrl	pointer
,	O
"grab ctrl (ftpCmd)"	pointer
)	O
;	O
return	O
rc	long
;	O
}	O
static	O
int	O
ftpMkdir	function
(	O
const	O
char	O
*	O
path	pointer
,	O
mode_t	int
mode	int
)	O
{	O
int	O
rc	long
;	O
if	O
(	O
(	O
rc	long
=	O
ftpCmd	pointer
(	O
"MKD"	pointer
,	O
path	pointer
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
return	O
rc	long
;	O
return	O
rc	long
;	O
}	O
static	O
int	O
ftpChdir	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
return	O
ftpCmd	pointer
(	O
"CWD"	pointer
,	O
path	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
ftpRmdir	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
return	O
ftpCmd	pointer
(	O
"RMD"	pointer
,	O
path	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
ftpRename	function
(	O
const	O
char	O
*	O
oldpath	pointer
,	O
const	O
char	O
*	O
newpath	pointer
)	O
{	O
int	O
rc	long
;	O
if	O
(	O
(	O
rc	long
=	O
ftpCmd	pointer
(	O
"RNFR"	pointer
,	O
oldpath	pointer
,	O
NULL	O
)	O
)	O
!=	O
0	int
)	O
return	O
rc	long
;	O
return	O
ftpCmd	pointer
(	O
"RNTO"	pointer
,	O
newpath	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
ftpUnlink	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
return	O
ftpCmd	pointer
(	O
"DELE"	pointer
,	O
path	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
ftpAbort	function
(	O
urlinfo	struct
u	union
,	O
FD_t	pointer
data	pointer
)	O
{	O
static	O
unsigned	O
char	O
ipbuf	array
[	O
3	int
]	O
=	O
{	O
IAC	int
,	O
IP	int
,	O
IAC	int
}	O
;	O
FD_t	pointer
ctrl	pointer
;	O
int	O
rc	long
;	O
int	O
tosecs	int
;	O
URLSANE	O
(	O
u	union
)	O
;	O
if	O
(	O
data	pointer
!=	O
NULL	O
)	O
{	O
data	pointer
->	O
ftpFileDoneNeeded	int
=	O
0	int
;	O
if	O
(	O
fdFileno	function
(	O
data	pointer
)	O
>=	O
0	int
)	O
u	union
->	O
ctrl	pointer
=	O
fdFree	O
(	O
u	union
->	O
ctrl	pointer
,	O
"open data (ftpAbort)"	pointer
)	O
;	O
u	union
->	O
ctrl	pointer
=	O
fdFree	O
(	O
u	union
->	O
ctrl	pointer
,	O
"grab data (ftpAbort)"	pointer
)	O
;	O
}	O
ctrl	pointer
=	O
u	union
->	O
ctrl	pointer
;	O
DBGIO	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
"-> ABOR\n"	pointer
)	O
)	O
;	O
if	O
(	O
send	function
(	O
fdFileno	function
(	O
ctrl	pointer
)	O
,	O
ipbuf	array
,	O
sizeof	O
(	O
ipbuf	array
)	O
,	O
MSG_OOB	int
)	O
!=	O
sizeof	O
(	O
ipbuf	array
)	O
)	O
{	O
fdClose	function
(	O
ctrl	pointer
)	O
;	O
return	O
FTPERR_SERVER_IO_ERROR	O
;	O
}	O
sprintf	function
(	O
u	union
->	O
buf	pointer
,	O
"%cABOR\r\n"	pointer
,	O
(	O
char	O
)	O
DM	int
)	O
;	O
if	O
(	O
fdWrite	function
(	O
ctrl	pointer
,	O
u	union
->	O
buf	pointer
,	O
7	int
)	O
!=	O
7	int
)	O
{	O
fdClose	function
(	O
ctrl	pointer
)	O
;	O
return	O
FTPERR_SERVER_IO_ERROR	O
;	O
}	O
if	O
(	O
data	pointer
&&	O
fdFileno	function
(	O
data	pointer
)	O
>=	O
0	int
)	O
{	O
tosecs	int
=	O
data	pointer
->	O
rd_timeoutsecs	int
;	O
data	pointer
->	O
rd_timeoutsecs	int
=	O
10	int
;	O
if	O
(	O
fdReadable	function
(	O
data	pointer
,	O
data	pointer
->	O
rd_timeoutsecs	int
)	O
>	O
0	int
)	O
{	O
while	O
(	O
timedRead	function
(	O
data	pointer
,	O
u	union
->	O
buf	pointer
,	O
u	union
->	O
bufAlloced	int
)	O
>	O
0	int
)	O
;	O
}	O
data	pointer
->	O
rd_timeoutsecs	int
=	O
tosecs	int
;	O
shutdown	function
(	O
fdFileno	function
(	O
data	pointer
)	O
,	O
SHUT_RDWR	int
)	O
;	O
close	pointer
(	O
fdFileno	function
(	O
data	pointer
)	O
)	O
;	O
data	pointer
->	O
fps	array
[	O
0	int
]	O
.	O
fdno	int
=	O
-	O
1	int
;	O
}	O
tosecs	int
=	O
u	union
->	O
ctrl	pointer
->	O
rd_timeoutsecs	int
;	O
u	union
->	O
ctrl	pointer
->	O
rd_timeoutsecs	int
=	O
10	int
;	O
if	O
(	O
(	O
rc	long
=	O
ftpCheckResponse	function
(	O
u	union
,	O
NULL	O
)	O
)	O
==	O
FTPERR_NIC_ABORT_IN_PROGRESS	O
)	O
{	O
rc	long
=	O
ftpCheckResponse	function
(	O
u	union
,	O
NULL	O
)	O
;	O
}	O
rc	long
=	O
ftpCheckResponse	function
(	O
u	union
,	O
NULL	O
)	O
;	O
u	union
->	O
ctrl	pointer
->	O
rd_timeoutsecs	int
=	O
tosecs	int
;	O
return	O
rc	long
;	O
}	O
static	O
int	O
ftpFileDone	function
(	O
urlinfo	struct
u	union
,	O
FD_t	pointer
data	pointer
)	O
{	O
int	O
rc	long
=	O
0	int
;	O
URLSANE	O
(	O
u	union
)	O
;	O
assert	O
(	O
data	pointer
->	O
ftpFileDoneNeeded	int
)	O
;	O
if	O
(	O
data	pointer
->	O
ftpFileDoneNeeded	int
)	O
{	O
data	pointer
->	O
ftpFileDoneNeeded	int
=	O
0	int
;	O
u	union
->	O
ctrl	pointer
=	O
fdFree	O
(	O
u	union
->	O
ctrl	pointer
,	O
"open data (ftpFileDone)"	pointer
)	O
;	O
u	union
->	O
ctrl	pointer
=	O
fdFree	O
(	O
u	union
->	O
ctrl	pointer
,	O
"grab data (ftpFileDone)"	pointer
)	O
;	O
rc	long
=	O
ftpCheckResponse	function
(	O
u	union
,	O
NULL	O
)	O
;	O
}	O
return	O
rc	long
;	O
}	O
static	O
int	O
httpResp	function
(	O
urlinfo	struct
u	union
,	O
FD_t	pointer
ctrl	pointer
,	O
char	O
*	O
*	O
str	pointer
)	O
{	O
int	O
ec	int
=	O
0	int
;	O
int	O
rc	long
;	O
URLSANE	O
(	O
u	union
)	O
;	O
rc	long
=	O
checkResponse	function
(	O
u	union
,	O
ctrl	pointer
,	O
&	O
ec	int
,	O
str	pointer
)	O
;	O
if	O
(	O
_ftp_debug	int
&&	O
!	O
(	O
rc	long
==	O
0	int
&&	O
ec	int
==	O
200	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** httpResp: rc %d ec %d\n"	pointer
,	O
rc	long
,	O
ec	int
)	O
;	O
switch	O
(	O
ec	int
)	O
{	O
case	O
200	int
:	O
break	O
;	O
default	O
:	O
rc	long
=	O
FTPERR_FILE_NOT_FOUND	O
;	O
break	O
;	O
}	O
return	O
rc	long
;	O
}	O
static	O
int	O
httpReq	function
(	O
FD_t	pointer
ctrl	pointer
,	O
const	O
char	O
*	O
httpCmd	pointer
,	O
const	O
char	O
*	O
httpArg	pointer
)	O
{	O
urlinfo	struct
u	union
=	O
ctrl	pointer
->	O
url	pointer
;	O
const	O
char	O
*	O
host	pointer
;	O
const	O
char	O
*	O
path	pointer
;	O
int	O
port	int
;	O
int	O
rc	long
;	O
char	O
*	O
req	pointer
;	O
size_t	long
len	long
;	O
int	O
retrying	int
=	O
0	int
;	O
URLSANE	O
(	O
u	union
)	O
;	O
assert	O
(	O
ctrl	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
(	O
(	O
host	pointer
=	O
(	O
u	union
->	O
proxyh	pointer
?	O
u	union
->	O
proxyh	pointer
:	O
u	union
->	O
host	pointer
)	O
)	O
==	O
NULL	O
)	O
)	O
return	O
FTPERR_BAD_HOSTNAME	O
;	O
if	O
(	O
(	O
port	int
=	O
(	O
u	union
->	O
proxyp	int
>	O
0	int
?	O
u	union
->	O
proxyp	int
:	O
u	union
->	O
port	int
)	O
)	O
<	O
0	int
)	O
port	int
=	O
80	int
;	O
path	pointer
=	O
(	O
u	union
->	O
proxyh	pointer
||	O
u	union
->	O
proxyp	int
>	O
0	int
)	O
?	O
u	union
->	O
url	pointer
:	O
httpArg	pointer
;	O
reopen	O
:	O
if	O
(	O
fdFileno	function
(	O
ctrl	pointer
)	O
>=	O
0	int
&&	O
(	O
rc	long
=	O
fdWritable	function
(	O
ctrl	pointer
,	O
0	int
)	O
)	O
<	O
1	int
)	O
{	O
fdClose	function
(	O
ctrl	pointer
)	O
;	O
}	O
if	O
(	O
fdFileno	function
(	O
ctrl	pointer
)	O
<	O
0	int
)	O
{	O
rc	long
=	O
tcpConnect	function
(	O
ctrl	pointer
,	O
host	pointer
,	O
port	int
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
goto	O
errxit2	O
;	O
ctrl	pointer
=	O
fdLink	O
(	O
ctrl	pointer
,	O
"open ctrl (httpReq)"	pointer
)	O
;	O
}	O
len	long
=	O
sizeof	O
(	O
"req x HTTP/1.0\r\nUser-Agent: rpm/3.0.4\r\nHost: y:z\r\nAccept: text/plain\r\nTransfer-Encoding: chunked\r\n\r\n"	pointer
)	O
+	O
strlen	function
(	O
httpCmd	pointer
)	O
+	O
strlen	function
(	O
path	pointer
)	O
+	O
sizeof	O
(	O
VERSION	pointer
)	O
+	O
strlen	function
(	O
host	pointer
)	O
+	O
20	int
;	O
req	pointer
=	O
alloca	function
(	O
len	long
)	O
;	O
*	O
req	pointer
=	O
'\0'	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
httpCmd	pointer
,	O
"PUT"	pointer
)	O
)	O
{	O
sprintf	function
(	O
req	pointer
,	O
"%s %s HTTP/1.%d\r\nUser-Agent: rpm/%s\r\nHost: %s:%d\r\nAccept: text/plain\r\nTransfer-Encoding: chunked\r\n\r\n"	pointer
,	O
httpCmd	pointer
,	O
path	pointer
,	O
(	O
u	union
->	O
httpVersion	int
?	O
1	int
:	O
0	int
)	O
,	O
VERSION	pointer
,	O
host	pointer
,	O
port	int
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
req	pointer
,	O
"%s %s HTTP/1.%d\r\nUser-Agent: rpm/%s\r\nHost: %s:%d\r\nAccept: text/plain\r\n\r\n"	pointer
,	O
httpCmd	pointer
,	O
path	pointer
,	O
(	O
u	union
->	O
httpVersion	int
?	O
1	int
:	O
0	int
)	O
,	O
VERSION	pointer
,	O
host	pointer
,	O
port	int
)	O
;	O
}	O
if	O
(	O
_ftp_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"-> %s"	pointer
,	O
req	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
req	pointer
)	O
;	O
if	O
(	O
fdWrite	function
(	O
ctrl	pointer
,	O
req	pointer
,	O
len	long
)	O
!=	O
len	long
)	O
{	O
rc	long
=	O
FTPERR_SERVER_IO_ERROR	O
;	O
goto	O
errxit	O
;	O
}	O
if	O
(	O
!	O
strcmp	function
(	O
httpCmd	pointer
,	O
"PUT"	pointer
)	O
)	O
{	O
ctrl	pointer
->	O
wr_chunked	int
=	O
1	int
;	O
}	O
else	O
{	O
rc	long
=	O
httpResp	function
(	O
u	union
,	O
ctrl	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	long
)	O
{	O
if	O
(	O
!	O
retrying	int
)	O
{	O
retrying	int
=	O
1	int
;	O
fdClose	function
(	O
ctrl	pointer
)	O
;	O
goto	O
reopen	O
;	O
}	O
goto	O
errxit	O
;	O
}	O
}	O
ctrl	pointer
=	O
fdLink	O
(	O
ctrl	pointer
,	O
"open data (httpReq)"	pointer
)	O
;	O
return	O
0	int
;	O
errxit	O
:	O
fdSetSyserrno	function
(	O
ctrl	pointer
,	O
errno	O
,	O
ftpStrerror	function
(	O
rc	long
)	O
)	O
;	O
errxit2	O
:	O
if	O
(	O
fdFileno	function
(	O
ctrl	pointer
)	O
>=	O
0	int
)	O
fdClose	function
(	O
ctrl	pointer
)	O
;	O
return	O
rc	long
;	O
}	O
void	O
*	O
ufdGetUrlinfo	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
if	O
(	O
fd	pointer
->	O
url	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
urlLink	function
(	O
fd	pointer
->	O
url	pointer
,	O
"ufdGetUrlinfo"	pointer
)	O
;	O
}	O
static	O
ssize_t	long
ufdRead	function
(	O
void	O
*	O
cookie	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
count	long
)	O
{	O
FD_t	pointer
fd	pointer
=	O
c2f	function
(	O
cookie	pointer
)	O
;	O
int	O
bytesRead	int
;	O
int	O
total	long
=	O
0	int
;	O
if	O
(	O
fdGetIo	function
(	O
fd	pointer
)	O
==	O
fdio	pointer
)	O
{	O
struct	O
stat	struct
sb	struct
;	O
int	O
fdno	int
=	O
fdFileno	function
(	O
fd	pointer
)	O
;	O
fstat	function
(	O
fdno	int
,	O
&	O
sb	struct
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
sb	struct
.	O
st_mode	int
)	O
)	O
return	O
fdRead	function
(	O
fd	pointer
,	O
buf	pointer
,	O
count	long
)	O
;	O
}	O
UFDONLY	O
(	O
fd	pointer
)	O
;	O
assert	O
(	O
fd	pointer
->	O
rd_timeoutsecs	int
>=	O
0	int
)	O
;	O
for	O
(	O
total	long
=	O
0	int
;	O
total	long
<	O
count	long
;	O
total	long
+=	O
bytesRead	int
)	O
{	O
int	O
rc	long
;	O
bytesRead	int
=	O
0	int
;	O
if	O
(	O
fd	pointer
->	O
bytesRemain	long
==	O
0	int
)	O
return	O
total	long
;	O
rc	long
=	O
fdReadable	function
(	O
fd	pointer
,	O
fd	pointer
->	O
rd_timeoutsecs	int
)	O
;	O
switch	O
(	O
rc	long
)	O
{	O
case	O
-	O
1	int
:	O
case	O
0	int
:	O
return	O
total	long
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
rc	long
=	O
fdRead	function
(	O
fd	pointer
,	O
buf	pointer
+	O
total	long
,	O
count	long
-	O
total	long
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
{	O
switch	O
(	O
errno	O
)	O
{	O
case	O
EWOULDBLOCK	O
:	O
continue	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** read: rc %d errno %d %s \"%s\"\n"	pointer
,	O
rc	long
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
,	O
buf	pointer
)	O
;	O
return	O
rc	long
;	O
break	O
;	O
}	O
else	O
if	O
(	O
rc	long
==	O
0	int
)	O
{	O
return	O
total	long
;	O
break	O
;	O
}	O
bytesRead	int
=	O
rc	long
;	O
}	O
return	O
count	long
;	O
}	O
static	O
ssize_t	long
ufdWrite	function
(	O
void	O
*	O
cookie	pointer
,	O
const	O
char	O
*	O
buf	pointer
,	O
size_t	long
count	long
)	O
{	O
FD_t	pointer
fd	pointer
=	O
c2f	function
(	O
cookie	pointer
)	O
;	O
int	O
bytesWritten	int
;	O
int	O
total	long
=	O
0	int
;	O
UFDONLY	O
(	O
fd	pointer
)	O
;	O
for	O
(	O
total	long
=	O
0	int
;	O
total	long
<	O
count	long
;	O
total	long
+=	O
bytesWritten	int
)	O
{	O
int	O
rc	long
;	O
bytesWritten	int
=	O
0	int
;	O
if	O
(	O
fd	pointer
->	O
bytesRemain	long
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"*** ufdWrite fd %p WRITE PAST END OF CONTENT\n"	pointer
,	O
fd	pointer
)	O
;	O
return	O
total	long
;	O
}	O
rc	long
=	O
fdWritable	function
(	O
fd	pointer
,	O
2	int
)	O
;	O
switch	O
(	O
rc	long
)	O
{	O
case	O
-	O
1	int
:	O
case	O
0	int
:	O
return	O
total	long
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
rc	long
=	O
fdWrite	function
(	O
fd	pointer
,	O
buf	pointer
+	O
total	long
,	O
count	long
-	O
total	long
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
{	O
switch	O
(	O
errno	O
)	O
{	O
case	O
EWOULDBLOCK	O
:	O
continue	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** write: rc %d errno %d %s \"%s\"\n"	pointer
,	O
rc	long
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
,	O
buf	pointer
)	O
;	O
return	O
rc	long
;	O
break	O
;	O
}	O
else	O
if	O
(	O
rc	long
==	O
0	int
)	O
{	O
return	O
total	long
;	O
break	O
;	O
}	O
bytesWritten	int
=	O
rc	long
;	O
}	O
return	O
count	long
;	O
}	O
static	O
int	O
ufdSeek	function
(	O
void	O
*	O
cookie	pointer
,	O
off_t	long
pos	long
,	O
int	O
whence	int
)	O
{	O
FD_t	pointer
fd	pointer
=	O
c2f	function
(	O
cookie	pointer
)	O
;	O
switch	O
(	O
fd	pointer
->	O
urlType	int
)	O
{	O
case	O
URL_IS_UNKNOWN	int
:	O
case	O
URL_IS_PATH	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_HTTP	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
fdSeek	function
(	O
cookie	pointer
,	O
pos	long
,	O
whence	int
)	O
;	O
}	O
static	O
int	O
ufdClose	function
(	O
void	O
*	O
cookie	pointer
)	O
{	O
FD_t	pointer
fd	pointer
=	O
c2f	function
(	O
cookie	pointer
)	O
;	O
UFDONLY	O
(	O
fd	pointer
)	O
;	O
if	O
(	O
fd	pointer
->	O
url	pointer
)	O
{	O
urlinfo	struct
u	union
=	O
fd	pointer
->	O
url	pointer
;	O
if	O
(	O
fd	pointer
==	O
u	union
->	O
data	pointer
)	O
fd	pointer
=	O
u	union
->	O
data	pointer
=	O
fdFree	O
(	O
fd	pointer
,	O
"grab data (ufdClose persist)"	pointer
)	O
;	O
else	O
fd	pointer
=	O
fdFree	O
(	O
fd	pointer
,	O
"grab data (ufdClose)"	pointer
)	O
;	O
(	O
void	O
)	O
urlFree	function
(	O
fd	pointer
->	O
url	pointer
,	O
"url (ufdClose)"	pointer
)	O
;	O
fd	pointer
->	O
url	pointer
=	O
NULL	O
;	O
u	union
->	O
ctrl	pointer
=	O
fdFree	O
(	O
u	union
->	O
ctrl	pointer
,	O
"grab ctrl (ufdClose)"	pointer
)	O
;	O
if	O
(	O
u	union
->	O
urltype	enum
==	O
URL_IS_FTP	int
)	O
{	O
{	O
FILE	struct
*	O
fp	pointer
=	O
fdGetFILE	O
(	O
fd	pointer
)	O
;	O
if	O
(	O
noLibio	int
&&	O
fp	pointer
)	O
fdSetFp	function
(	O
fd	pointer
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
fd	pointer
->	O
bytesRemain	long
>	O
0	int
)	O
{	O
if	O
(	O
fd	pointer
->	O
ftpFileDoneNeeded	int
)	O
{	O
if	O
(	O
fdReadable	function
(	O
u	union
->	O
ctrl	pointer
,	O
0	int
)	O
>	O
0	int
)	O
ftpFileDone	function
(	O
u	union
,	O
fd	pointer
)	O
;	O
else	O
ftpAbort	function
(	O
u	union
,	O
fd	pointer
)	O
;	O
}	O
}	O
else	O
{	O
int	O
rc	long
;	O
rc	long
=	O
fdClose	function
(	O
fd	pointer
)	O
;	O
if	O
(	O
fd	pointer
->	O
ftpFileDoneNeeded	int
)	O
ftpFileDone	function
(	O
u	union
,	O
fd	pointer
)	O
;	O
return	O
rc	long
;	O
}	O
}	O
if	O
(	O
!	O
strcmp	function
(	O
u	union
->	O
service	pointer
,	O
"http"	pointer
)	O
)	O
{	O
if	O
(	O
fd	pointer
->	O
wr_chunked	int
)	O
{	O
int	O
rc	long
;	O
fdWrite	function
(	O
fd	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
fd	pointer
->	O
wr_chunked	int
=	O
0	int
;	O
if	O
(	O
_ftp_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"-> \r\n"	pointer
)	O
;	O
(	O
void	O
)	O
fdWrite	function
(	O
fd	pointer
,	O
"\r\n"	pointer
,	O
sizeof	O
(	O
"\r\n"	pointer
)	O
-	O
1	int
)	O
;	O
rc	long
=	O
httpResp	function
(	O
u	union
,	O
fd	pointer
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
fd	pointer
==	O
u	union
->	O
ctrl	pointer
)	O
fd	pointer
=	O
u	union
->	O
ctrl	pointer
=	O
fdFree	O
(	O
fd	pointer
,	O
"open data (ufdClose HTTP persist ctrl)"	pointer
)	O
;	O
else	O
if	O
(	O
fd	pointer
==	O
u	union
->	O
data	pointer
)	O
fd	pointer
=	O
u	union
->	O
data	pointer
=	O
fdFree	O
(	O
fd	pointer
,	O
"open data (ufdClose HTTP persist data)"	pointer
)	O
;	O
else	O
fd	pointer
=	O
fdFree	O
(	O
fd	pointer
,	O
"open data (ufdClose HTTP)"	pointer
)	O
;	O
{	O
FILE	struct
*	O
fp	pointer
=	O
fdGetFILE	O
(	O
fd	pointer
)	O
;	O
if	O
(	O
noLibio	int
&&	O
fp	pointer
)	O
fdSetFp	function
(	O
fd	pointer
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
fd	pointer
->	O
persist	int
&&	O
u	union
->	O
httpVersion	int
&&	O
(	O
fd	pointer
==	O
u	union
->	O
ctrl	pointer
||	O
fd	pointer
==	O
u	union
->	O
data	pointer
)	O
&&	O
fd	pointer
->	O
bytesRemain	long
==	O
0	int
)	O
{	O
fd	pointer
->	O
contentLength	long
=	O
fd	pointer
->	O
bytesRemain	long
=	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
else	O
{	O
fd	pointer
->	O
contentLength	long
=	O
fd	pointer
->	O
bytesRemain	long
=	O
-	O
1	int
;	O
}	O
}	O
}	O
return	O
fdClose	function
(	O
fd	pointer
)	O
;	O
}	O
static	O
FD_t	pointer
ftpOpen	function
(	O
const	O
char	O
*	O
url	pointer
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
,	O
urlinfo	struct
*	O
uret	pointer
)	O
{	O
urlinfo	struct
u	union
=	O
NULL	O
;	O
FD_t	pointer
fd	pointer
=	O
NULL	O
;	O
if	O
(	O
urlConnect	function
(	O
url	pointer
,	O
&	O
u	union
)	O
<	O
0	int
)	O
goto	O
exit	function
;	O
if	O
(	O
u	union
->	O
data	pointer
==	O
NULL	O
)	O
u	union
->	O
data	pointer
=	O
fdNew	O
(	O
"persist data (ftpOpen)"	pointer
)	O
;	O
if	O
(	O
u	union
->	O
data	pointer
->	O
url	pointer
==	O
NULL	O
)	O
fd	pointer
=	O
fdLink	O
(	O
u	union
->	O
data	pointer
,	O
"grab data (ftpOpen persist data)"	pointer
)	O
;	O
else	O
fd	pointer
=	O
fdNew	O
(	O
"grab data (ftpOpen)"	pointer
)	O
;	O
if	O
(	O
fd	pointer
)	O
{	O
fdSetIo	function
(	O
fd	pointer
,	O
ufdio	pointer
)	O
;	O
fd	pointer
->	O
ftpFileDoneNeeded	int
=	O
0	int
;	O
fd	pointer
->	O
rd_timeoutsecs	int
=	O
ftpTimeoutSecs	int
;	O
fd	pointer
->	O
contentLength	long
=	O
fd	pointer
->	O
bytesRemain	long
=	O
-	O
1	int
;	O
fd	pointer
->	O
url	pointer
=	O
urlLink	function
(	O
u	union
,	O
"url (ufdOpen FTP)"	pointer
)	O
;	O
fd	pointer
->	O
urlType	int
=	O
URL_IS_FTP	int
;	O
}	O
exit	function
:	O
if	O
(	O
uret	pointer
)	O
*	O
uret	pointer
=	O
u	union
;	O
return	O
fd	pointer
;	O
}	O
static	O
FD_t	pointer
httpOpen	function
(	O
const	O
char	O
*	O
url	pointer
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
,	O
urlinfo	struct
*	O
uret	pointer
)	O
{	O
urlinfo	struct
u	union
=	O
NULL	O
;	O
FD_t	pointer
fd	pointer
=	O
NULL	O
;	O
if	O
(	O
urlSplit	function
(	O
url	pointer
,	O
&	O
u	union
)	O
)	O
goto	O
exit	function
;	O
if	O
(	O
u	union
->	O
ctrl	pointer
==	O
NULL	O
)	O
u	union
->	O
ctrl	pointer
=	O
fdNew	O
(	O
"persist ctrl (httpOpen)"	pointer
)	O
;	O
if	O
(	O
u	union
->	O
ctrl	pointer
->	O
nrefs	int
>	O
2	int
&&	O
u	union
->	O
data	pointer
==	O
NULL	O
)	O
u	union
->	O
data	pointer
=	O
fdNew	O
(	O
"persist data (httpOpen)"	pointer
)	O
;	O
if	O
(	O
u	union
->	O
ctrl	pointer
->	O
url	pointer
==	O
NULL	O
)	O
fd	pointer
=	O
fdLink	O
(	O
u	union
->	O
ctrl	pointer
,	O
"grab ctrl (httpOpen persist ctrl)"	pointer
)	O
;	O
else	O
if	O
(	O
u	union
->	O
data	pointer
->	O
url	pointer
==	O
NULL	O
)	O
fd	pointer
=	O
fdLink	O
(	O
u	union
->	O
data	pointer
,	O
"grab ctrl (httpOpen persist data)"	pointer
)	O
;	O
else	O
fd	pointer
=	O
fdNew	O
(	O
"grab ctrl (httpOpen)"	pointer
)	O
;	O
if	O
(	O
fd	pointer
)	O
{	O
fdSetIo	function
(	O
fd	pointer
,	O
ufdio	pointer
)	O
;	O
fd	pointer
->	O
ftpFileDoneNeeded	int
=	O
0	int
;	O
fd	pointer
->	O
rd_timeoutsecs	int
=	O
httpTimeoutSecs	int
;	O
fd	pointer
->	O
contentLength	long
=	O
fd	pointer
->	O
bytesRemain	long
=	O
-	O
1	int
;	O
fd	pointer
->	O
url	pointer
=	O
urlLink	function
(	O
u	union
,	O
"url (httpOpen)"	pointer
)	O
;	O
fd	pointer
=	O
fdLink	O
(	O
fd	pointer
,	O
"grab data (httpOpen)"	pointer
)	O
;	O
fd	pointer
->	O
urlType	int
=	O
URL_IS_HTTP	int
;	O
}	O
exit	function
:	O
if	O
(	O
uret	pointer
)	O
*	O
uret	pointer
=	O
u	union
;	O
return	O
fd	pointer
;	O
}	O
static	O
FD_t	pointer
ufdOpen	function
(	O
const	O
char	O
*	O
url	pointer
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
)	O
{	O
FD_t	pointer
fd	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
cmd	pointer
;	O
urlinfo	struct
u	union
;	O
const	O
char	O
*	O
path	pointer
;	O
urltype	enum
urlType	int
=	O
urlPath	function
(	O
url	pointer
,	O
&	O
path	pointer
)	O
;	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** ufdOpen(%s,0x%x,0%o)\n"	pointer
,	O
url	pointer
,	O
flags	int
,	O
(	O
unsigned	O
)	O
mode	int
)	O
;	O
switch	O
(	O
urlType	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
fd	pointer
=	O
ftpOpen	function
(	O
url	pointer
,	O
flags	int
,	O
mode	int
,	O
&	O
u	union
)	O
;	O
if	O
(	O
fd	pointer
==	O
NULL	O
||	O
u	union
==	O
NULL	O
)	O
break	O
;	O
cmd	pointer
=	O
(	O
(	O
flags	int
&	O
O_WRONLY	int
)	O
?	O
(	O
(	O
flags	int
&	O
O_APPEND	int
)	O
?	O
"APPE"	pointer
:	O
(	O
(	O
flags	int
&	O
O_CREAT	int
)	O
?	O
"STOR"	pointer
:	O
"STOR"	pointer
)	O
)	O
:	O
(	O
(	O
flags	int
&	O
O_CREAT	int
)	O
?	O
"STOR"	pointer
:	O
"RETR"	pointer
)	O
)	O
;	O
u	union
->	O
openError	int
=	O
ftpReq	function
(	O
fd	pointer
,	O
cmd	pointer
,	O
path	pointer
)	O
;	O
if	O
(	O
u	union
->	O
openError	int
<	O
0	int
)	O
{	O
fd	pointer
=	O
fdLink	O
(	O
fd	pointer
,	O
"error data (ufdOpen FTP)"	pointer
)	O
;	O
}	O
else	O
{	O
fd	pointer
->	O
bytesRemain	long
=	O
(	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"RETR"	pointer
)	O
)	O
?	O
fd	pointer
->	O
contentLength	long
:	O
-	O
1	int
)	O
;	O
fd	pointer
->	O
wr_chunked	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
URL_IS_HTTP	int
:	O
fd	pointer
=	O
httpOpen	function
(	O
url	pointer
,	O
flags	int
,	O
mode	int
,	O
&	O
u	union
)	O
;	O
if	O
(	O
fd	pointer
==	O
NULL	O
||	O
u	union
==	O
NULL	O
)	O
break	O
;	O
cmd	pointer
=	O
(	O
(	O
flags	int
&	O
O_WRONLY	int
)	O
?	O
(	O
(	O
flags	int
&	O
O_APPEND	int
)	O
?	O
"PUT"	pointer
:	O
(	O
(	O
flags	int
&	O
O_CREAT	int
)	O
?	O
"PUT"	pointer
:	O
"PUT"	pointer
)	O
)	O
:	O
"GET"	pointer
)	O
;	O
u	union
->	O
openError	int
=	O
httpReq	function
(	O
fd	pointer
,	O
cmd	pointer
,	O
path	pointer
)	O
;	O
if	O
(	O
u	union
->	O
openError	int
<	O
0	int
)	O
{	O
fd	pointer
=	O
fdLink	O
(	O
fd	pointer
,	O
"error ctrl (ufdOpen HTTP)"	pointer
)	O
;	O
fd	pointer
=	O
fdLink	O
(	O
fd	pointer
,	O
"error data (ufdOpen HTTP)"	pointer
)	O
;	O
}	O
else	O
{	O
fd	pointer
->	O
bytesRemain	long
=	O
(	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"GET"	pointer
)	O
)	O
?	O
fd	pointer
->	O
contentLength	long
:	O
-	O
1	int
)	O
;	O
fd	pointer
->	O
wr_chunked	int
=	O
(	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"PUT"	pointer
)	O
)	O
?	O
fd	pointer
->	O
wr_chunked	int
:	O
0	int
)	O
;	O
}	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
assert	O
(	O
!	O
(	O
flags	int
&	O
O_RDWR	int
)	O
)	O
;	O
fd	pointer
=	O
fdDup	function
(	O
(	O
(	O
flags	int
&	O
O_WRONLY	int
)	O
?	O
STDOUT_FILENO	int
:	O
STDIN_FILENO	int
)	O
)	O
;	O
if	O
(	O
fd	pointer
)	O
{	O
fdSetIo	function
(	O
fd	pointer
,	O
ufdio	pointer
)	O
;	O
fd	pointer
->	O
rd_timeoutsecs	int
=	O
600	int
;	O
fd	pointer
->	O
contentLength	long
=	O
fd	pointer
->	O
bytesRemain	long
=	O
-	O
1	int
;	O
}	O
break	O
;	O
case	O
URL_IS_PATH	int
:	O
case	O
URL_IS_UNKNOWN	int
:	O
default	O
:	O
fd	pointer
=	O
fdOpen	function
(	O
path	pointer
,	O
flags	int
,	O
mode	int
)	O
;	O
if	O
(	O
fd	pointer
)	O
{	O
fdSetIo	function
(	O
fd	pointer
,	O
ufdio	pointer
)	O
;	O
fd	pointer
->	O
rd_timeoutsecs	int
=	O
1	int
;	O
fd	pointer
->	O
contentLength	long
=	O
fd	pointer
->	O
bytesRemain	long
=	O
-	O
1	int
;	O
}	O
break	O
;	O
}	O
if	O
(	O
fd	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
fd	pointer
->	O
urlType	int
=	O
urlType	int
;	O
if	O
(	O
Fileno	function
(	O
fd	pointer
)	O
<	O
0	int
)	O
{	O
ufdClose	function
(	O
fd	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==>\tufdOpen(\"%s\",%x,0%o) %s\n"	pointer
,	O
url	pointer
,	O
flags	int
,	O
(	O
unsigned	O
)	O
mode	int
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
return	O
fd	pointer
;	O
}	O
static	O
struct	O
FDIO_s	struct
ufdio_s	struct
=	O
{	O
ufdRead	function
,	O
ufdWrite	function
,	O
ufdSeek	function
,	O
ufdClose	function
,	O
XfdLink	function
,	O
XfdFree	function
,	O
XfdNew	function
,	O
fdFileno	function
,	O
ufdOpen	function
,	O
NULL	O
,	O
fdGetFp	function
,	O
NULL	O
,	O
Mkdir	function
,	O
Chdir	function
,	O
Rmdir	function
,	O
Rename	function
,	O
Unlink	function
}	O
;	O
FDIO_t	pointer
ufdio	pointer
=	O
&	O
ufdio_s	struct
;	O
long	O
int	O
fadGetFileSize	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
return	O
fd	pointer
->	O
fileSize	long
;	O
}	O
void	O
fadSetFileSize	function
(	O
FD_t	pointer
fd	pointer
,	O
long	O
int	O
fileSize	long
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
fd	pointer
->	O
fileSize	long
=	O
fileSize	long
;	O
}	O
unsigned	O
int	O
fadGetFirstFree	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
return	O
fd	pointer
->	O
firstFree	int
;	O
}	O
void	O
fadSetFirstFree	function
(	O
FD_t	pointer
fd	pointer
,	O
unsigned	O
int	O
firstFree	int
)	O
{	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
fd	pointer
->	O
firstFree	int
=	O
firstFree	int
;	O
}	O
extern	O
fdio_open_function_t	function
fadOpen	function
;	O
static	O
struct	O
FDIO_s	struct
fadio_s	struct
=	O
{	O
fdRead	function
,	O
fdWrite	function
,	O
fdSeek	function
,	O
fdClose	function
,	O
XfdLink	function
,	O
XfdFree	function
,	O
XfdNew	function
,	O
fdFileno	function
,	O
fadOpen	function
,	O
NULL	O
,	O
fdGetFp	function
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
FDIO_t	pointer
fadio	pointer
=	O
&	O
fadio_s	struct
;	O
static	O
const	O
char	O
*	O
getFdErrstr	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
const	O
char	O
*	O
errstr	pointer
=	O
NULL	O
;	O
{	O
errstr	pointer
=	O
strerror	function
(	O
fd	pointer
->	O
syserrno	int
)	O
;	O
}	O
return	O
errstr	pointer
;	O
}	O
const	O
char	O
*	O
Fstrerror	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
if	O
(	O
fd	pointer
==	O
NULL	O
)	O
return	O
strerror	function
(	O
errno	O
)	O
;	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
return	O
getFdErrstr	function
(	O
fd	pointer
)	O
;	O
}	O
size_t	long
Fread	function
(	O
void	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
size_t	long
nmemb	long
,	O
FD_t	pointer
fd	pointer
)	O
{	O
fdio_read_function_t	function
*	O
_read	pointer
;	O
int	O
rc	long
;	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==> Fread(%p,%u,%u,%p) %s\n"	pointer
,	O
buf	pointer
,	O
(	O
unsigned	O
)	O
size	long
,	O
(	O
unsigned	O
)	O
nmemb	long
,	O
fd	pointer
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
if	O
(	O
fdGetIo	function
(	O
fd	pointer
)	O
==	O
fpio	pointer
)	O
{	O
rc	long
=	O
fread	function
(	O
buf	pointer
,	O
size	long
,	O
nmemb	long
,	O
fdGetFILE	O
(	O
fd	pointer
)	O
)	O
;	O
return	O
rc	long
;	O
}	O
_read	pointer
=	O
FDIOVEC	O
(	O
fd	pointer
,	O
read	pointer
)	O
;	O
rc	long
=	O
(	O
_read	pointer
?	O
(	O
*	O
_read	pointer
)	O
(	O
fd	pointer
,	O
buf	pointer
,	O
size	long
*	O
nmemb	long
)	O
:	O
-	O
2	int
)	O
;	O
return	O
rc	long
;	O
}	O
size_t	long
Fwrite	function
(	O
const	O
void	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
size_t	long
nmemb	long
,	O
FD_t	pointer
fd	pointer
)	O
{	O
fdio_write_function_t	function
*	O
_write	pointer
;	O
int	O
rc	long
;	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==> Fwrite(%p,%u,%u,%p) %s\n"	pointer
,	O
buf	pointer
,	O
(	O
unsigned	O
)	O
size	long
,	O
(	O
unsigned	O
)	O
nmemb	long
,	O
fd	pointer
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
if	O
(	O
fdGetIo	function
(	O
fd	pointer
)	O
==	O
fpio	pointer
)	O
{	O
rc	long
=	O
fwrite	function
(	O
buf	pointer
,	O
size	long
,	O
nmemb	long
,	O
fdGetFILE	O
(	O
fd	pointer
)	O
)	O
;	O
return	O
rc	long
;	O
}	O
_write	pointer
=	O
FDIOVEC	O
(	O
fd	pointer
,	O
write	pointer
)	O
;	O
rc	long
=	O
(	O
_write	pointer
?	O
_write	pointer
(	O
fd	pointer
,	O
buf	pointer
,	O
size	long
*	O
nmemb	long
)	O
:	O
-	O
2	int
)	O
;	O
return	O
rc	long
;	O
}	O
int	O
Fseek	function
(	O
FD_t	pointer
fd	pointer
,	O
long	O
int	O
offset	long
,	O
int	O
whence	int
)	O
{	O
fdio_seek_function_t	function
*	O
_seek	pointer
;	O
long	O
int	O
rc	long
;	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==> Fseek(%p,%ld,%d) %s\n"	pointer
,	O
fd	pointer
,	O
offset	long
,	O
whence	int
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
if	O
(	O
fdGetIo	function
(	O
fd	pointer
)	O
==	O
fpio	pointer
)	O
{	O
rc	long
=	O
fseek	function
(	O
fdGetFILE	O
(	O
fd	pointer
)	O
,	O
offset	long
,	O
whence	int
)	O
;	O
return	O
rc	long
;	O
}	O
_seek	pointer
=	O
FDIOVEC	O
(	O
fd	pointer
,	O
seek	pointer
)	O
;	O
rc	long
=	O
(	O
_seek	pointer
?	O
_seek	pointer
(	O
fd	pointer
,	O
offset	long
,	O
whence	int
)	O
:	O
-	O
2	int
)	O
;	O
return	O
rc	long
;	O
}	O
int	O
Fclose	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
int	O
rc	long
,	O
ec	int
=	O
0	int
;	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==> Fclose(%p) %s\n"	pointer
,	O
fd	pointer
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
fd	pointer
=	O
fdLink	O
(	O
fd	pointer
,	O
"Fclose"	pointer
)	O
;	O
while	O
(	O
fd	pointer
->	O
nfps	int
>=	O
0	int
)	O
{	O
FDSTACK_t	struct
*	O
fps	array
=	O
&	O
fd	pointer
->	O
fps	array
[	O
fd	pointer
->	O
nfps	int
]	O
;	O
if	O
(	O
fps	array
->	O
io	pointer
==	O
fpio	pointer
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
fdGetFILE	O
(	O
fd	pointer
)	O
;	O
int	O
fpno	int
=	O
fileno	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
fd	pointer
->	O
nfps	int
>	O
0	int
&&	O
fpno	int
==	O
-	O
1	int
&&	O
fd	pointer
->	O
fps	array
[	O
fd	pointer
->	O
nfps	int
-	O
1	int
]	O
.	O
io	pointer
==	O
ufdio	pointer
&&	O
fd	pointer
->	O
fps	array
[	O
fd	pointer
->	O
nfps	int
-	O
1	int
]	O
.	O
fp	pointer
==	O
fp	pointer
&&	O
fd	pointer
->	O
fps	array
[	O
fd	pointer
->	O
nfps	int
-	O
1	int
]	O
.	O
fdno	int
>=	O
0	int
)	O
{	O
fflush	function
(	O
fp	pointer
)	O
;	O
fd	pointer
->	O
nfps	int
--	O
;	O
rc	long
=	O
ufdClose	function
(	O
fd	pointer
)	O
;	O
if	O
(	O
fdGetFdno	function
(	O
fd	pointer
)	O
>=	O
0	int
)	O
break	O
;	O
fdSetFp	function
(	O
fd	pointer
,	O
NULL	O
)	O
;	O
fd	pointer
->	O
nfps	int
++	O
;	O
rc	long
=	O
fclose	function
(	O
fp	pointer
)	O
;	O
fdPop	function
(	O
fd	pointer
)	O
;	O
if	O
(	O
noLibio	int
)	O
fdSetFp	function
(	O
fd	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
fflush	function
(	O
fp	pointer
)	O
;	O
rc	long
=	O
fclose	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
fpno	int
==	O
-	O
1	int
)	O
{	O
fd	pointer
=	O
fdFree	O
(	O
fd	pointer
,	O
"fopencookie (Fclose)"	pointer
)	O
;	O
fdPop	function
(	O
fd	pointer
)	O
;	O
if	O
(	O
rc	long
==	O
-	O
1	int
&&	O
fd	pointer
->	O
fps	array
[	O
fd	pointer
->	O
nfps	int
]	O
.	O
fdno	int
>=	O
0	int
)	O
{	O
fdio_close_function_t	function
*	O
_close	pointer
=	O
FDIOVEC	O
(	O
fd	pointer
,	O
close	pointer
)	O
;	O
rc	long
=	O
_close	pointer
(	O
fd	pointer
)	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
fdio_close_function_t	function
*	O
_close	pointer
=	O
FDIOVEC	O
(	O
fd	pointer
,	O
close	pointer
)	O
;	O
rc	long
=	O
_close	pointer
(	O
fd	pointer
)	O
;	O
}	O
if	O
(	O
fd	pointer
->	O
nfps	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
ec	int
==	O
0	int
&&	O
rc	long
)	O
ec	int
=	O
rc	long
;	O
fdPop	function
(	O
fd	pointer
)	O
;	O
}	O
fd	pointer
=	O
fdFree	O
(	O
fd	pointer
,	O
"Fclose"	pointer
)	O
;	O
return	O
ec	int
;	O
}	O
static	O
inline	O
void	O
cvtfmode	function
(	O
const	O
char	O
*	O
m	pointer
,	O
char	O
*	O
stdio	pointer
,	O
size_t	long
nstdio	long
,	O
char	O
*	O
other	pointer
,	O
size_t	long
nother	long
,	O
const	O
char	O
*	O
*	O
end	struct
,	O
int	O
*	O
f	pointer
)	O
{	O
int	O
flags	int
=	O
0	int
;	O
char	O
c	int
;	O
switch	O
(	O
*	O
m	pointer
)	O
{	O
case	O
'a'	O
:	O
flags	int
|=	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_APPEND	int
;	O
if	O
(	O
--	O
nstdio	long
>	O
0	int
)	O
*	O
stdio	pointer
++	O
=	O
*	O
m	pointer
;	O
break	O
;	O
case	O
'w'	O
:	O
flags	int
|=	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
;	O
if	O
(	O
--	O
nstdio	long
>	O
0	int
)	O
*	O
stdio	pointer
++	O
=	O
*	O
m	pointer
;	O
break	O
;	O
case	O
'r'	O
:	O
flags	int
|=	O
O_RDONLY	int
;	O
if	O
(	O
--	O
nstdio	long
>	O
0	int
)	O
*	O
stdio	pointer
++	O
=	O
*	O
m	pointer
;	O
break	O
;	O
default	O
:	O
*	O
stdio	pointer
=	O
'\0'	O
;	O
return	O
;	O
break	O
;	O
}	O
m	pointer
++	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
m	pointer
++	O
)	O
!=	O
'\0'	O
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'.'	O
:	O
break	O
;	O
case	O
'+'	O
:	O
flags	int
&=	O
~	O
(	O
O_RDONLY	int
|	O
O_WRONLY	int
)	O
;	O
flags	int
|=	O
O_RDWR	int
;	O
if	O
(	O
--	O
nstdio	long
>	O
0	int
)	O
*	O
stdio	pointer
++	O
=	O
c	int
;	O
continue	O
;	O
case	O
'b'	O
:	O
if	O
(	O
--	O
nstdio	long
>	O
0	int
)	O
*	O
stdio	pointer
++	O
=	O
c	int
;	O
continue	O
;	O
case	O
'x'	O
:	O
flags	int
|=	O
O_EXCL	int
;	O
if	O
(	O
--	O
nstdio	long
>	O
0	int
)	O
*	O
stdio	pointer
++	O
=	O
c	int
;	O
continue	O
;	O
default	O
:	O
if	O
(	O
--	O
nother	long
>	O
0	int
)	O
*	O
other	pointer
++	O
=	O
c	int
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
*	O
stdio	pointer
=	O
*	O
other	pointer
=	O
'\0'	O
;	O
if	O
(	O
end	struct
)	O
*	O
end	struct
=	O
(	O
*	O
m	pointer
?	O
m	pointer
:	O
NULL	O
)	O
;	O
if	O
(	O
f	pointer
)	O
*	O
f	pointer
=	O
flags	int
;	O
}	O
FD_t	pointer
Fdopen	function
(	O
FD_t	pointer
ofd	pointer
,	O
const	O
char	O
*	O
fmode	pointer
)	O
{	O
char	O
stdio	pointer
[	O
20	int
]	O
,	O
other	pointer
[	O
20	int
]	O
,	O
zstdio	array
[	O
20	int
]	O
;	O
const	O
char	O
*	O
end	struct
=	O
NULL	O
;	O
FDIO_t	pointer
iof	pointer
=	O
NULL	O
;	O
FD_t	pointer
fd	pointer
=	O
ofd	pointer
;	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Fdopen(%p,%s) %s\n"	pointer
,	O
fd	pointer
,	O
fmode	pointer
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
;	O
FDSANE	O
(	O
fd	pointer
)	O
;	O
if	O
(	O
fmode	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
cvtfmode	function
(	O
fmode	pointer
,	O
stdio	pointer
,	O
sizeof	O
(	O
stdio	pointer
)	O
,	O
other	pointer
,	O
sizeof	O
(	O
other	pointer
)	O
,	O
&	O
end	struct
,	O
NULL	O
)	O
;	O
if	O
(	O
stdio	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
NULL	O
;	O
zstdio	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
strncat	function
(	O
zstdio	array
,	O
stdio	pointer
,	O
sizeof	O
(	O
zstdio	array
)	O
-	O
strlen	function
(	O
zstdio	array
)	O
)	O
;	O
strncat	function
(	O
zstdio	array
,	O
other	pointer
,	O
sizeof	O
(	O
zstdio	array
)	O
-	O
strlen	function
(	O
zstdio	array
)	O
)	O
;	O
if	O
(	O
end	struct
==	O
NULL	O
&&	O
other	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
fd	pointer
;	O
if	O
(	O
end	struct
&&	O
*	O
end	struct
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
end	struct
,	O
"fdio"	pointer
)	O
)	O
{	O
iof	pointer
=	O
fdio	pointer
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
end	struct
,	O
"ufdio"	pointer
)	O
)	O
{	O
iof	pointer
=	O
ufdio	pointer
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
end	struct
,	O
"fadio"	pointer
)	O
)	O
{	O
iof	pointer
=	O
fadio	pointer
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
end	struct
,	O
"fpio"	pointer
)	O
)	O
{	O
iof	pointer
=	O
fpio	pointer
;	O
if	O
(	O
noLibio	int
)	O
{	O
int	O
fdno	int
=	O
Fileno	function
(	O
fd	pointer
)	O
;	O
FILE	struct
*	O
fp	pointer
=	O
fdopen	function
(	O
fdno	int
,	O
stdio	pointer
)	O
;	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Fdopen fpio fp %p\n"	pointer
,	O
fp	pointer
)	O
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
if	O
(	O
fdGetFp	function
(	O
fd	pointer
)	O
==	O
NULL	O
)	O
fdSetFp	function
(	O
fd	pointer
,	O
fp	pointer
)	O
;	O
fdPush	function
(	O
fd	pointer
,	O
fpio	pointer
,	O
fp	pointer
,	O
fdno	int
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
other	pointer
[	O
0	int
]	O
)	O
{	O
for	O
(	O
end	struct
=	O
other	pointer
;	O
*	O
end	struct
&&	O
strchr	function
(	O
"0123456789fh"	pointer
,	O
*	O
end	struct
)	O
;	O
end	struct
++	O
)	O
;	O
if	O
(	O
*	O
end	struct
==	O
'\0'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal error in rpmio.c:%d\n"	pointer
,	O
__LINE__	O
)	O
;	O
}	O
}	O
if	O
(	O
iof	pointer
==	O
NULL	O
)	O
return	O
fd	pointer
;	O
if	O
(	O
!	O
noLibio	int
)	O
{	O
FILE	struct
*	O
fp	pointer
=	O
NULL	O
;	O
if	O
(	O
fp	pointer
)	O
{	O
if	O
(	O
fdGetFp	function
(	O
fd	pointer
)	O
==	O
NULL	O
)	O
fdSetFp	function
(	O
fd	pointer
,	O
fp	pointer
)	O
;	O
fdPush	function
(	O
fd	pointer
,	O
fpio	pointer
,	O
fp	pointer
,	O
fileno	function
(	O
fp	pointer
)	O
)	O
;	O
fd	pointer
=	O
fdLink	O
(	O
fd	pointer
,	O
"fopencookie"	pointer
)	O
;	O
}	O
}	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==> Fdopen(%p,\"%s\") returns fd %p %s\n"	pointer
,	O
ofd	pointer
,	O
fmode	pointer
,	O
fd	pointer
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
return	O
fd	pointer
;	O
}	O
FD_t	pointer
Fopen	function
(	O
const	O
char	O
*	O
path	pointer
,	O
const	O
char	O
*	O
fmode	pointer
)	O
{	O
char	O
stdio	pointer
[	O
20	int
]	O
,	O
other	pointer
[	O
20	int
]	O
;	O
const	O
char	O
*	O
end	struct
=	O
NULL	O
;	O
mode_t	int
perms	int
=	O
0666	int
;	O
int	O
flags	int
;	O
FD_t	pointer
fd	pointer
;	O
if	O
(	O
path	pointer
==	O
NULL	O
||	O
fmode	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
cvtfmode	function
(	O
fmode	pointer
,	O
stdio	pointer
,	O
sizeof	O
(	O
stdio	pointer
)	O
,	O
other	pointer
,	O
sizeof	O
(	O
other	pointer
)	O
,	O
&	O
end	struct
,	O
&	O
flags	int
)	O
;	O
if	O
(	O
stdio	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
return	O
NULL	O
;	O
if	O
(	O
end	struct
==	O
NULL	O
||	O
!	O
strcmp	function
(	O
end	struct
,	O
"fdio"	pointer
)	O
)	O
{	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Fopen fdio path %s fmode %s\n"	pointer
,	O
path	pointer
,	O
fmode	pointer
)	O
;	O
fd	pointer
=	O
fdOpen	function
(	O
path	pointer
,	O
flags	int
,	O
perms	int
)	O
;	O
if	O
(	O
fdFileno	function
(	O
fd	pointer
)	O
<	O
0	int
)	O
{	O
fdClose	function
(	O
fd	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
end	struct
,	O
"fadio"	pointer
)	O
)	O
{	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Fopen fadio path %s fmode %s\n"	pointer
,	O
path	pointer
,	O
fmode	pointer
)	O
;	O
fd	pointer
=	O
fadOpen	function
(	O
path	pointer
,	O
flags	int
,	O
perms	int
)	O
;	O
if	O
(	O
fdFileno	function
(	O
fd	pointer
)	O
<	O
0	int
)	O
{	O
fdClose	function
(	O
fd	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
{	O
FILE	struct
*	O
fp	pointer
;	O
int	O
fdno	int
;	O
int	O
isHTTP	int
=	O
0	int
;	O
switch	O
(	O
urlIsURL	function
(	O
path	pointer
)	O
)	O
{	O
case	O
URL_IS_HTTP	int
:	O
isHTTP	int
=	O
1	int
;	O
case	O
URL_IS_PATH	int
:	O
case	O
URL_IS_DASH	int
:	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_UNKNOWN	int
:	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Fopen ufdio path %s fmode %s\n"	pointer
,	O
path	pointer
,	O
fmode	pointer
)	O
;	O
fd	pointer
=	O
ufdOpen	function
(	O
path	pointer
,	O
flags	int
,	O
perms	int
)	O
;	O
if	O
(	O
fd	pointer
==	O
NULL	O
||	O
fdFileno	function
(	O
fd	pointer
)	O
<	O
0	int
)	O
return	O
fd	pointer
;	O
break	O
;	O
default	O
:	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Fopen WTFO path %s fmode %s\n"	pointer
,	O
path	pointer
,	O
fmode	pointer
)	O
;	O
return	O
NULL	O
;	O
break	O
;	O
}	O
if	O
(	O
isHTTP	int
&&	O
(	O
(	O
fp	pointer
=	O
fdGetFp	function
(	O
fd	pointer
)	O
)	O
!=	O
NULL	O
)	O
&&	O
(	O
(	O
fdno	int
=	O
fdGetFdno	function
(	O
fd	pointer
)	O
)	O
>=	O
0	int
)	O
)	O
{	O
fdPush	function
(	O
fd	pointer
,	O
fpio	pointer
,	O
fp	pointer
,	O
fileno	function
(	O
fp	pointer
)	O
)	O
;	O
return	O
fd	pointer
;	O
}	O
}	O
fd	pointer
=	O
Fdopen	function
(	O
fd	pointer
,	O
fmode	pointer
)	O
;	O
return	O
fd	pointer
;	O
}	O
int	O
Fflush	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
if	O
(	O
fd	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
if	O
(	O
fdGetIo	function
(	O
fd	pointer
)	O
==	O
fpio	pointer
)	O
return	O
fflush	function
(	O
fdGetFILE	O
(	O
fd	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
Ferror	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
int	O
i	int
,	O
rc	long
=	O
0	int
;	O
if	O
(	O
fd	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
fd	pointer
->	O
nfps	int
;	O
rc	long
==	O
0	int
&&	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
{	O
FDSTACK_t	struct
*	O
fps	array
=	O
&	O
fd	pointer
->	O
fps	array
[	O
i	int
]	O
;	O
int	O
ec	int
;	O
if	O
(	O
fps	array
->	O
io	pointer
==	O
fpio	pointer
)	O
{	O
ec	int
=	O
ferror	function
(	O
fdGetFILE	O
(	O
fd	pointer
)	O
)	O
;	O
}	O
else	O
{	O
ec	int
=	O
(	O
fdFileno	function
(	O
fd	pointer
)	O
<	O
0	int
?	O
-	O
1	int
:	O
0	int
)	O
;	O
}	O
if	O
(	O
rc	long
==	O
0	int
&&	O
ec	int
)	O
rc	long
=	O
ec	int
;	O
}	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==> Ferror(%p) rc %d %s\n"	pointer
,	O
fd	pointer
,	O
rc	long
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
return	O
rc	long
;	O
}	O
int	O
Fileno	function
(	O
FD_t	pointer
fd	pointer
)	O
{	O
int	O
i	int
,	O
rc	long
=	O
-	O
1	int
;	O
for	O
(	O
i	int
=	O
fd	pointer
->	O
nfps	int
;	O
rc	long
==	O
-	O
1	int
&&	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
{	O
rc	long
=	O
fd	pointer
->	O
fps	array
[	O
i	int
]	O
.	O
fdno	int
;	O
}	O
DBGIO	O
(	O
fd	pointer
,	O
(	O
stderr	pointer
,	O
"==> Fileno(%p) rc %d %s\n"	pointer
,	O
fd	pointer
,	O
rc	long
,	O
fdbg	function
(	O
fd	pointer
)	O
)	O
)	O
;	O
return	O
rc	long
;	O
}	O
int	O
Fcntl	function
(	O
FD_t	pointer
fd	pointer
,	O
int	O
op	int
,	O
void	O
*	O
lip	pointer
)	O
{	O
return	O
fcntl	function
(	O
Fileno	function
(	O
fd	pointer
)	O
,	O
op	int
,	O
lip	pointer
)	O
;	O
}	O
ssize_t	long
Pread	function
(	O
FD_t	pointer
fd	pointer
,	O
void	O
*	O
buf	pointer
,	O
size_t	long
count	long
,	O
off_t	long
offset	long
)	O
{	O
if	O
(	O
Fseek	function
(	O
fd	pointer
,	O
offset	long
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
Fread	function
(	O
buf	pointer
,	O
sizeof	O
(	O
char	O
)	O
,	O
count	long
,	O
fd	pointer
)	O
;	O
}	O
ssize_t	long
Pwrite	function
(	O
FD_t	pointer
fd	pointer
,	O
const	O
void	O
*	O
buf	pointer
,	O
size_t	long
count	long
,	O
off_t	long
offset	long
)	O
{	O
if	O
(	O
Fseek	function
(	O
fd	pointer
,	O
offset	long
,	O
SEEK_SET	int
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
return	O
Fwrite	function
(	O
buf	pointer
,	O
sizeof	O
(	O
char	O
)	O
,	O
count	long
,	O
fd	pointer
)	O
;	O
}	O
int	O
Mkdir	function
(	O
const	O
char	O
*	O
path	pointer
,	O
mode_t	int
mode	int
)	O
{	O
const	O
char	O
*	O
lpath	pointer
;	O
int	O
ut	int
=	O
urlPath	function
(	O
path	pointer
,	O
&	O
lpath	pointer
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
return	O
ftpMkdir	function
(	O
path	pointer
,	O
mode	int
)	O
;	O
break	O
;	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
path	pointer
=	O
lpath	pointer
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
mkdir	function
(	O
path	pointer
,	O
mode	int
)	O
;	O
}	O
int	O
Chdir	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
const	O
char	O
*	O
lpath	pointer
;	O
int	O
ut	int
=	O
urlPath	function
(	O
path	pointer
,	O
&	O
lpath	pointer
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
return	O
ftpChdir	function
(	O
path	pointer
)	O
;	O
break	O
;	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
path	pointer
=	O
lpath	pointer
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
chdir	function
(	O
path	pointer
)	O
;	O
}	O
int	O
Rmdir	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
const	O
char	O
*	O
lpath	pointer
;	O
int	O
ut	int
=	O
urlPath	function
(	O
path	pointer
,	O
&	O
lpath	pointer
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
return	O
ftpRmdir	function
(	O
path	pointer
)	O
;	O
break	O
;	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
path	pointer
=	O
lpath	pointer
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
rmdir	function
(	O
path	pointer
)	O
;	O
}	O
int	O
Rename	function
(	O
const	O
char	O
*	O
oldpath	pointer
,	O
const	O
char	O
*	O
newpath	pointer
)	O
{	O
const	O
char	O
*	O
oe	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
ne	long
=	O
NULL	O
;	O
int	O
oldut	int
,	O
newut	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
oldpath	pointer
,	O
newpath	pointer
)	O
)	O
return	O
0	int
;	O
oldut	int
=	O
urlPath	function
(	O
oldpath	pointer
,	O
&	O
oe	pointer
)	O
;	O
switch	O
(	O
oldut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
newut	int
=	O
urlPath	function
(	O
newpath	pointer
,	O
&	O
ne	long
)	O
;	O
switch	O
(	O
newut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** rename old %*s new %*s\n"	pointer
,	O
(	O
oe	pointer
-	O
oldpath	pointer
)	O
,	O
oldpath	pointer
,	O
(	O
ne	long
-	O
newpath	pointer
)	O
,	O
newpath	pointer
)	O
;	O
if	O
(	O
!	O
(	O
oldut	int
==	O
newut	int
&&	O
oe	pointer
&&	O
ne	long
&&	O
(	O
oe	pointer
-	O
oldpath	pointer
)	O
==	O
(	O
ne	long
-	O
newpath	pointer
)	O
&&	O
!	O
strncasecmp	function
(	O
oldpath	pointer
,	O
newpath	pointer
,	O
(	O
oe	pointer
-	O
oldpath	pointer
)	O
)	O
)	O
)	O
return	O
-	O
2	int
;	O
return	O
ftpRename	function
(	O
oldpath	pointer
,	O
newpath	pointer
)	O
;	O
break	O
;	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
oldpath	pointer
=	O
oe	pointer
;	O
newpath	pointer
=	O
ne	long
;	O
break	O
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
rename	function
(	O
oldpath	pointer
,	O
newpath	pointer
)	O
;	O
}	O
int	O
Link	function
(	O
const	O
char	O
*	O
oldpath	pointer
,	O
const	O
char	O
*	O
newpath	pointer
)	O
{	O
const	O
char	O
*	O
oe	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
ne	long
=	O
NULL	O
;	O
int	O
oldut	int
,	O
newut	int
;	O
oldut	int
=	O
urlPath	function
(	O
oldpath	pointer
,	O
&	O
oe	pointer
)	O
;	O
switch	O
(	O
oldut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
newut	int
=	O
urlPath	function
(	O
newpath	pointer
,	O
&	O
ne	long
)	O
;	O
switch	O
(	O
newut	int
)	O
{	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_PATH	int
:	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** link old %*s new %*s\n"	pointer
,	O
(	O
oe	pointer
-	O
oldpath	pointer
)	O
,	O
oldpath	pointer
,	O
(	O
ne	long
-	O
newpath	pointer
)	O
,	O
newpath	pointer
)	O
;	O
if	O
(	O
!	O
(	O
oldut	int
==	O
newut	int
&&	O
oe	pointer
&&	O
ne	long
&&	O
(	O
oe	pointer
-	O
oldpath	pointer
)	O
==	O
(	O
ne	long
-	O
newpath	pointer
)	O
&&	O
!	O
strncasecmp	function
(	O
oldpath	pointer
,	O
newpath	pointer
,	O
(	O
oe	pointer
-	O
oldpath	pointer
)	O
)	O
)	O
)	O
return	O
-	O
2	int
;	O
oldpath	pointer
=	O
oe	pointer
;	O
newpath	pointer
=	O
ne	long
;	O
break	O
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
link	function
(	O
oldpath	pointer
,	O
newpath	pointer
)	O
;	O
}	O
int	O
Unlink	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
const	O
char	O
*	O
lpath	pointer
;	O
int	O
ut	int
=	O
urlPath	function
(	O
path	pointer
,	O
&	O
lpath	pointer
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
return	O
ftpUnlink	function
(	O
path	pointer
)	O
;	O
break	O
;	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
path	pointer
=	O
lpath	pointer
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
unlink	function
(	O
path	pointer
)	O
;	O
}	O
static	O
int	O
current_mday	int
;	O
static	O
int	O
current_mon	int
;	O
static	O
int	O
current_year	int
;	O
static	O
char	O
*	O
columns	array
[	O
MAXCOLS	int
]	O
;	O
static	O
int	O
column_ptr	array
[	O
MAXCOLS	int
]	O
;	O
static	O
int	O
vfs_split_text	function
(	O
char	O
*	O
p	pointer
)	O
{	O
char	O
*	O
original	pointer
=	O
p	pointer
;	O
int	O
numcols	int
;	O
for	O
(	O
numcols	int
=	O
0	int
;	O
*	O
p	pointer
&&	O
numcols	int
<	O
MAXCOLS	int
;	O
numcols	int
++	O
)	O
{	O
while	O
(	O
*	O
p	pointer
==	O
' '	O
||	O
*	O
p	pointer
==	O
'\r'	O
||	O
*	O
p	pointer
==	O
'\n'	O
)	O
{	O
*	O
p	pointer
=	O
0	int
;	O
p	pointer
++	O
;	O
}	O
columns	array
[	O
numcols	int
]	O
=	O
p	pointer
;	O
column_ptr	array
[	O
numcols	int
]	O
=	O
p	pointer
-	O
original	pointer
;	O
while	O
(	O
*	O
p	pointer
&&	O
*	O
p	pointer
!=	O
' '	O
&&	O
*	O
p	pointer
!=	O
'\r'	O
&&	O
*	O
p	pointer
!=	O
'\n'	O
)	O
p	pointer
++	O
;	O
}	O
return	O
numcols	int
;	O
}	O
static	O
int	O
is_num	function
(	O
int	O
idx	int
)	O
{	O
if	O
(	O
!	O
columns	array
[	O
idx	int
]	O
||	O
columns	array
[	O
idx	int
]	O
[	O
0	int
]	O
<	O
'0'	O
||	O
columns	array
[	O
idx	int
]	O
[	O
0	int
]	O
>	O
'9'	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
is_dos_date	function
(	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
strlen	function
(	O
str	pointer
)	O
==	O
8	int
&&	O
str	pointer
[	O
2	int
]	O
==	O
str	pointer
[	O
5	int
]	O
&&	O
strchr	function
(	O
"\\-/"	pointer
,	O
(	O
int	O
)	O
str	pointer
[	O
2	int
]	O
)	O
!=	O
NULL	O
)	O
return	O
(	O
1	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
is_week	function
(	O
char	O
*	O
str	pointer
,	O
struct	O
tm	struct
*	O
tim	pointer
)	O
{	O
static	O
char	O
*	O
week	pointer
=	O
"SunMonTueWedThuFriSat"	pointer
;	O
char	O
*	O
pos	long
;	O
if	O
(	O
(	O
pos	long
=	O
strstr	function
(	O
week	pointer
,	O
str	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
tim	pointer
!=	O
NULL	O
)	O
tim	pointer
->	O
tm_wday	int
=	O
(	O
pos	long
-	O
week	pointer
)	O
/	O
3	int
;	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
is_month	function
(	O
char	O
*	O
str	pointer
,	O
struct	O
tm	struct
*	O
tim	pointer
)	O
{	O
static	O
char	O
*	O
month	pointer
=	O
"JanFebMarAprMayJunJulAugSepOctNovDec"	pointer
;	O
char	O
*	O
pos	long
;	O
if	O
(	O
(	O
pos	long
=	O
strstr	function
(	O
month	pointer
,	O
str	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
tim	pointer
!=	O
NULL	O
)	O
tim	pointer
->	O
tm_mon	int
=	O
(	O
pos	long
-	O
month	pointer
)	O
/	O
3	int
;	O
return	O
(	O
1	int
)	O
;	O
}	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
is_time	function
(	O
char	O
*	O
str	pointer
,	O
struct	O
tm	struct
*	O
tim	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
p2	pointer
;	O
if	O
(	O
(	O
p	pointer
=	O
strchr	function
(	O
str	pointer
,	O
':'	O
)	O
)	O
&&	O
(	O
p2	pointer
=	O
strrchr	function
(	O
str	pointer
,	O
':'	O
)	O
)	O
)	O
{	O
if	O
(	O
p	pointer
!=	O
p2	pointer
)	O
{	O
if	O
(	O
sscanf	function
(	O
str	pointer
,	O
"%2d:%2d:%2d"	pointer
,	O
&	O
tim	pointer
->	O
tm_hour	int
,	O
&	O
tim	pointer
->	O
tm_min	int
,	O
&	O
tim	pointer
->	O
tm_sec	int
)	O
!=	O
3	int
)	O
return	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
sscanf	function
(	O
str	pointer
,	O
"%2d:%2d"	pointer
,	O
&	O
tim	pointer
->	O
tm_hour	int
,	O
&	O
tim	pointer
->	O
tm_min	int
)	O
!=	O
2	int
)	O
return	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
int	O
is_year	function
(	O
char	O
*	O
str	pointer
,	O
struct	O
tm	struct
*	O
tim	pointer
)	O
{	O
long	O
year	long
;	O
if	O
(	O
strchr	function
(	O
str	pointer
,	O
':'	O
)	O
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
strlen	function
(	O
str	pointer
)	O
!=	O
4	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
sscanf	function
(	O
str	pointer
,	O
"%ld"	pointer
,	O
&	O
year	long
)	O
!=	O
1	int
)	O
return	O
(	O
0	int
)	O
;	O
if	O
(	O
year	long
<	O
1900	int
||	O
year	long
>	O
3000	int
)	O
return	O
(	O
0	int
)	O
;	O
tim	pointer
->	O
tm_year	int
=	O
(	O
int	O
)	O
(	O
year	long
-	O
1900	int
)	O
;	O
return	O
(	O
1	int
)	O
;	O
}	O
static	O
int	O
vfs_parse_filetype	function
(	O
char	O
c	int
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'd'	O
:	O
return	O
S_IFDIR	O
;	O
case	O
'b'	O
:	O
return	O
S_IFBLK	O
;	O
case	O
'c'	O
:	O
return	O
S_IFCHR	O
;	O
case	O
'l'	O
:	O
return	O
S_IFLNK	O
;	O
case	O
's'	O
:	O
case	O
'p'	O
:	O
return	O
S_IFIFO	O
;	O
case	O
'm'	O
:	O
case	O
'n'	O
:	O
case	O
'-'	O
:	O
case	O
'?'	O
:	O
return	O
S_IFREG	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
static	O
int	O
vfs_parse_filemode	function
(	O
char	O
*	O
p	pointer
)	O
{	O
int	O
res	int
=	O
0	int
;	O
switch	O
(	O
*	O
(	O
p	pointer
++	O
)	O
)	O
{	O
case	O
'r'	O
:	O
res	int
|=	O
0400	int
;	O
break	O
;	O
case	O
'-'	O
:	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
*	O
(	O
p	pointer
++	O
)	O
)	O
{	O
case	O
'w'	O
:	O
res	int
|=	O
0200	int
;	O
break	O
;	O
case	O
'-'	O
:	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
*	O
(	O
p	pointer
++	O
)	O
)	O
{	O
case	O
'x'	O
:	O
res	int
|=	O
0100	int
;	O
break	O
;	O
case	O
's'	O
:	O
res	int
|=	O
0100	int
|	O
S_ISUID	O
;	O
break	O
;	O
case	O
'S'	O
:	O
res	int
|=	O
S_ISUID	O
;	O
break	O
;	O
case	O
'-'	O
:	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
*	O
(	O
p	pointer
++	O
)	O
)	O
{	O
case	O
'r'	O
:	O
res	int
|=	O
0040	int
;	O
break	O
;	O
case	O
'-'	O
:	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
*	O
(	O
p	pointer
++	O
)	O
)	O
{	O
case	O
'w'	O
:	O
res	int
|=	O
0020	int
;	O
break	O
;	O
case	O
'-'	O
:	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
*	O
(	O
p	pointer
++	O
)	O
)	O
{	O
case	O
'x'	O
:	O
res	int
|=	O
0010	int
;	O
break	O
;	O
case	O
's'	O
:	O
res	int
|=	O
0010	int
|	O
S_ISGID	O
;	O
break	O
;	O
case	O
'l'	O
:	O
case	O
'S'	O
:	O
res	int
|=	O
S_ISGID	O
;	O
break	O
;	O
case	O
'-'	O
:	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
*	O
(	O
p	pointer
++	O
)	O
)	O
{	O
case	O
'r'	O
:	O
res	int
|=	O
0004	int
;	O
break	O
;	O
case	O
'-'	O
:	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
*	O
(	O
p	pointer
++	O
)	O
)	O
{	O
case	O
'w'	O
:	O
res	int
|=	O
0002	int
;	O
break	O
;	O
case	O
'-'	O
:	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
switch	O
(	O
*	O
(	O
p	pointer
++	O
)	O
)	O
{	O
case	O
'x'	O
:	O
res	int
|=	O
0001	int
;	O
break	O
;	O
case	O
't'	O
:	O
res	int
|=	O
0001	int
|	O
S_ISVTX	O
;	O
break	O
;	O
case	O
'T'	O
:	O
res	int
|=	O
S_ISVTX	O
;	O
break	O
;	O
case	O
'-'	O
:	O
break	O
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
vfs_parse_filedate	function
(	O
int	O
idx	int
,	O
time_t	long
*	O
t	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
struct	O
tm	struct
tim	pointer
;	O
int	O
d	array
[	O
3	int
]	O
;	O
int	O
got_year	int
=	O
0	int
;	O
tim	pointer
.	O
tm_year	int
=	O
current_year	int
;	O
tim	pointer
.	O
tm_mon	int
=	O
current_mon	int
;	O
tim	pointer
.	O
tm_mday	int
=	O
current_mday	int
;	O
tim	pointer
.	O
tm_hour	int
=	O
0	int
;	O
tim	pointer
.	O
tm_min	int
=	O
0	int
;	O
tim	pointer
.	O
tm_sec	int
=	O
0	int
;	O
tim	pointer
.	O
tm_isdst	int
=	O
-	O
1	int
;	O
p	pointer
=	O
columns	array
[	O
idx	int
++	O
]	O
;	O
if	O
(	O
is_week	function
(	O
p	pointer
,	O
&	O
tim	pointer
)	O
)	O
p	pointer
=	O
columns	array
[	O
idx	int
++	O
]	O
;	O
if	O
(	O
is_month	function
(	O
p	pointer
,	O
&	O
tim	pointer
)	O
)	O
{	O
if	O
(	O
is_num	function
(	O
idx	int
)	O
)	O
tim	pointer
.	O
tm_mday	int
=	O
(	O
int	O
)	O
atol	function
(	O
columns	array
[	O
idx	int
++	O
]	O
)	O
;	O
else	O
return	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
is_dos_date	function
(	O
p	pointer
)	O
)	O
{	O
p	pointer
[	O
2	int
]	O
=	O
p	pointer
[	O
5	int
]	O
=	O
'-'	O
;	O
if	O
(	O
sscanf	function
(	O
p	pointer
,	O
"%2d-%2d-%2d"	pointer
,	O
&	O
d	array
[	O
0	int
]	O
,	O
&	O
d	array
[	O
1	int
]	O
,	O
&	O
d	array
[	O
2	int
]	O
)	O
==	O
3	int
)	O
{	O
d	array
[	O
0	int
]	O
--	O
;	O
if	O
(	O
d	array
[	O
2	int
]	O
<	O
70	int
)	O
d	array
[	O
2	int
]	O
+=	O
100	int
;	O
tim	pointer
.	O
tm_mon	int
=	O
d	array
[	O
0	int
]	O
;	O
tim	pointer
.	O
tm_mday	int
=	O
d	array
[	O
1	int
]	O
;	O
tim	pointer
.	O
tm_year	int
=	O
d	array
[	O
2	int
]	O
;	O
got_year	int
=	O
1	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
if	O
(	O
is_num	function
(	O
idx	int
)	O
)	O
{	O
if	O
(	O
is_time	function
(	O
columns	array
[	O
idx	int
]	O
,	O
&	O
tim	pointer
)	O
||	O
(	O
got_year	int
=	O
is_year	function
(	O
columns	array
[	O
idx	int
]	O
,	O
&	O
tim	pointer
)	O
)	O
)	O
{	O
idx	int
++	O
;	O
if	O
(	O
is_num	function
(	O
idx	int
)	O
&&	O
(	O
(	O
got_year	int
=	O
is_year	function
(	O
columns	array
[	O
idx	int
]	O
,	O
&	O
tim	pointer
)	O
)	O
||	O
is_time	function
(	O
columns	array
[	O
idx	int
]	O
,	O
&	O
tim	pointer
)	O
)	O
)	O
idx	int
++	O
;	O
}	O
}	O
else	O
return	O
0	int
;	O
if	O
(	O
!	O
got_year	int
&&	O
current_mon	int
<	O
6	int
&&	O
current_mon	int
<	O
tim	pointer
.	O
tm_mon	int
&&	O
tim	pointer
.	O
tm_mon	int
-	O
current_mon	int
>=	O
6	int
)	O
tim	pointer
.	O
tm_year	int
--	O
;	O
if	O
(	O
(	O
*	O
t	pointer
=	O
mktime	function
(	O
&	O
tim	pointer
)	O
)	O
<	O
0	int
)	O
*	O
t	pointer
=	O
0	int
;	O
return	O
idx	int
;	O
}	O
static	O
int	O
vfs_parse_ls_lga	function
(	O
char	O
*	O
p	pointer
,	O
struct	O
stat	struct
*	O
s	pointer
,	O
char	O
*	O
*	O
filename	pointer
,	O
char	O
*	O
*	O
linkname	pointer
)	O
{	O
int	O
idx	int
,	O
idx2	int
,	O
num_cols	int
;	O
int	O
i	int
;	O
char	O
*	O
p_copy	pointer
;	O
if	O
(	O
strncmp	function
(	O
p	pointer
,	O
"total"	pointer
,	O
5	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
p_copy	pointer
=	O
g_strdup	O
(	O
p	pointer
)	O
;	O
if	O
(	O
(	O
i	int
=	O
vfs_parse_filetype	function
(	O
*	O
(	O
p	pointer
++	O
)	O
)	O
)	O
==	O
-	O
1	int
)	O
goto	O
error	pointer
;	O
s	pointer
->	O
st_mode	int
=	O
i	int
;	O
if	O
(	O
*	O
p	pointer
==	O
' '	O
)	O
p	pointer
++	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'['	O
)	O
{	O
if	O
(	O
strlen	function
(	O
p	pointer
)	O
<=	O
8	int
||	O
p	pointer
[	O
8	int
]	O
!=	O
']'	O
)	O
goto	O
error	pointer
;	O
if	O
(	O
S_ISDIR	O
(	O
s	pointer
->	O
st_mode	int
)	O
)	O
s	pointer
->	O
st_mode	int
|=	O
(	O
S_IRUSR	O
|	O
S_IRGRP	O
|	O
S_IROTH	O
|	O
S_IWUSR	O
|	O
S_IXUSR	O
|	O
S_IXGRP	O
|	O
S_IXOTH	O
)	O
;	O
else	O
s	pointer
->	O
st_mode	int
|=	O
(	O
S_IRUSR	O
|	O
S_IRGRP	O
|	O
S_IROTH	O
|	O
S_IWUSR	O
)	O
;	O
p	pointer
+=	O
9	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
i	int
=	O
vfs_parse_filemode	function
(	O
p	pointer
)	O
)	O
==	O
-	O
1	int
)	O
goto	O
error	pointer
;	O
s	pointer
->	O
st_mode	int
|=	O
i	int
;	O
p	pointer
+=	O
9	int
;	O
if	O
(	O
*	O
p	pointer
==	O
'+'	O
)	O
p	pointer
++	O
;	O
}	O
g_free	O
(	O
p_copy	pointer
)	O
;	O
p_copy	pointer
=	O
g_strdup	O
(	O
p	pointer
)	O
;	O
num_cols	int
=	O
vfs_split_text	function
(	O
p	pointer
)	O
;	O
s	pointer
->	O
st_nlink	long
=	O
atol	function
(	O
columns	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
s	pointer
->	O
st_nlink	long
<	O
0	int
)	O
goto	O
error	pointer
;	O
if	O
(	O
!	O
is_num	function
(	O
1	int
)	O
)	O
unameToUid	function
(	O
columns	array
[	O
1	int
]	O
,	O
&	O
s	pointer
->	O
st_uid	int
)	O
;	O
else	O
s	pointer
->	O
st_uid	int
=	O
(	O
uid_t	int
)	O
atol	function
(	O
columns	array
[	O
1	int
]	O
)	O
;	O
for	O
(	O
idx	int
=	O
3	int
;	O
idx	int
<=	O
5	int
;	O
idx	int
++	O
)	O
if	O
(	O
is_month	function
(	O
columns	array
[	O
idx	int
]	O
,	O
NULL	O
)	O
||	O
is_week	function
(	O
columns	array
[	O
idx	int
]	O
,	O
NULL	O
)	O
||	O
is_dos_date	function
(	O
columns	array
[	O
idx	int
]	O
)	O
)	O
break	O
;	O
if	O
(	O
idx	int
==	O
6	int
||	O
(	O
idx	int
==	O
5	int
&&	O
!	O
S_ISCHR	O
(	O
s	pointer
->	O
st_mode	int
)	O
&&	O
!	O
S_ISBLK	O
(	O
s	pointer
->	O
st_mode	int
)	O
)	O
)	O
goto	O
error	pointer
;	O
if	O
(	O
idx	int
==	O
3	int
||	O
(	O
idx	int
==	O
4	int
&&	O
(	O
S_ISCHR	O
(	O
s	pointer
->	O
st_mode	int
)	O
||	O
S_ISBLK	O
(	O
s	pointer
->	O
st_mode	int
)	O
)	O
)	O
)	O
idx2	int
=	O
2	int
;	O
else	O
{	O
if	O
(	O
is_num	function
(	O
2	int
)	O
)	O
s	pointer
->	O
st_gid	int
=	O
(	O
gid_t	int
)	O
atol	function
(	O
columns	array
[	O
2	int
]	O
)	O
;	O
else	O
gnameToGid	function
(	O
columns	array
[	O
1	int
]	O
,	O
&	O
s	pointer
->	O
st_gid	int
)	O
;	O
idx2	int
=	O
3	int
;	O
}	O
if	O
(	O
S_ISCHR	O
(	O
s	pointer
->	O
st_mode	int
)	O
||	O
S_ISBLK	O
(	O
s	pointer
->	O
st_mode	int
)	O
)	O
{	O
int	O
maj	int
,	O
min	int
;	O
if	O
(	O
!	O
is_num	function
(	O
idx2	int
)	O
||	O
sscanf	function
(	O
columns	array
[	O
idx2	int
]	O
,	O
" %d,"	pointer
,	O
&	O
maj	int
)	O
!=	O
1	int
)	O
goto	O
error	pointer
;	O
if	O
(	O
!	O
is_num	function
(	O
++	O
idx2	int
)	O
||	O
sscanf	function
(	O
columns	array
[	O
idx2	int
]	O
,	O
" %d"	pointer
,	O
&	O
min	int
)	O
!=	O
1	int
)	O
goto	O
error	pointer
;	O
s	pointer
->	O
st_size	long
=	O
0	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
is_num	function
(	O
idx2	int
)	O
)	O
goto	O
error	pointer
;	O
s	pointer
->	O
st_size	long
=	O
(	O
size_t	long
)	O
atol	function
(	O
columns	array
[	O
idx2	int
]	O
)	O
;	O
}	O
idx	int
=	O
vfs_parse_filedate	function
(	O
idx	int
,	O
&	O
s	pointer
->	O
st_mtime	O
)	O
;	O
if	O
(	O
!	O
idx	int
)	O
goto	O
error	pointer
;	O
s	pointer
->	O
st_atime	O
=	O
s	pointer
->	O
st_ctime	O
=	O
s	pointer
->	O
st_mtime	O
;	O
s	pointer
->	O
st_dev	long
=	O
0	int
;	O
s	pointer
->	O
st_ino	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
idx	int
+	O
1	int
,	O
idx2	int
=	O
0	int
;	O
i	int
<	O
num_cols	int
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
columns	array
[	O
i	int
]	O
,	O
"->"	pointer
)	O
==	O
0	int
)	O
{	O
idx2	int
=	O
i	int
;	O
break	O
;	O
}	O
if	O
(	O
(	O
(	O
S_ISLNK	O
(	O
s	pointer
->	O
st_mode	int
)	O
||	O
(	O
num_cols	int
==	O
idx	int
+	O
3	int
&&	O
s	pointer
->	O
st_nlink	long
>	O
1	int
)	O
)	O
)	O
&&	O
idx2	int
)	O
{	O
int	O
p	pointer
;	O
char	O
*	O
s	pointer
;	O
if	O
(	O
filename	pointer
)	O
{	O
int	O
nb	long
=	O
column_ptr	array
[	O
idx2	int
]	O
-	O
column_ptr	array
[	O
idx	int
]	O
-	O
1	int
;	O
s	pointer
=	O
xmalloc	function
(	O
nb	long
+	O
1	int
)	O
;	O
strncpy	function
(	O
s	pointer
,	O
p_copy	pointer
+	O
column_ptr	array
[	O
idx	int
]	O
,	O
nb	long
)	O
;	O
*	O
filename	pointer
=	O
s	pointer
;	O
}	O
if	O
(	O
linkname	pointer
)	O
{	O
s	pointer
=	O
g_strdup	O
(	O
p_copy	pointer
+	O
column_ptr	array
[	O
idx2	int
+	O
1	int
]	O
)	O
;	O
p	pointer
=	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
s	pointer
[	O
p	pointer
-	O
1	int
]	O
==	O
'\r'	O
||	O
s	pointer
[	O
p	pointer
-	O
1	int
]	O
==	O
'\n'	O
)	O
s	pointer
[	O
p	pointer
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
s	pointer
[	O
p	pointer
-	O
2	int
]	O
==	O
'\r'	O
||	O
s	pointer
[	O
p	pointer
-	O
2	int
]	O
==	O
'\n'	O
)	O
s	pointer
[	O
p	pointer
-	O
2	int
]	O
=	O
0	int
;	O
*	O
linkname	pointer
=	O
s	pointer
;	O
}	O
}	O
else	O
{	O
if	O
(	O
filename	pointer
)	O
{	O
int	O
p	pointer
;	O
char	O
*	O
s	pointer
;	O
s	pointer
=	O
g_strdup	O
(	O
p_copy	pointer
+	O
column_ptr	array
[	O
idx	int
++	O
]	O
)	O
;	O
p	pointer
=	O
strlen	function
(	O
s	pointer
)	O
;	O
if	O
(	O
s	pointer
[	O
p	pointer
-	O
1	int
]	O
==	O
'\r'	O
||	O
s	pointer
[	O
p	pointer
-	O
1	int
]	O
==	O
'\n'	O
)	O
s	pointer
[	O
p	pointer
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
s	pointer
[	O
p	pointer
-	O
2	int
]	O
==	O
'\r'	O
||	O
s	pointer
[	O
p	pointer
-	O
2	int
]	O
==	O
'\n'	O
)	O
s	pointer
[	O
p	pointer
-	O
2	int
]	O
=	O
0	int
;	O
*	O
filename	pointer
=	O
s	pointer
;	O
}	O
if	O
(	O
linkname	pointer
)	O
*	O
linkname	pointer
=	O
NULL	O
;	O
}	O
g_free	O
(	O
p_copy	pointer
)	O
;	O
return	O
1	int
;	O
error	pointer
:	O
if	O
(	O
p_copy	pointer
!=	O
p	pointer
)	O
g_free	O
(	O
p_copy	pointer
)	O
;	O
return	O
0	int
;	O
}	O
typedef	O
enum	O
{	O
DO_FTP_STAT	int
=	O
1	int
,	O
DO_FTP_LSTAT	int
=	O
2	int
,	O
DO_FTP_READLINK	int
=	O
3	int
,	O
DO_FTP_ACCESS	int
=	O
4	int
,	O
DO_FTP_GLOB	int
=	O
5	int
}	O
ftpSysCall_t	enum
;	O
static	O
size_t	long
ftpBufAlloced	long
=	O
0	int
;	O
static	O
char	O
*	O
ftpBuf	pointer
=	O
NULL	O
;	O
static	O
int	O
ftpNLST	function
(	O
const	O
char	O
*	O
url	pointer
,	O
ftpSysCall_t	enum
ftpSysCall	enum
,	O
struct	O
stat	struct
*	O
st	pointer
,	O
char	O
*	O
rlbuf	pointer
,	O
size_t	long
rlbufsiz	long
)	O
{	O
FD_t	pointer
fd	pointer
;	O
const	O
char	O
*	O
path	pointer
;	O
int	O
bufLength	int
,	O
moretodo	int
;	O
const	O
char	O
*	O
n	int
,	O
*	O
ne	long
,	O
*	O
o	pointer
,	O
*	O
oe	pointer
;	O
char	O
*	O
s	pointer
;	O
char	O
*	O
se	pointer
;	O
const	O
char	O
*	O
urldn	pointer
;	O
char	O
*	O
bn	pointer
=	O
NULL	O
;	O
int	O
nbn	int
=	O
0	int
;	O
urlinfo	struct
u	union
;	O
int	O
rc	long
;	O
n	int
=	O
ne	long
=	O
o	pointer
=	O
oe	pointer
=	O
NULL	O
;	O
(	O
void	O
)	O
urlPath	function
(	O
url	pointer
,	O
&	O
path	pointer
)	O
;	O
if	O
(	O
*	O
path	pointer
==	O
'\0'	O
)	O
return	O
-	O
2	int
;	O
switch	O
(	O
ftpSysCall	enum
)	O
{	O
case	O
DO_FTP_GLOB	int
:	O
fd	pointer
=	O
ftpOpen	function
(	O
url	pointer
,	O
0	int
,	O
0	int
,	O
&	O
u	union
)	O
;	O
if	O
(	O
fd	pointer
==	O
NULL	O
||	O
u	union
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
u	union
->	O
openError	int
=	O
ftpReq	function
(	O
fd	pointer
,	O
"NLST"	pointer
,	O
path	pointer
)	O
;	O
break	O
;	O
default	O
:	O
urldn	pointer
=	O
alloca_strdup	O
(	O
url	pointer
)	O
;	O
if	O
(	O
(	O
bn	pointer
=	O
strrchr	function
(	O
urldn	pointer
,	O
'/'	O
)	O
)	O
==	O
NULL	O
)	O
return	O
-	O
2	int
;	O
else	O
if	O
(	O
bn	pointer
==	O
path	pointer
)	O
bn	pointer
=	O
"."	pointer
;	O
else	O
*	O
bn	pointer
++	O
=	O
'\0'	O
;	O
nbn	int
=	O
strlen	function
(	O
bn	pointer
)	O
;	O
rc	long
=	O
ftpChdir	function
(	O
urldn	pointer
)	O
;	O
if	O
(	O
rc	long
<	O
0	int
)	O
return	O
rc	long
;	O
fd	pointer
=	O
ftpOpen	function
(	O
url	pointer
,	O
0	int
,	O
0	int
,	O
&	O
u	union
)	O
;	O
if	O
(	O
fd	pointer
==	O
NULL	O
||	O
u	union
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
u	union
->	O
openError	int
=	O
ftpReq	function
(	O
fd	pointer
,	O
"NLST"	pointer
,	O
"-la"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
u	union
->	O
openError	int
<	O
0	int
)	O
{	O
fd	pointer
=	O
fdLink	O
(	O
fd	pointer
,	O
"error data (ftpStat)"	pointer
)	O
;	O
rc	long
=	O
-	O
2	int
;	O
goto	O
exit	function
;	O
}	O
if	O
(	O
ftpBufAlloced	long
==	O
0	int
||	O
ftpBuf	pointer
==	O
NULL	O
)	O
{	O
ftpBufAlloced	long
=	O
url_iobuf_size	int
;	O
ftpBuf	pointer
=	O
xcalloc	function
(	O
ftpBufAlloced	long
,	O
sizeof	O
(	O
ftpBuf	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
*	O
ftpBuf	pointer
=	O
'\0'	O
;	O
bufLength	int
=	O
0	int
;	O
moretodo	int
=	O
1	int
;	O
do	O
{	O
if	O
(	O
(	O
ftpBufAlloced	long
-	O
bufLength	int
)	O
<	O
(	O
1024	int
+	O
80	int
)	O
)	O
{	O
ftpBufAlloced	long
<<=	O
2	int
;	O
ftpBuf	pointer
=	O
xrealloc	function
(	O
ftpBuf	pointer
,	O
ftpBufAlloced	long
)	O
;	O
}	O
s	pointer
=	O
se	pointer
=	O
ftpBuf	pointer
+	O
bufLength	int
;	O
*	O
se	pointer
=	O
'\0'	O
;	O
rc	long
=	O
fdFgets	function
(	O
fd	pointer
,	O
se	pointer
,	O
(	O
ftpBufAlloced	long
-	O
bufLength	int
)	O
)	O
;	O
if	O
(	O
rc	long
<=	O
0	int
)	O
{	O
moretodo	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
ftpSysCall	enum
==	O
DO_FTP_GLOB	int
)	O
{	O
bufLength	int
+=	O
strlen	function
(	O
se	pointer
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
s	pointer
=	O
se	pointer
;	O
*	O
s	pointer
!=	O
'\0'	O
;	O
s	pointer
=	O
se	pointer
)	O
{	O
int	O
bingo	int
;	O
while	O
(	O
*	O
se	pointer
&&	O
*	O
se	pointer
!=	O
'\n'	O
)	O
se	pointer
++	O
;	O
if	O
(	O
se	pointer
>	O
s	pointer
&&	O
se	pointer
[	O
-	O
1	int
]	O
==	O
'\r'	O
)	O
se	pointer
[	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
se	pointer
==	O
'\0'	O
)	O
break	O
;	O
*	O
se	pointer
++	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
"total "	pointer
,	O
sizeof	O
(	O
"total "	pointer
)	O
-	O
1	int
)	O
)	O
continue	O
;	O
o	pointer
=	O
NULL	O
;	O
for	O
(	O
bingo	int
=	O
0	int
,	O
n	int
=	O
se	pointer
;	O
n	int
>=	O
s	pointer
;	O
n	int
--	O
)	O
{	O
switch	O
(	O
*	O
n	int
)	O
{	O
case	O
'\0'	O
:	O
oe	pointer
=	O
ne	long
=	O
n	int
;	O
break	O
;	O
case	O
' '	O
:	O
if	O
(	O
o	pointer
||	O
!	O
(	O
n	int
[	O
-	O
3	int
]	O
==	O
' '	O
&&	O
n	int
[	O
-	O
2	int
]	O
==	O
'-'	O
&&	O
n	int
[	O
-	O
1	int
]	O
==	O
'>'	O
)	O
)	O
{	O
while	O
(	O
*	O
(	O
++	O
n	int
)	O
==	O
' '	O
)	O
;	O
bingo	int
++	O
;	O
break	O
;	O
}	O
for	O
(	O
o	pointer
=	O
n	int
+	O
1	int
;	O
*	O
o	pointer
==	O
' '	O
;	O
o	pointer
++	O
)	O
;	O
n	int
-=	O
3	int
;	O
ne	long
=	O
n	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
bingo	int
)	O
break	O
;	O
}	O
if	O
(	O
nbn	int
!=	O
(	O
ne	long
-	O
n	int
)	O
)	O
continue	O
;	O
if	O
(	O
strncmp	function
(	O
n	int
,	O
bn	pointer
,	O
nbn	int
)	O
)	O
continue	O
;	O
moretodo	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
moretodo	int
&&	O
se	pointer
>	O
s	pointer
)	O
{	O
bufLength	int
=	O
se	pointer
-	O
s	pointer
-	O
1	int
;	O
if	O
(	O
s	pointer
!=	O
ftpBuf	pointer
)	O
memmove	function
(	O
ftpBuf	pointer
,	O
s	pointer
,	O
bufLength	int
)	O
;	O
}	O
else	O
{	O
bufLength	int
=	O
0	int
;	O
}	O
}	O
while	O
(	O
moretodo	int
)	O
;	O
switch	O
(	O
ftpSysCall	enum
)	O
{	O
case	O
DO_FTP_STAT	int
:	O
if	O
(	O
o	pointer
&&	O
oe	pointer
)	O
{	O
}	O
case	O
DO_FTP_LSTAT	int
:	O
if	O
(	O
st	pointer
==	O
NULL	O
||	O
!	O
(	O
n	int
&&	O
ne	long
)	O
)	O
{	O
rc	long
=	O
-	O
1	int
;	O
}	O
else	O
{	O
rc	long
=	O
(	O
(	O
vfs_parse_ls_lga	function
(	O
s	pointer
,	O
st	pointer
,	O
NULL	O
,	O
NULL	O
)	O
>	O
0	int
)	O
?	O
0	int
:	O
-	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
DO_FTP_READLINK	int
:	O
if	O
(	O
rlbuf	pointer
==	O
NULL	O
||	O
!	O
(	O
o	pointer
&&	O
oe	pointer
)	O
)	O
{	O
rc	long
=	O
-	O
1	int
;	O
}	O
else	O
{	O
rc	long
=	O
oe	pointer
-	O
o	pointer
;	O
if	O
(	O
rc	long
>	O
rlbufsiz	long
)	O
rc	long
=	O
rlbufsiz	long
;	O
memcpy	function
(	O
rlbuf	pointer
,	O
o	pointer
,	O
rc	long
)	O
;	O
if	O
(	O
rc	long
<	O
rlbufsiz	long
)	O
rlbuf	pointer
[	O
rc	long
]	O
=	O
'\0'	O
;	O
}	O
break	O
;	O
case	O
DO_FTP_ACCESS	int
:	O
rc	long
=	O
0	int
;	O
break	O
;	O
case	O
DO_FTP_GLOB	int
:	O
rc	long
=	O
0	int
;	O
break	O
;	O
}	O
exit	function
:	O
ufdClose	function
(	O
fd	pointer
)	O
;	O
return	O
rc	long
;	O
}	O
static	O
int	O
ftpStat	function
(	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
return	O
ftpNLST	function
(	O
path	pointer
,	O
DO_FTP_STAT	int
,	O
st	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
static	O
int	O
ftpLstat	function
(	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
int	O
rc	long
;	O
rc	long
=	O
ftpNLST	function
(	O
path	pointer
,	O
DO_FTP_LSTAT	int
,	O
st	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** ftpLstat(%s) rc %d\n"	pointer
,	O
path	pointer
,	O
rc	long
)	O
;	O
return	O
rc	long
;	O
}	O
static	O
int	O
ftpReadlink	function
(	O
const	O
char	O
*	O
path	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
bufsiz	long
)	O
{	O
return	O
ftpNLST	function
(	O
path	pointer
,	O
DO_FTP_READLINK	int
,	O
NULL	O
,	O
buf	pointer
,	O
bufsiz	long
)	O
;	O
}	O
static	O
void	O
ftpGlobfree	function
(	O
glob_t	struct
*	O
pglob	pointer
)	O
{	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** ftpGlobfree(%p)\n"	pointer
,	O
pglob	pointer
)	O
;	O
if	O
(	O
pglob	pointer
->	O
gl_offs	long
==	O
-	O
1	int
)	O
xfree	O
(	O
pglob	pointer
->	O
gl_pathv	pointer
)	O
;	O
}	O
int	O
Stat	function
(	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
const	O
char	O
*	O
lpath	pointer
;	O
int	O
ut	int
=	O
urlPath	function
(	O
path	pointer
,	O
&	O
lpath	pointer
)	O
;	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Stat(%s,%p)\n"	pointer
,	O
path	pointer
,	O
st	pointer
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
return	O
ftpStat	function
(	O
path	pointer
,	O
st	pointer
)	O
;	O
break	O
;	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
path	pointer
=	O
lpath	pointer
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
stat	struct
(	O
path	pointer
,	O
st	pointer
)	O
;	O
}	O
int	O
Lstat	function
(	O
const	O
char	O
*	O
path	pointer
,	O
struct	O
stat	struct
*	O
st	pointer
)	O
{	O
const	O
char	O
*	O
lpath	pointer
;	O
int	O
ut	int
=	O
urlPath	function
(	O
path	pointer
,	O
&	O
lpath	pointer
)	O
;	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Lstat(%s,%p)\n"	pointer
,	O
path	pointer
,	O
st	pointer
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
return	O
ftpLstat	function
(	O
path	pointer
,	O
st	pointer
)	O
;	O
break	O
;	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
path	pointer
=	O
lpath	pointer
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
lstat	function
(	O
path	pointer
,	O
st	pointer
)	O
;	O
}	O
int	O
Readlink	function
(	O
const	O
char	O
*	O
path	pointer
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
bufsiz	long
)	O
{	O
const	O
char	O
*	O
lpath	pointer
;	O
int	O
ut	int
=	O
urlPath	function
(	O
path	pointer
,	O
&	O
lpath	pointer
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
return	O
ftpReadlink	function
(	O
path	pointer
,	O
buf	pointer
,	O
bufsiz	long
)	O
;	O
break	O
;	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
path	pointer
=	O
lpath	pointer
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
readlink	function
(	O
path	pointer
,	O
buf	pointer
,	O
bufsiz	long
)	O
;	O
}	O
int	O
Access	function
(	O
const	O
char	O
*	O
path	pointer
,	O
int	O
amode	int
)	O
{	O
const	O
char	O
*	O
lpath	pointer
;	O
int	O
ut	int
=	O
urlPath	function
(	O
path	pointer
,	O
&	O
lpath	pointer
)	O
;	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Access(%s,%d)\n"	pointer
,	O
path	pointer
,	O
amode	int
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
path	pointer
=	O
lpath	pointer
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
access	function
(	O
path	pointer
,	O
amode	int
)	O
;	O
}	O
int	O
Glob	function
(	O
const	O
char	O
*	O
path	pointer
,	O
int	O
flags	int
,	O
int	O
errfunc	function
(	O
const	O
char	O
*	O
epath	pointer
,	O
int	O
eerrno	int
)	O
,	O
glob_t	struct
*	O
pglob	pointer
)	O
{	O
const	O
char	O
*	O
lpath	pointer
;	O
int	O
ut	int
=	O
urlPath	function
(	O
path	pointer
,	O
&	O
lpath	pointer
)	O
;	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Glob(%s,0x%x,%p,%p)\n"	pointer
,	O
path	pointer
,	O
flags	int
,	O
errfunc	function
,	O
pglob	pointer
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"fatal error in rpmio.c:%d\n"	pointer
,	O
__LINE__	O
)	O
;	O
exit	function
(	O
222	int
)	O
;	O
break	O
;	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
path	pointer
=	O
lpath	pointer
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
-	O
2	int
;	O
break	O
;	O
}	O
return	O
glob	function
(	O
path	pointer
,	O
flags	int
,	O
errfunc	function
,	O
pglob	pointer
)	O
;	O
}	O
void	O
Globfree	function
(	O
glob_t	struct
*	O
pglob	pointer
)	O
{	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Globfree(%p)\n"	pointer
,	O
pglob	pointer
)	O
;	O
if	O
(	O
pglob	pointer
->	O
gl_offs	long
==	O
-	O
1	int
)	O
ftpGlobfree	function
(	O
pglob	pointer
)	O
;	O
else	O
globfree	function
(	O
pglob	pointer
)	O
;	O
}	O
DIR	struct
*	O
Opendir	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
const	O
char	O
*	O
lpath	pointer
;	O
int	O
ut	int
=	O
urlPath	function
(	O
path	pointer
,	O
&	O
lpath	pointer
)	O
;	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Opendir(%s)\n"	pointer
,	O
path	pointer
)	O
;	O
switch	O
(	O
ut	int
)	O
{	O
case	O
URL_IS_FTP	int
:	O
case	O
URL_IS_HTTP	int
:	O
case	O
URL_IS_PATH	int
:	O
path	pointer
=	O
lpath	pointer
;	O
case	O
URL_IS_UNKNOWN	int
:	O
break	O
;	O
case	O
URL_IS_DASH	int
:	O
default	O
:	O
return	O
NULL	O
;	O
break	O
;	O
}	O
return	O
opendir	function
(	O
path	pointer
)	O
;	O
}	O
struct	O
dirent	struct
*	O
Readdir	function
(	O
DIR	struct
*	O
dir	pointer
)	O
{	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Readdir(%p)\n"	pointer
,	O
dir	pointer
)	O
;	O
return	O
readdir	function
(	O
dir	pointer
)	O
;	O
}	O
int	O
Closedir	function
(	O
DIR	struct
*	O
dir	pointer
)	O
{	O
if	O
(	O
_rpmio_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** Closedir(%p)\n"	pointer
,	O
dir	pointer
)	O
;	O
return	O
closedir	function
(	O
dir	pointer
)	O
;	O
}	O
static	O
struct	O
FDIO_s	struct
fpio_s	struct
=	O
{	O
ufdRead	function
,	O
ufdWrite	function
,	O
fdSeek	function
,	O
ufdClose	function
,	O
XfdLink	function
,	O
XfdFree	function
,	O
XfdNew	function
,	O
fdFileno	function
,	O
ufdOpen	function
,	O
NULL	O
,	O
fdGetFp	function
,	O
NULL	O
,	O
Mkdir	function
,	O
Chdir	function
,	O
Rmdir	function
,	O
Rename	function
,	O
Unlink	function
}	O
;	O
FDIO_t	pointer
fpio	pointer
=	O
&	O
fpio_s	struct
;	O
