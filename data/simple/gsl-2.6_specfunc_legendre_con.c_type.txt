static	O
int	O
conicalP_negmu_xlt1_CF1	function
(	O
const	O
double	O
mu	double
,	O
const	O
int	O
ell	int
,	O
const	O
double	O
tau	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
double	O
RECUR_BIG	double
=	O
GSL_SQRT_DBL_MAX	int
;	O
const	O
int	O
maxiter	int
=	O
5000	int
;	O
int	O
n	int
=	O
1	int
;	O
double	O
xi	double
=	O
x	double
/	O
(	O
sqrt	function
(	O
1.0	int
-	O
x	double
)	O
*	O
sqrt	function
(	O
1.0	int
+	O
x	double
)	O
)	O
;	O
double	O
Anm2	double
=	O
1.0	int
;	O
double	O
Bnm2	double
=	O
0.0	int
;	O
double	O
Anm1	double
=	O
0.0	int
;	O
double	O
Bnm1	double
=	O
1.0	int
;	O
double	O
a1	double
=	O
1.0	int
;	O
double	O
b1	double
=	O
2.0	int
*	O
(	O
mu	double
+	O
ell	int
+	O
1.0	int
)	O
*	O
xi	double
;	O
double	O
An	double
=	O
b1	double
*	O
Anm1	double
+	O
a1	double
*	O
Anm2	double
;	O
double	O
Bn	double
=	O
b1	double
*	O
Bnm1	double
+	O
a1	double
*	O
Bnm2	double
;	O
double	O
an	double
,	O
bn	double
;	O
double	O
fn	double
=	O
An	double
/	O
Bn	double
;	O
while	O
(	O
n	int
<	O
maxiter	int
)	O
{	O
double	O
old_fn	double
;	O
double	O
del	double
;	O
n	int
++	O
;	O
Anm2	double
=	O
Anm1	double
;	O
Bnm2	double
=	O
Bnm1	double
;	O
Anm1	double
=	O
An	double
;	O
Bnm1	double
=	O
Bn	double
;	O
an	double
=	O
tau	double
*	O
tau	double
+	O
(	O
mu	double
-	O
0.5	int
+	O
ell	int
+	O
n	int
)	O
*	O
(	O
mu	double
-	O
0.5	int
+	O
ell	int
+	O
n	int
)	O
;	O
bn	double
=	O
2.0	int
*	O
(	O
ell	int
+	O
mu	double
+	O
n	int
)	O
*	O
xi	double
;	O
An	double
=	O
bn	double
*	O
Anm1	double
+	O
an	double
*	O
Anm2	double
;	O
Bn	double
=	O
bn	double
*	O
Bnm1	double
+	O
an	double
*	O
Bnm2	double
;	O
if	O
(	O
fabs	function
(	O
An	double
)	O
>	O
RECUR_BIG	double
||	O
fabs	function
(	O
Bn	double
)	O
>	O
RECUR_BIG	double
)	O
{	O
An	double
/=	O
RECUR_BIG	double
;	O
Bn	double
/=	O
RECUR_BIG	double
;	O
Anm1	double
/=	O
RECUR_BIG	double
;	O
Bnm1	double
/=	O
RECUR_BIG	double
;	O
Anm2	double
/=	O
RECUR_BIG	double
;	O
Bnm2	double
/=	O
RECUR_BIG	double
;	O
}	O
old_fn	double
=	O
fn	double
;	O
fn	double
=	O
An	double
/	O
Bn	double
;	O
del	double
=	O
old_fn	double
/	O
fn	double
;	O
if	O
(	O
fabs	function
(	O
del	double
-	O
1.0	int
)	O
<	O
2.0	int
*	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
result	pointer
->	O
val	double
=	O
fn	double
;	O
result	pointer
->	O
err	double
=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
sqrt	function
(	O
n	int
)	O
+	O
1.0	int
)	O
*	O
fabs	function
(	O
fn	double
)	O
;	O
if	O
(	O
n	int
>=	O
maxiter	int
)	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
conicalP_negmu_xgt1_CF1	function
(	O
const	O
double	O
mu	double
,	O
const	O
int	O
ell	int
,	O
const	O
double	O
tau	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
int	O
maxk	int
=	O
20000	int
;	O
const	O
double	O
gamma	function
=	O
1.0	int
-	O
1.0	int
/	O
(	O
x	double
*	O
x	double
)	O
;	O
const	O
double	O
pre	double
=	O
sqrt	function
(	O
x	double
-	O
1.0	int
)	O
*	O
sqrt	function
(	O
x	double
+	O
1.0	int
)	O
/	O
(	O
x	double
*	O
(	O
2.0	int
*	O
(	O
ell	int
+	O
mu	double
+	O
1.0	int
)	O
)	O
)	O
;	O
double	O
tk	double
=	O
1.0	int
;	O
double	O
sum	double
=	O
1.0	int
;	O
double	O
rhok	double
=	O
0.0	int
;	O
int	O
k	double
;	O
for	O
(	O
k	double
=	O
1	int
;	O
k	double
<	O
maxk	int
;	O
k	double
++	O
)	O
{	O
double	O
tlk	double
=	O
2.0	int
*	O
(	O
ell	int
+	O
mu	double
+	O
k	double
)	O
;	O
double	O
l1k	double
=	O
(	O
ell	int
+	O
mu	double
-	O
0.5	int
+	O
1.0	int
+	O
k	double
)	O
;	O
double	O
ak	double
=	O
-	O
(	O
tau	double
*	O
tau	double
+	O
l1k	double
*	O
l1k	double
)	O
/	O
(	O
tlk	double
*	O
(	O
tlk	double
+	O
2.0	int
)	O
)	O
*	O
gamma	function
;	O
rhok	double
=	O
-	O
ak	double
*	O
(	O
1.0	int
+	O
rhok	double
)	O
/	O
(	O
1.0	int
+	O
ak	double
*	O
(	O
1.0	int
+	O
rhok	double
)	O
)	O
;	O
tk	double
*=	O
rhok	double
;	O
sum	double
+=	O
tk	double
;	O
if	O
(	O
fabs	function
(	O
tk	double
/	O
sum	double
)	O
<	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
}	O
result	pointer
->	O
val	double
=	O
pre	double
*	O
sum	double
;	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
pre	double
*	O
tk	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
sqrt	function
(	O
k	double
)	O
+	O
1.0	int
)	O
*	O
fabs	function
(	O
pre	double
*	O
sum	double
)	O
;	O
if	O
(	O
k	double
>=	O
maxk	int
)	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
inline	O
static	O
double	O
olver_U1	function
(	O
double	O
beta2	double
,	O
double	O
p	double
)	O
{	O
return	O
(	O
p	double
-	O
1.0	int
)	O
/	O
(	O
24.0	int
*	O
(	O
1.0	int
+	O
beta2	double
)	O
)	O
*	O
(	O
3.0	int
+	O
beta2	double
*	O
(	O
2.0	int
+	O
5.0	int
*	O
p	double
*	O
(	O
1.0	int
+	O
p	double
)	O
)	O
)	O
;	O
}	O
inline	O
static	O
double	O
olver_U2	function
(	O
double	O
beta2	double
,	O
double	O
p	double
)	O
{	O
double	O
beta4	double
=	O
beta2	double
*	O
beta2	double
;	O
double	O
p2	double
=	O
p	double
*	O
p	double
;	O
double	O
poly1	double
=	O
4.0	int
*	O
beta4	double
+	O
84.0	int
*	O
beta2	double
-	O
63.0	int
;	O
double	O
poly2	double
=	O
16.0	int
*	O
beta4	double
+	O
90.0	int
*	O
beta2	double
-	O
81.0	int
;	O
double	O
poly3	double
=	O
beta2	double
*	O
p2	double
*	O
(	O
97.0	int
*	O
beta2	double
-	O
432.0	int
+	O
77.0	int
*	O
p	double
*	O
(	O
beta2	double
-	O
6.0	int
)	O
-	O
385.0	int
*	O
beta2	double
*	O
p2	double
*	O
(	O
1.0	int
+	O
p	double
)	O
)	O
;	O
return	O
(	O
1.0	int
-	O
p	double
)	O
/	O
(	O
1152.0	int
*	O
(	O
1.0	int
+	O
beta2	double
)	O
)	O
*	O
(	O
poly1	double
+	O
poly2	double
+	O
poly3	double
)	O
;	O
}	O
static	O
const	O
double	O
U3c1	array
[	O
]	O
=	O
{	O
-	O
1307.0	int
,	O
-	O
1647.0	int
,	O
3375.0	int
,	O
3675.0	int
}	O
;	O
static	O
const	O
double	O
U3c2	array
[	O
]	O
=	O
{	O
29366.0	int
,	O
35835.0	int
,	O
-	O
252360.0	int
,	O
-	O
272630.0	int
,	O
276810.0	int
,	O
290499.0	int
}	O
;	O
static	O
const	O
double	O
U3c3	array
[	O
]	O
=	O
{	O
-	O
29748.0	int
,	O
-	O
8840.0	int
,	O
1725295.0	int
,	O
1767025.0	int
,	O
-	O
7313470.0	int
,	O
-	O
754778.0	int
,	O
6309875.0	int
,	O
6480045.0	int
}	O
;	O
static	O
const	O
double	O
U3c4	array
[	O
]	O
=	O
{	O
2696.0	int
,	O
-	O
16740.0	int
,	O
-	O
524250.0	int
,	O
-	O
183975.0	int
,	O
14670540.0	int
,	O
14172939.0	int
,	O
-	O
48206730.0	int
,	O
-	O
48461985.0	int
,	O
36756720.0	int
,	O
37182145.0	int
}	O
;	O
static	O
const	O
double	O
U3c5	array
[	O
]	O
=	O
{	O
9136.0	int
,	O
22480.0	int
,	O
12760.0	int
,	O
-	O
252480.0	int
,	O
-	O
4662165.0	int
,	O
-	O
1705341.0	int
,	O
92370135.0	int
,	O
86244015.0	int
,	O
-	O
263678415.0	int
,	O
-	O
260275015.0	int
,	O
185910725.0	int
,	O
185910725.0	int
}	O
;	O
int	O
gsl_sf_conicalP_xlt1_large_neg_mu_e	function
(	O
double	O
mu	double
,	O
double	O
tau	double
,	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
,	O
double	O
*	O
ln_multiplier	pointer
)	O
{	O
double	O
beta	double
=	O
tau	double
/	O
mu	double
;	O
double	O
beta2	double
=	O
beta	double
*	O
beta	double
;	O
double	O
S	double
=	O
beta	double
*	O
acos	function
(	O
(	O
1.0	int
-	O
beta2	double
)	O
/	O
(	O
1.0	int
+	O
beta2	double
)	O
)	O
;	O
double	O
p	double
=	O
x	double
/	O
sqrt	function
(	O
beta2	double
*	O
(	O
1.0	int
-	O
x	double
*	O
x	double
)	O
+	O
1.0	int
)	O
;	O
gsl_sf_result	struct
lg_mup1	struct
;	O
int	O
lg_stat	int
=	O
gsl_sf_lngamma_e	function
(	O
mu	double
+	O
1.0	int
,	O
&	O
lg_mup1	struct
)	O
;	O
double	O
ln_pre_1	double
=	O
0.5	int
*	O
mu	double
*	O
(	O
S	double
-	O
log	function
(	O
1.0	int
+	O
beta2	double
)	O
+	O
log	function
(	O
(	O
1.0	int
-	O
p	double
)	O
/	O
(	O
1.0	int
+	O
p	double
)	O
)	O
)	O
-	O
lg_mup1	struct
.	O
val	double
;	O
double	O
ln_pre_2	double
=	O
-	O
0.25	int
*	O
log	function
(	O
1.0	int
+	O
beta2	double
*	O
(	O
1.0	int
-	O
x	double
)	O
)	O
;	O
double	O
ln_pre_3	double
=	O
-	O
tau	double
*	O
atan	function
(	O
p	double
*	O
beta	double
)	O
;	O
double	O
ln_pre	double
=	O
ln_pre_1	double
+	O
ln_pre_2	double
+	O
ln_pre_3	double
;	O
double	O
sum	double
=	O
1.0	int
-	O
olver_U1	function
(	O
beta2	double
,	O
p	double
)	O
/	O
mu	double
+	O
olver_U2	function
(	O
beta2	double
,	O
p	double
)	O
/	O
(	O
mu	double
*	O
mu	double
)	O
;	O
if	O
(	O
sum	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
*	O
ln_multiplier	pointer
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_e	function
(	O
ln_pre	double
,	O
sum	double
,	O
result	pointer
)	O
;	O
if	O
(	O
stat_e	int
!=	O
GSL_SUCCESS	int
)	O
{	O
result	pointer
->	O
val	double
=	O
sum	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
sum	double
)	O
;	O
*	O
ln_multiplier	pointer
=	O
ln_pre	double
;	O
}	O
else	O
{	O
*	O
ln_multiplier	pointer
=	O
0.0	int
;	O
}	O
return	O
lg_stat	int
;	O
}	O
}	O
inline	O
static	O
double	O
olver_B0_xi	function
(	O
double	O
mu	double
,	O
double	O
xi	double
)	O
{	O
return	O
(	O
1.0	int
-	O
4.0	int
*	O
mu	double
*	O
mu	double
)	O
/	O
(	O
8.0	int
*	O
xi	double
)	O
*	O
(	O
1.0	int
/	O
tanh	function
(	O
xi	double
)	O
-	O
1.0	int
/	O
xi	double
)	O
;	O
}	O
static	O
double	O
olver_A1_xi	function
(	O
double	O
mu	double
,	O
double	O
xi	double
,	O
double	O
x	double
)	O
{	O
double	O
B	double
=	O
olver_B0_xi	function
(	O
mu	double
,	O
xi	double
)	O
;	O
double	O
psi	double
;	O
if	O
(	O
fabs	function
(	O
x	double
-	O
1.0	int
)	O
<	O
GSL_ROOT4_DBL_EPSILON	int
)	O
{	O
double	O
y	double
=	O
x	double
-	O
1.0	int
;	O
double	O
s	int
=	O
-	O
1.0	int
/	O
3.0	int
+	O
y	double
*	O
(	O
2.0	int
/	O
15.0	int
-	O
y	double
*	O
(	O
61.0	int
/	O
945.0	int
-	O
452.0	int
/	O
14175.0	int
*	O
y	double
)	O
)	O
;	O
psi	double
=	O
(	O
4.0	int
*	O
mu	double
*	O
mu	double
-	O
1.0	int
)	O
/	O
16.0	int
*	O
s	int
;	O
}	O
else	O
{	O
psi	double
=	O
(	O
4.0	int
*	O
mu	double
*	O
mu	double
-	O
1.0	int
)	O
/	O
16.0	int
*	O
(	O
1.0	int
/	O
(	O
x	double
*	O
x	double
-	O
1.0	int
)	O
-	O
1.0	int
/	O
(	O
xi	double
*	O
xi	double
)	O
)	O
;	O
}	O
return	O
0.5	int
*	O
xi	double
*	O
xi	double
*	O
B	double
*	O
B	double
+	O
(	O
mu	double
+	O
0.5	int
)	O
*	O
B	double
-	O
psi	double
+	O
mu	double
/	O
6.0	int
*	O
(	O
0.25	int
-	O
mu	double
*	O
mu	double
)	O
;	O
}	O
inline	O
static	O
double	O
olver_B0_th	function
(	O
double	O
mu	double
,	O
double	O
theta	double
)	O
{	O
return	O
-	O
(	O
1.0	int
-	O
4.0	int
*	O
mu	double
*	O
mu	double
)	O
/	O
(	O
8.0	int
*	O
theta	double
)	O
*	O
(	O
1.0	int
/	O
tan	function
(	O
theta	double
)	O
-	O
1.0	int
/	O
theta	double
)	O
;	O
}	O
static	O
double	O
olver_A1_th	function
(	O
double	O
mu	double
,	O
double	O
theta	double
,	O
double	O
x	double
)	O
{	O
double	O
B	double
=	O
olver_B0_th	function
(	O
mu	double
,	O
theta	double
)	O
;	O
double	O
psi	double
;	O
if	O
(	O
fabs	function
(	O
x	double
-	O
1.0	int
)	O
<	O
GSL_ROOT4_DBL_EPSILON	int
)	O
{	O
double	O
y	double
=	O
1.0	int
-	O
x	double
;	O
double	O
s	int
=	O
-	O
1.0	int
/	O
3.0	int
+	O
y	double
*	O
(	O
2.0	int
/	O
15.0	int
-	O
y	double
*	O
(	O
61.0	int
/	O
945.0	int
-	O
452.0	int
/	O
14175.0	int
*	O
y	double
)	O
)	O
;	O
psi	double
=	O
(	O
4.0	int
*	O
mu	double
*	O
mu	double
-	O
1.0	int
)	O
/	O
16.0	int
*	O
s	int
;	O
}	O
else	O
{	O
psi	double
=	O
(	O
4.0	int
*	O
mu	double
*	O
mu	double
-	O
1.0	int
)	O
/	O
16.0	int
*	O
(	O
1.0	int
/	O
(	O
x	double
*	O
x	double
-	O
1.0	int
)	O
+	O
1.0	int
/	O
(	O
theta	double
*	O
theta	double
)	O
)	O
;	O
}	O
return	O
-	O
0.5	int
*	O
theta	double
*	O
theta	double
*	O
B	double
*	O
B	double
+	O
(	O
mu	double
+	O
0.5	int
)	O
*	O
B	double
-	O
psi	double
+	O
mu	double
/	O
6.0	int
*	O
(	O
0.25	int
-	O
mu	double
*	O
mu	double
)	O
;	O
}	O
int	O
gsl_sf_conicalP_xgt1_neg_mu_largetau_e	function
(	O
const	O
double	O
mu	double
,	O
const	O
double	O
tau	double
,	O
const	O
double	O
x	double
,	O
double	O
acosh_x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
,	O
double	O
*	O
ln_multiplier	pointer
)	O
{	O
double	O
xi	double
=	O
acosh_x	double
;	O
double	O
ln_xi_pre	double
;	O
double	O
ln_pre	double
;	O
double	O
sumA	double
,	O
sumB	double
,	O
sum	double
;	O
double	O
arg	pointer
;	O
gsl_sf_result	struct
J_mup1	struct
;	O
gsl_sf_result	struct
J_mu	struct
;	O
double	O
J_mum1	double
;	O
if	O
(	O
xi	double
<	O
GSL_ROOT4_DBL_EPSILON	int
)	O
{	O
ln_xi_pre	double
=	O
-	O
xi	double
*	O
xi	double
/	O
6.0	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct
lnshxi	struct
;	O
gsl_sf_lnsinh_e	function
(	O
xi	double
,	O
&	O
lnshxi	struct
)	O
;	O
ln_xi_pre	double
=	O
log	function
(	O
xi	double
)	O
-	O
lnshxi	struct
.	O
val	double
;	O
}	O
ln_pre	double
=	O
0.5	int
*	O
ln_xi_pre	double
-	O
mu	double
*	O
log	function
(	O
tau	double
)	O
;	O
arg	pointer
=	O
tau	double
*	O
xi	double
;	O
gsl_sf_bessel_Jnu_e	function
(	O
mu	double
+	O
1.0	int
,	O
arg	pointer
,	O
&	O
J_mup1	struct
)	O
;	O
gsl_sf_bessel_Jnu_e	function
(	O
mu	double
,	O
arg	pointer
,	O
&	O
J_mu	struct
)	O
;	O
J_mum1	double
=	O
-	O
J_mup1	struct
.	O
val	double
+	O
2.0	int
*	O
mu	double
/	O
arg	pointer
*	O
J_mu	struct
.	O
val	double
;	O
sumA	double
=	O
1.0	int
-	O
olver_A1_xi	function
(	O
-	O
mu	double
,	O
xi	double
,	O
x	double
)	O
/	O
(	O
tau	double
*	O
tau	double
)	O
;	O
sumB	double
=	O
olver_B0_xi	function
(	O
-	O
mu	double
,	O
xi	double
)	O
;	O
sum	double
=	O
J_mu	struct
.	O
val	double
*	O
sumA	double
-	O
xi	double
/	O
tau	double
*	O
J_mum1	double
*	O
sumB	double
;	O
if	O
(	O
sum	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
*	O
ln_multiplier	pointer
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_e	function
(	O
ln_pre	double
,	O
sum	double
,	O
result	pointer
)	O
;	O
if	O
(	O
stat_e	int
!=	O
GSL_SUCCESS	int
)	O
{	O
result	pointer
->	O
val	double
=	O
sum	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
sum	double
)	O
;	O
*	O
ln_multiplier	pointer
=	O
ln_pre	double
;	O
}	O
else	O
{	O
*	O
ln_multiplier	pointer
=	O
0.0	int
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_conicalP_xlt1_neg_mu_largetau_e	function
(	O
const	O
double	O
mu	double
,	O
const	O
double	O
tau	double
,	O
const	O
double	O
x	double
,	O
const	O
double	O
acos_x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
,	O
double	O
*	O
ln_multiplier	pointer
)	O
{	O
double	O
theta	double
=	O
acos_x	double
;	O
double	O
ln_th_pre	double
;	O
double	O
ln_pre	double
;	O
double	O
sumA	double
,	O
sumB	double
,	O
sum	double
,	O
sumerr	double
;	O
double	O
arg	pointer
;	O
gsl_sf_result	struct
I_mup1	struct
,	O
I_mu	struct
;	O
double	O
I_mum1	double
;	O
if	O
(	O
theta	double
<	O
GSL_ROOT4_DBL_EPSILON	int
)	O
{	O
ln_th_pre	double
=	O
theta	double
*	O
theta	double
/	O
6.0	int
;	O
}	O
else	O
{	O
ln_th_pre	double
=	O
log	function
(	O
theta	double
/	O
sin	function
(	O
theta	double
)	O
)	O
;	O
}	O
ln_pre	double
=	O
0.5	int
*	O
ln_th_pre	double
-	O
mu	double
*	O
log	function
(	O
tau	double
)	O
;	O
arg	pointer
=	O
tau	double
*	O
theta	double
;	O
gsl_sf_bessel_Inu_e	function
(	O
mu	double
+	O
1.0	int
,	O
arg	pointer
,	O
&	O
I_mup1	struct
)	O
;	O
gsl_sf_bessel_Inu_e	function
(	O
mu	double
,	O
arg	pointer
,	O
&	O
I_mu	struct
)	O
;	O
I_mum1	double
=	O
I_mup1	struct
.	O
val	double
+	O
2.0	int
*	O
mu	double
/	O
arg	pointer
*	O
I_mu	struct
.	O
val	double
;	O
sumA	double
=	O
1.0	int
-	O
olver_A1_th	function
(	O
-	O
mu	double
,	O
theta	double
,	O
x	double
)	O
/	O
(	O
tau	double
*	O
tau	double
)	O
;	O
sumB	double
=	O
olver_B0_th	function
(	O
-	O
mu	double
,	O
theta	double
)	O
;	O
sum	double
=	O
I_mu	struct
.	O
val	double
*	O
sumA	double
-	O
theta	double
/	O
tau	double
*	O
I_mum1	double
*	O
sumB	double
;	O
sumerr	double
=	O
fabs	function
(	O
I_mu	struct
.	O
err	double
*	O
sumA	double
)	O
;	O
sumerr	double
+=	O
fabs	function
(	O
I_mup1	struct
.	O
err	double
*	O
theta	double
/	O
tau	double
*	O
sumB	double
)	O
;	O
sumerr	double
+=	O
fabs	function
(	O
I_mu	struct
.	O
err	double
*	O
theta	double
/	O
tau	double
*	O
sumB	double
*	O
2.0	int
*	O
mu	double
/	O
arg	pointer
)	O
;	O
if	O
(	O
sum	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
*	O
ln_multiplier	pointer
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_e	function
(	O
ln_pre	double
,	O
sum	double
,	O
result	pointer
)	O
;	O
if	O
(	O
stat_e	int
!=	O
GSL_SUCCESS	int
)	O
{	O
result	pointer
->	O
val	double
=	O
sum	double
;	O
result	pointer
->	O
err	double
=	O
sumerr	double
;	O
result	pointer
->	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
sum	double
)	O
;	O
*	O
ln_multiplier	pointer
=	O
ln_pre	double
;	O
}	O
else	O
{	O
*	O
ln_multiplier	pointer
=	O
0.0	int
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
static	O
int	O
conicalP_hyperg_large_x	function
(	O
const	O
double	O
mu	double
,	O
const	O
double	O
tau	double
,	O
const	O
double	O
y	double
,	O
double	O
*	O
reF	pointer
,	O
double	O
*	O
imF	pointer
)	O
{	O
const	O
int	O
kmax	int
=	O
1000	int
;	O
const	O
double	O
re_a	double
=	O
0.25	int
-	O
0.5	int
*	O
mu	double
;	O
const	O
double	O
re_b	double
=	O
0.75	int
-	O
0.5	int
*	O
mu	double
;	O
const	O
double	O
re_c	double
=	O
1.0	int
;	O
const	O
double	O
im_a	double
=	O
-	O
0.5	int
*	O
tau	double
;	O
const	O
double	O
im_b	double
=	O
-	O
0.5	int
*	O
tau	double
;	O
const	O
double	O
im_c	double
=	O
-	O
tau	double
;	O
double	O
re_sum	double
=	O
1.0	int
;	O
double	O
im_sum	double
=	O
0.0	int
;	O
double	O
re_term	double
=	O
1.0	int
;	O
double	O
im_term	double
=	O
0.0	int
;	O
int	O
k	double
;	O
for	O
(	O
k	double
=	O
1	int
;	O
k	double
<=	O
kmax	int
;	O
k	double
++	O
)	O
{	O
double	O
re_ak	double
=	O
re_a	double
+	O
k	double
-	O
1.0	int
;	O
double	O
re_bk	double
=	O
re_b	double
+	O
k	double
-	O
1.0	int
;	O
double	O
re_ck	double
=	O
re_c	double
+	O
k	double
-	O
1.0	int
;	O
double	O
im_ak	double
=	O
im_a	double
;	O
double	O
im_bk	double
=	O
im_b	double
;	O
double	O
im_ck	double
=	O
im_c	double
;	O
double	O
den	double
=	O
re_ck	double
*	O
re_ck	double
+	O
im_ck	double
*	O
im_ck	double
;	O
double	O
re_multiplier	double
=	O
(	O
(	O
re_ak	double
*	O
re_bk	double
-	O
im_ak	double
*	O
im_bk	double
)	O
*	O
re_ck	double
+	O
im_ck	double
*	O
(	O
im_ak	double
*	O
re_bk	double
+	O
re_ak	double
*	O
im_bk	double
)	O
)	O
/	O
den	double
;	O
double	O
im_multiplier	double
=	O
(	O
(	O
im_ak	double
*	O
re_bk	double
+	O
re_ak	double
*	O
im_bk	double
)	O
*	O
re_ck	double
-	O
im_ck	double
*	O
(	O
re_ak	double
*	O
re_bk	double
-	O
im_ak	double
*	O
im_bk	double
)	O
)	O
/	O
den	double
;	O
double	O
re_tmp	double
=	O
re_multiplier	double
*	O
re_term	double
-	O
im_multiplier	double
*	O
im_term	double
;	O
double	O
im_tmp	double
=	O
im_multiplier	double
*	O
re_term	double
+	O
re_multiplier	double
*	O
im_term	double
;	O
double	O
asum	double
=	O
fabs	function
(	O
re_sum	double
)	O
+	O
fabs	function
(	O
im_sum	double
)	O
;	O
re_term	double
=	O
y	double
/	O
k	double
*	O
re_tmp	double
;	O
im_term	double
=	O
y	double
/	O
k	double
*	O
im_tmp	double
;	O
if	O
(	O
fabs	function
(	O
re_term	double
/	O
asum	double
)	O
<	O
GSL_DBL_EPSILON	int
&&	O
fabs	function
(	O
im_term	double
/	O
asum	double
)	O
<	O
GSL_DBL_EPSILON	int
)	O
break	O
;	O
re_sum	double
+=	O
re_term	double
;	O
im_sum	double
+=	O
im_term	double
;	O
}	O
*	O
reF	pointer
=	O
re_sum	double
;	O
*	O
imF	pointer
=	O
im_sum	double
;	O
if	O
(	O
k	double
==	O
kmax	int
)	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EMAXITER	int
)	O
;	O
else	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_conicalP_large_x_e	function
(	O
const	O
double	O
mu	double
,	O
const	O
double	O
tau	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
,	O
double	O
*	O
ln_multiplier	pointer
)	O
{	O
double	O
y	double
=	O
(	O
x	double
<	O
0.5	int
*	O
GSL_SQRT_DBL_MAX	int
?	O
1.0	int
/	O
(	O
x	double
*	O
x	double
)	O
:	O
0.0	int
)	O
;	O
double	O
reF	pointer
,	O
imF	pointer
;	O
int	O
stat_F	int
=	O
conicalP_hyperg_large_x	function
(	O
mu	double
,	O
tau	double
,	O
y	double
,	O
&	O
reF	pointer
,	O
&	O
imF	pointer
)	O
;	O
gsl_sf_result	struct
lgr_num	struct
,	O
lgth_num	struct
;	O
gsl_sf_result	struct
lgr_den	struct
,	O
lgth_den	struct
;	O
int	O
stat_gn	int
=	O
gsl_sf_lngamma_complex_e	function
(	O
0.0	int
,	O
tau	double
,	O
&	O
lgr_num	struct
,	O
&	O
lgth_num	struct
)	O
;	O
int	O
stat_gd	int
=	O
gsl_sf_lngamma_complex_e	function
(	O
0.5	int
-	O
mu	double
,	O
tau	double
,	O
&	O
lgr_den	struct
,	O
&	O
lgth_den	struct
)	O
;	O
double	O
angle	double
=	O
lgth_num	struct
.	O
val	double
-	O
lgth_den	struct
.	O
val	double
+	O
atan2	function
(	O
imF	pointer
,	O
reF	pointer
)	O
;	O
double	O
lnx	double
=	O
log	function
(	O
x	double
)	O
;	O
double	O
lnxp1	double
=	O
log	function
(	O
x	double
+	O
1.0	int
)	O
;	O
double	O
lnxm1	double
=	O
log	function
(	O
x	double
-	O
1.0	int
)	O
;	O
double	O
lnpre_const	double
=	O
0.5	int
*	O
M_LN2	int
-	O
0.5	int
*	O
M_LNPI	int
;	O
double	O
lnpre_comm	double
=	O
(	O
mu	double
-	O
0.5	int
)	O
*	O
lnx	double
-	O
0.5	int
*	O
mu	double
*	O
(	O
lnxp1	double
+	O
lnxm1	double
)	O
;	O
double	O
lnpre_err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
0.5	int
*	O
M_LN2	int
+	O
0.5	int
*	O
M_LNPI	int
)	O
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
(	O
mu	double
-	O
0.5	int
)	O
*	O
lnx	double
)	O
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
0.5	int
*	O
mu	double
)	O
*	O
(	O
fabs	function
(	O
lnxp1	double
)	O
+	O
fabs	function
(	O
lnxm1	double
)	O
)	O
;	O
gsl_sf_result	struct
cos_result	struct
;	O
int	O
stat_cos	int
=	O
gsl_sf_cos_e	function
(	O
angle	double
+	O
tau	double
*	O
(	O
log	function
(	O
x	double
)	O
+	O
M_LN2	int
)	O
,	O
&	O
cos_result	struct
)	O
;	O
int	O
status	int
=	O
GSL_ERROR_SELECT_4	O
(	O
stat_cos	int
,	O
stat_gd	int
,	O
stat_gn	int
,	O
stat_F	int
)	O
;	O
if	O
(	O
cos_result	struct
.	O
val	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
status	int
;	O
}	O
else	O
{	O
double	O
lnFf_val	double
=	O
0.5	int
*	O
log	function
(	O
reF	pointer
*	O
reF	pointer
+	O
imF	pointer
*	O
imF	pointer
)	O
+	O
lgr_num	struct
.	O
val	double
-	O
lgr_den	struct
.	O
val	double
;	O
double	O
lnFf_err	double
=	O
lgr_num	struct
.	O
err	double
+	O
lgr_den	struct
.	O
err	double
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
lnFf_val	double
)	O
;	O
double	O
lnnoc_val	double
=	O
lnpre_const	double
+	O
lnpre_comm	double
+	O
lnFf_val	double
;	O
double	O
lnnoc_err	double
=	O
lnpre_err	double
+	O
lnFf_err	double
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
lnnoc_val	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	function
(	O
lnnoc_val	double
,	O
lnnoc_err	double
,	O
cos_result	struct
.	O
val	double
,	O
cos_result	struct
.	O
err	double
,	O
result	pointer
)	O
;	O
if	O
(	O
stat_e	int
==	O
GSL_SUCCESS	int
)	O
{	O
*	O
ln_multiplier	pointer
=	O
0.0	int
;	O
}	O
else	O
{	O
result	pointer
->	O
val	double
=	O
cos_result	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
cos_result	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
*	O
ln_multiplier	pointer
=	O
lnnoc_val	double
;	O
}	O
return	O
status	int
;	O
}	O
}	O
static	O
int	O
conicalP_xlt1_hyperg_A	function
(	O
double	O
mu	double
,	O
double	O
tau	double
,	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
double	O
x2	double
=	O
x	double
*	O
x	double
;	O
double	O
err_amp	double
=	O
1.0	int
+	O
1.0	int
/	O
(	O
GSL_DBL_EPSILON	int
+	O
fabs	function
(	O
1.0	int
-	O
fabs	function
(	O
x	double
)	O
)	O
)	O
;	O
double	O
pre_val	double
=	O
M_SQRTPI	int
/	O
pow	function
(	O
0.5	int
*	O
sqrt	function
(	O
1	int
-	O
x2	double
)	O
,	O
mu	double
)	O
;	O
double	O
pre_err	double
=	O
err_amp	double
*	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
mu	double
)	O
+	O
1.0	int
)	O
*	O
fabs	function
(	O
pre_val	double
)	O
;	O
gsl_sf_result	struct
ln_g1	struct
,	O
ln_g2	struct
,	O
arg_g1	struct
,	O
arg_g2	struct
;	O
gsl_sf_result	struct
F1	struct
,	O
F2	struct
;	O
gsl_sf_result	struct
pre1	struct
,	O
pre2	struct
;	O
double	O
t1_val	double
,	O
t1_err	double
;	O
double	O
t2_val	double
,	O
t2_err	double
;	O
int	O
stat_F1	int
=	O
gsl_sf_hyperg_2F1_conj_e	function
(	O
0.25	int
-	O
0.5	int
*	O
mu	double
,	O
0.5	int
*	O
tau	double
,	O
0.5	int
,	O
x2	double
,	O
&	O
F1	struct
)	O
;	O
int	O
stat_F2	int
=	O
gsl_sf_hyperg_2F1_conj_e	function
(	O
0.75	int
-	O
0.5	int
*	O
mu	double
,	O
0.5	int
*	O
tau	double
,	O
1.5	int
,	O
x2	double
,	O
&	O
F2	struct
)	O
;	O
int	O
status	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_F1	int
,	O
stat_F2	int
)	O
;	O
gsl_sf_lngamma_complex_e	function
(	O
0.75	int
-	O
0.5	int
*	O
mu	double
,	O
-	O
0.5	int
*	O
tau	double
,	O
&	O
ln_g1	struct
,	O
&	O
arg_g1	struct
)	O
;	O
gsl_sf_lngamma_complex_e	function
(	O
0.25	int
-	O
0.5	int
*	O
mu	double
,	O
-	O
0.5	int
*	O
tau	double
,	O
&	O
ln_g2	struct
,	O
&	O
arg_g2	struct
)	O
;	O
gsl_sf_exp_err_e	function
(	O
-	O
2.0	int
*	O
ln_g1	struct
.	O
val	double
,	O
2.0	int
*	O
ln_g1	struct
.	O
err	double
,	O
&	O
pre1	struct
)	O
;	O
gsl_sf_exp_err_e	function
(	O
-	O
2.0	int
*	O
ln_g2	struct
.	O
val	double
,	O
2.0	int
*	O
ln_g2	struct
.	O
err	double
,	O
&	O
pre2	struct
)	O
;	O
pre2	struct
.	O
val	double
*=	O
-	O
2.0	int
*	O
x	double
;	O
pre2	struct
.	O
err	double
*=	O
2.0	int
*	O
fabs	function
(	O
x	double
)	O
;	O
pre2	struct
.	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
pre2	struct
.	O
val	double
)	O
;	O
t1_val	double
=	O
pre1	struct
.	O
val	double
*	O
F1	struct
.	O
val	double
;	O
t1_err	double
=	O
fabs	function
(	O
pre1	struct
.	O
val	double
)	O
*	O
F1	struct
.	O
err	double
+	O
pre1	struct
.	O
err	double
*	O
fabs	function
(	O
F1	struct
.	O
val	double
)	O
;	O
t2_val	double
=	O
pre2	struct
.	O
val	double
*	O
F2	struct
.	O
val	double
;	O
t2_err	double
=	O
fabs	function
(	O
pre2	struct
.	O
val	double
)	O
*	O
F2	struct
.	O
err	double
+	O
pre2	struct
.	O
err	double
*	O
fabs	function
(	O
F2	struct
.	O
val	double
)	O
;	O
result	pointer
->	O
val	double
=	O
pre_val	double
*	O
(	O
t1_val	double
+	O
t2_val	double
)	O
;	O
result	pointer
->	O
err	double
=	O
pre_val	double
*	O
(	O
t1_err	double
+	O
t2_err	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
pre_err	double
*	O
fabs	function
(	O
t1_val	double
+	O
t2_val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
conicalP_0_V	function
(	O
const	O
double	O
t	double
,	O
const	O
double	O
f	pointer
,	O
const	O
double	O
tau	double
,	O
const	O
double	O
sgn	pointer
,	O
double	O
*	O
V0	pointer
,	O
double	O
*	O
V1	pointer
)	O
{	O
double	O
C	array
[	O
8	int
]	O
;	O
double	O
T	array
[	O
8	int
]	O
;	O
double	O
H	array
[	O
8	int
]	O
;	O
double	O
V	array
[	O
12	int
]	O
;	O
int	O
i	int
;	O
T	array
[	O
0	int
]	O
=	O
1.0	int
;	O
H	array
[	O
0	int
]	O
=	O
1.0	int
;	O
V	array
[	O
0	int
]	O
=	O
1.0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
7	int
;	O
i	int
++	O
)	O
{	O
T	array
[	O
i	int
]	O
=	O
T	array
[	O
i	int
-	O
1	int
]	O
*	O
t	double
;	O
H	array
[	O
i	int
]	O
=	O
H	array
[	O
i	int
-	O
1	int
]	O
*	O
(	O
t	double
*	O
f	pointer
)	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
11	int
;	O
i	int
++	O
)	O
{	O
V	array
[	O
i	int
]	O
=	O
V	array
[	O
i	int
-	O
1	int
]	O
*	O
tau	double
;	O
}	O
C	array
[	O
0	int
]	O
=	O
1.0	int
;	O
C	array
[	O
1	int
]	O
=	O
(	O
H	array
[	O
1	int
]	O
-	O
1.0	int
)	O
/	O
(	O
8.0	int
*	O
T	array
[	O
1	int
]	O
)	O
;	O
C	array
[	O
2	int
]	O
=	O
(	O
9.0	int
*	O
H	array
[	O
2	int
]	O
+	O
6.0	int
*	O
H	array
[	O
1	int
]	O
-	O
15.0	int
-	O
sgn	pointer
*	O
8.0	int
*	O
T	array
[	O
2	int
]	O
)	O
/	O
(	O
128.0	int
*	O
T	array
[	O
2	int
]	O
)	O
;	O
C	array
[	O
3	int
]	O
=	O
5.0	int
*	O
(	O
15.0	int
*	O
H	array
[	O
3	int
]	O
+	O
27.0	int
*	O
H	array
[	O
2	int
]	O
+	O
21.0	int
*	O
H	array
[	O
1	int
]	O
-	O
63.0	int
-	O
sgn	pointer
*	O
T	array
[	O
2	int
]	O
*	O
(	O
16.0	int
*	O
H	array
[	O
1	int
]	O
+	O
24.0	int
)	O
)	O
/	O
(	O
1024.0	int
*	O
T	array
[	O
3	int
]	O
)	O
;	O
C	array
[	O
4	int
]	O
=	O
7.0	int
*	O
(	O
525.0	int
*	O
H	array
[	O
4	int
]	O
+	O
1500.0	int
*	O
H	array
[	O
3	int
]	O
+	O
2430.0	int
*	O
H	array
[	O
2	int
]	O
+	O
1980.0	int
*	O
H	array
[	O
1	int
]	O
-	O
6435.0	int
+	O
192.0	int
*	O
T	array
[	O
4	int
]	O
-	O
sgn	pointer
*	O
T	array
[	O
2	int
]	O
*	O
(	O
720.0	int
*	O
H	array
[	O
2	int
]	O
+	O
1600.0	int
*	O
H	array
[	O
1	int
]	O
+	O
2160.0	int
)	O
)	O
/	O
(	O
32768.0	int
*	O
T	array
[	O
4	int
]	O
)	O
;	O
C	array
[	O
5	int
]	O
=	O
21.0	int
*	O
(	O
2835.0	int
*	O
H	array
[	O
5	int
]	O
+	O
11025.0	int
*	O
H	array
[	O
4	int
]	O
+	O
24750.0	int
*	O
H	array
[	O
3	int
]	O
+	O
38610.0	int
*	O
H	array
[	O
2	int
]	O
+	O
32175.0	int
*	O
H	array
[	O
1	int
]	O
-	O
109395.0	int
+	O
T	array
[	O
4	int
]	O
*	O
(	O
1984.0	int
*	O
H	array
[	O
1	int
]	O
+	O
4032.0	int
)	O
-	O
sgn	pointer
*	O
T	array
[	O
2	int
]	O
*	O
(	O
4800.0	int
*	O
H	array
[	O
3	int
]	O
+	O
15120.0	int
*	O
H	array
[	O
2	int
]	O
+	O
26400.0	int
*	O
H	array
[	O
1	int
]	O
+	O
34320.0	int
)	O
)	O
/	O
(	O
262144.0	int
*	O
T	array
[	O
5	int
]	O
)	O
;	O
C	array
[	O
6	int
]	O
=	O
11.0	int
*	O
(	O
218295.0	int
*	O
H	array
[	O
6	int
]	O
+	O
1071630.0	int
*	O
H	array
[	O
5	int
]	O
+	O
3009825.0	int
*	O
H	array
[	O
4	int
]	O
+	O
6142500.0	int
*	O
H	array
[	O
3	int
]	O
+	O
9398025.0	int
*	O
H	array
[	O
2	int
]	O
+	O
7936110.0	int
*	O
H	array
[	O
1	int
]	O
-	O
27776385.0	int
+	O
T	array
[	O
4	int
]	O
*	O
(	O
254016.0	int
*	O
H	array
[	O
2	int
]	O
+	O
749952.0	int
*	O
H	array
[	O
1	int
]	O
+	O
1100736.0	int
)	O
-	O
sgn	pointer
*	O
T	array
[	O
2	int
]	O
*	O
(	O
441000.0	int
*	O
H	array
[	O
4	int
]	O
+	O
1814400.0	int
*	O
H	array
[	O
3	int
]	O
+	O
4127760.0	int
*	O
H	array
[	O
2	int
]	O
+	O
6552000.0	int
*	O
H	array
[	O
1	int
]	O
+	O
8353800.0	int
+	O
31232.0	int
*	O
T	array
[	O
4	int
]	O
)	O
)	O
/	O
(	O
4194304.0	int
*	O
T	array
[	O
6	int
]	O
)	O
;	O
*	O
V0	pointer
=	O
C	array
[	O
0	int
]	O
+	O
(	O
-	O
4.0	int
*	O
C	array
[	O
3	int
]	O
/	O
T	array
[	O
1	int
]	O
+	O
C	array
[	O
4	int
]	O
)	O
/	O
V	array
[	O
4	int
]	O
+	O
(	O
-	O
192.0	int
*	O
C	array
[	O
5	int
]	O
/	O
T	array
[	O
3	int
]	O
+	O
144.0	int
*	O
C	array
[	O
6	int
]	O
/	O
T	array
[	O
2	int
]	O
)	O
/	O
V	array
[	O
8	int
]	O
+	O
sgn	pointer
*	O
(	O
-	O
C	array
[	O
2	int
]	O
/	O
V	array
[	O
2	int
]	O
+	O
(	O
-	O
24.0	int
*	O
C	array
[	O
4	int
]	O
/	O
T	array
[	O
2	int
]	O
+	O
12.0	int
*	O
C	array
[	O
5	int
]	O
/	O
T	array
[	O
1	int
]	O
-	O
C	array
[	O
6	int
]	O
)	O
/	O
V	array
[	O
6	int
]	O
+	O
(	O
-	O
1920.0	int
*	O
C	array
[	O
6	int
]	O
/	O
T	array
[	O
4	int
]	O
)	O
/	O
V	array
[	O
10	int
]	O
)	O
;	O
*	O
V1	pointer
=	O
C	array
[	O
1	int
]	O
/	O
V	array
[	O
1	int
]	O
+	O
(	O
8.0	int
*	O
(	O
C	array
[	O
3	int
]	O
/	O
T	array
[	O
2	int
]	O
-	O
C	array
[	O
4	int
]	O
/	O
T	array
[	O
1	int
]	O
)	O
+	O
C	array
[	O
5	int
]	O
)	O
/	O
V	array
[	O
5	int
]	O
+	O
(	O
384.0	int
*	O
C	array
[	O
5	int
]	O
/	O
T	array
[	O
4	int
]	O
-	O
768.0	int
*	O
C	array
[	O
6	int
]	O
/	O
T	array
[	O
3	int
]	O
)	O
/	O
V	array
[	O
9	int
]	O
+	O
sgn	pointer
*	O
(	O
(	O
2.0	int
*	O
C	array
[	O
2	int
]	O
/	O
T	array
[	O
1	int
]	O
-	O
C	array
[	O
3	int
]	O
)	O
/	O
V	array
[	O
3	int
]	O
+	O
(	O
48.0	int
*	O
C	array
[	O
4	int
]	O
/	O
T	array
[	O
3	int
]	O
-	O
72.0	int
*	O
C	array
[	O
5	int
]	O
/	O
T	array
[	O
2	int
]	O
+	O
18.0	int
*	O
C	array
[	O
6	int
]	O
/	O
T	array
[	O
1	int
]	O
)	O
/	O
V	array
[	O
7	int
]	O
+	O
(	O
3840.0	int
*	O
C	array
[	O
6	int
]	O
/	O
T	array
[	O
5	int
]	O
)	O
/	O
V	array
[	O
11	int
]	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
conicalP_1_V	function
(	O
const	O
double	O
t	double
,	O
const	O
double	O
f	pointer
,	O
const	O
double	O
tau	double
,	O
const	O
double	O
sgn	pointer
,	O
double	O
*	O
V0	pointer
,	O
double	O
*	O
V1	pointer
)	O
{	O
double	O
Cm1	double
;	O
double	O
C	array
[	O
8	int
]	O
;	O
double	O
T	array
[	O
8	int
]	O
;	O
double	O
H	array
[	O
8	int
]	O
;	O
double	O
V	array
[	O
12	int
]	O
;	O
int	O
i	int
;	O
T	array
[	O
0	int
]	O
=	O
1.0	int
;	O
H	array
[	O
0	int
]	O
=	O
1.0	int
;	O
V	array
[	O
0	int
]	O
=	O
1.0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
7	int
;	O
i	int
++	O
)	O
{	O
T	array
[	O
i	int
]	O
=	O
T	array
[	O
i	int
-	O
1	int
]	O
*	O
t	double
;	O
H	array
[	O
i	int
]	O
=	O
H	array
[	O
i	int
-	O
1	int
]	O
*	O
(	O
t	double
*	O
f	pointer
)	O
;	O
}	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<=	O
11	int
;	O
i	int
++	O
)	O
{	O
V	array
[	O
i	int
]	O
=	O
V	array
[	O
i	int
-	O
1	int
]	O
*	O
tau	double
;	O
}	O
Cm1	double
=	O
-	O
1.0	int
;	O
C	array
[	O
0	int
]	O
=	O
3.0	int
*	O
(	O
1.0	int
-	O
H	array
[	O
1	int
]	O
)	O
/	O
(	O
8.0	int
*	O
T	array
[	O
1	int
]	O
)	O
;	O
C	array
[	O
1	int
]	O
=	O
(	O
-	O
15.0	int
*	O
H	array
[	O
2	int
]	O
+	O
6.0	int
*	O
H	array
[	O
1	int
]	O
+	O
9.0	int
+	O
sgn	pointer
*	O
8.0	int
*	O
T	array
[	O
2	int
]	O
)	O
/	O
(	O
128.0	int
*	O
T	array
[	O
2	int
]	O
)	O
;	O
C	array
[	O
2	int
]	O
=	O
3.0	int
*	O
(	O
-	O
35.0	int
*	O
H	array
[	O
3	int
]	O
-	O
15.0	int
*	O
H	array
[	O
2	int
]	O
+	O
15.0	int
*	O
H	array
[	O
1	int
]	O
+	O
35.0	int
+	O
sgn	pointer
*	O
T	array
[	O
2	int
]	O
*	O
(	O
32.0	int
*	O
H	array
[	O
1	int
]	O
+	O
8.0	int
)	O
)	O
/	O
(	O
1024.0	int
*	O
T	array
[	O
3	int
]	O
)	O
;	O
C	array
[	O
3	int
]	O
=	O
(	O
-	O
4725.0	int
*	O
H	array
[	O
4	int
]	O
-	O
6300.0	int
*	O
H	array
[	O
3	int
]	O
-	O
3150.0	int
*	O
H	array
[	O
2	int
]	O
+	O
3780.0	int
*	O
H	array
[	O
1	int
]	O
+	O
10395.0	int
-	O
1216.0	int
*	O
T	array
[	O
4	int
]	O
+	O
sgn	pointer
*	O
T	array
[	O
2	int
]	O
*	O
(	O
6000.0	int
*	O
H	array
[	O
2	int
]	O
+	O
5760.0	int
*	O
H	array
[	O
1	int
]	O
+	O
1680.0	int
)	O
)	O
/	O
(	O
32768.0	int
*	O
T	array
[	O
4	int
]	O
)	O
;	O
C	array
[	O
4	int
]	O
=	O
7.0	int
*	O
(	O
-	O
10395.0	int
*	O
H	array
[	O
5	int
]	O
-	O
23625.0	int
*	O
H	array
[	O
4	int
]	O
-	O
28350.0	int
*	O
H	array
[	O
3	int
]	O
-	O
14850.0	int
*	O
H	array
[	O
2	int
]	O
+	O
19305.0	int
*	O
H	array
[	O
1	int
]	O
+	O
57915.0	int
-	O
T	array
[	O
4	int
]	O
*	O
(	O
6336.0	int
*	O
H	array
[	O
1	int
]	O
+	O
6080.0	int
)	O
+	O
sgn	pointer
*	O
T	array
[	O
2	int
]	O
*	O
(	O
16800.0	int
*	O
H	array
[	O
3	int
]	O
+	O
30000.0	int
*	O
H	array
[	O
2	int
]	O
+	O
25920.0	int
*	O
H	array
[	O
1	int
]	O
+	O
7920.0	int
)	O
)	O
/	O
(	O
262144.0	int
*	O
T	array
[	O
5	int
]	O
)	O
;	O
C	array
[	O
5	int
]	O
=	O
(	O
-	O
2837835.0	int
*	O
H	array
[	O
6	int
]	O
-	O
9168390.0	int
*	O
H	array
[	O
5	int
]	O
-	O
16372125.0	int
*	O
H	array
[	O
4	int
]	O
-	O
18918900	int
*	O
H	array
[	O
3	int
]	O
-	O
10135125.0	int
*	O
H	array
[	O
2	int
]	O
+	O
13783770.0	int
*	O
H	array
[	O
1	int
]	O
+	O
43648605.0	int
-	O
T	array
[	O
4	int
]	O
*	O
(	O
3044160.0	int
*	O
H	array
[	O
2	int
]	O
+	O
5588352.0	int
*	O
H	array
[	O
1	int
]	O
+	O
4213440.0	int
)	O
+	O
sgn	pointer
*	O
T	array
[	O
2	int
]	O
*	O
(	O
5556600.0	int
*	O
H	array
[	O
4	int
]	O
+	O
14817600.0	int
*	O
H	array
[	O
3	int
]	O
+	O
20790000.0	int
*	O
H	array
[	O
2	int
]	O
+	O
17297280.0	int
*	O
H	array
[	O
1	int
]	O
+	O
5405400.0	int
+	O
323072.0	int
*	O
T	array
[	O
4	int
]	O
)	O
)	O
/	O
(	O
4194304.0	int
*	O
T	array
[	O
6	int
]	O
)	O
;	O
C	array
[	O
6	int
]	O
=	O
0.0	int
;	O
*	O
V0	pointer
=	O
C	array
[	O
0	int
]	O
+	O
(	O
-	O
4.0	int
*	O
C	array
[	O
3	int
]	O
/	O
T	array
[	O
1	int
]	O
+	O
C	array
[	O
4	int
]	O
)	O
/	O
V	array
[	O
4	int
]	O
+	O
(	O
-	O
192.0	int
*	O
C	array
[	O
5	int
]	O
/	O
T	array
[	O
3	int
]	O
+	O
144.0	int
*	O
C	array
[	O
6	int
]	O
/	O
T	array
[	O
2	int
]	O
)	O
/	O
V	array
[	O
8	int
]	O
+	O
sgn	pointer
*	O
(	O
-	O
C	array
[	O
2	int
]	O
/	O
V	array
[	O
2	int
]	O
+	O
(	O
-	O
24.0	int
*	O
C	array
[	O
4	int
]	O
/	O
T	array
[	O
2	int
]	O
+	O
12.0	int
*	O
C	array
[	O
5	int
]	O
/	O
T	array
[	O
1	int
]	O
-	O
C	array
[	O
6	int
]	O
)	O
/	O
V	array
[	O
6	int
]	O
)	O
;	O
*	O
V1	pointer
=	O
C	array
[	O
1	int
]	O
/	O
V	array
[	O
1	int
]	O
+	O
(	O
8.0	int
*	O
(	O
C	array
[	O
3	int
]	O
/	O
T	array
[	O
2	int
]	O
-	O
C	array
[	O
4	int
]	O
/	O
T	array
[	O
1	int
]	O
)	O
+	O
C	array
[	O
5	int
]	O
)	O
/	O
V	array
[	O
5	int
]	O
+	O
(	O
384.0	int
*	O
C	array
[	O
5	int
]	O
/	O
T	array
[	O
4	int
]	O
-	O
768.0	int
*	O
C	array
[	O
6	int
]	O
/	O
T	array
[	O
3	int
]	O
)	O
/	O
V	array
[	O
9	int
]	O
+	O
sgn	pointer
*	O
(	O
Cm1	double
*	O
V	array
[	O
1	int
]	O
+	O
(	O
2.0	int
*	O
C	array
[	O
2	int
]	O
/	O
T	array
[	O
1	int
]	O
-	O
C	array
[	O
3	int
]	O
)	O
/	O
V	array
[	O
3	int
]	O
+	O
(	O
48.0	int
*	O
C	array
[	O
4	int
]	O
/	O
T	array
[	O
3	int
]	O
-	O
72.0	int
*	O
C	array
[	O
5	int
]	O
/	O
T	array
[	O
2	int
]	O
+	O
18.0	int
*	O
C	array
[	O
6	int
]	O
/	O
T	array
[	O
1	int
]	O
)	O
/	O
V	array
[	O
7	int
]	O
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_conicalP_0_e	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
x	double
<=	O
-	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
1.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
1.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
lambda	double
==	O
0.0	int
)	O
{	O
gsl_sf_result	struct
K	struct
;	O
int	O
stat_K	int
;	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
const	O
double	O
th	double
=	O
acos	function
(	O
x	double
)	O
;	O
const	O
double	O
s	int
=	O
sin	function
(	O
0.5	int
*	O
th	double
)	O
;	O
stat_K	int
=	O
gsl_sf_ellint_Kcomp_e	function
(	O
s	int
,	O
GSL_MODE_DEFAULT	int
,	O
&	O
K	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
2.0	int
/	O
M_PI	int
*	O
K	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
/	O
M_PI	int
*	O
K	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_K	int
;	O
}	O
else	O
{	O
const	O
double	O
xi	double
=	O
acosh	function
(	O
x	double
)	O
;	O
const	O
double	O
c	array
=	O
cosh	function
(	O
0.5	int
*	O
xi	double
)	O
;	O
const	O
double	O
t	double
=	O
tanh	function
(	O
0.5	int
*	O
xi	double
)	O
;	O
stat_K	int
=	O
gsl_sf_ellint_Kcomp_e	function
(	O
t	double
,	O
GSL_MODE_DEFAULT	int
,	O
&	O
K	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
2.0	int
/	O
M_PI	int
/	O
c	array
*	O
K	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
/	O
M_PI	int
/	O
c	array
*	O
K	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_K	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
x	double
<=	O
0.0	int
&&	O
lambda	double
<	O
1000.0	int
)	O
||	O
(	O
x	double
<	O
0.1	int
&&	O
lambda	double
<	O
17.0	int
)	O
||	O
(	O
x	double
<	O
0.2	int
&&	O
lambda	double
<	O
5.0	int
)	O
)	O
{	O
return	O
conicalP_xlt1_hyperg_A	function
(	O
0.0	int
,	O
lambda	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
x	double
<=	O
0.2	int
&&	O
lambda	double
<	O
17.0	int
)	O
||	O
(	O
x	double
<=	O
1.5	int
&&	O
lambda	double
<	O
20.0	int
)	O
)	O
{	O
return	O
gsl_sf_hyperg_2F1_conj_e	function
(	O
0.5	int
,	O
lambda	double
,	O
1.0	int
,	O
(	O
1.0	int
-	O
x	double
)	O
/	O
2	int
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
1.5	int
<	O
x	double
&&	O
lambda	double
<	O
GSL_MAX	O
(	O
x	double
,	O
20.0	int
)	O
)	O
{	O
gsl_sf_result	struct
P	struct
;	O
double	O
lm	double
;	O
int	O
stat_P	int
=	O
gsl_sf_conicalP_large_x_e	function
(	O
0.0	int
,	O
lambda	double
,	O
x	double
,	O
&	O
P	struct
,	O
&	O
lm	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	function
(	O
lm	double
,	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
lm	double
)	O
,	O
P	struct
.	O
val	double
,	O
P	struct
.	O
err	double
,	O
result	pointer
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_P	int
)	O
;	O
}	O
else	O
{	O
double	O
V0	pointer
,	O
V1	pointer
;	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
double	O
th	double
=	O
acos	function
(	O
x	double
)	O
;	O
double	O
sth	double
=	O
sqrt	function
(	O
1.0	int
-	O
x	double
*	O
x	double
)	O
;	O
gsl_sf_result	struct
I0	struct
,	O
I1	struct
;	O
int	O
stat_I0	int
=	O
gsl_sf_bessel_I0_scaled_e	function
(	O
th	double
*	O
lambda	double
,	O
&	O
I0	struct
)	O
;	O
int	O
stat_I1	int
=	O
gsl_sf_bessel_I1_scaled_e	function
(	O
th	double
*	O
lambda	double
,	O
&	O
I1	struct
)	O
;	O
int	O
stat_I	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_I0	int
,	O
stat_I1	int
)	O
;	O
int	O
stat_V	int
=	O
conicalP_0_V	function
(	O
th	double
,	O
x	double
/	O
sth	double
,	O
lambda	double
,	O
-	O
1.0	int
,	O
&	O
V0	pointer
,	O
&	O
V1	pointer
)	O
;	O
double	O
bessterm	double
=	O
V0	pointer
*	O
I0	struct
.	O
val	double
+	O
V1	pointer
*	O
I1	struct
.	O
val	double
;	O
double	O
besserr	double
=	O
fabs	function
(	O
V0	pointer
)	O
*	O
I0	struct
.	O
err	double
+	O
fabs	function
(	O
V1	pointer
)	O
*	O
I1	struct
.	O
err	double
;	O
double	O
arg1	double
=	O
th	double
*	O
lambda	double
;	O
double	O
sqts	double
=	O
sqrt	function
(	O
th	double
/	O
sth	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	function
(	O
arg1	double
,	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
arg1	double
)	O
,	O
sqts	double
*	O
bessterm	double
,	O
sqts	double
*	O
besserr	double
,	O
result	pointer
)	O
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_V	int
,	O
stat_I	int
)	O
;	O
}	O
else	O
{	O
double	O
sh	double
=	O
sqrt	function
(	O
x	double
-	O
1.0	int
)	O
*	O
sqrt	function
(	O
x	double
+	O
1.0	int
)	O
;	O
double	O
xi	double
=	O
log	function
(	O
x	double
+	O
sh	double
)	O
;	O
gsl_sf_result	struct
J0	struct
,	O
J1	struct
;	O
int	O
stat_J0	int
=	O
gsl_sf_bessel_J0_e	function
(	O
xi	double
*	O
lambda	double
,	O
&	O
J0	struct
)	O
;	O
int	O
stat_J1	int
=	O
gsl_sf_bessel_J1_e	function
(	O
xi	double
*	O
lambda	double
,	O
&	O
J1	struct
)	O
;	O
int	O
stat_J	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_J0	int
,	O
stat_J1	int
)	O
;	O
int	O
stat_V	int
=	O
conicalP_0_V	function
(	O
xi	double
,	O
x	double
/	O
sh	double
,	O
lambda	double
,	O
1.0	int
,	O
&	O
V0	pointer
,	O
&	O
V1	pointer
)	O
;	O
double	O
bessterm	double
=	O
V0	pointer
*	O
J0	struct
.	O
val	double
+	O
V1	pointer
*	O
J1	struct
.	O
val	double
;	O
double	O
besserr	double
=	O
fabs	function
(	O
V0	pointer
)	O
*	O
J0	struct
.	O
err	double
+	O
fabs	function
(	O
V1	pointer
)	O
*	O
J1	struct
.	O
err	double
;	O
double	O
pre_val	double
=	O
sqrt	function
(	O
xi	double
/	O
sh	double
)	O
;	O
double	O
pre_err	double
=	O
2.0	int
*	O
fabs	function
(	O
pre_val	double
)	O
;	O
result	pointer
->	O
val	double
=	O
pre_val	double
*	O
bessterm	double
;	O
result	pointer
->	O
err	double
=	O
pre_val	double
*	O
besserr	double
;	O
result	pointer
->	O
err	double
+=	O
pre_err	double
*	O
fabs	function
(	O
bessterm	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_V	int
,	O
stat_J	int
)	O
;	O
}	O
}	O
}	O
int	O
gsl_sf_conicalP_1_e	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
x	double
<=	O
-	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
lambda	double
==	O
0.0	int
)	O
{	O
gsl_sf_result	struct
K	struct
,	O
E	struct
;	O
int	O
stat_K	int
,	O
stat_E	int
;	O
if	O
(	O
x	double
==	O
1.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
if	O
(	O
1.0	int
-	O
x	double
<	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
double	O
err_amp	double
=	O
GSL_MAX_DBL	function
(	O
1.0	int
,	O
1.0	int
/	O
(	O
GSL_DBL_EPSILON	int
+	O
fabs	function
(	O
1.0	int
-	O
x	double
)	O
)	O
)	O
;	O
result	pointer
->	O
val	double
=	O
0.25	int
/	O
M_SQRT2	int
*	O
sqrt	function
(	O
1.0	int
-	O
x	double
)	O
*	O
(	O
1.0	int
+	O
5.0	int
/	O
16.0	int
*	O
(	O
1.0	int
-	O
x	double
)	O
)	O
;	O
result	pointer
->	O
err	double
=	O
err_amp	double
*	O
3.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
th	double
=	O
acos	function
(	O
x	double
)	O
;	O
const	O
double	O
s	int
=	O
sin	function
(	O
0.5	int
*	O
th	double
)	O
;	O
const	O
double	O
c2	double
=	O
1.0	int
-	O
s	int
*	O
s	int
;	O
const	O
double	O
sth	double
=	O
sin	function
(	O
th	double
)	O
;	O
const	O
double	O
pre	double
=	O
2.0	int
/	O
(	O
M_PI	int
*	O
sth	double
)	O
;	O
stat_K	int
=	O
gsl_sf_ellint_Kcomp_e	function
(	O
s	int
,	O
GSL_MODE_DEFAULT	int
,	O
&	O
K	struct
)	O
;	O
stat_E	int
=	O
gsl_sf_ellint_Ecomp_e	function
(	O
s	int
,	O
GSL_MODE_DEFAULT	int
,	O
&	O
E	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
pre	double
*	O
(	O
E	struct
.	O
val	double
-	O
c2	double
*	O
K	struct
.	O
val	double
)	O
;	O
result	pointer
->	O
err	double
=	O
pre	double
*	O
(	O
E	struct
.	O
err	double
+	O
fabs	function
(	O
c2	double
)	O
*	O
K	struct
.	O
err	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_K	int
,	O
stat_E	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
x	double
-	O
1.0	int
<	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
double	O
err_amp	double
=	O
GSL_MAX_DBL	function
(	O
1.0	int
,	O
1.0	int
/	O
(	O
GSL_DBL_EPSILON	int
+	O
fabs	function
(	O
1.0	int
-	O
x	double
)	O
)	O
)	O
;	O
result	pointer
->	O
val	double
=	O
-	O
0.25	int
/	O
M_SQRT2	int
*	O
sqrt	function
(	O
x	double
-	O
1.0	int
)	O
*	O
(	O
1.0	int
-	O
5.0	int
/	O
16.0	int
*	O
(	O
x	double
-	O
1.0	int
)	O
)	O
;	O
result	pointer
->	O
err	double
=	O
err_amp	double
*	O
3.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
xi	double
=	O
acosh	function
(	O
x	double
)	O
;	O
const	O
double	O
c	array
=	O
cosh	function
(	O
0.5	int
*	O
xi	double
)	O
;	O
const	O
double	O
t	double
=	O
tanh	function
(	O
0.5	int
*	O
xi	double
)	O
;	O
const	O
double	O
sxi	double
=	O
sinh	function
(	O
xi	double
)	O
;	O
const	O
double	O
pre	double
=	O
2.0	int
/	O
(	O
M_PI	int
*	O
sxi	double
)	O
*	O
c	array
;	O
stat_K	int
=	O
gsl_sf_ellint_Kcomp_e	function
(	O
t	double
,	O
GSL_MODE_DEFAULT	int
,	O
&	O
K	struct
)	O
;	O
stat_E	int
=	O
gsl_sf_ellint_Ecomp_e	function
(	O
t	double
,	O
GSL_MODE_DEFAULT	int
,	O
&	O
E	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
pre	double
*	O
(	O
E	struct
.	O
val	double
-	O
K	struct
.	O
val	double
)	O
;	O
result	pointer
->	O
err	double
=	O
pre	double
*	O
(	O
E	struct
.	O
err	double
+	O
K	struct
.	O
err	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_K	int
,	O
stat_E	int
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
x	double
<=	O
0.0	int
&&	O
lambda	double
<	O
1000.0	int
)	O
||	O
(	O
x	double
<	O
0.1	int
&&	O
lambda	double
<	O
17.0	int
)	O
||	O
(	O
x	double
<	O
0.2	int
&&	O
lambda	double
<	O
5.0	int
)	O
)	O
{	O
return	O
conicalP_xlt1_hyperg_A	function
(	O
1.0	int
,	O
lambda	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
x	double
<=	O
0.2	int
&&	O
lambda	double
<	O
17.0	int
)	O
||	O
(	O
x	double
<	O
1.5	int
&&	O
lambda	double
<	O
20.0	int
)	O
)	O
{	O
const	O
double	O
arg	pointer
=	O
fabs	function
(	O
x	double
*	O
x	double
-	O
1.0	int
)	O
;	O
const	O
double	O
sgn	pointer
=	O
GSL_SIGN	O
(	O
1.0	int
-	O
x	double
)	O
;	O
const	O
double	O
pre	double
=	O
0.5	int
*	O
(	O
lambda	double
*	O
lambda	double
+	O
0.25	int
)	O
*	O
sgn	pointer
*	O
sqrt	function
(	O
arg	pointer
)	O
;	O
gsl_sf_result	struct
F	struct
;	O
int	O
stat_F	int
=	O
gsl_sf_hyperg_2F1_conj_e	function
(	O
1.5	int
,	O
lambda	double
,	O
2.0	int
,	O
(	O
1.0	int
-	O
x	double
)	O
/	O
2	int
,	O
&	O
F	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
pre	double
*	O
F	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
fabs	function
(	O
pre	double
)	O
*	O
F	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_F	int
;	O
}	O
else	O
if	O
(	O
1.5	int
<=	O
x	double
&&	O
lambda	double
<	O
GSL_MAX	O
(	O
x	double
,	O
20.0	int
)	O
)	O
{	O
gsl_sf_result	struct
P	struct
;	O
double	O
lm	double
;	O
int	O
stat_P	int
=	O
gsl_sf_conicalP_large_x_e	function
(	O
1.0	int
,	O
lambda	double
,	O
x	double
,	O
&	O
P	struct
,	O
&	O
lm	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	function
(	O
lm	double
,	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
lm	double
)	O
,	O
P	struct
.	O
val	double
,	O
P	struct
.	O
err	double
,	O
result	pointer
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_e	int
,	O
stat_P	int
)	O
;	O
}	O
else	O
{	O
double	O
V0	pointer
,	O
V1	pointer
;	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
const	O
double	O
sqrt_1mx	double
=	O
sqrt	function
(	O
1.0	int
-	O
x	double
)	O
;	O
const	O
double	O
sqrt_1px	double
=	O
sqrt	function
(	O
1.0	int
+	O
x	double
)	O
;	O
const	O
double	O
th	double
=	O
acos	function
(	O
x	double
)	O
;	O
const	O
double	O
sth	double
=	O
sqrt_1mx	double
*	O
sqrt_1px	double
;	O
gsl_sf_result	struct
I0	struct
,	O
I1	struct
;	O
int	O
stat_I0	int
=	O
gsl_sf_bessel_I0_scaled_e	function
(	O
th	double
*	O
lambda	double
,	O
&	O
I0	struct
)	O
;	O
int	O
stat_I1	int
=	O
gsl_sf_bessel_I1_scaled_e	function
(	O
th	double
*	O
lambda	double
,	O
&	O
I1	struct
)	O
;	O
int	O
stat_I	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_I0	int
,	O
stat_I1	int
)	O
;	O
int	O
stat_V	int
=	O
conicalP_1_V	function
(	O
th	double
,	O
x	double
/	O
sth	double
,	O
lambda	double
,	O
-	O
1.0	int
,	O
&	O
V0	pointer
,	O
&	O
V1	pointer
)	O
;	O
double	O
bessterm	double
=	O
V0	pointer
*	O
I0	struct
.	O
val	double
+	O
V1	pointer
*	O
I1	struct
.	O
val	double
;	O
double	O
besserr	double
=	O
fabs	function
(	O
V0	pointer
)	O
*	O
I0	struct
.	O
err	double
+	O
fabs	function
(	O
V1	pointer
)	O
*	O
I1	struct
.	O
err	double
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
V0	pointer
*	O
I0	struct
.	O
val	double
)	O
+	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
V1	pointer
*	O
I1	struct
.	O
val	double
)	O
;	O
double	O
arg1	double
=	O
th	double
*	O
lambda	double
;	O
double	O
sqts	double
=	O
sqrt	function
(	O
th	double
/	O
sth	double
)	O
;	O
int	O
stat_e	int
=	O
gsl_sf_exp_mult_err_e	function
(	O
arg1	double
,	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
arg1	double
)	O
,	O
sqts	double
*	O
bessterm	double
,	O
sqts	double
*	O
besserr	double
,	O
result	pointer
)	O
;	O
result	pointer
->	O
err	double
*=	O
1.0	int
/	O
sqrt_1mx	double
;	O
return	O
GSL_ERROR_SELECT_3	O
(	O
stat_e	int
,	O
stat_V	int
,	O
stat_I	int
)	O
;	O
}	O
else	O
{	O
const	O
double	O
sqrt_xm1	double
=	O
sqrt	function
(	O
x	double
-	O
1.0	int
)	O
;	O
const	O
double	O
sqrt_xp1	double
=	O
sqrt	function
(	O
x	double
+	O
1.0	int
)	O
;	O
const	O
double	O
sh	double
=	O
sqrt_xm1	double
*	O
sqrt_xp1	double
;	O
const	O
double	O
xi	double
=	O
log	function
(	O
x	double
+	O
sh	double
)	O
;	O
const	O
double	O
xi_lam	double
=	O
xi	double
*	O
lambda	double
;	O
gsl_sf_result	struct
J0	struct
,	O
J1	struct
;	O
const	O
int	O
stat_J0	int
=	O
gsl_sf_bessel_J0_e	function
(	O
xi_lam	double
,	O
&	O
J0	struct
)	O
;	O
const	O
int	O
stat_J1	int
=	O
gsl_sf_bessel_J1_e	function
(	O
xi_lam	double
,	O
&	O
J1	struct
)	O
;	O
const	O
int	O
stat_J	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_J0	int
,	O
stat_J1	int
)	O
;	O
const	O
int	O
stat_V	int
=	O
conicalP_1_V	function
(	O
xi	double
,	O
x	double
/	O
sh	double
,	O
lambda	double
,	O
1.0	int
,	O
&	O
V0	pointer
,	O
&	O
V1	pointer
)	O
;	O
const	O
double	O
bessterm	double
=	O
V0	pointer
*	O
J0	struct
.	O
val	double
+	O
V1	pointer
*	O
J1	struct
.	O
val	double
;	O
const	O
double	O
besserr	double
=	O
fabs	function
(	O
V0	pointer
)	O
*	O
J0	struct
.	O
err	double
+	O
fabs	function
(	O
V1	pointer
)	O
*	O
J1	struct
.	O
err	double
+	O
512.0	int
*	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
V0	pointer
*	O
J0	struct
.	O
val	double
)	O
+	O
512.0	int
*	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
V1	pointer
*	O
J1	struct
.	O
val	double
)	O
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
xi_lam	double
*	O
V0	pointer
*	O
J1	struct
.	O
val	double
)	O
+	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
xi_lam	double
*	O
V1	pointer
*	O
J0	struct
.	O
val	double
)	O
;	O
const	O
double	O
pre	double
=	O
sqrt	function
(	O
xi	double
/	O
sh	double
)	O
;	O
result	pointer
->	O
val	double
=	O
pre	double
*	O
bessterm	double
;	O
result	pointer
->	O
err	double
=	O
pre	double
*	O
besserr	double
*	O
sqrt_xp1	double
/	O
sqrt_xm1	double
;	O
result	pointer
->	O
err	double
+=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_V	int
,	O
stat_J	int
)	O
;	O
}	O
}	O
}	O
int	O
gsl_sf_conicalP_half_e	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
x	double
<=	O
-	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
double	O
err_amp	double
=	O
1.0	int
+	O
1.0	int
/	O
(	O
GSL_DBL_EPSILON	int
+	O
fabs	function
(	O
1.0	int
-	O
fabs	function
(	O
x	double
)	O
)	O
)	O
;	O
double	O
ac	double
=	O
acos	function
(	O
x	double
)	O
;	O
double	O
den	double
=	O
sqrt	function
(	O
sqrt	function
(	O
1.0	int
-	O
x	double
)	O
*	O
sqrt	function
(	O
1.0	int
+	O
x	double
)	O
)	O
;	O
result	pointer
->	O
val	double
=	O
Root_2OverPi_	int
/	O
den	double
*	O
cosh	function
(	O
ac	double
*	O
lambda	double
)	O
;	O
result	pointer
->	O
err	double
=	O
err_amp	double
*	O
3.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
*=	O
fabs	function
(	O
ac	double
*	O
lambda	double
)	O
+	O
1.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
==	O
1.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
err_amp	double
=	O
1.0	int
+	O
1.0	int
/	O
(	O
GSL_DBL_EPSILON	int
+	O
fabs	function
(	O
1.0	int
-	O
fabs	function
(	O
x	double
)	O
)	O
)	O
;	O
double	O
sq_term	double
=	O
sqrt	function
(	O
x	double
-	O
1.0	int
)	O
*	O
sqrt	function
(	O
x	double
+	O
1.0	int
)	O
;	O
double	O
ln_term	double
=	O
log	function
(	O
x	double
+	O
sq_term	double
)	O
;	O
double	O
den	double
=	O
sqrt	function
(	O
sq_term	double
)	O
;	O
double	O
carg_val	double
=	O
lambda	double
*	O
ln_term	double
;	O
double	O
carg_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
carg_val	double
)	O
;	O
gsl_sf_result	struct
cos_result	struct
;	O
int	O
stat_cos	int
=	O
gsl_sf_cos_err_e	function
(	O
carg_val	double
,	O
carg_err	double
,	O
&	O
cos_result	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
Root_2OverPi_	int
/	O
den	double
*	O
cos_result	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
err_amp	double
*	O
Root_2OverPi_	int
/	O
den	double
*	O
cos_result	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_cos	int
;	O
}	O
}	O
int	O
gsl_sf_conicalP_mhalf_e	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
x	double
<=	O
-	O
1.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
double	O
ac	double
=	O
acos	function
(	O
x	double
)	O
;	O
double	O
den	double
=	O
sqrt	function
(	O
sqrt	function
(	O
1.0	int
-	O
x	double
)	O
*	O
sqrt	function
(	O
1.0	int
+	O
x	double
)	O
)	O
;	O
double	O
arg	pointer
=	O
ac	double
*	O
lambda	double
;	O
double	O
err_amp	double
=	O
1.0	int
+	O
1.0	int
/	O
(	O
GSL_DBL_EPSILON	int
+	O
fabs	function
(	O
1.0	int
-	O
fabs	function
(	O
x	double
)	O
)	O
)	O
;	O
if	O
(	O
fabs	function
(	O
arg	pointer
)	O
<	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
result	pointer
->	O
val	double
=	O
Root_2OverPi_	int
/	O
den	double
*	O
ac	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
*=	O
err_amp	double
;	O
}	O
else	O
{	O
result	pointer
->	O
val	double
=	O
Root_2OverPi_	int
/	O
(	O
den	double
*	O
lambda	double
)	O
*	O
sinh	function
(	O
arg	pointer
)	O
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
(	O
fabs	function
(	O
arg	pointer
)	O
+	O
1.0	int
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
*=	O
err_amp	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
==	O
1.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
double	O
sq_term	double
=	O
sqrt	function
(	O
x	double
-	O
1.0	int
)	O
*	O
sqrt	function
(	O
x	double
+	O
1.0	int
)	O
;	O
double	O
ln_term	double
=	O
log	function
(	O
x	double
+	O
sq_term	double
)	O
;	O
double	O
den	double
=	O
sqrt	function
(	O
sq_term	double
)	O
;	O
double	O
arg_val	double
=	O
lambda	double
*	O
ln_term	double
;	O
double	O
arg_err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
arg_val	double
)	O
;	O
if	O
(	O
arg_val	double
<	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
result	pointer
->	O
val	double
=	O
Root_2OverPi_	int
/	O
den	double
*	O
ln_term	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
gsl_sf_result	struct
sin_result	struct
;	O
int	O
stat_sin	int
=	O
gsl_sf_sin_err_e	function
(	O
arg_val	double
,	O
arg_err	double
,	O
&	O
sin_result	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
Root_2OverPi_	int
/	O
(	O
den	double
*	O
lambda	double
)	O
*	O
sin_result	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
Root_2OverPi_	int
/	O
fabs	function
(	O
den	double
*	O
lambda	double
)	O
*	O
sin_result	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
3.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_sin	int
;	O
}	O
}	O
}	O
int	O
gsl_sf_conicalP_sph_reg_e	function
(	O
const	O
int	O
l	int
,	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
x	double
<=	O
-	O
1.0	int
||	O
l	int
<	O
-	O
1	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
l	int
==	O
-	O
1	int
)	O
{	O
return	O
gsl_sf_conicalP_half_e	function
(	O
lambda	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
l	int
==	O
0	int
)	O
{	O
return	O
gsl_sf_conicalP_mhalf_e	function
(	O
lambda	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
1.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
double	O
c	array
=	O
1.0	int
/	O
sqrt	function
(	O
1.0	int
-	O
x	double
*	O
x	double
)	O
;	O
gsl_sf_result	struct
r_Pellm1	struct
;	O
gsl_sf_result	struct
r_Pell	struct
;	O
int	O
stat_0	int
=	O
gsl_sf_conicalP_half_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
r_Pellm1	struct
)	O
;	O
int	O
stat_1	int
=	O
gsl_sf_conicalP_mhalf_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
r_Pell	struct
)	O
;	O
int	O
stat_P	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_0	int
,	O
stat_1	int
)	O
;	O
double	O
Pellm1	double
=	O
r_Pellm1	struct
.	O
val	double
;	O
double	O
Pell	double
=	O
r_Pell	struct
.	O
val	double
;	O
double	O
Pellp1	double
;	O
int	O
ell	int
;	O
for	O
(	O
ell	int
=	O
0	int
;	O
ell	int
<	O
l	int
;	O
ell	int
++	O
)	O
{	O
double	O
d	double
=	O
(	O
ell	int
+	O
1.0	int
)	O
*	O
(	O
ell	int
+	O
1.0	int
)	O
+	O
lambda	double
*	O
lambda	double
;	O
Pellp1	double
=	O
(	O
Pellm1	double
-	O
(	O
2.0	int
*	O
ell	int
+	O
1.0	int
)	O
*	O
c	array
*	O
x	double
*	O
Pell	double
)	O
/	O
d	double
;	O
Pellm1	double
=	O
Pell	double
;	O
Pell	double
=	O
Pellp1	double
;	O
}	O
result	pointer
->	O
val	double
=	O
Pell	double
;	O
result	pointer
->	O
err	double
=	O
(	O
0.5	int
*	O
l	int
+	O
1.0	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
Pell	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
l	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_P	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
const	O
double	O
xi	double
=	O
x	double
/	O
(	O
sqrt	function
(	O
1.0	int
-	O
x	double
)	O
*	O
sqrt	function
(	O
1.0	int
+	O
x	double
)	O
)	O
;	O
gsl_sf_result	struct
rat	struct
;	O
gsl_sf_result	struct
Phf	struct
;	O
int	O
stat_CF1	int
=	O
conicalP_negmu_xlt1_CF1	function
(	O
0.5	int
,	O
l	int
,	O
lambda	double
,	O
x	double
,	O
&	O
rat	struct
)	O
;	O
int	O
stat_Phf	int
=	O
gsl_sf_conicalP_half_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
Phf	struct
)	O
;	O
double	O
Pellp1	double
=	O
rat	struct
.	O
val	double
*	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Pell	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Pellm1	double
;	O
int	O
ell	int
;	O
for	O
(	O
ell	int
=	O
l	int
;	O
ell	int
>=	O
0	int
;	O
ell	int
--	O
)	O
{	O
double	O
d	double
=	O
(	O
ell	int
+	O
1.0	int
)	O
*	O
(	O
ell	int
+	O
1.0	int
)	O
+	O
lambda	double
*	O
lambda	double
;	O
Pellm1	double
=	O
(	O
2.0	int
*	O
ell	int
+	O
1.0	int
)	O
*	O
xi	double
*	O
Pell	double
+	O
d	double
*	O
Pellp1	double
;	O
Pellp1	double
=	O
Pell	double
;	O
Pell	double
=	O
Pellm1	double
;	O
}	O
result	pointer
->	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
Phf	struct
.	O
val	double
/	O
Pell	double
;	O
result	pointer
->	O
err	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
Phf	struct
.	O
err	double
/	O
fabs	function
(	O
Pell	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
fabs	function
(	O
rat	struct
.	O
err	double
/	O
rat	struct
.	O
val	double
)	O
*	O
(	O
l	int
+	O
1.0	int
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_Phf	int
,	O
stat_CF1	int
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
1.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
xi	double
=	O
x	double
/	O
sqrt	function
(	O
(	O
x	double
-	O
1.0	int
)	O
*	O
(	O
x	double
+	O
1.0	int
)	O
)	O
;	O
gsl_sf_result	struct
rat	struct
;	O
int	O
stat_CF1	int
=	O
conicalP_negmu_xgt1_CF1	function
(	O
0.5	int
,	O
l	int
,	O
lambda	double
,	O
x	double
,	O
&	O
rat	struct
)	O
;	O
int	O
stat_P	int
;	O
double	O
Pellp1	double
=	O
rat	struct
.	O
val	double
*	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Pell	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Pellm1	double
;	O
int	O
ell	int
;	O
for	O
(	O
ell	int
=	O
l	int
;	O
ell	int
>=	O
0	int
;	O
ell	int
--	O
)	O
{	O
double	O
d	double
=	O
(	O
ell	int
+	O
1.0	int
)	O
*	O
(	O
ell	int
+	O
1.0	int
)	O
+	O
lambda	double
*	O
lambda	double
;	O
Pellm1	double
=	O
(	O
2.0	int
*	O
ell	int
+	O
1.0	int
)	O
*	O
xi	double
*	O
Pell	double
-	O
d	double
*	O
Pellp1	double
;	O
Pellp1	double
=	O
Pell	double
;	O
Pell	double
=	O
Pellm1	double
;	O
}	O
if	O
(	O
fabs	function
(	O
Pell	double
)	O
>	O
fabs	function
(	O
Pellp1	double
)	O
)	O
{	O
gsl_sf_result	struct
Phf	struct
;	O
stat_P	int
=	O
gsl_sf_conicalP_half_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
Phf	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
Phf	struct
.	O
val	double
/	O
Pell	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_SQRT_DBL_MIN	int
*	O
Phf	struct
.	O
err	double
/	O
fabs	function
(	O
Pell	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
fabs	function
(	O
rat	struct
.	O
err	double
/	O
rat	struct
.	O
val	double
)	O
*	O
(	O
l	int
+	O
1.0	int
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct
Pmhf	struct
;	O
stat_P	int
=	O
gsl_sf_conicalP_mhalf_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
Pmhf	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
Pmhf	struct
.	O
val	double
/	O
Pellp1	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_SQRT_DBL_MIN	int
*	O
Pmhf	struct
.	O
err	double
/	O
fabs	function
(	O
Pellp1	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
fabs	function
(	O
rat	struct
.	O
err	double
/	O
rat	struct
.	O
val	double
)	O
*	O
(	O
l	int
+	O
1.0	int
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
}	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_P	int
,	O
stat_CF1	int
)	O
;	O
}	O
}	O
int	O
gsl_sf_conicalP_cyl_reg_e	function
(	O
const	O
int	O
m	int
,	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
if	O
(	O
x	double
<=	O
-	O
1.0	int
||	O
m	int
<	O
-	O
1	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
m	int
==	O
-	O
1	int
)	O
{	O
return	O
gsl_sf_conicalP_1_e	function
(	O
lambda	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
m	int
==	O
0	int
)	O
{	O
return	O
gsl_sf_conicalP_0_e	function
(	O
lambda	double
,	O
x	double
,	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
1.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
double	O
c	array
=	O
1.0	int
/	O
sqrt	function
(	O
1.0	int
-	O
x	double
*	O
x	double
)	O
;	O
gsl_sf_result	struct
r_Pkm1	struct
;	O
gsl_sf_result	struct
r_Pk	struct
;	O
int	O
stat_0	int
=	O
gsl_sf_conicalP_1_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
r_Pkm1	struct
)	O
;	O
int	O
stat_1	int
=	O
gsl_sf_conicalP_0_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
r_Pk	struct
)	O
;	O
int	O
stat_P	int
=	O
GSL_ERROR_SELECT_2	O
(	O
stat_0	int
,	O
stat_1	int
)	O
;	O
double	O
Pkm1	double
=	O
r_Pkm1	struct
.	O
val	double
;	O
double	O
Pk	double
=	O
r_Pk	struct
.	O
val	double
;	O
double	O
Pkp1	double
;	O
int	O
k	double
;	O
for	O
(	O
k	double
=	O
0	int
;	O
k	double
<	O
m	int
;	O
k	double
++	O
)	O
{	O
double	O
d	double
=	O
(	O
k	double
+	O
0.5	int
)	O
*	O
(	O
k	double
+	O
0.5	int
)	O
+	O
lambda	double
*	O
lambda	double
;	O
Pkp1	double
=	O
(	O
Pkm1	double
-	O
2.0	int
*	O
k	double
*	O
c	array
*	O
x	double
*	O
Pk	double
)	O
/	O
d	double
;	O
Pkm1	double
=	O
Pk	double
;	O
Pk	double
=	O
Pkp1	double
;	O
}	O
result	pointer
->	O
val	double
=	O
Pk	double
;	O
result	pointer
->	O
err	double
=	O
(	O
m	int
+	O
2.0	int
)	O
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
Pk	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
stat_P	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
1.0	int
)	O
{	O
const	O
double	O
xi	double
=	O
x	double
/	O
(	O
sqrt	function
(	O
1.0	int
-	O
x	double
)	O
*	O
sqrt	function
(	O
1.0	int
+	O
x	double
)	O
)	O
;	O
gsl_sf_result	struct
rat	struct
;	O
gsl_sf_result	struct
P0	struct
;	O
int	O
stat_CF1	int
=	O
conicalP_negmu_xlt1_CF1	function
(	O
0.0	int
,	O
m	int
,	O
lambda	double
,	O
x	double
,	O
&	O
rat	struct
)	O
;	O
int	O
stat_P0	int
=	O
gsl_sf_conicalP_0_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
P0	struct
)	O
;	O
double	O
Pkp1	double
=	O
rat	struct
.	O
val	double
*	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Pk	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Pkm1	double
;	O
int	O
k	double
;	O
for	O
(	O
k	double
=	O
m	int
;	O
k	double
>	O
0	int
;	O
k	double
--	O
)	O
{	O
double	O
d	double
=	O
(	O
k	double
+	O
0.5	int
)	O
*	O
(	O
k	double
+	O
0.5	int
)	O
+	O
lambda	double
*	O
lambda	double
;	O
Pkm1	double
=	O
2.0	int
*	O
k	double
*	O
xi	double
*	O
Pk	double
+	O
d	double
*	O
Pkp1	double
;	O
Pkp1	double
=	O
Pk	double
;	O
Pk	double
=	O
Pkm1	double
;	O
}	O
result	pointer
->	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
P0	struct
.	O
val	double
/	O
Pk	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_SQRT_DBL_MIN	int
*	O
P0	struct
.	O
err	double
/	O
fabs	function
(	O
Pk	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
fabs	function
(	O
rat	struct
.	O
err	double
/	O
rat	struct
.	O
val	double
)	O
*	O
(	O
m	int
+	O
1.0	int
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_P0	int
,	O
stat_CF1	int
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
1.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
xi	double
=	O
x	double
/	O
sqrt	function
(	O
(	O
x	double
-	O
1.0	int
)	O
*	O
(	O
x	double
+	O
1.0	int
)	O
)	O
;	O
gsl_sf_result	struct
rat	struct
;	O
int	O
stat_CF1	int
=	O
conicalP_negmu_xgt1_CF1	function
(	O
0.0	int
,	O
m	int
,	O
lambda	double
,	O
x	double
,	O
&	O
rat	struct
)	O
;	O
int	O
stat_P	int
;	O
double	O
Pkp1	double
=	O
rat	struct
.	O
val	double
*	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Pk	double
=	O
GSL_SQRT_DBL_MIN	int
;	O
double	O
Pkm1	double
;	O
int	O
k	double
;	O
for	O
(	O
k	double
=	O
m	int
;	O
k	double
>	O
-	O
1	int
;	O
k	double
--	O
)	O
{	O
double	O
d	double
=	O
(	O
k	double
+	O
0.5	int
)	O
*	O
(	O
k	double
+	O
0.5	int
)	O
+	O
lambda	double
*	O
lambda	double
;	O
Pkm1	double
=	O
2.0	int
*	O
k	double
*	O
xi	double
*	O
Pk	double
-	O
d	double
*	O
Pkp1	double
;	O
Pkp1	double
=	O
Pk	double
;	O
Pk	double
=	O
Pkm1	double
;	O
}	O
if	O
(	O
fabs	function
(	O
Pk	double
)	O
>	O
fabs	function
(	O
Pkp1	double
)	O
)	O
{	O
gsl_sf_result	struct
P1	struct
;	O
stat_P	int
=	O
gsl_sf_conicalP_1_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
P1	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
P1	struct
.	O
val	double
/	O
Pk	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_SQRT_DBL_MIN	int
*	O
P1	struct
.	O
err	double
/	O
fabs	function
(	O
Pk	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
fabs	function
(	O
rat	struct
.	O
err	double
/	O
rat	struct
.	O
val	double
)	O
*	O
(	O
m	int
+	O
2.0	int
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
}	O
else	O
{	O
gsl_sf_result	struct
P0	struct
;	O
stat_P	int
=	O
gsl_sf_conicalP_0_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
P0	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
GSL_SQRT_DBL_MIN	int
*	O
P0	struct
.	O
val	double
/	O
Pkp1	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_SQRT_DBL_MIN	int
*	O
P0	struct
.	O
err	double
/	O
fabs	function
(	O
Pkp1	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
fabs	function
(	O
rat	struct
.	O
err	double
/	O
rat	struct
.	O
val	double
)	O
*	O
(	O
m	int
+	O
2.0	int
)	O
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
}	O
return	O
GSL_ERROR_SELECT_2	O
(	O
stat_P	int
,	O
stat_CF1	int
)	O
;	O
}	O
}	O
double	O
gsl_sf_conicalP_0	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_conicalP_0_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_conicalP_1	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_conicalP_1_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_conicalP_half	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_conicalP_half_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_conicalP_mhalf	function
(	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_conicalP_mhalf_e	function
(	O
lambda	double
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_conicalP_sph_reg	function
(	O
const	O
int	O
l	int
,	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_conicalP_sph_reg_e	function
(	O
l	int
,	O
lambda	double
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_conicalP_cyl_reg	function
(	O
const	O
int	O
m	int
,	O
const	O
double	O
lambda	double
,	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_conicalP_cyl_reg_e	function
(	O
m	int
,	O
lambda	double
,	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
