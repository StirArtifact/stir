typedef	O
struct	O
{	O
gsl_matrix	struct
*	O
A	pointer
;	O
gsl_matrix	struct
*	O
A_copy	pointer
;	O
gsl_matrix	struct
*	O
J	pointer
;	O
gsl_vector	struct
*	O
diag	pointer
;	O
gsl_vector	struct
*	O
rhs	pointer
;	O
gsl_vector	struct
*	O
x_trial	pointer
;	O
gsl_vector	struct
*	O
f_trial	pointer
;	O
gsl_vector	struct
*	O
work	pointer
;	O
long	O
nu	long
;	O
double	O
mu	double
;	O
double	O
tau	double
;	O
}	O
lmniel_state_t	struct
;	O
static	O
int	O
lmniel_alloc	function
(	O
void	O
*	O
vstate	pointer
,	O
const	O
size_t	long
n	int
,	O
const	O
size_t	long
p	int
)	O
;	O
static	O
void	O
lmniel_free	function
(	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
int	O
lmniel_set	function
(	O
void	O
*	O
vstate	pointer
,	O
const	O
gsl_vector	struct
*	O
swts	pointer
,	O
gsl_multifit_function_fdf	struct
*	O
fdf	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_vector	struct
*	O
dx	pointer
)	O
;	O
static	O
int	O
lmniel_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
const	O
gsl_vector	struct
*	O
swts	pointer
,	O
gsl_multifit_function_fdf	struct
*	O
fdf	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_vector	struct
*	O
dx	pointer
)	O
;	O
static	O
int	O
lmniel_alloc	function
(	O
void	O
*	O
vstate	pointer
,	O
const	O
size_t	long
n	int
,	O
const	O
size_t	long
p	int
)	O
{	O
lmniel_state_t	struct
*	O
state	pointer
=	O
(	O
lmniel_state_t	struct
*	O
)	O
vstate	pointer
;	O
state	pointer
->	O
A	pointer
=	O
gsl_matrix_alloc	function
(	O
p	int
,	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
A	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR	O
(	O
"failed to allocate space for A"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
J	pointer
=	O
gsl_matrix_alloc	function
(	O
n	int
,	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
J	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR	O
(	O
"failed to allocate space for J"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
diag	pointer
=	O
gsl_vector_alloc	function
(	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
diag	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR	O
(	O
"failed to allocate space for diag"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
rhs	pointer
=	O
gsl_vector_alloc	function
(	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
rhs	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR	O
(	O
"failed to allocate space for rhs"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
work	pointer
=	O
gsl_vector_alloc	function
(	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
work	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR	O
(	O
"failed to allocate space for work"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
A_copy	pointer
=	O
gsl_matrix_alloc	function
(	O
p	int
,	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
A_copy	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR	O
(	O
"failed to allocate space for A_copy"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
x_trial	pointer
=	O
gsl_vector_alloc	function
(	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
x_trial	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR	O
(	O
"failed to allocate space for x_trial"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
f_trial	pointer
=	O
gsl_vector_alloc	function
(	O
n	int
)	O
;	O
if	O
(	O
state	pointer
->	O
f_trial	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR	O
(	O
"failed to allocate space for f_trial"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
tau	double
=	O
1.0e-3	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
void	O
lmniel_free	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
lmniel_state_t	struct
*	O
state	pointer
=	O
(	O
lmniel_state_t	struct
*	O
)	O
vstate	pointer
;	O
if	O
(	O
state	pointer
->	O
A	pointer
)	O
gsl_matrix_free	function
(	O
state	pointer
->	O
A	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
J	pointer
)	O
gsl_matrix_free	function
(	O
state	pointer
->	O
J	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
diag	pointer
)	O
gsl_vector_free	function
(	O
state	pointer
->	O
diag	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
rhs	pointer
)	O
gsl_vector_free	function
(	O
state	pointer
->	O
rhs	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
work	pointer
)	O
gsl_vector_free	function
(	O
state	pointer
->	O
work	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
A_copy	pointer
)	O
gsl_matrix_free	function
(	O
state	pointer
->	O
A_copy	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
x_trial	pointer
)	O
gsl_vector_free	function
(	O
state	pointer
->	O
x_trial	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
f_trial	pointer
)	O
gsl_vector_free	function
(	O
state	pointer
->	O
f_trial	pointer
)	O
;	O
}	O
static	O
int	O
lmniel_set	function
(	O
void	O
*	O
vstate	pointer
,	O
const	O
gsl_vector	struct
*	O
swts	pointer
,	O
gsl_multifit_function_fdf	struct
*	O
fdf	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_vector	struct
*	O
dx	pointer
)	O
{	O
int	O
status	int
;	O
lmniel_state_t	struct
*	O
state	pointer
=	O
(	O
lmniel_state_t	struct
*	O
)	O
vstate	pointer
;	O
const	O
size_t	long
p	int
=	O
x	double
->	O
size	long
;	O
size_t	long
i	long
;	O
fdf	pointer
->	O
nevalf	long
=	O
0	int
;	O
fdf	pointer
->	O
nevaldf	long
=	O
0	int
;	O
status	int
=	O
gsl_multifit_eval_wf	function
(	O
fdf	pointer
,	O
x	double
,	O
swts	pointer
,	O
f	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
fdf	pointer
->	O
df	pointer
)	O
status	int
=	O
gsl_multifit_eval_wdf	function
(	O
fdf	pointer
,	O
x	double
,	O
swts	pointer
,	O
state	pointer
->	O
J	pointer
)	O
;	O
else	O
status	int
=	O
gsl_multifit_fdfsolver_dif_df	function
(	O
x	double
,	O
swts	pointer
,	O
fdf	pointer
,	O
f	pointer
,	O
state	pointer
->	O
J	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
gsl_blas_dgemv	function
(	O
CblasTrans	int
,	O
-	O
1.0	int
,	O
state	pointer
->	O
J	pointer
,	O
f	pointer
,	O
0.0	int
,	O
state	pointer
->	O
rhs	pointer
)	O
;	O
gsl_vector_set_all	function
(	O
state	pointer
->	O
diag	pointer
,	O
1.0	int
)	O
;	O
state	pointer
->	O
nu	long
=	O
2	int
;	O
state	pointer
->	O
mu	double
=	O
-	O
1.0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
p	int
;	O
++	O
i	long
)	O
{	O
gsl_vector_view	struct
c	pointer
=	O
gsl_matrix_column	function
(	O
state	pointer
->	O
J	pointer
,	O
i	long
)	O
;	O
double	O
result	pointer
;	O
gsl_blas_ddot	function
(	O
&	O
c	pointer
.	O
vector	struct
,	O
&	O
c	pointer
.	O
vector	struct
,	O
&	O
result	pointer
)	O
;	O
state	pointer
->	O
mu	double
=	O
GSL_MAX	O
(	O
state	pointer
->	O
mu	double
,	O
result	pointer
)	O
;	O
}	O
state	pointer
->	O
mu	double
*=	O
state	pointer
->	O
tau	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
lmniel_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
const	O
gsl_vector	struct
*	O
swts	pointer
,	O
gsl_multifit_function_fdf	struct
*	O
fdf	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_vector	struct
*	O
dx	pointer
)	O
{	O
int	O
status	int
;	O
lmniel_state_t	struct
*	O
state	pointer
=	O
(	O
lmniel_state_t	struct
*	O
)	O
vstate	pointer
;	O
gsl_matrix	struct
*	O
J	pointer
=	O
state	pointer
->	O
J	pointer
;	O
gsl_matrix	struct
*	O
A	pointer
=	O
state	pointer
->	O
A	pointer
;	O
gsl_vector	struct
*	O
rhs	pointer
=	O
state	pointer
->	O
rhs	pointer
;	O
gsl_vector	struct
*	O
x_trial	pointer
=	O
state	pointer
->	O
x_trial	pointer
;	O
gsl_vector	struct
*	O
f_trial	pointer
=	O
state	pointer
->	O
f_trial	pointer
;	O
gsl_vector	struct
*	O
diag	pointer
=	O
state	pointer
->	O
diag	pointer
;	O
double	O
dF	double
;	O
double	O
dL	double
;	O
int	O
foundstep	int
=	O
0	int
;	O
status	int
=	O
gsl_blas_dsyrk	function
(	O
CblasLower	int
,	O
CblasTrans	int
,	O
1.0	int
,	O
J	pointer
,	O
0.0	int
,	O
A	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
gsl_matrix_transpose_tricpy	function
(	O
CblasLower	int
,	O
CblasUnit	int
,	O
A	pointer
,	O
A	pointer
)	O
;	O
while	O
(	O
!	O
foundstep	int
)	O
{	O
status	int
=	O
lmniel_calc_dx	function
(	O
state	pointer
->	O
mu	double
,	O
A	pointer
,	O
rhs	pointer
,	O
dx	pointer
,	O
state	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
lmniel_trial_step	function
(	O
x	double
,	O
dx	pointer
,	O
x_trial	pointer
)	O
;	O
status	int
=	O
gsl_multifit_eval_wf	function
(	O
fdf	pointer
,	O
x_trial	pointer
,	O
swts	pointer
,	O
f_trial	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
dF	double
=	O
lmniel_calc_dF	function
(	O
f	pointer
,	O
f_trial	pointer
)	O
;	O
dL	double
=	O
lmniel_calc_dL	function
(	O
state	pointer
->	O
mu	double
,	O
diag	pointer
,	O
dx	pointer
,	O
rhs	pointer
)	O
;	O
if	O
(	O
(	O
dL	double
>	O
0.0	int
)	O
&&	O
(	O
dF	double
>=	O
0.0	int
)	O
)	O
{	O
double	O
tmp	double
;	O
tmp	double
=	O
2.0	int
*	O
(	O
dF	double
/	O
dL	double
)	O
-	O
1.0	int
;	O
tmp	double
=	O
1.0	int
-	O
tmp	double
*	O
tmp	double
*	O
tmp	double
;	O
state	pointer
->	O
mu	double
*=	O
GSL_MAX	O
(	O
LM_ONE_THIRD	O
,	O
tmp	double
)	O
;	O
state	pointer
->	O
nu	long
=	O
2	int
;	O
if	O
(	O
fdf	pointer
->	O
df	pointer
)	O
status	int
=	O
gsl_multifit_eval_wdf	function
(	O
fdf	pointer
,	O
x_trial	pointer
,	O
swts	pointer
,	O
J	pointer
)	O
;	O
else	O
status	int
=	O
gsl_multifit_fdfsolver_dif_df	function
(	O
x_trial	pointer
,	O
swts	pointer
,	O
fdf	pointer
,	O
f_trial	pointer
,	O
J	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
gsl_vector_memcpy	function
(	O
x	double
,	O
x_trial	pointer
)	O
;	O
gsl_vector_memcpy	function
(	O
f	pointer
,	O
f_trial	pointer
)	O
;	O
gsl_blas_dgemv	function
(	O
CblasTrans	int
,	O
-	O
1.0	int
,	O
J	pointer
,	O
f	pointer
,	O
0.0	int
,	O
rhs	pointer
)	O
;	O
foundstep	int
=	O
1	int
;	O
}	O
else	O
{	O
long	O
nu2	long
;	O
state	pointer
->	O
mu	double
*=	O
(	O
double	O
)	O
state	pointer
->	O
nu	long
;	O
nu2	long
=	O
state	pointer
->	O
nu	long
<<	O
1	int
;	O
if	O
(	O
nu2	long
<=	O
state	pointer
->	O
nu	long
)	O
{	O
gsl_vector_view	struct
d	struct
=	O
gsl_matrix_diagonal	function
(	O
A	pointer
)	O
;	O
state	pointer
->	O
nu	long
=	O
2	int
;	O
state	pointer
->	O
mu	double
=	O
state	pointer
->	O
tau	double
*	O
gsl_vector_max	function
(	O
&	O
d	struct
.	O
vector	struct
)	O
;	O
break	O
;	O
}	O
state	pointer
->	O
nu	long
=	O
nu2	long
;	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
lmniel_gradient	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_vector	struct
*	O
g	pointer
)	O
{	O
lmniel_state_t	struct
*	O
state	pointer
=	O
(	O
lmniel_state_t	struct
*	O
)	O
vstate	pointer
;	O
gsl_vector_memcpy	function
(	O
g	pointer
,	O
state	pointer
->	O
rhs	pointer
)	O
;	O
gsl_vector_scale	function
(	O
g	pointer
,	O
-	O
1.0	int
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
lmniel_jac	function
(	O
void	O
*	O
vstate	pointer
,	O
gsl_matrix	struct
*	O
J	pointer
)	O
{	O
lmniel_state_t	struct
*	O
state	pointer
=	O
(	O
lmniel_state_t	struct
*	O
)	O
vstate	pointer
;	O
int	O
s	pointer
=	O
gsl_matrix_memcpy	function
(	O
J	pointer
,	O
state	pointer
->	O
J	pointer
)	O
;	O
return	O
s	pointer
;	O
}	O
static	O
const	O
gsl_multifit_fdfsolver_type	struct
lmniel_type	struct
=	O
{	O
"lmniel"	pointer
,	O
sizeof	O
(	O
lmniel_state_t	struct
)	O
,	O
&	O
lmniel_alloc	function
,	O
&	O
lmniel_set	function
,	O
&	O
lmniel_iterate	function
,	O
&	O
lmniel_gradient	function
,	O
&	O
lmniel_jac	function
,	O
&	O
lmniel_free	function
}	O
;	O
const	O
gsl_multifit_fdfsolver_type	struct
*	O
gsl_multifit_fdfsolver_lmniel	pointer
=	O
&	O
lmniel_type	struct
;	O
