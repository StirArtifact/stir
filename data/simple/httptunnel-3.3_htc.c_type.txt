typedef	O
struct	O
{	O
char	O
*	O
me	pointer
;	O
char	O
*	O
device	pointer
;	O
char	O
*	O
host_name	pointer
;	O
int	O
host_port	int
;	O
char	O
*	O
proxy_name	pointer
;	O
int	O
proxy_port	int
;	O
size_t	long
proxy_buffer_size	long
;	O
int	O
proxy_buffer_timeout	int
;	O
size_t	long
content_length	long
;	O
int	O
forward_port	int
;	O
int	O
use_std	int
;	O
int	O
use_daemon	int
;	O
int	O
strict_content_length	int
;	O
int	O
keep_alive	int
;	O
int	O
max_connection_age	int
;	O
char	O
*	O
proxy_authorization	pointer
;	O
char	O
*	O
user_agent	pointer
;	O
}	O
Arguments	struct
;	O
int	O
debug_level	int
=	O
0	int
;	O
FILE	struct
*	O
debug_file	pointer
=	O
NULL	O
;	O
static	O
void	O
usage	function
(	O
FILE	struct
*	O
f	pointer
,	O
const	O
char	O
*	O
me	pointer
)	O
{	O
fprintf	function
(	O
f	pointer
,	O
"Usage: %s [OPTION]... HOST[:PORT]\n"	pointer
"Set up a httptunnel connection to PORT at HOST (default port is %d).\n"	pointer
"When a connection is made, I/O is redirected from the source specified\n"	pointer
"by the --device, --forward-port or --stdin-stdout switch to the tunnel.\n"	pointer
"\n"	pointer
"  -A, --proxy-authorization USER:PASSWORD  proxy authorization\n"	pointer
"  -z, --proxy-authorization-file FILE      proxy authorization file\n"	pointer
"  -B, --proxy-buffer-size BYTES  assume a proxy buffer size of BYTES bytes\n"	pointer
"                                 (k, M, and G postfixes recognized)\n"	pointer
"  -c, --content-length BYTES     use HTTP PUT requests of BYTES size\n"	pointer
"                                 (k, M, and G postfixes recognized)\n"	pointer
"  -d, --device DEVICE            use DEVICE for input and output\n"	pointer
"  -F, --forward-port PORT        use TCP port PORT for input and output\n"	pointer
"  -h, --help                     display this help and exit\n"	pointer
"  -k, --keep-alive SECONDS       send keepalive bytes every SECONDS seconds\n"	pointer
"                                 (default is %d)\n"	pointer
"  -M, --max-connection-age SEC   maximum time a connection will stay\n"	pointer
"                                 open is SEC seconds (default is %d)\n"	pointer
"  -P, --proxy HOSTNAME[:PORT]    use a HTTP proxy (default port is %d)\n"	pointer
"  -s, --stdin-stdout             use stdin/stdout for communication\n"	pointer
"                                 (implies --no-daemon)\n"	pointer
"  -S, --strict-content-length    always write Content-Length bytes in requests\n"	pointer
"  -T, --timeout TIME             timeout, in milliseconds, before sending\n"	pointer
"                                 padding to a buffering proxy\n"	pointer
"  -U, --user-agent STRING        specify User-Agent value in HTTP requests\n"	pointer
"  -V, --version                  output version information and exit\n"	pointer
"  -w, --no-daemon                don't fork into the background\n"	pointer
"\n"	pointer
"Report bugs to %s.\n"	pointer
,	O
me	pointer
,	O
DEFAULT_HOST_PORT	int
,	O
DEFAULT_KEEP_ALIVE	int
,	O
DEFAULT_MAX_CONNECTION_AGE	int
,	O
DEFAULT_PROXY_PORT	int
,	O
BUG_REPORT_EMAIL	pointer
)	O
;	O
}	O
static	O
int	O
wait_for_connection_on_socket	function
(	O
int	O
s	int
)	O
{	O
struct	O
sockaddr	struct
addr	struct
;	O
socklen_t	int
len	long
;	O
int	O
t	int
;	O
len	long
=	O
sizeof	O
addr	struct
;	O
t	int
=	O
accept	function
(	O
s	int
,	O
&	O
addr	struct
,	O
&	O
len	long
)	O
;	O
if	O
(	O
t	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
return	O
t	int
;	O
}	O
static	O
void	O
parse_arguments	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
Arguments	struct
*	O
arg	pointer
)	O
{	O
int	O
c	int
;	O
arg	pointer
->	O
me	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
arg	pointer
->	O
device	pointer
=	O
NULL	O
;	O
arg	pointer
->	O
forward_port	int
=	O
-	O
1	int
;	O
arg	pointer
->	O
host_name	pointer
=	O
NULL	O
;	O
arg	pointer
->	O
host_port	int
=	O
DEFAULT_HOST_PORT	int
;	O
arg	pointer
->	O
proxy_name	pointer
=	O
NO_PROXY	O
;	O
arg	pointer
->	O
proxy_port	int
=	O
DEFAULT_PROXY_PORT	int
;	O
arg	pointer
->	O
proxy_buffer_size	long
=	O
NO_PROXY_BUFFER	int
;	O
arg	pointer
->	O
proxy_buffer_timeout	int
=	O
-	O
1	int
;	O
arg	pointer
->	O
content_length	long
=	O
DEFAULT_CONTENT_LENGTH	O
;	O
arg	pointer
->	O
use_std	int
=	O
FALSE	int
;	O
arg	pointer
->	O
use_daemon	int
=	O
TRUE	int
;	O
arg	pointer
->	O
strict_content_length	int
=	O
FALSE	int
;	O
arg	pointer
->	O
keep_alive	int
=	O
DEFAULT_KEEP_ALIVE	int
;	O
arg	pointer
->	O
max_connection_age	int
=	O
DEFAULT_CONNECTION_MAX_TIME	int
;	O
arg	pointer
->	O
proxy_authorization	pointer
=	O
NULL	O
;	O
arg	pointer
->	O
user_agent	pointer
=	O
NULL	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
option_index	int
=	O
0	int
;	O
static	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'h'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'V'	O
}	O
,	O
{	O
"no-daemon"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'w'	O
}	O
,	O
{	O
"stdin-stdout"	pointer
,	O
no_argument	int
,	O
0	int
,	O
's'	O
}	O
,	O
{	O
"proxy"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'P'	O
}	O
,	O
{	O
"device"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'd'	O
}	O
,	O
{	O
"timeout"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'T'	O
}	O
,	O
{	O
"keep-alive"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'k'	O
}	O
,	O
{	O
"user-agent"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'U'	O
}	O
,	O
{	O
"forward-port"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'F'	O
}	O
,	O
{	O
"content-length"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'c'	O
}	O
,	O
{	O
"strict-content-length"	pointer
,	O
no_argument	int
,	O
0	int
,	O
'S'	O
}	O
,	O
{	O
"proxy-buffer-size"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'B'	O
}	O
,	O
{	O
"proxy-authorization"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'A'	O
}	O
,	O
{	O
"max-connection-age"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'M'	O
}	O
,	O
{	O
"proxy-authorization-file"	pointer
,	O
required_argument	int
,	O
0	int
,	O
'z'	O
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
const	O
char	O
*	O
short_options	pointer
=	O
"A:B:c:d:F:hk:M:P:sST:U:Vwz:"	pointer
;	O
c	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
short_options	pointer
,	O
long_options	array
,	O
&	O
option_index	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
0	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"option %s"	pointer
,	O
long_options	array
[	O
option_index	int
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
optarg	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
" with arg %s"	pointer
,	O
optarg	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
arg	pointer
->	O
proxy_authorization	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'B'	O
:	O
arg	pointer
->	O
proxy_buffer_size	long
=	O
atoi_with_postfix	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
arg	pointer
->	O
content_length	long
=	O
atoi_with_postfix	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
arg	pointer
->	O
device	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'F'	O
:	O
arg	pointer
->	O
forward_port	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
arg	pointer
->	O
keep_alive	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
arg	pointer
->	O
max_connection_age	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	function
(	O
stdout	pointer
,	O
arg	pointer
->	O
me	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
case	O
'P'	O
:	O
name_and_port	function
(	O
optarg	pointer
,	O
&	O
arg	pointer
->	O
proxy_name	pointer
,	O
&	O
arg	pointer
->	O
proxy_port	int
)	O
;	O
if	O
(	O
arg	pointer
->	O
proxy_port	int
==	O
-	O
1	int
)	O
arg	pointer
->	O
proxy_port	int
=	O
DEFAULT_PROXY_PORT	int
;	O
if	O
(	O
arg	pointer
->	O
proxy_buffer_timeout	int
==	O
-	O
1	int
)	O
arg	pointer
->	O
proxy_buffer_timeout	int
=	O
DEFAULT_PROXY_BUFFER_TIMEOUT	int
;	O
break	O
;	O
case	O
's'	O
:	O
arg	pointer
->	O
use_std	int
=	O
TRUE	int
;	O
arg	pointer
->	O
use_daemon	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'S'	O
:	O
arg	pointer
->	O
strict_content_length	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'T'	O
:	O
arg	pointer
->	O
proxy_buffer_timeout	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'U'	O
:	O
arg	pointer
->	O
user_agent	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'V'	O
:	O
printf	function
(	O
"htc (%s) %s\n"	pointer
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
case	O
'w'	O
:	O
arg	pointer
->	O
use_daemon	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'z'	O
:	O
{	O
struct	O
stat	struct
s	int
;	O
char	O
*	O
auth	pointer
;	O
int	O
f	pointer
;	O
f	pointer
=	O
open	function
(	O
optarg	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
f	pointer
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"couldn't open %s: %s\n"	pointer
,	O
optarg	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fstat	function
(	O
f	pointer
,	O
&	O
s	int
)	O
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error fstating %s: %s\n"	pointer
,	O
optarg	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
auth	pointer
=	O
malloc	function
(	O
s	int
.	O
st_size	long
+	O
1	int
)	O
;	O
if	O
(	O
auth	pointer
==	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"out of memory whilst allocating "	pointer
"authentication string\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
read_all	function
(	O
f	pointer
,	O
auth	pointer
,	O
s	int
.	O
st_size	long
)	O
==	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"error reading %s: %s\n"	pointer
,	O
optarg	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
s	int
.	O
st_size	long
>=	O
1	int
&&	O
auth	pointer
[	O
s	int
.	O
st_size	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
s	int
.	O
st_size	long
-=	O
(	O
s	int
.	O
st_size	long
>=	O
2	int
&&	O
auth	pointer
[	O
s	int
.	O
st_size	long
-	O
2	int
]	O
==	O
'\r'	O
)	O
?	O
2	int
:	O
1	int
;	O
}	O
auth	pointer
[	O
s	int
.	O
st_size	long
]	O
=	O
0	int
;	O
arg	pointer
->	O
proxy_authorization	pointer
=	O
auth	pointer
;	O
}	O
break	O
;	O
case	O
'?'	O
:	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"?? getopt returned character code 0%o ??\n"	pointer
,	O
c	int
)	O
;	O
}	O
}	O
if	O
(	O
optind	int
==	O
argc	int
-	O
1	int
)	O
{	O
name_and_port	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
&	O
arg	pointer
->	O
host_name	pointer
,	O
&	O
arg	pointer
->	O
host_port	int
)	O
;	O
if	O
(	O
arg	pointer
->	O
host_port	int
==	O
-	O
1	int
)	O
arg	pointer
->	O
host_port	int
=	O
DEFAULT_HOST_PORT	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: the destination of the tunnel must be specified.\n"	pointer
"%s: try '%s --help' for help.\n"	pointer
,	O
arg	pointer
->	O
me	pointer
,	O
arg	pointer
->	O
me	pointer
,	O
arg	pointer
->	O
me	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
arg	pointer
->	O
device	pointer
==	O
NULL	O
&&	O
arg	pointer
->	O
forward_port	int
==	O
-	O
1	int
&&	O
!	O
arg	pointer
->	O
use_std	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: one of --device, --forward-port or --stdin-stdout must be used.\n"	pointer
"%s: try '%s -help' for help.\n"	pointer
,	O
arg	pointer
->	O
me	pointer
,	O
arg	pointer
->	O
me	pointer
,	O
arg	pointer
->	O
me	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
(	O
arg	pointer
->	O
device	pointer
!=	O
NULL	O
&&	O
arg	pointer
->	O
forward_port	int
!=	O
-	O
1	int
)	O
||	O
(	O
arg	pointer
->	O
device	pointer
!=	O
NULL	O
&&	O
arg	pointer
->	O
use_std	int
)	O
||	O
(	O
arg	pointer
->	O
forward_port	int
!=	O
-	O
1	int
&&	O
arg	pointer
->	O
use_std	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: only one of --device, --forward-port or --stdin-stdout can be used.\n"	pointer
"%s: try '%s --help' for help.\n"	pointer
,	O
arg	pointer
->	O
me	pointer
,	O
arg	pointer
->	O
me	pointer
,	O
arg	pointer
->	O
me	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
arg	pointer
->	O
host_name	pointer
==	O
NULL	O
||	O
arg	pointer
->	O
host_port	int
==	O
-	O
1	int
||	O
(	O
arg	pointer
->	O
proxy_name	pointer
!=	O
NO_PROXY	O
&&	O
arg	pointer
->	O
proxy_port	int
==	O
-	O
1	int
)	O
)	O
{	O
usage	function
(	O
stderr	pointer
,	O
arg	pointer
->	O
me	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
debug_level	int
==	O
0	int
&&	O
debug_file	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: --logfile can't be used without debugging\n"	pointer
,	O
arg	pointer
->	O
me	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
arg	pointer
->	O
proxy_name	pointer
==	O
NO_PROXY	O
)	O
{	O
if	O
(	O
arg	pointer
->	O
proxy_buffer_size	long
!=	O
NO_PROXY_BUFFER	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: --proxy-buffer-size can't be "	pointer
"used without --proxy\n"	pointer
,	O
arg	pointer
->	O
me	pointer
)	O
;	O
arg	pointer
->	O
proxy_buffer_size	long
=	O
NO_PROXY_BUFFER	int
;	O
}	O
if	O
(	O
arg	pointer
->	O
proxy_buffer_timeout	int
!=	O
-	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: --proxy-buffer-timeout can't be "	pointer
"used without --proxy\n"	pointer
,	O
arg	pointer
->	O
me	pointer
)	O
;	O
arg	pointer
->	O
proxy_buffer_timeout	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
arg	pointer
->	O
proxy_authorization	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: --proxy-authorization can't be "	pointer
"used without --proxy\n"	pointer
,	O
arg	pointer
->	O
me	pointer
)	O
;	O
arg	pointer
->	O
proxy_authorization	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
arg	pointer
->	O
proxy_buffer_size	long
==	O
NO_PROXY_BUFFER	int
)	O
arg	pointer
->	O
proxy_buffer_timeout	int
=	O
-	O
1	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
s	int
=	O
-	O
1	int
;	O
int	O
fd	int
=	O
-	O
1	int
;	O
Arguments	struct
arg	pointer
;	O
Tunnel	struct
*	O
tunnel	pointer
;	O
int	O
closed	pointer
;	O
parse_arguments	function
(	O
argc	int
,	O
argv	pointer
,	O
&	O
arg	pointer
)	O
;	O
if	O
(	O
(	O
debug_level	int
==	O
0	int
||	O
debug_file	pointer
!=	O
NULL	O
)	O
&&	O
arg	pointer
.	O
use_daemon	int
)	O
daemon	function
(	O
0	int
,	O
1	int
)	O
;	O
openlog	function
(	O
"htc"	pointer
,	O
LOG_PID	int
,	O
LOG_DAEMON	O
)	O
;	O
log_notice	function
(	O
"htc (%s) %s started with arguments:"	pointer
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
log_notice	function
(	O
"  me = %s"	pointer
,	O
arg	pointer
.	O
me	pointer
)	O
;	O
log_notice	function
(	O
"  device = %s"	pointer
,	O
arg	pointer
.	O
device	pointer
?	O
arg	pointer
.	O
device	pointer
:	O
"(null)"	pointer
)	O
;	O
log_notice	function
(	O
"  host_name = %s"	pointer
,	O
arg	pointer
.	O
host_name	pointer
?	O
arg	pointer
.	O
host_name	pointer
:	O
"(null)"	pointer
)	O
;	O
log_notice	function
(	O
"  host_port = %d"	pointer
,	O
arg	pointer
.	O
host_port	int
)	O
;	O
log_notice	function
(	O
"  proxy_name = %s"	pointer
,	O
arg	pointer
.	O
proxy_name	pointer
?	O
arg	pointer
.	O
proxy_name	pointer
:	O
"(null)"	pointer
)	O
;	O
log_notice	function
(	O
"  proxy_port = %d"	pointer
,	O
arg	pointer
.	O
proxy_port	int
)	O
;	O
log_notice	function
(	O
"  proxy_buffer_size = %d"	pointer
,	O
arg	pointer
.	O
proxy_buffer_size	long
)	O
;	O
log_notice	function
(	O
"  proxy_buffer_timeout = %d"	pointer
,	O
arg	pointer
.	O
proxy_buffer_timeout	int
)	O
;	O
log_notice	function
(	O
"  content_length = %d"	pointer
,	O
arg	pointer
.	O
content_length	long
)	O
;	O
log_notice	function
(	O
"  forward_port = %d"	pointer
,	O
arg	pointer
.	O
forward_port	int
)	O
;	O
log_notice	function
(	O
"  max_connection_age = %d"	pointer
,	O
arg	pointer
.	O
max_connection_age	int
)	O
;	O
log_notice	function
(	O
"  use_std = %d"	pointer
,	O
arg	pointer
.	O
use_std	int
)	O
;	O
log_notice	function
(	O
"  strict_content_length = %d"	pointer
,	O
arg	pointer
.	O
strict_content_length	int
)	O
;	O
log_notice	function
(	O
"  keep_alive = %d"	pointer
,	O
arg	pointer
.	O
keep_alive	int
)	O
;	O
log_notice	function
(	O
"  proxy_authorization = %s"	pointer
,	O
arg	pointer
.	O
proxy_authorization	pointer
?	O
arg	pointer
.	O
proxy_authorization	pointer
:	O
"(null)"	pointer
)	O
;	O
log_notice	function
(	O
"  user_agent = %s"	pointer
,	O
arg	pointer
.	O
user_agent	pointer
?	O
arg	pointer
.	O
user_agent	pointer
:	O
"(null)"	pointer
)	O
;	O
log_notice	function
(	O
"  debug_level = %d"	pointer
,	O
debug_level	int
)	O
;	O
if	O
(	O
arg	pointer
.	O
forward_port	int
!=	O
-	O
1	int
)	O
{	O
struct	O
in_addr	struct
addr	struct
;	O
addr	struct
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
s	int
=	O
server_socket	function
(	O
addr	struct
,	O
arg	pointer
.	O
forward_port	int
,	O
0	int
)	O
;	O
log_debug	function
(	O
"server_socket (%d) = %d"	pointer
,	O
arg	pointer
.	O
forward_port	int
,	O
s	int
)	O
;	O
if	O
(	O
s	int
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"couldn't create server socket: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
log_exit	function
(	O
1	int
)	O
;	O
}	O
}	O
signal	function
(	O
SIGPIPE	int
,	O
SIG_IGN	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
time_t	long
last_tunnel_write	long
;	O
if	O
(	O
arg	pointer
.	O
device	pointer
)	O
{	O
fd	int
=	O
open_device	function
(	O
arg	pointer
.	O
device	pointer
)	O
;	O
log_debug	function
(	O
"open_device (\"%s\") = %d"	pointer
,	O
arg	pointer
.	O
device	pointer
,	O
fd	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"couldn't open %s: %s"	pointer
,	O
arg	pointer
.	O
device	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
log_exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fd	int
==	O
0	int
)	O
{	O
log_notice	function
(	O
"changing fd from %d to 3"	pointer
,	O
fd	int
)	O
;	O
if	O
(	O
dup2	function
(	O
fd	int
,	O
3	int
)	O
!=	O
3	int
)	O
{	O
log_error	function
(	O
"couldn't dup2(%d,3): %s"	pointer
,	O
fd	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
log_exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
arg	pointer
.	O
forward_port	int
!=	O
-	O
1	int
)	O
{	O
log_debug	function
(	O
"waiting for connection on port %d"	pointer
,	O
arg	pointer
.	O
forward_port	int
)	O
;	O
fd	int
=	O
wait_for_connection_on_socket	function
(	O
s	int
)	O
;	O
log_debug	function
(	O
"wait_for_connection_on_socket (%d) = %d"	pointer
,	O
s	int
,	O
fd	int
)	O
;	O
if	O
(	O
fd	int
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"couldn't forward port %d: %s"	pointer
,	O
arg	pointer
.	O
forward_port	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
log_exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
fd	int
==	O
0	int
)	O
{	O
log_notice	function
(	O
"changing fd from %d to 3"	pointer
,	O
fd	int
)	O
;	O
if	O
(	O
dup2	function
(	O
fd	int
,	O
3	int
)	O
!=	O
3	int
)	O
{	O
log_error	function
(	O
"couldn't dup2(%d,3): %s"	pointer
,	O
fd	int
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
log_exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
arg	pointer
.	O
use_std	int
)	O
{	O
log_debug	function
(	O
"using stdin as fd"	pointer
)	O
;	O
fd	int
=	O
0	int
;	O
if	O
(	O
fcntl	function
(	O
fd	int
,	O
F_SETFL	int
,	O
O_NONBLOCK	int
)	O
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"couldn't set stdin to non-blocking mode: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
log_exit	function
(	O
1	int
)	O
;	O
}	O
}	O
log_debug	function
(	O
"creating a new tunnel"	pointer
)	O
;	O
tunnel	pointer
=	O
tunnel_new_client	function
(	O
arg	pointer
.	O
host_name	pointer
,	O
arg	pointer
.	O
host_port	int
,	O
arg	pointer
.	O
proxy_name	pointer
,	O
arg	pointer
.	O
proxy_port	int
,	O
arg	pointer
.	O
content_length	long
)	O
;	O
if	O
(	O
tunnel	pointer
==	O
NULL	O
)	O
{	O
log_error	function
(	O
"couldn't create tunnel"	pointer
)	O
;	O
log_exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
tunnel_setopt	function
(	O
tunnel	pointer
,	O
"strict_content_length"	pointer
,	O
&	O
arg	pointer
.	O
strict_content_length	int
)	O
==	O
-	O
1	int
)	O
log_debug	function
(	O
"tunnel_setopt strict_content_length error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
tunnel_setopt	function
(	O
tunnel	pointer
,	O
"keep_alive"	pointer
,	O
&	O
arg	pointer
.	O
keep_alive	int
)	O
==	O
-	O
1	int
)	O
log_debug	function
(	O
"tunnel_setopt keep_alive error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
tunnel_setopt	function
(	O
tunnel	pointer
,	O
"max_connection_age"	pointer
,	O
&	O
arg	pointer
.	O
max_connection_age	int
)	O
==	O
-	O
1	int
)	O
log_debug	function
(	O
"tunnel_setopt max_connection_age error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
arg	pointer
.	O
proxy_authorization	pointer
!=	O
NULL	O
)	O
{	O
ssize_t	long
len	long
;	O
char	O
*	O
auth	pointer
;	O
len	long
=	O
encode_base64	function
(	O
arg	pointer
.	O
proxy_authorization	pointer
,	O
strlen	function
(	O
arg	pointer
.	O
proxy_authorization	pointer
)	O
,	O
&	O
auth	pointer
)	O
;	O
if	O
(	O
len	long
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"encode_base64 error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
char	O
*	O
str	pointer
=	O
malloc	function
(	O
len	long
+	O
7	int
)	O
;	O
if	O
(	O
str	pointer
==	O
NULL	O
)	O
{	O
log_error	function
(	O
"out of memory when encoding "	pointer
"authorization string"	pointer
)	O
;	O
log_exit	function
(	O
1	int
)	O
;	O
}	O
strcpy	function
(	O
str	pointer
,	O
"Basic "	pointer
)	O
;	O
strcat	function
(	O
str	pointer
,	O
auth	pointer
)	O
;	O
free	function
(	O
auth	pointer
)	O
;	O
if	O
(	O
tunnel_setopt	function
(	O
tunnel	pointer
,	O
"proxy_authorization"	pointer
,	O
str	pointer
)	O
==	O
-	O
1	int
)	O
log_error	function
(	O
"tunnel_setopt proxy_authorization error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
}	O
}	O
if	O
(	O
arg	pointer
.	O
user_agent	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
tunnel_setopt	function
(	O
tunnel	pointer
,	O
"user_agent"	pointer
,	O
arg	pointer
.	O
user_agent	pointer
)	O
==	O
-	O
1	int
)	O
log_error	function
(	O
"tunnel_setopt user_agent error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
tunnel_connect	function
(	O
tunnel	pointer
)	O
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"couldn't open tunnel: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
log_exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
arg	pointer
.	O
proxy_name	pointer
)	O
log_notice	function
(	O
"connected to %s:%d via %s:%d"	pointer
,	O
arg	pointer
.	O
host_name	pointer
,	O
arg	pointer
.	O
host_port	int
,	O
arg	pointer
.	O
proxy_name	pointer
,	O
arg	pointer
.	O
proxy_port	int
)	O
;	O
else	O
log_notice	function
(	O
"connected to %s:%d"	pointer
,	O
arg	pointer
.	O
host_name	pointer
,	O
arg	pointer
.	O
host_port	int
)	O
;	O
closed	pointer
=	O
FALSE	int
;	O
time	function
(	O
&	O
last_tunnel_write	long
)	O
;	O
while	O
(	O
!	O
closed	pointer
)	O
{	O
struct	O
pollfd	struct
pollfd	struct
[	O
2	int
]	O
;	O
int	O
keep_alive_timeout	int
;	O
int	O
timeout	int
;	O
time_t	long
t	int
;	O
int	O
n	long
;	O
pollfd	struct
[	O
0	int
]	O
.	O
fd	int
=	O
fd	int
;	O
pollfd	struct
[	O
0	int
]	O
.	O
events	short
=	O
POLLIN	int
;	O
pollfd	struct
[	O
1	int
]	O
.	O
fd	int
=	O
tunnel_pollin_fd	function
(	O
tunnel	pointer
)	O
;	O
pollfd	struct
[	O
1	int
]	O
.	O
events	short
=	O
POLLIN	int
;	O
time	function
(	O
&	O
t	int
)	O
;	O
timeout	int
=	O
1000	int
*	O
(	O
arg	pointer
.	O
keep_alive	int
-	O
(	O
t	int
-	O
last_tunnel_write	long
)	O
)	O
;	O
keep_alive_timeout	int
=	O
TRUE	int
;	O
if	O
(	O
timeout	int
<	O
0	int
)	O
timeout	int
=	O
0	int
;	O
if	O
(	O
arg	pointer
.	O
proxy_buffer_timeout	int
!=	O
-	O
1	int
&&	O
arg	pointer
.	O
proxy_buffer_timeout	int
<	O
timeout	int
)	O
{	O
timeout	int
=	O
arg	pointer
.	O
proxy_buffer_timeout	int
;	O
keep_alive_timeout	int
=	O
FALSE	int
;	O
}	O
log_annoying	function
(	O
"poll () ..."	pointer
)	O
;	O
n	long
=	O
poll	function
(	O
pollfd	struct
,	O
2	int
,	O
timeout	int
)	O
;	O
log_annoying	function
(	O
"... = %d"	pointer
,	O
n	long
)	O
;	O
if	O
(	O
n	long
==	O
-	O
1	int
)	O
{	O
log_error	function
(	O
"poll error: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
log_exit	function
(	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
n	long
==	O
0	int
)	O
{	O
log_verbose	function
(	O
"poll() timed out"	pointer
)	O
;	O
if	O
(	O
keep_alive_timeout	int
)	O
{	O
tunnel_padding	function
(	O
tunnel	pointer
,	O
1	int
)	O
;	O
time	function
(	O
&	O
last_tunnel_write	long
)	O
;	O
}	O
else	O
{	O
if	O
(	O
tunnel_maybe_pad	function
(	O
tunnel	pointer
,	O
arg	pointer
.	O
proxy_buffer_size	long
)	O
>	O
0	int
)	O
time	function
(	O
&	O
last_tunnel_write	long
)	O
;	O
}	O
continue	O
;	O
}	O
handle_input	function
(	O
"device or port"	pointer
,	O
tunnel	pointer
,	O
fd	int
,	O
pollfd	struct
[	O
0	int
]	O
.	O
revents	short
,	O
handle_device_input	function
,	O
&	O
closed	pointer
)	O
;	O
handle_input	function
(	O
"tunnel"	pointer
,	O
tunnel	pointer
,	O
fd	int
,	O
pollfd	struct
[	O
1	int
]	O
.	O
revents	short
,	O
handle_tunnel_input	function
,	O
&	O
closed	pointer
)	O
;	O
if	O
(	O
pollfd	struct
[	O
0	int
]	O
.	O
revents	short
&	O
POLLIN	int
)	O
time	function
(	O
&	O
last_tunnel_write	long
)	O
;	O
}	O
log_debug	function
(	O
"destroying tunnel"	pointer
)	O
;	O
if	O
(	O
fd	int
!=	O
0	int
)	O
{	O
close	function
(	O
fd	int
)	O
;	O
}	O
tunnel_destroy	function
(	O
tunnel	pointer
)	O
;	O
if	O
(	O
arg	pointer
.	O
proxy_name	pointer
)	O
log_notice	function
(	O
"disconnected from %s:%d via %s:%d"	pointer
,	O
arg	pointer
.	O
host_name	pointer
,	O
arg	pointer
.	O
host_port	int
,	O
arg	pointer
.	O
proxy_name	pointer
,	O
arg	pointer
.	O
proxy_port	int
)	O
;	O
else	O
log_notice	function
(	O
"disconnected from %s%d"	pointer
,	O
arg	pointer
.	O
host_name	pointer
,	O
arg	pointer
.	O
host_port	int
)	O
;	O
}	O
log_debug	function
(	O
"closing server socket"	pointer
)	O
;	O
close	function
(	O
s	int
)	O
;	O
log_exit	function
(	O
0	int
)	O
;	O
}	O
