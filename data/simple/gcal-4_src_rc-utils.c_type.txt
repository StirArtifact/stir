__BEGIN_DECLARATIONS	O
static	O
void	O
var_warning	function
__P_	O
(	O
(	O
const	O
int	O
exit_status	int
,	O
const	O
int	O
var_name	pointer
,	O
const	O
char	O
*	O
line_buffer	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
long	O
line_number	long
)	O
)	O
;	O
__END_DECLARATIONS	O
Bool	int
rc_valid_day	function
(	O
date_text	pointer
,	O
day	int
,	O
month	int
,	O
year	int
)	O
const	O
char	O
*	O
date_text	pointer
;	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
{	O
register	O
int	O
i	int
;	O
register	O
int	O
wd	int
=	O
weekday_of_date	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
auto	O
const	O
char	O
*	O
ptr_date_text	pointer
=	O
date_text	pointer
;	O
auto	O
Bool	int
hd_found	int
;	O
static	O
Bool	int
inclusive_weekday_map	array
[	O
DAY_MAX	int
+	O
1	int
]	O
;	O
static	O
Bool	int
exclusive_weekday_map	array
[	O
DAY_MAX	int
+	O
1	int
]	O
;	O
for	O
(	O
i	int
=	O
DAY_MIN	int
;	O
i	int
<=	O
DAY_MAX	int
;	O
i	int
++	O
)	O
inclusive_weekday_map	array
[	O
i	int
]	O
=	O
!	O
(	O
exclusive_weekday_map	array
[	O
i	int
]	O
=	O
TRUE	O
)	O
;	O
*	O
inclusive_weekday_map	array
=	O
*	O
exclusive_weekday_map	array
=	O
FALSE	O
;	O
while	O
(	O
*	O
ptr_date_text	pointer
)	O
{	O
hd_found	int
=	O
FALSE	O
;	O
switch	O
(	O
*	O
ptr_date_text	pointer
)	O
{	O
case	O
RC_EX_LHDY_CHAR	char
:	O
case	O
RC_EX_AHDY_CHAR	char
:	O
if	O
(	O
hd_ldays	array
[	O
(	O
(	O
month	int
-	O
1	int
)	O
*	O
MONTH_LAST	int
)	O
+	O
(	O
day	int
-	O
1	int
)	O
]	O
)	O
hd_found	int
=	O
TRUE	O
;	O
if	O
(	O
hd_found	int
||	O
*	O
ptr_date_text	pointer
==	O
RC_EX_LHDY_CHAR	char
)	O
{	O
if	O
(	O
hd_found	int
)	O
{	O
exclusive_weekday_map	array
[	O
wd	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array
=	O
TRUE	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
hd_mdays	array
[	O
(	O
(	O
month	int
-	O
1	int
)	O
*	O
MONTH_LAST	int
)	O
+	O
(	O
day	int
-	O
1	int
)	O
]	O
)	O
{	O
exclusive_weekday_map	array
[	O
wd	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array
=	O
TRUE	O
;	O
}	O
break	O
;	O
case	O
RC_EX_NLHDY_CHAR	char
:	O
case	O
RC_EX_NAHDY_CHAR	char
:	O
if	O
(	O
hd_ldays	array
[	O
(	O
(	O
month	int
-	O
1	int
)	O
*	O
MONTH_LAST	int
)	O
+	O
(	O
day	int
-	O
1	int
)	O
]	O
)	O
{	O
hd_found	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
if	O
(	O
hd_found	int
||	O
*	O
ptr_date_text	pointer
==	O
RC_EX_NLHDY_CHAR	char
)	O
{	O
if	O
(	O
hd_found	int
)	O
inclusive_weekday_map	array
[	O
wd	int
]	O
=	O
TRUE	O
;	O
*	O
inclusive_weekday_map	array
=	O
TRUE	O
;	O
break	O
;	O
}	O
if	O
(	O
hd_mdays	array
[	O
(	O
(	O
month	int
-	O
1	int
)	O
*	O
MONTH_LAST	int
)	O
+	O
(	O
day	int
-	O
1	int
)	O
]	O
)	O
{	O
hd_found	int
=	O
TRUE	O
;	O
break	O
;	O
}	O
if	O
(	O
hd_found	int
)	O
inclusive_weekday_map	array
[	O
wd	int
]	O
=	O
TRUE	O
;	O
*	O
inclusive_weekday_map	array
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_MON_CHAR	char
:	O
exclusive_weekday_map	array
[	O
DAY_MIN	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NMON_CHAR	char
:	O
*	O
inclusive_weekday_map	array
=	O
inclusive_weekday_map	array
[	O
DAY_MIN	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_TUE_CHAR	char
:	O
exclusive_weekday_map	array
[	O
2	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NTUE_CHAR	char
:	O
*	O
inclusive_weekday_map	array
=	O
inclusive_weekday_map	array
[	O
2	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_WED_CHAR	char
:	O
exclusive_weekday_map	array
[	O
3	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NWED_CHAR	char
:	O
*	O
inclusive_weekday_map	array
=	O
inclusive_weekday_map	array
[	O
3	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_THU_CHAR	char
:	O
exclusive_weekday_map	array
[	O
4	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NTHU_CHAR	char
:	O
*	O
inclusive_weekday_map	array
=	O
inclusive_weekday_map	array
[	O
4	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_FRI_CHAR	char
:	O
exclusive_weekday_map	array
[	O
5	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NFRI_CHAR	char
:	O
*	O
inclusive_weekday_map	array
=	O
inclusive_weekday_map	array
[	O
5	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_SAT_CHAR	char
:	O
exclusive_weekday_map	array
[	O
6	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NSAT_CHAR	char
:	O
*	O
inclusive_weekday_map	array
=	O
inclusive_weekday_map	array
[	O
6	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_SUN_CHAR	char
:	O
exclusive_weekday_map	array
[	O
DAY_MAX	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NSUN_CHAR	char
:	O
*	O
inclusive_weekday_map	array
=	O
inclusive_weekday_map	array
[	O
DAY_MAX	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_MON_2_THU_CHAR	char
:	O
for	O
(	O
i	int
=	O
DAY_MIN	int
;	O
i	int
<=	O
4	int
;	O
i	int
++	O
)	O
exclusive_weekday_map	array
[	O
i	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NMON_2_THU_CHAR	char
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
4	int
;	O
i	int
++	O
)	O
inclusive_weekday_map	array
[	O
i	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_MON_2_FRI_CHAR	char
:	O
for	O
(	O
i	int
=	O
DAY_MIN	int
;	O
i	int
<=	O
5	int
;	O
i	int
++	O
)	O
exclusive_weekday_map	array
[	O
i	int
]	O
=	O
FALSE	O
;	O
*	O
exclusive_weekday_map	array
=	O
TRUE	O
;	O
break	O
;	O
case	O
RC_EX_NMON_2_FRI_CHAR	char
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
5	int
;	O
i	int
++	O
)	O
inclusive_weekday_map	array
[	O
i	int
]	O
=	O
TRUE	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
ptr_date_text	pointer
++	O
;	O
}	O
if	O
(	O
*	O
inclusive_weekday_map	array
||	O
*	O
exclusive_weekday_map	array
)	O
{	O
if	O
(	O
*	O
inclusive_weekday_map	array
&&	O
*	O
exclusive_weekday_map	array
)	O
{	O
if	O
(	O
!	O
inclusive_weekday_map	array
[	O
wd	int
]	O
||	O
!	O
exclusive_weekday_map	array
[	O
wd	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
inclusive_weekday_map	array
)	O
{	O
if	O
(	O
!	O
inclusive_weekday_map	array
[	O
wd	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
exclusive_weekday_map	array
[	O
wd	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
Bool	int
rc_valid_period	function
(	O
date_text	pointer
,	O
d	int
,	O
m	int
,	O
y	int
,	O
incr_year	int
,	O
decr_year	int
)	O
char	O
*	O
date_text	pointer
;	O
const	O
int	O
d	int
;	O
const	O
int	O
m	int
;	O
const	O
int	O
y	int
;	O
const	O
int	O
incr_year	int
;	O
const	O
int	O
decr_year	int
;	O
{	O
auto	O
Slint	long
num	long
;	O
register	O
int	O
i	int
;	O
static	O
Bool	int
inclusive_date_map	array
[	O
DAY_LAST	int
+	O
2	int
]	O
;	O
static	O
Bool	int
exclusive_date_map	array
[	O
DAY_LAST	int
+	O
2	int
]	O
;	O
auto	O
int	O
len	int
;	O
auto	O
int	O
rlen	int
;	O
auto	O
int	O
dd	int
;	O
auto	O
int	O
rdd	int
;	O
auto	O
int	O
mm	int
;	O
auto	O
int	O
rmm	int
;	O
auto	O
int	O
yy	int
;	O
auto	O
int	O
ryy	int
;	O
auto	O
int	O
nn	int
;	O
auto	O
int	O
rnn	int
;	O
auto	O
int	O
hhn	int
;	O
auto	O
int	O
rhn	int
;	O
auto	O
int	O
hhwd	int
;	O
auto	O
int	O
rhwd	int
;	O
auto	O
char	O
*	O
ptr_date_text	pointer
=	O
date_text	pointer
;	O
auto	O
char	O
*	O
ptr_char	pointer
;	O
auto	O
char	O
special_text_char	char
;	O
auto	O
char	O
ch	char
;	O
auto	O
char	O
hhc	char
;	O
auto	O
char	O
rhc	char
;	O
auto	O
Bool	int
is_weekday_mode	pointer
;	O
auto	O
Bool	int
ris_weekday_mode	int
;	O
auto	O
Bool	int
is_range	int
;	O
auto	O
Bool	int
dflt_yy_set	int
;	O
auto	O
Bool	int
dflt_ryy_set	int
;	O
for	O
(	O
i	int
=	O
DAY_MIN	int
;	O
i	int
<	O
DAY_LAST	int
+	O
2	int
;	O
i	int
++	O
)	O
inclusive_date_map	array
[	O
i	int
]	O
=	O
!	O
(	O
exclusive_date_map	array
[	O
i	int
]	O
=	O
TRUE	O
)	O
;	O
*	O
inclusive_date_map	array
=	O
*	O
exclusive_date_map	array
=	O
FALSE	O
;	O
while	O
(	O
*	O
ptr_date_text	pointer
)	O
{	O
rhc	char
=	O
'\0'	O
;	O
rlen	int
=	O
rdd	int
=	O
rmm	int
=	O
ryy	int
=	O
rnn	int
=	O
0	int
;	O
is_range	int
=	O
dflt_yy_set	int
=	O
dflt_ryy_set	int
=	O
FALSE	O
;	O
special_text_char	char
=	O
*	O
ptr_date_text	pointer
++	O
;	O
ptr_char	pointer
=	O
ptr_date_text	pointer
;	O
while	O
(	O
*	O
ptr_date_text	pointer
&&	O
(	O
*	O
ptr_date_text	pointer
!=	O
*	O
SPLIT_SEP	pointer
)	O
&&	O
(	O
*	O
ptr_date_text	pointer
!=	O
RC_DRANGE_CHAR	char
)	O
)	O
ptr_date_text	pointer
++	O
;	O
if	O
(	O
*	O
ptr_date_text	pointer
==	O
RC_DRANGE_CHAR	char
)	O
is_range	int
=	O
TRUE	O
;	O
ch	char
=	O
*	O
ptr_date_text	pointer
;	O
*	O
ptr_date_text	pointer
=	O
'\0'	O
;	O
(	O
void	O
)	O
rc_get_date	function
(	O
ptr_char	pointer
,	O
lptrs3	pointer
,	O
FALSE	O
,	O
&	O
is_weekday_mode	pointer
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
yy	int
,	O
&	O
nn	int
,	O
&	O
len	int
,	O
&	O
hhc	char
,	O
&	O
hhn	int
,	O
&	O
hhwd	int
,	O
_	O
(	O
"Internal"	pointer
)	O
,	O
-	O
1L	int
,	O
date_text	pointer
,	O
FALSE	O
)	O
;	O
if	O
(	O
yy	int
==	O
SPECIAL_VALUE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: invalid date given -- %s\n%s\n%s\n"	pointer
)	O
,	O
prgr_name	pointer
,	O
date_text	pointer
,	O
usage_msg	function
(	O
)	O
,	O
lopt_msg	function
(	O
)	O
)	O
;	O
my_exit	function
(	O
ERR_INVALID_OPTION	int
)	O
;	O
}	O
*	O
ptr_date_text	pointer
=	O
ch	char
;	O
if	O
(	O
is_range	int
)	O
{	O
ptr_char	pointer
=	O
++	O
ptr_date_text	pointer
;	O
while	O
(	O
*	O
ptr_date_text	pointer
&&	O
(	O
*	O
ptr_date_text	pointer
!=	O
*	O
SPLIT_SEP	pointer
)	O
)	O
ptr_date_text	pointer
++	O
;	O
ch	char
=	O
*	O
ptr_date_text	pointer
;	O
*	O
ptr_date_text	pointer
=	O
'\0'	O
;	O
(	O
void	O
)	O
rc_get_date	function
(	O
ptr_char	pointer
,	O
lptrs3	pointer
,	O
FALSE	O
,	O
&	O
ris_weekday_mode	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
&	O
ryy	int
,	O
&	O
rnn	int
,	O
&	O
rlen	int
,	O
&	O
rhc	char
,	O
&	O
rhn	int
,	O
&	O
rhwd	int
,	O
_	O
(	O
"Internal"	pointer
)	O
,	O
-	O
1L	int
,	O
date_text	pointer
,	O
FALSE	O
)	O
;	O
if	O
(	O
ryy	int
==	O
SPECIAL_VALUE	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: invalid date given -- %s\n%s\n%s\n"	pointer
)	O
,	O
prgr_name	pointer
,	O
date_text	pointer
,	O
usage_msg	function
(	O
)	O
,	O
lopt_msg	function
(	O
)	O
)	O
;	O
my_exit	function
(	O
ERR_INVALID_OPTION	int
)	O
;	O
}	O
*	O
ptr_date_text	pointer
=	O
ch	char
;	O
}	O
if	O
(	O
ch	char
)	O
ptr_date_text	pointer
++	O
;	O
if	O
(	O
!	O
len	int
)	O
dflt_yy_set	int
=	O
TRUE	O
;	O
if	O
(	O
!	O
rlen	int
)	O
dflt_ryy_set	int
=	O
TRUE	O
;	O
if	O
(	O
!	O
yy	int
)	O
{	O
if	O
(	O
dflt_yy_set	int
)	O
yy	int
=	O
YEAR_MIN	int
;	O
else	O
{	O
yy	int
=	O
year	int
;	O
if	O
(	O
y	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
yy	int
=	O
y	int
;	O
}	O
}	O
if	O
(	O
!	O
ryy	int
)	O
{	O
if	O
(	O
dflt_ryy_set	int
)	O
ryy	int
=	O
YEAR_MAX	int
;	O
else	O
{	O
ryy	int
=	O
year	int
;	O
if	O
(	O
y	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
ryy	int
=	O
y	int
;	O
}	O
}	O
if	O
(	O
!	O
dflt_yy_set	int
&&	O
(	O
yy	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
{	O
yy	int
-=	O
incr_year	int
;	O
yy	int
+=	O
decr_year	int
;	O
}	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
ryy	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
{	O
ryy	int
-=	O
incr_year	int
;	O
ryy	int
+=	O
decr_year	int
;	O
}	O
switch	O
(	O
hhc	char
)	O
{	O
case	O
RC_EASTER_CHAR	char
:	O
case	O
RC_TODAY_CHAR	char
:	O
if	O
(	O
!	O
dflt_yy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
if	O
(	O
!	O
precomp_date	function
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
yy	int
+	O
incr_year	int
,	O
(	O
hhc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
yy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
!	O
precomp_date	function
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
yy	int
,	O
(	O
hhc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
yy	int
=	O
SPECIAL_VALUE	O
;	O
break	O
;	O
case	O
'D'	O
:	O
case	O
'W'	O
:	O
if	O
(	O
!	O
dflt_yy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
auto	O
int	O
fiscal_year	int
=	O
yy	int
+	O
incr_year	int
;	O
if	O
(	O
!	O
precomp_nth_wd	function
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
hhn	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
fiscal_year	int
,	O
(	O
hhc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
yy	int
=	O
fiscal_year	int
;	O
}	O
else	O
(	O
void	O
)	O
precomp_nth_wd	function
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
hhn	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
yy	int
,	O
(	O
hhc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
islower	function
(	O
hhc	char
)	O
)	O
{	O
if	O
(	O
rc_dvar	array
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
)	O
{	O
mm	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
;	O
dd	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_day	char
;	O
}	O
else	O
if	O
(	O
rc_dvar	array
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_month	char
)	O
{	O
mm	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_month	char
;	O
dd	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
hhc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_day	char
;	O
}	O
if	O
(	O
!	O
dflt_yy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
if	O
(	O
!	O
precomp_date	function
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
yy	int
+	O
incr_year	int
,	O
DVar	int
)	O
)	O
yy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
!	O
precomp_date	function
(	O
hhn	int
,	O
hhwd	int
,	O
&	O
dd	int
,	O
&	O
mm	int
,	O
yy	int
,	O
DVar	int
)	O
)	O
yy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
switch	O
(	O
rhc	char
)	O
{	O
case	O
RC_EASTER_CHAR	char
:	O
case	O
RC_TODAY_CHAR	char
:	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
if	O
(	O
!	O
precomp_date	function
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
ryy	int
+	O
incr_year	int
,	O
(	O
rhc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
ryy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
!	O
precomp_date	function
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
ryy	int
,	O
(	O
rhc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
ryy	int
=	O
SPECIAL_VALUE	O
;	O
break	O
;	O
case	O
'D'	O
:	O
case	O
'W'	O
:	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
auto	O
int	O
fiscal_year	int
=	O
ryy	int
+	O
incr_year	int
;	O
if	O
(	O
!	O
precomp_nth_wd	function
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rhn	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
&	O
fiscal_year	int
,	O
(	O
rhc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
ryy	int
=	O
fiscal_year	int
;	O
}	O
else	O
(	O
void	O
)	O
precomp_nth_wd	function
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rhn	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
&	O
ryy	int
,	O
(	O
rhc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
islower	function
(	O
rhc	char
)	O
)	O
{	O
if	O
(	O
rc_dvar	array
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
)	O
{	O
rmm	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
;	O
rdd	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_day	char
;	O
}	O
else	O
if	O
(	O
rc_dvar	array
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_month	char
)	O
{	O
rmm	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_month	char
;	O
rdd	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
rhc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_day	char
;	O
}	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
{	O
if	O
(	O
!	O
precomp_date	function
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
ryy	int
+	O
incr_year	int
,	O
DVar	int
)	O
)	O
ryy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
!	O
precomp_date	function
(	O
rhn	int
,	O
rhwd	int
,	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
ryy	int
,	O
DVar	int
)	O
)	O
ryy	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
if	O
(	O
len	int
>	O
len_year_max	int
)	O
len	int
-=	O
len_year_max	int
;	O
else	O
len	int
=	O
0	int
;	O
if	O
(	O
rlen	int
>	O
len_year_max	int
)	O
rlen	int
-=	O
len_year_max	int
;	O
else	O
rlen	int
=	O
0	int
;	O
if	O
(	O
!	O
mm	int
)	O
{	O
if	O
(	O
len	int
>=	O
1	int
)	O
{	O
mm	int
=	O
m	int
;	O
if	O
(	O
len	int
==	O
2	int
)	O
len	int
=	O
0	int
;	O
else	O
len	int
--	O
;	O
}	O
else	O
mm	int
=	O
MONTH_MIN	int
;	O
}	O
else	O
{	O
if	O
(	O
len	int
==	O
2	int
)	O
len	int
=	O
0	int
;	O
else	O
len	int
--	O
;	O
}	O
if	O
(	O
!	O
dd	int
)	O
{	O
if	O
(	O
len	int
>=	O
1	int
)	O
dd	int
=	O
d	int
;	O
else	O
dd	int
=	O
DAY_MIN	int
;	O
}	O
if	O
(	O
!	O
rmm	int
)	O
{	O
if	O
(	O
rlen	int
>=	O
1	int
)	O
{	O
rmm	int
=	O
m	int
;	O
if	O
(	O
rlen	int
==	O
2	int
)	O
rlen	int
=	O
0	int
;	O
else	O
rlen	int
--	O
;	O
}	O
else	O
rmm	int
=	O
MONTH_MAX	int
;	O
}	O
else	O
{	O
if	O
(	O
rlen	int
==	O
2	int
)	O
rlen	int
=	O
0	int
;	O
else	O
rlen	int
--	O
;	O
}	O
if	O
(	O
!	O
rdd	int
)	O
{	O
if	O
(	O
rlen	int
>=	O
1	int
)	O
rdd	int
=	O
d	int
;	O
else	O
{	O
if	O
(	O
rmm	int
==	O
2	int
)	O
{	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
rdd	int
=	O
days_of_february	function
(	O
ryy	int
+	O
incr_year	int
)	O
;	O
else	O
rdd	int
=	O
days_of_february	function
(	O
ryy	int
)	O
;	O
}	O
else	O
rdd	int
=	O
dvec	array
[	O
rmm	int
-	O
1	int
]	O
;	O
}	O
}	O
if	O
(	O
dd	int
==	O
99	int
)	O
{	O
if	O
(	O
mm	int
==	O
2	int
)	O
dd	int
=	O
days_of_february	function
(	O
yy	int
)	O
;	O
else	O
dd	int
=	O
dvec	array
[	O
mm	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
rdd	int
==	O
99	int
)	O
{	O
if	O
(	O
rmm	int
==	O
2	int
)	O
{	O
if	O
(	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
rdd	int
=	O
days_of_february	function
(	O
ryy	int
+	O
incr_year	int
)	O
;	O
else	O
rdd	int
=	O
days_of_february	function
(	O
ryy	int
)	O
;	O
}	O
else	O
rdd	int
=	O
dvec	array
[	O
rmm	int
-	O
1	int
]	O
;	O
}	O
if	O
(	O
nn	int
)	O
nth_weekday_of_month	function
(	O
&	O
dd	int
,	O
&	O
mm	int
,	O
&	O
yy	int
,	O
&	O
nn	int
,	O
&	O
is_weekday_mode	pointer
)	O
;	O
if	O
(	O
rnn	int
)	O
nth_weekday_of_month	function
(	O
&	O
rdd	int
,	O
&	O
rmm	int
,	O
&	O
ryy	int
,	O
&	O
rnn	int
,	O
&	O
ris_weekday_mode	int
)	O
;	O
if	O
(	O
(	O
!	O
is_range	int
&&	O
(	O
yy	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
||	O
(	O
is_range	int
&&	O
(	O
yy	int
!=	O
SPECIAL_VALUE	O
)	O
&&	O
(	O
ryy	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
)	O
{	O
register	O
int	O
true_year	int
=	O
(	O
y	int
)	O
?	O
y	int
:	O
year	int
+	O
incr_year	int
;	O
if	O
(	O
!	O
nn	int
&&	O
!	O
dflt_yy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
||	O
(	O
incr_year	int
&&	O
(	O
rc_tomorrow_flag	int
||	O
rc_week_flag	int
)	O
)	O
)	O
)	O
yy	int
+=	O
incr_year	int
;	O
if	O
(	O
!	O
rnn	int
&&	O
!	O
dflt_ryy_set	int
&&	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
||	O
(	O
incr_year	int
&&	O
(	O
rc_tomorrow_flag	int
||	O
rc_week_flag	int
)	O
)	O
)	O
)	O
ryy	int
+=	O
incr_year	int
;	O
num	long
=	O
d_between	function
(	O
dd	int
,	O
mm	int
,	O
yy	int
,	O
rdd	int
,	O
rmm	int
,	O
ryy	int
)	O
;	O
if	O
(	O
num	long
>=	O
0L	int
)	O
{	O
register	O
int	O
s_doy	int
=	O
DAY_MIN	int
;	O
register	O
int	O
e_doy	int
=	O
DAY_LAST	int
+	O
1	int
;	O
if	O
(	O
special_text_char	char
==	O
RC_IDATE_CHAR	char
)	O
*	O
inclusive_date_map	array
=	O
TRUE	O
;	O
else	O
*	O
exclusive_date_map	array
=	O
TRUE	O
;	O
if	O
(	O
yy	int
==	O
true_year	int
)	O
s_doy	int
=	O
day_of_year	function
(	O
dd	int
,	O
mm	int
,	O
yy	int
)	O
;	O
else	O
if	O
(	O
yy	int
>	O
true_year	int
)	O
s_doy	int
=	O
SPECIAL_VALUE	O
;	O
if	O
(	O
ryy	int
==	O
true_year	int
)	O
e_doy	int
=	O
day_of_year	function
(	O
rdd	int
,	O
rmm	int
,	O
ryy	int
)	O
;	O
else	O
if	O
(	O
ryy	int
<	O
true_year	int
)	O
e_doy	int
=	O
SPECIAL_VALUE	O
;	O
if	O
(	O
(	O
s_doy	int
!=	O
SPECIAL_VALUE	O
)	O
&&	O
(	O
e_doy	int
!=	O
SPECIAL_VALUE	O
)	O
)	O
{	O
if	O
(	O
special_text_char	char
==	O
RC_IDATE_CHAR	char
)	O
for	O
(	O
i	int
=	O
s_doy	int
;	O
i	int
<=	O
e_doy	int
;	O
i	int
++	O
)	O
inclusive_date_map	array
[	O
i	int
]	O
=	O
TRUE	O
;	O
else	O
for	O
(	O
i	int
=	O
s_doy	int
;	O
i	int
<=	O
e_doy	int
;	O
i	int
++	O
)	O
exclusive_date_map	array
[	O
i	int
]	O
=	O
FALSE	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
*	O
inclusive_date_map	array
||	O
*	O
exclusive_date_map	array
)	O
{	O
i	int
=	O
day_of_year	function
(	O
d	int
,	O
m	int
,	O
year	int
+	O
incr_year	int
-	O
decr_year	int
)	O
;	O
if	O
(	O
*	O
inclusive_date_map	array
&&	O
*	O
exclusive_date_map	array
)	O
{	O
if	O
(	O
!	O
inclusive_date_map	array
[	O
i	int
]	O
||	O
!	O
exclusive_date_map	array
[	O
i	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
inclusive_date_map	array
)	O
{	O
if	O
(	O
!	O
inclusive_date_map	array
[	O
i	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
exclusive_date_map	array
[	O
i	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
void	O
rc_clean_flags	function
(	O
)	O
{	O
rc_tomorrow_flag	int
=	O
rc_week_flag	int
=	O
rc_month_flag	int
=	O
rc_year_flag	int
=	O
rc_week_year_flag	int
=	O
rc_forwards_flag	int
=	O
rc_backwards_flag	int
=	O
rc_period_flag	int
=	O
FALSE	O
;	O
}	O
Line_struct	struct
*	O
rc_get_date	function
(	O
the_line	pointer
,	O
lineptrs	pointer
,	O
is_rc_file	int
,	O
is_weekday_mode	pointer
,	O
d	int
,	O
m	int
,	O
y	int
,	O
n	long
,	O
len	int
,	O
hc	char
,	O
hn	int
,	O
hwd	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
on_error_exit	int
)	O
char	O
*	O
the_line	pointer
;	O
Line_struct	struct
*	O
lineptrs	pointer
;	O
const	O
Bool	int
is_rc_file	int
;	O
Bool	int
*	O
is_weekday_mode	pointer
;	O
int	O
*	O
d	int
;	O
int	O
*	O
m	int
;	O
int	O
*	O
y	int
;	O
int	O
*	O
n	long
;	O
int	O
*	O
len	int
;	O
char	O
*	O
hc	char
;	O
int	O
*	O
hn	int
;	O
int	O
*	O
hwd	int
;	O
const	O
char	O
*	O
filename	pointer
;	O
const	O
long	O
line_number	long
;	O
const	O
char	O
*	O
line_buffer	pointer
;	O
const	O
Bool	int
on_error_exit	int
;	O
{	O
register	O
int	O
num_of_range_chars	int
=	O
0	int
;	O
register	O
int	O
num_of_repeat_chars	int
=	O
0	int
;	O
register	O
int	O
num_of_appears_chars	int
=	O
0	int
;	O
register	O
int	O
i	int
;	O
static	O
char	O
str7	array
[	O
8	int
]	O
;	O
auto	O
char	O
*	O
ptr_char	pointer
;	O
auto	O
Bool	int
is_hdy_mode	int
=	O
FALSE	O
;	O
*	O
hc	char
=	O
'\0'	O
;	O
lineptrs	pointer
->	O
day_list	int
=	O
lineptrs	pointer
->	O
day_range	int
=	O
FALSE	O
;	O
lineptrs	pointer
->	O
repeat_part	pointer
=	O
lineptrs	pointer
->	O
appears_part	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
(	O
*	O
len	int
)	O
=	O
(	O
*	O
hn	int
)	O
=	O
(	O
*	O
hwd	int
)	O
=	O
(	O
*	O
n	long
)	O
=	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
the_line	pointer
&&	O
!	O
isspace	function
(	O
*	O
the_line	pointer
)	O
&&	O
isdigit	function
(	O
*	O
the_line	pointer
)	O
&&	O
(	O
i	int
<	O
len_year_max	int
)	O
)	O
str7	array
[	O
i	int
++	O
]	O
=	O
*	O
the_line	pointer
++	O
;	O
str7	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
*	O
y	int
=	O
my_atoi	function
(	O
str7	array
)	O
;	O
*	O
len	int
=	O
i	int
;	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
the_line	pointer
&&	O
!	O
isspace	function
(	O
*	O
the_line	pointer
)	O
&&	O
(	O
i	int
<	O
2	int
)	O
)	O
str7	array
[	O
i	int
++	O
]	O
=	O
*	O
the_line	pointer
++	O
;	O
if	O
(	O
i	int
)	O
if	O
(	O
isalpha	function
(	O
*	O
the_line	pointer
)	O
&&	O
(	O
isupper	function
(	O
str7	array
[	O
i	int
-	O
1	int
]	O
)	O
||	O
str7	array
[	O
i	int
-	O
1	int
]	O
==	O
'"'	O
||	O
islower	function
(	O
str7	array
[	O
i	int
-	O
1	int
]	O
)	O
)	O
)	O
str7	array
[	O
i	int
++	O
]	O
=	O
*	O
the_line	pointer
++	O
;	O
str7	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
*	O
m	int
=	O
my_atoi	function
(	O
str7	array
)	O
;	O
if	O
(	O
!	O
*	O
m	int
)	O
*	O
m	int
=	O
compare_d_m_name	function
(	O
str7	array
,	O
MOnth	int
)	O
;	O
else	O
if	O
(	O
i	int
==	O
3	int
||	O
(	O
(	O
i	int
==	O
2	int
)	O
&&	O
(	O
!	O
isdigit	function
(	O
str7	array
[	O
1	int
]	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_MONTH_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
*	O
m	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
i	int
)	O
{	O
*	O
len	int
+=	O
i	int
;	O
if	O
(	O
*	O
str7	array
==	O
RC_HDY_CHAR	char
)	O
{	O
is_hdy_mode	int
=	O
TRUE	O
;	O
if	O
(	O
i	int
==	O
2	int
)	O
*	O
hc	char
=	O
(	O
char	O
)	O
tolower	function
(	O
str7	array
[	O
1	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
*	O
str7	array
==	O
RC_NWD_CHAR	char
)	O
{	O
is_hdy_mode	int
=	O
TRUE	O
;	O
if	O
(	O
(	O
i	int
==	O
2	int
)	O
&&	O
(	O
toupper	function
(	O
str7	array
[	O
1	int
]	O
)	O
==	O
'D'	O
||	O
toupper	function
(	O
str7	array
[	O
1	int
]	O
)	O
==	O
'W'	O
)	O
)	O
*	O
hc	char
=	O
(	O
char	O
)	O
toupper	function
(	O
str7	array
[	O
1	int
]	O
)	O
;	O
else	O
{	O
if	O
(	O
i	int
==	O
2	int
)	O
*	O
hc	char
=	O
(	O
char	O
)	O
toupper	function
(	O
str7	array
[	O
1	int
]	O
)	O
;	O
else	O
*	O
hc	char
=	O
*	O
str7	array
;	O
}	O
}	O
}	O
if	O
(	O
*	O
m	int
==	O
99	int
)	O
*	O
m	int
=	O
MONTH_MAX	int
;	O
if	O
(	O
!	O
is_hdy_mode	int
&&	O
(	O
*	O
m	int
>	O
MONTH_MAX	int
||	O
(	O
!	O
*	O
m	int
&&	O
(	O
(	O
(	O
i	int
==	O
1	int
)	O
&&	O
!	O
isdigit	function
(	O
*	O
str7	array
)	O
)	O
||	O
(	O
(	O
i	int
==	O
2	int
)	O
&&	O
(	O
!	O
isdigit	function
(	O
*	O
str7	array
)	O
||	O
!	O
isdigit	function
(	O
str7	array
[	O
1	int
]	O
)	O
)	O
)	O
||	O
(	O
(	O
i	int
==	O
3	int
)	O
&&	O
(	O
!	O
isdigit	function
(	O
*	O
str7	array
)	O
||	O
!	O
isdigit	function
(	O
str7	array
[	O
1	int
]	O
)	O
||	O
!	O
isdigit	function
(	O
str7	array
[	O
2	int
]	O
)	O
)	O
)	O
)	O
)	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_MONTH_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
*	O
m	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
ptr_char	pointer
=	O
lineptrs	pointer
->	O
day_part	pointer
=	O
the_line	pointer
;	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
the_line	pointer
&&	O
!	O
isspace	function
(	O
*	O
the_line	pointer
)	O
&&	O
(	O
i	int
<	O
(	O
(	O
is_hdy_mode	int
)	O
?	O
7	int
:	O
3	int
)	O
)	O
)	O
str7	array
[	O
i	int
++	O
]	O
=	O
*	O
the_line	pointer
++	O
;	O
str7	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
*	O
d	int
=	O
atoi	function
(	O
str7	array
)	O
;	O
*	O
len	int
+=	O
i	int
;	O
*	O
is_weekday_mode	pointer
=	O
FALSE	O
;	O
the_line	pointer
--	O
;	O
if	O
(	O
isalpha	function
(	O
*	O
the_line	pointer
)	O
||	O
(	O
(	O
i	int
<	O
3	int
)	O
&&	O
!	O
is_hdy_mode	int
)	O
)	O
the_line	pointer
++	O
;	O
while	O
(	O
*	O
ptr_char	pointer
&&	O
!	O
isspace	function
(	O
*	O
ptr_char	pointer
)	O
)	O
{	O
if	O
(	O
*	O
ptr_char	pointer
==	O
RC_DLIST_CHAR	char
)	O
lineptrs	pointer
->	O
day_list	int
=	O
TRUE	O
;	O
else	O
if	O
(	O
*	O
ptr_char	pointer
==	O
RC_DRANGE_CHAR	char
)	O
{	O
num_of_range_chars	int
++	O
;	O
lineptrs	pointer
->	O
day_range	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
*	O
ptr_char	pointer
==	O
RC_REPEAT_CHAR	char
)	O
{	O
num_of_repeat_chars	int
++	O
;	O
lineptrs	pointer
->	O
repeat_part	pointer
=	O
ptr_char	pointer
;	O
}	O
else	O
if	O
(	O
*	O
ptr_char	pointer
==	O
RC_APPEARS_CHAR	char
)	O
{	O
num_of_appears_chars	int
++	O
;	O
lineptrs	pointer
->	O
appears_part	pointer
=	O
ptr_char	pointer
;	O
}	O
ptr_char	pointer
++	O
;	O
}	O
if	O
(	O
lineptrs	pointer
->	O
day_list	int
||	O
lineptrs	pointer
->	O
day_range	int
)	O
{	O
if	O
(	O
is_rc_file	int
)	O
{	O
if	O
(	O
(	O
num_of_range_chars	int
>	O
1	int
||	O
*	O
ptr_char	pointer
==	O
RC_DLIST_CHAR	char
||	O
*	O
ptr_char	pointer
==	O
RC_DRANGE_CHAR	char
||	O
(	O
lineptrs	pointer
->	O
day_list	int
&&	O
lineptrs	pointer
->	O
day_range	int
)	O
||	O
(	O
!	O
lineptrs	pointer
->	O
day_list	int
&&	O
!	O
lineptrs	pointer
->	O
day_range	int
&&	O
(	O
num_of_repeat_chars	int
>	O
1	int
||	O
num_of_appears_chars	int
>	O
1	int
)	O
)	O
)	O
&&	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
0	int
)	O
;	O
if	O
(	O
islower	function
(	O
*	O
hc	char
)	O
&&	O
(	O
*	O
hc	char
!=	O
RC_EASTER_CHAR	char
)	O
&&	O
(	O
*	O
hc	char
!=	O
RC_TODAY_CHAR	char
)	O
)	O
{	O
if	O
(	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
||	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_month	char
)	O
{	O
if	O
(	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
)	O
{	O
*	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
;	O
*	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_day	char
;	O
}	O
else	O
{	O
*	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_month	char
;	O
*	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_day	char
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
warning_level	int
>=	O
0	int
)	O
&&	O
on_error_exit	int
)	O
var_warning	function
(	O
ERR_INVALID_VAR_REFERENCE	int
,	O
(	O
int	O
)	O
*	O
hc	char
,	O
line_buffer	pointer
,	O
filename	pointer
,	O
line_number	long
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
if	O
(	O
!	O
isalpha	function
(	O
str7	array
[	O
i	int
-	O
1	int
]	O
)	O
)	O
(	O
*	O
len	int
)	O
--	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
*	O
the_line	pointer
&&	O
!	O
isspace	function
(	O
*	O
the_line	pointer
)	O
)	O
{	O
the_line	pointer
++	O
;	O
i	int
++	O
;	O
}	O
*	O
len	int
+=	O
i	int
;	O
}	O
else	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
is_rc_file	int
&&	O
(	O
num_of_repeat_chars	int
||	O
num_of_appears_chars	int
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
else	O
if	O
(	O
num_of_repeat_chars	int
>	O
1	int
||	O
num_of_appears_chars	int
>	O
1	int
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
lineptrs	pointer
->	O
day_part	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
if	O
(	O
lineptrs	pointer
->	O
day_part	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
!	O
is_hdy_mode	int
)	O
{	O
if	O
(	O
!	O
*	O
d	int
)	O
{	O
if	O
(	O
*	O
str7	array
)	O
*	O
d	int
=	O
compare_d_m_name	function
(	O
str7	array
,	O
DAy	int
)	O
;	O
if	O
(	O
*	O
d	int
)	O
{	O
*	O
is_weekday_mode	pointer
=	O
TRUE	O
;	O
if	O
(	O
isdigit	function
(	O
str7	array
[	O
i	int
-	O
1	int
]	O
)	O
)	O
(	O
*	O
len	int
)	O
--	O
;	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
isdigit	function
(	O
str7	array
[	O
i	int
]	O
)	O
)	O
i	int
++	O
;	O
if	O
(	O
str7	array
[	O
i	int
]	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_DAY_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
*	O
d	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
i	int
>	O
1	int
)	O
&&	O
!	O
isdigit	function
(	O
str7	array
[	O
1	int
]	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_DAY_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
*	O
d	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
*	O
the_line	pointer
&&	O
!	O
isspace	function
(	O
*	O
the_line	pointer
)	O
)	O
{	O
if	O
(	O
isdigit	function
(	O
*	O
the_line	pointer
)	O
)	O
{	O
*	O
n	long
=	O
CHR2DIG	O
(	O
*	O
the_line	pointer
)	O
;	O
if	O
(	O
*	O
n	long
)	O
{	O
if	O
(	O
(	O
*	O
n	long
>	O
5	int
)	O
&&	O
(	O
*	O
n	long
<	O
9	int
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_NWD_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
*	O
n	long
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
lineptrs	pointer
->	O
repeat_part	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
lineptrs	pointer
->	O
appears_part	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_NO_SEPARATOR_CHAR	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
*	O
the_line	pointer
)	O
the_line	pointer
++	O
;	O
if	O
(	O
*	O
the_line	pointer
&&	O
!	O
isspace	function
(	O
*	O
the_line	pointer
)	O
&&	O
(	O
lineptrs	pointer
->	O
repeat_part	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
lineptrs	pointer
->	O
appears_part	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_NO_SEPARATOR_CHAR	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
*	O
n	long
&&	O
(	O
*	O
d	int
<	O
DAY_MIN	int
||	O
*	O
d	int
>	O
DAY_MAX	int
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_DAY_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
*	O
d	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
(	O
*	O
len	int
)	O
++	O
;	O
if	O
(	O
lineptrs	pointer
->	O
repeat_part	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
||	O
lineptrs	pointer
->	O
appears_part	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
while	O
(	O
*	O
the_line	pointer
&&	O
!	O
isspace	function
(	O
*	O
the_line	pointer
)	O
)	O
{	O
the_line	pointer
++	O
;	O
(	O
*	O
len	int
)	O
++	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
isdigit	function
(	O
*	O
the_line	pointer
)	O
)	O
the_line	pointer
++	O
;	O
if	O
(	O
*	O
the_line	pointer
&&	O
!	O
isspace	function
(	O
*	O
the_line	pointer
)	O
&&	O
(	O
lineptrs	pointer
->	O
repeat_part	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
(	O
lineptrs	pointer
->	O
appears_part	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_NO_SEPARATOR_CHAR	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
0	int
)	O
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
i	int
=	O
atoi	function
(	O
str7	array
)	O
;	O
ptr_char	pointer
=	O
str7	array
;	O
if	O
(	O
islower	function
(	O
*	O
hc	char
)	O
)	O
{	O
if	O
(	O
*	O
ptr_char	pointer
==	O
*	O
ASC_LIT	pointer
||	O
*	O
ptr_char	pointer
==	O
*	O
DES_LIT	pointer
)	O
ptr_char	pointer
++	O
;	O
if	O
(	O
*	O
ptr_char	pointer
==	O
*	O
ASC_LIT	pointer
||	O
*	O
ptr_char	pointer
==	O
*	O
DES_LIT	pointer
||	O
isalpha	function
(	O
*	O
ptr_char	pointer
)	O
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
0	int
)	O
;	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
ptr_char	pointer
==	O
*	O
ASC_LIT	pointer
||	O
*	O
ptr_char	pointer
==	O
*	O
DES_LIT	pointer
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
0	int
)	O
;	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
while	O
(	O
isdigit	function
(	O
*	O
ptr_char	pointer
)	O
)	O
ptr_char	pointer
++	O
;	O
if	O
(	O
*	O
ptr_char	pointer
&&	O
(	O
*	O
ptr_char	pointer
!=	O
RC_REPEAT_CHAR	char
)	O
&&	O
(	O
*	O
ptr_char	pointer
!=	O
RC_APPEARS_CHAR	char
)	O
)	O
{	O
*	O
hwd	int
=	O
compare_d_m_name	function
(	O
ptr_char	pointer
,	O
DAy	int
)	O
;	O
if	O
(	O
!	O
*	O
hwd	int
)	O
{	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
0	int
)	O
;	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
if	O
(	O
*	O
y	int
>=	O
0	int
)	O
{	O
if	O
(	O
*	O
hc	char
==	O
RC_EASTER_CHAR	char
||	O
*	O
hc	char
==	O
RC_TODAY_CHAR	char
)	O
{	O
if	O
(	O
!	O
precomp_date	function
(	O
i	int
,	O
*	O
hwd	int
,	O
d	int
,	O
m	int
,	O
*	O
y	int
,	O
(	O
*	O
hc	char
==	O
RC_EASTER_CHAR	char
)	O
?	O
EAster	int
:	O
TOday	int
)	O
)	O
{	O
if	O
(	O
!	O
*	O
y	int
)	O
{	O
*	O
hn	int
=	O
i	int
;	O
*	O
d	int
=	O
(	O
*	O
m	int
)	O
=	O
0	int
;	O
}	O
else	O
{	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
*	O
hc	char
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
islower	function
(	O
*	O
hc	char
)	O
)	O
{	O
if	O
(	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
||	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_month	char
)	O
{	O
if	O
(	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
)	O
{	O
*	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
;	O
*	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_day	char
;	O
}	O
else	O
{	O
*	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_month	char
;	O
*	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
hc	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_day	char
;	O
}	O
if	O
(	O
!	O
precomp_date	function
(	O
i	int
,	O
*	O
hwd	int
,	O
d	int
,	O
m	int
,	O
*	O
y	int
,	O
DVar	int
)	O
)	O
{	O
if	O
(	O
!	O
*	O
y	int
)	O
*	O
hn	int
=	O
i	int
;	O
else	O
{	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
*	O
hc	char
=	O
'\0'	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
warning_level	int
>=	O
0	int
)	O
&&	O
on_error_exit	int
)	O
var_warning	function
(	O
ERR_INVALID_VAR_REFERENCE	int
,	O
(	O
int	O
)	O
*	O
hc	char
,	O
line_buffer	pointer
,	O
filename	pointer
,	O
line_number	long
)	O
;	O
*	O
hc	char
=	O
'\0'	O
;	O
*	O
d	int
=	O
0	int
;	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
hc	char
==	O
'D'	O
||	O
*	O
hc	char
==	O
'W'	O
)	O
{	O
if	O
(	O
*	O
y	int
==	O
0	int
)	O
{	O
*	O
hn	int
=	O
i	int
;	O
*	O
d	int
=	O
0	int
;	O
*	O
m	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
precomp_nth_wd	function
(	O
i	int
,	O
*	O
hwd	int
,	O
hn	int
,	O
d	int
,	O
m	int
,	O
y	int
,	O
(	O
*	O
hc	char
==	O
'D'	O
)	O
?	O
DAy	int
:	O
WEek	int
)	O
)	O
*	O
hc	char
=	O
'\0'	O
;	O
}	O
else	O
if	O
(	O
on_error_exit	int
)	O
my_error	function
(	O
ERR_INVALID_DATE_FIELD	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
lineptrs	pointer
->	O
repeat_part	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
||	O
lineptrs	pointer
->	O
appears_part	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
while	O
(	O
*	O
the_line	pointer
&&	O
!	O
isspace	function
(	O
*	O
the_line	pointer
)	O
)	O
{	O
the_line	pointer
++	O
;	O
(	O
*	O
len	int
)	O
++	O
;	O
}	O
if	O
(	O
*	O
the_line	pointer
)	O
the_line	pointer
++	O
;	O
}	O
}	O
if	O
(	O
is_rc_file	int
)	O
{	O
if	O
(	O
lineptrs	pointer
->	O
day_part	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	pointer
=	O
lineptrs	pointer
->	O
day_part	pointer
;	O
i	int
=	O
0	int
;	O
LOOP	O
{	O
if	O
(	O
!	O
*	O
ptr_char	pointer
||	O
isspace	function
(	O
*	O
ptr_char	pointer
)	O
)	O
break	O
;	O
i	int
++	O
;	O
ptr_char	pointer
++	O
;	O
}	O
ptr_char	pointer
=	O
lineptrs	pointer
->	O
day_part	pointer
;	O
lineptrs	pointer
->	O
day_part	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
i	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"lineptrs->day_part"	pointer
,	O
0	int
)	O
;	O
strncpy	function
(	O
lineptrs	pointer
->	O
day_part	pointer
,	O
ptr_char	pointer
,	O
i	int
)	O
;	O
lineptrs	pointer
->	O
day_part	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
lineptrs	pointer
->	O
repeat_part	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	pointer
=	O
lineptrs	pointer
->	O
repeat_part	pointer
;	O
i	int
=	O
0	int
;	O
LOOP	O
{	O
if	O
(	O
!	O
*	O
ptr_char	pointer
||	O
isspace	function
(	O
*	O
ptr_char	pointer
)	O
)	O
break	O
;	O
i	int
++	O
;	O
ptr_char	pointer
++	O
;	O
}	O
ptr_char	pointer
=	O
lineptrs	pointer
->	O
repeat_part	pointer
;	O
lineptrs	pointer
->	O
repeat_part	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
i	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"lineptrs->repeat_part"	pointer
,	O
0	int
)	O
;	O
strncpy	function
(	O
lineptrs	pointer
->	O
repeat_part	pointer
,	O
ptr_char	pointer
,	O
i	int
)	O
;	O
lineptrs	pointer
->	O
repeat_part	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
lineptrs	pointer
->	O
appears_part	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
ptr_char	pointer
=	O
lineptrs	pointer
->	O
appears_part	pointer
;	O
i	int
=	O
0	int
;	O
LOOP	O
{	O
if	O
(	O
!	O
*	O
ptr_char	pointer
||	O
isspace	function
(	O
*	O
ptr_char	pointer
)	O
)	O
break	O
;	O
i	int
++	O
;	O
ptr_char	pointer
++	O
;	O
}	O
ptr_char	pointer
=	O
lineptrs	pointer
->	O
appears_part	pointer
;	O
lineptrs	pointer
->	O
appears_part	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
i	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"lineptrs->appears_part"	pointer
,	O
0	int
)	O
;	O
strncpy	function
(	O
lineptrs	pointer
->	O
appears_part	pointer
,	O
ptr_char	pointer
,	O
i	int
)	O
;	O
lineptrs	pointer
->	O
appears_part	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
(	O
lineptrs	pointer
->	O
repeat_part	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
||	O
lineptrs	pointer
->	O
appears_part	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
&&	O
!	O
is_hdy_mode	int
&&	O
!	O
*	O
is_weekday_mode	pointer
&&	O
!	O
lineptrs	pointer
->	O
day_list	int
&&	O
!	O
lineptrs	pointer
->	O
day_range	int
)	O
(	O
*	O
len	int
)	O
--	O
;	O
}	O
lineptrs	pointer
->	O
text_part	pointer
=	O
the_line	pointer
;	O
return	O
(	O
lineptrs	pointer
)	O
;	O
}	O
Bool	int
precomp_nth_wd	function
(	O
diff	int
,	O
wd	int
,	O
n	long
,	O
day	int
,	O
month	int
,	O
year	int
,	O
mode	enum
)	O
int	O
diff	int
;	O
const	O
int	O
wd	int
;	O
int	O
*	O
n	long
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
*	O
year	int
;	O
const	O
Cmode_enum	enum
mode	enum
;	O
{	O
register	O
int	O
the_diff	int
=	O
diff	int
;	O
register	O
int	O
j	int
=	O
DAY_LAST	int
+	O
(	O
days_of_february	function
(	O
*	O
year	int
)	O
==	O
29	int
)	O
;	O
auto	O
int	O
i	int
=	O
0	int
;	O
if	O
(	O
*	O
year	int
)	O
{	O
if	O
(	O
mode	enum
==	O
DAy	int
)	O
{	O
*	O
day	int
=	O
DAY_MIN	int
;	O
*	O
month	int
=	O
MONTH_MIN	int
;	O
if	O
(	O
wd	int
)	O
{	O
if	O
(	O
the_diff	int
==	O
WEEK_MAX	int
+	O
1	int
||	O
the_diff	int
==	O
99	int
)	O
{	O
i	int
=	O
the_diff	int
;	O
diff	int
=	O
WEEK_MAX	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
the_diff	int
==	O
999	int
)	O
diff	int
=	O
j	int
;	O
i	int
=	O
diff	int
--	O
;	O
}	O
}	O
else	O
{	O
register	O
int	O
k	int
=	O
(	O
iso_week_number	int
)	O
?	O
DAY_MIN	int
:	O
start_day	int
;	O
diff	int
=	O
i	int
=	O
weekno2doy	function
(	O
the_diff	int
,	O
*	O
year	int
,	O
iso_week_number	int
,	O
k	int
)	O
;	O
if	O
(	O
diff	int
>	O
DAY_MIN	int
)	O
{	O
diff	int
--	O
;	O
k	int
=	O
j	int
-	O
diff	int
;	O
if	O
(	O
iso_week_number	int
)	O
j	int
=	O
wd	int
;	O
else	O
j	int
=	O
SYEAR	O
(	O
wd	int
,	O
start_day	int
)	O
;	O
if	O
(	O
(	O
the_diff	int
==	O
99	int
)	O
&&	O
(	O
*	O
year	int
!=	O
YEAR_MAX	int
)	O
&&	O
(	O
j	int
>	O
k	int
)	O
)	O
diff	int
-=	O
DAY_MAX	int
;	O
}	O
else	O
diff	int
=	O
1	int
;	O
if	O
(	O
doy2date	function
(	O
diff	int
,	O
(	O
days_of_february	function
(	O
*	O
year	int
)	O
==	O
29	int
)	O
,	O
day	int
,	O
month	int
)	O
)	O
diff	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
precomp_date	function
(	O
diff	int
,	O
wd	int
,	O
day	int
,	O
month	int
,	O
*	O
year	int
,	O
DVar	int
)	O
)	O
{	O
if	O
(	O
!	O
*	O
year	int
)	O
{	O
*	O
day	int
=	O
0	int
;	O
*	O
month	int
=	O
0	int
;	O
*	O
n	long
=	O
diff	int
;	O
}	O
else	O
{	O
*	O
day	int
=	O
0	int
;	O
*	O
month	int
=	O
0	int
;	O
*	O
year	int
=	O
SPECIAL_VALUE	O
;	O
}	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
wd	int
&&	O
(	O
mode	enum
==	O
DAy	int
)	O
)	O
{	O
register	O
int	O
year_old	int
=	O
(	O
*	O
year	int
)	O
;	O
if	O
(	O
i	int
)	O
for	O
(	O
diff	int
=	O
DAY_MIN	int
;	O
diff	int
<=	O
DAY_MAX	int
;	O
diff	int
++	O
)	O
(	O
void	O
)	O
next_date	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
if	O
(	O
(	O
(	O
*	O
day	int
<=	O
DAY_MAX	int
)	O
&&	O
(	O
*	O
year	int
!=	O
year_old	int
)	O
)	O
||	O
weekday_of_date	function
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
*	O
year	int
)	O
==	O
wd	int
)	O
for	O
(	O
diff	int
=	O
DAY_MIN	int
;	O
diff	int
<=	O
DAY_MAX	int
;	O
diff	int
++	O
)	O
(	O
void	O
)	O
prev_date	function
(	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
if	O
(	O
i	int
==	O
WEEK_MAX	int
+	O
1	int
)	O
{	O
i	int
=	O
DAY_MIN	int
;	O
*	O
month	int
=	O
MONTH_MIN	int
;	O
(	O
void	O
)	O
precomp_date	function
(	O
WEEK_MAX	int
,	O
wd	int
,	O
&	O
i	int
,	O
month	int
,	O
*	O
year	int
,	O
DVar	int
)	O
;	O
if	O
(	O
(	O
*	O
day	int
==	O
i	int
)	O
&&	O
(	O
weekday_of_date	function
(	O
DAY_MIN	int
,	O
MONTH_MIN	int
,	O
*	O
year	int
)	O
!=	O
wd	int
)	O
)	O
{	O
*	O
day	int
=	O
0	int
;	O
*	O
month	int
=	O
0	int
;	O
*	O
year	int
=	O
SPECIAL_VALUE	O
;	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
!	O
wd	int
||	O
i	int
<	O
DAY_MIN	int
||	O
(	O
(	O
the_diff	int
<=	O
1	int
)	O
&&	O
(	O
*	O
day	int
==	O
DAY_MAX	int
+	O
1	int
)	O
&&	O
(	O
wd	int
==	O
DAY_MIN	int
)	O
)	O
)	O
{	O
if	O
(	O
*	O
day	int
>=	O
DAY_MAX	int
+	O
i	int
)	O
*	O
day	int
-=	O
DAY_MAX	int
;	O
else	O
if	O
(	O
!	O
wd	int
&&	O
(	O
i	int
<	O
DAY_MIN	int
||	O
(	O
(	O
*	O
day	int
==	O
DAY_MIN	int
+	O
1	int
)	O
&&	O
(	O
i	int
==	O
DAY_MIN	int
)	O
)	O
)	O
)	O
(	O
*	O
day	int
)	O
--	O
;	O
if	O
(	O
*	O
day	int
<	O
DAY_MIN	int
)	O
{	O
*	O
day	int
=	O
0	int
;	O
*	O
month	int
=	O
0	int
;	O
*	O
year	int
=	O
SPECIAL_VALUE	O
;	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
}	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
Bool	int
precomp_date	function
(	O
diff	int
,	O
wd	int
,	O
day	int
,	O
month	int
,	O
year	int
,	O
mode	enum
)	O
int	O
diff	int
;	O
const	O
int	O
wd	int
;	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
const	O
int	O
year	int
;	O
const	O
Cmode_enum	enum
mode	enum
;	O
{	O
register	O
int	O
i	int
;	O
if	O
(	O
(	O
(	O
mode	enum
==	O
EAster	int
)	O
&&	O
(	O
year	int
>=	O
EASTER_MIN	int
)	O
&&	O
(	O
year	int
<=	O
EASTER_MAX	O
)	O
)	O
||	O
(	O
(	O
mode	enum
==	O
TOday	int
||	O
mode	enum
==	O
DVar	int
)	O
&&	O
(	O
year	int
>=	O
YEAR_MIN	int
)	O
&&	O
(	O
year	int
<=	O
YEAR_MAX	int
)	O
)	O
)	O
{	O
switch	O
(	O
mode	enum
)	O
{	O
case	O
EAster	int
:	O
i	int
=	O
knuth_easter_formula	function
(	O
year	int
)	O
;	O
break	O
;	O
case	O
TOday	int
:	O
*	O
day	int
=	O
act_day	int
;	O
*	O
month	int
=	O
act_month	int
;	O
default	O
:	O
if	O
(	O
!	O
valid_date	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
year	int
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
i	int
=	O
day_of_year	function
(	O
*	O
day	int
,	O
*	O
month	int
,	O
year	int
)	O
;	O
}	O
if	O
(	O
wd	int
)	O
{	O
if	O
(	O
wd	int
<	O
DAY_MIN	int
||	O
wd	int
>	O
DAY_MAX	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
!	O
diff	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
else	O
if	O
(	O
diff	int
==	O
-	O
99	int
)	O
{	O
*	O
month	int
=	O
MONTH_MIN	int
;	O
*	O
day	int
=	O
eval_holiday	function
(	O
DAY_MIN	int
,	O
*	O
month	int
,	O
year	int
,	O
wd	int
,	O
TRUE	O
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
else	O
if	O
(	O
diff	int
==	O
99	int
)	O
{	O
*	O
month	int
=	O
MONTH_MAX	int
;	O
*	O
day	int
=	O
eval_holiday	function
(	O
dvec	array
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
*	O
month	int
,	O
year	int
,	O
wd	int
,	O
FALSE	O
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
else	O
{	O
register	O
int	O
act_wd	int
;	O
auto	O
int	O
d	int
;	O
auto	O
int	O
m	int
;	O
auto	O
int	O
y	int
=	O
year	int
;	O
(	O
void	O
)	O
doy2date	function
(	O
i	int
,	O
(	O
days_of_february	function
(	O
y	int
)	O
==	O
29	int
)	O
,	O
&	O
d	int
,	O
&	O
m	int
)	O
;	O
act_wd	int
=	O
weekday_of_date	function
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
if	O
(	O
act_wd	int
!=	O
wd	int
)	O
{	O
if	O
(	O
diff	int
<	O
0	int
)	O
{	O
while	O
(	O
act_wd	int
!=	O
wd	int
)	O
{	O
(	O
void	O
)	O
prev_date	function
(	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
)	O
;	O
act_wd	int
=	O
weekday_of_date	function
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
i	int
--	O
;	O
}	O
diff	int
++	O
;	O
}	O
else	O
{	O
while	O
(	O
act_wd	int
!=	O
wd	int
)	O
{	O
(	O
void	O
)	O
next_date	function
(	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
)	O
;	O
act_wd	int
=	O
weekday_of_date	function
(	O
d	int
,	O
m	int
,	O
y	int
)	O
;	O
i	int
++	O
;	O
}	O
diff	int
--	O
;	O
}	O
}	O
if	O
(	O
y	int
!=	O
year	int
)	O
return	O
(	O
FALSE	O
)	O
;	O
i	int
+=	O
diff	int
*	O
DAY_MAX	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
diff	int
==	O
-	O
999	int
)	O
i	int
=	O
1	int
;	O
else	O
if	O
(	O
diff	int
==	O
999	int
)	O
i	int
=	O
DAY_LAST	int
+	O
(	O
days_of_february	function
(	O
year	int
)	O
==	O
29	int
)	O
;	O
else	O
i	int
+=	O
diff	int
;	O
}	O
if	O
(	O
doy2date	function
(	O
i	int
,	O
(	O
days_of_february	function
(	O
year	int
)	O
==	O
29	int
)	O
,	O
day	int
,	O
month	int
)	O
)	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
void	O
set_dvar	function
(	O
line_buffer	pointer
,	O
lineptrs	pointer
,	O
filename	pointer
,	O
line_number	long
,	O
mode	enum
)	O
const	O
char	O
*	O
line_buffer	pointer
;	O
Line_struct	struct
*	O
lineptrs	pointer
;	O
const	O
char	O
*	O
filename	pointer
;	O
const	O
long	O
line_number	long
;	O
const	O
Var_enum	enum
mode	enum
;	O
{	O
register	O
int	O
error	int
=	O
0	int
;	O
auto	O
char	O
dvar	char
=	O
'\0'	O
;	O
if	O
(	O
isalpha	function
(	O
*	O
line_buffer	pointer
)	O
&&	O
(	O
tolower	function
(	O
*	O
line_buffer	pointer
)	O
!=	O
RC_EASTER_CHAR	char
)	O
&&	O
(	O
tolower	function
(	O
*	O
line_buffer	pointer
)	O
!=	O
RC_TODAY_CHAR	char
)	O
)	O
{	O
auto	O
int	O
i	int
;	O
auto	O
int	O
len	int
;	O
auto	O
int	O
d	int
=	O
0	int
;	O
auto	O
int	O
m	int
=	O
0	int
;	O
auto	O
int	O
y	int
=	O
year	int
;	O
auto	O
int	O
n	long
;	O
auto	O
const	O
char	O
*	O
ptr_char	pointer
=	O
line_buffer	pointer
;	O
auto	O
char	O
op	char
;	O
auto	O
char	O
op2	char
;	O
static	O
char	O
str20	array
[	O
21	int
]	O
;	O
auto	O
Bool	int
is_weekday_mode	pointer
;	O
auto	O
Bool	int
dvar_with_displacement	int
=	O
FALSE	O
;	O
auto	O
Bool	int
dvar_add_sub	int
=	O
FALSE	O
;	O
auto	O
Bool	int
dvar_inc_dec	int
=	O
FALSE	O
;	O
ptr_char	pointer
++	O
;	O
if	O
(	O
*	O
ptr_char	pointer
!=	O
*	O
RC_VAR_ASSIGN	pointer
)	O
{	O
if	O
(	O
(	O
*	O
ptr_char	pointer
!=	O
*	O
RC_VAR_ADD	pointer
)	O
&&	O
(	O
*	O
ptr_char	pointer
!=	O
*	O
RC_VAR_SUB	pointer
)	O
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
else	O
{	O
op	char
=	O
*	O
ptr_char	pointer
++	O
;	O
if	O
(	O
*	O
ptr_char	pointer
)	O
{	O
op2	char
=	O
*	O
ptr_char	pointer
++	O
;	O
if	O
(	O
op2	char
==	O
op	char
||	O
op2	char
==	O
*	O
RC_VAR_ASSIGN	pointer
)	O
{	O
if	O
(	O
mode	enum
==	O
LOcal	int
)	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
line_buffer	pointer
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
;	O
if	O
(	O
m	int
)	O
{	O
if	O
(	O
op	char
==	O
op2	char
)	O
{	O
while	O
(	O
isspace	function
(	O
*	O
ptr_char	pointer
)	O
)	O
ptr_char	pointer
++	O
;	O
if	O
(	O
*	O
ptr_char	pointer
)	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
else	O
dvar_inc_dec	int
=	O
TRUE	O
;	O
}	O
else	O
{	O
dvar_add_sub	int
=	O
TRUE	O
;	O
if	O
(	O
*	O
ptr_char	pointer
==	O
*	O
RC_VAR_ADD	pointer
||	O
*	O
ptr_char	pointer
==	O
*	O
RC_VAR_SUB	pointer
)	O
{	O
if	O
(	O
op	char
==	O
*	O
RC_VAR_SUB	pointer
)	O
{	O
if	O
(	O
*	O
ptr_char	pointer
==	O
*	O
RC_VAR_ADD	pointer
)	O
op	char
=	O
*	O
RC_VAR_SUB	pointer
;	O
else	O
op	char
=	O
*	O
RC_VAR_ADD	pointer
;	O
}	O
else	O
op	char
=	O
*	O
ptr_char	pointer
;	O
ptr_char	pointer
++	O
;	O
}	O
}	O
if	O
(	O
!	O
error	int
)	O
goto	O
LABEL_compute_dvar	O
;	O
}	O
else	O
{	O
if	O
(	O
mode	enum
==	O
GLobal	int
)	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
else	O
error	int
=	O
ERR_INVALID_VAR_REFERENCE	int
;	O
}	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
}	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
ptr_char	pointer
++	O
;	O
if	O
(	O
!	O
*	O
ptr_char	pointer
)	O
{	O
if	O
(	O
mode	enum
==	O
GLobal	int
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
}	O
else	O
{	O
if	O
(	O
isalpha	function
(	O
*	O
ptr_char	pointer
)	O
&&	O
!	O
isalpha	function
(	O
*	O
(	O
ptr_char	pointer
+	O
1	int
)	O
)	O
)	O
{	O
dvar	char
=	O
op	char
=	O
*	O
ptr_char	pointer
;	O
ptr_char	pointer
++	O
;	O
if	O
(	O
!	O
*	O
ptr_char	pointer
||	O
isspace	function
(	O
*	O
ptr_char	pointer
)	O
)	O
{	O
if	O
(	O
tolower	function
(	O
dvar	char
)	O
==	O
RC_EASTER_CHAR	char
||	O
tolower	function
(	O
dvar	char
)	O
==	O
RC_TODAY_CHAR	char
)	O
error	int
=	O
ERR_INVALID_VAR_ASSIGNMENT	int
;	O
else	O
{	O
if	O
(	O
mode	enum
==	O
GLobal	int
)	O
{	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
dvar	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_month	char
;	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
dvar	char
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_day	char
;	O
}	O
else	O
{	O
m	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
dvar	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
;	O
d	int
=	O
(	O
int	O
)	O
rc_dvar	array
[	O
IDX	O
(	O
dvar	char
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_day	char
;	O
}	O
if	O
(	O
!	O
m	int
)	O
error	int
=	O
ERR_INVALID_VAR_REFERENCE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
*	O
ptr_char	pointer
==	O
*	O
ASC_LIT	pointer
||	O
*	O
ptr_char	pointer
==	O
*	O
DES_LIT	pointer
||	O
isdigit	function
(	O
*	O
ptr_char	pointer
)	O
)	O
{	O
ptr_char	pointer
--	O
;	O
dvar_with_displacement	int
=	O
TRUE	O
;	O
goto	O
LABEL_compute_dvar	O
;	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
}	O
}	O
else	O
{	O
LABEL_compute_dvar	O
:	O
strncpy	function
(	O
str20	array
,	O
ptr_char	pointer
,	O
20	int
)	O
;	O
str20	array
[	O
20	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
dvar_with_displacement	int
)	O
sprintf	function
(	O
s5	pointer
,	O
"%0*d%c%s"	pointer
,	O
len_year_max	int
,	O
y	int
,	O
RC_HDY_CHAR	char
,	O
str20	array
)	O
;	O
else	O
if	O
(	O
dvar_add_sub	int
)	O
sprintf	function
(	O
s5	pointer
,	O
"%0*d%c%c%c%s"	pointer
,	O
len_year_max	int
,	O
y	int
,	O
RC_HDY_CHAR	char
,	O
*	O
line_buffer	pointer
,	O
op	char
,	O
str20	array
)	O
;	O
else	O
if	O
(	O
dvar_inc_dec	int
)	O
sprintf	function
(	O
s5	pointer
,	O
"%0*d%c%c%c1"	pointer
,	O
len_year_max	int
,	O
y	int
,	O
RC_HDY_CHAR	char
,	O
*	O
line_buffer	pointer
,	O
op	char
)	O
;	O
else	O
sprintf	function
(	O
s5	pointer
,	O
"%0*d%s"	pointer
,	O
len_year_max	int
,	O
y	int
,	O
str20	array
)	O
;	O
(	O
void	O
)	O
rc_get_date	function
(	O
s5	pointer
,	O
lineptrs	pointer
,	O
FALSE	O
,	O
&	O
is_weekday_mode	pointer
,	O
&	O
d	int
,	O
&	O
m	int
,	O
&	O
y	int
,	O
&	O
n	long
,	O
&	O
len	int
,	O
&	O
op	char
,	O
&	O
i	int
,	O
&	O
i	int
,	O
filename	pointer
,	O
line_number	long
,	O
line_buffer	pointer
,	O
TRUE	O
)	O
;	O
if	O
(	O
y	int
!=	O
SPECIAL_VALUE	O
)	O
{	O
if	O
(	O
(	O
mode	enum
==	O
GLobal	int
)	O
&&	O
(	O
op	char
||	O
is_weekday_mode	pointer
)	O
)	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
else	O
{	O
if	O
(	O
m	int
<	O
MONTH_MIN	int
||	O
m	int
>	O
MONTH_MAX	int
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
else	O
{	O
i	int
=	O
dvec	array
[	O
m	int
-	O
1	int
]	O
;	O
if	O
(	O
m	int
==	O
2	int
)	O
i	int
+=	O
is_leap_year	int
;	O
if	O
(	O
is_weekday_mode	pointer
)	O
{	O
if	O
(	O
n	long
==	O
9	int
)	O
d	int
=	O
eval_holiday	function
(	O
i	int
,	O
m	int
,	O
year	int
,	O
d	int
,	O
FALSE	O
)	O
;	O
else	O
{	O
d	int
=	O
eval_holiday	function
(	O
DAY_MIN	int
,	O
m	int
,	O
year	int
,	O
d	int
,	O
TRUE	O
)	O
;	O
d	int
+=	O
(	O
DAY_MAX	int
*	O
(	O
n	long
-	O
1	int
)	O
)	O
;	O
if	O
(	O
d	int
>	O
i	int
)	O
error	int
=	O
ERR_INVALID_VAR_ASSIGNMENT	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
d	int
==	O
99	int
)	O
d	int
=	O
i	int
;	O
if	O
(	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
+	O
1	int
)	O
&&	O
(	O
days_of_february	function
(	O
year	int
+	O
1	int
)	O
==	O
28	int
)	O
&&	O
!	O
rc_feb_29_to_feb_28	int
&&	O
!	O
rc_feb_29_to_mar_01	int
&&	O
(	O
m	int
==	O
2	int
)	O
&&	O
(	O
d	int
==	O
29	int
)	O
)	O
error	int
=	O
ERR_INVALID_VAR_ASSIGNMENT	int
;	O
else	O
{	O
if	O
(	O
d	int
>	O
i	int
)	O
{	O
manage_leap_day	function
(	O
&	O
d	int
,	O
&	O
m	int
,	O
year	int
,	O
line_buffer	pointer
,	O
filename	pointer
,	O
line_number	long
)	O
;	O
i	int
=	O
d	int
;	O
}	O
if	O
(	O
d	int
<	O
DAY_MIN	int
||	O
d	int
>	O
i	int
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
}	O
}	O
}	O
}	O
}	O
else	O
error	int
=	O
ERR_INVALID_VAR_ASSIGNMENT	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
error	int
)	O
{	O
if	O
(	O
mode	enum
==	O
GLobal	int
)	O
{	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
line_buffer	pointer
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_month	char
=	O
(	O
char	O
)	O
m	int
;	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
line_buffer	pointer
)	O
]	O
.	O
dvar_global	struct
.	O
dvar_day	char
=	O
(	O
char	O
)	O
d	int
;	O
}	O
else	O
{	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
line_buffer	pointer
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_month	char
=	O
(	O
char	O
)	O
m	int
;	O
rc_dvar	array
[	O
IDX	O
(	O
*	O
line_buffer	pointer
)	O
]	O
.	O
dvar_local	struct
.	O
dvar_day	char
=	O
(	O
char	O
)	O
d	int
;	O
}	O
}	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
if	O
(	O
error	int
)	O
{	O
if	O
(	O
(	O
mode	enum
==	O
GLobal	int
)	O
&&	O
(	O
error	int
==	O
ERR_ILLEGAL_VAR_DEFINITION	int
||	O
error	int
==	O
ERR_ILLEGAL_VAR_OPERATION	int
)	O
)	O
warning_level	int
=	O
WARN_LVL_MAX	int
;	O
if	O
(	O
warning_level	int
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
dvar	char
)	O
dvar	char
=	O
*	O
line_buffer	pointer
;	O
var_warning	function
(	O
error	int
,	O
(	O
int	O
)	O
dvar	char
,	O
line_buffer	pointer
,	O
filename	pointer
,	O
line_number	long
)	O
;	O
}	O
}	O
}	O
void	O
set_tvar	function
(	O
line_buffer	pointer
,	O
filename	pointer
,	O
line_number	long
,	O
mode	enum
)	O
const	O
char	O
*	O
line_buffer	pointer
;	O
const	O
char	O
*	O
filename	pointer
;	O
const	O
long	O
line_number	long
;	O
const	O
Var_enum	enum
mode	enum
;	O
{	O
register	O
int	O
error	int
=	O
0	int
;	O
auto	O
char	O
tvar	char
=	O
'\0'	O
;	O
if	O
(	O
*	O
line_buffer	pointer
!=	O
RC_TVAR_CHAR	char
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
else	O
{	O
auto	O
char	O
*	O
ptr_char	pointer
=	O
(	O
char	O
*	O
)	O
line_buffer	pointer
;	O
ptr_char	pointer
++	O
;	O
if	O
(	O
!	O
isalpha	function
(	O
*	O
ptr_char	pointer
)	O
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
else	O
{	O
tvar	char
=	O
*	O
ptr_char	pointer
++	O
;	O
if	O
(	O
(	O
*	O
ptr_char	pointer
!=	O
*	O
RC_VAR_ASSIGN	pointer
)	O
&&	O
(	O
*	O
ptr_char	pointer
!=	O
*	O
RC_TVAR_ICMD_ASSIGN	pointer
)	O
&&	O
(	O
*	O
ptr_char	pointer
!=	O
*	O
RC_TVAR_UCMD_ASSIGN	pointer
)	O
&&	O
(	O
*	O
ptr_char	pointer
!=	O
*	O
RC_VAR_ADD	pointer
)	O
&&	O
(	O
*	O
ptr_char	pointer
!=	O
*	O
RC_VAR_SUB	pointer
)	O
)	O
error	int
=	O
ERR_ILLEGAL_VAR_DEFINITION	int
;	O
else	O
{	O
register	O
int	O
i	int
=	O
0	int
;	O
register	O
int	O
j	int
;	O
register	O
int	O
len	int
=	O
0	int
;	O
auto	O
char	O
*	O
ptr_tvar	pointer
;	O
auto	O
char	O
op	char
;	O
auto	O
char	O
op2	char
=	O
'\0'	O
;	O
auto	O
char	O
op3	char
=	O
op2	char
;	O
auto	O
Bool	int
is_quoted	int
=	O
FALSE	O
;	O
auto	O
Bool	int
restore_tvar	int
=	O
FALSE	O
;	O
op	char
=	O
*	O
ptr_char	pointer
++	O
;	O
if	O
(	O
op	char
)	O
{	O
op2	char
=	O
*	O
ptr_char	pointer
;	O
if	O
(	O
op2	char
)	O
op3	char
=	O
*	O
(	O
ptr_char	pointer
+	O
1	int
)	O
;	O
}	O
ptr_tvar	pointer
=	O
strchr	function
(	O
ptr_char	pointer
,	O
RC_TVAR_CHAR	char
)	O
;	O
if	O
(	O
ptr_tvar	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
auto	O
Bool	int
global_tvar_defined	int
;	O
auto	O
Bool	int
local_tvar_set	int
;	O
do	O
{	O
len	int
=	O
(	O
int	O
)	O
(	O
ptr_tvar	pointer
-	O
ptr_char	pointer
)	O
;	O
if	O
(	O
len	int
)	O
{	O
while	O
(	O
(	O
Uint	int
)	O
len	int
+	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strncpy	function
(	O
s5	pointer
+	O
i	int
,	O
ptr_char	pointer
,	O
len	int
)	O
;	O
i	int
+=	O
len	int
;	O
}	O
s5	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
i	int
)	O
if	O
(	O
s5	pointer
[	O
i	int
-	O
1	int
]	O
==	O
QUOTE_CHAR	char
)	O
is_quoted	int
=	O
TRUE	O
;	O
ptr_tvar	pointer
++	O
;	O
if	O
(	O
!	O
is_quoted	int
&&	O
isalpha	function
(	O
*	O
ptr_tvar	pointer
)	O
)	O
{	O
global_tvar_defined	int
=	O
local_tvar_set	int
=	O
FALSE	O
;	O
if	O
(	O
rc_tvar	array
[	O
IDX	O
(	O
*	O
ptr_tvar	pointer
)	O
]	O
.	O
tvar_global	struct
.	O
tvar_text	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
global_tvar_defined	int
=	O
TRUE	O
;	O
if	O
(	O
rc_tvar	array
[	O
IDX	O
(	O
*	O
ptr_tvar	pointer
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
if	O
(	O
*	O
rc_tvar	array
[	O
IDX	O
(	O
*	O
ptr_tvar	pointer
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
)	O
local_tvar_set	int
=	O
TRUE	O
;	O
j	int
=	O
0	int
;	O
if	O
(	O
global_tvar_defined	int
&&	O
(	O
mode	enum
==	O
GLobal	int
||	O
(	O
(	O
mode	enum
==	O
LOcal	int
)	O
&&	O
!	O
local_tvar_set	int
)	O
)	O
)	O
{	O
j	int
=	O
(	O
int	O
)	O
strlen	function
(	O
rc_tvar	array
[	O
IDX	O
(	O
*	O
ptr_tvar	pointer
)	O
]	O
.	O
tvar_global	struct
.	O
tvar_text	pointer
)	O
;	O
if	O
(	O
j	int
)	O
{	O
while	O
(	O
(	O
Uint	int
)	O
i	int
+	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	function
(	O
s5	pointer
,	O
rc_tvar	array
[	O
IDX	O
(	O
*	O
ptr_tvar	pointer
)	O
]	O
.	O
tvar_global	struct
.	O
tvar_text	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
mode	enum
==	O
LOcal	int
)	O
&&	O
local_tvar_set	int
)	O
{	O
j	int
=	O
(	O
int	O
)	O
strlen	function
(	O
rc_tvar	array
[	O
IDX	O
(	O
*	O
ptr_tvar	pointer
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
)	O
;	O
while	O
(	O
(	O
Uint	int
)	O
i	int
+	O
j	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	function
(	O
s5	pointer
,	O
rc_tvar	array
[	O
IDX	O
(	O
*	O
ptr_tvar	pointer
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
)	O
;	O
}	O
if	O
(	O
(	O
(	O
mode	enum
==	O
GLobal	int
)	O
&&	O
global_tvar_defined	int
)	O
||	O
(	O
(	O
mode	enum
==	O
LOcal	int
)	O
&&	O
(	O
global_tvar_defined	int
||	O
local_tvar_set	int
)	O
)	O
||	O
(	O
(	O
tvar	char
==	O
*	O
ptr_tvar	pointer
)	O
&&	O
(	O
(	O
(	O
mode	enum
==	O
GLobal	int
)	O
&&	O
!	O
global_tvar_defined	int
)	O
||	O
(	O
(	O
mode	enum
==	O
LOcal	int
)	O
&&	O
!	O
global_tvar_defined	int
&&	O
!	O
local_tvar_set	int
)	O
)	O
)	O
)	O
{	O
len	int
+=	O
2	int
;	O
if	O
(	O
j	int
)	O
i	int
+=	O
j	int
;	O
else	O
if	O
(	O
i	int
)	O
if	O
(	O
isspace	function
(	O
s5	pointer
[	O
i	int
-	O
1	int
]	O
)	O
&&	O
isspace	function
(	O
*	O
(	O
ptr_tvar	pointer
+	O
1	int
)	O
)	O
)	O
s5	pointer
[	O
--	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
restore_tvar	int
=	O
TRUE	O
;	O
}	O
else	O
restore_tvar	int
=	O
TRUE	O
;	O
if	O
(	O
restore_tvar	int
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
i	int
+	O
1	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
s5	pointer
[	O
i	int
++	O
]	O
=	O
RC_TVAR_CHAR	char
;	O
len	int
++	O
;	O
if	O
(	O
*	O
ptr_tvar	pointer
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
i	int
+	O
1	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
s5	pointer
[	O
i	int
++	O
]	O
=	O
*	O
ptr_tvar	pointer
;	O
len	int
++	O
;	O
}	O
s5	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
ptr_char	pointer
+=	O
len	int
;	O
ptr_tvar	pointer
=	O
strchr	function
(	O
ptr_char	pointer
,	O
RC_TVAR_CHAR	char
)	O
;	O
restore_tvar	int
=	O
is_quoted	int
=	O
FALSE	O
;	O
}	O
while	O
(	O
ptr_tvar	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
*	O
ptr_char	pointer
)	O
{	O
i	int
+=	O
(	O
int	O
)	O
strlen	function
(	O
ptr_char	pointer
)	O
;	O
while	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
strcat	function
(	O
s5	pointer
,	O
ptr_char	pointer
)	O
;	O
}	O
i	int
++	O
;	O
ptr_char	pointer
=	O
s5	pointer
;	O
}	O
else	O
i	int
=	O
(	O
int	O
)	O
strlen	function
(	O
ptr_char	pointer
)	O
+	O
1	int
;	O
if	O
(	O
op	char
==	O
*	O
RC_VAR_ASSIGN	pointer
||	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	pointer
||	O
op	char
==	O
*	O
RC_TVAR_UCMD_ASSIGN	pointer
)	O
{	O
if	O
(	O
rc_execute_command	int
&&	O
(	O
i	int
>	O
1	int
)	O
&&	O
(	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	pointer
||	O
op	char
==	O
*	O
RC_TVAR_UCMD_ASSIGN	pointer
)	O
)	O
{	O
static	O
char	O
*	O
txt2gcal_prgr	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
char	O
*	O
ptr_tfn	pointer
;	O
auto	O
char	O
*	O
the_command	pointer
;	O
ptr_tfn	pointer
=	O
TMPFILENAME	O
;	O
if	O
(	O
ptr_tfn	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
my_error	function
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"tmpnam()="	pointer
,	O
0	int
)	O
;	O
rc_tvar_tfn	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
strlen	function
(	O
ptr_tfn	pointer
)	O
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_tvar_tfn"	pointer
,	O
0	int
)	O
;	O
strcpy	function
(	O
rc_tvar_tfn	pointer
,	O
ptr_tfn	pointer
)	O
;	O
rc_tvar_tfp	pointer
=	O
fopen	function
(	O
rc_tvar_tfn	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
rc_tvar_tfp	pointer
==	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
my_error	function
(	O
ERR_WRITE_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
rc_tvar_tfn	pointer
,	O
0	int
)	O
;	O
if	O
(	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	pointer
)	O
i	int
+=	O
(	O
strlen	function
(	O
REDIRECT_OUT	pointer
)	O
+	O
strlen	function
(	O
rc_tvar_tfn	pointer
)	O
)	O
;	O
else	O
{	O
if	O
(	O
txt2gcal_prgr	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
txt2gcal_prgr	pointer
=	O
getenv	function
(	O
ENV_VAR_TXT2GCALPROG	pointer
)	O
;	O
if	O
(	O
txt2gcal_prgr	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
!	O
*	O
txt2gcal_prgr	pointer
)	O
txt2gcal_prgr	pointer
=	O
TXT2GCAL_PRGR	pointer
;	O
}	O
else	O
txt2gcal_prgr	pointer
=	O
TXT2GCAL_PRGR	pointer
;	O
}	O
i	int
+=	O
(	O
strlen	function
(	O
PIPELINE	pointer
)	O
+	O
strlen	function
(	O
txt2gcal_prgr	pointer
)	O
+	O
strlen	function
(	O
REDIRECT_OUT	pointer
)	O
+	O
strlen	function
(	O
rc_tvar_tfn	pointer
)	O
)	O
;	O
}	O
j	int
=	O
i	int
;	O
the_command	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
i	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_tvar_tfn"	pointer
,	O
0	int
)	O
;	O
if	O
(	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	pointer
)	O
sprintf	function
(	O
the_command	pointer
,	O
"%s%s%s"	pointer
,	O
ptr_char	pointer
,	O
REDIRECT_OUT	pointer
,	O
rc_tvar_tfn	pointer
)	O
;	O
else	O
sprintf	function
(	O
the_command	pointer
,	O
"%s%s%s%s%s"	pointer
,	O
ptr_char	pointer
,	O
PIPELINE	pointer
,	O
txt2gcal_prgr	pointer
,	O
REDIRECT_OUT	pointer
,	O
rc_tvar_tfn	pointer
)	O
;	O
i	int
=	O
my_system	function
(	O
the_command	pointer
)	O
;	O
if	O
(	O
warning_level	int
>=	O
0	int
)	O
{	O
while	O
(	O
(	O
Uint	int
)	O
j	int
+	O
LEN_SINGLE_LINE	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
if	O
(	O
i	int
==	O
-	O
1	int
)	O
{	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"Cannot execute command in file `%s'\nLine: %ld %s"	pointer
)	O
,	O
filename	pointer
,	O
line_number	long
,	O
the_command	pointer
)	O
;	O
print_text	function
(	O
stderr	pointer
,	O
s5	pointer
)	O
;	O
if	O
(	O
warning_level	int
>=	O
WARN_LVL_MAX	int
)	O
{	O
j	int
=	O
(	O
int	O
)	O
strlen	function
(	O
the_command	pointer
)	O
;	O
if	O
(	O
(	O
Uint	int
)	O
j	int
>=	O
maxlen_max	int
-	O
9	int
)	O
resize_all_strings	function
(	O
j	int
+	O
9	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
sprintf	function
(	O
s5	pointer
,	O
"system(%s)="	pointer
,	O
the_command	pointer
)	O
;	O
my_error	function
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
22L	int
,	O
s5	pointer
,	O
i	int
)	O
;	O
}	O
error	int
=	O
ERR_INVALID_VAR_ASSIGNMENT	int
;	O
}	O
else	O
{	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"Command executed (exit code=%d) in file `%s'\nLine %ld: %s"	pointer
)	O
,	O
i	int
,	O
filename	pointer
,	O
line_number	long
,	O
the_command	pointer
)	O
;	O
print_text	function
(	O
stderr	pointer
,	O
s5	pointer
)	O
;	O
if	O
(	O
i	int
&&	O
(	O
warning_level	int
>=	O
WARN_LVL_MAX	int
)	O
)	O
my_exit	function
(	O
ERR_EXTERNAL_CMD_FAILURE	int
)	O
;	O
}	O
}	O
free	function
(	O
the_command	pointer
)	O
;	O
if	O
(	O
!	O
error	int
)	O
{	O
auto	O
long	O
lnumber	long
=	O
0L	int
;	O
auto	O
int	O
llength	int
;	O
auto	O
int	O
in_pool	int
=	O
0	int
;	O
static	O
char	O
rc_nl	array
[	O
2	int
]	O
=	O
{	O
RC_NL_CHAR	char
,	O
'\0'	O
}	O
;	O
auto	O
char	O
*	O
pool	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
char	O
*	O
ptr_pool	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
auto	O
Bool	int
b_dummy	int
;	O
if	O
(	O
fclose	function
(	O
rc_tvar_tfp	pointer
)	O
==	O
EOF	O
)	O
my_error	function
(	O
ERR_WRITE_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
rc_tvar_tfn	pointer
,	O
0	int
)	O
;	O
rc_tvar_tfp	pointer
=	O
fopen	function
(	O
rc_tvar_tfn	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
rc_tvar_tfp	pointer
==	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
my_error	function
(	O
ERR_READ_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
rc_tvar_tfn	pointer
,	O
0	int
)	O
;	O
pool	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
BUF_LEN	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"pool"	pointer
,	O
0	int
)	O
;	O
j	int
=	O
0	int
;	O
*	O
s5	pointer
=	O
'\0'	O
;	O
while	O
(	O
(	O
ptr_pool	pointer
=	O
file_read_line	function
(	O
rc_tvar_tfp	pointer
,	O
&	O
s7	pointer
,	O
&	O
in_pool	int
,	O
pool	pointer
,	O
ptr_pool	pointer
,	O
rc_tvar_tfn	pointer
,	O
&	O
lnumber	long
,	O
&	O
llength	int
,	O
COmmon	int
,	O
&	O
b_dummy	int
,	O
&	O
b_dummy	int
,	O
&	O
b_dummy	int
)	O
)	O
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	pointer
)	O
{	O
if	O
(	O
(	O
Uint	int
)	O
j	int
+	O
llength	int
+	O
2	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
maxlen_max	int
<<	O
1	int
,	O
TRUE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
if	O
(	O
*	O
s7	pointer
)	O
strcat	function
(	O
s5	pointer
,	O
s7	pointer
)	O
;	O
strcat	function
(	O
s5	pointer
,	O
rc_nl	array
)	O
;	O
j	int
+=	O
(	O
llength	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
ptr_char	pointer
=	O
s7	pointer
;	O
while	O
(	O
!	O
isspace	function
(	O
*	O
ptr_char	pointer
)	O
)	O
{	O
ptr_char	pointer
++	O
;	O
i	int
++	O
;	O
}	O
ptr_char	pointer
++	O
;	O
i	int
=	O
llength	int
-	O
i	int
;	O
break	O
;	O
}	O
}	O
free	function
(	O
pool	pointer
)	O
;	O
if	O
(	O
op	char
==	O
*	O
RC_TVAR_ICMD_ASSIGN	pointer
)	O
{	O
i	int
=	O
j	int
;	O
s5	pointer
[	O
i	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
ptr_char	pointer
=	O
strchr	function
(	O
s5	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
ptr_char	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
do	O
{	O
*	O
ptr_char	pointer
=	O
RC_NL_CHAR	char
;	O
ptr_char	pointer
=	O
strchr	function
(	O
s5	pointer
,	O
'\n'	O
)	O
;	O
}	O
while	O
(	O
ptr_char	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
ptr_char	pointer
=	O
s5	pointer
;	O
}	O
if	O
(	O
fclose	function
(	O
rc_tvar_tfp	pointer
)	O
==	O
EOF	O
)	O
my_error	function
(	O
ERR_WRITE_FILE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
rc_tvar_tfn	pointer
,	O
0	int
)	O
;	O
j	int
=	O
unlink	function
(	O
rc_tvar_tfn	pointer
)	O
;	O
if	O
(	O
j	int
)	O
my_error	function
(	O
ERR_INTERNAL_C_FUNC_FAILURE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"unlink(rc_tvar_tfn)="	pointer
,	O
j	int
)	O
;	O
free	function
(	O
rc_tvar_tfn	pointer
)	O
;	O
rc_tvar_tfn	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
}	O
}	O
if	O
(	O
mode	enum
==	O
GLobal	int
)	O
{	O
if	O
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_global	struct
.	O
tvar_text	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_global	struct
.	O
tvar_text	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
i	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"rc_tvar[IDX(tvar)].tvar_global.tvar_text"	pointer
,	O
IDX	O
(	O
tvar	char
)	O
)	O
;	O
else	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_global	struct
.	O
tvar_text	pointer
=	O
(	O
char	O
*	O
)	O
my_realloc	function
(	O
(	O
VOID_PTR	O
)	O
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_global	struct
.	O
tvar_text	pointer
)	O
,	O
i	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_tvar[IDX(tvar)].tvar_global.tvar_text"	pointer
,	O
IDX	O
(	O
tvar	char
)	O
)	O
;	O
strcpy	function
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_global	struct
.	O
tvar_text	pointer
,	O
ptr_char	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
=	O
(	O
char	O
*	O
)	O
my_malloc	function
(	O
i	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
1L	int
,	O
"rc_tvar[IDX(tvar)].tvar_local.tvar_text"	pointer
,	O
IDX	O
(	O
tvar	char
)	O
)	O
;	O
else	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
=	O
(	O
char	O
*	O
)	O
my_realloc	function
(	O
(	O
VOID_PTR	O
)	O
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
)	O
,	O
i	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_tvar[IDX(tvar)].tvar_local.tvar_text"	pointer
,	O
IDX	O
(	O
tvar	char
)	O
)	O
;	O
strcpy	function
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
,	O
ptr_char	pointer
)	O
;	O
}	O
}	O
else	O
{	O
auto	O
Bool	int
tvar_inc_dec	int
=	O
FALSE	O
;	O
if	O
(	O
op2	char
==	O
op	char
||	O
op2	char
==	O
*	O
RC_VAR_ASSIGN	pointer
)	O
{	O
if	O
(	O
mode	enum
==	O
LOcal	int
)	O
{	O
if	O
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
!=	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
*	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
)	O
{	O
if	O
(	O
op	char
==	O
op2	char
)	O
{	O
if	O
(	O
op3	char
&&	O
!	O
isspace	function
(	O
op3	char
)	O
)	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
else	O
{	O
ptr_char	pointer
=	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
;	O
if	O
(	O
*	O
ptr_char	pointer
==	O
*	O
RC_VAR_ADD	pointer
||	O
*	O
ptr_char	pointer
==	O
*	O
RC_VAR_SUB	pointer
)	O
ptr_char	pointer
++	O
;	O
while	O
(	O
isdigit	function
(	O
*	O
ptr_char	pointer
)	O
)	O
ptr_char	pointer
++	O
;	O
if	O
(	O
*	O
ptr_char	pointer
)	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
else	O
tvar_inc_dec	int
=	O
TRUE	O
;	O
}	O
}	O
else	O
{	O
ptr_char	pointer
++	O
;	O
if	O
(	O
*	O
ptr_char	pointer
==	O
*	O
RC_VAR_ADD	pointer
||	O
*	O
ptr_char	pointer
==	O
*	O
RC_VAR_SUB	pointer
)	O
{	O
if	O
(	O
op	char
==	O
*	O
RC_VAR_SUB	pointer
)	O
{	O
if	O
(	O
*	O
ptr_char	pointer
==	O
*	O
RC_VAR_ADD	pointer
)	O
op	char
=	O
*	O
RC_VAR_SUB	pointer
;	O
else	O
op	char
=	O
*	O
RC_VAR_ADD	pointer
;	O
}	O
else	O
op	char
=	O
*	O
ptr_char	pointer
;	O
ptr_char	pointer
++	O
;	O
}	O
}	O
}	O
else	O
error	int
=	O
ERR_INVALID_VAR_REFERENCE	int
;	O
}	O
else	O
error	int
=	O
ERR_INVALID_VAR_REFERENCE	int
;	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
if	O
(	O
!	O
error	int
)	O
{	O
static	O
Slint	long
num	long
;	O
if	O
(	O
tvar_inc_dec	int
)	O
{	O
len	int
=	O
strlen	function
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
)	O
;	O
num	long
=	O
atol	function
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
)	O
;	O
if	O
(	O
op	char
==	O
*	O
RC_VAR_ADD	pointer
)	O
num	long
++	O
;	O
else	O
num	long
--	O
;	O
}	O
else	O
{	O
i	int
=	O
0	int
;	O
while	O
(	O
isdigit	function
(	O
*	O
ptr_char	pointer
)	O
)	O
s5	pointer
[	O
i	int
++	O
]	O
=	O
*	O
ptr_char	pointer
++	O
;	O
while	O
(	O
isspace	function
(	O
*	O
ptr_char	pointer
)	O
)	O
ptr_char	pointer
++	O
;	O
if	O
(	O
i	int
&&	O
!	O
*	O
ptr_char	pointer
)	O
{	O
s5	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
len	int
=	O
strlen	function
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
)	O
;	O
num	long
=	O
atol	function
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
)	O
;	O
if	O
(	O
op	char
==	O
*	O
RC_VAR_ADD	pointer
)	O
num	long
+=	O
atol	function
(	O
s5	pointer
)	O
;	O
else	O
num	long
-=	O
atol	function
(	O
s5	pointer
)	O
;	O
}	O
else	O
error	int
=	O
ERR_ILLEGAL_VAR_OPERATION	int
;	O
}	O
if	O
(	O
!	O
error	int
)	O
{	O
sprintf	function
(	O
s5	pointer
,	O
"%0*ld"	pointer
,	O
len	int
,	O
num	long
)	O
;	O
len	int
=	O
(	O
int	O
)	O
strlen	function
(	O
s5	pointer
)	O
;	O
if	O
(	O
len	int
!=	O
(	O
int	O
)	O
strlen	function
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
)	O
)	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
=	O
(	O
char	O
*	O
)	O
my_realloc	function
(	O
(	O
VOID_PTR	O
)	O
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
)	O
,	O
len	int
+	O
1	int
,	O
ERR_NO_MEMORY_AVAILABLE	int
,	O
__FILE__	O
,	O
(	O
(	O
long	O
)	O
__LINE__	O
)	O
-	O
2L	int
,	O
"rc_tvar[IDX(tvar)].tvar_local.tvar_text"	pointer
,	O
IDX	O
(	O
tvar	char
)	O
)	O
;	O
strcpy	function
(	O
rc_tvar	array
[	O
IDX	O
(	O
tvar	char
)	O
]	O
.	O
tvar_local	struct
.	O
tvar_text	pointer
,	O
s5	pointer
)	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
error	int
)	O
{	O
if	O
(	O
(	O
mode	enum
==	O
GLobal	int
)	O
&&	O
(	O
error	int
==	O
ERR_ILLEGAL_VAR_DEFINITION	int
||	O
error	int
==	O
ERR_ILLEGAL_VAR_OPERATION	int
)	O
)	O
warning_level	int
=	O
WARN_LVL_MAX	int
;	O
if	O
(	O
warning_level	int
>=	O
0	int
)	O
{	O
if	O
(	O
*	O
line_buffer	pointer
==	O
RC_TVAR_CHAR	char
)	O
tvar	char
=	O
*	O
(	O
line_buffer	pointer
+	O
1	int
)	O
;	O
if	O
(	O
!	O
tvar	char
)	O
tvar	char
=	O
*	O
line_buffer	pointer
;	O
var_warning	function
(	O
error	int
,	O
(	O
int	O
)	O
tvar	char
,	O
line_buffer	pointer
,	O
filename	pointer
,	O
line_number	long
)	O
;	O
}	O
}	O
}	O
void	O
nth_weekday_of_month	function
(	O
d	int
,	O
m	int
,	O
y	int
,	O
n	long
,	O
is_weekday_mode	pointer
)	O
int	O
*	O
d	int
;	O
int	O
*	O
m	int
;	O
int	O
*	O
y	int
;	O
const	O
int	O
*	O
n	long
;	O
Bool	int
*	O
is_weekday_mode	pointer
;	O
{	O
register	O
int	O
i	int
;	O
register	O
int	O
j	int
=	O
0	int
;	O
auto	O
int	O
dd	int
=	O
0	int
;	O
auto	O
int	O
mm	int
=	O
0	int
;	O
auto	O
Bool	int
year_set	int
=	O
FALSE	O
;	O
auto	O
Bool	int
year_modified	int
=	O
FALSE	O
;	O
if	O
(	O
*	O
n	long
&&	O
(	O
!	O
rc_year_flag	int
||	O
(	O
*	O
m	int
&&	O
rc_year_flag	int
)	O
)	O
&&	O
(	O
!	O
rc_period_list	int
||	O
(	O
*	O
m	int
&&	O
rc_period_list	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
*	O
m	int
&&	O
(	O
is_3month_mode	int
||	O
is_3month_mode2	int
||	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
)	O
;	O
else	O
{	O
*	O
is_weekday_mode	pointer
=	O
FALSE	O
;	O
if	O
(	O
!	O
*	O
y	int
)	O
{	O
year_set	int
=	O
TRUE	O
;	O
*	O
y	int
=	O
year	int
;	O
}	O
if	O
(	O
!	O
*	O
m	int
)	O
{	O
*	O
m	int
=	O
month	int
;	O
if	O
(	O
rc_week_flag	int
||	O
rc_tomorrow_flag	int
)	O
{	O
if	O
(	O
(	O
*	O
n	long
>	O
3	int
)	O
&&	O
(	O
day	int
<	O
DAY_MIN	int
)	O
)	O
{	O
i	int
=	O
(	O
days_of_february	function
(	O
year	int
-	O
1	int
)	O
==	O
29	int
)	O
;	O
j	int
=	O
day	int
+	O
DAY_LAST	int
+	O
i	int
;	O
(	O
void	O
)	O
doy2date	function
(	O
j	int
,	O
i	int
,	O
&	O
dd	int
,	O
&	O
mm	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
n	long
==	O
1	int
)	O
{	O
if	O
(	O
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
>	O
0	int
)	O
&&	O
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
<	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
)	O
(	O
void	O
)	O
doy2date	function
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
,	O
is_leap_year	int
,	O
&	O
dd	int
,	O
&	O
mm	int
)	O
;	O
else	O
{	O
i	int
=	O
(	O
days_of_february	function
(	O
year	int
+	O
1	int
)	O
==	O
29	int
)	O
;	O
j	int
=	O
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
)	O
-	O
(	O
DAY_LAST	int
+	O
is_leap_year	int
)	O
;	O
(	O
void	O
)	O
doy2date	function
(	O
j	int
,	O
i	int
,	O
&	O
dd	int
,	O
&	O
mm	int
)	O
;	O
}	O
}	O
dd	int
=	O
*	O
d	int
;	O
}	O
}	O
else	O
if	O
(	O
year_set	int
&&	O
(	O
rc_week_flag	int
||	O
rc_tomorrow_flag	int
)	O
)	O
{	O
if	O
(	O
(	O
*	O
n	long
==	O
9	int
)	O
&&	O
(	O
*	O
m	int
==	O
MONTH_MAX	int
)	O
&&	O
(	O
*	O
y	int
>	O
YEAR_MIN	int
)	O
&&	O
(	O
day	int
<	O
DAY_MIN	int
)	O
)	O
{	O
year_modified	int
=	O
TRUE	O
;	O
(	O
*	O
y	int
)	O
--	O
;	O
}	O
else	O
if	O
(	O
(	O
*	O
n	long
==	O
1	int
)	O
&&	O
(	O
*	O
m	int
==	O
MONTH_MIN	int
)	O
&&	O
(	O
*	O
y	int
<	O
YEAR_MAX	int
)	O
&&	O
(	O
day	int
+	O
DAY_MAX	int
>=	O
DAY_LAST	int
+	O
is_leap_year	int
)	O
)	O
{	O
year_modified	int
=	O
TRUE	O
;	O
(	O
*	O
y	int
)	O
++	O
;	O
}	O
}	O
if	O
(	O
year_set	int
&&	O
(	O
*	O
y	int
<	O
YEAR_MAX	int
)	O
&&	O
(	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
)	O
&&	O
(	O
*	O
m	int
<	O
fiscal_month	int
)	O
)	O
)	O
if	O
(	O
!	O
year_modified	int
)	O
(	O
*	O
y	int
)	O
++	O
;	O
if	O
(	O
*	O
m	int
==	O
2	int
)	O
i	int
=	O
days_of_february	function
(	O
*	O
y	int
)	O
;	O
else	O
i	int
=	O
dvec	array
[	O
*	O
m	int
-	O
1	int
]	O
;	O
if	O
(	O
*	O
n	long
==	O
9	int
)	O
*	O
d	int
=	O
eval_holiday	function
(	O
i	int
,	O
*	O
m	int
,	O
*	O
y	int
,	O
*	O
d	int
,	O
FALSE	O
)	O
;	O
else	O
{	O
*	O
d	int
=	O
eval_holiday	function
(	O
DAY_MIN	int
,	O
*	O
m	int
,	O
*	O
y	int
,	O
*	O
d	int
,	O
TRUE	O
)	O
;	O
*	O
d	int
+=	O
(	O
DAY_MAX	int
*	O
(	O
*	O
n	long
-	O
1	int
)	O
)	O
;	O
if	O
(	O
*	O
d	int
>	O
i	int
)	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
if	O
(	O
mm	int
&&	O
(	O
rc_week_flag	int
||	O
rc_tomorrow_flag	int
)	O
)	O
{	O
if	O
(	O
(	O
*	O
n	long
==	O
1	int
)	O
&&	O
(	O
mm	int
!=	O
*	O
m	int
)	O
)	O
{	O
*	O
m	int
=	O
mm	int
;	O
if	O
(	O
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
>	O
0	int
)	O
&&	O
(	O
day	int
+	O
DAY_MAX	int
-	O
1	int
<	O
DAY_LAST	int
+	O
is_leap_year	int
+	O
1	int
)	O
)	O
;	O
else	O
if	O
(	O
year_set	int
&&	O
(	O
year	int
<	O
YEAR_MAX	int
)	O
)	O
*	O
y	int
=	O
year	int
+	O
1	int
;	O
*	O
d	int
=	O
eval_holiday	function
(	O
DAY_MIN	int
,	O
*	O
m	int
,	O
*	O
y	int
,	O
dd	int
,	O
TRUE	O
)	O
;	O
}	O
else	O
if	O
(	O
(	O
*	O
n	long
>	O
3	int
)	O
&&	O
(	O
(	O
adate_set	int
&&	O
(	O
mm	int
==	O
*	O
m	int
)	O
)	O
||	O
(	O
!	O
adate_set	int
&&	O
(	O
mm	int
!=	O
*	O
m	int
)	O
)	O
)	O
)	O
{	O
if	O
(	O
!	O
adate_set	int
)	O
*	O
m	int
=	O
mm	int
;	O
if	O
(	O
year_set	int
&&	O
(	O
year	int
>	O
YEAR_MIN	int
)	O
)	O
*	O
y	int
=	O
year	int
-	O
1	int
;	O
if	O
(	O
*	O
n	long
==	O
9	int
)	O
*	O
d	int
=	O
eval_holiday	function
(	O
dvec	array
[	O
MONTH_MAX	int
-	O
1	int
]	O
,	O
*	O
m	int
,	O
*	O
y	int
,	O
dd	int
,	O
FALSE	O
)	O
;	O
else	O
{	O
*	O
d	int
=	O
eval_holiday	function
(	O
DAY_MIN	int
,	O
*	O
m	int
,	O
*	O
y	int
,	O
dd	int
,	O
TRUE	O
)	O
;	O
*	O
d	int
+=	O
(	O
DAY_MAX	int
*	O
(	O
*	O
n	long
-	O
1	int
)	O
)	O
;	O
if	O
(	O
*	O
d	int
>	O
dvec	array
[	O
MONTH_MAX	int
-	O
1	int
]	O
)	O
*	O
y	int
=	O
SPECIAL_VALUE	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
Slint	long
d_between	function
(	O
d1	int
,	O
m1	int
,	O
y1	function
,	O
d2	int
,	O
m2	int
,	O
y2	int
)	O
const	O
int	O
d1	int
;	O
const	O
int	O
m1	int
;	O
const	O
int	O
y1	function
;	O
const	O
int	O
d2	int
;	O
const	O
int	O
m2	int
;	O
const	O
int	O
y2	int
;	O
{	O
return	O
(	O
date2num	function
(	O
d2	int
,	O
m2	int
,	O
y2	int
)	O
-	O
date2num	function
(	O
d1	int
,	O
m1	int
,	O
y1	function
)	O
)	O
;	O
}	O
Slint	long
w_between	function
(	O
d1	int
,	O
m1	int
,	O
y1	function
,	O
d2	int
,	O
m2	int
,	O
y2	int
)	O
const	O
int	O
d1	int
;	O
const	O
int	O
m1	int
;	O
const	O
int	O
y1	function
;	O
const	O
int	O
d2	int
;	O
const	O
int	O
m2	int
;	O
const	O
int	O
y2	int
;	O
{	O
auto	O
Ulint	long
date1	long
=	O
date2num	function
(	O
d1	int
,	O
m1	int
,	O
y1	function
)	O
;	O
auto	O
Ulint	long
date2	long
=	O
date2num	function
(	O
d2	int
,	O
m2	int
,	O
y2	int
)	O
;	O
auto	O
Slint	long
diff	int
;	O
auto	O
Slint	long
result	long
;	O
diff	int
=	O
(	O
Slint	long
)	O
date2	long
-	O
(	O
date1	long
-	O
(	O
SYEAR	O
(	O
weekday_of_date	function
(	O
d1	int
,	O
m1	int
,	O
y1	function
)	O
,	O
start_day	int
)	O
)	O
+	O
1	int
)	O
;	O
result	long
=	O
diff	int
/	O
DAY_MAX	int
;	O
if	O
(	O
(	O
diff	int
%	O
DAY_MAX	int
)	O
&&	O
(	O
diff	int
<	O
0L	int
)	O
)	O
result	long
--	O
;	O
return	O
(	O
result	long
)	O
;	O
}	O
Slint	long
m_between	function
(	O
m1	int
,	O
y1	function
,	O
m2	int
,	O
y2	int
)	O
const	O
int	O
m1	int
;	O
const	O
int	O
y1	function
;	O
const	O
int	O
m2	int
;	O
const	O
int	O
y2	int
;	O
{	O
return	O
(	O
(	O
(	O
y2	int
-	O
y1	function
)	O
*	O
MONTH_MAX	int
)	O
+	O
(	O
m2	int
-	O
m1	int
)	O
)	O
;	O
}	O
void	O
manage_leap_day	function
(	O
day	int
,	O
month	int
,	O
year	int
,	O
line_buffer	pointer
,	O
filename	pointer
,	O
line_number	long
)	O
int	O
*	O
day	int
;	O
int	O
*	O
month	int
;	O
int	O
year	int
;	O
const	O
char	O
*	O
line_buffer	pointer
;	O
const	O
char	O
*	O
filename	pointer
;	O
const	O
long	O
line_number	long
;	O
{	O
register	O
int	O
action	int
=	O
0	int
;	O
if	O
(	O
(	O
*	O
month	int
==	O
2	int
)	O
&&	O
(	O
*	O
day	int
==	O
29	int
)	O
&&	O
(	O
rc_feb_29_to_feb_28	int
||	O
rc_feb_29_to_mar_01	int
)	O
)	O
{	O
if	O
(	O
(	O
fiscal_month	int
>	O
MONTH_MIN	int
+	O
1	int
)	O
&&	O
(	O
year	int
<	O
YEAR_MAX	int
)	O
)	O
{	O
if	O
(	O
days_of_february	function
(	O
year	int
+	O
1	int
)	O
==	O
28	int
)	O
{	O
if	O
(	O
rc_feb_29_to_feb_28	int
)	O
*	O
day	int
=	O
action	int
=	O
28	int
;	O
else	O
{	O
*	O
day	int
=	O
action	int
=	O
DAY_MIN	int
;	O
(	O
*	O
month	int
)	O
++	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
days_of_february	function
(	O
year	int
)	O
==	O
28	int
)	O
{	O
if	O
(	O
rc_feb_29_to_feb_28	int
)	O
*	O
day	int
=	O
action	int
=	O
28	int
;	O
else	O
{	O
*	O
day	int
=	O
action	int
=	O
DAY_MIN	int
;	O
(	O
*	O
month	int
)	O
++	O
;	O
}	O
}	O
if	O
(	O
(	O
warning_level	int
>=	O
0	int
)	O
&&	O
action	int
)	O
{	O
*	O
s5	pointer
=	O
'\0'	O
;	O
print_text	function
(	O
stderr	pointer
,	O
s5	pointer
)	O
;	O
action	int
=	O
(	O
int	O
)	O
strlen	function
(	O
filename	pointer
)	O
+	O
LEN_SINGLE_LINE	int
;	O
if	O
(	O
(	O
Uint	int
)	O
action	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
action	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"Leap-day set to `%02d-%s' in file `%s'."	pointer
)	O
,	O
*	O
day	int
,	O
month_name	function
(	O
*	O
month	int
)	O
,	O
filename	pointer
)	O
;	O
print_text	function
(	O
stderr	pointer
,	O
s5	pointer
)	O
;	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"Line %ld: %s"	pointer
)	O
,	O
line_number	long
,	O
line_buffer	pointer
)	O
;	O
print_text	function
(	O
stderr	pointer
,	O
s5	pointer
)	O
;	O
}	O
}	O
}	O
char	O
*	O
biorhythm	function
(	O
create_bar	int
,	O
axis_len	int
,	O
string	pointer
,	O
day	int
,	O
month	int
,	O
year	int
,	O
birth_day	int
,	O
birth_month	int
,	O
birth_year	int
,	O
emo_text	pointer
,	O
emo_phase	pointer
,	O
emo_waxes	pointer
,	O
int_text	pointer
,	O
int_phase	pointer
,	O
int_waxes	pointer
,	O
phy_text	pointer
,	O
phy_phase	pointer
,	O
phy_waxes	pointer
,	O
critical_day	pointer
,	O
positive_day	pointer
,	O
negative_day	pointer
)	O
const	O
Bool	int
create_bar	int
;	O
int	O
axis_len	int
;	O
char	O
*	O
string	pointer
;	O
const	O
int	O
day	int
;	O
const	O
int	O
month	int
;	O
const	O
int	O
year	int
;	O
const	O
int	O
birth_day	int
;	O
const	O
int	O
birth_month	int
;	O
const	O
int	O
birth_year	int
;	O
const	O
char	O
*	O
emo_text	pointer
;	O
int	O
*	O
emo_phase	pointer
;	O
int	O
*	O
emo_waxes	pointer
;	O
const	O
char	O
*	O
int_text	pointer
;	O
int	O
*	O
int_phase	pointer
;	O
int	O
*	O
int_waxes	pointer
;	O
const	O
char	O
*	O
phy_text	pointer
;	O
int	O
*	O
phy_phase	pointer
;	O
int	O
*	O
phy_waxes	pointer
;	O
int	O
*	O
critical_day	pointer
;	O
int	O
*	O
positive_day	pointer
;	O
int	O
*	O
negative_day	pointer
;	O
{	O
auto	O
double	O
x	double
;	O
auto	O
Slint	long
diff	int
=	O
d_between	function
(	O
birth_day	int
,	O
birth_month	int
,	O
birth_year	int
,	O
day	int
,	O
month	int
,	O
year	int
)	O
;	O
register	O
int	O
yes_phase	int
;	O
register	O
int	O
yes_waxes	int
;	O
register	O
int	O
i	int
;	O
(	O
*	O
critical_day	pointer
)	O
=	O
(	O
*	O
positive_day	pointer
)	O
=	O
(	O
*	O
negative_day	pointer
)	O
=	O
(	O
*	O
emo_waxes	pointer
)	O
=	O
(	O
*	O
int_waxes	pointer
)	O
=	O
(	O
*	O
phy_waxes	pointer
)	O
=	O
0	int
;	O
if	O
(	O
create_bar	int
)	O
{	O
auto	O
char	O
*	O
ptr_string	pointer
;	O
for	O
(	O
i	int
=	O
BIO_AXIS_TOTAL	O
(	O
axis_len	int
)	O
,	O
ptr_string	pointer
=	O
string	pointer
;	O
--	O
i	int
;	O
)	O
*	O
ptr_string	pointer
++	O
=	O
' '	O
;	O
string	pointer
[	O
BIO_AXIS_TOTAL	O
(	O
axis_len	int
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
string	pointer
[	O
BIO_AXIS_EXTRA	int
-	O
1	int
]	O
=	O
*	O
BIO_WANES	O
;	O
string	pointer
[	O
BIO_AXIS_TOTAL	O
(	O
axis_len	int
)	O
-	O
BIO_AXIS_EXTRA	int
-	O
1	int
]	O
=	O
*	O
BIO_WAXES	O
;	O
}	O
if	O
(	O
diff	int
<	O
1L	int
)	O
diff	int
=	O
21252L	int
-	O
(	O
-	O
diff	int
%	O
21252L	int
)	O
;	O
else	O
diff	int
%=	O
21252L	int
;	O
x	double
=	O
MY_TWO_PI	int
*	O
(	O
diff	int
-	O
1L	int
)	O
/	O
28.0	int
;	O
yes_phase	int
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	function
(	O
x	double
)	O
)	O
;	O
yes_waxes	int
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	function
(	O
x	double
)	O
)	O
)	O
;	O
x	double
=	O
MY_TWO_PI	int
*	O
diff	int
/	O
28.0	int
;	O
*	O
emo_phase	pointer
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	function
(	O
x	double
)	O
)	O
;	O
*	O
emo_waxes	pointer
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	function
(	O
x	double
)	O
)	O
)	O
;	O
if	O
(	O
*	O
emo_phase	pointer
==	O
100	int
)	O
(	O
*	O
positive_day	pointer
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
100	int
)	O
&&	O
(	O
*	O
emo_waxes	pointer
<=	O
0	int
)	O
)	O
(	O
*	O
positive_day	pointer
)	O
++	O
;	O
if	O
(	O
*	O
emo_phase	pointer
==	O
-	O
100	int
)	O
(	O
*	O
negative_day	pointer
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
-	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
-	O
100	int
)	O
&&	O
(	O
*	O
emo_waxes	pointer
>=	O
0	int
)	O
)	O
(	O
*	O
negative_day	pointer
)	O
++	O
;	O
*	O
emo_waxes	pointer
=	O
(	O
*	O
emo_waxes	pointer
>=	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
emo_phase	pointer
)	O
<=	O
0	int
)	O
)	O
||	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
-	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
emo_phase	pointer
)	O
>=	O
0	int
)	O
)	O
)	O
(	O
*	O
critical_day	pointer
)	O
++	O
;	O
x	double
=	O
MY_TWO_PI	int
*	O
(	O
diff	int
-	O
1L	int
)	O
/	O
33.0	int
;	O
yes_phase	int
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	function
(	O
x	double
)	O
)	O
;	O
yes_waxes	int
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	function
(	O
x	double
)	O
)	O
)	O
;	O
x	double
=	O
MY_TWO_PI	int
*	O
diff	int
/	O
33.0	int
;	O
*	O
int_phase	pointer
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	function
(	O
x	double
)	O
)	O
;	O
*	O
int_waxes	pointer
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	function
(	O
x	double
)	O
)	O
)	O
;	O
if	O
(	O
*	O
int_phase	pointer
==	O
100	int
)	O
(	O
*	O
positive_day	pointer
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
100	int
)	O
&&	O
(	O
*	O
int_waxes	pointer
<=	O
0	int
)	O
)	O
(	O
*	O
positive_day	pointer
)	O
++	O
;	O
if	O
(	O
*	O
int_phase	pointer
==	O
-	O
100	int
)	O
(	O
*	O
negative_day	pointer
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
-	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
-	O
100	int
)	O
&&	O
(	O
*	O
int_waxes	pointer
>=	O
0	int
)	O
)	O
(	O
*	O
negative_day	pointer
)	O
++	O
;	O
*	O
int_waxes	pointer
=	O
(	O
*	O
int_waxes	pointer
>=	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
int_phase	pointer
)	O
<=	O
0	int
)	O
)	O
||	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
-	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
int_phase	pointer
)	O
>=	O
0	int
)	O
)	O
)	O
(	O
*	O
critical_day	pointer
)	O
++	O
;	O
x	double
=	O
MY_TWO_PI	int
*	O
(	O
diff	int
-	O
1L	int
)	O
/	O
23.0	int
;	O
yes_phase	int
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	function
(	O
x	double
)	O
)	O
;	O
yes_waxes	int
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	function
(	O
x	double
)	O
)	O
)	O
;	O
x	double
=	O
MY_TWO_PI	int
*	O
diff	int
/	O
23.0	int
;	O
*	O
phy_phase	pointer
=	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
sin	function
(	O
x	double
)	O
)	O
;	O
*	O
phy_waxes	pointer
=	O
SGN	O
(	O
(	O
int	O
)	O
ROUND	O
(	O
100.0	int
*	O
cos	function
(	O
x	double
)	O
)	O
)	O
;	O
if	O
(	O
*	O
phy_phase	pointer
==	O
100	int
)	O
(	O
*	O
positive_day	pointer
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
100	int
)	O
&&	O
(	O
*	O
phy_waxes	pointer
<=	O
0	int
)	O
)	O
(	O
*	O
positive_day	pointer
)	O
++	O
;	O
if	O
(	O
*	O
phy_phase	pointer
==	O
-	O
100	int
)	O
(	O
*	O
negative_day	pointer
)	O
++	O
;	O
else	O
if	O
(	O
(	O
yes_waxes	int
==	O
-	O
1	int
)	O
&&	O
(	O
yes_phase	int
!=	O
-	O
100	int
)	O
&&	O
(	O
*	O
phy_waxes	pointer
>=	O
0	int
)	O
)	O
(	O
*	O
negative_day	pointer
)	O
++	O
;	O
*	O
phy_waxes	pointer
=	O
(	O
*	O
phy_waxes	pointer
>=	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
phy_phase	pointer
)	O
<=	O
0	int
)	O
)	O
||	O
(	O
(	O
SGN	O
(	O
yes_phase	int
)	O
==	O
-	O
1	int
)	O
&&	O
(	O
SGN	O
(	O
*	O
phy_phase	pointer
)	O
>=	O
0	int
)	O
)	O
)	O
(	O
*	O
critical_day	pointer
)	O
++	O
;	O
if	O
(	O
create_bar	int
)	O
{	O
i	int
=	O
*	O
emo_phase	pointer
/	O
BIO_AXIS_SCALE	O
(	O
axis_len	int
)	O
;	O
if	O
(	O
SGN	O
(	O
*	O
emo_phase	pointer
)	O
>=	O
0	int
)	O
i	int
+=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
;	O
else	O
i	int
=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
+	O
i	int
;	O
if	O
(	O
string	pointer
[	O
i	int
]	O
==	O
' '	O
)	O
string	pointer
[	O
i	int
]	O
=	O
*	O
emo_text	pointer
;	O
else	O
string	pointer
[	O
i	int
]	O
=	O
*	O
BIO_OVERLAPS	O
;	O
i	int
=	O
*	O
int_phase	pointer
/	O
BIO_AXIS_SCALE	O
(	O
axis_len	int
)	O
;	O
if	O
(	O
SGN	O
(	O
*	O
int_phase	pointer
)	O
>=	O
0	int
)	O
i	int
+=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
;	O
else	O
i	int
=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
+	O
i	int
;	O
if	O
(	O
string	pointer
[	O
i	int
]	O
==	O
' '	O
)	O
string	pointer
[	O
i	int
]	O
=	O
*	O
int_text	pointer
;	O
else	O
string	pointer
[	O
i	int
]	O
=	O
*	O
BIO_OVERLAPS	O
;	O
i	int
=	O
*	O
phy_phase	pointer
/	O
BIO_AXIS_SCALE	O
(	O
axis_len	int
)	O
;	O
if	O
(	O
SGN	O
(	O
*	O
phy_phase	pointer
)	O
>=	O
0	int
)	O
i	int
+=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
;	O
else	O
i	int
=	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
+	O
i	int
;	O
if	O
(	O
string	pointer
[	O
i	int
]	O
==	O
' '	O
)	O
string	pointer
[	O
i	int
]	O
=	O
*	O
phy_text	pointer
;	O
else	O
string	pointer
[	O
i	int
]	O
=	O
*	O
BIO_OVERLAPS	O
;	O
*	O
string	pointer
=	O
DIG2CHR	O
(	O
*	O
negative_day	pointer
)	O
;	O
string	pointer
[	O
BIO_AXIS_TOTAL	O
(	O
axis_len	int
)	O
-	O
BIO_AXIS_EXTRA	int
]	O
=	O
DIG2CHR	O
(	O
*	O
positive_day	pointer
)	O
;	O
string	pointer
[	O
BIO_AXIS_ZERO	O
(	O
axis_len	int
)	O
]	O
=	O
DIG2CHR	O
(	O
*	O
critical_day	pointer
)	O
;	O
}	O
return	O
(	O
string	pointer
)	O
;	O
}	O
double	O
compute_distance	function
(	O
coor1	pointer
,	O
coor2	pointer
)	O
const	O
Coor_struct	struct
*	O
coor1	pointer
;	O
const	O
Coor_struct	struct
*	O
coor2	pointer
;	O
{	O
auto	O
double	O
lon_c1	double
=	O
TORAD	O
(	O
coor1	pointer
->	O
lon_deg	int
+	O
MM2DEG	O
(	O
coor1	pointer
->	O
lon_min	int
)	O
+	O
SS2DEG	O
(	O
coor1	pointer
->	O
lon_sec	int
)	O
)	O
;	O
auto	O
double	O
lat_c1	double
=	O
TORAD	O
(	O
coor1	pointer
->	O
lat_deg	int
+	O
MM2DEG	O
(	O
coor1	pointer
->	O
lat_min	int
)	O
+	O
SS2DEG	O
(	O
coor1	pointer
->	O
lat_sec	int
)	O
)	O
;	O
auto	O
double	O
lon_c2	double
=	O
TORAD	O
(	O
coor2	pointer
->	O
lon_deg	int
+	O
MM2DEG	O
(	O
coor2	pointer
->	O
lon_min	int
)	O
+	O
SS2DEG	O
(	O
coor2	pointer
->	O
lon_sec	int
)	O
)	O
;	O
auto	O
double	O
lat_c2	double
=	O
TORAD	O
(	O
coor2	pointer
->	O
lat_deg	int
+	O
MM2DEG	O
(	O
coor2	pointer
->	O
lat_min	int
)	O
+	O
SS2DEG	O
(	O
coor2	pointer
->	O
lat_sec	int
)	O
)	O
;	O
auto	O
double	O
delta_lambda	double
;	O
auto	O
double	O
x1	double
;	O
auto	O
double	O
x2	double
;	O
switch	O
(	O
coor1	pointer
->	O
the_mode	int
)	O
{	O
case	O
0	int
:	O
x1	double
=	O
gd_latitude2gc_latitude	function
(	O
lat_c1	double
,	O
coor1	pointer
->	O
meters_above_sea_level	int
,	O
&	O
lat_c1	double
)	O
;	O
x2	double
=	O
gd_latitude2gc_latitude	function
(	O
lat_c2	double
,	O
coor2	pointer
->	O
meters_above_sea_level	int
,	O
&	O
lat_c2	double
)	O
;	O
if	O
(	O
SGN	O
(	O
lat_c1	double
)	O
==	O
0	int
||	O
SGN	O
(	O
lat_c2	double
)	O
==	O
0	int
||	O
SGN	O
(	O
lat_c1	double
)	O
==	O
SGN	O
(	O
lat_c2	double
)	O
)	O
{	O
delta_lambda	double
=	O
(	O
x1	double
+	O
x2	double
)	O
*	O
0.5	int
;	O
x1	double
=	O
2.0	int
*	O
MAX	O
(	O
x1	double
,	O
delta_lambda	double
)	O
+	O
MIN	O
(	O
x1	double
,	O
delta_lambda	double
)	O
+	O
2.0	int
*	O
MAX	O
(	O
x2	double
,	O
delta_lambda	double
)	O
+	O
MIN	O
(	O
x2	double
,	O
delta_lambda	double
)	O
;	O
}	O
else	O
x1	double
=	O
4.0	int
*	O
EQUATOR_EARTH_RADIUS	int
+	O
x1	double
+	O
x2	double
;	O
delta_lambda	double
=	O
lon_c1	double
-	O
lon_c2	double
;	O
return	O
(	O
DEG2DAY	O
(	O
TODEG	O
(	O
acos	function
(	O
sin	function
(	O
lat_c1	double
)	O
*	O
sin	function
(	O
lat_c2	double
)	O
+	O
cos	function
(	O
lat_c1	double
)	O
*	O
cos	function
(	O
lat_c2	double
)	O
*	O
cos	function
(	O
delta_lambda	double
)	O
)	O
)	O
)	O
*	O
(	O
x1	double
/	O
6000.0	int
)	O
*	O
MY_TWO_PI	int
)	O
;	O
case	O
1	int
:	O
delta_lambda	double
=	O
lon_c1	double
-	O
lon_c2	double
;	O
x1	double
=	O
cos	function
(	O
lat_c1	double
)	O
*	O
tan	function
(	O
lat_c2	double
)	O
-	O
sin	function
(	O
lat_c1	double
)	O
*	O
cos	function
(	O
delta_lambda	double
)	O
;	O
break	O
;	O
case	O
2	int
:	O
delta_lambda	double
=	O
lon_c2	double
-	O
lon_c1	double
;	O
x1	double
=	O
cos	function
(	O
lat_c2	double
)	O
*	O
tan	function
(	O
lat_c1	double
)	O
-	O
sin	function
(	O
lat_c2	double
)	O
*	O
cos	function
(	O
delta_lambda	double
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
x2	double
=	O
sin	function
(	O
delta_lambda	double
)	O
;	O
if	O
(	O
x1	double
>	O
0.0	int
)	O
delta_lambda	double
=	O
atan	function
(	O
x2	double
/	O
x1	double
)	O
;	O
else	O
if	O
(	O
x1	double
<	O
0.0	int
)	O
delta_lambda	double
=	O
atan	function
(	O
x2	double
/	O
x1	double
)	O
+	O
MY_PI	int
;	O
else	O
if	O
(	O
x2	double
>	O
0.0	int
)	O
delta_lambda	double
=	O
MY_HALF_PI	int
;	O
else	O
if	O
(	O
x2	double
<	O
0.0	int
)	O
delta_lambda	double
=	O
-	O
MY_HALF_PI	int
;	O
else	O
return	O
(	O
SPECIAL_VALUE	O
)	O
;	O
if	O
(	O
SGN	O
(	O
delta_lambda	double
)	O
>	O
0	int
)	O
delta_lambda	double
=	O
MY_TWO_PI	int
-	O
delta_lambda	double
;	O
else	O
if	O
(	O
SGN	O
(	O
delta_lambda	double
)	O
<	O
0	int
)	O
delta_lambda	double
=	O
-	O
delta_lambda	double
;	O
return	O
(	O
TODEG	O
(	O
delta_lambda	double
)	O
)	O
;	O
}	O
static	O
void	O
var_warning	function
(	O
exit_status	int
,	O
var_name	pointer
,	O
line_buffer	pointer
,	O
filename	pointer
,	O
line_number	long
)	O
const	O
int	O
exit_status	int
;	O
const	O
int	O
var_name	pointer
;	O
const	O
char	O
*	O
line_buffer	pointer
;	O
const	O
char	O
*	O
filename	pointer
;	O
const	O
long	O
line_number	long
;	O
{	O
register	O
int	O
i	int
;	O
auto	O
Bool	int
with_usage	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
line_number	long
)	O
S_NEWLINE	O
(	O
stderr	pointer
)	O
;	O
else	O
{	O
*	O
s5	pointer
=	O
'\0'	O
;	O
print_text	function
(	O
stderr	pointer
,	O
s5	pointer
)	O
;	O
}	O
if	O
(	O
warning_level	int
>=	O
WARN_LVL_MAX	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s: abort, "	pointer
)	O
,	O
prgr_name	pointer
)	O
;	O
i	int
=	O
(	O
int	O
)	O
strlen	function
(	O
filename	pointer
)	O
+	O
LEN_SINGLE_LINE	int
;	O
if	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
i	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
switch	O
(	O
exit_status	int
)	O
{	O
case	O
ERR_ILLEGAL_VAR_DEFINITION	int
:	O
if	O
(	O
line_number	long
)	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"illegal variable definition in file `%s'"	pointer
)	O
,	O
filename	pointer
)	O
;	O
else	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"illegal definition of variable `%c'"	pointer
)	O
,	O
(	O
char	O
)	O
var_name	pointer
)	O
;	O
if	O
(	O
!	O
line_number	long
)	O
with_usage	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
ERR_ILLEGAL_VAR_OPERATION	int
:	O
if	O
(	O
line_number	long
)	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"illegal variable operation in file `%s'"	pointer
)	O
,	O
filename	pointer
)	O
;	O
else	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"illegal operation on variable `%c'"	pointer
)	O
,	O
(	O
char	O
)	O
var_name	pointer
)	O
;	O
if	O
(	O
!	O
line_number	long
)	O
with_usage	int
=	O
TRUE	O
;	O
break	O
;	O
case	O
ERR_INVALID_VAR_REFERENCE	int
:	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"variable `%c' undefined in file `%s'"	pointer
)	O
,	O
(	O
char	O
)	O
var_name	pointer
,	O
filename	pointer
)	O
;	O
break	O
;	O
case	O
ERR_INVALID_VAR_ASSIGNMENT	int
:	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"invalid value assigned to variable `%c' in file `%s'"	pointer
)	O
,	O
(	O
char	O
)	O
var_name	pointer
,	O
filename	pointer
)	O
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
warning_level	int
<	O
WARN_LVL_MAX	int
)	O
{	O
*	O
s5	pointer
=	O
(	O
char	O
)	O
toupper	function
(	O
*	O
s5	pointer
)	O
;	O
strcat	function
(	O
s5	pointer
,	O
"."	pointer
)	O
;	O
}	O
if	O
(	O
!	O
line_number	long
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
s5	pointer
)	O
;	O
else	O
print_text	function
(	O
stderr	pointer
,	O
s5	pointer
)	O
;	O
if	O
(	O
warning_level	int
>=	O
WARN_LVL_MAX	int
)	O
{	O
if	O
(	O
!	O
line_number	long
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Invalid argument in command line given -- %s"	pointer
)	O
,	O
line_buffer	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Line %ld: %s"	pointer
)	O
,	O
line_number	long
,	O
line_buffer	pointer
)	O
;	O
S_NEWLINE	O
(	O
stderr	pointer
)	O
;	O
}	O
else	O
{	O
i	int
=	O
(	O
int	O
)	O
strlen	function
(	O
line_buffer	pointer
)	O
+	O
LEN_SINGLE_LINE	int
;	O
if	O
(	O
(	O
Uint	int
)	O
i	int
>=	O
maxlen_max	int
)	O
resize_all_strings	function
(	O
i	int
+	O
1	int
,	O
FALSE	O
,	O
__FILE__	O
,	O
(	O
long	O
)	O
__LINE__	O
)	O
;	O
if	O
(	O
!	O
line_number	long
)	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"Argument `%s' of command line ignored."	pointer
)	O
,	O
line_buffer	pointer
)	O
;	O
else	O
sprintf	function
(	O
s5	pointer
,	O
_	O
(	O
"Line %ld ignored: %s"	pointer
)	O
,	O
line_number	long
,	O
line_buffer	pointer
)	O
;	O
if	O
(	O
!	O
line_number	long
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n"	pointer
,	O
s5	pointer
)	O
;	O
else	O
print_text	function
(	O
stderr	pointer
,	O
s5	pointer
)	O
;	O
}	O
if	O
(	O
with_usage	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s\n%s\n"	pointer
,	O
usage_msg	function
(	O
)	O
,	O
lopt_msg	function
(	O
)	O
)	O
;	O
if	O
(	O
warning_level	int
>=	O
WARN_LVL_MAX	int
)	O
my_exit	function
(	O
exit_status	int
)	O
;	O
}	O
