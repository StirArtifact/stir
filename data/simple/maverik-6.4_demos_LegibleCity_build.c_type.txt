extern	O
MAV_BB	O
city_bb	int
;	O
extern	O
MAV_SMS	O
*	O
city_build	pointer
;	O
Alphabet	struct
alphabet	array
[	O
255	int
]	O
;	O
static	O
int	O
ascii	array
[	O
NUM_LETTERS	int
]	O
=	O
{	O
33	int
,	O
38	int
,	O
39	int
,	O
40	int
,	O
41	int
,	O
44	int
,	O
45	int
,	O
46	int
,	O
47	int
,	O
48	int
,	O
49	int
,	O
50	int
,	O
51	int
,	O
52	int
,	O
53	int
,	O
54	int
,	O
55	int
,	O
56	int
,	O
57	int
,	O
58	int
,	O
61	int
,	O
63	int
,	O
65	int
,	O
66	int
,	O
67	int
,	O
68	int
,	O
69	int
,	O
70	int
,	O
71	int
,	O
72	int
,	O
73	int
,	O
74	int
,	O
75	int
,	O
76	int
,	O
77	int
,	O
78	int
,	O
79	int
,	O
80	int
,	O
81	int
,	O
82	int
,	O
83	int
,	O
84	int
,	O
85	int
,	O
86	int
,	O
87	int
,	O
88	int
,	O
89	int
,	O
90	int
,	O
96	int
,	O
128	int
,	O
130	int
,	O
131	int
,	O
133	int
,	O
136	int
,	O
138	int
,	O
140	int
,	O
141	int
,	O
142	int
,	O
147	int
,	O
149	int
,	O
150	int
,	O
151	int
,	O
153	int
,	O
154	int
,	O
225	int
}	O
;	O
static	O
float	O
letter_widths	array
[	O
NUM_LETTERS	int
+	O
1	int
]	O
[	O
2	int
]	O
=	O
{	O
{	O
32.0	int
,	O
0.8	int
}	O
,	O
{	O
33.0	int
,	O
0.3277	int
}	O
,	O
{	O
38.0	int
,	O
1.0217	int
}	O
,	O
{	O
39.0	int
,	O
0.2121	int
}	O
,	O
{	O
40.0	int
,	O
0.3374	int
}	O
,	O
{	O
41.0	int
,	O
0.3374	int
}	O
,	O
{	O
44.0	int
,	O
0.2313	int
}	O
,	O
{	O
45.0	int
,	O
0.6169	int
}	O
,	O
{	O
46.0	int
,	O
0.2313	int
}	O
,	O
{	O
47.0	int
,	O
0.7615	int
}	O
,	O
{	O
48.0	int
,	O
0.7615	int
}	O
,	O
{	O
49.0	int
,	O
0.5783	int
}	O
,	O
{	O
50.0	int
,	O
0.7615	int
}	O
,	O
{	O
51.0	int
,	O
0.6458	int
}	O
,	O
{	O
52.0	int
,	O
0.9350	int
}	O
,	O
{	O
53.0	int
,	O
0.7711	int
}	O
,	O
{	O
54.0	int
,	O
0.7615	int
}	O
,	O
{	O
55.0	int
,	O
0.6651	int
}	O
,	O
{	O
56.0	int
,	O
0.7615	int
}	O
,	O
{	O
57.0	int
,	O
0.7615	int
}	O
,	O
{	O
58.0	int
,	O
0.2313	int
}	O
,	O
{	O
61.0	int
,	O
0.6169	int
}	O
,	O
{	O
63.0	int
,	O
0.7615	int
}	O
,	O
{	O
65.0	int
,	O
0.8000	int
}	O
,	O
{	O
66.0	int
,	O
0.7615	int
}	O
,	O
{	O
67.0	int
,	O
0.7615	int
}	O
,	O
{	O
68.0	int
,	O
0.7615	int
}	O
,	O
{	O
69.0	int
,	O
0.6169	int
}	O
,	O
{	O
70.0	int
,	O
0.5783	int
}	O
,	O
{	O
71.0	int
,	O
0.7615	int
}	O
,	O
{	O
72.0	int
,	O
0.7615	int
}	O
,	O
{	O
73.0	int
,	O
0.2410	int
}	O
,	O
{	O
74.0	int
,	O
0.7615	int
}	O
,	O
{	O
75.0	int
,	O
0.8000	int
}	O
,	O
{	O
76.0	int
,	O
0.5494	int
}	O
,	O
{	O
77.0	int
,	O
1.0217	int
}	O
,	O
{	O
78.0	int
,	O
0.8000	int
}	O
,	O
{	O
79.0	int
,	O
0.7615	int
}	O
,	O
{	O
80.0	int
,	O
0.7615	int
}	O
,	O
{	O
81.0	int
,	O
0.8771	int
}	O
,	O
{	O
82.0	int
,	O
0.7615	int
}	O
,	O
{	O
83.0	int
,	O
0.7615	int
}	O
,	O
{	O
84.0	int
,	O
0.8675	int
}	O
,	O
{	O
85.0	int
,	O
0.7615	int
}	O
,	O
{	O
86.0	int
,	O
0.8000	int
}	O
,	O
{	O
87.0	int
,	O
1.3302	int
}	O
,	O
{	O
88.0	int
,	O
0.8964	int
}	O
,	O
{	O
89.0	int
,	O
0.7904	int
}	O
,	O
{	O
90.0	int
,	O
0.6651	int
}	O
,	O
{	O
96.0	int
,	O
0.2121	int
}	O
,	O
{	O
128.0	int
,	O
0.7615	int
}	O
,	O
{	O
130.0	int
,	O
0.6169	int
}	O
,	O
{	O
131.0	int
,	O
0.8000	int
}	O
,	O
{	O
133.0	int
,	O
0.8000	int
}	O
,	O
{	O
136.0	int
,	O
0.6169	int
}	O
,	O
{	O
138.0	int
,	O
0.6169	int
}	O
,	O
{	O
140.0	int
,	O
0.6169	int
}	O
,	O
{	O
141.0	int
,	O
0.2410	int
}	O
,	O
{	O
142.0	int
,	O
0.8000	int
}	O
,	O
{	O
147.0	int
,	O
0.7615	int
}	O
,	O
{	O
149.0	int
,	O
0.7615	int
}	O
,	O
{	O
150.0	int
,	O
0.7615	int
}	O
,	O
{	O
151.0	int
,	O
0.7615	int
}	O
,	O
{	O
153.0	int
,	O
0.7615	int
}	O
,	O
{	O
154.0	int
,	O
0.7615	int
}	O
,	O
{	O
225.0	int
,	O
0.7615	int
}	O
}	O
;	O
static	O
float	O
colours	array
[	O
NUM_COLOURS	int
]	O
[	O
3	int
]	O
=	O
{	O
{	O
1.0000	int
,	O
0.6627	int
,	O
0.2588	int
}	O
,	O
{	O
0.8118	int
,	O
0.5176	int
,	O
0.3529	int
}	O
,	O
{	O
1.0000	int
,	O
0.3725	int
,	O
0.0118	int
}	O
,	O
{	O
1.0000	int
,	O
0.3333	int
,	O
0.0902	int
}	O
,	O
{	O
1.0000	int
,	O
0.1765	int
,	O
0.0471	int
}	O
,	O
{	O
0.9490	int
,	O
0.4471	int
,	O
0.1333	int
}	O
,	O
{	O
1.0000	int
,	O
0.0902	int
,	O
0.0235	int
}	O
,	O
{	O
1.0000	int
,	O
0.6627	int
,	O
0.2588	int
}	O
,	O
{	O
0.9490	int
,	O
0.4471	int
,	O
0.1333	int
}	O
,	O
{	O
1.0000	int
,	O
0.3333	int
,	O
0.0902	int
}	O
,	O
{	O
0.6745	int
,	O
0.4824	int
,	O
0.4824	int
}	O
,	O
{	O
0.8118	int
,	O
0.5176	int
,	O
0.3529	int
}	O
,	O
{	O
1.0000	int
,	O
0.1020	int
,	O
0.0902	int
}	O
,	O
{	O
1.0000	int
,	O
0.5098	int
,	O
0.0824	int
}	O
,	O
{	O
0.9882	int
,	O
0.1725	int
,	O
0.2275	int
}	O
,	O
{	O
0.9490	int
,	O
0.4471	int
,	O
0.1333	int
}	O
,	O
{	O
1.0000	int
,	O
0.1020	int
,	O
0.0902	int
}	O
,	O
{	O
1.0000	int
,	O
0.1765	int
,	O
0.0471	int
}	O
,	O
{	O
1.0000	int
,	O
0.3333	int
,	O
0.0902	int
}	O
,	O
{	O
0.9922	int
,	O
0.0078	int
,	O
0.0078	int
}	O
,	O
{	O
1.0000	int
,	O
0.3059	int
,	O
0.2118	int
}	O
,	O
{	O
0.9490	int
,	O
0.4471	int
,	O
0.1333	int
}	O
,	O
{	O
1.0000	int
,	O
0.6627	int
,	O
0.2588	int
}	O
,	O
{	O
0.9882	int
,	O
0.1725	int
,	O
0.2275	int
}	O
,	O
{	O
0.6745	int
,	O
0.4824	int
,	O
0.4824	int
}	O
,	O
{	O
1.0000	int
,	O
0.1020	int
,	O
0.0902	int
}	O
,	O
{	O
1.0000	int
,	O
0.6627	int
,	O
0.2588	int
}	O
,	O
{	O
1.0000	int
,	O
0.0902	int
,	O
0.0235	int
}	O
,	O
{	O
0.9922	int
,	O
0.4196	int
,	O
0.3137	int
}	O
,	O
{	O
1.0000	int
,	O
0.3059	int
,	O
0.2118	int
}	O
,	O
{	O
1.0000	int
,	O
0.6627	int
,	O
0.2588	int
}	O
,	O
{	O
1.0000	int
,	O
0.0902	int
,	O
0.0235	int
}	O
,	O
{	O
1.0000	int
,	O
0.5098	int
,	O
0.0824	int
}	O
,	O
{	O
0.9922	int
,	O
0.0078	int
,	O
0.0078	int
}	O
,	O
{	O
0.8118	int
,	O
0.5176	int
,	O
0.3529	int
}	O
,	O
{	O
1.0000	int
,	O
0.3725	int
,	O
0.0118	int
}	O
,	O
{	O
1.0000	int
,	O
0.6627	int
,	O
0.2588	int
}	O
,	O
{	O
1.0000	int
,	O
0.1020	int
,	O
0.0902	int
}	O
,	O
{	O
1.0000	int
,	O
0.1765	int
,	O
0.0471	int
}	O
,	O
{	O
1.0000	int
,	O
0.3059	int
,	O
0.2118	int
}	O
,	O
{	O
1.0000	int
,	O
0.3059	int
,	O
0.2118	int
}	O
,	O
{	O
0.9922	int
,	O
0.0078	int
,	O
0.0078	int
}	O
,	O
{	O
1.0000	int
,	O
0.5098	int
,	O
0.0824	int
}	O
,	O
{	O
0.6745	int
,	O
0.4824	int
,	O
0.4824	int
}	O
,	O
{	O
1.0000	int
,	O
0.3725	int
,	O
0.0118	int
}	O
,	O
{	O
0.6745	int
,	O
0.4824	int
,	O
0.4824	int
}	O
,	O
{	O
0.9922	int
,	O
0.4196	int
,	O
0.3137	int
}	O
,	O
{	O
1.0000	int
,	O
0.3333	int
,	O
0.0902	int
}	O
,	O
{	O
1.0000	int
,	O
0.6627	int
,	O
0.2588	int
}	O
,	O
{	O
1.0000	int
,	O
0.1765	int
,	O
0.0471	int
}	O
,	O
{	O
0.9961	int
,	O
0.9961	int
,	O
0.4431	int
}	O
,	O
{	O
0.8275	int
,	O
0.3922	int
,	O
0.1176	int
}	O
,	O
{	O
0.7843	int
,	O
0.7843	int
,	O
0.7843	int
}	O
,	O
{	O
0.7843	int
,	O
0.7843	int
,	O
0.7843	int
}	O
,	O
{	O
0.8118	int
,	O
0.5176	int
,	O
0.3529	int
}	O
,	O
{	O
0.9961	int
,	O
0.5843	int
,	O
0.5843	int
}	O
,	O
{	O
0.5725	int
,	O
0.5059	int
,	O
0.8902	int
}	O
,	O
{	O
0.8471	int
,	O
0.6078	int
,	O
0.6078	int
}	O
,	O
{	O
0.9961	int
,	O
0.5843	int
,	O
0.5843	int
}	O
,	O
{	O
0.6941	int
,	O
0.1608	int
,	O
0.0039	int
}	O
,	O
{	O
0.9961	int
,	O
0.9961	int
,	O
0.4431	int
}	O
,	O
{	O
0.9961	int
,	O
0.9961	int
,	O
0.4431	int
}	O
,	O
{	O
0.9961	int
,	O
0.5843	int
,	O
0.5843	int
}	O
,	O
{	O
1.0000	int
,	O
0.5608	int
,	O
0.2235	int
}	O
,	O
{	O
1.0000	int
,	O
0.6745	int
,	O
0.8706	int
}	O
,	O
{	O
0.5725	int
,	O
0.5059	int
,	O
0.8902	int
}	O
,	O
{	O
0.9804	int
,	O
0.9804	int
,	O
0.7490	int
}	O
,	O
{	O
0.7137	int
,	O
0.7922	int
,	O
0.2667	int
}	O
,	O
{	O
0.6941	int
,	O
0.1608	int
,	O
0.0039	int
}	O
,	O
{	O
0.7412	int
,	O
0.4431	int
,	O
0.2157	int
}	O
,	O
{	O
0.9961	int
,	O
0.7843	int
,	O
0.1451	int
}	O
,	O
{	O
0.6941	int
,	O
0.1608	int
,	O
0.0039	int
}	O
,	O
{	O
0.8118	int
,	O
0.5176	int
,	O
0.3529	int
}	O
,	O
{	O
0.7137	int
,	O
0.7922	int
,	O
0.2667	int
}	O
,	O
{	O
0.7412	int
,	O
0.4431	int
,	O
0.2157	int
}	O
,	O
{	O
0.2667	int
,	O
0.9922	int
,	O
0.5529	int
}	O
,	O
{	O
0.8275	int
,	O
0.3922	int
,	O
0.1176	int
}	O
,	O
{	O
0.9961	int
,	O
0.5843	int
,	O
0.5843	int
}	O
,	O
{	O
0.8118	int
,	O
0.5176	int
,	O
0.3529	int
}	O
,	O
{	O
0.7843	int
,	O
0.7843	int
,	O
0.7843	int
}	O
,	O
{	O
0.4902	int
,	O
0.8588	int
,	O
0.8627	int
}	O
,	O
{	O
0.8118	int
,	O
0.5176	int
,	O
0.3529	int
}	O
,	O
{	O
0.4902	int
,	O
0.8588	int
,	O
0.8627	int
}	O
,	O
{	O
0.8275	int
,	O
0.3922	int
,	O
0.1176	int
}	O
,	O
{	O
0.2667	int
,	O
0.9922	int
,	O
0.5529	int
}	O
,	O
{	O
0.9804	int
,	O
0.9804	int
,	O
0.7490	int
}	O
,	O
{	O
1.0000	int
,	O
0.7882	int
,	O
0.4745	int
}	O
,	O
{	O
0.9961	int
,	O
0.5843	int
,	O
0.5843	int
}	O
,	O
{	O
0.7843	int
,	O
0.7843	int
,	O
0.7843	int
}	O
,	O
{	O
1.0000	int
,	O
0.6745	int
,	O
0.8706	int
}	O
,	O
{	O
0.9804	int
,	O
0.9804	int
,	O
0.7490	int
}	O
,	O
{	O
0.6941	int
,	O
0.1608	int
,	O
0.0039	int
}	O
,	O
{	O
0.7843	int
,	O
0.7843	int
,	O
0.7843	int
}	O
,	O
{	O
0.7961	int
,	O
0.9961	int
,	O
0.7882	int
}	O
,	O
{	O
0.7843	int
,	O
0.7843	int
,	O
0.7843	int
}	O
,	O
{	O
0.8471	int
,	O
0.6078	int
,	O
0.6078	int
}	O
,	O
{	O
0.8471	int
,	O
0.6078	int
,	O
0.6078	int
}	O
,	O
{	O
0.8471	int
,	O
0.6078	int
,	O
0.6078	int
}	O
,	O
{	O
0.8471	int
,	O
0.6078	int
,	O
0.6078	int
}	O
,	O
{	O
0.8471	int
,	O
0.6078	int
,	O
0.6078	int
}	O
,	O
{	O
0.0274	int
,	O
0.2600	int
,	O
0.3800	int
}	O
,	O
{	O
0.4000	int
,	O
0.4000	int
,	O
0.4000	int
}	O
,	O
{	O
0.0274	int
,	O
0.3800	int
,	O
0.1600	int
}	O
,	O
{	O
1.0000	int
,	O
1.0000	int
,	O
1.0000	int
}	O
}	O
;	O
void	O
Make_Font	function
(	O
void	O
)	O
{	O
MAV_vector	O
r0	O
,	O
r1	O
,	O
*	O
verts	pointer
;	O
FILE	O
*	O
file	pointer
;	O
char	O
filename	array
[	O
100	int
]	O
;	O
int	O
i	int
,	O
j	int
,	O
l	int
,	O
c	int
,	O
num_verts	int
,	O
index	array
[	O
100	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_COLOURS	int
;	O
i	int
++	O
)	O
{	O
mav_paletteMaterialSet	function
(	O
mav_palette_default	O
,	O
i	int
+	O
1	int
,	O
0.3	int
*	O
colours	array
[	O
i	int
]	O
[	O
0	int
]	O
,	O
0.3	int
*	O
colours	array
[	O
i	int
]	O
[	O
1	int
]	O
,	O
0.3	int
*	O
colours	array
[	O
i	int
]	O
[	O
2	int
]	O
,	O
1.0	int
,	O
colours	array
[	O
i	int
]	O
[	O
0	int
]	O
,	O
colours	array
[	O
i	int
]	O
[	O
1	int
]	O
,	O
colours	array
[	O
i	int
]	O
[	O
2	int
]	O
,	O
1.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
,	O
0.0	int
)	O
;	O
mav_paletteColourSet	function
(	O
mav_palette_default	O
,	O
i	int
+	O
1	int
,	O
colours	array
[	O
i	int
]	O
[	O
0	int
]	O
,	O
colours	array
[	O
i	int
]	O
[	O
1	int
]	O
,	O
colours	array
[	O
i	int
]	O
[	O
2	int
]	O
,	O
1.0	int
)	O
;	O
}	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
NUM_LETTERS	int
+	O
1	int
;	O
l	int
++	O
)	O
alphabet	array
[	O
(	O
int	O
)	O
(	O
letter_widths	array
[	O
l	int
]	O
[	O
0	int
]	O
)	O
]	O
.	O
letter_width	float
=	O
letter_widths	array
[	O
l	int
]	O
[	O
1	int
]	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
NUM_LETTERS	int
;	O
l	int
++	O
)	O
{	O
c	int
=	O
ascii	array
[	O
l	int
]	O
;	O
sprintf	O
(	O
filename	array
,	O
"data/font/%d.cdat"	pointer
,	O
c	int
)	O
;	O
file	pointer
=	O
fopen	function
(	O
filename	array
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Failed to open font file %s\n"	pointer
,	O
filename	array
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
fscanf	function
(	O
file	pointer
,	O
"%d"	pointer
,	O
&	O
num_verts	int
)	O
;	O
verts	pointer
=	O
mav_malloc	function
(	O
num_verts	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_verts	int
;	O
j	int
++	O
)	O
fscanf	function
(	O
file	pointer
,	O
"%g %g %g"	pointer
,	O
&	O
verts	pointer
[	O
j	int
]	O
.	O
x	O
,	O
&	O
verts	pointer
[	O
j	int
]	O
.	O
y	O
,	O
&	O
verts	pointer
[	O
j	int
]	O
.	O
z	O
)	O
;	O
mav_BBCompInit	function
(	O
&	O
alphabet	array
[	O
c	int
]	O
.	O
bb	int
)	O
;	O
fscanf	function
(	O
file	pointer
,	O
"%d"	pointer
,	O
&	O
alphabet	array
[	O
c	int
]	O
.	O
num_polys	int
)	O
;	O
alphabet	array
[	O
c	int
]	O
.	O
polys	pointer
=	O
mav_malloc	function
(	O
alphabet	array
[	O
c	int
]	O
.	O
num_polys	int
*	O
sizeof	O
(	O
LC_Polygon	struct
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
alphabet	array
[	O
c	int
]	O
.	O
num_polys	int
;	O
i	int
++	O
)	O
{	O
num_verts	int
=	O
0	int
;	O
fscanf	function
(	O
file	pointer
,	O
"%d"	pointer
,	O
&	O
index	array
[	O
num_verts	int
]	O
)	O
;	O
while	O
(	O
index	array
[	O
num_verts	int
]	O
!=	O
-	O
1	int
)	O
{	O
num_verts	int
++	O
;	O
fscanf	function
(	O
file	pointer
,	O
"%d"	pointer
,	O
&	O
index	array
[	O
num_verts	int
]	O
)	O
;	O
}	O
alphabet	array
[	O
c	int
]	O
.	O
polys	pointer
[	O
i	int
]	O
.	O
num_verts	int
=	O
num_verts	int
;	O
alphabet	array
[	O
c	int
]	O
.	O
polys	pointer
[	O
i	int
]	O
.	O
verts	pointer
=	O
mav_malloc	function
(	O
num_verts	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
num_verts	int
;	O
j	int
++	O
)	O
{	O
alphabet	array
[	O
c	int
]	O
.	O
polys	pointer
[	O
i	int
]	O
.	O
verts	pointer
[	O
j	int
]	O
=	O
verts	pointer
[	O
index	array
[	O
j	int
]	O
]	O
;	O
mav_BBCompPt	function
(	O
alphabet	array
[	O
c	int
]	O
.	O
polys	pointer
[	O
i	int
]	O
.	O
verts	pointer
[	O
j	int
]	O
,	O
&	O
alphabet	array
[	O
c	int
]	O
.	O
bb	int
)	O
;	O
}	O
r0	O
=	O
mav_vectorNormalize	function
(	O
mav_vectorSub	function
(	O
alphabet	array
[	O
c	int
]	O
.	O
polys	pointer
[	O
i	int
]	O
.	O
verts	pointer
[	O
2	int
]	O
,	O
alphabet	array
[	O
c	int
]	O
.	O
polys	pointer
[	O
i	int
]	O
.	O
verts	pointer
[	O
1	int
]	O
)	O
)	O
;	O
r1	O
=	O
mav_vectorNormalize	function
(	O
mav_vectorSub	function
(	O
alphabet	array
[	O
c	int
]	O
.	O
polys	pointer
[	O
i	int
]	O
.	O
verts	pointer
[	O
0	int
]	O
,	O
alphabet	array
[	O
c	int
]	O
.	O
polys	pointer
[	O
i	int
]	O
.	O
verts	pointer
[	O
1	int
]	O
)	O
)	O
;	O
alphabet	array
[	O
c	int
]	O
.	O
polys	pointer
[	O
i	int
]	O
.	O
normal	int
=	O
mav_vectorNormalize	function
(	O
mav_vectorCrossProduct	function
(	O
r0	O
,	O
r1	O
)	O
)	O
;	O
}	O
mav_free	function
(	O
verts	pointer
)	O
;	O
fclose	function
(	O
file	pointer
)	O
;	O
}	O
}	O
Feature	struct
*	O
feature	pointer
;	O
int	O
feature_vertices	int
;	O
int	O
num_polygons	int
;	O
typedef	O
void	O
(	O
CALLBACK	O
*	O
MAVLIB_GLUCB	pointer
)	O
(	O
)	O
;	O
void	O
CALLBACK	O
my_begin	function
(	O
GLenum	O
mode	int
)	O
{	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
num_verts	int
=	O
3	int
;	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
verts	pointer
=	O
mav_malloc	function
(	O
3	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
num_verts	int
=	O
0	int
;	O
}	O
void	O
CALLBACK	O
my_error	function
(	O
GLenum	O
en	int
)	O
{	O
printf	O
(	O
"GLU error: %s\n"	pointer
,	O
gluErrorString	function
(	O
en	int
)	O
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
void	O
CALLBACK	O
my_vertex	function
(	O
void	O
*	O
v	pointer
)	O
{	O
MAV_vector	O
r0	O
,	O
r1	O
;	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
verts	pointer
[	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
num_verts	int
]	O
=	O
*	O
(	O
(	O
MAV_vector	O
*	O
)	O
v	pointer
)	O
;	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
num_verts	int
++	O
;	O
if	O
(	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
num_verts	int
==	O
3	int
)	O
{	O
r0	O
=	O
mav_vectorSub	function
(	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
verts	pointer
[	O
1	int
]	O
,	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
verts	pointer
[	O
0	int
]	O
)	O
;	O
r1	O
=	O
mav_vectorSub	function
(	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
verts	pointer
[	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
num_verts	int
-	O
1	int
]	O
,	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
verts	pointer
[	O
0	int
]	O
)	O
;	O
feature	pointer
->	O
polys	pointer
[	O
feature	pointer
->	O
num_polys	int
]	O
.	O
normal	int
=	O
mav_vectorNormalize	function
(	O
mav_vectorCrossProduct	function
(	O
r0	O
,	O
r1	O
)	O
)	O
;	O
feature	pointer
->	O
num_polys	int
++	O
;	O
}	O
}	O
void	O
CALLBACK	O
count_polygons	function
(	O
void	O
*	O
v	pointer
)	O
{	O
feature_vertices	int
++	O
;	O
if	O
(	O
feature_vertices	int
==	O
3	int
)	O
{	O
feature	pointer
->	O
num_polys	int
++	O
;	O
feature_vertices	int
=	O
0	int
;	O
}	O
}	O
void	O
CALLBACK	O
my_edge_flag	function
(	O
GLboolean	O
f	int
)	O
{	O
}	O
void	O
Build_Feature	function
(	O
FILE	O
*	O
file	pointer
,	O
int	O
type	int
)	O
{	O
MAV_vector	O
*	O
verts	pointer
;	O
GLdouble	O
data	O
[	O
3	int
]	O
;	O
GLUtesselator	O
*	O
tobj	O
;	O
int	O
i	int
,	O
num_verts	int
;	O
feature	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
Feature	struct
)	O
)	O
;	O
fscanf	function
(	O
file	pointer
,	O
"%d\n"	pointer
,	O
&	O
num_verts	int
)	O
;	O
verts	pointer
=	O
mav_malloc	function
(	O
num_verts	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
mav_BBCompInit	function
(	O
&	O
feature	pointer
->	O
bb	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_verts	int
;	O
i	int
++	O
)	O
{	O
fscanf	function
(	O
file	pointer
,	O
"(%f,%f,%*f)\n"	pointer
,	O
&	O
verts	pointer
[	O
i	int
]	O
.	O
x	O
,	O
&	O
verts	pointer
[	O
i	int
]	O
.	O
z	O
)	O
;	O
verts	pointer
[	O
i	int
]	O
.	O
x	O
=	O
-	O
verts	pointer
[	O
i	int
]	O
.	O
x	O
;	O
verts	pointer
[	O
i	int
]	O
.	O
y	O
=	O
0.0	int
;	O
mav_BBCompPt	function
(	O
verts	pointer
[	O
i	int
]	O
,	O
&	O
feature	pointer
->	O
bb	int
)	O
;	O
}	O
tobj	O
=	O
gluNewTess	function
(	O
)	O
;	O
if	O
(	O
!	O
tobj	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Failed to allocate GLUtesselator\n"	pointer
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
feature	pointer
->	O
num_polys	int
=	O
0	int
;	O
feature_vertices	int
=	O
0	int
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_BEGIN	O
,	O
NULL	O
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_END	O
,	O
NULL	O
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_ERROR	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
my_error	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_VERTEX	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
count_polygons	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_EDGE_FLAG	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
my_edge_flag	function
)	O
;	O
gluTessBeginPolygon	O
(	O
tobj	O
,	O
NULL	O
)	O
;	O
gluTessBeginContour	O
(	O
tobj	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_verts	int
;	O
i	int
++	O
)	O
{	O
data	O
[	O
0	int
]	O
=	O
(	O
GLdouble	O
)	O
verts	pointer
[	O
i	int
]	O
.	O
x	O
;	O
data	O
[	O
1	int
]	O
=	O
(	O
GLdouble	O
)	O
verts	pointer
[	O
i	int
]	O
.	O
y	O
;	O
data	O
[	O
2	int
]	O
=	O
(	O
GLdouble	O
)	O
verts	pointer
[	O
i	int
]	O
.	O
z	O
;	O
gluTessVertex	function
(	O
tobj	O
,	O
data	O
,	O
(	O
GLvoid	O
*	O
)	O
&	O
verts	pointer
[	O
i	int
]	O
)	O
;	O
}	O
gluTessEndContour	O
(	O
tobj	O
)	O
;	O
gluTessEndPolygon	O
(	O
tobj	O
)	O
;	O
gluDeleteTess	function
(	O
tobj	O
)	O
;	O
feature	pointer
->	O
polys	pointer
=	O
mav_malloc	function
(	O
feature	pointer
->	O
num_polys	int
*	O
sizeof	O
(	O
LC_Polygon	struct
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
feature	pointer
->	O
num_polys	int
;	O
i	int
++	O
)	O
{	O
feature	pointer
->	O
polys	pointer
[	O
i	int
]	O
.	O
verts	pointer
=	O
mav_malloc	function
(	O
3	int
*	O
sizeof	O
(	O
MAV_vector	O
)	O
)	O
;	O
feature	pointer
->	O
polys	pointer
[	O
i	int
]	O
.	O
num_verts	int
=	O
0	int
;	O
}	O
tobj	O
=	O
gluNewTess	function
(	O
)	O
;	O
if	O
(	O
!	O
tobj	O
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Failed to allocate GLUtesselator\n"	pointer
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
feature	pointer
->	O
num_polys	int
=	O
0	int
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_BEGIN	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
my_begin	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_END	O
,	O
NULL	O
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_ERROR	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
my_error	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_VERTEX	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
my_vertex	function
)	O
;	O
gluTessCallback	function
(	O
tobj	O
,	O
GLU_TESS_EDGE_FLAG	O
,	O
(	O
MAVLIB_GLUCB	pointer
)	O
my_edge_flag	function
)	O
;	O
gluTessBeginPolygon	O
(	O
tobj	O
,	O
NULL	O
)	O
;	O
gluTessBeginContour	O
(	O
tobj	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_verts	int
;	O
i	int
++	O
)	O
{	O
data	O
[	O
0	int
]	O
=	O
(	O
double	O
)	O
verts	pointer
[	O
i	int
]	O
.	O
x	O
;	O
data	O
[	O
1	int
]	O
=	O
(	O
double	O
)	O
verts	pointer
[	O
i	int
]	O
.	O
y	O
;	O
data	O
[	O
2	int
]	O
=	O
(	O
double	O
)	O
verts	pointer
[	O
i	int
]	O
.	O
z	O
;	O
gluTessVertex	function
(	O
tobj	O
,	O
data	O
,	O
(	O
void	O
*	O
)	O
&	O
verts	pointer
[	O
i	int
]	O
)	O
;	O
}	O
gluTessEndContour	O
(	O
tobj	O
)	O
;	O
gluTessEndPolygon	O
(	O
tobj	O
)	O
;	O
gluDeleteTess	function
(	O
tobj	O
)	O
;	O
feature	pointer
->	O
matrix	int
=	O
MAV_ID_MATRIX	O
;	O
feature	pointer
->	O
sp	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_COLOUR	O
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
switch	O
(	O
type	int
)	O
{	O
case	O
CANAL	int
:	O
feature	pointer
->	O
sp	pointer
->	O
colour	O
=	O
101	int
;	O
break	O
;	O
case	O
PAVEMENT	int
:	O
feature	pointer
->	O
sp	pointer
->	O
colour	O
=	O
102	int
;	O
break	O
;	O
case	O
GRASS	int
:	O
feature	pointer
->	O
sp	pointer
->	O
colour	O
=	O
103	int
;	O
break	O
;	O
default	O
:	O
feature	pointer
->	O
sp	pointer
->	O
colour	O
=	O
104	int
;	O
break	O
;	O
}	O
mav_SMSObjectAdd	function
(	O
city_build	pointer
,	O
mav_objectNew	function
(	O
mav_class_feature	pointer
,	O
feature	pointer
)	O
)	O
;	O
}	O
Vector	struct
*	O
vector_list	pointer
;	O
Vector	struct
*	O
Find_Vector	function
(	O
char	O
*	O
name	array
)	O
{	O
Vector	struct
*	O
v	pointer
;	O
v	pointer
=	O
vector_list	pointer
;	O
while	O
(	O
v	pointer
)	O
{	O
if	O
(	O
strcmp	O
(	O
v	pointer
->	O
name	array
,	O
name	array
)	O
==	O
0	int
)	O
return	O
v	pointer
;	O
v	pointer
=	O
v	pointer
->	O
next	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
Make_Streets	function
(	O
char	O
*	O
strfile	pointer
,	O
char	O
*	O
lstfile	pointer
)	O
{	O
MAV_BB	O
bb	int
;	O
MAV_vector	O
newdr	O
;	O
Alphabet	struct
*	O
letter	pointer
;	O
Character	struct
*	O
character	pointer
;	O
Vector	struct
*	O
v	pointer
,	O
*	O
current_vector	pointer
;	O
float	O
width	float
,	O
height	float
,	O
depth	float
,	O
spacing	float
,	O
letter_width	float
;	O
float	O
current_spacing_x	float
=	O
0	int
,	O
current_spacing_y	float
=	O
0	int
;	O
float	O
vx1	float
=	O
0	int
,	O
vy1	float
=	O
0	int
,	O
vx2	float
,	O
vy2	float
,	O
dx	float
=	O
0	int
,	O
dy	float
=	O
0	int
,	O
dlen	float
,	O
dir	float
=	O
0	int
,	O
newx	float
,	O
newy	float
;	O
int	O
num_polygons	int
;	O
FILE	O
*	O
file	pointer
;	O
unsigned	O
char	O
str	array
[	O
100	int
]	O
,	O
c	int
;	O
file	pointer
=	O
fopen	function
(	O
strfile	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Failed to open street file %s\n"	pointer
,	O
strfile	pointer
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
mav_BBCompInit	function
(	O
&	O
city_bb	int
)	O
;	O
vector_list	pointer
=	O
NULL	O
;	O
while	O
(	O
fscanf	function
(	O
file	pointer
,	O
"%s"	pointer
,	O
str	array
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
strncmp	O
(	O
(	O
const	O
char	O
*	O
)	O
str	array
,	O
";"	pointer
,	O
1	int
)	O
==	O
0	int
)	O
{	O
fread	function
(	O
&	O
c	int
,	O
1	int
,	O
1	int
,	O
file	pointer
)	O
;	O
while	O
(	O
(	O
int	O
)	O
c	int
!=	O
9	int
&&	O
(	O
int	O
)	O
c	int
!=	O
10	int
)	O
fread	function
(	O
&	O
c	int
,	O
1	int
,	O
1	int
,	O
file	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
strncmp	O
(	O
(	O
const	O
char	O
*	O
)	O
str	array
,	O
"canal"	pointer
,	O
5	int
)	O
)	O
Build_Feature	function
(	O
file	pointer
,	O
CANAL	int
)	O
;	O
else	O
if	O
(	O
!	O
strncmp	O
(	O
(	O
const	O
char	O
*	O
)	O
str	array
,	O
"pavem"	pointer
,	O
5	int
)	O
)	O
Build_Feature	function
(	O
file	pointer
,	O
PAVEMENT	int
)	O
;	O
else	O
if	O
(	O
!	O
strncmp	O
(	O
(	O
const	O
char	O
*	O
)	O
str	array
,	O
"grass"	pointer
,	O
5	int
)	O
)	O
Build_Feature	function
(	O
file	pointer
,	O
GRASS	int
)	O
;	O
else	O
{	O
v	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
Vector	struct
)	O
)	O
;	O
strcpy	O
(	O
v	pointer
->	O
name	array
,	O
(	O
const	O
char	O
*	O
)	O
str	array
)	O
;	O
fscanf	function
(	O
file	pointer
,	O
"%f %f"	pointer
,	O
&	O
v	pointer
->	O
start	int
.	O
x	O
,	O
&	O
v	pointer
->	O
start	int
.	O
z	O
)	O
;	O
v	pointer
->	O
start	int
.	O
x	O
=	O
-	O
v	pointer
->	O
start	int
.	O
x	O
;	O
v	pointer
->	O
start	int
.	O
y	O
=	O
0.0	int
;	O
fscanf	function
(	O
file	pointer
,	O
"%*f %f %f"	pointer
,	O
&	O
v	pointer
->	O
end	int
.	O
x	O
,	O
&	O
v	pointer
->	O
end	int
.	O
z	O
)	O
;	O
v	pointer
->	O
end	int
.	O
x	O
=	O
-	O
v	pointer
->	O
end	int
.	O
x	O
;	O
v	pointer
->	O
end	int
.	O
y	O
=	O
0.0	int
;	O
v	pointer
->	O
sp	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_COLOUR	O
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
fscanf	function
(	O
file	pointer
,	O
"%*f %i"	pointer
,	O
&	O
v	pointer
->	O
sp	pointer
->	O
colour	O
)	O
;	O
v	pointer
->	O
sp	pointer
->	O
colour	O
++	O
;	O
v	pointer
->	O
phrase_length	float
=	O
0.0	int
;	O
v	pointer
->	O
num_characters	int
=	O
0	int
;	O
v	pointer
->	O
bb	int
.	O
min	O
.	O
x	O
=	O
(	O
v	pointer
->	O
start	int
.	O
x	O
<	O
v	pointer
->	O
end	int
.	O
x	O
)	O
?	O
v	pointer
->	O
start	int
.	O
x	O
:	O
v	pointer
->	O
end	int
.	O
x	O
;	O
v	pointer
->	O
bb	int
.	O
min	O
.	O
y	O
=	O
0.0	int
;	O
v	pointer
->	O
bb	int
.	O
min	O
.	O
z	O
=	O
(	O
v	pointer
->	O
start	int
.	O
z	O
<	O
v	pointer
->	O
end	int
.	O
z	O
)	O
?	O
v	pointer
->	O
start	int
.	O
z	O
:	O
v	pointer
->	O
end	int
.	O
z	O
;	O
v	pointer
->	O
bb	int
.	O
max	O
.	O
x	O
=	O
(	O
v	pointer
->	O
start	int
.	O
x	O
>	O
v	pointer
->	O
end	int
.	O
x	O
)	O
?	O
v	pointer
->	O
start	int
.	O
x	O
:	O
v	pointer
->	O
end	int
.	O
x	O
;	O
v	pointer
->	O
bb	int
.	O
max	O
.	O
y	O
=	O
0.0	int
;	O
v	pointer
->	O
bb	int
.	O
max	O
.	O
z	O
=	O
(	O
v	pointer
->	O
start	int
.	O
z	O
>	O
v	pointer
->	O
end	int
.	O
z	O
)	O
?	O
v	pointer
->	O
start	int
.	O
z	O
:	O
v	pointer
->	O
end	int
.	O
z	O
;	O
mav_BBCompBB	function
(	O
v	pointer
->	O
bb	int
,	O
&	O
city_bb	int
)	O
;	O
v	pointer
->	O
matrix	int
=	O
MAV_ID_MATRIX	O
;	O
;	O
v	pointer
->	O
next	pointer
=	O
vector_list	pointer
;	O
vector_list	pointer
=	O
v	pointer
;	O
mav_SMSObjectAdd	function
(	O
city_build	pointer
,	O
mav_objectNew	function
(	O
mav_class_vector	pointer
,	O
v	pointer
)	O
)	O
;	O
}	O
}	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
file	pointer
=	O
fopen	function
(	O
lstfile	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Failed to open letters file %s\n"	pointer
,	O
lstfile	pointer
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
current_vector	pointer
=	O
NULL	O
;	O
while	O
(	O
fscanf	function
(	O
file	pointer
,	O
"%s"	pointer
,	O
str	array
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
strncmp	O
(	O
(	O
const	O
char	O
*	O
)	O
str	array
,	O
";"	pointer
,	O
1	int
)	O
==	O
0	int
)	O
{	O
fread	function
(	O
&	O
c	int
,	O
1	int
,	O
1	int
,	O
file	pointer
)	O
;	O
while	O
(	O
(	O
int	O
)	O
c	int
!=	O
9	int
&&	O
(	O
int	O
)	O
c	int
!=	O
10	int
)	O
fread	function
(	O
&	O
c	int
,	O
1	int
,	O
1	int
,	O
file	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
strncmp	O
(	O
(	O
const	O
char	O
*	O
)	O
str	array
,	O
":"	pointer
,	O
1	int
)	O
)	O
{	O
current_vector	pointer
=	O
Find_Vector	function
(	O
(	O
char	O
*	O
)	O
str	array
)	O
;	O
if	O
(	O
!	O
current_vector	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Unknown vector name %s\n"	pointer
,	O
str	array
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
current_spacing_x	float
=	O
0.0	int
;	O
current_spacing_y	float
=	O
0.0	int
;	O
vx1	float
=	O
-	O
current_vector	pointer
->	O
start	int
.	O
x	O
;	O
vy1	float
=	O
current_vector	pointer
->	O
start	int
.	O
z	O
;	O
vx2	float
=	O
-	O
current_vector	pointer
->	O
end	int
.	O
x	O
;	O
vy2	float
=	O
current_vector	pointer
->	O
end	int
.	O
z	O
;	O
dx	float
=	O
vx2	float
-	O
vx1	float
;	O
dy	float
=	O
vy2	float
-	O
vy1	float
;	O
dlen	float
=	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
*	O
dy	float
)	O
;	O
dx	float
/=	O
dlen	float
;	O
dy	float
/=	O
dlen	float
;	O
dir	float
=	O
atan2	O
(	O
dx	float
,	O
dy	float
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
current_vector	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Can't have letters before a vector\n"	pointer
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
fscanf	function
(	O
file	pointer
,	O
"%f %f %f %f"	pointer
,	O
&	O
width	float
,	O
&	O
height	float
,	O
&	O
depth	float
,	O
&	O
spacing	float
)	O
;	O
if	O
(	O
strlen	O
(	O
(	O
const	O
char	O
*	O
)	O
str	array
)	O
>	O
1	int
)	O
{	O
letter	pointer
=	O
&	O
alphabet	array
[	O
(	O
int	O
)	O
str	array
[	O
1	int
]	O
]	O
;	O
letter_width	float
=	O
letter	pointer
->	O
letter_width	float
;	O
}	O
else	O
letter_width	float
=	O
0.8	int
;	O
current_spacing_x	float
+=	O
0.1	int
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
0.1	int
*	O
width	float
*	O
dy	float
;	O
current_spacing_x	float
+=	O
(	O
letter_width	float
+	O
0.1	int
)	O
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
(	O
letter_width	float
+	O
0.1	int
)	O
*	O
width	float
*	O
dy	float
;	O
current_vector	pointer
->	O
phrase_length	float
=	O
(	O
letter_width	float
+	O
0.1	int
)	O
*	O
width	float
+	O
sqrt	O
(	O
current_spacing_x	float
*	O
current_spacing_x	float
+	O
current_spacing_y	float
*	O
current_spacing_y	float
)	O
;	O
current_vector	pointer
->	O
num_characters	int
++	O
;	O
}	O
}	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
v	pointer
=	O
vector_list	pointer
;	O
while	O
(	O
v	pointer
)	O
{	O
if	O
(	O
v	pointer
->	O
phrase_length	float
>	O
0.0	int
)	O
{	O
newdr	O
.	O
x	O
=	O
v	pointer
->	O
end	int
.	O
x	O
-	O
v	pointer
->	O
start	int
.	O
x	O
;	O
newdr	O
.	O
z	O
=	O
v	pointer
->	O
end	int
.	O
z	O
-	O
v	pointer
->	O
start	int
.	O
z	O
;	O
dlen	float
=	O
sqrt	O
(	O
newdr	O
.	O
x	O
*	O
newdr	O
.	O
x	O
+	O
newdr	O
.	O
z	O
*	O
newdr	O
.	O
z	O
)	O
;	O
v	pointer
->	O
extra_width	float
=	O
dlen	float
/	O
v	pointer
->	O
phrase_length	float
;	O
}	O
else	O
v	pointer
->	O
extra_width	float
=	O
0.0	int
;	O
v	pointer
=	O
v	pointer
->	O
next	pointer
;	O
}	O
file	pointer
=	O
fopen	function
(	O
lstfile	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
file	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Failed to open letters file %s\n"	pointer
,	O
lstfile	pointer
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
current_vector	pointer
=	O
NULL	O
;	O
num_polygons	int
=	O
0	int
;	O
while	O
(	O
fscanf	function
(	O
file	pointer
,	O
"%s"	pointer
,	O
str	array
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
strncmp	O
(	O
(	O
const	O
char	O
*	O
)	O
str	array
,	O
";"	pointer
,	O
1	int
)	O
==	O
0	int
)	O
{	O
fread	function
(	O
&	O
c	int
,	O
1	int
,	O
1	int
,	O
file	pointer
)	O
;	O
while	O
(	O
(	O
int	O
)	O
c	int
!=	O
9	int
&&	O
(	O
int	O
)	O
c	int
!=	O
10	int
)	O
fread	function
(	O
&	O
c	int
,	O
1	int
,	O
1	int
,	O
file	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
strncmp	O
(	O
(	O
const	O
char	O
*	O
)	O
str	array
,	O
":"	pointer
,	O
1	int
)	O
)	O
{	O
current_vector	pointer
=	O
Find_Vector	function
(	O
(	O
char	O
*	O
)	O
str	array
)	O
;	O
if	O
(	O
!	O
current_vector	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Unknown vector name %s\n"	pointer
,	O
str	array
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
current_spacing_x	float
=	O
0.0	int
;	O
current_spacing_y	float
=	O
0.0	int
;	O
vx1	float
=	O
-	O
current_vector	pointer
->	O
start	int
.	O
x	O
;	O
vy1	float
=	O
current_vector	pointer
->	O
start	int
.	O
z	O
;	O
vx2	float
=	O
-	O
current_vector	pointer
->	O
end	int
.	O
x	O
;	O
vy2	float
=	O
current_vector	pointer
->	O
end	int
.	O
z	O
;	O
dx	float
=	O
vx2	float
-	O
vx1	float
;	O
dy	float
=	O
vy2	float
-	O
vy1	float
;	O
dlen	float
=	O
sqrt	O
(	O
dx	float
*	O
dx	float
+	O
dy	float
*	O
dy	float
)	O
;	O
dx	float
/=	O
dlen	float
;	O
dy	float
/=	O
dlen	float
;	O
dir	float
=	O
atan2	O
(	O
dx	float
,	O
dy	float
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
current_vector	pointer
)	O
{	O
fprintf	function
(	O
stderr	O
,	O
"Can't have letters before a vector\n"	pointer
)	O
;	O
exit	O
(	O
0	int
)	O
;	O
}	O
fscanf	function
(	O
file	pointer
,	O
"%g %g %g %g"	pointer
,	O
&	O
width	float
,	O
&	O
height	float
,	O
&	O
depth	float
,	O
&	O
spacing	float
)	O
;	O
width	float
*=	O
current_vector	pointer
->	O
extra_width	float
;	O
if	O
(	O
strlen	O
(	O
(	O
const	O
char	O
*	O
)	O
str	array
)	O
>	O
1	int
)	O
{	O
letter	pointer
=	O
&	O
alphabet	array
[	O
(	O
int	O
)	O
str	array
[	O
1	int
]	O
]	O
;	O
letter_width	float
=	O
letter	pointer
->	O
letter_width	float
;	O
num_polygons	int
+=	O
letter	pointer
->	O
num_polys	int
;	O
character	pointer
=	O
mav_malloc	function
(	O
sizeof	O
(	O
Character	struct
)	O
)	O
;	O
character	pointer
->	O
character	pointer
=	O
letter	pointer
;	O
character	pointer
->	O
sp	pointer
=	O
mav_surfaceParamsNew	function
(	O
MAV_MATERIAL	O
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
character	pointer
->	O
sp	pointer
->	O
material	O
=	O
current_vector	pointer
->	O
sp	pointer
->	O
colour	O
;	O
current_spacing_x	float
+=	O
0.1	int
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
0.1	int
*	O
width	float
*	O
dy	float
;	O
newx	float
=	O
-	O
(	O
vx1	float
+	O
current_spacing_x	float
)	O
;	O
newy	float
=	O
vy1	float
+	O
current_spacing_y	float
;	O
character	pointer
->	O
matrix	int
=	O
mav_matrixSet	function
(	O
0.0	int
,	O
0.0	int
,	O
-	O
(	O
180.0	int
*	O
dir	float
/	O
MAV_PI	O
+	O
90.0	int
)	O
,	O
newx	float
,	O
0.0	int
,	O
newy	float
)	O
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
0	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
1	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
2	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
3	int
]	O
[	O
0	int
]	O
*=	O
width	float
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
0	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
1	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
2	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
3	int
]	O
[	O
1	int
]	O
*=	O
height	float
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
0	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
1	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
2	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
character	pointer
->	O
matrix	int
.	O
mat	O
[	O
3	int
]	O
[	O
2	int
]	O
*=	O
depth	float
;	O
mav_SMSObjectAdd	function
(	O
city_build	pointer
,	O
mav_objectNew	function
(	O
mav_class_character	pointer
,	O
character	pointer
)	O
)	O
;	O
mav_BBAlign	function
(	O
character	pointer
->	O
character	pointer
->	O
bb	int
,	O
character	pointer
->	O
matrix	int
,	O
&	O
bb	int
)	O
;	O
mav_BBCompBB	function
(	O
bb	int
,	O
&	O
city_bb	int
)	O
;	O
character	pointer
->	O
centre	int
=	O
mav_vectorScalar	function
(	O
mav_vectorAdd	function
(	O
bb	int
.	O
min	O
,	O
bb	int
.	O
max	O
)	O
,	O
0.5	int
)	O
;	O
}	O
else	O
{	O
letter_width	float
=	O
0.8	int
;	O
current_spacing_x	float
+=	O
0.1	int
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
0.1	int
*	O
width	float
*	O
dy	float
;	O
}	O
current_spacing_x	float
+=	O
(	O
letter_width	float
+	O
0.1	int
)	O
*	O
width	float
*	O
dx	float
;	O
current_spacing_y	float
+=	O
(	O
letter_width	float
+	O
0.1	int
)	O
*	O
width	float
*	O
dy	float
;	O
}	O
}	O
}	O
fclose	function
(	O
file	pointer
)	O
;	O
fprintf	function
(	O
stdout	O
,	O
"%d polygons\n"	pointer
,	O
num_polygons	int
)	O
;	O
}	O
