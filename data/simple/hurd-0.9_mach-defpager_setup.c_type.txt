int	O
page_aligned	function
(	O
vm_offset_t	O
num	int
)	O
{	O
return	O
trunc_page	function
(	O
num	int
)	O
==	O
num	int
;	O
}	O
extern	O
mach_port_t	O
default_pager_default_port	int
;	O
kern_return_t	O
S_default_pager_paging_storage	function
(	O
mach_port_t	O
pager	int
,	O
mach_port_t	O
device	int
,	O
recnum_t	O
*	O
runs	pointer
,	O
mach_msg_type_number_t	O
nrun	int
,	O
default_pager_filename_t	O
name	pointer
,	O
boolean_t	O
add	int
)	O
{	O
struct	O
file_direct	O
*	O
fdp	pointer
;	O
int	O
sizes	int
[	O
DEV_GET_RECORDS_COUNT	O
]	O
;	O
natural_t	O
count	O
;	O
mach_msg_type_number_t	O
i	O
;	O
error_t	int
err	int
;	O
recnum_t	O
devsize	O
;	O
if	O
(	O
pager	int
!=	O
default_pager_default_port	int
)	O
return	O
KERN_INVALID_ARGUMENT	O
;	O
if	O
(	O
!	O
add	int
)	O
return	O
remove_paging_file	function
(	O
name	pointer
)	O
;	O
if	O
(	O
nrun	int
<	O
2	int
||	O
nrun	int
%	O
2	int
!=	O
0	int
)	O
return	O
EINVAL	int
;	O
count	O
=	O
DEV_GET_RECORDS_COUNT	O
;	O
err	int
=	O
device_get_status	function
(	O
device	int
,	O
DEV_GET_RECORDS	O
,	O
sizes	int
,	O
&	O
count	O
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
if	O
(	O
count	O
<	O
DEV_GET_RECORDS_COUNT	O
||	O
sizes	int
[	O
DEV_GET_RECORDS_RECORD_SIZE	O
]	O
<=	O
0	int
)	O
return	O
EINVAL	int
;	O
devsize	O
=	O
sizes	int
[	O
DEV_GET_RECORDS_DEVICE_RECORDS	O
]	O
;	O
if	O
(	O
vm_page_size	O
%	O
sizes	int
[	O
DEV_GET_RECORDS_RECORD_SIZE	O
]	O
!=	O
0	int
)	O
return	O
EINVAL	int
;	O
fdp	pointer
=	O
kalloc	function
(	O
offsetof	O
(	O
struct	O
file_direct	O
,	O
runs	pointer
[	O
nrun	int
]	O
)	O
)	O
;	O
if	O
(	O
fdp	pointer
==	O
0	int
)	O
return	O
ENOMEM	int
;	O
fdp	pointer
->	O
device	int
=	O
device	int
;	O
fdp	pointer
->	O
bshift	O
=	O
ffs	function
(	O
sizes	int
[	O
DEV_GET_RECORDS_RECORD_SIZE	O
]	O
)	O
-	O
1	int
;	O
fdp	pointer
->	O
fd_bsize	O
=	O
sizes	int
[	O
DEV_GET_RECORDS_RECORD_SIZE	O
]	O
;	O
fdp	pointer
->	O
nruns	O
=	O
nrun	int
/	O
2	int
;	O
fdp	pointer
->	O
fd_size	O
=	O
0	int
;	O
for	O
(	O
i	O
=	O
0	int
;	O
i	O
<	O
nrun	int
;	O
i	O
+=	O
2	int
)	O
{	O
fdp	pointer
->	O
runs	pointer
[	O
i	O
]	O
.	O
start	O
=	O
runs	pointer
[	O
i	O
]	O
;	O
fdp	pointer
->	O
runs	pointer
[	O
i	O
]	O
.	O
length	O
=	O
runs	pointer
[	O
i	O
+	O
1	int
]	O
;	O
if	O
(	O
fdp	pointer
->	O
runs	pointer
[	O
i	O
]	O
.	O
start	O
+	O
fdp	pointer
->	O
runs	pointer
[	O
i	O
]	O
.	O
length	O
>	O
devsize	O
)	O
{	O
kfree	function
(	O
fdp	pointer
,	O
offsetof	O
(	O
struct	O
file_direct	O
,	O
runs	pointer
[	O
nrun	int
]	O
)	O
)	O
;	O
return	O
EINVAL	int
;	O
}	O
fdp	pointer
->	O
fd_size	O
+=	O
fdp	pointer
->	O
runs	pointer
[	O
i	O
]	O
.	O
length	O
;	O
}	O
create_paging_partition	function
(	O
name	pointer
,	O
fdp	pointer
,	O
0	int
,	O
-	O
3	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
page_read_file_direct	function
(	O
struct	O
file_direct	O
*	O
fdp	pointer
,	O
vm_offset_t	O
offset	int
,	O
vm_size_t	O
size	int
,	O
vm_offset_t	O
*	O
addr	pointer
,	O
vm_size_t	O
*	O
size_read	pointer
)	O
{	O
struct	O
storage_run	O
*	O
r	pointer
;	O
error_t	int
err	int
;	O
char	O
*	O
readloc	pointer
;	O
char	O
*	O
page	pointer
;	O
mach_msg_type_number_t	O
nread	O
;	O
assert	O
(	O
page_aligned	function
(	O
offset	int
)	O
)	O
;	O
assert	O
(	O
size	int
==	O
vm_page_size	O
)	O
;	O
offset	int
>>=	O
fdp	pointer
->	O
bshift	O
;	O
assert	O
(	O
offset	int
+	O
(	O
size	int
>>	O
fdp	pointer
->	O
bshift	O
)	O
<=	O
fdp	pointer
->	O
fd_size	O
)	O
;	O
for	O
(	O
r	pointer
=	O
fdp	pointer
->	O
runs	pointer
;	O
offset	int
>	O
r	pointer
->	O
length	O
;	O
++	O
r	pointer
)	O
offset	int
-=	O
r	pointer
->	O
length	O
;	O
if	O
(	O
offset	int
+	O
(	O
size	int
>>	O
fdp	pointer
->	O
bshift	O
)	O
<=	O
r	pointer
->	O
length	O
)	O
return	O
device_read	function
(	O
fdp	pointer
->	O
device	int
,	O
0	int
,	O
r	pointer
->	O
start	O
+	O
offset	int
,	O
size	int
,	O
(	O
char	O
*	O
*	O
)	O
addr	pointer
,	O
size_read	pointer
)	O
;	O
err	int
=	O
device_read	function
(	O
fdp	pointer
->	O
device	int
,	O
0	int
,	O
r	pointer
->	O
start	O
+	O
offset	int
,	O
(	O
r	pointer
->	O
length	O
-	O
offset	int
)	O
<<	O
fdp	pointer
->	O
bshift	O
,	O
(	O
char	O
*	O
*	O
)	O
addr	pointer
,	O
&	O
nread	O
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
size	int
-=	O
nread	O
;	O
readloc	pointer
=	O
(	O
char	O
*	O
)	O
*	O
addr	pointer
;	O
do	O
{	O
readloc	pointer
+=	O
nread	O
;	O
offset	int
+=	O
nread	O
>>	O
fdp	pointer
->	O
bshift	O
;	O
if	O
(	O
offset	int
>	O
r	pointer
->	O
length	O
)	O
offset	int
-=	O
r	pointer
++	O
->	O
length	O
;	O
err	int
=	O
device_read	function
(	O
fdp	pointer
->	O
device	int
,	O
0	int
,	O
r	pointer
->	O
start	O
+	O
offset	int
,	O
(	O
r	pointer
->	O
length	O
-	O
offset	int
)	O
<<	O
fdp	pointer
->	O
bshift	O
,	O
&	O
page	pointer
,	O
&	O
nread	O
)	O
;	O
if	O
(	O
err	int
)	O
{	O
vm_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
(	O
vm_address_t	O
)	O
*	O
addr	pointer
,	O
vm_page_size	O
)	O
;	O
return	O
err	int
;	O
}	O
memcpy	function
(	O
readloc	pointer
,	O
page	pointer
,	O
nread	O
)	O
;	O
vm_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
(	O
vm_address_t	O
)	O
page	pointer
,	O
vm_page_size	O
)	O
;	O
size	int
-=	O
nread	O
;	O
}	O
while	O
(	O
size	int
>	O
0	int
)	O
;	O
*	O
size_read	pointer
=	O
vm_page_size	O
;	O
return	O
0	int
;	O
}	O
int	O
page_write_file_direct	function
(	O
struct	O
file_direct	O
*	O
fdp	pointer
,	O
vm_offset_t	O
offset	int
,	O
vm_offset_t	O
addr	pointer
,	O
vm_size_t	O
size	int
,	O
vm_size_t	O
*	O
size_written	pointer
)	O
{	O
struct	O
storage_run	O
*	O
r	pointer
;	O
error_t	int
err	int
;	O
int	O
wrote	int
;	O
assert	O
(	O
page_aligned	function
(	O
offset	int
)	O
)	O
;	O
assert	O
(	O
size	int
==	O
vm_page_size	O
)	O
;	O
offset	int
>>=	O
fdp	pointer
->	O
bshift	O
;	O
assert	O
(	O
offset	int
+	O
(	O
size	int
>>	O
fdp	pointer
->	O
bshift	O
)	O
<=	O
fdp	pointer
->	O
fd_size	O
)	O
;	O
for	O
(	O
r	pointer
=	O
fdp	pointer
->	O
runs	pointer
;	O
offset	int
>	O
r	pointer
->	O
length	O
;	O
++	O
r	pointer
)	O
offset	int
-=	O
r	pointer
->	O
length	O
;	O
if	O
(	O
offset	int
+	O
(	O
size	int
>>	O
fdp	pointer
->	O
bshift	O
)	O
<=	O
r	pointer
->	O
length	O
)	O
{	O
err	int
=	O
device_write	function
(	O
fdp	pointer
->	O
device	int
,	O
0	int
,	O
r	pointer
->	O
start	O
+	O
offset	int
,	O
(	O
char	O
*	O
)	O
addr	pointer
,	O
size	int
,	O
&	O
wrote	int
)	O
;	O
*	O
size_written	pointer
=	O
wrote	int
;	O
return	O
err	int
;	O
}	O
err	int
=	O
device_write	function
(	O
fdp	pointer
->	O
device	int
,	O
0	int
,	O
r	pointer
->	O
start	O
+	O
offset	int
,	O
(	O
char	O
*	O
)	O
addr	pointer
,	O
(	O
r	pointer
->	O
length	O
-	O
offset	int
)	O
<<	O
fdp	pointer
->	O
bshift	O
,	O
&	O
wrote	int
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
size	int
-=	O
wrote	int
;	O
do	O
{	O
mach_msg_type_number_t	O
segsize	O
;	O
addr	pointer
+=	O
wrote	int
;	O
offset	int
+=	O
wrote	int
>>	O
fdp	pointer
->	O
bshift	O
;	O
if	O
(	O
offset	int
>	O
r	pointer
->	O
length	O
)	O
offset	int
-=	O
r	pointer
++	O
->	O
length	O
;	O
segsize	O
=	O
(	O
r	pointer
->	O
length	O
-	O
offset	int
)	O
<<	O
fdp	pointer
->	O
bshift	O
;	O
if	O
(	O
segsize	O
>	O
size	int
)	O
segsize	O
=	O
size	int
;	O
err	int
=	O
device_write	function
(	O
fdp	pointer
->	O
device	int
,	O
0	int
,	O
r	pointer
->	O
start	O
+	O
offset	int
,	O
(	O
char	O
*	O
)	O
addr	pointer
,	O
segsize	O
,	O
&	O
wrote	int
)	O
;	O
if	O
(	O
err	int
)	O
{	O
vm_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
(	O
vm_address_t	O
)	O
addr	pointer
,	O
vm_page_size	O
)	O
;	O
return	O
err	int
;	O
}	O
size	int
-=	O
wrote	int
;	O
}	O
while	O
(	O
size	int
>	O
0	int
)	O
;	O
*	O
size_written	pointer
=	O
vm_page_size	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
add_paging_file	function
(	O
master_device_port	int
,	O
file_name	pointer
,	O
linux_signature	int
)	O
mach_port_t	O
master_device_port	int
;	O
char	O
*	O
file_name	pointer
;	O
int	O
linux_signature	int
;	O
{	O
error_t	int
err	int
;	O
mach_port_t	O
dev	O
;	O
int	O
sizes	int
[	O
DEV_GET_SIZE_COUNT	O
]	O
;	O
natural_t	O
count	O
;	O
char	O
*	O
devname	O
=	O
file_name	pointer
;	O
assert	O
(	O
linux_signature	int
==	O
0	int
)	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
file_name	pointer
,	O
"/dev/"	pointer
,	O
5	int
)	O
)	O
devname	O
+=	O
5	int
;	O
err	int
=	O
device_open	O
(	O
master_device_port	int
,	O
D_READ	O
|	O
D_WRITE	O
,	O
devname	O
,	O
&	O
dev	O
)	O
;	O
if	O
(	O
err	int
)	O
return	O
err	int
;	O
count	O
=	O
DEV_GET_SIZE_COUNT	O
;	O
err	int
=	O
device_get_status	function
(	O
dev	O
,	O
DEV_GET_SIZE	O
,	O
sizes	int
,	O
&	O
count	O
)	O
;	O
if	O
(	O
!	O
err	int
&&	O
count	O
<	O
DEV_GET_SIZE_COUNT	O
)	O
err	int
=	O
EGRATUITOUS	O
;	O
if	O
(	O
err	int
)	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
dev	O
)	O
;	O
else	O
{	O
struct	O
file_direct	O
*	O
fdp	pointer
;	O
fdp	pointer
=	O
kalloc	function
(	O
offsetof	O
(	O
struct	O
file_direct	O
,	O
runs	pointer
[	O
1	int
]	O
)	O
)	O
;	O
if	O
(	O
fdp	pointer
==	O
0	int
)	O
return	O
ENOMEM	int
;	O
fdp	pointer
->	O
device	int
=	O
dev	O
;	O
fdp	pointer
->	O
fd_bsize	O
=	O
sizes	int
[	O
DEV_GET_SIZE_RECORD_SIZE	O
]	O
;	O
fdp	pointer
->	O
bshift	O
=	O
ffs	function
(	O
sizes	int
[	O
DEV_GET_SIZE_RECORD_SIZE	O
]	O
)	O
-	O
1	int
;	O
fdp	pointer
->	O
fd_size	O
=	O
sizes	int
[	O
DEV_GET_SIZE_DEVICE_SIZE	O
]	O
>>	O
fdp	pointer
->	O
bshift	O
;	O
fdp	pointer
->	O
nruns	O
=	O
1	int
;	O
fdp	pointer
->	O
runs	pointer
[	O
0	int
]	O
.	O
start	O
=	O
0	int
;	O
fdp	pointer
->	O
runs	pointer
[	O
0	int
]	O
.	O
length	O
=	O
fdp	pointer
->	O
fd_size	O
;	O
create_paging_partition	function
(	O
file_name	pointer
,	O
fdp	pointer
,	O
0	int
,	O
0	int
)	O
;	O
}	O
return	O
err	int
;	O
}	O
kern_return_t	O
remove_paging_file	function
(	O
char	O
*	O
file_name	pointer
)	O
{	O
struct	O
file_direct	O
*	O
fdp	pointer
=	O
0	int
;	O
kern_return_t	O
kr	O
;	O
kr	O
=	O
destroy_paging_partition	function
(	O
file_name	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
fdp	pointer
)	O
;	O
if	O
(	O
kr	O
==	O
KERN_SUCCESS	O
&&	O
fdp	pointer
!=	O
0	int
)	O
{	O
mach_port_deallocate	function
(	O
mach_task_self	function
(	O
)	O
,	O
fdp	pointer
->	O
device	int
)	O
;	O
kfree	function
(	O
fdp	pointer
,	O
(	O
char	O
*	O
)	O
&	O
fdp	pointer
->	O
runs	pointer
[	O
fdp	pointer
->	O
nruns	O
]	O
-	O
(	O
char	O
*	O
)	O
fdp	pointer
)	O
;	O
}	O
return	O
kr	O
;	O
}	O
