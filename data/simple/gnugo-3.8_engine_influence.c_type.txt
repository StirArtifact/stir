static	O
void	O
add_influence_source	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
float	O
strength	array
,	O
float	O
attenuation	float
,	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
;	O
static	O
void	O
print_influence	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
const	O
char	O
*	O
info_string	pointer
)	O
;	O
static	O
void	O
print_numeric_influence	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
const	O
float	O
values	array
[	O
BOARDMAX	O
]	O
,	O
const	O
char	O
*	O
format	pointer
,	O
int	O
width	int
,	O
int	O
draw_stones	int
,	O
int	O
mark_epsilon	int
)	O
;	O
static	O
void	O
print_influence_areas	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
;	O
static	O
void	O
value_territory	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
;	O
static	O
void	O
enter_intrusion_source	function
(	O
int	O
source_pos	int
,	O
int	O
strength_pos	int
,	O
float	O
strength	array
,	O
float	O
attenuation	float
,	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
;	O
static	O
void	O
add_marked_intrusions	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
;	O
struct	O
influence_data	struct
initial_black_influence	struct
;	O
struct	O
influence_data	struct
initial_white_influence	struct
;	O
struct	O
influence_data	struct
move_influence	struct
;	O
struct	O
influence_data	struct
followup_influence	struct
;	O
static	O
struct	O
influence_data	struct
escape_influence	struct
;	O
static	O
struct	O
influence_data	struct
*	O
current_influence	pointer
=	O
NULL	O
;	O
static	O
struct	O
moyo_determination_data	struct
moyo_data	struct
;	O
static	O
struct	O
moyo_determination_data	struct
moyo_restricted_data	struct
;	O
static	O
float	O
territory_determination_value	float
;	O
static	O
struct	O
interpolation_data	struct
min_infl_for_territory	struct
=	O
{	O
6	int
,	O
0.0	int
,	O
24.0	int
,	O
{	O
6.0	int
,	O
15.0	int
,	O
26.0	int
,	O
36.0	int
,	O
45.0	int
,	O
50.0	int
,	O
55.0	int
}	O
}	O
;	O
static	O
struct	O
interpolation_data	struct
territory_correction	struct
=	O
{	O
5	int
,	O
(	O
float	O
)	O
0.0	int
,	O
1.0	int
,	O
{	O
0.0	int
,	O
0.25	int
,	O
0.45	int
,	O
0.65	int
,	O
0.85	int
,	O
1.0	int
}	O
}	O
;	O
static	O
int	O
debug_influence	int
=	O
NO_MOVE	O
;	O
static	O
int	O
influence_id	int
=	O
0	int
;	O
static	O
void	O
accumulate_influence	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
ii	int
;	O
int	O
m	int
=	O
I	O
(	O
pos	int
)	O
;	O
int	O
n	int
=	O
J	O
(	O
pos	int
)	O
;	O
int	O
k	int
;	O
float	O
b	char
;	O
float	O
inv_attenuation	float
;	O
float	O
inv_diagonal_damping	float
;	O
float	O
*	O
permeability_array	pointer
;	O
int	O
queue_start	int
=	O
0	int
;	O
int	O
queue_end	int
=	O
1	int
;	O
static	O
float	O
working	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
working_area_initialized	int
=	O
0	int
;	O
if	O
(	O
!	O
working_area_initialized	int
)	O
{	O
for	O
(	O
ii	int
=	O
0	int
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
working	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
working_area_initialized	int
=	O
1	int
;	O
}	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"Accumulating influence for %s at %m\n"	pointer
,	O
color_to_string	function
(	O
color	int
)	O
,	O
m	int
,	O
n	int
)	O
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
inv_attenuation	float
=	O
1.0	int
/	O
q	pointer
->	O
white_attenuation	array
[	O
pos	int
]	O
;	O
else	O
inv_attenuation	float
=	O
1.0	int
/	O
q	pointer
->	O
black_attenuation	array
[	O
pos	int
]	O
;	O
if	O
(	O
q	pointer
->	O
is_territorial_influence	int
)	O
inv_diagonal_damping	float
=	O
1.0	int
/	O
TERR_DIAGONAL_DAMPING	O
;	O
else	O
inv_diagonal_damping	float
=	O
1.0	int
/	O
DIAGONAL_DAMPING	O
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
permeability_array	pointer
=	O
q	pointer
->	O
white_permeability	array
;	O
else	O
permeability_array	pointer
=	O
q	pointer
->	O
black_permeability	array
;	O
q	pointer
->	O
queue	array
[	O
0	int
]	O
=	O
pos	int
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
working	array
[	O
pos	int
]	O
=	O
q	pointer
->	O
white_strength	array
[	O
pos	int
]	O
;	O
else	O
working	array
[	O
pos	int
]	O
=	O
q	pointer
->	O
black_strength	array
[	O
pos	int
]	O
;	O
while	O
(	O
queue_start	int
<	O
queue_end	int
)	O
{	O
float	O
current_strength	float
;	O
int	O
delta_i	int
,	O
delta_j	int
;	O
ii	int
=	O
q	pointer
->	O
queue	array
[	O
queue_start	int
]	O
;	O
delta_i	int
=	O
I	O
(	O
ii	int
)	O
-	O
m	int
;	O
delta_j	int
=	O
J	O
(	O
ii	int
)	O
-	O
n	int
;	O
queue_start	int
++	O
;	O
if	O
(	O
permeability_array	pointer
[	O
ii	int
]	O
==	O
0.0	int
)	O
continue	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"Picked %1m from queue. w=%f start=%d end=%d\n"	pointer
,	O
ii	int
,	O
working	array
[	O
ii	int
]	O
,	O
queue_start	int
,	O
queue_end	int
)	O
;	O
if	O
(	O
queue_start	int
==	O
1	int
)	O
b	char
=	O
1.0	int
;	O
else	O
b	char
=	O
1.0	int
/	O
(	O
(	O
delta_i	int
)	O
*	O
(	O
delta_i	int
)	O
+	O
(	O
delta_j	int
)	O
*	O
(	O
delta_j	int
)	O
)	O
;	O
current_strength	float
=	O
working	array
[	O
ii	int
]	O
*	O
inv_attenuation	float
;	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
+	O
delta	array
[	O
0	int
]	O
)	O
)	O
code1	O
(	O
deltai	array
[	O
0	int
]	O
,	O
deltaj	array
[	O
0	int
]	O
,	O
ii	int
+	O
delta	array
[	O
0	int
]	O
,	O
0	int
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
+	O
delta	array
[	O
1	int
]	O
)	O
)	O
code1	O
(	O
deltai	array
[	O
1	int
]	O
,	O
deltaj	array
[	O
1	int
]	O
,	O
ii	int
+	O
delta	array
[	O
1	int
]	O
,	O
0	int
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
+	O
delta	array
[	O
2	int
]	O
)	O
)	O
code1	O
(	O
deltai	array
[	O
2	int
]	O
,	O
deltaj	array
[	O
2	int
]	O
,	O
ii	int
+	O
delta	array
[	O
2	int
]	O
,	O
0	int
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
+	O
delta	array
[	O
3	int
]	O
)	O
)	O
code1	O
(	O
deltai	array
[	O
3	int
]	O
,	O
deltaj	array
[	O
3	int
]	O
,	O
ii	int
+	O
delta	array
[	O
3	int
]	O
,	O
0	int
)	O
;	O
b	char
*=	O
0.5	int
;	O
current_strength	float
*=	O
inv_diagonal_damping	float
;	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
+	O
delta	array
[	O
4	int
]	O
)	O
)	O
code1	O
(	O
deltai	array
[	O
4	int
]	O
,	O
deltaj	array
[	O
4	int
]	O
,	O
ii	int
+	O
delta	array
[	O
4	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
+	O
delta	array
[	O
5	int
]	O
)	O
)	O
code1	O
(	O
deltai	array
[	O
5	int
]	O
,	O
deltaj	array
[	O
5	int
]	O
,	O
ii	int
+	O
delta	array
[	O
5	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
+	O
delta	array
[	O
6	int
]	O
)	O
)	O
code1	O
(	O
deltai	array
[	O
6	int
]	O
,	O
deltaj	array
[	O
6	int
]	O
,	O
ii	int
+	O
delta	array
[	O
6	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
+	O
delta	array
[	O
7	int
]	O
)	O
)	O
code1	O
(	O
deltai	array
[	O
7	int
]	O
,	O
deltaj	array
[	O
7	int
]	O
,	O
ii	int
+	O
delta	array
[	O
7	int
]	O
,	O
1	int
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
queue_end	int
;	O
k	int
++	O
)	O
{	O
ii	int
=	O
q	pointer
->	O
queue	array
[	O
k	int
]	O
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
{	O
if	O
(	O
working	array
[	O
ii	int
]	O
>	O
1.01	int
*	O
INFLUENCE_CUTOFF	int
||	O
q	pointer
->	O
white_influence	array
[	O
ii	int
]	O
==	O
0.0	int
)	O
q	pointer
->	O
white_influence	array
[	O
ii	int
]	O
+=	O
working	array
[	O
ii	int
]	O
;	O
}	O
else	O
{	O
if	O
(	O
working	array
[	O
ii	int
]	O
>	O
1.01	int
*	O
INFLUENCE_CUTOFF	int
||	O
q	pointer
->	O
black_influence	array
[	O
ii	int
]	O
==	O
0.0	int
)	O
q	pointer
->	O
black_influence	array
[	O
ii	int
]	O
+=	O
working	array
[	O
ii	int
]	O
;	O
}	O
working	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
}	O
}	O
static	O
void	O
init_influence	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
const	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
const	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
ii	int
;	O
float	O
attenuation	float
;	O
if	O
(	O
cosmic_gnugo	int
)	O
{	O
float	O
t	float
;	O
if	O
(	O
(	O
board_size	int
!=	O
19	int
)	O
||	O
(	O
movenum	int
<=	O
2	int
)	O
||	O
(	O
(	O
movenum	int
/	O
2	int
)	O
%	O
2	int
)	O
)	O
cosmic_importance	float
=	O
0.0	int
;	O
else	O
{	O
cosmic_importance	float
=	O
1.0	int
-	O
(	O
movenum	int
/	O
150.0	int
)	O
*	O
(	O
movenum	int
/	O
150.0	int
)	O
;	O
cosmic_importance	float
=	O
gg_max	O
(	O
0.0	int
,	O
cosmic_importance	float
)	O
;	O
}	O
t	float
=	O
cosmic_importance	float
;	O
moyo_data	struct
.	O
influence_balance	float
=	O
t	float
*	O
15.0	int
+	O
(	O
1.0	int
-	O
t	float
)	O
*	O
5.0	int
;	O
moyo_data	struct
.	O
my_influence_minimum	float
=	O
t	float
*	O
5.0	int
+	O
(	O
1.0	int
-	O
t	float
)	O
*	O
5.0	int
;	O
moyo_data	struct
.	O
opp_influence_maximum	float
=	O
t	float
*	O
30.0	int
+	O
(	O
1.0	int
-	O
t	float
)	O
*	O
30.0	int
;	O
moyo_restricted_data	struct
=	O
moyo_data	struct
;	O
territory_determination_value	float
=	O
t	float
*	O
0.95	int
+	O
(	O
1.0	int
-	O
t	float
)	O
*	O
0.95	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
0	int
]	O
=	O
t	float
*	O
6.0	int
+	O
(	O
1.0	int
-	O
t	float
)	O
*	O
10.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
1	int
]	O
=	O
t	float
*	O
10.0	int
+	O
(	O
1.0	int
-	O
t	float
)	O
*	O
15.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
2	int
]	O
=	O
t	float
*	O
20.0	int
+	O
(	O
1.0	int
-	O
t	float
)	O
*	O
15.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
3	int
]	O
=	O
t	float
*	O
20.0	int
+	O
(	O
1.0	int
-	O
t	float
)	O
*	O
20.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
4	int
]	O
=	O
t	float
*	O
20.0	int
+	O
(	O
1.0	int
-	O
t	float
)	O
*	O
20.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
5	int
]	O
=	O
t	float
*	O
15.0	int
+	O
(	O
1.0	int
-	O
t	float
)	O
*	O
15.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
6	int
]	O
=	O
t	float
*	O
10.0	int
+	O
(	O
1.0	int
-	O
t	float
)	O
*	O
15.0	int
;	O
}	O
else	O
{	O
cosmic_importance	float
=	O
0.0	int
;	O
moyo_data	struct
.	O
influence_balance	float
=	O
7.0	int
;	O
moyo_data	struct
.	O
my_influence_minimum	float
=	O
5.0	int
;	O
moyo_data	struct
.	O
opp_influence_maximum	float
=	O
10.0	int
;	O
moyo_restricted_data	struct
.	O
influence_balance	float
=	O
10.0	int
;	O
moyo_restricted_data	struct
.	O
my_influence_minimum	float
=	O
10.0	int
;	O
moyo_restricted_data	struct
.	O
opp_influence_maximum	float
=	O
10.0	int
;	O
territory_determination_value	float
=	O
0.95	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
0	int
]	O
=	O
6.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
1	int
]	O
=	O
15.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
2	int
]	O
=	O
26.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
3	int
]	O
=	O
36.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
4	int
]	O
=	O
45.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
5	int
]	O
=	O
50.0	int
;	O
min_infl_for_territory	struct
.	O
values	array
[	O
6	int
]	O
=	O
55.0	int
;	O
}	O
if	O
(	O
q	pointer
->	O
is_territorial_influence	int
)	O
attenuation	float
=	O
TERR_DEFAULT_ATTENUATION	O
;	O
else	O
attenuation	float
=	O
2	int
*	O
DEFAULT_ATTENUATION	O
;	O
q	pointer
->	O
intrusion_counter	int
=	O
0	int
;	O
memcpy	function
(	O
q	pointer
->	O
safe	array
,	O
safe_stones	array
,	O
BOARDMAX	O
*	O
sizeof	O
(	O
*	O
safe_stones	array
)	O
)	O
;	O
q	pointer
->	O
captured	int
=	O
black_captured	int
-	O
white_captured	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
{	O
q	pointer
->	O
white_influence	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
q	pointer
->	O
black_influence	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
q	pointer
->	O
white_attenuation	array
[	O
ii	int
]	O
=	O
attenuation	float
;	O
q	pointer
->	O
black_attenuation	array
[	O
ii	int
]	O
=	O
attenuation	float
;	O
q	pointer
->	O
white_permeability	array
[	O
ii	int
]	O
=	O
1.0	int
;	O
q	pointer
->	O
black_permeability	array
[	O
ii	int
]	O
=	O
1.0	int
;	O
q	pointer
->	O
white_strength	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
q	pointer
->	O
black_strength	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
q	pointer
->	O
non_territory	array
[	O
ii	int
]	O
=	O
EMPTY	int
;	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
ii	int
]	O
)	O
)	O
{	O
if	O
(	O
!	O
safe_stones	array
[	O
ii	int
]	O
)	O
{	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
WHITE	int
)	O
q	pointer
->	O
white_permeability	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
else	O
q	pointer
->	O
black_permeability	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
}	O
else	O
{	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
WHITE	int
)	O
{	O
if	O
(	O
strength	array
)	O
q	pointer
->	O
white_strength	array
[	O
ii	int
]	O
=	O
strength	array
[	O
ii	int
]	O
;	O
else	O
q	pointer
->	O
white_strength	array
[	O
ii	int
]	O
=	O
DEFAULT_STRENGTH	int
;	O
q	pointer
->	O
black_permeability	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
}	O
else	O
{	O
if	O
(	O
strength	array
)	O
q	pointer
->	O
black_strength	array
[	O
ii	int
]	O
=	O
strength	array
[	O
ii	int
]	O
;	O
else	O
q	pointer
->	O
black_strength	array
[	O
ii	int
]	O
=	O
DEFAULT_STRENGTH	int
;	O
q	pointer
->	O
white_permeability	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
}	O
}	O
}	O
else	O
q	pointer
->	O
safe	array
[	O
ii	int
]	O
=	O
0	int
;	O
}	O
}	O
static	O
void	O
add_influence_source	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
float	O
strength	array
,	O
float	O
attenuation	float
,	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
{	O
if	O
(	O
(	O
color	int
&	O
WHITE	int
)	O
&&	O
(	O
q	pointer
->	O
white_strength	array
[	O
pos	int
]	O
<	O
strength	array
)	O
)	O
{	O
q	pointer
->	O
white_strength	array
[	O
pos	int
]	O
=	O
strength	array
;	O
q	pointer
->	O
white_attenuation	array
[	O
pos	int
]	O
=	O
attenuation	float
;	O
}	O
if	O
(	O
(	O
color	int
&	O
BLACK	int
)	O
&&	O
(	O
q	pointer
->	O
black_strength	array
[	O
pos	int
]	O
<	O
strength	array
)	O
)	O
{	O
q	pointer
->	O
black_strength	array
[	O
pos	int
]	O
=	O
strength	array
;	O
q	pointer
->	O
black_attenuation	array
[	O
pos	int
]	O
=	O
attenuation	float
;	O
}	O
}	O
static	O
void	O
enter_intrusion_source	function
(	O
int	O
source_pos	int
,	O
int	O
strength_pos	int
,	O
float	O
strength	array
,	O
float	O
attenuation	float
,	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
{	O
if	O
(	O
q	pointer
->	O
intrusion_counter	int
>=	O
MAX_INTRUSIONS	O
)	O
{	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"intrusion list exhausted\n"	pointer
)	O
;	O
return	O
;	O
}	O
q	pointer
->	O
intrusions	array
[	O
q	pointer
->	O
intrusion_counter	int
]	O
.	O
source_pos	int
=	O
source_pos	int
;	O
q	pointer
->	O
intrusions	array
[	O
q	pointer
->	O
intrusion_counter	int
]	O
.	O
strength_pos	int
=	O
strength_pos	int
;	O
q	pointer
->	O
intrusions	array
[	O
q	pointer
->	O
intrusion_counter	int
]	O
.	O
strength	array
=	O
strength	array
;	O
q	pointer
->	O
intrusions	array
[	O
q	pointer
->	O
intrusion_counter	int
]	O
.	O
attenuation	float
=	O
attenuation	float
;	O
q	pointer
->	O
intrusion_counter	int
++	O
;	O
}	O
static	O
int	O
compare_intrusions	function
(	O
const	O
void	O
*	O
p1	pointer
,	O
const	O
void	O
*	O
p2	pointer
)	O
{	O
const	O
struct	O
intrusion_data	struct
*	O
intr1	pointer
=	O
p1	pointer
;	O
const	O
struct	O
intrusion_data	struct
*	O
intr2	pointer
=	O
p2	pointer
;	O
if	O
(	O
intr1	pointer
->	O
source_pos	int
-	O
intr2	pointer
->	O
source_pos	int
!=	O
0	int
)	O
return	O
(	O
intr1	pointer
->	O
source_pos	int
-	O
intr2	pointer
->	O
source_pos	int
)	O
;	O
else	O
if	O
(	O
intr1	pointer
->	O
strength_pos	int
-	O
intr2	pointer
->	O
strength_pos	int
!=	O
0	int
)	O
return	O
(	O
intr1	pointer
->	O
strength_pos	int
-	O
intr2	pointer
->	O
strength_pos	int
)	O
;	O
else	O
if	O
(	O
intr1	pointer
->	O
strength	array
>	O
intr2	pointer
->	O
strength	array
)	O
return	O
1	int
;	O
else	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
reset_unblocked_blocks	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
!	O
q	pointer
->	O
safe	array
[	O
pos	int
]	O
&&	O
q	pointer
->	O
white_strength	array
[	O
pos	int
]	O
>	O
0.0	int
&&	O
q	pointer
->	O
white_permeability	array
[	O
pos	int
]	O
!=	O
1.0	int
)	O
{	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"  black block removed from %1m\n"	pointer
,	O
pos	int
)	O
;	O
q	pointer
->	O
white_permeability	array
[	O
pos	int
]	O
=	O
1.0	int
;	O
}	O
if	O
(	O
!	O
q	pointer
->	O
safe	array
[	O
pos	int
]	O
&&	O
q	pointer
->	O
black_strength	array
[	O
pos	int
]	O
>	O
0.0	int
&&	O
q	pointer
->	O
black_permeability	array
[	O
pos	int
]	O
!=	O
1.0	int
)	O
{	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"  white block removed from %1m\n"	pointer
,	O
pos	int
)	O
;	O
q	pointer
->	O
black_permeability	array
[	O
pos	int
]	O
=	O
1.0	int
;	O
}	O
}	O
}	O
static	O
void	O
add_marked_intrusions	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
{	O
int	O
i	int
;	O
int	O
j	int
=	O
0	int
;	O
int	O
source_pos	int
;	O
float	O
strength_sum	float
;	O
float	O
correction	float
;	O
float	O
source_strength	float
;	O
float	O
allowed_strength	float
;	O
int	O
color	int
=	O
q	pointer
->	O
color_to_move	int
;	O
gg_sort	function
(	O
q	pointer
->	O
intrusions	array
,	O
q	pointer
->	O
intrusion_counter	int
,	O
sizeof	O
(	O
q	pointer
->	O
intrusions	array
[	O
0	int
]	O
)	O
,	O
compare_intrusions	function
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
q	pointer
->	O
intrusion_counter	int
;	O
i	int
=	O
j	int
)	O
{	O
strength_sum	float
=	O
0.0	int
;	O
source_pos	int
=	O
q	pointer
->	O
intrusions	array
[	O
i	int
]	O
.	O
source_pos	int
;	O
if	O
(	O
source_pos	int
==	O
NO_MOVE	O
)	O
{	O
add_influence_source	function
(	O
q	pointer
->	O
intrusions	array
[	O
i	int
]	O
.	O
strength_pos	int
,	O
color	int
,	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
strength	array
,	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
attenuation	float
,	O
q	pointer
)	O
;	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"Adding %s intrusion at %1m, value %f\n"	pointer
,	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
"black"	pointer
:	O
"white"	pointer
,	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
strength_pos	int
,	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
strength	array
)	O
;	O
j	int
=	O
i	int
+	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
color	int
==	O
BLACK	int
)	O
source_strength	float
=	O
q	pointer
->	O
black_strength	array
[	O
source_pos	int
]	O
;	O
else	O
source_strength	float
=	O
q	pointer
->	O
white_strength	array
[	O
source_pos	int
]	O
;	O
for	O
(	O
j	int
=	O
i	int
;	O
(	O
j	int
<	O
q	pointer
->	O
intrusion_counter	int
)	O
&&	O
(	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
source_pos	int
==	O
source_pos	int
)	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
==	O
i	int
||	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
strength_pos	int
!=	O
q	pointer
->	O
intrusions	array
[	O
j	int
-	O
1	int
]	O
.	O
strength_pos	int
)	O
strength_sum	float
+=	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
strength	array
;	O
}	O
if	O
(	O
q	pointer
==	O
&	O
followup_influence	struct
)	O
allowed_strength	float
=	O
source_strength	float
;	O
else	O
allowed_strength	float
=	O
0.6	int
*	O
source_strength	float
;	O
if	O
(	O
strength_sum	float
>	O
allowed_strength	float
)	O
correction	float
=	O
(	O
allowed_strength	float
/	O
strength_sum	float
)	O
;	O
else	O
correction	float
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
i	int
;	O
(	O
j	int
<	O
q	pointer
->	O
intrusion_counter	int
)	O
&&	O
(	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
source_pos	int
==	O
source_pos	int
)	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
j	int
==	O
i	int
||	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
strength_pos	int
!=	O
q	pointer
->	O
intrusions	array
[	O
j	int
-	O
1	int
]	O
.	O
strength_pos	int
)	O
{	O
add_influence_source	function
(	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
strength_pos	int
,	O
color	int
,	O
correction	float
*	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
strength	array
,	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
attenuation	float
,	O
q	pointer
)	O
;	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"Adding %s intrusion for %1m at %1m, value %f (correction %f)\n"	pointer
,	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
"black"	pointer
:	O
"white"	pointer
,	O
source_pos	int
,	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
strength_pos	int
,	O
correction	float
*	O
q	pointer
->	O
intrusions	array
[	O
j	int
]	O
.	O
strength	array
,	O
correction	float
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
influence_callback	function
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
int	O
ll	int
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
pos	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
move_offset	int
,	O
ll	int
,	O
anchor	int
)	O
;	O
int	O
k	int
;	O
struct	O
influence_data	struct
*	O
q	pointer
=	O
data	pointer
;	O
if	O
(	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_E	int
)	O
&&	O
q	pointer
->	O
is_territorial_influence	int
)	O
return	O
;	O
if	O
(	O
doing_scoring	int
&&	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_I	int
)	O
)	O
return	O
;	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
(	O
CLASS_A	int
|	O
CLASS_D	int
)	O
)	O
{	O
int	O
something_to_do	int
=	O
0	int
;	O
gg_assert	O
(	O
q	pointer
->	O
is_territorial_influence	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
patlen	int
;	O
++	O
k	int
)	O
{	O
int	O
blocking_color	int
;	O
int	O
ii	int
;	O
if	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
!=	O
ATT_comma	int
&&	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
!=	O
ATT_not	int
)	O
break	O
;	O
ii	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_D	int
)	O
blocking_color	int
=	O
color	int
;	O
else	O
blocking_color	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
if	O
(	O
(	O
blocking_color	int
==	O
WHITE	int
&&	O
q	pointer
->	O
black_permeability	array
[	O
ii	int
]	O
!=	O
0.0	int
)	O
||	O
(	O
blocking_color	int
==	O
BLACK	int
&&	O
q	pointer
->	O
white_permeability	array
[	O
ii	int
]	O
!=	O
0.0	int
)	O
)	O
{	O
something_to_do	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
something_to_do	int
)	O
return	O
;	O
}	O
if	O
(	O
(	O
pattern	pointer
->	O
class	int
&	O
(	O
CLASS_D	int
|	O
CLASS_A	int
|	O
CLASS_B	int
|	O
CLASS_E	int
|	O
CLASS_t	int
)	O
)	O
&&	O
!	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_s	int
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
patlen	int
;	O
++	O
k	int
)	O
{	O
int	O
ii	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
if	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_O	int
)	O
{	O
if	O
(	O
(	O
pattern	pointer
->	O
class	int
&	O
(	O
CLASS_B	int
|	O
CLASS_t	int
|	O
CLASS_E	int
|	O
CLASS_D	int
)	O
)	O
&&	O
(	O
(	O
color	int
==	O
WHITE	int
&&	O
q	pointer
->	O
white_strength	array
[	O
ii	int
]	O
==	O
0.0	int
)	O
||	O
(	O
color	int
==	O
BLACK	int
&&	O
q	pointer
->	O
black_strength	array
[	O
ii	int
]	O
==	O
0.0	int
)	O
)	O
)	O
return	O
;	O
}	O
else	O
if	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_X	int
)	O
{	O
if	O
(	O
(	O
pattern	pointer
->	O
class	int
&	O
(	O
CLASS_A	int
|	O
CLASS_t	int
)	O
)	O
&&	O
(	O
(	O
color	int
==	O
BLACK	int
&&	O
q	pointer
->	O
white_strength	array
[	O
ii	int
]	O
==	O
0.0	int
)	O
||	O
(	O
color	int
==	O
WHITE	int
&&	O
q	pointer
->	O
black_strength	array
[	O
ii	int
]	O
==	O
0.0	int
)	O
)	O
)	O
return	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	int
)	O
&&	O
!	O
pattern	pointer
->	O
autohelper	pointer
(	O
ll	int
,	O
pos	int
,	O
color	int
,	O
0	int
)	O
)	O
return	O
;	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"influence pattern '%s'+%d matched at %1m\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
if	O
(	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_t	int
)	O
&&	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_ACTION	int
)	O
)	O
{	O
pattern	pointer
->	O
autohelper	pointer
(	O
ll	int
,	O
pos	int
,	O
color	int
,	O
INFLUENCE_CALLBACK	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_I	int
)	O
{	O
int	O
this_color	int
=	O
EMPTY	int
;	O
float	O
strength	array
;	O
float	O
attenuation	float
;	O
if	O
(	O
q	pointer
->	O
color_to_move	int
==	O
EMPTY	int
||	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_s	int
)	O
)	O
this_color	int
=	O
BLACK	int
|	O
WHITE	int
;	O
else	O
if	O
(	O
q	pointer
->	O
color_to_move	int
!=	O
color	int
)	O
this_color	int
=	O
q	pointer
->	O
color_to_move	int
;	O
if	O
(	O
cosmic_gnugo	int
)	O
{	O
float	O
t	float
=	O
0.15	int
+	O
(	O
1.0	int
-	O
cosmic_importance	float
)	O
;	O
t	float
=	O
gg_min	O
(	O
1.0	int
,	O
t	float
)	O
;	O
t	float
=	O
gg_max	O
(	O
0.0	int
,	O
t	float
)	O
;	O
strength	array
=	O
t	float
*	O
pattern	pointer
->	O
value	pointer
;	O
attenuation	float
=	O
1.6	int
;	O
}	O
else	O
{	O
strength	array
=	O
pattern	pointer
->	O
value	pointer
;	O
attenuation	float
=	O
1.5	int
;	O
}	O
if	O
(	O
!	O
q	pointer
->	O
is_territorial_influence	int
&&	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_e	int
)	O
)	O
add_influence_source	function
(	O
pos	int
,	O
this_color	int
,	O
20	int
*	O
strength	array
,	O
attenuation	float
,	O
q	pointer
)	O
;	O
else	O
add_influence_source	function
(	O
pos	int
,	O
this_color	int
,	O
strength	array
,	O
attenuation	float
,	O
q	pointer
)	O
;	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"  low intensity influence source at %1m, strength %f, color %C\n"	pointer
,	O
pos	int
,	O
strength	array
,	O
this_color	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_E	int
)	O
{	O
add_influence_source	function
(	O
pos	int
,	O
color	int
,	O
pattern	pointer
->	O
value	pointer
,	O
DEFAULT_ATTENUATION	O
,	O
q	pointer
)	O
;	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"  extra %C source at %1m, strength %f\n"	pointer
,	O
color	int
,	O
pos	int
,	O
pattern	pointer
->	O
value	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_B	int
)	O
{	O
float	O
strength	array
;	O
if	O
(	O
cosmic_gnugo	int
)	O
{	O
float	O
t	float
=	O
0.15	int
+	O
(	O
1.0	int
-	O
cosmic_importance	float
)	O
;	O
t	float
=	O
gg_min	O
(	O
1.0	int
,	O
t	float
)	O
;	O
t	float
=	O
gg_max	O
(	O
0.0	int
,	O
t	float
)	O
;	O
strength	array
=	O
t	float
*	O
pattern	pointer
->	O
value	pointer
;	O
}	O
else	O
strength	array
=	O
pattern	pointer
->	O
value	pointer
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
patlen	int
;	O
++	O
k	int
)	O
if	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_not	int
)	O
{	O
int	O
ii	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
if	O
(	O
q	pointer
->	O
is_territorial_influence	int
)	O
enter_intrusion_source	function
(	O
anchor	int
,	O
ii	int
,	O
strength	array
,	O
TERR_DEFAULT_ATTENUATION	O
,	O
q	pointer
)	O
;	O
else	O
add_influence_source	function
(	O
ii	int
,	O
color	int
,	O
strength	array
,	O
DEFAULT_ATTENUATION	O
,	O
q	pointer
)	O
;	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"  intrusion at %1m\n"	pointer
,	O
ii	int
)	O
;	O
}	O
return	O
;	O
}	O
gg_assert	O
(	O
pattern	pointer
->	O
class	int
&	O
(	O
CLASS_D	int
|	O
CLASS_A	int
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
patlen	int
;	O
++	O
k	int
)	O
{	O
if	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_comma	int
||	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_not	int
)	O
{	O
int	O
ii	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
int	O
blocking_color	int
;	O
if	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_D	int
)	O
blocking_color	int
=	O
color	int
;	O
else	O
blocking_color	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"  barrier for %s influence at %1m\n"	pointer
,	O
color_to_string	function
(	O
OTHER_COLOR	O
(	O
blocking_color	int
)	O
)	O
,	O
ii	int
)	O
;	O
if	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_comma	int
)	O
{	O
if	O
(	O
blocking_color	int
==	O
WHITE	int
)	O
q	pointer
->	O
black_permeability	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
else	O
q	pointer
->	O
white_permeability	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
}	O
else	O
{	O
if	O
(	O
blocking_color	int
==	O
WHITE	int
)	O
q	pointer
->	O
black_permeability	array
[	O
ii	int
]	O
*=	O
0.7	int
;	O
else	O
q	pointer
->	O
white_permeability	array
[	O
ii	int
]	O
*=	O
0.7	int
;	O
}	O
}	O
}	O
}	O
static	O
void	O
followup_influence_callback	function
(	O
int	O
anchor	int
,	O
int	O
color	int
,	O
struct	O
pattern	pointer
*	O
pattern	pointer
,	O
int	O
ll	int
,	O
void	O
*	O
data	pointer
)	O
{	O
int	O
k	int
;	O
int	O
t	float
;	O
struct	O
influence_data	struct
*	O
q	pointer
=	O
data	pointer
;	O
UNUSED	O
(	O
color	int
)	O
;	O
if	O
(	O
!	O
(	O
pattern	pointer
->	O
class	int
&	O
CLASS_B	int
)	O
)	O
return	O
;	O
t	float
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
move_offset	int
,	O
ll	int
,	O
anchor	int
)	O
;	O
if	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_CONSTRAINT	int
&&	O
!	O
pattern	pointer
->	O
autohelper	pointer
(	O
ll	int
,	O
t	float
,	O
color	int
,	O
0	int
)	O
)	O
return	O
;	O
if	O
(	O
(	O
pattern	pointer
->	O
autohelper_flag	int
&	O
HAVE_ACTION	int
)	O
&&	O
!	O
pattern	pointer
->	O
autohelper	pointer
(	O
ll	int
,	O
t	float
,	O
color	int
,	O
FOLLOWUP_INFLUENCE_CALLBACK	int
)	O
)	O
return	O
;	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"influence pattern '%s'+%d matched at %1m\n"	pointer
,	O
pattern	pointer
->	O
name	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
pattern	pointer
->	O
patlen	int
;	O
++	O
k	int
)	O
if	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
att	char
==	O
ATT_not	int
)	O
{	O
int	O
ii	int
=	O
AFFINE_TRANSFORM	O
(	O
pattern	pointer
->	O
patn	pointer
[	O
k	int
]	O
.	O
offset	short
,	O
ll	int
,	O
anchor	int
)	O
;	O
enter_intrusion_source	function
(	O
anchor	int
,	O
ii	int
,	O
pattern	pointer
->	O
value	pointer
,	O
TERR_DEFAULT_ATTENUATION	O
,	O
q	pointer
)	O
;	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"  followup for %1m: intrusion at %1m\n"	pointer
,	O
anchor	int
,	O
ii	int
)	O
;	O
}	O
}	O
void	O
influence_mark_non_territory	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"  non-territory for %C at %1m\n"	pointer
,	O
color	int
,	O
pos	int
)	O
;	O
current_influence	pointer
->	O
non_territory	array
[	O
pos	int
]	O
|=	O
color	int
;	O
}	O
void	O
influence_erase_territory	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
ASSERT1	O
(	O
(	O
color	int
==	O
WHITE	int
&&	O
q	pointer
->	O
territory_value	array
[	O
pos	int
]	O
>=	O
0.0	int
)	O
||	O
(	O
color	int
==	O
BLACK	int
&&	O
q	pointer
->	O
territory_value	array
[	O
pos	int
]	O
<=	O
0.0	int
)	O
,	O
pos	int
)	O
;	O
current_influence	pointer
=	O
q	pointer
;	O
q	pointer
->	O
territory_value	array
[	O
pos	int
]	O
=	O
0.0	int
;	O
influence_mark_non_territory	function
(	O
pos	int
,	O
color	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
)	O
{	O
q	pointer
->	O
territory_value	array
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
=	O
0.0	int
;	O
influence_mark_non_territory	function
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
,	O
color	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
find_influence_patterns	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
{	O
int	O
ii	int
;	O
current_influence	pointer
=	O
q	pointer
;	O
matchpat	function
(	O
influence_callback	function
,	O
ANCHOR_COLOR	int
,	O
&	O
influencepat_db	struct
,	O
q	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
q	pointer
->	O
color_to_move	int
!=	O
EMPTY	int
)	O
matchpat	function
(	O
influence_callback	function
,	O
q	pointer
->	O
color_to_move	int
,	O
&	O
barrierspat_db	struct
,	O
q	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
q	pointer
->	O
is_territorial_influence	int
)	O
add_marked_intrusions	function
(	O
q	pointer
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
!	O
q	pointer
->	O
safe	array
[	O
ii	int
]	O
)	O
{	O
int	O
k	int
;	O
float	O
black_reduction	float
=	O
1.0	int
;	O
float	O
white_reduction	float
=	O
1.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
ii	int
+	O
d	int
]	O
)	O
&&	O
q	pointer
->	O
safe	array
[	O
ii	int
+	O
d	int
]	O
)	O
{	O
float	O
reduction	float
=	O
(	O
k	int
<	O
4	int
)	O
?	O
0.25	int
:	O
0.65	int
;	O
if	O
(	O
board	pointer
[	O
ii	int
+	O
d	int
]	O
==	O
BLACK	int
)	O
white_reduction	float
*=	O
reduction	float
;	O
else	O
black_reduction	float
*=	O
reduction	float
;	O
}	O
else	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
ii	int
+	O
d	int
]	O
)	O
&&	O
!	O
q	pointer
->	O
safe	array
[	O
ii	int
+	O
d	int
]	O
)	O
{	O
if	O
(	O
board	pointer
[	O
ii	int
+	O
d	int
]	O
==	O
BLACK	int
)	O
white_reduction	float
=	O
-	O
100.0	int
;	O
else	O
black_reduction	float
=	O
-	O
100.0	int
;	O
}	O
}	O
if	O
(	O
black_reduction	float
>	O
0.0	int
)	O
q	pointer
->	O
black_permeability	array
[	O
ii	int
]	O
*=	O
black_reduction	float
;	O
if	O
(	O
white_reduction	float
>	O
0.0	int
)	O
q	pointer
->	O
white_permeability	array
[	O
ii	int
]	O
*=	O
white_reduction	float
;	O
}	O
reset_unblocked_blocks	function
(	O
q	pointer
)	O
;	O
}	O
static	O
int	O
check_double_block	function
(	O
int	O
color	int
,	O
int	O
pos	int
,	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
{	O
int	O
k	int
;	O
int	O
block_neighbors	int
=	O
0	int
;	O
const	O
float	O
*	O
permeability	float
=	O
(	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
q	pointer
->	O
black_permeability	array
:	O
q	pointer
->	O
white_permeability	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
permeability	float
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
0.0	int
)	O
block_neighbors	int
++	O
;	O
if	O
(	O
block_neighbors	int
>=	O
2	int
)	O
{	O
float	O
smallest_value	float
=	O
4.0	int
*	O
MAX_BOARD	int
*	O
MAX_BOARD	int
;	O
int	O
smallest_block	int
=	O
NO_MOVE	O
;	O
float	O
sign	float
=	O
(	O
(	O
color	int
==	O
WHITE	int
)	O
?	O
-	O
1.0	int
:	O
1.0	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
neighbor	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
neighbor	int
]	O
==	O
EMPTY	int
&&	O
permeability	float
[	O
neighbor	int
]	O
==	O
0.0	int
)	O
{	O
float	O
this_value	float
=	O
sign	float
*	O
q	pointer
->	O
territory_value	array
[	O
neighbor	int
]	O
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
4	int
;	O
j	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
neighbor	int
+	O
delta	array
[	O
j	int
]	O
)	O
)	O
this_value	float
+=	O
sign	float
*	O
q	pointer
->	O
territory_value	array
[	O
neighbor	int
+	O
delta	array
[	O
j	int
]	O
]	O
;	O
if	O
(	O
this_value	float
+	O
0.0005	int
<	O
smallest_value	float
)	O
{	O
smallest_block	int
=	O
neighbor	int
;	O
smallest_value	float
=	O
this_value	float
;	O
}	O
}	O
}	O
ASSERT1	O
(	O
ON_BOARD1	O
(	O
smallest_block	int
)	O
,	O
pos	int
)	O
;	O
return	O
smallest_block	int
;	O
}	O
return	O
NO_MOVE	O
;	O
}	O
static	O
void	O
remove_double_blocks	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
const	O
signed	O
char	O
inhibited_sources	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
ii	int
;	O
float	O
*	O
strength	array
=	O
(	O
(	O
q	pointer
->	O
color_to_move	int
==	O
WHITE	int
)	O
?	O
q	pointer
->	O
white_strength	array
:	O
q	pointer
->	O
black_strength	array
)	O
;	O
int	O
double_blocks	array
[	O
MAX_DOUBLE_BLOCKS	int
]	O
;	O
int	O
num_blocks	int
=	O
0	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
EMPTY	int
&&	O
!	O
(	O
inhibited_sources	array
&&	O
inhibited_sources	array
[	O
ii	int
]	O
)	O
&&	O
strength	array
[	O
ii	int
]	O
>	O
0.0	int
)	O
{	O
double_blocks	array
[	O
num_blocks	int
]	O
=	O
check_double_block	function
(	O
q	pointer
->	O
color_to_move	int
,	O
ii	int
,	O
q	pointer
)	O
;	O
if	O
(	O
double_blocks	array
[	O
num_blocks	int
]	O
!=	O
NO_MOVE	O
)	O
{	O
num_blocks	int
++	O
;	O
if	O
(	O
num_blocks	int
==	O
MAX_DOUBLE_BLOCKS	int
)	O
break	O
;	O
}	O
}	O
{	O
int	O
k	int
;	O
float	O
*	O
permeability	float
=	O
(	O
(	O
q	pointer
->	O
color_to_move	int
==	O
BLACK	int
)	O
?	O
q	pointer
->	O
black_permeability	array
:	O
q	pointer
->	O
white_permeability	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_blocks	int
;	O
k	int
++	O
)	O
{	O
DEBUG	O
(	O
DEBUG_INFLUENCE	int
,	O
"Removing block for %s at %1m.\n"	pointer
,	O
color_to_string	function
(	O
q	pointer
->	O
color_to_move	int
)	O
,	O
double_blocks	array
[	O
k	int
]	O
)	O
;	O
permeability	float
[	O
double_blocks	array
[	O
k	int
]	O
]	O
=	O
1.0	int
;	O
accumulate_influence	function
(	O
q	pointer
,	O
double_blocks	array
[	O
k	int
]	O
,	O
q	pointer
->	O
color_to_move	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
do_compute_influence	function
(	O
const	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
const	O
signed	O
char	O
inhibited_sources	array
[	O
BOARDMAX	O
]	O
,	O
const	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
move	pointer
,	O
const	O
char	O
*	O
trace_message	pointer
)	O
{	O
int	O
ii	int
;	O
init_influence	function
(	O
q	pointer
,	O
safe_stones	array
,	O
strength	array
)	O
;	O
modify_depth_values	function
(	O
stackp	int
-	O
1	int
)	O
;	O
find_influence_patterns	function
(	O
q	pointer
)	O
;	O
modify_depth_values	function
(	O
1	int
-	O
stackp	int
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
!	O
(	O
inhibited_sources	array
&&	O
inhibited_sources	array
[	O
ii	int
]	O
)	O
)	O
{	O
if	O
(	O
q	pointer
->	O
white_strength	array
[	O
ii	int
]	O
>	O
0.0	int
)	O
accumulate_influence	function
(	O
q	pointer
,	O
ii	int
,	O
WHITE	int
)	O
;	O
if	O
(	O
q	pointer
->	O
black_strength	array
[	O
ii	int
]	O
>	O
0.0	int
)	O
accumulate_influence	function
(	O
q	pointer
,	O
ii	int
,	O
BLACK	int
)	O
;	O
}	O
value_territory	function
(	O
q	pointer
)	O
;	O
remove_double_blocks	function
(	O
q	pointer
,	O
inhibited_sources	array
)	O
;	O
value_territory	function
(	O
q	pointer
)	O
;	O
if	O
(	O
(	O
move	pointer
==	O
NO_MOVE	O
&&	O
(	O
printmoyo	int
&	O
PRINTMOYO_INITIAL_INFLUENCE	int
)	O
)	O
||	O
(	O
debug_influence	int
&&	O
move	pointer
==	O
debug_influence	int
)	O
)	O
print_influence	function
(	O
q	pointer
,	O
trace_message	pointer
)	O
;	O
}	O
void	O
compute_influence	function
(	O
int	O
color	int
,	O
const	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
const	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
,	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
move	pointer
,	O
const	O
char	O
*	O
trace_message	pointer
)	O
{	O
int	O
save_debug	int
=	O
debug	int
;	O
VALGRIND_MAKE_WRITABLE	O
(	O
q	pointer
,	O
sizeof	O
(	O
*	O
q	pointer
)	O
)	O
;	O
q	pointer
->	O
is_territorial_influence	int
=	O
1	int
;	O
q	pointer
->	O
color_to_move	int
=	O
color	int
;	O
if	O
(	O
(	O
move	pointer
==	O
NO_MOVE	O
&&	O
!	O
(	O
printmoyo	int
&	O
PRINTMOYO_INITIAL_INFLUENCE	int
)	O
)	O
||	O
(	O
move	pointer
!=	O
NO_MOVE	O
&&	O
move	pointer
!=	O
debug_influence	int
)	O
)	O
debug	int
=	O
debug	int
&	O
~	O
DEBUG_INFLUENCE	int
;	O
influence_id	int
++	O
;	O
q	pointer
->	O
id	int
=	O
influence_id	int
;	O
do_compute_influence	function
(	O
safe_stones	array
,	O
NULL	O
,	O
strength	array
,	O
q	pointer
,	O
move	pointer
,	O
trace_message	pointer
)	O
;	O
debug	int
=	O
save_debug	int
;	O
}	O
int	O
whose_territory	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
pos	int
)	O
{	O
float	O
bi	float
=	O
q	pointer
->	O
black_influence	array
[	O
pos	int
]	O
;	O
float	O
wi	float
=	O
q	pointer
->	O
white_influence	array
[	O
pos	int
]	O
;	O
float	O
terr	float
=	O
q	pointer
->	O
territory_value	array
[	O
pos	int
]	O
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
bi	float
>	O
0.0	int
&&	O
wi	float
==	O
0.0	int
&&	O
terr	float
<	O
-	O
territory_determination_value	float
)	O
return	O
BLACK	int
;	O
if	O
(	O
wi	float
>	O
0.0	int
&&	O
bi	float
==	O
0.0	int
&&	O
terr	float
>	O
territory_determination_value	float
)	O
return	O
WHITE	int
;	O
return	O
EMPTY	int
;	O
}	O
int	O
whose_moyo	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
pos	int
)	O
{	O
float	O
bi	float
=	O
q	pointer
->	O
black_influence	array
[	O
pos	int
]	O
;	O
float	O
wi	float
=	O
q	pointer
->	O
white_influence	array
[	O
pos	int
]	O
;	O
int	O
territory_color	int
=	O
whose_territory	function
(	O
q	pointer
,	O
pos	int
)	O
;	O
if	O
(	O
territory_color	int
!=	O
EMPTY	int
)	O
return	O
territory_color	int
;	O
if	O
(	O
bi	float
>	O
moyo_data	struct
.	O
influence_balance	float
*	O
wi	float
&&	O
bi	float
>	O
moyo_data	struct
.	O
my_influence_minimum	float
&&	O
wi	float
<	O
moyo_data	struct
.	O
opp_influence_maximum	float
)	O
return	O
BLACK	int
;	O
if	O
(	O
wi	float
>	O
moyo_data	struct
.	O
influence_balance	float
*	O
bi	float
&&	O
wi	float
>	O
moyo_data	struct
.	O
my_influence_minimum	float
&&	O
bi	float
<	O
moyo_data	struct
.	O
opp_influence_maximum	float
)	O
return	O
WHITE	int
;	O
return	O
EMPTY	int
;	O
}	O
int	O
whose_moyo_restricted	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
pos	int
)	O
{	O
float	O
bi	float
=	O
q	pointer
->	O
black_influence	array
[	O
pos	int
]	O
;	O
float	O
wi	float
=	O
q	pointer
->	O
white_influence	array
[	O
pos	int
]	O
;	O
int	O
territory_color	int
=	O
whose_territory	function
(	O
q	pointer
,	O
pos	int
)	O
;	O
if	O
(	O
territory_color	int
!=	O
EMPTY	int
)	O
return	O
territory_color	int
;	O
else	O
if	O
(	O
bi	float
>	O
moyo_restricted_data	struct
.	O
influence_balance	float
*	O
wi	float
&&	O
bi	float
>	O
moyo_restricted_data	struct
.	O
my_influence_minimum	float
&&	O
wi	float
<	O
moyo_restricted_data	struct
.	O
opp_influence_maximum	float
)	O
return	O
BLACK	int
;	O
else	O
if	O
(	O
wi	float
>	O
moyo_restricted_data	struct
.	O
influence_balance	float
*	O
bi	float
&&	O
wi	float
>	O
moyo_restricted_data	struct
.	O
my_influence_minimum	float
&&	O
bi	float
<	O
moyo_restricted_data	struct
.	O
opp_influence_maximum	float
)	O
return	O
WHITE	int
;	O
else	O
return	O
EMPTY	int
;	O
}	O
int	O
whose_area	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
pos	int
)	O
{	O
float	O
bi	float
=	O
q	pointer
->	O
black_influence	array
[	O
pos	int
]	O
;	O
float	O
wi	float
=	O
q	pointer
->	O
white_influence	array
[	O
pos	int
]	O
;	O
int	O
moyo_color	int
=	O
whose_moyo	function
(	O
q	pointer
,	O
pos	int
)	O
;	O
if	O
(	O
moyo_color	int
!=	O
EMPTY	int
)	O
return	O
moyo_color	int
;	O
if	O
(	O
bi	float
>	O
3.0	int
*	O
wi	float
&&	O
bi	float
>	O
1.0	int
&&	O
wi	float
<	O
40.0	int
)	O
return	O
BLACK	int
;	O
if	O
(	O
wi	float
>	O
3.0	int
*	O
bi	float
&&	O
wi	float
>	O
1.0	int
&&	O
bi	float
<	O
40.0	int
)	O
return	O
WHITE	int
;	O
return	O
EMPTY	int
;	O
}	O
static	O
void	O
value_territory	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
{	O
int	O
ii	int
;	O
int	O
dist_i	int
,	O
dist_j	int
;	O
float	O
central	float
;	O
float	O
first_guess	array
[	O
BOARDMAX	O
]	O
;	O
float	O
ratio	float
;	O
int	O
k	int
;	O
memset	function
(	O
first_guess	array
,	O
0	int
,	O
BOARDMAX	O
*	O
sizeof	O
(	O
float	O
)	O
)	O
;	O
memset	function
(	O
q	pointer
->	O
territory_value	array
,	O
0	int
,	O
BOARDMAX	O
*	O
sizeof	O
(	O
float	O
)	O
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
!	O
q	pointer
->	O
safe	array
[	O
ii	int
]	O
)	O
{	O
float	O
diff	float
=	O
0.0	int
;	O
if	O
(	O
q	pointer
->	O
white_influence	array
[	O
ii	int
]	O
+	O
q	pointer
->	O
black_influence	array
[	O
ii	int
]	O
>	O
0	int
)	O
diff	float
=	O
(	O
q	pointer
->	O
white_influence	array
[	O
ii	int
]	O
-	O
q	pointer
->	O
black_influence	array
[	O
ii	int
]	O
)	O
/	O
(	O
q	pointer
->	O
white_influence	array
[	O
ii	int
]	O
+	O
q	pointer
->	O
black_influence	array
[	O
ii	int
]	O
)	O
;	O
first_guess	array
[	O
ii	int
]	O
=	O
diff	float
*	O
diff	float
*	O
diff	float
;	O
dist_i	int
=	O
gg_min	O
(	O
I	O
(	O
ii	int
)	O
,	O
board_size	int
-	O
I	O
(	O
ii	int
)	O
-	O
1	int
)	O
;	O
dist_j	int
=	O
gg_min	O
(	O
J	O
(	O
ii	int
)	O
,	O
board_size	int
-	O
J	O
(	O
ii	int
)	O
-	O
1	int
)	O
;	O
if	O
(	O
dist_i	int
>	O
dist_j	int
)	O
dist_i	int
=	O
gg_min	O
(	O
4	int
,	O
dist_i	int
)	O
;	O
else	O
dist_j	int
=	O
gg_min	O
(	O
4	int
,	O
dist_j	int
)	O
;	O
central	float
=	O
(	O
float	O
)	O
2	int
*	O
gg_min	O
(	O
dist_i	int
,	O
dist_j	int
)	O
+	O
dist_i	int
+	O
dist_j	int
;	O
ratio	float
=	O
gg_max	O
(	O
q	pointer
->	O
black_influence	array
[	O
ii	int
]	O
,	O
q	pointer
->	O
white_influence	array
[	O
ii	int
]	O
)	O
/	O
gg_interpolate	function
(	O
&	O
min_infl_for_territory	struct
,	O
central	float
)	O
;	O
if	O
(	O
doing_scoring	int
&&	O
(	O
q	pointer
->	O
black_influence	array
[	O
ii	int
]	O
==	O
0.0	int
||	O
q	pointer
->	O
white_influence	array
[	O
ii	int
]	O
==	O
0.0	int
)	O
)	O
ratio	float
=	O
1.0	int
;	O
first_guess	array
[	O
ii	int
]	O
*=	O
gg_interpolate	function
(	O
&	O
territory_correction	struct
,	O
ratio	float
)	O
;	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
BLACK	int
)	O
first_guess	array
[	O
ii	int
]	O
=	O
1.0	int
;	O
else	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
WHITE	int
)	O
first_guess	array
[	O
ii	int
]	O
=	O
-	O
1.0	int
;	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
=	O
first_guess	array
[	O
ii	int
]	O
;	O
}	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
!	O
q	pointer
->	O
safe	array
[	O
ii	int
]	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
ii	int
+	O
delta	array
[	O
k	int
]	O
)	O
)	O
continue	O
;	O
if	O
(	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
>	O
0.0	int
)	O
{	O
if	O
(	O
!	O
q	pointer
->	O
safe	array
[	O
ii	int
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
{	O
float	O
neighbor_val	float
=	O
q	pointer
->	O
black_permeability	array
[	O
ii	int
+	O
delta	array
[	O
k	int
]	O
]	O
*	O
first_guess	array
[	O
ii	int
+	O
delta	array
[	O
k	int
]	O
]	O
+	O
(	O
1.0	int
-	O
q	pointer
->	O
black_permeability	array
[	O
ii	int
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
*	O
first_guess	array
[	O
ii	int
]	O
;	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
=	O
gg_max	O
(	O
0	int
,	O
gg_min	O
(	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
,	O
neighbor_val	float
)	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
q	pointer
->	O
safe	array
[	O
ii	int
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
{	O
float	O
neighbor_val	float
=	O
q	pointer
->	O
white_permeability	array
[	O
ii	int
+	O
delta	array
[	O
k	int
]	O
]	O
*	O
first_guess	array
[	O
ii	int
+	O
delta	array
[	O
k	int
]	O
]	O
+	O
(	O
1	int
-	O
q	pointer
->	O
white_permeability	array
[	O
ii	int
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
*	O
first_guess	array
[	O
ii	int
]	O
;	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
=	O
gg_min	O
(	O
0	int
,	O
gg_max	O
(	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
,	O
neighbor_val	float
)	O
)	O
;	O
}	O
}	O
}	O
}	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
!	O
q	pointer
->	O
safe	array
[	O
ii	int
]	O
)	O
{	O
if	O
(	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
>	O
0.0	int
&&	O
(	O
q	pointer
->	O
non_territory	array
[	O
ii	int
]	O
&	O
WHITE	int
)	O
)	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
if	O
(	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
<	O
0.0	int
&&	O
(	O
q	pointer
->	O
non_territory	array
[	O
ii	int
]	O
&	O
BLACK	int
)	O
)	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
BLACK	int
)	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
+=	O
1.0	int
;	O
else	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
WHITE	int
)	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
-=	O
1.0	int
;	O
}	O
}	O
static	O
void	O
segment_region	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
owner_function_ptr	pointer
region_owner	pointer
,	O
struct	O
moyo_data	struct
*	O
regions	pointer
)	O
{	O
int	O
ii	int
;	O
static	O
signed	O
char	O
marked	array
[	O
BOARDMAX	O
]	O
;	O
regions	pointer
->	O
number	int
=	O
0	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
{	O
marked	array
[	O
ii	int
]	O
=	O
0	int
;	O
regions	pointer
->	O
segmentation	array
[	O
ii	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
!	O
marked	array
[	O
ii	int
]	O
&&	O
region_owner	pointer
(	O
q	pointer
,	O
ii	int
)	O
!=	O
EMPTY	int
)	O
{	O
int	O
size	int
=	O
0	int
;	O
float	O
terr_val	float
=	O
0.0	int
;	O
int	O
queue_start	int
=	O
0	int
;	O
int	O
queue_end	int
=	O
1	int
;	O
int	O
color	int
=	O
region_owner	pointer
(	O
q	pointer
,	O
ii	int
)	O
;	O
regions	pointer
->	O
number	int
++	O
;	O
marked	array
[	O
ii	int
]	O
=	O
1	int
;	O
q	pointer
->	O
queue	array
[	O
0	int
]	O
=	O
ii	int
;	O
while	O
(	O
queue_start	int
<	O
queue_end	int
)	O
{	O
int	O
tt	int
=	O
q	pointer
->	O
queue	array
[	O
queue_start	int
]	O
;	O
int	O
k	int
;	O
queue_start	int
++	O
;	O
if	O
(	O
!	O
q	pointer
->	O
safe	array
[	O
tt	int
]	O
||	O
board	pointer
[	O
tt	int
]	O
!=	O
color	int
)	O
{	O
size	int
++	O
;	O
if	O
(	O
q	pointer
->	O
is_territorial_influence	int
)	O
terr_val	float
+=	O
gg_abs	O
(	O
q	pointer
->	O
territory_value	array
[	O
tt	int
]	O
)	O
;	O
}	O
regions	pointer
->	O
segmentation	array
[	O
tt	int
]	O
=	O
regions	pointer
->	O
number	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
tt	int
+	O
d	int
)	O
&&	O
!	O
marked	array
[	O
tt	int
+	O
d	int
]	O
&&	O
region_owner	pointer
(	O
q	pointer
,	O
tt	int
+	O
d	int
)	O
==	O
color	int
)	O
{	O
q	pointer
->	O
queue	array
[	O
queue_end	int
]	O
=	O
tt	int
+	O
d	int
;	O
queue_end	int
++	O
;	O
marked	array
[	O
tt	int
+	O
d	int
]	O
=	O
1	int
;	O
}	O
}	O
}	O
regions	pointer
->	O
size	int
[	O
regions	pointer
->	O
number	int
]	O
=	O
size	int
;	O
regions	pointer
->	O
territorial_value	array
[	O
regions	pointer
->	O
number	int
]	O
=	O
terr_val	float
;	O
regions	pointer
->	O
owner	array
[	O
regions	pointer
->	O
number	int
]	O
=	O
color	int
;	O
}	O
}	O
void	O
influence_get_territory_segmentation	function
(	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
struct	O
moyo_data	struct
*	O
moyos	pointer
)	O
{	O
segment_region	function
(	O
q	pointer
,	O
whose_territory	function
,	O
moyos	pointer
)	O
;	O
}	O
float	O
influence_territory	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
return	O
q	pointer
->	O
territory_value	array
[	O
pos	int
]	O
;	O
else	O
return	O
-	O
q	pointer
->	O
territory_value	array
[	O
pos	int
]	O
;	O
}	O
int	O
influence_considered_lively	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
pos	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
pos	int
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
return	O
(	O
q	pointer
->	O
safe	array
[	O
pos	int
]	O
&&	O
(	O
(	O
color	int
==	O
WHITE	int
&&	O
q	pointer
->	O
white_strength	array
[	O
pos	int
]	O
>	O
0	int
)	O
||	O
(	O
color	int
==	O
BLACK	int
&&	O
q	pointer
->	O
black_strength	array
[	O
pos	int
]	O
>	O
0	int
)	O
)	O
)	O
;	O
}	O
void	O
compute_followup_influence	function
(	O
const	O
struct	O
influence_data	struct
*	O
base	pointer
,	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
move	pointer
,	O
const	O
char	O
*	O
trace_message	pointer
)	O
{	O
int	O
ii	int
;	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
;	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
base	pointer
->	O
color_to_move	int
)	O
;	O
int	O
save_debug	int
=	O
debug	int
;	O
memcpy	function
(	O
q	pointer
,	O
base	pointer
,	O
sizeof	O
(	O
*	O
q	pointer
)	O
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
q	pointer
->	O
color_to_move	int
)	O
,	O
move	pointer
)	O
;	O
q	pointer
->	O
color_to_move	int
=	O
color	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
{	O
if	O
(	O
q	pointer
->	O
safe	array
[	O
ii	int
]	O
==	O
INFLUENCE_SAVED_STONE	int
)	O
goal	pointer
[	O
ii	int
]	O
=	O
1	int
;	O
else	O
goal	pointer
[	O
ii	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
(	O
move	pointer
==	O
NO_MOVE	O
&&	O
!	O
(	O
printmoyo	int
&	O
PRINTMOYO_INITIAL_INFLUENCE	int
)	O
)	O
||	O
(	O
move	pointer
!=	O
debug_influence	int
)	O
)	O
debug	int
=	O
debug	int
&	O
~	O
DEBUG_INFLUENCE	int
;	O
q	pointer
->	O
intrusion_counter	int
=	O
0	int
;	O
current_influence	pointer
=	O
q	pointer
;	O
matchpat_goal_anchor	function
(	O
followup_influence_callback	function
,	O
color	int
,	O
&	O
barrierspat_db	struct
,	O
q	pointer
,	O
goal	pointer
,	O
1	int
)	O
;	O
debug	int
=	O
save_debug	int
;	O
add_marked_intrusions	function
(	O
q	pointer
)	O
;	O
reset_unblocked_blocks	function
(	O
q	pointer
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
if	O
(	O
(	O
color	int
==	O
BLACK	int
&&	O
q	pointer
->	O
black_strength	array
[	O
ii	int
]	O
>	O
base	pointer
->	O
black_strength	array
[	O
ii	int
]	O
)	O
||	O
(	O
color	int
==	O
WHITE	int
&&	O
q	pointer
->	O
white_strength	array
[	O
ii	int
]	O
>	O
base	pointer
->	O
white_strength	array
[	O
ii	int
]	O
)	O
)	O
accumulate_influence	function
(	O
q	pointer
,	O
ii	int
,	O
color	int
)	O
;	O
value_territory	function
(	O
q	pointer
)	O
;	O
if	O
(	O
debug_influence	int
&&	O
debug_influence	int
==	O
move	pointer
)	O
print_influence	function
(	O
q	pointer
,	O
trace_message	pointer
)	O
;	O
}	O
void	O
compute_escape_influence	function
(	O
int	O
color	int
,	O
const	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
const	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
const	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
escape_value	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
ii	int
;	O
int	O
save_debug	int
=	O
debug	int
;	O
static	O
int	O
cached_board	array
[	O
BOARDMAX	O
]	O
;	O
static	O
signed	O
char	O
escape_values	array
[	O
BOARDMAX	O
]	O
[	O
2	int
]	O
;	O
static	O
int	O
active_caches	array
[	O
2	int
]	O
=	O
{	O
0	int
,	O
0	int
}	O
;	O
int	O
cache_number	int
=	O
(	O
color	int
==	O
WHITE	int
)	O
;	O
VALGRIND_MAKE_WRITABLE	O
(	O
&	O
escape_influence	struct
,	O
sizeof	O
(	O
escape_influence	struct
)	O
)	O
;	O
if	O
(	O
!	O
goal	pointer
)	O
{	O
int	O
board_was_cached	int
=	O
1	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
{	O
if	O
(	O
cached_board	array
[	O
ii	int
]	O
!=	O
board	pointer
[	O
ii	int
]	O
)	O
{	O
cached_board	array
[	O
ii	int
]	O
=	O
board	pointer
[	O
ii	int
]	O
;	O
board_was_cached	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
!	O
board_was_cached	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
active_caches	array
[	O
k	int
]	O
=	O
0	int
;	O
if	O
(	O
active_caches	array
[	O
cache_number	int
]	O
)	O
{	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
escape_value	array
[	O
ii	int
]	O
=	O
escape_values	array
[	O
ii	int
]	O
[	O
cache_number	int
]	O
;	O
return	O
;	O
}	O
}	O
escape_influence	struct
.	O
is_territorial_influence	int
=	O
0	int
;	O
escape_influence	struct
.	O
color_to_move	int
=	O
EMPTY	int
;	O
if	O
(	O
!	O
(	O
debug	int
&	O
DEBUG_ESCAPE	int
)	O
)	O
debug	int
&=	O
~	O
DEBUG_INFLUENCE	int
;	O
do_compute_influence	function
(	O
safe_stones	array
,	O
goal	pointer
,	O
strength	array
,	O
&	O
escape_influence	struct
,	O
-	O
1	int
,	O
NULL	O
)	O
;	O
debug	int
=	O
save_debug	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
{	O
if	O
(	O
whose_moyo	function
(	O
&	O
escape_influence	struct
,	O
ii	int
)	O
==	O
color	int
)	O
escape_value	array
[	O
ii	int
]	O
=	O
4	int
;	O
else	O
if	O
(	O
whose_area	function
(	O
&	O
escape_influence	struct
,	O
ii	int
)	O
==	O
color	int
)	O
escape_value	array
[	O
ii	int
]	O
=	O
2	int
;	O
else	O
if	O
(	O
whose_area	function
(	O
&	O
escape_influence	struct
,	O
ii	int
)	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
goal	pointer
)	O
{	O
escape_value	array
[	O
ii	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
goal	pointer
[	O
ii	int
]	O
)	O
{	O
int	O
goal_proximity	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
+	O
delta	array
[	O
k	int
]	O
)	O
)	O
{	O
goal_proximity	int
+=	O
2	int
*	O
goal	pointer
[	O
ii	int
+	O
delta	array
[	O
k	int
]	O
]	O
;	O
if	O
(	O
k	int
<	O
4	int
&&	O
ON_BOARD	O
(	O
ii	int
+	O
2	int
*	O
delta	array
[	O
k	int
]	O
)	O
)	O
goal_proximity	int
+=	O
goal	pointer
[	O
ii	int
+	O
delta	array
[	O
k	int
]	O
]	O
;	O
}	O
else	O
goal_proximity	int
+=	O
1	int
;	O
}	O
if	O
(	O
goal_proximity	int
<	O
6	int
)	O
escape_value	array
[	O
ii	int
]	O
=	O
1	int
;	O
}	O
}	O
else	O
escape_value	array
[	O
ii	int
]	O
=	O
1	int
;	O
}	O
else	O
escape_value	array
[	O
ii	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
0	int
&&	O
(	O
debug	int
&	O
DEBUG_ESCAPE	int
)	O
&&	O
verbose	int
>	O
0	int
)	O
print_influence	function
(	O
&	O
escape_influence	struct
,	O
"escape influence"	pointer
)	O
;	O
if	O
(	O
!	O
goal	pointer
)	O
{	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
escape_values	array
[	O
ii	int
]	O
[	O
cache_number	int
]	O
=	O
escape_value	array
[	O
ii	int
]	O
;	O
active_caches	array
[	O
cache_number	int
]	O
=	O
1	int
;	O
}	O
}	O
static	O
float	O
delta_territory_cache	array
[	O
BOARDMAX	O
]	O
;	O
static	O
float	O
followup_territory_cache	array
[	O
BOARDMAX	O
]	O
;	O
static	O
Hash_data	struct
delta_territory_cache_hash	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
territory_cache_position_number	int
=	O
-	O
1	int
;	O
static	O
int	O
territory_cache_influence_id	int
=	O
-	O
1	int
;	O
static	O
int	O
territory_cache_color	int
=	O
-	O
1	int
;	O
int	O
retrieve_delta_territory_cache	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
float	O
*	O
move_value	pointer
,	O
float	O
*	O
followup_value	pointer
,	O
const	O
struct	O
influence_data	struct
*	O
base	pointer
,	O
Hash_data	struct
safety_hash	struct
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
territory_cache_position_number	int
==	O
position_number	int
&&	O
territory_cache_color	int
==	O
color	int
&&	O
territory_cache_influence_id	int
==	O
base	pointer
->	O
id	int
&&	O
delta_territory_cache	array
[	O
pos	int
]	O
!=	O
NOT_COMPUTED	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_HASHVALUES	O
;	O
i	int
++	O
)	O
if	O
(	O
delta_territory_cache_hash	array
[	O
pos	int
]	O
.	O
hashval	array
[	O
i	int
]	O
!=	O
safety_hash	struct
.	O
hashval	array
[	O
i	int
]	O
)	O
return	O
0	int
;	O
*	O
move_value	pointer
=	O
delta_territory_cache	array
[	O
pos	int
]	O
;	O
*	O
followup_value	pointer
=	O
followup_territory_cache	array
[	O
pos	int
]	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"%1m: retrieved territory value from cache: %f, %f\n"	pointer
,	O
pos	int
,	O
*	O
move_value	pointer
,	O
*	O
followup_value	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
store_delta_territory_cache	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
float	O
move_value	pointer
,	O
float	O
followup_value	pointer
,	O
const	O
struct	O
influence_data	struct
*	O
base	pointer
,	O
Hash_data	struct
safety_hash	struct
)	O
{	O
int	O
i	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
territory_cache_position_number	int
!=	O
position_number	int
||	O
territory_cache_color	int
!=	O
color	int
||	O
territory_cache_influence_id	int
!=	O
base	pointer
->	O
id	int
)	O
{	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
delta_territory_cache	array
[	O
ii	int
]	O
=	O
NOT_COMPUTED	O
;	O
territory_cache_position_number	int
=	O
position_number	int
;	O
territory_cache_influence_id	int
=	O
base	pointer
->	O
id	int
;	O
territory_cache_color	int
=	O
color	int
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"Cleared delta territory cache.\n"	pointer
)	O
;	O
}	O
delta_territory_cache	array
[	O
pos	int
]	O
=	O
move_value	pointer
;	O
followup_territory_cache	array
[	O
pos	int
]	O
=	O
followup_value	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NUM_HASHVALUES	O
;	O
i	int
++	O
)	O
delta_territory_cache_hash	array
[	O
pos	int
]	O
.	O
hashval	array
[	O
i	int
]	O
=	O
safety_hash	struct
.	O
hashval	array
[	O
i	int
]	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"%1m: Stored delta territory cache: %f, %f\n"	pointer
,	O
pos	int
,	O
move_value	pointer
,	O
followup_value	pointer
)	O
;	O
}	O
float	O
influence_delta_territory	function
(	O
const	O
struct	O
influence_data	struct
*	O
base	pointer
,	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
color	int
,	O
int	O
move	pointer
)	O
{	O
int	O
ii	int
;	O
float	O
total_delta	float
=	O
0.0	int
;	O
float	O
this_delta	float
;	O
ASSERT_ON_BOARD1	O
(	O
move	pointer
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
color	int
)	O
,	O
move	pointer
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
{	O
float	O
new_value	float
=	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
;	O
float	O
old_value	float
=	O
base	pointer
->	O
territory_value	array
[	O
ii	int
]	O
;	O
this_delta	float
=	O
new_value	float
-	O
old_value	float
;	O
if	O
(	O
color	int
==	O
BLACK	int
)	O
{	O
new_value	float
=	O
-	O
new_value	float
;	O
old_value	float
=	O
-	O
old_value	float
;	O
this_delta	float
=	O
-	O
this_delta	float
;	O
}	O
if	O
(	O
move	pointer
!=	O
-	O
1	int
&&	O
(	O
this_delta	float
>	O
0.02	int
||	O
-	O
this_delta	float
>	O
0.02	int
)	O
)	O
DEBUG	O
(	O
DEBUG_TERRITORY	int
,	O
"  %1m:   - %1m territory change %f (%f -> %f)\n"	pointer
,	O
move	pointer
,	O
ii	int
,	O
this_delta	float
,	O
old_value	float
,	O
new_value	float
)	O
;	O
total_delta	float
+=	O
this_delta	float
;	O
}	O
this_delta	float
=	O
q	pointer
->	O
captured	int
-	O
base	pointer
->	O
captured	int
;	O
if	O
(	O
color	int
==	O
BLACK	int
)	O
this_delta	float
=	O
-	O
this_delta	float
;	O
if	O
(	O
move	pointer
!=	O
-	O
1	int
&&	O
this_delta	float
!=	O
0.0	int
)	O
DEBUG	O
(	O
DEBUG_TERRITORY	int
,	O
"  %1m:   - captured stones %f\n"	pointer
,	O
move	pointer
,	O
this_delta	float
)	O
;	O
total_delta	float
+=	O
this_delta	float
;	O
return	O
total_delta	float
;	O
}	O
float	O
influence_score	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
int	O
use_chinese_rules	int
)	O
{	O
float	O
score	float
=	O
0.0	int
;	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
score	float
+=	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
;	O
if	O
(	O
use_chinese_rules	int
)	O
score	float
+=	O
stones_on_board	function
(	O
WHITE	int
)	O
-	O
stones_on_board	function
(	O
BLACK	int
)	O
+	O
komi	float
+	O
handicap	int
;	O
else	O
score	float
+=	O
black_captured	int
-	O
white_captured	int
+	O
komi	float
;	O
return	O
score	float
;	O
}	O
float	O
game_status	function
(	O
int	O
color	int
)	O
{	O
struct	O
influence_data	struct
*	O
iq	pointer
=	O
INITIAL_INFLUENCE	O
(	O
color	int
)	O
;	O
struct	O
influence_data	struct
*	O
oq	pointer
=	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
;	O
int	O
count	int
=	O
0	int
;	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
{	O
if	O
(	O
iq	pointer
->	O
safe	array
[	O
ii	int
]	O
)	O
count	int
+=	O
WEIGHT_TERRITORY	int
;	O
else	O
if	O
(	O
whose_territory	function
(	O
iq	pointer
,	O
ii	int
)	O
!=	O
EMPTY	int
&&	O
whose_territory	function
(	O
oq	pointer
,	O
ii	int
)	O
!=	O
EMPTY	int
)	O
count	int
+=	O
WEIGHT_TERRITORY	int
;	O
else	O
if	O
(	O
whose_moyo	function
(	O
oq	pointer
,	O
ii	int
)	O
!=	O
EMPTY	int
)	O
count	int
+=	O
WEIGHT_MOYO	int
;	O
else	O
if	O
(	O
whose_area	function
(	O
oq	pointer
,	O
ii	int
)	O
!=	O
EMPTY	int
)	O
count	int
+=	O
WEIGHT_AREA	int
;	O
}	O
return	O
(	O
float	O
)	O
count	int
/	O
(	O
WEIGHT_TERRITORY	int
*	O
board_size	int
*	O
board_size	int
)	O
;	O
}	O
void	O
debug_influence_move	function
(	O
int	O
move	pointer
)	O
{	O
debug_influence	int
=	O
move	pointer
;	O
}	O
void	O
get_influence	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
float	O
white_influence	array
[	O
BOARDMAX	O
]	O
,	O
float	O
black_influence	array
[	O
BOARDMAX	O
]	O
,	O
float	O
white_strength	array
[	O
BOARDMAX	O
]	O
,	O
float	O
black_strength	array
[	O
BOARDMAX	O
]	O
,	O
float	O
white_attenuation	array
[	O
BOARDMAX	O
]	O
,	O
float	O
black_attenuation	array
[	O
BOARDMAX	O
]	O
,	O
float	O
white_permeability	array
[	O
BOARDMAX	O
]	O
,	O
float	O
black_permeability	array
[	O
BOARDMAX	O
]	O
,	O
float	O
territory_value	array
[	O
BOARDMAX	O
]	O
,	O
int	O
influence_regions	array
[	O
BOARDMAX	O
]	O
,	O
int	O
non_territory	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
{	O
white_influence	array
[	O
ii	int
]	O
=	O
q	pointer
->	O
white_influence	array
[	O
ii	int
]	O
;	O
black_influence	array
[	O
ii	int
]	O
=	O
q	pointer
->	O
black_influence	array
[	O
ii	int
]	O
;	O
white_strength	array
[	O
ii	int
]	O
=	O
q	pointer
->	O
white_strength	array
[	O
ii	int
]	O
;	O
black_strength	array
[	O
ii	int
]	O
=	O
q	pointer
->	O
black_strength	array
[	O
ii	int
]	O
;	O
white_attenuation	array
[	O
ii	int
]	O
=	O
q	pointer
->	O
white_attenuation	array
[	O
ii	int
]	O
;	O
black_attenuation	array
[	O
ii	int
]	O
=	O
q	pointer
->	O
black_attenuation	array
[	O
ii	int
]	O
;	O
white_permeability	array
[	O
ii	int
]	O
=	O
q	pointer
->	O
white_permeability	array
[	O
ii	int
]	O
;	O
black_permeability	array
[	O
ii	int
]	O
=	O
q	pointer
->	O
black_permeability	array
[	O
ii	int
]	O
;	O
territory_value	array
[	O
ii	int
]	O
=	O
q	pointer
->	O
territory_value	array
[	O
ii	int
]	O
;	O
non_territory	array
[	O
ii	int
]	O
=	O
q	pointer
->	O
non_territory	array
[	O
ii	int
]	O
;	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
whose_territory	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
WHITE	int
)	O
influence_regions	array
[	O
ii	int
]	O
=	O
3	int
;	O
else	O
if	O
(	O
whose_territory	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
BLACK	int
)	O
influence_regions	array
[	O
ii	int
]	O
=	O
-	O
3	int
;	O
else	O
if	O
(	O
whose_moyo	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
WHITE	int
)	O
influence_regions	array
[	O
ii	int
]	O
=	O
2	int
;	O
else	O
if	O
(	O
whose_moyo	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
BLACK	int
)	O
influence_regions	array
[	O
ii	int
]	O
=	O
-	O
2	int
;	O
else	O
if	O
(	O
whose_area	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
WHITE	int
)	O
influence_regions	array
[	O
ii	int
]	O
=	O
1	int
;	O
else	O
if	O
(	O
whose_area	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
BLACK	int
)	O
influence_regions	array
[	O
ii	int
]	O
=	O
-	O
1	int
;	O
else	O
influence_regions	array
[	O
ii	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
WHITE	int
)	O
influence_regions	array
[	O
ii	int
]	O
=	O
4	int
;	O
else	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
BLACK	int
)	O
influence_regions	array
[	O
ii	int
]	O
=	O
-	O
4	int
;	O
}	O
}	O
void	O
print_influence	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
const	O
char	O
*	O
info_string	pointer
)	O
{	O
if	O
(	O
printmoyo	int
&	O
PRINTMOYO_ATTENUATION	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"white attenuation (%s):\n"	pointer
,	O
info_string	pointer
)	O
;	O
print_numeric_influence	function
(	O
q	pointer
,	O
q	pointer
->	O
white_attenuation	array
,	O
"%3.2f"	pointer
,	O
3	int
,	O
0	int
,	O
0	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"black attenuation (%s):\n"	pointer
,	O
info_string	pointer
)	O
;	O
print_numeric_influence	function
(	O
q	pointer
,	O
q	pointer
->	O
black_attenuation	array
,	O
"%3.2f"	pointer
,	O
3	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
printmoyo	int
&	O
PRINTMOYO_PERMEABILITY	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"white permeability:\n"	pointer
)	O
;	O
print_numeric_influence	function
(	O
q	pointer
,	O
q	pointer
->	O
white_permeability	array
,	O
"%3.1f"	pointer
,	O
3	int
,	O
0	int
,	O
0	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"black permeability:\n"	pointer
)	O
;	O
print_numeric_influence	function
(	O
q	pointer
,	O
q	pointer
->	O
black_permeability	array
,	O
"%3.1f"	pointer
,	O
3	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
printmoyo	int
&	O
PRINTMOYO_STRENGTH	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"white strength:\n"	pointer
)	O
;	O
if	O
(	O
q	pointer
->	O
is_territorial_influence	int
)	O
print_numeric_influence	function
(	O
q	pointer
,	O
q	pointer
->	O
white_strength	array
,	O
"%5.1f"	pointer
,	O
5	int
,	O
0	int
,	O
0	int
)	O
;	O
else	O
print_numeric_influence	function
(	O
q	pointer
,	O
q	pointer
->	O
white_strength	array
,	O
"%3.0f"	pointer
,	O
3	int
,	O
0	int
,	O
1	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"black strength:\n"	pointer
)	O
;	O
if	O
(	O
q	pointer
->	O
is_territorial_influence	int
)	O
print_numeric_influence	function
(	O
q	pointer
,	O
q	pointer
->	O
black_strength	array
,	O
"%5.1f"	pointer
,	O
5	int
,	O
0	int
,	O
0	int
)	O
;	O
else	O
print_numeric_influence	function
(	O
q	pointer
,	O
q	pointer
->	O
black_strength	array
,	O
"%3.0f"	pointer
,	O
3	int
,	O
0	int
,	O
1	int
)	O
;	O
}	O
if	O
(	O
printmoyo	int
&	O
PRINTMOYO_NUMERIC_INFLUENCE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"white influence (%s):\n"	pointer
,	O
info_string	pointer
)	O
;	O
print_numeric_influence	function
(	O
q	pointer
,	O
q	pointer
->	O
white_influence	array
,	O
"%5.1f"	pointer
,	O
5	int
,	O
1	int
,	O
0	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"black influence (%s):\n"	pointer
,	O
info_string	pointer
)	O
;	O
print_numeric_influence	function
(	O
q	pointer
,	O
q	pointer
->	O
black_influence	array
,	O
"%5.1f"	pointer
,	O
5	int
,	O
1	int
,	O
0	int
)	O
;	O
}	O
if	O
(	O
printmoyo	int
&	O
PRINTMOYO_PRINT_INFLUENCE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"influence regions (%s):\n"	pointer
,	O
info_string	pointer
)	O
;	O
print_influence_areas	function
(	O
q	pointer
)	O
;	O
}	O
if	O
(	O
printmoyo	int
&	O
PRINTMOYO_VALUE_TERRITORY	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"territory (%s)"	pointer
,	O
info_string	pointer
)	O
;	O
print_numeric_influence	function
(	O
q	pointer
,	O
q	pointer
->	O
territory_value	array
,	O
"%5.2f"	pointer
,	O
5	int
,	O
1	int
,	O
0	int
)	O
;	O
}	O
}	O
static	O
void	O
print_numeric_influence	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
,	O
const	O
float	O
values	array
[	O
BOARDMAX	O
]	O
,	O
const	O
char	O
*	O
format	pointer
,	O
int	O
width	int
,	O
int	O
draw_stones	int
,	O
int	O
mark_epsilon	int
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
ch	char
;	O
char	O
format_stone	array
[	O
20	int
]	O
;	O
memset	function
(	O
format_stone	array
,	O
' '	O
,	O
20	int
)	O
;	O
format_stone	array
[	O
(	O
width	int
+	O
1	int
)	O
/	O
2	int
]	O
=	O
'%'	O
;	O
format_stone	array
[	O
(	O
width	int
+	O
3	int
)	O
/	O
2	int
]	O
=	O
'c'	O
;	O
format_stone	array
[	O
width	int
+	O
2	int
]	O
=	O
0	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"   "	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
ch	char
=	O
'A'	O
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
,	O
ch	char
++	O
)	O
{	O
if	O
(	O
ch	char
==	O
'I'	O
)	O
ch	char
++	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
format_stone	array
,	O
ch	char
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
int	O
ii	int
=	O
board_size	int
-	O
i	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%2d "	pointer
,	O
ii	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
int	O
ii	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
draw_stones	int
&&	O
q	pointer
->	O
safe	array
[	O
ii	int
]	O
)	O
{	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
WHITE	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
format_stone	array
,	O
'O'	O
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
format_stone	array
,	O
'X'	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
mark_epsilon	int
&&	O
values	array
[	O
ii	int
]	O
>	O
0.0	int
&&	O
values	array
[	O
ii	int
]	O
<	O
1.0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"eps"	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
format	pointer
,	O
values	array
[	O
ii	int
]	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
" "	pointer
)	O
;	O
}	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"%2d\n"	pointer
,	O
ii	int
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"   "	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
ch	char
=	O
'A'	O
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
,	O
ch	char
++	O
)	O
{	O
if	O
(	O
ch	char
==	O
'I'	O
)	O
ch	char
++	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
format_stone	array
,	O
ch	char
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
print_influence_areas	function
(	O
const	O
struct	O
influence_data	struct
*	O
q	pointer
)	O
{	O
int	O
ii	int
;	O
start_draw_board	function
(	O
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
{	O
int	O
c	char
=	O
EMPTY	int
;	O
int	O
color	int
=	O
GG_COLOR_BLACK	int
;	O
if	O
(	O
q	pointer
->	O
safe	array
[	O
ii	int
]	O
)	O
{	O
color	int
=	O
GG_COLOR_BLACK	int
;	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
WHITE	int
)	O
c	char
=	O
'O'	O
;	O
else	O
c	char
=	O
'X'	O
;	O
}	O
else	O
if	O
(	O
whose_territory	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
WHITE	int
)	O
{	O
c	char
=	O
'o'	O
;	O
color	int
=	O
GG_COLOR_CYAN	int
;	O
}	O
else	O
if	O
(	O
whose_territory	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
BLACK	int
)	O
{	O
c	char
=	O
'x'	O
;	O
color	int
=	O
GG_COLOR_CYAN	int
;	O
}	O
else	O
if	O
(	O
whose_moyo	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
WHITE	int
)	O
{	O
c	char
=	O
'o'	O
;	O
color	int
=	O
GG_COLOR_YELLOW	int
;	O
}	O
else	O
if	O
(	O
whose_moyo	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
BLACK	int
)	O
{	O
c	char
=	O
'x'	O
;	O
color	int
=	O
GG_COLOR_YELLOW	int
;	O
}	O
else	O
if	O
(	O
whose_area	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
WHITE	int
)	O
{	O
c	char
=	O
'o'	O
;	O
color	int
=	O
GG_COLOR_RED	int
;	O
}	O
else	O
if	O
(	O
whose_area	function
(	O
q	pointer
,	O
ii	int
)	O
==	O
BLACK	int
)	O
{	O
c	char
=	O
'x'	O
;	O
color	int
=	O
GG_COLOR_RED	int
;	O
}	O
draw_color_char	function
(	O
I	O
(	O
ii	int
)	O
,	O
J	O
(	O
ii	int
)	O
,	O
c	char
,	O
color	int
)	O
;	O
}	O
end_draw_board	function
(	O
)	O
;	O
}	O
