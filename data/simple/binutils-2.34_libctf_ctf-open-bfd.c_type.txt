static	O
struct	O
ctf_archive_internal	struct
*	O
ctf_new_archive_internal	function
(	O
int	O
is_archive	int
,	O
struct	O
ctf_archive	struct
*	O
arc	pointer
,	O
ctf_file_t	struct
*	O
fp	pointer
,	O
const	O
ctf_sect_t	struct
*	O
symsect	pointer
,	O
const	O
ctf_sect_t	struct
*	O
strsect	pointer
,	O
int	O
*	O
errp	pointer
)	O
{	O
struct	O
ctf_archive_internal	struct
*	O
arci	pointer
;	O
if	O
(	O
(	O
arci	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
ctf_archive_internal	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
is_archive	int
)	O
ctf_arc_close_internal	function
(	O
arc	pointer
)	O
;	O
else	O
ctf_file_close	function
(	O
fp	pointer
)	O
;	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
errno	O
)	O
)	O
;	O
}	O
arci	pointer
->	O
ctfi_is_archive	int
=	O
is_archive	int
;	O
if	O
(	O
is_archive	int
)	O
arci	pointer
->	O
ctfi_archive	pointer
=	O
arc	pointer
;	O
else	O
arci	pointer
->	O
ctfi_file	pointer
=	O
fp	pointer
;	O
if	O
(	O
symsect	pointer
)	O
memcpy	function
(	O
&	O
arci	pointer
->	O
ctfi_symsect	struct
,	O
symsect	pointer
,	O
sizeof	O
(	O
struct	O
ctf_sect	struct
)	O
)	O
;	O
if	O
(	O
strsect	pointer
)	O
memcpy	function
(	O
&	O
arci	pointer
->	O
ctfi_strsect	struct
,	O
strsect	pointer
,	O
sizeof	O
(	O
struct	O
ctf_sect	struct
)	O
)	O
;	O
return	O
arci	pointer
;	O
}	O
static	O
void	O
ctf_bfdclose	function
(	O
struct	O
ctf_archive_internal	struct
*	O
arci	pointer
)	O
{	O
if	O
(	O
arci	pointer
->	O
ctfi_abfd	pointer
!=	O
NULL	O
)	O
if	O
(	O
!	O
bfd_close_all_done	function
(	O
arci	pointer
->	O
ctfi_abfd	pointer
)	O
)	O
ctf_dprintf	function
(	O
"Cannot close BFD: %s\n"	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
}	O
ctf_archive_t	struct
*	O
ctf_bfdopen	function
(	O
struct	O
bfd	struct
*	O
abfd	pointer
,	O
int	O
*	O
errp	pointer
)	O
{	O
ctf_archive_t	struct
*	O
arc	pointer
;	O
asection	struct
*	O
ctf_asect	pointer
;	O
bfd_byte	char
*	O
contents	pointer
;	O
ctf_sect_t	struct
ctfsect	struct
;	O
libctf_init_debug	function
(	O
)	O
;	O
if	O
(	O
(	O
ctf_asect	pointer
=	O
bfd_get_section_by_name	function
(	O
abfd	pointer
,	O
_CTF_SECTION	array
)	O
)	O
==	O
NULL	O
)	O
{	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_NOCTFDATA	int
)	O
)	O
;	O
}	O
if	O
(	O
!	O
bfd_malloc_and_get_section	function
(	O
abfd	pointer
,	O
ctf_asect	pointer
,	O
&	O
contents	pointer
)	O
)	O
{	O
ctf_dprintf	function
(	O
"ctf_bfdopen(): cannot malloc CTF section: %s\n"	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_FMT	int
)	O
)	O
;	O
}	O
ctfsect	struct
.	O
cts_name	pointer
=	O
_CTF_SECTION	array
;	O
ctfsect	struct
.	O
cts_entsize	long
=	O
1	int
;	O
ctfsect	struct
.	O
cts_size	long
=	O
bfd_section_size	function
(	O
ctf_asect	pointer
)	O
;	O
ctfsect	struct
.	O
cts_data	pointer
=	O
contents	pointer
;	O
if	O
(	O
(	O
arc	pointer
=	O
ctf_bfdopen_ctfsect	function
(	O
abfd	pointer
,	O
&	O
ctfsect	struct
,	O
errp	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
arc	pointer
->	O
ctfi_data	pointer
=	O
(	O
void	O
*	O
)	O
ctfsect	struct
.	O
cts_data	pointer
;	O
return	O
arc	pointer
;	O
}	O
free	function
(	O
contents	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
ctf_archive_t	struct
*	O
ctf_bfdopen_ctfsect	function
(	O
struct	O
bfd	struct
*	O
abfd	pointer
_libctf_unused_	O
,	O
const	O
ctf_sect_t	struct
*	O
ctfsect	struct
,	O
int	O
*	O
errp	pointer
)	O
{	O
struct	O
ctf_archive	struct
*	O
arc	pointer
=	O
NULL	O
;	O
ctf_archive_t	struct
*	O
arci	pointer
;	O
ctf_file_t	struct
*	O
fp	pointer
=	O
NULL	O
;	O
ctf_sect_t	struct
*	O
symsectp	pointer
=	O
NULL	O
;	O
ctf_sect_t	struct
*	O
strsectp	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
bfderrstr	pointer
=	O
NULL	O
;	O
int	O
is_archive	int
;	O
ctf_sect_t	struct
symsect	pointer
,	O
strsect	pointer
;	O
Elf_Internal_Shdr	struct
*	O
strhdr	pointer
;	O
Elf_Internal_Shdr	struct
*	O
symhdr	pointer
=	O
&	O
elf_symtab_hdr	O
(	O
abfd	pointer
)	O
;	O
size_t	long
symcount	int
=	O
symhdr	pointer
->	O
sh_size	array
/	O
symhdr	pointer
->	O
sh_entsize	array
;	O
Elf_Internal_Sym	struct
*	O
isymbuf	pointer
;	O
bfd_byte	char
*	O
symtab	pointer
;	O
const	O
char	O
*	O
strtab	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
symtab	pointer
=	O
malloc	function
(	O
symhdr	pointer
->	O
sh_size	array
)	O
)	O
==	O
NULL	O
)	O
{	O
bfderrstr	pointer
=	O
"Cannot malloc symbol table"	pointer
;	O
goto	O
err	long
;	O
}	O
isymbuf	pointer
=	O
bfd_elf_get_elf_syms	function
(	O
abfd	pointer
,	O
symhdr	pointer
,	O
symcount	int
,	O
0	int
,	O
NULL	O
,	O
symtab	pointer
,	O
NULL	O
)	O
;	O
free	function
(	O
isymbuf	pointer
)	O
;	O
if	O
(	O
isymbuf	pointer
==	O
NULL	O
)	O
{	O
bfderrstr	pointer
=	O
"Cannot read symbol table"	pointer
;	O
goto	O
err_free_sym	O
;	O
}	O
if	O
(	O
elf_elfsections	O
(	O
abfd	pointer
)	O
!=	O
NULL	O
&&	O
symhdr	pointer
->	O
sh_link	array
<	O
elf_numsections	O
(	O
abfd	pointer
)	O
)	O
{	O
strhdr	pointer
=	O
elf_elfsections	O
(	O
abfd	pointer
)	O
[	O
symhdr	pointer
->	O
sh_link	array
]	O
;	O
if	O
(	O
strhdr	pointer
->	O
contents	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
(	O
strtab	pointer
=	O
bfd_elf_get_str_section	function
(	O
abfd	pointer
,	O
symhdr	pointer
->	O
sh_link	array
)	O
)	O
==	O
NULL	O
)	O
{	O
bfderrstr	pointer
=	O
"Cannot read string table"	pointer
;	O
goto	O
err_free_sym	O
;	O
}	O
}	O
else	O
strtab	pointer
=	O
(	O
const	O
char	O
*	O
)	O
strhdr	pointer
->	O
contents	pointer
;	O
}	O
if	O
(	O
strtab	pointer
)	O
{	O
strsect	pointer
.	O
cts_data	pointer
=	O
strtab	pointer
;	O
strsect	pointer
.	O
cts_name	pointer
=	O
".strtab"	pointer
;	O
strsect	pointer
.	O
cts_size	long
=	O
strhdr	pointer
->	O
sh_size	array
;	O
strsectp	pointer
=	O
&	O
strsect	pointer
;	O
assert	O
(	O
symhdr	pointer
->	O
sh_entsize	array
==	O
get_elf_backend_data	O
(	O
abfd	pointer
)	O
->	O
s	pointer
->	O
sizeof_sym	char
)	O
;	O
symsect	pointer
.	O
cts_name	pointer
=	O
".symtab"	pointer
;	O
symsect	pointer
.	O
cts_entsize	long
=	O
symhdr	pointer
->	O
sh_entsize	array
;	O
symsect	pointer
.	O
cts_size	long
=	O
symhdr	pointer
->	O
sh_size	array
;	O
symsect	pointer
.	O
cts_data	pointer
=	O
symtab	pointer
;	O
symsectp	pointer
=	O
&	O
symsect	pointer
;	O
}	O
if	O
(	O
ctfsect	struct
->	O
cts_size	long
>	O
sizeof	O
(	O
uint64_t	long
)	O
&&	O
(	O
(	O
*	O
(	O
uint64_t	long
*	O
)	O
ctfsect	struct
->	O
cts_data	pointer
)	O
==	O
CTFA_MAGIC	int
)	O
)	O
{	O
is_archive	int
=	O
1	int
;	O
if	O
(	O
(	O
arc	pointer
=	O
ctf_arc_bufopen	function
(	O
(	O
void	O
*	O
)	O
ctfsect	struct
->	O
cts_data	pointer
,	O
ctfsect	struct
->	O
cts_size	long
,	O
errp	pointer
)	O
)	O
==	O
NULL	O
)	O
goto	O
err_free_str	O
;	O
}	O
else	O
{	O
is_archive	int
=	O
0	int
;	O
if	O
(	O
(	O
fp	pointer
=	O
ctf_bufopen	function
(	O
ctfsect	struct
,	O
symsectp	pointer
,	O
strsectp	pointer
,	O
errp	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
ctf_dprintf	function
(	O
"ctf_internal_open(): cannot open CTF: %s\n"	pointer
,	O
ctf_errmsg	function
(	O
*	O
errp	pointer
)	O
)	O
;	O
goto	O
err_free_str	O
;	O
}	O
}	O
arci	pointer
=	O
ctf_new_archive_internal	function
(	O
is_archive	int
,	O
arc	pointer
,	O
fp	pointer
,	O
symsectp	pointer
,	O
strsectp	pointer
,	O
errp	pointer
)	O
;	O
if	O
(	O
arci	pointer
)	O
return	O
arci	pointer
;	O
err_free_str	O
:	O
;	O
err_free_sym	O
:	O
free	function
(	O
symtab	pointer
)	O
;	O
err	long
:	O
_libctf_unused_	O
;	O
if	O
(	O
bfderrstr	pointer
)	O
{	O
ctf_dprintf	function
(	O
"ctf_bfdopen(): %s: %s\n"	pointer
,	O
bfderrstr	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_FMT	int
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
ctf_archive_t	struct
*	O
ctf_fdopen	function
(	O
int	O
fd	int
,	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
target	pointer
,	O
int	O
*	O
errp	pointer
)	O
{	O
ctf_archive_t	struct
*	O
arci	pointer
;	O
bfd	struct
*	O
abfd	pointer
;	O
int	O
nfd	int
;	O
struct	O
stat	struct
st	struct
;	O
ssize_t	long
nbytes	long
;	O
ctf_preamble_t	struct
ctfhdr	struct
;	O
uint64_t	long
arc_magic	long
;	O
memset	function
(	O
&	O
ctfhdr	struct
,	O
0	int
,	O
sizeof	O
(	O
ctfhdr	struct
)	O
)	O
;	O
libctf_init_debug	function
(	O
)	O
;	O
if	O
(	O
fstat	function
(	O
fd	int
,	O
&	O
st	struct
)	O
==	O
-	O
1	int
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
errno	O
)	O
)	O
;	O
if	O
(	O
(	O
nbytes	long
=	O
ctf_pread	function
(	O
fd	int
,	O
&	O
ctfhdr	struct
,	O
sizeof	O
(	O
ctfhdr	struct
)	O
,	O
0	int
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
nbytes	long
<	O
0	int
?	O
errno	O
:	O
ECTF_FMT	int
)	O
)	O
;	O
if	O
(	O
(	O
size_t	long
)	O
nbytes	long
>=	O
sizeof	O
(	O
ctf_preamble_t	struct
)	O
&&	O
(	O
ctfhdr	struct
.	O
ctp_magic	short
==	O
CTF_MAGIC	int
||	O
ctfhdr	struct
.	O
ctp_magic	short
==	O
bswap_16	O
(	O
CTF_MAGIC	int
)	O
)	O
)	O
{	O
ctf_file_t	struct
*	O
fp	pointer
=	O
NULL	O
;	O
void	O
*	O
data	pointer
;	O
if	O
(	O
(	O
data	pointer
=	O
ctf_mmap	function
(	O
st	struct
.	O
st_size	array
,	O
0	int
,	O
fd	int
)	O
)	O
==	O
NULL	O
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
errno	O
)	O
)	O
;	O
if	O
(	O
(	O
fp	pointer
=	O
ctf_simple_open	function
(	O
data	pointer
,	O
(	O
size_t	long
)	O
st	struct
.	O
st_size	array
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
errp	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
ctf_munmap	function
(	O
data	pointer
,	O
(	O
size_t	long
)	O
st	struct
.	O
st_size	array
)	O
;	O
return	O
NULL	O
;	O
}	O
fp	pointer
->	O
ctf_data_mmapped	pointer
=	O
data	pointer
;	O
fp	pointer
->	O
ctf_data_mmapped_len	long
=	O
(	O
size_t	long
)	O
st	struct
.	O
st_size	array
;	O
return	O
ctf_new_archive_internal	function
(	O
0	int
,	O
NULL	O
,	O
fp	pointer
,	O
NULL	O
,	O
NULL	O
,	O
errp	pointer
)	O
;	O
}	O
if	O
(	O
(	O
nbytes	long
=	O
ctf_pread	function
(	O
fd	int
,	O
&	O
arc_magic	long
,	O
sizeof	O
(	O
arc_magic	long
)	O
,	O
0	int
)	O
)	O
<=	O
0	int
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
nbytes	long
<	O
0	int
?	O
errno	O
:	O
ECTF_FMT	int
)	O
)	O
;	O
if	O
(	O
(	O
size_t	long
)	O
nbytes	long
>=	O
sizeof	O
(	O
uint64_t	long
)	O
&&	O
le64toh	O
(	O
arc_magic	long
)	O
==	O
CTFA_MAGIC	int
)	O
{	O
struct	O
ctf_archive	struct
*	O
arc	pointer
;	O
if	O
(	O
(	O
arc	pointer
=	O
ctf_arc_open_internal	function
(	O
filename	pointer
,	O
errp	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
NULL	O
;	O
return	O
ctf_new_archive_internal	function
(	O
1	int
,	O
arc	pointer
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
errp	pointer
)	O
;	O
}	O
if	O
(	O
(	O
nfd	int
=	O
dup	function
(	O
fd	int
)	O
)	O
<	O
0	int
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
errno	O
)	O
)	O
;	O
if	O
(	O
(	O
abfd	pointer
=	O
bfd_fdopenr	function
(	O
filename	pointer
,	O
target	pointer
,	O
nfd	int
)	O
)	O
==	O
NULL	O
)	O
{	O
ctf_dprintf	function
(	O
"Cannot open BFD from %s: %s\n"	pointer
,	O
filename	pointer
?	O
filename	pointer
:	O
"(unknown file)"	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_FMT	int
)	O
)	O
;	O
}	O
bfd_set_cacheable	function
(	O
abfd	pointer
,	O
1	int
)	O
;	O
if	O
(	O
!	O
bfd_check_format	function
(	O
abfd	pointer
,	O
bfd_object	int
)	O
)	O
{	O
ctf_dprintf	function
(	O
"BFD format problem in %s: %s\n"	pointer
,	O
filename	pointer
?	O
filename	pointer
:	O
"(unknown file)"	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
if	O
(	O
bfd_get_error	function
(	O
)	O
==	O
bfd_error_file_ambiguously_recognized	int
)	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_BFD_AMBIGUOUS	int
)	O
)	O
;	O
else	O
return	O
(	O
ctf_set_open_errno	function
(	O
errp	pointer
,	O
ECTF_FMT	int
)	O
)	O
;	O
}	O
if	O
(	O
(	O
arci	pointer
=	O
ctf_bfdopen	function
(	O
abfd	pointer
,	O
errp	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
bfd_close_all_done	function
(	O
abfd	pointer
)	O
)	O
ctf_dprintf	function
(	O
"Cannot close BFD: %s\n"	pointer
,	O
bfd_errmsg	function
(	O
bfd_get_error	function
(	O
)	O
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
arci	pointer
->	O
ctfi_bfd_close	pointer
=	O
ctf_bfdclose	function
;	O
arci	pointer
->	O
ctfi_abfd	pointer
=	O
abfd	pointer
;	O
return	O
arci	pointer
;	O
}	O
ctf_archive_t	struct
*	O
ctf_open	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
target	pointer
,	O
int	O
*	O
errp	pointer
)	O
{	O
ctf_archive_t	struct
*	O
arc	pointer
;	O
int	O
fd	int
;	O
if	O
(	O
(	O
fd	int
=	O
open	function
(	O
filename	pointer
,	O
O_RDONLY	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errp	pointer
!=	O
NULL	O
)	O
*	O
errp	pointer
=	O
errno	O
;	O
return	O
NULL	O
;	O
}	O
arc	pointer
=	O
ctf_fdopen	function
(	O
fd	int
,	O
filename	pointer
,	O
target	pointer
,	O
errp	pointer
)	O
;	O
(	O
void	O
)	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
arc	pointer
;	O
}	O
ctf_archive_t	struct
*	O
ctf_arc_open	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
int	O
*	O
errp	pointer
)	O
{	O
return	O
ctf_open	function
(	O
filename	pointer
,	O
NULL	O
,	O
errp	pointer
)	O
;	O
}	O
