typedef	O
enum	O
{	O
tNONE	int
,	O
tEOF	int
,	O
tSTRING	int
,	O
tFORMFEED	int
,	O
tNEWLINE	int
,	O
tCARRIAGE_RETURN	int
,	O
tWRAPPED_NEWLINE	int
,	O
tEPSF	int
,	O
tSETFILENAME	int
,	O
tSETPAGENUMBER	int
,	O
tNEWPAGE	int
,	O
tFONT	int
,	O
tCOLOR	int
,	O
tBGCOLOR	int
,	O
tSAVEX	int
,	O
tLOADX	int
,	O
tPS	int
}	O
TokenType	enum
;	O
typedef	O
enum	O
{	O
ESC_COMMENT	int
,	O
ESC_EPSF	int
,	O
ESC_FONT	int
,	O
ESC_COLOR	int
,	O
ESC_BGCOLOR	int
,	O
ESC_NEWPAGE	int
,	O
ESC_SETFILENAME	int
,	O
ESC_SETPAGENUMBER	int
,	O
ESC_SHADE	int
,	O
ESC_BGGRAY	int
,	O
ESC_ESCAPE	int
,	O
ESC_SAVEX	int
,	O
ESC_LOADX	int
,	O
ESC_PS	int
}	O
SpecialEscape	enum
;	O
struct	O
gs_token_st	struct
{	O
TokenType	enum
type	int
;	O
unsigned	O
int	O
flags	int
;	O
double	O
new_x	double
;	O
double	O
new_y	double
;	O
int	O
new_col	int
;	O
union	O
{	O
int	O
i	int
;	O
char	O
*	O
str	pointer
;	O
struct	O
{	O
double	O
x	double
;	O
double	O
y	double
;	O
double	O
w	int
;	O
double	O
h	int
;	O
double	O
xscale	double
;	O
double	O
yscale	double
;	O
int	O
llx	double
,	O
lly	double
,	O
urx	double
,	O
ury	double
;	O
char	O
filename	pointer
[	O
PATH_MAX	int
]	O
;	O
char	O
*	O
skipbuf	pointer
;	O
unsigned	O
int	O
skipbuf_len	int
;	O
unsigned	O
int	O
skipbuf_pos	int
;	O
FILE	struct
*	O
fp	pointer
;	O
int	O
pipe	function
;	O
}	O
epsf	struct
;	O
Color	struct
color	struct
;	O
Color	struct
bgcolor	struct
;	O
struct	O
{	O
char	O
name	pointer
[	O
PATH_MAX	int
]	O
;	O
FontPoint	struct
size	long
;	O
InputEncoding	enum
encoding	array
;	O
}	O
font	pointer
;	O
char	O
filename	pointer
[	O
PATH_MAX	int
]	O
;	O
}	O
u	union
;	O
}	O
;	O
typedef	O
struct	O
gs_token_st	struct
Token	struct
;	O
static	O
void	O
get_next_token	function
___P	O
(	O
(	O
InputStream	struct
*	O
is	pointer
,	O
double	O
linestart	double
,	O
double	O
linepos	double
,	O
unsigned	O
int	O
col	int
,	O
double	O
linew	double
,	O
Token	struct
*	O
token	pointer
)	O
)	O
;	O
static	O
void	O
dump_ps_page_header	function
___P	O
(	O
(	O
char	O
*	O
fname	pointer
,	O
int	O
empty	int
)	O
)	O
;	O
static	O
void	O
dump_ps_page_trailer	function
(	O
)	O
;	O
static	O
void	O
dump_empty_page	function
(	O
)	O
;	O
static	O
int	O
recognize_eps_file	function
___P	O
(	O
(	O
Token	struct
*	O
token	pointer
)	O
)	O
;	O
static	O
void	O
paste_epsf	function
___P	O
(	O
(	O
Token	struct
*	O
token	pointer
)	O
)	O
;	O
static	O
int	O
do_pass_through	function
___P	O
(	O
(	O
char	O
*	O
fname	pointer
,	O
InputStream	struct
*	O
is	pointer
)	O
)	O
;	O
static	O
double	O
read_float	function
___P	O
(	O
(	O
InputStream	struct
*	O
is	pointer
,	O
int	O
units	int
,	O
int	O
horizontal	int
)	O
)	O
;	O
static	O
void	O
print_line_number	function
___P	O
(	O
(	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
space	double
,	O
double	O
margin	double
,	O
unsigned	O
int	O
linenum	int
)	O
)	O
;	O
static	O
void	O
divert	function
(	O
)	O
;	O
static	O
void	O
undivert	function
(	O
)	O
;	O
static	O
void	O
handle_two_side_options	function
(	O
)	O
;	O
unsigned	O
int	O
current_pagenum	int
=	O
0	int
;	O
unsigned	O
int	O
total_pages_in_file	int
;	O
unsigned	O
int	O
input_filenum	int
=	O
0	int
;	O
unsigned	O
int	O
current_file_linenum	int
;	O
int	O
first_pagenum_for_file	int
;	O
char	O
*	O
fname	pointer
=	O
NULL	O
;	O
static	O
int	O
ps_header_dumped	int
=	O
0	int
;	O
static	O
FILE	struct
*	O
divertfp	pointer
=	O
NULL	O
;	O
static	O
FILE	struct
*	O
cofp	pointer
=	O
NULL	O
;	O
static	O
int	O
do_print	int
=	O
1	int
;	O
static	O
int	O
user_fontp	int
=	O
0	int
;	O
static	O
char	O
user_font_name	array
[	O
PATH_MAX	int
]	O
;	O
static	O
FontPoint	struct
user_font_pt	struct
;	O
static	O
InputEncoding	enum
user_font_encoding	enum
;	O
static	O
int	O
user_colorp	int
=	O
0	int
;	O
static	O
Color	struct
user_color	struct
;	O
static	O
int	O
user_bgcolorp	int
=	O
0	int
;	O
static	O
Color	struct
user_bgcolor	struct
;	O
static	O
unsigned	O
int	O
print_line_number_last	int
;	O
static	O
double	O
xstore	array
[	O
256	int
]	O
;	O
void	O
dump_ps_header	function
(	O
)	O
{	O
char	O
*	O
cp	pointer
,	O
*	O
cp2	pointer
;	O
int	O
i	int
,	O
j	int
,	O
got	int
;	O
char	O
*	O
ps_version_string	pointer
;	O
if	O
(	O
ps_header_dumped	int
)	O
return	O
;	O
ps_header_dumped	int
=	O
1	int
;	O
ps_version_string	pointer
=	O
xstrdup	function
(	O
VERSION	pointer
)	O
;	O
cp	pointer
=	O
strrchr	function
(	O
ps_version_string	pointer
,	O
'.'	O
)	O
;	O
*	O
cp	pointer
=	O
' '	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%s\n"	pointer
,	O
output_first_line	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%BoundingBox: %d %d %d %d\n"	pointer
,	O
media	pointer
->	O
llx	double
,	O
media	pointer
->	O
lly	double
,	O
media	pointer
->	O
urx	double
,	O
media	pointer
->	O
ury	double
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%Title: %s\n"	pointer
,	O
title	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%For: %s\n"	pointer
,	O
passwd	struct
->	O
pw_gecos	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%Creator: %s\n"	pointer
,	O
PACKAGE_STRING	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%CreationDate: %s\n"	pointer
,	O
date_string	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%Orientation: %s\n"	pointer
,	O
(	O
(	O
nup	int
>	O
1	int
)	O
&&	O
nup_landscape	int
)	O
||	O
(	O
(	O
nup	int
==	O
1	int
)	O
&&	O
landscape	int
)	O
?	O
"Landscape"	pointer
:	O
"Portrait"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%Pages: (atend)\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%DocumentMedia: %s %d %d 0 () ()\n"	pointer
,	O
media	pointer
->	O
name	pointer
,	O
media	pointer
->	O
w	int
,	O
media	pointer
->	O
h	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%DocumentNeededResources: (atend)\n"	pointer
)	O
)	O
;	O
if	O
(	O
count_key_value_set	function
(	O
pagedevice	pointer
)	O
>	O
0	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%LanguageLevel: 2\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%EndComments\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%BeginProlog\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%BeginResource: procset Enscript-Prolog %s\n"	pointer
,	O
ps_version_string	pointer
)	O
)	O
;	O
if	O
(	O
!	O
paste_file	function
(	O
"enscript"	pointer
,	O
".pro"	pointer
)	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't find prolog \"%s\": %s\n"	pointer
)	O
,	O
"enscript.pro"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%EndResource\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%BeginResource: procset Enscript-Encoding-%s %s\n"	pointer
,	O
encoding_name	pointer
,	O
ps_version_string	pointer
)	O
)	O
;	O
if	O
(	O
!	O
paste_file	function
(	O
encoding_name	pointer
,	O
".enc"	pointer
)	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't find encoding file \"%s.enc\": %s\n"	pointer
)	O
,	O
encoding_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%EndResource\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%EndProlog\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%BeginSetup\n"	pointer
)	O
)	O
;	O
for	O
(	O
got	int
=	O
strhash_get_first	function
(	O
download_fonts	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
;	O
got	int
;	O
got	int
=	O
strhash_get_next	function
(	O
download_fonts	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
)	O
download_font	function
(	O
cp	pointer
)	O
;	O
for	O
(	O
got	int
=	O
strhash_get_first	function
(	O
res_fonts	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
;	O
got	int
;	O
got	int
=	O
strhash_get_next	function
(	O
res_fonts	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%IncludeResource: font %s\n"	pointer
,	O
cp	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/HFpt_w %g def\n"	pointer
,	O
HFpt	struct
.	O
w	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/HFpt_h %g def\n"	pointer
,	O
HFpt	struct
.	O
h	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/%s /HF-gs-font MF\n"	pointer
,	O
HFname	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/HF /HF-gs-font findfont [HFpt_w 0 0 HFpt_h 0 0] makefont def\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/%s /F-gs-font MF\n"	pointer
,	O
Fname	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/F-gs-font %g %g SF\n"	pointer
,	O
Fpt	struct
.	O
w	int
,	O
Fpt	struct
.	O
h	int
)	O
)	O
;	O
if	O
(	O
underlay	pointer
!=	O
NULL	O
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/ul_str (%s) def\n"	pointer
,	O
underlay	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/ul_w_ptsize %g def\n"	pointer
,	O
ul_ptsize	struct
.	O
w	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/ul_h_ptsize %g def\n"	pointer
,	O
ul_ptsize	struct
.	O
h	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/ul_gray %g def\n"	pointer
,	O
ul_gray	double
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/ul_x %g def\n"	pointer
,	O
ul_x	double
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/ul_y %g def\n"	pointer
,	O
ul_y	double
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/ul_angle %g def\n"	pointer
,	O
ul_angle	double
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/ul_style %d def\n"	pointer
,	O
ul_style	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/%s /F-ul-font MF\n"	pointer
,	O
ul_font	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/ul_font /F-ul-font findfont [ul_w_ptsize 0 0 ul_h_ptsize 0 0] makefont def\n"	pointer
)	O
)	O
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/#copies %d def\n"	pointer
,	O
num_copies	int
)	O
)	O
;	O
if	O
(	O
page_prefeed	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"true page_prefeed\n"	pointer
)	O
)	O
;	O
if	O
(	O
count_key_value_set	function
(	O
statusdict	pointer
)	O
>	O
0	int
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%% Statustdict definitions:\nstatusdict begin\n  "	pointer
)	O
)	O
;	O
i	int
=	O
2	int
;	O
for	O
(	O
got	int
=	O
strhash_get_first	function
(	O
statusdict	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
;	O
got	int
;	O
got	int
=	O
strhash_get_next	function
(	O
statusdict	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
)	O
{	O
j	int
=	O
strlen	function
(	O
cp	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
cp2	pointer
)	O
+	O
1	int
;	O
if	O
(	O
i	int
+	O
j	int
>	O
RESOURCE_LINE_WIDTH	int
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"\n  "	pointer
)	O
)	O
;	O
i	int
=	O
2	int
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%s %s "	pointer
,	O
cp2	pointer
,	O
cp	pointer
)	O
)	O
;	O
i	int
+=	O
j	int
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"\nend\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
pslevel	int
>=	O
2	int
&&	O
(	O
count_key_value_set	function
(	O
pagedevice	pointer
)	O
>	O
0	int
||	O
generate_PageSize	int
)	O
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%% Pagedevice definitions:\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"gs_languagelevel 1 gt {\n  <<\n    "	pointer
)	O
)	O
;	O
i	int
=	O
4	int
;	O
for	O
(	O
got	int
=	O
strhash_get_first	function
(	O
pagedevice	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
;	O
got	int
;	O
got	int
=	O
strhash_get_next	function
(	O
pagedevice	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
)	O
{	O
j	int
=	O
strlen	function
(	O
cp2	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
cp	pointer
)	O
+	O
2	int
;	O
if	O
(	O
i	int
+	O
j	int
>	O
RESOURCE_LINE_WIDTH	int
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"\n    "	pointer
)	O
)	O
;	O
i	int
=	O
4	int
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/%s %s "	pointer
,	O
cp	pointer
,	O
cp2	pointer
)	O
)	O
;	O
i	int
+=	O
j	int
;	O
}	O
if	O
(	O
generate_PageSize	int
)	O
{	O
if	O
(	O
i	int
+	O
21	int
>	O
RESOURCE_LINE_WIDTH	int
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"\n    "	pointer
)	O
)	O
;	O
i	int
=	O
4	int
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/PageSize [%d %d] "	pointer
,	O
media	pointer
->	O
w	int
,	O
media	pointer
->	O
h	int
)	O
)	O
;	O
i	int
+=	O
21	int
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"\n  >> setpagedevice\n} if\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
header	enum
!=	O
HDR_NONE	int
)	O
{	O
char	O
*	O
hdr	pointer
;	O
if	O
(	O
header	enum
==	O
HDR_SIMPLE	int
)	O
hdr	pointer
=	O
"simple"	pointer
;	O
else	O
hdr	pointer
=	O
fancy_header_name	pointer
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%BeginResource: procset Enscript-Header-%s %s\n"	pointer
,	O
hdr	pointer
,	O
ps_version_string	pointer
)	O
)	O
;	O
if	O
(	O
!	O
paste_file	function
(	O
hdr	pointer
,	O
".hdr"	pointer
)	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't find header definition file \"%s.hdr\": %s\n"	pointer
)	O
,	O
hdr	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%EndResource\n"	pointer
)	O
)	O
;	O
}	O
d_output_w	int
=	O
d_page_w	int
;	O
d_output_h	int
=	O
d_page_h	int
-	O
d_header_h	int
-	O
d_footer_h	int
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_page_w %d def\n"	pointer
,	O
d_page_w	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_page_h %d def\n"	pointer
,	O
d_page_h	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_header_x %d def\n"	pointer
,	O
0	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_header_y %d def\n"	pointer
,	O
d_output_h	int
+	O
d_footer_h	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_header_w %d def\n"	pointer
,	O
d_header_w	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_header_h %d def\n"	pointer
,	O
d_header_h	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_footer_x %d def\n"	pointer
,	O
0	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_footer_y %d def\n"	pointer
,	O
0	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_footer_w %d def\n"	pointer
,	O
d_header_w	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_footer_h %d def\n"	pointer
,	O
d_footer_h	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_output_w %d def\n"	pointer
,	O
d_output_w	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/d_output_h %d def\n"	pointer
,	O
d_output_h	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/cols %d def\n"	pointer
,	O
num_columns	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%EndSetup\n"	pointer
)	O
)	O
;	O
}	O
void	O
dump_ps_trailer	function
(	O
)	O
{	O
int	O
i	int
,	O
j	int
,	O
got	int
;	O
char	O
*	O
cp	pointer
;	O
void	O
*	O
value	pointer
;	O
unsigned	O
int	O
nup_subpage	int
;	O
if	O
(	O
!	O
ps_header_dumped	int
)	O
return	O
;	O
nup_subpage	int
=	O
(	O
total_pages	int
-	O
1	int
)	O
%	O
nup	int
;	O
if	O
(	O
nup	int
>	O
1	int
&&	O
nup_subpage	int
+	O
1	int
!=	O
nup	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"_R\nS\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%Trailer\n"	pointer
)	O
)	O
;	O
if	O
(	O
page_prefeed	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"false page_prefeed\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%Pages: %d\n"	pointer
,	O
total_pages	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%DocumentNeededResources: font "	pointer
)	O
)	O
;	O
i	int
=	O
32	int
;	O
for	O
(	O
got	int
=	O
strhash_get_first	function
(	O
res_fonts	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
&	O
value	pointer
)	O
;	O
got	int
;	O
got	int
=	O
strhash_get_next	function
(	O
res_fonts	pointer
,	O
&	O
cp	pointer
,	O
&	O
j	int
,	O
&	O
value	pointer
)	O
)	O
{	O
if	O
(	O
i	int
+	O
strlen	function
(	O
cp	pointer
)	O
+	O
1	int
>	O
RESOURCE_LINE_WIDTH	int
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"\n%%%%+ font "	pointer
)	O
)	O
;	O
i	int
=	O
9	int
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%s "	pointer
,	O
cp	pointer
)	O
)	O
;	O
i	int
+=	O
strlen	function
(	O
cp	pointer
)	O
+	O
1	int
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"\n%%%%EOF\n"	pointer
)	O
)	O
;	O
}	O
void	O
process_file	function
(	O
char	O
*	O
fname_arg	pointer
,	O
InputStream	struct
*	O
is	pointer
,	O
int	O
is_toc	int
)	O
{	O
int	O
col	int
;	O
double	O
x	double
,	O
y	double
;	O
double	O
lx	double
,	O
ly	double
;	O
double	O
linewidth	double
;	O
double	O
lineend	double
;	O
int	O
done	int
=	O
0	int
;	O
int	O
page_clear	int
=	O
1	int
;	O
unsigned	O
int	O
line_column	int
;	O
unsigned	O
int	O
current_linenum	int
;	O
double	O
linenumber_space	double
=	O
0	int
;	O
double	O
linenumber_margin	double
=	O
0	int
;	O
Token	struct
token	pointer
;	O
int	O
reuse_last_token	int
=	O
0	int
;	O
unsigned	O
int	O
current_slice	int
=	O
1	int
;	O
int	O
last_wrapped_line	int
=	O
-	O
1	int
;	O
int	O
last_spaced_file_linenum	int
=	O
-	O
1	int
;	O
int	O
save_current_pagenum	int
;	O
int	O
toc_pagenum	int
=	O
0	int
;	O
xfree	function
(	O
fname	pointer
)	O
;	O
fname	pointer
=	O
xstrdup	function
(	O
fname_arg	pointer
)	O
;	O
if	O
(	O
!	O
continuous_page_numbers	int
)	O
current_pagenum	int
=	O
0	int
;	O
total_pages_in_file	int
=	O
0	int
;	O
current_file_linenum	int
=	O
start_line_number	int
;	O
linenumber_space	double
=	O
CHAR_WIDTH	O
(	O
'0'	O
)	O
*	O
5	int
+	O
1.0	int
;	O
linenumber_margin	double
=	O
CHAR_WIDTH	O
(	O
':'	O
)	O
+	O
CHAR_WIDTH	O
(	O
'm'	O
)	O
;	O
input_filenum	int
++	O
;	O
print_line_number_last	int
=	O
(	O
unsigned	O
int	O
)	O
-	O
1	int
;	O
if	O
(	O
pass_through	int
||	O
output_language_pass_through	int
)	O
if	O
(	O
do_pass_through	function
(	O
fname	pointer
,	O
is	pointer
)	O
)	O
return	O
;	O
dump_ps_header	function
(	O
)	O
;	O
while	O
(	O
(	O
total_pages	int
%	O
file_align	int
)	O
!=	O
0	int
)	O
{	O
total_pages	int
++	O
;	O
dump_empty_page	function
(	O
)	O
;	O
}	O
MESSAGE	O
(	O
1	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"processing file \"%s\"...\n"	pointer
)	O
,	O
fname	pointer
)	O
)	O
;	O
linewidth	double
=	O
d_output_w	int
/	O
num_columns	int
-	O
2	int
*	O
d_output_x_margin	int
-	O
line_indent	double
;	O
first_pagenum_for_file	int
=	O
total_pages	int
+	O
1	int
;	O
divert	function
(	O
)	O
;	O
while	O
(	O
!	O
done	int
)	O
{	O
page_clear	int
=	O
1	int
;	O
for	O
(	O
col	int
=	O
0	int
;	O
!	O
done	int
&&	O
col	int
<	O
num_columns	int
;	O
col	int
++	O
)	O
{	O
lx	double
=	O
x	double
=	O
col	int
*	O
d_output_w	int
/	O
(	O
float	O
)	O
num_columns	int
+	O
d_output_x_margin	int
+	O
line_indent	double
;	O
lineend	double
=	O
lx	double
+	O
linewidth	double
;	O
ly	double
=	O
y	double
=	O
d_footer_h	int
+	O
d_output_h	int
-	O
d_output_y_margin	int
-	O
LINESKIP	O
;	O
current_linenum	int
=	O
0	int
;	O
line_column	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
line_numbers	int
&&	O
line_column	int
==	O
0	int
&&	O
(	O
current_file_linenum	int
!=	O
last_spaced_file_linenum	int
)	O
)	O
{	O
x	double
+=	O
linenumber_space	double
+	O
linenumber_margin	double
;	O
last_spaced_file_linenum	int
=	O
current_file_linenum	int
;	O
}	O
if	O
(	O
!	O
reuse_last_token	int
)	O
get_next_token	function
(	O
is	pointer
,	O
lx	double
,	O
x	double
,	O
line_column	int
,	O
lineend	double
,	O
&	O
token	pointer
)	O
;	O
reuse_last_token	int
=	O
0	int
;	O
if	O
(	O
token	pointer
.	O
type	int
==	O
tEOF	int
)	O
{	O
done	int
=	O
1	int
;	O
goto	O
end_of_page	O
;	O
}	O
if	O
(	O
page_clear	int
)	O
{	O
PageRange	struct
*	O
pr	pointer
;	O
current_pagenum	int
++	O
;	O
total_pages_in_file	int
++	O
;	O
if	O
(	O
page_ranges	pointer
==	O
NULL	O
)	O
do_print	int
=	O
1	int
;	O
else	O
{	O
do_print	int
=	O
0	int
;	O
for	O
(	O
pr	pointer
=	O
page_ranges	pointer
;	O
pr	pointer
;	O
pr	pointer
=	O
pr	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
pr	pointer
->	O
odd	int
||	O
pr	pointer
->	O
even	int
)	O
{	O
if	O
(	O
(	O
pr	pointer
->	O
odd	int
&&	O
(	O
current_pagenum	int
%	O
2	int
)	O
==	O
1	int
)	O
||	O
(	O
pr	pointer
->	O
even	int
&&	O
(	O
current_pagenum	int
%	O
2	int
)	O
==	O
0	int
)	O
)	O
{	O
do_print	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
pr	pointer
->	O
start	int
<=	O
current_pagenum	int
&&	O
current_pagenum	int
<=	O
pr	pointer
->	O
end	int
)	O
{	O
do_print	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
do_print	int
)	O
total_pages	int
++	O
;	O
if	O
(	O
is_toc	int
)	O
{	O
save_current_pagenum	int
=	O
current_pagenum	int
;	O
toc_pagenum	int
--	O
;	O
current_pagenum	int
=	O
toc_pagenum	int
;	O
}	O
dump_ps_page_header	function
(	O
fname	pointer
,	O
0	int
)	O
;	O
page_clear	int
=	O
0	int
;	O
if	O
(	O
is_toc	int
)	O
current_pagenum	int
=	O
save_current_pagenum	int
;	O
}	O
if	O
(	O
line_column	int
==	O
0	int
&&	O
line_highlight_gray	double
<	O
1.0	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g %g %g %g line_highlight\n"	pointer
,	O
lx	double
,	O
(	O
y	double
-	O
baselineskip	double
+	O
(	O
font_bbox_lly	double
*	O
Fpt	struct
.	O
h	int
/	O
UNITS_PER_POINT	int
)	O
)	O
,	O
linewidth	double
,	O
Fpt	struct
.	O
h	int
+	O
baselineskip	double
,	O
line_highlight_gray	double
)	O
)	O
;	O
if	O
(	O
line_numbers	int
&&	O
line_column	int
==	O
0	int
&&	O
token	pointer
.	O
type	int
!=	O
tFORMFEED	int
)	O
print_line_number	function
(	O
lx	double
,	O
y	double
,	O
linenumber_space	double
,	O
linenumber_margin	double
,	O
current_file_linenum	int
)	O
;	O
switch	O
(	O
token	pointer
.	O
type	int
)	O
{	O
case	O
tFORMFEED	int
:	O
switch	O
(	O
formfeed_type	enum
)	O
{	O
case	O
FORMFEED_COLUMN	int
:	O
goto	O
end_of_column	O
;	O
break	O
;	O
case	O
FORMFEED_PAGE	int
:	O
goto	O
end_of_page	O
;	O
break	O
;	O
case	O
FORMFEED_HCOLUMN	int
:	O
{	O
int	O
current_row	int
;	O
current_row	int
=	O
(	O
ly	double
-	O
y	double
)	O
/	O
horizontal_column_height	double
;	O
y	double
=	O
ly	double
-	O
(	O
current_row	int
+	O
1	int
)	O
*	O
horizontal_column_height	double
;	O
if	O
(	O
y	double
<	O
d_footer_h	int
+	O
d_output_y_margin	int
)	O
goto	O
end_of_column	O
;	O
}	O
break	O
;	O
}	O
break	O
;	O
case	O
tSTRING	int
:	O
if	O
(	O
CORRECT_SLICE	O
(	O
)	O
)	O
{	O
if	O
(	O
bggray	double
<	O
1.0	int
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g %g %g %g (%s) bgs\n"	pointer
,	O
x	double
,	O
y	double
,	O
Fpt	struct
.	O
h	int
+	O
baselineskip	double
,	O
baselineskip	double
-	O
(	O
font_bbox_lly	double
*	O
Fpt	struct
.	O
h	int
/	O
UNITS_PER_POINT	int
)	O
,	O
bggray	double
,	O
token	pointer
.	O
u	union
.	O
str	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
user_bgcolorp	int
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g %g %g %g %g %g (%s) bgcs\n"	pointer
,	O
x	double
,	O
y	double
,	O
Fpt	struct
.	O
h	int
+	O
baselineskip	double
,	O
baselineskip	double
-	O
(	O
font_bbox_lly	double
*	O
Fpt	struct
.	O
h	int
/	O
UNITS_PER_POINT	int
)	O
,	O
user_bgcolor	struct
.	O
r	float
,	O
user_bgcolor	struct
.	O
g	float
,	O
user_bgcolor	struct
.	O
b	float
,	O
token	pointer
.	O
u	union
.	O
str	pointer
)	O
)	O
;	O
}	O
else	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g M\n(%s) s\n"	pointer
,	O
x	double
,	O
y	double
,	O
token	pointer
.	O
u	union
.	O
str	pointer
)	O
)	O
;	O
}	O
}	O
x	double
=	O
token	pointer
.	O
new_x	double
;	O
line_column	int
=	O
token	pointer
.	O
new_col	int
;	O
break	O
;	O
case	O
tCARRIAGE_RETURN	int
:	O
x	double
=	O
col	int
*	O
d_output_w	int
/	O
(	O
float	O
)	O
num_columns	int
+	O
d_output_x_margin	int
+	O
line_indent	double
;	O
line_column	int
=	O
0	int
;	O
break	O
;	O
case	O
tNEWLINE	int
:	O
case	O
tWRAPPED_NEWLINE	int
:	O
if	O
(	O
token	pointer
.	O
type	int
==	O
tNEWLINE	int
)	O
{	O
current_file_linenum	int
++	O
;	O
current_slice	int
=	O
1	int
;	O
y	double
-=	O
LINESKIP	O
;	O
}	O
else	O
{	O
current_slice	int
++	O
;	O
if	O
(	O
!	O
slicing	int
)	O
{	O
switch	O
(	O
mark_wrapped_lines_style	enum
)	O
{	O
case	O
MWLS_NONE	int
:	O
break	O
;	O
case	O
MWLS_PLUS	int
:	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g M (+) s\n"	pointer
,	O
x	double
,	O
y	double
)	O
)	O
;	O
break	O
;	O
default	O
:	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g %g %g %d wrapped_line_mark\n"	pointer
,	O
x	double
,	O
y	double
,	O
Fpt	struct
.	O
w	int
,	O
Fpt	struct
.	O
h	int
,	O
mark_wrapped_lines_style	enum
)	O
)	O
;	O
break	O
;	O
}	O
y	double
-=	O
LINESKIP	O
;	O
}	O
if	O
(	O
!	O
slicing	int
||	O
current_slice	int
>	O
slice	int
)	O
if	O
(	O
current_file_linenum	int
!=	O
last_wrapped_line	int
)	O
{	O
if	O
(	O
do_print	int
)	O
num_truncated_lines	int
++	O
;	O
last_wrapped_line	int
=	O
current_file_linenum	int
;	O
}	O
}	O
current_linenum	int
++	O
;	O
if	O
(	O
current_linenum	int
>=	O
lines_per_page	int
||	O
y	double
<	O
d_footer_h	int
+	O
d_output_y_margin	int
)	O
goto	O
end_of_column	O
;	O
x	double
=	O
col	int
*	O
d_output_w	int
/	O
(	O
float	O
)	O
num_columns	int
+	O
d_output_x_margin	int
+	O
line_indent	double
;	O
line_column	int
=	O
0	int
;	O
break	O
;	O
case	O
tEPSF	int
:	O
if	O
(	O
token	pointer
.	O
flags	int
&	O
F_EPSF_ABSOLUTE_Y	int
)	O
token	pointer
.	O
new_y	double
=	O
ly	double
;	O
else	O
token	pointer
.	O
new_y	double
=	O
y	double
;	O
token	pointer
.	O
new_y	double
+=	O
token	pointer
.	O
u	union
.	O
epsf	struct
.	O
y	double
-	O
token	pointer
.	O
u	union
.	O
epsf	struct
.	O
h	int
;	O
if	O
(	O
token	pointer
.	O
flags	int
&	O
F_EPSF_ABSOLUTE_X	int
)	O
token	pointer
.	O
new_x	double
=	O
lx	double
;	O
else	O
token	pointer
.	O
new_x	double
=	O
x	double
;	O
token	pointer
.	O
new_x	double
+=	O
token	pointer
.	O
u	union
.	O
epsf	struct
.	O
x	double
;	O
if	O
(	O
token	pointer
.	O
flags	int
&	O
F_EPSF_CENTER	int
)	O
token	pointer
.	O
new_x	double
=	O
lx	double
+	O
(	O
linewidth	double
-	O
token	pointer
.	O
u	union
.	O
epsf	struct
.	O
w	int
)	O
/	O
2	int
;	O
if	O
(	O
token	pointer
.	O
flags	int
&	O
F_EPSF_RIGHT	int
)	O
token	pointer
.	O
new_x	double
=	O
lx	double
+	O
(	O
linewidth	double
-	O
token	pointer
.	O
u	union
.	O
epsf	struct
.	O
w	int
)	O
;	O
if	O
(	O
(	O
token	pointer
.	O
flags	int
&	O
F_EPSF_NO_CPOINT_UPDATE_Y	int
)	O
==	O
0	int
&&	O
token	pointer
.	O
new_y	double
<	O
d_footer_h	int
+	O
d_output_y_margin	int
)	O
{	O
if	O
(	O
current_linenum	int
==	O
0	int
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"EPS file \"%s\" is too large for page\n"	pointer
)	O
,	O
token	pointer
.	O
u	union
.	O
epsf	struct
.	O
filename	pointer
)	O
)	O
;	O
}	O
else	O
{	O
reuse_last_token	int
=	O
1	int
;	O
goto	O
end_of_column	O
;	O
}	O
}	O
if	O
(	O
CORRECT_SLICE	O
(	O
)	O
)	O
paste_epsf	function
(	O
&	O
token	pointer
)	O
;	O
if	O
(	O
!	O
(	O
token	pointer
.	O
flags	int
&	O
F_EPSF_NO_CPOINT_UPDATE_Y	int
)	O
)	O
y	double
=	O
token	pointer
.	O
new_y	double
;	O
if	O
(	O
!	O
(	O
token	pointer
.	O
flags	int
&	O
F_EPSF_NO_CPOINT_UPDATE_X	int
)	O
)	O
x	double
=	O
token	pointer
.	O
new_x	double
+	O
token	pointer
.	O
u	union
.	O
epsf	struct
.	O
w	int
;	O
if	O
(	O
y	double
<	O
d_footer_h	int
+	O
d_output_y_margin	int
)	O
goto	O
end_of_column	O
;	O
break	O
;	O
case	O
tFONT	int
:	O
if	O
(	O
line_column	int
==	O
0	int
)	O
{	O
double	O
newh	double
;	O
if	O
(	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
name	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
newh	double
=	O
default_Fpt	struct
.	O
h	int
;	O
else	O
newh	double
=	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
size	long
.	O
h	int
;	O
if	O
(	O
newh	double
!=	O
Fpt	struct
.	O
h	int
)	O
{	O
y	double
-=	O
(	O
newh	double
-	O
Fpt	struct
.	O
h	int
)	O
;	O
}	O
}	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"^@font="	pointer
)	O
)	O
;	O
if	O
(	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
name	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
Fpt	struct
.	O
w	int
=	O
default_Fpt	struct
.	O
w	int
;	O
Fpt	struct
.	O
h	int
=	O
default_Fpt	struct
.	O
h	int
;	O
Fname	pointer
=	O
default_Fname	pointer
;	O
encoding	array
=	O
default_Fencoding	enum
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/F-gs-font %g %g SF\n"	pointer
,	O
Fpt	struct
.	O
w	int
,	O
Fpt	struct
.	O
h	int
)	O
)	O
;	O
user_fontp	int
=	O
0	int
;	O
}	O
else	O
{	O
strhash_put	function
(	O
res_fonts	pointer
,	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
name	pointer
,	O
strlen	function
(	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
name	pointer
)	O
+	O
1	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
encoding	array
==	O
default_Fencoding	enum
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/%s %g %g SUF\n"	pointer
,	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
name	pointer
,	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
size	long
.	O
w	int
,	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
size	long
.	O
h	int
)	O
)	O
;	O
else	O
if	O
(	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
encoding	array
==	O
ENC_PS	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/%s %g %g SUF_PS\n"	pointer
,	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
name	pointer
,	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
size	long
.	O
w	int
,	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
size	long
.	O
h	int
)	O
)	O
;	O
else	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"user font encoding can be only the system's default or `ps'"	pointer
)	O
)	O
)	O
;	O
memset	function
(	O
user_font_name	array
,	O
0	int
,	O
sizeof	O
(	O
user_font_name	array
)	O
)	O
;	O
strncpy	function
(	O
user_font_name	array
,	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
name	pointer
,	O
sizeof	O
(	O
user_font_name	array
)	O
-	O
1	int
)	O
;	O
user_font_pt	struct
.	O
w	int
=	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
size	long
.	O
w	int
;	O
user_font_pt	struct
.	O
h	int
=	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
size	long
.	O
h	int
;	O
user_font_encoding	enum
=	O
token	pointer
.	O
u	union
.	O
font	pointer
.	O
encoding	array
;	O
user_fontp	int
=	O
1	int
;	O
Fpt	struct
.	O
w	int
=	O
user_font_pt	struct
.	O
w	int
;	O
Fpt	struct
.	O
h	int
=	O
user_font_pt	struct
.	O
h	int
;	O
Fname	pointer
=	O
user_font_name	array
;	O
encoding	array
=	O
user_font_encoding	enum
;	O
}	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"%s %g/%gpt\n"	pointer
,	O
Fname	pointer
,	O
Fpt	struct
.	O
w	int
,	O
Fpt	struct
.	O
h	int
)	O
)	O
;	O
read_font_info	function
(	O
)	O
;	O
if	O
(	O
y	double
<	O
d_footer_h	int
+	O
d_output_y_margin	int
)	O
goto	O
end_of_column	O
;	O
break	O
;	O
case	O
tCOLOR	int
:	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"^@color{%f %f %f}\n"	pointer
,	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
r	float
,	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
g	float
,	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
b	float
)	O
)	O
;	O
if	O
(	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
r	float
==	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
g	float
&&	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
g	float
==	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
b	float
&&	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
b	float
==	O
0.0	int
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"0 setgray\n"	pointer
)	O
)	O
;	O
user_colorp	int
=	O
0	int
;	O
}	O
else	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g %g setrgbcolor\n"	pointer
,	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
r	float
,	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
g	float
,	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
b	float
)	O
)	O
;	O
user_color	struct
.	O
r	float
=	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
r	float
;	O
user_color	struct
.	O
g	float
=	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
g	float
;	O
user_color	struct
.	O
b	float
=	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
b	float
;	O
user_colorp	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
tBGCOLOR	int
:	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"^@bgcolor{%f %f %f}\n"	pointer
,	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
r	float
,	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
g	float
,	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
b	float
)	O
)	O
;	O
if	O
(	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
r	float
==	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
g	float
&&	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
g	float
==	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
b	float
&&	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
b	float
==	O
1.0	int
)	O
{	O
user_bgcolorp	int
=	O
0	int
;	O
}	O
else	O
{	O
user_bgcolor	struct
.	O
r	float
=	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
r	float
;	O
user_bgcolor	struct
.	O
g	float
=	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
g	float
;	O
user_bgcolor	struct
.	O
b	float
=	O
token	pointer
.	O
u	union
.	O
color	struct
.	O
b	float
;	O
user_bgcolorp	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
tSETFILENAME	int
:	O
xfree	function
(	O
fname	pointer
)	O
;	O
fname	pointer
=	O
xstrdup	function
(	O
token	pointer
.	O
u	union
.	O
filename	pointer
)	O
;	O
break	O
;	O
case	O
tSETPAGENUMBER	int
:	O
current_pagenum	int
=	O
token	pointer
.	O
u	union
.	O
i	int
-	O
1	int
;	O
break	O
;	O
case	O
tNEWPAGE	int
:	O
if	O
(	O
current_linenum	int
>=	O
token	pointer
.	O
u	union
.	O
i	int
)	O
goto	O
end_of_page	O
;	O
break	O
;	O
case	O
tSAVEX	int
:	O
xstore	array
[	O
(	O
unsigned	O
char	O
)	O
token	pointer
.	O
u	union
.	O
i	int
]	O
=	O
x	double
;	O
break	O
;	O
case	O
tLOADX	int
:	O
x	double
=	O
xstore	array
[	O
(	O
unsigned	O
char	O
)	O
token	pointer
.	O
u	union
.	O
i	int
]	O
;	O
break	O
;	O
case	O
tPS	int
:	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g M\n%s\n"	pointer
,	O
x	double
,	O
y	double
,	O
token	pointer
.	O
u	union
.	O
str	pointer
)	O
)	O
;	O
xfree	function
(	O
token	pointer
.	O
u	union
.	O
str	pointer
)	O
;	O
break	O
;	O
case	O
tNONE	int
:	O
default	O
:	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
"process_file(): got illegal token %d"	pointer
,	O
token	pointer
.	O
type	int
)	O
)	O
;	O
break	O
;	O
}	O
}	O
end_of_column	O
:	O
;	O
}	O
end_of_page	O
:	O
if	O
(	O
!	O
page_clear	int
)	O
dump_ps_page_trailer	function
(	O
)	O
;	O
}	O
do_print	int
=	O
1	int
;	O
undivert	function
(	O
)	O
;	O
if	O
(	O
toc	int
)	O
{	O
char	O
*	O
cp	pointer
;	O
int	O
save_total_pages	int
=	O
total_pages	int
;	O
total_pages	int
=	O
first_pagenum_for_file	int
;	O
cp	pointer
=	O
format_user_string	function
(	O
"TOC"	pointer
,	O
toc_fmt_string	pointer
)	O
;	O
fprintf	function
(	O
toc_fp	pointer
,	O
"%s\n"	pointer
,	O
cp	pointer
)	O
;	O
xfree	function
(	O
cp	pointer
)	O
;	O
total_pages	int
=	O
save_total_pages	int
;	O
}	O
}	O
static	O
struct	O
{	O
char	O
*	O
name	pointer
;	O
SpecialEscape	enum
escape	enum
;	O
}	O
escapes	array
[	O
]	O
=	O
{	O
{	O
"comment"	pointer
,	O
ESC_COMMENT	int
}	O
,	O
{	O
"epsf"	pointer
,	O
ESC_EPSF	int
}	O
,	O
{	O
"font"	pointer
,	O
ESC_FONT	int
}	O
,	O
{	O
"color"	pointer
,	O
ESC_COLOR	int
}	O
,	O
{	O
"bgcolor"	pointer
,	O
ESC_BGCOLOR	int
}	O
,	O
{	O
"newpage"	pointer
,	O
ESC_NEWPAGE	int
}	O
,	O
{	O
"ps"	pointer
,	O
ESC_PS	int
}	O
,	O
{	O
"setfilename"	pointer
,	O
ESC_SETFILENAME	int
}	O
,	O
{	O
"setpagenumber"	pointer
,	O
ESC_SETPAGENUMBER	int
}	O
,	O
{	O
"shade"	pointer
,	O
ESC_SHADE	int
}	O
,	O
{	O
"bggray"	pointer
,	O
ESC_BGGRAY	int
}	O
,	O
{	O
"escape"	pointer
,	O
ESC_ESCAPE	int
}	O
,	O
{	O
"savex"	pointer
,	O
ESC_SAVEX	int
}	O
,	O
{	O
"loadx"	pointer
,	O
ESC_LOADX	int
}	O
,	O
{	O
NULL	O
,	O
0	int
}	O
,	O
}	O
;	O
static	O
void	O
read_special_escape	function
(	O
InputStream	struct
*	O
is	pointer
,	O
Token	struct
*	O
token	pointer
)	O
{	O
char	O
escname	array
[	O
256	int
]	O
;	O
char	O
buf	pointer
[	O
4096	int
]	O
;	O
int	O
i	int
,	O
e	int
;	O
int	O
ch	char
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
escname	array
)	O
-	O
1	int
&&	O
(	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
)	O
!=	O
EOF	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
isalnum	function
(	O
ch	char
)	O
)	O
{	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
break	O
;	O
}	O
else	O
escname	array
[	O
i	int
]	O
=	O
ch	char
;	O
}	O
escname	array
[	O
i	int
]	O
=	O
'\0'	O
;	O
for	O
(	O
e	int
=	O
0	int
;	O
escapes	array
[	O
e	int
]	O
.	O
name	pointer
;	O
e	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
escname	array
,	O
escapes	array
[	O
e	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
escapes	array
[	O
e	int
]	O
.	O
name	pointer
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"unknown special escape: %s"	pointer
)	O
,	O
escname	array
)	O
)	O
;	O
if	O
(	O
escapes	array
[	O
e	int
]	O
.	O
escape	enum
==	O
ESC_EPSF	int
)	O
{	O
int	O
i	int
;	O
int	O
pw	int
,	O
ph	int
;	O
double	O
scale	double
;	O
token	pointer
->	O
flags	int
=	O
0	int
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
x	double
=	O
0.0	int
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
y	double
=	O
0.0	int
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
h	int
=	O
0.0	int
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
pipe	function
=	O
0	int
;	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
;	O
if	O
(	O
ch	char
==	O
'['	O
)	O
{	O
while	O
(	O
(	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
)	O
!=	O
EOF	O
&&	O
ch	char
!=	O
']'	O
)	O
{	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'c'	O
:	O
token	pointer
->	O
flags	int
&=	O
~	O
M_EPSF_JUSTIFICATION	int
;	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_CENTER	int
;	O
break	O
;	O
case	O
'n'	O
:	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
;	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'x'	O
:	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_NO_CPOINT_UPDATE_X	int
;	O
break	O
;	O
case	O
'y'	O
:	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_NO_CPOINT_UPDATE_Y	int
;	O
break	O
;	O
default	O
:	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_NO_CPOINT_UPDATE_X	int
;	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_NO_CPOINT_UPDATE_Y	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'r'	O
:	O
token	pointer
->	O
flags	int
&=	O
~	O
M_EPSF_JUSTIFICATION	int
;	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_RIGHT	int
;	O
break	O
;	O
case	O
's'	O
:	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
;	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'x'	O
:	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_SCALE_X	int
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
xscale	double
=	O
read_float	function
(	O
is	pointer
,	O
0	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'y'	O
:	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_SCALE_Y	int
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
yscale	double
=	O
read_float	function
(	O
is	pointer
,	O
0	int
,	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_SCALE_X	int
;	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_SCALE_Y	int
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
xscale	double
=	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
yscale	double
=	O
read_float	function
(	O
is	pointer
,	O
0	int
,	O
1	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'x'	O
:	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
x	double
=	O
read_float	function
(	O
is	pointer
,	O
1	int
,	O
1	int
)	O
;	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
;	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'a'	O
:	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_ABSOLUTE_X	int
;	O
break	O
;	O
default	O
:	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'y'	O
:	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
y	double
=	O
-	O
read_float	function
(	O
is	pointer
,	O
1	int
,	O
0	int
)	O
;	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
;	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'a'	O
:	O
token	pointer
->	O
flags	int
|=	O
F_EPSF_ABSOLUTE_Y	int
;	O
break	O
;	O
default	O
:	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
'h'	O
:	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
h	int
=	O
read_float	function
(	O
is	pointer
,	O
1	int
,	O
0	int
)	O
;	O
break	O
;	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
break	O
;	O
default	O
:	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"illegal option %c for ^@epsf escape"	pointer
)	O
,	O
ch	char
)	O
)	O
;	O
}	O
}	O
if	O
(	O
ch	char
!=	O
']'	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed ^@epsf escape: no ']' after options"	pointer
)	O
)	O
)	O
;	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
;	O
}	O
if	O
(	O
ch	char
==	O
'{'	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
)	O
!=	O
EOF	O
&&	O
ch	char
!=	O
'}'	O
;	O
i	int
++	O
)	O
{	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
[	O
i	int
]	O
=	O
ch	char
;	O
if	O
(	O
i	int
+	O
1	int
>=	O
sizeof	O
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
)	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"too long file name for ^@epsf escape:\n%.*s"	pointer
)	O
,	O
i	int
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
)	O
)	O
;	O
}	O
if	O
(	O
ch	char
==	O
EOF	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"unexpected EOF while scanning ^@epsf escape"	pointer
)	O
)	O
)	O
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
token	pointer
->	O
type	int
=	O
tEPSF	int
;	O
}	O
else	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed ^@epsf escape: no '{' found"	pointer
)	O
)	O
)	O
;	O
if	O
(	O
!	O
recognize_eps_file	function
(	O
token	pointer
)	O
)	O
token	pointer
->	O
type	int
=	O
tNONE	int
;	O
else	O
{	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
y	double
+=	O
LINESKIP	O
-	O
1	int
;	O
if	O
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
h	int
!=	O
0.0	int
)	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
h	int
-=	O
1.0	int
;	O
pw	int
=	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
urx	double
-	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
llx	double
;	O
ph	int
=	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
ury	double
-	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
lly	double
;	O
if	O
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
h	int
==	O
0.0	int
)	O
scale	double
=	O
1.0	int
;	O
else	O
scale	double
=	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
h	int
/	O
ph	int
;	O
if	O
(	O
(	O
token	pointer
->	O
flags	int
&	O
F_EPSF_SCALE_X	int
)	O
==	O
0	int
)	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
xscale	double
=	O
scale	double
;	O
if	O
(	O
(	O
token	pointer
->	O
flags	int
&	O
F_EPSF_SCALE_Y	int
)	O
==	O
0	int
)	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
yscale	double
=	O
scale	double
;	O
pw	int
*=	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
xscale	double
;	O
ph	int
*=	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
yscale	double
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
w	int
=	O
pw	int
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
h	int
=	O
ph	int
;	O
}	O
}	O
else	O
if	O
(	O
escapes	array
[	O
e	int
]	O
.	O
escape	enum
==	O
ESC_COMMENT	int
)	O
{	O
while	O
(	O
(	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
)	O
!=	O
EOF	O
&&	O
ch	char
!=	O
nl	int
)	O
;	O
token	pointer
->	O
type	int
=	O
tNONE	int
;	O
}	O
else	O
{	O
char	O
*	O
cp	pointer
;	O
int	O
parenlevel	int
;	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
;	O
if	O
(	O
ch	char
!=	O
'{'	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed %s escape: no '{' found"	pointer
)	O
,	O
escapes	array
[	O
e	int
]	O
.	O
name	pointer
)	O
)	O
;	O
parenlevel	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
)	O
!=	O
EOF	O
&&	O
(	O
parenlevel	int
>	O
0	int
||	O
ch	char
!=	O
'}'	O
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
ch	char
==	O
'{'	O
)	O
parenlevel	int
++	O
;	O
else	O
if	O
(	O
ch	char
==	O
'}'	O
)	O
parenlevel	int
--	O
;	O
buf	pointer
[	O
i	int
]	O
=	O
ch	char
;	O
if	O
(	O
i	int
+	O
1	int
>=	O
sizeof	O
(	O
buf	pointer
)	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"too long argument for %s escape:\n%.*s"	pointer
)	O
,	O
escapes	array
[	O
e	int
]	O
.	O
name	pointer
,	O
i	int
,	O
buf	pointer
)	O
)	O
;	O
}	O
buf	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
switch	O
(	O
escapes	array
[	O
e	int
]	O
.	O
escape	enum
)	O
{	O
case	O
ESC_FONT	int
:	O
memset	function
(	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
,	O
0	int
,	O
sizeof	O
(	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
)	O
)	O
;	O
strncpy	function
(	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
)	O
-	O
1	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
,	O
"default"	pointer
)	O
==	O
0	int
)	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
else	O
{	O
if	O
(	O
!	O
parse_font_spec	function
(	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
,	O
&	O
cp	pointer
,	O
&	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
size	long
,	O
&	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
encoding	array
)	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed font spec for ^@font escape: %s"	pointer
)	O
,	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
)	O
)	O
;	O
memset	function
(	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
,	O
0	int
,	O
sizeof	O
(	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
)	O
)	O
;	O
strncpy	function
(	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
,	O
cp	pointer
,	O
sizeof	O
(	O
token	pointer
->	O
u	union
.	O
font	pointer
.	O
name	pointer
)	O
-	O
1	int
)	O
;	O
xfree	function
(	O
cp	pointer
)	O
;	O
}	O
token	pointer
->	O
type	int
=	O
tFONT	int
;	O
break	O
;	O
case	O
ESC_COLOR	int
:	O
case	O
ESC_BGCOLOR	int
:	O
if	O
(	O
strcmp	function
(	O
buf	pointer
,	O
"default"	pointer
)	O
==	O
0	int
)	O
{	O
double	O
val	double
=	O
0	int
;	O
if	O
(	O
escapes	array
[	O
e	int
]	O
.	O
escape	enum
==	O
ESC_BGCOLOR	int
)	O
val	double
=	O
1	int
;	O
token	pointer
->	O
u	union
.	O
color	struct
.	O
r	float
=	O
val	double
;	O
token	pointer
->	O
u	union
.	O
color	struct
.	O
g	float
=	O
val	double
;	O
token	pointer
->	O
u	union
.	O
color	struct
.	O
b	float
=	O
val	double
;	O
}	O
else	O
{	O
int	O
got	int
;	O
got	int
=	O
sscanf	function
(	O
buf	pointer
,	O
"%g %g %g"	pointer
,	O
&	O
token	pointer
->	O
u	union
.	O
color	struct
.	O
r	float
,	O
&	O
token	pointer
->	O
u	union
.	O
color	struct
.	O
g	float
,	O
&	O
token	pointer
->	O
u	union
.	O
color	struct
.	O
b	float
)	O
;	O
switch	O
(	O
got	int
)	O
{	O
case	O
0	int
:	O
case	O
2	int
:	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"malformed color spec for ^@%s escape: %s"	pointer
)	O
,	O
escapes	array
[	O
e	int
]	O
.	O
escape	enum
==	O
ESC_COLOR	int
?	O
"color"	pointer
:	O
"bgcolor"	pointer
,	O
buf	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
token	pointer
->	O
u	union
.	O
color	struct
.	O
g	float
=	O
token	pointer
->	O
u	union
.	O
color	struct
.	O
b	float
=	O
token	pointer
->	O
u	union
.	O
color	struct
.	O
r	float
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
if	O
(	O
escapes	array
[	O
e	int
]	O
.	O
escape	enum
==	O
ESC_COLOR	int
)	O
token	pointer
->	O
type	int
=	O
tCOLOR	int
;	O
else	O
token	pointer
->	O
type	int
=	O
tBGCOLOR	int
;	O
break	O
;	O
case	O
ESC_SHADE	int
:	O
line_highlight_gray	double
=	O
atof	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
line_highlight_gray	double
<	O
0.0	int
||	O
line_highlight_gray	double
>	O
1.0	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"invalid value for ^@shade escape: %s"	pointer
)	O
,	O
buf	pointer
)	O
)	O
;	O
token	pointer
->	O
type	int
=	O
tNONE	int
;	O
break	O
;	O
case	O
ESC_BGGRAY	int
:	O
bggray	double
=	O
atof	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
bggray	double
<	O
0.0	int
||	O
bggray	double
>	O
1.0	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"invalid value for ^@bggray escape: %s"	pointer
)	O
,	O
buf	pointer
)	O
)	O
;	O
token	pointer
->	O
type	int
=	O
tNONE	int
;	O
break	O
;	O
case	O
ESC_ESCAPE	int
:	O
if	O
(	O
strcmp	function
(	O
buf	pointer
,	O
"default"	pointer
)	O
==	O
0	int
)	O
escape_char	int
=	O
default_escape_char	int
;	O
else	O
escape_char	int
=	O
atoi	function
(	O
buf	pointer
)	O
;	O
token	pointer
->	O
type	int
=	O
tNONE	int
;	O
break	O
;	O
case	O
ESC_SETFILENAME	int
:	O
memset	function
(	O
token	pointer
->	O
u	union
.	O
filename	pointer
,	O
0	int
,	O
sizeof	O
(	O
token	pointer
->	O
u	union
.	O
filename	pointer
)	O
)	O
;	O
strncpy	function
(	O
token	pointer
->	O
u	union
.	O
filename	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
token	pointer
->	O
u	union
.	O
filename	pointer
)	O
-	O
1	int
)	O
;	O
token	pointer
->	O
type	int
=	O
tSETFILENAME	int
;	O
break	O
;	O
case	O
ESC_SETPAGENUMBER	int
:	O
token	pointer
->	O
u	union
.	O
i	int
=	O
atoi	function
(	O
buf	pointer
)	O
;	O
token	pointer
->	O
type	int
=	O
tSETPAGENUMBER	int
;	O
break	O
;	O
case	O
ESC_NEWPAGE	int
:	O
if	O
(	O
i	int
==	O
0	int
)	O
token	pointer
->	O
u	union
.	O
i	int
=	O
1	int
;	O
else	O
token	pointer
->	O
u	union
.	O
i	int
=	O
atoi	function
(	O
buf	pointer
)	O
;	O
token	pointer
->	O
type	int
=	O
tNEWPAGE	int
;	O
break	O
;	O
case	O
ESC_SAVEX	int
:	O
token	pointer
->	O
type	int
=	O
tSAVEX	int
;	O
token	pointer
->	O
u	union
.	O
i	int
=	O
atoi	function
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
ESC_LOADX	int
:	O
token	pointer
->	O
type	int
=	O
tLOADX	int
;	O
token	pointer
->	O
u	union
.	O
i	int
=	O
atoi	function
(	O
buf	pointer
)	O
;	O
break	O
;	O
case	O
ESC_PS	int
:	O
token	pointer
->	O
u	union
.	O
str	pointer
=	O
xstrdup	function
(	O
buf	pointer
)	O
;	O
token	pointer
->	O
type	int
=	O
tPS	int
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
get_next_token	function
(	O
InputStream	struct
*	O
is	pointer
,	O
double	O
linestart	double
,	O
double	O
linepos	double
,	O
unsigned	O
int	O
col	int
,	O
double	O
linew	double
,	O
Token	struct
*	O
token	pointer
)	O
{	O
static	O
unsigned	O
char	O
*	O
buffer	pointer
=	O
NULL	O
;	O
static	O
unsigned	O
int	O
buflen	int
=	O
0	int
;	O
unsigned	O
int	O
bufpos	int
=	O
0	int
;	O
int	O
ch	char
=	O
0	int
;	O
int	O
done	int
=	O
0	int
;	O
int	O
i	int
;	O
static	O
int	O
pending_token	int
=	O
tNONE	int
;	O
unsigned	O
int	O
original_col	int
=	O
col	int
;	O
if	O
(	O
pending_token	int
!=	O
tNONE	int
)	O
{	O
token	pointer
->	O
type	int
=	O
pending_token	int
;	O
pending_token	int
=	O
tNONE	int
;	O
return	O
;	O
}	O
while	O
(	O
!	O
done	int
)	O
{	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
;	O
switch	O
(	O
ch	char
)	O
{	O
case	O
EOF	O
:	O
if	O
(	O
BUFFER_EMPTY	O
(	O
)	O
)	O
{	O
token	pointer
->	O
type	int
=	O
tEOF	int
;	O
return	O
;	O
}	O
done	int
=	O
DONE_DONE	int
;	O
break	O
;	O
case	O
'\r'	O
:	O
case	O
'\n'	O
:	O
if	O
(	O
ch	char
==	O
nl	int
)	O
{	O
if	O
(	O
BUFFER_EMPTY	O
(	O
)	O
)	O
{	O
token	pointer
->	O
type	int
=	O
tNEWLINE	int
;	O
return	O
;	O
}	O
else	O
{	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
done	int
=	O
DONE_DONE	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
BUFFER_EMPTY	O
(	O
)	O
)	O
{	O
token	pointer
->	O
type	int
=	O
tCARRIAGE_RETURN	int
;	O
return	O
;	O
}	O
else	O
{	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
done	int
=	O
DONE_DONE	int
;	O
}	O
}	O
break	O
;	O
case	O
'\t'	O
:	O
if	O
(	O
font_is_fixed	enum
)	O
{	O
i	int
=	O
tabsize	int
-	O
(	O
col	int
%	O
tabsize	int
)	O
;	O
for	O
(	O
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
{	O
if	O
(	O
FITS_ON_LINE	O
(	O
' '	O
)	O
)	O
EMIT	O
(	O
' '	O
)	O
;	O
else	O
{	O
done	int
=	O
DONE_WRAP	int
;	O
break	O
;	O
}	O
}	O
}	O
else	O
{	O
double	O
grid	double
=	O
tabsize	int
*	O
CHAR_WIDTH	O
(	O
' '	O
)	O
;	O
col	int
++	O
;	O
linepos	double
=	O
(	O
(	O
(	O
int	O
)	O
(	O
(	O
linepos	double
-	O
linestart	double
)	O
/	O
grid	double
)	O
+	O
1	int
)	O
*	O
grid	double
+	O
linestart	double
)	O
;	O
if	O
(	O
linepos	double
>=	O
linew	double
)	O
done	int
=	O
DONE_WRAP	int
;	O
else	O
done	int
=	O
DONE_DONE	int
;	O
}	O
break	O
;	O
case	O
'\f'	O
:	O
if	O
(	O
BUFFER_EMPTY	O
(	O
)	O
)	O
{	O
if	O
(	O
interpret_formfeed	int
)	O
token	pointer
->	O
type	int
=	O
tFORMFEED	int
;	O
else	O
token	pointer
->	O
type	int
=	O
tNEWLINE	int
;	O
return	O
;	O
}	O
else	O
{	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
done	int
=	O
DONE_DONE	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
special_escapes	int
&&	O
ch	char
==	O
escape_char	int
)	O
{	O
if	O
(	O
BUFFER_EMPTY	O
(	O
)	O
)	O
{	O
read_special_escape	function
(	O
is	pointer
,	O
token	pointer
)	O
;	O
if	O
(	O
token	pointer
->	O
type	int
!=	O
tNONE	int
)	O
return	O
;	O
break	O
;	O
}	O
else	O
{	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
done	int
=	O
DONE_DONE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
ch	char
==	O
bs	int
)	O
{	O
if	O
(	O
BUFFER_EMPTY	O
(	O
)	O
||	O
!	O
EXISTS	O
(	O
buffer	pointer
[	O
bufpos	int
-	O
1	int
]	O
)	O
)	O
linepos	double
-=	O
CHAR_WIDTH	O
(	O
'm'	O
)	O
;	O
else	O
linepos	double
-=	O
CHAR_WIDTH	O
(	O
buffer	pointer
[	O
bufpos	int
-	O
1	int
]	O
)	O
;	O
done	int
=	O
DONE_DONE	int
;	O
break	O
;	O
}	O
if	O
(	O
EXISTS	O
(	O
ch	char
)	O
)	O
{	O
if	O
(	O
FITS_ON_LINE	O
(	O
ch	char
)	O
)	O
{	O
if	O
(	O
ch	char
<	O
040	int
||	O
(	O
clean_7bit	int
&&	O
ch	char
>=	O
0200	int
)	O
)	O
{	O
char	O
buf	pointer
[	O
10	int
]	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"\\%03o"	pointer
,	O
ch	char
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
buf	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
APPEND_CHAR	O
(	O
buf	pointer
[	O
i	int
]	O
)	O
;	O
linepos	double
+=	O
CHAR_WIDTH	O
(	O
ch	char
)	O
;	O
col	int
++	O
;	O
}	O
else	O
if	O
(	O
ch	char
==	O
'('	O
||	O
ch	char
==	O
')'	O
||	O
ch	char
==	O
'\\'	O
)	O
{	O
APPEND_CHAR	O
(	O
'\\'	O
)	O
;	O
EMIT	O
(	O
ch	char
)	O
;	O
}	O
else	O
EMIT	O
(	O
ch	char
)	O
;	O
}	O
else	O
{	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
done	int
=	O
DONE_WRAP	int
;	O
}	O
}	O
else	O
if	O
(	O
ISPRINT	O
(	O
ch	char
)	O
)	O
{	O
if	O
(	O
FITS_ON_LINE	O
(	O
'?'	O
)	O
)	O
{	O
EMIT	O
(	O
'?'	O
)	O
;	O
if	O
(	O
missing_chars	array
[	O
ch	char
]	O
++	O
==	O
0	int
)	O
num_missing_chars	int
++	O
;	O
}	O
else	O
{	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
done	int
=	O
DONE_WRAP	int
;	O
}	O
}	O
else	O
{	O
char	O
buf	pointer
[	O
20	int
]	O
;	O
double	O
len	long
=	O
0.0	int
;	O
if	O
(	O
non_printable_chars	array
[	O
ch	char
]	O
++	O
==	O
0	int
)	O
num_non_printable_chars	int
++	O
;	O
switch	O
(	O
non_printable_format	enum
)	O
{	O
case	O
NPF_SPACE	int
:	O
strcpy	function
(	O
buf	pointer
,	O
" "	pointer
)	O
;	O
break	O
;	O
case	O
NPF_QUESTIONMARK	int
:	O
strcpy	function
(	O
buf	pointer
,	O
"?"	pointer
)	O
;	O
break	O
;	O
case	O
NPF_CARET	int
:	O
if	O
(	O
ch	char
<	O
0x20	int
)	O
{	O
buf	pointer
[	O
0	int
]	O
=	O
'^'	O
;	O
buf	pointer
[	O
1	int
]	O
=	O
'@'	O
+	O
ch	char
;	O
buf	pointer
[	O
2	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
}	O
case	O
NPF_OCTAL	int
:	O
sprintf	function
(	O
buf	pointer
,	O
"\\%03o"	pointer
,	O
ch	char
)	O
;	O
break	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
buf	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
len	long
+=	O
CHAR_WIDTH	O
(	O
buf	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
linepos	double
+	O
len	long
<	O
linew	double
||	O
col	int
==	O
0	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
buf	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
buf	pointer
[	O
i	int
]	O
==	O
'\\'	O
)	O
APPEND_CHAR	O
(	O
'\\'	O
)	O
;	O
EMIT	O
(	O
buf	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
else	O
{	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
done	int
=	O
DONE_WRAP	int
;	O
}	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
done	int
==	O
DONE_WRAP	int
)	O
{	O
ch	char
=	O
nl	int
;	O
if	O
(	O
line_end	enum
==	O
LE_TRUNCATE	int
)	O
{	O
while	O
(	O
(	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
)	O
!=	O
EOF	O
&&	O
ch	char
!=	O
nl	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
BUFFER_EMPTY	O
(	O
)	O
&&	O
line_end	enum
==	O
LE_WORD_WRAP	int
)	O
{	O
int	O
w	int
;	O
if	O
(	O
ISSPACE	O
(	O
buffer	pointer
[	O
bufpos	int
-	O
1	int
]	O
)	O
)	O
{	O
while	O
(	O
(	O
w	int
=	O
is_getc	function
(	O
is	pointer
)	O
)	O
!=	O
EOF	O
&&	O
ISSPACE	O
(	O
w	int
)	O
)	O
;	O
is_ungetc	function
(	O
w	int
,	O
is	pointer
)	O
;	O
}	O
else	O
{	O
for	O
(	O
w	int
=	O
bufpos	int
-	O
1	int
;	O
w	int
>=	O
0	int
&&	O
!	O
ISSPACE	O
(	O
buffer	pointer
[	O
w	int
]	O
)	O
;	O
w	int
--	O
)	O
;	O
w	int
++	O
;	O
if	O
(	O
w	int
>	O
0	int
||	O
original_col	int
>	O
0	int
)	O
{	O
do	O
{	O
bufpos	int
--	O
;	O
if	O
(	O
bufpos	int
>	O
w	int
&&	O
(	O
buffer	pointer
[	O
bufpos	int
]	O
==	O
'('	O
||	O
buffer	pointer
[	O
bufpos	int
]	O
==	O
')'	O
||	O
buffer	pointer
[	O
bufpos	int
]	O
==	O
'\\'	O
)	O
&&	O
buffer	pointer
[	O
bufpos	int
-	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
is_ungetc	function
(	O
buffer	pointer
[	O
bufpos	int
]	O
,	O
is	pointer
)	O
;	O
UNEMIT	O
(	O
buffer	pointer
[	O
bufpos	int
]	O
)	O
;	O
bufpos	int
--	O
;	O
}	O
else	O
if	O
(	O
bufpos	int
-	O
2	int
>	O
w	int
&&	O
ISOCTAL	O
(	O
buffer	pointer
[	O
bufpos	int
]	O
)	O
&&	O
ISOCTAL	O
(	O
buffer	pointer
[	O
bufpos	int
-	O
1	int
]	O
)	O
&&	O
ISOCTAL	O
(	O
buffer	pointer
[	O
bufpos	int
-	O
2	int
]	O
)	O
&&	O
buffer	pointer
[	O
bufpos	int
-	O
3	int
]	O
==	O
'\\'	O
)	O
{	O
unsigned	O
int	O
ti	int
;	O
for	O
(	O
ti	int
=	O
w	int
;	O
ti	int
<	O
bufpos	int
-	O
3	int
;	O
ti	int
++	O
)	O
{	O
if	O
(	O
buffer	pointer
[	O
ti	int
]	O
==	O
'\\'	O
)	O
{	O
if	O
(	O
ISOCTAL	O
(	O
buffer	pointer
[	O
ti	int
+	O
1	int
]	O
)	O
)	O
{	O
unsigned	O
int	O
tti	int
;	O
for	O
(	O
tti	int
=	O
0	int
;	O
tti	int
<	O
3	int
&&	O
ISOCTAL	O
(	O
buffer	pointer
[	O
ti	int
+	O
1	int
]	O
)	O
;	O
tti	int
++	O
,	O
ti	int
++	O
)	O
;	O
}	O
else	O
ti	int
++	O
;	O
}	O
}	O
if	O
(	O
ti	int
==	O
bufpos	int
-	O
3	int
)	O
{	O
int	O
tch	int
;	O
tch	int
=	O
(	O
(	O
(	O
buffer	pointer
[	O
bufpos	int
-	O
2	int
]	O
-	O
'0'	O
)	O
<<	O
6	int
)	O
+	O
(	O
(	O
buffer	pointer
[	O
bufpos	int
-	O
1	int
]	O
-	O
'0'	O
)	O
<<	O
3	int
)	O
+	O
(	O
buffer	pointer
[	O
bufpos	int
]	O
-	O
'0'	O
)	O
)	O
;	O
is_ungetc	function
(	O
tch	int
,	O
is	pointer
)	O
;	O
UNEMIT	O
(	O
tch	int
)	O
;	O
bufpos	int
-=	O
3	int
;	O
}	O
else	O
goto	O
unemit_normal	O
;	O
}	O
else	O
{	O
unemit_normal	O
:	O
is_ungetc	function
(	O
buffer	pointer
[	O
bufpos	int
]	O
,	O
is	pointer
)	O
;	O
UNEMIT	O
(	O
buffer	pointer
[	O
bufpos	int
]	O
)	O
;	O
}	O
}	O
while	O
(	O
bufpos	int
>	O
w	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
ch	char
==	O
nl	int
)	O
{	O
if	O
(	O
line_end	enum
==	O
LE_TRUNCATE	int
)	O
{	O
if	O
(	O
do_print	int
)	O
num_truncated_lines	int
++	O
;	O
pending_token	int
=	O
tNEWLINE	int
;	O
}	O
else	O
pending_token	int
=	O
tWRAPPED_NEWLINE	int
;	O
}	O
else	O
pending_token	int
=	O
tEOF	int
;	O
}	O
APPEND_CHAR	O
(	O
'\0'	O
)	O
;	O
token	pointer
->	O
type	int
=	O
tSTRING	int
;	O
token	pointer
->	O
u	union
.	O
str	pointer
=	O
(	O
char	O
*	O
)	O
buffer	pointer
;	O
token	pointer
->	O
new_x	double
=	O
linepos	double
;	O
token	pointer
->	O
new_col	int
=	O
col	int
;	O
}	O
static	O
void	O
dump_ps_page_header	function
(	O
char	O
*	O
fname	pointer
,	O
int	O
empty	int
)	O
{	O
char	O
*	O
dirc	pointer
,	O
*	O
basec	pointer
,	O
*	O
fdir	pointer
,	O
*	O
ftail	pointer
;	O
int	O
got	int
,	O
i	int
;	O
char	O
*	O
cp	pointer
,	O
*	O
cp2	pointer
;	O
char	O
*	O
cstr	pointer
=	O
"%%"	pointer
;	O
unsigned	O
int	O
nup_subpage	int
;	O
nup_subpage	int
=	O
(	O
total_pages	int
-	O
1	int
)	O
%	O
nup	int
;	O
dirc	pointer
=	O
strdup	function
(	O
fname	pointer
)	O
;	O
basec	pointer
=	O
strdup	function
(	O
fname	pointer
)	O
;	O
fdir	pointer
=	O
dirname	function
(	O
dirc	pointer
)	O
;	O
ftail	pointer
=	O
basename	O
(	O
basec	pointer
)	O
;	O
if	O
(	O
nup	int
>	O
1	int
)	O
{	O
cstr	pointer
=	O
"%"	pointer
;	O
if	O
(	O
nup_subpage	int
==	O
0	int
)	O
{	O
switch	O
(	O
page_label	enum
)	O
{	O
case	O
LABEL_SHORT	int
:	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%Page: (%d-%d) %d\n"	pointer
,	O
current_pagenum	int
,	O
current_pagenum	int
+	O
nup	int
-	O
1	int
,	O
total_pages	int
/	O
nup	int
+	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
LABEL_LONG	int
:	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%Page: (%s:%3d-%3d) %d\n"	pointer
,	O
ftail	pointer
,	O
current_pagenum	int
,	O
current_pagenum	int
+	O
nup	int
-	O
1	int
,	O
total_pages	int
/	O
nup	int
+	O
1	int
)	O
)	O
;	O
break	O
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%BeginPageSetup\n_S\n"	pointer
)	O
)	O
;	O
if	O
(	O
(	O
total_pages	int
/	O
nup	int
+	O
1	int
)	O
%	O
2	int
==	O
0	int
)	O
handle_two_side_options	function
(	O
)	O
;	O
if	O
(	O
landscape	int
)	O
{	O
if	O
(	O
nup_landscape	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"90 rotate\n%d %d translate\n"	pointer
,	O
media	pointer
->	O
lly	double
,	O
-	O
media	pointer
->	O
urx	double
)	O
)	O
;	O
else	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%d %d translate\n"	pointer
,	O
media	pointer
->	O
llx	double
,	O
media	pointer
->	O
lly	double
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
nup_landscape	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"90 rotate\n%d %d translate\n"	pointer
,	O
media	pointer
->	O
lly	double
,	O
-	O
media	pointer
->	O
llx	double
)	O
)	O
;	O
else	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%d %d translate\n"	pointer
,	O
media	pointer
->	O
llx	double
,	O
media	pointer
->	O
ury	double
)	O
)	O
;	O
}	O
}	O
}	O
switch	O
(	O
page_label	enum
)	O
{	O
case	O
LABEL_SHORT	int
:	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%sPage: (%d) %d\n"	pointer
,	O
cstr	pointer
,	O
current_pagenum	int
,	O
total_pages	int
)	O
)	O
;	O
break	O
;	O
case	O
LABEL_LONG	int
:	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%sPage: (%s:%3d) %d\n"	pointer
,	O
cstr	pointer
,	O
ftail	pointer
,	O
current_pagenum	int
,	O
total_pages	int
)	O
)	O
;	O
break	O
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%sBeginPageSetup\n_S\n"	pointer
,	O
cstr	pointer
)	O
)	O
;	O
if	O
(	O
nup	int
>	O
1	int
)	O
{	O
int	O
xm	int
,	O
ym	int
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%% N-up sub-page %d/%d\n"	pointer
,	O
nup_subpage	int
+	O
1	int
,	O
nup	int
)	O
)	O
;	O
if	O
(	O
landscape	int
)	O
{	O
if	O
(	O
nup_columnwise	int
)	O
{	O
xm	int
=	O
nup_subpage	int
%	O
nup_columns	int
;	O
ym	int
=	O
nup_subpage	int
/	O
nup_columns	int
;	O
}	O
else	O
{	O
xm	int
=	O
nup_subpage	int
/	O
nup_rows	int
;	O
ym	int
=	O
nup_subpage	int
%	O
nup_rows	int
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%d %d translate\n"	pointer
,	O
xm	int
*	O
(	O
nup_width	int
+	O
nup_xpad	int
)	O
,	O
ym	int
*	O
(	O
nup_height	int
+	O
nup_ypad	int
)	O
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
nup_columnwise	int
)	O
{	O
xm	int
=	O
nup_subpage	int
/	O
nup_rows	int
;	O
ym	int
=	O
nup_subpage	int
%	O
nup_rows	int
;	O
}	O
else	O
{	O
xm	int
=	O
nup_subpage	int
%	O
nup_columns	int
;	O
ym	int
=	O
nup_subpage	int
/	O
nup_columns	int
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%d %d translate\n"	pointer
,	O
xm	int
*	O
(	O
nup_width	int
+	O
nup_xpad	int
)	O
,	O
-	O
(	O
(	O
int	O
)	O
(	O
ym	int
*	O
(	O
nup_height	int
+	O
nup_ypad	int
)	O
+	O
nup_height	int
)	O
)	O
)	O
)	O
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g dup scale\n"	pointer
,	O
nup_scale	double
)	O
)	O
;	O
if	O
(	O
landscape	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"90 rotate\n%d %d translate\n"	pointer
,	O
0	int
,	O
-	O
d_page_h	int
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
total_pages	int
%	O
2	int
==	O
0	int
)	O
handle_two_side_options	function
(	O
)	O
;	O
if	O
(	O
landscape	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"90 rotate\n%d %d translate\n"	pointer
,	O
media	pointer
->	O
lly	double
,	O
-	O
media	pointer
->	O
urx	double
)	O
)	O
;	O
else	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%d %d translate\n"	pointer
,	O
media	pointer
->	O
llx	double
,	O
media	pointer
->	O
lly	double
)	O
)	O
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/pagenum %d def\n"	pointer
,	O
current_pagenum	int
)	O
)	O
;	O
cp	pointer
=	O
escape_string	function
(	O
fname	pointer
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/fname (%s) def\n"	pointer
,	O
cp	pointer
)	O
)	O
;	O
xfree	function
(	O
cp	pointer
)	O
;	O
cp	pointer
=	O
escape_string	function
(	O
fdir	pointer
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/fdir (%s) def\n"	pointer
,	O
cp	pointer
)	O
)	O
;	O
xfree	function
(	O
cp	pointer
)	O
;	O
xfree	function
(	O
dirc	pointer
)	O
;	O
cp	pointer
=	O
escape_string	function
(	O
ftail	pointer
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/ftail (%s) def\n"	pointer
,	O
cp	pointer
)	O
)	O
;	O
xfree	function
(	O
cp	pointer
)	O
;	O
xfree	function
(	O
basec	pointer
)	O
;	O
if	O
(	O
user_fontp	int
)	O
{	O
if	O
(	O
encoding	array
==	O
default_Fencoding	enum
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/%s %g %g SUF\n"	pointer
,	O
Fname	pointer
,	O
Fpt	struct
.	O
w	int
,	O
Fpt	struct
.	O
h	int
)	O
)	O
;	O
else	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/%s %g %g SUF_PS\n"	pointer
,	O
Fname	pointer
,	O
Fpt	struct
.	O
w	int
,	O
Fpt	struct
.	O
h	int
)	O
)	O
;	O
}	O
if	O
(	O
count_key_value_set	function
(	O
user_strings	pointer
)	O
>	O
0	int
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%% User defined strings:\n"	pointer
)	O
)	O
;	O
for	O
(	O
got	int
=	O
strhash_get_first	function
(	O
user_strings	pointer
,	O
&	O
cp	pointer
,	O
&	O
i	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
;	O
got	int
;	O
got	int
=	O
strhash_get_next	function
(	O
user_strings	pointer
,	O
&	O
cp	pointer
,	O
&	O
i	int
,	O
(	O
void	O
*	O
*	O
)	O
&	O
cp2	pointer
)	O
)	O
{	O
cp2	pointer
=	O
format_user_string	function
(	O
"%Format"	pointer
,	O
cp2	pointer
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/%s (%s) def\n"	pointer
,	O
cp	pointer
,	O
cp2	pointer
)	O
)	O
;	O
xfree	function
(	O
cp2	pointer
)	O
;	O
}	O
}	O
if	O
(	O
page_header	pointer
)	O
{	O
char	O
*	O
h_left	pointer
;	O
char	O
*	O
h_center	pointer
;	O
char	O
*	O
h_right	pointer
=	O
NULL	O
;	O
h_left	pointer
=	O
format_user_string	function
(	O
"page header"	pointer
,	O
page_header	pointer
)	O
;	O
h_center	pointer
=	O
strchr	function
(	O
h_left	pointer
,	O
'|'	O
)	O
;	O
if	O
(	O
h_center	pointer
)	O
{	O
*	O
h_center	pointer
=	O
'\0'	O
;	O
h_center	pointer
++	O
;	O
h_right	pointer
=	O
strchr	function
(	O
h_center	pointer
,	O
'|'	O
)	O
;	O
if	O
(	O
h_right	pointer
)	O
{	O
*	O
h_right	pointer
=	O
'\0'	O
;	O
h_right	pointer
++	O
;	O
}	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/user_header_p true def\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/user_header_left_str (%s) def\n"	pointer
,	O
h_left	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/user_header_center_str (%s) def\n"	pointer
,	O
h_center	pointer
?	O
h_center	pointer
:	O
""	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/user_header_right_str (%s) def\n"	pointer
,	O
h_right	pointer
?	O
h_right	pointer
:	O
""	pointer
)	O
)	O
;	O
xfree	function
(	O
h_left	pointer
)	O
;	O
}	O
else	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/user_header_p false def\n"	pointer
)	O
)	O
;	O
if	O
(	O
page_footer	pointer
)	O
{	O
char	O
*	O
f_left	pointer
;	O
char	O
*	O
f_center	pointer
;	O
char	O
*	O
f_right	pointer
=	O
NULL	O
;	O
f_left	pointer
=	O
format_user_string	function
(	O
"page footer"	pointer
,	O
page_footer	pointer
)	O
;	O
f_center	pointer
=	O
strchr	function
(	O
f_left	pointer
,	O
'|'	O
)	O
;	O
if	O
(	O
f_center	pointer
)	O
{	O
*	O
f_center	pointer
=	O
'\0'	O
;	O
f_center	pointer
++	O
;	O
f_right	pointer
=	O
strchr	function
(	O
f_center	pointer
,	O
'|'	O
)	O
;	O
if	O
(	O
f_right	pointer
)	O
{	O
*	O
f_right	pointer
=	O
'\0'	O
;	O
f_right	pointer
++	O
;	O
}	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/user_footer_p true def\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/user_footer_left_str (%s) def\n"	pointer
,	O
f_left	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/user_footer_center_str (%s) def\n"	pointer
,	O
f_center	pointer
?	O
f_center	pointer
:	O
""	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/user_footer_right_str (%s) def\n"	pointer
,	O
f_right	pointer
?	O
f_right	pointer
:	O
""	pointer
)	O
)	O
;	O
xfree	function
(	O
f_left	pointer
)	O
;	O
}	O
else	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/user_footer_p false def\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%EndPageSetup\n"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
empty	int
)	O
{	O
if	O
(	O
highlight_bars	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%d %f %d %f highlight_bars\n"	pointer
,	O
highlight_bars	int
,	O
LINESKIP	O
,	O
d_output_y_margin	int
,	O
highlight_bar_gray	double
)	O
)	O
;	O
if	O
(	O
underlay	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
ul_position_p	int
||	O
ul_angle_p	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"user_underlay\n"	pointer
)	O
)	O
;	O
else	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"underlay\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
num_columns	int
>	O
1	int
&&	O
(	O
header	enum
==	O
HDR_FANCY	int
||	O
borders	int
)	O
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"column_lines\n"	pointer
)	O
)	O
;	O
if	O
(	O
borders	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"column_borders\n"	pointer
)	O
)	O
;	O
switch	O
(	O
header	enum
)	O
{	O
case	O
HDR_NONE	int
:	O
break	O
;	O
case	O
HDR_SIMPLE	int
:	O
case	O
HDR_FANCY	int
:	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"do_header\n"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
user_colorp	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g %g setrgbcolor\n"	pointer
,	O
user_color	struct
.	O
r	float
,	O
user_color	struct
.	O
g	float
,	O
user_color	struct
.	O
b	float
)	O
)	O
;	O
}	O
static	O
void	O
dump_ps_page_trailer	function
(	O
)	O
{	O
unsigned	O
int	O
nup_subpage	int
=	O
(	O
total_pages	int
-	O
1	int
)	O
%	O
nup	int
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"_R\n"	pointer
)	O
)	O
;	O
if	O
(	O
nup	int
>	O
1	int
)	O
{	O
if	O
(	O
nup_subpage	int
+	O
1	int
==	O
nup	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"_R\nS\n"	pointer
)	O
)	O
;	O
}	O
else	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"S\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
dump_empty_page	function
(	O
)	O
{	O
if	O
(	O
nup	int
>	O
1	int
)	O
{	O
unsigned	O
int	O
nup_subpage	int
=	O
(	O
total_pages	int
-	O
1	int
)	O
%	O
nup	int
;	O
if	O
(	O
nup_subpage	int
==	O
0	int
)	O
{	O
dump_ps_page_header	function
(	O
""	pointer
,	O
1	int
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"_R\n"	pointer
)	O
)	O
;	O
}	O
else	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%Page: (-) %d\n"	pointer
,	O
total_pages	int
)	O
)	O
;	O
if	O
(	O
nup_subpage	int
+	O
1	int
==	O
nup	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"_R\nS\n"	pointer
)	O
)	O
;	O
}	O
else	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%Page: (-) %d\nS\n"	pointer
,	O
total_pages	int
)	O
)	O
;	O
}	O
static	O
int	O
recognize_eps_file	function
(	O
Token	struct
*	O
token	pointer
)	O
{	O
int	O
i	int
;	O
char	O
buf	pointer
[	O
4096	int
]	O
;	O
char	O
*	O
filename	pointer
;	O
int	O
line	int
;	O
int	O
valid_epsf	int
;	O
float	O
llx	double
,	O
lly	double
,	O
urx	double
,	O
ury	double
;	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"^@epsf=\"%s\"\n"	pointer
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
)	O
)	O
;	O
i	int
=	O
strlen	function
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
)	O
;	O
filename	pointer
=	O
tilde_subst	function
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
)	O
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
fp	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"rb"	pointer
)	O
;	O
xfree	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
fp	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
[	O
0	int
]	O
!=	O
'/'	O
)	O
{	O
FileLookupCtx	struct
ctx	struct
;	O
ctx	struct
.	O
name	pointer
=	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
;	O
ctx	struct
.	O
suffix	pointer
=	O
""	pointer
;	O
ctx	struct
.	O
fullname	pointer
=	O
buffer_alloc	function
(	O
)	O
;	O
if	O
(	O
pathwalk	function
(	O
libpath	pointer
,	O
file_lookup	function
,	O
&	O
ctx	struct
)	O
)	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
fp	pointer
=	O
fopen	function
(	O
buffer_ptr	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
,	O
"rb"	pointer
)	O
;	O
buffer_free	function
(	O
ctx	struct
.	O
fullname	pointer
)	O
;	O
}	O
if	O
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
fp	pointer
==	O
NULL	O
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't open EPS file \"%s\": %s\n"	pointer
)	O
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
line	int
=	O
0	int
;	O
valid_epsf	int
=	O
0	int
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf	pointer
=	O
NULL	O
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf_len	int
=	O
0	int
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf_pos	int
=	O
0	int
;	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
fp	pointer
)	O
)	O
{	O
line	int
++	O
;	O
i	int
=	O
strlen	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
i	int
+	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf_pos	int
>=	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf_len	int
)	O
{	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf_len	int
+=	O
8192	int
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf	pointer
=	O
xrealloc	function
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf	pointer
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf_len	int
)	O
;	O
}	O
memcpy	function
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf	pointer
+	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf_pos	int
,	O
buf	pointer
,	O
i	int
)	O
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf_pos	int
+=	O
i	int
;	O
if	O
(	O
line	int
==	O
1	int
)	O
{	O
if	O
(	O
buf	pointer
[	O
0	int
]	O
!=	O
'%'	O
||	O
buf	pointer
[	O
1	int
]	O
!=	O
'!'	O
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"EPS file \"%s\" does not start with \"%%!\" magic\n"	pointer
)	O
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
BB_DSC	pointer
,	O
strlen	function
(	O
BB_DSC	pointer
)	O
)	O
==	O
0	int
)	O
{	O
i	int
=	O
sscanf	function
(	O
buf	pointer
+	O
strlen	function
(	O
BB_DSC	pointer
)	O
,	O
"%f %f %f %f"	pointer
,	O
&	O
llx	double
,	O
&	O
lly	double
,	O
&	O
urx	double
,	O
&	O
ury	double
)	O
;	O
if	O
(	O
i	int
!=	O
4	int
)	O
{	O
for	O
(	O
i	int
=	O
strlen	function
(	O
BB_DSC	pointer
)	O
;	O
buf	pointer
[	O
i	int
]	O
&&	O
(	O
buf	pointer
[	O
i	int
]	O
==	O
' '	O
||	O
buf	pointer
[	O
i	int
]	O
==	O
'\t'	O
)	O
;	O
i	int
++	O
)	O
;	O
if	O
(	O
strncmp	function
(	O
buf	pointer
+	O
i	int
,	O
BB_DSC_ATEND	pointer
,	O
strlen	function
(	O
BB_DSC_ATEND	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"EPS file \"%s\" contains malformed %%%%BoundingBox row:\n\"%.*s\"\n"	pointer
)	O
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
,	O
strlen	function
(	O
buf	pointer
)	O
-	O
1	int
,	O
buf	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
llx	double
=	O
llx	double
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
lly	double
=	O
lly	double
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
urx	double
=	O
urx	double
;	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
ury	double
=	O
ury	double
;	O
valid_epsf	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
valid_epsf	int
)	O
{	O
MESSAGE	O
(	O
0	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"EPS file \"%s\" is not a valid EPS file\n"	pointer
)	O
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
)	O
)	O
;	O
if	O
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
pipe	function
)	O
pclose	function
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
fp	pointer
)	O
;	O
else	O
fclose	function
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
fp	pointer
)	O
;	O
xfree	function
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf	pointer
)	O
;	O
return	O
0	int
;	O
}	O
MESSAGE	O
(	O
2	int
,	O
(	O
stderr	pointer
,	O
"BoundingBox: %d %d %d %d\n"	pointer
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
llx	double
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
lly	double
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
urx	double
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
ury	double
)	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
paste_epsf	function
(	O
Token	struct
*	O
token	pointer
)	O
{	O
char	O
buf	pointer
[	O
4096	int
]	O
;	O
int	O
i	int
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"BeginEPSF\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g translate\n"	pointer
,	O
token	pointer
->	O
new_x	double
,	O
token	pointer
->	O
new_y	double
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g scale\n"	pointer
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
xscale	double
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
yscale	double
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%d %d translate\n"	pointer
,	O
-	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
llx	double
,	O
-	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
lly	double
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%d %d %d %d Box clip newpath\n"	pointer
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
llx	double
-	O
1	int
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
lly	double
-	O
1	int
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
urx	double
-	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
llx	double
+	O
2	int
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
ury	double
-	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
lly	double
+	O
2	int
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%BeginDocument: %s%s\n"	pointer
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
filename	pointer
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
pipe	function
?	O
"|"	pointer
:	O
""	pointer
)	O
)	O
;	O
if	O
(	O
do_print	int
)	O
{	O
fwrite	function
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf	pointer
,	O
1	int
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf_pos	int
,	O
cofp	pointer
)	O
;	O
while	O
(	O
(	O
i	int
=	O
fread	function
(	O
buf	pointer
,	O
1	int
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
fp	pointer
)	O
)	O
!=	O
0	int
)	O
fwrite	function
(	O
buf	pointer
,	O
1	int
,	O
i	int
,	O
cofp	pointer
)	O
;	O
}	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"\n"	pointer
)	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%EndDocument\nEndEPSF\n"	pointer
)	O
)	O
;	O
if	O
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
pipe	function
)	O
pclose	function
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
fp	pointer
)	O
;	O
else	O
fclose	function
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
fp	pointer
)	O
;	O
xfree	function
(	O
token	pointer
->	O
u	union
.	O
epsf	struct
.	O
skipbuf	pointer
)	O
;	O
}	O
static	O
double	O
read_float	function
(	O
InputStream	struct
*	O
is	pointer
,	O
int	O
units	int
,	O
int	O
horizontal	int
)	O
{	O
char	O
buf	pointer
[	O
256	int
]	O
;	O
int	O
i	int
,	O
ch	char
;	O
double	O
val	double
;	O
for	O
(	O
i	int
=	O
0	int
;	O
(	O
i	int
<	O
sizeof	O
(	O
buf	pointer
)	O
-	O
1	int
&&	O
(	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
)	O
!=	O
EOF	O
&&	O
ISNUMBERDIGIT	O
(	O
ch	char
)	O
)	O
;	O
i	int
++	O
)	O
buf	pointer
[	O
i	int
]	O
=	O
ch	char
;	O
buf	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
ch	char
!=	O
EOF	O
)	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
val	double
=	O
atof	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
units	int
)	O
{	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
;	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'c'	O
:	O
val	double
*=	O
72	int
/	O
2.54	int
;	O
break	O
;	O
case	O
'p'	O
:	O
break	O
;	O
case	O
'i'	O
:	O
val	double
*=	O
72	int
;	O
break	O
;	O
default	O
:	O
is_ungetc	function
(	O
ch	char
,	O
is	pointer
)	O
;	O
case	O
'l'	O
:	O
if	O
(	O
horizontal	int
)	O
val	double
*=	O
CHAR_WIDTH	O
(	O
'm'	O
)	O
;	O
else	O
val	double
*=	O
LINESKIP	O
;	O
break	O
;	O
}	O
}	O
return	O
val	double
;	O
}	O
static	O
struct	O
{	O
char	O
*	O
magic	pointer
;	O
unsigned	O
int	O
magiclen	int
;	O
char	O
*	O
name	pointer
;	O
int	O
revert_delta	int
;	O
}	O
pass_through_magics	array
[	O
]	O
=	O
{	O
{	O
"%!"	pointer
,	O
2	int
,	O
"PostScript"	pointer
,	O
-	O
2	int
}	O
,	O
{	O
"\004%!"	pointer
,	O
3	int
,	O
"PostScript"	pointer
,	O
-	O
2	int
}	O
,	O
{	O
"\033E"	pointer
,	O
2	int
,	O
"PCL"	pointer
,	O
-	O
2	int
}	O
,	O
{	O
"\033%"	pointer
,	O
2	int
,	O
"PCL"	pointer
,	O
-	O
2	int
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
,	O
}	O
;	O
static	O
int	O
do_pass_through	function
(	O
char	O
*	O
fname	pointer
,	O
InputStream	struct
*	O
is	pointer
)	O
{	O
int	O
ch	char
;	O
unsigned	O
long	O
saved_pos	long
=	O
is	pointer
->	O
bufpos	int
;	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
output_language_pass_through	int
)	O
MESSAGE	O
(	O
1	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"passing through all input files for output language `%s'\n"	pointer
)	O
,	O
output_language	pointer
)	O
)	O
;	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
pass_through_magics	array
[	O
i	int
]	O
.	O
magic	pointer
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
pass_through_magics	array
[	O
i	int
]	O
.	O
magiclen	int
;	O
j	int
++	O
)	O
{	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
;	O
if	O
(	O
ch	char
==	O
EOF	O
||	O
ch	char
!=	O
(	O
unsigned	O
char	O
)	O
pass_through_magics	array
[	O
i	int
]	O
.	O
magic	pointer
[	O
j	int
]	O
)	O
break	O
;	O
}	O
if	O
(	O
j	int
>=	O
pass_through_magics	array
[	O
i	int
]	O
.	O
magiclen	int
)	O
break	O
;	O
is	pointer
->	O
bufpos	int
=	O
saved_pos	long
;	O
}	O
if	O
(	O
pass_through_magics	array
[	O
i	int
]	O
.	O
magic	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
is	pointer
->	O
bufpos	int
+=	O
pass_through_magics	array
[	O
i	int
]	O
.	O
revert_delta	int
;	O
if	O
(	O
ps_header_dumped	int
)	O
{	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%Page: (%s) -1\n_S\n%%%%BeginDocument: %s\n"	pointer
,	O
fname	pointer
,	O
fname	pointer
)	O
)	O
;	O
}	O
MESSAGE	O
(	O
1	int
,	O
(	O
stderr	pointer
,	O
_	O
(	O
"passing through %s file \"%s\"\n"	pointer
)	O
,	O
pass_through_magics	array
[	O
i	int
]	O
.	O
name	pointer
,	O
fname	pointer
)	O
)	O
;	O
}	O
do	O
{	O
fwrite	function
(	O
is	pointer
->	O
buf	pointer
+	O
is	pointer
->	O
bufpos	int
,	O
1	int
,	O
is	pointer
->	O
data_in_buf	int
-	O
is	pointer
->	O
bufpos	int
,	O
ofp	pointer
)	O
;	O
is	pointer
->	O
bufpos	int
=	O
is	pointer
->	O
data_in_buf	int
;	O
ch	char
=	O
is_getc	function
(	O
is	pointer
)	O
;	O
is	pointer
->	O
bufpos	int
=	O
0	int
;	O
}	O
while	O
(	O
ch	char
!=	O
EOF	O
)	O
;	O
if	O
(	O
!	O
output_language_pass_through	int
)	O
{	O
if	O
(	O
ps_header_dumped	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%%%%EndDocument\n_R\n"	pointer
)	O
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
print_line_number	function
(	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
space	double
,	O
double	O
margin	double
,	O
unsigned	O
int	O
linenum	int
)	O
{	O
double	O
len	long
=	O
0.0	int
;	O
char	O
buf	pointer
[	O
20	int
]	O
;	O
int	O
i	int
;	O
char	O
*	O
saved_Fname	pointer
=	O
""	pointer
;	O
FontPoint	struct
saved_Fpt	struct
;	O
InputEncoding	enum
saved_Fencoding	enum
;	O
saved_Fpt	struct
.	O
w	int
=	O
0.0	int
;	O
saved_Fpt	struct
.	O
h	int
=	O
0.0	int
;	O
if	O
(	O
linenum	int
==	O
print_line_number_last	int
)	O
return	O
;	O
print_line_number_last	int
=	O
linenum	int
;	O
if	O
(	O
user_fontp	int
)	O
{	O
saved_Fname	pointer
=	O
Fname	pointer
;	O
saved_Fpt	struct
.	O
w	int
=	O
Fpt	struct
.	O
w	int
;	O
saved_Fpt	struct
.	O
h	int
=	O
Fpt	struct
.	O
h	int
;	O
saved_Fencoding	enum
=	O
encoding	array
;	O
Fname	pointer
=	O
default_Fname	pointer
;	O
Fpt	struct
.	O
w	int
=	O
default_Fpt	struct
.	O
w	int
;	O
Fpt	struct
.	O
h	int
=	O
default_Fpt	struct
.	O
h	int
;	O
encoding	array
=	O
default_Fencoding	enum
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/F-gs-font %g %g SF\n"	pointer
,	O
Fpt	struct
.	O
w	int
,	O
Fpt	struct
.	O
h	int
)	O
)	O
;	O
read_font_info	function
(	O
)	O
;	O
}	O
sprintf	function
(	O
buf	pointer
,	O
"%d"	pointer
,	O
linenum	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
buf	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
len	long
+=	O
CHAR_WIDTH	O
(	O
buf	pointer
[	O
i	int
]	O
)	O
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%g %g M (%s:) s\n"	pointer
,	O
x	double
+	O
space	double
-	O
len	long
,	O
y	double
,	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
user_fontp	int
)	O
{	O
Fname	pointer
=	O
saved_Fname	pointer
;	O
Fpt	struct
.	O
w	int
=	O
saved_Fpt	struct
.	O
w	int
;	O
Fpt	struct
.	O
h	int
=	O
saved_Fpt	struct
.	O
h	int
;	O
encoding	array
=	O
saved_Fencoding	enum
;	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"/%s %g %g SUF\n"	pointer
,	O
Fname	pointer
,	O
Fpt	struct
.	O
w	int
,	O
Fpt	struct
.	O
h	int
)	O
)	O
;	O
read_font_info	function
(	O
)	O
;	O
}	O
}	O
static	O
char	O
divertfname	array
[	O
512	int
]	O
;	O
static	O
void	O
divert	function
(	O
)	O
{	O
assert	O
(	O
divertfp	pointer
==	O
NULL	O
)	O
;	O
divertfp	pointer
=	O
tmpfile	function
(	O
)	O
;	O
if	O
(	O
divertfp	pointer
==	O
NULL	O
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't create temporary divert file: %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
cofp	pointer
=	O
divertfp	pointer
;	O
}	O
static	O
void	O
undivert	function
(	O
)	O
{	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
int	O
doc_level	int
=	O
0	int
;	O
char	O
*	O
cp	pointer
;	O
assert	O
(	O
divertfp	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
fseek	function
(	O
divertfp	pointer
,	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
FATAL	O
(	O
(	O
stderr	pointer
,	O
_	O
(	O
"couldn't rewind divert file: %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
)	O
;	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
divertfp	pointer
)	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
"%%BeginDocument"	pointer
,	O
15	int
)	O
==	O
0	int
)	O
doc_level	int
++	O
;	O
else	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
"%%EndDocument"	pointer
,	O
13	int
)	O
==	O
0	int
)	O
doc_level	int
--	O
;	O
if	O
(	O
doc_level	int
==	O
0	int
)	O
{	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
"% User defined strings"	pointer
,	O
22	int
)	O
==	O
0	int
)	O
{	O
fputs	function
(	O
buf	pointer
,	O
ofp	pointer
)	O
;	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
divertfp	pointer
)	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
buf	pointer
,	O
"%%EndPageSetup"	pointer
,	O
14	int
)	O
==	O
0	int
)	O
break	O
;	O
cp	pointer
=	O
strchr	function
(	O
buf	pointer
,	O
'\001'	O
)	O
;	O
if	O
(	O
cp	pointer
)	O
{	O
*	O
cp	pointer
=	O
'\0'	O
;	O
fputs	function
(	O
buf	pointer
,	O
ofp	pointer
)	O
;	O
fprintf	function
(	O
ofp	pointer
,	O
"%d"	pointer
,	O
total_pages_in_file	int
)	O
;	O
fputs	function
(	O
cp	pointer
+	O
1	int
,	O
ofp	pointer
)	O
;	O
}	O
else	O
fputs	function
(	O
buf	pointer
,	O
ofp	pointer
)	O
;	O
}	O
}	O
}	O
fputs	function
(	O
buf	pointer
,	O
ofp	pointer
)	O
;	O
}	O
fclose	function
(	O
divertfp	pointer
)	O
;	O
divertfp	pointer
=	O
NULL	O
;	O
cofp	pointer
=	O
ofp	pointer
;	O
}	O
static	O
void	O
handle_two_side_options	function
(	O
)	O
{	O
if	O
(	O
rotate_even_pages	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"180 rotate\n%d %d translate\n"	pointer
,	O
-	O
media	pointer
->	O
w	int
,	O
-	O
media	pointer
->	O
h	int
)	O
)	O
;	O
if	O
(	O
swap_even_page_margins	int
)	O
OUTPUT	O
(	O
(	O
cofp	pointer
,	O
"%d 0 translate\n"	pointer
,	O
-	O
(	O
media	pointer
->	O
llx	double
-	O
(	O
media	pointer
->	O
w	int
-	O
media	pointer
->	O
urx	double
)	O
)	O
)	O
)	O
;	O
}	O
