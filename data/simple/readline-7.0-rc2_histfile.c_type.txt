extern	O
void	O
_hs_append_history_line	function
PARAMS	O
(	O
(	O
int	O
,	O
const	O
char	O
*	O
)	O
)	O
;	O
int	O
history_file_version	int
=	O
1	int
;	O
int	O
history_write_timestamps	int
=	O
0	int
;	O
int	O
history_multiline_entries	int
=	O
0	int
;	O
int	O
history_lines_read_from_file	int
=	O
0	int
;	O
int	O
history_lines_written_to_file	int
=	O
0	int
;	O
static	O
char	O
*	O
history_backupfile	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
history_tempfile	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
histfile_backup	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
int	O
histfile_restore	function
PARAMS	O
(	O
(	O
const	O
char	O
*	O
,	O
const	O
char	O
*	O
)	O
)	O
;	O
static	O
char	O
*	O
history_filename	function
(	O
filename	pointer
)	O
const	O
char	O
*	O
filename	pointer
;	O
{	O
char	O
*	O
return_val	pointer
;	O
const	O
char	O
*	O
home	pointer
;	O
int	O
home_len	int
;	O
return_val	pointer
=	O
filename	pointer
?	O
savestring	O
(	O
filename	pointer
)	O
:	O
(	O
char	O
*	O
)	O
NULL	O
;	O
if	O
(	O
return_val	pointer
)	O
return	O
(	O
return_val	pointer
)	O
;	O
home	pointer
=	O
sh_get_env_value	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
home	pointer
==	O
0	int
)	O
return	O
(	O
NULL	O
)	O
;	O
else	O
home_len	int
=	O
strlen	function
(	O
home	pointer
)	O
;	O
return_val	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
2	int
+	O
home_len	int
+	O
8	int
)	O
;	O
strcpy	function
(	O
return_val	pointer
,	O
home	pointer
)	O
;	O
return_val	pointer
[	O
home_len	int
]	O
=	O
'/'	O
;	O
strcpy	function
(	O
return_val	pointer
+	O
home_len	int
+	O
1	int
,	O
".history"	pointer
)	O
;	O
return	O
(	O
return_val	pointer
)	O
;	O
}	O
static	O
char	O
*	O
history_backupfile	function
(	O
filename	pointer
)	O
const	O
char	O
*	O
filename	pointer
;	O
{	O
const	O
char	O
*	O
fn	pointer
;	O
char	O
*	O
ret	pointer
,	O
linkbuf	array
[	O
PATH_MAX	int
+	O
1	int
]	O
;	O
size_t	long
len	long
;	O
ssize_t	long
n	long
;	O
struct	O
stat	struct
fs	struct
;	O
fn	pointer
=	O
filename	pointer
;	O
if	O
(	O
(	O
n	long
=	O
readlink	function
(	O
filename	pointer
,	O
linkbuf	array
,	O
sizeof	O
(	O
linkbuf	array
)	O
-	O
1	int
)	O
)	O
>	O
0	int
)	O
{	O
linkbuf	array
[	O
n	long
]	O
=	O
'\0'	O
;	O
fn	pointer
=	O
linkbuf	array
;	O
}	O
len	long
=	O
strlen	function
(	O
fn	pointer
)	O
;	O
ret	pointer
=	O
xmalloc	function
(	O
len	long
+	O
2	int
)	O
;	O
strcpy	function
(	O
ret	pointer
,	O
fn	pointer
)	O
;	O
ret	pointer
[	O
len	long
]	O
=	O
'-'	O
;	O
ret	pointer
[	O
len	long
+	O
1	int
]	O
=	O
'\0'	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
char	O
*	O
history_tempfile	function
(	O
filename	pointer
)	O
const	O
char	O
*	O
filename	pointer
;	O
{	O
const	O
char	O
*	O
fn	pointer
;	O
char	O
*	O
ret	pointer
,	O
linkbuf	array
[	O
PATH_MAX	int
+	O
1	int
]	O
;	O
size_t	long
len	long
;	O
ssize_t	long
n	long
;	O
struct	O
stat	struct
fs	struct
;	O
int	O
pid	int
;	O
fn	pointer
=	O
filename	pointer
;	O
if	O
(	O
(	O
n	long
=	O
readlink	function
(	O
filename	pointer
,	O
linkbuf	array
,	O
sizeof	O
(	O
linkbuf	array
)	O
-	O
1	int
)	O
)	O
>	O
0	int
)	O
{	O
linkbuf	array
[	O
n	long
]	O
=	O
'\0'	O
;	O
fn	pointer
=	O
linkbuf	array
;	O
}	O
len	long
=	O
strlen	function
(	O
fn	pointer
)	O
;	O
ret	pointer
=	O
xmalloc	function
(	O
len	long
+	O
11	int
)	O
;	O
strcpy	function
(	O
ret	pointer
,	O
fn	pointer
)	O
;	O
pid	int
=	O
(	O
int	O
)	O
getpid	function
(	O
)	O
;	O
ret	pointer
[	O
len	long
]	O
=	O
'-'	O
;	O
ret	pointer
[	O
len	long
+	O
1	int
]	O
=	O
(	O
pid	int
/	O
10000	int
%	O
10	int
)	O
+	O
'0'	O
;	O
ret	pointer
[	O
len	long
+	O
2	int
]	O
=	O
(	O
pid	int
/	O
1000	int
%	O
10	int
)	O
+	O
'0'	O
;	O
ret	pointer
[	O
len	long
+	O
3	int
]	O
=	O
(	O
pid	int
/	O
100	int
%	O
10	int
)	O
+	O
'0'	O
;	O
ret	pointer
[	O
len	long
+	O
4	int
]	O
=	O
(	O
pid	int
/	O
10	int
%	O
10	int
)	O
+	O
'0'	O
;	O
ret	pointer
[	O
len	long
+	O
5	int
]	O
=	O
(	O
pid	int
%	O
10	int
)	O
+	O
'0'	O
;	O
strcpy	function
(	O
ret	pointer
+	O
len	long
+	O
6	int
,	O
".tmp"	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
int	O
read_history	function
(	O
filename	pointer
)	O
const	O
char	O
*	O
filename	pointer
;	O
{	O
return	O
(	O
read_history_range	function
(	O
filename	pointer
,	O
0	int
,	O
-	O
1	int
)	O
)	O
;	O
}	O
int	O
read_history_range	function
(	O
filename	pointer
,	O
from	int
,	O
to	int
)	O
const	O
char	O
*	O
filename	pointer
;	O
int	O
from	int
,	O
to	int
;	O
{	O
register	O
char	O
*	O
line_start	pointer
,	O
*	O
line_end	pointer
,	O
*	O
p	pointer
;	O
char	O
*	O
input	pointer
,	O
*	O
buffer	pointer
,	O
*	O
bufend	pointer
,	O
*	O
last_ts	pointer
;	O
int	O
file	int
,	O
current_line	int
,	O
chars_read	int
,	O
has_timestamps	int
,	O
reset_comment_char	int
;	O
struct	O
stat	struct
finfo	struct
;	O
size_t	long
file_size	long
;	O
int	O
overflow_errno	int
=	O
EFBIG	int
;	O
history_lines_read_from_file	int
=	O
0	int
;	O
buffer	pointer
=	O
last_ts	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
input	pointer
=	O
history_filename	function
(	O
filename	pointer
)	O
;	O
file	int
=	O
input	pointer
?	O
open	function
(	O
input	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
,	O
0666	int
)	O
:	O
-	O
1	int
;	O
if	O
(	O
(	O
file	int
<	O
0	int
)	O
||	O
(	O
fstat	function
(	O
file	int
,	O
&	O
finfo	struct
)	O
==	O
-	O
1	int
)	O
)	O
goto	O
error_and_exit	O
;	O
file_size	long
=	O
(	O
size_t	long
)	O
finfo	struct
.	O
st_size	long
;	O
if	O
(	O
file_size	long
!=	O
finfo	struct
.	O
st_size	long
||	O
file_size	long
+	O
1	int
<	O
file_size	long
)	O
{	O
errno	O
=	O
overflow_errno	int
;	O
goto	O
error_and_exit	O
;	O
}	O
buffer	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
file_size	long
+	O
1	int
)	O
;	O
if	O
(	O
buffer	pointer
==	O
0	int
)	O
{	O
errno	O
=	O
overflow_errno	int
;	O
goto	O
error_and_exit	O
;	O
}	O
chars_read	int
=	O
read	pointer
(	O
file	int
,	O
buffer	pointer
,	O
file_size	long
)	O
;	O
if	O
(	O
chars_read	int
<	O
0	int
)	O
{	O
error_and_exit	O
:	O
if	O
(	O
errno	O
!=	O
0	int
)	O
chars_read	int
=	O
errno	O
;	O
else	O
chars_read	int
=	O
EIO	int
;	O
if	O
(	O
file	int
>=	O
0	int
)	O
close	pointer
(	O
file	int
)	O
;	O
FREE	O
(	O
input	pointer
)	O
;	O
FREE	O
(	O
buffer	pointer
)	O
;	O
return	O
(	O
chars_read	int
)	O
;	O
}	O
close	pointer
(	O
file	int
)	O
;	O
if	O
(	O
to	int
<	O
0	int
)	O
to	int
=	O
chars_read	int
;	O
bufend	pointer
=	O
buffer	pointer
+	O
chars_read	int
;	O
current_line	int
=	O
0	int
;	O
reset_comment_char	int
=	O
0	int
;	O
if	O
(	O
history_comment_char	char
==	O
'\0'	O
&&	O
buffer	pointer
[	O
0	int
]	O
==	O
'#'	O
&&	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
buffer	pointer
[	O
1	int
]	O
)	O
)	O
{	O
history_comment_char	char
=	O
'#'	O
;	O
reset_comment_char	int
=	O
1	int
;	O
}	O
has_timestamps	int
=	O
HIST_TIMESTAMP_START	O
(	O
buffer	pointer
)	O
;	O
history_multiline_entries	int
+=	O
has_timestamps	int
&&	O
history_write_timestamps	int
;	O
for	O
(	O
line_start	pointer
=	O
line_end	pointer
=	O
buffer	pointer
;	O
line_end	pointer
<	O
bufend	pointer
&&	O
current_line	int
<	O
from	int
;	O
line_end	pointer
++	O
)	O
if	O
(	O
*	O
line_end	pointer
==	O
'\n'	O
)	O
{	O
p	pointer
=	O
line_end	pointer
+	O
1	int
;	O
if	O
(	O
HIST_TIMESTAMP_START	O
(	O
p	pointer
)	O
==	O
0	int
)	O
current_line	int
++	O
;	O
line_start	pointer
=	O
p	pointer
;	O
}	O
for	O
(	O
line_end	pointer
=	O
line_start	pointer
;	O
line_end	pointer
<	O
bufend	pointer
;	O
line_end	pointer
++	O
)	O
if	O
(	O
*	O
line_end	pointer
==	O
'\n'	O
)	O
{	O
if	O
(	O
line_end	pointer
>	O
line_start	pointer
&&	O
line_end	pointer
[	O
-	O
1	int
]	O
==	O
'\r'	O
)	O
line_end	pointer
[	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
else	O
*	O
line_end	pointer
=	O
'\0'	O
;	O
if	O
(	O
*	O
line_start	pointer
)	O
{	O
if	O
(	O
HIST_TIMESTAMP_START	O
(	O
line_start	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
last_ts	pointer
==	O
NULL	O
&&	O
history_multiline_entries	int
)	O
_hs_append_history_line	function
(	O
history_length	int
-	O
1	int
,	O
line_start	pointer
)	O
;	O
else	O
add_history	function
(	O
line_start	pointer
)	O
;	O
if	O
(	O
last_ts	pointer
)	O
{	O
add_history_time	function
(	O
last_ts	pointer
)	O
;	O
last_ts	pointer
=	O
NULL	O
;	O
}	O
}	O
else	O
{	O
last_ts	pointer
=	O
line_start	pointer
;	O
current_line	int
--	O
;	O
}	O
}	O
current_line	int
++	O
;	O
if	O
(	O
current_line	int
>=	O
to	int
)	O
break	O
;	O
line_start	pointer
=	O
line_end	pointer
+	O
1	int
;	O
}	O
history_lines_read_from_file	int
=	O
current_line	int
;	O
if	O
(	O
reset_comment_char	int
)	O
history_comment_char	char
=	O
'\0'	O
;	O
FREE	O
(	O
input	pointer
)	O
;	O
FREE	O
(	O
buffer	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
histfile_backup	function
(	O
filename	pointer
,	O
back	pointer
)	O
const	O
char	O
*	O
filename	pointer
;	O
const	O
char	O
*	O
back	pointer
;	O
{	O
char	O
linkbuf	array
[	O
PATH_MAX	int
+	O
1	int
]	O
;	O
ssize_t	long
n	long
;	O
if	O
(	O
(	O
n	long
=	O
readlink	function
(	O
filename	pointer
,	O
linkbuf	array
,	O
sizeof	O
(	O
linkbuf	array
)	O
-	O
1	int
)	O
)	O
>	O
0	int
)	O
{	O
linkbuf	array
[	O
n	long
]	O
=	O
'\0'	O
;	O
return	O
(	O
rename	function
(	O
linkbuf	array
,	O
back	pointer
)	O
)	O
;	O
}	O
return	O
(	O
rename	function
(	O
filename	pointer
,	O
back	pointer
)	O
)	O
;	O
}	O
static	O
int	O
histfile_restore	function
(	O
backup	pointer
,	O
orig	pointer
)	O
const	O
char	O
*	O
backup	pointer
;	O
const	O
char	O
*	O
orig	pointer
;	O
{	O
char	O
linkbuf	array
[	O
PATH_MAX	int
+	O
1	int
]	O
;	O
ssize_t	long
n	long
;	O
if	O
(	O
(	O
n	long
=	O
readlink	function
(	O
orig	pointer
,	O
linkbuf	array
,	O
sizeof	O
(	O
linkbuf	array
)	O
-	O
1	int
)	O
)	O
>	O
0	int
)	O
{	O
linkbuf	array
[	O
n	long
]	O
=	O
'\0'	O
;	O
return	O
(	O
rename	function
(	O
backup	pointer
,	O
linkbuf	array
)	O
)	O
;	O
}	O
return	O
(	O
rename	function
(	O
backup	pointer
,	O
orig	pointer
)	O
)	O
;	O
}	O
int	O
history_truncate_file	function
(	O
fname	pointer
,	O
lines	int
)	O
const	O
char	O
*	O
fname	pointer
;	O
int	O
lines	int
;	O
{	O
char	O
*	O
buffer	pointer
,	O
*	O
filename	pointer
,	O
*	O
tempname	pointer
,	O
*	O
bp	pointer
,	O
*	O
bp1	pointer
;	O
int	O
file	int
,	O
chars_read	int
,	O
rv	int
,	O
orig_lines	int
,	O
exists	int
,	O
r	int
;	O
struct	O
stat	struct
finfo	struct
;	O
size_t	long
file_size	long
;	O
history_lines_written_to_file	int
=	O
0	int
;	O
buffer	pointer
=	O
(	O
char	O
*	O
)	O
NULL	O
;	O
filename	pointer
=	O
history_filename	function
(	O
fname	pointer
)	O
;	O
tempname	pointer
=	O
0	int
;	O
file	int
=	O
filename	pointer
?	O
open	function
(	O
filename	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
,	O
0666	int
)	O
:	O
-	O
1	int
;	O
rv	int
=	O
exists	int
=	O
0	int
;	O
if	O
(	O
file	int
==	O
-	O
1	int
||	O
fstat	function
(	O
file	int
,	O
&	O
finfo	struct
)	O
==	O
-	O
1	int
)	O
{	O
rv	int
=	O
errno	O
;	O
if	O
(	O
file	int
!=	O
-	O
1	int
)	O
close	pointer
(	O
file	int
)	O
;	O
goto	O
truncate_exit	O
;	O
}	O
exists	int
=	O
1	int
;	O
if	O
(	O
S_ISREG	O
(	O
finfo	struct
.	O
st_mode	int
)	O
==	O
0	int
)	O
{	O
close	pointer
(	O
file	int
)	O
;	O
rv	int
=	O
EINVAL	int
;	O
goto	O
truncate_exit	O
;	O
}	O
file_size	long
=	O
(	O
size_t	long
)	O
finfo	struct
.	O
st_size	long
;	O
if	O
(	O
file_size	long
!=	O
finfo	struct
.	O
st_size	long
||	O
file_size	long
+	O
1	int
<	O
file_size	long
)	O
{	O
close	pointer
(	O
file	int
)	O
;	O
rv	int
=	O
errno	O
=	O
EFBIG	int
;	O
goto	O
truncate_exit	O
;	O
}	O
buffer	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
file_size	long
+	O
1	int
)	O
;	O
if	O
(	O
buffer	pointer
==	O
0	int
)	O
{	O
rv	int
=	O
errno	O
;	O
close	pointer
(	O
file	int
)	O
;	O
goto	O
truncate_exit	O
;	O
}	O
chars_read	int
=	O
read	pointer
(	O
file	int
,	O
buffer	pointer
,	O
file_size	long
)	O
;	O
close	pointer
(	O
file	int
)	O
;	O
if	O
(	O
chars_read	int
<=	O
0	int
)	O
{	O
rv	int
=	O
(	O
chars_read	int
<	O
0	int
)	O
?	O
errno	O
:	O
0	int
;	O
goto	O
truncate_exit	O
;	O
}	O
orig_lines	int
=	O
lines	int
;	O
for	O
(	O
bp1	pointer
=	O
bp	pointer
=	O
buffer	pointer
+	O
chars_read	int
-	O
1	int
;	O
lines	int
&&	O
bp	pointer
>	O
buffer	pointer
;	O
bp	pointer
--	O
)	O
{	O
if	O
(	O
*	O
bp	pointer
==	O
'\n'	O
&&	O
HIST_TIMESTAMP_START	O
(	O
bp1	pointer
)	O
==	O
0	int
)	O
lines	int
--	O
;	O
bp1	pointer
=	O
bp	pointer
;	O
}	O
for	O
(	O
;	O
bp	pointer
>	O
buffer	pointer
;	O
bp	pointer
--	O
)	O
{	O
if	O
(	O
*	O
bp	pointer
==	O
'\n'	O
&&	O
HIST_TIMESTAMP_START	O
(	O
bp1	pointer
)	O
==	O
0	int
)	O
{	O
bp	pointer
++	O
;	O
break	O
;	O
}	O
bp1	pointer
=	O
bp	pointer
;	O
}	O
if	O
(	O
bp	pointer
<=	O
buffer	pointer
)	O
{	O
rv	int
=	O
0	int
;	O
history_lines_written_to_file	int
=	O
orig_lines	int
-	O
lines	int
;	O
goto	O
truncate_exit	O
;	O
}	O
tempname	pointer
=	O
history_tempfile	function
(	O
filename	pointer
)	O
;	O
if	O
(	O
(	O
file	int
=	O
open	function
(	O
tempname	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
|	O
O_BINARY	int
,	O
0600	int
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
write	pointer
(	O
file	int
,	O
bp	pointer
,	O
chars_read	int
-	O
(	O
bp	pointer
-	O
buffer	pointer
)	O
)	O
<	O
0	int
)	O
rv	int
=	O
errno	O
;	O
if	O
(	O
close	pointer
(	O
file	int
)	O
<	O
0	int
&&	O
rv	int
==	O
0	int
)	O
rv	int
=	O
errno	O
;	O
}	O
else	O
rv	int
=	O
errno	O
;	O
truncate_exit	O
:	O
FREE	O
(	O
buffer	pointer
)	O
;	O
history_lines_written_to_file	int
=	O
orig_lines	int
-	O
lines	int
;	O
if	O
(	O
rv	int
==	O
0	int
&&	O
filename	pointer
&&	O
tempname	pointer
)	O
rv	int
=	O
histfile_restore	function
(	O
tempname	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
rv	int
!=	O
0	int
)	O
{	O
if	O
(	O
tempname	pointer
)	O
unlink	function
(	O
tempname	pointer
)	O
;	O
history_lines_written_to_file	int
=	O
0	int
;	O
}	O
if	O
(	O
rv	int
==	O
0	int
&&	O
exists	int
)	O
r	int
=	O
chown	function
(	O
filename	pointer
,	O
finfo	struct
.	O
st_uid	int
,	O
finfo	struct
.	O
st_gid	int
)	O
;	O
xfree	function
(	O
filename	pointer
)	O
;	O
FREE	O
(	O
tempname	pointer
)	O
;	O
return	O
rv	int
;	O
}	O
static	O
int	O
history_do_write	function
(	O
filename	pointer
,	O
nelements	int
,	O
overwrite	int
)	O
const	O
char	O
*	O
filename	pointer
;	O
int	O
nelements	int
,	O
overwrite	int
;	O
{	O
register	O
int	O
i	int
;	O
char	O
*	O
output	pointer
,	O
*	O
tempname	pointer
,	O
*	O
histname	pointer
;	O
int	O
file	int
,	O
mode	int
,	O
rv	int
,	O
exists	int
;	O
struct	O
stat	struct
finfo	struct
;	O
mode	int
=	O
overwrite	int
?	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
|	O
O_BINARY	int
:	O
O_WRONLY	int
|	O
O_APPEND	int
|	O
O_BINARY	int
;	O
histname	pointer
=	O
history_filename	function
(	O
filename	pointer
)	O
;	O
exists	int
=	O
histname	pointer
?	O
(	O
stat	struct
(	O
histname	pointer
,	O
&	O
finfo	struct
)	O
==	O
0	int
)	O
:	O
0	int
;	O
tempname	pointer
=	O
(	O
overwrite	int
&&	O
exists	int
&&	O
S_ISREG	O
(	O
finfo	struct
.	O
st_mode	int
)	O
)	O
?	O
history_tempfile	function
(	O
histname	pointer
)	O
:	O
0	int
;	O
output	pointer
=	O
tempname	pointer
?	O
tempname	pointer
:	O
histname	pointer
;	O
file	int
=	O
output	pointer
?	O
open	function
(	O
output	pointer
,	O
mode	int
,	O
0600	int
)	O
:	O
-	O
1	int
;	O
rv	int
=	O
0	int
;	O
if	O
(	O
file	int
==	O
-	O
1	int
)	O
{	O
rv	int
=	O
errno	O
;	O
FREE	O
(	O
histname	pointer
)	O
;	O
FREE	O
(	O
tempname	pointer
)	O
;	O
return	O
(	O
rv	int
)	O
;	O
}	O
if	O
(	O
nelements	int
>	O
history_length	int
)	O
nelements	int
=	O
history_length	int
;	O
{	O
HIST_ENTRY	struct
*	O
*	O
the_history	pointer
;	O
register	O
int	O
j	int
;	O
int	O
buffer_size	int
;	O
char	O
*	O
buffer	pointer
;	O
the_history	pointer
=	O
history_list	function
(	O
)	O
;	O
for	O
(	O
buffer_size	int
=	O
0	int
,	O
i	int
=	O
history_length	int
-	O
nelements	int
;	O
i	int
<	O
history_length	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
history_write_timestamps	int
&&	O
the_history	pointer
[	O
i	int
]	O
->	O
timestamp	pointer
&&	O
the_history	pointer
[	O
i	int
]	O
->	O
timestamp	pointer
[	O
0	int
]	O
)	O
buffer_size	int
+=	O
strlen	function
(	O
the_history	pointer
[	O
i	int
]	O
->	O
timestamp	pointer
)	O
+	O
1	int
;	O
buffer_size	int
+=	O
strlen	function
(	O
the_history	pointer
[	O
i	int
]	O
->	O
line	pointer
)	O
+	O
1	int
;	O
}	O
buffer	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
buffer_size	int
)	O
;	O
if	O
(	O
buffer	pointer
==	O
0	int
)	O
{	O
rv	int
=	O
errno	O
;	O
close	pointer
(	O
file	int
)	O
;	O
if	O
(	O
tempname	pointer
)	O
unlink	function
(	O
tempname	pointer
)	O
;	O
FREE	O
(	O
histname	pointer
)	O
;	O
FREE	O
(	O
tempname	pointer
)	O
;	O
return	O
rv	int
;	O
}	O
for	O
(	O
j	int
=	O
0	int
,	O
i	int
=	O
history_length	int
-	O
nelements	int
;	O
i	int
<	O
history_length	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
history_write_timestamps	int
&&	O
the_history	pointer
[	O
i	int
]	O
->	O
timestamp	pointer
&&	O
the_history	pointer
[	O
i	int
]	O
->	O
timestamp	pointer
[	O
0	int
]	O
)	O
{	O
strcpy	function
(	O
buffer	pointer
+	O
j	int
,	O
the_history	pointer
[	O
i	int
]	O
->	O
timestamp	pointer
)	O
;	O
j	int
+=	O
strlen	function
(	O
the_history	pointer
[	O
i	int
]	O
->	O
timestamp	pointer
)	O
;	O
buffer	pointer
[	O
j	int
++	O
]	O
=	O
'\n'	O
;	O
}	O
strcpy	function
(	O
buffer	pointer
+	O
j	int
,	O
the_history	pointer
[	O
i	int
]	O
->	O
line	pointer
)	O
;	O
j	int
+=	O
strlen	function
(	O
the_history	pointer
[	O
i	int
]	O
->	O
line	pointer
)	O
;	O
buffer	pointer
[	O
j	int
++	O
]	O
=	O
'\n'	O
;	O
}	O
if	O
(	O
write	pointer
(	O
file	int
,	O
buffer	pointer
,	O
buffer_size	int
)	O
<	O
0	int
)	O
rv	int
=	O
errno	O
;	O
xfree	function
(	O
buffer	pointer
)	O
;	O
}	O
history_lines_written_to_file	int
=	O
nelements	int
;	O
if	O
(	O
close	pointer
(	O
file	int
)	O
<	O
0	int
&&	O
rv	int
==	O
0	int
)	O
rv	int
=	O
errno	O
;	O
if	O
(	O
rv	int
==	O
0	int
&&	O
histname	pointer
&&	O
tempname	pointer
)	O
rv	int
=	O
histfile_restore	function
(	O
tempname	pointer
,	O
histname	pointer
)	O
;	O
if	O
(	O
rv	int
!=	O
0	int
)	O
{	O
if	O
(	O
tempname	pointer
)	O
unlink	function
(	O
tempname	pointer
)	O
;	O
history_lines_written_to_file	int
=	O
0	int
;	O
}	O
if	O
(	O
rv	int
==	O
0	int
&&	O
exists	int
)	O
mode	int
=	O
chown	function
(	O
histname	pointer
,	O
finfo	struct
.	O
st_uid	int
,	O
finfo	struct
.	O
st_gid	int
)	O
;	O
FREE	O
(	O
histname	pointer
)	O
;	O
FREE	O
(	O
tempname	pointer
)	O
;	O
return	O
(	O
rv	int
)	O
;	O
}	O
int	O
append_history	function
(	O
nelements	int
,	O
filename	pointer
)	O
int	O
nelements	int
;	O
const	O
char	O
*	O
filename	pointer
;	O
{	O
return	O
(	O
history_do_write	function
(	O
filename	pointer
,	O
nelements	int
,	O
HISTORY_APPEND	int
)	O
)	O
;	O
}	O
int	O
write_history	function
(	O
filename	pointer
)	O
const	O
char	O
*	O
filename	pointer
;	O
{	O
return	O
(	O
history_do_write	function
(	O
filename	pointer
,	O
history_length	int
,	O
HISTORY_OVERWRITE	int
)	O
)	O
;	O
}	O
