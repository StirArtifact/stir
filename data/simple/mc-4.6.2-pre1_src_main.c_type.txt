WPanel	struct
*	O
left_panel	pointer
=	O
NULL	O
;	O
WPanel	struct
*	O
right_panel	pointer
=	O
NULL	O
;	O
WTree	struct
*	O
the_tree	pointer
=	O
NULL	O
;	O
struct	O
WMenu	struct
*	O
the_menubar	pointer
=	O
NULL	O
;	O
WPanel	struct
*	O
current_panel	pointer
=	O
NULL	O
;	O
int	O
is_right	int
=	O
0	int
;	O
volatile	O
int	O
quit	int
=	O
0	int
;	O
int	O
show_all_if_ambiguous	int
=	O
0	int
;	O
int	O
cd_symlinks	int
=	O
1	int
;	O
int	O
fast_refresh	int
=	O
0	int
;	O
int	O
mark_moves_down	int
=	O
1	int
;	O
int	O
auto_menu	int
=	O
0	int
;	O
int	O
alternate_plus_minus	int
=	O
0	int
;	O
int	O
only_leading_plus_minus	int
=	O
1	int
;	O
int	O
pause_after_run	int
=	O
pause_on_dumb_terminals	int
;	O
int	O
auto_save_setup	int
=	O
1	int
;	O
int	O
eight_bit_clean	int
=	O
1	int
;	O
int	O
full_eight_bits	int
=	O
0	int
;	O
int	O
use_internal_view	int
=	O
1	int
;	O
int	O
fast_reload_w	int
=	O
0	int
;	O
int	O
mouse_move_pages	int
=	O
1	int
;	O
int	O
navigate_with_arrows	int
=	O
0	int
;	O
int	O
force_ugly_line_drawing	int
=	O
0	int
;	O
int	O
reset_hp_softkeys	int
=	O
0	int
;	O
const	O
char	O
*	O
prompt	pointer
=	O
NULL	O
;	O
WLabel	struct
*	O
the_prompt	pointer
;	O
WLabel	struct
*	O
the_hint	pointer
;	O
WButtonBar	struct
*	O
the_bar	pointer
;	O
int	O
slow_terminal	int
=	O
0	int
;	O
Mouse_Type	enum
use_mouse_p	enum
=	O
MOUSE_NONE	int
;	O
static	O
int	O
force_xterm	int
=	O
0	int
;	O
int	O
safe_delete	int
=	O
0	int
;	O
int	O
clear_before_exec	int
=	O
1	int
;	O
int	O
confirm_delete	int
=	O
1	int
;	O
int	O
confirm_directory_hotlist_delete	int
=	O
1	int
;	O
int	O
confirm_overwrite	int
=	O
1	int
;	O
int	O
confirm_execute	int
=	O
0	int
;	O
int	O
confirm_exit	int
=	O
1	int
;	O
int	O
confirm_view_dir	int
=	O
0	int
;	O
int	O
drop_menus	int
=	O
0	int
;	O
Dlg_head	struct
*	O
midnight_dlg	pointer
;	O
int	O
update_prompt	int
=	O
0	int
;	O
const	O
char	O
*	O
home_dir	pointer
=	O
NULL	O
;	O
char	O
*	O
other_dir	pointer
=	O
NULL	O
;	O
int	O
boot_current_is_left	int
=	O
1	int
;	O
static	O
char	O
*	O
this_dir	pointer
=	O
NULL	O
;	O
int	O
xtree_mode	int
=	O
0	int
;	O
static	O
char	O
*	O
last_wd_file	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
last_wd_string	pointer
=	O
NULL	O
;	O
static	O
int	O
print_last_revert	int
=	O
0	int
;	O
int	O
force_colors	int
=	O
0	int
;	O
char	O
*	O
command_line_colors	pointer
=	O
NULL	O
;	O
static	O
const	O
char	O
*	O
view_one_file	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
edit_one_file	pointer
=	O
NULL	O
;	O
static	O
int	O
edit_one_file_start_line	int
=	O
0	int
;	O
int	O
midnight_shutdown	int
=	O
0	int
;	O
const	O
char	O
*	O
shell	pointer
=	O
NULL	O
;	O
char	O
*	O
mc_home	pointer
=	O
NULL	O
;	O
char	O
cmd_buf	array
[	O
512	int
]	O
;	O
static	O
void	O
reload_panelized	function
(	O
WPanel	struct
*	O
panel	pointer
)	O
{	O
int	O
i	array
,	O
j	int
;	O
dir_list	struct
*	O
list	pointer
=	O
&	O
panel	pointer
->	O
dir	pointer
;	O
if	O
(	O
panel	pointer
!=	O
current_panel	pointer
)	O
mc_chdir	function
(	O
panel	pointer
->	O
cwd	short
)	O
;	O
for	O
(	O
i	array
=	O
0	int
,	O
j	int
=	O
0	int
;	O
i	array
<	O
panel	pointer
->	O
count	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
)	O
{	O
do_file_mark	function
(	O
panel	pointer
,	O
i	array
,	O
0	int
)	O
;	O
}	O
if	O
(	O
mc_lstat	function
(	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
,	O
&	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
st	pointer
)	O
)	O
{	O
g_free	function
(	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
)	O
do_file_mark	function
(	O
panel	pointer
,	O
i	array
,	O
1	int
)	O
;	O
if	O
(	O
j	int
!=	O
i	array
)	O
list	pointer
->	O
list	pointer
[	O
j	int
]	O
=	O
list	pointer
->	O
list	pointer
[	O
i	array
]	O
;	O
j	int
++	O
;	O
}	O
if	O
(	O
j	int
==	O
0	int
)	O
panel	pointer
->	O
count	int
=	O
set_zero_dir	function
(	O
list	pointer
)	O
;	O
else	O
panel	pointer
->	O
count	int
=	O
j	int
;	O
if	O
(	O
panel	pointer
!=	O
current_panel	pointer
)	O
mc_chdir	function
(	O
current_panel	pointer
->	O
cwd	short
)	O
;	O
}	O
static	O
void	O
update_one_panel_widget	function
(	O
WPanel	struct
*	O
panel	pointer
,	O
int	O
force_update	int
,	O
const	O
char	O
*	O
current_file	pointer
)	O
{	O
int	O
free_pointer	int
;	O
char	O
*	O
my_current_file	pointer
=	O
NULL	O
;	O
if	O
(	O
force_update	int
&	O
UP_RELOAD	int
)	O
{	O
panel	pointer
->	O
is_panelized	int
=	O
0	int
;	O
mc_setctl	function
(	O
panel	pointer
->	O
cwd	short
,	O
VFS_SETCTL_FLUSH	int
,	O
0	int
)	O
;	O
memset	function
(	O
&	O
(	O
panel	pointer
->	O
dir_stat	struct
)	O
,	O
0	int
,	O
sizeof	O
(	O
panel	pointer
->	O
dir_stat	struct
)	O
)	O
;	O
}	O
if	O
(	O
current_file	pointer
==	O
UP_KEEPSEL	O
)	O
{	O
free_pointer	int
=	O
1	int
;	O
my_current_file	pointer
=	O
g_strdup	function
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
panel	pointer
->	O
selected	int
]	O
.	O
fname	pointer
)	O
;	O
current_file	pointer
=	O
my_current_file	pointer
;	O
}	O
else	O
free_pointer	int
=	O
0	int
;	O
if	O
(	O
panel	pointer
->	O
is_panelized	int
)	O
reload_panelized	function
(	O
panel	pointer
)	O
;	O
else	O
panel_reload	function
(	O
panel	pointer
)	O
;	O
try_to_select	function
(	O
panel	pointer
,	O
current_file	pointer
)	O
;	O
panel	pointer
->	O
dirty	int
=	O
1	int
;	O
if	O
(	O
free_pointer	int
)	O
g_free	function
(	O
my_current_file	pointer
)	O
;	O
}	O
void	O
panel_clean_dir	function
(	O
WPanel	struct
*	O
panel	pointer
)	O
{	O
int	O
count	int
=	O
panel	pointer
->	O
count	int
;	O
panel	pointer
->	O
count	int
=	O
0	int
;	O
panel	pointer
->	O
top_file	int
=	O
0	int
;	O
panel	pointer
->	O
selected	int
=	O
0	int
;	O
panel	pointer
->	O
marked	int
=	O
0	int
;	O
panel	pointer
->	O
dirs_marked	int
=	O
0	int
;	O
panel	pointer
->	O
total	double
=	O
0	int
;	O
panel	pointer
->	O
searching	int
=	O
0	int
;	O
panel	pointer
->	O
is_panelized	int
=	O
0	int
;	O
panel	pointer
->	O
dirty	int
=	O
1	int
;	O
clean_dir	function
(	O
&	O
panel	pointer
->	O
dir	pointer
,	O
count	int
)	O
;	O
}	O
static	O
void	O
update_one_panel	function
(	O
int	O
which	pointer
,	O
int	O
force_update	int
,	O
const	O
char	O
*	O
current_file	pointer
)	O
{	O
WPanel	struct
*	O
panel	pointer
;	O
if	O
(	O
get_display_type	function
(	O
which	pointer
)	O
!=	O
view_listing	int
)	O
return	O
;	O
panel	pointer
=	O
(	O
WPanel	struct
*	O
)	O
get_panel_widget	function
(	O
which	pointer
)	O
;	O
update_one_panel_widget	function
(	O
panel	pointer
,	O
force_update	int
,	O
current_file	pointer
)	O
;	O
}	O
void	O
update_panels	function
(	O
int	O
force_update	int
,	O
const	O
char	O
*	O
current_file	pointer
)	O
{	O
int	O
reload_other	int
=	O
!	O
(	O
force_update	int
&	O
UP_ONLY_CURRENT	int
)	O
;	O
WPanel	struct
*	O
panel	pointer
;	O
update_one_panel	function
(	O
get_current_index	function
(	O
)	O
,	O
force_update	int
,	O
current_file	pointer
)	O
;	O
if	O
(	O
reload_other	int
)	O
update_one_panel	function
(	O
get_other_index	function
(	O
)	O
,	O
force_update	int
,	O
UP_KEEPSEL	O
)	O
;	O
if	O
(	O
get_current_type	function
(	O
)	O
==	O
view_listing	int
)	O
panel	pointer
=	O
(	O
WPanel	struct
*	O
)	O
get_panel_widget	function
(	O
get_current_index	function
(	O
)	O
)	O
;	O
else	O
panel	pointer
=	O
(	O
WPanel	struct
*	O
)	O
get_panel_widget	function
(	O
get_other_index	function
(	O
)	O
)	O
;	O
mc_chdir	function
(	O
panel	pointer
->	O
cwd	short
)	O
;	O
}	O
void	O
save_cwds_stat	function
(	O
void	O
)	O
{	O
if	O
(	O
fast_reload	int
)	O
{	O
mc_stat	function
(	O
current_panel	pointer
->	O
cwd	short
,	O
&	O
(	O
current_panel	pointer
->	O
dir_stat	struct
)	O
)	O
;	O
if	O
(	O
get_other_type	function
(	O
)	O
==	O
view_listing	int
)	O
mc_stat	function
(	O
other_panel	O
->	O
cwd	short
,	O
&	O
(	O
other_panel	O
->	O
dir_stat	struct
)	O
)	O
;	O
}	O
}	O
void	O
do_possible_cd	function
(	O
const	O
char	O
*	O
new_dir	pointer
)	O
{	O
if	O
(	O
!	O
do_cd	function
(	O
new_dir	pointer
,	O
cd_exact	int
)	O
)	O
message	pointer
(	O
1	int
,	O
_	O
(	O
"Warning"	pointer
)	O
,	O
_	O
(	O
" The Commander can't change to the directory that \n"	pointer
" the subshell claims you are in.  Perhaps you have \n"	pointer
" deleted your working directory, or given yourself \n"	pointer
" extra access permissions with the \"su\" command? "	pointer
)	O
)	O
;	O
}	O
void	O
do_update_prompt	function
(	O
void	O
)	O
{	O
if	O
(	O
update_prompt	int
)	O
{	O
printf	function
(	O
"%s"	pointer
,	O
subshell_prompt	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
update_prompt	int
=	O
0	int
;	O
}	O
}	O
void	O
change_panel	function
(	O
void	O
)	O
{	O
free_completions	function
(	O
cmdline	pointer
)	O
;	O
dlg_one_down	function
(	O
midnight_dlg	pointer
)	O
;	O
}	O
static	O
void	O
stop_dialogs	function
(	O
void	O
)	O
{	O
midnight_dlg	pointer
->	O
running	int
=	O
0	int
;	O
if	O
(	O
current_dlg	pointer
)	O
{	O
current_dlg	pointer
->	O
running	int
=	O
0	int
;	O
}	O
}	O
static	O
int	O
quit_cmd_internal	function
(	O
int	O
quiet	int
)	O
{	O
int	O
q	int
=	O
quit	int
;	O
if	O
(	O
quiet	int
||	O
!	O
confirm_exit	int
)	O
{	O
q	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
query_dialog	function
(	O
_	O
(	O
" The Midnight Commander "	pointer
)	O
,	O
_	O
(	O
" Do you really want to quit the Midnight Commander? "	pointer
)	O
,	O
0	int
,	O
2	int
,	O
_	O
(	O
"&Yes"	pointer
)	O
,	O
_	O
(	O
"&No"	pointer
)	O
)	O
==	O
0	int
)	O
q	int
=	O
1	int
;	O
}	O
if	O
(	O
q	int
)	O
{	O
if	O
(	O
!	O
use_subshell	int
)	O
stop_dialogs	function
(	O
)	O
;	O
else	O
if	O
(	O
(	O
q	int
=	O
exit_subshell	function
(	O
)	O
)	O
)	O
stop_dialogs	function
(	O
)	O
;	O
}	O
if	O
(	O
q	int
)	O
quit	int
|=	O
1	int
;	O
return	O
quit	int
;	O
}	O
static	O
void	O
quit_cmd	function
(	O
void	O
)	O
{	O
quit_cmd_internal	function
(	O
0	int
)	O
;	O
}	O
void	O
quiet_quit_cmd	function
(	O
void	O
)	O
{	O
print_last_revert	int
=	O
1	int
;	O
quit_cmd_internal	function
(	O
1	int
)	O
;	O
}	O
void	O
repaint_screen	function
(	O
void	O
)	O
{	O
do_refresh	function
(	O
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
}	O
void	O
subshell_chdir	function
(	O
const	O
char	O
*	O
directory	enum
)	O
{	O
if	O
(	O
use_subshell	int
)	O
{	O
if	O
(	O
vfs_current_is_local	function
(	O
)	O
)	O
do_subshell_chdir	function
(	O
directory	enum
,	O
0	int
,	O
1	int
)	O
;	O
}	O
}	O
void	O
directory_history_add	function
(	O
struct	O
WPanel	struct
*	O
panel	pointer
,	O
const	O
char	O
*	O
dir	pointer
)	O
{	O
char	O
*	O
tmp	pointer
;	O
tmp	pointer
=	O
g_strdup	function
(	O
dir	pointer
)	O
;	O
strip_password	function
(	O
tmp	pointer
,	O
1	int
)	O
;	O
panel	pointer
->	O
dir_history	pointer
=	O
list_append_unique	function
(	O
panel	pointer
->	O
dir_history	pointer
,	O
tmp	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
get_parent_dir_name	function
(	O
const	O
char	O
*	O
cwd	short
,	O
const	O
char	O
*	O
lwd	array
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
if	O
(	O
strlen	function
(	O
lwd	array
)	O
>	O
strlen	function
(	O
cwd	short
)	O
)	O
if	O
(	O
(	O
p	pointer
=	O
strrchr	function
(	O
lwd	array
,	O
PATH_SEP	char
)	O
)	O
&&	O
!	O
strncmp	function
(	O
cwd	short
,	O
lwd	array
,	O
p	pointer
-	O
lwd	array
)	O
&&	O
(	O
strlen	function
(	O
cwd	short
)	O
==	O
p	pointer
-	O
lwd	array
||	O
(	O
p	pointer
==	O
lwd	array
&&	O
cwd	short
[	O
0	int
]	O
==	O
PATH_SEP	char
&&	O
cwd	short
[	O
1	int
]	O
==	O
'\0'	O
)	O
)	O
)	O
{	O
return	O
(	O
p	pointer
+	O
1	int
)	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
_do_panel_cd	function
(	O
WPanel	struct
*	O
panel	pointer
,	O
const	O
char	O
*	O
new_dir	pointer
,	O
enum	O
cd_enum	enum
cd_type	enum
)	O
{	O
const	O
char	O
*	O
directory	enum
;	O
char	O
*	O
olddir	pointer
;	O
char	O
temp	array
[	O
MC_MAXPATHLEN	O
]	O
;	O
char	O
*	O
translated_url	pointer
;	O
if	O
(	O
cd_type	enum
==	O
cd_parse_command	int
)	O
{	O
while	O
(	O
*	O
new_dir	pointer
==	O
' '	O
)	O
new_dir	pointer
++	O
;	O
}	O
olddir	pointer
=	O
g_strdup	function
(	O
panel	pointer
->	O
cwd	short
)	O
;	O
new_dir	pointer
=	O
translated_url	pointer
=	O
vfs_translate_url	function
(	O
new_dir	pointer
)	O
;	O
if	O
(	O
cd_type	enum
==	O
cd_parse_command	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
new_dir	pointer
,	O
"-"	pointer
)	O
)	O
{	O
strcpy	function
(	O
temp	array
,	O
panel	pointer
->	O
lwd	array
)	O
;	O
new_dir	pointer
=	O
temp	array
;	O
}	O
}	O
directory	enum
=	O
*	O
new_dir	pointer
?	O
new_dir	pointer
:	O
home_dir	pointer
;	O
if	O
(	O
mc_chdir	function
(	O
directory	enum
)	O
==	O
-	O
1	int
)	O
{	O
strcpy	function
(	O
panel	pointer
->	O
cwd	short
,	O
olddir	pointer
)	O
;	O
g_free	function
(	O
olddir	pointer
)	O
;	O
g_free	function
(	O
translated_url	pointer
)	O
;	O
return	O
0	int
;	O
}	O
g_free	function
(	O
translated_url	pointer
)	O
;	O
strcpy	function
(	O
panel	pointer
->	O
lwd	array
,	O
olddir	pointer
)	O
;	O
free_completions	function
(	O
cmdline	pointer
)	O
;	O
mc_get_current_wd	function
(	O
panel	pointer
->	O
cwd	short
,	O
sizeof	O
(	O
panel	pointer
->	O
cwd	short
)	O
-	O
2	int
)	O
;	O
vfs_release_path	function
(	O
olddir	pointer
)	O
;	O
subshell_chdir	function
(	O
panel	pointer
->	O
cwd	short
)	O
;	O
panel_clean_dir	function
(	O
panel	pointer
)	O
;	O
panel	pointer
->	O
count	int
=	O
do_load_dir	function
(	O
panel	pointer
->	O
cwd	short
,	O
&	O
panel	pointer
->	O
dir	pointer
,	O
panel	pointer
->	O
sort_type	pointer
,	O
panel	pointer
->	O
reverse	int
,	O
panel	pointer
->	O
case_sensitive	int
,	O
panel	pointer
->	O
filter	pointer
)	O
;	O
try_to_select	function
(	O
panel	pointer
,	O
get_parent_dir_name	function
(	O
panel	pointer
->	O
cwd	short
,	O
olddir	pointer
)	O
)	O
;	O
load_hint	function
(	O
0	int
)	O
;	O
panel	pointer
->	O
dirty	int
=	O
1	int
;	O
update_xterm_title_path	function
(	O
)	O
;	O
g_free	function
(	O
olddir	pointer
)	O
;	O
return	O
1	int
;	O
}	O
int	O
do_panel_cd	function
(	O
struct	O
WPanel	struct
*	O
panel	pointer
,	O
const	O
char	O
*	O
new_dir	pointer
,	O
enum	O
cd_enum	enum
cd_type	enum
)	O
{	O
int	O
r	pointer
;	O
r	pointer
=	O
_do_panel_cd	function
(	O
panel	pointer
,	O
new_dir	pointer
,	O
cd_type	enum
)	O
;	O
if	O
(	O
r	pointer
)	O
directory_history_add	function
(	O
panel	pointer
,	O
panel	pointer
->	O
cwd	short
)	O
;	O
return	O
r	pointer
;	O
}	O
int	O
do_cd	function
(	O
const	O
char	O
*	O
new_dir	pointer
,	O
enum	O
cd_enum	enum
exact	enum
)	O
{	O
return	O
(	O
do_panel_cd	function
(	O
current_panel	pointer
,	O
new_dir	pointer
,	O
exact	enum
)	O
)	O
;	O
}	O
void	O
directory_history_next	function
(	O
WPanel	struct
*	O
panel	pointer
)	O
{	O
GList	struct
*	O
nextdir	pointer
;	O
nextdir	pointer
=	O
g_list_next	O
(	O
panel	pointer
->	O
dir_history	pointer
)	O
;	O
if	O
(	O
!	O
nextdir	pointer
)	O
return	O
;	O
if	O
(	O
_do_panel_cd	function
(	O
panel	pointer
,	O
(	O
char	O
*	O
)	O
nextdir	pointer
->	O
data	pointer
,	O
cd_exact	int
)	O
)	O
panel	pointer
->	O
dir_history	pointer
=	O
nextdir	pointer
;	O
}	O
void	O
directory_history_prev	function
(	O
WPanel	struct
*	O
panel	pointer
)	O
{	O
GList	struct
*	O
prevdir	pointer
;	O
prevdir	pointer
=	O
g_list_previous	O
(	O
panel	pointer
->	O
dir_history	pointer
)	O
;	O
if	O
(	O
!	O
prevdir	pointer
)	O
return	O
;	O
if	O
(	O
_do_panel_cd	function
(	O
panel	pointer
,	O
(	O
char	O
*	O
)	O
prevdir	pointer
->	O
data	pointer
,	O
cd_exact	int
)	O
)	O
panel	pointer
->	O
dir_history	pointer
=	O
prevdir	pointer
;	O
}	O
void	O
directory_history_list	function
(	O
WPanel	struct
*	O
panel	pointer
)	O
{	O
char	O
*	O
s	pointer
;	O
if	O
(	O
!	O
panel	pointer
->	O
dir_history	pointer
)	O
return	O
;	O
s	pointer
=	O
show_hist	function
(	O
panel	pointer
->	O
dir_history	pointer
,	O
panel	pointer
->	O
widget	pointer
.	O
x	array
,	O
panel	pointer
->	O
widget	pointer
.	O
y	short
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
;	O
if	O
(	O
_do_panel_cd	function
(	O
panel	pointer
,	O
s	pointer
,	O
cd_exact	int
)	O
)	O
directory_history_add	function
(	O
panel	pointer
,	O
panel	pointer
->	O
cwd	short
)	O
;	O
else	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot change directory"	pointer
)	O
)	O
;	O
g_free	function
(	O
s	pointer
)	O
;	O
}	O
int	O
load_prompt	function
(	O
int	O
fd	int
,	O
void	O
*	O
unused	union
)	O
{	O
(	O
void	O
)	O
fd	int
;	O
(	O
void	O
)	O
unused	union
;	O
if	O
(	O
!	O
read_subshell_prompt	function
(	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
current_dlg	pointer
==	O
midnight_dlg	pointer
&&	O
command_prompt	int
)	O
{	O
char	O
*	O
tmp_prompt	pointer
;	O
int	O
prompt_len	int
;	O
tmp_prompt	pointer
=	O
strip_ctrl_codes	function
(	O
subshell_prompt	pointer
)	O
;	O
prompt_len	int
=	O
strlen	function
(	O
tmp_prompt	pointer
)	O
;	O
if	O
(	O
COLS	O
>	O
8	int
&&	O
prompt_len	int
>	O
COLS	O
-	O
8	int
)	O
{	O
tmp_prompt	pointer
[	O
COLS	O
-	O
8	int
]	O
=	O
'\0'	O
;	O
prompt_len	int
=	O
COLS	O
-	O
8	int
;	O
}	O
prompt	pointer
=	O
tmp_prompt	pointer
;	O
label_set_text	function
(	O
the_prompt	pointer
,	O
prompt	pointer
)	O
;	O
winput_set_origin	function
(	O
(	O
WInput	struct
*	O
)	O
cmdline	pointer
,	O
prompt_len	int
,	O
COLS	O
-	O
prompt_len	int
)	O
;	O
update_cursor	function
(	O
midnight_dlg	pointer
)	O
;	O
mc_refresh	function
(	O
)	O
;	O
}	O
update_prompt	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
maybe_cd	function
(	O
int	O
move_up_dir	int
)	O
{	O
if	O
(	O
navigate_with_arrows	int
)	O
{	O
if	O
(	O
!	O
cmdline	pointer
->	O
buffer	pointer
[	O
0	int
]	O
)	O
{	O
if	O
(	O
move_up_dir	int
)	O
{	O
do_cd	function
(	O
".."	pointer
,	O
cd_exact	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
selection	O
(	O
current_panel	pointer
)	O
->	O
st	pointer
.	O
st_mode	int
)	O
||	O
link_isdir	function
(	O
selection	O
(	O
current_panel	pointer
)	O
)	O
)	O
{	O
do_cd	function
(	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
,	O
cd_exact	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
sort_cmd	function
(	O
void	O
)	O
{	O
WPanel	struct
*	O
p	pointer
;	O
sortfn	function
*	O
sort_order	pointer
;	O
if	O
(	O
!	O
SELECTED_IS_PANEL	O
)	O
return	O
;	O
p	pointer
=	O
MENU_PANEL	O
;	O
sort_order	pointer
=	O
sort_box	function
(	O
p	pointer
->	O
sort_type	pointer
,	O
&	O
p	pointer
->	O
reverse	int
,	O
&	O
p	pointer
->	O
case_sensitive	int
)	O
;	O
panel_set_sort_order	function
(	O
p	pointer
,	O
sort_order	pointer
)	O
;	O
}	O
static	O
void	O
treebox_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
sel_dir	pointer
;	O
sel_dir	pointer
=	O
tree_box	function
(	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
)	O
;	O
if	O
(	O
sel_dir	pointer
)	O
{	O
do_cd	function
(	O
sel_dir	pointer
,	O
cd_exact	int
)	O
;	O
g_free	function
(	O
sel_dir	pointer
)	O
;	O
}	O
}	O
static	O
menu_entry	struct
LeftMenu	array
[	O
]	O
=	O
{	O
{	O
' '	O
,	O
N_	O
(	O
"&Listing mode..."	pointer
)	O
,	O
'L'	O
,	O
listing_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Quick view     C-x q"	pointer
)	O
,	O
'Q'	O
,	O
quick_view_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Info           C-x i"	pointer
)	O
,	O
'I'	O
,	O
info_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Tree"	pointer
)	O
,	O
'T'	O
,	O
tree_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Sort order..."	pointer
)	O
,	O
'S'	O
,	O
sort_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Filter..."	pointer
)	O
,	O
'F'	O
,	O
filter_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"FT&P link..."	pointer
)	O
,	O
'P'	O
,	O
ftplink_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"S&hell link..."	pointer
)	O
,	O
'H'	O
,	O
fishlink_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Rescan         C-r"	pointer
)	O
,	O
'R'	O
,	O
reread_cmd	function
}	O
}	O
;	O
static	O
menu_entry	struct
RightMenu	array
[	O
]	O
=	O
{	O
{	O
' '	O
,	O
N_	O
(	O
"&Listing mode..."	pointer
)	O
,	O
'L'	O
,	O
listing_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Quick view     C-x q"	pointer
)	O
,	O
'Q'	O
,	O
quick_view_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Info           C-x i"	pointer
)	O
,	O
'I'	O
,	O
info_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Tree"	pointer
)	O
,	O
'T'	O
,	O
tree_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Sort order..."	pointer
)	O
,	O
'S'	O
,	O
sort_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Filter..."	pointer
)	O
,	O
'F'	O
,	O
filter_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"FT&P link..."	pointer
)	O
,	O
'P'	O
,	O
ftplink_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"S&hell link..."	pointer
)	O
,	O
'H'	O
,	O
fishlink_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Rescan         C-r"	pointer
)	O
,	O
'R'	O
,	O
reread_cmd	function
}	O
}	O
;	O
static	O
menu_entry	struct
FileMenu	array
[	O
]	O
=	O
{	O
{	O
' '	O
,	O
N_	O
(	O
"&User menu          F2"	pointer
)	O
,	O
'U'	O
,	O
user_file_menu_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&View               F3"	pointer
)	O
,	O
'V'	O
,	O
view_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"Vie&w file...         "	pointer
)	O
,	O
'W'	O
,	O
view_file_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Filtered view     M-!"	pointer
)	O
,	O
'F'	O
,	O
filtered_view_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Edit               F4"	pointer
)	O
,	O
'E'	O
,	O
edit_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Copy               F5"	pointer
)	O
,	O
'C'	O
,	O
copy_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"c&Hmod           C-x c"	pointer
)	O
,	O
'H'	O
,	O
chmod_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Link            C-x l"	pointer
)	O
,	O
'L'	O
,	O
link_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&SymLink         C-x s"	pointer
)	O
,	O
'S'	O
,	O
symlink_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"edit s&Ymlink  C-x C-s"	pointer
)	O
,	O
'Y'	O
,	O
edit_symlink_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"ch&Own           C-x o"	pointer
)	O
,	O
'O'	O
,	O
chown_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Advanced chown       "	pointer
)	O
,	O
'A'	O
,	O
chown_advanced_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Rename/Move        F6"	pointer
)	O
,	O
'R'	O
,	O
ren_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Mkdir              F7"	pointer
)	O
,	O
'M'	O
,	O
mkdir_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Delete             F8"	pointer
)	O
,	O
'D'	O
,	O
delete_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Quick cd          M-c"	pointer
)	O
,	O
'Q'	O
,	O
quick_cd_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"select &Group      M-+"	pointer
)	O
,	O
'G'	O
,	O
select_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"u&Nselect group    M-\\"	pointer
)	O
,	O
'N'	O
,	O
unselect_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"reverse selec&Tion M-*"	pointer
)	O
,	O
'T'	O
,	O
reverse_selection_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"e&Xit              F10"	pointer
)	O
,	O
'X'	O
,	O
quit_cmd	function
}	O
}	O
;	O
static	O
menu_entry	struct
CmdMenu	array
[	O
]	O
=	O
{	O
{	O
' '	O
,	O
N_	O
(	O
"&Directory tree"	pointer
)	O
,	O
'D'	O
,	O
treebox_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Find file            M-?"	pointer
)	O
,	O
'F'	O
,	O
find_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"s&Wap panels          C-u"	pointer
)	O
,	O
'W'	O
,	O
swap_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"switch &Panels on/off C-o"	pointer
)	O
,	O
'P'	O
,	O
view_other_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Compare directories  C-x d"	pointer
)	O
,	O
'C'	O
,	O
compare_dirs_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"e&Xternal panelize    C-x !"	pointer
)	O
,	O
'X'	O
,	O
external_panelize	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"show directory s&Izes"	pointer
)	O
,	O
'I'	O
,	O
dirsizes_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"command &History"	pointer
)	O
,	O
'H'	O
,	O
history_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"di&Rectory hotlist    C-\\"	pointer
)	O
,	O
'R'	O
,	O
quick_chdir_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Active VFS list      C-x a"	pointer
)	O
,	O
'A'	O
,	O
reselect_vfs	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Background jobs      C-x j"	pointer
)	O
,	O
'B'	O
,	O
jobs_cmd	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"Edit &extension file"	pointer
)	O
,	O
'E'	O
,	O
ext_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"Edit &menu file"	pointer
)	O
,	O
'M'	O
,	O
edit_mc_menu_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"Edit edi&tor menu file"	pointer
)	O
,	O
'T'	O
,	O
edit_user_menu_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"Edit &syntax file"	pointer
)	O
,	O
'S'	O
,	O
edit_syntax_cmd	function
}	O
}	O
;	O
static	O
menu_entry	struct
OptMenu	array
[	O
]	O
=	O
{	O
{	O
' '	O
,	O
N_	O
(	O
"&Configuration..."	pointer
)	O
,	O
'C'	O
,	O
configure_box	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Layout..."	pointer
)	O
,	O
'L'	O
,	O
layout_cmd	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"c&Onfirmation..."	pointer
)	O
,	O
'O'	O
,	O
confirm_box	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Display bits..."	pointer
)	O
,	O
'D'	O
,	O
display_bits_box	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"learn &Keys..."	pointer
)	O
,	O
'K'	O
,	O
learn_keys	function
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Virtual FS..."	pointer
)	O
,	O
'V'	O
,	O
configure_vfs	function
}	O
,	O
{	O
' '	O
,	O
""	pointer
,	O
' '	O
,	O
0	int
}	O
,	O
{	O
' '	O
,	O
N_	O
(	O
"&Save setup"	pointer
)	O
,	O
'S'	O
,	O
save_setup_cmd	function
}	O
}	O
;	O
static	O
Menu	struct
*	O
MenuBar	array
[	O
5	int
]	O
;	O
void	O
init_menu	function
(	O
void	O
)	O
{	O
MenuBar	array
[	O
0	int
]	O
=	O
create_menu	function
(	O
horizontal_split	int
?	O
_	O
(	O
" &Above "	pointer
)	O
:	O
_	O
(	O
" &Left "	pointer
)	O
,	O
LeftMenu	array
,	O
menu_entries	O
(	O
LeftMenu	array
)	O
,	O
"[Left and Right Menus]"	pointer
)	O
;	O
MenuBar	array
[	O
1	int
]	O
=	O
create_menu	function
(	O
_	O
(	O
" &File "	pointer
)	O
,	O
FileMenu	array
,	O
menu_entries	O
(	O
FileMenu	array
)	O
,	O
"[File Menu]"	pointer
)	O
;	O
MenuBar	array
[	O
2	int
]	O
=	O
create_menu	function
(	O
_	O
(	O
" &Command "	pointer
)	O
,	O
CmdMenu	array
,	O
menu_entries	O
(	O
CmdMenu	array
)	O
,	O
"[Command Menu]"	pointer
)	O
;	O
MenuBar	array
[	O
3	int
]	O
=	O
create_menu	function
(	O
_	O
(	O
" &Options "	pointer
)	O
,	O
OptMenu	array
,	O
menu_entries	O
(	O
OptMenu	array
)	O
,	O
"[Options Menu]"	pointer
)	O
;	O
MenuBar	array
[	O
4	int
]	O
=	O
create_menu	function
(	O
horizontal_split	int
?	O
_	O
(	O
" &Below "	pointer
)	O
:	O
_	O
(	O
" &Right "	pointer
)	O
,	O
RightMenu	array
,	O
menu_entries	O
(	O
RightMenu	array
)	O
,	O
"[Left and Right Menus]"	pointer
)	O
;	O
}	O
void	O
done_menu	function
(	O
void	O
)	O
{	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
5	int
;	O
i	array
++	O
)	O
{	O
destroy_menu	function
(	O
MenuBar	array
[	O
i	array
]	O
)	O
;	O
}	O
}	O
static	O
void	O
menu_last_selected_cmd	function
(	O
void	O
)	O
{	O
the_menubar	pointer
->	O
active	int
=	O
1	int
;	O
the_menubar	pointer
->	O
dropped	int
=	O
drop_menus	int
;	O
the_menubar	pointer
->	O
previous_widget	int
=	O
midnight_dlg	pointer
->	O
current	pointer
->	O
dlg_id	int
;	O
dlg_select_widget	function
(	O
the_menubar	pointer
)	O
;	O
}	O
static	O
void	O
menu_cmd	function
(	O
void	O
)	O
{	O
if	O
(	O
the_menubar	pointer
->	O
active	int
)	O
return	O
;	O
if	O
(	O
(	O
get_current_index	function
(	O
)	O
==	O
0	int
)	O
^	O
(	O
!	O
current_panel	pointer
->	O
active	int
)	O
)	O
the_menubar	pointer
->	O
selected	int
=	O
0	int
;	O
else	O
the_menubar	pointer
->	O
selected	int
=	O
4	int
;	O
menu_last_selected_cmd	function
(	O
)	O
;	O
}	O
void	O
toggle_fast_reload	function
(	O
void	O
)	O
{	O
fast_reload	int
=	O
!	O
fast_reload	int
;	O
if	O
(	O
fast_reload_w	int
==	O
0	int
&&	O
fast_reload	int
)	O
{	O
message	pointer
(	O
0	int
,	O
_	O
(	O
" Information "	pointer
)	O
,	O
_	O
(	O
" Using the fast reload option may not reflect the exact \n"	pointer
" directory contents. In this case you'll need to do a   \n"	pointer
" manual reload of the directory. See the man page for   \n"	pointer
" the details.                                           "	pointer
)	O
)	O
;	O
fast_reload_w	int
=	O
1	int
;	O
}	O
}	O
void	O
toggle_mix_all_files	function
(	O
void	O
)	O
{	O
mix_all_files	int
=	O
!	O
mix_all_files	int
;	O
update_panels	function
(	O
UP_RELOAD	int
,	O
UP_KEEPSEL	O
)	O
;	O
}	O
void	O
toggle_show_backup	function
(	O
void	O
)	O
{	O
show_backups	int
=	O
!	O
show_backups	int
;	O
update_panels	function
(	O
UP_RELOAD	int
,	O
UP_KEEPSEL	O
)	O
;	O
}	O
void	O
toggle_show_hidden	function
(	O
void	O
)	O
{	O
show_dot_files	int
=	O
!	O
show_dot_files	int
;	O
update_panels	function
(	O
UP_RELOAD	int
,	O
UP_KEEPSEL	O
)	O
;	O
}	O
static	O
void	O
translated_mc_chdir	function
(	O
char	O
*	O
dir	pointer
)	O
{	O
char	O
*	O
newdir	pointer
;	O
newdir	pointer
=	O
vfs_translate_url	function
(	O
dir	pointer
)	O
;	O
mc_chdir	function
(	O
newdir	pointer
)	O
;	O
g_free	function
(	O
newdir	pointer
)	O
;	O
}	O
static	O
void	O
create_panels	function
(	O
void	O
)	O
{	O
int	O
current_index	int
;	O
int	O
other_index	int
;	O
int	O
current_mode	int
;	O
int	O
other_mode	int
;	O
char	O
original_dir	array
[	O
1024	int
]	O
;	O
original_dir	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
boot_current_is_left	int
)	O
{	O
current_index	int
=	O
0	int
;	O
other_index	int
=	O
1	int
;	O
current_mode	int
=	O
startup_left_mode	int
;	O
other_mode	int
=	O
startup_right_mode	int
;	O
}	O
else	O
{	O
current_index	int
=	O
1	int
;	O
other_index	int
=	O
0	int
;	O
current_mode	int
=	O
startup_right_mode	int
;	O
other_mode	int
=	O
startup_left_mode	int
;	O
}	O
if	O
(	O
this_dir	pointer
)	O
{	O
if	O
(	O
other_dir	pointer
)	O
{	O
mc_get_current_wd	function
(	O
original_dir	array
,	O
sizeof	O
(	O
original_dir	array
)	O
-	O
2	int
)	O
;	O
}	O
translated_mc_chdir	function
(	O
this_dir	pointer
)	O
;	O
}	O
set_display_type	function
(	O
current_index	int
,	O
current_mode	int
)	O
;	O
if	O
(	O
other_dir	pointer
)	O
{	O
if	O
(	O
original_dir	array
[	O
0	int
]	O
)	O
translated_mc_chdir	function
(	O
original_dir	array
)	O
;	O
translated_mc_chdir	function
(	O
other_dir	pointer
)	O
;	O
}	O
set_display_type	function
(	O
other_index	int
,	O
other_mode	int
)	O
;	O
if	O
(	O
startup_left_mode	int
==	O
view_listing	int
)	O
{	O
current_panel	pointer
=	O
left_panel	pointer
;	O
}	O
else	O
{	O
if	O
(	O
right_panel	pointer
)	O
current_panel	pointer
=	O
right_panel	pointer
;	O
else	O
current_panel	pointer
=	O
left_panel	pointer
;	O
}	O
cmdline	pointer
=	O
command_new	function
(	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
the_prompt	pointer
=	O
label_new	function
(	O
0	int
,	O
0	int
,	O
prompt	pointer
)	O
;	O
the_prompt	pointer
->	O
transparent	int
=	O
1	int
;	O
the_bar	pointer
=	O
buttonbar_new	function
(	O
keybar_visible	int
)	O
;	O
the_hint	pointer
=	O
label_new	function
(	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
the_hint	pointer
->	O
transparent	int
=	O
1	int
;	O
the_hint	pointer
->	O
auto_adjust_cols	int
=	O
0	int
;	O
the_hint	pointer
->	O
widget	pointer
.	O
cols	int
=	O
COLS	O
;	O
the_menubar	pointer
=	O
menubar_new	function
(	O
0	int
,	O
0	int
,	O
COLS	O
,	O
MenuBar	array
,	O
5	int
)	O
;	O
}	O
static	O
void	O
copy_current_pathname	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
command_prompt	int
)	O
return	O
;	O
command_insert	function
(	O
cmdline	pointer
,	O
current_panel	pointer
->	O
cwd	short
,	O
0	int
)	O
;	O
if	O
(	O
current_panel	pointer
->	O
cwd	short
[	O
strlen	function
(	O
current_panel	pointer
->	O
cwd	short
)	O
-	O
1	int
]	O
!=	O
PATH_SEP	char
)	O
command_insert	function
(	O
cmdline	pointer
,	O
PATH_SEP_STR	pointer
,	O
0	int
)	O
;	O
}	O
static	O
void	O
copy_other_pathname	function
(	O
void	O
)	O
{	O
if	O
(	O
get_other_type	function
(	O
)	O
!=	O
view_listing	int
)	O
return	O
;	O
if	O
(	O
!	O
command_prompt	int
)	O
return	O
;	O
command_insert	function
(	O
cmdline	pointer
,	O
other_panel	O
->	O
cwd	short
,	O
0	int
)	O
;	O
if	O
(	O
other_panel	O
->	O
cwd	short
[	O
strlen	function
(	O
other_panel	O
->	O
cwd	short
)	O
-	O
1	int
]	O
!=	O
PATH_SEP	char
)	O
command_insert	function
(	O
cmdline	pointer
,	O
PATH_SEP_STR	pointer
,	O
0	int
)	O
;	O
}	O
static	O
void	O
copy_readlink	function
(	O
WPanel	struct
*	O
panel	pointer
)	O
{	O
if	O
(	O
!	O
command_prompt	int
)	O
return	O
;	O
if	O
(	O
S_ISLNK	O
(	O
selection	O
(	O
panel	pointer
)	O
->	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
char	O
buffer	pointer
[	O
MC_MAXPATHLEN	O
]	O
;	O
char	O
*	O
p	pointer
=	O
concat_dir_and_file	function
(	O
panel	pointer
->	O
cwd	short
,	O
selection	O
(	O
panel	pointer
)	O
->	O
fname	pointer
)	O
;	O
int	O
i	array
;	O
i	array
=	O
mc_readlink	function
(	O
p	pointer
,	O
buffer	pointer
,	O
MC_MAXPATHLEN	O
-	O
1	int
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
if	O
(	O
i	array
>	O
0	int
)	O
{	O
buffer	pointer
[	O
i	array
]	O
=	O
0	int
;	O
command_insert	function
(	O
cmdline	pointer
,	O
buffer	pointer
,	O
1	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
copy_current_readlink	function
(	O
void	O
)	O
{	O
copy_readlink	function
(	O
current_panel	pointer
)	O
;	O
}	O
static	O
void	O
copy_other_readlink	function
(	O
void	O
)	O
{	O
if	O
(	O
get_other_type	function
(	O
)	O
!=	O
view_listing	int
)	O
return	O
;	O
copy_readlink	function
(	O
other_panel	O
)	O
;	O
}	O
static	O
void	O
copy_prog_name	function
(	O
void	O
)	O
{	O
char	O
*	O
tmp	pointer
;	O
if	O
(	O
!	O
command_prompt	int
)	O
return	O
;	O
if	O
(	O
get_current_type	function
(	O
)	O
==	O
view_tree	int
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
(	O
WTree	struct
*	O
)	O
get_panel_widget	function
(	O
get_current_index	function
(	O
)	O
)	O
;	O
tmp	pointer
=	O
tree_selected_name	function
(	O
tree	pointer
)	O
;	O
}	O
else	O
tmp	pointer
=	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
;	O
command_insert	function
(	O
cmdline	pointer
,	O
tmp	pointer
,	O
1	int
)	O
;	O
}	O
static	O
void	O
copy_tagged	function
(	O
WPanel	struct
*	O
panel	pointer
)	O
{	O
int	O
i	array
;	O
if	O
(	O
!	O
command_prompt	int
)	O
return	O
;	O
input_disable_update	function
(	O
cmdline	pointer
)	O
;	O
if	O
(	O
panel	pointer
->	O
marked	int
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
panel	pointer
->	O
count	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
)	O
command_insert	function
(	O
cmdline	pointer
,	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
,	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
command_insert	function
(	O
cmdline	pointer
,	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
panel	pointer
->	O
selected	int
]	O
.	O
fname	pointer
,	O
1	int
)	O
;	O
}	O
input_enable_update	function
(	O
cmdline	pointer
)	O
;	O
}	O
static	O
void	O
copy_current_tagged	function
(	O
void	O
)	O
{	O
copy_tagged	function
(	O
current_panel	pointer
)	O
;	O
}	O
static	O
void	O
copy_other_tagged	function
(	O
void	O
)	O
{	O
if	O
(	O
get_other_type	function
(	O
)	O
!=	O
view_listing	int
)	O
return	O
;	O
copy_tagged	function
(	O
other_panel	O
)	O
;	O
}	O
static	O
void	O
init_labels	function
(	O
void	O
)	O
{	O
buttonbar_set_label	function
(	O
midnight_dlg	pointer
,	O
1	int
,	O
_	O
(	O
"Help"	pointer
)	O
,	O
help_cmd	function
)	O
;	O
buttonbar_set_label	function
(	O
midnight_dlg	pointer
,	O
2	int
,	O
_	O
(	O
"Menu"	pointer
)	O
,	O
user_file_menu_cmd	function
)	O
;	O
buttonbar_set_label	function
(	O
midnight_dlg	pointer
,	O
9	int
,	O
_	O
(	O
"PullDn"	pointer
)	O
,	O
menu_cmd	function
)	O
;	O
buttonbar_set_label	function
(	O
midnight_dlg	pointer
,	O
10	int
,	O
_	O
(	O
"Quit"	pointer
)	O
,	O
quit_cmd	function
)	O
;	O
}	O
static	O
const	O
key_map	struct
ctl_x_map	array
[	O
]	O
=	O
{	O
{	O
XCTRL	O
(	O
'c'	O
)	O
,	O
quit_cmd	function
}	O
,	O
{	O
'd'	O
,	O
compare_dirs_cmd	function
}	O
,	O
{	O
'a'	O
,	O
reselect_vfs	function
}	O
,	O
{	O
'p'	O
,	O
copy_current_pathname	function
}	O
,	O
{	O
XCTRL	O
(	O
'p'	O
)	O
,	O
copy_other_pathname	function
}	O
,	O
{	O
't'	O
,	O
copy_current_tagged	function
}	O
,	O
{	O
XCTRL	O
(	O
't'	O
)	O
,	O
copy_other_tagged	function
}	O
,	O
{	O
'c'	O
,	O
chmod_cmd	function
}	O
,	O
{	O
'o'	O
,	O
chown_cmd	function
}	O
,	O
{	O
'r'	O
,	O
copy_current_readlink	function
}	O
,	O
{	O
XCTRL	O
(	O
'r'	O
)	O
,	O
copy_other_readlink	function
}	O
,	O
{	O
'l'	O
,	O
link_cmd	function
}	O
,	O
{	O
's'	O
,	O
symlink_cmd	function
}	O
,	O
{	O
XCTRL	O
(	O
's'	O
)	O
,	O
edit_symlink_cmd	function
}	O
,	O
{	O
'i'	O
,	O
info_cmd_no_menu	function
}	O
,	O
{	O
'q'	O
,	O
quick_cmd_no_menu	function
}	O
,	O
{	O
'h'	O
,	O
add2hotlist_cmd	function
}	O
,	O
{	O
'!'	O
,	O
external_panelize	function
}	O
,	O
{	O
'j'	O
,	O
jobs_cmd	function
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
int	O
ctl_x_map_enabled	int
=	O
0	int
;	O
static	O
void	O
ctl_x_cmd	function
(	O
void	O
)	O
{	O
ctl_x_map_enabled	int
=	O
1	int
;	O
}	O
static	O
void	O
nothing	function
(	O
void	O
)	O
{	O
}	O
static	O
const	O
key_map	struct
default_map	array
[	O
]	O
=	O
{	O
{	O
KEY_F	O
(	O
19	int
)	O
,	O
menu_last_selected_cmd	function
}	O
,	O
{	O
KEY_F	O
(	O
20	int
)	O
,	O
quiet_quit_cmd	function
}	O
,	O
{	O
XCTRL	O
(	O
'@'	O
)	O
,	O
single_dirsize_cmd	function
}	O
,	O
{	O
ALT	O
(	O
'a'	O
)	O
,	O
copy_current_pathname	function
}	O
,	O
{	O
ALT	O
(	O
'A'	O
)	O
,	O
copy_other_pathname	function
}	O
,	O
{	O
ALT	O
(	O
'c'	O
)	O
,	O
quick_cd_cmd	function
}	O
,	O
{	O
XCTRL	O
(	O
'\\'	O
)	O
,	O
quick_chdir_cmd	function
}	O
,	O
{	O
XCTRL	O
(	O
'z'	O
)	O
,	O
suspend_cmd	function
}	O
,	O
{	O
ALT	O
(	O
'!'	O
)	O
,	O
filtered_view_cmd	function
}	O
,	O
{	O
ALT	O
(	O
'?'	O
)	O
,	O
find_cmd	function
}	O
,	O
{	O
XCTRL	O
(	O
'r'	O
)	O
,	O
reread_cmd	function
}	O
,	O
{	O
ALT	O
(	O
't'	O
)	O
,	O
toggle_listing_cmd	function
}	O
,	O
{	O
XCTRL	O
(	O
'u'	O
)	O
,	O
swap_cmd	function
}	O
,	O
{	O
XCTRL	O
(	O
'o'	O
)	O
,	O
view_other_cmd	function
}	O
,	O
{	O
XCTRL	O
(	O
'x'	O
)	O
,	O
ctl_x_cmd	function
}	O
,	O
{	O
ESC_CHAR	char
,	O
nothing	function
}	O
,	O
{	O
XCTRL	O
(	O
'c'	O
)	O
,	O
nothing	function
}	O
,	O
{	O
XCTRL	O
(	O
'g'	O
)	O
,	O
nothing	function
}	O
,	O
{	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
static	O
void	O
setup_sigwinch	function
(	O
void	O
)	O
{	O
struct	O
sigaction	struct
act	struct
,	O
oact	struct
;	O
act	struct
.	O
sa_handler	pointer
=	O
flag_winch	function
;	O
sigemptyset	function
(	O
&	O
act	struct
.	O
sa_mask	struct
)	O
;	O
act	struct
.	O
sa_flags	int
=	O
0	int
;	O
act	struct
.	O
sa_flags	int
|=	O
SA_RESTART	int
;	O
sigaction	struct
(	O
SIGWINCH	int
,	O
&	O
act	struct
,	O
&	O
oact	struct
)	O
;	O
}	O
static	O
void	O
setup_pre	function
(	O
void	O
)	O
{	O
SLsmg_Display_Eight_Bit	int
=	O
full_eight_bits	int
?	O
128	int
:	O
160	int
;	O
}	O
static	O
void	O
init_xterm_support	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
termvalue	pointer
;	O
termvalue	pointer
=	O
getenv	function
(	O
"TERM"	pointer
)	O
;	O
if	O
(	O
!	O
termvalue	pointer
||	O
!	O
(	O
*	O
termvalue	pointer
)	O
)	O
{	O
fputs	function
(	O
_	O
(	O
"The TERM environment variable is unset!\n"	pointer
)	O
,	O
stderr	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
xmouse_seq	pointer
=	O
tty_tgetstr	function
(	O
"Km"	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
termvalue	pointer
,	O
"cygwin"	pointer
)	O
==	O
0	int
)	O
{	O
force_xterm	int
=	O
1	int
;	O
use_mouse_p	enum
=	O
MOUSE_DISABLED	int
;	O
}	O
if	O
(	O
force_xterm	int
||	O
strncmp	function
(	O
termvalue	pointer
,	O
"xterm"	pointer
,	O
5	int
)	O
==	O
0	int
||	O
strncmp	function
(	O
termvalue	pointer
,	O
"rxvt"	pointer
,	O
4	int
)	O
==	O
0	int
||	O
strcmp	function
(	O
termvalue	pointer
,	O
"Eterm"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
termvalue	pointer
,	O
"dtterm"	pointer
)	O
==	O
0	int
)	O
{	O
xterm_flag	int
=	O
1	int
;	O
if	O
(	O
!	O
xmouse_seq	pointer
)	O
{	O
xmouse_seq	pointer
=	O
ESC_STR	pointer
"[M"	pointer
;	O
}	O
if	O
(	O
use_mouse_p	enum
!=	O
MOUSE_DISABLED	int
)	O
{	O
const	O
char	O
*	O
color_term	pointer
=	O
getenv	function
(	O
"COLORTERM"	pointer
)	O
;	O
if	O
(	O
strncmp	function
(	O
termvalue	pointer
,	O
"rxvt"	pointer
,	O
4	int
)	O
==	O
0	int
||	O
(	O
color_term	pointer
!=	O
NULL	O
&&	O
strncmp	function
(	O
color_term	pointer
,	O
"rxvt"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
||	O
strcmp	function
(	O
termvalue	pointer
,	O
"Eterm"	pointer
)	O
==	O
0	int
)	O
{	O
use_mouse_p	enum
=	O
MOUSE_XTERM_NORMAL_TRACKING	int
;	O
}	O
else	O
{	O
use_mouse_p	enum
=	O
MOUSE_XTERM_BUTTON_EVENT_TRACKING	int
;	O
}	O
}	O
}	O
}	O
static	O
void	O
setup_mc	function
(	O
void	O
)	O
{	O
setup_pre	function
(	O
)	O
;	O
init_menu	function
(	O
)	O
;	O
create_panels	function
(	O
)	O
;	O
setup_panels	function
(	O
)	O
;	O
if	O
(	O
use_subshell	int
)	O
add_select_channel	function
(	O
subshell_pty	int
,	O
load_prompt	function
,	O
0	int
)	O
;	O
setup_sigwinch	function
(	O
)	O
;	O
if	O
(	O
baudrate	O
(	O
)	O
<	O
9600	int
||	O
slow_terminal	int
)	O
{	O
verbose	int
=	O
0	int
;	O
}	O
init_mouse	function
(	O
)	O
;	O
}	O
static	O
void	O
setup_dummy_mc	function
(	O
)	O
{	O
char	O
d	double
[	O
MC_MAXPATHLEN	O
]	O
;	O
mc_get_current_wd	function
(	O
d	double
,	O
MC_MAXPATHLEN	O
)	O
;	O
setup_mc	function
(	O
)	O
;	O
mc_chdir	function
(	O
d	double
)	O
;	O
}	O
static	O
void	O
done_mc	function
(	O
void	O
)	O
{	O
disable_mouse	function
(	O
)	O
;	O
done_menu	function
(	O
)	O
;	O
if	O
(	O
auto_save_setup	int
)	O
save_setup	function
(	O
)	O
;	O
else	O
save_hotlist	function
(	O
)	O
;	O
done_screen	function
(	O
)	O
;	O
vfs_add_current_stamps	function
(	O
)	O
;	O
}	O
static	O
void	O
done_mc_profile	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
auto_save_setup	int
)	O
profile_forget_profile	function
(	O
profile_name	pointer
)	O
;	O
sync_profiles	function
(	O
)	O
;	O
done_setup	function
(	O
)	O
;	O
free_profiles	function
(	O
)	O
;	O
}	O
static	O
cb_ret_t	enum
midnight_callback	function
(	O
struct	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
int	O
i	array
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
DLG_IDLE	int
:	O
set_idle_proc	function
(	O
h	pointer
,	O
0	int
)	O
;	O
if	O
(	O
auto_menu	int
)	O
{	O
user_file_menu_cmd	function
(	O
)	O
;	O
}	O
return	O
MSG_HANDLED	int
;	O
case	O
DLG_KEY	int
:	O
if	O
(	O
ctl_x_map_enabled	int
)	O
{	O
ctl_x_map_enabled	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
ctl_x_map	array
[	O
i	array
]	O
.	O
key_code	int
;	O
i	array
++	O
)	O
if	O
(	O
parm	int
==	O
ctl_x_map	array
[	O
i	array
]	O
.	O
key_code	int
)	O
{	O
(	O
*	O
ctl_x_map	array
[	O
i	array
]	O
.	O
fn	pointer
)	O
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
}	O
if	O
(	O
the_menubar	pointer
->	O
active	int
)	O
return	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
parm	int
==	O
KEY_F	O
(	O
10	int
)	O
)	O
{	O
quit_cmd	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
parm	int
==	O
'\t'	O
)	O
free_completions	function
(	O
cmdline	pointer
)	O
;	O
if	O
(	O
parm	int
==	O
'\n'	O
)	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
cmdline	pointer
->	O
buffer	pointer
[	O
i	array
]	O
&&	O
(	O
cmdline	pointer
->	O
buffer	pointer
[	O
i	array
]	O
==	O
' '	O
||	O
cmdline	pointer
->	O
buffer	pointer
[	O
i	array
]	O
==	O
'\t'	O
)	O
;	O
i	array
++	O
)	O
;	O
if	O
(	O
cmdline	pointer
->	O
buffer	pointer
[	O
i	array
]	O
)	O
{	O
send_message	function
(	O
(	O
Widget	struct
*	O
)	O
cmdline	pointer
,	O
WIDGET_KEY	int
,	O
parm	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
stuff	function
(	O
cmdline	pointer
,	O
""	pointer
,	O
0	int
)	O
;	O
cmdline	pointer
->	O
point	int
=	O
0	int
;	O
}	O
if	O
(	O
(	O
(	O
parm	int
&	O
~	O
(	O
KEY_M_CTRL	int
|	O
KEY_M_ALT	int
)	O
)	O
==	O
'\n'	O
)	O
&&	O
(	O
parm	int
&	O
(	O
KEY_M_CTRL	int
|	O
KEY_M_ALT	int
)	O
)	O
)	O
{	O
copy_prog_name	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
parm	int
==	O
(	O
KEY_M_CTRL	int
|	O
KEY_M_SHIFT	int
|	O
'\n'	O
)	O
)	O
{	O
copy_current_pathname	function
(	O
)	O
;	O
copy_prog_name	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
(	O
!	O
alternate_plus_minus	int
||	O
!	O
(	O
console_flag	char
||	O
xterm_flag	int
)	O
)	O
&&	O
!	O
quote	int
&&	O
!	O
current_panel	pointer
->	O
searching	int
)	O
{	O
if	O
(	O
!	O
only_leading_plus_minus	int
)	O
{	O
if	O
(	O
parm	int
==	O
'+'	O
)	O
{	O
select_cmd	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
parm	int
==	O
'\\'	O
||	O
parm	int
==	O
'-'	O
)	O
{	O
unselect_cmd	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
parm	int
==	O
'*'	O
)	O
{	O
reverse_selection_cmd	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
command_prompt	int
||	O
!	O
cmdline	pointer
->	O
buffer	pointer
[	O
0	int
]	O
)	O
{	O
if	O
(	O
parm	int
==	O
'+'	O
)	O
{	O
select_cmd	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
parm	int
==	O
'\\'	O
||	O
parm	int
==	O
'-'	O
)	O
{	O
unselect_cmd	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
parm	int
==	O
'*'	O
)	O
{	O
reverse_selection_cmd	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
}	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
DLG_HOTKEY_HANDLED	int
:	O
if	O
(	O
(	O
get_current_type	function
(	O
)	O
==	O
view_listing	int
)	O
&&	O
current_panel	pointer
->	O
searching	int
)	O
{	O
current_panel	pointer
->	O
searching	int
=	O
0	int
;	O
current_panel	pointer
->	O
dirty	int
=	O
1	int
;	O
}	O
return	O
MSG_HANDLED	int
;	O
case	O
DLG_UNHANDLED_KEY	int
:	O
if	O
(	O
command_prompt	int
)	O
{	O
int	O
v	pointer
;	O
v	pointer
=	O
send_message	function
(	O
(	O
Widget	struct
*	O
)	O
cmdline	pointer
,	O
WIDGET_KEY	int
,	O
parm	int
)	O
;	O
if	O
(	O
v	pointer
)	O
return	O
v	pointer
;	O
}	O
if	O
(	O
ctl_x_map_enabled	int
)	O
{	O
ctl_x_map_enabled	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
ctl_x_map	array
[	O
i	array
]	O
.	O
key_code	int
;	O
i	array
++	O
)	O
if	O
(	O
parm	int
==	O
ctl_x_map	array
[	O
i	array
]	O
.	O
key_code	int
)	O
{	O
(	O
*	O
ctl_x_map	array
[	O
i	array
]	O
.	O
fn	pointer
)	O
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
}	O
else	O
{	O
for	O
(	O
i	array
=	O
0	int
;	O
default_map	array
[	O
i	array
]	O
.	O
key_code	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
parm	int
==	O
default_map	array
[	O
i	array
]	O
.	O
key_code	int
)	O
{	O
(	O
*	O
default_map	array
[	O
i	array
]	O
.	O
fn	pointer
)	O
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
}	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
case	O
DLG_DRAW	int
:	O
if	O
(	O
console_flag	char
&&	O
output_lines	int
)	O
show_console_contents	function
(	O
output_start_y	int
,	O
LINES	O
-	O
output_lines	int
-	O
keybar_visible	int
-	O
1	int
,	O
LINES	O
-	O
keybar_visible	int
-	O
1	int
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
DLG_POST_KEY	int
:	O
if	O
(	O
!	O
the_menubar	pointer
->	O
active	int
)	O
update_dirty_panels	function
(	O
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_dlg_callback	function
(	O
h	pointer
,	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
void	O
update_xterm_title_path	function
(	O
void	O
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
s	pointer
;	O
if	O
(	O
xterm_flag	int
&&	O
xterm_title	int
)	O
{	O
p	pointer
=	O
s	pointer
=	O
g_strdup	function
(	O
strip_home_and_password	function
(	O
current_panel	pointer
->	O
cwd	short
)	O
)	O
;	O
do	O
{	O
if	O
(	O
!	O
is_printable	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
)	O
)	O
*	O
s	pointer
=	O
'?'	O
;	O
}	O
while	O
(	O
*	O
++	O
s	pointer
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"\33]0;mc - %s\7"	pointer
,	O
p	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
}	O
void	O
load_hint	function
(	O
int	O
force	int
)	O
{	O
char	O
*	O
hint	pointer
;	O
if	O
(	O
!	O
the_hint	pointer
->	O
widget	pointer
.	O
parent	pointer
)	O
return	O
;	O
if	O
(	O
!	O
message_visible	int
)	O
{	O
label_set_text	function
(	O
the_hint	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
hint	pointer
=	O
get_random_hint	function
(	O
force	int
)	O
)	O
)	O
{	O
if	O
(	O
*	O
hint	pointer
)	O
set_hintbar	function
(	O
hint	pointer
)	O
;	O
g_free	function
(	O
hint	pointer
)	O
;	O
}	O
else	O
{	O
char	O
text	pointer
[	O
BUF_SMALL	int
]	O
;	O
g_snprintf	function
(	O
text	pointer
,	O
sizeof	O
(	O
text	pointer
)	O
,	O
_	O
(	O
"GNU Midnight Commander %s\n"	pointer
)	O
,	O
VERSION	pointer
)	O
;	O
set_hintbar	function
(	O
text	pointer
)	O
;	O
}	O
}	O
static	O
void	O
setup_panels_and_run_mc	function
(	O
void	O
)	O
{	O
add_widget	function
(	O
midnight_dlg	pointer
,	O
the_menubar	pointer
)	O
;	O
add_widget	function
(	O
midnight_dlg	pointer
,	O
get_panel_widget	function
(	O
0	int
)	O
)	O
;	O
add_widget	function
(	O
midnight_dlg	pointer
,	O
get_panel_widget	function
(	O
1	int
)	O
)	O
;	O
add_widget	function
(	O
midnight_dlg	pointer
,	O
the_hint	pointer
)	O
;	O
load_hint	function
(	O
1	int
)	O
;	O
add_widget	function
(	O
midnight_dlg	pointer
,	O
cmdline	pointer
)	O
;	O
add_widget	function
(	O
midnight_dlg	pointer
,	O
the_prompt	pointer
)	O
;	O
add_widget	function
(	O
midnight_dlg	pointer
,	O
the_bar	pointer
)	O
;	O
init_labels	function
(	O
)	O
;	O
if	O
(	O
boot_current_is_left	int
)	O
dlg_select_widget	function
(	O
get_panel_widget	function
(	O
0	int
)	O
)	O
;	O
else	O
dlg_select_widget	function
(	O
get_panel_widget	function
(	O
1	int
)	O
)	O
;	O
run_dlg	function
(	O
midnight_dlg	pointer
)	O
;	O
}	O
static	O
char	O
*	O
prepend_cwd_on_local	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
char	O
*	O
d	double
;	O
int	O
l	pointer
;	O
if	O
(	O
vfs_file_is_local	function
(	O
filename	pointer
)	O
)	O
{	O
if	O
(	O
*	O
filename	pointer
==	O
PATH_SEP	char
)	O
return	O
g_strdup	function
(	O
filename	pointer
)	O
;	O
d	double
=	O
g_malloc	function
(	O
MC_MAXPATHLEN	O
+	O
strlen	function
(	O
filename	pointer
)	O
+	O
2	int
)	O
;	O
mc_get_current_wd	function
(	O
d	double
,	O
MC_MAXPATHLEN	O
)	O
;	O
l	pointer
=	O
strlen	function
(	O
d	double
)	O
;	O
d	double
[	O
l	pointer
++	O
]	O
=	O
PATH_SEP	char
;	O
strcpy	function
(	O
d	double
+	O
l	pointer
,	O
filename	pointer
)	O
;	O
canonicalize_pathname	function
(	O
d	double
)	O
;	O
return	O
d	double
;	O
}	O
else	O
return	O
g_strdup	function
(	O
filename	pointer
)	O
;	O
}	O
static	O
int	O
mc_maybe_editor_or_viewer	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
(	O
view_one_file	pointer
||	O
edit_one_file	pointer
)	O
)	O
return	O
0	int
;	O
setup_dummy_mc	function
(	O
)	O
;	O
if	O
(	O
view_one_file	pointer
)	O
{	O
char	O
*	O
path	pointer
=	O
NULL	O
;	O
path	pointer
=	O
prepend_cwd_on_local	function
(	O
view_one_file	pointer
)	O
;	O
view_file	function
(	O
path	pointer
,	O
0	int
,	O
1	int
)	O
;	O
g_free	function
(	O
path	pointer
)	O
;	O
}	O
else	O
{	O
edit_file	function
(	O
edit_one_file	pointer
,	O
edit_one_file_start_line	int
)	O
;	O
}	O
midnight_shutdown	int
=	O
1	int
;	O
done_mc	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
do_nc	function
(	O
void	O
)	O
{	O
int	O
midnight_colors	array
[	O
4	int
]	O
;	O
midnight_colors	array
[	O
0	int
]	O
=	O
NORMAL_COLOR	O
;	O
midnight_colors	array
[	O
1	int
]	O
=	O
REVERSE_COLOR	O
;	O
midnight_colors	array
[	O
2	int
]	O
=	O
INPUT_COLOR	O
;	O
midnight_colors	array
[	O
3	int
]	O
=	O
NORMAL_COLOR	O
;	O
midnight_dlg	pointer
=	O
create_dlg	function
(	O
0	int
,	O
0	int
,	O
LINES	O
,	O
COLS	O
,	O
midnight_colors	array
,	O
midnight_callback	function
,	O
"[main]"	pointer
,	O
NULL	O
,	O
DLG_WANT_IDLE	O
)	O
;	O
if	O
(	O
mc_maybe_editor_or_viewer	function
(	O
)	O
)	O
return	O
;	O
setup_mc	function
(	O
)	O
;	O
setup_panels_and_run_mc	function
(	O
)	O
;	O
midnight_shutdown	int
=	O
1	int
;	O
if	O
(	O
last_wd_file	pointer
&&	O
vfs_current_is_local	function
(	O
)	O
)	O
{	O
last_wd_string	pointer
=	O
g_strdup	function
(	O
current_panel	pointer
->	O
cwd	short
)	O
;	O
}	O
done_mc	function
(	O
)	O
;	O
destroy_dlg	function
(	O
midnight_dlg	pointer
)	O
;	O
current_panel	pointer
=	O
0	int
;	O
done_mc_profile	function
(	O
)	O
;	O
}	O
static	O
void	O
OS_Setup	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
mc_libdir	pointer
;	O
shell	pointer
=	O
getenv	function
(	O
"SHELL"	pointer
)	O
;	O
if	O
(	O
!	O
shell	pointer
||	O
!	O
*	O
shell	pointer
)	O
{	O
struct	O
passwd	struct
*	O
pwd	pointer
;	O
pwd	pointer
=	O
getpwuid	function
(	O
geteuid	function
(	O
)	O
)	O
;	O
if	O
(	O
pwd	pointer
!=	O
NULL	O
)	O
shell	pointer
=	O
g_strdup	function
(	O
pwd	pointer
->	O
pw_shell	pointer
)	O
;	O
}	O
if	O
(	O
!	O
shell	pointer
||	O
!	O
*	O
shell	pointer
)	O
shell	pointer
=	O
"/bin/sh"	pointer
;	O
if	O
(	O
(	O
mc_libdir	pointer
=	O
getenv	function
(	O
"MC_DATADIR"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
mc_home	pointer
=	O
g_strdup	function
(	O
mc_libdir	pointer
)	O
;	O
}	O
else	O
{	O
mc_home	pointer
=	O
g_strdup	function
(	O
DATADIR	O
)	O
;	O
}	O
}	O
static	O
void	O
sigchld_handler_no_subshell	function
(	O
int	O
sig	int
)	O
{	O
int	O
pid	int
,	O
status	int
;	O
if	O
(	O
!	O
console_flag	char
)	O
return	O
;	O
pid	int
=	O
waitpid	function
(	O
cons_saver_pid	int
,	O
&	O
status	int
,	O
WUNTRACED	int
|	O
WNOHANG	int
)	O
;	O
if	O
(	O
pid	int
==	O
cons_saver_pid	int
)	O
{	O
if	O
(	O
WIFSTOPPED	O
(	O
status	int
)	O
)	O
{	O
kill	function
(	O
pid	int
,	O
SIGCONT	int
)	O
;	O
}	O
else	O
{	O
handle_console	function
(	O
CONSOLE_DONE	int
)	O
;	O
console_flag	char
=	O
0	int
;	O
}	O
}	O
(	O
void	O
)	O
sig	int
;	O
}	O
static	O
void	O
init_sigchld	function
(	O
void	O
)	O
{	O
struct	O
sigaction	struct
sigchld_action	struct
;	O
sigchld_action	struct
.	O
sa_handler	pointer
=	O
use_subshell	int
?	O
sigchld_handler	function
:	O
sigchld_handler_no_subshell	function
;	O
sigemptyset	function
(	O
&	O
sigchld_action	struct
.	O
sa_mask	struct
)	O
;	O
sigchld_action	struct
.	O
sa_flags	int
=	O
SA_RESTART	int
;	O
if	O
(	O
sigaction	struct
(	O
SIGCHLD	int
,	O
&	O
sigchld_action	struct
,	O
NULL	O
)	O
==	O
-	O
1	int
)	O
{	O
use_subshell	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
print_mc_usage	function
(	O
poptContext	pointer
ctx	pointer
,	O
FILE	struct
*	O
stream	pointer
)	O
{	O
int	O
leftColWidth	int
;	O
poptSetOtherOptionHelp	function
(	O
ctx	pointer
,	O
_	O
(	O
"[flags] [this_dir] [other_panel_dir]\n"	pointer
)	O
)	O
;	O
leftColWidth	int
=	O
poptPrintHelp	function
(	O
ctx	pointer
,	O
stream	pointer
,	O
0	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  %-*s   %s\n"	pointer
,	O
leftColWidth	int
,	O
_	O
(	O
"+number"	pointer
)	O
,	O
_	O
(	O
"Set initial line number for the internal editor"	pointer
)	O
)	O
;	O
fputs	function
(	O
_	O
(	O
"\n"	pointer
"Please send any bug reports (including the output of `mc -V')\n"	pointer
"to mc-devel@gnome.org\n"	pointer
)	O
,	O
stream	pointer
)	O
;	O
show_version	function
(	O
0	int
)	O
;	O
}	O
static	O
void	O
print_color_usage	function
(	O
void	O
)	O
{	O
fputs	function
(	O
_	O
(	O
"--colors KEYWORD={FORE},{BACK}\n\n"	pointer
"{FORE} and {BACK} can be omitted, and the default will be used\n"	pointer
"\n"	pointer
"Keywords:\n"	pointer
"   Global:       errors, reverse, gauge, input, viewunderline\n"	pointer
"   File display: normal, selected, marked, markselect\n"	pointer
"   Dialog boxes: dnormal, dfocus, dhotnormal, dhotfocus, errdhotnormal,\n"	pointer
"                 errdhotfocus\n"	pointer
"   Menus:        menu, menuhot, menusel, menuhotsel\n"	pointer
"   Editor:       editnormal, editbold, editmarked\n"	pointer
"   Help:         helpnormal, helpitalic, helpbold, helplink, helpslink\n"	pointer
"   File types:   directory, executable, link, stalelink, device, special, core\n"	pointer
"\n"	pointer
"Colors:\n"	pointer
"   black, gray, red, brightred, green, brightgreen, brown,\n"	pointer
"   yellow, blue, brightblue, magenta, brightmagenta, cyan,\n"	pointer
"   brightcyan, lightgray and white\n\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
static	O
void	O
process_args	function
(	O
poptContext	pointer
ctx	pointer
,	O
int	O
c	int
,	O
const	O
char	O
*	O
option_arg	pointer
)	O
{	O
switch	O
(	O
c	int
)	O
{	O
case	O
'V'	O
:	O
show_version	function
(	O
1	int
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
disable_colors	int
=	O
0	int
;	O
force_colors	int
=	O
1	int
;	O
break	O
;	O
case	O
'f'	O
:	O
printf	function
(	O
"%s\n"	pointer
,	O
mc_home	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
mc_setctl	function
(	O
"/#ftp:"	pointer
,	O
VFS_SETCTL_LOGFILE	int
,	O
(	O
void	O
*	O
)	O
option_arg	pointer
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
use_mouse_p	enum
=	O
MOUSE_DISABLED	int
;	O
break	O
;	O
case	O
'u'	O
:	O
use_subshell	int
=	O
0	int
;	O
break	O
;	O
case	O
'H'	O
:	O
print_color_usage	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
print_mc_usage	function
(	O
ctx	pointer
,	O
stdout	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
static	O
const	O
struct	O
poptOption	struct
argument_table	array
[	O
]	O
=	O
{	O
{	O
"help"	pointer
,	O
'h'	O
,	O
POPT_ARG_NONE	int
,	O
NULL	O
,	O
'h'	O
,	O
N_	O
(	O
"Displays this help message"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"version"	pointer
,	O
'V'	O
,	O
POPT_ARG_NONE	int
,	O
NULL	O
,	O
'V'	O
,	O
N_	O
(	O
"Displays the current version"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"xterm"	pointer
,	O
'x'	O
,	O
POPT_ARG_NONE	int
,	O
&	O
force_xterm	int
,	O
0	int
,	O
N_	O
(	O
"Forces xterm features"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"nomouse"	pointer
,	O
'd'	O
,	O
POPT_ARG_NONE	int
,	O
NULL	O
,	O
'd'	O
,	O
N_	O
(	O
"Disable mouse support in text version"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"termcap"	pointer
,	O
't'	O
,	O
0	int
,	O
&	O
SLtt_Try_Termcap	int
,	O
0	int
,	O
N_	O
(	O
"Tries to use termcap instead of terminfo"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"resetsoft"	pointer
,	O
'k'	O
,	O
POPT_ARG_NONE	int
,	O
&	O
reset_hp_softkeys	int
,	O
0	int
,	O
N_	O
(	O
"Resets soft keys on HP terminals"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"slow"	pointer
,	O
's'	O
,	O
POPT_ARG_NONE	int
,	O
&	O
slow_terminal	int
,	O
0	int
,	O
N_	O
(	O
"To run on slow terminals"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"stickchars"	pointer
,	O
'a'	O
,	O
0	int
,	O
&	O
force_ugly_line_drawing	int
,	O
0	int
,	O
N_	O
(	O
"Use stickchars to draw"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"nocolor"	pointer
,	O
'b'	O
,	O
POPT_ARG_NONE	int
,	O
&	O
disable_colors	int
,	O
0	int
,	O
N_	O
(	O
"Requests to run in black and white"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"color"	pointer
,	O
'c'	O
,	O
POPT_ARG_NONE	int
,	O
NULL	O
,	O
'c'	O
,	O
N_	O
(	O
"Request to run in color mode"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"colors"	pointer
,	O
'C'	O
,	O
POPT_ARG_STRING	int
,	O
&	O
command_line_colors	pointer
,	O
0	int
,	O
N_	O
(	O
"Specifies a color configuration"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"help-colors"	pointer
,	O
'H'	O
,	O
POPT_ARG_NONE	int
,	O
NULL	O
,	O
'H'	O
,	O
N_	O
(	O
"Displays a help screen on how to change the color scheme"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"ftplog"	pointer
,	O
'l'	O
,	O
POPT_ARG_STRING	int
,	O
NULL	O
,	O
'l'	O
,	O
N_	O
(	O
"Log ftp dialog to specified file"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"datadir"	pointer
,	O
'f'	O
,	O
POPT_ARG_NONE	int
,	O
NULL	O
,	O
'f'	O
,	O
N_	O
(	O
"Print data directory"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"printwd"	pointer
,	O
'P'	O
,	O
POPT_ARG_STRING	int
,	O
&	O
last_wd_file	pointer
,	O
0	int
,	O
N_	O
(	O
"Print last working directory to specified file"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"subshell"	pointer
,	O
'U'	O
,	O
POPT_ARG_NONE	int
,	O
&	O
use_subshell	int
,	O
0	int
,	O
N_	O
(	O
"Enables subshell support (default)"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"nosubshell"	pointer
,	O
'u'	O
,	O
POPT_ARG_NONE	int
,	O
NULL	O
,	O
'u'	O
,	O
N_	O
(	O
"Disables subshell support"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"view"	pointer
,	O
'v'	O
,	O
POPT_ARG_STRING	int
,	O
&	O
view_one_file	pointer
,	O
0	int
,	O
N_	O
(	O
"Launches the file viewer on a file"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
"edit"	pointer
,	O
'e'	O
,	O
POPT_ARG_STRING	int
,	O
&	O
edit_one_file	pointer
,	O
0	int
,	O
N_	O
(	O
"Edits one file"	pointer
)	O
,	O
NULL	O
}	O
,	O
{	O
NULL	O
,	O
'\0'	O
,	O
0	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
static	O
void	O
handle_args	function
(	O
int	O
argc	pointer
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
char	O
*	O
tmp	pointer
;	O
poptContext	pointer
ctx	pointer
;	O
const	O
char	O
*	O
base	int
;	O
int	O
c	int
;	O
ctx	pointer
=	O
poptGetContext	function
(	O
"mc"	pointer
,	O
argc	pointer
,	O
argv	pointer
,	O
argument_table	array
,	O
POPT_CONTEXT_NO_EXEC	O
)	O
;	O
while	O
(	O
(	O
c	int
=	O
poptGetNextOpt	function
(	O
ctx	pointer
)	O
)	O
>	O
0	int
)	O
{	O
process_args	function
(	O
ctx	pointer
,	O
c	int
,	O
poptGetOptArg	function
(	O
ctx	pointer
)	O
)	O
;	O
}	O
if	O
(	O
c	int
<	O
-	O
1	int
)	O
{	O
print_mc_usage	function
(	O
ctx	pointer
,	O
stderr	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
poptBadOption	function
(	O
ctx	pointer
,	O
POPT_BADOPTION_NOALIAS	O
)	O
,	O
poptStrerror	function
(	O
c	int
)	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
tmp	pointer
=	O
poptGetArg	function
(	O
ctx	pointer
)	O
;	O
base	int
=	O
x_basename	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
!	O
STRNCOMP	O
(	O
base	int
,	O
"mce"	pointer
,	O
3	int
)	O
||	O
!	O
STRCOMP	O
(	O
base	int
,	O
"vi"	pointer
)	O
)	O
{	O
edit_one_file	pointer
=	O
""	pointer
;	O
if	O
(	O
tmp	pointer
)	O
{	O
if	O
(	O
*	O
tmp	pointer
==	O
'+'	O
&&	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
tmp	pointer
[	O
1	int
]	O
)	O
)	O
{	O
int	O
start_line	int
=	O
atoi	function
(	O
tmp	pointer
)	O
;	O
if	O
(	O
start_line	int
>	O
0	int
)	O
{	O
char	O
*	O
file	pointer
=	O
poptGetArg	function
(	O
ctx	pointer
)	O
;	O
if	O
(	O
file	pointer
)	O
{	O
tmp	pointer
=	O
file	pointer
;	O
edit_one_file_start_line	int
=	O
start_line	int
;	O
}	O
}	O
}	O
edit_one_file	pointer
=	O
g_strdup	function
(	O
tmp	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
STRNCOMP	O
(	O
base	int
,	O
"mcv"	pointer
,	O
3	int
)	O
||	O
!	O
STRCOMP	O
(	O
base	int
,	O
"view"	pointer
)	O
)	O
{	O
if	O
(	O
tmp	pointer
)	O
view_one_file	pointer
=	O
g_strdup	function
(	O
tmp	pointer
)	O
;	O
else	O
{	O
fputs	function
(	O
"No arguments given to the viewer\n"	pointer
,	O
stderr	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
tmp	pointer
)	O
{	O
this_dir	pointer
=	O
g_strdup	function
(	O
tmp	pointer
)	O
;	O
if	O
(	O
(	O
tmp	pointer
=	O
poptGetArg	function
(	O
ctx	pointer
)	O
)	O
)	O
other_dir	pointer
=	O
g_strdup	function
(	O
tmp	pointer
)	O
;	O
}	O
}	O
poptFreeContext	function
(	O
ctx	pointer
)	O
;	O
}	O
static	O
int	O
do_mc_filename_rename	function
(	O
const	O
char	O
*	O
o_name	pointer
,	O
const	O
char	O
*	O
n_name	pointer
)	O
{	O
char	O
*	O
full_o_name	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
o_name	pointer
)	O
;	O
char	O
*	O
full_n_name	pointer
=	O
g_strconcat	function
(	O
home_dir	pointer
,	O
MC_BASE	pointer
,	O
n_name	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
int	O
move	int
;	O
move	int
=	O
0	int
==	O
rename	function
(	O
full_o_name	pointer
,	O
full_n_name	pointer
)	O
;	O
g_free	function
(	O
full_o_name	pointer
)	O
;	O
g_free	function
(	O
full_n_name	pointer
)	O
;	O
return	O
move	int
;	O
}	O
static	O
int	O
compatibility_move_mc_files	function
(	O
void	O
)	O
{	O
struct	O
stat	struct
s	pointer
;	O
int	O
move	int
=	O
0	int
;	O
char	O
*	O
mc_dir	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
".mc"	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
mc_dir	pointer
,	O
&	O
s	pointer
)	O
&&	O
(	O
errno	O
==	O
ENOENT	int
)	O
&&	O
(	O
mkdir	function
(	O
mc_dir	pointer
,	O
0777	int
)	O
!=	O
-	O
1	int
)	O
)	O
{	O
move	int
=	O
do_mc_filename_rename	function
(	O
".mc.ini"	pointer
,	O
"ini"	pointer
)	O
;	O
move	int
+=	O
do_mc_filename_rename	function
(	O
".mc.hot"	pointer
,	O
"hotlist"	pointer
)	O
;	O
move	int
+=	O
do_mc_filename_rename	function
(	O
".mc.ext"	pointer
,	O
"bindings"	pointer
)	O
;	O
move	int
+=	O
do_mc_filename_rename	function
(	O
".mc.menu"	pointer
,	O
"menu"	pointer
)	O
;	O
move	int
+=	O
do_mc_filename_rename	function
(	O
".mc.bashrc"	pointer
,	O
"bashrc"	pointer
)	O
;	O
move	int
+=	O
do_mc_filename_rename	function
(	O
".mc.inputrc"	pointer
,	O
"inputrc"	pointer
)	O
;	O
move	int
+=	O
do_mc_filename_rename	function
(	O
".mc.tcshrc"	pointer
,	O
"tcshrc"	pointer
)	O
;	O
move	int
+=	O
do_mc_filename_rename	function
(	O
".mc.tree"	pointer
,	O
"Tree"	pointer
)	O
;	O
}	O
g_free	function
(	O
mc_dir	pointer
)	O
;	O
return	O
move	int
;	O
}	O
int	O
main	function
(	O
int	O
argc	pointer
,	O
char	O
*	O
argv	pointer
[	O
]	O
)	O
{	O
int	O
show_change_notice	int
=	O
0	int
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
"mc"	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
"mc"	pointer
)	O
;	O
mc_tmpdir	function
(	O
)	O
;	O
OS_Setup	function
(	O
)	O
;	O
home_dir	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
!	O
home_dir	pointer
)	O
{	O
home_dir	pointer
=	O
mc_home	pointer
;	O
}	O
vfs_init	function
(	O
)	O
;	O
SLtt_Ignore_Beep	int
=	O
1	int
;	O
handle_args	function
(	O
argc	pointer
,	O
argv	pointer
)	O
;	O
init_key	function
(	O
)	O
;	O
handle_console	function
(	O
CONSOLE_INIT	int
)	O
;	O
if	O
(	O
edit_one_file	pointer
||	O
view_one_file	pointer
)	O
use_subshell	int
=	O
0	int
;	O
if	O
(	O
use_subshell	int
)	O
subshell_get_console_attributes	function
(	O
)	O
;	O
init_sigchld	function
(	O
)	O
;	O
show_change_notice	int
=	O
compatibility_move_mc_files	function
(	O
)	O
;	O
save_stop_handler	function
(	O
)	O
;	O
slang_init	function
(	O
)	O
;	O
init_key_input_fd	function
(	O
)	O
;	O
load_setup	function
(	O
)	O
;	O
init_curses	function
(	O
)	O
;	O
init_xterm_support	function
(	O
)	O
;	O
if	O
(	O
use_subshell	int
)	O
init_subshell	function
(	O
)	O
;	O
load_key_defs	function
(	O
)	O
;	O
if	O
(	O
console_flag	char
)	O
handle_console	function
(	O
CONSOLE_SAVE	int
)	O
;	O
if	O
(	O
alternate_plus_minus	int
)	O
application_keypad_mode	function
(	O
)	O
;	O
if	O
(	O
show_change_notice	int
)	O
{	O
message	pointer
(	O
1	int
,	O
_	O
(	O
" Notice "	pointer
)	O
,	O
_	O
(	O
" The Midnight Commander configuration files \n"	pointer
" are now stored in the ~/.mc directory, the \n"	pointer
" files have been moved now\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
use_subshell	int
)	O
{	O
prompt	pointer
=	O
strip_ctrl_codes	function
(	O
subshell_prompt	pointer
)	O
;	O
if	O
(	O
!	O
prompt	pointer
)	O
prompt	pointer
=	O
""	pointer
;	O
}	O
else	O
prompt	pointer
=	O
(	O
geteuid	function
(	O
)	O
==	O
0	int
)	O
?	O
"# "	pointer
:	O
"$ "	pointer
;	O
if	O
(	O
!	O
midnight_shutdown	int
)	O
do_nc	function
(	O
)	O
;	O
tree_store_save	function
(	O
)	O
;	O
vfs_shut	function
(	O
)	O
;	O
flush_extension_file	function
(	O
)	O
;	O
endwin	O
(	O
)	O
;	O
slang_shutdown	function
(	O
)	O
;	O
if	O
(	O
console_flag	char
&&	O
!	O
(	O
quit	int
&	O
SUBSHELL_EXIT	int
)	O
)	O
handle_console	function
(	O
CONSOLE_RESTORE	int
)	O
;	O
if	O
(	O
alternate_plus_minus	int
)	O
numeric_keypad_mode	function
(	O
)	O
;	O
signal	function
(	O
SIGCHLD	int
,	O
SIG_DFL	O
)	O
;	O
if	O
(	O
console_flag	char
)	O
handle_console	function
(	O
CONSOLE_DONE	int
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
if	O
(	O
last_wd_file	pointer
&&	O
last_wd_string	pointer
&&	O
!	O
print_last_revert	int
&&	O
!	O
edit_one_file	pointer
&&	O
!	O
view_one_file	pointer
)	O
{	O
int	O
last_wd_fd	int
=	O
open	function
(	O
last_wd_file	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_TRUNC	int
|	O
O_EXCL	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
)	O
;	O
if	O
(	O
last_wd_fd	int
!=	O
-	O
1	int
)	O
{	O
write	pointer
(	O
last_wd_fd	int
,	O
last_wd_string	pointer
,	O
strlen	function
(	O
last_wd_string	pointer
)	O
)	O
;	O
close	pointer
(	O
last_wd_fd	int
)	O
;	O
}	O
}	O
g_free	function
(	O
last_wd_string	pointer
)	O
;	O
g_free	function
(	O
mc_home	pointer
)	O
;	O
done_key	function
(	O
)	O
;	O
g_free	function
(	O
this_dir	pointer
)	O
;	O
g_free	function
(	O
other_dir	pointer
)	O
;	O
return	O
0	int
;	O
}	O
