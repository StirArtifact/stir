const	O
char	O
inflate_copyright	array
[	O
]	O
=	O
" inflate 1.2.11 Copyright 1995-2017 Mark Adler "	pointer
;	O
int	O
ZLIB_INTERNAL	O
inflate_table	function
(	O
type	enum
,	O
lens	pointer
,	O
codes	int
,	O
table	pointer
,	O
bits	pointer
,	O
work	pointer
)	O
codetype	enum
type	enum
;	O
unsigned	O
short	O
FAR	O
*	O
lens	pointer
;	O
unsigned	O
codes	int
;	O
code	struct
FAR	O
*	O
FAR	O
*	O
table	pointer
;	O
unsigned	O
FAR	O
*	O
bits	pointer
;	O
unsigned	O
short	O
FAR	O
*	O
work	pointer
;	O
{	O
unsigned	O
len	int
;	O
unsigned	O
sym	int
;	O
unsigned	O
min	int
,	O
max	int
;	O
unsigned	O
root	int
;	O
unsigned	O
curr	int
;	O
unsigned	O
drop	int
;	O
int	O
left	int
;	O
unsigned	O
used	int
;	O
unsigned	O
huff	int
;	O
unsigned	O
incr	int
;	O
unsigned	O
fill	int
;	O
unsigned	O
low	int
;	O
unsigned	O
mask	int
;	O
code	struct
here	struct
;	O
code	struct
FAR	O
*	O
next	pointer
;	O
const	O
unsigned	O
short	O
FAR	O
*	O
base	pointer
;	O
const	O
unsigned	O
short	O
FAR	O
*	O
extra	pointer
;	O
unsigned	O
match	int
;	O
unsigned	O
short	O
count	array
[	O
MAXBITS	int
+	O
1	int
]	O
;	O
unsigned	O
short	O
offs	array
[	O
MAXBITS	int
+	O
1	int
]	O
;	O
static	O
const	O
unsigned	O
short	O
lbase	array
[	O
31	int
]	O
=	O
{	O
3	int
,	O
4	int
,	O
5	int
,	O
6	int
,	O
7	int
,	O
8	int
,	O
9	int
,	O
10	int
,	O
11	int
,	O
13	int
,	O
15	int
,	O
17	int
,	O
19	int
,	O
23	int
,	O
27	int
,	O
31	int
,	O
35	int
,	O
43	int
,	O
51	int
,	O
59	int
,	O
67	int
,	O
83	int
,	O
99	int
,	O
115	int
,	O
131	int
,	O
163	int
,	O
195	int
,	O
227	int
,	O
258	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
const	O
unsigned	O
short	O
lext	array
[	O
31	int
]	O
=	O
{	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
17	int
,	O
17	int
,	O
17	int
,	O
17	int
,	O
18	int
,	O
18	int
,	O
18	int
,	O
18	int
,	O
19	int
,	O
19	int
,	O
19	int
,	O
19	int
,	O
20	int
,	O
20	int
,	O
20	int
,	O
20	int
,	O
21	int
,	O
21	int
,	O
21	int
,	O
21	int
,	O
16	int
,	O
77	int
,	O
202	int
}	O
;	O
static	O
const	O
unsigned	O
short	O
dbase	array
[	O
32	int
]	O
=	O
{	O
1	int
,	O
2	int
,	O
3	int
,	O
4	int
,	O
5	int
,	O
7	int
,	O
9	int
,	O
13	int
,	O
17	int
,	O
25	int
,	O
33	int
,	O
49	int
,	O
65	int
,	O
97	int
,	O
129	int
,	O
193	int
,	O
257	int
,	O
385	int
,	O
513	int
,	O
769	int
,	O
1025	int
,	O
1537	int
,	O
2049	int
,	O
3073	int
,	O
4097	int
,	O
6145	int
,	O
8193	int
,	O
12289	int
,	O
16385	int
,	O
24577	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
const	O
unsigned	O
short	O
dext	array
[	O
32	int
]	O
=	O
{	O
16	int
,	O
16	int
,	O
16	int
,	O
16	int
,	O
17	int
,	O
17	int
,	O
18	int
,	O
18	int
,	O
19	int
,	O
19	int
,	O
20	int
,	O
20	int
,	O
21	int
,	O
21	int
,	O
22	int
,	O
22	int
,	O
23	int
,	O
23	int
,	O
24	int
,	O
24	int
,	O
25	int
,	O
25	int
,	O
26	int
,	O
26	int
,	O
27	int
,	O
27	int
,	O
28	int
,	O
28	int
,	O
29	int
,	O
29	int
,	O
64	int
,	O
64	int
}	O
;	O
for	O
(	O
len	int
=	O
0	int
;	O
len	int
<=	O
MAXBITS	int
;	O
len	int
++	O
)	O
count	array
[	O
len	int
]	O
=	O
0	int
;	O
for	O
(	O
sym	int
=	O
0	int
;	O
sym	int
<	O
codes	int
;	O
sym	int
++	O
)	O
count	array
[	O
lens	pointer
[	O
sym	int
]	O
]	O
++	O
;	O
root	int
=	O
*	O
bits	pointer
;	O
for	O
(	O
max	int
=	O
MAXBITS	int
;	O
max	int
>=	O
1	int
;	O
max	int
--	O
)	O
if	O
(	O
count	array
[	O
max	int
]	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
root	int
>	O
max	int
)	O
root	int
=	O
max	int
;	O
if	O
(	O
max	int
==	O
0	int
)	O
{	O
here	struct
.	O
op	char
=	O
(	O
unsigned	O
char	O
)	O
64	int
;	O
here	struct
.	O
bits	pointer
=	O
(	O
unsigned	O
char	O
)	O
1	int
;	O
here	struct
.	O
val	short
=	O
(	O
unsigned	O
short	O
)	O
0	int
;	O
*	O
(	O
*	O
table	pointer
)	O
++	O
=	O
here	struct
;	O
*	O
(	O
*	O
table	pointer
)	O
++	O
=	O
here	struct
;	O
*	O
bits	pointer
=	O
1	int
;	O
return	O
0	int
;	O
}	O
for	O
(	O
min	int
=	O
1	int
;	O
min	int
<	O
max	int
;	O
min	int
++	O
)	O
if	O
(	O
count	array
[	O
min	int
]	O
!=	O
0	int
)	O
break	O
;	O
if	O
(	O
root	int
<	O
min	int
)	O
root	int
=	O
min	int
;	O
left	int
=	O
1	int
;	O
for	O
(	O
len	int
=	O
1	int
;	O
len	int
<=	O
MAXBITS	int
;	O
len	int
++	O
)	O
{	O
left	int
<<=	O
1	int
;	O
left	int
-=	O
count	array
[	O
len	int
]	O
;	O
if	O
(	O
left	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
left	int
>	O
0	int
&&	O
(	O
type	enum
==	O
CODES	int
||	O
max	int
!=	O
1	int
)	O
)	O
return	O
-	O
1	int
;	O
offs	array
[	O
1	int
]	O
=	O
0	int
;	O
for	O
(	O
len	int
=	O
1	int
;	O
len	int
<	O
MAXBITS	int
;	O
len	int
++	O
)	O
offs	array
[	O
len	int
+	O
1	int
]	O
=	O
offs	array
[	O
len	int
]	O
+	O
count	array
[	O
len	int
]	O
;	O
for	O
(	O
sym	int
=	O
0	int
;	O
sym	int
<	O
codes	int
;	O
sym	int
++	O
)	O
if	O
(	O
lens	pointer
[	O
sym	int
]	O
!=	O
0	int
)	O
work	pointer
[	O
offs	array
[	O
lens	pointer
[	O
sym	int
]	O
]	O
++	O
]	O
=	O
(	O
unsigned	O
short	O
)	O
sym	int
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
CODES	int
:	O
base	pointer
=	O
extra	pointer
=	O
work	pointer
;	O
match	int
=	O
20	int
;	O
break	O
;	O
case	O
LENS	int
:	O
base	pointer
=	O
lbase	array
;	O
extra	pointer
=	O
lext	array
;	O
match	int
=	O
257	int
;	O
break	O
;	O
default	O
:	O
base	pointer
=	O
dbase	array
;	O
extra	pointer
=	O
dext	array
;	O
match	int
=	O
0	int
;	O
}	O
huff	int
=	O
0	int
;	O
sym	int
=	O
0	int
;	O
len	int
=	O
min	int
;	O
next	pointer
=	O
*	O
table	pointer
;	O
curr	int
=	O
root	int
;	O
drop	int
=	O
0	int
;	O
low	int
=	O
(	O
unsigned	O
)	O
(	O
-	O
1	int
)	O
;	O
used	int
=	O
1U	int
<<	O
root	int
;	O
mask	int
=	O
used	int
-	O
1	int
;	O
if	O
(	O
(	O
type	enum
==	O
LENS	int
&&	O
used	int
>	O
ENOUGH_LENS	int
)	O
||	O
(	O
type	enum
==	O
DISTS	int
&&	O
used	int
>	O
ENOUGH_DISTS	int
)	O
)	O
return	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
here	struct
.	O
bits	pointer
=	O
(	O
unsigned	O
char	O
)	O
(	O
len	int
-	O
drop	int
)	O
;	O
if	O
(	O
work	pointer
[	O
sym	int
]	O
+	O
1U	int
<	O
match	int
)	O
{	O
here	struct
.	O
op	char
=	O
(	O
unsigned	O
char	O
)	O
0	int
;	O
here	struct
.	O
val	short
=	O
work	pointer
[	O
sym	int
]	O
;	O
}	O
else	O
if	O
(	O
work	pointer
[	O
sym	int
]	O
>=	O
match	int
)	O
{	O
here	struct
.	O
op	char
=	O
(	O
unsigned	O
char	O
)	O
(	O
extra	pointer
[	O
work	pointer
[	O
sym	int
]	O
-	O
match	int
]	O
)	O
;	O
here	struct
.	O
val	short
=	O
base	pointer
[	O
work	pointer
[	O
sym	int
]	O
-	O
match	int
]	O
;	O
}	O
else	O
{	O
here	struct
.	O
op	char
=	O
(	O
unsigned	O
char	O
)	O
(	O
32	int
+	O
64	int
)	O
;	O
here	struct
.	O
val	short
=	O
0	int
;	O
}	O
incr	int
=	O
1U	int
<<	O
(	O
len	int
-	O
drop	int
)	O
;	O
fill	int
=	O
1U	int
<<	O
curr	int
;	O
min	int
=	O
fill	int
;	O
do	O
{	O
fill	int
-=	O
incr	int
;	O
next	pointer
[	O
(	O
huff	int
>>	O
drop	int
)	O
+	O
fill	int
]	O
=	O
here	struct
;	O
}	O
while	O
(	O
fill	int
!=	O
0	int
)	O
;	O
incr	int
=	O
1U	int
<<	O
(	O
len	int
-	O
1	int
)	O
;	O
while	O
(	O
huff	int
&	O
incr	int
)	O
incr	int
>>=	O
1	int
;	O
if	O
(	O
incr	int
!=	O
0	int
)	O
{	O
huff	int
&=	O
incr	int
-	O
1	int
;	O
huff	int
+=	O
incr	int
;	O
}	O
else	O
huff	int
=	O
0	int
;	O
sym	int
++	O
;	O
if	O
(	O
--	O
(	O
count	array
[	O
len	int
]	O
)	O
==	O
0	int
)	O
{	O
if	O
(	O
len	int
==	O
max	int
)	O
break	O
;	O
len	int
=	O
lens	pointer
[	O
work	pointer
[	O
sym	int
]	O
]	O
;	O
}	O
if	O
(	O
len	int
>	O
root	int
&&	O
(	O
huff	int
&	O
mask	int
)	O
!=	O
low	int
)	O
{	O
if	O
(	O
drop	int
==	O
0	int
)	O
drop	int
=	O
root	int
;	O
next	pointer
+=	O
min	int
;	O
curr	int
=	O
len	int
-	O
drop	int
;	O
left	int
=	O
(	O
int	O
)	O
(	O
1	int
<<	O
curr	int
)	O
;	O
while	O
(	O
curr	int
+	O
drop	int
<	O
max	int
)	O
{	O
left	int
-=	O
count	array
[	O
curr	int
+	O
drop	int
]	O
;	O
if	O
(	O
left	int
<=	O
0	int
)	O
break	O
;	O
curr	int
++	O
;	O
left	int
<<=	O
1	int
;	O
}	O
used	int
+=	O
1U	int
<<	O
curr	int
;	O
if	O
(	O
(	O
type	enum
==	O
LENS	int
&&	O
used	int
>	O
ENOUGH_LENS	int
)	O
||	O
(	O
type	enum
==	O
DISTS	int
&&	O
used	int
>	O
ENOUGH_DISTS	int
)	O
)	O
return	O
1	int
;	O
low	int
=	O
huff	int
&	O
mask	int
;	O
(	O
*	O
table	pointer
)	O
[	O
low	int
]	O
.	O
op	char
=	O
(	O
unsigned	O
char	O
)	O
curr	int
;	O
(	O
*	O
table	pointer
)	O
[	O
low	int
]	O
.	O
bits	pointer
=	O
(	O
unsigned	O
char	O
)	O
root	int
;	O
(	O
*	O
table	pointer
)	O
[	O
low	int
]	O
.	O
val	short
=	O
(	O
unsigned	O
short	O
)	O
(	O
next	pointer
-	O
*	O
table	pointer
)	O
;	O
}	O
}	O
if	O
(	O
huff	int
!=	O
0	int
)	O
{	O
here	struct
.	O
op	char
=	O
(	O
unsigned	O
char	O
)	O
64	int
;	O
here	struct
.	O
bits	pointer
=	O
(	O
unsigned	O
char	O
)	O
(	O
len	int
-	O
drop	int
)	O
;	O
here	struct
.	O
val	short
=	O
(	O
unsigned	O
short	O
)	O
0	int
;	O
next	pointer
[	O
huff	int
]	O
=	O
here	struct
;	O
}	O
*	O
table	pointer
+=	O
used	int
;	O
*	O
bits	pointer
=	O
root	int
;	O
return	O
0	int
;	O
}	O
