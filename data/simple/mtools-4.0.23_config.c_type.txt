static	O
char	O
buffer	array
[	O
MAX_LINE_LEN	int
+	O
1	int
]	O
;	O
static	O
char	O
*	O
pos	array
;	O
static	O
char	O
*	O
token	pointer
;	O
static	O
size_t	long
token_length	long
;	O
static	O
FILE	struct
*	O
fp	pointer
;	O
static	O
int	O
linenumber	int
;	O
static	O
int	O
lastTokenLinenumber	int
;	O
static	O
const	O
char	O
*	O
filename	pointer
=	O
NULL	O
;	O
static	O
int	O
file_nr	int
=	O
0	int
;	O
static	O
unsigned	O
int	O
flag_mask	int
;	O
static	O
unsigned	O
int	O
cur_devs	int
;	O
static	O
int	O
cur_dev	int
;	O
static	O
int	O
trusted	int
=	O
0	int
;	O
static	O
unsigned	O
int	O
nr_dev	int
;	O
struct	O
device	struct
*	O
devices	pointer
;	O
static	O
int	O
token_nr	int
;	O
static	O
char	O
default_drive	char
=	O
'\0'	O
;	O
unsigned	O
int	O
mtools_skip_check	int
=	O
0	int
;	O
unsigned	O
int	O
mtools_fat_compatibility	int
=	O
0	int
;	O
unsigned	O
int	O
mtools_ignore_short_case	int
=	O
0	int
;	O
uint8_t	char
mtools_rate_0	char
=	O
0	int
;	O
uint8_t	char
mtools_rate_any	char
=	O
0	int
;	O
unsigned	O
int	O
mtools_no_vfat	int
=	O
0	int
;	O
unsigned	O
int	O
mtools_numeric_tail	int
=	O
1	int
;	O
unsigned	O
int	O
mtools_dotted_dir	int
=	O
0	int
;	O
unsigned	O
int	O
mtools_twenty_four_hour_clock	int
=	O
1	int
;	O
unsigned	O
int	O
mtools_lock_timeout	int
=	O
30	int
;	O
unsigned	O
int	O
mtools_default_codepage	int
=	O
850	int
;	O
const	O
char	O
*	O
mtools_date_string	pointer
=	O
"yyyy-mm-dd"	pointer
;	O
char	O
*	O
country_string	pointer
=	O
0	int
;	O
typedef	O
struct	O
switches_l	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
caddr_t	pointer
address	long
;	O
enum	O
{	O
T_INT	int
,	O
T_STRING	int
,	O
T_UINT	int
,	O
T_UINT8	int
,	O
T_UINT16	int
}	O
type	enum
;	O
}	O
switches_t	struct
;	O
static	O
switches_t	struct
global_switches	array
[	O
]	O
=	O
{	O
{	O
"MTOOLS_LOWER_CASE"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_ignore_short_case	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_FAT_COMPATIBILITY"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_fat_compatibility	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_SKIP_CHECK"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_skip_check	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_NO_VFAT"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_no_vfat	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_RATE_0"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_rate_0	char
,	O
T_UINT8	int
}	O
,	O
{	O
"MTOOLS_RATE_ANY"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_rate_any	char
,	O
T_UINT8	int
}	O
,	O
{	O
"MTOOLS_NAME_NUMERIC_TAIL"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_numeric_tail	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_DOTTED_DIR"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_dotted_dir	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_TWENTY_FOUR_HOUR_CLOCK"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_twenty_four_hour_clock	int
,	O
T_UINT	int
}	O
,	O
{	O
"MTOOLS_DATE_STRING"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_date_string	pointer
,	O
T_STRING	int
}	O
,	O
{	O
"MTOOLS_LOCK_TIMEOUT"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_lock_timeout	int
,	O
T_UINT	int
}	O
,	O
{	O
"DEFAULT_CODEPAGE"	pointer
,	O
(	O
caddr_t	pointer
)	O
&	O
mtools_default_codepage	int
,	O
T_UINT	int
}	O
}	O
;	O
typedef	O
struct	O
{	O
const	O
char	O
*	O
name	pointer
;	O
unsigned	O
int	O
flag	pointer
;	O
}	O
flags_t	struct
;	O
static	O
flags_t	struct
openflags	array
[	O
]	O
=	O
{	O
{	O
"sync"	pointer
,	O
O_SYNC	int
}	O
,	O
{	O
"nodelay"	pointer
,	O
O_NDELAY	O
}	O
,	O
{	O
"exclusive"	pointer
,	O
O_EXCL	int
}	O
,	O
{	O
"none"	pointer
,	O
0	int
}	O
}	O
;	O
static	O
flags_t	struct
misc_flags	int
[	O
]	O
=	O
{	O
{	O
"use_xdf"	pointer
,	O
USE_XDF_FLAG	int
}	O
,	O
{	O
"scsi"	pointer
,	O
SCSI_FLAG	int
}	O
,	O
{	O
"nolock"	pointer
,	O
NOLOCK_FLAG	int
}	O
,	O
{	O
"mformat_only"	pointer
,	O
MFORMAT_ONLY_FLAG	int
}	O
,	O
{	O
"filter"	pointer
,	O
FILTER_FLAG	int
}	O
,	O
{	O
"privileged"	pointer
,	O
PRIV_FLAG	int
}	O
,	O
{	O
"vold"	pointer
,	O
VOLD_FLAG	int
}	O
,	O
{	O
"remote"	pointer
,	O
FLOPPYD_FLAG	int
}	O
,	O
{	O
"swap"	pointer
,	O
SWAP_FLAG	int
}	O
,	O
}	O
;	O
static	O
struct	O
{	O
const	O
char	O
*	O
name	pointer
;	O
signed	O
char	O
fat_bits	int
;	O
unsigned	O
int	O
tracks	int
;	O
unsigned	O
short	O
heads	short
;	O
unsigned	O
short	O
sectors	short
;	O
}	O
default_formats	array
[	O
]	O
=	O
{	O
{	O
"hd514"	pointer
,	O
12	int
,	O
80	int
,	O
2	int
,	O
15	int
}	O
,	O
{	O
"high-density-5-1/4"	pointer
,	O
12	int
,	O
80	int
,	O
2	int
,	O
15	int
}	O
,	O
{	O
"1.2m"	pointer
,	O
12	int
,	O
80	int
,	O
2	int
,	O
15	int
}	O
,	O
{	O
"hd312"	pointer
,	O
12	int
,	O
80	int
,	O
2	int
,	O
18	int
}	O
,	O
{	O
"high-density-3-1/2"	pointer
,	O
12	int
,	O
80	int
,	O
2	int
,	O
18	int
}	O
,	O
{	O
"1.44m"	pointer
,	O
12	int
,	O
80	int
,	O
2	int
,	O
18	int
}	O
,	O
{	O
"dd312"	pointer
,	O
12	int
,	O
80	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"double-density-3-1/2"	pointer
,	O
12	int
,	O
80	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"720k"	pointer
,	O
12	int
,	O
80	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"dd514"	pointer
,	O
12	int
,	O
40	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"double-density-5-1/4"	pointer
,	O
12	int
,	O
40	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"360k"	pointer
,	O
12	int
,	O
40	int
,	O
2	int
,	O
9	int
}	O
,	O
{	O
"320k"	pointer
,	O
12	int
,	O
40	int
,	O
2	int
,	O
8	int
}	O
,	O
{	O
"180k"	pointer
,	O
12	int
,	O
40	int
,	O
1	int
,	O
9	int
}	O
,	O
{	O
"160k"	pointer
,	O
12	int
,	O
40	int
,	O
1	int
,	O
8	int
}	O
}	O
;	O
static	O
switches_t	struct
dswitches	array
[	O
]	O
=	O
{	O
{	O
"FILE"	pointer
,	O
OFFS	O
(	O
name	pointer
)	O
,	O
T_STRING	int
}	O
,	O
{	O
"OFFSET"	pointer
,	O
OFFS	O
(	O
offset	long
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"PARTITION"	pointer
,	O
OFFS	O
(	O
partition	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"FAT"	pointer
,	O
OFFS	O
(	O
fat_bits	int
)	O
,	O
T_INT	int
}	O
,	O
{	O
"FAT_BITS"	pointer
,	O
OFFS	O
(	O
fat_bits	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"MODE"	pointer
,	O
OFFS	O
(	O
mode	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"TRACKS"	pointer
,	O
OFFS	O
(	O
tracks	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"CYLINDERS"	pointer
,	O
OFFS	O
(	O
tracks	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"HEADS"	pointer
,	O
OFFS	O
(	O
heads	short
)	O
,	O
T_UINT16	int
}	O
,	O
{	O
"SECTORS"	pointer
,	O
OFFS	O
(	O
sectors	short
)	O
,	O
T_UINT16	int
}	O
,	O
{	O
"HIDDEN"	pointer
,	O
OFFS	O
(	O
hidden	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"PRECMD"	pointer
,	O
OFFS	O
(	O
precmd	pointer
)	O
,	O
T_STRING	int
}	O
,	O
{	O
"BLOCKSIZE"	pointer
,	O
OFFS	O
(	O
blocksize	int
)	O
,	O
T_UINT	int
}	O
,	O
{	O
"CODEPAGE"	pointer
,	O
OFFS	O
(	O
codepage	int
)	O
,	O
T_UINT	int
}	O
}	O
;	O
static	O
void	O
maintain_default_drive	function
(	O
char	O
drive	char
)	O
{	O
if	O
(	O
default_drive	char
==	O
':'	O
)	O
return	O
;	O
if	O
(	O
default_drive	char
==	O
'\0'	O
||	O
default_drive	char
>	O
drive	char
)	O
default_drive	char
=	O
drive	char
;	O
}	O
char	O
get_default_drive	function
(	O
void	O
)	O
{	O
if	O
(	O
default_drive	char
!=	O
'\0'	O
)	O
return	O
default_drive	char
;	O
else	O
return	O
'A'	O
;	O
}	O
static	O
void	O
syntax	function
(	O
const	O
char	O
*	O
msg	pointer
,	O
int	O
thisLine	int
)	O
NORETURN	O
;	O
static	O
void	O
syntax	function
(	O
const	O
char	O
*	O
msg	pointer
,	O
int	O
thisLine	int
)	O
{	O
char	O
drive	char
=	O
'\0'	O
;	O
if	O
(	O
thisLine	int
)	O
lastTokenLinenumber	int
=	O
linenumber	int
;	O
if	O
(	O
cur_dev	int
>=	O
0	int
)	O
drive	char
=	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
drive	char
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Syntax error at line %d "	pointer
,	O
lastTokenLinenumber	int
)	O
;	O
if	O
(	O
drive	char
)	O
fprintf	function
(	O
stderr	pointer
,	O
"for drive %c: "	pointer
,	O
drive	char
)	O
;	O
if	O
(	O
token	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
"column %ld "	pointer
,	O
(	O
long	O
)	O
(	O
token	pointer
-	O
buffer	array
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"in file %s: %s\n"	pointer
,	O
filename	pointer
,	O
msg	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
static	O
void	O
get_env_conf	function
(	O
void	O
)	O
{	O
char	O
*	O
s	pointer
;	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
global_switches	array
)	O
/	O
sizeof	O
(	O
*	O
global_switches	array
)	O
;	O
i	int
++	O
)	O
{	O
s	pointer
=	O
getenv	function
(	O
global_switches	array
[	O
i	int
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
s	pointer
)	O
{	O
if	O
(	O
global_switches	array
[	O
i	int
]	O
.	O
type	enum
==	O
T_INT	int
)	O
*	O
(	O
(	O
int	O
*	O
)	O
global_switches	array
[	O
i	int
]	O
.	O
address	long
)	O
=	O
(	O
int	O
)	O
strtol	function
(	O
s	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
global_switches	array
[	O
i	int
]	O
.	O
type	enum
==	O
T_UINT	int
)	O
*	O
(	O
(	O
unsigned	O
int	O
*	O
)	O
global_switches	array
[	O
i	int
]	O
.	O
address	long
)	O
=	O
(	O
unsigned	O
int	O
)	O
strtoul	function
(	O
s	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
global_switches	array
[	O
i	int
]	O
.	O
type	enum
==	O
T_UINT8	int
)	O
*	O
(	O
(	O
uint8_t	char
*	O
)	O
global_switches	array
[	O
i	int
]	O
.	O
address	long
)	O
=	O
(	O
uint8_t	char
)	O
strtou8	function
(	O
s	pointer
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
global_switches	array
[	O
i	int
]	O
.	O
type	enum
==	O
T_UINT16	int
)	O
*	O
(	O
(	O
uint16_t	short
*	O
)	O
global_switches	array
[	O
i	int
]	O
.	O
address	long
)	O
=	O
(	O
uint16_t	short
)	O
strtou8	function
(	O
s	pointer
,	O
0	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
global_switches	array
[	O
i	int
]	O
.	O
type	enum
==	O
T_STRING	int
)	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
global_switches	array
[	O
i	int
]	O
.	O
address	long
)	O
=	O
s	pointer
;	O
}	O
}	O
}	O
static	O
int	O
mtools_getline	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
fp	pointer
||	O
!	O
fgets	function
(	O
buffer	array
,	O
MAX_LINE_LEN	int
,	O
fp	pointer
)	O
)	O
return	O
-	O
1	int
;	O
linenumber	int
++	O
;	O
pos	array
=	O
buffer	array
;	O
token_nr	int
=	O
0	int
;	O
buffer	array
[	O
MAX_LINE_LEN	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strlen	function
(	O
buffer	array
)	O
==	O
MAX_LINE_LEN	int
)	O
syntax	function
(	O
"line too long"	pointer
,	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
skip_junk	function
(	O
int	O
expect	int
)	O
{	O
lastTokenLinenumber	int
=	O
linenumber	int
;	O
while	O
(	O
!	O
pos	array
||	O
!	O
*	O
pos	array
||	O
strchr	function
(	O
" #\n\t"	pointer
,	O
*	O
pos	array
)	O
)	O
{	O
if	O
(	O
!	O
pos	array
||	O
!	O
*	O
pos	array
||	O
*	O
pos	array
==	O
'#'	O
)	O
{	O
if	O
(	O
mtools_getline	function
(	O
)	O
)	O
{	O
pos	array
=	O
0	int
;	O
if	O
(	O
expect	int
)	O
syntax	function
(	O
"end of file unexpected"	pointer
,	O
1	int
)	O
;	O
return	O
;	O
}	O
}	O
else	O
pos	array
++	O
;	O
}	O
token_nr	int
++	O
;	O
}	O
static	O
char	O
*	O
get_next_token	function
(	O
void	O
)	O
{	O
skip_junk	function
(	O
0	int
)	O
;	O
if	O
(	O
!	O
pos	array
)	O
{	O
token_length	long
=	O
0	int
;	O
token	pointer
=	O
0	int
;	O
return	O
0	int
;	O
}	O
token	pointer
=	O
pos	array
;	O
token_length	long
=	O
strcspn	function
(	O
token	pointer
,	O
" \t\n#:="	pointer
)	O
;	O
pos	array
+=	O
token_length	long
;	O
return	O
token	pointer
;	O
}	O
static	O
int	O
match_token	function
(	O
const	O
char	O
*	O
template	pointer
)	O
{	O
return	O
(	O
strlen	function
(	O
template	pointer
)	O
==	O
token_length	long
&&	O
!	O
strncasecmp	function
(	O
template	pointer
,	O
token	pointer
,	O
token_length	long
)	O
)	O
;	O
}	O
static	O
void	O
expect_char	function
(	O
char	O
c	char
)	O
{	O
char	O
buf	pointer
[	O
11	int
]	O
;	O
skip_junk	function
(	O
1	int
)	O
;	O
if	O
(	O
*	O
pos	array
!=	O
c	char
)	O
{	O
sprintf	function
(	O
buf	pointer
,	O
"expected %c"	pointer
,	O
c	char
)	O
;	O
syntax	function
(	O
buf	pointer
,	O
1	int
)	O
;	O
}	O
pos	array
++	O
;	O
}	O
static	O
char	O
*	O
get_string	function
(	O
void	O
)	O
{	O
char	O
*	O
end	pointer
,	O
*	O
str	pointer
;	O
skip_junk	function
(	O
1	int
)	O
;	O
if	O
(	O
*	O
pos	array
!=	O
'"'	O
)	O
syntax	function
(	O
" \" expected"	pointer
,	O
0	int
)	O
;	O
str	pointer
=	O
pos	array
+	O
1	int
;	O
end	pointer
=	O
strchr	function
(	O
str	pointer
,	O
'\"'	O
)	O
;	O
if	O
(	O
!	O
end	pointer
)	O
syntax	function
(	O
"unterminated string constant"	pointer
,	O
1	int
)	O
;	O
*	O
end	pointer
=	O
'\0'	O
;	O
pos	array
=	O
end	pointer
+	O
1	int
;	O
return	O
str	pointer
;	O
}	O
static	O
unsigned	O
long	O
get_unumber	function
(	O
unsigned	O
long	O
max	long
)	O
{	O
char	O
*	O
last	pointer
;	O
unsigned	O
long	O
n	int
;	O
skip_junk	function
(	O
1	int
)	O
;	O
last	pointer
=	O
pos	array
;	O
n	int
=	O
strtoul	function
(	O
pos	array
,	O
&	O
pos	array
,	O
0	int
)	O
;	O
if	O
(	O
last	pointer
==	O
pos	array
)	O
syntax	function
(	O
"numeral expected"	pointer
,	O
0	int
)	O
;	O
if	O
(	O
n	int
>	O
max	long
)	O
syntax	function
(	O
"number too big"	pointer
,	O
0	int
)	O
;	O
pos	array
++	O
;	O
token_nr	int
++	O
;	O
return	O
n	int
;	O
}	O
static	O
int	O
get_number	function
(	O
void	O
)	O
{	O
char	O
*	O
last	pointer
;	O
int	O
n	int
;	O
skip_junk	function
(	O
1	int
)	O
;	O
last	pointer
=	O
pos	array
;	O
n	int
=	O
(	O
int	O
)	O
strtol	function
(	O
pos	array
,	O
&	O
pos	array
,	O
0	int
)	O
;	O
if	O
(	O
last	pointer
==	O
pos	array
)	O
syntax	function
(	O
"numeral expected"	pointer
,	O
0	int
)	O
;	O
pos	array
++	O
;	O
token_nr	int
++	O
;	O
return	O
n	int
;	O
}	O
static	O
void	O
purge	function
(	O
char	O
drive	char
,	O
int	O
fn	int
)	O
{	O
unsigned	O
int	O
i	int
,	O
j	int
;	O
drive	char
=	O
ch_toupper	function
(	O
drive	char
)	O
;	O
for	O
(	O
j	int
=	O
0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
cur_devs	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
devices	pointer
[	O
i	int
]	O
.	O
drive	char
!=	O
drive	char
||	O
devices	pointer
[	O
i	int
]	O
.	O
file_nr	int
==	O
fn	int
)	O
devices	pointer
[	O
j	int
++	O
]	O
=	O
devices	pointer
[	O
i	int
]	O
;	O
}	O
cur_devs	int
=	O
j	int
;	O
}	O
static	O
void	O
grow	function
(	O
void	O
)	O
{	O
if	O
(	O
cur_devs	int
>=	O
nr_dev	int
-	O
2	int
)	O
{	O
nr_dev	int
=	O
(	O
cur_devs	int
+	O
2	int
)	O
<<	O
1	int
;	O
if	O
(	O
!	O
(	O
devices	pointer
=	O
Grow	O
(	O
devices	pointer
,	O
nr_dev	int
,	O
struct	O
device	struct
)	O
)	O
)	O
{	O
printOom	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
init_drive	function
(	O
void	O
)	O
{	O
memset	function
(	O
(	O
char	O
*	O
)	O
&	O
devices	pointer
[	O
cur_dev	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
struct	O
device	struct
)	O
)	O
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
ssize	char
=	O
2	int
;	O
}	O
static	O
void	O
prepend	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
i	int
;	O
grow	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
cur_devs	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
devices	pointer
[	O
i	int
]	O
=	O
devices	pointer
[	O
i	int
-	O
1	int
]	O
;	O
cur_dev	int
=	O
0	int
;	O
cur_devs	int
++	O
;	O
init_drive	function
(	O
)	O
;	O
}	O
static	O
void	O
append	function
(	O
void	O
)	O
{	O
grow	function
(	O
)	O
;	O
cur_dev	int
=	O
cur_devs	int
;	O
cur_devs	int
++	O
;	O
init_drive	function
(	O
)	O
;	O
}	O
static	O
void	O
finish_drive_clause	function
(	O
void	O
)	O
{	O
if	O
(	O
cur_dev	int
==	O
-	O
1	int
)	O
{	O
trusted	int
=	O
0	int
;	O
return	O
;	O
}	O
if	O
(	O
!	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
name	pointer
)	O
syntax	function
(	O
"missing filename"	pointer
,	O
0	int
)	O
;	O
if	O
(	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
tracks	int
||	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
heads	short
||	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
sectors	short
)	O
{	O
if	O
(	O
!	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
tracks	int
||	O
!	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
heads	short
||	O
!	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
sectors	short
)	O
syntax	function
(	O
"incomplete geometry: either indicate all of track/heads/sectors or none of them"	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
misc_flags	int
&	O
(	O
MFORMAT_ONLY_FLAG	int
|	O
FILTER_FLAG	int
)	O
)	O
)	O
syntax	function
(	O
"if you supply a geometry, you also must supply one of the `mformat_only' or `filter' flags"	pointer
,	O
0	int
)	O
;	O
}	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
file_nr	int
=	O
file_nr	int
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
cfg_filename	pointer
=	O
filename	pointer
;	O
if	O
(	O
!	O
(	O
flag_mask	int
&	O
PRIV_FLAG	int
)	O
&&	O
IS_SCSI	O
(	O
&	O
devices	pointer
[	O
cur_dev	int
]	O
)	O
)	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
misc_flags	int
|=	O
PRIV_FLAG	int
;	O
if	O
(	O
!	O
trusted	int
&&	O
(	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
misc_flags	int
&	O
PRIV_FLAG	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: privileged flag ignored for drive %c: defined in file %s\n"	pointer
,	O
toupper	function
(	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
drive	char
)	O
,	O
filename	pointer
)	O
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
misc_flags	int
&=	O
~	O
PRIV_FLAG	int
;	O
}	O
trusted	int
=	O
0	int
;	O
cur_dev	int
=	O
-	O
1	int
;	O
}	O
static	O
int	O
set_var	function
(	O
struct	O
switches_l	struct
*	O
switches	pointer
,	O
int	O
nr	int
,	O
caddr_t	pointer
base_address	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nr	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_token	function
(	O
switches	pointer
[	O
i	int
]	O
.	O
name	pointer
)	O
)	O
{	O
expect_char	function
(	O
'='	O
)	O
;	O
if	O
(	O
switches	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
T_UINT	int
)	O
*	O
(	O
(	O
unsigned	O
int	O
*	O
)	O
(	O
(	O
long	O
)	O
switches	pointer
[	O
i	int
]	O
.	O
address	long
+	O
base_address	pointer
)	O
)	O
=	O
(	O
unsigned	O
int	O
)	O
get_unumber	function
(	O
UINT_MAX	O
)	O
;	O
else	O
if	O
(	O
switches	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
T_UINT8	int
)	O
*	O
(	O
(	O
uint8_t	char
*	O
)	O
(	O
(	O
long	O
)	O
switches	pointer
[	O
i	int
]	O
.	O
address	long
+	O
base_address	pointer
)	O
)	O
=	O
(	O
uint8_t	char
)	O
get_unumber	function
(	O
UINT8_MAX	O
)	O
;	O
else	O
if	O
(	O
switches	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
T_UINT16	int
)	O
*	O
(	O
(	O
uint16_t	short
*	O
)	O
(	O
(	O
long	O
)	O
switches	pointer
[	O
i	int
]	O
.	O
address	long
+	O
base_address	pointer
)	O
)	O
=	O
(	O
uint16_t	short
)	O
get_unumber	function
(	O
UINT16_MAX	O
)	O
;	O
else	O
if	O
(	O
switches	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
T_INT	int
)	O
*	O
(	O
(	O
int	O
*	O
)	O
(	O
(	O
long	O
)	O
switches	pointer
[	O
i	int
]	O
.	O
address	long
+	O
base_address	pointer
)	O
)	O
=	O
get_number	function
(	O
)	O
;	O
else	O
if	O
(	O
switches	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
T_STRING	int
)	O
*	O
(	O
(	O
char	O
*	O
*	O
)	O
(	O
(	O
long	O
)	O
switches	pointer
[	O
i	int
]	O
.	O
address	long
+	O
base_address	pointer
)	O
)	O
=	O
strdup	function
(	O
get_string	function
(	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
set_openflags	function
(	O
struct	O
device	struct
*	O
dev	pointer
)	O
{	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
openflags	array
)	O
/	O
sizeof	O
(	O
*	O
openflags	array
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_token	function
(	O
openflags	array
[	O
i	int
]	O
.	O
name	pointer
)	O
)	O
{	O
dev	pointer
->	O
mode	int
|=	O
openflags	array
[	O
i	int
]	O
.	O
flag	pointer
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
set_misc_flags	function
(	O
struct	O
device	struct
*	O
dev	pointer
)	O
{	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
misc_flags	int
)	O
/	O
sizeof	O
(	O
*	O
misc_flags	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_token	function
(	O
misc_flags	int
[	O
i	int
]	O
.	O
name	pointer
)	O
)	O
{	O
flag_mask	int
|=	O
misc_flags	int
[	O
i	int
]	O
.	O
flag	pointer
;	O
skip_junk	function
(	O
0	int
)	O
;	O
if	O
(	O
pos	array
&&	O
*	O
pos	array
==	O
'='	O
)	O
{	O
pos	array
++	O
;	O
switch	O
(	O
get_number	function
(	O
)	O
)	O
{	O
case	O
0	int
:	O
return	O
0	int
;	O
case	O
1	int
:	O
break	O
;	O
default	O
:	O
syntax	function
(	O
"expected 0 or 1"	pointer
,	O
0	int
)	O
;	O
}	O
}	O
dev	pointer
->	O
misc_flags	int
|=	O
misc_flags	int
[	O
i	int
]	O
.	O
flag	pointer
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
set_def_format	function
(	O
struct	O
device	struct
*	O
dev	pointer
)	O
{	O
unsigned	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
default_formats	array
)	O
/	O
sizeof	O
(	O
*	O
default_formats	array
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
match_token	function
(	O
default_formats	array
[	O
i	int
]	O
.	O
name	pointer
)	O
)	O
{	O
if	O
(	O
!	O
dev	pointer
->	O
ssize	char
)	O
dev	pointer
->	O
ssize	char
=	O
2	int
;	O
if	O
(	O
!	O
dev	pointer
->	O
tracks	int
)	O
dev	pointer
->	O
tracks	int
=	O
default_formats	array
[	O
i	int
]	O
.	O
tracks	int
;	O
if	O
(	O
!	O
dev	pointer
->	O
heads	short
)	O
dev	pointer
->	O
heads	short
=	O
default_formats	array
[	O
i	int
]	O
.	O
heads	short
;	O
if	O
(	O
!	O
dev	pointer
->	O
sectors	short
)	O
dev	pointer
->	O
sectors	short
=	O
default_formats	array
[	O
i	int
]	O
.	O
sectors	short
;	O
if	O
(	O
!	O
dev	pointer
->	O
fat_bits	int
)	O
dev	pointer
->	O
fat_bits	int
=	O
default_formats	array
[	O
i	int
]	O
.	O
fat_bits	int
;	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
parse_one	function
(	O
int	O
privilege	int
)	O
;	O
void	O
set_cmd_line_image	function
(	O
char	O
*	O
img	pointer
)	O
{	O
char	O
*	O
ofsp	pointer
;	O
prepend	function
(	O
)	O
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
drive	char
=	O
':'	O
;	O
default_drive	char
=	O
':'	O
;	O
ofsp	pointer
=	O
strstr	function
(	O
img	pointer
,	O
"@@"	pointer
)	O
;	O
if	O
(	O
ofsp	pointer
==	O
NULL	O
)	O
{	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
name	pointer
=	O
strdup	function
(	O
img	pointer
)	O
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
offset	long
=	O
0	int
;	O
}	O
else	O
{	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
name	pointer
=	O
strndup	function
(	O
img	pointer
,	O
ofsp	pointer
-	O
img	pointer
)	O
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
offset	long
=	O
str_to_offset	function
(	O
ofsp	pointer
+	O
2	int
)	O
;	O
}	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
fat_bits	int
=	O
0	int
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
tracks	int
=	O
0	int
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
heads	short
=	O
0	int
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
sectors	short
=	O
0	int
;	O
if	O
(	O
strchr	function
(	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
name	pointer
,	O
'|'	O
)	O
)	O
{	O
char	O
*	O
pipechar	pointer
=	O
strchr	function
(	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
name	pointer
,	O
'|'	O
)	O
;	O
*	O
pipechar	pointer
=	O
0	int
;	O
strncpy	function
(	O
buffer	array
,	O
pipechar	pointer
+	O
1	int
,	O
MAX_LINE_LEN	int
)	O
;	O
buffer	array
[	O
MAX_LINE_LEN	int
]	O
=	O
'\0'	O
;	O
fp	pointer
=	O
NULL	O
;	O
filename	pointer
=	O
"{command line}"	pointer
;	O
linenumber	int
=	O
0	int
;	O
lastTokenLinenumber	int
=	O
0	int
;	O
pos	array
=	O
buffer	array
;	O
token	pointer
=	O
0	int
;	O
while	O
(	O
parse_one	function
(	O
0	int
)	O
)	O
;	O
}	O
}	O
static	O
uint16_t	short
tou16	function
(	O
int	O
in	int
,	O
const	O
char	O
*	O
comment	pointer
)	O
{	O
if	O
(	O
in	int
>	O
UINT16_MAX	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Number of %s %d too big\n"	pointer
,	O
comment	pointer
,	O
in	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
in	int
<	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Number of %s %d negative\n"	pointer
,	O
comment	pointer
,	O
in	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
(	O
uint16_t	short
)	O
in	int
;	O
}	O
static	O
void	O
parse_old_device_line	function
(	O
char	O
drive	char
)	O
{	O
char	O
name	pointer
[	O
MAXPATHLEN	O
]	O
;	O
int	O
items	int
;	O
long	O
offset	long
;	O
int	O
heads	short
,	O
sectors	short
;	O
finish_drive_clause	function
(	O
)	O
;	O
purge	function
(	O
drive	char
,	O
file_nr	int
)	O
;	O
append	function
(	O
)	O
;	O
items	int
=	O
sscanf	function
(	O
token	pointer
,	O
"%c %s %i %i %i %i %li"	pointer
,	O
&	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
drive	char
,	O
name	pointer
,	O
&	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
fat_bits	int
,	O
&	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
tracks	int
,	O
&	O
heads	short
,	O
&	O
sectors	short
,	O
&	O
offset	long
)	O
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
heads	short
=	O
tou16	function
(	O
heads	short
,	O
"heads"	pointer
)	O
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
sectors	short
=	O
tou16	function
(	O
sectors	short
,	O
"sectors"	pointer
)	O
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
offset	long
=	O
(	O
off_t	long
)	O
offset	long
;	O
switch	O
(	O
items	int
)	O
{	O
case	O
2	int
:	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
fat_bits	int
=	O
0	int
;	O
case	O
3	int
:	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
sectors	short
=	O
0	int
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
heads	short
=	O
0	int
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
tracks	int
=	O
0	int
;	O
case	O
6	int
:	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
offset	long
=	O
0	int
;	O
default	O
:	O
break	O
;	O
case	O
0	int
:	O
case	O
1	int
:	O
case	O
4	int
:	O
case	O
5	int
:	O
syntax	function
(	O
"bad number of parameters"	pointer
,	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
tracks	int
)	O
{	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
sectors	short
=	O
0	int
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
heads	short
=	O
0	int
;	O
}	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
drive	char
=	O
ch_toupper	function
(	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
drive	char
)	O
;	O
maintain_default_drive	function
(	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
drive	char
)	O
;	O
if	O
(	O
!	O
(	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
name	pointer
=	O
strdup	function
(	O
name	pointer
)	O
)	O
)	O
{	O
printOom	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
misc_flags	int
|=	O
MFORMAT_ONLY_FLAG	int
;	O
finish_drive_clause	function
(	O
)	O
;	O
pos	array
=	O
0	int
;	O
}	O
static	O
int	O
parse_one	function
(	O
int	O
privilege	int
)	O
{	O
int	O
action	int
=	O
0	int
;	O
get_next_token	function
(	O
)	O
;	O
if	O
(	O
!	O
token	pointer
)	O
return	O
0	int
;	O
if	O
(	O
(	O
match_token	function
(	O
"drive"	pointer
)	O
&&	O
(	O
(	O
action	int
=	O
1	int
)	O
)	O
)	O
||	O
(	O
match_token	function
(	O
"drive+"	pointer
)	O
&&	O
(	O
(	O
action	int
=	O
2	int
)	O
)	O
)	O
||	O
(	O
match_token	function
(	O
"+drive"	pointer
)	O
&&	O
(	O
(	O
action	int
=	O
3	int
)	O
)	O
)	O
||	O
(	O
match_token	function
(	O
"clear_drive"	pointer
)	O
&&	O
(	O
(	O
action	int
=	O
4	int
)	O
)	O
)	O
)	O
{	O
finish_drive_clause	function
(	O
)	O
;	O
get_next_token	function
(	O
)	O
;	O
if	O
(	O
token_length	long
!=	O
1	int
)	O
syntax	function
(	O
"drive letter expected"	pointer
,	O
0	int
)	O
;	O
if	O
(	O
action	int
==	O
1	int
||	O
action	int
==	O
4	int
)	O
purge	function
(	O
token	pointer
[	O
0	int
]	O
,	O
file_nr	int
)	O
;	O
if	O
(	O
action	int
==	O
4	int
)	O
return	O
1	int
;	O
if	O
(	O
action	int
==	O
3	int
)	O
prepend	function
(	O
)	O
;	O
else	O
append	function
(	O
)	O
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
(	O
devices	pointer
+	O
cur_dev	int
)	O
,	O
0	int
,	O
sizeof	O
(	O
*	O
devices	pointer
)	O
)	O
;	O
trusted	int
=	O
privilege	int
;	O
flag_mask	int
=	O
0	int
;	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
drive	char
=	O
ch_toupper	function
(	O
token	pointer
[	O
0	int
]	O
)	O
;	O
maintain_default_drive	function
(	O
devices	pointer
[	O
cur_dev	int
]	O
.	O
drive	char
)	O
;	O
expect_char	function
(	O
':'	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
token_nr	int
==	O
1	int
&&	O
token_length	long
==	O
1	int
)	O
{	O
parse_old_device_line	function
(	O
token	pointer
[	O
0	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
(	O
cur_dev	int
<	O
0	int
||	O
(	O
set_var	function
(	O
dswitches	array
,	O
sizeof	O
(	O
dswitches	array
)	O
/	O
sizeof	O
(	O
*	O
dswitches	array
)	O
,	O
(	O
caddr_t	pointer
)	O
&	O
devices	pointer
[	O
cur_dev	int
]	O
)	O
&&	O
set_openflags	function
(	O
&	O
devices	pointer
[	O
cur_dev	int
]	O
)	O
&&	O
set_misc_flags	function
(	O
&	O
devices	pointer
[	O
cur_dev	int
]	O
)	O
&&	O
set_def_format	function
(	O
&	O
devices	pointer
[	O
cur_dev	int
]	O
)	O
)	O
)	O
&&	O
set_var	function
(	O
global_switches	array
,	O
sizeof	O
(	O
global_switches	array
)	O
/	O
sizeof	O
(	O
*	O
global_switches	array
)	O
,	O
0	int
)	O
)	O
syntax	function
(	O
"unrecognized keyword"	pointer
,	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
parse	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
privilege	int
)	O
{	O
if	O
(	O
fp	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"File descriptor already set!\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
fp	pointer
=	O
fopen	function
(	O
name	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
return	O
0	int
;	O
file_nr	int
++	O
;	O
filename	pointer
=	O
name	pointer
;	O
linenumber	int
=	O
0	int
;	O
lastTokenLinenumber	int
=	O
0	int
;	O
pos	array
=	O
0	int
;	O
token	pointer
=	O
0	int
;	O
cur_dev	int
=	O
-	O
1	int
;	O
while	O
(	O
parse_one	function
(	O
privilege	int
)	O
)	O
;	O
finish_drive_clause	function
(	O
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
filename	pointer
=	O
NULL	O
;	O
fp	pointer
=	O
NULL	O
;	O
return	O
1	int
;	O
}	O
void	O
read_config	function
(	O
void	O
)	O
{	O
char	O
*	O
homedir	pointer
;	O
char	O
*	O
envConfFile	pointer
;	O
static	O
char	O
conf_file	array
[	O
MAXPATHLEN	O
+	O
sizeof	O
(	O
CFG_FILE1	pointer
)	O
]	O
;	O
file_nr	int
=	O
0	int
;	O
cur_devs	int
=	O
nr_const_devices	int
;	O
nr_dev	int
=	O
nr_const_devices	int
+	O
2	int
;	O
devices	pointer
=	O
NewArray	O
(	O
nr_dev	int
,	O
struct	O
device	struct
)	O
;	O
if	O
(	O
!	O
devices	pointer
)	O
{	O
printOom	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
nr_const_devices	int
)	O
memcpy	function
(	O
devices	pointer
,	O
const_devices	array
,	O
nr_const_devices	int
*	O
sizeof	O
(	O
struct	O
device	struct
)	O
)	O
;	O
(	O
void	O
)	O
(	O
(	O
parse	function
(	O
CONF_FILE	pointer
,	O
1	int
)	O
|	O
parse	function
(	O
LOCAL_CONF_FILE	pointer
,	O
1	int
)	O
|	O
parse	function
(	O
SYS_CONF_FILE	O
,	O
1	int
)	O
)	O
||	O
(	O
parse	function
(	O
OLD_CONF_FILE	pointer
,	O
1	int
)	O
|	O
parse	function
(	O
OLD_LOCAL_CONF_FILE	pointer
,	O
1	int
)	O
)	O
)	O
;	O
homedir	pointer
=	O
get_homedir	function
(	O
)	O
;	O
if	O
(	O
homedir	pointer
)	O
{	O
strncpy	function
(	O
conf_file	array
,	O
homedir	pointer
,	O
MAXPATHLEN	O
)	O
;	O
conf_file	array
[	O
MAXPATHLEN	O
]	O
=	O
'\0'	O
;	O
strcat	function
(	O
conf_file	array
,	O
CFG_FILE1	pointer
)	O
;	O
parse	function
(	O
conf_file	array
,	O
0	int
)	O
;	O
}	O
memset	function
(	O
(	O
char	O
*	O
)	O
&	O
devices	pointer
[	O
cur_devs	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
struct	O
device	struct
)	O
)	O
;	O
envConfFile	pointer
=	O
getenv	function
(	O
"MTOOLSRC"	pointer
)	O
;	O
if	O
(	O
envConfFile	pointer
)	O
parse	function
(	O
envConfFile	pointer
,	O
0	int
)	O
;	O
get_env_conf	function
(	O
)	O
;	O
if	O
(	O
mtools_skip_check	int
)	O
mtools_fat_compatibility	int
=	O
1	int
;	O
}	O
void	O
mtoolstest	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
type	enum
UNUSEDP	O
)	O
NORETURN	O
;	O
void	O
mtoolstest	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
type	enum
UNUSEDP	O
)	O
{	O
struct	O
device	struct
*	O
dev	pointer
;	O
char	O
drive	char
=	O
'\0'	O
;	O
if	O
(	O
argc	int
>	O
1	int
&&	O
argv	pointer
[	O
1	int
]	O
[	O
0	int
]	O
&&	O
argv	pointer
[	O
1	int
]	O
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
drive	char
=	O
ch_toupper	function
(	O
argv	pointer
[	O
1	int
]	O
[	O
0	int
]	O
)	O
;	O
}	O
for	O
(	O
dev	pointer
=	O
devices	pointer
;	O
dev	pointer
->	O
name	pointer
;	O
dev	pointer
++	O
)	O
{	O
if	O
(	O
drive	char
&&	O
drive	char
!=	O
dev	pointer
->	O
drive	char
)	O
continue	O
;	O
printf	function
(	O
"drive %c:\n"	pointer
,	O
dev	pointer
->	O
drive	char
)	O
;	O
printf	function
(	O
"\t#fn=%d mode=%d "	pointer
,	O
dev	pointer
->	O
file_nr	int
,	O
dev	pointer
->	O
mode	int
)	O
;	O
if	O
(	O
dev	pointer
->	O
cfg_filename	pointer
)	O
printf	function
(	O
"defined in %s\n"	pointer
,	O
dev	pointer
->	O
cfg_filename	pointer
)	O
;	O
else	O
printf	function
(	O
"builtin\n"	pointer
)	O
;	O
printf	function
(	O
"\tfile=\"%s\" fat_bits=%d \n"	pointer
,	O
dev	pointer
->	O
name	pointer
,	O
dev	pointer
->	O
fat_bits	int
)	O
;	O
printf	function
(	O
"\ttracks=%d heads=%d sectors=%d hidden=%d\n"	pointer
,	O
dev	pointer
->	O
tracks	int
,	O
dev	pointer
->	O
heads	short
,	O
dev	pointer
->	O
sectors	short
,	O
dev	pointer
->	O
hidden	int
)	O
;	O
printf	function
(	O
"\toffset=0x%lx\n"	pointer
,	O
(	O
long	O
)	O
dev	pointer
->	O
offset	long
)	O
;	O
printf	function
(	O
"\tpartition=%d\n"	pointer
,	O
dev	pointer
->	O
partition	int
)	O
;	O
if	O
(	O
dev	pointer
->	O
misc_flags	int
)	O
printf	function
(	O
"\t"	pointer
)	O
;	O
if	O
(	O
DO_SWAP	O
(	O
dev	pointer
)	O
)	O
printf	function
(	O
"swap "	pointer
)	O
;	O
if	O
(	O
IS_SCSI	O
(	O
dev	pointer
)	O
)	O
printf	function
(	O
"scsi "	pointer
)	O
;	O
if	O
(	O
IS_PRIVILEGED	O
(	O
dev	pointer
)	O
)	O
printf	function
(	O
"privileged"	pointer
)	O
;	O
if	O
(	O
IS_MFORMAT_ONLY	O
(	O
dev	pointer
)	O
)	O
printf	function
(	O
"mformat_only "	pointer
)	O
;	O
if	O
(	O
SHOULD_USE_VOLD	O
(	O
dev	pointer
)	O
)	O
printf	function
(	O
"vold "	pointer
)	O
;	O
if	O
(	O
SHOULD_USE_XDF	O
(	O
dev	pointer
)	O
)	O
printf	function
(	O
"use_xdf "	pointer
)	O
;	O
if	O
(	O
dev	pointer
->	O
misc_flags	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
dev	pointer
->	O
mode	int
)	O
printf	function
(	O
"\t"	pointer
)	O
;	O
if	O
(	O
dev	pointer
->	O
mode	int
&	O
O_SYNC	int
)	O
printf	function
(	O
"sync "	pointer
)	O
;	O
if	O
(	O
(	O
dev	pointer
->	O
mode	int
&	O
O_NDELAY	O
)	O
)	O
printf	function
(	O
"nodelay "	pointer
)	O
;	O
if	O
(	O
(	O
dev	pointer
->	O
mode	int
&	O
O_EXCL	int
)	O
)	O
printf	function
(	O
"exclusive "	pointer
)	O
;	O
if	O
(	O
dev	pointer
->	O
mode	int
)	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
dev	pointer
->	O
precmd	pointer
)	O
printf	function
(	O
"\tprecmd=%s\n"	pointer
,	O
dev	pointer
->	O
precmd	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
printf	function
(	O
"mtools_fat_compatibility=%d\n"	pointer
,	O
mtools_fat_compatibility	int
)	O
;	O
printf	function
(	O
"mtools_skip_check=%d\n"	pointer
,	O
mtools_skip_check	int
)	O
;	O
printf	function
(	O
"mtools_lower_case=%d\n"	pointer
,	O
mtools_ignore_short_case	int
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
