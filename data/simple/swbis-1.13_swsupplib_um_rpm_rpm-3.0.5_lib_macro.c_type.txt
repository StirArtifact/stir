static	O
int	O
_debug	int
=	O
0	int
;	O
struct	O
MacroContext	struct
rpmGlobalMacroContext	struct
;	O
struct	O
MacroContext	struct
rpmCLIMacroContext	struct
;	O
typedef	O
struct	O
MacroBuf	struct
{	O
const	O
char	O
*	O
s	pointer
;	O
char	O
*	O
t	pointer
;	O
size_t	long
nb	long
;	O
int	O
depth	int
;	O
int	O
macro_trace	int
;	O
int	O
expand_trace	int
;	O
void	O
*	O
spec	pointer
;	O
MacroContext	struct
*	O
mc	pointer
;	O
}	O
MacroBuf	struct
;	O
static	O
int	O
expandMacro	function
(	O
MacroBuf	struct
*	O
mb	pointer
)	O
;	O
int	O
max_macro_depth	int
=	O
MAX_MACRO_DEPTH	int
;	O
int	O
print_macro_trace	int
=	O
0	int
;	O
int	O
print_expand_trace	int
=	O
0	int
;	O
static	O
int	O
compareMacroName	function
(	O
const	O
void	O
*	O
ap	pointer
,	O
const	O
void	O
*	O
bp	pointer
)	O
{	O
MacroEntry	struct
*	O
ame	pointer
=	O
*	O
(	O
(	O
MacroEntry	struct
*	O
*	O
)	O
ap	pointer
)	O
;	O
MacroEntry	struct
*	O
bme	pointer
=	O
*	O
(	O
(	O
MacroEntry	struct
*	O
*	O
)	O
bp	pointer
)	O
;	O
if	O
(	O
ame	pointer
==	O
NULL	O
&&	O
bme	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
if	O
(	O
ame	pointer
==	O
NULL	O
)	O
return	O
1	int
;	O
if	O
(	O
bme	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
return	O
strcmp	function
(	O
ame	pointer
->	O
name	pointer
,	O
bme	pointer
->	O
name	pointer
)	O
;	O
}	O
static	O
void	O
expandMacroTable	function
(	O
MacroContext	struct
*	O
mc	pointer
)	O
{	O
if	O
(	O
mc	pointer
->	O
macroTable	pointer
==	O
NULL	O
)	O
{	O
mc	pointer
->	O
macrosAllocated	int
=	O
MACRO_CHUNK_SIZE	int
;	O
mc	pointer
->	O
macroTable	pointer
=	O
(	O
MacroEntry	struct
*	O
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
(	O
mc	pointer
->	O
macroTable	pointer
)	O
)	O
*	O
mc	pointer
->	O
macrosAllocated	int
)	O
;	O
mc	pointer
->	O
firstFree	int
=	O
0	int
;	O
}	O
else	O
{	O
mc	pointer
->	O
macrosAllocated	int
+=	O
MACRO_CHUNK_SIZE	int
;	O
mc	pointer
->	O
macroTable	pointer
=	O
(	O
MacroEntry	struct
*	O
*	O
)	O
xrealloc	function
(	O
mc	pointer
->	O
macroTable	pointer
,	O
sizeof	O
(	O
*	O
(	O
mc	pointer
->	O
macroTable	pointer
)	O
)	O
*	O
mc	pointer
->	O
macrosAllocated	int
)	O
;	O
}	O
memset	function
(	O
&	O
mc	pointer
->	O
macroTable	pointer
[	O
mc	pointer
->	O
firstFree	int
]	O
,	O
0	int
,	O
MACRO_CHUNK_SIZE	int
*	O
sizeof	O
(	O
*	O
(	O
mc	pointer
->	O
macroTable	pointer
)	O
)	O
)	O
;	O
}	O
static	O
void	O
sortMacroTable	function
(	O
MacroContext	struct
*	O
mc	pointer
)	O
{	O
int	O
i	int
;	O
qsort	function
(	O
mc	pointer
->	O
macroTable	pointer
,	O
mc	pointer
->	O
firstFree	int
,	O
sizeof	O
(	O
*	O
(	O
mc	pointer
->	O
macroTable	pointer
)	O
)	O
,	O
compareMacroName	function
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mc	pointer
->	O
firstFree	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
mc	pointer
->	O
macroTable	pointer
[	O
i	int
]	O
!=	O
NULL	O
)	O
continue	O
;	O
mc	pointer
->	O
firstFree	int
=	O
i	int
;	O
break	O
;	O
}	O
}	O
void	O
rpmDumpMacroTable	function
(	O
MacroContext	struct
*	O
mc	pointer
,	O
FILE	struct
*	O
fp	pointer
)	O
{	O
int	O
i	int
;	O
int	O
nempty	int
=	O
0	int
;	O
int	O
nactive	int
=	O
0	int
;	O
if	O
(	O
mc	pointer
==	O
NULL	O
)	O
mc	pointer
=	O
&	O
rpmGlobalMacroContext	struct
;	O
if	O
(	O
fp	pointer
==	O
NULL	O
)	O
fp	pointer
=	O
stderr	pointer
;	O
fprintf	function
(	O
fp	pointer
,	O
"========================\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mc	pointer
->	O
firstFree	int
;	O
i	int
++	O
)	O
{	O
MacroEntry	struct
*	O
me	pointer
;	O
if	O
(	O
(	O
me	pointer
=	O
mc	pointer
->	O
macroTable	pointer
[	O
i	int
]	O
)	O
==	O
NULL	O
)	O
{	O
nempty	int
++	O
;	O
continue	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"%3d%c %s"	pointer
,	O
me	pointer
->	O
level	int
,	O
(	O
me	pointer
->	O
used	int
>	O
0	int
?	O
'='	O
:	O
':'	O
)	O
,	O
me	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
me	pointer
->	O
opts	pointer
&&	O
*	O
me	pointer
->	O
opts	pointer
)	O
fprintf	function
(	O
fp	pointer
,	O
"(%s)"	pointer
,	O
me	pointer
->	O
opts	pointer
)	O
;	O
if	O
(	O
me	pointer
->	O
body	pointer
&&	O
*	O
me	pointer
->	O
body	pointer
)	O
fprintf	function
(	O
fp	pointer
,	O
"\t%s"	pointer
,	O
me	pointer
->	O
body	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
nactive	int
++	O
;	O
}	O
fprintf	function
(	O
fp	pointer
,	O
_	O
(	O
"======================== active %d empty %d\n"	pointer
)	O
,	O
nactive	int
,	O
nempty	int
)	O
;	O
}	O
static	O
MacroEntry	struct
*	O
*	O
findEntry	function
(	O
MacroContext	struct
*	O
mc	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
namelen	long
)	O
{	O
MacroEntry	struct
keybuf	struct
,	O
*	O
key	pointer
,	O
*	O
*	O
ret	pointer
;	O
char	O
namebuf	array
[	O
1024	int
]	O
;	O
if	O
(	O
mc	pointer
==	O
NULL	O
)	O
mc	pointer
=	O
&	O
rpmGlobalMacroContext	struct
;	O
if	O
(	O
!	O
mc	pointer
->	O
firstFree	int
)	O
return	O
NULL	O
;	O
if	O
(	O
namelen	long
>	O
0	int
)	O
{	O
strncpy	function
(	O
namebuf	array
,	O
name	pointer
,	O
namelen	long
)	O
;	O
namebuf	array
[	O
namelen	long
]	O
=	O
'\0'	O
;	O
name	pointer
=	O
namebuf	array
;	O
}	O
key	pointer
=	O
&	O
keybuf	struct
;	O
memset	function
(	O
key	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
key	pointer
)	O
)	O
;	O
key	pointer
->	O
name	pointer
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
ret	pointer
=	O
(	O
MacroEntry	struct
*	O
*	O
)	O
bsearch	function
(	O
&	O
key	pointer
,	O
mc	pointer
->	O
macroTable	pointer
,	O
mc	pointer
->	O
firstFree	int
,	O
sizeof	O
(	O
*	O
(	O
mc	pointer
->	O
macroTable	pointer
)	O
)	O
,	O
compareMacroName	function
)	O
;	O
return	O
ret	pointer
;	O
}	O
static	O
char	O
*	O
rdcl	function
(	O
char	O
*	O
buf	pointer
,	O
size_t	long
size	long
,	O
FD_t	pointer
fd	pointer
,	O
int	O
escapes	int
)	O
{	O
char	O
*	O
q	pointer
=	O
buf	pointer
;	O
size_t	long
nb	long
=	O
0	int
;	O
size_t	long
nread	long
=	O
0	int
;	O
*	O
q	pointer
=	O
'\0'	O
;	O
do	O
{	O
if	O
(	O
fgets	function
(	O
q	pointer
,	O
size	long
,	O
(	O
FILE	struct
*	O
)	O
fdGetFp	function
(	O
fd	pointer
)	O
)	O
==	O
NULL	O
)	O
break	O
;	O
nb	long
=	O
strlen	function
(	O
q	pointer
)	O
;	O
nread	long
+=	O
nb	long
;	O
for	O
(	O
q	pointer
+=	O
nb	long
-	O
1	int
;	O
nb	long
>	O
0	int
&&	O
iseol	O
(	O
*	O
q	pointer
)	O
;	O
q	pointer
--	O
)	O
nb	long
--	O
;	O
if	O
(	O
!	O
(	O
nb	long
>	O
0	int
&&	O
*	O
q	pointer
==	O
'\\'	O
)	O
)	O
{	O
*	O
(	O
++	O
q	pointer
)	O
=	O
'\0'	O
;	O
break	O
;	O
}	O
if	O
(	O
escapes	int
)	O
{	O
q	pointer
++	O
;	O
nb	long
++	O
;	O
}	O
size	long
-=	O
nb	long
;	O
if	O
(	O
*	O
q	pointer
==	O
'\r'	O
)	O
*	O
q	pointer
=	O
'\n'	O
;	O
*	O
(	O
++	O
q	pointer
)	O
=	O
'\0'	O
;	O
}	O
while	O
(	O
size	long
>	O
0	int
)	O
;	O
return	O
(	O
nread	long
>	O
0	int
?	O
buf	pointer
:	O
NULL	O
)	O
;	O
}	O
static	O
const	O
char	O
*	O
matchchar	function
(	O
const	O
char	O
*	O
p	pointer
,	O
char	O
pl	char
,	O
char	O
pr	char
)	O
{	O
int	O
lvl	int
=	O
0	int
;	O
char	O
c	int
;	O
while	O
(	O
(	O
c	int
=	O
*	O
p	pointer
++	O
)	O
!=	O
'\0'	O
)	O
{	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
{	O
p	pointer
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
c	int
==	O
pr	char
)	O
{	O
if	O
(	O
--	O
lvl	int
<=	O
0	int
)	O
return	O
--	O
p	pointer
;	O
}	O
else	O
if	O
(	O
c	int
==	O
pl	char
)	O
lvl	int
++	O
;	O
}	O
return	O
(	O
const	O
char	O
*	O
)	O
NULL	O
;	O
}	O
static	O
void	O
printMacro	function
(	O
MacroBuf	struct
*	O
mb	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
const	O
char	O
*	O
se	pointer
)	O
{	O
const	O
char	O
*	O
senl	pointer
;	O
const	O
char	O
*	O
ellipsis	pointer
;	O
int	O
choplen	int
;	O
if	O
(	O
s	pointer
>=	O
se	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%3d>%*s(empty)"	pointer
)	O
,	O
mb	pointer
->	O
depth	int
,	O
(	O
2	int
*	O
mb	pointer
->	O
depth	int
+	O
1	int
)	O
,	O
""	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
s	pointer
[	O
-	O
1	int
]	O
==	O
'{'	O
)	O
s	pointer
--	O
;	O
for	O
(	O
senl	pointer
=	O
se	pointer
;	O
*	O
senl	pointer
&&	O
!	O
iseol	O
(	O
*	O
senl	pointer
)	O
;	O
senl	pointer
++	O
)	O
;	O
choplen	int
=	O
61	int
-	O
(	O
2	int
*	O
mb	pointer
->	O
depth	int
)	O
;	O
if	O
(	O
(	O
senl	pointer
-	O
s	pointer
)	O
>	O
choplen	int
)	O
{	O
senl	pointer
=	O
s	pointer
+	O
choplen	int
;	O
ellipsis	pointer
=	O
"..."	pointer
;	O
}	O
else	O
ellipsis	pointer
=	O
""	pointer
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%3d>%*s%%%.*s^"	pointer
,	O
mb	pointer
->	O
depth	int
,	O
(	O
2	int
*	O
mb	pointer
->	O
depth	int
+	O
1	int
)	O
,	O
""	pointer
,	O
(	O
int	O
)	O
(	O
se	pointer
-	O
s	pointer
)	O
,	O
s	pointer
)	O
;	O
if	O
(	O
se	pointer
[	O
1	int
]	O
!=	O
'\0'	O
&&	O
(	O
senl	pointer
-	O
(	O
se	pointer
+	O
1	int
)	O
)	O
>	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%-.*s%s"	pointer
,	O
(	O
int	O
)	O
(	O
senl	pointer
-	O
(	O
se	pointer
+	O
1	int
)	O
)	O
,	O
se	pointer
+	O
1	int
,	O
ellipsis	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
static	O
void	O
printExpansion	function
(	O
MacroBuf	struct
*	O
mb	pointer
,	O
const	O
char	O
*	O
t	pointer
,	O
const	O
char	O
*	O
te	pointer
)	O
{	O
const	O
char	O
*	O
ellipsis	pointer
;	O
int	O
choplen	int
;	O
if	O
(	O
!	O
(	O
te	pointer
>	O
t	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%3d<%*s(empty)\n"	pointer
)	O
,	O
mb	pointer
->	O
depth	int
,	O
(	O
2	int
*	O
mb	pointer
->	O
depth	int
+	O
1	int
)	O
,	O
""	pointer
)	O
;	O
return	O
;	O
}	O
while	O
(	O
te	pointer
>	O
t	pointer
&&	O
iseol	O
(	O
te	pointer
[	O
-	O
1	int
]	O
)	O
)	O
te	pointer
--	O
;	O
ellipsis	pointer
=	O
""	pointer
;	O
if	O
(	O
mb	pointer
->	O
depth	int
>	O
0	int
)	O
{	O
const	O
char	O
*	O
tenl	pointer
;	O
while	O
(	O
(	O
tenl	pointer
=	O
strchr	function
(	O
t	pointer
,	O
'\n'	O
)	O
)	O
&&	O
tenl	pointer
<	O
te	pointer
)	O
t	pointer
=	O
++	O
tenl	pointer
;	O
choplen	int
=	O
61	int
-	O
(	O
2	int
*	O
mb	pointer
->	O
depth	int
)	O
;	O
if	O
(	O
(	O
te	pointer
-	O
t	pointer
)	O
>	O
choplen	int
)	O
{	O
te	pointer
=	O
t	pointer
+	O
choplen	int
;	O
ellipsis	pointer
=	O
"..."	pointer
;	O
}	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"%3d<%*s"	pointer
,	O
mb	pointer
->	O
depth	int
,	O
(	O
2	int
*	O
mb	pointer
->	O
depth	int
+	O
1	int
)	O
,	O
""	pointer
)	O
;	O
if	O
(	O
te	pointer
>	O
t	pointer
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%.*s%s"	pointer
,	O
(	O
int	O
)	O
(	O
te	pointer
-	O
t	pointer
)	O
,	O
t	pointer
,	O
ellipsis	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
static	O
int	O
expandT	function
(	O
MacroBuf	struct
*	O
mb	pointer
,	O
const	O
char	O
*	O
f	pointer
,	O
size_t	long
flen	long
)	O
{	O
char	O
*	O
sbuf	pointer
;	O
const	O
char	O
*	O
s	pointer
=	O
mb	pointer
->	O
s	pointer
;	O
int	O
rc	int
;	O
sbuf	pointer
=	O
alloca	function
(	O
flen	long
+	O
1	int
)	O
;	O
memset	function
(	O
sbuf	pointer
,	O
0	int
,	O
(	O
flen	long
+	O
1	int
)	O
)	O
;	O
strncpy	function
(	O
sbuf	pointer
,	O
f	pointer
,	O
flen	long
)	O
;	O
sbuf	pointer
[	O
flen	long
]	O
=	O
'\0'	O
;	O
mb	pointer
->	O
s	pointer
=	O
sbuf	pointer
;	O
rc	int
=	O
expandMacro	function
(	O
mb	pointer
)	O
;	O
mb	pointer
->	O
s	pointer
=	O
s	pointer
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
expandU	function
(	O
MacroBuf	struct
*	O
mb	pointer
,	O
char	O
*	O
u	union
,	O
size_t	long
ulen	long
)	O
{	O
const	O
char	O
*	O
s	pointer
=	O
mb	pointer
->	O
s	pointer
;	O
char	O
*	O
t	pointer
=	O
mb	pointer
->	O
t	pointer
;	O
size_t	long
nb	long
=	O
mb	pointer
->	O
nb	long
;	O
char	O
*	O
tbuf	pointer
;	O
int	O
rc	int
;	O
tbuf	pointer
=	O
alloca	function
(	O
ulen	long
+	O
1	int
)	O
;	O
memset	function
(	O
tbuf	pointer
,	O
0	int
,	O
(	O
ulen	long
+	O
1	int
)	O
)	O
;	O
mb	pointer
->	O
s	pointer
=	O
u	union
;	O
mb	pointer
->	O
t	pointer
=	O
tbuf	pointer
;	O
mb	pointer
->	O
nb	long
=	O
ulen	long
;	O
rc	int
=	O
expandMacro	function
(	O
mb	pointer
)	O
;	O
tbuf	pointer
[	O
ulen	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
ulen	long
>	O
mb	pointer
->	O
nb	long
)	O
strncpy	function
(	O
u	union
,	O
tbuf	pointer
,	O
(	O
ulen	long
-	O
mb	pointer
->	O
nb	long
+	O
1	int
)	O
)	O
;	O
mb	pointer
->	O
s	pointer
=	O
s	pointer
;	O
mb	pointer
->	O
t	pointer
=	O
t	pointer
;	O
mb	pointer
->	O
nb	long
=	O
nb	long
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
doShellEscape	function
(	O
MacroBuf	struct
*	O
mb	pointer
,	O
const	O
char	O
*	O
cmd	pointer
,	O
size_t	long
clen	long
)	O
{	O
char	O
pcmd	array
[	O
BUFSIZ	int
]	O
;	O
FILE	struct
*	O
shf	pointer
;	O
int	O
rc	int
;	O
int	O
c	int
;	O
strncpy	function
(	O
pcmd	array
,	O
cmd	pointer
,	O
clen	long
)	O
;	O
pcmd	array
[	O
clen	long
]	O
=	O
'\0'	O
;	O
rc	int
=	O
expandU	function
(	O
mb	pointer
,	O
pcmd	array
,	O
sizeof	O
(	O
pcmd	array
)	O
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
(	O
shf	pointer
=	O
popen	function
(	O
pcmd	array
,	O
"r"	pointer
)	O
)	O
==	O
NULL	O
)	O
return	O
1	int
;	O
while	O
(	O
mb	pointer
->	O
nb	long
>	O
0	int
&&	O
(	O
c	int
=	O
fgetc	function
(	O
shf	pointer
)	O
)	O
!=	O
EOF	O
)	O
SAVECHAR	O
(	O
mb	pointer
,	O
c	int
)	O
;	O
pclose	function
(	O
shf	pointer
)	O
;	O
while	O
(	O
iseol	O
(	O
mb	pointer
->	O
t	pointer
[	O
-	O
1	int
]	O
)	O
)	O
{	O
*	O
(	O
mb	pointer
->	O
t	pointer
--	O
)	O
=	O
'\0'	O
;	O
mb	pointer
->	O
nb	long
++	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
const	O
char	O
*	O
doDefine	function
(	O
MacroBuf	struct
*	O
mb	pointer
,	O
const	O
char	O
*	O
se	pointer
,	O
int	O
level	int
,	O
int	O
expandbody	int
)	O
{	O
const	O
char	O
*	O
s	pointer
=	O
se	pointer
;	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
,	O
*	O
n	pointer
=	O
buf	pointer
,	O
*	O
ne	pointer
=	O
n	pointer
;	O
char	O
*	O
o	pointer
=	O
NULL	O
,	O
*	O
oe	pointer
;	O
char	O
*	O
b	pointer
,	O
*	O
be	pointer
;	O
int	O
c	int
;	O
int	O
oc	int
=	O
')'	O
;	O
COPYNAME	O
(	O
ne	pointer
,	O
s	pointer
,	O
c	int
)	O
;	O
oe	pointer
=	O
ne	pointer
+	O
1	int
;	O
if	O
(	O
*	O
s	pointer
==	O
'('	O
)	O
{	O
s	pointer
++	O
;	O
o	pointer
=	O
oe	pointer
;	O
COPYOPTS	O
(	O
oe	pointer
,	O
s	pointer
,	O
oc	int
)	O
;	O
s	pointer
++	O
;	O
}	O
b	pointer
=	O
be	pointer
=	O
oe	pointer
+	O
1	int
;	O
SKIPBLANK	O
(	O
s	pointer
,	O
c	int
)	O
;	O
if	O
(	O
c	int
==	O
'{'	O
)	O
{	O
if	O
(	O
(	O
se	pointer
=	O
matchchar	function
(	O
s	pointer
,	O
c	int
,	O
'}'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s has unterminated body"	pointer
)	O
,	O
n	pointer
)	O
;	O
se	pointer
=	O
s	pointer
;	O
return	O
se	pointer
;	O
}	O
s	pointer
++	O
;	O
strncpy	function
(	O
b	pointer
,	O
s	pointer
,	O
(	O
se	pointer
-	O
s	pointer
)	O
)	O
;	O
b	pointer
[	O
se	pointer
-	O
s	pointer
]	O
=	O
'\0'	O
;	O
be	pointer
+=	O
strlen	function
(	O
b	pointer
)	O
;	O
se	pointer
++	O
;	O
s	pointer
=	O
se	pointer
;	O
}	O
else	O
{	O
COPYBODY	O
(	O
be	pointer
,	O
s	pointer
,	O
c	int
)	O
;	O
while	O
(	O
--	O
be	pointer
>=	O
b	pointer
&&	O
(	O
c	int
=	O
*	O
be	pointer
)	O
&&	O
(	O
isblank	function
(	O
c	int
)	O
||	O
iseol	O
(	O
c	int
)	O
)	O
)	O
;	O
*	O
(	O
++	O
be	pointer
)	O
=	O
'\0'	O
;	O
}	O
while	O
(	O
iseol	O
(	O
*	O
s	pointer
)	O
)	O
s	pointer
++	O
;	O
se	pointer
=	O
s	pointer
;	O
if	O
(	O
!	O
(	O
(	O
c	int
=	O
*	O
n	pointer
)	O
&&	O
(	O
isalpha	function
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
)	O
&&	O
(	O
ne	pointer
-	O
n	pointer
)	O
>	O
2	int
)	O
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s has illegal name (%%define)"	pointer
)	O
,	O
n	pointer
)	O
;	O
return	O
se	pointer
;	O
}	O
if	O
(	O
o	pointer
&&	O
oc	int
!=	O
')'	O
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s has unterminated opts"	pointer
)	O
,	O
n	pointer
)	O
;	O
return	O
se	pointer
;	O
}	O
if	O
(	O
(	O
be	pointer
-	O
b	pointer
)	O
<	O
1	int
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s has empty body"	pointer
)	O
,	O
n	pointer
)	O
;	O
return	O
se	pointer
;	O
}	O
if	O
(	O
expandbody	int
&&	O
expandU	function
(	O
mb	pointer
,	O
b	pointer
,	O
(	O
&	O
buf	pointer
[	O
sizeof	O
(	O
buf	pointer
)	O
]	O
-	O
b	pointer
)	O
)	O
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s failed to expand"	pointer
)	O
,	O
n	pointer
)	O
;	O
return	O
se	pointer
;	O
}	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
n	pointer
,	O
o	pointer
,	O
b	pointer
,	O
(	O
level	int
-	O
1	int
)	O
)	O
;	O
return	O
se	pointer
;	O
}	O
static	O
const	O
char	O
*	O
doUndefine	function
(	O
MacroContext	struct
*	O
mc	pointer
,	O
const	O
char	O
*	O
se	pointer
)	O
{	O
const	O
char	O
*	O
s	pointer
=	O
se	pointer
;	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
,	O
*	O
n	pointer
=	O
buf	pointer
,	O
*	O
ne	pointer
=	O
n	pointer
;	O
int	O
c	int
;	O
COPYNAME	O
(	O
ne	pointer
,	O
s	pointer
,	O
c	int
)	O
;	O
while	O
(	O
iseol	O
(	O
*	O
s	pointer
)	O
)	O
s	pointer
++	O
;	O
se	pointer
=	O
s	pointer
;	O
if	O
(	O
!	O
(	O
(	O
c	int
=	O
*	O
n	pointer
)	O
&&	O
(	O
isalpha	function
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
)	O
&&	O
(	O
ne	pointer
-	O
n	pointer
)	O
>	O
2	int
)	O
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Macro %%%s has illegal name (%%undefine)"	pointer
)	O
,	O
n	pointer
)	O
;	O
return	O
se	pointer
;	O
}	O
delMacro	function
(	O
mc	pointer
,	O
n	pointer
)	O
;	O
return	O
se	pointer
;	O
}	O
static	O
void	O
pushMacro	function
(	O
MacroEntry	struct
*	O
*	O
mep	pointer
,	O
const	O
char	O
*	O
n	pointer
,	O
const	O
char	O
*	O
o	pointer
,	O
const	O
char	O
*	O
b	pointer
,	O
int	O
level	int
)	O
{	O
MacroEntry	struct
*	O
prev	pointer
=	O
(	O
*	O
mep	pointer
?	O
*	O
mep	pointer
:	O
NULL	O
)	O
;	O
MacroEntry	struct
*	O
me	pointer
=	O
(	O
MacroEntry	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
me	pointer
)	O
)	O
;	O
me	pointer
->	O
prev	pointer
=	O
prev	pointer
;	O
me	pointer
->	O
name	pointer
=	O
(	O
prev	pointer
?	O
prev	pointer
->	O
name	pointer
:	O
xstrdup	function
(	O
n	pointer
)	O
)	O
;	O
me	pointer
->	O
opts	pointer
=	O
(	O
o	pointer
?	O
xstrdup	function
(	O
o	pointer
)	O
:	O
NULL	O
)	O
;	O
me	pointer
->	O
body	pointer
=	O
xstrdup	function
(	O
b	pointer
?	O
b	pointer
:	O
""	pointer
)	O
;	O
me	pointer
->	O
used	int
=	O
0	int
;	O
me	pointer
->	O
level	int
=	O
level	int
;	O
*	O
mep	pointer
=	O
me	pointer
;	O
}	O
static	O
void	O
popMacro	function
(	O
MacroEntry	struct
*	O
*	O
mep	pointer
)	O
{	O
MacroEntry	struct
*	O
me	pointer
=	O
(	O
*	O
mep	pointer
?	O
*	O
mep	pointer
:	O
NULL	O
)	O
;	O
if	O
(	O
me	pointer
)	O
{	O
if	O
(	O
(	O
*	O
mep	pointer
=	O
me	pointer
->	O
prev	pointer
)	O
==	O
NULL	O
)	O
FREE	O
(	O
me	pointer
->	O
name	pointer
)	O
;	O
FREE	O
(	O
me	pointer
->	O
opts	pointer
)	O
;	O
FREE	O
(	O
me	pointer
->	O
body	pointer
)	O
;	O
FREE	O
(	O
me	pointer
)	O
;	O
}	O
}	O
static	O
void	O
freeArgs	function
(	O
MacroBuf	struct
*	O
mb	pointer
)	O
{	O
MacroContext	struct
*	O
mc	pointer
=	O
mb	pointer
->	O
mc	pointer
;	O
int	O
ndeleted	int
=	O
0	int
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mc	pointer
->	O
firstFree	int
;	O
i	int
++	O
)	O
{	O
MacroEntry	struct
*	O
*	O
mep	pointer
,	O
*	O
me	pointer
;	O
int	O
skiptest	int
=	O
0	int
;	O
mep	pointer
=	O
&	O
mc	pointer
->	O
macroTable	pointer
[	O
i	int
]	O
;	O
me	pointer
=	O
*	O
mep	pointer
;	O
if	O
(	O
me	pointer
==	O
NULL	O
)	O
continue	O
;	O
if	O
(	O
me	pointer
->	O
level	int
<	O
mb	pointer
->	O
depth	int
)	O
continue	O
;	O
if	O
(	O
strlen	function
(	O
me	pointer
->	O
name	pointer
)	O
==	O
1	int
&&	O
strchr	function
(	O
"#*0"	pointer
,	O
*	O
me	pointer
->	O
name	pointer
)	O
)	O
{	O
if	O
(	O
*	O
me	pointer
->	O
name	pointer
==	O
'*'	O
&&	O
me	pointer
->	O
used	int
>	O
0	int
)	O
skiptest	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
skiptest	int
&&	O
me	pointer
->	O
used	int
<=	O
0	int
)	O
{	O
}	O
popMacro	function
(	O
mep	pointer
)	O
;	O
if	O
(	O
!	O
(	O
mep	pointer
&&	O
*	O
mep	pointer
)	O
)	O
ndeleted	int
++	O
;	O
}	O
if	O
(	O
ndeleted	int
)	O
sortMacroTable	function
(	O
mc	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
grabArgs	function
(	O
MacroBuf	struct
*	O
mb	pointer
,	O
const	O
MacroEntry	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
se	pointer
,	O
char	O
lastc	char
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
,	O
*	O
b	pointer
,	O
*	O
be	pointer
;	O
char	O
aname	array
[	O
16	int
]	O
;	O
const	O
char	O
*	O
opts	pointer
,	O
*	O
o	pointer
;	O
int	O
argc	int
=	O
0	int
;	O
const	O
char	O
*	O
*	O
argv	pointer
;	O
int	O
c	int
;	O
b	pointer
=	O
be	pointer
=	O
rpm_stpcpy	function
(	O
buf	pointer
,	O
me	pointer
->	O
name	pointer
)	O
;	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
"0"	pointer
,	O
NULL	O
,	O
buf	pointer
,	O
mb	pointer
->	O
depth	int
)	O
;	O
argc	int
=	O
1	int
;	O
*	O
be	pointer
++	O
=	O
' '	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
se	pointer
++	O
)	O
!=	O
'\0'	O
&&	O
c	int
!=	O
lastc	char
)	O
{	O
if	O
(	O
!	O
isblank	function
(	O
c	int
)	O
)	O
{	O
*	O
be	pointer
++	O
=	O
c	int
;	O
continue	O
;	O
}	O
if	O
(	O
be	pointer
[	O
-	O
1	int
]	O
==	O
' '	O
)	O
continue	O
;	O
*	O
be	pointer
++	O
=	O
' '	O
;	O
argc	int
++	O
;	O
}	O
if	O
(	O
c	int
==	O
'\0'	O
)	O
se	pointer
--	O
;	O
if	O
(	O
be	pointer
[	O
-	O
1	int
]	O
!=	O
' '	O
)	O
argc	int
++	O
,	O
be	pointer
++	O
;	O
be	pointer
[	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
*	O
b	pointer
==	O
' '	O
)	O
b	pointer
++	O
;	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
"**"	pointer
,	O
NULL	O
,	O
b	pointer
,	O
mb	pointer
->	O
depth	int
)	O
;	O
argv	pointer
=	O
(	O
const	O
char	O
*	O
*	O
)	O
alloca	function
(	O
(	O
argc	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
be	pointer
[	O
-	O
1	int
]	O
=	O
' '	O
;	O
b	pointer
=	O
buf	pointer
;	O
for	O
(	O
c	int
=	O
0	int
;	O
c	int
<	O
argc	int
;	O
c	int
++	O
)	O
{	O
argv	pointer
[	O
c	int
]	O
=	O
b	pointer
;	O
b	pointer
=	O
strchr	function
(	O
b	pointer
,	O
' '	O
)	O
;	O
*	O
b	pointer
++	O
=	O
'\0'	O
;	O
}	O
argv	pointer
[	O
argc	int
]	O
=	O
NULL	O
;	O
opts	pointer
=	O
me	pointer
->	O
opts	pointer
;	O
while	O
(	O
(	O
c	int
=	O
getopt	function
(	O
argc	int
,	O
(	O
char	O
*	O
*	O
)	O
argv	pointer
,	O
opts	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
c	int
==	O
'?'	O
||	O
(	O
o	pointer
=	O
strchr	function
(	O
opts	pointer
,	O
c	int
)	O
)	O
==	O
NULL	O
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Unknown option %c in %s(%s)"	pointer
)	O
,	O
c	int
,	O
me	pointer
->	O
name	pointer
,	O
opts	pointer
)	O
;	O
return	O
se	pointer
;	O
}	O
*	O
be	pointer
++	O
=	O
'-'	O
;	O
*	O
be	pointer
++	O
=	O
c	int
;	O
if	O
(	O
o	pointer
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
*	O
be	pointer
++	O
=	O
' '	O
;	O
be	pointer
=	O
rpm_stpcpy	function
(	O
be	pointer
,	O
optarg	pointer
)	O
;	O
}	O
*	O
be	pointer
++	O
=	O
'\0'	O
;	O
aname	array
[	O
0	int
]	O
=	O
'-'	O
;	O
aname	array
[	O
1	int
]	O
=	O
c	int
;	O
aname	array
[	O
2	int
]	O
=	O
'\0'	O
;	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
aname	array
,	O
NULL	O
,	O
b	pointer
,	O
mb	pointer
->	O
depth	int
)	O
;	O
if	O
(	O
o	pointer
[	O
1	int
]	O
==	O
':'	O
)	O
{	O
aname	array
[	O
0	int
]	O
=	O
'-'	O
;	O
aname	array
[	O
1	int
]	O
=	O
c	int
;	O
aname	array
[	O
2	int
]	O
=	O
'*'	O
;	O
aname	array
[	O
3	int
]	O
=	O
'\0'	O
;	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
aname	array
,	O
NULL	O
,	O
optarg	pointer
,	O
mb	pointer
->	O
depth	int
)	O
;	O
}	O
be	pointer
=	O
b	pointer
;	O
}	O
sprintf	function
(	O
aname	array
,	O
"%d"	pointer
,	O
(	O
argc	int
-	O
optind	int
)	O
)	O
;	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
"#"	pointer
,	O
NULL	O
,	O
aname	array
,	O
mb	pointer
->	O
depth	int
)	O
;	O
*	O
be	pointer
=	O
'\0'	O
;	O
for	O
(	O
c	int
=	O
optind	int
;	O
c	int
<	O
argc	int
;	O
c	int
++	O
)	O
{	O
sprintf	function
(	O
aname	array
,	O
"%d"	pointer
,	O
(	O
c	int
-	O
optind	int
+	O
1	int
)	O
)	O
;	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
aname	array
,	O
NULL	O
,	O
argv	pointer
[	O
c	int
]	O
,	O
mb	pointer
->	O
depth	int
)	O
;	O
*	O
be	pointer
++	O
=	O
' '	O
;	O
be	pointer
=	O
rpm_stpcpy	function
(	O
be	pointer
,	O
argv	pointer
[	O
c	int
]	O
)	O
;	O
}	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
"*"	pointer
,	O
NULL	O
,	O
b	pointer
,	O
mb	pointer
->	O
depth	int
)	O
;	O
return	O
se	pointer
;	O
}	O
static	O
void	O
doOutput	function
(	O
MacroBuf	struct
*	O
mb	pointer
,	O
int	O
waserror	int
,	O
const	O
char	O
*	O
msg	pointer
,	O
size_t	long
msglen	long
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
strncpy	function
(	O
buf	pointer
,	O
msg	pointer
,	O
msglen	long
)	O
;	O
buf	pointer
[	O
msglen	long
]	O
=	O
'\0'	O
;	O
expandU	function
(	O
mb	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
if	O
(	O
waserror	int
)	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
"%s"	pointer
,	O
buf	pointer
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"%s"	pointer
,	O
buf	pointer
)	O
;	O
}	O
static	O
void	O
doFoo	function
(	O
MacroBuf	struct
*	O
mb	pointer
,	O
int	O
negate	int
,	O
const	O
char	O
*	O
f	pointer
,	O
size_t	long
fn	long
,	O
const	O
char	O
*	O
g	pointer
,	O
size_t	long
glen	long
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
,	O
*	O
b	pointer
=	O
NULL	O
,	O
*	O
be	pointer
;	O
int	O
c	int
;	O
buf	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
g	pointer
)	O
{	O
strncpy	function
(	O
buf	pointer
,	O
g	pointer
,	O
glen	long
)	O
;	O
buf	pointer
[	O
glen	long
]	O
=	O
'\0'	O
;	O
expandU	function
(	O
mb	pointer
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"basename"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
if	O
(	O
(	O
b	pointer
=	O
strrchr	function
(	O
buf	pointer
,	O
'/'	O
)	O
)	O
==	O
NULL	O
)	O
b	pointer
=	O
buf	pointer
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"suffix"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
if	O
(	O
(	O
b	pointer
=	O
strrchr	function
(	O
buf	pointer
,	O
'.'	O
)	O
)	O
!=	O
NULL	O
)	O
b	pointer
++	O
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"expand"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
b	pointer
=	O
buf	pointer
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"verbose"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
if	O
(	O
negate	int
)	O
b	pointer
=	O
(	O
rpmIsVerbose	function
(	O
)	O
?	O
NULL	O
:	O
buf	pointer
)	O
;	O
else	O
b	pointer
=	O
(	O
rpmIsVerbose	function
(	O
)	O
?	O
buf	pointer
:	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"url2path"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"u2p"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
(	O
void	O
)	O
urlPath	function
(	O
buf	pointer
,	O
(	O
const	O
char	O
*	O
*	O
)	O
&	O
b	pointer
)	O
;	O
if	O
(	O
*	O
b	pointer
==	O
'\0'	O
)	O
b	pointer
=	O
"/"	pointer
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"uncompress"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
int	O
compressed	pointer
=	O
1	int
;	O
for	O
(	O
b	pointer
=	O
buf	pointer
;	O
(	O
c	int
=	O
*	O
b	pointer
)	O
&&	O
isblank	function
(	O
c	int
)	O
;	O
)	O
b	pointer
++	O
;	O
for	O
(	O
be	pointer
=	O
b	pointer
;	O
(	O
c	int
=	O
*	O
be	pointer
)	O
&&	O
!	O
isblank	function
(	O
c	int
)	O
;	O
)	O
be	pointer
++	O
;	O
*	O
be	pointer
++	O
=	O
'\0'	O
;	O
isCompressed	function
(	O
b	pointer
,	O
&	O
compressed	pointer
)	O
;	O
switch	O
(	O
compressed	pointer
)	O
{	O
default	O
:	O
case	O
0	int
:	O
sprintf	function
(	O
be	pointer
,	O
"%%_cat %s"	pointer
,	O
b	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
sprintf	function
(	O
be	pointer
,	O
"%%_gzip -dc %s"	pointer
,	O
b	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
sprintf	function
(	O
be	pointer
,	O
"%%_bzip2 %s"	pointer
,	O
b	pointer
)	O
;	O
break	O
;	O
}	O
b	pointer
=	O
be	pointer
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"S"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
for	O
(	O
b	pointer
=	O
buf	pointer
;	O
(	O
c	int
=	O
*	O
b	pointer
)	O
&&	O
isdigit	function
(	O
c	int
)	O
;	O
)	O
b	pointer
++	O
;	O
if	O
(	O
!	O
c	int
)	O
{	O
b	pointer
++	O
;	O
sprintf	function
(	O
b	pointer
,	O
"%%SOURCE%s"	pointer
,	O
buf	pointer
)	O
;	O
}	O
else	O
b	pointer
=	O
buf	pointer
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"P"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
for	O
(	O
b	pointer
=	O
buf	pointer
;	O
(	O
c	int
=	O
*	O
b	pointer
)	O
&&	O
isdigit	function
(	O
c	int
)	O
;	O
)	O
b	pointer
++	O
;	O
if	O
(	O
!	O
c	int
)	O
{	O
b	pointer
++	O
;	O
sprintf	function
(	O
b	pointer
,	O
"%%PATCH%s"	pointer
,	O
buf	pointer
)	O
;	O
}	O
else	O
b	pointer
=	O
buf	pointer
;	O
}	O
else	O
if	O
(	O
STREQ	O
(	O
"F"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
b	pointer
=	O
buf	pointer
+	O
strlen	function
(	O
buf	pointer
)	O
+	O
1	int
;	O
sprintf	function
(	O
b	pointer
,	O
"file%s.file"	pointer
,	O
buf	pointer
)	O
;	O
}	O
if	O
(	O
b	pointer
)	O
{	O
expandT	function
(	O
mb	pointer
,	O
b	pointer
,	O
strlen	function
(	O
b	pointer
)	O
)	O
;	O
}	O
}	O
static	O
int	O
expandMacro	function
(	O
MacroBuf	struct
*	O
mb	pointer
)	O
{	O
MacroEntry	struct
*	O
*	O
mep	pointer
;	O
MacroEntry	struct
*	O
me	pointer
;	O
const	O
char	O
*	O
s	pointer
=	O
mb	pointer
->	O
s	pointer
,	O
*	O
se	pointer
;	O
const	O
char	O
*	O
f	pointer
,	O
*	O
fe	pointer
;	O
const	O
char	O
*	O
g	pointer
,	O
*	O
ge	pointer
;	O
size_t	long
fn	long
,	O
gn	long
;	O
char	O
*	O
t	pointer
=	O
mb	pointer
->	O
t	pointer
;	O
int	O
c	int
;	O
int	O
rc	int
=	O
0	int
;	O
int	O
negate	int
;	O
char	O
grab	char
;	O
int	O
chkexist	int
;	O
if	O
(	O
++	O
mb	pointer
->	O
depth	int
>	O
max_macro_depth	int
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Recursion depth(%d) greater than max(%d)"	pointer
)	O
,	O
mb	pointer
->	O
depth	int
,	O
max_macro_depth	int
)	O
;	O
mb	pointer
->	O
depth	int
--	O
;	O
mb	pointer
->	O
expand_trace	int
=	O
1	int
;	O
return	O
1	int
;	O
}	O
while	O
(	O
rc	int
==	O
0	int
&&	O
mb	pointer
->	O
nb	long
>	O
0	int
&&	O
(	O
c	int
=	O
*	O
s	pointer
)	O
!=	O
'\0'	O
)	O
{	O
s	pointer
++	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
'%'	O
:	O
if	O
(	O
*	O
s	pointer
!=	O
'%'	O
)	O
break	O
;	O
s	pointer
++	O
;	O
default	O
:	O
SAVECHAR	O
(	O
mb	pointer
,	O
c	int
)	O
;	O
continue	O
;	O
break	O
;	O
}	O
f	pointer
=	O
fe	pointer
=	O
NULL	O
;	O
g	pointer
=	O
ge	pointer
=	O
NULL	O
;	O
if	O
(	O
mb	pointer
->	O
depth	int
>	O
1	int
)	O
t	pointer
=	O
mb	pointer
->	O
t	pointer
;	O
negate	int
=	O
0	int
;	O
grab	char
=	O
'\0'	O
;	O
chkexist	int
=	O
0	int
;	O
switch	O
(	O
(	O
c	int
=	O
*	O
s	pointer
)	O
)	O
{	O
default	O
:	O
while	O
(	O
strchr	function
(	O
"!?"	pointer
,	O
*	O
s	pointer
)	O
!=	O
NULL	O
)	O
{	O
switch	O
(	O
*	O
s	pointer
++	O
)	O
{	O
case	O
'!'	O
:	O
negate	int
=	O
(	O
++	O
negate	int
%	O
2	int
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
chkexist	int
++	O
;	O
break	O
;	O
}	O
}	O
f	pointer
=	O
se	pointer
=	O
s	pointer
;	O
if	O
(	O
*	O
se	pointer
==	O
'-'	O
)	O
se	pointer
++	O
;	O
while	O
(	O
(	O
c	int
=	O
*	O
se	pointer
)	O
&&	O
(	O
isalnum	function
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
)	O
)	O
se	pointer
++	O
;	O
switch	O
(	O
*	O
se	pointer
)	O
{	O
case	O
'*'	O
:	O
se	pointer
++	O
;	O
if	O
(	O
*	O
se	pointer
==	O
'*'	O
)	O
se	pointer
++	O
;	O
break	O
;	O
case	O
'#'	O
:	O
se	pointer
++	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
fe	pointer
=	O
se	pointer
;	O
if	O
(	O
(	O
c	int
=	O
*	O
fe	pointer
)	O
&&	O
isblank	function
(	O
c	int
)	O
)	O
grab	char
=	O
'\n'	O
;	O
break	O
;	O
case	O
'('	O
:	O
if	O
(	O
(	O
se	pointer
=	O
matchchar	function
(	O
s	pointer
,	O
c	int
,	O
')'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Unterminated %c: %s"	pointer
)	O
,	O
c	int
,	O
s	pointer
)	O
;	O
rc	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
mb	pointer
->	O
macro_trace	int
)	O
printMacro	function
(	O
mb	pointer
,	O
s	pointer
,	O
se	pointer
+	O
1	int
)	O
;	O
s	pointer
++	O
;	O
rc	int
=	O
doShellEscape	function
(	O
mb	pointer
,	O
s	pointer
,	O
(	O
se	pointer
-	O
s	pointer
)	O
)	O
;	O
se	pointer
++	O
;	O
s	pointer
=	O
se	pointer
;	O
continue	O
;	O
break	O
;	O
case	O
'{'	O
:	O
if	O
(	O
(	O
se	pointer
=	O
matchchar	function
(	O
s	pointer
,	O
c	int
,	O
'}'	O
)	O
)	O
==	O
NULL	O
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Unterminated %c: %s"	pointer
)	O
,	O
c	int
,	O
s	pointer
)	O
;	O
rc	int
=	O
1	int
;	O
continue	O
;	O
}	O
f	pointer
=	O
s	pointer
+	O
1	int
;	O
se	pointer
++	O
;	O
while	O
(	O
strchr	function
(	O
"!?"	pointer
,	O
*	O
f	pointer
)	O
!=	O
NULL	O
)	O
{	O
switch	O
(	O
*	O
f	pointer
++	O
)	O
{	O
case	O
'!'	O
:	O
negate	int
=	O
(	O
++	O
negate	int
%	O
2	int
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
chkexist	int
++	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
fe	pointer
=	O
f	pointer
;	O
(	O
c	int
=	O
*	O
fe	pointer
)	O
&&	O
!	O
strchr	function
(	O
" :}"	pointer
,	O
c	int
)	O
;	O
)	O
fe	pointer
++	O
;	O
switch	O
(	O
c	int
)	O
{	O
case	O
':'	O
:	O
g	pointer
=	O
fe	pointer
+	O
1	int
;	O
ge	pointer
=	O
se	pointer
-	O
1	int
;	O
break	O
;	O
case	O
' '	O
:	O
grab	char
=	O
se	pointer
[	O
-	O
1	int
]	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
break	O
;	O
}	O
fn	long
=	O
(	O
fe	pointer
-	O
f	pointer
)	O
;	O
gn	long
=	O
(	O
ge	pointer
-	O
g	pointer
)	O
;	O
if	O
(	O
fn	long
<=	O
0	int
)	O
{	O
c	int
=	O
'%'	O
;	O
SAVECHAR	O
(	O
mb	pointer
,	O
c	int
)	O
;	O
s	pointer
=	O
se	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
mb	pointer
->	O
macro_trace	int
)	O
printMacro	function
(	O
mb	pointer
,	O
s	pointer
,	O
se	pointer
)	O
;	O
if	O
(	O
STREQ	O
(	O
"global"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
s	pointer
=	O
doDefine	function
(	O
mb	pointer
,	O
se	pointer
,	O
RMIL_GLOBAL	int
,	O
1	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"define"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
s	pointer
=	O
doDefine	function
(	O
mb	pointer
,	O
se	pointer
,	O
mb	pointer
->	O
depth	int
,	O
0	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"undefine"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
s	pointer
=	O
doUndefine	function
(	O
mb	pointer
->	O
mc	pointer
,	O
se	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"echo"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"warn"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"error"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
int	O
waserror	int
=	O
0	int
;	O
if	O
(	O
STREQ	O
(	O
"error"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
waserror	int
=	O
1	int
;	O
if	O
(	O
g	pointer
<	O
ge	pointer
)	O
doOutput	function
(	O
mb	pointer
,	O
waserror	int
,	O
g	pointer
,	O
gn	long
)	O
;	O
else	O
doOutput	function
(	O
mb	pointer
,	O
waserror	int
,	O
f	pointer
,	O
fn	long
)	O
;	O
s	pointer
=	O
se	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"trace"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
mb	pointer
->	O
expand_trace	int
=	O
mb	pointer
->	O
macro_trace	int
=	O
(	O
negate	int
?	O
0	int
:	O
mb	pointer
->	O
depth	int
)	O
;	O
if	O
(	O
mb	pointer
->	O
depth	int
==	O
1	int
)	O
{	O
print_macro_trace	int
=	O
mb	pointer
->	O
macro_trace	int
;	O
print_expand_trace	int
=	O
mb	pointer
->	O
expand_trace	int
;	O
}	O
s	pointer
=	O
se	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"dump"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
rpmDumpMacroTable	function
(	O
mb	pointer
->	O
mc	pointer
,	O
NULL	O
)	O
;	O
while	O
(	O
iseol	O
(	O
*	O
se	pointer
)	O
)	O
se	pointer
++	O
;	O
s	pointer
=	O
se	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
STREQ	O
(	O
"basename"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"suffix"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"expand"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"verbose"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"uncompress"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"url2path"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"u2p"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"S"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"P"	pointer
,	O
f	pointer
,	O
fn	long
)	O
||	O
STREQ	O
(	O
"F"	pointer
,	O
f	pointer
,	O
fn	long
)	O
)	O
{	O
doFoo	function
(	O
mb	pointer
,	O
negate	int
,	O
f	pointer
,	O
fn	long
,	O
g	pointer
,	O
gn	long
)	O
;	O
s	pointer
=	O
se	pointer
;	O
continue	O
;	O
}	O
mep	pointer
=	O
findEntry	function
(	O
mb	pointer
->	O
mc	pointer
,	O
f	pointer
,	O
fn	long
)	O
;	O
me	pointer
=	O
(	O
mep	pointer
?	O
*	O
mep	pointer
:	O
NULL	O
)	O
;	O
if	O
(	O
*	O
f	pointer
==	O
'-'	O
)	O
{	O
if	O
(	O
me	pointer
)	O
me	pointer
->	O
used	int
++	O
;	O
if	O
(	O
(	O
me	pointer
==	O
NULL	O
&&	O
!	O
negate	int
)	O
||	O
(	O
me	pointer
!=	O
NULL	O
&&	O
negate	int
)	O
)	O
{	O
s	pointer
=	O
se	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
g	pointer
&&	O
g	pointer
<	O
ge	pointer
)	O
{	O
rc	int
=	O
expandT	function
(	O
mb	pointer
,	O
g	pointer
,	O
gn	long
)	O
;	O
}	O
else	O
if	O
(	O
me	pointer
->	O
body	pointer
&&	O
*	O
me	pointer
->	O
body	pointer
)	O
{	O
rc	int
=	O
expandT	function
(	O
mb	pointer
,	O
me	pointer
->	O
body	pointer
,	O
strlen	function
(	O
me	pointer
->	O
body	pointer
)	O
)	O
;	O
}	O
s	pointer
=	O
se	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
chkexist	int
)	O
{	O
if	O
(	O
(	O
me	pointer
==	O
NULL	O
&&	O
!	O
negate	int
)	O
||	O
(	O
me	pointer
!=	O
NULL	O
&&	O
negate	int
)	O
)	O
{	O
s	pointer
=	O
se	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
g	pointer
&&	O
g	pointer
<	O
ge	pointer
)	O
{	O
rc	int
=	O
expandT	function
(	O
mb	pointer
,	O
g	pointer
,	O
gn	long
)	O
;	O
}	O
else	O
if	O
(	O
me	pointer
&&	O
me	pointer
->	O
body	pointer
&&	O
*	O
me	pointer
->	O
body	pointer
)	O
{	O
rc	int
=	O
expandT	function
(	O
mb	pointer
,	O
me	pointer
->	O
body	pointer
,	O
strlen	function
(	O
me	pointer
->	O
body	pointer
)	O
)	O
;	O
}	O
s	pointer
=	O
se	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
me	pointer
==	O
NULL	O
)	O
{	O
c	int
=	O
'%'	O
;	O
SAVECHAR	O
(	O
mb	pointer
,	O
c	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
me	pointer
&&	O
me	pointer
->	O
opts	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
grab	char
)	O
{	O
se	pointer
=	O
grabArgs	function
(	O
mb	pointer
,	O
me	pointer
,	O
fe	pointer
,	O
grab	char
)	O
;	O
}	O
else	O
{	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
"**"	pointer
,	O
NULL	O
,	O
""	pointer
,	O
mb	pointer
->	O
depth	int
)	O
;	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
"*"	pointer
,	O
NULL	O
,	O
""	pointer
,	O
mb	pointer
->	O
depth	int
)	O
;	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
"#"	pointer
,	O
NULL	O
,	O
"0"	pointer
,	O
mb	pointer
->	O
depth	int
)	O
;	O
addMacro	function
(	O
mb	pointer
->	O
mc	pointer
,	O
"0"	pointer
,	O
NULL	O
,	O
me	pointer
->	O
name	pointer
,	O
mb	pointer
->	O
depth	int
)	O
;	O
}	O
}	O
if	O
(	O
me	pointer
->	O
body	pointer
&&	O
*	O
me	pointer
->	O
body	pointer
)	O
{	O
mb	pointer
->	O
s	pointer
=	O
me	pointer
->	O
body	pointer
;	O
rc	int
=	O
expandMacro	function
(	O
mb	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
me	pointer
->	O
used	int
++	O
;	O
}	O
if	O
(	O
me	pointer
->	O
opts	pointer
!=	O
NULL	O
)	O
freeArgs	function
(	O
mb	pointer
)	O
;	O
s	pointer
=	O
se	pointer
;	O
}	O
*	O
mb	pointer
->	O
t	pointer
=	O
'\0'	O
;	O
mb	pointer
->	O
s	pointer
=	O
s	pointer
;	O
mb	pointer
->	O
depth	int
--	O
;	O
if	O
(	O
rc	int
!=	O
0	int
||	O
mb	pointer
->	O
expand_trace	int
)	O
printExpansion	function
(	O
mb	pointer
,	O
t	pointer
,	O
mb	pointer
->	O
t	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
const	O
char	O
*	O
getMacroBody	function
(	O
MacroContext	struct
*	O
mc	pointer
,	O
const	O
char	O
*	O
name	pointer
)	O
{	O
MacroEntry	struct
*	O
*	O
mep	pointer
=	O
findEntry	function
(	O
mc	pointer
,	O
name	pointer
,	O
0	int
)	O
;	O
MacroEntry	struct
*	O
me	pointer
=	O
(	O
mep	pointer
?	O
*	O
mep	pointer
:	O
NULL	O
)	O
;	O
return	O
(	O
me	pointer
?	O
me	pointer
->	O
body	pointer
:	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
}	O
int	O
expandMacros	function
(	O
void	O
*	O
spec	pointer
,	O
MacroContext	struct
*	O
mc	pointer
,	O
char	O
*	O
s	pointer
,	O
size_t	long
slen	long
)	O
{	O
MacroBuf	struct
macrobuf	struct
,	O
*	O
mb	pointer
=	O
&	O
macrobuf	struct
;	O
char	O
*	O
tbuf	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
s	pointer
==	O
NULL	O
||	O
slen	long
<=	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
mc	pointer
==	O
NULL	O
)	O
mc	pointer
=	O
&	O
rpmGlobalMacroContext	struct
;	O
tbuf	pointer
=	O
alloca	function
(	O
slen	long
+	O
1	int
)	O
;	O
memset	function
(	O
tbuf	pointer
,	O
0	int
,	O
(	O
slen	long
+	O
1	int
)	O
)	O
;	O
mb	pointer
->	O
s	pointer
=	O
s	pointer
;	O
mb	pointer
->	O
t	pointer
=	O
tbuf	pointer
;	O
mb	pointer
->	O
nb	long
=	O
slen	long
;	O
mb	pointer
->	O
depth	int
=	O
0	int
;	O
mb	pointer
->	O
macro_trace	int
=	O
print_macro_trace	int
;	O
mb	pointer
->	O
expand_trace	int
=	O
print_expand_trace	int
;	O
mb	pointer
->	O
spec	pointer
=	O
spec	pointer
;	O
mb	pointer
->	O
mc	pointer
=	O
mc	pointer
;	O
rc	int
=	O
expandMacro	function
(	O
mb	pointer
)	O
;	O
if	O
(	O
mb	pointer
->	O
nb	long
<=	O
0	int
)	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"Target buffer overflow"	pointer
)	O
)	O
;	O
tbuf	pointer
[	O
slen	long
]	O
=	O
'\0'	O
;	O
strncpy	function
(	O
s	pointer
,	O
tbuf	pointer
,	O
(	O
slen	long
-	O
mb	pointer
->	O
nb	long
+	O
1	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
void	O
addMacro	function
(	O
MacroContext	struct
*	O
mc	pointer
,	O
const	O
char	O
*	O
n	pointer
,	O
const	O
char	O
*	O
o	pointer
,	O
const	O
char	O
*	O
b	pointer
,	O
int	O
level	int
)	O
{	O
MacroEntry	struct
*	O
*	O
mep	pointer
;	O
if	O
(	O
mc	pointer
==	O
NULL	O
)	O
mc	pointer
=	O
&	O
rpmGlobalMacroContext	struct
;	O
if	O
(	O
(	O
mep	pointer
=	O
findEntry	function
(	O
mc	pointer
,	O
n	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
mc	pointer
->	O
firstFree	int
==	O
mc	pointer
->	O
macrosAllocated	int
)	O
expandMacroTable	function
(	O
mc	pointer
)	O
;	O
mep	pointer
=	O
mc	pointer
->	O
macroTable	pointer
+	O
mc	pointer
->	O
firstFree	int
++	O
;	O
}	O
pushMacro	function
(	O
mep	pointer
,	O
n	pointer
,	O
o	pointer
,	O
b	pointer
,	O
level	int
)	O
;	O
if	O
(	O
(	O
*	O
mep	pointer
)	O
->	O
prev	pointer
==	O
NULL	O
)	O
sortMacroTable	function
(	O
mc	pointer
)	O
;	O
}	O
void	O
delMacro	function
(	O
MacroContext	struct
*	O
mc	pointer
,	O
const	O
char	O
*	O
n	pointer
)	O
{	O
MacroEntry	struct
*	O
*	O
mep	pointer
;	O
if	O
(	O
mc	pointer
==	O
NULL	O
)	O
mc	pointer
=	O
&	O
rpmGlobalMacroContext	struct
;	O
if	O
(	O
(	O
mep	pointer
=	O
findEntry	function
(	O
mc	pointer
,	O
n	pointer
,	O
0	int
)	O
)	O
!=	O
NULL	O
)	O
{	O
popMacro	function
(	O
mep	pointer
)	O
;	O
if	O
(	O
!	O
(	O
mep	pointer
&&	O
*	O
mep	pointer
)	O
)	O
sortMacroTable	function
(	O
mc	pointer
)	O
;	O
}	O
}	O
int	O
rpmDefineMacro	function
(	O
MacroContext	struct
*	O
mc	pointer
,	O
const	O
char	O
*	O
macro	pointer
,	O
int	O
level	int
)	O
{	O
MacroBuf	struct
macrobuf	struct
,	O
*	O
mb	pointer
=	O
&	O
macrobuf	struct
;	O
mb	pointer
->	O
mc	pointer
=	O
(	O
mc	pointer
?	O
mc	pointer
:	O
&	O
rpmGlobalMacroContext	struct
)	O
;	O
(	O
void	O
)	O
doDefine	function
(	O
mb	pointer
,	O
macro	pointer
,	O
level	int
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
void	O
rpmLoadMacros	function
(	O
MacroContext	struct
*	O
mc	pointer
,	O
int	O
level	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
mc	pointer
==	O
NULL	O
||	O
mc	pointer
==	O
&	O
rpmGlobalMacroContext	struct
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mc	pointer
->	O
firstFree	int
;	O
i	int
++	O
)	O
{	O
MacroEntry	struct
*	O
*	O
mep	pointer
,	O
*	O
me	pointer
;	O
mep	pointer
=	O
&	O
mc	pointer
->	O
macroTable	pointer
[	O
i	int
]	O
;	O
me	pointer
=	O
*	O
mep	pointer
;	O
if	O
(	O
me	pointer
==	O
NULL	O
)	O
continue	O
;	O
addMacro	function
(	O
NULL	O
,	O
me	pointer
->	O
name	pointer
,	O
me	pointer
->	O
opts	pointer
,	O
me	pointer
->	O
body	pointer
,	O
(	O
level	int
-	O
1	int
)	O
)	O
;	O
}	O
}	O
void	O
rpmInitMacros	function
(	O
MacroContext	struct
*	O
mc	pointer
,	O
const	O
char	O
*	O
macrofiles	pointer
)	O
{	O
char	O
*	O
m	pointer
,	O
*	O
mfile	pointer
,	O
*	O
me	pointer
;	O
if	O
(	O
macrofiles	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
mc	pointer
==	O
NULL	O
)	O
mc	pointer
=	O
&	O
rpmGlobalMacroContext	struct
;	O
for	O
(	O
mfile	pointer
=	O
m	pointer
=	O
xstrdup	function
(	O
macrofiles	pointer
)	O
;	O
*	O
mfile	pointer
;	O
mfile	pointer
=	O
me	pointer
)	O
{	O
FD_t	pointer
fd	pointer
;	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
for	O
(	O
me	pointer
=	O
mfile	pointer
;	O
(	O
me	pointer
=	O
strchr	function
(	O
me	pointer
,	O
':'	O
)	O
)	O
!=	O
NULL	O
;	O
me	pointer
++	O
)	O
{	O
if	O
(	O
!	O
(	O
me	pointer
[	O
1	int
]	O
==	O
'/'	O
&&	O
me	pointer
[	O
2	int
]	O
==	O
'/'	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
me	pointer
&&	O
*	O
me	pointer
==	O
':'	O
)	O
*	O
me	pointer
++	O
=	O
'\0'	O
;	O
else	O
me	pointer
=	O
mfile	pointer
+	O
strlen	function
(	O
mfile	pointer
)	O
;	O
buf	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
mfile	pointer
[	O
0	int
]	O
==	O
'~'	O
&&	O
mfile	pointer
[	O
1	int
]	O
==	O
'/'	O
)	O
{	O
char	O
*	O
home	pointer
;	O
if	O
(	O
(	O
home	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
mfile	pointer
+=	O
2	int
;	O
strncpy	function
(	O
buf	pointer
,	O
home	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
strncat	function
(	O
buf	pointer
,	O
"/"	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
-	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
}	O
strncat	function
(	O
buf	pointer
,	O
mfile	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
-	O
strlen	function
(	O
buf	pointer
)	O
)	O
;	O
buf	pointer
[	O
sizeof	O
(	O
buf	pointer
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
fd	pointer
=	O
Fopen	function
(	O
buf	pointer
,	O
"r.fpio"	pointer
)	O
;	O
if	O
(	O
fd	pointer
==	O
NULL	O
||	O
Ferror	function
(	O
fd	pointer
)	O
)	O
{	O
if	O
(	O
fd	pointer
)	O
Fclose	function
(	O
fd	pointer
)	O
;	O
continue	O
;	O
}	O
max_macro_depth	int
=	O
16	int
;	O
while	O
(	O
rdcl	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
fd	pointer
,	O
1	int
)	O
!=	O
NULL	O
)	O
{	O
char	O
c	int
,	O
*	O
n	pointer
;	O
n	pointer
=	O
buf	pointer
;	O
SKIPBLANK	O
(	O
n	pointer
,	O
c	int
)	O
;	O
if	O
(	O
c	int
!=	O
'%'	O
)	O
continue	O
;	O
n	pointer
++	O
;	O
(	O
void	O
)	O
rpmDefineMacro	function
(	O
NULL	O
,	O
n	pointer
,	O
RMIL_MACROFILES	O
)	O
;	O
}	O
Fclose	function
(	O
fd	pointer
)	O
;	O
}	O
if	O
(	O
m	pointer
)	O
free	function
(	O
m	pointer
)	O
;	O
rpmLoadMacros	function
(	O
&	O
rpmCLIMacroContext	struct
,	O
RMIL_CMDLINE	O
)	O
;	O
}	O
void	O
rpmFreeMacros	function
(	O
MacroContext	struct
*	O
mc	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
mc	pointer
==	O
NULL	O
)	O
mc	pointer
=	O
&	O
rpmGlobalMacroContext	struct
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mc	pointer
->	O
firstFree	int
;	O
i	int
++	O
)	O
{	O
MacroEntry	struct
*	O
me	pointer
;	O
while	O
(	O
(	O
me	pointer
=	O
mc	pointer
->	O
macroTable	pointer
[	O
i	int
]	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
(	O
mc	pointer
->	O
macroTable	pointer
[	O
i	int
]	O
=	O
me	pointer
->	O
prev	pointer
)	O
==	O
NULL	O
)	O
FREE	O
(	O
me	pointer
->	O
name	pointer
)	O
;	O
FREE	O
(	O
me	pointer
->	O
opts	pointer
)	O
;	O
FREE	O
(	O
me	pointer
->	O
body	pointer
)	O
;	O
FREE	O
(	O
me	pointer
)	O
;	O
}	O
}	O
FREE	O
(	O
mc	pointer
->	O
macroTable	pointer
)	O
;	O
memset	function
(	O
mc	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
mc	pointer
)	O
)	O
;	O
}	O
int	O
isCompressed	function
(	O
const	O
char	O
*	O
file	pointer
,	O
int	O
*	O
compressed	pointer
)	O
{	O
FD_t	pointer
fd	pointer
;	O
ssize_t	long
nb	long
;	O
int	O
rc	int
=	O
-	O
1	int
;	O
unsigned	O
char	O
magic	array
[	O
4	int
]	O
;	O
*	O
compressed	pointer
=	O
COMPRESSED_NOT	int
;	O
fd	pointer
=	O
Fopen	function
(	O
file	pointer
,	O
"r.ufdio"	pointer
)	O
;	O
if	O
(	O
fd	pointer
==	O
NULL	O
||	O
Ferror	function
(	O
fd	pointer
)	O
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"File %s: %s"	pointer
)	O
,	O
file	pointer
,	O
Fstrerror	function
(	O
fd	pointer
)	O
)	O
;	O
if	O
(	O
fd	pointer
)	O
Fclose	function
(	O
fd	pointer
)	O
;	O
return	O
1	int
;	O
}	O
nb	long
=	O
Fread	function
(	O
magic	array
,	O
sizeof	O
(	O
char	O
)	O
,	O
sizeof	O
(	O
magic	array
)	O
,	O
fd	pointer
)	O
;	O
if	O
(	O
nb	long
<	O
0	int
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"File %s: %s"	pointer
)	O
,	O
file	pointer
,	O
Fstrerror	function
(	O
fd	pointer
)	O
)	O
;	O
rc	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
nb	long
<	O
sizeof	O
(	O
magic	array
)	O
)	O
{	O
rpmError	function
(	O
RPMERR_BADSPEC	O
,	O
_	O
(	O
"File %s is smaller than %d bytes"	pointer
)	O
,	O
file	pointer
,	O
sizeof	O
(	O
magic	array
)	O
)	O
;	O
rc	int
=	O
0	int
;	O
}	O
Fclose	function
(	O
fd	pointer
)	O
;	O
if	O
(	O
rc	int
>=	O
0	int
)	O
return	O
rc	int
;	O
rc	int
=	O
0	int
;	O
if	O
(	O
(	O
(	O
magic	array
[	O
0	int
]	O
==	O
0037	int
)	O
&&	O
(	O
magic	array
[	O
1	int
]	O
==	O
0213	int
)	O
)	O
||	O
(	O
(	O
magic	array
[	O
0	int
]	O
==	O
0037	int
)	O
&&	O
(	O
magic	array
[	O
1	int
]	O
==	O
0236	int
)	O
)	O
||	O
(	O
(	O
magic	array
[	O
0	int
]	O
==	O
0037	int
)	O
&&	O
(	O
magic	array
[	O
1	int
]	O
==	O
0036	int
)	O
)	O
||	O
(	O
(	O
magic	array
[	O
0	int
]	O
==	O
0037	int
)	O
&&	O
(	O
magic	array
[	O
1	int
]	O
==	O
0240	int
)	O
)	O
||	O
(	O
(	O
magic	array
[	O
0	int
]	O
==	O
0037	int
)	O
&&	O
(	O
magic	array
[	O
1	int
]	O
==	O
0235	int
)	O
)	O
||	O
(	O
(	O
magic	array
[	O
0	int
]	O
==	O
0120	int
)	O
&&	O
(	O
magic	array
[	O
1	int
]	O
==	O
0113	int
)	O
&&	O
(	O
magic	array
[	O
2	int
]	O
==	O
0003	int
)	O
&&	O
(	O
magic	array
[	O
3	int
]	O
==	O
0004	int
)	O
)	O
)	O
{	O
*	O
compressed	pointer
=	O
COMPRESSED_OTHER	int
;	O
}	O
else	O
if	O
(	O
(	O
magic	array
[	O
0	int
]	O
==	O
'B'	O
)	O
&&	O
(	O
magic	array
[	O
1	int
]	O
==	O
'Z'	O
)	O
)	O
{	O
*	O
compressed	pointer
=	O
COMPRESSED_BZIP2	int
;	O
}	O
return	O
rc	int
;	O
}	O
char	O
*	O
rpmExpand	function
(	O
const	O
char	O
*	O
arg	pointer
,	O
...	O
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
,	O
*	O
p	pointer
,	O
*	O
pe	pointer
;	O
const	O
char	O
*	O
s	pointer
;	O
va_list	array
ap	pointer
;	O
if	O
(	O
arg	pointer
==	O
NULL	O
)	O
return	O
xstrdup	function
(	O
""	pointer
)	O
;	O
p	pointer
=	O
buf	pointer
;	O
pe	pointer
=	O
rpm_stpcpy	function
(	O
p	pointer
,	O
arg	pointer
)	O
;	O
va_start	O
(	O
ap	pointer
,	O
arg	pointer
)	O
;	O
while	O
(	O
(	O
s	pointer
=	O
va_arg	O
(	O
ap	pointer
,	O
const	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
pe	pointer
=	O
rpm_stpcpy	function
(	O
pe	pointer
,	O
s	pointer
)	O
;	O
va_end	O
(	O
ap	pointer
)	O
;	O
expandMacros	function
(	O
NULL	O
,	O
NULL	O
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
return	O
xstrdup	function
(	O
buf	pointer
)	O
;	O
}	O
int	O
rpmExpandNumeric	function
(	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
const	O
char	O
*	O
val	array
;	O
int	O
rc	int
;	O
if	O
(	O
arg	pointer
==	O
NULL	O
)	O
return	O
0	int
;	O
val	array
=	O
rpmExpand	function
(	O
arg	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
(	O
val	array
&&	O
*	O
val	array
!=	O
'%'	O
)	O
)	O
rc	int
=	O
0	int
;	O
else	O
if	O
(	O
*	O
val	array
==	O
'Y'	O
||	O
*	O
val	array
==	O
'y'	O
)	O
rc	int
=	O
1	int
;	O
else	O
if	O
(	O
*	O
val	array
==	O
'N'	O
||	O
*	O
val	array
==	O
'n'	O
)	O
rc	int
=	O
0	int
;	O
else	O
{	O
char	O
*	O
end	pointer
;	O
rc	int
=	O
strtol	function
(	O
val	array
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
(	O
end	pointer
&&	O
*	O
end	pointer
==	O
'\0'	O
)	O
)	O
rc	int
=	O
0	int
;	O
}	O
xfree	O
(	O
val	array
)	O
;	O
return	O
rc	int
;	O
}	O
char	O
*	O
rpmCleanPath	function
(	O
char	O
*	O
path	pointer
)	O
{	O
const	O
char	O
*	O
s	pointer
;	O
char	O
*	O
se	pointer
,	O
*	O
t	pointer
,	O
*	O
te	pointer
;	O
s	pointer
=	O
t	pointer
=	O
te	pointer
=	O
path	pointer
;	O
while	O
(	O
*	O
s	pointer
)	O
{	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
':'	O
:	O
if	O
(	O
s	pointer
[	O
1	int
]	O
==	O
'/'	O
&&	O
s	pointer
[	O
2	int
]	O
==	O
'/'	O
)	O
{	O
*	O
t	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
*	O
t	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
}	O
break	O
;	O
case	O
'/'	O
:	O
for	O
(	O
se	pointer
=	O
te	pointer
+	O
1	int
;	O
se	pointer
<	O
t	pointer
&&	O
*	O
se	pointer
!=	O
'/'	O
;	O
se	pointer
++	O
)	O
;	O
if	O
(	O
se	pointer
<	O
t	pointer
&&	O
*	O
se	pointer
==	O
'/'	O
)	O
{	O
te	pointer
=	O
se	pointer
;	O
}	O
while	O
(	O
s	pointer
[	O
1	int
]	O
==	O
'/'	O
)	O
s	pointer
++	O
;	O
while	O
(	O
t	pointer
>	O
path	pointer
&&	O
t	pointer
[	O
-	O
1	int
]	O
==	O
'/'	O
)	O
t	pointer
--	O
;	O
break	O
;	O
case	O
'.'	O
:	O
if	O
(	O
t	pointer
==	O
path	pointer
&&	O
s	pointer
[	O
1	int
]	O
==	O
'.'	O
)	O
{	O
*	O
t	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
break	O
;	O
}	O
if	O
(	O
t	pointer
==	O
path	pointer
&&	O
s	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
break	O
;	O
}	O
if	O
(	O
(	O
t	pointer
==	O
path	pointer
||	O
t	pointer
[	O
-	O
1	int
]	O
==	O
'/'	O
)	O
&&	O
(	O
s	pointer
[	O
1	int
]	O
==	O
'/'	O
||	O
s	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
)	O
{	O
s	pointer
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
t	pointer
>	O
path	pointer
&&	O
t	pointer
[	O
-	O
1	int
]	O
==	O
'/'	O
&&	O
s	pointer
[	O
1	int
]	O
==	O
'.'	O
&&	O
(	O
s	pointer
[	O
2	int
]	O
==	O
'/'	O
||	O
s	pointer
[	O
2	int
]	O
==	O
'\0'	O
)	O
)	O
{	O
t	pointer
=	O
te	pointer
;	O
if	O
(	O
te	pointer
>	O
path	pointer
)	O
for	O
(	O
--	O
te	pointer
;	O
te	pointer
>	O
path	pointer
&&	O
*	O
te	pointer
!=	O
'/'	O
;	O
te	pointer
--	O
)	O
;	O
s	pointer
++	O
;	O
s	pointer
++	O
;	O
continue	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
*	O
t	pointer
++	O
=	O
*	O
s	pointer
++	O
;	O
}	O
if	O
(	O
t	pointer
>	O
&	O
path	pointer
[	O
1	int
]	O
&&	O
t	pointer
[	O
-	O
1	int
]	O
==	O
'/'	O
)	O
t	pointer
--	O
;	O
*	O
t	pointer
=	O
'\0'	O
;	O
return	O
path	pointer
;	O
}	O
const	O
char	O
*	O
rpmGetPath	function
(	O
const	O
char	O
*	O
path	pointer
,	O
...	O
)	O
{	O
char	O
buf	pointer
[	O
BUFSIZ	int
]	O
;	O
const	O
char	O
*	O
s	pointer
;	O
char	O
*	O
t	pointer
,	O
*	O
te	pointer
;	O
va_list	array
ap	pointer
;	O
if	O
(	O
path	pointer
==	O
NULL	O
)	O
return	O
xstrdup	function
(	O
""	pointer
)	O
;	O
t	pointer
=	O
buf	pointer
;	O
te	pointer
=	O
rpm_stpcpy	function
(	O
t	pointer
,	O
path	pointer
)	O
;	O
*	O
te	pointer
=	O
'\0'	O
;	O
va_start	O
(	O
ap	pointer
,	O
path	pointer
)	O
;	O
while	O
(	O
(	O
s	pointer
=	O
va_arg	O
(	O
ap	pointer
,	O
const	O
char	O
*	O
)	O
)	O
!=	O
NULL	O
)	O
{	O
te	pointer
=	O
rpm_stpcpy	function
(	O
te	pointer
,	O
s	pointer
)	O
;	O
*	O
te	pointer
=	O
'\0'	O
;	O
}	O
va_end	O
(	O
ap	pointer
)	O
;	O
expandMacros	function
(	O
NULL	O
,	O
NULL	O
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
return	O
xstrdup	function
(	O
rpmCleanPath	function
(	O
buf	pointer
)	O
)	O
;	O
}	O
const	O
char	O
*	O
rpmGenPath	function
(	O
const	O
char	O
*	O
urlroot	pointer
,	O
const	O
char	O
*	O
urlmdir	pointer
,	O
const	O
char	O
*	O
urlfile	pointer
)	O
{	O
const	O
char	O
*	O
xroot	pointer
=	O
rpmGetPath	function
(	O
urlroot	pointer
,	O
NULL	O
)	O
,	O
*	O
root	pointer
=	O
xroot	pointer
;	O
const	O
char	O
*	O
xmdir	pointer
=	O
rpmGetPath	function
(	O
urlmdir	pointer
,	O
NULL	O
)	O
,	O
*	O
mdir	pointer
=	O
xmdir	pointer
;	O
const	O
char	O
*	O
xfile	pointer
=	O
rpmGetPath	function
(	O
urlfile	pointer
,	O
NULL	O
)	O
,	O
*	O
file	pointer
=	O
xfile	pointer
;	O
const	O
char	O
*	O
result	pointer
;	O
const	O
char	O
*	O
url	pointer
=	O
NULL	O
;	O
int	O
nurl	int
=	O
0	int
;	O
int	O
ut	int
;	O
if	O
(	O
_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** RGP xroot %s xmdir %s xfile %s\n"	pointer
,	O
xroot	pointer
,	O
xmdir	pointer
,	O
xfile	pointer
)	O
;	O
ut	int
=	O
urlPath	function
(	O
xroot	pointer
,	O
&	O
root	pointer
)	O
;	O
if	O
(	O
url	pointer
==	O
NULL	O
&&	O
ut	int
>	O
URL_IS_DASH	int
)	O
{	O
url	pointer
=	O
xroot	pointer
;	O
nurl	int
=	O
root	pointer
-	O
xroot	pointer
;	O
if	O
(	O
_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** RGP ut %d root %s nurl %d\n"	pointer
,	O
ut	int
,	O
root	pointer
,	O
nurl	int
)	O
;	O
}	O
if	O
(	O
root	pointer
==	O
NULL	O
||	O
*	O
root	pointer
==	O
'\0'	O
)	O
root	pointer
=	O
"/"	pointer
;	O
ut	int
=	O
urlPath	function
(	O
xmdir	pointer
,	O
&	O
mdir	pointer
)	O
;	O
if	O
(	O
url	pointer
==	O
NULL	O
&&	O
ut	int
>	O
URL_IS_DASH	int
)	O
{	O
url	pointer
=	O
xmdir	pointer
;	O
nurl	int
=	O
mdir	pointer
-	O
xmdir	pointer
;	O
if	O
(	O
_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** RGP ut %d mdir %s nurl %d\n"	pointer
,	O
ut	int
,	O
mdir	pointer
,	O
nurl	int
)	O
;	O
}	O
if	O
(	O
mdir	pointer
==	O
NULL	O
||	O
*	O
mdir	pointer
==	O
'\0'	O
)	O
mdir	pointer
=	O
"/"	pointer
;	O
ut	int
=	O
urlPath	function
(	O
xfile	pointer
,	O
&	O
file	pointer
)	O
;	O
if	O
(	O
url	pointer
==	O
NULL	O
&&	O
ut	int
>	O
URL_IS_DASH	int
)	O
{	O
url	pointer
=	O
xfile	pointer
;	O
nurl	int
=	O
file	pointer
-	O
xfile	pointer
;	O
if	O
(	O
_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** RGP ut %d file %s nurl %d\n"	pointer
,	O
ut	int
,	O
file	pointer
,	O
nurl	int
)	O
;	O
}	O
if	O
(	O
url	pointer
&&	O
nurl	int
>	O
0	int
)	O
{	O
char	O
*	O
t	pointer
=	O
strncpy	function
(	O
alloca	function
(	O
nurl	int
+	O
1	int
)	O
,	O
url	pointer
,	O
nurl	int
)	O
;	O
t	pointer
[	O
nurl	int
]	O
=	O
'\0'	O
;	O
url	pointer
=	O
t	pointer
;	O
}	O
else	O
url	pointer
=	O
""	pointer
;	O
result	pointer
=	O
rpmGetPath	function
(	O
url	pointer
,	O
root	pointer
,	O
"/"	pointer
,	O
mdir	pointer
,	O
"/"	pointer
,	O
file	pointer
,	O
NULL	O
)	O
;	O
xfree	O
(	O
xroot	pointer
)	O
;	O
xfree	O
(	O
xmdir	pointer
)	O
;	O
xfree	O
(	O
xfile	pointer
)	O
;	O
if	O
(	O
_debug	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"*** RGP result %s\n"	pointer
,	O
result	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
