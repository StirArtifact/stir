char	O
*	O
copyright	pointer
=	O
"GIT is free software; you can redistribute it and/or modify it under the\nterms of the GNU General Public License as published by the Free Software\nFoundation; either version 3, or (at your option) any later version.\nCopyright (C) 1993-2001, 2007-2008 Free Software Foundation, Inc.\nWritten by Tudor Hulubei and Andrei Pitis, Bucharest, Romania\n\n"	pointer
;	O
extern	O
int	O
LinuxConsole	int
;	O
int	O
AnsiColors	int
=	O
ON	int
;	O
int	O
TypeSensitivity	int
=	O
ON	int
;	O
char	O
*	O
g_home	pointer
;	O
char	O
*	O
g_program	pointer
;	O
char	O
*	O
program_name	pointer
;	O
char	O
*	O
version	pointer
=	O
VERSION	pointer
;	O
int	O
two_panel_mode	int
=	O
1	int
;	O
int	O
current_mode	int
=	O
GIT_SCREEN_MODE	int
;	O
int	O
panel_no	int
;	O
int	O
wait_msg	int
;	O
int	O
UseLastScreenChar	int
;	O
char	O
color_section	array
[	O
]	O
=	O
"[GITFM-Color]"	pointer
;	O
char	O
monochrome_section	array
[	O
]	O
=	O
"[GITFM-Monochrome]"	pointer
;	O
char	O
lock_bad	array
[	O
]	O
=	O
"Bad password, try again..."	pointer
;	O
char	O
*	O
exit_msg	pointer
;	O
char	O
*	O
screen	pointer
;	O
char	O
PS1	array
[	O
4	int
]	O
=	O
" $ "	pointer
;	O
panel_t	struct
*	O
left_panel	pointer
,	O
*	O
right_panel	pointer
,	O
*	O
src_panel	pointer
,	O
*	O
dst_panel	pointer
,	O
*	O
tmp_panel	pointer
;	O
static	O
char	O
*	O
NormalModeHelp	pointer
=	O
""	pointer
;	O
static	O
char	O
*	O
CommandLineModeHelp	pointer
=	O
""	pointer
;	O
static	O
int	O
ConfirmOnExit	int
;	O
char	O
*	O
*	O
dir_history	pointer
;	O
int	O
dir_history_count	int
;	O
int	O
dir_history_point	int
;	O
char	O
builtin	array
[	O
BUILTIN_OPERATIONS	int
]	O
[	O
MAX_BUILTIN_NAME	int
]	O
=	O
{	O
"copy"	pointer
,	O
"move"	pointer
,	O
"make-directory"	pointer
,	O
"delete"	pointer
,	O
"exit"	pointer
,	O
"previous-history-element"	pointer
,	O
"tty-mode"	pointer
,	O
"refresh"	pointer
,	O
"switch-panels"	pointer
,	O
"next-history-element"	pointer
,	O
"panel-enable-next-mode"	pointer
,	O
"panel-enable-owner-group"	pointer
,	O
"panel-enable-date-time"	pointer
,	O
"panel-enable-size"	pointer
,	O
"panel-enable-abbrevsize"	pointer
,	O
"panel-enable-mode"	pointer
,	O
"panel-enable-full-name"	pointer
,	O
"panel-sort-next-method"	pointer
,	O
"panel-sort-by-name"	pointer
,	O
"panel-sort-by-extension"	pointer
,	O
"panel-sort-by-size"	pointer
,	O
"panel-sort-by-date"	pointer
,	O
"panel-sort-by-mode"	pointer
,	O
"panel-sort-by-owner-id"	pointer
,	O
"panel-sort-by-group-id"	pointer
,	O
"panel-sort-by-owner-name"	pointer
,	O
"panel-sort-by-group-name"	pointer
,	O
"select-entry"	pointer
,	O
"entry-to-input-line"	pointer
,	O
"beginning-of-panel"	pointer
,	O
"end-of-panel"	pointer
,	O
"scroll-down"	pointer
,	O
"scroll-up"	pointer
,	O
"previous-line"	pointer
,	O
"next-line"	pointer
,	O
"other-panel"	pointer
,	O
"change-directory"	pointer
,	O
"select-files-matching-pattern"	pointer
,	O
"unselect-files-matching-pattern"	pointer
,	O
"adapt-current-directory"	pointer
,	O
"adapt-other-directory"	pointer
,	O
"other-path-to-input-line"	pointer
,	O
"selected-entries-to-input-line"	pointer
,	O
"backward-char"	pointer
,	O
"forward-char"	pointer
,	O
"backward-word"	pointer
,	O
"forward-word"	pointer
,	O
"beginning-of-line"	pointer
,	O
"end-of-line"	pointer
,	O
"delete-char"	pointer
,	O
"backward-delete-char"	pointer
,	O
"kill-word"	pointer
,	O
"backward-kill-word"	pointer
,	O
"kill-line"	pointer
,	O
"kill-to-beginning-of-line"	pointer
,	O
"kill-to-end-of-line"	pointer
,	O
"just-one-space"	pointer
,	O
"delete-horizontal-space"	pointer
,	O
"downcase-word"	pointer
,	O
"upcase-word"	pointer
,	O
"capitalize-word"	pointer
,	O
"action"	pointer
,	O
"set-mark"	pointer
,	O
"kill-region"	pointer
,	O
"kill-ring-save"	pointer
,	O
"yank"	pointer
,	O
"exchange-point-and-mark"	pointer
,	O
"set-scroll-step"	pointer
,	O
"isearch-backward"	pointer
,	O
"isearch-forward"	pointer
,	O
"previous-directory"	pointer
,	O
"next-directory"	pointer
,	O
"reset-directory-history"	pointer
,	O
"enlarge-panel"	pointer
,	O
"enlarge-other-panel"	pointer
,	O
"two-panels"	pointer
,	O
"lock"	pointer
,	O
"quick-compare-panels"	pointer
,	O
"thorough-compare-panels"	pointer
,	O
"name-downcase"	pointer
,	O
"name-upcase"	pointer
,	O
"up-one-dir"	pointer
,	O
"compare"	pointer
,	O
"bin-packing"	pointer
,	O
"horizontal-scroll-left"	pointer
,	O
"horizontal-scroll-right"	pointer
,	O
"select-extension"	pointer
,	O
"unselect-extension"	pointer
,	O
"apropos"	pointer
,	O
}	O
;	O
typedef	O
struct	O
{	O
char	O
*	O
name	pointer
;	O
char	O
*	O
body	pointer
;	O
char	O
*	O
new_dir	pointer
;	O
char	O
save_screen	char
;	O
char	O
pause	function
;	O
char	O
hide	char
;	O
char	O
builtin	array
;	O
char	O
*	O
sequence	pointer
;	O
xstack_t	struct
*	O
history	pointer
;	O
}	O
command_t	struct
;	O
int	O
panels_can_be_displayed	function
(	O
)	O
{	O
if	O
(	O
tty_lines	int
>=	O
7	int
)	O
{	O
if	O
(	O
two_panel_mode	int
)	O
{	O
if	O
(	O
tty_columns	int
>=	O
6	int
*	O
2	int
)	O
return	O
ON	int
;	O
}	O
else	O
if	O
(	O
tty_columns	int
>=	O
6	int
)	O
return	O
ON	int
;	O
}	O
return	O
OFF	int
;	O
}	O
int	O
in_terminal_mode	function
(	O
)	O
{	O
return	O
(	O
current_mode	int
==	O
GIT_TERMINAL_MODE	int
)	O
;	O
}	O
void	O
resize	function
(	O
resize_required	int
)	O
int	O
resize_required	int
;	O
{	O
int	O
display_title	int
=	O
OFF	int
;	O
int	O
display_status	int
=	O
OFF	int
;	O
int	O
old_tty_lines	int
=	O
tty_lines	int
;	O
int	O
old_tty_columns	int
=	O
tty_columns	int
;	O
tty_resize	function
(	O
)	O
;	O
if	O
(	O
!	O
resize_required	int
)	O
if	O
(	O
tty_lines	int
==	O
old_tty_lines	int
&&	O
tty_columns	int
==	O
old_tty_columns	int
)	O
return	O
;	O
if	O
(	O
LinuxConsole	int
)	O
screen	pointer
=	O
xrealloc	function
(	O
screen	pointer
,	O
4	int
+	O
tty_columns	int
*	O
tty_lines	int
*	O
2	int
)	O
;	O
if	O
(	O
tty_lines	int
>=	O
2	int
)	O
display_status	int
=	O
ON	int
;	O
if	O
(	O
tty_lines	int
>=	O
3	int
)	O
display_title	int
=	O
ON	int
;	O
if	O
(	O
panels_can_be_displayed	function
(	O
)	O
)	O
{	O
if	O
(	O
two_panel_mode	int
)	O
{	O
int	O
right_panel_columns	int
=	O
(	O
tty_columns	int
>>	O
1	int
)	O
;	O
int	O
left_panel_columns	int
=	O
right_panel_columns	int
+	O
(	O
tty_columns	int
&	O
1	int
)	O
;	O
if	O
(	O
window_x	function
(	O
panel_window	function
(	O
src_panel	pointer
)	O
)	O
<=	O
window_x	function
(	O
panel_window	function
(	O
dst_panel	pointer
)	O
)	O
)	O
{	O
panel_resize	function
(	O
src_panel	pointer
,	O
0	int
,	O
1	int
,	O
tty_lines	int
-	O
3	int
,	O
left_panel_columns	int
)	O
;	O
panel_resize	function
(	O
dst_panel	pointer
,	O
left_panel_columns	int
,	O
1	int
,	O
tty_lines	int
-	O
3	int
,	O
right_panel_columns	int
)	O
;	O
}	O
else	O
{	O
panel_resize	function
(	O
src_panel	pointer
,	O
left_panel_columns	int
,	O
1	int
,	O
tty_lines	int
-	O
3	int
,	O
right_panel_columns	int
)	O
;	O
panel_resize	function
(	O
dst_panel	pointer
,	O
0	int
,	O
1	int
,	O
tty_lines	int
-	O
3	int
,	O
left_panel_columns	int
)	O
;	O
}	O
}	O
else	O
{	O
panel_resize	function
(	O
src_panel	pointer
,	O
0	int
,	O
1	int
,	O
tty_lines	int
-	O
3	int
,	O
tty_columns	int
)	O
;	O
panel_resize	function
(	O
dst_panel	pointer
,	O
0	int
,	O
1	int
,	O
tty_lines	int
-	O
3	int
,	O
tty_columns	int
)	O
;	O
}	O
}	O
else	O
{	O
panel_resize	function
(	O
src_panel	pointer
,	O
0x10000	int
,	O
0x10000	int
,	O
2	int
,	O
80	int
)	O
;	O
panel_resize	function
(	O
dst_panel	pointer
,	O
0x10000	int
,	O
0x10000	int
,	O
2	int
,	O
80	int
)	O
;	O
}	O
title_resize	function
(	O
display_title	int
?	O
tty_columns	int
:	O
0	int
,	O
0	int
)	O
;	O
status_resize	function
(	O
display_status	int
?	O
tty_columns	int
:	O
0	int
,	O
tty_lines	int
-	O
1	int
)	O
;	O
il_resize	function
(	O
tty_columns	int
,	O
(	O
tty_lines	int
==	O
1	int
)	O
?	O
0	int
:	O
(	O
tty_lines	int
-	O
2	int
)	O
)	O
;	O
}	O
void	O
refresh	function
(	O
signum	int
)	O
int	O
signum	int
;	O
{	O
resize	function
(	O
0	int
)	O
;	O
if	O
(	O
signum	int
==	O
SIGCONT	int
)	O
{	O
tty_set_mode	function
(	O
TTY_NONCANONIC	int
)	O
;	O
tty_defaults	function
(	O
)	O
;	O
}	O
if	O
(	O
wait_msg	int
)	O
return	O
;	O
panel_no_optimizations	function
(	O
src_panel	pointer
)	O
;	O
panel_no_optimizations	function
(	O
dst_panel	pointer
)	O
;	O
panel_center_current_entry	function
(	O
src_panel	pointer
)	O
;	O
panel_center_current_entry	function
(	O
dst_panel	pointer
)	O
;	O
if	O
(	O
current_mode	int
==	O
GIT_SCREEN_MODE	int
)	O
{	O
if	O
(	O
!	O
panels_can_be_displayed	function
(	O
)	O
)	O
{	O
tty_defaults	function
(	O
)	O
;	O
tty_clear	function
(	O
)	O
;	O
}	O
title_update	function
(	O
)	O
;	O
panel_update	function
(	O
src_panel	pointer
)	O
;	O
if	O
(	O
two_panel_mode	int
)	O
panel_update	function
(	O
dst_panel	pointer
)	O
;	O
}	O
else	O
tty_put_screen	function
(	O
screen	pointer
)	O
;	O
status_update	function
(	O
)	O
;	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
signum	int
==	O
SIGCONT	int
)	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
}	O
void	O
report_undefined_key	function
(	O
status_message	pointer
)	O
char	O
*	O
status_message	pointer
;	O
{	O
char	O
*	O
prev	pointer
=	O
tty_get_previous_key_seq	function
(	O
)	O
;	O
size_t	long
length	long
=	O
strlen	function
(	O
prev	pointer
)	O
;	O
if	O
(	O
length	long
&&	O
(	O
prev	pointer
[	O
length	long
-	O
1	int
]	O
!=	O
key_INTERRUPT	O
)	O
)	O
{	O
char	O
*	O
str	pointer
=	O
(	O
char	O
*	O
)	O
tty_key_machine2human	function
(	O
prev	pointer
)	O
;	O
char	O
*	O
buf	pointer
=	O
xmalloc	function
(	O
128	int
+	O
strlen	function
(	O
str	pointer
)	O
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%s: not defined."	pointer
,	O
str	pointer
)	O
;	O
status	function
(	O
buf	pointer
,	O
STATUS_ERROR	int
,	O
STATUS_LEFT	int
)	O
;	O
xfree	function
(	O
buf	pointer
)	O
;	O
tty_beep	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
}	O
else	O
tty_beep	function
(	O
)	O
;	O
if	O
(	O
status_message	pointer
)	O
status	function
(	O
status_message	pointer
,	O
STATUS_OK	int
,	O
STATUS_CENTERED	int
)	O
;	O
else	O
status_default	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
extern	O
int	O
il_dispatch_commands	function
PROTO	O
(	O
(	O
int	O
,	O
int	O
)	O
)	O
;	O
extern	O
char	O
*	O
il_fix_text	function
PROTO	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
extern	O
char	O
*	O
il_build_help_from_string	function
PROTO	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
extern	O
char	O
*	O
il_isearch	function
PROTO	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
*	O
,	O
int	O
,	O
int	O
*	O
)	O
)	O
;	O
extern	O
char	O
il_read_char	function
PROTO	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
extern	O
char	O
*	O
il_read_line	function
PROTO	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
*	O
,	O
char	O
*	O
,	O
xstack_t	struct
*	O
)	O
)	O
;	O
void	O
il_history_add_entry	function
(	O
history	pointer
,	O
text	pointer
)	O
xstack_t	struct
*	O
history	pointer
;	O
char	O
*	O
text	pointer
;	O
{	O
char	O
*	O
history_text	pointer
;	O
if	O
(	O
xstack_preview	function
(	O
history	pointer
,	O
&	O
history_text	pointer
,	O
1	int
)	O
&&	O
strcmp	function
(	O
history_text	pointer
,	O
text	pointer
)	O
==	O
0	int
)	O
return	O
;	O
history_text	pointer
=	O
xstrdup	function
(	O
text	pointer
)	O
;	O
xstack_push	function
(	O
history	pointer
,	O
&	O
history_text	pointer
)	O
;	O
}	O
char	O
*	O
il_history_view_entry	function
(	O
history	pointer
,	O
offset	int
)	O
xstack_t	struct
*	O
history	pointer
;	O
int	O
offset	int
;	O
{	O
char	O
*	O
history_text	pointer
;	O
return	O
xstack_preview	function
(	O
history	pointer
,	O
&	O
history_text	pointer
,	O
offset	int
)	O
?	O
history_text	pointer
:	O
NULL	O
;	O
}	O
int	O
il_dispatch_commands	function
(	O
key	int
,	O
flags	int
)	O
int	O
key	int
;	O
int	O
flags	int
;	O
{	O
if	O
(	O
(	O
flags	int
&	O
IL_MOVE	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
BUILTIN_backward_char	O
:	O
il_backward_char	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_forward_char	O
:	O
il_forward_char	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_backward_word	O
:	O
il_backward_word	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_forward_word	O
:	O
il_forward_word	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_beginning_of_line	O
:	O
il_beginning_of_line	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_end_of_line	O
:	O
il_end_of_line	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_delete_char	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_delete_char	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_backward_delete_char	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_backward_delete_char	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_kill_word	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_kill_word	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_backward_kill_word	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_backward_kill_word	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_kill_line	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_kill_line	function
(	O
IL_STORE	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_kill_to_beginning_of_line	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_kill_to_beginning_of_line	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_kill_to_end_of_line	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_kill_to_end_of_line	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_just_one_space	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_just_one_space	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_delete_horizontal_space	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_delete_horizontal_space	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_downcase_word	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_downcase_word	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_upcase_word	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_upcase_word	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_capitalize_word	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_capitalize_word	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_set_mark	O
:	O
il_set_mark	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_kill_region	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_kill_region	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_kill_ring_save	O
:	O
il_kill_ring_save	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_yank	O
:	O
if	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
il_yank	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_exchange_point_and_mark	O
:	O
il_exchange_point_and_mark	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
flags	int
&	O
IL_EDIT	int
)	O
&&	O
isprint	function
(	O
key	int
)	O
)	O
il_insert_char	function
(	O
key	int
)	O
;	O
else	O
return	O
0	int
;	O
break	O
;	O
}	O
return	O
1	int
;	O
}	O
char	O
*	O
il_fix_text	function
(	O
text	pointer
)	O
char	O
*	O
text	pointer
;	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
*	O
fixed_text	pointer
;	O
size_t	long
fixed_text_length	long
;	O
if	O
(	O
text	pointer
==	O
NULL	O
)	O
return	O
NULL	O
;	O
fixed_text	pointer
=	O
xmalloc	function
(	O
fixed_text_length	long
=	O
(	O
strlen	function
(	O
text	pointer
)	O
+	O
1	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
0	int
;	O
text	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
if	O
(	O
text	pointer
[	O
i	int
]	O
==	O
'\t'	O
)	O
{	O
fixed_text	pointer
=	O
xrealloc	function
(	O
fixed_text	pointer
,	O
fixed_text_length	long
+=	O
8	int
)	O
;	O
memcpy	function
(	O
&	O
fixed_text	pointer
[	O
j	int
]	O
,	O
"        "	pointer
,	O
8	int
)	O
;	O
j	int
+=	O
8	int
;	O
}	O
else	O
if	O
(	O
isprint	function
(	O
(	O
int	O
)	O
text	pointer
[	O
i	int
]	O
)	O
)	O
fixed_text	pointer
[	O
j	int
++	O
]	O
=	O
text	pointer
[	O
i	int
]	O
;	O
else	O
fixed_text	pointer
[	O
j	int
++	O
]	O
=	O
'?'	O
;	O
fixed_text	pointer
[	O
j	int
]	O
=	O
0	int
;	O
return	O
fixed_text	pointer
;	O
}	O
char	O
*	O
il_build_help_from_string	function
(	O
options	pointer
)	O
char	O
*	O
options	pointer
;	O
{	O
size_t	long
len	long
=	O
0	int
;	O
char	O
*	O
options_ptr	pointer
=	O
options	pointer
;	O
char	O
*	O
help	pointer
=	O
xmalloc	function
(	O
1	int
+	O
strlen	function
(	O
options	pointer
)	O
*	O
3	int
+	O
8	int
)	O
;	O
help	pointer
[	O
len	long
++	O
]	O
=	O
'('	O
;	O
for	O
(	O
;	O
*	O
(	O
options_ptr	pointer
+	O
1	int
)	O
;	O
options_ptr	pointer
++	O
)	O
{	O
help	pointer
[	O
len	long
++	O
]	O
=	O
*	O
options_ptr	pointer
;	O
help	pointer
[	O
len	long
++	O
]	O
=	O
','	O
;	O
help	pointer
[	O
len	long
++	O
]	O
=	O
' '	O
;	O
}	O
help	pointer
[	O
len	long
++	O
]	O
=	O
*	O
options_ptr	pointer
;	O
help	pointer
[	O
len	long
++	O
]	O
=	O
')'	O
;	O
help	pointer
[	O
len	long
++	O
]	O
=	O
' '	O
;	O
help	pointer
[	O
len	long
++	O
]	O
=	O
'\0'	O
;	O
return	O
help	pointer
;	O
}	O
char	O
il_read_char	function
(	O
message	pointer
,	O
options	pointer
,	O
flags	int
)	O
char	O
*	O
message	pointer
;	O
char	O
*	O
options	pointer
;	O
int	O
flags	int
;	O
{	O
char	O
*	O
help	pointer
;	O
tty_key_t	struct
*	O
ks	pointer
;	O
int	O
key	int
,	O
repeat_count	int
;	O
command_t	struct
*	O
command	pointer
;	O
input_line_t	struct
*	O
saved_il	pointer
=	O
NULL	O
;	O
if	O
(	O
flags	int
&	O
IL_SAVE	int
)	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
il_reset_line	function
(	O
)	O
;	O
if	O
(	O
message	pointer
)	O
{	O
char	O
*	O
text	pointer
=	O
il_fix_text	function
(	O
message	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
IL_ERROR	int
)	O
{	O
il_insert_text	function
(	O
"*** "	pointer
)	O
;	O
il_set_error_flag	function
(	O
1	int
)	O
;	O
}	O
il_insert_text	function
(	O
text	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
IL_HOME	int
)	O
il_beginning_of_line	function
(	O
)	O
;	O
xfree	function
(	O
text	pointer
)	O
;	O
if	O
(	O
options	pointer
)	O
{	O
help	pointer
=	O
il_build_help_from_string	function
(	O
options	pointer
)	O
;	O
il_insert_text	function
(	O
help	pointer
)	O
;	O
xfree	function
(	O
help	pointer
)	O
;	O
}	O
}	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
flags	int
&	O
IL_BEEP	int
)	O
tty_beep	function
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
(	O
ks	pointer
=	O
tty_get_key	function
(	O
&	O
repeat_count	int
)	O
)	O
==	O
NULL	O
)	O
{	O
tty_beep	function
(	O
)	O
;	O
status_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
}	O
key	int
=	O
ks	pointer
->	O
key_seq	pointer
[	O
0	int
]	O
;	O
command	pointer
=	O
(	O
command_t	struct
*	O
)	O
ks	pointer
->	O
aux_data	pointer
;	O
if	O
(	O
command	pointer
&&	O
command	pointer
->	O
builtin	array
)	O
key	int
=	O
-	O
1	int
-	O
(	O
command	pointer
->	O
name	pointer
-	O
builtin	array
[	O
0	int
]	O
)	O
/	O
MAX_BUILTIN_NAME	int
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
BUILTIN_refresh	O
:	O
refresh	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_action	O
:	O
if	O
(	O
options	pointer
!=	O
NULL	O
)	O
key	int
=	O
*	O
options	pointer
;	O
case	O
key_INTERRUPT	O
:	O
goto	O
done	O
;	O
default	O
:	O
while	O
(	O
repeat_count	int
--	O
)	O
if	O
(	O
il_dispatch_commands	function
(	O
key	int
,	O
flags	int
)	O
==	O
0	int
)	O
goto	O
il_error	O
;	O
il_update	function
(	O
)	O
;	O
break	O
;	O
il_error	O
:	O
if	O
(	O
options	pointer
==	O
NULL	O
)	O
goto	O
done	O
;	O
if	O
(	O
options	pointer
&&	O
strchr	function
(	O
options	pointer
,	O
key	int
)	O
)	O
goto	O
done	O
;	O
tty_beep	function
(	O
)	O
;	O
break	O
;	O
}	O
status_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
done	O
:	O
il_set_error_flag	function
(	O
0	int
)	O
;	O
if	O
(	O
(	O
flags	int
&	O
IL_SAVE	int
)	O
&&	O
saved_il	pointer
)	O
{	O
il_restore	function
(	O
saved_il	pointer
)	O
;	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
return	O
(	O
key	int
==	O
key_INTERRUPT	O
)	O
?	O
0	int
:	O
key	int
;	O
}	O
char	O
*	O
il_read_line	function
(	O
static_text	pointer
,	O
dest	pointer
,	O
default_string	pointer
,	O
history	pointer
)	O
char	O
*	O
static_text	pointer
;	O
char	O
*	O
*	O
dest	pointer
;	O
char	O
*	O
default_string	pointer
;	O
xstack_t	struct
*	O
history	pointer
;	O
{	O
tty_key_t	struct
*	O
ks	pointer
;	O
char	O
*	O
history_text	pointer
;	O
command_t	struct
*	O
command	pointer
;	O
int	O
key	int
=	O
0	int
,	O
repeat_count	int
,	O
offset	int
=	O
0	int
;	O
il_reset_line	function
(	O
)	O
;	O
if	O
(	O
static_text	pointer
)	O
il_set_static_text	function
(	O
static_text	pointer
)	O
;	O
if	O
(	O
default_string	pointer
)	O
il_insert_text	function
(	O
default_string	pointer
)	O
;	O
if	O
(	O
history	pointer
&&	O
default_string	pointer
)	O
{	O
il_history_add_entry	function
(	O
history	pointer
,	O
default_string	pointer
)	O
;	O
offset	int
=	O
1	int
;	O
}	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
(	O
ks	pointer
=	O
tty_get_key	function
(	O
&	O
repeat_count	int
)	O
)	O
==	O
NULL	O
)	O
{	O
tty_beep	function
(	O
)	O
;	O
status_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
}	O
key	int
=	O
ks	pointer
->	O
key_seq	pointer
[	O
0	int
]	O
;	O
command	pointer
=	O
(	O
command_t	struct
*	O
)	O
ks	pointer
->	O
aux_data	pointer
;	O
if	O
(	O
command	pointer
&&	O
command	pointer
->	O
builtin	array
)	O
key	int
=	O
-	O
1	int
-	O
(	O
command	pointer
->	O
name	pointer
-	O
builtin	array
[	O
0	int
]	O
)	O
/	O
MAX_BUILTIN_NAME	int
;	O
switch	O
(	O
key	int
)	O
{	O
case	O
BUILTIN_previous_line	O
:	O
case	O
BUILTIN_previous_history_element	O
:	O
if	O
(	O
history	pointer
==	O
NULL	O
)	O
break	O
;	O
history_text	pointer
=	O
il_history_view_entry	function
(	O
history	pointer
,	O
++	O
offset	int
)	O
;	O
if	O
(	O
history_text	pointer
==	O
NULL	O
)	O
{	O
offset	int
--	O
;	O
tty_beep	function
(	O
)	O
;	O
}	O
else	O
{	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
il_insert_text	function
(	O
history_text	pointer
)	O
;	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_next_line	O
:	O
case	O
BUILTIN_next_history_element	O
:	O
if	O
(	O
history	pointer
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
offset	int
==	O
0	int
)	O
{	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
break	O
;	O
}	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
offset	int
--	O
;	O
if	O
(	O
offset	int
>	O
0	int
)	O
{	O
history_text	pointer
=	O
il_history_view_entry	function
(	O
history	pointer
,	O
offset	int
)	O
;	O
il_insert_text	function
(	O
history_text	pointer
)	O
;	O
}	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_refresh	O
:	O
refresh	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_action	O
:	O
il_get_contents	function
(	O
dest	pointer
)	O
;	O
case	O
key_INTERRUPT	O
:	O
goto	O
done	O
;	O
default	O
:	O
while	O
(	O
repeat_count	int
--	O
)	O
if	O
(	O
il_dispatch_commands	function
(	O
key	int
,	O
IL_MOVE	int
|	O
IL_EDIT	int
)	O
==	O
0	int
)	O
tty_beep	function
(	O
)	O
;	O
il_update	function
(	O
)	O
;	O
break	O
;	O
}	O
status_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
done	O
:	O
if	O
(	O
key	int
==	O
BUILTIN_action	O
)	O
{	O
if	O
(	O
history	pointer
)	O
il_history_add_entry	function
(	O
history	pointer
,	O
*	O
dest	pointer
)	O
;	O
return	O
*	O
dest	pointer
;	O
}	O
else	O
return	O
NULL	O
;	O
}	O
char	O
*	O
il_isearch	function
(	O
static_text	pointer
,	O
dest	pointer
,	O
status	function
,	O
action	int
)	O
char	O
*	O
static_text	pointer
;	O
char	O
*	O
*	O
dest	pointer
;	O
int	O
status	function
;	O
int	O
*	O
action	int
;	O
{	O
int	O
key	int
;	O
int	O
keycmd	int
;	O
tty_key_t	struct
*	O
ks	pointer
;	O
command_t	struct
*	O
command	pointer
;	O
static	O
input_line_t	struct
*	O
saved_il	pointer
;	O
if	O
(	O
status	function
==	O
IL_ISEARCH_BEGIN	int
)	O
{	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
il_reset_line	function
(	O
)	O
;	O
if	O
(	O
static_text	pointer
)	O
il_set_static_text	function
(	O
static_text	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
status	function
==	O
IL_ISEARCH_END	int
)	O
{	O
il_restore	function
(	O
saved_il	pointer
)	O
;	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
action	int
==	O
NULL	O
)	O
return	O
NULL	O
;	O
*	O
action	int
=	O
IL_ISEARCH_ACTION_NONE	int
;	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
restart	O
:	O
if	O
(	O
(	O
ks	pointer
=	O
tty_get_key	function
(	O
NULL	O
)	O
)	O
==	O
NULL	O
)	O
{	O
status_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
return	O
NULL	O
;	O
}	O
keycmd	int
=	O
key	int
=	O
ks	pointer
->	O
key_seq	pointer
[	O
0	int
]	O
;	O
command	pointer
=	O
(	O
command_t	struct
*	O
)	O
ks	pointer
->	O
aux_data	pointer
;	O
if	O
(	O
command	pointer
&&	O
command	pointer
->	O
builtin	array
)	O
keycmd	int
=	O
-	O
1	int
-	O
(	O
command	pointer
->	O
name	pointer
-	O
builtin	array
[	O
0	int
]	O
)	O
/	O
MAX_BUILTIN_NAME	int
;	O
switch	O
(	O
keycmd	int
)	O
{	O
case	O
key_INTERRUPT	O
:	O
case	O
BUILTIN_action	O
:	O
break	O
;	O
case	O
BUILTIN_refresh	O
:	O
refresh	function
(	O
0	int
)	O
;	O
goto	O
restart	O
;	O
case	O
BUILTIN_backward_delete_char	O
:	O
if	O
(	O
il_is_empty	function
(	O
)	O
)	O
tty_beep	function
(	O
)	O
;	O
else	O
{	O
*	O
action	int
=	O
IL_ISEARCH_ACTION_DECREASE	int
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
keycmd	int
==	O
BUILTIN_isearch_backward	O
&&	O
status	function
==	O
IL_ISEARCH_BACKWARD	int
)	O
||	O
(	O
keycmd	int
==	O
BUILTIN_isearch_forward	O
&&	O
status	function
==	O
IL_ISEARCH_FORWARD	int
)	O
)	O
{	O
if	O
(	O
il_is_empty	function
(	O
)	O
)	O
*	O
action	int
=	O
IL_ISEARCH_ACTION_INCREASE	int
;	O
else	O
*	O
action	int
=	O
IL_ISEARCH_ACTION_RETRY	int
;	O
break	O
;	O
}	O
if	O
(	O
isprint	function
(	O
key	int
)	O
)	O
{	O
il_insert_char	function
(	O
key	int
)	O
;	O
*	O
action	int
=	O
IL_ISEARCH_ACTION_INCREASE	int
;	O
}	O
else	O
{	O
keycmd	int
=	O
key_INTERRUPT	O
;	O
}	O
break	O
;	O
}	O
status_update	function
(	O
)	O
;	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
il_get_contents	function
(	O
dest	pointer
)	O
;	O
return	O
(	O
keycmd	int
==	O
BUILTIN_action	O
||	O
keycmd	int
==	O
key_INTERRUPT	O
)	O
?	O
NULL	O
:	O
*	O
dest	pointer
;	O
}	O
void	O
dir_history_reset	function
(	O
)	O
{	O
if	O
(	O
dir_history	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dir_history_count	int
;	O
i	int
++	O
)	O
xfree	function
(	O
dir_history	pointer
[	O
i	int
]	O
)	O
;	O
xfree	function
(	O
dir_history	pointer
)	O
;	O
dir_history	pointer
=	O
NULL	O
;	O
}	O
dir_history_count	int
=	O
0	int
;	O
dir_history_point	int
=	O
0	int
;	O
}	O
void	O
dir_history_add	function
(	O
directory	pointer
)	O
char	O
*	O
directory	pointer
;	O
{	O
dir_history_point	int
=	O
dir_history_count	int
;	O
dir_history	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	function
(	O
dir_history	pointer
,	O
++	O
dir_history_count	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
dir_history	pointer
[	O
dir_history_point	int
]	O
=	O
xstrdup	function
(	O
directory	pointer
)	O
;	O
}	O
void	O
dir_history_next	function
(	O
this	pointer
,	O
link	function
)	O
panel_t	struct
*	O
this	pointer
;	O
panel_t	struct
*	O
link	function
;	O
{	O
if	O
(	O
dir_history_point	int
<	O
dir_history_count	int
-	O
1	int
)	O
panel_action	function
(	O
this	pointer
,	O
act_CHDIR	int
,	O
link	function
,	O
dir_history	pointer
[	O
++	O
dir_history_point	int
]	O
,	O
1	int
)	O
;	O
else	O
tty_beep	function
(	O
)	O
;	O
}	O
void	O
dir_history_prev	function
(	O
this	pointer
,	O
link	function
)	O
panel_t	struct
*	O
this	pointer
;	O
panel_t	struct
*	O
link	function
;	O
{	O
if	O
(	O
dir_history_point	int
)	O
panel_action	function
(	O
this	pointer
,	O
act_CHDIR	int
,	O
link	function
,	O
dir_history	pointer
[	O
--	O
dir_history_point	int
]	O
,	O
1	int
)	O
;	O
else	O
tty_beep	function
(	O
)	O
;	O
}	O
void	O
clean_up	function
(	O
)	O
{	O
tty_end	function
(	O
NULL	O
)	O
;	O
status_end	function
(	O
)	O
;	O
remove_log	function
(	O
)	O
;	O
}	O
void	O
fatal	function
(	O
postmsg	pointer
)	O
char	O
*	O
postmsg	pointer
;	O
{	O
if	O
(	O
tty_get_mode	function
(	O
)	O
==	O
TTY_NONCANONIC	int
)	O
clean_up	function
(	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: fatal error: %s.\n"	pointer
,	O
g_program	pointer
,	O
postmsg	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
int	O
command_expand	function
(	O
command	pointer
,	O
dest	pointer
,	O
p	pointer
,	O
l	pointer
)	O
command_t	struct
*	O
command	pointer
;	O
char	O
*	O
*	O
dest	pointer
;	O
panel_t	struct
*	O
p	pointer
,	O
*	O
l	pointer
;	O
{	O
char	O
c	char
;	O
uid_t	int
uid	int
;	O
gid_t	int
gid	int
;	O
int	O
retval	int
;	O
panel_t	struct
*	O
t	pointer
;	O
size_t	long
len	long
;	O
struct	O
group	struct
*	O
grp	pointer
;	O
struct	O
passwd	struct
*	O
pwd	pointer
;	O
static	O
int	O
busy	int
=	O
0	int
;	O
char	O
*	O
answer	pointer
=	O
NULL	O
;	O
char	O
*	O
question	pointer
=	O
NULL	O
;	O
int	O
i_flag	int
=	O
0	int
,	O
entry	int
;	O
size_t	long
oldtmplen	long
,	O
tmplen	long
;	O
char	O
*	O
ptr	pointer
,	O
*	O
tmp	pointer
=	O
NULL	O
,	O
*	O
d	pointer
,	O
*	O
flag	pointer
;	O
char	O
*	O
src	pointer
=	O
command	pointer
->	O
body	pointer
,	O
*	O
save_body	pointer
;	O
len	long
=	O
strlen	function
(	O
src	pointer
)	O
+	O
1	int
;	O
d	pointer
=	O
*	O
dest	pointer
=	O
xmalloc	function
(	O
len	long
)	O
;	O
while	O
(	O
*	O
src	pointer
)	O
{	O
if	O
(	O
*	O
src	pointer
!=	O
'%'	O
)	O
*	O
d	pointer
++	O
=	O
*	O
src	pointer
++	O
;	O
else	O
{	O
t	pointer
=	O
islower	function
(	O
(	O
int	O
)	O
*	O
++	O
src	pointer
)	O
?	O
p	pointer
:	O
l	pointer
;	O
switch	O
(	O
*	O
src	pointer
)	O
{	O
case	O
'?'	O
:	O
if	O
(	O
busy	int
)	O
{	O
busy	int
=	O
0	int
;	O
goto	O
bad_command	O
;	O
}	O
if	O
(	O
*	O
++	O
src	pointer
!=	O
'{'	O
)	O
goto	O
bad_command	O
;	O
if	O
(	O
(	O
ptr	pointer
=	O
strchr	function
(	O
++	O
src	pointer
,	O
'}'	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
bad_command	O
;	O
*	O
ptr	pointer
=	O
0	int
;	O
c	char
=	O
il_read_char	function
(	O
src	pointer
,	O
"yn"	pointer
,	O
IL_MOVE	int
)	O
;	O
*	O
ptr	pointer
=	O
'}'	O
;	O
if	O
(	O
c	char
!=	O
'y'	O
)	O
goto	O
strings_dont_match	O
;	O
src	pointer
=	O
ptr	pointer
;	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
busy	int
)	O
{	O
busy	int
=	O
0	int
;	O
goto	O
bad_command	O
;	O
}	O
if	O
(	O
*	O
++	O
src	pointer
!=	O
'{'	O
)	O
goto	O
bad_command	O
;	O
if	O
(	O
(	O
ptr	pointer
=	O
strchr	function
(	O
++	O
src	pointer
,	O
','	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
bad_command	O
;	O
*	O
ptr	pointer
=	O
0	int
;	O
busy	int
=	O
1	int
;	O
save_body	pointer
=	O
command	pointer
->	O
body	pointer
;	O
command	pointer
->	O
body	pointer
=	O
src	pointer
;	O
retval	int
=	O
command_expand	function
(	O
command	pointer
,	O
&	O
answer	pointer
,	O
p	pointer
,	O
l	pointer
)	O
;	O
command	pointer
->	O
body	pointer
=	O
save_body	pointer
;	O
busy	int
=	O
0	int
;	O
if	O
(	O
retval	int
<	O
1	int
)	O
{	O
*	O
ptr	pointer
=	O
','	O
;	O
if	O
(	O
retval	int
==	O
0	int
)	O
goto	O
bad_command	O
;	O
else	O
goto	O
strings_dont_match	O
;	O
}	O
question	pointer
=	O
xmalloc	function
(	O
16	int
+	O
strlen	function
(	O
command	pointer
->	O
name	pointer
)	O
+	O
strlen	function
(	O
answer	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
question	pointer
,	O
"%s: %s"	pointer
,	O
command	pointer
->	O
name	pointer
,	O
answer	pointer
)	O
;	O
xfree	function
(	O
answer	pointer
)	O
;	O
answer	pointer
=	O
NULL	O
;	O
*	O
ptr	pointer
++	O
=	O
','	O
;	O
if	O
(	O
(	O
src	pointer
=	O
strchr	function
(	O
ptr	pointer
,	O
'}'	O
)	O
)	O
==	O
NULL	O
)	O
goto	O
bad_command	O
;	O
*	O
src	pointer
=	O
0	int
;	O
if	O
(	O
strlen	function
(	O
question	pointer
)	O
>	O
MAX_STATIC_SIZE	int
)	O
question	pointer
[	O
MAX_STATIC_SIZE	int
]	O
=	O
0	int
;	O
busy	int
=	O
1	int
;	O
save_body	pointer
=	O
command	pointer
->	O
body	pointer
;	O
command	pointer
->	O
body	pointer
=	O
ptr	pointer
;	O
retval	int
=	O
command_expand	function
(	O
command	pointer
,	O
&	O
answer	pointer
,	O
p	pointer
,	O
l	pointer
)	O
;	O
command	pointer
->	O
body	pointer
=	O
save_body	pointer
;	O
busy	int
=	O
0	int
;	O
if	O
(	O
retval	int
<	O
1	int
)	O
{	O
*	O
src	pointer
=	O
'}'	O
;	O
xfree	function
(	O
question	pointer
)	O
;	O
question	pointer
=	O
NULL	O
;	O
if	O
(	O
retval	int
==	O
0	int
)	O
goto	O
bad_command	O
;	O
goto	O
strings_dont_match	O
;	O
}	O
flag	pointer
=	O
il_read_line	function
(	O
question	pointer
,	O
&	O
tmp	pointer
,	O
answer	pointer
,	O
command	pointer
->	O
history	pointer
)	O
;	O
xfree	function
(	O
question	pointer
)	O
;	O
xfree	function
(	O
answer	pointer
)	O
;	O
question	pointer
=	O
answer	pointer
=	O
NULL	O
;	O
if	O
(	O
flag	pointer
==	O
NULL	O
)	O
{	O
*	O
src	pointer
=	O
'}'	O
;	O
goto	O
strings_dont_match	O
;	O
}	O
*	O
src	pointer
=	O
'}'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'F'	O
:	O
if	O
(	O
panel_get_current_file_type	function
(	O
t	pointer
)	O
!=	O
FILE_ENTRY	int
)	O
goto	O
strings_dont_match	O
;	O
get_file_name	O
:	O
ptr	pointer
=	O
panel_get_current_file_name	function
(	O
t	pointer
)	O
;	O
tmp	pointer
=	O
xmalloc	function
(	O
1	int
+	O
strlen	function
(	O
ptr	pointer
)	O
+	O
1	int
+	O
1	int
)	O
;	O
sprintf	function
(	O
tmp	pointer
,	O
"\"%s\""	pointer
,	O
ptr	pointer
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
case	O
'D'	O
:	O
if	O
(	O
panel_get_current_file_type	function
(	O
t	pointer
)	O
!=	O
DIR_ENTRY	int
)	O
goto	O
strings_dont_match	O
;	O
goto	O
get_file_name	O
;	O
case	O
'l'	O
:	O
case	O
'L'	O
:	O
if	O
(	O
panel_get_current_file_type	function
(	O
t	pointer
)	O
!=	O
SYMLINK_ENTRY	int
)	O
goto	O
strings_dont_match	O
;	O
goto	O
get_file_name	O
;	O
case	O
't'	O
:	O
case	O
'T'	O
:	O
if	O
(	O
panel_get_current_file_type	function
(	O
t	pointer
)	O
!=	O
FIFO_ENTRY	int
)	O
goto	O
strings_dont_match	O
;	O
goto	O
get_file_name	O
;	O
case	O
'z'	O
:	O
case	O
'Z'	O
:	O
if	O
(	O
panel_get_current_file_type	function
(	O
t	pointer
)	O
!=	O
SOCKET_ENTRY	int
)	O
goto	O
strings_dont_match	O
;	O
goto	O
get_file_name	O
;	O
case	O
'a'	O
:	O
case	O
'A'	O
:	O
goto	O
get_file_name	O
;	O
case	O
'm'	O
:	O
case	O
'M'	O
:	O
tmp	pointer
=	O
xmalloc	function
(	O
16	int
)	O
;	O
sprintf	function
(	O
tmp	pointer
,	O
"%o"	pointer
,	O
(	O
int	O
)	O
panel_get_current_file_mode	function
(	O
t	pointer
)	O
&	O
07777	int
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
case	O
'O'	O
:	O
uid	int
=	O
panel_get_current_file_uid	function
(	O
t	pointer
)	O
;	O
pwd	pointer
=	O
getpwuid	function
(	O
uid	int
)	O
;	O
if	O
(	O
pwd	pointer
)	O
tmp	pointer
=	O
xstrdup	function
(	O
pwd	pointer
->	O
pw_name	pointer
)	O
;	O
else	O
{	O
tmp	pointer
=	O
xmalloc	function
(	O
16	int
)	O
;	O
sprintf	function
(	O
tmp	pointer
,	O
"%o"	pointer
,	O
(	O
int	O
)	O
uid	int
)	O
;	O
}	O
break	O
;	O
case	O
'g'	O
:	O
case	O
'G'	O
:	O
gid	int
=	O
panel_get_current_file_gid	function
(	O
t	pointer
)	O
;	O
grp	pointer
=	O
getgrgid	function
(	O
gid	int
)	O
;	O
if	O
(	O
grp	pointer
)	O
tmp	pointer
=	O
xstrdup	function
(	O
grp	pointer
->	O
gr_name	pointer
)	O
;	O
else	O
{	O
tmp	pointer
=	O
xmalloc	function
(	O
16	int
)	O
;	O
sprintf	function
(	O
tmp	pointer
,	O
"%o"	pointer
,	O
(	O
int	O
)	O
gid	int
)	O
;	O
}	O
break	O
;	O
case	O
'p'	O
:	O
case	O
'P'	O
:	O
tmp	pointer
=	O
xmalloc	function
(	O
1	int
+	O
strlen	function
(	O
t	pointer
->	O
path	pointer
)	O
+	O
1	int
+	O
1	int
)	O
;	O
sprintf	function
(	O
tmp	pointer
,	O
"\"%s\""	pointer
,	O
t	pointer
->	O
path	pointer
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
case	O
'B'	O
:	O
ptr	pointer
=	O
strrchr	function
(	O
t	pointer
->	O
path	pointer
,	O
'/'	O
)	O
;	O
ptr	pointer
=	O
(	O
*	O
++	O
ptr	pointer
)	O
?	O
ptr	pointer
:	O
"/root"	pointer
;	O
tmp	pointer
=	O
xmalloc	function
(	O
1	int
+	O
strlen	function
(	O
ptr	pointer
)	O
+	O
1	int
+	O
1	int
)	O
;	O
sprintf	function
(	O
tmp	pointer
,	O
"\"%s\""	pointer
,	O
ptr	pointer
)	O
;	O
break	O
;	O
case	O
'i'	O
:	O
case	O
'I'	O
:	O
i_flag	int
=	O
(	O
*	O
src	pointer
==	O
'i'	O
)	O
?	O
1	int
:	O
2	int
;	O
if	O
(	O
busy	int
&&	O
t	pointer
->	O
selected_entries	int
)	O
{	O
tmplen	long
=	O
20	int
;	O
tmp	pointer
=	O
xmalloc	function
(	O
tmplen	long
+	O
1	int
)	O
;	O
strcpy	function
(	O
tmp	pointer
,	O
"selected entries"	pointer
)	O
;	O
break	O
;	O
}	O
tmp	pointer
=	O
NULL	O
;	O
tmplen	long
=	O
0	int
;	O
panel_init_iterator	function
(	O
t	pointer
)	O
;	O
while	O
(	O
(	O
entry	int
=	O
panel_get_next	function
(	O
t	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
oldtmplen	long
=	O
tmplen	long
;	O
tmplen	long
+=	O
1	int
+	O
strlen	function
(	O
t	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
+	O
1	int
+	O
1	int
;	O
tmp	pointer
=	O
xrealloc	function
(	O
tmp	pointer
,	O
tmplen	long
+	O
1	int
)	O
;	O
tmp	pointer
[	O
oldtmplen	long
]	O
=	O
'"'	O
;	O
strcpy	function
(	O
tmp	pointer
+	O
oldtmplen	long
+	O
1	int
,	O
t	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
;	O
tmp	pointer
[	O
tmplen	long
-	O
2	int
]	O
=	O
'"'	O
;	O
tmp	pointer
[	O
tmplen	long
-	O
1	int
]	O
=	O
' '	O
;	O
tmp	pointer
[	O
tmplen	long
]	O
=	O
0	int
;	O
}	O
if	O
(	O
tmplen	long
==	O
0	int
)	O
goto	O
strings_dont_match	O
;	O
break	O
;	O
default	O
:	O
goto	O
bad_command	O
;	O
}	O
src	pointer
++	O
;	O
*	O
d	pointer
=	O
0	int
;	O
if	O
(	O
tmp	pointer
)	O
{	O
*	O
dest	pointer
=	O
xrealloc	function
(	O
*	O
dest	pointer
,	O
len	long
+=	O
strlen	function
(	O
tmp	pointer
)	O
)	O
;	O
strcat	function
(	O
*	O
dest	pointer
,	O
tmp	pointer
)	O
;	O
d	pointer
=	O
*	O
dest	pointer
+	O
strlen	function
(	O
*	O
dest	pointer
)	O
;	O
xfree	function
(	O
tmp	pointer
)	O
;	O
tmp	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
*	O
d	pointer
=	O
0	int
;	O
return	O
1	int
+	O
i_flag	int
;	O
bad_command	O
:	O
xfree	function
(	O
*	O
dest	pointer
)	O
;	O
*	O
dest	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
strings_dont_match	O
:	O
if	O
(	O
tmp	pointer
)	O
xfree	function
(	O
tmp	pointer
)	O
;	O
*	O
dest	pointer
=	O
NULL	O
;	O
return	O
-	O
1	int
;	O
}	O
void	O
add_to_environment	function
(	O
variable	pointer
,	O
alternate_variable	pointer
,	O
value	pointer
)	O
char	O
*	O
variable	pointer
;	O
char	O
*	O
alternate_variable	pointer
;	O
char	O
*	O
value	pointer
;	O
{	O
char	O
*	O
alternate_value	pointer
;	O
if	O
(	O
getenv	function
(	O
variable	pointer
)	O
==	O
NULL	O
)	O
{	O
if	O
(	O
alternate_variable	pointer
&&	O
(	O
alternate_value	pointer
=	O
getenv	function
(	O
alternate_variable	pointer
)	O
)	O
)	O
xsetenv	function
(	O
variable	pointer
,	O
alternate_value	pointer
)	O
;	O
else	O
xsetenv	function
(	O
variable	pointer
,	O
value	pointer
)	O
;	O
}	O
}	O
int	O
read_keys	function
(	O
keys	int
,	O
errors	pointer
)	O
int	O
keys	int
;	O
int	O
*	O
errors	pointer
;	O
{	O
int	O
i	int
,	O
j	int
;	O
command_t	struct
*	O
command	pointer
;	O
int	O
need_conversion	int
;	O
char	O
key_seq	pointer
[	O
80	int
]	O
;	O
char	O
*	O
contents	array
[	O
KEYSDATA_FIELDS	int
-	O
2	int
]	O
;	O
*	O
errors	pointer
=	O
0	int
;	O
for	O
(	O
i	int
=	O
keys	int
;	O
i	int
<	O
MAX_KEYS	int
;	O
i	int
++	O
)	O
{	O
configuration_getvarinfo	function
(	O
key_seq	pointer
,	O
contents	array
,	O
KEYSDATA_FIELDS	int
-	O
2	int
,	O
NO_SEEK	int
)	O
;	O
if	O
(	O
*	O
key_seq	pointer
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
*	O
key_seq	pointer
!=	O
'^'	O
)	O
{	O
char	O
*	O
key_seq_ptr	pointer
=	O
tty_get_symbol_key_seq	function
(	O
key_seq	pointer
)	O
;	O
if	O
(	O
key_seq_ptr	pointer
)	O
{	O
if	O
(	O
*	O
key_seq_ptr	pointer
==	O
'\0'	O
)	O
continue	O
;	O
strcpy	function
(	O
key_seq	pointer
,	O
key_seq_ptr	pointer
)	O
;	O
need_conversion	int
=	O
0	int
;	O
}	O
else	O
{	O
need_conversion	int
=	O
1	int
;	O
}	O
}	O
else	O
need_conversion	int
=	O
1	int
;	O
command	pointer
=	O
(	O
command_t	struct
*	O
)	O
xcalloc	function
(	O
1	int
,	O
sizeof	O
(	O
command_t	struct
)	O
)	O
;	O
if	O
(	O
contents	array
[	O
0	int
]	O
)	O
command	pointer
->	O
name	pointer
=	O
xstrdup	function
(	O
contents	array
[	O
0	int
]	O
)	O
;	O
else	O
{	O
xfree	function
(	O
command	pointer
)	O
;	O
continue	O
;	O
}	O
command	pointer
->	O
history	pointer
=	O
xstack_init	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
if	O
(	O
contents	array
[	O
2	int
]	O
)	O
command	pointer
->	O
new_dir	pointer
=	O
xstrdup	function
(	O
contents	array
[	O
2	int
]	O
)	O
;	O
if	O
(	O
contents	array
[	O
1	int
]	O
)	O
command	pointer
->	O
body	pointer
=	O
xstrdup	function
(	O
contents	array
[	O
1	int
]	O
)	O
;	O
else	O
goto	O
insert	O
;	O
if	O
(	O
contents	array
[	O
3	int
]	O
)	O
command	pointer
->	O
save_screen	char
=	O
(	O
(	O
tolower	function
(	O
(	O
int	O
)	O
contents	array
[	O
3	int
]	O
[	O
0	int
]	O
)	O
==	O
'y'	O
)	O
?	O
1	int
:	O
0	int
)	O
;	O
else	O
command	pointer
->	O
save_screen	char
=	O
1	int
;	O
if	O
(	O
contents	array
[	O
4	int
]	O
)	O
command	pointer
->	O
pause	function
=	O
(	O
(	O
tolower	function
(	O
(	O
int	O
)	O
contents	array
[	O
4	int
]	O
[	O
0	int
]	O
)	O
==	O
'y'	O
)	O
?	O
1	int
:	O
0	int
)	O
;	O
if	O
(	O
contents	array
[	O
5	int
]	O
)	O
command	pointer
->	O
hide	char
=	O
(	O
(	O
tolower	function
(	O
(	O
int	O
)	O
contents	array
[	O
5	int
]	O
[	O
0	int
]	O
)	O
==	O
'y'	O
)	O
?	O
1	int
:	O
0	int
)	O
;	O
insert	O
:	O
if	O
(	O
islower	function
(	O
(	O
int	O
)	O
command	pointer
->	O
name	pointer
[	O
0	int
]	O
)	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
BUILTIN_OPERATIONS	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
command	pointer
->	O
name	pointer
,	O
builtin	array
[	O
j	int
]	O
)	O
==	O
0	int
)	O
{	O
xfree	function
(	O
command	pointer
->	O
name	pointer
)	O
;	O
command	pointer
->	O
name	pointer
=	O
builtin	array
[	O
j	int
]	O
;	O
command	pointer
->	O
builtin	array
=	O
1	int
;	O
break	O
;	O
}	O
}	O
command	pointer
->	O
sequence	pointer
=	O
xstrdup	function
(	O
key_seq	pointer
)	O
;	O
if	O
(	O
command	pointer
->	O
builtin	array
||	O
command	pointer
->	O
body	pointer
||	O
command	pointer
->	O
new_dir	pointer
)	O
{	O
if	O
(	O
need_conversion	int
)	O
{	O
if	O
(	O
tty_key_human2machine	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	pointer
)	O
)	O
tty_key_list_insert	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	pointer
,	O
(	O
void	O
*	O
)	O
command	pointer
)	O
;	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: invalid key sequence '%s'\n"	pointer
,	O
g_program	pointer
,	O
key_seq	pointer
)	O
;	O
(	O
*	O
errors	pointer
)	O
++	O
;	O
}	O
}	O
else	O
tty_key_list_insert	function
(	O
(	O
unsigned	O
char	O
*	O
)	O
key_seq	pointer
,	O
(	O
void	O
*	O
)	O
command	pointer
)	O
;	O
}	O
}	O
return	O
i	int
;	O
}	O
void	O
hide	char
(	O
)	O
{	O
tty_set_mode	function
(	O
TTY_CANONIC	int
)	O
;	O
tty_defaults	function
(	O
)	O
;	O
tty_put_screen	function
(	O
screen	pointer
)	O
;	O
}	O
void	O
set_prompt	function
(	O
)	O
{	O
char	O
temp	pointer
[	O
MAX_STATIC_SIZE	int
+	O
1	int
]	O
;	O
il_set_static_text	function
(	O
strcat	function
(	O
truncate_string	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
,	O
temp	pointer
,	O
MAX_STATIC_SIZE	int
-	O
strlen	function
(	O
PS1	array
)	O
+	O
1	int
)	O
,	O
PS1	array
)	O
)	O
;	O
}	O
void	O
reread	function
(	O
)	O
{	O
panel_action	function
(	O
dst_panel	pointer
,	O
act_REGET	int
,	O
src_panel	pointer
,	O
(	O
void	O
*	O
)	O
-	O
1	int
,	O
1	int
)	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_REGET	int
,	O
dst_panel	pointer
,	O
(	O
void	O
*	O
)	O
-	O
1	int
,	O
1	int
)	O
;	O
}	O
void	O
usage	function
(	O
)	O
{	O
printf	function
(	O
"usage: %s [-hvcblp] [path1] [path2]\n"	pointer
,	O
g_program	pointer
)	O
;	O
printf	function
(	O
" -h         print this help message\n"	pointer
)	O
;	O
printf	function
(	O
" -v         print the version number\n"	pointer
)	O
;	O
printf	function
(	O
" -c         use ANSI colors\n"	pointer
)	O
;	O
printf	function
(	O
" -b         don't use ANSI colors\n"	pointer
)	O
;	O
printf	function
(	O
" -l         don't use the last screen character\n"	pointer
)	O
;	O
printf	function
(	O
" -p         output final path at exit\n"	pointer
)	O
;	O
}	O
int	O
main	function
(	O
argc	int
,	O
argv	array
)	O
int	O
argc	int
;	O
char	O
*	O
argv	array
[	O
]	O
;	O
{	O
tty_key_t	struct
*	O
ks	pointer
;	O
char	O
*	O
final_path	pointer
;	O
command_t	struct
*	O
command	pointer
;	O
size_t	long
len	long
=	O
0	int
,	O
ptrlen	long
;	O
char	O
*	O
temporary_directory	pointer
;	O
int	O
previous_isearch_failed	int
;	O
int	O
resuming_previous_isearch	int
;	O
int	O
output_final_path	int
=	O
OFF	int
;	O
input_line_t	struct
*	O
saved_il	pointer
=	O
NULL	O
;	O
char	O
*	O
panel_path	pointer
,	O
*	O
current_path	pointer
;	O
char	O
*	O
lock_password	pointer
,	O
*	O
unlock_password	pointer
,	O
*	O
aproposstr	pointer
;	O
int	O
child_exit_code	int
,	O
repeat_count	int
,	O
keys	int
;	O
int	O
action_status	int
,	O
i	int
,	O
retval	int
,	O
to_case	int
,	O
cmp_mode	int
;	O
int	O
c	char
,	O
ansi_colors	int
=	O
-	O
1	int
,	O
use_last_screen_character	int
=	O
ON	int
;	O
int	O
entry	int
,	O
key	int
,	O
app_end	int
=	O
0	int
,	O
first_time	int
=	O
1	int
,	O
errors	pointer
=	O
0	int
;	O
char	O
*	O
left_panel_path	pointer
,	O
*	O
right_panel_path	pointer
,	O
*	O
output_string	pointer
;	O
char	O
*	O
cmdln	pointer
=	O
NULL	O
,	O
*	O
input	pointer
=	O
NULL	O
,	O
*	O
ptr	pointer
,	O
*	O
srcptr	pointer
,	O
*	O
search_string	pointer
=	O
NULL	O
;	O
signals_init	function
(	O
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
program_name	pointer
=	O
g_program	pointer
=	O
argv	array
[	O
0	int
]	O
;	O
g_home	pointer
=	O
getenv	function
(	O
"HOME"	pointer
)	O
;	O
if	O
(	O
g_home	pointer
==	O
NULL	O
)	O
g_home	pointer
=	O
"."	pointer
;	O
compute_directories	function
(	O
)	O
;	O
update_path	function
(	O
)	O
;	O
get_login_name	function
(	O
)	O
;	O
exit_msg	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
PRODUCT	pointer
)	O
+	O
16	int
)	O
;	O
sprintf	function
(	O
exit_msg	pointer
,	O
"Exit %s? "	pointer
,	O
PRODUCT	pointer
)	O
;	O
if	O
(	O
getenv	function
(	O
"COLORTERM"	pointer
)	O
!=	O
NULL	O
)	O
ansi_colors	int
=	O
ON	int
;	O
while	O
(	O
(	O
c	char
=	O
getopt	function
(	O
argc	int
,	O
argv	array
,	O
"hvcblp"	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
switch	O
(	O
c	char
)	O
{	O
case	O
'h'	O
:	O
usage	function
(	O
)	O
;	O
return	O
0	int
;	O
case	O
'v'	O
:	O
printf	function
(	O
"%s %s\n"	pointer
,	O
PRODUCT	pointer
,	O
VERSION	pointer
)	O
;	O
return	O
0	int
;	O
case	O
'c'	O
:	O
ansi_colors	int
=	O
ON	int
;	O
break	O
;	O
case	O
'b'	O
:	O
ansi_colors	int
=	O
OFF	int
;	O
break	O
;	O
case	O
'l'	O
:	O
use_last_screen_character	int
=	O
OFF	int
;	O
break	O
;	O
case	O
'p'	O
:	O
output_final_path	int
=	O
ON	int
;	O
break	O
;	O
case	O
'?'	O
:	O
return	O
1	int
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: unknown error\n"	pointer
,	O
g_program	pointer
)	O
;	O
return	O
1	int
;	O
}	O
left_panel_path	pointer
=	O
right_panel_path	pointer
=	O
"."	pointer
;	O
if	O
(	O
optind	int
<	O
argc	int
)	O
{	O
left_panel_path	pointer
=	O
xstrdup	function
(	O
argv	array
[	O
optind	int
++	O
]	O
)	O
;	O
if	O
(	O
optind	int
<	O
argc	int
)	O
right_panel_path	pointer
=	O
xstrdup	function
(	O
argv	array
[	O
optind	int
++	O
]	O
)	O
;	O
else	O
right_panel_path	pointer
=	O
left_panel_path	pointer
;	O
}	O
if	O
(	O
optind	int
<	O
argc	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: warning: invalid extra options ignored\n"	pointer
,	O
g_program	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
"%s %s (%s), %s %s\n"	pointer
,	O
PRODUCT	pointer
,	O
VERSION	pointer
,	O
HOST	pointer
,	O
__TIME__	O
,	O
__DATE__	O
)	O
;	O
printf	function
(	O
copyright	pointer
)	O
;	O
add_to_environment	function
(	O
"GIT_EDITOR"	pointer
,	O
"EDITOR"	pointer
,	O
"vi"	pointer
)	O
;	O
add_to_environment	function
(	O
"GNUIT_EDITOR"	pointer
,	O
"GIT_EDITOR"	pointer
,	O
"vi"	pointer
)	O
;	O
add_to_environment	function
(	O
"GIT_PAGER"	pointer
,	O
"PAGER"	pointer
,	O
"more"	pointer
)	O
;	O
add_to_environment	function
(	O
"GNUIT_PAGER"	pointer
,	O
"GIT_PAGER"	pointer
,	O
"more"	pointer
)	O
;	O
add_to_environment	function
(	O
"GIT_BROWSER"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
"lynx"	pointer
)	O
;	O
add_to_environment	function
(	O
"GNUIT_BROWSER"	pointer
,	O
"GIT_BROWSER"	pointer
,	O
"lynx"	pointer
)	O
;	O
add_to_environment	function
(	O
"GIT_SHELL"	pointer
,	O
"SHELL"	pointer
,	O
"/bin/sh"	pointer
)	O
;	O
add_to_environment	function
(	O
"GNUIT_SHELL"	pointer
,	O
"GIT_SHELL"	pointer
,	O
"/bin/sh"	pointer
)	O
;	O
add_to_environment	function
(	O
"GIT_RMAIL"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
"mail"	pointer
)	O
;	O
add_to_environment	function
(	O
"GNUIT_RMAIL"	pointer
,	O
"GIT_RMAIL"	pointer
,	O
"mail"	pointer
)	O
;	O
add_to_environment	function
(	O
"GIT_VMSTAT"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
"free"	pointer
)	O
;	O
add_to_environment	function
(	O
"GNUIT_VMSTAT"	pointer
,	O
"GIT_VMSTAT"	pointer
,	O
"free"	pointer
)	O
;	O
tty_init	function
(	O
TTY_RESTRICTED_INPUT	int
)	O
;	O
common_configuration_init	function
(	O
)	O
;	O
use_section	function
(	O
"[GITFM-FTI]"	pointer
)	O
;	O
get_file_type_info	function
(	O
)	O
;	O
use_section	function
(	O
"[GITFM-Keys]"	pointer
)	O
;	O
keys	int
=	O
read_keys	function
(	O
0	int
,	O
&	O
errors	pointer
)	O
;	O
wait_msg	int
+=	O
errors	pointer
;	O
configuration_end	function
(	O
)	O
;	O
wait_msg	int
+=	O
(	O
specific_configuration_init	function
(	O
)	O
==	O
0	int
)	O
;	O
temporary_directory	pointer
=	O
getenv	function
(	O
"TMPDIR"	pointer
)	O
;	O
if	O
(	O
temporary_directory	pointer
==	O
NULL	O
)	O
temporary_directory	pointer
=	O
"/tmp"	pointer
;	O
stdout_log_template	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
temporary_directory	pointer
)	O
+	O
1	int
)	O
;	O
stderr_log_template	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
temporary_directory	pointer
)	O
+	O
1	int
)	O
;	O
stdout_log_name	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
temporary_directory	pointer
)	O
+	O
1	int
)	O
;	O
stderr_log_name	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
temporary_directory	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
stdout_log_template	pointer
,	O
"%s/gnuit.1.XXXXXX"	pointer
,	O
temporary_directory	pointer
)	O
;	O
sprintf	function
(	O
stderr_log_template	pointer
,	O
"%s/gnuit.2.XXXXXX"	pointer
,	O
temporary_directory	pointer
)	O
;	O
use_section	function
(	O
"[Setup]"	pointer
)	O
;	O
if	O
(	O
ansi_colors	int
==	O
-	O
1	int
)	O
AnsiColors	int
=	O
get_flag_var	function
(	O
"AnsiColors"	pointer
,	O
OFF	int
)	O
;	O
else	O
AnsiColors	int
=	O
ansi_colors	int
;	O
if	O
(	O
use_last_screen_character	int
)	O
UseLastScreenChar	int
=	O
get_flag_var	function
(	O
"UseLastScreenChar"	pointer
,	O
OFF	int
)	O
;	O
else	O
UseLastScreenChar	int
=	O
OFF	int
;	O
tty_set_last_char_flag	function
(	O
UseLastScreenChar	int
)	O
;	O
use_section	function
(	O
"[GITFM-Setup]"	pointer
)	O
;	O
if	O
(	O
AnsiColors	int
==	O
ON	int
)	O
TypeSensitivity	int
=	O
get_flag_var	function
(	O
"TypeSensitivity"	pointer
,	O
ON	int
)	O
;	O
else	O
TypeSensitivity	int
=	O
OFF	int
;	O
ConfirmOnExit	int
=	O
get_flag_var	function
(	O
"ConfirmOnExit"	pointer
,	O
OFF	int
)	O
;	O
NormalModeHelp	pointer
=	O
get_string_var	function
(	O
"NormalModeHelp"	pointer
,	O
""	pointer
)	O
;	O
CommandLineModeHelp	pointer
=	O
get_string_var	function
(	O
"CommandLineModeHelp"	pointer
,	O
""	pointer
)	O
;	O
use_section	function
(	O
AnsiColors	int
?	O
color_section	array
:	O
monochrome_section	array
)	O
;	O
get_colorset_var	function
(	O
TitleColors	array
,	O
TitleFields	array
,	O
TITLE_FIELDS	int
)	O
;	O
use_section	function
(	O
"[GITFM-FTI]"	pointer
)	O
;	O
get_file_type_info	function
(	O
)	O
;	O
use_section	function
(	O
"[GITFM-Keys]"	pointer
)	O
;	O
keys	int
=	O
read_keys	function
(	O
keys	int
,	O
&	O
errors	pointer
)	O
;	O
wait_msg	int
+=	O
errors	pointer
;	O
if	O
(	O
keys	int
==	O
MAX_KEYS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: too many key sequences; only %d are allowed.\n"	pointer
,	O
g_program	pointer
,	O
MAX_KEYS	int
)	O
;	O
if	O
(	O
getuid	function
(	O
)	O
==	O
0	int
)	O
PS1	array
[	O
1	int
]	O
=	O
'#'	O
;	O
current_path	pointer
=	O
xgetcwd	function
(	O
)	O
;	O
if	O
(	O
current_path	pointer
==	O
NULL	O
)	O
fatal	function
(	O
"`getcwd' failed: permission denied"	pointer
)	O
;	O
tty_start_cursorapp	function
(	O
)	O
;	O
title_init	function
(	O
)	O
;	O
il_init	function
(	O
)	O
;	O
status_init	function
(	O
NormalModeHelp	pointer
)	O
;	O
if	O
(	O
left_panel_path	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
panel_path	pointer
=	O
xstrdup	function
(	O
left_panel_path	pointer
)	O
;	O
else	O
{	O
panel_path	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
current_path	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
left_panel_path	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
panel_path	pointer
,	O
"%s/%s"	pointer
,	O
current_path	pointer
,	O
left_panel_path	pointer
)	O
;	O
}	O
left_panel	pointer
=	O
panel_init	function
(	O
panel_path	pointer
)	O
;	O
xfree	function
(	O
panel_path	pointer
)	O
;	O
if	O
(	O
right_panel_path	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
panel_path	pointer
=	O
xstrdup	function
(	O
right_panel_path	pointer
)	O
;	O
else	O
{	O
panel_path	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
current_path	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
right_panel_path	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
panel_path	pointer
,	O
"%s/%s"	pointer
,	O
current_path	pointer
,	O
right_panel_path	pointer
)	O
;	O
}	O
right_panel	pointer
=	O
panel_init	function
(	O
panel_path	pointer
)	O
;	O
xfree	function
(	O
panel_path	pointer
)	O
;	O
xfree	function
(	O
current_path	pointer
)	O
;	O
configuration_end	function
(	O
)	O
;	O
src_panel	pointer
=	O
left_panel	pointer
;	O
dst_panel	pointer
=	O
right_panel	pointer
;	O
resize	function
(	O
0	int
)	O
;	O
tty_get_screen	function
(	O
screen	pointer
)	O
;	O
tty_set_mode	function
(	O
TTY_NONCANONIC	int
)	O
;	O
tty_defaults	function
(	O
)	O
;	O
dir_history	pointer
=	O
NULL	O
;	O
dir_history_count	int
=	O
0	int
;	O
dir_history_point	int
=	O
0	int
;	O
signal_handlers	function
(	O
ON	int
)	O
;	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
restart	O
:	O
if	O
(	O
wait_msg	int
)	O
{	O
alarm	function
(	O
0	int
)	O
;	O
fprintf	function
(	O
stdout	pointer
,	O
"Press almost any key to continue\n"	pointer
)	O
;	O
tty_goto	function
(	O
tty_lines	int
-	O
1	int
,	O
0	int
)	O
;	O
tty_get_key	function
(	O
NULL	O
)	O
;	O
wait_msg	int
=	O
0	int
;	O
}	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
alarm	function
(	O
60	int
-	O
get_local_time	function
(	O
)	O
->	O
tm_sec	int
)	O
;	O
src_panel	pointer
=	O
panel_no	int
?	O
right_panel	pointer
:	O
left_panel	pointer
;	O
dst_panel	pointer
=	O
panel_no	int
?	O
left_panel	pointer
:	O
right_panel	pointer
;	O
if	O
(	O
tty_lines	int
<	O
7	int
)	O
{	O
tty_defaults	function
(	O
)	O
;	O
tty_clear	function
(	O
)	O
;	O
}	O
title_update	function
(	O
)	O
;	O
status_default	function
(	O
)	O
;	O
il_restore	function
(	O
saved_il	pointer
)	O
;	O
tty_update	function
(	O
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
reread	function
(	O
)	O
;	O
refresh	function
(	O
0	int
)	O
;	O
il_restore	function
(	O
saved_il	pointer
)	O
;	O
panel_set_focus	function
(	O
src_panel	pointer
,	O
ON	int
)	O
;	O
if	O
(	O
first_time	int
)	O
{	O
dir_history_add	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
first_time	int
=	O
0	int
;	O
}	O
set_prompt	function
(	O
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
while	O
(	O
!	O
app_end	int
)	O
{	O
il_restore	function
(	O
saved_il	pointer
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
il_get_contents	function
(	O
&	O
cmdln	pointer
)	O
;	O
user_heart_attack	int
=	O
0	int
;	O
while	O
(	O
(	O
ks	pointer
=	O
tty_get_key	function
(	O
&	O
repeat_count	int
)	O
)	O
==	O
NULL	O
)	O
report_undefined_key	function
(	O
NULL	O
)	O
;	O
status_update	function
(	O
)	O
;	O
key	int
=	O
ks	pointer
->	O
key_seq	pointer
[	O
0	int
]	O
;	O
command	pointer
=	O
(	O
command_t	struct
*	O
)	O
ks	pointer
->	O
aux_data	pointer
;	O
if	O
(	O
command	pointer
)	O
{	O
if	O
(	O
command	pointer
->	O
builtin	array
)	O
key	int
=	O
-	O
1	int
-	O
(	O
command	pointer
->	O
name	pointer
-	O
builtin	array
[	O
0	int
]	O
)	O
/	O
MAX_BUILTIN_NAME	int
;	O
else	O
{	O
if	O
(	O
command	pointer
->	O
name	pointer
)	O
{	O
panel_no_optimizations	function
(	O
src_panel	pointer
)	O
;	O
panel_no_optimizations	function
(	O
dst_panel	pointer
)	O
;	O
if	O
(	O
command	pointer
->	O
body	pointer
)	O
{	O
char	O
*	O
cmd	pointer
=	O
NULL	O
;	O
retval	int
=	O
command_expand	function
(	O
command	pointer
,	O
&	O
cmd	pointer
,	O
src_panel	pointer
,	O
dst_panel	pointer
)	O
;	O
if	O
(	O
retval	int
)	O
{	O
if	O
(	O
retval	int
>	O
0	int
)	O
{	O
size_t	long
msglen	long
=	O
32	int
+	O
strlen	function
(	O
command	pointer
->	O
name	pointer
)	O
+	O
strlen	function
(	O
cmd	pointer
)	O
+	O
1	int
;	O
char	O
*	O
msg	pointer
=	O
xmalloc	function
(	O
msglen	long
)	O
;	O
sprintf	function
(	O
msg	pointer
,	O
"%s: %s"	pointer
,	O
command	pointer
->	O
name	pointer
,	O
cmd	pointer
)	O
;	O
status	function
(	O
msg	pointer
,	O
STATUS_WARNING	int
,	O
STATUS_LEFT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
command	pointer
->	O
hide	char
)	O
{	O
msg	pointer
=	O
xmalloc	function
(	O
64	int
+	O
strlen	function
(	O
command	pointer
->	O
name	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
msg	pointer
,	O
"Wait, running %s command %s..."	pointer
,	O
"user-defined"	pointer
,	O
command	pointer
->	O
name	pointer
)	O
;	O
il_message	function
(	O
msg	pointer
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
}	O
if	O
(	O
!	O
is_a_bg_command	function
(	O
cmd	pointer
)	O
)	O
tty_update_title	function
(	O
cmd	pointer
)	O
;	O
child_exit_code	int
=	O
start	function
(	O
cmd	pointer
,	O
command	pointer
->	O
hide	char
)	O
;	O
xfree	function
(	O
cmd	pointer
)	O
;	O
if	O
(	O
command	pointer
->	O
hide	char
)	O
{	O
if	O
(	O
WIFSIGNALED	O
(	O
child_exit_code	int
)	O
)	O
{	O
il_read_char	function
(	O
"Command interrupted by signal"	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_BEEP	int
|	O
IL_ERROR	int
)	O
;	O
}	O
else	O
if	O
(	O
WIFEXITED	O
(	O
child_exit_code	int
)	O
&&	O
(	O
WEXITSTATUS	O
(	O
child_exit_code	int
)	O
!=	O
0	int
)	O
)	O
{	O
tty_beep	function
(	O
)	O
;	O
display_errors	function
(	O
command	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
command	pointer
->	O
save_screen	char
)	O
tty_get_screen	function
(	O
screen	pointer
)	O
;	O
tty_touch	function
(	O
)	O
;	O
if	O
(	O
command	pointer
->	O
pause	function
)	O
wait_msg	int
=	O
1	int
;	O
}	O
if	O
(	O
WIFEXITED	O
(	O
child_exit_code	int
)	O
&&	O
(	O
WEXITSTATUS	O
(	O
child_exit_code	int
)	O
==	O
0	int
)	O
&&	O
command	pointer
->	O
new_dir	pointer
)	O
{	O
char	O
*	O
expanded_dir	pointer
=	O
tilde_expand	function
(	O
command	pointer
->	O
new_dir	pointer
)	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_CHDIR	int
,	O
dst_panel	pointer
,	O
expanded_dir	pointer
,	O
1	int
)	O
;	O
dir_history_add	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
xfree	function
(	O
expanded_dir	pointer
)	O
;	O
}	O
if	O
(	O
WIFEXITED	O
(	O
child_exit_code	int
)	O
&&	O
(	O
WEXITSTATUS	O
(	O
child_exit_code	int
)	O
==	O
0	int
)	O
)	O
{	O
if	O
(	O
retval	int
==	O
2	int
)	O
panel_unselect_all	function
(	O
src_panel	pointer
)	O
;	O
else	O
if	O
(	O
retval	int
==	O
3	int
)	O
panel_unselect_all	function
(	O
dst_panel	pointer
)	O
;	O
}	O
goto	O
restart	O
;	O
}	O
else	O
continue	O
;	O
}	O
else	O
{	O
char	O
*	O
msg	pointer
;	O
msg	pointer
=	O
xmalloc	function
(	O
80	int
+	O
strlen	function
(	O
(	O
char	O
*	O
)	O
ks	pointer
->	O
key_seq	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
msg	pointer
,	O
"%s: invalid command on key sequence %s !"	pointer
,	O
command	pointer
->	O
name	pointer
,	O
command	pointer
->	O
sequence	pointer
)	O
;	O
il_read_char	function
(	O
msg	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_FREEZED	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
command	pointer
->	O
new_dir	pointer
)	O
{	O
char	O
*	O
expanded_dir	pointer
=	O
tilde_expand	function
(	O
command	pointer
->	O
new_dir	pointer
)	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_CHDIR	int
,	O
dst_panel	pointer
,	O
expanded_dir	pointer
,	O
1	int
)	O
;	O
dir_history_add	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
xfree	function
(	O
expanded_dir	pointer
)	O
;	O
}	O
goto	O
restart	O
;	O
}	O
}	O
}	O
}	O
switch	O
(	O
key	int
)	O
{	O
case	O
key_INTERRUPT	O
:	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_other_panel	O
:	O
if	O
(	O
!	O
two_panel_mode	int
)	O
goto	O
one_panel_mode	O
;	O
if	O
(	O
(	O
repeat_count	int
&	O
1	int
)	O
==	O
0	int
)	O
break	O
;	O
panel_set_focus	function
(	O
src_panel	pointer
,	O
OFF	int
)	O
;	O
tmp_panel	pointer
=	O
src_panel	pointer
;	O
src_panel	pointer
=	O
dst_panel	pointer
;	O
dst_panel	pointer
=	O
tmp_panel	pointer
;	O
panel_no	int
=	O
!	O
panel_no	int
;	O
panel_set_focus	function
(	O
src_panel	pointer
,	O
ON	int
)	O
;	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
set_prompt	function
(	O
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_previous_line	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_UP	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
repeat_count	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_next_line	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_DOWN	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
repeat_count	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_action	O
:	O
action_status	int
=	O
0	int
;	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
il_get_contents	function
(	O
&	O
cmdln	pointer
)	O
;	O
for	O
(	O
i	int
=	O
strlen	function
(	O
cmdln	pointer
)	O
-	O
1	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
if	O
(	O
cmdln	pointer
[	O
i	int
]	O
==	O
' '	O
)	O
cmdln	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
else	O
break	O
;	O
switch	O
(	O
cmdln	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'+'	O
:	O
if	O
(	O
cmdln	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
panel_action	function
(	O
src_panel	pointer
,	O
act_SELECT_ALL	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
else	O
panel_action	function
(	O
src_panel	pointer
,	O
act_PATTERN_SELECT	int
,	O
dst_panel	pointer
,	O
cmdln	pointer
+	O
1	int
,	O
1	int
)	O
;	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
if	O
(	O
cmdln	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
panel_action	function
(	O
src_panel	pointer
,	O
act_UNSELECT_ALL	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
else	O
panel_action	function
(	O
src_panel	pointer
,	O
act_PATTERN_UNSELECT	int
,	O
dst_panel	pointer
,	O
cmdln	pointer
+	O
1	int
,	O
1	int
)	O
;	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
break	O
;	O
case	O
'\0'	O
:	O
action_status	int
=	O
panel_action	function
(	O
src_panel	pointer
,	O
act_ENTER	int
,	O
dst_panel	pointer
,	O
screen	pointer
,	O
1	int
)	O
;	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
set_prompt	function
(	O
)	O
;	O
break	O
;	O
case	O
'*'	O
:	O
if	O
(	O
cmdln	pointer
[	O
1	int
]	O
==	O
'\0'	O
)	O
{	O
panel_action	function
(	O
src_panel	pointer
,	O
act_TOGGLE	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
break	O
;	O
}	O
default	O
:	O
if	O
(	O
history_expand	function
(	O
cmdln	pointer
,	O
&	O
output_string	pointer
)	O
>=	O
0	int
)	O
{	O
int	O
bg_cmd	int
;	O
if	O
(	O
is_an_empty_command	function
(	O
output_string	pointer
)	O
)	O
{	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
il_read_char	function
(	O
"Void command."	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_FREEZED	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
break	O
;	O
}	O
bg_cmd	int
=	O
is_a_bg_command	function
(	O
output_string	pointer
)	O
;	O
if	O
(	O
!	O
bg_cmd	int
)	O
tty_update_title	function
(	O
output_string	pointer
)	O
;	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
il_insert_text	function
(	O
output_string	pointer
)	O
;	O
start	function
(	O
output_string	pointer
,	O
bg_cmd	int
)	O
;	O
il_history	function
(	O
IL_RECORD	int
)	O
;	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
if	O
(	O
!	O
bg_cmd	int
)	O
{	O
panel_no_optimizations	function
(	O
src_panel	pointer
)	O
;	O
panel_no_optimizations	function
(	O
dst_panel	pointer
)	O
;	O
tty_touch	function
(	O
)	O
;	O
tty_get_screen	function
(	O
screen	pointer
)	O
;	O
action_status	int
=	O
1	int
;	O
wait_msg	int
=	O
1	int
;	O
}	O
}	O
else	O
il_read_char	function
(	O
output_string	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_FREEZED	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
break	O
;	O
}	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
if	O
(	O
action_status	int
)	O
goto	O
restart	O
;	O
break	O
;	O
case	O
BUILTIN_select_entry	O
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
repeat_count	int
;	O
i	int
++	O
)	O
panel_action	function
(	O
src_panel	pointer
,	O
act_SELECT	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_scroll_down	O
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
repeat_count	int
;	O
i	int
++	O
)	O
panel_action	function
(	O
src_panel	pointer
,	O
act_PGUP	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_scroll_up	O
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
repeat_count	int
;	O
i	int
++	O
)	O
panel_action	function
(	O
src_panel	pointer
,	O
act_PGDOWN	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_beginning_of_panel	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_HOME	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_end_of_panel	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_END	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_refresh	O
:	O
reread	function
(	O
)	O
;	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
refresh	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_tty_mode	O
:	O
if	O
(	O
(	O
repeat_count	int
&	O
1	int
)	O
==	O
0	int
)	O
break	O
;	O
alarm	function
(	O
0	int
)	O
;	O
tty_put_screen	function
(	O
screen	pointer
)	O
;	O
status	function
(	O
CommandLineModeHelp	pointer
,	O
STATUS_OK	int
,	O
STATUS_CENTERED	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
il_restore	function
(	O
saved_il	pointer
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
il_get_contents	function
(	O
&	O
cmdln	pointer
)	O
;	O
current_mode	int
=	O
GIT_TERMINAL_MODE	int
;	O
while	O
(	O
(	O
ks	pointer
=	O
tty_get_key	function
(	O
&	O
repeat_count	int
)	O
)	O
==	O
NULL	O
)	O
report_undefined_key	function
(	O
CommandLineModeHelp	pointer
)	O
;	O
key	int
=	O
ks	pointer
->	O
key_seq	pointer
[	O
0	int
]	O
;	O
command	pointer
=	O
(	O
command_t	struct
*	O
)	O
ks	pointer
->	O
aux_data	pointer
;	O
if	O
(	O
command	pointer
&&	O
command	pointer
->	O
builtin	array
)	O
key	int
=	O
-	O
1	int
-	O
(	O
command	pointer
->	O
name	pointer
-	O
builtin	array
[	O
0	int
]	O
)	O
/	O
MAX_BUILTIN_NAME	int
;	O
if	O
(	O
key	int
==	O
BUILTIN_tty_mode	O
&&	O
(	O
repeat_count	int
&	O
1	int
)	O
)	O
{	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
key	int
)	O
{	O
case	O
key_INTERRUPT	O
:	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_action	O
:	O
if	O
(	O
cmdln	pointer
[	O
0	int
]	O
)	O
{	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
if	O
(	O
history_expand	function
(	O
cmdln	pointer
,	O
&	O
output_string	pointer
)	O
<	O
0	int
)	O
{	O
il_read_char	function
(	O
output_string	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_FREEZED	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
break	O
;	O
}	O
tty_put_screen	function
(	O
screen	pointer
)	O
;	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
il_insert_text	function
(	O
output_string	pointer
)	O
;	O
tty_update_title	function
(	O
output_string	pointer
)	O
;	O
start	function
(	O
output_string	pointer
,	O
0	int
)	O
;	O
tty_get_screen	function
(	O
screen	pointer
)	O
;	O
il_history	function
(	O
IL_RECORD	int
)	O
;	O
status	function
(	O
CommandLineModeHelp	pointer
,	O
STATUS_OK	int
,	O
STATUS_CENTERED	int
)	O
;	O
il_kill_line	function
(	O
IL_DONT_STORE	int
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_previous_history_element	O
:	O
case	O
BUILTIN_previous_line	O
:	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
repeat_count	int
;	O
i	int
++	O
)	O
{	O
il_history	function
(	O
IL_PREVIOUS	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_next_history_element	O
:	O
case	O
BUILTIN_next_line	O
:	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
repeat_count	int
;	O
i	int
++	O
)	O
{	O
il_history	function
(	O
IL_NEXT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_refresh	O
:	O
refresh	function
(	O
0	int
)	O
;	O
tty_put_screen	function
(	O
screen	pointer
)	O
;	O
status	function
(	O
CommandLineModeHelp	pointer
,	O
STATUS_OK	int
,	O
STATUS_CENTERED	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_exit	O
:	O
if	O
(	O
ConfirmOnExit	int
==	O
OFF	int
||	O
il_read_char	function
(	O
exit_msg	pointer
,	O
"yn"	pointer
,	O
IL_FREEZED	int
)	O
==	O
'y'	O
)	O
{	O
app_end	int
=	O
1	int
;	O
goto	O
end_tty_mode	O
;	O
}	O
status	function
(	O
CommandLineModeHelp	pointer
,	O
STATUS_OK	int
,	O
STATUS_CENTERED	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
key	int
)	O
{	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
while	O
(	O
repeat_count	int
--	O
)	O
il_dispatch_commands	function
(	O
key	int
,	O
IL_MOVE	int
|	O
IL_EDIT	int
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
}	O
break	O
;	O
}	O
status_update	function
(	O
)	O
;	O
}	O
end_tty_mode	O
:	O
panel_no_optimizations	function
(	O
src_panel	pointer
)	O
;	O
panel_no_optimizations	function
(	O
dst_panel	pointer
)	O
;	O
tty_touch	function
(	O
)	O
;	O
status_default	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
alarm	function
(	O
60	int
-	O
get_local_time	function
(	O
)	O
->	O
tm_sec	int
)	O
;	O
current_mode	int
=	O
GIT_SCREEN_MODE	int
;	O
if	O
(	O
app_end	int
)	O
continue	O
;	O
goto	O
restart	O
;	O
case	O
BUILTIN_copy	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_COPY	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_move	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_MOVE	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_make_directory	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_MKDIR	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_delete	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_DELETE	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_panel_enable_next_mode	O
:	O
case	O
BUILTIN_panel_enable_owner_group	O
:	O
case	O
BUILTIN_panel_enable_date_time	O
:	O
case	O
BUILTIN_panel_enable_abbrevsize	O
:	O
case	O
BUILTIN_panel_enable_size	O
:	O
case	O
BUILTIN_panel_enable_mode	O
:	O
case	O
BUILTIN_panel_enable_full_name	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_ENABLE_NEXT_MODE	int
-	O
(	O
key	int
-	O
BUILTIN_panel_enable_next_mode	O
)	O
,	O
NULL	O
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_panel_sort_next_method	O
:	O
case	O
BUILTIN_panel_sort_by_name	O
:	O
case	O
BUILTIN_panel_sort_by_extension	O
:	O
case	O
BUILTIN_panel_sort_by_size	O
:	O
case	O
BUILTIN_panel_sort_by_date	O
:	O
case	O
BUILTIN_panel_sort_by_mode	O
:	O
case	O
BUILTIN_panel_sort_by_owner_id	O
:	O
case	O
BUILTIN_panel_sort_by_group_id	O
:	O
case	O
BUILTIN_panel_sort_by_owner_name	O
:	O
case	O
BUILTIN_panel_sort_by_group_name	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_SORT_NEXT_METHOD	int
-	O
(	O
key	int
-	O
BUILTIN_panel_sort_next_method	O
)	O
,	O
NULL	O
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_exit	O
:	O
if	O
(	O
ConfirmOnExit	int
==	O
OFF	int
||	O
il_read_char	function
(	O
exit_msg	pointer
,	O
"yn"	pointer
,	O
IL_FREEZED	int
)	O
==	O
'y'	O
)	O
app_end	int
=	O
1	int
;	O
break	O
;	O
case	O
BUILTIN_entry_to_input_line	O
:	O
srcptr	pointer
=	O
panel_get_current_file_name	function
(	O
src_panel	pointer
)	O
;	O
ptr	pointer
=	O
xmalloc	function
(	O
1	int
+	O
1	int
+	O
strlen	function
(	O
srcptr	pointer
)	O
+	O
1	int
+	O
1	int
+	O
1	int
)	O
;	O
copy_to_cmdln	O
:	O
len	long
=	O
strlen	function
(	O
cmdln	pointer
)	O
;	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
if	O
(	O
(	O
len	long
!=	O
0	int
)	O
&&	O
(	O
(	O
cmdln	pointer
[	O
il_point	function
(	O
)	O
-	O
1	int
]	O
==	O
'/'	O
)	O
||	O
(	O
cmdln	pointer
[	O
il_point	function
(	O
)	O
-	O
1	int
]	O
==	O
' '	O
)	O
)	O
)	O
{	O
if	O
(	O
needs_quotes	function
(	O
srcptr	pointer
,	O
strlen	function
(	O
srcptr	pointer
)	O
)	O
)	O
sprintf	function
(	O
ptr	pointer
,	O
"\"%s\" "	pointer
,	O
srcptr	pointer
)	O
;	O
else	O
sprintf	function
(	O
ptr	pointer
,	O
"%s "	pointer
,	O
srcptr	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
needs_quotes	function
(	O
srcptr	pointer
,	O
strlen	function
(	O
srcptr	pointer
)	O
)	O
)	O
sprintf	function
(	O
ptr	pointer
,	O
" \"%s\" "	pointer
,	O
srcptr	pointer
)	O
;	O
else	O
sprintf	function
(	O
ptr	pointer
,	O
" %s "	pointer
,	O
srcptr	pointer
)	O
;	O
}	O
ptrlen	long
=	O
strlen	function
(	O
ptr	pointer
)	O
;	O
toprintable	function
(	O
ptr	pointer
,	O
strlen	function
(	O
ptr	pointer
)	O
)	O
;	O
il_insert_text	function
(	O
ptr	pointer
)	O
;	O
xfree	function
(	O
ptr	pointer
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_other_path_to_input_line	O
:	O
srcptr	pointer
=	O
dst_panel	pointer
->	O
path	pointer
;	O
ptr	pointer
=	O
xmalloc	function
(	O
1	int
+	O
1	int
+	O
dst_panel	pointer
->	O
pathlen	long
+	O
1	int
+	O
1	int
+	O
1	int
)	O
;	O
goto	O
copy_to_cmdln	O
;	O
case	O
BUILTIN_selected_entries_to_input_line	O
:	O
len	long
=	O
strlen	function
(	O
cmdln	pointer
)	O
;	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
panel_init_iterator	function
(	O
src_panel	pointer
)	O
;	O
while	O
(	O
(	O
entry	int
=	O
panel_get_next	function
(	O
src_panel	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
srcptr	pointer
=	O
src_panel	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
;	O
ptr	pointer
=	O
xmalloc	function
(	O
1	int
+	O
1	int
+	O
strlen	function
(	O
srcptr	pointer
)	O
+	O
1	int
+	O
1	int
+	O
1	int
)	O
;	O
if	O
(	O
needs_quotes	function
(	O
srcptr	pointer
,	O
strlen	function
(	O
srcptr	pointer
)	O
)	O
)	O
sprintf	function
(	O
ptr	pointer
,	O
" \"%s\""	pointer
,	O
srcptr	pointer
)	O
;	O
else	O
sprintf	function
(	O
ptr	pointer
,	O
" %s"	pointer
,	O
srcptr	pointer
)	O
;	O
ptrlen	long
=	O
strlen	function
(	O
ptr	pointer
)	O
;	O
len	long
+=	O
ptrlen	long
;	O
toprintable	function
(	O
ptr	pointer
,	O
ptrlen	long
)	O
;	O
il_insert_text	function
(	O
ptr	pointer
)	O
;	O
xfree	function
(	O
ptr	pointer
)	O
;	O
}	O
il_insert_text	function
(	O
" "	pointer
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_previous_history_element	O
:	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
repeat_count	int
;	O
i	int
++	O
)	O
{	O
il_history	function
(	O
IL_PREVIOUS	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_next_history_element	O
:	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
repeat_count	int
;	O
i	int
++	O
)	O
{	O
il_history	function
(	O
IL_NEXT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_switch_panels	O
:	O
if	O
(	O
(	O
repeat_count	int
&	O
1	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
two_panel_mode	int
)	O
break	O
;	O
panel_no_optimizations	function
(	O
src_panel	pointer
)	O
;	O
panel_no_optimizations	function
(	O
dst_panel	pointer
)	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_SWITCH	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
panel_update	function
(	O
src_panel	pointer
)	O
;	O
panel_update	function
(	O
dst_panel	pointer
)	O
;	O
break	O
;	O
case	O
BUILTIN_change_directory	O
:	O
if	O
(	O
il_read_line	function
(	O
"Directory: "	pointer
,	O
&	O
input	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
command	pointer
->	O
history	pointer
)	O
)	O
{	O
char	O
*	O
expanded_input	pointer
;	O
if	O
(	O
input	pointer
[	O
0	int
]	O
==	O
0	int
)	O
break	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_CHDIR	int
,	O
dst_panel	pointer
,	O
expanded_input	pointer
=	O
tilde_expand	function
(	O
input	pointer
)	O
,	O
1	int
)	O
;	O
dir_history_add	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
xfree	function
(	O
expanded_input	pointer
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
input	pointer
=	O
NULL	O
;	O
il_restore	function
(	O
saved_il	pointer
)	O
;	O
set_prompt	function
(	O
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_select_files_matching_pattern	O
:	O
if	O
(	O
il_read_line	function
(	O
"Select files matching one of the patterns: "	pointer
,	O
&	O
input	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
command	pointer
->	O
history	pointer
)	O
)	O
{	O
if	O
(	O
input	pointer
[	O
0	int
]	O
==	O
0	int
)	O
break	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_PATTERN_SELECT	int
,	O
dst_panel	pointer
,	O
input	pointer
,	O
1	int
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
input	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_unselect_files_matching_pattern	O
:	O
if	O
(	O
il_read_line	function
(	O
"Unselect files matching one of the patterns: "	pointer
,	O
&	O
input	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
command	pointer
->	O
history	pointer
)	O
)	O
{	O
if	O
(	O
input	pointer
[	O
0	int
]	O
==	O
0	int
)	O
break	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_PATTERN_UNSELECT	int
,	O
dst_panel	pointer
,	O
input	pointer
,	O
1	int
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
input	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_adapt_current_directory	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_CHDIR	int
,	O
dst_panel	pointer
,	O
dst_panel	pointer
->	O
path	pointer
,	O
1	int
)	O
;	O
dir_history_add	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
set_prompt	function
(	O
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_adapt_other_directory	O
:	O
panel_action	function
(	O
dst_panel	pointer
,	O
act_CHDIR	int
,	O
src_panel	pointer
,	O
src_panel	pointer
->	O
path	pointer
,	O
1	int
)	O
;	O
dir_history_add	function
(	O
panel_get_path	function
(	O
dst_panel	pointer
)	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_set_scroll_step	O
:	O
if	O
(	O
il_read_line	function
(	O
"Scroll step: "	pointer
,	O
&	O
input	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
command	pointer
->	O
history	pointer
)	O
)	O
{	O
if	O
(	O
input	pointer
[	O
0	int
]	O
==	O
0	int
)	O
break	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_SET_SCROLL_STEP	int
,	O
dst_panel	pointer
,	O
input	pointer
,	O
1	int
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
input	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_isearch_backward	O
:	O
previous_isearch_failed	int
=	O
0	int
;	O
resuming_previous_isearch	int
=	O
0	int
;	O
il_isearch	function
(	O
"I-search backward: "	pointer
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
IL_ISEARCH_BEGIN	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_ISEARCH_BEGIN	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
isearch_aux_t	struct
iai	struct
;	O
if	O
(	O
il_isearch	function
(	O
(	O
char	O
*	O
)	O
NULL	O
,	O
&	O
input	pointer
,	O
IL_ISEARCH_BACKWARD	int
,	O
&	O
iai	struct
.	O
action	int
)	O
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
strlen	function
(	O
input	pointer
)	O
==	O
0	int
&&	O
search_string	pointer
&&	O
strlen	function
(	O
search_string	pointer
)	O
)	O
{	O
xfree	function
(	O
input	pointer
)	O
;	O
input	pointer
=	O
strdup	function
(	O
search_string	pointer
)	O
;	O
il_insert_text	function
(	O
input	pointer
)	O
;	O
resuming_previous_isearch	int
=	O
1	int
;	O
previous_isearch_failed	int
=	O
0	int
;	O
}	O
if	O
(	O
iai	struct
.	O
action	int
==	O
IL_ISEARCH_ACTION_RETRY	int
&&	O
previous_isearch_failed	int
)	O
{	O
panel_set_wrapped_isearch_flag	function
(	O
src_panel	pointer
,	O
1	int
)	O
;	O
previous_isearch_failed	int
=	O
0	int
;	O
}	O
iai	struct
.	O
string	pointer
=	O
input	pointer
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_ISEARCH_BACKWARD	int
,	O
dst_panel	pointer
,	O
&	O
iai	struct
,	O
1	int
)	O
;	O
if	O
(	O
iai	struct
.	O
action	int
==	O
IL_ISEARCH_ACTION_FAILED	O
)	O
{	O
previous_isearch_failed	int
=	O
1	int
;	O
tty_beep	function
(	O
)	O
;	O
}	O
else	O
{	O
int	O
update	int
=	O
0	int
;	O
if	O
(	O
resuming_previous_isearch	int
)	O
if	O
(	O
iai	struct
.	O
length	long
<	O
strlen	function
(	O
search_string	pointer
)	O
)	O
{	O
il_kill_line	function
(	O
0	int
)	O
;	O
resuming_previous_isearch	int
=	O
0	int
;	O
update	int
=	O
1	int
;	O
}	O
if	O
(	O
iai	struct
.	O
length	long
<	O
strlen	function
(	O
input	pointer
)	O
)	O
{	O
il_backward_delete_char	function
(	O
)	O
;	O
update	int
=	O
1	int
;	O
}	O
if	O
(	O
update	int
)	O
{	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
search_string	pointer
)	O
xfree	function
(	O
search_string	pointer
)	O
;	O
if	O
(	O
input	pointer
==	O
NULL	O
)	O
break	O
;	O
search_string	pointer
=	O
strdup	function
(	O
input	pointer
)	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_ISEARCH_END	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
il_isearch	function
(	O
(	O
char	O
*	O
)	O
NULL	O
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
IL_ISEARCH_END	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_isearch_forward	O
:	O
previous_isearch_failed	int
=	O
0	int
;	O
resuming_previous_isearch	int
=	O
0	int
;	O
il_isearch	function
(	O
"I-search: "	pointer
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
IL_ISEARCH_BEGIN	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_ISEARCH_BEGIN	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
isearch_aux_t	struct
iai	struct
;	O
if	O
(	O
il_isearch	function
(	O
(	O
char	O
*	O
)	O
NULL	O
,	O
&	O
input	pointer
,	O
IL_ISEARCH_FORWARD	int
,	O
&	O
iai	struct
.	O
action	int
)	O
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
strlen	function
(	O
input	pointer
)	O
==	O
0	int
&&	O
search_string	pointer
&&	O
strlen	function
(	O
search_string	pointer
)	O
)	O
{	O
xfree	function
(	O
input	pointer
)	O
;	O
input	pointer
=	O
strdup	function
(	O
search_string	pointer
)	O
;	O
il_insert_text	function
(	O
input	pointer
)	O
;	O
resuming_previous_isearch	int
=	O
1	int
;	O
previous_isearch_failed	int
=	O
0	int
;	O
}	O
if	O
(	O
iai	struct
.	O
action	int
==	O
IL_ISEARCH_ACTION_RETRY	int
&&	O
previous_isearch_failed	int
)	O
{	O
tty_beep	function
(	O
)	O
;	O
panel_set_wrapped_isearch_flag	function
(	O
src_panel	pointer
,	O
1	int
)	O
;	O
previous_isearch_failed	int
=	O
0	int
;	O
}	O
iai	struct
.	O
string	pointer
=	O
input	pointer
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_ISEARCH_FORWARD	int
,	O
dst_panel	pointer
,	O
&	O
iai	struct
,	O
1	int
)	O
;	O
if	O
(	O
iai	struct
.	O
action	int
==	O
IL_ISEARCH_ACTION_FAILED	O
)	O
{	O
previous_isearch_failed	int
=	O
1	int
;	O
tty_beep	function
(	O
)	O
;	O
}	O
else	O
{	O
int	O
update	int
=	O
0	int
;	O
if	O
(	O
resuming_previous_isearch	int
)	O
if	O
(	O
iai	struct
.	O
length	long
<	O
strlen	function
(	O
search_string	pointer
)	O
)	O
{	O
il_kill_line	function
(	O
0	int
)	O
;	O
resuming_previous_isearch	int
=	O
0	int
;	O
update	int
=	O
1	int
;	O
}	O
if	O
(	O
iai	struct
.	O
length	long
<	O
strlen	function
(	O
input	pointer
)	O
)	O
{	O
il_backward_delete_char	function
(	O
)	O
;	O
update	int
=	O
1	int
;	O
}	O
if	O
(	O
update	int
)	O
{	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
search_string	pointer
)	O
xfree	function
(	O
search_string	pointer
)	O
;	O
if	O
(	O
input	pointer
==	O
NULL	O
)	O
break	O
;	O
search_string	pointer
=	O
strdup	function
(	O
input	pointer
)	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_ISEARCH_END	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
il_isearch	function
(	O
(	O
char	O
*	O
)	O
NULL	O
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
,	O
IL_ISEARCH_END	int
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_reset_directory_history	O
:	O
dir_history_reset	function
(	O
)	O
;	O
dir_history_add	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_previous_directory	O
:	O
dir_history_prev	function
(	O
src_panel	pointer
,	O
dst_panel	pointer
)	O
;	O
il_restore	function
(	O
saved_il	pointer
)	O
;	O
set_prompt	function
(	O
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_next_directory	O
:	O
dir_history_next	function
(	O
src_panel	pointer
,	O
dst_panel	pointer
)	O
;	O
il_restore	function
(	O
saved_il	pointer
)	O
;	O
set_prompt	function
(	O
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_enlarge_other_panel	O
:	O
one_panel_mode	O
:	O
panel_set_focus	function
(	O
src_panel	pointer
,	O
OFF	int
)	O
;	O
tmp_panel	pointer
=	O
src_panel	pointer
;	O
src_panel	pointer
=	O
dst_panel	pointer
;	O
dst_panel	pointer
=	O
tmp_panel	pointer
;	O
panel_no	int
=	O
!	O
panel_no	int
;	O
panel_set_focus	function
(	O
src_panel	pointer
,	O
ON	int
)	O
;	O
panel_activate	function
(	O
src_panel	pointer
)	O
;	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
set_prompt	function
(	O
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
case	O
BUILTIN_enlarge_panel	O
:	O
panel_no_optimizations	function
(	O
src_panel	pointer
)	O
;	O
panel_no_optimizations	function
(	O
dst_panel	pointer
)	O
;	O
tty_touch	function
(	O
)	O
;	O
panel_deactivate	function
(	O
dst_panel	pointer
)	O
;	O
two_panel_mode	int
=	O
0	int
;	O
resize	function
(	O
1	int
)	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_ENABLE_ALL	int
,	O
NULL	O
,	O
NULL	O
,	O
1	int
)	O
;	O
panel_action	function
(	O
dst_panel	pointer
,	O
act_ENABLE_ALL	int
,	O
NULL	O
,	O
NULL	O
,	O
1	int
)	O
;	O
panel_update	function
(	O
src_panel	pointer
)	O
;	O
break	O
;	O
case	O
BUILTIN_two_panels	O
:	O
panel_no_optimizations	function
(	O
src_panel	pointer
)	O
;	O
panel_no_optimizations	function
(	O
dst_panel	pointer
)	O
;	O
tty_touch	function
(	O
)	O
;	O
panel_activate	function
(	O
dst_panel	pointer
)	O
;	O
two_panel_mode	int
=	O
1	int
;	O
resize	function
(	O
1	int
)	O
;	O
if	O
(	O
tty_columns	int
<	O
6	int
*	O
2	int
)	O
refresh	function
(	O
1	int
)	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_ENABLE_SIZE	int
,	O
NULL	O
,	O
NULL	O
,	O
1	int
)	O
;	O
panel_action	function
(	O
dst_panel	pointer
,	O
act_ENABLE_SIZE	int
,	O
NULL	O
,	O
NULL	O
,	O
1	int
)	O
;	O
panel_update	function
(	O
src_panel	pointer
)	O
;	O
panel_update	function
(	O
dst_panel	pointer
)	O
;	O
break	O
;	O
case	O
BUILTIN_lock	O
:	O
il_echo	function
(	O
0	int
)	O
;	O
lock_password	pointer
=	O
NULL	O
;	O
il_read_line	function
(	O
"Enter a password: "	pointer
,	O
&	O
lock_password	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
(	O
xstack_t	struct
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
lock_password	pointer
==	O
NULL	O
||	O
*	O
lock_password	pointer
==	O
'\0'	O
)	O
{	O
il_echo	function
(	O
1	int
)	O
;	O
break	O
;	O
}	O
for	O
(	O
unlock_password	pointer
=	O
NULL	O
;	O
;	O
)	O
{	O
il_read_line	function
(	O
"Enter password to unlock: "	pointer
,	O
&	O
unlock_password	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
(	O
xstack_t	struct
*	O
)	O
NULL	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
unlock_password	pointer
&&	O
strcmp	function
(	O
lock_password	pointer
,	O
unlock_password	pointer
)	O
==	O
0	int
)	O
break	O
;	O
il_message	function
(	O
lock_bad	array
)	O
;	O
tty_beep	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
sleep	function
(	O
2	int
)	O
;	O
}	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
lock_password	pointer
)	O
;	O
xfree	function
(	O
unlock_password	pointer
)	O
;	O
il_echo	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_quick_compare_panels	O
:	O
cmp_mode	int
=	O
CMPDIR_QUICK	int
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_CMPDIR	int
,	O
dst_panel	pointer
,	O
&	O
cmp_mode	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_thorough_compare_panels	O
:	O
cmp_mode	int
=	O
CMPDIR_THOROUGH	int
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_CMPDIR	int
,	O
dst_panel	pointer
,	O
&	O
cmp_mode	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_name_downcase	O
:	O
to_case	int
=	O
CASE_DOWN	int
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_CASE	int
,	O
dst_panel	pointer
,	O
&	O
to_case	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_name_upcase	O
:	O
to_case	int
=	O
CASE_UP	int
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_CASE	int
,	O
dst_panel	pointer
,	O
&	O
to_case	int
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_up_one_dir	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_UP_ONE_DIR	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
il_restore	function
(	O
saved_il	pointer
)	O
;	O
set_prompt	function
(	O
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
tty_update_title	function
(	O
panel_get_path	function
(	O
src_panel	pointer
)	O
)	O
;	O
break	O
;	O
case	O
BUILTIN_compare	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_COMPARE	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_bin_packing	O
:	O
if	O
(	O
il_read_line	function
(	O
"Bin size (in Kb): "	pointer
,	O
&	O
input	pointer
,	O
"0"	pointer
,	O
command	pointer
->	O
history	pointer
)	O
)	O
{	O
if	O
(	O
input	pointer
[	O
0	int
]	O
==	O
0	int
)	O
break	O
;	O
panel_action	function
(	O
src_panel	pointer
,	O
act_BIN_PACKING	int
,	O
dst_panel	pointer
,	O
input	pointer
,	O
1	int
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
input	pointer
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
BUILTIN_horizontal_scroll_left	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_HORIZONTAL_SCROLL_LEFT	int
,	O
dst_panel	pointer
,	O
input	pointer
,	O
repeat_count	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_horizontal_scroll_right	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_HORIZONTAL_SCROLL_RIGHT	int
,	O
dst_panel	pointer
,	O
input	pointer
,	O
repeat_count	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_select_extension	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_SELECT_EXTENSION	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_unselect_extension	O
:	O
panel_action	function
(	O
src_panel	pointer
,	O
act_UNSELECT_EXTENSION	int
,	O
dst_panel	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
BUILTIN_apropos	O
:	O
aproposstr	pointer
=	O
NULL	O
;	O
il_read_line	function
(	O
"Apropos: "	pointer
,	O
&	O
aproposstr	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
command	pointer
->	O
history	pointer
)	O
;	O
if	O
(	O
aproposstr	pointer
)	O
{	O
if	O
(	O
*	O
aproposstr	pointer
!=	O
'\0'	O
)	O
{	O
extern	O
tty_key_t	struct
*	O
key_list_head	pointer
;	O
tty_key_t	struct
*	O
key	int
;	O
int	O
fd	int
;	O
FILE	struct
*	O
fp	pointer
=	O
NULL	O
;	O
int	O
gotmatch	int
=	O
0	int
;	O
char	O
*	O
template	pointer
=	O
"gnuit-apropos-XXXXXX"	pointer
;	O
char	O
*	O
tmpfn	pointer
;	O
tmpfn	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
temporary_directory	pointer
)	O
+	O
strlen	function
(	O
template	pointer
)	O
+	O
1	int
+	O
2	int
)	O
;	O
sprintf	function
(	O
tmpfn	pointer
,	O
"%s/%s"	pointer
,	O
temporary_directory	pointer
,	O
template	pointer
)	O
;	O
fd	int
=	O
mkstemp	function
(	O
tmpfn	pointer
)	O
;	O
if	O
(	O
fd	int
!=	O
-	O
1	int
)	O
fp	pointer
=	O
fdopen	function
(	O
fd	int
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
il_read_char	function
(	O
"Error opening temporary file"	pointer
,	O
NULL	O
,	O
IL_ERROR	int
|	O
IL_BEEP	int
)	O
;	O
break	O
;	O
}	O
for	O
(	O
key	int
=	O
key_list_head	pointer
;	O
key	int
;	O
key	int
=	O
key	int
->	O
next	pointer
)	O
{	O
command_t	struct
*	O
command	pointer
=	O
(	O
command_t	struct
*	O
)	O
key	int
->	O
aux_data	pointer
;	O
if	O
(	O
strcasestr	function
(	O
command	pointer
->	O
name	pointer
,	O
aproposstr	pointer
)	O
)	O
{	O
gotmatch	int
=	O
1	int
;	O
fprintf	function
(	O
fp	pointer
,	O
"%s: %s\n"	pointer
,	O
command	pointer
->	O
name	pointer
,	O
command	pointer
->	O
sequence	pointer
)	O
;	O
}	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
if	O
(	O
gotmatch	int
)	O
{	O
char	O
*	O
cmd	pointer
,	O
*	O
pager	pointer
;	O
pager	pointer
=	O
getenv	function
(	O
"GNUIT_PAGER"	pointer
)	O
;	O
if	O
(	O
!	O
pager	pointer
)	O
pager	pointer
=	O
"more"	pointer
;	O
cmd	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
pager	pointer
)	O
+	O
strlen	function
(	O
tmpfn	pointer
)	O
+	O
1	int
+	O
1	int
)	O
;	O
sprintf	function
(	O
cmd	pointer
,	O
"%s %s"	pointer
,	O
pager	pointer
,	O
tmpfn	pointer
)	O
;	O
start	function
(	O
cmd	pointer
,	O
0	int
)	O
;	O
xfree	function
(	O
cmd	pointer
)	O
;	O
wait_msg	int
=	O
1	int
;	O
}	O
else	O
il_read_char	function
(	O
"No matches"	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
unlink	function
(	O
tmpfn	pointer
)	O
;	O
xfree	function
(	O
tmpfn	pointer
)	O
;	O
}	O
xfree	function
(	O
aproposstr	pointer
)	O
;	O
goto	O
restart	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
key	int
)	O
{	O
il_free	function
(	O
saved_il	pointer
)	O
;	O
while	O
(	O
repeat_count	int
--	O
)	O
il_dispatch_commands	function
(	O
key	int
,	O
IL_MOVE	int
|	O
IL_EDIT	int
)	O
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
}	O
break	O
;	O
}	O
}	O
final_path	pointer
=	O
panel_get_path	function
(	O
src_panel	pointer
)	O
;	O
panel_end	function
(	O
left_panel	pointer
)	O
;	O
panel_end	function
(	O
right_panel	pointer
)	O
;	O
tty_set_mode	function
(	O
TTY_CANONIC	int
)	O
;	O
tty_defaults	function
(	O
)	O
;	O
if	O
(	O
il	pointer
)	O
il_end	function
(	O
)	O
;	O
status_end	function
(	O
)	O
;	O
remove_log	function
(	O
)	O
;	O
tty_end	function
(	O
screen	pointer
)	O
;	O
if	O
(	O
output_final_path	int
)	O
write	pointer
(	O
3	int
,	O
final_path	pointer
,	O
strlen	function
(	O
final_path	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
