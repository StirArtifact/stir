typedef	O
struct	O
File_t	struct
{	O
Class_t	struct
*	O
Class	pointer
;	O
int	O
refs	int
;	O
struct	O
Fs_t	struct
*	O
Fs	pointer
;	O
Stream_t	struct
*	O
Buffer	pointer
;	O
int	O
(	O
*	O
map	pointer
)	O
(	O
struct	O
File_t	struct
*	O
this	pointer
,	O
off_t	long
where	long
,	O
size_t	long
*	O
len	long
,	O
int	O
mode	int
,	O
mt_off_t	long
*	O
res	pointer
)	O
;	O
size_t	long
FileSize	long
;	O
size_t	long
preallocatedSize	long
;	O
int	O
preallocatedClusters	int
;	O
unsigned	O
int	O
FirstAbsCluNr	int
;	O
unsigned	O
int	O
PreviousAbsCluNr	int
;	O
unsigned	O
int	O
PreviousRelCluNr	int
;	O
direntry_t	struct
direntry	pointer
;	O
size_t	long
hint	pointer
;	O
struct	O
dirCache_t	struct
*	O
dcp	pointer
;	O
unsigned	O
int	O
loopDetectRel	int
;	O
unsigned	O
int	O
loopDetectAbs	int
;	O
}	O
File_t	struct
;	O
static	O
Class_t	struct
FileClass	struct
;	O
static	O
T_HashTable	struct
*	O
filehash	pointer
;	O
static	O
File_t	struct
*	O
getUnbufferedFile	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
while	O
(	O
Stream	pointer
->	O
Class	pointer
!=	O
&	O
FileClass	struct
)	O
Stream	pointer
=	O
Stream	pointer
->	O
Next	pointer
;	O
return	O
(	O
File_t	struct
*	O
)	O
Stream	pointer
;	O
}	O
Fs_t	struct
*	O
getFs	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
return	O
getUnbufferedFile	function
(	O
Stream	pointer
)	O
->	O
Fs	pointer
;	O
}	O
struct	O
dirCache_t	struct
*	O
*	O
getDirCacheP	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
return	O
&	O
getUnbufferedFile	function
(	O
Stream	pointer
)	O
->	O
dcp	pointer
;	O
}	O
direntry_t	struct
*	O
getDirentry	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
return	O
&	O
getUnbufferedFile	function
(	O
Stream	pointer
)	O
->	O
direntry	pointer
;	O
}	O
static	O
int	O
recalcPreallocSize	function
(	O
File_t	struct
*	O
This	pointer
)	O
{	O
size_t	long
currentClusters	long
,	O
neededClusters	long
;	O
unsigned	O
int	O
clus_size	int
;	O
int	O
neededPrealloc	int
;	O
Fs_t	struct
*	O
Fs	pointer
=	O
This	pointer
->	O
Fs	pointer
;	O
int	O
r	int
;	O
clus_size	int
=	O
Fs	pointer
->	O
cluster_size	int
*	O
Fs	pointer
->	O
sector_size	int
;	O
currentClusters	long
=	O
(	O
This	pointer
->	O
FileSize	long
+	O
clus_size	int
-	O
1	int
)	O
/	O
clus_size	int
;	O
neededClusters	long
=	O
(	O
This	pointer
->	O
preallocatedSize	long
+	O
clus_size	int
-	O
1	int
)	O
/	O
clus_size	int
;	O
neededPrealloc	int
=	O
neededClusters	long
-	O
currentClusters	long
;	O
if	O
(	O
neededPrealloc	int
<	O
0	int
)	O
neededPrealloc	int
=	O
0	int
;	O
r	int
=	O
fsPreallocateClusters	function
(	O
Fs	pointer
,	O
neededPrealloc	int
-	O
This	pointer
->	O
preallocatedClusters	int
)	O
;	O
if	O
(	O
r	int
)	O
return	O
r	int
;	O
This	pointer
->	O
preallocatedClusters	int
=	O
neededPrealloc	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_loopDetect	function
(	O
unsigned	O
int	O
*	O
oldrel	pointer
,	O
unsigned	O
int	O
rel	int
,	O
unsigned	O
int	O
*	O
oldabs	pointer
,	O
unsigned	O
int	O
absol	int
)	O
{	O
if	O
(	O
*	O
oldrel	pointer
&&	O
rel	int
>	O
*	O
oldrel	pointer
&&	O
absol	int
==	O
*	O
oldabs	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"loop detected! oldrel=%d newrel=%d abs=%d\n"	pointer
,	O
*	O
oldrel	pointer
,	O
rel	int
,	O
absol	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
rel	int
>=	O
2	int
*	O
*	O
oldrel	pointer
+	O
1	int
)	O
{	O
*	O
oldrel	pointer
=	O
rel	int
;	O
*	O
oldabs	pointer
=	O
absol	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
loopDetect	function
(	O
File_t	struct
*	O
This	pointer
,	O
unsigned	O
int	O
rel	int
,	O
unsigned	O
int	O
absol	int
)	O
{	O
return	O
_loopDetect	function
(	O
&	O
This	pointer
->	O
loopDetectRel	int
,	O
rel	int
,	O
&	O
This	pointer
->	O
loopDetectAbs	int
,	O
absol	int
)	O
;	O
}	O
static	O
unsigned	O
int	O
_countBlocks	function
(	O
Fs_t	struct
*	O
This	pointer
,	O
unsigned	O
int	O
block	int
)	O
{	O
unsigned	O
int	O
blocks	int
;	O
unsigned	O
int	O
rel	int
,	O
oldabs	pointer
,	O
oldrel	pointer
;	O
blocks	int
=	O
0	int
;	O
oldabs	pointer
=	O
oldrel	pointer
=	O
rel	int
=	O
0	int
;	O
while	O
(	O
block	int
<=	O
This	pointer
->	O
last_fat	int
&&	O
block	int
!=	O
1	int
&&	O
block	int
)	O
{	O
blocks	int
++	O
;	O
block	int
=	O
fatDecode	function
(	O
This	pointer
,	O
block	int
)	O
;	O
rel	int
++	O
;	O
if	O
(	O
_loopDetect	function
(	O
&	O
oldrel	pointer
,	O
rel	int
,	O
&	O
oldabs	pointer
,	O
block	int
)	O
<	O
0	int
)	O
block	int
=	O
1	int
;	O
}	O
return	O
blocks	int
;	O
}	O
unsigned	O
int	O
countBlocks	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
unsigned	O
int	O
block	int
)	O
{	O
Stream_t	struct
*	O
Stream	pointer
=	O
GetFs	function
(	O
Dir	pointer
)	O
;	O
DeclareThis	O
(	O
Fs_t	struct
)	O
;	O
return	O
_countBlocks	function
(	O
This	pointer
,	O
block	int
)	O
;	O
}	O
static	O
size_t	long
countBytes	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
unsigned	O
int	O
block	int
)	O
{	O
Stream_t	struct
*	O
Stream	pointer
=	O
GetFs	function
(	O
Dir	pointer
)	O
;	O
DeclareThis	O
(	O
Fs_t	struct
)	O
;	O
return	O
_countBlocks	function
(	O
This	pointer
,	O
block	int
)	O
*	O
This	pointer
->	O
sector_size	int
*	O
This	pointer
->	O
cluster_size	int
;	O
}	O
void	O
printFat	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
File_t	struct
*	O
This	pointer
=	O
getUnbufferedFile	function
(	O
Stream	pointer
)	O
;	O
unsigned	O
long	O
n	pointer
;	O
unsigned	O
int	O
rel	int
;	O
unsigned	O
long	O
begin	int
,	O
end	pointer
;	O
int	O
first	int
;	O
n	pointer
=	O
This	pointer
->	O
FirstAbsCluNr	int
;	O
if	O
(	O
!	O
n	pointer
)	O
{	O
printf	function
(	O
"Root directory or empty file\n"	pointer
)	O
;	O
return	O
;	O
}	O
rel	int
=	O
0	int
;	O
first	int
=	O
1	int
;	O
begin	int
=	O
end	pointer
=	O
0	int
;	O
do	O
{	O
if	O
(	O
first	int
||	O
n	pointer
!=	O
end	pointer
+	O
1	int
)	O
{	O
if	O
(	O
!	O
first	int
)	O
{	O
if	O
(	O
begin	int
!=	O
end	pointer
)	O
printf	function
(	O
"-%lu"	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
"> "	pointer
)	O
;	O
}	O
begin	int
=	O
end	pointer
=	O
n	pointer
;	O
printf	function
(	O
"<%lu"	pointer
,	O
begin	int
)	O
;	O
}	O
else	O
{	O
end	pointer
++	O
;	O
}	O
first	int
=	O
0	int
;	O
n	pointer
=	O
fatDecode	function
(	O
This	pointer
->	O
Fs	pointer
,	O
n	pointer
)	O
;	O
rel	int
++	O
;	O
if	O
(	O
loopDetect	function
(	O
This	pointer
,	O
rel	int
,	O
n	pointer
)	O
<	O
0	int
)	O
n	pointer
=	O
1	int
;	O
}	O
while	O
(	O
n	pointer
<=	O
This	pointer
->	O
Fs	pointer
->	O
last_fat	int
&&	O
n	pointer
!=	O
1	int
)	O
;	O
if	O
(	O
!	O
first	int
)	O
{	O
if	O
(	O
begin	int
!=	O
end	pointer
)	O
printf	function
(	O
"-%lu"	pointer
,	O
end	pointer
)	O
;	O
printf	function
(	O
">"	pointer
)	O
;	O
}	O
}	O
void	O
printFatWithOffset	function
(	O
Stream_t	struct
*	O
Stream	pointer
,	O
off_t	long
offset	long
)	O
{	O
File_t	struct
*	O
This	pointer
=	O
getUnbufferedFile	function
(	O
Stream	pointer
)	O
;	O
unsigned	O
long	O
n	pointer
;	O
int	O
rel	int
;	O
off_t	long
clusSize	long
;	O
n	pointer
=	O
This	pointer
->	O
FirstAbsCluNr	int
;	O
if	O
(	O
!	O
n	pointer
)	O
{	O
printf	function
(	O
"Root directory or empty file\n"	pointer
)	O
;	O
return	O
;	O
}	O
clusSize	long
=	O
This	pointer
->	O
Fs	pointer
->	O
cluster_size	int
*	O
This	pointer
->	O
Fs	pointer
->	O
sector_size	int
;	O
rel	int
=	O
0	int
;	O
while	O
(	O
offset	long
>=	O
clusSize	long
)	O
{	O
n	pointer
=	O
fatDecode	function
(	O
This	pointer
->	O
Fs	pointer
,	O
n	pointer
)	O
;	O
rel	int
++	O
;	O
if	O
(	O
loopDetect	function
(	O
This	pointer
,	O
rel	int
,	O
n	pointer
)	O
<	O
0	int
)	O
return	O
;	O
if	O
(	O
n	pointer
>	O
This	pointer
->	O
Fs	pointer
->	O
last_fat	int
)	O
return	O
;	O
offset	long
-=	O
clusSize	long
;	O
}	O
printf	function
(	O
"%lu"	pointer
,	O
n	pointer
)	O
;	O
}	O
static	O
int	O
normal_map	function
(	O
File_t	struct
*	O
This	pointer
,	O
off_t	long
where	long
,	O
size_t	long
*	O
len	long
,	O
int	O
mode	int
,	O
mt_off_t	long
*	O
res	pointer
)	O
{	O
unsigned	O
int	O
offset	long
;	O
size_t	long
end	pointer
;	O
int	O
NrClu	int
;	O
unsigned	O
int	O
RelCluNr	int
;	O
unsigned	O
int	O
CurCluNr	int
;	O
unsigned	O
int	O
NewCluNr	int
;	O
unsigned	O
int	O
AbsCluNr	int
;	O
unsigned	O
int	O
clus_size	int
;	O
Fs_t	struct
*	O
Fs	pointer
=	O
This	pointer
->	O
Fs	pointer
;	O
*	O
res	pointer
=	O
0	int
;	O
clus_size	int
=	O
Fs	pointer
->	O
cluster_size	int
*	O
Fs	pointer
->	O
sector_size	int
;	O
offset	long
=	O
where	long
%	O
clus_size	int
;	O
if	O
(	O
mode	int
==	O
MT_READ	int
)	O
maximize	O
(	O
*	O
len	long
,	O
This	pointer
->	O
FileSize	long
-	O
where	long
)	O
;	O
if	O
(	O
*	O
len	long
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
This	pointer
->	O
FirstAbsCluNr	int
<	O
2	int
)	O
{	O
if	O
(	O
mode	int
==	O
MT_READ	int
||	O
*	O
len	long
==	O
0	int
)	O
{	O
*	O
len	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
NewCluNr	int
=	O
get_next_free_cluster	function
(	O
This	pointer
->	O
Fs	pointer
,	O
1	int
)	O
;	O
if	O
(	O
NewCluNr	int
==	O
1	int
)	O
{	O
errno	O
=	O
ENOSPC	int
;	O
return	O
-	O
2	int
;	O
}	O
hash_remove	function
(	O
filehash	pointer
,	O
(	O
void	O
*	O
)	O
This	pointer
,	O
This	pointer
->	O
hint	pointer
)	O
;	O
This	pointer
->	O
FirstAbsCluNr	int
=	O
NewCluNr	int
;	O
hash_add	function
(	O
filehash	pointer
,	O
(	O
void	O
*	O
)	O
This	pointer
,	O
&	O
This	pointer
->	O
hint	pointer
)	O
;	O
fatAllocate	function
(	O
This	pointer
->	O
Fs	pointer
,	O
NewCluNr	int
,	O
Fs	pointer
->	O
end_fat	int
)	O
;	O
}	O
RelCluNr	int
=	O
where	long
/	O
clus_size	int
;	O
if	O
(	O
RelCluNr	int
>=	O
This	pointer
->	O
PreviousRelCluNr	int
)	O
{	O
CurCluNr	int
=	O
This	pointer
->	O
PreviousRelCluNr	int
;	O
AbsCluNr	int
=	O
This	pointer
->	O
PreviousAbsCluNr	int
;	O
}	O
else	O
{	O
CurCluNr	int
=	O
0	int
;	O
AbsCluNr	int
=	O
This	pointer
->	O
FirstAbsCluNr	int
;	O
}	O
NrClu	int
=	O
(	O
offset	long
+	O
*	O
len	long
-	O
1	int
)	O
/	O
clus_size	int
;	O
while	O
(	O
CurCluNr	int
<=	O
RelCluNr	int
+	O
NrClu	int
)	O
{	O
if	O
(	O
CurCluNr	int
==	O
RelCluNr	int
)	O
{	O
This	pointer
->	O
PreviousRelCluNr	int
=	O
RelCluNr	int
;	O
This	pointer
->	O
PreviousAbsCluNr	int
=	O
AbsCluNr	int
;	O
}	O
NewCluNr	int
=	O
fatDecode	function
(	O
This	pointer
->	O
Fs	pointer
,	O
AbsCluNr	int
)	O
;	O
if	O
(	O
NewCluNr	int
==	O
1	int
||	O
NewCluNr	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Fat problem while decoding %d %x\n"	pointer
,	O
AbsCluNr	int
,	O
NewCluNr	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
CurCluNr	int
==	O
RelCluNr	int
+	O
NrClu	int
)	O
break	O
;	O
if	O
(	O
NewCluNr	int
>	O
Fs	pointer
->	O
last_fat	int
&&	O
mode	int
==	O
MT_WRITE	int
)	O
{	O
NewCluNr	int
=	O
get_next_free_cluster	function
(	O
This	pointer
->	O
Fs	pointer
,	O
AbsCluNr	int
)	O
;	O
if	O
(	O
NewCluNr	int
==	O
1	int
)	O
{	O
errno	O
=	O
ENOSPC	int
;	O
return	O
-	O
2	int
;	O
}	O
fatAppend	function
(	O
This	pointer
->	O
Fs	pointer
,	O
AbsCluNr	int
,	O
NewCluNr	int
)	O
;	O
}	O
if	O
(	O
CurCluNr	int
<	O
RelCluNr	int
&&	O
NewCluNr	int
>	O
Fs	pointer
->	O
last_fat	int
)	O
{	O
*	O
len	long
=	O
0	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
CurCluNr	int
>=	O
RelCluNr	int
&&	O
NewCluNr	int
!=	O
AbsCluNr	int
+	O
1	int
)	O
break	O
;	O
CurCluNr	int
++	O
;	O
AbsCluNr	int
=	O
NewCluNr	int
;	O
if	O
(	O
loopDetect	function
(	O
This	pointer
,	O
CurCluNr	int
,	O
AbsCluNr	int
)	O
)	O
{	O
errno	O
=	O
EIO	int
;	O
return	O
-	O
2	int
;	O
}	O
}	O
maximize	O
(	O
*	O
len	long
,	O
(	O
1	int
+	O
CurCluNr	int
-	O
RelCluNr	int
)	O
*	O
clus_size	int
-	O
offset	long
)	O
;	O
end	pointer
=	O
where	long
+	O
*	O
len	long
;	O
if	O
(	O
batchmode	int
&&	O
mode	int
==	O
MT_WRITE	int
&&	O
end	pointer
>=	O
This	pointer
->	O
FileSize	long
)	O
{	O
*	O
len	long
+=	O
ROUND_UP	O
(	O
end	pointer
,	O
clus_size	int
)	O
-	O
end	pointer
;	O
}	O
if	O
(	O
(	O
*	O
len	long
+	O
offset	long
)	O
/	O
clus_size	int
+	O
This	pointer
->	O
PreviousAbsCluNr	int
-	O
2	int
>	O
Fs	pointer
->	O
num_clus	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"cluster too big\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
*	O
res	pointer
=	O
sectorsToBytes	function
(	O
(	O
Stream_t	struct
*	O
)	O
Fs	pointer
,	O
(	O
This	pointer
->	O
PreviousAbsCluNr	int
-	O
2	int
)	O
*	O
Fs	pointer
->	O
cluster_size	int
+	O
Fs	pointer
->	O
clus_start	int
)	O
+	O
offset	long
;	O
return	O
1	int
;	O
}	O
static	O
int	O
root_map	function
(	O
File_t	struct
*	O
This	pointer
,	O
off_t	long
where	long
,	O
size_t	long
*	O
len	long
,	O
int	O
mode	int
UNUSEDP	O
,	O
mt_off_t	long
*	O
res	pointer
)	O
{	O
Fs_t	struct
*	O
Fs	pointer
=	O
This	pointer
->	O
Fs	pointer
;	O
if	O
(	O
Fs	pointer
->	O
dir_len	int
*	O
Fs	pointer
->	O
sector_size	int
<	O
(	O
size_t	long
)	O
where	long
)	O
{	O
*	O
len	long
=	O
0	int
;	O
errno	O
=	O
ENOSPC	int
;	O
return	O
-	O
2	int
;	O
}	O
sizemaximize	O
(	O
*	O
len	long
,	O
Fs	pointer
->	O
dir_len	int
*	O
Fs	pointer
->	O
sector_size	int
-	O
where	long
)	O
;	O
if	O
(	O
*	O
len	long
==	O
0	int
)	O
return	O
0	int
;	O
*	O
res	pointer
=	O
sectorsToBytes	function
(	O
(	O
Stream_t	struct
*	O
)	O
Fs	pointer
,	O
Fs	pointer
->	O
dir_start	int
)	O
+	O
where	long
;	O
return	O
1	int
;	O
}	O
static	O
int	O
read_file	function
(	O
Stream_t	struct
*	O
Stream	pointer
,	O
char	O
*	O
buf	pointer
,	O
mt_off_t	long
iwhere	long
,	O
size_t	long
len	long
)	O
{	O
DeclareThis	O
(	O
File_t	struct
)	O
;	O
mt_off_t	long
pos	array
;	O
int	O
err	long
;	O
off_t	long
where	long
=	O
truncBytes32	function
(	O
iwhere	long
)	O
;	O
Stream_t	struct
*	O
Disk	pointer
=	O
This	pointer
->	O
Fs	pointer
->	O
Next	pointer
;	O
err	long
=	O
This	pointer
->	O
map	pointer
(	O
This	pointer
,	O
where	long
,	O
&	O
len	long
,	O
MT_READ	int
,	O
&	O
pos	array
)	O
;	O
if	O
(	O
err	long
<=	O
0	int
)	O
return	O
err	long
;	O
return	O
READS	O
(	O
Disk	pointer
,	O
buf	pointer
,	O
pos	array
,	O
len	long
)	O
;	O
}	O
static	O
int	O
write_file	function
(	O
Stream_t	struct
*	O
Stream	pointer
,	O
char	O
*	O
buf	pointer
,	O
mt_off_t	long
iwhere	long
,	O
size_t	long
len	long
)	O
{	O
DeclareThis	O
(	O
File_t	struct
)	O
;	O
mt_off_t	long
pos	array
;	O
int	O
ret	int
;	O
size_t	long
requestedLen	long
;	O
Stream_t	struct
*	O
Disk	pointer
=	O
This	pointer
->	O
Fs	pointer
->	O
Next	pointer
;	O
off_t	long
where	long
=	O
truncBytes32	function
(	O
iwhere	long
)	O
;	O
int	O
err	long
;	O
requestedLen	long
=	O
len	long
;	O
err	long
=	O
This	pointer
->	O
map	pointer
(	O
This	pointer
,	O
where	long
,	O
&	O
len	long
,	O
MT_WRITE	int
,	O
&	O
pos	array
)	O
;	O
if	O
(	O
err	long
<=	O
0	int
)	O
return	O
err	long
;	O
if	O
(	O
batchmode	int
)	O
ret	int
=	O
force_write	function
(	O
Disk	pointer
,	O
buf	pointer
,	O
pos	array
,	O
len	long
)	O
;	O
else	O
ret	int
=	O
WRITES	O
(	O
Disk	pointer
,	O
buf	pointer
,	O
pos	array
,	O
len	long
)	O
;	O
if	O
(	O
ret	int
>	O
(	O
signed	O
int	O
)	O
requestedLen	long
)	O
ret	int
=	O
requestedLen	long
;	O
if	O
(	O
ret	int
>	O
0	int
&&	O
where	long
+	O
ret	int
>	O
(	O
off_t	long
)	O
This	pointer
->	O
FileSize	long
)	O
This	pointer
->	O
FileSize	long
=	O
where	long
+	O
ret	int
;	O
recalcPreallocSize	function
(	O
This	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
month	array
[	O
]	O
=	O
{	O
0	int
,	O
31	int
,	O
59	int
,	O
90	int
,	O
120	int
,	O
151	int
,	O
181	int
,	O
212	int
,	O
243	int
,	O
273	int
,	O
304	int
,	O
334	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
__inline__	O
time_t	long
conv_stamp	function
(	O
struct	O
directory	struct
*	O
dir	pointer
)	O
{	O
struct	O
tm	struct
*	O
tmbuf	pointer
;	O
long	O
tzone	long
,	O
dst	long
;	O
time_t	long
accum	long
,	O
tmp	long
;	O
accum	long
=	O
DOS_YEAR	O
(	O
dir	pointer
)	O
-	O
1970	int
;	O
accum	long
=	O
accum	long
*	O
365L	int
+	O
month	array
[	O
DOS_MONTH	O
(	O
dir	pointer
)	O
-	O
1	int
]	O
+	O
DOS_DAY	O
(	O
dir	pointer
)	O
;	O
accum	long
+=	O
(	O
DOS_YEAR	O
(	O
dir	pointer
)	O
-	O
1972	int
)	O
/	O
4L	int
;	O
if	O
(	O
!	O
(	O
DOS_YEAR	O
(	O
dir	pointer
)	O
%	O
4	int
)	O
&&	O
DOS_MONTH	O
(	O
dir	pointer
)	O
<	O
3	int
)	O
accum	long
--	O
;	O
accum	long
=	O
accum	long
*	O
24L	int
+	O
DOS_HOUR	O
(	O
dir	pointer
)	O
;	O
accum	long
=	O
accum	long
*	O
60L	int
+	O
DOS_MINUTE	O
(	O
dir	pointer
)	O
;	O
accum	long
=	O
accum	long
*	O
60L	int
+	O
DOS_SEC	O
(	O
dir	pointer
)	O
;	O
{	O
extern	O
long	O
timezone	struct
;	O
tzset	function
(	O
)	O
;	O
tzone	long
=	O
(	O
long	O
)	O
timezone	struct
;	O
}	O
accum	long
+=	O
tzone	long
;	O
tmp	long
=	O
accum	long
;	O
tmbuf	pointer
=	O
localtime	function
(	O
&	O
tmp	long
)	O
;	O
if	O
(	O
tmbuf	pointer
)	O
{	O
dst	long
=	O
(	O
tmbuf	pointer
->	O
tm_isdst	int
)	O
?	O
(	O
-	O
60L	int
*	O
60L	int
)	O
:	O
0L	int
;	O
accum	long
+=	O
dst	long
;	O
}	O
return	O
accum	long
;	O
}	O
static	O
int	O
get_file_data	function
(	O
Stream_t	struct
*	O
Stream	pointer
,	O
time_t	long
*	O
date	array
,	O
mt_size_t	long
*	O
size	array
,	O
int	O
*	O
type	enum
,	O
int	O
*	O
address	long
)	O
{	O
DeclareThis	O
(	O
File_t	struct
)	O
;	O
if	O
(	O
date	array
)	O
*	O
date	array
=	O
conv_stamp	function
(	O
&	O
This	pointer
->	O
direntry	pointer
.	O
dir	pointer
)	O
;	O
if	O
(	O
size	array
)	O
*	O
size	array
=	O
(	O
mt_size_t	long
)	O
This	pointer
->	O
FileSize	long
;	O
if	O
(	O
type	enum
)	O
*	O
type	enum
=	O
This	pointer
->	O
direntry	pointer
.	O
dir	pointer
.	O
attr	char
&	O
ATTR_DIR	int
;	O
if	O
(	O
address	long
)	O
*	O
address	long
=	O
This	pointer
->	O
FirstAbsCluNr	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
free_file	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
DeclareThis	O
(	O
File_t	struct
)	O
;	O
Fs_t	struct
*	O
Fs	pointer
=	O
This	pointer
->	O
Fs	pointer
;	O
fsPreallocateClusters	function
(	O
Fs	pointer
,	O
-	O
This	pointer
->	O
preallocatedClusters	int
)	O
;	O
FREE	O
(	O
&	O
This	pointer
->	O
direntry	pointer
.	O
Dir	pointer
)	O
;	O
freeDirCache	function
(	O
Stream	pointer
)	O
;	O
return	O
hash_remove	function
(	O
filehash	pointer
,	O
(	O
void	O
*	O
)	O
Stream	pointer
,	O
This	pointer
->	O
hint	pointer
)	O
;	O
}	O
static	O
int	O
flush_file	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
DeclareThis	O
(	O
File_t	struct
)	O
;	O
direntry_t	struct
*	O
entry	int
=	O
&	O
This	pointer
->	O
direntry	pointer
;	O
if	O
(	O
isRootDir	function
(	O
Stream	pointer
)	O
)	O
{	O
return	O
0	int
;	O
}	O
if	O
(	O
This	pointer
->	O
FirstAbsCluNr	int
!=	O
getStart	function
(	O
entry	int
->	O
Dir	pointer
,	O
&	O
entry	int
->	O
dir	pointer
)	O
)	O
{	O
set_word	function
(	O
entry	int
->	O
dir	pointer
.	O
start	array
,	O
This	pointer
->	O
FirstAbsCluNr	int
&	O
0xffff	int
)	O
;	O
set_word	function
(	O
entry	int
->	O
dir	pointer
.	O
startHi	array
,	O
This	pointer
->	O
FirstAbsCluNr	int
>>	O
16	int
)	O
;	O
dir_write	function
(	O
entry	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
pre_allocate_file	function
(	O
Stream_t	struct
*	O
Stream	pointer
,	O
mt_size_t	long
isize	long
)	O
{	O
DeclareThis	O
(	O
File_t	struct
)	O
;	O
size_t	long
size	array
=	O
truncBytes32	function
(	O
isize	long
)	O
;	O
if	O
(	O
size	array
>	O
This	pointer
->	O
FileSize	long
&&	O
size	array
>	O
This	pointer
->	O
preallocatedSize	long
)	O
{	O
This	pointer
->	O
preallocatedSize	long
=	O
size	array
;	O
return	O
recalcPreallocSize	function
(	O
This	pointer
)	O
;	O
}	O
else	O
return	O
0	int
;	O
}	O
static	O
Class_t	struct
FileClass	struct
=	O
{	O
read_file	function
,	O
write_file	function
,	O
flush_file	function
,	O
free_file	function
,	O
0	int
,	O
get_file_data	function
,	O
pre_allocate_file	function
,	O
get_dosConvert_pass_through	function
,	O
0	int
}	O
;	O
static	O
unsigned	O
int	O
getAbsCluNr	function
(	O
File_t	struct
*	O
This	pointer
)	O
{	O
if	O
(	O
This	pointer
->	O
FirstAbsCluNr	int
)	O
return	O
This	pointer
->	O
FirstAbsCluNr	int
;	O
if	O
(	O
isRootDir	function
(	O
(	O
Stream_t	struct
*	O
)	O
This	pointer
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
size_t	long
func1	function
(	O
void	O
*	O
Stream	pointer
)	O
{	O
DeclareThis	O
(	O
File_t	struct
)	O
;	O
return	O
getAbsCluNr	function
(	O
This	pointer
)	O
^	O
(	O
long	O
)	O
This	pointer
->	O
Fs	pointer
;	O
}	O
static	O
size_t	long
func2	function
(	O
void	O
*	O
Stream	pointer
)	O
{	O
DeclareThis	O
(	O
File_t	struct
)	O
;	O
return	O
getAbsCluNr	function
(	O
This	pointer
)	O
;	O
}	O
static	O
int	O
comp	function
(	O
void	O
*	O
Stream	pointer
,	O
void	O
*	O
Stream2	pointer
)	O
{	O
DeclareThis	O
(	O
File_t	struct
)	O
;	O
File_t	struct
*	O
This2	pointer
=	O
(	O
File_t	struct
*	O
)	O
Stream2	pointer
;	O
return	O
This	pointer
->	O
Fs	pointer
!=	O
This2	pointer
->	O
Fs	pointer
||	O
getAbsCluNr	function
(	O
This	pointer
)	O
!=	O
getAbsCluNr	function
(	O
This2	pointer
)	O
;	O
}	O
static	O
void	O
init_hash	function
(	O
void	O
)	O
{	O
static	O
int	O
is_initialised	int
=	O
0	int
;	O
if	O
(	O
!	O
is_initialised	int
)	O
{	O
make_ht	function
(	O
func1	function
,	O
func2	function
,	O
comp	function
,	O
20	int
,	O
&	O
filehash	pointer
)	O
;	O
is_initialised	int
=	O
1	int
;	O
}	O
}	O
static	O
Stream_t	struct
*	O
_internalFileOpen	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
unsigned	O
int	O
first	int
,	O
size_t	long
size	array
,	O
direntry_t	struct
*	O
entry	int
)	O
{	O
Stream_t	struct
*	O
Stream	pointer
=	O
GetFs	function
(	O
Dir	pointer
)	O
;	O
DeclareThis	O
(	O
Fs_t	struct
)	O
;	O
File_t	struct
Pattern	struct
;	O
File_t	struct
*	O
File	pointer
;	O
init_hash	function
(	O
)	O
;	O
This	pointer
->	O
refs	int
++	O
;	O
if	O
(	O
first	int
!=	O
1	int
)	O
{	O
Pattern	struct
.	O
Fs	pointer
=	O
This	pointer
;	O
Pattern	struct
.	O
Class	pointer
=	O
&	O
FileClass	struct
;	O
if	O
(	O
first	int
||	O
(	O
entry	int
&&	O
!	O
IS_DIR	O
(	O
entry	int
)	O
)	O
)	O
Pattern	struct
.	O
map	pointer
=	O
normal_map	function
;	O
else	O
Pattern	struct
.	O
map	pointer
=	O
root_map	function
;	O
Pattern	struct
.	O
FirstAbsCluNr	int
=	O
first	int
;	O
Pattern	struct
.	O
loopDetectRel	int
=	O
0	int
;	O
Pattern	struct
.	O
loopDetectAbs	int
=	O
first	int
;	O
if	O
(	O
!	O
hash_lookup	function
(	O
filehash	pointer
,	O
(	O
T_HashTableEl	pointer
)	O
&	O
Pattern	struct
,	O
(	O
T_HashTableEl	pointer
*	O
*	O
)	O
&	O
File	pointer
,	O
0	int
)	O
)	O
{	O
File	pointer
->	O
refs	int
++	O
;	O
This	pointer
->	O
refs	int
--	O
;	O
return	O
(	O
Stream_t	struct
*	O
)	O
File	pointer
;	O
}	O
}	O
File	pointer
=	O
New	O
(	O
File_t	struct
)	O
;	O
if	O
(	O
!	O
File	pointer
)	O
return	O
NULL	O
;	O
File	pointer
->	O
dcp	pointer
=	O
0	int
;	O
File	pointer
->	O
preallocatedClusters	int
=	O
0	int
;	O
File	pointer
->	O
preallocatedSize	long
=	O
0	int
;	O
File	pointer
->	O
direntry	pointer
=	O
*	O
entry	int
;	O
if	O
(	O
entry	int
->	O
entry	int
==	O
-	O
3	int
)	O
File	pointer
->	O
direntry	pointer
.	O
Dir	pointer
=	O
(	O
Stream_t	struct
*	O
)	O
File	pointer
;	O
else	O
COPY	O
(	O
File	pointer
->	O
direntry	pointer
.	O
Dir	pointer
)	O
;	O
File	pointer
->	O
Class	pointer
=	O
&	O
FileClass	struct
;	O
File	pointer
->	O
Fs	pointer
=	O
This	pointer
;	O
if	O
(	O
first	int
||	O
(	O
entry	int
&&	O
!	O
IS_DIR	O
(	O
entry	int
)	O
)	O
)	O
File	pointer
->	O
map	pointer
=	O
normal_map	function
;	O
else	O
File	pointer
->	O
map	pointer
=	O
root_map	function
;	O
if	O
(	O
first	int
==	O
1	int
)	O
File	pointer
->	O
FirstAbsCluNr	int
=	O
0	int
;	O
else	O
File	pointer
->	O
FirstAbsCluNr	int
=	O
first	int
;	O
File	pointer
->	O
loopDetectRel	int
=	O
0	int
;	O
File	pointer
->	O
loopDetectAbs	int
=	O
0	int
;	O
File	pointer
->	O
PreviousRelCluNr	int
=	O
0xffff	int
;	O
File	pointer
->	O
FileSize	long
=	O
size	array
;	O
File	pointer
->	O
refs	int
=	O
1	int
;	O
File	pointer
->	O
Buffer	pointer
=	O
0	int
;	O
hash_add	function
(	O
filehash	pointer
,	O
(	O
void	O
*	O
)	O
File	pointer
,	O
&	O
File	pointer
->	O
hint	pointer
)	O
;	O
return	O
(	O
Stream_t	struct
*	O
)	O
File	pointer
;	O
}	O
Stream_t	struct
*	O
OpenRoot	function
(	O
Stream_t	struct
*	O
Dir	pointer
)	O
{	O
unsigned	O
int	O
num	int
;	O
direntry_t	struct
entry	int
;	O
size_t	long
size	array
;	O
Stream_t	struct
*	O
file	pointer
;	O
memset	function
(	O
&	O
entry	int
,	O
0	int
,	O
sizeof	O
(	O
direntry_t	struct
)	O
)	O
;	O
num	int
=	O
fat32RootCluster	function
(	O
Dir	pointer
)	O
;	O
entry	int
.	O
entry	int
=	O
-	O
3	int
;	O
entry	int
.	O
name	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
mk_entry_from_base	function
(	O
"/"	pointer
,	O
ATTR_DIR	int
,	O
num	int
,	O
0	int
,	O
0	int
,	O
&	O
entry	int
.	O
dir	pointer
)	O
;	O
if	O
(	O
num	int
)	O
size	array
=	O
countBytes	function
(	O
Dir	pointer
,	O
num	int
)	O
;	O
else	O
{	O
Fs_t	struct
*	O
Fs	pointer
=	O
(	O
Fs_t	struct
*	O
)	O
GetFs	function
(	O
Dir	pointer
)	O
;	O
size	array
=	O
Fs	pointer
->	O
dir_len	int
*	O
Fs	pointer
->	O
sector_size	int
;	O
}	O
file	pointer
=	O
_internalFileOpen	function
(	O
Dir	pointer
,	O
num	int
,	O
size	array
,	O
&	O
entry	int
)	O
;	O
bufferize	function
(	O
&	O
file	pointer
)	O
;	O
return	O
file	pointer
;	O
}	O
Stream_t	struct
*	O
OpenFileByDirentry	function
(	O
direntry_t	struct
*	O
entry	int
)	O
{	O
Stream_t	struct
*	O
file	pointer
;	O
unsigned	O
int	O
first	int
;	O
size_t	long
size	array
;	O
first	int
=	O
getStart	function
(	O
entry	int
->	O
Dir	pointer
,	O
&	O
entry	int
->	O
dir	pointer
)	O
;	O
if	O
(	O
!	O
first	int
&&	O
IS_DIR	O
(	O
entry	int
)	O
)	O
return	O
OpenRoot	function
(	O
entry	int
->	O
Dir	pointer
)	O
;	O
if	O
(	O
IS_DIR	O
(	O
entry	int
)	O
)	O
size	array
=	O
countBytes	function
(	O
entry	int
->	O
Dir	pointer
,	O
first	int
)	O
;	O
else	O
size	array
=	O
FILE_SIZE	O
(	O
&	O
entry	int
->	O
dir	pointer
)	O
;	O
file	pointer
=	O
_internalFileOpen	function
(	O
entry	int
->	O
Dir	pointer
,	O
first	int
,	O
size	array
,	O
entry	int
)	O
;	O
if	O
(	O
IS_DIR	O
(	O
entry	int
)	O
)	O
{	O
bufferize	function
(	O
&	O
file	pointer
)	O
;	O
if	O
(	O
first	int
==	O
1	int
)	O
dir_grow	function
(	O
file	pointer
,	O
0	int
)	O
;	O
}	O
return	O
file	pointer
;	O
}	O
int	O
isRootDir	function
(	O
Stream_t	struct
*	O
Stream	pointer
)	O
{	O
File_t	struct
*	O
This	pointer
=	O
getUnbufferedFile	function
(	O
Stream	pointer
)	O
;	O
return	O
This	pointer
->	O
map	pointer
==	O
root_map	function
;	O
}	O
