static	O
void	O
initialize_supplementary_dragon_data	function
(	O
void	O
)	O
;	O
static	O
void	O
find_lunches	function
(	O
void	O
)	O
;	O
static	O
void	O
eye_computations	function
(	O
void	O
)	O
;	O
static	O
void	O
revise_inessentiality	function
(	O
void	O
)	O
;	O
static	O
void	O
find_neighbor_dragons	function
(	O
void	O
)	O
;	O
static	O
void	O
add_adjacent_dragons	function
(	O
int	O
a	char
,	O
int	O
b	char
)	O
;	O
static	O
void	O
add_adjacent_dragon	function
(	O
int	O
a	char
,	O
int	O
b	char
)	O
;	O
static	O
int	O
dragon_invincible	function
(	O
int	O
pos	int
)	O
;	O
static	O
int	O
dragon_looks_inessential	function
(	O
int	O
origin	int
)	O
;	O
static	O
void	O
identify_thrashing_dragons	function
(	O
void	O
)	O
;	O
static	O
void	O
analyze_false_eye_territory	function
(	O
void	O
)	O
;	O
static	O
int	O
connected_to_eye	function
(	O
int	O
pos	int
,	O
int	O
str	int
,	O
int	O
color	int
,	O
int	O
eye_color	int
,	O
struct	O
eye_data	struct
*	O
eye	array
)	O
;	O
static	O
void	O
connected_to_eye_recurse	function
(	O
int	O
pos	int
,	O
int	O
str	int
,	O
int	O
color	int
,	O
int	O
eye_color	int
,	O
struct	O
eye_data	struct
*	O
eye	array
,	O
signed	O
char	O
*	O
mx	array
,	O
signed	O
char	O
*	O
me	pointer
,	O
int	O
*	O
halfeyes	pointer
)	O
;	O
static	O
enum	O
dragon_status	function
compute_crude_status	function
(	O
int	O
pos	int
)	O
;	O
static	O
int	O
compute_escape	function
(	O
int	O
pos	int
,	O
int	O
dragon_status_known	int
)	O
;	O
static	O
void	O
compute_surrounding_moyo_sizes	function
(	O
const	O
struct	O
influence_data	O
*	O
q	pointer
)	O
;	O
static	O
void	O
clear_cut_list	function
(	O
void	O
)	O
;	O
static	O
int	O
dragon2_initialized	int
;	O
static	O
int	O
lively_white_dragons	int
;	O
static	O
int	O
lively_black_dragons	int
;	O
static	O
int	O
next_worm_list	array
[	O
BOARDMAX	O
]	O
;	O
struct	O
dragon_data2	struct
*	O
dragon2_func	function
(	O
int	O
pos	int
)	O
{	O
ASSERT1	O
(	O
ON_BOARD1	O
(	O
pos	int
)	O
&&	O
dragon	int
[	O
pos	int
]	O
.	O
id	int
>=	O
0	int
&&	O
dragon	int
[	O
pos	int
]	O
.	O
id	int
<	O
number_of_dragons	int
,	O
pos	int
)	O
;	O
return	O
&	O
dragon2	pointer
[	O
dragon	int
[	O
pos	int
]	O
.	O
id	int
]	O
;	O
}	O
void	O
make_dragons	function
(	O
int	O
stop_before_owl	int
)	O
{	O
int	O
str	int
;	O
int	O
d	int
;	O
dragon2_initialized	int
=	O
0	int
;	O
initialize_dragon_data	function
(	O
)	O
;	O
memset	function
(	O
cutting_points	array
,	O
0	int
,	O
sizeof	O
(	O
cutting_points	array
)	O
)	O
;	O
find_cuts	function
(	O
)	O
;	O
find_connections	function
(	O
)	O
;	O
initialize_supplementary_dragon_data	function
(	O
)	O
;	O
make_domains	function
(	O
black_eye	array
,	O
white_eye	array
,	O
0	int
)	O
;	O
find_lunches	function
(	O
)	O
;	O
find_half_and_false_eyes	function
(	O
BLACK	int
,	O
black_eye	array
,	O
half_eye	array
,	O
NULL	O
)	O
;	O
find_half_and_false_eyes	function
(	O
WHITE	int
,	O
white_eye	array
,	O
half_eye	array
,	O
NULL	O
)	O
;	O
eye_computations	function
(	O
)	O
;	O
analyze_false_eye_territory	function
(	O
)	O
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
compute_dragon_genus	function
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
,	O
&	O
dragon2	pointer
[	O
d	int
]	O
.	O
genus	pointer
,	O
NO_MOVE	O
)	O
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
&&	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
==	O
str	int
)	O
DRAGON2	O
(	O
str	int
)	O
.	O
escape_route	float
=	O
compute_escape	function
(	O
str	int
,	O
0	int
)	O
;	O
compute_refined_dragon_weaknesses	function
(	O
)	O
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
dragon2	pointer
[	O
d	int
]	O
.	O
weakness_pre_owl	float
=	O
dragon2	pointer
[	O
d	int
]	O
.	O
weakness	float
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
)	O
if	O
(	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
==	O
str	int
&&	O
board	pointer
[	O
str	int
]	O
)	O
dragon	int
[	O
str	int
]	O
.	O
crude_status	function
=	O
compute_crude_status	function
(	O
str	int
)	O
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
&&	O
board	pointer
[	O
str	int
]	O
!=	O
EMPTY	int
)	O
dragon	int
[	O
str	int
]	O
=	O
dragon	int
[	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
]	O
;	O
find_neighbor_dragons	function
(	O
)	O
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
dragon2	pointer
[	O
d	int
]	O
.	O
surround_status	int
=	O
compute_surroundings	function
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
,	O
NO_MOVE	O
,	O
0	int
,	O
&	O
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
surround_size	pointer
)	O
)	O
;	O
if	O
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
surround_status	int
==	O
SURROUNDED	int
)	O
{	O
dragon2	pointer
[	O
d	int
]	O
.	O
escape_route	float
=	O
0	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_DRAGONS	int
)	O
gprintf	function
(	O
"surrounded dragon found at %1m\n"	pointer
,	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
)	O
;	O
}	O
else	O
if	O
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
surround_status	int
==	O
WEAKLY_SURROUNDED	int
)	O
{	O
dragon2	pointer
[	O
d	int
]	O
.	O
escape_route	float
/=	O
2	int
;	O
if	O
(	O
debug	int
&	O
DEBUG_DRAGONS	int
)	O
gprintf	function
(	O
"weakly surrounded dragon found at %1m\n"	pointer
,	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
)	O
;	O
}	O
}	O
if	O
(	O
stop_before_owl	int
)	O
return	O
;	O
start_timer	function
(	O
2	int
)	O
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
)	O
{	O
int	O
attack_point	pointer
=	O
NO_MOVE	O
;	O
int	O
defense_point	pointer
=	O
NO_MOVE	O
;	O
struct	O
eyevalue	struct
no_eyes	struct
;	O
set_eyevalue	function
(	O
&	O
no_eyes	struct
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
||	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
!=	O
str	int
)	O
continue	O
;	O
if	O
(	O
crude_dragon_weakness	function
(	O
ALIVE	int
,	O
&	O
no_eyes	struct
,	O
0	int
,	O
DRAGON2	O
(	O
str	int
)	O
.	O
moyo_territorial_value	float
,	O
DRAGON2	O
(	O
str	int
)	O
.	O
escape_route	float
-	O
10	int
)	O
<	O
0.00001	int
+	O
gg_max	O
(	O
0.12	int
,	O
0.32	int
-	O
0.01	int
*	O
dragon	int
[	O
str	int
]	O
.	O
effective_size	float
)	O
)	O
{	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_status	enum
=	O
UNCHECKED	int
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_point	int
=	O
NO_MOVE	O
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_point	int
=	O
NO_MOVE	O
;	O
}	O
else	O
{	O
int	O
acode	int
=	O
0	int
;	O
int	O
dcode	int
=	O
0	int
;	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
owl_nodes_before	int
=	O
get_owl_node_counter	function
(	O
)	O
;	O
start_timer	function
(	O
3	int
)	O
;	O
acode	int
=	O
owl_attack	function
(	O
str	int
,	O
&	O
attack_point	pointer
,	O
&	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_certain	int
,	O
&	O
kworm	int
)	O
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_node_count	int
=	O
get_owl_node_counter	function
(	O
)	O
-	O
owl_nodes_before	int
;	O
if	O
(	O
acode	int
!=	O
0	int
)	O
{	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_point	int
=	O
attack_point	pointer
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_code	int
=	O
acode	int
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_kworm	int
=	O
kworm	int
;	O
if	O
(	O
attack_point	pointer
!=	O
NO_MOVE	O
)	O
{	O
kworm	int
=	O
NO_MOVE	O
;	O
dcode	int
=	O
owl_defend	function
(	O
str	int
,	O
&	O
defense_point	pointer
,	O
&	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_certain	int
,	O
&	O
kworm	int
)	O
;	O
if	O
(	O
dcode	int
!=	O
0	int
)	O
{	O
if	O
(	O
defense_point	pointer
!=	O
NO_MOVE	O
)	O
{	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_status	enum
=	O
(	O
acode	int
==	O
GAIN	int
?	O
ALIVE	int
:	O
CRITICAL	int
)	O
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_point	int
=	O
defense_point	pointer
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_code	int
=	O
dcode	int
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_kworm	int
=	O
kworm	int
;	O
}	O
else	O
{	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_status	enum
=	O
(	O
acode	int
==	O
GAIN	int
?	O
ALIVE	int
:	O
CRITICAL	int
)	O
;	O
DEBUG	O
(	O
DEBUG_OWL_PERFORMANCE	int
,	O
"Inconsistent owl attack and defense results for %1m.\n"	pointer
,	O
str	int
)	O
;	O
dcode	int
=	O
owl_does_defend	function
(	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_point	int
,	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
dcode	int
!=	O
0	int
)	O
{	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_point	int
=	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_point	int
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_code	int
=	O
dcode	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
dcode	int
==	O
0	int
)	O
{	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_status	enum
=	O
DEAD	int
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_point	int
=	O
NO_MOVE	O
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_code	int
=	O
0	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_certain	int
)	O
{	O
kworm	int
=	O
NO_MOVE	O
;	O
dcode	int
=	O
owl_defend	function
(	O
str	int
,	O
&	O
defense_point	pointer
,	O
&	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_certain	int
,	O
&	O
kworm	int
)	O
;	O
if	O
(	O
dcode	int
!=	O
0	int
)	O
{	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_point	int
=	O
defense_point	pointer
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_code	int
=	O
dcode	int
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_kworm	int
=	O
kworm	int
;	O
}	O
}	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_status	enum
=	O
ALIVE	int
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_point	int
=	O
NO_MOVE	O
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_code	int
=	O
0	int
;	O
}	O
}	O
}	O
time_report	function
(	O
2	int
,	O
"  owl reading"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
)	O
{	O
if	O
(	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_status	enum
!=	O
UNCHECKED	int
)	O
dragon	int
[	O
str	int
]	O
.	O
status	enum
=	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_status	enum
;	O
else	O
dragon	int
[	O
str	int
]	O
.	O
status	enum
=	O
ALIVE	int
;	O
}	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
&&	O
board	pointer
[	O
str	int
]	O
!=	O
EMPTY	int
)	O
dragon	int
[	O
str	int
]	O
=	O
dragon	int
[	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
]	O
;	O
identify_thrashing_dragons	function
(	O
)	O
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
&&	O
board	pointer
[	O
str	int
]	O
!=	O
EMPTY	int
&&	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
==	O
str	int
)	O
{	O
struct	O
eyevalue	struct
no_eyes	struct
;	O
set_eyevalue	function
(	O
&	O
no_eyes	struct
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
crude_dragon_weakness	function
(	O
ALIVE	int
,	O
&	O
no_eyes	struct
,	O
0	int
,	O
DRAGON2	O
(	O
str	int
)	O
.	O
moyo_territorial_value	float
,	O
DRAGON2	O
(	O
str	int
)	O
.	O
escape_route	float
-	O
10	int
)	O
<	O
0.00001	int
+	O
gg_max	O
(	O
0.12	int
,	O
0.32	int
-	O
0.01	int
*	O
dragon	int
[	O
str	int
]	O
.	O
effective_size	float
)	O
)	O
{	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_threat_status	enum
=	O
UNCHECKED	int
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_second_attack_point	int
=	O
NO_MOVE	O
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_second_defense_point	int
=	O
NO_MOVE	O
;	O
}	O
else	O
{	O
int	O
acode	int
=	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_code	int
;	O
int	O
dcode	int
=	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_code	int
;	O
int	O
defense_point	pointer
,	O
second_defense_point	int
;	O
if	O
(	O
get_level	function
(	O
)	O
>=	O
8	int
&&	O
!	O
disable_threat_computation	int
&&	O
(	O
owl_threats	int
||	O
thrashing_stone	array
[	O
str	int
]	O
)	O
)	O
{	O
if	O
(	O
acode	int
&&	O
!	O
dcode	int
&&	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_point	int
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
owl_threaten_defense	function
(	O
str	int
,	O
&	O
defense_point	pointer
,	O
&	O
second_defense_point	int
)	O
)	O
{	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_threat_status	enum
=	O
CAN_THREATEN_DEFENSE	int
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_defense_point	int
=	O
defense_point	pointer
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_second_defense_point	int
=	O
second_defense_point	int
;	O
}	O
else	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_threat_status	enum
=	O
DEAD	int
;	O
}	O
else	O
if	O
(	O
!	O
acode	int
)	O
{	O
int	O
attack_point	pointer
,	O
second_attack_point	int
;	O
if	O
(	O
owl_threaten_attack	function
(	O
str	int
,	O
&	O
attack_point	pointer
,	O
&	O
second_attack_point	int
)	O
)	O
{	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_threat_status	enum
=	O
CAN_THREATEN_ATTACK	int
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_attack_point	int
=	O
attack_point	pointer
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_second_attack_point	int
=	O
second_attack_point	int
;	O
}	O
else	O
DRAGON2	O
(	O
str	int
)	O
.	O
owl_threat_status	enum
=	O
ALIVE	int
;	O
}	O
}	O
}	O
}	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
&&	O
board	pointer
[	O
str	int
]	O
!=	O
EMPTY	int
)	O
dragon	int
[	O
str	int
]	O
=	O
dragon	int
[	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
]	O
;	O
time_report	function
(	O
2	int
,	O
"  owl threats "	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
int	O
true_genus	int
;	O
int	O
origin	int
=	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
;	O
struct	O
eyevalue	struct
*	O
genus	pointer
=	O
&	O
dragon2	pointer
[	O
d	int
]	O
.	O
genus	pointer
;	O
true_genus	int
=	O
max_eyes	function
(	O
genus	pointer
)	O
+	O
min_eyes	function
(	O
genus	pointer
)	O
;	O
if	O
(	O
dragon_looks_inessential	function
(	O
origin	int
)	O
)	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
=	O
INESSENTIAL	int
;	O
else	O
if	O
(	O
dragon	int
[	O
origin	int
]	O
.	O
size	int
==	O
worm	array
[	O
origin	int
]	O
.	O
size	int
&&	O
worm	array
[	O
origin	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array
[	O
origin	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
=	O
TACTICALLY_DEAD	int
;	O
else	O
if	O
(	O
0	int
)	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
=	O
ALIVE_IN_SEKI	int
;	O
else	O
if	O
(	O
dragon_invincible	function
(	O
origin	int
)	O
)	O
{	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
=	O
INVINCIBLE	int
;	O
DRAGON	O
(	O
d	int
)	O
.	O
status	enum
=	O
ALIVE	int
;	O
}	O
else	O
if	O
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_status	enum
==	O
DEAD	int
)	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
=	O
DEAD	int
;	O
else	O
if	O
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_status	enum
==	O
CRITICAL	int
)	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
=	O
CRITICAL	int
;	O
else	O
if	O
(	O
true_genus	int
>=	O
6	int
||	O
dragon2	pointer
[	O
d	int
]	O
.	O
moyo_size	int
>	O
20	int
)	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
=	O
STRONGLY_ALIVE	int
;	O
else	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
=	O
ALIVE	int
;	O
}	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
)	O
dragon	int
[	O
str	int
]	O
.	O
status	enum
=	O
dragon	int
[	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
]	O
.	O
status	enum
;	O
revise_inessentiality	function
(	O
)	O
;	O
semeai	function
(	O
)	O
;	O
time_report	function
(	O
2	int
,	O
"  semeai module"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
lively_white_dragons	int
=	O
0	int
;	O
lively_black_dragons	int
=	O
0	int
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
if	O
(	O
DRAGON	O
(	O
d	int
)	O
.	O
status	enum
!=	O
DEAD	int
)	O
{	O
if	O
(	O
DRAGON	O
(	O
d	int
)	O
.	O
color	int
==	O
WHITE	int
)	O
lively_white_dragons	int
++	O
;	O
else	O
lively_black_dragons	int
++	O
;	O
}	O
}	O
static	O
void	O
find_lunches	function
(	O
)	O
{	O
int	O
str	int
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
)	O
{	O
int	O
food	int
;	O
if	O
(	O
worm	array
[	O
str	int
]	O
.	O
origin	int
!=	O
str	int
||	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
||	O
worm	array
[	O
str	int
]	O
.	O
lunch	int
==	O
NO_MOVE	O
)	O
continue	O
;	O
food	int
=	O
worm	array
[	O
str	int
]	O
.	O
lunch	int
;	O
if	O
(	O
worm	array
[	O
food	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
continue	O
;	O
add_lunch	function
(	O
str	int
,	O
food	int
)	O
;	O
{	O
int	O
origin	int
=	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
;	O
int	O
lunch	int
=	O
DRAGON2	O
(	O
origin	int
)	O
.	O
lunch	int
;	O
if	O
(	O
lunch	int
==	O
NO_MOVE	O
||	O
worm	array
[	O
food	int
]	O
.	O
cutstone	int
>	O
worm	array
[	O
lunch	int
]	O
.	O
cutstone	int
||	O
(	O
worm	array
[	O
food	int
]	O
.	O
cutstone	int
==	O
worm	array
[	O
lunch	int
]	O
.	O
cutstone	int
&&	O
(	O
worm	array
[	O
food	int
]	O
.	O
liberties	pointer
<	O
worm	array
[	O
lunch	int
]	O
.	O
liberties	pointer
)	O
)	O
)	O
{	O
DRAGON2	O
(	O
origin	int
)	O
.	O
lunch	int
=	O
worm	array
[	O
food	int
]	O
.	O
origin	int
;	O
TRACE	O
(	O
"at %1m setting %1m.lunch to %1m (cutstone=%d)\n"	pointer
,	O
str	int
,	O
origin	int
,	O
worm	array
[	O
food	int
]	O
.	O
origin	int
,	O
worm	array
[	O
food	int
]	O
.	O
cutstone	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
eye_computations	function
(	O
)	O
{	O
int	O
str	int
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
black_eye	array
[	O
str	int
]	O
.	O
color	int
==	O
BLACK	int
&&	O
black_eye	array
[	O
str	int
]	O
.	O
origin	int
==	O
str	int
)	O
{	O
struct	O
eyevalue	struct
value	pointer
;	O
int	O
attack_point	pointer
,	O
defense_point	pointer
;	O
compute_eyes	function
(	O
str	int
,	O
&	O
value	pointer
,	O
&	O
attack_point	pointer
,	O
&	O
defense_point	pointer
,	O
black_eye	array
,	O
half_eye	array
,	O
1	int
)	O
;	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"Black eyespace at %1m: %s\n"	pointer
,	O
str	int
,	O
eyevalue_to_string	function
(	O
&	O
value	pointer
)	O
)	O
;	O
black_eye	array
[	O
str	int
]	O
.	O
value	pointer
=	O
value	pointer
;	O
propagate_eye	function
(	O
str	int
,	O
black_eye	array
)	O
;	O
}	O
if	O
(	O
white_eye	array
[	O
str	int
]	O
.	O
color	int
==	O
WHITE	int
&&	O
white_eye	array
[	O
str	int
]	O
.	O
origin	int
==	O
str	int
)	O
{	O
struct	O
eyevalue	struct
value	pointer
;	O
int	O
attack_point	pointer
,	O
defense_point	pointer
;	O
compute_eyes	function
(	O
str	int
,	O
&	O
value	pointer
,	O
&	O
attack_point	pointer
,	O
&	O
defense_point	pointer
,	O
white_eye	array
,	O
half_eye	array
,	O
1	int
)	O
;	O
DEBUG	O
(	O
DEBUG_EYES	int
,	O
"White eyespace at %1m: %s\n"	pointer
,	O
str	int
,	O
eyevalue_to_string	function
(	O
&	O
value	pointer
)	O
)	O
;	O
white_eye	array
[	O
str	int
]	O
.	O
value	pointer
=	O
value	pointer
;	O
propagate_eye	function
(	O
str	int
,	O
white_eye	array
)	O
;	O
}	O
}	O
}	O
static	O
void	O
revise_inessentiality	function
(	O
)	O
{	O
int	O
str	int
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
)	O
{	O
if	O
(	O
is_worm_origin	function
(	O
str	int
,	O
str	int
)	O
&&	O
worm	array
[	O
str	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array
[	O
str	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
!	O
worm	array
[	O
str	int
]	O
.	O
inessential	int
)	O
{	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
neighbors	int
;	O
int	O
r	int
;	O
int	O
essential	int
=	O
0	int
;	O
neighbors	int
=	O
extended_chainlinks	function
(	O
str	int
,	O
adjs	array
,	O
0	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
neighbors	int
;	O
r	int
++	O
)	O
if	O
(	O
dragon	int
[	O
adjs	array
[	O
r	int
]	O
]	O
.	O
status	enum
!=	O
DEAD	int
)	O
{	O
essential	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
essential	int
&&	O
neighbors	int
>	O
0	int
)	O
{	O
DEBUG	O
(	O
DEBUG_WORMS	int
,	O
"Worm %1m revised to be inessential.\n"	pointer
,	O
str	int
)	O
;	O
worm	array
[	O
str	int
]	O
.	O
inessential	int
=	O
1	int
;	O
propagate_worm	function
(	O
str	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
&&	O
board	pointer
[	O
str	int
]	O
!=	O
EMPTY	int
&&	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
==	O
str	int
&&	O
DRAGON2	O
(	O
str	int
)	O
.	O
safety	int
==	O
CRITICAL	int
)	O
{	O
int	O
w	int
;	O
for	O
(	O
w	int
=	O
first_worm_in_dragon	function
(	O
str	int
)	O
;	O
w	int
!=	O
NO_MOVE	O
;	O
w	int
=	O
next_worm_in_dragon	function
(	O
w	int
)	O
)	O
{	O
if	O
(	O
!	O
worm	array
[	O
w	int
]	O
.	O
inessential	int
)	O
break	O
;	O
}	O
if	O
(	O
w	int
==	O
NO_MOVE	O
)	O
{	O
DEBUG	O
(	O
DEBUG_DRAGONS	int
,	O
"Dragon %1m revised to be inessential.\n"	pointer
,	O
str	int
)	O
;	O
DRAGON2	O
(	O
str	int
)	O
.	O
safety	int
=	O
INESSENTIAL	int
;	O
}	O
}	O
}	O
}	O
void	O
initialize_dragon_data	function
(	O
void	O
)	O
{	O
int	O
str	int
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
)	O
{	O
dragon	int
[	O
str	int
]	O
.	O
id	int
=	O
-	O
1	int
;	O
dragon	int
[	O
str	int
]	O
.	O
size	int
=	O
worm	array
[	O
str	int
]	O
.	O
size	int
;	O
dragon	int
[	O
str	int
]	O
.	O
effective_size	float
=	O
worm	array
[	O
str	int
]	O
.	O
effective_size	float
;	O
dragon	int
[	O
str	int
]	O
.	O
color	int
=	O
worm	array
[	O
str	int
]	O
.	O
color	int
;	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
=	O
worm	array
[	O
str	int
]	O
.	O
origin	int
;	O
dragon	int
[	O
str	int
]	O
.	O
crude_status	function
=	O
UNKNOWN	int
;	O
dragon	int
[	O
str	int
]	O
.	O
status	enum
=	O
UNKNOWN	int
;	O
half_eye	array
[	O
str	int
]	O
.	O
type	char
=	O
0	int
;	O
half_eye	array
[	O
str	int
]	O
.	O
value	pointer
=	O
10.0	int
;	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
&&	O
worm	array
[	O
str	int
]	O
.	O
origin	int
==	O
str	int
)	O
DEBUG	O
(	O
DEBUG_DRAGONS	int
,	O
"Initializing dragon from worm at %1m, size %d\n"	pointer
,	O
str	int
,	O
worm	array
[	O
str	int
]	O
.	O
size	int
)	O
;	O
}	O
memset	function
(	O
next_worm_list	array
,	O
0	int
,	O
sizeof	O
(	O
next_worm_list	array
)	O
)	O
;	O
number_of_dragons	int
=	O
0	int
;	O
clear_cut_list	function
(	O
)	O
;	O
memset	function
(	O
black_vital_points	array
,	O
0	int
,	O
BOARDMAX	O
*	O
sizeof	O
(	O
struct	O
vital_eye_points	struct
)	O
)	O
;	O
memset	function
(	O
white_vital_points	array
,	O
0	int
,	O
BOARDMAX	O
*	O
sizeof	O
(	O
struct	O
vital_eye_points	struct
)	O
)	O
;	O
}	O
static	O
void	O
initialize_supplementary_dragon_data	function
(	O
void	O
)	O
{	O
int	O
str	int
;	O
int	O
d	int
;	O
int	O
origin	int
;	O
number_of_dragons	int
=	O
0	int
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
str	int
)	O
)	O
continue	O
;	O
origin	int
=	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
;	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
dragon	int
[	O
origin	int
]	O
.	O
id	int
==	O
-	O
1	int
)	O
dragon	int
[	O
origin	int
]	O
.	O
id	int
=	O
number_of_dragons	int
++	O
;	O
dragon	int
[	O
str	int
]	O
.	O
id	int
=	O
dragon	int
[	O
origin	int
]	O
.	O
id	int
;	O
}	O
if	O
(	O
dragon2	pointer
!=	O
NULL	O
)	O
free	function
(	O
dragon2	pointer
)	O
;	O
dragon2	pointer
=	O
malloc	function
(	O
number_of_dragons	int
*	O
sizeof	O
(	O
*	O
dragon2	pointer
)	O
)	O
;	O
gg_assert	O
(	O
dragon2	pointer
!=	O
NULL	O
)	O
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
str	int
)	O
)	O
continue	O
;	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
str	int
]	O
)	O
&&	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
==	O
str	int
)	O
{	O
DRAGON2	O
(	O
str	int
)	O
.	O
origin	int
=	O
str	int
;	O
}	O
}	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
dragon2	pointer
[	O
d	int
]	O
.	O
neighbors	int
=	O
0	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
hostile_neighbors	int
=	O
0	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
moyo_size	int
=	O
-	O
1	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
moyo_territorial_value	float
=	O
0.0	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
=	O
-	O
1	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
escape_route	float
=	O
0	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
heye	int
=	O
NO_MOVE	O
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
lunch	int
=	O
NO_MOVE	O
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
surround_status	int
=	O
0	int
;	O
set_eyevalue	function
(	O
&	O
dragon2	pointer
[	O
d	int
]	O
.	O
genus	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
semeais	int
=	O
0	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
semeai_defense_code	int
=	O
0	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
semeai_defense_point	int
=	O
NO_MOVE	O
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
semeai_attack_code	int
=	O
0	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
semeai_attack_point	int
=	O
NO_MOVE	O
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_attack_point	int
=	O
NO_MOVE	O
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_attack_code	int
=	O
0	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_attack_certain	int
=	O
1	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_defense_point	int
=	O
NO_MOVE	O
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_defense_code	int
=	O
0	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_defense_certain	int
=	O
1	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_status	enum
=	O
UNCHECKED	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_threat_status	enum
=	O
UNCHECKED	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_second_attack_point	int
=	O
NO_MOVE	O
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_second_defense_point	int
=	O
NO_MOVE	O
;	O
}	O
dragon2_initialized	int
=	O
1	int
;	O
}	O
static	O
void	O
find_neighbor_dragons	function
(	O
)	O
{	O
int	O
m	int
,	O
n	int
;	O
int	O
pos	int
;	O
int	O
pos2	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
d	int
;	O
int	O
dragons	array
[	O
BOARDMAX	O
]	O
;	O
int	O
distances	array
[	O
BOARDMAX	O
]	O
;	O
int	O
dist	int
;	O
int	O
k	int
;	O
int	O
color	int
;	O
gg_assert	O
(	O
dragon2_initialized	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
)	O
{	O
dragons	array
[	O
pos	int
]	O
=	O
dragon	int
[	O
pos	int
]	O
.	O
id	int
;	O
distances	array
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
dragons	array
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
distances	array
[	O
pos	int
]	O
=	O
-	O
1	int
;	O
}	O
}	O
for	O
(	O
dist	int
=	O
1	int
;	O
dist	int
<=	O
5	int
;	O
dist	int
++	O
)	O
{	O
int	O
found_one	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
distances	array
[	O
pos	int
]	O
!=	O
dist	int
-	O
1	int
||	O
dragons	array
[	O
pos	int
]	O
<	O
0	int
)	O
continue	O
;	O
color	int
=	O
DRAGON	O
(	O
dragons	array
[	O
pos	int
]	O
)	O
.	O
color	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
!	O
ON_BOARD1	O
(	O
pos2	int
)	O
)	O
continue	O
;	O
if	O
(	O
distances	array
[	O
pos2	int
]	O
>=	O
0	int
&&	O
distances	array
[	O
pos2	int
]	O
<	O
dist	int
)	O
continue	O
;	O
if	O
(	O
dist	int
==	O
1	int
||	O
(	O
whose_area	function
(	O
INITIAL_INFLUENCE	O
(	O
color	int
)	O
,	O
pos	int
)	O
==	O
color	int
&&	O
whose_area	function
(	O
INITIAL_INFLUENCE	O
(	O
color	int
)	O
,	O
pos2	int
)	O
!=	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
{	O
if	O
(	O
distances	array
[	O
pos2	int
]	O
==	O
dist	int
)	O
{	O
if	O
(	O
dragons	array
[	O
pos2	int
]	O
!=	O
dragons	array
[	O
pos	int
]	O
)	O
dragons	array
[	O
pos2	int
]	O
=	O
-	O
2	int
;	O
}	O
else	O
{	O
dragons	array
[	O
pos2	int
]	O
=	O
dragons	array
[	O
pos	int
]	O
;	O
distances	array
[	O
pos2	int
]	O
=	O
dist	int
;	O
found_one	int
=	O
1	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
!	O
found_one	int
)	O
break	O
;	O
}	O
if	O
(	O
0	int
)	O
{	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%3d"	pointer
,	O
dragons	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%3d"	pointer
,	O
distances	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
dragons	array
[	O
pos	int
]	O
==	O
-	O
2	int
)	O
{	O
int	O
neighbors	int
=	O
0	int
;	O
int	O
adjacent	array
[	O
4	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD1	O
(	O
pos2	int
)	O
&&	O
dragons	array
[	O
pos2	int
]	O
>=	O
0	int
)	O
adjacent	array
[	O
neighbors	int
++	O
]	O
=	O
dragons	array
[	O
pos2	int
]	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
neighbors	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
neighbors	int
;	O
j	int
++	O
)	O
add_adjacent_dragons	function
(	O
adjacent	array
[	O
i	int
]	O
,	O
adjacent	array
[	O
j	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
dragons	array
[	O
pos	int
]	O
>=	O
0	int
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
dragons	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
>=	O
0	int
&&	O
dragons	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
!=	O
dragons	array
[	O
pos	int
]	O
)	O
add_adjacent_dragons	function
(	O
dragons	array
[	O
pos	int
]	O
,	O
dragons	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
)	O
;	O
}	O
if	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
dragons	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
>=	O
0	int
&&	O
dragons	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
!=	O
dragons	array
[	O
pos	int
]	O
)	O
add_adjacent_dragons	function
(	O
dragons	array
[	O
pos	int
]	O
,	O
dragons	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
0	int
)	O
{	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
gprintf	function
(	O
"dragon %d at %1m:"	pointer
,	O
d	int
,	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dragon2	pointer
[	O
d	int
]	O
.	O
neighbors	int
;	O
i	int
++	O
)	O
gprintf	function
(	O
" %1m(%d)"	pointer
,	O
dragon2	pointer
[	O
dragon2	pointer
[	O
d	int
]	O
.	O
adjacent	array
[	O
i	int
]	O
]	O
.	O
origin	int
,	O
dragon2	pointer
[	O
d	int
]	O
.	O
adjacent	array
[	O
i	int
]	O
)	O
;	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
add_adjacent_dragons	function
(	O
int	O
a	char
,	O
int	O
b	char
)	O
{	O
gg_assert	O
(	O
a	char
>=	O
0	int
&&	O
a	char
<	O
number_of_dragons	int
&&	O
b	char
>=	O
0	int
&&	O
b	char
<	O
number_of_dragons	int
)	O
;	O
if	O
(	O
a	char
==	O
b	char
)	O
return	O
;	O
add_adjacent_dragon	function
(	O
a	char
,	O
b	char
)	O
;	O
add_adjacent_dragon	function
(	O
b	char
,	O
a	char
)	O
;	O
}	O
static	O
void	O
add_adjacent_dragon	function
(	O
int	O
a	char
,	O
int	O
b	char
)	O
{	O
int	O
i	int
;	O
gg_assert	O
(	O
a	char
>=	O
0	int
&&	O
a	char
<	O
number_of_dragons	int
&&	O
b	char
>=	O
0	int
&&	O
b	char
<	O
number_of_dragons	int
)	O
;	O
if	O
(	O
dragon2	pointer
[	O
a	char
]	O
.	O
neighbors	int
==	O
MAX_NEIGHBOR_DRAGONS	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dragon2	pointer
[	O
a	char
]	O
.	O
neighbors	int
;	O
i	int
++	O
)	O
if	O
(	O
dragon2	pointer
[	O
a	char
]	O
.	O
adjacent	array
[	O
i	int
]	O
==	O
b	char
)	O
return	O
;	O
dragon2	pointer
[	O
a	char
]	O
.	O
adjacent	array
[	O
dragon2	pointer
[	O
a	char
]	O
.	O
neighbors	int
++	O
]	O
=	O
b	char
;	O
if	O
(	O
DRAGON	O
(	O
a	char
)	O
.	O
color	int
==	O
OTHER_COLOR	O
(	O
DRAGON	O
(	O
b	char
)	O
.	O
color	int
)	O
)	O
dragon2	pointer
[	O
a	char
]	O
.	O
hostile_neighbors	int
++	O
;	O
}	O
static	O
int	O
dragon_invincible	function
(	O
int	O
dr	int
)	O
{	O
struct	O
eye_data	struct
*	O
eye	array
;	O
int	O
eye_color	int
;	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
strong_eyes	int
=	O
0	int
;	O
int	O
mx	array
[	O
BOARDMAX	O
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
dr	int
]	O
)	O
,	O
dr	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
is_same_dragon	function
(	O
pos	int
,	O
dr	int
)	O
&&	O
worm	array
[	O
pos	int
]	O
.	O
invincible	int
)	O
return	O
1	int
;	O
}	O
if	O
(	O
DRAGON2	O
(	O
dr	int
)	O
.	O
owl_status	enum
!=	O
UNCHECKED	int
&&	O
DRAGON2	O
(	O
dr	int
)	O
.	O
owl_status	enum
!=	O
ALIVE	int
)	O
return	O
0	int
;	O
if	O
(	O
board	pointer
[	O
dr	int
]	O
==	O
BLACK	int
)	O
{	O
eye	array
=	O
black_eye	array
;	O
eye_color	int
=	O
BLACK	int
;	O
}	O
else	O
{	O
eye	array
=	O
white_eye	array
;	O
eye_color	int
=	O
WHITE	int
;	O
}	O
memset	function
(	O
mx	array
,	O
0	int
,	O
sizeof	O
(	O
mx	array
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
board	pointer
[	O
dr	int
]	O
&&	O
is_same_dragon	function
(	O
pos	int
,	O
dr	int
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
eye	array
[	O
pos2	int
]	O
.	O
color	int
==	O
eye_color	int
&&	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
eye	array
[	O
pos2	int
]	O
.	O
marginal	char
||	O
is_halfeye	function
(	O
half_eye	array
,	O
pos2	int
)	O
)	O
mx	array
[	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
]	O
=	O
2	int
;	O
else	O
if	O
(	O
mx	array
[	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
]	O
==	O
0	int
)	O
mx	array
[	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
]	O
=	O
1	int
;	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
==	O
OTHER_COLOR	O
(	O
board	pointer
[	O
dr	int
]	O
)	O
&&	O
(	O
!	O
attack	function
(	O
pos2	int
,	O
NULL	O
)	O
||	O
find_defense	function
(	O
pos2	int
,	O
NULL	O
)	O
)	O
)	O
mx	array
[	O
eye	array
[	O
pos2	int
]	O
.	O
origin	int
]	O
=	O
2	int
;	O
}	O
}	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
mx	array
[	O
pos	int
]	O
==	O
1	int
&&	O
eye	array
[	O
pos	int
]	O
.	O
msize	int
==	O
0	int
)	O
strong_eyes	int
++	O
;	O
}	O
if	O
(	O
strong_eyes	int
>=	O
2	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
dragon_looks_inessential	function
(	O
int	O
origin	int
)	O
{	O
if	O
(	O
dragon	int
[	O
origin	int
]	O
.	O
size	int
!=	O
worm	array
[	O
origin	int
]	O
.	O
size	int
)	O
return	O
0	int
;	O
if	O
(	O
owl_substantial	function
(	O
origin	int
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
get_alive_stones	function
(	O
int	O
color	int
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
d	int
;	O
get_lively_stones	function
(	O
color	int
,	O
safe_stones	array
)	O
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
if	O
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
==	O
DEAD	int
||	O
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
==	O
CRITICAL	int
&&	O
board	pointer
[	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
{	O
mark_dragon	function
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
,	O
safe_stones	array
,	O
0	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
identify_thrashing_dragons	function
(	O
)	O
{	O
int	O
k	int
;	O
int	O
dist	int
;	O
int	O
last_move	int
;	O
int	O
color	int
;	O
thrashing_dragon	int
=	O
0	int
;	O
memset	function
(	O
thrashing_stone	array
,	O
0	int
,	O
sizeof	O
(	O
thrashing_stone	array
)	O
)	O
;	O
last_move	int
=	O
get_last_move	function
(	O
)	O
;	O
if	O
(	O
last_move	int
==	O
NO_MOVE	O
||	O
dragon	int
[	O
last_move	int
]	O
.	O
status	enum
!=	O
DEAD	int
)	O
return	O
;	O
thrashing_dragon	int
=	O
dragon	int
[	O
last_move	int
]	O
.	O
origin	int
;	O
DEBUG	O
(	O
DEBUG_DRAGONS	int
,	O
"thrashing dragon found at %1m\n"	pointer
,	O
thrashing_dragon	int
)	O
;	O
mark_dragon	function
(	O
thrashing_dragon	int
,	O
thrashing_stone	array
,	O
1	int
)	O
;	O
color	int
=	O
board	pointer
[	O
thrashing_dragon	int
]	O
;	O
for	O
(	O
dist	int
=	O
1	int
;	O
dist	int
<	O
5	int
;	O
dist	int
++	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
color	int
||	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
!=	O
pos	int
||	O
thrashing_stone	array
[	O
pos	int
]	O
!=	O
dist	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DRAGON2	O
(	O
pos	int
)	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
adjacent	array
[	O
k	int
]	O
;	O
if	O
(	O
DRAGON	O
(	O
d	int
)	O
.	O
color	int
==	O
color	int
&&	O
DRAGON	O
(	O
d	int
)	O
.	O
status	enum
==	O
DEAD	int
&&	O
thrashing_stone	array
[	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
]	O
==	O
0	int
)	O
{	O
DEBUG	O
(	O
DEBUG_DRAGONS	int
,	O
"neighbor at distance %d of thrashing dragon found at %1m\n"	pointer
,	O
dist	int
+	O
1	int
,	O
DRAGON	O
(	O
d	int
)	O
.	O
origin	int
)	O
;	O
mark_dragon	function
(	O
DRAGON	O
(	O
d	int
)	O
.	O
origin	int
,	O
thrashing_stone	array
,	O
(	O
signed	O
char	O
)	O
(	O
dist	int
+	O
1	int
)	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
set_dragon_strengths	function
(	O
const	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
{	O
if	O
(	O
safe_stones	array
[	O
ii	int
]	O
)	O
{	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
ii	int
]	O
)	O
,	O
ii	int
)	O
;	O
strength	array
[	O
ii	int
]	O
=	O
DEFAULT_STRENGTH	int
*	O
(	O
1.0	int
-	O
0.3	int
*	O
DRAGON2	O
(	O
ii	int
)	O
.	O
weakness_pre_owl	float
)	O
;	O
}	O
else	O
strength	array
[	O
ii	int
]	O
=	O
0.0	int
;	O
}	O
}	O
void	O
mark_inessential_stones	function
(	O
int	O
color	int
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
ii	int
]	O
)	O
&&	O
(	O
DRAGON2	O
(	O
ii	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
||	O
(	O
worm	array
[	O
ii	int
]	O
.	O
inessential	int
&&	O
(	O
(	O
DRAGON2	O
(	O
ii	int
)	O
.	O
safety	int
!=	O
DEAD	int
&&	O
DRAGON2	O
(	O
ii	int
)	O
.	O
safety	int
!=	O
TACTICALLY_DEAD	int
&&	O
DRAGON2	O
(	O
ii	int
)	O
.	O
safety	int
!=	O
CRITICAL	int
)	O
||	O
(	O
DRAGON2	O
(	O
ii	int
)	O
.	O
safety	int
==	O
CRITICAL	int
&&	O
board	pointer
[	O
ii	int
]	O
==	O
color	int
)	O
)	O
)	O
)	O
)	O
safe_stones	array
[	O
ii	int
]	O
=	O
INFLUENCE_SAFE_STONE	int
;	O
}	O
void	O
set_strength_data	function
(	O
int	O
color	int
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
)	O
{	O
gg_assert	O
(	O
IS_STONE	O
(	O
color	int
)	O
||	O
color	int
==	O
EMPTY	int
)	O
;	O
get_alive_stones	function
(	O
color	int
,	O
safe_stones	array
)	O
;	O
set_dragon_strengths	function
(	O
safe_stones	array
,	O
strength	array
)	O
;	O
mark_inessential_stones	function
(	O
color	int
,	O
safe_stones	array
)	O
;	O
}	O
void	O
compute_dragon_influence	function
(	O
)	O
{	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
;	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
;	O
set_strength_data	function
(	O
BLACK	int
,	O
safe_stones	array
,	O
strength	array
)	O
;	O
compute_influence	function
(	O
BLACK	int
,	O
safe_stones	array
,	O
strength	array
,	O
&	O
initial_black_influence	struct
,	O
NO_MOVE	O
,	O
"initial black influence, dragons known"	pointer
)	O
;	O
break_territories	function
(	O
BLACK	int
,	O
&	O
initial_black_influence	struct
,	O
1	int
,	O
NO_MOVE	O
)	O
;	O
set_strength_data	function
(	O
WHITE	int
,	O
safe_stones	array
,	O
strength	array
)	O
;	O
compute_influence	function
(	O
WHITE	int
,	O
safe_stones	array
,	O
strength	array
,	O
&	O
initial_white_influence	struct
,	O
NO_MOVE	O
,	O
"initial white influence, dragons known"	pointer
)	O
;	O
break_territories	function
(	O
WHITE	int
,	O
&	O
initial_white_influence	struct
,	O
1	int
,	O
NO_MOVE	O
)	O
;	O
}	O
void	O
compute_dragon_genus	function
(	O
int	O
d	int
,	O
struct	O
eyevalue	struct
*	O
genus	pointer
,	O
int	O
eye_to_exclude	int
)	O
{	O
int	O
pos	int
;	O
int	O
dr	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
d	int
]	O
)	O
,	O
d	int
)	O
;	O
gg_assert	O
(	O
eye_to_exclude	int
==	O
NO_MOVE	O
||	O
ON_BOARD1	O
(	O
eye_to_exclude	int
)	O
)	O
;	O
set_eyevalue	function
(	O
genus	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
if	O
(	O
board	pointer
[	O
d	int
]	O
==	O
BLACK	int
)	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
black_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
BLACK	int
&&	O
black_eye	array
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
&&	O
(	O
eye_to_exclude	int
==	O
NO_MOVE	O
||	O
black_eye	array
[	O
eye_to_exclude	int
]	O
.	O
origin	int
!=	O
pos	int
)	O
&&	O
find_eye_dragons	function
(	O
pos	int
,	O
black_eye	array
,	O
BLACK	int
,	O
&	O
dr	int
,	O
1	int
)	O
==	O
1	int
&&	O
is_same_dragon	function
(	O
dr	int
,	O
d	int
)	O
)	O
{	O
TRACE	O
(	O
"eye at %1m (%s) found for dragon at %1m--augmenting genus\n"	pointer
,	O
pos	int
,	O
eyevalue_to_string	function
(	O
&	O
black_eye	array
[	O
pos	int
]	O
.	O
value	pointer
)	O
,	O
dr	int
)	O
;	O
if	O
(	O
eye_to_exclude	int
==	O
NO_MOVE	O
&&	O
(	O
eye_move_urgency	function
(	O
&	O
black_eye	array
[	O
pos	int
]	O
.	O
value	pointer
)	O
>	O
eye_move_urgency	function
(	O
genus	pointer
)	O
)	O
)	O
DRAGON2	O
(	O
d	int
)	O
.	O
heye	int
=	O
black_vital_points	array
[	O
pos	int
]	O
.	O
defense_points	array
[	O
0	int
]	O
;	O
add_eyevalues	function
(	O
genus	pointer
,	O
&	O
black_eye	array
[	O
pos	int
]	O
.	O
value	pointer
,	O
genus	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
white_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
WHITE	int
&&	O
white_eye	array
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
&&	O
(	O
eye_to_exclude	int
==	O
NO_MOVE	O
||	O
white_eye	array
[	O
eye_to_exclude	int
]	O
.	O
origin	int
!=	O
pos	int
)	O
&&	O
find_eye_dragons	function
(	O
pos	int
,	O
white_eye	array
,	O
WHITE	int
,	O
&	O
dr	int
,	O
1	int
)	O
==	O
1	int
&&	O
is_same_dragon	function
(	O
dr	int
,	O
d	int
)	O
)	O
{	O
TRACE	O
(	O
"eye at %1m (%s) found for dragon at %1m--augmenting genus\n"	pointer
,	O
pos	int
,	O
eyevalue_to_string	function
(	O
&	O
white_eye	array
[	O
pos	int
]	O
.	O
value	pointer
)	O
,	O
dr	int
)	O
;	O
if	O
(	O
eye_to_exclude	int
==	O
NO_MOVE	O
&&	O
(	O
eye_move_urgency	function
(	O
&	O
white_eye	array
[	O
pos	int
]	O
.	O
value	pointer
)	O
>	O
eye_move_urgency	function
(	O
genus	pointer
)	O
)	O
)	O
DRAGON2	O
(	O
d	int
)	O
.	O
heye	int
=	O
white_vital_points	array
[	O
pos	int
]	O
.	O
defense_points	array
[	O
0	int
]	O
;	O
add_eyevalues	function
(	O
genus	pointer
,	O
&	O
white_eye	array
[	O
pos	int
]	O
.	O
value	pointer
,	O
genus	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
analyze_false_eye_territory	function
(	O
void	O
)	O
{	O
int	O
pos	int
;	O
int	O
color	int
;	O
int	O
eye_color	int
;	O
struct	O
eye_data	struct
*	O
eye	array
;	O
int	O
k	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
false_eye_territory	array
[	O
pos	int
]	O
=	O
0	int
;	O
if	O
(	O
half_eye	array
[	O
pos	int
]	O
.	O
type	char
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
white_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
WHITE	int
)	O
{	O
color	int
=	O
WHITE	int
;	O
eye_color	int
=	O
WHITE	int
;	O
eye	array
=	O
white_eye	array
;	O
}	O
else	O
if	O
(	O
black_eye	array
[	O
pos	int
]	O
.	O
color	int
==	O
BLACK	int
)	O
{	O
color	int
=	O
BLACK	int
;	O
eye_color	int
=	O
BLACK	int
;	O
eye	array
=	O
black_eye	array
;	O
}	O
else	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
!=	O
color	int
&&	O
eye	array
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
.	O
color	int
!=	O
eye_color	int
)	O
break	O
;	O
if	O
(	O
k	int
<	O
4	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
!	O
connected_to_eye	function
(	O
pos	int
,	O
pos	int
+	O
delta	array
[	O
k	int
]	O
,	O
color	int
,	O
eye_color	int
,	O
eye	array
)	O
)	O
break	O
;	O
if	O
(	O
k	int
==	O
4	int
)	O
{	O
false_eye_territory	array
[	O
pos	int
]	O
=	O
1	int
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"False eye territory at %1m\n"	pointer
,	O
pos	int
)	O
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
forced_backfilling_moves	array
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
static	O
int	O
connected_to_eye	function
(	O
int	O
pos	int
,	O
int	O
str	int
,	O
int	O
color	int
,	O
int	O
eye_color	int
,	O
struct	O
eye_data	struct
*	O
eye	array
)	O
{	O
signed	O
char	O
mx	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
me	pointer
[	O
BOARDMAX	O
]	O
;	O
int	O
k	int
;	O
int	O
halfeyes	pointer
;	O
memset	function
(	O
mx	array
,	O
0	int
,	O
sizeof	O
(	O
mx	array
)	O
)	O
;	O
memset	function
(	O
me	pointer
,	O
0	int
,	O
sizeof	O
(	O
me	pointer
)	O
)	O
;	O
mx	array
[	O
pos	int
]	O
=	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
)	O
mx	array
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
=	O
1	int
;	O
halfeyes	pointer
=	O
0	int
;	O
connected_to_eye_recurse	function
(	O
pos	int
,	O
str	int
,	O
color	int
,	O
eye_color	int
,	O
eye	array
,	O
mx	array
,	O
me	pointer
,	O
&	O
halfeyes	pointer
)	O
;	O
if	O
(	O
halfeyes	pointer
>=	O
2	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
connected_to_eye_recurse	function
(	O
int	O
pos	int
,	O
int	O
str	int
,	O
int	O
color	int
,	O
int	O
eye_color	int
,	O
struct	O
eye_data	struct
*	O
eye	array
,	O
signed	O
char	O
*	O
mx	array
,	O
signed	O
char	O
*	O
me	pointer
,	O
int	O
*	O
halfeyes	pointer
)	O
{	O
int	O
liberties	pointer
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
r	int
;	O
int	O
k	int
;	O
mark_string	function
(	O
str	int
,	O
mx	array
,	O
1	int
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
str	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
{	O
if	O
(	O
eye	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
.	O
color	int
==	O
eye_color	int
&&	O
libs	pointer
[	O
r	int
]	O
!=	O
pos	int
&&	O
!	O
me	pointer
[	O
eye	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
.	O
origin	int
]	O
)	O
{	O
me	pointer
[	O
eye	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
.	O
origin	int
]	O
=	O
1	int
;	O
*	O
halfeyes	pointer
+=	O
(	O
min_eyes	function
(	O
&	O
eye	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
.	O
value	pointer
)	O
+	O
max_eyes	function
(	O
&	O
eye	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
.	O
value	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
*	O
halfeyes	pointer
>=	O
2	int
)	O
return	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
liberties	pointer
;	O
r	int
++	O
)	O
{	O
if	O
(	O
mx	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
)	O
continue	O
;	O
mx	array
[	O
libs	pointer
[	O
r	int
]	O
]	O
=	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
board	pointer
[	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
is_same_dragon	function
(	O
str	int
,	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
)	O
&&	O
!	O
mx	array
[	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
]	O
)	O
connected_to_eye_recurse	function
(	O
pos	int
,	O
libs	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
,	O
color	int
,	O
eye_color	int
,	O
eye	array
,	O
mx	array
,	O
me	pointer
,	O
halfeyes	pointer
)	O
;	O
if	O
(	O
*	O
halfeyes	pointer
>=	O
2	int
)	O
return	O
;	O
}	O
}	O
}	O
void	O
show_dragons	function
(	O
void	O
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
struct	O
worm_data	struct
*	O
w	int
=	O
&	O
(	O
worm	array
[	O
pos	int
]	O
)	O
;	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
)	O
continue	O
;	O
if	O
(	O
w	int
->	O
origin	int
==	O
pos	int
)	O
{	O
gprintf	function
(	O
"%1m : (dragon %1m) %s string of size %d (%f), genus %d: (%d,%d,%d,%d)"	pointer
,	O
pos	int
,	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
,	O
color_to_string	function
(	O
board	pointer
[	O
pos	int
]	O
)	O
,	O
w	int
->	O
size	int
,	O
w	int
->	O
effective_size	float
,	O
w	int
->	O
genus	pointer
,	O
w	int
->	O
liberties	pointer
,	O
w	int
->	O
liberties2	int
,	O
w	int
->	O
liberties3	int
,	O
w	int
->	O
liberties4	int
)	O
;	O
if	O
(	O
w	int
->	O
cutstone	int
==	O
1	int
)	O
gprintf	function
(	O
"%o - is a potential cutting stone\n"	pointer
)	O
;	O
else	O
if	O
(	O
w	int
->	O
cutstone	int
==	O
2	int
)	O
gprintf	function
(	O
"%o - is a cutting stone\n"	pointer
)	O
;	O
else	O
gprintf	function
(	O
"%o\n"	pointer
)	O
;	O
if	O
(	O
w	int
->	O
cutstone2	int
>	O
0	int
)	O
gprintf	function
(	O
"- cutstone2 = %d\n"	pointer
,	O
w	int
->	O
cutstone2	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_TACTICAL_POINTS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
w	int
->	O
attack_codes	array
[	O
k	int
]	O
==	O
0	int
)	O
break	O
;	O
gprintf	function
(	O
"- attackable at %1m, attack code = %d\n"	pointer
,	O
w	int
->	O
attack_points	array
[	O
k	int
]	O
,	O
w	int
->	O
attack_codes	array
[	O
k	int
]	O
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_TACTICAL_POINTS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
w	int
->	O
defense_codes	array
[	O
k	int
]	O
==	O
0	int
)	O
break	O
;	O
gprintf	function
(	O
"- defendable at %1m, defend code = %d\n"	pointer
,	O
w	int
->	O
defense_points	array
[	O
k	int
]	O
,	O
w	int
->	O
defense_codes	array
[	O
k	int
]	O
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_TACTICAL_POINTS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
w	int
->	O
attack_threat_codes	array
[	O
k	int
]	O
==	O
0	int
)	O
break	O
;	O
gprintf	function
(	O
"- attack threat at %1m, attack threat code = %d\n"	pointer
,	O
w	int
->	O
attack_threat_points	array
[	O
k	int
]	O
,	O
w	int
->	O
attack_threat_codes	array
[	O
k	int
]	O
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_TACTICAL_POINTS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
w	int
->	O
defense_threat_codes	array
[	O
k	int
]	O
==	O
0	int
)	O
break	O
;	O
gprintf	function
(	O
"- defense threat at %1m, defense threat code = %d\n"	pointer
,	O
w	int
->	O
defense_threat_points	array
[	O
k	int
]	O
,	O
w	int
->	O
defense_threat_codes	array
[	O
k	int
]	O
)	O
;	O
}	O
if	O
(	O
w	int
->	O
lunch	int
!=	O
NO_MOVE	O
)	O
gprintf	function
(	O
"... adjacent worm %1m is lunch\n"	pointer
,	O
w	int
->	O
lunch	int
)	O
;	O
if	O
(	O
w	int
->	O
inessential	int
)	O
gprintf	function
(	O
"- is inessential\n"	pointer
)	O
;	O
if	O
(	O
w	int
->	O
invincible	int
)	O
gprintf	function
(	O
"- is invincible\n"	pointer
)	O
;	O
if	O
(	O
is_ko_point	function
(	O
pos	int
)	O
)	O
gprintf	function
(	O
"- is a ko stone\n"	pointer
)	O
;	O
}	O
}	O
gprintf	function
(	O
"%o\n"	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
struct	O
dragon_data	struct
*	O
dd	pointer
=	O
&	O
(	O
dragon	int
[	O
pos	int
]	O
)	O
;	O
struct	O
dragon_data2	struct
*	O
d2	int
;	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
)	O
continue	O
;	O
d2	int
=	O
&	O
(	O
dragon2	pointer
[	O
dd	pointer
->	O
id	int
]	O
)	O
;	O
if	O
(	O
dd	pointer
->	O
origin	int
==	O
pos	int
)	O
{	O
gprintf	function
(	O
"%1m : %s dragon size %d (%f), genus %s, escape factor %d, crude status %s, status %s, moyo size %d, moyo territory value %f, safety %s, weakness pre owl %f, weakness %f"	pointer
,	O
pos	int
,	O
board	pointer
[	O
pos	int
]	O
==	O
BLACK	int
?	O
"B"	pointer
:	O
"W"	pointer
,	O
dd	pointer
->	O
size	int
,	O
dd	pointer
->	O
effective_size	float
,	O
eyevalue_to_string	function
(	O
&	O
d2	int
->	O
genus	pointer
)	O
,	O
d2	int
->	O
escape_route	float
,	O
status_to_string	function
(	O
dd	pointer
->	O
crude_status	function
)	O
,	O
status_to_string	function
(	O
dd	pointer
->	O
status	enum
)	O
,	O
d2	int
->	O
moyo_size	int
,	O
d2	int
->	O
moyo_territorial_value	float
,	O
status_to_string	function
(	O
d2	int
->	O
safety	int
)	O
,	O
d2	int
->	O
weakness_pre_owl	float
,	O
d2	int
->	O
weakness	float
)	O
;	O
gprintf	function
(	O
", owl status %s\n"	pointer
,	O
status_to_string	function
(	O
d2	int
->	O
owl_status	enum
)	O
)	O
;	O
if	O
(	O
d2	int
->	O
owl_status	enum
==	O
CRITICAL	int
)	O
{	O
gprintf	function
(	O
"... owl attackable at %1m, code %d\n"	pointer
,	O
d2	int
->	O
owl_attack_point	int
,	O
d2	int
->	O
owl_attack_code	int
)	O
;	O
gprintf	function
(	O
"... owl defendable at %1m, code %d\n"	pointer
,	O
d2	int
->	O
owl_defense_point	int
,	O
d2	int
->	O
owl_defense_code	int
)	O
;	O
}	O
if	O
(	O
dd	pointer
->	O
status	enum
==	O
CRITICAL	int
&&	O
d2	int
->	O
semeais	int
)	O
{	O
if	O
(	O
d2	int
->	O
semeai_defense_point	int
)	O
gprintf	function
(	O
"... semeai defense move at %1m, result code %s\n"	pointer
,	O
d2	int
->	O
semeai_defense_point	int
,	O
result_to_string	function
(	O
d2	int
->	O
semeai_defense_code	int
)	O
)	O
;	O
if	O
(	O
d2	int
->	O
semeai_attack_point	int
)	O
gprintf	function
(	O
"... semeai attack move at %1m, result code %s\n"	pointer
,	O
d2	int
->	O
semeai_attack_point	int
,	O
result_to_string	function
(	O
d2	int
->	O
semeai_attack_code	int
)	O
)	O
;	O
}	O
gprintf	function
(	O
"... neighbors"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
d2	int
->	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
d	int
=	O
d2	int
->	O
adjacent	array
[	O
k	int
]	O
;	O
gprintf	function
(	O
" %1m"	pointer
,	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
)	O
;	O
}	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
d2	int
->	O
lunch	int
!=	O
NO_MOVE	O
)	O
gprintf	function
(	O
"... adjacent worm %1m is lunch\n"	pointer
,	O
d2	int
->	O
lunch	int
)	O
;	O
}	O
}	O
}	O
static	O
int	O
new_dragon_origins	array
[	O
BOARDMAX	O
]	O
;	O
void	O
compute_new_dragons	function
(	O
int	O
dragon_origins	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
int	O
saved_cutting_points	array
[	O
BOARDMAX	O
]	O
;	O
gg_assert	O
(	O
stackp	int
>	O
0	int
)	O
;	O
memcpy	function
(	O
saved_cutting_points	array
,	O
cutting_points	array
,	O
sizeof	O
(	O
cutting_points	array
)	O
)	O
;	O
memset	function
(	O
cutting_points	array
,	O
0	int
,	O
sizeof	O
(	O
cutting_points	array
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
new_dragon_origins	array
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
else	O
new_dragon_origins	array
[	O
pos	int
]	O
=	O
find_origin	function
(	O
pos	int
)	O
;	O
}	O
find_cuts	function
(	O
)	O
;	O
find_connections	function
(	O
)	O
;	O
memcpy	function
(	O
cutting_points	array
,	O
saved_cutting_points	array
,	O
sizeof	O
(	O
cutting_points	array
)	O
)	O
;	O
memcpy	function
(	O
dragon_origins	array
,	O
new_dragon_origins	array
,	O
sizeof	O
(	O
new_dragon_origins	array
)	O
)	O
;	O
}	O
static	O
void	O
join_new_dragons	function
(	O
int	O
d1	int
,	O
int	O
d2	int
)	O
{	O
int	O
pos	int
;	O
d1	int
=	O
new_dragon_origins	array
[	O
d1	int
]	O
;	O
d2	int
=	O
new_dragon_origins	array
[	O
d2	int
]	O
;	O
if	O
(	O
d1	int
==	O
d2	int
)	O
return	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
d1	int
]	O
==	O
board	pointer
[	O
d2	int
]	O
,	O
d1	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
d1	int
]	O
)	O
,	O
d1	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
new_dragon_origins	array
[	O
pos	int
]	O
==	O
d2	int
)	O
new_dragon_origins	array
[	O
pos	int
]	O
=	O
d1	int
;	O
}	O
void	O
join_dragons	function
(	O
int	O
d1	int
,	O
int	O
d2	int
)	O
{	O
int	O
ii	int
;	O
int	O
origin	int
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
{	O
join_new_dragons	function
(	O
d1	int
,	O
d2	int
)	O
;	O
return	O
;	O
}	O
d1	int
=	O
dragon	int
[	O
d1	int
]	O
.	O
origin	int
;	O
d2	int
=	O
dragon	int
[	O
d2	int
]	O
.	O
origin	int
;	O
if	O
(	O
d1	int
==	O
d2	int
)	O
return	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
d1	int
]	O
==	O
board	pointer
[	O
d2	int
]	O
,	O
d1	int
)	O
;	O
gg_assert	O
(	O
dragon2_initialized	int
==	O
0	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
d1	int
]	O
)	O
,	O
d1	int
)	O
;	O
if	O
(	O
worm	array
[	O
d1	int
]	O
.	O
size	int
>	O
worm	array
[	O
d2	int
]	O
.	O
size	int
||	O
(	O
worm	array
[	O
d1	int
]	O
.	O
size	int
==	O
worm	array
[	O
d2	int
]	O
.	O
size	int
&&	O
d1	int
<	O
d2	int
)	O
)	O
{	O
origin	int
=	O
d1	int
;	O
DEBUG	O
(	O
DEBUG_DRAGONS	int
,	O
"joining dragon at %1m to dragon at %1m\n"	pointer
,	O
d2	int
,	O
d1	int
)	O
;	O
}	O
else	O
{	O
origin	int
=	O
d2	int
;	O
DEBUG	O
(	O
DEBUG_DRAGONS	int
,	O
"joining dragon at %1m to dragon at %1m\n"	pointer
,	O
d1	int
,	O
d2	int
)	O
;	O
}	O
dragon	int
[	O
origin	int
]	O
.	O
size	int
=	O
dragon	int
[	O
d2	int
]	O
.	O
size	int
+	O
dragon	int
[	O
d1	int
]	O
.	O
size	int
;	O
dragon	int
[	O
origin	int
]	O
.	O
effective_size	float
=	O
(	O
dragon	int
[	O
d2	int
]	O
.	O
effective_size	float
+	O
dragon	int
[	O
d1	int
]	O
.	O
effective_size	float
)	O
;	O
{	O
int	O
last_worm_origin_dragon	int
=	O
origin	int
;	O
while	O
(	O
next_worm_list	array
[	O
last_worm_origin_dragon	int
]	O
!=	O
NO_MOVE	O
)	O
last_worm_origin_dragon	int
=	O
next_worm_list	array
[	O
last_worm_origin_dragon	int
]	O
;	O
if	O
(	O
origin	int
==	O
d1	int
)	O
next_worm_list	array
[	O
last_worm_origin_dragon	int
]	O
=	O
d2	int
;	O
else	O
next_worm_list	array
[	O
last_worm_origin_dragon	int
]	O
=	O
d1	int
;	O
}	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
(	O
dragon	int
[	O
ii	int
]	O
.	O
origin	int
==	O
d1	int
||	O
dragon	int
[	O
ii	int
]	O
.	O
origin	int
==	O
d2	int
)	O
)	O
dragon	int
[	O
ii	int
]	O
.	O
origin	int
=	O
origin	int
;	O
}	O
}	O
static	O
enum	O
dragon_status	function
compute_crude_status	function
(	O
int	O
pos	int
)	O
{	O
struct	O
eyevalue	struct
*	O
genus	pointer
=	O
&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
genus	pointer
;	O
int	O
true_genus	int
=	O
max_eyes	function
(	O
genus	pointer
)	O
+	O
min_eyes	function
(	O
genus	pointer
)	O
;	O
int	O
lunch	int
=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
lunch	int
;	O
gg_assert	O
(	O
dragon2_initialized	int
)	O
;	O
if	O
(	O
true_genus	int
>	O
3	int
)	O
return	O
ALIVE	int
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
size	int
==	O
worm	array
[	O
pos	int
]	O
.	O
size	int
&&	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array
[	O
pos	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
&&	O
true_genus	int
<	O
3	int
)	O
return	O
DEAD	int
;	O
if	O
(	O
lunch	int
!=	O
NO_MOVE	O
&&	O
true_genus	int
<	O
3	int
&&	O
worm	array
[	O
lunch	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
escape_route	float
<	O
5	int
)	O
if	O
(	O
true_genus	int
==	O
2	int
||	O
worm	array
[	O
lunch	int
]	O
.	O
size	int
>	O
2	int
)	O
return	O
CRITICAL	int
;	O
if	O
(	O
lunch	int
!=	O
NO_MOVE	O
&&	O
true_genus	int
>=	O
3	int
)	O
return	O
ALIVE	int
;	O
if	O
(	O
lunch	int
==	O
NO_MOVE	O
||	O
worm	array
[	O
lunch	int
]	O
.	O
cutstone	int
<	O
2	int
)	O
{	O
if	O
(	O
true_genus	int
<	O
3	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
escape_route	float
==	O
0	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
moyo_size	int
<	O
5	int
)	O
return	O
DEAD	int
;	O
if	O
(	O
true_genus	int
==	O
3	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
escape_route	float
<	O
5	int
)	O
return	O
CRITICAL	int
;	O
}	O
if	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
moyo_territorial_value	float
>	O
9.99	int
)	O
return	O
ALIVE	int
;	O
return	O
UNKNOWN	int
;	O
}	O
int	O
dragon_escape	function
(	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
,	O
int	O
color	int
,	O
signed	O
char	O
escape_value	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
ii	int
;	O
int	O
k	int
;	O
static	O
int	O
mx	array
[	O
BOARDMAX	O
]	O
;	O
static	O
int	O
mx_initialized	int
=	O
0	int
;	O
int	O
queue	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
queue_start	int
=	O
0	int
;	O
int	O
queue_end	int
=	O
0	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
distance	int
;	O
int	O
escape_potential	int
=	O
0	int
;	O
gg_assert	O
(	O
IS_STONE	O
(	O
color	int
)	O
)	O
;	O
if	O
(	O
!	O
mx_initialized	int
)	O
{	O
memset	function
(	O
mx	array
,	O
0	int
,	O
sizeof	O
(	O
mx	array
)	O
)	O
;	O
mx_initialized	int
=	O
1	int
;	O
}	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
goal	pointer
[	O
ii	int
]	O
)	O
ENQUEUE	O
(	O
ii	int
)	O
;	O
for	O
(	O
distance	int
=	O
0	int
;	O
distance	int
<=	O
4	int
;	O
distance	int
++	O
)	O
{	O
int	O
save_queue_end	int
=	O
queue_end	int
;	O
while	O
(	O
queue_start	int
<	O
save_queue_end	int
)	O
{	O
ii	int
=	O
queue	array
[	O
queue_start	int
]	O
;	O
queue_start	int
++	O
;	O
if	O
(	O
cut_possible	function
(	O
ii	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
continue	O
;	O
if	O
(	O
distance	int
==	O
4	int
)	O
escape_potential	int
+=	O
escape_value	array
[	O
ii	int
]	O
;	O
else	O
{	O
if	O
(	O
ON_BOARD	O
(	O
SOUTH	O
(	O
ii	int
)	O
)	O
&&	O
!	O
mx	array
[	O
SOUTH	O
(	O
ii	int
)	O
]	O
&&	O
(	O
board	pointer
[	O
SOUTH	O
(	O
ii	int
)	O
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
SOUTH	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
ON_BOARD	O
(	O
SE	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
SE	O
(	O
ii	int
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
SS	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
SS	O
(	O
ii	int
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
SW	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
SW	O
(	O
ii	int
)	O
]	O
!=	O
other	int
)	O
)	O
)	O
ENQUEUE	O
(	O
SOUTH	O
(	O
ii	int
)	O
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
WEST	O
(	O
ii	int
)	O
)	O
&&	O
!	O
mx	array
[	O
WEST	O
(	O
ii	int
)	O
]	O
&&	O
(	O
board	pointer
[	O
WEST	O
(	O
ii	int
)	O
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
WEST	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
ON_BOARD	O
(	O
SW	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
SW	O
(	O
ii	int
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
WW	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
WW	O
(	O
ii	int
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
NW	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
NW	O
(	O
ii	int
)	O
]	O
!=	O
other	int
)	O
)	O
)	O
ENQUEUE	O
(	O
WEST	O
(	O
ii	int
)	O
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
NORTH	O
(	O
ii	int
)	O
)	O
&&	O
!	O
mx	array
[	O
NORTH	O
(	O
ii	int
)	O
]	O
&&	O
(	O
board	pointer
[	O
NORTH	O
(	O
ii	int
)	O
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
NORTH	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
ON_BOARD	O
(	O
NW	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
NW	O
(	O
ii	int
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
NN	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
NN	O
(	O
ii	int
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
NE	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
NE	O
(	O
ii	int
)	O
]	O
!=	O
other	int
)	O
)	O
)	O
ENQUEUE	O
(	O
NORTH	O
(	O
ii	int
)	O
)	O
;	O
if	O
(	O
ON_BOARD	O
(	O
EAST	O
(	O
ii	int
)	O
)	O
&&	O
!	O
mx	array
[	O
EAST	O
(	O
ii	int
)	O
]	O
&&	O
(	O
board	pointer
[	O
EAST	O
(	O
ii	int
)	O
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
EAST	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
ON_BOARD	O
(	O
NE	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
NE	O
(	O
ii	int
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
EE	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
EE	O
(	O
ii	int
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
SE	O
(	O
ii	int
)	O
)	O
&&	O
board	pointer
[	O
SE	O
(	O
ii	int
)	O
]	O
!=	O
other	int
)	O
)	O
)	O
ENQUEUE	O
(	O
EAST	O
(	O
ii	int
)	O
)	O
;	O
if	O
(	O
distance	int
==	O
0	int
)	O
{	O
if	O
(	O
board	pointer
[	O
SOUTH	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
WEST	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
!	O
mx	array
[	O
SW	O
(	O
ii	int
)	O
]	O
&&	O
(	O
board	pointer
[	O
SW	O
(	O
ii	int
)	O
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
SW	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
ON_BOARD	O
(	O
SOUTH	O
(	O
SW	O
(	O
ii	int
)	O
)	O
)	O
&&	O
board	pointer
[	O
SOUTH	O
(	O
SW	O
(	O
ii	int
)	O
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
WEST	O
(	O
SW	O
(	O
ii	int
)	O
)	O
)	O
&&	O
board	pointer
[	O
WEST	O
(	O
SW	O
(	O
ii	int
)	O
)	O
]	O
!=	O
other	int
)	O
)	O
)	O
ENQUEUE	O
(	O
SW	O
(	O
ii	int
)	O
)	O
;	O
if	O
(	O
board	pointer
[	O
WEST	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
NORTH	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
!	O
mx	array
[	O
NW	O
(	O
ii	int
)	O
]	O
&&	O
(	O
board	pointer
[	O
NW	O
(	O
ii	int
)	O
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
NW	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
ON_BOARD	O
(	O
WEST	O
(	O
NW	O
(	O
ii	int
)	O
)	O
)	O
&&	O
board	pointer
[	O
WEST	O
(	O
NW	O
(	O
ii	int
)	O
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
NORTH	O
(	O
NW	O
(	O
ii	int
)	O
)	O
)	O
&&	O
board	pointer
[	O
NORTH	O
(	O
NW	O
(	O
ii	int
)	O
)	O
]	O
!=	O
other	int
)	O
)	O
)	O
ENQUEUE	O
(	O
NW	O
(	O
ii	int
)	O
)	O
;	O
if	O
(	O
board	pointer
[	O
NORTH	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
EAST	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
!	O
mx	array
[	O
NE	O
(	O
ii	int
)	O
]	O
&&	O
(	O
board	pointer
[	O
NE	O
(	O
ii	int
)	O
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
NE	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
ON_BOARD	O
(	O
NORTH	O
(	O
NE	O
(	O
ii	int
)	O
)	O
)	O
&&	O
board	pointer
[	O
NORTH	O
(	O
NE	O
(	O
ii	int
)	O
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
EAST	O
(	O
NE	O
(	O
ii	int
)	O
)	O
)	O
&&	O
board	pointer
[	O
EAST	O
(	O
NE	O
(	O
ii	int
)	O
)	O
]	O
!=	O
other	int
)	O
)	O
)	O
ENQUEUE	O
(	O
NE	O
(	O
ii	int
)	O
)	O
;	O
if	O
(	O
board	pointer
[	O
EAST	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
SOUTH	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
!	O
mx	array
[	O
SE	O
(	O
ii	int
)	O
]	O
&&	O
(	O
board	pointer
[	O
SE	O
(	O
ii	int
)	O
]	O
==	O
color	int
||	O
(	O
board	pointer
[	O
SE	O
(	O
ii	int
)	O
]	O
==	O
EMPTY	int
&&	O
ON_BOARD	O
(	O
EAST	O
(	O
SE	O
(	O
ii	int
)	O
)	O
)	O
&&	O
board	pointer
[	O
EAST	O
(	O
SE	O
(	O
ii	int
)	O
)	O
]	O
!=	O
other	int
&&	O
ON_BOARD	O
(	O
SOUTH	O
(	O
SE	O
(	O
ii	int
)	O
)	O
)	O
&&	O
board	pointer
[	O
SOUTH	O
(	O
SE	O
(	O
ii	int
)	O
)	O
]	O
!=	O
other	int
)	O
)	O
)	O
ENQUEUE	O
(	O
SE	O
(	O
ii	int
)	O
)	O
;	O
}	O
}	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
queue_end	int
;	O
k	int
++	O
)	O
{	O
ASSERT1	O
(	O
mx	array
[	O
queue	array
[	O
k	int
]	O
]	O
==	O
1	int
,	O
queue	array
[	O
k	int
]	O
)	O
;	O
mx	array
[	O
queue	array
[	O
k	int
]	O
]	O
=	O
0	int
;	O
}	O
return	O
escape_potential	int
;	O
}	O
static	O
int	O
compute_escape	function
(	O
int	O
pos	int
,	O
int	O
dragon_status_known	int
)	O
{	O
int	O
ii	int
;	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
escape_value	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
,	O
pos	int
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
goal	pointer
[	O
ii	int
]	O
=	O
is_same_dragon	function
(	O
ii	int
,	O
pos	int
)	O
;	O
get_lively_stones	function
(	O
OTHER_COLOR	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
,	O
safe_stones	array
)	O
;	O
compute_escape_influence	function
(	O
board	pointer
[	O
pos	int
]	O
,	O
safe_stones	array
,	O
NULL	O
,	O
0	int
,	O
escape_value	array
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
ii	int
)	O
)	O
continue	O
;	O
if	O
(	O
dragon_status_known	int
)	O
{	O
if	O
(	O
dragon	int
[	O
ii	int
]	O
.	O
crude_status	function
==	O
ALIVE	int
)	O
escape_value	array
[	O
ii	int
]	O
=	O
6	int
;	O
else	O
if	O
(	O
dragon	int
[	O
ii	int
]	O
.	O
crude_status	function
==	O
UNKNOWN	int
&&	O
(	O
DRAGON2	O
(	O
ii	int
)	O
.	O
escape_route	float
>	O
5	int
||	O
DRAGON2	O
(	O
ii	int
)	O
.	O
moyo_size	int
>	O
5	int
)	O
)	O
escape_value	array
[	O
ii	int
]	O
=	O
4	int
;	O
}	O
else	O
{	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
board	pointer
[	O
pos	int
]	O
&&	O
!	O
goal	pointer
[	O
ii	int
]	O
&&	O
worm	array
[	O
ii	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
escape_value	array
[	O
ii	int
]	O
=	O
2	int
;	O
}	O
}	O
return	O
dragon_escape	function
(	O
goal	pointer
,	O
board	pointer
[	O
pos	int
]	O
,	O
escape_value	array
)	O
;	O
}	O
static	O
void	O
compute_surrounding_moyo_sizes	function
(	O
const	O
struct	O
influence_data	O
*	O
q	pointer
)	O
{	O
int	O
pos	int
;	O
int	O
d	int
;	O
int	O
k	int
;	O
int	O
moyo_color	int
;	O
float	O
moyo_sizes	array
[	O
BOARDMAX	O
]	O
;	O
float	O
moyo_values	array
[	O
BOARDMAX	O
]	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
moyo_sizes	array
[	O
pos	int
]	O
=	O
0.0	int
;	O
moyo_values	array
[	O
pos	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
moyo_color	int
=	O
whose_moyo_restricted	function
(	O
q	pointer
,	O
pos	int
)	O
;	O
if	O
(	O
moyo_color	int
==	O
board	pointer
[	O
pos	int
]	O
)	O
continue	O
;	O
if	O
(	O
moyo_color	int
==	O
WHITE	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
number_close_white_worms	array
[	O
pos	int
]	O
;	O
k	int
++	O
)	O
{	O
int	O
w	int
=	O
close_white_worms	array
[	O
pos	int
]	O
[	O
k	int
]	O
;	O
int	O
dr	int
=	O
dragon	int
[	O
w	int
]	O
.	O
origin	int
;	O
moyo_sizes	array
[	O
dr	int
]	O
+=	O
1.0	int
/	O
number_close_white_worms	array
[	O
pos	int
]	O
;	O
moyo_values	array
[	O
dr	int
]	O
+=	O
(	O
gg_min	O
(	O
influence_territory	function
(	O
q	pointer
,	O
pos	int
,	O
WHITE	int
)	O
,	O
1.0	int
)	O
/	O
number_close_white_worms	array
[	O
pos	int
]	O
)	O
;	O
}	O
}	O
if	O
(	O
moyo_color	int
==	O
BLACK	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
number_close_black_worms	array
[	O
pos	int
]	O
;	O
k	int
++	O
)	O
{	O
int	O
w	int
=	O
close_black_worms	array
[	O
pos	int
]	O
[	O
k	int
]	O
;	O
int	O
dr	int
=	O
dragon	int
[	O
w	int
]	O
.	O
origin	int
;	O
moyo_sizes	array
[	O
dr	int
]	O
+=	O
1.0	int
/	O
number_close_black_worms	array
[	O
pos	int
]	O
;	O
moyo_values	array
[	O
dr	int
]	O
+=	O
(	O
gg_min	O
(	O
influence_territory	function
(	O
q	pointer
,	O
pos	int
,	O
BLACK	int
)	O
,	O
1.0	int
)	O
/	O
number_close_black_worms	array
[	O
pos	int
]	O
)	O
;	O
}	O
}	O
}	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
int	O
this_moyo_size	int
=	O
(	O
int	O
)	O
moyo_sizes	array
[	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
]	O
;	O
float	O
this_moyo_value	float
=	O
moyo_values	array
[	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
]	O
;	O
if	O
(	O
this_moyo_size	int
<	O
dragon2	pointer
[	O
d	int
]	O
.	O
moyo_size	int
)	O
{	O
dragon2	pointer
[	O
d	int
]	O
.	O
moyo_size	int
=	O
this_moyo_size	int
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
moyo_territorial_value	float
=	O
this_moyo_value	float
;	O
}	O
}	O
}	O
static	O
struct	O
interpolation_data	struct
moyo_value2weakness	struct
=	O
{	O
5	int
,	O
0.0	int
,	O
15.0	int
,	O
{	O
1.0	int
,	O
0.65	int
,	O
0.3	int
,	O
0.15	int
,	O
0.05	int
,	O
0.0	int
}	O
}	O
;	O
static	O
struct	O
interpolation_data	struct
escape_route2weakness	struct
=	O
{	O
5	int
,	O
0.0	int
,	O
25.0	int
,	O
{	O
1.0	int
,	O
0.6	int
,	O
0.3	int
,	O
0.1	int
,	O
0.05	int
,	O
0.0	int
}	O
}	O
;	O
static	O
struct	O
interpolation_data	struct
genus2weakness	struct
=	O
{	O
6	int
,	O
0.0	int
,	O
3.0	int
,	O
{	O
1.0	int
,	O
0.95	int
,	O
0.8	int
,	O
0.5	int
,	O
0.2	int
,	O
0.1	int
,	O
0.0	int
}	O
}	O
;	O
float	O
crude_dragon_weakness	function
(	O
int	O
safety	int
,	O
struct	O
eyevalue	struct
*	O
genus	pointer
,	O
int	O
has_lunch	int
,	O
float	O
moyo_value	float
,	O
float	O
escape_route	float
)	O
{	O
float	O
true_genus	int
=	O
0.5	int
*	O
(	O
max_eyes	function
(	O
genus	pointer
)	O
+	O
min_eyes	function
(	O
genus	pointer
)	O
+	O
(	O
has_lunch	int
!=	O
0	int
)	O
)	O
;	O
float	O
weakness_value	array
[	O
3	int
]	O
;	O
float	O
weakness	float
;	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
safety	int
==	O
INVINCIBLE	int
||	O
safety	int
==	O
INESSENTIAL	int
)	O
return	O
0.0	int
;	O
if	O
(	O
safety	int
==	O
TACTICALLY_DEAD	int
||	O
safety	int
==	O
DEAD	int
||	O
safety	int
==	O
CRITICAL	int
)	O
return	O
1.0	int
;	O
weakness_value	array
[	O
0	int
]	O
=	O
gg_interpolate	function
(	O
&	O
moyo_value2weakness	struct
,	O
moyo_value	float
)	O
;	O
weakness_value	array
[	O
1	int
]	O
=	O
gg_interpolate	function
(	O
&	O
escape_route2weakness	struct
,	O
escape_route	float
)	O
;	O
weakness_value	array
[	O
2	int
]	O
=	O
gg_interpolate	function
(	O
&	O
genus2weakness	struct
,	O
true_genus	int
)	O
;	O
DEBUG	O
(	O
DEBUG_DRAGONS	int
,	O
"  moyo value %f -> %f, escape %f -> %f, eyes %f -> %f\n"	pointer
,	O
moyo_value	float
,	O
weakness_value	array
[	O
0	int
]	O
,	O
escape_route	float
,	O
weakness_value	array
[	O
1	int
]	O
,	O
true_genus	int
,	O
weakness_value	array
[	O
2	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
3	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
3	int
;	O
j	int
++	O
)	O
if	O
(	O
weakness_value	array
[	O
j	int
]	O
<	O
weakness_value	array
[	O
i	int
]	O
)	O
{	O
float	O
tmp	float
=	O
weakness_value	array
[	O
i	int
]	O
;	O
weakness_value	array
[	O
i	int
]	O
=	O
weakness_value	array
[	O
j	int
]	O
;	O
weakness_value	array
[	O
j	int
]	O
=	O
tmp	float
;	O
}	O
weakness	float
=	O
gg_min	O
(	O
0.7	int
*	O
weakness_value	array
[	O
0	int
]	O
+	O
0.3	int
*	O
weakness_value	array
[	O
1	int
]	O
,	O
1.3	int
*	O
weakness_value	array
[	O
0	int
]	O
)	O
;	O
gg_assert	O
(	O
weakness	float
>=	O
0.0	int
&&	O
weakness	float
<=	O
1.0	int
)	O
;	O
return	O
weakness	float
;	O
}	O
static	O
float	O
compute_dragon_weakness_value	function
(	O
int	O
d	int
)	O
{	O
int	O
origin	int
=	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
;	O
float	O
weakness	float
;	O
DEBUG	O
(	O
DEBUG_DRAGONS	int
,	O
"Computing weakness of dragon at %1m:\n"	pointer
,	O
origin	int
)	O
;	O
weakness	float
=	O
crude_dragon_weakness	function
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
,	O
&	O
dragon2	pointer
[	O
d	int
]	O
.	O
genus	pointer
,	O
dragon2	pointer
[	O
d	int
]	O
.	O
lunch	int
!=	O
NO_MOVE	O
,	O
dragon2	pointer
[	O
d	int
]	O
.	O
moyo_territorial_value	float
,	O
(	O
float	O
)	O
dragon2	pointer
[	O
d	int
]	O
.	O
escape_route	float
)	O
;	O
if	O
(	O
!	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_attack_certain	int
)	O
weakness	float
+=	O
gg_min	O
(	O
0.25	int
*	O
(	O
1.0	int
-	O
weakness	float
)	O
,	O
0.25	int
*	O
weakness	float
)	O
;	O
if	O
(	O
!	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_defense_certain	int
)	O
weakness	float
+=	O
gg_min	O
(	O
0.25	int
*	O
(	O
1.0	int
-	O
weakness	float
)	O
,	O
0.25	int
*	O
weakness	float
)	O
;	O
if	O
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_threat_status	enum
==	O
CAN_THREATEN_ATTACK	int
)	O
weakness	float
+=	O
0.15	int
*	O
(	O
1.0	int
-	O
weakness	float
)	O
;	O
if	O
(	O
weakness	float
<	O
0.0	int
)	O
weakness	float
=	O
0.0	int
;	O
if	O
(	O
weakness	float
>	O
1.0	int
)	O
weakness	float
=	O
1.0	int
;	O
DEBUG	O
(	O
DEBUG_DRAGONS	int
,	O
" result: %f.\n"	pointer
,	O
weakness	float
)	O
;	O
return	O
weakness	float
;	O
}	O
void	O
compute_refined_dragon_weaknesses	function
(	O
)	O
{	O
int	O
d	int
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
dragon2	pointer
[	O
d	int
]	O
.	O
moyo_size	int
=	O
2	int
*	O
BOARDMAX	O
;	O
compute_surrounding_moyo_sizes	function
(	O
&	O
initial_black_influence	struct
)	O
;	O
compute_surrounding_moyo_sizes	function
(	O
&	O
initial_white_influence	struct
)	O
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
dragon2	pointer
[	O
d	int
]	O
.	O
weakness	float
=	O
compute_dragon_weakness_value	function
(	O
d	int
)	O
;	O
}	O
void	O
compute_strategic_sizes	function
(	O
)	O
{	O
float	O
*	O
bonus	pointer
=	O
calloc	function
(	O
number_of_dragons	int
,	O
sizeof	O
(	O
float	O
)	O
)	O
;	O
int	O
d	int
;	O
int	O
k	int
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
float	O
sum	pointer
=	O
0.0	int
;	O
if	O
(	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
==	O
INESSENTIAL	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
dragon2	pointer
[	O
d	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
d2	int
=	O
dragon2	pointer
[	O
d	int
]	O
.	O
adjacent	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
dragon2	pointer
[	O
d2	int
]	O
.	O
origin	int
]	O
==	O
OTHER_COLOR	O
(	O
board	pointer
[	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
]	O
)	O
&&	O
dragon2	pointer
[	O
d2	int
]	O
.	O
safety	int
!=	O
INESSENTIAL	int
)	O
sum	pointer
+=	O
DRAGON	O
(	O
d2	int
)	O
.	O
effective_size	float
*	O
dragon2	pointer
[	O
d2	int
]	O
.	O
weakness	float
;	O
}	O
if	O
(	O
sum	pointer
==	O
0.0	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
dragon2	pointer
[	O
d	int
]	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
{	O
int	O
d2	int
=	O
dragon2	pointer
[	O
d	int
]	O
.	O
adjacent	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
dragon2	pointer
[	O
d2	int
]	O
.	O
origin	int
]	O
==	O
OTHER_COLOR	O
(	O
board	pointer
[	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
]	O
)	O
&&	O
dragon2	pointer
[	O
d2	int
]	O
.	O
safety	int
!=	O
INESSENTIAL	int
)	O
{	O
bonus	pointer
[	O
d2	int
]	O
+=	O
(	O
(	O
DRAGON	O
(	O
d2	int
)	O
.	O
effective_size	float
*	O
dragon2	pointer
[	O
d2	int
]	O
.	O
weakness	float
)	O
/	O
sum	pointer
)	O
*	O
DRAGON	O
(	O
d	int
)	O
.	O
effective_size	float
*	O
dragon2	pointer
[	O
d	int
]	O
.	O
weakness	float
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"Dragon %1m receives %f effective size bonus from %1m.\n"	pointer
,	O
dragon2	pointer
[	O
d2	int
]	O
.	O
origin	int
,	O
(	O
(	O
DRAGON	O
(	O
d2	int
)	O
.	O
effective_size	float
*	O
dragon2	pointer
[	O
d2	int
]	O
.	O
weakness	float
)	O
/	O
sum	pointer
)	O
*	O
DRAGON	O
(	O
d	int
)	O
.	O
effective_size	float
*	O
dragon2	pointer
[	O
d	int
]	O
.	O
weakness	float
,	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
)	O
;	O
}	O
}	O
}	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"Dragon %1m gets effective size bonus of %f.\n"	pointer
,	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
,	O
bonus	pointer
[	O
d	int
]	O
)	O
;	O
dragon2	pointer
[	O
d	int
]	O
.	O
strategic_size	float
=	O
gg_min	O
(	O
bonus	pointer
[	O
d	int
]	O
+	O
DRAGON	O
(	O
d	int
)	O
.	O
effective_size	float
,	O
3	int
*	O
DRAGON	O
(	O
d	int
)	O
.	O
effective_size	float
)	O
;	O
}	O
free	function
(	O
bonus	pointer
)	O
;	O
}	O
int	O
is_same_dragon	function
(	O
int	O
d1	int
,	O
int	O
d2	int
)	O
{	O
if	O
(	O
d1	int
==	O
NO_MOVE	O
||	O
d2	int
==	O
NO_MOVE	O
)	O
return	O
(	O
d1	int
==	O
d2	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
d1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
d2	int
)	O
;	O
return	O
(	O
dragon	int
[	O
d1	int
]	O
.	O
origin	int
==	O
dragon	int
[	O
d2	int
]	O
.	O
origin	int
)	O
;	O
}	O
int	O
are_neighbor_dragons	function
(	O
int	O
d1	int
,	O
int	O
d2	int
)	O
{	O
int	O
k	int
;	O
d1	int
=	O
dragon	int
[	O
d1	int
]	O
.	O
origin	int
;	O
d2	int
=	O
dragon	int
[	O
d2	int
]	O
.	O
origin	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DRAGON2	O
(	O
d1	int
)	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
if	O
(	O
dragon2	pointer
[	O
DRAGON2	O
(	O
d1	int
)	O
.	O
adjacent	array
[	O
k	int
]	O
]	O
.	O
origin	int
==	O
d2	int
)	O
return	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
DRAGON2	O
(	O
d2	int
)	O
.	O
neighbors	int
;	O
k	int
++	O
)	O
if	O
(	O
dragon2	pointer
[	O
DRAGON2	O
(	O
d2	int
)	O
.	O
adjacent	array
[	O
k	int
]	O
]	O
.	O
origin	int
==	O
d1	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
mark_dragon	function
(	O
int	O
pos	int
,	O
signed	O
char	O
mx	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
mark	char
)	O
{	O
int	O
w	int
;	O
for	O
(	O
w	int
=	O
first_worm_in_dragon	function
(	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
)	O
;	O
w	int
!=	O
NO_MOVE	O
;	O
w	int
=	O
next_worm_in_dragon	function
(	O
w	int
)	O
)	O
mark_string	function
(	O
w	int
,	O
mx	array
,	O
mark	char
)	O
;	O
}	O
int	O
first_worm_in_dragon	function
(	O
int	O
d	int
)	O
{	O
return	O
dragon	int
[	O
d	int
]	O
.	O
origin	int
;	O
}	O
int	O
next_worm_in_dragon	function
(	O
int	O
w	int
)	O
{	O
ASSERT1	O
(	O
worm	array
[	O
w	int
]	O
.	O
origin	int
==	O
w	int
,	O
w	int
)	O
;	O
return	O
next_worm_list	array
[	O
w	int
]	O
;	O
}	O
enum	O
dragon_status	function
crude_status	function
(	O
int	O
pos	int
)	O
{	O
return	O
dragon	int
[	O
pos	int
]	O
.	O
crude_status	function
;	O
}	O
enum	O
dragon_status	function
dragon_status	function
(	O
int	O
pos	int
)	O
{	O
return	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
;	O
}	O
int	O
lively_dragon_exists	function
(	O
int	O
color	int
)	O
{	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
return	O
lively_white_dragons	int
>	O
0	int
;	O
else	O
return	O
lively_black_dragons	int
>	O
0	int
;	O
}	O
int	O
dragon_weak	function
(	O
int	O
pos	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
id	int
<	O
0	int
||	O
dragon	int
[	O
pos	int
]	O
.	O
id	int
>=	O
number_of_dragons	int
)	O
return	O
1	int
;	O
return	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
weakness	float
>	O
0.40001	int
)	O
;	O
}	O
int	O
size_of_biggest_critical_dragon	function
(	O
void	O
)	O
{	O
int	O
str	int
;	O
int	O
max_size	int
=	O
0	int
;	O
for	O
(	O
str	int
=	O
BOARDMIN	O
;	O
str	int
<	O
BOARDMAX	O
;	O
str	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
str	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
||	O
dragon	int
[	O
str	int
]	O
.	O
origin	int
!=	O
str	int
)	O
continue	O
;	O
if	O
(	O
dragon	int
[	O
str	int
]	O
.	O
status	enum
==	O
CRITICAL	int
)	O
{	O
if	O
(	O
dragon	int
[	O
str	int
]	O
.	O
size	int
>=	O
max_size	int
)	O
max_size	int
=	O
dragon	int
[	O
str	int
]	O
.	O
size	int
;	O
}	O
}	O
return	O
max_size	int
;	O
}	O
struct	O
cut_data	struct
{	O
int	O
apos	int
;	O
int	O
bpos	int
;	O
int	O
move	pointer
;	O
}	O
;	O
static	O
int	O
num_cuts	int
=	O
0	int
;	O
static	O
struct	O
cut_data	struct
cut_list	array
[	O
MAX_CUTS	O
]	O
;	O
static	O
void	O
clear_cut_list	function
(	O
)	O
{	O
num_cuts	int
=	O
0	int
;	O
}	O
void	O
add_cut	function
(	O
int	O
apos	int
,	O
int	O
bpos	int
,	O
int	O
move	pointer
)	O
{	O
gg_assert	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
board	pointer
[	O
bpos	int
]	O
)	O
;	O
if	O
(	O
num_cuts	int
==	O
MAX_CUTS	O
)	O
return	O
;	O
if	O
(	O
apos	int
>	O
bpos	int
)	O
{	O
int	O
tmp	float
=	O
apos	int
;	O
apos	int
=	O
bpos	int
;	O
bpos	int
=	O
tmp	float
;	O
}	O
if	O
(	O
move	pointer
==	O
NO_MOVE	O
)	O
return	O
;	O
cut_list	array
[	O
num_cuts	int
]	O
.	O
apos	int
=	O
apos	int
;	O
cut_list	array
[	O
num_cuts	int
]	O
.	O
bpos	int
=	O
bpos	int
;	O
cut_list	array
[	O
num_cuts	int
]	O
.	O
move	pointer
=	O
move	pointer
;	O
num_cuts	int
++	O
;	O
if	O
(	O
0	int
)	O
gprintf	function
(	O
"Added %d-th cut at %1m between %1m and %1m.\n"	pointer
,	O
num_cuts	int
,	O
move	pointer
,	O
apos	int
,	O
bpos	int
)	O
;	O
}	O
void	O
cut_reasons	function
(	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_cuts	int
;	O
k	int
++	O
)	O
if	O
(	O
board	pointer
[	O
cut_list	array
[	O
k	int
]	O
.	O
apos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
!	O
is_same_dragon	function
(	O
cut_list	array
[	O
k	int
]	O
.	O
apos	int
,	O
cut_list	array
[	O
k	int
]	O
.	O
bpos	int
)	O
&&	O
string_connect	function
(	O
cut_list	array
[	O
k	int
]	O
.	O
apos	int
,	O
cut_list	array
[	O
k	int
]	O
.	O
bpos	int
,	O
NULL	O
)	O
==	O
WIN	int
)	O
add_cut_move	function
(	O
cut_list	array
[	O
k	int
]	O
.	O
move	pointer
,	O
cut_list	array
[	O
k	int
]	O
.	O
apos	int
,	O
cut_list	array
[	O
k	int
]	O
.	O
bpos	int
)	O
;	O
}	O
void	O
ascii_report_dragon	function
(	O
char	O
*	O
string	int
)	O
{	O
int	O
pos	int
=	O
string_to_location	function
(	O
board_size	int
,	O
string	int
)	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"unknown position %s\n"	pointer
,	O
string	int
)	O
;	O
else	O
report_dragon	function
(	O
stderr	pointer
,	O
pos	int
)	O
;	O
}	O
void	O
report_dragon	function
(	O
FILE	struct
*	O
outfile	pointer
,	O
int	O
pos	int
)	O
{	O
int	O
w	int
;	O
int	O
k	int
;	O
struct	O
dragon_data	struct
*	O
d	int
=	O
&	O
(	O
dragon	int
[	O
pos	int
]	O
)	O
;	O
struct	O
dragon_data2	struct
*	O
d2	int
=	O
&	O
(	O
dragon2	pointer
[	O
d	int
->	O
id	int
]	O
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
gprintf	function
(	O
"There is no dragon at %1m\n"	pointer
,	O
pos	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
d	int
->	O
id	int
<	O
0	int
)	O
{	O
gprintf	function
(	O
"Dragon data not available at %1m\n"	pointer
,	O
pos	int
)	O
;	O
return	O
;	O
}	O
gfprintf	function
(	O
outfile	pointer
,	O
"color                   %s\n"	pointer
,	O
color_to_string	function
(	O
d	int
->	O
color	int
)	O
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"origin                  %1m\n"	pointer
,	O
d	int
->	O
origin	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"size                    %d\n"	pointer
,	O
d	int
->	O
size	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"effective_size          %f\n"	pointer
,	O
d	int
->	O
effective_size	float
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"strategic_size          %f\n"	pointer
,	O
d2	int
->	O
strategic_size	float
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"genus                   %s\n"	pointer
,	O
eyevalue_to_string	function
(	O
&	O
d2	int
->	O
genus	pointer
)	O
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"heye                    %1m\n"	pointer
,	O
d2	int
->	O
heye	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"escape_route            %d\n"	pointer
,	O
d2	int
->	O
escape_route	float
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"lunch                   %1m\n"	pointer
,	O
d2	int
->	O
lunch	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"crude_status            %s\n"	pointer
,	O
status_to_string	function
(	O
d	int
->	O
crude_status	function
)	O
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_status              %s\n"	pointer
,	O
status_to_string	function
(	O
d2	int
->	O
owl_status	enum
)	O
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"status                  %s\n"	pointer
,	O
status_to_string	function
(	O
d	int
->	O
status	enum
)	O
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"safety                  %s\n"	pointer
,	O
status_to_string	function
(	O
d2	int
->	O
safety	int
)	O
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"weakness                %f\n"	pointer
,	O
d2	int
->	O
weakness	float
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"weakness_pre_owl        %f\n"	pointer
,	O
d2	int
->	O
weakness_pre_owl	float
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"surround_status         %d\n"	pointer
,	O
d2	int
->	O
surround_status	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"surround_size           %d\n"	pointer
,	O
d2	int
->	O
surround_size	pointer
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"moyo_size               %d\n"	pointer
,	O
d2	int
->	O
moyo_size	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"moyo_territorial_value  %f\n"	pointer
,	O
d2	int
->	O
moyo_territorial_value	float
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"neighbors               "	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
d2	int
->	O
neighbors	int
;	O
k	int
++	O
)	O
gfprintf	function
(	O
outfile	pointer
,	O
"%1m "	pointer
,	O
DRAGON	O
(	O
d2	int
->	O
adjacent	array
[	O
k	int
]	O
)	O
.	O
origin	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"\nhostile_neighbors       %d\n"	pointer
,	O
d2	int
->	O
hostile_neighbors	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_attack_code         %d\n"	pointer
,	O
d2	int
->	O
owl_attack_code	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_attack_point        %1m\n"	pointer
,	O
d2	int
->	O
owl_attack_point	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_attack_certain      %s\n"	pointer
,	O
(	O
d2	int
->	O
owl_attack_certain	int
)	O
?	O
"YES"	pointer
:	O
"NO"	pointer
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_2nd_attack_point    %1m\n"	pointer
,	O
d2	int
->	O
owl_second_attack_point	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_threat_status       %s\n"	pointer
,	O
status_to_string	function
(	O
d2	int
->	O
owl_threat_status	enum
)	O
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_defense_code        %d\n"	pointer
,	O
d2	int
->	O
owl_defense_code	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_defense_point       %1m\n"	pointer
,	O
d2	int
->	O
owl_defense_point	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_defense_certain     %s\n"	pointer
,	O
(	O
d2	int
->	O
owl_defense_certain	int
)	O
?	O
"YES"	pointer
:	O
"NO"	pointer
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_2nd_defense_point   %1m\n"	pointer
,	O
d2	int
->	O
owl_second_defense_point	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_attack_kworm        %1m\n"	pointer
,	O
d2	int
->	O
owl_attack_kworm	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"owl_defense_kworm       %1m\n"	pointer
,	O
d2	int
->	O
owl_defense_kworm	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"semeais                 %d\n"	pointer
,	O
d2	int
->	O
semeais	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"semeai_defense_code     %d\n"	pointer
,	O
d2	int
->	O
semeai_defense_code	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"semeai_defense_point    %1m\n"	pointer
,	O
d2	int
->	O
semeai_defense_point	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"semeai_defense_certain  %d\n"	pointer
,	O
d2	int
->	O
semeai_defense_certain	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"semeai_defense_target   %1m\n"	pointer
,	O
d2	int
->	O
semeai_defense_target	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"semeai_attack_code      %d\n"	pointer
,	O
d2	int
->	O
semeai_attack_code	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"semeai_attack_point     %1m\n"	pointer
,	O
d2	int
->	O
semeai_attack_point	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"semeai_attack_certain   %d\n"	pointer
,	O
d2	int
->	O
semeai_attack_certain	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"semeai_attack_target    %1m\n"	pointer
,	O
d2	int
->	O
semeai_attack_target	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"strings                 "	pointer
)	O
;	O
for	O
(	O
w	int
=	O
first_worm_in_dragon	function
(	O
pos	int
)	O
;	O
w	int
!=	O
NO_MOVE	O
;	O
w	int
=	O
next_worm_in_dragon	function
(	O
w	int
)	O
)	O
gfprintf	function
(	O
outfile	pointer
,	O
"%1m "	pointer
,	O
w	int
)	O
;	O
gfprintf	function
(	O
outfile	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
