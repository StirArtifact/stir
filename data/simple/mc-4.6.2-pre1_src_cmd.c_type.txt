int	O
output_starts_shell	int
=	O
0	int
;	O
int	O
use_internal_edit	int
=	O
1	int
;	O
int	O
view_file_at_line	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
int	O
plain_view	int
,	O
int	O
internal	int
,	O
int	O
start_line	int
)	O
{	O
static	O
const	O
char	O
*	O
viewer	pointer
=	O
NULL	O
;	O
int	O
move_dir	pointer
=	O
0	int
;	O
if	O
(	O
plain_view	int
)	O
{	O
int	O
changed_hex_mode	int
=	O
0	int
;	O
int	O
changed_nroff_flag	int
=	O
0	int
;	O
int	O
changed_magic_flag	int
=	O
0	int
;	O
altered_hex_mode	int
=	O
0	int
;	O
altered_nroff_flag	int
=	O
0	int
;	O
altered_magic_flag	int
=	O
0	int
;	O
if	O
(	O
default_hex_mode	int
)	O
changed_hex_mode	int
=	O
1	int
;	O
if	O
(	O
default_nroff_flag	int
)	O
changed_nroff_flag	int
=	O
1	int
;	O
if	O
(	O
default_magic_flag	int
)	O
changed_magic_flag	int
=	O
1	int
;	O
default_hex_mode	int
=	O
0	int
;	O
default_nroff_flag	int
=	O
0	int
;	O
default_magic_flag	int
=	O
0	int
;	O
mc_internal_viewer	function
(	O
NULL	O
,	O
filename	pointer
,	O
&	O
move_dir	pointer
,	O
start_line	int
)	O
;	O
if	O
(	O
changed_hex_mode	int
&&	O
!	O
altered_hex_mode	int
)	O
default_hex_mode	int
=	O
1	int
;	O
if	O
(	O
changed_nroff_flag	int
&&	O
!	O
altered_nroff_flag	int
)	O
default_nroff_flag	int
=	O
1	int
;	O
if	O
(	O
changed_magic_flag	int
&&	O
!	O
altered_magic_flag	int
)	O
default_magic_flag	int
=	O
1	int
;	O
repaint_screen	function
(	O
)	O
;	O
return	O
move_dir	pointer
;	O
}	O
if	O
(	O
internal	int
)	O
{	O
char	O
view_entry	array
[	O
BUF_TINY	int
]	O
;	O
if	O
(	O
start_line	int
!=	O
0	int
)	O
g_snprintf	function
(	O
view_entry	array
,	O
sizeof	O
(	O
view_entry	array
)	O
,	O
"View:%d"	pointer
,	O
start_line	int
)	O
;	O
else	O
strcpy	function
(	O
view_entry	array
,	O
"View"	pointer
)	O
;	O
if	O
(	O
regex_command	function
(	O
filename	pointer
,	O
view_entry	array
,	O
&	O
move_dir	pointer
)	O
==	O
0	int
)	O
{	O
mc_internal_viewer	function
(	O
NULL	O
,	O
filename	pointer
,	O
&	O
move_dir	pointer
,	O
start_line	int
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
viewer	pointer
)	O
{	O
viewer	pointer
=	O
getenv	function
(	O
"VIEWER"	pointer
)	O
;	O
if	O
(	O
!	O
viewer	pointer
)	O
viewer	pointer
=	O
getenv	function
(	O
"PAGER"	pointer
)	O
;	O
if	O
(	O
!	O
viewer	pointer
)	O
viewer	pointer
=	O
"view"	pointer
;	O
}	O
execute_with_vfs_arg	function
(	O
viewer	pointer
,	O
filename	pointer
)	O
;	O
}	O
return	O
move_dir	pointer
;	O
}	O
int	O
view_file	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
int	O
plain_view	int
,	O
int	O
internal	int
)	O
{	O
return	O
view_file_at_line	function
(	O
filename	pointer
,	O
plain_view	int
,	O
internal	int
,	O
0	int
)	O
;	O
}	O
static	O
int	O
scan_for_file	function
(	O
WPanel	struct
*	O
panel	pointer
,	O
int	O
idx	int
,	O
int	O
direction	int
)	O
{	O
int	O
i	array
=	O
idx	int
+	O
direction	int
;	O
while	O
(	O
i	array
!=	O
idx	int
)	O
{	O
if	O
(	O
i	array
<	O
0	int
)	O
i	array
=	O
panel	pointer
->	O
count	int
-	O
1	int
;	O
if	O
(	O
i	array
==	O
panel	pointer
->	O
count	int
)	O
i	array
=	O
0	int
;	O
if	O
(	O
!	O
S_ISDIR	O
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
st	pointer
.	O
st_mode	int
)	O
)	O
return	O
i	array
;	O
i	array
+=	O
direction	int
;	O
}	O
return	O
i	array
;	O
}	O
static	O
void	O
do_view_cmd	function
(	O
int	O
normal	int
)	O
{	O
int	O
dir	pointer
,	O
file_idx	int
;	O
if	O
(	O
S_ISDIR	O
(	O
selection	O
(	O
current_panel	pointer
)	O
->	O
st	pointer
.	O
st_mode	int
)	O
||	O
link_isdir	function
(	O
selection	O
(	O
current_panel	pointer
)	O
)	O
)	O
{	O
if	O
(	O
confirm_view_dir	int
&&	O
(	O
current_panel	pointer
->	O
marked	int
||	O
current_panel	pointer
->	O
dirs_marked	int
)	O
)	O
{	O
if	O
(	O
query_dialog	function
(	O
_	O
(	O
" Confirmation "	pointer
)	O
,	O
_	O
(	O
"Files tagged, want to cd?"	pointer
)	O
,	O
0	int
,	O
2	int
,	O
_	O
(	O
"&Yes"	pointer
)	O
,	O
_	O
(	O
"&No"	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
return	O
;	O
}	O
}	O
if	O
(	O
!	O
do_cd	function
(	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
,	O
cd_exact	int
)	O
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot change directory"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
file_idx	int
=	O
current_panel	pointer
->	O
selected	int
;	O
while	O
(	O
1	int
)	O
{	O
char	O
*	O
filename	pointer
;	O
filename	pointer
=	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
file_idx	int
]	O
.	O
fname	pointer
;	O
dir	pointer
=	O
view_file	function
(	O
filename	pointer
,	O
normal	int
,	O
use_internal_view	int
)	O
;	O
if	O
(	O
dir	pointer
==	O
0	int
)	O
break	O
;	O
file_idx	int
=	O
scan_for_file	function
(	O
current_panel	pointer
,	O
file_idx	int
,	O
dir	pointer
)	O
;	O
}	O
}	O
void	O
view_cmd	function
(	O
void	O
)	O
{	O
do_view_cmd	function
(	O
0	int
)	O
;	O
}	O
void	O
view_file_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
filename	pointer
;	O
filename	pointer
=	O
input_expand_dialog	function
(	O
_	O
(	O
" View file "	pointer
)	O
,	O
_	O
(	O
" Filename:"	pointer
)	O
,	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
)	O
;	O
if	O
(	O
!	O
filename	pointer
)	O
return	O
;	O
view_file	function
(	O
filename	pointer
,	O
0	int
,	O
use_internal_view	int
)	O
;	O
g_free	function
(	O
filename	pointer
)	O
;	O
}	O
void	O
view_simple_cmd	function
(	O
void	O
)	O
{	O
do_view_cmd	function
(	O
1	int
)	O
;	O
}	O
void	O
filtered_view_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
command	pointer
;	O
command	pointer
=	O
input_dialog	function
(	O
_	O
(	O
" Filtered view "	pointer
)	O
,	O
_	O
(	O
" Filter command and arguments:"	pointer
)	O
,	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
)	O
;	O
if	O
(	O
!	O
command	pointer
)	O
return	O
;	O
mc_internal_viewer	function
(	O
command	pointer
,	O
""	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
g_free	function
(	O
command	pointer
)	O
;	O
}	O
void	O
do_edit_at_line	function
(	O
const	O
char	O
*	O
what	pointer
,	O
int	O
start_line	int
)	O
{	O
static	O
const	O
char	O
*	O
editor	pointer
=	O
NULL	O
;	O
if	O
(	O
use_internal_edit	int
)	O
{	O
edit_file	function
(	O
what	pointer
,	O
start_line	int
)	O
;	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
editor	pointer
)	O
{	O
editor	pointer
=	O
getenv	function
(	O
"EDITOR"	pointer
)	O
;	O
if	O
(	O
!	O
editor	pointer
)	O
editor	pointer
=	O
get_default_editor	pointer
(	O
)	O
;	O
}	O
execute_with_vfs_arg	function
(	O
editor	pointer
,	O
what	pointer
)	O
;	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
static	O
void	O
do_edit	function
(	O
const	O
char	O
*	O
what	pointer
)	O
{	O
do_edit_at_line	function
(	O
what	pointer
,	O
0	int
)	O
;	O
}	O
void	O
edit_cmd	function
(	O
void	O
)	O
{	O
if	O
(	O
regex_command	function
(	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
,	O
"Edit"	pointer
,	O
0	int
)	O
==	O
0	int
)	O
do_edit	function
(	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
)	O
;	O
}	O
void	O
edit_cmd_new	function
(	O
void	O
)	O
{	O
do_edit	function
(	O
NULL	O
)	O
;	O
}	O
void	O
copy_cmd	function
(	O
void	O
)	O
{	O
save_cwds_stat	function
(	O
)	O
;	O
if	O
(	O
panel_operate	function
(	O
current_panel	pointer
,	O
OP_COPY	int
,	O
0	int
)	O
)	O
{	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
}	O
void	O
ren_cmd	function
(	O
void	O
)	O
{	O
save_cwds_stat	function
(	O
)	O
;	O
if	O
(	O
panel_operate	function
(	O
current_panel	pointer
,	O
OP_MOVE	int
,	O
0	int
)	O
)	O
{	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
}	O
void	O
copy_cmd_local	function
(	O
void	O
)	O
{	O
save_cwds_stat	function
(	O
)	O
;	O
if	O
(	O
panel_operate	function
(	O
current_panel	pointer
,	O
OP_COPY	int
,	O
1	int
)	O
)	O
{	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
}	O
void	O
ren_cmd_local	function
(	O
void	O
)	O
{	O
save_cwds_stat	function
(	O
)	O
;	O
if	O
(	O
panel_operate	function
(	O
current_panel	pointer
,	O
OP_MOVE	int
,	O
1	int
)	O
)	O
{	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
}	O
void	O
mkdir_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
dir	pointer
,	O
*	O
absdir	pointer
;	O
dir	pointer
=	O
input_expand_dialog	function
(	O
_	O
(	O
"Create a new Directory"	pointer
)	O
,	O
_	O
(	O
" Enter directory name:"	pointer
)	O
,	O
""	pointer
)	O
;	O
if	O
(	O
!	O
dir	pointer
)	O
return	O
;	O
if	O
(	O
dir	pointer
[	O
0	int
]	O
==	O
'/'	O
||	O
dir	pointer
[	O
0	int
]	O
==	O
'~'	O
)	O
absdir	pointer
=	O
g_strdup	function
(	O
dir	pointer
)	O
;	O
else	O
absdir	pointer
=	O
concat_dir_and_file	function
(	O
current_panel	pointer
->	O
cwd	short
,	O
dir	pointer
)	O
;	O
save_cwds_stat	function
(	O
)	O
;	O
if	O
(	O
my_mkdir	function
(	O
absdir	pointer
,	O
0777	int
)	O
==	O
0	int
)	O
{	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
dir	pointer
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
select_item	function
(	O
current_panel	pointer
)	O
;	O
}	O
else	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
"  %s  "	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
}	O
g_free	function
(	O
absdir	pointer
)	O
;	O
g_free	function
(	O
dir	pointer
)	O
;	O
}	O
void	O
delete_cmd	function
(	O
void	O
)	O
{	O
save_cwds_stat	function
(	O
)	O
;	O
if	O
(	O
panel_operate	function
(	O
current_panel	pointer
,	O
OP_DELETE	int
,	O
0	int
)	O
)	O
{	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
}	O
void	O
delete_cmd_local	function
(	O
void	O
)	O
{	O
save_cwds_stat	function
(	O
)	O
;	O
if	O
(	O
panel_operate	function
(	O
current_panel	pointer
,	O
OP_DELETE	int
,	O
1	int
)	O
)	O
{	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
}	O
void	O
find_cmd	function
(	O
void	O
)	O
{	O
do_find	function
(	O
)	O
;	O
}	O
static	O
void	O
set_panel_filter_to	function
(	O
WPanel	struct
*	O
p	pointer
,	O
char	O
*	O
allocated_filter_string	pointer
)	O
{	O
g_free	function
(	O
p	pointer
->	O
filter	pointer
)	O
;	O
p	pointer
->	O
filter	pointer
=	O
0	int
;	O
if	O
(	O
!	O
(	O
allocated_filter_string	pointer
[	O
0	int
]	O
==	O
'*'	O
&&	O
allocated_filter_string	pointer
[	O
1	int
]	O
==	O
0	int
)	O
)	O
p	pointer
->	O
filter	pointer
=	O
allocated_filter_string	pointer
;	O
else	O
g_free	function
(	O
allocated_filter_string	pointer
)	O
;	O
reread_cmd	function
(	O
)	O
;	O
}	O
static	O
void	O
set_panel_filter	function
(	O
WPanel	struct
*	O
p	pointer
)	O
{	O
char	O
*	O
reg_exp	pointer
;	O
const	O
char	O
*	O
x	array
;	O
x	array
=	O
p	pointer
->	O
filter	pointer
?	O
p	pointer
->	O
filter	pointer
:	O
easy_patterns	int
?	O
"*"	pointer
:	O
"."	pointer
;	O
reg_exp	pointer
=	O
input_dialog_help	function
(	O
_	O
(	O
" Filter "	pointer
)	O
,	O
_	O
(	O
" Set expression for filtering filenames"	pointer
)	O
,	O
"[Filter...]"	pointer
,	O
x	array
)	O
;	O
if	O
(	O
!	O
reg_exp	pointer
)	O
return	O
;	O
set_panel_filter_to	function
(	O
p	pointer
,	O
reg_exp	pointer
)	O
;	O
}	O
void	O
filter_cmd	function
(	O
void	O
)	O
{	O
WPanel	struct
*	O
p	pointer
;	O
if	O
(	O
!	O
SELECTED_IS_PANEL	O
)	O
return	O
;	O
p	pointer
=	O
MENU_PANEL	O
;	O
set_panel_filter	function
(	O
p	pointer
)	O
;	O
}	O
void	O
reread_cmd	function
(	O
void	O
)	O
{	O
int	O
flag	int
;	O
if	O
(	O
get_current_type	function
(	O
)	O
==	O
view_listing	int
&&	O
get_other_type	function
(	O
)	O
==	O
view_listing	int
)	O
flag	int
=	O
strcmp	function
(	O
current_panel	pointer
->	O
cwd	short
,	O
other_panel	O
->	O
cwd	short
)	O
?	O
UP_ONLY_CURRENT	int
:	O
0	int
;	O
else	O
flag	int
=	O
UP_ONLY_CURRENT	int
;	O
update_panels	function
(	O
UP_RELOAD	int
|	O
flag	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
void	O
reverse_selection_cmd	function
(	O
void	O
)	O
{	O
file_entry	struct
*	O
file	pointer
;	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
current_panel	pointer
->	O
count	int
;	O
i	array
++	O
)	O
{	O
file	pointer
=	O
&	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
;	O
if	O
(	O
S_ISDIR	O
(	O
file	pointer
->	O
st	pointer
.	O
st_mode	int
)	O
)	O
continue	O
;	O
do_file_mark	function
(	O
current_panel	pointer
,	O
i	array
,	O
!	O
file	pointer
->	O
f	float
.	O
marked	int
)	O
;	O
}	O
}	O
static	O
void	O
select_unselect_cmd	function
(	O
const	O
char	O
*	O
title	pointer
,	O
int	O
cmd	pointer
)	O
{	O
char	O
*	O
reg_exp	pointer
,	O
*	O
reg_exp_t	pointer
;	O
int	O
i	array
;	O
int	O
c	int
;	O
int	O
dirflag	int
=	O
0	int
;	O
reg_exp	pointer
=	O
input_dialog	function
(	O
title	pointer
,	O
""	pointer
,	O
easy_patterns	int
?	O
"*"	pointer
:	O
"."	pointer
)	O
;	O
if	O
(	O
!	O
reg_exp	pointer
)	O
return	O
;	O
if	O
(	O
!	O
*	O
reg_exp	pointer
)	O
{	O
g_free	function
(	O
reg_exp	pointer
)	O
;	O
return	O
;	O
}	O
reg_exp_t	pointer
=	O
reg_exp	pointer
;	O
if	O
(	O
*	O
reg_exp_t	pointer
==	O
PATH_SEP	char
)	O
{	O
dirflag	int
=	O
1	int
;	O
reg_exp_t	pointer
++	O
;	O
}	O
if	O
(	O
reg_exp_t	pointer
[	O
strlen	function
(	O
reg_exp_t	pointer
)	O
-	O
1	int
]	O
==	O
PATH_SEP	char
)	O
{	O
dirflag	int
=	O
1	int
;	O
reg_exp_t	pointer
[	O
strlen	function
(	O
reg_exp_t	pointer
)	O
-	O
1	int
]	O
=	O
0	int
;	O
}	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
current_panel	pointer
->	O
count	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
,	O
".."	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
S_ISDIR	O
(	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
!	O
dirflag	int
)	O
continue	O
;	O
}	O
else	O
{	O
if	O
(	O
dirflag	int
)	O
continue	O
;	O
}	O
c	int
=	O
regexp_match	function
(	O
reg_exp_t	pointer
,	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
,	O
match_file	int
)	O
;	O
if	O
(	O
c	int
==	O
-	O
1	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"  Malformed regular expression  "	pointer
)	O
)	O
;	O
g_free	function
(	O
reg_exp	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
c	int
)	O
{	O
do_file_mark	function
(	O
current_panel	pointer
,	O
i	array
,	O
cmd	pointer
)	O
;	O
}	O
}	O
g_free	function
(	O
reg_exp	pointer
)	O
;	O
}	O
void	O
select_cmd	function
(	O
void	O
)	O
{	O
select_unselect_cmd	function
(	O
_	O
(	O
" Select "	pointer
)	O
,	O
1	int
)	O
;	O
}	O
void	O
unselect_cmd	function
(	O
void	O
)	O
{	O
select_unselect_cmd	function
(	O
_	O
(	O
" Unselect "	pointer
)	O
,	O
0	int
)	O
;	O
}	O
static	O
int	O
check_for_default	function
(	O
char	O
*	O
default_file	pointer
,	O
char	O
*	O
file	pointer
)	O
{	O
struct	O
stat	struct
s	pointer
;	O
off_t	long
count	int
=	O
0	int
;	O
double	O
bytes	pointer
=	O
0	int
;	O
FileOpContext	struct
*	O
ctx	pointer
;	O
if	O
(	O
mc_stat	function
(	O
file	pointer
,	O
&	O
s	pointer
)	O
)	O
{	O
if	O
(	O
mc_stat	function
(	O
default_file	pointer
,	O
&	O
s	pointer
)	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
ctx	pointer
=	O
file_op_context_new	function
(	O
OP_COPY	int
)	O
;	O
file_op_context_create_ui	function
(	O
ctx	pointer
,	O
0	int
)	O
;	O
copy_file_file	function
(	O
ctx	pointer
,	O
default_file	pointer
,	O
file	pointer
,	O
1	int
,	O
&	O
count	int
,	O
&	O
bytes	pointer
,	O
1	int
)	O
;	O
file_op_context_destroy	function
(	O
ctx	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
ext_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
buffer	pointer
;	O
char	O
*	O
extdir	pointer
;	O
int	O
dir	pointer
;	O
dir	pointer
=	O
0	int
;	O
if	O
(	O
geteuid	function
(	O
)	O
==	O
0	int
)	O
{	O
dir	pointer
=	O
query_dialog	function
(	O
_	O
(	O
"Extension file edit"	pointer
)	O
,	O
_	O
(	O
" Which extension file you want to edit? "	pointer
)	O
,	O
0	int
,	O
2	int
,	O
_	O
(	O
"&User"	pointer
)	O
,	O
_	O
(	O
"&System Wide"	pointer
)	O
)	O
;	O
}	O
extdir	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
MC_LIB_EXT	pointer
)	O
;	O
if	O
(	O
dir	pointer
==	O
0	int
)	O
{	O
buffer	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
MC_USER_EXT	pointer
)	O
;	O
check_for_default	function
(	O
extdir	pointer
,	O
buffer	pointer
)	O
;	O
do_edit	function
(	O
buffer	pointer
)	O
;	O
g_free	function
(	O
buffer	pointer
)	O
;	O
}	O
else	O
if	O
(	O
dir	pointer
==	O
1	int
)	O
do_edit	function
(	O
extdir	pointer
)	O
;	O
g_free	function
(	O
extdir	pointer
)	O
;	O
flush_extension_file	function
(	O
)	O
;	O
}	O
static	O
void	O
menu_edit_cmd	function
(	O
int	O
where	int
)	O
{	O
char	O
*	O
buffer	pointer
;	O
char	O
*	O
menufile	pointer
;	O
int	O
dir	pointer
=	O
0	int
;	O
dir	pointer
=	O
query_dialog	function
(	O
_	O
(	O
" Menu edit "	pointer
)	O
,	O
_	O
(	O
" Which menu file do you want to edit? "	pointer
)	O
,	O
0	int
,	O
geteuid	function
(	O
)	O
?	O
2	int
:	O
3	int
,	O
_	O
(	O
"&Local"	pointer
)	O
,	O
_	O
(	O
"&Home"	pointer
)	O
,	O
_	O
(	O
"&System Wide"	pointer
)	O
)	O
;	O
menufile	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
where	int
?	O
CEDIT_GLOBAL_MENU	pointer
:	O
MC_GLOBAL_MENU	pointer
)	O
;	O
switch	O
(	O
dir	pointer
)	O
{	O
case	O
0	int
:	O
buffer	pointer
=	O
g_strdup	function
(	O
where	int
?	O
CEDIT_LOCAL_MENU	pointer
:	O
MC_LOCAL_MENU	pointer
)	O
;	O
check_for_default	function
(	O
menufile	pointer
,	O
buffer	pointer
)	O
;	O
break	O
;	O
case	O
1	int
:	O
buffer	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
where	int
?	O
CEDIT_HOME_MENU	pointer
:	O
MC_HOME_MENU	pointer
)	O
;	O
check_for_default	function
(	O
menufile	pointer
,	O
buffer	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
buffer	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
where	int
?	O
CEDIT_GLOBAL_MENU	pointer
:	O
MC_GLOBAL_MENU	pointer
)	O
;	O
break	O
;	O
default	O
:	O
g_free	function
(	O
menufile	pointer
)	O
;	O
return	O
;	O
}	O
do_edit	function
(	O
buffer	pointer
)	O
;	O
if	O
(	O
dir	pointer
==	O
0	int
)	O
chmod	function
(	O
buffer	pointer
,	O
0600	int
)	O
;	O
g_free	function
(	O
buffer	pointer
)	O
;	O
g_free	function
(	O
menufile	pointer
)	O
;	O
}	O
void	O
quick_chdir_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
target	pointer
;	O
target	pointer
=	O
hotlist_cmd	function
(	O
LIST_HOTLIST	int
)	O
;	O
if	O
(	O
!	O
target	pointer
)	O
return	O
;	O
if	O
(	O
get_current_type	function
(	O
)	O
==	O
view_tree	int
)	O
tree_chdir	function
(	O
the_tree	pointer
,	O
target	pointer
)	O
;	O
else	O
if	O
(	O
!	O
do_cd	function
(	O
target	pointer
,	O
cd_exact	int
)	O
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot change directory"	pointer
)	O
)	O
;	O
g_free	function
(	O
target	pointer
)	O
;	O
}	O
void	O
edit_mc_menu_cmd	function
(	O
void	O
)	O
{	O
menu_edit_cmd	function
(	O
0	int
)	O
;	O
}	O
void	O
edit_user_menu_cmd	function
(	O
void	O
)	O
{	O
menu_edit_cmd	function
(	O
1	int
)	O
;	O
}	O
void	O
edit_syntax_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
buffer	pointer
;	O
char	O
*	O
extdir	pointer
;	O
int	O
dir	pointer
=	O
0	int
;	O
if	O
(	O
geteuid	function
(	O
)	O
==	O
0	int
)	O
{	O
dir	pointer
=	O
query_dialog	function
(	O
_	O
(	O
"Syntax file edit"	pointer
)	O
,	O
_	O
(	O
" Which syntax file you want to edit? "	pointer
)	O
,	O
0	int
,	O
2	int
,	O
_	O
(	O
"&User"	pointer
)	O
,	O
_	O
(	O
"&System Wide"	pointer
)	O
)	O
;	O
}	O
extdir	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
"syntax"	pointer
PATH_SEP_STR	pointer
"Syntax"	pointer
)	O
;	O
if	O
(	O
dir	pointer
==	O
0	int
)	O
{	O
buffer	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
SYNTAX_FILE	O
)	O
;	O
check_for_default	function
(	O
extdir	pointer
,	O
buffer	pointer
)	O
;	O
do_edit	function
(	O
buffer	pointer
)	O
;	O
g_free	function
(	O
buffer	pointer
)	O
;	O
}	O
else	O
if	O
(	O
dir	pointer
==	O
1	int
)	O
do_edit	function
(	O
extdir	pointer
)	O
;	O
g_free	function
(	O
extdir	pointer
)	O
;	O
}	O
void	O
reselect_vfs	function
(	O
void	O
)	O
{	O
char	O
*	O
target	pointer
;	O
target	pointer
=	O
hotlist_cmd	function
(	O
LIST_VFSLIST	int
)	O
;	O
if	O
(	O
!	O
target	pointer
)	O
return	O
;	O
if	O
(	O
!	O
do_cd	function
(	O
target	pointer
,	O
cd_exact	int
)	O
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"Cannot change directory"	pointer
)	O
)	O
;	O
g_free	function
(	O
target	pointer
)	O
;	O
}	O
static	O
int	O
compare_files	function
(	O
char	O
*	O
name1	pointer
,	O
char	O
*	O
name2	pointer
,	O
off_t	long
size	long
)	O
{	O
int	O
file1	int
,	O
file2	int
;	O
int	O
result	long
=	O
-	O
1	int
;	O
file1	int
=	O
open	function
(	O
name1	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
file1	int
>=	O
0	int
)	O
{	O
file2	int
=	O
open	function
(	O
name2	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
file2	int
>=	O
0	int
)	O
{	O
char	O
*	O
data1	pointer
,	O
*	O
data2	pointer
;	O
data1	pointer
=	O
mmap	function
(	O
0	int
,	O
size	long
,	O
PROT_READ	int
,	O
MAP_FILE	int
|	O
MAP_PRIVATE	int
,	O
file1	int
,	O
0	int
)	O
;	O
if	O
(	O
data1	pointer
!=	O
(	O
char	O
*	O
)	O
-	O
1	int
)	O
{	O
data2	pointer
=	O
mmap	function
(	O
0	int
,	O
size	long
,	O
PROT_READ	int
,	O
MAP_FILE	int
|	O
MAP_PRIVATE	int
,	O
file2	int
,	O
0	int
)	O
;	O
if	O
(	O
data2	pointer
!=	O
(	O
char	O
*	O
)	O
-	O
1	int
)	O
{	O
rotate_dash	function
(	O
)	O
;	O
result	long
=	O
memcmp	function
(	O
data1	pointer
,	O
data2	pointer
,	O
size	long
)	O
;	O
munmap	function
(	O
data2	pointer
,	O
size	long
)	O
;	O
}	O
munmap	function
(	O
data1	pointer
,	O
size	long
)	O
;	O
}	O
close	pointer
(	O
file2	int
)	O
;	O
}	O
close	pointer
(	O
file1	int
)	O
;	O
}	O
return	O
result	long
;	O
}	O
enum	O
CompareMode	enum
{	O
compare_quick	int
,	O
compare_size_only	int
,	O
compare_thourough	int
}	O
;	O
static	O
void	O
compare_dir	function
(	O
WPanel	struct
*	O
panel	pointer
,	O
WPanel	struct
*	O
other	pointer
,	O
enum	O
CompareMode	enum
mode	int
)	O
{	O
int	O
i	array
,	O
j	int
;	O
char	O
*	O
src_name	pointer
,	O
*	O
dst_name	pointer
;	O
panel	pointer
->	O
marked	int
=	O
0	int
;	O
panel	pointer
->	O
total	long
=	O
0	int
;	O
panel	pointer
->	O
dirs_marked	int
=	O
0	int
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
panel	pointer
->	O
count	int
;	O
i	array
++	O
)	O
{	O
file_entry	struct
*	O
source	pointer
=	O
&	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
;	O
file_mark	function
(	O
panel	pointer
,	O
i	array
,	O
0	int
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
source	pointer
->	O
st	pointer
.	O
st_mode	int
)	O
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
other	pointer
->	O
count	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
source	pointer
->	O
fname	pointer
,	O
other	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
j	int
]	O
.	O
fname	pointer
)	O
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
j	int
>=	O
other	pointer
->	O
count	int
)	O
do_file_mark	function
(	O
panel	pointer
,	O
i	array
,	O
1	int
)	O
;	O
else	O
{	O
file_entry	struct
*	O
target	pointer
=	O
&	O
other	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
j	int
]	O
;	O
if	O
(	O
mode	int
!=	O
compare_size_only	int
)	O
{	O
if	O
(	O
source	pointer
->	O
st	pointer
.	O
st_mtime	O
<	O
target	pointer
->	O
st	pointer
.	O
st_mtime	O
)	O
continue	O
;	O
}	O
if	O
(	O
source	pointer
->	O
st	pointer
.	O
st_size	long
!=	O
target	pointer
->	O
st	pointer
.	O
st_size	long
)	O
{	O
do_file_mark	function
(	O
panel	pointer
,	O
i	array
,	O
1	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
mode	int
==	O
compare_size_only	int
)	O
continue	O
;	O
if	O
(	O
mode	int
==	O
compare_quick	int
)	O
{	O
if	O
(	O
source	pointer
->	O
st	pointer
.	O
st_mtime	O
>	O
target	pointer
->	O
st	pointer
.	O
st_mtime	O
)	O
{	O
do_file_mark	function
(	O
panel	pointer
,	O
i	array
,	O
1	int
)	O
;	O
}	O
continue	O
;	O
}	O
src_name	pointer
=	O
concat_dir_and_file	function
(	O
panel	pointer
->	O
cwd	short
,	O
source	pointer
->	O
fname	pointer
)	O
;	O
dst_name	pointer
=	O
concat_dir_and_file	function
(	O
other	pointer
->	O
cwd	short
,	O
target	pointer
->	O
fname	pointer
)	O
;	O
if	O
(	O
compare_files	function
(	O
src_name	pointer
,	O
dst_name	pointer
,	O
source	pointer
->	O
st	pointer
.	O
st_size	long
)	O
)	O
do_file_mark	function
(	O
panel	pointer
,	O
i	array
,	O
1	int
)	O
;	O
g_free	function
(	O
src_name	pointer
)	O
;	O
g_free	function
(	O
dst_name	pointer
)	O
;	O
}	O
}	O
}	O
void	O
compare_dirs_cmd	function
(	O
void	O
)	O
{	O
int	O
choice	int
;	O
enum	O
CompareMode	enum
thorough_flag	enum
;	O
choice	int
=	O
query_dialog	function
(	O
_	O
(	O
" Compare directories "	pointer
)	O
,	O
_	O
(	O
" Select compare method: "	pointer
)	O
,	O
0	int
,	O
3	int
,	O
_	O
(	O
"&Quick"	pointer
)	O
,	O
_	O
(	O
"&Size only"	pointer
)	O
,	O
_	O
(	O
"&Thorough"	pointer
)	O
,	O
_	O
(	O
"&Cancel"	pointer
)	O
)	O
;	O
if	O
(	O
choice	int
<	O
0	int
||	O
choice	int
>	O
2	int
)	O
return	O
;	O
else	O
thorough_flag	enum
=	O
choice	int
;	O
if	O
(	O
get_current_type	function
(	O
)	O
==	O
view_listing	int
&&	O
get_other_type	function
(	O
)	O
==	O
view_listing	int
)	O
{	O
compare_dir	function
(	O
current_panel	pointer
,	O
other_panel	O
,	O
thorough_flag	enum
)	O
;	O
compare_dir	function
(	O
other_panel	O
,	O
current_panel	pointer
,	O
thorough_flag	enum
)	O
;	O
}	O
else	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Both panels should be in the "	pointer
"listing mode to use this command "	pointer
)	O
)	O
;	O
}	O
}	O
void	O
history_cmd	function
(	O
void	O
)	O
{	O
Listbox	struct
*	O
listbox	pointer
;	O
GList	struct
*	O
current	pointer
;	O
if	O
(	O
cmdline	pointer
->	O
need_push	int
)	O
{	O
if	O
(	O
push_history	function
(	O
cmdline	pointer
,	O
cmdline	pointer
->	O
buffer	pointer
)	O
==	O
2	int
)	O
cmdline	pointer
->	O
need_push	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
cmdline	pointer
->	O
history	pointer
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" The command history is empty "	pointer
)	O
)	O
;	O
return	O
;	O
}	O
current	pointer
=	O
g_list_first	function
(	O
cmdline	pointer
->	O
history	pointer
)	O
;	O
listbox	pointer
=	O
create_listbox_window	function
(	O
60	int
,	O
10	int
,	O
_	O
(	O
" Command history "	pointer
)	O
,	O
"[Command Menu]"	pointer
)	O
;	O
while	O
(	O
current	pointer
)	O
{	O
LISTBOX_APPEND_TEXT	O
(	O
listbox	pointer
,	O
0	int
,	O
(	O
char	O
*	O
)	O
current	pointer
->	O
data	pointer
,	O
current	pointer
)	O
;	O
current	pointer
=	O
g_list_next	O
(	O
current	pointer
)	O
;	O
}	O
run_dlg	function
(	O
listbox	pointer
->	O
dlg	pointer
)	O
;	O
if	O
(	O
listbox	pointer
->	O
dlg	pointer
->	O
ret_value	int
==	O
B_CANCEL	int
)	O
current	pointer
=	O
NULL	O
;	O
else	O
current	pointer
=	O
listbox	pointer
->	O
list	pointer
->	O
current	pointer
->	O
data	pointer
;	O
destroy_dlg	function
(	O
listbox	pointer
->	O
dlg	pointer
)	O
;	O
g_free	function
(	O
listbox	pointer
)	O
;	O
if	O
(	O
!	O
current	pointer
)	O
return	O
;	O
cmdline	pointer
->	O
history	pointer
=	O
current	pointer
;	O
assign_text	function
(	O
cmdline	pointer
,	O
(	O
char	O
*	O
)	O
current	pointer
->	O
data	pointer
)	O
;	O
update_input	function
(	O
cmdline	pointer
,	O
1	int
)	O
;	O
}	O
void	O
swap_cmd	function
(	O
void	O
)	O
{	O
swap_panels	function
(	O
)	O
;	O
touchwin	O
(	O
stdscr	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
void	O
view_other_cmd	function
(	O
void	O
)	O
{	O
static	O
int	O
message_flag	int
=	O
TRUE	O
;	O
if	O
(	O
!	O
xterm_flag	int
&&	O
!	O
console_flag	char
&&	O
!	O
use_subshell	int
&&	O
!	O
output_starts_shell	int
)	O
{	O
if	O
(	O
message_flag	int
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Not an xterm or Linux console; \n"	pointer
" the panels cannot be toggled. "	pointer
)	O
)	O
;	O
message_flag	int
=	O
FALSE	O
;	O
}	O
else	O
{	O
toggle_panels	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
do_link	function
(	O
int	O
symbolic_link	int
,	O
const	O
char	O
*	O
fname	pointer
)	O
{	O
char	O
*	O
dest	pointer
=	O
NULL	O
,	O
*	O
src	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
symbolic_link	int
)	O
{	O
src	pointer
=	O
g_strdup_printf	function
(	O
_	O
(	O
"Link %s to:"	pointer
)	O
,	O
name_trunc	function
(	O
fname	pointer
,	O
46	int
)	O
)	O
;	O
dest	pointer
=	O
input_expand_dialog	function
(	O
_	O
(	O
" Link "	pointer
)	O
,	O
src	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
!	O
dest	pointer
||	O
!	O
*	O
dest	pointer
)	O
goto	O
cleanup	O
;	O
save_cwds_stat	function
(	O
)	O
;	O
if	O
(	O
-	O
1	int
==	O
mc_link	function
(	O
fname	pointer
,	O
dest	pointer
)	O
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" link: %s "	pointer
)	O
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
char	O
*	O
s	pointer
;	O
char	O
*	O
d	double
;	O
s	pointer
=	O
concat_dir_and_file	function
(	O
current_panel	pointer
->	O
cwd	short
,	O
fname	pointer
)	O
;	O
if	O
(	O
get_other_type	function
(	O
)	O
==	O
view_listing	int
)	O
{	O
d	double
=	O
concat_dir_and_file	function
(	O
other_panel	O
->	O
cwd	short
,	O
fname	pointer
)	O
;	O
}	O
else	O
{	O
d	double
=	O
g_strdup	function
(	O
fname	pointer
)	O
;	O
}	O
symlink_dialog	function
(	O
s	pointer
,	O
d	double
,	O
&	O
dest	pointer
,	O
&	O
src	pointer
)	O
;	O
g_free	function
(	O
d	double
)	O
;	O
g_free	function
(	O
s	pointer
)	O
;	O
if	O
(	O
!	O
dest	pointer
||	O
!	O
*	O
dest	pointer
||	O
!	O
src	pointer
||	O
!	O
*	O
src	pointer
)	O
goto	O
cleanup	O
;	O
save_cwds_stat	function
(	O
)	O
;	O
if	O
(	O
-	O
1	int
==	O
mc_symlink	function
(	O
dest	pointer
,	O
src	pointer
)	O
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" symlink: %s "	pointer
)	O
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
}	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
cleanup	O
:	O
g_free	function
(	O
src	pointer
)	O
;	O
g_free	function
(	O
dest	pointer
)	O
;	O
}	O
void	O
link_cmd	function
(	O
void	O
)	O
{	O
do_link	function
(	O
0	int
,	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
)	O
;	O
}	O
void	O
symlink_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
filename	pointer
=	O
NULL	O
;	O
filename	pointer
=	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
;	O
if	O
(	O
filename	pointer
)	O
{	O
do_link	function
(	O
1	int
,	O
filename	pointer
)	O
;	O
}	O
}	O
void	O
edit_symlink_cmd	function
(	O
void	O
)	O
{	O
if	O
(	O
S_ISLNK	O
(	O
selection	O
(	O
current_panel	pointer
)	O
->	O
st	pointer
.	O
st_mode	int
)	O
)	O
{	O
char	O
buffer	pointer
[	O
MC_MAXPATHLEN	O
]	O
;	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
int	O
i	array
;	O
char	O
*	O
dest	pointer
,	O
*	O
q	pointer
;	O
p	pointer
=	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
;	O
q	pointer
=	O
g_strdup_printf	function
(	O
_	O
(	O
" Symlink `%s\' points to: "	pointer
)	O
,	O
name_trunc	function
(	O
p	pointer
,	O
32	int
)	O
)	O
;	O
i	array
=	O
readlink	function
(	O
p	pointer
,	O
buffer	pointer
,	O
MC_MAXPATHLEN	O
-	O
1	int
)	O
;	O
if	O
(	O
i	array
>	O
0	int
)	O
{	O
buffer	pointer
[	O
i	array
]	O
=	O
0	int
;	O
dest	pointer
=	O
input_expand_dialog	function
(	O
_	O
(	O
" Edit symlink "	pointer
)	O
,	O
q	pointer
,	O
buffer	pointer
)	O
;	O
if	O
(	O
dest	pointer
)	O
{	O
if	O
(	O
*	O
dest	pointer
&&	O
strcmp	function
(	O
buffer	pointer
,	O
dest	pointer
)	O
)	O
{	O
save_cwds_stat	function
(	O
)	O
;	O
if	O
(	O
-	O
1	int
==	O
mc_unlink	function
(	O
p	pointer
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" edit symlink, unable to remove %s: %s "	pointer
)	O
,	O
p	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
-	O
1	int
==	O
mc_symlink	function
(	O
dest	pointer
,	O
p	pointer
)	O
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" edit symlink: %s "	pointer
)	O
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
}	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
g_free	function
(	O
dest	pointer
)	O
;	O
}	O
}	O
g_free	function
(	O
q	pointer
)	O
;	O
}	O
else	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"`%s' is not a symbolic link"	pointer
)	O
,	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
)	O
;	O
}	O
}	O
void	O
help_cmd	function
(	O
void	O
)	O
{	O
interactive_display	function
(	O
NULL	O
,	O
"[main]"	pointer
)	O
;	O
}	O
void	O
user_file_menu_cmd	function
(	O
void	O
)	O
{	O
user_menu_cmd	function
(	O
NULL	O
)	O
;	O
}	O
char	O
*	O
guess_message_value	function
(	O
void	O
)	O
{	O
static	O
const	O
char	O
*	O
const	O
var	array
[	O
]	O
=	O
{	O
"LANGUAGE"	pointer
,	O
"LC_ALL"	pointer
,	O
"LC_MESSAGES"	pointer
,	O
"LANG"	pointer
,	O
NULL	O
}	O
;	O
unsigned	O
i	array
=	O
0	int
;	O
const	O
char	O
*	O
locale	pointer
=	O
NULL	O
;	O
while	O
(	O
var	array
[	O
i	array
]	O
!=	O
NULL	O
)	O
{	O
locale	pointer
=	O
getenv	function
(	O
var	array
[	O
i	array
]	O
)	O
;	O
if	O
(	O
locale	pointer
!=	O
NULL	O
&&	O
locale	pointer
[	O
0	int
]	O
!=	O
'\0'	O
)	O
break	O
;	O
i	array
++	O
;	O
}	O
if	O
(	O
locale	pointer
==	O
NULL	O
)	O
locale	pointer
=	O
""	pointer
;	O
return	O
g_strdup	function
(	O
locale	pointer
)	O
;	O
}	O
char	O
*	O
get_random_hint	function
(	O
int	O
force	int
)	O
{	O
char	O
*	O
data	pointer
,	O
*	O
result	long
,	O
*	O
eol	pointer
;	O
int	O
len	int
;	O
int	O
start	pointer
;	O
static	O
int	O
last_sec	int
;	O
static	O
struct	O
timeval	struct
tv	pointer
;	O
gettimeofday	function
(	O
&	O
tv	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
force	int
&&	O
!	O
(	O
tv	pointer
.	O
tv_sec	long
>	O
last_sec	int
+	O
60	int
)	O
)	O
return	O
g_strdup	function
(	O
""	pointer
)	O
;	O
last_sec	int
=	O
tv	pointer
.	O
tv_sec	long
;	O
data	pointer
=	O
load_mc_home_file	function
(	O
MC_HINT	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
data	pointer
)	O
return	O
0	int
;	O
srand	function
(	O
tv	pointer
.	O
tv_sec	long
)	O
;	O
len	int
=	O
strlen	function
(	O
data	pointer
)	O
;	O
start	pointer
=	O
rand	function
(	O
)	O
%	O
len	int
;	O
for	O
(	O
;	O
start	pointer
;	O
start	pointer
--	O
)	O
{	O
if	O
(	O
data	pointer
[	O
start	pointer
]	O
==	O
'\n'	O
)	O
{	O
start	pointer
++	O
;	O
break	O
;	O
}	O
}	O
eol	pointer
=	O
strchr	function
(	O
&	O
data	pointer
[	O
start	pointer
]	O
,	O
'\n'	O
)	O
;	O
if	O
(	O
eol	pointer
)	O
*	O
eol	pointer
=	O
0	int
;	O
result	long
=	O
g_strdup	function
(	O
&	O
data	pointer
[	O
start	pointer
]	O
)	O
;	O
g_free	function
(	O
data	pointer
)	O
;	O
return	O
result	long
;	O
}	O
static	O
void	O
nice_cd	function
(	O
const	O
char	O
*	O
text	pointer
,	O
const	O
char	O
*	O
xtext	pointer
,	O
const	O
char	O
*	O
help	pointer
,	O
const	O
char	O
*	O
prefix	pointer
,	O
int	O
to_home	int
)	O
{	O
char	O
*	O
machine	pointer
;	O
char	O
*	O
cd_path	pointer
;	O
if	O
(	O
!	O
SELECTED_IS_PANEL	O
)	O
return	O
;	O
machine	pointer
=	O
input_dialog_help	function
(	O
text	pointer
,	O
xtext	pointer
,	O
help	pointer
,	O
""	pointer
)	O
;	O
if	O
(	O
!	O
machine	pointer
)	O
return	O
;	O
to_home	int
=	O
0	int
;	O
if	O
(	O
strncmp	function
(	O
prefix	pointer
,	O
machine	pointer
,	O
strlen	function
(	O
prefix	pointer
)	O
)	O
==	O
0	int
)	O
cd_path	pointer
=	O
g_strconcat	function
(	O
machine	pointer
,	O
to_home	int
?	O
"/~/"	pointer
:	O
(	O
char	O
*	O
)	O
NULL	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
else	O
cd_path	pointer
=	O
g_strconcat	function
(	O
prefix	pointer
,	O
machine	pointer
,	O
to_home	int
?	O
"/~/"	pointer
:	O
(	O
char	O
*	O
)	O
NULL	O
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
if	O
(	O
do_panel_cd	function
(	O
MENU_PANEL	O
,	O
cd_path	pointer
,	O
0	int
)	O
)	O
directory_history_add	function
(	O
MENU_PANEL	O
,	O
(	O
MENU_PANEL	O
)	O
->	O
cwd	short
)	O
;	O
else	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot chdir to %s "	pointer
)	O
,	O
cd_path	pointer
)	O
;	O
g_free	function
(	O
cd_path	pointer
)	O
;	O
g_free	function
(	O
machine	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
machine_str	pointer
=	O
N_	O
(	O
" Enter machine name (F1 for details): "	pointer
)	O
;	O
void	O
ftplink_cmd	function
(	O
void	O
)	O
{	O
nice_cd	function
(	O
_	O
(	O
" FTP to machine "	pointer
)	O
,	O
_	O
(	O
machine_str	pointer
)	O
,	O
"[FTP File System]"	pointer
,	O
"/#ftp:"	pointer
,	O
1	int
)	O
;	O
}	O
void	O
fishlink_cmd	function
(	O
void	O
)	O
{	O
nice_cd	function
(	O
_	O
(	O
" Shell link to machine "	pointer
)	O
,	O
_	O
(	O
machine_str	pointer
)	O
,	O
"[FIle transfer over SHell filesystem]"	pointer
,	O
"/#sh:"	pointer
,	O
1	int
)	O
;	O
}	O
void	O
quick_cd_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
p	pointer
=	O
cd_dialog	function
(	O
)	O
;	O
if	O
(	O
p	pointer
&&	O
*	O
p	pointer
)	O
{	O
char	O
*	O
q	pointer
=	O
g_strconcat	function
(	O
"cd "	pointer
,	O
p	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
do_cd_command	function
(	O
q	pointer
)	O
;	O
g_free	function
(	O
q	pointer
)	O
;	O
}	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
void	O
single_dirsize_cmd	function
(	O
void	O
)	O
{	O
WPanel	struct
*	O
panel	pointer
=	O
current_panel	pointer
;	O
file_entry	struct
*	O
entry	pointer
;	O
off_t	long
marked	int
;	O
double	O
total	long
;	O
entry	pointer
=	O
&	O
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
panel	pointer
->	O
selected	int
]	O
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
entry	pointer
->	O
st	pointer
.	O
st_mode	int
)	O
&&	O
strcmp	function
(	O
entry	pointer
->	O
fname	pointer
,	O
".."	pointer
)	O
!=	O
0	int
)	O
{	O
total	long
=	O
0.0	int
;	O
compute_dir_size	function
(	O
entry	pointer
->	O
fname	pointer
,	O
&	O
marked	int
,	O
&	O
total	long
)	O
;	O
entry	pointer
->	O
st	pointer
.	O
st_size	long
=	O
(	O
off_t	long
)	O
total	long
;	O
entry	pointer
->	O
f	float
.	O
dir_size_computed	int
=	O
1	int
;	O
}	O
if	O
(	O
mark_moves_down	int
)	O
send_message	function
(	O
&	O
(	O
panel	pointer
->	O
widget	pointer
)	O
,	O
WIDGET_KEY	int
,	O
KEY_DOWN	int
)	O
;	O
recalculate_panel_summary	function
(	O
panel	pointer
)	O
;	O
panel	pointer
->	O
dirty	int
=	O
1	int
;	O
}	O
void	O
dirsizes_cmd	function
(	O
void	O
)	O
{	O
WPanel	struct
*	O
panel	pointer
=	O
current_panel	pointer
;	O
int	O
i	array
;	O
off_t	long
marked	int
;	O
double	O
total	long
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
panel	pointer
->	O
count	int
;	O
i	array
++	O
)	O
if	O
(	O
S_ISDIR	O
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
st	pointer
.	O
st_mode	int
)	O
&&	O
(	O
(	O
panel	pointer
->	O
dirs_marked	int
&&	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
marked	int
)	O
||	O
!	O
panel	pointer
->	O
dirs_marked	int
)	O
&&	O
strcmp	function
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
,	O
".."	pointer
)	O
!=	O
0	int
)	O
{	O
total	long
=	O
0.0l	int
;	O
compute_dir_size	function
(	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
fname	pointer
,	O
&	O
marked	int
,	O
&	O
total	long
)	O
;	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
st	pointer
.	O
st_size	long
=	O
(	O
off_t	long
)	O
total	long
;	O
panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
i	array
]	O
.	O
f	float
.	O
dir_size_computed	int
=	O
1	int
;	O
}	O
recalculate_panel_summary	function
(	O
panel	pointer
)	O
;	O
panel_re_sort	function
(	O
panel	pointer
)	O
;	O
panel	pointer
->	O
dirty	int
=	O
1	int
;	O
}	O
void	O
save_setup_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
str	pointer
;	O
save_setup	function
(	O
)	O
;	O
sync_profiles	function
(	O
)	O
;	O
str	pointer
=	O
g_strconcat	function
(	O
_	O
(	O
" Setup saved to ~/"	pointer
)	O
,	O
PROFILE_NAME	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
message	pointer
(	O
0	int
,	O
_	O
(	O
" Setup "	pointer
)	O
,	O
str	pointer
)	O
;	O
g_free	function
(	O
str	pointer
)	O
;	O
}	O
static	O
void	O
configure_panel_listing	function
(	O
WPanel	struct
*	O
p	pointer
,	O
int	O
view_type	int
,	O
int	O
use_msformat	pointer
,	O
char	O
*	O
user	pointer
,	O
char	O
*	O
status	int
)	O
{	O
p	pointer
->	O
user_mini_status	int
=	O
use_msformat	pointer
;	O
p	pointer
->	O
list_type	int
=	O
view_type	int
;	O
if	O
(	O
view_type	int
==	O
list_user	int
||	O
use_msformat	pointer
)	O
{	O
g_free	function
(	O
p	pointer
->	O
user_format	pointer
)	O
;	O
p	pointer
->	O
user_format	pointer
=	O
user	pointer
;	O
g_free	function
(	O
p	pointer
->	O
user_status_format	array
[	O
view_type	int
]	O
)	O
;	O
p	pointer
->	O
user_status_format	array
[	O
view_type	int
]	O
=	O
status	int
;	O
set_panel_formats	function
(	O
p	pointer
)	O
;	O
}	O
else	O
{	O
g_free	function
(	O
user	pointer
)	O
;	O
g_free	function
(	O
status	int
)	O
;	O
}	O
set_panel_formats	function
(	O
p	pointer
)	O
;	O
do_refresh	function
(	O
)	O
;	O
}	O
void	O
info_cmd_no_menu	function
(	O
void	O
)	O
{	O
if	O
(	O
get_display_type	function
(	O
0	int
)	O
==	O
view_info	int
)	O
set_display_type	function
(	O
0	int
,	O
view_listing	int
)	O
;	O
else	O
if	O
(	O
get_display_type	function
(	O
1	int
)	O
==	O
view_info	int
)	O
set_display_type	function
(	O
1	int
,	O
view_listing	int
)	O
;	O
else	O
set_display_type	function
(	O
current_panel	pointer
==	O
left_panel	pointer
?	O
1	int
:	O
0	int
,	O
view_info	int
)	O
;	O
}	O
void	O
quick_cmd_no_menu	function
(	O
void	O
)	O
{	O
if	O
(	O
get_display_type	function
(	O
0	int
)	O
==	O
view_quick	int
)	O
set_display_type	function
(	O
0	int
,	O
view_listing	int
)	O
;	O
else	O
if	O
(	O
get_display_type	function
(	O
1	int
)	O
==	O
view_quick	int
)	O
set_display_type	function
(	O
1	int
,	O
view_listing	int
)	O
;	O
else	O
set_display_type	function
(	O
current_panel	pointer
==	O
left_panel	pointer
?	O
1	int
:	O
0	int
,	O
view_quick	int
)	O
;	O
}	O
static	O
void	O
switch_to_listing	function
(	O
int	O
panel_index	int
)	O
{	O
if	O
(	O
get_display_type	function
(	O
panel_index	int
)	O
!=	O
view_listing	int
)	O
set_display_type	function
(	O
panel_index	int
,	O
view_listing	int
)	O
;	O
}	O
void	O
listing_cmd	function
(	O
void	O
)	O
{	O
int	O
view_type	int
,	O
use_msformat	pointer
;	O
char	O
*	O
user	pointer
,	O
*	O
status	int
;	O
WPanel	struct
*	O
p	pointer
;	O
int	O
display_type	int
;	O
display_type	int
=	O
get_display_type	function
(	O
MENU_PANEL_IDX	O
)	O
;	O
if	O
(	O
display_type	int
==	O
view_listing	int
)	O
p	pointer
=	O
MENU_PANEL_IDX	O
==	O
0	int
?	O
left_panel	pointer
:	O
right_panel	pointer
;	O
else	O
p	pointer
=	O
0	int
;	O
view_type	int
=	O
display_box	function
(	O
p	pointer
,	O
&	O
user	pointer
,	O
&	O
status	int
,	O
&	O
use_msformat	pointer
,	O
MENU_PANEL_IDX	O
)	O
;	O
if	O
(	O
view_type	int
==	O
-	O
1	int
)	O
return	O
;	O
switch_to_listing	function
(	O
MENU_PANEL_IDX	O
)	O
;	O
p	pointer
=	O
MENU_PANEL_IDX	O
==	O
0	int
?	O
left_panel	pointer
:	O
right_panel	pointer
;	O
configure_panel_listing	function
(	O
p	pointer
,	O
view_type	int
,	O
use_msformat	pointer
,	O
user	pointer
,	O
status	int
)	O
;	O
}	O
void	O
tree_cmd	function
(	O
void	O
)	O
{	O
set_display_type	function
(	O
MENU_PANEL_IDX	O
,	O
view_tree	int
)	O
;	O
}	O
void	O
info_cmd	function
(	O
void	O
)	O
{	O
set_display_type	function
(	O
MENU_PANEL_IDX	O
,	O
view_info	int
)	O
;	O
}	O
void	O
quick_view_cmd	function
(	O
void	O
)	O
{	O
if	O
(	O
(	O
WPanel	struct
*	O
)	O
get_panel_widget	function
(	O
MENU_PANEL_IDX	O
)	O
==	O
current_panel	pointer
)	O
change_panel	function
(	O
)	O
;	O
set_display_type	function
(	O
MENU_PANEL_IDX	O
,	O
view_quick	int
)	O
;	O
}	O
static	O
int	O
set_basic_panel_listing_to	function
(	O
int	O
panel_index	int
,	O
int	O
listing_mode	int
)	O
{	O
WPanel	struct
*	O
p	pointer
=	O
(	O
WPanel	struct
*	O
)	O
get_panel_widget	function
(	O
panel_index	int
)	O
;	O
switch_to_listing	function
(	O
panel_index	int
)	O
;	O
p	pointer
->	O
list_type	int
=	O
listing_mode	int
;	O
if	O
(	O
set_panel_formats	function
(	O
p	pointer
)	O
)	O
return	O
0	int
;	O
do_refresh	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
void	O
toggle_listing_cmd	function
(	O
void	O
)	O
{	O
int	O
current	pointer
=	O
get_current_index	function
(	O
)	O
;	O
WPanel	struct
*	O
p	pointer
=	O
(	O
WPanel	struct
*	O
)	O
get_panel_widget	function
(	O
current	pointer
)	O
;	O
set_basic_panel_listing_to	function
(	O
current	pointer
,	O
(	O
p	pointer
->	O
list_type	int
+	O
1	int
)	O
%	O
LIST_TYPES	int
)	O
;	O
}	O
