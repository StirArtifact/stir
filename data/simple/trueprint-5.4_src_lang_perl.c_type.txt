char	O
lang_perl_defaults	array
[	O
]	O
=	O
"--i --F --f"	pointer
;	O
typedef	O
enum	O
{	O
IP_CODE	int
,	O
IP_STRING	int
,	O
IP_COMMENT	int
,	O
IP_STRING_ESCAPE	int
,	O
IP_POD	int
,	O
IP_INPOD	int
,	O
IP_POD_END	int
,	O
}	O
perl_ip_states	enum
;	O
typedef	O
enum	O
{	O
Q_LOOKING	int
,	O
Q_SAWLT	int
,	O
Q_SAWLTLT	int
,	O
Q_SAWQ	int
,	O
Q_IDENT	int
,	O
Q_STALLED	int
,	O
Q_AFTER_HEREDOC_SIGNAL	int
,	O
Q_WITHIN_HEREDOC_FINDING	int
,	O
Q_WITHIN_HEREDOC	int
,	O
}	O
perl_q_states	enum
;	O
typedef	O
enum	O
{	O
SUB_INIT	int
,	O
SUB_BOL	int
,	O
SUB_S	int
,	O
SUB_SU	int
,	O
SUB_SUB	int
,	O
SUB_FOUND	int
,	O
SUB_NAME	int
,	O
}	O
perl_sub_states	enum
;	O
typedef	O
unsigned	O
char	O
byte	char
;	O
char	O
nestable_chars	array
[	O
256	int
]	O
;	O
static	O
boolean	enum
perl_has_been_setup	enum
=	O
FALSE	int
;	O
static	O
void	O
perl_setup	function
(	O
void	O
)	O
{	O
memset	function
(	O
nestable_chars	array
,	O
0	int
,	O
sizeof	O
(	O
nestable_chars	array
)	O
)	O
;	O
nestable_chars	array
[	O
(	O
byte	char
)	O
'('	O
]	O
=	O
')'	O
;	O
nestable_chars	array
[	O
(	O
byte	char
)	O
'['	O
]	O
=	O
']'	O
;	O
nestable_chars	array
[	O
(	O
byte	char
)	O
'{'	O
]	O
=	O
'}'	O
;	O
nestable_chars	array
[	O
(	O
byte	char
)	O
'<'	O
]	O
=	O
'>'	O
;	O
nestable_chars	array
[	O
(	O
byte	char
)	O
'`'	O
]	O
=	O
'\''	O
;	O
perl_has_been_setup	enum
=	O
TRUE	int
;	O
}	O
static	O
int	O
isword	function
(	O
int	O
c	int
)	O
{	O
return	O
isalnum	function
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
;	O
}	O
static	O
int	O
isidentstart	function
(	O
int	O
c	int
)	O
{	O
return	O
isalpha	function
(	O
c	int
)	O
||	O
c	int
==	O
'_'	O
;	O
}	O
typedef	O
enum	O
{	O
MYCHAR_NORMAL	int
,	O
MYCHAR_FUNCTION	int
,	O
MYCHAR_STRING	int
,	O
MYCHAR_COMMENT	int
,	O
}	O
my_char_status	enum
;	O
static	O
void	O
note	function
(	O
char	O
c	int
,	O
perl_ip_states	enum
state	pointer
,	O
perl_q_states	enum
q_state	enum
,	O
perl_sub_states	enum
sub_state	enum
,	O
my_char_status	enum
status	enum
,	O
char	O
end_token	char
)	O
;	O
static	O
stream_status	enum
my_get_perl_char	function
(	O
char	O
*	O
input_char	pointer
,	O
my_char_status	enum
*	O
status	enum
)	O
{	O
static	O
perl_ip_states	enum
state	pointer
;	O
static	O
perl_sub_states	enum
sub_state	enum
;	O
static	O
perl_q_states	enum
q_state	enum
;	O
static	O
char	O
end_token	char
;	O
static	O
boolean	enum
line_start	enum
=	O
FALSE	int
;	O
static	O
int	O
hd_check_index	int
=	O
0	int
;	O
static	O
int	O
hd_end_index	int
=	O
0	int
;	O
static	O
char	O
hd_end	array
[	O
SYMBOL_LEN	int
]	O
;	O
static	O
int	O
brace_count	int
=	O
0	int
;	O
static	O
int	O
q_count	int
=	O
0	int
;	O
static	O
boolean	enum
in_function	enum
;	O
static	O
int	O
previous_newlines	int
=	O
0	int
;	O
stream_status	enum
retval	enum
;	O
*	O
status	enum
=	O
MYCHAR_NORMAL	int
;	O
if	O
(	O
restart_language	enum
==	O
TRUE	int
)	O
{	O
state	pointer
=	O
IP_CODE	int
;	O
sub_state	enum
=	O
SUB_INIT	int
;	O
q_state	enum
=	O
Q_LOOKING	int
;	O
q_count	int
=	O
0	int
;	O
restart_language	enum
=	O
FALSE	int
;	O
brace_count	int
=	O
0	int
;	O
previous_newlines	int
=	O
0	int
;	O
if	O
(	O
!	O
perl_has_been_setup	enum
)	O
perl_setup	function
(	O
)	O
;	O
}	O
if	O
(	O
line_start	enum
)	O
previous_newlines	int
++	O
;	O
else	O
previous_newlines	int
=	O
0	int
;	O
line_start	enum
=	O
FALSE	int
;	O
retval	enum
=	O
getnextchar	function
(	O
input_char	pointer
)	O
;	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
IP_CODE	int
:	O
switch	O
(	O
*	O
input_char	pointer
)	O
{	O
case	O
'"'	O
:	O
case	O
'\''	O
:	O
if	O
(	O
q_state	enum
!=	O
Q_SAWLTLT	int
)	O
{	O
state	pointer
=	O
IP_STRING	int
;	O
end_token	char
=	O
*	O
input_char	pointer
;	O
}	O
break	O
;	O
case	O
'\n'	O
:	O
line_start	enum
=	O
TRUE	int
;	O
break	O
;	O
case	O
'='	O
:	O
if	O
(	O
previous_newlines	int
>=	O
2	int
)	O
{	O
state	pointer
=	O
IP_POD	int
;	O
*	O
status	enum
=	O
MYCHAR_COMMENT	int
;	O
}	O
break	O
;	O
case	O
'#'	O
:	O
state	pointer
=	O
IP_COMMENT	int
;	O
*	O
status	enum
=	O
MYCHAR_COMMENT	int
;	O
break	O
;	O
case	O
'{'	O
:	O
brace_count	int
++	O
;	O
break	O
;	O
case	O
'}'	O
:	O
brace_count	int
--	O
;	O
if	O
(	O
brace_count	int
==	O
0	int
&&	O
in_function	enum
)	O
{	O
end_function	function
(	O
page_number	long
)	O
;	O
in_function	enum
=	O
FALSE	int
;	O
retval	enum
|=	O
STREAM_FUNCTION_END	int
;	O
}	O
if	O
(	O
brace_count	int
<	O
0	int
)	O
brace_count	int
=	O
0	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
IP_POD	int
:	O
*	O
status	enum
=	O
MYCHAR_COMMENT	int
;	O
state	pointer
=	O
IP_INPOD	int
;	O
break	O
;	O
case	O
IP_INPOD	int
:	O
*	O
status	enum
=	O
MYCHAR_COMMENT	int
;	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
line_start	enum
=	O
TRUE	int
;	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'='	O
&&	O
previous_newlines	int
>=	O
2	int
)	O
state	pointer
=	O
IP_POD_END	int
;	O
break	O
;	O
case	O
IP_POD_END	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
state	pointer
=	O
IP_CODE	int
;	O
else	O
*	O
status	enum
=	O
MYCHAR_COMMENT	int
;	O
break	O
;	O
case	O
IP_COMMENT	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
state	pointer
=	O
IP_CODE	int
;	O
*	O
status	enum
=	O
MYCHAR_COMMENT	int
;	O
break	O
;	O
case	O
IP_STRING	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
end_token	char
)	O
{	O
state	pointer
=	O
IP_CODE	int
;	O
q_state	enum
=	O
Q_STALLED	int
;	O
}	O
else	O
{	O
*	O
status	enum
=	O
MYCHAR_STRING	int
;	O
if	O
(	O
*	O
input_char	pointer
==	O
'\\'	O
)	O
state	pointer
=	O
IP_STRING_ESCAPE	int
;	O
}	O
break	O
;	O
case	O
IP_STRING_ESCAPE	int
:	O
state	pointer
=	O
IP_STRING	int
;	O
*	O
status	enum
=	O
MYCHAR_STRING	int
;	O
break	O
;	O
}	O
if	O
(	O
state	pointer
==	O
IP_CODE	int
)	O
{	O
switch	O
(	O
q_state	enum
)	O
{	O
case	O
Q_LOOKING	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
'q'	O
)	O
{	O
q_state	enum
=	O
Q_SAWQ	int
;	O
q_count	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'<'	O
)	O
q_state	enum
=	O
Q_SAWLT	int
;	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'\''	O
)	O
{	O
end_token	char
=	O
'\''	O
;	O
state	pointer
=	O
IP_STRING	int
;	O
}	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'"'	O
)	O
{	O
end_token	char
=	O
'"'	O
;	O
state	pointer
=	O
IP_STRING	int
;	O
}	O
else	O
if	O
(	O
isword	function
(	O
*	O
input_char	pointer
)	O
)	O
q_state	enum
=	O
Q_IDENT	int
;	O
break	O
;	O
case	O
Q_SAWLT	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
'<'	O
)	O
q_state	enum
=	O
Q_SAWLTLT	int
;	O
else	O
q_state	enum
=	O
Q_LOOKING	int
;	O
hd_end_index	int
=	O
0	int
;	O
break	O
;	O
case	O
Q_SAWLTLT	int
:	O
if	O
(	O
isidentstart	function
(	O
*	O
input_char	pointer
)	O
)	O
hd_end	array
[	O
hd_end_index	int
++	O
]	O
=	O
*	O
input_char	pointer
;	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'"'	O
||	O
*	O
input_char	pointer
==	O
'\''	O
)	O
;	O
else	O
if	O
(	O
hd_end_index	int
>	O
0	int
)	O
{	O
if	O
(	O
isword	function
(	O
*	O
input_char	pointer
)	O
)	O
hd_end	array
[	O
hd_end_index	int
++	O
]	O
=	O
*	O
input_char	pointer
;	O
else	O
{	O
state	pointer
=	O
IP_CODE	int
;	O
q_state	enum
=	O
Q_AFTER_HEREDOC_SIGNAL	int
;	O
}	O
}	O
else	O
q_state	enum
=	O
Q_LOOKING	int
;	O
break	O
;	O
case	O
Q_AFTER_HEREDOC_SIGNAL	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
{	O
q_state	enum
=	O
Q_WITHIN_HEREDOC_FINDING	int
;	O
hd_check_index	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
Q_WITHIN_HEREDOC_FINDING	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
hd_check_index	int
=	O
0	int
;	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
hd_end	array
[	O
hd_check_index	int
]	O
)	O
{	O
hd_check_index	int
++	O
;	O
if	O
(	O
hd_check_index	int
==	O
hd_end_index	int
)	O
{	O
state	pointer
=	O
IP_CODE	int
;	O
q_state	enum
=	O
Q_LOOKING	int
;	O
}	O
}	O
else	O
if	O
(	O
hd_check_index	int
==	O
0	int
&&	O
isspace	function
(	O
*	O
input_char	pointer
)	O
)	O
;	O
else	O
q_state	enum
=	O
Q_WITHIN_HEREDOC	int
;	O
*	O
status	enum
=	O
MYCHAR_COMMENT	int
;	O
break	O
;	O
case	O
Q_WITHIN_HEREDOC	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
{	O
hd_check_index	int
=	O
0	int
;	O
q_state	enum
=	O
Q_WITHIN_HEREDOC_FINDING	int
;	O
}	O
*	O
status	enum
=	O
MYCHAR_COMMENT	int
;	O
break	O
;	O
case	O
Q_SAWQ	int
:	O
if	O
(	O
q_count	int
==	O
1	int
)	O
{	O
if	O
(	O
*	O
input_char	pointer
==	O
'q'	O
)	O
q_count	int
++	O
;	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'x'	O
)	O
q_count	int
++	O
;	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'w'	O
)	O
q_count	int
++	O
;	O
if	O
(	O
q_count	int
==	O
2	int
)	O
break	O
;	O
}	O
if	O
(	O
isword	function
(	O
*	O
input_char	pointer
)	O
)	O
q_state	enum
=	O
Q_IDENT	int
;	O
else	O
if	O
(	O
nestable_chars	array
[	O
(	O
byte	char
)	O
*	O
input_char	pointer
]	O
)	O
{	O
end_token	char
=	O
nestable_chars	array
[	O
(	O
byte	char
)	O
*	O
input_char	pointer
]	O
;	O
state	pointer
=	O
IP_STRING	int
;	O
q_state	enum
=	O
Q_LOOKING	int
;	O
}	O
else	O
if	O
(	O
isspace	function
(	O
*	O
input_char	pointer
)	O
)	O
{	O
q_state	enum
=	O
Q_LOOKING	int
;	O
}	O
else	O
{	O
end_token	char
=	O
*	O
input_char	pointer
;	O
state	pointer
=	O
IP_STRING	int
;	O
q_state	enum
=	O
Q_LOOKING	int
;	O
}	O
break	O
;	O
case	O
Q_IDENT	int
:	O
if	O
(	O
!	O
isword	function
(	O
*	O
input_char	pointer
)	O
)	O
q_state	enum
=	O
Q_LOOKING	int
;	O
break	O
;	O
case	O
Q_STALLED	int
:	O
q_state	enum
=	O
Q_LOOKING	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
state	pointer
!=	O
IP_CODE	int
)	O
{	O
sub_state	enum
=	O
SUB_INIT	int
;	O
}	O
else	O
{	O
switch	O
(	O
sub_state	enum
)	O
{	O
case	O
SUB_INIT	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
sub_state	enum
=	O
SUB_BOL	int
;	O
break	O
;	O
case	O
SUB_BOL	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
sub_state	enum
=	O
SUB_BOL	int
;	O
else	O
if	O
(	O
isspace	function
(	O
*	O
input_char	pointer
)	O
)	O
;	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
's'	O
)	O
sub_state	enum
=	O
SUB_S	int
;	O
else	O
sub_state	enum
=	O
SUB_INIT	int
;	O
break	O
;	O
case	O
SUB_S	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
'u'	O
)	O
sub_state	enum
=	O
SUB_SU	int
;	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
sub_state	enum
=	O
SUB_BOL	int
;	O
else	O
sub_state	enum
=	O
SUB_INIT	int
;	O
break	O
;	O
case	O
SUB_SU	int
:	O
if	O
(	O
*	O
input_char	pointer
==	O
'b'	O
)	O
sub_state	enum
=	O
SUB_SUB	int
;	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
sub_state	enum
=	O
SUB_BOL	int
;	O
else	O
sub_state	enum
=	O
SUB_INIT	int
;	O
break	O
;	O
case	O
SUB_SUB	int
:	O
if	O
(	O
isspace	function
(	O
*	O
input_char	pointer
)	O
)	O
sub_state	enum
=	O
SUB_FOUND	int
;	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
sub_state	enum
=	O
SUB_BOL	int
;	O
else	O
sub_state	enum
=	O
SUB_INIT	int
;	O
break	O
;	O
case	O
SUB_FOUND	int
:	O
if	O
(	O
isidentstart	function
(	O
*	O
input_char	pointer
)	O
)	O
{	O
*	O
status	enum
=	O
MYCHAR_FUNCTION	int
;	O
sub_state	enum
=	O
SUB_NAME	int
;	O
}	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'{'	O
)	O
sub_state	enum
=	O
SUB_INIT	int
;	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
sub_state	enum
=	O
SUB_BOL	int
;	O
break	O
;	O
case	O
SUB_NAME	int
:	O
if	O
(	O
isalnum	function
(	O
*	O
input_char	pointer
)	O
||	O
*	O
input_char	pointer
==	O
'_'	O
)	O
{	O
*	O
status	enum
=	O
MYCHAR_FUNCTION	int
;	O
in_function	enum
=	O
TRUE	int
;	O
}	O
else	O
if	O
(	O
*	O
input_char	pointer
==	O
'\n'	O
)	O
sub_state	enum
=	O
SUB_BOL	int
;	O
else	O
sub_state	enum
=	O
SUB_INIT	int
;	O
break	O
;	O
}	O
}	O
return	O
retval	enum
;	O
}	O
stream_status	enum
get_perl_char	function
(	O
char	O
*	O
input_char	pointer
,	O
char_status	enum
*	O
retstatus	pointer
)	O
{	O
my_char_status	enum
status	enum
;	O
stream_status	enum
retval	enum
;	O
static	O
int	O
function_start_page	int
;	O
static	O
int	O
function_start	int
=	O
0	int
;	O
static	O
char	O
function_name	array
[	O
SYMBOL_LEN	int
]	O
;	O
static	O
int	O
function_name_index	int
=	O
0	int
;	O
retval	enum
=	O
my_get_perl_char	function
(	O
input_char	pointer
,	O
&	O
status	enum
)	O
;	O
if	O
(	O
function_start	int
&&	O
status	enum
!=	O
MYCHAR_FUNCTION	int
)	O
{	O
function_name	array
[	O
function_name_index	int
]	O
=	O
'\0'	O
;	O
add_function	function
(	O
function_name	array
,	O
function_start	int
,	O
char_number	long
,	O
function_start_page	int
,	O
current_filename	pointer
)	O
;	O
function_start	int
=	O
0	int
;	O
}	O
switch	O
(	O
status	enum
)	O
{	O
case	O
MYCHAR_FUNCTION	int
:	O
*	O
retstatus	pointer
=	O
CHAR_BOLD	int
;	O
if	O
(	O
!	O
function_start	int
)	O
{	O
function_start	int
=	O
char_number	long
;	O
function_start_page	int
=	O
page_number	long
;	O
function_name_index	int
=	O
0	int
;	O
}	O
function_name	array
[	O
function_name_index	int
++	O
]	O
=	O
*	O
input_char	pointer
;	O
break	O
;	O
case	O
MYCHAR_NORMAL	int
:	O
*	O
retstatus	pointer
=	O
CHAR_NORMAL	int
;	O
break	O
;	O
case	O
MYCHAR_STRING	int
:	O
*	O
retstatus	pointer
=	O
CHAR_NORMAL	int
;	O
break	O
;	O
case	O
MYCHAR_COMMENT	int
:	O
*	O
retstatus	pointer
=	O
CHAR_ITALIC	int
;	O
break	O
;	O
}	O
if	O
(	O
pass	short
==	O
1	int
)	O
*	O
retstatus	pointer
=	O
get_function_name_posn	function
(	O
char_number	long
,	O
*	O
retstatus	pointer
)	O
;	O
return	O
retval	enum
;	O
}	O
static	O
void	O
note	function
(	O
char	O
c	int
,	O
perl_ip_states	enum
state	pointer
,	O
perl_q_states	enum
q_state	enum
,	O
perl_sub_states	enum
sub_state	enum
,	O
my_char_status	enum
status	enum
,	O
char	O
end_token	char
)	O
{	O
static	O
int	O
counter	int
=	O
0	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%05d: %02x "	pointer
,	O
counter	int
++	O
,	O
(	O
unsigned	O
int	O
)	O
c	int
)	O
;	O
if	O
(	O
isprint	function
(	O
c	int
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"(%c) "	pointer
,	O
c	int
)	O
;	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
IP_CODE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"IP_CODE "	pointer
)	O
;	O
break	O
;	O
case	O
IP_STRING	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"IP_STRING "	pointer
)	O
;	O
break	O
;	O
case	O
IP_COMMENT	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"IP_COMMENT "	pointer
)	O
;	O
break	O
;	O
case	O
IP_STRING_ESCAPE	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"IP_STRING_ESCAPE "	pointer
)	O
;	O
break	O
;	O
case	O
IP_POD	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"IP_POD "	pointer
)	O
;	O
break	O
;	O
case	O
IP_INPOD	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"IP_INPOD "	pointer
)	O
;	O
break	O
;	O
case	O
IP_POD_END	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"IP_POD_END "	pointer
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
q_state	enum
)	O
{	O
case	O
Q_LOOKING	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Q_LOOKING "	pointer
)	O
;	O
break	O
;	O
case	O
Q_SAWLT	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Q_SAWLT "	pointer
)	O
;	O
break	O
;	O
case	O
Q_SAWLTLT	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Q_SAWLTLT "	pointer
)	O
;	O
break	O
;	O
case	O
Q_SAWQ	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Q_SAWQ "	pointer
)	O
;	O
break	O
;	O
case	O
Q_IDENT	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Q_IDENT "	pointer
)	O
;	O
break	O
;	O
case	O
Q_STALLED	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Q_STALLED "	pointer
)	O
;	O
break	O
;	O
case	O
Q_AFTER_HEREDOC_SIGNAL	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Q_AFTER_HEREDOC_SIGNAL "	pointer
)	O
;	O
break	O
;	O
case	O
Q_WITHIN_HEREDOC_FINDING	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Q_WITHIN_HEREDOC_FINDING "	pointer
)	O
;	O
break	O
;	O
case	O
Q_WITHIN_HEREDOC	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Q_WITHIN_HEREDOC "	pointer
)	O
;	O
break	O
;	O
}	O
switch	O
(	O
sub_state	enum
)	O
{	O
case	O
SUB_INIT	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"SUB_INIT "	pointer
)	O
;	O
break	O
;	O
case	O
SUB_BOL	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"SUB_BOL "	pointer
)	O
;	O
break	O
;	O
case	O
SUB_S	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"SUB_S "	pointer
)	O
;	O
break	O
;	O
case	O
SUB_SU	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"SUB_SU "	pointer
)	O
;	O
break	O
;	O
case	O
SUB_SUB	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"SUB_SUB "	pointer
)	O
;	O
break	O
;	O
case	O
SUB_FOUND	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"SUB_FOUND "	pointer
)	O
;	O
break	O
;	O
case	O
SUB_NAME	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"SUB_NAME "	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
end_token	char
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"end_token=%c "	pointer
,	O
end_token	char
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"=> "	pointer
)	O
;	O
switch	O
(	O
status	enum
)	O
{	O
case	O
MYCHAR_NORMAL	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"MYCHAR_NORMAL "	pointer
)	O
;	O
break	O
;	O
case	O
MYCHAR_FUNCTION	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"MYCHAR_FUNCTION "	pointer
)	O
;	O
break	O
;	O
case	O
MYCHAR_STRING	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"MYCHAR_STRING "	pointer
)	O
;	O
break	O
;	O
case	O
MYCHAR_COMMENT	int
:	O
fprintf	function
(	O
stderr	pointer
,	O
"MYCHAR_COMMENT "	pointer
)	O
;	O
break	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
