DEFUNO_NEW	function
(	O
"NULL"	pointer
,	O
object	O
,	O
fLnull	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lnull	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
x0	O
==	O
Cnil	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"NOT"	pointer
,	O
object	O
,	O
fLnot	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
x0	O
==	O
Cnil	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"SYMBOLP"	pointer
,	O
object	O
,	O
fLsymbolp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lsymbolp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_symbol	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"ATOM"	pointer
,	O
object	O
,	O
fLatom	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Latom	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
!=	O
t_cons	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"CONSP"	pointer
,	O
object	O
,	O
fLconsp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lconsp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_cons	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"LISTP"	pointer
,	O
object	O
,	O
fLlistp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Llistp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
x0	O
==	O
Cnil	O
||	O
type_of	function
(	O
x0	O
)	O
==	O
t_cons	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"NUMBERP"	pointer
,	O
object	O
,	O
fLnumberp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lnumberp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
enum	O
type	O
t	enum
;	O
t	enum
=	O
type_of	function
(	O
x0	O
)	O
;	O
if	O
(	O
t	enum
==	O
t_fixnum	O
||	O
t	enum
==	O
t_bignum	O
||	O
t	enum
==	O
t_ratio	O
||	O
t	enum
==	O
t_shortfloat	O
||	O
t	enum
==	O
t_longfloat	O
||	O
t	enum
==	O
t_complex	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"INTEGERP"	pointer
,	O
object	O
,	O
fLintegerp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lintegerp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
enum	O
type	O
t	enum
;	O
t	enum
=	O
type_of	function
(	O
x0	O
)	O
;	O
if	O
(	O
t	enum
==	O
t_fixnum	O
||	O
t	enum
==	O
t_bignum	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"RATIONALP"	pointer
,	O
object	O
,	O
fLrationalp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
enum	O
type	O
t	enum
;	O
t	enum
=	O
type_of	function
(	O
x0	O
)	O
;	O
if	O
(	O
t	enum
==	O
t_fixnum	O
||	O
t	enum
==	O
t_bignum	O
||	O
t	enum
==	O
t_ratio	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"REALP"	pointer
,	O
object	O
,	O
fLrealp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
enum	O
type	O
t	enum
;	O
t	enum
=	O
type_of	function
(	O
x0	O
)	O
;	O
RETURN1	function
(	O
(	O
TS_MEMBER	function
(	O
t	enum
,	O
TS	function
(	O
t_fixnum	O
)	O
|	O
TS	function
(	O
t_bignum	O
)	O
|	O
TS	function
(	O
t_ratio	O
)	O
|	O
TS	function
(	O
t_longfloat	O
)	O
|	O
TS	function
(	O
t_shortfloat	O
)	O
)	O
?	O
Ct	O
:	O
Cnil	O
)	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"FLOATP"	pointer
,	O
object	O
,	O
fLfloatp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lfloatp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
enum	O
type	O
t	enum
;	O
t	enum
=	O
type_of	function
(	O
x0	O
)	O
;	O
if	O
(	O
t	enum
==	O
t_longfloat	O
||	O
t	enum
==	O
t_shortfloat	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"COMPLEXP"	pointer
,	O
object	O
,	O
fLcomplexp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lcomplexp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_complex	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"CHARACTERP"	pointer
,	O
object	O
,	O
fLcharacterp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lcharacterp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_character	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"STRINGP"	pointer
,	O
object	O
,	O
fLstringp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lstringp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_string	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"BIT-VECTOR-P"	pointer
,	O
object	O
,	O
fLbit_vector_p	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lbit_vector_p	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_bitvector	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"VECTORP"	pointer
,	O
object	O
,	O
fLvectorp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lvectorp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
enum	O
type	O
t	enum
;	O
t	enum
=	O
type_of	function
(	O
x0	O
)	O
;	O
if	O
(	O
t	enum
==	O
t_vector	O
||	O
t	enum
==	O
t_string	O
||	O
t	enum
==	O
t_bitvector	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"SIMPLE-STRING-P"	pointer
,	O
object	O
,	O
fLsimple_string_p	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lsimple_string_p	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_string	O
&&	O
!	O
x0	O
->	O
st	O
.	O
st_hasfillp	O
&&	O
x0	O
->	O
st	O
.	O
st_displaced	O
->	O
c	O
.	O
c_car	O
==	O
Cnil	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"SIMPLE-BIT-VECTOR-P"	pointer
,	O
object	O
,	O
fLsimple_bit_vector_p	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lsimple_bit_vector_p	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_bitvector	O
&&	O
!	O
x0	O
->	O
bv	O
.	O
bv_hasfillp	O
&&	O
x0	O
->	O
bv	O
.	O
bv_displaced	O
->	O
c	O
.	O
c_car	O
==	O
Cnil	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"SIMPLE-VECTOR-P"	pointer
,	O
object	O
,	O
fLsimple_vector_p	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lsimple_vector_p	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
enum	O
type	O
t	enum
;	O
t	enum
=	O
type_of	function
(	O
x0	O
)	O
;	O
if	O
(	O
t	enum
==	O
t_vector	O
&&	O
!	O
x0	O
->	O
v	O
.	O
v_hasfillp	O
&&	O
x0	O
->	O
v	O
.	O
v_displaced	O
->	O
c	O
.	O
c_car	O
==	O
Cnil	O
&&	O
(	O
enum	O
aelttype	O
)	O
x0	O
->	O
v	O
.	O
v_elttype	O
==	O
aet_object	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"ARRAYP"	pointer
,	O
object	O
,	O
fLarrayp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Larrayp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
enum	O
type	O
t	enum
;	O
t	enum
=	O
type_of	function
(	O
x0	O
)	O
;	O
if	O
(	O
t	enum
==	O
t_array	O
||	O
t	enum
==	O
t_vector	O
||	O
t	enum
==	O
t_string	O
||	O
t	enum
==	O
t_bitvector	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"PACKAGEP"	pointer
,	O
object	O
,	O
fLpackagep	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lpackagep	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_package	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"FUNCTIONP"	pointer
,	O
object	O
,	O
fLfunctionp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lfunctionp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
enum	O
type	O
t	enum
;	O
object	O
x	int
;	O
t	enum
=	O
type_of	function
(	O
x0	O
)	O
;	O
if	O
(	O
t	enum
==	O
t_cfun	O
||	O
t	enum
==	O
t_cclosure	O
||	O
t	enum
==	O
t_sfun	O
||	O
t	enum
==	O
t_gfun	O
||	O
t	enum
==	O
t_closure	O
||	O
t	enum
==	O
t_afun	O
||	O
t	enum
==	O
t_vfun	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
if	O
(	O
t	enum
==	O
t_symbol	O
)	O
{	O
if	O
(	O
x0	O
->	O
s	O
.	O
s_gfdef	O
!=	O
OBJNULL	O
&&	O
x0	O
->	O
s	O
.	O
s_mflag	O
==	O
FALSE	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
}	O
else	O
if	O
(	O
t	enum
==	O
t_cons	O
)	O
{	O
x	int
=	O
x0	O
->	O
c	O
.	O
c_car	O
;	O
if	O
(	O
x	int
==	O
sLlambda	O
||	O
x	int
==	O
sLlambda_block	O
||	O
x	int
==	O
sSlambda_block_expanded	O
||	O
x	int
==	O
sLlambda_closure	O
||	O
x	int
==	O
sLlambda_block_closure	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
}	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"COMPILED-FUNCTION-P"	pointer
,	O
object	O
,	O
fLcompiled_function_p	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lcompiled_function_p	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
;	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_cfun	O
||	O
type_of	function
(	O
x0	O
)	O
==	O
t_cclosure	O
||	O
type_of	function
(	O
x0	O
)	O
==	O
t_sfun	O
||	O
type_of	function
(	O
x0	O
)	O
==	O
t_gfun	O
||	O
type_of	function
(	O
x0	O
)	O
==	O
t_afun	O
||	O
type_of	function
(	O
x0	O
)	O
==	O
t_closure	O
||	O
type_of	function
(	O
x0	O
)	O
==	O
t_vfun	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUNO_NEW	function
(	O
"COMMONP"	pointer
,	O
object	O
,	O
fLcommonp	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
void	O
,	O
Lcommonp	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
;	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
!=	O
t_spice	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"EQ"	pointer
,	O
object	O
,	O
fLeq	O
,	O
LISP	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
,	O
object	O
x1	O
)	O
,	O
""	pointer
)	O
{	O
RETURN1	function
(	O
x0	O
==	O
x1	O
?	O
Ct	O
:	O
Cnil	O
)	O
;	O
}	O
bool	O
eql1	function
(	O
register	O
object	O
x	int
,	O
register	O
object	O
y	int
)	O
{	O
if	O
(	O
valid_cdr	function
(	O
x	int
)	O
||	O
valid_cdr	function
(	O
y	int
)	O
||	O
x	int
->	O
d	O
.	O
t	enum
!=	O
y	int
->	O
d	O
.	O
t	enum
)	O
return	O
FALSE	O
;	O
switch	O
(	O
x	int
->	O
d	O
.	O
t	enum
)	O
{	O
eqlm	O
(	O
x	int
,	O
y	int
)	O
;	O
}	O
}	O
bool	O
oeql	function
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
return	O
eql	function
(	O
x	int
,	O
y	int
)	O
?	O
TRUE	O
:	O
FALSE	O
;	O
}	O
DEFUN_NEW	function
(	O
"EQL"	pointer
,	O
object	O
,	O
fLeql	O
,	O
LISP	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
,	O
object	O
x1	O
)	O
,	O
""	pointer
)	O
{	O
RETURN1	function
(	O
eql	function
(	O
x0	O
,	O
x1	O
)	O
?	O
Ct	O
:	O
Cnil	O
)	O
;	O
}	O
bool	O
equal1	function
(	O
register	O
object	O
x	int
,	O
register	O
object	O
y	int
)	O
{	O
if	O
(	O
valid_cdr	function
(	O
x	int
)	O
)	O
return	O
valid_cdr	function
(	O
y	int
)	O
&&	O
equal	function
(	O
x	int
->	O
c	O
.	O
c_car	O
,	O
y	int
->	O
c	O
.	O
c_car	O
)	O
&&	O
equal	function
(	O
x	int
->	O
c	O
.	O
c_cdr	O
,	O
y	int
->	O
c	O
.	O
c_cdr	O
)	O
;	O
if	O
(	O
valid_cdr	function
(	O
y	int
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
x	int
->	O
d	O
.	O
t	enum
!=	O
y	int
->	O
d	O
.	O
t	enum
)	O
return	O
FALSE	O
;	O
switch	O
(	O
x	int
->	O
d	O
.	O
t	enum
)	O
{	O
case	O
t_string	O
:	O
return	O
(	O
string_eq	function
(	O
x	int
,	O
y	int
)	O
)	O
;	O
case	O
t_bitvector	O
:	O
{	O
fixnum	O
i	int
,	O
ox	O
,	O
oy	O
;	O
if	O
(	O
x	int
->	O
bv	O
.	O
bv_fillp	O
!=	O
y	int
->	O
bv	O
.	O
bv_fillp	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
ox	O
=	O
BV_OFFSET	function
(	O
x	int
)	O
;	O
oy	O
=	O
BV_OFFSET	function
(	O
y	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
x	int
->	O
bv	O
.	O
bv_fillp	O
;	O
i	int
++	O
)	O
if	O
(	O
(	O
(	O
x	int
->	O
bv	O
.	O
bv_self	O
[	O
(	O
i	int
+	O
ox	O
)	O
/	O
8	int
]	O
&	O
(	O
0200	int
>>	O
(	O
i	int
+	O
ox	O
)	O
%	O
8	int
)	O
)	O
?	O
1	int
:	O
0	int
)	O
!=	O
(	O
(	O
y	int
->	O
bv	O
.	O
bv_self	O
[	O
(	O
i	int
+	O
oy	O
)	O
/	O
8	int
]	O
&	O
(	O
0200	int
>>	O
(	O
i	int
+	O
oy	O
)	O
%	O
8	int
)	O
)	O
?	O
1	int
:	O
0	int
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
case	O
t_pathname	O
:	O
if	O
(	O
equal	function
(	O
x	int
->	O
pn	O
.	O
pn_host	O
,	O
y	int
->	O
pn	O
.	O
pn_host	O
)	O
&&	O
equal	function
(	O
x	int
->	O
pn	O
.	O
pn_device	O
,	O
y	int
->	O
pn	O
.	O
pn_device	O
)	O
&&	O
equal	function
(	O
x	int
->	O
pn	O
.	O
pn_directory	O
,	O
y	int
->	O
pn	O
.	O
pn_directory	O
)	O
&&	O
equal	function
(	O
x	int
->	O
pn	O
.	O
pn_name	O
,	O
y	int
->	O
pn	O
.	O
pn_name	O
)	O
&&	O
equal	function
(	O
x	int
->	O
pn	O
.	O
pn_type	O
,	O
y	int
->	O
pn	O
.	O
pn_type	O
)	O
&&	O
equal	function
(	O
x	int
->	O
pn	O
.	O
pn_version	O
,	O
y	int
->	O
pn	O
.	O
pn_version	O
)	O
)	O
return	O
(	O
TRUE	O
)	O
;	O
else	O
return	O
(	O
FALSE	O
)	O
;	O
eqlm	O
(	O
x	int
,	O
y	int
)	O
;	O
}	O
}	O
bool	O
oequal	function
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
return	O
equal	function
(	O
x	int
,	O
y	int
)	O
?	O
TRUE	O
:	O
FALSE	O
;	O
}	O
DEFUN_NEW	function
(	O
"EQUAL"	pointer
,	O
object	O
,	O
fLequal	O
,	O
LISP	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
,	O
object	O
x1	O
)	O
,	O
""	pointer
)	O
{	O
RETURN1	function
(	O
equal	function
(	O
x0	O
,	O
x1	O
)	O
?	O
Ct	O
:	O
Cnil	O
)	O
;	O
}	O
bool	O
equalp1	function
(	O
register	O
object	O
x	int
,	O
register	O
object	O
y	int
)	O
{	O
enum	O
type	O
tx	enum
,	O
ty	enum
;	O
fixnum	O
j	int
;	O
if	O
(	O
listp	function
(	O
x	int
)	O
)	O
return	O
listp	function
(	O
y	int
)	O
&&	O
equalp	function
(	O
x	int
->	O
c	O
.	O
c_car	O
,	O
y	int
->	O
c	O
.	O
c_car	O
)	O
&&	O
equalp	function
(	O
x	int
->	O
c	O
.	O
c_cdr	O
,	O
y	int
->	O
c	O
.	O
c_cdr	O
)	O
;	O
if	O
(	O
listp	function
(	O
y	int
)	O
)	O
return	O
FALSE	O
;	O
tx	enum
=	O
is_imm_fixnum	function
(	O
x	int
)	O
?	O
t_fixnum	O
:	O
x	int
->	O
d	O
.	O
t	enum
;	O
ty	enum
=	O
is_imm_fixnum	function
(	O
y	int
)	O
?	O
t_fixnum	O
:	O
y	int
->	O
d	O
.	O
t	enum
;	O
switch	O
(	O
tx	enum
)	O
{	O
case	O
t_fixnum	O
:	O
case	O
t_bignum	O
:	O
case	O
t_ratio	O
:	O
case	O
t_shortfloat	O
:	O
case	O
t_longfloat	O
:	O
case	O
t_complex	O
:	O
if	O
(	O
ty	enum
==	O
t_fixnum	O
||	O
ty	enum
==	O
t_bignum	O
||	O
ty	enum
==	O
t_ratio	O
||	O
ty	enum
==	O
t_shortfloat	O
||	O
ty	enum
==	O
t_longfloat	O
||	O
ty	enum
==	O
t_complex	O
)	O
return	O
(	O
!	O
number_compare	function
(	O
x	int
,	O
y	int
)	O
)	O
;	O
else	O
return	O
(	O
FALSE	O
)	O
;	O
case	O
t_vector	O
:	O
case	O
t_string	O
:	O
case	O
t_bitvector	O
:	O
if	O
(	O
ty	enum
==	O
t_vector	O
||	O
ty	enum
==	O
t_string	O
||	O
ty	enum
==	O
t_bitvector	O
)	O
{	O
j	int
=	O
x	int
->	O
v	O
.	O
v_fillp	O
;	O
if	O
(	O
j	int
!=	O
y	int
->	O
v	O
.	O
v_fillp	O
)	O
return	O
FALSE	O
;	O
goto	O
ARRAY	O
;	O
}	O
else	O
return	O
(	O
FALSE	O
)	O
;	O
case	O
t_array	O
:	O
if	O
(	O
ty	enum
==	O
t_array	O
&&	O
x	int
->	O
a	O
.	O
a_rank	O
==	O
y	int
->	O
a	O
.	O
a_rank	O
)	O
{	O
if	O
(	O
x	int
->	O
a	O
.	O
a_rank	O
>	O
1	int
)	O
{	O
fixnum	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
x	int
->	O
a	O
.	O
a_rank	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
x	int
->	O
a	O
.	O
a_dims	O
[	O
i	int
]	O
!=	O
y	int
->	O
a	O
.	O
a_dims	O
[	O
i	int
]	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
}	O
if	O
(	O
x	int
->	O
a	O
.	O
a_dim	O
!=	O
y	int
->	O
a	O
.	O
a_dim	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
j	int
=	O
x	int
->	O
a	O
.	O
a_dim	O
;	O
goto	O
ARRAY	O
;	O
}	O
else	O
return	O
(	O
FALSE	O
)	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
tx	enum
!=	O
ty	enum
)	O
return	O
(	O
FALSE	O
)	O
;	O
switch	O
(	O
tx	enum
)	O
{	O
case	O
t_character	O
:	O
return	O
(	O
char_equal	function
(	O
x	int
,	O
y	int
)	O
)	O
;	O
case	O
t_structure	O
:	O
{	O
fixnum	O
i	int
;	O
if	O
(	O
x	int
->	O
str	O
.	O
str_def	O
!=	O
y	int
->	O
str	O
.	O
str_def	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
{	O
fixnum	O
leng	O
=	O
S_DATA	O
(	O
x	int
->	O
str	O
.	O
str_def	O
)	O
->	O
length	O
;	O
unsigned	O
char	O
*	O
s_type	pointer
=	O
&	O
SLOT_TYPE	function
(	O
x	int
->	O
str	O
.	O
str_def	O
,	O
0	int
)	O
;	O
unsigned	O
short	O
*	O
s_pos	pointer
=	O
&	O
SLOT_POS	function
(	O
x	int
->	O
str	O
.	O
str_def	O
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
leng	O
;	O
i	int
++	O
,	O
s_pos	pointer
++	O
)	O
{	O
if	O
(	O
s_type	pointer
[	O
i	int
]	O
==	O
aet_object	O
)	O
{	O
if	O
(	O
!	O
equalp	function
(	O
STREF	function
(	O
object	O
,	O
x	int
,	O
*	O
s_pos	pointer
)	O
,	O
STREF	function
(	O
object	O
,	O
y	int
,	O
*	O
s_pos	pointer
)	O
)	O
)	O
return	O
FALSE	O
;	O
}	O
else	O
switch	O
(	O
s_type	pointer
[	O
i	int
]	O
)	O
{	O
case	O
aet_lf	O
:	O
if	O
(	O
(	O
!	O
(	O
*	O
s_pos	pointer
&	O
(	O
sizeof	O
(	O
longfloat	O
)	O
-	O
1	int
)	O
)	O
)	O
&&	O
STREF	function
(	O
longfloat	O
,	O
x	int
,	O
*	O
s_pos	pointer
)	O
!=	O
STREF	function
(	O
longfloat	O
,	O
y	int
,	O
*	O
s_pos	pointer
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
break	O
;	O
case	O
aet_sf	O
:	O
if	O
(	O
(	O
!	O
(	O
*	O
s_pos	pointer
&	O
(	O
sizeof	O
(	O
shortfloat	O
)	O
-	O
1	int
)	O
)	O
)	O
&&	O
STREF	function
(	O
shortfloat	O
,	O
x	int
,	O
*	O
s_pos	pointer
)	O
!=	O
STREF	function
(	O
shortfloat	O
,	O
y	int
,	O
*	O
s_pos	pointer
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
!	O
(	O
*	O
s_pos	pointer
&	O
(	O
sizeof	O
(	O
fixnum	O
)	O
-	O
1	int
)	O
)	O
)	O
&&	O
STREF	function
(	O
fixnum	O
,	O
x	int
,	O
*	O
s_pos	pointer
)	O
!=	O
STREF	function
(	O
fixnum	O
,	O
y	int
,	O
*	O
s_pos	pointer
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
break	O
;	O
}	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
}	O
case	O
t_hashtable	O
:	O
{	O
unsigned	O
i	int
;	O
struct	O
htent	O
*	O
e	pointer
;	O
if	O
(	O
x	int
->	O
ht	O
.	O
ht_nent	O
!=	O
y	int
->	O
ht	O
.	O
ht_nent	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
if	O
(	O
x	int
->	O
ht	O
.	O
ht_test	O
!=	O
y	int
->	O
ht	O
.	O
ht_test	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
x	int
->	O
ht	O
.	O
ht_size	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
x	int
->	O
ht	O
.	O
ht_self	O
[	O
i	int
]	O
.	O
hte_key	O
==	O
OBJNULL	O
)	O
continue	O
;	O
if	O
(	O
(	O
e	pointer
=	O
gethash	function
(	O
x	int
->	O
ht	O
.	O
ht_self	O
[	O
i	int
]	O
.	O
hte_key	O
,	O
y	int
)	O
)	O
->	O
hte_key	O
==	O
OBJNULL	O
||	O
!	O
equalp	function
(	O
x	int
->	O
ht	O
.	O
ht_self	O
[	O
i	int
]	O
.	O
hte_value	O
,	O
e	pointer
->	O
hte_value	O
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
return	O
(	O
TRUE	O
)	O
;	O
break	O
;	O
}	O
case	O
t_pathname	O
:	O
return	O
(	O
equal	function
(	O
x	int
,	O
y	int
)	O
)	O
;	O
case	O
t_random	O
:	O
return	O
(	O
x	int
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_seed	O
->	O
_mp_alloc	O
==	O
y	int
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_seed	O
->	O
_mp_alloc	O
&&	O
!	O
memcmp	function
(	O
x	int
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_seed	O
->	O
_mp_d	O
,	O
y	int
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_seed	O
->	O
_mp_d	O
,	O
x	int
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_seed	O
->	O
_mp_alloc	O
*	O
sizeof	O
(	O
*	O
x	int
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_seed	O
->	O
_mp_d	O
)	O
)	O
)	O
;	O
default	O
:	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
ARRAY	O
:	O
{	O
fixnum	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
equalp	function
(	O
aref	function
(	O
x	int
,	O
i	int
)	O
,	O
aref	function
(	O
y	int
,	O
i	int
)	O
)	O
)	O
return	O
(	O
FALSE	O
)	O
;	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
}	O
bool	O
oequalp	function
(	O
object	O
x	int
,	O
object	O
y	int
)	O
{	O
return	O
equalp	function
(	O
x	int
,	O
y	int
)	O
?	O
TRUE	O
:	O
FALSE	O
;	O
}	O
DEFUN_NEW	function
(	O
"EQUALP"	pointer
,	O
object	O
,	O
fLequalp	O
,	O
LISP	O
,	O
2	int
,	O
2	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
,	O
object	O
x1	O
)	O
,	O
""	pointer
)	O
{	O
RETURN1	function
(	O
equalp	function
(	O
x0	O
,	O
x1	O
)	O
?	O
Ct	O
:	O
Cnil	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
Fand	int
)	O
(	O
object	O
args	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	function
(	O
args	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	function
(	O
Ct	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
MMcdr	function
(	O
args	int
)	O
)	O
)	O
{	O
eval	function
(	O
MMcar	function
(	O
args	int
)	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
==	O
Cnil	O
)	O
{	O
vs_base	O
=	O
vs_top	O
=	O
top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
return	O
;	O
}	O
vs_top	O
=	O
top	O
;	O
args	int
=	O
MMcdr	function
(	O
args	int
)	O
;	O
}	O
eval	function
(	O
MMcar	function
(	O
args	int
)	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
For	int
)	O
(	O
object	O
args	int
)	O
{	O
object	O
*	O
top	O
=	O
vs_top	O
;	O
if	O
(	O
endp	function
(	O
args	int
)	O
)	O
{	O
vs_base	O
=	O
vs_top	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
return	O
;	O
}	O
while	O
(	O
!	O
endp	function
(	O
MMcdr	function
(	O
args	int
)	O
)	O
)	O
{	O
eval	function
(	O
MMcar	function
(	O
args	int
)	O
)	O
;	O
if	O
(	O
vs_base	O
[	O
0	int
]	O
!=	O
Cnil	O
)	O
{	O
top	O
[	O
0	int
]	O
=	O
vs_base	O
[	O
0	int
]	O
;	O
vs_base	O
=	O
top	O
;	O
vs_top	O
=	O
top	O
+	O
1	int
;	O
return	O
;	O
}	O
vs_top	O
=	O
top	O
;	O
args	int
=	O
MMcdr	function
(	O
args	int
)	O
;	O
}	O
eval	function
(	O
MMcar	function
(	O
args	int
)	O
)	O
;	O
}	O
bool	O
contains_sharp_comma	function
(	O
object	O
x	int
)	O
{	O
enum	O
type	O
tx	enum
;	O
cs_check	function
(	O
x	int
)	O
;	O
BEGIN	O
:	O
tx	enum
=	O
type_of	function
(	O
x	int
)	O
;	O
if	O
(	O
tx	enum
==	O
t_complex	O
)	O
return	O
(	O
contains_sharp_comma	function
(	O
x	int
->	O
cmp	O
.	O
cmp_real	O
)	O
||	O
contains_sharp_comma	function
(	O
x	int
->	O
cmp	O
.	O
cmp_imag	O
)	O
)	O
;	O
if	O
(	O
tx	enum
==	O
t_vector	O
)	O
{	O
int	O
i	int
;	O
if	O
(	O
x	int
->	O
v	O
.	O
v_elttype	O
==	O
aet_object	O
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
x	int
->	O
v	O
.	O
v_fillp	O
;	O
i	int
++	O
)	O
if	O
(	O
contains_sharp_comma	function
(	O
x	int
->	O
v	O
.	O
v_self	O
[	O
i	int
]	O
)	O
)	O
return	O
(	O
TRUE	O
)	O
;	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
if	O
(	O
tx	enum
==	O
t_cons	O
)	O
{	O
if	O
(	O
x	int
->	O
c	O
.	O
c_car	O
==	O
siSsharp_comma	O
)	O
return	O
(	O
TRUE	O
)	O
;	O
if	O
(	O
contains_sharp_comma	function
(	O
x	int
->	O
c	O
.	O
c_car	O
)	O
)	O
return	O
(	O
TRUE	O
)	O
;	O
x	int
=	O
x	int
->	O
c	O
.	O
c_cdr	O
;	O
goto	O
BEGIN	O
;	O
}	O
if	O
(	O
tx	enum
==	O
t_array	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
x	int
->	O
a	O
.	O
a_elttype	O
==	O
aet_object	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
,	O
j	int
=	O
1	int
;	O
i	int
<	O
x	int
->	O
a	O
.	O
a_rank	O
;	O
i	int
++	O
)	O
j	int
*=	O
x	int
->	O
a	O
.	O
a_dims	O
[	O
i	int
]	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
j	int
;	O
i	int
++	O
)	O
if	O
(	O
contains_sharp_comma	function
(	O
x	int
->	O
a	O
.	O
a_self	O
[	O
i	int
]	O
)	O
)	O
return	O
(	O
TRUE	O
)	O
;	O
}	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
if	O
(	O
tx	enum
==	O
t_structure	O
)	O
return	O
(	O
TRUE	O
)	O
;	O
return	O
(	O
FALSE	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"CONTAINS-SHARP-COMMA"	pointer
,	O
object	O
,	O
fScontains_sharp_comma	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
contains_sharp_comma	function
(	O
x0	O
)	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"SPICEP"	pointer
,	O
object	O
,	O
fSspicep	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_spice	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"FIXNUMP"	pointer
,	O
object	O
,	O
fSfixnump	O
,	O
SI	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
type_of	function
(	O
x0	O
)	O
==	O
t_fixnum	O
)	O
x0	O
=	O
Ct	O
;	O
else	O
x0	O
=	O
Cnil	O
;	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
void	O
gcl_init_predicate_function	function
(	O
void	O
)	O
{	O
sLand	O
=	O
make_special_form	function
(	O
"AND"	pointer
,	O
Fand	int
)	O
;	O
sLor	O
=	O
make_special_form	function
(	O
"OR"	pointer
,	O
For	int
)	O
;	O
}	O
