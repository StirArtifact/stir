static	O
int	O
report_uncertainty	int
=	O
0	int
;	O
static	O
int	O
gtp_orientation	int
=	O
0	int
;	O
static	O
void	O
gtp_print_code	function
(	O
int	O
c	char
)	O
;	O
static	O
void	O
gtp_print_vertices2	function
(	O
int	O
n	int
,	O
int	O
*	O
moves	array
)	O
;	O
static	O
void	O
rotate_on_input	function
(	O
int	O
ai	int
,	O
int	O
aj	int
,	O
int	O
*	O
bi	pointer
,	O
int	O
*	O
bj	pointer
)	O
;	O
static	O
void	O
rotate_on_output	function
(	O
int	O
ai	int
,	O
int	O
aj	int
,	O
int	O
*	O
bi	pointer
,	O
int	O
*	O
bj	pointer
)	O
;	O
DECLARE	O
(	O
gtp_aa_confirm_safety	function
)	O
;	O
DECLARE	O
(	O
gtp_accurate_approxlib	function
)	O
;	O
DECLARE	O
(	O
gtp_accuratelib	function
)	O
;	O
DECLARE	O
(	O
gtp_advance_random_seed	function
)	O
;	O
DECLARE	O
(	O
gtp_all_legal	function
)	O
;	O
DECLARE	O
(	O
gtp_all_move_values	function
)	O
;	O
DECLARE	O
(	O
gtp_analyze_eyegraph	function
)	O
;	O
DECLARE	O
(	O
gtp_analyze_semeai	function
)	O
;	O
DECLARE	O
(	O
gtp_analyze_semeai_after_move	function
)	O
;	O
DECLARE	O
(	O
gtp_attack	function
)	O
;	O
DECLARE	O
(	O
gtp_attack_either	function
)	O
;	O
DECLARE	O
(	O
gtp_block_off	function
)	O
;	O
DECLARE	O
(	O
gtp_break_in	function
)	O
;	O
DECLARE	O
(	O
gtp_captures	function
)	O
;	O
DECLARE	O
(	O
gtp_clear_board	function
)	O
;	O
DECLARE	O
(	O
gtp_clear_cache	function
)	O
;	O
DECLARE	O
(	O
gtp_combination_attack	function
)	O
;	O
DECLARE	O
(	O
gtp_combination_defend	function
)	O
;	O
DECLARE	O
(	O
gtp_connect	function
)	O
;	O
DECLARE	O
(	O
gtp_countlib	function
)	O
;	O
DECLARE	O
(	O
gtp_cputime	function
)	O
;	O
DECLARE	O
(	O
gtp_decrease_depths	function
)	O
;	O
DECLARE	O
(	O
gtp_defend	function
)	O
;	O
DECLARE	O
(	O
gtp_defend_both	function
)	O
;	O
DECLARE	O
(	O
gtp_disconnect	function
)	O
;	O
DECLARE	O
(	O
gtp_does_attack	function
)	O
;	O
DECLARE	O
(	O
gtp_does_defend	function
)	O
;	O
DECLARE	O
(	O
gtp_does_surround	function
)	O
;	O
DECLARE	O
(	O
gtp_dragon_data	function
)	O
;	O
DECLARE	O
(	O
gtp_dragon_status	function
)	O
;	O
DECLARE	O
(	O
gtp_dragon_stones	function
)	O
;	O
DECLARE	O
(	O
gtp_draw_search_area	function
)	O
;	O
DECLARE	O
(	O
gtp_dump_stack	function
)	O
;	O
DECLARE	O
(	O
gtp_echo	function
)	O
;	O
DECLARE	O
(	O
gtp_echo_err	function
)	O
;	O
DECLARE	O
(	O
gtp_estimate_score	function
)	O
;	O
DECLARE	O
(	O
gtp_eval_eye	function
)	O
;	O
DECLARE	O
(	O
gtp_experimental_score	function
)	O
;	O
DECLARE	O
(	O
gtp_eye_data	function
)	O
;	O
DECLARE	O
(	O
gtp_final_score	function
)	O
;	O
DECLARE	O
(	O
gtp_final_status	function
)	O
;	O
DECLARE	O
(	O
gtp_final_status_list	function
)	O
;	O
DECLARE	O
(	O
gtp_findlib	function
)	O
;	O
DECLARE	O
(	O
gtp_finish_sgftrace	function
)	O
;	O
DECLARE	O
(	O
gtp_fixed_handicap	function
)	O
;	O
DECLARE	O
(	O
gtp_followup_influence	function
)	O
;	O
DECLARE	O
(	O
gtp_genmove	function
)	O
;	O
DECLARE	O
(	O
gtp_genmove_black	function
)	O
;	O
DECLARE	O
(	O
gtp_genmove_white	function
)	O
;	O
DECLARE	O
(	O
gtp_get_connection_node_counter	function
)	O
;	O
DECLARE	O
(	O
gtp_get_handicap	function
)	O
;	O
DECLARE	O
(	O
gtp_get_komi	function
)	O
;	O
DECLARE	O
(	O
gtp_get_life_node_counter	function
)	O
;	O
DECLARE	O
(	O
gtp_get_owl_node_counter	function
)	O
;	O
DECLARE	O
(	O
gtp_get_random_seed	function
)	O
;	O
DECLARE	O
(	O
gtp_get_reading_node_counter	function
)	O
;	O
DECLARE	O
(	O
gtp_get_trymove_counter	function
)	O
;	O
DECLARE	O
(	O
gtp_gg_genmove	function
)	O
;	O
DECLARE	O
(	O
gtp_gg_undo	function
)	O
;	O
DECLARE	O
(	O
gtp_half_eye_data	function
)	O
;	O
DECLARE	O
(	O
gtp_increase_depths	function
)	O
;	O
DECLARE	O
(	O
gtp_initial_influence	function
)	O
;	O
DECLARE	O
(	O
gtp_invariant_hash	function
)	O
;	O
DECLARE	O
(	O
gtp_invariant_hash_for_moves	function
)	O
;	O
DECLARE	O
(	O
gtp_is_legal	function
)	O
;	O
DECLARE	O
(	O
gtp_is_surrounded	function
)	O
;	O
DECLARE	O
(	O
gtp_kgs_genmove_cleanup	function
)	O
;	O
DECLARE	O
(	O
gtp_known_command	function
)	O
;	O
DECLARE	O
(	O
gtp_ladder_attack	function
)	O
;	O
DECLARE	O
(	O
gtp_last_move	function
)	O
;	O
DECLARE	O
(	O
gtp_limit_search	function
)	O
;	O
DECLARE	O
(	O
gtp_list_commands	function
)	O
;	O
DECLARE	O
(	O
gtp_list_stones	function
)	O
;	O
DECLARE	O
(	O
gtp_loadsgf	function
)	O
;	O
DECLARE	O
(	O
gtp_move_influence	function
)	O
;	O
DECLARE	O
(	O
gtp_move_probabilities	function
)	O
;	O
DECLARE	O
(	O
gtp_move_reasons	function
)	O
;	O
DECLARE	O
(	O
gtp_move_uncertainty	function
)	O
;	O
DECLARE	O
(	O
gtp_move_history	function
)	O
;	O
DECLARE	O
(	O
gtp_name	function
)	O
;	O
DECLARE	O
(	O
gtp_owl_attack	function
)	O
;	O
DECLARE	O
(	O
gtp_owl_connection_defends	function
)	O
;	O
DECLARE	O
(	O
gtp_owl_defend	function
)	O
;	O
DECLARE	O
(	O
gtp_owl_does_attack	function
)	O
;	O
DECLARE	O
(	O
gtp_owl_does_defend	function
)	O
;	O
DECLARE	O
(	O
gtp_owl_substantial	function
)	O
;	O
DECLARE	O
(	O
gtp_owl_threaten_attack	function
)	O
;	O
DECLARE	O
(	O
gtp_owl_threaten_defense	function
)	O
;	O
DECLARE	O
(	O
gtp_place_free_handicap	function
)	O
;	O
DECLARE	O
(	O
gtp_play	function
)	O
;	O
DECLARE	O
(	O
gtp_playblack	function
)	O
;	O
DECLARE	O
(	O
gtp_playwhite	function
)	O
;	O
DECLARE	O
(	O
gtp_popgo	function
)	O
;	O
DECLARE	O
(	O
gtp_printsgf	function
)	O
;	O
DECLARE	O
(	O
gtp_program_version	function
)	O
;	O
DECLARE	O
(	O
gtp_protocol_version	function
)	O
;	O
DECLARE	O
(	O
gtp_query_boardsize	function
)	O
;	O
DECLARE	O
(	O
gtp_query_orientation	function
)	O
;	O
DECLARE	O
(	O
gtp_quit	function
)	O
;	O
DECLARE	O
(	O
gtp_reg_genmove	function
)	O
;	O
DECLARE	O
(	O
gtp_report_uncertainty	function
)	O
;	O
DECLARE	O
(	O
gtp_reset_connection_node_counter	function
)	O
;	O
DECLARE	O
(	O
gtp_reset_life_node_counter	function
)	O
;	O
DECLARE	O
(	O
gtp_reset_owl_node_counter	function
)	O
;	O
DECLARE	O
(	O
gtp_reset_reading_node_counter	function
)	O
;	O
DECLARE	O
(	O
gtp_reset_search_mask	function
)	O
;	O
DECLARE	O
(	O
gtp_reset_trymove_counter	function
)	O
;	O
DECLARE	O
(	O
gtp_restricted_genmove	function
)	O
;	O
DECLARE	O
(	O
gtp_same_dragon	function
)	O
;	O
DECLARE	O
(	O
gtp_set_boardsize	function
)	O
;	O
DECLARE	O
(	O
gtp_set_free_handicap	function
)	O
;	O
DECLARE	O
(	O
gtp_set_komi	function
)	O
;	O
DECLARE	O
(	O
gtp_set_level	function
)	O
;	O
DECLARE	O
(	O
gtp_set_orientation	function
)	O
;	O
DECLARE	O
(	O
gtp_set_random_seed	function
)	O
;	O
DECLARE	O
(	O
gtp_set_search_diamond	function
)	O
;	O
DECLARE	O
(	O
gtp_set_search_limit	function
)	O
;	O
DECLARE	O
(	O
gtp_showboard	function
)	O
;	O
DECLARE	O
(	O
gtp_start_sgftrace	function
)	O
;	O
DECLARE	O
(	O
gtp_surround_map	function
)	O
;	O
DECLARE	O
(	O
gtp_tactical_analyze_semeai	function
)	O
;	O
DECLARE	O
(	O
gtp_test_eyeshape	function
)	O
;	O
DECLARE	O
(	O
gtp_time_left	function
)	O
;	O
DECLARE	O
(	O
gtp_time_settings	function
)	O
;	O
DECLARE	O
(	O
gtp_top_moves	function
)	O
;	O
DECLARE	O
(	O
gtp_top_moves_black	function
)	O
;	O
DECLARE	O
(	O
gtp_top_moves_white	function
)	O
;	O
DECLARE	O
(	O
gtp_tryko	function
)	O
;	O
DECLARE	O
(	O
gtp_trymove	function
)	O
;	O
DECLARE	O
(	O
gtp_tune_move_ordering	function
)	O
;	O
DECLARE	O
(	O
gtp_unconditional_status	function
)	O
;	O
DECLARE	O
(	O
gtp_undo	function
)	O
;	O
DECLARE	O
(	O
gtp_what_color	function
)	O
;	O
DECLARE	O
(	O
gtp_worm_cutstone	function
)	O
;	O
DECLARE	O
(	O
gtp_worm_data	function
)	O
;	O
DECLARE	O
(	O
gtp_worm_stones	function
)	O
;	O
static	O
struct	O
gtp_command	struct
commands	array
[	O
]	O
=	O
{	O
{	O
"aa_confirm_safety"	pointer
,	O
gtp_aa_confirm_safety	function
}	O
,	O
{	O
"accurate_approxlib"	pointer
,	O
gtp_accurate_approxlib	function
}	O
,	O
{	O
"accuratelib"	pointer
,	O
gtp_accuratelib	function
}	O
,	O
{	O
"advance_random_seed"	pointer
,	O
gtp_advance_random_seed	function
}	O
,	O
{	O
"all_legal"	pointer
,	O
gtp_all_legal	function
}	O
,	O
{	O
"all_move_values"	pointer
,	O
gtp_all_move_values	function
}	O
,	O
{	O
"analyze_eyegraph"	pointer
,	O
gtp_analyze_eyegraph	function
}	O
,	O
{	O
"analyze_semeai"	pointer
,	O
gtp_analyze_semeai	function
}	O
,	O
{	O
"analyze_semeai_after_move"	pointer
,	O
gtp_analyze_semeai_after_move	function
}	O
,	O
{	O
"attack"	pointer
,	O
gtp_attack	function
}	O
,	O
{	O
"attack_either"	pointer
,	O
gtp_attack_either	function
}	O
,	O
{	O
"black"	pointer
,	O
gtp_playblack	function
}	O
,	O
{	O
"block_off"	pointer
,	O
gtp_block_off	function
}	O
,	O
{	O
"boardsize"	pointer
,	O
gtp_set_boardsize	function
}	O
,	O
{	O
"break_in"	pointer
,	O
gtp_break_in	function
}	O
,	O
{	O
"captures"	pointer
,	O
gtp_captures	function
}	O
,	O
{	O
"clear_board"	pointer
,	O
gtp_clear_board	function
}	O
,	O
{	O
"clear_cache"	pointer
,	O
gtp_clear_cache	function
}	O
,	O
{	O
"color"	pointer
,	O
gtp_what_color	function
}	O
,	O
{	O
"combination_attack"	pointer
,	O
gtp_combination_attack	function
}	O
,	O
{	O
"combination_defend"	pointer
,	O
gtp_combination_defend	function
}	O
,	O
{	O
"connect"	pointer
,	O
gtp_connect	function
}	O
,	O
{	O
"countlib"	pointer
,	O
gtp_countlib	function
}	O
,	O
{	O
"cputime"	pointer
,	O
gtp_cputime	function
}	O
,	O
{	O
"decrease_depths"	pointer
,	O
gtp_decrease_depths	function
}	O
,	O
{	O
"defend"	pointer
,	O
gtp_defend	function
}	O
,	O
{	O
"defend_both"	pointer
,	O
gtp_defend_both	function
}	O
,	O
{	O
"disconnect"	pointer
,	O
gtp_disconnect	function
}	O
,	O
{	O
"does_attack"	pointer
,	O
gtp_does_attack	function
}	O
,	O
{	O
"does_defend"	pointer
,	O
gtp_does_defend	function
}	O
,	O
{	O
"does_surround"	pointer
,	O
gtp_does_surround	function
}	O
,	O
{	O
"dragon_data"	pointer
,	O
gtp_dragon_data	function
}	O
,	O
{	O
"dragon_status"	pointer
,	O
gtp_dragon_status	function
}	O
,	O
{	O
"dragon_stones"	pointer
,	O
gtp_dragon_stones	function
}	O
,	O
{	O
"draw_search_area"	pointer
,	O
gtp_draw_search_area	function
}	O
,	O
{	O
"dump_stack"	pointer
,	O
gtp_dump_stack	function
}	O
,	O
{	O
"echo"	pointer
,	O
gtp_echo	function
}	O
,	O
{	O
"echo_err"	pointer
,	O
gtp_echo_err	function
}	O
,	O
{	O
"estimate_score"	pointer
,	O
gtp_estimate_score	function
}	O
,	O
{	O
"eval_eye"	pointer
,	O
gtp_eval_eye	function
}	O
,	O
{	O
"experimental_score"	pointer
,	O
gtp_experimental_score	function
}	O
,	O
{	O
"eye_data"	pointer
,	O
gtp_eye_data	function
}	O
,	O
{	O
"final_score"	pointer
,	O
gtp_final_score	function
}	O
,	O
{	O
"final_status"	pointer
,	O
gtp_final_status	function
}	O
,	O
{	O
"final_status_list"	pointer
,	O
gtp_final_status_list	function
}	O
,	O
{	O
"findlib"	pointer
,	O
gtp_findlib	function
}	O
,	O
{	O
"finish_sgftrace"	pointer
,	O
gtp_finish_sgftrace	function
}	O
,	O
{	O
"fixed_handicap"	pointer
,	O
gtp_fixed_handicap	function
}	O
,	O
{	O
"followup_influence"	pointer
,	O
gtp_followup_influence	function
}	O
,	O
{	O
"genmove"	pointer
,	O
gtp_genmove	function
}	O
,	O
{	O
"genmove_black"	pointer
,	O
gtp_genmove_black	function
}	O
,	O
{	O
"genmove_white"	pointer
,	O
gtp_genmove_white	function
}	O
,	O
{	O
"get_connection_node_counter"	pointer
,	O
gtp_get_connection_node_counter	function
}	O
,	O
{	O
"get_handicap"	pointer
,	O
gtp_get_handicap	function
}	O
,	O
{	O
"get_komi"	pointer
,	O
gtp_get_komi	function
}	O
,	O
{	O
"get_life_node_counter"	pointer
,	O
gtp_get_life_node_counter	function
}	O
,	O
{	O
"get_owl_node_counter"	pointer
,	O
gtp_get_owl_node_counter	function
}	O
,	O
{	O
"get_random_seed"	pointer
,	O
gtp_get_random_seed	function
}	O
,	O
{	O
"get_reading_node_counter"	pointer
,	O
gtp_get_reading_node_counter	function
}	O
,	O
{	O
"get_trymove_counter"	pointer
,	O
gtp_get_trymove_counter	function
}	O
,	O
{	O
"gg-undo"	pointer
,	O
gtp_gg_undo	function
}	O
,	O
{	O
"gg_genmove"	pointer
,	O
gtp_gg_genmove	function
}	O
,	O
{	O
"half_eye_data"	pointer
,	O
gtp_half_eye_data	function
}	O
,	O
{	O
"help"	pointer
,	O
gtp_list_commands	function
}	O
,	O
{	O
"increase_depths"	pointer
,	O
gtp_increase_depths	function
}	O
,	O
{	O
"initial_influence"	pointer
,	O
gtp_initial_influence	function
}	O
,	O
{	O
"invariant_hash_for_moves"	pointer
,	O
gtp_invariant_hash_for_moves	function
}	O
,	O
{	O
"invariant_hash"	pointer
,	O
gtp_invariant_hash	function
}	O
,	O
{	O
"is_legal"	pointer
,	O
gtp_is_legal	function
}	O
,	O
{	O
"is_surrounded"	pointer
,	O
gtp_is_surrounded	function
}	O
,	O
{	O
"kgs-genmove_cleanup"	pointer
,	O
gtp_kgs_genmove_cleanup	function
}	O
,	O
{	O
"known_command"	pointer
,	O
gtp_known_command	function
}	O
,	O
{	O
"komi"	pointer
,	O
gtp_set_komi	function
}	O
,	O
{	O
"ladder_attack"	pointer
,	O
gtp_ladder_attack	function
}	O
,	O
{	O
"last_move"	pointer
,	O
gtp_last_move	function
}	O
,	O
{	O
"level"	pointer
,	O
gtp_set_level	function
}	O
,	O
{	O
"limit_search"	pointer
,	O
gtp_limit_search	function
}	O
,	O
{	O
"list_commands"	pointer
,	O
gtp_list_commands	function
}	O
,	O
{	O
"list_stones"	pointer
,	O
gtp_list_stones	function
}	O
,	O
{	O
"loadsgf"	pointer
,	O
gtp_loadsgf	function
}	O
,	O
{	O
"move_influence"	pointer
,	O
gtp_move_influence	function
}	O
,	O
{	O
"move_probabilities"	pointer
,	O
gtp_move_probabilities	function
}	O
,	O
{	O
"move_reasons"	pointer
,	O
gtp_move_reasons	function
}	O
,	O
{	O
"move_uncertainty"	pointer
,	O
gtp_move_uncertainty	function
}	O
,	O
{	O
"move_history"	pointer
,	O
gtp_move_history	function
}	O
,	O
{	O
"name"	pointer
,	O
gtp_name	function
}	O
,	O
{	O
"new_score"	pointer
,	O
gtp_estimate_score	function
}	O
,	O
{	O
"orientation"	pointer
,	O
gtp_set_orientation	function
}	O
,	O
{	O
"owl_attack"	pointer
,	O
gtp_owl_attack	function
}	O
,	O
{	O
"owl_connection_defends"	pointer
,	O
gtp_owl_connection_defends	function
}	O
,	O
{	O
"owl_defend"	pointer
,	O
gtp_owl_defend	function
}	O
,	O
{	O
"owl_does_attack"	pointer
,	O
gtp_owl_does_attack	function
}	O
,	O
{	O
"owl_does_defend"	pointer
,	O
gtp_owl_does_defend	function
}	O
,	O
{	O
"owl_substantial"	pointer
,	O
gtp_owl_substantial	function
}	O
,	O
{	O
"owl_threaten_attack"	pointer
,	O
gtp_owl_threaten_attack	function
}	O
,	O
{	O
"owl_threaten_defense"	pointer
,	O
gtp_owl_threaten_defense	function
}	O
,	O
{	O
"place_free_handicap"	pointer
,	O
gtp_place_free_handicap	function
}	O
,	O
{	O
"play"	pointer
,	O
gtp_play	function
}	O
,	O
{	O
"popgo"	pointer
,	O
gtp_popgo	function
}	O
,	O
{	O
"printsgf"	pointer
,	O
gtp_printsgf	function
}	O
,	O
{	O
"protocol_version"	pointer
,	O
gtp_protocol_version	function
}	O
,	O
{	O
"query_boardsize"	pointer
,	O
gtp_query_boardsize	function
}	O
,	O
{	O
"query_orientation"	pointer
,	O
gtp_query_orientation	function
}	O
,	O
{	O
"quit"	pointer
,	O
gtp_quit	function
}	O
,	O
{	O
"reg_genmove"	pointer
,	O
gtp_reg_genmove	function
}	O
,	O
{	O
"report_uncertainty"	pointer
,	O
gtp_report_uncertainty	function
}	O
,	O
{	O
"reset_connection_node_counter"	pointer
,	O
gtp_reset_connection_node_counter	function
}	O
,	O
{	O
"reset_life_node_counter"	pointer
,	O
gtp_reset_life_node_counter	function
}	O
,	O
{	O
"reset_owl_node_counter"	pointer
,	O
gtp_reset_owl_node_counter	function
}	O
,	O
{	O
"reset_reading_node_counter"	pointer
,	O
gtp_reset_reading_node_counter	function
}	O
,	O
{	O
"reset_search_mask"	pointer
,	O
gtp_reset_search_mask	function
}	O
,	O
{	O
"reset_trymove_counter"	pointer
,	O
gtp_reset_trymove_counter	function
}	O
,	O
{	O
"restricted_genmove"	pointer
,	O
gtp_restricted_genmove	function
}	O
,	O
{	O
"same_dragon"	pointer
,	O
gtp_same_dragon	function
}	O
,	O
{	O
"set_free_handicap"	pointer
,	O
gtp_set_free_handicap	function
}	O
,	O
{	O
"set_random_seed"	pointer
,	O
gtp_set_random_seed	function
}	O
,	O
{	O
"set_search_diamond"	pointer
,	O
gtp_set_search_diamond	function
}	O
,	O
{	O
"set_search_limit"	pointer
,	O
gtp_set_search_limit	function
}	O
,	O
{	O
"showboard"	pointer
,	O
gtp_showboard	function
}	O
,	O
{	O
"start_sgftrace"	pointer
,	O
gtp_start_sgftrace	function
}	O
,	O
{	O
"surround_map"	pointer
,	O
gtp_surround_map	function
}	O
,	O
{	O
"tactical_analyze_semeai"	pointer
,	O
gtp_tactical_analyze_semeai	function
}	O
,	O
{	O
"test_eyeshape"	pointer
,	O
gtp_test_eyeshape	function
}	O
,	O
{	O
"time_left"	pointer
,	O
gtp_time_left	function
}	O
,	O
{	O
"time_settings"	pointer
,	O
gtp_time_settings	function
}	O
,	O
{	O
"top_moves"	pointer
,	O
gtp_top_moves	function
}	O
,	O
{	O
"top_moves_black"	pointer
,	O
gtp_top_moves_black	function
}	O
,	O
{	O
"top_moves_white"	pointer
,	O
gtp_top_moves_white	function
}	O
,	O
{	O
"tryko"	pointer
,	O
gtp_tryko	function
}	O
,	O
{	O
"trymove"	pointer
,	O
gtp_trymove	function
}	O
,	O
{	O
"tune_move_ordering"	pointer
,	O
gtp_tune_move_ordering	function
}	O
,	O
{	O
"unconditional_status"	pointer
,	O
gtp_unconditional_status	function
}	O
,	O
{	O
"undo"	pointer
,	O
gtp_undo	function
}	O
,	O
{	O
"version"	pointer
,	O
gtp_program_version	function
}	O
,	O
{	O
"white"	pointer
,	O
gtp_playwhite	function
}	O
,	O
{	O
"worm_cutstone"	pointer
,	O
gtp_worm_cutstone	function
}	O
,	O
{	O
"worm_data"	pointer
,	O
gtp_worm_data	function
}	O
,	O
{	O
"worm_stones"	pointer
,	O
gtp_worm_stones	function
}	O
,	O
{	O
NULL	O
,	O
NULL	O
}	O
}	O
;	O
void	O
play_gtp	function
(	O
FILE	struct
*	O
gtp_input	pointer
,	O
FILE	struct
*	O
gtp_output	pointer
,	O
FILE	struct
*	O
gtp_dump_commands	pointer
,	O
int	O
gtp_initial_orientation	int
)	O
{	O
setbuf	function
(	O
gtp_output	pointer
,	O
NULL	O
)	O
;	O
gtp_internal_set_boardsize	function
(	O
board_size	int
)	O
;	O
gtp_orientation	int
=	O
gtp_initial_orientation	int
;	O
gtp_set_vertex_transform_hooks	function
(	O
rotate_on_input	function
,	O
rotate_on_output	function
)	O
;	O
init_timers	function
(	O
)	O
;	O
reset_engine	function
(	O
)	O
;	O
clearstats	function
(	O
)	O
;	O
gtp_main_loop	function
(	O
commands	array
,	O
gtp_input	pointer
,	O
gtp_output	pointer
,	O
gtp_dump_commands	pointer
)	O
;	O
if	O
(	O
showstatistics	int
)	O
showstats	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_quit	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
gtp_success	function
(	O
""	pointer
)	O
;	O
return	O
GTP_QUIT	O
;	O
}	O
static	O
int	O
gtp_protocol_version	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
gtp_version	int
)	O
;	O
}	O
static	O
int	O
gtp_name	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"GNU Go"	pointer
)	O
;	O
}	O
static	O
int	O
gtp_program_version	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
VERSION	pointer
)	O
;	O
}	O
static	O
int	O
gtp_set_boardsize	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
boardsize	int
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
&	O
boardsize	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	function
(	O
"boardsize not an integer"	pointer
)	O
;	O
if	O
(	O
!	O
check_boardsize	function
(	O
boardsize	int
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
gtp_version	int
==	O
1	int
)	O
return	O
gtp_failure	function
(	O
"unacceptable boardsize"	pointer
)	O
;	O
else	O
return	O
gtp_failure	function
(	O
"unacceptable size"	pointer
)	O
;	O
}	O
if	O
(	O
stones_on_board	function
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
0	int
)	O
update_random_seed	function
(	O
)	O
;	O
board_size	int
=	O
boardsize	int
;	O
clear_board	function
(	O
)	O
;	O
gtp_internal_set_boardsize	function
(	O
boardsize	int
)	O
;	O
reset_engine	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_query_boardsize	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
board_size	int
)	O
;	O
}	O
static	O
int	O
gtp_clear_board	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
if	O
(	O
stones_on_board	function
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
0	int
)	O
update_random_seed	function
(	O
)	O
;	O
clear_board	function
(	O
)	O
;	O
init_timers	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_set_orientation	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
orientation	int
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
&	O
orientation	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	function
(	O
"orientation not an integer"	pointer
)	O
;	O
if	O
(	O
orientation	int
<	O
0	int
||	O
orientation	int
>	O
7	int
)	O
return	O
gtp_failure	function
(	O
"unacceptable orientation"	pointer
)	O
;	O
clear_board	function
(	O
)	O
;	O
gtp_orientation	int
=	O
orientation	int
;	O
gtp_set_vertex_transform_hooks	function
(	O
rotate_on_input	function
,	O
rotate_on_output	function
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_query_orientation	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
gtp_orientation	int
)	O
;	O
}	O
static	O
int	O
gtp_set_komi	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%f"	pointer
,	O
&	O
komi	float
)	O
<	O
1	int
)	O
return	O
gtp_failure	function
(	O
"komi not a float"	pointer
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_get_komi	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%4.1f"	pointer
,	O
komi	float
)	O
;	O
}	O
static	O
int	O
gtp_playblack	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
*	O
c	char
;	O
for	O
(	O
c	char
=	O
s	pointer
;	O
*	O
c	char
;	O
c	char
++	O
)	O
*	O
c	char
=	O
tolower	function
(	O
(	O
int	O
)	O
*	O
c	char
)	O
;	O
if	O
(	O
strncmp	function
(	O
s	pointer
,	O
"pass"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
{	O
i	int
=	O
-	O
1	int
;	O
j	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
!	O
is_allowed_move	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
BLACK	int
)	O
)	O
return	O
gtp_failure	function
(	O
"illegal move"	pointer
)	O
;	O
gnugo_play_move	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
BLACK	int
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_playwhite	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
*	O
c	char
;	O
for	O
(	O
c	char
=	O
s	pointer
;	O
*	O
c	char
;	O
c	char
++	O
)	O
*	O
c	char
=	O
tolower	function
(	O
(	O
int	O
)	O
*	O
c	char
)	O
;	O
if	O
(	O
strncmp	function
(	O
s	pointer
,	O
"pass"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
{	O
i	int
=	O
-	O
1	int
;	O
j	int
=	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
!	O
is_allowed_move	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
WHITE	int
)	O
)	O
return	O
gtp_failure	function
(	O
"illegal move"	pointer
)	O
;	O
gnugo_play_move	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
WHITE	int
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_play	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_move	function
(	O
s	pointer
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color or coordinate"	pointer
)	O
;	O
if	O
(	O
!	O
is_allowed_move	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
)	O
return	O
gtp_failure	function
(	O
"illegal move"	pointer
)	O
;	O
gnugo_play_move	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_fixed_handicap	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
m	int
,	O
n	int
;	O
int	O
first	int
=	O
1	int
;	O
int	O
this_handicap	int
;	O
if	O
(	O
gtp_version	int
==	O
1	int
)	O
clear_board	function
(	O
)	O
;	O
else	O
if	O
(	O
stones_on_board	function
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"board not empty"	pointer
)	O
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
&	O
this_handicap	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	function
(	O
"handicap not an integer"	pointer
)	O
;	O
if	O
(	O
this_handicap	int
<	O
2	int
&&	O
(	O
gtp_version	int
>	O
1	int
||	O
this_handicap	int
!=	O
0	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid handicap"	pointer
)	O
;	O
if	O
(	O
place_fixed_handicap	function
(	O
this_handicap	int
)	O
!=	O
this_handicap	int
)	O
{	O
clear_board	function
(	O
)	O
;	O
return	O
gtp_failure	function
(	O
"invalid handicap"	pointer
)	O
;	O
}	O
handicap	int
=	O
this_handicap	int
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
m	int
,	O
n	int
)	O
!=	O
EMPTY	int
)	O
{	O
if	O
(	O
!	O
first	int
)	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
else	O
first	int
=	O
0	int
;	O
gtp_mprintf	function
(	O
"%m"	pointer
,	O
m	int
,	O
n	int
)	O
;	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_place_free_handicap	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
m	int
,	O
n	int
;	O
int	O
first	int
=	O
1	int
;	O
int	O
this_handicap	int
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
&	O
this_handicap	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	function
(	O
"handicap not an integer"	pointer
)	O
;	O
if	O
(	O
stones_on_board	function
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"board not empty"	pointer
)	O
;	O
if	O
(	O
this_handicap	int
<	O
2	int
)	O
return	O
gtp_failure	function
(	O
"invalid handicap"	pointer
)	O
;	O
handicap	int
=	O
place_free_handicap	function
(	O
this_handicap	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
m	int
,	O
n	int
)	O
!=	O
EMPTY	int
)	O
{	O
if	O
(	O
!	O
first	int
)	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
else	O
first	int
=	O
0	int
;	O
gtp_mprintf	function
(	O
"%m"	pointer
,	O
m	int
,	O
n	int
)	O
;	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_set_free_handicap	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
n	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
k	int
;	O
if	O
(	O
stones_on_board	function
(	O
BLACK	int
|	O
WHITE	int
)	O
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"board not empty"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_BOARD	int
*	O
MAX_BOARD	int
;	O
k	int
++	O
)	O
{	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
if	O
(	O
board	pointer
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
!=	O
EMPTY	int
)	O
{	O
clear_board	function
(	O
)	O
;	O
return	O
gtp_failure	function
(	O
"repeated vertex"	pointer
)	O
;	O
}	O
add_stone	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
BLACK	int
)	O
;	O
s	pointer
+=	O
n	int
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%*s"	pointer
)	O
!=	O
EOF	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
k	int
<	O
2	int
)	O
{	O
clear_board	function
(	O
)	O
;	O
return	O
gtp_failure	function
(	O
"invalid handicap"	pointer
)	O
;	O
}	O
handicap	int
=	O
k	int
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_get_handicap	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
handicap	int
)	O
;	O
}	O
static	O
int	O
gtp_loadsgf	function
(	O
char	O
*	O
s	pointer
)	O
{	O
char	O
filename	pointer
[	O
GTP_BUFSIZE	int
]	O
;	O
char	O
untilstring	pointer
[	O
GTP_BUFSIZE	int
]	O
;	O
SGFTree	struct
sgftree	struct
;	O
Gameinfo	struct
gameinfo	pointer
;	O
int	O
nread	int
;	O
int	O
color_to_move	int
;	O
nread	int
=	O
sscanf	function
(	O
s	pointer
,	O
"%s %s"	pointer
,	O
filename	pointer
,	O
untilstring	pointer
)	O
;	O
if	O
(	O
nread	int
<	O
1	int
)	O
return	O
gtp_failure	function
(	O
"missing filename"	pointer
)	O
;	O
sgftree_clear	function
(	O
&	O
sgftree	struct
)	O
;	O
if	O
(	O
!	O
sgftree_readfile	function
(	O
&	O
sgftree	struct
,	O
filename	pointer
)	O
)	O
return	O
gtp_failure	function
(	O
"cannot open or parse '%s'"	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
nread	int
==	O
1	int
)	O
color_to_move	int
=	O
gameinfo_play_sgftree_rot	function
(	O
&	O
gameinfo	pointer
,	O
&	O
sgftree	struct
,	O
NULL	O
,	O
gtp_orientation	int
)	O
;	O
else	O
color_to_move	int
=	O
gameinfo_play_sgftree_rot	function
(	O
&	O
gameinfo	pointer
,	O
&	O
sgftree	struct
,	O
untilstring	pointer
,	O
gtp_orientation	int
)	O
;	O
if	O
(	O
color_to_move	int
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"cannot load '%s'"	pointer
,	O
filename	pointer
)	O
;	O
gtp_internal_set_boardsize	function
(	O
board_size	int
)	O
;	O
reset_engine	function
(	O
)	O
;	O
init_timers	function
(	O
)	O
;	O
sgfFreeNode	function
(	O
sgftree	struct
.	O
root	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_mprintf	function
(	O
"%C"	pointer
,	O
color_to_move	int
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_what_color	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
return	O
gtp_success	function
(	O
color_to_string	function
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_list_stones	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
=	O
EMPTY	int
;	O
int	O
vertexi	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
vertexj	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
vertices	int
=	O
0	int
;	O
if	O
(	O
!	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
color	int
)	O
{	O
vertexi	array
[	O
vertices	int
]	O
=	O
i	int
;	O
vertexj	array
[	O
vertices	int
++	O
]	O
=	O
j	int
;	O
}	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertices	function
(	O
vertices	int
,	O
vertexi	array
,	O
vertexj	array
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_countlib	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
countlib	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_findlib	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	pointer
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
liberties	pointer
=	O
findlib	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertices2	function
(	O
liberties	pointer
,	O
libs	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_accuratelib	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	pointer
;	O
if	O
(	O
!	O
gtp_decode_move	function
(	O
s	pointer
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color or coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must be empty"	pointer
)	O
;	O
liberties	pointer
=	O
accuratelib	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertices2	function
(	O
liberties	pointer
,	O
libs	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_accurate_approxlib	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
int	O
libs	pointer
[	O
MAXLIBS	O
]	O
;	O
int	O
liberties	pointer
;	O
if	O
(	O
!	O
gtp_decode_move	function
(	O
s	pointer
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color or coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must be empty"	pointer
)	O
;	O
liberties	pointer
=	O
accuratelib	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
,	O
MAXLIBS	O
,	O
libs	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertices2	function
(	O
liberties	pointer
,	O
libs	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_is_legal	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_move	function
(	O
s	pointer
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color or coordinate"	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
is_allowed_move	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
)	O
;	O
}	O
static	O
int	O
gtp_all_legal	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
int	O
movei	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
movej	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
moves	array
=	O
0	int
;	O
if	O
(	O
!	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
&&	O
is_allowed_move	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
)	O
{	O
movei	array
[	O
moves	array
]	O
=	O
i	int
;	O
movej	array
[	O
moves	array
++	O
]	O
=	O
j	int
;	O
}	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertices	function
(	O
moves	array
,	O
movei	array
,	O
movej	array
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_captures	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
if	O
(	O
color	int
==	O
BLACK	int
)	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
white_captured	int
)	O
;	O
else	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
black_captured	int
)	O
;	O
}	O
static	O
int	O
gtp_last_move	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
pos	int
;	O
int	O
color	int
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
if	O
(	O
move_history_pointer	int
<=	O
0	int
)	O
return	O
gtp_failure	function
(	O
"no previous move known"	pointer
)	O
;	O
pos	int
=	O
move_history_pos	array
[	O
move_history_pointer	int
-	O
1	int
]	O
;	O
color	int
=	O
move_history_color	array
[	O
move_history_pointer	int
-	O
1	int
]	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_mprintf	function
(	O
"%C %m"	pointer
,	O
color	int
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_move_history	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
k	int
,	O
pos	int
,	O
color	int
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
move_history_pointer	int
>	O
0	int
)	O
for	O
(	O
k	int
=	O
move_history_pointer	int
-	O
1	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
color	int
=	O
move_history_color	array
[	O
k	int
]	O
;	O
pos	int
=	O
move_history_pos	array
[	O
k	int
]	O
;	O
gtp_mprintf	function
(	O
"%C %m\n"	pointer
,	O
color	int
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
}	O
else	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_invariant_hash	function
(	O
char	O
*	O
s	pointer
)	O
{	O
Hash_data	struct
hash	struct
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
hashdata_calc_orientation_invariant	function
(	O
&	O
hash	struct
,	O
board	pointer
,	O
board_ko_pos	int
)	O
;	O
return	O
gtp_success	function
(	O
"%s"	pointer
,	O
hashdata_to_string	function
(	O
&	O
hash	struct
)	O
)	O
;	O
}	O
static	O
int	O
gtp_invariant_hash_for_moves	function
(	O
char	O
*	O
s	pointer
)	O
{	O
Hash_data	struct
hash	struct
;	O
int	O
color	int
;	O
int	O
pos	int
;	O
int	O
move_found	int
=	O
0	int
;	O
if	O
(	O
!	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
"gtp_invariant_hash_for_moves"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
hashdata_calc_orientation_invariant	function
(	O
&	O
hash	struct
,	O
board	pointer
,	O
board_ko_pos	int
)	O
;	O
gtp_mprintf	function
(	O
"%m %s\n"	pointer
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
,	O
hashdata_to_string	function
(	O
&	O
hash	struct
)	O
)	O
;	O
popgo	function
(	O
)	O
;	O
move_found	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
move_found	int
)	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_trymove	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_move	function
(	O
s	pointer
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color or coordinate"	pointer
)	O
;	O
if	O
(	O
!	O
trymove	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
,	O
"gtp_trymove"	pointer
,	O
NO_MOVE	O
)	O
)	O
return	O
gtp_failure	function
(	O
"illegal move"	pointer
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_tryko	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_move	function
(	O
s	pointer
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
||	O
POS	O
(	O
i	int
,	O
j	int
)	O
==	O
PASS_MOVE	int
)	O
return	O
gtp_failure	function
(	O
"invalid color or coordinate"	pointer
)	O
;	O
if	O
(	O
!	O
tryko	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
,	O
"gtp_tryko"	pointer
)	O
)	O
return	O
gtp_failure	function
(	O
"illegal move"	pointer
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_popgo	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
if	O
(	O
stackp	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"Stack empty."	pointer
)	O
;	O
popgo	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_clear_cache	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
clear_persistent_caches	function
(	O
)	O
;	O
reading_cache_clear	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_attack	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
apos	int
;	O
int	O
attack_code	pointer
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
attack_code	pointer
=	O
attack	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
apos	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
attack_code	pointer
)	O
;	O
if	O
(	O
attack_code	pointer
>	O
0	int
)	O
{	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
apos	int
)	O
,	O
J	O
(	O
apos	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_attack_either	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	pointer
,	O
bj	pointer
;	O
int	O
n	int
;	O
int	O
acode	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"string vertex must be empty"	pointer
)	O
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
+	O
n	int
,	O
&	O
bi	pointer
,	O
&	O
bj	pointer
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
bi	pointer
,	O
bj	pointer
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"string vertex must not be empty"	pointer
)	O
;	O
acode	int
=	O
attack_either	function
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
POS	O
(	O
bi	pointer
,	O
bj	pointer
)	O
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
acode	int
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_defend	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
dpos	int
;	O
int	O
defend_code	pointer
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
defend_code	pointer
=	O
find_defense	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
dpos	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
defend_code	pointer
)	O
;	O
if	O
(	O
defend_code	pointer
>	O
0	int
)	O
{	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
dpos	int
)	O
,	O
J	O
(	O
dpos	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_does_attack	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
ti	int
,	O
tj	int
;	O
int	O
attack_code	pointer
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ti	int
,	O
&	O
tj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ti	int
,	O
tj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"move vertex must be empty"	pointer
)	O
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
+	O
n	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"string vertex must not be empty"	pointer
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
attack_code	pointer
=	O
does_attack	function
(	O
POS	O
(	O
ti	int
,	O
tj	int
)	O
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
attack_code	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_does_defend	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
ti	int
,	O
tj	int
;	O
int	O
defense_code	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ti	int
,	O
&	O
tj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ti	int
,	O
tj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"move vertex must be empty"	pointer
)	O
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
+	O
n	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"string vertex must not be empty"	pointer
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
defense_code	int
=	O
does_defend	function
(	O
POS	O
(	O
ti	int
,	O
tj	int
)	O
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
defense_code	int
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_ladder_attack	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
apos	int
;	O
int	O
attack_code	pointer
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
if	O
(	O
countlib	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
!=	O
2	int
)	O
return	O
gtp_failure	function
(	O
"string must have exactly 2 liberties"	pointer
)	O
;	O
attack_code	pointer
=	O
simple_ladder	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
apos	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
attack_code	pointer
)	O
;	O
if	O
(	O
attack_code	pointer
>	O
0	int
)	O
{	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
apos	int
)	O
,	O
J	O
(	O
apos	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_increase_depths	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
increase_depth_values	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_decrease_depths	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
decrease_depth_values	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_owl_attack	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
attack_point	pointer
;	O
int	O
attack_code	pointer
;	O
int	O
result_certain	int
;	O
int	O
kworm	int
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
attack_code	pointer
=	O
owl_attack	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
attack_point	pointer
,	O
&	O
result_certain	int
,	O
&	O
kworm	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
attack_code	pointer
)	O
;	O
if	O
(	O
attack_code	pointer
>	O
0	int
)	O
{	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
attack_point	pointer
)	O
,	O
J	O
(	O
attack_point	pointer
)	O
)	O
;	O
}	O
if	O
(	O
!	O
result_certain	int
&&	O
report_uncertainty	int
)	O
gtp_printf	function
(	O
" uncertain"	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_defend	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
defense_point	pointer
;	O
int	O
defend_code	pointer
;	O
int	O
result_certain	int
;	O
int	O
kworm	int
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
defend_code	pointer
=	O
owl_defend	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
defense_point	pointer
,	O
&	O
result_certain	int
,	O
&	O
kworm	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
defend_code	pointer
)	O
;	O
if	O
(	O
defend_code	pointer
>	O
0	int
)	O
{	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
defense_point	pointer
)	O
,	O
J	O
(	O
defense_point	pointer
)	O
)	O
;	O
}	O
if	O
(	O
!	O
result_certain	int
&&	O
report_uncertainty	int
)	O
gtp_printf	function
(	O
" uncertain"	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_threaten_attack	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
attack_point1	int
;	O
int	O
attack_point2	int
;	O
int	O
attack_code	pointer
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
attack_code	pointer
=	O
owl_threaten_attack	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
attack_point1	int
,	O
&	O
attack_point2	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
attack_code	pointer
)	O
;	O
if	O
(	O
attack_code	pointer
>	O
0	int
)	O
{	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
attack_point1	int
)	O
,	O
J	O
(	O
attack_point1	int
)	O
)	O
;	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
attack_point2	int
)	O
,	O
J	O
(	O
attack_point2	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_threaten_defense	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
defense_point1	int
;	O
int	O
defense_point2	int
;	O
int	O
defend_code	pointer
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
defend_code	pointer
=	O
owl_threaten_defense	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
defense_point1	int
,	O
&	O
defense_point2	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
defend_code	pointer
)	O
;	O
if	O
(	O
defend_code	pointer
>	O
0	int
)	O
{	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
defense_point1	int
)	O
,	O
J	O
(	O
defense_point1	int
)	O
)	O
;	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
defense_point2	int
)	O
,	O
J	O
(	O
defense_point2	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_does_attack	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
ti	int
,	O
tj	int
;	O
int	O
attack_code	pointer
;	O
int	O
kworm	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ti	int
,	O
&	O
tj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ti	int
,	O
tj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"move vertex must be empty"	pointer
)	O
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
+	O
n	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"dragon vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
attack_code	pointer
=	O
owl_does_attack	function
(	O
POS	O
(	O
ti	int
,	O
tj	int
)	O
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
kworm	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
attack_code	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_does_defend	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
ti	int
,	O
tj	int
;	O
int	O
defense_code	int
;	O
int	O
kworm	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ti	int
,	O
&	O
tj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ti	int
,	O
tj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"move vertex must be empty"	pointer
)	O
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
+	O
n	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"dragon vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
defense_code	int
=	O
owl_does_defend	function
(	O
POS	O
(	O
ti	int
,	O
tj	int
)	O
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
kworm	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
defense_code	int
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_connection_defends	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	pointer
,	O
bj	pointer
;	O
int	O
ti	int
,	O
tj	int
;	O
int	O
defense_code	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ti	int
,	O
&	O
tj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ti	int
,	O
tj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"move vertex must be empty"	pointer
)	O
;	O
s	pointer
+=	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
s	pointer
+=	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
bi	pointer
,	O
&	O
bj	pointer
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
||	O
BOARD	O
(	O
bi	pointer
,	O
bj	pointer
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"dragon vertex must not be empty"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
!=	O
BOARD	O
(	O
bi	pointer
,	O
bj	pointer
)	O
)	O
return	O
gtp_failure	function
(	O
"dragon vertices must have the same color"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
defense_code	int
=	O
owl_connection_defends	function
(	O
POS	O
(	O
ti	int
,	O
tj	int
)	O
,	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
POS	O
(	O
bi	pointer
,	O
bj	pointer
)	O
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
defense_code	int
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_defend_both	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	pointer
,	O
bj	pointer
;	O
int	O
n	int
;	O
int	O
dcode	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"string vertex must be empty"	pointer
)	O
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
+	O
n	int
,	O
&	O
bi	pointer
,	O
&	O
bj	pointer
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
bi	pointer
,	O
bj	pointer
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"string vertex must not be empty"	pointer
)	O
;	O
dcode	int
=	O
defend_both	function
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
POS	O
(	O
bi	pointer
,	O
bj	pointer
)	O
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
dcode	int
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_owl_substantial	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
result	int
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
result	int
=	O
owl_substantial	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
result	int
)	O
;	O
}	O
static	O
int	O
gtp_analyze_semeai	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
k	int
;	O
int	O
dragona	int
,	O
dragonb	int
;	O
int	O
resulta	pointer
,	O
resultb	pointer
,	O
move	pointer
,	O
result_certain	int
;	O
k	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
k	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
dragona	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
+	O
k	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
dragonb	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
owl_analyze_semeai	function
(	O
dragona	int
,	O
dragonb	int
,	O
&	O
resulta	pointer
,	O
&	O
resultb	pointer
,	O
&	O
move	pointer
,	O
1	int
,	O
&	O
result_certain	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
resulta	pointer
)	O
;	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_code	function
(	O
resultb	pointer
)	O
;	O
gtp_mprintf	function
(	O
" %m"	pointer
,	O
I	O
(	O
move	pointer
)	O
,	O
J	O
(	O
move	pointer
)	O
)	O
;	O
if	O
(	O
!	O
result_certain	int
&&	O
report_uncertainty	int
)	O
gtp_printf	function
(	O
" uncertain"	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_analyze_semeai_after_move	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
int	O
move	pointer
;	O
int	O
k	int
;	O
int	O
dragona	int
,	O
dragonb	int
;	O
int	O
resulta	pointer
,	O
resultb	pointer
,	O
semeai_move	pointer
,	O
result_certain	int
;	O
k	int
=	O
gtp_decode_move	function
(	O
s	pointer
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
move	pointer
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
k	int
==	O
0	int
||	O
move	pointer
==	O
NO_MOVE	O
)	O
return	O
gtp_failure	function
(	O
"invalid color or coordinate"	pointer
)	O
;	O
if	O
(	O
board	pointer
[	O
move	pointer
]	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"move vertex is not empty"	pointer
)	O
;	O
s	pointer
+=	O
k	int
;	O
k	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
k	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
dragona	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
board	pointer
[	O
dragona	int
]	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"dragon vertex must not be empty"	pointer
)	O
;	O
s	pointer
+=	O
k	int
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
dragonb	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
board	pointer
[	O
dragonb	int
]	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"dragon vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
owl_analyze_semeai_after_move	function
(	O
move	pointer
,	O
color	int
,	O
dragona	int
,	O
dragonb	int
,	O
&	O
resulta	pointer
,	O
&	O
resultb	pointer
,	O
&	O
semeai_move	pointer
,	O
1	int
,	O
&	O
result_certain	int
,	O
0	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
resulta	pointer
)	O
;	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_code	function
(	O
resultb	pointer
)	O
;	O
gtp_mprintf	function
(	O
" %m"	pointer
,	O
I	O
(	O
semeai_move	pointer
)	O
,	O
J	O
(	O
semeai_move	pointer
)	O
)	O
;	O
if	O
(	O
!	O
result_certain	int
&&	O
report_uncertainty	int
)	O
gtp_printf	function
(	O
" uncertain"	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_tactical_analyze_semeai	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
k	int
;	O
int	O
dragona	int
,	O
dragonb	int
;	O
int	O
resulta	pointer
,	O
resultb	pointer
,	O
move	pointer
,	O
result_certain	int
;	O
k	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
k	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
dragona	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
+	O
k	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
dragonb	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
sgf_dumptree	pointer
)	O
reading_cache_clear	function
(	O
)	O
;	O
owl_analyze_semeai	function
(	O
dragona	int
,	O
dragonb	int
,	O
&	O
resulta	pointer
,	O
&	O
resultb	pointer
,	O
&	O
move	pointer
,	O
0	int
,	O
&	O
result_certain	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
resulta	pointer
)	O
;	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_code	function
(	O
resultb	pointer
)	O
;	O
gtp_mprintf	function
(	O
" %m"	pointer
,	O
I	O
(	O
move	pointer
)	O
,	O
J	O
(	O
move	pointer
)	O
)	O
;	O
if	O
(	O
!	O
result_certain	int
&&	O
report_uncertainty	int
)	O
gtp_printf	function
(	O
" uncertain"	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_connect	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	pointer
,	O
bj	pointer
;	O
int	O
connect_move	int
=	O
PASS_MOVE	int
;	O
int	O
result	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
+	O
n	int
,	O
&	O
bi	pointer
,	O
&	O
bj	pointer
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
||	O
BOARD	O
(	O
bi	pointer
,	O
bj	pointer
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
!=	O
BOARD	O
(	O
bi	pointer
,	O
bj	pointer
)	O
)	O
return	O
gtp_failure	function
(	O
"vertices must have same color"	pointer
)	O
;	O
result	int
=	O
string_connect	function
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
POS	O
(	O
bi	pointer
,	O
bj	pointer
)	O
,	O
&	O
connect_move	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
result	int
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
gtp_mprintf	function
(	O
" %m"	pointer
,	O
I	O
(	O
connect_move	int
)	O
,	O
J	O
(	O
connect_move	int
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_disconnect	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	pointer
,	O
bj	pointer
;	O
int	O
disconnect_move	int
=	O
PASS_MOVE	int
;	O
int	O
result	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
+	O
n	int
,	O
&	O
bi	pointer
,	O
&	O
bj	pointer
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
||	O
BOARD	O
(	O
bi	pointer
,	O
bj	pointer
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
!=	O
BOARD	O
(	O
bi	pointer
,	O
bj	pointer
)	O
)	O
return	O
gtp_failure	function
(	O
"vertices must have same color"	pointer
)	O
;	O
result	int
=	O
disconnect	function
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
POS	O
(	O
bi	pointer
,	O
bj	pointer
)	O
,	O
&	O
disconnect_move	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
result	int
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
gtp_mprintf	function
(	O
" %m"	pointer
,	O
I	O
(	O
disconnect_move	int
)	O
,	O
J	O
(	O
disconnect_move	int
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_break_in	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
i	int
,	O
j	int
;	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
;	O
int	O
break_move	int
=	O
PASS_MOVE	int
;	O
int	O
result	int
;	O
int	O
n	int
;	O
int	O
k	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
memset	function
(	O
goal	pointer
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
s	pointer
+=	O
n	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_BOARD	int
*	O
MAX_BOARD	int
;	O
k	int
++	O
)	O
{	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
goal	pointer
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
=	O
1	int
;	O
s	pointer
+=	O
n	int
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%*s"	pointer
)	O
!=	O
EOF	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
result	int
=	O
break_in	function
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
goal	pointer
,	O
&	O
break_move	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
result	int
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
gtp_mprintf	function
(	O
" %m"	pointer
,	O
I	O
(	O
break_move	int
)	O
,	O
J	O
(	O
break_move	int
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_block_off	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
i	int
,	O
j	int
;	O
signed	O
char	O
goal	pointer
[	O
BOARDMAX	O
]	O
;	O
int	O
block_move	int
=	O
PASS_MOVE	int
;	O
int	O
result	int
;	O
int	O
n	int
;	O
int	O
k	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
memset	function
(	O
goal	pointer
,	O
0	int
,	O
BOARDMAX	O
)	O
;	O
s	pointer
+=	O
n	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_BOARD	int
*	O
MAX_BOARD	int
;	O
k	int
++	O
)	O
{	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
goal	pointer
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
=	O
1	int
;	O
s	pointer
+=	O
n	int
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%*s"	pointer
)	O
!=	O
EOF	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
result	int
=	O
block_off	function
(	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
,	O
goal	pointer
,	O
&	O
block_move	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_code	function
(	O
result	int
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
gtp_mprintf	function
(	O
" %m"	pointer
,	O
I	O
(	O
block_move	int
)	O
,	O
J	O
(	O
block_move	int
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_eval_eye	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
m	int
,	O
n	int
;	O
struct	O
eyevalue	struct
value	pointer
;	O
int	O
attack_point	pointer
;	O
int	O
defense_point	pointer
;	O
int	O
pos	int
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
m	int
,	O
&	O
n	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
if	O
(	O
black_eye	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
color	int
==	O
BLACK	int
)	O
{	O
pos	int
=	O
black_eye	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
origin	int
;	O
compute_eyes	function
(	O
pos	int
,	O
&	O
value	pointer
,	O
&	O
attack_point	pointer
,	O
&	O
defense_point	pointer
,	O
black_eye	array
,	O
half_eye	array
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
white_eye	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
color	int
==	O
WHITE	int
)	O
{	O
pos	int
=	O
white_eye	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
origin	int
;	O
compute_eyes	function
(	O
pos	int
,	O
&	O
value	pointer
,	O
&	O
attack_point	pointer
,	O
&	O
defense_point	pointer
,	O
white_eye	array
,	O
half_eye	array
,	O
0	int
)	O
;	O
}	O
else	O
return	O
gtp_success	function
(	O
"-1"	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_printf	function
(	O
"%d %d"	pointer
,	O
min_eyes	function
(	O
&	O
value	pointer
)	O
,	O
max_eyes	function
(	O
&	O
value	pointer
)	O
)	O
;	O
if	O
(	O
eye_move_urgency	function
(	O
&	O
value	pointer
)	O
>	O
0	int
)	O
{	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
attack_point	pointer
)	O
,	O
J	O
(	O
attack_point	pointer
)	O
)	O
;	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
defense_point	pointer
)	O
,	O
J	O
(	O
defense_point	pointer
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_dragon_status	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
str	int
=	O
NO_MOVE	O
;	O
int	O
pos	int
;	O
int	O
empty_response	int
=	O
1	int
;	O
if	O
(	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
{	O
str	int
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
if	O
(	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%*s"	pointer
)	O
!=	O
EOF	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
(	O
pos	int
==	O
str	int
||	O
(	O
str	int
==	O
NO_MOVE	O
&&	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
&&	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
str	int
==	O
NO_MOVE	O
)	O
gtp_mprintf	function
(	O
"%m: "	pointer
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
==	O
ALIVE	int
)	O
gtp_printf	function
(	O
"alive\n"	pointer
)	O
;	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
gtp_printf	function
(	O
"dead\n"	pointer
)	O
;	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
==	O
UNKNOWN	int
)	O
gtp_printf	function
(	O
"unknown\n"	pointer
)	O
;	O
else	O
{	O
assert	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
==	O
CRITICAL	int
)	O
;	O
gtp_mprintf	function
(	O
"critical %m %m\n"	pointer
,	O
I	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
)	O
,	O
J	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_point	int
)	O
,	O
I	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
)	O
,	O
J	O
(	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_point	int
)	O
)	O
;	O
}	O
empty_response	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
empty_response	int
)	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_same_dragon	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
ai	int
,	O
aj	int
;	O
int	O
bi	pointer
,	O
bj	pointer
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
+	O
n	int
,	O
&	O
bi	pointer
,	O
&	O
bj	pointer
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
ai	int
,	O
aj	int
)	O
==	O
EMPTY	int
||	O
BOARD	O
(	O
bi	pointer
,	O
bj	pointer
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
dragon	int
[	O
POS	O
(	O
ai	int
,	O
aj	int
)	O
]	O
.	O
id	int
==	O
dragon	int
[	O
POS	O
(	O
bi	pointer
,	O
bj	pointer
)	O
]	O
.	O
id	int
)	O
;	O
}	O
static	O
int	O
gtp_unconditional_status	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
enum	O
dragon_status	function
status	enum
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_WORMS	int
)	O
;	O
status	enum
=	O
worm	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
.	O
unconditional_status	enum
;	O
if	O
(	O
status	enum
==	O
UNKNOWN	int
)	O
return	O
gtp_success	function
(	O
"undecided"	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%s"	pointer
,	O
status_to_string	function
(	O
status	enum
)	O
)	O
;	O
}	O
static	O
int	O
gtp_combination_attack	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
color	int
;	O
int	O
attack_point	pointer
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_ALL	int
)	O
;	O
if	O
(	O
!	O
atari_atari	function
(	O
color	int
,	O
&	O
attack_point	pointer
,	O
NULL	O
,	O
verbose	int
)	O
)	O
attack_point	pointer
=	O
NO_MOVE	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
attack_point	pointer
)	O
,	O
J	O
(	O
attack_point	pointer
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_combination_defend	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
color	int
;	O
signed	O
char	O
defense_points	array
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
int	O
first	int
=	O
1	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_ALL	int
)	O
;	O
memset	function
(	O
defense_points	array
,	O
0	int
,	O
sizeof	O
(	O
defense_points	array
)	O
)	O
;	O
if	O
(	O
!	O
atari_atari	function
(	O
color	int
,	O
NULL	O
,	O
defense_points	array
,	O
verbose	int
)	O
)	O
return	O
gtp_success	function
(	O
"PASS"	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
defense_points	array
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
!	O
first	int
)	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
else	O
first	int
=	O
0	int
;	O
gtp_print_vertex	function
(	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_aa_confirm_safety	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
color	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
n	int
;	O
int	O
minsize	int
=	O
0	int
;	O
int	O
result	int
;	O
int	O
defense_point	pointer
=	O
NO_MOVE	O
;	O
signed	O
char	O
saved_dragons	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
saved_worms	array
[	O
BOARDMAX	O
]	O
;	O
n	int
=	O
gtp_decode_move	function
(	O
s	pointer
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
||	O
POS	O
(	O
i	int
,	O
j	int
)	O
==	O
NO_MOVE	O
)	O
return	O
gtp_failure	function
(	O
"invalid color or coordinate"	pointer
)	O
;	O
sscanf	function
(	O
s	pointer
+	O
n	int
,	O
"%d"	pointer
,	O
&	O
minsize	int
)	O
;	O
genmove	function
(	O
color	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
get_saved_dragons	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
saved_dragons	array
)	O
;	O
get_saved_worms	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
saved_worms	array
)	O
;	O
result	int
=	O
atari_atari_confirm_safety	function
(	O
color	int
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
&	O
defense_point	pointer
,	O
minsize	int
,	O
saved_dragons	array
,	O
saved_worms	array
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_mprintf	function
(	O
"%d"	pointer
,	O
result	int
)	O
;	O
if	O
(	O
result	int
==	O
0	int
)	O
gtp_mprintf	function
(	O
" %m"	pointer
,	O
I	O
(	O
defense_point	pointer
)	O
,	O
J	O
(	O
defense_point	pointer
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_genmove_black	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
move	pointer
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"genmove cannot be called when stackp > 0"	pointer
)	O
;	O
move	pointer
=	O
genmove	function
(	O
BLACK	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
gnugo_play_move	function
(	O
move	pointer
,	O
BLACK	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
move	pointer
)	O
,	O
J	O
(	O
move	pointer
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_genmove_white	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
move	pointer
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"genmove cannot be called when stackp > 0"	pointer
)	O
;	O
move	pointer
=	O
genmove	function
(	O
WHITE	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
gnugo_play_move	function
(	O
move	pointer
,	O
WHITE	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
move	pointer
)	O
,	O
J	O
(	O
move	pointer
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_genmove	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
move	pointer
;	O
int	O
resign	pointer
;	O
int	O
color	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"genmove cannot be called when stackp > 0"	pointer
)	O
;	O
adjust_level_offset	function
(	O
color	int
)	O
;	O
move	pointer
=	O
genmove	function
(	O
color	int
,	O
NULL	O
,	O
&	O
resign	pointer
)	O
;	O
if	O
(	O
resign	pointer
)	O
return	O
gtp_success	function
(	O
"resign"	pointer
)	O
;	O
gnugo_play_move	function
(	O
move	pointer
,	O
color	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
move	pointer
)	O
,	O
J	O
(	O
move	pointer
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_reg_genmove	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
move	pointer
;	O
int	O
color	int
;	O
int	O
n	int
;	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	function
(	O
)	O
;	O
n	int
=	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"genmove cannot be called when stackp > 0"	pointer
)	O
;	O
set_random_seed	function
(	O
0	int
)	O
;	O
move	pointer
=	O
genmove_conservative	function
(	O
color	int
,	O
NULL	O
)	O
;	O
set_random_seed	function
(	O
saved_random_seed	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
move	pointer
)	O
,	O
J	O
(	O
move	pointer
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_gg_genmove	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
move	pointer
;	O
int	O
color	int
;	O
int	O
n	int
;	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	function
(	O
)	O
;	O
unsigned	O
int	O
seed	int
;	O
n	int
=	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"genmove cannot be called when stackp > 0"	pointer
)	O
;	O
seed	int
=	O
0	int
;	O
sscanf	function
(	O
s	pointer
+	O
n	int
,	O
"%u"	pointer
,	O
&	O
seed	int
)	O
;	O
set_random_seed	function
(	O
seed	int
)	O
;	O
move	pointer
=	O
genmove_conservative	function
(	O
color	int
,	O
NULL	O
)	O
;	O
set_random_seed	function
(	O
saved_random_seed	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
move	pointer
)	O
,	O
J	O
(	O
move	pointer
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_restricted_genmove	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
move	pointer
;	O
int	O
i	int
,	O
j	int
;	O
int	O
color	int
;	O
int	O
n	int
;	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	function
(	O
)	O
;	O
int	O
allowed_moves	array
[	O
BOARDMAX	O
]	O
;	O
int	O
number_allowed_moves	int
=	O
0	int
;	O
memset	function
(	O
allowed_moves	array
,	O
0	int
,	O
sizeof	O
(	O
allowed_moves	array
)	O
)	O
;	O
n	int
=	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
s	pointer
+=	O
n	int
;	O
while	O
(	O
1	int
)	O
{	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
>	O
0	int
)	O
{	O
allowed_moves	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
=	O
1	int
;	O
number_allowed_moves	int
++	O
;	O
s	pointer
+=	O
n	int
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%*s"	pointer
)	O
!=	O
EOF	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
number_allowed_moves	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"no allowed vertex"	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"genmove cannot be called when stackp > 0"	pointer
)	O
;	O
set_random_seed	function
(	O
0	int
)	O
;	O
move	pointer
=	O
genmove_restricted	function
(	O
color	int
,	O
allowed_moves	array
)	O
;	O
set_random_seed	function
(	O
saved_random_seed	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
move	pointer
)	O
,	O
J	O
(	O
move	pointer
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_kgs_genmove_cleanup	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
move	pointer
;	O
int	O
color	int
;	O
int	O
n	int
;	O
int	O
save_capture_all_dead	int
=	O
capture_all_dead	int
;	O
n	int
=	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"kgs-genmove_cleanup cannot be called when stackp > 0"	pointer
)	O
;	O
capture_all_dead	int
=	O
1	int
;	O
adjust_level_offset	function
(	O
color	int
)	O
;	O
move	pointer
=	O
genmove	function
(	O
color	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
capture_all_dead	int
=	O
save_capture_all_dead	int
;	O
gnugo_play_move	function
(	O
move	pointer
,	O
color	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_print_vertex	function
(	O
I	O
(	O
move	pointer
)	O
,	O
J	O
(	O
move	pointer
)	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_move_reasons	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be occupied"	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
list_move_reasons	function
(	O
gtp_output_file	pointer
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
==	O
0	int
)	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_all_move_values	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
print_all_move_values	function
(	O
gtp_output_file	pointer
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_top_moves	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
k	int
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
;	O
k	int
++	O
)	O
if	O
(	O
best_move_values	array
[	O
k	int
]	O
>	O
0.0	int
)	O
{	O
gtp_print_vertex	function
(	O
I	O
(	O
best_moves	array
[	O
k	int
]	O
)	O
,	O
J	O
(	O
best_moves	array
[	O
k	int
]	O
)	O
)	O
;	O
gtp_printf	function
(	O
" %.2f "	pointer
,	O
best_move_values	array
[	O
k	int
]	O
)	O
;	O
}	O
gtp_printf	function
(	O
"\n\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_top_moves_white	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
k	int
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
genmove	function
(	O
WHITE	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
;	O
k	int
++	O
)	O
if	O
(	O
best_move_values	array
[	O
k	int
]	O
>	O
0.0	int
)	O
{	O
gtp_print_vertex	function
(	O
I	O
(	O
best_moves	array
[	O
k	int
]	O
)	O
,	O
J	O
(	O
best_moves	array
[	O
k	int
]	O
)	O
)	O
;	O
gtp_printf	function
(	O
" %.2f "	pointer
,	O
best_move_values	array
[	O
k	int
]	O
)	O
;	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_top_moves_black	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
k	int
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
genmove	function
(	O
BLACK	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
;	O
k	int
++	O
)	O
if	O
(	O
best_move_values	array
[	O
k	int
]	O
>	O
0.0	int
)	O
{	O
gtp_print_vertex	function
(	O
I	O
(	O
best_moves	array
[	O
k	int
]	O
)	O
,	O
J	O
(	O
best_moves	array
[	O
k	int
]	O
)	O
)	O
;	O
gtp_printf	function
(	O
" %.2f "	pointer
,	O
best_move_values	array
[	O
k	int
]	O
)	O
;	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_set_level	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
new_level	int
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
&	O
new_level	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	function
(	O
"level not an integer"	pointer
)	O
;	O
set_level	function
(	O
new_level	int
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_undo	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
||	O
!	O
undo_move	function
(	O
1	int
)	O
)	O
return	O
gtp_failure	function
(	O
"cannot undo"	pointer
)	O
;	O
reset_engine	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_gg_undo	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
number_moves	int
=	O
1	int
;	O
sscanf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
&	O
number_moves	int
)	O
;	O
if	O
(	O
number_moves	int
<	O
0	int
)	O
return	O
gtp_failure	function
(	O
"can't undo a negative number of moves"	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
||	O
!	O
undo_move	function
(	O
number_moves	int
)	O
)	O
return	O
gtp_failure	function
(	O
"cannot undo"	pointer
)	O
;	O
reset_engine	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_time_settings	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
main_time	int
,	O
byoyomi_time	int
,	O
byoyomi_stones	int
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%d %d %d"	pointer
,	O
&	O
main_time	int
,	O
&	O
byoyomi_time	int
,	O
&	O
byoyomi_stones	int
)	O
<	O
3	int
)	O
return	O
gtp_failure	function
(	O
"not three integers"	pointer
)	O
;	O
clock_settings	function
(	O
main_time	int
,	O
byoyomi_time	int
,	O
byoyomi_stones	int
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_time_left	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
color	int
;	O
int	O
time	function
;	O
int	O
stones	pointer
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
;	O
if	O
(	O
!	O
n	int
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
+	O
n	int
,	O
"%d %d"	pointer
,	O
&	O
time	function
,	O
&	O
stones	pointer
)	O
<	O
2	int
)	O
return	O
gtp_failure	function
(	O
"time and stones not two integers"	pointer
)	O
;	O
update_time_left	function
(	O
color	int
,	O
time	function
,	O
stones	pointer
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
float	O
final_score	float
;	O
static	O
enum	O
dragon_status	function
final_status	array
[	O
MAX_BOARD	int
]	O
[	O
MAX_BOARD	int
]	O
;	O
static	O
enum	O
dragon_status	function
status_numbers	array
[	O
6	int
]	O
=	O
{	O
ALIVE	int
,	O
DEAD	int
,	O
ALIVE_IN_SEKI	int
,	O
WHITE_TERRITORY	int
,	O
BLACK_TERRITORY	int
,	O
DAME	int
}	O
;	O
static	O
const	O
char	O
*	O
status_names	array
[	O
6	int
]	O
=	O
{	O
"alive"	pointer
,	O
"dead"	pointer
,	O
"seki"	pointer
,	O
"white_territory"	pointer
,	O
"black_territory"	pointer
,	O
"dame"	pointer
}	O
;	O
static	O
void	O
finish_and_score_game	function
(	O
int	O
seed	int
)	O
{	O
int	O
move	pointer
;	O
int	O
i	int
,	O
j	int
;	O
int	O
next	pointer
;	O
int	O
pass	int
=	O
0	int
;	O
int	O
moves	array
=	O
0	int
;	O
int	O
saved_board	array
[	O
MAX_BOARD	int
]	O
[	O
MAX_BOARD	int
]	O
;	O
struct	O
board_state	struct
saved_pos	struct
;	O
static	O
int	O
current_board	array
[	O
MAX_BOARD	int
]	O
[	O
MAX_BOARD	int
]	O
;	O
static	O
int	O
current_seed	int
=	O
-	O
1	int
;	O
int	O
cached_board	int
=	O
1	int
;	O
if	O
(	O
current_seed	int
!=	O
seed	int
)	O
{	O
current_seed	int
=	O
seed	int
;	O
cached_board	int
=	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
!=	O
current_board	array
[	O
i	int
]	O
[	O
j	int
]	O
)	O
{	O
current_board	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
;	O
cached_board	int
=	O
0	int
;	O
}	O
if	O
(	O
cached_board	int
)	O
return	O
;	O
doing_scoring	int
=	O
1	int
;	O
store_board	function
(	O
&	O
saved_pos	struct
)	O
;	O
if	O
(	O
get_last_player	function
(	O
)	O
==	O
EMPTY	int
)	O
next	pointer
=	O
BLACK	int
;	O
else	O
next	pointer
=	O
OTHER_COLOR	O
(	O
get_last_player	function
(	O
)	O
)	O
;	O
do	O
{	O
move	pointer
=	O
genmove_conservative	function
(	O
next	pointer
,	O
NULL	O
)	O
;	O
gnugo_play_move	function
(	O
move	pointer
,	O
next	pointer
)	O
;	O
if	O
(	O
move	pointer
!=	O
PASS_MOVE	int
)	O
{	O
pass	int
=	O
0	int
;	O
moves	array
++	O
;	O
}	O
else	O
pass	int
++	O
;	O
next	pointer
=	O
OTHER_COLOR	O
(	O
next	pointer
)	O
;	O
}	O
while	O
(	O
pass	int
<	O
2	int
&&	O
moves	array
<	O
board_size	int
*	O
board_size	int
)	O
;	O
final_score	float
=	O
aftermath_compute_score	function
(	O
next	pointer
,	O
NULL	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
aftermath_final_status	function
(	O
next	pointer
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
saved_board	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
;	O
}	O
restore_board	function
(	O
&	O
saved_pos	struct
)	O
;	O
doing_scoring	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
saved_board	array
[	O
i	int
]	O
[	O
j	int
]	O
)	O
continue	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
==	O
ALIVE	int
||	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
==	O
ALIVE_IN_SEKI	int
)	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
DAME	int
;	O
else	O
if	O
(	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
==	O
DEAD	int
)	O
{	O
if	O
(	O
saved_board	array
[	O
i	int
]	O
[	O
j	int
]	O
==	O
BLACK	int
)	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
WHITE_TERRITORY	int
;	O
else	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
BLACK_TERRITORY	int
;	O
}	O
}	O
else	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
BLACK	int
)	O
{	O
if	O
(	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
==	O
WHITE_TERRITORY	int
)	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
DEAD	int
;	O
else	O
if	O
(	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
==	O
DAME	int
)	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
ALIVE_IN_SEKI	int
;	O
else	O
if	O
(	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
==	O
BLACK_TERRITORY	int
)	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
ALIVE	int
;	O
else	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
DEAD	int
;	O
}	O
else	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
WHITE	int
)	O
{	O
if	O
(	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
==	O
BLACK_TERRITORY	int
)	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
DEAD	int
;	O
else	O
if	O
(	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
==	O
DAME	int
)	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
ALIVE_IN_SEKI	int
;	O
else	O
if	O
(	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
==	O
WHITE_TERRITORY	int
)	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
ALIVE	int
;	O
else	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
=	O
DEAD	int
;	O
}	O
}	O
}	O
static	O
int	O
gtp_final_score	function
(	O
char	O
*	O
s	pointer
)	O
{	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	function
(	O
)	O
;	O
int	O
seed	int
;	O
seed	int
=	O
0	int
;	O
sscanf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
&	O
seed	int
)	O
;	O
set_random_seed	function
(	O
seed	int
)	O
;	O
finish_and_score_game	function
(	O
seed	int
)	O
;	O
set_random_seed	function
(	O
saved_random_seed	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
final_score	float
>	O
0.0	int
)	O
gtp_printf	function
(	O
"W+%3.1f"	pointer
,	O
final_score	float
)	O
;	O
else	O
if	O
(	O
final_score	float
<	O
0.0	int
)	O
gtp_printf	function
(	O
"B+%3.1f"	pointer
,	O
-	O
final_score	float
)	O
;	O
else	O
gtp_printf	function
(	O
"0"	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_final_status	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
seed	int
;	O
int	O
n	int
;	O
int	O
ai	int
,	O
aj	int
;	O
int	O
k	int
;	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	function
(	O
)	O
;	O
const	O
char	O
*	O
result	int
=	O
NULL	O
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
ai	int
,	O
&	O
aj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
seed	int
=	O
0	int
;	O
sscanf	function
(	O
s	pointer
+	O
n	int
,	O
"%d"	pointer
,	O
&	O
seed	int
)	O
;	O
set_random_seed	function
(	O
seed	int
)	O
;	O
finish_and_score_game	function
(	O
seed	int
)	O
;	O
set_random_seed	function
(	O
saved_random_seed	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
6	int
;	O
k	int
++	O
)	O
if	O
(	O
final_status	array
[	O
ai	int
]	O
[	O
aj	int
]	O
==	O
status_numbers	array
[	O
k	int
]	O
)	O
{	O
result	int
=	O
status_names	array
[	O
k	int
]	O
;	O
break	O
;	O
}	O
assert	O
(	O
result	int
!=	O
NULL	O
)	O
;	O
return	O
gtp_success	function
(	O
result	int
)	O
;	O
}	O
static	O
int	O
gtp_final_status_list	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
seed	int
;	O
int	O
n	int
;	O
int	O
i	int
,	O
j	int
;	O
enum	O
dragon_status	function
status	enum
=	O
UNKNOWN	int
;	O
int	O
k	int
;	O
char	O
status_string	array
[	O
GTP_BUFSIZE	int
]	O
;	O
int	O
first	int
;	O
unsigned	O
int	O
saved_random_seed	int
=	O
get_random_seed	function
(	O
)	O
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%s %n"	pointer
,	O
status_string	array
,	O
&	O
n	int
)	O
!=	O
1	int
)	O
return	O
gtp_failure	function
(	O
"missing status"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
6	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
status_string	array
,	O
status_names	array
[	O
k	int
]	O
)	O
==	O
0	int
)	O
status	enum
=	O
status_numbers	array
[	O
k	int
]	O
;	O
}	O
if	O
(	O
status	enum
==	O
UNKNOWN	int
)	O
return	O
gtp_failure	function
(	O
"invalid status"	pointer
)	O
;	O
seed	int
=	O
0	int
;	O
sscanf	function
(	O
s	pointer
+	O
n	int
,	O
"%d"	pointer
,	O
&	O
seed	int
)	O
;	O
set_random_seed	function
(	O
seed	int
)	O
;	O
finish_and_score_game	function
(	O
seed	int
)	O
;	O
set_random_seed	function
(	O
saved_random_seed	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
first	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
final_status	array
[	O
i	int
]	O
[	O
j	int
]	O
!=	O
status	enum
)	O
continue	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
!	O
first	int
)	O
gtp_printf	function
(	O
" "	pointer
)	O
;	O
else	O
first	int
=	O
0	int
;	O
gtp_print_vertex	function
(	O
i	int
,	O
j	int
)	O
;	O
}	O
else	O
{	O
int	O
num_stones	int
;	O
int	O
stones	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
if	O
(	O
find_origin	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
!=	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
first	int
)	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
else	O
first	int
=	O
0	int
;	O
num_stones	int
=	O
findstones	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
board_size	int
*	O
board_size	int
,	O
stones	pointer
)	O
;	O
gtp_print_vertices2	function
(	O
num_stones	int
,	O
stones	pointer
)	O
;	O
}	O
}	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_estimate_score	function
(	O
char	O
*	O
s	pointer
)	O
{	O
float	O
score	float
;	O
float	O
upper_bound	float
,	O
lower_bound	float
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
score	float
=	O
gnugo_estimate_score	function
(	O
&	O
upper_bound	float
,	O
&	O
lower_bound	float
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
score	float
>=	O
0.0	int
)	O
gtp_printf	function
(	O
"W+%3.1f (upper bound: %3.1f, lower: %3.1f)"	pointer
,	O
score	float
,	O
upper_bound	float
,	O
lower_bound	float
)	O
;	O
else	O
if	O
(	O
score	float
<	O
0.0	int
)	O
gtp_printf	function
(	O
"B+%3.1f (upper bound: %3.1f, lower: %3.1f)"	pointer
,	O
-	O
score	float
,	O
upper_bound	float
,	O
lower_bound	float
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_experimental_score	function
(	O
char	O
*	O
s	pointer
)	O
{	O
float	O
upper_bound	float
,	O
lower_bound	float
,	O
score	float
;	O
int	O
color	int
;	O
if	O
(	O
!	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
||	O
(	O
color	int
!=	O
BLACK	int
&&	O
color	int
!=	O
WHITE	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
genmove_conservative	function
(	O
color	int
,	O
NULL	O
)	O
;	O
gnugo_estimate_score	function
(	O
&	O
upper_bound	float
,	O
&	O
lower_bound	float
)	O
;	O
if	O
(	O
debug	int
&	O
DEBUG_SCORING	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"upper = %3.1f, lower = %3.1f, best = %3.1f\n"	pointer
,	O
upper_bound	float
,	O
lower_bound	float
,	O
best_move_values	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
score	float
=	O
lower_bound	float
+	O
best_move_values	array
[	O
0	int
]	O
;	O
else	O
score	float
=	O
upper_bound	float
-	O
best_move_values	array
[	O
0	int
]	O
;	O
return	O
gtp_success	function
(	O
"%3.1f"	pointer
,	O
score	float
)	O
;	O
}	O
static	O
int	O
gtp_reset_life_node_counter	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_get_life_node_counter	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"0"	pointer
)	O
;	O
}	O
static	O
int	O
gtp_reset_owl_node_counter	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
reset_owl_node_counter	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_get_owl_node_counter	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
nodes	int
=	O
get_owl_node_counter	function
(	O
)	O
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
nodes	int
)	O
;	O
}	O
static	O
int	O
gtp_reset_reading_node_counter	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
reset_reading_node_counter	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_get_reading_node_counter	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
nodes	int
=	O
get_reading_node_counter	function
(	O
)	O
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
nodes	int
)	O
;	O
}	O
static	O
int	O
gtp_reset_trymove_counter	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
reset_trymove_counter	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_get_trymove_counter	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
nodes	int
=	O
get_trymove_counter	function
(	O
)	O
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
nodes	int
)	O
;	O
}	O
static	O
int	O
gtp_reset_connection_node_counter	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
reset_connection_node_counter	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_get_connection_node_counter	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
nodes	int
=	O
get_connection_node_counter	function
(	O
)	O
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
nodes	int
)	O
;	O
}	O
static	O
int	O
gtp_test_eyeshape	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
n	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
eye_vertices	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
eyesize	int
=	O
0	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
while	O
(	O
n	int
>	O
0	int
)	O
{	O
eye_vertices	pointer
[	O
eyesize	int
]	O
=	O
POS	O
(	O
i	int
,	O
j	int
)	O
;	O
eyesize	int
++	O
;	O
s	pointer
+=	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
}	O
if	O
(	O
eyesize	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
test_eyeshape	function
(	O
eyesize	int
,	O
eye_vertices	pointer
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_analyze_eyegraph	function
(	O
char	O
*	O
s	pointer
)	O
{	O
struct	O
eyevalue	struct
value	pointer
;	O
char	O
analyzed_eyegraph	pointer
[	O
1024	int
]	O
;	O
int	O
result	int
=	O
analyze_eyegraph	function
(	O
s	pointer
,	O
&	O
value	pointer
,	O
analyzed_eyegraph	pointer
)	O
;	O
if	O
(	O
result	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"failed to analyze"	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%s\n%s"	pointer
,	O
eyevalue_to_string	function
(	O
&	O
value	pointer
)	O
,	O
analyzed_eyegraph	pointer
)	O
;	O
}	O
static	O
int	O
gtp_cputime	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%.3f"	pointer
,	O
gg_cputime	function
(	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_showboard	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
simple_showboard	function
(	O
gtp_output_file	pointer
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
static	O
int	O
gtp_dump_stack	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
dump_stack	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
has_prefix	function
(	O
const	O
char	O
*	O
s	pointer
,	O
const	O
char	O
*	O
prefix	pointer
)	O
{	O
return	O
strncmp	function
(	O
s	pointer
,	O
prefix	pointer
,	O
strlen	function
(	O
prefix	pointer
)	O
)	O
==	O
0	int
;	O
}	O
static	O
int	O
print_influence_data	function
(	O
struct	O
influence_data	O
*	O
q	pointer
,	O
char	O
*	O
what_data	pointer
)	O
{	O
float	O
white_influence	array
[	O
BOARDMAX	O
]	O
;	O
float	O
black_influence	array
[	O
BOARDMAX	O
]	O
;	O
float	O
white_strength	array
[	O
BOARDMAX	O
]	O
;	O
float	O
black_strength	array
[	O
BOARDMAX	O
]	O
;	O
float	O
white_attenuation	array
[	O
BOARDMAX	O
]	O
;	O
float	O
black_attenuation	array
[	O
BOARDMAX	O
]	O
;	O
float	O
white_permeability	array
[	O
BOARDMAX	O
]	O
;	O
float	O
black_permeability	array
[	O
BOARDMAX	O
]	O
;	O
float	O
territory_value	array
[	O
BOARDMAX	O
]	O
;	O
int	O
influence_regions	array
[	O
BOARDMAX	O
]	O
;	O
int	O
non_territory	array
[	O
BOARDMAX	O
]	O
;	O
int	O
m	int
,	O
n	int
;	O
float	O
*	O
float_pointer	pointer
=	O
NULL	O
;	O
int	O
*	O
int_pointer	pointer
=	O
NULL	O
;	O
while	O
(	O
*	O
what_data	pointer
==	O
' '	O
)	O
what_data	pointer
++	O
;	O
get_influence	function
(	O
q	pointer
,	O
white_influence	array
,	O
black_influence	array
,	O
white_strength	array
,	O
black_strength	array
,	O
white_attenuation	array
,	O
black_attenuation	array
,	O
white_permeability	array
,	O
black_permeability	array
,	O
territory_value	array
,	O
influence_regions	array
,	O
non_territory	array
)	O
;	O
if	O
(	O
has_prefix	function
(	O
what_data	pointer
,	O
"white_influence"	pointer
)	O
)	O
float_pointer	pointer
=	O
white_influence	array
;	O
else	O
if	O
(	O
has_prefix	function
(	O
what_data	pointer
,	O
"black_influence"	pointer
)	O
)	O
float_pointer	pointer
=	O
black_influence	array
;	O
else	O
if	O
(	O
has_prefix	function
(	O
what_data	pointer
,	O
"white_strength"	pointer
)	O
)	O
float_pointer	pointer
=	O
white_strength	array
;	O
else	O
if	O
(	O
has_prefix	function
(	O
what_data	pointer
,	O
"black_strength"	pointer
)	O
)	O
float_pointer	pointer
=	O
black_strength	array
;	O
else	O
if	O
(	O
has_prefix	function
(	O
what_data	pointer
,	O
"white_attenuation"	pointer
)	O
)	O
float_pointer	pointer
=	O
white_attenuation	array
;	O
else	O
if	O
(	O
has_prefix	function
(	O
what_data	pointer
,	O
"black_attenuation"	pointer
)	O
)	O
float_pointer	pointer
=	O
black_attenuation	array
;	O
else	O
if	O
(	O
has_prefix	function
(	O
what_data	pointer
,	O
"white_permeability"	pointer
)	O
)	O
float_pointer	pointer
=	O
white_permeability	array
;	O
else	O
if	O
(	O
has_prefix	function
(	O
what_data	pointer
,	O
"black_permeability"	pointer
)	O
)	O
float_pointer	pointer
=	O
black_permeability	array
;	O
else	O
if	O
(	O
has_prefix	function
(	O
what_data	pointer
,	O
"territory_value"	pointer
)	O
)	O
float_pointer	pointer
=	O
territory_value	array
;	O
else	O
if	O
(	O
has_prefix	function
(	O
what_data	pointer
,	O
"influence_regions"	pointer
)	O
)	O
int_pointer	pointer
=	O
influence_regions	array
;	O
else	O
if	O
(	O
has_prefix	function
(	O
what_data	pointer
,	O
"non_territory"	pointer
)	O
)	O
int_pointer	pointer
=	O
non_territory	array
;	O
else	O
return	O
gtp_failure	function
(	O
"unknown influence data"	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
{	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
{	O
if	O
(	O
float_pointer	pointer
)	O
gtp_printf	function
(	O
"%6.2f "	pointer
,	O
float_pointer	pointer
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
;	O
else	O
gtp_printf	function
(	O
"%2d "	pointer
,	O
int_pointer	pointer
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
)	O
;	O
}	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_initial_influence	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
color	int
;	O
struct	O
influence_data	O
*	O
q	pointer
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid color"	pointer
)	O
;	O
q	pointer
=	O
INITIAL_INFLUENCE	O
(	O
color	int
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_ALL	int
)	O
;	O
return	O
print_influence_data	function
(	O
q	pointer
,	O
s	pointer
+	O
n	int
)	O
;	O
}	O
static	O
int	O
gtp_move_influence	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
color	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_move	function
(	O
s	pointer
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid move"	pointer
)	O
;	O
prepare_move_influence_debugging	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
;	O
return	O
print_influence_data	function
(	O
&	O
move_influence	struct
,	O
s	pointer
+	O
n	int
)	O
;	O
}	O
static	O
int	O
gtp_move_probabilities	function
(	O
char	O
*	O
s	pointer
)	O
{	O
float	O
probabilities	array
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
int	O
any_moves_printed	int
=	O
0	int
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
compute_move_probabilities	function
(	O
probabilities	array
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
probabilities	array
[	O
pos	int
]	O
!=	O
0.0	int
)	O
{	O
gtp_mprintf	function
(	O
"%m "	pointer
,	O
I	O
(	O
pos	int
)	O
,	O
J	O
(	O
pos	int
)	O
)	O
;	O
gtp_printf	function
(	O
"%.4f\n"	pointer
,	O
probabilities	array
[	O
pos	int
]	O
)	O
;	O
any_moves_printed	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
any_moves_printed	int
)	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_move_uncertainty	function
(	O
char	O
*	O
s	pointer
)	O
{	O
float	O
probabilities	array
[	O
BOARDMAX	O
]	O
;	O
int	O
pos	int
;	O
double	O
uncertainty	double
=	O
0.0	int
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
compute_move_probabilities	function
(	O
probabilities	array
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
probabilities	array
[	O
pos	int
]	O
>	O
0.0	int
)	O
{	O
uncertainty	double
+=	O
-	O
1	int
*	O
(	O
(	O
double	O
)	O
probabilities	array
[	O
pos	int
]	O
)	O
*	O
log	function
(	O
(	O
double	O
)	O
probabilities	array
[	O
pos	int
]	O
)	O
/	O
log	function
(	O
2.0	int
)	O
;	O
}	O
}	O
gtp_printf	function
(	O
"%.4f\n\n"	pointer
,	O
uncertainty	double
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_followup_influence	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
color	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_move	function
(	O
s	pointer
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid move"	pointer
)	O
;	O
prepare_move_influence_debugging	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
color	int
)	O
;	O
return	O
print_influence_data	function
(	O
&	O
followup_influence	struct
,	O
s	pointer
+	O
n	int
)	O
;	O
}	O
static	O
int	O
gtp_worm_data	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
int	O
m	int
,	O
n	int
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%*c"	pointer
)	O
>=	O
0	int
&&	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color or coordinate"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_WORMS	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
i	int
==	O
-	O
1	int
||	O
(	O
m	int
==	O
i	int
&&	O
n	int
==	O
j	int
)	O
)	O
{	O
struct	O
worm_data	struct
*	O
w	int
=	O
&	O
worm	array
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
;	O
gtp_print_vertex	function
(	O
m	int
,	O
n	int
)	O
;	O
gtp_printf	function
(	O
":\n"	pointer
)	O
;	O
gtp_mprintf	function
(	O
"origin               %m\n"	pointer
,	O
I	O
(	O
w	int
->	O
origin	int
)	O
,	O
J	O
(	O
w	int
->	O
origin	int
)	O
)	O
;	O
gtp_mprintf	function
(	O
"color                %C\n"	pointer
,	O
w	int
->	O
color	int
)	O
;	O
gtp_printf	function
(	O
"size                 %d\n"	pointer
,	O
w	int
->	O
size	int
)	O
;	O
gtp_printf	function
(	O
"effective_size       %.2f\n"	pointer
,	O
w	int
->	O
effective_size	float
)	O
;	O
gtp_printf	function
(	O
"liberties            %d\n"	pointer
,	O
w	int
->	O
liberties	pointer
)	O
;	O
gtp_printf	function
(	O
"liberties2           %d\n"	pointer
,	O
w	int
->	O
liberties2	int
)	O
;	O
gtp_printf	function
(	O
"liberties3           %d\n"	pointer
,	O
w	int
->	O
liberties3	int
)	O
;	O
gtp_printf	function
(	O
"liberties4           %d\n"	pointer
,	O
w	int
->	O
liberties4	int
)	O
;	O
gtp_printf	function
(	O
"attack_code          %d\n"	pointer
,	O
w	int
->	O
attack_codes	array
[	O
0	int
]	O
)	O
;	O
gtp_mprintf	function
(	O
"attack_point         %m\n"	pointer
,	O
I	O
(	O
w	int
->	O
attack_points	array
[	O
0	int
]	O
)	O
,	O
J	O
(	O
w	int
->	O
attack_points	array
[	O
0	int
]	O
)	O
)	O
;	O
gtp_printf	function
(	O
"defense_code         %d\n"	pointer
,	O
w	int
->	O
defense_codes	array
[	O
0	int
]	O
)	O
;	O
gtp_mprintf	function
(	O
"defense_point        %m\n"	pointer
,	O
I	O
(	O
w	int
->	O
defense_points	array
[	O
0	int
]	O
)	O
,	O
J	O
(	O
w	int
->	O
defense_points	array
[	O
0	int
]	O
)	O
)	O
;	O
gtp_mprintf	function
(	O
"lunch                %m\n"	pointer
,	O
I	O
(	O
w	int
->	O
lunch	int
)	O
,	O
J	O
(	O
w	int
->	O
lunch	int
)	O
)	O
;	O
gtp_printf	function
(	O
"cutstone             %d\n"	pointer
,	O
w	int
->	O
cutstone	int
)	O
;	O
gtp_printf	function
(	O
"cutstone2            %d\n"	pointer
,	O
w	int
->	O
cutstone2	int
)	O
;	O
gtp_printf	function
(	O
"genus                %d\n"	pointer
,	O
w	int
->	O
genus	pointer
)	O
;	O
gtp_printf	function
(	O
"inessential          %d\n"	pointer
,	O
w	int
->	O
inessential	int
)	O
;	O
gtp_printf	function
(	O
"invincible           %d\n"	pointer
,	O
w	int
->	O
invincible	int
)	O
;	O
gtp_printf	function
(	O
"unconditional_status %s\n"	pointer
,	O
status_to_string	function
(	O
w	int
->	O
unconditional_status	enum
)	O
)	O
;	O
}	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_worm_stones	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
int	O
color	int
=	O
EMPTY	int
;	O
int	O
m	int
,	O
n	int
;	O
int	O
u	int
,	O
v	int
;	O
int	O
board_empty	int
=	O
1	int
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%*c"	pointer
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
&&	O
!	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
}	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"worm_stones called on an empty vertex"	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
u	int
=	O
0	int
;	O
u	int
<	O
board_size	int
;	O
u	int
++	O
)	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
board_size	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
BOARD	O
(	O
u	int
,	O
v	int
)	O
==	O
EMPTY	int
||	O
(	O
color	int
!=	O
EMPTY	int
&&	O
BOARD	O
(	O
u	int
,	O
v	int
)	O
!=	O
color	int
)	O
)	O
continue	O
;	O
board_empty	int
=	O
0	int
;	O
if	O
(	O
find_origin	function
(	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
!=	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
continue	O
;	O
if	O
(	O
ON_BOARD2	O
(	O
i	int
,	O
j	int
)	O
&&	O
!	O
same_string	function
(	O
POS	O
(	O
u	int
,	O
v	int
)	O
,	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
)	O
continue	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
BOARD	O
(	O
m	int
,	O
n	int
)	O
!=	O
EMPTY	int
&&	O
same_string	function
(	O
POS	O
(	O
m	int
,	O
n	int
)	O
,	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
)	O
gtp_mprintf	function
(	O
"%m "	pointer
,	O
m	int
,	O
n	int
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
if	O
(	O
board_empty	int
)	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_worm_cutstone	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"vertex must not be empty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_WORMS	int
)	O
;	O
return	O
gtp_success	function
(	O
" %d"	pointer
,	O
worm	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
.	O
cutstone	int
)	O
;	O
}	O
static	O
int	O
gtp_dragon_data	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
int	O
m	int
,	O
n	int
;	O
int	O
newline_needed	int
=	O
0	int
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%*c"	pointer
)	O
>=	O
0	int
&&	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"dragon data unavailable when stackp > 0"	pointer
)	O
;	O
silent_examine_position	function
(	O
FULL_EXAMINE_DRAGONS	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
ON_BOARD2	O
(	O
i	int
,	O
j	int
)	O
&&	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
gtp_mprintf	function
(	O
"%m empty\n"	pointer
,	O
i	int
,	O
j	int
)	O
;	O
else	O
{	O
newline_needed	int
=	O
1	int
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
(	O
m	int
==	O
i	int
&&	O
n	int
==	O
j	int
)	O
||	O
(	O
i	int
==	O
-	O
1	int
&&	O
BOARD	O
(	O
m	int
,	O
n	int
)	O
!=	O
EMPTY	int
&&	O
dragon	int
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
origin	int
==	O
POS	O
(	O
m	int
,	O
n	int
)	O
)	O
)	O
{	O
gtp_print_vertex	function
(	O
m	int
,	O
n	int
)	O
;	O
gtp_printf	function
(	O
":\n"	pointer
)	O
;	O
report_dragon	function
(	O
gtp_output_file	pointer
,	O
POS	O
(	O
m	int
,	O
n	int
)	O
)	O
;	O
newline_needed	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
newline_needed	int
)	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_dragon_stones	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
int	O
color	int
=	O
EMPTY	int
;	O
int	O
m	int
,	O
n	int
;	O
int	O
u	int
,	O
v	int
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%*c"	pointer
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
&&	O
!	O
gtp_decode_color	function
(	O
s	pointer
,	O
&	O
color	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
}	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"dragon_stones called on an empty vertex"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
u	int
=	O
0	int
;	O
u	int
<	O
board_size	int
;	O
u	int
++	O
)	O
for	O
(	O
v	int
=	O
0	int
;	O
v	int
<	O
board_size	int
;	O
v	int
++	O
)	O
{	O
if	O
(	O
BOARD	O
(	O
u	int
,	O
v	int
)	O
==	O
EMPTY	int
||	O
(	O
color	int
!=	O
EMPTY	int
&&	O
BOARD	O
(	O
u	int
,	O
v	int
)	O
!=	O
color	int
)	O
)	O
continue	O
;	O
if	O
(	O
dragon	int
[	O
POS	O
(	O
u	int
,	O
v	int
)	O
]	O
.	O
origin	int
!=	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
continue	O
;	O
if	O
(	O
ON_BOARD2	O
(	O
i	int
,	O
j	int
)	O
&&	O
dragon	int
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
.	O
origin	int
!=	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
continue	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
board_size	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
if	O
(	O
dragon	int
[	O
POS	O
(	O
m	int
,	O
n	int
)	O
]	O
.	O
origin	int
==	O
POS	O
(	O
u	int
,	O
v	int
)	O
)	O
gtp_mprintf	function
(	O
"%m "	pointer
,	O
m	int
,	O
n	int
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_eye_data	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
color	int
=	O
EMPTY	int
;	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
struct	O
eye_data	struct
*	O
e	pointer
;	O
if	O
(	O
!	O
gtp_decode_move	function
(	O
s	pointer
,	O
&	O
color	int
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid color or coordinate"	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"eye data unavailable when stackp > 0"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
if	O
(	O
color	int
==	O
BLACK	int
)	O
e	pointer
=	O
&	O
black_eye	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
;	O
else	O
e	pointer
=	O
&	O
white_eye	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
;	O
gtp_mprintf	function
(	O
"origin               %m\n"	pointer
,	O
I	O
(	O
e	pointer
->	O
origin	int
)	O
,	O
J	O
(	O
e	pointer
->	O
origin	int
)	O
)	O
;	O
gtp_mprintf	function
(	O
"color                %C\n"	pointer
,	O
e	pointer
->	O
color	int
)	O
;	O
gtp_printf	function
(	O
"esize                %d\n"	pointer
,	O
e	pointer
->	O
esize	int
)	O
;	O
gtp_printf	function
(	O
"msize                %d\n"	pointer
,	O
e	pointer
->	O
msize	int
)	O
;	O
gtp_printf	function
(	O
"value                %s\n"	pointer
,	O
eyevalue_to_string	function
(	O
&	O
e	pointer
->	O
value	pointer
)	O
)	O
;	O
gtp_printf	function
(	O
"marginal             %d\n"	pointer
,	O
e	pointer
->	O
marginal	char
)	O
;	O
gtp_printf	function
(	O
"neighbors            %d\n"	pointer
,	O
e	pointer
->	O
neighbors	int
)	O
;	O
gtp_printf	function
(	O
"marginal_neighbors   %d\n"	pointer
,	O
e	pointer
->	O
marginal_neighbors	char
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_half_eye_data	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
=	O
-	O
1	int
;	O
int	O
j	int
=	O
-	O
1	int
;	O
struct	O
half_eye_data	struct
*	O
h	pointer
;	O
int	O
k	int
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
stackp	int
>	O
0	int
)	O
return	O
gtp_failure	function
(	O
"half eye data unavailable when stackp > 0"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS_WITHOUT_OWL	int
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
h	pointer
=	O
&	O
half_eye	array
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
;	O
gtp_printf	function
(	O
"value                %.2f\n"	pointer
,	O
h	pointer
->	O
value	pointer
)	O
;	O
if	O
(	O
h	pointer
->	O
type	char
==	O
HALF_EYE	int
)	O
gtp_printf	function
(	O
"type                 HALF_EYE\n"	pointer
)	O
;	O
else	O
if	O
(	O
h	pointer
->	O
type	char
==	O
FALSE_EYE	int
)	O
gtp_printf	function
(	O
"type                 FALSE_EYE\n"	pointer
)	O
;	O
else	O
gtp_printf	function
(	O
"type                 %d\n"	pointer
,	O
h	pointer
->	O
type	char
)	O
;	O
gtp_printf	function
(	O
"num_attacks          %d\n"	pointer
,	O
h	pointer
->	O
num_attacks	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
h	pointer
->	O
num_attacks	int
;	O
k	int
++	O
)	O
gtp_mprintf	function
(	O
"attack_point[%d]      %m\n"	pointer
,	O
k	int
,	O
I	O
(	O
h	pointer
->	O
attack_point	pointer
[	O
k	int
]	O
)	O
,	O
J	O
(	O
h	pointer
->	O
attack_point	pointer
[	O
k	int
]	O
)	O
)	O
;	O
gtp_printf	function
(	O
"num_defenses         %d\n"	pointer
,	O
h	pointer
->	O
num_defenses	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
h	pointer
->	O
num_defenses	int
;	O
k	int
++	O
)	O
gtp_mprintf	function
(	O
"defense_point[%d]     %m\n"	pointer
,	O
k	int
,	O
I	O
(	O
h	pointer
->	O
defense_point	pointer
[	O
k	int
]	O
)	O
,	O
J	O
(	O
h	pointer
->	O
defense_point	pointer
[	O
k	int
]	O
)	O
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
SGFTree	struct
gtp_sgftree	struct
;	O
static	O
int	O
gtp_start_sgftrace	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
sgffile_begindump	function
(	O
&	O
gtp_sgftree	struct
)	O
;	O
count_variations	int
=	O
1	int
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_finish_sgftrace	function
(	O
char	O
*	O
s	pointer
)	O
{	O
char	O
filename	pointer
[	O
GTP_BUFSIZE	int
]	O
;	O
int	O
nread	int
;	O
nread	int
=	O
sscanf	function
(	O
s	pointer
,	O
"%s"	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
nread	int
<	O
1	int
)	O
return	O
gtp_failure	function
(	O
"missing filename"	pointer
)	O
;	O
sgffile_enddump	function
(	O
filename	pointer
)	O
;	O
count_variations	int
=	O
0	int
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_printsgf	function
(	O
char	O
*	O
s	pointer
)	O
{	O
char	O
filename	pointer
[	O
GTP_BUFSIZE	int
]	O
;	O
int	O
nread	int
;	O
int	O
next	pointer
;	O
if	O
(	O
get_last_player	function
(	O
)	O
==	O
EMPTY	int
)	O
next	pointer
=	O
BLACK	int
;	O
else	O
next	pointer
=	O
OTHER_COLOR	O
(	O
get_last_player	function
(	O
)	O
)	O
;	O
nread	int
=	O
sscanf	function
(	O
s	pointer
,	O
"%s"	pointer
,	O
filename	pointer
)	O
;	O
if	O
(	O
nread	int
<	O
1	int
)	O
gg_snprintf	function
(	O
filename	pointer
,	O
GTP_BUFSIZE	int
,	O
"%s"	pointer
,	O
"-"	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
filename	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
{	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
sgffile_printsgf	function
(	O
next	pointer
,	O
filename	pointer
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
else	O
{	O
sgffile_printsgf	function
(	O
next	pointer
,	O
filename	pointer
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
}	O
static	O
int	O
gtp_tune_move_ordering	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
params	array
[	O
MOVE_ORDERING_PARAMETERS	int
]	O
;	O
int	O
k	int
;	O
int	O
p	int
;	O
int	O
n	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MOVE_ORDERING_PARAMETERS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%d%n"	pointer
,	O
&	O
p	int
,	O
&	O
n	int
)	O
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"incorrect arguments, expected %d integers"	pointer
,	O
MOVE_ORDERING_PARAMETERS	int
)	O
;	O
params	array
[	O
k	int
]	O
=	O
p	int
;	O
s	pointer
+=	O
n	int
;	O
}	O
tune_move_ordering	function
(	O
params	array
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_echo	function
(	O
char	O
*	O
s	pointer
)	O
{	O
return	O
gtp_success	function
(	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
}	O
static	O
int	O
gtp_echo_err	function
(	O
char	O
*	O
s	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
fflush	function
(	O
gtp_output_file	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
}	O
static	O
int	O
gtp_list_commands	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
k	int
;	O
UNUSED	O
(	O
s	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
commands	array
[	O
k	int
]	O
.	O
name	short
!=	O
NULL	O
;	O
k	int
++	O
)	O
gtp_printf	function
(	O
"%s\n"	pointer
,	O
commands	array
[	O
k	int
]	O
.	O
name	short
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
return	O
GTP_OK	int
;	O
}	O
static	O
int	O
gtp_known_command	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
k	int
;	O
char	O
command	array
[	O
GTP_BUFSIZE	int
]	O
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%s"	pointer
,	O
command	array
)	O
==	O
1	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
commands	array
[	O
k	int
]	O
.	O
name	short
!=	O
NULL	O
;	O
k	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
command	array
,	O
commands	array
[	O
k	int
]	O
.	O
name	short
)	O
==	O
0	int
)	O
return	O
gtp_success	function
(	O
"true"	pointer
)	O
;	O
}	O
return	O
gtp_success	function
(	O
"false"	pointer
)	O
;	O
}	O
static	O
int	O
gtp_report_uncertainty	function
(	O
char	O
*	O
s	pointer
)	O
{	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
"on"	pointer
,	O
2	int
)	O
)	O
{	O
report_uncertainty	int
=	O
1	int
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
if	O
(	O
!	O
strncmp	function
(	O
s	pointer
,	O
"off"	pointer
,	O
3	int
)	O
)	O
{	O
report_uncertainty	int
=	O
0	int
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
return	O
gtp_failure	function
(	O
"invalid argument"	pointer
)	O
;	O
}	O
static	O
void	O
gtp_print_code	function
(	O
int	O
c	char
)	O
{	O
static	O
int	O
conversion	array
[	O
6	int
]	O
=	O
{	O
0	int
,	O
3	int
,	O
5	int
,	O
4	int
,	O
2	int
,	O
1	int
,	O
}	O
;	O
gtp_printf	function
(	O
"%d"	pointer
,	O
conversion	array
[	O
c	char
]	O
)	O
;	O
}	O
static	O
void	O
gtp_print_vertices2	function
(	O
int	O
n	int
,	O
int	O
*	O
moves	array
)	O
{	O
int	O
movei	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
movej	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
{	O
movei	array
[	O
k	int
]	O
=	O
I	O
(	O
moves	array
[	O
k	int
]	O
)	O
;	O
movej	array
[	O
k	int
]	O
=	O
J	O
(	O
moves	array
[	O
k	int
]	O
)	O
;	O
}	O
gtp_print_vertices	function
(	O
n	int
,	O
movei	array
,	O
movej	array
)	O
;	O
}	O
static	O
void	O
rotate_on_input	function
(	O
int	O
ai	int
,	O
int	O
aj	int
,	O
int	O
*	O
bi	pointer
,	O
int	O
*	O
bj	pointer
)	O
{	O
rotate	function
(	O
ai	int
,	O
aj	int
,	O
bi	pointer
,	O
bj	pointer
,	O
board_size	int
,	O
gtp_orientation	int
)	O
;	O
}	O
static	O
void	O
rotate_on_output	function
(	O
int	O
ai	int
,	O
int	O
aj	int
,	O
int	O
*	O
bi	pointer
,	O
int	O
*	O
bj	pointer
)	O
{	O
inv_rotate	function
(	O
ai	int
,	O
aj	int
,	O
bi	pointer
,	O
bj	pointer
,	O
board_size	int
,	O
gtp_orientation	int
)	O
;	O
}	O
static	O
int	O
gtp_get_random_seed	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
get_random_seed	function
(	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_set_random_seed	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
seed	int
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
&	O
seed	int
)	O
<	O
1	int
)	O
return	O
gtp_failure	function
(	O
"invalid seed"	pointer
)	O
;	O
set_random_seed	function
(	O
seed	int
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_advance_random_seed	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
;	O
int	O
games	int
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
&	O
games	int
)	O
<	O
1	int
||	O
games	int
<	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid number of games"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
games	int
;	O
i	int
++	O
)	O
update_random_seed	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
get_random_seed	function
(	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_is_surrounded	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"dragon vertex must be nonempty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS	int
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
DRAGON2	O
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
.	O
surround_status	int
)	O
;	O
}	O
static	O
int	O
gtp_does_surround	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
si	int
,	O
sj	int
,	O
di	int
,	O
dj	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
si	int
,	O
&	O
sj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
si	int
,	O
sj	int
)	O
!=	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"move vertex must be empty"	pointer
)	O
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
+	O
n	int
,	O
&	O
di	int
,	O
&	O
dj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
di	int
,	O
dj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"dragon vertex must be nonempty"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS	int
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
does_surround	function
(	O
POS	O
(	O
si	int
,	O
sj	int
)	O
,	O
POS	O
(	O
di	int
,	O
dj	int
)	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_surround_map	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
di	int
,	O
dj	int
,	O
mi	int
,	O
mj	int
;	O
int	O
n	int
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
di	int
,	O
&	O
dj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
if	O
(	O
BOARD	O
(	O
di	int
,	O
dj	int
)	O
==	O
EMPTY	int
)	O
return	O
gtp_failure	function
(	O
"dragon vertex must not be empty"	pointer
)	O
;	O
n	int
=	O
gtp_decode_coord	function
(	O
s	pointer
+	O
n	int
,	O
&	O
mi	int
,	O
&	O
mj	int
)	O
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS	int
)	O
;	O
return	O
gtp_success	function
(	O
"%d"	pointer
,	O
surround_map	function
(	O
POS	O
(	O
di	int
,	O
dj	int
)	O
,	O
POS	O
(	O
mi	int
,	O
mj	int
)	O
)	O
)	O
;	O
}	O
static	O
int	O
gtp_set_search_diamond	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
if	O
(	O
!	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
)	O
return	O
gtp_failure	function
(	O
"invalid coordinate"	pointer
)	O
;	O
set_limit_search	function
(	O
1	int
)	O
;	O
set_search_diamond	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_reset_search_mask	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
reset_search_mask	function
(	O
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_limit_search	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
value	pointer
;	O
if	O
(	O
sscanf	function
(	O
s	pointer
,	O
"%d"	pointer
,	O
&	O
value	pointer
)	O
<	O
1	int
)	O
return	O
gtp_failure	function
(	O
"invalid value for search limit"	pointer
)	O
;	O
set_limit_search	function
(	O
value	pointer
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_set_search_limit	function
(	O
char	O
*	O
s	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
gtp_decode_coord	function
(	O
s	pointer
,	O
&	O
i	int
,	O
&	O
j	int
)	O
;	O
set_search_mask	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
,	O
1	int
)	O
;	O
return	O
gtp_success	function
(	O
""	pointer
)	O
;	O
}	O
static	O
int	O
gtp_draw_search_area	function
(	O
char	O
*	O
s	pointer
)	O
{	O
UNUSED	O
(	O
s	pointer
)	O
;	O
gtp_start_response	function
(	O
GTP_SUCCESS	int
)	O
;	O
gtp_printf	function
(	O
"\n"	pointer
)	O
;	O
draw_search_area	function
(	O
)	O
;	O
return	O
gtp_finish_response	function
(	O
)	O
;	O
}	O
