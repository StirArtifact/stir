static	O
int	O
check_resource_name	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
int	O
ndots	int
=	O
0	int
;	O
const	O
char	O
*	O
p	pointer
=	O
name	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
(	O
c_isalpha	function
(	O
*	O
p	pointer
)	O
||	O
(	O
*	O
p	pointer
==	O
'$'	O
)	O
||	O
(	O
*	O
p	pointer
==	O
'_'	O
)	O
)	O
)	O
return	O
-	O
1	int
;	O
do	O
p	pointer
++	O
;	O
while	O
(	O
c_isalpha	function
(	O
*	O
p	pointer
)	O
||	O
(	O
*	O
p	pointer
==	O
'$'	O
)	O
||	O
(	O
*	O
p	pointer
==	O
'_'	O
)	O
||	O
c_isdigit	function
(	O
*	O
p	pointer
)	O
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'\0'	O
)	O
break	O
;	O
if	O
(	O
*	O
p	pointer
!=	O
'.'	O
)	O
return	O
-	O
1	int
;	O
p	pointer
++	O
;	O
ndots	int
++	O
;	O
}	O
return	O
ndots	int
;	O
}	O
static	O
unsigned	O
int	O
string_hashcode	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
const	O
char	O
*	O
str_limit	pointer
=	O
str	pointer
+	O
strlen	function
(	O
str	pointer
)	O
;	O
int	O
hash	int
=	O
0	int
;	O
while	O
(	O
str	pointer
<	O
str_limit	pointer
)	O
{	O
ucs4_t	int
uc	int
;	O
str	pointer
+=	O
u8_mbtouc	function
(	O
&	O
uc	int
,	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
str	pointer
,	O
str_limit	pointer
-	O
str	pointer
)	O
;	O
if	O
(	O
uc	int
<	O
0x10000	int
)	O
hash	int
=	O
31	int
*	O
hash	int
+	O
uc	int
;	O
else	O
{	O
ucs4_t	int
uc1	int
=	O
0xd800	int
+	O
(	O
(	O
uc	int
-	O
0x10000	int
)	O
>>	O
10	int
)	O
;	O
ucs4_t	int
uc2	int
=	O
0xdc00	int
+	O
(	O
(	O
uc	int
-	O
0x10000	int
)	O
&	O
0x3ff	int
)	O
;	O
hash	int
=	O
31	int
*	O
hash	int
+	O
uc1	int
;	O
hash	int
=	O
31	int
*	O
hash	int
+	O
uc2	int
;	O
}	O
}	O
return	O
hash	int
&	O
0x7fffffff	int
;	O
}	O
static	O
unsigned	O
int	O
msgid_hashcode	function
(	O
const	O
char	O
*	O
msgctxt	pointer
,	O
const	O
char	O
*	O
msgid	pointer
)	O
{	O
if	O
(	O
msgctxt	pointer
==	O
NULL	O
)	O
return	O
string_hashcode	function
(	O
msgid	pointer
)	O
;	O
else	O
{	O
size_t	long
msgctxt_len	long
=	O
strlen	function
(	O
msgctxt	pointer
)	O
;	O
size_t	long
msgid_len	long
=	O
strlen	function
(	O
msgid	pointer
)	O
;	O
size_t	long
combined_len	long
=	O
msgctxt_len	long
+	O
1	int
+	O
msgid_len	long
;	O
char	O
*	O
combined	pointer
;	O
unsigned	O
int	O
result	pointer
;	O
combined	pointer
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
combined_len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
combined	pointer
,	O
msgctxt	pointer
,	O
msgctxt_len	long
)	O
;	O
combined	pointer
[	O
msgctxt_len	long
]	O
=	O
MSGCTXT_SEPARATOR	char
;	O
memcpy	function
(	O
combined	pointer
+	O
msgctxt_len	long
+	O
1	int
,	O
msgid	pointer
,	O
msgid_len	long
+	O
1	int
)	O
;	O
result	pointer
=	O
string_hashcode	function
(	O
combined	pointer
)	O
;	O
freea	function
(	O
combined	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
}	O
static	O
unsigned	O
int	O
compute_hashsize	function
(	O
message_list_ty	struct
*	O
mlp	pointer
,	O
bool	bool
*	O
collisionp	pointer
)	O
{	O
unsigned	O
int	O
n	long
=	O
mlp	pointer
->	O
nitems	long
;	O
unsigned	O
int	O
*	O
hashcodes	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
xmalloca	O
(	O
n	long
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
unsigned	O
int	O
hashsize	int
;	O
unsigned	O
int	O
best_hashsize	int
;	O
unsigned	O
int	O
best_score	int
;	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n	long
;	O
j	long
++	O
)	O
hashcodes	pointer
[	O
j	long
]	O
=	O
msgid_hashcode	function
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgctxt	pointer
,	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgid	pointer
)	O
;	O
best_hashsize	int
=	O
0	int
;	O
best_score	int
=	O
UINT_MAX	O
;	O
for	O
(	O
hashsize	int
=	O
n	long
;	O
hashsize	int
<=	O
XXN	int
*	O
n	long
;	O
hashsize	int
++	O
)	O
{	O
char	O
*	O
bitmap	pointer
;	O
unsigned	O
int	O
score	int
;	O
if	O
(	O
hashsize	int
>=	O
best_score	int
)	O
break	O
;	O
bitmap	pointer
=	O
XNMALLOC	O
(	O
hashsize	int
,	O
char	O
)	O
;	O
memset	function
(	O
bitmap	pointer
,	O
0	int
,	O
hashsize	int
)	O
;	O
score	int
=	O
0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n	long
;	O
j	long
++	O
)	O
{	O
unsigned	O
int	O
idx	int
=	O
hashcodes	pointer
[	O
j	long
]	O
%	O
hashsize	int
;	O
if	O
(	O
bitmap	pointer
[	O
idx	int
]	O
!=	O
0	int
)	O
{	O
if	O
(	O
(	O
hashsize	int
%	O
2	int
)	O
==	O
0	int
)	O
goto	O
bad_hashsize	O
;	O
else	O
{	O
unsigned	O
int	O
idx0	int
=	O
idx	int
;	O
unsigned	O
int	O
incr	int
=	O
1	int
+	O
(	O
hashcodes	pointer
[	O
j	long
]	O
%	O
(	O
hashsize	int
-	O
2	int
)	O
)	O
;	O
score	int
+=	O
2	int
;	O
do	O
{	O
score	int
++	O
;	O
idx	int
+=	O
incr	int
;	O
if	O
(	O
idx	int
>=	O
hashsize	int
)	O
idx	int
-=	O
hashsize	int
;	O
if	O
(	O
idx	int
==	O
idx0	int
)	O
goto	O
bad_hashsize	O
;	O
}	O
while	O
(	O
bitmap	pointer
[	O
idx	int
]	O
!=	O
0	int
)	O
;	O
}	O
}	O
bitmap	pointer
[	O
idx	int
]	O
=	O
1	int
;	O
}	O
score	int
=	O
XXS	int
*	O
score	int
+	O
hashsize	int
;	O
if	O
(	O
score	int
>	O
hashsize	int
)	O
{	O
unsigned	O
int	O
incr	int
;	O
for	O
(	O
incr	int
=	O
1	int
;	O
incr	int
<=	O
hashsize	int
/	O
2	int
;	O
incr	int
++	O
)	O
if	O
(	O
(	O
hashsize	int
%	O
incr	int
)	O
==	O
0	int
)	O
{	O
unsigned	O
int	O
idx0	int
;	O
for	O
(	O
idx0	int
=	O
0	int
;	O
idx0	int
<	O
incr	int
;	O
idx0	int
++	O
)	O
{	O
bool	bool
full	bool
=	O
true	int
;	O
unsigned	O
int	O
idx	int
;	O
for	O
(	O
idx	int
=	O
idx0	int
;	O
idx	int
<	O
hashsize	int
;	O
idx	int
+=	O
incr	int
)	O
if	O
(	O
bitmap	pointer
[	O
idx	int
]	O
==	O
0	int
)	O
{	O
full	bool
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
full	bool
)	O
goto	O
bad_hashsize	O
;	O
}	O
}	O
}	O
if	O
(	O
false	int
)	O
bad_hashsize	O
:	O
score	int
=	O
UINT_MAX	O
;	O
free	function
(	O
bitmap	pointer
)	O
;	O
if	O
(	O
score	int
<	O
best_score	int
)	O
{	O
best_score	int
=	O
score	int
;	O
best_hashsize	int
=	O
hashsize	int
;	O
}	O
}	O
if	O
(	O
best_hashsize	int
==	O
0	int
||	O
best_score	int
<	O
best_hashsize	int
)	O
abort	function
(	O
)	O
;	O
freea	function
(	O
hashcodes	pointer
)	O
;	O
*	O
collisionp	pointer
=	O
(	O
best_score	int
>	O
best_hashsize	int
)	O
;	O
return	O
best_hashsize	int
;	O
}	O
struct	O
table_item	struct
{	O
unsigned	O
int	O
index	function
;	O
message_ty	struct
*	O
mp	pointer
;	O
}	O
;	O
static	O
int	O
compare_index	function
(	O
const	O
void	O
*	O
pval1	pointer
,	O
const	O
void	O
*	O
pval2	pointer
)	O
{	O
return	O
(	O
int	O
)	O
(	O
(	O
const	O
struct	O
table_item	struct
*	O
)	O
pval1	pointer
)	O
->	O
index	function
-	O
(	O
int	O
)	O
(	O
(	O
const	O
struct	O
table_item	struct
*	O
)	O
pval2	pointer
)	O
->	O
index	function
;	O
}	O
static	O
struct	O
table_item	struct
*	O
compute_table_items	function
(	O
message_list_ty	struct
*	O
mlp	pointer
,	O
unsigned	O
int	O
hashsize	int
)	O
{	O
unsigned	O
int	O
n	long
=	O
mlp	pointer
->	O
nitems	long
;	O
struct	O
table_item	struct
*	O
arr	pointer
=	O
XNMALLOC	O
(	O
n	long
,	O
struct	O
table_item	struct
)	O
;	O
char	O
*	O
bitmap	pointer
;	O
size_t	long
j	long
;	O
bitmap	pointer
=	O
XNMALLOC	O
(	O
hashsize	int
,	O
char	O
)	O
;	O
memset	function
(	O
bitmap	pointer
,	O
0	int
,	O
hashsize	int
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
n	long
;	O
j	long
++	O
)	O
{	O
unsigned	O
int	O
hashcode	int
=	O
msgid_hashcode	function
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgctxt	pointer
,	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgid	pointer
)	O
;	O
unsigned	O
int	O
idx	int
=	O
hashcode	int
%	O
hashsize	int
;	O
if	O
(	O
bitmap	pointer
[	O
idx	int
]	O
!=	O
0	int
)	O
{	O
unsigned	O
int	O
incr	int
=	O
1	int
+	O
(	O
hashcode	int
%	O
(	O
hashsize	int
-	O
2	int
)	O
)	O
;	O
do	O
{	O
idx	int
+=	O
incr	int
;	O
if	O
(	O
idx	int
>=	O
hashsize	int
)	O
idx	int
-=	O
hashsize	int
;	O
}	O
while	O
(	O
bitmap	pointer
[	O
idx	int
]	O
!=	O
0	int
)	O
;	O
}	O
bitmap	pointer
[	O
idx	int
]	O
=	O
1	int
;	O
arr	pointer
[	O
j	long
]	O
.	O
index	function
=	O
idx	int
;	O
arr	pointer
[	O
j	long
]	O
.	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
}	O
free	function
(	O
bitmap	pointer
)	O
;	O
qsort	function
(	O
arr	pointer
,	O
n	long
,	O
sizeof	O
(	O
arr	pointer
[	O
0	int
]	O
)	O
,	O
compare_index	function
)	O
;	O
return	O
arr	pointer
;	O
}	O
static	O
void	O
write_java_string	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
char	O
*	O
str	pointer
)	O
{	O
static	O
const	O
char	O
hexdigit	array
[	O
]	O
=	O
"0123456789abcdef"	pointer
;	O
const	O
char	O
*	O
str_limit	pointer
=	O
str	pointer
+	O
strlen	function
(	O
str	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"\""	pointer
)	O
;	O
while	O
(	O
str	pointer
<	O
str_limit	pointer
)	O
{	O
ucs4_t	int
uc	int
;	O
str	pointer
+=	O
u8_mbtouc	function
(	O
&	O
uc	int
,	O
(	O
const	O
unsigned	O
char	O
*	O
)	O
str	pointer
,	O
str_limit	pointer
-	O
str	pointer
)	O
;	O
if	O
(	O
uc	int
<	O
0x10000	int
)	O
{	O
if	O
(	O
uc	int
==	O
0x000a	int
)	O
fprintf	function
(	O
stream	pointer
,	O
"\\n"	pointer
)	O
;	O
else	O
if	O
(	O
uc	int
==	O
0x000d	int
)	O
fprintf	function
(	O
stream	pointer
,	O
"\\r"	pointer
)	O
;	O
else	O
if	O
(	O
uc	int
==	O
0x0022	int
)	O
fprintf	function
(	O
stream	pointer
,	O
"\\\""	pointer
)	O
;	O
else	O
if	O
(	O
uc	int
==	O
0x005c	int
)	O
fprintf	function
(	O
stream	pointer
,	O
"\\\\"	pointer
)	O
;	O
else	O
if	O
(	O
uc	int
>=	O
0x0020	int
&&	O
uc	int
<	O
0x007f	int
)	O
fprintf	function
(	O
stream	pointer
,	O
"%c"	pointer
,	O
(	O
int	O
)	O
uc	int
)	O
;	O
else	O
fprintf	function
(	O
stream	pointer
,	O
"\\u%c%c%c%c"	pointer
,	O
hexdigit	array
[	O
(	O
uc	int
>>	O
12	int
)	O
&	O
0x0f	int
]	O
,	O
hexdigit	array
[	O
(	O
uc	int
>>	O
8	int
)	O
&	O
0x0f	int
]	O
,	O
hexdigit	array
[	O
(	O
uc	int
>>	O
4	int
)	O
&	O
0x0f	int
]	O
,	O
hexdigit	array
[	O
uc	int
&	O
0x0f	int
]	O
)	O
;	O
}	O
else	O
{	O
ucs4_t	int
uc1	int
=	O
0xd800	int
+	O
(	O
(	O
uc	int
-	O
0x10000	int
)	O
>>	O
10	int
)	O
;	O
ucs4_t	int
uc2	int
=	O
0xdc00	int
+	O
(	O
(	O
uc	int
-	O
0x10000	int
)	O
&	O
0x3ff	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"\\u%c%c%c%c"	pointer
,	O
hexdigit	array
[	O
(	O
uc1	int
>>	O
12	int
)	O
&	O
0x0f	int
]	O
,	O
hexdigit	array
[	O
(	O
uc1	int
>>	O
8	int
)	O
&	O
0x0f	int
]	O
,	O
hexdigit	array
[	O
(	O
uc1	int
>>	O
4	int
)	O
&	O
0x0f	int
]	O
,	O
hexdigit	array
[	O
uc1	int
&	O
0x0f	int
]	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"\\u%c%c%c%c"	pointer
,	O
hexdigit	array
[	O
(	O
uc2	int
>>	O
12	int
)	O
&	O
0x0f	int
]	O
,	O
hexdigit	array
[	O
(	O
uc2	int
>>	O
8	int
)	O
&	O
0x0f	int
]	O
,	O
hexdigit	array
[	O
(	O
uc2	int
>>	O
4	int
)	O
&	O
0x0f	int
]	O
,	O
hexdigit	array
[	O
uc2	int
&	O
0x0f	int
]	O
)	O
;	O
}	O
}	O
fprintf	function
(	O
stream	pointer
,	O
"\""	pointer
)	O
;	O
}	O
static	O
void	O
write_java_msgid	function
(	O
FILE	struct
*	O
stream	pointer
,	O
message_ty	struct
*	O
mp	pointer
)	O
{	O
const	O
char	O
*	O
msgctxt	pointer
=	O
mp	pointer
->	O
msgctxt	pointer
;	O
const	O
char	O
*	O
msgid	pointer
=	O
mp	pointer
->	O
msgid	pointer
;	O
if	O
(	O
msgctxt	pointer
==	O
NULL	O
)	O
write_java_string	function
(	O
stream	pointer
,	O
msgid	pointer
)	O
;	O
else	O
{	O
size_t	long
msgctxt_len	long
=	O
strlen	function
(	O
msgctxt	pointer
)	O
;	O
size_t	long
msgid_len	long
=	O
strlen	function
(	O
msgid	pointer
)	O
;	O
size_t	long
combined_len	long
=	O
msgctxt_len	long
+	O
1	int
+	O
msgid_len	long
;	O
char	O
*	O
combined	pointer
;	O
combined	pointer
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
combined_len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
combined	pointer
,	O
msgctxt	pointer
,	O
msgctxt_len	long
)	O
;	O
combined	pointer
[	O
msgctxt_len	long
]	O
=	O
MSGCTXT_SEPARATOR	char
;	O
memcpy	function
(	O
combined	pointer
+	O
msgctxt_len	long
+	O
1	int
,	O
msgid	pointer
,	O
msgid_len	long
+	O
1	int
)	O
;	O
write_java_string	function
(	O
stream	pointer
,	O
combined	pointer
)	O
;	O
freea	function
(	O
combined	pointer
)	O
;	O
}	O
}	O
static	O
void	O
write_java_msgstr	function
(	O
FILE	struct
*	O
stream	pointer
,	O
message_ty	struct
*	O
mp	pointer
)	O
{	O
if	O
(	O
mp	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
{	O
bool	bool
first	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
fprintf	function
(	O
stream	pointer
,	O
"new java.lang.String[] { "	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
mp	pointer
->	O
msgstr	pointer
,	O
first	pointer
=	O
true	int
;	O
p	pointer
<	O
mp	pointer
->	O
msgstr	pointer
+	O
mp	pointer
->	O
msgstr_len	long
;	O
p	pointer
+=	O
strlen	function
(	O
p	pointer
)	O
+	O
1	int
,	O
first	pointer
=	O
false	int
)	O
{	O
if	O
(	O
!	O
first	pointer
)	O
fprintf	function
(	O
stream	pointer
,	O
", "	pointer
)	O
;	O
write_java_string	function
(	O
stream	pointer
,	O
p	pointer
)	O
;	O
}	O
fprintf	function
(	O
stream	pointer
,	O
" }"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
mp	pointer
->	O
msgstr_len	long
!=	O
strlen	function
(	O
mp	pointer
->	O
msgstr	pointer
)	O
+	O
1	int
)	O
abort	function
(	O
)	O
;	O
write_java_string	function
(	O
stream	pointer
,	O
mp	pointer
->	O
msgstr	pointer
)	O
;	O
}	O
}	O
static	O
void	O
write_lookup_code	function
(	O
FILE	struct
*	O
stream	pointer
,	O
unsigned	O
int	O
hashsize	int
,	O
bool	bool
collisions	bool
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"    int hash_val = msgid.hashCode() & 0x7fffffff;\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    int idx = (hash_val %% %d) << 1;\n"	pointer
,	O
hashsize	int
)	O
;	O
if	O
(	O
collisions	bool
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"    {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"      java.lang.Object found = table[idx];\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"      if (found == null)\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"        return null;\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"      if (msgid.equals(found))\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"        return table[idx + 1];\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    }\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    int incr = ((hash_val %% %d) + 1) << 1;\n"	pointer
,	O
hashsize	int
-	O
2	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    for (;;) {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"      idx += incr;\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"      if (idx >= %d)\n"	pointer
,	O
2	int
*	O
hashsize	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"        idx -= %d;\n"	pointer
,	O
2	int
*	O
hashsize	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"      java.lang.Object found = table[idx];\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"      if (found == null)\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"        return null;\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"      if (msgid.equals(found))\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"        return table[idx + 1];\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    }\n"	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"    java.lang.Object found = table[idx];\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    if (found != null && msgid.equals(found))\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"      return table[idx + 1];\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    return null;\n"	pointer
)	O
;	O
}	O
}	O
static	O
bool	bool
is_expression_boolean	function
(	O
struct	O
expression	struct
*	O
exp	pointer
)	O
{	O
switch	O
(	O
exp	pointer
->	O
operation	enum
)	O
{	O
case	O
var	int
:	O
case	O
mult	int
:	O
case	O
divide	int
:	O
case	O
module	int
:	O
case	O
plus	int
:	O
case	O
minus	int
:	O
return	O
false	int
;	O
case	O
lnot	int
:	O
case	O
less_than	int
:	O
case	O
greater_than	int
:	O
case	O
less_or_equal	int
:	O
case	O
greater_or_equal	int
:	O
case	O
equal	int
:	O
case	O
not_equal	int
:	O
case	O
land	int
:	O
case	O
lor	int
:	O
return	O
true	int
;	O
case	O
num	int
:	O
return	O
(	O
exp	pointer
->	O
val	array
.	O
num	int
==	O
0	int
||	O
exp	pointer
->	O
val	array
.	O
num	int
==	O
1	int
)	O
;	O
case	O
qmop	int
:	O
return	O
is_expression_boolean	function
(	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
)	O
&&	O
is_expression_boolean	function
(	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
2	int
]	O
)	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
write_java_expression	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
struct	O
expression	struct
*	O
exp	pointer
,	O
bool	bool
as_boolean	bool
)	O
{	O
if	O
(	O
as_boolean	bool
)	O
{	O
switch	O
(	O
exp	pointer
->	O
operation	enum
)	O
{	O
case	O
num	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"%s"	pointer
,	O
exp	pointer
->	O
val	array
.	O
num	int
?	O
"true"	pointer
:	O
"false"	pointer
)	O
;	O
return	O
;	O
case	O
lnot	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"(!"	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
true	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
less_than	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" < "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
greater_than	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" > "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
less_or_equal	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" <= "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
greater_or_equal	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" >= "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
equal	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" == "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
not_equal	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" != "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
land	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
true	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" && "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
true	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
lor	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
true	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" || "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
true	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
qmop	int
:	O
if	O
(	O
is_expression_boolean	function
(	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
)	O
&&	O
is_expression_boolean	function
(	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
2	int
]	O
)	O
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
true	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" ? "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
true	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" : "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
2	int
]	O
,	O
true	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
}	O
case	O
var	int
:	O
case	O
mult	int
:	O
case	O
divide	int
:	O
case	O
module	int
:	O
case	O
plus	int
:	O
case	O
minus	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" != 0)"	pointer
)	O
;	O
return	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
else	O
{	O
switch	O
(	O
exp	pointer
->	O
operation	enum
)	O
{	O
case	O
var	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"n"	pointer
)	O
;	O
return	O
;	O
case	O
num	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"%lu"	pointer
,	O
exp	pointer
->	O
val	array
.	O
num	int
)	O
;	O
return	O
;	O
case	O
mult	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" * "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
divide	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" / "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
module	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" %% "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
plus	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" + "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
minus	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" - "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
qmop	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
0	int
]	O
,	O
true	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" ? "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
1	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" : "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
->	O
val	array
.	O
args	array
[	O
2	int
]	O
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
")"	pointer
)	O
;	O
return	O
;	O
case	O
lnot	int
:	O
case	O
less_than	int
:	O
case	O
greater_than	int
:	O
case	O
less_or_equal	int
:	O
case	O
greater_or_equal	int
:	O
case	O
equal	int
:	O
case	O
not_equal	int
:	O
case	O
land	int
:	O
case	O
lor	int
:	O
fprintf	function
(	O
stream	pointer
,	O
"("	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
exp	pointer
,	O
true	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" ? 1 : 0)"	pointer
)	O
;	O
return	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
write_java1_init_statements	function
(	O
FILE	struct
*	O
stream	pointer
,	O
message_list_ty	struct
*	O
mlp	pointer
,	O
size_t	long
start_index	long
,	O
size_t	long
end_index	long
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
start_index	long
;	O
j	long
<	O
end_index	long
;	O
j	long
++	O
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"    t.put("	pointer
)	O
;	O
write_java_msgid	function
(	O
stream	pointer
,	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
","	pointer
)	O
;	O
write_java_msgstr	function
(	O
stream	pointer
,	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
");\n"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
write_java2_init_statements	function
(	O
FILE	struct
*	O
stream	pointer
,	O
message_list_ty	struct
*	O
mlp	pointer
,	O
const	O
struct	O
table_item	struct
*	O
table_items	pointer
,	O
size_t	long
start_index	long
,	O
size_t	long
end_index	long
)	O
{	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
start_index	long
;	O
j	long
<	O
end_index	long
;	O
j	long
++	O
)	O
{	O
const	O
struct	O
table_item	struct
*	O
ti	pointer
=	O
&	O
table_items	pointer
[	O
j	long
]	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    t[%d] = "	pointer
,	O
2	int
*	O
ti	pointer
->	O
index	function
)	O
;	O
write_java_msgid	function
(	O
stream	pointer
,	O
ti	pointer
->	O
mp	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
";\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    t[%d] = "	pointer
,	O
2	int
*	O
ti	pointer
->	O
index	function
+	O
1	int
)	O
;	O
write_java_msgstr	function
(	O
stream	pointer
,	O
ti	pointer
->	O
mp	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
";\n"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
write_java_code	function
(	O
FILE	struct
*	O
stream	pointer
,	O
const	O
char	O
*	O
class_name	pointer
,	O
message_list_ty	struct
*	O
mlp	pointer
,	O
bool	bool
assume_java2	bool
)	O
{	O
const	O
char	O
*	O
last_dot	pointer
;	O
unsigned	O
int	O
plurals	int
;	O
size_t	long
j	long
;	O
fprintf	function
(	O
stream	pointer
,	O
"/* Automatically generated by GNU msgfmt.  Do not modify!  */\n"	pointer
)	O
;	O
last_dot	pointer
=	O
strrchr	function
(	O
class_name	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
last_dot	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"package "	pointer
)	O
;	O
fwrite	function
(	O
class_name	pointer
,	O
1	int
,	O
last_dot	pointer
-	O
class_name	pointer
,	O
stream	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
";\npublic class %s"	pointer
,	O
last_dot	pointer
+	O
1	int
)	O
;	O
}	O
else	O
fprintf	function
(	O
stream	pointer
,	O
"public class %s"	pointer
,	O
class_name	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
" extends java.util.ResourceBundle {\n"	pointer
)	O
;	O
plurals	int
=	O
0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
plurals	int
++	O
;	O
if	O
(	O
assume_java2	bool
)	O
{	O
unsigned	O
int	O
hashsize	int
;	O
bool	bool
collisions	bool
;	O
struct	O
table_item	struct
*	O
table_items	pointer
;	O
const	O
char	O
*	O
table_eltype	pointer
;	O
hashsize	int
=	O
compute_hashsize	function
(	O
mlp	pointer
,	O
&	O
collisions	bool
)	O
;	O
table_items	pointer
=	O
compute_table_items	function
(	O
mlp	pointer
,	O
hashsize	int
)	O
;	O
table_eltype	pointer
=	O
(	O
plurals	int
?	O
"java.lang.Object"	pointer
:	O
"java.lang.String"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  private static final %s[] table;\n"	pointer
,	O
table_eltype	pointer
)	O
;	O
{	O
const	O
size_t	long
max_items_per_method	long
=	O
1000	int
;	O
if	O
(	O
mlp	pointer
->	O
nitems	long
>	O
max_items_per_method	long
)	O
{	O
unsigned	O
int	O
k	int
;	O
size_t	long
start_j	long
;	O
size_t	long
end_j	long
;	O
for	O
(	O
k	int
=	O
0	int
,	O
start_j	long
=	O
0	int
,	O
end_j	long
=	O
start_j	long
+	O
max_items_per_method	long
;	O
start_j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
k	int
++	O
,	O
start_j	long
=	O
end_j	long
,	O
end_j	long
=	O
start_j	long
+	O
max_items_per_method	long
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"  static void clinit_part_%u (%s[] t) {\n"	pointer
,	O
k	int
,	O
table_eltype	pointer
)	O
;	O
write_java2_init_statements	function
(	O
stream	pointer
,	O
mlp	pointer
,	O
table_items	pointer
,	O
start_j	long
,	O
MIN	O
(	O
end_j	long
,	O
mlp	pointer
->	O
nitems	long
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
}	O
fprintf	function
(	O
stream	pointer
,	O
"  static {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    %s[] t = new %s[%d];\n"	pointer
,	O
table_eltype	pointer
,	O
table_eltype	pointer
,	O
2	int
*	O
hashsize	int
)	O
;	O
if	O
(	O
mlp	pointer
->	O
nitems	long
>	O
max_items_per_method	long
)	O
{	O
unsigned	O
int	O
k	int
;	O
size_t	long
start_j	long
;	O
for	O
(	O
k	int
=	O
0	int
,	O
start_j	long
=	O
0	int
;	O
start_j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
k	int
++	O
,	O
start_j	long
+=	O
max_items_per_method	long
)	O
fprintf	function
(	O
stream	pointer
,	O
"    clinit_part_%u(t);\n"	pointer
,	O
k	int
)	O
;	O
}	O
else	O
write_java2_init_statements	function
(	O
stream	pointer
,	O
mlp	pointer
,	O
table_items	pointer
,	O
0	int
,	O
mlp	pointer
->	O
nitems	long
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    table = t;\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
if	O
(	O
plurals	int
)	O
{	O
bool	bool
first	pointer
;	O
fprintf	function
(	O
stream	pointer
,	O
"  public static final java.lang.String[] get_msgid_plural_table () {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    return new java.lang.String[] { "	pointer
)	O
;	O
first	pointer
=	O
true	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
struct	O
table_item	struct
*	O
ti	pointer
=	O
&	O
table_items	pointer
[	O
j	long
]	O
;	O
if	O
(	O
ti	pointer
->	O
mp	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
!	O
first	pointer
)	O
fprintf	function
(	O
stream	pointer
,	O
", "	pointer
)	O
;	O
write_java_string	function
(	O
stream	pointer
,	O
ti	pointer
->	O
mp	pointer
->	O
msgid_plural	pointer
)	O
;	O
first	pointer
=	O
false	int
;	O
}	O
}	O
fprintf	function
(	O
stream	pointer
,	O
" };\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
if	O
(	O
plurals	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"  public java.lang.Object lookup (java.lang.String msgid) {\n"	pointer
)	O
;	O
write_lookup_code	function
(	O
stream	pointer
,	O
hashsize	int
,	O
collisions	bool
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
stream	pointer
,	O
"  public java.lang.Object handleGetObject (java.lang.String msgid) throws java.util.MissingResourceException {\n"	pointer
)	O
;	O
if	O
(	O
plurals	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"    java.lang.Object value = lookup(msgid);\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    return (value instanceof java.lang.String[] ? ((java.lang.String[])value)[0] : value);\n"	pointer
)	O
;	O
}	O
else	O
write_lookup_code	function
(	O
stream	pointer
,	O
hashsize	int
,	O
collisions	bool
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  public java.util.Enumeration getKeys () {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    return\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"      new java.util.Enumeration() {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"        private int idx = 0;\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"        { while (idx < %d && table[idx] == null) idx += 2; }\n"	pointer
,	O
2	int
*	O
hashsize	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"        public boolean hasMoreElements () {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"          return (idx < %d);\n"	pointer
,	O
2	int
*	O
hashsize	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"        }\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"        public java.lang.Object nextElement () {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"          java.lang.Object key = table[idx];\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"          do idx += 2; while (idx < %d && table[idx] == null);\n"	pointer
,	O
2	int
*	O
hashsize	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"          return key;\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"        }\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"      };\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"  private static final java.util.Hashtable table;\n"	pointer
)	O
;	O
{	O
const	O
size_t	long
max_items_per_method	long
=	O
1500	int
;	O
if	O
(	O
mlp	pointer
->	O
nitems	long
>	O
max_items_per_method	long
)	O
{	O
unsigned	O
int	O
k	int
;	O
size_t	long
start_j	long
;	O
size_t	long
end_j	long
;	O
for	O
(	O
k	int
=	O
0	int
,	O
start_j	long
=	O
0	int
,	O
end_j	long
=	O
start_j	long
+	O
max_items_per_method	long
;	O
start_j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
k	int
++	O
,	O
start_j	long
=	O
end_j	long
,	O
end_j	long
=	O
start_j	long
+	O
max_items_per_method	long
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"  static void clinit_part_%u (java.util.Hashtable t) {\n"	pointer
,	O
k	int
)	O
;	O
write_java1_init_statements	function
(	O
stream	pointer
,	O
mlp	pointer
,	O
start_j	long
,	O
MIN	O
(	O
end_j	long
,	O
mlp	pointer
->	O
nitems	long
)	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
}	O
fprintf	function
(	O
stream	pointer
,	O
"  static {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    java.util.Hashtable t = new java.util.Hashtable();\n"	pointer
)	O
;	O
if	O
(	O
mlp	pointer
->	O
nitems	long
>	O
max_items_per_method	long
)	O
{	O
unsigned	O
int	O
k	int
;	O
size_t	long
start_j	long
;	O
for	O
(	O
k	int
=	O
0	int
,	O
start_j	long
=	O
0	int
;	O
start_j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
k	int
++	O
,	O
start_j	long
+=	O
max_items_per_method	long
)	O
fprintf	function
(	O
stream	pointer
,	O
"    clinit_part_%u(t);\n"	pointer
,	O
k	int
)	O
;	O
}	O
else	O
write_java1_init_statements	function
(	O
stream	pointer
,	O
mlp	pointer
,	O
0	int
,	O
mlp	pointer
->	O
nitems	long
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    table = t;\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
if	O
(	O
plurals	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"  public static final java.util.Hashtable get_msgid_plural_table () {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    java.util.Hashtable p = new java.util.Hashtable();\n"	pointer
)	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"    p.put("	pointer
)	O
;	O
write_java_msgid	function
(	O
stream	pointer
,	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
","	pointer
)	O
;	O
write_java_string	function
(	O
stream	pointer
,	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgid_plural	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
");\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
stream	pointer
,	O
"    return p;\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
if	O
(	O
plurals	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"  public java.lang.Object lookup (java.lang.String msgid) {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    return table.get(msgid);\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
stream	pointer
,	O
"  public java.lang.Object handleGetObject (java.lang.String msgid) throws java.util.MissingResourceException {\n"	pointer
)	O
;	O
if	O
(	O
plurals	int
)	O
{	O
fprintf	function
(	O
stream	pointer
,	O
"    java.lang.Object value = table.get(msgid);\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    return (value instanceof java.lang.String[] ? ((java.lang.String[])value)[0] : value);\n"	pointer
)	O
;	O
}	O
else	O
fprintf	function
(	O
stream	pointer
,	O
"    return table.get(msgid);\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  public java.util.Enumeration getKeys () {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    return table.keys();\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
if	O
(	O
plurals	int
)	O
{	O
message_ty	struct
*	O
header_entry	pointer
;	O
const	O
struct	O
expression	struct
*	O
plural	pointer
;	O
unsigned	O
long	O
int	O
nplurals	long
;	O
header_entry	pointer
=	O
message_list_search	function
(	O
mlp	pointer
,	O
NULL	O
,	O
""	pointer
)	O
;	O
extract_plural_expression	function
(	O
header_entry	pointer
?	O
header_entry	pointer
->	O
msgstr	pointer
:	O
NULL	O
,	O
&	O
plural	pointer
,	O
&	O
nplurals	long
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  public static long pluralEval (long n) {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    return "	pointer
)	O
;	O
write_java_expression	function
(	O
stream	pointer
,	O
plural	pointer
,	O
false	int
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
";\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
stream	pointer
,	O
"  public java.util.ResourceBundle getParent () {\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"    return parent;\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"  }\n"	pointer
)	O
;	O
fprintf	function
(	O
stream	pointer
,	O
"}\n"	pointer
)	O
;	O
}	O
int	O
msgdomain_write_java	function
(	O
message_list_ty	struct
*	O
mlp	pointer
,	O
const	O
char	O
*	O
canon_encoding	pointer
,	O
const	O
char	O
*	O
resource_name	pointer
,	O
const	O
char	O
*	O
locale_name	pointer
,	O
const	O
char	O
*	O
directory	pointer
,	O
bool	bool
assume_java2	bool
,	O
bool	bool
output_source	bool
)	O
{	O
int	O
retval	int
;	O
struct	O
temp_dir	struct
*	O
tmpdir	pointer
;	O
int	O
ndots	int
;	O
char	O
*	O
class_name	pointer
;	O
char	O
*	O
*	O
subdirs	pointer
;	O
char	O
*	O
java_file_name	pointer
;	O
FILE	struct
*	O
java_file	pointer
;	O
const	O
char	O
*	O
java_sources	pointer
[	O
1	int
]	O
;	O
const	O
char	O
*	O
source_dir_name	pointer
;	O
if	O
(	O
mlp	pointer
->	O
nitems	long
==	O
0	int
)	O
return	O
0	int
;	O
retval	int
=	O
1	int
;	O
iconv_message_list	function
(	O
mlp	pointer
,	O
canon_encoding	pointer
,	O
po_charset_utf8	pointer
,	O
NULL	O
)	O
;	O
message_list_delete_header_field	function
(	O
mlp	pointer
,	O
"POT-Creation-Date:"	pointer
)	O
;	O
if	O
(	O
output_source	bool
)	O
{	O
tmpdir	pointer
=	O
NULL	O
;	O
source_dir_name	pointer
=	O
directory	pointer
;	O
}	O
else	O
{	O
tmpdir	pointer
=	O
create_temp_dir	function
(	O
"msg"	pointer
,	O
NULL	O
,	O
false	int
)	O
;	O
if	O
(	O
tmpdir	pointer
==	O
NULL	O
)	O
goto	O
quit1	O
;	O
source_dir_name	pointer
=	O
tmpdir	pointer
->	O
dir_name	pointer
;	O
}	O
if	O
(	O
resource_name	pointer
==	O
NULL	O
)	O
resource_name	pointer
=	O
"Messages"	pointer
;	O
ndots	int
=	O
check_resource_name	function
(	O
resource_name	pointer
)	O
;	O
if	O
(	O
ndots	int
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"not a valid Java class name: %s"	pointer
)	O
,	O
resource_name	pointer
)	O
;	O
goto	O
quit2	O
;	O
}	O
if	O
(	O
locale_name	pointer
!=	O
NULL	O
)	O
class_name	pointer
=	O
xasprintf	function
(	O
"%s_%s"	pointer
,	O
resource_name	pointer
,	O
locale_name	pointer
)	O
;	O
else	O
class_name	pointer
=	O
xstrdup	function
(	O
resource_name	pointer
)	O
;	O
subdirs	pointer
=	O
(	O
ndots	int
>	O
0	int
?	O
(	O
char	O
*	O
*	O
)	O
xmalloca	O
(	O
ndots	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
:	O
NULL	O
)	O
;	O
{	O
const	O
char	O
*	O
p	pointer
;	O
const	O
char	O
*	O
last_dir	pointer
;	O
int	O
i	long
;	O
last_dir	pointer
=	O
source_dir_name	pointer
;	O
p	pointer
=	O
resource_name	pointer
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ndots	int
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
q	pointer
=	O
strchr	function
(	O
p	pointer
,	O
'.'	O
)	O
;	O
size_t	long
n	long
=	O
q	pointer
-	O
p	pointer
;	O
char	O
*	O
part	pointer
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
n	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
part	pointer
,	O
p	pointer
,	O
n	long
)	O
;	O
part	pointer
[	O
n	long
]	O
=	O
'\0'	O
;	O
subdirs	pointer
[	O
i	long
]	O
=	O
xconcatenated_filename	function
(	O
last_dir	pointer
,	O
part	pointer
,	O
NULL	O
)	O
;	O
freea	function
(	O
part	pointer
)	O
;	O
last_dir	pointer
=	O
subdirs	pointer
[	O
i	long
]	O
;	O
p	pointer
=	O
q	pointer
+	O
1	int
;	O
}	O
if	O
(	O
locale_name	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
suffix	pointer
=	O
xasprintf	function
(	O
"_%s.java"	pointer
,	O
locale_name	pointer
)	O
;	O
java_file_name	pointer
=	O
xconcatenated_filename	function
(	O
last_dir	pointer
,	O
p	pointer
,	O
suffix	pointer
)	O
;	O
free	function
(	O
suffix	pointer
)	O
;	O
}	O
else	O
java_file_name	pointer
=	O
xconcatenated_filename	function
(	O
last_dir	pointer
,	O
p	pointer
,	O
".java"	pointer
)	O
;	O
}	O
if	O
(	O
output_source	bool
)	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ndots	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
mkdir	function
(	O
subdirs	pointer
[	O
i	long
]	O
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IXUSR	O
)	O
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"failed to create \"%s\""	pointer
)	O
,	O
subdirs	pointer
[	O
i	long
]	O
)	O
;	O
goto	O
quit3	O
;	O
}	O
}	O
java_file	pointer
=	O
fopen	function
(	O
java_file_name	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
java_file	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"failed to create \"%s\""	pointer
)	O
,	O
java_file_name	pointer
)	O
;	O
goto	O
quit3	O
;	O
}	O
write_java_code	function
(	O
java_file	pointer
,	O
class_name	pointer
,	O
mlp	pointer
,	O
assume_java2	bool
)	O
;	O
if	O
(	O
fwriteerror	function
(	O
java_file	pointer
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"error while writing \"%s\" file"	pointer
)	O
,	O
java_file_name	pointer
)	O
;	O
goto	O
quit3	O
;	O
}	O
retval	int
=	O
0	int
;	O
goto	O
quit3	O
;	O
}	O
{	O
int	O
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ndots	int
;	O
i	long
++	O
)	O
{	O
register_temp_subdir	function
(	O
tmpdir	pointer
,	O
subdirs	pointer
[	O
i	long
]	O
)	O
;	O
if	O
(	O
mkdir	function
(	O
subdirs	pointer
[	O
i	long
]	O
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IXUSR	O
)	O
<	O
0	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"failed to create \"%s\""	pointer
)	O
,	O
subdirs	pointer
[	O
i	long
]	O
)	O
;	O
unregister_temp_subdir	function
(	O
tmpdir	pointer
,	O
subdirs	pointer
[	O
i	long
]	O
)	O
;	O
goto	O
quit3	O
;	O
}	O
}	O
}	O
register_temp_file	function
(	O
tmpdir	pointer
,	O
java_file_name	pointer
)	O
;	O
java_file	pointer
=	O
fopen_temp	function
(	O
java_file_name	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
java_file	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"failed to create \"%s\""	pointer
)	O
,	O
java_file_name	pointer
)	O
;	O
unregister_temp_file	function
(	O
tmpdir	pointer
,	O
java_file_name	pointer
)	O
;	O
goto	O
quit3	O
;	O
}	O
write_java_code	function
(	O
java_file	pointer
,	O
class_name	pointer
,	O
mlp	pointer
,	O
assume_java2	bool
)	O
;	O
if	O
(	O
fwriteerror_temp	function
(	O
java_file	pointer
)	O
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"error while writing \"%s\" file"	pointer
)	O
,	O
java_file_name	pointer
)	O
;	O
goto	O
quit3	O
;	O
}	O
java_sources	pointer
[	O
0	int
]	O
=	O
java_file_name	pointer
;	O
if	O
(	O
compile_java_class	function
(	O
java_sources	pointer
,	O
1	int
,	O
NULL	O
,	O
0	int
,	O
"1.5"	pointer
,	O
"1.6"	pointer
,	O
directory	pointer
,	O
true	int
,	O
false	int
,	O
true	int
,	O
verbose	bool
>	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
verbose	bool
)	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"compilation of Java class failed, please try --verbose or set $JAVAC"	pointer
)	O
)	O
;	O
else	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"compilation of Java class failed, please try to set $JAVAC"	pointer
)	O
)	O
;	O
goto	O
quit3	O
;	O
}	O
retval	int
=	O
0	int
;	O
quit3	O
:	O
{	O
int	O
i	long
;	O
free	function
(	O
java_file_name	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
ndots	int
;	O
i	long
++	O
)	O
free	function
(	O
subdirs	pointer
[	O
i	long
]	O
)	O
;	O
}	O
freea	function
(	O
subdirs	pointer
)	O
;	O
free	function
(	O
class_name	pointer
)	O
;	O
quit2	O
:	O
if	O
(	O
tmpdir	pointer
!=	O
NULL	O
)	O
cleanup_temp_dir	function
(	O
tmpdir	pointer
)	O
;	O
quit1	O
:	O
return	O
retval	int
;	O
}	O
