static	O
unsigned	O
int	O
loglevel	int
;	O
static	O
int	O
cur_ver	int
=	O
0	int
;	O
static	O
BITCODE_BL	int
rcount1	int
=	O
0	int
,	O
rcount2	int
=	O
0	int
;	O
static	O
int	O
resolve_objectref_vector	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
;	O
static	O
void	O
decode_preR13_section_ptr	function
(	O
const	O
char	O
*	O
restrict	O
name	pointer
,	O
Dwg_Section_Type_r11	enum
id	int
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
;	O
static	O
void	O
decode_preR13_section_chk	function
(	O
Dwg_Section_Type_r11	enum
id	int
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
;	O
static	O
int	O
decode_preR13_section	function
(	O
Dwg_Section_Type_r11	enum
id	int
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
;	O
static	O
int	O
decode_preR13_entities	function
(	O
unsigned	O
long	O
start	struct
,	O
unsigned	O
long	O
end	struct
,	O
unsigned	O
long	O
offset	double
,	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
;	O
static	O
int	O
decode_preR13	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
;	O
static	O
int	O
decode_R13_R2000	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
;	O
static	O
int	O
decode_R2004	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
;	O
static	O
int	O
decode_R2007	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
;	O
static	O
Dwg_Resbuf	struct
*	O
dwg_decode_xdata	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object_XRECORD	struct
*	O
restrict	O
obj	pointer
,	O
BITCODE_BL	int
size	char
)	O
;	O
static	O
int	O
dwg_decode_eed	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object_Object	struct
*	O
restrict	O
obj	pointer
)	O
;	O
static	O
int	O
dwg_decode_ole2	function
(	O
Dwg_Entity_OLE2FRAME	struct
*	O
restrict	O
_obj	pointer
)	O
;	O
static	O
int	O
dwg_decode_object	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
str_dat	pointer
,	O
Dwg_Object_Object	struct
*	O
restrict	O
obj	pointer
)	O
;	O
static	O
int	O
dwg_decode_entity	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
str_dat	pointer
,	O
Dwg_Object_Entity	struct
*	O
restrict	O
ent	pointer
)	O
;	O
static	O
int	O
dwg_decode_common_entity_handle_data	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
;	O
static	O
const	O
char	O
*	O
dwg_ref_objname	function
(	O
const	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
)	O
;	O
static	O
const	O
char	O
*	O
dwg_ref_tblname	function
(	O
const	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
)	O
;	O
int	O
dwg_decode	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
int	O
i	int
;	O
char	O
version	short
[	O
7	int
]	O
;	O
dwg	pointer
->	O
num_object_refs	int
=	O
0	int
;	O
dwg	pointer
->	O
num_entities	int
=	O
0	int
;	O
dwg	pointer
->	O
num_objects	int
=	O
0	int
;	O
dwg	pointer
->	O
num_classes	short
=	O
0	int
;	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
=	O
0	int
;	O
dwg	pointer
->	O
thumbnail	struct
.	O
chain	pointer
=	O
NULL	O
;	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
=	O
0	int
;	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc	int
=	O
0	int
;	O
dwg	pointer
->	O
dwg_class	pointer
=	O
NULL	O
;	O
dwg	pointer
->	O
object_ref	pointer
=	O
NULL	O
;	O
dwg	pointer
->	O
object	pointer
=	O
NULL	O
;	O
dwg	pointer
->	O
object_map	pointer
=	O
hash_new	function
(	O
dat	pointer
->	O
size	char
/	O
1000	int
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
object_map	pointer
)	O
{	O
dwg	pointer
->	O
object_map	pointer
=	O
hash_new	function
(	O
1024	int
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
object_map	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
}	O
dwg	pointer
->	O
dirty_refs	int
=	O
1	int
;	O
memset	function
(	O
&	O
dwg	pointer
->	O
header_vars	struct
,	O
0	int
,	O
sizeof	O
(	O
dwg	pointer
->	O
header_vars	struct
)	O
)	O
;	O
memset	function
(	O
&	O
dwg	pointer
->	O
summaryinfo	struct
,	O
0	int
,	O
sizeof	O
(	O
dwg	pointer
->	O
summaryinfo	struct
)	O
)	O
;	O
memset	function
(	O
&	O
dwg	pointer
->	O
r2004_header	struct
.	O
file_ID_string	array
[	O
0	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
dwg	pointer
->	O
r2004_header	struct
)	O
)	O
;	O
memset	function
(	O
&	O
dwg	pointer
->	O
auxheader	struct
.	O
aux_intro	array
[	O
0	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
dwg	pointer
->	O
auxheader	struct
)	O
)	O
;	O
memset	function
(	O
&	O
dwg	pointer
->	O
second_header	struct
,	O
0	int
,	O
sizeof	O
(	O
dwg	pointer
->	O
second_header	struct
)	O
)	O
;	O
if	O
(	O
dwg	pointer
->	O
opts	int
)	O
{	O
loglevel	int
=	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_LOGLEVEL	int
;	O
dat	pointer
->	O
opts	int
=	O
dwg	pointer
->	O
opts	int
;	O
}	O
dat	pointer
->	O
byte	char
=	O
0	int
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
if	O
(	O
!	O
dat	pointer
->	O
chain	pointer
||	O
dat	pointer
->	O
size	char
<	O
58	int
)	O
{	O
LOG_ERROR	O
(	O
"dwg too small: %lu bytes"	pointer
,	O
dat	pointer
->	O
size	char
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
strncpy	function
(	O
version	short
,	O
(	O
const	O
char	O
*	O
)	O
dat	pointer
->	O
chain	pointer
,	O
6	int
)	O
;	O
version	short
[	O
6	int
]	O
=	O
'\0'	O
;	O
dwg	pointer
->	O
header	struct
.	O
version	short
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
R_AFTER	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
strEQ	O
(	O
version	short
,	O
version_codes	array
[	O
(	O
Dwg_Version_Type	enum
)	O
i	int
]	O
)	O
)	O
{	O
dwg	pointer
->	O
header	struct
.	O
version	short
=	O
(	O
Dwg_Version_Type	enum
)	O
i	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
dwg	pointer
->	O
header	struct
.	O
version	short
)	O
{	O
if	O
(	O
strncmp	function
(	O
version	short
,	O
"AC"	pointer
,	O
2	int
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Invalid DWG, magic: %s"	pointer
,	O
version	short
)	O
;	O
}	O
else	O
{	O
LOG_ERROR	O
(	O
"Invalid or unimplemented DWG version code %s"	pointer
,	O
version	short
)	O
;	O
}	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
dat	pointer
->	O
version	short
=	O
dwg	pointer
->	O
header	struct
.	O
version	short
;	O
dwg	pointer
->	O
header	struct
.	O
from_version	enum
=	O
dat	pointer
->	O
version	short
;	O
dat	pointer
->	O
from_version	enum
=	O
dat	pointer
->	O
version	short
;	O
LOG_INFO	O
(	O
"This file's version code is: %s (%s)\n"	pointer
,	O
version	short
,	O
dwg_version_type	function
(	O
dat	pointer
->	O
version	short
)	O
)	O
PRE	O
(	O
R_13	int
)	O
{	O
LOG_ERROR	O
(	O
WE_CAN	O
"We don't decode many entities and no blocks yet."	pointer
)	O
}	O
VERSIONS	O
(	O
R_13	int
,	O
R_2000	int
)	O
{	O
return	O
decode_R13_R2000	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
VERSION	O
(	O
R_2004	int
)	O
{	O
return	O
decode_R2004	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
VERSION	O
(	O
R_2007	int
)	O
{	O
return	O
decode_R2007	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
SINCE	O
(	O
R_2010	int
)	O
{	O
read_r2007_init	function
(	O
dwg	pointer
)	O
;	O
return	O
decode_R2004	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
LOG_ERROR	O
(	O
"LibreDWG does not support this version: %s."	pointer
,	O
version	short
)	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
static	O
void	O
decode_preR13_section_ptr	function
(	O
const	O
char	O
*	O
restrict	O
name	pointer
,	O
Dwg_Section_Type_r11	enum
id	int
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Section	struct
*	O
tbl	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
id	int
]	O
;	O
tbl	pointer
->	O
size	char
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
tbl	pointer
->	O
number	short
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
tbl	pointer
->	O
address	long
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
strncpy	function
(	O
tbl	pointer
->	O
name	pointer
,	O
name	pointer
,	O
63	int
)	O
;	O
tbl	pointer
->	O
name	pointer
[	O
63	int
]	O
=	O
'\0'	O
;	O
LOG_TRACE	O
(	O
"ptr table %-8s [%2d]: size:%-4u nr:%-2ld (0x%lx-0x%lx)\n"	pointer
,	O
tbl	pointer
->	O
name	pointer
,	O
id	int
,	O
tbl	pointer
->	O
size	char
,	O
(	O
long	O
)	O
tbl	pointer
->	O
number	short
,	O
(	O
unsigned	O
long	O
)	O
tbl	pointer
->	O
address	long
,	O
(	O
unsigned	O
long	O
)	O
(	O
tbl	pointer
->	O
address	long
+	O
(	O
unsigned	O
long	O
)	O
(	O
tbl	pointer
->	O
number	short
*	O
tbl	pointer
->	O
size	char
)	O
)	O
)	O
}	O
static	O
void	O
decode_preR13_section_chk	function
(	O
Dwg_Section_Type_r11	enum
id	int
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Section	struct
*	O
tbl	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
id	int
]	O
;	O
BITCODE_RS	short
id1	short
,	O
size	char
;	O
BITCODE_RL	int
address	long
;	O
BITCODE_RLd	int
number	short
;	O
id1	short
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
size	char
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
CMP	O
(	O
size	char
,	O
RS	O
)	O
;	O
number	short
=	O
(	O
BITCODE_RLd	int
)	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
CMP	O
(	O
number	short
,	O
RL	O
)	O
;	O
address	long
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
CMP	O
(	O
address	long
,	O
RL	O
)	O
LOG_TRACE	O
(	O
"chk table %-8s [%2d]: size:%-4u nr:%-3ld (0x%x)\n"	pointer
,	O
tbl	pointer
->	O
name	pointer
,	O
id	int
,	O
size	char
,	O
(	O
long	O
)	O
tbl	pointer
->	O
number	short
,	O
address	long
)	O
}	O
GCC30_DIAG_IGNORE	O
(	O
-	O
Wformat	O
-	O
nonliteral	O
)	O
static	O
int	O
decode_preR13_section	function
(	O
Dwg_Section_Type_r11	enum
id	int
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Section	struct
*	O
tbl	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
id	int
]	O
;	O
int	O
i	int
;	O
BITCODE_BL	int
vcount	int
;	O
int	O
error	int
=	O
0	int
;	O
long	O
unsigned	O
int	O
num	long
=	O
dwg	pointer
->	O
num_objects	int
;	O
long	O
unsigned	O
int	O
old_size	long
=	O
num	long
*	O
sizeof	O
(	O
Dwg_Object	struct
)	O
;	O
long	O
unsigned	O
int	O
size	char
=	O
tbl	pointer
->	O
number	short
*	O
sizeof	O
(	O
Dwg_Object	struct
)	O
;	O
long	O
unsigned	O
int	O
pos	long
;	O
if	O
(	O
(	O
unsigned	O
)	O
tbl	pointer
->	O
number	short
>	O
100000	int
||	O
size	char
>	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"Invalid table number %ld for %-8s [%2d]"	pointer
,	O
(	O
long	O
)	O
tbl	pointer
->	O
number	short
,	O
tbl	pointer
->	O
name	pointer
,	O
id	int
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
LOG_TRACE	O
(	O
"\ncontents table %-8s [%2d]: size:%-4u nr:%-3ld (0x%lx-0x%lx)\n"	pointer
,	O
tbl	pointer
->	O
name	pointer
,	O
id	int
,	O
tbl	pointer
->	O
size	char
,	O
(	O
long	O
)	O
tbl	pointer
->	O
number	short
,	O
(	O
unsigned	O
long	O
)	O
tbl	pointer
->	O
address	long
,	O
(	O
unsigned	O
long	O
)	O
(	O
tbl	pointer
->	O
address	long
+	O
(	O
(	O
unsigned	O
long	O
long	O
)	O
tbl	pointer
->	O
number	short
*	O
tbl	pointer
->	O
size	char
)	O
)	O
)	O
dat	pointer
->	O
byte	char
=	O
tbl	pointer
->	O
address	long
;	O
if	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
tbl	pointer
->	O
number	short
*	O
tbl	pointer
->	O
size	char
)	O
>	O
dat	pointer
->	O
size	char
-	O
dat	pointer
->	O
byte	char
)	O
{	O
LOG_ERROR	O
(	O
"Invalid table number %ld or size %ld for %-8s [%2d]"	pointer
,	O
(	O
long	O
)	O
tbl	pointer
->	O
number	short
,	O
(	O
long	O
)	O
tbl	pointer
->	O
size	char
,	O
tbl	pointer
->	O
name	pointer
,	O
id	int
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
if	O
(	O
dwg	pointer
->	O
num_objects	int
%	O
REFS_PER_REALLOC	int
==	O
0	int
)	O
dwg	pointer
->	O
object	pointer
=	O
realloc	function
(	O
dwg	pointer
->	O
object	pointer
,	O
old_size	long
+	O
size	char
+	O
REFS_PER_REALLOC	int
)	O
;	O
switch	O
(	O
id	int
)	O
{	O
case	O
SECTION_BLOCK	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tbl	pointer
->	O
number	short
;	O
i	int
++	O
)	O
{	O
PREP_TABLE	O
(	O
BLOCK_HEADER	pointer
)	O
;	O
FIELD_RC	O
(	O
flag	short
,	O
70	int
)	O
;	O
FIELD_TF	O
(	O
name	pointer
,	O
32	int
,	O
2	int
)	O
;	O
FIELD_RS	O
(	O
used	short
,	O
0	int
)	O
;	O
FIELD_RC	O
(	O
block_scaling	char
,	O
0	int
)	O
;	O
FIELD_CAST	O
(	O
num_owned	int
,	O
RS	O
,	O
BL	O
,	O
0	int
)	O
;	O
FIELD_RC	O
(	O
flag2	char
,	O
0	int
)	O
;	O
FIELD_CAST	O
(	O
num_inserts	int
,	O
RS	O
,	O
RL	O
,	O
0	int
)	O
;	O
FIELD_RS	O
(	O
flag3	short
,	O
0	int
)	O
;	O
CHK_ENDPOS	O
;	O
}	O
break	O
;	O
case	O
SECTION_LAYER	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tbl	pointer
->	O
number	short
;	O
i	int
++	O
)	O
{	O
PREP_TABLE	O
(	O
LAYER	pointer
)	O
;	O
FIELD_CAST	O
(	O
flag	short
,	O
RC	O
,	O
RS	O
,	O
70	int
)	O
;	O
FIELD_TF	O
(	O
name	pointer
,	O
32	int
,	O
2	int
)	O
;	O
FIELD_RS	O
(	O
used	short
,	O
0	int
)	O
;	O
FIELD_RS	O
(	O
color_rs	short
,	O
62	int
)	O
;	O
FIELD_RS	O
(	O
ltype_rs	short
,	O
6	int
)	O
;	O
CHK_ENDPOS	O
;	O
}	O
break	O
;	O
case	O
SECTION_STYLE	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tbl	pointer
->	O
number	short
;	O
i	int
++	O
)	O
{	O
PREP_TABLE	O
(	O
STYLE	pointer
)	O
;	O
FIELD_RC	O
(	O
flag	short
,	O
70	int
)	O
;	O
FIELD_TF	O
(	O
name	pointer
,	O
32	int
,	O
2	int
)	O
;	O
FIELD_RS	O
(	O
used	short
,	O
0	int
)	O
;	O
FIELD_RD	O
(	O
fixed_height	double
,	O
40	int
)	O
;	O
FIELD_RD	O
(	O
width_factor	double
,	O
41	int
)	O
;	O
FIELD_RD	O
(	O
oblique_ang	double
,	O
50	int
)	O
;	O
FIELD_RC	O
(	O
generation	short
,	O
71	int
)	O
;	O
FIELD_RD	O
(	O
last_height	double
,	O
42	int
)	O
;	O
FIELD_TF	O
(	O
font_name	pointer
,	O
64	int
,	O
3	int
)	O
;	O
FIELD_TF	O
(	O
bigfont_name	pointer
,	O
64	int
,	O
4	int
)	O
;	O
CHK_ENDPOS	O
;	O
}	O
break	O
;	O
case	O
SECTION_LTYPE	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tbl	pointer
->	O
number	short
;	O
i	int
++	O
)	O
{	O
PREP_TABLE	O
(	O
LTYPE	pointer
)	O
;	O
FIELD_RC	O
(	O
flag	short
,	O
70	int
)	O
;	O
FIELD_TF	O
(	O
name	pointer
,	O
32	int
,	O
2	int
)	O
;	O
FIELD_RS	O
(	O
used	short
,	O
0	int
)	O
;	O
FIELD_TF	O
(	O
description	pointer
,	O
48	int
,	O
3	int
)	O
;	O
FIELD_RC	O
(	O
alignment	char
,	O
72	int
)	O
;	O
FIELD_RC	O
(	O
num_dashes	char
,	O
73	int
)	O
;	O
FIELD_VECTOR	O
(	O
dashes_r11	pointer
,	O
RD	O
,	O
num_dashes	char
,	O
340	int
)	O
;	O
CHK_ENDPOS	O
;	O
}	O
break	O
;	O
case	O
SECTION_VIEW	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tbl	pointer
->	O
number	short
;	O
i	int
++	O
)	O
{	O
PREP_TABLE	O
(	O
VIEW	pointer
)	O
;	O
FIELD_RC	O
(	O
flag	short
,	O
70	int
)	O
;	O
FIELD_TF	O
(	O
name	pointer
,	O
32	int
,	O
2	int
)	O
;	O
FIELD_RS	O
(	O
used	short
,	O
0	int
)	O
;	O
FIELD_RD	O
(	O
height	double
,	O
40	int
)	O
;	O
FIELD_2RD	O
(	O
center	struct
,	O
10	int
)	O
;	O
FIELD_RD	O
(	O
width	double
,	O
41	int
)	O
;	O
FIELD_3RD	O
(	O
target	struct
,	O
12	int
)	O
;	O
FIELD_3RD	O
(	O
direction	struct
,	O
11	int
)	O
;	O
FIELD_CAST	O
(	O
VIEWMODE	char
,	O
RS	O
,	O
4BITS	int
,	O
71	int
)	O
;	O
FIELD_RD	O
(	O
lens_length	double
,	O
42	int
)	O
;	O
FIELD_RD	O
(	O
front_clip	double
,	O
43	int
)	O
;	O
FIELD_RD	O
(	O
back_clip	double
,	O
44	int
)	O
;	O
FIELD_RD	O
(	O
twist_angle	double
,	O
50	int
)	O
;	O
CHK_ENDPOS	O
;	O
}	O
break	O
;	O
case	O
SECTION_UCS	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tbl	pointer
->	O
number	short
;	O
i	int
++	O
)	O
{	O
PREP_TABLE	O
(	O
UCS	pointer
)	O
;	O
FIELD_RC	O
(	O
flag	short
,	O
70	int
)	O
;	O
FIELD_TF	O
(	O
name	pointer
,	O
32	int
,	O
2	int
)	O
;	O
FIELD_RS	O
(	O
used	short
,	O
0	int
)	O
;	O
FIELD_2RD	O
(	O
origin	struct
,	O
10	int
)	O
;	O
FIELD_2RD	O
(	O
x_direction	struct
,	O
11	int
)	O
;	O
FIELD_2RD	O
(	O
y_direction	struct
,	O
12	int
)	O
;	O
CHK_ENDPOS	O
;	O
}	O
break	O
;	O
case	O
SECTION_VPORT	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tbl	pointer
->	O
number	short
;	O
i	int
++	O
)	O
{	O
PREP_TABLE	O
(	O
VPORT	pointer
)	O
;	O
FIELD_RC	O
(	O
flag	short
,	O
70	int
)	O
;	O
FIELD_TF	O
(	O
name	pointer
,	O
32	int
,	O
2	int
)	O
;	O
FIELD_RS	O
(	O
used	short
,	O
0	int
)	O
;	O
FIELD_RD	O
(	O
VIEWSIZE	double
,	O
40	int
)	O
;	O
FIELD_RD	O
(	O
aspect_ratio	double
,	O
41	int
)	O
;	O
FIELD_2RD	O
(	O
VIEWCTR	struct
,	O
12	int
)	O
;	O
FIELD_3RD	O
(	O
view_target	struct
,	O
17	int
)	O
;	O
FIELD_3RD	O
(	O
VIEWDIR	struct
,	O
16	int
)	O
;	O
FIELD_RD	O
(	O
view_twist	double
,	O
50	int
)	O
;	O
FIELD_RD	O
(	O
lens_length	double
,	O
42	int
)	O
;	O
FIELD_RD	O
(	O
front_clip	double
,	O
43	int
)	O
;	O
FIELD_RD	O
(	O
back_clip	double
,	O
33	int
)	O
;	O
FIELD_CAST	O
(	O
VIEWMODE	char
,	O
RS	O
,	O
4BITS	int
,	O
71	int
)	O
;	O
FIELD_2RD	O
(	O
lower_left	struct
,	O
10	int
)	O
;	O
FIELD_2RD	O
(	O
upper_right	struct
,	O
11	int
)	O
;	O
FIELD_RC	O
(	O
UCSFOLLOW	char
,	O
71	int
)	O
;	O
FIELD_RS	O
(	O
circle_zoom	short
,	O
72	int
)	O
;	O
FIELD_RC	O
(	O
FASTZOOM	char
,	O
73	int
)	O
;	O
FIELD_RC	O
(	O
UCSICON	char
,	O
74	int
)	O
;	O
FIELD_RC	O
(	O
GRIDMODE	short
,	O
76	int
)	O
;	O
FIELD_2RD	O
(	O
GRIDUNIT	struct
,	O
15	int
)	O
;	O
FIELD_CAST	O
(	O
SNAPMODE	short
,	O
RS	O
,	O
B	O
,	O
70	int
)	O
;	O
FIELD_RC	O
(	O
SNAPSTYLE	char
,	O
70	int
)	O
;	O
FIELD_RS	O
(	O
SNAPISOPAIR	short
,	O
78	int
)	O
;	O
FIELD_RD	O
(	O
SNAPANG	double
,	O
50	int
)	O
;	O
FIELD_2RD	O
(	O
SNAPBASE	struct
,	O
13	int
)	O
;	O
FIELD_2RD	O
(	O
SNAPUNIT	struct
,	O
14	int
)	O
;	O
CHK_ENDPOS	O
;	O
}	O
break	O
;	O
case	O
SECTION_APPID	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tbl	pointer
->	O
number	short
;	O
i	int
++	O
)	O
{	O
PREP_TABLE	O
(	O
APPID	pointer
)	O
;	O
FIELD_RC	O
(	O
flag	short
,	O
70	int
)	O
;	O
FIELD_TF	O
(	O
name	pointer
,	O
32	int
,	O
2	int
)	O
;	O
FIELD_RS	O
(	O
used	short
,	O
0	int
)	O
;	O
CHK_ENDPOS	O
;	O
}	O
break	O
;	O
case	O
SECTION_DIMSTYLE	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
tbl	pointer
->	O
number	short
;	O
i	int
++	O
)	O
{	O
PREP_TABLE	O
(	O
DIMSTYLE	pointer
)	O
;	O
FIELD_RC	O
(	O
flag	short
,	O
70	int
)	O
;	O
FIELD_TF	O
(	O
name	pointer
,	O
32	int
,	O
2	int
)	O
;	O
FIELD_RS	O
(	O
used	short
,	O
0	int
)	O
;	O
FIELD_RD	O
(	O
DIMSCALE	double
,	O
40	int
)	O
;	O
FIELD_RD	O
(	O
DIMASZ	double
,	O
41	int
)	O
;	O
FIELD_RD	O
(	O
DIMEXO	double
,	O
42	int
)	O
;	O
FIELD_RD	O
(	O
DIMDLI	double
,	O
43	int
)	O
;	O
FIELD_RD	O
(	O
DIMEXE	double
,	O
44	int
)	O
;	O
FIELD_RD	O
(	O
DIMRND	double
,	O
45	int
)	O
;	O
FIELD_RD	O
(	O
DIMDLE	double
,	O
46	int
)	O
;	O
FIELD_RD	O
(	O
DIMTP	double
,	O
47	int
)	O
;	O
FIELD_RD	O
(	O
DIMTM	double
,	O
48	int
)	O
;	O
FIELD_RD	O
(	O
DIMTXT	double
,	O
140	int
)	O
;	O
FIELD_RD	O
(	O
DIMCEN	double
,	O
141	int
)	O
;	O
FIELD_RD	O
(	O
DIMTSZ	double
,	O
142	int
)	O
;	O
FIELD_RD	O
(	O
DIMALTF	double
,	O
143	int
)	O
;	O
FIELD_RD	O
(	O
DIMLFAC	double
,	O
144	int
)	O
;	O
FIELD_RD	O
(	O
DIMTVP	double
,	O
145	int
)	O
;	O
FIELD_RC	O
(	O
DIMTOL	char
,	O
71	int
)	O
;	O
FIELD_RC	O
(	O
DIMLIM	char
,	O
72	int
)	O
;	O
FIELD_RC	O
(	O
DIMTIH	char
,	O
73	int
)	O
;	O
FIELD_RC	O
(	O
DIMTOH	char
,	O
74	int
)	O
;	O
FIELD_RC	O
(	O
DIMSE1	char
,	O
75	int
)	O
;	O
FIELD_RC	O
(	O
DIMSE2	char
,	O
76	int
)	O
;	O
FIELD_CAST	O
(	O
DIMTAD	short
,	O
RC	O
,	O
RS	O
,	O
77	int
)	O
;	O
FIELD_CAST	O
(	O
DIMZIN	short
,	O
RC	O
,	O
BS	O
,	O
78	int
)	O
;	O
FIELD_RC	O
(	O
DIMALT	char
,	O
170	int
)	O
;	O
FIELD_CAST	O
(	O
DIMALTD	short
,	O
RC	O
,	O
BS	O
,	O
171	int
)	O
;	O
FIELD_RC	O
(	O
DIMTOFL	char
,	O
172	int
)	O
;	O
FIELD_RC	O
(	O
DIMSAH	char
,	O
173	int
)	O
;	O
FIELD_RC	O
(	O
DIMTIX	char
,	O
174	int
)	O
;	O
FIELD_RC	O
(	O
DIMSOXD	char
,	O
175	int
)	O
;	O
FIELD_TF	O
(	O
DIMPOST	pointer
,	O
16	int
,	O
3	int
)	O
;	O
FIELD_TF	O
(	O
DIMAPOST	pointer
,	O
16	int
,	O
4	int
)	O
;	O
FIELD_TF	O
(	O
DIMBLK_T	pointer
,	O
16	int
,	O
5	int
)	O
;	O
FIELD_TF	O
(	O
DIMBLK1_T	pointer
,	O
16	int
,	O
6	int
)	O
;	O
FIELD_TF	O
(	O
DIMBLK2_T	pointer
,	O
66	int
,	O
7	int
)	O
;	O
FIELD_RS	O
(	O
DIMCLRD_N	short
,	O
176	int
)	O
;	O
FIELD_RS	O
(	O
DIMCLRE_N	short
,	O
177	int
)	O
;	O
FIELD_RS	O
(	O
DIMCLRT_N	short
,	O
178	int
)	O
;	O
FIELD_RC	O
(	O
DIMUPT	char
,	O
0	int
)	O
;	O
FIELD_RD	O
(	O
DIMTFAC	double
,	O
146	int
)	O
;	O
FIELD_RD	O
(	O
DIMGAP	double
,	O
147	int
)	O
;	O
CHK_ENDPOS	O
;	O
}	O
break	O
;	O
case	O
SECTION_VPORT_ENTITY	int
:	O
if	O
(	O
tbl	pointer
->	O
number	short
)	O
{	O
LOG_WARN	O
(	O
"VPORT_ENTITY table ignored"	pointer
)	O
;	O
tbl	pointer
->	O
number	short
=	O
0	int
;	O
}	O
break	O
;	O
case	O
SECTION_HEADER_R11	int
:	O
default	O
:	O
LOG_ERROR	O
(	O
"Invalid table id %d"	pointer
,	O
id	int
)	O
;	O
tbl	pointer
->	O
number	short
=	O
0	int
;	O
break	O
;	O
}	O
dwg	pointer
->	O
num_objects	int
+=	O
tbl	pointer
->	O
number	short
;	O
dat	pointer
->	O
byte	char
=	O
tbl	pointer
->	O
address	long
+	O
(	O
tbl	pointer
->	O
number	short
*	O
tbl	pointer
->	O
size	char
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
decode_entity_preR13	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dwg_Object_Entity	struct
*	O
ent	pointer
)	O
{	O
Dwg_Object_Entity	struct
*	O
_obj	pointer
=	O
ent	pointer
;	O
obj	pointer
->	O
type	short
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
_obj	pointer
->	O
flag_r11	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
obj	pointer
->	O
size	char
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
LOG_INFO	O
(	O
"\n===========================\n"	pointer
"Entity number: %d, Type: %d, Size: %d\n"	pointer
,	O
obj	pointer
->	O
index	short
,	O
obj	pointer
->	O
type	short
,	O
obj	pointer
->	O
size	char
)	O
;	O
LOG_TRACE	O
(	O
"flag_r11: "	pointer
FORMAT_RC	pointer
"\n"	pointer
,	O
_obj	pointer
->	O
flag_r11	char
)	O
;	O
FIELD_RS	O
(	O
layer_r11	short
,	O
8	int
)	O
;	O
FIELD_RS	O
(	O
opts_r11	short
,	O
0	int
)	O
;	O
if	O
(	O
ent	pointer
->	O
flag_r11	char
&	O
1	int
)	O
{	O
FIELD_RC	O
(	O
color_r11	char
,	O
0	int
)	O
;	O
}	O
if	O
(	O
ent	pointer
->	O
flag_r11	char
&	O
0x40	int
)	O
{	O
FIELD_RC	O
(	O
extra_r11	char
,	O
0	int
)	O
;	O
}	O
if	O
(	O
ent	pointer
->	O
extra_r11	char
&	O
2	int
)	O
{	O
int	O
error	int
=	O
dwg_decode_eed	function
(	O
dat	pointer
,	O
(	O
Dwg_Object_Object	struct
*	O
)	O
ent	pointer
)	O
;	O
if	O
(	O
error	int
&	O
(	O
DWG_ERR_INVALIDEED	int
|	O
DWG_ERR_VALUEOUTOFBOUNDS	int
)	O
)	O
return	O
error	int
;	O
}	O
if	O
(	O
FIELD_VALUE	O
(	O
flag_r11	char
)	O
&	O
2	int
)	O
FIELD_RS	O
(	O
kind_r11	short
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
AFL_GCC_TOOBIG	O
static	O
int	O
decode_preR13	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
BITCODE_RL	int
entities_start	int
,	O
entities_end	int
,	O
blocks_start	int
,	O
blocks_end	int
;	O
BITCODE_RL	int
rl1	int
,	O
rl2	int
;	O
BITCODE_RS	short
rs2	short
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
int	O
tbl_id	int
;	O
int	O
error	int
=	O
0	int
;	O
{	O
int	O
i	int
;	O
struct	O
Dwg_Header	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
;	O
Bit_Chain	struct
*	O
hdl_dat	pointer
=	O
dat	pointer
;	O
dat	pointer
->	O
byte	char
=	O
0x06	int
;	O
}	O
LOG_TRACE	O
(	O
"@0x%lx\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
=	O
12	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
=	O
(	O
Dwg_Section	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Section	struct
)	O
*	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
entities_start	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
entities_end	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"entities 0x%x - 0x%x\n"	pointer
,	O
entities_start	int
,	O
entities_end	int
)	O
;	O
blocks_start	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
blocks_end	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
rl2	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"blocks   0x%x (0x%x) - 0x%x (0x%x)\n"	pointer
,	O
blocks_start	int
,	O
rl1	int
,	O
blocks_end	int
,	O
rl2	int
)	O
;	O
tbl_id	int
=	O
0	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
0	int
]	O
.	O
number	short
=	O
0	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
0	int
]	O
.	O
type	short
=	O
(	O
Dwg_Section_Type	enum
)	O
SECTION_HEADER_R11	int
;	O
strcpy	function
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
0	int
]	O
.	O
name	pointer
,	O
"HEADER"	pointer
)	O
;	O
decode_preR13_section_ptr	function
(	O
"BLOCK"	pointer
,	O
SECTION_BLOCK	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_ptr	function
(	O
"LAYER"	pointer
,	O
SECTION_LAYER	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_ptr	function
(	O
"STYLE"	pointer
,	O
SECTION_STYLE	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_ptr	function
(	O
"LTYPE"	pointer
,	O
SECTION_LTYPE	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_ptr	function
(	O
"VIEW"	pointer
,	O
SECTION_VIEW	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_BLOCK	int
]	O
.	O
size	char
>	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"BLOCK.size overflow"	pointer
)	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
LOG_TRACE	O
(	O
"@0x%lx\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
{	O
Dwg_Header_Variables	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
header_vars	struct
;	O
Bit_Chain	struct
*	O
hdl_dat	pointer
=	O
dat	pointer
;	O
}	O
LOG_TRACE	O
(	O
"@0x%lx\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
dat	pointer
->	O
byte	char
=	O
0x3ef	int
;	O
LOG_TRACE	O
(	O
"@0x%lx\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
decode_preR13_section_ptr	function
(	O
"UCS"	pointer
,	O
SECTION_UCS	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
dat	pointer
->	O
byte	char
=	O
0x500	int
;	O
LOG_TRACE	O
(	O
"@0x%lx\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
decode_preR13_section_ptr	function
(	O
"VPORT"	pointer
,	O
SECTION_VPORT	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
rl2	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"?2 long: 0x%x 0x%x\n"	pointer
,	O
rl1	int
,	O
rl2	int
)	O
;	O
decode_preR13_section_ptr	function
(	O
"APPID"	pointer
,	O
SECTION_APPID	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
rs2	short
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"?long+short: 0x%x 0x%x\n"	pointer
,	O
rl1	int
,	O
(	O
unsigned	O
)	O
rs2	short
)	O
;	O
decode_preR13_section_ptr	function
(	O
"DIMSTYLE"	pointer
,	O
SECTION_DIMSTYLE	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
dat	pointer
->	O
byte	char
=	O
0x69f	int
;	O
decode_preR13_section_ptr	function
(	O
"VPORT_ENTITY"	pointer
,	O
SECTION_VPORT_ENTITY	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
dat	pointer
->	O
byte	char
+=	O
38	int
;	O
error	int
|=	O
decode_preR13_entities	function
(	O
entities_start	int
,	O
entities_end	int
,	O
0	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
return	O
error	int
;	O
dat	pointer
->	O
byte	char
+=	O
19	int
;	O
error	int
|=	O
decode_preR13_section	function
(	O
SECTION_BLOCK	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
error	int
|=	O
decode_preR13_section	function
(	O
SECTION_LAYER	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
error	int
|=	O
decode_preR13_section	function
(	O
SECTION_STYLE	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
error	int
|=	O
decode_preR13_section	function
(	O
SECTION_LTYPE	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
error	int
|=	O
decode_preR13_section	function
(	O
SECTION_VIEW	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
error	int
|=	O
decode_preR13_section	function
(	O
SECTION_UCS	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
error	int
|=	O
decode_preR13_section	function
(	O
SECTION_VPORT	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
error	int
|=	O
decode_preR13_section	function
(	O
SECTION_APPID	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
error	int
|=	O
decode_preR13_section	function
(	O
SECTION_DIMSTYLE	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
error	int
|=	O
decode_preR13_section	function
(	O
SECTION_VPORT_ENTITY	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
return	O
error	int
;	O
error	int
|=	O
decode_preR13_entities	function
(	O
blocks_start	int
,	O
blocks_end	int
,	O
blocks_start	int
-	O
0x40000000	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
return	O
error	int
;	O
LOG_TRACE	O
(	O
"@0x%lx\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
rl2	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"?2long: 0x%x 0x%x %f\n"	pointer
,	O
rl1	int
,	O
rl2	int
,	O
(	O
double	O
)	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
-	O
8	int
]	O
)	O
;	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
rl2	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"?2long: 0x%x 0x%x %f\n"	pointer
,	O
rl1	int
,	O
rl2	int
,	O
(	O
double	O
)	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
-	O
8	int
]	O
)	O
;	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
rl2	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"?2long: 0x%x 0x%x %f\n"	pointer
,	O
rl1	int
,	O
rl2	int
,	O
(	O
double	O
)	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
-	O
8	int
]	O
)	O
;	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
rl2	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"?2long: 0x%x 0x%x %f\n"	pointer
,	O
rl1	int
,	O
rl2	int
,	O
(	O
double	O
)	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
-	O
8	int
]	O
)	O
;	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"?1long: 0x%x\n"	pointer
,	O
rl1	int
)	O
;	O
LOG_TRACE	O
(	O
"@0x%lx: 4 block ptrs chk\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
if	O
(	O
(	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
)	O
!=	O
entities_start	int
)	O
{	O
LOG_WARN	O
(	O
"entities_start %x/%x"	pointer
,	O
rl1	int
,	O
entities_start	int
)	O
;	O
}	O
if	O
(	O
(	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
)	O
!=	O
entities_end	int
)	O
{	O
LOG_WARN	O
(	O
"entities_end %x/%x"	pointer
,	O
rl1	int
,	O
entities_end	int
)	O
;	O
}	O
if	O
(	O
(	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
)	O
!=	O
blocks_start	int
)	O
{	O
LOG_WARN	O
(	O
"blocks_start %x/%x"	pointer
,	O
rl1	int
,	O
blocks_start	int
)	O
;	O
}	O
if	O
(	O
(	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
)	O
!=	O
blocks_end	int
)	O
{	O
LOG_WARN	O
(	O
"blocks_end %x/%x"	pointer
,	O
rl1	int
,	O
blocks_end	int
)	O
;	O
}	O
LOG_TRACE	O
(	O
"@0x%lx\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
rl2	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"?2long: 0x%x 0x%x\n"	pointer
,	O
rl1	int
,	O
rl2	int
)	O
;	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"?1long: 0x%x\n"	pointer
,	O
rl1	int
)	O
;	O
dat	pointer
->	O
byte	char
=	O
blocks_end	int
+	O
36	int
+	O
4	int
*	O
4	int
+	O
12	int
;	O
LOG_TRACE	O
(	O
"@0x%lx\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
decode_preR13_section_chk	function
(	O
SECTION_BLOCK	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_chk	function
(	O
SECTION_LAYER	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_chk	function
(	O
SECTION_STYLE	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_chk	function
(	O
SECTION_LTYPE	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_chk	function
(	O
SECTION_VIEW	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_chk	function
(	O
SECTION_UCS	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_chk	function
(	O
SECTION_VPORT	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_chk	function
(	O
SECTION_APPID	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_chk	function
(	O
SECTION_DIMSTYLE	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
decode_preR13_section_chk	function
(	O
SECTION_VPORT_ENTITY	int
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
rl1	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"long 0x%x\n"	pointer
,	O
rl1	int
)	O
;	O
return	O
0	int
;	O
}	O
AFL_GCC_POP	O
static	O
int	O
decode_R13_R2000	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
unsigned	O
int	O
section_size	int
=	O
0	int
;	O
unsigned	O
char	O
sgdc	array
[	O
2	int
]	O
;	O
unsigned	O
int	O
crc	int
,	O
crc2	int
;	O
long	O
unsigned	O
int	O
size	char
;	O
long	O
unsigned	O
int	O
lasta	long
;	O
long	O
unsigned	O
int	O
lastmap	long
;	O
long	O
unsigned	O
int	O
startpos	long
;	O
long	O
unsigned	O
int	O
object_begin	long
;	O
long	O
unsigned	O
int	O
object_end	long
;	O
long	O
unsigned	O
int	O
pvz	long
;	O
BITCODE_BL	int
j	int
,	O
k	int
;	O
int	O
error	int
=	O
0	int
;	O
const	O
char	O
*	O
section_names	array
[	O
]	O
=	O
{	O
"AcDb:Header"	pointer
,	O
"AcDb:Classes"	pointer
,	O
"AcDb:Handles"	pointer
,	O
"2NDHEADER"	pointer
,	O
"MEASUREMENT"	pointer
,	O
"AcDb:AuxHeader"	pointer
}	O
;	O
{	O
int	O
i	int
;	O
struct	O
Dwg_Header	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
;	O
Bit_Chain	struct
*	O
hdl_dat	pointer
=	O
dat	pointer
;	O
dat	pointer
->	O
byte	char
=	O
0x06	int
;	O
}	O
assert	O
(	O
dat	pointer
->	O
byte	char
==	O
0x15	int
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"\nnum_sections: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
)	O
if	O
(	O
!	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
)	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
=	O
6	int
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
<	O
3	int
)	O
{	O
LOG_ERROR	O
(	O
"Not enough sections: "	pointer
FORMAT_RL	O
,	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
>	O
10	int
)	O
{	O
LOG_ERROR	O
(	O
"Too many sections: "	pointer
FORMAT_RL	O
,	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
=	O
(	O
Dwg_Section	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Section	struct
)	O
*	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
;	O
j	int
++	O
)	O
{	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
number	short
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
address	long
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
size	char
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
j	int
<	O
6	int
)	O
strcpy	function
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
name	pointer
,	O
section_names	array
[	O
j	int
]	O
)	O
;	O
LOG_TRACE	O
(	O
"section[%u].number:  %4d [RC] %s\n"	pointer
,	O
j	int
,	O
(	O
int	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
number	short
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
name	pointer
)	O
LOG_TRACE	O
(	O
"section[%u].address: %4u [RL]\n"	pointer
,	O
j	int
,	O
(	O
unsigned	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
address	long
)	O
LOG_TRACE	O
(	O
"section[%u].size:    %4u [RL]\n"	pointer
,	O
j	int
,	O
(	O
unsigned	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
size	char
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
address	long
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
j	int
]	O
.	O
size	char
>	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"section[%u] address or size overflow"	pointer
,	O
j	int
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
}	O
crc2	int
=	O
bit_calc_CRC	function
(	O
0xC0C1	int
,	O
&	O
dat	pointer
->	O
chain	pointer
[	O
0	int
]	O
,	O
dat	pointer
->	O
byte	char
)	O
;	O
crc	int
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"crc: %04X [RSx] from 0-%lu\n"	pointer
,	O
crc	int
,	O
dat	pointer
->	O
byte	char
-	O
2	int
)	O
;	O
if	O
(	O
crc	int
!=	O
crc2	int
)	O
{	O
LOG_ERROR	O
(	O
"Header CRC mismatch %04X <=> %04X"	pointer
,	O
crc	int
,	O
crc2	int
)	O
;	O
error	int
|=	O
DWG_ERR_WRONGCRC	int
;	O
}	O
if	O
(	O
bit_search_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_HEADER_END	int
)	O
)	O
)	O
LOG_TRACE	O
(	O
"         HEADER (end):    %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
==	O
6	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2000	int
)	O
{	O
int	O
i	int
;	O
struct	O
Dwg_AuxHeader	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
auxheader	struct
;	O
Bit_Chain	struct
*	O
hdl_dat	pointer
=	O
dat	pointer
;	O
BITCODE_BL	int
end_address	int
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_AUXHEADER_R2000	int
]	O
.	O
address	long
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_AUXHEADER_R2000	int
]	O
.	O
size	char
;	O
obj	pointer
=	O
NULL	O
;	O
dat	pointer
->	O
byte	char
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_AUXHEADER_R2000	int
]	O
.	O
address	long
;	O
LOG_TRACE	O
(	O
"\n"	pointer
"=======> AuxHeader:       %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
dat	pointer
->	O
byte	char
)	O
LOG_TRACE	O
(	O
"         AuxHeader (end): %4u\n"	pointer
,	O
(	O
unsigned	O
)	O
end_address	int
)	O
if	O
(	O
dat	pointer
->	O
size	char
<	O
end_address	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid AuxHeader size: buffer overflow"	pointer
)	O
error	int
|=	O
DWG_ERR_SECTIONNOTFOUND	int
;	O
}	O
else	O
{	O
BITCODE_BL	int
old_size	long
=	O
dat	pointer
->	O
size	char
;	O
dat	pointer
->	O
size	char
=	O
end_address	int
;	O
dat	pointer
->	O
size	char
=	O
old_size	long
;	O
}	O
}	O
if	O
(	O
bit_search_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_THUMBNAIL_BEGIN	int
)	O
)	O
)	O
{	O
unsigned	O
long	O
int	O
start_address	long
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
start_address	long
=	O
dat	pointer
->	O
byte	char
;	O
LOG_TRACE	O
(	O
"\n=======> Thumbnail:       %4u\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
start_address	long
-	O
16	int
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
&&	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
!=	O
dat	pointer
->	O
byte	char
-	O
16	int
)	O
LOG_WARN	O
(	O
"Illegal HEADER.thumbnail_address: %i != %lu"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
,	O
dat	pointer
->	O
byte	char
-	O
16	int
)	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
=	O
dat	pointer
->	O
byte	char
-	O
16	int
;	O
if	O
(	O
bit_search_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_THUMBNAIL_END	int
)	O
)	O
)	O
{	O
BITCODE_RL	int
bmpsize	int
;	O
LOG_TRACE	O
(	O
"         Thumbnail (end): %4u\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
dat	pointer
->	O
byte	char
)	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
=	O
(	O
dat	pointer
->	O
byte	char
-	O
16	int
)	O
-	O
start_address	long
;	O
dwg	pointer
->	O
thumbnail	struct
.	O
chain	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
calloc	function
(	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
,	O
1	int
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
thumbnail	struct
.	O
chain	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
memcpy	function
(	O
dwg	pointer
->	O
thumbnail	struct
.	O
chain	pointer
,	O
&	O
dat	pointer
->	O
chain	pointer
[	O
start_address	long
]	O
,	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
;	O
dat	pointer
->	O
byte	char
+=	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
;	O
dwg_bmp	function
(	O
dwg	pointer
,	O
&	O
bmpsize	int
)	O
;	O
if	O
(	O
bmpsize	int
>	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
LOG_ERROR	O
(	O
"BMP size overflow: %i > %lu\n"	pointer
,	O
bmpsize	int
,	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
}	O
}	O
LOG_INFO	O
(	O
"\n"	pointer
"=======> Header Variables:         %4u\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
address	long
)	O
LOG_INFO	O
(	O
"         Header Variables   (end): %4u\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
address	long
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
size	char
)	O
)	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
address	long
<	O
58	int
||	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
address	long
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
size	char
>	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"Invalid Header section, skipped"	pointer
)	O
error	int
|=	O
DWG_ERR_SECTIONNOTFOUND	int
;	O
goto	O
classes_section	O
;	O
}	O
dat	pointer
->	O
byte	char
=	O
pvz	long
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
address	long
+	O
16	int
;	O
dwg	pointer
->	O
header_vars	struct
.	O
size	char
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"         Length: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
dwg	pointer
->	O
header_vars	struct
.	O
size	char
)	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
dwg_decode_header_variables	function
(	O
dat	pointer
,	O
dat	pointer
,	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
bit	char
||	O
dat	pointer
->	O
byte	char
!=	O
pvz	long
+	O
dwg	pointer
->	O
header_vars	struct
.	O
size	char
+	O
4	int
)	O
{	O
unsigned	O
char	O
r	char
=	O
8	int
-	O
dat	pointer
->	O
bit	char
;	O
LOG_HANDLE	O
(	O
" padding: %ld byte, %d bits\n"	pointer
,	O
pvz	long
+	O
dwg	pointer
->	O
header_vars	struct
.	O
size	char
+	O
4	int
-	O
dat	pointer
->	O
byte	char
,	O
r	char
)	O
;	O
}	O
LOG_HANDLE	O
(	O
" crc pos: %lu\n"	pointer
,	O
pvz	long
+	O
dwg	pointer
->	O
header_vars	struct
.	O
size	char
+	O
4	int
)	O
;	O
bit_set_position	function
(	O
dat	pointer
,	O
(	O
pvz	long
+	O
dwg	pointer
->	O
header_vars	struct
.	O
size	char
+	O
4	int
)	O
*	O
8	int
)	O
;	O
crc	int
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"crc: %04X [RSx] from %lu-%lu=%ld\n"	pointer
,	O
crc	int
,	O
pvz	long
,	O
dat	pointer
->	O
byte	char
-	O
2	int
,	O
dat	pointer
->	O
byte	char
-	O
2	int
-	O
pvz	long
)	O
;	O
crc2	int
=	O
0	int
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
size	char
>	O
34	int
&&	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
size	char
<	O
0xfff	int
&&	O
pvz	long
<	O
dat	pointer
->	O
byte	char
&&	O
pvz	long
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
size	char
<	O
dat	pointer
->	O
size	char
)	O
{	O
BITCODE_RL	int
crc_size	int
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
size	char
-	O
34	int
;	O
LOG_HANDLE	O
(	O
" calc Header crc size: "	pointer
FORMAT_RL	O
"\n"	pointer
,	O
crc_size	int
)	O
;	O
crc2	int
=	O
bit_calc_CRC	function
(	O
0xC0C1	int
,	O
&	O
dat	pointer
->	O
chain	pointer
[	O
pvz	long
]	O
,	O
crc_size	int
)	O
;	O
}	O
if	O
(	O
crc	int
!=	O
crc2	int
)	O
{	O
LOG_WARN	O
(	O
"Header Section[%ld] CRC mismatch %04X <=> %04X"	pointer
,	O
(	O
long	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HEADER_R13	int
]	O
.	O
number	short
,	O
crc	int
,	O
crc2	int
)	O
;	O
error	int
|=	O
DWG_ERR_WRONGCRC	int
;	O
}	O
classes_section	O
:	O
LOG_INFO	O
(	O
"\n"	pointer
"=======> CLASS (start): %4lu\n"	pointer
,	O
(	O
long	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_CLASSES_R13	int
]	O
.	O
address	long
)	O
LOG_INFO	O
(	O
"         CLASS (end)  : %4lu\n"	pointer
,	O
(	O
long	O
)	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_CLASSES_R13	int
]	O
.	O
address	long
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_CLASSES_R13	int
]	O
.	O
size	char
)	O
)	O
dat	pointer
->	O
byte	char
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_CLASSES_R13	int
]	O
.	O
address	long
+	O
16	int
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
size	char
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
lasta	long
=	O
dat	pointer
->	O
byte	char
+	O
size	char
;	O
LOG_TRACE	O
(	O
"         Length: %lu [RL]\n"	pointer
,	O
size	char
)	O
;	O
dwg	pointer
->	O
layout_type	int
=	O
0	int
;	O
dwg	pointer
->	O
num_classes	short
=	O
0	int
;	O
do	O
{	O
BITCODE_BS	short
i	int
;	O
Dwg_Class	struct
*	O
klass	pointer
;	O
i	int
=	O
dwg	pointer
->	O
num_classes	short
;	O
if	O
(	O
i	int
==	O
0	int
)	O
dwg	pointer
->	O
dwg_class	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
Dwg_Class	struct
)	O
)	O
;	O
else	O
dwg	pointer
->	O
dwg_class	pointer
=	O
realloc	function
(	O
dwg	pointer
->	O
dwg_class	pointer
,	O
(	O
i	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
Dwg_Class	struct
)	O
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
dwg_class	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
klass	pointer
=	O
&	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
;	O
memset	function
(	O
klass	pointer
,	O
0	int
,	O
sizeof	O
(	O
Dwg_Class	struct
)	O
)	O
;	O
klass	pointer
->	O
number	short
=	O
bit_read_BS	function
(	O
dat	pointer
)	O
;	O
klass	pointer
->	O
proxyflag	short
=	O
bit_read_BS	function
(	O
dat	pointer
)	O
;	O
klass	pointer
->	O
appname	pointer
=	O
bit_read_TV	function
(	O
dat	pointer
)	O
;	O
klass	pointer
->	O
cppname	pointer
=	O
bit_read_TV	function
(	O
dat	pointer
)	O
;	O
klass	pointer
->	O
dxfname	pointer
=	O
bit_read_TV	function
(	O
dat	pointer
)	O
;	O
klass	pointer
->	O
is_zombie	char
=	O
bit_read_B	function
(	O
dat	pointer
)	O
;	O
klass	pointer
->	O
item_class_id	short
=	O
bit_read_BS	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"Class %d 0x%x %s\n"	pointer
" %s \"%s\" %d 0x%x\n"	pointer
,	O
klass	pointer
->	O
number	short
,	O
klass	pointer
->	O
proxyflag	short
,	O
klass	pointer
->	O
dxfname	pointer
,	O
klass	pointer
->	O
cppname	pointer
,	O
klass	pointer
->	O
appname	pointer
,	O
klass	pointer
->	O
is_zombie	char
,	O
klass	pointer
->	O
item_class_id	short
)	O
if	O
(	O
klass	pointer
->	O
dxfname	pointer
&&	O
strEQc	O
(	O
(	O
const	O
char	O
*	O
)	O
klass	pointer
->	O
dxfname	pointer
,	O
"LAYOUT"	pointer
)	O
)	O
dwg	pointer
->	O
layout_type	int
=	O
klass	pointer
->	O
number	short
;	O
dwg	pointer
->	O
num_classes	short
++	O
;	O
if	O
(	O
dwg	pointer
->	O
num_classes	short
>	O
500	int
)	O
{	O
LOG_ERROR	O
(	O
"number of classes is greater than 500"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
while	O
(	O
dat	pointer
->	O
byte	char
<	O
(	O
lasta	long
-	O
1	int
)	O
)	O
;	O
dat	pointer
->	O
byte	char
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_CLASSES_R13	int
]	O
.	O
address	long
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_CLASSES_R13	int
]	O
.	O
size	char
-	O
18	int
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
pvz	long
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_CLASSES_R13	int
]	O
.	O
address	long
+	O
16	int
;	O
if	O
(	O
!	O
bit_check_CRC	function
(	O
dat	pointer
,	O
pvz	long
,	O
0xC0C1	int
)	O
)	O
error	int
|=	O
DWG_ERR_WRONGCRC	int
;	O
dat	pointer
->	O
byte	char
+=	O
16	int
;	O
pvz	long
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"unknown: 0x%04lx [RL] @%lu\n"	pointer
,	O
pvz	long
,	O
dat	pointer
->	O
byte	char
-	O
4	int
)	O
LOG_INFO	O
(	O
"Number of classes read: %u\n"	pointer
,	O
dwg	pointer
->	O
num_classes	short
)	O
dat	pointer
->	O
byte	char
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
address	long
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
lastmap	long
=	O
dat	pointer
->	O
byte	char
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
size	char
;	O
dwg	pointer
->	O
num_objects	int
=	O
0	int
;	O
object_begin	long
=	O
dat	pointer
->	O
size	char
;	O
object_end	long
=	O
0	int
;	O
LOG_INFO	O
(	O
"\n"	pointer
"=======> Handles (start) : %8u\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
address	long
)	O
LOG_INFO	O
(	O
"         Handles (end)   : %8u\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
address	long
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
size	char
)	O
)	O
LOG_INFO	O
(	O
"         Length: %u\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
size	char
)	O
do	O
{	O
long	O
unsigned	O
int	O
last_offset	long
=	O
0	int
;	O
long	O
unsigned	O
int	O
last_handle	long
=	O
0	int
;	O
long	O
unsigned	O
int	O
oldpos	long
=	O
0	int
;	O
long	O
unsigned	O
int	O
maxh	long
=	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
size	char
<<	O
1	int
;	O
BITCODE_BL	int
max_handles	int
=	O
maxh	long
<	O
INT32_MAX	O
?	O
(	O
BITCODE_BL	int
)	O
maxh	long
:	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
size	char
;	O
int	O
added	int
;	O
startpos	long
=	O
dat	pointer
->	O
byte	char
;	O
section_size	int
=	O
bit_read_RS_LE	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"Handles page size: %u [RS_LE] @%lu\n"	pointer
,	O
section_size	int
,	O
startpos	long
)	O
;	O
if	O
(	O
section_size	int
>	O
2040	int
)	O
{	O
LOG_ERROR	O
(	O
"Object-map section size greater than 2040!"	pointer
)	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
while	O
(	O
dat	pointer
->	O
byte	char
-	O
startpos	long
<	O
section_size	int
)	O
{	O
BITCODE_UMC	long
handleoff	long
;	O
BITCODE_MC	long
offset	double
;	O
oldpos	long
=	O
dat	pointer
->	O
byte	char
;	O
handleoff	long
=	O
bit_read_UMC	function
(	O
dat	pointer
)	O
;	O
offset	double
=	O
bit_read_MC	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
!	O
handleoff	long
||	O
handleoff	long
>	O
max_handles	int
-	O
last_handle	long
)	O
{	O
BITCODE_MC	long
prevsize	long
=	O
dwg	pointer
->	O
num_objects	int
?	O
dwg	pointer
->	O
object	pointer
[	O
dwg	pointer
->	O
num_objects	int
-	O
1	int
]	O
.	O
size	char
+	O
4	int
:	O
0L	int
;	O
LOG_WARN	O
(	O
"Ignore invalid handleoff (@%lu)"	pointer
,	O
oldpos	long
)	O
;	O
if	O
(	O
offset	double
==	O
1	int
||	O
(	O
offset	double
>	O
0	int
&&	O
offset	double
<	O
prevsize	long
&&	O
prevsize	long
>	O
0	int
)	O
||	O
(	O
offset	double
<	O
0	int
&&	O
labs	function
(	O
(	O
long	O
)	O
offset	double
)	O
<	O
prevsize	long
&&	O
prevsize	long
>	O
0	int
)	O
)	O
{	O
if	O
(	O
offset	double
!=	O
prevsize	long
)	O
LOG_ERROR	O
(	O
"Invalid offset: %ld [MC]"	pointer
,	O
offset	double
)	O
;	O
offset	double
=	O
prevsize	long
;	O
LOG_WARN	O
(	O
"Recover invalid offset to %ld"	pointer
,	O
offset	double
)	O
;	O
}	O
}	O
last_offset	long
+=	O
offset	double
;	O
LOG_TRACE	O
(	O
"\nNext object: %lu "	pointer
,	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
num_objects	int
)	O
LOG_TRACE	O
(	O
"Handleoff: %lX [UMC] "	pointer
"Offset: "	pointer
FORMAT_MC	pointer
" [MC] @%lu\n"	pointer
,	O
handleoff	long
,	O
offset	double
,	O
last_offset	long
)	O
if	O
(	O
dat	pointer
->	O
byte	char
==	O
oldpos	long
)	O
break	O
;	O
if	O
(	O
object_end	long
<	O
last_offset	long
)	O
object_end	long
=	O
last_offset	long
;	O
if	O
(	O
object_begin	long
>	O
last_offset	long
)	O
object_begin	long
=	O
last_offset	long
;	O
added	int
=	O
dwg_decode_add_object	function
(	O
dwg	pointer
,	O
dat	pointer
,	O
dat	pointer
,	O
last_offset	long
)	O
;	O
if	O
(	O
added	int
>	O
0	int
)	O
error	int
|=	O
added	int
;	O
last_handle	long
=	O
dwg	pointer
->	O
object	pointer
[	O
dwg	pointer
->	O
num_objects	int
-	O
1	int
]	O
.	O
handle	pointer
.	O
value	double
;	O
}	O
if	O
(	O
dat	pointer
->	O
byte	char
==	O
oldpos	long
)	O
break	O
;	O
if	O
(	O
dat	pointer
->	O
bit	char
>	O
0	int
)	O
{	O
dat	pointer
->	O
byte	char
+=	O
1	int
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
}	O
crc	int
=	O
bit_read_RS_LE	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"\nHandles page crc: %04X [RS_LE] (%lu-%lu = %u)\n"	pointer
,	O
crc	int
,	O
startpos	long
,	O
startpos	long
+	O
section_size	int
,	O
section_size	int
)	O
;	O
crc2	int
=	O
bit_calc_CRC	function
(	O
0xC0C1	int
,	O
dat	pointer
->	O
chain	pointer
+	O
startpos	long
,	O
section_size	int
)	O
;	O
if	O
(	O
crc	int
!=	O
crc2	int
)	O
{	O
LOG_ERROR	O
(	O
"Handles Section[%ld] page CRC mismatch %04X <=> %04X"	pointer
,	O
(	O
long	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_HANDLES_R13	int
]	O
.	O
number	short
,	O
crc	int
,	O
crc2	int
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
!=	O
R_14	int
)	O
error	int
|=	O
DWG_ERR_WRONGCRC	int
;	O
}	O
if	O
(	O
dat	pointer
->	O
byte	char
>=	O
lastmap	long
)	O
break	O
;	O
}	O
while	O
(	O
section_size	int
>	O
2	int
)	O
;	O
LOG_INFO	O
(	O
"Num objects: %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
num_objects	int
)	O
LOG_INFO	O
(	O
"\n"	pointer
"=======> Last Object      : %8lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
object_begin	long
)	O
dat	pointer
->	O
byte	char
=	O
object_end	long
;	O
object_begin	long
=	O
bit_read_MS	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"last object size: %lu [MS] (@%lu)\n"	pointer
,	O
object_begin	long
,	O
object_end	long
)	O
LOG_INFO	O
(	O
"         Last Object (end): %8lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
object_end	long
+	O
object_begin	long
+	O
2	int
)	O
)	O
if	O
(	O
bit_search_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_SECOND_HEADER_BEGIN	int
)	O
)	O
)	O
{	O
BITCODE_RL	int
i	int
;	O
BITCODE_RC	char
sig	char
,	O
sig2	char
;	O
BITCODE_BL	int
vcount	int
;	O
long	O
unsigned	O
int	O
pvzadr	long
;	O
struct	O
_dwg_second_header	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
second_header	struct
;	O
obj	pointer
=	O
NULL	O
;	O
LOG_INFO	O
(	O
"\n"	pointer
"=======> Second Header 3 (start): %8u\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
dat	pointer
->	O
byte	char
-	O
16	int
)	O
pvzadr	long
=	O
dat	pointer
->	O
byte	char
;	O
LOG_TRACE	O
(	O
"pvzadr: %lx\n"	pointer
,	O
pvzadr	long
)	O
FIELD_RL	O
(	O
size	char
,	O
0	int
)	O
;	O
FIELD_BLx	O
(	O
address	long
,	O
0	int
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
<=	O
SECTION_2NDHEADER_R13	int
)	O
{	O
LOG_WARN	O
(	O
"Only %d num_sections, but 2ndheader found, extending to 4"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
=	O
SECTION_2NDHEADER_R13	int
+	O
1	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
=	O
realloc	function
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
*	O
sizeof	O
(	O
Dwg_Section	struct
)	O
)	O
;	O
memset	function
(	O
&	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
Dwg_Section	struct
)	O
)	O
;	O
}	O
if	O
(	O
!	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
address	long
)	O
{	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
address	long
=	O
dwg	pointer
->	O
second_header	struct
.	O
address	long
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
SECTION_2NDHEADER_R13	int
]	O
.	O
size	char
=	O
dwg	pointer
->	O
second_header	struct
.	O
size	char
;	O
}	O
bit_read_fixed	function
(	O
dat	pointer
,	O
_obj	pointer
->	O
version	short
,	O
12	int
)	O
;	O
LOG_TRACE	O
(	O
"version: %s [TFF 12]\n"	pointer
,	O
_obj	pointer
->	O
version	short
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
FIELD_B	O
(	O
null_b	array
[	O
i	int
]	O
,	O
0	int
)	O
;	O
FIELD_RC	O
(	O
unknown_10	short
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
FIELD_RC	O
(	O
unknown_rc4	array
[	O
i	int
]	O
,	O
0	int
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
<	O
R_2000	int
&&	O
FIELD_VALUE	O
(	O
unknown_10	short
)	O
==	O
0x18	int
&&	O
FIELD_VALUE	O
(	O
unknown_rc4	array
[	O
0	int
]	O
)	O
==	O
0x78	int
)	O
dat	pointer
->	O
byte	char
-=	O
2	int
;	O
UNTIL	O
(	O
R_2000	int
)	O
{	O
FIELD_RC	O
(	O
num_sections	int
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MIN	O
(	O
6	int
,	O
FIELD_VALUE	O
(	O
num_sections	int
)	O
)	O
;	O
i	int
++	O
)	O
{	O
FIELD_RC	O
(	O
section	pointer
[	O
i	int
]	O
.	O
nr	char
,	O
0	int
)	O
;	O
FIELD_BLx	O
(	O
section	pointer
[	O
i	int
]	O
.	O
address	long
,	O
0	int
)	O
;	O
FIELD_BL	O
(	O
section	pointer
[	O
i	int
]	O
.	O
size	char
,	O
0	int
)	O
;	O
}	O
if	O
(	O
DWG_LOGLEVEL	O
>=	O
DWG_LOGLEVEL_HANDLE	int
)	O
{	O
LOG_HANDLE	O
(	O
"1st header was:\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
;	O
i	int
++	O
)	O
{	O
LOG_HANDLE	O
(	O
"section["	pointer
FORMAT_RL	O
"] "	pointer
FORMAT_RLd	O
" "	pointer
FORMAT_RLL	O
" "	pointer
FORMAT_RL	O
" \n"	pointer
,	O
i	int
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
number	short
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
size	char
)	O
;	O
}	O
LOG_HANDLE	O
(	O
"start 3: %lu\n"	pointer
,	O
pvzadr	long
-	O
16	int
)	O
;	O
}	O
FIELD_BS	O
(	O
num_handlers	short
,	O
0	int
)	O
;	O
if	O
(	O
FIELD_VALUE	O
(	O
num_handlers	short
)	O
>	O
16	int
)	O
{	O
LOG_ERROR	O
(	O
"Second header num_handlers > 16: %d\n"	pointer
,	O
FIELD_VALUE	O
(	O
num_handlers	short
)	O
)	O
;	O
FIELD_VALUE	O
(	O
num_handlers	short
)	O
=	O
14	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
FIELD_VALUE	O
(	O
num_handlers	short
)	O
;	O
i	int
++	O
)	O
{	O
FIELD_RC	O
(	O
handlers	array
[	O
i	int
]	O
.	O
size	char
,	O
0	int
)	O
;	O
FIELD_RC	O
(	O
handlers	array
[	O
i	int
]	O
.	O
nr	char
,	O
0	int
)	O
;	O
FIELD_VECTOR	O
(	O
handlers	array
[	O
i	int
]	O
.	O
data	pointer
,	O
RC	O
,	O
handlers	array
[	O
i	int
]	O
.	O
size	char
,	O
0	int
)	O
;	O
}	O
crc	int
=	O
bit_read_CRC	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"crc: %04X\n"	pointer
,	O
crc	int
)	O
;	O
VERSION	O
(	O
R_14	int
)	O
{	O
FIELD_RL	O
(	O
junk_r14_1	int
,	O
0	int
)	O
;	O
FIELD_RL	O
(	O
junk_r14_2	int
,	O
0	int
)	O
;	O
}	O
}	O
if	O
(	O
bit_search_sentinel	function
(	O
dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_SECOND_HEADER_END	int
)	O
)	O
)	O
LOG_INFO	O
(	O
"         Second Header 3 (end)  : %8u\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
dat	pointer
->	O
byte	char
)	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
>	O
4	int
)	O
{	O
LOG_INFO	O
(	O
"\n"	pointer
"=======> MEASUREMENT 4 (start)  : %8u\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
4	int
]	O
.	O
address	long
)	O
LOG_INFO	O
(	O
"         MEASUREMENT 4 (end)    : %8u\n"	pointer
,	O
(	O
unsigned	O
int	O
)	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
4	int
]	O
.	O
address	long
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
4	int
]	O
.	O
size	char
)	O
)	O
dat	pointer
->	O
byte	char
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
4	int
]	O
.	O
address	long
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
dwg	pointer
->	O
header_vars	struct
.	O
MEASUREMENT	short
=	O
(	O
BITCODE_BS	short
)	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"MEASUREMENT: "	pointer
FORMAT_BS	O
" [RL] (0 English/1 Metric)\n"	pointer
,	O
dwg	pointer
->	O
header_vars	struct
.	O
MEASUREMENT	short
)	O
}	O
LOG_INFO	O
(	O
"\nnum_objects: %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
num_objects	int
)	O
LOG_TRACE	O
(	O
"num_object_refs: %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
num_object_refs	int
)	O
LOG_TRACE	O
(	O
"Resolving pointers from ObjectRef vector:\n"	pointer
)	O
error	int
|=	O
resolve_objectref_vector	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
resolve_objectref_vector	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
BITCODE_BL	int
i	int
;	O
Dwg_Object	struct
*	O
obj	pointer
;	O
dwg	pointer
->	O
dirty_refs	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_object_refs	int
;	O
i	int
++	O
)	O
{	O
Dwg_Object_Ref	struct
*	O
ref	pointer
=	O
dwg	pointer
->	O
object_ref	pointer
[	O
i	int
]	O
;	O
LOG_INSANE	O
(	O
"==========\n"	pointer
)	O
LOG_TRACE	O
(	O
"-objref[%3ld]: HANDLE"	pointer
FORMAT_REF	pointer
"\n"	pointer
,	O
(	O
long	O
)	O
i	int
,	O
ARGS_REF	O
(	O
ref	pointer
)	O
)	O
obj	pointer
=	O
dwg_resolve_handle	function
(	O
dwg	pointer
,	O
ref	pointer
->	O
absolute_ref	long
)	O
;	O
if	O
(	O
obj	pointer
)	O
{	O
LOG_TRACE	O
(	O
"-found:     HANDLE("	pointer
FORMAT_H	pointer
") => [%u]\n"	pointer
,	O
ARGS_H	O
(	O
obj	pointer
->	O
handle	pointer
)	O
,	O
obj	pointer
->	O
index	short
)	O
}	O
ref	pointer
->	O
obj	pointer
=	O
obj	pointer
;	O
}	O
return	O
dwg	pointer
->	O
num_object_refs	int
?	O
0	int
:	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
Dwg_Object_Ref	struct
*	O
dwg_find_objectref	function
(	O
const	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
for	O
(	O
BITCODE_BL	int
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_object_refs	int
;	O
i	int
++	O
)	O
{	O
Dwg_Object_Ref	struct
*	O
ref	pointer
=	O
dwg	pointer
->	O
object_ref	pointer
[	O
i	int
]	O
;	O
Dwg_Object	struct
*	O
found	pointer
=	O
dwg_resolve_handle_silent	function
(	O
dwg	pointer
,	O
ref	pointer
->	O
absolute_ref	long
)	O
;	O
if	O
(	O
found	pointer
==	O
obj	pointer
)	O
return	O
ref	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
void	O
dwg_resolve_objectrefs_silent	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
BITCODE_BL	int
i	int
;	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
;	O
int	O
oldloglevel	int
=	O
loglevel	int
;	O
loglevel	int
=	O
0	int
;	O
dwg	pointer
->	O
dirty_refs	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_object_refs	int
;	O
i	int
++	O
)	O
{	O
obj	pointer
=	O
dwg_resolve_handle	function
(	O
dwg	pointer
,	O
dwg	pointer
->	O
object_ref	pointer
[	O
i	int
]	O
->	O
absolute_ref	long
)	O
;	O
dwg	pointer
->	O
object_ref	pointer
[	O
i	int
]	O
->	O
obj	pointer
=	O
obj	pointer
;	O
}	O
loglevel	int
=	O
oldloglevel	int
;	O
}	O
void	O
bfr_read	function
(	O
void	O
*	O
restrict	O
dst	pointer
,	O
BITCODE_RC	char
*	O
restrict	O
*	O
restrict	O
src	pointer
,	O
size_t	long
size	char
)	O
{	O
memcpy	function
(	O
dst	pointer
,	O
*	O
src	pointer
,	O
size	char
)	O
;	O
*	O
src	pointer
+=	O
size	char
;	O
}	O
static	O
unsigned	O
int	O
read_literal_length	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
unsigned	O
char	O
*	O
restrict	O
opcode	pointer
)	O
{	O
unsigned	O
int	O
total	int
=	O
0	int
;	O
BITCODE_RC	char
byte	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
*	O
opcode	pointer
=	O
0x00	int
;	O
if	O
(	O
byte	char
>=	O
0x01	int
&&	O
byte	char
<=	O
0x0F	int
)	O
return	O
byte	char
+	O
3	int
;	O
else	O
if	O
(	O
byte	char
==	O
0	int
)	O
{	O
total	int
=	O
0x0F	int
;	O
while	O
(	O
(	O
(	O
byte	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
)	O
==	O
0	int
)	O
&&	O
(	O
dat	pointer
->	O
byte	char
<	O
dat	pointer
->	O
size	char
)	O
)	O
{	O
total	int
+=	O
0xFF	int
;	O
}	O
if	O
(	O
dat	pointer
->	O
byte	char
>=	O
dat	pointer
->	O
size	char
)	O
return	O
0	int
;	O
else	O
return	O
total	int
+	O
byte	char
+	O
3	int
;	O
}	O
else	O
if	O
(	O
byte	char
&	O
0xF0	int
)	O
*	O
opcode	pointer
=	O
byte	char
;	O
return	O
0	int
;	O
}	O
static	O
int	O
read_long_compression_offset	function
(	O
Bit_Chain	struct
*	O
dat	pointer
)	O
{	O
int	O
total	int
=	O
0	int
;	O
BITCODE_RC	char
byte	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
byte	char
==	O
0	int
)	O
{	O
total	int
=	O
0xFF	int
;	O
while	O
(	O
(	O
byte	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
)	O
==	O
0	int
&&	O
dat	pointer
->	O
size	char
-	O
dat	pointer
->	O
byte	char
>	O
1	int
)	O
total	int
+=	O
0xFF	int
;	O
}	O
return	O
total	int
+	O
byte	char
;	O
}	O
static	O
int	O
read_two_byte_offset	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
unsigned	O
int	O
*	O
restrict	O
lit_length	pointer
)	O
{	O
int	O
offset	double
;	O
BITCODE_RC	char
firstByte	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
BITCODE_RC	char
secondByte	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
offset	double
=	O
(	O
firstByte	char
>>	O
2	int
)	O
|	O
(	O
secondByte	char
<<	O
6	int
)	O
;	O
*	O
lit_length	pointer
=	O
(	O
firstByte	char
&	O
0x03	int
)	O
;	O
return	O
offset	double
;	O
}	O
static	O
int	O
decompress_R2004_section	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
BITCODE_RC	char
*	O
restrict	O
decomp	pointer
,	O
uint32_t	int
decomp_data_size	int
,	O
uint32_t	int
comp_data_size	int
)	O
{	O
unsigned	O
int	O
i	int
,	O
lit_length	pointer
;	O
uint32_t	int
comp_offset	int
,	O
comp_bytes	int
;	O
long	O
bytes_left	long
;	O
unsigned	O
char	O
opcode1	char
=	O
0	int
,	O
opcode2	char
;	O
long	O
unsigned	O
int	O
start_byte	long
=	O
dat	pointer
->	O
byte	char
;	O
BITCODE_RC	char
*	O
src	pointer
,	O
*	O
dst	pointer
=	O
decomp	pointer
;	O
BITCODE_RC	char
*	O
dst_end	pointer
=	O
decomp	pointer
+	O
decomp_data_size	int
;	O
bytes_left	long
=	O
(	O
long	O
)	O
decomp_data_size	int
;	O
LOG_INSANE	O
(	O
"bytes_left: %ld\n"	pointer
,	O
bytes_left	long
)	O
if	O
(	O
comp_data_size	int
>	O
dat	pointer
->	O
size	char
-	O
start_byte	long
)	O
{	O
LOG_WARN	O
(	O
"Invalid comp_data_size %ld > %lu bytes left"	pointer
,	O
bytes_left	long
,	O
dat	pointer
->	O
size	char
-	O
dat	pointer
->	O
byte	char
)	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
lit_length	pointer
=	O
read_literal_length	function
(	O
dat	pointer
,	O
&	O
opcode1	char
)	O
;	O
if	O
(	O
(	O
long	O
)	O
lit_length	pointer
>	O
bytes_left	long
)	O
{	O
LOG_ERROR	O
(	O
"Invalid literal_length %u > %ld bytes left"	pointer
,	O
lit_length	pointer
,	O
bytes_left	long
)	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
bit_read_fixed	function
(	O
dat	pointer
,	O
decomp	pointer
,	O
lit_length	pointer
)	O
;	O
dst	pointer
+=	O
lit_length	pointer
;	O
bytes_left	long
-=	O
lit_length	pointer
;	O
LOG_INSANE	O
(	O
"(%ld) "	pointer
,	O
bytes_left	long
)	O
opcode1	char
=	O
0x00	int
;	O
while	O
(	O
dat	pointer
->	O
byte	char
-	O
start_byte	long
<	O
comp_data_size	int
&&	O
dst	pointer
<	O
dst_end	pointer
)	O
{	O
LOG_INSANE	O
(	O
"-O %x "	pointer
,	O
opcode1	char
)	O
if	O
(	O
opcode1	char
==	O
0x00	int
)	O
{	O
opcode1	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
LOG_INSANE	O
(	O
"<O %x "	pointer
,	O
opcode1	char
)	O
}	O
if	O
(	O
opcode1	char
>=	O
0x40	int
)	O
{	O
comp_bytes	int
=	O
(	O
(	O
opcode1	char
&	O
0xF0	int
)	O
>>	O
4	int
)	O
-	O
1	int
;	O
opcode2	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
LOG_INSANE	O
(	O
"<O %x "	pointer
,	O
opcode2	char
)	O
comp_offset	int
=	O
(	O
opcode2	char
<<	O
2	int
)	O
|	O
(	O
(	O
opcode1	char
&	O
0x0C	int
)	O
>>	O
2	int
)	O
;	O
if	O
(	O
opcode1	char
&	O
0x03	int
)	O
{	O
lit_length	pointer
=	O
(	O
opcode1	char
&	O
0x03	int
)	O
;	O
opcode1	char
=	O
0x00	int
;	O
}	O
else	O
lit_length	pointer
=	O
read_literal_length	function
(	O
dat	pointer
,	O
&	O
opcode1	char
)	O
;	O
}	O
else	O
if	O
(	O
opcode1	char
>=	O
0x21	int
&&	O
opcode1	char
<=	O
0x3F	int
)	O
{	O
comp_bytes	int
=	O
opcode1	char
-	O
0x1E	int
;	O
comp_offset	int
=	O
read_two_byte_offset	function
(	O
dat	pointer
,	O
&	O
lit_length	pointer
)	O
;	O
if	O
(	O
lit_length	pointer
!=	O
0	int
)	O
opcode1	char
=	O
0x00	int
;	O
else	O
lit_length	pointer
=	O
read_literal_length	function
(	O
dat	pointer
,	O
&	O
opcode1	char
)	O
;	O
}	O
else	O
if	O
(	O
opcode1	char
==	O
0x20	int
)	O
{	O
comp_bytes	int
=	O
read_long_compression_offset	function
(	O
dat	pointer
)	O
+	O
0x21	int
;	O
comp_offset	int
=	O
read_two_byte_offset	function
(	O
dat	pointer
,	O
&	O
lit_length	pointer
)	O
;	O
if	O
(	O
lit_length	pointer
!=	O
0	int
)	O
opcode1	char
=	O
0x00	int
;	O
else	O
lit_length	pointer
=	O
read_literal_length	function
(	O
dat	pointer
,	O
&	O
opcode1	char
)	O
;	O
}	O
else	O
if	O
(	O
opcode1	char
>=	O
0x12	int
&&	O
opcode1	char
<=	O
0x1F	int
)	O
{	O
comp_bytes	int
=	O
(	O
opcode1	char
&	O
0x0F	int
)	O
+	O
2	int
;	O
comp_offset	int
=	O
read_two_byte_offset	function
(	O
dat	pointer
,	O
&	O
lit_length	pointer
)	O
+	O
0x3FFF	int
;	O
if	O
(	O
lit_length	pointer
!=	O
0	int
)	O
opcode1	char
=	O
0x00	int
;	O
else	O
lit_length	pointer
=	O
read_literal_length	function
(	O
dat	pointer
,	O
&	O
opcode1	char
)	O
;	O
}	O
else	O
if	O
(	O
opcode1	char
==	O
0x10	int
)	O
{	O
comp_bytes	int
=	O
read_long_compression_offset	function
(	O
dat	pointer
)	O
+	O
9	int
;	O
comp_offset	int
=	O
read_two_byte_offset	function
(	O
dat	pointer
,	O
&	O
lit_length	pointer
)	O
+	O
0x3FFF	int
;	O
if	O
(	O
lit_length	pointer
!=	O
0	int
)	O
opcode1	char
=	O
0x00	int
;	O
else	O
lit_length	pointer
=	O
read_literal_length	function
(	O
dat	pointer
,	O
&	O
opcode1	char
)	O
;	O
}	O
else	O
if	O
(	O
opcode1	char
==	O
0x11	int
)	O
break	O
;	O
else	O
{	O
LOG_ERROR	O
(	O
"Invalid opcode 0x%x in input stream at pos %lu"	pointer
,	O
opcode1	char
,	O
dat	pointer
->	O
byte	char
)	O
;	O
return	O
DWG_ERR_INTERNALERROR	int
;	O
}	O
src	pointer
=	O
dst	pointer
-	O
comp_offset	int
-	O
1	int
;	O
if	O
(	O
src	pointer
<	O
decomp	pointer
)	O
{	O
LOG_ERROR	O
(	O
"decompress_R2004_section: src offset underflow"	pointer
)	O
;	O
return	O
DWG_ERR_INTERNALERROR	int
;	O
}	O
if	O
(	O
comp_bytes	int
)	O
{	O
LOG_INSANE	O
(	O
"<C %d "	pointer
,	O
comp_bytes	int
)	O
;	O
if	O
(	O
(	O
long	O
)	O
comp_bytes	int
>	O
bytes_left	long
)	O
{	O
LOG_ERROR	O
(	O
"\nInvalid comp_bytes %lu > %ld bytes left (vs %ld)"	pointer
,	O
(	O
unsigned	O
long	O
)	O
comp_bytes	int
,	O
bytes_left	long
,	O
(	O
long	O
)	O
(	O
dst_end	pointer
-	O
dst	pointer
)	O
)	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
if	O
(	O
dst	pointer
+	O
comp_bytes	int
>	O
dst_end	pointer
)	O
{	O
LOG_ERROR	O
(	O
"\nInvalid bytes_left %ld, %p + %u > %p (%ld)"	pointer
,	O
bytes_left	long
,	O
dst	pointer
,	O
comp_bytes	int
,	O
dst_end	pointer
,	O
(	O
long	O
)	O
(	O
dst_end	pointer
-	O
dst	pointer
)	O
)	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
comp_bytes	int
;	O
++	O
i	int
)	O
*	O
dst	pointer
++	O
=	O
*	O
src	pointer
++	O
;	O
bytes_left	long
-=	O
comp_bytes	int
;	O
LOG_INSANE	O
(	O
"(%ld) "	pointer
,	O
bytes_left	long
)	O
}	O
LOG_INSANE	O
(	O
"<L %d\n"	pointer
,	O
lit_length	pointer
)	O
if	O
(	O
lit_length	pointer
)	O
{	O
if	O
(	O
(	O
(	O
long	O
)	O
lit_length	pointer
>	O
bytes_left	long
)	O
||	O
dst	pointer
+	O
lit_length	pointer
>	O
dst_end	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Invalid lit_length %u > %ld bytes left"	pointer
,	O
lit_length	pointer
,	O
bytes_left	long
)	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
lit_length	pointer
;	O
++	O
i	int
)	O
*	O
dst	pointer
++	O
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
bytes_left	long
-=	O
lit_length	pointer
;	O
LOG_INSANE	O
(	O
"(%ld) "	pointer
,	O
bytes_left	long
)	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
Dwg_Section	struct
*	O
find_section	function
(	O
Dwg_Data	struct
*	O
dwg	pointer
,	O
unsigned	O
long	O
int	O
idx	long
)	O
{	O
BITCODE_BL	int
i	int
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
==	O
0	int
||	O
idx	long
==	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
(	O
unsigned	O
long	O
int	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
number	short
==	O
idx	long
)	O
return	O
&	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
int	O
add_section	function
(	O
Dwg_Data	struct
*	O
dwg	pointer
)	O
{	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
==	O
0	int
)	O
{	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Section	struct
)	O
)	O
;	O
}	O
else	O
{	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
=	O
realloc	function
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
,	O
sizeof	O
(	O
Dwg_Section	struct
)	O
*	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
+	O
1	int
)	O
)	O
;	O
memset	function
(	O
&	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
]	O
,	O
0	int
,	O
sizeof	O
(	O
Dwg_Section	struct
)	O
)	O
;	O
}	O
if	O
(	O
!	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
++	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
read_R2004_section_map	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
BITCODE_RC	char
*	O
decomp	pointer
,	O
*	O
ptr	pointer
;	O
int	O
i	int
,	O
error	int
=	O
0	int
,	O
found_section_map_id	int
=	O
0	int
;	O
uint64_t	long
section_address	long
;	O
long	O
bytes_remaining	long
;	O
const	O
uint32_t	int
comp_data_size	int
=	O
dwg	pointer
->	O
r2004_header	struct
.	O
comp_data_size	int
;	O
const	O
uint32_t	int
decomp_data_size	int
=	O
dwg	pointer
->	O
r2004_header	struct
.	O
decomp_data_size	int
;	O
const	O
int32_t	int
section_array_size	int
=	O
(	O
int32_t	int
)	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_array_size	int
;	O
const	O
uint64_t	long
section_map_address	long
=	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_map_address	long
+	O
0x100	int
;	O
const	O
BITCODE_RL	int
section_map_id	int
=	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_map_id	int
;	O
int	O
max_id	int
=	O
0	int
;	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
=	O
0	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
=	O
0	int
;	O
if	O
(	O
decomp_data_size	int
>	O
0x2f000000	int
&&	O
(	O
decomp_data_size	int
>	O
8	int
*	O
comp_data_size	int
||	O
comp_data_size	int
>	O
dat	pointer
->	O
size	char
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Invalid r2004_header.decomp_data_size %"	pointer
PRIu32	pointer
,	O
decomp_data_size	int
)	O
dwg	pointer
->	O
r2004_header	struct
.	O
decomp_data_size	int
=	O
8	int
*	O
comp_data_size	int
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
decomp	pointer
=	O
(	O
BITCODE_RC	char
*	O
)	O
calloc	function
(	O
decomp_data_size	int
+	O
1024	int
,	O
sizeof	O
(	O
BITCODE_RC	char
)	O
)	O
;	O
if	O
(	O
!	O
decomp	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
error	int
=	O
decompress_R2004_section	function
(	O
dat	pointer
,	O
decomp	pointer
,	O
decomp_data_size	int
+	O
1024	int
,	O
comp_data_size	int
)	O
;	O
if	O
(	O
error	int
>	O
DWG_ERR_CRITICAL	O
||	O
error	int
==	O
DWG_ERR_VALUEOUTOFBOUNDS	int
)	O
{	O
free	function
(	O
decomp	pointer
)	O
;	O
return	O
error	int
;	O
}	O
LOG_TRACE	O
(	O
"\n#### Read 2004 Section Page Map ####\n"	pointer
)	O
section_address	long
=	O
0x100	int
;	O
i	int
=	O
0	int
;	O
bytes_remaining	long
=	O
(	O
long	O
)	O
decomp_data_size	int
;	O
ptr	pointer
=	O
decomp	pointer
;	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
=	O
0	int
;	O
while	O
(	O
bytes_remaining	long
>=	O
8	int
)	O
{	O
error	int
|=	O
add_section	function
(	O
dwg	pointer
)	O
;	O
if	O
(	O
error	int
>	O
DWG_ERR_CRITICAL	O
)	O
return	O
error	int
;	O
bfr_read	function
(	O
&	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
,	O
&	O
ptr	pointer
,	O
8	int
)	O
;	O
bytes_remaining	long
-=	O
8	int
;	O
LOG_TRACE	O
(	O
"Section[%2d]=%2d,"	pointer
,	O
i	int
,	O
(	O
int	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
number	short
)	O
LOG_TRACE	O
(	O
" size: %5u,"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
size	char
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
=	O
section_address	long
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
number	short
<=	O
section_array_size	int
)	O
{	O
section_address	long
+=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
size	char
;	O
LOG_TRACE	O
(	O
" address: 0x%04lx\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
)	O
}	O
else	O
LOG_TRACE	O
(	O
" (ignored > %d section_array_size)\n"	pointer
,	O
(	O
int	O
)	O
section_array_size	int
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
number	short
>	O
max_id	int
)	O
max_id	int
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
number	short
;	O
if	O
(	O
(	O
BITCODE_RL	int
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
number	short
==	O
section_map_id	int
)	O
{	O
found_section_map_id	int
++	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
!=	O
section_map_address	long
)	O
{	O
LOG_WARN	O
(	O
"Repair invalid section_map_address: %"	pointer
PRIx64	O
" != %"	pointer
PRIx64	O
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
,	O
section_map_address	long
)	O
;	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
=	O
section_map_address	long
;	O
}	O
}	O
if	O
(	O
i	int
>=	O
(	O
int	O
)	O
section_array_size	int
)	O
{	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
LOG_WARN	O
(	O
"Overflow section_array_size: %d >= %d (remaining: %ld)"	pointer
,	O
i	int
,	O
(	O
int	O
)	O
section_array_size	int
,	O
(	O
long	O
)	O
bytes_remaining	long
)	O
;	O
if	O
(	O
i	int
>	O
1000	int
)	O
return	O
error	int
;	O
}	O
if	O
(	O
bytes_remaining	long
>=	O
16	int
&&	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
number	short
<	O
0	int
)	O
{	O
bfr_read	function
(	O
&	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
parent	pointer
,	O
&	O
ptr	pointer
,	O
16	int
)	O
;	O
bytes_remaining	long
-=	O
16	int
;	O
LOG_TRACE	O
(	O
"  Parent: %d, "	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
parent	pointer
)	O
LOG_TRACE	O
(	O
"Left:   %d, "	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
left	int
)	O
LOG_TRACE	O
(	O
"Right:  %d, "	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
right	int
)	O
LOG_TRACE	O
(	O
"0x00:   %d\n"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
x00	int
)	O
}	O
i	int
++	O
;	O
}	O
i	int
--	O
;	O
free	function
(	O
decomp	pointer
)	O
;	O
if	O
(	O
max_id	int
!=	O
(	O
int32_t	int
)	O
section_array_size	int
)	O
{	O
LOG_WARN	O
(	O
"Invalid section_array_size: [%d].%d != %d"	pointer
,	O
i	int
,	O
max_id	int
,	O
(	O
int	O
)	O
section_array_size	int
)	O
;	O
}	O
if	O
(	O
section_address	long
!=	O
(	O
uint64_t	long
)	O
dwg	pointer
->	O
r2004_header	struct
.	O
last_section_address	long
+	O
0x100	int
)	O
{	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
LOG_WARN	O
(	O
"Invalid last_section_address: %"	pointer
PRIx64	O
" != %"	pointer
PRIx64	O
,	O
section_address	long
,	O
dwg	pointer
->	O
r2004_header	struct
.	O
last_section_address	long
)	O
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
!=	O
dwg	pointer
->	O
r2004_header	struct
.	O
num_gaps	int
+	O
dwg	pointer
->	O
r2004_header	struct
.	O
num_sections	int
)	O
{	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
LOG_WARN	O
(	O
"Invalid num_sections: %d != gaps: "	pointer
FORMAT_RL	O
" + sects: "	pointer
FORMAT_RL	O
,	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
,	O
dwg	pointer
->	O
r2004_header	struct
.	O
num_gaps	int
,	O
dwg	pointer
->	O
r2004_header	struct
.	O
num_sections	int
)	O
;	O
}	O
if	O
(	O
!	O
found_section_map_id	int
)	O
{	O
BITCODE_RLx	int
section_type	int
;	O
Dwg_Section	struct
*	O
info	pointer
;	O
LOG_WARN	O
(	O
"section_map_id "	pointer
FORMAT_RL	O
" not found"	pointer
,	O
section_map_id	int
)	O
;	O
info	pointer
=	O
find_section	function
(	O
dwg	pointer
,	O
section_map_id	int
)	O
;	O
if	O
(	O
!	O
info	pointer
)	O
{	O
i	int
=	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
;	O
add_section	function
(	O
dwg	pointer
)	O
;	O
LOG_WARN	O
(	O
"Add section_map_id [%d] %d => address 0x%"	pointer
PRIx64	O
,	O
i	int
,	O
section_map_id	int
,	O
section_map_address	long
)	O
;	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
number	short
=	O
section_map_id	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
=	O
section_map_address	long
;	O
if	O
(	O
i	int
>	O
0	int
)	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
size	char
=	O
section_map_address	long
-	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
-	O
1	int
]	O
.	O
address	long
;	O
}	O
info	pointer
=	O
find_section	function
(	O
dwg	pointer
,	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_info_id	int
)	O
;	O
if	O
(	O
!	O
info	pointer
)	O
goto	O
repair_info_id	O
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
dat	pointer
->	O
byte	char
=	O
info	pointer
->	O
address	long
;	O
section_type	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
section_type	int
!=	O
0x4163003b	int
)	O
{	O
repair_info_id	O
:	O
LOG_WARN	O
(	O
"Repair invalid section_info_id [%d]: => %u"	pointer
,	O
i	int
-	O
1	int
,	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_info_id	int
)	O
;	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
int	O
)	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
;	O
++	O
i	int
)	O
{	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
dat	pointer
->	O
byte	char
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
;	O
if	O
(	O
dat	pointer
->	O
byte	char
>	O
dat	pointer
->	O
size	char
)	O
break	O
;	O
section_type	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
section_type	int
==	O
0x4163003b	int
)	O
{	O
LOG_WARN	O
(	O
"Fixed section_info_id [%d]: => %u @"	pointer
FORMAT_RLL	O
,	O
i	int
,	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_info_id	int
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
)	O
;	O
if	O
(	O
!	O
info	pointer
)	O
info	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
;	O
info	pointer
->	O
address	long
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
;	O
info	pointer
->	O
size	char
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
size	char
;	O
info	pointer
->	O
number	short
=	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_info_id	int
;	O
}	O
}	O
if	O
(	O
!	O
info	pointer
||	O
info	pointer
->	O
number	short
!=	O
(	O
int	O
)	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_info_id	int
)	O
{	O
i	int
=	O
dwg	pointer
->	O
header	struct
.	O
num_sections	int
;	O
add_section	function
(	O
dwg	pointer
)	O
;	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
number	short
=	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_info_id	int
;	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
=	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
-	O
1	int
]	O
.	O
address	long
+	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
-	O
1	int
]	O
.	O
size	char
;	O
LOG_WARN	O
(	O
"Add section_info_id [%d] %u => address 0x%"	pointer
PRIx64	O
,	O
i	int
,	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_info_id	int
,	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
[	O
i	int
]	O
.	O
address	long
)	O
;	O
}	O
}	O
}	O
if	O
(	O
found_section_map_id	int
>	O
1	int
)	O
{	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
LOG_WARN	O
(	O
"Illegal 2004 Section Page Map. Found %d section_map_id sections"	pointer
,	O
found_section_map_id	int
)	O
}	O
return	O
error	int
;	O
}	O
static	O
int	O
read_R2004_section_info	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
uint32_t	int
comp_data_size	int
,	O
uint32_t	int
decomp_data_size	int
)	O
{	O
BITCODE_RC	char
*	O
decomp	pointer
,	O
*	O
ptr	pointer
,	O
*	O
decomp_end	pointer
;	O
BITCODE_BL	int
i	int
,	O
j	int
;	O
int32_t	int
section_number	int
=	O
0	int
;	O
uint32_t	int
data_size	int
,	O
maxsize	int
;	O
uint64_t	long
offset	double
;	O
int	O
error	int
;	O
if	O
(	O
decomp_data_size	int
>	O
0x2f000000	int
&&	O
(	O
decomp_data_size	int
>	O
8	int
*	O
comp_data_size	int
||	O
comp_data_size	int
>	O
dat	pointer
->	O
size	char
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Invalid r2004_header.decomp_data_size %"	pointer
PRIu32	pointer
,	O
decomp_data_size	int
)	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
decomp	pointer
=	O
(	O
BITCODE_RC	char
*	O
)	O
calloc	function
(	O
decomp_data_size	int
+	O
1024	int
,	O
sizeof	O
(	O
BITCODE_RC	char
)	O
)	O
;	O
if	O
(	O
!	O
decomp	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
error	int
=	O
decompress_R2004_section	function
(	O
dat	pointer
,	O
decomp	pointer
,	O
decomp_data_size	int
+	O
1024	int
,	O
comp_data_size	int
)	O
;	O
if	O
(	O
error	int
>	O
DWG_ERR_CRITICAL	O
||	O
error	int
==	O
DWG_ERR_VALUEOUTOFBOUNDS	int
)	O
{	O
free	function
(	O
decomp	pointer
)	O
;	O
return	O
error	int
;	O
}	O
ptr	pointer
=	O
decomp	pointer
;	O
bfr_read	function
(	O
&	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
,	O
&	O
ptr	pointer
,	O
20	int
)	O
;	O
LOG_TRACE	O
(	O
"\n#### Read 2004 section_infohdr ####\n"	pointer
)	O
LOG_TRACE	O
(	O
"num_desc:   %d\n"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc	int
)	O
LOG_TRACE	O
(	O
"compressed: %d\n"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
compressed	int
)	O
LOG_TRACE	O
(	O
"max_size:   0x%x\n"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
max_size	int
)	O
LOG_TRACE	O
(	O
"encrypted:  %d\n"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
encrypted	int
)	O
LOG_TRACE	O
(	O
"num_desc2:  %d/0x%x\n"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc2	int
,	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc2	int
)	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc	int
>	O
0x2f00000	int
)	O
{	O
LOG_ERROR	O
(	O
"Illegal num_desc2"	pointer
)	O
;	O
free	function
(	O
decomp	pointer
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc	int
=	O
0	int
;	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc2	int
=	O
0	int
;	O
return	O
error	int
|	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
dwg	pointer
->	O
header	struct
.	O
section_info	pointer
=	O
(	O
Dwg_Section_Info	struct
*	O
)	O
calloc	function
(	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc	int
,	O
sizeof	O
(	O
Dwg_Section_Info	struct
)	O
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
header	struct
.	O
section_info	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
error	int
|	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
decomp_end	pointer
=	O
decomp	pointer
+	O
decomp_data_size	int
+	O
1024	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc	int
;	O
++	O
i	int
)	O
{	O
Dwg_Section_Info	struct
*	O
info	pointer
;	O
uint64_t	long
sum_decomp	long
=	O
0	int
;	O
uint64_t	long
prev_address	long
=	O
0	int
;	O
if	O
(	O
ptr	pointer
+	O
32	int
+	O
64	int
>=	O
decomp_end	pointer
)	O
{	O
free	function
(	O
decomp	pointer
)	O
;	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc	int
=	O
i	int
;	O
LOG_ERROR	O
(	O
"read_R2004_section_info out of range"	pointer
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
info	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
.	O
section_info	pointer
[	O
i	int
]	O
;	O
bfr_read	function
(	O
info	pointer
,	O
&	O
ptr	pointer
,	O
32	int
+	O
64	int
)	O
;	O
LOG_TRACE	O
(	O
"\nsection_info[%d] fields:\n"	pointer
,	O
i	int
)	O
LOG_TRACE	O
(	O
"size:            %ld\n"	pointer
,	O
(	O
long	O
)	O
info	pointer
->	O
size	char
)	O
LOG_TRACE	O
(	O
"num_sections:    %u\n"	pointer
,	O
info	pointer
->	O
num_sections	int
)	O
LOG_TRACE	O
(	O
"max_decomp_size: %u / 0x%x\n"	pointer
,	O
info	pointer
->	O
max_decomp_size	int
,	O
info	pointer
->	O
max_decomp_size	int
)	O
LOG_TRACE	O
(	O
"unknown:         %u\n"	pointer
,	O
info	pointer
->	O
unknown	char
)	O
LOG_TRACE	O
(	O
"compressed:      %u (1=no, 2=yes)\n"	pointer
,	O
info	pointer
->	O
compressed	int
)	O
LOG_TRACE	O
(	O
"type:            0x%x\n"	pointer
,	O
(	O
unsigned	O
)	O
info	pointer
->	O
type	short
)	O
LOG_TRACE	O
(	O
"encrypted:       %d (0=no, 1=yes, 2=unknown)\n"	pointer
,	O
info	pointer
->	O
encrypted	int
)	O
LOG_TRACE	O
(	O
"name:            %s\n\n"	pointer
,	O
info	pointer
->	O
name	pointer
)	O
if	O
(	O
ptr	pointer
+	O
(	O
16	int
*	O
info	pointer
->	O
num_sections	int
)	O
>=	O
decomp_end	pointer
)	O
{	O
info	pointer
->	O
name	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
info	pointer
->	O
num_sections	int
=	O
0	int
;	O
info	pointer
->	O
sections	pointer
=	O
NULL	O
;	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc	int
=	O
i	int
;	O
free	function
(	O
decomp	pointer
)	O
;	O
LOG_ERROR	O
(	O
"read_R2004_section_info out of range"	pointer
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
if	O
(	O
info	pointer
->	O
num_sections	int
<	O
1000000	int
)	O
{	O
int32_t	int
old_section_number	int
=	O
0	int
;	O
LOG_INFO	O
(	O
"Page count %u in area %d\n"	pointer
,	O
info	pointer
->	O
num_sections	int
,	O
i	int
)	O
;	O
info	pointer
->	O
sections	pointer
=	O
calloc	function
(	O
info	pointer
->	O
num_sections	int
,	O
sizeof	O
(	O
Dwg_Section	struct
*	O
)	O
)	O
;	O
if	O
(	O
!	O
info	pointer
->	O
sections	pointer
)	O
{	O
free	function
(	O
decomp	pointer
)	O
;	O
LOG_ERROR	O
(	O
"Out of memory with %u sections"	pointer
,	O
info	pointer
->	O
num_sections	int
)	O
;	O
return	O
error	int
|	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
prev_address	long
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
info	pointer
->	O
num_sections	int
;	O
j	int
++	O
)	O
{	O
struct	O
_section_page	struct
{	O
int32_t	int
number	short
;	O
uint32_t	int
size	char
;	O
uint64_t	long
address	long
;	O
}	O
page	struct
;	O
bfr_read	function
(	O
&	O
page	struct
,	O
&	O
ptr	pointer
,	O
16	int
)	O
;	O
sum_decomp	long
+=	O
page	struct
.	O
size	char
;	O
info	pointer
->	O
sections	pointer
[	O
j	int
]	O
=	O
find_section	function
(	O
dwg	pointer
,	O
page	struct
.	O
number	short
)	O
;	O
if	O
(	O
page	struct
.	O
number	short
<	O
0	int
)	O
{	O
LOG_TRACE	O
(	O
"Page: %4"	pointer
PRId32	pointer
" (-)"	pointer
,	O
page	struct
.	O
number	short
)	O
info	pointer
->	O
num_sections	int
++	O
;	O
info	pointer
->	O
sections	pointer
=	O
realloc	function
(	O
info	pointer
->	O
sections	pointer
,	O
info	pointer
->	O
num_sections	int
*	O
sizeof	O
(	O
Dwg_Section	struct
*	O
)	O
)	O
;	O
info	pointer
->	O
sections	pointer
[	O
info	pointer
->	O
num_sections	int
-	O
1	int
]	O
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
page	struct
.	O
address	long
<	O
prev_address	long
)	O
{	O
LOG_TRACE	O
(	O
"Page: %4"	pointer
PRId32	pointer
" (a)"	pointer
,	O
page	struct
.	O
number	short
)	O
}	O
else	O
if	O
(	O
info	pointer
->	O
sections	pointer
[	O
0	int
]	O
&&	O
page	struct
.	O
number	short
>	O
(	O
int32_t	int
)	O
(	O
info	pointer
->	O
num_sections	int
+	O
info	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
number	short
)	O
)	O
{	O
LOG_INFO	O
(	O
"Page: %4"	pointer
PRId32	pointer
" (n)"	pointer
,	O
page	struct
.	O
number	short
)	O
}	O
else	O
if	O
(	O
!	O
info	pointer
->	O
sections	pointer
[	O
j	int
]	O
&&	O
page	struct
.	O
number	short
!=	O
old_section_number	int
+	O
1	int
)	O
{	O
LOG_INFO	O
(	O
"Page: %4"	pointer
PRId32	pointer
" (b)"	pointer
,	O
page	struct
.	O
number	short
)	O
LOG_TRACE	O
(	O
" size: %5"	pointer
PRIu32	pointer
,	O
page	struct
.	O
size	char
)	O
LOG_TRACE	O
(	O
" address: 0x%"	pointer
PRIx64	O
,	O
page	struct
.	O
address	long
)	O
if	O
(	O
info	pointer
->	O
sections	pointer
[	O
j	int
]	O
)	O
LOG_TRACE	O
(	O
" info: 0x%"	pointer
PRIx64	O
,	O
info	pointer
->	O
sections	pointer
[	O
j	int
]	O
->	O
address	long
)	O
;	O
LOG_TRACE	O
(	O
"\n"	pointer
)	O
ptr	pointer
-=	O
16	int
;	O
break	O
;	O
}	O
else	O
{	O
LOG_TRACE	O
(	O
"Page: %4"	pointer
PRId32	pointer
"    "	pointer
,	O
page	struct
.	O
number	short
)	O
old_section_number	int
=	O
page	struct
.	O
number	short
;	O
prev_address	long
=	O
page	struct
.	O
address	long
;	O
}	O
LOG_TRACE	O
(	O
" size: %5"	pointer
PRIu32	pointer
,	O
page	struct
.	O
size	char
)	O
LOG_TRACE	O
(	O
" address: 0x%"	pointer
PRIx64	O
,	O
page	struct
.	O
address	long
)	O
if	O
(	O
info	pointer
->	O
sections	pointer
[	O
j	int
]	O
)	O
LOG_TRACE	O
(	O
" info: 0x%"	pointer
PRIx64	O
,	O
info	pointer
->	O
sections	pointer
[	O
j	int
]	O
->	O
address	long
)	O
;	O
LOG_TRACE	O
(	O
"\n"	pointer
)	O
}	O
}	O
else	O
{	O
LOG_ERROR	O
(	O
"Section count %u in area %d too high! Skipping"	pointer
,	O
info	pointer
->	O
num_sections	int
,	O
i	int
)	O
;	O
info	pointer
->	O
num_sections	int
=	O
0	int
;	O
free	function
(	O
decomp	pointer
)	O
;	O
return	O
error	int
|	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
}	O
free	function
(	O
decomp	pointer
)	O
;	O
return	O
error	int
;	O
}	O
typedef	O
union	O
_encrypted_section_header	union
{	O
uint32_t	int
long_data	array
[	O
8	int
]	O
;	O
unsigned	O
char	O
char_data	array
[	O
32	int
]	O
;	O
struct	O
{	O
uint32_t	int
tag	pointer
;	O
uint32_t	int
section_type	int
;	O
uint32_t	int
data_size	int
;	O
uint32_t	int
section_size	int
;	O
uint32_t	int
address	long
;	O
uint32_t	int
unknown	char
;	O
uint32_t	int
checksum_1	int
;	O
uint32_t	int
checksum_2	int
;	O
}	O
fields	pointer
;	O
}	O
encrypted_section_header	union
;	O
static	O
int	O
read_2004_compressed_section	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Bit_Chain	struct
*	O
sec_dat	pointer
,	O
BITCODE_RL	int
section_type	int
)	O
{	O
uint32_t	int
address	long
,	O
sec_mask	int
,	O
initial_address	int
;	O
uint32_t	int
max_decomp_size	int
;	O
long	O
bytes_left	long
;	O
Dwg_Section_Info	struct
*	O
info	pointer
=	O
NULL	O
;	O
encrypted_section_header	union
es	union
;	O
BITCODE_RC	char
*	O
decomp	pointer
;	O
BITCODE_BL	int
i	int
,	O
j	int
;	O
int	O
error	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
header	struct
.	O
section_infohdr	struct
.	O
num_desc	int
&&	O
!	O
info	pointer
;	O
++	O
i	int
)	O
{	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
section_info	pointer
[	O
i	int
]	O
.	O
type	short
==	O
section_type	int
)	O
{	O
info	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
.	O
section_info	pointer
[	O
i	int
]	O
;	O
break	O
;	O
}	O
}	O
sec_dat	pointer
->	O
chain	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
info	pointer
)	O
{	O
LOG_WARN	O
(	O
"Failed to find section_info["	pointer
FORMAT_BL	O
"] with type 0x%x"	pointer
,	O
i	int
,	O
section_type	int
)	O
;	O
return	O
DWG_ERR_SECTIONNOTFOUND	int
;	O
}	O
else	O
{	O
LOG_TRACE	O
(	O
"\nFound section_info["	pointer
FORMAT_BL	O
"] %s type 0x%x with %d sections (%scompressed):\n"	pointer
,	O
i	int
,	O
info	pointer
->	O
name	pointer
,	O
section_type	int
,	O
info	pointer
->	O
num_sections	int
,	O
info	pointer
->	O
compressed	int
==	O
2	int
?	O
""	pointer
:	O
"un"	pointer
)	O
;	O
}	O
max_decomp_size	int
=	O
info	pointer
->	O
num_sections	int
*	O
info	pointer
->	O
max_decomp_size	int
;	O
if	O
(	O
max_decomp_size	int
==	O
0	int
||	O
max_decomp_size	int
>	O
0x2f000000	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid section %s count or max decompression size. "	pointer
"Sections: %u, Max size: %u"	pointer
,	O
info	pointer
->	O
name	pointer
,	O
info	pointer
->	O
num_sections	int
,	O
info	pointer
->	O
max_decomp_size	int
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
decomp	pointer
=	O
(	O
BITCODE_RC	char
*	O
)	O
calloc	function
(	O
max_decomp_size	int
,	O
sizeof	O
(	O
BITCODE_RC	char
)	O
)	O
;	O
if	O
(	O
!	O
decomp	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory with %u sections"	pointer
,	O
info	pointer
->	O
num_sections	int
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
initial_address	int
=	O
info	pointer
->	O
sections	pointer
[	O
0	int
]	O
?	O
info	pointer
->	O
sections	pointer
[	O
0	int
]	O
->	O
address	long
:	O
0	int
;	O
sec_dat	pointer
->	O
bit	char
=	O
0	int
;	O
sec_dat	pointer
->	O
byte	char
=	O
0	int
;	O
sec_dat	pointer
->	O
version	short
=	O
dat	pointer
->	O
version	short
;	O
sec_dat	pointer
->	O
from_version	enum
=	O
dat	pointer
->	O
from_version	enum
;	O
sec_dat	pointer
->	O
chain	pointer
=	O
decomp	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
info	pointer
->	O
num_sections	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
!	O
info	pointer
->	O
sections	pointer
[	O
i	int
]	O
)	O
{	O
LOG_WARN	O
(	O
"Skip empty section %u %s"	pointer
,	O
i	int
,	O
info	pointer
->	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
address	long
=	O
info	pointer
->	O
sections	pointer
[	O
i	int
]	O
->	O
address	long
;	O
dat	pointer
->	O
byte	char
=	O
address	long
;	O
bit_read_fixed	function
(	O
dat	pointer
,	O
es	union
.	O
char_data	array
,	O
32	int
)	O
;	O
sec_mask	int
=	O
0x4164536b	int
^	O
address	long
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
8	int
;	O
++	O
j	int
)	O
es	union
.	O
long_data	array
[	O
j	int
]	O
^=	O
sec_mask	int
;	O
LOG_INFO	O
(	O
"=== Section %s (%u) @%u ===\n"	pointer
,	O
info	pointer
->	O
name	pointer
,	O
i	int
,	O
address	long
)	O
if	O
(	O
es	union
.	O
fields	pointer
.	O
tag	pointer
!=	O
0x4163043b	int
)	O
{	O
LOG_WARN	O
(	O
"Section Tag:      0x%x  (should be 0x4163043b)"	pointer
,	O
(	O
unsigned	O
)	O
es	union
.	O
fields	pointer
.	O
tag	pointer
)	O
;	O
}	O
else	O
{	O
LOG_INFO	O
(	O
"Section Tag:      0x%x\n"	pointer
,	O
(	O
unsigned	O
)	O
es	union
.	O
fields	pointer
.	O
tag	pointer
)	O
;	O
}	O
LOG_INFO	O
(	O
"Section Type:     %u\n"	pointer
,	O
(	O
unsigned	O
)	O
es	union
.	O
fields	pointer
.	O
section_type	int
)	O
LOG_INFO	O
(	O
"Data size:        0x%x/%u\n"	pointer
,	O
(	O
unsigned	O
)	O
es	union
.	O
fields	pointer
.	O
data_size	int
,	O
(	O
unsigned	O
)	O
es	union
.	O
fields	pointer
.	O
data_size	int
)	O
LOG_INFO	O
(	O
"Comp data size:   0x%x\n"	pointer
,	O
(	O
unsigned	O
)	O
es	union
.	O
fields	pointer
.	O
section_size	int
)	O
LOG_TRACE	O
(	O
"StartOffset:      0x%x\n"	pointer
,	O
(	O
unsigned	O
)	O
es	union
.	O
fields	pointer
.	O
address	long
)	O
LOG_HANDLE	O
(	O
"Unknown:          0x%x\n"	pointer
,	O
(	O
unsigned	O
)	O
es	union
.	O
fields	pointer
.	O
unknown	char
)	O
LOG_HANDLE	O
(	O
"Checksum1:        0x%x\n"	pointer
,	O
(	O
unsigned	O
)	O
es	union
.	O
fields	pointer
.	O
checksum_1	int
)	O
LOG_HANDLE	O
(	O
"Checksum2:        0x%x\n"	pointer
,	O
(	O
unsigned	O
)	O
es	union
.	O
fields	pointer
.	O
checksum_2	int
)	O
LOG_TRACE	O
(	O
"Section start:    %lu\n\n"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
;	O
LOG_INSANE	O
(	O
"info[%d]->max_decomp_size: %lu (0x%lx)\n"	pointer
,	O
i	int
,	O
(	O
unsigned	O
long	O
)	O
info	pointer
->	O
max_decomp_size	int
,	O
(	O
unsigned	O
long	O
)	O
info	pointer
->	O
max_decomp_size	int
)	O
LOG_INSANE	O
(	O
"max_decomp_size:          %lu (0x%lx)\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
max_decomp_size	int
,	O
(	O
unsigned	O
long	O
)	O
max_decomp_size	int
)	O
bytes_left	long
=	O
max_decomp_size	int
-	O
(	O
i	int
*	O
info	pointer
->	O
max_decomp_size	int
)	O
;	O
LOG_INSANE	O
(	O
"bytes_left:               %ld\n"	pointer
,	O
bytes_left	long
)	O
;	O
if	O
(	O
info	pointer
->	O
compressed	int
==	O
2	int
&&	O
bytes_left	long
>	O
0	int
&&	O
(	O
i	int
*	O
info	pointer
->	O
max_decomp_size	int
)	O
<=	O
max_decomp_size	int
)	O
{	O
error	int
=	O
decompress_R2004_section	function
(	O
dat	pointer
,	O
&	O
decomp	pointer
[	O
i	int
*	O
info	pointer
->	O
max_decomp_size	int
]	O
,	O
bytes_left	long
,	O
es	union
.	O
fields	pointer
.	O
data_size	int
)	O
;	O
if	O
(	O
error	int
>	O
DWG_ERR_CRITICAL	O
)	O
{	O
sec_dat	pointer
->	O
chain	pointer
=	O
NULL	O
;	O
free	function
(	O
decomp	pointer
)	O
;	O
return	O
error	int
;	O
}	O
sec_dat	pointer
->	O
size	char
=	O
max_decomp_size	int
;	O
}	O
else	O
{	O
if	O
(	O
info	pointer
->	O
compressed	int
==	O
2	int
||	O
info	pointer
->	O
size	char
>	O
max_decomp_size	int
||	O
!	O
(	O
(	O
unsigned	O
long	O
)	O
(	O
address	long
+	O
es	union
.	O
fields	pointer
.	O
address	long
+	O
32	int
+	O
info	pointer
->	O
size	char
)	O
<=	O
dat	pointer
->	O
size	char
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Some section size out of bounds"	pointer
)	O
sec_dat	pointer
->	O
chain	pointer
=	O
NULL	O
;	O
free	function
(	O
decomp	pointer
)	O
;	O
return	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
memcpy	function
(	O
&	O
decomp	pointer
[	O
i	int
*	O
info	pointer
->	O
size	char
]	O
,	O
&	O
dat	pointer
->	O
chain	pointer
[	O
address	long
+	O
es	union
.	O
fields	pointer
.	O
address	long
+	O
32	int
]	O
,	O
info	pointer
->	O
size	char
)	O
;	O
sec_dat	pointer
->	O
size	char
=	O
info	pointer
->	O
size	char
;	O
}	O
}	O
return	O
error	int
;	O
}	O
static	O
int	O
read_2004_section_classes	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
BITCODE_RL	int
size	char
;	O
BITCODE_BS	short
max_num	short
,	O
i	int
;	O
unsigned	O
long	O
int	O
num_objects	int
,	O
dwg_version	int
,	O
maint_version	int
,	O
unknown	char
;	O
char	O
c	char
;	O
int	O
error	int
;	O
Bit_Chain	struct
sec_dat	pointer
=	O
{	O
0	int
}	O
,	O
str_dat	pointer
=	O
{	O
0	int
}	O
;	O
error	int
=	O
read_2004_compressed_section	function
(	O
dat	pointer
,	O
dwg	pointer
,	O
&	O
sec_dat	pointer
,	O
SECTION_CLASSES	int
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read compressed %s section"	pointer
,	O
"Classes"	pointer
)	O
;	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
if	O
(	O
bit_search_sentinel	function
(	O
&	O
sec_dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_CLASS_BEGIN	int
)	O
)	O
)	O
{	O
BITCODE_RL	int
bitsize	int
=	O
0	int
;	O
LOG_TRACE	O
(	O
"\nClasses\n-------------------\n"	pointer
)	O
size	char
=	O
bit_read_RL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"size: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
size	char
)	O
if	O
(	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2010	int
&&	O
dwg	pointer
->	O
header	struct
.	O
maint_version	int
>	O
3	int
)	O
||	O
dat	pointer
->	O
version	short
>=	O
R_2018	int
)	O
{	O
BITCODE_RL	int
hsize	int
=	O
bit_read_RL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"hsize: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
hsize	int
)	O
}	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
)	O
{	O
bitsize	int
=	O
bit_read_RL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"bitsize: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
bitsize	int
)	O
}	O
max_num	short
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"max_num: "	pointer
FORMAT_BS	O
" [BS]\n"	pointer
,	O
max_num	short
)	O
c	char
=	O
bit_read_RC	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_HANDLE	O
(	O
"c: "	pointer
FORMAT_RC	pointer
" [RC]\n"	pointer
,	O
c	char
)	O
c	char
=	O
bit_read_RC	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_HANDLE	O
(	O
"c: "	pointer
FORMAT_RC	pointer
" [RC]\n"	pointer
,	O
c	char
)	O
c	char
=	O
bit_read_B	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_HANDLE	O
(	O
"c: "	pointer
FORMAT_B	pointer
" [B]\n"	pointer
,	O
c	char
)	O
dwg	pointer
->	O
layout_type	int
=	O
0	int
;	O
dwg	pointer
->	O
num_classes	short
=	O
max_num	short
-	O
499	int
;	O
if	O
(	O
max_num	short
<	O
500	int
||	O
dwg	pointer
->	O
num_classes	short
>	O
100	int
+	O
(	O
size	char
/	O
sizeof	O
(	O
Dwg_Class	struct
)	O
)	O
)	O
{	O
LOG_ERROR	O
(	O
"Invalid max class number %d"	pointer
,	O
max_num	short
)	O
dwg	pointer
->	O
num_classes	short
=	O
0	int
;	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
assert	O
(	O
max_num	short
>=	O
500	int
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
)	O
section_string_stream	function
(	O
&	O
sec_dat	pointer
,	O
bitsize	int
,	O
&	O
str_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
=	O
(	O
Dwg_Class	struct
*	O
)	O
calloc	function
(	O
dwg	pointer
->	O
num_classes	short
,	O
sizeof	O
(	O
Dwg_Class	struct
)	O
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
dwg_class	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
dwg	pointer
->	O
num_classes	short
;	O
i	int
++	O
)	O
{	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
number	short
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
proxyflag	short
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"-------------------\n"	pointer
)	O
LOG_TRACE	O
(	O
"Number:           %d [BS]\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
number	short
)	O
LOG_TRACE	O
(	O
"Proxyflag:        %x [BS]\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
proxyflag	short
)	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2007	int
)	O
{	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
appname	pointer
=	O
(	O
char	O
*	O
)	O
bit_read_TU	function
(	O
&	O
str_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
cppname	pointer
=	O
(	O
char	O
*	O
)	O
bit_read_TU	function
(	O
&	O
str_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname_u	pointer
=	O
bit_read_TU	function
(	O
&	O
str_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname	pointer
=	O
bit_convert_TU	function
(	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname_u	pointer
)	O
;	O
if	O
(	O
DWG_LOGLEVEL	O
>=	O
DWG_LOGLEVEL_TRACE	int
)	O
{	O
char	O
*	O
appu8	pointer
=	O
bit_convert_TU	function
(	O
(	O
BITCODE_TU	pointer
)	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
appname	pointer
)	O
;	O
LOG_TRACE	O
(	O
"Application name: \"%s\" [TU 0 (as utf-8)]\n"	pointer
,	O
appu8	pointer
)	O
;	O
LOG_TRACE_TU	O
(	O
"C++ class name  "	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
cppname	pointer
,	O
0	int
)	O
LOG_TRACE_TU	O
(	O
"DXF record name "	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname_u	pointer
,	O
0	int
)	O
free	function
(	O
appu8	pointer
)	O
;	O
}	O
}	O
else	O
{	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
appname	pointer
=	O
bit_read_TV	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
cppname	pointer
=	O
bit_read_TV	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname	pointer
=	O
bit_read_TV	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"Application name: %s [TV]\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
appname	pointer
)	O
LOG_TRACE	O
(	O
"C++ class name:   %s [TV]\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
cppname	pointer
)	O
LOG_TRACE	O
(	O
"DXF record name:  %s [TV]\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname	pointer
)	O
}	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
is_zombie	char
=	O
bit_read_B	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
item_class_id	short
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"Class ID:         0x%x [BS] "	pointer
"(0x1f3 for object, 0x1f2 for entity)\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
item_class_id	short
)	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
num_instances	int
=	O
bit_read_BL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dwg_version	int
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
maint_version	int
=	O
bit_read_BS	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
unknown_1	double
=	O
bit_read_BL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
unknown_1	double
=	O
bit_read_BL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"num_instances:    %u\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
num_instances	int
)	O
LOG_HANDLE	O
(	O
"dwg version:      %u (%u)\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dwg_version	int
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
maint_version	int
)	O
LOG_HANDLE	O
(	O
"unknown:          %u %u\n"	pointer
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
unknown_1	double
,	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
unknown_2	double
)	O
if	O
(	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname	pointer
&&	O
strEQ	O
(	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
dxfname	pointer
,	O
"LAYOUT"	pointer
)	O
)	O
dwg	pointer
->	O
layout_type	int
=	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
.	O
number	short
;	O
}	O
}	O
else	O
{	O
LOG_ERROR	O
(	O
"Failed to find class section sentinel"	pointer
)	O
;	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
DWG_ERR_CLASSESNOTFOUND	int
;	O
}	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
read_2004_section_header	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
int	O
error	int
;	O
Bit_Chain	struct
sec_dat	pointer
=	O
{	O
0	int
}	O
;	O
sec_dat	pointer
.	O
opts	int
=	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_LOGLEVEL	int
;	O
error	int
=	O
read_2004_compressed_section	function
(	O
dat	pointer
,	O
dwg	pointer
,	O
&	O
sec_dat	pointer
,	O
SECTION_HEADER	int
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read compressed %s section"	pointer
,	O
"Header"	pointer
)	O
;	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
if	O
(	O
bit_search_sentinel	function
(	O
&	O
sec_dat	pointer
,	O
dwg_sentinel	function
(	O
DWG_SENTINEL_VARIABLE_BEGIN	int
)	O
)	O
)	O
{	O
LOG_TRACE	O
(	O
"\nHeader\n-------------------\n"	pointer
)	O
dwg	pointer
->	O
header_vars	struct
.	O
size	char
=	O
bit_read_RL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"size: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
dwg	pointer
->	O
header_vars	struct
.	O
size	char
)	O
;	O
PRE	O
(	O
R_2007	int
)	O
{	O
error	int
|=	O
dwg_decode_header_variables	function
(	O
&	O
sec_dat	pointer
,	O
&	O
sec_dat	pointer
,	O
&	O
sec_dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
else	O
{	O
Bit_Chain	struct
hdl_dat	pointer
,	O
str_dat	pointer
;	O
BITCODE_RL	int
endbits	int
=	O
160	int
;	O
hdl_dat	pointer
=	O
sec_dat	pointer
;	O
str_dat	pointer
=	O
sec_dat	pointer
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
maint_version	int
>	O
3	int
||	O
dat	pointer
->	O
version	short
>=	O
R_2018	int
)	O
{	O
dwg	pointer
->	O
header_vars	struct
.	O
bitsize_hi	int
=	O
bit_read_RL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"bitsize_hi: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
dwg	pointer
->	O
header_vars	struct
.	O
bitsize_hi	int
)	O
endbits	int
+=	O
32	int
;	O
}	O
dwg	pointer
->	O
header_vars	struct
.	O
bitsize	int
=	O
bit_read_RL	function
(	O
&	O
sec_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"bitsize: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
dwg	pointer
->	O
header_vars	struct
.	O
bitsize	int
)	O
endbits	int
+=	O
dwg	pointer
->	O
header_vars	struct
.	O
bitsize	int
;	O
bit_set_position	function
(	O
&	O
hdl_dat	pointer
,	O
endbits	int
)	O
;	O
section_string_stream	function
(	O
&	O
sec_dat	pointer
,	O
dwg	pointer
->	O
header_vars	struct
.	O
bitsize	int
,	O
&	O
str_dat	pointer
)	O
;	O
error	int
|=	O
dwg_decode_header_variables	function
(	O
&	O
sec_dat	pointer
,	O
&	O
hdl_dat	pointer
,	O
&	O
str_dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
}	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
read_2004_section_handles	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Bit_Chain	struct
obj_dat	struct
=	O
{	O
NULL	O
}	O
,	O
hdl_dat	pointer
=	O
{	O
NULL	O
}	O
;	O
BITCODE_RS	short
section_size	int
=	O
0	int
;	O
long	O
unsigned	O
int	O
endpos	long
;	O
int	O
error	int
;	O
obj_dat	struct
.	O
opts	int
=	O
hdl_dat	pointer
.	O
opts	int
=	O
dwg	pointer
->	O
opts	int
&	O
DWG_OPTS_LOGLEVEL	int
;	O
error	int
=	O
read_2004_compressed_section	function
(	O
dat	pointer
,	O
dwg	pointer
,	O
&	O
obj_dat	struct
,	O
SECTION_OBJECTS	int
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
||	O
!	O
obj_dat	struct
.	O
chain	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read compressed %s section"	pointer
,	O
"AcDbObjects"	pointer
)	O
;	O
if	O
(	O
obj_dat	struct
.	O
chain	pointer
)	O
free	function
(	O
obj_dat	struct
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
error	int
=	O
read_2004_compressed_section	function
(	O
dat	pointer
,	O
dwg	pointer
,	O
&	O
hdl_dat	pointer
,	O
SECTION_HANDLES	int
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
||	O
!	O
hdl_dat	pointer
.	O
chain	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read compressed %s section"	pointer
,	O
"Handles"	pointer
)	O
;	O
free	function
(	O
obj_dat	struct
.	O
chain	pointer
)	O
;	O
if	O
(	O
hdl_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
hdl_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
endpos	long
=	O
hdl_dat	pointer
.	O
byte	char
+	O
hdl_dat	pointer
.	O
size	char
;	O
dwg	pointer
->	O
num_objects	int
=	O
0	int
;	O
do	O
{	O
long	O
unsigned	O
int	O
last_offset	long
;	O
long	O
unsigned	O
int	O
oldpos	long
=	O
0	int
;	O
long	O
unsigned	O
int	O
startpos	long
=	O
hdl_dat	pointer
.	O
byte	char
;	O
BITCODE_BL	int
max_handles	int
=	O
hdl_dat	pointer
.	O
size	char
*	O
2	int
;	O
uint16_t	short
crc1	short
,	O
crc2	int
;	O
section_size	int
=	O
bit_read_RS_LE	function
(	O
&	O
hdl_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"\nHandles page size: %u [RS_LE]\n"	pointer
,	O
section_size	int
)	O
;	O
if	O
(	O
section_size	int
>	O
2040	int
)	O
{	O
LOG_ERROR	O
(	O
"Object-map/handles page size greater than 2040!"	pointer
)	O
;	O
free	function
(	O
hdl_dat	pointer
.	O
chain	pointer
)	O
;	O
free	function
(	O
obj_dat	struct
.	O
chain	pointer
)	O
;	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
last_offset	long
=	O
0	int
;	O
while	O
(	O
(	O
long	O
)	O
(	O
hdl_dat	pointer
.	O
byte	char
-	O
startpos	long
)	O
<	O
(	O
long	O
)	O
section_size	int
)	O
{	O
int	O
added	int
;	O
BITCODE_UMC	long
handleoff	long
;	O
BITCODE_MC	long
offset	double
;	O
BITCODE_BL	int
last_handle	long
=	O
dwg	pointer
->	O
num_objects	int
?	O
dwg	pointer
->	O
object	pointer
[	O
dwg	pointer
->	O
num_objects	int
-	O
1	int
]	O
.	O
handle	pointer
.	O
value	double
:	O
0	int
;	O
oldpos	long
=	O
hdl_dat	pointer
.	O
byte	char
;	O
handleoff	long
=	O
bit_read_UMC	function
(	O
&	O
hdl_dat	pointer
)	O
;	O
offset	double
=	O
bit_read_MC	function
(	O
&	O
hdl_dat	pointer
)	O
;	O
if	O
(	O
!	O
handleoff	long
||	O
handleoff	long
>	O
max_handles	int
-	O
last_handle	long
)	O
{	O
BITCODE_MC	long
prevsize	long
=	O
dwg	pointer
->	O
num_objects	int
?	O
dwg	pointer
->	O
object	pointer
[	O
dwg	pointer
->	O
num_objects	int
-	O
1	int
]	O
.	O
size	char
+	O
4	int
:	O
0	int
;	O
LOG_WARN	O
(	O
"Ignore invalid handleoff (@%lu)"	pointer
,	O
oldpos	long
)	O
if	O
(	O
offset	double
==	O
1	int
||	O
(	O
offset	double
>	O
0	int
&&	O
offset	double
<	O
prevsize	long
&&	O
prevsize	long
>	O
0	int
)	O
||	O
(	O
offset	double
<	O
0	int
&&	O
labs	function
(	O
(	O
long	O
)	O
offset	double
)	O
<	O
prevsize	long
&&	O
prevsize	long
>	O
0	int
)	O
)	O
{	O
if	O
(	O
offset	double
!=	O
prevsize	long
)	O
LOG_ERROR	O
(	O
"Invalid offset: %ld [MC]"	pointer
,	O
offset	double
)	O
;	O
offset	double
=	O
prevsize	long
;	O
LOG_WARN	O
(	O
"Recover invalid offset to %ld"	pointer
,	O
offset	double
)	O
;	O
}	O
}	O
last_offset	long
+=	O
offset	double
;	O
LOG_TRACE	O
(	O
"\n< Next object: %lu "	pointer
,	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
num_objects	int
)	O
LOG_HANDLE	O
(	O
"Handleoff: %lX [UMC] "	pointer
"Offset: "	pointer
FORMAT_MC	pointer
" [MC] @%lu\n"	pointer
,	O
handleoff	long
,	O
offset	double
,	O
last_offset	long
)	O
;	O
if	O
(	O
hdl_dat	pointer
.	O
byte	char
==	O
oldpos	long
)	O
break	O
;	O
added	int
=	O
dwg_decode_add_object	function
(	O
dwg	pointer
,	O
&	O
obj_dat	struct
,	O
&	O
obj_dat	struct
,	O
last_offset	long
)	O
;	O
if	O
(	O
added	int
>	O
0	int
)	O
error	int
|=	O
added	int
;	O
}	O
if	O
(	O
hdl_dat	pointer
.	O
byte	char
==	O
oldpos	long
)	O
break	O
;	O
crc1	short
=	O
bit_calc_CRC	function
(	O
0xC0C1	int
,	O
&	O
(	O
hdl_dat	pointer
.	O
chain	pointer
[	O
startpos	long
]	O
)	O
,	O
hdl_dat	pointer
.	O
byte	char
-	O
startpos	long
)	O
;	O
crc2	int
=	O
bit_read_RS_LE	function
(	O
&	O
hdl_dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"Handles page crc: %04X [RS_LE]\n"	pointer
,	O
crc2	int
)	O
;	O
if	O
(	O
crc1	short
==	O
crc2	int
)	O
{	O
LOG_INSANE	O
(	O
"Handles page CRC: %04X from %lu-%lu=%ld\n"	pointer
,	O
crc2	int
,	O
startpos	long
,	O
hdl_dat	pointer
.	O
byte	char
-	O
2	int
,	O
hdl_dat	pointer
.	O
byte	char
-	O
startpos	long
-	O
2	int
)	O
;	O
}	O
else	O
{	O
LOG_WARN	O
(	O
"Handles page CRC: %04X vs calc. %04X from %lu-%lu=%ld\n"	pointer
,	O
crc2	int
,	O
crc1	short
,	O
startpos	long
,	O
hdl_dat	pointer
.	O
byte	char
-	O
2	int
,	O
hdl_dat	pointer
.	O
byte	char
-	O
startpos	long
-	O
2	int
)	O
;	O
error	int
|=	O
DWG_ERR_WRONGCRC	int
;	O
}	O
if	O
(	O
hdl_dat	pointer
.	O
byte	char
>=	O
endpos	long
)	O
break	O
;	O
}	O
while	O
(	O
section_size	int
>	O
2	int
)	O
;	O
free	function
(	O
hdl_dat	pointer
.	O
chain	pointer
)	O
;	O
free	function
(	O
obj_dat	struct
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
summaryinfo_private	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Bit_Chain	struct
*	O
str_dat	pointer
=	O
dat	pointer
;	O
struct	O
Dwg_SummaryInfo	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
summaryinfo	struct
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
int	O
error	int
=	O
0	int
;	O
return	O
error	int
;	O
}	O
static	O
int	O
read_2004_section_summary	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Bit_Chain	struct
old_dat	struct
,	O
sec_dat	pointer
=	O
{	O
0	int
}	O
;	O
int	O
error	int
=	O
0	int
;	O
error	int
=	O
read_2004_compressed_section	function
(	O
dat	pointer
,	O
dwg	pointer
,	O
&	O
sec_dat	pointer
,	O
SECTION_SUMMARYINFO	int
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read uncompressed %s section"	pointer
,	O
"SummaryInfo"	pointer
)	O
;	O
return	O
error	int
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
summaryinfo_address	int
!=	O
(	O
BITCODE_RL	int
)	O
dat	pointer
->	O
byte	char
)	O
LOG_WARN	O
(	O
"summaryinfo_address mismatch: "	pointer
FORMAT_RL	O
" != %lu"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
summaryinfo_address	int
,	O
dat	pointer
->	O
byte	char
)	O
;	O
LOG_TRACE	O
(	O
"SummaryInfo\n-------------------\n"	pointer
)	O
old_dat	struct
=	O
*	O
dat	pointer
;	O
dat	pointer
=	O
&	O
sec_dat	pointer
;	O
error	int
=	O
summaryinfo_private	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
*	O
dat	pointer
=	O
old_dat	struct
;	O
return	O
error	int
;	O
}	O
static	O
int	O
read_2004_section_preview	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Bit_Chain	struct
sec_dat	pointer
=	O
{	O
0	int
}	O
;	O
int	O
error	int
=	O
0	int
;	O
BITCODE_RL	int
size	char
;	O
unsigned	O
char	O
*	O
sentinel	enum
;	O
error	int
=	O
read_2004_compressed_section	function
(	O
dat	pointer
,	O
dwg	pointer
,	O
&	O
sec_dat	pointer
,	O
SECTION_PREVIEW	int
)	O
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read uncompressed %s section"	pointer
,	O
"Preview"	pointer
)	O
;	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
!=	O
(	O
BITCODE_RL	int
)	O
dat	pointer
->	O
byte	char
)	O
LOG_WARN	O
(	O
"thumbnail_address mismatch: "	pointer
FORMAT_RL	O
" != %lu"	pointer
,	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
,	O
dat	pointer
->	O
byte	char
)	O
;	O
LOG_TRACE	O
(	O
"Preview\n-------------------\n"	pointer
)	O
;	O
if	O
(	O
!	O
sec_dat	pointer
.	O
chain	pointer
||	O
sec_dat	pointer
.	O
size	char
<	O
16	int
)	O
{	O
LOG_WARN	O
(	O
"Empty thumbnail"	pointer
)	O
;	O
if	O
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
sentinel	enum
=	O
dwg_sentinel	function
(	O
DWG_SENTINEL_THUMBNAIL_BEGIN	int
)	O
;	O
if	O
(	O
memcmp	function
(	O
sentinel	enum
,	O
sec_dat	pointer
.	O
chain	pointer
,	O
16	int
)	O
)	O
{	O
LOG_WARN	O
(	O
"thumbnail sentinel mismatch"	pointer
)	O
;	O
free	function
(	O
sec_dat	pointer
.	O
chain	pointer
)	O
;	O
return	O
error	int
;	O
}	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
=	O
sec_dat	pointer
.	O
size	char
-	O
32	int
;	O
dwg	pointer
->	O
thumbnail	struct
.	O
chain	pointer
=	O
sec_dat	pointer
.	O
chain	pointer
;	O
dwg	pointer
->	O
thumbnail	struct
.	O
byte	char
=	O
16	int
;	O
dwg_bmp	function
(	O
dwg	pointer
,	O
&	O
size	char
)	O
;	O
if	O
(	O
abs	function
(	O
(	O
int	O
)	O
(	O
(	O
long	O
)	O
size	char
-	O
(	O
long	O
)	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
)	O
)	O
>	O
200	int
)	O
LOG_WARN	O
(	O
"thumbnail.size mismatch: %lu != "	pointer
FORMAT_RL	O
,	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
,	O
size	char
)	O
;	O
dat	pointer
->	O
byte	char
+=	O
dwg	pointer
->	O
thumbnail	struct
.	O
size	char
;	O
return	O
error	int
;	O
}	O
static	O
void	O
decrypt_R2004_header	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
BITCODE_RC	char
*	O
restrict	O
decrypted	pointer
,	O
unsigned	O
long	O
size	char
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
unsigned	O
int	O
rseed	int
=	O
1	int
;	O
unsigned	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	char
;	O
i	int
++	O
)	O
{	O
rseed	int
*=	O
0x343fd	int
;	O
rseed	int
+=	O
0x269ec3	int
;	O
decrypted	pointer
[	O
i	int
]	O
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
^	O
(	O
rseed	int
>>	O
0x10	int
)	O
;	O
}	O
}	O
GCC30_DIAG_IGNORE	O
(	O
-	O
Wformat	O
-	O
nonliteral	O
)	O
static	O
int	O
decode_R2004_header	function
(	O
Bit_Chain	struct
*	O
restrict	O
file_dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
int	O
error	int
=	O
0	int
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
struct	O
Dwg_R2004_Header	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
r2004_header	struct
;	O
Bit_Chain	struct
*	O
hdl_dat	pointer
=	O
file_dat	pointer
;	O
{	O
const	O
unsigned	O
long	O
size	char
=	O
sizeof	O
(	O
struct	O
Dwg_R2004_Header	struct
)	O
;	O
BITCODE_RC	char
decrypted_data	array
[	O
size	char
]	O
;	O
Bit_Chain	struct
decrypted_header_dat	struct
=	O
*	O
file_dat	pointer
;	O
Bit_Chain	struct
*	O
dat	pointer
;	O
decrypted_header_dat	struct
.	O
size	char
=	O
size	char
;	O
decrypted_header_dat	struct
.	O
chain	pointer
=	O
decrypted_data	array
;	O
decrypted_header_dat	struct
.	O
byte	char
=	O
decrypted_header_dat	struct
.	O
bit	char
=	O
0	int
;	O
file_dat	pointer
->	O
byte	char
=	O
0x80	int
;	O
file_dat	pointer
->	O
bit	char
=	O
0	int
;	O
decrypt_R2004_header	function
(	O
file_dat	pointer
,	O
decrypted_data	array
,	O
size	char
,	O
dwg	pointer
)	O
;	O
dat	pointer
=	O
&	O
decrypted_header_dat	struct
;	O
dat	pointer
->	O
bit	char
=	O
dat	pointer
->	O
byte	char
=	O
0	int
;	O
LOG_TRACE	O
(	O
"\n#### 2004 File Header ####\n"	pointer
)	O
;	O
}	O
{	O
Bit_Chain	struct
*	O
dat	pointer
=	O
file_dat	pointer
;	O
dat	pointer
->	O
byte	char
=	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_map_address	long
+	O
0x100	int
;	O
LOG_TRACE	O
(	O
"\n=== Read System Section (Section Page Map) ===\n\n"	pointer
)	O
FIELD_RLx	O
(	O
section_type	int
,	O
0	int
)	O
;	O
if	O
(	O
FIELD_VALUE	O
(	O
section_type	int
)	O
!=	O
0x41630e3b	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid System Section Page Map type 0x%x != 0x41630e3b"	pointer
,	O
FIELD_VALUE	O
(	O
section_type	int
)	O
)	O
;	O
return	O
DWG_ERR_SECTIONNOTFOUND	int
;	O
}	O
FIELD_RL	O
(	O
decomp_data_size	int
,	O
0	int
)	O
;	O
FIELD_RL	O
(	O
comp_data_size	int
,	O
0	int
)	O
;	O
FIELD_RL	O
(	O
compression_type	int
,	O
0	int
)	O
;	O
FIELD_RLx	O
(	O
checksum	int
,	O
0	int
)	O
;	O
}	O
return	O
error	int
;	O
}	O
static	O
int	O
decode_R2004	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
int	O
j	int
,	O
error	int
=	O
0	int
;	O
Dwg_Section	struct
*	O
section	pointer
;	O
{	O
struct	O
Dwg_Header	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
Bit_Chain	struct
*	O
hdl_dat	pointer
=	O
dat	pointer
;	O
int	O
i	int
;	O
dat	pointer
->	O
byte	char
=	O
0x06	int
;	O
}	O
error	int
|=	O
decode_R2004_header	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
if	O
(	O
error	int
>	O
DWG_ERR_CRITICAL	O
)	O
return	O
error	int
;	O
error	int
|=	O
read_R2004_section_map	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
header	struct
.	O
section	pointer
||	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read R2004 Section Page Map."	pointer
)	O
return	O
error	int
|	O
DWG_ERR_INTERNALERROR	int
;	O
}	O
section	pointer
=	O
find_section	function
(	O
dwg	pointer
,	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_info_id	int
)	O
;	O
if	O
(	O
section	pointer
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
Dwg_Section	struct
*	O
_obj	pointer
=	O
section	pointer
;	O
LOG_TRACE	O
(	O
"\n=== Data Section (Section Info %d) @%lx ===\n"	pointer
,	O
dwg	pointer
->	O
r2004_header	struct
.	O
section_info_id	int
,	O
(	O
unsigned	O
long	O
)	O
section	pointer
->	O
address	long
)	O
dat	pointer
->	O
byte	char
=	O
section	pointer
->	O
address	long
;	O
FIELD_RLx	O
(	O
section_type	int
,	O
0	int
)	O
;	O
if	O
(	O
FIELD_VALUE	O
(	O
section_type	int
)	O
!=	O
0x4163003b	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid Data Section Page Map type 0x%x != 0x4163003b"	pointer
,	O
FIELD_VALUE	O
(	O
section_type	int
)	O
)	O
;	O
return	O
DWG_ERR_SECTIONNOTFOUND	int
;	O
}	O
FIELD_RL	O
(	O
decomp_data_size	int
,	O
0	int
)	O
;	O
FIELD_RL	O
(	O
comp_data_size	int
,	O
0	int
)	O
;	O
FIELD_RL	O
(	O
compression_type	int
,	O
0	int
)	O
;	O
FIELD_RLx	O
(	O
checksum	int
,	O
0	int
)	O
;	O
error	int
|=	O
read_R2004_section_info	function
(	O
dat	pointer
,	O
dwg	pointer
,	O
_obj	pointer
->	O
comp_data_size	int
,	O
_obj	pointer
->	O
decomp_data_size	int
)	O
;	O
}	O
else	O
error	int
|=	O
DWG_ERR_SECTIONNOTFOUND	int
;	O
error	int
|=	O
read_2004_section_header	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
summaryinfo_address	int
)	O
error	int
|=	O
read_2004_section_summary	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
error	int
|=	O
read_2004_section_classes	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
error	int
|=	O
read_2004_section_handles	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
thumbnail_address	int
)	O
error	int
|=	O
read_2004_section_preview	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
LOG_INFO	O
(	O
"\nnum_objects: %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
num_objects	int
)	O
LOG_TRACE	O
(	O
"num_object_refs: %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
num_object_refs	int
)	O
LOG_TRACE	O
(	O
"Resolving pointers from ObjectRef vector:\n"	pointer
)	O
error	int
|=	O
resolve_objectref_vector	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
decode_R2007	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Bit_Chain	struct
hdl_dat	pointer
=	O
{	O
0	int
}	O
;	O
int	O
error	int
;	O
hdl_dat	pointer
=	O
*	O
dat	pointer
;	O
{	O
int	O
i	int
;	O
struct	O
Dwg_Header	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
header	struct
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
dat	pointer
->	O
byte	char
=	O
0x06	int
;	O
}	O
error	int
=	O
read_r2007_meta_data	function
(	O
dat	pointer
,	O
&	O
hdl_dat	pointer
,	O
dwg	pointer
)	O
;	O
LOG_INFO	O
(	O
"\nnum_objects: %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
num_objects	int
)	O
LOG_TRACE	O
(	O
"num_object_refs: %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
dwg	pointer
->	O
num_object_refs	int
)	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
{	O
LOG_ERROR	O
(	O
"Failed to read 2007 meta data"	pointer
)	O
return	O
error	int
;	O
}	O
LOG_TRACE	O
(	O
"Resolving pointers from ObjectRef vector:\n"	pointer
)	O
return	O
error	int
|	O
resolve_objectref_vector	function
(	O
dat	pointer
,	O
dwg	pointer
)	O
;	O
}	O
static	O
int	O
eed_need_size	function
(	O
BITCODE_BS	short
need	short
,	O
BITCODE_BS	short
have	short
)	O
{	O
if	O
(	O
need	short
>	O
have	short
)	O
{	O
LOG_ERROR	O
(	O
"Invalid EED size %d > %d"	pointer
,	O
(	O
int	O
)	O
need	short
,	O
(	O
int	O
)	O
have	short
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
dwg_decode_eed_data	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Eed_Data	struct
*	O
restrict	O
data	pointer
,	O
unsigned	O
long	O
int	O
end	struct
,	O
BITCODE_BS	short
size	char
)	O
{	O
int	O
lenc	int
;	O
BITCODE_BS	short
j	int
;	O
BITCODE_RS	short
lens	short
;	O
data	pointer
->	O
code	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"code: %d [RC], "	pointer
,	O
(	O
int	O
)	O
data	pointer
->	O
code	char
)	O
;	O
switch	O
(	O
data	pointer
->	O
code	char
)	O
{	O
case	O
0	int
:	O
PRE	O
(	O
R_2007	int
)	O
{	O
if	O
(	O
eed_need_size	function
(	O
3	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
length	double
=	O
lenc	int
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
codepage	int
=	O
bit_read_RS_LE	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
(	O
long	O
)	O
lenc	int
>	O
size	char
-	O
4	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid EED string len %d, max %d"	pointer
,	O
lenc	int
,	O
(	O
int	O
)	O
size	char
-	O
4	int
)	O
dat	pointer
->	O
byte	char
=	O
end	struct
;	O
break	O
;	O
}	O
if	O
(	O
eed_need_size	function
(	O
lenc	int
+	O
3	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
bit_read_fixed	function
(	O
dat	pointer
,	O
(	O
BITCODE_RC	char
*	O
)	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
string	array
,	O
lenc	int
)	O
;	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
string	array
[	O
lenc	int
]	O
=	O
'\0'	O
;	O
LOG_TRACE	O
(	O
"string: len=%d [RC] cp=%d [RS_LE] \"%s\" [TF]\n"	pointer
,	O
(	O
int	O
)	O
lenc	int
,	O
(	O
int	O
)	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
codepage	int
,	O
data	pointer
->	O
u	union
.	O
eed_0	struct
.	O
string	array
)	O
;	O
}	O
LATER_VERSIONS	O
{	O
if	O
(	O
eed_need_size	function
(	O
2	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
data	pointer
->	O
u	union
.	O
eed_0_r2007	struct
.	O
length	double
=	O
lens	short
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
eed_need_size	function
(	O
(	O
lens	short
*	O
2	int
)	O
+	O
2	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
MIN	O
(	O
lens	short
,	O
(	O
size	char
-	O
3	int
)	O
/	O
2	int
)	O
;	O
j	int
++	O
)	O
data	pointer
->	O
u	union
.	O
eed_0_r2007	struct
.	O
string	array
[	O
j	int
]	O
=	O
bit_read_RS_LE	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
DWG_LOGLEVEL	O
>=	O
DWG_LOGLEVEL_TRACE	int
)	O
{	O
char	O
*	O
u8	pointer
=	O
bit_convert_TU	function
(	O
data	pointer
->	O
u	union
.	O
eed_0_r2007	struct
.	O
string	array
)	O
;	O
LOG_TRACE	O
(	O
"wstring: len=%d [RS] \"%s\" [TU]\n"	pointer
,	O
(	O
int	O
)	O
lens	short
,	O
u8	pointer
)	O
;	O
free	function
(	O
u8	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
2	int
:	O
if	O
(	O
eed_need_size	function
(	O
1	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
data	pointer
->	O
u	union
.	O
eed_2	struct
.	O
byte	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"byte: "	pointer
FORMAT_RC	pointer
" [RC]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_2	struct
.	O
byte	char
)	O
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
eed_need_size	function
(	O
4	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
data	pointer
->	O
u	union
.	O
eed_3	struct
.	O
layer	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"layer: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_3	struct
.	O
layer	int
)	O
;	O
break	O
;	O
case	O
4	int
:	O
if	O
(	O
eed_need_size	function
(	O
1	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
data	pointer
->	O
u	union
.	O
eed_4	struct
.	O
length	double
=	O
lenc	int
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
eed_need_size	function
(	O
lenc	int
+	O
1	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
MIN	O
(	O
lenc	int
,	O
size	char
-	O
2	int
)	O
;	O
j	int
++	O
)	O
data	pointer
->	O
u	union
.	O
eed_4	struct
.	O
data	pointer
[	O
j	int
]	O
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"binary[%d] \"%s\" [TF]\n"	pointer
,	O
j	int
-	O
1	int
,	O
data	pointer
->	O
u	union
.	O
eed_4	struct
.	O
data	pointer
)	O
;	O
break	O
;	O
case	O
5	int
:	O
if	O
(	O
eed_need_size	function
(	O
8	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
data	pointer
->	O
u	union
.	O
eed_5	struct
.	O
entity	long
=	O
bit_read_RLL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"entity: 0x%"	pointer
PRIx64	O
" [RLL]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_5	struct
.	O
entity	long
)	O
;	O
break	O
;	O
case	O
10	int
:	O
case	O
11	int
:	O
case	O
12	int
:	O
case	O
13	int
:	O
case	O
14	int
:	O
case	O
15	int
:	O
if	O
(	O
eed_need_size	function
(	O
3	int
*	O
8	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
x	double
=	O
bit_read_RD	function
(	O
dat	pointer
)	O
;	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
y	double
=	O
bit_read_RD	function
(	O
dat	pointer
)	O
;	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
z	double
=	O
bit_read_RD	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"3dpoint: (%f, %f, %f) [3RD]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
x	double
,	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
y	double
,	O
data	pointer
->	O
u	union
.	O
eed_10	struct
.	O
point	struct
.	O
z	double
)	O
;	O
break	O
;	O
case	O
40	int
:	O
case	O
41	int
:	O
case	O
42	int
:	O
if	O
(	O
eed_need_size	function
(	O
8	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
data	pointer
->	O
u	union
.	O
eed_40	struct
.	O
real	double
=	O
bit_read_RD	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"real: %f [RD]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_40	struct
.	O
real	double
)	O
;	O
break	O
;	O
case	O
70	int
:	O
if	O
(	O
eed_need_size	function
(	O
2	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
data	pointer
->	O
u	union
.	O
eed_70	struct
.	O
rs	short
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"short: "	pointer
FORMAT_RS	O
" [RS]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_70	struct
.	O
rs	short
)	O
;	O
break	O
;	O
case	O
71	int
:	O
if	O
(	O
eed_need_size	function
(	O
4	int
,	O
size	char
)	O
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
data	pointer
->	O
u	union
.	O
eed_71	struct
.	O
rl	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"long: "	pointer
FORMAT_RL	O
" [RL]\n"	pointer
,	O
data	pointer
->	O
u	union
.	O
eed_71	struct
.	O
rl	int
)	O
;	O
break	O
;	O
default	O
:	O
LOG_ERROR	O
(	O
"unknown EED code %d"	pointer
,	O
data	pointer
->	O
code	char
)	O
;	O
LOG_POS	O
dat	pointer
->	O
byte	char
=	O
end	struct
;	O
LOG_POS	O
return	O
DWG_ERR_INVALIDEED	int
;	O
}	O
LOG_POS	O
return	O
0	int
;	O
}	O
static	O
int	O
dwg_decode_eed	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
BITCODE_BS	short
size	char
;	O
int	O
error	int
=	O
0	int
;	O
unsigned	O
int	O
idx	long
=	O
0	int
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
dwg	pointer
;	O
Dwg_Object	struct
*	O
_obj	pointer
;	O
long	O
unsigned	O
int	O
sav_byte	long
=	O
dat	pointer
->	O
byte	char
;	O
if	O
(	O
!	O
dwg	pointer
)	O
return	O
DWG_ERR_INVALIDEED	int
;	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
obj	pointer
->	O
objid	int
]	O
;	O
obj	pointer
->	O
num_eed	int
=	O
0	int
;	O
while	O
(	O
(	O
size	char
=	O
bit_read_BS	function
(	O
dat	pointer
)	O
)	O
)	O
{	O
int	O
i	int
;	O
BITCODE_BS	short
j	int
;	O
long	O
unsigned	O
int	O
end	struct
,	O
offset	double
;	O
LOG_TRACE	O
(	O
"EED[%u] size: "	pointer
FORMAT_BS	O
" [BS]\n"	pointer
,	O
idx	long
,	O
size	char
)	O
;	O
LOG_POS	O
if	O
(	O
size	char
>	O
_obj	pointer
->	O
size	char
||	O
dat	pointer
->	O
byte	char
==	O
sav_byte	long
)	O
{	O
LOG_ERROR	O
(	O
"Invalid EED size "	pointer
FORMAT_BS	O
" > %u"	pointer
,	O
size	char
,	O
_obj	pointer
->	O
size	char
)	O
;	O
obj	pointer
->	O
num_eed	int
=	O
idx	long
;	O
return	O
DWG_ERR_INVALIDEED	int
;	O
}	O
obj	pointer
->	O
num_eed	int
=	O
idx	long
+	O
1	int
;	O
if	O
(	O
idx	long
)	O
{	O
obj	pointer
->	O
eed	pointer
=	O
(	O
Dwg_Eed	struct
*	O
)	O
realloc	function
(	O
obj	pointer
->	O
eed	pointer
,	O
obj	pointer
->	O
num_eed	int
*	O
sizeof	O
(	O
Dwg_Eed	struct
)	O
)	O
;	O
memset	function
(	O
&	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
,	O
0	int
,	O
sizeof	O
(	O
Dwg_Eed	struct
)	O
)	O
;	O
}	O
else	O
{	O
obj	pointer
->	O
eed	pointer
=	O
(	O
Dwg_Eed	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Eed	struct
)	O
)	O
;	O
}	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
size	char
=	O
size	char
;	O
error	int
|=	O
bit_read_H	function
(	O
dat	pointer
,	O
&	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
handle	pointer
)	O
;	O
end	struct
=	O
dat	pointer
->	O
byte	char
+	O
size	char
;	O
if	O
(	O
error	int
)	O
{	O
LOG_ERROR	O
(	O
"No EED[%d].handle"	pointer
,	O
idx	long
)	O
;	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
size	char
=	O
0	int
;	O
obj	pointer
->	O
num_eed	int
--	O
;	O
dat	pointer
->	O
byte	char
=	O
end	struct
;	O
continue	O
;	O
}	O
else	O
{	O
LOG_TRACE	O
(	O
"EED[%u] handle: "	pointer
FORMAT_H	pointer
"\n"	pointer
,	O
idx	long
,	O
ARGS_H	O
(	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
handle	pointer
)	O
)	O
;	O
LOG_POS	O
;	O
if	O
(	O
dat	pointer
->	O
byte	char
>=	O
dat	pointer
->	O
size	char
)	O
end	struct
=	O
dat	pointer
->	O
byte	char
;	O
if	O
(	O
_obj	pointer
->	O
supertype	enum
==	O
DWG_SUPERTYPE_OBJECT	int
&&	O
_obj	pointer
->	O
dxfname	pointer
&&	O
strEQc	O
(	O
_obj	pointer
->	O
dxfname	pointer
,	O
"MLEADERSTYLE"	pointer
)	O
)	O
{	O
Dwg_Object_Ref	struct
ref	pointer
;	O
ref	pointer
.	O
obj	pointer
=	O
NULL	O
;	O
ref	pointer
.	O
handleref	struct
=	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
handle	pointer
;	O
ref	pointer
.	O
absolute_ref	long
=	O
0L	int
;	O
if	O
(	O
dwg_resolve_handleref	function
(	O
&	O
ref	pointer
,	O
_obj	pointer
)	O
)	O
{	O
Dwg_Object_APPID_CONTROL	struct
*	O
appid	pointer
=	O
&	O
dwg	pointer
->	O
appid_control	struct
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
appid	pointer
->	O
num_entries	short
;	O
j	int
++	O
)	O
{	O
if	O
(	O
appid	pointer
->	O
entries	pointer
[	O
j	int
]	O
&&	O
appid	pointer
->	O
entries	pointer
[	O
j	int
]	O
->	O
absolute_ref	long
==	O
ref	pointer
.	O
absolute_ref	long
)	O
{	O
Dwg_Object_MLEADERSTYLE	struct
*	O
this	pointer
=	O
obj	pointer
->	O
tio	union
.	O
MLEADERSTYLE	pointer
;	O
this	pointer
->	O
is_new_format	char
=	O
1	int
;	O
LOG_TRACE	O
(	O
"EED found ACAD_MLEADERVER %lX: new format\n"	pointer
,	O
ref	pointer
.	O
absolute_ref	long
)	O
;	O
}	O
}	O
}	O
}	O
}	O
sav_byte	long
=	O
dat	pointer
->	O
byte	char
;	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
raw	pointer
=	O
bit_read_TF	function
(	O
dat	pointer
,	O
size	char
)	O
;	O
LOG_TRACE	O
(	O
"EED[%u] raw: %d\n"	pointer
,	O
idx	long
,	O
size	char
)	O
;	O
LOG_TRACE_TF	O
(	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
raw	pointer
,	O
size	char
)	O
;	O
dat	pointer
->	O
byte	char
=	O
sav_byte	long
;	O
LOG_POS	O
while	O
(	O
dat	pointer
->	O
byte	char
<	O
end	struct
)	O
{	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
data	pointer
=	O
(	O
Dwg_Eed_Data	struct
*	O
)	O
calloc	function
(	O
size	char
+	O
8	int
,	O
1	int
)	O
;	O
LOG_TRACE	O
(	O
"EED[%u] "	pointer
,	O
idx	long
)	O
;	O
error	int
|=	O
dwg_decode_eed_data	function
(	O
dat	pointer
,	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
data	pointer
,	O
end	struct
,	O
size	char
)	O
;	O
if	O
(	O
dat	pointer
->	O
byte	char
>=	O
dat	pointer
->	O
size	char
||	O
dat	pointer
->	O
byte	char
==	O
sav_byte	long
)	O
error	int
|=	O
DWG_ERR_INVALIDEED	int
;	O
if	O
(	O
error	int
&	O
DWG_ERR_INVALIDEED	int
)	O
{	O
free	function
(	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
data	pointer
)	O
;	O
LOG_HANDLE	O
(	O
"        invalid eed[%d]: skip\n"	pointer
,	O
idx	long
)	O
;	O
LOG_POS	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
data	pointer
=	O
NULL	O
;	O
obj	pointer
->	O
num_eed	int
--	O
;	O
dat	pointer
->	O
byte	char
=	O
end	struct
;	O
continue	O
;	O
}	O
if	O
(	O
dat	pointer
->	O
byte	char
<	O
end	struct
-	O
1	int
)	O
{	O
idx	long
++	O
;	O
obj	pointer
->	O
num_eed	int
=	O
idx	long
+	O
1	int
;	O
size	char
=	O
(	O
long	O
)	O
(	O
end	struct
-	O
dat	pointer
->	O
byte	char
+	O
1	int
)	O
;	O
obj	pointer
->	O
eed	pointer
=	O
(	O
Dwg_Eed	struct
*	O
)	O
realloc	function
(	O
obj	pointer
->	O
eed	pointer
,	O
obj	pointer
->	O
num_eed	int
*	O
sizeof	O
(	O
Dwg_Eed	struct
)	O
)	O
;	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
handle	pointer
=	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
-	O
1	int
]	O
.	O
handle	pointer
;	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
size	char
=	O
0	int
;	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
raw	pointer
=	O
NULL	O
;	O
sav_byte	long
=	O
dat	pointer
->	O
byte	char
;	O
}	O
else	O
{	O
break	O
;	O
}	O
}	O
LOG_POS	O
if	O
(	O
obj	pointer
->	O
eed	pointer
[	O
idx	long
]	O
.	O
raw	pointer
)	O
{	O
dat	pointer
->	O
byte	char
=	O
end	struct
;	O
LOG_POS	O
}	O
idx	long
++	O
;	O
}	O
LOG_HANDLE	O
(	O
"EED[%u] size: "	pointer
FORMAT_BS	O
" [BS] (end)\n"	pointer
,	O
idx	long
,	O
size	char
)	O
;	O
LOG_TRACE	O
(	O
"num_eed: "	pointer
FORMAT_BL	O
"\n"	pointer
,	O
obj	pointer
->	O
num_eed	int
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
dwg_decode_ole2	function
(	O
Dwg_Entity_OLE2FRAME	struct
*	O
restrict	O
_obj	pointer
)	O
{	O
Bit_Chain	struct
bdat	struct
;	O
Bit_Chain	struct
*	O
dat	pointer
=	O
&	O
bdat	struct
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
dat	pointer
->	O
byte	char
=	O
0	int
;	O
dat	pointer
->	O
size	char
=	O
0x80	int
;	O
dat	pointer
->	O
chain	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
_obj	pointer
->	O
data	pointer
[	O
0	int
]	O
;	O
dat	pointer
->	O
version	short
=	O
_obj	pointer
->	O
parent	pointer
->	O
dwg	pointer
->	O
header	struct
.	O
version	short
;	O
_obj	pointer
->	O
oleversion	short
=	O
2	int
;	O
_obj	pointer
->	O
oleclient	pointer
=	O
(	O
char	O
*	O
)	O
"OLE"	pointer
;	O
_obj	pointer
->	O
pt1	struct
.	O
x	double
=	O
30.13602472538446	int
;	O
_obj	pointer
->	O
pt1	struct
.	O
y	double
=	O
-	O
18.98882829402869	int
;	O
_obj	pointer
->	O
pt2	struct
.	O
x	double
=	O
35.27188116753285	int
;	O
_obj	pointer
->	O
pt2	struct
.	O
y	double
=	O
-	O
22.39344715050545	int
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
dat	pointer
->	O
byte	char
=	O
0	int
;	O
dat	pointer
->	O
size	char
=	O
_obj	pointer
->	O
data_length	int
;	O
dat	pointer
->	O
chain	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
_obj	pointer
->	O
data	pointer
[	O
0x80	int
]	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
obj_has_strings	function
(	O
unsigned	O
int	O
type	short
)	O
{	O
switch	O
(	O
type	short
)	O
{	O
case	O
DWG_TYPE_TEXT	int
:	O
case	O
DWG_TYPE_ATTRIB	int
:	O
case	O
DWG_TYPE_ATTDEF	int
:	O
case	O
DWG_TYPE_BLOCK	int
:	O
return	O
1	int
;	O
case	O
DWG_TYPE_ENDBLK	int
:	O
case	O
DWG_TYPE_SEQEND	int
:	O
case	O
DWG_TYPE_INSERT	int
:	O
case	O
DWG_TYPE_MINSERT	int
:	O
case	O
DWG_TYPE_VERTEX_2D	int
:	O
case	O
DWG_TYPE_VERTEX_3D	int
:	O
case	O
DWG_TYPE_VERTEX_MESH	int
:	O
case	O
DWG_TYPE_VERTEX_PFACE	int
:	O
case	O
DWG_TYPE_VERTEX_PFACE_FACE	int
:	O
case	O
DWG_TYPE_POLYLINE_2D	int
:	O
case	O
DWG_TYPE_POLYLINE_3D	int
:	O
case	O
DWG_TYPE_ARC	int
:	O
case	O
DWG_TYPE_CIRCLE	int
:	O
case	O
DWG_TYPE_LINE	int
:	O
return	O
0	int
;	O
case	O
DWG_TYPE_DIMENSION_ORDINATE	int
:	O
case	O
DWG_TYPE_DIMENSION_LINEAR	int
:	O
case	O
DWG_TYPE_DIMENSION_ALIGNED	int
:	O
case	O
DWG_TYPE_DIMENSION_ANG3PT	int
:	O
case	O
DWG_TYPE_DIMENSION_ANG2LN	int
:	O
case	O
DWG_TYPE_DIMENSION_RADIUS	int
:	O
case	O
DWG_TYPE_DIMENSION_DIAMETER	int
:	O
return	O
1	int
;	O
case	O
DWG_TYPE_POINT	int
:	O
case	O
DWG_TYPE__3DFACE	int
:	O
case	O
DWG_TYPE_POLYLINE_PFACE	int
:	O
case	O
DWG_TYPE_POLYLINE_MESH	int
:	O
case	O
DWG_TYPE_SOLID	int
:	O
case	O
DWG_TYPE_TRACE	int
:	O
case	O
DWG_TYPE_SHAPE	int
:	O
return	O
0	int
;	O
case	O
DWG_TYPE_VIEWPORT	int
:	O
return	O
1	int
;	O
case	O
DWG_TYPE_ELLIPSE	int
:	O
case	O
DWG_TYPE_SPLINE	int
:	O
return	O
0	int
;	O
case	O
DWG_TYPE_REGION	int
:	O
case	O
DWG_TYPE__3DSOLID	int
:	O
case	O
DWG_TYPE_BODY	int
:	O
return	O
1	int
;	O
case	O
DWG_TYPE_RAY	int
:	O
case	O
DWG_TYPE_XLINE	int
:	O
return	O
0	int
;	O
case	O
DWG_TYPE_DICTIONARY	int
:	O
case	O
DWG_TYPE_OLEFRAME	int
:	O
case	O
DWG_TYPE_MTEXT	int
:	O
case	O
DWG_TYPE_LEADER	int
:	O
return	O
1	int
;	O
case	O
DWG_TYPE_TOLERANCE	int
:	O
case	O
DWG_TYPE_MLINE	int
:	O
return	O
0	int
;	O
case	O
DWG_TYPE_BLOCK_CONTROL	int
:	O
case	O
DWG_TYPE_LAYER_CONTROL	int
:	O
case	O
DWG_TYPE_STYLE_CONTROL	int
:	O
case	O
DWG_TYPE_LTYPE_CONTROL	int
:	O
case	O
DWG_TYPE_VIEW_CONTROL	int
:	O
case	O
DWG_TYPE_UCS_CONTROL	int
:	O
case	O
DWG_TYPE_VPORT_CONTROL	int
:	O
case	O
DWG_TYPE_APPID_CONTROL	int
:	O
case	O
DWG_TYPE_DIMSTYLE_CONTROL	int
:	O
case	O
DWG_TYPE_VPORT_ENTITY_CONTROL	int
:	O
return	O
0	int
;	O
case	O
DWG_TYPE_BLOCK_HEADER	int
:	O
case	O
DWG_TYPE_LAYER	int
:	O
case	O
DWG_TYPE_STYLE	int
:	O
case	O
DWG_TYPE_LTYPE	int
:	O
case	O
DWG_TYPE_VIEW	int
:	O
case	O
DWG_TYPE_UCS	int
:	O
case	O
DWG_TYPE_VPORT	int
:	O
case	O
DWG_TYPE_APPID	int
:	O
case	O
DWG_TYPE_DIMSTYLE	int
:	O
case	O
DWG_TYPE_VPORT_ENTITY_HEADER	int
:	O
return	O
1	int
;	O
case	O
DWG_TYPE_GROUP	int
:	O
case	O
DWG_TYPE_MLINESTYLE	int
:	O
case	O
DWG_TYPE_OLE2FRAME	int
:	O
return	O
1	int
;	O
case	O
DWG_TYPE_DUMMY	int
:	O
case	O
DWG_TYPE_LONG_TRANSACTION	int
:	O
case	O
DWG_TYPE_LWPOLYLINE	int
:	O
return	O
0	int
;	O
case	O
DWG_TYPE_HATCH	int
:	O
case	O
DWG_TYPE_XRECORD	int
:	O
return	O
1	int
;	O
case	O
DWG_TYPE_PLACEHOLDER	int
:	O
return	O
0	int
;	O
case	O
DWG_TYPE_VBA_PROJECT	int
:	O
case	O
DWG_TYPE_LAYOUT	int
:	O
case	O
DWG_TYPE_PROXY_ENTITY	int
:	O
case	O
DWG_TYPE_PROXY_OBJECT	int
:	O
default	O
:	O
return	O
1	int
;	O
}	O
}	O
static	O
int	O
dwg_decode_entity	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
str_dat	pointer
,	O
Dwg_Object_Entity	struct
*	O
restrict	O
ent	pointer
)	O
{	O
unsigned	O
int	O
i	int
;	O
int	O
error	int
=	O
0	int
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
ent	pointer
->	O
dwg	pointer
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
ent	pointer
->	O
objid	int
]	O
;	O
Dwg_Object_Entity	struct
*	O
_obj	pointer
=	O
ent	pointer
;	O
unsigned	O
long	O
objectpos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
obj	pointer
->	O
bitsize_pos	long
=	O
objectpos	long
;	O
PRE	O
(	O
R_13	int
)	O
{	O
if	O
(	O
FIELD_VALUE	O
(	O
flag_r11	char
)	O
&	O
4	int
&&	O
FIELD_VALUE	O
(	O
kind_r11	short
)	O
>	O
2	int
&&	O
FIELD_VALUE	O
(	O
kind_r11	short
)	O
!=	O
22	int
)	O
FIELD_RD	O
(	O
elevation_r11	double
,	O
30	int
)	O
;	O
if	O
(	O
FIELD_VALUE	O
(	O
flag_r11	char
)	O
&	O
8	int
)	O
FIELD_RD	O
(	O
thickness_r11	double
,	O
39	int
)	O
;	O
if	O
(	O
FIELD_VALUE	O
(	O
flag_r11	char
)	O
&	O
0x20	int
)	O
{	O
Dwg_Object_Ref	struct
*	O
hdl	array
=	O
dwg_decode_handleref_with_code	function
(	O
dat	pointer
,	O
obj	pointer
,	O
dwg	pointer
,	O
0	int
)	O
;	O
if	O
(	O
hdl	array
)	O
obj	pointer
->	O
handle	pointer
=	O
hdl	array
->	O
handleref	struct
;	O
}	O
if	O
(	O
FIELD_VALUE	O
(	O
extra_r11	char
)	O
&	O
4	int
)	O
FIELD_RS	O
(	O
paper_r11	short
,	O
0	int
)	O
;	O
}	O
VERSIONS	O
(	O
R_2000	int
,	O
R_2007	int
)	O
{	O
obj	pointer
->	O
bitsize	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"bitsize: "	pointer
FORMAT_RL	O
" [RL] @%lu.%u\n"	pointer
,	O
obj	pointer
->	O
bitsize	int
,	O
dat	pointer
->	O
byte	char
-	O
2	int
,	O
dat	pointer
->	O
bit	char
)	O
;	O
if	O
(	O
obj	pointer
->	O
bitsize	int
>	O
obj	pointer
->	O
size	char
*	O
8	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid bitsize "	pointer
FORMAT_RL	O
" => "	pointer
FORMAT_RL	O
,	O
obj	pointer
->	O
bitsize	int
,	O
obj	pointer
->	O
size	char
*	O
8	int
)	O
;	O
obj	pointer
->	O
bitsize	int
=	O
obj	pointer
->	O
size	char
*	O
8	int
;	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
}	O
SINCE	O
(	O
R_2007	int
)	O
{	O
SINCE	O
(	O
R_2010	int
)	O
LOG_HANDLE	O
(	O
" bitsize: "	pointer
FORMAT_RL	O
","	pointer
,	O
obj	pointer
->	O
bitsize	int
)	O
;	O
error	int
|=	O
obj_handle_stream	function
(	O
dat	pointer
,	O
obj	pointer
,	O
hdl_dat	pointer
)	O
;	O
if	O
(	O
obj	pointer
->	O
type	short
>=	O
500	int
||	O
obj_has_strings	function
(	O
obj	pointer
->	O
type	short
)	O
)	O
error	int
|=	O
obj_string_stream	function
(	O
dat	pointer
,	O
obj	pointer
,	O
str_dat	pointer
)	O
;	O
else	O
{	O
str_dat	pointer
->	O
chain	pointer
+=	O
str_dat	pointer
->	O
byte	char
;	O
str_dat	pointer
->	O
byte	char
=	O
0	int
;	O
str_dat	pointer
->	O
bit	char
=	O
0	int
;	O
str_dat	pointer
->	O
size	char
=	O
0	int
;	O
bit_advance_position	function
(	O
str_dat	pointer
,	O
obj	pointer
->	O
bitsize	int
-	O
1	int
-	O
8	int
)	O
;	O
}	O
}	O
error	int
|=	O
bit_read_H	function
(	O
dat	pointer
,	O
&	O
(	O
obj	pointer
->	O
handle	pointer
)	O
)	O
;	O
if	O
(	O
error	int
&	O
DWG_ERR_INVALIDHANDLE	int
)	O
{	O
LOG_WARN	O
(	O
"dwg_decode_entity handle @%lu.%u"	pointer
,	O
dat	pointer
->	O
byte	char
,	O
dat	pointer
->	O
bit	char
)	O
;	O
obj	pointer
->	O
bitsize	int
=	O
0	int
;	O
ent	pointer
->	O
num_eed	int
=	O
0	int
;	O
ent	pointer
->	O
preview_exists	char
=	O
0	int
;	O
return	O
error	int
;	O
}	O
LOG_TRACE	O
(	O
"handle: "	pointer
FORMAT_H	pointer
" [H 5]\n"	pointer
,	O
ARGS_H	O
(	O
obj	pointer
->	O
handle	pointer
)	O
)	O
PRE	O
(	O
R_13	int
)	O
{	O
return	O
DWG_ERR_NOTYETSUPPORTED	int
;	O
}	O
error	int
|=	O
dwg_decode_eed	function
(	O
dat	pointer
,	O
(	O
Dwg_Object_Object	struct
*	O
)	O
ent	pointer
)	O
;	O
if	O
(	O
error	int
&	O
(	O
DWG_ERR_INVALIDEED	int
|	O
DWG_ERR_VALUEOUTOFBOUNDS	int
)	O
)	O
return	O
error	int
;	O
SINCE	O
(	O
R_2007	int
)	O
{	O
dwg_decode_common_entity_handle_data	function
(	O
dat	pointer
,	O
hdl_dat	pointer
,	O
obj	pointer
)	O
;	O
}	O
obj	pointer
->	O
common_size	long
=	O
bit_position	function
(	O
dat	pointer
)	O
-	O
objectpos	long
;	O
LOG_HANDLE	O
(	O
"--common_size: %lu\n"	pointer
,	O
obj	pointer
->	O
common_size	long
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
dwg_decode_object	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
str_dat	pointer
,	O
Dwg_Object_Object	struct
*	O
restrict	O
_obj	pointer
)	O
{	O
unsigned	O
int	O
i	int
;	O
int	O
error	int
=	O
0	int
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
_obj	pointer
->	O
dwg	pointer
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
_obj	pointer
->	O
objid	int
]	O
;	O
unsigned	O
long	O
objectpos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
obj	pointer
->	O
bitsize_pos	long
=	O
objectpos	long
;	O
VERSIONS	O
(	O
R_2000	int
,	O
R_2007	int
)	O
{	O
obj	pointer
->	O
bitsize	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"bitsize: "	pointer
FORMAT_RL	O
" [RL] @%lu.%u\n"	pointer
,	O
obj	pointer
->	O
bitsize	int
,	O
dat	pointer
->	O
byte	char
-	O
2	int
,	O
dat	pointer
->	O
bit	char
)	O
if	O
(	O
obj	pointer
->	O
bitsize	int
>	O
obj	pointer
->	O
size	char
*	O
8	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid bitsize "	pointer
FORMAT_RL	O
" => "	pointer
FORMAT_RL	O
,	O
obj	pointer
->	O
bitsize	int
,	O
obj	pointer
->	O
size	char
*	O
8	int
)	O
;	O
obj	pointer
->	O
bitsize	int
=	O
obj	pointer
->	O
size	char
*	O
8	int
;	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
}	O
SINCE	O
(	O
R_2007	int
)	O
{	O
SINCE	O
(	O
R_2010	int
)	O
LOG_HANDLE	O
(	O
" bitsize: "	pointer
FORMAT_RL	O
","	pointer
,	O
obj	pointer
->	O
bitsize	int
)	O
;	O
error	int
|=	O
obj_handle_stream	function
(	O
dat	pointer
,	O
obj	pointer
,	O
hdl_dat	pointer
)	O
;	O
if	O
(	O
obj	pointer
->	O
type	short
>=	O
500	int
||	O
obj_has_strings	function
(	O
obj	pointer
->	O
type	short
)	O
)	O
error	int
|=	O
obj_string_stream	function
(	O
dat	pointer
,	O
obj	pointer
,	O
str_dat	pointer
)	O
;	O
else	O
{	O
str_dat	pointer
->	O
chain	pointer
+=	O
str_dat	pointer
->	O
byte	char
;	O
str_dat	pointer
->	O
byte	char
=	O
0	int
;	O
str_dat	pointer
->	O
bit	char
=	O
0	int
;	O
str_dat	pointer
->	O
size	char
=	O
0	int
;	O
bit_advance_position	function
(	O
str_dat	pointer
,	O
obj	pointer
->	O
bitsize	int
-	O
1	int
-	O
8	int
)	O
;	O
}	O
}	O
error	int
|=	O
bit_read_H	function
(	O
dat	pointer
,	O
&	O
obj	pointer
->	O
handle	pointer
)	O
;	O
if	O
(	O
error	int
&	O
DWG_ERR_INVALIDHANDLE	int
)	O
{	O
LOG_ERROR	O
(	O
"Wrong object handle at pos 0x%0lx"	pointer
,	O
dat	pointer
->	O
byte	char
)	O
return	O
error	int
;	O
}	O
LOG_TRACE	O
(	O
"handle: "	pointer
FORMAT_H	pointer
" [H 5]\n"	pointer
,	O
ARGS_H	O
(	O
obj	pointer
->	O
handle	pointer
)	O
)	O
error	int
|=	O
dwg_decode_eed	function
(	O
dat	pointer
,	O
_obj	pointer
)	O
;	O
if	O
(	O
error	int
&	O
(	O
DWG_ERR_INVALIDEED	int
|	O
DWG_ERR_VALUEOUTOFBOUNDS	int
)	O
)	O
return	O
error	int
;	O
VERSIONS	O
(	O
R_13	int
,	O
R_14	int
)	O
{	O
obj	pointer
->	O
bitsize	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"bitsize: %u [RL]\n"	pointer
,	O
obj	pointer
->	O
bitsize	int
)	O
;	O
if	O
(	O
obj	pointer
->	O
bitsize	int
>	O
obj	pointer
->	O
size	char
*	O
8	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid bitsize "	pointer
FORMAT_RL	O
" => "	pointer
FORMAT_RL	O
,	O
obj	pointer
->	O
bitsize	int
,	O
obj	pointer
->	O
size	char
*	O
8	int
)	O
;	O
obj	pointer
->	O
bitsize	int
=	O
obj	pointer
->	O
size	char
*	O
8	int
;	O
error	int
|=	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
}	O
FIELD_BL	O
(	O
num_reactors	int
,	O
0	int
)	O
;	O
SINCE	O
(	O
R_2010	int
)	O
{	O
if	O
(	O
_obj	pointer
->	O
num_reactors	int
>	O
0x1000	int
)	O
{	O
LOG_WARN	O
(	O
"Invalid num_reactors %ld"	pointer
,	O
(	O
long	O
)	O
_obj	pointer
->	O
num_reactors	int
)	O
_obj	pointer
->	O
num_reactors	int
=	O
0	int
;	O
}	O
}	O
SINCE	O
(	O
R_2004	int
)	O
{	O
FIELD_B	O
(	O
xdic_missing_flag	char
,	O
0	int
)	O
;	O
}	O
SINCE	O
(	O
R_2013	int
)	O
{	O
FIELD_B	O
(	O
has_ds_binary_data	char
,	O
0	int
)	O
;	O
}	O
obj	pointer
->	O
common_size	long
=	O
bit_position	function
(	O
dat	pointer
)	O
-	O
objectpos	long
;	O
LOG_HANDLE	O
(	O
"--common_size: %lu\n"	pointer
,	O
obj	pointer
->	O
common_size	long
)	O
;	O
return	O
error	int
;	O
}	O
static	O
int	O
dwg_decode_add_object_ref	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
ref	pointer
)	O
{	O
Dwg_Object_Ref	struct
*	O
*	O
object_ref_old	pointer
=	O
dwg	pointer
->	O
object_ref	pointer
;	O
if	O
(	O
!	O
dwg	pointer
->	O
num_object_refs	int
)	O
dwg	pointer
->	O
object_ref	pointer
=	O
calloc	function
(	O
REFS_PER_REALLOC	int
,	O
sizeof	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
)	O
;	O
else	O
if	O
(	O
dwg	pointer
->	O
num_object_refs	int
%	O
REFS_PER_REALLOC	int
==	O
0	int
)	O
dwg	pointer
->	O
object_ref	pointer
=	O
realloc	function
(	O
dwg	pointer
->	O
object_ref	pointer
,	O
(	O
dwg	pointer
->	O
num_object_refs	int
+	O
REFS_PER_REALLOC	int
)	O
*	O
sizeof	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
object_ref	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
dwg	pointer
->	O
object_ref	pointer
=	O
object_ref_old	pointer
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
dwg	pointer
->	O
object_ref	pointer
[	O
dwg	pointer
->	O
num_object_refs	int
++	O
]	O
=	O
ref	pointer
;	O
return	O
0	int
;	O
}	O
Dwg_Object_Ref	struct
*	O
dwg_new_ref	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Object_Ref	struct
*	O
ref	pointer
=	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Object_Ref	struct
)	O
)	O
;	O
if	O
(	O
!	O
ref	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
dwg_decode_add_object_ref	function
(	O
dwg	pointer
,	O
ref	pointer
)	O
)	O
{	O
free	function
(	O
ref	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
ref	pointer
;	O
}	O
Dwg_Object_Ref	struct
*	O
dwg_decode_handleref	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Object_Ref	struct
*	O
ref	pointer
=	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Object_Ref	struct
)	O
)	O
;	O
if	O
(	O
!	O
ref	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
bit_read_H	function
(	O
dat	pointer
,	O
&	O
ref	pointer
->	O
handleref	struct
)	O
)	O
{	O
LOG_WARN	O
(	O
"Invalid handleref: "	pointer
FORMAT_REF	pointer
,	O
ARGS_REF	O
(	O
ref	pointer
)	O
)	O
free	function
(	O
ref	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
ref	pointer
->	O
handleref	struct
.	O
size	char
||	O
(	O
obj	pointer
&&	O
ref	pointer
->	O
handleref	struct
.	O
code	char
>	O
5	int
)	O
)	O
{	O
if	O
(	O
dwg_decode_add_object_ref	function
(	O
dwg	pointer
,	O
ref	pointer
)	O
)	O
{	O
free	function
(	O
ref	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
ref	pointer
->	O
handleref	struct
.	O
value	double
)	O
{	O
if	O
(	O
obj	pointer
)	O
{	O
free	function
(	O
ref	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
ref	pointer
->	O
absolute_ref	long
=	O
0	int
;	O
ref	pointer
->	O
obj	pointer
=	O
NULL	O
;	O
return	O
ref	pointer
;	O
}	O
if	O
(	O
!	O
obj	pointer
)	O
{	O
if	O
(	O
ref	pointer
->	O
handleref	struct
.	O
value	double
)	O
{	O
ref	pointer
->	O
absolute_ref	long
=	O
ref	pointer
->	O
handleref	struct
.	O
value	double
;	O
ref	pointer
->	O
obj	pointer
=	O
NULL	O
;	O
return	O
ref	pointer
;	O
}	O
if	O
(	O
ref	pointer
->	O
handleref	struct
.	O
code	char
>=	O
6	int
)	O
{	O
LOG_ERROR	O
(	O
"Empty obj argument for handleref code %d"	pointer
,	O
ref	pointer
->	O
handleref	struct
.	O
code	char
)	O
;	O
ref	pointer
->	O
obj	pointer
=	O
NULL	O
;	O
return	O
NULL	O
;	O
}	O
}	O
switch	O
(	O
ref	pointer
->	O
handleref	struct
.	O
code	char
)	O
{	O
case	O
0x06	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
+	O
1	int
)	O
;	O
break	O
;	O
case	O
0x08	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
-	O
1	int
)	O
;	O
break	O
;	O
case	O
0x0A	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
+	O
ref	pointer
->	O
handleref	struct
.	O
value	double
)	O
;	O
break	O
;	O
case	O
0x0C	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
-	O
ref	pointer
->	O
handleref	struct
.	O
value	double
)	O
;	O
break	O
;	O
case	O
0x0E	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
obj	pointer
->	O
handle	pointer
.	O
value	double
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
case	O
4	int
:	O
case	O
5	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
ref	pointer
->	O
handleref	struct
.	O
value	double
;	O
break	O
;	O
case	O
0	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
ref	pointer
->	O
handleref	struct
.	O
value	double
;	O
break	O
;	O
default	O
:	O
ref	pointer
->	O
absolute_ref	long
=	O
0	int
;	O
ref	pointer
->	O
obj	pointer
=	O
NULL	O
;	O
LOG_WARN	O
(	O
"Invalid handle pointer code %d"	pointer
,	O
ref	pointer
->	O
handleref	struct
.	O
code	char
)	O
;	O
break	O
;	O
}	O
return	O
ref	pointer
;	O
}	O
Dwg_Object_Ref	struct
*	O
dwg_decode_handleref_with_code	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
unsigned	O
int	O
code	char
)	O
{	O
int	O
err	int
;	O
Dwg_Object_Ref	struct
*	O
ref	pointer
=	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Object_Ref	struct
)	O
)	O
;	O
if	O
(	O
!	O
ref	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
err	int
=	O
bit_read_H	function
(	O
dat	pointer
,	O
&	O
ref	pointer
->	O
handleref	struct
)	O
;	O
if	O
(	O
err	int
)	O
{	O
free	function
(	O
ref	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
ref	pointer
->	O
handleref	struct
.	O
size	char
||	O
(	O
obj	pointer
&&	O
ref	pointer
->	O
handleref	struct
.	O
code	char
>	O
5	int
)	O
)	O
{	O
if	O
(	O
dwg_decode_add_object_ref	function
(	O
dwg	pointer
,	O
ref	pointer
)	O
)	O
{	O
free	function
(	O
ref	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
ref	pointer
->	O
handleref	struct
.	O
value	double
)	O
{	O
ref	pointer
->	O
absolute_ref	long
=	O
0	int
;	O
ref	pointer
->	O
obj	pointer
=	O
NULL	O
;	O
return	O
ref	pointer
;	O
}	O
if	O
(	O
!	O
obj	pointer
)	O
{	O
ref	pointer
->	O
absolute_ref	long
=	O
ref	pointer
->	O
handleref	struct
.	O
value	double
;	O
ref	pointer
->	O
obj	pointer
=	O
NULL	O
;	O
return	O
ref	pointer
;	O
}	O
switch	O
(	O
ref	pointer
->	O
handleref	struct
.	O
code	char
)	O
{	O
case	O
0x06	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
+	O
1	int
)	O
;	O
break	O
;	O
case	O
0x08	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
-	O
1	int
)	O
;	O
break	O
;	O
case	O
0x0A	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
+	O
ref	pointer
->	O
handleref	struct
.	O
value	double
)	O
;	O
break	O
;	O
case	O
0x0C	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
-	O
ref	pointer
->	O
handleref	struct
.	O
value	double
)	O
;	O
break	O
;	O
case	O
0x0E	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
obj	pointer
->	O
handle	pointer
.	O
value	double
;	O
break	O
;	O
case	O
2	int
:	O
case	O
3	int
:	O
case	O
4	int
:	O
case	O
5	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
ref	pointer
->	O
handleref	struct
.	O
value	double
;	O
break	O
;	O
case	O
0	int
:	O
ref	pointer
->	O
absolute_ref	long
=	O
ref	pointer
->	O
handleref	struct
.	O
value	double
;	O
break	O
;	O
default	O
:	O
ref	pointer
->	O
absolute_ref	long
=	O
0	int
;	O
ref	pointer
->	O
obj	pointer
=	O
NULL	O
;	O
LOG_WARN	O
(	O
"Invalid handle pointer code %d"	pointer
,	O
ref	pointer
->	O
handleref	struct
.	O
code	char
)	O
;	O
break	O
;	O
}	O
return	O
ref	pointer
;	O
}	O
AFL_GCC_TOOBIG	O
int	O
dwg_decode_header_variables	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Bit_Chain	struct
*	O
str_dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Header_Variables	struct
*	O
_obj	pointer
=	O
&	O
dwg	pointer
->	O
header_vars	struct
;	O
Dwg_Object	struct
*	O
obj	pointer
=	O
NULL	O
;	O
int	O
error	int
=	O
0	int
;	O
return	O
error	int
;	O
}	O
AFL_GCC_POP	O
static	O
int	O
dwg_decode_common_entity_handle_data	function
(	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
Dwg_Object_Entity	struct
*	O
_obj	pointer
,	O
*	O
_ent	pointer
;	O
BITCODE_BL	int
vcount	int
;	O
int	O
error	int
=	O
0	int
;	O
_obj	pointer
=	O
_ent	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2007	int
&&	O
_ent	pointer
->	O
color	short
.	O
flag	short
&	O
0x40	int
)	O
FIELD_HANDLE	O
(	O
color	short
.	O
handle	pointer
,	O
0	int
,	O
430	int
)	O
;	O
return	O
error	int
;	O
}	O
enum	O
RES_BUF_VALUE_TYPE	enum
get_base_value_type	function
(	O
short	O
gc	short
)	O
{	O
if	O
(	O
gc	short
>=	O
300	int
)	O
{	O
if	O
(	O
gc	short
>=	O
440	int
)	O
{	O
if	O
(	O
gc	short
>=	O
1000	int
)	O
{	O
if	O
(	O
gc	short
==	O
1004	int
)	O
return	O
VT_BINARY	int
;	O
if	O
(	O
gc	short
<=	O
1009	int
)	O
return	O
VT_STRING	int
;	O
if	O
(	O
gc	short
<=	O
1059	int
)	O
return	O
VT_REAL	int
;	O
if	O
(	O
gc	short
<=	O
1070	int
)	O
return	O
VT_INT16	int
;	O
if	O
(	O
gc	short
==	O
1071	int
)	O
return	O
VT_INT32	int
;	O
}	O
else	O
{	O
if	O
(	O
gc	short
<=	O
459	int
)	O
return	O
VT_INT32	int
;	O
if	O
(	O
gc	short
<=	O
469	int
)	O
return	O
VT_REAL	int
;	O
if	O
(	O
gc	short
<=	O
479	int
)	O
return	O
VT_STRING	int
;	O
if	O
(	O
gc	short
<=	O
998	int
)	O
return	O
VT_INVALID	int
;	O
if	O
(	O
gc	short
==	O
999	int
)	O
return	O
VT_STRING	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
gc	short
>=	O
390	int
)	O
{	O
if	O
(	O
gc	short
<=	O
399	int
)	O
return	O
VT_HANDLE	int
;	O
if	O
(	O
gc	short
<=	O
409	int
)	O
return	O
VT_INT16	int
;	O
if	O
(	O
gc	short
<=	O
419	int
)	O
return	O
VT_STRING	int
;	O
if	O
(	O
gc	short
<=	O
429	int
)	O
return	O
VT_INT32	int
;	O
if	O
(	O
gc	short
<=	O
439	int
)	O
return	O
VT_STRING	int
;	O
}	O
else	O
{	O
if	O
(	O
gc	short
<=	O
309	int
)	O
return	O
VT_STRING	int
;	O
if	O
(	O
gc	short
<=	O
319	int
)	O
return	O
VT_BINARY	int
;	O
if	O
(	O
gc	short
<=	O
329	int
)	O
return	O
VT_HANDLE	int
;	O
if	O
(	O
gc	short
<=	O
369	int
)	O
return	O
VT_OBJECTID	int
;	O
if	O
(	O
gc	short
<=	O
389	int
)	O
return	O
VT_INT16	int
;	O
}	O
}	O
}	O
else	O
if	O
(	O
gc	short
>=	O
105	int
)	O
{	O
if	O
(	O
gc	short
>=	O
210	int
)	O
{	O
if	O
(	O
gc	short
<=	O
239	int
)	O
return	O
VT_REAL	int
;	O
if	O
(	O
gc	short
<=	O
269	int
)	O
return	O
VT_INVALID	int
;	O
if	O
(	O
gc	short
<=	O
279	int
)	O
return	O
VT_INT16	int
;	O
if	O
(	O
gc	short
<=	O
289	int
)	O
return	O
VT_INT8	int
;	O
if	O
(	O
gc	short
<=	O
299	int
)	O
return	O
VT_BOOL	int
;	O
}	O
else	O
{	O
if	O
(	O
gc	short
==	O
105	int
)	O
return	O
VT_HANDLE	int
;	O
if	O
(	O
gc	short
<=	O
109	int
)	O
return	O
VT_INVALID	int
;	O
if	O
(	O
gc	short
<=	O
149	int
)	O
return	O
VT_REAL	int
;	O
if	O
(	O
gc	short
<=	O
169	int
)	O
return	O
VT_INT64	int
;	O
if	O
(	O
gc	short
<=	O
179	int
)	O
return	O
VT_INT16	int
;	O
if	O
(	O
gc	short
<=	O
209	int
)	O
return	O
VT_INVALID	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
gc	short
>=	O
38	int
)	O
{	O
if	O
(	O
gc	short
<=	O
59	int
)	O
return	O
VT_REAL	int
;	O
if	O
(	O
gc	short
<=	O
79	int
)	O
return	O
VT_INT16	int
;	O
if	O
(	O
gc	short
<=	O
99	int
)	O
return	O
VT_INT32	int
;	O
if	O
(	O
gc	short
<=	O
101	int
)	O
return	O
VT_STRING	int
;	O
if	O
(	O
gc	short
==	O
102	int
)	O
return	O
VT_STRING	int
;	O
}	O
else	O
{	O
if	O
(	O
gc	short
<	O
0	int
)	O
return	O
VT_HANDLE	int
;	O
if	O
(	O
gc	short
<=	O
4	int
)	O
return	O
VT_STRING	int
;	O
if	O
(	O
gc	short
==	O
5	int
)	O
return	O
VT_HANDLE	int
;	O
if	O
(	O
gc	short
<=	O
9	int
)	O
return	O
VT_STRING	int
;	O
if	O
(	O
gc	short
<=	O
37	int
)	O
return	O
VT_POINT3D	int
;	O
}	O
}	O
return	O
VT_INVALID	int
;	O
}	O
void	O
dwg_free_xdata_resbuf	function
(	O
Dwg_Resbuf	struct
*	O
rbuf	pointer
)	O
{	O
while	O
(	O
rbuf	pointer
)	O
{	O
Dwg_Resbuf	struct
*	O
next	pointer
=	O
rbuf	pointer
->	O
next	pointer
;	O
short	O
type	short
=	O
get_base_value_type	function
(	O
rbuf	pointer
->	O
type	short
)	O
;	O
if	O
(	O
type	short
==	O
VT_STRING	int
||	O
type	short
==	O
VT_BINARY	int
)	O
free	function
(	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
)	O
;	O
free	function
(	O
rbuf	pointer
)	O
;	O
rbuf	pointer
=	O
next	pointer
;	O
}	O
}	O
static	O
Dwg_Resbuf	struct
*	O
dwg_decode_xdata	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object_XRECORD	struct
*	O
restrict	O
obj	pointer
,	O
BITCODE_BL	int
num_databytes	int
)	O
{	O
Dwg_Resbuf	struct
*	O
rbuf	pointer
,	O
*	O
root	pointer
=	O
NULL	O
,	O
*	O
curr	pointer
=	O
NULL	O
;	O
unsigned	O
char	O
codepage	int
;	O
long	O
unsigned	O
int	O
start_address	long
,	O
end_address	int
,	O
curr_address	long
;	O
BITCODE_BL	int
i	int
,	O
num_xdata	int
=	O
0	int
;	O
BITCODE_RS	short
length	double
;	O
int	O
error	int
;	O
static	O
int	O
cnt	int
=	O
0	int
;	O
cnt	int
++	O
;	O
start_address	long
=	O
dat	pointer
->	O
byte	char
;	O
end_address	int
=	O
start_address	long
+	O
(	O
unsigned	O
long	O
int	O
)	O
num_databytes	int
;	O
if	O
(	O
obj	pointer
->	O
parent	pointer
&&	O
obj	pointer
->	O
parent	pointer
->	O
objid	int
)	O
{	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
->	O
dwg	pointer
;	O
Dwg_Object	struct
*	O
o	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
obj	pointer
->	O
parent	pointer
->	O
objid	int
]	O
;	O
if	O
(	O
num_databytes	int
>	O
o	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"Invalid XRECORD.num_databytes "	pointer
FORMAT_BL	O
,	O
num_databytes	int
)	O
;	O
obj	pointer
->	O
num_databytes	int
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
}	O
LOG_INSANE	O
(	O
"xdata:\n"	pointer
)	O
;	O
LOG_INSANE_TF	O
(	O
&	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
,	O
(	O
int	O
)	O
num_databytes	int
)	O
;	O
curr_address	long
=	O
dat	pointer
->	O
byte	char
;	O
while	O
(	O
dat	pointer
->	O
byte	char
<	O
end_address	int
)	O
{	O
enum	O
RES_BUF_VALUE_TYPE	enum
vtype	enum
;	O
rbuf	pointer
=	O
(	O
Dwg_Resbuf	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Resbuf	struct
)	O
)	O
;	O
if	O
(	O
!	O
rbuf	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
dwg_free_xdata_resbuf	function
(	O
root	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
rbuf	pointer
->	O
next	pointer
=	O
NULL	O
;	O
rbuf	pointer
->	O
type	short
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
LOG_INSANE	O
(	O
"xdata[%u] type: "	pointer
FORMAT_RS	O
" [RS]\n"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
type	short
)	O
if	O
(	O
dat	pointer
->	O
byte	char
==	O
curr_address	long
||	O
dat	pointer
->	O
byte	char
>=	O
end_address	int
)	O
{	O
free	function
(	O
rbuf	pointer
)	O
;	O
dat	pointer
->	O
byte	char
=	O
end_address	int
;	O
break	O
;	O
}	O
if	O
(	O
rbuf	pointer
->	O
type	short
<	O
0	int
||	O
rbuf	pointer
->	O
type	short
>=	O
2000	int
)	O
{	O
LOG_ERROR	O
(	O
"Invalid xdata type %d [RS]"	pointer
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
free	function
(	O
rbuf	pointer
)	O
;	O
dat	pointer
->	O
byte	char
=	O
end_address	int
;	O
break	O
;	O
}	O
vtype	enum
=	O
get_base_value_type	function
(	O
rbuf	pointer
->	O
type	short
)	O
;	O
switch	O
(	O
vtype	enum
)	O
{	O
case	O
VT_STRING	int
:	O
PRE	O
(	O
R_2007	int
)	O
{	O
length	double
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
LOG_INSANE	O
(	O
"xdata[%u]: length "	pointer
FORMAT_RS	O
"\n"	pointer
,	O
num_xdata	int
,	O
length	double
)	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
codepage	int
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
LOG_INSANE	O
(	O
"xdata[%u]: codepage %d\n"	pointer
,	O
num_xdata	int
,	O
(	O
int	O
)	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
codepage	int
)	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
length	double
>	O
end_address	int
||	O
(	O
short	O
)	O
length	double
<	O
0	int
)	O
break	O
;	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
=	O
length	double
;	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
=	O
bit_read_TF	function
(	O
dat	pointer
,	O
length	double
)	O
;	O
LOG_INSANE	O
(	O
"STRING "	pointer
)	O
LOG_TRACE	O
(	O
"xdata[%u]: \"%s\" [TF %d %d]\n"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
,	O
length	double
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
}	O
LATER_VERSIONS	O
{	O
length	double
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
(	O
short	O
)	O
length	double
>	O
0	int
&&	O
dat	pointer
->	O
byte	char
+	O
(	O
length	double
*	O
2	int
)	O
<=	O
end_address	int
)	O
{	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
wdata	pointer
=	O
calloc	function
(	O
length	double
+	O
1	int
,	O
2	int
)	O
;	O
if	O
(	O
!	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
wdata	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
obj	pointer
->	O
num_databytes	int
=	O
0	int
;	O
obj	pointer
->	O
num_xdata	int
=	O
0	int
;	O
if	O
(	O
root	pointer
)	O
{	O
dwg_free_xdata_resbuf	function
(	O
root	pointer
)	O
;	O
if	O
(	O
rbuf	pointer
)	O
free	function
(	O
rbuf	pointer
)	O
;	O
}	O
else	O
dwg_free_xdata_resbuf	function
(	O
rbuf	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
=	O
length	double
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
length	double
;	O
i	int
++	O
)	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
wdata	pointer
[	O
i	int
]	O
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
wdata	pointer
[	O
i	int
]	O
=	O
'\0'	O
;	O
LOG_INSANE	O
(	O
"UNISTRING "	pointer
)	O
LOG_TRACE_TU	O
(	O
"xdata"	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
wdata	pointer
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
}	O
else	O
{	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
=	O
0	int
;	O
}	O
}	O
break	O
;	O
case	O
VT_REAL	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
8	int
>	O
end_address	int
)	O
break	O
;	O
rbuf	pointer
->	O
value	double
.	O
dbl	double
=	O
bit_read_RD	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: %f [RD %d]\n"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
value	double
.	O
dbl	double
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_BOOL	int
:	O
case	O
VT_INT8	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
1	int
>	O
end_address	int
)	O
break	O
;	O
rbuf	pointer
->	O
value	double
.	O
i8	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: %d [RC %d]\n"	pointer
,	O
num_xdata	int
,	O
(	O
int	O
)	O
rbuf	pointer
->	O
value	double
.	O
i8	char
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_INT16	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
2	int
>	O
end_address	int
)	O
break	O
;	O
rbuf	pointer
->	O
value	double
.	O
i16	short
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: %d [RS %d]\n"	pointer
,	O
num_xdata	int
,	O
(	O
int	O
)	O
rbuf	pointer
->	O
value	double
.	O
i16	short
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_INT32	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
4	int
>	O
end_address	int
)	O
break	O
;	O
rbuf	pointer
->	O
value	double
.	O
i32	int
=	O
bit_read_RL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: %d [RL %d]\n"	pointer
,	O
num_xdata	int
,	O
(	O
int	O
)	O
rbuf	pointer
->	O
value	double
.	O
i32	int
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_INT64	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
8	int
>	O
end_address	int
)	O
break	O
;	O
rbuf	pointer
->	O
value	double
.	O
i64	long
=	O
bit_read_BLL	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: "	pointer
FORMAT_BLL	O
" [BLL %d]\n"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
value	double
.	O
i64	long
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_POINT3D	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
24	int
>	O
end_address	int
)	O
break	O
;	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
0	int
]	O
=	O
bit_read_RD	function
(	O
dat	pointer
)	O
;	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
1	int
]	O
=	O
bit_read_RD	function
(	O
dat	pointer
)	O
;	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
2	int
]	O
=	O
bit_read_RD	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: %f,%f,%f [3RD %d]\n"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
0	int
]	O
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
1	int
]	O
,	O
rbuf	pointer
->	O
value	double
.	O
pt	array
[	O
2	int
]	O
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_BINARY	int
:	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
=	O
bit_read_RC	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
>	O
end_address	int
)	O
{	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
=	O
0	int
;	O
break	O
;	O
}	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
=	O
bit_read_TF	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
)	O
;	O
LOG_INSANE	O
(	O
"BINARY "	pointer
)	O
LOG_TRACE	O
(	O
"xdata[%u]: [TF %d %d] "	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
LOG_TRACE_TF	O
(	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
u	union
.	O
data	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
str	struct
.	O
size	char
)	O
;	O
break	O
;	O
case	O
VT_HANDLE	int
:	O
case	O
VT_OBJECTID	int
:	O
if	O
(	O
dat	pointer
->	O
byte	char
+	O
8	int
>	O
end_address	int
)	O
break	O
;	O
bit_read_fixed	function
(	O
dat	pointer
,	O
rbuf	pointer
->	O
value	double
.	O
hdl	array
,	O
8	int
)	O
;	O
LOG_TRACE	O
(	O
"xdata[%u]: "	pointer
FORMAT_H	pointer
" [H %d]\n"	pointer
,	O
num_xdata	int
,	O
ARGS_H	O
(	O
rbuf	pointer
->	O
value	double
.	O
h	struct
)	O
,	O
rbuf	pointer
->	O
type	short
)	O
;	O
break	O
;	O
case	O
VT_INVALID	int
:	O
default	O
:	O
LOG_ERROR	O
(	O
"Invalid group code in xdata[%u]: %d"	pointer
,	O
num_xdata	int
,	O
rbuf	pointer
->	O
type	short
)	O
LOG_WARN	O
(	O
"xdata Read %lu, expected %d"	pointer
,	O
dat	pointer
->	O
byte	char
-	O
start_address	long
,	O
obj	pointer
->	O
num_databytes	int
)	O
;	O
dwg_free_xdata_resbuf	function
(	O
rbuf	pointer
)	O
;	O
if	O
(	O
curr	pointer
)	O
curr	pointer
->	O
next	pointer
=	O
NULL	O
;	O
dat	pointer
->	O
byte	char
=	O
end_address	int
;	O
obj	pointer
->	O
num_xdata	int
=	O
num_xdata	int
;	O
return	O
root	pointer
;	O
}	O
num_xdata	int
++	O
;	O
if	O
(	O
!	O
curr	pointer
)	O
{	O
curr	pointer
=	O
root	pointer
=	O
rbuf	pointer
;	O
}	O
else	O
{	O
curr	pointer
->	O
next	pointer
=	O
rbuf	pointer
;	O
curr	pointer
=	O
rbuf	pointer
;	O
}	O
curr_address	long
=	O
dat	pointer
->	O
byte	char
;	O
}	O
if	O
(	O
curr_address	long
<	O
end_address	int
)	O
LOG_WARN	O
(	O
"xdata Read %lu, expected %d"	pointer
,	O
dat	pointer
->	O
byte	char
-	O
start_address	long
,	O
obj	pointer
->	O
num_databytes	int
)	O
;	O
obj	pointer
->	O
num_xdata	int
=	O
num_xdata	int
;	O
return	O
root	pointer
;	O
}	O
static	O
void	O
check_POLYLINE_handles	function
(	O
Dwg_Object	struct
*	O
obj	pointer
)	O
{	O
Dwg_Entity_POLYLINE_2D	struct
*	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
POLYLINE_2D	pointer
;	O
Dwg_Data	struct
*	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2004	int
)	O
{	O
BITCODE_BL	int
i	int
=	O
0	int
;	O
Dwg_Object_Ref	struct
*	O
layer	int
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
layer	int
;	O
Dwg_Object_Ref	struct
*	O
seqend	pointer
=	O
_obj	pointer
->	O
seqend	pointer
;	O
if	O
(	O
layer	int
&&	O
!	O
layer	int
->	O
obj	pointer
)	O
layer	int
->	O
obj	pointer
=	O
dwg_ref_object_relative	function
(	O
dwg	pointer
,	O
layer	int
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
layer	int
||	O
!	O
layer	int
->	O
obj	pointer
)	O
{	O
LOG_WARN	O
(	O
"Wrong POLYLINE.layer %lX"	pointer
,	O
layer	int
?	O
layer	int
->	O
handleref	struct
.	O
value	double
:	O
0L	int
)	O
;	O
if	O
(	O
_obj	pointer
->	O
num_owned	int
>	O
0	int
&&	O
_obj	pointer
->	O
vertex	pointer
)	O
{	O
Dwg_Object_Ref	struct
*	O
vertex	pointer
=	O
_obj	pointer
->	O
vertex	pointer
[	O
0	int
]	O
;	O
if	O
(	O
vertex	pointer
&&	O
!	O
vertex	pointer
->	O
obj	pointer
)	O
vertex	pointer
->	O
obj	pointer
=	O
dwg_ref_object_relative	function
(	O
dwg	pointer
,	O
vertex	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
vertex	pointer
&&	O
vertex	pointer
->	O
obj	pointer
&&	O
vertex	pointer
->	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_LAYER	int
)	O
{	O
Dwg_Object	struct
*	O
seq	pointer
;	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
layer	int
=	O
layer	int
=	O
vertex	pointer
;	O
LOG_WARN	O
(	O
"POLYLINE.layer is vertex[0] %lX, shift em, NULL seqend"	pointer
,	O
layer	int
->	O
handleref	struct
.	O
value	double
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_obj	pointer
->	O
num_owned	int
-	O
1	int
;	O
i	int
++	O
)	O
{	O
_obj	pointer
->	O
vertex	pointer
[	O
i	int
]	O
=	O
_obj	pointer
->	O
vertex	pointer
[	O
i	int
+	O
1	int
]	O
;	O
}	O
_obj	pointer
->	O
vertex	pointer
[	O
_obj	pointer
->	O
num_owned	int
-	O
1	int
]	O
=	O
seqend	pointer
;	O
_obj	pointer
->	O
seqend	pointer
=	O
NULL	O
;	O
seq	pointer
=	O
dwg_next_object	function
(	O
obj	pointer
)	O
;	O
if	O
(	O
seq	pointer
&&	O
seq	pointer
->	O
type	short
==	O
DWG_TYPE_SEQEND	int
)	O
{	O
LOG_WARN	O
(	O
"POLYLINE.seqend = POLYLINE+1 %lX"	pointer
,	O
seq	pointer
->	O
handle	pointer
.	O
value	double
)	O
;	O
seqend	pointer
=	O
_obj	pointer
->	O
seqend	pointer
=	O
dwg_find_objectref	function
(	O
dwg	pointer
,	O
seq	pointer
)	O
;	O
}	O
else	O
{	O
seq	pointer
=	O
dwg_next_object	function
(	O
seqend	pointer
->	O
obj	pointer
)	O
;	O
if	O
(	O
seq	pointer
&&	O
seq	pointer
->	O
type	short
==	O
DWG_TYPE_SEQEND	int
)	O
{	O
LOG_WARN	O
(	O
"POLYLINE.seqend = VERTEX+1 %lX"	pointer
,	O
seq	pointer
->	O
handle	pointer
.	O
value	double
)	O
;	O
seqend	pointer
=	O
_obj	pointer
->	O
seqend	pointer
=	O
dwg_find_objectref	function
(	O
dwg	pointer
,	O
seq	pointer
)	O
;	O
}	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
layer	int
->	O
obj	pointer
->	O
fixedtype	enum
!=	O
DWG_TYPE_LAYER	int
&&	O
layer	int
->	O
obj	pointer
->	O
fixedtype	enum
!=	O
DWG_TYPE_DICTIONARY	int
)	O
{	O
LOG_WARN	O
(	O
"Wrong POLYLINE.layer %s"	pointer
,	O
layer	int
->	O
obj	pointer
->	O
dxfname	pointer
)	O
}	O
if	O
(	O
!	O
seqend	pointer
||	O
!	O
seqend	pointer
->	O
handleref	struct
.	O
value	double
)	O
{	O
LOG_WARN	O
(	O
"Empty POLYLINE.seqend"	pointer
)	O
}	O
else	O
if	O
(	O
seqend	pointer
->	O
obj	pointer
&&	O
seqend	pointer
->	O
obj	pointer
->	O
fixedtype	enum
!=	O
DWG_TYPE_SEQEND	int
)	O
{	O
LOG_WARN	O
(	O
"Wrong POLYLINE.seqend %s"	pointer
,	O
seqend	pointer
->	O
obj	pointer
->	O
dxfname	pointer
)	O
}	O
if	O
(	O
!	O
_obj	pointer
->	O
vertex	pointer
)	O
return	O
;	O
for	O
(	O
;	O
i	int
<	O
_obj	pointer
->	O
num_owned	int
;	O
i	int
++	O
)	O
{	O
Dwg_Object_Ref	struct
*	O
v	pointer
=	O
_obj	pointer
->	O
vertex	pointer
[	O
i	int
]	O
;	O
if	O
(	O
!	O
v	pointer
||	O
!	O
v	pointer
->	O
handleref	struct
.	O
value	double
)	O
{	O
LOG_WARN	O
(	O
"Empty POLYLINE.vertex[%d]"	pointer
,	O
i	int
)	O
;	O
}	O
else	O
if	O
(	O
v	pointer
->	O
obj	pointer
&&	O
v	pointer
->	O
obj	pointer
->	O
fixedtype	enum
!=	O
DWG_TYPE_VERTEX_2D	int
&&	O
v	pointer
->	O
obj	pointer
->	O
fixedtype	enum
!=	O
DWG_TYPE_VERTEX_3D	int
&&	O
v	pointer
->	O
obj	pointer
->	O
fixedtype	enum
!=	O
DWG_TYPE_VERTEX_MESH	int
&&	O
v	pointer
->	O
obj	pointer
->	O
fixedtype	enum
!=	O
DWG_TYPE_VERTEX_PFACE	int
&&	O
v	pointer
->	O
obj	pointer
->	O
fixedtype	enum
!=	O
DWG_TYPE_VERTEX_PFACE_FACE	int
)	O
{	O
LOG_WARN	O
(	O
"Wrong POLYLINE.vertex[%d] %lX %s"	pointer
,	O
i	int
,	O
v	pointer
->	O
handleref	struct
.	O
value	double
,	O
v	pointer
->	O
obj	pointer
->	O
dxfname	pointer
)	O
}	O
}	O
}	O
}	O
static	O
int	O
decode_preR13_entities	function
(	O
unsigned	O
long	O
start	struct
,	O
unsigned	O
long	O
end	struct
,	O
unsigned	O
long	O
offset	double
,	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
int	O
error	int
=	O
0	int
;	O
BITCODE_BL	int
num	long
=	O
dwg	pointer
->	O
num_objects	int
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
LOG_TRACE	O
(	O
"entities: (0x%lx-0x%lx, offset 0x%lx) TODO\n"	pointer
,	O
start	struct
,	O
end	struct
,	O
offset	double
)	O
while	O
(	O
dat	pointer
->	O
byte	char
<	O
end	struct
)	O
{	O
Dwg_Object	struct
*	O
obj	pointer
;	O
Dwg_Object_Entity	struct
*	O
ent	pointer
;	O
BITCODE_RS	short
crc	int
;	O
if	O
(	O
!	O
num	long
)	O
dwg	pointer
->	O
object	pointer
=	O
(	O
Dwg_Object	struct
*	O
)	O
malloc	function
(	O
REFS_PER_REALLOC	int
*	O
sizeof	O
(	O
Dwg_Object	struct
)	O
)	O
;	O
else	O
if	O
(	O
num	long
%	O
REFS_PER_REALLOC	int
==	O
0	int
)	O
dwg	pointer
->	O
object	pointer
=	O
realloc	function
(	O
dwg	pointer
->	O
object	pointer
,	O
(	O
num	long
+	O
REFS_PER_REALLOC	int
)	O
*	O
sizeof	O
(	O
Dwg_Object	struct
)	O
)	O
;	O
if	O
(	O
!	O
dwg	pointer
->	O
object	pointer
)	O
{	O
LOG_ERROR	O
(	O
"Out of memory"	pointer
)	O
;	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
}	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
num	long
]	O
;	O
memset	function
(	O
obj	pointer
,	O
0	int
,	O
sizeof	O
(	O
Dwg_Object	struct
)	O
)	O
;	O
dwg	pointer
->	O
num_objects	int
++	O
;	O
obj	pointer
->	O
index	short
=	O
num	long
;	O
obj	pointer
->	O
parent	pointer
=	O
dwg	pointer
;	O
obj	pointer
->	O
address	long
=	O
dat	pointer
->	O
byte	char
;	O
DEBUG_HERE	O
;	O
switch	O
(	O
obj	pointer
->	O
type	short
)	O
{	O
case	O
1	int
:	O
error	int
|=	O
dwg_decode_LINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
2	int
:	O
error	int
|=	O
dwg_decode_POINT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
3	int
:	O
error	int
|=	O
dwg_decode_CIRCLE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
4	int
:	O
error	int
|=	O
dwg_decode_SHAPE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
7	int
:	O
error	int
|=	O
dwg_decode_TEXT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
8	int
:	O
error	int
|=	O
dwg_decode_ARC	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
9	int
:	O
error	int
|=	O
dwg_decode_TRACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
11	int
:	O
error	int
|=	O
dwg_decode_SOLID	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
12	int
:	O
error	int
|=	O
dwg_decode_BLOCK	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
13	int
:	O
error	int
|=	O
dwg_decode_ENDBLK	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
14	int
:	O
error	int
|=	O
dwg_decode_INSERT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
15	int
:	O
error	int
|=	O
dwg_decode_ATTDEF	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
16	int
:	O
error	int
|=	O
dwg_decode_ATTRIB	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
17	int
:	O
error	int
|=	O
dwg_decode_SEQEND	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
19	int
:	O
error	int
|=	O
dwg_decode_POLYLINE_2D	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
20	int
:	O
error	int
|=	O
dwg_decode_VERTEX_2D	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
22	int
:	O
error	int
|=	O
dwg_decode__3DFACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
23	int
:	O
error	int
|=	O
dwg_decode_DIMENSION_LINEAR	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
24	int
:	O
error	int
|=	O
dwg_decode_VPORT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
default	O
:	O
LOG_ERROR	O
(	O
"Unknown object type %d"	pointer
,	O
obj	pointer
->	O
type	short
)	O
break	O
;	O
}	O
bit_set_position	function
(	O
dat	pointer
,	O
obj	pointer
->	O
address	long
+	O
obj	pointer
->	O
size	char
-	O
2	int
)	O
;	O
crc	int
=	O
bit_read_RS	function
(	O
dat	pointer
)	O
;	O
LOG_TRACE	O
(	O
"crc: %04X [RSx]\n"	pointer
,	O
crc	int
)	O
;	O
num	long
++	O
;	O
if	O
(	O
obj	pointer
->	O
size	char
<	O
2	int
||	O
obj	pointer
->	O
size	char
>	O
0x1000	int
)	O
dat	pointer
->	O
byte	char
=	O
end	struct
;	O
}	O
dat	pointer
->	O
byte	char
=	O
end	struct
;	O
return	O
error	int
;	O
}	O
static	O
int	O
dwg_decode_variable_type	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
Dwg_Class	struct
*	O
klass	pointer
;	O
int	O
i	int
;	O
int	O
is_entity	int
;	O
i	int
=	O
obj	pointer
->	O
type	short
-	O
500	int
;	O
if	O
(	O
i	int
<	O
0	int
||	O
i	int
>=	O
dwg	pointer
->	O
num_classes	short
)	O
{	O
LOG_ERROR	O
(	O
"Invalid object type %d, only %u classes"	pointer
,	O
obj	pointer
->	O
type	short
,	O
dwg	pointer
->	O
num_classes	short
)	O
;	O
return	O
DWG_ERR_INVALIDTYPE	int
;	O
}	O
klass	pointer
=	O
&	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
;	O
if	O
(	O
!	O
klass	pointer
||	O
!	O
klass	pointer
->	O
dxfname	pointer
)	O
return	O
DWG_ERR_INTERNALERROR	int
;	O
obj	pointer
->	O
dxfname	pointer
=	O
klass	pointer
->	O
dxfname	pointer
;	O
is_entity	int
=	O
dwg_class_is_entity	function
(	O
klass	pointer
)	O
;	O
LOG_WARN	O
(	O
"Unknown Class %s %d %s (0x%x%s)"	pointer
,	O
is_entity	int
?	O
"entity"	pointer
:	O
"object"	pointer
,	O
klass	pointer
->	O
number	short
,	O
klass	pointer
->	O
dxfname	pointer
,	O
klass	pointer
->	O
proxyflag	short
,	O
klass	pointer
->	O
is_zombie	char
?	O
"is_zombie"	pointer
:	O
""	pointer
)	O
return	O
DWG_ERR_UNHANDLEDCLASS	int
;	O
}	O
EXPORT	O
int	O
dwg_add_object	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
)	O
{	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
;	O
BITCODE_BL	int
num	long
=	O
dwg	pointer
->	O
num_objects	int
;	O
int	O
realloced	int
=	O
0	int
;	O
if	O
(	O
!	O
num	long
)	O
dwg	pointer
->	O
object	pointer
=	O
calloc	function
(	O
REFS_PER_REALLOC	int
,	O
sizeof	O
(	O
Dwg_Object	struct
)	O
)	O
;	O
else	O
if	O
(	O
num	long
%	O
REFS_PER_REALLOC	int
==	O
0	int
)	O
{	O
Dwg_Object	struct
*	O
restrict	O
old	pointer
=	O
dwg	pointer
->	O
object	pointer
;	O
dwg	pointer
->	O
object	pointer
=	O
realloc	function
(	O
dwg	pointer
->	O
object	pointer
,	O
(	O
num	long
+	O
REFS_PER_REALLOC	int
)	O
*	O
sizeof	O
(	O
Dwg_Object	struct
)	O
)	O
;	O
realloced	int
=	O
old	pointer
!=	O
dwg	pointer
->	O
object	pointer
;	O
}	O
if	O
(	O
!	O
dwg	pointer
->	O
object	pointer
)	O
return	O
DWG_ERR_OUTOFMEM	int
;	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
num	long
]	O
;	O
memset	function
(	O
obj	pointer
,	O
0	int
,	O
sizeof	O
(	O
Dwg_Object	struct
)	O
)	O
;	O
obj	pointer
->	O
index	short
=	O
num	long
;	O
dwg	pointer
->	O
num_objects	int
++	O
;	O
obj	pointer
->	O
parent	pointer
=	O
dwg	pointer
;	O
return	O
realloced	int
?	O
-	O
1	int
:	O
0	int
;	O
}	O
int	O
dwg_decode_add_object	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Bit_Chain	struct
*	O
dat	pointer
,	O
Bit_Chain	struct
*	O
hdl_dat	pointer
,	O
long	O
unsigned	O
int	O
address	long
)	O
{	O
long	O
unsigned	O
int	O
objpos	long
,	O
restartpos	long
;	O
Bit_Chain	struct
abs_dat	struct
=	O
{	O
NULL	O
}	O
;	O
unsigned	O
char	O
previous_bit	char
;	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
;	O
BITCODE_BL	int
num	long
=	O
dwg	pointer
->	O
num_objects	int
;	O
int	O
error	int
=	O
0	int
;	O
int	O
realloced	int
=	O
0	int
;	O
abs_dat	struct
=	O
*	O
dat	pointer
;	O
dat	pointer
->	O
byte	char
=	O
address	long
;	O
dat	pointer
->	O
bit	char
=	O
0	int
;	O
realloced	int
=	O
dwg_add_object	function
(	O
dwg	pointer
)	O
;	O
if	O
(	O
realloced	int
>	O
0	int
)	O
{	O
*	O
dat	pointer
=	O
abs_dat	struct
;	O
return	O
realloced	int
;	O
}	O
obj	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
num	long
]	O
;	O
LOG_INFO	O
(	O
"==========================================\n"	pointer
"Object number: %lu/%lX"	pointer
,	O
(	O
unsigned	O
long	O
)	O
num	long
,	O
(	O
unsigned	O
long	O
)	O
num	long
)	O
obj	pointer
->	O
size	char
=	O
bit_read_MS	function
(	O
dat	pointer
)	O
;	O
LOG_INFO	O
(	O
", Size: %d [MS]"	pointer
,	O
obj	pointer
->	O
size	char
)	O
SINCE	O
(	O
R_2010	int
)	O
{	O
obj	pointer
->	O
handlestream_size	long
=	O
bit_read_UMC	function
(	O
dat	pointer
)	O
;	O
LOG_INFO	O
(	O
", Hdlsize: "	pointer
FORMAT_UMC	pointer
" [UMC] "	pointer
,	O
obj	pointer
->	O
handlestream_size	long
)	O
;	O
obj	pointer
->	O
bitsize	int
=	O
obj	pointer
->	O
size	char
*	O
8	int
-	O
obj	pointer
->	O
handlestream_size	long
;	O
}	O
objpos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
obj	pointer
->	O
address	long
=	O
dat	pointer
->	O
byte	char
;	O
bit_reset_chain	function
(	O
dat	pointer
)	O
;	O
if	O
(	O
obj	pointer
->	O
size	char
>	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"\nInvalid object size. Would overflow"	pointer
)	O
;	O
*	O
dat	pointer
=	O
abs_dat	struct
;	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
dat	pointer
->	O
size	char
=	O
obj	pointer
->	O
size	char
;	O
SINCE	O
(	O
R_2010	int
)	O
{	O
obj	pointer
->	O
type	short
=	O
bit_read_BOT	function
(	O
dat	pointer
)	O
;	O
}	O
else	O
{	O
obj	pointer
->	O
type	short
=	O
bit_read_BS	function
(	O
dat	pointer
)	O
;	O
}	O
LOG_INFO	O
(	O
", Type: %d [%s]\n"	pointer
,	O
obj	pointer
->	O
type	short
,	O
dat	pointer
->	O
version	short
>=	O
R_2010	int
?	O
"BOT"	pointer
:	O
"BS"	pointer
)	O
;	O
restartpos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
switch	O
(	O
obj	pointer
->	O
type	short
)	O
{	O
case	O
DWG_TYPE_TEXT	int
:	O
error	int
=	O
dwg_decode_TEXT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_ATTRIB	int
:	O
error	int
=	O
dwg_decode_ATTRIB	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_ATTDEF	int
:	O
error	int
=	O
dwg_decode_ATTDEF	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_BLOCK	int
:	O
error	int
=	O
dwg_decode_BLOCK	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_ENDBLK	int
:	O
error	int
=	O
dwg_decode_ENDBLK	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_SEQEND	int
:	O
error	int
=	O
dwg_decode_SEQEND	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_13	int
&&	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
)	O
{	O
Dwg_Object	struct
*	O
restrict	O
owner	pointer
=	O
dwg_resolve_handle	function
(	O
dwg	pointer
,	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
ownerhandle	pointer
->	O
absolute_ref	long
)	O
;	O
if	O
(	O
!	O
owner	pointer
)	O
{	O
LOG_WARN	O
(	O
"no SEQEND.ownerhandle"	pointer
)	O
}	O
else	O
if	O
(	O
owner	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_INSERT	int
||	O
owner	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_MINSERT	int
)	O
{	O
hash_set	function
(	O
dwg	pointer
->	O
object_map	pointer
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
(	O
uint32_t	int
)	O
num	long
)	O
;	O
(	O
void	O
)	O
dwg_validate_INSERT	function
(	O
owner	pointer
)	O
;	O
}	O
else	O
if	O
(	O
owner	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_POLYLINE_2D	int
||	O
owner	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_POLYLINE_3D	int
||	O
owner	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_POLYLINE_PFACE	int
||	O
owner	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_POLYLINE_MESH	int
)	O
{	O
Dwg_Entity_POLYLINE_2D	struct
*	O
restrict	O
_obj	pointer
=	O
owner	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
POLYLINE_2D	pointer
;	O
if	O
(	O
!	O
_obj	pointer
->	O
seqend	pointer
)	O
hash_set	function
(	O
dwg	pointer
->	O
object_map	pointer
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
(	O
uint32_t	int
)	O
num	long
)	O
;	O
(	O
void	O
)	O
dwg_validate_POLYLINE	function
(	O
owner	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DWG_TYPE_INSERT	int
:	O
error	int
=	O
dwg_decode_INSERT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_MINSERT	int
:	O
error	int
=	O
dwg_decode_MINSERT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VERTEX_2D	int
:	O
error	int
=	O
dwg_decode_VERTEX_2D	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VERTEX_3D	int
:	O
error	int
=	O
dwg_decode_VERTEX_3D	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VERTEX_MESH	int
:	O
error	int
=	O
dwg_decode_VERTEX_MESH	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VERTEX_PFACE	int
:	O
error	int
=	O
dwg_decode_VERTEX_PFACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VERTEX_PFACE_FACE	int
:	O
error	int
=	O
dwg_decode_VERTEX_PFACE_FACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_2D	int
:	O
error	int
=	O
dwg_decode_POLYLINE_2D	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2010	int
)	O
check_POLYLINE_handles	function
(	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_3D	int
:	O
error	int
=	O
dwg_decode_POLYLINE_3D	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2010	int
)	O
check_POLYLINE_handles	function
(	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_ARC	int
:	O
error	int
=	O
dwg_decode_ARC	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_CIRCLE	int
:	O
error	int
=	O
dwg_decode_CIRCLE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LINE	int
:	O
error	int
=	O
dwg_decode_LINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_ORDINATE	int
:	O
error	int
=	O
dwg_decode_DIMENSION_ORDINATE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_LINEAR	int
:	O
error	int
=	O
dwg_decode_DIMENSION_LINEAR	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_ALIGNED	int
:	O
error	int
=	O
dwg_decode_DIMENSION_ALIGNED	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_ANG3PT	int
:	O
error	int
=	O
dwg_decode_DIMENSION_ANG3PT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_ANG2LN	int
:	O
error	int
=	O
dwg_decode_DIMENSION_ANG2LN	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_RADIUS	int
:	O
error	int
=	O
dwg_decode_DIMENSION_RADIUS	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMENSION_DIAMETER	int
:	O
error	int
=	O
dwg_decode_DIMENSION_DIAMETER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_POINT	int
:	O
error	int
=	O
dwg_decode_POINT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE__3DFACE	int
:	O
error	int
=	O
dwg_decode__3DFACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_PFACE	int
:	O
error	int
=	O
dwg_decode_POLYLINE_PFACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2010	int
)	O
check_POLYLINE_handles	function
(	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_POLYLINE_MESH	int
:	O
error	int
=	O
dwg_decode_POLYLINE_MESH	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
dat	pointer
->	O
version	short
>=	O
R_2010	int
)	O
check_POLYLINE_handles	function
(	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_SOLID	int
:	O
error	int
=	O
dwg_decode_SOLID	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_TRACE	int
:	O
error	int
=	O
dwg_decode_TRACE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_SHAPE	int
:	O
error	int
=	O
dwg_decode_SHAPE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VIEWPORT	int
:	O
error	int
=	O
dwg_decode_VIEWPORT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_ELLIPSE	int
:	O
error	int
=	O
dwg_decode_ELLIPSE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_SPLINE	int
:	O
error	int
=	O
dwg_decode_SPLINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_REGION	int
:	O
error	int
=	O
dwg_decode_REGION	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE__3DSOLID	int
:	O
error	int
=	O
dwg_decode__3DSOLID	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_BODY	int
:	O
error	int
=	O
dwg_decode_BODY	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_RAY	int
:	O
error	int
=	O
dwg_decode_RAY	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_XLINE	int
:	O
error	int
=	O
dwg_decode_XLINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DICTIONARY	int
:	O
error	int
=	O
dwg_decode_DICTIONARY	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_MTEXT	int
:	O
error	int
=	O
dwg_decode_MTEXT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LEADER	int
:	O
error	int
=	O
dwg_decode_LEADER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_TOLERANCE	int
:	O
error	int
=	O
dwg_decode_TOLERANCE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_MLINE	int
:	O
error	int
=	O
dwg_decode_MLINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_BLOCK_CONTROL	int
:	O
error	int
=	O
dwg_decode_BLOCK_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_CONTROL	pointer
)	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_CONTROL	pointer
->	O
objid	int
=	O
num	long
;	O
if	O
(	O
!	O
dwg	pointer
->	O
block_control	struct
.	O
parent	pointer
)	O
dwg	pointer
->	O
block_control	struct
=	O
*	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
BLOCK_CONTROL	pointer
;	O
else	O
LOG_WARN	O
(	O
"Second BLOCK_CONTROL object ignored"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_BLOCK_HEADER	int
:	O
error	int
=	O
dwg_decode_BLOCK_HEADER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LAYER_CONTROL	int
:	O
error	int
=	O
dwg_decode_LAYER_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYER_CONTROL	pointer
)	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYER_CONTROL	pointer
->	O
objid	int
=	O
num	long
;	O
dwg	pointer
->	O
layer_control	struct
=	O
*	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LAYER_CONTROL	pointer
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_LAYER	int
:	O
error	int
=	O
dwg_decode_LAYER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_STYLE_CONTROL	int
:	O
error	int
=	O
dwg_decode_STYLE_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
STYLE_CONTROL	pointer
)	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
STYLE_CONTROL	pointer
->	O
objid	int
=	O
num	long
;	O
dwg	pointer
->	O
style_control	struct
=	O
*	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
STYLE_CONTROL	pointer
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_STYLE	int
:	O
error	int
=	O
dwg_decode_STYLE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LTYPE_CONTROL	int
:	O
error	int
=	O
dwg_decode_LTYPE_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LTYPE_CONTROL	pointer
)	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LTYPE_CONTROL	pointer
->	O
objid	int
=	O
num	long
;	O
dwg	pointer
->	O
ltype_control	struct
=	O
*	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
LTYPE_CONTROL	pointer
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_LTYPE	int
:	O
error	int
=	O
dwg_decode_LTYPE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VIEW_CONTROL	int
:	O
error	int
=	O
dwg_decode_VIEW_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VIEW_CONTROL	pointer
)	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VIEW_CONTROL	pointer
->	O
objid	int
=	O
num	long
;	O
dwg	pointer
->	O
view_control	struct
=	O
*	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VIEW_CONTROL	pointer
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_VIEW	int
:	O
error	int
=	O
dwg_decode_VIEW	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_UCS_CONTROL	int
:	O
error	int
=	O
dwg_decode_UCS_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
UCS_CONTROL	pointer
)	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
UCS_CONTROL	pointer
->	O
objid	int
=	O
num	long
;	O
dwg	pointer
->	O
ucs_control	struct
=	O
*	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
UCS_CONTROL	pointer
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_UCS	int
:	O
error	int
=	O
dwg_decode_UCS	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VPORT_CONTROL	int
:	O
error	int
=	O
dwg_decode_VPORT_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VPORT_CONTROL	pointer
)	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VPORT_CONTROL	pointer
->	O
objid	int
=	O
num	long
;	O
dwg	pointer
->	O
vport_control	struct
=	O
*	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VPORT_CONTROL	pointer
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_VPORT	int
:	O
error	int
=	O
dwg_decode_VPORT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_APPID_CONTROL	int
:	O
error	int
=	O
dwg_decode_APPID_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
APPID_CONTROL	pointer
)	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
APPID_CONTROL	pointer
->	O
objid	int
=	O
num	long
;	O
dwg	pointer
->	O
appid_control	struct
=	O
*	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
APPID_CONTROL	pointer
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_APPID	int
:	O
error	int
=	O
dwg_decode_APPID	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DIMSTYLE_CONTROL	int
:	O
error	int
=	O
dwg_decode_DIMSTYLE_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DIMSTYLE_CONTROL	pointer
)	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DIMSTYLE_CONTROL	pointer
->	O
objid	int
=	O
num	long
;	O
dwg	pointer
->	O
dimstyle_control	struct
=	O
*	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
DIMSTYLE_CONTROL	pointer
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_DIMSTYLE	int
:	O
error	int
=	O
dwg_decode_DIMSTYLE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VPORT_ENTITY_CONTROL	int
:	O
error	int
=	O
dwg_decode_VPORT_ENTITY_CONTROL	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
error	int
&&	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VPORT_ENTITY_CONTROL	pointer
)	O
{	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VPORT_ENTITY_CONTROL	pointer
->	O
objid	int
=	O
num	long
;	O
dwg	pointer
->	O
vport_entity_control	struct
=	O
*	O
obj	pointer
->	O
tio	union
.	O
object	pointer
->	O
tio	union
.	O
VPORT_ENTITY_CONTROL	pointer
;	O
}	O
break	O
;	O
case	O
DWG_TYPE_VPORT_ENTITY_HEADER	int
:	O
error	int
=	O
dwg_decode_VPORT_ENTITY_HEADER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_GROUP	int
:	O
error	int
=	O
dwg_decode_GROUP	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_MLINESTYLE	int
:	O
error	int
=	O
dwg_decode_MLINESTYLE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_OLE2FRAME	int
:	O
error	int
=	O
dwg_decode_OLE2FRAME	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_DUMMY	int
:	O
error	int
=	O
dwg_decode_DUMMY	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LONG_TRANSACTION	int
:	O
error	int
=	O
dwg_decode_LONG_TRANSACTION	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_LWPOLYLINE	int
:	O
error	int
=	O
dwg_decode_LWPOLYLINE	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_HATCH	int
:	O
error	int
=	O
dwg_decode_HATCH	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_XRECORD	int
:	O
error	int
=	O
dwg_decode_XRECORD	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_PLACEHOLDER	int
:	O
error	int
=	O
dwg_decode_PLACEHOLDER	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_OLEFRAME	int
:	O
error	int
=	O
dwg_decode_OLEFRAME	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_VBA_PROJECT	int
:	O
LOG_ERROR	O
(	O
"Unhandled Object VBA_PROJECT. Has its own section"	pointer
)	O
;	O
error	int
=	O
DWG_ERR_UNHANDLEDCLASS	int
;	O
break	O
;	O
case	O
DWG_TYPE_LAYOUT	int
:	O
error	int
=	O
dwg_decode_LAYOUT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_PROXY_ENTITY	int
:	O
error	int
=	O
dwg_decode_PROXY_ENTITY	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
case	O
DWG_TYPE_PROXY_OBJECT	int
:	O
error	int
=	O
dwg_decode_PROXY_OBJECT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
obj	pointer
->	O
type	short
==	O
dwg	pointer
->	O
layout_type	int
)	O
error	int
=	O
dwg_decode_LAYOUT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
else	O
if	O
(	O
(	O
error	int
=	O
dwg_decode_variable_type	function
(	O
dwg	pointer
,	O
dat	pointer
,	O
hdl_dat	pointer
,	O
obj	pointer
)	O
)	O
&	O
DWG_ERR_UNHANDLEDCLASS	int
)	O
{	O
int	O
is_entity	int
=	O
0	int
;	O
int	O
i	int
=	O
obj	pointer
->	O
type	short
-	O
500	int
;	O
Dwg_Class	struct
*	O
klass	pointer
=	O
NULL	O
;	O
bit_set_position	function
(	O
dat	pointer
,	O
restartpos	long
)	O
;	O
if	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
(	O
int	O
)	O
dwg	pointer
->	O
num_classes	short
)	O
{	O
klass	pointer
=	O
&	O
dwg	pointer
->	O
dwg_class	pointer
[	O
i	int
]	O
;	O
is_entity	int
=	O
dwg_class_is_entity	function
(	O
klass	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
i	int
<	O
0	int
)	O
LOG_ERROR	O
(	O
"Invalid class index %d < 0"	pointer
,	O
i	int
)	O
else	O
LOG_ERROR	O
(	O
"Invalid class index %d >= %d"	pointer
,	O
i	int
,	O
(	O
int	O
)	O
dwg	pointer
->	O
num_classes	short
)	O
obj	pointer
->	O
type	short
=	O
0	int
;	O
*	O
dat	pointer
=	O
abs_dat	struct
;	O
return	O
error	int
|	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
}	O
if	O
(	O
is_entity	int
)	O
error	int
|=	O
dwg_decode_UNKNOWN_ENT	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
else	O
error	int
|=	O
dwg_decode_UNKNOWN_OBJ	function
(	O
dat	pointer
,	O
obj	pointer
)	O
;	O
if	O
(	O
!	O
dat	pointer
)	O
return	O
error	int
;	O
if	O
(	O
error	int
>=	O
DWG_ERR_CRITICAL	O
)	O
*	O
dat	pointer
=	O
abs_dat	struct
;	O
}	O
}	O
if	O
(	O
obj	pointer
->	O
handle	pointer
.	O
value	double
)	O
{	O
LOG_HANDLE	O
(	O
" object_map{%lX} = %lu\n"	pointer
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
(	O
unsigned	O
long	O
)	O
num	long
)	O
;	O
hash_set	function
(	O
dwg	pointer
->	O
object_map	pointer
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
(	O
uint32_t	int
)	O
num	long
)	O
;	O
}	O
if	O
(	O
dat	pointer
->	O
byte	char
>	O
8	int
*	O
dat	pointer
->	O
size	char
)	O
{	O
LOG_ERROR	O
(	O
"Invalid object address (overflow): %lu > %lu"	pointer
,	O
dat	pointer
->	O
byte	char
,	O
8	int
*	O
dat	pointer
->	O
size	char
)	O
;	O
*	O
dat	pointer
=	O
abs_dat	struct
;	O
return	O
error	int
|	O
DWG_ERR_INVALIDDWG	int
;	O
}	O
restartpos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
*	O
dat	pointer
=	O
abs_dat	struct
;	O
bit_set_position	function
(	O
dat	pointer
,	O
objpos	long
+	O
restartpos	long
)	O
;	O
if	O
(	O
dat	pointer
->	O
bit	char
)	O
{	O
unsigned	O
char	O
r	char
=	O
8	int
-	O
dat	pointer
->	O
bit	char
;	O
LOG_HANDLE	O
(	O
" padding: %X/%X (%d bits)\n"	pointer
,	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
,	O
dat	pointer
->	O
chain	pointer
[	O
dat	pointer
->	O
byte	char
]	O
&	O
(	O
(	O
1	int
<<	O
r	char
)	O
-	O
1	int
)	O
,	O
r	char
)	O
;	O
bit_advance_position	function
(	O
dat	pointer
,	O
r	char
)	O
;	O
}	O
bit_set_position	function
(	O
dat	pointer
,	O
(	O
obj	pointer
->	O
address	long
+	O
obj	pointer
->	O
size	char
)	O
*	O
8	int
-	O
2	int
)	O
;	O
if	O
(	O
!	O
bit_check_CRC	function
(	O
dat	pointer
,	O
address	long
,	O
0xC0C1	int
)	O
)	O
error	int
|=	O
DWG_ERR_WRONGCRC	int
;	O
*	O
dat	pointer
=	O
abs_dat	struct
;	O
return	O
realloced	int
?	O
-	O
1	int
:	O
error	int
;	O
}	O
int	O
dwg_decode_unknown	function
(	O
Bit_Chain	struct
*	O
restrict	O
dat	pointer
,	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
int	O
num_bytes	int
;	O
unsigned	O
long	O
pos	long
=	O
bit_position	function
(	O
dat	pointer
)	O
;	O
long	O
num_bits	long
=	O
(	O
8	int
*	O
obj	pointer
->	O
size	char
)	O
-	O
pos	long
;	O
if	O
(	O
num_bits	long
<	O
0	int
)	O
return	O
DWG_ERR_VALUEOUTOFBOUNDS	int
;	O
obj	pointer
->	O
num_unknown_bits	long
=	O
num_bits	long
;	O
num_bytes	int
=	O
num_bits	long
/	O
8	int
;	O
if	O
(	O
num_bits	long
%	O
8	int
)	O
{	O
num_bytes	int
++	O
;	O
dat	pointer
->	O
size	char
++	O
;	O
}	O
obj	pointer
->	O
unknown_bits	pointer
=	O
bit_read_TF	function
(	O
dat	pointer
,	O
num_bytes	int
)	O
;	O
LOG_TRACE	O
(	O
"unknown_bits [%ld (%lu,%ld,%d) TF]: "	pointer
,	O
num_bits	long
,	O
obj	pointer
->	O
common_size	long
,	O
obj	pointer
->	O
bitsize	int
-	O
obj	pointer
->	O
common_size	long
,	O
(	O
int	O
)	O
obj	pointer
->	O
stringstream_size	int
)	O
;	O
LOG_TRACE_TF	O
(	O
obj	pointer
->	O
unknown_bits	pointer
,	O
num_bytes	int
)	O
;	O
bit_set_position	function
(	O
dat	pointer
,	O
pos	long
)	O
;	O
if	O
(	O
num_bits	long
%	O
8	int
)	O
dat	pointer
->	O
size	char
--	O
;	O
return	O
0	int
;	O
}	O
char	O
*	O
dwg_dim_blockname	function
(	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
const	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
BITCODE_BL	int
id	int
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
objid	int
;	O
Dwg_Object	struct
*	O
restrict	O
hdr	pointer
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
id	int
+	O
1	int
]	O
;	O
Dwg_Object	struct
*	O
restrict	O
blk	struct
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
id	int
+	O
2	int
]	O
;	O
if	O
(	O
(	O
hdr	pointer
->	O
type	short
==	O
DWG_TYPE_LAYER	int
||	O
hdr	pointer
->	O
type	short
==	O
DWG_TYPE_DICTIONARY	int
)	O
&&	O
blk	struct
->	O
type	short
==	O
DWG_TYPE_BLOCK_HEADER	int
)	O
{	O
hdr	pointer
=	O
blk	struct
;	O
blk	struct
=	O
&	O
dwg	pointer
->	O
object	pointer
[	O
id	int
+	O
3	int
]	O
;	O
}	O
if	O
(	O
hdr	pointer
->	O
type	short
==	O
DWG_TYPE_BLOCK_HEADER	int
&&	O
blk	struct
->	O
type	short
==	O
DWG_TYPE_BLOCK	int
)	O
{	O
Dwg_Entity_BLOCK	struct
*	O
restrict	O
_blk	pointer
=	O
blk	struct
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
BLOCK	pointer
;	O
return	O
_blk	pointer
->	O
name	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
inline	O
int	O
ref_after	function
(	O
const	O
Dwg_Object_Ref	struct
*	O
restrict	O
r1	pointer
,	O
const	O
Dwg_Object_Ref	struct
*	O
restrict	O
r2	pointer
)	O
{	O
if	O
(	O
!	O
r1	pointer
||	O
!	O
r2	pointer
||	O
!	O
r1	pointer
->	O
obj	pointer
||	O
!	O
r2	pointer
->	O
obj	pointer
)	O
return	O
0	int
;	O
return	O
r1	pointer
->	O
obj	pointer
->	O
index	short
>=	O
r2	pointer
->	O
obj	pointer
->	O
index	short
?	O
1	int
:	O
0	int
;	O
}	O
int	O
dwg_validate_INSERT	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
Dwg_Object	struct
*	O
restrict	O
next	pointer
=	O
dwg_next_object	function
(	O
obj	pointer
)	O
;	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_INSERT	int
)	O
{	O
Dwg_Entity_INSERT	struct
*	O
restrict	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
INSERT	pointer
;	O
Dwg_Object_Ref	struct
*	O
restrict	O
seqend	pointer
=	O
_obj	pointer
->	O
seqend	pointer
;	O
if	O
(	O
!	O
_obj	pointer
->	O
has_attribs	char
)	O
return	O
1	int
;	O
if	O
(	O
!	O
seqend	pointer
||	O
next	pointer
==	O
seqend	pointer
->	O
obj	pointer
)	O
{	O
LOG_TRACE	O
(	O
"unsorted INSERT %lX SEQEND %lX ATTRIB\n"	pointer
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
seqend	pointer
&&	O
seqend	pointer
->	O
obj	pointer
?	O
seqend	pointer
->	O
obj	pointer
->	O
handle	pointer
.	O
value	double
:	O
0L	int
)	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
obj	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_MINSERT	int
)	O
{	O
Dwg_Entity_MINSERT	struct
*	O
restrict	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
MINSERT	pointer
;	O
Dwg_Object_Ref	struct
*	O
restrict	O
seqend	pointer
=	O
_obj	pointer
->	O
seqend	pointer
;	O
if	O
(	O
!	O
_obj	pointer
->	O
has_attribs	char
)	O
return	O
1	int
;	O
if	O
(	O
!	O
seqend	pointer
||	O
next	pointer
==	O
seqend	pointer
->	O
obj	pointer
)	O
{	O
LOG_TRACE	O
(	O
"unsorted INSERT %lX SEQEND %lX ATTRIB\n"	pointer
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
seqend	pointer
&&	O
seqend	pointer
->	O
obj	pointer
?	O
seqend	pointer
->	O
obj	pointer
->	O
handle	pointer
.	O
value	double
:	O
0L	int
)	O
return	O
0	int
;	O
}	O
}	O
return	O
1	int
;	O
}	O
int	O
dwg_validate_POLYLINE	function
(	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
)	O
{	O
Dwg_Entity_POLYLINE_2D	struct
*	O
restrict	O
_obj	pointer
=	O
obj	pointer
->	O
tio	union
.	O
entity	long
->	O
tio	union
.	O
POLYLINE_2D	pointer
;	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
=	O
obj	pointer
->	O
parent	pointer
;	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>	O
R_11	int
)	O
{	O
Dwg_Object_Ref	struct
*	O
restrict	O
seqend	pointer
=	O
_obj	pointer
->	O
seqend	pointer
;	O
if	O
(	O
!	O
seqend	pointer
)	O
{	O
Dwg_Object	struct
*	O
restrict	O
next	pointer
=	O
dwg_next_object	function
(	O
obj	pointer
)	O
;	O
if	O
(	O
next	pointer
&&	O
next	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_SEQEND	int
)	O
{	O
seqend	pointer
=	O
dwg_find_objectref	function
(	O
dwg	pointer
,	O
next	pointer
)	O
;	O
if	O
(	O
seqend	pointer
==	O
NULL	O
)	O
{	O
seqend	pointer
=	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Object_Ref	struct
)	O
)	O
;	O
seqend	pointer
->	O
obj	pointer
=	O
next	pointer
;	O
seqend	pointer
->	O
handleref	struct
=	O
next	pointer
->	O
handle	pointer
;	O
seqend	pointer
->	O
absolute_ref	long
=	O
next	pointer
->	O
handle	pointer
.	O
value	double
;	O
dwg_decode_add_object_ref	function
(	O
dwg	pointer
,	O
seqend	pointer
)	O
;	O
}	O
_obj	pointer
->	O
seqend	pointer
=	O
seqend	pointer
;	O
LOG_WARN	O
(	O
"fixed empty POLYLINE.seqend with +1 obj"	pointer
)	O
}	O
else	O
if	O
(	O
_obj	pointer
->	O
vertex	pointer
)	O
{	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
=	O
_obj	pointer
->	O
vertex	pointer
[	O
_obj	pointer
->	O
num_owned	int
-	O
1	int
]	O
;	O
if	O
(	O
ref	pointer
&&	O
ref	pointer
->	O
obj	pointer
)	O
{	O
next	pointer
=	O
dwg_next_object	function
(	O
ref	pointer
->	O
obj	pointer
)	O
;	O
if	O
(	O
next	pointer
&&	O
next	pointer
->	O
fixedtype	enum
==	O
DWG_TYPE_SEQEND	int
)	O
{	O
seqend	pointer
=	O
dwg_find_objectref	function
(	O
dwg	pointer
,	O
next	pointer
)	O
;	O
if	O
(	O
seqend	pointer
==	O
NULL	O
)	O
{	O
seqend	pointer
=	O
(	O
Dwg_Object_Ref	struct
*	O
)	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
Dwg_Object_Ref	struct
)	O
)	O
;	O
seqend	pointer
->	O
obj	pointer
=	O
next	pointer
;	O
seqend	pointer
->	O
handleref	struct
=	O
next	pointer
->	O
handle	pointer
;	O
seqend	pointer
->	O
absolute_ref	long
=	O
next	pointer
->	O
handle	pointer
.	O
value	double
;	O
dwg_decode_add_object_ref	function
(	O
dwg	pointer
,	O
seqend	pointer
)	O
;	O
}	O
_obj	pointer
->	O
seqend	pointer
=	O
seqend	pointer
;	O
LOG_WARN	O
(	O
"fixed empty POLYLINE.seqend with last vertex +1"	pointer
)	O
}	O
}	O
}	O
}	O
}	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>	O
R_11	int
&&	O
dwg	pointer
->	O
header	struct
.	O
version	short
<=	O
R_2000	int
)	O
{	O
Dwg_Object_Ref	struct
*	O
restrict	O
first_vertex	pointer
=	O
_obj	pointer
->	O
first_vertex	pointer
;	O
Dwg_Object_Ref	struct
*	O
restrict	O
last_vertex	pointer
=	O
_obj	pointer
->	O
last_vertex	pointer
;	O
Dwg_Object_Ref	struct
*	O
restrict	O
seqend	pointer
=	O
_obj	pointer
->	O
seqend	pointer
;	O
if	O
(	O
ref_after	function
(	O
first_vertex	pointer
,	O
last_vertex	pointer
)	O
||	O
ref_after	function
(	O
last_vertex	pointer
,	O
seqend	pointer
)	O
)	O
{	O
LOG_TRACE	O
(	O
"unsorted POLYLINE VERTEX SEQEND\n"	pointer
)	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
dwg	pointer
->	O
header	struct
.	O
version	short
>=	O
R_2004	int
&&	O
_obj	pointer
->	O
vertex	pointer
)	O
{	O
BITCODE_BL	int
i	int
=	O
1	int
;	O
Dwg_Object_Ref	struct
*	O
restrict	O
first_vertex	pointer
=	O
_obj	pointer
->	O
vertex	pointer
[	O
0	int
]	O
;	O
Dwg_Object_Ref	struct
*	O
restrict	O
seqend	pointer
=	O
_obj	pointer
->	O
seqend	pointer
;	O
if	O
(	O
ref_after	function
(	O
first_vertex	pointer
,	O
seqend	pointer
)	O
)	O
{	O
if	O
(	O
first_vertex	pointer
->	O
obj	pointer
->	O
index	short
<	O
obj	pointer
->	O
index	short
)	O
{	O
LOG_WARN	O
(	O
"skip wrong POLYLINE.vertex[0] handle %lX < %lX\n"	pointer
,	O
first_vertex	pointer
->	O
obj	pointer
->	O
handle	pointer
.	O
value	double
,	O
obj	pointer
->	O
handle	pointer
.	O
value	double
)	O
;	O
if	O
(	O
_obj	pointer
->	O
num_owned	int
>	O
1	int
)	O
first_vertex	pointer
=	O
_obj	pointer
->	O
vertex	pointer
[	O
1	int
]	O
;	O
i	int
=	O
2	int
;	O
}	O
else	O
{	O
LOG_TRACE	O
(	O
"unsorted POLYLINE VERTEX SEQEND\n"	pointer
)	O
return	O
0	int
;	O
}	O
}	O
for	O
(	O
;	O
i	int
<	O
_obj	pointer
->	O
num_owned	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
ref_after	function
(	O
first_vertex	pointer
,	O
_obj	pointer
->	O
vertex	pointer
[	O
i	int
]	O
)	O
||	O
ref_after	function
(	O
_obj	pointer
->	O
vertex	pointer
[	O
i	int
]	O
,	O
seqend	pointer
)	O
)	O
{	O
LOG_TRACE	O
(	O
"unsorted POLYLINE VERTEX SEQEND\n"	pointer
)	O
return	O
0	int
;	O
}	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
const	O
char	O
*	O
dwg_ref_objname	function
(	O
const	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
)	O
{	O
Dwg_Object	struct
*	O
restrict	O
obj	pointer
=	O
dwg_ref_object_silent	function
(	O
dwg	pointer
,	O
ref	pointer
)	O
;	O
return	O
obj	pointer
?	O
obj	pointer
->	O
name	pointer
:	O
""	pointer
;	O
}	O
static	O
const	O
char	O
*	O
dwg_ref_tblname	function
(	O
const	O
Dwg_Data	struct
*	O
restrict	O
dwg	pointer
,	O
Dwg_Object_Ref	struct
*	O
restrict	O
ref	pointer
)	O
{	O
const	O
char	O
*	O
restrict	O
name	pointer
=	O
dwg_dynapi_handle_name	function
(	O
dwg	pointer
,	O
ref	pointer
)	O
;	O
return	O
name	pointer
?	O
name	pointer
:	O
""	pointer
;	O
}	O
