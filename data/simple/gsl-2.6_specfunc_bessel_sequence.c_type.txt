static	O
int	O
rk_step	function
(	O
double	O
nu	double
,	O
double	O
x	double
,	O
double	O
dx	double
,	O
double	O
*	O
Jp	pointer
,	O
double	O
*	O
J	pointer
)	O
{	O
double	O
p_0	double
=	O
*	O
Jp	pointer
;	O
double	O
u_0	double
=	O
*	O
J	pointer
;	O
double	O
p_1	double
=	O
dx	double
*	O
DYDX_p	O
(	O
p_0	double
,	O
u_0	double
,	O
x	double
)	O
;	O
double	O
u_1	double
=	O
dx	double
*	O
DYDX_u	O
(	O
p_0	double
,	O
u_0	double
,	O
x	double
)	O
;	O
double	O
p_2	double
=	O
dx	double
*	O
DYDX_p	O
(	O
p_0	double
+	O
0.5	int
*	O
p_1	double
,	O
u_0	double
+	O
0.5	int
*	O
u_1	double
,	O
x	double
+	O
0.5	int
*	O
dx	double
)	O
;	O
double	O
u_2	double
=	O
dx	double
*	O
DYDX_u	O
(	O
p_0	double
+	O
0.5	int
*	O
p_1	double
,	O
u_0	double
+	O
0.5	int
*	O
u_1	double
,	O
x	double
+	O
0.5	int
*	O
dx	double
)	O
;	O
double	O
p_3	double
=	O
dx	double
*	O
DYDX_p	O
(	O
p_0	double
+	O
0.5	int
*	O
p_2	double
,	O
u_0	double
+	O
0.5	int
*	O
u_2	double
,	O
x	double
+	O
0.5	int
*	O
dx	double
)	O
;	O
double	O
u_3	double
=	O
dx	double
*	O
DYDX_u	O
(	O
p_0	double
+	O
0.5	int
*	O
p_2	double
,	O
u_0	double
+	O
0.5	int
*	O
u_2	double
,	O
x	double
+	O
0.5	int
*	O
dx	double
)	O
;	O
double	O
p_4	double
=	O
dx	double
*	O
DYDX_p	O
(	O
p_0	double
+	O
p_3	double
,	O
u_0	double
+	O
u_3	double
,	O
x	double
+	O
dx	double
)	O
;	O
double	O
u_4	double
=	O
dx	double
*	O
DYDX_u	O
(	O
p_0	double
+	O
p_3	double
,	O
u_0	double
+	O
u_3	double
,	O
x	double
+	O
dx	double
)	O
;	O
*	O
Jp	pointer
=	O
p_0	double
+	O
p_1	double
/	O
6.0	int
+	O
p_2	double
/	O
3.0	int
+	O
p_3	double
/	O
3.0	int
+	O
p_4	double
/	O
6.0	int
;	O
*	O
J	pointer
=	O
u_0	double
+	O
u_1	double
/	O
6.0	int
+	O
u_2	double
/	O
3.0	int
+	O
u_3	double
/	O
3.0	int
+	O
u_4	double
/	O
6.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
int	O
gsl_sf_bessel_sequence_Jnu_e	function
(	O
double	O
nu	double
,	O
gsl_mode_t	int
mode	int
,	O
size_t	long
size	long
,	O
double	O
*	O
v	pointer
)	O
{	O
if	O
(	O
nu	double
<	O
0.0	int
)	O
{	O
GSL_ERROR	O
(	O
"domain error"	pointer
,	O
GSL_EDOM	int
)	O
;	O
}	O
else	O
if	O
(	O
size	long
==	O
0	int
)	O
{	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
else	O
{	O
const	O
gsl_prec_t	int
goal	int
=	O
GSL_MODE_PREC	function
(	O
mode	int
)	O
;	O
const	O
double	O
dx_array	array
[	O
]	O
=	O
{	O
0.001	int
,	O
0.03	int
,	O
0.1	int
}	O
;	O
const	O
double	O
dx_nominal	double
=	O
dx_array	array
[	O
goal	int
]	O
;	O
const	O
int	O
cnu	int
=	O
(	O
int	O
)	O
ceil	function
(	O
nu	double
)	O
;	O
const	O
double	O
nu13	double
=	O
pow	function
(	O
nu	double
,	O
1.0	int
/	O
3.0	int
)	O
;	O
const	O
double	O
smalls	array
[	O
]	O
=	O
{	O
0.01	int
,	O
0.02	int
,	O
0.4	int
,	O
0.7	int
,	O
1.3	int
,	O
2.0	int
,	O
2.5	int
,	O
3.2	int
,	O
3.5	int
,	O
4.5	int
,	O
6.0	int
}	O
;	O
const	O
double	O
x_small	double
=	O
(	O
nu	double
>=	O
10.0	int
?	O
nu	double
-	O
nu13	double
:	O
smalls	array
[	O
cnu	int
]	O
)	O
;	O
gsl_sf_result	struct
J0	struct
,	O
J1	struct
;	O
double	O
Jp	pointer
,	O
J	pointer
;	O
double	O
x	double
;	O
size_t	long
i	long
=	O
0	int
;	O
x	double
=	O
v	pointer
[	O
0	int
]	O
;	O
gsl_sf_bessel_Jnu_e	function
(	O
nu	double
,	O
x	double
,	O
&	O
J0	struct
)	O
;	O
v	pointer
[	O
0	int
]	O
=	O
J0	struct
.	O
val	double
;	O
++	O
i	long
;	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
if	O
(	O
v	pointer
[	O
1	int
]	O
<=	O
x	double
)	O
{	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
x	double
=	O
v	pointer
[	O
1	int
]	O
;	O
gsl_sf_bessel_Jnu_e	function
(	O
nu	double
,	O
x	double
,	O
&	O
J0	struct
)	O
;	O
v	pointer
[	O
1	int
]	O
=	O
J0	struct
.	O
val	double
;	O
++	O
i	long
;	O
}	O
while	O
(	O
v	pointer
[	O
i	long
]	O
<	O
x_small	double
&&	O
i	long
<	O
size	long
)	O
{	O
if	O
(	O
v	pointer
[	O
i	long
]	O
<=	O
x	double
)	O
{	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
x	double
=	O
v	pointer
[	O
i	long
]	O
;	O
gsl_sf_bessel_Jnu_e	function
(	O
nu	double
,	O
x	double
,	O
&	O
J0	struct
)	O
;	O
v	pointer
[	O
i	long
]	O
=	O
J0	struct
.	O
val	double
;	O
++	O
i	long
;	O
}	O
gsl_sf_bessel_Jnu_e	function
(	O
nu	double
+	O
1.0	int
,	O
x	double
,	O
&	O
J1	struct
)	O
;	O
J	pointer
=	O
J0	struct
.	O
val	double
;	O
Jp	pointer
=	O
-	O
J1	struct
.	O
val	double
+	O
nu	double
/	O
x	double
*	O
J0	struct
.	O
val	double
;	O
while	O
(	O
i	long
<	O
size	long
)	O
{	O
const	O
double	O
dv	double
=	O
v	pointer
[	O
i	long
]	O
-	O
x	double
;	O
const	O
int	O
Nd	int
=	O
(	O
int	O
)	O
ceil	function
(	O
dv	double
/	O
dx_nominal	double
)	O
;	O
const	O
double	O
dx	double
=	O
dv	double
/	O
Nd	int
;	O
double	O
xj	double
;	O
int	O
j	int
;	O
if	O
(	O
v	pointer
[	O
i	long
]	O
<=	O
x	double
)	O
{	O
GSL_ERROR	O
(	O
"error"	pointer
,	O
GSL_EFAILED	int
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
,	O
xj	double
=	O
x	double
;	O
j	int
<	O
Nd	int
;	O
j	int
++	O
,	O
xj	double
+=	O
dx	double
)	O
{	O
rk_step	function
(	O
nu	double
,	O
xj	double
,	O
dx	double
,	O
&	O
Jp	pointer
,	O
&	O
J	pointer
)	O
;	O
}	O
x	double
=	O
v	pointer
[	O
i	long
]	O
;	O
v	pointer
[	O
i	long
]	O
=	O
J	pointer
;	O
++	O
i	long
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
