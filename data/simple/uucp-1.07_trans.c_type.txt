const	O
char	O
trans_rcsid	array
[	O
]	O
=	O
"$Id: trans.c,v 1.49 2002/03/05 19:10:41 ian Rel $"	pointer
;	O
struct	O
sreceive_ack	struct
{	O
struct	O
sreceive_ack	struct
*	O
qnext	pointer
;	O
char	O
*	O
zto	pointer
;	O
char	O
*	O
ztemp	pointer
;	O
boolean	int
fmarked	int
;	O
}	O
;	O
static	O
void	O
utqueue	function
P	O
(	O
(	O
struct	O
stransfer	struct
*	O
*	O
,	O
struct	O
stransfer	struct
*	O
,	O
boolean	int
fhead	int
)	O
)	O
;	O
static	O
void	O
utdequeue	function
P	O
(	O
(	O
struct	O
stransfer	struct
*	O
)	O
)	O
;	O
static	O
void	O
utchanalc	function
P	O
(	O
(	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
,	O
struct	O
stransfer	struct
*	O
qtrans	pointer
)	O
)	O
;	O
__inline__	O
static	O
struct	O
stransfer	struct
*	O
qtchan	function
P	O
(	O
(	O
int	O
ichan	int
)	O
)	O
;	O
__inline__	O
static	O
void	O
utchanfree	function
P	O
(	O
(	O
struct	O
stransfer	struct
*	O
qtrans	pointer
)	O
)	O
;	O
static	O
void	O
utfree_queue	function
P	O
(	O
(	O
struct	O
stransfer	struct
*	O
*	O
pq	pointer
)	O
)	O
;	O
static	O
boolean	int
fttime	function
P	O
(	O
(	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
,	O
long	O
*	O
pisecs	pointer
,	O
long	O
*	O
pimicros	pointer
)	O
)	O
;	O
static	O
boolean	int
fcheck_queue	function
P	O
(	O
(	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
)	O
)	O
;	O
static	O
boolean	int
ftadd_cmd	function
P	O
(	O
(	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
,	O
const	O
char	O
*	O
z	pointer
,	O
size_t	long
cdata	long
,	O
int	O
iremote	int
,	O
boolean	int
flast	int
)	O
)	O
;	O
static	O
boolean	int
fremote_hangup_reply	function
P	O
(	O
(	O
struct	O
stransfer	struct
*	O
qtrans	pointer
,	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
)	O
)	O
;	O
static	O
void	O
utfree_receive_ack	function
P	O
(	O
(	O
struct	O
sreceive_ack	struct
*	O
q	pointer
)	O
)	O
;	O
static	O
void	O
utfree_acked	function
P	O
(	O
(	O
void	O
)	O
)	O
;	O
static	O
boolean	int
flocal_poll_file	function
P	O
(	O
(	O
struct	O
stransfer	struct
*	O
qtrans	pointer
,	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
)	O
)	O
;	O
static	O
struct	O
stransfer	struct
*	O
qTlocal	pointer
;	O
static	O
struct	O
stransfer	struct
*	O
qTremote	pointer
;	O
struct	O
stransfer	struct
*	O
qTsend	pointer
;	O
static	O
struct	O
stransfer	struct
*	O
qTreceive	pointer
;	O
static	O
struct	O
stransfer	struct
*	O
qTavail	pointer
;	O
static	O
struct	O
stransfer	struct
*	O
aqTchan	array
[	O
IMAX_CHAN	O
+	O
1	int
]	O
;	O
static	O
int	O
cTchans	int
;	O
static	O
int	O
iTchan	int
;	O
static	O
struct	O
stransfer	struct
*	O
aqTremote	array
[	O
IMAX_CHAN	O
+	O
1	int
]	O
;	O
static	O
struct	O
stransfer	struct
*	O
qTtiming_rec	pointer
;	O
static	O
long	O
iTrecsecs	long
;	O
static	O
long	O
iTrecmicros	long
;	O
static	O
long	O
iTchecktime	long
;	O
static	O
size_t	long
cTcmdlen	long
;	O
static	O
struct	O
sreceive_ack	struct
*	O
qTreceive_ack	pointer
;	O
static	O
void	O
utqueue	function
(	O
pq	pointer
,	O
q	pointer
,	O
fhead	int
)	O
struct	O
stransfer	struct
*	O
*	O
pq	pointer
;	O
struct	O
stransfer	struct
*	O
q	pointer
;	O
boolean	int
fhead	int
;	O
{	O
if	O
(	O
*	O
pq	pointer
==	O
NULL	O
)	O
{	O
*	O
pq	pointer
=	O
q	pointer
;	O
q	pointer
->	O
qprev	pointer
=	O
q	pointer
->	O
qnext	pointer
=	O
q	pointer
;	O
}	O
else	O
{	O
q	pointer
->	O
qnext	pointer
=	O
*	O
pq	pointer
;	O
q	pointer
->	O
qprev	pointer
=	O
(	O
*	O
pq	pointer
)	O
->	O
qprev	pointer
;	O
q	pointer
->	O
qprev	pointer
->	O
qnext	pointer
=	O
q	pointer
;	O
q	pointer
->	O
qnext	pointer
->	O
qprev	pointer
=	O
q	pointer
;	O
if	O
(	O
fhead	int
)	O
*	O
pq	pointer
=	O
q	pointer
;	O
}	O
q	pointer
->	O
pqqueue	pointer
=	O
pq	pointer
;	O
}	O
static	O
void	O
utdequeue	function
(	O
q	pointer
)	O
struct	O
stransfer	struct
*	O
q	pointer
;	O
{	O
if	O
(	O
q	pointer
->	O
pqqueue	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
*	O
(	O
q	pointer
->	O
pqqueue	pointer
)	O
==	O
q	pointer
)	O
{	O
if	O
(	O
q	pointer
->	O
qnext	pointer
==	O
q	pointer
)	O
*	O
(	O
q	pointer
->	O
pqqueue	pointer
)	O
=	O
NULL	O
;	O
else	O
*	O
(	O
q	pointer
->	O
pqqueue	pointer
)	O
=	O
q	pointer
->	O
qnext	pointer
;	O
}	O
q	pointer
->	O
pqqueue	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
q	pointer
->	O
qprev	pointer
!=	O
NULL	O
)	O
q	pointer
->	O
qprev	pointer
->	O
qnext	pointer
=	O
q	pointer
->	O
qnext	pointer
;	O
if	O
(	O
q	pointer
->	O
qnext	pointer
!=	O
NULL	O
)	O
q	pointer
->	O
qnext	pointer
->	O
qprev	pointer
=	O
q	pointer
->	O
qprev	pointer
;	O
q	pointer
->	O
qprev	pointer
=	O
NULL	O
;	O
q	pointer
->	O
qnext	pointer
=	O
NULL	O
;	O
}	O
boolean	int
fqueue_local	function
(	O
qdaemon	pointer
,	O
qtrans	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
ATTRIBUTE_UNUSED	O
;	O
struct	O
stransfer	struct
*	O
qtrans	pointer
;	O
{	O
utdequeue	function
(	O
qtrans	pointer
)	O
;	O
utqueue	function
(	O
&	O
qTlocal	pointer
,	O
qtrans	pointer
,	O
FALSE	O
)	O
;	O
return	O
TRUE	O
;	O
}	O
boolean	int
fqueue_remote	function
(	O
qdaemon	pointer
,	O
qtrans	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
ATTRIBUTE_UNUSED	O
;	O
struct	O
stransfer	struct
*	O
qtrans	pointer
;	O
{	O
DEBUG_MESSAGE1	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"fqueue_remote: Channel %d"	pointer
,	O
qtrans	pointer
->	O
iremote	int
)	O
;	O
if	O
(	O
qtrans	pointer
->	O
iremote	int
>	O
0	int
)	O
aqTremote	array
[	O
qtrans	pointer
->	O
iremote	int
]	O
=	O
qtrans	pointer
;	O
utdequeue	function
(	O
qtrans	pointer
)	O
;	O
utqueue	function
(	O
&	O
qTremote	pointer
,	O
qtrans	pointer
,	O
FALSE	O
)	O
;	O
return	O
TRUE	O
;	O
}	O
boolean	int
fqueue_send	function
(	O
qdaemon	pointer
,	O
qtrans	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
ATTRIBUTE_UNUSED	O
;	O
struct	O
stransfer	struct
*	O
qtrans	pointer
;	O
{	O
if	O
(	O
qtrans	pointer
->	O
psendfn	pointer
==	O
NULL	O
)	O
ulog	function
(	O
LOG_FATAL	int
,	O
"fqueue_send: Bad call"	pointer
)	O
;	O
utdequeue	function
(	O
qtrans	pointer
)	O
;	O
if	O
(	O
qTsend	pointer
==	O
NULL	O
)	O
utqueue	function
(	O
&	O
qTsend	pointer
,	O
qtrans	pointer
,	O
FALSE	O
)	O
;	O
else	O
{	O
register	O
struct	O
stransfer	struct
*	O
q	pointer
;	O
boolean	int
ffirst	int
;	O
ffirst	int
=	O
TRUE	O
;	O
q	pointer
=	O
qTsend	pointer
;	O
do	O
{	O
if	O
(	O
!	O
qtrans	pointer
->	O
fsendfile	int
&&	O
q	pointer
->	O
fsendfile	int
)	O
break	O
;	O
if	O
(	O
(	O
!	O
qtrans	pointer
->	O
fsendfile	int
||	O
q	pointer
->	O
fsendfile	int
)	O
&&	O
UUCONF_GRADE_CMP	O
(	O
qtrans	pointer
->	O
s	struct
.	O
bgrade	char
,	O
q	pointer
->	O
s	struct
.	O
bgrade	char
)	O
<	O
0	int
)	O
break	O
;	O
ffirst	int
=	O
FALSE	O
;	O
q	pointer
=	O
q	pointer
->	O
qnext	pointer
;	O
}	O
while	O
(	O
q	pointer
!=	O
qTsend	pointer
)	O
;	O
qtrans	pointer
->	O
qnext	pointer
=	O
q	pointer
;	O
qtrans	pointer
->	O
qprev	pointer
=	O
q	pointer
->	O
qprev	pointer
;	O
q	pointer
->	O
qprev	pointer
=	O
qtrans	pointer
;	O
qtrans	pointer
->	O
qprev	pointer
->	O
qnext	pointer
=	O
qtrans	pointer
;	O
if	O
(	O
ffirst	int
)	O
qTsend	pointer
=	O
qtrans	pointer
;	O
qtrans	pointer
->	O
pqqueue	pointer
=	O
&	O
qTsend	pointer
;	O
}	O
return	O
TRUE	O
;	O
}	O
boolean	int
fqueue_receive	function
(	O
qdaemon	pointer
,	O
qtrans	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
ATTRIBUTE_UNUSED	O
;	O
struct	O
stransfer	struct
*	O
qtrans	pointer
;	O
{	O
if	O
(	O
qtrans	pointer
->	O
precfn	pointer
==	O
NULL	O
)	O
ulog	function
(	O
LOG_FATAL	int
,	O
"fqueue_receive: Bad call"	pointer
)	O
;	O
if	O
(	O
qTreceive	pointer
==	O
NULL	O
)	O
iTrecsecs	long
=	O
ixsysdep_process_time	function
(	O
&	O
iTrecmicros	long
)	O
;	O
utdequeue	function
(	O
qtrans	pointer
)	O
;	O
utqueue	function
(	O
&	O
qTreceive	pointer
,	O
qtrans	pointer
,	O
FALSE	O
)	O
;	O
return	O
TRUE	O
;	O
}	O
static	O
void	O
utchanalc	function
(	O
qdaemon	pointer
,	O
qtrans	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
struct	O
stransfer	struct
*	O
qtrans	pointer
;	O
{	O
do	O
{	O
++	O
iTchan	int
;	O
if	O
(	O
iTchan	int
>	O
qdaemon	pointer
->	O
cchans	int
)	O
iTchan	int
=	O
1	int
;	O
}	O
while	O
(	O
aqTchan	array
[	O
iTchan	int
]	O
!=	O
NULL	O
)	O
;	O
qtrans	pointer
->	O
ilocal	int
=	O
iTchan	int
;	O
aqTchan	array
[	O
iTchan	int
]	O
=	O
qtrans	pointer
;	O
++	O
cTchans	int
;	O
}	O
__inline__	O
static	O
struct	O
stransfer	struct
*	O
qtchan	function
(	O
ic	int
)	O
int	O
ic	int
;	O
{	O
return	O
aqTchan	array
[	O
ic	int
]	O
;	O
}	O
__inline__	O
static	O
void	O
utchanfree	function
(	O
qt	pointer
)	O
struct	O
stransfer	struct
*	O
qt	pointer
;	O
{	O
if	O
(	O
qt	pointer
->	O
ilocal	int
!=	O
0	int
)	O
{	O
aqTchan	array
[	O
qt	pointer
->	O
ilocal	int
]	O
=	O
NULL	O
;	O
qt	pointer
->	O
ilocal	int
=	O
0	int
;	O
--	O
cTchans	int
;	O
}	O
}	O
struct	O
stransfer	struct
*	O
qtransalc	function
(	O
qcmd	pointer
)	O
struct	O
scmd	struct
*	O
qcmd	pointer
;	O
{	O
register	O
struct	O
stransfer	struct
*	O
q	pointer
;	O
q	pointer
=	O
qTavail	pointer
;	O
if	O
(	O
q	pointer
!=	O
NULL	O
)	O
utdequeue	function
(	O
q	pointer
)	O
;	O
else	O
q	pointer
=	O
(	O
struct	O
stransfer	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
stransfer	struct
)	O
)	O
;	O
q	pointer
->	O
qnext	pointer
=	O
NULL	O
;	O
q	pointer
->	O
qprev	pointer
=	O
NULL	O
;	O
q	pointer
->	O
pqqueue	pointer
=	O
NULL	O
;	O
q	pointer
->	O
psendfn	pointer
=	O
NULL	O
;	O
q	pointer
->	O
precfn	pointer
=	O
NULL	O
;	O
q	pointer
->	O
pinfo	pointer
=	O
NULL	O
;	O
q	pointer
->	O
fsendfile	int
=	O
FALSE	O
;	O
q	pointer
->	O
frecfile	int
=	O
FALSE	O
;	O
q	pointer
->	O
e	pointer
=	O
EFILECLOSED	O
;	O
q	pointer
->	O
ipos	long
=	O
0	int
;	O
q	pointer
->	O
fcmd	int
=	O
FALSE	O
;	O
q	pointer
->	O
zcmd	pointer
=	O
NULL	O
;	O
q	pointer
->	O
ccmd	long
=	O
0	int
;	O
q	pointer
->	O
ilocal	int
=	O
0	int
;	O
q	pointer
->	O
iremote	int
=	O
0	int
;	O
if	O
(	O
qcmd	pointer
!=	O
NULL	O
)	O
{	O
q	pointer
->	O
s	struct
=	O
*	O
qcmd	pointer
;	O
q	pointer
->	O
s	struct
.	O
zfrom	pointer
=	O
zbufcpy	function
(	O
qcmd	pointer
->	O
zfrom	pointer
)	O
;	O
q	pointer
->	O
s	struct
.	O
zto	pointer
=	O
zbufcpy	function
(	O
qcmd	pointer
->	O
zto	pointer
)	O
;	O
q	pointer
->	O
s	struct
.	O
zuser	pointer
=	O
zbufcpy	function
(	O
qcmd	pointer
->	O
zuser	pointer
)	O
;	O
q	pointer
->	O
s	struct
.	O
zoptions	pointer
=	O
zbufcpy	function
(	O
qcmd	pointer
->	O
zoptions	pointer
)	O
;	O
q	pointer
->	O
s	struct
.	O
ztemp	pointer
=	O
zbufcpy	function
(	O
qcmd	pointer
->	O
ztemp	pointer
)	O
;	O
q	pointer
->	O
s	struct
.	O
znotify	pointer
=	O
zbufcpy	function
(	O
qcmd	pointer
->	O
znotify	pointer
)	O
;	O
q	pointer
->	O
s	struct
.	O
zcmd	pointer
=	O
zbufcpy	function
(	O
qcmd	pointer
->	O
zcmd	pointer
)	O
;	O
}	O
else	O
{	O
q	pointer
->	O
s	struct
.	O
zfrom	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
zto	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
zuser	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
zoptions	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
ztemp	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
znotify	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
zcmd	pointer
=	O
NULL	O
;	O
}	O
q	pointer
->	O
zlog	pointer
=	O
NULL	O
;	O
q	pointer
->	O
isecs	long
=	O
0	int
;	O
q	pointer
->	O
imicros	long
=	O
0	int
;	O
q	pointer
->	O
cbytes	long
=	O
0	int
;	O
return	O
q	pointer
;	O
}	O
void	O
utransfree	function
(	O
q	pointer
)	O
struct	O
stransfer	struct
*	O
q	pointer
;	O
{	O
ubuffree	function
(	O
q	pointer
->	O
zcmd	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
q	pointer
->	O
s	struct
.	O
zfrom	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
q	pointer
->	O
s	struct
.	O
zto	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
q	pointer
->	O
s	struct
.	O
zuser	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
q	pointer
->	O
s	struct
.	O
zoptions	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
q	pointer
->	O
s	struct
.	O
ztemp	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
q	pointer
->	O
s	struct
.	O
znotify	pointer
)	O
;	O
ubuffree	function
(	O
(	O
char	O
*	O
)	O
q	pointer
->	O
s	struct
.	O
zcmd	pointer
)	O
;	O
utchanfree	function
(	O
q	pointer
)	O
;	O
if	O
(	O
q	pointer
->	O
iremote	int
>	O
0	int
)	O
{	O
aqTremote	array
[	O
q	pointer
->	O
iremote	int
]	O
=	O
NULL	O
;	O
q	pointer
->	O
iremote	int
=	O
0	int
;	O
}	O
if	O
(	O
ffileisopen	O
(	O
q	pointer
->	O
e	pointer
)	O
)	O
{	O
(	O
void	O
)	O
ffileclose	O
(	O
q	pointer
->	O
e	pointer
)	O
;	O
q	pointer
->	O
e	pointer
=	O
EFILECLOSED	O
;	O
}	O
q	pointer
->	O
zcmd	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
zfrom	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
zto	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
zuser	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
zoptions	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
ztemp	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
znotify	pointer
=	O
NULL	O
;	O
q	pointer
->	O
s	struct
.	O
zcmd	pointer
=	O
NULL	O
;	O
q	pointer
->	O
psendfn	pointer
=	O
NULL	O
;	O
q	pointer
->	O
precfn	pointer
=	O
NULL	O
;	O
if	O
(	O
qTtiming_rec	pointer
==	O
q	pointer
)	O
qTtiming_rec	pointer
=	O
NULL	O
;	O
utdequeue	function
(	O
q	pointer
)	O
;	O
utqueue	function
(	O
&	O
qTavail	pointer
,	O
q	pointer
,	O
FALSE	O
)	O
;	O
}	O
static	O
void	O
utfree_queue	function
(	O
pq	pointer
)	O
struct	O
stransfer	struct
*	O
*	O
pq	pointer
;	O
{	O
while	O
(	O
*	O
pq	pointer
!=	O
NULL	O
)	O
utransfree	function
(	O
*	O
pq	pointer
)	O
;	O
}	O
static	O
boolean	int
fttime	function
(	O
qdaemon	pointer
,	O
pisecs	pointer
,	O
pimicros	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
long	O
*	O
pisecs	pointer
;	O
long	O
*	O
pimicros	pointer
;	O
{	O
*	O
pisecs	pointer
=	O
ixsysdep_process_time	function
(	O
pimicros	pointer
)	O
;	O
if	O
(	O
*	O
pisecs	pointer
-	O
iTchecktime	long
>=	O
CCHECKWAIT	O
)	O
{	O
if	O
(	O
!	O
fcheck_queue	function
(	O
qdaemon	pointer
)	O
)	O
return	O
FALSE	O
;	O
}	O
return	O
TRUE	O
;	O
}	O
boolean	int
fqueue	function
(	O
qdaemon	pointer
,	O
pfany	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
boolean	int
*	O
pfany	pointer
;	O
{	O
const	O
struct	O
uuconf_system	struct
*	O
qsys	pointer
;	O
long	O
ival	long
;	O
int	O
bgrade	char
;	O
struct	O
uuconf_timespan	struct
*	O
qlocal_size	pointer
,	O
*	O
qremote_size	pointer
;	O
if	O
(	O
pfany	pointer
!=	O
NULL	O
)	O
*	O
pfany	pointer
=	O
FALSE	O
;	O
qsys	pointer
=	O
qdaemon	pointer
->	O
qsys	pointer
;	O
if	O
(	O
!	O
qdaemon	pointer
->	O
fcaller	int
)	O
{	O
if	O
(	O
!	O
ftimespan_match	function
(	O
qsys	pointer
->	O
uuconf_qcalledtimegrade	pointer
,	O
&	O
ival	long
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
)	O
bgrade	char
=	O
qdaemon	pointer
->	O
bgrade	char
;	O
else	O
bgrade	char
=	O
(	O
char	O
)	O
ival	long
;	O
}	O
else	O
{	O
if	O
(	O
!	O
ftimespan_match	function
(	O
qsys	pointer
->	O
uuconf_qtimegrade	pointer
,	O
&	O
ival	long
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
)	O
bgrade	char
=	O
'\0'	O
;	O
else	O
bgrade	char
=	O
(	O
char	O
)	O
ival	long
;	O
}	O
if	O
(	O
qdaemon	pointer
->	O
fcaller	int
)	O
{	O
qlocal_size	pointer
=	O
qsys	pointer
->	O
uuconf_qcall_local_size	pointer
;	O
qremote_size	pointer
=	O
qsys	pointer
->	O
uuconf_qcall_remote_size	pointer
;	O
}	O
else	O
{	O
qlocal_size	pointer
=	O
qsys	pointer
->	O
uuconf_qcalled_local_size	pointer
;	O
qremote_size	pointer
=	O
qsys	pointer
->	O
uuconf_qcalled_remote_size	pointer
;	O
}	O
if	O
(	O
!	O
ftimespan_match	function
(	O
qlocal_size	pointer
,	O
&	O
qdaemon	pointer
->	O
clocal_size	long
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
)	O
qdaemon	pointer
->	O
clocal_size	long
=	O
(	O
long	O
)	O
-	O
1	int
;	O
if	O
(	O
!	O
ftimespan_match	function
(	O
qremote_size	pointer
,	O
&	O
qdaemon	pointer
->	O
cremote_size	long
,	O
(	O
int	O
*	O
)	O
NULL	O
)	O
)	O
qdaemon	pointer
->	O
cremote_size	long
=	O
(	O
long	O
)	O
-	O
1	int
;	O
if	O
(	O
bgrade	char
==	O
'\0'	O
)	O
return	O
TRUE	O
;	O
if	O
(	O
!	O
fsysdep_get_work_init	function
(	O
qsys	pointer
,	O
bgrade	char
,	O
COMMANDS_PER_SCAN	O
)	O
)	O
return	O
FALSE	O
;	O
while	O
(	O
TRUE	O
)	O
{	O
struct	O
scmd	struct
s	struct
;	O
if	O
(	O
!	O
fsysdep_get_work	function
(	O
qsys	pointer
,	O
bgrade	char
,	O
COMMANDS_PER_SCAN	O
,	O
&	O
s	struct
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
s	struct
.	O
bcmd	char
==	O
'H'	O
)	O
{	O
ulog_user	function
(	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
s	struct
.	O
bcmd	char
==	O
'P'	O
)	O
{	O
struct	O
stransfer	struct
*	O
qtrans	pointer
;	O
ulog_user	function
(	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
qtrans	pointer
=	O
qtransalc	function
(	O
&	O
s	struct
)	O
;	O
qtrans	pointer
->	O
psendfn	pointer
=	O
flocal_poll_file	function
;	O
if	O
(	O
!	O
fqueue_local	function
(	O
qdaemon	pointer
,	O
qtrans	pointer
)	O
)	O
return	O
FALSE	O
;	O
continue	O
;	O
}	O
ulog_user	function
(	O
s	struct
.	O
zuser	pointer
)	O
;	O
switch	O
(	O
s	struct
.	O
bcmd	char
)	O
{	O
case	O
'S'	O
:	O
case	O
'E'	O
:	O
if	O
(	O
!	O
flocal_send_file_init	function
(	O
qdaemon	pointer
,	O
&	O
s	struct
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'R'	O
:	O
if	O
(	O
!	O
flocal_rec_file_init	function
(	O
qdaemon	pointer
,	O
&	O
s	struct
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
case	O
'X'	O
:	O
if	O
(	O
!	O
flocal_xcmd_init	function
(	O
qdaemon	pointer
,	O
&	O
s	struct
)	O
)	O
return	O
FALSE	O
;	O
break	O
;	O
default	O
:	O
ulog	function
(	O
LOG_FATAL	int
,	O
"fqueue: Can't happen"	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
pfany	pointer
!=	O
NULL	O
)	O
*	O
pfany	pointer
=	O
qTlocal	pointer
!=	O
NULL	O
;	O
iTchecktime	long
=	O
ixsysdep_process_time	function
(	O
(	O
long	O
*	O
)	O
NULL	O
)	O
;	O
return	O
TRUE	O
;	O
}	O
void	O
uclear_queue	function
(	O
qdaemon	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
{	O
int	O
i	int
;	O
usysdep_get_work_free	function
(	O
qdaemon	pointer
->	O
qsys	pointer
)	O
;	O
utfree_queue	function
(	O
&	O
qTlocal	pointer
)	O
;	O
utfree_queue	function
(	O
&	O
qTremote	pointer
)	O
;	O
utfree_queue	function
(	O
&	O
qTsend	pointer
)	O
;	O
utfree_queue	function
(	O
&	O
qTreceive	pointer
)	O
;	O
cTchans	int
=	O
0	int
;	O
iTchan	int
=	O
0	int
;	O
qTtiming_rec	pointer
=	O
NULL	O
;	O
cTcmdlen	long
=	O
0	int
;	O
if	O
(	O
qTreceive_ack	pointer
!=	O
NULL	O
)	O
utfree_acked	function
(	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
IMAX_CHAN	O
+	O
1	int
;	O
i	int
++	O
)	O
{	O
aqTchan	array
[	O
i	int
]	O
=	O
NULL	O
;	O
aqTremote	array
[	O
i	int
]	O
=	O
NULL	O
;	O
}	O
}	O
static	O
boolean	int
fcheck_queue	function
(	O
qdaemon	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
{	O
if	O
(	O
qdaemon	pointer
->	O
fmaster	int
||	O
qdaemon	pointer
->	O
cchans	int
>	O
1	int
||	O
!	O
qdaemon	pointer
->	O
frequest_hangup	int
)	O
{	O
boolean	int
fany	int
;	O
DEBUG_MESSAGE0	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"fcheck_queue: Rechecking work queue"	pointer
)	O
;	O
if	O
(	O
!	O
fqueue	function
(	O
qdaemon	pointer
,	O
&	O
fany	int
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
fany	int
&&	O
!	O
qdaemon	pointer
->	O
fmaster	int
&&	O
qdaemon	pointer
->	O
cchans	int
<=	O
1	int
)	O
qdaemon	pointer
->	O
frequest_hangup	int
=	O
TRUE	O
;	O
}	O
return	O
TRUE	O
;	O
}	O
boolean	int
floop	function
(	O
qdaemon	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
{	O
boolean	int
fret	int
;	O
fret	int
=	O
TRUE	O
;	O
while	O
(	O
!	O
qdaemon	pointer
->	O
fhangup	int
)	O
{	O
register	O
struct	O
stransfer	struct
*	O
q	pointer
;	O
if	O
(	O
iDebug	int
!=	O
0	int
)	O
{	O
ulog_close	function
(	O
)	O
;	O
ustats_close	function
(	O
)	O
;	O
}	O
if	O
(	O
qdaemon	pointer
->	O
fmaster	int
)	O
{	O
boolean	int
fhangup	int
;	O
qdaemon	pointer
->	O
frequest_hangup	int
=	O
FALSE	O
;	O
fhangup	int
=	O
FALSE	O
;	O
if	O
(	O
qdaemon	pointer
->	O
fhangup_requested	int
&&	O
qTsend	pointer
==	O
NULL	O
&&	O
(	O
qTreceive	pointer
==	O
NULL	O
||	O
qdaemon	pointer
->	O
cchans	int
>	O
1	int
)	O
)	O
{	O
DEBUG_MESSAGE0	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"floop: Transferring control at remote request"	pointer
)	O
;	O
fhangup	int
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
qTremote	pointer
==	O
NULL	O
&&	O
qTlocal	pointer
==	O
NULL	O
&&	O
qTsend	pointer
==	O
NULL	O
&&	O
qTreceive	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
fqueue	function
(	O
qdaemon	pointer
,	O
(	O
boolean	int
*	O
)	O
NULL	O
)	O
)	O
{	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
if	O
(	O
qTlocal	pointer
==	O
NULL	O
)	O
{	O
DEBUG_MESSAGE0	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"floop: No work for master"	pointer
)	O
;	O
fhangup	int
=	O
TRUE	O
;	O
}	O
}	O
if	O
(	O
fhangup	int
)	O
{	O
if	O
(	O
!	O
(	O
*	O
qdaemon	pointer
->	O
qproto	pointer
->	O
pfsendcmd	pointer
)	O
(	O
qdaemon	pointer
,	O
"H"	pointer
,	O
0	int
,	O
0	int
)	O
)	O
{	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
qdaemon	pointer
->	O
fmaster	int
=	O
FALSE	O
;	O
}	O
}	O
if	O
(	O
!	O
qdaemon	pointer
->	O
fmaster	int
)	O
qdaemon	pointer
->	O
fhangup_requested	int
=	O
FALSE	O
;	O
while	O
(	O
qTremote	pointer
!=	O
NULL	O
)	O
{	O
q	pointer
=	O
qTremote	pointer
;	O
utdequeue	function
(	O
q	pointer
)	O
;	O
utqueue	function
(	O
&	O
qTsend	pointer
,	O
q	pointer
,	O
TRUE	O
)	O
;	O
}	O
if	O
(	O
qdaemon	pointer
->	O
fmaster	int
||	O
qdaemon	pointer
->	O
cchans	int
>	O
1	int
)	O
{	O
while	O
(	O
qTlocal	pointer
!=	O
NULL	O
&&	O
cTchans	int
<	O
qdaemon	pointer
->	O
cchans	int
)	O
{	O
q	pointer
=	O
qTlocal	pointer
;	O
if	O
(	O
!	O
fqueue_send	function
(	O
qdaemon	pointer
,	O
q	pointer
)	O
)	O
{	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
utchanalc	function
(	O
qdaemon	pointer
,	O
q	pointer
)	O
;	O
}	O
if	O
(	O
!	O
fret	int
)	O
break	O
;	O
}	O
q	pointer
=	O
qTsend	pointer
;	O
if	O
(	O
q	pointer
==	O
NULL	O
)	O
{	O
ulog_user	function
(	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
DEBUG_MESSAGE0	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"floop: Waiting for data"	pointer
)	O
;	O
if	O
(	O
!	O
(	O
*	O
qdaemon	pointer
->	O
qproto	pointer
->	O
pfwait	pointer
)	O
(	O
qdaemon	pointer
)	O
)	O
{	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
ulog_user	function
(	O
q	pointer
->	O
s	struct
.	O
zuser	pointer
)	O
;	O
if	O
(	O
!	O
q	pointer
->	O
fsendfile	int
)	O
{	O
if	O
(	O
!	O
(	O
*	O
q	pointer
->	O
psendfn	pointer
)	O
(	O
q	pointer
,	O
qdaemon	pointer
)	O
)	O
{	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
long	O
isecs	long
,	O
imicros	long
;	O
boolean	int
fcharged	int
;	O
long	O
cmax_time	long
;	O
long	O
istart	long
=	O
0	int
;	O
long	O
inextsecs	long
=	O
0	int
,	O
inextmicros	long
;	O
if	O
(	O
!	O
fttime	function
(	O
qdaemon	pointer
,	O
&	O
isecs	long
,	O
&	O
imicros	long
)	O
)	O
{	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
fcharged	int
=	O
FALSE	O
;	O
if	O
(	O
q	pointer
->	O
zlog	pointer
!=	O
NULL	O
)	O
{	O
ulog	function
(	O
LOG_NORMAL	int
,	O
"%s"	pointer
,	O
q	pointer
->	O
zlog	pointer
)	O
;	O
ubuffree	function
(	O
q	pointer
->	O
zlog	pointer
)	O
;	O
q	pointer
->	O
zlog	pointer
=	O
NULL	O
;	O
}	O
cmax_time	long
=	O
qdaemon	pointer
->	O
qsys	pointer
->	O
uuconf_cmax_file_time	long
;	O
if	O
(	O
qdaemon	pointer
->	O
cchans	int
<=	O
1	int
)	O
cmax_time	long
=	O
0	int
;	O
if	O
(	O
cmax_time	long
>	O
0	int
)	O
istart	long
=	O
ixsysdep_time	function
(	O
NULL	O
)	O
;	O
while	O
(	O
q	pointer
==	O
qTsend	pointer
&&	O
q	pointer
->	O
fsendfile	int
&&	O
qTremote	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
zdata	pointer
;	O
size_t	long
cdata	long
;	O
long	O
ipos	long
;	O
zdata	pointer
=	O
(	O
*	O
qdaemon	pointer
->	O
qproto	pointer
->	O
pzgetspace	pointer
)	O
(	O
qdaemon	pointer
,	O
&	O
cdata	long
)	O
;	O
if	O
(	O
zdata	pointer
==	O
NULL	O
)	O
{	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
if	O
(	O
ffileeof	O
(	O
q	pointer
->	O
e	pointer
)	O
)	O
cdata	long
=	O
0	int
;	O
else	O
{	O
cdata	long
=	O
cfileread	O
(	O
q	pointer
->	O
e	pointer
,	O
zdata	pointer
,	O
cdata	long
)	O
;	O
if	O
(	O
ffileioerror	O
(	O
q	pointer
->	O
e	pointer
,	O
cdata	long
)	O
)	O
{	O
ulog	function
(	O
LOG_ERROR	int
,	O
"read: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
}	O
ipos	long
=	O
q	pointer
->	O
ipos	long
;	O
q	pointer
->	O
ipos	long
+=	O
cdata	long
;	O
q	pointer
->	O
cbytes	long
+=	O
cdata	long
;	O
if	O
(	O
!	O
(	O
*	O
qdaemon	pointer
->	O
qproto	pointer
->	O
pfsenddata	pointer
)	O
(	O
qdaemon	pointer
,	O
zdata	pointer
,	O
cdata	long
,	O
q	pointer
->	O
ilocal	int
,	O
q	pointer
->	O
iremote	int
,	O
ipos	long
)	O
)	O
{	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
if	O
(	O
cdata	long
==	O
0	int
)	O
{	O
inextsecs	long
=	O
ixsysdep_process_time	function
(	O
&	O
inextmicros	long
)	O
;	O
DEBUG_MESSAGE4	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"floop: Charging %ld to %c %s %s"	pointer
,	O
(	O
(	O
inextsecs	long
-	O
isecs	long
)	O
*	O
1000000	int
+	O
inextmicros	long
-	O
imicros	long
)	O
,	O
q	pointer
->	O
s	struct
.	O
bcmd	char
,	O
q	pointer
->	O
s	struct
.	O
zfrom	pointer
,	O
q	pointer
->	O
s	struct
.	O
zto	pointer
)	O
;	O
q	pointer
->	O
isecs	long
+=	O
inextsecs	long
-	O
isecs	long
;	O
q	pointer
->	O
imicros	long
+=	O
inextmicros	long
-	O
imicros	long
;	O
fcharged	int
=	O
TRUE	O
;	O
q	pointer
->	O
fsendfile	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
(	O
*	O
q	pointer
->	O
psendfn	pointer
)	O
(	O
q	pointer
,	O
qdaemon	pointer
)	O
)	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
if	O
(	O
cmax_time	long
>	O
0	int
&&	O
q	pointer
->	O
qnext	pointer
!=	O
q	pointer
&&	O
ixsysdep_time	function
(	O
NULL	O
)	O
-	O
istart	long
>=	O
cmax_time	long
)	O
{	O
DEBUG_MESSAGE0	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"floop: Switch file"	pointer
)	O
;	O
utdequeue	function
(	O
q	pointer
)	O
;	O
utqueue	function
(	O
&	O
qTsend	pointer
,	O
q	pointer
,	O
FALSE	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
fret	int
)	O
break	O
;	O
if	O
(	O
!	O
fcharged	int
)	O
{	O
inextsecs	long
=	O
ixsysdep_process_time	function
(	O
&	O
inextmicros	long
)	O
;	O
DEBUG_MESSAGE4	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"floop: Charging %ld to %c %s %s"	pointer
,	O
(	O
(	O
inextsecs	long
-	O
isecs	long
)	O
*	O
1000000	int
+	O
inextmicros	long
-	O
imicros	long
)	O
,	O
q	pointer
->	O
s	struct
.	O
bcmd	char
,	O
q	pointer
->	O
s	struct
.	O
zfrom	pointer
,	O
q	pointer
->	O
s	struct
.	O
zto	pointer
)	O
;	O
q	pointer
->	O
isecs	long
+=	O
inextsecs	long
-	O
isecs	long
;	O
q	pointer
->	O
imicros	long
+=	O
inextmicros	long
-	O
imicros	long
;	O
}	O
if	O
(	O
inextsecs	long
-	O
iTchecktime	long
>=	O
CCHECKWAIT	O
)	O
{	O
if	O
(	O
!	O
fcheck_queue	function
(	O
qdaemon	pointer
)	O
)	O
{	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
}	O
}	O
}	O
}	O
ulog_user	function
(	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
(	O
void	O
)	O
(	O
*	O
qdaemon	pointer
->	O
qproto	pointer
->	O
pfshutdown	pointer
)	O
(	O
qdaemon	pointer
)	O
;	O
if	O
(	O
fret	int
)	O
uwindow_acked	function
(	O
qdaemon	pointer
,	O
TRUE	O
)	O
;	O
else	O
ufailed	function
(	O
qdaemon	pointer
)	O
;	O
return	O
fret	int
;	O
}	O
boolean	int
fgot_data	function
(	O
qdaemon	pointer
,	O
zfirst	pointer
,	O
cfirst	long
,	O
zsecond	pointer
,	O
csecond	long
,	O
ilocal	int
,	O
iremote	int
,	O
ipos	long
,	O
fallacked	int
,	O
pfexit	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
const	O
char	O
*	O
zfirst	pointer
;	O
size_t	long
cfirst	long
;	O
const	O
char	O
*	O
zsecond	pointer
;	O
size_t	long
csecond	long
;	O
int	O
ilocal	int
;	O
int	O
iremote	int
;	O
long	O
ipos	long
;	O
boolean	int
fallacked	int
;	O
boolean	int
*	O
pfexit	pointer
;	O
{	O
struct	O
stransfer	struct
*	O
q	pointer
;	O
int	O
cwrote	int
;	O
boolean	int
fret	int
;	O
long	O
isecs	long
,	O
imicros	long
;	O
if	O
(	O
fallacked	int
&&	O
qTreceive_ack	pointer
!=	O
NULL	O
)	O
uwindow_acked	function
(	O
qdaemon	pointer
,	O
TRUE	O
)	O
;	O
if	O
(	O
ilocal	int
==	O
-	O
1	int
&&	O
qTreceive	pointer
!=	O
NULL	O
)	O
q	pointer
=	O
qTreceive	pointer
;	O
else	O
if	O
(	O
ilocal	int
==	O
0	int
&&	O
iremote	int
>	O
0	int
&&	O
aqTremote	array
[	O
iremote	int
]	O
!=	O
NULL	O
)	O
q	pointer
=	O
aqTremote	array
[	O
iremote	int
]	O
;	O
else	O
if	O
(	O
ilocal	int
<=	O
0	int
)	O
{	O
const	O
char	O
*	O
znull	pointer
;	O
ulog_user	function
(	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
znull	pointer
=	O
(	O
const	O
char	O
*	O
)	O
memchr	function
(	O
zfirst	pointer
,	O
'\0'	O
,	O
cfirst	long
)	O
;	O
if	O
(	O
znull	pointer
!=	O
NULL	O
)	O
fret	int
=	O
ftadd_cmd	function
(	O
qdaemon	pointer
,	O
zfirst	pointer
,	O
(	O
size_t	long
)	O
(	O
znull	pointer
-	O
zfirst	pointer
)	O
,	O
iremote	int
,	O
TRUE	O
)	O
;	O
else	O
{	O
fret	int
=	O
ftadd_cmd	function
(	O
qdaemon	pointer
,	O
zfirst	pointer
,	O
cfirst	long
,	O
iremote	int
,	O
FALSE	O
)	O
;	O
if	O
(	O
fret	int
&&	O
csecond	long
>	O
0	int
)	O
{	O
znull	pointer
=	O
(	O
const	O
char	O
*	O
)	O
memchr	function
(	O
zsecond	pointer
,	O
'\0'	O
,	O
csecond	long
)	O
;	O
if	O
(	O
znull	pointer
!=	O
NULL	O
)	O
fret	int
=	O
ftadd_cmd	function
(	O
qdaemon	pointer
,	O
zsecond	pointer
,	O
(	O
size_t	long
)	O
(	O
znull	pointer
-	O
zsecond	pointer
)	O
,	O
iremote	int
,	O
TRUE	O
)	O
;	O
else	O
fret	int
=	O
ftadd_cmd	function
(	O
qdaemon	pointer
,	O
zsecond	pointer
,	O
csecond	long
,	O
iremote	int
,	O
FALSE	O
)	O
;	O
}	O
}	O
if	O
(	O
pfexit	pointer
!=	O
NULL	O
&&	O
(	O
qdaemon	pointer
->	O
fhangup	int
||	O
qTremote	pointer
!=	O
NULL	O
)	O
)	O
*	O
pfexit	pointer
=	O
TRUE	O
;	O
if	O
(	O
!	O
fttime	function
(	O
qdaemon	pointer
,	O
&	O
iTrecsecs	long
,	O
&	O
iTrecmicros	long
)	O
)	O
fret	int
=	O
FALSE	O
;	O
return	O
fret	int
;	O
}	O
else	O
{	O
q	pointer
=	O
qtchan	function
(	O
ilocal	int
)	O
;	O
}	O
if	O
(	O
q	pointer
==	O
NULL	O
||	O
q	pointer
->	O
precfn	pointer
==	O
NULL	O
)	O
{	O
ulog	function
(	O
LOG_ERROR	int
,	O
"Protocol error: %lu bytes remote %d local %d"	pointer
,	O
(	O
unsigned	O
long	O
)	O
(	O
cfirst	long
+	O
csecond	long
)	O
,	O
iremote	int
,	O
ilocal	int
)	O
;	O
return	O
FALSE	O
;	O
}	O
ulog_user	function
(	O
q	pointer
->	O
s	struct
.	O
zuser	pointer
)	O
;	O
fret	int
=	O
TRUE	O
;	O
if	O
(	O
q	pointer
->	O
zlog	pointer
!=	O
NULL	O
&&	O
!	O
q	pointer
->	O
fsendfile	int
)	O
{	O
ulog	function
(	O
LOG_NORMAL	int
,	O
"%s"	pointer
,	O
q	pointer
->	O
zlog	pointer
)	O
;	O
ubuffree	function
(	O
q	pointer
->	O
zlog	pointer
)	O
;	O
q	pointer
->	O
zlog	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
cfirst	long
==	O
0	int
||	O
q	pointer
->	O
fcmd	int
||	O
!	O
q	pointer
->	O
frecfile	int
||	O
q	pointer
!=	O
qTtiming_rec	pointer
)	O
{	O
struct	O
stransfer	struct
*	O
qcharge	pointer
;	O
if	O
(	O
!	O
fttime	function
(	O
qdaemon	pointer
,	O
&	O
isecs	long
,	O
&	O
imicros	long
)	O
)	O
fret	int
=	O
FALSE	O
;	O
if	O
(	O
qTtiming_rec	pointer
!=	O
NULL	O
)	O
qcharge	pointer
=	O
qTtiming_rec	pointer
;	O
else	O
if	O
(	O
qTsend	pointer
!=	O
NULL	O
)	O
qcharge	pointer
=	O
NULL	O
;	O
else	O
qcharge	pointer
=	O
q	pointer
;	O
if	O
(	O
qcharge	pointer
!=	O
NULL	O
)	O
{	O
DEBUG_MESSAGE4	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"fgot_data: Charging %ld to %c %s %s"	pointer
,	O
(	O
(	O
isecs	long
-	O
iTrecsecs	long
)	O
*	O
1000000	int
+	O
imicros	long
-	O
iTrecmicros	long
)	O
,	O
qcharge	pointer
->	O
s	struct
.	O
bcmd	char
,	O
qcharge	pointer
->	O
s	struct
.	O
zfrom	pointer
,	O
qcharge	pointer
->	O
s	struct
.	O
zto	pointer
)	O
;	O
qcharge	pointer
->	O
isecs	long
+=	O
isecs	long
-	O
iTrecsecs	long
;	O
qcharge	pointer
->	O
imicros	long
+=	O
imicros	long
-	O
iTrecmicros	long
;	O
}	O
iTrecsecs	long
=	O
isecs	long
;	O
iTrecmicros	long
=	O
imicros	long
;	O
if	O
(	O
cfirst	long
==	O
0	int
||	O
q	pointer
->	O
fcmd	int
||	O
!	O
q	pointer
->	O
frecfile	int
)	O
qTtiming_rec	pointer
=	O
NULL	O
;	O
else	O
qTtiming_rec	pointer
=	O
q	pointer
;	O
}	O
if	O
(	O
q	pointer
->	O
fcmd	int
)	O
{	O
const	O
char	O
*	O
znull	pointer
;	O
znull	pointer
=	O
NULL	O
;	O
while	O
(	O
cfirst	long
>	O
0	int
)	O
{	O
size_t	long
cnew	long
;	O
char	O
*	O
znew	pointer
;	O
znull	pointer
=	O
(	O
const	O
char	O
*	O
)	O
memchr	function
(	O
zfirst	pointer
,	O
'\0'	O
,	O
cfirst	long
)	O
;	O
if	O
(	O
znull	pointer
!=	O
NULL	O
)	O
cnew	long
=	O
znull	pointer
-	O
zfirst	pointer
;	O
else	O
cnew	long
=	O
cfirst	long
;	O
znew	pointer
=	O
zbufalc	function
(	O
q	pointer
->	O
ccmd	long
+	O
cnew	long
+	O
1	int
)	O
;	O
if	O
(	O
q	pointer
->	O
ccmd	long
>	O
0	int
)	O
memcpy	function
(	O
znew	pointer
,	O
q	pointer
->	O
zcmd	pointer
,	O
q	pointer
->	O
ccmd	long
)	O
;	O
memcpy	function
(	O
znew	pointer
+	O
q	pointer
->	O
ccmd	long
,	O
zfirst	pointer
,	O
cnew	long
)	O
;	O
znew	pointer
[	O
q	pointer
->	O
ccmd	long
+	O
cnew	long
]	O
=	O
'\0'	O
;	O
ubuffree	function
(	O
q	pointer
->	O
zcmd	pointer
)	O
;	O
q	pointer
->	O
zcmd	pointer
=	O
znew	pointer
;	O
q	pointer
->	O
ccmd	long
+=	O
cnew	long
;	O
if	O
(	O
znull	pointer
!=	O
NULL	O
)	O
break	O
;	O
zfirst	pointer
=	O
zsecond	pointer
;	O
cfirst	long
=	O
csecond	long
;	O
csecond	long
=	O
0	int
;	O
}	O
if	O
(	O
znull	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
zcmd	pointer
;	O
size_t	long
ccmd	long
;	O
zcmd	pointer
=	O
q	pointer
->	O
zcmd	pointer
;	O
ccmd	long
=	O
q	pointer
->	O
ccmd	long
;	O
q	pointer
->	O
fcmd	int
=	O
FALSE	O
;	O
q	pointer
->	O
zcmd	pointer
=	O
NULL	O
;	O
q	pointer
->	O
ccmd	long
=	O
0	int
;	O
if	O
(	O
!	O
(	O
*	O
q	pointer
->	O
precfn	pointer
)	O
(	O
q	pointer
,	O
qdaemon	pointer
,	O
zcmd	pointer
,	O
ccmd	long
+	O
1	int
)	O
)	O
fret	int
=	O
FALSE	O
;	O
ubuffree	function
(	O
zcmd	pointer
)	O
;	O
}	O
if	O
(	O
pfexit	pointer
!=	O
NULL	O
&&	O
(	O
qdaemon	pointer
->	O
fhangup	int
||	O
qdaemon	pointer
->	O
fmaster	int
||	O
qTsend	pointer
!=	O
NULL	O
)	O
)	O
*	O
pfexit	pointer
=	O
TRUE	O
;	O
}	O
else	O
if	O
(	O
!	O
q	pointer
->	O
frecfile	int
||	O
cfirst	long
==	O
0	int
)	O
{	O
q	pointer
->	O
frecfile	int
=	O
FALSE	O
;	O
if	O
(	O
!	O
(	O
*	O
q	pointer
->	O
precfn	pointer
)	O
(	O
q	pointer
,	O
qdaemon	pointer
,	O
zfirst	pointer
,	O
cfirst	long
)	O
)	O
fret	int
=	O
FALSE	O
;	O
if	O
(	O
fret	int
&&	O
csecond	long
>	O
0	int
)	O
return	O
fgot_data	function
(	O
qdaemon	pointer
,	O
zsecond	pointer
,	O
csecond	long
,	O
(	O
const	O
char	O
*	O
)	O
NULL	O
,	O
(	O
size_t	long
)	O
0	int
,	O
ilocal	int
,	O
iremote	int
,	O
ipos	long
+	O
(	O
long	O
)	O
cfirst	long
,	O
FALSE	O
,	O
pfexit	pointer
)	O
;	O
if	O
(	O
pfexit	pointer
!=	O
NULL	O
&&	O
(	O
qdaemon	pointer
->	O
fhangup	int
||	O
qdaemon	pointer
->	O
fmaster	int
||	O
qTsend	pointer
!=	O
NULL	O
)	O
)	O
*	O
pfexit	pointer
=	O
TRUE	O
;	O
}	O
else	O
{	O
if	O
(	O
ipos	long
!=	O
-	O
1	int
&&	O
ipos	long
!=	O
q	pointer
->	O
ipos	long
)	O
{	O
DEBUG_MESSAGE1	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"fgot_data: Seeking to %ld"	pointer
,	O
ipos	long
)	O
;	O
if	O
(	O
!	O
ffileseek	O
(	O
q	pointer
->	O
e	pointer
,	O
ipos	long
)	O
)	O
{	O
ulog	function
(	O
LOG_ERROR	int
,	O
"seek: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
fret	int
=	O
FALSE	O
;	O
}	O
q	pointer
->	O
ipos	long
=	O
ipos	long
;	O
}	O
if	O
(	O
fret	int
)	O
{	O
while	O
(	O
cfirst	long
>	O
0	int
)	O
{	O
cwrote	int
=	O
cfilewrite	O
(	O
q	pointer
->	O
e	pointer
,	O
(	O
char	O
*	O
)	O
zfirst	pointer
,	O
cfirst	long
)	O
;	O
if	O
(	O
cwrote	int
>=	O
0	int
&&	O
(	O
size_t	long
)	O
cwrote	int
==	O
cfirst	long
)	O
{	O
long	O
cfree_space	long
;	O
cfree_space	long
=	O
qdaemon	pointer
->	O
qsys	pointer
->	O
uuconf_cfree_space	long
;	O
if	O
(	O
cfree_space	long
>	O
0	int
&&	O
(	O
(	O
size_t	long
)	O
(	O
q	pointer
->	O
cbytes	long
/	O
FREE_SPACE_DELTA	O
)	O
!=	O
(	O
q	pointer
->	O
cbytes	long
+	O
cfirst	long
)	O
/	O
FREE_SPACE_DELTA	O
)	O
&&	O
!	O
frec_check_free	function
(	O
q	pointer
,	O
cfree_space	long
)	O
)	O
{	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
q	pointer
->	O
cbytes	long
+=	O
cfirst	long
;	O
q	pointer
->	O
ipos	long
+=	O
cfirst	long
;	O
}	O
else	O
{	O
if	O
(	O
ffileioerror	O
(	O
q	pointer
->	O
e	pointer
,	O
cwrote	int
)	O
)	O
ulog	function
(	O
LOG_ERROR	int
,	O
"write: %s"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
else	O
ulog	function
(	O
LOG_ERROR	int
,	O
"Wrote %d to file when trying to write %lu"	pointer
,	O
cwrote	int
,	O
(	O
unsigned	O
long	O
)	O
cfirst	long
)	O
;	O
fret	int
=	O
FALSE	O
;	O
break	O
;	O
}	O
zfirst	pointer
=	O
zsecond	pointer
;	O
cfirst	long
=	O
csecond	long
;	O
csecond	long
=	O
0	int
;	O
}	O
}	O
if	O
(	O
pfexit	pointer
!=	O
NULL	O
&&	O
qdaemon	pointer
->	O
fhangup	int
)	O
*	O
pfexit	pointer
=	O
TRUE	O
;	O
}	O
return	O
fret	int
;	O
}	O
static	O
boolean	int
ftadd_cmd	function
(	O
qdaemon	pointer
,	O
z	pointer
,	O
clen	long
,	O
iremote	int
,	O
flast	int
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
const	O
char	O
*	O
z	pointer
;	O
size_t	long
clen	long
;	O
int	O
iremote	int
;	O
boolean	int
flast	int
;	O
{	O
static	O
char	O
*	O
zbuf	pointer
;	O
static	O
size_t	long
cbuf	long
;	O
size_t	long
cneed	long
;	O
struct	O
scmd	struct
s	struct
;	O
cneed	long
=	O
cTcmdlen	long
+	O
clen	long
+	O
1	int
;	O
if	O
(	O
cneed	long
>	O
cbuf	long
)	O
{	O
zbuf	pointer
=	O
(	O
char	O
*	O
)	O
xrealloc	function
(	O
(	O
pointer	pointer
)	O
zbuf	pointer
,	O
cneed	long
)	O
;	O
cbuf	long
=	O
cneed	long
;	O
}	O
memcpy	function
(	O
zbuf	pointer
+	O
cTcmdlen	long
,	O
z	pointer
,	O
clen	long
)	O
;	O
zbuf	pointer
[	O
cTcmdlen	long
+	O
clen	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
!	O
flast	int
)	O
{	O
cTcmdlen	long
+=	O
clen	long
;	O
return	O
TRUE	O
;	O
}	O
cTcmdlen	long
=	O
0	int
;	O
DEBUG_MESSAGE1	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"ftadd_cmd: Got command \"%s\""	pointer
,	O
zbuf	pointer
)	O
;	O
if	O
(	O
!	O
fparse_cmd	function
(	O
zbuf	pointer
,	O
&	O
s	struct
)	O
||	O
s	struct
.	O
bcmd	char
==	O
'P'	O
)	O
{	O
ulog	function
(	O
LOG_ERROR	int
,	O
"Received garbled command \"%s\""	pointer
,	O
zbuf	pointer
)	O
;	O
return	O
TRUE	O
;	O
}	O
if	O
(	O
(	O
qdaemon	pointer
->	O
ifeatures	int
&	O
FEATURE_SIZES	O
)	O
==	O
0	int
)	O
s	struct
.	O
cbytes	long
=	O
-	O
1	int
;	O
if	O
(	O
s	struct
.	O
bcmd	char
!=	O
'H'	O
&&	O
s	struct
.	O
bcmd	char
!=	O
'Y'	O
&&	O
s	struct
.	O
bcmd	char
!=	O
'N'	O
)	O
ulog_user	function
(	O
s	struct
.	O
zuser	pointer
)	O
;	O
else	O
ulog_user	function
(	O
(	O
const	O
char	O
*	O
)	O
NULL	O
)	O
;	O
switch	O
(	O
s	struct
.	O
bcmd	char
)	O
{	O
case	O
'S'	O
:	O
case	O
'E'	O
:	O
return	O
fremote_send_file_init	function
(	O
qdaemon	pointer
,	O
&	O
s	struct
,	O
iremote	int
)	O
;	O
case	O
'R'	O
:	O
return	O
fremote_rec_file_init	function
(	O
qdaemon	pointer
,	O
&	O
s	struct
,	O
iremote	int
)	O
;	O
case	O
'X'	O
:	O
return	O
fremote_xcmd_init	function
(	O
qdaemon	pointer
,	O
&	O
s	struct
,	O
iremote	int
)	O
;	O
case	O
'H'	O
:	O
ulog_close	function
(	O
)	O
;	O
ustats_close	function
(	O
)	O
;	O
{	O
struct	O
stransfer	struct
*	O
q	pointer
;	O
q	pointer
=	O
qtransalc	function
(	O
(	O
struct	O
scmd	struct
*	O
)	O
NULL	O
)	O
;	O
q	pointer
->	O
psendfn	pointer
=	O
fremote_hangup_reply	function
;	O
q	pointer
->	O
iremote	int
=	O
iremote	int
;	O
q	pointer
->	O
s	struct
.	O
bcmd	char
=	O
'H'	O
;	O
return	O
fqueue_remote	function
(	O
qdaemon	pointer
,	O
q	pointer
)	O
;	O
}	O
case	O
'N'	O
:	O
return	O
TRUE	O
;	O
case	O
'Y'	O
:	O
if	O
(	O
qdaemon	pointer
->	O
fhangup	int
)	O
return	O
TRUE	O
;	O
if	O
(	O
qdaemon	pointer
->	O
fmaster	int
)	O
ulog	function
(	O
LOG_ERROR	int
,	O
"Got hangup reply as master"	pointer
)	O
;	O
fLog_sighup	int
=	O
FALSE	O
;	O
(	O
void	O
)	O
(	O
*	O
qdaemon	pointer
->	O
qproto	pointer
->	O
pfsendcmd	pointer
)	O
(	O
qdaemon	pointer
,	O
"HY"	pointer
,	O
0	int
,	O
iremote	int
)	O
;	O
qdaemon	pointer
->	O
fhangup	int
=	O
TRUE	O
;	O
return	O
TRUE	O
;	O
default	O
:	O
ulog	function
(	O
LOG_FATAL	int
,	O
"ftadd_cmd: Can't happen"	pointer
)	O
;	O
return	O
FALSE	O
;	O
}	O
}	O
static	O
boolean	int
fremote_hangup_reply	function
(	O
qtrans	pointer
,	O
qdaemon	pointer
)	O
struct	O
stransfer	struct
*	O
qtrans	pointer
;	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
{	O
boolean	int
fret	int
;	O
utransfree	function
(	O
qtrans	pointer
)	O
;	O
if	O
(	O
qTremote	pointer
==	O
NULL	O
&&	O
qTlocal	pointer
==	O
NULL	O
&&	O
qTsend	pointer
==	O
NULL	O
&&	O
qTreceive	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
!	O
fqueue	function
(	O
qdaemon	pointer
,	O
(	O
boolean	int
*	O
)	O
NULL	O
)	O
)	O
return	O
FALSE	O
;	O
if	O
(	O
qTlocal	pointer
==	O
NULL	O
)	O
{	O
DEBUG_MESSAGE0	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"fremote_hangup_reply: No work"	pointer
)	O
;	O
fret	int
=	O
(	O
(	O
*	O
qdaemon	pointer
->	O
qproto	pointer
->	O
pfsendcmd	pointer
)	O
(	O
qdaemon	pointer
,	O
"HY"	pointer
,	O
0	int
,	O
0	int
)	O
&&	O
(	O
*	O
qdaemon	pointer
->	O
qproto	pointer
->	O
pfsendcmd	pointer
)	O
(	O
qdaemon	pointer
,	O
"HY"	pointer
,	O
0	int
,	O
0	int
)	O
)	O
;	O
qdaemon	pointer
->	O
fhangup	int
=	O
TRUE	O
;	O
return	O
fret	int
;	O
}	O
}	O
DEBUG_MESSAGE0	O
(	O
DEBUG_UUCP_PROTO	O
,	O
"fremote_hangup_reply: Found work"	pointer
)	O
;	O
fret	int
=	O
(	O
*	O
qdaemon	pointer
->	O
qproto	pointer
->	O
pfsendcmd	pointer
)	O
(	O
qdaemon	pointer
,	O
"HN"	pointer
,	O
0	int
,	O
0	int
)	O
;	O
qdaemon	pointer
->	O
fmaster	int
=	O
TRUE	O
;	O
return	O
fret	int
;	O
}	O
static	O
struct	O
sreceive_ack	struct
*	O
qTfree_receive_ack	pointer
;	O
void	O
usent_receive_ack	function
(	O
qdaemon	pointer
,	O
qtrans	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
ATTRIBUTE_UNUSED	O
;	O
struct	O
stransfer	struct
*	O
qtrans	pointer
;	O
{	O
struct	O
sreceive_ack	struct
*	O
q	pointer
;	O
if	O
(	O
qTfree_receive_ack	pointer
==	O
NULL	O
)	O
q	pointer
=	O
(	O
struct	O
sreceive_ack	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
sreceive_ack	struct
)	O
)	O
;	O
else	O
{	O
q	pointer
=	O
qTfree_receive_ack	pointer
;	O
qTfree_receive_ack	pointer
=	O
q	pointer
->	O
qnext	pointer
;	O
}	O
q	pointer
->	O
qnext	pointer
=	O
qTreceive_ack	pointer
;	O
q	pointer
->	O
zto	pointer
=	O
zbufcpy	function
(	O
qtrans	pointer
->	O
s	struct
.	O
zto	pointer
)	O
;	O
q	pointer
->	O
ztemp	pointer
=	O
zbufcpy	function
(	O
qtrans	pointer
->	O
s	struct
.	O
ztemp	pointer
)	O
;	O
q	pointer
->	O
fmarked	int
=	O
FALSE	O
;	O
qTreceive_ack	pointer
=	O
q	pointer
;	O
}	O
static	O
void	O
utfree_receive_ack	function
(	O
q	pointer
)	O
struct	O
sreceive_ack	struct
*	O
q	pointer
;	O
{	O
ubuffree	function
(	O
q	pointer
->	O
zto	pointer
)	O
;	O
ubuffree	function
(	O
q	pointer
->	O
ztemp	pointer
)	O
;	O
q	pointer
->	O
qnext	pointer
=	O
qTfree_receive_ack	pointer
;	O
qTfree_receive_ack	pointer
=	O
q	pointer
;	O
}	O
void	O
uwindow_acked	function
(	O
qdaemon	pointer
,	O
fallacked	int
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
boolean	int
fallacked	int
;	O
{	O
register	O
struct	O
sreceive_ack	struct
*	O
*	O
pq	pointer
;	O
pq	pointer
=	O
&	O
qTreceive_ack	pointer
;	O
while	O
(	O
*	O
pq	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
fallacked	int
||	O
(	O
*	O
pq	pointer
)	O
->	O
fmarked	int
)	O
{	O
struct	O
sreceive_ack	struct
*	O
q	pointer
;	O
q	pointer
=	O
*	O
pq	pointer
;	O
(	O
void	O
)	O
fsysdep_forget_reception	function
(	O
qdaemon	pointer
->	O
qsys	pointer
,	O
q	pointer
->	O
zto	pointer
,	O
q	pointer
->	O
ztemp	pointer
)	O
;	O
*	O
pq	pointer
=	O
q	pointer
->	O
qnext	pointer
;	O
utfree_receive_ack	function
(	O
q	pointer
)	O
;	O
}	O
else	O
{	O
(	O
*	O
pq	pointer
)	O
->	O
fmarked	int
=	O
TRUE	O
;	O
pq	pointer
=	O
&	O
(	O
*	O
pq	pointer
)	O
->	O
qnext	pointer
;	O
}	O
}	O
}	O
static	O
void	O
utfree_acked	function
(	O
)	O
{	O
struct	O
sreceive_ack	struct
*	O
q	pointer
;	O
q	pointer
=	O
qTreceive_ack	pointer
;	O
while	O
(	O
q	pointer
!=	O
NULL	O
)	O
{	O
struct	O
sreceive_ack	struct
*	O
qnext	pointer
;	O
qnext	pointer
=	O
q	pointer
->	O
qnext	pointer
;	O
utfree_receive_ack	function
(	O
q	pointer
)	O
;	O
q	pointer
=	O
qnext	pointer
;	O
}	O
qTreceive_ack	pointer
=	O
NULL	O
;	O
}	O
void	O
ufailed	function
(	O
qdaemon	pointer
)	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
;	O
{	O
register	O
struct	O
stransfer	struct
*	O
q	pointer
;	O
if	O
(	O
qTsend	pointer
!=	O
NULL	O
)	O
{	O
q	pointer
=	O
qTsend	pointer
;	O
do	O
{	O
if	O
(	O
(	O
q	pointer
->	O
fsendfile	int
||	O
q	pointer
->	O
frecfile	int
)	O
&&	O
q	pointer
->	O
cbytes	long
>	O
0	int
)	O
{	O
ustats	function
(	O
FALSE	O
,	O
q	pointer
->	O
s	struct
.	O
zuser	pointer
,	O
qdaemon	pointer
->	O
qsys	pointer
->	O
uuconf_zname	pointer
,	O
q	pointer
->	O
fsendfile	int
,	O
q	pointer
->	O
cbytes	long
,	O
q	pointer
->	O
isecs	long
,	O
q	pointer
->	O
imicros	long
,	O
qdaemon	pointer
->	O
fcaller	int
)	O
;	O
if	O
(	O
q	pointer
->	O
fsendfile	int
)	O
qdaemon	pointer
->	O
csent	long
+=	O
q	pointer
->	O
cbytes	long
;	O
else	O
qdaemon	pointer
->	O
creceived	long
+=	O
q	pointer
->	O
cbytes	long
;	O
}	O
if	O
(	O
q	pointer
->	O
frecfile	int
)	O
(	O
void	O
)	O
frec_discard_temp	function
(	O
qdaemon	pointer
,	O
q	pointer
)	O
;	O
q	pointer
=	O
q	pointer
->	O
qnext	pointer
;	O
}	O
while	O
(	O
q	pointer
!=	O
qTsend	pointer
)	O
;	O
}	O
if	O
(	O
qTreceive	pointer
!=	O
NULL	O
)	O
{	O
q	pointer
=	O
qTreceive	pointer
;	O
do	O
{	O
if	O
(	O
(	O
q	pointer
->	O
fsendfile	int
||	O
q	pointer
->	O
frecfile	int
)	O
&&	O
q	pointer
->	O
cbytes	long
>	O
0	int
)	O
{	O
ustats	function
(	O
FALSE	O
,	O
q	pointer
->	O
s	struct
.	O
zuser	pointer
,	O
qdaemon	pointer
->	O
qsys	pointer
->	O
uuconf_zname	pointer
,	O
q	pointer
->	O
fsendfile	int
,	O
q	pointer
->	O
cbytes	long
,	O
q	pointer
->	O
isecs	long
,	O
q	pointer
->	O
imicros	long
,	O
qdaemon	pointer
->	O
fcaller	int
)	O
;	O
if	O
(	O
q	pointer
->	O
fsendfile	int
)	O
qdaemon	pointer
->	O
csent	long
+=	O
q	pointer
->	O
cbytes	long
;	O
else	O
qdaemon	pointer
->	O
creceived	long
+=	O
q	pointer
->	O
cbytes	long
;	O
}	O
if	O
(	O
q	pointer
->	O
frecfile	int
)	O
(	O
void	O
)	O
frec_discard_temp	function
(	O
qdaemon	pointer
,	O
q	pointer
)	O
;	O
q	pointer
=	O
q	pointer
->	O
qnext	pointer
;	O
}	O
while	O
(	O
q	pointer
!=	O
qTreceive	pointer
)	O
;	O
}	O
}	O
static	O
boolean	int
flocal_poll_file	function
(	O
qtrans	pointer
,	O
qdaemon	pointer
)	O
struct	O
stransfer	struct
*	O
qtrans	pointer
;	O
struct	O
sdaemon	struct
*	O
qdaemon	pointer
ATTRIBUTE_UNUSED	O
;	O
{	O
boolean	int
fret	int
;	O
fret	int
=	O
fsysdep_did_work	function
(	O
qtrans	pointer
->	O
s	struct
.	O
pseq	pointer
)	O
;	O
utransfree	function
(	O
qtrans	pointer
)	O
;	O
return	O
fret	int
;	O
}	O
