static	O
void	O
mark_c_stack	function
(	O
jmp_buf	O
,	O
int	O
,	O
void	O
(	O
*	O
)	O
(	O
void	O
*	O
,	O
void	O
*	O
,	O
int	O
)	O
)	O
;	O
static	O
void	O
mark_contblock	function
(	O
void	O
*	O
,	O
int	O
)	O
;	O
static	O
void	O
mark_object	function
(	O
object	O
)	O
;	O
inline	O
struct	O
pageinfo	O
*	O
get_pageinfo	function
(	O
void	O
*	O
x	pointer
)	O
{	O
struct	O
pageinfo	O
*	O
v	pointer
=	O
contblock_list_head	O
;	O
void	O
*	O
vv	pointer
;	O
for	O
(	O
;	O
(	O
vv	pointer
=	O
v	pointer
)	O
&&	O
(	O
vv	pointer
>=	O
x	pointer
||	O
vv	pointer
+	O
v	pointer
->	O
in_use	O
*	O
PAGESIZE	O
<=	O
x	pointer
)	O
;	O
v	pointer
=	O
v	pointer
->	O
next	O
)	O
;	O
return	O
v	pointer
;	O
}	O
inline	O
char	O
get_bit	function
(	O
char	O
*	O
v	pointer
,	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x	pointer
)	O
{	O
void	O
*	O
ve	pointer
=	O
CB_DATA_START	function
(	O
pi	pointer
)	O
;	O
fixnum	O
off	O
=	O
(	O
x	pointer
-	O
ve	pointer
)	O
>>	O
LOG_BYTES_CONTBLOCK	O
,	O
i	int
=	O
off	O
>>	O
LOG_BITS_CHAR	int
,	O
s	int
=	O
off	O
&	O
~	O
(	O
~	O
0UL	int
<<	O
LOG_BITS_CHAR	int
)	O
;	O
return	O
(	O
v	pointer
[	O
i	int
]	O
>>	O
s	int
)	O
&	O
0x1	int
;	O
}	O
inline	O
void	O
set_bit	function
(	O
char	O
*	O
v	pointer
,	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x	pointer
)	O
{	O
void	O
*	O
ve	pointer
=	O
CB_DATA_START	function
(	O
pi	pointer
)	O
;	O
fixnum	O
off	O
=	O
(	O
x	pointer
-	O
ve	pointer
)	O
>>	O
LOG_BYTES_CONTBLOCK	O
,	O
i	int
=	O
off	O
>>	O
LOG_BITS_CHAR	int
,	O
s	int
=	O
off	O
&	O
~	O
(	O
~	O
0UL	int
<<	O
LOG_BITS_CHAR	int
)	O
;	O
v	pointer
[	O
i	int
]	O
|=	O
(	O
1UL	int
<<	O
s	int
)	O
;	O
}	O
inline	O
void	O
set_bits	function
(	O
char	O
*	O
v	pointer
,	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x1	pointer
,	O
void	O
*	O
x2	pointer
)	O
{	O
void	O
*	O
ds	pointer
=	O
CB_DATA_START	function
(	O
pi	pointer
)	O
;	O
fixnum	O
i1	O
,	O
s1	O
,	O
i2	O
,	O
s2	O
,	O
se	O
;	O
ptr_set	O
(	O
x1	pointer
,	O
ds	pointer
,	O
i1	O
,	O
s1	O
)	O
;	O
ptr_set	O
(	O
x2	pointer
,	O
ds	pointer
,	O
i2	O
,	O
s2	O
)	O
;	O
if	O
(	O
i1	O
==	O
i2	O
)	O
{	O
se	O
=	O
s2	O
;	O
s2	O
=	O
0	int
;	O
}	O
else	O
se	O
=	O
CHAR_SIZE	O
;	O
for	O
(	O
;	O
s1	O
<	O
se	O
;	O
s1	O
++	O
)	O
bit_set	O
(	O
v	pointer
,	O
i1	O
,	O
s1	O
)	O
;	O
if	O
(	O
i2	O
>	O
++	O
i1	O
)	O
memset	function
(	O
v	pointer
+	O
i1	O
,	O
-	O
1	int
,	O
(	O
i2	O
-	O
i1	O
)	O
)	O
;	O
for	O
(	O
;	O
--	O
s2	O
>=	O
0	int
;	O
)	O
bit_set	O
(	O
v	pointer
,	O
i2	O
,	O
s2	O
)	O
;	O
}	O
inline	O
void	O
*	O
get_bits	function
(	O
char	O
*	O
v	pointer
,	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x	pointer
)	O
{	O
void	O
*	O
ds	pointer
=	O
CB_DATA_START	function
(	O
pi	pointer
)	O
,	O
*	O
de	pointer
=	O
CB_DATA_END	function
(	O
pi	pointer
)	O
;	O
fixnum	O
i	int
,	O
s	int
,	O
ie	O
=	O
mbytes	O
(	O
pi	pointer
->	O
in_use	O
)	O
;	O
bool	O
z	O
;	O
char	O
cz	char
;	O
ptr_set	O
(	O
x	pointer
,	O
ds	pointer
,	O
i	int
,	O
s	int
)	O
;	O
z	O
=	O
bit_get	O
(	O
v	pointer
,	O
i	int
,	O
s	int
)	O
;	O
cz	char
=	O
z	O
?	O
-	O
1	int
:	O
0	int
;	O
for	O
(	O
;	O
++	O
s	int
<	O
CHAR_SIZE	O
&&	O
z	O
==	O
bit_get	O
(	O
v	pointer
,	O
i	int
,	O
s	int
)	O
;	O
)	O
;	O
if	O
(	O
s	int
==	O
CHAR_SIZE	O
)	O
{	O
for	O
(	O
;	O
++	O
i	int
<	O
ie	O
&&	O
v	pointer
[	O
i	int
]	O
==	O
cz	char
;	O
)	O
;	O
if	O
(	O
i	int
<	O
ie	O
)	O
for	O
(	O
s	int
=	O
-	O
1	int
;	O
++	O
s	int
<	O
CHAR_SIZE	O
&&	O
z	O
==	O
bit_get	O
(	O
v	pointer
,	O
i	int
,	O
s	int
)	O
;	O
)	O
;	O
else	O
s	int
=	O
CHAR_SIZE	O
-	O
1	int
;	O
}	O
ds	pointer
=	O
ptr_get	O
(	O
ds	pointer
,	O
i	int
,	O
s	int
)	O
;	O
return	O
ds	pointer
<	O
de	pointer
?	O
ds	pointer
:	O
de	pointer
;	O
}	O
inline	O
char	O
get_mark_bit	function
(	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x	pointer
)	O
{	O
return	O
get_bit	function
(	O
CB_MARK_START	function
(	O
pi	pointer
)	O
,	O
pi	pointer
,	O
x	pointer
)	O
;	O
}	O
inline	O
void	O
set_mark_bit	function
(	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x	pointer
)	O
{	O
set_bit	function
(	O
CB_MARK_START	function
(	O
pi	pointer
)	O
,	O
pi	pointer
,	O
x	pointer
)	O
;	O
}	O
inline	O
void	O
*	O
get_mark_bits	function
(	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x	pointer
)	O
{	O
return	O
get_bits	function
(	O
CB_MARK_START	function
(	O
pi	pointer
)	O
,	O
pi	pointer
,	O
x	pointer
)	O
;	O
}	O
inline	O
void	O
set_mark_bits	function
(	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x1	pointer
,	O
void	O
*	O
x2	pointer
)	O
{	O
set_bits	function
(	O
CB_MARK_START	function
(	O
pi	pointer
)	O
,	O
pi	pointer
,	O
x1	pointer
,	O
x2	pointer
)	O
;	O
}	O
inline	O
char	O
get_sgc_bit	function
(	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x	pointer
)	O
{	O
return	O
get_bit	function
(	O
CB_SGCF_START	function
(	O
pi	pointer
)	O
,	O
pi	pointer
,	O
x	pointer
)	O
;	O
}	O
inline	O
void	O
set_sgc_bit	function
(	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x	pointer
)	O
{	O
set_bit	function
(	O
CB_SGCF_START	function
(	O
pi	pointer
)	O
,	O
pi	pointer
,	O
x	pointer
)	O
;	O
}	O
inline	O
void	O
*	O
get_sgc_bits	function
(	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x	pointer
)	O
{	O
return	O
get_bits	function
(	O
CB_SGCF_START	function
(	O
pi	pointer
)	O
,	O
pi	pointer
,	O
x	pointer
)	O
;	O
}	O
inline	O
void	O
set_sgc_bits	function
(	O
struct	O
pageinfo	O
*	O
pi	pointer
,	O
void	O
*	O
x1	pointer
,	O
void	O
*	O
x2	pointer
)	O
{	O
set_bits	function
(	O
CB_SGCF_START	function
(	O
pi	pointer
)	O
,	O
pi	pointer
,	O
x1	pointer
,	O
x2	pointer
)	O
;	O
}	O
static	O
int	O
gc_time	int
=	O
-	O
1	int
;	O
static	O
int	O
gc_start	int
=	O
0	int
;	O
static	O
int	O
gc_recursive	int
=	O
0	int
;	O
int	O
runtime	function
(	O
void	O
)	O
;	O
long	O
first_protectable_page	long
=	O
0	int
;	O
static	O
char	O
*	O
copy_relblock	function
(	O
char	O
*	O
p	pointer
,	O
int	O
s	int
)	O
;	O
long	O
real_maxpage	long
;	O
long	O
new_holepage	long
;	O
struct	O
apage	struct
{	O
char	O
apage_self	char
[	O
PAGESIZE	O
]	O
;	O
}	O
;	O
object	O
sSAnotify_gbcA	int
;	O
bool	O
debug	int
;	O
object	O
sSAgbc_messageA	int
;	O
object	O
*	O
mark_origin	array
[	O
MARK_ORIGIN_MAX	int
]	O
;	O
int	O
mark_origin_max	int
;	O
struct	O
{	O
object	O
*	O
mob_addr	pointer
;	O
int	O
mob_size	int
;	O
}	O
mark_origin_block	array
[	O
MARK_ORIGIN_BLOCK_MAX	int
]	O
;	O
int	O
mark_origin_block_max	int
;	O
enum	O
type	O
what_to_collect	enum
;	O
void	O
enter_mark_origin	function
(	O
object	O
*	O
p	pointer
)	O
{	O
if	O
(	O
mark_origin_max	int
>=	O
MARK_ORIGIN_MAX	int
)	O
error	function
(	O
"too many mark origins"	pointer
)	O
;	O
mark_origin	array
[	O
mark_origin_max	int
++	O
]	O
=	O
p	pointer
;	O
}	O
inline	O
void	O
mark_cons	function
(	O
object	O
x	pointer
)	O
{	O
do	O
{	O
object	O
d	O
=	O
x	pointer
->	O
c	O
.	O
c_cdr	O
;	O
mark	function
(	O
x	pointer
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
c	O
.	O
c_car	O
)	O
;	O
x	pointer
=	O
d	O
;	O
if	O
(	O
NULL_OR_ON_C_STACK	function
(	O
x	pointer
)	O
||	O
is_marked_or_free	function
(	O
x	pointer
)	O
)	O
return	O
;	O
}	O
while	O
(	O
cdr_listp	function
(	O
x	pointer
)	O
)	O
;	O
mark_object	function
(	O
x	pointer
)	O
;	O
}	O
bool	O
collect_both	int
=	O
0	int
;	O
static	O
void	O
mark_link_array	function
(	O
void	O
*	O
v	pointer
,	O
void	O
*	O
ve	pointer
)	O
{	O
void	O
*	O
*	O
p	pointer
,	O
*	O
*	O
pe	pointer
;	O
if	O
(	O
NULL_OR_ON_C_STACK	function
(	O
v	pointer
)	O
)	O
return	O
;	O
if	O
(	O
sLAlink_arrayA	O
->	O
s	int
.	O
s_dbind	O
==	O
Cnil	O
)	O
return	O
;	O
p	pointer
=	O
(	O
void	O
*	O
)	O
sLAlink_arrayA	O
->	O
s	int
.	O
s_dbind	O
->	O
v	pointer
.	O
v_self	O
;	O
pe	pointer
=	O
(	O
void	O
*	O
)	O
p	pointer
+	O
sLAlink_arrayA	O
->	O
s	int
.	O
s_dbind	O
->	O
v	pointer
.	O
v_fillp	O
;	O
if	O
(	O
is_marked	function
(	O
sLAlink_arrayA	O
->	O
s	int
.	O
s_dbind	O
)	O
&&	O
COLLECT_RELBLOCK_P	O
)	O
{	O
fixnum	O
j	pointer
=	O
rb_pointer1	O
-	O
rb_pointer	O
;	O
p	pointer
=	O
(	O
void	O
*	O
)	O
p	pointer
+	O
j	pointer
;	O
pe	pointer
=	O
(	O
void	O
*	O
)	O
pe	pointer
+	O
j	pointer
;	O
}	O
for	O
(	O
;	O
p	pointer
<	O
pe	pointer
;	O
p	pointer
+=	O
2	int
)	O
if	O
(	O
*	O
p	pointer
>=	O
v	pointer
&&	O
*	O
p	pointer
<	O
ve	pointer
)	O
{	O
massert	function
(	O
!	O
LINK_ARRAY_MARKED	O
(	O
p	pointer
)	O
)	O
;	O
MARK_LINK_ARRAY	O
(	O
p	pointer
)	O
;	O
}	O
}	O
static	O
void	O
prune_link_array	function
(	O
void	O
)	O
{	O
void	O
*	O
*	O
p	pointer
,	O
*	O
*	O
pe	pointer
,	O
*	O
*	O
n	pointer
,	O
*	O
*	O
ne	pointer
;	O
if	O
(	O
sLAlink_arrayA	O
->	O
s	int
.	O
s_dbind	O
==	O
Cnil	O
)	O
return	O
;	O
ne	pointer
=	O
n	pointer
=	O
p	pointer
=	O
(	O
void	O
*	O
)	O
sLAlink_arrayA	O
->	O
s	int
.	O
s_dbind	O
->	O
v	pointer
.	O
v_self	O
;	O
pe	pointer
=	O
(	O
void	O
*	O
)	O
p	pointer
+	O
sLAlink_arrayA	O
->	O
s	int
.	O
s_dbind	O
->	O
v	pointer
.	O
v_fillp	O
;	O
while	O
(	O
p	pointer
<	O
pe	pointer
)	O
{	O
if	O
(	O
*	O
p	pointer
)	O
{	O
*	O
ne	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
*	O
ne	pointer
++	O
=	O
*	O
p	pointer
++	O
;	O
}	O
else	O
p	pointer
+=	O
2	int
;	O
}	O
sLAlink_arrayA	O
->	O
s	int
.	O
s_dbind	O
->	O
v	pointer
.	O
v_fillp	O
=	O
(	O
ne	pointer
-	O
n	pointer
)	O
*	O
sizeof	O
(	O
*	O
n	pointer
)	O
;	O
}	O
static	O
void	O
sweep_link_array	function
(	O
void	O
)	O
{	O
void	O
*	O
*	O
*	O
p	pointer
,	O
*	O
*	O
*	O
pe	pointer
;	O
if	O
(	O
sLAlink_arrayA	O
->	O
s	int
.	O
s_dbind	O
==	O
Cnil	O
)	O
return	O
;	O
p	pointer
=	O
(	O
void	O
*	O
)	O
sLAlink_arrayA	O
->	O
s	int
.	O
s_dbind	O
->	O
v	pointer
.	O
v_self	O
;	O
pe	pointer
=	O
(	O
void	O
*	O
)	O
p	pointer
+	O
sLAlink_arrayA	O
->	O
s	int
.	O
s_dbind	O
->	O
v	pointer
.	O
v_fillp	O
;	O
for	O
(	O
;	O
p	pointer
<	O
pe	pointer
;	O
p	pointer
+=	O
2	int
)	O
if	O
(	O
*	O
p	pointer
)	O
{	O
if	O
(	O
LINK_ARRAY_MARKED	O
(	O
p	pointer
)	O
)	O
CLEAR_LINK_ARRAY	O
(	O
p	pointer
)	O
;	O
else	O
{	O
*	O
*	O
p	pointer
=	O
p	pointer
[	O
1	int
]	O
;	O
*	O
p	pointer
=	O
0	int
;	O
}	O
}	O
prune_link_array	function
(	O
)	O
;	O
}	O
static	O
void	O
mark_object	function
(	O
object	O
x	pointer
)	O
{	O
fixnum	O
i	int
,	O
j	pointer
;	O
object	O
*	O
p	pointer
;	O
char	O
*	O
cp	pointer
;	O
enum	O
type	O
tp	enum
;	O
BEGIN	O
:	O
if	O
(	O
NULL_OR_ON_C_STACK	function
(	O
x	pointer
)	O
||	O
is_marked_or_free	function
(	O
x	pointer
)	O
)	O
return	O
;	O
tp	enum
=	O
type_of	function
(	O
x	pointer
)	O
;	O
if	O
(	O
tp	enum
==	O
t_cons	O
)	O
{	O
mark_cons	function
(	O
x	pointer
)	O
;	O
return	O
;	O
}	O
mark	function
(	O
x	pointer
)	O
;	O
switch	O
(	O
tp	enum
)	O
{	O
case	O
t_fixnum	O
:	O
break	O
;	O
case	O
t_ratio	O
:	O
mark_object	function
(	O
x	pointer
->	O
rat	O
.	O
rat_num	O
)	O
;	O
x	pointer
=	O
x	pointer
->	O
rat	O
.	O
rat_den	O
;	O
goto	O
BEGIN	O
;	O
case	O
t_shortfloat	O
:	O
break	O
;	O
case	O
t_longfloat	O
:	O
break	O
;	O
case	O
t_complex	O
:	O
mark_object	function
(	O
x	pointer
->	O
cmp	O
.	O
cmp_imag	O
)	O
;	O
x	pointer
=	O
x	pointer
->	O
cmp	O
.	O
cmp_real	O
;	O
goto	O
BEGIN	O
;	O
case	O
t_character	O
:	O
break	O
;	O
case	O
t_symbol	O
:	O
mark_object	function
(	O
x	pointer
->	O
s	int
.	O
s_plist	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
s	int
.	O
s_gfdef	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
s	int
.	O
s_dbind	O
)	O
;	O
if	O
(	O
x	pointer
->	O
s	int
.	O
s_self	O
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
inheap	function
(	O
x	pointer
->	O
s	int
.	O
s_self	O
)	O
)	O
{	O
if	O
(	O
what_to_collect	enum
==	O
t_contiguous	O
)	O
mark_contblock	function
(	O
x	pointer
->	O
s	int
.	O
s_self	O
,	O
x	pointer
->	O
s	int
.	O
s_fillp	O
)	O
;	O
}	O
else	O
if	O
(	O
COLLECT_RELBLOCK_P	O
)	O
x	pointer
->	O
s	int
.	O
s_self	O
=	O
copy_relblock	function
(	O
x	pointer
->	O
s	int
.	O
s_self	O
,	O
x	pointer
->	O
s	int
.	O
s_fillp	O
)	O
;	O
break	O
;	O
case	O
t_package	O
:	O
mark_object	function
(	O
x	pointer
->	O
p	pointer
.	O
p_name	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
p	pointer
.	O
p_nicknames	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
p	pointer
.	O
p_shadowings	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
p	pointer
.	O
p_uselist	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
p	pointer
.	O
p_usedbylist	O
)	O
;	O
if	O
(	O
what_to_collect	enum
!=	O
t_contiguous	O
)	O
break	O
;	O
if	O
(	O
x	pointer
->	O
p	pointer
.	O
p_internal	O
!=	O
NULL	O
)	O
mark_contblock	function
(	O
(	O
char	O
*	O
)	O
(	O
x	pointer
->	O
p	pointer
.	O
p_internal	O
)	O
,	O
x	pointer
->	O
p	pointer
.	O
p_internal_size	O
*	O
sizeof	O
(	O
object	O
)	O
)	O
;	O
if	O
(	O
x	pointer
->	O
p	pointer
.	O
p_external	O
!=	O
NULL	O
)	O
mark_contblock	function
(	O
(	O
char	O
*	O
)	O
(	O
x	pointer
->	O
p	pointer
.	O
p_external	O
)	O
,	O
x	pointer
->	O
p	pointer
.	O
p_external_size	O
*	O
sizeof	O
(	O
object	O
)	O
)	O
;	O
break	O
;	O
case	O
t_hashtable	O
:	O
mark_object	function
(	O
x	pointer
->	O
ht	O
.	O
ht_rhsize	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
ht	O
.	O
ht_rhthresh	O
)	O
;	O
if	O
(	O
x	pointer
->	O
ht	O
.	O
ht_self	O
==	O
NULL	O
)	O
break	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	pointer
=	O
x	pointer
->	O
ht	O
.	O
ht_size	O
;	O
i	int
<	O
j	pointer
;	O
i	int
++	O
)	O
{	O
mark_object	function
(	O
x	pointer
->	O
ht	O
.	O
ht_self	O
[	O
i	int
]	O
.	O
hte_key	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
ht	O
.	O
ht_self	O
[	O
i	int
]	O
.	O
hte_value	O
)	O
;	O
}	O
if	O
(	O
inheap	function
(	O
x	pointer
->	O
ht	O
.	O
ht_self	O
)	O
)	O
{	O
if	O
(	O
what_to_collect	enum
==	O
t_contiguous	O
)	O
mark_contblock	function
(	O
(	O
char	O
*	O
)	O
x	pointer
->	O
ht	O
.	O
ht_self	O
,	O
j	pointer
*	O
sizeof	O
(	O
struct	O
htent	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
COLLECT_RELBLOCK_P	O
)	O
x	pointer
->	O
ht	O
.	O
ht_self	O
=	O
(	O
void	O
*	O
)	O
copy_relblock	function
(	O
(	O
char	O
*	O
)	O
x	pointer
->	O
ht	O
.	O
ht_self	O
,	O
j	pointer
*	O
sizeof	O
(	O
struct	O
htent	O
)	O
)	O
;	O
;	O
break	O
;	O
case	O
t_array	O
:	O
if	O
(	O
(	O
x	pointer
->	O
a	pointer
.	O
a_displaced	O
)	O
!=	O
Cnil	O
)	O
mark_displaced_field	O
(	O
x	pointer
)	O
;	O
if	O
(	O
x	pointer
->	O
a	pointer
.	O
a_dims	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
inheap	function
(	O
x	pointer
->	O
a	pointer
.	O
a_dims	O
)	O
)	O
{	O
if	O
(	O
what_to_collect	enum
==	O
t_contiguous	O
)	O
mark_contblock	function
(	O
(	O
char	O
*	O
)	O
(	O
x	pointer
->	O
a	pointer
.	O
a_dims	O
)	O
,	O
sizeof	O
(	O
int	O
)	O
*	O
x	pointer
->	O
a	pointer
.	O
a_rank	O
)	O
;	O
}	O
else	O
if	O
(	O
COLLECT_RELBLOCK_P	O
)	O
x	pointer
->	O
a	pointer
.	O
a_dims	O
=	O
(	O
int	O
*	O
)	O
copy_relblock	function
(	O
(	O
char	O
*	O
)	O
(	O
x	pointer
->	O
a	pointer
.	O
a_dims	O
)	O
,	O
sizeof	O
(	O
int	O
)	O
*	O
x	pointer
->	O
a	pointer
.	O
a_rank	O
)	O
;	O
}	O
if	O
(	O
(	O
enum	O
aelttype	O
)	O
x	pointer
->	O
a	pointer
.	O
a_elttype	O
==	O
aet_ch	O
)	O
goto	O
CASE_STRING	O
;	O
if	O
(	O
(	O
enum	O
aelttype	O
)	O
x	pointer
->	O
a	pointer
.	O
a_elttype	O
==	O
aet_bit	O
)	O
goto	O
CASE_BITVECTOR	O
;	O
if	O
(	O
(	O
enum	O
aelttype	O
)	O
x	pointer
->	O
a	pointer
.	O
a_elttype	O
==	O
aet_object	O
)	O
goto	O
CASE_GENERAL	O
;	O
CASE_SPECIAL	O
:	O
cp	pointer
=	O
(	O
char	O
*	O
)	O
(	O
x	pointer
->	O
fixa	O
.	O
fixa_self	O
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
break	O
;	O
switch	O
(	O
(	O
enum	O
aelttype	O
)	O
x	pointer
->	O
a	pointer
.	O
a_elttype	O
)	O
{	O
case	O
aet_lf	O
:	O
j	pointer
=	O
sizeof	O
(	O
longfloat	O
)	O
*	O
x	pointer
->	O
lfa	O
.	O
lfa_dim	O
;	O
if	O
(	O
(	O
COLLECT_RELBLOCK_P	O
)	O
&&	O
!	O
(	O
inheap	function
(	O
cp	pointer
)	O
)	O
)	O
ROUND_RB_POINTERS_DOUBLE	O
;	O
break	O
;	O
case	O
aet_char	O
:	O
case	O
aet_uchar	O
:	O
j	pointer
=	O
sizeof	O
(	O
char	O
)	O
*	O
x	pointer
->	O
a	pointer
.	O
a_dim	O
;	O
break	O
;	O
case	O
aet_short	O
:	O
case	O
aet_ushort	O
:	O
j	pointer
=	O
sizeof	O
(	O
short	O
)	O
*	O
x	pointer
->	O
a	pointer
.	O
a_dim	O
;	O
break	O
;	O
default	O
:	O
j	pointer
=	O
sizeof	O
(	O
fixnum	O
)	O
*	O
x	pointer
->	O
fixa	O
.	O
fixa_dim	O
;	O
}	O
goto	O
COPY	O
;	O
CASE_GENERAL	O
:	O
p	pointer
=	O
x	pointer
->	O
a	pointer
.	O
a_self	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
break	O
;	O
j	pointer
=	O
0	int
;	O
if	O
(	O
x	pointer
->	O
a	pointer
.	O
a_displaced	O
->	O
c	O
.	O
c_car	O
==	O
Cnil	O
)	O
for	O
(	O
i	int
=	O
0	int
,	O
j	pointer
=	O
x	pointer
->	O
a	pointer
.	O
a_dim	O
;	O
i	int
<	O
j	pointer
;	O
i	int
++	O
)	O
mark_object	function
(	O
p	pointer
[	O
i	int
]	O
)	O
;	O
cp	pointer
=	O
(	O
char	O
*	O
)	O
p	pointer
;	O
j	pointer
*=	O
sizeof	O
(	O
object	O
)	O
;	O
COPY	O
:	O
if	O
(	O
inheap	function
(	O
cp	pointer
)	O
)	O
{	O
if	O
(	O
what_to_collect	enum
==	O
t_contiguous	O
)	O
mark_contblock	function
(	O
cp	pointer
,	O
j	pointer
)	O
;	O
}	O
else	O
if	O
(	O
COLLECT_RELBLOCK_P	O
)	O
{	O
if	O
(	O
x	pointer
->	O
a	pointer
.	O
a_displaced	O
==	O
Cnil	O
)	O
{	O
x	pointer
->	O
a	pointer
.	O
a_self	O
=	O
(	O
object	O
*	O
)	O
copy_relblock	function
(	O
cp	pointer
,	O
j	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	pointer
->	O
a	pointer
.	O
a_displaced	O
->	O
c	O
.	O
c_car	O
==	O
Cnil	O
)	O
{	O
i	int
=	O
(	O
long	O
)	O
(	O
object	O
*	O
)	O
copy_relblock	function
(	O
cp	pointer
,	O
j	pointer
)	O
-	O
(	O
long	O
)	O
(	O
x	pointer
->	O
a	pointer
.	O
a_self	O
)	O
;	O
adjust_displaced	function
(	O
x	pointer
,	O
i	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
t_vector	O
:	O
if	O
(	O
(	O
x	pointer
->	O
v	pointer
.	O
v_displaced	O
)	O
!=	O
Cnil	O
)	O
mark_displaced_field	O
(	O
x	pointer
)	O
;	O
if	O
(	O
(	O
enum	O
aelttype	O
)	O
x	pointer
->	O
v	pointer
.	O
v_elttype	O
==	O
aet_object	O
)	O
goto	O
CASE_GENERAL	O
;	O
else	O
goto	O
CASE_SPECIAL	O
;	O
case	O
t_bignum	O
:	O
if	O
(	O
(	O
int	O
)	O
what_to_collect	enum
>=	O
(	O
int	O
)	O
t_contiguous	O
)	O
{	O
j	pointer
=	O
MP_ALLOCATED	function
(	O
x	pointer
)	O
;	O
cp	pointer
=	O
(	O
char	O
*	O
)	O
MP_SELF	function
(	O
x	pointer
)	O
;	O
if	O
(	O
cp	pointer
==	O
0	int
)	O
break	O
;	O
j	pointer
=	O
j	pointer
*	O
MP_LIMB_SIZE	O
;	O
if	O
(	O
inheap	function
(	O
cp	pointer
)	O
)	O
{	O
if	O
(	O
what_to_collect	enum
==	O
t_contiguous	O
)	O
mark_contblock	function
(	O
cp	pointer
,	O
j	pointer
)	O
;	O
}	O
else	O
if	O
(	O
COLLECT_RELBLOCK_P	O
)	O
{	O
MP_SELF	function
(	O
x	pointer
)	O
=	O
(	O
void	O
*	O
)	O
copy_relblock	function
(	O
cp	pointer
,	O
j	pointer
)	O
;	O
}	O
}	O
break	O
;	O
CASE_STRING	O
:	O
case	O
t_string	O
:	O
if	O
(	O
(	O
x	pointer
->	O
st	O
.	O
st_displaced	O
)	O
!=	O
Cnil	O
)	O
mark_displaced_field	O
(	O
x	pointer
)	O
;	O
j	pointer
=	O
x	pointer
->	O
st	O
.	O
st_dim	O
;	O
cp	pointer
=	O
x	pointer
->	O
st	O
.	O
st_self	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
break	O
;	O
COPY_STRING	O
:	O
if	O
(	O
inheap	function
(	O
cp	pointer
)	O
)	O
{	O
if	O
(	O
what_to_collect	enum
==	O
t_contiguous	O
)	O
mark_contblock	function
(	O
cp	pointer
,	O
j	pointer
)	O
;	O
}	O
else	O
if	O
(	O
COLLECT_RELBLOCK_P	O
)	O
{	O
if	O
(	O
x	pointer
->	O
st	O
.	O
st_displaced	O
==	O
Cnil	O
)	O
x	pointer
->	O
st	O
.	O
st_self	O
=	O
copy_relblock	function
(	O
cp	pointer
,	O
j	pointer
)	O
;	O
else	O
if	O
(	O
x	pointer
->	O
st	O
.	O
st_displaced	O
->	O
c	O
.	O
c_car	O
==	O
Cnil	O
)	O
{	O
i	int
=	O
copy_relblock	function
(	O
cp	pointer
,	O
j	pointer
)	O
-	O
cp	pointer
;	O
adjust_displaced	function
(	O
x	pointer
,	O
i	int
)	O
;	O
}	O
}	O
break	O
;	O
CASE_BITVECTOR	O
:	O
case	O
t_bitvector	O
:	O
if	O
(	O
(	O
x	pointer
->	O
bv	O
.	O
bv_displaced	O
)	O
!=	O
Cnil	O
)	O
mark_displaced_field	O
(	O
x	pointer
)	O
;	O
j	pointer
=	O
sizeof	O
(	O
fixnum	O
)	O
*	O
(	O
(	O
BV_OFFSET	function
(	O
x	pointer
)	O
+	O
x	pointer
->	O
bv	O
.	O
bv_dim	O
+	O
W_SIZE	O
-	O
1	int
)	O
/	O
W_SIZE	O
)	O
;	O
cp	pointer
=	O
x	pointer
->	O
bv	O
.	O
bv_self	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
break	O
;	O
goto	O
COPY_STRING	O
;	O
case	O
t_structure	O
:	O
mark_object	function
(	O
x	pointer
->	O
str	O
.	O
str_def	O
)	O
;	O
p	pointer
=	O
x	pointer
->	O
str	O
.	O
str_self	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
break	O
;	O
{	O
object	O
def	O
=	O
x	pointer
->	O
str	O
.	O
str_def	O
;	O
unsigned	O
char	O
*	O
s_type	pointer
=	O
&	O
SLOT_TYPE	function
(	O
def	O
,	O
0	int
)	O
;	O
unsigned	O
short	O
*	O
s_pos	pointer
=	O
&	O
SLOT_POS	function
(	O
def	O
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
j	pointer
=	O
S_DATA	function
(	O
def	O
)	O
->	O
length	O
;	O
i	int
<	O
j	pointer
;	O
i	int
++	O
)	O
if	O
(	O
s_type	pointer
[	O
i	int
]	O
==	O
0	int
)	O
mark_object	function
(	O
STREF	function
(	O
object	O
,	O
x	pointer
,	O
s_pos	pointer
[	O
i	int
]	O
)	O
)	O
;	O
if	O
(	O
inheap	function
(	O
x	pointer
->	O
str	O
.	O
str_self	O
)	O
)	O
{	O
if	O
(	O
what_to_collect	enum
==	O
t_contiguous	O
)	O
mark_contblock	function
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
S_DATA	function
(	O
def	O
)	O
->	O
size	int
)	O
;	O
}	O
else	O
if	O
(	O
COLLECT_RELBLOCK_P	O
)	O
x	pointer
->	O
str	O
.	O
str_self	O
=	O
(	O
object	O
*	O
)	O
copy_relblock	function
(	O
(	O
char	O
*	O
)	O
p	pointer
,	O
S_DATA	function
(	O
def	O
)	O
->	O
size	int
)	O
;	O
}	O
break	O
;	O
case	O
t_stream	O
:	O
switch	O
(	O
x	pointer
->	O
sm	O
.	O
sm_mode	O
)	O
{	O
case	O
smm_input	O
:	O
case	O
smm_output	O
:	O
case	O
smm_io	O
:	O
case	O
smm_socket	O
:	O
case	O
smm_probe	O
:	O
mark_object	function
(	O
x	pointer
->	O
sm	O
.	O
sm_object0	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
sm	O
.	O
sm_object1	O
)	O
;	O
if	O
(	O
what_to_collect	enum
==	O
t_contiguous	O
&&	O
x	pointer
->	O
sm	O
.	O
sm_fp	O
&&	O
x	pointer
->	O
sm	O
.	O
sm_buffer	O
)	O
mark_contblock	function
(	O
x	pointer
->	O
sm	O
.	O
sm_buffer	O
,	O
BUFSIZ	O
)	O
;	O
break	O
;	O
case	O
smm_synonym	O
:	O
mark_object	function
(	O
x	pointer
->	O
sm	O
.	O
sm_object0	O
)	O
;	O
break	O
;	O
case	O
smm_broadcast	O
:	O
case	O
smm_concatenated	O
:	O
mark_object	function
(	O
x	pointer
->	O
sm	O
.	O
sm_object0	O
)	O
;	O
break	O
;	O
case	O
smm_two_way	O
:	O
case	O
smm_echo	O
:	O
mark_object	function
(	O
x	pointer
->	O
sm	O
.	O
sm_object0	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
sm	O
.	O
sm_object1	O
)	O
;	O
break	O
;	O
case	O
smm_string_input	O
:	O
case	O
smm_string_output	O
:	O
mark_object	function
(	O
x	pointer
->	O
sm	O
.	O
sm_object0	O
)	O
;	O
break	O
;	O
case	O
smm_user_defined	O
:	O
mark_object	function
(	O
x	pointer
->	O
sm	O
.	O
sm_object0	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
sm	O
.	O
sm_object1	O
)	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
"mark stream botch"	pointer
)	O
;	O
}	O
break	O
;	O
case	O
t_random	O
:	O
if	O
(	O
(	O
int	O
)	O
what_to_collect	enum
>=	O
(	O
int	O
)	O
t_contiguous	O
)	O
{	O
MARK_MP	O
(	O
x	pointer
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_seed	O
)	O
;	O
if	O
(	O
x	pointer
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_algdata	O
.	O
_mp_lc	O
)	O
{	O
MARK_MP	O
(	O
x	pointer
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_algdata	O
.	O
_mp_lc	O
->	O
_mp_a	O
)	O
;	O
if	O
(	O
!	O
x	pointer
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_algdata	O
.	O
_mp_lc	O
->	O
_mp_m2exp	O
)	O
MARK_MP	O
(	O
x	pointer
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_algdata	O
.	O
_mp_lc	O
->	O
_mp_m	O
)	O
;	O
MARK_CP	O
(	O
x	pointer
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_algdata	O
.	O
_mp_lc	O
,	O
sizeof	O
(	O
*	O
x	pointer
->	O
rnd	O
.	O
rnd_state	O
.	O
_mp_algdata	O
.	O
_mp_lc	O
)	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
t_readtable	O
:	O
if	O
(	O
x	pointer
->	O
rt	O
.	O
rt_self	O
==	O
NULL	O
)	O
break	O
;	O
if	O
(	O
what_to_collect	enum
==	O
t_contiguous	O
)	O
mark_contblock	function
(	O
(	O
char	O
*	O
)	O
(	O
x	pointer
->	O
rt	O
.	O
rt_self	O
)	O
,	O
RTABSIZE	O
*	O
sizeof	O
(	O
struct	O
rtent	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
RTABSIZE	O
;	O
i	int
++	O
)	O
{	O
mark_object	function
(	O
x	pointer
->	O
rt	O
.	O
rt_self	O
[	O
i	int
]	O
.	O
rte_macro	O
)	O
;	O
if	O
(	O
x	pointer
->	O
rt	O
.	O
rt_self	O
[	O
i	int
]	O
.	O
rte_dtab	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
what_to_collect	enum
==	O
t_contiguous	O
)	O
mark_contblock	function
(	O
(	O
char	O
*	O
)	O
(	O
x	pointer
->	O
rt	O
.	O
rt_self	O
[	O
i	int
]	O
.	O
rte_dtab	O
)	O
,	O
RTABSIZE	O
*	O
sizeof	O
(	O
object	O
)	O
)	O
;	O
for	O
(	O
j	pointer
=	O
0	int
;	O
j	pointer
<	O
RTABSIZE	O
;	O
j	pointer
++	O
)	O
mark_object	function
(	O
x	pointer
->	O
rt	O
.	O
rt_self	O
[	O
i	int
]	O
.	O
rte_dtab	O
[	O
j	pointer
]	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
t_pathname	O
:	O
mark_object	function
(	O
x	pointer
->	O
pn	O
.	O
pn_host	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
pn	O
.	O
pn_device	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
pn	O
.	O
pn_directory	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
pn	O
.	O
pn_name	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
pn	O
.	O
pn_type	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
pn	O
.	O
pn_version	O
)	O
;	O
break	O
;	O
case	O
t_closure	O
:	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
x	pointer
->	O
cl	O
.	O
cl_envdim	O
;	O
i	int
++	O
)	O
mark_object	function
(	O
x	pointer
->	O
cl	O
.	O
cl_env	O
[	O
i	int
]	O
)	O
;	O
if	O
(	O
COLLECT_RELBLOCK_P	O
)	O
x	pointer
->	O
cl	O
.	O
cl_env	O
=	O
(	O
void	O
*	O
)	O
copy_relblock	function
(	O
(	O
void	O
*	O
)	O
x	pointer
->	O
cl	O
.	O
cl_env	O
,	O
x	pointer
->	O
cl	O
.	O
cl_envdim	O
*	O
sizeof	O
(	O
object	O
)	O
)	O
;	O
}	O
case	O
t_cfun	O
:	O
case	O
t_sfun	O
:	O
case	O
t_vfun	O
:	O
case	O
t_afun	O
:	O
case	O
t_gfun	O
:	O
mark_object	function
(	O
x	pointer
->	O
cf	O
.	O
cf_name	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
cf	O
.	O
cf_data	O
)	O
;	O
break	O
;	O
case	O
t_cfdata	O
:	O
if	O
(	O
x	pointer
->	O
cfd	O
.	O
cfd_self	O
!=	O
NULL	O
)	O
{	O
int	O
i	int
=	O
x	pointer
->	O
cfd	O
.	O
cfd_fillp	O
;	O
while	O
(	O
i	int
--	O
>	O
0	int
)	O
mark_object	function
(	O
x	pointer
->	O
cfd	O
.	O
cfd_self	O
[	O
i	int
]	O
)	O
;	O
}	O
if	O
(	O
what_to_collect	enum
==	O
t_contiguous	O
)	O
{	O
mark_contblock	function
(	O
x	pointer
->	O
cfd	O
.	O
cfd_start	O
,	O
x	pointer
->	O
cfd	O
.	O
cfd_size	O
)	O
;	O
mark_link_array	function
(	O
x	pointer
->	O
cfd	O
.	O
cfd_start	O
,	O
x	pointer
->	O
cfd	O
.	O
cfd_start	O
+	O
x	pointer
->	O
cfd	O
.	O
cfd_size	O
)	O
;	O
}	O
break	O
;	O
case	O
t_cclosure	O
:	O
mark_object	function
(	O
x	pointer
->	O
cc	O
.	O
cc_name	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
cc	O
.	O
cc_env	O
)	O
;	O
mark_object	function
(	O
x	pointer
->	O
cc	O
.	O
cc_data	O
)	O
;	O
if	O
(	O
x	pointer
->	O
cc	O
.	O
cc_turbo	O
!=	O
NULL	O
)	O
{	O
mark_object	function
(	O
*	O
(	O
x	pointer
->	O
cc	O
.	O
cc_turbo	O
-	O
1	int
)	O
)	O
;	O
if	O
(	O
COLLECT_RELBLOCK_P	O
)	O
x	pointer
->	O
cc	O
.	O
cc_turbo	O
=	O
(	O
void	O
*	O
)	O
copy_relblock	function
(	O
(	O
char	O
*	O
)	O
(	O
x	pointer
->	O
cc	O
.	O
cc_turbo	O
-	O
1	int
)	O
,	O
(	O
1	int
+	O
fix	function
(	O
*	O
(	O
x	pointer
->	O
cc	O
.	O
cc_turbo	O
-	O
1	int
)	O
)	O
)	O
*	O
sizeof	O
(	O
object	O
)	O
)	O
+	O
sizeof	O
(	O
object	O
)	O
;	O
}	O
break	O
;	O
case	O
t_spice	O
:	O
break	O
;	O
default	O
:	O
if	O
(	O
debug	int
)	O
printf	O
(	O
"\ttype = %d\n"	pointer
,	O
type_of	function
(	O
x	pointer
)	O
)	O
;	O
error	function
(	O
"mark botch"	pointer
)	O
;	O
}	O
}	O
static	O
long	O
*	O
c_stack_where	pointer
;	O
void	O
*	O
*	O
contblock_stack_list	pointer
=	O
NULL	O
;	O
static	O
void	O
mark_stack_carefully	function
(	O
void	O
*	O
topv	pointer
,	O
void	O
*	O
bottomv	pointer
,	O
int	O
offset	int
)	O
{	O
long	O
pageoffset	long
;	O
long	O
p	pointer
;	O
object	O
x	pointer
;	O
struct	O
typemanager	O
*	O
tm	pointer
;	O
register	O
long	O
*	O
j	pointer
;	O
long	O
*	O
top	pointer
=	O
topv	pointer
,	O
*	O
bottom	pointer
=	O
bottomv	pointer
;	O
if	O
(	O
top	pointer
==	O
0	int
)	O
top	pointer
=	O
c_stack_where	pointer
;	O
if	O
(	O
bottom	pointer
==	O
0	int
)	O
bottom	pointer
=	O
c_stack_where	pointer
;	O
if	O
(	O
offset	int
)	O
mark_stack_carefully	function
(	O
(	O
(	O
(	O
char	O
*	O
)	O
top	pointer
)	O
+	O
offset	int
)	O
,	O
bottom	pointer
,	O
0	int
)	O
;	O
for	O
(	O
j	pointer
=	O
top	pointer
;	O
j	pointer
>=	O
bottom	pointer
;	O
j	pointer
--	O
)	O
{	O
void	O
*	O
v	pointer
=	O
(	O
void	O
*	O
)	O
(	O
*	O
j	pointer
)	O
,	O
*	O
*	O
a	pointer
;	O
struct	O
pageinfo	O
*	O
pi	pointer
;	O
if	O
(	O
!	O
VALID_DATA_ADDRESS_P	function
(	O
v	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
(	O
p	pointer
=	O
page	function
(	O
v	pointer
)	O
)	O
<	O
first_data_page	O
)	O
continue	O
;	O
pageoffset	long
=	O
v	pointer
-	O
(	O
void	O
*	O
)	O
pagetochar	function
(	O
p	pointer
)	O
;	O
pi	pointer
=	O
pagetoinfo	function
(	O
p	pointer
)	O
;	O
if	O
(	O
!	O
PAGEINFO_P	O
(	O
pi	pointer
)	O
)	O
continue	O
;	O
for	O
(	O
a	pointer
=	O
contblock_stack_list	pointer
;	O
a	pointer
&&	O
a	pointer
[	O
0	int
]	O
!=	O
pi	pointer
;	O
a	pointer
=	O
a	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
a	pointer
)	O
continue	O
;	O
tm	pointer
=	O
tm_of	function
(	O
pi	pointer
->	O
type	O
)	O
;	O
if	O
(	O
tm	pointer
->	O
tm_type	O
>=	O
t_end	O
)	O
continue	O
;	O
if	O
(	O
pageoffset	long
<	O
0	int
||	O
pageoffset	long
>=	O
tm	pointer
->	O
tm_size	O
*	O
tm	pointer
->	O
tm_nppage	O
)	O
continue	O
;	O
x	pointer
=	O
(	O
object	O
)	O
(	O
v	pointer
-	O
pageoffset	long
%	O
tm	pointer
->	O
tm_size	O
)	O
;	O
if	O
(	O
is_marked_or_free	function
(	O
x	pointer
)	O
)	O
continue	O
;	O
mark_object	function
(	O
x	pointer
)	O
;	O
}	O
}	O
static	O
void	O
mark_phase	function
(	O
void	O
)	O
{	O
STATIC	O
fixnum	O
i	int
,	O
j	pointer
;	O
STATIC	O
struct	O
package	O
*	O
pp	O
;	O
STATIC	O
bds_ptr	O
bdp	O
;	O
STATIC	O
frame_ptr	O
frp	O
;	O
STATIC	O
ihs_ptr	O
ihsp	O
;	O
mark_object	function
(	O
Cnil	O
->	O
s	int
.	O
s_plist	O
)	O
;	O
mark_object	function
(	O
Ct	O
->	O
s	int
.	O
s_plist	O
)	O
;	O
mark_stack_carefully	function
(	O
vs_top	O
-	O
1	int
,	O
vs_org	O
,	O
0	int
)	O
;	O
mark_stack_carefully	function
(	O
MVloc	O
+	O
(	O
sizeof	O
(	O
MVloc	O
)	O
/	O
sizeof	O
(	O
object	O
)	O
)	O
,	O
MVloc	O
,	O
0	int
)	O
;	O
if	O
(	O
debug	int
)	O
{	O
printf	O
(	O
"value stack marked\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
}	O
for	O
(	O
bdp	O
=	O
bds_org	O
;	O
bdp	O
<=	O
bds_top	O
;	O
bdp	O
++	O
)	O
{	O
mark_object	function
(	O
bdp	O
->	O
bds_sym	O
)	O
;	O
mark_object	function
(	O
bdp	O
->	O
bds_val	O
)	O
;	O
}	O
for	O
(	O
frp	O
=	O
frs_org	O
;	O
frp	O
<=	O
frs_top	O
;	O
frp	O
++	O
)	O
mark_object	function
(	O
frp	O
->	O
frs_val	O
)	O
;	O
for	O
(	O
ihsp	O
=	O
ihs_org	O
;	O
ihsp	O
<=	O
ihs_top	O
;	O
ihsp	O
++	O
)	O
mark_object	function
(	O
ihsp	O
->	O
ihs_function	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mark_origin_max	int
;	O
i	int
++	O
)	O
mark_object	function
(	O
*	O
mark_origin	array
[	O
i	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
mark_origin_block_max	int
;	O
i	int
++	O
)	O
for	O
(	O
j	pointer
=	O
0	int
;	O
j	pointer
<	O
mark_origin_block	array
[	O
i	int
]	O
.	O
mob_size	int
;	O
j	pointer
++	O
)	O
mark_object	function
(	O
mark_origin_block	array
[	O
i	int
]	O
.	O
mob_addr	pointer
[	O
j	pointer
]	O
)	O
;	O
for	O
(	O
pp	O
=	O
pack_pointer	O
;	O
pp	O
!=	O
NULL	O
;	O
pp	O
=	O
pp	O
->	O
p_link	O
)	O
mark_object	function
(	O
(	O
object	O
)	O
pp	O
)	O
;	O
if	O
(	O
debug	int
)	O
{	O
printf	O
(	O
"symbol navigation\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
}	O
{	O
int	O
size	int
;	O
for	O
(	O
pp	O
=	O
pack_pointer	O
;	O
pp	O
!=	O
NULL	O
;	O
pp	O
=	O
pp	O
->	O
p_link	O
)	O
{	O
size	int
=	O
pp	O
->	O
p_internal_size	O
;	O
if	O
(	O
pp	O
->	O
p_internal	O
!=	O
NULL	O
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
mark_object	function
(	O
pp	O
->	O
p_internal	O
[	O
i	int
]	O
)	O
;	O
size	int
=	O
pp	O
->	O
p_external_size	O
;	O
if	O
(	O
pp	O
->	O
p_external	O
!=	O
NULL	O
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
size	int
;	O
i	int
++	O
)	O
mark_object	function
(	O
pp	O
->	O
p_external	O
[	O
i	int
]	O
)	O
;	O
}	O
}	O
mark_c_stack	function
(	O
0	int
,	O
N_RECURSION_REQD	int
,	O
mark_stack_carefully	function
)	O
;	O
}	O
static	O
void	O
mark_c_stack	function
(	O
jmp_buf	O
env1	int
,	O
int	O
n	pointer
,	O
void	O
(	O
*	O
fn	pointer
)	O
(	O
void	O
*	O
,	O
void	O
*	O
,	O
int	O
)	O
)	O
{	O
jmp_buf	O
env	O
;	O
int	O
where	int
;	O
if	O
(	O
n	pointer
==	O
N_RECURSION_REQD	int
)	O
c_stack_where	pointer
=	O
(	O
long	O
*	O
)	O
(	O
void	O
*	O
)	O
&	O
env	O
;	O
if	O
(	O
n	pointer
>	O
0	int
)	O
{	O
setjmp	function
(	O
env	O
)	O
;	O
mark_c_stack	function
(	O
env	O
,	O
n	pointer
-	O
1	int
,	O
fn	pointer
)	O
;	O
}	O
else	O
{	O
{	O
struct	O
pageinfo	O
*	O
v	pointer
,	O
*	O
tv	pointer
;	O
void	O
*	O
*	O
a	pointer
;	O
fixnum	O
i	int
;	O
for	O
(	O
v	pointer
=	O
contblock_list_head	O
,	O
contblock_stack_list	pointer
=	O
NULL	O
;	O
v	pointer
;	O
v	pointer
=	O
v	pointer
->	O
next	O
)	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
v	pointer
->	O
in_use	O
;	O
i	int
++	O
)	O
{	O
tv	pointer
=	O
pagetoinfo	function
(	O
page	function
(	O
v	pointer
)	O
+	O
i	int
)	O
;	O
if	O
(	O
PAGEINFO_P	O
(	O
tv	pointer
)	O
)	O
{	O
a	pointer
=	O
contblock_stack_list	pointer
;	O
contblock_stack_list	pointer
=	O
alloca	function
(	O
2	int
*	O
sizeof	O
(	O
a	pointer
)	O
)	O
;	O
contblock_stack_list	pointer
[	O
0	int
]	O
=	O
tv	pointer
;	O
contblock_stack_list	pointer
[	O
1	int
]	O
=	O
a	pointer
;	O
}	O
}	O
if	O
(	O
&	O
where	int
>	O
cs_org	O
)	O
(	O
*	O
fn	pointer
)	O
(	O
0	int
,	O
cs_org	O
,	O
C_GC_OFFSET	int
)	O
;	O
else	O
(	O
*	O
fn	pointer
)	O
(	O
cs_org	O
,	O
0	int
,	O
C_GC_OFFSET	int
)	O
;	O
contblock_stack_list	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
static	O
void	O
sweep_phase	function
(	O
void	O
)	O
{	O
STATIC	O
long	O
j	pointer
,	O
k	O
;	O
STATIC	O
object	O
x	pointer
;	O
STATIC	O
char	O
*	O
p	pointer
;	O
STATIC	O
struct	O
typemanager	O
*	O
tm	pointer
;	O
STATIC	O
object	O
f	O
;	O
STATIC	O
struct	O
pageinfo	O
*	O
v	pointer
;	O
for	O
(	O
v	pointer
=	O
cell_list_head	O
;	O
v	pointer
;	O
v	pointer
=	O
v	pointer
->	O
next	O
)	O
{	O
tm	pointer
=	O
tm_of	function
(	O
(	O
enum	O
type	O
)	O
v	pointer
->	O
type	O
)	O
;	O
p	pointer
=	O
pagetochar	function
(	O
page	function
(	O
v	pointer
)	O
)	O
;	O
f	O
=	O
tm	pointer
->	O
tm_free	O
;	O
k	O
=	O
0	int
;	O
for	O
(	O
j	pointer
=	O
tm	pointer
->	O
tm_nppage	O
;	O
j	pointer
>	O
0	int
;	O
--	O
j	pointer
,	O
p	pointer
+=	O
tm	pointer
->	O
tm_size	O
)	O
{	O
x	pointer
=	O
(	O
object	O
)	O
p	pointer
;	O
if	O
(	O
is_free	function
(	O
x	pointer
)	O
)	O
continue	O
;	O
else	O
if	O
(	O
is_marked	function
(	O
x	pointer
)	O
)	O
{	O
unmark	function
(	O
x	pointer
)	O
;	O
continue	O
;	O
}	O
SET_LINK	function
(	O
x	pointer
,	O
f	O
)	O
;	O
make_free	function
(	O
x	pointer
)	O
;	O
f	O
=	O
x	pointer
;	O
k	O
++	O
;	O
}	O
tm	pointer
->	O
tm_free	O
=	O
f	O
;	O
tm	pointer
->	O
tm_nfree	O
+=	O
k	O
;	O
pagetoinfo	function
(	O
page	function
(	O
v	pointer
)	O
)	O
->	O
in_use	O
-=	O
k	O
;	O
}	O
}	O
static	O
void	O
contblock_sweep_phase	function
(	O
void	O
)	O
{	O
STATIC	O
char	O
*	O
s	int
,	O
*	O
e	O
,	O
*	O
p	pointer
,	O
*	O
q	pointer
;	O
STATIC	O
struct	O
contblock	O
*	O
cbp	O
;	O
STATIC	O
struct	O
pageinfo	O
*	O
v	pointer
;	O
cb_pointer	O
=	O
NULL	O
;	O
ncb	O
=	O
0	int
;	O
for	O
(	O
v	pointer
=	O
contblock_list_head	O
;	O
v	pointer
;	O
v	pointer
=	O
v	pointer
->	O
next	O
)	O
{	O
bool	O
z	O
;	O
s	int
=	O
CB_DATA_START	function
(	O
v	pointer
)	O
;	O
e	O
=	O
(	O
void	O
*	O
)	O
v	pointer
+	O
v	pointer
->	O
in_use	O
*	O
PAGESIZE	O
;	O
z	O
=	O
get_mark_bit	function
(	O
v	pointer
,	O
s	int
)	O
;	O
for	O
(	O
p	pointer
=	O
s	int
;	O
p	pointer
<	O
e	O
;	O
)	O
{	O
q	pointer
=	O
get_bits	function
(	O
CB_MARK_START	function
(	O
v	pointer
)	O
,	O
v	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
!	O
z	O
)	O
insert_contblock	function
(	O
p	pointer
,	O
q	pointer
-	O
p	pointer
)	O
;	O
z	O
=	O
1	int
-	O
z	O
;	O
p	pointer
=	O
q	pointer
;	O
}	O
bzero	function
(	O
CB_MARK_START	function
(	O
v	pointer
)	O
,	O
CB_SGCF_START	function
(	O
v	pointer
)	O
-	O
CB_MARK_START	function
(	O
v	pointer
)	O
)	O
;	O
}	O
if	O
(	O
debug	int
)	O
{	O
for	O
(	O
cbp	O
=	O
cb_pointer	O
;	O
cbp	O
!=	O
NULL	O
;	O
cbp	O
=	O
cbp	O
->	O
cb_link	O
)	O
printf	O
(	O
"%d-byte contblock\n"	pointer
,	O
cbp	O
->	O
cb_size	O
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
}	O
sweep_link_array	function
(	O
)	O
;	O
}	O
int	O
(	O
*	O
GBC_enter_hook	pointer
)	O
(	O
)	O
=	O
NULL	O
;	O
int	O
(	O
*	O
GBC_exit_hook	pointer
)	O
(	O
)	O
=	O
NULL	O
;	O
char	O
*	O
old_rb_start	pointer
;	O
fixnum	O
fault_pages	int
=	O
0	int
;	O
void	O
GBC	function
(	O
enum	O
type	O
t	enum
)	O
{	O
long	O
i	int
,	O
j	pointer
;	O
int	O
tm	pointer
=	O
0	int
;	O
BEGIN_NO_INTERRUPT	O
;	O
if	O
(	O
t	enum
==	O
t_other	O
)	O
{	O
collect_both	int
=	O
1	int
;	O
t	enum
=	O
t_contiguous	O
;	O
}	O
if	O
(	O
in_signal_handler	O
&&	O
t	enum
==	O
t_relocatable	O
)	O
error	function
(	O
"cant gc relocatable in signal handler"	pointer
)	O
;	O
if	O
(	O
GBC_enter_hook	pointer
!=	O
NULL	O
)	O
(	O
*	O
GBC_enter_hook	pointer
)	O
(	O
)	O
;	O
if	O
(	O
!	O
GBC_enable	O
)	O
error	function
(	O
"GBC is not enabled"	pointer
)	O
;	O
interrupt_enable	O
=	O
FALSE	O
;	O
if	O
(	O
saving_system	O
)	O
{	O
struct	O
pageinfo	O
*	O
v	pointer
;	O
void	O
*	O
x	pointer
;	O
struct	O
typemanager	O
*	O
tm	pointer
=	O
tm_of	function
(	O
t_stream	O
)	O
;	O
unsigned	O
j	pointer
;	O
for	O
(	O
v	pointer
=	O
cell_list_head	O
;	O
v	pointer
;	O
v	pointer
=	O
v	pointer
->	O
next	O
)	O
if	O
(	O
tm	pointer
->	O
tm_type	O
==	O
v	pointer
->	O
type	O
)	O
for	O
(	O
x	pointer
=	O
pagetochar	function
(	O
page	function
(	O
v	pointer
)	O
)	O
,	O
j	pointer
=	O
tm	pointer
->	O
tm_nppage	O
;	O
j	pointer
--	O
;	O
x	pointer
+=	O
tm	pointer
->	O
tm_size	O
)	O
{	O
object	O
o	O
=	O
x	pointer
;	O
if	O
(	O
type_of	function
(	O
o	O
)	O
==	O
t_stream	O
&&	O
!	O
is_free	function
(	O
o	O
)	O
&&	O
o	O
->	O
sm	O
.	O
sm_fp	O
&&	O
o	O
->	O
sm	O
.	O
sm_fp	O
!=	O
stdin	O
&&	O
o	O
->	O
sm	O
.	O
sm_fp	O
!=	O
stdout	O
)	O
close_stream	function
(	O
o	O
)	O
;	O
}	O
t	enum
=	O
t_relocatable	O
;	O
gc_time	int
=	O
-	O
1	int
;	O
}	O
debug	int
=	O
symbol_value	function
(	O
sSAgbc_messageA	int
)	O
!=	O
Cnil	O
;	O
what_to_collect	enum
=	O
t	enum
;	O
tm_table	O
[	O
(	O
int	O
)	O
t	enum
]	O
.	O
tm_gbccount	O
++	O
;	O
tm_table	O
[	O
(	O
int	O
)	O
t	enum
]	O
.	O
tm_adjgbccnt	O
++	O
;	O
if	O
(	O
debug	int
||	O
(	O
sSAnotify_gbcA	int
->	O
s	int
.	O
s_dbind	O
!=	O
Cnil	O
)	O
)	O
{	O
if	O
(	O
gc_time	int
<	O
0	int
)	O
gc_time	int
=	O
0	int
;	O
printf	O
(	O
"[%s for %ld %s pages.."	pointer
,	O
(	O
"GC"	pointer
)	O
,	O
(	O
tm_of	function
(	O
t	enum
)	O
->	O
tm_npage	O
)	O
,	O
(	O
tm_table	O
[	O
(	O
int	O
)	O
t	enum
]	O
.	O
tm_name	O
)	O
+	O
1	int
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
}	O
if	O
(	O
gc_time	int
>=	O
0	int
&&	O
!	O
gc_recursive	int
++	O
)	O
{	O
gc_start	int
=	O
runtime	function
(	O
)	O
;	O
}	O
if	O
(	O
COLLECT_RELBLOCK_P	O
)	O
{	O
i	int
=	O
rb_pointer	O
-	O
REAL_RB_START	O
+	O
PAGESIZE	O
;	O
rb_start	O
=	O
heap_end	O
+	O
PAGESIZE	O
*	O
holepage	O
;	O
rb_end	O
=	O
heap_end	O
+	O
(	O
holepage	O
+	O
nrbpage	O
)	O
*	O
PAGESIZE	O
;	O
if	O
(	O
rb_start	O
<	O
rb_pointer	O
)	O
rb_start1	O
=	O
(	O
char	O
*	O
)	O
(	O
(	O
long	O
)	O
(	O
rb_pointer	O
+	O
PAGESIZE	O
-	O
1	int
)	O
&	O
-	O
(	O
unsigned	O
long	O
)	O
PAGESIZE	O
)	O
;	O
else	O
rb_start1	O
=	O
rb_start	O
;	O
rb_pointer	O
=	O
rb_start	O
;	O
rb_pointer1	O
=	O
rb_start1	O
;	O
i	int
=	O
(	O
rb_end	O
<	O
(	O
rb_start1	O
+	O
i	int
)	O
?	O
(	O
rb_start1	O
+	O
i	int
)	O
:	O
rb_end	O
)	O
-	O
heap_end	O
;	O
alloc_page	function
(	O
-	O
(	O
i	int
+	O
PAGESIZE	O
-	O
1	int
)	O
/	O
PAGESIZE	O
)	O
;	O
}	O
if	O
(	O
debug	int
)	O
{	O
printf	O
(	O
"mark phase\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
tm	pointer
=	O
runtime	function
(	O
)	O
;	O
}	O
mark_phase	function
(	O
)	O
;	O
if	O
(	O
debug	int
)	O
{	O
printf	O
(	O
"mark ended (%d)\n"	pointer
,	O
runtime	function
(	O
)	O
-	O
tm	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
}	O
if	O
(	O
debug	int
)	O
{	O
printf	O
(	O
"sweep phase\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
tm	pointer
=	O
runtime	function
(	O
)	O
;	O
}	O
sweep_phase	function
(	O
)	O
;	O
if	O
(	O
debug	int
)	O
{	O
printf	O
(	O
"sweep ended (%d)\n"	pointer
,	O
runtime	function
(	O
)	O
-	O
tm	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
}	O
if	O
(	O
COLLECT_RELBLOCK_P	O
)	O
{	O
if	O
(	O
rb_start	O
<	O
rb_start1	O
)	O
{	O
j	pointer
=	O
(	O
rb_pointer	O
-	O
rb_start	O
+	O
PAGESIZE	O
-	O
1	int
)	O
/	O
PAGESIZE	O
;	O
memmove	function
(	O
rb_start	O
,	O
rb_start1	O
,	O
j	pointer
*	O
PAGESIZE	O
)	O
;	O
}	O
rb_limit	O
=	O
rb_end	O
-	O
2	int
*	O
RB_GETA	O
;	O
}	O
if	O
(	O
t	enum
==	O
t_contiguous	O
)	O
{	O
if	O
(	O
debug	int
)	O
{	O
printf	O
(	O
"contblock sweep phase\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
tm	pointer
=	O
runtime	function
(	O
)	O
;	O
}	O
contblock_sweep_phase	function
(	O
)	O
;	O
if	O
(	O
debug	int
)	O
printf	O
(	O
"contblock sweep ended (%d)\n"	pointer
,	O
runtime	function
(	O
)	O
-	O
tm	pointer
)	O
;	O
}	O
if	O
(	O
debug	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
,	O
j	pointer
=	O
0	int
;	O
i	int
<	O
(	O
int	O
)	O
t_end	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
tm_table	O
[	O
i	int
]	O
.	O
tm_type	O
==	O
(	O
enum	O
type	O
)	O
i	int
)	O
{	O
printf	O
(	O
"%13s: %8ld used %8ld free %4ld/%ld pages\n"	pointer
,	O
tm_table	O
[	O
i	int
]	O
.	O
tm_name	O
,	O
TM_NUSED	function
(	O
tm_table	O
[	O
i	int
]	O
)	O
,	O
tm_table	O
[	O
i	int
]	O
.	O
tm_nfree	O
,	O
tm_table	O
[	O
i	int
]	O
.	O
tm_npage	O
,	O
tm_table	O
[	O
i	int
]	O
.	O
tm_maxpage	O
)	O
;	O
j	pointer
+=	O
tm_table	O
[	O
i	int
]	O
.	O
tm_npage	O
;	O
}	O
else	O
printf	O
(	O
"%13s: linked to %s\n"	pointer
,	O
tm_table	O
[	O
i	int
]	O
.	O
tm_name	O
,	O
tm_table	O
[	O
(	O
int	O
)	O
tm_table	O
[	O
i	int
]	O
.	O
tm_type	O
]	O
.	O
tm_name	O
)	O
;	O
}	O
printf	O
(	O
"contblock: %ld blocks %ld pages\n"	pointer
,	O
ncb	O
,	O
ncbpage	O
)	O
;	O
printf	O
(	O
"hole: %ld pages\n"	pointer
,	O
holepage	O
)	O
;	O
printf	O
(	O
"relblock: %ld bytes used %ld bytes free %ld pages\n"	pointer
,	O
(	O
long	O
)	O
(	O
rb_pointer	O
-	O
rb_start	O
)	O
,	O
(	O
long	O
)	O
(	O
rb_end	O
-	O
rb_pointer	O
)	O
,	O
nrbpage	O
)	O
;	O
printf	O
(	O
"GBC ended\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
}	O
interrupt_enable	O
=	O
TRUE	O
;	O
if	O
(	O
GBC_exit_hook	pointer
!=	O
NULL	O
)	O
(	O
*	O
GBC_exit_hook	pointer
)	O
(	O
)	O
;	O
if	O
(	O
gc_time	int
>=	O
0	int
&&	O
!	O
--	O
gc_recursive	int
)	O
{	O
gc_time	int
=	O
gc_time	int
+	O
(	O
gc_start	int
=	O
(	O
runtime	function
(	O
)	O
-	O
gc_start	int
)	O
)	O
;	O
}	O
if	O
(	O
sSAnotify_gbcA	int
->	O
s	int
.	O
s_dbind	O
!=	O
Cnil	O
)	O
{	O
if	O
(	O
gc_recursive	int
)	O
fprintf	function
(	O
stdout	O
,	O
"(T=...).GC finished]\n"	pointer
)	O
;	O
else	O
fprintf	function
(	O
stdout	O
,	O
"(T=%d).GC finished]\n"	pointer
,	O
gc_start	int
)	O
;	O
fflush	function
(	O
stdout	O
)	O
;	O
}	O
{	O
extern	O
long	O
opt_maxpage	function
(	O
struct	O
typemanager	O
*	O
)	O
;	O
if	O
(	O
IGNORE_MAX_PAGES	O
&&	O
OPTIMIZE_MAX_PAGES	O
)	O
opt_maxpage	function
(	O
tm_table	O
+	O
t	enum
)	O
;	O
}	O
collect_both	int
=	O
0	int
;	O
END_NO_INTERRUPT	O
;	O
CHECK_INTERRUPT	O
;	O
}	O
static	O
void	O
FFN	function
(	O
siLheap_report	int
)	O
(	O
void	O
)	O
{	O
int	O
i	int
;	O
check_arg	function
(	O
0	int
)	O
;	O
vs_check_push	function
(	O
make_fixnum	function
(	O
sizeof	O
(	O
fixnum	O
)	O
*	O
CHAR_SIZE	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
PAGESIZE	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
(	O
ufixnum	O
)	O
data_start	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
(	O
ufixnum	O
)	O
data_start	O
+	O
(	O
real_maxpage	long
<<	O
PAGEWIDTH	O
)	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
0	int
)	O
)	O
;	O
i	int
=	O
sizeof	O
(	O
fixnum	O
)	O
*	O
CHAR_SIZE	O
-	O
2	int
;	O
i	int
=	O
1	int
<<	O
i	int
;	O
vs_push	function
(	O
make_fixnum	function
(	O
(	O
(	O
unsigned	O
long	O
)	O
cs_base	O
+	O
i	int
-	O
1	int
)	O
&	O
-	O
i	int
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
abs	function
(	O
cs_base	O
-	O
cs_org	O
)	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
(	O
CSTACK_DIRECTION	O
+	O
1	int
)	O
>>	O
1	int
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
CSTACK_ALIGNMENT	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
abs	function
(	O
cs_limit	O
-	O
cs_org	O
)	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
0	int
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
0	int
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
phys_pages	O
)	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
siLroom_report	int
)	O
(	O
void	O
)	O
{	O
int	O
i	int
;	O
check_arg	function
(	O
0	int
)	O
;	O
vs_check_push	function
(	O
make_fixnum	function
(	O
real_maxpage	long
-	O
first_data_page	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
available_pages	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
ncbpage	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
maxcbpage	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
ncb	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
cbgbccount	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
holepage	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
rb_pointer	O
-	O
rb_start	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
rb_end	O
-	O
rb_pointer	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
nrbpage	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
maxrbpage	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
rbgbccount	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
int	O
)	O
t_end	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
tm_table	O
[	O
i	int
]	O
.	O
tm_type	O
==	O
(	O
enum	O
type	O
)	O
i	int
)	O
{	O
vs_check_push	function
(	O
make_fixnum	function
(	O
TM_NUSED	function
(	O
tm_table	O
[	O
i	int
]	O
)	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
tm_table	O
[	O
i	int
]	O
.	O
tm_nfree	O
+	O
tm_table	O
[	O
i	int
]	O
.	O
tm_alt_nfree	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
tm_table	O
[	O
i	int
]	O
.	O
tm_npage	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
tm_table	O
[	O
i	int
]	O
.	O
tm_maxpage	O
)	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
tm_table	O
[	O
i	int
]	O
.	O
tm_gbccount	O
)	O
)	O
;	O
}	O
else	O
{	O
vs_check_push	function
(	O
Cnil	O
)	O
;	O
vs_push	function
(	O
make_fixnum	function
(	O
tm_table	O
[	O
i	int
]	O
.	O
tm_type	O
)	O
)	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
vs_push	function
(	O
Cnil	O
)	O
;	O
}	O
}	O
}	O
static	O
void	O
FFN	function
(	O
siLreset_gbc_count	int
)	O
(	O
void	O
)	O
{	O
int	O
i	int
;	O
check_arg	function
(	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
t_other	O
;	O
i	int
++	O
)	O
tm_table	O
[	O
i	int
]	O
.	O
tm_gbccount	O
=	O
tm_table	O
[	O
i	int
]	O
.	O
tm_adjgbccnt	O
=	O
tm_table	O
[	O
i	int
]	O
.	O
tm_opt_maxpage	O
=	O
0	int
;	O
}	O
static	O
char	O
*	O
copy_relblock	function
(	O
char	O
*	O
p	pointer
,	O
int	O
s	int
)	O
{	O
char	O
*	O
res	pointer
=	O
rb_pointer	O
;	O
char	O
*	O
q	pointer
=	O
rb_pointer1	O
;	O
s	int
=	O
ROUND_UP_PTR	function
(	O
s	int
)	O
;	O
rb_pointer	O
+=	O
s	int
;	O
rb_pointer1	O
+=	O
s	int
;	O
memmove	function
(	O
q	pointer
,	O
p	pointer
,	O
s	int
)	O
;	O
return	O
res	pointer
;	O
}	O
static	O
void	O
mark_contblock	function
(	O
void	O
*	O
p	pointer
,	O
int	O
s	int
)	O
{	O
STATIC	O
char	O
*	O
q	pointer
;	O
STATIC	O
char	O
*	O
x	pointer
,	O
*	O
y	O
;	O
struct	O
pageinfo	O
*	O
v	pointer
;	O
if	O
(	O
NULL_OR_ON_C_STACK	function
(	O
p	pointer
)	O
)	O
return	O
;	O
q	pointer
=	O
p	pointer
+	O
s	int
;	O
x	pointer
=	O
(	O
char	O
*	O
)	O
ROUND_DOWN_PTR_CONT	function
(	O
p	pointer
)	O
;	O
y	O
=	O
(	O
char	O
*	O
)	O
ROUND_UP_PTR_CONT	function
(	O
q	pointer
)	O
;	O
v	pointer
=	O
get_pageinfo	function
(	O
x	pointer
)	O
;	O
set_mark_bits	function
(	O
v	pointer
,	O
x	pointer
,	O
y	O
)	O
;	O
}	O
DEFUN_NEW	function
(	O
"GBC"	pointer
,	O
object	O
,	O
fLgbc	O
,	O
LISP	O
,	O
1	int
,	O
1	int
,	O
NONE	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
OO	O
,	O
(	O
object	O
x0	O
)	O
,	O
""	pointer
)	O
{	O
if	O
(	O
x0	O
==	O
Ct	O
)	O
GBC	function
(	O
t_other	O
)	O
;	O
else	O
if	O
(	O
x0	O
==	O
Cnil	O
)	O
GBC	function
(	O
t_cons	O
)	O
;	O
else	O
if	O
(	O
eql	function
(	O
small_fixnum	function
(	O
0	int
)	O
,	O
x0	O
)	O
)	O
GBC	function
(	O
t_contiguous	O
)	O
;	O
else	O
{	O
x0	O
=	O
small_fixnum	function
(	O
1	int
)	O
;	O
GBC	function
(	O
t_relocatable	O
)	O
;	O
}	O
RETURN1	function
(	O
x0	O
)	O
;	O
}	O
static	O
void	O
FFN	function
(	O
siLgbc_time	int
)	O
(	O
void	O
)	O
{	O
if	O
(	O
vs_top	O
>	O
vs_base	O
)	O
gc_time	int
=	O
fix	function
(	O
vs_base	O
[	O
0	int
]	O
)	O
;	O
else	O
{	O
vs_base	O
[	O
0	int
]	O
=	O
make_fixnum	function
(	O
gc_time	int
)	O
;	O
vs_top	O
=	O
vs_base	O
+	O
1	int
;	O
}	O
}	O
DEFVAR	function
(	O
"*NOTIFY-GBC*"	pointer
,	O
sSAnotify_gbcA	int
,	O
SI	O
,	O
Cnil	O
,	O
""	pointer
)	O
;	O
DEFVAR	function
(	O
"*GBC-MESSAGE*"	pointer
,	O
sSAgbc_messageA	int
,	O
SI	O
,	O
Cnil	O
,	O
""	pointer
)	O
;	O
void	O
gcl_init_GBC	function
(	O
void	O
)	O
{	O
make_si_function	function
(	O
"HEAP-REPORT"	pointer
,	O
siLheap_report	int
)	O
;	O
make_si_function	function
(	O
"ROOM-REPORT"	pointer
,	O
siLroom_report	int
)	O
;	O
make_si_function	function
(	O
"RESET-GBC-COUNT"	pointer
,	O
siLreset_gbc_count	int
)	O
;	O
make_si_function	function
(	O
"GBC-TIME"	pointer
,	O
siLgbc_time	int
)	O
;	O
}	O
