static	O
double	O
transport2_data	array
[	O
18	int
]	O
=	O
{	O
1.671760446434538503	int
,	O
-	O
0.147735359946794490	int
,	O
0.148213819946936338e-01	int
,	O
-	O
0.14195330326305613e-02	int
,	O
0.1306541324415708e-03	int
,	O
-	O
0.117155795867579e-04	int
,	O
0.10333498445756e-05	int
,	O
-	O
0.901911304223e-07	int
,	O
0.78177169833e-08	int
,	O
-	O
0.6744565684e-09	int
,	O
0.579946394e-10	int
,	O
-	O
0.49747619e-11	int
,	O
0.425961e-12	int
,	O
-	O
0.36422e-13	int
,	O
0.3111e-14	int
,	O
-	O
0.265e-15	int
,	O
0.23e-16	int
,	O
-	O
0.19e-17	int
}	O
;	O
static	O
cheb_series	struct
transport2_cs	struct
=	O
{	O
transport2_data	array
,	O
17	int
,	O
-	O
1	int
,	O
1	int
,	O
9	int
}	O
;	O
static	O
double	O
transport3_data	array
[	O
18	int
]	O
=	O
{	O
0.762012543243872007	int
,	O
-	O
0.105674387705058533	int
,	O
0.119778084819657810e-01	int
,	O
-	O
0.12144015203698307e-02	int
,	O
0.1155099769392855e-03	int
,	O
-	O
0.105815992124423e-04	int
,	O
0.9474663385302e-06	int
,	O
-	O
0.836221212858e-07	int
,	O
0.73109099278e-08	int
,	O
-	O
0.6350594779e-09	int
,	O
0.549118282e-10	int
,	O
-	O
0.47321395e-11	int
,	O
0.4067695e-12	int
,	O
-	O
0.348971e-13	int
,	O
0.29892e-14	int
,	O
-	O
0.256e-15	int
,	O
0.219e-16	int
,	O
-	O
0.19e-17	int
}	O
;	O
static	O
cheb_series	struct
transport3_cs	struct
=	O
{	O
transport3_data	array
,	O
17	int
,	O
-	O
1	int
,	O
1	int
,	O
9	int
}	O
;	O
static	O
double	O
transport4_data	array
[	O
18	int
]	O
=	O
{	O
0.4807570994615110579	int
,	O
-	O
0.8175378810321083956e-01	int
,	O
0.1002700665975162973e-01	int
,	O
-	O
0.10599339359820151e-02	int
,	O
0.1034506245030405e-03	int
,	O
-	O
0.96442705485899e-05	int
,	O
0.8745544408515e-06	int
,	O
-	O
0.779321207981e-07	int
,	O
0.68649886141e-08	int
,	O
-	O
0.5999571076e-09	int
,	O
0.521366241e-10	int
,	O
-	O
0.45118382e-11	int
,	O
0.3892159e-12	int
,	O
-	O
0.334936e-13	int
,	O
0.28767e-14	int
,	O
-	O
0.2467e-15	int
,	O
0.211e-16	int
,	O
-	O
0.18e-17	int
}	O
;	O
static	O
cheb_series	struct
transport4_cs	struct
=	O
{	O
transport4_data	array
,	O
17	int
,	O
-	O
1	int
,	O
1	int
,	O
9	int
}	O
;	O
static	O
double	O
transport5_data	array
[	O
18	int
]	O
=	O
{	O
0.347777777133910789	int
,	O
-	O
0.66456988976050428e-01	int
,	O
0.8611072656883309e-02	int
,	O
-	O
0.9396682223755538e-03	int
,	O
0.936324806081513e-04	int
,	O
-	O
0.88571319340833e-05	int
,	O
0.811914989145e-06	int
,	O
-	O
0.72957654233e-07	int
,	O
0.646971455e-08	int
,	O
-	O
0.568490283e-09	int
,	O
0.49625598e-10	int
,	O
-	O
0.4310940e-11	int
,	O
0.373100e-12	int
,	O
-	O
0.32198e-13	int
,	O
0.2772e-14	int
,	O
-	O
0.238e-15	int
,	O
0.21e-16	int
,	O
-	O
0.18e-17	int
}	O
;	O
static	O
cheb_series	struct
transport5_cs	struct
=	O
{	O
transport5_data	array
,	O
17	int
,	O
-	O
1	int
,	O
1	int
,	O
9	int
}	O
;	O
static	O
double	O
transport_sumexp	function
(	O
const	O
int	O
numexp	int
,	O
const	O
int	O
order	int
,	O
const	O
double	O
t	double
,	O
double	O
x	double
)	O
{	O
double	O
rk	double
=	O
(	O
double	O
)	O
numexp	int
;	O
double	O
sumexp	double
=	O
0.0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
numexp	int
;	O
k	int
++	O
)	O
{	O
double	O
sum2	double
=	O
1.0	int
;	O
double	O
xk	double
=	O
1.0	int
/	O
(	O
rk	double
*	O
x	double
)	O
;	O
double	O
xk1	double
=	O
1.0	int
;	O
int	O
j	int
;	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<=	O
order	int
;	O
j	int
++	O
)	O
{	O
sum2	double
=	O
sum2	double
*	O
xk1	double
*	O
xk	double
+	O
1.0	int
;	O
xk1	double
+=	O
1.0	int
;	O
}	O
sumexp	double
*=	O
t	double
;	O
sumexp	double
+=	O
sum2	double
;	O
rk	double
-=	O
1.0	int
;	O
}	O
return	O
sumexp	double
;	O
}	O
int	O
gsl_sf_transport_2_e	function
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
double	O
val_infinity	double
=	O
3.289868133696452873	int
;	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
<	O
3.0	int
*	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
result	pointer
->	O
val	double
=	O
x	double
;	O
result	pointer
->	O
err	double
=	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
x	double
)	O
+	O
x	double
*	O
x	double
/	O
2.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<=	O
4.0	int
)	O
{	O
double	O
t	double
=	O
(	O
x	double
*	O
x	double
/	O
8.0	int
-	O
0.5	int
)	O
-	O
0.5	int
;	O
gsl_sf_result	struct
result_c	struct
;	O
cheb_eval_e	function
(	O
&	O
transport2_cs	struct
,	O
t	double
,	O
&	O
result_c	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
x	double
*	O
result_c	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
x	double
*	O
result_c	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
-	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
const	O
int	O
numexp	int
=	O
(	O
int	O
)	O
(	O
(	O
-	O
GSL_LOG_DBL_EPSILON	O
)	O
/	O
x	double
)	O
+	O
1	int
;	O
const	O
double	O
sumexp	double
=	O
transport_sumexp	function
(	O
numexp	int
,	O
2	int
,	O
exp	function
(	O
-	O
x	double
)	O
,	O
x	double
)	O
;	O
const	O
double	O
t	double
=	O
2.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
+	O
log	function
(	O
sumexp	double
)	O
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
fabs	function
(	O
t	double
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
2.0	int
/	O
GSL_DBL_EPSILON	int
)	O
{	O
const	O
int	O
numexp	int
=	O
1	int
;	O
const	O
double	O
sumexp	double
=	O
transport_sumexp	function
(	O
numexp	int
,	O
2	int
,	O
1.0	int
,	O
x	double
)	O
;	O
const	O
double	O
t	double
=	O
2.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
+	O
log	function
(	O
sumexp	double
)	O
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
(	O
fabs	function
(	O
t	double
)	O
+	O
1.0	int
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
t	double
=	O
2.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
(	O
fabs	function
(	O
t	double
)	O
+	O
1.0	int
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_transport_3_e	function
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
double	O
val_infinity	double
=	O
7.212341418957565712	int
;	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
3.0	int
*	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.5	int
*	O
x	double
*	O
x	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
result	pointer
->	O
val	double
;	O
CHECK_UNDERFLOW	O
(	O
result	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<=	O
4.0	int
)	O
{	O
const	O
double	O
x2	double
=	O
x	double
*	O
x	double
;	O
const	O
double	O
t	double
=	O
(	O
x2	double
/	O
8.0	int
-	O
0.5	int
)	O
-	O
0.5	int
;	O
gsl_sf_result	struct
result_c	struct
;	O
cheb_eval_e	function
(	O
&	O
transport3_cs	struct
,	O
t	double
,	O
&	O
result_c	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
x2	double
*	O
result_c	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
x2	double
*	O
result_c	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
-	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
const	O
int	O
numexp	int
=	O
(	O
int	O
)	O
(	O
(	O
-	O
GSL_LOG_DBL_EPSILON	O
)	O
/	O
x	double
)	O
+	O
1	int
;	O
const	O
double	O
sumexp	double
=	O
transport_sumexp	function
(	O
numexp	int
,	O
3	int
,	O
exp	function
(	O
-	O
x	double
)	O
,	O
x	double
)	O
;	O
const	O
double	O
t	double
=	O
3.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
+	O
log	function
(	O
sumexp	double
)	O
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
fabs	function
(	O
t	double
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
3.0	int
/	O
GSL_DBL_EPSILON	int
)	O
{	O
const	O
int	O
numexp	int
=	O
1	int
;	O
const	O
double	O
sumexp	double
=	O
transport_sumexp	function
(	O
numexp	int
,	O
3	int
,	O
1.0	int
,	O
x	double
)	O
;	O
const	O
double	O
t	double
=	O
3.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
+	O
log	function
(	O
sumexp	double
)	O
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
(	O
fabs	function
(	O
t	double
)	O
+	O
1.0	int
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
t	double
=	O
3.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
(	O
fabs	function
(	O
t	double
)	O
+	O
1.0	int
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_transport_4_e	function
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
double	O
val_infinity	double
=	O
25.97575760906731660	int
;	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
3.0	int
*	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
result	pointer
->	O
val	double
=	O
x	double
*	O
x	double
*	O
x	double
/	O
3.0	int
;	O
result	pointer
->	O
err	double
=	O
3.0	int
*	O
GSL_DBL_EPSILON	int
*	O
result	pointer
->	O
val	double
;	O
CHECK_UNDERFLOW	O
(	O
result	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<=	O
4.0	int
)	O
{	O
const	O
double	O
x2	double
=	O
x	double
*	O
x	double
;	O
const	O
double	O
t	double
=	O
(	O
x2	double
/	O
8.0	int
-	O
0.5	int
)	O
-	O
0.5	int
;	O
gsl_sf_result	struct
result_c	struct
;	O
cheb_eval_e	function
(	O
&	O
transport4_cs	struct
,	O
t	double
,	O
&	O
result_c	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
x2	double
*	O
x	double
*	O
result_c	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
x2	double
*	O
x	double
*	O
result_c	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
-	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
const	O
int	O
numexp	int
=	O
(	O
int	O
)	O
(	O
(	O
-	O
GSL_LOG_DBL_EPSILON	O
)	O
/	O
x	double
)	O
+	O
1	int
;	O
const	O
double	O
sumexp	double
=	O
transport_sumexp	function
(	O
numexp	int
,	O
4	int
,	O
exp	function
(	O
-	O
x	double
)	O
,	O
x	double
)	O
;	O
const	O
double	O
t	double
=	O
4.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
+	O
log	function
(	O
sumexp	double
)	O
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
(	O
fabs	function
(	O
t	double
)	O
+	O
1.0	int
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
3.0	int
/	O
GSL_DBL_EPSILON	int
)	O
{	O
const	O
int	O
numexp	int
=	O
1	int
;	O
const	O
double	O
sumexp	double
=	O
transport_sumexp	function
(	O
numexp	int
,	O
4	int
,	O
1.0	int
,	O
x	double
)	O
;	O
const	O
double	O
t	double
=	O
4.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
+	O
log	function
(	O
sumexp	double
)	O
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
(	O
fabs	function
(	O
t	double
)	O
+	O
1.0	int
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
t	double
=	O
4.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
(	O
fabs	function
(	O
t	double
)	O
+	O
1.0	int
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
int	O
gsl_sf_transport_5_e	function
(	O
const	O
double	O
x	double
,	O
gsl_sf_result	struct
*	O
result	pointer
)	O
{	O
const	O
double	O
val_infinity	double
=	O
124.4313306172043912	int
;	O
if	O
(	O
x	double
<	O
0.0	int
)	O
{	O
DOMAIN_ERROR	O
(	O
result	pointer
)	O
;	O
}	O
else	O
if	O
(	O
x	double
==	O
0.0	int
)	O
{	O
result	pointer
->	O
val	double
=	O
0.0	int
;	O
result	pointer
->	O
err	double
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
3.0	int
*	O
GSL_SQRT_DBL_EPSILON	int
)	O
{	O
result	pointer
->	O
val	double
=	O
x	double
*	O
x	double
*	O
x	double
*	O
x	double
/	O
4.0	int
;	O
result	pointer
->	O
err	double
=	O
4.0	int
*	O
GSL_DBL_EPSILON	int
*	O
result	pointer
->	O
val	double
;	O
CHECK_UNDERFLOW	O
(	O
result	pointer
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<=	O
4.0	int
)	O
{	O
const	O
double	O
x2	double
=	O
x	double
*	O
x	double
;	O
const	O
double	O
t	double
=	O
(	O
x2	double
/	O
8.0	int
-	O
0.5	int
)	O
-	O
0.5	int
;	O
gsl_sf_result	struct
result_c	struct
;	O
cheb_eval_e	function
(	O
&	O
transport5_cs	struct
,	O
t	double
,	O
&	O
result_c	struct
)	O
;	O
result	pointer
->	O
val	double
=	O
x2	double
*	O
x2	double
*	O
result_c	struct
.	O
val	double
;	O
result	pointer
->	O
err	double
=	O
x2	double
*	O
x2	double
*	O
result_c	struct
.	O
err	double
;	O
result	pointer
->	O
err	double
+=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
fabs	function
(	O
result	pointer
->	O
val	double
)	O
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
-	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
const	O
int	O
numexp	int
=	O
(	O
int	O
)	O
(	O
(	O
-	O
GSL_LOG_DBL_EPSILON	O
)	O
/	O
x	double
)	O
+	O
1	int
;	O
const	O
double	O
sumexp	double
=	O
transport_sumexp	function
(	O
numexp	int
,	O
5	int
,	O
exp	function
(	O
-	O
x	double
)	O
,	O
x	double
)	O
;	O
const	O
double	O
t	double
=	O
5.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
+	O
log	function
(	O
sumexp	double
)	O
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
(	O
fabs	function
(	O
t	double
)	O
+	O
1.0	int
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
if	O
(	O
x	double
<	O
3.0	int
/	O
GSL_DBL_EPSILON	int
)	O
{	O
const	O
int	O
numexp	int
=	O
1	int
;	O
const	O
double	O
sumexp	double
=	O
transport_sumexp	function
(	O
numexp	int
,	O
5	int
,	O
1.0	int
,	O
x	double
)	O
;	O
const	O
double	O
t	double
=	O
5.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
+	O
log	function
(	O
sumexp	double
)	O
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
(	O
fabs	function
(	O
t	double
)	O
+	O
1.0	int
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
else	O
{	O
const	O
double	O
t	double
=	O
5.0	int
*	O
log	function
(	O
x	double
)	O
-	O
x	double
;	O
if	O
(	O
t	double
<	O
GSL_LOG_DBL_EPSILON	O
)	O
{	O
result	pointer
->	O
val	double
=	O
val_infinity	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
val_infinity	double
;	O
}	O
else	O
{	O
const	O
double	O
et	double
=	O
exp	function
(	O
t	double
)	O
;	O
result	pointer
->	O
val	double
=	O
val_infinity	double
-	O
et	double
;	O
result	pointer
->	O
err	double
=	O
2.0	int
*	O
GSL_DBL_EPSILON	int
*	O
(	O
val_infinity	double
+	O
(	O
fabs	function
(	O
t	double
)	O
+	O
1.0	int
)	O
*	O
et	double
)	O
;	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
}	O
double	O
gsl_sf_transport_2	function
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_transport_2_e	function
(	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_transport_3	function
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_transport_3_e	function
(	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_transport_4	function
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_transport_4_e	function
(	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
double	O
gsl_sf_transport_5	function
(	O
const	O
double	O
x	double
)	O
{	O
EVAL_RESULT	O
(	O
gsl_sf_transport_5_e	function
(	O
x	double
,	O
&	O
result	pointer
)	O
)	O
;	O
}	O
