static	O
bool	bool
quiet	bool
;	O
static	O
int	O
verbosity_level	int
;	O
static	O
int	O
force_po	int
;	O
static	O
bool	bool
multi_domain_mode	bool
=	O
false	int
;	O
static	O
bool	bool
for_msgfmt	bool
=	O
false	int
;	O
static	O
bool	bool
use_fuzzy_matching	bool
=	O
true	int
;	O
static	O
bool	bool
keep_previous	bool
=	O
false	int
;	O
static	O
const	O
char	O
*	O
catalogname	pointer
=	O
NULL	O
;	O
static	O
message_list_list_ty	struct
*	O
compendiums	pointer
;	O
static	O
string_list_ty	struct
*	O
compendium_filenames	pointer
;	O
static	O
bool	bool
update_mode	bool
=	O
false	int
;	O
static	O
const	O
char	O
*	O
version_control_string	pointer
;	O
static	O
const	O
char	O
*	O
backup_suffix_string	pointer
;	O
static	O
const	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"add-location"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"backup"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
1	int
}	O
,	O
{	O
"color"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
9	int
}	O
,	O
{	O
"compendium"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'C'	O
}	O
,	O
{	O
"directory"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'D'	O
}	O
,	O
{	O
"escape"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'E'	O
}	O
,	O
{	O
"for-msgfmt"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
12	int
}	O
,	O
{	O
"force-po"	pointer
,	O
no_argument	int
,	O
&	O
force_po	int
,	O
1	int
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"indent"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"lang"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
8	int
}	O
,	O
{	O
"multi-domain"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'm'	O
}	O
,	O
{	O
"no-escape"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
{	O
"no-fuzzy-matching"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'N'	O
}	O
,	O
{	O
"no-location"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
11	int
}	O
,	O
{	O
"no-wrap"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
4	int
}	O
,	O
{	O
"output-file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"previous"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
7	int
}	O
,	O
{	O
"properties-input"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'P'	O
}	O
,	O
{	O
"properties-output"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'p'	O
}	O
,	O
{	O
"quiet"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
{	O
"sort-by-file"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
{	O
"sort-output"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"silent"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
{	O
"strict"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
2	int
}	O
,	O
{	O
"stringtable-input"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
5	int
}	O
,	O
{	O
"stringtable-output"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
6	int
}	O
,	O
{	O
"style"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
10	int
}	O
,	O
{	O
"suffix"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
CHAR_MAX	O
+	O
3	int
}	O
,	O
{	O
"update"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'U'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
"width"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'w'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
struct	O
statistics	struct
{	O
size_t	long
merged	long
;	O
size_t	long
fuzzied	long
;	O
size_t	long
missing	long
;	O
size_t	long
obsolete	bool
;	O
}	O
;	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
__attribute__	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
static	O
void	O
compendium	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
;	O
static	O
void	O
msgdomain_list_stablesort_by_obsolete	function
(	O
msgdomain_list_ty	struct
*	O
mdlp	pointer
)	O
;	O
static	O
msgdomain_list_ty	struct
*	O
merge	function
(	O
const	O
char	O
*	O
fn1	pointer
,	O
const	O
char	O
*	O
fn2	pointer
,	O
catalog_input_format_ty	pointer
input_syntax	pointer
,	O
msgdomain_list_ty	struct
*	O
*	O
defp	pointer
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
opt	int
;	O
bool	bool
do_help	bool
;	O
bool	bool
do_version	bool
;	O
char	O
*	O
output_file	pointer
;	O
char	O
*	O
color	int
;	O
msgdomain_list_ty	struct
*	O
def	pointer
;	O
msgdomain_list_ty	struct
*	O
result	pointer
;	O
catalog_input_format_ty	pointer
input_syntax	pointer
=	O
&	O
input_format_po	struct
;	O
catalog_output_format_ty	pointer
output_syntax	pointer
=	O
&	O
output_format_po	struct
;	O
bool	bool
sort_by_filepos	bool
=	O
false	int
;	O
bool	bool
sort_by_msgid	bool
=	O
false	int
;	O
set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
error_print_progname	pointer
=	O
maybe_print_progname	function
;	O
verbosity_level	int
=	O
0	int
;	O
quiet	bool
=	O
false	int
;	O
gram_max_allowed_errors	int
=	O
UINT_MAX	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
PACKAGE	pointer
,	O
relocate	O
(	O
LOCALEDIR	O
)	O
)	O
;	O
bindtextdomain	function
(	O
"bison-runtime"	pointer
,	O
relocate	O
(	O
BISON_LOCALEDIR	O
)	O
)	O
;	O
textdomain	function
(	O
PACKAGE	pointer
)	O
;	O
atexit	function
(	O
close_stdout	function
)	O
;	O
do_help	bool
=	O
false	int
;	O
do_version	bool
=	O
false	int
;	O
output_file	pointer
=	O
NULL	O
;	O
color	int
=	O
NULL	O
;	O
while	O
(	O
(	O
opt	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"C:D:eEFhimn:No:pPqsUvVw:"	pointer
,	O
long_options	array
,	O
NULL	O
)	O
)	O
!=	O
EOF	O
)	O
switch	O
(	O
opt	int
)	O
{	O
case	O
'\0'	O
:	O
break	O
;	O
case	O
'C'	O
:	O
compendium	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
dir_list_append	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
message_print_style_escape	function
(	O
false	int
)	O
;	O
break	O
;	O
case	O
'E'	O
:	O
message_print_style_escape	function
(	O
true	int
)	O
;	O
break	O
;	O
case	O
'F'	O
:	O
sort_by_filepos	bool
=	O
true	int
;	O
break	O
;	O
case	O
'h'	O
:	O
do_help	bool
=	O
true	int
;	O
break	O
;	O
case	O
'i'	O
:	O
message_print_style_indent	function
(	O
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
multi_domain_mode	bool
=	O
true	int
;	O
break	O
;	O
case	O
'n'	O
:	O
if	O
(	O
handle_filepos_comment_option	function
(	O
optarg	pointer
)	O
)	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
use_fuzzy_matching	bool
=	O
false	int
;	O
break	O
;	O
case	O
'o'	O
:	O
output_file	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'p'	O
:	O
output_syntax	pointer
=	O
&	O
output_format_properties	struct
;	O
break	O
;	O
case	O
'P'	O
:	O
input_syntax	pointer
=	O
&	O
input_format_properties	struct
;	O
break	O
;	O
case	O
'q'	O
:	O
quiet	bool
=	O
true	int
;	O
break	O
;	O
case	O
's'	O
:	O
sort_by_msgid	bool
=	O
true	int
;	O
break	O
;	O
case	O
'U'	O
:	O
update_mode	bool
=	O
true	int
;	O
break	O
;	O
case	O
'v'	O
:	O
++	O
verbosity_level	int
;	O
break	O
;	O
case	O
'V'	O
:	O
do_version	bool
=	O
true	int
;	O
break	O
;	O
case	O
'w'	O
:	O
{	O
int	O
value	int
;	O
char	O
*	O
endp	pointer
;	O
value	int
=	O
strtol	function
(	O
optarg	pointer
,	O
&	O
endp	pointer
,	O
10	int
)	O
;	O
if	O
(	O
endp	pointer
!=	O
optarg	pointer
)	O
message_page_width_set	function
(	O
value	int
)	O
;	O
}	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
1	int
:	O
version_control_string	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
2	int
:	O
message_print_style_uniforum	function
(	O
)	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
3	int
:	O
backup_suffix_string	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
4	int
:	O
message_page_width_ignore	function
(	O
)	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
5	int
:	O
input_syntax	pointer
=	O
&	O
input_format_stringtable	struct
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
6	int
:	O
output_syntax	pointer
=	O
&	O
output_format_stringtable	struct
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
7	int
:	O
keep_previous	bool
=	O
true	int
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
8	int
:	O
catalogname	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
9	int
:	O
if	O
(	O
handle_color_option	function
(	O
optarg	pointer
)	O
||	O
color_test_mode	bool
)	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
color	int
=	O
optarg	pointer
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
10	int
:	O
handle_style_option	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
11	int
:	O
message_print_style_filepos	function
(	O
filepos_comment_none	int
)	O
;	O
break	O
;	O
case	O
CHAR_MAX	O
+	O
12	int
:	O
for_msgfmt	bool
=	O
true	int
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
do_version	bool
)	O
{	O
printf	function
(	O
"%s (GNU %s) %s\n"	pointer
,	O
basename	function
(	O
program_name	pointer
)	O
,	O
PACKAGE	pointer
,	O
VERSION	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Copyright (C) %s Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n"	pointer
)	O
,	O
"1995-2019"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Written by %s.\n"	pointer
)	O
,	O
proper_name	function
(	O
"Peter Miller"	pointer
)	O
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
do_help	bool
)	O
usage	function
(	O
EXIT_SUCCESS	int
)	O
;	O
if	O
(	O
optind	int
>=	O
argc	int
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"no input files given"	pointer
)	O
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
optind	int
+	O
2	int
!=	O
argc	int
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"exactly 2 input files required"	pointer
)	O
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
update_mode	bool
)	O
{	O
if	O
(	O
output_file	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	pointer
)	O
,	O
"--update"	pointer
,	O
"--output-file"	pointer
)	O
;	O
}	O
if	O
(	O
for_msgfmt	bool
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	pointer
)	O
,	O
"--update"	pointer
,	O
"--for-msgfmt"	pointer
)	O
;	O
}	O
if	O
(	O
color	int
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	pointer
)	O
,	O
"--update"	pointer
,	O
"--color"	pointer
)	O
;	O
}	O
if	O
(	O
style_file_name	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	pointer
)	O
,	O
"--update"	pointer
,	O
"--style"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
version_control_string	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s is only valid with %s"	pointer
)	O
,	O
"--backup"	pointer
,	O
"--update"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
backup_suffix_string	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_SUCCESS	int
,	O
0	int
,	O
_	O
(	O
"%s is only valid with %s"	pointer
)	O
,	O
"--suffix"	pointer
,	O
"--update"	pointer
)	O
;	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
}	O
if	O
(	O
sort_by_msgid	bool
&&	O
sort_by_filepos	bool
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"%s and %s are mutually exclusive"	pointer
)	O
,	O
"--sort-output"	pointer
,	O
"--sort-by-file"	pointer
)	O
;	O
if	O
(	O
update_mode	bool
&&	O
input_syntax	pointer
==	O
&	O
input_format_properties	struct
)	O
output_syntax	pointer
=	O
&	O
output_format_properties	struct
;	O
if	O
(	O
update_mode	bool
&&	O
input_syntax	pointer
==	O
&	O
input_format_stringtable	struct
)	O
output_syntax	pointer
=	O
&	O
output_format_stringtable	struct
;	O
if	O
(	O
for_msgfmt	bool
)	O
{	O
use_fuzzy_matching	bool
=	O
false	int
;	O
quiet	bool
=	O
true	int
;	O
message_print_style_comment	function
(	O
false	int
)	O
;	O
message_print_style_filepos	function
(	O
filepos_comment_none	int
)	O
;	O
}	O
openmp_init	function
(	O
)	O
;	O
result	pointer
=	O
merge	function
(	O
argv	pointer
[	O
optind	int
]	O
,	O
argv	pointer
[	O
optind	int
+	O
1	int
]	O
,	O
input_syntax	pointer
,	O
&	O
def	pointer
)	O
;	O
if	O
(	O
sort_by_filepos	bool
)	O
msgdomain_list_sort_by_filepos	function
(	O
result	pointer
)	O
;	O
else	O
if	O
(	O
sort_by_msgid	bool
)	O
msgdomain_list_sort_by_msgid	function
(	O
result	pointer
)	O
;	O
if	O
(	O
update_mode	bool
)	O
{	O
if	O
(	O
output_syntax	pointer
->	O
sorts_obsoletes_to_end	bool
)	O
msgdomain_list_stablesort_by_obsolete	function
(	O
result	pointer
)	O
;	O
if	O
(	O
!	O
msgdomain_list_equal	function
(	O
def	pointer
,	O
result	pointer
,	O
true	int
)	O
)	O
{	O
enum	O
backup_type	enum
backup_type	enum
;	O
char	O
*	O
backup_file	pointer
;	O
output_file	pointer
=	O
argv	pointer
[	O
optind	int
]	O
;	O
if	O
(	O
backup_suffix_string	pointer
==	O
NULL	O
)	O
{	O
backup_suffix_string	pointer
=	O
getenv	function
(	O
"SIMPLE_BACKUP_SUFFIX"	pointer
)	O
;	O
if	O
(	O
backup_suffix_string	pointer
!=	O
NULL	O
&&	O
backup_suffix_string	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
backup_suffix_string	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
backup_suffix_string	pointer
!=	O
NULL	O
)	O
simple_backup_suffix	pointer
=	O
backup_suffix_string	pointer
;	O
backup_type	enum
=	O
xget_version	function
(	O
_	O
(	O
"backup type"	pointer
)	O
,	O
version_control_string	pointer
)	O
;	O
if	O
(	O
backup_type	enum
!=	O
none	int
)	O
{	O
backup_file	pointer
=	O
find_backup_file_name	function
(	O
output_file	pointer
,	O
backup_type	enum
)	O
;	O
copy_file_preserving	function
(	O
output_file	pointer
,	O
backup_file	pointer
)	O
;	O
}	O
msgdomain_list_print	function
(	O
result	pointer
,	O
output_file	pointer
,	O
output_syntax	pointer
,	O
true	int
,	O
false	int
)	O
;	O
}	O
}	O
else	O
{	O
msgdomain_list_print	function
(	O
result	pointer
,	O
output_file	pointer
,	O
output_syntax	pointer
,	O
force_po	int
,	O
false	int
)	O
;	O
}	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
int	O
status	int
)	O
{	O
if	O
(	O
status	int
!=	O
EXIT_SUCCESS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Try '%s --help' for more information.\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
else	O
{	O
printf	function
(	O
_	O
(	O
"Usage: %s [OPTION] def.po ref.pot\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Merges two Uniforum style .po files together.  The def.po file is an\nexisting PO file with translations which will be taken over to the newly\ncreated file as long as they still match; comments will be preserved,\nbut extracted comments and file positions will be discarded.  The ref.pot\nfile is the last created PO file with up-to-date source references but\nold translations, or a PO Template file (generally created by xgettext);\nany translations or comments in the file will be discarded, however dot\ncomments and file positions will be preserved.  Where an exact match\ncannot be found, fuzzy matching is used to produce better results.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Mandatory arguments to long options are mandatory for short options too.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Input file location:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  def.po                      translations referring to old sources\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  ref.pot                     references to new sources\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -D, --directory=DIRECTORY   add DIRECTORY to list for input files search\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -C, --compendium=FILE       additional library of message translations,\n                              may be specified more than once\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Operation mode:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -U, --update                update def.po,\n                              do nothing if def.po already up to date\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Output file location:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -o, --output-file=FILE      write output to specified file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"The results are written to standard output if no output file is specified\nor if it is -.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Output file location in update mode:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"The result is written back to def.po.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --backup=CONTROL        make a backup of def.po\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --suffix=SUFFIX         override the usual backup suffix\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"The version control method may be selected via the --backup option or through\nthe VERSION_CONTROL environment variable.  Here are the values:\n  none, off       never make backups (even if --backup is given)\n  numbered, t     make numbered backups\n  existing, nil   numbered if numbered backups exist, simple otherwise\n  simple, never   always make simple backups\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"The backup suffix is '~', unless set with --suffix or the SIMPLE_BACKUP_SUFFIX\nenvironment variable.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Operation modifiers:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -m, --multi-domain          apply ref.pot to each of the domains in def.po\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --for-msgfmt            produce output for '%s', not for a translator\n"	pointer
)	O
,	O
"msgfmt"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"  -N, --no-fuzzy-matching     do not use fuzzy matching\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --previous              keep previous msgids of translated messages\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Input file syntax:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -P, --properties-input      input files are in Java .properties syntax\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --stringtable-input     input files are in NeXTstep/GNUstep .strings\n                              syntax\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Output details:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --lang=CATALOGNAME      set 'Language' field in the header entry\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --color                 use colors and other text attributes always\n      --color=WHEN            use colors and other text attributes if WHEN.\n                              WHEN may be 'always', 'never', 'auto', or 'html'.\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --style=STYLEFILE       specify CSS style rule file for --color\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -e, --no-escape             do not use C escapes in output (default)\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -E, --escape                use C escapes in output, no extended chars\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --force-po              write PO file even if empty\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -i, --indent                indented output style\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --no-location           suppress '#: filename:line' lines\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -n, --add-location          preserve '#: filename:line' lines (default)\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --strict                strict Uniforum output style\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -p, --properties-output     write out a Java .properties file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --stringtable-output    write out a NeXTstep/GNUstep .strings file\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -w, --width=NUMBER          set output page width\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"      --no-wrap               do not break long message lines, longer than\n                              the output page width, into several lines\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -s, --sort-output           generate sorted output\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -F, --sort-by-file          sort output by file location\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Informative output:\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -h, --help                  display this help and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -V, --version               output version information and exit\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -v, --verbose               increase verbosity level\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"  -q, --quiet, --silent       suppress progress indicators\n"	pointer
)	O
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
fputs	function
(	O
_	O
(	O
"Report bugs to <bug-gnu-gettext@gnu.org>.\n"	pointer
)	O
,	O
stdout	pointer
)	O
;	O
}	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
void	O
compendium	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
msgdomain_list_ty	struct
*	O
mdlp	pointer
;	O
size_t	long
k	long
;	O
mdlp	pointer
=	O
read_catalog_file	function
(	O
filename	pointer
,	O
&	O
input_format_po	struct
)	O
;	O
if	O
(	O
compendiums	pointer
==	O
NULL	O
)	O
{	O
compendiums	pointer
=	O
message_list_list_alloc	function
(	O
)	O
;	O
compendium_filenames	pointer
=	O
string_list_alloc	function
(	O
)	O
;	O
}	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
mdlp	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_list_append	function
(	O
compendiums	pointer
,	O
mdlp	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
)	O
;	O
string_list_append	function
(	O
compendium_filenames	pointer
,	O
filename	pointer
)	O
;	O
}	O
}	O
static	O
void	O
msgdomain_list_stablesort_by_obsolete	function
(	O
msgdomain_list_ty	struct
*	O
mdlp	pointer
)	O
{	O
size_t	long
k	long
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
mdlp	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
mdlp	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
if	O
(	O
mlp	pointer
->	O
nitems	long
>	O
0	int
)	O
{	O
message_ty	struct
*	O
*	O
l1	pointer
=	O
XNMALLOC	O
(	O
mlp	pointer
->	O
nitems	long
,	O
message_ty	struct
*	O
)	O
;	O
size_t	long
n1	long
;	O
message_ty	struct
*	O
*	O
l2	pointer
=	O
XNMALLOC	O
(	O
mlp	pointer
->	O
nitems	long
,	O
message_ty	struct
*	O
)	O
;	O
size_t	long
n2	long
;	O
size_t	long
j	long
;	O
n1	long
=	O
0	int
;	O
n2	long
=	O
0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
mp	pointer
->	O
obsolete	bool
)	O
l2	pointer
[	O
n2	long
++	O
]	O
=	O
mp	pointer
;	O
else	O
l1	pointer
[	O
n1	long
++	O
]	O
=	O
mp	pointer
;	O
}	O
if	O
(	O
n1	long
>	O
0	int
&&	O
n2	long
>	O
0	int
)	O
{	O
memcpy	function
(	O
mlp	pointer
->	O
item	pointer
,	O
l1	pointer
,	O
n1	long
*	O
sizeof	O
(	O
message_ty	struct
*	O
)	O
)	O
;	O
memcpy	function
(	O
mlp	pointer
->	O
item	pointer
+	O
n1	long
,	O
l2	pointer
,	O
n2	long
*	O
sizeof	O
(	O
message_ty	struct
*	O
)	O
)	O
;	O
}	O
free	function
(	O
l2	pointer
)	O
;	O
free	function
(	O
l1	pointer
)	O
;	O
}	O
}	O
}	O
typedef	O
struct	O
definitions_ty	struct
definitions_ty	struct
;	O
struct	O
definitions_ty	struct
{	O
message_list_list_ty	struct
*	O
lists	pointer
;	O
message_fuzzy_index_ty	struct
*	O
curr_findex	pointer
;	O
gl_lock_define	O
(	O
,	O
curr_findex_init_lock	union
)	O
message_fuzzy_index_ty	struct
*	O
comp_findex	pointer
;	O
gl_lock_define	O
(	O
,	O
comp_findex_init_lock	union
)	O
const	O
char	O
*	O
canon_charset	pointer
;	O
}	O
;	O
static	O
inline	O
void	O
definitions_init	function
(	O
definitions_ty	struct
*	O
definitions	pointer
,	O
const	O
char	O
*	O
canon_charset	pointer
)	O
{	O
definitions	pointer
->	O
lists	pointer
=	O
message_list_list_alloc	function
(	O
)	O
;	O
message_list_list_append	function
(	O
definitions	pointer
->	O
lists	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
compendiums	pointer
!=	O
NULL	O
)	O
message_list_list_append_list	function
(	O
definitions	pointer
->	O
lists	pointer
,	O
compendiums	pointer
)	O
;	O
definitions	pointer
->	O
curr_findex	pointer
=	O
NULL	O
;	O
gl_lock_init	O
(	O
definitions	pointer
->	O
curr_findex_init_lock	union
)	O
;	O
definitions	pointer
->	O
comp_findex	pointer
=	O
NULL	O
;	O
gl_lock_init	O
(	O
definitions	pointer
->	O
comp_findex_init_lock	union
)	O
;	O
definitions	pointer
->	O
canon_charset	pointer
=	O
canon_charset	pointer
;	O
}	O
static	O
inline	O
message_list_ty	struct
*	O
definitions_current_list	function
(	O
const	O
definitions_ty	struct
*	O
definitions	pointer
)	O
{	O
return	O
definitions	pointer
->	O
lists	pointer
->	O
item	pointer
[	O
0	int
]	O
;	O
}	O
static	O
inline	O
void	O
definitions_set_current_list	function
(	O
definitions_ty	struct
*	O
definitions	pointer
,	O
message_list_ty	struct
*	O
mlp	pointer
)	O
{	O
definitions	pointer
->	O
lists	pointer
->	O
item	pointer
[	O
0	int
]	O
=	O
mlp	pointer
;	O
if	O
(	O
definitions	pointer
->	O
curr_findex	pointer
!=	O
NULL	O
)	O
{	O
message_fuzzy_index_free	function
(	O
definitions	pointer
->	O
curr_findex	pointer
)	O
;	O
definitions	pointer
->	O
curr_findex	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
inline	O
void	O
definitions_init_curr_findex	function
(	O
definitions_ty	struct
*	O
definitions	pointer
)	O
{	O
gl_lock_lock	O
(	O
definitions	pointer
->	O
curr_findex_init_lock	union
)	O
;	O
if	O
(	O
definitions	pointer
->	O
curr_findex	pointer
==	O
NULL	O
)	O
definitions	pointer
->	O
curr_findex	pointer
=	O
message_fuzzy_index_alloc	function
(	O
definitions_current_list	function
(	O
definitions	pointer
)	O
,	O
definitions	pointer
->	O
canon_charset	pointer
)	O
;	O
gl_lock_unlock	O
(	O
definitions	pointer
->	O
curr_findex_init_lock	union
)	O
;	O
}	O
static	O
inline	O
void	O
definitions_init_comp_findex	function
(	O
definitions_ty	struct
*	O
definitions	pointer
)	O
{	O
gl_lock_lock	O
(	O
definitions	pointer
->	O
comp_findex_init_lock	union
)	O
;	O
if	O
(	O
definitions	pointer
->	O
comp_findex	pointer
==	O
NULL	O
)	O
{	O
message_list_ty	struct
*	O
all_compendium	pointer
;	O
size_t	long
i	long
;	O
all_compendium	pointer
=	O
message_list_alloc	function
(	O
false	int
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
compendiums	pointer
->	O
nitems	long
;	O
i	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
compendiums	pointer
->	O
item	pointer
[	O
i	long
]	O
;	O
size_t	long
j	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
message_list_append	function
(	O
all_compendium	pointer
,	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
;	O
}	O
definitions	pointer
->	O
comp_findex	pointer
=	O
message_fuzzy_index_alloc	function
(	O
all_compendium	pointer
,	O
definitions	pointer
->	O
canon_charset	pointer
)	O
;	O
}	O
gl_lock_unlock	O
(	O
definitions	pointer
->	O
comp_findex_init_lock	union
)	O
;	O
}	O
static	O
inline	O
message_ty	struct
*	O
definitions_search	function
(	O
const	O
definitions_ty	struct
*	O
definitions	pointer
,	O
const	O
char	O
*	O
msgctxt	pointer
,	O
const	O
char	O
*	O
msgid	pointer
)	O
{	O
return	O
message_list_list_search	function
(	O
definitions	pointer
->	O
lists	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
)	O
;	O
}	O
static	O
inline	O
message_ty	struct
*	O
definitions_search_fuzzy	function
(	O
definitions_ty	struct
*	O
definitions	pointer
,	O
const	O
char	O
*	O
msgctxt	pointer
,	O
const	O
char	O
*	O
msgid	pointer
)	O
{	O
message_ty	struct
*	O
mp1	pointer
;	O
if	O
(	O
false	int
)	O
{	O
mp1	pointer
=	O
message_list_search_fuzzy	function
(	O
definitions_current_list	function
(	O
definitions	pointer
)	O
,	O
msgctxt	pointer
,	O
msgid	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
definitions	pointer
->	O
curr_findex	pointer
==	O
NULL	O
)	O
definitions_init_curr_findex	function
(	O
definitions	pointer
)	O
;	O
mp1	pointer
=	O
message_fuzzy_index_search	function
(	O
definitions	pointer
->	O
curr_findex	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
,	O
FUZZY_THRESHOLD	int
,	O
false	int
)	O
;	O
}	O
if	O
(	O
compendiums	pointer
!=	O
NULL	O
)	O
{	O
double	O
lower_bound_for_mp2	double
;	O
message_ty	struct
*	O
mp2	pointer
;	O
lower_bound_for_mp2	double
=	O
(	O
mp1	pointer
!=	O
NULL	O
?	O
fuzzy_search_goal_function	function
(	O
mp1	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
,	O
0.0	int
)	O
:	O
FUZZY_THRESHOLD	int
)	O
;	O
if	O
(	O
!	O
(	O
lower_bound_for_mp2	double
>=	O
FUZZY_THRESHOLD	int
)	O
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
definitions	pointer
->	O
comp_findex	pointer
==	O
NULL	O
)	O
definitions_init_comp_findex	function
(	O
definitions	pointer
)	O
;	O
mp2	pointer
=	O
message_fuzzy_index_search	function
(	O
definitions	pointer
->	O
comp_findex	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
,	O
lower_bound_for_mp2	double
,	O
true	int
)	O
;	O
if	O
(	O
mp1	pointer
==	O
NULL	O
||	O
(	O
mp2	pointer
!=	O
NULL	O
&&	O
(	O
fuzzy_search_goal_function	function
(	O
mp2	pointer
,	O
msgctxt	pointer
,	O
msgid	pointer
,	O
lower_bound_for_mp2	double
)	O
>	O
lower_bound_for_mp2	double
)	O
)	O
)	O
mp1	pointer
=	O
mp2	pointer
;	O
}	O
return	O
mp1	pointer
;	O
}	O
static	O
inline	O
void	O
definitions_destroy	function
(	O
definitions_ty	struct
*	O
definitions	pointer
)	O
{	O
message_list_list_free	function
(	O
definitions	pointer
->	O
lists	pointer
,	O
2	int
)	O
;	O
if	O
(	O
definitions	pointer
->	O
curr_findex	pointer
!=	O
NULL	O
)	O
message_fuzzy_index_free	function
(	O
definitions	pointer
->	O
curr_findex	pointer
)	O
;	O
if	O
(	O
definitions	pointer
->	O
comp_findex	pointer
!=	O
NULL	O
)	O
message_fuzzy_index_free	function
(	O
definitions	pointer
->	O
comp_findex	pointer
)	O
;	O
}	O
static	O
void	O
silent_error_logger	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
__attribute__	O
(	O
(	O
__format__	O
(	O
__printf__	O
,	O
1	int
,	O
2	int
)	O
)	O
)	O
;	O
static	O
void	O
silent_error_logger	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
}	O
static	O
void	O
silent_xerror	function
(	O
int	O
severity	int
,	O
const	O
struct	O
message_ty	struct
*	O
message	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
size_t	long
lineno	long
,	O
size_t	long
column	long
,	O
int	O
multiline_p	int
,	O
const	O
char	O
*	O
message_text	pointer
)	O
{	O
}	O
static	O
message_ty	struct
*	O
message_merge	function
(	O
message_ty	struct
*	O
def	pointer
,	O
message_ty	struct
*	O
ref	pointer
,	O
bool	bool
force_fuzzy	bool
,	O
const	O
struct	O
plural_distribution	struct
*	O
distribution	pointer
)	O
{	O
const	O
char	O
*	O
msgstr	pointer
;	O
size_t	long
msgstr_len	long
;	O
const	O
char	O
*	O
prev_msgctxt	pointer
;	O
const	O
char	O
*	O
prev_msgid	pointer
;	O
const	O
char	O
*	O
prev_msgid_plural	pointer
;	O
message_ty	struct
*	O
result	pointer
;	O
size_t	long
j	long
,	O
i	long
;	O
if	O
(	O
is_header	O
(	O
ref	pointer
)	O
)	O
{	O
static	O
const	O
struct	O
{	O
const	O
char	O
*	O
name	pointer
;	O
size_t	long
len	long
;	O
}	O
known_fields	array
[	O
]	O
=	O
{	O
{	O
"Project-Id-Version:"	pointer
,	O
sizeof	O
(	O
"Project-Id-Version:"	pointer
)	O
-	O
1	int
}	O
,	O
{	O
"Report-Msgid-Bugs-To:"	pointer
,	O
sizeof	O
(	O
"Report-Msgid-Bugs-To:"	pointer
)	O
-	O
1	int
}	O
,	O
{	O
"POT-Creation-Date:"	pointer
,	O
sizeof	O
(	O
"POT-Creation-Date:"	pointer
)	O
-	O
1	int
}	O
,	O
{	O
"PO-Revision-Date:"	pointer
,	O
sizeof	O
(	O
"PO-Revision-Date:"	pointer
)	O
-	O
1	int
}	O
,	O
{	O
"Last-Translator:"	pointer
,	O
sizeof	O
(	O
"Last-Translator:"	pointer
)	O
-	O
1	int
}	O
,	O
{	O
"Language-Team:"	pointer
,	O
sizeof	O
(	O
"Language-Team:"	pointer
)	O
-	O
1	int
}	O
,	O
{	O
"Language:"	pointer
,	O
sizeof	O
(	O
"Language:"	pointer
)	O
-	O
1	int
}	O
,	O
{	O
"MIME-Version:"	pointer
,	O
sizeof	O
(	O
"MIME-Version:"	pointer
)	O
-	O
1	int
}	O
,	O
{	O
"Content-Type:"	pointer
,	O
sizeof	O
(	O
"Content-Type:"	pointer
)	O
-	O
1	int
}	O
,	O
{	O
"Content-Transfer-Encoding:"	pointer
,	O
sizeof	O
(	O
"Content-Transfer-Encoding:"	pointer
)	O
-	O
1	int
}	O
}	O
;	O
struct	O
{	O
const	O
char	O
*	O
string	pointer
;	O
size_t	long
len	long
;	O
}	O
header_fields	array
[	O
UNKNOWN	int
+	O
1	int
]	O
;	O
struct	O
obstack	struct
pool	struct
;	O
const	O
char	O
*	O
cp	pointer
;	O
char	O
*	O
newp	pointer
;	O
size_t	long
len	long
,	O
cnt	long
;	O
memset	function
(	O
header_fields	array
,	O
'\0'	O
,	O
sizeof	O
(	O
header_fields	array
)	O
)	O
;	O
obstack_init	O
(	O
&	O
pool	struct
)	O
;	O
cp	pointer
=	O
def	pointer
->	O
msgstr	pointer
;	O
while	O
(	O
*	O
cp	pointer
!=	O
'\0'	O
)	O
{	O
const	O
char	O
*	O
endp	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
'\n'	O
)	O
;	O
int	O
terminated	int
=	O
endp	pointer
!=	O
NULL	O
;	O
if	O
(	O
!	O
terminated	int
)	O
{	O
char	O
*	O
copy	pointer
;	O
endp	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
'\0'	O
)	O
;	O
len	long
=	O
endp	pointer
-	O
cp	pointer
+	O
1	int
;	O
copy	pointer
=	O
(	O
char	O
*	O
)	O
obstack_alloc	O
(	O
&	O
pool	struct
,	O
len	long
+	O
1	int
)	O
;	O
stpcpy	function
(	O
stpcpy	function
(	O
copy	pointer
,	O
cp	pointer
)	O
,	O
"\n"	pointer
)	O
;	O
cp	pointer
=	O
copy	pointer
;	O
}	O
else	O
{	O
len	long
=	O
(	O
endp	pointer
-	O
cp	pointer
)	O
+	O
1	int
;	O
++	O
endp	pointer
;	O
}	O
for	O
(	O
cnt	long
=	O
0	int
;	O
cnt	long
<	O
sizeof	O
(	O
known_fields	array
)	O
/	O
sizeof	O
(	O
known_fields	array
[	O
0	int
]	O
)	O
;	O
++	O
cnt	long
)	O
if	O
(	O
c_strncasecmp	function
(	O
cp	pointer
,	O
known_fields	array
[	O
cnt	long
]	O
.	O
name	pointer
,	O
known_fields	array
[	O
cnt	long
]	O
.	O
len	long
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
cnt	long
<	O
sizeof	O
(	O
known_fields	array
)	O
/	O
sizeof	O
(	O
known_fields	array
[	O
0	int
]	O
)	O
)	O
{	O
header_fields	array
[	O
cnt	long
]	O
.	O
string	pointer
=	O
&	O
cp	pointer
[	O
known_fields	array
[	O
cnt	long
]	O
.	O
len	long
]	O
;	O
header_fields	array
[	O
cnt	long
]	O
.	O
len	long
=	O
len	long
-	O
known_fields	array
[	O
cnt	long
]	O
.	O
len	long
;	O
}	O
else	O
{	O
char	O
*	O
extended	pointer
=	O
(	O
char	O
*	O
)	O
obstack_alloc	O
(	O
&	O
pool	struct
,	O
header_fields	array
[	O
UNKNOWN	int
]	O
.	O
len	long
+	O
len	long
+	O
1	int
)	O
;	O
if	O
(	O
header_fields	array
[	O
UNKNOWN	int
]	O
.	O
string	pointer
)	O
memcpy	function
(	O
extended	pointer
,	O
header_fields	array
[	O
UNKNOWN	int
]	O
.	O
string	pointer
,	O
header_fields	array
[	O
UNKNOWN	int
]	O
.	O
len	long
)	O
;	O
memcpy	function
(	O
&	O
extended	pointer
[	O
header_fields	array
[	O
UNKNOWN	int
]	O
.	O
len	long
]	O
,	O
cp	pointer
,	O
len	long
)	O
;	O
extended	pointer
[	O
header_fields	array
[	O
UNKNOWN	int
]	O
.	O
len	long
+	O
len	long
]	O
=	O
'\0'	O
;	O
header_fields	array
[	O
UNKNOWN	int
]	O
.	O
string	pointer
=	O
extended	pointer
;	O
header_fields	array
[	O
UNKNOWN	int
]	O
.	O
len	long
+=	O
len	long
;	O
}	O
cp	pointer
=	O
endp	pointer
;	O
}	O
if	O
(	O
catalogname	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
catalogname	pointer
)	O
;	O
char	O
*	O
copy	pointer
=	O
(	O
char	O
*	O
)	O
obstack_alloc	O
(	O
&	O
pool	struct
,	O
1	int
+	O
len	long
+	O
1	int
+	O
1	int
)	O
;	O
stpcpy	function
(	O
stpcpy	function
(	O
stpcpy	function
(	O
copy	pointer
,	O
" "	pointer
)	O
,	O
catalogname	pointer
)	O
,	O
"\n"	pointer
)	O
;	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
string	pointer
=	O
copy	pointer
;	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
len	long
=	O
strlen	function
(	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
string	pointer
)	O
;	O
}	O
else	O
if	O
(	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
string	pointer
==	O
NULL	O
)	O
{	O
const	O
char	O
*	O
language_team_ptr	pointer
=	O
header_fields	array
[	O
LANGUAGE_TEAM	int
]	O
.	O
string	pointer
;	O
if	O
(	O
language_team_ptr	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
language_team_len	long
=	O
header_fields	array
[	O
LANGUAGE_TEAM	int
]	O
.	O
len	long
;	O
while	O
(	O
language_team_len	long
>	O
0	int
&&	O
(	O
*	O
language_team_ptr	pointer
==	O
' '	O
||	O
*	O
language_team_ptr	pointer
==	O
'\t'	O
)	O
)	O
{	O
language_team_ptr	pointer
++	O
;	O
language_team_len	long
--	O
;	O
}	O
while	O
(	O
language_team_len	long
>	O
0	int
&&	O
(	O
language_team_ptr	pointer
[	O
language_team_len	long
-	O
1	int
]	O
==	O
' '	O
||	O
language_team_ptr	pointer
[	O
language_team_len	long
-	O
1	int
]	O
==	O
'\t'	O
)	O
)	O
language_team_len	long
--	O
;	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
language_team_len	long
;	O
i	long
>	O
0	int
;	O
i	long
--	O
)	O
if	O
(	O
language_team_ptr	pointer
[	O
i	long
-	O
1	int
]	O
==	O
' '	O
||	O
language_team_ptr	pointer
[	O
i	long
-	O
1	int
]	O
==	O
'\t'	O
)	O
break	O
;	O
if	O
(	O
i	long
<	O
language_team_len	long
&&	O
(	O
language_team_ptr	pointer
[	O
i	long
]	O
==	O
'<'	O
||	O
language_team_ptr	pointer
[	O
language_team_len	long
-	O
1	int
]	O
==	O
'>'	O
||	O
memchr	function
(	O
language_team_ptr	pointer
,	O
'@'	O
,	O
language_team_len	long
)	O
!=	O
NULL	O
||	O
memchr	function
(	O
language_team_ptr	pointer
,	O
'/'	O
,	O
language_team_len	long
)	O
!=	O
NULL	O
)	O
)	O
{	O
while	O
(	O
i	long
>	O
0	int
&&	O
(	O
language_team_ptr	pointer
[	O
i	long
-	O
1	int
]	O
==	O
' '	O
||	O
language_team_ptr	pointer
[	O
i	long
-	O
1	int
]	O
==	O
'\t'	O
)	O
)	O
i	long
--	O
;	O
language_team_len	long
=	O
i	long
;	O
}	O
}	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
language_variant_table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
strlen	function
(	O
language_variant_table	array
[	O
i	long
]	O
.	O
english	pointer
)	O
==	O
language_team_len	long
&&	O
memcmp	function
(	O
language_variant_table	array
[	O
i	long
]	O
.	O
english	pointer
,	O
language_team_ptr	pointer
,	O
language_team_len	long
)	O
==	O
0	int
)	O
{	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
string	pointer
=	O
language_variant_table	array
[	O
i	long
]	O
.	O
code	pointer
;	O
break	O
;	O
}	O
}	O
if	O
(	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
string	pointer
==	O
NULL	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
language_table_size	long
;	O
i	long
++	O
)	O
if	O
(	O
strlen	function
(	O
language_table	array
[	O
i	long
]	O
.	O
english	pointer
)	O
==	O
language_team_len	long
&&	O
memcmp	function
(	O
language_table	array
[	O
i	long
]	O
.	O
english	pointer
,	O
language_team_ptr	pointer
,	O
language_team_len	long
)	O
==	O
0	int
)	O
{	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
string	pointer
=	O
language_table	array
[	O
i	long
]	O
.	O
code	pointer
;	O
break	O
;	O
}	O
}	O
if	O
(	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
string	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
str	pointer
=	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
string	pointer
;	O
size_t	long
len	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
char	O
*	O
copy	pointer
=	O
(	O
char	O
*	O
)	O
obstack_alloc	O
(	O
&	O
pool	struct
,	O
1	int
+	O
len	long
+	O
1	int
+	O
1	int
)	O
;	O
stpcpy	function
(	O
stpcpy	function
(	O
stpcpy	function
(	O
copy	pointer
,	O
" "	pointer
)	O
,	O
str	pointer
)	O
,	O
"\n"	pointer
)	O
;	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
string	pointer
=	O
copy	pointer
;	O
}	O
else	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
string	pointer
=	O
" \n"	pointer
;	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
len	long
=	O
strlen	function
(	O
header_fields	array
[	O
LANGUAGE	int
]	O
.	O
string	pointer
)	O
;	O
}	O
}	O
{	O
const	O
char	O
*	O
msgid_bugs_ptr	pointer
;	O
msgid_bugs_ptr	pointer
=	O
c_strstr	function
(	O
ref	pointer
->	O
msgstr	pointer
,	O
"Report-Msgid-Bugs-To:"	pointer
)	O
;	O
if	O
(	O
msgid_bugs_ptr	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
msgid_bugs_len	long
;	O
const	O
char	O
*	O
endp	pointer
;	O
msgid_bugs_ptr	pointer
+=	O
sizeof	O
(	O
"Report-Msgid-Bugs-To:"	pointer
)	O
-	O
1	int
;	O
endp	pointer
=	O
strchr	function
(	O
msgid_bugs_ptr	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
endp	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
extended	pointer
;	O
endp	pointer
=	O
strchr	function
(	O
msgid_bugs_ptr	pointer
,	O
'\0'	O
)	O
;	O
msgid_bugs_len	long
=	O
(	O
endp	pointer
-	O
msgid_bugs_ptr	pointer
)	O
+	O
1	int
;	O
extended	pointer
=	O
(	O
char	O
*	O
)	O
obstack_alloc	O
(	O
&	O
pool	struct
,	O
msgid_bugs_len	long
+	O
1	int
)	O
;	O
stpcpy	function
(	O
stpcpy	function
(	O
extended	pointer
,	O
msgid_bugs_ptr	pointer
)	O
,	O
"\n"	pointer
)	O
;	O
msgid_bugs_ptr	pointer
=	O
extended	pointer
;	O
}	O
else	O
msgid_bugs_len	long
=	O
(	O
endp	pointer
-	O
msgid_bugs_ptr	pointer
)	O
+	O
1	int
;	O
header_fields	array
[	O
REPORT_MSGID_BUGS_TO	int
]	O
.	O
string	pointer
=	O
msgid_bugs_ptr	pointer
;	O
header_fields	array
[	O
REPORT_MSGID_BUGS_TO	int
]	O
.	O
len	long
=	O
msgid_bugs_len	long
;	O
}	O
}	O
{	O
const	O
char	O
*	O
pot_date_ptr	pointer
;	O
pot_date_ptr	pointer
=	O
c_strstr	function
(	O
ref	pointer
->	O
msgstr	pointer
,	O
"POT-Creation-Date:"	pointer
)	O
;	O
if	O
(	O
pot_date_ptr	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
pot_date_len	long
;	O
const	O
char	O
*	O
endp	pointer
;	O
pot_date_ptr	pointer
+=	O
sizeof	O
(	O
"POT-Creation-Date:"	pointer
)	O
-	O
1	int
;	O
endp	pointer
=	O
strchr	function
(	O
pot_date_ptr	pointer
,	O
'\n'	O
)	O
;	O
if	O
(	O
endp	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
extended	pointer
;	O
endp	pointer
=	O
strchr	function
(	O
pot_date_ptr	pointer
,	O
'\0'	O
)	O
;	O
pot_date_len	long
=	O
(	O
endp	pointer
-	O
pot_date_ptr	pointer
)	O
+	O
1	int
;	O
extended	pointer
=	O
(	O
char	O
*	O
)	O
obstack_alloc	O
(	O
&	O
pool	struct
,	O
pot_date_len	long
+	O
1	int
)	O
;	O
stpcpy	function
(	O
stpcpy	function
(	O
extended	pointer
,	O
pot_date_ptr	pointer
)	O
,	O
"\n"	pointer
)	O
;	O
pot_date_ptr	pointer
=	O
extended	pointer
;	O
}	O
else	O
pot_date_len	long
=	O
(	O
endp	pointer
-	O
pot_date_ptr	pointer
)	O
+	O
1	int
;	O
header_fields	array
[	O
POT_CREATION_DATE	int
]	O
.	O
string	pointer
=	O
pot_date_ptr	pointer
;	O
header_fields	array
[	O
POT_CREATION_DATE	int
]	O
.	O
len	long
=	O
pot_date_len	long
;	O
}	O
}	O
len	long
=	O
0	int
;	O
for	O
(	O
cnt	long
=	O
0	int
;	O
cnt	long
<	O
UNKNOWN	int
;	O
++	O
cnt	long
)	O
if	O
(	O
header_fields	array
[	O
cnt	long
]	O
.	O
string	pointer
!=	O
NULL	O
)	O
len	long
+=	O
known_fields	array
[	O
cnt	long
]	O
.	O
len	long
+	O
header_fields	array
[	O
cnt	long
]	O
.	O
len	long
;	O
len	long
+=	O
header_fields	array
[	O
UNKNOWN	int
]	O
.	O
len	long
;	O
cp	pointer
=	O
newp	pointer
=	O
XNMALLOC	O
(	O
len	long
+	O
1	int
,	O
char	O
)	O
;	O
newp	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
IF_FILLED	O
(	O
PROJECT_ID	int
)	O
;	O
IF_FILLED	O
(	O
REPORT_MSGID_BUGS_TO	int
)	O
;	O
IF_FILLED	O
(	O
POT_CREATION_DATE	int
)	O
;	O
IF_FILLED	O
(	O
PO_REVISION_DATE	int
)	O
;	O
IF_FILLED	O
(	O
LAST_TRANSLATOR	int
)	O
;	O
IF_FILLED	O
(	O
LANGUAGE_TEAM	int
)	O
;	O
IF_FILLED	O
(	O
LANGUAGE	int
)	O
;	O
IF_FILLED	O
(	O
MIME_VERSION	int
)	O
;	O
IF_FILLED	O
(	O
CONTENT_TYPE	int
)	O
;	O
IF_FILLED	O
(	O
CONTENT_TRANSFER	int
)	O
;	O
if	O
(	O
header_fields	array
[	O
UNKNOWN	int
]	O
.	O
string	pointer
!=	O
NULL	O
)	O
stpcpy	function
(	O
newp	pointer
,	O
header_fields	array
[	O
UNKNOWN	int
]	O
.	O
string	pointer
)	O
;	O
obstack_free	O
(	O
&	O
pool	struct
,	O
NULL	O
)	O
;	O
msgstr	pointer
=	O
cp	pointer
;	O
msgstr_len	long
=	O
strlen	function
(	O
cp	pointer
)	O
+	O
1	int
;	O
prev_msgctxt	pointer
=	O
NULL	O
;	O
prev_msgid	pointer
=	O
NULL	O
;	O
prev_msgid_plural	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
msgstr	pointer
=	O
def	pointer
->	O
msgstr	pointer
;	O
msgstr_len	long
=	O
def	pointer
->	O
msgstr_len	long
;	O
if	O
(	O
def	pointer
->	O
is_fuzzy	bool
)	O
{	O
prev_msgctxt	pointer
=	O
def	pointer
->	O
prev_msgctxt	pointer
;	O
prev_msgid	pointer
=	O
def	pointer
->	O
prev_msgid	pointer
;	O
prev_msgid_plural	pointer
=	O
def	pointer
->	O
prev_msgid_plural	pointer
;	O
}	O
else	O
{	O
prev_msgctxt	pointer
=	O
def	pointer
->	O
msgctxt	pointer
;	O
prev_msgid	pointer
=	O
def	pointer
->	O
msgid	pointer
;	O
prev_msgid_plural	pointer
=	O
def	pointer
->	O
msgid_plural	pointer
;	O
}	O
}	O
result	pointer
=	O
message_alloc	function
(	O
ref	pointer
->	O
msgctxt	pointer
!=	O
NULL	O
?	O
xstrdup	function
(	O
ref	pointer
->	O
msgctxt	pointer
)	O
:	O
NULL	O
,	O
xstrdup	function
(	O
ref	pointer
->	O
msgid	pointer
)	O
,	O
ref	pointer
->	O
msgid_plural	pointer
,	O
msgstr	pointer
,	O
msgstr_len	long
,	O
&	O
def	pointer
->	O
pos	struct
)	O
;	O
if	O
(	O
def	pointer
->	O
comment	pointer
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
def	pointer
->	O
comment	pointer
->	O
nitems	long
;	O
++	O
j	long
)	O
message_comment_append	function
(	O
result	pointer
,	O
def	pointer
->	O
comment	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
;	O
if	O
(	O
ref	pointer
->	O
comment_dot	pointer
)	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
ref	pointer
->	O
comment_dot	pointer
->	O
nitems	long
;	O
++	O
j	long
)	O
message_comment_dot_append	function
(	O
result	pointer
,	O
ref	pointer
->	O
comment_dot	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
;	O
result	pointer
->	O
is_fuzzy	bool
=	O
def	pointer
->	O
is_fuzzy	bool
|	O
force_fuzzy	bool
;	O
if	O
(	O
!	O
result	pointer
->	O
is_fuzzy	bool
&&	O
(	O
ref	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
?	O
def	pointer
->	O
msgid_plural	pointer
==	O
NULL	O
||	O
strcmp	function
(	O
ref	pointer
->	O
msgid_plural	pointer
,	O
def	pointer
->	O
msgid_plural	pointer
)	O
!=	O
0	int
:	O
def	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
)	O
result	pointer
->	O
is_fuzzy	bool
=	O
true	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NFORMATS	int
;	O
i	long
++	O
)	O
{	O
result	pointer
->	O
is_format	enum
[	O
i	long
]	O
=	O
ref	pointer
->	O
is_format	enum
[	O
i	long
]	O
;	O
if	O
(	O
!	O
result	pointer
->	O
is_fuzzy	bool
&&	O
possible_format_p	function
(	O
ref	pointer
->	O
is_format	enum
[	O
i	long
]	O
)	O
&&	O
!	O
possible_format_p	function
(	O
def	pointer
->	O
is_format	enum
[	O
i	long
]	O
)	O
&&	O
check_msgid_msgstr_format_i	function
(	O
ref	pointer
->	O
msgid	pointer
,	O
ref	pointer
->	O
msgid_plural	pointer
,	O
msgstr	pointer
,	O
msgstr_len	long
,	O
i	long
,	O
ref	pointer
->	O
range	struct
,	O
distribution	pointer
,	O
silent_error_logger	function
)	O
>	O
0	int
)	O
result	pointer
->	O
is_fuzzy	bool
=	O
true	int
;	O
}	O
result	pointer
->	O
range	struct
=	O
ref	pointer
->	O
range	struct
;	O
if	O
(	O
!	O
result	pointer
->	O
is_fuzzy	bool
&&	O
has_range_p	O
(	O
def	pointer
->	O
range	struct
)	O
&&	O
!	O
(	O
has_range_p	O
(	O
ref	pointer
->	O
range	struct
)	O
&&	O
ref	pointer
->	O
range	struct
.	O
min	int
>=	O
def	pointer
->	O
range	struct
.	O
min	int
&&	O
ref	pointer
->	O
range	struct
.	O
max	int
<=	O
def	pointer
->	O
range	struct
.	O
max	int
)	O
)	O
result	pointer
->	O
is_fuzzy	bool
=	O
true	int
;	O
result	pointer
->	O
do_wrap	enum
=	O
ref	pointer
->	O
do_wrap	enum
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
NSYNTAXCHECKS	int
;	O
i	long
++	O
)	O
result	pointer
->	O
do_syntax_check	array
[	O
i	long
]	O
=	O
ref	pointer
->	O
do_syntax_check	array
[	O
i	long
]	O
;	O
if	O
(	O
keep_previous	bool
)	O
{	O
result	pointer
->	O
prev_msgctxt	pointer
=	O
prev_msgctxt	pointer
;	O
result	pointer
->	O
prev_msgid	pointer
=	O
prev_msgid	pointer
;	O
result	pointer
->	O
prev_msgid_plural	pointer
=	O
prev_msgid_plural	pointer
;	O
}	O
result	pointer
->	O
obsolete	bool
=	O
ref	pointer
->	O
obsolete	bool
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
ref	pointer
->	O
filepos_count	long
;	O
++	O
j	long
)	O
{	O
lex_pos_ty	struct
*	O
pp	pointer
=	O
&	O
ref	pointer
->	O
filepos	pointer
[	O
j	long
]	O
;	O
message_comment_filepos	function
(	O
result	pointer
,	O
pp	pointer
->	O
file_name	pointer
,	O
pp	pointer
->	O
line_number	long
)	O
;	O
}	O
if	O
(	O
ref	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
def	pointer
->	O
msgid_plural	pointer
==	O
NULL	O
)	O
result	pointer
->	O
used	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
def	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
)	O
result	pointer
->	O
used	int
=	O
2	int
;	O
}	O
return	O
result	pointer
;	O
}	O
static	O
void	O
match_domain	function
(	O
const	O
char	O
*	O
fn1	pointer
,	O
const	O
char	O
*	O
fn2	pointer
,	O
definitions_ty	struct
*	O
definitions	pointer
,	O
message_list_ty	struct
*	O
refmlp	pointer
,	O
message_list_ty	struct
*	O
resultmlp	pointer
,	O
struct	O
statistics	struct
*	O
stats	pointer
,	O
unsigned	O
int	O
*	O
processed	pointer
)	O
{	O
message_ty	struct
*	O
header_entry	pointer
;	O
unsigned	O
long	O
int	O
nplurals	long
;	O
const	O
struct	O
expression	struct
*	O
plural_expr	pointer
;	O
char	O
*	O
untranslated_plural_msgstr	pointer
;	O
struct	O
plural_distribution	struct
distribution	pointer
;	O
struct	O
search_result	struct
{	O
message_ty	struct
*	O
found	pointer
;	O
bool	bool
fuzzy	bool
;	O
}	O
*	O
search_results	pointer
;	O
size_t	long
j	long
;	O
header_entry	pointer
=	O
message_list_search	function
(	O
definitions_current_list	function
(	O
definitions	pointer
)	O
,	O
NULL	O
,	O
""	pointer
)	O
;	O
extract_plural_expression	function
(	O
header_entry	pointer
?	O
header_entry	pointer
->	O
msgstr	pointer
:	O
NULL	O
,	O
&	O
plural_expr	pointer
,	O
&	O
nplurals	long
)	O
;	O
untranslated_plural_msgstr	pointer
=	O
XNMALLOC	O
(	O
nplurals	long
,	O
char	O
)	O
;	O
memset	function
(	O
untranslated_plural_msgstr	pointer
,	O
'\0'	O
,	O
nplurals	long
)	O
;	O
{	O
void	O
(	O
*	O
old_po_xerror	pointer
)	O
(	O
int	O
,	O
const	O
struct	O
message_ty	struct
*	O
,	O
const	O
char	O
*	O
,	O
size_t	long
,	O
size_t	long
,	O
int	O
,	O
const	O
char	O
*	O
)	O
=	O
po_xerror	pointer
;	O
po_xerror	pointer
=	O
silent_xerror	function
;	O
if	O
(	O
check_plural_eval	function
(	O
plural_expr	pointer
,	O
nplurals	long
,	O
header_entry	pointer
,	O
&	O
distribution	pointer
)	O
>	O
0	int
)	O
{	O
distribution	pointer
.	O
expr	pointer
=	O
NULL	O
;	O
distribution	pointer
.	O
often	pointer
=	O
NULL	O
;	O
distribution	pointer
.	O
often_length	long
=	O
0	int
;	O
distribution	pointer
.	O
histogram	pointer
=	O
NULL	O
;	O
}	O
po_xerror	pointer
=	O
old_po_xerror	pointer
;	O
}	O
search_results	pointer
=	O
XNMALLOC	O
(	O
refmlp	pointer
->	O
nitems	long
,	O
struct	O
search_result	struct
)	O
;	O
{	O
long	O
int	O
nn	long
=	O
refmlp	pointer
->	O
nitems	long
;	O
long	O
int	O
jj	long
;	O
for	O
(	O
jj	long
=	O
0	int
;	O
jj	long
<	O
nn	long
;	O
jj	long
++	O
)	O
{	O
message_ty	struct
*	O
refmsg	pointer
=	O
refmlp	pointer
->	O
item	pointer
[	O
jj	long
]	O
;	O
message_ty	struct
*	O
defmsg	pointer
;	O
if	O
(	O
!	O
quiet	bool
&&	O
verbosity_level	int
<=	O
1	int
&&	O
*	O
processed	pointer
%	O
DOT_FREQUENCY	int
==	O
0	int
)	O
fputc	function
(	O
'.'	O
,	O
stderr	pointer
)	O
;	O
(	O
*	O
processed	pointer
)	O
++	O
;	O
defmsg	pointer
=	O
definitions_search	function
(	O
definitions	pointer
,	O
refmsg	pointer
->	O
msgctxt	pointer
,	O
refmsg	pointer
->	O
msgid	pointer
)	O
;	O
if	O
(	O
defmsg	pointer
!=	O
NULL	O
)	O
{	O
search_results	pointer
[	O
jj	long
]	O
.	O
found	pointer
=	O
defmsg	pointer
;	O
search_results	pointer
[	O
jj	long
]	O
.	O
fuzzy	bool
=	O
false	int
;	O
}	O
else	O
if	O
(	O
!	O
is_header	O
(	O
refmsg	pointer
)	O
&&	O
use_fuzzy_matching	bool
&&	O
(	O
(	O
defmsg	pointer
=	O
definitions_search_fuzzy	function
(	O
definitions	pointer
,	O
refmsg	pointer
->	O
msgctxt	pointer
,	O
refmsg	pointer
->	O
msgid	pointer
)	O
)	O
!=	O
NULL	O
)	O
)	O
{	O
search_results	pointer
[	O
jj	long
]	O
.	O
found	pointer
=	O
defmsg	pointer
;	O
search_results	pointer
[	O
jj	long
]	O
.	O
fuzzy	bool
=	O
true	int
;	O
}	O
else	O
search_results	pointer
[	O
jj	long
]	O
.	O
found	pointer
=	O
NULL	O
;	O
}	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
refmlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
refmsg	pointer
=	O
refmlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
search_results	pointer
[	O
j	long
]	O
.	O
found	pointer
!=	O
NULL	O
&&	O
!	O
search_results	pointer
[	O
j	long
]	O
.	O
fuzzy	bool
)	O
{	O
message_ty	struct
*	O
defmsg	pointer
=	O
search_results	pointer
[	O
j	long
]	O
.	O
found	pointer
;	O
message_ty	struct
*	O
mp	pointer
=	O
message_merge	function
(	O
defmsg	pointer
,	O
refmsg	pointer
,	O
false	int
,	O
&	O
distribution	pointer
)	O
;	O
if	O
(	O
!	O
(	O
for_msgfmt	bool
&&	O
(	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
==	O
'\0'	O
||	O
(	O
mp	pointer
->	O
is_fuzzy	bool
&&	O
!	O
is_header	O
(	O
mp	pointer
)	O
)	O
)	O
)	O
)	O
{	O
message_list_append	function
(	O
resultmlp	pointer
,	O
mp	pointer
)	O
;	O
defmsg	pointer
->	O
used	int
=	O
1	int
;	O
}	O
stats	pointer
->	O
merged	long
++	O
;	O
}	O
else	O
if	O
(	O
!	O
is_header	O
(	O
refmsg	pointer
)	O
)	O
{	O
if	O
(	O
search_results	pointer
[	O
j	long
]	O
.	O
found	pointer
!=	O
NULL	O
&&	O
search_results	pointer
[	O
j	long
]	O
.	O
fuzzy	bool
)	O
{	O
message_ty	struct
*	O
defmsg	pointer
=	O
search_results	pointer
[	O
j	long
]	O
.	O
found	pointer
;	O
message_ty	struct
*	O
mp	pointer
;	O
if	O
(	O
verbosity_level	int
>	O
1	int
)	O
{	O
po_gram_error_at_line	function
(	O
&	O
refmsg	pointer
->	O
pos	struct
,	O
_	O
(	O
"this message is used but not defined..."	pointer
)	O
)	O
;	O
error_message_count	int
--	O
;	O
po_gram_error_at_line	function
(	O
&	O
defmsg	pointer
->	O
pos	struct
,	O
_	O
(	O
"...but this definition is similar"	pointer
)	O
)	O
;	O
}	O
mp	pointer
=	O
message_merge	function
(	O
defmsg	pointer
,	O
refmsg	pointer
,	O
true	int
,	O
&	O
distribution	pointer
)	O
;	O
message_list_append	function
(	O
resultmlp	pointer
,	O
mp	pointer
)	O
;	O
defmsg	pointer
->	O
used	int
=	O
1	int
;	O
stats	pointer
->	O
fuzzied	long
++	O
;	O
if	O
(	O
!	O
quiet	bool
&&	O
verbosity_level	int
<=	O
1	int
)	O
fputc	function
(	O
'.'	O
,	O
stderr	pointer
)	O
;	O
}	O
else	O
{	O
message_ty	struct
*	O
mp	pointer
;	O
bool	bool
is_untranslated	bool
;	O
const	O
char	O
*	O
p	pointer
;	O
const	O
char	O
*	O
pend	pointer
;	O
if	O
(	O
verbosity_level	int
>	O
1	int
)	O
po_gram_error_at_line	function
(	O
&	O
refmsg	pointer
->	O
pos	struct
,	O
_	O
(	O
"this message is used but not defined in %s"	pointer
)	O
,	O
fn1	pointer
)	O
;	O
mp	pointer
=	O
message_copy	function
(	O
refmsg	pointer
)	O
;	O
is_untranslated	bool
=	O
true	int
;	O
for	O
(	O
p	pointer
=	O
mp	pointer
->	O
msgstr	pointer
,	O
pend	pointer
=	O
p	pointer
+	O
mp	pointer
->	O
msgstr_len	long
;	O
p	pointer
<	O
pend	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
!=	O
'\0'	O
)	O
{	O
is_untranslated	bool
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
mp	pointer
->	O
msgid_plural	pointer
!=	O
NULL	O
&&	O
is_untranslated	bool
)	O
{	O
if	O
(	O
nplurals	long
>	O
mp	pointer
->	O
msgstr_len	long
)	O
mp	pointer
->	O
msgstr	pointer
=	O
untranslated_plural_msgstr	pointer
;	O
mp	pointer
->	O
msgstr_len	long
=	O
nplurals	long
;	O
}	O
if	O
(	O
!	O
(	O
for_msgfmt	bool
&&	O
(	O
is_untranslated	bool
||	O
mp	pointer
->	O
is_fuzzy	bool
)	O
)	O
)	O
{	O
message_list_append	function
(	O
resultmlp	pointer
,	O
mp	pointer
)	O
;	O
}	O
stats	pointer
->	O
missing	long
++	O
;	O
}	O
}	O
}	O
free	function
(	O
search_results	pointer
)	O
;	O
{	O
int	O
problematic	int
=	O
0	int
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
resultmlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
problematic	int
|=	O
resultmlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
used	int
;	O
if	O
(	O
problematic	int
)	O
{	O
unsigned	O
long	O
int	O
nplurals	long
=	O
0	int
;	O
if	O
(	O
problematic	int
&	O
1	int
)	O
{	O
message_ty	struct
*	O
header_entry	pointer
=	O
message_list_search	function
(	O
resultmlp	pointer
,	O
NULL	O
,	O
""	pointer
)	O
;	O
nplurals	long
=	O
get_plural_count	function
(	O
header_entry	pointer
?	O
header_entry	pointer
->	O
msgstr	pointer
:	O
NULL	O
)	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
resultmlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
resultmlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
(	O
mp	pointer
->	O
used	int
&	O
1	int
)	O
&&	O
(	O
nplurals	long
>	O
0	int
)	O
)	O
{	O
size_t	long
new_msgstr_len	long
;	O
char	O
*	O
new_msgstr	pointer
;	O
char	O
*	O
p	pointer
;	O
unsigned	O
long	O
i	long
;	O
if	O
(	O
verbosity_level	int
>	O
1	int
)	O
po_gram_error_at_line	function
(	O
&	O
mp	pointer
->	O
pos	struct
,	O
_	O
(	O
"this message should define plural forms"	pointer
)	O
)	O
;	O
new_msgstr_len	long
=	O
nplurals	long
*	O
mp	pointer
->	O
msgstr_len	long
;	O
new_msgstr	pointer
=	O
XNMALLOC	O
(	O
new_msgstr_len	long
,	O
char	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
,	O
p	pointer
=	O
new_msgstr	pointer
;	O
i	long
<	O
nplurals	long
;	O
i	long
++	O
)	O
{	O
memcpy	function
(	O
p	pointer
,	O
mp	pointer
->	O
msgstr	pointer
,	O
mp	pointer
->	O
msgstr_len	long
)	O
;	O
p	pointer
+=	O
mp	pointer
->	O
msgstr_len	long
;	O
}	O
mp	pointer
->	O
msgstr	pointer
=	O
new_msgstr	pointer
;	O
mp	pointer
->	O
msgstr_len	long
=	O
new_msgstr_len	long
;	O
mp	pointer
->	O
is_fuzzy	bool
=	O
true	int
;	O
}	O
if	O
(	O
(	O
mp	pointer
->	O
used	int
&	O
2	int
)	O
&&	O
(	O
mp	pointer
->	O
msgstr_len	long
>	O
strlen	function
(	O
mp	pointer
->	O
msgstr	pointer
)	O
+	O
1	int
)	O
)	O
{	O
if	O
(	O
verbosity_level	int
>	O
1	int
)	O
po_gram_error_at_line	function
(	O
&	O
mp	pointer
->	O
pos	struct
,	O
_	O
(	O
"this message should not define plural forms"	pointer
)	O
)	O
;	O
mp	pointer
->	O
msgstr_len	long
=	O
strlen	function
(	O
mp	pointer
->	O
msgstr	pointer
)	O
+	O
1	int
;	O
mp	pointer
->	O
is_fuzzy	bool
=	O
true	int
;	O
}	O
mp	pointer
->	O
used	int
=	O
0	int
;	O
}	O
}	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
resultmlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
mp	pointer
=	O
resultmlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
!	O
mp	pointer
->	O
is_fuzzy	bool
||	O
mp	pointer
->	O
msgstr	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
mp	pointer
->	O
prev_msgctxt	pointer
=	O
NULL	O
;	O
mp	pointer
->	O
prev_msgid	pointer
=	O
NULL	O
;	O
mp	pointer
->	O
prev_msgid_plural	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
static	O
msgdomain_list_ty	struct
*	O
merge	function
(	O
const	O
char	O
*	O
fn1	pointer
,	O
const	O
char	O
*	O
fn2	pointer
,	O
catalog_input_format_ty	pointer
input_syntax	pointer
,	O
msgdomain_list_ty	struct
*	O
*	O
defp	pointer
)	O
{	O
msgdomain_list_ty	struct
*	O
def	pointer
;	O
msgdomain_list_ty	struct
*	O
ref	pointer
;	O
size_t	long
j	long
,	O
k	long
;	O
unsigned	O
int	O
processed	pointer
;	O
struct	O
statistics	struct
stats	pointer
;	O
msgdomain_list_ty	struct
*	O
result	pointer
;	O
const	O
char	O
*	O
def_canon_charset	pointer
;	O
definitions_ty	struct
definitions	pointer
;	O
message_list_ty	struct
*	O
empty_list	pointer
;	O
stats	pointer
.	O
merged	long
=	O
stats	pointer
.	O
fuzzied	long
=	O
stats	pointer
.	O
missing	long
=	O
stats	pointer
.	O
obsolete	bool
=	O
0	int
;	O
def	pointer
=	O
read_catalog_file	function
(	O
fn1	pointer
,	O
input_syntax	pointer
)	O
;	O
ref	pointer
=	O
read_catalog_file	function
(	O
fn2	pointer
,	O
input_syntax	pointer
)	O
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
ref	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
if	O
(	O
message_list_search	function
(	O
ref	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
,	O
NULL	O
,	O
""	pointer
)	O
==	O
NULL	O
)	O
{	O
static	O
lex_pos_ty	struct
pos	struct
=	O
{	O
__FILE__	O
,	O
__LINE__	O
}	O
;	O
message_ty	struct
*	O
refheader	pointer
=	O
message_alloc	function
(	O
NULL	O
,	O
""	pointer
,	O
NULL	O
,	O
""	pointer
,	O
1	int
,	O
&	O
pos	struct
)	O
;	O
message_list_prepend	function
(	O
ref	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
,	O
refheader	pointer
)	O
;	O
}	O
{	O
bool	bool
was_utf8	bool
=	O
false	int
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
ref	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
ref	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
is_header	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
&&	O
!	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
obsolete	bool
)	O
{	O
const	O
char	O
*	O
header	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgstr	pointer
;	O
if	O
(	O
header	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
charsetstr	pointer
=	O
c_strstr	function
(	O
header	pointer
,	O
"charset="	pointer
)	O
;	O
if	O
(	O
charsetstr	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
;	O
charsetstr	pointer
+=	O
strlen	function
(	O
"charset="	pointer
)	O
;	O
len	long
=	O
strcspn	function
(	O
charsetstr	pointer
,	O
" \t\n"	pointer
)	O
;	O
if	O
(	O
len	long
==	O
strlen	function
(	O
"UTF-8"	pointer
)	O
&&	O
c_strncasecmp	function
(	O
charsetstr	pointer
,	O
"UTF-8"	pointer
,	O
len	long
)	O
==	O
0	int
)	O
was_utf8	bool
=	O
true	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
was_utf8	bool
)	O
{	O
def	pointer
=	O
iconv_msgdomain_list	function
(	O
def	pointer
,	O
"UTF-8"	pointer
,	O
true	int
,	O
fn1	pointer
)	O
;	O
if	O
(	O
compendiums	pointer
!=	O
NULL	O
)	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
compendiums	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
iconv_message_list	function
(	O
compendiums	pointer
->	O
item	pointer
[	O
k	long
]	O
,	O
NULL	O
,	O
po_charset_utf8	pointer
,	O
compendium_filenames	pointer
->	O
item	pointer
[	O
k	long
]	O
)	O
;	O
}	O
else	O
if	O
(	O
compendiums	pointer
!=	O
NULL	O
&&	O
compendiums	pointer
->	O
nitems	long
>	O
0	int
)	O
{	O
bool	bool
conversion_done	bool
=	O
false	int
;	O
{	O
char	O
*	O
charset	pointer
=	O
NULL	O
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
def	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
def	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
is_header	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
&&	O
!	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
obsolete	bool
)	O
{	O
const	O
char	O
*	O
header	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgstr	pointer
;	O
if	O
(	O
header	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
charsetstr	pointer
=	O
c_strstr	function
(	O
header	pointer
,	O
"charset="	pointer
)	O
;	O
if	O
(	O
charsetstr	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
;	O
charsetstr	pointer
+=	O
strlen	function
(	O
"charset="	pointer
)	O
;	O
len	long
=	O
strcspn	function
(	O
charsetstr	pointer
,	O
" \t\n"	pointer
)	O
;	O
charset	pointer
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
charset	pointer
,	O
charsetstr	pointer
,	O
len	long
)	O
;	O
charset	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
charset	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
charset	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
canon_charset	pointer
=	O
po_charset_canonicalize	function
(	O
charset	pointer
)	O
;	O
if	O
(	O
canon_charset	pointer
!=	O
NULL	O
)	O
{	O
bool	bool
all_compendiums_iconvable	bool
=	O
true	int
;	O
if	O
(	O
compendiums	pointer
!=	O
NULL	O
)	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
compendiums	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
if	O
(	O
!	O
is_message_list_iconvable	function
(	O
compendiums	pointer
->	O
item	pointer
[	O
k	long
]	O
,	O
NULL	O
,	O
canon_charset	pointer
)	O
)	O
{	O
all_compendiums_iconvable	bool
=	O
false	int
;	O
break	O
;	O
}	O
if	O
(	O
all_compendiums_iconvable	bool
)	O
{	O
if	O
(	O
compendiums	pointer
!=	O
NULL	O
)	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
compendiums	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
iconv_message_list	function
(	O
compendiums	pointer
->	O
item	pointer
[	O
k	long
]	O
,	O
NULL	O
,	O
canon_charset	pointer
,	O
compendium_filenames	pointer
->	O
item	pointer
[	O
k	long
]	O
)	O
;	O
conversion_done	bool
=	O
true	int
;	O
}	O
}	O
freea	function
(	O
charset	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
conversion_done	bool
)	O
{	O
if	O
(	O
def	pointer
->	O
nitems	long
==	O
0	int
||	O
(	O
def	pointer
->	O
nitems	long
==	O
1	int
&&	O
def	pointer
->	O
item	pointer
[	O
0	int
]	O
->	O
messages	pointer
->	O
nitems	long
==	O
0	int
)	O
)	O
{	O
const	O
char	O
*	O
common_canon_charset	pointer
=	O
NULL	O
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
compendiums	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
compendiums	pointer
->	O
item	pointer
[	O
k	long
]	O
;	O
char	O
*	O
charset	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
canon_charset	pointer
=	O
NULL	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
is_header	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
&&	O
!	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
obsolete	bool
)	O
{	O
const	O
char	O
*	O
header	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgstr	pointer
;	O
if	O
(	O
header	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
charsetstr	pointer
=	O
c_strstr	function
(	O
header	pointer
,	O
"charset="	pointer
)	O
;	O
if	O
(	O
charsetstr	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
;	O
charsetstr	pointer
+=	O
strlen	function
(	O
"charset="	pointer
)	O
;	O
len	long
=	O
strcspn	function
(	O
charsetstr	pointer
,	O
" \t\n"	pointer
)	O
;	O
charset	pointer
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
charset	pointer
,	O
charsetstr	pointer
,	O
len	long
)	O
;	O
charset	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
charset	pointer
!=	O
NULL	O
)	O
{	O
canon_charset	pointer
=	O
po_charset_canonicalize	function
(	O
charset	pointer
)	O
;	O
freea	function
(	O
charset	pointer
)	O
;	O
}	O
if	O
(	O
canon_charset	pointer
==	O
NULL	O
||	O
(	O
common_canon_charset	pointer
!=	O
NULL	O
&&	O
canon_charset	pointer
!=	O
common_canon_charset	pointer
)	O
)	O
{	O
common_canon_charset	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
common_canon_charset	pointer
=	O
canon_charset	pointer
;	O
}	O
if	O
(	O
common_canon_charset	pointer
!=	O
NULL	O
)	O
conversion_done	bool
=	O
true	int
;	O
}	O
if	O
(	O
!	O
conversion_done	bool
)	O
{	O
def	pointer
=	O
iconv_msgdomain_list	function
(	O
def	pointer
,	O
"UTF-8"	pointer
,	O
true	int
,	O
fn1	pointer
)	O
;	O
if	O
(	O
compendiums	pointer
!=	O
NULL	O
)	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
compendiums	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
iconv_message_list	function
(	O
compendiums	pointer
->	O
item	pointer
[	O
k	long
]	O
,	O
NULL	O
,	O
po_charset_utf8	pointer
,	O
compendium_filenames	pointer
->	O
item	pointer
[	O
k	long
]	O
)	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
use_fuzzy_matching	bool
)	O
{	O
def_canon_charset	pointer
=	O
def	pointer
->	O
encoding	pointer
;	O
if	O
(	O
def_canon_charset	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
charset	pointer
=	O
NULL	O
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
def	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
message_list_ty	struct
*	O
mlp	pointer
=	O
def	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
mlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
if	O
(	O
is_header	O
(	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
)	O
&&	O
!	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
obsolete	bool
)	O
{	O
const	O
char	O
*	O
header	pointer
=	O
mlp	pointer
->	O
item	pointer
[	O
j	long
]	O
->	O
msgstr	pointer
;	O
if	O
(	O
header	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
charsetstr	pointer
=	O
c_strstr	function
(	O
header	pointer
,	O
"charset="	pointer
)	O
;	O
if	O
(	O
charsetstr	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
len	long
;	O
charsetstr	pointer
+=	O
strlen	function
(	O
"charset="	pointer
)	O
;	O
len	long
=	O
strcspn	function
(	O
charsetstr	pointer
,	O
" \t\n"	pointer
)	O
;	O
charset	pointer
=	O
(	O
char	O
*	O
)	O
xmalloca	O
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
charset	pointer
,	O
charsetstr	pointer
,	O
len	long
)	O
;	O
charset	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
charset	pointer
!=	O
NULL	O
)	O
break	O
;	O
}	O
if	O
(	O
charset	pointer
!=	O
NULL	O
)	O
def_canon_charset	pointer
=	O
po_charset_canonicalize	function
(	O
charset	pointer
)	O
;	O
if	O
(	O
def_canon_charset	pointer
==	O
NULL	O
)	O
def_canon_charset	pointer
=	O
po_charset_ascii	pointer
;	O
}	O
}	O
else	O
def_canon_charset	pointer
=	O
NULL	O
;	O
definitions_init	function
(	O
&	O
definitions	pointer
,	O
def_canon_charset	pointer
)	O
;	O
empty_list	pointer
=	O
message_list_alloc	function
(	O
false	int
)	O
;	O
result	pointer
=	O
msgdomain_list_alloc	function
(	O
false	int
)	O
;	O
processed	pointer
=	O
0	int
;	O
if	O
(	O
!	O
multi_domain_mode	bool
)	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
ref	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
const	O
char	O
*	O
domain	pointer
=	O
ref	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
domain	pointer
;	O
message_list_ty	struct
*	O
refmlp	pointer
=	O
ref	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
message_list_ty	struct
*	O
resultmlp	pointer
=	O
msgdomain_list_sublist	function
(	O
result	pointer
,	O
domain	pointer
,	O
true	int
)	O
;	O
message_list_ty	struct
*	O
defmlp	pointer
;	O
defmlp	pointer
=	O
msgdomain_list_sublist	function
(	O
def	pointer
,	O
domain	pointer
,	O
false	int
)	O
;	O
if	O
(	O
defmlp	pointer
==	O
NULL	O
)	O
defmlp	pointer
=	O
empty_list	pointer
;	O
definitions_set_current_list	function
(	O
&	O
definitions	pointer
,	O
defmlp	pointer
)	O
;	O
match_domain	function
(	O
fn1	pointer
,	O
fn2	pointer
,	O
&	O
definitions	pointer
,	O
refmlp	pointer
,	O
resultmlp	pointer
,	O
&	O
stats	pointer
,	O
&	O
processed	pointer
)	O
;	O
}	O
else	O
{	O
message_list_ty	struct
*	O
refmlp	pointer
=	O
ref	pointer
->	O
item	pointer
[	O
0	int
]	O
->	O
messages	pointer
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
def	pointer
->	O
nitems	long
;	O
k	long
++	O
)	O
{	O
const	O
char	O
*	O
domain	pointer
=	O
def	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
domain	pointer
;	O
message_list_ty	struct
*	O
defmlp	pointer
=	O
def	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
if	O
(	O
k	long
>	O
0	int
||	O
defmlp	pointer
->	O
nitems	long
>	O
0	int
)	O
{	O
message_list_ty	struct
*	O
resultmlp	pointer
=	O
msgdomain_list_sublist	function
(	O
result	pointer
,	O
domain	pointer
,	O
true	int
)	O
;	O
definitions_set_current_list	function
(	O
&	O
definitions	pointer
,	O
defmlp	pointer
)	O
;	O
match_domain	function
(	O
fn1	pointer
,	O
fn2	pointer
,	O
&	O
definitions	pointer
,	O
refmlp	pointer
,	O
resultmlp	pointer
,	O
&	O
stats	pointer
,	O
&	O
processed	pointer
)	O
;	O
}	O
}	O
}	O
definitions_destroy	function
(	O
&	O
definitions	pointer
)	O
;	O
if	O
(	O
!	O
for_msgfmt	bool
)	O
{	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
def	pointer
->	O
nitems	long
;	O
++	O
k	long
)	O
{	O
const	O
char	O
*	O
domain	pointer
=	O
def	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
domain	pointer
;	O
message_list_ty	struct
*	O
defmlp	pointer
=	O
def	pointer
->	O
item	pointer
[	O
k	long
]	O
->	O
messages	pointer
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
defmlp	pointer
->	O
nitems	long
;	O
j	long
++	O
)	O
{	O
message_ty	struct
*	O
defmsg	pointer
=	O
defmlp	pointer
->	O
item	pointer
[	O
j	long
]	O
;	O
if	O
(	O
!	O
defmsg	pointer
->	O
used	int
)	O
{	O
message_ty	struct
*	O
mp	pointer
;	O
mp	pointer
=	O
message_copy	function
(	O
defmsg	pointer
)	O
;	O
if	O
(	O
mp	pointer
->	O
comment_dot	pointer
!=	O
NULL	O
)	O
{	O
string_list_free	function
(	O
mp	pointer
->	O
comment_dot	pointer
)	O
;	O
mp	pointer
->	O
comment_dot	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
mp	pointer
->	O
filepos	pointer
!=	O
NULL	O
)	O
{	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
mp	pointer
->	O
filepos_count	long
;	O
i	long
++	O
)	O
free	function
(	O
(	O
char	O
*	O
)	O
mp	pointer
->	O
filepos	pointer
[	O
i	long
]	O
.	O
file_name	pointer
)	O
;	O
mp	pointer
->	O
filepos_count	long
=	O
0	int
;	O
free	function
(	O
mp	pointer
->	O
filepos	pointer
)	O
;	O
mp	pointer
->	O
filepos	pointer
=	O
NULL	O
;	O
}	O
mp	pointer
->	O
obsolete	bool
=	O
true	int
;	O
message_list_append	function
(	O
msgdomain_list_sublist	function
(	O
result	pointer
,	O
domain	pointer
,	O
true	int
)	O
,	O
mp	pointer
)	O
;	O
stats	pointer
.	O
obsolete	bool
++	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
def	pointer
->	O
encoding	pointer
==	O
ref	pointer
->	O
encoding	pointer
)	O
result	pointer
->	O
encoding	pointer
=	O
def	pointer
->	O
encoding	pointer
;	O
if	O
(	O
verbosity_level	int
>	O
0	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%sRead %ld old + %ld reference, merged %ld, fuzzied %ld, missing %ld, obsolete %ld.\n"	pointer
)	O
,	O
!	O
quiet	bool
&&	O
verbosity_level	int
<=	O
1	int
?	O
"\n"	pointer
:	O
""	pointer
,	O
(	O
long	O
)	O
def	pointer
->	O
nitems	long
,	O
(	O
long	O
)	O
ref	pointer
->	O
nitems	long
,	O
(	O
long	O
)	O
stats	pointer
.	O
merged	long
,	O
(	O
long	O
)	O
stats	pointer
.	O
fuzzied	long
,	O
(	O
long	O
)	O
stats	pointer
.	O
missing	long
,	O
(	O
long	O
)	O
stats	pointer
.	O
obsolete	bool
)	O
;	O
else	O
if	O
(	O
!	O
quiet	bool
)	O
fputs	function
(	O
_	O
(	O
" done.\n"	pointer
)	O
,	O
stderr	pointer
)	O
;	O
*	O
defp	pointer
=	O
def	pointer
;	O
return	O
result	pointer
;	O
}	O
