bfd_boolean	int
literal_prefix_dollar_hex	int
=	O
FALSE	int
;	O
static	O
void	O
floating_constant	function
(	O
expressionS	struct
*	O
expressionP	pointer
)	O
;	O
static	O
valueT	long
generic_bignum_to_int32	function
(	O
void	O
)	O
;	O
static	O
valueT	long
generic_bignum_to_int64	function
(	O
void	O
)	O
;	O
static	O
void	O
integer_constant	function
(	O
int	O
radix	int
,	O
expressionS	struct
*	O
expressionP	pointer
)	O
;	O
static	O
void	O
mri_char_constant	function
(	O
expressionS	struct
*	O
)	O
;	O
static	O
void	O
clean_up_expression	function
(	O
expressionS	struct
*	O
expressionP	pointer
)	O
;	O
static	O
segT	pointer
operand	function
(	O
expressionS	struct
*	O
,	O
enum	O
expr_mode	enum
)	O
;	O
static	O
operatorT	enum
operatorf	function
(	O
int	O
*	O
)	O
;	O
struct	O
expr_symbol_line	struct
{	O
struct	O
expr_symbol_line	struct
*	O
next	pointer
;	O
symbolS	struct
*	O
sym	pointer
;	O
const	O
char	O
*	O
file	pointer
;	O
unsigned	O
int	O
line	int
;	O
}	O
;	O
static	O
struct	O
expr_symbol_line	struct
*	O
expr_symbol_lines	pointer
;	O
symbolS	struct
*	O
make_expr_symbol	function
(	O
expressionS	struct
*	O
expressionP	pointer
)	O
{	O
expressionS	struct
zero	struct
;	O
symbolS	struct
*	O
symbolP	pointer
;	O
struct	O
expr_symbol_line	struct
*	O
n	int
;	O
if	O
(	O
expressionP	pointer
->	O
X_op	enum
==	O
O_symbol	int
&&	O
expressionP	pointer
->	O
X_add_number	long
==	O
0	int
)	O
return	O
expressionP	pointer
->	O
X_add_symbol	pointer
;	O
if	O
(	O
expressionP	pointer
->	O
X_op	enum
==	O
O_big	int
)	O
{	O
if	O
(	O
expressionP	pointer
->	O
X_add_number	long
>	O
0	int
)	O
as_bad	function
(	O
_	O
(	O
"bignum invalid"	pointer
)	O
)	O
;	O
else	O
as_bad	function
(	O
_	O
(	O
"floating point number invalid"	pointer
)	O
)	O
;	O
zero	struct
.	O
X_op	enum
=	O
O_constant	int
;	O
zero	struct
.	O
X_add_number	long
=	O
0	int
;	O
zero	struct
.	O
X_unsigned	int
=	O
0	int
;	O
zero	struct
.	O
X_extrabit	int
=	O
0	int
;	O
clean_up_expression	function
(	O
&	O
zero	struct
)	O
;	O
expressionP	pointer
=	O
&	O
zero	struct
;	O
}	O
symbolP	pointer
=	O
symbol_create	function
(	O
FAKE_LABEL_NAME	pointer
,	O
(	O
expressionP	pointer
->	O
X_op	enum
==	O
O_constant	int
?	O
absolute_section	O
:	O
expressionP	pointer
->	O
X_op	enum
==	O
O_register	int
?	O
reg_section	pointer
:	O
expr_section	pointer
)	O
,	O
0	int
,	O
&	O
zero_address_frag	struct
)	O
;	O
symbol_set_value_expression	function
(	O
symbolP	pointer
,	O
expressionP	pointer
)	O
;	O
if	O
(	O
expressionP	pointer
->	O
X_op	enum
==	O
O_constant	int
)	O
resolve_symbol_value	function
(	O
symbolP	pointer
)	O
;	O
n	int
=	O
XNEW	O
(	O
struct	O
expr_symbol_line	struct
)	O
;	O
n	int
->	O
sym	pointer
=	O
symbolP	pointer
;	O
n	int
->	O
file	pointer
=	O
as_where	function
(	O
&	O
n	int
->	O
line	int
)	O
;	O
n	int
->	O
next	pointer
=	O
expr_symbol_lines	pointer
;	O
expr_symbol_lines	pointer
=	O
n	int
;	O
return	O
symbolP	pointer
;	O
}	O
int	O
expr_symbol_where	function
(	O
symbolS	struct
*	O
sym	pointer
,	O
const	O
char	O
*	O
*	O
pfile	pointer
,	O
unsigned	O
int	O
*	O
pline	pointer
)	O
{	O
struct	O
expr_symbol_line	struct
*	O
l	long
;	O
for	O
(	O
l	long
=	O
expr_symbol_lines	pointer
;	O
l	long
!=	O
NULL	O
;	O
l	long
=	O
l	long
->	O
next	pointer
)	O
{	O
if	O
(	O
l	long
->	O
sym	pointer
==	O
sym	pointer
)	O
{	O
*	O
pfile	pointer
=	O
l	long
->	O
file	pointer
;	O
*	O
pline	pointer
=	O
l	long
->	O
line	int
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
symbolS	struct
*	O
expr_build_uconstant	function
(	O
offsetT	long
value	long
)	O
{	O
expressionS	struct
e	struct
;	O
e	struct
.	O
X_op	enum
=	O
O_constant	int
;	O
e	struct
.	O
X_add_number	long
=	O
value	long
;	O
e	struct
.	O
X_unsigned	int
=	O
1	int
;	O
e	struct
.	O
X_extrabit	int
=	O
0	int
;	O
return	O
make_expr_symbol	function
(	O
&	O
e	struct
)	O
;	O
}	O
symbolS	struct
*	O
expr_build_dot	function
(	O
void	O
)	O
{	O
expressionS	struct
e	struct
;	O
current_location	function
(	O
&	O
e	struct
)	O
;	O
return	O
symbol_clone_if_forward_ref	function
(	O
make_expr_symbol	function
(	O
&	O
e	struct
)	O
)	O
;	O
}	O
LITTLENUM_TYPE	short
generic_bignum	array
[	O
SIZE_OF_LARGE_NUMBER	O
+	O
6	int
]	O
;	O
FLONUM_TYPE	struct
generic_floating_point_number	struct
=	O
{	O
&	O
generic_bignum	array
[	O
6	int
]	O
,	O
&	O
generic_bignum	array
[	O
SIZE_OF_LARGE_NUMBER	O
+	O
6	int
-	O
1	int
]	O
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
static	O
void	O
floating_constant	function
(	O
expressionS	struct
*	O
expressionP	pointer
)	O
{	O
int	O
error_code	int
;	O
error_code	int
=	O
atof_generic	function
(	O
&	O
input_line_pointer	pointer
,	O
"."	pointer
,	O
EXP_CHARS	array
,	O
&	O
generic_floating_point_number	struct
)	O
;	O
if	O
(	O
error_code	int
)	O
{	O
if	O
(	O
error_code	int
==	O
ERROR_EXPONENT_OVERFLOW	O
)	O
{	O
as_bad	function
(	O
_	O
(	O
"bad floating-point constant: exponent overflow"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
as_bad	function
(	O
_	O
(	O
"bad floating-point constant: unknown error code=%d"	pointer
)	O
,	O
error_code	int
)	O
;	O
}	O
}	O
expressionP	pointer
->	O
X_op	enum
=	O
O_big	int
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
-	O
1	int
;	O
}	O
static	O
valueT	long
generic_bignum_to_int32	function
(	O
void	O
)	O
{	O
valueT	long
number	long
=	O
(	O
(	O
generic_bignum	array
[	O
1	int
]	O
&	O
LITTLENUM_MASK	O
)	O
<<	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
|	O
(	O
generic_bignum	array
[	O
0	int
]	O
&	O
LITTLENUM_MASK	O
)	O
;	O
number	long
&=	O
0xffffffff	int
;	O
return	O
number	long
;	O
}	O
static	O
valueT	long
generic_bignum_to_int64	function
(	O
void	O
)	O
{	O
valueT	long
number	long
=	O
(	O
(	O
(	O
(	O
(	O
(	O
(	O
(	O
valueT	long
)	O
generic_bignum	array
[	O
3	int
]	O
&	O
LITTLENUM_MASK	O
)	O
<<	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
|	O
(	O
(	O
valueT	long
)	O
generic_bignum	array
[	O
2	int
]	O
&	O
LITTLENUM_MASK	O
)	O
)	O
<<	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
|	O
(	O
(	O
valueT	long
)	O
generic_bignum	array
[	O
1	int
]	O
&	O
LITTLENUM_MASK	O
)	O
)	O
<<	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
|	O
(	O
(	O
valueT	long
)	O
generic_bignum	array
[	O
0	int
]	O
&	O
LITTLENUM_MASK	O
)	O
)	O
;	O
return	O
number	long
;	O
}	O
static	O
void	O
integer_constant	function
(	O
int	O
radix	int
,	O
expressionS	struct
*	O
expressionP	pointer
)	O
{	O
char	O
*	O
start	pointer
;	O
char	O
*	O
suffix	pointer
=	O
NULL	O
;	O
char	O
c	struct
;	O
valueT	long
number	long
;	O
short	O
int	O
digit	short
;	O
short	O
int	O
maxdig	short
=	O
0	int
;	O
int	O
too_many_digits	int
=	O
0	int
;	O
char	O
*	O
name	pointer
;	O
symbolS	struct
*	O
symbolP	pointer
;	O
int	O
small	int
;	O
if	O
(	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
*	O
input_line_pointer	pointer
]	O
)	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_absent	int
;	O
return	O
;	O
}	O
if	O
(	O
(	O
NUMBERS_WITH_SUFFIX	int
||	O
flag_m68k_mri	int
)	O
&&	O
radix	int
==	O
0	int
)	O
{	O
int	O
flt	int
=	O
0	int
;	O
for	O
(	O
suffix	pointer
=	O
input_line_pointer	pointer
;	O
ISALNUM	O
(	O
*	O
suffix	pointer
)	O
;	O
suffix	pointer
++	O
)	O
{	O
if	O
(	O
*	O
suffix	pointer
==	O
'e'	O
||	O
*	O
suffix	pointer
==	O
'E'	O
)	O
flt	int
=	O
1	int
;	O
}	O
if	O
(	O
suffix	pointer
==	O
input_line_pointer	pointer
)	O
{	O
radix	int
=	O
10	int
;	O
suffix	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
c	struct
=	O
*	O
--	O
suffix	pointer
;	O
c	struct
=	O
TOUPPER	O
(	O
c	struct
)	O
;	O
if	O
(	O
(	O
NUMBERS_WITH_SUFFIX	int
&&	O
LOCAL_LABELS_FB	int
?	O
*	O
suffix	pointer
:	O
c	struct
)	O
==	O
'B'	O
)	O
radix	int
=	O
2	int
;	O
else	O
if	O
(	O
c	struct
==	O
'D'	O
)	O
radix	int
=	O
10	int
;	O
else	O
if	O
(	O
c	struct
==	O
'O'	O
||	O
c	struct
==	O
'Q'	O
)	O
radix	int
=	O
8	int
;	O
else	O
if	O
(	O
c	struct
==	O
'H'	O
)	O
radix	int
=	O
16	int
;	O
else	O
if	O
(	O
suffix	pointer
[	O
1	int
]	O
==	O
'.'	O
||	O
c	struct
==	O
'E'	O
||	O
flt	int
)	O
{	O
floating_constant	function
(	O
expressionP	pointer
)	O
;	O
return	O
;	O
}	O
else	O
{	O
radix	int
=	O
10	int
;	O
suffix	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
switch	O
(	O
radix	int
)	O
{	O
case	O
2	int
:	O
maxdig	short
=	O
2	int
;	O
too_many_digits	int
=	O
valuesize	int
+	O
1	int
;	O
break	O
;	O
case	O
8	int
:	O
maxdig	short
=	O
radix	int
=	O
8	int
;	O
too_many_digits	int
=	O
(	O
valuesize	int
+	O
2	int
)	O
/	O
3	int
+	O
1	int
;	O
break	O
;	O
case	O
16	int
:	O
maxdig	short
=	O
radix	int
=	O
16	int
;	O
too_many_digits	int
=	O
(	O
valuesize	int
+	O
3	int
)	O
/	O
4	int
+	O
1	int
;	O
break	O
;	O
case	O
10	int
:	O
maxdig	short
=	O
radix	int
=	O
10	int
;	O
too_many_digits	int
=	O
(	O
valuesize	int
+	O
11	int
)	O
/	O
4	int
;	O
}	O
start	pointer
=	O
input_line_pointer	pointer
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
for	O
(	O
number	long
=	O
0	int
;	O
(	O
digit	short
=	O
hex_value	O
(	O
c	struct
)	O
)	O
<	O
maxdig	short
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
)	O
{	O
number	long
=	O
number	long
*	O
radix	int
+	O
digit	short
;	O
}	O
small	int
=	O
(	O
input_line_pointer	pointer
-	O
start	pointer
-	O
1	int
)	O
<	O
too_many_digits	int
;	O
if	O
(	O
radix	int
==	O
16	int
&&	O
c	struct
==	O
'_'	O
)	O
{	O
int	O
num_little_digits	int
=	O
0	int
;	O
int	O
i	pointer
;	O
input_line_pointer	pointer
=	O
start	pointer
;	O
know	O
(	O
LITTLENUM_NUMBER_OF_BITS	O
==	O
16	int
)	O
;	O
for	O
(	O
c	struct
=	O
'_'	O
;	O
c	struct
==	O
'_'	O
;	O
num_little_digits	int
+=	O
2	int
)	O
{	O
int	O
ndigit	int
=	O
0	int
;	O
number	long
=	O
0	int
;	O
for	O
(	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
(	O
digit	short
=	O
hex_value	O
(	O
c	struct
)	O
)	O
<	O
maxdig	short
;	O
c	struct
=	O
*	O
(	O
input_line_pointer	pointer
++	O
)	O
)	O
{	O
number	long
=	O
number	long
*	O
radix	int
+	O
digit	short
;	O
ndigit	int
++	O
;	O
}	O
if	O
(	O
ndigit	int
>	O
8	int
)	O
as_bad	function
(	O
_	O
(	O
"a bignum with underscores may not have more than 8 hex digits in any word"	pointer
)	O
)	O
;	O
know	O
(	O
LITTLENUM_NUMBER_OF_BITS	O
==	O
16	int
)	O
;	O
for	O
(	O
i	pointer
=	O
min	O
(	O
num_little_digits	int
+	O
1	int
,	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
)	O
;	O
i	pointer
>=	O
2	int
;	O
i	pointer
--	O
)	O
generic_bignum	array
[	O
i	pointer
]	O
=	O
generic_bignum	array
[	O
i	pointer
-	O
2	int
]	O
;	O
generic_bignum	array
[	O
0	int
]	O
=	O
number	long
&	O
0xffffffff	int
;	O
generic_bignum	array
[	O
1	int
]	O
=	O
number	long
>>	O
16	int
;	O
}	O
if	O
(	O
num_little_digits	int
>	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
)	O
num_little_digits	int
=	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
;	O
gas_assert	O
(	O
num_little_digits	int
>=	O
4	int
)	O
;	O
if	O
(	O
num_little_digits	int
!=	O
8	int
)	O
as_bad	function
(	O
_	O
(	O
"a bignum with underscores must have exactly 4 words"	pointer
)	O
)	O
;	O
while	O
(	O
generic_bignum	array
[	O
num_little_digits	int
-	O
1	int
]	O
==	O
0	int
&&	O
num_little_digits	int
>	O
1	int
)	O
num_little_digits	int
--	O
;	O
if	O
(	O
num_little_digits	int
<=	O
2	int
)	O
{	O
number	long
=	O
generic_bignum_to_int32	function
(	O
)	O
;	O
small	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
num_little_digits	int
<=	O
4	int
)	O
{	O
number	long
=	O
generic_bignum_to_int64	function
(	O
)	O
;	O
small	int
=	O
1	int
;	O
}	O
else	O
{	O
small	int
=	O
0	int
;	O
number	long
=	O
num_little_digits	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
small	int
)	O
{	O
LITTLENUM_TYPE	short
*	O
leader	pointer
;	O
LITTLENUM_TYPE	short
*	O
pointer	pointer
;	O
long	O
carry	long
;	O
leader	pointer
=	O
generic_bignum	array
;	O
generic_bignum	array
[	O
0	int
]	O
=	O
0	int
;	O
generic_bignum	array
[	O
1	int
]	O
=	O
0	int
;	O
generic_bignum	array
[	O
2	int
]	O
=	O
0	int
;	O
generic_bignum	array
[	O
3	int
]	O
=	O
0	int
;	O
input_line_pointer	pointer
=	O
start	pointer
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
for	O
(	O
;	O
(	O
carry	long
=	O
hex_value	O
(	O
c	struct
)	O
)	O
<	O
maxdig	short
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
)	O
{	O
for	O
(	O
pointer	pointer
=	O
generic_bignum	array
;	O
pointer	pointer
<=	O
leader	pointer
;	O
pointer	pointer
++	O
)	O
{	O
long	O
work	long
;	O
work	long
=	O
carry	long
+	O
radix	int
*	O
*	O
pointer	pointer
;	O
*	O
pointer	pointer
=	O
work	long
&	O
LITTLENUM_MASK	O
;	O
carry	long
=	O
work	long
>>	O
LITTLENUM_NUMBER_OF_BITS	O
;	O
}	O
if	O
(	O
carry	long
)	O
{	O
if	O
(	O
leader	pointer
<	O
generic_bignum	array
+	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
)	O
{	O
*	O
++	O
leader	pointer
=	O
carry	long
;	O
}	O
}	O
}	O
know	O
(	O
LITTLENUM_NUMBER_OF_BITS	O
==	O
16	int
)	O
;	O
if	O
(	O
leader	pointer
<	O
generic_bignum	array
+	O
2	int
)	O
{	O
number	long
=	O
generic_bignum_to_int32	function
(	O
)	O
;	O
small	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
leader	pointer
<	O
generic_bignum	array
+	O
4	int
)	O
{	O
number	long
=	O
generic_bignum_to_int64	function
(	O
)	O
;	O
small	int
=	O
1	int
;	O
}	O
else	O
{	O
number	long
=	O
leader	pointer
-	O
generic_bignum	array
+	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
NUMBERS_WITH_SUFFIX	int
||	O
flag_m68k_mri	int
)	O
&&	O
suffix	pointer
!=	O
NULL	O
&&	O
input_line_pointer	pointer
-	O
1	int
==	O
suffix	pointer
)	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
if	O
(	O
tc_allow_U_suffix	int
&&	O
(	O
c	struct
==	O
'U'	O
||	O
c	struct
==	O
'u'	O
)	O
)	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
if	O
(	O
tc_allow_L_suffix	int
)	O
while	O
(	O
c	struct
==	O
'L'	O
||	O
c	struct
==	O
'l'	O
)	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
if	O
(	O
small	int
)	O
{	O
if	O
(	O
LOCAL_LABELS_FB	int
&&	O
c	struct
==	O
'b'	O
)	O
{	O
name	pointer
=	O
fb_label_name	function
(	O
(	O
int	O
)	O
number	long
,	O
0	int
)	O
;	O
symbolP	pointer
=	O
symbol_find	function
(	O
name	pointer
)	O
;	O
if	O
(	O
(	O
symbolP	pointer
!=	O
NULL	O
)	O
&&	O
(	O
S_IS_DEFINED	function
(	O
symbolP	pointer
)	O
)	O
)	O
{	O
know	O
(	O
SEG_NORMAL	O
(	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
)	O
)	O
;	O
expressionP	pointer
->	O
X_op	enum
=	O
O_symbol	int
;	O
expressionP	pointer
->	O
X_add_symbol	pointer
=	O
symbolP	pointer
;	O
}	O
else	O
{	O
as_bad	function
(	O
_	O
(	O
"backward ref to unknown label \"%d:\""	pointer
)	O
,	O
(	O
int	O
)	O
number	long
)	O
;	O
expressionP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
}	O
expressionP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
LOCAL_LABELS_FB	int
&&	O
c	struct
==	O
'f'	O
)	O
{	O
name	pointer
=	O
fb_label_name	function
(	O
(	O
int	O
)	O
number	long
,	O
1	int
)	O
;	O
symbolP	pointer
=	O
symbol_find_or_make	function
(	O
name	pointer
)	O
;	O
know	O
(	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
==	O
undefined_section	O
||	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
==	O
text_section	pointer
||	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
==	O
data_section	pointer
)	O
;	O
expressionP	pointer
->	O
X_op	enum
=	O
O_symbol	int
;	O
expressionP	pointer
->	O
X_add_symbol	pointer
=	O
symbolP	pointer
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
}	O
else	O
if	O
(	O
LOCAL_LABELS_DOLLAR	int
&&	O
c	struct
==	O
'$'	O
)	O
{	O
if	O
(	O
dollar_label_defined	function
(	O
(	O
long	O
)	O
number	long
)	O
)	O
{	O
name	pointer
=	O
dollar_label_name	function
(	O
(	O
long	O
)	O
number	long
,	O
0	int
)	O
;	O
symbolP	pointer
=	O
symbol_find	function
(	O
name	pointer
)	O
;	O
know	O
(	O
symbolP	pointer
!=	O
NULL	O
)	O
;	O
}	O
else	O
{	O
name	pointer
=	O
dollar_label_name	function
(	O
(	O
long	O
)	O
number	long
,	O
1	int
)	O
;	O
symbolP	pointer
=	O
symbol_find_or_make	function
(	O
name	pointer
)	O
;	O
}	O
expressionP	pointer
->	O
X_op	enum
=	O
O_symbol	int
;	O
expressionP	pointer
->	O
X_add_symbol	pointer
=	O
symbolP	pointer
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
}	O
else	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
number	long
;	O
input_line_pointer	pointer
--	O
;	O
}	O
}	O
else	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_big	int
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
number	long
;	O
input_line_pointer	pointer
--	O
;	O
}	O
}	O
static	O
void	O
mri_char_constant	function
(	O
expressionS	struct
*	O
expressionP	pointer
)	O
{	O
int	O
i	pointer
;	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
'\''	O
&&	O
input_line_pointer	pointer
[	O
1	int
]	O
!=	O
'\''	O
)	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
return	O
;	O
}	O
for	O
(	O
i	pointer
=	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
;	O
i	pointer
>=	O
0	int
;	O
i	pointer
--	O
)	O
{	O
int	O
j	int
;	O
generic_bignum	array
[	O
i	pointer
]	O
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
CHARS_PER_LITTLENUM	O
;	O
j	int
++	O
)	O
{	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
'\''	O
)	O
{	O
if	O
(	O
input_line_pointer	pointer
[	O
1	int
]	O
!=	O
'\''	O
)	O
break	O
;	O
++	O
input_line_pointer	pointer
;	O
}	O
generic_bignum	array
[	O
i	pointer
]	O
<<=	O
8	int
;	O
generic_bignum	array
[	O
i	pointer
]	O
+=	O
*	O
input_line_pointer	pointer
;	O
++	O
input_line_pointer	pointer
;	O
}	O
if	O
(	O
i	pointer
<	O
SIZE_OF_LARGE_NUMBER	O
-	O
1	int
)	O
{	O
for	O
(	O
;	O
j	int
<	O
CHARS_PER_LITTLENUM	O
;	O
j	int
++	O
)	O
generic_bignum	array
[	O
i	pointer
]	O
<<=	O
8	int
;	O
}	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
'\''	O
&&	O
input_line_pointer	pointer
[	O
1	int
]	O
!=	O
'\''	O
)	O
break	O
;	O
}	O
if	O
(	O
i	pointer
<	O
0	int
)	O
{	O
as_bad	function
(	O
_	O
(	O
"character constant too large"	pointer
)	O
)	O
;	O
i	pointer
=	O
0	int
;	O
}	O
if	O
(	O
i	pointer
>	O
0	int
)	O
{	O
int	O
c	struct
;	O
int	O
j	int
;	O
c	struct
=	O
SIZE_OF_LARGE_NUMBER	O
-	O
i	pointer
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
c	struct
;	O
j	int
++	O
)	O
generic_bignum	array
[	O
j	int
]	O
=	O
generic_bignum	array
[	O
i	pointer
+	O
j	int
]	O
;	O
i	pointer
=	O
c	struct
;	O
}	O
know	O
(	O
LITTLENUM_NUMBER_OF_BITS	O
==	O
16	int
)	O
;	O
if	O
(	O
i	pointer
>	O
2	int
)	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_big	int
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
i	pointer
;	O
}	O
else	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
if	O
(	O
i	pointer
<	O
2	int
)	O
expressionP	pointer
->	O
X_add_number	long
=	O
generic_bignum	array
[	O
0	int
]	O
&	O
LITTLENUM_MASK	O
;	O
else	O
expressionP	pointer
->	O
X_add_number	long
=	O
(	O
(	O
(	O
generic_bignum	array
[	O
1	int
]	O
&	O
LITTLENUM_MASK	O
)	O
<<	O
LITTLENUM_NUMBER_OF_BITS	O
)	O
|	O
(	O
generic_bignum	array
[	O
0	int
]	O
&	O
LITTLENUM_MASK	O
)	O
)	O
;	O
}	O
++	O
input_line_pointer	pointer
;	O
}	O
void	O
current_location	function
(	O
expressionS	struct
*	O
expressionp	pointer
)	O
{	O
if	O
(	O
now_seg	pointer
==	O
absolute_section	O
)	O
{	O
expressionp	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
expressionp	pointer
->	O
X_add_number	long
=	O
abs_section_offset	long
;	O
}	O
else	O
{	O
expressionp	pointer
->	O
X_op	enum
=	O
O_symbol	int
;	O
expressionp	pointer
->	O
X_add_symbol	pointer
=	O
&	O
dot_symbol	struct
;	O
expressionp	pointer
->	O
X_add_number	long
=	O
0	int
;	O
}	O
}	O
static	O
segT	pointer
operand	function
(	O
expressionS	struct
*	O
expressionP	pointer
,	O
enum	O
expr_mode	enum
mode	pointer
)	O
{	O
char	O
c	struct
;	O
symbolS	struct
*	O
symbolP	pointer
;	O
char	O
*	O
name	pointer
;	O
segT	pointer
segment	pointer
;	O
expressionP	pointer
->	O
X_unsigned	int
=	O
1	int
;	O
expressionP	pointer
->	O
X_extrabit	int
=	O
0	int
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
if	O
(	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
c	struct
]	O
)	O
goto	O
eol	O
;	O
switch	O
(	O
c	struct
)	O
{	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
input_line_pointer	pointer
--	O
;	O
integer_constant	function
(	O
(	O
NUMBERS_WITH_SUFFIX	int
||	O
flag_m68k_mri	int
)	O
?	O
0	int
:	O
10	int
,	O
expressionP	pointer
)	O
;	O
break	O
;	O
case	O
'0'	O
:	O
if	O
(	O
NUMBERS_WITH_SUFFIX	int
||	O
flag_m68k_mri	int
)	O
{	O
char	O
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
input_line_pointer	pointer
;	O
hex_p	O
(	O
*	O
s	pointer
)	O
;	O
s	pointer
++	O
)	O
;	O
if	O
(	O
*	O
s	pointer
==	O
'h'	O
||	O
*	O
s	pointer
==	O
'H'	O
||	O
*	O
input_line_pointer	pointer
==	O
'.'	O
)	O
{	O
--	O
input_line_pointer	pointer
;	O
integer_constant	function
(	O
0	int
,	O
expressionP	pointer
)	O
;	O
break	O
;	O
}	O
}	O
c	struct
=	O
*	O
input_line_pointer	pointer
;	O
switch	O
(	O
c	struct
)	O
{	O
case	O
'o'	O
:	O
case	O
'O'	O
:	O
case	O
'q'	O
:	O
case	O
'Q'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
if	O
(	O
NUMBERS_WITH_SUFFIX	int
||	O
flag_m68k_mri	int
)	O
{	O
integer_constant	function
(	O
0	int
,	O
expressionP	pointer
)	O
;	O
break	O
;	O
}	O
default	O
:	O
default_case	O
:	O
if	O
(	O
c	struct
&&	O
strchr	function
(	O
FLT_CHARS	array
,	O
c	struct
)	O
)	O
{	O
input_line_pointer	pointer
++	O
;	O
floating_constant	function
(	O
expressionP	pointer
)	O
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
-	O
TOLOWER	O
(	O
c	struct
)	O
;	O
}	O
else	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'x'	O
:	O
case	O
'X'	O
:	O
if	O
(	O
flag_m68k_mri	int
)	O
goto	O
default_case	O
;	O
input_line_pointer	pointer
++	O
;	O
integer_constant	function
(	O
16	int
,	O
expressionP	pointer
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
if	O
(	O
LOCAL_LABELS_FB	int
&&	O
!	O
flag_m68k_mri	int
&&	O
input_line_pointer	pointer
[	O
1	int
]	O
!=	O
'0'	O
&&	O
input_line_pointer	pointer
[	O
1	int
]	O
!=	O
'1'	O
)	O
{	O
input_line_pointer	pointer
--	O
;	O
integer_constant	function
(	O
10	int
,	O
expressionP	pointer
)	O
;	O
break	O
;	O
}	O
case	O
'B'	O
:	O
if	O
(	O
input_line_pointer	pointer
[	O
1	int
]	O
==	O
'0'	O
||	O
input_line_pointer	pointer
[	O
1	int
]	O
==	O
'1'	O
)	O
{	O
input_line_pointer	pointer
++	O
;	O
integer_constant	function
(	O
2	int
,	O
expressionP	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
flag_m68k_mri	int
||	O
NUMBERS_WITH_SUFFIX	int
)	O
input_line_pointer	pointer
++	O
;	O
goto	O
default_case	O
;	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
integer_constant	function
(	O
(	O
flag_m68k_mri	int
||	O
NUMBERS_WITH_SUFFIX	int
)	O
?	O
0	int
:	O
8	int
,	O
expressionP	pointer
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
LOCAL_LABELS_FB	int
)	O
{	O
int	O
is_label	int
=	O
1	int
;	O
if	O
(	O
!	O
is_end_of_line	array
[	O
(	O
unsigned	O
char	O
)	O
input_line_pointer	pointer
[	O
1	int
]	O
]	O
&&	O
strchr	function
(	O
FLT_CHARS	array
,	O
'f'	O
)	O
!=	O
NULL	O
)	O
{	O
char	O
*	O
cp	pointer
=	O
input_line_pointer	pointer
+	O
1	int
;	O
atof_generic	function
(	O
&	O
cp	pointer
,	O
"."	pointer
,	O
EXP_CHARS	array
,	O
&	O
generic_floating_point_number	struct
)	O
;	O
is_label	int
=	O
(	O
cp	pointer
==	O
input_line_pointer	pointer
+	O
1	int
||	O
(	O
cp	pointer
==	O
input_line_pointer	pointer
+	O
2	int
&&	O
(	O
cp	pointer
[	O
-	O
1	int
]	O
==	O
'-'	O
||	O
cp	pointer
[	O
-	O
1	int
]	O
==	O
'+'	O
)	O
)	O
||	O
*	O
cp	pointer
==	O
'f'	O
||	O
*	O
cp	pointer
==	O
'b'	O
)	O
;	O
}	O
if	O
(	O
is_label	int
)	O
{	O
input_line_pointer	pointer
--	O
;	O
integer_constant	function
(	O
10	int
,	O
expressionP	pointer
)	O
;	O
break	O
;	O
}	O
}	O
case	O
'd'	O
:	O
case	O
'D'	O
:	O
if	O
(	O
flag_m68k_mri	int
||	O
NUMBERS_WITH_SUFFIX	int
)	O
{	O
integer_constant	function
(	O
0	int
,	O
expressionP	pointer
)	O
;	O
break	O
;	O
}	O
case	O
'F'	O
:	O
case	O
'r'	O
:	O
case	O
'e'	O
:	O
case	O
'E'	O
:	O
case	O
'g'	O
:	O
case	O
'G'	O
:	O
input_line_pointer	pointer
++	O
;	O
floating_constant	function
(	O
expressionP	pointer
)	O
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
-	O
TOLOWER	O
(	O
c	struct
)	O
;	O
break	O
;	O
case	O
'$'	O
:	O
if	O
(	O
LOCAL_LABELS_DOLLAR	int
)	O
{	O
integer_constant	function
(	O
10	int
,	O
expressionP	pointer
)	O
;	O
break	O
;	O
}	O
else	O
goto	O
default_case	O
;	O
}	O
break	O
;	O
case	O
'['	O
:	O
if	O
(	O
md_need_index_operator	O
(	O
)	O
)	O
goto	O
de_fault	O
;	O
case	O
'('	O
:	O
segment	pointer
=	O
expr	function
(	O
0	int
,	O
expressionP	pointer
,	O
mode	pointer
)	O
;	O
if	O
(	O
(	O
c	struct
==	O
'('	O
&&	O
*	O
input_line_pointer	pointer
!=	O
')'	O
)	O
||	O
(	O
c	struct
==	O
'['	O
&&	O
*	O
input_line_pointer	pointer
!=	O
']'	O
)	O
)	O
{	O
if	O
(	O
*	O
input_line_pointer	pointer
)	O
as_bad	function
(	O
_	O
(	O
"found '%c', expected: '%c'"	pointer
)	O
,	O
*	O
input_line_pointer	pointer
,	O
c	struct
==	O
'('	O
?	O
')'	O
:	O
']'	O
)	O
;	O
else	O
as_bad	function
(	O
_	O
(	O
"missing '%c'"	pointer
)	O
,	O
c	struct
==	O
'('	O
?	O
')'	O
:	O
']'	O
)	O
;	O
}	O
else	O
input_line_pointer	pointer
++	O
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
return	O
segment	pointer
;	O
case	O
'\''	O
:	O
if	O
(	O
!	O
flag_m68k_mri	int
)	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
*	O
input_line_pointer	pointer
++	O
;	O
break	O
;	O
}	O
mri_char_constant	function
(	O
expressionP	pointer
)	O
;	O
break	O
;	O
case	O
'~'	O
:	O
if	O
(	O
is_name_beginner	O
(	O
c	struct
)	O
)	O
goto	O
isname	O
;	O
case	O
'!'	O
:	O
case	O
'-'	O
:	O
case	O
'+'	O
:	O
{	O
unary	O
:	O
operand	function
(	O
expressionP	pointer
,	O
mode	pointer
)	O
;	O
if	O
(	O
expressionP	pointer
->	O
X_op	enum
==	O
O_constant	int
)	O
{	O
if	O
(	O
c	struct
==	O
'-'	O
)	O
{	O
expressionP	pointer
->	O
X_add_number	long
=	O
-	O
(	O
addressT	long
)	O
expressionP	pointer
->	O
X_add_number	long
;	O
expressionP	pointer
->	O
X_unsigned	int
=	O
0	int
;	O
if	O
(	O
expressionP	pointer
->	O
X_add_number	long
)	O
expressionP	pointer
->	O
X_extrabit	int
^=	O
1	int
;	O
}	O
else	O
if	O
(	O
c	struct
==	O
'~'	O
||	O
c	struct
==	O
'"'	O
)	O
expressionP	pointer
->	O
X_add_number	long
=	O
~	O
expressionP	pointer
->	O
X_add_number	long
;	O
else	O
if	O
(	O
c	struct
==	O
'!'	O
)	O
expressionP	pointer
->	O
X_add_number	long
=	O
!	O
expressionP	pointer
->	O
X_add_number	long
;	O
}	O
else	O
if	O
(	O
expressionP	pointer
->	O
X_op	enum
==	O
O_big	int
&&	O
expressionP	pointer
->	O
X_add_number	long
<=	O
0	int
&&	O
c	struct
==	O
'-'	O
&&	O
(	O
generic_floating_point_number	struct
.	O
sign	char
==	O
'+'	O
||	O
generic_floating_point_number	struct
.	O
sign	char
==	O
'P'	O
)	O
)	O
{	O
if	O
(	O
generic_floating_point_number	struct
.	O
sign	char
==	O
'+'	O
)	O
generic_floating_point_number	struct
.	O
sign	char
=	O
'-'	O
;	O
else	O
generic_floating_point_number	struct
.	O
sign	char
=	O
'N'	O
;	O
}	O
else	O
if	O
(	O
expressionP	pointer
->	O
X_op	enum
==	O
O_big	int
&&	O
expressionP	pointer
->	O
X_add_number	long
>	O
0	int
)	O
{	O
int	O
i	pointer
;	O
if	O
(	O
c	struct
==	O
'~'	O
||	O
c	struct
==	O
'-'	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
expressionP	pointer
->	O
X_add_number	long
;	O
++	O
i	pointer
)	O
generic_bignum	array
[	O
i	pointer
]	O
=	O
~	O
generic_bignum	array
[	O
i	pointer
]	O
;	O
if	O
(	O
expressionP	pointer
->	O
X_add_number	long
<	O
SIZE_OF_LARGE_NUMBER	O
)	O
{	O
expressionP	pointer
->	O
X_add_number	long
=	O
SIZE_OF_LARGE_NUMBER	O
;	O
for	O
(	O
;	O
i	pointer
<	O
expressionP	pointer
->	O
X_add_number	long
;	O
++	O
i	pointer
)	O
generic_bignum	array
[	O
i	pointer
]	O
=	O
~	O
(	O
LITTLENUM_TYPE	short
)	O
0	int
;	O
}	O
if	O
(	O
c	struct
==	O
'-'	O
)	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
expressionP	pointer
->	O
X_add_number	long
;	O
++	O
i	pointer
)	O
{	O
generic_bignum	array
[	O
i	pointer
]	O
+=	O
1	int
;	O
if	O
(	O
generic_bignum	array
[	O
i	pointer
]	O
)	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
c	struct
==	O
'!'	O
)	O
{	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
expressionP	pointer
->	O
X_add_number	long
;	O
++	O
i	pointer
)	O
if	O
(	O
generic_bignum	array
[	O
i	pointer
]	O
!=	O
0	int
)	O
break	O
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
i	pointer
>=	O
expressionP	pointer
->	O
X_add_number	long
;	O
expressionP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
expressionP	pointer
->	O
X_unsigned	int
=	O
1	int
;	O
expressionP	pointer
->	O
X_extrabit	int
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
expressionP	pointer
->	O
X_op	enum
!=	O
O_illegal	int
&&	O
expressionP	pointer
->	O
X_op	enum
!=	O
O_absent	int
)	O
{	O
if	O
(	O
c	struct
!=	O
'+'	O
)	O
{	O
expressionP	pointer
->	O
X_add_symbol	pointer
=	O
make_expr_symbol	function
(	O
expressionP	pointer
)	O
;	O
if	O
(	O
c	struct
==	O
'-'	O
)	O
expressionP	pointer
->	O
X_op	enum
=	O
O_uminus	int
;	O
else	O
if	O
(	O
c	struct
==	O
'~'	O
||	O
c	struct
==	O
'"'	O
)	O
expressionP	pointer
->	O
X_op	enum
=	O
O_bit_not	int
;	O
else	O
expressionP	pointer
->	O
X_op	enum
=	O
O_logical_not	int
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
}	O
}	O
else	O
as_warn	function
(	O
_	O
(	O
"Unary operator %c ignored because bad operand follows"	pointer
)	O
,	O
c	struct
)	O
;	O
}	O
break	O
;	O
case	O
'$'	O
:	O
if	O
(	O
literal_prefix_dollar_hex	int
)	O
{	O
if	O
(	O
*	O
input_line_pointer	pointer
==	O
'L'	O
)	O
goto	O
isname	O
;	O
integer_constant	function
(	O
16	int
,	O
expressionP	pointer
)	O
;	O
}	O
else	O
{	O
goto	O
isname	O
;	O
}	O
break	O
;	O
case	O
'.'	O
:	O
if	O
(	O
!	O
is_part_of_name	O
(	O
*	O
input_line_pointer	pointer
)	O
)	O
{	O
current_location	function
(	O
expressionP	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
(	O
strncasecmp	function
(	O
input_line_pointer	pointer
,	O
"startof."	pointer
,	O
8	int
)	O
==	O
0	int
&&	O
!	O
is_part_of_name	O
(	O
input_line_pointer	pointer
[	O
8	int
]	O
)	O
)	O
||	O
(	O
strncasecmp	function
(	O
input_line_pointer	pointer
,	O
"sizeof."	pointer
,	O
7	int
)	O
==	O
0	int
&&	O
!	O
is_part_of_name	O
(	O
input_line_pointer	pointer
[	O
7	int
]	O
)	O
)	O
)	O
{	O
int	O
start	pointer
;	O
start	pointer
=	O
(	O
input_line_pointer	pointer
[	O
1	int
]	O
==	O
't'	O
||	O
input_line_pointer	pointer
[	O
1	int
]	O
==	O
'T'	O
)	O
;	O
input_line_pointer	pointer
+=	O
start	pointer
?	O
8	int
:	O
7	int
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
expressionP	pointer
->	O
X_op	enum
=	O
O_absent	int
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
'('	O
)	O
as_bad	function
(	O
_	O
(	O
"syntax error in .startof. or .sizeof."	pointer
)	O
)	O
;	O
else	O
{	O
char	O
*	O
buf	pointer
;	O
++	O
input_line_pointer	pointer
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
c	struct
=	O
get_symbol_name	function
(	O
&	O
name	pointer
)	O
;	O
if	O
(	O
!	O
*	O
name	pointer
)	O
{	O
as_bad	function
(	O
_	O
(	O
"expected symbol name"	pointer
)	O
)	O
;	O
(	O
void	O
)	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
if	O
(	O
c	struct
!=	O
')'	O
)	O
ignore_rest_of_line	function
(	O
)	O
;	O
else	O
++	O
input_line_pointer	pointer
;	O
break	O
;	O
}	O
buf	pointer
=	O
concat	function
(	O
start	pointer
?	O
".startof."	pointer
:	O
".sizeof."	pointer
,	O
name	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
symbolP	pointer
=	O
symbol_make	function
(	O
buf	pointer
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
expressionP	pointer
->	O
X_op	enum
=	O
O_symbol	int
;	O
expressionP	pointer
->	O
X_add_symbol	pointer
=	O
symbolP	pointer
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
*	O
input_line_pointer	pointer
=	O
c	struct
;	O
SKIP_WHITESPACE_AFTER_NAME	O
(	O
)	O
;	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
')'	O
)	O
as_bad	function
(	O
_	O
(	O
"syntax error in .startof. or .sizeof."	pointer
)	O
)	O
;	O
else	O
++	O
input_line_pointer	pointer
;	O
}	O
break	O
;	O
}	O
else	O
{	O
goto	O
isname	O
;	O
}	O
case	O
','	O
:	O
eol	O
:	O
expressionP	pointer
->	O
X_op	enum
=	O
O_absent	int
;	O
input_line_pointer	pointer
--	O
;	O
break	O
;	O
default	O
:	O
de_fault	O
:	O
if	O
(	O
is_name_beginner	O
(	O
c	struct
)	O
||	O
c	struct
==	O
'"'	O
)	O
{	O
isname	O
:	O
--	O
input_line_pointer	pointer
;	O
c	struct
=	O
get_symbol_name	function
(	O
&	O
name	pointer
)	O
;	O
{	O
operatorT	enum
op	enum
=	O
md_operator	O
(	O
name	pointer
,	O
1	int
,	O
&	O
c	struct
)	O
;	O
switch	O
(	O
op	enum
)	O
{	O
case	O
O_uminus	int
:	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
c	struct
=	O
'-'	O
;	O
goto	O
unary	O
;	O
case	O
O_bit_not	int
:	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
c	struct
=	O
'~'	O
;	O
goto	O
unary	O
;	O
case	O
O_logical_not	int
:	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
c	struct
=	O
'!'	O
;	O
goto	O
unary	O
;	O
case	O
O_illegal	int
:	O
as_bad	function
(	O
_	O
(	O
"invalid use of operator \"%s\""	pointer
)	O
,	O
name	pointer
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
if	O
(	O
op	enum
!=	O
O_absent	int
&&	O
op	enum
!=	O
O_illegal	int
)	O
{	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
expr	function
(	O
9	int
,	O
expressionP	pointer
,	O
mode	pointer
)	O
;	O
expressionP	pointer
->	O
X_add_symbol	pointer
=	O
make_expr_symbol	function
(	O
expressionP	pointer
)	O
;	O
expressionP	pointer
->	O
X_op_symbol	pointer
=	O
NULL	O
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
expressionP	pointer
->	O
X_op	enum
=	O
op	enum
;	O
break	O
;	O
}	O
}	O
if	O
(	O
md_parse_name	O
(	O
name	pointer
,	O
expressionP	pointer
,	O
mode	pointer
,	O
&	O
c	struct
)	O
)	O
{	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
break	O
;	O
}	O
symbolP	pointer
=	O
symbol_find_or_make	function
(	O
name	pointer
)	O
;	O
segment	pointer
=	O
S_GET_SEGMENT	function
(	O
symbolP	pointer
)	O
;	O
if	O
(	O
mode	pointer
!=	O
expr_defer	int
&&	O
segment	pointer
==	O
absolute_section	O
&&	O
!	O
S_FORCE_RELOC	function
(	O
symbolP	pointer
,	O
0	int
)	O
)	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
S_GET_VALUE	function
(	O
symbolP	pointer
)	O
;	O
}	O
else	O
if	O
(	O
mode	pointer
!=	O
expr_defer	int
&&	O
segment	pointer
==	O
reg_section	pointer
)	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_register	int
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
S_GET_VALUE	function
(	O
symbolP	pointer
)	O
;	O
}	O
else	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_symbol	int
;	O
expressionP	pointer
->	O
X_add_symbol	pointer
=	O
symbolP	pointer
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
}	O
restore_line_pointer	function
(	O
c	struct
)	O
;	O
}	O
else	O
{	O
expressionP	pointer
->	O
X_op	enum
=	O
O_absent	int
;	O
--	O
input_line_pointer	pointer
;	O
md_operand	function
(	O
expressionP	pointer
)	O
;	O
if	O
(	O
expressionP	pointer
->	O
X_op	enum
==	O
O_absent	int
)	O
{	O
++	O
input_line_pointer	pointer
;	O
as_bad	function
(	O
_	O
(	O
"bad expression"	pointer
)	O
)	O
;	O
expressionP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
}	O
}	O
break	O
;	O
}	O
clean_up_expression	function
(	O
expressionP	pointer
)	O
;	O
SKIP_ALL_WHITESPACE	O
(	O
)	O
;	O
know	O
(	O
*	O
input_line_pointer	pointer
!=	O
' '	O
)	O
;	O
if	O
(	O
expressionP	pointer
->	O
X_add_symbol	pointer
)	O
symbol_mark_used	function
(	O
expressionP	pointer
->	O
X_add_symbol	pointer
)	O
;	O
if	O
(	O
mode	pointer
!=	O
expr_defer	int
)	O
{	O
expressionP	pointer
->	O
X_add_symbol	pointer
=	O
symbol_clone_if_forward_ref	function
(	O
expressionP	pointer
->	O
X_add_symbol	pointer
)	O
;	O
expressionP	pointer
->	O
X_op_symbol	pointer
=	O
symbol_clone_if_forward_ref	function
(	O
expressionP	pointer
->	O
X_op_symbol	pointer
)	O
;	O
}	O
switch	O
(	O
expressionP	pointer
->	O
X_op	enum
)	O
{	O
default	O
:	O
return	O
absolute_section	O
;	O
case	O
O_symbol	int
:	O
return	O
S_GET_SEGMENT	function
(	O
expressionP	pointer
->	O
X_add_symbol	pointer
)	O
;	O
case	O
O_register	int
:	O
return	O
reg_section	pointer
;	O
}	O
}	O
static	O
void	O
clean_up_expression	function
(	O
expressionS	struct
*	O
expressionP	pointer
)	O
{	O
switch	O
(	O
expressionP	pointer
->	O
X_op	enum
)	O
{	O
case	O
O_illegal	int
:	O
case	O
O_absent	int
:	O
expressionP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
case	O
O_big	int
:	O
case	O
O_constant	int
:	O
case	O
O_register	int
:	O
expressionP	pointer
->	O
X_add_symbol	pointer
=	O
NULL	O
;	O
case	O
O_symbol	int
:	O
case	O
O_uminus	int
:	O
case	O
O_bit_not	int
:	O
expressionP	pointer
->	O
X_op_symbol	pointer
=	O
NULL	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
static	O
const	O
operatorT	enum
op_encoding	array
[	O
256	int
]	O
=	O
{	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_bit_or_not	int
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_modulus	int
,	O
O_bit_and	int
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_multiply	int
,	O
O_add	int
,	O
__	O
,	O
O_subtract	int
,	O
__	O
,	O
O_divide	int
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_lt	int
,	O
O_SINGLE_EQ	O
,	O
O_gt	int
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_bit_exclusive_or	int
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
O_bit_inclusive_or	int
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
,	O
__	O
}	O
;	O
static	O
operator_rankT	char
op_rank	array
[	O
O_max	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
9	int
,	O
9	int
,	O
9	int
,	O
8	int
,	O
8	int
,	O
8	int
,	O
8	int
,	O
8	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
7	int
,	O
5	int
,	O
5	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
4	int
,	O
3	int
,	O
2	int
,	O
1	int
,	O
}	O
;	O
void	O
expr_set_precedence	function
(	O
void	O
)	O
{	O
if	O
(	O
flag_m68k_mri	int
)	O
{	O
op_rank	array
[	O
O_multiply	int
]	O
=	O
MRI_MUL_PRECEDENCE	int
;	O
op_rank	array
[	O
O_divide	int
]	O
=	O
MRI_MUL_PRECEDENCE	int
;	O
op_rank	array
[	O
O_modulus	int
]	O
=	O
MRI_MUL_PRECEDENCE	int
;	O
}	O
else	O
{	O
op_rank	array
[	O
O_multiply	int
]	O
=	O
STANDARD_MUL_PRECEDENCE	int
;	O
op_rank	array
[	O
O_divide	int
]	O
=	O
STANDARD_MUL_PRECEDENCE	int
;	O
op_rank	array
[	O
O_modulus	int
]	O
=	O
STANDARD_MUL_PRECEDENCE	int
;	O
}	O
}	O
void	O
expr_set_rank	function
(	O
operatorT	enum
op	enum
,	O
operator_rankT	char
rank	char
)	O
{	O
gas_assert	O
(	O
op	enum
>=	O
O_md1	int
&&	O
op	enum
<	O
ARRAY_SIZE	O
(	O
op_rank	array
)	O
)	O
;	O
op_rank	array
[	O
op	enum
]	O
=	O
rank	char
;	O
}	O
void	O
expr_begin	function
(	O
void	O
)	O
{	O
expr_set_precedence	function
(	O
)	O
;	O
{	O
expressionS	struct
e	struct
;	O
e	struct
.	O
X_op	enum
=	O
O_max	int
;	O
gas_assert	O
(	O
e	struct
.	O
X_op	enum
==	O
O_max	int
)	O
;	O
}	O
}	O
static	O
inline	O
operatorT	enum
operatorf	function
(	O
int	O
*	O
num_chars	pointer
)	O
{	O
int	O
c	struct
;	O
operatorT	enum
ret	pointer
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
&	O
0xff	int
;	O
*	O
num_chars	pointer
=	O
1	int
;	O
if	O
(	O
is_end_of_line	array
[	O
c	struct
]	O
)	O
return	O
O_illegal	int
;	O
if	O
(	O
is_name_beginner	O
(	O
c	struct
)	O
)	O
{	O
char	O
*	O
name	pointer
;	O
char	O
ec	char
=	O
get_symbol_name	function
(	O
&	O
name	pointer
)	O
;	O
ret	pointer
=	O
md_operator	O
(	O
name	pointer
,	O
2	int
,	O
&	O
ec	char
)	O
;	O
switch	O
(	O
ret	pointer
)	O
{	O
case	O
O_absent	int
:	O
*	O
input_line_pointer	pointer
=	O
ec	char
;	O
input_line_pointer	pointer
=	O
name	pointer
;	O
break	O
;	O
case	O
O_uminus	int
:	O
case	O
O_bit_not	int
:	O
case	O
O_logical_not	int
:	O
as_bad	function
(	O
_	O
(	O
"invalid use of operator \"%s\""	pointer
)	O
,	O
name	pointer
)	O
;	O
ret	pointer
=	O
O_illegal	int
;	O
default	O
:	O
*	O
input_line_pointer	pointer
=	O
ec	char
;	O
*	O
num_chars	pointer
=	O
input_line_pointer	pointer
-	O
name	pointer
;	O
input_line_pointer	pointer
=	O
name	pointer
;	O
return	O
ret	pointer
;	O
}	O
}	O
switch	O
(	O
c	struct
)	O
{	O
default	O
:	O
ret	pointer
=	O
op_encoding	array
[	O
c	struct
]	O
;	O
if	O
(	O
ret	pointer
==	O
O_illegal	int
)	O
{	O
char	O
*	O
start	pointer
=	O
input_line_pointer	pointer
;	O
ret	pointer
=	O
md_operator	O
(	O
NULL	O
,	O
2	int
,	O
NULL	O
)	O
;	O
if	O
(	O
ret	pointer
!=	O
O_illegal	int
)	O
*	O
num_chars	pointer
=	O
input_line_pointer	pointer
-	O
start	pointer
;	O
input_line_pointer	pointer
=	O
start	pointer
;	O
}	O
return	O
ret	pointer
;	O
case	O
'+'	O
:	O
case	O
'-'	O
:	O
return	O
op_encoding	array
[	O
c	struct
]	O
;	O
case	O
'<'	O
:	O
switch	O
(	O
input_line_pointer	pointer
[	O
1	int
]	O
)	O
{	O
default	O
:	O
return	O
op_encoding	array
[	O
c	struct
]	O
;	O
case	O
'<'	O
:	O
ret	pointer
=	O
O_left_shift	int
;	O
break	O
;	O
case	O
'>'	O
:	O
ret	pointer
=	O
O_ne	int
;	O
break	O
;	O
case	O
'='	O
:	O
ret	pointer
=	O
O_le	int
;	O
break	O
;	O
}	O
*	O
num_chars	pointer
=	O
2	int
;	O
return	O
ret	pointer
;	O
case	O
'='	O
:	O
if	O
(	O
input_line_pointer	pointer
[	O
1	int
]	O
!=	O
'='	O
)	O
return	O
op_encoding	array
[	O
c	struct
]	O
;	O
*	O
num_chars	pointer
=	O
2	int
;	O
return	O
O_eq	int
;	O
case	O
'>'	O
:	O
switch	O
(	O
input_line_pointer	pointer
[	O
1	int
]	O
)	O
{	O
default	O
:	O
return	O
op_encoding	array
[	O
c	struct
]	O
;	O
case	O
'>'	O
:	O
ret	pointer
=	O
O_right_shift	int
;	O
break	O
;	O
case	O
'='	O
:	O
ret	pointer
=	O
O_ge	int
;	O
break	O
;	O
}	O
*	O
num_chars	pointer
=	O
2	int
;	O
return	O
ret	pointer
;	O
case	O
'!'	O
:	O
switch	O
(	O
input_line_pointer	pointer
[	O
1	int
]	O
)	O
{	O
case	O
'!'	O
:	O
*	O
num_chars	pointer
=	O
2	int
;	O
return	O
O_bit_exclusive_or	int
;	O
case	O
'='	O
:	O
*	O
num_chars	pointer
=	O
2	int
;	O
return	O
O_ne	int
;	O
default	O
:	O
if	O
(	O
flag_m68k_mri	int
)	O
return	O
O_bit_inclusive_or	int
;	O
return	O
op_encoding	array
[	O
c	struct
]	O
;	O
}	O
case	O
'|'	O
:	O
if	O
(	O
input_line_pointer	pointer
[	O
1	int
]	O
!=	O
'|'	O
)	O
return	O
op_encoding	array
[	O
c	struct
]	O
;	O
*	O
num_chars	pointer
=	O
2	int
;	O
return	O
O_logical_or	int
;	O
case	O
'&'	O
:	O
if	O
(	O
input_line_pointer	pointer
[	O
1	int
]	O
!=	O
'&'	O
)	O
return	O
op_encoding	array
[	O
c	struct
]	O
;	O
*	O
num_chars	pointer
=	O
2	int
;	O
return	O
O_logical_and	int
;	O
}	O
}	O
void	O
add_to_result	function
(	O
expressionS	struct
*	O
resultP	pointer
,	O
offsetT	long
amount	long
,	O
int	O
rhs_highbit	int
)	O
{	O
valueT	long
ures	long
=	O
resultP	pointer
->	O
X_add_number	long
;	O
valueT	long
uamount	long
=	O
amount	long
;	O
resultP	pointer
->	O
X_add_number	long
+=	O
amount	long
;	O
resultP	pointer
->	O
X_extrabit	int
^=	O
rhs_highbit	int
;	O
if	O
(	O
ures	long
+	O
uamount	long
<	O
ures	long
)	O
resultP	pointer
->	O
X_extrabit	int
^=	O
1	int
;	O
}	O
void	O
subtract_from_result	function
(	O
expressionS	struct
*	O
resultP	pointer
,	O
offsetT	long
amount	long
,	O
int	O
rhs_highbit	int
)	O
{	O
valueT	long
ures	long
=	O
resultP	pointer
->	O
X_add_number	long
;	O
valueT	long
uamount	long
=	O
amount	long
;	O
resultP	pointer
->	O
X_add_number	long
-=	O
amount	long
;	O
resultP	pointer
->	O
X_extrabit	int
^=	O
rhs_highbit	int
;	O
if	O
(	O
ures	long
<	O
uamount	long
)	O
resultP	pointer
->	O
X_extrabit	int
^=	O
1	int
;	O
}	O
segT	pointer
expr	function
(	O
int	O
rankarg	int
,	O
expressionS	struct
*	O
resultP	pointer
,	O
enum	O
expr_mode	enum
mode	pointer
)	O
{	O
operator_rankT	char
rank	char
=	O
(	O
operator_rankT	char
)	O
rankarg	int
;	O
segT	pointer
retval	pointer
;	O
expressionS	struct
right	struct
;	O
operatorT	enum
op_left	enum
;	O
operatorT	enum
op_right	enum
;	O
int	O
op_chars	int
;	O
know	O
(	O
rankarg	int
>=	O
0	int
)	O
;	O
if	O
(	O
rank	char
==	O
0	int
)	O
{	O
dot_value	long
=	O
frag_now_fix	function
(	O
)	O
;	O
dot_frag	pointer
=	O
frag_now	pointer
;	O
}	O
retval	pointer
=	O
operand	function
(	O
resultP	pointer
,	O
mode	pointer
)	O
;	O
know	O
(	O
*	O
input_line_pointer	pointer
!=	O
' '	O
)	O
;	O
op_left	enum
=	O
operatorf	function
(	O
&	O
op_chars	int
)	O
;	O
while	O
(	O
op_left	enum
!=	O
O_illegal	int
&&	O
op_rank	array
[	O
(	O
int	O
)	O
op_left	enum
]	O
>	O
rank	char
)	O
{	O
segT	pointer
rightseg	pointer
;	O
offsetT	long
frag_off	long
;	O
input_line_pointer	pointer
+=	O
op_chars	int
;	O
right	struct
.	O
X_md	short
=	O
0	int
;	O
rightseg	pointer
=	O
expr	function
(	O
op_rank	array
[	O
(	O
int	O
)	O
op_left	enum
]	O
,	O
&	O
right	struct
,	O
mode	pointer
)	O
;	O
if	O
(	O
right	struct
.	O
X_op	enum
==	O
O_absent	int
)	O
{	O
as_warn	function
(	O
_	O
(	O
"missing operand; zero assumed"	pointer
)	O
)	O
;	O
right	struct
.	O
X_op	enum
=	O
O_constant	int
;	O
right	struct
.	O
X_add_number	long
=	O
0	int
;	O
right	struct
.	O
X_add_symbol	pointer
=	O
NULL	O
;	O
right	struct
.	O
X_op_symbol	pointer
=	O
NULL	O
;	O
}	O
know	O
(	O
*	O
input_line_pointer	pointer
!=	O
' '	O
)	O
;	O
if	O
(	O
op_left	enum
==	O
O_index	int
)	O
{	O
if	O
(	O
*	O
input_line_pointer	pointer
!=	O
']'	O
)	O
as_bad	function
(	O
"missing right bracket"	pointer
)	O
;	O
else	O
{	O
++	O
input_line_pointer	pointer
;	O
SKIP_WHITESPACE	O
(	O
)	O
;	O
}	O
}	O
op_right	enum
=	O
operatorf	function
(	O
&	O
op_chars	int
)	O
;	O
know	O
(	O
op_right	enum
==	O
O_illegal	int
||	O
op_left	enum
==	O
O_index	int
||	O
op_rank	array
[	O
(	O
int	O
)	O
op_right	enum
]	O
<=	O
op_rank	array
[	O
(	O
int	O
)	O
op_left	enum
]	O
)	O
;	O
know	O
(	O
(	O
int	O
)	O
op_left	enum
>=	O
(	O
int	O
)	O
O_multiply	int
)	O
;	O
know	O
(	O
(	O
int	O
)	O
op_left	enum
<	O
(	O
int	O
)	O
O_max	int
)	O
;	O
if	O
(	O
resultP	pointer
->	O
X_op	enum
==	O
O_big	int
)	O
{	O
if	O
(	O
resultP	pointer
->	O
X_add_number	long
>	O
0	int
)	O
as_warn	function
(	O
_	O
(	O
"left operand is a bignum; integer 0 assumed"	pointer
)	O
)	O
;	O
else	O
as_warn	function
(	O
_	O
(	O
"left operand is a float; integer 0 assumed"	pointer
)	O
)	O
;	O
resultP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
resultP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
resultP	pointer
->	O
X_add_symbol	pointer
=	O
NULL	O
;	O
resultP	pointer
->	O
X_op_symbol	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
right	struct
.	O
X_op	enum
==	O
O_big	int
)	O
{	O
if	O
(	O
right	struct
.	O
X_add_number	long
>	O
0	int
)	O
as_warn	function
(	O
_	O
(	O
"right operand is a bignum; integer 0 assumed"	pointer
)	O
)	O
;	O
else	O
as_warn	function
(	O
_	O
(	O
"right operand is a float; integer 0 assumed"	pointer
)	O
)	O
;	O
right	struct
.	O
X_op	enum
=	O
O_constant	int
;	O
right	struct
.	O
X_add_number	long
=	O
0	int
;	O
right	struct
.	O
X_add_symbol	pointer
=	O
NULL	O
;	O
right	struct
.	O
X_op_symbol	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
mode	pointer
==	O
expr_defer	int
&&	O
(	O
(	O
resultP	pointer
->	O
X_add_symbol	pointer
!=	O
NULL	O
&&	O
S_IS_FORWARD_REF	function
(	O
resultP	pointer
->	O
X_add_symbol	pointer
)	O
)	O
||	O
(	O
right	struct
.	O
X_add_symbol	pointer
!=	O
NULL	O
&&	O
S_IS_FORWARD_REF	function
(	O
right	struct
.	O
X_add_symbol	pointer
)	O
)	O
)	O
)	O
goto	O
general	O
;	O
if	O
(	O
op_left	enum
==	O
O_add	int
&&	O
right	struct
.	O
X_op	enum
==	O
O_constant	int
&&	O
(	O
md_register_arithmetic	int
||	O
resultP	pointer
->	O
X_op	enum
!=	O
O_register	int
)	O
)	O
{	O
add_to_result	function
(	O
resultP	pointer
,	O
right	struct
.	O
X_add_number	long
,	O
right	struct
.	O
X_extrabit	int
)	O
;	O
}	O
else	O
if	O
(	O
op_left	enum
==	O
O_subtract	int
&&	O
right	struct
.	O
X_op	enum
==	O
O_symbol	int
&&	O
resultP	pointer
->	O
X_op	enum
==	O
O_symbol	int
&&	O
retval	pointer
==	O
rightseg	pointer
&&	O
(	O
(	O
SEG_NORMAL	O
(	O
rightseg	pointer
)	O
&&	O
!	O
S_FORCE_RELOC	function
(	O
resultP	pointer
->	O
X_add_symbol	pointer
,	O
0	int
)	O
&&	O
!	O
S_FORCE_RELOC	function
(	O
right	struct
.	O
X_add_symbol	pointer
,	O
0	int
)	O
)	O
||	O
right	struct
.	O
X_add_symbol	pointer
==	O
resultP	pointer
->	O
X_add_symbol	pointer
)	O
&&	O
frag_offset_fixed_p	function
(	O
symbol_get_frag	function
(	O
resultP	pointer
->	O
X_add_symbol	pointer
)	O
,	O
symbol_get_frag	function
(	O
right	struct
.	O
X_add_symbol	pointer
)	O
,	O
&	O
frag_off	long
)	O
)	O
{	O
offsetT	long
symval_diff	long
=	O
S_GET_VALUE	function
(	O
resultP	pointer
->	O
X_add_symbol	pointer
)	O
-	O
S_GET_VALUE	function
(	O
right	struct
.	O
X_add_symbol	pointer
)	O
;	O
subtract_from_result	function
(	O
resultP	pointer
,	O
right	struct
.	O
X_add_number	long
,	O
right	struct
.	O
X_extrabit	int
)	O
;	O
subtract_from_result	function
(	O
resultP	pointer
,	O
frag_off	long
/	O
OCTETS_PER_BYTE	O
,	O
0	int
)	O
;	O
add_to_result	function
(	O
resultP	pointer
,	O
symval_diff	long
,	O
symval_diff	long
<	O
0	int
)	O
;	O
resultP	pointer
->	O
X_op	enum
=	O
O_constant	int
;	O
resultP	pointer
->	O
X_add_symbol	pointer
=	O
0	int
;	O
}	O
else	O
if	O
(	O
op_left	enum
==	O
O_subtract	int
&&	O
right	struct
.	O
X_op	enum
==	O
O_constant	int
&&	O
(	O
md_register_arithmetic	int
||	O
resultP	pointer
->	O
X_op	enum
!=	O
O_register	int
)	O
)	O
{	O
subtract_from_result	function
(	O
resultP	pointer
,	O
right	struct
.	O
X_add_number	long
,	O
right	struct
.	O
X_extrabit	int
)	O
;	O
}	O
else	O
if	O
(	O
op_left	enum
==	O
O_add	int
&&	O
resultP	pointer
->	O
X_op	enum
==	O
O_constant	int
&&	O
(	O
md_register_arithmetic	int
||	O
right	struct
.	O
X_op	enum
!=	O
O_register	int
)	O
)	O
{	O
resultP	pointer
->	O
X_op	enum
=	O
right	struct
.	O
X_op	enum
;	O
resultP	pointer
->	O
X_add_symbol	pointer
=	O
right	struct
.	O
X_add_symbol	pointer
;	O
resultP	pointer
->	O
X_op_symbol	pointer
=	O
right	struct
.	O
X_op_symbol	pointer
;	O
add_to_result	function
(	O
resultP	pointer
,	O
right	struct
.	O
X_add_number	long
,	O
right	struct
.	O
X_extrabit	int
)	O
;	O
retval	pointer
=	O
rightseg	pointer
;	O
}	O
else	O
if	O
(	O
resultP	pointer
->	O
X_op	enum
==	O
O_constant	int
&&	O
right	struct
.	O
X_op	enum
==	O
O_constant	int
)	O
{	O
offsetT	long
v	long
=	O
right	struct
.	O
X_add_number	long
;	O
if	O
(	O
v	long
==	O
0	int
&&	O
(	O
op_left	enum
==	O
O_divide	int
||	O
op_left	enum
==	O
O_modulus	int
)	O
)	O
{	O
as_warn	function
(	O
_	O
(	O
"division by zero"	pointer
)	O
)	O
;	O
v	long
=	O
1	int
;	O
}	O
if	O
(	O
(	O
valueT	long
)	O
v	long
>=	O
sizeof	O
(	O
valueT	long
)	O
*	O
CHAR_BIT	O
&&	O
(	O
op_left	enum
==	O
O_left_shift	int
||	O
op_left	enum
==	O
O_right_shift	int
)	O
)	O
{	O
as_warn_value_out_of_range	function
(	O
_	O
(	O
"shift count"	pointer
)	O
,	O
v	long
,	O
0	int
,	O
sizeof	O
(	O
valueT	long
)	O
*	O
CHAR_BIT	O
-	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
resultP	pointer
->	O
X_add_number	long
=	O
v	long
=	O
0	int
;	O
}	O
switch	O
(	O
op_left	enum
)	O
{	O
default	O
:	O
goto	O
general	O
;	O
case	O
O_multiply	int
:	O
resultP	pointer
->	O
X_add_number	long
*=	O
v	long
;	O
break	O
;	O
case	O
O_divide	int
:	O
resultP	pointer
->	O
X_add_number	long
/=	O
v	long
;	O
break	O
;	O
case	O
O_modulus	int
:	O
resultP	pointer
->	O
X_add_number	long
%=	O
v	long
;	O
break	O
;	O
case	O
O_left_shift	int
:	O
resultP	pointer
->	O
X_add_number	long
<<=	O
v	long
;	O
break	O
;	O
case	O
O_right_shift	int
:	O
resultP	pointer
->	O
X_add_number	long
=	O
(	O
offsetT	long
)	O
(	O
(	O
valueT	long
)	O
resultP	pointer
->	O
X_add_number	long
>>	O
(	O
valueT	long
)	O
v	long
)	O
;	O
break	O
;	O
case	O
O_bit_inclusive_or	int
:	O
resultP	pointer
->	O
X_add_number	long
|=	O
v	long
;	O
break	O
;	O
case	O
O_bit_or_not	int
:	O
resultP	pointer
->	O
X_add_number	long
|=	O
~	O
v	long
;	O
break	O
;	O
case	O
O_bit_exclusive_or	int
:	O
resultP	pointer
->	O
X_add_number	long
^=	O
v	long
;	O
break	O
;	O
case	O
O_bit_and	int
:	O
resultP	pointer
->	O
X_add_number	long
&=	O
v	long
;	O
break	O
;	O
case	O
O_subtract	int
:	O
subtract_from_result	function
(	O
resultP	pointer
,	O
v	long
,	O
0	int
)	O
;	O
break	O
;	O
case	O
O_eq	int
:	O
resultP	pointer
->	O
X_add_number	long
=	O
resultP	pointer
->	O
X_add_number	long
==	O
v	long
?	O
~	O
(	O
offsetT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_ne	int
:	O
resultP	pointer
->	O
X_add_number	long
=	O
resultP	pointer
->	O
X_add_number	long
!=	O
v	long
?	O
~	O
(	O
offsetT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_lt	int
:	O
resultP	pointer
->	O
X_add_number	long
=	O
resultP	pointer
->	O
X_add_number	long
<	O
v	long
?	O
~	O
(	O
offsetT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_le	int
:	O
resultP	pointer
->	O
X_add_number	long
=	O
resultP	pointer
->	O
X_add_number	long
<=	O
v	long
?	O
~	O
(	O
offsetT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_ge	int
:	O
resultP	pointer
->	O
X_add_number	long
=	O
resultP	pointer
->	O
X_add_number	long
>=	O
v	long
?	O
~	O
(	O
offsetT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_gt	int
:	O
resultP	pointer
->	O
X_add_number	long
=	O
resultP	pointer
->	O
X_add_number	long
>	O
v	long
?	O
~	O
(	O
offsetT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_logical_and	int
:	O
resultP	pointer
->	O
X_add_number	long
=	O
resultP	pointer
->	O
X_add_number	long
&&	O
v	long
;	O
break	O
;	O
case	O
O_logical_or	int
:	O
resultP	pointer
->	O
X_add_number	long
=	O
resultP	pointer
->	O
X_add_number	long
||	O
v	long
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
resultP	pointer
->	O
X_op	enum
==	O
O_symbol	int
&&	O
right	struct
.	O
X_op	enum
==	O
O_symbol	int
&&	O
(	O
op_left	enum
==	O
O_add	int
||	O
op_left	enum
==	O
O_subtract	int
||	O
(	O
resultP	pointer
->	O
X_add_number	long
==	O
0	int
&&	O
right	struct
.	O
X_add_number	long
==	O
0	int
)	O
)	O
)	O
{	O
resultP	pointer
->	O
X_op	enum
=	O
op_left	enum
;	O
resultP	pointer
->	O
X_op_symbol	pointer
=	O
right	struct
.	O
X_add_symbol	pointer
;	O
if	O
(	O
op_left	enum
==	O
O_add	int
)	O
add_to_result	function
(	O
resultP	pointer
,	O
right	struct
.	O
X_add_number	long
,	O
right	struct
.	O
X_extrabit	int
)	O
;	O
else	O
if	O
(	O
op_left	enum
==	O
O_subtract	int
)	O
{	O
subtract_from_result	function
(	O
resultP	pointer
,	O
right	struct
.	O
X_add_number	long
,	O
right	struct
.	O
X_extrabit	int
)	O
;	O
if	O
(	O
retval	pointer
==	O
rightseg	pointer
&&	O
SEG_NORMAL	O
(	O
retval	pointer
)	O
&&	O
!	O
S_FORCE_RELOC	function
(	O
resultP	pointer
->	O
X_add_symbol	pointer
,	O
0	int
)	O
&&	O
!	O
S_FORCE_RELOC	function
(	O
right	struct
.	O
X_add_symbol	pointer
,	O
0	int
)	O
)	O
{	O
retval	pointer
=	O
absolute_section	O
;	O
rightseg	pointer
=	O
absolute_section	O
;	O
}	O
}	O
}	O
else	O
{	O
general	O
:	O
resultP	pointer
->	O
X_add_symbol	pointer
=	O
make_expr_symbol	function
(	O
resultP	pointer
)	O
;	O
resultP	pointer
->	O
X_op_symbol	pointer
=	O
make_expr_symbol	function
(	O
&	O
right	struct
)	O
;	O
resultP	pointer
->	O
X_op	enum
=	O
op_left	enum
;	O
resultP	pointer
->	O
X_add_number	long
=	O
0	int
;	O
resultP	pointer
->	O
X_unsigned	int
=	O
1	int
;	O
resultP	pointer
->	O
X_extrabit	int
=	O
0	int
;	O
}	O
if	O
(	O
retval	pointer
!=	O
rightseg	pointer
)	O
{	O
if	O
(	O
retval	pointer
==	O
undefined_section	O
)	O
;	O
else	O
if	O
(	O
rightseg	pointer
==	O
undefined_section	O
)	O
retval	pointer
=	O
rightseg	pointer
;	O
else	O
if	O
(	O
retval	pointer
==	O
expr_section	pointer
)	O
;	O
else	O
if	O
(	O
rightseg	pointer
==	O
expr_section	pointer
)	O
retval	pointer
=	O
rightseg	pointer
;	O
else	O
if	O
(	O
retval	pointer
==	O
reg_section	pointer
)	O
;	O
else	O
if	O
(	O
rightseg	pointer
==	O
reg_section	pointer
)	O
retval	pointer
=	O
rightseg	pointer
;	O
else	O
if	O
(	O
rightseg	pointer
==	O
absolute_section	O
)	O
;	O
else	O
if	O
(	O
retval	pointer
==	O
absolute_section	O
)	O
retval	pointer
=	O
rightseg	pointer
;	O
else	O
if	O
(	O
op_left	enum
==	O
O_subtract	int
)	O
;	O
else	O
as_bad	function
(	O
_	O
(	O
"operation combines symbols in different segments"	pointer
)	O
)	O
;	O
}	O
op_left	enum
=	O
op_right	enum
;	O
}	O
if	O
(	O
resultP	pointer
->	O
X_add_symbol	pointer
)	O
symbol_mark_used	function
(	O
resultP	pointer
->	O
X_add_symbol	pointer
)	O
;	O
if	O
(	O
rank	char
==	O
0	int
&&	O
mode	pointer
==	O
expr_evaluate	int
)	O
resolve_expression	function
(	O
resultP	pointer
)	O
;	O
return	O
resultP	pointer
->	O
X_op	enum
==	O
O_constant	int
?	O
absolute_section	O
:	O
retval	pointer
;	O
}	O
int	O
resolve_expression	function
(	O
expressionS	struct
*	O
expressionP	pointer
)	O
{	O
valueT	long
final_val	long
=	O
expressionP	pointer
->	O
X_add_number	long
;	O
symbolS	struct
*	O
add_symbol	pointer
=	O
expressionP	pointer
->	O
X_add_symbol	pointer
;	O
symbolS	struct
*	O
orig_add_symbol	pointer
=	O
add_symbol	pointer
;	O
symbolS	struct
*	O
op_symbol	pointer
=	O
expressionP	pointer
->	O
X_op_symbol	pointer
;	O
operatorT	enum
op	enum
=	O
expressionP	pointer
->	O
X_op	enum
;	O
valueT	long
left	long
,	O
right	struct
;	O
segT	pointer
seg_left	pointer
,	O
seg_right	pointer
;	O
fragS	struct
*	O
frag_left	pointer
,	O
*	O
frag_right	pointer
;	O
offsetT	long
frag_off	long
;	O
switch	O
(	O
op	enum
)	O
{	O
default	O
:	O
return	O
0	int
;	O
case	O
O_constant	int
:	O
case	O
O_register	int
:	O
left	long
=	O
0	int
;	O
break	O
;	O
case	O
O_symbol	int
:	O
case	O
O_symbol_rva	int
:	O
if	O
(	O
!	O
snapshot_symbol	function
(	O
&	O
add_symbol	pointer
,	O
&	O
left	long
,	O
&	O
seg_left	pointer
,	O
&	O
frag_left	pointer
)	O
)	O
return	O
0	int
;	O
break	O
;	O
case	O
O_uminus	int
:	O
case	O
O_bit_not	int
:	O
case	O
O_logical_not	int
:	O
if	O
(	O
!	O
snapshot_symbol	function
(	O
&	O
add_symbol	pointer
,	O
&	O
left	long
,	O
&	O
seg_left	pointer
,	O
&	O
frag_left	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
seg_left	pointer
!=	O
absolute_section	O
)	O
return	O
0	int
;	O
if	O
(	O
op	enum
==	O
O_logical_not	int
)	O
left	long
=	O
!	O
left	long
;	O
else	O
if	O
(	O
op	enum
==	O
O_uminus	int
)	O
left	long
=	O
-	O
left	long
;	O
else	O
left	long
=	O
~	O
left	long
;	O
op	enum
=	O
O_constant	int
;	O
break	O
;	O
case	O
O_multiply	int
:	O
case	O
O_divide	int
:	O
case	O
O_modulus	int
:	O
case	O
O_left_shift	int
:	O
case	O
O_right_shift	int
:	O
case	O
O_bit_inclusive_or	int
:	O
case	O
O_bit_or_not	int
:	O
case	O
O_bit_exclusive_or	int
:	O
case	O
O_bit_and	int
:	O
case	O
O_add	int
:	O
case	O
O_subtract	int
:	O
case	O
O_eq	int
:	O
case	O
O_ne	int
:	O
case	O
O_lt	int
:	O
case	O
O_le	int
:	O
case	O
O_ge	int
:	O
case	O
O_gt	int
:	O
case	O
O_logical_and	int
:	O
case	O
O_logical_or	int
:	O
if	O
(	O
!	O
snapshot_symbol	function
(	O
&	O
add_symbol	pointer
,	O
&	O
left	long
,	O
&	O
seg_left	pointer
,	O
&	O
frag_left	pointer
)	O
||	O
!	O
snapshot_symbol	function
(	O
&	O
op_symbol	pointer
,	O
&	O
right	struct
,	O
&	O
seg_right	pointer
,	O
&	O
frag_right	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
op	enum
==	O
O_add	int
)	O
{	O
if	O
(	O
seg_right	pointer
==	O
absolute_section	O
)	O
{	O
final_val	long
+=	O
right	struct
;	O
op	enum
=	O
O_symbol	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
seg_left	pointer
==	O
absolute_section	O
)	O
{	O
final_val	long
+=	O
left	long
;	O
left	long
=	O
right	struct
;	O
seg_left	pointer
=	O
seg_right	pointer
;	O
add_symbol	pointer
=	O
op_symbol	pointer
;	O
orig_add_symbol	pointer
=	O
expressionP	pointer
->	O
X_op_symbol	pointer
;	O
op	enum
=	O
O_symbol	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
op	enum
==	O
O_subtract	int
)	O
{	O
if	O
(	O
seg_right	pointer
==	O
absolute_section	O
)	O
{	O
final_val	long
-=	O
right	struct
;	O
op	enum
=	O
O_symbol	int
;	O
break	O
;	O
}	O
}	O
frag_off	long
=	O
0	int
;	O
if	O
(	O
!	O
(	O
seg_left	pointer
==	O
absolute_section	O
&&	O
seg_right	pointer
==	O
absolute_section	O
)	O
&&	O
!	O
(	O
op	enum
==	O
O_eq	int
||	O
op	enum
==	O
O_ne	int
)	O
&&	O
!	O
(	O
(	O
op	enum
==	O
O_subtract	int
||	O
op	enum
==	O
O_lt	int
||	O
op	enum
==	O
O_le	int
||	O
op	enum
==	O
O_ge	int
||	O
op	enum
==	O
O_gt	int
)	O
&&	O
seg_left	pointer
==	O
seg_right	pointer
&&	O
(	O
finalize_syms	int
||	O
frag_offset_fixed_p	function
(	O
frag_left	pointer
,	O
frag_right	pointer
,	O
&	O
frag_off	long
)	O
||	O
(	O
op	enum
==	O
O_gt	int
&&	O
frag_gtoffset_p	function
(	O
left	long
,	O
frag_left	pointer
,	O
right	struct
,	O
frag_right	pointer
,	O
&	O
frag_off	long
)	O
)	O
)	O
&&	O
(	O
seg_left	pointer
!=	O
reg_section	pointer
||	O
left	long
==	O
right	struct
)	O
&&	O
(	O
seg_left	pointer
!=	O
undefined_section	O
||	O
add_symbol	pointer
==	O
op_symbol	pointer
)	O
)	O
)	O
{	O
if	O
(	O
(	O
seg_left	pointer
==	O
absolute_section	O
&&	O
left	long
==	O
0	int
)	O
||	O
(	O
seg_right	pointer
==	O
absolute_section	O
&&	O
right	struct
==	O
0	int
)	O
)	O
{	O
if	O
(	O
op	enum
==	O
O_bit_exclusive_or	int
||	O
op	enum
==	O
O_bit_inclusive_or	int
)	O
{	O
if	O
(	O
!	O
(	O
seg_right	pointer
==	O
absolute_section	O
&&	O
right	struct
==	O
0	int
)	O
)	O
{	O
seg_left	pointer
=	O
seg_right	pointer
;	O
left	long
=	O
right	struct
;	O
add_symbol	pointer
=	O
op_symbol	pointer
;	O
orig_add_symbol	pointer
=	O
expressionP	pointer
->	O
X_op_symbol	pointer
;	O
}	O
op	enum
=	O
O_symbol	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
op	enum
==	O
O_left_shift	int
||	O
op	enum
==	O
O_right_shift	int
)	O
{	O
if	O
(	O
!	O
(	O
seg_left	pointer
==	O
absolute_section	O
&&	O
left	long
==	O
0	int
)	O
)	O
{	O
op	enum
=	O
O_symbol	int
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
op	enum
!=	O
O_multiply	int
&&	O
op	enum
!=	O
O_bit_or_not	int
&&	O
op	enum
!=	O
O_bit_and	int
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
op	enum
==	O
O_multiply	int
&&	O
seg_left	pointer
==	O
absolute_section	O
&&	O
left	long
==	O
1	int
)	O
{	O
seg_left	pointer
=	O
seg_right	pointer
;	O
left	long
=	O
right	struct
;	O
add_symbol	pointer
=	O
op_symbol	pointer
;	O
orig_add_symbol	pointer
=	O
expressionP	pointer
->	O
X_op_symbol	pointer
;	O
op	enum
=	O
O_symbol	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
(	O
op	enum
==	O
O_multiply	int
||	O
op	enum
==	O
O_divide	int
)	O
&&	O
seg_right	pointer
==	O
absolute_section	O
&&	O
right	struct
==	O
1	int
)	O
{	O
op	enum
=	O
O_symbol	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
left	long
==	O
right	struct
&&	O
(	O
(	O
seg_left	pointer
==	O
reg_section	pointer
&&	O
seg_right	pointer
==	O
reg_section	pointer
)	O
||	O
(	O
seg_left	pointer
==	O
undefined_section	O
&&	O
seg_right	pointer
==	O
undefined_section	O
&&	O
add_symbol	pointer
==	O
op_symbol	pointer
)	O
)	O
)	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
op	enum
==	O
O_bit_and	int
||	O
op	enum
==	O
O_bit_inclusive_or	int
)	O
{	O
op	enum
=	O
O_symbol	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
op	enum
!=	O
O_bit_exclusive_or	int
&&	O
op	enum
!=	O
O_bit_or_not	int
)	O
return	O
0	int
;	O
}	O
right	struct
+=	O
frag_off	long
/	O
OCTETS_PER_BYTE	O
;	O
switch	O
(	O
op	enum
)	O
{	O
case	O
O_add	int
:	O
left	long
+=	O
right	struct
;	O
break	O
;	O
case	O
O_subtract	int
:	O
left	long
-=	O
right	struct
;	O
break	O
;	O
case	O
O_multiply	int
:	O
left	long
*=	O
right	struct
;	O
break	O
;	O
case	O
O_divide	int
:	O
if	O
(	O
right	struct
==	O
0	int
)	O
return	O
0	int
;	O
left	long
=	O
(	O
offsetT	long
)	O
left	long
/	O
(	O
offsetT	long
)	O
right	struct
;	O
break	O
;	O
case	O
O_modulus	int
:	O
if	O
(	O
right	struct
==	O
0	int
)	O
return	O
0	int
;	O
left	long
=	O
(	O
offsetT	long
)	O
left	long
%	O
(	O
offsetT	long
)	O
right	struct
;	O
break	O
;	O
case	O
O_left_shift	int
:	O
left	long
<<=	O
right	struct
;	O
break	O
;	O
case	O
O_right_shift	int
:	O
left	long
>>=	O
right	struct
;	O
break	O
;	O
case	O
O_bit_inclusive_or	int
:	O
left	long
|=	O
right	struct
;	O
break	O
;	O
case	O
O_bit_or_not	int
:	O
left	long
|=	O
~	O
right	struct
;	O
break	O
;	O
case	O
O_bit_exclusive_or	int
:	O
left	long
^=	O
right	struct
;	O
break	O
;	O
case	O
O_bit_and	int
:	O
left	long
&=	O
right	struct
;	O
break	O
;	O
case	O
O_eq	int
:	O
case	O
O_ne	int
:	O
left	long
=	O
(	O
left	long
==	O
right	struct
&&	O
seg_left	pointer
==	O
seg_right	pointer
&&	O
(	O
finalize_syms	int
||	O
frag_left	pointer
==	O
frag_right	pointer
)	O
&&	O
(	O
seg_left	pointer
!=	O
undefined_section	O
||	O
add_symbol	pointer
==	O
op_symbol	pointer
)	O
?	O
~	O
(	O
valueT	long
)	O
0	int
:	O
0	int
)	O
;	O
if	O
(	O
op	enum
==	O
O_ne	int
)	O
left	long
=	O
~	O
left	long
;	O
break	O
;	O
case	O
O_lt	int
:	O
left	long
=	O
(	O
offsetT	long
)	O
left	long
<	O
(	O
offsetT	long
)	O
right	struct
?	O
~	O
(	O
valueT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_le	int
:	O
left	long
=	O
(	O
offsetT	long
)	O
left	long
<=	O
(	O
offsetT	long
)	O
right	struct
?	O
~	O
(	O
valueT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_ge	int
:	O
left	long
=	O
(	O
offsetT	long
)	O
left	long
>=	O
(	O
offsetT	long
)	O
right	struct
?	O
~	O
(	O
valueT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_gt	int
:	O
left	long
=	O
(	O
offsetT	long
)	O
left	long
>	O
(	O
offsetT	long
)	O
right	struct
?	O
~	O
(	O
valueT	long
)	O
0	int
:	O
0	int
;	O
break	O
;	O
case	O
O_logical_and	int
:	O
left	long
=	O
left	long
&&	O
right	struct
;	O
break	O
;	O
case	O
O_logical_or	int
:	O
left	long
=	O
left	long
||	O
right	struct
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
op	enum
=	O
O_constant	int
;	O
break	O
;	O
}	O
if	O
(	O
op	enum
==	O
O_symbol	int
)	O
{	O
if	O
(	O
seg_left	pointer
==	O
absolute_section	O
)	O
op	enum
=	O
O_constant	int
;	O
else	O
if	O
(	O
seg_left	pointer
==	O
reg_section	pointer
&&	O
final_val	long
==	O
0	int
)	O
op	enum
=	O
O_register	int
;	O
else	O
if	O
(	O
!	O
symbol_same_p	function
(	O
add_symbol	pointer
,	O
orig_add_symbol	pointer
)	O
)	O
final_val	long
+=	O
left	long
;	O
expressionP	pointer
->	O
X_add_symbol	pointer
=	O
add_symbol	pointer
;	O
}	O
expressionP	pointer
->	O
X_op	enum
=	O
op	enum
;	O
if	O
(	O
op	enum
==	O
O_constant	int
||	O
op	enum
==	O
O_register	int
)	O
final_val	long
+=	O
left	long
;	O
expressionP	pointer
->	O
X_add_number	long
=	O
final_val	long
;	O
return	O
1	int
;	O
}	O
char	O
get_symbol_name	function
(	O
char	O
*	O
*	O
ilp_return	pointer
)	O
{	O
char	O
c	struct
;	O
*	O
ilp_return	pointer
=	O
input_line_pointer	pointer
;	O
if	O
(	O
is_name_beginner	O
(	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
)	O
||	O
(	O
input_from_string	int
&&	O
c	struct
==	O
FAKE_LABEL_CHAR	char
)	O
)	O
{	O
while	O
(	O
is_part_of_name	O
(	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
)	O
||	O
(	O
input_from_string	int
&&	O
c	struct
==	O
FAKE_LABEL_CHAR	char
)	O
)	O
;	O
if	O
(	O
is_name_ender	O
(	O
c	struct
)	O
)	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
}	O
else	O
if	O
(	O
c	struct
==	O
'"'	O
)	O
{	O
bfd_boolean	int
backslash_seen	int
;	O
*	O
ilp_return	pointer
=	O
input_line_pointer	pointer
;	O
do	O
{	O
backslash_seen	int
=	O
c	struct
==	O
'\\'	O
;	O
c	struct
=	O
*	O
input_line_pointer	pointer
++	O
;	O
}	O
while	O
(	O
c	struct
!=	O
0	int
&&	O
(	O
c	struct
!=	O
'"'	O
||	O
backslash_seen	int
)	O
)	O
;	O
if	O
(	O
c	struct
==	O
0	int
)	O
as_warn	function
(	O
_	O
(	O
"missing closing '\"'"	pointer
)	O
)	O
;	O
}	O
*	O
--	O
input_line_pointer	pointer
=	O
0	int
;	O
return	O
c	struct
;	O
}	O
char	O
restore_line_pointer	function
(	O
char	O
c	struct
)	O
{	O
*	O
input_line_pointer	pointer
=	O
c	struct
;	O
if	O
(	O
c	struct
==	O
'"'	O
)	O
c	struct
=	O
*	O
++	O
input_line_pointer	pointer
;	O
return	O
c	struct
;	O
}	O
unsigned	O
int	O
get_single_number	function
(	O
void	O
)	O
{	O
expressionS	struct
exp	pointer
;	O
operand	function
(	O
&	O
exp	pointer
,	O
expr_normal	int
)	O
;	O
return	O
exp	pointer
.	O
X_add_number	long
;	O
}	O
