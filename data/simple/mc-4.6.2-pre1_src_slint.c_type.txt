static	O
struct	O
termios	struct
boot_mode	struct
;	O
static	O
struct	O
termios	struct
new_mode	struct
;	O
static	O
int	O
no_slang_delay	int
;	O
static	O
void	O
load_terminfo_keys	function
(	O
void	O
)	O
;	O
void	O
slang_init	function
(	O
void	O
)	O
{	O
SLtt_get_terminfo	function
(	O
)	O
;	O
if	O
(	O
(	O
COLS	O
<	O
10	int
)	O
||	O
(	O
LINES	O
<	O
5	int
)	O
||	O
(	O
SLang_Version	int
<	O
10407	int
&&	O
(	O
COLS	O
>	O
255	int
||	O
LINES	O
>	O
255	int
)	O
)	O
||	O
(	O
SLang_Version	int
>=	O
10407	int
&&	O
(	O
COLS	O
>	O
512	int
||	O
LINES	O
>	O
512	int
)	O
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Screen size %dx%d is not supported.\n"	pointer
"Check the TERM environment variable.\n"	pointer
)	O
,	O
COLS	O
,	O
LINES	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
tcgetattr	function
(	O
fileno	function
(	O
stdin	pointer
)	O
,	O
&	O
boot_mode	struct
)	O
;	O
SLang_init_tty	function
(	O
XCTRL	O
(	O
'c'	O
)	O
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
SLang_TT_Read_FD	int
==	O
fileno	function
(	O
stderr	pointer
)	O
)	O
SLang_TT_Read_FD	int
=	O
fileno	function
(	O
stdin	pointer
)	O
;	O
if	O
(	O
force_ugly_line_drawing	int
)	O
SLtt_Has_Alt_Charset	int
=	O
0	int
;	O
if	O
(	O
tcgetattr	function
(	O
SLang_TT_Read_FD	int
,	O
&	O
new_mode	struct
)	O
==	O
0	int
)	O
{	O
new_mode	struct
.	O
c_cc	array
[	O
VLNEXT	int
]	O
=	O
NULL_VALUE	O
;	O
tcsetattr	function
(	O
SLang_TT_Read_FD	int
,	O
TCSADRAIN	int
,	O
&	O
new_mode	struct
)	O
;	O
}	O
slang_prog_mode	function
(	O
)	O
;	O
load_terminfo_keys	function
(	O
)	O
;	O
SLtt_Blink_Mode	int
=	O
0	int
;	O
}	O
void	O
slang_set_raw_mode	function
(	O
void	O
)	O
{	O
tcsetattr	function
(	O
SLang_TT_Read_FD	int
,	O
TCSANOW	int
,	O
&	O
new_mode	struct
)	O
;	O
}	O
void	O
slang_prog_mode	function
(	O
void	O
)	O
{	O
tcsetattr	function
(	O
SLang_TT_Read_FD	int
,	O
TCSANOW	int
,	O
&	O
new_mode	struct
)	O
;	O
SLsmg_init_smg	function
(	O
)	O
;	O
SLsmg_touch_lines	function
(	O
0	int
,	O
LINES	O
)	O
;	O
}	O
void	O
slang_shell_mode	function
(	O
void	O
)	O
{	O
tcsetattr	function
(	O
SLang_TT_Read_FD	int
,	O
TCSANOW	int
,	O
&	O
boot_mode	struct
)	O
;	O
}	O
void	O
slang_shutdown	function
(	O
void	O
)	O
{	O
char	O
*	O
op_cap	pointer
;	O
slang_shell_mode	function
(	O
)	O
;	O
do_exit_ca_mode	function
(	O
)	O
;	O
SLang_reset_tty	function
(	O
)	O
;	O
op_cap	pointer
=	O
SLtt_tgetstr	function
(	O
"op"	pointer
)	O
;	O
if	O
(	O
op_cap	pointer
)	O
{	O
fprintf	function
(	O
stdout	pointer
,	O
"%s"	pointer
,	O
op_cap	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
}	O
}	O
static	O
void	O
slang_reset_softkeys	function
(	O
void	O
)	O
{	O
int	O
key	pointer
;	O
char	O
*	O
send	pointer
;	O
static	O
const	O
char	O
display	array
[	O
]	O
=	O
"                "	pointer
;	O
char	O
tmp	array
[	O
BUF_SMALL	int
]	O
;	O
for	O
(	O
key	pointer
=	O
1	int
;	O
key	pointer
<	O
9	int
;	O
key	pointer
++	O
)	O
{	O
g_snprintf	function
(	O
tmp	array
,	O
sizeof	O
(	O
tmp	array
)	O
,	O
"k%d"	pointer
,	O
key	pointer
)	O
;	O
send	pointer
=	O
(	O
char	O
*	O
)	O
SLtt_tgetstr	function
(	O
tmp	array
)	O
;	O
if	O
(	O
send	pointer
)	O
{	O
g_snprintf	function
(	O
tmp	array
,	O
sizeof	O
(	O
tmp	array
)	O
,	O
"\033&f%dk%dd%dL%s%s"	pointer
,	O
key	pointer
,	O
(	O
int	O
)	O
(	O
sizeof	O
(	O
display	array
)	O
-	O
1	int
)	O
,	O
(	O
int	O
)	O
strlen	function
(	O
send	pointer
)	O
,	O
display	array
,	O
send	pointer
)	O
;	O
SLtt_write_string	function
(	O
tmp	array
)	O
;	O
}	O
}	O
}	O
void	O
slang_keypad	function
(	O
int	O
set	int
)	O
{	O
char	O
*	O
keypad_string	pointer
;	O
extern	O
int	O
reset_hp_softkeys	int
;	O
keypad_string	pointer
=	O
(	O
char	O
*	O
)	O
SLtt_tgetstr	function
(	O
set	int
?	O
"ks"	pointer
:	O
"ke"	pointer
)	O
;	O
if	O
(	O
keypad_string	pointer
)	O
SLtt_write_string	function
(	O
keypad_string	pointer
)	O
;	O
if	O
(	O
set	int
&&	O
reset_hp_softkeys	int
)	O
slang_reset_softkeys	function
(	O
)	O
;	O
}	O
void	O
set_slang_delay	function
(	O
int	O
v	pointer
)	O
{	O
no_slang_delay	int
=	O
v	pointer
;	O
}	O
void	O
hline	function
(	O
int	O
ch	int
,	O
int	O
len	int
)	O
{	O
int	O
last_x	int
,	O
last_y	int
;	O
last_x	int
=	O
SLsmg_get_column	function
(	O
)	O
;	O
last_y	int
=	O
SLsmg_get_row	function
(	O
)	O
;	O
if	O
(	O
ch	int
==	O
0	int
)	O
ch	int
=	O
ACS_HLINE	O
;	O
if	O
(	O
ch	int
==	O
ACS_HLINE	O
)	O
{	O
SLsmg_draw_hline	function
(	O
len	int
)	O
;	O
}	O
else	O
{	O
while	O
(	O
len	int
--	O
)	O
addch	O
(	O
ch	int
)	O
;	O
}	O
move	O
(	O
last_y	int
,	O
last_x	int
)	O
;	O
}	O
void	O
vline	function
(	O
int	O
character	int
,	O
int	O
len	int
)	O
{	O
if	O
(	O
!	O
slow_terminal	int
)	O
{	O
SLsmg_draw_vline	function
(	O
len	int
)	O
;	O
}	O
else	O
{	O
int	O
last_x	int
,	O
last_y	int
,	O
pos	pointer
=	O
0	int
;	O
last_x	int
=	O
SLsmg_get_column	function
(	O
)	O
;	O
last_y	int
=	O
SLsmg_get_row	function
(	O
)	O
;	O
while	O
(	O
len	int
--	O
)	O
{	O
move	O
(	O
last_y	int
+	O
pos	pointer
++	O
,	O
last_x	int
)	O
;	O
addch	O
(	O
' '	O
)	O
;	O
}	O
move	O
(	O
last_x	int
,	O
last_y	int
)	O
;	O
}	O
}	O
int	O
has_colors	function
(	O
void	O
)	O
{	O
const	O
char	O
*	O
terminal	pointer
=	O
getenv	function
(	O
"TERM"	pointer
)	O
;	O
char	O
*	O
cts	pointer
=	O
color_terminal_string	array
,	O
*	O
s	pointer
;	O
size_t	long
i	array
;	O
if	O
(	O
force_colors	int
)	O
SLtt_Use_Ansi_Colors	int
=	O
1	int
;	O
if	O
(	O
NULL	O
!=	O
getenv	function
(	O
"COLORTERM"	pointer
)	O
)	O
SLtt_Use_Ansi_Colors	int
=	O
1	int
;	O
if	O
(	O
!	O
disable_colors	int
)	O
{	O
if	O
(	O
*	O
cts	pointer
)	O
{	O
while	O
(	O
*	O
cts	pointer
)	O
{	O
while	O
(	O
*	O
cts	pointer
==	O
' '	O
||	O
*	O
cts	pointer
==	O
'\t'	O
)	O
cts	pointer
++	O
;	O
s	pointer
=	O
cts	pointer
;	O
i	array
=	O
0	int
;	O
while	O
(	O
*	O
cts	pointer
&&	O
*	O
cts	pointer
!=	O
','	O
)	O
{	O
cts	pointer
++	O
;	O
i	array
++	O
;	O
}	O
if	O
(	O
i	array
&&	O
i	array
==	O
strlen	function
(	O
terminal	pointer
)	O
&&	O
strncmp	function
(	O
s	pointer
,	O
terminal	pointer
,	O
i	array
)	O
==	O
0	int
)	O
SLtt_Use_Ansi_Colors	int
=	O
1	int
;	O
if	O
(	O
*	O
cts	pointer
==	O
','	O
)	O
cts	pointer
++	O
;	O
}	O
}	O
}	O
if	O
(	O
SLtt_Use_Ansi_Colors	int
)	O
{	O
if	O
(	O
use_colors	int
)	O
{	O
mc_init_pair	function
(	O
A_REVERSE	int
,	O
"black"	pointer
,	O
"white"	pointer
)	O
;	O
mc_init_pair	function
(	O
A_BOLD	int
,	O
"white"	pointer
,	O
"black"	pointer
)	O
;	O
}	O
else	O
{	O
mc_init_pair	function
(	O
A_REVERSE	int
,	O
"black"	pointer
,	O
"lightgray"	pointer
)	O
;	O
mc_init_pair	function
(	O
A_BOLD	int
,	O
"white"	pointer
,	O
"black"	pointer
)	O
;	O
mc_init_pair	function
(	O
A_BOLD_REVERSE	int
,	O
"white"	pointer
,	O
"lightgray"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
SLtt_set_mono	function
(	O
A_BOLD	int
,	O
NULL	O
,	O
SLTT_BOLD_MASK	int
)	O
;	O
SLtt_set_mono	function
(	O
A_REVERSE	int
,	O
NULL	O
,	O
SLTT_REV_MASK	int
)	O
;	O
SLtt_set_mono	function
(	O
A_BOLD	int
|	O
A_REVERSE	int
,	O
NULL	O
,	O
SLTT_BOLD_MASK	int
|	O
SLTT_REV_MASK	int
)	O
;	O
}	O
return	O
SLtt_Use_Ansi_Colors	int
;	O
}	O
void	O
attrset	function
(	O
int	O
color	short
)	O
{	O
if	O
(	O
!	O
SLtt_Use_Ansi_Colors	int
)	O
{	O
SLsmg_set_color	function
(	O
color	short
)	O
;	O
return	O
;	O
}	O
if	O
(	O
color	short
&	O
A_BOLD	int
)	O
{	O
if	O
(	O
color	short
==	O
A_BOLD	int
)	O
SLsmg_set_color	function
(	O
A_BOLD	int
)	O
;	O
else	O
SLsmg_set_color	function
(	O
(	O
color	short
&	O
(	O
~	O
A_BOLD	int
)	O
)	O
+	O
8	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
color	short
==	O
A_REVERSE	int
)	O
SLsmg_set_color	function
(	O
A_REVERSE	int
)	O
;	O
else	O
SLsmg_set_color	function
(	O
color	short
)	O
;	O
}	O
static	O
const	O
struct	O
{	O
int	O
key_code	int
;	O
const	O
char	O
*	O
key_name	pointer
;	O
}	O
key_table	array
[	O
]	O
=	O
{	O
{	O
KEY_F	O
(	O
0	int
)	O
,	O
"k0"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
1	int
)	O
,	O
"k1"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
2	int
)	O
,	O
"k2"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
3	int
)	O
,	O
"k3"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
4	int
)	O
,	O
"k4"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
5	int
)	O
,	O
"k5"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
6	int
)	O
,	O
"k6"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
7	int
)	O
,	O
"k7"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
8	int
)	O
,	O
"k8"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
9	int
)	O
,	O
"k9"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
10	int
)	O
,	O
"k;"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
11	int
)	O
,	O
"F1"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
12	int
)	O
,	O
"F2"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
13	int
)	O
,	O
"F3"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
14	int
)	O
,	O
"F4"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
15	int
)	O
,	O
"F5"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
16	int
)	O
,	O
"F6"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
17	int
)	O
,	O
"F7"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
18	int
)	O
,	O
"F8"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
19	int
)	O
,	O
"F9"	pointer
}	O
,	O
{	O
KEY_F	O
(	O
20	int
)	O
,	O
"FA"	pointer
}	O
,	O
{	O
KEY_IC	int
,	O
"kI"	pointer
}	O
,	O
{	O
KEY_NPAGE	int
,	O
"kN"	pointer
}	O
,	O
{	O
KEY_PPAGE	int
,	O
"kP"	pointer
}	O
,	O
{	O
KEY_LEFT	int
,	O
"kl"	pointer
}	O
,	O
{	O
KEY_RIGHT	int
,	O
"kr"	pointer
}	O
,	O
{	O
KEY_UP	int
,	O
"ku"	pointer
}	O
,	O
{	O
KEY_DOWN	int
,	O
"kd"	pointer
}	O
,	O
{	O
KEY_DC	int
,	O
"kD"	pointer
}	O
,	O
{	O
KEY_BACKSPACE	int
,	O
"kb"	pointer
}	O
,	O
{	O
KEY_HOME	int
,	O
"kh"	pointer
}	O
,	O
{	O
KEY_END	int
,	O
"@7"	pointer
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
void	O
do_define_key	function
(	O
int	O
code	int
,	O
const	O
char	O
*	O
strcap	pointer
)	O
{	O
char	O
*	O
seq	pointer
;	O
seq	pointer
=	O
(	O
char	O
*	O
)	O
SLtt_tgetstr	function
(	O
(	O
char	O
*	O
)	O
strcap	pointer
)	O
;	O
if	O
(	O
seq	pointer
)	O
define_sequence	function
(	O
code	int
,	O
seq	pointer
,	O
MCKEY_NOACTION	int
)	O
;	O
}	O
static	O
void	O
load_terminfo_keys	function
(	O
void	O
)	O
{	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
key_table	array
[	O
i	array
]	O
.	O
key_code	int
;	O
i	array
++	O
)	O
do_define_key	function
(	O
key_table	array
[	O
i	array
]	O
.	O
key_code	int
,	O
key_table	array
[	O
i	array
]	O
.	O
key_name	pointer
)	O
;	O
}	O
int	O
getch	function
(	O
void	O
)	O
{	O
int	O
c	int
;	O
if	O
(	O
no_slang_delay	int
)	O
if	O
(	O
SLang_input_pending2	O
(	O
0	int
)	O
==	O
0	int
)	O
return	O
-	O
1	int
;	O
c	int
=	O
SLang_getkey2	O
(	O
)	O
;	O
if	O
(	O
c	int
==	O
SLANG_GETKEY_ERROR	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"SLang_getkey returned SLANG_GETKEY_ERROR\n"	pointer
"Assuming EOF on stdin and exiting\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
c	int
;	O
}	O
void	O
mc_refresh	function
(	O
void	O
)	O
{	O
if	O
(	O
!	O
we_are_background	int
)	O
refresh	O
(	O
)	O
;	O
}	O
