void	O
change_dragon_status	function
(	O
int	O
dr	int
,	O
enum	O
dragon_status	function
status	enum
)	O
{	O
int	O
pos	int
;	O
int	O
origin	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
==	O
origin	int
)	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
=	O
status	enum
;	O
}	O
}	O
int	O
defend_against	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
apos	int
)	O
{	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
"defend_against"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
safe_move	function
(	O
apos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
==	O
0	int
)	O
{	O
popgo	function
(	O
)	O
;	O
return	O
1	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
cut_possible	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
return	O
(	O
cutting_points	array
[	O
pos	int
]	O
&	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
!=	O
0	int
;	O
}	O
int	O
does_attack	function
(	O
int	O
move	pointer
,	O
int	O
str	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
result	int
=	O
0	int
;	O
int	O
acode	int
=	O
0	int
;	O
int	O
dcode	int
=	O
0	int
;	O
int	O
spos	int
=	O
NO_MOVE	O
;	O
attack_and_defend	function
(	O
str	int
,	O
&	O
acode	int
,	O
NULL	O
,	O
&	O
dcode	int
,	O
&	O
spos	int
)	O
;	O
if	O
(	O
acode	int
!=	O
0	int
&&	O
dcode	int
==	O
0	int
)	O
return	O
0	int
;	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
other	int
,	O
"does_attack-A"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
!	O
board	pointer
[	O
str	int
]	O
)	O
result	int
=	O
WIN	int
;	O
else	O
result	int
=	O
REVERSE_RESULT	O
(	O
find_defense	function
(	O
str	int
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
result	int
!=	O
0	int
)	O
{	O
increase_depth_values	function
(	O
)	O
;	O
if	O
(	O
spos	int
!=	O
NO_MOVE	O
&&	O
trymove	function
(	O
spos	int
,	O
color	int
,	O
"does_attack-B"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
str	int
]	O
)	O
{	O
int	O
new_result	int
=	O
attack	function
(	O
str	int
,	O
NULL	O
)	O
;	O
if	O
(	O
new_result	int
<	O
result	int
)	O
result	int
=	O
new_result	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
decrease_depth_values	function
(	O
)	O
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
result	int
<	O
acode	int
)	O
result	int
=	O
0	int
;	O
return	O
result	int
;	O
}	O
int	O
does_defend	function
(	O
int	O
move	pointer
,	O
int	O
str	int
)	O
{	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
result	int
=	O
0	int
;	O
int	O
spos	int
=	O
NO_MOVE	O
;	O
if	O
(	O
!	O
attack	function
(	O
str	int
,	O
&	O
spos	int
)	O
)	O
return	O
0	int
;	O
gg_assert	O
(	O
spos	int
!=	O
NO_MOVE	O
)	O
;	O
if	O
(	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
"does_defend-A"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
!	O
attack	function
(	O
str	int
,	O
NULL	O
)	O
)	O
{	O
result	int
=	O
1	int
;	O
increase_depth_values	function
(	O
)	O
;	O
if	O
(	O
trymove	function
(	O
spos	int
,	O
other	int
,	O
"does_defend-B"	pointer
,	O
str	int
)	O
)	O
{	O
if	O
(	O
!	O
board	pointer
[	O
str	int
]	O
||	O
!	O
find_defense	function
(	O
str	int
,	O
NULL	O
)	O
)	O
result	int
=	O
0	int
;	O
popgo	function
(	O
)	O
;	O
}	O
decrease_depth_values	function
(	O
)	O
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
return	O
result	int
;	O
}	O
int	O
somewhere	function
(	O
int	O
color	int
,	O
int	O
check_alive	int
,	O
int	O
num_moves	int
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
||	O
!	O
check_alive	int
)	O
;	O
va_start	O
(	O
ap	array
,	O
num_moves	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
pos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
(	O
!	O
check_alive	int
||	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
!=	O
DEAD	int
)	O
)	O
{	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
1	int
;	O
}	O
}	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
0	int
;	O
}	O
int	O
visible_along_edge	function
(	O
int	O
color	int
,	O
int	O
apos	int
,	O
int	O
bpos	int
)	O
{	O
int	O
ai	int
=	O
I	O
(	O
apos	int
)	O
;	O
int	O
aj	int
=	O
J	O
(	O
apos	int
)	O
;	O
int	O
bi	int
=	O
I	O
(	O
bpos	int
)	O
;	O
int	O
bj	int
=	O
J	O
(	O
bpos	int
)	O
;	O
int	O
pos	int
;	O
int	O
forward	int
;	O
int	O
up	int
;	O
ASSERT1	O
(	O
(	O
ai	int
==	O
bi	int
)	O
^	O
(	O
aj	int
==	O
bj	int
)	O
,	O
apos	int
)	O
;	O
if	O
(	O
ai	int
==	O
bi	int
)	O
{	O
if	O
(	O
aj	int
>	O
bj	int
)	O
forward	int
=	O
WEST	O
(	O
0	int
)	O
;	O
else	O
forward	int
=	O
EAST	O
(	O
0	int
)	O
;	O
if	O
(	O
ai	int
<	O
board_size	int
/	O
2	int
)	O
{	O
pos	int
=	O
POS	O
(	O
0	int
,	O
bj	int
)	O
;	O
up	int
=	O
SOUTH	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
pos	int
=	O
POS	O
(	O
board_size	int
-	O
1	int
,	O
bj	int
)	O
;	O
up	int
=	O
NORTH	O
(	O
0	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
ai	int
>	O
bi	int
)	O
forward	int
=	O
NORTH	O
(	O
0	int
)	O
;	O
else	O
forward	int
=	O
SOUTH	O
(	O
0	int
)	O
;	O
if	O
(	O
aj	int
<	O
board_size	int
/	O
2	int
)	O
{	O
pos	int
=	O
POS	O
(	O
bi	int
,	O
0	int
)	O
;	O
up	int
=	O
EAST	O
(	O
0	int
)	O
;	O
}	O
else	O
{	O
pos	int
=	O
POS	O
(	O
bi	int
,	O
board_size	int
-	O
1	int
)	O
;	O
up	int
=	O
WEST	O
(	O
0	int
)	O
;	O
}	O
}	O
for	O
(	O
;	O
ON_BOARD	O
(	O
pos	int
)	O
;	O
pos	int
+=	O
forward	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
4	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
+	O
k	int
*	O
up	int
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
k	int
*	O
up	int
]	O
==	O
color	int
)	O
return	O
1	int
;	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
k	int
*	O
up	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
return	O
0	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
test_symmetry_after_move	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
strict	int
)	O
{	O
int	O
pos	int
;	O
int	O
result	int
=	O
1	int
;	O
if	O
(	O
move	pointer
!=	O
PASS_MOVE	int
)	O
{	O
if	O
(	O
board	pointer
[	O
move	pointer
]	O
!=	O
EMPTY	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
"find_mirror_move"	pointer
,	O
NO_MOVE	O
)	O
)	O
return	O
0	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
MIRROR_MOVE	O
(	O
pos	int
)	O
;	O
pos	int
++	O
)	O
{	O
int	O
sum	pointer
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
sum	pointer
=	O
board	pointer
[	O
pos	int
]	O
+	O
board	pointer
[	O
MIRROR_MOVE	O
(	O
pos	int
)	O
]	O
;	O
if	O
(	O
sum	pointer
!=	O
EMPTY	int
+	O
EMPTY	int
&&	O
sum	pointer
!=	O
BLACK	int
+	O
WHITE	int
)	O
{	O
if	O
(	O
strict	int
||	O
sum	pointer
==	O
EMPTY	int
+	O
WHITE	int
||	O
sum	pointer
==	O
EMPTY	int
+	O
BLACK	int
)	O
{	O
result	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
move	pointer
!=	O
PASS_MOVE	int
)	O
popgo	function
(	O
)	O
;	O
return	O
result	int
;	O
}	O
int	O
play_break_through_n	function
(	O
int	O
color	int
,	O
int	O
num_moves	int
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
mcolor	int
=	O
color	int
;	O
int	O
success	int
=	O
0	int
;	O
int	O
i	int
;	O
int	O
played_moves	int
=	O
0	int
;	O
int	O
apos	int
;	O
int	O
xpos	int
;	O
int	O
ypos	int
;	O
int	O
zpos	int
;	O
va_start	O
(	O
ap	array
,	O
num_moves	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
apos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
apos	int
!=	O
NO_MOVE	O
&&	O
(	O
trymove	function
(	O
apos	int
,	O
mcolor	int
,	O
"play_break_through_n"	pointer
,	O
NO_MOVE	O
)	O
||	O
tryko	function
(	O
apos	int
,	O
mcolor	int
,	O
"play_break_through_n"	pointer
)	O
)	O
)	O
played_moves	int
++	O
;	O
mcolor	int
=	O
OTHER_COLOR	O
(	O
mcolor	int
)	O
;	O
}	O
xpos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
ypos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
zpos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
board	pointer
[	O
xpos	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
ypos	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
zpos	int
]	O
==	O
EMPTY	int
)	O
success	int
=	O
1	int
;	O
else	O
success	int
=	O
break_through	function
(	O
xpos	int
,	O
ypos	int
,	O
zpos	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
played_moves	int
;	O
i	int
++	O
)	O
popgo	function
(	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
success	int
;	O
}	O
int	O
play_attack_defend_n	function
(	O
int	O
color	int
,	O
int	O
do_attack	int
,	O
int	O
num_moves	int
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
mcolor	int
=	O
color	int
;	O
int	O
success	int
=	O
0	int
;	O
int	O
i	int
;	O
int	O
played_moves	int
=	O
0	int
;	O
int	O
apos	int
;	O
int	O
zpos	int
;	O
va_start	O
(	O
ap	array
,	O
num_moves	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
apos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
apos	int
!=	O
NO_MOVE	O
&&	O
(	O
trymove	function
(	O
apos	int
,	O
mcolor	int
,	O
"play_attack_defend_n"	pointer
,	O
NO_MOVE	O
)	O
||	O
tryko	function
(	O
apos	int
,	O
mcolor	int
,	O
"play_attack_defend_n"	pointer
)	O
)	O
)	O
played_moves	int
++	O
;	O
mcolor	int
=	O
OTHER_COLOR	O
(	O
mcolor	int
)	O
;	O
}	O
zpos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
do_attack	int
)	O
{	O
if	O
(	O
board	pointer
[	O
zpos	int
]	O
==	O
EMPTY	int
)	O
success	int
=	O
WIN	int
;	O
else	O
success	int
=	O
attack	function
(	O
zpos	int
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
board	pointer
[	O
zpos	int
]	O
==	O
EMPTY	int
)	O
success	int
=	O
0	int
;	O
else	O
{	O
int	O
dcode	int
=	O
find_defense	function
(	O
zpos	int
,	O
NULL	O
)	O
;	O
if	O
(	O
dcode	int
==	O
0	int
&&	O
!	O
attack	function
(	O
zpos	int
,	O
NULL	O
)	O
)	O
success	int
=	O
WIN	int
;	O
else	O
success	int
=	O
dcode	int
;	O
}	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
played_moves	int
;	O
i	int
++	O
)	O
popgo	function
(	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
success	int
;	O
}	O
int	O
play_attack_defend2_n	function
(	O
int	O
color	int
,	O
int	O
do_attack	int
,	O
int	O
num_moves	int
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
mcolor	int
=	O
color	int
;	O
int	O
success	int
=	O
0	int
;	O
int	O
i	int
;	O
int	O
played_moves	int
=	O
0	int
;	O
int	O
apos	int
;	O
int	O
ypos	int
;	O
int	O
zpos	int
;	O
va_start	O
(	O
ap	array
,	O
num_moves	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
apos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
apos	int
!=	O
NO_MOVE	O
&&	O
(	O
trymove	function
(	O
apos	int
,	O
mcolor	int
,	O
"play_attack_defend_n"	pointer
,	O
NO_MOVE	O
)	O
||	O
tryko	function
(	O
apos	int
,	O
mcolor	int
,	O
"play_attack_defend_n"	pointer
)	O
)	O
)	O
played_moves	int
++	O
;	O
mcolor	int
=	O
OTHER_COLOR	O
(	O
mcolor	int
)	O
;	O
}	O
ypos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
zpos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
do_attack	int
)	O
{	O
if	O
(	O
board	pointer
[	O
ypos	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
zpos	int
]	O
==	O
EMPTY	int
)	O
success	int
=	O
WIN	int
;	O
else	O
success	int
=	O
attack_either	function
(	O
ypos	int
,	O
zpos	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
board	pointer
[	O
ypos	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
zpos	int
]	O
==	O
EMPTY	int
)	O
success	int
=	O
0	int
;	O
else	O
success	int
=	O
defend_both	function
(	O
ypos	int
,	O
zpos	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
played_moves	int
;	O
i	int
++	O
)	O
popgo	function
(	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
success	int
;	O
}	O
int	O
play_connect_n	function
(	O
int	O
color	int
,	O
int	O
do_connect	int
,	O
int	O
num_moves	int
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
mcolor	int
=	O
color	int
;	O
int	O
success	int
=	O
0	int
;	O
int	O
i	int
;	O
int	O
played_moves	int
=	O
0	int
;	O
int	O
apos	int
;	O
int	O
ypos	int
;	O
int	O
zpos	int
;	O
va_start	O
(	O
ap	array
,	O
num_moves	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
apos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
apos	int
!=	O
NO_MOVE	O
&&	O
(	O
trymove	function
(	O
apos	int
,	O
mcolor	int
,	O
"play_connect_n"	pointer
,	O
NO_MOVE	O
)	O
||	O
tryko	function
(	O
apos	int
,	O
mcolor	int
,	O
"play_connect_n"	pointer
)	O
)	O
)	O
played_moves	int
++	O
;	O
mcolor	int
=	O
OTHER_COLOR	O
(	O
mcolor	int
)	O
;	O
}	O
ypos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
zpos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
do_connect	int
)	O
{	O
if	O
(	O
board	pointer
[	O
ypos	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
zpos	int
]	O
==	O
EMPTY	int
)	O
success	int
=	O
0	int
;	O
else	O
success	int
=	O
string_connect	function
(	O
ypos	int
,	O
zpos	int
,	O
NULL	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
board	pointer
[	O
ypos	int
]	O
==	O
EMPTY	int
||	O
board	pointer
[	O
zpos	int
]	O
==	O
EMPTY	int
)	O
success	int
=	O
WIN	int
;	O
else	O
success	int
=	O
disconnect	function
(	O
ypos	int
,	O
zpos	int
,	O
NULL	O
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
played_moves	int
;	O
i	int
++	O
)	O
popgo	function
(	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
success	int
;	O
}	O
int	O
play_lib_n	function
(	O
int	O
color	int
,	O
int	O
num_moves	int
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
mcolor	int
=	O
color	int
;	O
int	O
libs	pointer
=	O
0	int
;	O
int	O
i	int
;	O
int	O
played_moves	int
=	O
0	int
;	O
int	O
apos	int
;	O
int	O
ypos	int
;	O
va_start	O
(	O
ap	array
,	O
num_moves	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
apos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
apos	int
!=	O
NO_MOVE	O
&&	O
(	O
trymove	function
(	O
apos	int
,	O
mcolor	int
,	O
"play_connect_n"	pointer
,	O
NO_MOVE	O
)	O
||	O
tryko	function
(	O
apos	int
,	O
mcolor	int
,	O
"play_connect_n"	pointer
)	O
)	O
)	O
played_moves	int
++	O
;	O
mcolor	int
=	O
OTHER_COLOR	O
(	O
mcolor	int
)	O
;	O
}	O
ypos	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
board	pointer
[	O
ypos	int
]	O
==	O
EMPTY	int
)	O
libs	pointer
=	O
0	int
;	O
else	O
libs	pointer
=	O
countlib	function
(	O
ypos	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
played_moves	int
;	O
i	int
++	O
)	O
popgo	function
(	O
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
libs	pointer
;	O
}	O
void	O
set_depth_values	function
(	O
int	O
level	int
,	O
int	O
report_levels	int
)	O
{	O
static	O
int	O
node_limits	array
[	O
]	O
=	O
{	O
500	int
,	O
500	int
,	O
450	int
,	O
400	int
,	O
400	int
,	O
325	int
,	O
275	int
,	O
200	int
,	O
150	int
,	O
100	int
,	O
75	int
,	O
50	int
}	O
;	O
int	O
depth_level	int
;	O
if	O
(	O
level	int
>=	O
10	int
)	O
depth_level	int
=	O
level	int
-	O
10	int
;	O
else	O
if	O
(	O
level	int
==	O
9	int
)	O
depth_level	int
=	O
0	int
;	O
else	O
if	O
(	O
level	int
==	O
8	int
)	O
depth_level	int
=	O
-	O
1	int
;	O
else	O
depth_level	int
=	O
level	int
-	O
8	int
;	O
depth	int
=	O
gg_max	O
(	O
6	int
,	O
DEPTH	int
+	O
depth_level	int
)	O
;	O
branch_depth	int
=	O
gg_max	O
(	O
3	int
,	O
BRANCH_DEPTH	int
+	O
depth_level	int
)	O
;	O
backfill_depth	int
=	O
gg_max	O
(	O
2	int
,	O
BACKFILL_DEPTH	int
+	O
depth_level	int
)	O
;	O
backfill2_depth	int
=	O
gg_max	O
(	O
1	int
,	O
BACKFILL2_DEPTH	int
+	O
depth_level	int
)	O
;	O
break_chain_depth	int
=	O
gg_max	O
(	O
2	int
,	O
BREAK_CHAIN_DEPTH	int
+	O
depth_level	int
)	O
;	O
if	O
(	O
level	int
>=	O
8	int
)	O
owl_distrust_depth	int
=	O
gg_max	O
(	O
1	int
,	O
(	O
2	int
*	O
OWL_DISTRUST_DEPTH	int
+	O
depth_level	int
)	O
/	O
2	int
)	O
;	O
else	O
owl_distrust_depth	int
=	O
gg_max	O
(	O
1	int
,	O
(	O
2	int
*	O
OWL_DISTRUST_DEPTH	int
-	O
1	int
+	O
depth_level	int
)	O
/	O
2	int
)	O
;	O
owl_branch_depth	int
=	O
gg_max	O
(	O
2	int
,	O
(	O
2	int
*	O
OWL_BRANCH_DEPTH	int
+	O
depth_level	int
)	O
/	O
2	int
)	O
;	O
owl_reading_depth	int
=	O
gg_max	O
(	O
5	int
,	O
(	O
2	int
*	O
OWL_READING_DEPTH	int
+	O
depth_level	int
)	O
/	O
2	int
)	O
;	O
if	O
(	O
level	int
>=	O
10	int
)	O
aa_depth	int
=	O
gg_max	O
(	O
0	int
,	O
AA_DEPTH	int
+	O
(	O
level	int
-	O
10	int
)	O
)	O
;	O
else	O
if	O
(	O
level	int
==	O
9	int
)	O
aa_depth	int
=	O
gg_max	O
(	O
0	int
,	O
AA_DEPTH	int
)	O
;	O
else	O
if	O
(	O
level	int
>=	O
7	int
)	O
aa_depth	int
=	O
gg_max	O
(	O
0	int
,	O
AA_DEPTH	int
-	O
1	int
)	O
;	O
else	O
aa_depth	int
=	O
gg_max	O
(	O
0	int
,	O
AA_DEPTH	int
-	O
(	O
8	int
-	O
level	int
)	O
)	O
;	O
if	O
(	O
level	int
>=	O
10	int
)	O
ko_depth	int
=	O
gg_max	O
(	O
1	int
,	O
KO_DEPTH	int
+	O
(	O
level	int
-	O
10	int
)	O
)	O
;	O
else	O
if	O
(	O
level	int
==	O
9	int
)	O
ko_depth	int
=	O
gg_max	O
(	O
1	int
,	O
KO_DEPTH	int
)	O
;	O
else	O
if	O
(	O
level	int
>=	O
7	int
)	O
ko_depth	int
=	O
gg_max	O
(	O
1	int
,	O
KO_DEPTH	int
-	O
1	int
)	O
;	O
else	O
ko_depth	int
=	O
gg_max	O
(	O
1	int
,	O
KO_DEPTH	int
+	O
(	O
level	int
-	O
8	int
)	O
)	O
;	O
if	O
(	O
level	int
>=	O
10	int
)	O
fourlib_depth	int
=	O
gg_max	O
(	O
1	int
,	O
FOURLIB_DEPTH	int
+	O
(	O
level	int
-	O
10	int
)	O
)	O
;	O
else	O
if	O
(	O
level	int
>=	O
7	int
)	O
fourlib_depth	int
=	O
gg_max	O
(	O
1	int
,	O
FOURLIB_DEPTH	int
)	O
;	O
else	O
fourlib_depth	int
=	O
gg_max	O
(	O
1	int
,	O
FOURLIB_DEPTH	int
+	O
(	O
level	int
-	O
7	int
)	O
)	O
;	O
if	O
(	O
level	int
>=	O
8	int
)	O
superstring_depth	int
=	O
gg_max	O
(	O
1	int
,	O
SUPERSTRING_DEPTH	int
)	O
;	O
else	O
superstring_depth	int
=	O
0	int
;	O
if	O
(	O
level	int
>=	O
10	int
)	O
owl_node_limit	int
=	O
OWL_NODE_LIMIT	int
*	O
pow	function
(	O
1.5	int
,	O
depth_level	int
)	O
;	O
else	O
{	O
owl_node_limit	int
=	O
(	O
OWL_NODE_LIMIT	int
*	O
node_limits	array
[	O
10	int
-	O
level	int
]	O
/	O
node_limits	array
[	O
0	int
]	O
)	O
;	O
owl_node_limit	int
=	O
gg_max	O
(	O
20	int
,	O
owl_node_limit	int
)	O
;	O
}	O
semeai_branch_depth	int
=	O
gg_max	O
(	O
2	int
,	O
(	O
2	int
*	O
SEMEAI_BRANCH_DEPTH	int
+	O
depth_level	int
)	O
/	O
2	int
)	O
;	O
semeai_branch_depth2	int
=	O
gg_max	O
(	O
2	int
,	O
(	O
2	int
*	O
SEMEAI_BRANCH_DEPTH2	int
+	O
depth_level	int
)	O
/	O
2	int
)	O
;	O
semeai_node_limit	int
=	O
SEMEAI_NODE_LIMIT	int
*	O
pow	function
(	O
1.5	int
,	O
depth_level	int
)	O
;	O
connect_depth	int
=	O
gg_max	O
(	O
2	int
,	O
CONNECT_DEPTH	int
+	O
2	int
*	O
depth_level	int
)	O
;	O
connect_depth2	int
=	O
gg_max	O
(	O
2	int
,	O
CONNECT_DEPTH2	int
+	O
2	int
*	O
depth_level	int
)	O
;	O
connection_node_limit	int
=	O
CONNECT_NODE_LIMIT	int
*	O
pow	function
(	O
1.45	int
,	O
depth_level	int
)	O
;	O
breakin_depth	int
=	O
gg_max	O
(	O
2	int
,	O
BREAKIN_DEPTH	int
+	O
2	int
*	O
depth_level	int
)	O
;	O
breakin_node_limit	int
=	O
BREAKIN_NODE_LIMIT	int
*	O
pow	function
(	O
1.5	int
,	O
depth_level	int
)	O
;	O
if	O
(	O
mandated_depth	int
!=	O
-	O
1	int
)	O
depth	int
=	O
mandated_depth	int
;	O
if	O
(	O
mandated_backfill_depth	int
!=	O
-	O
1	int
)	O
backfill_depth	int
=	O
mandated_backfill_depth	int
;	O
if	O
(	O
mandated_backfill2_depth	int
!=	O
-	O
1	int
)	O
backfill2_depth	int
=	O
mandated_backfill2_depth	int
;	O
if	O
(	O
mandated_break_chain_depth	int
!=	O
-	O
1	int
)	O
break_chain_depth	int
=	O
mandated_break_chain_depth	int
;	O
if	O
(	O
mandated_superstring_depth	int
!=	O
-	O
1	int
)	O
superstring_depth	int
=	O
mandated_superstring_depth	int
;	O
if	O
(	O
mandated_branch_depth	int
!=	O
-	O
1	int
)	O
branch_depth	int
=	O
mandated_branch_depth	int
;	O
if	O
(	O
mandated_fourlib_depth	int
!=	O
-	O
1	int
)	O
fourlib_depth	int
=	O
mandated_fourlib_depth	int
;	O
if	O
(	O
mandated_ko_depth	int
!=	O
-	O
1	int
)	O
ko_depth	int
=	O
mandated_ko_depth	int
;	O
if	O
(	O
mandated_aa_depth	int
!=	O
-	O
1	int
)	O
aa_depth	int
=	O
mandated_aa_depth	int
;	O
if	O
(	O
mandated_owl_distrust_depth	int
!=	O
-	O
1	int
)	O
owl_distrust_depth	int
=	O
mandated_owl_distrust_depth	int
;	O
if	O
(	O
mandated_owl_branch_depth	int
!=	O
-	O
1	int
)	O
owl_branch_depth	int
=	O
mandated_owl_branch_depth	int
;	O
if	O
(	O
mandated_owl_reading_depth	int
!=	O
-	O
1	int
)	O
owl_reading_depth	int
=	O
mandated_owl_reading_depth	int
;	O
if	O
(	O
mandated_owl_node_limit	int
!=	O
-	O
1	int
)	O
owl_node_limit	int
=	O
mandated_owl_node_limit	int
;	O
if	O
(	O
mandated_semeai_node_limit	int
!=	O
-	O
1	int
)	O
semeai_node_limit	int
=	O
mandated_semeai_node_limit	int
;	O
depth_offset	int
=	O
0	int
;	O
if	O
(	O
report_levels	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"at level %d:\n\ndepth: %d\nbranch_depth: %d\nbackfill_depth: %d\nbackfill2_depth: %d\nbreak_chain_depth: %d\nowl_distrust_depth: %d\nowl_branch_depth: %d\nowl_reading_depth: %d\naa_depth: %d\nko_depth: %d\nfourlib_depth: %d\nsuperstring_depth: %d\nowl_node_limit: %d\nsemeai_branch_depth: %d\nsemeai_branch_depth2: %d\nsemeai_node_limit: %d\nconnect_depth: %d\nconnect_depth2: %d\nconnection_node_limit: %d\nbreakin_depth: %d\nbreakin_node_limit: %d\n\n"	pointer
,	O
level	int
,	O
depth	int
,	O
branch_depth	int
,	O
backfill_depth	int
,	O
backfill2_depth	int
,	O
break_chain_depth	int
,	O
owl_distrust_depth	int
,	O
owl_branch_depth	int
,	O
owl_reading_depth	int
,	O
aa_depth	int
,	O
ko_depth	int
,	O
fourlib_depth	int
,	O
superstring_depth	int
,	O
owl_node_limit	int
,	O
semeai_branch_depth	int
,	O
semeai_branch_depth2	int
,	O
semeai_node_limit	int
,	O
connect_depth	int
,	O
connect_depth2	int
,	O
connection_node_limit	int
,	O
breakin_depth	int
,	O
breakin_node_limit	int
)	O
;	O
}	O
}	O
static	O
int	O
depth_modification	int
=	O
0	int
;	O
void	O
modify_depth_values	function
(	O
int	O
n	int
)	O
{	O
depth	int
+=	O
n	int
;	O
backfill_depth	int
+=	O
n	int
;	O
backfill2_depth	int
+=	O
n	int
;	O
break_chain_depth	int
+=	O
n	int
;	O
superstring_depth	int
+=	O
n	int
;	O
branch_depth	int
+=	O
n	int
;	O
fourlib_depth	int
+=	O
n	int
;	O
ko_depth	int
+=	O
n	int
;	O
breakin_depth	int
+=	O
n	int
;	O
depth_offset	int
+=	O
n	int
;	O
depth_modification	int
+=	O
n	int
;	O
}	O
void	O
increase_depth_values	function
(	O
void	O
)	O
{	O
modify_depth_values	function
(	O
1	int
)	O
;	O
}	O
void	O
decrease_depth_values	function
(	O
void	O
)	O
{	O
modify_depth_values	function
(	O
-	O
1	int
)	O
;	O
}	O
int	O
get_depth_modification	function
(	O
void	O
)	O
{	O
return	O
depth_modification	int
;	O
}	O
static	O
int	O
detect_owl_blunder	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
*	O
defense_point	pointer
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
int	O
liberties	pointer
,	O
float	O
*	O
return_value	pointer
,	O
int	O
save_verbose	int
)	O
;	O
static	O
void	O
detect_tactical_blunder	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
*	O
defense_point	pointer
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
int	O
liberties	pointer
,	O
int	O
*	O
libs	pointer
,	O
float	O
*	O
return_value	pointer
,	O
int	O
save_verbose	int
)	O
;	O
int	O
confirm_safety	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
*	O
defense_point	pointer
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
)	O
{	O
return	O
(	O
blunder_size	function
(	O
move	pointer
,	O
color	int
,	O
defense_point	pointer
,	O
safe_stones	array
)	O
==	O
0.0	int
)	O
;	O
}	O
float	O
blunder_size	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
*	O
defense_point	pointer
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
libs	pointer
[	O
5	int
]	O
;	O
int	O
liberties	pointer
=	O
accuratelib	function
(	O
move	pointer
,	O
color	int
,	O
5	int
,	O
libs	pointer
)	O
;	O
int	O
trouble	int
=	O
0	int
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
float	O
return_value	pointer
=	O
0.0	int
;	O
int	O
atari	int
;	O
signed	O
char	O
defense_moves	array
[	O
BOARDMAX	O
]	O
;	O
if	O
(	O
defense_point	pointer
)	O
*	O
defense_point	pointer
=	O
NO_MOVE	O
;	O
TRACE	O
(	O
"Checking safety of a %s move at %1m\n"	pointer
,	O
color_to_string	function
(	O
color	int
)	O
,	O
move	pointer
)	O
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
trouble	int
=	O
detect_owl_blunder	function
(	O
move	pointer
,	O
color	int
,	O
defense_point	pointer
,	O
safe_stones	array
,	O
liberties	pointer
,	O
&	O
return_value	pointer
,	O
save_verbose	int
)	O
;	O
if	O
(	O
trouble	int
)	O
detect_tactical_blunder	function
(	O
move	pointer
,	O
color	int
,	O
defense_point	pointer
,	O
safe_stones	array
,	O
liberties	pointer
,	O
libs	pointer
,	O
&	O
return_value	pointer
,	O
save_verbose	int
)	O
;	O
atari	int
=	O
atari_atari_blunder_size	function
(	O
color	int
,	O
move	pointer
,	O
defense_moves	array
,	O
safe_stones	array
)	O
;	O
if	O
(	O
atari	int
)	O
{	O
if	O
(	O
defense_point	pointer
)	O
{	O
int	O
pos	int
;	O
*	O
defense_point	pointer
=	O
NO_MOVE	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
defense_moves	array
[	O
pos	int
]	O
)	O
{	O
*	O
defense_point	pointer
=	O
pos	int
;	O
break	O
;	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
TRACE	O
(	O
"Combination attack appears.\n"	pointer
)	O
;	O
return_value	pointer
+=	O
(	O
float	O
)	O
atari	int
;	O
}	O
verbose	int
=	O
save_verbose	int
;	O
return	O
return_value	pointer
;	O
}	O
static	O
int	O
detect_owl_blunder	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
*	O
defense_point	pointer
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
int	O
liberties	pointer
,	O
float	O
*	O
return_value	pointer
,	O
int	O
save_verbose	int
)	O
{	O
int	O
k	int
;	O
int	O
ii	int
;	O
int	O
trouble	int
=	O
0	int
;	O
int	O
dragon_analyzed	array
[	O
4	int
]	O
=	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
;	O
int	O
current_verbose	int
=	O
verbose	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
bpos	int
=	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
;	O
int	O
j	int
;	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
!=	O
color	int
)	O
continue	O
;	O
if	O
(	O
liberties	pointer
<=	O
worm	array
[	O
bpos	int
]	O
.	O
liberties	pointer
&&	O
liberties	pointer
<=	O
4	int
)	O
trouble	int
=	O
1	int
;	O
else	O
if	O
(	O
min_eyes	function
(	O
&	O
(	O
DRAGON2	O
(	O
bpos	int
)	O
.	O
genus	pointer
)	O
)	O
>	O
2	int
||	O
!	O
is_proper_eye_space	function
(	O
move	pointer
)	O
)	O
continue	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
k	int
;	O
j	int
++	O
)	O
if	O
(	O
dragon_analyzed	array
[	O
j	int
]	O
==	O
dragon	int
[	O
bpos	int
]	O
.	O
origin	int
)	O
break	O
;	O
if	O
(	O
j	int
<	O
k	int
)	O
continue	O
;	O
dragon_analyzed	array
[	O
k	int
]	O
=	O
dragon	int
[	O
bpos	int
]	O
.	O
origin	int
;	O
if	O
(	O
safe_stones	array
&&	O
safe_stones	array
[	O
bpos	int
]	O
==	O
OWL_SAVED_STONE	int
)	O
continue	O
;	O
if	O
(	O
(	O
dragon	int
[	O
bpos	int
]	O
.	O
status	enum
==	O
ALIVE	int
||	O
(	O
safe_stones	array
&&	O
safe_stones	array
[	O
bpos	int
]	O
)	O
)	O
&&	O
DRAGON2	O
(	O
bpos	int
)	O
.	O
safety	int
!=	O
INVINCIBLE	int
&&	O
DRAGON2	O
(	O
bpos	int
)	O
.	O
safety	int
!=	O
STRONGLY_ALIVE	int
)	O
{	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
acode	int
=	O
owl_confirm_safety	function
(	O
move	pointer
,	O
bpos	int
,	O
defense_point	pointer
,	O
&	O
kworm	int
)	O
;	O
if	O
(	O
acode	int
!=	O
WIN	int
)	O
{	O
int	O
r	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
DRAGON2	O
(	O
bpos	int
)	O
.	O
neighbors	int
;	O
r	int
++	O
)	O
{	O
int	O
neighbor	int
=	O
dragon2	pointer
[	O
DRAGON2	O
(	O
bpos	int
)	O
.	O
adjacent	array
[	O
r	int
]	O
]	O
.	O
origin	int
;	O
int	O
resultb	pointer
;	O
if	O
(	O
board	pointer
[	O
neighbor	int
]	O
==	O
color	int
)	O
continue	O
;	O
owl_analyze_semeai_after_move	function
(	O
move	pointer
,	O
color	int
,	O
neighbor	int
,	O
bpos	int
,	O
NULL	O
,	O
&	O
resultb	pointer
,	O
NULL	O
,	O
1	int
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
resultb	pointer
==	O
0	int
)	O
acode	int
=	O
WIN	int
;	O
}	O
}	O
if	O
(	O
acode	int
==	O
0	int
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
TRACE	O
(	O
"Dragon at %1m becomes attackable.\n"	pointer
,	O
bpos	int
)	O
;	O
verbose	int
=	O
current_verbose	int
;	O
*	O
return_value	pointer
+=	O
2.0	int
*	O
dragon	int
[	O
bpos	int
]	O
.	O
effective_size	float
;	O
if	O
(	O
safe_stones	array
)	O
mark_dragon	function
(	O
bpos	int
,	O
safe_stones	array
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
acode	int
==	O
LOSS	int
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
TRACE	O
(	O
"Dragon at %1m becomes attackable.\n"	pointer
,	O
bpos	int
)	O
;	O
verbose	int
=	O
current_verbose	int
;	O
if	O
(	O
kworm	int
==	O
move	pointer
)	O
{	O
int	O
l	int
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
4	int
;	O
l	int
++	O
)	O
{	O
int	O
kworm	int
=	O
move	pointer
+	O
delta	array
[	O
l	int
]	O
;	O
if	O
(	O
board	pointer
[	O
kworm	int
]	O
==	O
color	int
)	O
{	O
*	O
return_value	pointer
+=	O
2.0	int
*	O
worm	array
[	O
kworm	int
]	O
.	O
effective_size	float
;	O
if	O
(	O
safe_stones	array
)	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
worm	array
[	O
ii	int
]	O
.	O
origin	int
==	O
worm	array
[	O
kworm	int
]	O
.	O
origin	int
)	O
safe_stones	array
[	O
ii	int
]	O
=	O
0	int
;	O
}	O
}	O
}	O
else	O
{	O
*	O
return_value	pointer
+=	O
2.0	int
*	O
worm	array
[	O
kworm	int
]	O
.	O
effective_size	float
;	O
if	O
(	O
safe_stones	array
)	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
ii	int
)	O
&&	O
worm	array
[	O
ii	int
]	O
.	O
origin	int
==	O
worm	array
[	O
kworm	int
]	O
.	O
origin	int
)	O
safe_stones	array
[	O
ii	int
]	O
=	O
0	int
;	O
}	O
}	O
}	O
}	O
return	O
trouble	int
;	O
}	O
static	O
void	O
detect_tactical_blunder	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
*	O
defense_point	pointer
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
int	O
liberties	pointer
,	O
int	O
*	O
libs	pointer
,	O
float	O
*	O
return_value	pointer
,	O
int	O
save_verbose	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
pos	int
;	O
int	O
ii	int
;	O
int	O
current_verbose	int
=	O
verbose	int
;	O
if	O
(	O
!	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
,	O
NO_MOVE	O
)	O
)	O
return	O
;	O
increase_depth_values	function
(	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
||	O
worm	array
[	O
pos	int
]	O
.	O
origin	int
!=	O
pos	int
||	O
pos	int
==	O
move	pointer
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
(	O
(	O
safe_stones	array
&&	O
safe_stones	array
[	O
pos	int
]	O
)	O
||	O
(	O
!	O
safe_stones	array
&&	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
)	O
&&	O
attack	function
(	O
pos	int
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
defense_point	pointer
)	O
{	O
find_defense	function
(	O
pos	int
,	O
defense_point	pointer
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
!	O
is_legal	function
(	O
*	O
defense_point	pointer
,	O
color	int
)	O
||	O
play_attack_defend_n	function
(	O
color	int
,	O
1	int
,	O
1	int
,	O
*	O
defense_point	pointer
,	O
pos	int
)	O
)	O
find_defense	function
(	O
pos	int
,	O
defense_point	pointer
)	O
;	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
,	O
NO_MOVE	O
)	O
;	O
}	O
verbose	int
=	O
save_verbose	int
;	O
TRACE	O
(	O
"After %1m Worm at %1m becomes attackable.\n"	pointer
,	O
move	pointer
,	O
pos	int
)	O
;	O
verbose	int
=	O
current_verbose	int
;	O
*	O
return_value	pointer
+=	O
worm	array
[	O
pos	int
]	O
.	O
effective_size	float
;	O
if	O
(	O
safe_stones	array
)	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
worm	array
[	O
ii	int
]	O
.	O
origin	int
==	O
worm	array
[	O
pos	int
]	O
.	O
origin	int
)	O
safe_stones	array
[	O
ii	int
]	O
=	O
0	int
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
other	int
&&	O
worm	array
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
&&	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array
[	O
pos	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
&&	O
find_defense	function
(	O
pos	int
,	O
NULL	O
)	O
)	O
{	O
int	O
owl_attacks	int
;	O
int	O
defense_effective	int
=	O
0	int
;	O
popgo	function
(	O
)	O
;	O
decrease_depth_values	function
(	O
)	O
;	O
owl_attacks	int
=	O
owl_does_attack	function
(	O
move	pointer
,	O
pos	int
,	O
NULL	O
)	O
;	O
if	O
(	O
owl_attacks	int
!=	O
WIN	int
)	O
{	O
*	O
return_value	pointer
+=	O
2	int
*	O
worm	array
[	O
pos	int
]	O
.	O
effective_size	float
;	O
defense_effective	int
=	O
1	int
;	O
verbose	int
=	O
save_verbose	int
;	O
TRACE	O
(	O
"After %1m worm at %1m becomes defendable - A.\n"	pointer
,	O
move	pointer
,	O
pos	int
)	O
;	O
verbose	int
=	O
current_verbose	int
;	O
}	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
!=	O
ALIVE	int
)	O
{	O
int	O
k	int
;	O
int	O
adj	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
num_adj	pointer
;	O
num_adj	pointer
=	O
extended_chainlinks	function
(	O
pos	int
,	O
adj	array
,	O
0	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_adj	pointer
;	O
k	int
++	O
)	O
{	O
int	O
neighbor	int
=	O
adj	array
[	O
k	int
]	O
;	O
int	O
resulta	pointer
;	O
owl_analyze_semeai_after_move	function
(	O
move	pointer
,	O
color	int
,	O
pos	int
,	O
neighbor	int
,	O
&	O
resulta	pointer
,	O
NULL	O
,	O
NULL	O
,	O
1	int
,	O
NULL	O
,	O
1	int
)	O
;	O
if	O
(	O
resulta	pointer
!=	O
0	int
)	O
{	O
*	O
return_value	pointer
+=	O
2	int
*	O
worm	array
[	O
pos	int
]	O
.	O
effective_size	float
;	O
defense_effective	int
=	O
1	int
;	O
verbose	int
=	O
save_verbose	int
;	O
TRACE	O
(	O
"After %1m worm at %1m becomes defendable - B.\n"	pointer
,	O
move	pointer
,	O
pos	int
)	O
;	O
verbose	int
=	O
current_verbose	int
;	O
break	O
;	O
}	O
}	O
}	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
,	O
NO_MOVE	O
)	O
;	O
increase_depth_values	function
(	O
)	O
;	O
if	O
(	O
defense_effective	int
&&	O
defense_point	pointer
)	O
{	O
int	O
dpos	int
;	O
if	O
(	O
attack	function
(	O
pos	int
,	O
&	O
dpos	int
)	O
)	O
{	O
*	O
defense_point	pointer
=	O
dpos	int
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
!	O
is_legal	function
(	O
dpos	int
,	O
color	int
)	O
||	O
play_attack_defend_n	function
(	O
color	int
,	O
0	int
,	O
1	int
,	O
dpos	int
,	O
pos	int
)	O
)	O
attack	function
(	O
pos	int
,	O
defense_point	pointer
)	O
;	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
,	O
NO_MOVE	O
)	O
;	O
}	O
else	O
{	O
verbose	int
=	O
save_verbose	int
;	O
TRACE	O
(	O
"No attack found (unexpectedly) on %1m after move at %1m.\n"	pointer
,	O
pos	int
,	O
move	pointer
)	O
;	O
verbose	int
=	O
current_verbose	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
liberties	pointer
==	O
2	int
)	O
{	O
float	O
d_a_blunder_size	float
;	O
if	O
(	O
double_atari	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
other	int
,	O
&	O
d_a_blunder_size	float
,	O
safe_stones	array
)	O
)	O
{	O
if	O
(	O
defense_point	pointer
&&	O
safe_move	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
color	int
)	O
==	O
WIN	int
)	O
*	O
defense_point	pointer
=	O
libs	pointer
[	O
0	int
]	O
;	O
*	O
return_value	pointer
+=	O
d_a_blunder_size	float
;	O
verbose	int
=	O
save_verbose	int
;	O
TRACE	O
(	O
"Double threat appears at %1m.\n"	pointer
,	O
libs	pointer
[	O
0	int
]	O
)	O
;	O
verbose	int
=	O
current_verbose	int
;	O
}	O
else	O
if	O
(	O
double_atari	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
other	int
,	O
&	O
d_a_blunder_size	float
,	O
safe_stones	array
)	O
)	O
{	O
if	O
(	O
defense_point	pointer
&&	O
safe_move	function
(	O
libs	pointer
[	O
1	int
]	O
,	O
color	int
)	O
==	O
WIN	int
)	O
*	O
defense_point	pointer
=	O
libs	pointer
[	O
1	int
]	O
;	O
*	O
return_value	pointer
+=	O
d_a_blunder_size	float
;	O
verbose	int
=	O
save_verbose	int
;	O
TRACE	O
(	O
"Double threat appears at %1m.\n"	pointer
,	O
libs	pointer
[	O
1	int
]	O
)	O
;	O
verbose	int
=	O
current_verbose	int
;	O
}	O
}	O
decrease_depth_values	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
int	O
double_atari	function
(	O
int	O
move	pointer
,	O
int	O
color	int
,	O
float	O
*	O
value	pointer
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
int	O
m	int
=	O
I	O
(	O
move	pointer
)	O
;	O
int	O
n	int
=	O
J	O
(	O
move	pointer
)	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
move	pointer
)	O
)	O
return	O
0	int
;	O
for	O
(	O
k	int
=	O
4	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
int	O
dm	int
=	O
deltai	array
[	O
k	int
]	O
;	O
int	O
dn	int
=	O
deltaj	array
[	O
k	int
]	O
;	O
if	O
(	O
BOARD	O
(	O
m	int
+	O
dm	int
,	O
n	int
+	O
dn	int
)	O
==	O
color	int
&&	O
BOARD	O
(	O
m	int
,	O
n	int
+	O
dn	int
)	O
==	O
other	int
&&	O
BOARD	O
(	O
m	int
+	O
dm	int
,	O
n	int
)	O
==	O
other	int
&&	O
(	O
!	O
safe_stones	array
||	O
(	O
safe_stones	array
[	O
POS	O
(	O
m	int
,	O
n	int
+	O
dn	int
)	O
]	O
&&	O
safe_stones	array
[	O
POS	O
(	O
m	int
+	O
dm	int
,	O
n	int
)	O
]	O
)	O
)	O
&&	O
trymove	function
(	O
move	pointer
,	O
color	int
,	O
"double_atari"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
countlib	function
(	O
move	pointer
)	O
>	O
1	int
&&	O
(	O
BOARD	O
(	O
m	int
,	O
n	int
+	O
dn	int
)	O
==	O
EMPTY	int
||	O
BOARD	O
(	O
m	int
+	O
dm	int
,	O
n	int
)	O
==	O
EMPTY	int
||	O
!	O
defend_both	function
(	O
POS	O
(	O
m	int
,	O
n	int
+	O
dn	int
)	O
,	O
POS	O
(	O
m	int
+	O
dm	int
,	O
n	int
)	O
)	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
if	O
(	O
value	pointer
)	O
{	O
if	O
(	O
worm	array
[	O
POS	O
(	O
m	int
,	O
n	int
+	O
dn	int
)	O
]	O
.	O
effective_size	float
>	O
worm	array
[	O
POS	O
(	O
m	int
+	O
dm	int
,	O
n	int
)	O
]	O
.	O
effective_size	float
)	O
{	O
*	O
value	pointer
=	O
2.0	int
*	O
worm	array
[	O
POS	O
(	O
m	int
,	O
n	int
+	O
dn	int
)	O
]	O
.	O
effective_size	float
;	O
if	O
(	O
safe_stones	array
)	O
mark_string	function
(	O
POS	O
(	O
m	int
,	O
n	int
+	O
dn	int
)	O
,	O
safe_stones	array
,	O
0	int
)	O
;	O
}	O
else	O
{	O
*	O
value	pointer
=	O
2.0	int
*	O
worm	array
[	O
POS	O
(	O
m	int
+	O
dm	int
,	O
n	int
)	O
]	O
.	O
effective_size	float
;	O
if	O
(	O
safe_stones	array
)	O
mark_string	function
(	O
POS	O
(	O
m	int
+	O
dm	int
,	O
n	int
)	O
,	O
safe_stones	array
,	O
0	int
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
playing_into_snapback	function
(	O
int	O
move	pointer
,	O
int	O
color	int
)	O
{	O
int	O
libs	pointer
[	O
2	int
]	O
;	O
int	O
k	int
;	O
if	O
(	O
approxlib	function
(	O
move	pointer
,	O
color	int
,	O
1	int
,	O
NULL	O
)	O
!=	O
0	int
||	O
accuratelib	function
(	O
move	pointer
,	O
color	int
,	O
2	int
,	O
libs	pointer
)	O
!=	O
1	int
)	O
return	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	pointer
[	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
color	int
&&	O
adjacent_strings	function
(	O
libs	pointer
[	O
0	int
]	O
,	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
who_wins	function
(	O
int	O
color	int
,	O
FILE	struct
*	O
outfile	pointer
)	O
{	O
float	O
result	int
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS	int
)	O
;	O
if	O
(	O
color	int
!=	O
BLACK	int
&&	O
color	int
!=	O
WHITE	int
)	O
color	int
=	O
BLACK	int
;	O
result	int
=	O
(	O
white_score	float
+	O
black_score	float
)	O
/	O
2.0	int
;	O
if	O
(	O
result	int
==	O
0.0	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
"Result: jigo   "	pointer
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
"Result: %c+%.1f   "	pointer
,	O
(	O
result	int
>	O
0.0	int
)	O
?	O
'W'	O
:	O
'B'	O
,	O
gg_abs	O
(	O
result	int
)	O
)	O
;	O
}	O
static	O
void	O
do_find_superstring	function
(	O
int	O
str	int
,	O
int	O
*	O
num_stones	int
,	O
int	O
*	O
stones	pointer
,	O
int	O
*	O
num_lib	pointer
,	O
int	O
*	O
libs	pointer
,	O
int	O
maxlibs	int
,	O
int	O
*	O
num_adj	pointer
,	O
int	O
*	O
adjs	pointer
,	O
int	O
liberty_cap	int
,	O
int	O
proper	int
,	O
int	O
type	char
)	O
;	O
static	O
void	O
superstring_add_string	function
(	O
int	O
str	int
,	O
int	O
*	O
num_my_stones	pointer
,	O
int	O
*	O
my_stones	pointer
,	O
int	O
*	O
num_stones	int
,	O
int	O
*	O
stones	pointer
,	O
int	O
*	O
num_libs	pointer
,	O
int	O
*	O
libs	pointer
,	O
int	O
maxlibs	int
,	O
int	O
*	O
num_adj	pointer
,	O
int	O
*	O
adjs	pointer
,	O
int	O
liberty_cap	int
,	O
signed	O
char	O
mx	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
ml	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
ma	array
[	O
BOARDMAX	O
]	O
,	O
int	O
do_add	int
)	O
;	O
void	O
find_superstring	function
(	O
int	O
str	int
,	O
int	O
*	O
num_stones	int
,	O
int	O
*	O
stones	pointer
)	O
{	O
do_find_superstring	function
(	O
str	int
,	O
num_stones	int
,	O
stones	pointer
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
1	int
)	O
;	O
}	O
void	O
find_superstring_conservative	function
(	O
int	O
str	int
,	O
int	O
*	O
num_stones	int
,	O
int	O
*	O
stones	pointer
)	O
{	O
do_find_superstring	function
(	O
str	int
,	O
num_stones	int
,	O
stones	pointer
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
void	O
find_superstring_liberties	function
(	O
int	O
str	int
,	O
int	O
*	O
num_libs	pointer
,	O
int	O
*	O
libs	pointer
,	O
int	O
liberty_cap	int
)	O
{	O
do_find_superstring	function
(	O
str	int
,	O
NULL	O
,	O
NULL	O
,	O
num_libs	pointer
,	O
libs	pointer
,	O
MAX_LIBERTIES	int
,	O
NULL	O
,	O
NULL	O
,	O
liberty_cap	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
void	O
find_proper_superstring_liberties	function
(	O
int	O
str	int
,	O
int	O
*	O
num_libs	pointer
,	O
int	O
*	O
libs	pointer
,	O
int	O
liberty_cap	int
)	O
{	O
do_find_superstring	function
(	O
str	int
,	O
NULL	O
,	O
NULL	O
,	O
num_libs	pointer
,	O
libs	pointer
,	O
MAX_LIBERTIES	int
,	O
NULL	O
,	O
NULL	O
,	O
liberty_cap	int
,	O
1	int
,	O
0	int
)	O
;	O
}	O
void	O
find_superstring_stones_and_liberties	function
(	O
int	O
str	int
,	O
int	O
*	O
num_stones	int
,	O
int	O
*	O
stones	pointer
,	O
int	O
*	O
num_libs	pointer
,	O
int	O
*	O
libs	pointer
,	O
int	O
liberty_cap	int
)	O
{	O
do_find_superstring	function
(	O
str	int
,	O
num_stones	int
,	O
stones	pointer
,	O
num_libs	pointer
,	O
libs	pointer
,	O
MAX_LIBERTIES	int
,	O
NULL	O
,	O
NULL	O
,	O
liberty_cap	int
,	O
0	int
,	O
0	int
)	O
;	O
}	O
void	O
superstring_chainlinks	function
(	O
int	O
str	int
,	O
int	O
*	O
num_adj	pointer
,	O
int	O
adjs	pointer
[	O
MAXCHAIN	int
]	O
,	O
int	O
liberty_cap	int
)	O
{	O
do_find_superstring	function
(	O
str	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
num_adj	pointer
,	O
adjs	pointer
,	O
liberty_cap	int
,	O
0	int
,	O
2	int
)	O
;	O
}	O
void	O
proper_superstring_chainlinks	function
(	O
int	O
str	int
,	O
int	O
*	O
num_adj	pointer
,	O
int	O
adjs	pointer
[	O
MAXCHAIN	int
]	O
,	O
int	O
liberty_cap	int
)	O
{	O
do_find_superstring	function
(	O
str	int
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
,	O
0	int
,	O
num_adj	pointer
,	O
adjs	pointer
,	O
liberty_cap	int
,	O
1	int
,	O
2	int
)	O
;	O
}	O
static	O
void	O
do_find_superstring	function
(	O
int	O
str	int
,	O
int	O
*	O
num_stones	int
,	O
int	O
*	O
stones	pointer
,	O
int	O
*	O
num_libs	pointer
,	O
int	O
*	O
libs	pointer
,	O
int	O
maxlibs	int
,	O
int	O
*	O
num_adj	pointer
,	O
int	O
*	O
adjs	pointer
,	O
int	O
liberty_cap	int
,	O
int	O
proper	int
,	O
int	O
type	char
)	O
{	O
int	O
num_my_stones	pointer
;	O
int	O
my_stones	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
signed	O
char	O
mx	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
ml	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
ma	array
[	O
BOARDMAX	O
]	O
;	O
int	O
k	int
,	O
l	int
,	O
r	int
;	O
int	O
color	int
=	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
memset	function
(	O
mx	array
,	O
0	int
,	O
sizeof	O
(	O
mx	array
)	O
)	O
;	O
memset	function
(	O
ml	array
,	O
0	int
,	O
sizeof	O
(	O
ml	array
)	O
)	O
;	O
memset	function
(	O
ma	array
,	O
0	int
,	O
sizeof	O
(	O
ma	array
)	O
)	O
;	O
if	O
(	O
num_stones	int
)	O
*	O
num_stones	int
=	O
0	int
;	O
if	O
(	O
num_libs	pointer
)	O
*	O
num_libs	pointer
=	O
0	int
;	O
if	O
(	O
num_adj	pointer
)	O
*	O
num_adj	pointer
=	O
0	int
;	O
num_my_stones	pointer
=	O
0	int
;	O
superstring_add_string	function
(	O
str	int
,	O
&	O
num_my_stones	pointer
,	O
my_stones	pointer
,	O
num_stones	int
,	O
stones	pointer
,	O
num_libs	pointer
,	O
libs	pointer
,	O
maxlibs	int
,	O
num_adj	pointer
,	O
adjs	pointer
,	O
liberty_cap	int
,	O
mx	array
,	O
ml	array
,	O
ma	array
,	O
!	O
proper	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_my_stones	pointer
;	O
r	int
++	O
)	O
{	O
int	O
pos	int
=	O
my_stones	pointer
[	O
r	int
]	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
right	int
=	O
delta	array
[	O
k	int
]	O
;	O
int	O
up	int
=	O
delta	array
[	O
(	O
k	int
+	O
1	int
)	O
%	O
4	int
]	O
;	O
int	O
apos	int
=	O
pos	int
+	O
right	int
;	O
int	O
bpos	int
=	O
pos	int
+	O
right	int
+	O
up	int
;	O
int	O
cpos	int
=	O
pos	int
+	O
2	int
*	O
right	int
;	O
int	O
dpos	int
=	O
pos	int
+	O
right	int
-	O
up	int
;	O
int	O
epos	int
=	O
pos	int
+	O
2	int
*	O
up	int
;	O
int	O
fpos	int
=	O
pos	int
+	O
right	int
+	O
2	int
*	O
up	int
;	O
int	O
gpos	int
=	O
pos	int
+	O
up	int
;	O
int	O
unsafe_move	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
apos	int
)	O
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
type	char
==	O
2	int
)	O
unsafe_move	int
=	O
(	O
approxlib	function
(	O
apos	int
,	O
other	int
,	O
2	int
,	O
NULL	O
)	O
<	O
2	int
)	O
;	O
else	O
unsafe_move	int
=	O
is_self_atari	function
(	O
apos	int
,	O
other	int
)	O
;	O
if	O
(	O
unsafe_move	int
&&	O
type	char
==	O
1	int
&&	O
is_ko	function
(	O
apos	int
,	O
other	int
,	O
NULL	O
)	O
)	O
unsafe_move	int
=	O
0	int
;	O
if	O
(	O
unsafe_move	int
)	O
{	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
color	int
&&	O
!	O
mx	array
[	O
bpos	int
]	O
)	O
superstring_add_string	function
(	O
bpos	int
,	O
&	O
num_my_stones	pointer
,	O
my_stones	pointer
,	O
num_stones	int
,	O
stones	pointer
,	O
num_libs	pointer
,	O
libs	pointer
,	O
maxlibs	int
,	O
num_adj	pointer
,	O
adjs	pointer
,	O
liberty_cap	int
,	O
mx	array
,	O
ml	array
,	O
ma	array
,	O
1	int
)	O
;	O
if	O
(	O
board	pointer
[	O
cpos	int
]	O
==	O
color	int
&&	O
!	O
mx	array
[	O
cpos	int
]	O
)	O
superstring_add_string	function
(	O
cpos	int
,	O
&	O
num_my_stones	pointer
,	O
my_stones	pointer
,	O
num_stones	int
,	O
stones	pointer
,	O
num_libs	pointer
,	O
libs	pointer
,	O
maxlibs	int
,	O
num_adj	pointer
,	O
adjs	pointer
,	O
liberty_cap	int
,	O
mx	array
,	O
ml	array
,	O
ma	array
,	O
1	int
)	O
;	O
if	O
(	O
board	pointer
[	O
dpos	int
]	O
==	O
color	int
&&	O
!	O
mx	array
[	O
dpos	int
]	O
)	O
superstring_add_string	function
(	O
dpos	int
,	O
&	O
num_my_stones	pointer
,	O
my_stones	pointer
,	O
num_stones	int
,	O
stones	pointer
,	O
num_libs	pointer
,	O
libs	pointer
,	O
maxlibs	int
,	O
num_adj	pointer
,	O
adjs	pointer
,	O
liberty_cap	int
,	O
mx	array
,	O
ml	array
,	O
ma	array
,	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
board	pointer
[	O
apos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
bpos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
fpos	int
]	O
==	O
color	int
&&	O
board	pointer
[	O
epos	int
]	O
==	O
color	int
&&	O
!	O
mx	array
[	O
epos	int
]	O
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
)	O
superstring_add_string	function
(	O
epos	int
,	O
&	O
num_my_stones	pointer
,	O
my_stones	pointer
,	O
num_stones	int
,	O
stones	pointer
,	O
num_libs	pointer
,	O
libs	pointer
,	O
maxlibs	int
,	O
num_adj	pointer
,	O
adjs	pointer
,	O
liberty_cap	int
,	O
mx	array
,	O
ml	array
,	O
ma	array
,	O
1	int
)	O
;	O
if	O
(	O
board	pointer
[	O
bpos	int
]	O
==	O
color	int
&&	O
!	O
mx	array
[	O
bpos	int
]	O
&&	O
board	pointer
[	O
apos	int
]	O
==	O
EMPTY	int
&&	O
board	pointer
[	O
gpos	int
]	O
==	O
EMPTY	int
)	O
superstring_add_string	function
(	O
bpos	int
,	O
&	O
num_my_stones	pointer
,	O
my_stones	pointer
,	O
num_stones	int
,	O
stones	pointer
,	O
num_libs	pointer
,	O
libs	pointer
,	O
maxlibs	int
,	O
num_adj	pointer
,	O
adjs	pointer
,	O
liberty_cap	int
,	O
mx	array
,	O
ml	array
,	O
ma	array
,	O
1	int
)	O
;	O
if	O
(	O
type	char
==	O
1	int
)	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
2	int
;	O
l	int
++	O
)	O
{	O
int	O
upos	int
;	O
if	O
(	O
l	int
==	O
0	int
)	O
{	O
upos	int
=	O
apos	int
;	O
}	O
else	O
{	O
upos	int
=	O
bpos	int
;	O
}	O
if	O
(	O
board	pointer
[	O
upos	int
]	O
!=	O
other	int
)	O
continue	O
;	O
upos	int
=	O
find_origin	function
(	O
upos	int
)	O
;	O
if	O
(	O
mx	array
[	O
upos	int
]	O
==	O
1	int
)	O
continue	O
;	O
mx	array
[	O
upos	int
]	O
=	O
1	int
;	O
if	O
(	O
attack	function
(	O
upos	int
,	O
NULL	O
)	O
&&	O
!	O
find_defense	function
(	O
upos	int
,	O
NULL	O
)	O
)	O
{	O
int	O
lunch_stones	array
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
int	O
num_lunch_stones	int
=	O
findstones	function
(	O
upos	int
,	O
MAX_BOARD	int
*	O
MAX_BOARD	int
,	O
lunch_stones	array
)	O
;	O
int	O
m	int
,	O
n	int
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
num_lunch_stones	int
;	O
m	int
++	O
)	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
8	int
;	O
n	int
++	O
)	O
{	O
int	O
vpos	int
=	O
lunch_stones	array
[	O
m	int
]	O
+	O
delta	array
[	O
n	int
]	O
;	O
if	O
(	O
board	pointer
[	O
vpos	int
]	O
==	O
color	int
&&	O
!	O
mx	array
[	O
vpos	int
]	O
)	O
superstring_add_string	function
(	O
vpos	int
,	O
&	O
num_my_stones	pointer
,	O
my_stones	pointer
,	O
num_stones	int
,	O
stones	pointer
,	O
num_libs	pointer
,	O
libs	pointer
,	O
maxlibs	int
,	O
num_adj	pointer
,	O
adjs	pointer
,	O
liberty_cap	int
,	O
mx	array
,	O
ml	array
,	O
ma	array
,	O
1	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
num_libs	pointer
&&	O
maxlibs	int
>	O
0	int
&&	O
*	O
num_libs	pointer
>=	O
maxlibs	int
)	O
return	O
;	O
}	O
}	O
}	O
static	O
void	O
superstring_add_string	function
(	O
int	O
str	int
,	O
int	O
*	O
num_my_stones	pointer
,	O
int	O
*	O
my_stones	pointer
,	O
int	O
*	O
num_stones	int
,	O
int	O
*	O
stones	pointer
,	O
int	O
*	O
num_libs	pointer
,	O
int	O
*	O
libs	pointer
,	O
int	O
maxlibs	int
,	O
int	O
*	O
num_adj	pointer
,	O
int	O
*	O
adjs	pointer
,	O
int	O
liberty_cap	int
,	O
signed	O
char	O
mx	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
ml	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
ma	array
[	O
BOARDMAX	O
]	O
,	O
int	O
do_add	int
)	O
{	O
int	O
num_my_libs	int
;	O
int	O
my_libs	array
[	O
MAXLIBS	O
]	O
;	O
int	O
num_my_adj	int
;	O
int	O
my_adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
new_stones	int
;	O
int	O
k	int
;	O
ASSERT1	O
(	O
mx	array
[	O
str	int
]	O
==	O
0	int
,	O
str	int
)	O
;	O
new_stones	int
=	O
findstones	function
(	O
str	int
,	O
board_size	int
*	O
board_size	int
,	O
&	O
(	O
my_stones	pointer
[	O
*	O
num_my_stones	pointer
]	O
)	O
)	O
;	O
mark_string	function
(	O
str	int
,	O
mx	array
,	O
1	int
)	O
;	O
if	O
(	O
stones	pointer
)	O
{	O
gg_assert	O
(	O
num_stones	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
new_stones	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
do_add	int
)	O
{	O
stones	pointer
[	O
*	O
num_stones	int
]	O
=	O
my_stones	pointer
[	O
*	O
num_my_stones	pointer
+	O
k	int
]	O
;	O
(	O
*	O
num_stones	int
)	O
++	O
;	O
}	O
}	O
}	O
(	O
*	O
num_my_stones	pointer
)	O
+=	O
new_stones	int
;	O
if	O
(	O
libs	pointer
)	O
{	O
gg_assert	O
(	O
num_libs	pointer
)	O
;	O
num_my_libs	int
=	O
findlib	function
(	O
str	int
,	O
MAXLIBS	O
,	O
my_libs	array
)	O
;	O
if	O
(	O
liberty_cap	int
>	O
0	int
&&	O
num_my_libs	int
>	O
liberty_cap	int
)	O
(	O
*	O
num_my_stones	pointer
)	O
-=	O
new_stones	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_my_libs	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
ml	array
[	O
my_libs	array
[	O
k	int
]	O
]	O
)	O
continue	O
;	O
ml	array
[	O
my_libs	array
[	O
k	int
]	O
]	O
=	O
1	int
;	O
if	O
(	O
do_add	int
&&	O
(	O
liberty_cap	int
==	O
0	int
||	O
num_my_libs	int
<=	O
liberty_cap	int
)	O
)	O
{	O
libs	pointer
[	O
*	O
num_libs	pointer
]	O
=	O
my_libs	array
[	O
k	int
]	O
;	O
(	O
*	O
num_libs	pointer
)	O
++	O
;	O
if	O
(	O
*	O
num_libs	pointer
==	O
maxlibs	int
)	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
adjs	pointer
)	O
{	O
gg_assert	O
(	O
num_adj	pointer
)	O
;	O
num_my_adj	int
=	O
chainlinks	function
(	O
str	int
,	O
my_adjs	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_my_adj	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
liberty_cap	int
>	O
0	int
&&	O
countlib	function
(	O
my_adjs	array
[	O
k	int
]	O
)	O
>	O
liberty_cap	int
)	O
continue	O
;	O
if	O
(	O
ma	array
[	O
my_adjs	array
[	O
k	int
]	O
]	O
)	O
continue	O
;	O
ma	array
[	O
my_adjs	array
[	O
k	int
]	O
]	O
=	O
1	int
;	O
if	O
(	O
do_add	int
)	O
{	O
adjs	pointer
[	O
*	O
num_adj	pointer
]	O
=	O
my_adjs	array
[	O
k	int
]	O
;	O
(	O
*	O
num_adj	pointer
)	O
++	O
;	O
}	O
}	O
}	O
}	O
static	O
double	O
timers	array
[	O
NUMBER_OF_TIMERS	int
]	O
;	O
void	O
start_timer	function
(	O
int	O
n	int
)	O
{	O
gg_assert	O
(	O
n	int
>=	O
0	int
&&	O
n	int
<	O
NUMBER_OF_TIMERS	int
)	O
;	O
if	O
(	O
!	O
showtime	int
)	O
return	O
;	O
timers	array
[	O
n	int
]	O
=	O
gg_cputime	function
(	O
)	O
;	O
}	O
double	O
time_report	function
(	O
int	O
n	int
,	O
const	O
char	O
*	O
occupation	pointer
,	O
int	O
move	pointer
,	O
double	O
mintime	double
)	O
{	O
double	O
t	double
;	O
double	O
dt	double
;	O
gg_assert	O
(	O
n	int
>=	O
0	int
&&	O
n	int
<	O
NUMBER_OF_TIMERS	int
)	O
;	O
if	O
(	O
!	O
showtime	int
)	O
return	O
0.0	int
;	O
t	double
=	O
gg_cputime	function
(	O
)	O
;	O
dt	double
=	O
t	double
-	O
timers	array
[	O
n	int
]	O
;	O
if	O
(	O
dt	double
>	O
mintime	double
)	O
{	O
gprintf	function
(	O
"%s"	pointer
,	O
occupation	pointer
)	O
;	O
if	O
(	O
move	pointer
!=	O
NO_MOVE	O
)	O
gprintf	function
(	O
"%1m"	pointer
,	O
move	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
": %.2f sec\n"	pointer
,	O
dt	double
)	O
;	O
}	O
timers	array
[	O
n	int
]	O
=	O
t	double
;	O
return	O
dt	double
;	O
}	O
void	O
clearstats	function
(	O
)	O
{	O
stats	struct
.	O
nodes	int
=	O
0	int
;	O
stats	struct
.	O
read_result_entered	int
=	O
0	int
;	O
stats	struct
.	O
read_result_hits	int
=	O
0	int
;	O
stats	struct
.	O
trusted_read_result_hits	int
=	O
0	int
;	O
}	O
void	O
showstats	function
(	O
)	O
{	O
gprintf	function
(	O
"Nodes:                    %d\n"	pointer
,	O
stats	struct
.	O
nodes	int
)	O
;	O
gprintf	function
(	O
"Read results entered:     %d\n"	pointer
,	O
stats	struct
.	O
read_result_entered	int
)	O
;	O
gprintf	function
(	O
"Read result hits:         %d\n"	pointer
,	O
stats	struct
.	O
read_result_hits	int
)	O
;	O
gprintf	function
(	O
"Trusted read result hits: %d\n"	pointer
,	O
stats	struct
.	O
trusted_read_result_hits	int
)	O
;	O
}	O
int	O
choose_mc_patterns	function
(	O
char	O
*	O
name	short
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
mc_pattern_databases	array
[	O
k	int
]	O
.	O
name	short
;	O
k	int
++	O
)	O
{	O
if	O
(	O
!	O
name	short
||	O
strcmp	function
(	O
name	short
,	O
mc_pattern_databases	array
[	O
k	int
]	O
.	O
name	short
)	O
==	O
0	int
)	O
{	O
mc_init_patterns	function
(	O
mc_pattern_databases	array
[	O
k	int
]	O
.	O
values	array
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
void	O
list_mc_patterns	function
(	O
void	O
)	O
{	O
int	O
k	int
;	O
printf	function
(	O
"Available builtin Monte Carlo local patterns:\n\n"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
mc_pattern_databases	array
[	O
k	int
]	O
.	O
name	short
;	O
k	int
++	O
)	O
{	O
if	O
(	O
k	int
==	O
0	int
)	O
printf	function
(	O
"* %s (default)\n"	pointer
,	O
mc_pattern_databases	array
[	O
k	int
]	O
.	O
name	short
)	O
;	O
else	O
printf	function
(	O
"* %s\n"	pointer
,	O
mc_pattern_databases	array
[	O
k	int
]	O
.	O
name	short
)	O
;	O
}	O
printf	function
(	O
"\nUse \"--mc-patterns name\" to choose one of these.\n"	pointer
)	O
;	O
printf	function
(	O
"Use \"--mc-load-patterns filename\" to directly load a pattern database.\n"	pointer
)	O
;	O
}	O
