void	O
*	O
ap_resize_buffer	function
(	O
void	O
*	O
buf	pointer
,	O
const	O
int	O
min_size	int
)	O
{	O
if	O
(	O
buf	pointer
)	O
buf	pointer
=	O
realloc	function
(	O
buf	pointer
,	O
min_size	int
)	O
;	O
else	O
buf	pointer
=	O
malloc	function
(	O
min_size	int
)	O
;	O
return	O
buf	pointer
;	O
}	O
char	O
push_back_record	function
(	O
Arg_parser	struct
*	O
ap	pointer
,	O
const	O
int	O
code	int
,	O
const	O
char	O
*	O
argument	pointer
)	O
{	O
const	O
int	O
len	int
=	O
strlen	function
(	O
argument	pointer
)	O
;	O
ap_Record	struct
*	O
p	pointer
;	O
void	O
*	O
tmp	pointer
=	O
ap_resize_buffer	function
(	O
ap	pointer
->	O
data	pointer
,	O
(	O
ap	pointer
->	O
data_size	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
ap_Record	struct
)	O
)	O
;	O
if	O
(	O
!	O
tmp	pointer
)	O
return	O
0	int
;	O
ap	pointer
->	O
data	pointer
=	O
(	O
ap_Record	struct
*	O
)	O
tmp	pointer
;	O
p	pointer
=	O
&	O
(	O
ap	pointer
->	O
data	pointer
[	O
ap	pointer
->	O
data_size	int
]	O
)	O
;	O
p	pointer
->	O
code	int
=	O
code	int
;	O
p	pointer
->	O
argument	pointer
=	O
0	int
;	O
tmp	pointer
=	O
ap_resize_buffer	function
(	O
p	pointer
->	O
argument	pointer
,	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
tmp	pointer
)	O
return	O
0	int
;	O
p	pointer
->	O
argument	pointer
=	O
(	O
char	O
*	O
)	O
tmp	pointer
;	O
strncpy	function
(	O
p	pointer
->	O
argument	pointer
,	O
argument	pointer
,	O
len	int
+	O
1	int
)	O
;	O
++	O
ap	pointer
->	O
data_size	int
;	O
return	O
1	int
;	O
}	O
char	O
add_error	function
(	O
Arg_parser	struct
*	O
ap	pointer
,	O
const	O
char	O
*	O
msg	pointer
)	O
{	O
const	O
int	O
len	int
=	O
strlen	function
(	O
msg	pointer
)	O
;	O
void	O
*	O
tmp	pointer
=	O
ap_resize_buffer	function
(	O
ap	pointer
->	O
error	pointer
,	O
ap	pointer
->	O
error_size	int
+	O
len	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
tmp	pointer
)	O
return	O
0	int
;	O
ap	pointer
->	O
error	pointer
=	O
(	O
char	O
*	O
)	O
tmp	pointer
;	O
strncpy	function
(	O
ap	pointer
->	O
error	pointer
+	O
ap	pointer
->	O
error_size	int
,	O
msg	pointer
,	O
len	int
+	O
1	int
)	O
;	O
ap	pointer
->	O
error_size	int
+=	O
len	int
;	O
return	O
1	int
;	O
}	O
void	O
free_data	function
(	O
Arg_parser	struct
*	O
ap	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ap	pointer
->	O
data_size	int
;	O
++	O
i	int
)	O
free	function
(	O
ap	pointer
->	O
data	pointer
[	O
i	int
]	O
.	O
argument	pointer
)	O
;	O
if	O
(	O
ap	pointer
->	O
data	pointer
)	O
{	O
free	function
(	O
ap	pointer
->	O
data	pointer
)	O
;	O
ap	pointer
->	O
data	pointer
=	O
0	int
;	O
}	O
ap	pointer
->	O
data_size	int
=	O
0	int
;	O
}	O
char	O
parse_long_option	function
(	O
Arg_parser	struct
*	O
ap	pointer
,	O
const	O
char	O
*	O
const	O
opt	pointer
,	O
const	O
char	O
*	O
const	O
arg	pointer
,	O
const	O
ap_Option	struct
options	array
[	O
]	O
,	O
int	O
*	O
argindp	pointer
)	O
{	O
unsigned	O
int	O
len	int
;	O
int	O
index	function
=	O
-	O
1	int
;	O
int	O
i	int
;	O
char	O
exact	char
=	O
0	int
,	O
ambig	char
=	O
0	int
;	O
for	O
(	O
len	int
=	O
0	int
;	O
opt	pointer
[	O
len	int
+	O
2	int
]	O
&&	O
opt	pointer
[	O
len	int
+	O
2	int
]	O
!=	O
'='	O
;	O
++	O
len	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
options	array
[	O
i	int
]	O
.	O
code	int
!=	O
0	int
;	O
++	O
i	int
)	O
if	O
(	O
options	array
[	O
i	int
]	O
.	O
name	pointer
&&	O
!	O
strncmp	function
(	O
options	array
[	O
i	int
]	O
.	O
name	pointer
,	O
&	O
opt	pointer
[	O
2	int
]	O
,	O
len	int
)	O
)	O
{	O
if	O
(	O
strlen	function
(	O
options	array
[	O
i	int
]	O
.	O
name	pointer
)	O
==	O
len	int
)	O
{	O
index	function
=	O
i	int
;	O
exact	char
=	O
1	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
index	function
<	O
0	int
)	O
index	function
=	O
i	int
;	O
else	O
if	O
(	O
options	array
[	O
index	function
]	O
.	O
code	int
!=	O
options	array
[	O
i	int
]	O
.	O
code	int
||	O
options	array
[	O
index	function
]	O
.	O
has_arg	enum
!=	O
options	array
[	O
i	int
]	O
.	O
has_arg	enum
)	O
ambig	char
=	O
1	int
;	O
}	O
if	O
(	O
ambig	char
&&	O
!	O
exact	char
)	O
{	O
add_error	function
(	O
ap	pointer
,	O
"option `"	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
opt	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
"' is ambiguous"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
index	function
<	O
0	int
)	O
{	O
add_error	function
(	O
ap	pointer
,	O
"unrecognized option `"	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
opt	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
"'"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
++	O
*	O
argindp	pointer
;	O
if	O
(	O
opt	pointer
[	O
len	int
+	O
2	int
]	O
)	O
{	O
if	O
(	O
options	array
[	O
index	function
]	O
.	O
has_arg	enum
==	O
ap_no	int
)	O
{	O
add_error	function
(	O
ap	pointer
,	O
"option `--"	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
options	array
[	O
index	function
]	O
.	O
name	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
"' doesn't allow an argument"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
options	array
[	O
index	function
]	O
.	O
has_arg	enum
==	O
ap_yes	int
&&	O
!	O
opt	pointer
[	O
len	int
+	O
3	int
]	O
)	O
{	O
add_error	function
(	O
ap	pointer
,	O
"option `--"	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
options	array
[	O
index	function
]	O
.	O
name	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
"' requires an argument"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
push_back_record	function
(	O
ap	pointer
,	O
options	array
[	O
index	function
]	O
.	O
code	int
,	O
&	O
opt	pointer
[	O
len	int
+	O
3	int
]	O
)	O
;	O
}	O
if	O
(	O
options	array
[	O
index	function
]	O
.	O
has_arg	enum
==	O
ap_yes	int
)	O
{	O
if	O
(	O
!	O
arg	pointer
||	O
!	O
arg	pointer
[	O
0	int
]	O
)	O
{	O
add_error	function
(	O
ap	pointer
,	O
"option `--"	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
options	array
[	O
index	function
]	O
.	O
name	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
"' requires an argument"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
++	O
*	O
argindp	pointer
;	O
return	O
push_back_record	function
(	O
ap	pointer
,	O
options	array
[	O
index	function
]	O
.	O
code	int
,	O
arg	pointer
)	O
;	O
}	O
return	O
push_back_record	function
(	O
ap	pointer
,	O
options	array
[	O
index	function
]	O
.	O
code	int
,	O
""	pointer
)	O
;	O
}	O
char	O
parse_short_option	function
(	O
Arg_parser	struct
*	O
ap	pointer
,	O
const	O
char	O
*	O
const	O
opt	pointer
,	O
const	O
char	O
*	O
const	O
arg	pointer
,	O
const	O
ap_Option	struct
options	array
[	O
]	O
,	O
int	O
*	O
argindp	pointer
)	O
{	O
int	O
cind	int
=	O
1	int
;	O
while	O
(	O
cind	int
>	O
0	int
)	O
{	O
int	O
index	function
=	O
-	O
1	int
;	O
int	O
i	int
;	O
const	O
unsigned	O
char	O
code	int
=	O
opt	pointer
[	O
cind	int
]	O
;	O
const	O
char	O
code_str	array
[	O
2	int
]	O
=	O
{	O
code	int
,	O
0	int
}	O
;	O
if	O
(	O
code	int
!=	O
0	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
options	array
[	O
i	int
]	O
.	O
code	int
;	O
++	O
i	int
)	O
if	O
(	O
code	int
==	O
options	array
[	O
i	int
]	O
.	O
code	int
)	O
{	O
index	function
=	O
i	int
;	O
break	O
;	O
}	O
if	O
(	O
index	function
<	O
0	int
)	O
{	O
add_error	function
(	O
ap	pointer
,	O
"invalid option -- "	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
code_str	array
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
opt	pointer
[	O
++	O
cind	int
]	O
==	O
0	int
)	O
{	O
++	O
*	O
argindp	pointer
;	O
cind	int
=	O
0	int
;	O
}	O
if	O
(	O
options	array
[	O
index	function
]	O
.	O
has_arg	enum
!=	O
ap_no	int
&&	O
cind	int
>	O
0	int
&&	O
opt	pointer
[	O
cind	int
]	O
)	O
{	O
if	O
(	O
!	O
push_back_record	function
(	O
ap	pointer
,	O
code	int
,	O
&	O
opt	pointer
[	O
cind	int
]	O
)	O
)	O
return	O
0	int
;	O
++	O
*	O
argindp	pointer
;	O
cind	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
options	array
[	O
index	function
]	O
.	O
has_arg	enum
==	O
ap_yes	int
)	O
{	O
if	O
(	O
!	O
arg	pointer
||	O
!	O
arg	pointer
[	O
0	int
]	O
)	O
{	O
add_error	function
(	O
ap	pointer
,	O
"option requires an argument -- "	pointer
)	O
;	O
add_error	function
(	O
ap	pointer
,	O
code_str	array
)	O
;	O
return	O
1	int
;	O
}	O
++	O
*	O
argindp	pointer
;	O
cind	int
=	O
0	int
;	O
if	O
(	O
!	O
push_back_record	function
(	O
ap	pointer
,	O
code	int
,	O
arg	pointer
)	O
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
push_back_record	function
(	O
ap	pointer
,	O
code	int
,	O
""	pointer
)	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
char	O
ap_init	function
(	O
Arg_parser	struct
*	O
ap	pointer
,	O
const	O
int	O
argc	int
,	O
const	O
char	O
*	O
const	O
argv	array
[	O
]	O
,	O
const	O
ap_Option	struct
options	array
[	O
]	O
,	O
const	O
char	O
in_order	char
)	O
{	O
const	O
char	O
*	O
*	O
non_options	pointer
=	O
0	int
;	O
int	O
non_options_size	int
=	O
0	int
;	O
int	O
argind	int
=	O
1	int
;	O
int	O
i	int
;	O
ap	pointer
->	O
data	pointer
=	O
0	int
;	O
ap	pointer
->	O
error	pointer
=	O
0	int
;	O
ap	pointer
->	O
data_size	int
=	O
0	int
;	O
ap	pointer
->	O
error_size	int
=	O
0	int
;	O
if	O
(	O
argc	int
<	O
2	int
||	O
!	O
argv	array
||	O
!	O
options	array
)	O
return	O
1	int
;	O
while	O
(	O
argind	int
<	O
argc	int
)	O
{	O
const	O
unsigned	O
char	O
ch1	char
=	O
argv	array
[	O
argind	int
]	O
[	O
0	int
]	O
;	O
const	O
unsigned	O
char	O
ch2	char
=	O
(	O
ch1	char
?	O
argv	array
[	O
argind	int
]	O
[	O
1	int
]	O
:	O
0	int
)	O
;	O
if	O
(	O
ch1	char
==	O
'-'	O
&&	O
ch2	char
)	O
{	O
const	O
char	O
*	O
const	O
opt	pointer
=	O
argv	array
[	O
argind	int
]	O
;	O
const	O
char	O
*	O
const	O
arg	pointer
=	O
(	O
argind	int
+	O
1	int
<	O
argc	int
)	O
?	O
argv	array
[	O
argind	int
+	O
1	int
]	O
:	O
0	int
;	O
if	O
(	O
ch2	char
==	O
'-'	O
)	O
{	O
if	O
(	O
!	O
argv	array
[	O
argind	int
]	O
[	O
2	int
]	O
)	O
{	O
++	O
argind	int
;	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
parse_long_option	function
(	O
ap	pointer
,	O
opt	pointer
,	O
arg	pointer
,	O
options	array
,	O
&	O
argind	int
)	O
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
parse_short_option	function
(	O
ap	pointer
,	O
opt	pointer
,	O
arg	pointer
,	O
options	array
,	O
&	O
argind	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
ap	pointer
->	O
error	pointer
)	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
in_order	char
)	O
{	O
void	O
*	O
tmp	pointer
=	O
ap_resize_buffer	function
(	O
non_options	pointer
,	O
(	O
non_options_size	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
non_options	pointer
)	O
)	O
;	O
if	O
(	O
!	O
tmp	pointer
)	O
return	O
0	int
;	O
non_options	pointer
=	O
(	O
const	O
char	O
*	O
*	O
)	O
tmp	pointer
;	O
non_options	pointer
[	O
non_options_size	int
++	O
]	O
=	O
argv	array
[	O
argind	int
++	O
]	O
;	O
}	O
else	O
if	O
(	O
!	O
push_back_record	function
(	O
ap	pointer
,	O
0	int
,	O
argv	array
[	O
argind	int
++	O
]	O
)	O
)	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
ap	pointer
->	O
error	pointer
)	O
free_data	function
(	O
ap	pointer
)	O
;	O
else	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
non_options_size	int
;	O
++	O
i	int
)	O
if	O
(	O
!	O
push_back_record	function
(	O
ap	pointer
,	O
0	int
,	O
non_options	pointer
[	O
i	int
]	O
)	O
)	O
return	O
0	int
;	O
while	O
(	O
argind	int
<	O
argc	int
)	O
if	O
(	O
!	O
push_back_record	function
(	O
ap	pointer
,	O
0	int
,	O
argv	array
[	O
argind	int
++	O
]	O
)	O
)	O
return	O
0	int
;	O
}	O
if	O
(	O
non_options	pointer
)	O
free	function
(	O
non_options	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
ap_free	function
(	O
Arg_parser	struct
*	O
ap	pointer
)	O
{	O
free_data	function
(	O
ap	pointer
)	O
;	O
if	O
(	O
ap	pointer
->	O
error	pointer
)	O
{	O
free	function
(	O
ap	pointer
->	O
error	pointer
)	O
;	O
ap	pointer
->	O
error	pointer
=	O
0	int
;	O
}	O
ap	pointer
->	O
error_size	int
=	O
0	int
;	O
}	O
const	O
char	O
*	O
ap_error	function
(	O
const	O
Arg_parser	struct
*	O
ap	pointer
)	O
{	O
return	O
ap	pointer
->	O
error	pointer
;	O
}	O
int	O
ap_arguments	function
(	O
const	O
Arg_parser	struct
*	O
ap	pointer
)	O
{	O
return	O
ap	pointer
->	O
data_size	int
;	O
}	O
int	O
ap_code	function
(	O
const	O
Arg_parser	struct
*	O
ap	pointer
,	O
const	O
int	O
i	int
)	O
{	O
if	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
ap_arguments	function
(	O
ap	pointer
)	O
)	O
return	O
ap	pointer
->	O
data	pointer
[	O
i	int
]	O
.	O
code	int
;	O
else	O
return	O
0	int
;	O
}	O
const	O
char	O
*	O
ap_argument	function
(	O
const	O
Arg_parser	struct
*	O
ap	pointer
,	O
const	O
int	O
i	int
)	O
{	O
if	O
(	O
i	int
>=	O
0	int
&&	O
i	int
<	O
ap_arguments	function
(	O
ap	pointer
)	O
)	O
return	O
ap	pointer
->	O
data	pointer
[	O
i	int
]	O
.	O
argument	pointer
;	O
else	O
return	O
""	pointer
;	O
}	O
