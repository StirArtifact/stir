static	O
adns_status	enum
pap_qstring	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
*	O
cbyte_io	pointer
,	O
int	O
max	int
,	O
int	O
*	O
len_r	pointer
,	O
char	O
*	O
*	O
str_r	pointer
)	O
{	O
const	O
byte	char
*	O
dgram	pointer
=	O
pai	pointer
->	O
dgram	pointer
;	O
int	O
l	long
,	O
cbyte	int
;	O
char	O
*	O
str	pointer
;	O
cbyte	int
=	O
*	O
cbyte_io	pointer
;	O
if	O
(	O
cbyte	int
>=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
GET_B	O
(	O
cbyte	int
,	O
l	long
)	O
;	O
if	O
(	O
cbyte	int
+	O
l	long
>	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
str	pointer
=	O
adns__alloc_interim	function
(	O
pai	pointer
->	O
qu	pointer
,	O
l	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
str	pointer
)	O
R_NOMEM	O
;	O
str	pointer
[	O
l	long
]	O
=	O
0	int
;	O
memcpy	function
(	O
str	pointer
,	O
dgram	pointer
+	O
cbyte	int
,	O
l	long
)	O
;	O
*	O
len_r	pointer
=	O
l	long
;	O
*	O
str_r	pointer
=	O
str	pointer
;	O
*	O
cbyte_io	pointer
=	O
cbyte	int
+	O
l	long
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
csp_qstring	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
char	O
*	O
dp	pointer
,	O
int	O
len	int
)	O
{	O
unsigned	O
char	O
ch	char
;	O
char	O
buf	pointer
[	O
10	int
]	O
;	O
int	O
cn	int
;	O
CSP_ADDSTR	O
(	O
"\""	pointer
)	O
;	O
for	O
(	O
cn	int
=	O
0	int
;	O
cn	int
<	O
len	int
;	O
cn	int
++	O
)	O
{	O
ch	char
=	O
*	O
dp	pointer
++	O
;	O
if	O
(	O
ch	char
==	O
'\\'	O
)	O
{	O
CSP_ADDSTR	O
(	O
"\\\\"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
ch	char
==	O
'"'	O
)	O
{	O
CSP_ADDSTR	O
(	O
"\\\""	pointer
)	O
;	O
}	O
else	O
if	O
(	O
ch	char
>=	O
32	int
&&	O
ch	char
<=	O
126	int
)	O
{	O
if	O
(	O
!	O
adns__vbuf_append	function
(	O
vb	pointer
,	O
&	O
ch	char
,	O
1	int
)	O
)	O
R_NOMEM	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
buf	pointer
,	O
"\\x%02x"	pointer
,	O
ch	char
)	O
;	O
CSP_ADDSTR	O
(	O
buf	pointer
)	O
;	O
}	O
}	O
CSP_ADDSTR	O
(	O
"\""	pointer
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
void	O
mf_str	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
datap	pointer
)	O
{	O
char	O
*	O
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns__makefinal_str	function
(	O
qu	pointer
,	O
rrp	pointer
)	O
;	O
}	O
static	O
void	O
mf_intstr	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_intstr	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns__makefinal_str	function
(	O
qu	pointer
,	O
&	O
rrp	pointer
->	O
str	pointer
)	O
;	O
}	O
static	O
void	O
mf_manyistr	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_intstr	struct
*	O
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_rr_intstr	struct
*	O
te	pointer
,	O
*	O
table	pointer
;	O
void	O
*	O
tablev	pointer
;	O
int	O
tc	int
;	O
for	O
(	O
tc	int
=	O
0	int
,	O
te	pointer
=	O
*	O
rrp	pointer
;	O
te	pointer
->	O
i	int
>=	O
0	int
;	O
te	pointer
++	O
,	O
tc	int
++	O
)	O
;	O
tablev	pointer
=	O
*	O
rrp	pointer
;	O
adns__makefinal_block	function
(	O
qu	pointer
,	O
&	O
tablev	pointer
,	O
sizeof	O
(	O
*	O
te	pointer
)	O
*	O
(	O
tc	int
+	O
1	int
)	O
)	O
;	O
*	O
rrp	pointer
=	O
table	pointer
=	O
tablev	pointer
;	O
for	O
(	O
te	pointer
=	O
*	O
rrp	pointer
;	O
te	pointer
->	O
i	int
>=	O
0	int
;	O
te	pointer
++	O
)	O
adns__makefinal_str	function
(	O
qu	pointer
,	O
&	O
te	pointer
->	O
str	pointer
)	O
;	O
}	O
static	O
adns_status	enum
pa_txt	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_intstr	struct
*	O
*	O
rrp	pointer
=	O
datap	pointer
,	O
*	O
table	pointer
,	O
*	O
te	pointer
;	O
const	O
byte	char
*	O
dgram	pointer
=	O
pai	pointer
->	O
dgram	pointer
;	O
int	O
ti	int
,	O
tc	int
,	O
l	long
,	O
startbyte	int
;	O
adns_status	enum
st	enum
;	O
startbyte	int
=	O
cbyte	int
;	O
if	O
(	O
cbyte	int
>=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
tc	int
=	O
0	int
;	O
while	O
(	O
cbyte	int
<	O
max	int
)	O
{	O
GET_B	O
(	O
cbyte	int
,	O
l	long
)	O
;	O
cbyte	int
+=	O
l	long
;	O
tc	int
++	O
;	O
}	O
if	O
(	O
cbyte	int
!=	O
max	int
||	O
!	O
tc	int
)	O
return	O
adns_s_invaliddata	int
;	O
table	pointer
=	O
adns__alloc_interim	function
(	O
pai	pointer
->	O
qu	pointer
,	O
sizeof	O
(	O
*	O
table	pointer
)	O
*	O
(	O
tc	int
+	O
1	int
)	O
)	O
;	O
if	O
(	O
!	O
table	pointer
)	O
R_NOMEM	O
;	O
for	O
(	O
cbyte	int
=	O
startbyte	int
,	O
ti	int
=	O
0	int
,	O
te	pointer
=	O
table	pointer
;	O
ti	int
<	O
tc	int
;	O
ti	int
++	O
,	O
te	pointer
++	O
)	O
{	O
st	enum
=	O
pap_qstring	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
&	O
te	pointer
->	O
i	int
,	O
&	O
te	pointer
->	O
str	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
}	O
assert	O
(	O
cbyte	int
==	O
max	int
)	O
;	O
te	pointer
->	O
i	int
=	O
-	O
1	int
;	O
te	pointer
->	O
str	pointer
=	O
0	int
;	O
*	O
rrp	pointer
=	O
table	pointer
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
cs_txt	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
adns_rr_intstr	struct
*	O
const	O
*	O
rrp	pointer
=	O
datap	pointer
;	O
const	O
adns_rr_intstr	struct
*	O
current	pointer
;	O
adns_status	enum
st	enum
;	O
int	O
spc	int
;	O
for	O
(	O
current	pointer
=	O
*	O
rrp	pointer
,	O
spc	int
=	O
0	int
;	O
current	pointer
->	O
i	int
>=	O
0	int
;	O
current	pointer
++	O
,	O
spc	int
=	O
1	int
)	O
{	O
if	O
(	O
spc	int
)	O
CSP_ADDSTR	O
(	O
" "	pointer
)	O
;	O
st	enum
=	O
csp_qstring	function
(	O
vb	pointer
,	O
current	pointer
->	O
str	pointer
,	O
current	pointer
->	O
i	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
}	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
cs_hinfo	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
adns_rr_intstrpair	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
csp_qstring	function
(	O
vb	pointer
,	O
rrp	pointer
->	O
array	array
[	O
0	int
]	O
.	O
str	pointer
,	O
rrp	pointer
->	O
array	array
[	O
0	int
]	O
.	O
i	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
CSP_ADDSTR	O
(	O
" "	pointer
)	O
;	O
st	enum
=	O
csp_qstring	function
(	O
vb	pointer
,	O
rrp	pointer
->	O
array	array
[	O
1	int
]	O
.	O
str	pointer
,	O
rrp	pointer
->	O
array	array
[	O
1	int
]	O
.	O
i	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
pa_inaddr	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
struct	O
in_addr	struct
*	O
storeto	pointer
=	O
datap	pointer
;	O
if	O
(	O
max	int
-	O
cbyte	int
!=	O
4	int
)	O
return	O
adns_s_invaliddata	int
;	O
memcpy	function
(	O
storeto	pointer
,	O
pai	pointer
->	O
dgram	pointer
+	O
cbyte	int
,	O
4	int
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
int	O
search_sortlist	function
(	O
adns_state	pointer
ads	pointer
,	O
struct	O
in_addr	struct
ad	struct
)	O
{	O
const	O
struct	O
sortlist	struct
*	O
slp	pointer
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
slp	pointer
=	O
ads	pointer
->	O
sortlist	struct
;	O
i	int
<	O
ads	pointer
->	O
nsortlist	int
&&	O
!	O
(	O
(	O
ad	struct
.	O
s_addr	int
&	O
slp	pointer
->	O
mask	struct
.	O
s_addr	int
)	O
==	O
slp	pointer
->	O
base	struct
.	O
s_addr	int
)	O
;	O
i	int
++	O
,	O
slp	pointer
++	O
)	O
;	O
return	O
i	int
;	O
}	O
static	O
int	O
dip_inaddr	function
(	O
adns_state	pointer
ads	pointer
,	O
struct	O
in_addr	struct
a	pointer
,	O
struct	O
in_addr	struct
b	pointer
)	O
{	O
int	O
ai	int
,	O
bi	int
;	O
if	O
(	O
!	O
ads	pointer
->	O
nsortlist	int
)	O
return	O
0	int
;	O
ai	int
=	O
search_sortlist	function
(	O
ads	pointer
,	O
a	pointer
)	O
;	O
bi	int
=	O
search_sortlist	function
(	O
ads	pointer
,	O
b	pointer
)	O
;	O
return	O
bi	int
<	O
ai	int
;	O
}	O
static	O
int	O
di_inaddr	function
(	O
adns_state	pointer
ads	pointer
,	O
const	O
void	O
*	O
datap_a	pointer
,	O
const	O
void	O
*	O
datap_b	pointer
)	O
{	O
const	O
struct	O
in_addr	struct
*	O
ap	pointer
=	O
datap_a	pointer
,	O
*	O
bp	pointer
=	O
datap_b	pointer
;	O
return	O
dip_inaddr	function
(	O
ads	pointer
,	O
*	O
ap	pointer
,	O
*	O
bp	pointer
)	O
;	O
}	O
static	O
adns_status	enum
cs_inaddr	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
struct	O
in_addr	struct
*	O
rrp	pointer
=	O
datap	pointer
,	O
rr	struct
=	O
*	O
rrp	pointer
;	O
const	O
char	O
*	O
ia	struct
;	O
ia	struct
=	O
inet_ntoa	function
(	O
rr	struct
)	O
;	O
assert	O
(	O
ia	struct
)	O
;	O
CSP_ADDSTR	O
(	O
ia	struct
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
pa_addr	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_addr	struct
*	O
storeto	pointer
=	O
datap	pointer
;	O
const	O
byte	char
*	O
dgram	pointer
=	O
pai	pointer
->	O
dgram	pointer
;	O
if	O
(	O
max	int
-	O
cbyte	int
!=	O
4	int
)	O
return	O
adns_s_invaliddata	int
;	O
storeto	pointer
->	O
len	int
=	O
sizeof	O
(	O
storeto	pointer
->	O
addr	union
.	O
inet	struct
)	O
;	O
memset	function
(	O
&	O
storeto	pointer
->	O
addr	union
,	O
0	int
,	O
sizeof	O
(	O
storeto	pointer
->	O
addr	union
.	O
inet	struct
)	O
)	O
;	O
storeto	pointer
->	O
addr	union
.	O
inet	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
memcpy	function
(	O
&	O
storeto	pointer
->	O
addr	union
.	O
inet	struct
.	O
sin_addr	struct
,	O
dgram	pointer
+	O
cbyte	int
,	O
4	int
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
int	O
di_addr	function
(	O
adns_state	pointer
ads	pointer
,	O
const	O
void	O
*	O
datap_a	pointer
,	O
const	O
void	O
*	O
datap_b	pointer
)	O
{	O
const	O
adns_rr_addr	struct
*	O
ap	pointer
=	O
datap_a	pointer
,	O
*	O
bp	pointer
=	O
datap_b	pointer
;	O
assert	O
(	O
ap	pointer
->	O
addr	union
.	O
sa	struct
.	O
sa_family	short
==	O
AF_INET	O
)	O
;	O
return	O
dip_inaddr	function
(	O
ads	pointer
,	O
ap	pointer
->	O
addr	union
.	O
inet	struct
.	O
sin_addr	struct
,	O
bp	pointer
->	O
addr	union
.	O
inet	struct
.	O
sin_addr	struct
)	O
;	O
}	O
static	O
int	O
div_addr	function
(	O
void	O
*	O
context	pointer
,	O
const	O
void	O
*	O
datap_a	pointer
,	O
const	O
void	O
*	O
datap_b	pointer
)	O
{	O
const	O
adns_state	pointer
ads	pointer
=	O
context	pointer
;	O
return	O
di_addr	function
(	O
ads	pointer
,	O
datap_a	pointer
,	O
datap_b	pointer
)	O
;	O
}	O
static	O
adns_status	enum
csp_addr	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
adns_rr_addr	struct
*	O
rrp	pointer
)	O
{	O
const	O
char	O
*	O
ia	struct
;	O
static	O
char	O
buf	pointer
[	O
30	int
]	O
;	O
switch	O
(	O
rrp	pointer
->	O
addr	union
.	O
inet	struct
.	O
sin_family	short
)	O
{	O
case	O
AF_INET	O
:	O
CSP_ADDSTR	O
(	O
"INET "	pointer
)	O
;	O
ia	struct
=	O
inet_ntoa	function
(	O
rrp	pointer
->	O
addr	union
.	O
inet	struct
.	O
sin_addr	struct
)	O
;	O
assert	O
(	O
ia	struct
)	O
;	O
CSP_ADDSTR	O
(	O
ia	struct
)	O
;	O
break	O
;	O
default	O
:	O
sprintf	function
(	O
buf	pointer
,	O
"AF=%u"	pointer
,	O
rrp	pointer
->	O
addr	union
.	O
sa	struct
.	O
sa_family	short
)	O
;	O
CSP_ADDSTR	O
(	O
buf	pointer
)	O
;	O
break	O
;	O
}	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
cs_addr	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
adns_rr_addr	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
return	O
csp_addr	function
(	O
vb	pointer
,	O
rrp	pointer
)	O
;	O
}	O
static	O
adns_status	enum
pap_domain	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
*	O
cbyte_io	pointer
,	O
int	O
max	int
,	O
char	O
*	O
*	O
domain_r	pointer
,	O
parsedomain_flags	enum
flags	enum
)	O
{	O
adns_status	enum
st	enum
;	O
char	O
*	O
dm	pointer
;	O
st	enum
=	O
adns__parse_domain	function
(	O
pai	pointer
->	O
qu	pointer
->	O
ads	pointer
,	O
pai	pointer
->	O
serv	int
,	O
pai	pointer
->	O
qu	pointer
,	O
&	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
,	O
flags	enum
,	O
pai	pointer
->	O
dgram	pointer
,	O
pai	pointer
->	O
dglen	int
,	O
cbyte_io	pointer
,	O
max	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
!	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
.	O
used	int
)	O
return	O
adns_s_invaliddata	int
;	O
dm	pointer
=	O
adns__alloc_interim	function
(	O
pai	pointer
->	O
qu	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
.	O
used	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
dm	pointer
)	O
R_NOMEM	O
;	O
dm	pointer
[	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
.	O
used	int
]	O
=	O
0	int
;	O
memcpy	function
(	O
dm	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
.	O
buf	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
.	O
used	int
)	O
;	O
*	O
domain_r	pointer
=	O
dm	pointer
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
csp_domain	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
char	O
*	O
domain	pointer
)	O
{	O
CSP_ADDSTR	O
(	O
domain	pointer
)	O
;	O
if	O
(	O
!	O
*	O
domain	pointer
)	O
CSP_ADDSTR	O
(	O
"."	pointer
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
cs_domain	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
char	O
*	O
const	O
*	O
domainp	pointer
=	O
datap	pointer
;	O
return	O
csp_domain	function
(	O
vb	pointer
,	O
*	O
domainp	pointer
)	O
;	O
}	O
static	O
adns_status	enum
pa_dom_raw	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
char	O
*	O
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
pap_domain	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
rrp	pointer
,	O
pdf_quoteok	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
cbyte	int
!=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
pa_host_raw	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
char	O
*	O
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
pap_domain	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
rrp	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
flags	enum
&	O
adns_qf_quoteok_anshost	int
?	O
pdf_quoteok	int
:	O
0	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
cbyte	int
!=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
pap_findaddrs	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
adns_rr_hostaddr	struct
*	O
ha	struct
,	O
int	O
*	O
cbyte_io	pointer
,	O
int	O
count	int
,	O
int	O
dmstart	int
)	O
{	O
int	O
rri	int
,	O
naddrs	int
;	O
int	O
type	enum
,	O
class	int
,	O
rdlen	int
,	O
rdstart	int
,	O
ownermatched	int
;	O
unsigned	O
long	O
ttl	long
;	O
adns_status	enum
st	enum
;	O
for	O
(	O
rri	int
=	O
0	int
,	O
naddrs	int
=	O
-	O
1	int
;	O
rri	int
<	O
count	int
;	O
rri	int
++	O
)	O
{	O
st	enum
=	O
adns__findrr_anychk	function
(	O
pai	pointer
->	O
qu	pointer
,	O
pai	pointer
->	O
serv	int
,	O
pai	pointer
->	O
dgram	pointer
,	O
pai	pointer
->	O
dglen	int
,	O
cbyte_io	pointer
,	O
&	O
type	enum
,	O
&	O
class	int
,	O
&	O
ttl	long
,	O
&	O
rdlen	int
,	O
&	O
rdstart	int
,	O
pai	pointer
->	O
dgram	pointer
,	O
pai	pointer
->	O
dglen	int
,	O
dmstart	int
,	O
&	O
ownermatched	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
!	O
ownermatched	int
||	O
class	int
!=	O
DNS_CLASS_IN	int
||	O
type	enum
!=	O
adns_r_a	int
)	O
{	O
if	O
(	O
naddrs	int
>	O
0	int
)	O
break	O
;	O
else	O
continue	O
;	O
}	O
if	O
(	O
naddrs	int
==	O
-	O
1	int
)	O
{	O
naddrs	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
adns__vbuf_ensure	function
(	O
&	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
,	O
(	O
naddrs	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
adns_rr_addr	struct
)	O
)	O
)	O
R_NOMEM	O
;	O
adns__update_expires	function
(	O
pai	pointer
->	O
qu	pointer
,	O
ttl	long
,	O
pai	pointer
->	O
now	pointer
)	O
;	O
st	enum
=	O
pa_addr	function
(	O
pai	pointer
,	O
rdstart	int
,	O
rdstart	int
+	O
rdlen	int
,	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
.	O
buf	pointer
+	O
naddrs	int
*	O
sizeof	O
(	O
adns_rr_addr	struct
)	O
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
naddrs	int
++	O
;	O
}	O
if	O
(	O
naddrs	int
>=	O
0	int
)	O
{	O
ha	struct
->	O
addrs	pointer
=	O
adns__alloc_interim	function
(	O
pai	pointer
->	O
qu	pointer
,	O
naddrs	int
*	O
sizeof	O
(	O
adns_rr_addr	struct
)	O
)	O
;	O
if	O
(	O
!	O
ha	struct
->	O
addrs	pointer
)	O
R_NOMEM	O
;	O
memcpy	function
(	O
ha	struct
->	O
addrs	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
.	O
buf	pointer
,	O
naddrs	int
*	O
sizeof	O
(	O
adns_rr_addr	struct
)	O
)	O
;	O
ha	struct
->	O
naddrs	int
=	O
naddrs	int
;	O
ha	struct
->	O
astatus	enum
=	O
adns_s_ok	int
;	O
adns__isort	function
(	O
ha	struct
->	O
addrs	pointer
,	O
naddrs	int
,	O
sizeof	O
(	O
adns_rr_addr	struct
)	O
,	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
.	O
buf	pointer
,	O
div_addr	function
,	O
pai	pointer
->	O
ads	pointer
)	O
;	O
}	O
return	O
adns_s_ok	int
;	O
}	O
static	O
void	O
icb_hostaddr	function
(	O
adns_query	pointer
parent	pointer
,	O
adns_query	pointer
child	pointer
)	O
{	O
adns_answer	struct
*	O
cans	pointer
=	O
child	pointer
->	O
answer	pointer
;	O
adns_rr_hostaddr	struct
*	O
rrp	pointer
=	O
child	pointer
->	O
ctx	struct
.	O
info	union
.	O
hostaddr	pointer
;	O
adns_state	pointer
ads	pointer
=	O
parent	pointer
->	O
ads	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
cans	pointer
->	O
status	enum
;	O
rrp	pointer
->	O
astatus	enum
=	O
st	enum
;	O
rrp	pointer
->	O
naddrs	int
=	O
(	O
st	enum
>	O
0	int
&&	O
st	enum
<=	O
adns_s_max_tempfail	int
)	O
?	O
-	O
1	int
:	O
cans	pointer
->	O
nrrs	int
;	O
rrp	pointer
->	O
addrs	pointer
=	O
cans	pointer
->	O
rrs	union
.	O
addr	union
;	O
adns__transfer_interim	function
(	O
child	pointer
,	O
parent	pointer
,	O
rrp	pointer
->	O
addrs	pointer
,	O
rrp	pointer
->	O
naddrs	int
*	O
sizeof	O
(	O
adns_rr_addr	struct
)	O
)	O
;	O
if	O
(	O
parent	pointer
->	O
children	struct
.	O
head	pointer
)	O
{	O
LIST_LINK_TAIL	O
(	O
ads	pointer
->	O
childw	struct
,	O
parent	pointer
)	O
;	O
}	O
else	O
{	O
adns__query_done	function
(	O
parent	pointer
)	O
;	O
}	O
}	O
static	O
adns_status	enum
pap_hostaddr	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
*	O
cbyte_io	pointer
,	O
int	O
max	int
,	O
adns_rr_hostaddr	struct
*	O
rrp	pointer
)	O
{	O
adns_status	enum
st	enum
;	O
int	O
dmstart	int
,	O
cbyte	int
;	O
qcontext	struct
ctx	struct
;	O
int	O
id	int
;	O
adns_query	pointer
nqu	pointer
;	O
adns_queryflags	enum
nflags	enum
;	O
dmstart	int
=	O
cbyte	int
=	O
*	O
cbyte_io	pointer
;	O
st	enum
=	O
pap_domain	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
&	O
rrp	pointer
->	O
host	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
flags	enum
&	O
adns_qf_quoteok_anshost	int
?	O
pdf_quoteok	int
:	O
0	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
*	O
cbyte_io	pointer
=	O
cbyte	int
;	O
rrp	pointer
->	O
astatus	enum
=	O
adns_s_ok	int
;	O
rrp	pointer
->	O
naddrs	int
=	O
-	O
1	int
;	O
rrp	pointer
->	O
addrs	pointer
=	O
0	int
;	O
cbyte	int
=	O
pai	pointer
->	O
nsstart	int
;	O
st	enum
=	O
pap_findaddrs	function
(	O
pai	pointer
,	O
rrp	pointer
,	O
&	O
cbyte	int
,	O
pai	pointer
->	O
nscount	int
,	O
dmstart	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
rrp	pointer
->	O
naddrs	int
!=	O
-	O
1	int
)	O
return	O
adns_s_ok	int
;	O
st	enum
=	O
pap_findaddrs	function
(	O
pai	pointer
,	O
rrp	pointer
,	O
&	O
cbyte	int
,	O
pai	pointer
->	O
arcount	int
,	O
dmstart	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
rrp	pointer
->	O
naddrs	int
!=	O
-	O
1	int
)	O
return	O
adns_s_ok	int
;	O
st	enum
=	O
adns__mkquery_frdgram	function
(	O
pai	pointer
->	O
ads	pointer
,	O
&	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
,	O
&	O
id	int
,	O
pai	pointer
->	O
dgram	pointer
,	O
pai	pointer
->	O
dglen	int
,	O
dmstart	int
,	O
adns_r_addr	int
,	O
adns_qf_quoteok_query	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
ctx	struct
.	O
ext	pointer
=	O
0	int
;	O
ctx	struct
.	O
callback	pointer
=	O
icb_hostaddr	function
;	O
ctx	struct
.	O
info	union
.	O
hostaddr	pointer
=	O
rrp	pointer
;	O
nflags	enum
=	O
adns_qf_quoteok_query	int
;	O
if	O
(	O
!	O
(	O
pai	pointer
->	O
qu	pointer
->	O
flags	enum
&	O
adns_qf_cname_loose	int
)	O
)	O
nflags	enum
|=	O
adns_qf_cname_forbid	int
;	O
st	enum
=	O
adns__internal_submit	function
(	O
pai	pointer
->	O
ads	pointer
,	O
&	O
nqu	pointer
,	O
adns__findtype	function
(	O
adns_r_addr	int
)	O
,	O
&	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
,	O
id	int
,	O
nflags	enum
,	O
pai	pointer
->	O
now	pointer
,	O
&	O
ctx	struct
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
nqu	pointer
->	O
parent	pointer
=	O
pai	pointer
->	O
qu	pointer
;	O
LIST_LINK_TAIL_PART	O
(	O
pai	pointer
->	O
qu	pointer
->	O
children	struct
,	O
nqu	pointer
,	O
siblings	struct
.	O
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
pa_hostaddr	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_hostaddr	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
pap_hostaddr	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
rrp	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
cbyte	int
!=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
int	O
dip_hostaddr	function
(	O
adns_state	pointer
ads	pointer
,	O
const	O
adns_rr_hostaddr	struct
*	O
ap	pointer
,	O
const	O
adns_rr_hostaddr	struct
*	O
bp	pointer
)	O
{	O
if	O
(	O
ap	pointer
->	O
astatus	enum
!=	O
bp	pointer
->	O
astatus	enum
)	O
return	O
ap	pointer
->	O
astatus	enum
;	O
if	O
(	O
ap	pointer
->	O
astatus	enum
)	O
return	O
0	int
;	O
assert	O
(	O
ap	pointer
->	O
addrs	pointer
[	O
0	int
]	O
.	O
addr	union
.	O
sa	struct
.	O
sa_family	short
==	O
AF_INET	O
)	O
;	O
assert	O
(	O
bp	pointer
->	O
addrs	pointer
[	O
0	int
]	O
.	O
addr	union
.	O
sa	struct
.	O
sa_family	short
==	O
AF_INET	O
)	O
;	O
return	O
dip_inaddr	function
(	O
ads	pointer
,	O
ap	pointer
->	O
addrs	pointer
[	O
0	int
]	O
.	O
addr	union
.	O
inet	struct
.	O
sin_addr	struct
,	O
bp	pointer
->	O
addrs	pointer
[	O
0	int
]	O
.	O
addr	union
.	O
inet	struct
.	O
sin_addr	struct
)	O
;	O
}	O
static	O
int	O
di_hostaddr	function
(	O
adns_state	pointer
ads	pointer
,	O
const	O
void	O
*	O
datap_a	pointer
,	O
const	O
void	O
*	O
datap_b	pointer
)	O
{	O
const	O
adns_rr_hostaddr	struct
*	O
ap	pointer
=	O
datap_a	pointer
,	O
*	O
bp	pointer
=	O
datap_b	pointer
;	O
return	O
dip_hostaddr	function
(	O
ads	pointer
,	O
ap	pointer
,	O
bp	pointer
)	O
;	O
}	O
static	O
void	O
mfp_hostaddr	function
(	O
adns_query	pointer
qu	pointer
,	O
adns_rr_hostaddr	struct
*	O
rrp	pointer
)	O
{	O
void	O
*	O
tablev	pointer
;	O
adns__makefinal_str	function
(	O
qu	pointer
,	O
&	O
rrp	pointer
->	O
host	pointer
)	O
;	O
tablev	pointer
=	O
rrp	pointer
->	O
addrs	pointer
;	O
adns__makefinal_block	function
(	O
qu	pointer
,	O
&	O
tablev	pointer
,	O
rrp	pointer
->	O
naddrs	int
*	O
sizeof	O
(	O
*	O
rrp	pointer
->	O
addrs	pointer
)	O
)	O
;	O
rrp	pointer
->	O
addrs	pointer
=	O
tablev	pointer
;	O
}	O
static	O
void	O
mf_hostaddr	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_hostaddr	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
mfp_hostaddr	function
(	O
qu	pointer
,	O
rrp	pointer
)	O
;	O
}	O
static	O
adns_status	enum
csp_hostaddr	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
adns_rr_hostaddr	struct
*	O
rrp	pointer
)	O
{	O
const	O
char	O
*	O
errstr	pointer
;	O
adns_status	enum
st	enum
;	O
char	O
buf	pointer
[	O
20	int
]	O
;	O
int	O
i	int
;	O
st	enum
=	O
csp_domain	function
(	O
vb	pointer
,	O
rrp	pointer
->	O
host	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
CSP_ADDSTR	O
(	O
" "	pointer
)	O
;	O
CSP_ADDSTR	O
(	O
adns_errtypeabbrev	function
(	O
rrp	pointer
->	O
astatus	enum
)	O
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
" %d "	pointer
,	O
rrp	pointer
->	O
astatus	enum
)	O
;	O
CSP_ADDSTR	O
(	O
buf	pointer
)	O
;	O
CSP_ADDSTR	O
(	O
adns_errabbrev	function
(	O
rrp	pointer
->	O
astatus	enum
)	O
)	O
;	O
CSP_ADDSTR	O
(	O
" "	pointer
)	O
;	O
errstr	pointer
=	O
adns_strerror	function
(	O
rrp	pointer
->	O
astatus	enum
)	O
;	O
st	enum
=	O
csp_qstring	function
(	O
vb	pointer
,	O
errstr	pointer
,	O
strlen	function
(	O
errstr	pointer
)	O
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
rrp	pointer
->	O
naddrs	int
>=	O
0	int
)	O
{	O
CSP_ADDSTR	O
(	O
" ("	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
rrp	pointer
->	O
naddrs	int
;	O
i	int
++	O
)	O
{	O
CSP_ADDSTR	O
(	O
" "	pointer
)	O
;	O
st	enum
=	O
csp_addr	function
(	O
vb	pointer
,	O
&	O
rrp	pointer
->	O
addrs	pointer
[	O
i	int
]	O
)	O
;	O
}	O
CSP_ADDSTR	O
(	O
" )"	pointer
)	O
;	O
}	O
else	O
{	O
CSP_ADDSTR	O
(	O
" ?"	pointer
)	O
;	O
}	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
cs_hostaddr	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
adns_rr_hostaddr	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
return	O
csp_hostaddr	function
(	O
vb	pointer
,	O
rrp	pointer
)	O
;	O
}	O
static	O
adns_status	enum
pa_mx_raw	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
byte	char
*	O
dgram	pointer
=	O
pai	pointer
->	O
dgram	pointer
;	O
adns_rr_intstr	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
int	O
pref	int
;	O
if	O
(	O
cbyte	int
+	O
2	int
>	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
GET_W	O
(	O
cbyte	int
,	O
pref	int
)	O
;	O
rrp	pointer
->	O
i	int
=	O
pref	int
;	O
st	enum
=	O
pap_domain	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
&	O
rrp	pointer
->	O
str	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
flags	enum
&	O
adns_qf_quoteok_anshost	int
?	O
pdf_quoteok	int
:	O
0	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
cbyte	int
!=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
int	O
di_mx_raw	function
(	O
adns_state	pointer
ads	pointer
,	O
const	O
void	O
*	O
datap_a	pointer
,	O
const	O
void	O
*	O
datap_b	pointer
)	O
{	O
const	O
adns_rr_intstr	struct
*	O
ap	pointer
=	O
datap_a	pointer
,	O
*	O
bp	pointer
=	O
datap_b	pointer
;	O
if	O
(	O
ap	pointer
->	O
i	int
<	O
bp	pointer
->	O
i	int
)	O
return	O
0	int
;	O
if	O
(	O
ap	pointer
->	O
i	int
>	O
bp	pointer
->	O
i	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
adns_status	enum
pa_mx	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
byte	char
*	O
dgram	pointer
=	O
pai	pointer
->	O
dgram	pointer
;	O
adns_rr_inthostaddr	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
int	O
pref	int
;	O
if	O
(	O
cbyte	int
+	O
2	int
>	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
GET_W	O
(	O
cbyte	int
,	O
pref	int
)	O
;	O
rrp	pointer
->	O
i	int
=	O
pref	int
;	O
st	enum
=	O
pap_hostaddr	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
&	O
rrp	pointer
->	O
ha	struct
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
cbyte	int
!=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
int	O
di_mx	function
(	O
adns_state	pointer
ads	pointer
,	O
const	O
void	O
*	O
datap_a	pointer
,	O
const	O
void	O
*	O
datap_b	pointer
)	O
{	O
const	O
adns_rr_inthostaddr	struct
*	O
ap	pointer
=	O
datap_a	pointer
,	O
*	O
bp	pointer
=	O
datap_b	pointer
;	O
if	O
(	O
ap	pointer
->	O
i	int
<	O
bp	pointer
->	O
i	int
)	O
return	O
0	int
;	O
if	O
(	O
ap	pointer
->	O
i	int
>	O
bp	pointer
->	O
i	int
)	O
return	O
1	int
;	O
return	O
dip_hostaddr	function
(	O
ads	pointer
,	O
&	O
ap	pointer
->	O
ha	struct
,	O
&	O
bp	pointer
->	O
ha	struct
)	O
;	O
}	O
static	O
void	O
mf_inthostaddr	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_inthostaddr	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
mfp_hostaddr	function
(	O
qu	pointer
,	O
&	O
rrp	pointer
->	O
ha	struct
)	O
;	O
}	O
static	O
adns_status	enum
cs_inthostaddr	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
adns_rr_inthostaddr	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
char	O
buf	pointer
[	O
10	int
]	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%u "	pointer
,	O
rrp	pointer
->	O
i	int
)	O
;	O
CSP_ADDSTR	O
(	O
buf	pointer
)	O
;	O
return	O
csp_hostaddr	function
(	O
vb	pointer
,	O
&	O
rrp	pointer
->	O
ha	struct
)	O
;	O
}	O
static	O
adns_status	enum
cs_inthost	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
adns_rr_intstr	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
char	O
buf	pointer
[	O
10	int
]	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%u "	pointer
,	O
rrp	pointer
->	O
i	int
)	O
;	O
CSP_ADDSTR	O
(	O
buf	pointer
)	O
;	O
return	O
csp_domain	function
(	O
vb	pointer
,	O
rrp	pointer
->	O
str	pointer
)	O
;	O
}	O
static	O
void	O
icb_ptr	function
(	O
adns_query	pointer
parent	pointer
,	O
adns_query	pointer
child	pointer
)	O
{	O
adns_answer	struct
*	O
cans	pointer
=	O
child	pointer
->	O
answer	pointer
;	O
const	O
adns_rr_addr	struct
*	O
queried	pointer
,	O
*	O
found	pointer
;	O
adns_state	pointer
ads	pointer
=	O
parent	pointer
->	O
ads	pointer
;	O
int	O
i	int
;	O
if	O
(	O
cans	pointer
->	O
status	enum
==	O
adns_s_nxdomain	int
||	O
cans	pointer
->	O
status	enum
==	O
adns_s_nodata	int
)	O
{	O
adns__query_fail	function
(	O
parent	pointer
,	O
adns_s_inconsistent	int
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
cans	pointer
->	O
status	enum
)	O
{	O
adns__query_fail	function
(	O
parent	pointer
,	O
cans	pointer
->	O
status	enum
)	O
;	O
return	O
;	O
}	O
queried	pointer
=	O
&	O
parent	pointer
->	O
ctx	struct
.	O
info	union
.	O
ptr_parent_addr	struct
;	O
for	O
(	O
i	int
=	O
0	int
,	O
found	pointer
=	O
cans	pointer
->	O
rrs	union
.	O
addr	union
;	O
i	int
<	O
cans	pointer
->	O
nrrs	int
;	O
i	int
++	O
,	O
found	pointer
++	O
)	O
{	O
if	O
(	O
queried	pointer
->	O
len	int
==	O
found	pointer
->	O
len	int
&&	O
!	O
memcmp	function
(	O
&	O
queried	pointer
->	O
addr	union
,	O
&	O
found	pointer
->	O
addr	union
,	O
queried	pointer
->	O
len	int
)	O
)	O
{	O
if	O
(	O
!	O
parent	pointer
->	O
children	struct
.	O
head	pointer
)	O
{	O
adns__query_done	function
(	O
parent	pointer
)	O
;	O
return	O
;	O
}	O
else	O
{	O
LIST_LINK_TAIL	O
(	O
ads	pointer
->	O
childw	struct
,	O
parent	pointer
)	O
;	O
return	O
;	O
}	O
}	O
}	O
adns__query_fail	function
(	O
parent	pointer
,	O
adns_s_inconsistent	int
)	O
;	O
}	O
static	O
adns_status	enum
pa_ptr	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
dmstart	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
static	O
const	O
char	O
*	O
(	O
expectdomain	array
[	O
]	O
)	O
=	O
{	O
DNS_INADDR_ARPA	O
}	O
;	O
char	O
*	O
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
adns_rr_addr	struct
*	O
ap	pointer
;	O
findlabel_state	struct
fls	pointer
;	O
char	O
*	O
ep	pointer
;	O
byte	char
ipv	array
[	O
4	int
]	O
;	O
char	O
labbuf	array
[	O
4	int
]	O
;	O
int	O
cbyte	int
,	O
i	int
,	O
lablen	int
,	O
labstart	int
,	O
l	long
,	O
id	int
;	O
adns_query	pointer
nqu	pointer
;	O
qcontext	struct
ctx	struct
;	O
cbyte	int
=	O
dmstart	int
;	O
st	enum
=	O
pap_domain	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
rrp	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
flags	enum
&	O
adns_qf_quoteok_anshost	int
?	O
pdf_quoteok	int
:	O
0	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
cbyte	int
!=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
ap	pointer
=	O
&	O
pai	pointer
->	O
qu	pointer
->	O
ctx	struct
.	O
info	union
.	O
ptr_parent_addr	struct
;	O
if	O
(	O
!	O
ap	pointer
->	O
len	int
)	O
{	O
adns__findlabel_start	function
(	O
&	O
fls	pointer
,	O
pai	pointer
->	O
ads	pointer
,	O
-	O
1	int
,	O
pai	pointer
->	O
qu	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
query_dgram	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
query_dglen	int
,	O
pai	pointer
->	O
qu	pointer
->	O
query_dglen	int
,	O
DNS_HDRSIZE	int
,	O
0	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
{	O
st	enum
=	O
adns__findlabel_next	function
(	O
&	O
fls	pointer
,	O
&	O
lablen	int
,	O
&	O
labstart	int
)	O
;	O
assert	O
(	O
!	O
st	enum
)	O
;	O
if	O
(	O
lablen	int
<=	O
0	int
||	O
lablen	int
>	O
3	int
)	O
return	O
adns_s_querydomainwrong	int
;	O
memcpy	function
(	O
labbuf	array
,	O
pai	pointer
->	O
qu	pointer
->	O
query_dgram	pointer
+	O
labstart	int
,	O
lablen	int
)	O
;	O
labbuf	array
[	O
lablen	int
]	O
=	O
0	int
;	O
ipv	array
[	O
3	int
-	O
i	int
]	O
=	O
strtoul	function
(	O
labbuf	array
,	O
&	O
ep	pointer
,	O
10	int
)	O
;	O
if	O
(	O
*	O
ep	pointer
)	O
return	O
adns_s_querydomainwrong	int
;	O
if	O
(	O
lablen	int
>	O
1	int
&&	O
pai	pointer
->	O
qu	pointer
->	O
query_dgram	pointer
[	O
labstart	int
]	O
==	O
'0'	O
)	O
return	O
adns_s_querydomainwrong	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
expectdomain	array
)	O
/	O
sizeof	O
(	O
*	O
expectdomain	array
)	O
;	O
i	int
++	O
)	O
{	O
st	enum
=	O
adns__findlabel_next	function
(	O
&	O
fls	pointer
,	O
&	O
lablen	int
,	O
&	O
labstart	int
)	O
;	O
assert	O
(	O
!	O
st	enum
)	O
;	O
l	long
=	O
strlen	function
(	O
expectdomain	array
[	O
i	int
]	O
)	O
;	O
if	O
(	O
lablen	int
!=	O
l	long
||	O
memcmp	function
(	O
pai	pointer
->	O
qu	pointer
->	O
query_dgram	pointer
+	O
labstart	int
,	O
expectdomain	array
[	O
i	int
]	O
,	O
l	long
)	O
)	O
return	O
adns_s_querydomainwrong	int
;	O
}	O
st	enum
=	O
adns__findlabel_next	function
(	O
&	O
fls	pointer
,	O
&	O
lablen	int
,	O
0	int
)	O
;	O
assert	O
(	O
!	O
st	enum
)	O
;	O
if	O
(	O
lablen	int
)	O
return	O
adns_s_querydomainwrong	int
;	O
ap	pointer
->	O
len	int
=	O
sizeof	O
(	O
struct	O
sockaddr_in	struct
)	O
;	O
memset	function
(	O
&	O
ap	pointer
->	O
addr	union
,	O
0	int
,	O
sizeof	O
(	O
ap	pointer
->	O
addr	union
.	O
inet	struct
)	O
)	O
;	O
ap	pointer
->	O
addr	union
.	O
inet	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
ap	pointer
->	O
addr	union
.	O
inet	struct
.	O
sin_addr	struct
.	O
s_addr	int
=	O
htonl	function
(	O
(	O
ipv	array
[	O
0	int
]	O
<<	O
24	int
)	O
|	O
(	O
ipv	array
[	O
1	int
]	O
<<	O
16	int
)	O
|	O
(	O
ipv	array
[	O
2	int
]	O
<<	O
8	int
)	O
|	O
(	O
ipv	array
[	O
3	int
]	O
)	O
)	O
;	O
}	O
st	enum
=	O
adns__mkquery_frdgram	function
(	O
pai	pointer
->	O
ads	pointer
,	O
&	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
,	O
&	O
id	int
,	O
pai	pointer
->	O
dgram	pointer
,	O
pai	pointer
->	O
dglen	int
,	O
dmstart	int
,	O
adns_r_addr	int
,	O
adns_qf_quoteok_query	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
ctx	struct
.	O
ext	pointer
=	O
0	int
;	O
ctx	struct
.	O
callback	pointer
=	O
icb_ptr	function
;	O
memset	function
(	O
&	O
ctx	struct
.	O
info	union
,	O
0	int
,	O
sizeof	O
(	O
ctx	struct
.	O
info	union
)	O
)	O
;	O
st	enum
=	O
adns__internal_submit	function
(	O
pai	pointer
->	O
ads	pointer
,	O
&	O
nqu	pointer
,	O
adns__findtype	function
(	O
adns_r_addr	int
)	O
,	O
&	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
,	O
id	int
,	O
adns_qf_quoteok_query	int
,	O
pai	pointer
->	O
now	pointer
,	O
&	O
ctx	struct
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
nqu	pointer
->	O
parent	pointer
=	O
pai	pointer
->	O
qu	pointer
;	O
LIST_LINK_TAIL_PART	O
(	O
pai	pointer
->	O
qu	pointer
->	O
children	struct
,	O
nqu	pointer
,	O
siblings	struct
.	O
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
void	O
mf_strpair	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_strpair	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns__makefinal_str	function
(	O
qu	pointer
,	O
&	O
rrp	pointer
->	O
array	array
[	O
0	int
]	O
)	O
;	O
adns__makefinal_str	function
(	O
qu	pointer
,	O
&	O
rrp	pointer
->	O
array	array
[	O
1	int
]	O
)	O
;	O
}	O
static	O
void	O
mf_intstrpair	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_intstrpair	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns__makefinal_str	function
(	O
qu	pointer
,	O
&	O
rrp	pointer
->	O
array	array
[	O
0	int
]	O
.	O
str	pointer
)	O
;	O
adns__makefinal_str	function
(	O
qu	pointer
,	O
&	O
rrp	pointer
->	O
array	array
[	O
1	int
]	O
.	O
str	pointer
)	O
;	O
}	O
static	O
adns_status	enum
pa_hinfo	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_intstrpair	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
2	int
;	O
i	int
++	O
)	O
{	O
st	enum
=	O
pap_qstring	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
&	O
rrp	pointer
->	O
array	array
[	O
i	int
]	O
.	O
i	int
,	O
&	O
rrp	pointer
->	O
array	array
[	O
i	int
]	O
.	O
str	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
}	O
if	O
(	O
cbyte	int
!=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
pap_mailbox822	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
*	O
cbyte_io	pointer
,	O
int	O
max	int
,	O
char	O
*	O
*	O
mb_r	pointer
)	O
{	O
int	O
lablen	int
,	O
labstart	int
,	O
i	int
,	O
needquote	int
,	O
c	int
,	O
r	int
,	O
neednorm	int
;	O
const	O
unsigned	O
char	O
*	O
p	pointer
;	O
char	O
*	O
str	pointer
;	O
findlabel_state	struct
fls	pointer
;	O
adns_status	enum
st	enum
;	O
vbuf	struct
*	O
vb	pointer
;	O
vb	pointer
=	O
&	O
pai	pointer
->	O
qu	pointer
->	O
vb	pointer
;	O
vb	pointer
->	O
used	int
=	O
0	int
;	O
adns__findlabel_start	function
(	O
&	O
fls	pointer
,	O
pai	pointer
->	O
ads	pointer
,	O
-	O
1	int
,	O
pai	pointer
->	O
qu	pointer
,	O
pai	pointer
->	O
dgram	pointer
,	O
pai	pointer
->	O
dglen	int
,	O
max	int
,	O
*	O
cbyte_io	pointer
,	O
cbyte_io	pointer
)	O
;	O
st	enum
=	O
adns__findlabel_next	function
(	O
&	O
fls	pointer
,	O
&	O
lablen	int
,	O
&	O
labstart	int
)	O
;	O
if	O
(	O
!	O
lablen	int
)	O
{	O
adns__vbuf_appendstr	function
(	O
vb	pointer
,	O
"."	pointer
)	O
;	O
goto	O
x_ok	O
;	O
}	O
neednorm	int
=	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
needquote	int
=	O
0	int
,	O
p	pointer
=	O
pai	pointer
->	O
dgram	pointer
+	O
labstart	int
;	O
i	int
<	O
lablen	int
;	O
i	int
++	O
)	O
{	O
c	int
=	O
*	O
p	pointer
++	O
;	O
if	O
(	O
(	O
c	int
&	O
~	O
128	int
)	O
<	O
32	int
||	O
(	O
c	int
&	O
~	O
128	int
)	O
==	O
127	int
)	O
return	O
adns_s_invaliddata	int
;	O
if	O
(	O
c	int
==	O
'.'	O
&&	O
!	O
neednorm	int
)	O
neednorm	int
=	O
1	int
;	O
else	O
if	O
(	O
c	int
==	O
' '	O
||	O
c	int
>=	O
127	int
||	O
ctype_822special	function
(	O
c	int
)	O
)	O
needquote	int
++	O
;	O
else	O
neednorm	int
=	O
0	int
;	O
}	O
if	O
(	O
needquote	int
||	O
neednorm	int
)	O
{	O
r	int
=	O
adns__vbuf_ensure	function
(	O
vb	pointer
,	O
lablen	int
+	O
needquote	int
+	O
4	int
)	O
;	O
if	O
(	O
!	O
r	int
)	O
R_NOMEM	O
;	O
adns__vbuf_appendq	function
(	O
vb	pointer
,	O
"\""	pointer
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
needquote	int
=	O
0	int
,	O
p	pointer
=	O
pai	pointer
->	O
dgram	pointer
+	O
labstart	int
;	O
i	int
<	O
lablen	int
;	O
i	int
++	O
,	O
p	pointer
++	O
)	O
{	O
c	int
=	O
*	O
p	pointer
;	O
if	O
(	O
c	int
==	O
'"'	O
||	O
c	int
==	O
'\\'	O
)	O
adns__vbuf_appendq	function
(	O
vb	pointer
,	O
"\\"	pointer
,	O
1	int
)	O
;	O
adns__vbuf_appendq	function
(	O
vb	pointer
,	O
p	pointer
,	O
1	int
)	O
;	O
}	O
adns__vbuf_appendq	function
(	O
vb	pointer
,	O
"\""	pointer
,	O
1	int
)	O
;	O
}	O
else	O
{	O
r	int
=	O
adns__vbuf_append	function
(	O
vb	pointer
,	O
pai	pointer
->	O
dgram	pointer
+	O
labstart	int
,	O
lablen	int
)	O
;	O
if	O
(	O
!	O
r	int
)	O
R_NOMEM	O
;	O
}	O
r	int
=	O
adns__vbuf_appendstr	function
(	O
vb	pointer
,	O
"@"	pointer
)	O
;	O
if	O
(	O
!	O
r	int
)	O
R_NOMEM	O
;	O
st	enum
=	O
adns__parse_domain_more	function
(	O
&	O
fls	pointer
,	O
pai	pointer
->	O
ads	pointer
,	O
pai	pointer
->	O
qu	pointer
,	O
vb	pointer
,	O
0	int
,	O
pai	pointer
->	O
dgram	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
x_ok	O
:	O
str	pointer
=	O
adns__alloc_interim	function
(	O
pai	pointer
->	O
qu	pointer
,	O
vb	pointer
->	O
used	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
str	pointer
)	O
R_NOMEM	O
;	O
memcpy	function
(	O
str	pointer
,	O
vb	pointer
->	O
buf	pointer
,	O
vb	pointer
->	O
used	int
)	O
;	O
str	pointer
[	O
vb	pointer
->	O
used	int
]	O
=	O
0	int
;	O
*	O
mb_r	pointer
=	O
str	pointer
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
pap_mailbox	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
*	O
cbyte_io	pointer
,	O
int	O
max	int
,	O
char	O
*	O
*	O
mb_r	pointer
)	O
{	O
if	O
(	O
pai	pointer
->	O
qu	pointer
->	O
typei	pointer
->	O
typekey	enum
&	O
adns__qtf_mail822	int
)	O
{	O
return	O
pap_mailbox822	function
(	O
pai	pointer
,	O
cbyte_io	pointer
,	O
max	int
,	O
mb_r	pointer
)	O
;	O
}	O
else	O
{	O
return	O
pap_domain	function
(	O
pai	pointer
,	O
cbyte_io	pointer
,	O
max	int
,	O
mb_r	pointer
,	O
pdf_quoteok	int
)	O
;	O
}	O
}	O
static	O
adns_status	enum
csp_mailbox	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
char	O
*	O
mailbox	pointer
)	O
{	O
return	O
csp_domain	function
(	O
vb	pointer
,	O
mailbox	pointer
)	O
;	O
}	O
static	O
adns_status	enum
pa_rp	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_strpair	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
pap_mailbox	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
&	O
rrp	pointer
->	O
array	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
st	enum
=	O
pap_domain	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
&	O
rrp	pointer
->	O
array	array
[	O
1	int
]	O
,	O
pdf_quoteok	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
cbyte	int
!=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
cs_rp	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
adns_rr_strpair	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
csp_mailbox	function
(	O
vb	pointer
,	O
rrp	pointer
->	O
array	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
CSP_ADDSTR	O
(	O
" "	pointer
)	O
;	O
st	enum
=	O
csp_domain	function
(	O
vb	pointer
,	O
rrp	pointer
->	O
array	array
[	O
1	int
]	O
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
pa_soa	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_soa	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
const	O
byte	char
*	O
dgram	pointer
=	O
pai	pointer
->	O
dgram	pointer
;	O
adns_status	enum
st	enum
;	O
int	O
msw	int
,	O
lsw	int
,	O
i	int
;	O
st	enum
=	O
pap_domain	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
&	O
rrp	pointer
->	O
mname	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
flags	enum
&	O
adns_qf_quoteok_anshost	int
?	O
pdf_quoteok	int
:	O
0	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
st	enum
=	O
pap_mailbox	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
&	O
rrp	pointer
->	O
rname	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
cbyte	int
+	O
20	int
!=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
5	int
;	O
i	int
++	O
)	O
{	O
GET_W	O
(	O
cbyte	int
,	O
msw	int
)	O
;	O
GET_W	O
(	O
cbyte	int
,	O
lsw	int
)	O
;	O
(	O
&	O
rrp	pointer
->	O
serial	long
)	O
[	O
i	int
]	O
=	O
(	O
msw	int
<<	O
16	int
)	O
|	O
lsw	int
;	O
}	O
return	O
adns_s_ok	int
;	O
}	O
static	O
void	O
mf_soa	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_soa	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns__makefinal_str	function
(	O
qu	pointer
,	O
&	O
rrp	pointer
->	O
mname	pointer
)	O
;	O
adns__makefinal_str	function
(	O
qu	pointer
,	O
&	O
rrp	pointer
->	O
rname	pointer
)	O
;	O
}	O
static	O
adns_status	enum
cs_soa	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
adns_rr_soa	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
char	O
buf	pointer
[	O
20	int
]	O
;	O
int	O
i	int
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
csp_domain	function
(	O
vb	pointer
,	O
rrp	pointer
->	O
mname	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
CSP_ADDSTR	O
(	O
" "	pointer
)	O
;	O
st	enum
=	O
csp_mailbox	function
(	O
vb	pointer
,	O
rrp	pointer
->	O
rname	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
5	int
;	O
i	int
++	O
)	O
{	O
sprintf	function
(	O
buf	pointer
,	O
" %lu"	pointer
,	O
(	O
&	O
rrp	pointer
->	O
serial	long
)	O
[	O
i	int
]	O
)	O
;	O
CSP_ADDSTR	O
(	O
buf	pointer
)	O
;	O
}	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
qdpl_srv	function
(	O
adns_state	pointer
ads	pointer
,	O
const	O
char	O
*	O
*	O
p_io	pointer
,	O
const	O
char	O
*	O
pe	pointer
,	O
int	O
labelnum	int
,	O
char	O
label_r	array
[	O
DNS_MAXDOMAIN	int
]	O
,	O
int	O
*	O
ll_io	pointer
,	O
adns_queryflags	enum
flags	enum
,	O
const	O
typeinfo	struct
*	O
typei	pointer
)	O
{	O
int	O
useflags	int
;	O
const	O
char	O
*	O
p_orig	pointer
;	O
adns_status	enum
st	enum
;	O
if	O
(	O
labelnum	int
<	O
2	int
&&	O
!	O
(	O
flags	enum
&	O
adns_qf_quoteok_query	int
)	O
)	O
{	O
useflags	int
=	O
adns_qf_quoteok_query	int
;	O
p_orig	pointer
=	O
*	O
p_io	pointer
;	O
}	O
else	O
{	O
useflags	int
=	O
flags	enum
;	O
p_orig	pointer
=	O
0	int
;	O
}	O
st	enum
=	O
adns__qdpl_normal	function
(	O
ads	pointer
,	O
p_io	pointer
,	O
pe	pointer
,	O
labelnum	int
,	O
label_r	array
,	O
ll_io	pointer
,	O
useflags	int
,	O
typei	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
p_orig	pointer
)	O
{	O
int	O
ll	int
=	O
*	O
ll_io	pointer
;	O
if	O
(	O
!	O
ll	int
||	O
label_r	array
[	O
0	int
]	O
!=	O
'_'	O
)	O
return	O
adns_s_querydomaininvalid	int
;	O
if	O
(	O
memchr	function
(	O
p_orig	pointer
+	O
1	int
,	O
'\\'	O
,	O
pe	pointer
-	O
(	O
p_orig	pointer
+	O
1	int
)	O
)	O
)	O
return	O
adns_s_querydomaininvalid	int
;	O
}	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
pap_srv_begin	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
*	O
cbyte_io	pointer
,	O
int	O
max	int
,	O
adns_rr_srvha	struct
*	O
rrp	pointer
)	O
{	O
const	O
byte	char
*	O
dgram	pointer
=	O
pai	pointer
->	O
dgram	pointer
;	O
int	O
ti	int
,	O
cbyte	int
;	O
cbyte	int
=	O
*	O
cbyte_io	pointer
;	O
if	O
(	O
(	O
*	O
cbyte_io	pointer
+=	O
6	int
)	O
>	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
rrp	pointer
->	O
priority	int
=	O
GET_W	O
(	O
cbyte	int
,	O
ti	int
)	O
;	O
rrp	pointer
->	O
weight	int
=	O
GET_W	O
(	O
cbyte	int
,	O
ti	int
)	O
;	O
rrp	pointer
->	O
port	int
=	O
GET_W	O
(	O
cbyte	int
,	O
ti	int
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
pa_srvraw	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_srvraw	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
pap_srv_begin	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
datap	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
st	enum
=	O
pap_domain	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
&	O
rrp	pointer
->	O
host	pointer
,	O
pai	pointer
->	O
qu	pointer
->	O
flags	enum
&	O
adns_qf_quoteok_anshost	int
?	O
pdf_quoteok	int
:	O
0	int
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
cbyte	int
!=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
pa_srvha	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_srvha	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
pap_srv_begin	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
datap	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
st	enum
=	O
pap_hostaddr	function
(	O
pai	pointer
,	O
&	O
cbyte	int
,	O
max	int
,	O
&	O
rrp	pointer
->	O
ha	struct
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
if	O
(	O
cbyte	int
!=	O
max	int
)	O
return	O
adns_s_invaliddata	int
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
void	O
mf_srvraw	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_srvraw	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns__makefinal_str	function
(	O
qu	pointer
,	O
&	O
rrp	pointer
->	O
host	pointer
)	O
;	O
}	O
static	O
void	O
mf_srvha	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_srvha	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
mfp_hostaddr	function
(	O
qu	pointer
,	O
&	O
rrp	pointer
->	O
ha	struct
)	O
;	O
}	O
static	O
int	O
di_srv	function
(	O
adns_state	pointer
ads	pointer
,	O
const	O
void	O
*	O
datap_a	pointer
,	O
const	O
void	O
*	O
datap_b	pointer
)	O
{	O
const	O
adns_rr_srvraw	struct
*	O
ap	pointer
=	O
datap_a	pointer
,	O
*	O
bp	pointer
=	O
datap_b	pointer
;	O
if	O
(	O
ap	pointer
->	O
priority	int
<	O
bp	pointer
->	O
priority	int
)	O
return	O
0	int
;	O
if	O
(	O
ap	pointer
->	O
priority	int
>	O
bp	pointer
->	O
priority	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
adns_status	enum
csp_srv_begin	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
adns_rr_srvha	struct
*	O
rrp	pointer
)	O
{	O
char	O
buf	pointer
[	O
30	int
]	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%u %u %u "	pointer
,	O
rrp	pointer
->	O
priority	int
,	O
rrp	pointer
->	O
weight	int
,	O
rrp	pointer
->	O
port	int
)	O
;	O
CSP_ADDSTR	O
(	O
buf	pointer
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
cs_srvraw	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
adns_rr_srvraw	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
csp_srv_begin	function
(	O
vb	pointer
,	O
(	O
const	O
void	O
*	O
)	O
rrp	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
return	O
csp_domain	function
(	O
vb	pointer
,	O
rrp	pointer
->	O
host	pointer
)	O
;	O
}	O
static	O
adns_status	enum
cs_srvha	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
adns_rr_srvha	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
adns_status	enum
st	enum
;	O
st	enum
=	O
csp_srv_begin	function
(	O
vb	pointer
,	O
(	O
const	O
void	O
*	O
)	O
datap	pointer
)	O
;	O
if	O
(	O
st	enum
)	O
return	O
st	enum
;	O
return	O
csp_hostaddr	function
(	O
vb	pointer
,	O
&	O
rrp	pointer
->	O
ha	struct
)	O
;	O
}	O
static	O
void	O
postsort_srv	function
(	O
adns_state	pointer
ads	pointer
,	O
void	O
*	O
array	array
,	O
int	O
nrrs	int
,	O
const	O
struct	O
typeinfo	struct
*	O
typei	pointer
)	O
{	O
char	O
*	O
workbegin	pointer
,	O
*	O
workend	pointer
,	O
*	O
search	pointer
,	O
*	O
arrayend	pointer
;	O
const	O
adns_rr_srvha	struct
*	O
rr	struct
;	O
union	O
{	O
adns_rr_srvha	struct
ha	struct
;	O
adns_rr_srvraw	struct
raw	struct
;	O
}	O
rrtmp	union
;	O
int	O
cpriority	int
,	O
totalweight	int
,	O
runtotal	int
;	O
long	O
randval	long
;	O
for	O
(	O
workbegin	pointer
=	O
array	array
,	O
arrayend	pointer
=	O
workbegin	pointer
+	O
typei	pointer
->	O
rrsz	int
*	O
nrrs	int
;	O
workbegin	pointer
<	O
arrayend	pointer
;	O
workbegin	pointer
=	O
workend	pointer
)	O
{	O
cpriority	int
=	O
(	O
rr	struct
=	O
(	O
void	O
*	O
)	O
workbegin	pointer
)	O
->	O
priority	int
;	O
for	O
(	O
workend	pointer
=	O
workbegin	pointer
,	O
totalweight	int
=	O
0	int
;	O
workend	pointer
<	O
arrayend	pointer
&&	O
(	O
rr	struct
=	O
(	O
void	O
*	O
)	O
workend	pointer
)	O
->	O
priority	int
==	O
cpriority	int
;	O
workend	pointer
+=	O
typei	pointer
->	O
rrsz	int
)	O
{	O
totalweight	int
+=	O
rr	struct
->	O
weight	int
;	O
}	O
for	O
(	O
;	O
workbegin	pointer
+	O
typei	pointer
->	O
rrsz	int
<	O
workend	pointer
;	O
workbegin	pointer
+=	O
typei	pointer
->	O
rrsz	int
)	O
{	O
randval	long
=	O
nrand48	function
(	O
ads	pointer
->	O
rand48xsubi	array
)	O
;	O
randval	long
%=	O
(	O
totalweight	int
+	O
1	int
)	O
;	O
for	O
(	O
search	pointer
=	O
workbegin	pointer
,	O
runtotal	int
=	O
0	int
;	O
(	O
runtotal	int
+=	O
(	O
rr	struct
=	O
(	O
void	O
*	O
)	O
search	pointer
)	O
->	O
weight	int
)	O
<	O
randval	long
;	O
search	pointer
+=	O
typei	pointer
->	O
rrsz	int
)	O
;	O
assert	O
(	O
search	pointer
<	O
arrayend	pointer
)	O
;	O
totalweight	int
-=	O
rr	struct
->	O
weight	int
;	O
if	O
(	O
search	pointer
!=	O
workbegin	pointer
)	O
{	O
memcpy	function
(	O
&	O
rrtmp	union
,	O
workbegin	pointer
,	O
typei	pointer
->	O
rrsz	int
)	O
;	O
memcpy	function
(	O
workbegin	pointer
,	O
search	pointer
,	O
typei	pointer
->	O
rrsz	int
)	O
;	O
memcpy	function
(	O
search	pointer
,	O
&	O
rrtmp	union
,	O
typei	pointer
->	O
rrsz	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
mf_byteblock	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_byteblock	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
void	O
*	O
bytes	pointer
=	O
rrp	pointer
->	O
data	pointer
;	O
adns__makefinal_block	function
(	O
qu	pointer
,	O
&	O
bytes	pointer
,	O
rrp	pointer
->	O
len	int
)	O
;	O
rrp	pointer
->	O
data	pointer
=	O
bytes	pointer
;	O
}	O
static	O
adns_status	enum
pa_opaque	function
(	O
const	O
parseinfo	struct
*	O
pai	pointer
,	O
int	O
cbyte	int
,	O
int	O
max	int
,	O
void	O
*	O
datap	pointer
)	O
{	O
adns_rr_byteblock	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
rrp	pointer
->	O
len	int
=	O
max	int
-	O
cbyte	int
;	O
rrp	pointer
->	O
data	pointer
=	O
adns__alloc_interim	function
(	O
pai	pointer
->	O
qu	pointer
,	O
rrp	pointer
->	O
len	int
)	O
;	O
if	O
(	O
!	O
rrp	pointer
->	O
data	pointer
)	O
R_NOMEM	O
;	O
memcpy	function
(	O
rrp	pointer
->	O
data	pointer
,	O
pai	pointer
->	O
dgram	pointer
+	O
cbyte	int
,	O
rrp	pointer
->	O
len	int
)	O
;	O
return	O
adns_s_ok	int
;	O
}	O
static	O
adns_status	enum
cs_opaque	function
(	O
vbuf	struct
*	O
vb	pointer
,	O
const	O
void	O
*	O
datap	pointer
)	O
{	O
const	O
adns_rr_byteblock	struct
*	O
rrp	pointer
=	O
datap	pointer
;	O
char	O
buf	pointer
[	O
10	int
]	O
;	O
int	O
l	long
;	O
unsigned	O
char	O
*	O
p	pointer
;	O
sprintf	function
(	O
buf	pointer
,	O
"\\# %d"	pointer
,	O
rrp	pointer
->	O
len	int
)	O
;	O
CSP_ADDSTR	O
(	O
buf	pointer
)	O
;	O
for	O
(	O
l	long
=	O
rrp	pointer
->	O
len	int
,	O
p	pointer
=	O
rrp	pointer
->	O
data	pointer
;	O
l	long
>=	O
4	int
;	O
l	long
-=	O
4	int
,	O
p	pointer
+=	O
4	int
)	O
{	O
sprintf	function
(	O
buf	pointer
,	O
" %02x%02x%02x%02x"	pointer
,	O
p	pointer
[	O
0	int
]	O
,	O
p	pointer
[	O
1	int
]	O
,	O
p	pointer
[	O
2	int
]	O
,	O
p	pointer
[	O
3	int
]	O
)	O
;	O
CSP_ADDSTR	O
(	O
buf	pointer
)	O
;	O
}	O
for	O
(	O
;	O
l	long
>	O
0	int
;	O
l	long
--	O
,	O
p	pointer
++	O
)	O
{	O
sprintf	function
(	O
buf	pointer
,	O
" %02x"	pointer
,	O
*	O
p	pointer
)	O
;	O
CSP_ADDSTR	O
(	O
buf	pointer
)	O
;	O
}	O
return	O
adns_s_ok	int
;	O
}	O
static	O
void	O
mf_flat	function
(	O
adns_query	pointer
qu	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
}	O
static	O
const	O
typeinfo	struct
typeinfos	array
[	O
]	O
=	O
{	O
FLAT_TYPE	O
(	O
a	pointer
,	O
"A"	pointer
,	O
0	int
,	O
inaddr	pointer
,	O
pa_inaddr	function
,	O
di_inaddr	function
,	O
cs_inaddr	function
)	O
,	O
DEEP_TYPE	O
(	O
ns_raw	O
,	O
"NS"	pointer
,	O
"raw"	pointer
,	O
str	pointer
,	O
pa_host_raw	function
,	O
0	int
,	O
cs_domain	function
)	O
,	O
DEEP_TYPE	O
(	O
cname	pointer
,	O
"CNAME"	pointer
,	O
0	int
,	O
str	pointer
,	O
pa_dom_raw	function
,	O
0	int
,	O
cs_domain	function
)	O
,	O
DEEP_TYPE	O
(	O
soa_raw	O
,	O
"SOA"	pointer
,	O
"raw"	pointer
,	O
soa	pointer
,	O
pa_soa	function
,	O
0	int
,	O
cs_soa	function
)	O
,	O
DEEP_TYPE	O
(	O
ptr_raw	O
,	O
"PTR"	pointer
,	O
"raw"	pointer
,	O
str	pointer
,	O
pa_host_raw	function
,	O
0	int
,	O
cs_domain	function
)	O
,	O
DEEP_TYPE	O
(	O
hinfo	O
,	O
"HINFO"	pointer
,	O
0	int
,	O
intstrpair	pointer
,	O
pa_hinfo	function
,	O
0	int
,	O
cs_hinfo	function
)	O
,	O
DEEP_TYPE	O
(	O
mx_raw	O
,	O
"MX"	pointer
,	O
"raw"	pointer
,	O
intstr	pointer
,	O
pa_mx_raw	function
,	O
di_mx_raw	function
,	O
cs_inthost	function
)	O
,	O
DEEP_TYPE	O
(	O
txt	O
,	O
"TXT"	pointer
,	O
0	int
,	O
manyistr	pointer
,	O
pa_txt	function
,	O
0	int
,	O
cs_txt	function
)	O
,	O
DEEP_TYPE	O
(	O
rp_raw	O
,	O
"RP"	pointer
,	O
"raw"	pointer
,	O
strpair	pointer
,	O
pa_rp	function
,	O
0	int
,	O
cs_rp	function
)	O
,	O
XTRA_TYPE	O
(	O
srv_raw	O
,	O
"SRV"	pointer
,	O
"raw"	pointer
,	O
srvraw	pointer
,	O
pa_srvraw	function
,	O
di_srv	function
,	O
cs_srvraw	function
,	O
qdpl_srv	function
,	O
postsort_srv	function
)	O
,	O
FLAT_TYPE	O
(	O
addr	union
,	O
"A"	pointer
,	O
"addr"	pointer
,	O
addr	union
,	O
pa_addr	function
,	O
di_addr	function
,	O
cs_addr	function
)	O
,	O
DEEP_TYPE	O
(	O
ns	O
,	O
"NS"	pointer
,	O
"+addr"	pointer
,	O
hostaddr	pointer
,	O
pa_hostaddr	function
,	O
di_hostaddr	function
,	O
cs_hostaddr	function
)	O
,	O
DEEP_TYPE	O
(	O
ptr	O
,	O
"PTR"	pointer
,	O
"checked"	pointer
,	O
str	pointer
,	O
pa_ptr	function
,	O
0	int
,	O
cs_domain	function
)	O
,	O
DEEP_TYPE	O
(	O
mx	O
,	O
"MX"	pointer
,	O
"+addr"	pointer
,	O
inthostaddr	pointer
,	O
pa_mx	function
,	O
di_mx	function
,	O
cs_inthostaddr	function
)	O
,	O
XTRA_TYPE	O
(	O
srv	O
,	O
"SRV"	pointer
,	O
"+addr"	pointer
,	O
srvha	pointer
,	O
pa_srvha	function
,	O
di_srv	function
,	O
cs_srvha	function
,	O
qdpl_srv	function
,	O
postsort_srv	function
)	O
,	O
DEEP_TYPE	O
(	O
soa	pointer
,	O
"SOA"	pointer
,	O
"822"	pointer
,	O
soa	pointer
,	O
pa_soa	function
,	O
0	int
,	O
cs_soa	function
)	O
,	O
DEEP_TYPE	O
(	O
rp	O
,	O
"RP"	pointer
,	O
"822"	pointer
,	O
strpair	pointer
,	O
pa_rp	function
,	O
0	int
,	O
cs_rp	function
)	O
,	O
}	O
;	O
static	O
const	O
typeinfo	struct
typeinfo_unknown	struct
=	O
DEEP_TYPE	O
(	O
unknown	O
,	O
0	int
,	O
"unknown"	pointer
,	O
byteblock	pointer
,	O
pa_opaque	function
,	O
0	int
,	O
cs_opaque	function
)	O
;	O
const	O
typeinfo	struct
*	O
adns__findtype	function
(	O
adns_rrtype	enum
type	enum
)	O
{	O
const	O
typeinfo	struct
*	O
begin	pointer
,	O
*	O
end	pointer
,	O
*	O
mid	pointer
;	O
if	O
(	O
type	enum
&	O
adns_r_unknown	int
)	O
return	O
&	O
typeinfo_unknown	struct
;	O
begin	pointer
=	O
typeinfos	array
;	O
end	pointer
=	O
typeinfos	array
+	O
(	O
sizeof	O
(	O
typeinfos	array
)	O
/	O
sizeof	O
(	O
typeinfo	struct
)	O
)	O
;	O
while	O
(	O
begin	pointer
<	O
end	pointer
)	O
{	O
mid	pointer
=	O
begin	pointer
+	O
(	O
(	O
end	pointer
-	O
begin	pointer
)	O
>>	O
1	int
)	O
;	O
if	O
(	O
mid	pointer
->	O
typekey	enum
==	O
type	enum
)	O
return	O
mid	pointer
;	O
if	O
(	O
type	enum
>	O
mid	pointer
->	O
typekey	enum
)	O
begin	pointer
=	O
mid	pointer
+	O
1	int
;	O
else	O
end	pointer
=	O
mid	pointer
;	O
}	O
return	O
0	int
;	O
}	O
