struct	O
pipe	function
{	O
int	O
pin	int
;	O
FILE	struct
*	O
fpin	pointer
;	O
int	O
pout	int
;	O
int	O
perr	int
;	O
FILE	struct
*	O
fperr	pointer
;	O
int	O
cin	int
;	O
int	O
cout	int
;	O
int	O
cerr	int
;	O
fd_set	struct
error_set	struct
;	O
}	O
;	O
typedef	O
struct	O
pipe	function
pipe_t	struct
;	O
static	O
char	O
*	O
xstrdup	function
(	O
const	O
char	O
*	O
)	O
;	O
static	O
void	O
*	O
xmalloc	function
(	O
size_t	long
)	O
;	O
static	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
,	O
size_t	long
)	O
;	O
static	O
void	O
error	function
(	O
int	O
status	int
,	O
int	O
errnum	int
,	O
const	O
char	O
*	O
message	pointer
,	O
...	O
)	O
;	O
static	O
void	O
sig_chld	function
(	O
int	O
)	O
;	O
static	O
void	O
sig_pipe	function
(	O
int	O
)	O
;	O
void	O
new_pipe	function
(	O
pipe_t	struct
*	O
)	O
;	O
void	O
parent	function
(	O
pipe_t	struct
*	O
,	O
int	O
,	O
char	O
*	O
*	O
)	O
;	O
void	O
read_file	function
(	O
pipe_t	struct
*	O
,	O
FILE	struct
*	O
,	O
char	O
*	O
)	O
;	O
void	O
read_ispell	function
(	O
pipe_t	struct
*	O
,	O
char	O
*	O
,	O
int	O
)	O
;	O
void	O
read_ispell_errors	function
(	O
pipe_t	struct
*	O
)	O
;	O
void	O
run_ispell_in_child	function
(	O
pipe_t	struct
*	O
)	O
;	O
const	O
struct	O
option	struct
long_options	array
[	O
]	O
=	O
{	O
{	O
"all-chains"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
{	O
"british"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'b'	O
}	O
,	O
{	O
"dictionary"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'h'	O
}	O
,	O
{	O
"ispell"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'i'	O
}	O
,	O
{	O
"ispell-version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'I'	O
}	O
,	O
{	O
"number"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
{	O
"print-file-name"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
{	O
"print-stems"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
{	O
"stop-list"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
{	O
"verbose"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'v'	O
}	O
,	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'V'	O
}	O
,	O
{	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
0	int
}	O
}	O
;	O
char	O
*	O
program_name	pointer
=	O
NULL	O
;	O
char	O
*	O
ispell_prog	pointer
=	O
NULL	O
;	O
char	O
*	O
dictionary	pointer
=	O
NULL	O
;	O
int	O
show_ispell_version	int
=	O
0	int
;	O
int	O
read_stdin	int
=	O
0	int
;	O
int	O
british	int
=	O
0	int
;	O
int	O
verbose	int
=	O
0	int
;	O
int	O
number_lines	int
=	O
0	int
;	O
int	O
print_file_names	int
=	O
0	int
;	O
int	O
interactive	int
=	O
0	int
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
opt	int
=	O
0	int
;	O
int	O
opt_error	int
=	O
0	int
;	O
int	O
show_help	int
=	O
0	int
;	O
int	O
show_version	int
=	O
0	int
;	O
pid_t	int
pid	int
=	O
0	int
;	O
pipe_t	struct
ispell_pipe	struct
;	O
program_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
while	O
(	O
1	int
)	O
{	O
opt	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"IVbdhilnosvx"	pointer
,	O
long_options	array
,	O
(	O
int	O
*	O
)	O
0	int
)	O
;	O
if	O
(	O
opt	int
==	O
EOF	O
)	O
break	O
;	O
switch	O
(	O
opt	int
)	O
{	O
case	O
'I'	O
:	O
show_ispell_version	int
=	O
1	int
;	O
break	O
;	O
case	O
'V'	O
:	O
show_version	int
=	O
1	int
;	O
break	O
;	O
case	O
'b'	O
:	O
british	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
if	O
(	O
optarg	pointer
!=	O
NULL	O
)	O
dictionary	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
else	O
error	function
(	O
0	int
,	O
0	int
,	O
"option argument not given"	pointer
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
show_help	int
=	O
1	int
;	O
break	O
;	O
case	O
'i'	O
:	O
if	O
(	O
optarg	pointer
!=	O
NULL	O
)	O
ispell_prog	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
else	O
error	function
(	O
0	int
,	O
0	int
,	O
"option argument not given"	pointer
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
break	O
;	O
case	O
'n'	O
:	O
number_lines	int
=	O
1	int
;	O
break	O
;	O
case	O
'o'	O
:	O
print_file_names	int
=	O
1	int
;	O
break	O
;	O
case	O
's'	O
:	O
break	O
;	O
case	O
'v'	O
:	O
verbose	int
=	O
1	int
;	O
break	O
;	O
case	O
'x'	O
:	O
break	O
;	O
default	O
:	O
opt_error	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
opt_error	int
)	O
{	O
printf	function
(	O
"Try `%s --help' for more information.\n"	pointer
,	O
program_name	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
show_version	int
)	O
{	O
puts	function
(	O
"GNU Spell "	pointer
VERSION	pointer
"\n"	pointer
"Copyright (C) 1996,2010 Free Software Foundation, Inc.\n"	pointer
"License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n"	pointer
"This is free software: you are free to change and redistribute it.\n"	pointer
"There is NO WARRANTY, to the extent permitted by law.\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
show_help	int
)	O
{	O
printf	function
(	O
"Usage: %s [OPTION]... [FILE]...\n"	pointer
,	O
program_name	pointer
)	O
;	O
puts	function
(	O
"This is GNU Spell, a Unix spell emulator.\n\n"	pointer
"  -I, --ispell-version\t\tPrint Ispell's version.\n"	pointer
"  -V, --version\t\t\tPrint the version number.\n"	pointer
"  -b, --british\t\t\tUse the British dictionary.\n"	pointer
"  -d, --dictionary=FILE\t\tUse FILE to look up words.\n"	pointer
"  -h, --help\t\t\tPrint a summary of the options.\n"	pointer
"  -i, --ispell=PROGRAM\t\tCalls PROGRAM as Ispell.\n"	pointer
"  -l, --all-chains\t\tIgnored; for compatibility.\n"	pointer
"  -n, --number\t\t\tPrint line numbers before lines.\n"	pointer
"  -o, --print-file-name\t\tPrint file names before lines.\n"	pointer
"  -s, --stop-list=FILE\t\tIgnored; for compatibility.\n"	pointer
"  -v, --verbose\t\t\tPrint words not literally found.\n"	pointer
"  -x, --print-stems\t\tIgnored; for compatibility.\n\n"	pointer
"Please use Info to read more (type `info spell').\n"	pointer
"Report bugs to: cate@gnu.org\n"	pointer
"spell home page: <http://www.gnu.org/software/spell/>\n"	pointer
"General help using GNU software: <http://www.gnu.org/gethelp/>\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
if	O
(	O
!	O
ispell_prog	pointer
)	O
ispell_prog	pointer
=	O
"ispell"	pointer
;	O
new_pipe	function
(	O
&	O
ispell_pipe	struct
)	O
;	O
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error forking to run Ispell"	pointer
)	O
;	O
else	O
if	O
(	O
pid	int
>	O
0	int
)	O
parent	function
(	O
&	O
ispell_pipe	struct
,	O
argc	int
,	O
argv	pointer
)	O
;	O
else	O
run_ispell_in_child	function
(	O
&	O
ispell_pipe	struct
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
void	O
read_file	function
(	O
pipe_t	struct
*	O
the_pipe	pointer
,	O
FILE	struct
*	O
stream	pointer
,	O
char	O
*	O
file	pointer
)	O
{	O
size_t	long
buff_size	long
=	O
INITIAL_BUFF_SIZE	int
;	O
char	O
*	O
buff	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
[	O
INITIAL_BUFF_SIZE	int
]	O
)	O
)	O
;	O
ssize_t	long
len	long
,	O
rlen	long
,	O
zlen	long
;	O
char	O
*	O
wbuff	pointer
;	O
unsigned	O
long	O
line	long
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
len	long
=	O
getline	function
(	O
&	O
buff	pointer
,	O
&	O
buff_size	long
,	O
stream	pointer
)	O
;	O
line	long
++	O
;	O
if	O
(	O
len	long
<	O
0	int
)	O
{	O
if	O
(	O
feof	function
(	O
stream	pointer
)	O
)	O
{	O
free	function
(	O
buff	pointer
)	O
;	O
return	O
;	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"%s: error reading line"	pointer
,	O
file	pointer
)	O
;	O
}	O
}	O
if	O
(	O
len	long
>	O
0	int
&&	O
buff	pointer
[	O
len	long
-	O
1	int
]	O
!=	O
'\n'	O
)	O
{	O
if	O
(	O
len	long
>=	O
buff_size	long
-	O
1	int
)	O
buff	pointer
=	O
xrealloc	function
(	O
buff	pointer
,	O
buff_size	long
+=	O
16	int
)	O
;	O
buff	pointer
[	O
len	long
]	O
=	O
'\n'	O
;	O
len	long
++	O
;	O
}	O
wbuff	pointer
=	O
buff	pointer
;	O
rlen	long
=	O
0	int
;	O
zlen	long
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
rlen	long
=	O
strlen	function
(	O
wbuff	pointer
)	O
;	O
zlen	long
+=	O
rlen	long
;	O
if	O
(	O
zlen	long
>=	O
len	long
)	O
break	O
;	O
wbuff	pointer
[	O
rlen	long
]	O
=	O
' '	O
;	O
wbuff	pointer
+=	O
rlen	long
;	O
}	O
rlen	long
=	O
write	function
(	O
the_pipe	pointer
->	O
pout	int
,	O
"^"	pointer
,	O
1	int
)	O
;	O
if	O
(	O
rlen	long
<=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error writing to Ispell"	pointer
)	O
;	O
wbuff	pointer
=	O
buff	pointer
;	O
while	O
(	O
len	long
>	O
0	int
)	O
{	O
rlen	long
=	O
write	function
(	O
the_pipe	pointer
->	O
pout	int
,	O
wbuff	pointer
,	O
len	long
)	O
;	O
if	O
(	O
rlen	long
<=	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error writing to Ispell"	pointer
)	O
;	O
len	long
-=	O
rlen	long
;	O
wbuff	pointer
+=	O
rlen	long
;	O
}	O
fsync	function
(	O
the_pipe	pointer
->	O
pout	int
)	O
;	O
read_ispell_errors	function
(	O
the_pipe	pointer
)	O
;	O
read_ispell	function
(	O
the_pipe	pointer
,	O
file	pointer
,	O
line	long
)	O
;	O
read_ispell_errors	function
(	O
the_pipe	pointer
)	O
;	O
}	O
if	O
(	O
fclose	function
(	O
stream	pointer
)	O
==	O
EOF	O
)	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s: close error"	pointer
,	O
file	pointer
)	O
;	O
free	function
(	O
buff	pointer
)	O
;	O
}	O
void	O
read_ispell	function
(	O
pipe_t	struct
*	O
ispell_pipe	struct
,	O
char	O
*	O
file	pointer
,	O
int	O
line	long
)	O
{	O
size_t	long
buff_size	long
=	O
INITIAL_BUFF_SIZE	int
;	O
char	O
*	O
buff	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
[	O
INITIAL_BUFF_SIZE	int
]	O
)	O
)	O
;	O
ssize_t	long
len	long
;	O
char	O
b0	char
;	O
while	O
(	O
1	int
)	O
{	O
len	long
=	O
getline	function
(	O
&	O
buff	pointer
,	O
&	O
buff_size	long
,	O
ispell_pipe	struct
->	O
fpin	pointer
)	O
;	O
if	O
(	O
len	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
feof	function
(	O
ispell_pipe	struct
->	O
fpin	pointer
)	O
)	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
else	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error reading data from ispell/aspell"	pointer
)	O
;	O
}	O
b0	char
=	O
buff	pointer
[	O
0	int
]	O
;	O
if	O
(	O
len	long
==	O
1	int
&&	O
b0	char
==	O
'\n'	O
)	O
{	O
free	function
(	O
buff	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
b0	char
==	O
'*'	O
||	O
b0	char
==	O
'+'	O
||	O
b0	char
==	O
'-'	O
)	O
continue	O
;	O
if	O
(	O
b0	char
==	O
'&'	O
||	O
b0	char
==	O
'#'	O
||	O
(	O
b0	char
==	O
'?'	O
&&	O
verbose	int
)	O
)	O
{	O
int	O
pos	int
;	O
if	O
(	O
print_file_names	int
)	O
{	O
printf	function
(	O
"%s:"	pointer
,	O
file	pointer
)	O
;	O
if	O
(	O
!	O
number_lines	int
)	O
putchar	function
(	O
' '	O
)	O
;	O
}	O
if	O
(	O
number_lines	int
)	O
printf	function
(	O
"%d: "	pointer
,	O
line	long
)	O
;	O
for	O
(	O
pos	int
=	O
2	int
;	O
buff	pointer
[	O
pos	int
]	O
!=	O
' '	O
;	O
pos	int
++	O
)	O
putchar	function
(	O
buff	pointer
[	O
pos	int
]	O
)	O
;	O
putchar	function
(	O
'\n'	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
b0	char
==	O
'?'	O
&&	O
!	O
verbose	int
)	O
continue	O
;	O
error	function
(	O
0	int
,	O
0	int
,	O
"unrecognized Ispell line `%s'"	pointer
,	O
buff	pointer
)	O
;	O
}	O
free	function
(	O
buff	pointer
)	O
;	O
}	O
void	O
read_ispell_errors	function
(	O
pipe_t	struct
*	O
the_pipe	pointer
)	O
{	O
struct	O
timeval	struct
time_out	struct
;	O
size_t	long
buff_size	long
=	O
INITIAL_BUFF_SIZE	int
;	O
char	O
*	O
buff	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
[	O
INITIAL_BUFF_SIZE	int
]	O
)	O
)	O
;	O
ssize_t	long
len	long
;	O
time_out	struct
.	O
tv_sec	long
=	O
time_out	struct
.	O
tv_usec	long
=	O
0	int
;	O
while	O
(	O
select	function
(	O
FD_SETSIZE	O
,	O
&	O
(	O
the_pipe	pointer
->	O
error_set	struct
)	O
,	O
NULL	O
,	O
NULL	O
,	O
&	O
time_out	struct
)	O
==	O
1	int
)	O
{	O
len	long
=	O
getline	function
(	O
&	O
buff	pointer
,	O
&	O
buff_size	long
,	O
the_pipe	pointer
->	O
fperr	pointer
)	O
;	O
if	O
(	O
len	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
feof	function
(	O
the_pipe	pointer
->	O
fperr	pointer
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"premature EOF from Ispell's stderr"	pointer
)	O
;	O
else	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error reading errors of ispell/aspell"	pointer
)	O
;	O
}	O
if	O
(	O
len	long
>	O
1	int
&&	O
buff	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'\r'	O
||	O
buff	pointer
[	O
len	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
if	O
(	O
len	long
>	O
2	int
&&	O
buff	pointer
[	O
len	long
-	O
2	int
]	O
==	O
'\r'	O
||	O
buff	pointer
[	O
len	long
-	O
2	int
]	O
==	O
'\n'	O
)	O
len	long
-=	O
2	int
;	O
else	O
len	long
-=	O
1	int
;	O
buff	pointer
[	O
len	long
]	O
=	O
0	int
;	O
}	O
if	O
(	O
!	O
memcmp	function
(	O
buff	pointer
,	O
"Can't open "	pointer
,	O
strlen	function
(	O
"Can't open "	pointer
)	O
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"%s: cannot open"	pointer
,	O
buff	pointer
+	O
strlen	function
(	O
"Can't open "	pointer
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
ispell_prog	pointer
,	O
buff	pointer
)	O
;	O
}	O
free	function
(	O
buff	pointer
)	O
;	O
}	O
void	O
new_pipe	function
(	O
pipe_t	struct
*	O
the_pipe	pointer
)	O
{	O
int	O
ifd	array
[	O
2	int
]	O
;	O
int	O
ofd	array
[	O
2	int
]	O
;	O
int	O
efd	array
[	O
2	int
]	O
;	O
if	O
(	O
signal	function
(	O
SIGPIPE	int
,	O
sig_pipe	function
)	O
==	O
SIG_ERR	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error creating SIGPIPE handler"	pointer
)	O
;	O
if	O
(	O
signal	function
(	O
SIGCHLD	int
,	O
sig_chld	function
)	O
==	O
SIG_ERR	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error creating SIGCHLD handler"	pointer
)	O
;	O
if	O
(	O
pipe	function
(	O
ifd	array
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error creating pipe to Ispell"	pointer
)	O
;	O
the_pipe	pointer
->	O
pin	int
=	O
ifd	array
[	O
0	int
]	O
;	O
the_pipe	pointer
->	O
cout	int
=	O
ifd	array
[	O
1	int
]	O
;	O
the_pipe	pointer
->	O
fpin	pointer
=	O
fdopen	function
(	O
the_pipe	pointer
->	O
pin	int
,	O
"r"	pointer
)	O
;	O
if	O
(	O
the_pipe	pointer
->	O
fpin	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error opening the pipe to Ispell"	pointer
)	O
;	O
if	O
(	O
pipe	function
(	O
ofd	array
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error creating pipe to Ispell"	pointer
)	O
;	O
the_pipe	pointer
->	O
cin	int
=	O
ofd	array
[	O
0	int
]	O
;	O
the_pipe	pointer
->	O
pout	int
=	O
ofd	array
[	O
1	int
]	O
;	O
if	O
(	O
pipe	function
(	O
efd	array
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error creating pipe to Ispell"	pointer
)	O
;	O
the_pipe	pointer
->	O
perr	int
=	O
efd	array
[	O
0	int
]	O
;	O
the_pipe	pointer
->	O
cerr	int
=	O
efd	array
[	O
1	int
]	O
;	O
the_pipe	pointer
->	O
fperr	pointer
=	O
fdopen	function
(	O
the_pipe	pointer
->	O
perr	int
,	O
"r"	pointer
)	O
;	O
if	O
(	O
the_pipe	pointer
->	O
fperr	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error opening the error pipe to Ispell"	pointer
)	O
;	O
FD_ZERO	O
(	O
&	O
(	O
the_pipe	pointer
->	O
error_set	struct
)	O
)	O
;	O
FD_SET	O
(	O
the_pipe	pointer
->	O
perr	int
,	O
&	O
(	O
the_pipe	pointer
->	O
error_set	struct
)	O
)	O
;	O
}	O
static	O
void	O
sig_pipe	function
(	O
int	O
signo	int
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"broken pipe"	pointer
)	O
;	O
}	O
static	O
void	O
sig_chld	function
(	O
int	O
signo	int
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"Ispell died"	pointer
)	O
;	O
}	O
void	O
parent	function
(	O
pipe_t	struct
*	O
the_pipe	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
FILE	struct
*	O
stream	pointer
;	O
char	O
*	O
file	pointer
=	O
NULL	O
;	O
int	O
arg_error	int
=	O
0	int
;	O
int	O
arg_index	int
=	O
optind	int
;	O
close	function
(	O
the_pipe	pointer
->	O
cin	int
)	O
;	O
close	function
(	O
the_pipe	pointer
->	O
cout	int
)	O
;	O
close	function
(	O
the_pipe	pointer
->	O
cerr	int
)	O
;	O
read_ispell_errors	function
(	O
the_pipe	pointer
)	O
;	O
{	O
size_t	long
buff_size	long
=	O
INITIAL_BUFF_SIZE	int
;	O
char	O
*	O
buff	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
char	O
[	O
INITIAL_BUFF_SIZE	int
]	O
)	O
)	O
;	O
ssize_t	long
len	long
;	O
size_t	long
ipos	long
=	O
0	int
;	O
size_t	long
fpos	long
;	O
len	long
=	O
getline	function
(	O
&	O
buff	pointer
,	O
&	O
buff_size	long
,	O
the_pipe	pointer
->	O
fpin	pointer
)	O
;	O
if	O
(	O
len	long
==	O
-	O
1	int
)	O
{	O
if	O
(	O
feof	function
(	O
the_pipe	pointer
->	O
fpin	pointer
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"premature EOF from Ispell's stdout"	pointer
)	O
;	O
else	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error reading errors of ispell/aspell"	pointer
)	O
;	O
}	O
if	O
(	O
show_ispell_version	int
)	O
{	O
for	O
(	O
;	O
!	O
isdigit	function
(	O
buff	pointer
[	O
ipos	long
]	O
)	O
&&	O
ipos	long
<	O
len	long
;	O
ipos	long
++	O
)	O
;	O
fpos	long
=	O
ipos	long
;	O
for	O
(	O
;	O
buff	pointer
[	O
fpos	long
]	O
!=	O
' '	O
&&	O
fpos	long
<	O
len	long
;	O
fpos	long
++	O
)	O
;	O
buff	pointer
[	O
fpos	long
]	O
=	O
0	int
;	O
printf	function
(	O
"%s: Ispell version %s\n"	pointer
,	O
program_name	pointer
,	O
buff	pointer
+	O
ipos	long
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
}	O
free	function
(	O
buff	pointer
)	O
;	O
}	O
if	O
(	O
argc	int
==	O
1	int
)	O
read_file	function
(	O
the_pipe	pointer
,	O
stdin	pointer
,	O
"-"	pointer
)	O
;	O
while	O
(	O
arg_index	int
<	O
argc	int
)	O
{	O
arg_error	int
=	O
0	int
;	O
file	pointer
=	O
argv	pointer
[	O
arg_index	int
]	O
;	O
if	O
(	O
file	pointer
[	O
0	int
]	O
==	O
'-'	O
&&	O
file	pointer
[	O
1	int
]	O
==	O
0	int
)	O
{	O
read_stdin	int
=	O
1	int
;	O
stream	pointer
=	O
stdin	pointer
;	O
}	O
else	O
{	O
struct	O
stat	struct
stat_buf	struct
;	O
if	O
(	O
stat	struct
(	O
file	pointer
,	O
&	O
stat_buf	struct
)	O
==	O
-	O
1	int
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s: stat error"	pointer
,	O
file	pointer
)	O
;	O
arg_index	int
++	O
;	O
continue	O
;	O
}	O
if	O
(	O
S_ISDIR	O
(	O
stat_buf	struct
.	O
st_mode	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
"%s: is a directory"	pointer
,	O
file	pointer
)	O
;	O
arg_index	int
++	O
;	O
continue	O
;	O
}	O
stream	pointer
=	O
fopen	function
(	O
file	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
stream	pointer
)	O
{	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s: open error"	pointer
,	O
file	pointer
)	O
;	O
arg_error	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
arg_error	int
)	O
read_file	function
(	O
the_pipe	pointer
,	O
stream	pointer
,	O
file	pointer
)	O
;	O
arg_index	int
++	O
;	O
}	O
}	O
void	O
run_ispell_in_child	function
(	O
pipe_t	struct
*	O
the_pipe	pointer
)	O
{	O
close	function
(	O
the_pipe	pointer
->	O
pin	int
)	O
;	O
close	function
(	O
the_pipe	pointer
->	O
pout	int
)	O
;	O
close	function
(	O
the_pipe	pointer
->	O
perr	int
)	O
;	O
if	O
(	O
the_pipe	pointer
->	O
cin	int
!=	O
STDIN_FILENO	int
)	O
if	O
(	O
dup2	function
(	O
the_pipe	pointer
->	O
cin	int
,	O
STDIN_FILENO	int
)	O
!=	O
STDIN_FILENO	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error duping to stdin"	pointer
)	O
;	O
if	O
(	O
the_pipe	pointer
->	O
cout	int
!=	O
STDOUT_FILENO	int
)	O
if	O
(	O
dup2	function
(	O
the_pipe	pointer
->	O
cout	int
,	O
STDOUT_FILENO	int
)	O
!=	O
STDOUT_FILENO	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error duping to stdout"	pointer
)	O
;	O
if	O
(	O
the_pipe	pointer
->	O
cerr	int
!=	O
STDERR_FILENO	int
)	O
if	O
(	O
dup2	function
(	O
the_pipe	pointer
->	O
cerr	int
,	O
STDERR_FILENO	int
)	O
!=	O
STDERR_FILENO	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error duping to stderr"	pointer
)	O
;	O
if	O
(	O
dictionary	pointer
!=	O
NULL	O
)	O
if	O
(	O
execlp	function
(	O
ispell_prog	pointer
,	O
"ispell"	pointer
,	O
"-a"	pointer
,	O
"-p"	pointer
,	O
dictionary	pointer
,	O
NULL	O
)	O
<	O
0	int
)	O
if	O
(	O
errno	O
!=	O
ENOENT	int
||	O
execlp	function
(	O
"aspell"	pointer
,	O
"aspell"	pointer
,	O
"-a"	pointer
,	O
"-p"	pointer
,	O
dictionary	pointer
,	O
NULL	O
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error executing ispell/aspell"	pointer
)	O
;	O
if	O
(	O
british	int
)	O
if	O
(	O
execlp	function
(	O
ispell_prog	pointer
,	O
"ispell"	pointer
,	O
"-a"	pointer
,	O
"-d"	pointer
,	O
"british"	pointer
,	O
NULL	O
)	O
<	O
0	int
)	O
if	O
(	O
errno	O
!=	O
ENOENT	int
||	O
execlp	function
(	O
"aspell"	pointer
,	O
"aspell"	pointer
,	O
"-a"	pointer
,	O
"-d"	pointer
,	O
"british"	pointer
,	O
NULL	O
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error executing ispell/aspell"	pointer
)	O
;	O
if	O
(	O
execlp	function
(	O
ispell_prog	pointer
,	O
"ispell"	pointer
,	O
"-a"	pointer
,	O
NULL	O
)	O
<	O
0	int
)	O
if	O
(	O
errno	O
!=	O
ENOENT	int
||	O
execlp	function
(	O
"aspell"	pointer
,	O
"aspell"	pointer
,	O
"-a"	pointer
,	O
NULL	O
)	O
<	O
0	int
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"error executing ispell/aspell"	pointer
)	O
;	O
}	O
static	O
void	O
error	function
(	O
int	O
status	int
,	O
int	O
errnum	int
,	O
const	O
char	O
*	O
message	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
;	O
va_start	O
(	O
args	array
,	O
message	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
message	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
if	O
(	O
errnum	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
": %s"	pointer
,	O
strerror	function
(	O
errnum	int
)	O
)	O
;	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
if	O
(	O
status	int
)	O
exit	function
(	O
status	int
)	O
;	O
}	O
static	O
void	O
*	O
xmalloc	function
(	O
size_t	long
size	long
)	O
{	O
void	O
*	O
ptr	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
!	O
ptr	pointer
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"virtual memory exhausted"	pointer
)	O
;	O
return	O
ptr	pointer
;	O
}	O
static	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
!	O
ptr	pointer
)	O
return	O
xmalloc	function
(	O
size	long
)	O
;	O
ptr	pointer
=	O
realloc	function
(	O
ptr	pointer
,	O
size	long
)	O
;	O
if	O
(	O
!	O
ptr	pointer
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"virtual memory exhausted"	pointer
)	O
;	O
return	O
ptr	pointer
;	O
}	O
static	O
char	O
*	O
xstrdup	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
ptr	pointer
=	O
strdup	function
(	O
str	pointer
)	O
;	O
if	O
(	O
!	O
ptr	pointer
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
errno	O
,	O
"virtual memory exhausted"	pointer
)	O
;	O
return	O
ptr	pointer
;	O
}	O
