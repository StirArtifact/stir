typedef	O
off_t	long
scm_t_off	long
;	O
struct	O
apply_data	struct
{	O
SCM	function
proc	int
;	O
SCM	function
arg	int
;	O
}	O
;	O
SCM	function
apply_catch_body	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
apply_data	struct
*	O
xp	pointer
=	O
data	pointer
;	O
return	O
scm_apply_0	function
(	O
xp	pointer
->	O
proc	int
,	O
xp	pointer
->	O
arg	int
)	O
;	O
}	O
static	O
SCM	function
eval_catch_handler	function
(	O
void	O
*	O
data	pointer
,	O
SCM	function
tag	int
,	O
SCM	function
throw_args	int
)	O
{	O
scm_handle_by_message_noexit	function
(	O
"dico"	pointer
,	O
tag	int
,	O
throw_args	int
)	O
;	O
longjmp	function
(	O
*	O
(	O
jmp_buf	array
*	O
)	O
data	pointer
,	O
1	int
)	O
;	O
}	O
struct	O
scheme_exec_data	struct
{	O
SCM	function
(	O
*	O
handler	pointer
)	O
(	O
void	O
*	O
data	pointer
)	O
;	O
void	O
*	O
data	pointer
;	O
SCM	function
result	pointer
;	O
}	O
;	O
static	O
SCM	function
scheme_safe_exec_body	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
scheme_exec_data	struct
*	O
ed	pointer
=	O
data	pointer
;	O
ed	pointer
->	O
result	pointer
=	O
ed	pointer
->	O
handler	pointer
(	O
ed	pointer
->	O
data	pointer
)	O
;	O
return	O
SCM_BOOL_F	O
;	O
}	O
static	O
int	O
guile_safe_exec	function
(	O
SCM	function
(	O
*	O
handler	pointer
)	O
(	O
void	O
*	O
data	pointer
)	O
,	O
void	O
*	O
data	pointer
,	O
SCM	function
*	O
result	pointer
)	O
{	O
jmp_buf	array
jmp_env	array
;	O
struct	O
scheme_exec_data	struct
ed	pointer
;	O
if	O
(	O
setjmp	function
(	O
jmp_env	array
)	O
)	O
return	O
1	int
;	O
ed	pointer
.	O
handler	pointer
=	O
handler	pointer
;	O
ed	pointer
.	O
data	pointer
=	O
data	pointer
;	O
scm_c_with_throw_handler	function
(	O
SCM_BOOL_T	O
,	O
scheme_safe_exec_body	function
,	O
(	O
void	O
*	O
)	O
&	O
ed	pointer
,	O
eval_catch_handler	function
,	O
&	O
jmp_env	array
,	O
0	int
)	O
;	O
if	O
(	O
result	pointer
)	O
*	O
result	pointer
=	O
ed	pointer
.	O
result	pointer
;	O
return	O
0	int
;	O
}	O
struct	O
load_closure	struct
{	O
char	O
*	O
filename	pointer
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
}	O
;	O
static	O
SCM	function
load_path_handler	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
load_closure	struct
*	O
lp	pointer
=	O
data	pointer
;	O
scm_set_program_arguments	function
(	O
lp	pointer
->	O
argc	int
,	O
lp	pointer
->	O
argv	pointer
,	O
lp	pointer
->	O
filename	pointer
)	O
;	O
scm_primitive_load_path	function
(	O
scm_from_locale_string	function
(	O
lp	pointer
->	O
filename	pointer
)	O
)	O
;	O
return	O
SCM_UNDEFINED	O
;	O
}	O
static	O
int	O
guile_load	function
(	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
args	pointer
)	O
{	O
struct	O
load_closure	struct
lc	struct
;	O
if	O
(	O
args	pointer
)	O
{	O
struct	O
wordsplit	function
ws	pointer
;	O
if	O
(	O
wordsplit	function
(	O
args	pointer
,	O
&	O
ws	pointer
,	O
WRDSF_DEFFLAGS	O
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
"wordsplit: %s"	pointer
,	O
wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
lc	struct
.	O
argc	int
=	O
ws	pointer
.	O
ws_wordc	O
;	O
lc	struct
.	O
argv	pointer
=	O
ws	pointer
.	O
ws_wordv	O
;	O
wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
}	O
else	O
{	O
lc	struct
.	O
argc	int
=	O
0	int
;	O
lc	struct
.	O
argv	pointer
=	O
NULL	O
;	O
}	O
lc	struct
.	O
filename	pointer
=	O
filename	pointer
;	O
return	O
guile_safe_exec	function
(	O
load_path_handler	function
,	O
&	O
lc	struct
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
_add_load_path	function
(	O
char	O
*	O
path	pointer
)	O
{	O
SCM	function
scm	int
,	O
path_scm	O
;	O
SCM	function
*	O
pscm	O
;	O
path_scm	O
=	O
SCM_VARIABLE_REF	function
(	O
scm_c_lookup	function
(	O
"%load-path"	pointer
)	O
)	O
;	O
for	O
(	O
scm	int
=	O
path_scm	O
;	O
scm	int
!=	O
SCM_EOL	O
;	O
scm	int
=	O
SCM_CDR	function
(	O
scm	int
)	O
)	O
{	O
SCM	function
val	pointer
=	O
SCM_CAR	function
(	O
scm	int
)	O
;	O
if	O
(	O
scm_is_string	function
(	O
val	pointer
)	O
)	O
{	O
char	O
*	O
s	pointer
=	O
scm_to_locale_string	function
(	O
val	pointer
)	O
;	O
int	O
res	int
=	O
strcmp	function
(	O
s	pointer
,	O
path	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
if	O
(	O
res	int
==	O
0	int
)	O
return	O
;	O
}	O
}	O
pscm	O
=	O
SCM_VARIABLE_LOC	function
(	O
scm_c_lookup	function
(	O
"%load-path"	pointer
)	O
)	O
;	O
*	O
pscm	O
=	O
scm_append	function
(	O
scm_list_3	function
(	O
path_scm	O
,	O
scm_list_1	function
(	O
scm_from_locale_string	function
(	O
path	pointer
)	O
)	O
,	O
SCM_EOL	O
)	O
)	O
;	O
}	O
static	O
void	O
memerr	function
(	O
const	O
char	O
*	O
fname	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: not enough memory"	pointer
)	O
,	O
fname	pointer
)	O
;	O
}	O
static	O
char	O
*	O
proc_name	function
(	O
SCM	function
proc	int
)	O
{	O
return	O
scm_to_locale_string	function
(	O
scm_symbol_to_string	function
(	O
scm_procedure_name	function
(	O
proc	int
)	O
)	O
)	O
;	O
}	O
static	O
void	O
str_rettype_error	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: invalid return type"	pointer
)	O
,	O
name	pointer
)	O
;	O
}	O
static	O
void	O
rettype_error	function
(	O
SCM	function
proc	int
)	O
{	O
char	O
*	O
name	pointer
=	O
proc_name	function
(	O
proc	int
)	O
;	O
str_rettype_error	function
(	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
}	O
static	O
int	O
guile_call_proc	function
(	O
SCM	function
*	O
result	pointer
,	O
SCM	function
proc	int
,	O
SCM	function
arglist	int
)	O
{	O
jmp_buf	array
jmp_env	array
;	O
struct	O
apply_data	struct
adata	struct
;	O
if	O
(	O
setjmp	function
(	O
jmp_env	array
)	O
)	O
{	O
char	O
*	O
name	pointer
=	O
proc_name	function
(	O
proc	int
)	O
;	O
dico_log	function
(	O
L_NOTICE	int
,	O
0	int
,	O
_	O
(	O
"procedure `%s' failed: see error output for details"	pointer
)	O
,	O
name	pointer
)	O
;	O
free	function
(	O
name	pointer
)	O
;	O
return	O
1	int
;	O
}	O
adata	struct
.	O
proc	int
=	O
proc	int
;	O
adata	struct
.	O
arg	int
=	O
arglist	int
;	O
*	O
result	pointer
=	O
scm_c_with_throw_handler	function
(	O
SCM_BOOL_T	O
,	O
apply_catch_body	function
,	O
&	O
adata	struct
,	O
eval_catch_handler	function
,	O
&	O
jmp_env	array
,	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
scm_t_bits	O
_guile_dico_key_tag	int
;	O
static	O
SCM	function
dico_new_scm_key	function
(	O
struct	O
dico_key	struct
*	O
*	O
pkey	pointer
)	O
{	O
struct	O
dico_key	struct
*	O
kptr	pointer
;	O
kptr	pointer
=	O
scm_gc_malloc	function
(	O
sizeof	O
(	O
*	O
kptr	pointer
)	O
,	O
"Dico key"	pointer
)	O
;	O
*	O
pkey	pointer
=	O
kptr	pointer
;	O
SCM_RETURN_NEWSMOB	function
(	O
_guile_dico_key_tag	int
,	O
kptr	pointer
)	O
;	O
}	O
static	O
size_t	long
_guile_dico_key_free	function
(	O
SCM	function
message_smob	int
)	O
{	O
struct	O
dico_key	struct
*	O
kp	pointer
=	O
(	O
struct	O
dico_key	struct
*	O
)	O
SCM_CDR	function
(	O
message_smob	int
)	O
;	O
dico_key_deinit	function
(	O
kp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_guile_dico_key_print	function
(	O
SCM	function
message_smob	int
,	O
SCM	function
port	pointer
,	O
scm_print_state	O
*	O
pstate	pointer
)	O
{	O
struct	O
dico_key	struct
*	O
kp	pointer
=	O
(	O
struct	O
dico_key	struct
*	O
)	O
SCM_CDR	function
(	O
message_smob	int
)	O
;	O
scm_puts	function
(	O
"#<key "	pointer
,	O
port	pointer
)	O
;	O
scm_puts	function
(	O
kp	pointer
->	O
strat	pointer
->	O
name	pointer
,	O
port	pointer
)	O
;	O
scm_puts	function
(	O
" ("	pointer
,	O
port	pointer
)	O
;	O
scm_puts	function
(	O
kp	pointer
->	O
word	pointer
,	O
port	pointer
)	O
;	O
scm_puts	function
(	O
")>"	pointer
,	O
port	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
_guile_init_dico_key	function
(	O
void	O
)	O
{	O
_guile_dico_key_tag	int
=	O
scm_make_smob_type	function
(	O
"Dico key"	pointer
,	O
sizeof	O
(	O
struct	O
dico_key	struct
)	O
)	O
;	O
scm_set_smob_free	function
(	O
_guile_dico_key_tag	int
,	O
_guile_dico_key_free	function
)	O
;	O
scm_set_smob_print	function
(	O
_guile_dico_key_tag	int
,	O
_guile_dico_key_print	function
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_dico_key_p	O
,	O
"dico-key?"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	function
obj	O
)	O
,	O
"Return @samp{#t} if @var{obj} is a selection key."	pointer
)	O
{	O
return	O
CELL_IS_KEY	O
(	O
obj	O
)	O
?	O
SCM_BOOL_T	O
:	O
SCM_BOOL_F	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_dico_key__word	O
,	O
"dico-key->word"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	function
key	pointer
)	O
,	O
"Return search word from the @var{key}."	pointer
)	O
{	O
struct	O
dico_key	struct
*	O
kp	pointer
;	O
SCM_ASSERT	function
(	O
CELL_IS_KEY	O
(	O
key	pointer
)	O
,	O
key	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
kp	pointer
=	O
(	O
struct	O
dico_key	struct
*	O
)	O
SCM_CDR	function
(	O
key	pointer
)	O
;	O
return	O
scm_from_locale_string	function
(	O
kp	pointer
->	O
word	pointer
)	O
;	O
}	O
scm_t_bits	O
_guile_strategy_tag	int
;	O
struct	O
_guile_strategy	struct
{	O
dico_strategy_t	pointer
strat	pointer
;	O
}	O
;	O
static	O
SCM	function
_make_strategy	function
(	O
const	O
dico_strategy_t	pointer
strat	pointer
)	O
{	O
struct	O
_guile_strategy	struct
*	O
sp	pointer
;	O
sp	pointer
=	O
scm_gc_malloc	function
(	O
sizeof	O
(	O
struct	O
_guile_strategy	struct
)	O
,	O
"strategy"	pointer
)	O
;	O
sp	pointer
->	O
strat	pointer
=	O
strat	pointer
;	O
SCM_RETURN_NEWSMOB	function
(	O
_guile_strategy_tag	int
,	O
sp	pointer
)	O
;	O
}	O
static	O
size_t	long
_guile_strategy_free	function
(	O
SCM	function
message_smob	int
)	O
{	O
return	O
0	int
;	O
}	O
static	O
int	O
_guile_strategy_print	function
(	O
SCM	function
message_smob	int
,	O
SCM	function
port	pointer
,	O
scm_print_state	O
*	O
pstate	pointer
)	O
{	O
struct	O
_guile_strategy	struct
*	O
sp	pointer
=	O
(	O
struct	O
_guile_strategy	struct
*	O
)	O
SCM_CDR	function
(	O
message_smob	int
)	O
;	O
scm_puts	function
(	O
"#<strategy "	pointer
,	O
port	pointer
)	O
;	O
scm_puts	function
(	O
sp	pointer
->	O
strat	pointer
->	O
name	pointer
,	O
port	pointer
)	O
;	O
scm_puts	function
(	O
" ["	pointer
,	O
port	pointer
)	O
;	O
scm_puts	function
(	O
sp	pointer
->	O
strat	pointer
->	O
descr	pointer
,	O
port	pointer
)	O
;	O
scm_puts	function
(	O
"]>"	pointer
,	O
port	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
_guile_init_strategy	function
(	O
void	O
)	O
{	O
_guile_strategy_tag	int
=	O
scm_make_smob_type	function
(	O
"strategy"	pointer
,	O
sizeof	O
(	O
struct	O
_guile_strategy	struct
)	O
)	O
;	O
scm_set_smob_free	function
(	O
_guile_strategy_tag	int
,	O
_guile_strategy_free	function
)	O
;	O
scm_set_smob_print	function
(	O
_guile_strategy_tag	int
,	O
_guile_strategy_print	function
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_dico_strat_selector_p	O
,	O
"dico-strat-selector?"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	function
strat	pointer
)	O
,	O
"Return true if @var{strat} has a selector."	pointer
)	O
{	O
struct	O
_guile_strategy	struct
*	O
sp	pointer
;	O
SCM_ASSERT	function
(	O
CELL_IS_STRAT	O
(	O
strat	pointer
)	O
,	O
strat	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
sp	pointer
=	O
(	O
struct	O
_guile_strategy	struct
*	O
)	O
SCM_CDR	function
(	O
strat	pointer
)	O
;	O
return	O
sp	pointer
->	O
strat	pointer
->	O
sel	pointer
?	O
SCM_BOOL_T	O
:	O
SCM_BOOL_F	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_dico_strat_select_p	O
,	O
"dico-strat-select?"	pointer
,	O
3	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	function
strat	pointer
,	O
SCM	function
word	pointer
,	O
SCM	function
key	pointer
)	O
,	O
"Return true if @var{key} matches @var{word} as per strategy selector @var{strat}."	pointer
)	O
{	O
struct	O
_guile_strategy	struct
*	O
sp	pointer
;	O
struct	O
dico_strategy	struct
*	O
stratp	pointer
;	O
char	O
*	O
wordstr	pointer
;	O
int	O
rc	int
;	O
SCM_ASSERT	function
(	O
CELL_IS_STRAT	O
(	O
strat	pointer
)	O
,	O
strat	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
word	pointer
)	O
,	O
word	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
sp	pointer
=	O
(	O
struct	O
_guile_strategy	struct
*	O
)	O
SCM_CDR	function
(	O
strat	pointer
)	O
;	O
stratp	pointer
=	O
sp	pointer
->	O
strat	pointer
;	O
wordstr	pointer
=	O
scm_to_locale_string	function
(	O
word	pointer
)	O
;	O
if	O
(	O
scm_is_string	function
(	O
key	pointer
)	O
)	O
{	O
char	O
*	O
keystr	pointer
=	O
scm_to_locale_string	function
(	O
key	pointer
)	O
;	O
struct	O
dico_key	struct
skey	struct
;	O
rc	int
=	O
dico_key_init	function
(	O
&	O
skey	struct
,	O
stratp	pointer
,	O
keystr	pointer
)	O
;	O
free	function
(	O
keystr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
free	function
(	O
wordstr	pointer
)	O
;	O
scm_misc_error	function
(	O
FUNC_NAME	O
,	O
"key initialization failed: ~S"	pointer
,	O
scm_list_1	function
(	O
key	pointer
)	O
)	O
;	O
}	O
rc	int
=	O
dico_key_match	function
(	O
&	O
skey	struct
,	O
wordstr	pointer
)	O
;	O
dico_key_deinit	function
(	O
&	O
skey	struct
)	O
;	O
}	O
else	O
{	O
struct	O
dico_key	struct
*	O
kptr	pointer
;	O
SCM_ASSERT	function
(	O
CELL_IS_KEY	O
(	O
key	pointer
)	O
,	O
key	pointer
,	O
SCM_ARG3	O
,	O
FUNC_NAME	O
)	O
;	O
kptr	pointer
=	O
(	O
struct	O
dico_key	struct
*	O
)	O
SCM_CDR	function
(	O
key	pointer
)	O
;	O
rc	int
=	O
dico_key_match	function
(	O
kptr	pointer
,	O
wordstr	pointer
)	O
;	O
}	O
free	function
(	O
wordstr	pointer
)	O
;	O
return	O
rc	int
?	O
SCM_BOOL_T	O
:	O
SCM_BOOL_F	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_dico_strat_name	O
,	O
"dico-strat-name"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	function
strat	pointer
)	O
,	O
"Return the name of the strategy @var{strat}."	pointer
)	O
{	O
struct	O
_guile_strategy	struct
*	O
sp	pointer
;	O
SCM_ASSERT	function
(	O
CELL_IS_STRAT	O
(	O
strat	pointer
)	O
,	O
strat	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
sp	pointer
=	O
(	O
struct	O
_guile_strategy	struct
*	O
)	O
SCM_CDR	function
(	O
strat	pointer
)	O
;	O
return	O
scm_from_locale_string	function
(	O
sp	pointer
->	O
strat	pointer
->	O
name	pointer
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_dico_strat_description	O
,	O
"dico-strat-description"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	function
strat	pointer
)	O
,	O
"Return a textual description of the strategy @var{strat}."	pointer
)	O
{	O
struct	O
_guile_strategy	struct
*	O
sp	pointer
;	O
SCM_ASSERT	function
(	O
CELL_IS_STRAT	O
(	O
strat	pointer
)	O
,	O
strat	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
sp	pointer
=	O
(	O
struct	O
_guile_strategy	struct
*	O
)	O
SCM_CDR	function
(	O
strat	pointer
)	O
;	O
return	O
scm_from_locale_string	function
(	O
sp	pointer
->	O
strat	pointer
->	O
descr	pointer
)	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_dico_strat_default_p	O
,	O
"dico-strat-default?"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	function
strat	pointer
)	O
,	O
"Return true if @var{strat} is a default strategy."	pointer
)	O
{	O
struct	O
_guile_strategy	struct
*	O
sp	pointer
;	O
SCM_ASSERT	function
(	O
CELL_IS_STRAT	O
(	O
strat	pointer
)	O
,	O
strat	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
sp	pointer
=	O
(	O
struct	O
_guile_strategy	struct
*	O
)	O
SCM_CDR	function
(	O
strat	pointer
)	O
;	O
return	O
dico_strategy_is_default_p	O
(	O
sp	pointer
->	O
strat	pointer
)	O
?	O
SCM_BOOL_T	O
:	O
SCM_BOOL_F	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_dico_make_key	O
,	O
"dico-make-key"	pointer
,	O
2	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	function
strat	pointer
,	O
SCM	function
word	pointer
)	O
,	O
"Make a key for given @var{word} and strategy @var{strat}."	pointer
)	O
{	O
SCM	function
ret	O
;	O
struct	O
dico_key	struct
*	O
key	pointer
;	O
struct	O
_guile_strategy	struct
*	O
sp	pointer
;	O
char	O
*	O
wordstr	pointer
;	O
int	O
rc	int
;	O
SCM_ASSERT	function
(	O
CELL_IS_STRAT	O
(	O
strat	pointer
)	O
,	O
strat	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
word	pointer
)	O
,	O
word	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
sp	pointer
=	O
(	O
struct	O
_guile_strategy	struct
*	O
)	O
SCM_CDR	function
(	O
strat	pointer
)	O
;	O
wordstr	pointer
=	O
scm_to_locale_string	function
(	O
word	pointer
)	O
;	O
ret	O
=	O
dico_new_scm_key	function
(	O
&	O
key	pointer
)	O
;	O
rc	int
=	O
dico_key_init	function
(	O
key	pointer
,	O
sp	pointer
->	O
strat	pointer
,	O
wordstr	pointer
)	O
;	O
free	function
(	O
wordstr	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
scm_misc_error	function
(	O
FUNC_NAME	O
,	O
"key initialization failed: ~S"	pointer
,	O
scm_list_1	function
(	O
ret	O
)	O
)	O
;	O
return	O
ret	O
;	O
}	O
static	O
int	O
_guile_selector	function
(	O
int	O
cmd	int
,	O
struct	O
dico_key	struct
*	O
key	pointer
,	O
const	O
char	O
*	O
dict_word	pointer
)	O
{	O
SCM	function
result	pointer
;	O
SCM	function
list	array
=	O
scm_list_4	O
(	O
(	O
SCM	function
)	O
key	pointer
->	O
strat	pointer
->	O
closure	pointer
,	O
scm_from_int	function
(	O
cmd	int
)	O
,	O
scm_from_locale_string	function
(	O
key	pointer
->	O
word	pointer
)	O
,	O
scm_from_locale_string	function
(	O
dict_word	pointer
)	O
)	O
;	O
if	O
(	O
guile_safe_exec	function
(	O
apply_catch_body	function
,	O
list	array
,	O
&	O
result	pointer
)	O
)	O
return	O
0	int
;	O
return	O
result	pointer
!=	O
SCM_BOOL_F	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_dico_register_strat	O
,	O
"dico-register-strat"	pointer
,	O
2	int
,	O
1	int
,	O
0	int
,	O
(	O
SCM	function
strat	pointer
,	O
SCM	function
descr	pointer
,	O
SCM	function
fun	O
)	O
,	O
"Register a new strategy."	pointer
)	O
{	O
struct	O
dico_strategy	struct
strategy	pointer
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
strat	pointer
)	O
,	O
strat	pointer
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
descr	pointer
)	O
,	O
descr	pointer
,	O
SCM_ARG2	O
,	O
FUNC_NAME	O
)	O
;	O
if	O
(	O
!	O
SCM_UNBNDP	function
(	O
fun	O
)	O
)	O
SCM_ASSERT	function
(	O
scm_procedure_p	function
(	O
fun	O
)	O
,	O
fun	O
,	O
SCM_ARG3	O
,	O
FUNC_NAME	O
)	O
;	O
strategy	pointer
.	O
name	pointer
=	O
scm_to_locale_string	function
(	O
strat	pointer
)	O
;	O
strategy	pointer
.	O
descr	pointer
=	O
scm_to_locale_string	function
(	O
descr	pointer
)	O
;	O
if	O
(	O
SCM_UNBNDP	function
(	O
fun	O
)	O
)	O
{	O
strategy	pointer
.	O
sel	pointer
=	O
NULL	O
;	O
strategy	pointer
.	O
closure	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
strategy	pointer
.	O
sel	pointer
=	O
_guile_selector	function
;	O
strategy	pointer
.	O
closure	pointer
=	O
fun	O
;	O
}	O
dico_strategy_add	function
(	O
&	O
strategy	pointer
)	O
;	O
free	function
(	O
strategy	pointer
.	O
name	pointer
)	O
;	O
free	function
(	O
strategy	pointer
.	O
descr	pointer
)	O
;	O
return	O
SCM_UNSPECIFIED	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_dico_register_markup	O
,	O
"dico-register-markup"	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
(	O
SCM	function
type	enum
)	O
,	O
"Register new markup type."	pointer
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
str	pointer
;	O
SCM_ASSERT	function
(	O
scm_is_string	function
(	O
type	enum
)	O
,	O
type	enum
,	O
SCM_ARG1	O
,	O
FUNC_NAME	O
)	O
;	O
str	pointer
=	O
scm_to_locale_string	function
(	O
type	enum
)	O
;	O
rc	int
=	O
dico_markup_register	function
(	O
str	pointer
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
ENOMEM	int
:	O
scm_report_out_of_memory	function
(	O
)	O
;	O
break	O
;	O
case	O
EINVAL	int
:	O
scm_misc_error	function
(	O
FUNC_NAME	O
,	O
"Invalid markup name: ~S"	pointer
,	O
scm_list_1	function
(	O
type	enum
)	O
)	O
;	O
default	O
:	O
scm_misc_error	function
(	O
FUNC_NAME	O
,	O
"Unexpected error: ~S"	pointer
,	O
scm_list_1	function
(	O
scm_from_int	function
(	O
rc	int
)	O
)	O
)	O
;	O
}	O
return	O
SCM_UNSPECIFIED	O
;	O
}	O
SCM_DEFINE_PUBLIC	function
(	O
scm_dico_current_markup	O
,	O
"dico-current-markup"	pointer
,	O
0	int
,	O
0	int
,	O
0	int
,	O
(	O
)	O
,	O
"Return current dico markup type."	pointer
)	O
{	O
return	O
scm_from_locale_string	function
(	O
dico_markup_type	pointer
)	O
;	O
}	O
static	O
scm_t_port_type	O
*	O
scm_dico_port_type	pointer
;	O
struct	O
_guile_dico_port	struct
{	O
dico_stream_t	pointer
str	pointer
;	O
}	O
;	O
static	O
SCM	function
_make_dico_port	function
(	O
dico_stream_t	pointer
str	pointer
)	O
{	O
struct	O
_guile_dico_port	struct
*	O
dp	pointer
;	O
dp	pointer
=	O
scm_gc_typed_calloc	function
(	O
struct	O
_guile_dico_port	struct
)	O
;	O
dp	pointer
->	O
str	pointer
=	O
str	pointer
;	O
return	O
scm_c_make_port	function
(	O
scm_dico_port_type	pointer
,	O
SCM_BUF0	O
|	O
SCM_WRTNG	O
,	O
(	O
scm_t_bits	O
)	O
dp	pointer
)	O
;	O
}	O
static	O
void	O
_dico_port_close	function
(	O
SCM	function
port	pointer
)	O
{	O
struct	O
_guile_dico_port	struct
*	O
dp	pointer
=	O
DICO_PORT	O
(	O
port	pointer
)	O
;	O
if	O
(	O
dp	pointer
&&	O
dp	pointer
->	O
str	pointer
)	O
dico_stream_flush	function
(	O
dp	pointer
->	O
str	pointer
)	O
;	O
}	O
static	O
size_t	long
_dico_port_write	function
(	O
SCM	function
port	pointer
,	O
SCM	function
src	pointer
,	O
size_t	long
start	pointer
,	O
size_t	long
count	long
)	O
{	O
struct	O
_guile_dico_port	struct
*	O
dp	pointer
=	O
DICO_PORT	O
(	O
port	pointer
)	O
;	O
dico_stream_write	function
(	O
dp	pointer
->	O
str	pointer
,	O
SCM_BYTEVECTOR_CONTENTS	function
(	O
src	pointer
)	O
+	O
start	pointer
,	O
count	long
)	O
;	O
return	O
count	long
;	O
}	O
static	O
scm_t_off	long
_dico_port_seek	function
(	O
SCM	function
port	pointer
,	O
scm_t_off	long
offset	long
,	O
int	O
whence	int
)	O
{	O
struct	O
_guile_dico_port	struct
*	O
dp	pointer
=	O
DICO_PORT	O
(	O
port	pointer
)	O
;	O
return	O
(	O
scm_t_off	long
)	O
dico_stream_seek	function
(	O
dp	pointer
->	O
str	pointer
,	O
(	O
off_t	long
)	O
offset	long
,	O
whence	int
)	O
;	O
}	O
static	O
int	O
_dico_port_print	function
(	O
SCM	function
exp	int
,	O
SCM	function
port	pointer
,	O
scm_print_state	O
*	O
pstate	pointer
)	O
{	O
scm_puts	function
(	O
"#<Dico port>"	pointer
,	O
port	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
_guile_init_dico_port	function
(	O
void	O
)	O
{	O
scm_dico_port_type	pointer
=	O
scm_make_port_type	function
(	O
"dico-port"	pointer
,	O
NULL	O
,	O
_dico_port_write	function
)	O
;	O
scm_set_port_print	function
(	O
scm_dico_port_type	pointer
,	O
_dico_port_print	function
)	O
;	O
scm_set_port_needs_close_on_gc	function
(	O
scm_dico_port_type	pointer
,	O
1	int
)	O
;	O
scm_set_port_close	function
(	O
scm_dico_port_type	pointer
,	O
_dico_port_close	function
)	O
;	O
scm_set_port_seek	function
(	O
scm_dico_port_type	pointer
,	O
_dico_port_seek	function
)	O
;	O
}	O
static	O
scm_t_port_type	O
*	O
scm_dico_log_port_type	pointer
;	O
static	O
SCM	function
_make_dico_log_port	function
(	O
int	O
level	int
)	O
{	O
dico_stream_t	pointer
str	pointer
=	O
dico_log_stream_create	function
(	O
level	int
)	O
;	O
return	O
str	pointer
?	O
_make_dico_port	function
(	O
str	pointer
)	O
:	O
SCM_BOOL_F	O
;	O
}	O
static	O
int	O
_dico_log_port_print	function
(	O
SCM	function
exp	int
,	O
SCM	function
port	pointer
,	O
scm_print_state	O
*	O
pstate	pointer
)	O
{	O
scm_puts	function
(	O
"#<Dico log port>"	pointer
,	O
port	pointer
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
_guile_init_dico_log_port	function
(	O
void	O
)	O
{	O
scm_dico_log_port_type	pointer
=	O
scm_make_port_type	function
(	O
"dico-log-port"	pointer
,	O
NULL	O
,	O
_dico_port_write	function
)	O
;	O
scm_set_port_print	function
(	O
scm_dico_log_port_type	pointer
,	O
_dico_log_port_print	function
)	O
;	O
scm_set_port_close	function
(	O
scm_dico_log_port_type	pointer
,	O
_dico_port_close	function
)	O
;	O
scm_set_port_needs_close_on_gc	function
(	O
scm_dico_log_port_type	pointer
,	O
1	int
)	O
;	O
scm_set_port_seek	function
(	O
scm_dico_log_port_type	pointer
,	O
_dico_port_seek	function
)	O
;	O
}	O
static	O
void	O
_guile_init_funcs	function
(	O
void	O
)	O
{	O
}	O
static	O
int	O
guile_debug	int
;	O
static	O
char	O
*	O
guile_init_script	pointer
;	O
static	O
char	O
*	O
guile_init_args	pointer
;	O
static	O
char	O
*	O
guile_init_fun	pointer
;	O
enum	O
guile_proc_ind	enum
{	O
open_proc	int
,	O
close_proc	int
,	O
info_proc	int
,	O
descr_proc	int
,	O
lang_proc	int
,	O
match_proc	int
,	O
define_proc	int
,	O
output_proc	int
,	O
result_count_proc	int
,	O
compare_count_proc	int
,	O
free_result_proc	int
,	O
result_headers_proc	int
,	O
db_mime_header_proc	int
,	O
MAX_PROC	int
}	O
;	O
static	O
char	O
*	O
guile_proc_name	array
[	O
]	O
=	O
{	O
"open"	pointer
,	O
"close"	pointer
,	O
"info"	pointer
,	O
"descr"	pointer
,	O
"lang"	pointer
,	O
"match"	pointer
,	O
"define"	pointer
,	O
"output"	pointer
,	O
"result-count"	pointer
,	O
"compare-count"	pointer
,	O
"free-result"	pointer
,	O
"result-headers"	pointer
,	O
"db-mime-header"	pointer
}	O
;	O
typedef	O
SCM	function
guile_vtab	array
[	O
MAX_PROC	int
]	O
;	O
static	O
guile_vtab	array
global_vtab	array
;	O
struct	O
_guile_database	struct
{	O
const	O
char	O
*	O
dbname	pointer
;	O
guile_vtab	array
vtab	array
;	O
int	O
argc	int
;	O
char	O
*	O
*	O
argv	pointer
;	O
SCM	function
handle	int
;	O
}	O
;	O
static	O
int	O
proc_name_to_index	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_PROC	int
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
guile_proc_name	array
[	O
i	int
]	O
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
return	O
i	int
;	O
}	O
struct	O
init_struct	struct
{	O
const	O
char	O
*	O
init_fun	pointer
;	O
const	O
char	O
*	O
db_name	pointer
;	O
}	O
;	O
static	O
SCM	function
call_init_handler	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
init_struct	struct
*	O
p	pointer
=	O
(	O
struct	O
init_struct	struct
*	O
)	O
data	pointer
;	O
SCM	function
procsym	int
=	O
SCM_VARIABLE_REF	function
(	O
scm_c_lookup	function
(	O
p	pointer
->	O
init_fun	pointer
)	O
)	O
;	O
SCM	function
arg	int
;	O
if	O
(	O
p	pointer
->	O
db_name	pointer
)	O
arg	int
=	O
scm_from_locale_string	function
(	O
p	pointer
->	O
db_name	pointer
)	O
;	O
else	O
arg	int
=	O
SCM_BOOL_F	O
;	O
return	O
scm_apply_0	function
(	O
procsym	int
,	O
scm_list_1	function
(	O
arg	int
)	O
)	O
;	O
}	O
static	O
int	O
init_vtab	function
(	O
const	O
char	O
*	O
init_fun	pointer
,	O
const	O
char	O
*	O
dbname	pointer
,	O
guile_vtab	array
vtab	array
)	O
{	O
SCM	function
res	int
;	O
struct	O
init_struct	struct
istr	struct
;	O
istr	struct
.	O
init_fun	pointer
=	O
init_fun	pointer
;	O
istr	struct
.	O
db_name	pointer
=	O
dbname	pointer
;	O
if	O
(	O
guile_safe_exec	function
(	O
call_init_handler	function
,	O
&	O
istr	struct
,	O
&	O
res	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
scm_list_p	function
(	O
res	int
)	O
&&	O
res	int
!=	O
SCM_EOL	O
)	O
{	O
str_rettype_error	function
(	O
init_fun	pointer
)	O
;	O
return	O
1	int
;	O
}	O
for	O
(	O
;	O
res	int
!=	O
SCM_EOL	O
;	O
res	int
=	O
SCM_CDR	function
(	O
res	int
)	O
)	O
{	O
int	O
idx	int
;	O
char	O
*	O
ident	pointer
;	O
SCM	function
name	pointer
,	O
proc	int
;	O
SCM	function
car	O
=	O
SCM_CAR	function
(	O
res	int
)	O
;	O
if	O
(	O
!	O
scm_list_p	function
(	O
res	int
)	O
||	O
!	O
scm_is_string	function
(	O
name	pointer
=	O
SCM_CAR	function
(	O
car	O
)	O
)	O
||	O
!	O
scm_procedure_p	function
(	O
proc	int
=	O
SCM_CDR	function
(	O
car	O
)	O
)	O
)	O
{	O
str_rettype_error	function
(	O
init_fun	pointer
)	O
;	O
return	O
1	int
;	O
}	O
ident	pointer
=	O
scm_to_locale_string	function
(	O
name	pointer
)	O
;	O
idx	int
=	O
proc_name_to_index	function
(	O
ident	pointer
)	O
;	O
if	O
(	O
idx	int
==	O
MAX_PROC	int
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: %s: unknown virtual function"	pointer
)	O
,	O
init_fun	pointer
,	O
ident	pointer
)	O
;	O
free	function
(	O
ident	pointer
)	O
;	O
return	O
1	int
;	O
}	O
free	function
(	O
ident	pointer
)	O
;	O
vtab	array
[	O
idx	int
]	O
=	O
proc	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
set_load_path	function
(	O
struct	O
dico_option	struct
*	O
opt	pointer
,	O
const	O
char	O
*	O
val	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
char	O
*	O
tmp	pointer
=	O
strdup	function
(	O
val	pointer
)	O
;	O
if	O
(	O
!	O
tmp	pointer
)	O
return	O
1	int
;	O
for	O
(	O
p	pointer
=	O
strtok	function
(	O
tmp	pointer
,	O
":"	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
strtok	function
(	O
NULL	O
,	O
":"	pointer
)	O
)	O
_add_load_path	function
(	O
p	pointer
)	O
;	O
free	function
(	O
tmp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
dico_option	struct
init_option	array
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
debug	O
)	O
,	O
dico_opt_bool	int
,	O
&	O
guile_debug	int
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
script	O
)	O
,	O
dico_opt_string	int
,	O
&	O
guile_init_script	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
args	pointer
)	O
,	O
dico_opt_string	int
,	O
&	O
guile_init_args	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
load	O
-	O
path	pointer
)	O
,	O
dico_opt_null	int
,	O
NULL	O
,	O
{	O
0	int
}	O
,	O
set_load_path	function
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
fun	O
)	O
,	O
dico_opt_string	int
,	O
&	O
guile_init_fun	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
int	O
mod_init	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
SCM	function
port	pointer
;	O
scm_init_guile	function
(	O
)	O
;	O
scm_load_goops	function
(	O
)	O
;	O
if	O
(	O
dico_parseopt	function
(	O
init_option	array
,	O
argc	int
,	O
argv	pointer
,	O
0	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
_guile_init_strategy	function
(	O
)	O
;	O
_guile_init_dico_key	function
(	O
)	O
;	O
_guile_init_dico_port	function
(	O
)	O
;	O
_guile_init_dico_log_port	function
(	O
)	O
;	O
_guile_init_funcs	function
(	O
)	O
;	O
port	pointer
=	O
_make_dico_log_port	function
(	O
L_ERR	int
)	O
;	O
if	O
(	O
port	pointer
==	O
SCM_BOOL_F	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init: cannot initialize error port"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
scm_set_current_output_port	function
(	O
port	pointer
)	O
;	O
scm_set_current_error_port	function
(	O
port	pointer
)	O
;	O
if	O
(	O
guile_init_script	pointer
&&	O
guile_load	function
(	O
guile_init_script	pointer
,	O
guile_init_args	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init: cannot load init script %s"	pointer
)	O
,	O
guile_init_script	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
guile_init_fun	pointer
&&	O
init_vtab	function
(	O
guile_init_fun	pointer
,	O
NULL	O
,	O
global_vtab	array
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
dico_handle_t	pointer
mod_init_db	function
(	O
const	O
char	O
*	O
dbname	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
struct	O
_guile_database	struct
*	O
db	pointer
;	O
int	O
i	int
;	O
int	O
err	int
=	O
0	int
;	O
char	O
*	O
init_script	pointer
=	O
NULL	O
;	O
char	O
*	O
init_args	pointer
=	O
NULL	O
;	O
char	O
*	O
init_fun	pointer
=	O
guile_init_fun	pointer
;	O
struct	O
dico_option	struct
db_option	array
[	O
]	O
=	O
{	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
script	O
)	O
,	O
dico_opt_string	int
,	O
&	O
init_script	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
args	pointer
)	O
,	O
dico_opt_string	int
,	O
&	O
init_args	pointer
}	O
,	O
{	O
DICO_OPTSTR	O
(	O
init	O
-	O
fun	O
)	O
,	O
dico_opt_string	int
,	O
&	O
init_fun	pointer
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
if	O
(	O
dico_parseopt	function
(	O
db_option	array
,	O
argc	int
,	O
argv	pointer
,	O
DICO_PARSEOPT_PERMUTE	int
,	O
&	O
i	int
)	O
)	O
return	O
NULL	O
;	O
argc	int
-=	O
i	int
;	O
argv	pointer
+=	O
i	int
;	O
if	O
(	O
init_script	pointer
&&	O
guile_load	function
(	O
init_script	pointer
,	O
init_args	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_init: cannot load init script %s"	pointer
)	O
,	O
init_script	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
db	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
db	pointer
)	O
)	O
;	O
if	O
(	O
!	O
db	pointer
)	O
{	O
memerr	function
(	O
"mod_init_db"	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
db	pointer
->	O
dbname	pointer
=	O
dbname	pointer
;	O
memcpy	function
(	O
db	pointer
->	O
vtab	array
,	O
global_vtab	array
,	O
sizeof	O
(	O
db	pointer
->	O
vtab	array
)	O
)	O
;	O
if	O
(	O
init_fun	pointer
&&	O
init_vtab	function
(	O
init_fun	pointer
,	O
dbname	pointer
,	O
db	pointer
->	O
vtab	array
)	O
)	O
{	O
free	function
(	O
db	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_PROC	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
!	O
db	pointer
->	O
vtab	array
[	O
i	int
]	O
)	O
{	O
switch	O
(	O
i	int
)	O
{	O
case	O
open_proc	int
:	O
case	O
match_proc	int
:	O
case	O
define_proc	int
:	O
case	O
output_proc	int
:	O
case	O
result_count_proc	int
:	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"%s: %s: void virtual function"	pointer
)	O
,	O
argv	pointer
[	O
0	int
]	O
,	O
guile_proc_name	array
[	O
i	int
]	O
)	O
;	O
err	int
++	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
err	int
)	O
{	O
free	function
(	O
db	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
db	pointer
->	O
argc	int
=	O
argc	int
;	O
db	pointer
->	O
argv	pointer
=	O
argv	pointer
;	O
return	O
(	O
dico_handle_t	pointer
)	O
db	pointer
;	O
}	O
static	O
int	O
mod_free_db	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
_guile_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_guile_database	struct
*	O
)	O
hp	pointer
;	O
free	function
(	O
db	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
mod_close	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
_guile_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_guile_database	struct
*	O
)	O
hp	pointer
;	O
SCM	function
res	int
;	O
if	O
(	O
db	pointer
->	O
vtab	array
[	O
close_proc	int
]	O
)	O
if	O
(	O
guile_call_proc	function
(	O
&	O
res	int
,	O
db	pointer
->	O
vtab	array
[	O
close_proc	int
]	O
,	O
scm_list_1	function
(	O
db	pointer
->	O
handle	int
)	O
)	O
)	O
return	O
1	int
;	O
scm_gc_unprotect_object	function
(	O
db	pointer
->	O
handle	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
SCM	function
argv_to_scm	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
SCM	function
scm_first	O
=	O
SCM_EOL	O
,	O
scm_last	O
;	O
for	O
(	O
;	O
argc	int
;	O
argc	int
--	O
,	O
argv	pointer
++	O
)	O
{	O
SCM	function
new	O
=	O
scm_cons	function
(	O
scm_from_locale_string	function
(	O
*	O
argv	pointer
)	O
,	O
SCM_EOL	O
)	O
;	O
if	O
(	O
scm_first	O
==	O
SCM_EOL	O
)	O
scm_last	O
=	O
scm_first	O
=	O
new	O
;	O
else	O
{	O
SCM_SETCDR	function
(	O
scm_last	O
,	O
new	O
)	O
;	O
scm_last	O
=	O
new	O
;	O
}	O
}	O
return	O
scm_first	O
;	O
}	O
static	O
SCM	function
assoc_to_scm	function
(	O
dico_assoc_list_t	pointer
assoc	pointer
)	O
{	O
SCM	function
scm_first	O
=	O
SCM_EOL	O
,	O
scm_last	O
;	O
dico_iterator_t	pointer
itr	pointer
;	O
struct	O
dico_assoc	struct
*	O
p	pointer
;	O
itr	pointer
=	O
dico_assoc_iterator	function
(	O
assoc	pointer
)	O
;	O
for	O
(	O
p	pointer
=	O
dico_iterator_first	function
(	O
itr	pointer
)	O
;	O
p	pointer
;	O
p	pointer
=	O
dico_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
SCM	function
new	O
=	O
scm_cons	function
(	O
scm_cons	function
(	O
scm_from_locale_string	function
(	O
p	pointer
->	O
key	pointer
)	O
,	O
scm_from_locale_string	function
(	O
p	pointer
->	O
value	pointer
)	O
)	O
,	O
SCM_EOL	O
)	O
;	O
if	O
(	O
scm_first	O
==	O
SCM_EOL	O
)	O
scm_last	O
=	O
scm_first	O
=	O
new	O
;	O
else	O
{	O
SCM_SETCDR	function
(	O
scm_last	O
,	O
new	O
)	O
;	O
scm_last	O
=	O
new	O
;	O
}	O
}	O
dico_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
return	O
scm_first	O
;	O
}	O
static	O
void	O
scm_to_assoc	function
(	O
dico_assoc_list_t	pointer
assoc	pointer
,	O
SCM	function
scm	int
)	O
{	O
dico_assoc_clear	function
(	O
assoc	pointer
)	O
;	O
for	O
(	O
;	O
scm	int
!=	O
SCM_EOL	O
&&	O
scm_list_p	function
(	O
scm	int
)	O
;	O
scm	int
=	O
SCM_CDR	function
(	O
scm	int
)	O
)	O
{	O
SCM	function
elt	O
=	O
SCM_CAR	function
(	O
scm	int
)	O
;	O
if	O
(	O
!	O
scm_is_pair	function
(	O
elt	O
)	O
)	O
{	O
scm_misc_error	function
(	O
NULL	O
,	O
"Wrong element type: ~S"	pointer
,	O
scm_list_1	function
(	O
elt	O
)	O
)	O
;	O
}	O
dico_assoc_append	function
(	O
assoc	pointer
,	O
scm_to_locale_string	function
(	O
SCM_CAR	function
(	O
elt	O
)	O
)	O
,	O
scm_to_locale_string	function
(	O
SCM_CDR	function
(	O
elt	O
)	O
)	O
)	O
;	O
}	O
}	O
static	O
int	O
mod_open	function
(	O
dico_handle_t	pointer
dp	pointer
)	O
{	O
struct	O
_guile_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_guile_database	struct
*	O
)	O
dp	pointer
;	O
if	O
(	O
guile_call_proc	function
(	O
&	O
db	pointer
->	O
handle	int
,	O
db	pointer
->	O
vtab	array
[	O
open_proc	int
]	O
,	O
scm_cons	function
(	O
scm_from_locale_string	function
(	O
db	pointer
->	O
dbname	pointer
)	O
,	O
argv_to_scm	function
(	O
db	pointer
->	O
argc	int
,	O
db	pointer
->	O
argv	pointer
)	O
)	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
db	pointer
->	O
handle	int
==	O
SCM_EOL	O
||	O
db	pointer
->	O
handle	int
==	O
SCM_BOOL_F	O
)	O
return	O
1	int
;	O
scm_gc_protect_object	function
(	O
db	pointer
->	O
handle	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
mod_get_text	function
(	O
struct	O
_guile_database	struct
*	O
db	pointer
,	O
int	O
n	long
)	O
{	O
if	O
(	O
db	pointer
->	O
vtab	array
[	O
n	long
]	O
)	O
{	O
SCM	function
res	int
;	O
if	O
(	O
guile_call_proc	function
(	O
&	O
res	int
,	O
db	pointer
->	O
vtab	array
[	O
n	long
]	O
,	O
scm_list_1	function
(	O
db	pointer
->	O
handle	int
)	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
scm_is_string	function
(	O
res	int
)	O
)	O
return	O
scm_to_locale_string	function
(	O
res	int
)	O
;	O
else	O
{	O
rettype_error	function
(	O
db	pointer
->	O
vtab	array
[	O
n	long
]	O
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
static	O
char	O
*	O
mod_info	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
_guile_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_guile_database	struct
*	O
)	O
hp	pointer
;	O
return	O
mod_get_text	function
(	O
db	pointer
,	O
info_proc	int
)	O
;	O
}	O
static	O
char	O
*	O
mod_descr	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
_guile_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_guile_database	struct
*	O
)	O
hp	pointer
;	O
return	O
mod_get_text	function
(	O
db	pointer
,	O
descr_proc	int
)	O
;	O
}	O
static	O
dico_list_t	pointer
scm_to_langlist	function
(	O
SCM	function
scm	int
,	O
SCM	function
procsym	int
)	O
{	O
dico_list_t	pointer
list	array
=	O
NULL	O
;	O
if	O
(	O
scm	int
==	O
SCM_EOL	O
)	O
return	O
NULL	O
;	O
else	O
if	O
(	O
scm_is_string	function
(	O
scm	int
)	O
)	O
{	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
dico_list_append	function
(	O
list	array
,	O
scm_to_locale_string	function
(	O
scm	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
scm_list_p	function
(	O
scm	int
)	O
)	O
{	O
list	array
=	O
dico_list_create	function
(	O
)	O
;	O
for	O
(	O
;	O
scm	int
!=	O
SCM_EOL	O
&&	O
scm_list_p	function
(	O
scm	int
)	O
;	O
scm	int
=	O
SCM_CDR	function
(	O
scm	int
)	O
)	O
dico_list_append	function
(	O
list	array
,	O
scm_to_locale_string	function
(	O
SCM_CAR	function
(	O
scm	int
)	O
)	O
)	O
;	O
}	O
else	O
rettype_error	function
(	O
procsym	int
)	O
;	O
return	O
list	array
;	O
}	O
static	O
int	O
mod_lang	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
dico_list_t	pointer
list	array
[	O
2	int
]	O
)	O
{	O
struct	O
_guile_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_guile_database	struct
*	O
)	O
hp	pointer
;	O
SCM	function
proc	int
=	O
db	pointer
->	O
vtab	array
[	O
lang_proc	int
]	O
;	O
list	array
[	O
0	int
]	O
=	O
list	array
[	O
1	int
]	O
=	O
NULL	O
;	O
if	O
(	O
proc	int
)	O
{	O
SCM	function
res	int
;	O
if	O
(	O
guile_call_proc	function
(	O
&	O
res	int
,	O
proc	int
,	O
scm_list_1	function
(	O
db	pointer
->	O
handle	int
)	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
res	int
==	O
SCM_EOL	O
)	O
;	O
else	O
if	O
(	O
scm_is_string	function
(	O
res	int
)	O
)	O
{	O
list	array
[	O
0	int
]	O
=	O
dico_list_create	function
(	O
)	O
;	O
dico_list_append	function
(	O
list	array
[	O
0	int
]	O
,	O
scm_to_locale_string	function
(	O
res	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
scm_is_pair	function
(	O
res	int
)	O
)	O
{	O
list	array
[	O
0	int
]	O
=	O
scm_to_langlist	function
(	O
SCM_CAR	function
(	O
res	int
)	O
,	O
proc	int
)	O
;	O
list	array
[	O
1	int
]	O
=	O
scm_to_langlist	function
(	O
SCM_CDR	function
(	O
res	int
)	O
,	O
proc	int
)	O
;	O
}	O
else	O
{	O
rettype_error	function
(	O
proc	int
)	O
;	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
struct	O
guile_result	struct
{	O
struct	O
_guile_database	struct
*	O
db	pointer
;	O
SCM	function
result	pointer
;	O
}	O
;	O
static	O
dico_result_t	pointer
make_guile_result	function
(	O
struct	O
_guile_database	struct
*	O
db	pointer
,	O
SCM	function
res	int
)	O
{	O
struct	O
guile_result	struct
*	O
rp	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
rp	pointer
)	O
)	O
;	O
if	O
(	O
rp	pointer
)	O
{	O
rp	pointer
->	O
db	pointer
=	O
db	pointer
;	O
rp	pointer
->	O
result	pointer
=	O
res	int
;	O
}	O
return	O
(	O
dico_result_t	pointer
)	O
rp	pointer
;	O
}	O
static	O
dico_result_t	pointer
mod_match	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
const	O
dico_strategy_t	pointer
strat	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
_guile_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_guile_database	struct
*	O
)	O
hp	pointer
;	O
SCM	function
scm_strat	O
=	O
_make_strategy	function
(	O
strat	pointer
)	O
;	O
SCM	function
res	int
;	O
struct	O
dico_key	struct
*	O
key	pointer
;	O
SCM	function
scm_key	O
;	O
scm_key	O
=	O
dico_new_scm_key	function
(	O
&	O
key	pointer
)	O
;	O
if	O
(	O
dico_key_init	function
(	O
key	pointer
,	O
strat	pointer
,	O
word	pointer
)	O
)	O
{	O
dico_log	function
(	O
L_ERR	int
,	O
0	int
,	O
_	O
(	O
"mod_match: key initialization failed"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
guile_call_proc	function
(	O
&	O
res	int
,	O
db	pointer
->	O
vtab	array
[	O
match_proc	int
]	O
,	O
scm_list_3	function
(	O
db	pointer
->	O
handle	int
,	O
scm_strat	O
,	O
scm_key	O
)	O
)	O
)	O
return	O
NULL	O
;	O
dico_key_deinit	function
(	O
key	pointer
)	O
;	O
if	O
(	O
res	int
==	O
SCM_BOOL_F	O
||	O
res	int
==	O
SCM_EOL	O
)	O
return	O
NULL	O
;	O
scm_gc_protect_object	function
(	O
res	int
)	O
;	O
return	O
make_guile_result	function
(	O
db	pointer
,	O
res	int
)	O
;	O
}	O
static	O
dico_result_t	pointer
mod_define	function
(	O
dico_handle_t	pointer
hp	pointer
,	O
const	O
char	O
*	O
word	pointer
)	O
{	O
struct	O
_guile_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_guile_database	struct
*	O
)	O
hp	pointer
;	O
SCM	function
res	int
;	O
if	O
(	O
guile_call_proc	function
(	O
&	O
res	int
,	O
db	pointer
->	O
vtab	array
[	O
define_proc	int
]	O
,	O
scm_list_2	function
(	O
db	pointer
->	O
handle	int
,	O
scm_from_locale_string	function
(	O
word	pointer
)	O
)	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
res	int
==	O
SCM_BOOL_F	O
||	O
res	int
==	O
SCM_EOL	O
)	O
return	O
NULL	O
;	O
scm_gc_protect_object	function
(	O
res	int
)	O
;	O
return	O
make_guile_result	function
(	O
db	pointer
,	O
res	int
)	O
;	O
}	O
static	O
int	O
mod_output_result	function
(	O
dico_result_t	pointer
rp	pointer
,	O
size_t	long
n	long
,	O
dico_stream_t	pointer
str	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
guile_result	struct
*	O
gres	pointer
=	O
(	O
struct	O
guile_result	struct
*	O
)	O
rp	pointer
;	O
SCM	function
res	int
;	O
SCM	function
oport	O
=	O
scm_current_output_port	O
(	O
)	O
;	O
SCM	function
port	pointer
=	O
_make_dico_port	function
(	O
str	pointer
)	O
;	O
scm_set_current_output_port	function
(	O
port	pointer
)	O
;	O
rc	int
=	O
guile_call_proc	function
(	O
&	O
res	int
,	O
gres	pointer
->	O
db	pointer
->	O
vtab	array
[	O
output_proc	int
]	O
,	O
scm_list_2	function
(	O
gres	pointer
->	O
result	pointer
,	O
scm_from_int	function
(	O
n	long
)	O
)	O
)	O
;	O
scm_set_current_output_port	function
(	O
oport	O
)	O
;	O
_dico_port_close	function
(	O
port	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
size_t	long
mod_result_count	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
guile_result	struct
*	O
gres	pointer
=	O
(	O
struct	O
guile_result	struct
*	O
)	O
rp	pointer
;	O
SCM	function
res	int
;	O
if	O
(	O
guile_call_proc	function
(	O
&	O
res	int
,	O
gres	pointer
->	O
db	pointer
->	O
vtab	array
[	O
result_count_proc	int
]	O
,	O
scm_list_1	function
(	O
gres	pointer
->	O
result	pointer
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
scm_is_integer	function
(	O
res	int
)	O
)	O
return	O
scm_to_int32	function
(	O
res	int
)	O
;	O
else	O
rettype_error	function
(	O
gres	pointer
->	O
db	pointer
->	O
vtab	array
[	O
result_count_proc	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
size_t	long
mod_compare_count	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
guile_result	struct
*	O
gres	pointer
=	O
(	O
struct	O
guile_result	struct
*	O
)	O
rp	pointer
;	O
if	O
(	O
gres	pointer
->	O
db	pointer
->	O
vtab	array
[	O
compare_count_proc	int
]	O
)	O
{	O
SCM	function
res	int
;	O
if	O
(	O
guile_call_proc	function
(	O
&	O
res	int
,	O
gres	pointer
->	O
db	pointer
->	O
vtab	array
[	O
compare_count_proc	int
]	O
,	O
scm_list_1	function
(	O
gres	pointer
->	O
result	pointer
)	O
)	O
)	O
return	O
0	int
;	O
if	O
(	O
scm_is_integer	function
(	O
res	int
)	O
)	O
return	O
scm_to_int32	function
(	O
res	int
)	O
;	O
else	O
rettype_error	function
(	O
gres	pointer
->	O
db	pointer
->	O
vtab	array
[	O
compare_count_proc	int
]	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
mod_free_result	function
(	O
dico_result_t	pointer
rp	pointer
)	O
{	O
struct	O
guile_result	struct
*	O
gres	pointer
=	O
(	O
struct	O
guile_result	struct
*	O
)	O
rp	pointer
;	O
if	O
(	O
gres	pointer
->	O
db	pointer
->	O
vtab	array
[	O
free_result_proc	int
]	O
)	O
{	O
SCM	function
res	int
;	O
guile_call_proc	function
(	O
&	O
res	int
,	O
gres	pointer
->	O
db	pointer
->	O
vtab	array
[	O
free_result_proc	int
]	O
,	O
scm_list_1	function
(	O
gres	pointer
->	O
result	pointer
)	O
)	O
;	O
}	O
scm_gc_unprotect_object	function
(	O
gres	pointer
->	O
result	pointer
)	O
;	O
free	function
(	O
gres	pointer
)	O
;	O
}	O
static	O
int	O
mod_result_headers	function
(	O
dico_result_t	pointer
rp	pointer
,	O
dico_assoc_list_t	pointer
hdr	pointer
)	O
{	O
struct	O
guile_result	struct
*	O
gres	pointer
=	O
(	O
struct	O
guile_result	struct
*	O
)	O
rp	pointer
;	O
SCM	function
proc	int
=	O
gres	pointer
->	O
db	pointer
->	O
vtab	array
[	O
result_headers_proc	int
]	O
;	O
if	O
(	O
proc	int
)	O
{	O
SCM	function
res	int
;	O
if	O
(	O
guile_call_proc	function
(	O
&	O
res	int
,	O
proc	int
,	O
scm_list_2	function
(	O
gres	pointer
->	O
result	pointer
,	O
assoc_to_scm	function
(	O
hdr	pointer
)	O
)	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
scm_list_p	function
(	O
res	int
)	O
)	O
{	O
rettype_error	function
(	O
proc	int
)	O
;	O
return	O
1	int
;	O
}	O
scm_to_assoc	function
(	O
hdr	pointer
,	O
res	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
char	O
*	O
mod_db_mime_header	function
(	O
dico_handle_t	pointer
hp	pointer
)	O
{	O
struct	O
_guile_database	struct
*	O
db	pointer
=	O
(	O
struct	O
_guile_database	struct
*	O
)	O
hp	pointer
;	O
return	O
mod_get_text	function
(	O
db	pointer
,	O
db_mime_header_proc	int
)	O
;	O
}	O
struct	O
dico_database_module	struct
DICO_EXPORT	O
(	O
guile	O
,	O
module	O
)	O
=	O
{	O
.	O
dico_version	int
=	O
DICO_MODULE_VERSION	int
,	O
.	O
dico_capabilities	int
=	O
DICO_CAPA_NONE	int
,	O
.	O
dico_init	pointer
=	O
mod_init	function
,	O
.	O
dico_init_db	pointer
=	O
mod_init_db	function
,	O
.	O
dico_free_db	pointer
=	O
mod_free_db	function
,	O
.	O
dico_open	pointer
=	O
mod_open	function
,	O
.	O
dico_close	pointer
=	O
mod_close	function
,	O
.	O
dico_db_info	pointer
=	O
mod_info	function
,	O
.	O
dico_db_descr	pointer
=	O
mod_descr	function
,	O
.	O
dico_db_lang	pointer
=	O
mod_lang	function
,	O
.	O
dico_match	pointer
=	O
mod_match	function
,	O
.	O
dico_define	pointer
=	O
mod_define	function
,	O
.	O
dico_output_result	pointer
=	O
mod_output_result	function
,	O
.	O
dico_result_count	pointer
=	O
mod_result_count	function
,	O
.	O
dico_compare_count	pointer
=	O
mod_compare_count	function
,	O
.	O
dico_free_result	pointer
=	O
mod_free_result	function
,	O
.	O
dico_result_headers	pointer
=	O
mod_result_headers	function
,	O
.	O
dico_db_mime_header	pointer
=	O
mod_db_mime_header	function
}	O
;	O
