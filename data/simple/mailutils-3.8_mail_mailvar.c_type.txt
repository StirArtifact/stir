enum	O
mailvar_cmd	enum
{	O
mailvar_cmd_set	int
,	O
mailvar_cmd_unset	int
}	O
;	O
struct	O
mailvar_symbol	struct
{	O
struct	O
mailvar_variable	struct
var	pointer
;	O
int	O
flags	int
;	O
char	O
*	O
descr	pointer
;	O
int	O
(	O
*	O
handler	pointer
)	O
(	O
enum	O
mailvar_cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
)	O
;	O
}	O
;	O
mu_list_t	pointer
mailvar_list	pointer
=	O
NULL	O
;	O
static	O
int	O
set_decode_fallback	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
)	O
;	O
static	O
int	O
set_replyregex	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
)	O
;	O
static	O
int	O
set_screen	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
)	O
;	O
static	O
int	O
set_verbose	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
)	O
;	O
static	O
int	O
set_debug	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
)	O
;	O
static	O
int	O
set_folder	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
)	O
;	O
static	O
int	O
set_headline	function
(	O
enum	O
mailvar_cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
)	O
;	O
struct	O
mailvar_symbol	struct
mailvar_tab	array
[	O
]	O
=	O
{	O
{	O
{	O
mailvar_name_allnet	pointer
,	O
}	O
,	O
MAILVAR_HIDDEN	int
}	O
,	O
{	O
{	O
mailvar_name_append	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
|	O
MAILVAR_RDONLY	int
,	O
N_	O
(	O
"messages saved in mbox are appended to the end rather than prepended"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_appenddeadletter	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"append the contents of canceled letter to dead.letter file"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_askbcc	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"prompt user for bcc before composing the message"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_askcc	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"prompt user for cc before composing the message"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_ask	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"prompt user for subject before composing the message"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_asksub	pointer
,	O
}	O
,	O
MAILVAR_ALIAS	int
,	O
NULL	O
}	O
,	O
{	O
{	O
mailvar_name_autoinc	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"automatically incorporate newly arrived messages"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_autoprint	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"delete command behaves like dp"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_byname	pointer
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"record outgoing messages in a file named after the first recipient; "	pointer
"overrides the `record' variable"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_bang	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"replace every occurrence of ! in arguments to the shell command"	pointer
" with the last executed command"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_charset	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"output character set for decoded header fields"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_cmd	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"default shell command for pipe"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_columns	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_number	int
)	O
,	O
N_	O
(	O
"number of columns on terminal screen"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_crt	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_number	int
)	O
|	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"if numeric, sets the minimum number of output lines needed "	pointer
"to engage paging; if boolean, use the height of the terminal "	pointer
"screen to compute the threshold"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_datefield	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"get date from the `Date:' header, instead of the envelope"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_debug	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
|	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"set Mailutils debug level"	pointer
)	O
,	O
set_debug	function
}	O
,	O
{	O
{	O
mailvar_name_decode_fallback	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"how to represent characters that cannot be rendered using the "	pointer
"current character set"	pointer
)	O
,	O
set_decode_fallback	function
}	O
,	O
{	O
{	O
mailvar_name_dot	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"input message is terminated with a dot alone on a line"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_editheaders	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"allow editing message headers while composing"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_emptystart	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"start interactive mode if the mailbox is empty"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_escape	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"character denoting escapes"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_flipr	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"swap the meaning of reply and Reply commands"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_folder	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"folder directory name"	pointer
)	O
,	O
set_folder	function
}	O
,	O
{	O
{	O
mailvar_name_fromfield	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"get sender address from the `From:' header, instead of "	pointer
"the envelope"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_gnu_last_command	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
|	O
MAILVAR_RDONLY	int
,	O
N_	O
(	O
"last executed command line"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_header	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"run the `headers' command after entering interactive mode"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_headline	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"format string to use for the header summary"	pointer
)	O
,	O
set_headline	function
}	O
,	O
{	O
{	O
mailvar_name_hold	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"hold the read or saved messages in the system mailbox"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_ignore	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"ignore keyboard interrupts when composing messages"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_ignoreeof	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"ignore EOF character"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_indentprefix	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"string used by the ~m escape for indenting quoted messages"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_inplacealiases	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"expand aliases in the address header field "	pointer
"before starting composing the message"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_keep	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
|	O
MAILVAR_RDONLY	int
,	O
N_	O
(	O
"keep the empty user's system mailbox,"	pointer
" instead of removing it"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_keepsave	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"keep saved messages in system mailbox too"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_mailx	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"enable mailx compatibility mode"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_metamail	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"interpret the content of message parts; if set to a string "	pointer
"specifies the name of the external metamail command"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_metoo	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"do not remove sender addresses from the recipient list"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_mimenoask	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"a comma-separated list of MIME types for which "	pointer
"no confirmation is needed before running metamail interpreter"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_mode	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
|	O
MAILVAR_RDONLY	int
,	O
N_	O
(	O
"the name of current operation mode"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_nullbody	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"accept messages with an empty body"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_nullbodymsg	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"display this text when sending a message with empty body"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_outfolder	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"keep created files in this folder"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_page	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"pipe command terminates each message with a formfeed"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_prompt	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"command prompt sequence"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_quit	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"keyboard interrupts terminate the program"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_rc	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"read the system-wide configuration file upon startup"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_readonly	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"mailboxes are opened in readonly mode"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_record	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"save outgoing messages in this file"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_recursivealiases	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"recursively expand aliases"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_regex	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"use of regular expressions in search message specifications"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_replyprefix	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"prefix for the subject line of a reply message"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_replyregex	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"regexp for recognizing subject lines of reply messages"	pointer
)	O
,	O
set_replyregex	function
}	O
,	O
{	O
{	O
mailvar_name_return_address	pointer
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"return address for outgoing messages"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_save	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"store aborted messages in the user's dead.file"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_screen	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_number	int
)	O
,	O
N_	O
(	O
"number of lines on terminal screen"	pointer
)	O
,	O
set_screen	function
}	O
,	O
{	O
{	O
mailvar_name_sendmail	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"URL of the mail transport agent"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_sendwait	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
|	O
MAILVAR_HIDDEN	int
,	O
NULL	O
}	O
,	O
{	O
{	O
mailvar_name_sign	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"signature for use with the ~a command"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_Sign	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
,	O
N_	O
(	O
"name of the signature file for use with the ~A command"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_showenvelope	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"`print' command includes the SMTP envelope in its output"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_showto	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"if the message was sent by me, print its recipient address "	pointer
"in the header summary"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_toplines	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_number	int
)	O
,	O
N_	O
(	O
"number of lines to be displayed by `top' or `Top'"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_variable_pretty_print	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"print variables with short descriptions"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_varpp	pointer
,	O
}	O
,	O
MAILVAR_ALIAS	int
}	O
,	O
{	O
{	O
mailvar_name_variable_strict	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"perform strict checking when setting variables"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_varstrict	pointer
,	O
}	O
,	O
MAILVAR_ALIAS	int
}	O
,	O
{	O
{	O
mailvar_name_verbose	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"verbosely trace the process of message delivery"	pointer
)	O
,	O
set_verbose	function
}	O
,	O
{	O
{	O
mailvar_name_xmailer	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"add the `X-Mailer' header to the outgoing messages"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_mime	pointer
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
,	O
N_	O
(	O
"always compose MIME messages"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_onehop	pointer
,	O
}	O
,	O
MAILVAR_HIDDEN	int
,	O
NULL	O
}	O
,	O
{	O
{	O
mailvar_name_quiet	pointer
,	O
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
|	O
MAILVAR_HIDDEN	int
,	O
N_	O
(	O
"suppress the printing of the version when first invoked"	pointer
)	O
}	O
,	O
{	O
{	O
mailvar_name_PID	pointer
}	O
,	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_string	int
)	O
|	O
MAILVAR_RDONLY	int
,	O
N_	O
(	O
"PID of this process"	pointer
)	O
}	O
,	O
{	O
{	O
NULL	O
}	O
,	O
}	O
}	O
;	O
static	O
int	O
mailvar_symbol_count	int
=	O
sizeof	O
(	O
mailvar_tab	array
)	O
/	O
sizeof	O
(	O
mailvar_tab	array
[	O
0	int
]	O
)	O
-	O
1	int
;	O
struct	O
mailvar_symbol	struct
*	O
find_mailvar_symbol	function
(	O
const	O
char	O
*	O
var	pointer
)	O
{	O
struct	O
mailvar_symbol	struct
*	O
ep	pointer
;	O
for	O
(	O
ep	pointer
=	O
mailvar_tab	array
;	O
ep	pointer
->	O
var	pointer
.	O
name	pointer
;	O
ep	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
ep	pointer
->	O
var	pointer
.	O
name	pointer
,	O
var	pointer
)	O
==	O
0	int
)	O
{	O
while	O
(	O
(	O
ep	pointer
->	O
flags	int
&	O
MAILVAR_ALIAS	int
)	O
&&	O
ep	pointer
>	O
mailvar_tab	array
)	O
ep	pointer
--	O
;	O
return	O
ep	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
print_descr	function
(	O
mu_stream_t	pointer
out	pointer
,	O
const	O
char	O
*	O
s	pointer
,	O
int	O
n	pointer
,	O
int	O
doc_col	int
,	O
int	O
rmargin	int
,	O
char	O
*	O
pfx	pointer
)	O
{	O
mu_stream_stat_buffer	array
stat	pointer
;	O
if	O
(	O
!	O
s	pointer
)	O
return	O
;	O
mu_stream_set_stat	function
(	O
out	pointer
,	O
MU_STREAM_STAT_MASK	O
(	O
MU_STREAM_STAT_OUT	int
)	O
,	O
stat	pointer
)	O
;	O
stat	pointer
[	O
MU_STREAM_STAT_OUT	int
]	O
=	O
n	pointer
;	O
do	O
{	O
const	O
char	O
*	O
p	pointer
;	O
const	O
char	O
*	O
space	pointer
=	O
NULL	O
;	O
if	O
(	O
stat	pointer
[	O
MU_STREAM_STAT_OUT	int
]	O
&&	O
pfx	pointer
)	O
mu_stream_printf	function
(	O
out	pointer
,	O
"%s"	pointer
,	O
pfx	pointer
)	O
;	O
while	O
(	O
stat	pointer
[	O
MU_STREAM_STAT_OUT	int
]	O
<	O
doc_col	int
)	O
mu_stream_write	function
(	O
out	pointer
,	O
" "	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
for	O
(	O
p	pointer
=	O
s	pointer
;	O
*	O
p	pointer
&&	O
p	pointer
<	O
s	pointer
+	O
(	O
rmargin	int
-	O
doc_col	int
)	O
;	O
p	pointer
++	O
)	O
if	O
(	O
mu_isspace	O
(	O
*	O
p	pointer
)	O
)	O
space	pointer
=	O
p	pointer
;	O
if	O
(	O
!	O
space	pointer
||	O
p	pointer
<	O
s	pointer
+	O
(	O
rmargin	int
-	O
doc_col	int
)	O
)	O
{	O
mu_stream_printf	function
(	O
out	pointer
,	O
"%s"	pointer
,	O
s	pointer
)	O
;	O
s	pointer
+=	O
strlen	function
(	O
s	pointer
)	O
;	O
}	O
else	O
{	O
for	O
(	O
;	O
s	pointer
<	O
space	pointer
;	O
s	pointer
++	O
)	O
mu_stream_write	function
(	O
out	pointer
,	O
s	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
for	O
(	O
;	O
*	O
s	pointer
&&	O
mu_isspace	O
(	O
*	O
s	pointer
)	O
;	O
s	pointer
++	O
)	O
;	O
}	O
mu_stream_printf	function
(	O
out	pointer
,	O
"\n"	pointer
)	O
;	O
stat	pointer
[	O
MU_STREAM_STAT_OUT	int
]	O
=	O
1	int
;	O
}	O
while	O
(	O
*	O
s	pointer
)	O
;	O
mu_stream_set_stat	function
(	O
out	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
mailvar_variable_comp	function
(	O
const	O
void	O
*	O
a	pointer
,	O
const	O
void	O
*	O
b	pointer
)	O
{	O
const	O
struct	O
mailvar_variable	struct
*	O
v1	pointer
=	O
a	pointer
;	O
const	O
struct	O
mailvar_variable	struct
*	O
v2	pointer
=	O
b	pointer
;	O
return	O
strcmp	function
(	O
v1	pointer
->	O
name	pointer
,	O
v2	pointer
->	O
name	pointer
)	O
;	O
}	O
struct	O
mailvar_variable	struct
*	O
mailvar_find_variable	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
create	int
)	O
{	O
struct	O
mailvar_symbol	struct
*	O
sym	pointer
;	O
struct	O
mailvar_variable	struct
*	O
var	pointer
;	O
sym	pointer
=	O
find_mailvar_symbol	function
(	O
name	pointer
)	O
;	O
if	O
(	O
sym	pointer
)	O
var	pointer
=	O
&	O
sym	pointer
->	O
var	pointer
;	O
else	O
{	O
struct	O
mailvar_variable	struct
entry	struct
,	O
*	O
p	pointer
;	O
entry	struct
.	O
name	pointer
=	O
(	O
char	O
*	O
)	O
name	pointer
;	O
if	O
(	O
mailvar_list	pointer
==	O
NULL	O
)	O
{	O
mu_list_create	function
(	O
&	O
mailvar_list	pointer
)	O
;	O
mu_list_set_comparator	function
(	O
mailvar_list	pointer
,	O
mailvar_variable_comp	function
)	O
;	O
}	O
if	O
(	O
mu_list_locate	function
(	O
mailvar_list	pointer
,	O
&	O
entry	struct
,	O
(	O
void	O
*	O
*	O
)	O
&	O
p	pointer
)	O
)	O
{	O
if	O
(	O
!	O
create	int
)	O
return	O
0	int
;	O
else	O
{	O
p	pointer
=	O
mu_alloc	function
(	O
sizeof	O
*	O
p	pointer
)	O
;	O
p	pointer
->	O
name	pointer
=	O
mu_strdup	function
(	O
name	pointer
)	O
;	O
mu_list_prepend	function
(	O
mailvar_list	pointer
,	O
p	pointer
)	O
;	O
}	O
}	O
var	pointer
=	O
p	pointer
;	O
var	pointer
->	O
set	int
=	O
0	int
;	O
var	pointer
->	O
type	pointer
=	O
mailvar_type_whatever	int
;	O
var	pointer
->	O
value	pointer
.	O
number	int
=	O
0	int
;	O
}	O
return	O
var	pointer
;	O
}	O
int	O
mailvar_get	function
(	O
void	O
*	O
ptr	pointer
,	O
const	O
char	O
*	O
variable	pointer
,	O
enum	O
mailvar_type	enum
type	pointer
,	O
int	O
warn	int
)	O
{	O
struct	O
mailvar_variable	struct
*	O
var	pointer
=	O
mailvar_find_variable	function
(	O
variable	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
var	pointer
->	O
set	int
||	O
var	pointer
->	O
type	pointer
!=	O
type	pointer
)	O
{	O
if	O
(	O
warn	int
)	O
mu_error	function
(	O
_	O
(	O
"No value set for \"%s\""	pointer
)	O
,	O
variable	pointer
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ptr	pointer
)	O
switch	O
(	O
type	pointer
)	O
{	O
case	O
mailvar_type_string	int
:	O
*	O
(	O
char	O
*	O
*	O
)	O
ptr	pointer
=	O
var	pointer
->	O
value	pointer
.	O
string	pointer
;	O
break	O
;	O
case	O
mailvar_type_number	int
:	O
*	O
(	O
int	O
*	O
)	O
ptr	pointer
=	O
var	pointer
->	O
value	pointer
.	O
number	int
;	O
break	O
;	O
case	O
mailvar_type_boolean	int
:	O
*	O
(	O
int	O
*	O
)	O
ptr	pointer
=	O
var	pointer
->	O
value	pointer
.	O
bool	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
mailvar_is_true	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
return	O
mailvar_get	function
(	O
NULL	O
,	O
name	pointer
,	O
mailvar_type_boolean	int
,	O
0	int
)	O
==	O
0	int
;	O
}	O
void	O
mailvar_variable_reset	function
(	O
struct	O
mailvar_variable	struct
*	O
var	pointer
)	O
{	O
if	O
(	O
!	O
var	pointer
->	O
set	int
)	O
return	O
;	O
switch	O
(	O
var	pointer
->	O
type	pointer
)	O
{	O
case	O
mailvar_type_string	int
:	O
free	function
(	O
var	pointer
->	O
value	pointer
.	O
string	pointer
)	O
;	O
var	pointer
->	O
value	pointer
.	O
string	pointer
=	O
NULL	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
var	pointer
->	O
set	int
=	O
0	int
;	O
}	O
int	O
mailvar_set	function
(	O
const	O
char	O
*	O
variable	pointer
,	O
void	O
*	O
value	pointer
,	O
enum	O
mailvar_type	enum
type	pointer
,	O
int	O
flags	int
)	O
{	O
struct	O
mailvar_variable	struct
*	O
var	pointer
,	O
newvar	struct
;	O
const	O
struct	O
mailvar_symbol	struct
*	O
sym	pointer
=	O
find_mailvar_symbol	function
(	O
variable	pointer
)	O
;	O
enum	O
mailvar_cmd	enum
cmd	enum
=	O
(	O
flags	int
&	O
MOPTF_UNSET	int
)	O
?	O
mailvar_cmd_unset	int
:	O
mailvar_cmd_set	int
;	O
if	O
(	O
!	O
(	O
flags	int
&	O
MOPTF_QUIET	int
)	O
&&	O
mailvar_is_true	function
(	O
mailvar_name_variable_strict	pointer
)	O
)	O
{	O
if	O
(	O
!	O
sym	pointer
)	O
mu_diag_output	function
(	O
MU_DIAG_WARNING	O
,	O
_	O
(	O
"setting unknown variable %s"	pointer
)	O
,	O
variable	pointer
)	O
;	O
else	O
if	O
(	O
sym	pointer
->	O
flags	int
&	O
MAILVAR_RDONLY	int
)	O
{	O
mu_error	function
(	O
cmd	enum
==	O
mailvar_cmd_set	int
?	O
_	O
(	O
"Cannot set read-only variable %s"	pointer
)	O
:	O
_	O
(	O
"Cannot unset read-only variable %s"	pointer
)	O
,	O
variable	pointer
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
sym	pointer
->	O
flags	int
&	O
MAILVAR_TYPEMASK	O
(	O
type	pointer
)	O
)	O
&&	O
cmd	enum
==	O
mailvar_cmd_set	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"Wrong type for %s"	pointer
)	O
,	O
variable	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
var	pointer
=	O
mailvar_find_variable	function
(	O
variable	pointer
,	O
cmd	enum
==	O
mailvar_cmd_set	int
)	O
;	O
if	O
(	O
!	O
var	pointer
||	O
(	O
var	pointer
->	O
set	int
&&	O
!	O
(	O
flags	int
&	O
MOPTF_OVERWRITE	int
)	O
)	O
)	O
return	O
0	int
;	O
newvar	struct
.	O
name	pointer
=	O
var	pointer
->	O
name	pointer
;	O
newvar	struct
.	O
type	pointer
=	O
var	pointer
->	O
type	pointer
;	O
newvar	struct
.	O
set	int
=	O
0	int
;	O
memset	function
(	O
&	O
newvar	struct
.	O
value	pointer
,	O
0	int
,	O
sizeof	O
(	O
newvar	struct
.	O
value	pointer
)	O
)	O
;	O
switch	O
(	O
cmd	enum
)	O
{	O
case	O
mailvar_cmd_set	int
:	O
if	O
(	O
value	pointer
)	O
{	O
switch	O
(	O
type	pointer
)	O
{	O
case	O
mailvar_type_number	int
:	O
newvar	struct
.	O
value	pointer
.	O
number	int
=	O
*	O
(	O
int	O
*	O
)	O
value	pointer
;	O
break	O
;	O
case	O
mailvar_type_string	int
:	O
{	O
char	O
*	O
p	pointer
=	O
strdup	function
(	O
value	pointer
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
{	O
mu_error	function
(	O
"%s"	pointer
,	O
_	O
(	O
"Not enough memory"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
newvar	struct
.	O
value	pointer
.	O
string	pointer
=	O
p	pointer
;	O
}	O
break	O
;	O
case	O
mailvar_type_boolean	int
:	O
newvar	struct
.	O
value	pointer
.	O
bool	int
=	O
*	O
(	O
int	O
*	O
)	O
value	pointer
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
newvar	struct
.	O
set	int
=	O
1	int
;	O
}	O
newvar	struct
.	O
type	pointer
=	O
type	pointer
;	O
if	O
(	O
sym	pointer
&&	O
sym	pointer
->	O
handler	pointer
&&	O
sym	pointer
->	O
flags	int
&	O
MAILVAR_TYPEMASK	O
(	O
type	pointer
)	O
&&	O
sym	pointer
->	O
handler	pointer
(	O
cmd	enum
,	O
&	O
newvar	struct
)	O
)	O
{	O
mailvar_variable_reset	function
(	O
&	O
newvar	struct
)	O
;	O
return	O
1	int
;	O
}	O
mailvar_variable_reset	function
(	O
var	pointer
)	O
;	O
*	O
var	pointer
=	O
newvar	struct
;	O
break	O
;	O
case	O
mailvar_cmd_unset	int
:	O
if	O
(	O
sym	pointer
&&	O
sym	pointer
->	O
handler	pointer
&&	O
sym	pointer
->	O
handler	pointer
(	O
cmd	enum
,	O
var	pointer
)	O
)	O
return	O
1	int
;	O
mailvar_variable_reset	function
(	O
var	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
set_folder	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
var	pointer
)	O
{	O
int	O
rc	int
;	O
if	O
(	O
var	pointer
->	O
value	pointer
.	O
string	pointer
)	O
{	O
char	O
*	O
p	pointer
=	O
mu_tilde_expansion	function
(	O
var	pointer
->	O
value	pointer
.	O
string	pointer
,	O
MU_HIERARCHY_DELIMITER	char
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
mu_alloc_die	function
(	O
)	O
;	O
if	O
(	O
var	pointer
->	O
set	int
)	O
free	function
(	O
var	pointer
->	O
value	pointer
.	O
string	pointer
)	O
;	O
var	pointer
->	O
value	pointer
.	O
string	pointer
=	O
p	pointer
;	O
}	O
rc	int
=	O
mu_set_folder_directory	function
(	O
var	pointer
->	O
value	pointer
.	O
string	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_set_folder_directory"	pointer
,	O
var	pointer
->	O
value	pointer
.	O
string	pointer
,	O
rc	int
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
set_headline	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
var	pointer
)	O
{	O
if	O
(	O
cmd	enum
==	O
mailvar_cmd_unset	int
)	O
return	O
1	int
;	O
mail_compile_headline	function
(	O
var	pointer
->	O
value	pointer
.	O
string	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
set_decode_fallback	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
var	pointer
)	O
{	O
char	O
*	O
value	pointer
;	O
int	O
rc	int
;	O
switch	O
(	O
cmd	enum
)	O
{	O
case	O
mailvar_cmd_set	int
:	O
value	pointer
=	O
var	pointer
->	O
value	pointer
.	O
string	pointer
;	O
break	O
;	O
case	O
mailvar_cmd_unset	int
:	O
value	pointer
=	O
"none"	pointer
;	O
}	O
rc	int
=	O
mu_set_default_fallback	function
(	O
value	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	function
(	O
_	O
(	O
"Incorrect value for decode-fallback"	pointer
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
set_replyregex	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
var	pointer
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
err	long
;	O
switch	O
(	O
cmd	enum
)	O
{	O
case	O
mailvar_cmd_set	int
:	O
if	O
(	O
(	O
rc	int
=	O
mu_unre_set_regex	function
(	O
var	pointer
->	O
value	pointer
.	O
string	pointer
,	O
0	int
,	O
&	O
err	long
)	O
)	O
)	O
{	O
if	O
(	O
err	long
)	O
mu_error	function
(	O
"%s: %s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
,	O
err	long
)	O
;	O
else	O
mu_error	function
(	O
"%s"	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
break	O
;	O
case	O
mailvar_cmd_unset	int
:	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
set_screen	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
var	pointer
)	O
{	O
if	O
(	O
cmd	enum
==	O
mailvar_cmd_set	int
)	O
page_invalidate	function
(	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
set_verbose	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
var	pointer
)	O
{	O
switch	O
(	O
cmd	enum
)	O
{	O
case	O
mailvar_cmd_set	int
:	O
mu_debug_set_category_level	function
(	O
MU_DEBCAT_APP	int
,	O
DEFAULT_DEBUG_LEVEL	O
)	O
;	O
break	O
;	O
case	O
mailvar_cmd_unset	int
:	O
mu_debug_set_category_level	function
(	O
MU_DEBCAT_APP	int
,	O
0	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
set_debug	function
(	O
enum	O
mailvar_cmd	enum
cmd	enum
,	O
struct	O
mailvar_variable	struct
*	O
var	pointer
)	O
{	O
mu_debug_clear_all	function
(	O
)	O
;	O
if	O
(	O
cmd	enum
==	O
mailvar_cmd_set	int
)	O
{	O
if	O
(	O
var	pointer
->	O
type	pointer
==	O
mailvar_type_boolean	int
)	O
{	O
if	O
(	O
var	pointer
->	O
set	int
)	O
mu_debug_set_category_level	function
(	O
MU_DEBCAT_ALL	int
,	O
DEFAULT_DEBUG_LEVEL	O
)	O
;	O
return	O
0	int
;	O
}	O
mu_debug_parse_spec	function
(	O
var	pointer
->	O
value	pointer
.	O
string	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
size_t	long
_mailvar_symbol_count	function
(	O
int	O
set	int
)	O
{	O
if	O
(	O
!	O
set	int
)	O
return	O
mailvar_symbol_count	int
;	O
else	O
{	O
struct	O
mailvar_symbol	struct
*	O
s	pointer
;	O
size_t	long
count	pointer
=	O
0	int
;	O
for	O
(	O
s	pointer
=	O
mailvar_tab	array
;	O
s	pointer
->	O
var	pointer
.	O
name	pointer
;	O
s	pointer
++	O
)	O
if	O
(	O
s	pointer
->	O
var	pointer
.	O
set	int
)	O
count	pointer
++	O
;	O
return	O
count	pointer
;	O
}	O
}	O
static	O
int	O
mailvar_mapper	function
(	O
void	O
*	O
*	O
itmv	pointer
,	O
size_t	long
itmc	long
,	O
void	O
*	O
call_data	pointer
)	O
{	O
return	O
MU_LIST_MAP_OK	int
;	O
}	O
int	O
_mailvar_symbol_to_list	function
(	O
int	O
set	int
,	O
mu_list_t	pointer
list	pointer
)	O
{	O
struct	O
mailvar_symbol	struct
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
mailvar_tab	array
;	O
s	pointer
->	O
var	pointer
.	O
name	pointer
;	O
s	pointer
++	O
)	O
if	O
(	O
!	O
set	int
||	O
s	pointer
->	O
var	pointer
.	O
set	int
)	O
mu_list_append	function
(	O
list	pointer
,	O
&	O
s	pointer
->	O
var	pointer
)	O
;	O
return	O
0	int
;	O
}	O
mu_list_t	pointer
mailvar_list_copy	function
(	O
int	O
set	int
)	O
{	O
mu_list_t	pointer
list	pointer
=	O
NULL	O
;	O
if	O
(	O
mailvar_list	pointer
)	O
mu_list_map	function
(	O
mailvar_list	pointer
,	O
mailvar_mapper	function
,	O
NULL	O
,	O
1	int
,	O
&	O
list	pointer
)	O
;	O
if	O
(	O
!	O
list	pointer
)	O
mu_list_create	function
(	O
&	O
list	pointer
)	O
;	O
_mailvar_symbol_to_list	function
(	O
set	int
,	O
list	pointer
)	O
;	O
mu_list_sort	function
(	O
list	pointer
,	O
mailvar_variable_comp	function
)	O
;	O
return	O
list	pointer
;	O
}	O
enum	O
{	O
MAILVAR_ITR_ALL	int
=	O
0	int
,	O
MAILVAR_ITR_SET	int
=	O
0x1	int
,	O
MAILVAR_ITR_WRITABLE	int
=	O
0x2	int
}	O
;	O
struct	O
mailvar_iterator	struct
{	O
int	O
flags	int
;	O
const	O
char	O
*	O
prefix	array
;	O
int	O
prefixlen	int
;	O
mu_list_t	pointer
varlist	pointer
;	O
mu_iterator_t	pointer
varitr	pointer
;	O
}	O
;	O
const	O
char	O
*	O
mailvar_iterate_next	function
(	O
struct	O
mailvar_iterator	struct
*	O
itr	pointer
)	O
{	O
struct	O
mailvar_variable	struct
*	O
vp	pointer
;	O
while	O
(	O
!	O
mu_iterator_is_done	function
(	O
itr	pointer
->	O
varitr	pointer
)	O
)	O
{	O
size_t	long
len	long
;	O
mu_iterator_current	function
(	O
itr	pointer
->	O
varitr	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
vp	pointer
)	O
;	O
mu_iterator_next	function
(	O
itr	pointer
->	O
varitr	pointer
)	O
;	O
if	O
(	O
itr	pointer
->	O
flags	int
&	O
MAILVAR_ITR_WRITABLE	int
)	O
{	O
const	O
struct	O
mailvar_symbol	struct
*	O
sym	pointer
=	O
find_mailvar_symbol	function
(	O
vp	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
sym	pointer
&&	O
(	O
sym	pointer
->	O
flags	int
&	O
MAILVAR_RDONLY	int
)	O
)	O
continue	O
;	O
}	O
if	O
(	O
strlen	function
(	O
vp	pointer
->	O
name	pointer
)	O
>=	O
itr	pointer
->	O
prefixlen	int
&&	O
strncmp	function
(	O
vp	pointer
->	O
name	pointer
,	O
itr	pointer
->	O
prefix	array
,	O
itr	pointer
->	O
prefixlen	int
)	O
==	O
0	int
)	O
return	O
strdup	function
(	O
vp	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
itr	pointer
->	O
prefixlen	int
>=	O
2	int
&&	O
memcmp	function
(	O
itr	pointer
->	O
prefix	array
,	O
"no"	pointer
,	O
2	int
)	O
==	O
0	int
&&	O
(	O
len	long
=	O
strlen	function
(	O
vp	pointer
->	O
name	pointer
)	O
)	O
>=	O
itr	pointer
->	O
prefixlen	int
-	O
2	int
&&	O
memcmp	function
(	O
vp	pointer
->	O
name	pointer
,	O
itr	pointer
->	O
prefix	array
+	O
2	int
,	O
itr	pointer
->	O
prefixlen	int
-	O
2	int
)	O
==	O
0	int
)	O
{	O
char	O
*	O
p	pointer
;	O
struct	O
mailvar_symbol	struct
*	O
sym	pointer
=	O
find_mailvar_symbol	function
(	O
vp	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
sym	pointer
&&	O
!	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
MAILVAR_TYPEMASK	O
(	O
mailvar_type_boolean	int
)	O
)	O
)	O
)	O
continue	O
;	O
p	pointer
=	O
malloc	function
(	O
len	long
+	O
3	int
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
strcpy	function
(	O
p	pointer
,	O
"no"	pointer
)	O
;	O
strcpy	function
(	O
p	pointer
+	O
2	int
,	O
vp	pointer
->	O
name	pointer
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
}	O
return	O
NULL	O
;	O
}	O
const	O
char	O
*	O
mailvar_iterate_first	function
(	O
int	O
flags	int
,	O
const	O
char	O
*	O
prefix	array
,	O
struct	O
mailvar_iterator	struct
*	O
*	O
pitr	pointer
)	O
{	O
struct	O
mailvar_iterator	struct
*	O
itr	pointer
=	O
mu_alloc	function
(	O
sizeof	O
*	O
itr	pointer
)	O
;	O
itr	pointer
->	O
flags	int
=	O
flags	int
;	O
itr	pointer
->	O
prefix	array
=	O
prefix	array
;	O
itr	pointer
->	O
prefixlen	int
=	O
strlen	function
(	O
prefix	array
)	O
;	O
itr	pointer
->	O
varlist	pointer
=	O
mailvar_list_copy	function
(	O
flags	int
&	O
MAILVAR_ITR_SET	int
)	O
;	O
mu_list_get_iterator	function
(	O
itr	pointer
->	O
varlist	pointer
,	O
&	O
itr	pointer
->	O
varitr	pointer
)	O
;	O
mu_iterator_first	function
(	O
itr	pointer
->	O
varitr	pointer
)	O
;	O
*	O
pitr	pointer
=	O
itr	pointer
;	O
return	O
mailvar_iterate_next	function
(	O
itr	pointer
)	O
;	O
}	O
void	O
mailvar_iterate_end	function
(	O
struct	O
mailvar_iterator	struct
*	O
*	O
pitr	pointer
)	O
{	O
if	O
(	O
pitr	pointer
&&	O
*	O
pitr	pointer
)	O
{	O
struct	O
mailvar_iterator	struct
*	O
itr	pointer
=	O
*	O
pitr	pointer
;	O
mu_iterator_destroy	function
(	O
&	O
itr	pointer
->	O
varitr	pointer
)	O
;	O
mu_list_destroy	function
(	O
&	O
itr	pointer
->	O
varlist	pointer
)	O
;	O
free	function
(	O
itr	pointer
)	O
;	O
*	O
pitr	pointer
=	O
NULL	O
;	O
}	O
}	O
struct	O
mailvar_print_closure	struct
{	O
int	O
prettyprint	int
;	O
mu_stream_t	pointer
out	pointer
;	O
int	O
width	int
;	O
}	O
;	O
static	O
int	O
mailvar_printer	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
mailvar_variable	struct
*	O
vp	pointer
=	O
item	pointer
;	O
struct	O
mailvar_print_closure	struct
*	O
clos	pointer
=	O
data	pointer
;	O
if	O
(	O
clos	pointer
->	O
prettyprint	int
)	O
{	O
const	O
struct	O
mailvar_symbol	struct
*	O
sym	pointer
=	O
find_mailvar_symbol	function
(	O
vp	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
sym	pointer
)	O
{	O
if	O
(	O
sym	pointer
->	O
flags	int
&	O
MAILVAR_HIDDEN	int
)	O
return	O
0	int
;	O
if	O
(	O
sym	pointer
->	O
flags	int
&	O
MAILVAR_RDONLY	int
)	O
mu_stream_printf	function
(	O
clos	pointer
->	O
out	pointer
,	O
"# %s:\n"	pointer
,	O
_	O
(	O
"Read-only variable"	pointer
)	O
)	O
;	O
print_descr	function
(	O
clos	pointer
->	O
out	pointer
,	O
gettext	function
(	O
sym	pointer
->	O
descr	pointer
)	O
,	O
1	int
,	O
3	int
,	O
clos	pointer
->	O
width	int
-	O
1	int
,	O
"# "	pointer
)	O
;	O
}	O
}	O
switch	O
(	O
vp	pointer
->	O
type	pointer
)	O
{	O
case	O
mailvar_type_number	int
:	O
mu_stream_printf	function
(	O
clos	pointer
->	O
out	pointer
,	O
"%s=%d"	pointer
,	O
vp	pointer
->	O
name	pointer
,	O
vp	pointer
->	O
value	pointer
.	O
number	int
)	O
;	O
break	O
;	O
case	O
mailvar_type_string	int
:	O
mu_stream_printf	function
(	O
clos	pointer
->	O
out	pointer
,	O
"%s=\"%s\""	pointer
,	O
vp	pointer
->	O
name	pointer
,	O
vp	pointer
->	O
value	pointer
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
mailvar_type_boolean	int
:	O
if	O
(	O
!	O
vp	pointer
->	O
value	pointer
.	O
bool	int
)	O
mu_stream_printf	function
(	O
clos	pointer
->	O
out	pointer
,	O
"no"	pointer
)	O
;	O
mu_stream_printf	function
(	O
clos	pointer
->	O
out	pointer
,	O
"%s"	pointer
,	O
vp	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
case	O
mailvar_type_whatever	int
:	O
mu_stream_printf	function
(	O
clos	pointer
->	O
out	pointer
,	O
"%s %s"	pointer
,	O
vp	pointer
->	O
name	pointer
,	O
_	O
(	O
"oops?"	pointer
)	O
)	O
;	O
}	O
mu_stream_printf	function
(	O
clos	pointer
->	O
out	pointer
,	O
"\n"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
mailvar_print	function
(	O
int	O
set	int
)	O
{	O
mu_list_t	pointer
varlist	pointer
;	O
size_t	long
count	pointer
;	O
struct	O
mailvar_print_closure	struct
clos	pointer
;	O
varlist	pointer
=	O
mailvar_list_copy	function
(	O
set	int
)	O
;	O
mu_list_count	function
(	O
varlist	pointer
,	O
&	O
count	pointer
)	O
;	O
clos	pointer
.	O
out	pointer
=	O
open_pager	function
(	O
count	pointer
)	O
;	O
clos	pointer
.	O
prettyprint	int
=	O
mailvar_is_true	function
(	O
mailvar_name_variable_pretty_print	pointer
)	O
;	O
clos	pointer
.	O
width	int
=	O
util_screen_columns	function
(	O
)	O
;	O
mu_list_foreach	function
(	O
varlist	pointer
,	O
mailvar_printer	function
,	O
&	O
clos	pointer
)	O
;	O
mu_list_destroy	function
(	O
&	O
varlist	pointer
)	O
;	O
mu_stream_unref	function
(	O
clos	pointer
.	O
out	pointer
)	O
;	O
}	O
void	O
mailvar_variable_format	function
(	O
mu_stream_t	pointer
stream	pointer
,	O
const	O
struct	O
mailvar_variable	struct
*	O
var	pointer
,	O
const	O
char	O
*	O
defval	int
)	O
{	O
if	O
(	O
var	pointer
)	O
switch	O
(	O
var	pointer
->	O
type	pointer
)	O
{	O
case	O
mailvar_type_string	int
:	O
mu_stream_printf	function
(	O
stream	pointer
,	O
"%s"	pointer
,	O
var	pointer
->	O
value	pointer
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
mailvar_type_number	int
:	O
mu_stream_printf	function
(	O
stream	pointer
,	O
"%d"	pointer
,	O
var	pointer
->	O
value	pointer
.	O
number	int
)	O
;	O
break	O
;	O
case	O
mailvar_type_boolean	int
:	O
mu_stream_printf	function
(	O
stream	pointer
,	O
"%s"	pointer
,	O
var	pointer
->	O
set	int
?	O
"yes"	pointer
:	O
"no"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
defval	int
)	O
mu_stream_printf	function
(	O
stream	pointer
,	O
"%s"	pointer
,	O
defval	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
char	O
*	O
typestr	array
[	O
]	O
=	O
{	O
N_	O
(	O
"untyped"	pointer
)	O
,	O
N_	O
(	O
"numeric"	pointer
)	O
,	O
N_	O
(	O
"string"	pointer
)	O
,	O
N_	O
(	O
"boolean"	pointer
)	O
}	O
;	O
static	O
void	O
describe_symbol	function
(	O
mu_stream_t	pointer
out	pointer
,	O
int	O
width	int
,	O
const	O
struct	O
mailvar_symbol	struct
*	O
sym	pointer
)	O
{	O
int	O
i	int
,	O
t	int
;	O
const	O
struct	O
mailvar_symbol	struct
*	O
ali	pointer
;	O
mu_stream_stat_buffer	array
stat	pointer
;	O
mu_stream_set_stat	function
(	O
out	pointer
,	O
MU_STREAM_STAT_MASK	O
(	O
MU_STREAM_STAT_OUT	int
)	O
,	O
stat	pointer
)	O
;	O
mu_stream_printf	function
(	O
out	pointer
,	O
"%s"	pointer
,	O
sym	pointer
->	O
var	pointer
.	O
name	pointer
)	O
;	O
for	O
(	O
ali	pointer
=	O
sym	pointer
+	O
1	int
;	O
ali	pointer
->	O
var	pointer
.	O
name	pointer
&&	O
ali	pointer
->	O
flags	int
&	O
MAILVAR_ALIAS	int
;	O
ali	pointer
++	O
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
ali	pointer
->	O
var	pointer
.	O
name	pointer
)	O
+	O
2	int
;	O
if	O
(	O
stat	pointer
[	O
MU_STREAM_STAT_OUT	int
]	O
+	O
len	long
>	O
width	int
)	O
{	O
stat	pointer
[	O
MU_STREAM_STAT_OUT	int
]	O
=	O
0	int
;	O
mu_stream_printf	function
(	O
out	pointer
,	O
"\n%s"	pointer
,	O
ali	pointer
->	O
var	pointer
.	O
name	pointer
)	O
;	O
}	O
else	O
mu_stream_printf	function
(	O
out	pointer
,	O
", %s"	pointer
,	O
ali	pointer
->	O
var	pointer
.	O
name	pointer
)	O
;	O
}	O
mu_stream_printf	function
(	O
out	pointer
,	O
"\n"	pointer
)	O
;	O
mu_stream_set_stat	function
(	O
out	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_printf	function
(	O
out	pointer
,	O
_	O
(	O
"Type: "	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
,	O
t	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
typestr	array
)	O
/	O
sizeof	O
(	O
typestr	array
[	O
0	int
]	O
)	O
;	O
i	int
++	O
)	O
if	O
(	O
sym	pointer
->	O
flags	int
&	O
MAILVAR_TYPEMASK	O
(	O
i	int
)	O
)	O
{	O
if	O
(	O
t	int
++	O
)	O
mu_stream_printf	function
(	O
out	pointer
,	O
" %s "	pointer
,	O
_	O
(	O
"or"	pointer
)	O
)	O
;	O
mu_stream_printf	function
(	O
out	pointer
,	O
"%s"	pointer
,	O
gettext	function
(	O
typestr	array
[	O
i	int
]	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
t	int
)	O
mu_stream_printf	function
(	O
out	pointer
,	O
"%s"	pointer
,	O
gettext	function
(	O
typestr	array
[	O
0	int
]	O
)	O
)	O
;	O
mu_stream_printf	function
(	O
out	pointer
,	O
"\n"	pointer
)	O
;	O
mu_stream_printf	function
(	O
out	pointer
,	O
"%s"	pointer
,	O
_	O
(	O
"Current value: "	pointer
)	O
)	O
;	O
mailvar_variable_format	function
(	O
out	pointer
,	O
&	O
sym	pointer
->	O
var	pointer
,	O
_	O
(	O
"[not set]"	pointer
)	O
)	O
;	O
if	O
(	O
sym	pointer
->	O
flags	int
&	O
MAILVAR_RDONLY	int
)	O
mu_stream_printf	function
(	O
out	pointer
,	O
" [%s]"	pointer
,	O
_	O
(	O
"read-only"	pointer
)	O
)	O
;	O
mu_stream_printf	function
(	O
out	pointer
,	O
"\n"	pointer
)	O
;	O
print_descr	function
(	O
out	pointer
,	O
gettext	function
(	O
sym	pointer
->	O
descr	pointer
?	O
sym	pointer
->	O
descr	pointer
:	O
N_	O
(	O
"Not documented"	pointer
)	O
)	O
,	O
1	int
,	O
1	int
,	O
width	int
-	O
1	int
,	O
NULL	O
)	O
;	O
mu_stream_printf	function
(	O
out	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
int	O
mail_variable	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
pagelines	int
=	O
util_get_crt	function
(	O
)	O
;	O
int	O
width	int
=	O
util_screen_columns	function
(	O
)	O
;	O
mu_stream_t	pointer
out	pointer
=	O
open_pager	function
(	O
pagelines	int
+	O
1	int
)	O
;	O
if	O
(	O
argc	int
==	O
1	int
)	O
{	O
struct	O
mailvar_symbol	struct
*	O
sym	pointer
;	O
for	O
(	O
sym	pointer
=	O
mailvar_tab	array
;	O
sym	pointer
->	O
var	pointer
.	O
name	pointer
;	O
sym	pointer
++	O
)	O
if	O
(	O
!	O
(	O
sym	pointer
->	O
flags	int
&	O
(	O
MAILVAR_HIDDEN	int
|	O
MAILVAR_ALIAS	int
)	O
)	O
)	O
describe_symbol	function
(	O
out	pointer
,	O
width	int
,	O
sym	pointer
)	O
;	O
}	O
else	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
argc	int
;	O
i	int
++	O
)	O
{	O
struct	O
mailvar_symbol	struct
*	O
sym	pointer
=	O
find_mailvar_symbol	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
sym	pointer
)	O
mu_stream_printf	function
(	O
out	pointer
,	O
"%s: unknown\n"	pointer
,	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
else	O
describe_symbol	function
(	O
out	pointer
,	O
width	int
,	O
sym	pointer
)	O
;	O
}	O
}	O
mu_stream_unref	function
(	O
out	pointer
)	O
;	O
return	O
0	int
;	O
}	O
