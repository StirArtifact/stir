void	O
*	O
xalloc	function
(	O
unsigned	O
int	O
size	int
)	O
{	O
void	O
*	O
pt	pointer
=	O
malloc	function
(	O
size	int
)	O
;	O
if	O
(	O
!	O
pt	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"xalloc: Out of memory!\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
memset	function
(	O
pt	pointer
,	O
0	int
,	O
(	O
unsigned	O
long	O
)	O
size	int
)	O
;	O
return	O
pt	pointer
;	O
}	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
pt	pointer
,	O
unsigned	O
int	O
size	int
)	O
{	O
void	O
*	O
ptnew	pointer
=	O
realloc	function
(	O
pt	pointer
,	O
size	int
)	O
;	O
if	O
(	O
!	O
ptnew	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"xrealloc: Out of memory!\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
return	O
ptnew	pointer
;	O
}	O
SGFNode	struct
*	O
sgfNewNode	function
(	O
)	O
{	O
SGFNode	struct
*	O
newnode	pointer
;	O
newnode	pointer
=	O
xalloc	function
(	O
sizeof	O
(	O
SGFNode	struct
)	O
)	O
;	O
newnode	pointer
->	O
next	pointer
=	O
NULL	O
;	O
newnode	pointer
->	O
props	pointer
=	O
NULL	O
;	O
newnode	pointer
->	O
parent	pointer
=	O
NULL	O
;	O
newnode	pointer
->	O
child	pointer
=	O
NULL	O
;	O
return	O
newnode	pointer
;	O
}	O
void	O
sgfFreeNode	function
(	O
SGFNode	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
node	pointer
==	O
NULL	O
)	O
return	O
;	O
sgfFreeNode	function
(	O
node	pointer
->	O
next	pointer
)	O
;	O
sgfFreeNode	function
(	O
node	pointer
->	O
child	pointer
)	O
;	O
sgfFreeProperty	function
(	O
node	pointer
->	O
props	pointer
)	O
;	O
free	function
(	O
node	pointer
)	O
;	O
}	O
void	O
sgfAddProperty	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
,	O
const	O
char	O
*	O
value	pointer
)	O
{	O
SGFProperty	struct
*	O
prop	pointer
=	O
node	pointer
->	O
props	pointer
;	O
if	O
(	O
prop	pointer
)	O
while	O
(	O
prop	pointer
->	O
next	pointer
)	O
prop	pointer
=	O
prop	pointer
->	O
next	pointer
;	O
sgfMkProperty	function
(	O
name	short
,	O
value	pointer
,	O
node	pointer
,	O
prop	pointer
)	O
;	O
}	O
void	O
sgfAddPropertyInt	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
,	O
long	O
val	long
)	O
{	O
char	O
buffer	array
[	O
10	int
]	O
;	O
gg_snprintf	function
(	O
buffer	array
,	O
10	int
,	O
"%ld"	pointer
,	O
val	long
)	O
;	O
sgfAddProperty	function
(	O
node	pointer
,	O
name	short
,	O
buffer	array
)	O
;	O
}	O
void	O
sgfAddPropertyFloat	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
,	O
float	O
val	long
)	O
{	O
char	O
buffer	array
[	O
10	int
]	O
;	O
gg_snprintf	function
(	O
buffer	array
,	O
10	int
,	O
"%3.1f"	pointer
,	O
val	long
)	O
;	O
sgfAddProperty	function
(	O
node	pointer
,	O
name	short
,	O
buffer	array
)	O
;	O
}	O
int	O
sgfGetIntProperty	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
,	O
int	O
*	O
value	pointer
)	O
{	O
SGFProperty	struct
*	O
prop	pointer
;	O
short	O
nam	short
=	O
name	short
[	O
0	int
]	O
|	O
name	short
[	O
1	int
]	O
<<	O
8	int
;	O
for	O
(	O
prop	pointer
=	O
node	pointer
->	O
props	pointer
;	O
prop	pointer
;	O
prop	pointer
=	O
prop	pointer
->	O
next	pointer
)	O
if	O
(	O
prop	pointer
->	O
name	short
==	O
nam	short
)	O
{	O
*	O
value	pointer
=	O
atoi	function
(	O
prop	pointer
->	O
value	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
sgfGetFloatProperty	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
,	O
float	O
*	O
value	pointer
)	O
{	O
SGFProperty	struct
*	O
prop	pointer
;	O
short	O
nam	short
=	O
name	short
[	O
0	int
]	O
|	O
name	short
[	O
1	int
]	O
<<	O
8	int
;	O
for	O
(	O
prop	pointer
=	O
node	pointer
->	O
props	pointer
;	O
prop	pointer
;	O
prop	pointer
=	O
prop	pointer
->	O
next	pointer
)	O
if	O
(	O
prop	pointer
->	O
name	short
==	O
nam	short
)	O
{	O
*	O
value	pointer
=	O
(	O
float	O
)	O
atof	function
(	O
prop	pointer
->	O
value	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
sgfGetCharProperty	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
,	O
char	O
*	O
*	O
value	pointer
)	O
{	O
SGFProperty	struct
*	O
prop	pointer
;	O
short	O
nam	short
=	O
name	short
[	O
0	int
]	O
|	O
name	short
[	O
1	int
]	O
<<	O
8	int
;	O
for	O
(	O
prop	pointer
=	O
node	pointer
->	O
props	pointer
;	O
prop	pointer
;	O
prop	pointer
=	O
prop	pointer
->	O
next	pointer
)	O
if	O
(	O
prop	pointer
->	O
name	short
==	O
nam	short
)	O
{	O
*	O
value	pointer
=	O
prop	pointer
->	O
value	pointer
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
sgfHasProperty	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
)	O
{	O
SGFProperty	struct
*	O
prop	pointer
;	O
short	O
nam	short
=	O
name	short
[	O
0	int
]	O
|	O
name	short
[	O
1	int
]	O
<<	O
8	int
;	O
for	O
(	O
prop	pointer
=	O
node	pointer
->	O
props	pointer
;	O
prop	pointer
;	O
prop	pointer
=	O
prop	pointer
->	O
next	pointer
)	O
if	O
(	O
prop	pointer
->	O
name	short
==	O
nam	short
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
void	O
sgfOverwriteProperty	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
SGFProperty	struct
*	O
prop	pointer
;	O
short	O
nam	short
=	O
name	short
[	O
0	int
]	O
|	O
name	short
[	O
1	int
]	O
<<	O
8	int
;	O
for	O
(	O
prop	pointer
=	O
node	pointer
->	O
props	pointer
;	O
prop	pointer
;	O
prop	pointer
=	O
prop	pointer
->	O
next	pointer
)	O
if	O
(	O
prop	pointer
->	O
name	short
==	O
nam	short
)	O
{	O
prop	pointer
->	O
value	pointer
=	O
xrealloc	function
(	O
prop	pointer
->	O
value	pointer
,	O
strlen	function
(	O
text	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
prop	pointer
->	O
value	pointer
,	O
text	pointer
)	O
;	O
return	O
;	O
}	O
sgfAddProperty	function
(	O
node	pointer
,	O
name	short
,	O
text	pointer
)	O
;	O
}	O
void	O
sgfOverwritePropertyInt	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
,	O
int	O
val	long
)	O
{	O
SGFProperty	struct
*	O
prop	pointer
;	O
short	O
nam	short
=	O
name	short
[	O
0	int
]	O
|	O
name	short
[	O
1	int
]	O
<<	O
8	int
;	O
for	O
(	O
prop	pointer
=	O
node	pointer
->	O
props	pointer
;	O
prop	pointer
;	O
prop	pointer
=	O
prop	pointer
->	O
next	pointer
)	O
if	O
(	O
prop	pointer
->	O
name	short
==	O
nam	short
)	O
{	O
prop	pointer
->	O
value	pointer
=	O
xrealloc	function
(	O
prop	pointer
->	O
value	pointer
,	O
12	int
)	O
;	O
gg_snprintf	function
(	O
prop	pointer
->	O
value	pointer
,	O
12	int
,	O
"%d"	pointer
,	O
val	long
)	O
;	O
return	O
;	O
}	O
sgfAddPropertyInt	function
(	O
node	pointer
,	O
name	short
,	O
val	long
)	O
;	O
}	O
void	O
sgfOverwritePropertyFloat	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
,	O
float	O
val	long
)	O
{	O
SGFProperty	struct
*	O
prop	pointer
;	O
short	O
nam	short
=	O
name	short
[	O
0	int
]	O
|	O
name	short
[	O
1	int
]	O
<<	O
8	int
;	O
for	O
(	O
prop	pointer
=	O
node	pointer
->	O
props	pointer
;	O
prop	pointer
;	O
prop	pointer
=	O
prop	pointer
->	O
next	pointer
)	O
if	O
(	O
prop	pointer
->	O
name	short
==	O
nam	short
)	O
{	O
prop	pointer
->	O
value	pointer
=	O
xrealloc	function
(	O
prop	pointer
->	O
value	pointer
,	O
15	int
)	O
;	O
gg_snprintf	function
(	O
prop	pointer
->	O
value	pointer
,	O
15	int
,	O
"%3.1f"	pointer
,	O
val	long
)	O
;	O
return	O
;	O
}	O
sgfAddPropertyFloat	function
(	O
node	pointer
,	O
name	short
,	O
val	long
)	O
;	O
}	O
SGFNode	struct
*	O
sgfPrev	function
(	O
SGFNode	struct
*	O
node	pointer
)	O
{	O
SGFNode	struct
*	O
q	pointer
;	O
SGFNode	struct
*	O
prev	pointer
;	O
if	O
(	O
!	O
node	pointer
->	O
parent	pointer
)	O
return	O
NULL	O
;	O
q	pointer
=	O
node	pointer
->	O
parent	pointer
->	O
child	pointer
;	O
prev	pointer
=	O
NULL	O
;	O
while	O
(	O
q	pointer
&&	O
q	pointer
!=	O
node	pointer
)	O
{	O
prev	pointer
=	O
q	pointer
;	O
q	pointer
=	O
q	pointer
->	O
next	pointer
;	O
}	O
return	O
prev	pointer
;	O
}	O
SGFNode	struct
*	O
sgfRoot	function
(	O
SGFNode	struct
*	O
node	pointer
)	O
{	O
while	O
(	O
node	pointer
->	O
parent	pointer
)	O
node	pointer
=	O
node	pointer
->	O
parent	pointer
;	O
return	O
node	pointer
;	O
}	O
static	O
SGFProperty	struct
*	O
do_sgf_make_property	function
(	O
short	O
sgf_name	short
,	O
const	O
char	O
*	O
value	pointer
,	O
SGFNode	struct
*	O
node	pointer
,	O
SGFProperty	struct
*	O
last	pointer
)	O
{	O
SGFProperty	struct
*	O
prop	pointer
;	O
prop	pointer
=	O
(	O
SGFProperty	struct
*	O
)	O
xalloc	function
(	O
sizeof	O
(	O
SGFProperty	struct
)	O
)	O
;	O
prop	pointer
->	O
name	short
=	O
sgf_name	short
;	O
prop	pointer
->	O
value	pointer
=	O
xalloc	function
(	O
strlen	function
(	O
value	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
prop	pointer
->	O
value	pointer
,	O
value	pointer
)	O
;	O
prop	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
last	pointer
==	O
NULL	O
)	O
node	pointer
->	O
props	pointer
=	O
prop	pointer
;	O
else	O
last	pointer
->	O
next	pointer
=	O
prop	pointer
;	O
return	O
prop	pointer
;	O
}	O
SGFProperty	struct
*	O
sgfMkProperty	function
(	O
const	O
char	O
*	O
name	short
,	O
const	O
char	O
*	O
value	pointer
,	O
SGFNode	struct
*	O
node	pointer
,	O
SGFProperty	struct
*	O
last	pointer
)	O
{	O
static	O
const	O
short	O
properties_allowing_ranges	array
[	O
12	int
]	O
=	O
{	O
SGFAB	int
,	O
SGFAW	int
,	O
SGFAE	int
,	O
SGFCR	int
,	O
SGFMA	int
,	O
SGFSQ	int
,	O
SGFTR	int
,	O
SGFDD	int
,	O
SGFSL	int
,	O
SGFVW	int
,	O
SGFTB	int
,	O
SGFTW	int
}	O
;	O
int	O
k	int
;	O
short	O
sgf_name	short
;	O
if	O
(	O
strlen	function
(	O
name	short
)	O
==	O
1	int
)	O
sgf_name	short
=	O
name	short
[	O
0	int
]	O
|	O
(	O
short	O
)	O
(	O
' '	O
<<	O
8	int
)	O
;	O
else	O
sgf_name	short
=	O
name	short
[	O
0	int
]	O
|	O
name	short
[	O
1	int
]	O
<<	O
8	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
12	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
properties_allowing_ranges	array
[	O
k	int
]	O
==	O
sgf_name	short
)	O
break	O
;	O
}	O
if	O
(	O
k	int
<	O
12	int
&&	O
strlen	function
(	O
value	pointer
)	O
==	O
5	int
&&	O
value	pointer
[	O
2	int
]	O
==	O
':'	O
)	O
{	O
char	O
x1	char
=	O
value	pointer
[	O
0	int
]	O
;	O
char	O
y1	char
=	O
value	pointer
[	O
1	int
]	O
;	O
char	O
x2	char
=	O
value	pointer
[	O
3	int
]	O
;	O
char	O
y2	char
=	O
value	pointer
[	O
4	int
]	O
;	O
char	O
new_value	array
[	O
]	O
=	O
"xy"	pointer
;	O
if	O
(	O
x1	char
<=	O
x2	char
&&	O
y1	char
<=	O
y2	char
)	O
{	O
for	O
(	O
new_value	array
[	O
0	int
]	O
=	O
x1	char
;	O
new_value	array
[	O
0	int
]	O
<=	O
x2	char
;	O
new_value	array
[	O
0	int
]	O
++	O
)	O
{	O
for	O
(	O
new_value	array
[	O
1	int
]	O
=	O
y1	char
;	O
new_value	array
[	O
1	int
]	O
<=	O
y2	char
;	O
new_value	array
[	O
1	int
]	O
++	O
)	O
last	pointer
=	O
do_sgf_make_property	function
(	O
sgf_name	short
,	O
new_value	array
,	O
node	pointer
,	O
last	pointer
)	O
;	O
}	O
return	O
last	pointer
;	O
}	O
}	O
return	O
do_sgf_make_property	function
(	O
sgf_name	short
,	O
value	pointer
,	O
node	pointer
,	O
last	pointer
)	O
;	O
}	O
void	O
sgfFreeProperty	function
(	O
SGFProperty	struct
*	O
prop	pointer
)	O
{	O
if	O
(	O
prop	pointer
==	O
NULL	O
)	O
return	O
;	O
sgfFreeProperty	function
(	O
prop	pointer
->	O
next	pointer
)	O
;	O
free	function
(	O
prop	pointer
->	O
value	pointer
)	O
;	O
free	function
(	O
prop	pointer
)	O
;	O
}	O
SGFNode	struct
*	O
sgfAddStone	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
color	int
,	O
int	O
movex	int
,	O
int	O
movey	int
)	O
{	O
char	O
move	array
[	O
3	int
]	O
;	O
sprintf	function
(	O
move	array
,	O
"%c%c"	pointer
,	O
movey	int
+	O
'a'	O
,	O
movex	int
+	O
'a'	O
)	O
;	O
sgfAddProperty	function
(	O
node	pointer
,	O
(	O
color	int
==	O
BLACK	int
)	O
?	O
"AB"	pointer
:	O
"AW"	pointer
,	O
move	array
)	O
;	O
return	O
node	pointer
;	O
}	O
SGFNode	struct
*	O
sgfAddPlay	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
who	int
,	O
int	O
movex	int
,	O
int	O
movey	int
)	O
{	O
char	O
move	array
[	O
3	int
]	O
;	O
SGFNode	struct
*	O
new	pointer
;	O
if	O
(	O
movex	int
==	O
-	O
1	int
&&	O
movey	int
==	O
-	O
1	int
)	O
move	array
[	O
0	int
]	O
=	O
0	int
;	O
else	O
sprintf	function
(	O
move	array
,	O
"%c%c"	pointer
,	O
movey	int
+	O
'a'	O
,	O
movex	int
+	O
'a'	O
)	O
;	O
if	O
(	O
node	pointer
->	O
child	pointer
)	O
new	pointer
=	O
sgfStartVariantFirst	function
(	O
node	pointer
->	O
child	pointer
)	O
;	O
else	O
{	O
new	pointer
=	O
sgfNewNode	function
(	O
)	O
;	O
node	pointer
->	O
child	pointer
=	O
new	pointer
;	O
new	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
}	O
sgfAddProperty	function
(	O
new	pointer
,	O
(	O
who	int
==	O
BLACK	int
)	O
?	O
"B"	pointer
:	O
"W"	pointer
,	O
move	array
)	O
;	O
return	O
new	pointer
;	O
}	O
SGFNode	struct
*	O
sgfAddPlayLast	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
who	int
,	O
int	O
movex	int
,	O
int	O
movey	int
)	O
{	O
char	O
move	array
[	O
3	int
]	O
;	O
SGFNode	struct
*	O
new	pointer
;	O
if	O
(	O
movex	int
==	O
-	O
1	int
&&	O
movey	int
==	O
-	O
1	int
)	O
move	array
[	O
0	int
]	O
=	O
0	int
;	O
else	O
sprintf	function
(	O
move	array
,	O
"%c%c"	pointer
,	O
movey	int
+	O
'a'	O
,	O
movex	int
+	O
'a'	O
)	O
;	O
new	pointer
=	O
sgfAddChild	function
(	O
node	pointer
)	O
;	O
sgfAddProperty	function
(	O
new	pointer
,	O
(	O
who	int
==	O
BLACK	int
)	O
?	O
"B"	pointer
:	O
"W"	pointer
,	O
move	array
)	O
;	O
return	O
new	pointer
;	O
}	O
SGFNode	struct
*	O
sgfCreateHeaderNode	function
(	O
int	O
boardsize	int
,	O
float	O
komi	float
,	O
int	O
handicap	int
)	O
{	O
SGFNode	struct
*	O
root	pointer
=	O
sgfNewNode	function
(	O
)	O
;	O
sgfAddPropertyInt	function
(	O
root	pointer
,	O
"SZ"	pointer
,	O
boardsize	int
)	O
;	O
sgfAddPropertyFloat	function
(	O
root	pointer
,	O
"KM"	pointer
,	O
komi	float
)	O
;	O
sgfAddPropertyInt	function
(	O
root	pointer
,	O
"HA"	pointer
,	O
handicap	int
)	O
;	O
return	O
root	pointer
;	O
}	O
SGFNode	struct
*	O
sgfAddComment	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
comment	pointer
)	O
{	O
sgfAddProperty	function
(	O
node	pointer
,	O
"C "	pointer
,	O
comment	pointer
)	O
;	O
return	O
node	pointer
;	O
}	O
SGFNode	struct
*	O
sgfBoardText	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
i	int
,	O
int	O
j	int
,	O
const	O
char	O
*	O
text	pointer
)	O
{	O
void	O
*	O
str	pointer
=	O
xalloc	function
(	O
strlen	function
(	O
text	pointer
)	O
+	O
3	int
)	O
;	O
sprintf	function
(	O
str	pointer
,	O
"%c%c:%s"	pointer
,	O
j	int
+	O
'a'	O
,	O
i	int
+	O
'a'	O
,	O
text	pointer
)	O
;	O
sgfAddProperty	function
(	O
node	pointer
,	O
"LB"	pointer
,	O
str	pointer
)	O
;	O
free	function
(	O
str	pointer
)	O
;	O
return	O
node	pointer
;	O
}	O
SGFNode	struct
*	O
sgfBoardChar	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
i	int
,	O
int	O
j	int
,	O
char	O
c	char
)	O
{	O
char	O
text	pointer
[	O
2	int
]	O
=	O
""	pointer
;	O
text	pointer
[	O
0	int
]	O
=	O
c	char
;	O
text	pointer
[	O
1	int
]	O
=	O
0	int
;	O
return	O
sgfBoardText	function
(	O
node	pointer
,	O
i	int
,	O
j	int
,	O
text	pointer
)	O
;	O
}	O
SGFNode	struct
*	O
sgfBoardNumber	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
i	int
,	O
int	O
j	int
,	O
int	O
number	int
)	O
{	O
char	O
text	pointer
[	O
10	int
]	O
;	O
gg_snprintf	function
(	O
text	pointer
,	O
10	int
,	O
"%c%c:%i"	pointer
,	O
j	int
+	O
'a'	O
,	O
i	int
+	O
'a'	O
,	O
number	int
)	O
;	O
sgfAddProperty	function
(	O
node	pointer
,	O
"LB"	pointer
,	O
text	pointer
)	O
;	O
return	O
node	pointer
;	O
}	O
SGFNode	struct
*	O
sgfTriangle	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
i	int
,	O
int	O
j	int
)	O
{	O
char	O
text	pointer
[	O
3	int
]	O
;	O
gg_snprintf	function
(	O
text	pointer
,	O
3	int
,	O
"%c%c"	pointer
,	O
j	int
+	O
'a'	O
,	O
i	int
+	O
'a'	O
)	O
;	O
sgfAddProperty	function
(	O
node	pointer
,	O
"TR"	pointer
,	O
text	pointer
)	O
;	O
return	O
node	pointer
;	O
}	O
SGFNode	struct
*	O
sgfLabel	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
label	pointer
,	O
int	O
i	int
,	O
int	O
j	int
)	O
{	O
char	O
text	pointer
[	O
16	int
]	O
;	O
gg_snprintf	function
(	O
text	pointer
,	O
16	int
,	O
"%c%c:%s"	pointer
,	O
j	int
+	O
'a'	O
,	O
i	int
+	O
'a'	O
,	O
label	pointer
)	O
;	O
sgfAddProperty	function
(	O
node	pointer
,	O
"LB"	pointer
,	O
text	pointer
)	O
;	O
return	O
node	pointer
;	O
}	O
SGFNode	struct
*	O
sgfLabelInt	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
num	int
,	O
int	O
i	int
,	O
int	O
j	int
)	O
{	O
char	O
text	pointer
[	O
16	int
]	O
;	O
gg_snprintf	function
(	O
text	pointer
,	O
16	int
,	O
"%c%c:%d"	pointer
,	O
j	int
+	O
'a'	O
,	O
i	int
+	O
'a'	O
,	O
num	int
)	O
;	O
sgfAddProperty	function
(	O
node	pointer
,	O
"LB"	pointer
,	O
text	pointer
)	O
;	O
return	O
node	pointer
;	O
}	O
SGFNode	struct
*	O
sgfCircle	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
i	int
,	O
int	O
j	int
)	O
{	O
char	O
text	pointer
[	O
3	int
]	O
;	O
gg_snprintf	function
(	O
text	pointer
,	O
3	int
,	O
"%c%c"	pointer
,	O
j	int
+	O
'a'	O
,	O
i	int
+	O
'a'	O
)	O
;	O
sgfAddProperty	function
(	O
node	pointer
,	O
"CR"	pointer
,	O
text	pointer
)	O
;	O
return	O
node	pointer
;	O
}	O
SGFNode	struct
*	O
sgfSquare	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
i	int
,	O
int	O
j	int
)	O
{	O
return	O
sgfMark	function
(	O
node	pointer
,	O
i	int
,	O
j	int
)	O
;	O
}	O
SGFNode	struct
*	O
sgfMark	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
i	int
,	O
int	O
j	int
)	O
{	O
char	O
text	pointer
[	O
3	int
]	O
;	O
gg_snprintf	function
(	O
text	pointer
,	O
3	int
,	O
"%c%c"	pointer
,	O
j	int
+	O
'a'	O
,	O
i	int
+	O
'a'	O
)	O
;	O
sgfAddProperty	function
(	O
node	pointer
,	O
"MA"	pointer
,	O
text	pointer
)	O
;	O
return	O
node	pointer
;	O
}	O
SGFNode	struct
*	O
sgfStartVariant	function
(	O
SGFNode	struct
*	O
node	pointer
)	O
{	O
assert	O
(	O
node	pointer
)	O
;	O
assert	O
(	O
node	pointer
->	O
parent	pointer
)	O
;	O
while	O
(	O
node	pointer
->	O
next	pointer
)	O
node	pointer
=	O
node	pointer
->	O
next	pointer
;	O
node	pointer
->	O
next	pointer
=	O
sgfNewNode	function
(	O
)	O
;	O
node	pointer
->	O
next	pointer
->	O
parent	pointer
=	O
node	pointer
->	O
parent	pointer
;	O
return	O
node	pointer
->	O
next	pointer
;	O
}	O
SGFNode	struct
*	O
sgfStartVariantFirst	function
(	O
SGFNode	struct
*	O
node	pointer
)	O
{	O
SGFNode	struct
*	O
old_first_child	pointer
=	O
node	pointer
;	O
SGFNode	struct
*	O
new_first_child	pointer
=	O
sgfNewNode	function
(	O
)	O
;	O
assert	O
(	O
node	pointer
)	O
;	O
assert	O
(	O
node	pointer
->	O
parent	pointer
)	O
;	O
new_first_child	pointer
->	O
next	pointer
=	O
old_first_child	pointer
;	O
new_first_child	pointer
->	O
parent	pointer
=	O
old_first_child	pointer
->	O
parent	pointer
;	O
new_first_child	pointer
->	O
parent	pointer
->	O
child	pointer
=	O
new_first_child	pointer
;	O
return	O
new_first_child	pointer
;	O
}	O
SGFNode	struct
*	O
sgfAddChild	function
(	O
SGFNode	struct
*	O
node	pointer
)	O
{	O
SGFNode	struct
*	O
new_node	pointer
=	O
sgfNewNode	function
(	O
)	O
;	O
assert	O
(	O
node	pointer
)	O
;	O
new_node	pointer
->	O
parent	pointer
=	O
node	pointer
;	O
if	O
(	O
!	O
node	pointer
->	O
child	pointer
)	O
node	pointer
->	O
child	pointer
=	O
new_node	pointer
;	O
else	O
{	O
node	pointer
=	O
node	pointer
->	O
child	pointer
;	O
while	O
(	O
node	pointer
->	O
next	pointer
)	O
node	pointer
=	O
node	pointer
->	O
next	pointer
;	O
node	pointer
->	O
next	pointer
=	O
new_node	pointer
;	O
}	O
return	O
new_node	pointer
;	O
}	O
void	O
sgfWriteResult	function
(	O
SGFNode	struct
*	O
node	pointer
,	O
float	O
score	float
,	O
int	O
overwrite	int
)	O
{	O
char	O
text	pointer
[	O
8	int
]	O
;	O
char	O
winner	char
;	O
float	O
s	float
;	O
int	O
dummy	int
;	O
if	O
(	O
!	O
node	pointer
)	O
return	O
;	O
if	O
(	O
!	O
overwrite	int
)	O
if	O
(	O
sgfGetIntProperty	function
(	O
node	pointer
,	O
"RE"	pointer
,	O
&	O
dummy	int
)	O
)	O
return	O
;	O
if	O
(	O
score	float
>	O
0.0	int
)	O
{	O
winner	char
=	O
'W'	O
;	O
s	float
=	O
score	float
;	O
}	O
else	O
if	O
(	O
score	float
<	O
0.0	int
)	O
{	O
winner	char
=	O
'B'	O
;	O
s	float
=	O
-	O
score	float
;	O
}	O
else	O
{	O
winner	char
=	O
'0'	O
;	O
s	float
=	O
0	int
;	O
}	O
if	O
(	O
winner	char
==	O
'0'	O
)	O
gg_snprintf	function
(	O
text	pointer
,	O
8	int
,	O
"0"	pointer
)	O
;	O
else	O
if	O
(	O
score	float
<	O
1000.0	int
&&	O
score	float
>	O
-	O
1000.0	int
)	O
gg_snprintf	function
(	O
text	pointer
,	O
8	int
,	O
"%c+%3.1f"	pointer
,	O
winner	char
,	O
s	float
)	O
;	O
else	O
gg_snprintf	function
(	O
text	pointer
,	O
8	int
,	O
"%c+%c"	pointer
,	O
winner	char
,	O
'R'	O
)	O
;	O
sgfOverwriteProperty	function
(	O
node	pointer
,	O
"RE"	pointer
,	O
text	pointer
)	O
;	O
}	O
static	O
void	O
sgf_write_header_reduced	function
(	O
SGFNode	struct
*	O
root	pointer
,	O
int	O
overwrite	int
)	O
{	O
time_t	long
curtime	long
=	O
time	function
(	O
NULL	O
)	O
;	O
struct	O
tm	struct
*	O
loctime	pointer
=	O
localtime	function
(	O
&	O
curtime	long
)	O
;	O
char	O
str	pointer
[	O
128	int
]	O
;	O
int	O
dummy	int
;	O
gg_snprintf	function
(	O
str	pointer
,	O
128	int
,	O
"%4.4i-%2.2i-%2.2i"	pointer
,	O
loctime	pointer
->	O
tm_year	int
+	O
1900	int
,	O
loctime	pointer
->	O
tm_mon	int
+	O
1	int
,	O
loctime	pointer
->	O
tm_mday	int
)	O
;	O
if	O
(	O
overwrite	int
||	O
!	O
sgfGetIntProperty	function
(	O
root	pointer
,	O
"DT"	pointer
,	O
&	O
dummy	int
)	O
)	O
sgfOverwriteProperty	function
(	O
root	pointer
,	O
"DT"	pointer
,	O
str	pointer
)	O
;	O
if	O
(	O
overwrite	int
||	O
!	O
sgfGetIntProperty	function
(	O
root	pointer
,	O
"AP"	pointer
,	O
&	O
dummy	int
)	O
)	O
sgfOverwriteProperty	function
(	O
root	pointer
,	O
"AP"	pointer
,	O
"GNU Go:"	pointer
VERSION	pointer
)	O
;	O
sgfOverwriteProperty	function
(	O
root	pointer
,	O
"FF"	pointer
,	O
"4"	pointer
)	O
;	O
}	O
void	O
sgf_write_header	function
(	O
SGFNode	struct
*	O
root	pointer
,	O
int	O
overwrite	int
,	O
int	O
seed	int
,	O
float	O
komi	float
,	O
int	O
handicap	int
,	O
int	O
level	int
,	O
int	O
rules	int
)	O
{	O
char	O
str	pointer
[	O
128	int
]	O
;	O
int	O
dummy	int
;	O
gg_snprintf	function
(	O
str	pointer
,	O
128	int
,	O
"GNU Go %s Random Seed %d level %d"	pointer
,	O
VERSION	pointer
,	O
seed	int
,	O
level	int
)	O
;	O
if	O
(	O
overwrite	int
||	O
!	O
sgfGetIntProperty	function
(	O
root	pointer
,	O
"GN"	pointer
,	O
&	O
dummy	int
)	O
)	O
sgfOverwriteProperty	function
(	O
root	pointer
,	O
"GN"	pointer
,	O
str	pointer
)	O
;	O
if	O
(	O
overwrite	int
||	O
!	O
sgfGetIntProperty	function
(	O
root	pointer
,	O
"RU"	pointer
,	O
&	O
dummy	int
)	O
)	O
sgfOverwriteProperty	function
(	O
root	pointer
,	O
"RU"	pointer
,	O
rules	int
?	O
"Chinese"	pointer
:	O
"Japanese"	pointer
)	O
;	O
sgfOverwritePropertyFloat	function
(	O
root	pointer
,	O
"KM"	pointer
,	O
komi	float
)	O
;	O
sgfOverwritePropertyInt	function
(	O
root	pointer
,	O
"HA"	pointer
,	O
handicap	int
)	O
;	O
sgf_write_header_reduced	function
(	O
root	pointer
,	O
overwrite	int
)	O
;	O
}	O
static	O
void	O
parse_error	function
(	O
const	O
char	O
*	O
msg	pointer
,	O
int	O
arg	int
)	O
;	O
static	O
void	O
nexttoken	function
(	O
void	O
)	O
;	O
static	O
void	O
match	function
(	O
int	O
expected	int
)	O
;	O
static	O
FILE	struct
*	O
sgffile	pointer
;	O
static	O
char	O
*	O
sgferr	pointer
;	O
static	O
int	O
sgferrpos	int
;	O
static	O
int	O
lookahead	int
;	O
static	O
void	O
parse_error	function
(	O
const	O
char	O
*	O
msg	pointer
,	O
int	O
arg	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
msg	pointer
,	O
arg	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
void	O
nexttoken	function
(	O
)	O
{	O
do	O
lookahead	int
=	O
sgf_getch	O
(	O
)	O
;	O
while	O
(	O
isspace	function
(	O
lookahead	int
)	O
)	O
;	O
}	O
static	O
void	O
match	function
(	O
int	O
expected	int
)	O
{	O
if	O
(	O
lookahead	int
!=	O
expected	int
)	O
parse_error	function
(	O
"expected: %c"	pointer
,	O
expected	int
)	O
;	O
else	O
nexttoken	function
(	O
)	O
;	O
}	O
static	O
void	O
propident	function
(	O
char	O
*	O
buffer	array
,	O
int	O
size	int
)	O
{	O
if	O
(	O
lookahead	int
==	O
EOF	O
||	O
!	O
isupper	function
(	O
lookahead	int
)	O
)	O
parse_error	function
(	O
"Expected an upper case letter."	pointer
,	O
0	int
)	O
;	O
while	O
(	O
lookahead	int
!=	O
EOF	O
&&	O
isalpha	function
(	O
lookahead	int
)	O
)	O
{	O
if	O
(	O
isupper	function
(	O
lookahead	int
)	O
&&	O
size	int
>	O
1	int
)	O
{	O
*	O
buffer	array
++	O
=	O
lookahead	int
;	O
size	int
--	O
;	O
}	O
nexttoken	function
(	O
)	O
;	O
}	O
*	O
buffer	array
=	O
'\0'	O
;	O
}	O
static	O
void	O
propvalue	function
(	O
char	O
*	O
buffer	array
,	O
int	O
size	int
)	O
{	O
char	O
*	O
p	pointer
=	O
buffer	array
;	O
match	function
(	O
'['	O
)	O
;	O
while	O
(	O
lookahead	int
!=	O
']'	O
&&	O
lookahead	int
!=	O
EOF	O
)	O
{	O
if	O
(	O
lookahead	int
==	O
'\\'	O
)	O
{	O
lookahead	int
=	O
sgf_getch	O
(	O
)	O
;	O
if	O
(	O
lookahead	int
==	O
'\r'	O
)	O
{	O
lookahead	int
=	O
sgf_getch	O
(	O
)	O
;	O
if	O
(	O
lookahead	int
==	O
'\n'	O
)	O
lookahead	int
=	O
sgf_getch	O
(	O
)	O
;	O
}	O
else	O
if	O
(	O
lookahead	int
==	O
'\n'	O
)	O
{	O
lookahead	int
=	O
sgf_getch	O
(	O
)	O
;	O
if	O
(	O
lookahead	int
==	O
'\r'	O
)	O
lookahead	int
=	O
sgf_getch	O
(	O
)	O
;	O
}	O
}	O
if	O
(	O
size	int
>	O
1	int
)	O
{	O
*	O
p	pointer
++	O
=	O
lookahead	int
;	O
size	int
--	O
;	O
}	O
lookahead	int
=	O
sgf_getch	O
(	O
)	O
;	O
}	O
match	function
(	O
']'	O
)	O
;	O
--	O
p	pointer
;	O
while	O
(	O
p	pointer
>	O
buffer	array
&&	O
isspace	function
(	O
(	O
int	O
)	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
)	O
--	O
p	pointer
;	O
*	O
++	O
p	pointer
=	O
'\0'	O
;	O
}	O
static	O
SGFProperty	struct
*	O
property	pointer
(	O
SGFNode	struct
*	O
n	pointer
,	O
SGFProperty	struct
*	O
last	pointer
)	O
{	O
char	O
name	short
[	O
3	int
]	O
;	O
char	O
buffer	array
[	O
4000	int
]	O
;	O
propident	function
(	O
name	short
,	O
sizeof	O
(	O
name	short
)	O
)	O
;	O
do	O
{	O
propvalue	function
(	O
buffer	array
,	O
sizeof	O
(	O
buffer	array
)	O
)	O
;	O
last	pointer
=	O
sgfMkProperty	function
(	O
name	short
,	O
buffer	array
,	O
n	pointer
,	O
last	pointer
)	O
;	O
}	O
while	O
(	O
lookahead	int
==	O
'['	O
)	O
;	O
return	O
last	pointer
;	O
}	O
static	O
void	O
node	pointer
(	O
SGFNode	struct
*	O
n	pointer
)	O
{	O
SGFProperty	struct
*	O
last	pointer
=	O
NULL	O
;	O
match	function
(	O
';'	O
)	O
;	O
while	O
(	O
lookahead	int
!=	O
EOF	O
&&	O
isupper	function
(	O
lookahead	int
)	O
)	O
last	pointer
=	O
property	pointer
(	O
n	pointer
,	O
last	pointer
)	O
;	O
}	O
static	O
SGFNode	struct
*	O
sequence	function
(	O
SGFNode	struct
*	O
n	pointer
)	O
{	O
node	pointer
(	O
n	pointer
)	O
;	O
while	O
(	O
lookahead	int
==	O
';'	O
)	O
{	O
SGFNode	struct
*	O
new	pointer
=	O
sgfNewNode	function
(	O
)	O
;	O
new	pointer
->	O
parent	pointer
=	O
n	pointer
;	O
n	pointer
->	O
child	pointer
=	O
new	pointer
;	O
n	pointer
=	O
new	pointer
;	O
node	pointer
(	O
n	pointer
)	O
;	O
}	O
return	O
n	pointer
;	O
}	O
static	O
void	O
gametree	function
(	O
SGFNode	struct
*	O
*	O
p	pointer
,	O
SGFNode	struct
*	O
parent	pointer
,	O
int	O
mode	int
)	O
{	O
if	O
(	O
mode	int
==	O
STRICT_SGF	char
)	O
match	function
(	O
'('	O
)	O
;	O
else	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
lookahead	int
==	O
EOF	O
)	O
{	O
parse_error	function
(	O
"Empty file?"	pointer
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
lookahead	int
==	O
'('	O
)	O
{	O
while	O
(	O
lookahead	int
==	O
'('	O
)	O
nexttoken	function
(	O
)	O
;	O
if	O
(	O
lookahead	int
==	O
';'	O
)	O
break	O
;	O
}	O
nexttoken	function
(	O
)	O
;	O
}	O
{	O
SGFNode	struct
*	O
head	pointer
=	O
sgfNewNode	function
(	O
)	O
;	O
SGFNode	struct
*	O
last	pointer
;	O
head	pointer
->	O
parent	pointer
=	O
parent	pointer
;	O
*	O
p	pointer
=	O
head	pointer
;	O
last	pointer
=	O
sequence	function
(	O
head	pointer
)	O
;	O
p	pointer
=	O
&	O
last	pointer
->	O
child	pointer
;	O
while	O
(	O
lookahead	int
==	O
'('	O
)	O
{	O
gametree	function
(	O
p	pointer
,	O
last	pointer
,	O
STRICT_SGF	char
)	O
;	O
p	pointer
=	O
&	O
(	O
(	O
*	O
p	pointer
)	O
->	O
next	pointer
)	O
;	O
}	O
if	O
(	O
mode	int
==	O
STRICT_SGF	char
)	O
match	function
(	O
')'	O
)	O
;	O
}	O
}	O
static	O
void	O
gametreefuseki	function
(	O
SGFNode	struct
*	O
*	O
p	pointer
,	O
SGFNode	struct
*	O
parent	pointer
,	O
int	O
mode	int
,	O
int	O
moves_per_game	int
,	O
int	O
i	int
)	O
{	O
if	O
(	O
mode	int
==	O
STRICT_SGF	char
)	O
match	function
(	O
'('	O
)	O
;	O
else	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
lookahead	int
==	O
EOF	O
)	O
{	O
parse_error	function
(	O
"Empty file?"	pointer
,	O
0	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
lookahead	int
==	O
'('	O
)	O
{	O
while	O
(	O
lookahead	int
==	O
'('	O
)	O
nexttoken	function
(	O
)	O
;	O
if	O
(	O
lookahead	int
==	O
';'	O
)	O
break	O
;	O
}	O
nexttoken	function
(	O
)	O
;	O
}	O
{	O
SGFNode	struct
*	O
head	pointer
=	O
sgfNewNode	function
(	O
)	O
;	O
SGFNode	struct
*	O
last	pointer
;	O
head	pointer
->	O
parent	pointer
=	O
parent	pointer
;	O
*	O
p	pointer
=	O
head	pointer
;	O
last	pointer
=	O
sequence	function
(	O
head	pointer
)	O
;	O
p	pointer
=	O
&	O
last	pointer
->	O
child	pointer
;	O
while	O
(	O
lookahead	int
==	O
'('	O
)	O
{	O
if	O
(	O
last	pointer
->	O
props	pointer
&&	O
(	O
last	pointer
->	O
props	pointer
->	O
name	short
==	O
SGFB	int
||	O
last	pointer
->	O
props	pointer
->	O
name	short
==	O
SGFW	int
)	O
)	O
i	int
++	O
;	O
if	O
(	O
i	int
>=	O
moves_per_game	int
)	O
{	O
last	pointer
->	O
child	pointer
=	O
NULL	O
;	O
last	pointer
->	O
next	pointer
=	O
NULL	O
;	O
break	O
;	O
}	O
else	O
{	O
gametreefuseki	function
(	O
p	pointer
,	O
last	pointer
,	O
mode	int
,	O
moves_per_game	int
,	O
i	int
)	O
;	O
p	pointer
=	O
&	O
(	O
(	O
*	O
p	pointer
)	O
->	O
next	pointer
)	O
;	O
}	O
}	O
if	O
(	O
mode	int
==	O
STRICT_SGF	char
)	O
match	function
(	O
')'	O
)	O
;	O
}	O
}	O
SGFNode	struct
*	O
readsgffilefuseki	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
int	O
moves_per_game	int
)	O
{	O
SGFNode	struct
*	O
root	pointer
;	O
int	O
tmpi	int
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
filename	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
sgffile	pointer
=	O
stdin	pointer
;	O
else	O
sgffile	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
sgffile	pointer
)	O
return	O
NULL	O
;	O
nexttoken	function
(	O
)	O
;	O
gametreefuseki	function
(	O
&	O
root	pointer
,	O
NULL	O
,	O
LAX_SGF	char
,	O
moves_per_game	int
,	O
0	int
)	O
;	O
fclose	function
(	O
sgffile	pointer
)	O
;	O
if	O
(	O
sgferr	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Parse error: %s at position %d\n"	pointer
,	O
sgferr	pointer
,	O
sgferrpos	int
)	O
;	O
sgfFreeNode	function
(	O
root	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
sgfGetIntProperty	function
(	O
root	pointer
,	O
"GM"	pointer
,	O
&	O
tmpi	int
)	O
)	O
{	O
if	O
(	O
VERBOSE_WARNINGS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Couldn't find the game type (GM) attribute!\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
tmpi	int
!=	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"SGF file might be for game other than go: %d\n"	pointer
,	O
tmpi	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Trying to load anyway.\n"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
sgfGetIntProperty	function
(	O
root	pointer
,	O
"FF"	pointer
,	O
&	O
tmpi	int
)	O
)	O
{	O
if	O
(	O
VERBOSE_WARNINGS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Can not determine SGF spec version (FF)!\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
tmpi	int
<	O
3	int
||	O
tmpi	int
>	O
4	int
)	O
&&	O
VERBOSE_WARNINGS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Unsupported SGF spec version: %d\n"	pointer
,	O
tmpi	int
)	O
;	O
return	O
root	pointer
;	O
}	O
SGFNode	struct
*	O
readsgffile	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
SGFNode	struct
*	O
root	pointer
;	O
int	O
tmpi	int
=	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
filename	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
sgffile	pointer
=	O
stdin	pointer
;	O
else	O
sgffile	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
sgffile	pointer
)	O
return	O
NULL	O
;	O
nexttoken	function
(	O
)	O
;	O
gametree	function
(	O
&	O
root	pointer
,	O
NULL	O
,	O
LAX_SGF	char
)	O
;	O
if	O
(	O
sgffile	pointer
!=	O
stdin	pointer
)	O
fclose	function
(	O
sgffile	pointer
)	O
;	O
if	O
(	O
sgferr	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Parse error: %s at position %d\n"	pointer
,	O
sgferr	pointer
,	O
sgferrpos	int
)	O
;	O
sgfFreeNode	function
(	O
root	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
sgfGetIntProperty	function
(	O
root	pointer
,	O
"GM"	pointer
,	O
&	O
tmpi	int
)	O
)	O
{	O
if	O
(	O
VERBOSE_WARNINGS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Couldn't find the game type (GM) attribute!\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
tmpi	int
!=	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"SGF file might be for game other than go: %d\n"	pointer
,	O
tmpi	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Trying to load anyway.\n"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
sgfGetIntProperty	function
(	O
root	pointer
,	O
"FF"	pointer
,	O
&	O
tmpi	int
)	O
)	O
{	O
if	O
(	O
VERBOSE_WARNINGS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Can not determine SGF spec version (FF)!\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
tmpi	int
<	O
3	int
||	O
tmpi	int
>	O
4	int
)	O
&&	O
VERBOSE_WARNINGS	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Unsupported SGF spec version: %d\n"	pointer
,	O
tmpi	int
)	O
;	O
return	O
root	pointer
;	O
}	O
static	O
int	O
sgf_column	int
=	O
0	int
;	O
static	O
void	O
sgf_putc	function
(	O
int	O
c	char
,	O
FILE	struct
*	O
file	pointer
)	O
{	O
if	O
(	O
c	char
==	O
'\n'	O
&&	O
sgf_column	int
==	O
0	int
)	O
return	O
;	O
fputc	function
(	O
c	char
,	O
file	pointer
)	O
;	O
if	O
(	O
c	char
==	O
'\n'	O
)	O
sgf_column	int
=	O
0	int
;	O
else	O
sgf_column	int
++	O
;	O
if	O
(	O
c	char
==	O
']'	O
&&	O
sgf_column	int
>	O
60	int
)	O
{	O
fputc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
sgf_column	int
=	O
0	int
;	O
}	O
}	O
static	O
void	O
sgf_puts	function
(	O
const	O
char	O
*	O
s	float
,	O
FILE	struct
*	O
file	pointer
)	O
{	O
for	O
(	O
;	O
*	O
s	float
;	O
s	float
++	O
)	O
{	O
if	O
(	O
*	O
s	float
==	O
'['	O
||	O
*	O
s	float
==	O
']'	O
||	O
*	O
s	float
==	O
'\\'	O
)	O
{	O
fputc	function
(	O
'\\'	O
,	O
file	pointer
)	O
;	O
sgf_column	int
++	O
;	O
}	O
fputc	function
(	O
(	O
int	O
)	O
*	O
s	float
,	O
file	pointer
)	O
;	O
sgf_column	int
++	O
;	O
}	O
}	O
static	O
void	O
sgf_print_name	function
(	O
FILE	struct
*	O
file	pointer
,	O
short	O
name	short
)	O
{	O
sgf_putc	function
(	O
name	short
&	O
0xff	int
,	O
file	pointer
)	O
;	O
if	O
(	O
name	short
>>	O
8	int
!=	O
' '	O
)	O
sgf_putc	function
(	O
name	short
>>	O
8	int
,	O
file	pointer
)	O
;	O
}	O
static	O
void	O
sgf_print_property	function
(	O
FILE	struct
*	O
file	pointer
,	O
SGFNode	struct
*	O
node	pointer
,	O
short	O
name	short
,	O
int	O
is_comment	int
)	O
{	O
int	O
n	pointer
=	O
0	int
;	O
SGFProperty	struct
*	O
prop	pointer
;	O
for	O
(	O
prop	pointer
=	O
node	pointer
->	O
props	pointer
;	O
prop	pointer
;	O
prop	pointer
=	O
prop	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
prop	pointer
->	O
name	short
==	O
name	short
)	O
{	O
prop	pointer
->	O
name	short
|=	O
0x20	int
;	O
if	O
(	O
n	pointer
==	O
0	int
)	O
{	O
sgf_print_name	function
(	O
file	pointer
,	O
name	short
)	O
;	O
sgf_putc	function
(	O
'['	O
,	O
file	pointer
)	O
;	O
}	O
else	O
if	O
(	O
is_comment	int
)	O
sgf_putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
else	O
{	O
sgf_putc	function
(	O
']'	O
,	O
file	pointer
)	O
;	O
sgf_putc	function
(	O
'['	O
,	O
file	pointer
)	O
;	O
}	O
sgf_puts	function
(	O
prop	pointer
->	O
value	pointer
,	O
file	pointer
)	O
;	O
n	pointer
++	O
;	O
}	O
}	O
if	O
(	O
n	pointer
>	O
0	int
)	O
sgf_putc	function
(	O
']'	O
,	O
file	pointer
)	O
;	O
if	O
(	O
name	short
==	O
SGFAB	int
||	O
name	short
==	O
SGFAW	int
||	O
name	short
==	O
SGFAE	int
||	O
(	O
is_comment	int
&&	O
n	pointer
>	O
1	int
)	O
)	O
sgf_putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
}	O
static	O
void	O
sgfPrintRemainingProperties	function
(	O
FILE	struct
*	O
file	pointer
,	O
SGFNode	struct
*	O
node	pointer
)	O
{	O
SGFProperty	struct
*	O
prop	pointer
;	O
for	O
(	O
prop	pointer
=	O
node	pointer
->	O
props	pointer
;	O
prop	pointer
;	O
prop	pointer
=	O
prop	pointer
->	O
next	pointer
)	O
if	O
(	O
!	O
(	O
prop	pointer
->	O
name	short
&	O
0x20	int
)	O
)	O
sgf_print_property	function
(	O
file	pointer
,	O
node	pointer
,	O
prop	pointer
->	O
name	short
,	O
0	int
)	O
;	O
}	O
static	O
void	O
sgfPrintCharProperty	function
(	O
FILE	struct
*	O
file	pointer
,	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
)	O
{	O
short	O
nam	short
=	O
name	short
[	O
0	int
]	O
|	O
name	short
[	O
1	int
]	O
<<	O
8	int
;	O
sgf_print_property	function
(	O
file	pointer
,	O
node	pointer
,	O
nam	short
,	O
0	int
)	O
;	O
}	O
static	O
void	O
sgfPrintCommentProperty	function
(	O
FILE	struct
*	O
file	pointer
,	O
SGFNode	struct
*	O
node	pointer
,	O
const	O
char	O
*	O
name	short
)	O
{	O
short	O
nam	short
=	O
name	short
[	O
0	int
]	O
|	O
name	short
[	O
1	int
]	O
<<	O
8	int
;	O
sgf_print_property	function
(	O
file	pointer
,	O
node	pointer
,	O
nam	short
,	O
1	int
)	O
;	O
}	O
static	O
void	O
unparse_node	function
(	O
FILE	struct
*	O
file	pointer
,	O
SGFNode	struct
*	O
node	pointer
)	O
{	O
sgf_putc	function
(	O
';'	O
,	O
file	pointer
)	O
;	O
sgfPrintCharProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"B "	pointer
)	O
;	O
sgfPrintCharProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"W "	pointer
)	O
;	O
sgfPrintCommentProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"N "	pointer
)	O
;	O
sgfPrintCommentProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"C "	pointer
)	O
;	O
sgfPrintRemainingProperties	function
(	O
file	pointer
,	O
node	pointer
)	O
;	O
}	O
static	O
void	O
unparse_root	function
(	O
FILE	struct
*	O
file	pointer
,	O
SGFNode	struct
*	O
node	pointer
)	O
{	O
sgf_putc	function
(	O
';'	O
,	O
file	pointer
)	O
;	O
if	O
(	O
sgfHasProperty	function
(	O
node	pointer
,	O
"GM"	pointer
)	O
)	O
sgfPrintCharProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"GM"	pointer
)	O
;	O
else	O
{	O
fputs	function
(	O
"GM[1]"	pointer
,	O
file	pointer
)	O
;	O
sgf_column	int
+=	O
5	int
;	O
}	O
sgfPrintCharProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"FF"	pointer
)	O
;	O
sgf_putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
sgfPrintCharProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"SZ"	pointer
)	O
;	O
sgf_putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
sgfPrintCharProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"GN"	pointer
)	O
;	O
sgf_putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
sgfPrintCharProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"DT"	pointer
)	O
;	O
sgf_putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
sgfPrintCommentProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"PB"	pointer
)	O
;	O
sgfPrintCommentProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"BR"	pointer
)	O
;	O
sgf_putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
sgfPrintCommentProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"PW"	pointer
)	O
;	O
sgfPrintCommentProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"WR"	pointer
)	O
;	O
sgf_putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
sgfPrintCommentProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"N "	pointer
)	O
;	O
sgfPrintCommentProperty	function
(	O
file	pointer
,	O
node	pointer
,	O
"C "	pointer
)	O
;	O
sgfPrintRemainingProperties	function
(	O
file	pointer
,	O
node	pointer
)	O
;	O
sgf_putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
}	O
static	O
void	O
unparse_game	function
(	O
FILE	struct
*	O
file	pointer
,	O
SGFNode	struct
*	O
node	pointer
,	O
int	O
root	pointer
)	O
{	O
if	O
(	O
!	O
root	pointer
)	O
sgf_putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
sgf_putc	function
(	O
'('	O
,	O
file	pointer
)	O
;	O
if	O
(	O
root	pointer
)	O
unparse_root	function
(	O
file	pointer
,	O
node	pointer
)	O
;	O
else	O
unparse_node	function
(	O
file	pointer
,	O
node	pointer
)	O
;	O
node	pointer
=	O
node	pointer
->	O
child	pointer
;	O
while	O
(	O
node	pointer
!=	O
NULL	O
&&	O
node	pointer
->	O
next	pointer
==	O
NULL	O
)	O
{	O
unparse_node	function
(	O
file	pointer
,	O
node	pointer
)	O
;	O
node	pointer
=	O
node	pointer
->	O
child	pointer
;	O
}	O
while	O
(	O
node	pointer
!=	O
NULL	O
)	O
{	O
unparse_game	function
(	O
file	pointer
,	O
node	pointer
,	O
0	int
)	O
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
;	O
}	O
sgf_putc	function
(	O
')'	O
,	O
file	pointer
)	O
;	O
if	O
(	O
root	pointer
)	O
sgf_putc	function
(	O
'\n'	O
,	O
file	pointer
)	O
;	O
}	O
static	O
void	O
restore_property	function
(	O
SGFProperty	struct
*	O
prop	pointer
)	O
{	O
if	O
(	O
prop	pointer
)	O
{	O
restore_property	function
(	O
prop	pointer
->	O
next	pointer
)	O
;	O
prop	pointer
->	O
name	short
&=	O
~	O
0x20	int
;	O
}	O
}	O
static	O
void	O
restore_node	function
(	O
SGFNode	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
node	pointer
)	O
{	O
restore_property	function
(	O
node	pointer
->	O
props	pointer
)	O
;	O
restore_node	function
(	O
node	pointer
->	O
child	pointer
)	O
;	O
restore_node	function
(	O
node	pointer
->	O
next	pointer
)	O
;	O
}	O
}	O
int	O
writesgf	function
(	O
SGFNode	struct
*	O
root	pointer
,	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
FILE	struct
*	O
outfile	pointer
;	O
if	O
(	O
strcmp	function
(	O
filename	pointer
,	O
"-"	pointer
)	O
==	O
0	int
)	O
outfile	pointer
=	O
stdout	pointer
;	O
else	O
outfile	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
!	O
outfile	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Can not open %s\n"	pointer
,	O
filename	pointer
)	O
;	O
return	O
0	int
;	O
}	O
sgf_write_header_reduced	function
(	O
root	pointer
,	O
0	int
)	O
;	O
sgf_column	int
=	O
0	int
;	O
unparse_game	function
(	O
outfile	pointer
,	O
root	pointer
,	O
1	int
)	O
;	O
if	O
(	O
outfile	pointer
!=	O
stdout	pointer
)	O
fclose	function
(	O
outfile	pointer
)	O
;	O
restore_node	function
(	O
root	pointer
)	O
;	O
return	O
1	int
;	O
}	O
