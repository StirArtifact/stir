static	O
struct	O
timeval	struct
currenttime	struct
;	O
static	O
struct	O
timezone	struct
tzp	struct
;	O
static	O
int	O
registered	int
=	O
0	int
,	O
reghandler	int
=	O
0	int
;	O
static	O
tl_group	struct
group1	struct
,	O
group2	struct
;	O
tl_group	struct
*	O
syncgroup	pointer
=	O
&	O
group1	struct
,	O
*	O
asyncgroup	pointer
=	O
&	O
group2	struct
;	O
void	O
tl_update_time	function
(	O
void	O
)	O
{	O
do	O
{	O
gettimeofday	function
(	O
&	O
currenttime	struct
,	O
&	O
tzp	struct
)	O
;	O
}	O
while	O
(	O
currenttime	struct
.	O
tv_usec	long
>	O
999999	int
)	O
;	O
}	O
static	O
INLINE	O
int	O
__lookup_timer	function
(	O
tl_timer	struct
*	O
t	pointer
)	O
{	O
return	O
(	O
(	O
1000000	int
*	O
(	O
-	O
t	pointer
->	O
lastactivated	struct
.	O
tv_sec	long
+	O
currenttime	struct
.	O
tv_sec	long
)	O
+	O
(	O
-	O
t	pointer
->	O
lastactivated	struct
.	O
tv_usec	long
+	O
currenttime	struct
.	O
tv_usec	long
)	O
)	O
)	O
;	O
}	O
int	O
tl_lookup_timer	function
(	O
tl_timer	struct
*	O
t	pointer
)	O
{	O
if	O
(	O
t	pointer
->	O
stopped	int
)	O
{	O
return	O
(	O
t	pointer
->	O
stoppedtime	int
)	O
;	O
}	O
return	O
(	O
__lookup_timer	function
(	O
t	pointer
)	O
-	O
t	pointer
->	O
slowdown	int
)	O
;	O
}	O
void	O
tl_stop_timer	function
(	O
tl_timer	struct
*	O
t	pointer
)	O
{	O
if	O
(	O
!	O
t	pointer
->	O
stopped	int
)	O
{	O
t	pointer
->	O
stoppedtime	int
=	O
tl_lookup_timer	function
(	O
t	pointer
)	O
;	O
t	pointer
->	O
stopped	int
=	O
1	int
;	O
}	O
}	O
void	O
tl_slowdown_timer	function
(	O
tl_timer	struct
*	O
t	pointer
,	O
int	O
time	int
)	O
{	O
if	O
(	O
!	O
t	pointer
->	O
stopped	int
)	O
{	O
t	pointer
->	O
slowdown	int
+=	O
time	int
;	O
}	O
else	O
t	pointer
->	O
stoppedtime	int
-=	O
time	int
;	O
}	O
void	O
tl_resume_timer	function
(	O
tl_timer	struct
*	O
t	pointer
)	O
{	O
if	O
(	O
t	pointer
->	O
stopped	int
)	O
{	O
t	pointer
->	O
stopped	int
=	O
0	int
;	O
t	pointer
->	O
slowdown	int
=	O
__lookup_timer	function
(	O
t	pointer
)	O
-	O
t	pointer
->	O
stoppedtime	int
;	O
}	O
}	O
void	O
tl_sleep	function
(	O
int	O
time	int
)	O
{	O
usleep	function
(	O
time	int
)	O
;	O
}	O
void	O
tl_reset_timer	function
(	O
tl_timer	struct
*	O
t	pointer
)	O
{	O
if	O
(	O
t	pointer
->	O
stopped	int
)	O
t	pointer
->	O
stoppedtime	int
=	O
0	int
;	O
else	O
t	pointer
->	O
lastactivated	struct
=	O
currenttime	struct
,	O
t	pointer
->	O
slowdown	int
=	O
0	int
;	O
}	O
tl_timer	struct
*	O
tl_create_timer	function
(	O
void	O
)	O
{	O
tl_timer	struct
*	O
timer	struct
;	O
timer	struct
=	O
(	O
tl_timer	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
tl_timer	struct
)	O
)	O
;	O
if	O
(	O
timer	struct
==	O
NULL	O
)	O
return	O
NULL	O
;	O
timer	struct
->	O
interval	int
=	O
-	O
1	int
;	O
timer	struct
->	O
handler	pointer
=	O
NULL	O
;	O
timer	struct
->	O
multihandler	pointer
=	O
NULL	O
;	O
timer	struct
->	O
userdata	pointer
=	O
NULL	O
;	O
timer	struct
->	O
next	pointer
=	O
NULL	O
;	O
timer	struct
->	O
previous	pointer
=	O
NULL	O
;	O
timer	struct
->	O
group	pointer
=	O
NULL	O
;	O
timer	struct
->	O
stopped	int
=	O
0	int
;	O
timer	struct
->	O
stoppedtime	int
=	O
0	int
;	O
timer	struct
->	O
slowdown	int
=	O
0	int
;	O
tl_reset_timer	function
(	O
timer	struct
)	O
;	O
return	O
(	O
timer	struct
)	O
;	O
}	O
tl_group	struct
*	O
tl_create_group	function
(	O
void	O
)	O
{	O
tl_group	struct
*	O
timer	struct
;	O
timer	struct
=	O
(	O
tl_group	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
tl_group	struct
)	O
)	O
;	O
if	O
(	O
timer	struct
==	O
NULL	O
)	O
return	O
NULL	O
;	O
timer	struct
->	O
interval	int
=	O
-	O
1	int
;	O
timer	struct
->	O
handler	pointer
=	O
NULL	O
;	O
timer	struct
->	O
multihandler	pointer
=	O
NULL	O
;	O
timer	struct
->	O
userdata	pointer
=	O
NULL	O
;	O
timer	struct
->	O
next	pointer
=	O
NULL	O
;	O
timer	struct
->	O
previous	pointer
=	O
NULL	O
;	O
timer	struct
->	O
group	pointer
=	O
timer	struct
;	O
tl_reset_timer	function
(	O
timer	struct
)	O
;	O
return	O
(	O
timer	struct
)	O
;	O
}	O
void	O
tl_free_timer	function
(	O
tl_timer	struct
*	O
timer	struct
)	O
{	O
if	O
(	O
timer	struct
->	O
group	pointer
)	O
tl_remove_timer	function
(	O
timer	struct
)	O
;	O
free	function
(	O
(	O
void	O
*	O
)	O
timer	struct
)	O
;	O
}	O
void	O
tl_free_group	function
(	O
tl_group	struct
*	O
timer	struct
)	O
{	O
tl_timer	struct
*	O
next	pointer
;	O
do	O
{	O
next	pointer
=	O
timer	struct
->	O
next	pointer
;	O
free	function
(	O
(	O
void	O
*	O
)	O
timer	struct
)	O
;	O
}	O
while	O
(	O
next	pointer
!=	O
NULL	O
)	O
;	O
}	O
int	O
tl_process_group	function
(	O
tl_group	struct
*	O
group	pointer
,	O
int	O
*	O
activated	pointer
)	O
{	O
int	O
again	int
=	O
1	int
;	O
tl_timer	struct
*	O
timer	struct
,	O
*	O
timer1	pointer
;	O
int	O
minwait	int
=	O
INT_MAX	O
;	O
tl_update_time	function
(	O
)	O
;	O
if	O
(	O
activated	pointer
!=	O
NULL	O
)	O
*	O
activated	pointer
=	O
0	int
;	O
while	O
(	O
again	int
)	O
{	O
again	int
=	O
0	int
;	O
minwait	int
=	O
INT_MAX	O
;	O
timer	struct
=	O
group	pointer
->	O
next	pointer
;	O
while	O
(	O
timer	struct
!=	O
NULL	O
)	O
{	O
timer1	pointer
=	O
timer	struct
->	O
next	pointer
;	O
if	O
(	O
timer	struct
->	O
handler	pointer
&&	O
timer	struct
->	O
interval	int
>=	O
0	int
)	O
{	O
int	O
time	int
=	O
timer	struct
->	O
interval	int
-	O
tl_lookup_timer	function
(	O
timer	struct
)	O
;	O
if	O
(	O
time	int
<	O
500	int
)	O
{	O
if	O
(	O
activated	pointer
!=	O
NULL	O
)	O
(	O
*	O
activated	pointer
)	O
++	O
;	O
again	int
=	O
1	int
;	O
tl_reset_timer	function
(	O
timer	struct
)	O
;	O
if	O
(	O
time	int
<	O
-	O
200	int
*	O
1000000	int
)	O
time	int
=	O
0	int
;	O
tl_slowdown_timer	function
(	O
timer	struct
,	O
time	int
)	O
;	O
time	int
=	O
timer	struct
->	O
interval	int
+	O
time	int
;	O
timer	struct
->	O
handler	pointer
(	O
timer	struct
->	O
userdata	pointer
)	O
;	O
tl_update_time	function
(	O
)	O
;	O
}	O
if	O
(	O
time	int
<	O
minwait	int
)	O
minwait	int
=	O
time	int
;	O
}	O
else	O
if	O
(	O
timer	struct
->	O
multihandler	pointer
&&	O
timer	struct
->	O
interval	int
>	O
0	int
)	O
{	O
int	O
time	int
=	O
timer	struct
->	O
interval	int
-	O
tl_lookup_timer	function
(	O
timer	struct
)	O
;	O
if	O
(	O
time	int
<	O
500	int
)	O
{	O
int	O
n	int
;	O
if	O
(	O
activated	pointer
!=	O
NULL	O
)	O
(	O
*	O
activated	pointer
)	O
++	O
;	O
tl_reset_timer	function
(	O
timer	struct
)	O
;	O
if	O
(	O
time	int
<	O
-	O
200	int
*	O
1000000	int
)	O
time	int
=	O
0	int
;	O
n	int
=	O
-	O
(	O
time	int
+	O
500	int
)	O
/	O
timer	struct
->	O
interval	int
+	O
1	int
;	O
time	int
=	O
timer	struct
->	O
interval	int
*	O
n	int
+	O
time	int
;	O
tl_slowdown_timer	function
(	O
timer	struct
,	O
time	int
-	O
timer	struct
->	O
interval	int
+	O
n	int
*	O
timer	struct
->	O
interval	int
)	O
;	O
timer	struct
->	O
multihandler	pointer
(	O
timer	struct
->	O
userdata	pointer
,	O
n	int
)	O
;	O
tl_update_time	function
(	O
)	O
;	O
}	O
if	O
(	O
time	int
<	O
minwait	int
)	O
minwait	int
=	O
time	int
;	O
}	O
timer	struct
=	O
timer1	pointer
;	O
}	O
}	O
if	O
(	O
minwait	int
!=	O
INT_MAX	O
)	O
{	O
if	O
(	O
minwait	int
<	O
0	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
minwait	int
)	O
;	O
}	O
return	O
(	O
-	O
1	int
)	O
;	O
}	O
static	O
void	O
update_async	function
(	O
void	O
)	O
;	O
static	O
void	O
alarmhandler	function
(	O
int	O
a	int
)	O
{	O
update_async	function
(	O
)	O
;	O
signal	function
(	O
SIGALRM	int
,	O
alarmhandler	function
)	O
;	O
}	O
static	O
void	O
update_async	function
(	O
)	O
{	O
int	O
time	int
=	O
tl_process_group	function
(	O
asyncgroup	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
time	int
!=	O
-	O
1	int
)	O
{	O
struct	O
itimerval	struct
t	pointer
;	O
t	pointer
.	O
it_interval	struct
.	O
tv_sec	long
=	O
0	int
;	O
t	pointer
.	O
it_interval	struct
.	O
tv_usec	long
=	O
0	int
;	O
t	pointer
.	O
it_value	struct
.	O
tv_sec	long
=	O
time	int
/	O
1000000	int
;	O
t	pointer
.	O
it_value	struct
.	O
tv_usec	long
=	O
time	int
%	O
1000000	int
;	O
if	O
(	O
!	O
reghandler	int
)	O
{	O
signal	function
(	O
SIGALRM	int
,	O
alarmhandler	function
)	O
,	O
reghandler	int
=	O
1	int
;	O
}	O
setitimer	function
(	O
ITIMER_REAL	int
,	O
&	O
t	pointer
,	O
&	O
t	pointer
)	O
;	O
registered	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
registered	int
)	O
{	O
struct	O
itimerval	struct
t	pointer
;	O
t	pointer
.	O
it_interval	struct
.	O
tv_sec	long
=	O
0	int
;	O
t	pointer
.	O
it_interval	struct
.	O
tv_usec	long
=	O
0	int
;	O
t	pointer
.	O
it_value	struct
.	O
tv_sec	long
=	O
0	int
;	O
t	pointer
.	O
it_value	struct
.	O
tv_usec	long
=	O
0	int
;	O
setitimer	function
(	O
ITIMER_REAL	int
,	O
&	O
t	pointer
,	O
&	O
t	pointer
)	O
;	O
registered	int
=	O
0	int
;	O
}	O
}	O
void	O
tl_add_timer	function
(	O
tl_group	struct
*	O
group	pointer
,	O
tl_timer	struct
*	O
timer	struct
)	O
{	O
if	O
(	O
timer	struct
->	O
group	pointer
)	O
tl_remove_timer	function
(	O
timer	struct
)	O
;	O
timer	struct
->	O
previous	pointer
=	O
group	pointer
;	O
timer	struct
->	O
next	pointer
=	O
group	pointer
->	O
next	pointer
;	O
timer	struct
->	O
group	pointer
=	O
group	pointer
;	O
group	pointer
->	O
next	pointer
=	O
timer	struct
;	O
if	O
(	O
timer	struct
->	O
group	pointer
==	O
asyncgroup	pointer
)	O
update_async	function
(	O
)	O
;	O
}	O
void	O
tl_set_interval	function
(	O
tl_timer	struct
*	O
timer	struct
,	O
int	O
interval	int
)	O
{	O
if	O
(	O
timer	struct
->	O
interval	int
<=	O
0	int
)	O
{	O
tl_reset_timer	function
(	O
timer	struct
)	O
;	O
}	O
timer	struct
->	O
interval	int
=	O
interval	int
;	O
if	O
(	O
timer	struct
->	O
group	pointer
==	O
asyncgroup	pointer
)	O
update_async	function
(	O
)	O
;	O
}	O
void	O
tl_set_handler	function
(	O
tl_timer	struct
*	O
timer	struct
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
void	O
*	O
)	O
,	O
void	O
*	O
ud	pointer
)	O
{	O
timer	struct
->	O
handler	pointer
=	O
handler	pointer
;	O
timer	struct
->	O
userdata	pointer
=	O
ud	pointer
;	O
if	O
(	O
timer	struct
->	O
group	pointer
==	O
asyncgroup	pointer
)	O
update_async	function
(	O
)	O
;	O
}	O
void	O
tl_set_multihandler	function
(	O
tl_timer	struct
*	O
timer	struct
,	O
void	O
(	O
*	O
handler	pointer
)	O
(	O
void	O
*	O
,	O
int	O
)	O
,	O
void	O
*	O
ud	pointer
)	O
{	O
timer	struct
->	O
multihandler	pointer
=	O
handler	pointer
;	O
timer	struct
->	O
userdata	pointer
=	O
ud	pointer
;	O
if	O
(	O
timer	struct
->	O
group	pointer
==	O
asyncgroup	pointer
)	O
update_async	function
(	O
)	O
;	O
}	O
void	O
tl_remove_timer	function
(	O
tl_timer	struct
*	O
timer	struct
)	O
{	O
tl_group	struct
*	O
g	pointer
=	O
timer	struct
->	O
group	pointer
;	O
timer	struct
->	O
previous	pointer
->	O
next	pointer
=	O
timer	struct
->	O
next	pointer
;	O
if	O
(	O
timer	struct
->	O
next	pointer
!=	O
NULL	O
)	O
timer	struct
->	O
next	pointer
->	O
previous	pointer
=	O
timer	struct
->	O
previous	pointer
;	O
timer	struct
->	O
group	pointer
=	O
NULL	O
;	O
if	O
(	O
g	pointer
==	O
asyncgroup	pointer
)	O
update_async	function
(	O
)	O
;	O
}	O
