static	O
void	O
set_default_dirlist	function
(	O
char	O
*	O
)	O
;	O
static	O
void	O
set_section_start	function
(	O
char	O
*	O
,	O
char	O
*	O
)	O
;	O
static	O
void	O
set_segment_start	function
(	O
const	O
char	O
*	O
,	O
char	O
*	O
)	O
;	O
static	O
void	O
help	function
(	O
void	O
)	O
;	O
enum	O
control_enum	enum
{	O
ONE_DASH	int
=	O
1	int
,	O
TWO_DASHES	int
=	O
2	int
,	O
EXACTLY_TWO_DASHES	int
,	O
NO_HELP	int
}	O
;	O
struct	O
ld_option	struct
{	O
struct	O
option	struct
opt	struct
;	O
char	O
shortopt	char
;	O
const	O
char	O
*	O
arg	pointer
;	O
const	O
char	O
*	O
doc	pointer
;	O
enum	O
control_enum	enum
control	enum
;	O
}	O
;	O
static	O
const	O
struct	O
ld_option	struct
ld_options	array
[	O
]	O
=	O
{	O
{	O
{	O
NULL	O
,	O
required_argument	int
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'a'	O
,	O
N_	O
(	O
"KEYWORD"	pointer
)	O
,	O
N_	O
(	O
"Shared library control for HP/UX compatibility"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"architecture"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'A'	O
}	O
,	O
'A'	O
,	O
N_	O
(	O
"ARCH"	pointer
)	O
,	O
N_	O
(	O
"Set architecture"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"format"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'b'	O
}	O
,	O
'b'	O
,	O
N_	O
(	O
"TARGET"	pointer
)	O
,	O
N_	O
(	O
"Specify target for following input files"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"mri-script"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'c'	O
}	O
,	O
'c'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
N_	O
(	O
"Read MRI format linker script"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"dc"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
'd'	O
,	O
NULL	O
,	O
N_	O
(	O
"Force common symbols to be defined"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"dp"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'd'	O
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"force-group-allocation"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_FORCE_GROUP_ALLOCATION	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Force group members out of groups"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"entry"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'e'	O
}	O
,	O
'e'	O
,	O
N_	O
(	O
"ADDRESS"	pointer
)	O
,	O
N_	O
(	O
"Set start address"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"export-dynamic"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_EXPORT_DYNAMIC	int
}	O
,	O
'E'	O
,	O
NULL	O
,	O
N_	O
(	O
"Export all dynamic symbols"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-export-dynamic"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_EXPORT_DYNAMIC	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Undo the effect of --export-dynamic"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"EB"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_EB	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Link big-endian objects"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"EL"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_EL	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Link little-endian objects"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"auxiliary"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'f'	O
}	O
,	O
'f'	O
,	O
N_	O
(	O
"SHLIB"	pointer
)	O
,	O
N_	O
(	O
"Auxiliary filter for shared object symbol table"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"filter"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'F'	O
}	O
,	O
'F'	O
,	O
N_	O
(	O
"SHLIB"	pointer
)	O
,	O
N_	O
(	O
"Filter for shared object symbol table"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'g'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"gpsize"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'G'	O
}	O
,	O
'G'	O
,	O
N_	O
(	O
"SIZE"	pointer
)	O
,	O
N_	O
(	O
"Small data size (if no size, same as --shared)"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"soname"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_SONAME	int
}	O
,	O
'h'	O
,	O
N_	O
(	O
"FILENAME"	pointer
)	O
,	O
N_	O
(	O
"Set internal name of shared library"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"dynamic-linker"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_DYNAMIC_LINKER	int
}	O
,	O
'I'	O
,	O
N_	O
(	O
"PROGRAM"	pointer
)	O
,	O
N_	O
(	O
"Set PROGRAM as the dynamic linker to use"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-dynamic-linker"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_DYNAMIC_LINKER	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Produce an executable with no program interpreter header"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"library"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'l'	O
}	O
,	O
'l'	O
,	O
N_	O
(	O
"LIBNAME"	pointer
)	O
,	O
N_	O
(	O
"Search for library LIBNAME"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"library-path"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'L'	O
}	O
,	O
'L'	O
,	O
N_	O
(	O
"DIRECTORY"	pointer
)	O
,	O
N_	O
(	O
"Add DIRECTORY to library search path"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"sysroot=<DIRECTORY>"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_SYSROOT	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Override the default sysroot location"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
NULL	O
,	O
required_argument	int
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'm'	O
,	O
N_	O
(	O
"EMULATION"	pointer
)	O
,	O
N_	O
(	O
"Set emulation"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"print-map"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'M'	O
}	O
,	O
'M'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print map file on standard output"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"nmagic"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'n'	O
}	O
,	O
'n'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not page align data"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"omagic"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'N'	O
}	O
,	O
'N'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not page align data, do not make text readonly"	pointer
)	O
,	O
EXACTLY_TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-omagic"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_OMAGIC	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Page align data, make text readonly"	pointer
)	O
,	O
EXACTLY_TWO_DASHES	int
}	O
,	O
{	O
{	O
"output"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'o'	O
}	O
,	O
'o'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
N_	O
(	O
"Set output file name"	pointer
)	O
,	O
EXACTLY_TWO_DASHES	int
}	O
,	O
{	O
{	O
NULL	O
,	O
required_argument	int
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'O'	O
,	O
NULL	O
,	O
N_	O
(	O
"Optimize output file"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"out-implib"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_OUT_IMPLIB	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
N_	O
(	O
"Generate import library"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"plugin"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_PLUGIN	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"PLUGIN"	pointer
)	O
,	O
N_	O
(	O
"Load named plugin"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"plugin-opt"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_PLUGIN_OPT	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ARG"	pointer
)	O
,	O
N_	O
(	O
"Send arg to last-loaded plugin"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"flto"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
OPTION_IGNORE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for GCC LTO option compatibility"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"flto-partition="	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_IGNORE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for GCC LTO option compatibility"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"fuse-ld="	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_IGNORE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for GCC linker option compatibility"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"map-whole-files"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
OPTION_IGNORE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for gold option compatibility"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-map-whole-files"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
OPTION_IGNORE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for gold option compatibility"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"Qy"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_IGNORE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for SVR4 compatibility"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"emit-relocs"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'q'	O
}	O
,	O
'q'	O
,	O
NULL	O
,	O
"Generate relocations in final output"	pointer
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"relocatable"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'r'	O
}	O
,	O
'r'	O
,	O
NULL	O
,	O
N_	O
(	O
"Generate relocatable output"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'i'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"just-symbols"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'R'	O
}	O
,	O
'R'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
N_	O
(	O
"Just link symbols (if directory, same as --rpath)"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"strip-all"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
's'	O
}	O
,	O
's'	O
,	O
NULL	O
,	O
N_	O
(	O
"Strip all symbols"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"strip-debug"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'S'	O
}	O
,	O
'S'	O
,	O
NULL	O
,	O
N_	O
(	O
"Strip debugging symbols"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"strip-discarded"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_STRIP_DISCARDED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Strip symbols in discarded sections"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-strip-discarded"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_STRIP_DISCARDED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not strip symbols in discarded sections"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"trace"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
't'	O
}	O
,	O
't'	O
,	O
NULL	O
,	O
N_	O
(	O
"Trace file opens"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"script"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'T'	O
}	O
,	O
'T'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
N_	O
(	O
"Read linker script"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"default-script"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_DEFAULT_SCRIPT	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
N_	O
(	O
"Read default linker script"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"dT"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_DEFAULT_SCRIPT	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"undefined"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'u'	O
}	O
,	O
'u'	O
,	O
N_	O
(	O
"SYMBOL"	pointer
)	O
,	O
N_	O
(	O
"Start with undefined reference to SYMBOL"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"require-defined"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_REQUIRE_DEFINED_SYMBOL	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	pointer
)	O
,	O
N_	O
(	O
"Require SYMBOL be defined in the final output"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"unique"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
OPTION_UNIQUE	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=SECTION]"	pointer
)	O
,	O
N_	O
(	O
"Don't merge input [SECTION | orphan] sections"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"Ur"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_UR	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Build global constructor/destructor tables"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_VERSION	int
}	O
,	O
'v'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print version information"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
NULL	O
,	O
no_argument	int
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'V'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print version and emulation information"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"discard-all"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'x'	O
}	O
,	O
'x'	O
,	O
NULL	O
,	O
N_	O
(	O
"Discard all local symbols"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"discard-locals"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'X'	O
}	O
,	O
'X'	O
,	O
NULL	O
,	O
N_	O
(	O
"Discard temporary local symbols (default)"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"discard-none"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_DISCARD_NONE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Don't discard any local symbols"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"trace-symbol"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
'y'	O
}	O
,	O
'y'	O
,	O
N_	O
(	O
"SYMBOL"	pointer
)	O
,	O
N_	O
(	O
"Trace mentions of SYMBOL"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
NULL	O
,	O
required_argument	int
,	O
NULL	O
,	O
'\0'	O
}	O
,	O
'Y'	O
,	O
N_	O
(	O
"PATH"	pointer
)	O
,	O
N_	O
(	O
"Default search path for Solaris compatibility"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"start-group"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
'('	O
}	O
,	O
'('	O
,	O
NULL	O
,	O
N_	O
(	O
"Start a group"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"end-group"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
')'	O
}	O
,	O
')'	O
,	O
NULL	O
,	O
N_	O
(	O
"End a group"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"accept-unknown-input-arch"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_ACCEPT_UNKNOWN_INPUT_ARCH	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Accept input files whose architecture cannot be determined"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-accept-unknown-input-arch"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_ACCEPT_UNKNOWN_INPUT_ARCH	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Reject input files whose architecture is unknown"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"add-needed"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_ADD_DT_NEEDED_FOR_DYNAMIC	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_HELP	int
}	O
,	O
{	O
{	O
"no-add-needed"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_ADD_DT_NEEDED_FOR_DYNAMIC	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_HELP	int
}	O
,	O
{	O
{	O
"as-needed"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_ADD_DT_NEEDED_FOR_REGULAR	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Only set DT_NEEDED for following dynamic libs if used"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-as-needed"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_ADD_DT_NEEDED_FOR_REGULAR	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Always set DT_NEEDED for dynamic libraries mentioned on\n"	pointer
"                                the command line"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"assert"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_ASSERT	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"KEYWORD"	pointer
)	O
,	O
N_	O
(	O
"Ignored for SunOS compatibility"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"Bdynamic"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_CALL_SHARED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Link against shared libraries"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"dy"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_CALL_SHARED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"call_shared"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_CALL_SHARED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"Bstatic"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NON_SHARED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not link against shared libraries"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"dn"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NON_SHARED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"non_shared"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NON_SHARED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"static"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NON_SHARED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"Bsymbolic"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_SYMBOLIC	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Bind global references locally"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"Bsymbolic-functions"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_SYMBOLIC_FUNCTIONS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Bind global function references locally"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"check-sections"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_CHECK_SECTIONS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Check section addresses for overlaps (default)"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-check-sections"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_CHECK_SECTIONS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not check section addresses for overlaps"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"copy-dt-needed-entries"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_ADD_DT_NEEDED_FOR_DYNAMIC	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Copy DT_NEEDED links mentioned inside DSOs that follow"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-copy-dt-needed-entries"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_ADD_DT_NEEDED_FOR_DYNAMIC	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not copy DT_NEEDED links mentioned inside DSOs that follow"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"cref"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_CREF	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Output cross reference table"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"defsym"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_DEFSYM	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL=EXPRESSION"	pointer
)	O
,	O
N_	O
(	O
"Define a symbol"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"demangle"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
OPTION_DEMANGLE	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=STYLE]"	pointer
)	O
,	O
N_	O
(	O
"Demangle symbol names [using STYLE]"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"disable-multiple-abs-defs"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_DISABLE_MULTIPLE_DEFS_ABS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not allow multiple definitions with symbols included\n"	pointer
"           in filename invoked by -R or --just-symbols"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"embedded-relocs"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_EMBEDDED_RELOCS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Generate embedded relocs"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"fatal-warnings"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_WARN_FATAL	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Treat warnings as errors"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-fatal-warnings"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_WARN_FATAL	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not treat warnings as errors (default)"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"fini"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_FINI	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	pointer
)	O
,	O
N_	O
(	O
"Call SYMBOL at unload-time"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"force-exe-suffix"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_FORCE_EXE_SUFFIX	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Force generation of file with .exe suffix"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"gc-sections"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_GC_SECTIONS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Remove unused sections (on some targets)"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-gc-sections"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_GC_SECTIONS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Don't remove unused sections (default)"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"print-gc-sections"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_PRINT_GC_SECTIONS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"List removed unused sections on stderr"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-print-gc-sections"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_PRINT_GC_SECTIONS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not list removed unused sections"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"gc-keep-exported"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_GC_KEEP_EXPORTED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Keep exported symbols when removing unused sections"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"hash-size=<NUMBER>"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_HASH_SIZE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Set default hash table size close to <NUMBER>"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_HELP	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print option help"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"init"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_INIT	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	pointer
)	O
,	O
N_	O
(	O
"Call SYMBOL at load-time"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"Map"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_MAP	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
N_	O
(	O
"Write a map file"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"no-define-common"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_DEFINE_COMMON	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not define Common storage"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-demangle"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_DEMANGLE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not demangle symbol names"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-keep-memory"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_KEEP_MEMORY	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Use less memory and more disk I/O"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-undefined"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_UNDEFINED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not allow unresolved references in object files"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"allow-shlib-undefined"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_ALLOW_SHLIB_UNDEFINED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Allow unresolved references in shared libraries"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-allow-shlib-undefined"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_ALLOW_SHLIB_UNDEFINED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not allow unresolved references in shared libs"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"allow-multiple-definition"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_ALLOW_MULTIPLE_DEFINITION	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Allow multiple definitions"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-undefined-version"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_UNDEFINED_VERSION	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Disallow undefined version"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"default-symver"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_DEFAULT_SYMVER	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Create default symbol version"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"default-imported-symver"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_DEFAULT_IMPORTED_SYMVER	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Create default symbol version for imported symbols"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-warn-mismatch"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_WARN_MISMATCH	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Don't warn about mismatched input files"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-warn-search-mismatch"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_WARN_SEARCH_MISMATCH	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Don't warn on finding an incompatible library"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-whole-archive"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_WHOLE_ARCHIVE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Turn off --whole-archive"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"noinhibit-exec"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NOINHIBIT_EXEC	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Create an output file even if errors occur"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"noinhibit_exec"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NOINHIBIT_EXEC	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_HELP	int
}	O
,	O
{	O
{	O
"nostdlib"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NOSTDLIB	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Only use library directories specified on\n"	pointer
"                                the command line"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"oformat"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_OFORMAT	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"TARGET"	pointer
)	O
,	O
N_	O
(	O
"Specify target of output file"	pointer
)	O
,	O
EXACTLY_TWO_DASHES	int
}	O
,	O
{	O
{	O
"print-output-format"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_PRINT_OUTPUT_FORMAT	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print default output format"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"print-sysroot"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_PRINT_SYSROOT	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print current sysroot"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"qmagic"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_IGNORE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Ignored for Linux compatibility"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"reduce-memory-overheads"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_REDUCE_MEMORY_OVERHEADS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Reduce memory overheads, possibly taking much longer"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"relax"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_RELAX	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Reduce code size by using target specific optimizations"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-relax"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_RELAX	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not use relaxation techniques to reduce code size"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"retain-symbols-file"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_RETAIN_SYMBOLS_FILE	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
N_	O
(	O
"Keep only symbols listed in FILE"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"rpath"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_RPATH	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"PATH"	pointer
)	O
,	O
N_	O
(	O
"Set runtime shared library search path"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"rpath-link"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_RPATH_LINK	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"PATH"	pointer
)	O
,	O
N_	O
(	O
"Set link time shared library search path"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"shared"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_SHARED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Create a shared library"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"Bshareable"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_SHARED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"pie"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_PIE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Create a position independent executable"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"pic-executable"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_PIE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"sort-common"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
OPTION_SORT_COMMON	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=ascending|descending]"	pointer
)	O
,	O
N_	O
(	O
"Sort common symbols by alignment [in specified order]"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"sort_common"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_SORT_COMMON	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_HELP	int
}	O
,	O
{	O
{	O
"sort-section"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_SORT_SECTION	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"name|alignment"	pointer
)	O
,	O
N_	O
(	O
"Sort sections by name or maximum alignment"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"spare-dynamic-tags"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_SPARE_DYNAMIC_TAGS	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"COUNT"	pointer
)	O
,	O
N_	O
(	O
"How many tags to reserve in .dynamic section"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"split-by-file"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
OPTION_SPLIT_BY_FILE	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=SIZE]"	pointer
)	O
,	O
N_	O
(	O
"Split output sections every SIZE octets"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"split-by-reloc"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
OPTION_SPLIT_BY_RELOC	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=COUNT]"	pointer
)	O
,	O
N_	O
(	O
"Split output sections every COUNT relocs"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"stats"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_STATS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Print memory usage statistics"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"target-help"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_TARGET_HELP	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Display target specific options"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"task-link"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_TASK_LINK	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	pointer
)	O
,	O
N_	O
(	O
"Do task level linking"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"traditional-format"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_TRADITIONAL_FORMAT	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Use same format as native linker"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"section-start"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_SECTION_START	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SECTION=ADDRESS"	pointer
)	O
,	O
N_	O
(	O
"Set address of named section"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"Tbss"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_TBSS	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	pointer
)	O
,	O
N_	O
(	O
"Set address of .bss section"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"Tdata"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_TDATA	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	pointer
)	O
,	O
N_	O
(	O
"Set address of .data section"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"Ttext"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_TTEXT	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	pointer
)	O
,	O
N_	O
(	O
"Set address of .text section"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"Ttext-segment"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_TTEXT_SEGMENT	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	pointer
)	O
,	O
N_	O
(	O
"Set address of text segment"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"Trodata-segment"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_TRODATA_SEGMENT	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	pointer
)	O
,	O
N_	O
(	O
"Set address of rodata segment"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"Tldata-segment"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_TLDATA_SEGMENT	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"ADDRESS"	pointer
)	O
,	O
N_	O
(	O
"Set address of ldata segment"	pointer
)	O
,	O
ONE_DASH	int
}	O
,	O
{	O
{	O
"unresolved-symbols=<method>"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_UNRESOLVED_SYMBOLS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"How to handle unresolved symbols.  <method> is:\n"	pointer
"                                ignore-all, report-all, ignore-in-object-files,\n"	pointer
"                                ignore-in-shared-libs"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"verbose"	pointer
,	O
optional_argument	int
,	O
NULL	O
,	O
OPTION_VERBOSE	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"[=NUMBER]"	pointer
)	O
,	O
N_	O
(	O
"Output lots of information during link"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"dll-verbose"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_VERBOSE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
NULL	O
,	O
NO_HELP	int
}	O
,	O
{	O
{	O
"version-script"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_VERSION_SCRIPT	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
N_	O
(	O
"Read version information script"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"version-exports-section"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_VERSION_EXPORTS_SECTION	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	pointer
)	O
,	O
N_	O
(	O
"Take export symbols list from .exports, using\n"	pointer
"                                SYMBOL as the version."	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"dynamic-list-data"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_DYNAMIC_LIST_DATA	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Add data symbols to dynamic list"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"dynamic-list-cpp-new"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_DYNAMIC_LIST_CPP_NEW	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Use C++ operator new/delete dynamic list"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"dynamic-list-cpp-typeinfo"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_DYNAMIC_LIST_CPP_TYPEINFO	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Use C++ typeinfo dynamic list"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"dynamic-list"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_DYNAMIC_LIST	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"FILE"	pointer
)	O
,	O
N_	O
(	O
"Read dynamic list"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"warn-common"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_WARN_COMMON	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn about duplicate common symbols"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"warn-constructors"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_WARN_CONSTRUCTORS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn if global constructors/destructors are seen"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"warn-multiple-gp"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_WARN_MULTIPLE_GP	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn if the multiple GP values are used"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"warn-once"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_WARN_ONCE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn only once per undefined symbol"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"warn-section-align"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_WARN_SECTION_ALIGN	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn if start of section changes due to alignment"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"warn-shared-textrel"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_WARN_SHARED_TEXTREL	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn if shared object has DT_TEXTREL"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"warn-alternate-em"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_WARN_ALTERNATE_EM	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Warn if an object has alternate ELF machine code"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"warn-unresolved-symbols"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_WARN_UNRESOLVED_SYMBOLS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Report unresolved symbols as warnings"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"error-unresolved-symbols"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_ERROR_UNRESOLVED_SYMBOLS	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Report unresolved symbols as errors"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"whole-archive"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_WHOLE_ARCHIVE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Include all objects from following archives"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"wrap"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_WRAP	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	pointer
)	O
,	O
N_	O
(	O
"Use wrapper functions for SYMBOL"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"ignore-unresolved-symbol"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_IGNORE_UNRESOLVED_SYMBOL	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"SYMBOL"	pointer
)	O
,	O
N_	O
(	O
"Unresolved SYMBOL will not cause an error or warning"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"push-state"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_PUSH_STATE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Push state of flags governing input file handling"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"pop-state"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_POP_STATE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Pop state of flags governing input file handling"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"print-memory-usage"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_PRINT_MEMORY_USAGE	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Report target memory usage"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"orphan-handling"	pointer
,	O
required_argument	int
,	O
NULL	O
,	O
OPTION_ORPHAN_HANDLING	int
}	O
,	O
'\0'	O
,	O
N_	O
(	O
"=MODE"	pointer
)	O
,	O
N_	O
(	O
"Control how orphan sections are handled."	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"print-map-discarded"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_PRINT_MAP_DISCARDED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Show discarded sections in map file output (default)"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
{	O
{	O
"no-print-map-discarded"	pointer
,	O
no_argument	int
,	O
NULL	O
,	O
OPTION_NO_PRINT_MAP_DISCARDED	int
}	O
,	O
'\0'	O
,	O
NULL	O
,	O
N_	O
(	O
"Do not show discarded sections in map file output"	pointer
)	O
,	O
TWO_DASHES	int
}	O
,	O
}	O
;	O
void	O
parse_args	function
(	O
unsigned	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
unsigned	O
i	pointer
;	O
int	O
is	pointer
,	O
il	int
,	O
irl	int
;	O
int	O
ingroup	int
=	O
0	int
;	O
char	O
*	O
default_dirlist	pointer
=	O
NULL	O
;	O
char	O
*	O
shortopts	pointer
;	O
struct	O
option	struct
*	O
longopts	pointer
;	O
struct	O
option	struct
*	O
really_longopts	pointer
;	O
int	O
last_optind	int
;	O
enum	O
report_method	enum
how_to_report_unresolved_symbols	enum
=	O
RM_GENERATE_ERROR	int
;	O
enum	O
symbolic_enum	enum
{	O
symbolic_unset	int
=	O
0	int
,	O
symbolic	int
,	O
symbolic_functions	int
,	O
}	O
opt_symbolic	enum
=	O
symbolic_unset	int
;	O
enum	O
dynamic_list_enum	enum
{	O
dynamic_list_unset	int
=	O
0	int
,	O
dynamic_list_data	int
,	O
dynamic_list	pointer
}	O
opt_dynamic_list	enum
=	O
dynamic_list_unset	int
;	O
shortopts	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
OPTION_COUNT	O
*	O
3	int
+	O
2	int
)	O
;	O
longopts	pointer
=	O
(	O
struct	O
option	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
*	O
longopts	pointer
)	O
*	O
(	O
OPTION_COUNT	O
+	O
1	int
)	O
)	O
;	O
really_longopts	pointer
=	O
(	O
struct	O
option	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
*	O
really_longopts	pointer
)	O
*	O
(	O
OPTION_COUNT	O
+	O
1	int
)	O
)	O
;	O
shortopts	pointer
[	O
0	int
]	O
=	O
'-'	O
;	O
is	pointer
=	O
1	int
;	O
il	int
=	O
0	int
;	O
irl	int
=	O
0	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
OPTION_COUNT	O
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
ld_options	array
[	O
i	pointer
]	O
.	O
shortopt	char
!=	O
'\0'	O
)	O
{	O
shortopts	pointer
[	O
is	pointer
]	O
=	O
ld_options	array
[	O
i	pointer
]	O
.	O
shortopt	char
;	O
++	O
is	pointer
;	O
if	O
(	O
ld_options	array
[	O
i	pointer
]	O
.	O
opt	struct
.	O
has_arg	int
==	O
required_argument	int
||	O
ld_options	array
[	O
i	pointer
]	O
.	O
opt	struct
.	O
has_arg	int
==	O
optional_argument	int
)	O
{	O
shortopts	pointer
[	O
is	pointer
]	O
=	O
':'	O
;	O
++	O
is	pointer
;	O
if	O
(	O
ld_options	array
[	O
i	pointer
]	O
.	O
opt	struct
.	O
has_arg	int
==	O
optional_argument	int
)	O
{	O
shortopts	pointer
[	O
is	pointer
]	O
=	O
':'	O
;	O
++	O
is	pointer
;	O
}	O
}	O
}	O
if	O
(	O
ld_options	array
[	O
i	pointer
]	O
.	O
opt	struct
.	O
name	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
ld_options	array
[	O
i	pointer
]	O
.	O
control	enum
==	O
EXACTLY_TWO_DASHES	int
)	O
{	O
really_longopts	pointer
[	O
irl	int
]	O
=	O
ld_options	array
[	O
i	pointer
]	O
.	O
opt	struct
;	O
++	O
irl	int
;	O
}	O
else	O
{	O
longopts	pointer
[	O
il	int
]	O
=	O
ld_options	array
[	O
i	pointer
]	O
.	O
opt	struct
;	O
++	O
il	int
;	O
}	O
}	O
}	O
shortopts	pointer
[	O
is	pointer
]	O
=	O
'\0'	O
;	O
longopts	pointer
[	O
il	int
]	O
.	O
name	pointer
=	O
NULL	O
;	O
really_longopts	pointer
[	O
irl	int
]	O
.	O
name	pointer
=	O
NULL	O
;	O
ldemul_add_options	function
(	O
is	pointer
,	O
&	O
shortopts	pointer
,	O
il	int
,	O
&	O
longopts	pointer
,	O
irl	int
,	O
&	O
really_longopts	pointer
)	O
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
argc	int
;	O
i	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
argv	pointer
[	O
i	pointer
]	O
,	O
"-G"	pointer
)	O
==	O
0	int
&&	O
(	O
i	pointer
+	O
1	int
>=	O
argc	int
||	O
!	O
ISDIGIT	O
(	O
argv	pointer
[	O
i	pointer
+	O
1	int
]	O
[	O
0	int
]	O
)	O
)	O
)	O
argv	pointer
[	O
i	pointer
]	O
=	O
(	O
char	O
*	O
)	O
"--shared"	pointer
;	O
for	O
(	O
i	pointer
=	O
1	int
;	O
i	pointer
<	O
argc	int
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
argv	pointer
[	O
i	pointer
]	O
[	O
0	int
]	O
==	O
'-'	O
&&	O
argv	pointer
[	O
i	pointer
]	O
[	O
1	int
]	O
==	O
'l'	O
&&	O
argv	pointer
[	O
i	pointer
]	O
[	O
2	int
]	O
!=	O
'\0'	O
)	O
{	O
char	O
*	O
n	pointer
;	O
n	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
argv	pointer
[	O
i	pointer
]	O
)	O
+	O
20	int
)	O
;	O
sprintf	function
(	O
n	pointer
,	O
"--library=%s"	pointer
,	O
argv	pointer
[	O
i	pointer
]	O
+	O
2	int
)	O
;	O
argv	pointer
[	O
i	pointer
]	O
=	O
n	pointer
;	O
}	O
}	O
last_optind	int
=	O
-	O
1	int
;	O
while	O
(	O
1	int
)	O
{	O
int	O
longind	pointer
;	O
int	O
optc	int
;	O
static	O
unsigned	O
int	O
defsym_count	int
;	O
if	O
(	O
optind	int
!=	O
last_optind	int
)	O
if	O
(	O
ldemul_parse_args	function
(	O
argc	int
,	O
argv	pointer
)	O
)	O
continue	O
;	O
opterr	int
=	O
0	int
;	O
last_optind	int
=	O
optind	int
;	O
optc	int
=	O
getopt_long_only	function
(	O
argc	int
,	O
argv	pointer
,	O
shortopts	pointer
,	O
longopts	pointer
,	O
&	O
longind	pointer
)	O
;	O
if	O
(	O
optc	int
==	O
'?'	O
)	O
{	O
optind	int
=	O
last_optind	int
;	O
optc	int
=	O
getopt_long	function
(	O
argc	int
,	O
argv	pointer
,	O
"-"	pointer
,	O
really_longopts	pointer
,	O
&	O
longind	pointer
)	O
;	O
}	O
if	O
(	O
ldemul_handle_option	function
(	O
optc	int
)	O
)	O
continue	O
;	O
if	O
(	O
optc	int
==	O
-	O
1	int
)	O
break	O
;	O
switch	O
(	O
optc	int
)	O
{	O
case	O
'?'	O
:	O
{	O
int	O
opt	struct
;	O
for	O
(	O
opt	struct
=	O
ARRAY_SIZE	O
(	O
ld_options	array
)	O
;	O
opt	struct
--	O
;	O
)	O
if	O
(	O
ld_options	array
[	O
opt	struct
]	O
.	O
opt	struct
.	O
has_arg	int
==	O
required_argument	int
&&	O
ld_options	array
[	O
opt	struct
]	O
.	O
opt	struct
.	O
name	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
argv	pointer
[	O
last_optind	int
]	O
+	O
ld_options	array
[	O
opt	struct
]	O
.	O
control	enum
,	O
ld_options	array
[	O
opt	struct
]	O
.	O
opt	struct
.	O
name	pointer
)	O
==	O
0	int
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%P: %s: missing argument\n"	pointer
)	O
,	O
argv	pointer
[	O
last_optind	int
]	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
opt	struct
==	O
-	O
1	int
)	O
einfo	pointer
(	O
_	O
(	O
"%P: unrecognized option '%s'\n"	pointer
)	O
,	O
argv	pointer
[	O
last_optind	int
]	O
)	O
;	O
}	O
default	O
:	O
einfo	pointer
(	O
_	O
(	O
"%F%P: use the --help option for usage information\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
1	int
:	O
lang_add_input_file	function
(	O
optarg	pointer
,	O
lang_input_file_is_file_enum	int
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
OPTION_IGNORE	int
:	O
break	O
;	O
case	O
'a'	O
:	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"archive"	pointer
)	O
==	O
0	int
)	O
input_flags	struct
.	O
dynamic	int
=	O
FALSE	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"shared"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
optarg	pointer
,	O
"default"	pointer
)	O
==	O
0	int
)	O
input_flags	struct
.	O
dynamic	int
=	O
TRUE	int
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: unrecognized -a option `%s'\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_ASSERT	int
:	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"definitions"	pointer
)	O
==	O
0	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"nodefinitions"	pointer
)	O
==	O
0	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"nosymbolic"	pointer
)	O
==	O
0	int
)	O
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"pure-text"	pointer
)	O
==	O
0	int
)	O
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: unrecognized -assert option `%s'\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
ldfile_add_arch	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
lang_add_target	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
ldfile_open_command_file	function
(	O
optarg	pointer
)	O
;	O
parser_input	enum
=	O
input_mri_script	int
;	O
yyparse	function
(	O
)	O
;	O
break	O
;	O
case	O
OPTION_CALL_SHARED	int
:	O
input_flags	struct
.	O
dynamic	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NON_SHARED	int
:	O
input_flags	struct
.	O
dynamic	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_CREF	int
:	O
command_line	struct
.	O
cref	int
=	O
TRUE	int
;	O
link_info	struct
.	O
notice_all	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'd'	O
:	O
command_line	struct
.	O
force_common_definition	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_FORCE_GROUP_ALLOCATION	int
:	O
command_line	struct
.	O
force_group_allocation	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_DEFSYM	int
:	O
lex_string	pointer
=	O
optarg	pointer
;	O
lex_redirect	function
(	O
optarg	pointer
,	O
"--defsym"	pointer
,	O
++	O
defsym_count	int
)	O
;	O
parser_input	enum
=	O
input_defsym	int
;	O
yyparse	function
(	O
)	O
;	O
lex_string	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
OPTION_DEMANGLE	int
:	O
demangling	int
=	O
TRUE	int
;	O
if	O
(	O
optarg	pointer
!=	O
NULL	O
)	O
{	O
enum	O
demangling_styles	enum
style	enum
;	O
style	enum
=	O
cplus_demangle_name_to_style	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
style	enum
==	O
unknown_demangling	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: unknown demangling style `%s'\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
cplus_demangle_set_style	function
(	O
style	enum
)	O
;	O
}	O
break	O
;	O
case	O
'I'	O
:	O
case	O
OPTION_DYNAMIC_LINKER	int
:	O
command_line	struct
.	O
interpreter	pointer
=	O
optarg	pointer
;	O
link_info	struct
.	O
nointerp	int
=	O
0	int
;	O
break	O
;	O
case	O
OPTION_NO_DYNAMIC_LINKER	int
:	O
link_info	struct
.	O
nointerp	int
=	O
1	int
;	O
break	O
;	O
case	O
OPTION_SYSROOT	int
:	O
break	O
;	O
case	O
OPTION_EB	int
:	O
command_line	struct
.	O
endian	enum
=	O
ENDIAN_BIG	int
;	O
break	O
;	O
case	O
OPTION_EL	int
:	O
command_line	struct
.	O
endian	enum
=	O
ENDIAN_LITTLE	int
;	O
break	O
;	O
case	O
OPTION_EMBEDDED_RELOCS	int
:	O
command_line	struct
.	O
embedded_relocs	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_EXPORT_DYNAMIC	int
:	O
case	O
'E'	O
:	O
link_info	struct
.	O
export_dynamic	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_EXPORT_DYNAMIC	int
:	O
link_info	struct
.	O
export_dynamic	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'e'	O
:	O
lang_add_entry	function
(	O
optarg	pointer
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
if	O
(	O
command_line	struct
.	O
auxiliary_filters	pointer
==	O
NULL	O
)	O
{	O
command_line	struct
.	O
auxiliary_filters	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xmalloc	function
(	O
2	int
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
command_line	struct
.	O
auxiliary_filters	pointer
[	O
0	int
]	O
=	O
optarg	pointer
;	O
command_line	struct
.	O
auxiliary_filters	pointer
[	O
1	int
]	O
=	O
NULL	O
;	O
}	O
else	O
{	O
int	O
c	struct
;	O
char	O
*	O
*	O
p	pointer
;	O
c	struct
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
command_line	struct
.	O
auxiliary_filters	pointer
;	O
*	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
++	O
)	O
++	O
c	struct
;	O
command_line	struct
.	O
auxiliary_filters	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	function
(	O
command_line	struct
.	O
auxiliary_filters	pointer
,	O
(	O
c	struct
+	O
2	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
command_line	struct
.	O
auxiliary_filters	pointer
[	O
c	struct
]	O
=	O
optarg	pointer
;	O
command_line	struct
.	O
auxiliary_filters	pointer
[	O
c	struct
+	O
1	int
]	O
=	O
NULL	O
;	O
}	O
break	O
;	O
case	O
'F'	O
:	O
command_line	struct
.	O
filter_shlib	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
OPTION_FORCE_EXE_SUFFIX	int
:	O
command_line	struct
.	O
force_exe_suffix	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'G'	O
:	O
{	O
char	O
*	O
end	pointer
;	O
g_switch_value	int
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	pointer
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid number `%s'\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'g'	O
:	O
break	O
;	O
case	O
OPTION_GC_SECTIONS	int
:	O
link_info	struct
.	O
gc_sections	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_PRINT_GC_SECTIONS	int
:	O
link_info	struct
.	O
print_gc_sections	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_GC_KEEP_EXPORTED	int
:	O
link_info	struct
.	O
gc_keep_exported	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_HELP	int
:	O
help	function
(	O
)	O
;	O
xexit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
ldfile_add_library_path	function
(	O
optarg	pointer
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
lang_add_input_file	function
(	O
optarg	pointer
,	O
lang_input_file_is_l_enum	int
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
config	struct
.	O
map_filename	pointer
=	O
"-"	pointer
;	O
break	O
;	O
case	O
'm'	O
:	O
break	O
;	O
case	O
OPTION_MAP	int
:	O
config	struct
.	O
map_filename	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'N'	O
:	O
config	struct
.	O
text_read_only	int
=	O
FALSE	int
;	O
config	struct
.	O
magic_demand_paged	int
=	O
FALSE	int
;	O
input_flags	struct
.	O
dynamic	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_NO_OMAGIC	int
:	O
config	struct
.	O
text_read_only	int
=	O
TRUE	int
;	O
config	struct
.	O
magic_demand_paged	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'n'	O
:	O
config	struct
.	O
magic_demand_paged	int
=	O
FALSE	int
;	O
input_flags	struct
.	O
dynamic	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_NO_DEFINE_COMMON	int
:	O
link_info	struct
.	O
inhibit_common_definition	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_DEMANGLE	int
:	O
demangling	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_NO_GC_SECTIONS	int
:	O
link_info	struct
.	O
gc_sections	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_NO_PRINT_GC_SECTIONS	int
:	O
link_info	struct
.	O
print_gc_sections	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_NO_KEEP_MEMORY	int
:	O
link_info	struct
.	O
keep_memory	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_NO_UNDEFINED	int
:	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
how_to_report_unresolved_symbols	enum
;	O
break	O
;	O
case	O
OPTION_ALLOW_SHLIB_UNDEFINED	int
:	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
=	O
RM_IGNORE	int
;	O
break	O
;	O
case	O
OPTION_NO_ALLOW_SHLIB_UNDEFINED	int
:	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
=	O
how_to_report_unresolved_symbols	enum
;	O
break	O
;	O
case	O
OPTION_UNRESOLVED_SYMBOLS	int
:	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"ignore-all"	pointer
)	O
==	O
0	int
)	O
{	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
RM_IGNORE	int
;	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
=	O
RM_IGNORE	int
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"report-all"	pointer
)	O
==	O
0	int
)	O
{	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
how_to_report_unresolved_symbols	enum
;	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
=	O
how_to_report_unresolved_symbols	enum
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"ignore-in-object-files"	pointer
)	O
==	O
0	int
)	O
{	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
RM_IGNORE	int
;	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
=	O
how_to_report_unresolved_symbols	enum
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
"ignore-in-shared-libs"	pointer
)	O
==	O
0	int
)	O
{	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
how_to_report_unresolved_symbols	enum
;	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
=	O
RM_IGNORE	int
;	O
}	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: bad --unresolved-symbols option: %s\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_WARN_UNRESOLVED_SYMBOLS	int
:	O
how_to_report_unresolved_symbols	enum
=	O
RM_GENERATE_WARNING	int
;	O
if	O
(	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
==	O
RM_GENERATE_ERROR	int
)	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
RM_GENERATE_WARNING	int
;	O
if	O
(	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
==	O
RM_GENERATE_ERROR	int
)	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
=	O
RM_GENERATE_WARNING	int
;	O
break	O
;	O
case	O
OPTION_ERROR_UNRESOLVED_SYMBOLS	int
:	O
how_to_report_unresolved_symbols	enum
=	O
RM_GENERATE_ERROR	int
;	O
if	O
(	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
==	O
RM_GENERATE_WARNING	int
)	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
RM_GENERATE_ERROR	int
;	O
if	O
(	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
==	O
RM_GENERATE_WARNING	int
)	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
=	O
RM_GENERATE_ERROR	int
;	O
break	O
;	O
case	O
OPTION_ALLOW_MULTIPLE_DEFINITION	int
:	O
link_info	struct
.	O
allow_multiple_definition	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_UNDEFINED_VERSION	int
:	O
link_info	struct
.	O
allow_undefined_version	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_DEFAULT_SYMVER	int
:	O
link_info	struct
.	O
create_default_symver	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_DEFAULT_IMPORTED_SYMVER	int
:	O
link_info	struct
.	O
default_imported_symver	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_WARN_MISMATCH	int
:	O
command_line	struct
.	O
warn_mismatch	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_NO_WARN_SEARCH_MISMATCH	int
:	O
command_line	struct
.	O
warn_search_mismatch	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_NOINHIBIT_EXEC	int
:	O
force_make_executable	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NOSTDLIB	int
:	O
config	struct
.	O
only_cmd_line_lib_dirs	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_WHOLE_ARCHIVE	int
:	O
input_flags	struct
.	O
whole_archive	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'O'	O
:	O
link_info	struct
.	O
optimize	int
=	O
strtoul	function
(	O
optarg	pointer
,	O
NULL	O
,	O
0	int
)	O
?	O
TRUE	int
:	O
FALSE	int
;	O
break	O
;	O
case	O
'o'	O
:	O
lang_add_output	function
(	O
optarg	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
OPTION_OFORMAT	int
:	O
lang_add_output_format	function
(	O
optarg	pointer
,	O
NULL	O
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
OPTION_OUT_IMPLIB	int
:	O
command_line	struct
.	O
out_implib_filename	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_PRINT_SYSROOT	int
:	O
if	O
(	O
*	O
ld_sysroot	pointer
)	O
puts	function
(	O
ld_sysroot	pointer
)	O
;	O
xexit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
OPTION_PRINT_OUTPUT_FORMAT	int
:	O
command_line	struct
.	O
print_output_format	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_PLUGIN	int
:	O
plugin_opt_plugin	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_PLUGIN_OPT	int
:	O
if	O
(	O
plugin_opt_plugin_arg	function
(	O
optarg	pointer
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: bad -plugin-opt option\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'q'	O
:	O
link_info	struct
.	O
emitrelocations	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'i'	O
:	O
case	O
'r'	O
:	O
if	O
(	O
optind	int
==	O
last_optind	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: unrecognised option: %s\n"	pointer
)	O
,	O
argv	pointer
[	O
optind	int
]	O
)	O
;	O
if	O
(	O
bfd_link_pic	O
(	O
&	O
link_info	struct
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: -r and %s may not be used together\n"	pointer
)	O
,	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
?	O
"-shared"	pointer
:	O
"-pie"	pointer
)	O
;	O
link_info	struct
.	O
type	enum
=	O
type_relocatable	int
;	O
config	struct
.	O
build_constructors	int
=	O
FALSE	int
;	O
config	struct
.	O
magic_demand_paged	int
=	O
FALSE	int
;	O
config	struct
.	O
text_read_only	int
=	O
FALSE	int
;	O
input_flags	struct
.	O
dynamic	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'R'	O
:	O
{	O
struct	O
stat	struct
s	pointer
;	O
if	O
(	O
stat	struct
(	O
optarg	pointer
,	O
&	O
s	pointer
)	O
>=	O
0	int
&&	O
!	O
S_ISDIR	O
(	O
s	pointer
.	O
st_mode	int
)	O
)	O
{	O
lang_add_input_file	function
(	O
optarg	pointer
,	O
lang_input_file_is_symbols_only_enum	int
,	O
NULL	O
)	O
;	O
break	O
;	O
}	O
}	O
case	O
OPTION_RPATH	int
:	O
if	O
(	O
command_line	struct
.	O
rpath	pointer
==	O
NULL	O
)	O
command_line	struct
.	O
rpath	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
else	O
{	O
size_t	long
rpath_len	long
=	O
strlen	function
(	O
command_line	struct
.	O
rpath	pointer
)	O
;	O
size_t	long
optarg_len	long
=	O
strlen	function
(	O
optarg	pointer
)	O
;	O
char	O
*	O
buf	pointer
;	O
char	O
*	O
cp	pointer
=	O
command_line	struct
.	O
rpath	pointer
;	O
do	O
{	O
if	O
(	O
strncmp	function
(	O
optarg	pointer
,	O
cp	pointer
,	O
optarg_len	long
)	O
==	O
0	int
&&	O
(	O
cp	pointer
[	O
optarg_len	long
]	O
==	O
0	int
||	O
cp	pointer
[	O
optarg_len	long
]	O
==	O
config	struct
.	O
rpath_separator	char
)	O
)	O
break	O
;	O
cp	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
config	struct
.	O
rpath_separator	char
)	O
;	O
if	O
(	O
cp	pointer
!=	O
NULL	O
)	O
++	O
cp	pointer
;	O
}	O
while	O
(	O
cp	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
{	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
rpath_len	long
+	O
optarg_len	long
+	O
2	int
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%s%c%s"	pointer
,	O
command_line	struct
.	O
rpath	pointer
,	O
config	struct
.	O
rpath_separator	char
,	O
optarg	pointer
)	O
;	O
free	function
(	O
command_line	struct
.	O
rpath	pointer
)	O
;	O
command_line	struct
.	O
rpath	pointer
=	O
buf	pointer
;	O
}	O
}	O
break	O
;	O
case	O
OPTION_RPATH_LINK	int
:	O
if	O
(	O
command_line	struct
.	O
rpath_link	pointer
==	O
NULL	O
)	O
command_line	struct
.	O
rpath_link	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
else	O
{	O
char	O
*	O
buf	pointer
;	O
buf	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
strlen	function
(	O
command_line	struct
.	O
rpath_link	pointer
)	O
+	O
strlen	function
(	O
optarg	pointer
)	O
+	O
2	int
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%s%c%s"	pointer
,	O
command_line	struct
.	O
rpath_link	pointer
,	O
config	struct
.	O
rpath_separator	char
,	O
optarg	pointer
)	O
;	O
free	function
(	O
command_line	struct
.	O
rpath_link	pointer
)	O
;	O
command_line	struct
.	O
rpath_link	pointer
=	O
buf	pointer
;	O
}	O
break	O
;	O
case	O
OPTION_NO_RELAX	int
:	O
DISABLE_RELAXATION	O
;	O
break	O
;	O
case	O
OPTION_RELAX	int
:	O
ENABLE_RELAXATION	O
;	O
break	O
;	O
case	O
OPTION_RETAIN_SYMBOLS_FILE	int
:	O
add_keepsyms_file	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
link_info	struct
.	O
strip	enum
=	O
strip_debugger	int
;	O
break	O
;	O
case	O
's'	O
:	O
link_info	struct
.	O
strip	enum
=	O
strip_all	int
;	O
break	O
;	O
case	O
OPTION_STRIP_DISCARDED	int
:	O
link_info	struct
.	O
strip_discarded	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_STRIP_DISCARDED	int
:	O
link_info	struct
.	O
strip_discarded	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_DISABLE_MULTIPLE_DEFS_ABS	int
:	O
link_info	struct
.	O
prohibit_multiple_definition_absolute	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_SHARED	int
:	O
if	O
(	O
config	struct
.	O
has_shared	int
)	O
{	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: -r and %s may not be used together\n"	pointer
)	O
,	O
"-shared"	pointer
)	O
;	O
link_info	struct
.	O
type	enum
=	O
type_dll	int
;	O
if	O
(	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
==	O
RM_NOT_YET_SET	int
)	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
RM_IGNORE	int
;	O
if	O
(	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
==	O
RM_NOT_YET_SET	int
)	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
=	O
RM_IGNORE	int
;	O
}	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: -shared not supported\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPTION_PIE	int
:	O
if	O
(	O
config	struct
.	O
has_shared	int
)	O
{	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: -r and %s may not be used together\n"	pointer
)	O
,	O
"-pie"	pointer
)	O
;	O
link_info	struct
.	O
type	enum
=	O
type_pie	int
;	O
}	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: -pie not supported\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
case	O
OPTION_SONAME	int
:	O
if	O
(	O
optarg	pointer
[	O
0	int
]	O
==	O
'\0'	O
&&	O
command_line	struct
.	O
soname	pointer
&&	O
command_line	struct
.	O
soname	pointer
[	O
0	int
]	O
)	O
einfo	pointer
(	O
_	O
(	O
"%P: SONAME must not be empty string; keeping previous one\n"	pointer
)	O
)	O
;	O
else	O
command_line	struct
.	O
soname	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
OPTION_SORT_COMMON	int
:	O
if	O
(	O
optarg	pointer
==	O
NULL	O
||	O
strcmp	function
(	O
optarg	pointer
,	O
N_	O
(	O
"descending"	pointer
)	O
)	O
==	O
0	int
)	O
config	struct
.	O
sort_common	enum
=	O
sort_descending	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
N_	O
(	O
"ascending"	pointer
)	O
)	O
==	O
0	int
)	O
config	struct
.	O
sort_common	enum
=	O
sort_ascending	int
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid common section sorting option: %s\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_SORT_SECTION	int
:	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
N_	O
(	O
"name"	pointer
)	O
)	O
==	O
0	int
)	O
sort_section	enum
=	O
by_name	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
optarg	pointer
,	O
N_	O
(	O
"alignment"	pointer
)	O
)	O
==	O
0	int
)	O
sort_section	enum
=	O
by_alignment	int
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid section sorting option: %s\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_STATS	int
:	O
config	struct
.	O
stats	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_SYMBOLIC	int
:	O
opt_symbolic	enum
=	O
symbolic	int
;	O
break	O
;	O
case	O
OPTION_SYMBOLIC_FUNCTIONS	int
:	O
opt_symbolic	enum
=	O
symbolic_functions	int
;	O
break	O
;	O
case	O
't'	O
:	O
++	O
trace_files	int
;	O
break	O
;	O
case	O
'T'	O
:	O
previous_script_handle	pointer
=	O
saved_script_handle	pointer
;	O
ldfile_open_script_file	function
(	O
optarg	pointer
)	O
;	O
parser_input	enum
=	O
input_script	int
;	O
yyparse	function
(	O
)	O
;	O
previous_script_handle	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
OPTION_DEFAULT_SCRIPT	int
:	O
command_line	struct
.	O
default_script	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
OPTION_SECTION_START	int
:	O
{	O
char	O
*	O
optarg2	pointer
;	O
char	O
*	O
sec_name	pointer
;	O
int	O
len	long
;	O
optarg2	pointer
=	O
strchr	function
(	O
optarg	pointer
,	O
'='	O
)	O
;	O
if	O
(	O
optarg2	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid argument to option"	pointer
" \"--section-start\"\n"	pointer
)	O
)	O
;	O
optarg2	pointer
++	O
;	O
if	O
(	O
(	O
*	O
optarg	pointer
==	O
'\0'	O
)	O
||	O
(	O
*	O
optarg2	pointer
==	O
'\0'	O
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: missing argument(s) to option"	pointer
" \"--section-start\"\n"	pointer
)	O
)	O
;	O
len	long
=	O
optarg2	pointer
-	O
optarg	pointer
;	O
sec_name	pointer
=	O
(	O
char	O
*	O
)	O
xmalloc	function
(	O
len	long
)	O
;	O
memcpy	function
(	O
sec_name	pointer
,	O
optarg	pointer
,	O
len	long
-	O
1	int
)	O
;	O
sec_name	pointer
[	O
len	long
-	O
1	int
]	O
=	O
0	int
;	O
set_section_start	function
(	O
sec_name	pointer
,	O
optarg2	pointer
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_TARGET_HELP	int
:	O
ldemul_list_emulation_options	function
(	O
stdout	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
case	O
OPTION_TBSS	int
:	O
set_segment_start	function
(	O
".bss"	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_TDATA	int
:	O
set_segment_start	function
(	O
".data"	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_TTEXT	int
:	O
set_segment_start	function
(	O
".text"	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_TTEXT_SEGMENT	int
:	O
set_segment_start	function
(	O
".text-segment"	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_TRODATA_SEGMENT	int
:	O
set_segment_start	function
(	O
".rodata-segment"	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_TLDATA_SEGMENT	int
:	O
set_segment_start	function
(	O
".ldata-segment"	pointer
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_TRADITIONAL_FORMAT	int
:	O
link_info	struct
.	O
traditional_format	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_TASK_LINK	int
:	O
link_info	struct
.	O
task_link	int
=	O
TRUE	int
;	O
case	O
OPTION_UR	int
:	O
if	O
(	O
bfd_link_pic	O
(	O
&	O
link_info	struct
)	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: -r and %s may not be used together\n"	pointer
)	O
,	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
?	O
"-shared"	pointer
:	O
"-pie"	pointer
)	O
;	O
link_info	struct
.	O
type	enum
=	O
type_relocatable	int
;	O
config	struct
.	O
build_constructors	int
=	O
TRUE	int
;	O
config	struct
.	O
magic_demand_paged	int
=	O
FALSE	int
;	O
config	struct
.	O
text_read_only	int
=	O
FALSE	int
;	O
input_flags	struct
.	O
dynamic	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'u'	O
:	O
ldlang_add_undef	function
(	O
optarg	pointer
,	O
TRUE	int
)	O
;	O
break	O
;	O
case	O
OPTION_REQUIRE_DEFINED_SYMBOL	int
:	O
ldlang_add_require_defined	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_UNIQUE	int
:	O
if	O
(	O
optarg	pointer
!=	O
NULL	O
)	O
lang_add_unique	function
(	O
optarg	pointer
)	O
;	O
else	O
config	struct
.	O
unique_orphan_sections	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_VERBOSE	int
:	O
ldversion	function
(	O
1	int
)	O
;	O
version_printed	int
=	O
TRUE	int
;	O
verbose	int
=	O
TRUE	int
;	O
overflow_cutoff_limit	int
=	O
-	O
2	int
;	O
if	O
(	O
optarg	pointer
!=	O
NULL	O
)	O
{	O
char	O
*	O
end	pointer
;	O
int	O
level	int
ATTRIBUTE_UNUSED	O
=	O
strtoul	function
(	O
optarg	pointer
,	O
&	O
end	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
end	pointer
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid number `%s'\n"	pointer
)	O
,	O
optarg	pointer
)	O
;	O
report_plugin_symbols	int
=	O
level	int
>	O
1	int
;	O
}	O
break	O
;	O
case	O
'v'	O
:	O
ldversion	function
(	O
0	int
)	O
;	O
version_printed	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
'V'	O
:	O
ldversion	function
(	O
1	int
)	O
;	O
version_printed	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_VERSION	int
:	O
ldversion	function
(	O
2	int
)	O
;	O
xexit	function
(	O
0	int
)	O
;	O
break	O
;	O
case	O
OPTION_VERSION_SCRIPT	int
:	O
{	O
FILE	struct
*	O
hold_script_handle	pointer
;	O
hold_script_handle	pointer
=	O
saved_script_handle	pointer
;	O
ldfile_open_command_file	function
(	O
optarg	pointer
)	O
;	O
saved_script_handle	pointer
=	O
hold_script_handle	pointer
;	O
parser_input	enum
=	O
input_version_script	int
;	O
yyparse	function
(	O
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_VERSION_EXPORTS_SECTION	int
:	O
command_line	struct
.	O
version_exports_section	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
OPTION_DYNAMIC_LIST_DATA	int
:	O
opt_dynamic_list	enum
=	O
dynamic_list_data	int
;	O
if	O
(	O
opt_symbolic	enum
==	O
symbolic	int
)	O
opt_symbolic	enum
=	O
symbolic_unset	int
;	O
break	O
;	O
case	O
OPTION_DYNAMIC_LIST_CPP_TYPEINFO	int
:	O
lang_append_dynamic_list_cpp_typeinfo	function
(	O
)	O
;	O
if	O
(	O
opt_dynamic_list	enum
!=	O
dynamic_list_data	int
)	O
opt_dynamic_list	enum
=	O
dynamic_list	pointer
;	O
if	O
(	O
opt_symbolic	enum
==	O
symbolic	int
)	O
opt_symbolic	enum
=	O
symbolic_unset	int
;	O
break	O
;	O
case	O
OPTION_DYNAMIC_LIST_CPP_NEW	int
:	O
lang_append_dynamic_list_cpp_new	function
(	O
)	O
;	O
if	O
(	O
opt_dynamic_list	enum
!=	O
dynamic_list_data	int
)	O
opt_dynamic_list	enum
=	O
dynamic_list	pointer
;	O
if	O
(	O
opt_symbolic	enum
==	O
symbolic	int
)	O
opt_symbolic	enum
=	O
symbolic_unset	int
;	O
break	O
;	O
case	O
OPTION_DYNAMIC_LIST	int
:	O
{	O
FILE	struct
*	O
hold_script_handle	pointer
;	O
hold_script_handle	pointer
=	O
saved_script_handle	pointer
;	O
ldfile_open_command_file	function
(	O
optarg	pointer
)	O
;	O
saved_script_handle	pointer
=	O
hold_script_handle	pointer
;	O
parser_input	enum
=	O
input_dynamic_list	int
;	O
yyparse	function
(	O
)	O
;	O
}	O
if	O
(	O
opt_dynamic_list	enum
!=	O
dynamic_list_data	int
)	O
opt_dynamic_list	enum
=	O
dynamic_list	pointer
;	O
if	O
(	O
opt_symbolic	enum
==	O
symbolic	int
)	O
opt_symbolic	enum
=	O
symbolic_unset	int
;	O
break	O
;	O
case	O
OPTION_WARN_COMMON	int
:	O
config	struct
.	O
warn_common	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_CONSTRUCTORS	int
:	O
config	struct
.	O
warn_constructors	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_FATAL	int
:	O
config	struct
.	O
fatal_warnings	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_WARN_FATAL	int
:	O
config	struct
.	O
fatal_warnings	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_WARN_MULTIPLE_GP	int
:	O
config	struct
.	O
warn_multiple_gp	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_ONCE	int
:	O
config	struct
.	O
warn_once	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_SECTION_ALIGN	int
:	O
config	struct
.	O
warn_section_align	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_SHARED_TEXTREL	int
:	O
link_info	struct
.	O
warn_shared_textrel	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WARN_ALTERNATE_EM	int
:	O
link_info	struct
.	O
warn_alternate_em	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_WHOLE_ARCHIVE	int
:	O
input_flags	struct
.	O
whole_archive	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_ADD_DT_NEEDED_FOR_DYNAMIC	int
:	O
input_flags	struct
.	O
add_DT_NEEDED_for_dynamic	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_ADD_DT_NEEDED_FOR_DYNAMIC	int
:	O
input_flags	struct
.	O
add_DT_NEEDED_for_dynamic	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_ADD_DT_NEEDED_FOR_REGULAR	int
:	O
input_flags	struct
.	O
add_DT_NEEDED_for_regular	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_ADD_DT_NEEDED_FOR_REGULAR	int
:	O
input_flags	struct
.	O
add_DT_NEEDED_for_regular	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_WRAP	int
:	O
add_wrap	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_IGNORE_UNRESOLVED_SYMBOL	int
:	O
add_ignoresym	function
(	O
&	O
link_info	struct
,	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_DISCARD_NONE	int
:	O
link_info	struct
.	O
discard	enum
=	O
discard_none	int
;	O
break	O
;	O
case	O
'X'	O
:	O
link_info	struct
.	O
discard	enum
=	O
discard_l	int
;	O
break	O
;	O
case	O
'x'	O
:	O
link_info	struct
.	O
discard	enum
=	O
discard_all	int
;	O
break	O
;	O
case	O
'Y'	O
:	O
if	O
(	O
CONST_STRNEQ	O
(	O
optarg	pointer
,	O
"P,"	pointer
)	O
)	O
optarg	pointer
+=	O
2	int
;	O
if	O
(	O
default_dirlist	pointer
!=	O
NULL	O
)	O
free	function
(	O
default_dirlist	pointer
)	O
;	O
default_dirlist	pointer
=	O
xstrdup	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'y'	O
:	O
add_ysym	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
OPTION_SPARE_DYNAMIC_TAGS	int
:	O
link_info	struct
.	O
spare_dynamic_tags	int
=	O
strtoul	function
(	O
optarg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
break	O
;	O
case	O
OPTION_SPLIT_BY_RELOC	int
:	O
if	O
(	O
optarg	pointer
!=	O
NULL	O
)	O
config	struct
.	O
split_by_reloc	int
=	O
strtoul	function
(	O
optarg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
else	O
config	struct
.	O
split_by_reloc	int
=	O
32768	int
;	O
break	O
;	O
case	O
OPTION_SPLIT_BY_FILE	int
:	O
if	O
(	O
optarg	pointer
!=	O
NULL	O
)	O
config	struct
.	O
split_by_file	long
=	O
bfd_scan_vma	function
(	O
optarg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
else	O
config	struct
.	O
split_by_file	long
=	O
1	int
;	O
break	O
;	O
case	O
OPTION_CHECK_SECTIONS	int
:	O
command_line	struct
.	O
check_section_addresses	char
=	O
1	int
;	O
break	O
;	O
case	O
OPTION_NO_CHECK_SECTIONS	int
:	O
command_line	struct
.	O
check_section_addresses	char
=	O
0	int
;	O
break	O
;	O
case	O
OPTION_ACCEPT_UNKNOWN_INPUT_ARCH	int
:	O
command_line	struct
.	O
accept_unknown_input_arch	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_NO_ACCEPT_UNKNOWN_INPUT_ARCH	int
:	O
command_line	struct
.	O
accept_unknown_input_arch	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
'('	O
:	O
lang_enter_group	function
(	O
)	O
;	O
ingroup	int
++	O
;	O
break	O
;	O
case	O
')'	O
:	O
if	O
(	O
!	O
ingroup	int
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: group ended before it began (--help for usage)\n"	pointer
)	O
)	O
;	O
lang_leave_group	function
(	O
)	O
;	O
ingroup	int
--	O
;	O
break	O
;	O
case	O
OPTION_INIT	int
:	O
link_info	struct
.	O
init_function	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
OPTION_FINI	int
:	O
link_info	struct
.	O
fini_function	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
OPTION_REDUCE_MEMORY_OVERHEADS	int
:	O
link_info	struct
.	O
reduce_memory_overheads	int
=	O
TRUE	int
;	O
if	O
(	O
config	struct
.	O
hash_table_size	long
==	O
0	int
)	O
config	struct
.	O
hash_table_size	long
=	O
1021	int
;	O
break	O
;	O
case	O
OPTION_HASH_SIZE	int
:	O
{	O
bfd_size_type	long
new_size	long
;	O
new_size	long
=	O
strtoul	function
(	O
optarg	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
if	O
(	O
new_size	long
)	O
config	struct
.	O
hash_table_size	long
=	O
new_size	long
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%X%P: --hash-size needs a numeric argument\n"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_PUSH_STATE	int
:	O
input_flags	struct
.	O
pushed	pointer
=	O
xmemdup	function
(	O
&	O
input_flags	struct
,	O
sizeof	O
(	O
input_flags	struct
)	O
,	O
sizeof	O
(	O
input_flags	struct
)	O
)	O
;	O
break	O
;	O
case	O
OPTION_POP_STATE	int
:	O
if	O
(	O
input_flags	struct
.	O
pushed	pointer
==	O
NULL	O
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: no state pushed before popping\n"	pointer
)	O
)	O
;	O
else	O
{	O
struct	O
lang_input_statement_flags	struct
*	O
oldp	pointer
=	O
input_flags	struct
.	O
pushed	pointer
;	O
memcpy	function
(	O
&	O
input_flags	struct
,	O
oldp	pointer
,	O
sizeof	O
(	O
input_flags	struct
)	O
)	O
;	O
free	function
(	O
oldp	pointer
)	O
;	O
}	O
break	O
;	O
case	O
OPTION_PRINT_MEMORY_USAGE	int
:	O
command_line	struct
.	O
print_memory_usage	int
=	O
TRUE	int
;	O
break	O
;	O
case	O
OPTION_ORPHAN_HANDLING	int
:	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"place"	pointer
)	O
==	O
0	int
)	O
config	struct
.	O
orphan_handling	enum
=	O
orphan_handling_place	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"warn"	pointer
)	O
==	O
0	int
)	O
config	struct
.	O
orphan_handling	enum
=	O
orphan_handling_warn	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"error"	pointer
)	O
==	O
0	int
)	O
config	struct
.	O
orphan_handling	enum
=	O
orphan_handling_error	int
;	O
else	O
if	O
(	O
strcasecmp	function
(	O
optarg	pointer
,	O
"discard"	pointer
)	O
==	O
0	int
)	O
config	struct
.	O
orphan_handling	enum
=	O
orphan_handling_discard	int
;	O
else	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid argument to option"	pointer
" \"--orphan-handling\"\n"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
OPTION_NO_PRINT_MAP_DISCARDED	int
:	O
config	struct
.	O
print_map_discarded	int
=	O
FALSE	int
;	O
break	O
;	O
case	O
OPTION_PRINT_MAP_DISCARDED	int
:	O
config	struct
.	O
print_map_discarded	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
command_line	struct
.	O
soname	pointer
&&	O
command_line	struct
.	O
soname	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%P: SONAME must not be empty string; ignored\n"	pointer
)	O
)	O
;	O
command_line	struct
.	O
soname	pointer
=	O
NULL	O
;	O
}	O
while	O
(	O
ingroup	int
)	O
{	O
einfo	pointer
(	O
_	O
(	O
"%P: missing --end-group; added as last command line option\n"	pointer
)	O
)	O
;	O
lang_leave_group	function
(	O
)	O
;	O
ingroup	int
--	O
;	O
}	O
if	O
(	O
default_dirlist	pointer
!=	O
NULL	O
)	O
{	O
set_default_dirlist	function
(	O
default_dirlist	pointer
)	O
;	O
free	function
(	O
default_dirlist	pointer
)	O
;	O
}	O
if	O
(	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
==	O
RM_NOT_YET_SET	int
)	O
link_info	struct
.	O
unresolved_syms_in_objects	enum
=	O
how_to_report_unresolved_symbols	enum
;	O
if	O
(	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
==	O
RM_NOT_YET_SET	int
)	O
link_info	struct
.	O
unresolved_syms_in_shared_libs	enum
=	O
how_to_report_unresolved_symbols	enum
;	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
command_line	struct
.	O
check_section_addresses	char
<	O
0	int
)	O
command_line	struct
.	O
check_section_addresses	char
=	O
0	int
;	O
if	O
(	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
)	O
switch	O
(	O
opt_symbolic	enum
)	O
{	O
case	O
symbolic_unset	int
:	O
break	O
;	O
case	O
symbolic	int
:	O
link_info	struct
.	O
symbolic	int
=	O
TRUE	int
;	O
if	O
(	O
link_info	struct
.	O
dynamic_list	pointer
)	O
{	O
struct	O
bfd_elf_version_expr	struct
*	O
ent	pointer
,	O
*	O
next	pointer
;	O
for	O
(	O
ent	pointer
=	O
link_info	struct
.	O
dynamic_list	pointer
->	O
head	pointer
.	O
list	pointer
;	O
ent	pointer
;	O
ent	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
ent	pointer
->	O
next	pointer
;	O
free	function
(	O
ent	pointer
)	O
;	O
}	O
free	function
(	O
link_info	struct
.	O
dynamic_list	pointer
)	O
;	O
link_info	struct
.	O
dynamic_list	pointer
=	O
NULL	O
;	O
}	O
opt_dynamic_list	enum
=	O
dynamic_list_unset	int
;	O
break	O
;	O
case	O
symbolic_functions	int
:	O
opt_dynamic_list	enum
=	O
dynamic_list_data	int
;	O
break	O
;	O
}	O
switch	O
(	O
opt_dynamic_list	enum
)	O
{	O
case	O
dynamic_list_unset	int
:	O
break	O
;	O
case	O
dynamic_list_data	int
:	O
link_info	struct
.	O
dynamic_data	int
=	O
TRUE	int
;	O
case	O
dynamic_list	pointer
:	O
link_info	struct
.	O
dynamic	int
=	O
TRUE	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
bfd_link_dll	O
(	O
&	O
link_info	struct
)	O
)	O
{	O
if	O
(	O
command_line	struct
.	O
filter_shlib	pointer
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: -F may not be used without -shared\n"	pointer
)	O
)	O
;	O
if	O
(	O
command_line	struct
.	O
auxiliary_filters	pointer
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: -f may not be used without -shared\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
bfd_link_relocatable	O
(	O
&	O
link_info	struct
)	O
&&	O
link_info	struct
.	O
strip	enum
==	O
strip_all	int
)	O
{	O
link_info	struct
.	O
strip	enum
=	O
strip_debugger	int
;	O
if	O
(	O
link_info	struct
.	O
discard	enum
==	O
discard_sec_merge	int
)	O
link_info	struct
.	O
discard	enum
=	O
discard_all	int
;	O
}	O
}	O
static	O
void	O
set_default_dirlist	function
(	O
char	O
*	O
dirlist_ptr	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
while	O
(	O
1	int
)	O
{	O
p	pointer
=	O
strchr	function
(	O
dirlist_ptr	pointer
,	O
PATH_SEPARATOR	char
)	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
)	O
*	O
p	pointer
=	O
'\0'	O
;	O
if	O
(	O
*	O
dirlist_ptr	pointer
!=	O
'\0'	O
)	O
ldfile_add_library_path	function
(	O
dirlist_ptr	pointer
,	O
TRUE	int
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
break	O
;	O
dirlist_ptr	pointer
=	O
p	pointer
+	O
1	int
;	O
}	O
}	O
static	O
void	O
set_section_start	function
(	O
char	O
*	O
sect	pointer
,	O
char	O
*	O
valstr	pointer
)	O
{	O
const	O
char	O
*	O
end	pointer
;	O
bfd_vma	long
val	array
=	O
bfd_scan_vma	function
(	O
valstr	pointer
,	O
&	O
end	pointer
,	O
16	int
)	O
;	O
if	O
(	O
*	O
end	pointer
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid hex number `%s'\n"	pointer
)	O
,	O
valstr	pointer
)	O
;	O
lang_section_start	function
(	O
sect	pointer
,	O
exp_intop	function
(	O
val	array
)	O
,	O
NULL	O
)	O
;	O
}	O
static	O
void	O
set_segment_start	function
(	O
const	O
char	O
*	O
section	pointer
,	O
char	O
*	O
valstr	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
end	pointer
;	O
segment_type	struct
*	O
seg	pointer
;	O
bfd_vma	long
val	array
=	O
bfd_scan_vma	function
(	O
valstr	pointer
,	O
&	O
end	pointer
,	O
16	int
)	O
;	O
if	O
(	O
*	O
end	pointer
)	O
einfo	pointer
(	O
_	O
(	O
"%F%P: invalid hex number `%s'\n"	pointer
)	O
,	O
valstr	pointer
)	O
;	O
name	pointer
=	O
section	pointer
+	O
1	int
;	O
for	O
(	O
seg	pointer
=	O
segments	pointer
;	O
seg	pointer
;	O
seg	pointer
=	O
seg	pointer
->	O
next	pointer
)	O
if	O
(	O
strcmp	function
(	O
seg	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
seg	pointer
->	O
value	long
=	O
val	array
;	O
lang_section_start	function
(	O
section	pointer
,	O
exp_intop	function
(	O
val	array
)	O
,	O
seg	pointer
)	O
;	O
return	O
;	O
}	O
seg	pointer
=	O
stat_alloc	function
(	O
sizeof	O
(	O
*	O
seg	pointer
)	O
)	O
;	O
seg	pointer
->	O
name	pointer
=	O
name	pointer
;	O
seg	pointer
->	O
value	long
=	O
val	array
;	O
seg	pointer
->	O
used	int
=	O
FALSE	int
;	O
seg	pointer
->	O
next	pointer
=	O
segments	pointer
;	O
segments	pointer
=	O
seg	pointer
;	O
lang_section_start	function
(	O
section	pointer
,	O
exp_intop	function
(	O
val	array
)	O
,	O
seg	pointer
)	O
;	O
}	O
static	O
void	O
elf_shlib_list_options	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  --audit=AUDITLIB            Specify a library to use for auditing\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -Bgroup                     Selects group name lookup rules for DSO\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  --disable-new-dtags         Disable new dynamic tags\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  --enable-new-dtags          Enable new dynamic tags\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  --eh-frame-hdr              Create .eh_frame_hdr section\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  --no-eh-frame-hdr           Do not create .eh_frame_hdr section\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  --exclude-libs=LIBS         Make all symbols in LIBS hidden\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  --hash-style=STYLE          Set hash style to sysv, gnu or both\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -P AUDITLIB, --depaudit=AUDITLIB\n"	pointer
"                              Specify a library to use for auditing dependencies\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z combreloc                Merge dynamic relocs into one section and sort\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z nocombreloc              Don't merge dynamic relocs into one section\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z global                   Make symbols in DSO available for subsequently\n                               loaded objects\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z initfirst                Mark DSO to be initialized first at runtime\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z interpose                Mark object to interpose all DSOs but executable\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z lazy                     Mark object lazy runtime binding (default)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z loadfltr                 Mark object requiring immediate process\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z nocopyreloc              Don't create copy relocs\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z nodefaultlib             Mark object not to use default search paths\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z nodelete                 Mark DSO non-deletable at runtime\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z nodlopen                 Mark DSO not available to dlopen\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z nodump                   Mark DSO not available to dldump\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z now                      Mark object non-lazy runtime binding\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z origin                   Mark object requiring immediate $ORIGIN\n                                processing at runtime\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z relro                    Create RELRO program header (default)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z norelro                  Don't create RELRO program header\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z separate-code            Create separate code program header (default)\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z noseparate-code          Don't create separate code program header\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z common                   Generate common symbols with STT_COMMON type\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z nocommon                 Generate common symbols with STT_OBJECT type\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z stack-size=SIZE          Set size of stack segment\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z text                     Treat DT_TEXTREL in shared object as error\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z notext                   Don't treat DT_TEXTREL in shared object as error\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z textoff                  Don't treat DT_TEXTREL in shared object as error\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
elf_static_list_options	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  --build-id[=STYLE]          Generate build ID note\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  --compress-debug-sections=[none|zlib|zlib-gnu|zlib-gabi]\n                              Compress DWARF debug sections using zlib\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"                               Default: none\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z common-page-size=SIZE    Set common page size to SIZE\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z max-page-size=SIZE       Set maximum page size to SIZE\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z defs                     Report unresolved symbols in object files\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z muldefs                  Allow multiple definitions\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z execstack                Mark executable as requiring executable stack\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z noexecstack              Mark executable as not requiring executable stack\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  -z globalaudit              Mark executable requiring global auditing\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
elf_plt_unwind_list_options	function
(	O
FILE	struct
*	O
file	pointer
)	O
{	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  --ld-generated-unwind-info  Generate exception handling info for PLT\n"	pointer
)	O
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
_	O
(	O
"  --no-ld-generated-unwind-info\n                              Don't generate exception handling info for PLT\n"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
ld_list_options	function
(	O
FILE	struct
*	O
file	pointer
,	O
bfd_boolean	int
elf	int
,	O
bfd_boolean	int
shlib	int
,	O
bfd_boolean	int
plt_unwind	int
)	O
{	O
if	O
(	O
!	O
elf	int
)	O
return	O
;	O
printf	function
(	O
_	O
(	O
"ELF emulations:\n"	pointer
)	O
)	O
;	O
if	O
(	O
plt_unwind	int
)	O
elf_plt_unwind_list_options	function
(	O
file	pointer
)	O
;	O
elf_static_list_options	function
(	O
file	pointer
)	O
;	O
if	O
(	O
shlib	int
)	O
elf_shlib_list_options	function
(	O
file	pointer
)	O
;	O
}	O
static	O
void	O
help	function
(	O
void	O
)	O
{	O
unsigned	O
i	pointer
;	O
const	O
char	O
*	O
*	O
targets	pointer
,	O
*	O
*	O
pp	pointer
;	O
int	O
len	long
;	O
printf	function
(	O
_	O
(	O
"Usage: %s [options] file...\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"Options:\n"	pointer
)	O
)	O
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
OPTION_COUNT	O
;	O
i	pointer
++	O
)	O
{	O
if	O
(	O
ld_options	array
[	O
i	pointer
]	O
.	O
doc	pointer
!=	O
NULL	O
)	O
{	O
bfd_boolean	int
comma	int
;	O
unsigned	O
j	int
;	O
printf	function
(	O
"  "	pointer
)	O
;	O
comma	int
=	O
FALSE	int
;	O
len	long
=	O
2	int
;	O
j	int
=	O
i	pointer
;	O
do	O
{	O
if	O
(	O
ld_options	array
[	O
j	int
]	O
.	O
shortopt	char
!=	O
'\0'	O
&&	O
ld_options	array
[	O
j	int
]	O
.	O
control	enum
!=	O
NO_HELP	int
)	O
{	O
printf	function
(	O
"%s-%c"	pointer
,	O
comma	int
?	O
", "	pointer
:	O
""	pointer
,	O
ld_options	array
[	O
j	int
]	O
.	O
shortopt	char
)	O
;	O
len	long
+=	O
(	O
comma	int
?	O
2	int
:	O
0	int
)	O
+	O
2	int
;	O
if	O
(	O
ld_options	array
[	O
j	int
]	O
.	O
arg	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
ld_options	array
[	O
j	int
]	O
.	O
opt	struct
.	O
has_arg	int
!=	O
optional_argument	int
)	O
{	O
printf	function
(	O
" "	pointer
)	O
;	O
++	O
len	long
;	O
}	O
printf	function
(	O
"%s"	pointer
,	O
_	O
(	O
ld_options	array
[	O
j	int
]	O
.	O
arg	pointer
)	O
)	O
;	O
len	long
+=	O
strlen	function
(	O
_	O
(	O
ld_options	array
[	O
j	int
]	O
.	O
arg	pointer
)	O
)	O
;	O
}	O
comma	int
=	O
TRUE	int
;	O
}	O
++	O
j	int
;	O
}	O
while	O
(	O
j	int
<	O
OPTION_COUNT	O
&&	O
ld_options	array
[	O
j	int
]	O
.	O
doc	pointer
==	O
NULL	O
)	O
;	O
j	int
=	O
i	pointer
;	O
do	O
{	O
if	O
(	O
ld_options	array
[	O
j	int
]	O
.	O
opt	struct
.	O
name	pointer
!=	O
NULL	O
&&	O
ld_options	array
[	O
j	int
]	O
.	O
control	enum
!=	O
NO_HELP	int
)	O
{	O
int	O
two_dashes	int
=	O
(	O
ld_options	array
[	O
j	int
]	O
.	O
control	enum
==	O
TWO_DASHES	int
||	O
ld_options	array
[	O
j	int
]	O
.	O
control	enum
==	O
EXACTLY_TWO_DASHES	int
)	O
;	O
printf	function
(	O
"%s-%s%s"	pointer
,	O
comma	int
?	O
", "	pointer
:	O
""	pointer
,	O
two_dashes	int
?	O
"-"	pointer
:	O
""	pointer
,	O
ld_options	array
[	O
j	int
]	O
.	O
opt	struct
.	O
name	pointer
)	O
;	O
len	long
+=	O
(	O
(	O
comma	int
?	O
2	int
:	O
0	int
)	O
+	O
1	int
+	O
(	O
two_dashes	int
?	O
1	int
:	O
0	int
)	O
+	O
strlen	function
(	O
ld_options	array
[	O
j	int
]	O
.	O
opt	struct
.	O
name	pointer
)	O
)	O
;	O
if	O
(	O
ld_options	array
[	O
j	int
]	O
.	O
arg	pointer
!=	O
NULL	O
)	O
{	O
printf	function
(	O
" %s"	pointer
,	O
_	O
(	O
ld_options	array
[	O
j	int
]	O
.	O
arg	pointer
)	O
)	O
;	O
len	long
+=	O
1	int
+	O
strlen	function
(	O
_	O
(	O
ld_options	array
[	O
j	int
]	O
.	O
arg	pointer
)	O
)	O
;	O
}	O
comma	int
=	O
TRUE	int
;	O
}	O
++	O
j	int
;	O
}	O
while	O
(	O
j	int
<	O
OPTION_COUNT	O
&&	O
ld_options	array
[	O
j	int
]	O
.	O
doc	pointer
==	O
NULL	O
)	O
;	O
if	O
(	O
len	long
>=	O
30	int
)	O
{	O
printf	function
(	O
"\n"	pointer
)	O
;	O
len	long
=	O
0	int
;	O
}	O
for	O
(	O
;	O
len	long
<	O
30	int
;	O
len	long
++	O
)	O
putchar	function
(	O
' '	O
)	O
;	O
printf	function
(	O
"%s\n"	pointer
,	O
_	O
(	O
ld_options	array
[	O
i	pointer
]	O
.	O
doc	pointer
)	O
)	O
;	O
}	O
}	O
printf	function
(	O
_	O
(	O
"  @FILE"	pointer
)	O
)	O
;	O
for	O
(	O
len	long
=	O
strlen	function
(	O
"  @FILE"	pointer
)	O
;	O
len	long
<	O
30	int
;	O
len	long
++	O
)	O
putchar	function
(	O
' '	O
)	O
;	O
printf	function
(	O
_	O
(	O
"Read options from FILE\n"	pointer
)	O
)	O
;	O
printf	function
(	O
_	O
(	O
"%s: supported targets:"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
targets	pointer
=	O
bfd_target_list	function
(	O
)	O
;	O
for	O
(	O
pp	pointer
=	O
targets	pointer
;	O
*	O
pp	pointer
!=	O
NULL	O
;	O
pp	pointer
++	O
)	O
printf	function
(	O
" %s"	pointer
,	O
*	O
pp	pointer
)	O
;	O
free	function
(	O
targets	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"%s: supported emulations: "	pointer
)	O
,	O
program_name	pointer
)	O
;	O
ldemul_list_emulations	function
(	O
stdout	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
_	O
(	O
"%s: emulation specific options:\n"	pointer
)	O
,	O
program_name	pointer
)	O
;	O
ld_list_options	function
(	O
stdout	pointer
,	O
ELF_LIST_OPTIONS	O
,	O
ELF_SHLIB_LIST_OPTIONS	O
,	O
ELF_PLT_UNWIND_LIST_OPTIONS	O
)	O
;	O
ldemul_list_emulation_options	function
(	O
stdout	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
if	O
(	O
REPORT_BUGS_TO	pointer
[	O
0	int
]	O
)	O
printf	function
(	O
_	O
(	O
"Report bugs to %s\n"	pointer
)	O
,	O
REPORT_BUGS_TO	pointer
)	O
;	O
}	O
