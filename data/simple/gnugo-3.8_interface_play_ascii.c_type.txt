static	O
int	O
opt_showboard	int
=	O
1	int
;	O
static	O
int	O
showdead	int
=	O
0	int
;	O
static	O
SGFTree	struct
sgftree	struct
;	O
static	O
int	O
resignation_allowed	int
;	O
static	O
int	O
clock_on	int
=	O
0	int
;	O
static	O
int	O
current_score_estimate	int
=	O
NO_SCORE	int
;	O
static	O
void	O
do_play_ascii	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
)	O
;	O
static	O
int	O
ascii_endgame	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
,	O
int	O
reason	int
)	O
;	O
static	O
void	O
ascii_count	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
)	O
;	O
static	O
void	O
showcapture	function
(	O
char	O
*	O
line	int
)	O
;	O
static	O
void	O
showdefense	function
(	O
char	O
*	O
line	int
)	O
;	O
static	O
void	O
ascii_goto	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
,	O
char	O
*	O
line	int
)	O
;	O
static	O
void	O
ascii_free_handicap	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
,	O
char	O
*	O
handicap_string	pointer
)	O
;	O
static	O
int	O
sgf_initialized	int
;	O
static	O
void	O
make_letterbar	function
(	O
int	O
boardsize	int
,	O
char	O
*	O
letterbar	pointer
)	O
{	O
int	O
i	int
,	O
letteroffset	int
;	O
char	O
spaces	array
[	O
64	int
]	O
;	O
char	O
letter	array
[	O
64	int
]	O
;	O
if	O
(	O
boardsize	int
<=	O
25	int
)	O
strcpy	function
(	O
spaces	array
,	O
" "	pointer
)	O
;	O
strcpy	function
(	O
letterbar	pointer
,	O
"   "	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
boardsize	int
;	O
i	int
++	O
)	O
{	O
letteroffset	int
=	O
'A'	O
;	O
if	O
(	O
i	int
+	O
letteroffset	int
>=	O
'I'	O
)	O
letteroffset	int
++	O
;	O
strcat	function
(	O
letterbar	pointer
,	O
spaces	array
)	O
;	O
sprintf	function
(	O
letter	array
,	O
"%c"	pointer
,	O
i	int
+	O
letteroffset	int
)	O
;	O
strcat	function
(	O
letterbar	pointer
,	O
letter	array
)	O
;	O
}	O
}	O
static	O
int	O
hspot_size	int
;	O
static	O
char	O
hspots	array
[	O
MAX_BOARD	int
]	O
[	O
MAX_BOARD	int
]	O
;	O
static	O
void	O
set_handicap_spots	function
(	O
int	O
boardsize	int
)	O
{	O
if	O
(	O
hspot_size	int
==	O
boardsize	int
)	O
return	O
;	O
hspot_size	int
=	O
boardsize	int
;	O
memset	function
(	O
hspots	array
,	O
'.'	O
,	O
sizeof	O
(	O
hspots	array
)	O
)	O
;	O
if	O
(	O
boardsize	int
==	O
5	int
)	O
{	O
hspots	array
[	O
1	int
]	O
[	O
1	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
-	O
2	int
]	O
[	O
1	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
1	int
]	O
[	O
boardsize	int
-	O
2	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
-	O
2	int
]	O
[	O
boardsize	int
-	O
2	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
/	O
2	int
]	O
[	O
boardsize	int
/	O
2	int
]	O
=	O
'+'	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
(	O
boardsize	int
%	O
2	int
)	O
)	O
{	O
if	O
(	O
boardsize	int
>	O
2	int
&&	O
boardsize	int
<	O
12	int
)	O
{	O
hspots	array
[	O
2	int
]	O
[	O
2	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
-	O
3	int
]	O
[	O
2	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
2	int
]	O
[	O
boardsize	int
-	O
3	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
-	O
3	int
]	O
[	O
boardsize	int
-	O
3	int
]	O
=	O
'+'	O
;	O
}	O
else	O
{	O
hspots	array
[	O
3	int
]	O
[	O
3	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
-	O
4	int
]	O
[	O
3	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
3	int
]	O
[	O
boardsize	int
-	O
4	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
-	O
4	int
]	O
[	O
boardsize	int
-	O
4	int
]	O
=	O
'+'	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
boardsize	int
>	O
2	int
&&	O
boardsize	int
<	O
12	int
)	O
{	O
hspots	array
[	O
2	int
]	O
[	O
2	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
-	O
3	int
]	O
[	O
2	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
2	int
]	O
[	O
boardsize	int
-	O
3	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
-	O
3	int
]	O
[	O
boardsize	int
-	O
3	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
/	O
2	int
]	O
[	O
boardsize	int
/	O
2	int
]	O
=	O
'+'	O
;	O
}	O
else	O
if	O
(	O
boardsize	int
>	O
12	int
)	O
{	O
hspots	array
[	O
3	int
]	O
[	O
3	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
-	O
4	int
]	O
[	O
3	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
3	int
]	O
[	O
boardsize	int
-	O
4	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
-	O
4	int
]	O
[	O
boardsize	int
-	O
4	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
3	int
]	O
[	O
boardsize	int
/	O
2	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
/	O
2	int
]	O
[	O
3	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
/	O
2	int
]	O
[	O
boardsize	int
-	O
4	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
-	O
4	int
]	O
[	O
boardsize	int
/	O
2	int
]	O
=	O
'+'	O
;	O
hspots	array
[	O
boardsize	int
/	O
2	int
]	O
[	O
boardsize	int
/	O
2	int
]	O
=	O
'+'	O
;	O
}	O
}	O
return	O
;	O
}	O
static	O
void	O
ascii_showboard	function
(	O
void	O
)	O
{	O
int	O
i	int
,	O
j	int
;	O
char	O
letterbar	pointer
[	O
64	int
]	O
;	O
int	O
last_pos_was_move	int
;	O
int	O
pos_is_move	int
;	O
int	O
dead	int
;	O
int	O
last_move	int
=	O
get_last_move	function
(	O
)	O
;	O
make_letterbar	function
(	O
board_size	int
,	O
letterbar	pointer
)	O
;	O
set_handicap_spots	function
(	O
board_size	int
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
printf	function
(	O
"    White (O) has captured %d pieces\n"	pointer
,	O
black_captured	int
)	O
;	O
printf	function
(	O
"    Black (X) has captured %d pieces\n"	pointer
,	O
white_captured	int
)	O
;	O
if	O
(	O
showscore	int
)	O
{	O
if	O
(	O
current_score_estimate	int
==	O
NO_SCORE	int
)	O
printf	function
(	O
"    No score estimate is available yet.\n"	pointer
)	O
;	O
else	O
if	O
(	O
current_score_estimate	int
<	O
0	int
)	O
printf	function
(	O
"    Estimated score: Black is ahead by %d\n"	pointer
,	O
-	O
current_score_estimate	int
)	O
;	O
else	O
if	O
(	O
current_score_estimate	int
>	O
0	int
)	O
printf	function
(	O
"    Estimated score: White is ahead by %d\n"	pointer
,	O
current_score_estimate	int
)	O
;	O
else	O
printf	function
(	O
"    Estimated score: Even!\n"	pointer
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
printf	function
(	O
"%s"	pointer
,	O
letterbar	pointer
)	O
;	O
if	O
(	O
get_last_player	function
(	O
)	O
!=	O
EMPTY	int
)	O
{	O
gfprintf	function
(	O
stdout	pointer
,	O
"        Last move: %s %1m"	pointer
,	O
get_last_player	function
(	O
)	O
==	O
WHITE	int
?	O
"White"	pointer
:	O
"Black"	pointer
,	O
last_move	int
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
printf	function
(	O
" %2d"	pointer
,	O
board_size	int
-	O
i	int
)	O
;	O
last_pos_was_move	int
=	O
0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
==	O
last_move	int
)	O
pos_is_move	int
=	O
128	int
;	O
else	O
pos_is_move	int
=	O
0	int
;	O
dead	int
=	O
(	O
dragon_status	function
(	O
POS	O
(	O
i	int
,	O
j	int
)	O
)	O
==	O
DEAD	int
)	O
&&	O
showdead	int
;	O
switch	O
(	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
+	O
pos_is_move	int
+	O
last_pos_was_move	int
)	O
{	O
case	O
EMPTY	int
+	O
128	int
:	O
case	O
EMPTY	int
:	O
printf	function
(	O
" %c"	pointer
,	O
hspots	array
[	O
i	int
]	O
[	O
j	int
]	O
)	O
;	O
last_pos_was_move	int
=	O
0	int
;	O
break	O
;	O
case	O
BLACK	int
:	O
printf	function
(	O
" %c"	pointer
,	O
dead	int
?	O
'x'	O
:	O
'X'	O
)	O
;	O
last_pos_was_move	int
=	O
0	int
;	O
break	O
;	O
case	O
WHITE	int
:	O
printf	function
(	O
" %c"	pointer
,	O
dead	int
?	O
'o'	O
:	O
'O'	O
)	O
;	O
last_pos_was_move	int
=	O
0	int
;	O
break	O
;	O
case	O
BLACK	int
+	O
128	int
:	O
printf	function
(	O
"(%c)"	pointer
,	O
'X'	O
)	O
;	O
last_pos_was_move	int
=	O
256	int
;	O
break	O
;	O
case	O
WHITE	int
+	O
128	int
:	O
printf	function
(	O
"(%c)"	pointer
,	O
'O'	O
)	O
;	O
last_pos_was_move	int
=	O
256	int
;	O
break	O
;	O
case	O
EMPTY	int
+	O
256	int
:	O
printf	function
(	O
"%c"	pointer
,	O
hspots	array
[	O
i	int
]	O
[	O
j	int
]	O
)	O
;	O
last_pos_was_move	int
=	O
0	int
;	O
break	O
;	O
case	O
BLACK	int
+	O
256	int
:	O
printf	function
(	O
"%c"	pointer
,	O
dead	int
?	O
'x'	O
:	O
'X'	O
)	O
;	O
last_pos_was_move	int
=	O
0	int
;	O
break	O
;	O
case	O
WHITE	int
+	O
256	int
:	O
printf	function
(	O
"%c"	pointer
,	O
dead	int
?	O
'o'	O
:	O
'O'	O
)	O
;	O
last_pos_was_move	int
=	O
0	int
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Illegal board value %d\n"	pointer
,	O
(	O
int	O
)	O
BOARD	O
(	O
i	int
,	O
j	int
)	O
)	O
;	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
last_pos_was_move	int
==	O
0	int
)	O
{	O
if	O
(	O
board_size	int
>	O
10	int
)	O
printf	function
(	O
" %2d"	pointer
,	O
board_size	int
-	O
i	int
)	O
;	O
else	O
printf	function
(	O
" %1d"	pointer
,	O
board_size	int
-	O
i	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
board_size	int
>	O
10	int
)	O
printf	function
(	O
"%2d"	pointer
,	O
board_size	int
-	O
i	int
)	O
;	O
else	O
printf	function
(	O
"%1d"	pointer
,	O
board_size	int
-	O
i	int
)	O
;	O
}	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
fflush	function
(	O
stdout	pointer
)	O
;	O
printf	function
(	O
"%s\n\n"	pointer
,	O
letterbar	pointer
)	O
;	O
fflush	function
(	O
stdout	pointer
)	O
;	O
if	O
(	O
clock_on	int
)	O
{	O
clock_print	function
(	O
WHITE	int
)	O
;	O
clock_print	function
(	O
BLACK	int
)	O
;	O
}	O
}	O
static	O
void	O
show_commands	function
(	O
void	O
)	O
{	O
printf	function
(	O
"\nCommands:\n"	pointer
)	O
;	O
printf	function
(	O
" back                Take back your last move\n"	pointer
)	O
;	O
printf	function
(	O
" boardsize           Set boardsize (on move 1 only)\n"	pointer
)	O
;	O
printf	function
(	O
" comment             Write a comment to outputfile\n"	pointer
)	O
;	O
printf	function
(	O
" depth <num>         Set depth for reading\n"	pointer
)	O
;	O
printf	function
(	O
" display             Display game board\n"	pointer
)	O
;	O
printf	function
(	O
" exit                Exit GNU Go\n"	pointer
)	O
;	O
printf	function
(	O
" force <move>        Force a move for current color\n"	pointer
)	O
;	O
printf	function
(	O
" forward             Go to next node in game tree\n"	pointer
)	O
;	O
printf	function
(	O
" goto <movenum>      Go to movenum in game tree\n"	pointer
)	O
;	O
printf	function
(	O
" level <amount>      Playing level (default = 10)\n"	pointer
)	O
;	O
printf	function
(	O
" handicap <num>      Set fixed handicap (on move 1 only)\n"	pointer
)	O
;	O
printf	function
(	O
" freehandicap <num>  Place free handicap (on move 1 only)\n"	pointer
)	O
;	O
printf	function
(	O
"                     Omit <num> to place handicap yourself\n"	pointer
)	O
;	O
printf	function
(	O
" help                Display this help menu\n"	pointer
)	O
;	O
printf	function
(	O
" helpdebug           Display debug help menu\n"	pointer
)	O
;	O
printf	function
(	O
" info                Display program settings\n"	pointer
)	O
;	O
printf	function
(	O
" komi                Set komi (on move 1 only)\n"	pointer
)	O
;	O
printf	function
(	O
" last                Goto last node in game tree\n"	pointer
)	O
;	O
printf	function
(	O
" pass                Pass on your move\n"	pointer
)	O
;	O
printf	function
(	O
" play <num>          Play <num> moves\n"	pointer
)	O
;	O
printf	function
(	O
" playblack           Play as Black (switch if White)\n"	pointer
)	O
;	O
printf	function
(	O
" playwhite           Play as White (switch if Black)\n"	pointer
)	O
;	O
printf	function
(	O
" quit                Exit GNU Go\n"	pointer
)	O
;	O
printf	function
(	O
" resign              Resign the current game\n"	pointer
)	O
;	O
printf	function
(	O
" save <file>         Save the current game\n"	pointer
)	O
;	O
printf	function
(	O
" load <file>         Load a game from file\n"	pointer
)	O
;	O
printf	function
(	O
" score               Toggle display of score On/Off\n"	pointer
)	O
;	O
printf	function
(	O
" showboard           Toggle display of board On/Off\n"	pointer
)	O
;	O
printf	function
(	O
" switch              Switch the color you are playing\n"	pointer
)	O
;	O
printf	function
(	O
" undo                Take the last move back (same as back)\n"	pointer
)	O
;	O
printf	function
(	O
" <move>              A move of the format <letter><number>"	pointer
)	O
;	O
printf	function
(	O
"\n"	pointer
)	O
;	O
}	O
enum	O
commands	enum
{	O
INVALID	int
=	O
-	O
1	int
,	O
END	int
,	O
EXIT	int
,	O
QUIT	int
,	O
RESIGN	int
,	O
PASS	int
,	O
MOVE	int
,	O
FORCE	int
,	O
SWITCH	int
,	O
PLAY	int
,	O
PLAYBLACK	int
,	O
PLAYWHITE	int
,	O
SETHANDICAP	int
,	O
FREEHANDICAP	int
,	O
SETBOARDSIZE	int
,	O
SETKOMI	int
,	O
SETDEPTH	int
,	O
INFO	int
,	O
DISPLAY	int
,	O
SHOWBOARD	int
,	O
HELP	int
,	O
UNDO	int
,	O
COMMENT	int
,	O
SCORE	int
,	O
CMD_DEAD	int
,	O
CMD_BACK	int
,	O
CMD_FORWARD	int
,	O
CMD_LAST	int
,	O
CMD_CAPTURE	int
,	O
CMD_DEFEND	int
,	O
CMD_HELPDEBUG	int
,	O
CMD_SHOWAREA	int
,	O
CMD_SHOWMOYO	int
,	O
CMD_SHOWTERRI	int
,	O
CMD_GOTO	int
,	O
CMD_SAVE	int
,	O
CMD_LOAD	int
,	O
CMD_SHOWDRAGONS	int
,	O
CMD_LISTDRAGONS	int
,	O
SETLEVEL	int
,	O
NEW	int
,	O
COUNT	int
,	O
CONTINUE	int
}	O
;	O
static	O
int	O
get_command	function
(	O
char	O
*	O
command	pointer
)	O
{	O
char	O
c	char
;	O
int	O
d	int
;	O
if	O
(	O
!	O
(	O
(	O
sscanf	function
(	O
command	pointer
,	O
"%c%d"	pointer
,	O
&	O
c	char
,	O
&	O
d	int
)	O
!=	O
2	int
)	O
||	O
(	O
(	O
c	char
=	O
toupper	function
(	O
(	O
int	O
)	O
c	char
)	O
)	O
<	O
'A'	O
)	O
||	O
(	O
(	O
c	char
=	O
toupper	function
(	O
(	O
int	O
)	O
c	char
)	O
)	O
>	O
'Z'	O
)	O
||	O
(	O
c	char
==	O
'I'	O
)	O
)	O
)	O
return	O
MOVE	int
;	O
if	O
(	O
command	pointer
[	O
0	int
]	O
==	O
'?'	O
)	O
return	O
HELP	int
;	O
while	O
(	O
command	pointer
[	O
0	int
]	O
==	O
' '	O
)	O
command	pointer
++	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"playblack"	pointer
,	O
9	int
)	O
)	O
return	O
PLAYBLACK	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"playwhite"	pointer
,	O
9	int
)	O
)	O
return	O
PLAYWHITE	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"showboard"	pointer
,	O
9	int
)	O
)	O
return	O
SHOWBOARD	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"showdragons"	pointer
,	O
9	int
)	O
)	O
return	O
CMD_SHOWDRAGONS	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"listdragons"	pointer
,	O
9	int
)	O
)	O
return	O
CMD_LISTDRAGONS	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"boardsize"	pointer
,	O
9	int
)	O
)	O
return	O
SETBOARDSIZE	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"freehandicap"	pointer
,	O
9	int
)	O
)	O
return	O
FREEHANDICAP	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"handicap"	pointer
,	O
5	int
)	O
)	O
return	O
SETHANDICAP	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"display"	pointer
,	O
7	int
)	O
)	O
return	O
DISPLAY	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"helpdebug"	pointer
,	O
7	int
)	O
)	O
return	O
CMD_HELPDEBUG	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"resign"	pointer
,	O
6	int
)	O
)	O
return	O
RESIGN	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"showmoyo"	pointer
,	O
6	int
)	O
)	O
return	O
CMD_SHOWMOYO	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"showterri"	pointer
,	O
6	int
)	O
)	O
return	O
CMD_SHOWTERRI	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"showarea"	pointer
,	O
6	int
)	O
)	O
return	O
CMD_SHOWAREA	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"depth"	pointer
,	O
5	int
)	O
)	O
return	O
SETDEPTH	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"switch"	pointer
,	O
5	int
)	O
)	O
return	O
SWITCH	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"komi"	pointer
,	O
4	int
)	O
)	O
return	O
SETKOMI	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"play"	pointer
,	O
4	int
)	O
)	O
return	O
PLAY	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"info"	pointer
,	O
4	int
)	O
)	O
return	O
INFO	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"force"	pointer
,	O
4	int
)	O
)	O
return	O
FORCE	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"level"	pointer
,	O
5	int
)	O
)	O
return	O
SETLEVEL	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"pass"	pointer
,	O
4	int
)	O
)	O
return	O
PASS	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"save"	pointer
,	O
3	int
)	O
)	O
return	O
CMD_SAVE	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"load"	pointer
,	O
3	int
)	O
)	O
return	O
CMD_LOAD	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"end"	pointer
,	O
3	int
)	O
)	O
return	O
END	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"move"	pointer
,	O
3	int
)	O
)	O
return	O
MOVE	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"undo"	pointer
,	O
3	int
)	O
)	O
return	O
UNDO	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"comment"	pointer
,	O
3	int
)	O
)	O
return	O
COMMENT	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"score"	pointer
,	O
3	int
)	O
)	O
return	O
SCORE	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"dead"	pointer
,	O
3	int
)	O
)	O
return	O
CMD_DEAD	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"capture"	pointer
,	O
3	int
)	O
)	O
return	O
CMD_CAPTURE	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"defend"	pointer
,	O
3	int
)	O
)	O
return	O
CMD_DEFEND	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"exit"	pointer
,	O
4	int
)	O
)	O
return	O
EXIT	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"quit"	pointer
,	O
4	int
)	O
)	O
return	O
QUIT	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"help"	pointer
,	O
1	int
)	O
)	O
return	O
HELP	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"back"	pointer
,	O
2	int
)	O
)	O
return	O
CMD_BACK	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"forward"	pointer
,	O
2	int
)	O
)	O
return	O
CMD_FORWARD	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"last"	pointer
,	O
2	int
)	O
)	O
return	O
CMD_LAST	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"goto"	pointer
,	O
2	int
)	O
)	O
return	O
CMD_GOTO	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"game"	pointer
,	O
2	int
)	O
)	O
return	O
NEW	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"count"	pointer
,	O
3	int
)	O
)	O
return	O
COUNT	int
;	O
if	O
(	O
!	O
strncmp	function
(	O
command	pointer
,	O
"continue"	pointer
,	O
4	int
)	O
)	O
return	O
CONTINUE	int
;	O
return	O
INVALID	int
;	O
}	O
static	O
void	O
init_sgf	function
(	O
Gameinfo	struct
*	O
ginfo	pointer
)	O
{	O
if	O
(	O
sgf_initialized	int
)	O
return	O
;	O
sgf_initialized	int
=	O
1	int
;	O
sgf_write_header	function
(	O
sgftree	struct
.	O
root	pointer
,	O
1	int
,	O
get_random_seed	function
(	O
)	O
,	O
komi	float
,	O
ginfo	pointer
->	O
handicap	int
,	O
get_level	function
(	O
)	O
,	O
chinese_rules	int
)	O
;	O
if	O
(	O
ginfo	pointer
->	O
handicap	int
>	O
0	int
)	O
sgffile_recordboard	function
(	O
sgftree	struct
.	O
root	pointer
)	O
;	O
}	O
static	O
int	O
computer_move	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
,	O
int	O
*	O
passes	pointer
)	O
{	O
int	O
move	pointer
;	O
float	O
move_value	pointer
;	O
int	O
resign	pointer
;	O
int	O
resignation_declined	int
=	O
0	int
;	O
float	O
upper_bound	float
,	O
lower_bound	float
;	O
init_sgf	function
(	O
gameinfo	pointer
)	O
;	O
if	O
(	O
autolevel_on	int
)	O
adjust_level_offset	function
(	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
move	pointer
=	O
genmove	function
(	O
gameinfo	pointer
->	O
to_move	int
,	O
&	O
move_value	pointer
,	O
&	O
resign	pointer
)	O
;	O
if	O
(	O
resignation_allowed	int
&&	O
resign	pointer
)	O
{	O
int	O
state	pointer
=	O
ascii_endgame	function
(	O
gameinfo	pointer
,	O
2	int
)	O
;	O
if	O
(	O
state	pointer
!=	O
-	O
1	int
)	O
return	O
state	pointer
;	O
resignation_allowed	int
=	O
0	int
;	O
resignation_declined	int
=	O
1	int
;	O
}	O
if	O
(	O
showscore	int
)	O
{	O
gnugo_estimate_score	function
(	O
&	O
upper_bound	float
,	O
&	O
lower_bound	float
)	O
;	O
current_score_estimate	int
=	O
(	O
int	O
)	O
(	O
(	O
lower_bound	float
+	O
upper_bound	float
)	O
/	O
2.0	int
)	O
;	O
}	O
mprintf	function
(	O
"%s(%d): %1m\n"	pointer
,	O
color_to_string	function
(	O
gameinfo	pointer
->	O
to_move	int
)	O
,	O
movenum	int
+	O
1	int
,	O
move	pointer
)	O
;	O
if	O
(	O
is_pass	function
(	O
move	pointer
)	O
)	O
(	O
*	O
passes	pointer
)	O
++	O
;	O
else	O
*	O
passes	pointer
=	O
0	int
;	O
gnugo_play_move	function
(	O
move	pointer
,	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
sgffile_add_debuginfo	function
(	O
sgftree	struct
.	O
lastnode	pointer
,	O
move_value	pointer
)	O
;	O
sgftreeAddPlay	function
(	O
&	O
sgftree	struct
,	O
gameinfo	pointer
->	O
to_move	int
,	O
I	O
(	O
move	pointer
)	O
,	O
J	O
(	O
move	pointer
)	O
)	O
;	O
if	O
(	O
resignation_declined	int
)	O
sgftreeAddComment	function
(	O
&	O
sgftree	struct
,	O
"GNU Go resignation was declined"	pointer
)	O
;	O
sgffile_output	function
(	O
&	O
sgftree	struct
)	O
;	O
gameinfo	pointer
->	O
to_move	int
=	O
OTHER_COLOR	O
(	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
do_move	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
,	O
char	O
*	O
command	pointer
,	O
int	O
*	O
passes	pointer
,	O
int	O
force	int
)	O
{	O
int	O
move	pointer
=	O
string_to_location	function
(	O
board_size	int
,	O
command	pointer
)	O
;	O
if	O
(	O
move	pointer
==	O
NO_MOVE	O
)	O
{	O
printf	function
(	O
"\nInvalid move: %s\n"	pointer
,	O
command	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
is_allowed_move	function
(	O
move	pointer
,	O
gameinfo	pointer
->	O
to_move	int
)	O
)	O
{	O
printf	function
(	O
"\nIllegal move: %s"	pointer
,	O
command	pointer
)	O
;	O
return	O
0	int
;	O
}	O
*	O
passes	pointer
=	O
0	int
;	O
TRACE	O
(	O
"\nyour move: %1m\n\n"	pointer
,	O
move	pointer
)	O
;	O
init_sgf	function
(	O
gameinfo	pointer
)	O
;	O
gnugo_play_move	function
(	O
move	pointer
,	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
sgffile_add_debuginfo	function
(	O
sgftree	struct
.	O
lastnode	pointer
,	O
0.0	int
)	O
;	O
sgftreeAddPlay	function
(	O
&	O
sgftree	struct
,	O
gameinfo	pointer
->	O
to_move	int
,	O
I	O
(	O
move	pointer
)	O
,	O
J	O
(	O
move	pointer
)	O
)	O
;	O
sgffile_output	function
(	O
&	O
sgftree	struct
)	O
;	O
if	O
(	O
opt_showboard	int
)	O
{	O
ascii_showboard	function
(	O
)	O
;	O
printf	function
(	O
"GNU Go is thinking...\n"	pointer
)	O
;	O
}	O
if	O
(	O
force	int
)	O
{	O
gameinfo	pointer
->	O
computer_player	int
=	O
OTHER_COLOR	O
(	O
gameinfo	pointer
->	O
computer_player	int
)	O
;	O
gameinfo	pointer
->	O
to_move	int
=	O
OTHER_COLOR	O
(	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
sgftreeAddComment	function
(	O
&	O
sgftree	struct
,	O
"forced"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
gameinfo	pointer
->	O
to_move	int
=	O
OTHER_COLOR	O
(	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
return	O
computer_move	function
(	O
gameinfo	pointer
,	O
passes	pointer
)	O
;	O
}	O
static	O
int	O
do_pass	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
,	O
int	O
*	O
passes	pointer
,	O
int	O
force	int
)	O
{	O
(	O
*	O
passes	pointer
)	O
++	O
;	O
init_sgf	function
(	O
gameinfo	pointer
)	O
;	O
gnugo_play_move	function
(	O
PASS_MOVE	int
,	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
sgffile_add_debuginfo	function
(	O
sgftree	struct
.	O
lastnode	pointer
,	O
0.0	int
)	O
;	O
sgftreeAddPlay	function
(	O
&	O
sgftree	struct
,	O
gameinfo	pointer
->	O
to_move	int
,	O
-	O
1	int
,	O
-	O
1	int
)	O
;	O
sgffile_output	function
(	O
&	O
sgftree	struct
)	O
;	O
gameinfo	pointer
->	O
to_move	int
=	O
OTHER_COLOR	O
(	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
if	O
(	O
force	int
)	O
{	O
gameinfo	pointer
->	O
computer_player	int
=	O
OTHER_COLOR	O
(	O
gameinfo	pointer
->	O
computer_player	int
)	O
;	O
sgftreeAddComment	function
(	O
&	O
sgftree	struct
,	O
"forced"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
return	O
computer_move	function
(	O
gameinfo	pointer
,	O
passes	pointer
)	O
;	O
}	O
void	O
play_ascii	function
(	O
SGFTree	struct
*	O
tree	pointer
,	O
Gameinfo	struct
*	O
gameinfo	pointer
,	O
char	O
*	O
filename	pointer
,	O
char	O
*	O
until	pointer
)	O
{	O
int	O
sz	int
;	O
setvbuf	function
(	O
stdout	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
_IONBF	int
,	O
0	int
)	O
;	O
sgftree	struct
=	O
*	O
tree	pointer
;	O
if	O
(	O
filename	pointer
)	O
{	O
gameinfo_play_sgftree	function
(	O
gameinfo	pointer
,	O
&	O
sgftree	struct
,	O
until	pointer
)	O
;	O
sgf_initialized	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
sgfGetIntProperty	function
(	O
sgftree	struct
.	O
root	pointer
,	O
"SZ"	pointer
,	O
&	O
sz	int
)	O
)	O
gnugo_clear_board	function
(	O
sz	int
)	O
;	O
if	O
(	O
gameinfo	pointer
->	O
handicap	int
==	O
0	int
)	O
gameinfo	pointer
->	O
to_move	int
=	O
BLACK	int
;	O
else	O
{	O
gameinfo	pointer
->	O
handicap	int
=	O
place_fixed_handicap	function
(	O
gameinfo	pointer
->	O
handicap	int
)	O
;	O
gameinfo	pointer
->	O
to_move	int
=	O
WHITE	int
;	O
}	O
sgf_initialized	int
=	O
0	int
;	O
}	O
do_play_ascii	function
(	O
gameinfo	pointer
)	O
;	O
printf	function
(	O
"\nThanks! for playing GNU Go.\n\n"	pointer
)	O
;	O
*	O
tree	pointer
=	O
sgftree	struct
;	O
}	O
void	O
do_play_ascii	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
)	O
{	O
int	O
m	int
,	O
num	int
;	O
float	O
fnum	float
;	O
int	O
passes	pointer
=	O
0	int
;	O
int	O
tmp	int
;	O
char	O
line	int
[	O
80	int
]	O
;	O
char	O
*	O
line_ptr	pointer
=	O
line	int
;	O
char	O
*	O
command	pointer
;	O
char	O
*	O
tmpstring	pointer
;	O
int	O
state	pointer
=	O
1	int
;	O
if	O
(	O
have_time_settings	function
(	O
)	O
)	O
clock_on	int
=	O
1	int
;	O
while	O
(	O
state	pointer
==	O
1	int
)	O
{	O
state	pointer
=	O
0	int
;	O
current_score_estimate	int
=	O
NO_SCORE	int
;	O
resignation_allowed	int
=	O
1	int
;	O
printf	function
(	O
"\nBeginning ASCII mode game.\n\n"	pointer
)	O
;	O
gameinfo_print	function
(	O
gameinfo	pointer
)	O
;	O
if	O
(	O
gameinfo	pointer
->	O
computer_player	int
==	O
gameinfo	pointer
->	O
to_move	int
)	O
state	pointer
=	O
computer_move	function
(	O
gameinfo	pointer
,	O
&	O
passes	pointer
)	O
;	O
while	O
(	O
state	pointer
==	O
0	int
)	O
{	O
if	O
(	O
opt_showboard	int
)	O
ascii_showboard	function
(	O
)	O
;	O
mprintf	function
(	O
"%s(%d): "	pointer
,	O
color_to_string	function
(	O
gameinfo	pointer
->	O
to_move	int
)	O
,	O
movenum	int
+	O
1	int
)	O
;	O
line_ptr	pointer
=	O
line	int
;	O
if	O
(	O
!	O
fgets	function
(	O
line	int
,	O
80	int
,	O
stdin	pointer
)	O
)	O
return	O
;	O
while	O
(	O
state	pointer
==	O
0	int
&&	O
(	O
command	pointer
=	O
strtok	function
(	O
line_ptr	pointer
,	O
";"	pointer
)	O
,	O
line_ptr	pointer
=	O
0	int
,	O
command	pointer
)	O
)	O
{	O
switch	O
(	O
get_command	function
(	O
command	pointer
)	O
)	O
{	O
case	O
RESIGN	int
:	O
state	pointer
=	O
ascii_endgame	function
(	O
gameinfo	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
END	int
:	O
case	O
EXIT	int
:	O
case	O
QUIT	int
:	O
return	O
;	O
case	O
HELP	int
:	O
show_commands	function
(	O
)	O
;	O
break	O
;	O
case	O
CMD_HELPDEBUG	int
:	O
printf	function
(	O
DEBUG_COMMANDS	pointer
)	O
;	O
break	O
;	O
case	O
SHOWBOARD	int
:	O
opt_showboard	int
=	O
!	O
opt_showboard	int
;	O
break	O
;	O
case	O
INFO	int
:	O
printf	function
(	O
"\n"	pointer
)	O
;	O
gameinfo_print	function
(	O
gameinfo	pointer
)	O
;	O
break	O
;	O
case	O
SETBOARDSIZE	int
:	O
if	O
(	O
sgf_initialized	int
)	O
{	O
printf	function
(	O
"Boardsize cannot be changed after record is started!\n"	pointer
)	O
;	O
break	O
;	O
}	O
command	pointer
+=	O
10	int
;	O
if	O
(	O
sscanf	function
(	O
command	pointer
,	O
"%d"	pointer
,	O
&	O
num	int
)	O
!=	O
1	int
)	O
{	O
printf	function
(	O
"\nInvalid command syntax!\n"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
check_boardsize	function
(	O
num	int
,	O
stdout	pointer
)	O
)	O
break	O
;	O
board_size	int
=	O
num	int
;	O
clear_board	function
(	O
)	O
;	O
gameinfo	pointer
->	O
handicap	int
=	O
place_fixed_handicap	function
(	O
gameinfo	pointer
->	O
handicap	int
)	O
;	O
sgfOverwritePropertyInt	function
(	O
sgftree	struct
.	O
root	pointer
,	O
"SZ"	pointer
,	O
board_size	int
)	O
;	O
sgfOverwritePropertyInt	function
(	O
sgftree	struct
.	O
root	pointer
,	O
"HA"	pointer
,	O
gameinfo	pointer
->	O
handicap	int
)	O
;	O
break	O
;	O
case	O
SETHANDICAP	int
:	O
if	O
(	O
sgf_initialized	int
)	O
{	O
printf	function
(	O
"Handicap cannot be changed after game is started!\n"	pointer
)	O
;	O
break	O
;	O
}	O
command	pointer
+=	O
9	int
;	O
if	O
(	O
sscanf	function
(	O
command	pointer
,	O
"%d"	pointer
,	O
&	O
num	int
)	O
!=	O
1	int
)	O
{	O
printf	function
(	O
"\nInvalid command syntax!\n"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
num	int
<	O
0	int
||	O
num	int
>	O
MAX_HANDICAP	int
)	O
{	O
printf	function
(	O
"\nInvalid handicap: %d\n"	pointer
,	O
num	int
)	O
;	O
break	O
;	O
}	O
clear_board	function
(	O
)	O
;	O
gameinfo	pointer
->	O
handicap	int
=	O
place_fixed_handicap	function
(	O
num	int
)	O
;	O
printf	function
(	O
"\nSet handicap to %d\n"	pointer
,	O
gameinfo	pointer
->	O
handicap	int
)	O
;	O
gameinfo	pointer
->	O
to_move	int
=	O
(	O
gameinfo	pointer
->	O
handicap	int
?	O
WHITE	int
:	O
BLACK	int
)	O
;	O
break	O
;	O
case	O
FREEHANDICAP	int
:	O
if	O
(	O
sgf_initialized	int
)	O
{	O
printf	function
(	O
"Handicap cannot be changed after game is started!\n"	pointer
)	O
;	O
break	O
;	O
}	O
while	O
(	O
*	O
command	pointer
&&	O
*	O
command	pointer
!=	O
' '	O
)	O
command	pointer
++	O
;	O
ascii_free_handicap	function
(	O
gameinfo	pointer
,	O
command	pointer
)	O
;	O
break	O
;	O
case	O
SETKOMI	int
:	O
if	O
(	O
sgf_initialized	int
)	O
{	O
printf	function
(	O
"Komi cannot be modified after game record is started!\n"	pointer
)	O
;	O
break	O
;	O
}	O
command	pointer
+=	O
5	int
;	O
if	O
(	O
sscanf	function
(	O
command	pointer
,	O
"%f"	pointer
,	O
&	O
fnum	float
)	O
!=	O
1	int
)	O
{	O
printf	function
(	O
"\nInvalid command syntax!\n"	pointer
)	O
;	O
break	O
;	O
}	O
komi	float
=	O
fnum	float
;	O
printf	function
(	O
"\nSet Komi to %.1f\n"	pointer
,	O
komi	float
)	O
;	O
break	O
;	O
case	O
SETDEPTH	int
:	O
command	pointer
+=	O
6	int
;	O
if	O
(	O
sscanf	function
(	O
command	pointer
,	O
"%d"	pointer
,	O
&	O
num	int
)	O
!=	O
1	int
)	O
{	O
printf	function
(	O
"\nInvalid command syntax!\n"	pointer
)	O
;	O
break	O
;	O
}	O
mandated_depth	int
=	O
num	int
;	O
printf	function
(	O
"\nSet depth to %d\n"	pointer
,	O
mandated_depth	int
)	O
;	O
break	O
;	O
case	O
SETLEVEL	int
:	O
command	pointer
+=	O
6	int
;	O
if	O
(	O
sscanf	function
(	O
command	pointer
,	O
"%d"	pointer
,	O
&	O
num	int
)	O
!=	O
1	int
)	O
{	O
printf	function
(	O
"\nInvalid command syntax!\n"	pointer
)	O
;	O
break	O
;	O
}	O
set_level	function
(	O
num	int
)	O
;	O
printf	function
(	O
"\nSet level to %d\n"	pointer
,	O
num	int
)	O
;	O
break	O
;	O
case	O
DISPLAY	int
:	O
if	O
(	O
!	O
opt_showboard	int
)	O
ascii_showboard	function
(	O
)	O
;	O
break	O
;	O
case	O
FORCE	int
:	O
command	pointer
+=	O
6	int
;	O
switch	O
(	O
get_command	function
(	O
command	pointer
)	O
)	O
{	O
case	O
MOVE	int
:	O
state	pointer
=	O
do_move	function
(	O
gameinfo	pointer
,	O
command	pointer
,	O
&	O
passes	pointer
,	O
1	int
)	O
;	O
break	O
;	O
case	O
PASS	int
:	O
state	pointer
=	O
do_pass	function
(	O
gameinfo	pointer
,	O
&	O
passes	pointer
,	O
1	int
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"Illegal forced move: %s %d\n"	pointer
,	O
command	pointer
,	O
get_command	function
(	O
command	pointer
)	O
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
MOVE	int
:	O
state	pointer
=	O
do_move	function
(	O
gameinfo	pointer
,	O
command	pointer
,	O
&	O
passes	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
PASS	int
:	O
state	pointer
=	O
do_pass	function
(	O
gameinfo	pointer
,	O
&	O
passes	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
PLAY	int
:	O
command	pointer
+=	O
5	int
;	O
if	O
(	O
sscanf	function
(	O
command	pointer
,	O
"%d"	pointer
,	O
&	O
num	int
)	O
!=	O
1	int
)	O
{	O
printf	function
(	O
"\nInvalid command syntax!\n"	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
num	int
>=	O
0	int
)	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
num	int
;	O
m	int
++	O
)	O
{	O
gameinfo	pointer
->	O
computer_player	int
=	O
OTHER_COLOR	O
(	O
gameinfo	pointer
->	O
computer_player	int
)	O
;	O
state	pointer
=	O
computer_move	function
(	O
gameinfo	pointer
,	O
&	O
passes	pointer
)	O
;	O
if	O
(	O
state	pointer
)	O
break	O
;	O
if	O
(	O
passes	pointer
>=	O
2	int
)	O
break	O
;	O
}	O
else	O
{	O
printf	function
(	O
"\nInvalid number of moves specified: %d\n"	pointer
,	O
num	int
)	O
;	O
break	O
;	O
}	O
break	O
;	O
case	O
PLAYBLACK	int
:	O
if	O
(	O
gameinfo	pointer
->	O
computer_player	int
==	O
WHITE	int
)	O
gameinfo	pointer
->	O
computer_player	int
=	O
BLACK	int
;	O
if	O
(	O
gameinfo	pointer
->	O
computer_player	int
==	O
gameinfo	pointer
->	O
to_move	int
)	O
state	pointer
=	O
computer_move	function
(	O
gameinfo	pointer
,	O
&	O
passes	pointer
)	O
;	O
break	O
;	O
case	O
PLAYWHITE	int
:	O
if	O
(	O
gameinfo	pointer
->	O
computer_player	int
==	O
BLACK	int
)	O
gameinfo	pointer
->	O
computer_player	int
=	O
WHITE	int
;	O
if	O
(	O
gameinfo	pointer
->	O
computer_player	int
==	O
gameinfo	pointer
->	O
to_move	int
)	O
state	pointer
=	O
computer_move	function
(	O
gameinfo	pointer
,	O
&	O
passes	pointer
)	O
;	O
break	O
;	O
case	O
SWITCH	int
:	O
gameinfo	pointer
->	O
computer_player	int
=	O
OTHER_COLOR	O
(	O
gameinfo	pointer
->	O
computer_player	int
)	O
;	O
state	pointer
=	O
computer_move	function
(	O
gameinfo	pointer
,	O
&	O
passes	pointer
)	O
;	O
break	O
;	O
case	O
UNDO	int
:	O
case	O
CMD_BACK	int
:	O
if	O
(	O
undo_move	function
(	O
1	int
)	O
)	O
{	O
sgftreeAddComment	function
(	O
&	O
sgftree	struct
,	O
"undone"	pointer
)	O
;	O
sgftreeBack	function
(	O
&	O
sgftree	struct
)	O
;	O
gameinfo	pointer
->	O
to_move	int
=	O
OTHER_COLOR	O
(	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
}	O
else	O
printf	function
(	O
"\nCan't undo.\n"	pointer
)	O
;	O
break	O
;	O
case	O
CMD_FORWARD	int
:	O
if	O
(	O
sgftreeForward	function
(	O
&	O
sgftree	struct
)	O
)	O
gameinfo	pointer
->	O
to_move	int
=	O
gnugo_play_sgfnode	function
(	O
sgftree	struct
.	O
lastnode	pointer
,	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
else	O
printf	function
(	O
"\nEnd of game tree.\n"	pointer
)	O
;	O
break	O
;	O
case	O
CMD_LAST	int
:	O
while	O
(	O
sgftreeForward	function
(	O
&	O
sgftree	struct
)	O
)	O
gameinfo	pointer
->	O
to_move	int
=	O
gnugo_play_sgfnode	function
(	O
sgftree	struct
.	O
lastnode	pointer
,	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
break	O
;	O
case	O
COMMENT	int
:	O
printf	function
(	O
"\nEnter comment. Press ENTER when ready.\n"	pointer
)	O
;	O
fgets	function
(	O
line	int
,	O
80	int
,	O
stdin	pointer
)	O
;	O
sgftreeAddComment	function
(	O
&	O
sgftree	struct
,	O
line	int
)	O
;	O
break	O
;	O
case	O
SCORE	int
:	O
showscore	int
=	O
!	O
showscore	int
;	O
if	O
(	O
!	O
showscore	int
)	O
current_score_estimate	int
=	O
NO_SCORE	int
;	O
break	O
;	O
case	O
CMD_DEAD	int
:	O
silent_examine_position	function
(	O
FULL_EXAMINE_DRAGONS	int
)	O
;	O
showdead	int
=	O
!	O
showdead	int
;	O
break	O
;	O
case	O
CMD_CAPTURE	int
:	O
strtok	function
(	O
command	pointer
,	O
" "	pointer
)	O
;	O
showcapture	function
(	O
strtok	function
(	O
NULL	O
,	O
" "	pointer
)	O
)	O
;	O
break	O
;	O
case	O
CMD_DEFEND	int
:	O
strtok	function
(	O
command	pointer
,	O
" "	pointer
)	O
;	O
showdefense	function
(	O
strtok	function
(	O
NULL	O
,	O
" "	pointer
)	O
)	O
;	O
break	O
;	O
case	O
CMD_SHOWMOYO	int
:	O
tmp	int
=	O
printmoyo	int
;	O
printmoyo	int
=	O
PRINTMOYO_MOYO	int
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS	int
)	O
;	O
printmoyo	int
=	O
tmp	int
;	O
break	O
;	O
case	O
CMD_SHOWTERRI	int
:	O
tmp	int
=	O
printmoyo	int
;	O
printmoyo	int
=	O
PRINTMOYO_TERRITORY	int
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS	int
)	O
;	O
printmoyo	int
=	O
tmp	int
;	O
break	O
;	O
case	O
CMD_SHOWAREA	int
:	O
tmp	int
=	O
printmoyo	int
;	O
printmoyo	int
=	O
PRINTMOYO_AREA	int
;	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS	int
)	O
;	O
printmoyo	int
=	O
tmp	int
;	O
break	O
;	O
case	O
CMD_SHOWDRAGONS	int
:	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS	int
)	O
;	O
showboard	function
(	O
1	int
)	O
;	O
break	O
;	O
case	O
CMD_GOTO	int
:	O
strtok	function
(	O
command	pointer
,	O
" "	pointer
)	O
;	O
ascii_goto	function
(	O
gameinfo	pointer
,	O
strtok	function
(	O
NULL	O
,	O
" "	pointer
)	O
)	O
;	O
break	O
;	O
case	O
CMD_SAVE	int
:	O
strtok	function
(	O
command	pointer
,	O
" "	pointer
)	O
;	O
tmpstring	pointer
=	O
strtok	function
(	O
NULL	O
,	O
" "	pointer
)	O
;	O
if	O
(	O
tmpstring	pointer
)	O
{	O
tmpstring	pointer
[	O
strlen	function
(	O
tmpstring	pointer
)	O
-	O
1	int
]	O
=	O
0	int
;	O
init_sgf	function
(	O
gameinfo	pointer
)	O
;	O
writesgf	function
(	O
sgftree	struct
.	O
root	pointer
,	O
tmpstring	pointer
)	O
;	O
printf	function
(	O
"You may resume the game"	pointer
)	O
;	O
printf	function
(	O
" with -l %s --mode ascii\n"	pointer
,	O
tmpstring	pointer
)	O
;	O
printf	function
(	O
"or load %s\n"	pointer
,	O
tmpstring	pointer
)	O
;	O
}	O
else	O
printf	function
(	O
"Please specify filename\n"	pointer
)	O
;	O
break	O
;	O
case	O
CMD_LOAD	int
:	O
strtok	function
(	O
command	pointer
,	O
" "	pointer
)	O
;	O
tmpstring	pointer
=	O
strtok	function
(	O
NULL	O
,	O
" "	pointer
)	O
;	O
if	O
(	O
tmpstring	pointer
)	O
{	O
tmpstring	pointer
[	O
strlen	function
(	O
tmpstring	pointer
)	O
-	O
1	int
]	O
=	O
0	int
;	O
if	O
(	O
!	O
sgftree_readfile	function
(	O
&	O
sgftree	struct
,	O
tmpstring	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot open or parse '%s'\n"	pointer
,	O
tmpstring	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
gameinfo_play_sgftree	function
(	O
gameinfo	pointer
,	O
&	O
sgftree	struct
,	O
NULL	O
)	O
==	O
EMPTY	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot load '%s'\n"	pointer
,	O
tmpstring	pointer
)	O
;	O
else	O
{	O
sgf_initialized	int
=	O
1	int
;	O
sgfOverwritePropertyInt	function
(	O
sgftree	struct
.	O
root	pointer
,	O
"HA"	pointer
,	O
gameinfo	pointer
->	O
handicap	int
)	O
;	O
}	O
}	O
else	O
printf	function
(	O
"Please specify a filename\n"	pointer
)	O
;	O
break	O
;	O
case	O
CMD_LISTDRAGONS	int
:	O
silent_examine_position	function
(	O
EXAMINE_DRAGONS	int
)	O
;	O
show_dragons	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
printf	function
(	O
"\nInvalid command: %s"	pointer
,	O
command	pointer
)	O
;	O
break	O
;	O
}	O
if	O
(	O
passes	pointer
>=	O
2	int
)	O
state	pointer
=	O
ascii_endgame	function
(	O
gameinfo	pointer
,	O
0	int
)	O
;	O
}	O
}	O
sgffile_output	function
(	O
&	O
sgftree	struct
)	O
;	O
passes	pointer
=	O
0	int
;	O
update_random_seed	function
(	O
)	O
;	O
sgfFreeNode	function
(	O
sgftree	struct
.	O
root	pointer
)	O
;	O
sgftree_clear	function
(	O
&	O
sgftree	struct
)	O
;	O
sgftreeCreateHeaderNode	function
(	O
&	O
sgftree	struct
,	O
board_size	int
,	O
komi	float
,	O
gameinfo	pointer
->	O
handicap	int
)	O
;	O
sgf_initialized	int
=	O
0	int
;	O
gameinfo_clear	function
(	O
gameinfo	pointer
)	O
;	O
}	O
}	O
static	O
int	O
ascii_endgame	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
,	O
int	O
reason	int
)	O
{	O
char	O
line	int
[	O
80	int
]	O
;	O
char	O
*	O
line_ptr	pointer
;	O
char	O
*	O
command	pointer
;	O
char	O
*	O
tmpstring	pointer
;	O
int	O
state	pointer
=	O
0	int
;	O
if	O
(	O
reason	int
==	O
0	int
)	O
{	O
who_wins	function
(	O
gameinfo	pointer
->	O
computer_player	int
,	O
stdout	pointer
)	O
;	O
printf	function
(	O
"\nIf you disagree, we may count the game together.\n"	pointer
)	O
;	O
sgftreeWriteResult	function
(	O
&	O
sgftree	struct
,	O
(	O
white_score	float
+	O
black_score	float
)	O
/	O
2.0	int
,	O
1	int
)	O
;	O
}	O
else	O
{	O
int	O
color	int
=	O
OTHER_COLOR	O
(	O
gameinfo	pointer
->	O
to_move	int
)	O
;	O
if	O
(	O
reason	int
==	O
1	int
)	O
printf	function
(	O
"GNU Go wins by resignation.\n"	pointer
)	O
;	O
else	O
printf	function
(	O
"You win by resignation.\n"	pointer
)	O
;	O
printf	function
(	O
"Result: %c+Resign\n\n"	pointer
,	O
color	int
==	O
WHITE	int
?	O
'W'	O
:	O
'B'	O
)	O
;	O
sgftreeWriteResult	function
(	O
&	O
sgftree	struct
,	O
color	int
==	O
WHITE	int
?	O
1000.0	int
:	O
-	O
1000.0	int
,	O
1	int
)	O
;	O
}	O
while	O
(	O
state	pointer
==	O
0	int
)	O
{	O
printf	function
(	O
"You may optionally save the game as an SGF file.\n\n"	pointer
)	O
;	O
printf	function
(	O
"Type \"save <filename>\" to save,\n"	pointer
)	O
;	O
if	O
(	O
reason	int
==	O
0	int
)	O
printf	function
(	O
"     \"count\" to recount,\n"	pointer
)	O
;	O
else	O
if	O
(	O
reason	int
==	O
2	int
)	O
printf	function
(	O
"     \"continue\" to decline resignation and continue the game,\n"	pointer
)	O
;	O
printf	function
(	O
"     \"quit\" to quit\n"	pointer
)	O
;	O
printf	function
(	O
" or  \"game\" to play again\n"	pointer
)	O
;	O
line_ptr	pointer
=	O
line	int
;	O
if	O
(	O
!	O
fgets	function
(	O
line	int
,	O
80	int
,	O
stdin	pointer
)	O
)	O
break	O
;	O
command	pointer
=	O
strtok	function
(	O
line_ptr	pointer
,	O
""	pointer
)	O
;	O
switch	O
(	O
get_command	function
(	O
command	pointer
)	O
)	O
{	O
case	O
CMD_SAVE	int
:	O
strtok	function
(	O
command	pointer
,	O
" "	pointer
)	O
;	O
tmpstring	pointer
=	O
strtok	function
(	O
NULL	O
,	O
" "	pointer
)	O
;	O
if	O
(	O
tmpstring	pointer
)	O
{	O
tmpstring	pointer
[	O
strlen	function
(	O
tmpstring	pointer
)	O
-	O
1	int
]	O
=	O
0	int
;	O
init_sgf	function
(	O
gameinfo	pointer
)	O
;	O
writesgf	function
(	O
sgftree	struct
.	O
root	pointer
,	O
tmpstring	pointer
)	O
;	O
}	O
else	O
printf	function
(	O
"Please specify filename\n"	pointer
)	O
;	O
break	O
;	O
case	O
COUNT	int
:	O
if	O
(	O
reason	int
==	O
0	int
)	O
ascii_count	function
(	O
gameinfo	pointer
)	O
;	O
break	O
;	O
case	O
CONTINUE	int
:	O
state	pointer
=	O
-	O
1	int
;	O
break	O
;	O
case	O
NEW	int
:	O
state	pointer
=	O
1	int
;	O
break	O
;	O
case	O
QUIT	int
:	O
state	pointer
=	O
2	int
;	O
break	O
;	O
default	O
:	O
state	pointer
=	O
0	int
;	O
}	O
}	O
return	O
state	pointer
;	O
}	O
static	O
void	O
ascii_count	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
)	O
{	O
char	O
line	int
[	O
12	int
]	O
;	O
int	O
done	int
=	O
0	int
;	O
int	O
i	int
;	O
int	O
xyzzy	int
=	O
1	int
;	O
printf	function
(	O
"\nGame over. Let's count!.\n"	pointer
)	O
;	O
showdead	int
=	O
1	int
;	O
ascii_showboard	function
(	O
)	O
;	O
while	O
(	O
!	O
done	int
)	O
{	O
printf	function
(	O
"Dead stones are marked with small letters (x,o).\n"	pointer
)	O
;	O
printf	function
(	O
"\nIf you don't agree, enter the location of a group\n"	pointer
)	O
;	O
printf	function
(	O
"to toggle its state or \"done\".\n"	pointer
)	O
;	O
if	O
(	O
!	O
fgets	function
(	O
line	int
,	O
12	int
,	O
stdin	pointer
)	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
12	int
;	O
i	int
++	O
)	O
line	int
[	O
i	int
]	O
=	O
tolower	function
(	O
(	O
int	O
)	O
line	int
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
"done"	pointer
,	O
4	int
)	O
)	O
done	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
"quit"	pointer
,	O
4	int
)	O
)	O
return	O
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
"xyzzy"	pointer
,	O
5	int
)	O
)	O
{	O
if	O
(	O
xyzzy	int
)	O
{	O
printf	function
(	O
"\nYou are in a debris room filled with stuff washed in from the\n"	pointer
)	O
;	O
printf	function
(	O
"surface.  A low wide passage with cobbles becomes plugged\n"	pointer
)	O
;	O
printf	function
(	O
"with mud and debris here, but an awkward canyon leads\n"	pointer
)	O
;	O
printf	function
(	O
"upward and west.  A note on the wall says:\n"	pointer
)	O
;	O
printf	function
(	O
"   Magic Word \"XYZZY\"\n\n"	pointer
)	O
;	O
xyzzy	int
=	O
0	int
;	O
}	O
else	O
{	O
printf	function
(	O
"You are inside a building, a well house for a large spring.\n\n"	pointer
)	O
;	O
xyzzy	int
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
"help"	pointer
,	O
4	int
)	O
)	O
{	O
printf	function
(	O
"\nIf there are dead stones on the board I will remove them.\n"	pointer
)	O
;	O
printf	function
(	O
"You must tell me where they are. Type the coordinates of a\n"	pointer
)	O
;	O
printf	function
(	O
"dead group, or type \"done\"\n"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
"undo"	pointer
,	O
4	int
)	O
)	O
{	O
printf	function
(	O
"UNDO not allowed anymore. The status of the stones now\n"	pointer
)	O
;	O
printf	function
(	O
"toggles after entering the location of it.\n"	pointer
)	O
;	O
ascii_showboard	function
(	O
)	O
;	O
}	O
else	O
{	O
int	O
pos	int
=	O
string_to_location	function
(	O
board_size	int
,	O
line	int
)	O
;	O
if	O
(	O
pos	int
==	O
NO_MOVE	O
||	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
printf	function
(	O
"\ninvalid!\n"	pointer
)	O
;	O
else	O
{	O
enum	O
dragon_status	function
status	enum
=	O
dragon_status	function
(	O
pos	int
)	O
;	O
status	enum
=	O
(	O
status	enum
==	O
DEAD	int
)	O
?	O
ALIVE	int
:	O
DEAD	int
;	O
change_dragon_status	function
(	O
pos	int
,	O
status	enum
)	O
;	O
ascii_showboard	function
(	O
)	O
;	O
}	O
}	O
}	O
who_wins	function
(	O
gameinfo	pointer
->	O
computer_player	int
,	O
stdout	pointer
)	O
;	O
}	O
static	O
void	O
showcapture	function
(	O
char	O
*	O
line	int
)	O
{	O
int	O
str	int
;	O
int	O
move	pointer
;	O
gg_assert	O
(	O
line	int
)	O
;	O
str	int
=	O
string_to_location	function
(	O
board_size	int
,	O
line	int
)	O
;	O
if	O
(	O
str	int
==	O
NO_MOVE	O
||	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
)	O
{	O
printf	function
(	O
"\ninvalid point!\n"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
attack	function
(	O
str	int
,	O
&	O
move	pointer
)	O
)	O
mprintf	function
(	O
"\nSuccessful attack of %1m at %1m\n"	pointer
,	O
str	int
,	O
move	pointer
)	O
;	O
else	O
mprintf	function
(	O
"\n%1m cannot be attacked\n"	pointer
,	O
str	int
)	O
;	O
}	O
static	O
void	O
showdefense	function
(	O
char	O
*	O
line	int
)	O
{	O
int	O
str	int
;	O
int	O
move	pointer
;	O
gg_assert	O
(	O
line	int
)	O
;	O
str	int
=	O
string_to_location	function
(	O
board_size	int
,	O
line	int
)	O
;	O
if	O
(	O
str	int
==	O
NO_MOVE	O
||	O
board	pointer
[	O
str	int
]	O
==	O
EMPTY	int
)	O
{	O
printf	function
(	O
"\ninvalid point!\n"	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
attack	function
(	O
str	int
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
find_defense	function
(	O
str	int
,	O
&	O
move	pointer
)	O
)	O
mprintf	function
(	O
"\nSuccessful defense of %1m at %1m\n"	pointer
,	O
str	int
,	O
move	pointer
)	O
;	O
else	O
mprintf	function
(	O
"\n%1m cannot be defended\n"	pointer
,	O
str	int
)	O
;	O
}	O
else	O
mprintf	function
(	O
"\nThere is no need to defend %1m\n"	pointer
,	O
str	int
)	O
;	O
}	O
static	O
void	O
ascii_goto	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
,	O
char	O
*	O
line	int
)	O
{	O
const	O
char	O
*	O
movenumber	pointer
=	O
line	int
;	O
if	O
(	O
!	O
line	int
)	O
return	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
"last"	pointer
,	O
4	int
)	O
)	O
movenumber	pointer
=	O
"9999"	pointer
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
"first"	pointer
,	O
4	int
)	O
)	O
movenumber	pointer
=	O
"1"	pointer
;	O
printf	function
(	O
"goto %s\n"	pointer
,	O
movenumber	pointer
)	O
;	O
gameinfo_play_sgftree	function
(	O
gameinfo	pointer
,	O
&	O
sgftree	struct
,	O
movenumber	pointer
)	O
;	O
}	O
static	O
void	O
ascii_free_handicap	function
(	O
Gameinfo	struct
*	O
gameinfo	pointer
,	O
char	O
*	O
handicap_string	pointer
)	O
{	O
int	O
handi	int
;	O
int	O
i	int
;	O
char	O
line	int
[	O
80	int
]	O
;	O
int	O
stones	pointer
[	O
MAX_BOARD	int
*	O
MAX_BOARD	int
]	O
;	O
if	O
(	O
sscanf	function
(	O
handicap_string	pointer
,	O
"%d"	pointer
,	O
&	O
handi	int
)	O
==	O
1	int
)	O
{	O
if	O
(	O
handi	int
<	O
0	int
||	O
handi	int
==	O
1	int
)	O
{	O
printf	function
(	O
"\nInvalid command syntax!\n"	pointer
)	O
;	O
return	O
;	O
}	O
clear_board	function
(	O
)	O
;	O
handi	int
=	O
place_free_handicap	function
(	O
handi	int
)	O
;	O
printf	function
(	O
"\nPlaced %d stones of free handicap.\n"	pointer
,	O
handi	int
)	O
;	O
}	O
else	O
{	O
clear_board	function
(	O
)	O
;	O
handi	int
=	O
0	int
;	O
while	O
(	O
1	int
)	O
{	O
ascii_showboard	function
(	O
)	O
;	O
printf	function
(	O
"\nType in coordinates of next handicap stone, or one of the following commands:\n"	pointer
)	O
;	O
printf	function
(	O
"  undo        take back the last stone placed\n"	pointer
)	O
;	O
printf	function
(	O
"  clear       remove all the stones placed so far\n"	pointer
)	O
;	O
printf	function
(	O
"  done        finish placing handicap\n\n"	pointer
)	O
;	O
printf	function
(	O
"You have placed %d handicap stone(s) so far.\n\n"	pointer
,	O
handi	int
)	O
;	O
if	O
(	O
!	O
fgets	function
(	O
line	int
,	O
80	int
,	O
stdin	pointer
)	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
80	int
;	O
i	int
++	O
)	O
line	int
[	O
i	int
]	O
=	O
tolower	function
(	O
(	O
int	O
)	O
line	int
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
"undo"	pointer
,	O
4	int
)	O
)	O
{	O
if	O
(	O
!	O
handi	int
)	O
printf	function
(	O
"\nNothing to undo.\n"	pointer
)	O
;	O
else	O
{	O
remove_stone	function
(	O
stones	pointer
[	O
--	O
handi	int
]	O
)	O
;	O
gprintf	function
(	O
"\nRemoved the stone at %m.\n"	pointer
,	O
I	O
(	O
stones	pointer
[	O
handi	int
]	O
)	O
,	O
J	O
(	O
stones	pointer
[	O
handi	int
]	O
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
"clear"	pointer
,	O
5	int
)	O
)	O
{	O
clear_board	function
(	O
)	O
;	O
handi	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
"done"	pointer
,	O
4	int
)	O
)	O
{	O
if	O
(	O
handi	int
==	O
1	int
)	O
printf	function
(	O
"\nHandicap cannot be one stone. Either add "	pointer
"some more, or delete the only stone.\n"	pointer
)	O
;	O
else	O
break	O
;	O
}	O
else	O
{	O
int	O
pos	int
=	O
string_to_location	function
(	O
board_size	int
,	O
line	int
)	O
;	O
if	O
(	O
pos	int
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
)	O
printf	function
(	O
"\nThere's already a stone there.\n"	pointer
)	O
;	O
else	O
{	O
add_stone	function
(	O
pos	int
,	O
BLACK	int
)	O
;	O
stones	pointer
[	O
handi	int
++	O
]	O
=	O
pos	int
;	O
}	O
}	O
else	O
printf	function
(	O
"\nInvalid command: %s"	pointer
,	O
line	int
)	O
;	O
}	O
}	O
}	O
gameinfo	pointer
->	O
handicap	int
=	O
handi	int
;	O
gameinfo	pointer
->	O
to_move	int
=	O
(	O
handi	int
?	O
WHITE	int
:	O
BLACK	int
)	O
;	O
}	O
