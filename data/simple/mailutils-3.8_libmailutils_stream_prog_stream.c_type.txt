static	O
mu_list_t	pointer
prog_stream_list	pointer
;	O
static	O
int	O
_prog_stream_register	function
(	O
struct	O
_mu_prog_stream	struct
*	O
stream	pointer
)	O
{	O
if	O
(	O
!	O
prog_stream_list	pointer
)	O
{	O
int	O
rc	int
=	O
mu_list_create	function
(	O
&	O
prog_stream_list	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
}	O
return	O
mu_list_append	function
(	O
prog_stream_list	pointer
,	O
stream	pointer
)	O
;	O
}	O
static	O
void	O
_prog_stream_unregister	function
(	O
struct	O
_mu_prog_stream	struct
*	O
stream	pointer
)	O
{	O
mu_list_remove	function
(	O
prog_stream_list	pointer
,	O
stream	pointer
)	O
;	O
}	O
int	O
_mu_prog_limit_flags	int
=	O
_MU_PROG_AVAILABLE_LIMITS	O
;	O
int	O
_mu_prog_limit_codes	array
[	O
_MU_PROG_LIMIT_MAX	int
]	O
=	O
{	O
RLIMIT_AS	int
,	O
RLIMIT_CPU	int
,	O
RLIMIT_DATA	int
,	O
RLIMIT_FSIZE	int
,	O
RLIMIT_NPROC	O
,	O
RLIMIT_CORE	int
,	O
RLIMIT_MEMLOCK	O
,	O
RLIMIT_NOFILE	int
,	O
RLIMIT_RSS	O
,	O
RLIMIT_STACK	int
}	O
;	O
static	O
int	O
start_program_filter	function
(	O
int	O
*	O
p	pointer
,	O
struct	O
_mu_prog_stream	struct
*	O
fs	short
,	O
int	O
flags	int
)	O
{	O
int	O
rightp	array
[	O
2	int
]	O
,	O
leftp	array
[	O
2	int
]	O
;	O
int	O
i	int
;	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
REDIRECT_STDIN_P	O
(	O
flags	int
)	O
)	O
pipe	function
(	O
leftp	array
)	O
;	O
if	O
(	O
REDIRECT_STDOUT_P	O
(	O
flags	int
)	O
)	O
pipe	function
(	O
rightp	array
)	O
;	O
switch	O
(	O
fs	short
->	O
pid	int
=	O
fork	function
(	O
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
REDIRECT_STDOUT_P	O
(	O
flags	int
)	O
)	O
{	O
if	O
(	O
rightp	array
[	O
1	int
]	O
!=	O
1	int
)	O
{	O
close	function
(	O
1	int
)	O
;	O
dup2	function
(	O
rightp	array
[	O
1	int
]	O
,	O
1	int
)	O
;	O
}	O
close	function
(	O
rightp	array
[	O
0	int
]	O
)	O
;	O
}	O
if	O
(	O
REDIRECT_STDIN_P	O
(	O
flags	int
)	O
)	O
{	O
if	O
(	O
leftp	array
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
close	function
(	O
0	int
)	O
;	O
dup2	function
(	O
leftp	array
[	O
0	int
]	O
,	O
0	int
)	O
;	O
}	O
close	function
(	O
leftp	array
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_ERRTOOUT	int
)	O
dup2	function
(	O
1	int
,	O
2	int
)	O
;	O
if	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_WORKDIR	int
)	O
{	O
if	O
(	O
chdir	function
(	O
fs	short
->	O
hints	pointer
.	O
mu_prog_workdir	pointer
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot change to %s: %s"	pointer
)	O
,	O
fs	short
->	O
hints	pointer
.	O
mu_prog_workdir	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_IGNOREFAIL	int
)	O
)	O
_exit	function
(	O
127	int
)	O
;	O
}	O
}	O
if	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_UID	int
)	O
{	O
if	O
(	O
mu_set_user_privileges	function
(	O
fs	short
->	O
hints	pointer
.	O
mu_prog_uid	int
,	O
fs	short
->	O
hints	pointer
.	O
mu_prog_gidv	pointer
,	O
fs	short
->	O
hints	pointer
.	O
mu_prog_gidc	long
)	O
&&	O
!	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_IGNOREFAIL	int
)	O
)	O
_exit	function
(	O
127	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_MU_PROG_LIMIT_MAX	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
MU_PROG_HINT_LIMIT	O
(	O
i	int
)	O
&	O
fs	short
->	O
hint_flags	int
)	O
{	O
struct	O
rlimit	struct
rlim	struct
;	O
rlim	struct
.	O
rlim_cur	long
=	O
rlim	struct
.	O
rlim_max	long
=	O
fs	short
->	O
hints	pointer
.	O
mu_prog_limit	array
[	O
i	int
]	O
;	O
if	O
(	O
setrlimit	function
(	O
_mu_prog_limit_codes	array
[	O
i	int
]	O
,	O
&	O
rlim	struct
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"error setting limit %d to %lu: %s"	pointer
)	O
,	O
i	int
,	O
(	O
unsigned	O
long	O
)	O
rlim	struct
.	O
rlim_cur	long
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_IGNOREFAIL	int
)	O
)	O
_exit	function
(	O
127	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
MU_PROG_HINT_PRIO	int
&	O
fs	short
->	O
hint_flags	int
)	O
{	O
if	O
(	O
setpriority	function
(	O
PRIO_PROCESS	int
,	O
0	int
,	O
fs	short
->	O
hints	pointer
.	O
mu_prog_prio	int
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"error setting priority: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
!	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_IGNOREFAIL	int
)	O
)	O
_exit	function
(	O
127	int
)	O
;	O
}	O
}	O
for	O
(	O
i	int
=	O
mu_getmaxfd	function
(	O
)	O
;	O
i	int
>	O
2	int
;	O
i	int
--	O
)	O
close	function
(	O
i	int
)	O
;	O
execvp	function
(	O
fs	short
->	O
progname	pointer
,	O
fs	short
->	O
argv	pointer
)	O
;	O
syslog	function
(	O
LOG_ERR	int
|	O
LOG_USER	O
,	O
"can't run %s (ruid=%d, euid=%d): %m"	pointer
,	O
fs	short
->	O
progname	pointer
,	O
getuid	function
(	O
)	O
,	O
geteuid	function
(	O
)	O
)	O
;	O
_exit	function
(	O
127	int
)	O
;	O
case	O
-	O
1	int
:	O
rc	int
=	O
errno	O
;	O
if	O
(	O
REDIRECT_STDOUT_P	O
(	O
flags	int
)	O
)	O
{	O
close	function
(	O
rightp	array
[	O
0	int
]	O
)	O
;	O
close	function
(	O
rightp	array
[	O
1	int
]	O
)	O
;	O
}	O
if	O
(	O
REDIRECT_STDIN_P	O
(	O
flags	int
)	O
)	O
{	O
close	function
(	O
leftp	array
[	O
0	int
]	O
)	O
;	O
close	function
(	O
leftp	array
[	O
1	int
]	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
if	O
(	O
REDIRECT_STDOUT_P	O
(	O
flags	int
)	O
)	O
{	O
p	pointer
[	O
0	int
]	O
=	O
rightp	array
[	O
0	int
]	O
;	O
close	function
(	O
rightp	array
[	O
1	int
]	O
)	O
;	O
}	O
else	O
p	pointer
[	O
0	int
]	O
=	O
-	O
1	int
;	O
if	O
(	O
REDIRECT_STDIN_P	O
(	O
flags	int
)	O
)	O
{	O
p	pointer
[	O
1	int
]	O
=	O
leftp	array
[	O
1	int
]	O
;	O
close	function
(	O
leftp	array
[	O
0	int
]	O
)	O
;	O
}	O
else	O
p	pointer
[	O
1	int
]	O
=	O
-	O
1	int
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
void	O
_prog_wait	function
(	O
pid_t	int
pid	int
,	O
int	O
*	O
pstatus	pointer
)	O
{	O
if	O
(	O
pid	int
>	O
0	int
)	O
{	O
pid_t	int
t	int
;	O
do	O
t	int
=	O
waitpid	function
(	O
pid	int
,	O
pstatus	pointer
,	O
0	int
)	O
;	O
while	O
(	O
t	int
==	O
-	O
1	int
&&	O
errno	O
==	O
EINTR	int
)	O
;	O
}	O
}	O
static	O
void	O
_prog_done	function
(	O
mu_stream_t	pointer
stream	pointer
)	O
{	O
int	O
status	int
;	O
struct	O
_mu_prog_stream	struct
*	O
fs	short
=	O
(	O
struct	O
_mu_prog_stream	struct
*	O
)	O
stream	pointer
;	O
mu_argcv_free	function
(	O
fs	short
->	O
argc	long
,	O
fs	short
->	O
argv	pointer
)	O
;	O
free	function
(	O
fs	short
->	O
progname	pointer
)	O
;	O
if	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_WORKDIR	int
)	O
free	function
(	O
fs	short
->	O
hints	pointer
.	O
mu_prog_workdir	pointer
)	O
;	O
if	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_INPUT	int
)	O
mu_stream_unref	function
(	O
fs	short
->	O
hints	pointer
.	O
mu_prog_input	pointer
)	O
;	O
if	O
(	O
fs	short
->	O
in	pointer
)	O
mu_stream_destroy	function
(	O
&	O
fs	short
->	O
in	pointer
)	O
;	O
if	O
(	O
fs	short
->	O
out	pointer
)	O
mu_stream_destroy	function
(	O
&	O
fs	short
->	O
out	pointer
)	O
;	O
_prog_wait	function
(	O
fs	short
->	O
pid	int
,	O
&	O
fs	short
->	O
status	int
)	O
;	O
fs	short
->	O
pid	int
=	O
-	O
1	int
;	O
_prog_wait	function
(	O
fs	short
->	O
writer_pid	int
,	O
&	O
status	int
)	O
;	O
fs	short
->	O
writer_pid	int
=	O
-	O
1	int
;	O
_prog_stream_unregister	function
(	O
fs	short
)	O
;	O
}	O
static	O
int	O
_prog_close	function
(	O
mu_stream_t	pointer
stream	pointer
)	O
{	O
struct	O
_mu_prog_stream	struct
*	O
fs	short
=	O
(	O
struct	O
_mu_prog_stream	struct
*	O
)	O
stream	pointer
;	O
int	O
status	int
;	O
if	O
(	O
!	O
stream	pointer
)	O
return	O
EINVAL	int
;	O
if	O
(	O
fs	short
->	O
pid	int
<=	O
0	int
)	O
return	O
0	int
;	O
mu_stream_close	function
(	O
fs	short
->	O
out	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
fs	short
->	O
out	pointer
)	O
;	O
_prog_wait	function
(	O
fs	short
->	O
pid	int
,	O
&	O
fs	short
->	O
status	int
)	O
;	O
fs	short
->	O
pid	int
=	O
-	O
1	int
;	O
_prog_wait	function
(	O
fs	short
->	O
writer_pid	int
,	O
&	O
status	int
)	O
;	O
fs	short
->	O
writer_pid	int
=	O
-	O
1	int
;	O
mu_stream_close	function
(	O
fs	short
->	O
in	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
fs	short
->	O
in	pointer
)	O
;	O
if	O
(	O
WIFEXITED	O
(	O
fs	short
->	O
status	int
)	O
)	O
{	O
if	O
(	O
WEXITSTATUS	O
(	O
fs	short
->	O
status	int
)	O
==	O
0	int
)	O
return	O
0	int
;	O
else	O
if	O
(	O
WEXITSTATUS	O
(	O
fs	short
->	O
status	int
)	O
==	O
127	int
)	O
return	O
MU_ERR_PROCESS_NOEXEC	O
;	O
else	O
return	O
MU_ERR_PROCESS_EXITED	O
;	O
}	O
else	O
if	O
(	O
WIFSIGNALED	O
(	O
fs	short
->	O
status	int
)	O
)	O
return	O
MU_ERR_PROCESS_SIGNALED	O
;	O
return	O
MU_ERR_PROCESS_UNKNOWN_FAILURE	O
;	O
}	O
static	O
int	O
feed_input	function
(	O
struct	O
_mu_prog_stream	struct
*	O
fs	short
)	O
{	O
pid_t	int
pid	int
;	O
int	O
rc	int
=	O
0	int
;	O
pid	int
=	O
fork	function
(	O
)	O
;	O
switch	O
(	O
pid	int
)	O
{	O
default	O
:	O
fs	short
->	O
writer_pid	int
=	O
pid	int
;	O
mu_stream_close	function
(	O
fs	short
->	O
out	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
fs	short
->	O
out	pointer
)	O
;	O
break	O
;	O
case	O
0	int
:	O
mu_stream_copy	function
(	O
fs	short
->	O
out	pointer
,	O
fs	short
->	O
hints	pointer
.	O
mu_prog_input	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_close	function
(	O
fs	short
->	O
out	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
case	O
-	O
1	int
:	O
rc	int
=	O
errno	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
_prog_open	function
(	O
mu_stream_t	pointer
stream	pointer
)	O
{	O
struct	O
_mu_prog_stream	struct
*	O
fs	short
=	O
(	O
struct	O
_mu_prog_stream	struct
*	O
)	O
stream	pointer
;	O
int	O
rc	int
;	O
int	O
pfd	pointer
[	O
2	int
]	O
;	O
int	O
flags	int
;	O
int	O
seekable_flag	int
;	O
if	O
(	O
!	O
fs	short
||	O
fs	short
->	O
argc	long
==	O
0	int
)	O
return	O
EINVAL	int
;	O
if	O
(	O
fs	short
->	O
pid	int
)	O
{	O
_prog_close	function
(	O
stream	pointer
)	O
;	O
}	O
mu_stream_get_flags	function
(	O
stream	pointer
,	O
&	O
flags	int
)	O
;	O
seekable_flag	int
=	O
(	O
flags	int
&	O
MU_STREAM_SEEK	int
)	O
;	O
rc	int
=	O
start_program_filter	function
(	O
pfd	pointer
,	O
fs	short
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
rc	int
;	O
if	O
(	O
REDIRECT_STDOUT_P	O
(	O
flags	int
)	O
)	O
{	O
rc	int
=	O
mu_stdio_stream_create	function
(	O
&	O
fs	short
->	O
in	pointer
,	O
pfd	pointer
[	O
0	int
]	O
,	O
MU_STREAM_READ	int
|	O
seekable_flag	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
_prog_close	function
(	O
stream	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
if	O
(	O
REDIRECT_STDIN_P	O
(	O
flags	int
)	O
)	O
{	O
rc	int
=	O
mu_stdio_stream_create	function
(	O
&	O
fs	short
->	O
out	pointer
,	O
pfd	pointer
[	O
1	int
]	O
,	O
MU_STREAM_WRITE	int
|	O
seekable_flag	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
_prog_close	function
(	O
stream	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
_prog_stream_register	function
(	O
fs	short
)	O
;	O
if	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_INPUT	int
)	O
return	O
feed_input	function
(	O
fs	short
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_prog_read	function
(	O
mu_stream_t	pointer
stream	pointer
,	O
char	O
*	O
optr	pointer
,	O
size_t	long
osize	long
,	O
size_t	long
*	O
pnbytes	pointer
)	O
{	O
struct	O
_mu_prog_stream	struct
*	O
fs	short
=	O
(	O
struct	O
_mu_prog_stream	struct
*	O
)	O
stream	pointer
;	O
return	O
mu_stream_read	function
(	O
fs	short
->	O
in	pointer
,	O
optr	pointer
,	O
osize	long
,	O
pnbytes	pointer
)	O
;	O
}	O
static	O
int	O
_prog_write	function
(	O
mu_stream_t	pointer
stream	pointer
,	O
const	O
char	O
*	O
iptr	pointer
,	O
size_t	long
isize	long
,	O
size_t	long
*	O
pnbytes	pointer
)	O
{	O
struct	O
_mu_prog_stream	struct
*	O
fs	short
=	O
(	O
struct	O
_mu_prog_stream	struct
*	O
)	O
stream	pointer
;	O
return	O
mu_stream_write	function
(	O
fs	short
->	O
out	pointer
,	O
iptr	pointer
,	O
isize	long
,	O
pnbytes	pointer
)	O
;	O
}	O
static	O
int	O
_prog_flush	function
(	O
mu_stream_t	pointer
stream	pointer
)	O
{	O
struct	O
_mu_prog_stream	struct
*	O
fs	short
=	O
(	O
struct	O
_mu_prog_stream	struct
*	O
)	O
stream	pointer
;	O
mu_stream_flush	function
(	O
fs	short
->	O
in	pointer
)	O
;	O
mu_stream_flush	function
(	O
fs	short
->	O
out	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_prog_ioctl	function
(	O
struct	O
_mu_stream	struct
*	O
str	pointer
,	O
int	O
code	int
,	O
int	O
opcode	int
,	O
void	O
*	O
ptr	pointer
)	O
{	O
struct	O
_mu_prog_stream	struct
*	O
fstr	pointer
=	O
(	O
struct	O
_mu_prog_stream	struct
*	O
)	O
str	pointer
;	O
switch	O
(	O
code	int
)	O
{	O
case	O
MU_IOCTL_TRANSPORT	int
:	O
if	O
(	O
!	O
ptr	pointer
)	O
return	O
EINVAL	int
;	O
else	O
{	O
mu_transport_t	pointer
*	O
ptrans	pointer
=	O
ptr	pointer
;	O
mu_transport_t	pointer
t	int
[	O
2	int
]	O
;	O
switch	O
(	O
opcode	int
)	O
{	O
case	O
MU_IOCTL_OP_GET	int
:	O
mu_stream_ioctl	function
(	O
fstr	pointer
->	O
in	pointer
,	O
MU_IOCTL_TRANSPORT	int
,	O
MU_IOCTL_OP_GET	int
,	O
t	int
)	O
;	O
ptrans	pointer
[	O
0	int
]	O
=	O
t	int
[	O
0	int
]	O
;	O
mu_stream_ioctl	function
(	O
fstr	pointer
->	O
out	pointer
,	O
MU_IOCTL_TRANSPORT	int
,	O
MU_IOCTL_OP_GET	int
,	O
t	int
)	O
;	O
ptrans	pointer
[	O
1	int
]	O
=	O
t	int
[	O
1	int
]	O
;	O
break	O
;	O
case	O
MU_IOCTL_OP_SET	int
:	O
return	O
ENOSYS	int
;	O
default	O
:	O
return	O
EINVAL	int
;	O
}	O
}	O
break	O
;	O
case	O
MU_IOCTL_PROGSTREAM	int
:	O
if	O
(	O
!	O
ptr	pointer
)	O
return	O
EINVAL	int
;	O
switch	O
(	O
opcode	int
)	O
{	O
case	O
MU_IOCTL_PROG_STATUS	int
:	O
*	O
(	O
int	O
*	O
)	O
ptr	pointer
=	O
fstr	pointer
->	O
status	int
;	O
break	O
;	O
case	O
MU_IOCTL_PROG_PID	int
:	O
*	O
(	O
pid_t	int
*	O
)	O
ptr	pointer
=	O
fstr	pointer
->	O
pid	int
;	O
break	O
;	O
default	O
:	O
return	O
EINVAL	int
;	O
}	O
break	O
;	O
default	O
:	O
return	O
ENOSYS	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
_mu_prog_stream	struct
*	O
_prog_stream_create	function
(	O
const	O
char	O
*	O
progname	pointer
,	O
size_t	long
argc	long
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
hint_flags	int
,	O
struct	O
mu_prog_hints	struct
*	O
hints	pointer
,	O
int	O
flags	int
)	O
{	O
struct	O
_mu_prog_stream	struct
*	O
fs	short
;	O
fs	short
=	O
(	O
struct	O
_mu_prog_stream	struct
*	O
)	O
_mu_stream_create	function
(	O
sizeof	O
(	O
*	O
fs	short
)	O
,	O
flags	int
)	O
;	O
if	O
(	O
!	O
fs	short
)	O
return	O
NULL	O
;	O
fs	short
->	O
progname	pointer
=	O
strdup	function
(	O
progname	pointer
)	O
;	O
if	O
(	O
!	O
fs	short
->	O
progname	pointer
)	O
{	O
free	function
(	O
fs	short
)	O
;	O
return	O
NULL	O
;	O
}	O
fs	short
->	O
argc	long
=	O
argc	long
;	O
fs	short
->	O
argv	pointer
=	O
argv	pointer
;	O
fs	short
->	O
stream	pointer
.	O
read	function
=	O
_prog_read	function
;	O
fs	short
->	O
stream	pointer
.	O
write	function
=	O
_prog_write	function
;	O
fs	short
->	O
stream	pointer
.	O
open	function
=	O
_prog_open	function
;	O
fs	short
->	O
stream	pointer
.	O
close	function
=	O
_prog_close	function
;	O
fs	short
->	O
stream	pointer
.	O
ctl	pointer
=	O
_prog_ioctl	function
;	O
fs	short
->	O
stream	pointer
.	O
flush	pointer
=	O
_prog_flush	function
;	O
fs	short
->	O
stream	pointer
.	O
done	pointer
=	O
_prog_done	function
;	O
if	O
(	O
!	O
hints	pointer
)	O
fs	short
->	O
hint_flags	int
=	O
0	int
;	O
else	O
{	O
fs	short
->	O
hint_flags	int
=	O
(	O
hint_flags	int
&	O
_MU_PROG_HINT_MASK	int
)	O
|	O
(	O
hint_flags	int
&	O
_MU_PROG_AVAILABLE_LIMITS	O
)	O
;	O
if	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_WORKDIR	int
)	O
{	O
fs	short
->	O
hints	pointer
.	O
mu_prog_workdir	pointer
=	O
strdup	function
(	O
hints	pointer
->	O
mu_prog_workdir	pointer
)	O
;	O
if	O
(	O
!	O
fs	short
->	O
hints	pointer
.	O
mu_prog_workdir	pointer
)	O
{	O
free	function
(	O
fs	short
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
memcpy	function
(	O
fs	short
->	O
hints	pointer
.	O
mu_prog_limit	array
,	O
hints	pointer
->	O
mu_prog_limit	array
,	O
sizeof	O
(	O
fs	short
->	O
hints	pointer
.	O
mu_prog_limit	array
)	O
)	O
;	O
fs	short
->	O
hints	pointer
.	O
mu_prog_prio	int
=	O
hints	pointer
->	O
mu_prog_prio	int
;	O
if	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_INPUT	int
)	O
{	O
fs	short
->	O
hints	pointer
.	O
mu_prog_input	pointer
=	O
hints	pointer
->	O
mu_prog_input	pointer
;	O
mu_stream_ref	function
(	O
fs	short
->	O
hints	pointer
.	O
mu_prog_input	pointer
)	O
;	O
}	O
if	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_UID	int
)	O
{	O
fs	short
->	O
hints	pointer
.	O
mu_prog_uid	int
=	O
hints	pointer
->	O
mu_prog_uid	int
;	O
if	O
(	O
fs	short
->	O
hint_flags	int
&	O
MU_PROG_HINT_GID	int
)	O
{	O
fs	short
->	O
hints	pointer
.	O
mu_prog_gidv	pointer
=	O
calloc	function
(	O
hints	pointer
->	O
mu_prog_gidc	long
,	O
sizeof	O
(	O
fs	short
->	O
hints	pointer
.	O
mu_prog_gidv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
fs	short
->	O
hints	pointer
.	O
mu_prog_gidv	pointer
)	O
{	O
mu_stream_unref	function
(	O
(	O
mu_stream_t	pointer
)	O
fs	short
)	O
;	O
return	O
NULL	O
;	O
}	O
memcpy	function
(	O
fs	short
->	O
hints	pointer
.	O
mu_prog_gidv	pointer
,	O
hints	pointer
->	O
mu_prog_gidv	pointer
,	O
hints	pointer
->	O
mu_prog_gidc	long
*	O
fs	short
->	O
hints	pointer
.	O
mu_prog_gidv	pointer
[	O
0	int
]	O
)	O
;	O
fs	short
->	O
hints	pointer
.	O
mu_prog_gidc	long
=	O
hints	pointer
->	O
mu_prog_gidc	long
;	O
}	O
else	O
{	O
fs	short
->	O
hints	pointer
.	O
mu_prog_gidc	long
=	O
0	int
;	O
fs	short
->	O
hints	pointer
.	O
mu_prog_gidv	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
return	O
fs	short
;	O
}	O
int	O
mu_prog_stream_create	function
(	O
mu_stream_t	pointer
*	O
pstream	pointer
,	O
const	O
char	O
*	O
progname	pointer
,	O
size_t	long
argc	long
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
hint_flags	int
,	O
struct	O
mu_prog_hints	struct
*	O
hints	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	pointer
stream	pointer
;	O
char	O
*	O
*	O
xargv	pointer
;	O
size_t	long
i	int
;	O
if	O
(	O
pstream	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
if	O
(	O
progname	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
xargv	pointer
=	O
calloc	function
(	O
argc	long
+	O
1	int
,	O
sizeof	O
(	O
xargv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
!	O
xargv	pointer
)	O
return	O
ENOMEM	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
argc	long
;	O
i	int
++	O
)	O
{	O
xargv	pointer
[	O
i	int
]	O
=	O
strdup	function
(	O
argv	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
!	O
xargv	pointer
[	O
i	int
]	O
)	O
{	O
mu_argcv_free	function
(	O
i	int
,	O
argv	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
}	O
stream	pointer
=	O
(	O
mu_stream_t	pointer
)	O
_prog_stream_create	function
(	O
progname	pointer
,	O
argc	long
,	O
xargv	pointer
,	O
hint_flags	int
,	O
hints	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
!	O
stream	pointer
)	O
{	O
mu_argcv_free	function
(	O
argc	long
,	O
xargv	pointer
)	O
;	O
return	O
ENOMEM	int
;	O
}	O
rc	int
=	O
mu_stream_open	function
(	O
stream	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
else	O
*	O
pstream	pointer
=	O
stream	pointer
;	O
return	O
rc	int
;	O
}	O
int	O
mu_command_stream_create	function
(	O
mu_stream_t	pointer
*	O
pstream	pointer
,	O
const	O
char	O
*	O
command	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
;	O
mu_stream_t	pointer
stream	pointer
;	O
struct	O
mu_wordsplit	struct
ws	pointer
;	O
if	O
(	O
pstream	pointer
==	O
NULL	O
)	O
return	O
MU_ERR_OUT_PTR_NULL	O
;	O
if	O
(	O
command	pointer
==	O
NULL	O
)	O
return	O
EINVAL	int
;	O
ws	pointer
.	O
ws_comment	pointer
=	O
"#"	pointer
;	O
if	O
(	O
mu_wordsplit	struct
(	O
command	pointer
,	O
&	O
ws	pointer
,	O
MU_WRDSF_DEFFLAGS	O
|	O
MU_WRDSF_COMMENT	O
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"cannot split line `%s': %s"	pointer
)	O
,	O
command	pointer
,	O
mu_wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
return	O
errno	O
;	O
}	O
rc	int
=	O
mu_prog_stream_create	function
(	O
&	O
stream	pointer
,	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
,	O
ws	pointer
.	O
ws_wordc	long
,	O
ws	pointer
.	O
ws_wordv	pointer
,	O
0	int
,	O
NULL	O
,	O
flags	int
)	O
;	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
ws	pointer
.	O
ws_wordc	long
=	O
0	int
;	O
ws	pointer
.	O
ws_wordv	pointer
=	O
NULL	O
;	O
*	O
pstream	pointer
=	O
stream	pointer
;	O
}	O
mu_wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
