int	O
expand_undefined	int
;	O
static	O
inline	O
int	O
d2n	function
(	O
int	O
d	int
)	O
{	O
static	O
char	O
dig	array
[	O
]	O
=	O
"0123456789"	pointer
;	O
return	O
strchr	function
(	O
dig	array
,	O
d	int
)	O
-	O
dig	array
;	O
}	O
static	O
int	O
refno	function
(	O
char	O
const	O
*	O
input	pointer
,	O
int	O
*	O
len	long
)	O
{	O
if	O
(	O
c_isdigit	function
(	O
input	pointer
[	O
1	int
]	O
)	O
)	O
{	O
*	O
len	long
=	O
2	int
;	O
return	O
d2n	function
(	O
input	pointer
[	O
1	int
]	O
)	O
;	O
}	O
else	O
if	O
(	O
input	pointer
[	O
1	int
]	O
==	O
'{'	O
)	O
{	O
char	O
const	O
*	O
p	pointer
=	O
input	pointer
+	O
1	int
;	O
int	O
n	long
=	O
0	int
;	O
while	O
(	O
*	O
++	O
p	pointer
&&	O
c_isdigit	function
(	O
*	O
p	pointer
)	O
)	O
n	long
=	O
n	long
*	O
10	int
+	O
d2n	function
(	O
*	O
p	pointer
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
'}'	O
&&	O
p	pointer
>	O
&	O
input	pointer
[	O
1	int
]	O
)	O
{	O
*	O
len	long
=	O
p	pointer
-	O
input	pointer
+	O
1	int
;	O
return	O
n	long
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
char	O
*	O
expandref	function
(	O
char	O
const	O
*	O
input	pointer
,	O
struct	O
rush_backref	struct
*	O
backref	array
,	O
char	O
*	O
pfx	pointer
)	O
{	O
char	O
*	O
output	pointer
;	O
size_t	long
output_len	long
=	O
strlen	function
(	O
input	pointer
)	O
+	O
1	int
;	O
size_t	long
istart	long
=	O
0	int
,	O
ostart	long
=	O
0	int
;	O
output	pointer
=	O
xmalloc	function
(	O
output_len	long
)	O
;	O
while	O
(	O
input	pointer
[	O
istart	long
]	O
)	O
{	O
size_t	long
len	long
=	O
strcspn	function
(	O
input	pointer
+	O
istart	long
,	O
pfx	pointer
)	O
;	O
int	O
n	long
,	O
i	int
;	O
while	O
(	O
ostart	long
+	O
len	long
>=	O
output_len	long
)	O
output	pointer
=	O
x2realloc	function
(	O
output	pointer
,	O
&	O
output_len	long
)	O
;	O
memcpy	function
(	O
output	pointer
+	O
ostart	long
,	O
input	pointer
+	O
istart	long
,	O
len	long
)	O
;	O
ostart	long
+=	O
len	long
;	O
istart	long
+=	O
len	long
;	O
if	O
(	O
!	O
input	pointer
[	O
istart	long
]	O
)	O
break	O
;	O
else	O
if	O
(	O
istart	long
>	O
1	int
&&	O
input	pointer
[	O
istart	long
-	O
1	int
]	O
==	O
'\\'	O
)	O
{	O
output	pointer
[	O
ostart	long
-	O
1	int
]	O
=	O
input	pointer
[	O
istart	long
]	O
;	O
istart	long
++	O
;	O
}	O
else	O
if	O
(	O
(	O
n	long
=	O
refno	function
(	O
input	pointer
+	O
istart	long
,	O
&	O
i	int
)	O
)	O
>=	O
0	int
&&	O
n	long
<	O
backref	array
->	O
nmatch	long
)	O
{	O
len	long
=	O
backref	array
->	O
match	pointer
[	O
n	long
]	O
.	O
rm_eo	long
-	O
backref	array
->	O
match	pointer
[	O
n	long
]	O
.	O
rm_so	long
;	O
while	O
(	O
ostart	long
+	O
len	long
>=	O
output_len	long
)	O
output	pointer
=	O
x2realloc	function
(	O
output	pointer
,	O
&	O
output_len	long
)	O
;	O
memcpy	function
(	O
output	pointer
+	O
ostart	long
,	O
backref	array
->	O
subject	pointer
+	O
backref	array
->	O
match	pointer
[	O
n	long
]	O
.	O
rm_so	long
,	O
len	long
)	O
;	O
ostart	long
+=	O
len	long
;	O
istart	long
+=	O
i	int
;	O
}	O
else	O
{	O
if	O
(	O
ostart	long
+	O
2	int
>=	O
output_len	long
)	O
output	pointer
=	O
x2realloc	function
(	O
output	pointer
,	O
&	O
output_len	long
)	O
;	O
memcpy	function
(	O
output	pointer
+	O
ostart	long
,	O
input	pointer
+	O
istart	long
,	O
2	int
)	O
;	O
ostart	long
+=	O
2	int
;	O
istart	long
+=	O
2	int
;	O
}	O
}	O
output	pointer
[	O
ostart	long
]	O
=	O
0	int
;	O
return	O
xrealloc	function
(	O
output	pointer
,	O
ostart	long
+	O
1	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
var_uid	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
static	O
char	O
buf	array
[	O
INT_BUFSIZE_BOUND	O
(	O
uintmax_t	long
)	O
]	O
;	O
return	O
umaxtostr	function
(	O
req	pointer
->	O
pw	pointer
->	O
pw_uid	int
,	O
buf	array
)	O
;	O
}	O
static	O
const	O
char	O
*	O
var_user	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
return	O
req	pointer
->	O
pw	pointer
->	O
pw_name	pointer
;	O
}	O
static	O
const	O
char	O
*	O
var_gid	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
static	O
char	O
buf	array
[	O
INT_BUFSIZE_BOUND	O
(	O
uintmax_t	long
)	O
]	O
;	O
return	O
umaxtostr	function
(	O
req	pointer
->	O
pw	pointer
->	O
pw_gid	int
,	O
buf	array
)	O
;	O
}	O
static	O
const	O
char	O
*	O
var_group	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
struct	O
group	struct
*	O
grp	pointer
=	O
getgrgid	function
(	O
req	pointer
->	O
pw	pointer
->	O
pw_gid	int
)	O
;	O
return	O
grp	pointer
?	O
grp	pointer
->	O
gr_name	pointer
:	O
var_gid	function
(	O
req	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
var_home	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
return	O
req	pointer
->	O
pw	pointer
->	O
pw_dir	pointer
;	O
}	O
static	O
const	O
char	O
*	O
var_gecos	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
return	O
req	pointer
->	O
pw	pointer
->	O
pw_gecos	pointer
;	O
}	O
static	O
const	O
char	O
*	O
var_program	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
return	O
PROGFILE	O
(	O
req	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
var_command	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
return	O
req	pointer
->	O
cmdline	pointer
;	O
}	O
struct	O
vardef	struct
{	O
char	O
*	O
name	pointer
;	O
const	O
char	O
*	O
(	O
*	O
expand	pointer
)	O
(	O
struct	O
rush_request	struct
*	O
)	O
;	O
enum	O
transform_target_type	enum
target	struct
;	O
}	O
;	O
static	O
struct	O
vardef	struct
request_vars	array
[	O
]	O
=	O
{	O
{	O
"user"	pointer
,	O
var_user	function
,	O
target_readonly	int
}	O
,	O
{	O
"group"	pointer
,	O
var_group	function
,	O
target_readonly	int
}	O
,	O
{	O
"uid"	pointer
,	O
var_uid	function
,	O
target_readonly	int
}	O
,	O
{	O
"gid"	pointer
,	O
var_gid	function
,	O
target_readonly	int
}	O
,	O
{	O
"home"	pointer
,	O
var_home	function
,	O
target_readonly	int
}	O
,	O
{	O
"gecos"	pointer
,	O
var_gecos	function
,	O
target_readonly	int
}	O
,	O
{	O
"program"	pointer
,	O
var_program	function
,	O
target_program	int
}	O
,	O
{	O
"command"	pointer
,	O
var_command	function
,	O
target_command	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
vardef	struct
const	O
*	O
find_request_var	function
(	O
char	O
const	O
*	O
name	pointer
)	O
{	O
struct	O
vardef	struct
*	O
vd	pointer
;	O
for	O
(	O
vd	pointer
=	O
request_vars	array
;	O
vd	pointer
->	O
name	pointer
;	O
vd	pointer
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
vd	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
vd	pointer
;	O
}	O
return	O
NULL	O
;	O
}	O
enum	O
transform_target_type	enum
rush_variable_target	function
(	O
char	O
const	O
*	O
varname	pointer
)	O
{	O
struct	O
vardef	struct
const	O
*	O
vd	pointer
=	O
find_request_var	function
(	O
varname	pointer
)	O
;	O
return	O
vd	pointer
?	O
vd	pointer
->	O
target	struct
:	O
target_var	int
;	O
}	O
static	O
char	O
*	O
*	O
find_user_varptr	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
,	O
char	O
const	O
*	O
var	pointer
,	O
size_t	long
len	long
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
req	pointer
->	O
var_count	long
;	O
i	int
+=	O
2	int
)	O
if	O
(	O
strlen	function
(	O
req	pointer
->	O
var_kv	pointer
[	O
i	int
]	O
)	O
==	O
len	long
&&	O
memcmp	function
(	O
req	pointer
->	O
var_kv	pointer
[	O
i	int
]	O
,	O
var	pointer
,	O
len	long
)	O
==	O
0	int
)	O
return	O
&	O
req	pointer
->	O
var_kv	pointer
[	O
i	int
+	O
1	int
]	O
;	O
return	O
NULL	O
;	O
}	O
char	O
*	O
*	O
rush_getvarptr	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
,	O
char	O
const	O
*	O
varname	pointer
)	O
{	O
if	O
(	O
req	pointer
->	O
var_kv	pointer
)	O
{	O
char	O
*	O
*	O
ret	pointer
=	O
find_user_varptr	function
(	O
req	pointer
,	O
varname	pointer
,	O
strlen	function
(	O
varname	pointer
)	O
)	O
;	O
if	O
(	O
ret	pointer
)	O
return	O
ret	pointer
;	O
}	O
while	O
(	O
req	pointer
->	O
var_count	long
+	O
3	int
>=	O
req	pointer
->	O
var_max	long
)	O
req	pointer
->	O
var_kv	pointer
=	O
x2nrealloc	function
(	O
req	pointer
->	O
var_kv	pointer
,	O
&	O
req	pointer
->	O
var_max	long
,	O
sizeof	O
(	O
req	pointer
->	O
var_kv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
req	pointer
->	O
var_kv	pointer
[	O
req	pointer
->	O
var_count	long
++	O
]	O
=	O
xstrdup	function
(	O
varname	pointer
)	O
;	O
req	pointer
->	O
var_kv	pointer
[	O
req	pointer
->	O
var_count	long
++	O
]	O
=	O
NULL	O
;	O
req	pointer
->	O
var_kv	pointer
[	O
req	pointer
->	O
var_count	long
]	O
=	O
NULL	O
;	O
return	O
&	O
req	pointer
->	O
var_kv	pointer
[	O
req	pointer
->	O
var_count	long
-	O
1	int
]	O
;	O
}	O
void	O
rush_request_delvar	function
(	O
struct	O
rush_request	struct
*	O
req	pointer
,	O
char	O
const	O
*	O
varname	pointer
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
req	pointer
->	O
var_count	long
;	O
i	int
+=	O
2	int
)	O
{	O
if	O
(	O
strcmp	function
(	O
req	pointer
->	O
var_kv	pointer
[	O
i	int
]	O
,	O
varname	pointer
)	O
==	O
0	int
)	O
{	O
free	function
(	O
req	pointer
->	O
var_kv	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
req	pointer
->	O
var_kv	pointer
[	O
i	int
+	O
1	int
]	O
)	O
;	O
memmove	function
(	O
req	pointer
->	O
var_kv	pointer
+	O
i	int
,	O
req	pointer
->	O
var_kv	pointer
+	O
i	int
+	O
2	int
,	O
(	O
req	pointer
->	O
var_count	long
-	O
(	O
i	int
+	O
2	int
)	O
+	O
1	int
)	O
*	O
sizeof	O
req	pointer
->	O
var_kv	pointer
[	O
0	int
]	O
)	O
;	O
req	pointer
->	O
var_count	long
-=	O
2	int
;	O
break	O
;	O
}	O
}	O
}	O
static	O
int	O
getvar	function
(	O
char	O
*	O
*	O
ret	pointer
,	O
const	O
char	O
*	O
var	pointer
,	O
size_t	long
len	long
,	O
void	O
*	O
clos	pointer
)	O
{	O
struct	O
rush_request	struct
*	O
req	pointer
=	O
clos	pointer
;	O
const	O
char	O
*	O
s	long
=	O
NULL	O
;	O
char	O
*	O
p	pointer
;	O
struct	O
vardef	struct
*	O
vd	pointer
;	O
for	O
(	O
vd	pointer
=	O
request_vars	array
;	O
vd	pointer
->	O
name	pointer
;	O
vd	pointer
++	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
vd	pointer
->	O
name	pointer
,	O
var	pointer
,	O
len	long
)	O
==	O
0	int
)	O
{	O
s	long
=	O
vd	pointer
->	O
expand	pointer
(	O
clos	pointer
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
s	long
&&	O
req	pointer
->	O
var_kv	pointer
)	O
{	O
char	O
*	O
*	O
ptr	pointer
=	O
find_user_varptr	function
(	O
req	pointer
,	O
var	pointer
,	O
len	long
)	O
;	O
if	O
(	O
ptr	pointer
)	O
s	long
=	O
*	O
ptr	pointer
;	O
}	O
if	O
(	O
!	O
s	long
)	O
return	O
WRDSE_UNDEF	int
;	O
p	pointer
=	O
strdup	function
(	O
s	long
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
return	O
WRDSE_NOSPACE	int
;	O
*	O
ret	pointer
=	O
p	pointer
;	O
return	O
WRDSE_OK	int
;	O
}	O
void	O
rush_ws_error	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vlogmsg	function
(	O
LOG_ERR	int
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
}	O
char	O
*	O
rush_expand_string	function
(	O
const	O
char	O
*	O
string	pointer
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
struct	O
wordsplit	struct
ws	pointer
;	O
int	O
wsflags	int
=	O
WRDSF_NOSPLIT	int
|	O
WRDSF_NOCMD	int
|	O
(	O
expand_undefined	int
?	O
0	int
:	O
WRDSF_UNDEF	int
)	O
|	O
WRDSF_ENV	int
|	O
WRDSF_GETVAR	int
|	O
WRDSF_CLOSURE	int
|	O
WRDSF_ERROR	int
|	O
WRDSF_OPTIONS	int
;	O
char	O
*	O
result	pointer
;	O
ws	pointer
.	O
ws_getvar	pointer
=	O
getvar	function
;	O
ws	pointer
.	O
ws_closure	pointer
=	O
req	pointer
;	O
ws	pointer
.	O
ws_paramv	pointer
=	O
(	O
char	O
const	O
*	O
*	O
)	O
req	pointer
->	O
argv	pointer
;	O
ws	pointer
.	O
ws_paramc	long
=	O
req	pointer
->	O
argc	int
;	O
ws	pointer
.	O
ws_error	pointer
=	O
rush_ws_error	function
;	O
ws	pointer
.	O
ws_options	int
=	O
WRDSO_BSKEEP_QUOTE	int
|	O
WRDSO_NOCMDSPLIT	int
|	O
WRDSO_PARAMV	int
|	O
WRDSO_PARAM_NEGIDX	int
|	O
WRDSO_GETVARPREF	int
;	O
ws	pointer
.	O
ws_env	pointer
=	O
(	O
char	O
const	O
*	O
*	O
)	O
req	pointer
->	O
env	pointer
;	O
result	pointer
=	O
expandref	function
(	O
string	pointer
,	O
&	O
req	pointer
->	O
backref	array
[	O
req	pointer
->	O
backref_cur	int
]	O
,	O
"%"	pointer
)	O
;	O
switch	O
(	O
wordsplit	struct
(	O
result	pointer
,	O
&	O
ws	pointer
,	O
wsflags	int
)	O
)	O
{	O
case	O
0	int
:	O
break	O
;	O
case	O
WRDSE_UNDEF	int
:	O
die	function
(	O
config_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
"%s: %s"	pointer
,	O
wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
,	O
ws	pointer
.	O
ws_errctx	pointer
)	O
;	O
break	O
;	O
default	O
:	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
"%s"	pointer
,	O
wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
}	O
free	function
(	O
result	pointer
)	O
;	O
result	pointer
=	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
;	O
ws	pointer
.	O
ws_wordv	pointer
[	O
0	int
]	O
=	O
NULL	O
;	O
if	O
(	O
ws	pointer
.	O
ws_envbuf	pointer
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
req	pointer
->	O
env_count	long
;	O
i	int
++	O
)	O
free	function
(	O
req	pointer
->	O
env	pointer
[	O
i	int
]	O
)	O
;	O
req	pointer
->	O
env_count	long
=	O
0	int
;	O
if	O
(	O
req	pointer
->	O
env_max	long
<	O
ws	pointer
.	O
ws_envidx	long
+	O
1	int
)	O
{	O
req	pointer
->	O
env	pointer
=	O
xrealloc	function
(	O
req	pointer
->	O
env	pointer
,	O
(	O
ws	pointer
.	O
ws_envidx	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
req	pointer
->	O
env	pointer
[	O
0	int
]	O
)	O
)	O
;	O
req	pointer
->	O
env_max	long
=	O
ws	pointer
.	O
ws_envidx	long
+	O
1	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ws	pointer
.	O
ws_envidx	long
;	O
i	int
++	O
)	O
{	O
size_t	long
len	long
=	O
strcspn	function
(	O
ws	pointer
.	O
ws_envbuf	pointer
[	O
i	int
]	O
,	O
"="	pointer
)	O
;	O
char	O
*	O
*	O
ptr	pointer
=	O
find_user_varptr	function
(	O
req	pointer
,	O
ws	pointer
.	O
ws_envbuf	pointer
[	O
i	int
]	O
,	O
len	long
)	O
;	O
if	O
(	O
ptr	pointer
)	O
{	O
free	function
(	O
*	O
ptr	pointer
)	O
;	O
*	O
ptr	pointer
=	O
xstrdup	function
(	O
ws	pointer
.	O
ws_envbuf	pointer
[	O
i	int
]	O
+	O
len	long
+	O
1	int
)	O
;	O
free	function
(	O
ws	pointer
.	O
ws_envbuf	pointer
[	O
i	int
]	O
)	O
;	O
}	O
else	O
{	O
req	pointer
->	O
env	pointer
[	O
req	pointer
->	O
env_count	long
++	O
]	O
=	O
ws	pointer
.	O
ws_envbuf	pointer
[	O
i	int
]	O
;	O
}	O
}	O
req	pointer
->	O
env	pointer
[	O
req	pointer
->	O
env_count	long
]	O
=	O
NULL	O
;	O
free	function
(	O
ws	pointer
.	O
ws_envbuf	pointer
)	O
;	O
ws	pointer
.	O
ws_envbuf	pointer
=	O
NULL	O
;	O
ws	pointer
.	O
ws_envidx	long
=	O
0	int
;	O
ws	pointer
.	O
ws_envsiz	long
=	O
0	int
;	O
}	O
wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
return	O
result	pointer
;	O
}	O
char	O
*	O
map_string	function
(	O
struct	O
rush_map	struct
*	O
map	struct
,	O
struct	O
rush_request	struct
*	O
req	pointer
)	O
{	O
char	O
*	O
file	pointer
;	O
FILE	struct
*	O
fp	pointer
;	O
struct	O
stat	struct
st	pointer
;	O
char	O
*	O
buf	array
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
;	O
size_t	long
line	int
=	O
0	int
;	O
char	O
*	O
key	pointer
;	O
char	O
*	O
ret	pointer
=	O
NULL	O
;	O
file	pointer
=	O
expand_tilde	function
(	O
map	struct
->	O
file	pointer
,	O
req	pointer
->	O
pw	pointer
->	O
pw_dir	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
file	pointer
,	O
&	O
st	pointer
)	O
)	O
{	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"cannot stat file %s: %s"	pointer
)	O
,	O
file	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
if	O
(	O
check_config_permissions	function
(	O
file	pointer
,	O
&	O
st	pointer
)	O
)	O
die	function
(	O
config_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"%s: file is not safe"	pointer
)	O
,	O
file	pointer
)	O
;	O
fp	pointer
=	O
fopen	function
(	O
file	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"%s: cannot open map file"	pointer
)	O
,	O
file	pointer
)	O
;	O
key	pointer
=	O
rush_expand_string	function
(	O
map	struct
->	O
key	pointer
,	O
req	pointer
)	O
;	O
while	O
(	O
getline	function
(	O
&	O
buf	array
,	O
&	O
size	long
,	O
fp	pointer
)	O
!=	O
-	O
1	int
)	O
{	O
size_t	long
len	long
;	O
struct	O
wordsplit	struct
ws	pointer
;	O
line	int
++	O
;	O
len	long
=	O
strlen	function
(	O
buf	array
)	O
;	O
while	O
(	O
len	long
>	O
0	int
&&	O
buf	array
[	O
len	long
-	O
1	int
]	O
==	O
'\n'	O
)	O
buf	array
[	O
--	O
len	long
]	O
=	O
0	int
;	O
ws	pointer
.	O
ws_delim	pointer
=	O
map	struct
->	O
delim	pointer
;	O
if	O
(	O
wordsplit	struct
(	O
buf	array
,	O
&	O
ws	pointer
,	O
WRDSF_NOVAR	int
|	O
WRDSF_NOCMD	int
|	O
WRDSF_DELIM	int
)	O
)	O
die	function
(	O
system_error	int
,	O
&	O
req	pointer
->	O
i18n	struct
,	O
_	O
(	O
"%s:%lu: failed to parse line: %s"	pointer
)	O
,	O
file	pointer
,	O
(	O
unsigned	O
long	O
)	O
line	int
,	O
wordsplit_strerror	function
(	O
&	O
ws	pointer
)	O
)	O
;	O
if	O
(	O
map	struct
->	O
key_field	int
<=	O
ws	pointer
.	O
ws_wordc	long
&&	O
map	struct
->	O
val_field	int
<=	O
ws	pointer
.	O
ws_wordc	long
&&	O
strcmp	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
map	struct
->	O
key_field	int
-	O
1	int
]	O
,	O
key	pointer
)	O
==	O
0	int
)	O
ret	pointer
=	O
xstrdup	function
(	O
ws	pointer
.	O
ws_wordv	pointer
[	O
map	struct
->	O
val_field	int
-	O
1	int
]	O
)	O
;	O
wordsplit_free	function
(	O
&	O
ws	pointer
)	O
;	O
if	O
(	O
ret	pointer
)	O
break	O
;	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
free	function
(	O
key	pointer
)	O
;	O
free	function
(	O
file	pointer
)	O
;	O
if	O
(	O
!	O
ret	pointer
&&	O
map	struct
->	O
defval	pointer
)	O
ret	pointer
=	O
xstrdup	function
(	O
map	struct
->	O
defval	pointer
)	O
;	O
return	O
ret	pointer
;	O
}	O
