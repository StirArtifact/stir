kern_return_t	O
_pager_do_write_request	function
(	O
struct	O
pager	struct
*	O
p	pointer
,	O
mach_port_t	O
control	int
,	O
vm_offset_t	int
offset	int
,	O
pointer_t	O
data	int
,	O
vm_size_t	int
length	int
,	O
int	O
dirty	int
,	O
int	O
kcopy	int
,	O
int	O
initializing	int
)	O
{	O
short	O
*	O
pm_entries	pointer
;	O
int	O
npages	int
,	O
i	int
;	O
char	O
*	O
notified	pointer
;	O
error_t	int
*	O
pagerrs	O
;	O
struct	O
lock_request	struct
*	O
lr	pointer
;	O
struct	O
lock_list	struct
{	O
struct	O
lock_request	struct
*	O
lr	pointer
;	O
struct	O
lock_list	struct
*	O
next	pointer
;	O
}	O
*	O
lock_list	struct
,	O
*	O
ll	pointer
;	O
int	O
wakeup	int
;	O
int	O
omitdata	int
=	O
0	int
;	O
if	O
(	O
!	O
p	pointer
||	O
p	pointer
->	O
port	struct
.	O
class	O
!=	O
_pager_class	pointer
)	O
return	O
EOPNOTSUPP	O
;	O
pthread_mutex_lock	function
(	O
&	O
p	pointer
->	O
interlock	int
)	O
;	O
if	O
(	O
control	int
!=	O
p	pointer
->	O
memobjcntl	int
)	O
{	O
printf	O
(	O
"incg data return: wrong control port\n"	pointer
)	O
;	O
goto	O
release_out	O
;	O
}	O
if	O
(	O
length	int
%	O
__vm_page_size	O
)	O
{	O
printf	O
(	O
"incg data return: bad length size %zd\n"	pointer
,	O
length	int
)	O
;	O
goto	O
release_out	O
;	O
}	O
if	O
(	O
offset	int
%	O
__vm_page_size	O
)	O
{	O
printf	O
(	O
"incg data return: misaligned request\n"	pointer
)	O
;	O
goto	O
release_out	O
;	O
}	O
if	O
(	O
p	pointer
->	O
pager_state	enum
!=	O
NORMAL	int
)	O
{	O
printf	O
(	O
"pager in wrong state for write\n"	pointer
)	O
;	O
goto	O
release_out	O
;	O
}	O
npages	int
=	O
length	int
/	O
__vm_page_size	O
;	O
pagerrs	O
=	O
alloca	O
(	O
npages	int
*	O
sizeof	O
(	O
error_t	int
)	O
)	O
;	O
notified	pointer
=	O
alloca	O
(	O
npages	int
*	O
(	O
sizeof	O
*	O
notified	pointer
)	O
)	O
;	O
memset	O
(	O
notified	pointer
,	O
-	O
1	int
,	O
npages	int
*	O
(	O
sizeof	O
*	O
notified	pointer
)	O
)	O
;	O
_pager_block_termination	function
(	O
p	pointer
)	O
;	O
_pager_pagemap_resize	function
(	O
p	pointer
,	O
offset	int
+	O
length	int
)	O
;	O
pm_entries	pointer
=	O
&	O
p	pointer
->	O
pagemap	pointer
[	O
offset	int
/	O
__vm_page_size	O
]	O
;	O
if	O
(	O
!	O
dirty	int
)	O
{	O
munmap	function
(	O
(	O
void	O
*	O
)	O
data	int
,	O
length	int
)	O
;	O
if	O
(	O
!	O
kcopy	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
notified	pointer
[	O
i	int
]	O
=	O
(	O
p	pointer
->	O
notify_on_evict	int
&&	O
!	O
(	O
pm_entries	pointer
[	O
i	int
]	O
&	O
PM_PAGEINWAIT	int
)	O
)	O
;	O
goto	O
notify	O
;	O
}	O
else	O
{	O
_pager_allow_termination	function
(	O
p	pointer
)	O
;	O
goto	O
release_out	O
;	O
}	O
}	O
retry	O
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
if	O
(	O
pm_entries	pointer
[	O
i	int
]	O
&	O
PM_PAGINGOUT	int
)	O
{	O
pm_entries	pointer
[	O
i	int
]	O
|=	O
PM_WRITEWAIT	int
;	O
pthread_cond_wait	function
(	O
&	O
p	pointer
->	O
wakeup	int
,	O
&	O
p	pointer
->	O
interlock	int
)	O
;	O
goto	O
retry	O
;	O
}	O
if	O
(	O
initializing	int
)	O
{	O
assert	function
(	O
npages	int
<=	O
32	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
pm_entries	pointer
[	O
i	int
]	O
&	O
PM_INIT	int
)	O
omitdata	int
|=	O
1	int
<<	O
i	int
;	O
else	O
pm_entries	pointer
[	O
i	int
]	O
|=	O
PM_PAGINGOUT	int
|	O
PM_INIT	int
;	O
}	O
}	O
else	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
pm_entries	pointer
[	O
i	int
]	O
|=	O
PM_PAGINGOUT	int
|	O
PM_INIT	int
;	O
lock_list	struct
=	O
0	int
;	O
for	O
(	O
lr	pointer
=	O
p	pointer
->	O
lock_requests	pointer
;	O
lr	pointer
;	O
lr	pointer
=	O
lr	pointer
->	O
next	pointer
)	O
if	O
(	O
offset	int
<	O
lr	pointer
->	O
end	int
&&	O
offset	int
+	O
length	int
>=	O
lr	pointer
->	O
start	int
)	O
{	O
ll	pointer
=	O
alloca	O
(	O
sizeof	O
(	O
struct	O
lock_list	struct
)	O
)	O
;	O
ll	pointer
->	O
lr	pointer
=	O
lr	pointer
;	O
ll	pointer
->	O
next	pointer
=	O
lock_list	struct
;	O
lock_list	struct
=	O
ll	pointer
;	O
lr	pointer
->	O
pending_writes	int
++	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
p	pointer
->	O
interlock	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
if	O
(	O
!	O
(	O
omitdata	int
&	O
(	O
1	int
<<	O
i	int
)	O
)	O
)	O
pagerrs	O
[	O
i	int
]	O
=	O
pager_write_page	function
(	O
p	pointer
->	O
upi	pointer
,	O
offset	int
+	O
(	O
vm_page_size	O
*	O
i	int
)	O
,	O
data	int
+	O
(	O
vm_page_size	O
*	O
i	int
)	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
p	pointer
->	O
interlock	int
)	O
;	O
_pager_pagemap_resize	function
(	O
p	pointer
,	O
offset	int
+	O
length	int
)	O
;	O
pm_entries	pointer
=	O
&	O
p	pointer
->	O
pagemap	pointer
[	O
offset	int
/	O
__vm_page_size	O
]	O
;	O
wakeup	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
omitdata	int
&	O
(	O
1	int
<<	O
i	int
)	O
)	O
{	O
notified	pointer
[	O
i	int
]	O
=	O
0	int
;	O
continue	O
;	O
}	O
if	O
(	O
pm_entries	pointer
[	O
i	int
]	O
&	O
PM_WRITEWAIT	int
)	O
wakeup	int
=	O
1	int
;	O
if	O
(	O
pagerrs	O
[	O
i	int
]	O
&&	O
!	O
(	O
pm_entries	pointer
[	O
i	int
]	O
&	O
PM_PAGEINWAIT	int
)	O
)	O
pm_entries	pointer
[	O
i	int
]	O
|=	O
PM_INVALID	int
;	O
if	O
(	O
pm_entries	pointer
[	O
i	int
]	O
&	O
PM_PAGEINWAIT	int
)	O
{	O
memory_object_data_supply	function
(	O
p	pointer
->	O
memobjcntl	int
,	O
offset	int
+	O
(	O
vm_page_size	O
*	O
i	int
)	O
,	O
data	int
+	O
(	O
vm_page_size	O
*	O
i	int
)	O
,	O
vm_page_size	O
,	O
1	int
,	O
VM_PROT_NONE	O
,	O
0	int
,	O
MACH_PORT_NULL	O
)	O
;	O
notified	pointer
[	O
i	int
]	O
=	O
0	int
;	O
}	O
else	O
{	O
munmap	function
(	O
(	O
void	O
*	O
)	O
(	O
data	int
+	O
(	O
vm_page_size	O
*	O
i	int
)	O
)	O
,	O
vm_page_size	O
)	O
;	O
notified	pointer
[	O
i	int
]	O
=	O
(	O
!	O
kcopy	int
&&	O
p	pointer
->	O
notify_on_evict	int
)	O
;	O
if	O
(	O
!	O
kcopy	int
)	O
pm_entries	pointer
[	O
i	int
]	O
&=	O
~	O
PM_INCORE	int
;	O
}	O
pm_entries	pointer
[	O
i	int
]	O
&=	O
~	O
(	O
PM_PAGINGOUT	int
|	O
PM_PAGEINWAIT	int
|	O
PM_WRITEWAIT	int
)	O
;	O
}	O
for	O
(	O
ll	pointer
=	O
lock_list	struct
;	O
ll	pointer
;	O
ll	pointer
=	O
ll	pointer
->	O
next	pointer
)	O
if	O
(	O
!	O
--	O
ll	pointer
->	O
lr	pointer
->	O
pending_writes	int
&&	O
!	O
ll	pointer
->	O
lr	pointer
->	O
locks_pending	int
)	O
wakeup	int
=	O
1	int
;	O
if	O
(	O
wakeup	int
)	O
pthread_cond_broadcast	function
(	O
&	O
p	pointer
->	O
wakeup	int
)	O
;	O
notify	O
:	O
_pager_allow_termination	function
(	O
p	pointer
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
p	pointer
->	O
interlock	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
npages	int
;	O
i	int
++	O
)	O
{	O
assert	function
(	O
notified	pointer
[	O
i	int
]	O
==	O
0	int
||	O
notified	pointer
[	O
i	int
]	O
==	O
1	int
)	O
;	O
if	O
(	O
notified	pointer
[	O
i	int
]	O
)	O
{	O
short	O
*	O
pm_entry	pointer
=	O
&	O
pm_entries	pointer
[	O
i	int
]	O
;	O
pager_notify_evict	function
(	O
p	pointer
->	O
upi	pointer
,	O
offset	int
+	O
(	O
i	int
*	O
vm_page_size	O
)	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
p	pointer
->	O
interlock	int
)	O
;	O
*	O
pm_entry	pointer
=	O
SET_PM_ERROR	O
(	O
SET_PM_NEXTERROR	O
(	O
*	O
pm_entry	pointer
,	O
0	int
)	O
,	O
0	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
p	pointer
->	O
interlock	int
)	O
;	O
}	O
}	O
return	O
0	int
;	O
release_out	O
:	O
pthread_mutex_unlock	function
(	O
&	O
p	pointer
->	O
interlock	int
)	O
;	O
return	O
0	int
;	O
}	O
kern_return_t	O
_pager_S_memory_object_data_return	function
(	O
struct	O
pager	struct
*	O
p	pointer
,	O
mach_port_t	O
control	int
,	O
vm_offset_t	int
offset	int
,	O
pointer_t	O
data	int
,	O
vm_size_t	int
length	int
,	O
int	O
dirty	int
,	O
int	O
kcopy	int
)	O
{	O
return	O
_pager_do_write_request	function
(	O
p	pointer
,	O
control	int
,	O
offset	int
,	O
data	int
,	O
length	int
,	O
dirty	int
,	O
kcopy	int
,	O
0	int
)	O
;	O
}	O
