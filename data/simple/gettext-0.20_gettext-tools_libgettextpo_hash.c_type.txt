typedef	O
struct	O
hash_entry	O
{	O
unsigned	O
long	O
used	O
;	O
const	O
void	O
*	O
key	pointer
;	O
size_t	O
keylen	int
;	O
void	O
*	O
data	pointer
;	O
struct	O
hash_entry	O
*	O
next	O
;	O
}	O
hash_entry	O
;	O
static	O
int	O
is_prime	function
(	O
unsigned	O
long	O
int	O
candidate	long
)	O
{	O
unsigned	O
long	O
int	O
divn	long
=	O
3	int
;	O
unsigned	O
long	O
int	O
sq	long
=	O
divn	long
*	O
divn	long
;	O
while	O
(	O
sq	long
<	O
candidate	long
&&	O
candidate	long
%	O
divn	long
!=	O
0	int
)	O
{	O
++	O
divn	long
;	O
sq	long
+=	O
4	int
*	O
divn	long
;	O
++	O
divn	long
;	O
}	O
return	O
candidate	long
%	O
divn	long
!=	O
0	int
;	O
}	O
unsigned	O
long	O
next_prime	O
(	O
unsigned	O
long	O
int	O
seed	long
)	O
{	O
seed	long
|=	O
1	int
;	O
while	O
(	O
!	O
is_prime	function
(	O
seed	long
)	O
)	O
seed	long
+=	O
2	int
;	O
return	O
seed	long
;	O
}	O
int	O
hash_init	O
(	O
hash_table	O
*	O
htab	pointer
,	O
unsigned	O
long	O
int	O
init_size	long
)	O
{	O
init_size	long
=	O
next_prime	O
(	O
init_size	long
)	O
;	O
htab	pointer
->	O
size	O
=	O
init_size	long
;	O
htab	pointer
->	O
filled	O
=	O
0	int
;	O
htab	pointer
->	O
first	O
=	O
NULL	O
;	O
htab	pointer
->	O
table	O
=	O
XCALLOC	function
(	O
init_size	long
+	O
1	int
,	O
hash_entry	O
)	O
;	O
obstack_init	function
(	O
&	O
htab	pointer
->	O
mem_pool	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
hash_destroy	O
(	O
hash_table	O
*	O
htab	pointer
)	O
{	O
free	function
(	O
htab	pointer
->	O
table	O
)	O
;	O
obstack_free	function
(	O
&	O
htab	pointer
->	O
mem_pool	O
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
unsigned	O
long	O
compute_hashval	function
(	O
const	O
void	O
*	O
key	pointer
,	O
size_t	O
keylen	int
)	O
{	O
size_t	O
cnt	O
;	O
unsigned	O
long	O
int	O
hval	long
;	O
cnt	O
=	O
0	int
;	O
hval	long
=	O
keylen	int
;	O
while	O
(	O
cnt	O
<	O
keylen	int
)	O
{	O
hval	long
=	O
(	O
hval	long
<<	O
9	int
)	O
|	O
(	O
hval	long
>>	O
(	O
sizeof	O
(	O
unsigned	O
long	O
)	O
*	O
CHAR_BIT	O
-	O
9	int
)	O
)	O
;	O
hval	long
+=	O
(	O
unsigned	O
long	O
int	O
)	O
*	O
(	O
(	O
(	O
const	O
char	O
*	O
)	O
key	pointer
)	O
+	O
cnt	O
++	O
)	O
;	O
}	O
return	O
hval	long
!=	O
0	int
?	O
hval	long
:	O
~	O
(	O
(	O
unsigned	O
long	O
)	O
0	int
)	O
;	O
}	O
static	O
size_t	O
lookup	function
(	O
hash_table	O
*	O
htab	pointer
,	O
const	O
void	O
*	O
key	pointer
,	O
size_t	O
keylen	int
,	O
unsigned	O
long	O
int	O
hval	long
)	O
{	O
unsigned	O
long	O
int	O
hash	long
;	O
size_t	O
idx	int
;	O
hash_entry	O
*	O
table	O
=	O
htab	pointer
->	O
table	O
;	O
hash	long
=	O
1	int
+	O
hval	long
%	O
htab	pointer
->	O
size	O
;	O
idx	int
=	O
hash	long
;	O
if	O
(	O
table	O
[	O
idx	int
]	O
.	O
used	O
)	O
{	O
if	O
(	O
table	O
[	O
idx	int
]	O
.	O
used	O
==	O
hval	long
&&	O
table	O
[	O
idx	int
]	O
.	O
keylen	int
==	O
keylen	int
&&	O
memcmp	O
(	O
table	O
[	O
idx	int
]	O
.	O
key	pointer
,	O
key	pointer
,	O
keylen	int
)	O
==	O
0	int
)	O
return	O
idx	int
;	O
hash	long
=	O
1	int
+	O
hval	long
%	O
(	O
htab	pointer
->	O
size	O
-	O
2	int
)	O
;	O
do	O
{	O
if	O
(	O
idx	int
<=	O
hash	long
)	O
idx	int
=	O
htab	pointer
->	O
size	O
+	O
idx	int
-	O
hash	long
;	O
else	O
idx	int
-=	O
hash	long
;	O
if	O
(	O
table	O
[	O
idx	int
]	O
.	O
used	O
==	O
hval	long
&&	O
table	O
[	O
idx	int
]	O
.	O
keylen	int
==	O
keylen	int
&&	O
memcmp	O
(	O
table	O
[	O
idx	int
]	O
.	O
key	pointer
,	O
key	pointer
,	O
keylen	int
)	O
==	O
0	int
)	O
return	O
idx	int
;	O
}	O
while	O
(	O
table	O
[	O
idx	int
]	O
.	O
used	O
)	O
;	O
}	O
return	O
idx	int
;	O
}	O
int	O
hash_find_entry	O
(	O
hash_table	O
*	O
htab	pointer
,	O
const	O
void	O
*	O
key	pointer
,	O
size_t	O
keylen	int
,	O
void	O
*	O
*	O
result	pointer
)	O
{	O
hash_entry	O
*	O
table	O
=	O
htab	pointer
->	O
table	O
;	O
size_t	O
idx	int
=	O
lookup	function
(	O
htab	pointer
,	O
key	pointer
,	O
keylen	int
,	O
compute_hashval	function
(	O
key	pointer
,	O
keylen	int
)	O
)	O
;	O
if	O
(	O
table	O
[	O
idx	int
]	O
.	O
used	O
==	O
0	int
)	O
return	O
-	O
1	int
;	O
*	O
result	pointer
=	O
table	O
[	O
idx	int
]	O
.	O
data	pointer
;	O
return	O
0	int
;	O
}	O
static	O
void	O
insert_entry_2	function
(	O
hash_table	O
*	O
htab	pointer
,	O
const	O
void	O
*	O
key	pointer
,	O
size_t	O
keylen	int
,	O
unsigned	O
long	O
int	O
hval	long
,	O
size_t	O
idx	int
,	O
void	O
*	O
data	pointer
)	O
{	O
hash_entry	O
*	O
table	O
=	O
htab	pointer
->	O
table	O
;	O
table	O
[	O
idx	int
]	O
.	O
used	O
=	O
hval	long
;	O
table	O
[	O
idx	int
]	O
.	O
key	pointer
=	O
key	pointer
;	O
table	O
[	O
idx	int
]	O
.	O
keylen	int
=	O
keylen	int
;	O
table	O
[	O
idx	int
]	O
.	O
data	pointer
=	O
data	pointer
;	O
if	O
(	O
htab	pointer
->	O
first	O
==	O
NULL	O
)	O
{	O
table	O
[	O
idx	int
]	O
.	O
next	O
=	O
&	O
table	O
[	O
idx	int
]	O
;	O
htab	pointer
->	O
first	O
=	O
&	O
table	O
[	O
idx	int
]	O
;	O
}	O
else	O
{	O
table	O
[	O
idx	int
]	O
.	O
next	O
=	O
htab	pointer
->	O
first	O
->	O
next	O
;	O
htab	pointer
->	O
first	O
->	O
next	O
=	O
&	O
table	O
[	O
idx	int
]	O
;	O
htab	pointer
->	O
first	O
=	O
&	O
table	O
[	O
idx	int
]	O
;	O
}	O
++	O
htab	pointer
->	O
filled	O
;	O
}	O
static	O
void	O
resize	function
(	O
hash_table	O
*	O
htab	pointer
)	O
{	O
unsigned	O
long	O
int	O
old_size	long
=	O
htab	pointer
->	O
size	O
;	O
hash_entry	O
*	O
table	O
=	O
htab	pointer
->	O
table	O
;	O
size_t	O
idx	int
;	O
htab	pointer
->	O
size	O
=	O
next_prime	O
(	O
htab	pointer
->	O
size	O
*	O
2	int
)	O
;	O
htab	pointer
->	O
filled	O
=	O
0	int
;	O
htab	pointer
->	O
first	O
=	O
NULL	O
;	O
htab	pointer
->	O
table	O
=	O
XCALLOC	function
(	O
1	int
+	O
htab	pointer
->	O
size	O
,	O
hash_entry	O
)	O
;	O
for	O
(	O
idx	int
=	O
1	int
;	O
idx	int
<=	O
old_size	long
;	O
++	O
idx	int
)	O
if	O
(	O
table	O
[	O
idx	int
]	O
.	O
used	O
)	O
insert_entry_2	function
(	O
htab	pointer
,	O
table	O
[	O
idx	int
]	O
.	O
key	pointer
,	O
table	O
[	O
idx	int
]	O
.	O
keylen	int
,	O
table	O
[	O
idx	int
]	O
.	O
used	O
,	O
lookup	function
(	O
htab	pointer
,	O
table	O
[	O
idx	int
]	O
.	O
key	pointer
,	O
table	O
[	O
idx	int
]	O
.	O
keylen	int
,	O
table	O
[	O
idx	int
]	O
.	O
used	O
)	O
,	O
table	O
[	O
idx	int
]	O
.	O
data	pointer
)	O
;	O
free	function
(	O
table	O
)	O
;	O
}	O
const	O
void	O
*	O
hash_insert_entry	O
(	O
hash_table	O
*	O
htab	pointer
,	O
const	O
void	O
*	O
key	pointer
,	O
size_t	O
keylen	int
,	O
void	O
*	O
data	pointer
)	O
{	O
unsigned	O
long	O
int	O
hval	long
=	O
compute_hashval	function
(	O
key	pointer
,	O
keylen	int
)	O
;	O
hash_entry	O
*	O
table	O
=	O
htab	pointer
->	O
table	O
;	O
size_t	O
idx	int
=	O
lookup	function
(	O
htab	pointer
,	O
key	pointer
,	O
keylen	int
,	O
hval	long
)	O
;	O
if	O
(	O
table	O
[	O
idx	int
]	O
.	O
used	O
)	O
return	O
NULL	O
;	O
else	O
{	O
void	O
*	O
keycopy	pointer
=	O
obstack_copy	function
(	O
&	O
htab	pointer
->	O
mem_pool	O
,	O
key	pointer
,	O
keylen	int
)	O
;	O
insert_entry_2	function
(	O
htab	pointer
,	O
keycopy	pointer
,	O
keylen	int
,	O
hval	long
,	O
idx	int
,	O
data	pointer
)	O
;	O
if	O
(	O
100	int
*	O
htab	pointer
->	O
filled	O
>	O
75	int
*	O
htab	pointer
->	O
size	O
)	O
resize	function
(	O
htab	pointer
)	O
;	O
return	O
keycopy	pointer
;	O
}	O
}	O
int	O
hash_set_value	O
(	O
hash_table	O
*	O
htab	pointer
,	O
const	O
void	O
*	O
key	pointer
,	O
size_t	O
keylen	int
,	O
void	O
*	O
data	pointer
)	O
{	O
unsigned	O
long	O
int	O
hval	long
=	O
compute_hashval	function
(	O
key	pointer
,	O
keylen	int
)	O
;	O
hash_entry	O
*	O
table	O
=	O
htab	pointer
->	O
table	O
;	O
size_t	O
idx	int
=	O
lookup	function
(	O
htab	pointer
,	O
key	pointer
,	O
keylen	int
,	O
hval	long
)	O
;	O
if	O
(	O
table	O
[	O
idx	int
]	O
.	O
used	O
)	O
{	O
table	O
[	O
idx	int
]	O
.	O
data	pointer
=	O
data	pointer
;	O
return	O
0	int
;	O
}	O
else	O
{	O
void	O
*	O
keycopy	pointer
=	O
obstack_copy	function
(	O
&	O
htab	pointer
->	O
mem_pool	O
,	O
key	pointer
,	O
keylen	int
)	O
;	O
insert_entry_2	function
(	O
htab	pointer
,	O
keycopy	pointer
,	O
keylen	int
,	O
hval	long
,	O
idx	int
,	O
data	pointer
)	O
;	O
if	O
(	O
100	int
*	O
htab	pointer
->	O
filled	O
>	O
75	int
*	O
htab	pointer
->	O
size	O
)	O
resize	function
(	O
htab	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
int	O
hash_iterate	O
(	O
hash_table	O
*	O
htab	pointer
,	O
void	O
*	O
*	O
ptr	pointer
,	O
const	O
void	O
*	O
*	O
key	pointer
,	O
size_t	O
*	O
keylen	int
,	O
void	O
*	O
*	O
data	pointer
)	O
{	O
hash_entry	O
*	O
curr	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
htab	pointer
->	O
first	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
curr	O
=	O
htab	pointer
->	O
first	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
ptr	pointer
==	O
htab	pointer
->	O
first	O
)	O
return	O
-	O
1	int
;	O
curr	O
=	O
(	O
hash_entry	O
*	O
)	O
*	O
ptr	pointer
;	O
}	O
curr	O
=	O
curr	O
->	O
next	O
;	O
*	O
ptr	pointer
=	O
(	O
void	O
*	O
)	O
curr	O
;	O
*	O
key	pointer
=	O
curr	O
->	O
key	pointer
;	O
*	O
keylen	int
=	O
curr	O
->	O
keylen	int
;	O
*	O
data	pointer
=	O
curr	O
->	O
data	pointer
;	O
return	O
0	int
;	O
}	O
int	O
hash_iterate_modify	O
(	O
hash_table	O
*	O
htab	pointer
,	O
void	O
*	O
*	O
ptr	pointer
,	O
const	O
void	O
*	O
*	O
key	pointer
,	O
size_t	O
*	O
keylen	int
,	O
void	O
*	O
*	O
*	O
datap	pointer
)	O
{	O
hash_entry	O
*	O
curr	O
;	O
if	O
(	O
*	O
ptr	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
htab	pointer
->	O
first	O
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
curr	O
=	O
htab	pointer
->	O
first	O
;	O
}	O
else	O
{	O
if	O
(	O
*	O
ptr	pointer
==	O
htab	pointer
->	O
first	O
)	O
return	O
-	O
1	int
;	O
curr	O
=	O
(	O
hash_entry	O
*	O
)	O
*	O
ptr	pointer
;	O
}	O
curr	O
=	O
curr	O
->	O
next	O
;	O
*	O
ptr	pointer
=	O
(	O
void	O
*	O
)	O
curr	O
;	O
*	O
key	pointer
=	O
curr	O
->	O
key	pointer
;	O
*	O
keylen	int
=	O
curr	O
->	O
keylen	int
;	O
*	O
datap	pointer
=	O
&	O
curr	O
->	O
data	pointer
;	O
return	O
0	int
;	O
}	O
