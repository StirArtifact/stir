OBJID	long
EDMAPROC	O
_edma_newobj_basic_stage	function
(	O
CLASSID	long
IdC	long
,	O
CLASSID	long
isSIU	long
,	O
EPVoid	pointer
ConstPar	pointer
)	O
{	O
EUint32	long
i	long
;	O
OBJID	long
IdO	long
;	O
HMEM	long
h	long
;	O
if	O
(	O
ProcMapTable	pointer
[	O
IdC	long
]	O
!=	O
CLASS_LOADED	int
)	O
if	O
(	O
(	O
edma_load_class_imp	function
(	O
IdC	long
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[new_obj_basic_stage] Can't load "	pointer
"class '%s' implementation"	pointer
,	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
obj_mutex	union
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
nMaxObj	long
;	O
i	long
++	O
)	O
if	O
(	O
gObj	O
[	O
(	O
nObj	long
+	O
i	long
)	O
%	O
nMaxObj	long
]	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
==	O
nMaxObj	long
)	O
{	O
if	O
(	O
(	O
hSObj	long
=	O
edma_prealloc	function
(	O
hSObj	long
,	O
sizeof	O
(	O
OBJ	struct
*	O
)	O
*	O
(	O
nMaxObj	long
+	O
OBJ_INC	int
)	O
)	O
)	O
==	O
(	O
HMEM	long
)	O
0	int
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
obj_mutex	union
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
"[edma_new_obj_basic_stage] "	pointer
"Can't create more objects"	pointer
)	O
;	O
}	O
SObject	pointer
=	O
edma_pget	function
(	O
hSObj	long
)	O
;	O
memset	function
(	O
(	O
SObject	pointer
+	O
nMaxObj	long
)	O
,	O
0	int
,	O
OBJ_INC	int
*	O
sizeof	O
(	O
OBJ	struct
*	O
)	O
)	O
;	O
i	long
=	O
nMaxObj	long
;	O
nMaxObj	long
=	O
nMaxObj	long
+	O
OBJ_INC	int
;	O
edma_printf	function
(	O
"[INFO] Object table extended to %d Objects"	pointer
,	O
nMaxObj	long
)	O
;	O
}	O
IdO	long
=	O
(	O
nObj	long
+	O
i	long
)	O
%	O
nMaxObj	long
;	O
if	O
(	O
(	O
gObj	O
[	O
IdO	long
]	O
=	O
(	O
OBJ	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
OBJ	struct
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
pthread_mutex_unlock	function
(	O
&	O
obj_mutex	union
)	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
"[edma_new_obj_basic_stage}"	pointer
"Can't alloc memory for object struct"	pointer
)	O
;	O
}	O
pthread_mutex_unlock	function
(	O
&	O
obj_mutex	union
)	O
;	O
memset	function
(	O
gObj	O
[	O
IdO	long
]	O
,	O
0	int
,	O
sizeof	O
(	O
OBJ	struct
)	O
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
Flag	char
=	O
OBJ_LOCKED	int
;	O
h	long
=	O
edma_palloc	function
(	O
gClass	O
[	O
IdC	long
]	O
->	O
TamDatos	long
)	O
;	O
if	O
(	O
h	long
==	O
(	O
HMEM	long
)	O
0	int
)	O
{	O
free	function
(	O
gObj	O
[	O
IdO	long
]	O
)	O
;	O
gObj	O
[	O
IdO	long
]	O
=	O
NULL	O
;	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
"[edma_new_obj_basic_stage "	pointer
"Can't create local storage for object"	pointer
)	O
;	O
}	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hData	long
=	O
h	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
Data	pointer
=	O
(	O
EPVoid	pointer
)	O
edma_pget	function
(	O
h	long
)	O
;	O
memset	function
(	O
gObj	O
[	O
IdO	long
]	O
->	O
Data	pointer
,	O
0	int
,	O
gClass	O
[	O
IdC	long
]	O
->	O
TamDatos	long
)	O
;	O
edma_log	function
(	O
"Allocated %d bytes for object of class '%s':%d at %p"	pointer
,	O
gClass	O
[	O
IdC	long
]	O
->	O
TamDatos	long
,	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array
,	O
IdC	long
,	O
gObj	O
[	O
IdO	long
]	O
->	O
Data	pointer
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
IdObj	long
=	O
IdO	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
=	O
IdC	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
IdApp	long
=	O
AppId	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
Father	long
=	O
-	O
1	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
PseudiFather	long
=	O
-	O
1	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
Flag	char
=	O
OBJ_EXIST	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
IdSIU	long
=	O
isSIU	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
Final	char
=	O
0	int
;	O
nObj	long
++	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
nUpTable	long
=	O
0	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
nDownTable	long
=	O
0	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
=	O
0	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hDownTable	long
=	O
0	int
;	O
return	O
IdO	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_newobj_vm_stage	function
(	O
OBJID	long
IdO	long
)	O
{	O
CLASSID	long
IdC	long
;	O
EUint32	long
i	long
,	O
j	long
;	O
IdC	long
=	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
gClass	O
[	O
IdC	long
]	O
->	O
nMetVir	long
)	O
{	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hvTable	long
=	O
edma_palloc	function
(	O
gClass	O
[	O
IdC	long
]	O
->	O
nMetVir	long
*	O
sizeof	O
(	O
PMetVir	struct
)	O
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	pointer
=	O
(	O
PMetVir	struct
*	O
)	O
edma_pget	function
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hvTable	long
)	O
;	O
if	O
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hvTable	long
==	O
0	int
)	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
"[edma_new_obj_vm_stage] "	pointer
"Can't allocate virtual table"	pointer
)	O
;	O
j	long
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
{	O
if	O
(	O
pClass	pointer
[	O
IdC	long
]	O
->	O
Met	pointer
[	O
i	long
]	O
.	O
Virtual	char
)	O
{	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	pointer
[	O
j	long
]	O
.	O
Ind	long
=	O
i	long
;	O
strncpy	function
(	O
(	O
char	O
*	O
)	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	pointer
[	O
j	long
]	O
.	O
Id	pointer
,	O
pClass	pointer
[	O
IdC	long
]	O
->	O
Met	pointer
[	O
i	long
]	O
.	O
IdMet	array
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	pointer
[	O
j	long
]	O
.	O
Func	pointer
=	O
(	O
PPROC	pointer
)	O
pClass	pointer
[	O
IdC	long
]	O
->	O
met_func	pointer
[	O
i	long
]	O
.	O
Func	pointer
;	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	pointer
[	O
j	long
]	O
.	O
Obj	long
=	O
gObj	O
[	O
IdO	long
]	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
vTable	pointer
[	O
j	long
]	O
.	O
next	long
=	O
NULL	O
;	O
j	long
++	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_newobj_inh_stage	function
(	O
OBJID	long
IdO	long
,	O
OBJID	long
Father	long
,	O
EPVoid	pointer
ConstPar	pointer
)	O
{	O
EUint32	long
i	long
,	O
must_link	long
,	O
j	long
;	O
CLASSID	long
IdC	long
;	O
OBJID	long
id	long
;	O
EPChar	pointer
ap_id	pointer
;	O
ESint32	long
flag	long
=	O
0	int
;	O
IdC	long
=	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
)	O
{	O
gObj	O
[	O
IdO	long
]	O
->	O
nUpTable	long
=	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
=	O
edma_palloc	function
(	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
*	O
sizeof	O
(	O
SC_ID	struct
)	O
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
=	O
(	O
SC_ID	struct
*	O
)	O
edma_pget	function
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
)	O
;	O
if	O
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
==	O
0	int
)	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
"[edma_new_obj_inh_stage] "	pointer
"Can't create superclass table"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
i	long
++	O
)	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
=	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
i	long
++	O
)	O
{	O
id	long
=	O
-	O
1	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
=	O
-	O
1	int
;	O
edma_printf_dbg	function
(	O
4	int
,	O
-	O
1	int
,	O
"[_edma_newobj_inh_stage] Creating "	pointer
"superobject of class %s"	pointer
,	O
gClass	O
[	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
]	O
->	O
ClassName	array
)	O
;	O
must_link	long
=	O
0	int
;	O
if	O
(	O
(	O
Father	long
!=	O
-	O
1	int
)	O
&&	O
(	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
==	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
)	O
)	O
{	O
id	long
=	O
Father	long
;	O
flag	long
=	O
1	int
;	O
must_link	long
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
id	long
=	O
edma_upcast_obj	function
(	O
IdO	long
,	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SubCIdList	pointer
[	O
i	long
]	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
must_link	long
=	O
1	int
;	O
if	O
(	O
(	O
id	long
=	O
edma_upcast_obj	function
(	O
gObj	O
[	O
IdO	long
]	O
->	O
root_obj	long
,	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SubCIdList	pointer
[	O
i	long
]	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
id	long
=	O
_edma_new_obj	function
(	O
gClass	O
[	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
]	O
->	O
ClassName	array
,	O
IdO	long
,	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	function
(	O
"[%s] Can't create superobject of class %s"	pointer
,	O
__FUNCTION__	O
,	O
gClass	O
[	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
]	O
->	O
ClassName	array
)	O
;	O
}	O
must_link	long
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
id	long
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	function
(	O
"[%s] Can't link superclass %s to object %d"	pointer
,	O
__FUNCTION__	O
,	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SubCIdList	pointer
[	O
i	long
]	O
)	O
;	O
}	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
=	O
id	long
;	O
if	O
(	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SubCIdList	pointer
[	O
i	long
]	O
[	O
0	int
]	O
)	O
strncpy	function
(	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Id	pointer
,	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SubCIdList	pointer
[	O
i	long
]	O
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
else	O
strncpy	function
(	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Id	pointer
,	O
gClass	O
[	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
]	O
->	O
ClassName	array
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
IdClass	long
=	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
;	O
if	O
(	O
must_link	long
)	O
{	O
ap_id	pointer
=	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCIdList	pointer
[	O
i	long
]	O
?	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCIdList	pointer
[	O
i	long
]	O
:	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
;	O
j	long
++	O
)	O
if	O
(	O
strncmp	function
(	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
[	O
j	long
]	O
.	O
Id	pointer
,	O
ap_id	pointer
,	O
EDMA_GENERAL_ID_LEN	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
j	long
==	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
)	O
edma_add_subobject	function
(	O
id	long
,	O
IdO	long
,	O
ap_id	pointer
)	O
;	O
else	O
edma_add_subobject	function
(	O
id	long
,	O
IdO	long
,	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array
)	O
;	O
}	O
}	O
}	O
return	O
IdO	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_newobj_final_stage	function
(	O
OBJID	long
IdO	long
,	O
EPChar	pointer
ClassName	array
,	O
EPVoid	pointer
ConstPar	pointer
)	O
{	O
EUint32	long
i	long
,	O
j	long
;	O
CLASSID	long
IdC	long
,	O
IdC1	long
;	O
ESint32	long
isSIU	long
;	O
IdC	long
=	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
;	O
isSIU	long
=	O
gObj	O
[	O
IdO	long
]	O
->	O
IdSIU	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	function
(	O
pClass	pointer
[	O
IdC	long
]	O
->	O
Met	pointer
[	O
i	long
]	O
.	O
IdMet	array
,	O
"born"	pointer
,	O
4	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
!=	O
gClass	O
[	O
IdC	long
]	O
->	O
nMet	short
)	O
{	O
edma_met1	function
(	O
IdO	long
,	O
i	long
,	O
0	int
,	O
NULL	O
)	O
;	O
}	O
if	O
(	O
isSIU	long
!=	O
-	O
1	int
)	O
{	O
edma_met3	function
(	O
IdO	long
,	O
"NewObj"	pointer
,	O
ClassName	array
)	O
;	O
}	O
gClass	O
[	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
]	O
->	O
Used	char
=	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
if	O
(	O
pClass	pointer
[	O
IdC	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
Tipo	long
==	O
DT_EUSER	int
)	O
{	O
IdC1	long
=	O
pClass	pointer
[	O
IdC	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
UserInfo	long
;	O
j	long
=	O
(	O
OBJID	long
)	O
edma_new_obj	function
(	O
gClass	O
[	O
IdC1	long
]	O
->	O
ClassName	array
,	O
NULL	O
)	O
;	O
*	O
(	O
(	O
OBJID	long
*	O
)	O
(	O
(	O
EPByte	pointer
)	O
gObj	O
[	O
IdO	long
]	O
->	O
Data	pointer
+	O
pClass	pointer
[	O
IdC	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
Off	short
)	O
)	O
=	O
j	long
;	O
}	O
return	O
IdO	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_new_obj	function
(	O
EPChar	pointer
ClassNam1	pointer
,	O
...	O
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
cid	long
,	O
siu_cid	pointer
;	O
ESint32	long
off	long
;	O
va_list	pointer
ConstPar	pointer
;	O
if	O
(	O
(	O
off	long
=	O
_edma_parse_class_name	function
(	O
ClassNam1	pointer
,	O
&	O
cid	long
,	O
&	O
siu_cid	pointer
,	O
-	O
1	int
,	O
-	O
1	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_new_obj] Invalid Class Name '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
va_start	O
(	O
ConstPar	pointer
,	O
ClassNam1	pointer
)	O
;	O
id	long
=	O
_edma_new_obj_internal	function
(	O
ClassNam1	pointer
+	O
off	long
,	O
cid	long
,	O
siu_cid	pointer
,	O
-	O
1	int
,	O
ConstPar	pointer
)	O
;	O
va_end	O
(	O
ConstPar	pointer
)	O
;	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_new_obj_with_version	function
(	O
EPChar	pointer
ClassNam1	pointer
,	O
ESint32	long
vmajor	long
,	O
ESint32	long
vminor	long
,	O
...	O
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
cid	long
,	O
siu_cid	pointer
;	O
ESint32	long
off	long
;	O
va_list	pointer
ConstPar	pointer
;	O
if	O
(	O
(	O
off	long
=	O
_edma_parse_class_name	function
(	O
ClassNam1	pointer
,	O
&	O
cid	long
,	O
&	O
siu_cid	pointer
,	O
vmajor	long
,	O
vminor	long
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_new_obj_with_version] Invalid Class Name '%s' "	pointer
"version %ld.%ld"	pointer
,	O
ClassNam1	pointer
,	O
vmajor	long
,	O
vminor	long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
va_start	O
(	O
ConstPar	pointer
,	O
vminor	long
)	O
;	O
id	long
=	O
_edma_new_obj_internal	function
(	O
ClassNam1	pointer
+	O
off	long
,	O
cid	long
,	O
siu_cid	pointer
,	O
-	O
1	int
,	O
ConstPar	pointer
)	O
;	O
va_end	O
(	O
ConstPar	pointer
)	O
;	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_new_obj	function
(	O
EPChar	pointer
ClassNam1	pointer
,	O
OBJID	long
father	long
,	O
EPVoid	pointer
ConstPar	pointer
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
cid	long
,	O
siu_cid	pointer
;	O
ESint32	long
off	long
;	O
if	O
(	O
(	O
off	long
=	O
_edma_parse_class_name	function
(	O
ClassNam1	pointer
,	O
&	O
cid	long
,	O
&	O
siu_cid	pointer
,	O
-	O
1	int
,	O
-	O
1	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_new_obj] Invalid Class Name '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
id	long
=	O
_edma_new_obj_internal	function
(	O
ClassNam1	pointer
+	O
off	long
,	O
cid	long
,	O
siu_cid	pointer
,	O
father	long
,	O
ConstPar	pointer
)	O
;	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_new_obj_internal	function
(	O
EPChar	pointer
ClassNam1	pointer
,	O
CLASSID	long
cid	long
,	O
CLASSID	long
siu_cid	pointer
,	O
OBJID	long
idFather	long
,	O
EPVoid	pointer
ConstPar	pointer
)	O
{	O
OBJID	long
id	long
;	O
if	O
(	O
(	O
id	long
=	O
_edma_newobj_basic_stage	function
(	O
cid	long
,	O
siu_cid	pointer
,	O
ConstPar	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Basic Stage Failed."	pointer
"Can't create object of class '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
gObj	O
[	O
id	long
]	O
->	O
root_obj	long
=	O
(	O
(	O
idFather	long
==	O
-	O
1	int
)	O
?	O
id	long
:	O
idFather	long
)	O
;	O
if	O
(	O
(	O
_edma_newobj_inh_stage	function
(	O
id	long
,	O
idFather	long
,	O
ConstPar	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Inheritance Stage Failed. "	pointer
" Can't create object of class '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
if	O
(	O
(	O
_edma_newobj_vm_stage	function
(	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Virtual Method Stage Failed."	pointer
" Can't create object of class '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
if	O
(	O
(	O
_edma_newobj_final_stage	function
(	O
id	long
,	O
ClassNam1	pointer
,	O
ConstPar	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Final Stage Failed. "	pointer
"can't create object of class '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
edma_new_simple_obj	function
(	O
EPChar	pointer
ClassNam1	pointer
,	O
EPVoid	pointer
ConstPar	pointer
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
cid	long
,	O
siu_cid	pointer
;	O
ESint32	long
off	long
;	O
if	O
(	O
ClassNam1	pointer
==	O
NULL	O
)	O
{	O
edma_printf_err	function
(	O
"[_edma_new_simple_obj] Invalid Class Name (NULL)"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
off	long
=	O
_edma_parse_class_name	function
(	O
ClassNam1	pointer
,	O
&	O
cid	long
,	O
&	O
siu_cid	pointer
,	O
-	O
1	int
,	O
-	O
1	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_new_simple_obj] Invalid Class Name '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
id	long
=	O
_edma_newobj_basic_stage	function
(	O
cid	long
,	O
siu_cid	pointer
,	O
ConstPar	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Basic Stage Failed."	pointer
"Can't create object of class '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
if	O
(	O
(	O
_edma_newobj_vm_stage	function
(	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Virtual Method Stage Failed."	pointer
" Can't create object of class '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
gClass	O
[	O
gObj	O
[	O
id	long
]	O
->	O
IdClass	long
]	O
->	O
Used	char
=	O
1	int
;	O
return	O
id	long
;	O
}	O
ESint32	long
EDMAPROC	O
_edma_free_superobjects	function
(	O
OBJID	long
IdObj	long
,	O
OBJID	long
old	long
,	O
ESint32	long
remove	function
)	O
{	O
int	O
i	long
,	O
n	int
;	O
POBJ	pointer
aux	pointer
;	O
n	int
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
[	O
0	int
]	O
.	O
IdClass	long
!=	O
-	O
1	int
)	O
{	O
aux	pointer
=	O
gObj	O
[	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
[	O
0	int
]	O
.	O
Obj	long
]	O
;	O
edma_remove_superclass_ap	function
(	O
IdObj	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
[	O
0	int
]	O
.	O
Id	pointer
)	O
;	O
if	O
(	O
(	O
aux	pointer
->	O
nDownTable	long
==	O
0	int
)	O
)	O
_edma_internal_free_obj	function
(	O
(	O
(	O
POBJ	pointer
)	O
aux	pointer
)	O
->	O
IdObj	long
,	O
IdObj	long
,	O
remove	function
)	O
;	O
}	O
else	O
edma_met3	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
[	O
0	int
]	O
.	O
Obj	long
,	O
"FreeObj"	pointer
)	O
;	O
}	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
)	O
edma_pfree	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
nUpTable	long
=	O
0	int
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_free_obj	function
(	O
OBJID	long
IdObj	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_free_obj"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
else	O
return	O
_edma_internal_free_obj	function
(	O
IdObj	long
,	O
IdObj	long
,	O
0	int
)	O
;	O
}	O
EUint32	long
EDMAPROC	O
_edma_internal_free_obj	function
(	O
OBJID	long
IdObj	long
,	O
OBJID	long
old	long
,	O
ESint32	long
flag	long
)	O
{	O
EUint32	long
i	long
,	O
j	long
,	O
n	int
;	O
EUint32	long
IdClass	long
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"_edma_internal_free_obj"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
Flag	char
==	O
OBJ_FREE	int
)	O
return	O
0	int
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
Flag	char
=	O
OBJ_FREE	int
;	O
IdClass	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSIU	long
!=	O
-	O
1	int
)	O
edma_met3	function
(	O
IdObj	long
,	O
"FreeObj"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdClass	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	function
(	O
pClass	pointer
[	O
IdClass	long
]	O
->	O
Met	pointer
[	O
i	long
]	O
.	O
IdMet	array
,	O
"rip"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
!=	O
gClass	O
[	O
IdClass	long
]	O
->	O
nMet	short
)	O
edma_met1	function
(	O
IdObj	long
,	O
i	long
,	O
0	int
,	O
NULL	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdClass	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
if	O
(	O
pClass	pointer
[	O
IdClass	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
Tipo	long
==	O
DT_EUSER	int
)	O
{	O
j	long
=	O
*	O
(	O
(	O
OBJID	long
*	O
)	O
(	O
(	O
EPByte	pointer
)	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	pointer
+	O
pClass	pointer
[	O
IdClass	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
Off	short
)	O
)	O
;	O
edma_free_obj	function
(	O
j	long
)	O
;	O
}	O
nObj	long
--	O
;	O
if	O
(	O
nObj	long
<	O
0	int
)	O
edma_print	function
(	O
"**** Ooops!! **** ---> (SYSTEM ERROR) "	pointer
"Negative number of objects in system..."	pointer
)	O
;	O
n	int
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
i	long
++	O
)	O
{	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	pointer
[	O
i	long
]	O
.	O
IdClass	long
!=	O
-	O
1	int
)	O
_edma_internal_free_obj	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	pointer
[	O
i	long
]	O
.	O
Obj	long
,	O
old	long
,	O
1	int
)	O
;	O
else	O
edma_met3	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	pointer
[	O
i	long
]	O
.	O
Obj	long
,	O
"FreeObj"	pointer
)	O
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
==	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
)	O
edma_pfree	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hDownTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	pointer
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
nDownTable	long
=	O
0	int
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
DownTable	pointer
=	O
NULL	O
;	O
if	O
(	O
flag	long
)	O
_edma_free_superobjects	function
(	O
IdObj	long
,	O
old	long
,	O
1	int
)	O
;	O
else	O
_edma_free_superobjects	function
(	O
IdObj	long
,	O
old	long
,	O
0	int
)	O
;	O
edma_pfree	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hData	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	pointer
)	O
;	O
edma_pfree	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hvTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	pointer
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	pointer
=	O
NULL	O
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSubSIU	pointer
)	O
{	O
free	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSubSIU	pointer
)	O
;	O
}	O
free	function
(	O
gObj	O
[	O
IdObj	long
]	O
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
=	O
NULL	O
;	O
edma_printf_dbg	function
(	O
4	int
,	O
-	O
1	int
,	O
"(%s) Rips Object %u of Class %s"	pointer
,	O
AppName	array
,	O
IdObj	long
,	O
gClass	O
[	O
IdClass	long
]	O
->	O
ClassName	array
)	O
;	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_free_one_obj	function
(	O
OBJID	long
IdObj	long
)	O
{	O
EUint32	long
i	long
,	O
j	long
;	O
EUint32	long
IdClass	long
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_free_one_obj"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
IdClass	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
IdSIU	long
!=	O
-	O
1	int
)	O
edma_met3	function
(	O
IdObj	long
,	O
"FreeObj"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdClass	long
]	O
->	O
nMet	short
;	O
i	long
++	O
)	O
if	O
(	O
strncmp	function
(	O
pClass	pointer
[	O
IdClass	long
]	O
->	O
Met	pointer
[	O
i	long
]	O
.	O
IdMet	array
,	O
"rip"	pointer
,	O
3	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
i	long
!=	O
gClass	O
[	O
IdClass	long
]	O
->	O
nMet	short
)	O
edma_met1	function
(	O
IdObj	long
,	O
i	long
,	O
0	int
,	O
NULL	O
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdClass	long
]	O
->	O
nProp	short
;	O
i	long
++	O
)	O
if	O
(	O
pClass	pointer
[	O
IdClass	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
Tipo	long
==	O
DT_EUSER	int
)	O
{	O
j	long
=	O
*	O
(	O
(	O
OBJID	long
*	O
)	O
(	O
(	O
EPByte	pointer
)	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	pointer
+	O
pClass	pointer
[	O
IdClass	long
]	O
->	O
Prop	pointer
[	O
i	long
]	O
.	O
Off	short
)	O
)	O
;	O
edma_free_obj	function
(	O
j	long
)	O
;	O
}	O
nObj	long
--	O
;	O
if	O
(	O
nObj	long
<	O
0	int
)	O
edma_print	function
(	O
"(SYSTEM ERROR) Negative number of objects in system..."	pointer
)	O
;	O
edma_pfree	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
UpTable	pointer
)	O
;	O
edma_pfree	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hData	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
Data	pointer
)	O
;	O
edma_pfree	function
(	O
gObj	O
[	O
IdObj	long
]	O
->	O
SysObj	struct
.	O
hvTable	long
,	O
gObj	O
[	O
IdObj	long
]	O
->	O
vTable	pointer
)	O
;	O
free	function
(	O
gObj	O
[	O
IdObj	long
]	O
)	O
;	O
gObj	O
[	O
IdObj	long
]	O
=	O
NULL	O
;	O
edma_printf_dbg	function
(	O
4	int
,	O
-	O
1	int
,	O
"(%s) Rips Object %u of Class %s"	pointer
,	O
AppName	array
,	O
IdObj	long
,	O
gClass	O
[	O
IdClass	long
]	O
->	O
ClassName	array
)	O
;	O
return	O
0	int
;	O
}	O
EDWord	long
EDMAPROC	O
edma_make_obj_virtual	function
(	O
OBJID	long
IdObj	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_make_obj_virtual"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
Flag	char
=	O
VIRTUAL_OBJECT	int
;	O
return	O
0	int
;	O
}	O
EUint32	long
EDMAPROC	O
edma_set_obj_final	function
(	O
OBJID	long
IdObj	long
,	O
EUint32	long
i	long
)	O
{	O
EUint32	long
old	long
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
IdObj	long
,	O
"edma_set_obj_final"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
old	long
=	O
gObj	O
[	O
IdObj	long
]	O
->	O
Final	char
;	O
gObj	O
[	O
IdObj	long
]	O
->	O
Final	char
=	O
i	long
;	O
return	O
old	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_swap_obj	function
(	O
OBJID	long
id	long
,	O
OBJID	long
new_id	long
)	O
{	O
POBJ	pointer
current	pointer
;	O
OBJID	long
aux	pointer
;	O
ESint32	long
i	long
,	O
j	long
;	O
void	O
*	O
p	pointer
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
id	long
,	O
"edma_swap_obj"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
new_id	long
,	O
"edma_swap_obj"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
id	long
]	O
->	O
nUpTable	long
;	O
i	long
++	O
)	O
{	O
aux	pointer
=	O
gObj	O
[	O
id	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
aux	pointer
]	O
->	O
nDownTable	long
;	O
j	long
++	O
)	O
if	O
(	O
gObj	O
[	O
aux	pointer
]	O
->	O
DownTable	pointer
[	O
j	long
]	O
.	O
Obj	long
==	O
id	long
)	O
{	O
gObj	O
[	O
aux	pointer
]	O
->	O
DownTable	pointer
[	O
j	long
]	O
.	O
Obj	long
=	O
new_id	long
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
;	O
i	long
++	O
)	O
{	O
aux	pointer
=	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
[	O
i	long
]	O
.	O
Obj	long
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
aux	pointer
]	O
->	O
nUpTable	long
;	O
j	long
++	O
)	O
if	O
(	O
gObj	O
[	O
aux	pointer
]	O
->	O
UpTable	pointer
[	O
j	long
]	O
.	O
Obj	long
==	O
id	long
)	O
{	O
gObj	O
[	O
aux	pointer
]	O
->	O
UpTable	pointer
[	O
j	long
]	O
.	O
Obj	long
=	O
new_id	long
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
new_id	long
]	O
->	O
nUpTable	long
;	O
i	long
++	O
)	O
{	O
aux	pointer
=	O
gObj	O
[	O
new_id	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
;	O
if	O
(	O
aux	pointer
==	O
new_id	long
)	O
{	O
aux	pointer
=	O
id	long
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
aux	pointer
]	O
->	O
nDownTable	long
;	O
j	long
++	O
)	O
if	O
(	O
gObj	O
[	O
aux	pointer
]	O
->	O
DownTable	pointer
[	O
j	long
]	O
.	O
Obj	long
==	O
new_id	long
)	O
{	O
gObj	O
[	O
aux	pointer
]	O
->	O
DownTable	pointer
[	O
j	long
]	O
.	O
Obj	long
=	O
id	long
;	O
}	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gObj	O
[	O
new_id	long
]	O
->	O
nDownTable	long
;	O
i	long
++	O
)	O
{	O
aux	pointer
=	O
gObj	O
[	O
new_id	long
]	O
->	O
DownTable	pointer
[	O
i	long
]	O
.	O
Obj	long
;	O
if	O
(	O
aux	pointer
==	O
new_id	long
)	O
{	O
aux	pointer
=	O
id	long
;	O
continue	O
;	O
}	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
aux	pointer
]	O
->	O
nUpTable	long
;	O
j	long
++	O
)	O
if	O
(	O
gObj	O
[	O
aux	pointer
]	O
->	O
UpTable	pointer
[	O
j	long
]	O
.	O
Obj	long
==	O
new_id	long
)	O
{	O
gObj	O
[	O
aux	pointer
]	O
->	O
UpTable	pointer
[	O
j	long
]	O
.	O
Obj	long
=	O
id	long
;	O
}	O
}	O
current	pointer
=	O
gObj	O
[	O
id	long
]	O
;	O
gObj	O
[	O
id	long
]	O
=	O
gObj	O
[	O
new_id	long
]	O
;	O
gObj	O
[	O
new_id	long
]	O
=	O
current	pointer
;	O
gObj	O
[	O
id	long
]	O
->	O
IdObj	long
=	O
id	long
;	O
gObj	O
[	O
new_id	long
]	O
->	O
IdObj	long
=	O
new_id	long
;	O
return	O
0	int
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_newobj_inh_stage1	function
(	O
OBJID	long
IdO	long
,	O
OBJID	long
Father	long
,	O
EPVoid	pointer
ConstPar	pointer
)	O
{	O
EUint32	long
i	long
,	O
must_link	long
,	O
j	long
;	O
CLASSID	long
IdC	long
;	O
OBJID	long
id	long
;	O
EPChar	pointer
ap_id	pointer
;	O
ESint32	long
flag	long
=	O
0	int
;	O
IdC	long
=	O
gObj	O
[	O
IdO	long
]	O
->	O
IdClass	long
;	O
if	O
(	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
)	O
{	O
gObj	O
[	O
IdO	long
]	O
->	O
nUpTable	long
=	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
=	O
edma_palloc	function
(	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
*	O
sizeof	O
(	O
SC_ID	struct
)	O
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
=	O
(	O
SC_ID	struct
*	O
)	O
edma_pget	function
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
)	O
;	O
if	O
(	O
gObj	O
[	O
IdO	long
]	O
->	O
SysObj	struct
.	O
hUpTable	long
==	O
0	int
)	O
return	O
_edma_system_exception	function
(	O
"%s"	pointer
,	O
"[edma_new_obj_inh_stage] "	pointer
"Can't create superclass table"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
i	long
++	O
)	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
=	O
-	O
1	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
gClass	O
[	O
IdC	long
]	O
->	O
Derived	long
;	O
i	long
++	O
)	O
{	O
id	long
=	O
-	O
1	int
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
=	O
-	O
1	int
;	O
edma_printf_dbg	function
(	O
4	int
,	O
-	O
1	int
,	O
"[_edma_newobj_inh_stage] Creating "	pointer
"superobject of class %s"	pointer
,	O
gClass	O
[	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
]	O
->	O
ClassName	array
)	O
;	O
edma_printf_dbg	function
(	O
4	int
,	O
-	O
1	int
,	O
"SuperClass %d: '%s'(%d) Father: %d: '%s'%d "	pointer
":: IdO: %d"	pointer
,	O
i	long
,	O
gClass	O
[	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
]	O
->	O
ClassName	array
,	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
,	O
Father	long
,	O
gClass	O
[	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array
,	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
,	O
IdO	long
)	O
;	O
must_link	long
=	O
0	int
;	O
if	O
(	O
(	O
Father	long
!=	O
-	O
1	int
)	O
&&	O
(	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
==	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
)	O
)	O
{	O
edma_printf_dbg	function
(	O
4	int
,	O
-	O
1	int
,	O
"**SuperClass %d: '%s'(%d) Father: %d: "	pointer
"'%s'%d "	pointer
,	O
i	long
,	O
gClass	O
[	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
]	O
->	O
ClassName	array
,	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
,	O
Father	long
,	O
gClass	O
[	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
]	O
->	O
ClassName	array
,	O
gObj	O
[	O
Father	long
]	O
->	O
IdClass	long
)	O
;	O
id	long
=	O
Father	long
;	O
flag	long
=	O
1	int
;	O
must_link	long
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
(	O
id	long
=	O
edma_upcast_obj	function
(	O
IdO	long
,	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SubCIdList	pointer
[	O
i	long
]	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
must_link	long
=	O
1	int
;	O
if	O
(	O
(	O
id	long
=	O
edma_upcast_obj	function
(	O
gObj	O
[	O
IdO	long
]	O
->	O
root_obj	long
,	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SubCIdList	pointer
[	O
i	long
]	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
id	long
=	O
_edma_new_obj1	function
(	O
gClass	O
[	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
]	O
->	O
ClassName	array
,	O
Father	long
,	O
NULL	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	function
(	O
"[%s] Can't create superobject of class %s"	pointer
,	O
__FUNCTION__	O
,	O
gClass	O
[	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
]	O
->	O
ClassName	array
)	O
;	O
}	O
must_link	long
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
id	long
==	O
-	O
1	int
)	O
{	O
return	O
_edma_system_exception	function
(	O
"[%s] Can't link superclass %s "	pointer
"to object %d"	pointer
,	O
__FUNCTION__	O
,	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SubCIdList	pointer
[	O
i	long
]	O
)	O
;	O
}	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Obj	long
=	O
id	long
;	O
if	O
(	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SubCIdList	pointer
[	O
i	long
]	O
[	O
0	int
]	O
)	O
strncpy	function
(	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Id	pointer
,	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SubCIdList	pointer
[	O
i	long
]	O
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
else	O
strncpy	function
(	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
Id	pointer
,	O
gClass	O
[	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
]	O
->	O
ClassName	array
,	O
EDMA_GENERAL_ID_LEN	int
)	O
;	O
gObj	O
[	O
IdO	long
]	O
->	O
UpTable	pointer
[	O
i	long
]	O
.	O
IdClass	long
=	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCList	pointer
[	O
i	long
]	O
;	O
if	O
(	O
must_link	long
)	O
{	O
ap_id	pointer
=	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCIdList	pointer
[	O
i	long
]	O
?	O
pClass	pointer
[	O
IdC	long
]	O
->	O
SCIdList	pointer
[	O
i	long
]	O
:	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
;	O
j	long
++	O
)	O
if	O
(	O
strncmp	function
(	O
gObj	O
[	O
id	long
]	O
->	O
DownTable	pointer
[	O
j	long
]	O
.	O
Id	pointer
,	O
ap_id	pointer
,	O
EDMA_GENERAL_ID_LEN	int
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
j	long
==	O
gObj	O
[	O
id	long
]	O
->	O
nDownTable	long
)	O
edma_add_subobject	function
(	O
id	long
,	O
IdO	long
,	O
ap_id	pointer
)	O
;	O
else	O
edma_add_subobject	function
(	O
id	long
,	O
IdO	long
,	O
gClass	O
[	O
IdC	long
]	O
->	O
ClassName	array
)	O
;	O
}	O
}	O
}	O
return	O
IdO	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_new_obj1	function
(	O
EPChar	pointer
ClassNam1	pointer
,	O
OBJID	long
father	long
,	O
EPVoid	pointer
ConstPar	pointer
)	O
{	O
OBJID	long
id	long
;	O
CLASSID	long
cid	long
,	O
siu_cid	pointer
;	O
ESint32	long
off	long
;	O
if	O
(	O
(	O
off	long
=	O
_edma_parse_class_name	function
(	O
ClassNam1	pointer
,	O
&	O
cid	long
,	O
&	O
siu_cid	pointer
,	O
-	O
1	int
,	O
-	O
1	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
edma_printf_err	function
(	O
"[edma_new_obj] Invalid Class Name '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
id	long
=	O
_edma_new_obj_internal1	function
(	O
ClassNam1	pointer
+	O
off	long
,	O
cid	long
,	O
siu_cid	pointer
,	O
father	long
,	O
ConstPar	pointer
)	O
;	O
return	O
id	long
;	O
}	O
OBJID	long
EDMAPROC	O
_edma_new_obj_internal1	function
(	O
EPChar	pointer
ClassNam1	pointer
,	O
CLASSID	long
cid	long
,	O
CLASSID	long
siu_cid	pointer
,	O
OBJID	long
idFather	long
,	O
EPVoid	pointer
ConstPar	pointer
)	O
{	O
OBJID	long
id	long
;	O
if	O
(	O
(	O
id	long
=	O
_edma_newobj_basic_stage	function
(	O
cid	long
,	O
siu_cid	pointer
,	O
ConstPar	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Basic Stage Failed."	pointer
"Can't create object of class '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
gObj	O
[	O
id	long
]	O
->	O
root_obj	long
=	O
(	O
(	O
idFather	long
==	O
-	O
1	int
)	O
?	O
id	long
:	O
idFather	long
)	O
;	O
if	O
(	O
(	O
_edma_newobj_inh_stage1	function
(	O
id	long
,	O
idFather	long
,	O
ConstPar	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Inheritance Stage Failed. "	pointer
" Can't create object of class '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
if	O
(	O
(	O
_edma_newobj_vm_stage	function
(	O
id	long
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Virtual Method Stage Failed."	pointer
" Can't create object of class '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
if	O
(	O
(	O
_edma_newobj_final_stage	function
(	O
id	long
,	O
ClassNam1	pointer
,	O
ConstPar	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
_edma_system_exception	function
(	O
"[edma_new_obj] Final Stage Failed. "	pointer
"can't create object of class '%s'"	pointer
,	O
ClassNam1	pointer
)	O
;	O
return	O
id	long
;	O
}	O
ESint32	long
EDMAPROC	O
edma_obj_commit_suicide	function
(	O
OBJID	long
id	long
)	O
{	O
if	O
(	O
(	O
edma_check_obj_id	function
(	O
id	long
,	O
"edma_met3"	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
gObj	O
[	O
id	long
]	O
->	O
Flag	char
=	O
OBJ_DIE	int
;	O
return	O
0	int
;	O
}	O
