static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: log_register.c,v 1.4 2014/04/17 20:27:30 sebdiaz Exp $"	pointer
;	O
int	O
CDB_log_register	function
(	O
dbenv	pointer
,	O
dbp	pointer
,	O
name	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
{	O
DBT	struct
fid_dbt	struct
,	O
r_name	struct
;	O
DB_LOG	struct
*	O
dblp	pointer
;	O
DB_LSN	struct
r_unused	struct
;	O
FNAME	struct
*	O
found	pointer
,	O
*	O
fnp	pointer
,	O
*	O
recover_fnp	pointer
,	O
*	O
reuse_fnp	pointer
;	O
LOG	struct
*	O
lp	pointer
;	O
size_t	long
len	int
;	O
int32_t	int
maxid	int
;	O
int	O
inserted	int
,	O
ok	int
,	O
ret	int
;	O
void	O
*	O
namep	pointer
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
lg_handle	pointer
,	O
DB_INIT_LOG	int
)	O
;	O
dblp	pointer
=	O
dbenv	pointer
->	O
lg_handle	pointer
;	O
lp	pointer
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
fnp	pointer
=	O
reuse_fnp	pointer
=	O
NULL	O
;	O
inserted	int
=	O
ret	int
=	O
0	int
;	O
namep	pointer
=	O
NULL	O
;	O
if	O
(	O
dbp	pointer
->	O
type	enum
!=	O
DB_BTREE	int
&&	O
dbp	pointer
->	O
type	enum
!=	O
DB_QUEUE	int
&&	O
dbp	pointer
->	O
type	enum
!=	O
DB_HASH	int
&&	O
dbp	pointer
->	O
type	enum
!=	O
DB_RECNO	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_log_register: unknown DB file type"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
ok	int
=	O
0	int
;	O
found	pointer
=	O
NULL	O
;	O
recover_fnp	pointer
=	O
NULL	O
;	O
for	O
(	O
maxid	int
=	O
0	int
,	O
fnp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
lp	pointer
->	O
fq	struct
,	O
__fname	struct
)	O
;	O
fnp	pointer
!=	O
NULL	O
;	O
fnp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
fnp	pointer
,	O
q	struct
,	O
__fname	struct
)	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
dblp	pointer
,	O
DBLOG_RECOVER	int
)	O
&&	O
fnp	pointer
->	O
id	int
==	O
dbp	pointer
->	O
log_fileid	int
)	O
recover_fnp	pointer
=	O
fnp	pointer
;	O
if	O
(	O
fnp	pointer
->	O
ref	short
==	O
0	int
)	O
{	O
if	O
(	O
reuse_fnp	pointer
==	O
NULL	O
)	O
reuse_fnp	pointer
=	O
fnp	pointer
;	O
continue	O
;	O
}	O
if	O
(	O
memcmp	function
(	O
dbp	pointer
->	O
fileid	array
,	O
fnp	pointer
->	O
ufid	array
,	O
DB_FILE_ID_LEN	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
fnp	pointer
->	O
meta_pgno	int
==	O
0	int
)	O
{	O
if	O
(	O
fnp	pointer
->	O
locked	int
==	O
1	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"File is locked"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
found	pointer
!=	O
NULL	O
)	O
goto	O
found	pointer
;	O
ok	int
=	O
1	int
;	O
}	O
if	O
(	O
dbp	pointer
->	O
meta_pgno	int
==	O
fnp	pointer
->	O
meta_pgno	int
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
dblp	pointer
,	O
DBLOG_RECOVER	int
)	O
)	O
{	O
if	O
(	O
fnp	pointer
->	O
id	int
!=	O
dbp	pointer
->	O
log_fileid	int
)	O
{	O
CDB___log_rem_logid	function
(	O
dblp	pointer
,	O
NULL	O
,	O
fnp	pointer
->	O
id	int
)	O
;	O
if	O
(	O
recover_fnp	pointer
!=	O
NULL	O
)	O
break	O
;	O
continue	O
;	O
}	O
fnp	pointer
->	O
ref	short
=	O
1	int
;	O
goto	O
found	pointer
;	O
}	O
++	O
fnp	pointer
->	O
ref	short
;	O
if	O
(	O
ok	int
)	O
goto	O
found	pointer
;	O
found	pointer
=	O
fnp	pointer
;	O
}	O
}	O
if	O
(	O
maxid	int
<=	O
fnp	pointer
->	O
id	int
)	O
maxid	int
=	O
fnp	pointer
->	O
id	int
+	O
1	int
;	O
}	O
if	O
(	O
(	O
fnp	pointer
=	O
found	pointer
)	O
!=	O
NULL	O
)	O
goto	O
found	pointer
;	O
if	O
(	O
recover_fnp	pointer
!=	O
NULL	O
)	O
fnp	pointer
=	O
recover_fnp	pointer
;	O
else	O
if	O
(	O
reuse_fnp	pointer
!=	O
NULL	O
)	O
fnp	pointer
=	O
reuse_fnp	pointer
;	O
else	O
{	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
dblp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
sizeof	O
(	O
FNAME	struct
)	O
,	O
0	int
,	O
&	O
fnp	pointer
)	O
)	O
!=	O
0	int
)	O
goto	O
mem_err	O
;	O
fnp	pointer
->	O
id	int
=	O
maxid	int
;	O
}	O
if	O
(	O
F_ISSET	O
(	O
dblp	pointer
,	O
DBLOG_RECOVER	int
)	O
)	O
fnp	pointer
->	O
id	int
=	O
dbp	pointer
->	O
log_fileid	int
;	O
fnp	pointer
->	O
ref	short
=	O
1	int
;	O
fnp	pointer
->	O
locked	int
=	O
0	int
;	O
fnp	pointer
->	O
s_type	enum
=	O
dbp	pointer
->	O
type	enum
;	O
memcpy	function
(	O
fnp	pointer
->	O
ufid	array
,	O
dbp	pointer
->	O
fileid	array
,	O
DB_FILE_ID_LEN	int
)	O
;	O
fnp	pointer
->	O
meta_pgno	int
=	O
dbp	pointer
->	O
meta_pgno	int
;	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
{	O
len	int
=	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
dblp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
len	int
,	O
0	int
,	O
&	O
namep	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
mem_err	O
:	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Unable to allocate memory to register %s"	pointer
,	O
namep	pointer
)	O
;	O
goto	O
err	pointer
;	O
}	O
fnp	pointer
->	O
name_off	int
=	O
R_OFFSET	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
namep	pointer
)	O
;	O
memcpy	function
(	O
namep	pointer
,	O
name	pointer
,	O
len	int
)	O
;	O
}	O
else	O
fnp	pointer
->	O
name_off	int
=	O
INVALID_ROFF	int
;	O
if	O
(	O
reuse_fnp	pointer
==	O
NULL	O
&&	O
recover_fnp	pointer
==	O
NULL	O
)	O
SH_TAILQ_INSERT_HEAD	O
(	O
&	O
lp	pointer
->	O
fq	struct
,	O
fnp	pointer
,	O
q	struct
,	O
__fname	struct
)	O
;	O
inserted	int
=	O
1	int
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dblp	pointer
,	O
DBLOG_RECOVER	int
)	O
)	O
{	O
if	O
(	O
name	pointer
!=	O
NULL	O
)	O
{	O
r_name	struct
.	O
data	pointer
=	O
(	O
void	O
*	O
)	O
name	pointer
;	O
r_name	struct
.	O
size	int
=	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
}	O
memset	function
(	O
&	O
fid_dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
fid_dbt	struct
)	O
)	O
;	O
fid_dbt	struct
.	O
data	pointer
=	O
dbp	pointer
->	O
fileid	array
;	O
fid_dbt	struct
.	O
size	int
=	O
DB_FILE_ID_LEN	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_register_log	function
(	O
dbenv	pointer
,	O
NULL	O
,	O
&	O
r_unused	struct
,	O
0	int
,	O
LOG_OPEN	int
,	O
name	pointer
==	O
NULL	O
?	O
NULL	O
:	O
&	O
r_name	struct
,	O
&	O
fid_dbt	struct
,	O
fnp	pointer
->	O
id	int
,	O
dbp	pointer
->	O
type	enum
,	O
dbp	pointer
->	O
meta_pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
}	O
found	pointer
:	O
if	O
(	O
!	O
F_ISSET	O
(	O
dblp	pointer
,	O
DBLOG_RECOVER	int
)	O
&&	O
(	O
ret	int
=	O
CDB___log_add_logid	function
(	O
dbenv	pointer
,	O
dblp	pointer
,	O
dbp	pointer
,	O
fnp	pointer
->	O
id	int
)	O
)	O
!=	O
0	int
)	O
goto	O
err	pointer
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dblp	pointer
,	O
DBLOG_RECOVER	int
)	O
)	O
dbp	pointer
->	O
log_fileid	int
=	O
fnp	pointer
->	O
id	int
;	O
if	O
(	O
0	int
)	O
{	O
err	pointer
:	O
if	O
(	O
inserted	int
)	O
SH_TAILQ_REMOVE	O
(	O
&	O
lp	pointer
->	O
fq	struct
,	O
fnp	pointer
,	O
q	struct
,	O
__fname	struct
)	O
;	O
if	O
(	O
namep	pointer
!=	O
NULL	O
)	O
CDB___db_shalloc_free	function
(	O
dblp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
namep	pointer
)	O
;	O
if	O
(	O
fnp	pointer
!=	O
NULL	O
)	O
CDB___db_shalloc_free	function
(	O
dblp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
fnp	pointer
)	O
;	O
}	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB_log_unregister	function
(	O
dbenv	pointer
,	O
dbp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
{	O
int	O
ret	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
lg_handle	pointer
,	O
DB_INIT_LOG	int
)	O
;	O
ret	int
=	O
CDB___log_filelist_update	function
(	O
dbenv	pointer
,	O
dbp	pointer
,	O
dbp	pointer
->	O
log_fileid	int
,	O
NULL	O
,	O
NULL	O
)	O
;	O
dbp	pointer
->	O
log_fileid	int
=	O
DB_LOGFILEID_INVALID	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___log_filelist_update	function
(	O
dbenv	pointer
,	O
dbp	pointer
,	O
fid	int
,	O
newname	pointer
,	O
set	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB	struct
*	O
dbp	pointer
;	O
int32_t	int
fid	int
;	O
const	O
char	O
*	O
newname	pointer
;	O
int	O
*	O
set	pointer
;	O
{	O
DBT	struct
fid_dbt	struct
,	O
r_name	struct
;	O
DB_LOG	struct
*	O
dblp	pointer
;	O
DB_LSN	struct
r_unused	struct
;	O
FNAME	struct
*	O
fnp	pointer
;	O
LOG	struct
*	O
lp	pointer
;	O
u_int32_t	int
len	int
,	O
newlen	int
;	O
int	O
ret	int
;	O
void	O
*	O
namep	pointer
;	O
ret	int
=	O
0	int
;	O
dblp	pointer
=	O
dbenv	pointer
->	O
lg_handle	pointer
;	O
lp	pointer
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
for	O
(	O
fnp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
lp	pointer
->	O
fq	struct
,	O
__fname	struct
)	O
;	O
fnp	pointer
!=	O
NULL	O
;	O
fnp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
fnp	pointer
,	O
q	struct
,	O
__fname	struct
)	O
)	O
if	O
(	O
fid	int
==	O
fnp	pointer
->	O
id	int
)	O
break	O
;	O
if	O
(	O
fnp	pointer
==	O
NULL	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_log_unregister: non-existent file id"	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
ret1	O
;	O
}	O
namep	pointer
=	O
NULL	O
;	O
len	int
=	O
0	int
;	O
if	O
(	O
fnp	pointer
->	O
name_off	int
!=	O
INVALID_ROFF	int
)	O
{	O
namep	pointer
=	O
R_ADDR	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
fnp	pointer
->	O
name_off	int
)	O
;	O
len	int
=	O
strlen	function
(	O
namep	pointer
)	O
+	O
1	int
;	O
}	O
if	O
(	O
!	O
F_ISSET	O
(	O
dblp	pointer
,	O
DBLOG_RECOVER	int
)	O
&&	O
fnp	pointer
->	O
ref	short
==	O
1	int
)	O
{	O
if	O
(	O
namep	pointer
!=	O
NULL	O
)	O
{	O
memset	function
(	O
&	O
r_name	struct
,	O
0	int
,	O
sizeof	O
(	O
r_name	struct
)	O
)	O
;	O
r_name	struct
.	O
data	pointer
=	O
namep	pointer
;	O
r_name	struct
.	O
size	int
=	O
len	int
;	O
}	O
memset	function
(	O
&	O
fid_dbt	struct
,	O
0	int
,	O
sizeof	O
(	O
fid_dbt	struct
)	O
)	O
;	O
fid_dbt	struct
.	O
data	pointer
=	O
fnp	pointer
->	O
ufid	array
;	O
fid_dbt	struct
.	O
size	int
=	O
DB_FILE_ID_LEN	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_register_log	function
(	O
dbenv	pointer
,	O
NULL	O
,	O
&	O
r_unused	struct
,	O
0	int
,	O
LOG_CLOSE	int
,	O
fnp	pointer
->	O
name_off	int
==	O
INVALID_ROFF	int
?	O
NULL	O
:	O
&	O
r_name	struct
,	O
&	O
fid_dbt	struct
,	O
fid	int
,	O
fnp	pointer
->	O
s_type	enum
,	O
fnp	pointer
->	O
meta_pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
ret1	O
;	O
}	O
if	O
(	O
newname	pointer
!=	O
NULL	O
)	O
{	O
DB_ASSERT	O
(	O
fnp	pointer
->	O
ref	short
==	O
1	int
)	O
;	O
newlen	int
=	O
strlen	function
(	O
newname	pointer
)	O
+	O
1	int
;	O
if	O
(	O
!	O
F_ISSET	O
(	O
dblp	pointer
,	O
DBLOG_RECOVER	int
)	O
)	O
{	O
r_name	struct
.	O
data	pointer
=	O
(	O
void	O
*	O
)	O
newname	pointer
;	O
r_name	struct
.	O
size	int
=	O
newlen	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___log_register_log	function
(	O
dbenv	pointer
,	O
NULL	O
,	O
&	O
r_unused	struct
,	O
0	int
,	O
LOG_OPEN	int
,	O
&	O
r_name	struct
,	O
&	O
fid_dbt	struct
,	O
fnp	pointer
->	O
id	int
,	O
fnp	pointer
->	O
s_type	enum
,	O
fnp	pointer
->	O
meta_pgno	int
)	O
)	O
!=	O
0	int
)	O
goto	O
ret1	O
;	O
}	O
if	O
(	O
set	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
len	int
!=	O
newlen	int
||	O
memcmp	function
(	O
namep	pointer
,	O
newname	pointer
,	O
len	int
)	O
!=	O
0	int
)	O
*	O
set	pointer
=	O
1	int
;	O
else	O
{	O
*	O
set	pointer
=	O
0	int
;	O
goto	O
ret1	O
;	O
}	O
}	O
if	O
(	O
len	int
<	O
newlen	int
)	O
{	O
CDB___db_shalloc_free	function
(	O
dblp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
R_ADDR	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
fnp	pointer
->	O
name_off	int
)	O
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___db_shalloc	function
(	O
dblp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
newlen	int
,	O
0	int
,	O
&	O
namep	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"Unable to allocate memory to register %s"	pointer
,	O
namep	pointer
)	O
;	O
goto	O
ret1	O
;	O
}	O
fnp	pointer
->	O
name_off	int
=	O
R_OFFSET	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
namep	pointer
)	O
;	O
}	O
else	O
namep	pointer
=	O
R_ADDR	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
fnp	pointer
->	O
name_off	int
)	O
;	O
memcpy	function
(	O
namep	pointer
,	O
newname	pointer
,	O
newlen	int
)	O
;	O
}	O
else	O
{	O
DB_ASSERT	O
(	O
fnp	pointer
->	O
ref	short
>=	O
1	int
)	O
;	O
--	O
fnp	pointer
->	O
ref	short
;	O
if	O
(	O
fnp	pointer
->	O
ref	short
==	O
0	int
)	O
{	O
if	O
(	O
fnp	pointer
->	O
name_off	int
!=	O
INVALID_ROFF	int
)	O
CDB___db_shalloc_free	function
(	O
dblp	pointer
->	O
reginfo	pointer
.	O
addr	pointer
,	O
R_ADDR	O
(	O
&	O
dblp	pointer
->	O
reginfo	pointer
,	O
fnp	pointer
->	O
name_off	int
)	O
)	O
;	O
fnp	pointer
->	O
name_off	int
=	O
INVALID_ROFF	int
;	O
}	O
if	O
(	O
!	O
F_ISSET	O
(	O
dblp	pointer
,	O
DBLOG_RECOVER	int
)	O
)	O
CDB___log_rem_logid	function
(	O
dblp	pointer
,	O
dbp	pointer
,	O
fid	int
)	O
;	O
}	O
ret1	O
:	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB___log_file_lock	function
(	O
dbp	pointer
)	O
DB	struct
*	O
dbp	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LOG	struct
*	O
dblp	pointer
;	O
FNAME	struct
*	O
fnp	pointer
;	O
LOG	struct
*	O
lp	pointer
;	O
int	O
ret	int
;	O
dbenv	pointer
=	O
dbp	pointer
->	O
dbenv	pointer
;	O
dblp	pointer
=	O
dbenv	pointer
->	O
lg_handle	pointer
;	O
lp	pointer
=	O
dblp	pointer
->	O
reginfo	pointer
.	O
primary	int
;	O
ret	int
=	O
0	int
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
for	O
(	O
fnp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
lp	pointer
->	O
fq	struct
,	O
__fname	struct
)	O
;	O
fnp	pointer
!=	O
NULL	O
;	O
fnp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
fnp	pointer
,	O
q	struct
,	O
__fname	struct
)	O
)	O
{	O
if	O
(	O
fnp	pointer
->	O
ref	short
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
!	O
memcmp	function
(	O
dbp	pointer
->	O
fileid	array
,	O
fnp	pointer
->	O
ufid	array
,	O
DB_FILE_ID_LEN	int
)	O
)	O
{	O
if	O
(	O
fnp	pointer
->	O
meta_pgno	int
==	O
0	int
)	O
{	O
if	O
(	O
fnp	pointer
->	O
ref	short
!=	O
1	int
)	O
goto	O
err	pointer
;	O
fnp	pointer
->	O
locked	int
=	O
1	int
;	O
}	O
else	O
{	O
err	pointer
:	O
CDB___db_err	function
(	O
dbp	pointer
->	O
dbenv	pointer
,	O
"File is open"	pointer
)	O
;	O
ret	int
=	O
EINVAL	int
;	O
goto	O
done	O
;	O
}	O
}	O
}	O
done	O
:	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
&	O
dblp	pointer
->	O
reginfo	pointer
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
