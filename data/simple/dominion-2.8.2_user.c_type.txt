extern	O
Suser	struct
user	struct
;	O
extern	O
Sworld	struct
world	struct
;	O
extern	O
int	O
debug	int
;	O
extern	O
int	O
(	O
*	O
wrapx	pointer
)	O
(	O
)	O
,	O
(	O
*	O
wrapy	pointer
)	O
(	O
)	O
;	O
extern	O
int	O
viewall	int
;	O
extern	O
char	O
*	O
update_time	pointer
,	O
*	O
get_update_time	function
(	O
)	O
,	O
*	O
mail_forwarding	function
(	O
)	O
,	O
*	O
civ_move	array
[	O
]	O
;	O
void	O
usageerr	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"usage: %s -[n nation] [-d dir] [-x] [-h] [-p] [-c]\n"	pointer
,	O
argv	array
[	O
0	int
]	O
)	O
;	O
}	O
void	O
init_user	function
(	O
int	O
innation	int
,	O
char	O
nation	array
[	O
]	O
)	O
{	O
char	O
passwd	array
[	O
NAMELEN	int
]	O
;	O
char	O
*	O
getpass	function
(	O
)	O
,	O
*	O
crypt	function
(	O
)	O
;	O
int	O
i	int
;	O
Sdiplo	struct
*	O
*	O
allocate_diplo	function
(	O
)	O
;	O
printf	function
(	O
"initializing user...\r\n"	pointer
)	O
;	O
load_army_types	function
(	O
)	O
;	O
load_spirit_types	function
(	O
)	O
;	O
load_master_execs	function
(	O
)	O
;	O
if	O
(	O
!	O
innation	int
)	O
{	O
printf	function
(	O
"which nation would you like to play? "	pointer
)	O
;	O
getline	function
(	O
nation	array
,	O
NAMELEN	int
)	O
;	O
}	O
if	O
(	O
(	O
user	struct
.	O
id	short
=	O
get_nation_id	function
(	O
nation	array
)	O
)	O
==	O
-	O
1	int
)	O
{	O
printf	function
(	O
"\r\nnation does not exist, sorry\r\n"	pointer
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
get_crypt_pass	function
(	O
"Your nation's password: "	pointer
,	O
passwd	array
,	O
NULL	O
,	O
NULL	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
world	struct
.	O
nations	pointer
[	O
user	struct
.	O
id	short
]	O
.	O
passwd	array
,	O
passwd	array
)	O
&&	O
strcmp	function
(	O
world	struct
.	O
nations	pointer
[	O
0	int
]	O
.	O
passwd	array
,	O
passwd	array
)	O
)	O
{	O
printf	function
(	O
"\r\nTry again\r\n"	pointer
)	O
;	O
get_crypt_pass	function
(	O
"Your nation's password: "	pointer
,	O
passwd	array
,	O
NULL	O
,	O
NULL	O
)	O
;	O
user	struct
.	O
id	short
=	O
get_nation_id	function
(	O
nation	array
)	O
;	O
if	O
(	O
strcmp	function
(	O
world	struct
.	O
nations	pointer
[	O
user	struct
.	O
id	short
]	O
.	O
passwd	array
,	O
passwd	array
)	O
&&	O
strcmp	function
(	O
world	struct
.	O
nations	pointer
[	O
0	int
]	O
.	O
passwd	array
,	O
passwd	array
)	O
)	O
{	O
printf	function
(	O
"\r\nwrong password, sorry\r\n"	pointer
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
handle_locks	function
(	O
user	struct
.	O
id	short
)	O
;	O
user	struct
.	O
np	pointer
=	O
&	O
world	struct
.	O
nations	pointer
[	O
user	struct
.	O
id	short
]	O
;	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
capital	struct
.	O
x	int
==	O
-	O
1	int
&&	O
user	struct
.	O
np	pointer
->	O
capital	struct
.	O
y	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
id	short
==	O
0	int
)	O
{	O
user	struct
.	O
np	pointer
->	O
capital	struct
.	O
x	int
=	O
0	int
;	O
user	struct
.	O
np	pointer
->	O
capital	struct
.	O
y	int
=	O
0	int
;	O
}	O
else	O
{	O
printf	function
(	O
"\r\nYour nation has been destroyed.\n"	pointer
)	O
;	O
printf	function
(	O
"Ask your Gamemaster for your last mail.\n"	pointer
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
}	O
user	struct
.	O
avail_armies	pointer
=	O
NULL	O
;	O
get_avail_armies	function
(	O
&	O
user	struct
,	O
user	struct
.	O
np	pointer
->	O
tech_skill	int
)	O
;	O
user	struct
.	O
spell_list	pointer
=	O
NULL	O
;	O
user	struct
.	O
spirit_list	pointer
=	O
NULL	O
;	O
get_spells	function
(	O
&	O
user	struct
,	O
user	struct
.	O
np	pointer
->	O
mag_skill	int
)	O
;	O
get_spirits	function
(	O
&	O
user	struct
,	O
user	struct
.	O
np	pointer
->	O
mag_skill	int
)	O
;	O
if	O
(	O
user	struct
.	O
id	short
!=	O
0	int
)	O
{	O
load_nation	function
(	O
user	struct
.	O
id	short
,	O
user	struct
.	O
np	pointer
)	O
;	O
}	O
else	O
{	O
load_options	function
(	O
user	struct
.	O
np	pointer
)	O
;	O
}	O
user	struct
.	O
cursor	struct
=	O
user	struct
.	O
center	struct
=	O
user	struct
.	O
np	pointer
->	O
capital	struct
;	O
user	struct
.	O
help_char	char
=	O
'?'	O
;	O
user	struct
.	O
map_style	int
=	O
NORMAL_MAP	int
;	O
user	struct
.	O
display	int
=	O
DESIGNATION	int
;	O
if	O
(	O
user	struct
.	O
id	short
!=	O
0	int
)	O
{	O
user	struct
.	O
highlight	int
=	O
H_OWNED	int
;	O
}	O
else	O
{	O
user	struct
.	O
highlight	int
=	O
H_NONE	int
;	O
}	O
user	struct
.	O
underwater	int
=	O
0	int
;	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
race	struct
.	O
pref_alt	int
<	O
0	int
)	O
{	O
user	struct
.	O
underwater	int
=	O
1	int
;	O
}	O
user	struct
.	O
n_execs	int
=	O
0	int
;	O
user	struct
.	O
current_army	int
=	O
first_sect_army	function
(	O
&	O
world	struct
.	O
map	pointer
[	O
user	struct
.	O
cursor	struct
.	O
x	int
]	O
[	O
user	struct
.	O
cursor	struct
.	O
y	int
]	O
)	O
;	O
user	struct
.	O
just_moved	int
=	O
1	int
;	O
user	struct
.	O
last_n_armies	int
=	O
0	int
;	O
if	O
(	O
user	struct
.	O
id	short
==	O
0	int
)	O
{	O
viewall	int
=	O
1	int
;	O
}	O
user	struct
.	O
show_sect_win	int
=	O
1	int
;	O
user	struct
.	O
diplo_matrix	pointer
=	O
allocate_diplo	function
(	O
world	struct
.	O
n_nations	int
)	O
;	O
read_in_diplo	function
(	O
user	struct
.	O
diplo_matrix	pointer
,	O
world	struct
.	O
n_nations	int
)	O
;	O
load_h_spells	function
(	O
&	O
user	struct
)	O
;	O
user	struct
.	O
visible_sectors	pointer
=	O
(	O
int	O
*	O
*	O
)	O
malloc	function
(	O
world	struct
.	O
xmax	int
*	O
sizeof	O
(	O
int	O
*	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
world	struct
.	O
xmax	int
;	O
++	O
i	int
)	O
{	O
user	struct
.	O
visible_sectors	pointer
[	O
i	int
]	O
=	O
(	O
int	O
*	O
)	O
malloc	function
(	O
world	struct
.	O
ymax	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
}	O
find_visible_sectors	function
(	O
user	struct
.	O
visible_sectors	pointer
)	O
;	O
}	O
void	O
army_visibility	function
(	O
int	O
*	O
*	O
visible_sectors	pointer
,	O
Sarmy	struct
*	O
ap	pointer
)	O
{	O
int	O
x	int
=	O
ap	pointer
->	O
pos	struct
.	O
x	int
,	O
y	int
=	O
ap	pointer
->	O
pos	struct
.	O
y	int
,	O
i	int
,	O
j	int
;	O
Ssector	struct
*	O
sp	int
;	O
sp	int
=	O
&	O
world	struct
.	O
map	pointer
[	O
x	int
]	O
[	O
y	int
]	O
;	O
if	O
(	O
has_hidden	O
(	O
sp	int
)	O
&&	O
sp	int
->	O
owner	int
!=	O
user	struct
.	O
id	short
)	O
{	O
visible_sectors	pointer
[	O
x	int
]	O
[	O
y	int
]	O
=	O
SEE_ARMIES	int
;	O
}	O
else	O
if	O
(	O
sp	int
->	O
owner	int
!=	O
user	struct
.	O
id	short
)	O
{	O
visible_sectors	pointer
[	O
x	int
]	O
[	O
y	int
]	O
=	O
SEE_ARMIES	int
;	O
}	O
else	O
{	O
visible_sectors	pointer
[	O
x	int
]	O
[	O
y	int
]	O
=	O
SEE_ALL	int
;	O
}	O
for	O
(	O
i	int
=	O
x	int
-	O
ARMY_SIGHT	int
;	O
i	int
<=	O
x	int
+	O
ARMY_SIGHT	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
y	int
-	O
ARMY_SIGHT	int
;	O
j	int
<=	O
y	int
+	O
ARMY_SIGHT	int
;	O
++	O
j	int
)	O
{	O
sp	int
=	O
&	O
world	struct
.	O
map	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
;	O
if	O
(	O
has_hidden	O
(	O
sp	int
)	O
&&	O
sp	int
->	O
owner	int
!=	O
user	struct
.	O
id	short
)	O
{	O
}	O
else	O
{	O
visible_sectors	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
|=	O
(	O
SEE_LAND_WATER	int
|	O
SEE_OWNER	int
|	O
SEE_DESIG	int
|	O
SEE_POPULATION	int
|	O
SEE_ARMIES	int
)	O
;	O
}	O
if	O
(	O
world	struct
.	O
map	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
.	O
owner	int
==	O
0	int
)	O
{	O
visible_sectors	pointer
[	O
(	O
*	O
wrapx	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
[	O
(	O
*	O
wrapy	pointer
)	O
(	O
i	int
,	O
j	int
)	O
]	O
|=	O
SEE_RESOURCES	int
;	O
}	O
}	O
}	O
}	O
void	O
options	function
(	O
)	O
{	O
WINDOW	struct
*	O
optw	pointer
;	O
char	O
c	char
;	O
int	O
done	int
=	O
0	int
;	O
optw	pointer
=	O
newwin	function
(	O
12	int
,	O
60	int
,	O
4	int
,	O
7	int
)	O
;	O
while	O
(	O
!	O
done	int
)	O
{	O
mvwprintw	function
(	O
optw	pointer
,	O
1	int
,	O
2	int
,	O
"[x]: toggle expert mode (%s)"	pointer
,	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
expert_mode	int
?	O
"on"	pointer
:	O
"off"	pointer
)	O
;	O
wclrtoeol	function
(	O
optw	pointer
)	O
;	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
)	O
{	O
mvwprintw	function
(	O
optw	pointer
,	O
2	int
,	O
2	int
,	O
"[f]: Change mail forwarding (\"%s\")"	pointer
,	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
)	O
;	O
}	O
else	O
{	O
mvwprintw	function
(	O
optw	pointer
,	O
2	int
,	O
2	int
,	O
"[f]: Change mail forwarding (none)"	pointer
)	O
;	O
}	O
wclrtoeol	function
(	O
optw	pointer
)	O
;	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
)	O
{	O
mvwprintw	function
(	O
optw	pointer
,	O
3	int
,	O
2	int
,	O
"[n]: Change news forwarding (\"%s\")"	pointer
,	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
)	O
;	O
}	O
else	O
{	O
mvwprintw	function
(	O
optw	pointer
,	O
3	int
,	O
2	int
,	O
"[n]: Change news forwarding (none)"	pointer
)	O
;	O
}	O
wclrtoeol	function
(	O
optw	pointer
)	O
;	O
mvwprintw	function
(	O
optw	pointer
,	O
4	int
,	O
2	int
,	O
"[c]: Toggle civilian movement (%s)"	pointer
,	O
civ_move	array
[	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
civ_movemode	int
]	O
)	O
;	O
wclrtoeol	function
(	O
optw	pointer
)	O
;	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
)	O
{	O
free	function
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
)	O
;	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
)	O
{	O
mvwprintw	function
(	O
optw	pointer
,	O
5	int
,	O
2	int
,	O
"[m]: Mail Program (%s)"	pointer
,	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
)	O
;	O
}	O
else	O
{	O
mvwprintw	function
(	O
optw	pointer
,	O
5	int
,	O
2	int
,	O
"[m]: Mail Program (internal)"	pointer
)	O
;	O
}	O
wclrtobot	function
(	O
optw	pointer
)	O
;	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
)	O
{	O
mvwprintw	function
(	O
optw	pointer
,	O
6	int
,	O
2	int
,	O
"[e]: Editor Program (%s)"	pointer
,	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
)	O
;	O
}	O
else	O
{	O
mvwprintw	function
(	O
optw	pointer
,	O
6	int
,	O
2	int
,	O
"[e]: Editor Program (default)"	pointer
)	O
;	O
}	O
wclrtobot	function
(	O
optw	pointer
)	O
;	O
box	function
(	O
optw	pointer
,	O
'|'	O
,	O
'-'	O
)	O
;	O
wrefresh	function
(	O
optw	pointer
)	O
;	O
statline	function
(	O
"Choose an option, hit space to get back."	pointer
,	O
"options"	pointer
)	O
;	O
switch	O
(	O
c	char
=	O
mygetch	function
(	O
)	O
)	O
{	O
case	O
'x'	O
:	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
expert_mode	int
=	O
!	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
expert_mode	int
;	O
user	struct
.	O
xmode	int
=	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
expert_mode	int
;	O
break	O
;	O
case	O
'f'	O
:	O
ask_for_forwarding	function
(	O
optw	pointer
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
civ_movemode	int
=	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
civ_movemode	int
+	O
1	int
)	O
%	O
3	int
;	O
break	O
;	O
case	O
'n'	O
:	O
ask_for_news_forwarding	function
(	O
optw	pointer
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
ask_for_editor	function
(	O
optw	pointer
)	O
;	O
break	O
;	O
case	O
' '	O
:	O
done	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
delwin	function
(	O
optw	pointer
)	O
;	O
user	struct
.	O
just_moved	int
=	O
1	int
;	O
save_options	function
(	O
user	struct
.	O
np	pointer
)	O
;	O
touch_all_wins	function
(	O
)	O
;	O
}	O
void	O
ask_for_news_forwarding	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
char	O
buf	array
[	O
200	int
]	O
;	O
mvwprintw	function
(	O
win	pointer
,	O
9	int
,	O
2	int
,	O
"New news address? (<return> for no forwarding)"	pointer
)	O
;	O
mvwprintw	function
(	O
win	pointer
,	O
10	int
,	O
4	int
,	O
"-->"	pointer
)	O
;	O
wrefresh	function
(	O
win	pointer
)	O
;	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
)	O
;	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
wget_string	function
(	O
win	pointer
,	O
buf	array
,	O
200	int
)	O
>	O
0	int
)	O
{	O
if	O
(	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
strlen	function
(	O
buf	array
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
mem_error	function
(	O
)	O
;	O
}	O
strcpy	function
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
news_forward	pointer
,	O
buf	array
)	O
;	O
}	O
}	O
void	O
ask_for_forwarding	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
char	O
buf	array
[	O
200	int
]	O
;	O
mvwprintw	function
(	O
win	pointer
,	O
9	int
,	O
2	int
,	O
"New mail address? (<return> for no forwarding)"	pointer
)	O
;	O
mvwprintw	function
(	O
win	pointer
,	O
10	int
,	O
4	int
,	O
"-->"	pointer
)	O
;	O
wrefresh	function
(	O
win	pointer
)	O
;	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
!=	O
NULL	O
)	O
{	O
free	function
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
)	O
;	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
wget_string	function
(	O
win	pointer
,	O
buf	array
,	O
200	int
)	O
>	O
0	int
)	O
{	O
if	O
(	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
strlen	function
(	O
buf	array
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
mem_error	function
(	O
)	O
;	O
}	O
strcpy	function
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_forward	pointer
,	O
buf	array
)	O
;	O
}	O
}	O
void	O
ask_for_mail_reader	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
char	O
buf	array
[	O
200	int
]	O
;	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
)	O
{	O
free	function
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
)	O
;	O
}	O
mvwprintw	function
(	O
win	pointer
,	O
9	int
,	O
2	int
,	O
"New mail reader? (<return> for internal mail)"	pointer
)	O
;	O
mvwprintw	function
(	O
win	pointer
,	O
10	int
,	O
4	int
,	O
"-->"	pointer
)	O
;	O
wrefresh	function
(	O
win	pointer
)	O
;	O
if	O
(	O
wget_string	function
(	O
win	pointer
,	O
buf	array
,	O
200	int
)	O
>	O
0	int
)	O
{	O
if	O
(	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
strlen	function
(	O
buf	array
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
mem_error	function
(	O
)	O
;	O
}	O
strcpy	function
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
,	O
buf	array
)	O
;	O
}	O
else	O
{	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
mail_reader	pointer
=	O
NULL	O
;	O
}	O
}	O
void	O
ask_for_editor	function
(	O
WINDOW	struct
*	O
win	pointer
)	O
{	O
WINDOW	struct
*	O
suboptw	pointer
;	O
char	O
buf	array
[	O
200	int
]	O
;	O
int	O
i	int
=	O
1	int
,	O
num	int
;	O
FILE	struct
*	O
fp	pointer
;	O
if	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
)	O
{	O
free	function
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
)	O
;	O
}	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
EDITORS_FILE	pointer
,	O
"r"	pointer
)	O
)	O
)	O
{	O
fgets	function
(	O
buf	array
,	O
199	int
,	O
fp	pointer
)	O
;	O
if	O
(	O
sscanf	function
(	O
buf	array
,	O
"%d"	pointer
,	O
&	O
num	int
)	O
<	O
1	int
)	O
{	O
mvwprintw	function
(	O
win	pointer
,	O
9	int
,	O
2	int
,	O
"You are not allowed to change editors. "	pointer
)	O
;	O
wrefresh	function
(	O
win	pointer
)	O
;	O
get_space	function
(	O
)	O
;	O
}	O
suboptw	pointer
=	O
newwin	function
(	O
num	int
+	O
4	int
,	O
30	int
,	O
8	int
,	O
10	int
)	O
;	O
while	O
(	O
fgets	function
(	O
buf	array
,	O
199	int
,	O
fp	pointer
)	O
)	O
{	O
mvwprintw	function
(	O
suboptw	pointer
,	O
i	int
,	O
2	int
,	O
"%d : %s"	pointer
,	O
i	int
,	O
buf	array
)	O
;	O
i	int
++	O
;	O
}	O
rewind	function
(	O
fp	pointer
)	O
;	O
mvwprintw	function
(	O
suboptw	pointer
,	O
i	int
,	O
2	int
,	O
"Select and editor by number "	pointer
)	O
;	O
mvwprintw	function
(	O
suboptw	pointer
,	O
i	int
+	O
1	int
,	O
4	int
,	O
"-->"	pointer
)	O
;	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
=	O
NULL	O
;	O
box	function
(	O
suboptw	pointer
,	O
'|'	O
,	O
'-'	O
)	O
;	O
wrefresh	function
(	O
suboptw	pointer
)	O
;	O
if	O
(	O
wget_string	function
(	O
suboptw	pointer
,	O
buf	array
,	O
200	int
)	O
>	O
0	int
)	O
{	O
if	O
(	O
sscanf	function
(	O
buf	array
,	O
"%d"	pointer
,	O
&	O
num	int
)	O
>	O
0	int
)	O
{	O
i	int
=	O
-	O
1	int
;	O
while	O
(	O
(	O
i	int
<	O
num	int
)	O
&&	O
(	O
fgets	function
(	O
buf	array
,	O
199	int
,	O
fp	pointer
)	O
)	O
)	O
i	int
++	O
;	O
if	O
(	O
(	O
i	int
==	O
num	int
)	O
&&	O
(	O
num	int
>	O
0	int
)	O
)	O
{	O
if	O
(	O
buf	array
[	O
strlen	function
(	O
buf	array
)	O
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
buf	array
[	O
strlen	function
(	O
buf	array
)	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
if	O
(	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
strlen	function
(	O
buf	array
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
mem_error	function
(	O
)	O
;	O
}	O
strcpy	function
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
,	O
buf	array
)	O
;	O
}	O
}	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
else	O
{	O
mvwprintw	function
(	O
win	pointer
,	O
9	int
,	O
2	int
,	O
"New editor? (<return> for default)"	pointer
)	O
;	O
mvwprintw	function
(	O
win	pointer
,	O
10	int
,	O
4	int
,	O
"-->"	pointer
)	O
;	O
wrefresh	function
(	O
win	pointer
)	O
;	O
if	O
(	O
wget_string	function
(	O
win	pointer
,	O
buf	array
,	O
200	int
)	O
>	O
0	int
)	O
{	O
if	O
(	O
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
(	O
strlen	function
(	O
buf	array
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
)	O
==	O
NULL	O
)	O
{	O
mem_error	function
(	O
)	O
;	O
}	O
strcpy	function
(	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
,	O
buf	array
)	O
;	O
}	O
else	O
{	O
user	struct
.	O
np	pointer
->	O
opts	pointer
->	O
editor	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
void	O
handle_locks	function
(	O
int	O
id	short
)	O
{	O
FILE	struct
*	O
lock_fp	pointer
,	O
*	O
is_locked	function
(	O
)	O
;	O
char	O
*	O
timestr	pointer
;	O
long	O
secs	long
;	O
if	O
(	O
strcmp	function
(	O
update_time	pointer
,	O
get_update_time	function
(	O
)	O
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error: Update has occured.  Please restart program \n"	pointer
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
if	O
(	O
(	O
lock_fp	pointer
=	O
is_locked	function
(	O
id	short
)	O
)	O
)	O
{	O
fscanf	function
(	O
lock_fp	pointer
,	O
"%ld"	pointer
,	O
&	O
secs	long
)	O
;	O
fclose	function
(	O
lock_fp	pointer
)	O
;	O
timestr	pointer
=	O
ctime	function
(	O
&	O
secs	long
)	O
;	O
printf	function
(	O
"\r\nYour nation is already being played.\n\r"	pointer
)	O
;	O
printf	function
(	O
"That session seems to have been started at %s"	pointer
,	O
timestr	pointer
)	O
;	O
printf	function
(	O
"If that session is no more and you want to play now, type [y] "	pointer
)	O
;	O
if	O
(	O
getchar	function
(	O
)	O
!=	O
'y'	O
)	O
{	O
printf	function
(	O
"OK, then you will have to wait until that session is over\n"	pointer
)	O
;	O
clean_exit	function
(	O
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
set_lock	function
(	O
id	short
)	O
;	O
}	O
