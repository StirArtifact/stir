char	O
*	O
username_valid_chars	pointer
;	O
int	O
check_user_name	function
(	O
char	O
*	O
p	pointer
)	O
{	O
for	O
(	O
;	O
*	O
p	pointer
&&	O
(	O
isalnum	function
(	O
*	O
p	pointer
)	O
||	O
strchr	function
(	O
username_valid_chars	pointer
,	O
*	O
p	pointer
)	O
)	O
;	O
p	pointer
++	O
)	O
;	O
return	O
*	O
p	pointer
;	O
}	O
LOCK_DECLARE	O
(	O
lock	O
)	O
static	O
enum	O
auth_status	enum
unix_expiration	function
(	O
char	O
*	O
name	pointer
,	O
time_t	long
*	O
exp	pointer
)	O
{	O
enum	O
auth_status	enum
status	int
=	O
auth_ok	int
;	O
STRUCT_SHADOW_PASSWD	O
*	O
spwd	struct
=	O
GETSPNAM	O
(	O
name	pointer
)	O
;	O
if	O
(	O
spwd	struct
&&	O
SHADOW_PASSWD_EXPIRE	O
(	O
spwd	struct
)	O
>	O
0	int
)	O
{	O
time_t	long
t	long
=	O
time	struct
(	O
NULL	O
)	O
;	O
if	O
(	O
t	long
>	O
SHADOW_PASSWD_EXPIRE	O
(	O
spwd	struct
)	O
*	O
SECONDS_PER_DAY	int
)	O
status	int
=	O
auth_account_expired	int
;	O
else	O
{	O
*	O
exp	pointer
=	O
SHADOW_PASSWD_EXPIRE	O
(	O
spwd	struct
)	O
*	O
SECONDS_PER_DAY	int
-	O
t	long
;	O
status	int
=	O
auth_valid	int
;	O
}	O
}	O
return	O
status	int
;	O
}	O
static	O
int	O
unix_pass	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
passwd	struct
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
encpw	pointer
;	O
int	O
pwlen	long
;	O
char	O
*	O
encrypted_pass	pointer
=	O
NULL	O
;	O
STRUCT_SHADOW_PASSWD	O
*	O
spwd	struct
;	O
LOCK_SET	O
(	O
lock	O
)	O
;	O
if	O
(	O
spwd	struct
=	O
GETSPNAM	O
(	O
name	pointer
)	O
)	O
encrypted_pass	pointer
=	O
SHADOW_PASSWD_ENCRYPTED	O
(	O
spwd	struct
)	O
;	O
else	O
{	O
struct	O
passwd	struct
*	O
pwd	pointer
;	O
if	O
(	O
pwd	pointer
=	O
getpwnam	function
(	O
name	pointer
)	O
)	O
encrypted_pass	pointer
=	O
pwd	pointer
->	O
pw_passwd	pointer
;	O
}	O
if	O
(	O
encrypted_pass	pointer
)	O
{	O
if	O
(	O
encrypted_pass	pointer
[	O
0	int
]	O
==	O
0	int
)	O
encrypted_pass	pointer
=	O
NULL	O
;	O
else	O
encrypted_pass	pointer
=	O
grad_estrdup	function
(	O
encrypted_pass	pointer
)	O
;	O
}	O
LOCK_RELEASE	O
(	O
lock	O
)	O
;	O
if	O
(	O
!	O
encrypted_pass	pointer
)	O
return	O
-	O
1	int
;	O
pwlen	long
=	O
strlen	function
(	O
encrypted_pass	pointer
)	O
;	O
encpw	pointer
=	O
grad_emalloc	function
(	O
pwlen	long
+	O
1	int
)	O
;	O
rc	int
=	O
grad_md5crypt	function
(	O
passwd	struct
,	O
encrypted_pass	pointer
,	O
encpw	pointer
,	O
pwlen	long
+	O
1	int
)	O
==	O
NULL	O
||	O
strlen	function
(	O
encpw	pointer
)	O
!=	O
pwlen	long
||	O
memcmp	function
(	O
encpw	pointer
,	O
encrypted_pass	pointer
,	O
pwlen	long
)	O
;	O
grad_free	function
(	O
encpw	pointer
)	O
;	O
grad_free	function
(	O
encrypted_pass	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
return	O
-	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
rad_auth_check_username	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
int	O
activefd	int
)	O
{	O
grad_avp_t	struct
*	O
namepair	pointer
=	O
grad_avl_find	function
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_USER_NAME	int
)	O
;	O
log_open	function
(	O
GRAD_LOG_AUTH	O
)	O
;	O
if	O
(	O
grad_avp_null_string_p	function
(	O
namepair	pointer
)	O
)	O
grad_log_req	function
(	O
GRAD_LOG_ERR	int
,	O
radreq	pointer
->	O
request	pointer
,	O
_	O
(	O
"No username"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
check_user_name	function
(	O
namepair	pointer
->	O
avp_strvalue	O
)	O
)	O
grad_log_req	function
(	O
GRAD_LOG_ERR	int
,	O
radreq	pointer
->	O
request	pointer
,	O
_	O
(	O
"Malformed username"	pointer
)	O
)	O
;	O
else	O
return	O
0	int
;	O
if	O
(	O
auth_reject_malformed_names	int
)	O
radius_send_reply	function
(	O
RT_ACCESS_REJECT	int
,	O
radreq	pointer
,	O
NULL	O
,	O
message_text	array
[	O
MSG_ACCESS_DENIED	int
]	O
,	O
activefd	int
)	O
;	O
else	O
stat_inc	O
(	O
auth	O
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_bad_req	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
int	O
rad_auth_init	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
int	O
activefd	int
)	O
{	O
grad_locus_t	struct
loc	struct
;	O
log_open	function
(	O
GRAD_LOG_AUTH	O
)	O
;	O
if	O
(	O
auth_detail	int
)	O
write_detail	function
(	O
radreq	pointer
,	O
REQ_AUTH_ZERO	int
,	O
R_AUTH	int
)	O
;	O
if	O
(	O
!	O
huntgroup_access	function
(	O
radreq	pointer
,	O
&	O
loc	struct
)	O
)	O
{	O
grad_log_req	function
(	O
GRAD_LOG_NOTICE	int
,	O
radreq	pointer
->	O
request	pointer
,	O
_	O
(	O
"Access denied by huntgroup %s:%d"	pointer
)	O
,	O
loc	struct
.	O
file	pointer
,	O
loc	struct
.	O
line	long
)	O
;	O
radius_send_reply	function
(	O
RT_ACCESS_REJECT	int
,	O
radreq	pointer
,	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
NULL	O
,	O
activefd	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
enum	O
auth_state	enum
{	O
as_init	int
,	O
as_validate	int
,	O
as_disable	int
,	O
as_realmuse	int
,	O
as_simuse	int
,	O
as_time	int
,	O
as_scheme	int
,	O
as_ipaddr	int
,	O
as_exec_wait	int
,	O
as_cleanup_cbkid	int
,	O
as_menu_challenge	int
,	O
as_ack	int
,	O
as_exec_nowait	int
,	O
as_stop	int
,	O
as_reject	int
,	O
as_reject_cleanup	int
,	O
AS_COUNT	int
}	O
;	O
enum	O
list_id	enum
{	O
L_null	int
,	O
L_req	int
,	O
L_reply	int
,	O
L_check	int
}	O
;	O
typedef	O
struct	O
auth_mach	struct
{	O
radiusd_request_t	struct
*	O
req	pointer
;	O
grad_avp_t	struct
*	O
user_check	pointer
;	O
grad_avp_t	struct
*	O
user_reply	pointer
;	O
int	O
activefd	int
;	O
grad_avp_t	struct
*	O
namepair	pointer
;	O
grad_avp_t	struct
*	O
check_pair	pointer
;	O
char	O
userpass	array
[	O
GRAD_STRING_LENGTH	int
+	O
1	int
]	O
;	O
char	O
*	O
user_msg	pointer
;	O
struct	O
obstack	struct
msg_stack	struct
;	O
enum	O
auth_state	enum
state	pointer
;	O
}	O
AUTH_MACH	struct
;	O
static	O
void	O
sfn_init	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_validate	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_scheme	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_disable	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_realmuse	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_simuse	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_time	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_ipaddr	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_exec_wait	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_cleanup_cbkid	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_menu_challenge	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_ack	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_exec_nowait	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_reject	function
(	O
AUTH_MACH	struct
*	O
)	O
;	O
static	O
void	O
sfn_reject_cleanup	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
;	O
static	O
int	O
check_expiration	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
;	O
struct	O
auth_state_s	struct
{	O
enum	O
auth_state	enum
this	enum
;	O
enum	O
auth_state	enum
next	pointer
;	O
int	O
attr	pointer
;	O
enum	O
list_id	enum
list	pointer
;	O
void	O
(	O
*	O
sfn	pointer
)	O
(	O
AUTH_MACH	struct
*	O
)	O
;	O
}	O
;	O
struct	O
auth_state_s	struct
states	array
[	O
]	O
=	O
{	O
{	O
as_init	int
,	O
as_validate	int
,	O
0	int
,	O
L_null	int
,	O
sfn_init	function
}	O
,	O
{	O
as_validate	int
,	O
as_disable	int
,	O
0	int
,	O
L_null	int
,	O
sfn_validate	function
}	O
,	O
{	O
as_disable	int
,	O
as_realmuse	int
,	O
0	int
,	O
L_null	int
,	O
sfn_disable	function
}	O
,	O
{	O
as_realmuse	int
,	O
as_simuse	int
,	O
0	int
,	O
L_null	int
,	O
sfn_realmuse	function
}	O
,	O
{	O
as_simuse	int
,	O
as_time	int
,	O
DA_SIMULTANEOUS_USE	int
,	O
L_check	int
,	O
sfn_simuse	function
}	O
,	O
{	O
as_time	int
,	O
as_scheme	int
,	O
DA_LOGIN_TIME	int
,	O
L_check	int
,	O
sfn_time	function
}	O
,	O
{	O
as_scheme	int
,	O
as_ipaddr	int
,	O
DA_SCHEME_PROCEDURE	int
,	O
L_reply	int
,	O
sfn_scheme	function
}	O
,	O
{	O
as_ipaddr	int
,	O
as_exec_wait	int
,	O
0	int
,	O
L_null	int
,	O
sfn_ipaddr	function
}	O
,	O
{	O
as_exec_wait	int
,	O
as_cleanup_cbkid	int
,	O
DA_EXEC_PROGRAM_WAIT	int
,	O
L_reply	int
,	O
sfn_exec_wait	function
}	O
,	O
{	O
as_cleanup_cbkid	int
,	O
as_menu_challenge	int
,	O
DA_CALLBACK_ID	int
,	O
L_reply	int
,	O
sfn_cleanup_cbkid	function
}	O
,	O
{	O
as_menu_challenge	int
,	O
as_ack	int
,	O
DA_MENU	int
,	O
L_reply	int
,	O
sfn_menu_challenge	function
}	O
,	O
{	O
as_ack	int
,	O
as_exec_nowait	int
,	O
0	int
,	O
L_null	int
,	O
sfn_ack	function
}	O
,	O
{	O
as_exec_nowait	int
,	O
as_stop	int
,	O
DA_EXEC_PROGRAM	int
,	O
L_reply	int
,	O
sfn_exec_nowait	function
}	O
,	O
{	O
as_stop	int
,	O
as_stop	int
,	O
0	int
,	O
L_null	int
,	O
NULL	O
}	O
,	O
{	O
as_reject	int
,	O
as_stop	int
,	O
0	int
,	O
L_null	int
,	O
sfn_reject	function
}	O
,	O
{	O
as_reject_cleanup	int
,	O
as_reject	int
,	O
0	int
,	O
L_null	int
,	O
sfn_reject_cleanup	function
}	O
,	O
}	O
;	O
static	O
int	O
is_log_mode	function
(	O
AUTH_MACH	struct
*	O
m	pointer
,	O
int	O
mask	int
)	O
;	O
static	O
void	O
auth_format_msg	function
(	O
AUTH_MACH	struct
*	O
m	pointer
,	O
int	O
msg_id	int
)	O
;	O
static	O
char	O
*	O
auth_finish_msg	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
;	O
static	O
void	O
auth_log	function
(	O
AUTH_MACH	struct
*	O
m	pointer
,	O
const	O
char	O
*	O
diag	pointer
,	O
const	O
char	O
*	O
pass	pointer
,	O
const	O
char	O
*	O
reason	pointer
,	O
const	O
char	O
*	O
addstr	pointer
)	O
{	O
if	O
(	O
reason	pointer
)	O
grad_log_req	function
(	O
GRAD_LOG_NOTICE	int
,	O
m	pointer
->	O
req	pointer
->	O
request	pointer
,	O
"%s [%s%s%s]: %s%s"	pointer
,	O
diag	pointer
,	O
m	pointer
->	O
namepair	pointer
->	O
avp_strvalue	O
,	O
pass	pointer
?	O
"/"	pointer
:	O
""	pointer
,	O
pass	pointer
?	O
pass	pointer
:	O
""	pointer
,	O
reason	pointer
,	O
addstr	pointer
?	O
addstr	pointer
:	O
""	pointer
)	O
;	O
else	O
grad_log_req	function
(	O
GRAD_LOG_NOTICE	int
,	O
m	pointer
->	O
req	pointer
->	O
request	pointer
,	O
"%s [%s%s%s]"	pointer
,	O
diag	pointer
,	O
m	pointer
->	O
namepair	pointer
->	O
avp_strvalue	O
,	O
pass	pointer
?	O
"/"	pointer
:	O
""	pointer
,	O
pass	pointer
?	O
pass	pointer
:	O
""	pointer
)	O
;	O
}	O
int	O
is_log_mode	function
(	O
AUTH_MACH	struct
*	O
m	pointer
,	O
int	O
mask	int
)	O
{	O
int	O
mode	int
=	O
log_mode	int
;	O
int	O
xmask	int
=	O
0	int
;	O
grad_avp_t	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
grad_avl_find	function
(	O
m	pointer
->	O
user_check	pointer
,	O
DA_LOG_MODE_MASK	int
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
?	O
grad_avl_find	function
(	O
p	pointer
->	O
next	pointer
,	O
DA_LOG_MODE_MASK	int
)	O
:	O
NULL	O
)	O
xmask	int
|=	O
p	pointer
->	O
avp_lvalue	O
;	O
for	O
(	O
p	pointer
=	O
grad_avl_find	function
(	O
m	pointer
->	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_LOG_MODE_MASK	int
)	O
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
?	O
grad_avl_find	function
(	O
p	pointer
->	O
next	pointer
,	O
DA_LOG_MODE_MASK	int
)	O
:	O
NULL	O
)	O
xmask	int
|=	O
p	pointer
->	O
avp_lvalue	O
;	O
return	O
(	O
mode	int
&	O
~	O
xmask	int
)	O
&	O
mask	int
;	O
}	O
void	O
auth_format_msg	function
(	O
AUTH_MACH	struct
*	O
m	pointer
,	O
int	O
msg_id	int
)	O
{	O
int	O
len	int
=	O
strlen	function
(	O
message_text	array
[	O
msg_id	int
]	O
)	O
;	O
obstack_grow	O
(	O
&	O
m	pointer
->	O
msg_stack	struct
,	O
message_text	array
[	O
msg_id	int
]	O
,	O
len	int
)	O
;	O
}	O
char	O
*	O
auth_finish_msg	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
if	O
(	O
m	pointer
->	O
user_msg	pointer
)	O
obstack_grow	O
(	O
&	O
m	pointer
->	O
msg_stack	struct
,	O
m	pointer
->	O
user_msg	pointer
,	O
strlen	function
(	O
m	pointer
->	O
user_msg	pointer
)	O
)	O
;	O
obstack_1grow	O
(	O
&	O
m	pointer
->	O
msg_stack	struct
,	O
0	int
)	O
;	O
return	O
radius_xlate	function
(	O
&	O
m	pointer
->	O
msg_stack	struct
,	O
obstack_finish	O
(	O
&	O
m	pointer
->	O
msg_stack	struct
)	O
,	O
m	pointer
->	O
req	pointer
->	O
request	pointer
,	O
m	pointer
->	O
user_reply	pointer
)	O
;	O
}	O
static	O
enum	O
auth_status	enum
rad_check_password	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
AUTH_MACH	struct
*	O
m	pointer
,	O
time_t	long
*	O
exp	pointer
)	O
{	O
char	O
*	O
ptr	pointer
;	O
char	O
*	O
real_password	pointer
=	O
NULL	O
;	O
char	O
name	pointer
[	O
GRAD_STRING_LENGTH	int
]	O
;	O
grad_avp_t	struct
*	O
auth_item	pointer
;	O
grad_avp_t	struct
*	O
tmp	pointer
;	O
int	O
auth_type	int
=	O
-	O
1	int
;	O
int	O
length	short
;	O
enum	O
auth_status	enum
result	pointer
=	O
auth_ok	int
;	O
char	O
*	O
authdata	pointer
=	O
NULL	O
;	O
char	O
pw_digest	array
[	O
GRAD_AUTHENTICATOR_LENGTH	int
]	O
;	O
int	O
pwlen	long
;	O
char	O
*	O
pwbuf	pointer
;	O
char	O
*	O
challenge	pointer
;	O
int	O
challenge_len	int
;	O
m	pointer
->	O
userpass	array
[	O
0	int
]	O
=	O
0	int
;	O
if	O
(	O
(	O
tmp	pointer
=	O
grad_avl_find	function
(	O
m	pointer
->	O
user_check	pointer
,	O
DA_AUTH_TYPE	int
)	O
)	O
!=	O
NULL	O
)	O
auth_type	int
=	O
tmp	pointer
->	O
avp_lvalue	O
;	O
switch	O
(	O
auth_type	int
)	O
{	O
case	O
DV_AUTH_TYPE_ACCEPT	int
:	O
return	O
auth_ok	int
;	O
case	O
DV_AUTH_TYPE_REJECT	int
:	O
return	O
auth_reject	int
;	O
case	O
DV_AUTH_TYPE_IGNORE	int
:	O
return	O
auth_ignore	int
;	O
}	O
if	O
(	O
auth_item	pointer
=	O
grad_avl_find	function
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_CHAP_PASSWORD	int
)	O
)	O
auth_type	int
=	O
DV_AUTH_TYPE_LOCAL	int
;	O
else	O
auth_item	pointer
=	O
grad_avl_find	function
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_USER_PASSWORD	int
)	O
;	O
if	O
(	O
auth_item	pointer
)	O
{	O
if	O
(	O
auth_item	pointer
->	O
avp_strlength	O
==	O
0	int
)	O
m	pointer
->	O
userpass	array
[	O
0	int
]	O
=	O
0	int
;	O
else	O
req_decrypt_password	function
(	O
m	pointer
->	O
userpass	array
,	O
radreq	pointer
->	O
request	pointer
,	O
auth_item	pointer
)	O
;	O
}	O
else	O
return	O
auth_fail	int
;	O
if	O
(	O
(	O
tmp	pointer
=	O
grad_avl_find	function
(	O
m	pointer
->	O
user_check	pointer
,	O
DA_AUTH_DATA	int
)	O
)	O
!=	O
NULL	O
)	O
authdata	pointer
=	O
tmp	pointer
->	O
avp_strvalue	O
;	O
tmp	pointer
=	O
grad_avl_find	function
(	O
m	pointer
->	O
user_check	pointer
,	O
DA_USER_PASSWORD	int
)	O
;	O
if	O
(	O
tmp	pointer
)	O
real_password	pointer
=	O
grad_estrdup	function
(	O
tmp	pointer
->	O
avp_strvalue	O
)	O
;	O
else	O
if	O
(	O
tmp	pointer
=	O
grad_avl_find	function
(	O
m	pointer
->	O
user_check	pointer
,	O
DA_PASSWORD_LOCATION	int
)	O
)	O
{	O
switch	O
(	O
tmp	pointer
->	O
avp_lvalue	O
)	O
{	O
case	O
DV_PASSWORD_LOCATION_SQL	int
:	O
default	O
:	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"unknown Password-Location value: %ld"	pointer
)	O
,	O
tmp	pointer
->	O
avp_lvalue	O
)	O
;	O
return	O
auth_fail	int
;	O
}	O
}	O
strip_username	function
(	O
1	int
,	O
m	pointer
->	O
namepair	pointer
->	O
avp_strvalue	O
,	O
m	pointer
->	O
user_check	pointer
,	O
name	pointer
)	O
;	O
GRAD_DEBUG4	O
(	O
1	int
,	O
"auth_type=%d, userpass=%s, name=%s, password=%s"	pointer
,	O
auth_type	int
,	O
m	pointer
->	O
userpass	array
,	O
name	pointer
,	O
real_password	pointer
?	O
real_password	pointer
:	O
"NONE"	pointer
)	O
;	O
switch	O
(	O
auth_type	int
)	O
{	O
case	O
DV_AUTH_TYPE_SYSTEM	int
:	O
GRAD_DEBUG	O
(	O
1	int
,	O
"auth: System"	pointer
)	O
;	O
if	O
(	O
unix_pass	function
(	O
name	pointer
,	O
m	pointer
->	O
userpass	array
)	O
!=	O
0	int
)	O
result	pointer
=	O
auth_fail	int
;	O
else	O
result	pointer
=	O
unix_expiration	function
(	O
name	pointer
,	O
exp	pointer
)	O
;	O
break	O
;	O
case	O
DV_AUTH_TYPE_PAM	int
:	O
grad_log_req	function
(	O
GRAD_LOG_ERR	int
,	O
radreq	pointer
->	O
request	pointer
,	O
_	O
(	O
"PAM authentication not available"	pointer
)	O
)	O
;	O
result	pointer
=	O
auth_nouser	int
;	O
break	O
;	O
case	O
DV_AUTH_TYPE_CRYPT_LOCAL	int
:	O
GRAD_DEBUG	O
(	O
1	int
,	O
"auth: Crypt"	pointer
)	O
;	O
if	O
(	O
real_password	pointer
==	O
NULL	O
)	O
{	O
result	pointer
=	O
auth_fail	int
;	O
break	O
;	O
}	O
pwlen	long
=	O
strlen	function
(	O
real_password	pointer
)	O
+	O
1	int
;	O
pwbuf	pointer
=	O
grad_emalloc	function
(	O
pwlen	long
)	O
;	O
if	O
(	O
!	O
grad_md5crypt	function
(	O
m	pointer
->	O
userpass	array
,	O
real_password	pointer
,	O
pwbuf	pointer
,	O
pwlen	long
)	O
)	O
result	pointer
=	O
auth_fail	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
real_password	pointer
,	O
pwbuf	pointer
)	O
!=	O
0	int
)	O
result	pointer
=	O
auth_fail	int
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"pwbuf: %s"	pointer
,	O
pwbuf	pointer
)	O
;	O
grad_free	function
(	O
pwbuf	pointer
)	O
;	O
break	O
;	O
case	O
DV_AUTH_TYPE_LOCAL	int
:	O
GRAD_DEBUG	O
(	O
1	int
,	O
"auth: Local"	pointer
)	O
;	O
if	O
(	O
auth_item	pointer
->	O
attribute	int
!=	O
DA_CHAP_PASSWORD	int
)	O
{	O
if	O
(	O
real_password	pointer
==	O
NULL	O
||	O
strcmp	function
(	O
real_password	pointer
,	O
m	pointer
->	O
userpass	array
)	O
!=	O
0	int
)	O
result	pointer
=	O
auth_fail	int
;	O
break	O
;	O
}	O
strcpy	function
(	O
m	pointer
->	O
userpass	array
,	O
"{chap-password}"	pointer
)	O
;	O
if	O
(	O
real_password	pointer
==	O
NULL	O
)	O
{	O
result	pointer
=	O
auth_fail	int
;	O
break	O
;	O
}	O
length	short
=	O
strlen	function
(	O
real_password	pointer
)	O
;	O
if	O
(	O
tmp	pointer
=	O
grad_avl_find	function
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_CHAP_CHALLENGE	int
)	O
)	O
{	O
challenge	pointer
=	O
tmp	pointer
->	O
avp_strvalue	O
;	O
challenge_len	int
=	O
tmp	pointer
->	O
avp_strlength	O
;	O
}	O
else	O
{	O
challenge	pointer
=	O
radreq	pointer
->	O
request	pointer
->	O
authenticator	array
;	O
challenge_len	int
=	O
GRAD_AUTHENTICATOR_LENGTH	int
;	O
}	O
pwlen	long
=	O
1	int
+	O
length	short
+	O
challenge_len	int
;	O
pwbuf	pointer
=	O
grad_emalloc	function
(	O
pwlen	long
)	O
;	O
ptr	pointer
=	O
pwbuf	pointer
;	O
*	O
ptr	pointer
++	O
=	O
*	O
auth_item	pointer
->	O
avp_strvalue	O
;	O
memcpy	function
(	O
ptr	pointer
,	O
real_password	pointer
,	O
length	short
)	O
;	O
ptr	pointer
+=	O
length	short
;	O
memcpy	function
(	O
ptr	pointer
,	O
challenge	pointer
,	O
challenge_len	int
)	O
;	O
grad_md5_calc	function
(	O
pw_digest	array
,	O
(	O
u_char	char
*	O
)	O
pwbuf	pointer
,	O
pwlen	long
)	O
;	O
grad_free	function
(	O
pwbuf	pointer
)	O
;	O
if	O
(	O
memcmp	function
(	O
pw_digest	array
,	O
auth_item	pointer
->	O
avp_strvalue	O
+	O
1	int
,	O
GRAD_CHAP_VALUE_LENGTH	int
)	O
!=	O
0	int
)	O
result	pointer
=	O
auth_fail	int
;	O
else	O
strcpy	function
(	O
m	pointer
->	O
userpass	array
,	O
real_password	pointer
)	O
;	O
break	O
;	O
default	O
:	O
result	pointer
=	O
scheme_try_auth	function
(	O
auth_type	int
,	O
radreq	pointer
,	O
m	pointer
->	O
user_check	pointer
,	O
&	O
m	pointer
->	O
user_reply	pointer
)	O
?	O
auth_fail	int
:	O
auth_ok	int
;	O
break	O
;	O
}	O
if	O
(	O
real_password	pointer
)	O
{	O
memset	function
(	O
real_password	pointer
,	O
0	int
,	O
strlen	function
(	O
real_password	pointer
)	O
)	O
;	O
grad_free	function
(	O
real_password	pointer
)	O
;	O
}	O
return	O
result	pointer
;	O
}	O
enum	O
auth_status	enum
radius_check_expiration	function
(	O
AUTH_MACH	struct
*	O
m	pointer
,	O
time_t	long
*	O
exp	pointer
)	O
{	O
grad_avp_t	struct
*	O
pair	pointer
;	O
if	O
(	O
pair	pointer
=	O
grad_avl_find	function
(	O
m	pointer
->	O
user_check	pointer
,	O
DA_EXPIRATION	int
)	O
)	O
{	O
struct	O
timeval	struct
tv	pointer
;	O
gettimeofday	function
(	O
&	O
tv	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
tv	pointer
.	O
tv_sec	long
>	O
pair	pointer
->	O
avp_lvalue	O
)	O
return	O
auth_account_expired	int
;	O
*	O
exp	pointer
=	O
pair	pointer
->	O
avp_lvalue	O
-	O
tv	pointer
.	O
tv_sec	long
;	O
return	O
auth_valid	int
;	O
}	O
return	O
auth_ok	int
;	O
}	O
int	O
rad_authenticate	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
int	O
activefd	int
)	O
{	O
enum	O
auth_state	enum
oldstate	enum
;	O
struct	O
auth_state_s	struct
*	O
sp	pointer
;	O
struct	O
auth_mach	struct
m	pointer
;	O
log_open	function
(	O
GRAD_LOG_AUTH	O
)	O
;	O
m	pointer
.	O
req	pointer
=	O
radreq	pointer
;	O
m	pointer
.	O
activefd	int
=	O
activefd	int
;	O
m	pointer
.	O
user_check	pointer
=	O
NULL	O
;	O
m	pointer
.	O
user_reply	pointer
=	O
NULL	O
;	O
m	pointer
.	O
check_pair	pointer
=	O
NULL	O
;	O
m	pointer
.	O
user_msg	pointer
=	O
NULL	O
;	O
obstack_init	O
(	O
&	O
m	pointer
.	O
msg_stack	struct
)	O
;	O
m	pointer
.	O
namepair	pointer
=	O
grad_avl_find	function
(	O
m	pointer
.	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_USER_NAME	int
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"auth: %s"	pointer
,	O
m	pointer
.	O
namepair	pointer
->	O
avp_strvalue	O
)	O
;	O
m	pointer
.	O
state	pointer
=	O
as_init	int
;	O
while	O
(	O
m	pointer
.	O
state	pointer
!=	O
as_stop	int
)	O
{	O
sp	pointer
=	O
&	O
states	array
[	O
m	pointer
.	O
state	pointer
]	O
;	O
oldstate	enum
=	O
m	pointer
.	O
state	pointer
;	O
if	O
(	O
sp	pointer
->	O
attr	pointer
)	O
{	O
grad_avp_t	struct
*	O
p	pointer
;	O
switch	O
(	O
sp	pointer
->	O
list	pointer
)	O
{	O
case	O
L_req	int
:	O
p	pointer
=	O
m	pointer
.	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
;	O
break	O
;	O
case	O
L_check	int
:	O
p	pointer
=	O
m	pointer
.	O
user_check	pointer
;	O
break	O
;	O
case	O
L_reply	int
:	O
p	pointer
=	O
m	pointer
.	O
user_reply	pointer
;	O
break	O
;	O
default	O
:	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
p	pointer
=	O
grad_avl_find	function
(	O
p	pointer
,	O
sp	pointer
->	O
attr	pointer
)	O
)	O
m	pointer
.	O
check_pair	pointer
=	O
p	pointer
;	O
else	O
{	O
m	pointer
.	O
state	pointer
=	O
sp	pointer
->	O
next	pointer
;	O
continue	O
;	O
}	O
}	O
(	O
*	O
sp	pointer
->	O
sfn	pointer
)	O
(	O
&	O
m	pointer
)	O
;	O
if	O
(	O
oldstate	enum
==	O
m	pointer
.	O
state	pointer
)	O
m	pointer
.	O
state	pointer
=	O
sp	pointer
->	O
next	pointer
;	O
}	O
grad_avl_free	function
(	O
m	pointer
.	O
user_check	pointer
)	O
;	O
grad_avl_free	function
(	O
m	pointer
.	O
user_reply	pointer
)	O
;	O
if	O
(	O
m	pointer
.	O
user_msg	pointer
)	O
free	function
(	O
m	pointer
.	O
user_msg	pointer
)	O
;	O
obstack_free	function
(	O
&	O
m	pointer
.	O
msg_stack	struct
,	O
NULL	O
)	O
;	O
memset	function
(	O
m	pointer
.	O
userpass	array
,	O
0	int
,	O
sizeof	O
(	O
m	pointer
.	O
userpass	array
)	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
sfn_init	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
radiusd_request_t	struct
*	O
radreq	pointer
=	O
m	pointer
->	O
req	pointer
;	O
grad_avp_t	struct
*	O
pair_ptr	pointer
;	O
switch	O
(	O
radreq	pointer
->	O
server_code	int
)	O
{	O
case	O
RT_ACCESS_REJECT	int
:	O
m	pointer
->	O
user_check	pointer
=	O
grad_avp_create_integer	function
(	O
DA_AUTH_TYPE	int
,	O
DV_AUTH_TYPE_REJECT	int
)	O
;	O
break	O
;	O
case	O
RT_ACCESS_ACCEPT	int
:	O
m	pointer
->	O
user_check	pointer
=	O
grad_avp_create_integer	function
(	O
DA_AUTH_TYPE	int
,	O
DV_AUTH_TYPE_ACCEPT	int
)	O
;	O
break	O
;	O
case	O
0	int
:	O
break	O
;	O
default	O
:	O
radius_send_reply	function
(	O
radreq	pointer
->	O
server_code	int
,	O
radreq	pointer
,	O
radreq	pointer
->	O
server_reply	pointer
,	O
NULL	O
,	O
m	pointer
->	O
activefd	int
)	O
;	O
newstate	O
(	O
as_stop	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
radreq	pointer
->	O
server_reply	pointer
)	O
{	O
m	pointer
->	O
user_reply	pointer
=	O
radius_decrypt_request_pairs	function
(	O
radreq	pointer
,	O
radreq	pointer
->	O
server_reply	pointer
)	O
;	O
radreq	pointer
->	O
server_reply	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
user_find	function
(	O
m	pointer
->	O
namepair	pointer
->	O
avp_strvalue	O
,	O
radreq	pointer
,	O
&	O
m	pointer
->	O
user_check	pointer
,	O
&	O
m	pointer
->	O
user_reply	pointer
)	O
!=	O
0	int
&&	O
!	O
radreq	pointer
->	O
server_code	int
)	O
{	O
if	O
(	O
is_log_mode	function
(	O
m	pointer
,	O
RLOG_AUTH	int
)	O
)	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"No such user"	pointer
)	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
auth_format_msg	function
(	O
m	pointer
,	O
MSG_ACCESS_DENIED	int
)	O
;	O
newstate	O
(	O
as_reject_cleanup	int
)	O
;	O
}	O
}	O
void	O
sfn_scheme	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
grad_avp_t	struct
*	O
p	pointer
;	O
grad_avp_t	struct
*	O
tmp	pointer
=	O
NULL	O
;	O
grad_avl_move_attr	function
(	O
&	O
tmp	pointer
,	O
&	O
m	pointer
->	O
user_reply	pointer
,	O
DA_SCHEME_PROCEDURE	int
)	O
;	O
if	O
(	O
scheme_eval_avl	function
(	O
m	pointer
->	O
req	pointer
,	O
m	pointer
->	O
user_check	pointer
,	O
tmp	pointer
,	O
&	O
m	pointer
->	O
user_reply	pointer
,	O
&	O
p	pointer
)	O
)	O
{	O
if	O
(	O
p	pointer
)	O
{	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"Login rejected"	pointer
)	O
,	O
NULL	O
,	O
_	O
(	O
"denied by Scheme procedure "	pointer
)	O
,	O
p	pointer
->	O
avp_strvalue	O
)	O
;	O
newstate	O
(	O
as_reject	int
)	O
;	O
}	O
else	O
{	O
newstate	O
(	O
as_reject_cleanup	int
)	O
;	O
}	O
}	O
grad_avl_free	function
(	O
tmp	pointer
)	O
;	O
}	O
static	O
void	O
auth_failure	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
grad_avp_t	struct
*	O
pair	pointer
;	O
char	O
*	O
cmd	pointer
;	O
pair	pointer
=	O
grad_avl_find	function
(	O
m	pointer
->	O
user_reply	pointer
,	O
DA_AUTH_FAILURE_TRIGGER	int
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
;	O
cmd	pointer
=	O
util_xlate	function
(	O
&	O
m	pointer
->	O
msg_stack	struct
,	O
pair	pointer
->	O
avp_strvalue	O
,	O
m	pointer
->	O
req	pointer
->	O
request	pointer
)	O
;	O
switch	O
(	O
cmd	pointer
[	O
0	int
]	O
)	O
{	O
case	O
'('	O
:	O
scheme_eval_unspecified_expr	function
(	O
cmd	pointer
)	O
;	O
break	O
;	O
case	O
'/'	O
:	O
radius_exec_command	function
(	O
cmd	pointer
)	O
;	O
break	O
;	O
default	O
:	O
grad_log_req	function
(	O
GRAD_LOG_ERR	int
,	O
m	pointer
->	O
req	pointer
->	O
request	pointer
,	O
_	O
(	O
"Invalid Auth-Failure-Trigger value: %s"	pointer
)	O
,	O
cmd	pointer
)	O
;	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"The value of Auth-Failure-Trigger attribute must begin with '/' or '('."	pointer
)	O
)	O
;	O
}	O
}	O
void	O
sfn_validate	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
radiusd_request_t	struct
*	O
radreq	pointer
=	O
m	pointer
->	O
req	pointer
;	O
enum	O
auth_status	enum
rc	int
;	O
time_t	long
exp	pointer
;	O
grad_avp_t	struct
*	O
pair	pointer
;	O
rc	int
=	O
rad_check_password	function
(	O
radreq	pointer
,	O
m	pointer
,	O
&	O
exp	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
auth_ok	int
)	O
{	O
radiusd_sql_auth_result_query	O
(	O
m	pointer
->	O
req	pointer
,	O
0	int
)	O
;	O
rc	int
=	O
radius_check_expiration	function
(	O
m	pointer
,	O
&	O
exp	pointer
)	O
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
auth_fail	int
)	O
{	O
radiusd_sql_auth_result_query	O
(	O
m	pointer
->	O
req	pointer
,	O
1	int
)	O
;	O
auth_failure	function
(	O
m	pointer
)	O
;	O
}	O
switch	O
(	O
rc	int
)	O
{	O
case	O
auth_ok	int
:	O
break	O
;	O
case	O
auth_valid	int
:	O
exp	pointer
/=	O
SECONDS_PER_DAY	int
;	O
if	O
(	O
warning_seconds	int
!=	O
0	int
&&	O
exp	pointer
<	O
warning_seconds	int
)	O
{	O
pair	pointer
=	O
grad_avp_create_integer	function
(	O
DA_PASSWORD_EXPIRE_DAYS	int
,	O
exp	pointer
)	O
;	O
grad_avl_add_pair	function
(	O
&	O
m	pointer
->	O
user_reply	pointer
,	O
pair	pointer
)	O
;	O
auth_format_msg	function
(	O
m	pointer
,	O
MSG_PASSWORD_EXPIRE_WARNING	int
)	O
;	O
}	O
break	O
;	O
case	O
auth_reject	int
:	O
if	O
(	O
is_log_mode	function
(	O
m	pointer
,	O
RLOG_AUTH	int
)	O
)	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"Rejected"	pointer
)	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
newstate	O
(	O
as_reject	int
)	O
;	O
auth_format_msg	function
(	O
m	pointer
,	O
MSG_ACCESS_DENIED	int
)	O
;	O
break	O
;	O
case	O
auth_ignore	int
:	O
if	O
(	O
is_log_mode	function
(	O
m	pointer
,	O
RLOG_AUTH	int
)	O
)	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"Ignored"	pointer
)	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
newstate	O
(	O
as_stop	int
)	O
;	O
break	O
;	O
case	O
auth_nouser	int
:	O
if	O
(	O
is_log_mode	function
(	O
m	pointer
,	O
RLOG_AUTH	int
)	O
)	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"No such user"	pointer
)	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
newstate	O
(	O
as_reject_cleanup	int
)	O
;	O
auth_format_msg	function
(	O
m	pointer
,	O
MSG_ACCESS_DENIED	int
)	O
;	O
break	O
;	O
case	O
auth_fail	int
:	O
if	O
(	O
is_log_mode	function
(	O
m	pointer
,	O
RLOG_AUTH	int
)	O
)	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"Login incorrect"	pointer
)	O
,	O
is_log_mode	function
(	O
m	pointer
,	O
RLOG_FAILED_PASS	int
)	O
?	O
m	pointer
->	O
userpass	array
:	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
newstate	O
(	O
as_reject_cleanup	int
)	O
;	O
auth_format_msg	function
(	O
m	pointer
,	O
MSG_ACCESS_DENIED	int
)	O
;	O
break	O
;	O
case	O
auth_account_expired	int
:	O
auth_format_msg	function
(	O
m	pointer
,	O
MSG_PASSWORD_EXPIRED	int
)	O
;	O
newstate	O
(	O
as_reject_cleanup	int
)	O
;	O
if	O
(	O
is_log_mode	function
(	O
m	pointer
,	O
RLOG_AUTH	int
)	O
)	O
{	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"Login incorrect"	pointer
)	O
,	O
NULL	O
,	O
_	O
(	O
"Account expired"	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
case	O
auth_password_expired	int
:	O
auth_format_msg	function
(	O
m	pointer
,	O
MSG_PASSWORD_EXPIRED	int
)	O
;	O
newstate	O
(	O
as_reject_cleanup	int
)	O
;	O
if	O
(	O
is_log_mode	function
(	O
m	pointer
,	O
RLOG_AUTH	int
)	O
)	O
{	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"Login incorrect"	pointer
)	O
,	O
NULL	O
,	O
_	O
(	O
"Password expired"	pointer
)	O
,	O
NULL	O
)	O
;	O
}	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"sfn_validate"	pointer
)	O
;	O
}	O
return	O
;	O
}	O
void	O
sfn_disable	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
if	O
(	O
get_deny	function
(	O
m	pointer
->	O
namepair	pointer
->	O
avp_strvalue	O
)	O
)	O
{	O
auth_format_msg	function
(	O
m	pointer
,	O
MSG_ACCOUNT_CLOSED	int
)	O
;	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"Account disabled"	pointer
)	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
newstate	O
(	O
as_reject_cleanup	int
)	O
;	O
}	O
}	O
void	O
sfn_realmuse	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
if	O
(	O
!	O
m	pointer
->	O
req	pointer
->	O
realm	array
)	O
return	O
;	O
if	O
(	O
radius_mlc_realm	function
(	O
m	pointer
->	O
req	pointer
)	O
==	O
0	int
)	O
return	O
;	O
auth_format_msg	function
(	O
m	pointer
,	O
MSG_REALM_QUOTA	int
)	O
;	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"Login failed"	pointer
)	O
,	O
NULL	O
,	O
_	O
(	O
"realm quota exceeded for "	pointer
)	O
,	O
m	pointer
->	O
req	pointer
->	O
realm	array
->	O
realm	array
)	O
;	O
newstate	O
(	O
as_reject_cleanup	int
)	O
;	O
}	O
void	O
sfn_simuse	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
char	O
name	pointer
[	O
GRAD_STRING_LENGTH	int
]	O
;	O
int	O
rc	int
;	O
int	O
count	int
;	O
strip_username	function
(	O
strip_names	int
,	O
m	pointer
->	O
namepair	pointer
->	O
avp_strvalue	O
,	O
m	pointer
->	O
user_check	pointer
,	O
name	pointer
)	O
;	O
rc	int
=	O
radius_mlc_user	function
(	O
name	pointer
,	O
m	pointer
->	O
req	pointer
,	O
m	pointer
->	O
check_pair	pointer
->	O
avp_lvalue	O
,	O
&	O
count	int
)	O
;	O
grad_avl_add_pair	function
(	O
&	O
m	pointer
->	O
user_reply	pointer
,	O
grad_avp_create_integer	function
(	O
DA_SIMULTANEOUS_USE	int
,	O
count	int
)	O
)	O
;	O
if	O
(	O
!	O
rc	int
)	O
return	O
;	O
auth_format_msg	function
(	O
m	pointer
,	O
(	O
m	pointer
->	O
check_pair	pointer
->	O
avp_lvalue	O
>	O
1	int
)	O
?	O
MSG_MULTIPLE_LOGIN	int
:	O
MSG_SECOND_LOGIN	int
)	O
;	O
grad_log_req	function
(	O
GRAD_LOG_WARN	int
,	O
m	pointer
->	O
req	pointer
->	O
request	pointer
,	O
_	O
(	O
"Multiple logins: [%s] max. %ld%s"	pointer
)	O
,	O
m	pointer
->	O
namepair	pointer
->	O
avp_strvalue	O
,	O
m	pointer
->	O
check_pair	pointer
->	O
avp_lvalue	O
,	O
rc	int
==	O
2	int
?	O
_	O
(	O
" [MPP attempt]"	pointer
)	O
:	O
""	pointer
)	O
;	O
newstate	O
(	O
as_reject_cleanup	int
)	O
;	O
}	O
static	O
grad_uint32_t	int
set_session_timeout	function
(	O
AUTH_MACH	struct
*	O
m	pointer
,	O
grad_uint32_t	int
val	array
)	O
{	O
grad_avp_t	struct
*	O
p	pointer
;	O
if	O
(	O
!	O
(	O
p	pointer
=	O
grad_avl_find	function
(	O
m	pointer
->	O
user_reply	pointer
,	O
DA_SESSION_TIMEOUT	int
)	O
)	O
)	O
{	O
p	pointer
=	O
grad_avp_create_integer	function
(	O
DA_SESSION_TIMEOUT	int
,	O
val	array
)	O
;	O
grad_avl_add_pair	function
(	O
&	O
m	pointer
->	O
user_reply	pointer
,	O
p	pointer
)	O
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
avp_lvalue	O
>	O
val	array
)	O
p	pointer
->	O
avp_lvalue	O
=	O
val	array
;	O
return	O
p	pointer
->	O
avp_lvalue	O
;	O
}	O
void	O
sfn_time	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
int	O
rc	int
;	O
time_t	long
t	long
;	O
unsigned	O
rest	pointer
;	O
time	struct
(	O
&	O
t	long
)	O
;	O
rc	int
=	O
ts_check	function
(	O
m	pointer
->	O
check_pair	pointer
->	O
avp_strvalue	O
,	O
&	O
t	long
,	O
&	O
rest	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
==	O
1	int
)	O
{	O
auth_format_msg	function
(	O
m	pointer
,	O
MSG_TIMESPAN_VIOLATION	int
)	O
;	O
grad_log_req	function
(	O
GRAD_LOG_ERR	int
,	O
m	pointer
->	O
req	pointer
->	O
request	pointer
,	O
_	O
(	O
"Outside allowed timespan (%s)"	pointer
)	O
,	O
m	pointer
->	O
check_pair	pointer
->	O
avp_strvalue	O
)	O
;	O
newstate	O
(	O
as_reject_cleanup	int
)	O
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
grad_uint32_t	int
to	pointer
=	O
set_session_timeout	function
(	O
m	pointer
,	O
rest	pointer
)	O
;	O
GRAD_DEBUG4	O
(	O
2	int
,	O
"user %s, span %s, timeout %d, real timeout %d"	pointer
,	O
m	pointer
->	O
namepair	pointer
->	O
avp_strvalue	O
,	O
m	pointer
->	O
check_pair	pointer
->	O
avp_strvalue	O
,	O
rest	pointer
,	O
to	pointer
)	O
;	O
}	O
}	O
void	O
sfn_ipaddr	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
grad_avp_t	struct
*	O
p	pointer
,	O
*	O
tmp	pointer
,	O
*	O
pp	pointer
;	O
if	O
(	O
!	O
grad_avl_find	function
(	O
m	pointer
->	O
user_reply	pointer
,	O
DA_FRAMED_IP_ADDRESS	int
)	O
)	O
{	O
if	O
(	O
p	pointer
=	O
grad_avl_find	function
(	O
m	pointer
->	O
req	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_FRAMED_IP_ADDRESS	int
)	O
)	O
{	O
grad_avl_add_pair	function
(	O
&	O
m	pointer
->	O
user_reply	pointer
,	O
grad_avp_dup	function
(	O
p	pointer
)	O
)	O
;	O
}	O
}	O
}	O
void	O
sfn_exec_wait	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
int	O
rc	int
;	O
grad_avp_t	struct
*	O
p	pointer
;	O
grad_avp_t	struct
*	O
reply	pointer
=	O
NULL	O
;	O
rc	int
=	O
exec_program_wait	function
(	O
m	pointer
->	O
req	pointer
,	O
m	pointer
->	O
check_pair	pointer
,	O
&	O
reply	pointer
,	O
&	O
p	pointer
)	O
;	O
if	O
(	O
rc	int
!=	O
0	int
)	O
{	O
newstate	O
(	O
as_reject	int
)	O
;	O
if	O
(	O
is_log_mode	function
(	O
m	pointer
,	O
RLOG_AUTH	int
)	O
)	O
{	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"Login incorrect"	pointer
)	O
,	O
NULL	O
,	O
_	O
(	O
"external check failed: "	pointer
)	O
,	O
p	pointer
->	O
avp_strvalue	O
)	O
;	O
}	O
grad_avl_free	function
(	O
m	pointer
->	O
user_reply	pointer
)	O
;	O
m	pointer
->	O
user_reply	pointer
=	O
reply	pointer
;	O
if	O
(	O
!	O
grad_avl_find	function
(	O
m	pointer
->	O
user_reply	pointer
,	O
DA_REPLY_MESSAGE	int
)	O
)	O
auth_format_msg	function
(	O
m	pointer
,	O
MSG_ACCESS_DENIED	int
)	O
;	O
}	O
else	O
{	O
grad_avl_merge	function
(	O
&	O
m	pointer
->	O
user_reply	pointer
,	O
&	O
reply	pointer
)	O
;	O
grad_avl_free	function
(	O
reply	pointer
)	O
;	O
}	O
}	O
void	O
sfn_exec_nowait	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
grad_avp_t	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
m	pointer
->	O
check_pair	pointer
;	O
p	pointer
;	O
p	pointer
=	O
grad_avl_find	function
(	O
p	pointer
->	O
next	pointer
,	O
DA_EXEC_PROGRAM	int
)	O
)	O
{	O
radius_eval_avp	function
(	O
m	pointer
->	O
req	pointer
,	O
p	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
radius_exec_program	function
(	O
p	pointer
->	O
avp_strvalue	O
,	O
m	pointer
->	O
req	pointer
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
}	O
void	O
sfn_cleanup_cbkid	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
static	O
int	O
delete_pairs	array
[	O
]	O
=	O
{	O
DA_FRAMED_PROTOCOL	int
,	O
DA_FRAMED_IP_ADDRESS	int
,	O
DA_FRAMED_IP_NETMASK	int
,	O
DA_FRAMED_ROUTE	int
,	O
DA_FRAMED_MTU	int
,	O
DA_FRAMED_COMPRESSION	int
,	O
DA_FILTER_ID	int
,	O
DA_PORT_LIMIT	int
,	O
DA_CALLBACK_NUMBER	int
,	O
0	int
}	O
;	O
int	O
*	O
ip	pointer
;	O
for	O
(	O
ip	pointer
=	O
delete_pairs	array
;	O
*	O
ip	pointer
;	O
ip	pointer
++	O
)	O
grad_avl_delete	function
(	O
&	O
m	pointer
->	O
user_reply	pointer
,	O
*	O
ip	pointer
)	O
;	O
}	O
void	O
sfn_menu_challenge	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
}	O
void	O
sfn_ack	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"ACK: %s"	pointer
,	O
m	pointer
->	O
namepair	pointer
->	O
avp_strvalue	O
)	O
;	O
radius_eval_avl	function
(	O
m	pointer
->	O
req	pointer
,	O
m	pointer
->	O
user_reply	pointer
)	O
;	O
radius_send_reply	function
(	O
RT_ACCESS_ACCEPT	int
,	O
m	pointer
->	O
req	pointer
,	O
m	pointer
->	O
user_reply	pointer
,	O
auth_finish_msg	function
(	O
m	pointer
)	O
,	O
m	pointer
->	O
activefd	int
)	O
;	O
if	O
(	O
is_log_mode	function
(	O
m	pointer
,	O
RLOG_AUTH	int
)	O
)	O
{	O
auth_log	function
(	O
m	pointer
,	O
_	O
(	O
"Login OK"	pointer
)	O
,	O
is_log_mode	function
(	O
m	pointer
,	O
RLOG_AUTH_PASS	int
)	O
?	O
m	pointer
->	O
userpass	array
:	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
}	O
void	O
sfn_reject_cleanup	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
grad_avl_free	function
(	O
m	pointer
->	O
user_reply	pointer
)	O
;	O
m	pointer
->	O
user_reply	pointer
=	O
NULL	O
;	O
newstate	O
(	O
as_reject	int
)	O
;	O
}	O
void	O
sfn_reject	function
(	O
AUTH_MACH	struct
*	O
m	pointer
)	O
{	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"REJECT: %s"	pointer
,	O
m	pointer
->	O
namepair	pointer
->	O
avp_strvalue	O
)	O
;	O
radius_eval_avl	function
(	O
m	pointer
->	O
req	pointer
,	O
m	pointer
->	O
user_reply	pointer
)	O
;	O
radius_send_reply	function
(	O
RT_ACCESS_REJECT	int
,	O
m	pointer
->	O
req	pointer
,	O
m	pointer
->	O
user_reply	pointer
,	O
auth_finish_msg	function
(	O
m	pointer
)	O
,	O
m	pointer
->	O
activefd	int
)	O
;	O
}	O
void	O
req_decrypt_password	function
(	O
char	O
*	O
password	pointer
,	O
grad_request_t	struct
*	O
req	pointer
,	O
grad_avp_t	struct
*	O
pair	pointer
)	O
{	O
grad_nas_t	struct
*	O
nas	int
;	O
char	O
*	O
s	pointer
;	O
if	O
(	O
!	O
pair	pointer
)	O
{	O
pair	pointer
=	O
grad_avl_find	function
(	O
req	pointer
->	O
avlist	pointer
,	O
DA_USER_PASSWORD	int
)	O
;	O
if	O
(	O
!	O
pair	pointer
)	O
return	O
;	O
}	O
if	O
(	O
pair	pointer
->	O
prop	int
&	O
GRAD_AP_ENCRYPT_RFC2138	int
)	O
{	O
nas	int
=	O
grad_nas_request_to_nas	function
(	O
req	pointer
)	O
;	O
if	O
(	O
nas	int
&&	O
(	O
s	pointer
=	O
grad_envar_lookup	function
(	O
nas	int
->	O
args	pointer
,	O
"broken_pass"	pointer
)	O
)	O
!=	O
NULL	O
&&	O
s	pointer
[	O
0	int
]	O
==	O
'1'	O
)	O
grad_decrypt_password_broken	function
(	O
password	pointer
,	O
pair	pointer
,	O
req	pointer
->	O
authenticator	array
,	O
req	pointer
->	O
secret	pointer
)	O
;	O
else	O
grad_decrypt_password	function
(	O
password	pointer
,	O
pair	pointer
,	O
req	pointer
->	O
authenticator	array
,	O
req	pointer
->	O
secret	pointer
)	O
;	O
}	O
else	O
if	O
(	O
pair	pointer
->	O
prop	int
&	O
GRAD_AP_ENCRYPT_RFC2868	int
)	O
{	O
u_char	char
tag	char
;	O
grad_decrypt_tunnel_password	function
(	O
password	pointer
,	O
&	O
tag	char
,	O
pair	pointer
,	O
req	pointer
->	O
authenticator	array
,	O
req	pointer
->	O
secret	pointer
)	O
;	O
}	O
}	O
