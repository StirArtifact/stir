extern	O
char	O
*	O
program_name	pointer
;	O
enum	O
sect_e	enum
{	O
info	int
=	O
0	int
,	O
ea	int
=	O
1	int
,	O
var	pointer
=	O
2	int
}	O
;	O
static	O
void	O
syntax_error	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
unsigned	O
int	O
linenum	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
TEXINFO_PRINTFLIKE	O
(	O
3	int
,	O
4	int
)	O
;	O
static	O
int	O
lookup_action	function
(	O
const	O
char	O
*	O
actname	pointer
)	O
;	O
int	O
compile	function
(	O
FILE	struct
*	O
fp	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
int	O
*	O
suppress_info	pointer
,	O
int	O
*	O
suppress_ea	pointer
)	O
{	O
int	O
error	pointer
=	O
0	int
;	O
char	O
rescan	char
=	O
0	int
;	O
unsigned	O
int	O
lnum	int
=	O
0	int
;	O
int	O
c	int
=	O
0	int
;	O
enum	O
{	O
start_of_line	int
,	O
start_of_comment	int
,	O
in_line_comment	int
,	O
in_trailing_comment	int
,	O
get_keyseq	int
,	O
got_keyseq	int
,	O
get_action	int
,	O
got_action	int
,	O
get_varname	int
,	O
got_varname	int
,	O
get_equals	int
,	O
got_equals	int
,	O
get_value	int
}	O
state	pointer
=	O
start_of_line	int
;	O
enum	O
sect_e	enum
section	enum
=	O
info	int
;	O
enum	O
{	O
normal	int
,	O
slosh	int
,	O
control	int
,	O
octal	int
,	O
special_key	int
}	O
seqstate	enum
=	O
normal	int
;	O
char	O
meta	char
=	O
0	int
;	O
char	O
ocnt	char
=	O
0	int
;	O
char	O
oval	char
=	O
0	int
;	O
char	O
comment	array
[	O
10	int
]	O
;	O
unsigned	O
int	O
clen	int
=	O
0	int
;	O
int	O
seq	array
[	O
20	int
]	O
;	O
unsigned	O
int	O
slen	int
=	O
0	int
;	O
char	O
act	array
[	O
80	int
]	O
;	O
unsigned	O
int	O
alen	int
=	O
0	int
;	O
char	O
varn	array
[	O
80	int
]	O
;	O
unsigned	O
int	O
varlen	int
=	O
0	int
;	O
char	O
val	int
[	O
80	int
]	O
;	O
unsigned	O
int	O
vallen	int
=	O
0	int
;	O
while	O
(	O
!	O
error	pointer
&&	O
(	O
rescan	char
||	O
(	O
c	int
=	O
fgetc	function
(	O
fp	pointer
)	O
)	O
!=	O
EOF	O
)	O
)	O
{	O
rescan	char
=	O
0	int
;	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
start_of_line	int
:	O
lnum	int
++	O
;	O
if	O
(	O
c	int
==	O
'#'	O
)	O
state	pointer
=	O
start_of_comment	int
;	O
else	O
if	O
(	O
c	int
!=	O
'\n'	O
)	O
{	O
switch	O
(	O
section	enum
)	O
{	O
case	O
info	int
:	O
case	O
ea	int
:	O
state	pointer
=	O
get_keyseq	int
;	O
seqstate	enum
=	O
normal	int
;	O
slen	int
=	O
0	int
;	O
break	O
;	O
case	O
var	pointer
:	O
state	pointer
=	O
get_varname	int
;	O
varlen	int
=	O
0	int
;	O
break	O
;	O
}	O
rescan	char
=	O
1	int
;	O
}	O
break	O
;	O
case	O
start_of_comment	int
:	O
clen	int
=	O
0	int
;	O
state	pointer
=	O
in_line_comment	int
;	O
case	O
in_line_comment	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
state	pointer
=	O
start_of_line	int
;	O
comment	array
[	O
clen	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
strcmp	function
(	O
comment	array
,	O
"info"	pointer
)	O
==	O
0	int
)	O
section	enum
=	O
info	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
comment	array
,	O
"echo-area"	pointer
)	O
==	O
0	int
)	O
section	enum
=	O
ea	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
comment	array
,	O
"var"	pointer
)	O
==	O
0	int
)	O
section	enum
=	O
var	pointer
;	O
else	O
if	O
(	O
strcmp	function
(	O
comment	array
,	O
"stop"	pointer
)	O
==	O
0	int
&&	O
(	O
section	enum
==	O
info	int
||	O
section	enum
==	O
ea	int
)	O
)	O
{	O
if	O
(	O
section	enum
==	O
info	int
)	O
*	O
suppress_info	pointer
=	O
1	int
;	O
else	O
*	O
suppress_ea	pointer
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
clen	int
<	O
sizeof	O
comment	array
-	O
1	int
)	O
comment	array
[	O
clen	int
++	O
]	O
=	O
c	int
;	O
break	O
;	O
case	O
in_trailing_comment	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
state	pointer
=	O
start_of_line	int
;	O
break	O
;	O
case	O
get_keyseq	int
:	O
switch	O
(	O
seqstate	enum
)	O
{	O
case	O
normal	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
isspace	function
(	O
c	int
)	O
)	O
{	O
state	pointer
=	O
got_keyseq	int
;	O
rescan	char
=	O
1	int
;	O
if	O
(	O
slen	int
==	O
0	int
)	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"missing key sequence"	pointer
)	O
)	O
;	O
error	pointer
=	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
c	int
==	O
'\\'	O
)	O
seqstate	enum
=	O
slosh	int
;	O
else	O
if	O
(	O
c	int
==	O
'^'	O
)	O
seqstate	enum
=	O
control	int
;	O
else	O
To_seq	O
(	O
c	int
)	O
;	O
break	O
;	O
case	O
slosh	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
seqstate	enum
=	O
octal	int
;	O
oval	char
=	O
c	int
-	O
'0'	O
;	O
ocnt	char
=	O
1	int
;	O
break	O
;	O
case	O
'b'	O
:	O
To_seq	O
(	O
'\b'	O
)	O
;	O
seqstate	enum
=	O
normal	int
;	O
break	O
;	O
case	O
'e'	O
:	O
To_seq	O
(	O
'\033'	O
)	O
;	O
seqstate	enum
=	O
normal	int
;	O
break	O
;	O
case	O
'n'	O
:	O
To_seq	O
(	O
'\n'	O
)	O
;	O
seqstate	enum
=	O
normal	int
;	O
break	O
;	O
case	O
'r'	O
:	O
To_seq	O
(	O
'\r'	O
)	O
;	O
seqstate	enum
=	O
normal	int
;	O
break	O
;	O
case	O
't'	O
:	O
To_seq	O
(	O
'\t'	O
)	O
;	O
seqstate	enum
=	O
normal	int
;	O
break	O
;	O
case	O
'm'	O
:	O
meta	char
=	O
1	int
;	O
seqstate	enum
=	O
normal	int
;	O
break	O
;	O
case	O
'k'	O
:	O
seqstate	enum
=	O
special_key	int
;	O
break	O
;	O
default	O
:	O
To_seq	O
(	O
c	int
)	O
;	O
seqstate	enum
=	O
normal	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
octal	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'0'	O
:	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
if	O
(	O
++	O
ocnt	char
<=	O
3	int
)	O
oval	char
=	O
oval	char
*	O
8	int
+	O
c	int
-	O
'0'	O
;	O
if	O
(	O
ocnt	char
==	O
3	int
)	O
seqstate	enum
=	O
normal	int
;	O
break	O
;	O
default	O
:	O
ocnt	char
=	O
4	int
;	O
seqstate	enum
=	O
normal	int
;	O
rescan	char
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
seqstate	enum
!=	O
octal	int
)	O
{	O
if	O
(	O
oval	char
)	O
To_seq	O
(	O
oval	char
)	O
;	O
else	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"NUL character (\\000) not permitted"	pointer
)	O
)	O
;	O
error	pointer
=	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
special_key	int
:	O
switch	O
(	O
c	int
)	O
{	O
case	O
'u'	O
:	O
To_seq	O
(	O
KEY_UP_ARROW	int
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
To_seq	O
(	O
KEY_DOWN_ARROW	int
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
To_seq	O
(	O
KEY_RIGHT_ARROW	int
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
To_seq	O
(	O
KEY_LEFT_ARROW	int
)	O
;	O
break	O
;	O
case	O
'U'	O
:	O
To_seq	O
(	O
KEY_PAGE_UP	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
To_seq	O
(	O
KEY_PAGE_DOWN	int
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
To_seq	O
(	O
KEY_HOME	int
)	O
;	O
break	O
;	O
case	O
'e'	O
:	O
To_seq	O
(	O
KEY_END	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
To_seq	O
(	O
KEY_DELETE	int
)	O
;	O
break	O
;	O
default	O
:	O
To_seq	O
(	O
c	int
)	O
;	O
rescan	char
=	O
1	int
;	O
break	O
;	O
}	O
seqstate	enum
=	O
normal	int
;	O
break	O
;	O
case	O
control	int
:	O
if	O
(	O
CONTROL	O
(	O
c	int
)	O
)	O
To_seq	O
(	O
CONTROL	O
(	O
c	int
)	O
)	O
;	O
else	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"NUL character (^%c) not permitted"	pointer
)	O
,	O
c	int
)	O
;	O
error	pointer
=	O
1	int
;	O
}	O
seqstate	enum
=	O
normal	int
;	O
break	O
;	O
}	O
break	O
;	O
case	O
got_keyseq	int
:	O
if	O
(	O
isspace	function
(	O
c	int
)	O
&&	O
c	int
!=	O
'\n'	O
)	O
break	O
;	O
state	pointer
=	O
get_action	int
;	O
alen	int
=	O
0	int
;	O
case	O
get_action	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
isspace	function
(	O
c	int
)	O
)	O
{	O
int	O
a	int
;	O
state	pointer
=	O
got_action	int
;	O
rescan	char
=	O
1	int
;	O
if	O
(	O
alen	int
==	O
0	int
)	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"missing action name"	pointer
)	O
)	O
;	O
error	pointer
=	O
1	int
;	O
}	O
else	O
{	O
int	O
keymap_bind_keyseq	function
(	O
Keymap	pointer
,	O
int	O
*	O
,	O
KEYMAP_ENTRY	struct
*	O
)	O
;	O
act	array
[	O
alen	int
]	O
=	O
'\0'	O
;	O
a	int
=	O
lookup_action	function
(	O
act	array
)	O
;	O
if	O
(	O
a	int
==	O
A_info_menu_digit	int
)	O
{	O
if	O
(	O
seq	array
[	O
0	int
]	O
!=	O
'1'	O
||	O
seq	array
[	O
1	int
]	O
!=	O
'\0'	O
||	O
section	enum
!=	O
info	int
)	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"cannot bind key sequence to menu-digit"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
KEYMAP_ENTRY	struct
ke	struct
;	O
int	O
i	int
;	O
ke	struct
.	O
type	enum
=	O
ISFUNC	int
;	O
ke	struct
.	O
value	union
.	O
function	pointer
=	O
&	O
function_doc_array	array
[	O
a	int
]	O
;	O
for	O
(	O
i	int
=	O
'1'	O
;	O
i	int
<=	O
'9'	O
;	O
i	int
++	O
)	O
{	O
seq	array
[	O
0	int
]	O
=	O
i	int
;	O
keymap_bind_keyseq	function
(	O
info_keymap	pointer
,	O
seq	array
,	O
&	O
ke	struct
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
a	int
==	O
-	O
1	int
)	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"unknown action `%s'"	pointer
)	O
,	O
act	array
)	O
;	O
}	O
else	O
{	O
KEYMAP_ENTRY	struct
ke	struct
;	O
static	O
InfoCommand	struct
invalid_function	struct
=	O
{	O
0	int
}	O
;	O
ke	struct
.	O
type	enum
=	O
ISFUNC	int
;	O
ke	struct
.	O
value	union
.	O
function	pointer
=	O
a	int
!=	O
A_INVALID	int
?	O
&	O
function_doc_array	array
[	O
a	int
]	O
:	O
&	O
invalid_function	struct
;	O
To_seq	O
(	O
0	int
)	O
;	O
if	O
(	O
section	enum
==	O
info	int
)	O
keymap_bind_keyseq	function
(	O
info_keymap	pointer
,	O
seq	array
,	O
&	O
ke	struct
)	O
;	O
else	O
keymap_bind_keyseq	function
(	O
echo_area_keymap	pointer
,	O
seq	array
,	O
&	O
ke	struct
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
alen	int
<	O
sizeof	O
act	array
-	O
1	int
)	O
act	array
[	O
alen	int
++	O
]	O
=	O
c	int
;	O
else	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"action name too long"	pointer
)	O
)	O
;	O
error	pointer
=	O
1	int
;	O
}	O
break	O
;	O
case	O
got_action	int
:	O
if	O
(	O
c	int
==	O
'#'	O
)	O
state	pointer
=	O
in_trailing_comment	int
;	O
else	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
state	pointer
=	O
start_of_line	int
;	O
else	O
if	O
(	O
!	O
isspace	function
(	O
c	int
)	O
)	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"extra characters following action `%s'"	pointer
)	O
,	O
act	array
)	O
;	O
error	pointer
=	O
1	int
;	O
}	O
break	O
;	O
case	O
get_varname	int
:	O
if	O
(	O
c	int
==	O
'='	O
)	O
{	O
if	O
(	O
varlen	int
==	O
0	int
)	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"missing variable name"	pointer
)	O
)	O
;	O
error	pointer
=	O
1	int
;	O
}	O
state	pointer
=	O
get_value	int
;	O
vallen	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
c	int
==	O
'\n'	O
||	O
isspace	function
(	O
c	int
)	O
)	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"missing `=' immediately after variable name"	pointer
)	O
)	O
;	O
error	pointer
=	O
1	int
;	O
}	O
else	O
if	O
(	O
varlen	int
<	O
sizeof	O
varn	array
-	O
1	int
)	O
varn	array
[	O
varlen	int
++	O
]	O
=	O
c	int
;	O
else	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"variable name too long"	pointer
)	O
)	O
;	O
error	pointer
=	O
1	int
;	O
}	O
break	O
;	O
case	O
get_value	int
:	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
{	O
VARIABLE_ALIST	struct
*	O
v	pointer
;	O
state	pointer
=	O
start_of_line	int
;	O
varn	array
[	O
varlen	int
]	O
=	O
'\0'	O
;	O
val	int
[	O
vallen	int
]	O
=	O
'\0'	O
;	O
v	pointer
=	O
variable_by_name	function
(	O
varn	array
)	O
;	O
if	O
(	O
!	O
v	pointer
)	O
info_error	function
(	O
_	O
(	O
"%s: no such variable"	pointer
)	O
,	O
varn	array
)	O
;	O
else	O
if	O
(	O
!	O
set_variable_to_value	function
(	O
v	pointer
,	O
val	int
,	O
SET_IN_CONFIG_FILE	int
)	O
)	O
info_error	function
(	O
_	O
(	O
"value %s is not valid for variable %s"	pointer
)	O
,	O
val	int
,	O
varn	array
)	O
;	O
}	O
else	O
if	O
(	O
vallen	int
<	O
sizeof	O
val	int
-	O
1	int
)	O
val	int
[	O
vallen	int
++	O
]	O
=	O
c	int
;	O
else	O
{	O
syntax_error	function
(	O
filename	pointer
,	O
lnum	int
,	O
_	O
(	O
"value too long"	pointer
)	O
)	O
;	O
error	pointer
=	O
1	int
;	O
}	O
break	O
;	O
case	O
get_equals	int
:	O
case	O
got_equals	int
:	O
case	O
got_varname	int
:	O
break	O
;	O
}	O
}	O
return	O
!	O
error	pointer
;	O
}	O
static	O
int	O
lookup_action	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
name	pointer
,	O
"invalid"	pointer
)	O
)	O
return	O
A_INVALID	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
function_doc_array	array
[	O
i	int
]	O
.	O
func_name	pointer
;	O
i	int
++	O
)	O
if	O
(	O
!	O
strcmp	function
(	O
function_doc_array	array
[	O
i	int
]	O
.	O
func_name	pointer
,	O
name	pointer
)	O
)	O
return	O
i	int
;	O
return	O
-	O
1	int
;	O
}	O
static	O
void	O
syntax_error	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
unsigned	O
int	O
linenum	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
program_name	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"\"%s\", line %u: "	pointer
)	O
,	O
filename	pointer
,	O
linenum	int
)	O
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
