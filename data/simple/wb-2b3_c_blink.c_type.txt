void	O
short2str	function
(	O
unsigned	O
char	O
*	O
str	pointer
,	O
int	O
pos	int
,	O
int	O
cint	int
)	O
{	O
str	pointer
[	O
(	O
pos	int
)	O
+	O
1	int
]	O
=	O
(	O
cint	int
)	O
&	O
0xff	int
;	O
str	pointer
[	O
(	O
pos	int
)	O
+	O
0	int
]	O
=	O
(	O
cint	int
)	O
>>	O
8	int
;	O
return	O
;	O
}	O
short	O
str2short	function
(	O
unsigned	O
char	O
*	O
str	pointer
,	O
int	O
pos	int
)	O
{	O
return	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	pointer
)	O
)	O
[	O
(	O
pos	int
)	O
+	O
1	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	pointer
)	O
)	O
[	O
pos	int
]	O
)	O
)	O
<<	O
8	int
)	O
;	O
}	O
void	O
long2str	function
(	O
unsigned	O
char	O
*	O
str	pointer
,	O
int	O
pos	int
,	O
long	O
clong	long
)	O
{	O
str	pointer
[	O
(	O
pos	int
)	O
+	O
3	int
]	O
=	O
(	O
clong	long
)	O
&	O
0xff	int
;	O
str	pointer
[	O
(	O
pos	int
)	O
+	O
2	int
]	O
=	O
(	O
(	O
clong	long
)	O
>>	O
8	int
)	O
&	O
0xff	int
;	O
str	pointer
[	O
(	O
pos	int
)	O
+	O
1	int
]	O
=	O
(	O
(	O
clong	long
)	O
>>	O
0x10	int
)	O
&	O
0xff	int
;	O
str	pointer
[	O
(	O
pos	int
)	O
+	O
0	int
]	O
=	O
(	O
clong	long
)	O
>>	O
0x18	int
;	O
return	O
;	O
}	O
long	O
str2long	function
(	O
unsigned	O
char	O
*	O
str	pointer
,	O
int	O
pos	int
)	O
{	O
return	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	pointer
)	O
)	O
[	O
(	O
pos	int
)	O
+	O
3	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	pointer
)	O
)	O
[	O
(	O
pos	int
)	O
+	O
2	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	pointer
)	O
)	O
[	O
(	O
pos	int
)	O
+	O
1	int
]	O
)	O
)	O
|	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
str	pointer
)	O
)	O
[	O
pos	int
]	O
)	O
)	O
<<	O
0x8L	int
)	O
)	O
<<	O
0x8L	int
)	O
)	O
<<	O
0x8L	int
)	O
;	O
}	O
int	O
set_field	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
val_str	pointer
,	O
int	O
f_pos	int
,	O
int	O
f_len	int
)	O
{	O
set_field_len	O
(	O
blk	pointer
,	O
b_pos	int
,	O
f_len	int
)	O
;	O
subbytes_move	O
(	O
val_str	pointer
,	O
f_pos	int
,	O
(	O
f_pos	int
)	O
+	O
(	O
f_len	int
)	O
,	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
return	O
(	O
f_len	int
)	O
+	O
1	int
+	O
(	O
b_pos	int
)	O
;	O
}	O
unsigned	O
char	O
leaf_split_key_str	array
[	O
]	O
=	O
{	O
0xff	int
,	O
(	O
leaf	int
)	O
}	O
;	O
void	O
init_leaf_blk	function
(	O
unsigned	O
char	O
*	O
nblk	pointer
,	O
long	O
bnum	long
,	O
int	O
typ	int
)	O
{	O
nblk	pointer
[	O
(	O
blk_size	int
)	O
-	O
1	int
]	O
=	O
0xa	int
;	O
blk_set_id	O
(	O
nblk	pointer
,	O
bnum	long
)	O
;	O
blk_set_nxt_id	O
(	O
nblk	pointer
,	O
0	int
)	O
;	O
blk_set_top_id	O
(	O
nblk	pointer
,	O
bnum	long
)	O
;	O
blk_set_time	O
(	O
nblk	pointer
,	O
0	int
)	O
;	O
blk_set_level	O
(	O
nblk	pointer
,	O
leaf	int
)	O
;	O
blk_set_typ	O
(	O
nblk	pointer
,	O
typ	int
)	O
;	O
set_field_len	O
(	O
nblk	pointer
,	O
blk_data_start	int
,	O
0	int
)	O
;	O
set_field	function
(	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
1	int
,	O
leaf_split_key_str	array
,	O
0	int
,	O
2	int
)	O
;	O
blk_set_end	O
(	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
(	O
(	O
(	O
typ	int
)	O
==	O
(	O
seq_typ	int
)	O
?	O
0	int
:	O
4	int
)	O
)	O
)	O
;	O
return	O
;	O
}	O
void	O
reroot	function
(	O
unsigned	O
char	O
*	O
rblk	pointer
,	O
unsigned	O
char	O
*	O
nblk	pointer
,	O
long	O
bnum	long
,	O
int	O
bsiz	int
)	O
{	O
int	O
rpos	int
=	O
blk_data_start	int
;	O
subbytes_move	O
(	O
rblk	pointer
,	O
4	int
,	O
bsiz	int
,	O
nblk	pointer
,	O
4	int
)	O
;	O
blk_set_nxt_id	O
(	O
rblk	pointer
,	O
0	int
)	O
;	O
blk_set_level	O
(	O
rblk	pointer
,	O
(	O
blk_level	O
(	O
rblk	pointer
)	O
)	O
+	O
1	int
)	O
;	O
set_field_len	O
(	O
rblk	pointer
,	O
rpos	int
,	O
0	int
)	O
;	O
rpos	int
=	O
set_field	function
(	O
rblk	pointer
,	O
(	O
rpos	int
)	O
+	O
1	int
,	O
leaf_split_key_str	array
,	O
0	int
,	O
2	int
)	O
;	O
rblk	pointer
[	O
(	O
rpos	int
)	O
-	O
1	int
]	O
=	O
(	O
blk_level	O
(	O
rblk	pointer
)	O
)	O
-	O
1	int
;	O
rpos	int
=	O
set_field	function
(	O
rblk	pointer
,	O
rpos	int
,	O
nblk	pointer
,	O
0	int
,	O
4	int
)	O
;	O
set_field_len	O
(	O
rblk	pointer
,	O
rpos	int
,	O
1	int
)	O
;	O
rpos	int
=	O
set_field	function
(	O
rblk	pointer
,	O
(	O
rpos	int
)	O
+	O
1	int
,	O
leaf_split_key_str	array
,	O
0	int
,	O
1	int
)	O
;	O
rblk	pointer
[	O
(	O
rpos	int
)	O
-	O
1	int
]	O
=	O
blk_level	O
(	O
rblk	pointer
)	O
;	O
blk_set_end	O
(	O
rblk	pointer
,	O
rpos	int
)	O
;	O
return	O
;	O
}	O
void	O
init_next_blk	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
unsigned	O
char	O
*	O
nblk	pointer
)	O
{	O
nblk	pointer
[	O
(	O
blk_size	int
)	O
-	O
1	int
]	O
=	O
0xa	int
;	O
blk_set_nxt_id	O
(	O
nblk	pointer
,	O
blk_nxt_id	O
(	O
blk	pointer
)	O
)	O
;	O
blk_set_top_id	O
(	O
nblk	pointer
,	O
blk_top_id	O
(	O
blk	pointer
)	O
)	O
;	O
blk_set_level	O
(	O
nblk	pointer
,	O
blk_level	O
(	O
blk	pointer
)	O
)	O
;	O
blk_set_typ	O
(	O
nblk	pointer
,	O
blk_typ	O
(	O
blk	pointer
)	O
)	O
;	O
blk_set_nxt_id	O
(	O
blk	pointer
,	O
blk_id	O
(	O
nblk	pointer
)	O
)	O
;	O
set_field_len	O
(	O
nblk	pointer
,	O
blk_data_start	int
,	O
0	int
)	O
;	O
set_field	function
(	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
1	int
,	O
no_byts	pointer
,	O
0	int
,	O
0	int
)	O
;	O
blk_set_end	O
(	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
)	O
;	O
return	O
;	O
}	O
int	O
split_key_pos	function
(	O
unsigned	O
char	O
*	O
blk	pointer
)	O
{	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	pointer
)	O
;	O
{	O
int	O
b_pos	int
=	O
blk_data_start	int
;	O
L_lp	O
:	O
{	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
if	O
(	O
(	O
s_pos	int
)	O
==	O
(	O
b_end	int
)	O
)	O
return	O
b_pos	int
;	O
else	O
if	O
(	O
(	O
s_pos	int
)	O
<	O
(	O
b_end	int
)	O
)	O
{	O
b_pos	int
=	O
next_cnvpair	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
goto	O
L_lp	O
;	O
}	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: blk past end %ld %d\n"	pointer
,	O
"split_key_pos"	pointer
,	O
blk_id	O
(	O
blk	pointer
)	O
,	O
s_pos	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
}	O
}	O
int	O
blk_find_pos	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_len	int
,	O
int	O
*	O
pkt	pointer
)	O
{	O
if	O
(	O
(	O
k_len	int
)	O
<	O
0	int
)	O
{	O
if	O
(	O
(	O
k_len	int
)	O
==	O
(	O
end_of_chain	O
)	O
)	O
{	O
int	O
skpos	int
=	O
split_key_pos	function
(	O
blk	pointer
)	O
;	O
pkt_pack	O
(	O
pkt	pointer
,	O
(	O
end_of_chain_P	O
(	O
blk	pointer
)	O
?	O
qpastp	O
:	O
pastend	O
)	O
,	O
skpos	int
,	O
0	int
,	O
blk_prev_key	function
(	O
blk	pointer
,	O
skpos	int
)	O
)	O
;	O
}	O
else	O
pkt_pack	O
(	O
pkt	pointer
,	O
qpastp	O
,	O
blk_data_start	int
,	O
0	int
,	O
0	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
int	O
k_pos	int
=	O
0	int
;	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	pointer
)	O
;	O
{	O
int	O
b_pos	int
=	O
blk_data_start	int
;	O
int	O
p_pos	int
=	O
0	int
;	O
L_chknxt	O
:	O
if	O
(	O
(	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
)	O
<	O
(	O
k_pos	int
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	pointer
,	O
qpastp	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
)	O
>	O
(	O
k_pos	int
)	O
)	O
{	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
(	O
s_pos	int
)	O
<	O
(	O
b_end	int
)	O
)	O
{	O
int	O
T_b_pos	int
=	O
next_cnvpair	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
p_pos	int
=	O
b_pos	int
;	O
b_pos	int
=	O
T_b_pos	int
;	O
goto	O
L_chknxt	O
;	O
}	O
else	O
if	O
(	O
(	O
s_pos	int
)	O
==	O
(	O
b_end	int
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	pointer
,	O
pastend	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s1: blk past end %ld %d\n"	pointer
,	O
"blk_find_pos"	pointer
,	O
blk_id	O
(	O
blk	pointer
)	O
,	O
s_pos	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
{	O
int	O
i	int
=	O
(	O
b_pos	int
)	O
+	O
2	int
;	O
int	O
f_len	int
=	O
field_len	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
L_mchlp	O
:	O
if	O
(	O
(	O
k_pos	int
)	O
>=	O
(	O
k_len	int
)	O
)	O
if	O
(	O
(	O
f_len	int
)	O
>	O
0	int
)	O
{	O
pkt_pack	O
(	O
pkt	pointer
,	O
pastp	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
(	O
s_pos	int
)	O
<	O
(	O
b_end	int
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	pointer
,	O
match	O
,	O
b_pos	int
,	O
k_len	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
s_pos	int
)	O
==	O
(	O
b_end	int
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	pointer
,	O
matchend	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s2: blk past end %ld %d\n"	pointer
,	O
"blk_find_pos"	pointer
,	O
blk_id	O
(	O
blk	pointer
)	O
,	O
s_pos	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
(	O
f_len	int
)	O
<=	O
0	int
)	O
||	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	pointer
)	O
)	O
[	O
i	int
]	O
)	O
)	O
<	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
key_str	pointer
)	O
)	O
[	O
k_pos	int
]	O
)	O
)	O
)	O
)	O
{	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
(	O
s_pos	int
)	O
<	O
(	O
b_end	int
)	O
)	O
{	O
int	O
T_b_pos	int
=	O
next_cnvpair	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
p_pos	int
=	O
b_pos	int
;	O
b_pos	int
=	O
T_b_pos	int
;	O
goto	O
L_chknxt	O
;	O
}	O
else	O
if	O
(	O
(	O
s_pos	int
)	O
==	O
(	O
b_end	int
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	pointer
,	O
pastend	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s3: blk past end %ld %d\n"	pointer
,	O
"blk_find_pos"	pointer
,	O
blk_id	O
(	O
blk	pointer
)	O
,	O
s_pos	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	pointer
)	O
)	O
[	O
i	int
]	O
)	O
)	O
>	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
key_str	pointer
)	O
)	O
[	O
k_pos	int
]	O
)	O
)	O
)	O
{	O
pkt_pack	O
(	O
pkt	pointer
,	O
(	O
(	O
k_pos	int
)	O
>	O
(	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
)	O
?	O
pastp	O
:	O
qpastp	O
)	O
,	O
b_pos	int
,	O
k_pos	int
,	O
p_pos	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
k_pos	int
=	O
(	O
k_pos	int
)	O
+	O
1	int
;	O
{	O
i	int
=	O
1	int
+	O
(	O
i	int
)	O
;	O
f_len	int
=	O
(	O
f_len	int
)	O
-	O
1	int
;	O
goto	O
L_mchlp	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
ENTRY	struct
*	O
chain_find	function
(	O
ENTRY	struct
*	O
ent	pointer
,	O
int	O
accmode	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_len	int
,	O
int	O
*	O
pkt	pointer
)	O
{	O
L_chain_find	O
:	O
{	O
unsigned	O
char	O
*	O
blk	pointer
=	O
ent_blk	O
(	O
ent	pointer
)	O
;	O
if	O
(	O
!	O
(	O
blk_find_pos	function
(	O
blk	pointer
,	O
key_str	pointer
,	O
k_len	int
,	O
pkt	pointer
)	O
)	O
)	O
{	O
release_ent	function
(	O
ent	pointer
,	O
accmode	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
matchend	O
)	O
)	O
||	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
pastend	O
)	O
)	O
)	O
)	O
return	O
ent	pointer
;	O
else	O
if	O
(	O
end_of_chain_P	O
(	O
blk	pointer
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: matched or past end of chain %ld:%ld\n"	pointer
,	O
"chain_find"	pointer
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
pkt_set_match_type	O
(	O
pkt	pointer
,	O
qpastp	O
)	O
;	O
return	O
ent	pointer
;	O
}	O
else	O
{	O
chains_to_next	int
=	O
1	int
+	O
(	O
chains_to_next	int
)	O
;	O
ent	pointer
=	O
switch_ent	function
(	O
ent	pointer
,	O
accmode	int
,	O
blk_nxt_id	O
(	O
blk	pointer
)	O
,	O
accmode	int
)	O
;	O
if	O
(	O
ent	pointer
)	O
goto	O
L_chain_find	O
;	O
else	O
return	O
0	int
;	O
}	O
}	O
}	O
ENTRY	struct
*	O
find_ent	function
(	O
ENTRY	struct
*	O
ent	pointer
,	O
int	O
desired_level	int
,	O
int	O
last_level	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_len	int
)	O
{	O
L_find_ent	O
:	O
if	O
(	O
ent	pointer
)	O
if	O
(	O
ents_ent_update_access_P	function
(	O
ent	pointer
,	O
accnone	O
,	O
accread	O
)	O
)	O
{	O
unsigned	O
char	O
*	O
blk	pointer
=	O
ent_blk	O
(	O
ent	pointer
)	O
;	O
int	O
blvl	int
=	O
blk_level	O
(	O
blk	pointer
)	O
;	O
if	O
(	O
(	O
blvl	int
)	O
==	O
(	O
desired_level	int
)	O
)	O
return	O
ent	pointer
;	O
else	O
if	O
(	O
(	O
blvl	int
)	O
<	O
(	O
desired_level	int
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< bad blk level %d (des=%d) in %ld:%ld\n"	pointer
,	O
blvl	int
,	O
desired_level	int
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
(	O
last_level	int
)	O
>=	O
0	int
)	O
&&	O
(	O
(	O
blvl	int
)	O
!=	O
(	O
(	O
last_level	int
)	O
-	O
1	int
)	O
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< bad blk level %d last=%d in %ld:%ld\n"	pointer
,	O
blvl	int
,	O
last_level	int
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
int	O
pkt	pointer
[	O
pkt_size	int
]	O
;	O
ent	pointer
=	O
chain_find	function
(	O
ent	pointer
,	O
accread	O
,	O
key_str	pointer
,	O
k_len	int
,	O
pkt	pointer
)	O
;	O
if	O
(	O
ent	pointer
)	O
{	O
int	O
pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
)	O
)	O
;	O
blk	pointer
=	O
ent_blk	O
(	O
ent	pointer
)	O
;	O
switch	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
{	O
case	O
qpastp	O
:	O
case	O
pastp	O
:	O
;	O
break	O
;	O
case	O
match	O
:	O
if	O
(	O
(	O
blk_end	O
(	O
blk	pointer
)	O
)	O
==	O
(	O
pos	int
)	O
)	O
{	O
pos	int
=	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
;	O
}	O
else	O
pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
pos	int
)	O
;	O
break	O
;	O
default	O
:	O
pos	int
=	O
0	int
;	O
break	O
;	O
}	O
if	O
(	O
!	O
(	O
pos	int
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: bad-MATCH-TYPE %d blk %ld:%ld\n"	pointer
,	O
"find_ent"	pointer
,	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
)	O
)	O
;	O
{	O
ent	pointer
=	O
switch_ent	function
(	O
ent	pointer
,	O
accread	O
,	O
(	O
(	O
blk_end	O
(	O
blk	pointer
)	O
)	O
==	O
(	O
pos	int
)	O
?	O
(	O
end_of_chain_P	O
(	O
blk	pointer
)	O
?	O
str2long	function
(	O
blk	pointer
,	O
-	O
6	int
+	O
(	O
pos	int
)	O
)	O
:	O
blk_nxt_id	O
(	O
blk	pointer
)	O
)	O
:	O
str2long	function
(	O
blk	pointer
,	O
1	int
+	O
(	O
pos	int
)	O
)	O
)	O
,	O
accnone	O
)	O
;	O
last_level	int
=	O
(	O
(	O
blk_end	O
(	O
blk	pointer
)	O
)	O
==	O
(	O
pos	int
)	O
)	O
&&	O
(	O
!	O
(	O
end_of_chain_P	O
(	O
blk	pointer
)	O
)	O
)	O
?	O
(	O
blk_level	O
(	O
blk	pointer
)	O
)	O
+	O
1	int
:	O
blk_level	O
(	O
blk	pointer
)	O
;	O
goto	O
L_find_ent	O
;	O
}	O
}	O
}	O
else	O
return	O
0	int
;	O
}	O
}	O
else	O
return	O
0	int
;	O
else	O
return	O
0	int
;	O
}	O
int	O
blk_prev_key	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
int	O
pos	int
)	O
{	O
{	O
int	O
b_pos	int
=	O
blk_data_start	int
;	O
int	O
p_pos	int
=	O
0	int
;	O
while	O
(	O
!	O
(	O
(	O
b_pos	int
)	O
>=	O
(	O
pos	int
)	O
)	O
)	O
{	O
{	O
int	O
T_b_pos	int
=	O
next_cnvpair	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
p_pos	int
=	O
b_pos	int
;	O
b_pos	int
=	O
T_b_pos	int
;	O
}	O
}	O
if	O
(	O
(	O
b_pos	int
)	O
>	O
(	O
pos	int
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: blk past end %ld %d\n"	pointer
,	O
"blk_prev_key"	pointer
,	O
blk_id	O
(	O
blk	pointer
)	O
,	O
p_pos	int
)	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
return	O
p_pos	int
;	O
}	O
}	O
int	O
get_this_val	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
ans_str	pointer
)	O
{	O
b_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
{	O
int	O
alen	int
=	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
subbytes_move	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
(	O
b_pos	int
)	O
+	O
1	int
+	O
(	O
alen	int
)	O
,	O
ans_str	pointer
,	O
0	int
)	O
;	O
return	O
alen	int
;	O
}	O
}	O
int	O
get_this_key	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
unsigned	O
char	O
*	O
ans_str	pointer
,	O
ENTRY	struct
*	O
ent	pointer
,	O
int	O
k_len	int
,	O
int	O
*	O
pkt	pointer
)	O
{	O
{	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	pointer
)	O
;	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
if	O
(	O
(	O
s_pos	int
)	O
<	O
(	O
b_end	int
)	O
)	O
{	O
int	O
f_pos	int
=	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
int	O
f_siz	int
=	O
field_len	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
)	O
;	O
int	O
alen	int
=	O
(	O
f_pos	int
)	O
+	O
(	O
f_siz	int
)	O
;	O
if	O
(	O
(	O
key_str	pointer
)	O
!=	O
(	O
ans_str	pointer
)	O
)	O
subbytes_move	O
(	O
key_str	pointer
,	O
0	int
,	O
f_pos	int
,	O
ans_str	pointer
,	O
0	int
)	O
;	O
subbytes_move	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
2	int
,	O
(	O
b_pos	int
)	O
+	O
2	int
+	O
(	O
f_siz	int
)	O
,	O
ans_str	pointer
,	O
f_pos	int
)	O
;	O
release_ent	function
(	O
ent	pointer
,	O
accread	O
)	O
;	O
return	O
alen	int
;	O
}	O
else	O
if	O
(	O
(	O
s_pos	int
)	O
!=	O
(	O
b_end	int
)	O
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: blk past end %ld %d\n"	pointer
,	O
"chain_next"	pointer
,	O
blk_id	O
(	O
blk	pointer
)	O
,	O
s_pos	int
)	O
)	O
;	O
release_ent	function
(	O
ent	pointer
,	O
accread	O
)	O
;	O
return	O
strangerr	O
;	O
}	O
else	O
if	O
(	O
end_of_chain_P	O
(	O
blk	pointer
)	O
)	O
{	O
release_ent	function
(	O
ent	pointer
,	O
accread	O
)	O
;	O
return	O
notpres	O
;	O
}	O
else	O
{	O
ent	pointer
=	O
switch_ent	function
(	O
ent	pointer
,	O
accread	O
,	O
blk_nxt_id	O
(	O
blk	pointer
)	O
,	O
accread	O
)	O
;	O
if	O
(	O
ent	pointer
)	O
ent	pointer
=	O
chain_find	function
(	O
ent	pointer
,	O
accread	O
,	O
key_str	pointer
,	O
k_len	int
,	O
pkt	pointer
)	O
;	O
if	O
(	O
ent	pointer
)	O
return	O
chain_next	function
(	O
ent	pointer
,	O
key_str	pointer
,	O
k_len	int
,	O
ans_str	pointer
,	O
pkt	pointer
)	O
;	O
else	O
return	O
unkerr	O
;	O
}	O
}	O
}	O
int	O
chain_next	function
(	O
ENTRY	struct
*	O
ent	pointer
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
ans_str	pointer
,	O
int	O
*	O
pkt	pointer
)	O
{	O
pkt_set_blk_to_cache	O
(	O
pkt	pointer
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
;	O
switch	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
{	O
case	O
pastp	O
:	O
case	O
qpastp	O
:	O
return	O
get_this_key	function
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
,	O
key_str	pointer
,	O
ans_str	pointer
,	O
ent	pointer
,	O
k_len	int
,	O
pkt	pointer
)	O
;	O
case	O
match	O
:	O
return	O
get_this_key	function
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
next_cnvpair	O
(	O
ent_blk	O
(	O
ent	pointer
)	O
,	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
)	O
,	O
key_str	pointer
,	O
ans_str	pointer
,	O
ent	pointer
,	O
k_len	int
,	O
pkt	pointer
)	O
;	O
default	O
:	O
release_ent	function
(	O
ent	pointer
,	O
accread	O
)	O
;	O
return	O
notpres	O
;	O
}	O
}	O
int	O
blk_change_size	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
int	O
loc	int
,	O
int	O
growth	int
,	O
int	O
bsiz	int
)	O
{	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	pointer
)	O
;	O
if	O
(	O
!	O
(	O
growth	int
)	O
)	O
return	O
!	O
0	int
;	O
else	O
if	O
(	O
(	O
(	O
b_end	int
)	O
+	O
(	O
growth	int
)	O
)	O
>	O
(	O
bsiz	int
)	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
0	int
>	O
(	O
growth	int
)	O
)	O
{	O
subbytes_move_left	O
(	O
blk	pointer
,	O
loc	int
,	O
b_end	int
,	O
blk	pointer
,	O
(	O
loc	int
)	O
+	O
(	O
growth	int
)	O
)	O
;	O
blk_set_end	O
(	O
blk	pointer
,	O
(	O
b_end	int
)	O
+	O
(	O
growth	int
)	O
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
{	O
subbytes_move_right	O
(	O
blk	pointer
,	O
loc	int
,	O
b_end	int
,	O
blk	pointer
,	O
(	O
loc	int
)	O
+	O
(	O
growth	int
)	O
)	O
;	O
blk_set_end	O
(	O
blk	pointer
,	O
(	O
b_end	int
)	O
+	O
(	O
growth	int
)	O
)	O
;	O
return	O
!	O
0	int
;	O
}	O
}	O
int	O
blk_remove_key_and_val	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
int	O
b_pos	int
,	O
int	O
bsiz	int
)	O
{	O
int	O
nb_pos	int
=	O
next_cnvpair	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
if	O
(	O
(	O
field_len	O
(	O
blk	pointer
,	O
nb_pos	int
)	O
)	O
>	O
(	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
)	O
)	O
{	O
int	O
delk_pos	int
=	O
(	O
field_len	O
(	O
blk	pointer
,	O
nb_pos	int
)	O
)	O
-	O
(	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
)	O
;	O
set_field_len	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
,	O
(	O
field_len	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
nb_pos	int
)	O
)	O
)	O
+	O
(	O
delk_pos	int
)	O
)	O
;	O
return	O
blk_change_size	function
(	O
blk	pointer
,	O
2	int
+	O
(	O
nb_pos	int
)	O
,	O
(	O
(	O
b_pos	int
)	O
-	O
(	O
nb_pos	int
)	O
)	O
+	O
(	O
delk_pos	int
)	O
,	O
bsiz	int
)	O
;	O
}	O
else	O
return	O
blk_change_size	function
(	O
blk	pointer
,	O
nb_pos	int
,	O
(	O
b_pos	int
)	O
-	O
(	O
nb_pos	int
)	O
,	O
bsiz	int
)	O
;	O
}	O
int	O
defer_insert_updates_P	int
=	O
0	int
;	O
int	O
parent_insert_update	function
(	O
SEGD	struct
*	O
seg	pointer
,	O
long	O
top_id	long
,	O
int	O
level	int
,	O
unsigned	O
char	O
*	O
nkey_str	pointer
,	O
int	O
nk_len	int
,	O
long	O
n_id	long
)	O
{	O
int	O
pkt	pointer
[	O
pkt_size	int
]	O
;	O
{	O
ENTRY	struct
*	O
ent	pointer
=	O
find_ent	function
(	O
get_ent	function
(	O
seg	pointer
,	O
top_id	long
,	O
accnone	O
)	O
,	O
1	int
+	O
(	O
level	int
)	O
,	O
-	O
1	int
,	O
nkey_str	pointer
,	O
nk_len	int
)	O
;	O
ENTRY	struct
*	O
xent	pointer
=	O
0	int
;	O
int	O
screw_case_P	int
=	O
0	int
;	O
unsigned	O
char	O
blkidstr	array
[	O
4	int
]	O
;	O
unsigned	O
char	O
*	O
blk	pointer
=	O
0	int
;	O
if	O
(	O
ent	pointer
)	O
{	O
long2str	function
(	O
blkidstr	array
,	O
0	int
,	O
n_id	long
)	O
;	O
if	O
(	O
ents_ent_update_access_P	function
(	O
ent	pointer
,	O
accread	O
,	O
accwrite	O
)	O
)	O
{	O
ent	pointer
=	O
chain_find	function
(	O
ent	pointer
,	O
accwrite	O
,	O
nkey_str	pointer
,	O
nk_len	int
,	O
pkt	pointer
)	O
;	O
blk	pointer
=	O
ent_blk	O
(	O
ent	pointer
)	O
;	O
}	O
else	O
{	O
release_ent	function
(	O
ent	pointer
,	O
accread	O
)	O
;	O
ent	pointer
=	O
0	int
;	O
}	O
if	O
(	O
(	O
ent	pointer
)	O
&&	O
(	O
at_split_key_pos_P	function
(	O
blk	pointer
,	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
)	O
)	O
)	O
{	O
screw_case_P	int
=	O
!	O
0	int
;	O
xent	pointer
=	O
next_nonempty_ent	function
(	O
ent_seg	O
(	O
ent	pointer
)	O
,	O
blk_nxt_id	O
(	O
blk	pointer
)	O
)	O
;	O
if	O
(	O
!	O
(	O
xent	pointer
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< No next key found for index insert %ld:%ld\n"	pointer
,	O
seg_id	O
(	O
ent_seg	O
(	O
ent	pointer
)	O
)	O
,	O
blk_id	O
(	O
blk	pointer
)	O
)	O
)	O
;	O
}	O
if	O
(	O
(	O
!	O
(	O
defer_insert_updates_P	int
)	O
)	O
&&	O
(	O
ent	pointer
)	O
&&	O
(	O
(	O
!	O
(	O
screw_case_P	int
)	O
)	O
||	O
(	O
xent	pointer
)	O
)	O
&&	O
(	O
chain_put	function
(	O
ent	pointer
,	O
nkey_str	pointer
,	O
nk_len	int
,	O
blkidstr	array
,	O
4	int
,	O
pkt	pointer
,	O
xent	pointer
,	O
wcb_sar	int
)	O
)	O
)	O
return	O
!	O
0	int
;	O
else	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
"WARNING: %s: couldn't update parent n-id=%ld nk-len=%d\n"	pointer
,	O
"parent_insert_update"	pointer
,	O
n_id	long
,	O
nk_len	int
)	O
)	O
;	O
deferred_inserts	int
=	O
1	int
+	O
(	O
deferred_inserts	int
)	O
;	O
if	O
(	O
ent	pointer
)	O
release_ent	function
(	O
ent	pointer
,	O
accwrite	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
return	O
0	int
;	O
}	O
}	O
int	O
at_split_key_pos_P	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
int	O
pos	int
)	O
{	O
return	O
(	O
blk_end	O
(	O
blk	pointer
)	O
)	O
==	O
(	O
next_field	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
pos	int
)	O
)	O
)	O
;	O
}	O
ENTRY	struct
*	O
next_nonempty_ent	function
(	O
SEGD	struct
*	O
seg	pointer
,	O
long	O
blknum	long
)	O
{	O
if	O
(	O
(	O
blknum	long
)	O
<=	O
0	int
)	O
return	O
0	int
;	O
else	O
{	O
ENTRY	struct
*	O
xent	pointer
=	O
get_ent	function
(	O
seg	pointer
,	O
blknum	long
,	O
accread	O
)	O
;	O
L_loop	O
:	O
if	O
(	O
xent	pointer
)	O
ents_ent_update_access_P	function
(	O
xent	pointer
,	O
accread	O
,	O
accwrite	O
)	O
;	O
if	O
(	O
!	O
(	O
xent	pointer
)	O
)	O
return	O
0	int
;	O
else	O
if	O
(	O
!	O
(	O
blk_empty_P	O
(	O
ent_blk	O
(	O
xent	pointer
)	O
)	O
)	O
)	O
return	O
xent	pointer
;	O
else	O
if	O
(	O
!	O
(	O
blk_nxt_id	O
(	O
ent_blk	O
(	O
xent	pointer
)	O
)	O
)	O
)	O
{	O
release_ent	function
(	O
xent	pointer
,	O
accwrite	O
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
xent	pointer
=	O
switch_ent	function
(	O
xent	pointer
,	O
accwrite	O
,	O
blk_nxt_id	O
(	O
ent_blk	O
(	O
xent	pointer
)	O
)	O
,	O
accwrite	O
)	O
;	O
goto	O
L_loop	O
;	O
}	O
}	O
}	O
int	O
recon_this_key	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
int	O
pos	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_pos	int
,	O
int	O
k_len	int
)	O
{	O
{	O
int	O
b_pos	int
=	O
blk_data_start	int
;	O
int	O
k_size	int
=	O
0	int
;	O
while	O
(	O
!	O
(	O
(	O
b_pos	int
)	O
>	O
(	O
pos	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
(	O
k_size	int
)	O
>	O
(	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
)	O
)	O
&&	O
(	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	pointer
)	O
)	O
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
)	O
)	O
<=	O
(	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
key_str	pointer
)	O
)	O
[	O
(	O
k_pos	int
)	O
+	O
(	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
)	O
]	O
)	O
)	O
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< bad key sequence %ld @ %d\n"	pointer
,	O
blk_id	O
(	O
blk	pointer
)	O
,	O
b_pos	int
)	O
)	O
;	O
k_size	int
=	O
(	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
)	O
+	O
(	O
field_len	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
)	O
;	O
if	O
(	O
(	O
k_size	int
)	O
>=	O
(	O
k_len	int
)	O
)	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< not-enough-room %d\n"	pointer
,	O
k_len	int
)	O
)	O
;	O
subbytes_move	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
2	int
,	O
(	O
b_pos	int
)	O
+	O
2	int
+	O
(	O
field_len	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
)	O
,	O
key_str	pointer
,	O
(	O
k_pos	int
)	O
+	O
(	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
)	O
)	O
;	O
b_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
if	O
(	O
(	O
b_pos	int
)	O
<	O
(	O
blk_end	O
(	O
blk	pointer
)	O
)	O
)	O
b_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
{	O
}	O
}	O
return	O
k_size	int
;	O
}	O
}	O
int	O
blk_insert_and_adjust	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
int	O
b_pos	int
,	O
int	O
k_pos	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	pointer
,	O
int	O
v_len	int
,	O
int	O
bsiz	int
)	O
{	O
{	O
int	O
oldk_pos	int
=	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
int	O
oldilen	int
=	O
field_len	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
int	O
ilen	int
=	O
(	O
k_len	int
)	O
-	O
(	O
oldk_pos	int
)	O
;	O
if	O
(	O
blk_change_size	function
(	O
blk	pointer
,	O
b_pos	int
,	O
2	int
+	O
(	O
(	O
k_len	int
)	O
-	O
(	O
k_pos	int
)	O
)	O
+	O
1	int
+	O
(	O
v_len	int
)	O
,	O
bsiz	int
)	O
)	O
{	O
b_pos	int
=	O
1	int
+	O
(	O
b_pos	int
)	O
;	O
b_pos	int
=	O
set_field	function
(	O
blk	pointer
,	O
b_pos	int
,	O
key_str	pointer
,	O
oldk_pos	int
,	O
ilen	int
)	O
;	O
b_pos	int
=	O
set_field	function
(	O
blk	pointer
,	O
b_pos	int
,	O
val_str	pointer
,	O
0	int
,	O
v_len	int
)	O
;	O
set_field_len	O
(	O
blk	pointer
,	O
b_pos	int
,	O
k_pos	int
)	O
;	O
set_field_len	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
(	O
oldilen	int
)	O
-	O
(	O
(	O
k_pos	int
)	O
-	O
(	O
oldk_pos	int
)	O
)	O
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
}	O
int	O
blk_simple_insert	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
int	O
b_pos	int
,	O
int	O
k_pos	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	pointer
,	O
int	O
v_len	int
,	O
int	O
bsiz	int
)	O
{	O
int	O
ilen	int
=	O
(	O
k_len	int
)	O
-	O
(	O
k_pos	int
)	O
;	O
if	O
(	O
blk_change_size	function
(	O
blk	pointer
,	O
b_pos	int
,	O
3	int
+	O
(	O
v_len	int
)	O
+	O
(	O
ilen	int
)	O
,	O
bsiz	int
)	O
)	O
{	O
set_field_len	O
(	O
blk	pointer
,	O
b_pos	int
,	O
k_pos	int
)	O
;	O
b_pos	int
=	O
1	int
+	O
(	O
b_pos	int
)	O
;	O
b_pos	int
=	O
set_field	function
(	O
blk	pointer
,	O
b_pos	int
,	O
key_str	pointer
,	O
k_pos	int
,	O
ilen	int
)	O
;	O
set_field	function
(	O
blk	pointer
,	O
b_pos	int
,	O
val_str	pointer
,	O
0	int
,	O
v_len	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
int	O
blk_change_existing_value	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	pointer
,	O
int	O
v_len	int
,	O
int	O
bsiz	int
)	O
{	O
int	O
ov_len	int
=	O
0	int
;	O
int	O
v_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
ov_len	int
=	O
field_len	O
(	O
blk	pointer
,	O
v_pos	int
)	O
;	O
if	O
(	O
blk_change_size	function
(	O
blk	pointer
,	O
(	O
v_pos	int
)	O
+	O
(	O
ov_len	int
)	O
+	O
1	int
,	O
(	O
v_len	int
)	O
-	O
(	O
ov_len	int
)	O
,	O
bsiz	int
)	O
)	O
{	O
set_field	function
(	O
blk	pointer
,	O
v_pos	int
,	O
val_str	pointer
,	O
0	int
,	O
v_len	int
)	O
;	O
return	O
!	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
int	O
val_leaf_split	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
unsigned	O
char	O
*	O
nblk	pointer
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_pos	int
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	pointer
,	O
int	O
v_len	int
)	O
{	O
{	O
int	O
v_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
;	O
int	O
s_pos	int
=	O
next_field	O
(	O
blk	pointer
,	O
v_pos	int
)	O
;	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	pointer
)	O
;	O
set_field_len	O
(	O
nblk	pointer
,	O
blk_data_start	int
,	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
b_end	int
)	O
-	O
(	O
s_pos	int
)	O
)	O
>	O
(	O
(	O
v_pos	int
)	O
-	O
(	O
blk_data_start	int
)	O
)	O
)	O
{	O
int	O
m_len	int
=	O
field_len	O
(	O
blk	pointer
,	O
s_pos	int
)	O
;	O
int	O
f_chr	int
=	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	pointer
)	O
)	O
[	O
(	O
s_pos	int
)	O
+	O
2	int
]	O
)	O
;	O
set_field_len	O
(	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
1	int
,	O
(	O
m_len	int
)	O
+	O
(	O
field_len	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
s_pos	int
)	O
)	O
)	O
)	O
;	O
subbytes_move	O
(	O
key_str	pointer
,	O
0	int
,	O
m_len	int
,	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
)	O
;	O
subbytes_move	O
(	O
blk	pointer
,	O
(	O
s_pos	int
)	O
+	O
2	int
,	O
b_end	int
,	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
(	O
m_len	int
)	O
+	O
2	int
)	O
;	O
blk_set_end	O
(	O
nblk	pointer
,	O
(	O
(	O
b_end	int
)	O
-	O
(	O
s_pos	int
)	O
)	O
+	O
(	O
m_len	int
)	O
+	O
(	O
blk_data_start	int
)	O
)	O
;	O
b_pos	int
=	O
set_field	function
(	O
blk	pointer
,	O
v_pos	int
,	O
val_str	pointer
,	O
0	int
,	O
v_len	int
)	O
;	O
blk	pointer
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
=	O
f_chr	int
;	O
set_field_len	O
(	O
blk	pointer
,	O
b_pos	int
,	O
m_len	int
)	O
;	O
}	O
else	O
{	O
int	O
nb_pos	int
=	O
(	O
blk_data_start	int
)	O
+	O
1	int
;	O
nb_pos	int
=	O
set_field	function
(	O
nblk	pointer
,	O
nb_pos	int
,	O
key_str	pointer
,	O
0	int
,	O
k_len	int
)	O
;	O
nb_pos	int
=	O
set_field	function
(	O
nblk	pointer
,	O
nb_pos	int
,	O
val_str	pointer
,	O
0	int
,	O
v_len	int
)	O
;	O
subbytes_move	O
(	O
blk	pointer
,	O
s_pos	int
,	O
b_end	int
,	O
nblk	pointer
,	O
nb_pos	int
)	O
;	O
blk_set_end	O
(	O
nblk	pointer
,	O
(	O
nb_pos	int
)	O
+	O
(	O
(	O
b_end	int
)	O
-	O
(	O
s_pos	int
)	O
)	O
)	O
;	O
}	O
set_field_len	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
1	int
)	O
;	O
blk_set_end	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
3	int
)	O
;	O
return	O
b_pos	int
;	O
}	O
}	O
int	O
qpastp_leaf_split	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
unsigned	O
char	O
*	O
nblk	pointer
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_pos	int
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	pointer
,	O
int	O
v_len	int
)	O
{	O
{	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	pointer
)	O
;	O
set_field_len	O
(	O
nblk	pointer
,	O
blk_data_start	int
,	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
b_end	int
)	O
-	O
(	O
b_pos	int
)	O
)	O
>	O
(	O
(	O
b_pos	int
)	O
-	O
(	O
blk_data_start	int
)	O
)	O
)	O
{	O
int	O
m_len	int
=	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
int	O
f_chr	int
=	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	pointer
)	O
)	O
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
)	O
;	O
set_field_len	O
(	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
1	int
,	O
(	O
m_len	int
)	O
+	O
(	O
field_len	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
)	O
)	O
;	O
subbytes_move	O
(	O
key_str	pointer
,	O
0	int
,	O
m_len	int
,	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
)	O
;	O
subbytes_move	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
2	int
,	O
b_end	int
,	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
(	O
m_len	int
)	O
+	O
2	int
)	O
;	O
blk_set_end	O
(	O
nblk	pointer
,	O
(	O
(	O
b_end	int
)	O
-	O
(	O
b_pos	int
)	O
)	O
+	O
(	O
m_len	int
)	O
+	O
(	O
blk_data_start	int
)	O
)	O
;	O
set_field_len	O
(	O
blk	pointer
,	O
b_pos	int
,	O
k_pos	int
)	O
;	O
b_pos	int
=	O
set_field	function
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
key_str	pointer
,	O
k_pos	int
,	O
(	O
k_len	int
)	O
-	O
(	O
k_pos	int
)	O
)	O
;	O
b_pos	int
=	O
set_field	function
(	O
blk	pointer
,	O
b_pos	int
,	O
val_str	pointer
,	O
0	int
,	O
v_len	int
)	O
;	O
blk	pointer
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
=	O
f_chr	int
;	O
set_field_len	O
(	O
blk	pointer
,	O
b_pos	int
,	O
m_len	int
)	O
;	O
}	O
else	O
{	O
int	O
nb_pos	int
=	O
(	O
blk_data_start	int
)	O
+	O
1	int
;	O
nb_pos	int
=	O
set_field	function
(	O
nblk	pointer
,	O
nb_pos	int
,	O
key_str	pointer
,	O
0	int
,	O
k_len	int
)	O
;	O
nb_pos	int
=	O
set_field	function
(	O
nblk	pointer
,	O
nb_pos	int
,	O
val_str	pointer
,	O
0	int
,	O
v_len	int
)	O
;	O
subbytes_move	O
(	O
blk	pointer
,	O
b_pos	int
,	O
b_end	int
,	O
nblk	pointer
,	O
nb_pos	int
)	O
;	O
blk_set_end	O
(	O
nblk	pointer
,	O
(	O
nb_pos	int
)	O
+	O
(	O
(	O
b_end	int
)	O
-	O
(	O
b_pos	int
)	O
)	O
)	O
;	O
set_field_len	O
(	O
blk	pointer
,	O
b_pos	int
,	O
k_pos	int
)	O
;	O
blk	pointer
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
=	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
key_str	pointer
)	O
)	O
[	O
k_pos	int
]	O
)	O
;	O
}	O
set_field_len	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
1	int
)	O
;	O
blk_set_end	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
3	int
)	O
;	O
return	O
b_pos	int
;	O
}	O
}	O
int	O
pastp_leaf_split	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
unsigned	O
char	O
*	O
nblk	pointer
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_pos	int
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	pointer
,	O
int	O
v_len	int
)	O
{	O
{	O
int	O
m_len	int
=	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
;	O
int	O
b_end	int
=	O
blk_end	O
(	O
blk	pointer
)	O
;	O
set_field_len	O
(	O
nblk	pointer
,	O
blk_data_start	int
,	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
b_end	int
)	O
-	O
(	O
b_pos	int
)	O
)	O
>	O
(	O
(	O
b_pos	int
)	O
-	O
(	O
blk_data_start	int
)	O
)	O
)	O
{	O
int	O
f_chr	int
=	O
(	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
(	O
blk	pointer
)	O
)	O
[	O
(	O
b_pos	int
)	O
+	O
2	int
+	O
(	O
(	O
k_pos	int
)	O
-	O
(	O
field_len	O
(	O
blk	pointer
,	O
b_pos	int
)	O
)	O
)	O
]	O
)	O
;	O
set_field_len	O
(	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
1	int
,	O
(	O
m_len	int
)	O
+	O
(	O
field_len	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
)	O
)	O
;	O
subbytes_move	O
(	O
key_str	pointer
,	O
0	int
,	O
m_len	int
,	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
)	O
;	O
subbytes_move	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
2	int
,	O
b_end	int
,	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
(	O
m_len	int
)	O
+	O
2	int
)	O
;	O
blk_set_end	O
(	O
nblk	pointer
,	O
(	O
(	O
b_end	int
)	O
-	O
(	O
b_pos	int
)	O
)	O
+	O
(	O
m_len	int
)	O
+	O
(	O
blk_data_start	int
)	O
)	O
;	O
set_field_len	O
(	O
blk	pointer
,	O
b_pos	int
,	O
m_len	int
)	O
;	O
b_pos	int
=	O
set_field	function
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
key_str	pointer
,	O
m_len	int
,	O
(	O
k_len	int
)	O
-	O
(	O
m_len	int
)	O
)	O
;	O
b_pos	int
=	O
set_field	function
(	O
blk	pointer
,	O
b_pos	int
,	O
val_str	pointer
,	O
0	int
,	O
v_len	int
)	O
;	O
blk	pointer
[	O
(	O
b_pos	int
)	O
+	O
2	int
]	O
=	O
f_chr	int
;	O
set_field_len	O
(	O
blk	pointer
,	O
b_pos	int
,	O
k_pos	int
)	O
;	O
}	O
else	O
{	O
int	O
nb_pos	int
=	O
(	O
blk_data_start	int
)	O
+	O
1	int
;	O
int	O
c_pos	int
=	O
(	O
b_pos	int
)	O
+	O
2	int
+	O
(	O
(	O
k_pos	int
)	O
-	O
(	O
m_len	int
)	O
)	O
;	O
nb_pos	int
=	O
set_field	function
(	O
nblk	pointer
,	O
nb_pos	int
,	O
key_str	pointer
,	O
0	int
,	O
k_len	int
)	O
;	O
nb_pos	int
=	O
set_field	function
(	O
nblk	pointer
,	O
nb_pos	int
,	O
val_str	pointer
,	O
0	int
,	O
v_len	int
)	O
;	O
set_field_len	O
(	O
nblk	pointer
,	O
nb_pos	int
,	O
k_pos	int
)	O
;	O
set_field_len	O
(	O
nblk	pointer
,	O
(	O
nb_pos	int
)	O
+	O
1	int
,	O
(	O
(	O
field_len	O
(	O
blk	pointer
,	O
1	int
+	O
(	O
b_pos	int
)	O
)	O
)	O
+	O
(	O
m_len	int
)	O
)	O
-	O
(	O
k_pos	int
)	O
)	O
;	O
subbytes_move	O
(	O
blk	pointer
,	O
c_pos	int
,	O
b_end	int
,	O
nblk	pointer
,	O
(	O
nb_pos	int
)	O
+	O
2	int
)	O
;	O
blk_set_end	O
(	O
nblk	pointer
,	O
(	O
nb_pos	int
)	O
+	O
2	int
+	O
(	O
(	O
b_end	int
)	O
-	O
(	O
c_pos	int
)	O
)	O
)	O
;	O
}	O
set_field_len	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
1	int
,	O
1	int
)	O
;	O
blk_set_end	O
(	O
blk	pointer
,	O
(	O
b_pos	int
)	O
+	O
3	int
)	O
;	O
return	O
b_pos	int
;	O
}	O
}	O
int	O
dummy_leaf_split	function
(	O
unsigned	O
char	O
*	O
blk	pointer
,	O
unsigned	O
char	O
*	O
nblk	pointer
,	O
int	O
b_pos	int
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_pos	int
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	pointer
,	O
int	O
v_len	int
)	O
{	O
dprintf	function
(	O
(	O
diagout	pointer
,	O
">>>>ERROR<<<< %s: bad-MATCH-TYPE blk %ld\n"	pointer
,	O
"dummy_leaf_split"	pointer
,	O
blk_id	O
(	O
blk	pointer
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int_function	pointer
select_split_fun	function
(	O
int	O
type	int
)	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
pastp	O
:	O
return	O
pastp_leaf_split	function
;	O
case	O
qpastp	O
:	O
return	O
qpastp_leaf_split	function
;	O
case	O
match	O
:	O
return	O
val_leaf_split	function
;	O
default	O
:	O
return	O
dummy_leaf_split	function
;	O
}	O
}	O
int	O
chain_put	function
(	O
ENTRY	struct
*	O
ent	pointer
,	O
unsigned	O
char	O
*	O
key_str	pointer
,	O
int	O
k_len	int
,	O
unsigned	O
char	O
*	O
val_str	pointer
,	O
int	O
v_len	int
,	O
int	O
*	O
pkt	pointer
,	O
ENTRY	struct
*	O
xent	pointer
,	O
int	O
wcb	int
)	O
{	O
{	O
unsigned	O
char	O
*	O
blk	pointer
=	O
ent_blk	O
(	O
ent	pointer
)	O
;	O
int	O
blklev	int
=	O
blk_level	O
(	O
blk	pointer
)	O
;	O
int	O
index_P	int
=	O
(	O
blklev	int
)	O
>	O
(	O
leaf	int
)	O
;	O
long	O
root_id	long
=	O
blk_top_id	O
(	O
blk	pointer
)	O
;	O
ENTRY	struct
*	O
nent	pointer
=	O
0	int
;	O
ENTRY	struct
*	O
nrent	pointer
=	O
0	int
;	O
SEGD	struct
*	O
seg	pointer
=	O
ent_seg	O
(	O
ent	pointer
)	O
;	O
int	O
bsiz	int
=	O
seg_bsiz	O
(	O
seg	pointer
)	O
;	O
int	O
result_P	int
=	O
0	int
;	O
int	O
split_P	int
=	O
0	int
;	O
ENTRY	struct
*	O
nkey_ent	pointer
=	O
ent	pointer
;	O
int	O
nkey_pos	int
=	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
;	O
ENTRY	struct
*	O
okey_ent	pointer
=	O
ent	pointer
;	O
int	O
okey_pos	int
=	O
blk_data_start	int
;	O
long	O
n_id	long
=	O
0x0L	int
;	O
int	O
s_pos	int
=	O
0	int
;	O
unsigned	O
char	O
split_str	array
[	O
0x100	int
]	O
;	O
int	O
s_len	int
=	O
0	int
;	O
pkt_set_blk_to_cache	O
(	O
pkt	pointer
,	O
ent_id	O
(	O
ent	pointer
)	O
)	O
;	O
if	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
pastp	O
)	O
)	O
&&	O
(	O
blk_insert_and_adjust	function
(	O
blk	pointer
,	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
,	O
pkt_key_pos	O
(	O
pkt	pointer
)	O
,	O
key_str	pointer
,	O
k_len	int
,	O
val_str	pointer
,	O
v_len	int
,	O
bsiz	int
)	O
)	O
)	O
{	O
result_P	int
=	O
!	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
qpastp	O
)	O
)	O
&&	O
(	O
blk_simple_insert	function
(	O
blk	pointer
,	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
,	O
pkt_key_pos	O
(	O
pkt	pointer
)	O
,	O
key_str	pointer
,	O
k_len	int
,	O
val_str	pointer
,	O
v_len	int
,	O
bsiz	int
)	O
)	O
)	O
{	O
result_P	int
=	O
!	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
match	O
)	O
)	O
&&	O
(	O
blk_change_existing_value	function
(	O
blk	pointer
,	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
,	O
key_str	pointer
,	O
k_len	int
,	O
val_str	pointer
,	O
v_len	int
,	O
bsiz	int
)	O
)	O
)	O
{	O
result_P	int
=	O
!	O
0	int
;	O
}	O
else	O
if	O
(	O
(	O
nent	pointer
=	O
create_new_blk_ent	function
(	O
seg	pointer
)	O
,	O
!	O
(	O
nent	pointer
)	O
)	O
)	O
;	O
else	O
{	O
split_P	int
=	O
!	O
0	int
;	O
{	O
unsigned	O
char	O
*	O
nblk	pointer
=	O
ent_blk	O
(	O
nent	pointer
)	O
;	O
n_id	long
=	O
ent_id	O
(	O
nent	pointer
)	O
;	O
init_next_blk	function
(	O
blk	pointer
,	O
nblk	pointer
)	O
;	O
block_splits	int
=	O
(	O
block_splits	int
)	O
+	O
1	int
;	O
s_pos	int
=	O
(	O
*	O
(	O
select_split_fun	function
(	O
pkt_match_type	O
(	O
pkt	pointer
)	O
)	O
)	O
)	O
(	O
blk	pointer
,	O
nblk	pointer
,	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
,	O
key_str	pointer
,	O
pkt_key_pos	O
(	O
pkt	pointer
)	O
,	O
k_len	int
,	O
val_str	pointer
,	O
v_len	int
)	O
;	O
s_len	int
=	O
1	int
+	O
(	O
field_len	O
(	O
blk	pointer
,	O
s_pos	int
)	O
)	O
;	O
subbytes_move	O
(	O
nblk	pointer
,	O
(	O
blk_data_start	int
)	O
+	O
2	int
,	O
1	int
+	O
(	O
field_len	O
(	O
blk	pointer
,	O
s_pos	int
)	O
)	O
+	O
(	O
(	O
blk_data_start	int
)	O
+	O
2	int
)	O
,	O
split_str	array
,	O
0	int
)	O
;	O
if	O
(	O
index_P	int
)	O
{	O
okey_ent	pointer
=	O
nent	pointer
;	O
if	O
(	O
(	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
)	O
!=	O
(	O
s_pos	int
)	O
)	O
{	O
split_index_inserts	int
=	O
1	int
+	O
(	O
split_index_inserts	int
)	O
;	O
}	O
else	O
{	O
okey_pos	int
=	O
next_cnvpair	O
(	O
nblk	pointer
,	O
blk_data_start	int
)	O
;	O
nkey_ent	pointer
=	O
nent	pointer
;	O
nkey_pos	int
=	O
blk_data_start	int
;	O
}	O
}	O
if	O
(	O
(	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
)	O
==	O
(	O
s_pos	int
)	O
)	O
pkt_set_blk_to_cache	O
(	O
pkt	pointer
,	O
ent_id	O
(	O
nent	pointer
)	O
)	O
;	O
if	O
(	O
root_P	O
(	O
blk	pointer
)	O
)	O
{	O
nrent	pointer
=	O
create_new_blk_ent	function
(	O
seg	pointer
)	O
;	O
if	O
(	O
nrent	pointer
)	O
{	O
reroot	function
(	O
blk	pointer
,	O
ent_blk	O
(	O
nrent	pointer
)	O
,	O
ent_id	O
(	O
nrent	pointer
)	O
,	O
seg_bsiz	O
(	O
seg	pointer
)	O
)	O
;	O
if	O
(	O
(	O
nkey_ent	pointer
)	O
==	O
(	O
ent	pointer
)	O
)	O
{	O
nkey_ent	pointer
=	O
nrent	pointer
;	O
pkt_set_blk_to_cache	O
(	O
pkt	pointer
,	O
ent_id	O
(	O
nrent	pointer
)	O
)	O
;	O
}	O
}	O
}	O
result_P	int
=	O
!	O
0	int
;	O
}	O
}	O
if	O
(	O
(	O
result_P	int
)	O
&&	O
(	O
index_P	int
)	O
)	O
{	O
if	O
(	O
xent	pointer
)	O
{	O
index_screw_case	int
=	O
1	int
+	O
(	O
index_screw_case	int
)	O
;	O
okey_ent	pointer
=	O
xent	pointer
;	O
okey_pos	int
=	O
blk_data_start	int
;	O
}	O
else	O
if	O
(	O
!	O
(	O
split_P	int
)	O
)	O
okey_pos	int
=	O
next_cnvpair	O
(	O
blk	pointer
,	O
pkt_match_pos	O
(	O
pkt	pointer
)	O
)	O
;	O
{	O
unsigned	O
char	O
tmpstr	array
[	O
4	int
]	O
;	O
int	O
oldv_pos	int
=	O
(	O
next_field	O
(	O
ent_blk	O
(	O
okey_ent	pointer
)	O
,	O
(	O
okey_pos	int
)	O
+	O
1	int
)	O
)	O
+	O
1	int
;	O
int	O
newv_pos	int
=	O
(	O
next_field	O
(	O
ent_blk	O
(	O
nkey_ent	pointer
)	O
,	O
(	O
nkey_pos	int
)	O
+	O
1	int
)	O
)	O
+	O
1	int
;	O
subbytes_move_left	O
(	O
ent_blk	O
(	O
okey_ent	pointer
)	O
,	O
oldv_pos	int
,	O
(	O
oldv_pos	int
)	O
+	O
4	int
,	O
tmpstr	array
,	O
0	int
)	O
;	O
subbytes_move_left	O
(	O
ent_blk	O
(	O
nkey_ent	pointer
)	O
,	O
newv_pos	int
,	O
(	O
newv_pos	int
)	O
+	O
4	int
,	O
ent_blk	O
(	O
okey_ent	pointer
)	O
,	O
oldv_pos	int
)	O
;	O
subbytes_move_left	O
(	O
tmpstr	array
,	O
0	int
,	O
4	int
,	O
ent_blk	O
(	O
nkey_ent	pointer
)	O
,	O
newv_pos	int
)	O
;	O
}	O
}	O
if	O
(	O
nrent	pointer
)	O
{	O
ents_ent_write	function
(	O
nrent	pointer
)	O
;	O
release_ent	function
(	O
nrent	pointer
,	O
accwrite	O
)	O
;	O
}	O
if	O
(	O
nent	pointer
)	O
{	O
ents_ent_write	function
(	O
nent	pointer
)	O
;	O
ents_ent_update_access_P	function
(	O
nent	pointer
,	O
accwrite	O
,	O
accnone	O
)	O
;	O
}	O
if	O
(	O
result_P	int
)	O
{	O
ent_set_dty	O
(	O
ent	pointer
,	O
!	O
0	int
)	O
;	O
if	O
(	O
(	O
split_P	int
)	O
||	O
(	O
xent	pointer
)	O
||	O
(	O
(	O
wcb_sap	int
)	O
&	O
(	O
wcb	int
)	O
)	O
)	O
ents_ent_write	function
(	O
ent	pointer
)	O
;	O
release_ent	function
(	O
ent	pointer
,	O
accwrite	O
)	O
;	O
}	O
if	O
(	O
xent	pointer
)	O
{	O
ent_set_dty	O
(	O
xent	pointer
,	O
!	O
0	int
)	O
;	O
ents_ent_write	function
(	O
xent	pointer
)	O
;	O
release_ent	function
(	O
xent	pointer
,	O
accwrite	O
)	O
;	O
}	O
if	O
(	O
split_P	int
)	O
parent_insert_update	function
(	O
seg	pointer
,	O
root_id	long
,	O
blklev	int
,	O
split_str	array
,	O
s_len	int
,	O
n_id	long
)	O
;	O
if	O
(	O
nent	pointer
)	O
release_ent	function
(	O
nent	pointer
,	O
accnone	O
)	O
;	O
return	O
result_P	int
;	O
}	O
}	O
