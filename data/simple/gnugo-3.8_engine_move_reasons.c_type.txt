struct	O
move_data	struct
move	pointer
[	O
BOARDMAX	O
]	O
;	O
struct	O
move_reason	struct
move_reasons	array
[	O
MAX_MOVE_REASONS	int
]	O
;	O
int	O
next_reason	int
;	O
int	O
conn_worm1	array
[	O
MAX_CONNECTIONS	O
]	O
;	O
int	O
conn_worm2	array
[	O
MAX_CONNECTIONS	O
]	O
;	O
int	O
next_connection	int
;	O
int	O
semeai_target1	array
[	O
MAX_POTENTIAL_SEMEAI	int
]	O
;	O
int	O
semeai_target2	array
[	O
MAX_POTENTIAL_SEMEAI	int
]	O
;	O
static	O
int	O
next_semeai	int
;	O
Reason_set	struct
either_data	array
[	O
MAX_EITHER	int
]	O
;	O
int	O
next_either	int
;	O
Reason_set	struct
all_data	array
[	O
MAX_ALL	int
]	O
;	O
int	O
next_all	int
;	O
int	O
eyes	array
[	O
MAX_EYES	O
]	O
;	O
int	O
eyecolor	array
[	O
MAX_EYES	O
]	O
;	O
int	O
next_eye	int
;	O
int	O
lunch_dragon	array
[	O
MAX_LUNCHES	O
]	O
;	O
int	O
lunch_worm	array
[	O
MAX_LUNCHES	O
]	O
;	O
int	O
next_lunch	int
;	O
int	O
replacement_map	array
[	O
BOARDMAX	O
]	O
;	O
int	O
current_color	int
;	O
static	O
int	O
known_good_attack_threats	array
[	O
BOARDMAX	O
]	O
[	O
MAX_ATTACK_THREATS	int
]	O
;	O
static	O
int	O
known_safe_moves	array
[	O
BOARDMAX	O
]	O
;	O
typedef	O
int	O
(	O
*	O
discard_condition_fn_ptr	pointer
)	O
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
;	O
struct	O
discard_rule	struct
{	O
int	O
reason_type	array
[	O
MAX_REASONS	int
]	O
;	O
discard_condition_fn_ptr	pointer
condition	pointer
;	O
int	O
flags	int
;	O
char	O
trace_message	pointer
[	O
MAX_TRACE_LENGTH	int
]	O
;	O
}	O
;	O
void	O
clear_move_reasons	function
(	O
void	O
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
next_reason	int
=	O
0	int
;	O
next_connection	int
=	O
0	int
;	O
next_semeai	int
=	O
0	int
;	O
next_either	int
=	O
0	int
;	O
next_all	int
=	O
0	int
;	O
next_eye	int
=	O
0	int
;	O
next_lunch	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
move	pointer
[	O
pos	int
]	O
.	O
value	pointer
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
final_value	float
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
territorial_value	array
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
strategical_value	float
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
maxpos_shape	float
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
numpos_shape	int
=	O
0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
maxneg_shape	float
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
numneg_shape	int
=	O
0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
followup_value	pointer
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
influence_followup_value	float
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
reverse_followup_value	float
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
secondary_value	float
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
max_value	float
=	O
HUGE_MOVE_VALUE	O
;	O
move	pointer
[	O
pos	int
]	O
.	O
min_territory	float
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
max_territory	float
=	O
HUGE_MOVE_VALUE	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
=	O
-	O
1	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
=	O
0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
worthwhile_threat	int
=	O
0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
randomness_scaling	float
=	O
1.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
random_number	float
=	O
gg_drand	function
(	O
)	O
;	O
replacement_map	array
[	O
pos	int
]	O
=	O
NO_MOVE	O
;	O
}	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
known_safe_moves	array
[	O
pos	int
]	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_ATTACK_THREATS	int
;	O
k	int
++	O
)	O
known_good_attack_threats	array
[	O
pos	int
]	O
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
}	O
}	O
int	O
find_connection	function
(	O
int	O
worm1	int
,	O
int	O
worm2	int
)	O
{	O
int	O
k	int
;	O
if	O
(	O
worm1	int
>	O
worm2	int
)	O
{	O
int	O
tmp	int
=	O
worm1	int
;	O
worm1	int
=	O
worm2	int
;	O
worm2	int
=	O
tmp	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
next_connection	int
;	O
k	int
++	O
)	O
if	O
(	O
conn_worm1	array
[	O
k	int
]	O
==	O
worm1	int
&&	O
conn_worm2	array
[	O
k	int
]	O
==	O
worm2	int
)	O
return	O
k	int
;	O
gg_assert	O
(	O
next_connection	int
<	O
MAX_CONNECTIONS	O
)	O
;	O
conn_worm1	array
[	O
next_connection	int
]	O
=	O
worm1	int
;	O
conn_worm2	array
[	O
next_connection	int
]	O
=	O
worm2	int
;	O
next_connection	int
++	O
;	O
return	O
next_connection	int
-	O
1	int
;	O
}	O
static	O
int	O
find_either_data	function
(	O
int	O
reason1	int
,	O
int	O
what1	int
,	O
int	O
reason2	int
,	O
int	O
what2	int
)	O
{	O
int	O
k	int
;	O
if	O
(	O
what1	int
>	O
what2	int
)	O
{	O
int	O
tmp	int
=	O
what1	int
;	O
what1	int
=	O
what2	int
;	O
what2	int
=	O
tmp	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
next_either	int
;	O
k	int
++	O
)	O
if	O
(	O
either_data	array
[	O
k	int
]	O
.	O
reason1	int
==	O
reason1	int
&&	O
either_data	array
[	O
k	int
]	O
.	O
what1	int
==	O
what1	int
&&	O
either_data	array
[	O
k	int
]	O
.	O
reason2	int
==	O
reason2	int
&&	O
either_data	array
[	O
k	int
]	O
.	O
what2	int
==	O
what2	int
)	O
return	O
k	int
;	O
gg_assert	O
(	O
next_either	int
<	O
MAX_EITHER	int
)	O
;	O
either_data	array
[	O
next_either	int
]	O
.	O
reason1	int
=	O
reason1	int
;	O
either_data	array
[	O
next_either	int
]	O
.	O
what1	int
=	O
what1	int
;	O
either_data	array
[	O
next_either	int
]	O
.	O
reason2	int
=	O
reason2	int
;	O
either_data	array
[	O
next_either	int
]	O
.	O
what2	int
=	O
what2	int
;	O
next_either	int
++	O
;	O
return	O
next_either	int
-	O
1	int
;	O
}	O
static	O
int	O
find_all_data	function
(	O
int	O
reason1	int
,	O
int	O
what1	int
,	O
int	O
reason2	int
,	O
int	O
what2	int
)	O
{	O
int	O
k	int
;	O
if	O
(	O
what1	int
>	O
what2	int
)	O
{	O
int	O
tmp	int
=	O
what1	int
;	O
what1	int
=	O
what2	int
;	O
what2	int
=	O
tmp	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
next_all	int
;	O
k	int
++	O
)	O
if	O
(	O
all_data	array
[	O
k	int
]	O
.	O
reason1	int
==	O
reason1	int
&&	O
all_data	array
[	O
k	int
]	O
.	O
what1	int
==	O
what1	int
&&	O
all_data	array
[	O
k	int
]	O
.	O
reason2	int
==	O
reason2	int
&&	O
all_data	array
[	O
k	int
]	O
.	O
what2	int
==	O
what2	int
)	O
return	O
k	int
;	O
gg_assert	O
(	O
next_all	int
<	O
MAX_ALL	int
)	O
;	O
all_data	array
[	O
next_all	int
]	O
.	O
reason1	int
=	O
reason1	int
;	O
all_data	array
[	O
next_all	int
]	O
.	O
what1	int
=	O
what1	int
;	O
all_data	array
[	O
next_all	int
]	O
.	O
reason2	int
=	O
reason2	int
;	O
all_data	array
[	O
next_all	int
]	O
.	O
what2	int
=	O
what2	int
;	O
next_all	int
++	O
;	O
return	O
next_all	int
-	O
1	int
;	O
}	O
static	O
int	O
find_pair_data	function
(	O
int	O
what1	int
,	O
int	O
what2	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
next_either	int
;	O
k	int
++	O
)	O
if	O
(	O
either_data	array
[	O
k	int
]	O
.	O
what1	int
==	O
what1	int
&&	O
either_data	array
[	O
k	int
]	O
.	O
what2	int
==	O
what2	int
)	O
return	O
k	int
;	O
gg_assert	O
(	O
next_either	int
<	O
MAX_EITHER	int
)	O
;	O
either_data	array
[	O
next_either	int
]	O
.	O
what1	int
=	O
what1	int
;	O
either_data	array
[	O
next_either	int
]	O
.	O
what2	int
=	O
what2	int
;	O
next_either	int
++	O
;	O
return	O
next_either	int
-	O
1	int
;	O
}	O
static	O
int	O
get_pos	function
(	O
int	O
reason	array
,	O
int	O
what	int
)	O
{	O
switch	O
(	O
reason	array
)	O
{	O
case	O
ATTACK_MOVE	int
:	O
case	O
DEFEND_MOVE	int
:	O
case	O
ATTACK_THREAT	O
:	O
case	O
DEFEND_THREAT	O
:	O
case	O
ATTACK_MOVE_GOOD_KO	int
:	O
case	O
ATTACK_MOVE_BAD_KO	int
:	O
case	O
DEFEND_MOVE_GOOD_KO	int
:	O
case	O
DEFEND_MOVE_BAD_KO	int
:	O
return	O
what	int
;	O
case	O
SEMEAI_MOVE	int
:	O
case	O
SEMEAI_THREAT	O
:	O
case	O
STRATEGIC_ATTACK_MOVE	int
:	O
case	O
STRATEGIC_DEFEND_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE	int
:	O
case	O
OWL_DEFEND_MOVE	int
:	O
case	O
OWL_ATTACK_THREAT	O
:	O
case	O
OWL_DEFEND_THREAT	O
:	O
case	O
OWL_PREVENT_THREAT	int
:	O
case	O
UNCERTAIN_OWL_ATTACK	int
:	O
case	O
UNCERTAIN_OWL_DEFENSE	int
:	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
return	O
what	int
;	O
case	O
EITHER_MOVE	int
:	O
return	O
either_data	array
[	O
what	int
]	O
.	O
what1	int
;	O
case	O
ALL_MOVE	int
:	O
return	O
all_data	array
[	O
what	int
]	O
.	O
what1	int
;	O
case	O
CONNECT_MOVE	int
:	O
case	O
CUT_MOVE	int
:	O
return	O
conn_worm1	array
[	O
what	int
]	O
;	O
case	O
ANTISUJI_MOVE	int
:	O
case	O
EXPAND_TERRITORY_MOVE	int
:	O
case	O
EXPAND_MOYO_MOVE	int
:	O
case	O
INVASION_MOVE	int
:	O
case	O
MY_ATARI_ATARI_MOVE	int
:	O
case	O
YOUR_ATARI_ATARI_MOVE	int
:	O
return	O
NO_MOVE	O
;	O
case	O
OWL_ATTACK_MOVE_GAIN	int
:	O
case	O
OWL_DEFEND_MOVE_LOSS	int
:	O
return	O
either_data	array
[	O
what	int
]	O
.	O
what1	int
;	O
default	O
:	O
gg_assert	O
(	O
0	int
)	O
;	O
return	O
0	int
;	O
}	O
}	O
void	O
add_lunch	function
(	O
int	O
eater	int
,	O
int	O
food	int
)	O
{	O
int	O
k	int
;	O
int	O
dragon1	int
=	O
dragon	int
[	O
eater	int
]	O
.	O
origin	int
;	O
int	O
worm1	int
=	O
worm	array
[	O
food	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
eater	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
food	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
next_lunch	int
;	O
k	int
++	O
)	O
if	O
(	O
(	O
lunch_dragon	array
[	O
k	int
]	O
==	O
dragon1	int
)	O
&&	O
(	O
lunch_worm	array
[	O
k	int
]	O
==	O
worm1	int
)	O
)	O
return	O
;	O
gg_assert	O
(	O
next_lunch	int
<	O
MAX_LUNCHES	O
)	O
;	O
lunch_dragon	array
[	O
next_lunch	int
]	O
=	O
dragon1	int
;	O
lunch_worm	array
[	O
next_lunch	int
]	O
=	O
worm1	int
;	O
next_lunch	int
++	O
;	O
return	O
;	O
}	O
static	O
void	O
add_move_reason	function
(	O
int	O
pos	int
,	O
int	O
type	char
,	O
int	O
what	int
)	O
{	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
stackp	int
==	O
0	int
)	O
{	O
ASSERT1	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
type	char
&&	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
==	O
what	int
)	O
return	O
;	O
}	O
if	O
(	O
k	int
>=	O
MAX_REASONS	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Move reason at %1m (type=%d, what=%d) dropped because list full.\n"	pointer
,	O
pos	int
,	O
type	char
,	O
what	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
next_reason	int
>=	O
MAX_MOVE_REASONS	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Move reason at %1m (type=%d, what=%d) dropped because global list full.\n"	pointer
,	O
pos	int
,	O
type	char
,	O
what	int
)	O
;	O
return	O
;	O
}	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
=	O
next_reason	int
;	O
move_reasons	array
[	O
next_reason	int
]	O
.	O
type	char
=	O
type	char
;	O
move_reasons	array
[	O
next_reason	int
]	O
.	O
what	int
=	O
what	int
;	O
move_reasons	array
[	O
next_reason	int
]	O
.	O
status	enum
=	O
ACTIVE	int
;	O
next_reason	int
++	O
;	O
}	O
static	O
void	O
remove_move_reason	function
(	O
int	O
pos	int
,	O
int	O
type	char
,	O
int	O
what	int
)	O
{	O
int	O
k	int
;	O
int	O
n	int
=	O
-	O
1	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
type	char
&&	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
==	O
what	int
)	O
n	int
=	O
k	int
;	O
}	O
if	O
(	O
n	int
==	O
-	O
1	int
)	O
return	O
;	O
k	int
--	O
;	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
n	int
]	O
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
=	O
-	O
1	int
;	O
}	O
int	O
move_reason_known	function
(	O
int	O
pos	int
,	O
int	O
type	char
,	O
int	O
what	int
)	O
{	O
int	O
k	int
;	O
int	O
r	int
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
type	char
&&	O
(	O
what	int
<	O
0	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
==	O
what	int
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
attack_move_reason_known	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
ASSERT1	O
(	O
what	int
<	O
0	int
||	O
IS_STONE	O
(	O
board	pointer
[	O
what	int
]	O
)	O
,	O
what	int
)	O
;	O
what	int
=	O
worm	array
[	O
what	int
]	O
.	O
origin	int
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
ATTACK_MOVE	int
,	O
what	int
)	O
)	O
return	O
WIN	int
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
ATTACK_MOVE_GOOD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_A	int
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
ATTACK_MOVE_BAD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_B	int
;	O
return	O
0	int
;	O
}	O
int	O
defense_move_reason_known	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
ASSERT1	O
(	O
what	int
<	O
0	int
||	O
IS_STONE	O
(	O
board	pointer
[	O
what	int
]	O
)	O
,	O
what	int
)	O
;	O
what	int
=	O
worm	array
[	O
what	int
]	O
.	O
origin	int
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
DEFEND_MOVE	int
,	O
what	int
)	O
)	O
return	O
WIN	int
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
DEFEND_MOVE_GOOD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_A	int
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
DEFEND_MOVE_BAD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_B	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
tactical_move_vs_whole_dragon_known	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
return	O
(	O
(	O
worm	array
[	O
what	int
]	O
.	O
size	int
==	O
dragon	int
[	O
what	int
]	O
.	O
size	int
)	O
&&	O
(	O
attack_move_reason_known	function
(	O
pos	int
,	O
what	int
)	O
||	O
defense_move_reason_known	function
(	O
pos	int
,	O
what	int
)	O
)	O
)	O
;	O
}	O
int	O
owl_attack_move_reason_known	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
OWL_ATTACK_MOVE	int
,	O
what	int
)	O
)	O
return	O
WIN	int
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
OWL_ATTACK_MOVE_GOOD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_A	int
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
OWL_ATTACK_MOVE_BAD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_B	int
;	O
return	O
0	int
;	O
}	O
int	O
owl_defense_move_reason_known	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
OWL_DEFEND_MOVE	int
,	O
what	int
)	O
)	O
return	O
WIN	int
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
OWL_DEFEND_MOVE_GOOD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_A	int
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
OWL_DEFEND_MOVE_BAD_KO	int
,	O
what	int
)	O
)	O
return	O
KO_B	int
;	O
return	O
0	int
;	O
}	O
int	O
owl_move_reason_known	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
return	O
(	O
owl_attack_move_reason_known	function
(	O
pos	int
,	O
what	int
)	O
||	O
owl_defense_move_reason_known	function
(	O
pos	int
,	O
what	int
)	O
)	O
;	O
}	O
static	O
int	O
owl_move_vs_worm_known	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
return	O
owl_move_reason_known	function
(	O
pos	int
,	O
dragon	int
[	O
what	int
]	O
.	O
origin	int
)	O
;	O
}	O
int	O
semeai_move_reason_known	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
return	O
move_reason_known	function
(	O
pos	int
,	O
SEMEAI_MOVE	int
,	O
what	int
)	O
;	O
}	O
static	O
int	O
concerns_inessential_worm	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
pos	int
)	O
;	O
return	O
DRAGON2	O
(	O
what	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
||	O
worm	array
[	O
what	int
]	O
.	O
inessential	int
;	O
}	O
static	O
int	O
concerns_inessential_dragon	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
pos	int
)	O
;	O
return	O
DRAGON2	O
(	O
what	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
;	O
}	O
static	O
int	O
move_is_marked_unsafe	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
what	int
)	O
;	O
return	O
(	O
!	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
&&	O
!	O
adjacent_to_nondead_stone	function
(	O
pos	int
,	O
current_color	int
)	O
)	O
;	O
}	O
static	O
int	O
concerns_noncritical_dragon	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
pos	int
)	O
;	O
return	O
(	O
dragon	int
[	O
what	int
]	O
.	O
status	enum
!=	O
CRITICAL	int
&&	O
worm	array
[	O
what	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
;	O
}	O
static	O
int	O
either_worm_attackable	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
pos	int
)	O
;	O
return	O
(	O
either_data	array
[	O
what	int
]	O
.	O
reason1	int
==	O
ATTACK_STRING	int
&&	O
either_data	array
[	O
what	int
]	O
.	O
reason2	int
==	O
ATTACK_STRING	int
&&	O
(	O
worm	array
[	O
either_data	array
[	O
what	int
]	O
.	O
what1	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
||	O
worm	array
[	O
either_data	array
[	O
what	int
]	O
.	O
what2	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
)	O
)	O
;	O
}	O
static	O
int	O
one_of_both_attackable	function
(	O
int	O
pos	int
,	O
int	O
what	int
)	O
{	O
UNUSED	O
(	O
pos	int
)	O
;	O
return	O
(	O
all_data	array
[	O
what	int
]	O
.	O
reason1	int
==	O
DEFEND_STRING	int
&&	O
all_data	array
[	O
what	int
]	O
.	O
reason2	int
==	O
DEFEND_STRING	int
&&	O
(	O
worm	array
[	O
all_data	array
[	O
what	int
]	O
.	O
what1	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
||	O
worm	array
[	O
all_data	array
[	O
what	int
]	O
.	O
what2	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
)	O
)	O
;	O
}	O
void	O
add_attack_move	function
(	O
int	O
pos	int
,	O
int	O
ww	int
,	O
int	O
code	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
ww	int
)	O
;	O
ww	int
=	O
worm	array
[	O
ww	int
]	O
.	O
origin	int
;	O
if	O
(	O
code	int
==	O
WIN	int
)	O
add_move_reason	function
(	O
pos	int
,	O
ATTACK_MOVE	int
,	O
ww	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_A	int
)	O
add_move_reason	function
(	O
pos	int
,	O
ATTACK_MOVE_GOOD_KO	int
,	O
ww	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_B	int
)	O
add_move_reason	function
(	O
pos	int
,	O
ATTACK_MOVE_BAD_KO	int
,	O
ww	int
)	O
;	O
}	O
void	O
add_defense_move	function
(	O
int	O
pos	int
,	O
int	O
ww	int
,	O
int	O
code	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
ww	int
)	O
;	O
ww	int
=	O
worm	array
[	O
ww	int
]	O
.	O
origin	int
;	O
if	O
(	O
code	int
==	O
WIN	int
)	O
add_move_reason	function
(	O
pos	int
,	O
DEFEND_MOVE	int
,	O
ww	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_A	int
)	O
add_move_reason	function
(	O
pos	int
,	O
DEFEND_MOVE_GOOD_KO	int
,	O
ww	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_B	int
)	O
add_move_reason	function
(	O
pos	int
,	O
DEFEND_MOVE_BAD_KO	int
,	O
ww	int
)	O
;	O
}	O
void	O
add_attack_threat_move	function
(	O
int	O
pos	int
,	O
int	O
ww	int
,	O
int	O
code	int
)	O
{	O
UNUSED	O
(	O
code	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
ww	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
ATTACK_THREAT	O
,	O
worm	array
[	O
ww	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
remove_attack_threat_move	function
(	O
int	O
pos	int
,	O
int	O
ww	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
ww	int
)	O
;	O
remove_move_reason	function
(	O
pos	int
,	O
ATTACK_THREAT	O
,	O
worm	array
[	O
ww	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
add_defense_threat_move	function
(	O
int	O
pos	int
,	O
int	O
ww	int
,	O
int	O
code	int
)	O
{	O
UNUSED	O
(	O
code	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
ww	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
DEFEND_THREAT	O
,	O
worm	array
[	O
ww	int
]	O
.	O
origin	int
)	O
;	O
}	O
int	O
get_attack_threats	function
(	O
int	O
pos	int
,	O
int	O
max_strings	int
,	O
int	O
strings	array
[	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
num_strings	int
;	O
num_strings	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_THREAT	O
)	O
strings	array
[	O
num_strings	int
++	O
]	O
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
num_strings	int
==	O
max_strings	int
)	O
break	O
;	O
}	O
return	O
num_strings	int
;	O
}	O
int	O
get_defense_threats	function
(	O
int	O
pos	int
,	O
int	O
max_strings	int
,	O
int	O
strings	array
[	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
num_strings	int
;	O
num_strings	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_THREAT	O
)	O
strings	array
[	O
num_strings	int
++	O
]	O
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
num_strings	int
==	O
max_strings	int
)	O
break	O
;	O
}	O
return	O
num_strings	int
;	O
}	O
int	O
get_biggest_owl_target	function
(	O
int	O
pos	int
)	O
{	O
int	O
k	int
;	O
int	O
biggest_target	int
=	O
-	O
1	int
;	O
float	O
target_size	float
=	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
OWL_ATTACK_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
case	O
OWL_ATTACK_THREAT	O
:	O
case	O
OWL_DEFEND_MOVE	int
:	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
case	O
OWL_DEFEND_THREAT	O
:	O
case	O
OWL_PREVENT_THREAT	int
:	O
if	O
(	O
dragon	int
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
>	O
target_size	float
)	O
{	O
biggest_target	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
target_size	float
=	O
dragon	int
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
;	O
}	O
break	O
;	O
}	O
}	O
return	O
biggest_target	int
;	O
}	O
void	O
add_connection_move	function
(	O
int	O
pos	int
,	O
int	O
w1	int
,	O
int	O
w2	int
)	O
{	O
int	O
connection	int
;	O
ASSERT_ON_BOARD1	O
(	O
w1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
w2	int
)	O
;	O
ASSERT1	O
(	O
worm	array
[	O
w1	int
]	O
.	O
color	int
==	O
worm	array
[	O
w2	int
]	O
.	O
color	int
,	O
w1	int
)	O
;	O
if	O
(	O
worm	array
[	O
w1	int
]	O
.	O
origin	int
==	O
worm	array
[	O
w2	int
]	O
.	O
origin	int
)	O
return	O
;	O
connection	int
=	O
find_connection	function
(	O
worm	array
[	O
w1	int
]	O
.	O
origin	int
,	O
worm	array
[	O
w2	int
]	O
.	O
origin	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
CONNECT_MOVE	int
,	O
connection	int
)	O
;	O
}	O
void	O
add_cut_move	function
(	O
int	O
pos	int
,	O
int	O
w1	int
,	O
int	O
w2	int
)	O
{	O
int	O
connection	int
;	O
ASSERT_ON_BOARD1	O
(	O
w1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
w2	int
)	O
;	O
ASSERT1	O
(	O
worm	array
[	O
w1	int
]	O
.	O
color	int
==	O
worm	array
[	O
w2	int
]	O
.	O
color	int
,	O
w1	int
)	O
;	O
if	O
(	O
worm	array
[	O
w1	int
]	O
.	O
origin	int
==	O
worm	array
[	O
w2	int
]	O
.	O
origin	int
)	O
return	O
;	O
connection	int
=	O
find_connection	function
(	O
worm	array
[	O
w1	int
]	O
.	O
origin	int
,	O
worm	array
[	O
w2	int
]	O
.	O
origin	int
)	O
;	O
if	O
(	O
(	O
worm	array
[	O
w1	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array
[	O
w1	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
||	O
(	O
worm	array
[	O
w2	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array
[	O
w2	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
)	O
return	O
;	O
add_move_reason	function
(	O
pos	int
,	O
CUT_MOVE	int
,	O
connection	int
)	O
;	O
}	O
void	O
add_antisuji_move	function
(	O
int	O
pos	int
)	O
{	O
add_move_reason	function
(	O
pos	int
,	O
ANTISUJI_MOVE	int
,	O
0	int
)	O
;	O
}	O
void	O
add_semeai_move	function
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
SEMEAI_MOVE	int
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
}	O
static	O
void	O
add_potential_semeai_move	function
(	O
int	O
pos	int
,	O
int	O
type	char
,	O
int	O
dr1	int
,	O
int	O
dr2	int
)	O
{	O
ASSERT1	O
(	O
ON_BOARD	O
(	O
dr1	int
)	O
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
ON_BOARD	O
(	O
dr2	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
next_semeai	int
>=	O
MAX_POTENTIAL_SEMEAI	int
)	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Potential semeai move at %1m dropped as list was full\n"	pointer
,	O
pos	int
)	O
;	O
else	O
{	O
semeai_target1	array
[	O
next_semeai	int
]	O
=	O
dr1	int
;	O
semeai_target2	array
[	O
next_semeai	int
]	O
=	O
dr2	int
;	O
add_move_reason	function
(	O
pos	int
,	O
type	char
,	O
next_semeai	int
)	O
;	O
next_semeai	int
++	O
;	O
}	O
}	O
void	O
add_potential_semeai_attack	function
(	O
int	O
pos	int
,	O
int	O
dr1	int
,	O
int	O
dr2	int
)	O
{	O
add_potential_semeai_move	function
(	O
pos	int
,	O
POTENTIAL_SEMEAI_ATTACK	int
,	O
dr1	int
,	O
dr2	int
)	O
;	O
}	O
void	O
add_potential_semeai_defense	function
(	O
int	O
pos	int
,	O
int	O
dr1	int
,	O
int	O
dr2	int
)	O
{	O
add_potential_semeai_move	function
(	O
pos	int
,	O
POTENTIAL_SEMEAI_DEFENSE	int
,	O
dr1	int
,	O
dr2	int
)	O
;	O
}	O
void	O
add_semeai_threat	function
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
SEMEAI_THREAT	O
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
add_either_move	function
(	O
int	O
pos	int
,	O
int	O
reason1	int
,	O
int	O
target1	int
,	O
int	O
reason2	int
,	O
int	O
target2	int
)	O
{	O
int	O
what1	int
=	O
0	int
;	O
int	O
what2	int
=	O
0	int
;	O
int	O
index	function
;	O
ASSERT_ON_BOARD1	O
(	O
target1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
target2	int
)	O
;	O
if	O
(	O
reason1	int
==	O
reason2	int
&&	O
target1	int
==	O
target2	int
)	O
return	O
;	O
gg_assert	O
(	O
reason1	int
==	O
ATTACK_STRING	int
)	O
;	O
gg_assert	O
(	O
reason2	int
==	O
ATTACK_STRING	int
)	O
;	O
switch	O
(	O
reason1	int
)	O
{	O
case	O
ATTACK_STRING	int
:	O
{	O
what1	int
=	O
worm	array
[	O
target1	int
]	O
.	O
origin	int
;	O
if	O
(	O
worm	array
[	O
target1	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array
[	O
target1	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
return	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
reason2	int
)	O
{	O
case	O
ATTACK_STRING	int
:	O
{	O
what2	int
=	O
worm	array
[	O
target2	int
]	O
.	O
origin	int
;	O
if	O
(	O
worm	array
[	O
target2	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array
[	O
target2	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
return	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
index	function
=	O
find_either_data	function
(	O
reason1	int
,	O
what1	int
,	O
reason2	int
,	O
what2	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
EITHER_MOVE	int
,	O
index	function
)	O
;	O
}	O
void	O
add_all_move	function
(	O
int	O
pos	int
,	O
int	O
reason1	int
,	O
int	O
target1	int
,	O
int	O
reason2	int
,	O
int	O
target2	int
)	O
{	O
int	O
what1	int
=	O
0	int
;	O
int	O
what2	int
=	O
0	int
;	O
int	O
index	function
;	O
ASSERT_ON_BOARD1	O
(	O
target1	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
target2	int
)	O
;	O
if	O
(	O
reason1	int
==	O
reason2	int
&&	O
target1	int
==	O
target2	int
)	O
return	O
;	O
gg_assert	O
(	O
reason1	int
==	O
DEFEND_STRING	int
)	O
;	O
gg_assert	O
(	O
reason2	int
==	O
DEFEND_STRING	int
)	O
;	O
switch	O
(	O
reason1	int
)	O
{	O
case	O
DEFEND_STRING	int
:	O
what1	int
=	O
worm	array
[	O
target1	int
]	O
.	O
origin	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
switch	O
(	O
reason2	int
)	O
{	O
case	O
DEFEND_STRING	int
:	O
what2	int
=	O
worm	array
[	O
target2	int
]	O
.	O
origin	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
index	function
=	O
find_all_data	function
(	O
reason1	int
,	O
what1	int
,	O
reason2	int
,	O
what2	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
ALL_MOVE	int
,	O
index	function
)	O
;	O
}	O
void	O
add_loss_move	function
(	O
int	O
pos	int
,	O
int	O
target1	int
,	O
int	O
target2	int
)	O
{	O
int	O
what1	int
=	O
dragon	int
[	O
target1	int
]	O
.	O
origin	int
;	O
int	O
what2	int
=	O
worm	array
[	O
target2	int
]	O
.	O
origin	int
;	O
int	O
index	function
=	O
find_pair_data	function
(	O
what1	int
,	O
what2	int
)	O
;	O
ASSERT1	O
(	O
target2	int
!=	O
NO_MOVE	O
,	O
pos	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
OWL_DEFEND_MOVE_LOSS	int
,	O
index	function
)	O
;	O
}	O
void	O
add_expand_territory_move	function
(	O
int	O
pos	int
)	O
{	O
add_move_reason	function
(	O
pos	int
,	O
EXPAND_TERRITORY_MOVE	int
,	O
0	int
)	O
;	O
}	O
void	O
add_expand_moyo_move	function
(	O
int	O
pos	int
)	O
{	O
add_move_reason	function
(	O
pos	int
,	O
EXPAND_MOYO_MOVE	int
,	O
0	int
)	O
;	O
}	O
void	O
add_invasion_move	function
(	O
int	O
pos	int
)	O
{	O
add_move_reason	function
(	O
pos	int
,	O
INVASION_MOVE	int
,	O
0	int
)	O
;	O
}	O
void	O
add_shape_value	function
(	O
int	O
pos	int
,	O
float	O
value	pointer
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	pointer
>	O
0.0	int
)	O
{	O
if	O
(	O
value	pointer
>	O
move	pointer
[	O
pos	int
]	O
.	O
maxpos_shape	float
)	O
move	pointer
[	O
pos	int
]	O
.	O
maxpos_shape	float
=	O
value	pointer
;	O
move	pointer
[	O
pos	int
]	O
.	O
numpos_shape	int
+=	O
1	int
;	O
}	O
else	O
if	O
(	O
value	pointer
<	O
0.0	int
)	O
{	O
value	pointer
=	O
-	O
value	pointer
;	O
if	O
(	O
value	pointer
>	O
move	pointer
[	O
pos	int
]	O
.	O
maxneg_shape	float
)	O
move	pointer
[	O
pos	int
]	O
.	O
maxneg_shape	float
=	O
value	pointer
;	O
move	pointer
[	O
pos	int
]	O
.	O
numneg_shape	int
+=	O
1	int
;	O
}	O
}	O
void	O
add_worthwhile_threat_move	function
(	O
int	O
pos	int
)	O
{	O
move	pointer
[	O
pos	int
]	O
.	O
worthwhile_threat	int
=	O
1	int
;	O
}	O
void	O
add_strategical_attack_move	function
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
STRATEGIC_ATTACK_MOVE	int
,	O
dr	int
)	O
;	O
}	O
void	O
add_strategical_defense_move	function
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
STRATEGIC_DEFEND_MOVE	int
,	O
dr	int
)	O
;	O
}	O
void	O
add_owl_attack_move	function
(	O
int	O
pos	int
,	O
int	O
dr	int
,	O
int	O
kworm	int
,	O
int	O
code	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
if	O
(	O
code	int
==	O
WIN	int
)	O
add_move_reason	function
(	O
pos	int
,	O
OWL_ATTACK_MOVE	int
,	O
dr	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_A	int
)	O
add_move_reason	function
(	O
pos	int
,	O
OWL_ATTACK_MOVE_GOOD_KO	int
,	O
dr	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_B	int
)	O
add_move_reason	function
(	O
pos	int
,	O
OWL_ATTACK_MOVE_BAD_KO	int
,	O
dr	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
GAIN	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
kworm	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
OWL_ATTACK_MOVE_GAIN	int
,	O
find_pair_data	function
(	O
dr	int
,	O
kworm	int
)	O
)	O
;	O
}	O
}	O
void	O
add_owl_defense_move	function
(	O
int	O
pos	int
,	O
int	O
dr	int
,	O
int	O
code	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
if	O
(	O
code	int
==	O
WIN	int
)	O
add_move_reason	function
(	O
pos	int
,	O
OWL_DEFEND_MOVE	int
,	O
dr	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_A	int
)	O
add_move_reason	function
(	O
pos	int
,	O
OWL_DEFEND_MOVE_GOOD_KO	int
,	O
dr	int
)	O
;	O
else	O
if	O
(	O
code	int
==	O
KO_B	int
)	O
add_move_reason	function
(	O
pos	int
,	O
OWL_DEFEND_MOVE_BAD_KO	int
,	O
dr	int
)	O
;	O
}	O
void	O
add_owl_attack_threat_move	function
(	O
int	O
pos	int
,	O
int	O
dr	int
,	O
int	O
code	int
)	O
{	O
UNUSED	O
(	O
code	int
)	O
;	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
OWL_ATTACK_THREAT	O
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
add_worthwhile_threat_move	function
(	O
pos	int
)	O
;	O
}	O
void	O
add_owl_uncertain_defense_move	function
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
UNCERTAIN_OWL_DEFENSE	int
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
add_owl_uncertain_attack_move	function
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
UNCERTAIN_OWL_ATTACK	int
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
add_owl_defense_threat_move	function
(	O
int	O
pos	int
,	O
int	O
dr	int
,	O
int	O
code	int
)	O
{	O
UNUSED	O
(	O
code	int
)	O
;	O
dr	int
=	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
;	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
OWL_DEFEND_THREAT	O
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
add_worthwhile_threat_move	function
(	O
pos	int
)	O
;	O
}	O
void	O
add_my_atari_atari_move	function
(	O
int	O
pos	int
,	O
int	O
size	int
)	O
{	O
add_move_reason	function
(	O
pos	int
,	O
MY_ATARI_ATARI_MOVE	int
,	O
size	int
)	O
;	O
}	O
void	O
add_your_atari_atari_move	function
(	O
int	O
pos	int
,	O
int	O
size	int
)	O
{	O
add_move_reason	function
(	O
pos	int
,	O
YOUR_ATARI_ATARI_MOVE	int
,	O
size	int
)	O
;	O
}	O
void	O
add_owl_prevent_threat_move	function
(	O
int	O
pos	int
,	O
int	O
dr	int
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
dr	int
)	O
;	O
add_move_reason	function
(	O
pos	int
,	O
OWL_PREVENT_THREAT	int
,	O
dragon	int
[	O
dr	int
]	O
.	O
origin	int
)	O
;	O
}	O
void	O
add_followup_value	function
(	O
int	O
pos	int
,	O
float	O
value	pointer
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	pointer
>	O
move	pointer
[	O
pos	int
]	O
.	O
followup_value	pointer
)	O
move	pointer
[	O
pos	int
]	O
.	O
followup_value	pointer
=	O
value	pointer
;	O
}	O
void	O
add_reverse_followup_value	function
(	O
int	O
pos	int
,	O
float	O
value	pointer
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	pointer
>	O
move	pointer
[	O
pos	int
]	O
.	O
reverse_followup_value	float
)	O
move	pointer
[	O
pos	int
]	O
.	O
reverse_followup_value	float
=	O
value	pointer
;	O
}	O
int	O
set_minimum_move_value	function
(	O
int	O
pos	int
,	O
float	O
value	pointer
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	pointer
>	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
)	O
{	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
=	O
value	pointer
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
set_maximum_move_value	function
(	O
int	O
pos	int
,	O
float	O
value	pointer
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	pointer
<	O
move	pointer
[	O
pos	int
]	O
.	O
max_value	float
)	O
move	pointer
[	O
pos	int
]	O
.	O
max_value	float
=	O
value	pointer
;	O
}	O
void	O
set_minimum_territorial_value	function
(	O
int	O
pos	int
,	O
float	O
value	pointer
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	pointer
>	O
move	pointer
[	O
pos	int
]	O
.	O
min_territory	float
)	O
move	pointer
[	O
pos	int
]	O
.	O
min_territory	float
=	O
value	pointer
;	O
}	O
void	O
set_maximum_territorial_value	function
(	O
int	O
pos	int
,	O
float	O
value	pointer
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
value	pointer
<	O
move	pointer
[	O
pos	int
]	O
.	O
max_territory	float
)	O
move	pointer
[	O
pos	int
]	O
.	O
max_territory	float
=	O
value	pointer
;	O
}	O
void	O
add_replacement_move	function
(	O
int	O
from	int
,	O
int	O
to	int
,	O
int	O
color	int
)	O
{	O
int	O
cc	int
;	O
int	O
pos	int
;	O
int	O
dummy	int
;	O
ASSERT_ON_BOARD1	O
(	O
from	int
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
to	int
)	O
;	O
if	O
(	O
board	pointer
[	O
from	int
]	O
!=	O
EMPTY	int
)	O
return	O
;	O
ASSERT1	O
(	O
board	pointer
[	O
to	int
]	O
==	O
EMPTY	int
,	O
to	int
)	O
;	O
cc	int
=	O
replacement_map	array
[	O
to	int
]	O
;	O
if	O
(	O
unconditionally_meaningless_move	function
(	O
to	int
,	O
color	int
,	O
&	O
dummy	int
)	O
)	O
{	O
return	O
;	O
}	O
if	O
(	O
replacement_map	array
[	O
from	int
]	O
!=	O
NO_MOVE	O
)	O
{	O
int	O
dd	int
=	O
replacement_map	array
[	O
from	int
]	O
;	O
if	O
(	O
0	int
)	O
{	O
ASSERT1	O
(	O
dd	int
==	O
to	int
||	O
to	int
==	O
replacement_map	array
[	O
dd	int
]	O
,	O
from	int
)	O
;	O
}	O
return	O
;	O
}	O
TRACE	O
(	O
"Move at %1m is replaced by %1m.\n"	pointer
,	O
from	int
,	O
to	int
)	O
;	O
if	O
(	O
cc	int
==	O
from	int
)	O
{	O
gprintf	function
(	O
"Cyclic point redistribution detected.\n"	pointer
)	O
;	O
ASSERT1	O
(	O
0	int
,	O
from	int
)	O
;	O
}	O
if	O
(	O
cc	int
!=	O
NO_MOVE	O
)	O
replacement_map	array
[	O
from	int
]	O
=	O
cc	int
;	O
else	O
replacement_map	array
[	O
from	int
]	O
=	O
to	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
&&	O
replacement_map	array
[	O
pos	int
]	O
==	O
from	int
)	O
replacement_map	array
[	O
pos	int
]	O
=	O
replacement_map	array
[	O
from	int
]	O
;	O
}	O
}	O
void	O
get_saved_worms	function
(	O
int	O
pos	int
,	O
signed	O
char	O
saved	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
memset	function
(	O
saved	array
,	O
0	int
,	O
sizeof	O
(	O
saved	array
[	O
0	int
]	O
)	O
*	O
BOARDMAX	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
int	O
what	int
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
what	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE	int
)	O
mark_string	function
(	O
worm	array
[	O
what	int
]	O
.	O
origin	int
,	O
saved	array
,	O
1	int
)	O
;	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_LOSS	int
)	O
{	O
int	O
origin	int
=	O
dragon	int
[	O
what	int
]	O
.	O
origin	int
;	O
int	O
kworm	int
=	O
worm	array
[	O
what	int
]	O
.	O
origin	int
;	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
ii	int
]	O
)	O
&&	O
dragon	int
[	O
ii	int
]	O
.	O
origin	int
==	O
origin	int
&&	O
worm	array
[	O
ii	int
]	O
.	O
origin	int
!=	O
kworm	int
)	O
mark_string	function
(	O
worm	array
[	O
ii	int
]	O
.	O
origin	int
,	O
saved	array
,	O
1	int
)	O
;	O
}	O
}	O
}	O
void	O
mark_changed_dragon	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
affected	int
,	O
int	O
affected2	int
,	O
int	O
move_reason_type	int
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
,	O
float	O
*	O
effective_size	float
)	O
{	O
int	O
ii	int
;	O
signed	O
char	O
new_status	char
=	O
INFLUENCE_SAVED_STONE	int
;	O
int	O
result_to_beat	int
=	O
0	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
affected	int
]	O
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
=	O
0.0	int
;	O
switch	O
(	O
move_reason_type	int
)	O
{	O
case	O
OWL_ATTACK_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
ASSERT1	O
(	O
board	pointer
[	O
affected	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
new_status	char
=	O
0	int
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
=	O
dragon	int
[	O
affected	int
]	O
.	O
effective_size	float
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE	int
:	O
ASSERT1	O
(	O
board	pointer
[	O
affected	int
]	O
==	O
color	int
,	O
pos	int
)	O
;	O
result_to_beat	int
=	O
WIN	int
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
ASSERT1	O
(	O
board	pointer
[	O
affected	int
]	O
==	O
color	int
,	O
pos	int
)	O
;	O
result_to_beat	int
=	O
KO_A	int
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
ASSERT1	O
(	O
board	pointer
[	O
affected	int
]	O
==	O
color	int
,	O
pos	int
)	O
;	O
result_to_beat	int
=	O
KO_B	int
;	O
break	O
;	O
case	O
OWL_ATTACK_MOVE_GAIN	int
:	O
ASSERT1	O
(	O
board	pointer
[	O
affected	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
new_status	char
=	O
0	int
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
=	O
worm	array
[	O
affected2	int
]	O
.	O
effective_size	float
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_LOSS	int
:	O
ASSERT1	O
(	O
board	pointer
[	O
affected	int
]	O
==	O
color	int
,	O
pos	int
)	O
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
=	O
dragon	int
[	O
affected	int
]	O
.	O
effective_size	float
-	O
worm	array
[	O
affected2	int
]	O
.	O
effective_size	float
;	O
result_to_beat	int
=	O
WIN	int
;	O
break	O
;	O
case	O
SEMEAI_MOVE	int
:	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
affected	int
]	O
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
board	pointer
[	O
affected	int
]	O
==	O
color	int
)	O
result_to_beat	int
=	O
WIN	int
;	O
else	O
{	O
new_status	char
=	O
0	int
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
=	O
dragon	int
[	O
affected	int
]	O
.	O
effective_size	float
;	O
}	O
break	O
;	O
default	O
:	O
ASSERT1	O
(	O
0	int
,	O
pos	int
)	O
;	O
}	O
if	O
(	O
move_reason_type	int
==	O
OWL_ATTACK_MOVE_GAIN	int
)	O
mark_changed_string	function
(	O
affected2	int
,	O
safe_stones	array
,	O
strength	array
,	O
new_status	char
)	O
;	O
else	O
{	O
for	O
(	O
ii	int
=	O
first_worm_in_dragon	function
(	O
affected	int
)	O
;	O
ii	int
!=	O
NO_MOVE	O
;	O
ii	int
=	O
next_worm_in_dragon	function
(	O
ii	int
)	O
)	O
if	O
(	O
new_status	char
==	O
0	int
)	O
mark_changed_string	function
(	O
ii	int
,	O
safe_stones	array
,	O
strength	array
,	O
new_status	char
)	O
;	O
else	O
{	O
int	O
worm_is_safe	int
=	O
0	int
;	O
if	O
(	O
worm	array
[	O
ii	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
==	O
NO_MOVE	O
||	O
defense_move_reason_known	function
(	O
pos	int
,	O
ii	int
)	O
)	O
worm_is_safe	int
=	O
1	int
;	O
else	O
if	O
(	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
"mark-changed-dragon"	pointer
,	O
ii	int
)	O
)	O
{	O
if	O
(	O
REVERSE_RESULT	O
(	O
attack	function
(	O
ii	int
,	O
NULL	O
)	O
)	O
>=	O
result_to_beat	int
)	O
worm_is_safe	int
=	O
1	int
;	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
worm_is_safe	int
||	O
move_reason_type	int
==	O
SEMEAI_MOVE	int
)	O
{	O
mark_changed_string	function
(	O
ii	int
,	O
safe_stones	array
,	O
strength	array
,	O
new_status	char
)	O
;	O
if	O
(	O
effective_size	float
)	O
*	O
effective_size	float
+=	O
worm	array
[	O
ii	int
]	O
.	O
effective_size	float
;	O
}	O
}	O
if	O
(	O
move_reason_type	int
==	O
OWL_DEFEND_MOVE_LOSS	int
)	O
{	O
new_status	char
=	O
0	int
;	O
mark_changed_string	function
(	O
affected2	int
,	O
safe_stones	array
,	O
strength	array
,	O
new_status	char
)	O
;	O
}	O
}	O
}	O
void	O
mark_changed_string	function
(	O
int	O
affected	int
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
,	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
new_status	char
)	O
{	O
float	O
new_strength	float
;	O
int	O
ii	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
affected	int
]	O
)	O
,	O
affected	int
)	O
;	O
if	O
(	O
new_status	char
==	O
0	int
)	O
new_strength	float
=	O
0.0	int
;	O
else	O
{	O
gg_assert	O
(	O
new_status	char
==	O
INFLUENCE_SAVED_STONE	int
)	O
;	O
new_strength	float
=	O
DEFAULT_STRENGTH	int
;	O
}	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
==	O
board	pointer
[	O
affected	int
]	O
&&	O
same_string	function
(	O
ii	int
,	O
affected	int
)	O
)	O
{	O
strength	array
[	O
ii	int
]	O
=	O
new_strength	float
;	O
safe_stones	array
[	O
ii	int
]	O
=	O
new_status	char
;	O
}	O
}	O
void	O
get_saved_dragons	function
(	O
int	O
pos	int
,	O
signed	O
char	O
saved	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
memset	function
(	O
saved	array
,	O
0	int
,	O
sizeof	O
(	O
saved	array
[	O
0	int
]	O
)	O
*	O
BOARDMAX	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
int	O
what	int
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
what	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE	int
)	O
mark_dragon	function
(	O
what	int
,	O
saved	array
,	O
1	int
)	O
;	O
}	O
}	O
void	O
mark_safe_stones	function
(	O
int	O
color	int
,	O
int	O
move_pos	int
,	O
const	O
signed	O
char	O
saved_dragons	array
[	O
BOARDMAX	O
]	O
,	O
const	O
signed	O
char	O
saved_worms	array
[	O
BOARDMAX	O
]	O
,	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
==	O
DEAD	int
||	O
(	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array
[	O
pos	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
)	O
safe_stones	array
[	O
pos	int
]	O
=	O
0	int
;	O
else	O
safe_stones	array
[	O
pos	int
]	O
=	O
SAFE_STONE	int
;	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
(	O
worm	array
[	O
pos	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
(	O
worm	array
[	O
pos	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
||	O
!	O
saved_worms	array
[	O
pos	int
]	O
)	O
)	O
||	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
safe_stones	array
[	O
pos	int
]	O
=	O
0	int
;	O
else	O
if	O
(	O
saved_dragons	array
[	O
pos	int
]	O
)	O
safe_stones	array
[	O
pos	int
]	O
=	O
OWL_SAVED_STONE	int
;	O
else	O
if	O
(	O
dragon	int
[	O
pos	int
]	O
.	O
status	enum
==	O
CRITICAL	int
)	O
safe_stones	array
[	O
pos	int
]	O
=	O
0	int
;	O
else	O
safe_stones	array
[	O
pos	int
]	O
=	O
SAFE_STONE	int
;	O
}	O
else	O
safe_stones	array
[	O
pos	int
]	O
=	O
0	int
;	O
}	O
safe_stones	array
[	O
move_pos	int
]	O
=	O
move	pointer
[	O
move_pos	int
]	O
.	O
move_safety	int
&&	O
safe_move	function
(	O
move_pos	int
,	O
color	int
)	O
==	O
WIN	int
;	O
}	O
int	O
list_move_reasons	function
(	O
FILE	struct
*	O
out	pointer
,	O
int	O
move_pos	int
)	O
{	O
int	O
m	int
;	O
int	O
n	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
reason1	int
;	O
int	O
reason2	int
;	O
int	O
aa	int
=	O
NO_MOVE	O
;	O
int	O
bb	int
=	O
NO_MOVE	O
;	O
int	O
worm1	int
=	O
-	O
1	int
;	O
int	O
worm2	int
=	O
-	O
1	int
;	O
int	O
num_move_reasons	int
=	O
0	int
;	O
gprintf	function
(	O
"\nMove reasons:\n"	pointer
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
for	O
(	O
m	int
=	O
board_size	int
-	O
1	int
;	O
m	int
>=	O
0	int
;	O
m	int
--	O
)	O
{	O
pos	int
=	O
POS	O
(	O
m	int
,	O
n	int
)	O
;	O
if	O
(	O
move_pos	int
!=	O
NO_MOVE	O
&&	O
move_pos	int
!=	O
pos	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
num_move_reasons	int
++	O
;	O
switch	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
ATTACK_MOVE	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m attacks %1m%s\n"	pointer
,	O
pos	int
,	O
aa	int
,	O
(	O
worm	array
[	O
aa	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
?	O
" (defenseless)"	pointer
:	O
""	pointer
)	O
;	O
break	O
;	O
case	O
ATTACK_MOVE_GOOD_KO	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m attacks %1m%s with good ko\n"	pointer
,	O
pos	int
,	O
aa	int
,	O
(	O
worm	array
[	O
aa	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
?	O
" (defenseless)"	pointer
:	O
""	pointer
)	O
;	O
break	O
;	O
case	O
ATTACK_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m attacks %1m%s with bad ko\n"	pointer
,	O
pos	int
,	O
aa	int
,	O
(	O
worm	array
[	O
aa	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
?	O
" (defenseless)"	pointer
:	O
""	pointer
)	O
;	O
break	O
;	O
case	O
DEFEND_MOVE	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m defends %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
DEFEND_MOVE_GOOD_KO	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m defends %1m with good ko\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
DEFEND_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m defends %1m with bad ko\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
ATTACK_THREAT	O
:	O
case	O
DEFEND_THREAT	O
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_THREAT	O
)	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m threatens to attack %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_THREAT	O
)	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m threatens to defend %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
UNCERTAIN_OWL_DEFENSE	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
board	pointer
[	O
aa	int
]	O
==	O
current_color	int
)	O
gfprintf	function
(	O
out	pointer
,	O
"%1m found alive but not certainly, %1m defends it again\n"	pointer
,	O
aa	int
,	O
pos	int
)	O
;	O
else	O
gfprintf	function
(	O
out	pointer
,	O
"%1m found dead but not certainly, %1m attacks it again\n"	pointer
,	O
aa	int
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
CONNECT_MOVE	int
:	O
case	O
CUT_MOVE	int
:	O
worm1	int
=	O
conn_worm1	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
;	O
worm2	int
=	O
conn_worm2	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
CONNECT_MOVE	int
)	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m connects %1m and %1m\n"	pointer
,	O
pos	int
,	O
worm1	int
,	O
worm2	int
)	O
;	O
else	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m cuts %1m and %1m\n"	pointer
,	O
pos	int
,	O
worm1	int
,	O
worm2	int
)	O
;	O
break	O
;	O
case	O
ANTISUJI_MOVE	int
:	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m is an antisuji\n"	pointer
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
SEMEAI_MOVE	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m wins semeai for %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
SEMEAI_THREAT	O
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m threatens to win semeai for %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
EITHER_MOVE	int
:	O
reason1	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
reason1	int
;	O
reason2	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
reason2	int
;	O
worm1	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
worm2	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m either %s %1m or %s %1m\n"	pointer
,	O
pos	int
,	O
reason1	int
==	O
ATTACK_STRING	int
?	O
"attacks"	pointer
:	O
"defends"	pointer
,	O
worm1	int
,	O
reason2	int
==	O
ATTACK_STRING	int
?	O
"attacks"	pointer
:	O
"defends"	pointer
,	O
worm2	int
)	O
;	O
break	O
;	O
case	O
ALL_MOVE	int
:	O
reason1	int
=	O
all_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
reason1	int
;	O
reason2	int
=	O
all_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
reason2	int
;	O
worm1	int
=	O
all_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
worm2	int
=	O
all_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m both %s %1m and %s %1m\n"	pointer
,	O
pos	int
,	O
reason1	int
==	O
ATTACK_STRING	int
?	O
"attacks"	pointer
:	O
"defends"	pointer
,	O
worm1	int
,	O
reason2	int
==	O
ATTACK_STRING	int
?	O
"attacks"	pointer
:	O
"defends"	pointer
,	O
worm2	int
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_MOVE	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m owl-attacks %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m owl-attacks %1m with good ko\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m owl-attacks %1m with bad ko\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_MOVE_GAIN	int
:	O
aa	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
bb	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m owl-attacks %1m (captures %1m)\n"	pointer
,	O
pos	int
,	O
aa	int
,	O
bb	int
)	O
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m owl-defends %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m owl-defends %1m with good ko\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m owl-defends %1m with bad ko\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_DEFEND_MOVE_LOSS	int
:	O
aa	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
bb	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m owl-defends %1m (loses %1m)\n"	pointer
,	O
pos	int
,	O
aa	int
,	O
bb	int
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_THREAT	O
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m owl-threatens to attack %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_DEFEND_THREAT	O
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m owl-threatens to defend %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_PREVENT_THREAT	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m owl-prevents a threat to attack or defend %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
EXPAND_TERRITORY_MOVE	int
:	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m expands territory\n"	pointer
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
EXPAND_MOYO_MOVE	int
:	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m expands moyo\n"	pointer
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
INVASION_MOVE	int
:	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m is an invasion\n"	pointer
,	O
pos	int
)	O
;	O
break	O
;	O
case	O
STRATEGIC_ATTACK_MOVE	int
:	O
case	O
STRATEGIC_DEFEND_MOVE	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
STRATEGIC_ATTACK_MOVE	int
)	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m strategically attacks %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
else	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m strategically defends %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
MY_ATARI_ATARI_MOVE	int
:	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m captures something\n"	pointer
,	O
pos	int
)	O
;	O
case	O
YOUR_ATARI_ATARI_MOVE	int
:	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m defends against combination attack\n"	pointer
,	O
pos	int
)	O
;	O
}	O
}	O
if	O
(	O
k	int
>	O
0	int
&&	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
==	O
0	int
)	O
gfprintf	function
(	O
out	pointer
,	O
"Move at %1m strategically or tactically unsafe\n"	pointer
,	O
pos	int
)	O
;	O
}	O
return	O
num_move_reasons	int
;	O
}	O
static	O
struct	O
discard_rule	struct
discard_rules	array
[	O
]	O
=	O
{	O
{	O
{	O
ATTACK_MOVE	int
,	O
ATTACK_MOVE_GOOD_KO	int
,	O
ATTACK_MOVE_BAD_KO	int
,	O
ATTACK_THREAT	O
,	O
DEFEND_MOVE	int
,	O
DEFEND_MOVE_GOOD_KO	int
,	O
DEFEND_MOVE_BAD_KO	int
,	O
DEFEND_THREAT	O
,	O
-	O
1	int
}	O
,	O
owl_move_vs_worm_known	function
,	O
TERRITORY_REDUNDANT	int
,	O
"  %1m: 0.0 - (threat of) attack/defense of %1m (owl attack/defense as well)\n"	pointer
}	O
,	O
{	O
{	O
SEMEAI_MOVE	int
,	O
SEMEAI_THREAT	O
,	O
-	O
1	int
}	O
,	O
owl_move_reason_known	function
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - (threat to) win semeai involving %1m (owl move as well)\n"	pointer
}	O
,	O
{	O
{	O
SEMEAI_MOVE	int
,	O
SEMEAI_THREAT	O
,	O
-	O
1	int
}	O
,	O
tactical_move_vs_whole_dragon_known	function
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - (threat to) win semeai involving %1m (tactical move as well)\n"	pointer
}	O
,	O
{	O
{	O
EITHER_MOVE	int
,	O
-	O
1	int
}	O
,	O
either_worm_attackable	function
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - 'attack either' is redundant at %1m (direct att./def. as well)\n"	pointer
}	O
,	O
{	O
{	O
ALL_MOVE	int
,	O
-	O
1	int
}	O
,	O
one_of_both_attackable	function
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - 'defend both' is redundant at %1m (direct att./def. as well)\n"	pointer
}	O
,	O
{	O
{	O
ATTACK_THREAT	O
,	O
DEFEND_THREAT	O
,	O
-	O
1	int
}	O
,	O
concerns_inessential_worm	function
,	O
TERRITORY_REDUNDANT	int
,	O
"  %1m: 0.0 - attack/defense threat of %1m (inessential)\n"	pointer
}	O
,	O
{	O
{	O
OWL_ATTACK_THREAT	O
,	O
UNCERTAIN_OWL_DEFENSE	int
,	O
-	O
1	int
}	O
,	O
concerns_inessential_dragon	function
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - (uncertain) owl attack/defense of %1m (inessential)\n"	pointer
}	O
,	O
{	O
{	O
ATTACK_MOVE	int
,	O
ATTACK_MOVE_GOOD_KO	int
,	O
ATTACK_MOVE_BAD_KO	int
,	O
DEFEND_MOVE	int
,	O
DEFEND_MOVE_GOOD_KO	int
,	O
DEFEND_MOVE_BAD_KO	int
,	O
-	O
1	int
}	O
,	O
move_is_marked_unsafe	function
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - tactical move vs %1m (unsafe move)\n"	pointer
}	O
,	O
{	O
{	O
OWL_ATTACK_MOVE	int
,	O
OWL_ATTACK_MOVE_GOOD_KO	int
,	O
OWL_ATTACK_MOVE_BAD_KO	int
,	O
OWL_DEFEND_MOVE	int
,	O
OWL_DEFEND_MOVE_GOOD_KO	int
,	O
OWL_DEFEND_MOVE_BAD_KO	int
,	O
-	O
1	int
}	O
,	O
concerns_noncritical_dragon	function
,	O
REDUNDANT	O
,	O
"  %1m: 0.0 - owl move vs %1m (non-critical)\n"	pointer
}	O
,	O
{	O
{	O
-	O
1	int
}	O
,	O
NULL	O
,	O
0	int
,	O
""	pointer
}	O
}	O
;	O
void	O
discard_redundant_move_reasons	function
(	O
int	O
pos	int
)	O
{	O
int	O
k1	int
,	O
k2	int
;	O
int	O
l	int
;	O
for	O
(	O
k1	int
=	O
0	int
;	O
!	O
(	O
discard_rules	array
[	O
k1	int
]	O
.	O
reason_type	array
[	O
0	int
]	O
==	O
-	O
1	int
)	O
;	O
k1	int
++	O
)	O
{	O
for	O
(	O
k2	int
=	O
0	int
;	O
!	O
(	O
discard_rules	array
[	O
k1	int
]	O
.	O
reason_type	array
[	O
k2	int
]	O
==	O
-	O
1	int
)	O
;	O
k2	int
++	O
)	O
{	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
MAX_REASONS	int
;	O
l	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
l	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
discard_rules	array
[	O
k1	int
]	O
.	O
reason_type	array
[	O
k2	int
]	O
)	O
&&	O
(	O
discard_rules	array
[	O
k1	int
]	O
.	O
condition	pointer
(	O
pos	int
,	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
)	O
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
discard_rules	array
[	O
k1	int
]	O
.	O
trace_message	pointer
,	O
pos	int
,	O
get_pos	function
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
,	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
)	O
)	O
;	O
move_reasons	array
[	O
r	int
]	O
.	O
status	enum
|=	O
discard_rules	array
[	O
k1	int
]	O
.	O
flags	int
;	O
}	O
}	O
}	O
}	O
}	O
int	O
is_antisuji_move	function
(	O
int	O
pos	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ANTISUJI_MOVE	int
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
scale_randomness	function
(	O
int	O
pos	int
,	O
float	O
scaling	float
)	O
{	O
if	O
(	O
scaling	float
>	O
move	pointer
[	O
pos	int
]	O
.	O
randomness_scaling	float
)	O
move	pointer
[	O
pos	int
]	O
.	O
randomness_scaling	float
=	O
scaling	float
;	O
}	O
void	O
register_good_attack_threat	function
(	O
int	O
move	pointer
,	O
int	O
target	int
)	O
{	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
move	pointer
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
target	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
worm	array
[	O
target	int
]	O
.	O
color	int
)	O
,	O
move	pointer
)	O
;	O
target	int
=	O
worm	array
[	O
target	int
]	O
.	O
origin	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_ATTACK_THREATS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
known_good_attack_threats	array
[	O
move	pointer
]	O
[	O
k	int
]	O
==	O
target	int
)	O
break	O
;	O
if	O
(	O
known_good_attack_threats	array
[	O
move	pointer
]	O
[	O
k	int
]	O
==	O
NO_MOVE	O
)	O
{	O
known_good_attack_threats	array
[	O
move	pointer
]	O
[	O
k	int
]	O
=	O
target	int
;	O
break	O
;	O
}	O
}	O
}	O
int	O
is_known_good_attack_threat	function
(	O
int	O
move	pointer
,	O
int	O
target	int
)	O
{	O
int	O
k	int
;	O
ASSERT_ON_BOARD1	O
(	O
move	pointer
)	O
;	O
ASSERT_ON_BOARD1	O
(	O
target	int
)	O
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
worm	array
[	O
target	int
]	O
.	O
color	int
)	O
,	O
move	pointer
)	O
;	O
target	int
=	O
worm	array
[	O
target	int
]	O
.	O
origin	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_ATTACK_THREATS	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
known_good_attack_threats	array
[	O
move	pointer
]	O
[	O
k	int
]	O
==	O
target	int
)	O
return	O
1	int
;	O
if	O
(	O
known_good_attack_threats	array
[	O
move	pointer
]	O
[	O
k	int
]	O
==	O
NO_MOVE	O
)	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
register_known_safe_move	function
(	O
int	O
move	pointer
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
move	pointer
)	O
;	O
known_safe_moves	array
[	O
move	pointer
]	O
=	O
1	int
;	O
}	O
int	O
is_known_safe_move	function
(	O
int	O
move	pointer
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
move	pointer
)	O
;	O
return	O
known_safe_moves	array
[	O
move	pointer
]	O
;	O
}	O
