struct	O
check_instance	struct
{	O
char	O
*	O
name	pointer
;	O
grad_uint32_t	int
nas_ip	int
;	O
int	O
port	array
;	O
char	O
*	O
sid	pointer
;	O
grad_uint32_t	int
framed_ip	int
;	O
int	O
method	int
;	O
char	O
*	O
func	pointer
;	O
grad_envar_t	struct
*	O
args	pointer
;	O
char	O
*	O
nasname	pointer
;	O
struct	O
obstack	struct
stack	struct
;	O
int	O
timeout	int
;	O
int	O
result	pointer
;	O
}	O
;	O
char	O
*	O
slookup	function
(	O
struct	O
check_instance	struct
*	O
checkp	pointer
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
defval	pointer
)	O
{	O
return	O
grad_envar_lookup_str	function
(	O
checkp	pointer
->	O
args	pointer
,	O
name	pointer
,	O
defval	pointer
)	O
;	O
}	O
int	O
ilookup	function
(	O
struct	O
check_instance	struct
*	O
checkp	pointer
,	O
char	O
*	O
name	pointer
,	O
int	O
defval	pointer
)	O
{	O
return	O
grad_envar_lookup_int	function
(	O
checkp	pointer
->	O
args	pointer
,	O
name	pointer
,	O
defval	pointer
)	O
;	O
}	O
struct	O
check_instance	struct
*	O
create_instance	function
(	O
struct	O
check_instance	struct
*	O
cptr	pointer
,	O
grad_nas_t	struct
*	O
nas	int
,	O
struct	O
radutmp	struct
*	O
up	pointer
)	O
{	O
RADCK_TYPE	struct
*	O
radck_type	struct
;	O
if	O
(	O
(	O
radck_type	struct
=	O
find_radck_type	function
(	O
nas	int
->	O
nastype	array
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"unknown NAS type: %s (nas %s)"	pointer
)	O
,	O
nas	int
->	O
nastype	array
,	O
nas	int
->	O
shortname	array
)	O
;	O
return	O
NULL	O
;	O
}	O
cptr	pointer
->	O
name	pointer
=	O
up	pointer
->	O
orig_login	array
[	O
0	int
]	O
?	O
up	pointer
->	O
orig_login	array
:	O
up	pointer
->	O
login	array
;	O
cptr	pointer
->	O
port	array
=	O
up	pointer
->	O
nas_port	int
;	O
cptr	pointer
->	O
sid	pointer
=	O
up	pointer
->	O
session_id	array
;	O
cptr	pointer
->	O
framed_ip	int
=	O
ntohl	function
(	O
up	pointer
->	O
framed_address	int
)	O
;	O
cptr	pointer
->	O
nas_ip	int
=	O
ntohl	function
(	O
up	pointer
->	O
nas_address	int
)	O
;	O
cptr	pointer
->	O
result	pointer
=	O
-	O
1	int
;	O
cptr	pointer
->	O
timeout	int
=	O
0	int
;	O
cptr	pointer
->	O
nasname	pointer
=	O
nas	int
->	O
shortname	array
?	O
nas	int
->	O
shortname	array
:	O
nas	int
->	O
longname	array
;	O
cptr	pointer
->	O
method	int
=	O
radck_type	struct
->	O
method	int
;	O
cptr	pointer
->	O
args	pointer
=	O
grad_envar_merge_lists	function
(	O
(	O
grad_envar_t	struct
*	O
)	O
nas	int
->	O
args	pointer
,	O
radck_type	struct
->	O
args	pointer
)	O
;	O
cptr	pointer
->	O
func	pointer
=	O
slookup	function
(	O
cptr	pointer
,	O
"function"	pointer
,	O
NULL	O
)	O
;	O
obstack_init	O
(	O
&	O
cptr	pointer
->	O
stack	struct
)	O
;	O
return	O
cptr	pointer
;	O
}	O
void	O
free_instance	function
(	O
struct	O
check_instance	struct
*	O
cptr	pointer
)	O
{	O
obstack_free	function
(	O
&	O
cptr	pointer
->	O
stack	struct
,	O
NULL	O
)	O
;	O
grad_envar_free_list	function
(	O
&	O
cptr	pointer
->	O
args	pointer
)	O
;	O
}	O
int	O
compare	function
(	O
struct	O
check_instance	struct
*	O
checkp	pointer
,	O
char	O
*	O
str	pointer
)	O
{	O
grad_value_t	struct
val	array
;	O
if	O
(	O
rewrite_invoke	function
(	O
Integer	int
,	O
&	O
val	array
,	O
checkp	pointer
->	O
func	pointer
,	O
NULL	O
,	O
"ssis"	pointer
,	O
str	pointer
,	O
checkp	pointer
->	O
name	pointer
,	O
checkp	pointer
->	O
port	array
,	O
checkp	pointer
->	O
sid	pointer
)	O
)	O
return	O
-	O
1	int
;	O
return	O
val	array
.	O
datum	union
.	O
ival	int
;	O
}	O
char	O
*	O
checkrad_xlat_new	function
(	O
struct	O
check_instance	struct
*	O
checkp	pointer
,	O
char	O
*	O
template	pointer
)	O
{	O
grad_request_t	struct
*	O
req	pointer
;	O
char	O
*	O
str	pointer
;	O
req	pointer
=	O
grad_request_alloc	function
(	O
)	O
;	O
grad_avl_add_pair	function
(	O
&	O
req	pointer
->	O
avlist	pointer
,	O
grad_avp_create_string	function
(	O
DA_USER_NAME	int
,	O
checkp	pointer
->	O
name	pointer
)	O
)	O
;	O
grad_avl_add_pair	function
(	O
&	O
req	pointer
->	O
avlist	pointer
,	O
grad_avp_create_integer	function
(	O
DA_NAS_PORT_ID	int
,	O
checkp	pointer
->	O
port	array
)	O
)	O
;	O
grad_avl_add_pair	function
(	O
&	O
req	pointer
->	O
avlist	pointer
,	O
grad_avp_create_string	function
(	O
DA_ACCT_SESSION_ID	int
,	O
checkp	pointer
->	O
sid	pointer
)	O
)	O
;	O
grad_avl_add_pair	function
(	O
&	O
req	pointer
->	O
avlist	pointer
,	O
grad_avp_create_integer	function
(	O
DA_FRAMED_IP_ADDRESS	int
,	O
checkp	pointer
->	O
framed_ip	int
)	O
)	O
;	O
grad_avl_add_pair	function
(	O
&	O
req	pointer
->	O
avlist	pointer
,	O
grad_avp_create_integer	function
(	O
DA_NAS_IP_ADDRESS	int
,	O
checkp	pointer
->	O
nas_ip	int
)	O
)	O
;	O
str	pointer
=	O
util_xlate	function
(	O
&	O
checkp	pointer
->	O
stack	struct
,	O
template	pointer
,	O
req	pointer
)	O
;	O
grad_request_free	function
(	O
req	pointer
)	O
;	O
return	O
str	pointer
;	O
}	O
char	O
*	O
checkrad_xlat_old	function
(	O
struct	O
check_instance	struct
*	O
checkp	pointer
,	O
char	O
*	O
str	pointer
)	O
{	O
char	O
*	O
ptr	pointer
;	O
int	O
len	int
;	O
char	O
buf	pointer
[	O
24	int
]	O
;	O
while	O
(	O
*	O
str	pointer
)	O
{	O
if	O
(	O
*	O
str	pointer
==	O
'%'	O
)	O
{	O
switch	O
(	O
str	pointer
[	O
1	int
]	O
)	O
{	O
case	O
'u'	O
:	O
ptr	pointer
=	O
checkp	pointer
->	O
name	pointer
;	O
break	O
;	O
case	O
's'	O
:	O
ptr	pointer
=	O
checkp	pointer
->	O
sid	pointer
;	O
break	O
;	O
case	O
'd'	O
:	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"%lu"	pointer
,	O
strtol	function
(	O
checkp	pointer
->	O
sid	pointer
,	O
NULL	O
,	O
16	int
)	O
)	O
;	O
ptr	pointer
=	O
buf	pointer
;	O
break	O
;	O
case	O
'p'	O
:	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"%d"	pointer
,	O
checkp	pointer
->	O
port	array
)	O
;	O
ptr	pointer
=	O
buf	pointer
;	O
break	O
;	O
case	O
'P'	O
:	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"%d"	pointer
,	O
checkp	pointer
->	O
port	array
+	O
1	int
)	O
;	O
ptr	pointer
=	O
buf	pointer
;	O
break	O
;	O
case	O
'i'	O
:	O
grad_ip_iptostr	function
(	O
checkp	pointer
->	O
framed_ip	int
,	O
buf	pointer
)	O
;	O
ptr	pointer
=	O
buf	pointer
;	O
break	O
;	O
default	O
:	O
ptr	pointer
=	O
NULL	O
;	O
obstack_grow	O
(	O
&	O
checkp	pointer
->	O
stack	struct
,	O
str	pointer
,	O
2	int
)	O
;	O
}	O
if	O
(	O
ptr	pointer
)	O
{	O
len	int
=	O
strlen	function
(	O
ptr	pointer
)	O
;	O
obstack_grow	O
(	O
&	O
checkp	pointer
->	O
stack	struct
,	O
ptr	pointer
,	O
len	int
)	O
;	O
}	O
str	pointer
+=	O
2	int
;	O
}	O
else	O
{	O
obstack_1grow	O
(	O
&	O
checkp	pointer
->	O
stack	struct
,	O
*	O
str	pointer
)	O
;	O
str	pointer
++	O
;	O
}	O
}	O
obstack_1grow	O
(	O
&	O
checkp	pointer
->	O
stack	struct
,	O
0	int
)	O
;	O
return	O
obstack_finish	O
(	O
&	O
checkp	pointer
->	O
stack	struct
)	O
;	O
}	O
char	O
*	O
checkrad_xlat	function
(	O
struct	O
check_instance	struct
*	O
checkp	pointer
,	O
char	O
*	O
str	pointer
)	O
{	O
if	O
(	O
str	pointer
[	O
0	int
]	O
==	O
'='	O
)	O
return	O
checkrad_xlat_new	function
(	O
checkp	pointer
,	O
str	pointer
+	O
1	int
)	O
;	O
return	O
checkrad_xlat_old	function
(	O
checkp	pointer
,	O
str	pointer
)	O
;	O
}	O
static	O
int	O
converse	pointer
(	O
int	O
type	int
,	O
struct	O
snmp_session	struct
*	O
sp	pointer
,	O
struct	O
snmp_pdu	struct
*	O
pdu	pointer
,	O
void	O
*	O
closure	pointer
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
struct	O
snmp_var	struct
*	O
vlist	pointer
;	O
struct	O
check_instance	struct
*	O
checkp	pointer
=	O
(	O
struct	O
check_instance	struct
*	O
)	O
closure	pointer
;	O
char	O
buf	pointer
[	O
64	int
]	O
;	O
if	O
(	O
type	int
==	O
SNMP_CONV_TIMEOUT	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"timed out in waiting SNMP response from NAS %s"	pointer
)	O
,	O
checkp	pointer
->	O
nasname	pointer
)	O
;	O
checkp	pointer
->	O
timeout	int
++	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
type	int
!=	O
SNMP_CONV_RECV_MSG	int
)	O
return	O
1	int
;	O
for	O
(	O
vlist	pointer
=	O
pdu	pointer
->	O
var	pointer
;	O
rc	int
==	O
0	int
&&	O
vlist	pointer
;	O
vlist	pointer
=	O
vlist	pointer
->	O
next	pointer
)	O
switch	O
(	O
vlist	pointer
->	O
type	int
)	O
{	O
case	O
SMI_STRING	O
:	O
rc	int
=	O
compare	function
(	O
checkp	pointer
,	O
vlist	pointer
->	O
var_str	O
)	O
;	O
GRAD_DEBUG2	O
(	O
2	int
,	O
"(STRING) %s: %d"	pointer
,	O
vlist	pointer
->	O
var_str	O
,	O
rc	int
)	O
;	O
break	O
;	O
case	O
SMI_INTEGER	O
:	O
case	O
SMI_COUNTER32	O
:	O
case	O
SMI_COUNTER64	O
:	O
snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"%d"	pointer
,	O
vlist	pointer
->	O
var_int	O
)	O
;	O
rc	int
=	O
compare	function
(	O
checkp	pointer
,	O
buf	pointer
)	O
;	O
GRAD_DEBUG2	O
(	O
2	int
,	O
"(INT) %d: %d"	pointer
,	O
vlist	pointer
->	O
var_int	O
,	O
rc	int
)	O
;	O
break	O
;	O
case	O
SMI_IPADDRESS	O
:	O
grad_ip_iptostr	function
(	O
*	O
(	O
grad_uint32_t	int
*	O
)	O
vlist	pointer
->	O
var_int	O
,	O
buf	pointer
)	O
;	O
rc	int
=	O
compare	function
(	O
checkp	pointer
,	O
buf	pointer
)	O
;	O
GRAD_DEBUG2	O
(	O
2	int
,	O
"(IPADDR) %#x: %d"	pointer
,	O
*	O
(	O
grad_uint32_t	int
*	O
)	O
vlist	pointer
->	O
var_str	O
,	O
rc	int
)	O
;	O
break	O
;	O
}	O
checkp	pointer
->	O
result	pointer
=	O
rc	int
;	O
return	O
1	int
;	O
}	O
int	O
snmp_check	function
(	O
struct	O
check_instance	struct
*	O
checkp	pointer
,	O
grad_nas_t	struct
*	O
nas	int
)	O
{	O
int	O
rc	int
=	O
-	O
1	int
;	O
struct	O
snmp_pdu	struct
*	O
pdu	pointer
;	O
struct	O
snmp_session	struct
*	O
sp	pointer
;	O
struct	O
snmp_var	struct
*	O
var	pointer
;	O
char	O
*	O
community	struct
;	O
int	O
retries	int
;	O
int	O
timeout	int
;	O
char	O
*	O
peername	pointer
;	O
int	O
remote_port	short
;	O
oid_t	pointer
oid	pointer
;	O
char	O
*	O
snmp_oid	pointer
;	O
if	O
(	O
(	O
snmp_oid	pointer
=	O
slookup	function
(	O
checkp	pointer
,	O
"oid"	pointer
,	O
NULL	O
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"no snmp_oid"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
snmp_oid	pointer
=	O
checkrad_xlat	function
(	O
checkp	pointer
,	O
snmp_oid	pointer
)	O
;	O
if	O
(	O
!	O
snmp_oid	pointer
)	O
return	O
-	O
1	int
;	O
oid	pointer
=	O
oid_create_from_string	function
(	O
snmp_oid	pointer
)	O
;	O
if	O
(	O
!	O
oid	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"invalid OID: %s"	pointer
)	O
,	O
snmp_oid	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
community	struct
=	O
slookup	function
(	O
checkp	pointer
,	O
"password"	pointer
,	O
NULL	O
)	O
)	O
==	O
NULL	O
&&	O
(	O
community	struct
=	O
slookup	function
(	O
checkp	pointer
,	O
"community"	pointer
,	O
NULL	O
)	O
)	O
==	O
NULL	O
)	O
community	struct
=	O
"public"	pointer
;	O
retries	int
=	O
ilookup	function
(	O
checkp	pointer
,	O
"retries"	pointer
,	O
3	int
)	O
;	O
timeout	int
=	O
ilookup	function
(	O
checkp	pointer
,	O
"timeout"	pointer
,	O
2	int
)	O
;	O
peername	pointer
=	O
slookup	function
(	O
checkp	pointer
,	O
"host"	pointer
,	O
nas	int
->	O
longname	array
)	O
;	O
remote_port	short
=	O
ilookup	function
(	O
checkp	pointer
,	O
"port"	pointer
,	O
161	int
)	O
;	O
sp	pointer
=	O
snmp_session_create	function
(	O
community	struct
,	O
peername	pointer
,	O
remote_port	short
,	O
converse	pointer
,	O
checkp	pointer
)	O
;	O
if	O
(	O
!	O
sp	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't create snmp session: %s"	pointer
)	O
,	O
snmp_strerror	function
(	O
snmp_errno	O
)	O
)	O
;	O
snmp_free	function
(	O
oid	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
snmp_session_open	function
(	O
sp	pointer
,	O
myip	int
,	O
0	int
,	O
timeout	int
,	O
retries	int
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't open snmp session: %s"	pointer
)	O
,	O
snmp_strerror	function
(	O
snmp_errno	O
)	O
)	O
;	O
snmp_free	function
(	O
oid	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
pdu	pointer
=	O
snmp_pdu_create	function
(	O
SNMP_PDU_GET	O
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't create SNMP PDU: %s"	pointer
)	O
,	O
snmp_strerror	function
(	O
snmp_errno	O
)	O
)	O
;	O
snmp_free	function
(	O
oid	pointer
)	O
;	O
snmp_session_close	function
(	O
sp	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
var	pointer
=	O
snmp_var_create	function
(	O
oid	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"can't create SNMP PDU: %s"	pointer
)	O
,	O
snmp_strerror	function
(	O
snmp_errno	O
)	O
)	O
;	O
snmp_free	function
(	O
oid	pointer
)	O
;	O
snmp_session_close	function
(	O
sp	pointer
)	O
;	O
snmp_pdu_free	function
(	O
pdu	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
snmp_pdu_add_var	function
(	O
pdu	pointer
,	O
var	pointer
)	O
;	O
snmp_free	function
(	O
oid	pointer
)	O
;	O
GRAD_DEBUG4	O
(	O
1	int
,	O
"snmpget: %s:%d %s %s"	pointer
,	O
peername	pointer
,	O
remote_port	short
,	O
community	struct
,	O
snmp_oid	pointer
)	O
;	O
checkp	pointer
->	O
result	pointer
=	O
rc	int
;	O
snmp_query	function
(	O
sp	pointer
,	O
pdu	pointer
)	O
;	O
rc	int
=	O
checkp	pointer
->	O
result	pointer
;	O
snmp_session_close	function
(	O
sp	pointer
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"result: %d"	pointer
,	O
rc	int
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
jmp_buf	array
to_env	array
;	O
static	O
RETSIGTYPE	void
alrm_handler	function
(	O
)	O
{	O
longjmp	function
(	O
to_env	array
,	O
1	int
)	O
;	O
}	O
int	O
finger_check	function
(	O
struct	O
check_instance	struct
*	O
checkp	pointer
,	O
grad_nas_t	struct
*	O
nas	int
)	O
{	O
char	O
*	O
arg	pointer
;	O
char	O
namebuf	array
[	O
RUT_NAMESIZE	int
+	O
1	int
]	O
;	O
int	O
namelen	int
;	O
register	O
FILE	struct
*	O
fp	pointer
;	O
register	O
int	O
c	pointer
,	O
lastc	int
;	O
struct	O
hostent	struct
*	O
hp	pointer
;	O
struct	O
sockaddr_in	struct
sin	struct
;	O
int	O
i	int
,	O
port	array
;	O
int	O
s	pointer
;	O
struct	O
iovec	struct
iov	array
[	O
3	int
]	O
;	O
struct	O
msghdr	struct
msg	pointer
;	O
int	O
found	int
=	O
0	int
;	O
char	O
*	O
peername	pointer
;	O
char	O
*	O
ptr	pointer
;	O
RETSIGTYPE	void
(	O
*	O
handler	pointer
)	O
(	O
)	O
=	O
SIG_IGN	O
;	O
unsigned	O
int	O
to	pointer
;	O
arg	pointer
=	O
checkrad_xlat	function
(	O
checkp	pointer
,	O
slookup	function
(	O
checkp	pointer
,	O
"arg"	pointer
,	O
"%u"	pointer
)	O
)	O
;	O
if	O
(	O
!	O
arg	pointer
)	O
return	O
-	O
1	int
;	O
ptr	pointer
=	O
arg	pointer
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
RUT_NAMESIZE	int
&&	O
*	O
ptr	pointer
;	O
++	O
ptr	pointer
,	O
++	O
i	int
)	O
namebuf	array
[	O
i	int
]	O
=	O
*	O
ptr	pointer
;	O
namebuf	array
[	O
i	int
]	O
=	O
0	int
;	O
namelen	int
=	O
i	int
;	O
peername	pointer
=	O
slookup	function
(	O
checkp	pointer
,	O
"host"	pointer
,	O
nas	int
->	O
longname	array
)	O
;	O
if	O
(	O
!	O
(	O
hp	pointer
=	O
gethostbyname	function
(	O
peername	pointer
)	O
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"unknown host: %s"	pointer
)	O
,	O
peername	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
(	O
port	array
=	O
ilookup	function
(	O
checkp	pointer
,	O
"port"	pointer
,	O
0	int
)	O
)	O
==	O
0	int
)	O
{	O
struct	O
servent	struct
*	O
sp	pointer
;	O
if	O
(	O
sp	pointer
=	O
getservbyname	function
(	O
"finger"	pointer
,	O
"tcp"	pointer
)	O
)	O
port	array
=	O
sp	pointer
->	O
s_port	int
;	O
else	O
port	array
=	O
htons	function
(	O
79	int
)	O
;	O
}	O
else	O
port	array
=	O
htons	function
(	O
port	array
)	O
;	O
sin	struct
.	O
sin_family	short
=	O
hp	pointer
->	O
h_addrtype	int
;	O
memcpy	function
(	O
&	O
sin	struct
.	O
sin_addr	struct
,	O
hp	pointer
->	O
h_addr	O
,	O
MIN	O
(	O
hp	pointer
->	O
h_length	int
,	O
sizeof	O
(	O
sin	struct
.	O
sin_addr	struct
)	O
)	O
)	O
;	O
sin	struct
.	O
sin_port	short
=	O
port	array
;	O
if	O
(	O
(	O
s	pointer
=	O
socket	function
(	O
hp	pointer
->	O
h_addrtype	int
,	O
SOCK_STREAM	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"socket"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
GRAD_DEBUG3	O
(	O
1	int
,	O
"finger %s@%s:%d"	pointer
,	O
namebuf	array
,	O
hp	pointer
->	O
h_name	pointer
,	O
ntohs	function
(	O
port	array
)	O
)	O
;	O
memset	function
(	O
&	O
msg	pointer
,	O
0	int
,	O
sizeof	O
(	O
msg	pointer
)	O
)	O
;	O
msg	pointer
.	O
msg_name	pointer
=	O
(	O
void	O
*	O
)	O
&	O
sin	struct
;	O
msg	pointer
.	O
msg_namelen	int
=	O
sizeof	O
sin	struct
;	O
msg	pointer
.	O
msg_iov	pointer
=	O
iov	array
;	O
msg	pointer
.	O
msg_iovlen	long
=	O
0	int
;	O
iov	array
[	O
msg	pointer
.	O
msg_iovlen	long
]	O
.	O
iov_base	pointer
=	O
namebuf	array
;	O
iov	array
[	O
msg	pointer
.	O
msg_iovlen	long
++	O
]	O
.	O
iov_len	long
=	O
namelen	int
;	O
iov	array
[	O
msg	pointer
.	O
msg_iovlen	long
]	O
.	O
iov_base	pointer
=	O
"\r\n"	pointer
;	O
iov	array
[	O
msg	pointer
.	O
msg_iovlen	long
++	O
]	O
.	O
iov_len	long
=	O
2	int
;	O
if	O
(	O
ilookup	function
(	O
checkp	pointer
,	O
"tcp"	pointer
,	O
1	int
)	O
&&	O
connect	function
(	O
s	pointer
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
sin	struct
,	O
sizeof	O
(	O
sin	struct
)	O
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"connect"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
sendmsg	function
(	O
s	pointer
,	O
&	O
msg	pointer
,	O
0	int
)	O
<	O
0	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"sendmsg"	pointer
)	O
;	O
close	pointer
(	O
s	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
lastc	int
=	O
0	int
;	O
if	O
(	O
(	O
fp	pointer
=	O
fdopen	function
(	O
s	pointer
,	O
"r"	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
setjmp	function
(	O
to_env	array
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"timed out in waiting for finger response from NAS %s"	pointer
)	O
,	O
checkp	pointer
->	O
nasname	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
alarm	function
(	O
0	int
)	O
;	O
grad_set_signal	function
(	O
SIGALRM	int
,	O
handler	pointer
)	O
;	O
return	O
checkp	pointer
->	O
result	pointer
=	O
-	O
1	int
;	O
}	O
to	pointer
=	O
ilookup	function
(	O
checkp	pointer
,	O
"timeout"	pointer
,	O
10	int
)	O
;	O
handler	pointer
=	O
grad_set_signal	function
(	O
SIGALRM	int
,	O
alrm_handler	function
)	O
;	O
alarm	function
(	O
to	pointer
)	O
;	O
while	O
(	O
(	O
c	pointer
=	O
getc	function
(	O
fp	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	pointer
==	O
0x0d	int
)	O
{	O
if	O
(	O
lastc	int
==	O
'\r'	O
)	O
continue	O
;	O
c	pointer
=	O
'\n'	O
;	O
lastc	int
=	O
'\r'	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
isprint	function
(	O
c	pointer
)	O
&&	O
!	O
isspace	function
(	O
c	pointer
)	O
)	O
{	O
c	pointer
&=	O
0x7f	int
;	O
c	pointer
|=	O
0x40	int
;	O
}	O
if	O
(	O
lastc	int
!=	O
'\r'	O
||	O
c	pointer
!=	O
'\n'	O
)	O
lastc	int
=	O
c	pointer
;	O
else	O
{	O
lastc	int
=	O
'\n'	O
;	O
continue	O
;	O
}	O
}	O
obstack_1grow	O
(	O
&	O
checkp	pointer
->	O
stack	struct
,	O
c	pointer
)	O
;	O
if	O
(	O
c	pointer
==	O
'\n'	O
)	O
{	O
to	pointer
=	O
alarm	function
(	O
0	int
)	O
;	O
grad_set_signal	function
(	O
SIGALRM	int
,	O
handler	pointer
)	O
;	O
obstack_1grow	O
(	O
&	O
checkp	pointer
->	O
stack	struct
,	O
0	int
)	O
;	O
ptr	pointer
=	O
obstack_finish	O
(	O
&	O
checkp	pointer
->	O
stack	struct
)	O
;	O
GRAD_DEBUG1	O
(	O
2	int
,	O
"got : %s"	pointer
,	O
ptr	pointer
)	O
;	O
found	int
=	O
compare	function
(	O
checkp	pointer
,	O
ptr	pointer
)	O
;	O
obstack_free	function
(	O
&	O
checkp	pointer
->	O
stack	struct
,	O
ptr	pointer
)	O
;	O
if	O
(	O
found	int
)	O
break	O
;	O
grad_set_signal	function
(	O
SIGALRM	int
,	O
alrm_handler	function
)	O
;	O
alarm	function
(	O
to	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
found	int
&&	O
lastc	int
!=	O
'\n'	O
)	O
{	O
alarm	function
(	O
0	int
)	O
;	O
grad_set_signal	function
(	O
SIGALRM	int
,	O
handler	pointer
)	O
;	O
obstack_1grow	O
(	O
&	O
checkp	pointer
->	O
stack	struct
,	O
'\n'	O
)	O
;	O
obstack_1grow	O
(	O
&	O
checkp	pointer
->	O
stack	struct
,	O
0	int
)	O
;	O
GRAD_DEBUG1	O
(	O
2	int
,	O
"got : %s"	pointer
,	O
ptr	pointer
)	O
;	O
ptr	pointer
=	O
obstack_finish	O
(	O
&	O
checkp	pointer
->	O
stack	struct
)	O
;	O
found	int
=	O
compare	function
(	O
checkp	pointer
,	O
ptr	pointer
)	O
;	O
}	O
if	O
(	O
ferror	function
(	O
fp	pointer
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
"finger"	pointer
)	O
;	O
}	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
alarm	function
(	O
0	int
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"result: %d"	pointer
,	O
found	int
)	O
;	O
checkp	pointer
->	O
result	pointer
=	O
found	int
;	O
return	O
found	int
;	O
}	O
int	O
ext_check	function
(	O
struct	O
check_instance	struct
*	O
checkp	pointer
,	O
grad_nas_t	struct
*	O
nas	int
)	O
{	O
char	O
*	O
s	pointer
,	O
*	O
path	pointer
;	O
int	O
rc	int
;	O
s	pointer
=	O
slookup	function
(	O
checkp	pointer
,	O
"path"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"path variable not set"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
path	pointer
=	O
checkrad_xlat_new	function
(	O
checkp	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
!	O
path	pointer
)	O
return	O
-	O
1	int
;	O
rc	int
=	O
radius_exec_command	function
(	O
path	pointer
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
case	O
1	int
:	O
return	O
rc	int
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
guile_check	function
(	O
struct	O
check_instance	struct
*	O
checkp	pointer
,	O
grad_nas_t	struct
*	O
nas	int
)	O
{	O
char	O
*	O
s	pointer
,	O
*	O
expr	pointer
;	O
int	O
rc	int
;	O
s	pointer
=	O
slookup	function
(	O
checkp	pointer
,	O
"expr"	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
s	pointer
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"expr variable not set"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
expr	pointer
=	O
checkrad_xlat_new	function
(	O
checkp	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
!	O
expr	pointer
)	O
return	O
-	O
1	int
;	O
rc	int
=	O
scheme_eval_boolean_expr	function
(	O
expr	pointer
)	O
;	O
switch	O
(	O
rc	int
)	O
{	O
case	O
0	int
:	O
case	O
1	int
:	O
return	O
rc	int
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
checkrad	function
(	O
grad_nas_t	struct
*	O
nas	int
,	O
struct	O
radutmp	struct
*	O
up	pointer
)	O
{	O
struct	O
check_instance	struct
checkp	pointer
;	O
int	O
rc	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
create_instance	function
(	O
&	O
checkp	pointer
,	O
nas	int
,	O
up	pointer
)	O
)	O
return	O
-	O
1	int
;	O
switch	O
(	O
checkp	pointer
.	O
method	int
)	O
{	O
case	O
METHOD_FINGER	int
:	O
rc	int
=	O
finger_check	function
(	O
&	O
checkp	pointer
,	O
nas	int
)	O
;	O
break	O
;	O
case	O
METHOD_SNMP	int
:	O
rc	int
=	O
snmp_check	function
(	O
&	O
checkp	pointer
,	O
nas	int
)	O
;	O
break	O
;	O
case	O
METHOD_EXT	int
:	O
rc	int
=	O
ext_check	function
(	O
&	O
checkp	pointer
,	O
nas	int
)	O
;	O
break	O
;	O
case	O
METHOD_GUILE	int
:	O
rc	int
=	O
guile_check	function
(	O
&	O
checkp	pointer
,	O
nas	int
)	O
;	O
break	O
;	O
default	O
:	O
grad_insist_fail	O
(	O
"bad method"	pointer
)	O
;	O
}	O
free_instance	function
(	O
&	O
checkp	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
