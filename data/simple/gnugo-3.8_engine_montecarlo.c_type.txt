static	O
int	O
mc_debug	int
=	O
0	int
;	O
struct	O
mc_board	struct
{	O
Intersection	char
board	pointer
[	O
BOARDSIZE	O
]	O
;	O
int	O
local_context	array
[	O
BOARDSIZE	O
]	O
;	O
int	O
queue	array
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
move_values_white	array
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
move_values_black	array
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
partitioned_move_value_sums_white	array
[	O
NUM_MOVE_PARTITIONS	int
]	O
;	O
unsigned	O
int	O
partitioned_move_value_sums_black	array
[	O
NUM_MOVE_PARTITIONS	int
]	O
;	O
int	O
move_partition_lists_white	array
[	O
BOARDMAX	O
]	O
;	O
int	O
move_partition_lists_black	array
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
move_value_sum_white	int
;	O
unsigned	O
int	O
move_value_sum_black	int
;	O
int	O
board_ko_pos	int
;	O
int	O
reference_stone	array
[	O
BOARDMAX	O
]	O
;	O
int	O
next_stone	array
[	O
BOARDMAX	O
]	O
;	O
int	O
first_liberty_edge	array
[	O
BOARDMAX	O
]	O
;	O
int	O
previous_liberty_edge	array
[	O
4	int
*	O
BOARDMAX	O
]	O
;	O
int	O
next_liberty_edge	array
[	O
4	int
*	O
BOARDMAX	O
]	O
;	O
Hash_data	struct
hash	struct
;	O
}	O
;	O
static	O
void	O
mc_add_liberty_edge	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
pos	int
,	O
int	O
lib	int
,	O
int	O
dir	int
)	O
{	O
int	O
this_liberty_edge	int
=	O
(	O
lib	int
<<	O
2	int
)	O
|	O
dir	int
;	O
int	O
reference	int
=	O
mc	pointer
->	O
reference_stone	array
[	O
pos	int
]	O
;	O
int	O
first_liberty_edge	array
=	O
mc	pointer
->	O
first_liberty_edge	array
[	O
reference	int
]	O
;	O
if	O
(	O
first_liberty_edge	array
)	O
{	O
int	O
second_liberty_edge	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
first_liberty_edge	array
]	O
;	O
mc	pointer
->	O
previous_liberty_edge	array
[	O
this_liberty_edge	int
]	O
=	O
first_liberty_edge	array
;	O
mc	pointer
->	O
next_liberty_edge	array
[	O
this_liberty_edge	int
]	O
=	O
second_liberty_edge	int
;	O
mc	pointer
->	O
next_liberty_edge	array
[	O
first_liberty_edge	array
]	O
=	O
this_liberty_edge	int
;	O
mc	pointer
->	O
previous_liberty_edge	array
[	O
second_liberty_edge	int
]	O
=	O
this_liberty_edge	int
;	O
}	O
else	O
{	O
mc	pointer
->	O
first_liberty_edge	array
[	O
reference	int
]	O
=	O
this_liberty_edge	int
;	O
mc	pointer
->	O
next_liberty_edge	array
[	O
this_liberty_edge	int
]	O
=	O
this_liberty_edge	int
;	O
mc	pointer
->	O
previous_liberty_edge	array
[	O
this_liberty_edge	int
]	O
=	O
this_liberty_edge	int
;	O
}	O
}	O
static	O
int	O
mc_remove_liberty_edge	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
pos	int
,	O
int	O
lib	int
,	O
int	O
dir	int
)	O
{	O
int	O
reference	int
=	O
mc	pointer
->	O
reference_stone	array
[	O
pos	int
]	O
;	O
int	O
this_liberty_edge	int
=	O
(	O
lib	int
<<	O
2	int
)	O
|	O
dir	int
;	O
int	O
next	pointer
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
this_liberty_edge	int
]	O
;	O
int	O
previous	int
=	O
mc	pointer
->	O
previous_liberty_edge	array
[	O
this_liberty_edge	int
]	O
;	O
if	O
(	O
next	pointer
==	O
this_liberty_edge	int
)	O
{	O
mc	pointer
->	O
first_liberty_edge	array
[	O
reference	int
]	O
=	O
0	int
;	O
return	O
0	int
;	O
}	O
mc	pointer
->	O
next_liberty_edge	array
[	O
previous	int
]	O
=	O
next	pointer
;	O
mc	pointer
->	O
previous_liberty_edge	array
[	O
next	pointer
]	O
=	O
previous	int
;	O
if	O
(	O
mc	pointer
->	O
first_liberty_edge	array
[	O
reference	int
]	O
==	O
this_liberty_edge	int
)	O
mc	pointer
->	O
first_liberty_edge	array
[	O
reference	int
]	O
=	O
next	pointer
;	O
return	O
next	pointer
;	O
}	O
static	O
void	O
mc_join_strings	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
str1	int
,	O
int	O
str2	int
)	O
{	O
int	O
reference	int
=	O
mc	pointer
->	O
reference_stone	array
[	O
str2	int
]	O
;	O
int	O
liberty_edge2	int
=	O
mc	pointer
->	O
first_liberty_edge	array
[	O
reference	int
]	O
;	O
int	O
liberty_edge1	int
=	O
mc	pointer
->	O
first_liberty_edge	array
[	O
mc	pointer
->	O
reference_stone	array
[	O
str1	int
]	O
]	O
;	O
int	O
next1	int
;	O
int	O
next2	int
;	O
int	O
pos	int
=	O
str1	int
;	O
do	O
{	O
mc	pointer
->	O
reference_stone	array
[	O
pos	int
]	O
=	O
reference	int
;	O
pos	int
=	O
mc	pointer
->	O
next_stone	array
[	O
pos	int
]	O
;	O
}	O
while	O
(	O
pos	int
!=	O
str1	int
)	O
;	O
next1	int
=	O
mc	pointer
->	O
next_stone	array
[	O
str1	int
]	O
;	O
mc	pointer
->	O
next_stone	array
[	O
str1	int
]	O
=	O
mc	pointer
->	O
next_stone	array
[	O
str2	int
]	O
;	O
mc	pointer
->	O
next_stone	array
[	O
str2	int
]	O
=	O
next1	int
;	O
if	O
(	O
liberty_edge1	int
!=	O
0	int
)	O
{	O
next1	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
liberty_edge1	int
]	O
;	O
next2	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
liberty_edge2	int
]	O
;	O
mc	pointer
->	O
next_liberty_edge	array
[	O
liberty_edge1	int
]	O
=	O
next2	int
;	O
mc	pointer
->	O
next_liberty_edge	array
[	O
liberty_edge2	int
]	O
=	O
next1	int
;	O
mc	pointer
->	O
previous_liberty_edge	array
[	O
next1	int
]	O
=	O
liberty_edge2	int
;	O
mc	pointer
->	O
previous_liberty_edge	array
[	O
next2	int
]	O
=	O
liberty_edge1	int
;	O
}	O
}	O
static	O
void	O
mc_queue_max_two_liberties	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
str	int
)	O
{	O
int	O
reference	int
=	O
mc	pointer
->	O
reference_stone	array
[	O
str	int
]	O
;	O
int	O
first_liberty_edge	array
=	O
mc	pointer
->	O
first_liberty_edge	array
[	O
reference	int
]	O
;	O
int	O
first_liberty	int
=	O
first_liberty_edge	array
>>	O
2	int
;	O
int	O
liberty_edge	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
first_liberty_edge	array
]	O
;	O
int	O
second_liberty	int
;	O
if	O
(	O
first_liberty	int
==	O
NO_MOVE	O
)	O
return	O
;	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array
)	O
{	O
if	O
(	O
(	O
liberty_edge	int
>>	O
2	int
)	O
!=	O
first_liberty	int
)	O
{	O
second_liberty	int
=	O
liberty_edge	int
>>	O
2	int
;	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array
)	O
{	O
if	O
(	O
(	O
liberty_edge	int
>>	O
2	int
)	O
!=	O
first_liberty	int
&&	O
(	O
liberty_edge	int
>>	O
2	int
)	O
!=	O
second_liberty	int
)	O
return	O
;	O
liberty_edge	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
liberty_edge	int
]	O
;	O
}	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	pointer
,	O
first_liberty	int
)	O
;	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	pointer
,	O
second_liberty	int
)	O
;	O
return	O
;	O
}	O
liberty_edge	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
liberty_edge	int
]	O
;	O
}	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	pointer
,	O
first_liberty	int
)	O
;	O
}	O
static	O
int	O
mc_remove_string	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
str	int
)	O
{	O
int	O
color	int
=	O
mc	pointer
->	O
board	pointer
[	O
str	int
]	O
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
pos	int
=	O
str	int
;	O
int	O
num_removed_stones	int
=	O
0	int
;	O
int	O
k	int
;	O
do	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
k	int
<	O
4	int
&&	O
mc	pointer
->	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
other	int
)	O
{	O
mc_queue_max_two_liberties	function
(	O
mc	pointer
,	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
;	O
mc_add_liberty_edge	function
(	O
mc	pointer
,	O
pos	int
+	O
delta	array
[	O
k	int
]	O
,	O
pos	int
,	O
k	int
)	O
;	O
}	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
)	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	pointer
,	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
;	O
}	O
mc	pointer
->	O
board	pointer
[	O
pos	int
]	O
=	O
EMPTY	int
;	O
mc	pointer
->	O
local_context	array
[	O
NW	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
14	int
;	O
mc	pointer
->	O
local_context	array
[	O
SW	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
12	int
;	O
mc	pointer
->	O
local_context	array
[	O
SE	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
10	int
;	O
mc	pointer
->	O
local_context	array
[	O
NE	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
8	int
;	O
mc	pointer
->	O
local_context	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
6	int
;	O
mc	pointer
->	O
local_context	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
4	int
;	O
mc	pointer
->	O
local_context	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
^=	O
color	int
<<	O
2	int
;	O
mc	pointer
->	O
local_context	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
^=	O
color	int
;	O
hashdata_invert_stone	function
(	O
&	O
(	O
mc	pointer
->	O
hash	struct
)	O
,	O
pos	int
,	O
color	int
)	O
;	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	pointer
,	O
pos	int
)	O
;	O
num_removed_stones	int
++	O
;	O
pos	int
=	O
mc	pointer
->	O
next_stone	array
[	O
pos	int
]	O
;	O
}	O
while	O
(	O
pos	int
!=	O
str	int
)	O
;	O
return	O
num_removed_stones	int
;	O
}	O
static	O
void	O
mc_init_board_from_global_board	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
)	O
{	O
int	O
stones	pointer
[	O
BOARDMAX	O
]	O
;	O
int	O
num_stones	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
r	int
;	O
memcpy	function
(	O
mc	pointer
->	O
board	pointer
,	O
board	pointer
,	O
sizeof	O
(	O
mc	pointer
->	O
board	pointer
)	O
)	O
;	O
mc	pointer
->	O
board_ko_pos	int
=	O
board_ko_pos	int
;	O
mc	pointer
->	O
hash	struct
=	O
board_hash	struct
;	O
memset	function
(	O
mc	pointer
->	O
queue	array
,	O
0	int
,	O
sizeof	O
(	O
mc	pointer
->	O
queue	array
)	O
)	O
;	O
mc	pointer
->	O
queue	array
[	O
0	int
]	O
=	O
1	int
;	O
memset	function
(	O
mc	pointer
->	O
next_stone	array
,	O
0	int
,	O
sizeof	O
(	O
mc	pointer
->	O
next_stone	array
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
geometry	int
=	O
(	O
(	O
mc	pointer
->	O
board	pointer
[	O
SE	O
(	O
pos	int
)	O
]	O
<<	O
14	int
)	O
|	O
(	O
mc	pointer
->	O
board	pointer
[	O
NE	O
(	O
pos	int
)	O
]	O
<<	O
12	int
)	O
|	O
(	O
mc	pointer
->	O
board	pointer
[	O
NW	O
(	O
pos	int
)	O
]	O
<<	O
10	int
)	O
|	O
(	O
mc	pointer
->	O
board	pointer
[	O
SW	O
(	O
pos	int
)	O
]	O
<<	O
8	int
)	O
|	O
(	O
mc	pointer
->	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
<<	O
6	int
)	O
|	O
(	O
mc	pointer
->	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
<<	O
4	int
)	O
|	O
(	O
mc	pointer
->	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
<<	O
2	int
)	O
|	O
mc	pointer
->	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
)	O
;	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
=	O
geometry	int
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
s	int
;	O
int	O
captured_black_stones	int
=	O
0	int
;	O
int	O
captured_white_stones	int
=	O
0	int
;	O
if	O
(	O
is_self_atari	function
(	O
pos	int
,	O
WHITE	int
)	O
)	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
1	int
<<	O
20	int
;	O
if	O
(	O
is_self_atari	function
(	O
pos	int
,	O
BLACK	int
)	O
)	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
1	int
<<	O
21	int
;	O
if	O
(	O
is_suicide	function
(	O
pos	int
,	O
WHITE	int
)	O
)	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
1	int
<<	O
22	int
;	O
if	O
(	O
is_suicide	function
(	O
pos	int
,	O
BLACK	int
)	O
)	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
1	int
<<	O
23	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
4	int
;	O
s	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
s	int
]	O
]	O
==	O
BLACK	int
&&	O
countlib	function
(	O
pos	int
+	O
delta	array
[	O
s	int
]	O
)	O
==	O
1	int
)	O
captured_black_stones	int
+=	O
countstones	function
(	O
pos	int
+	O
delta	array
[	O
s	int
]	O
)	O
;	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
s	int
]	O
]	O
==	O
WHITE	int
&&	O
countlib	function
(	O
pos	int
+	O
delta	array
[	O
s	int
]	O
)	O
==	O
1	int
)	O
captured_white_stones	int
+=	O
countstones	function
(	O
pos	int
+	O
delta	array
[	O
s	int
]	O
)	O
;	O
}	O
if	O
(	O
captured_black_stones	int
>	O
3	int
)	O
captured_black_stones	int
=	O
3	int
;	O
if	O
(	O
captured_white_stones	int
>	O
3	int
)	O
captured_white_stones	int
=	O
3	int
;	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
captured_black_stones	int
<<	O
16	int
;	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
captured_white_stones	int
<<	O
18	int
;	O
}	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
mc	pointer
->	O
next_stone	array
[	O
pos	int
]	O
==	O
0	int
)	O
{	O
num_stones	int
=	O
findstones	function
(	O
pos	int
,	O
BOARDMAX	O
,	O
stones	pointer
)	O
;	O
mc	pointer
->	O
first_liberty_edge	array
[	O
pos	int
]	O
=	O
0	int
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
num_stones	int
;	O
r	int
++	O
)	O
{	O
mc	pointer
->	O
next_stone	array
[	O
stones	pointer
[	O
r	int
]	O
]	O
=	O
stones	pointer
[	O
(	O
r	int
+	O
1	int
)	O
%	O
num_stones	int
]	O
;	O
mc	pointer
->	O
reference_stone	array
[	O
stones	pointer
[	O
r	int
]	O
]	O
=	O
pos	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
stones	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
)	O
mc_add_liberty_edge	function
(	O
mc	pointer
,	O
stones	pointer
[	O
r	int
]	O
,	O
stones	pointer
[	O
r	int
]	O
+	O
delta	array
[	O
k	int
]	O
,	O
(	O
k	int
+	O
2	int
)	O
%	O
4	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
mc_showboard	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
FILE	struct
*	O
outfile	pointer
)	O
{	O
int	O
i	int
,	O
j	int
;	O
draw_letter_coordinates	function
(	O
outfile	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
board_size	int
;	O
i	int
++	O
)	O
{	O
fprintf	function
(	O
outfile	pointer
,	O
"\n%2d"	pointer
,	O
board_size	int
-	O
i	int
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
board_size	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
==	O
EMPTY	int
)	O
fprintf	function
(	O
outfile	pointer
,	O
" %c"	pointer
,	O
is_hoshi_point	function
(	O
i	int
,	O
j	int
)	O
?	O
'+'	O
:	O
'.'	O
)	O
;	O
else	O
fprintf	function
(	O
outfile	pointer
,	O
" %c"	pointer
,	O
mc	pointer
->	O
board	pointer
[	O
POS	O
(	O
i	int
,	O
j	int
)	O
]	O
==	O
BLACK	int
?	O
'X'	O
:	O
'O'	O
)	O
;	O
}	O
}	O
fprintf	function
(	O
outfile	pointer
,	O
"\n"	pointer
)	O
;	O
draw_letter_coordinates	function
(	O
outfile	pointer
)	O
;	O
}	O
static	O
int	O
mc_countstones	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
str	int
,	O
int	O
maxstones	int
)	O
{	O
int	O
stone	int
=	O
str	int
;	O
int	O
num_stones	int
=	O
0	int
;	O
do	O
{	O
num_stones	int
++	O
;	O
stone	int
=	O
mc	pointer
->	O
next_stone	array
[	O
stone	int
]	O
;	O
}	O
while	O
(	O
stone	int
!=	O
str	int
&&	O
num_stones	int
<	O
maxstones	int
)	O
;	O
return	O
num_stones	int
;	O
}	O
static	O
int	O
mc_is_in_atari	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
str	int
,	O
int	O
*	O
lib	int
)	O
{	O
int	O
reference	int
=	O
mc	pointer
->	O
reference_stone	array
[	O
str	int
]	O
;	O
int	O
first_liberty_edge	array
=	O
mc	pointer
->	O
first_liberty_edge	array
[	O
reference	int
]	O
;	O
int	O
liberty	int
=	O
first_liberty_edge	array
>>	O
2	int
;	O
int	O
liberty_edge	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
first_liberty_edge	array
]	O
;	O
if	O
(	O
lib	int
)	O
*	O
lib	int
=	O
liberty	int
;	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array
)	O
{	O
if	O
(	O
(	O
liberty_edge	int
>>	O
2	int
)	O
!=	O
liberty	int
)	O
return	O
0	int
;	O
liberty_edge	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
liberty_edge	int
]	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
mc_is_in_atari2	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
first_liberty	int
,	O
int	O
first_liberty_edge	array
)	O
{	O
int	O
liberty_edge	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
first_liberty_edge	array
]	O
;	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array
)	O
{	O
if	O
(	O
(	O
liberty_edge	int
>>	O
2	int
)	O
!=	O
first_liberty	int
)	O
return	O
0	int
;	O
liberty_edge	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
liberty_edge	int
]	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
int	O
mc_stones_in_atari	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
maxstones	int
)	O
{	O
int	O
k	int
;	O
int	O
stones_in_atari	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
&&	O
stones_in_atari	int
<	O
maxstones	int
;	O
k	int
++	O
)	O
{	O
int	O
pos	int
=	O
move	pointer
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
mc_is_in_atari	function
(	O
mc	pointer
,	O
pos	int
,	O
NULL	O
)	O
)	O
stones_in_atari	int
+=	O
mc_countstones	function
(	O
mc	pointer
,	O
pos	int
,	O
maxstones	int
-	O
stones_in_atari	int
)	O
;	O
}	O
return	O
stones_in_atari	int
;	O
}	O
static	O
int	O
mc_has_two_liberties_one_given	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
str	int
,	O
int	O
first_liberty	int
,	O
int	O
*	O
second_liberty	int
)	O
{	O
int	O
reference	int
=	O
mc	pointer
->	O
reference_stone	array
[	O
str	int
]	O
;	O
int	O
first_liberty_edge	array
=	O
mc	pointer
->	O
first_liberty_edge	array
[	O
reference	int
]	O
;	O
int	O
liberty_edge	int
=	O
first_liberty_edge	array
;	O
*	O
second_liberty	int
=	O
NO_MOVE	O
;	O
do	O
{	O
int	O
liberty	int
=	O
liberty_edge	int
>>	O
2	int
;	O
if	O
(	O
liberty	int
!=	O
first_liberty	int
)	O
{	O
if	O
(	O
*	O
second_liberty	int
==	O
NO_MOVE	O
)	O
*	O
second_liberty	int
=	O
liberty	int
;	O
else	O
if	O
(	O
liberty	int
!=	O
*	O
second_liberty	int
)	O
return	O
0	int
;	O
}	O
liberty_edge	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
liberty_edge	int
]	O
;	O
}	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array
)	O
;	O
return	O
(	O
*	O
second_liberty	int
!=	O
NO_MOVE	O
)	O
;	O
}	O
static	O
int	O
mc_is_self_atari	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
captured	int
=	O
NO_MOVE	O
;	O
int	O
liberty	int
=	O
NO_MOVE	O
;	O
int	O
reference	int
;	O
int	O
other	int
;	O
if	O
(	O
(	O
(	O
mc	pointer
->	O
board	pointer
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
)	O
+	O
(	O
mc	pointer
->	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
)	O
+	O
(	O
mc	pointer
->	O
board	pointer
[	O
NORTH	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
)	O
+	O
(	O
mc	pointer
->	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
EMPTY	int
)	O
)	O
>	O
1	int
)	O
return	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
first_liberty_edge	array
;	O
int	O
liberty_edge	int
;	O
int	O
additional_liberty	int
=	O
0	int
;	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
{	O
if	O
(	O
pos2	int
!=	O
liberty	int
)	O
{	O
if	O
(	O
liberty	int
!=	O
NO_MOVE	O
)	O
return	O
0	int
;	O
else	O
liberty	int
=	O
pos2	int
;	O
}	O
}	O
else	O
if	O
(	O
IS_STONE	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
)	O
)	O
{	O
first_liberty_edge	array
=	O
(	O
pos	int
<<	O
2	int
)	O
|	O
k	int
;	O
liberty_edge	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
first_liberty_edge	array
]	O
;	O
while	O
(	O
liberty_edge	int
!=	O
first_liberty_edge	array
)	O
{	O
int	O
lib	int
=	O
liberty_edge	int
>>	O
2	int
;	O
if	O
(	O
lib	int
!=	O
pos	int
)	O
{	O
additional_liberty	int
=	O
1	int
;	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
lib	int
!=	O
liberty	int
)	O
{	O
if	O
(	O
liberty	int
!=	O
NO_MOVE	O
)	O
return	O
0	int
;	O
else	O
liberty	int
=	O
lib	int
;	O
}	O
}	O
else	O
break	O
;	O
}	O
liberty_edge	int
=	O
mc	pointer
->	O
next_liberty_edge	array
[	O
liberty_edge	int
]	O
;	O
}	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
!=	O
color	int
&&	O
additional_liberty	int
==	O
0	int
)	O
{	O
captured	int
=	O
pos2	int
;	O
if	O
(	O
pos2	int
!=	O
liberty	int
)	O
{	O
if	O
(	O
liberty	int
!=	O
NO_MOVE	O
)	O
return	O
0	int
;	O
else	O
liberty	int
=	O
pos2	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
liberty	int
==	O
NO_MOVE	O
||	O
captured	int
==	O
NO_MOVE	O
)	O
return	O
1	int
;	O
reference	int
=	O
mc	pointer
->	O
reference_stone	array
[	O
captured	int
]	O
;	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
color	int
)	O
{	O
int	O
stone	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
do	O
{	O
int	O
m	int
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
4	int
;	O
m	int
++	O
)	O
{	O
int	O
pos2	int
=	O
stone	int
+	O
delta	array
[	O
m	int
]	O
;	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
==	O
other	int
&&	O
pos2	int
!=	O
captured	int
&&	O
mc	pointer
->	O
reference_stone	array
[	O
pos2	int
]	O
==	O
reference	int
)	O
return	O
0	int
;	O
}	O
stone	int
=	O
mc	pointer
->	O
next_stone	array
[	O
stone	int
]	O
;	O
}	O
while	O
(	O
stone	int
!=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
;	O
}	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
mc_update_local_context	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
pos	int
)	O
{	O
int	O
min_white_liberties	int
=	O
0	int
;	O
int	O
min_black_liberties	int
=	O
0	int
;	O
int	O
white_liberty_through_stones	int
=	O
0	int
;	O
int	O
black_liberty_through_stones	int
=	O
0	int
;	O
int	O
min_white_captured_stones	int
=	O
0	int
;	O
int	O
min_black_captured_stones	int
=	O
0	int
;	O
int	O
white_suicide	int
=	O
0	int
;	O
int	O
black_suicide	int
=	O
0	int
;	O
int	O
white_self_atari	int
=	O
0	int
;	O
int	O
black_self_atari	int
=	O
0	int
;	O
int	O
white_captured_stones	int
=	O
0	int
;	O
int	O
black_captured_stones	int
=	O
0	int
;	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
switch	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
)	O
{	O
case	O
EMPTY	int
:	O
min_white_liberties	int
++	O
;	O
min_black_liberties	int
++	O
;	O
break	O
;	O
case	O
WHITE	int
:	O
if	O
(	O
mc_is_in_atari2	function
(	O
mc	pointer
,	O
pos	int
,	O
(	O
pos	int
<<	O
2	int
)	O
|	O
k	int
)	O
)	O
{	O
min_black_liberties	int
++	O
;	O
min_white_captured_stones	int
++	O
;	O
}	O
else	O
white_liberty_through_stones	int
=	O
1	int
;	O
break	O
;	O
case	O
BLACK	int
:	O
if	O
(	O
mc_is_in_atari2	function
(	O
mc	pointer
,	O
pos	int
,	O
(	O
pos	int
<<	O
2	int
)	O
|	O
k	int
)	O
)	O
{	O
min_white_liberties	int
++	O
;	O
min_black_captured_stones	int
++	O
;	O
}	O
else	O
black_liberty_through_stones	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
min_white_liberties	int
+	O
white_liberty_through_stones	int
==	O
0	int
)	O
{	O
white_suicide	int
=	O
1	int
;	O
white_self_atari	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
min_white_liberties	int
<=	O
1	int
)	O
white_self_atari	int
=	O
mc_is_self_atari	function
(	O
mc	pointer
,	O
pos	int
,	O
WHITE	int
)	O
;	O
if	O
(	O
min_black_liberties	int
+	O
black_liberty_through_stones	int
==	O
0	int
)	O
{	O
black_suicide	int
=	O
1	int
;	O
black_self_atari	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
min_black_liberties	int
<=	O
1	int
)	O
black_self_atari	int
=	O
mc_is_self_atari	function
(	O
mc	pointer
,	O
pos	int
,	O
BLACK	int
)	O
;	O
if	O
(	O
min_white_captured_stones	int
>=	O
3	int
)	O
white_captured_stones	int
=	O
3	int
;	O
else	O
if	O
(	O
min_white_captured_stones	int
>	O
0	int
)	O
white_captured_stones	int
=	O
mc_stones_in_atari	function
(	O
mc	pointer
,	O
pos	int
,	O
BLACK	int
,	O
3	int
)	O
;	O
if	O
(	O
min_black_captured_stones	int
>=	O
3	int
)	O
black_captured_stones	int
=	O
3	int
;	O
else	O
if	O
(	O
min_black_captured_stones	int
>	O
0	int
)	O
black_captured_stones	int
=	O
mc_stones_in_atari	function
(	O
mc	pointer
,	O
pos	int
,	O
WHITE	int
,	O
3	int
)	O
;	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
&=	O
0xffff	int
;	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
black_captured_stones	int
<<	O
16	int
;	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
white_captured_stones	int
<<	O
18	int
;	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
white_self_atari	int
<<	O
20	int
;	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
black_self_atari	int
<<	O
21	int
;	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
white_suicide	int
<<	O
22	int
;	O
mc	pointer
->	O
local_context	array
[	O
pos	int
]	O
|=	O
black_suicide	int
<<	O
23	int
;	O
}	O
static	O
int	O
mc_play_move	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
captured_stones	pointer
=	O
0	int
;	O
int	O
num_direct_liberties	int
=	O
0	int
;	O
int	O
pos2	int
;	O
while	O
(	O
mc	pointer
->	O
queue	array
[	O
0	int
]	O
!=	O
1	int
)	O
{	O
pos2	int
=	O
mc	pointer
->	O
queue	array
[	O
0	int
]	O
;	O
mc	pointer
->	O
queue	array
[	O
0	int
]	O
=	O
mc	pointer
->	O
queue	array
[	O
pos2	int
]	O
;	O
mc	pointer
->	O
queue	array
[	O
pos2	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
pos	int
==	O
PASS_MOVE	int
)	O
{	O
if	O
(	O
mc	pointer
->	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	function
(	O
&	O
mc	pointer
->	O
hash	struct
,	O
mc	pointer
->	O
board_ko_pos	int
)	O
;	O
mc	pointer
->	O
board_ko_pos	int
=	O
NO_MOVE	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
pos	int
==	O
mc	pointer
->	O
board_ko_pos	int
)	O
{	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
WEST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
||	O
mc	pointer
->	O
board	pointer
[	O
EAST	O
(	O
pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
mc_is_suicide	O
(	O
mc	pointer
,	O
pos	int
,	O
color	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
mc	pointer
->	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
hashdata_invert_ko	function
(	O
&	O
mc	pointer
->	O
hash	struct
,	O
mc	pointer
->	O
board_ko_pos	int
)	O
;	O
mc	pointer
->	O
board_ko_pos	int
=	O
NO_MOVE	O
;	O
mc	pointer
->	O
board	pointer
[	O
pos	int
]	O
=	O
color	int
;	O
hashdata_invert_stone	function
(	O
&	O
mc	pointer
->	O
hash	struct
,	O
pos	int
,	O
color	int
)	O
;	O
mc	pointer
->	O
next_stone	array
[	O
pos	int
]	O
=	O
pos	int
;	O
mc	pointer
->	O
local_context	array
[	O
NW	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
14	int
;	O
mc	pointer
->	O
local_context	array
[	O
SW	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
12	int
;	O
mc	pointer
->	O
local_context	array
[	O
SE	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
10	int
;	O
mc	pointer
->	O
local_context	array
[	O
NE	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
8	int
;	O
mc	pointer
->	O
local_context	array
[	O
WEST	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
6	int
;	O
mc	pointer
->	O
local_context	array
[	O
SOUTH	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
4	int
;	O
mc	pointer
->	O
local_context	array
[	O
EAST	O
(	O
pos	int
)	O
]	O
|=	O
color	int
<<	O
2	int
;	O
mc	pointer
->	O
local_context	array
[	O
NORTH	O
(	O
pos	int
)	O
]	O
|=	O
color	int
;	O
mc	pointer
->	O
reference_stone	array
[	O
pos	int
]	O
=	O
pos	int
;	O
mc	pointer
->	O
first_liberty_edge	array
[	O
pos	int
]	O
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
)	O
{	O
mc_add_liberty_edge	function
(	O
mc	pointer
,	O
pos	int
,	O
pos2	int
,	O
(	O
k	int
+	O
2	int
)	O
%	O
4	int
)	O
;	O
num_direct_liberties	int
++	O
;	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	pointer
,	O
pos2	int
)	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
liberty	int
;	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
==	O
color	int
)	O
{	O
if	O
(	O
mc	pointer
->	O
reference_stone	array
[	O
pos	int
]	O
!=	O
mc	pointer
->	O
reference_stone	array
[	O
pos2	int
]	O
)	O
{	O
if	O
(	O
mc_has_two_liberties_one_given	function
(	O
mc	pointer
,	O
pos2	int
,	O
pos	int
,	O
&	O
liberty	int
)	O
)	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	pointer
,	O
liberty	int
)	O
;	O
mc_join_strings	function
(	O
mc	pointer
,	O
pos	int
,	O
pos2	int
)	O
;	O
}	O
mc_remove_liberty_edge	function
(	O
mc	pointer
,	O
pos2	int
,	O
pos	int
,	O
k	int
)	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
if	O
(	O
mc_remove_liberty_edge	function
(	O
mc	pointer
,	O
pos2	int
,	O
pos	int
,	O
k	int
)	O
==	O
0	int
)	O
captured_stones	pointer
+=	O
mc_remove_string	function
(	O
mc	pointer
,	O
pos2	int
)	O
;	O
else	O
mc_queue_max_two_liberties	function
(	O
mc	pointer
,	O
pos2	int
)	O
;	O
}	O
}	O
if	O
(	O
captured_stones	pointer
==	O
1	int
&&	O
mc	pointer
->	O
next_stone	array
[	O
pos	int
]	O
==	O
pos	int
&&	O
num_direct_liberties	int
==	O
0	int
)	O
{	O
mc	pointer
->	O
board_ko_pos	int
=	O
mc	pointer
->	O
first_liberty_edge	array
[	O
pos	int
]	O
>>	O
2	int
;	O
hashdata_invert_ko	function
(	O
&	O
mc	pointer
->	O
hash	struct
,	O
mc	pointer
->	O
board_ko_pos	int
)	O
;	O
}	O
mc_queue_max_two_liberties	function
(	O
mc	pointer
,	O
pos	int
)	O
;	O
for	O
(	O
pos2	int
=	O
mc	pointer
->	O
queue	array
[	O
0	int
]	O
;	O
pos2	int
!=	O
1	int
;	O
pos2	int
=	O
mc	pointer
->	O
queue	array
[	O
pos2	int
]	O
)	O
if	O
(	O
pos2	int
!=	O
pos	int
)	O
mc_update_local_context	function
(	O
mc	pointer
,	O
pos2	int
)	O
;	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	pointer
,	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
)	O
MC_ADD_TO_UPDATE_QUEUE	O
(	O
mc	pointer
,	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
struct	O
mc_pattern_table	struct
{	O
unsigned	O
short	O
geometry_table	array
[	O
65536	int
]	O
;	O
unsigned	O
int	O
values	array
[	O
(	O
NUM_GEOMETRIES	int
+	O
1	int
)	O
*	O
NUM_PROPERTIES	int
]	O
;	O
}	O
;	O
static	O
struct	O
mc_pattern_table	struct
mc_patterns	struct
;	O
static	O
int	O
mc_find_pattern_number	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
move	pointer
,	O
int	O
color	int
,	O
int	O
near_previous_move	int
)	O
{	O
int	O
local_context	array
=	O
mc	pointer
->	O
local_context	array
[	O
move	pointer
]	O
;	O
int	O
properties	int
;	O
int	O
geometry	int
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
{	O
properties	int
=	O
(	O
(	O
(	O
local_context	array
>>	O
16	int
)	O
&	O
0xa0	int
)	O
|	O
(	O
(	O
local_context	array
>>	O
14	int
)	O
&	O
0x40	int
)	O
|	O
(	O
(	O
local_context	array
>>	O
17	int
)	O
&	O
0x06	int
)	O
|	O
(	O
(	O
local_context	array
>>	O
13	int
)	O
&	O
0x18	int
)	O
)	O
;	O
geometry	int
=	O
local_context	array
&	O
0xffff	int
;	O
}	O
else	O
{	O
properties	int
=	O
(	O
local_context	array
>>	O
15	int
)	O
&	O
0xfe	int
;	O
geometry	int
=	O
(	O
(	O
(	O
local_context	array
&	O
0x5555	int
)	O
<<	O
1	int
)	O
|	O
(	O
(	O
local_context	array
&	O
0xaaaa	int
)	O
>>	O
1	int
)	O
)	O
;	O
}	O
return	O
(	O
(	O
mc_patterns	struct
.	O
geometry_table	array
[	O
geometry	int
]	O
<<	O
8	int
)	O
|	O
properties	int
|	O
near_previous_move	int
)	O
;	O
}	O
static	O
unsigned	O
short	O
mc_register_geometry_pattern	function
(	O
unsigned	O
int	O
pattern	pointer
,	O
unsigned	O
short	O
n	int
)	O
{	O
int	O
k	int
;	O
int	O
j	int
;	O
unsigned	O
int	O
transformed_pattern	int
;	O
if	O
(	O
mc_patterns	struct
.	O
geometry_table	array
[	O
pattern	pointer
]	O
!=	O
0	int
)	O
return	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
transformed_pattern	int
=	O
pattern	pointer
;	O
if	O
(	O
k	int
>=	O
4	int
)	O
{	O
transformed_pattern	int
=	O
(	O
(	O
(	O
pattern	pointer
&	O
0x0300	int
)	O
<<	O
6	int
)	O
|	O
(	O
(	O
pattern	pointer
&	O
0x000c	int
)	O
<<	O
4	int
)	O
|	O
(	O
(	O
pattern	pointer
&	O
0x0c00	int
)	O
<<	O
2	int
)	O
|	O
(	O
pattern	pointer
&	O
0x0033	int
)	O
|	O
(	O
(	O
pattern	pointer
&	O
0x3000	int
)	O
>>	O
2	int
)	O
|	O
(	O
(	O
pattern	pointer
&	O
0x00c0	int
)	O
>>	O
4	int
)	O
|	O
(	O
(	O
pattern	pointer
&	O
0xc000	int
)	O
>>	O
6	int
)	O
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
k	int
%	O
4	int
;	O
j	int
++	O
)	O
{	O
transformed_pattern	int
=	O
(	O
(	O
(	O
transformed_pattern	int
&	O
0xc0c0	int
)	O
>>	O
6	int
)	O
|	O
(	O
(	O
transformed_pattern	int
&	O
0x3f3f	int
)	O
<<	O
2	int
)	O
)	O
;	O
}	O
mc_patterns	struct
.	O
geometry_table	array
[	O
transformed_pattern	int
]	O
=	O
n	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
mc_init_pattern_geometries	function
(	O
void	O
)	O
{	O
unsigned	O
int	O
pattern	pointer
;	O
unsigned	O
short	O
n	int
=	O
1	int
;	O
static	O
int	O
initialized	int
=	O
0	int
;	O
if	O
(	O
initialized	int
)	O
return	O
;	O
initialized	int
=	O
1	int
;	O
memset	function
(	O
mc_patterns	struct
.	O
geometry_table	array
,	O
0	int
,	O
sizeof	O
(	O
mc_patterns	struct
.	O
geometry_table	array
)	O
)	O
;	O
for	O
(	O
pattern	pointer
=	O
0	int
;	O
pattern	pointer
<	O
65536	int
;	O
pattern	pointer
++	O
)	O
{	O
unsigned	O
int	O
off_board	int
=	O
(	O
pattern	pointer
&	O
(	O
pattern	pointer
>>	O
1	int
)	O
)	O
&	O
0x5555	int
;	O
if	O
(	O
off_board	int
==	O
0x0	int
||	O
off_board	int
==	O
0x1410	int
||	O
off_board	int
==	O
0x5450	int
)	O
n	int
+=	O
mc_register_geometry_pattern	function
(	O
pattern	pointer
,	O
n	int
)	O
;	O
}	O
gg_assert	O
(	O
n	int
==	O
NUM_GEOMETRIES	int
+	O
1	int
)	O
;	O
}	O
static	O
void	O
mc_match_geometries	function
(	O
int	O
pattern	pointer
[	O
8	int
]	O
,	O
int	O
*	O
matching_geometries	pointer
,	O
int	O
n	int
)	O
{	O
int	O
k	int
;	O
int	O
geometry	int
=	O
0	int
;	O
if	O
(	O
n	int
==	O
8	int
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
8	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
pattern	pointer
[	O
k	int
]	O
==	O
'O'	O
)	O
geometry	int
|=	O
WHITE	int
<<	O
(	O
2	int
*	O
k	int
)	O
;	O
else	O
if	O
(	O
pattern	pointer
[	O
k	int
]	O
==	O
'X'	O
)	O
geometry	int
|=	O
BLACK	int
<<	O
(	O
2	int
*	O
k	int
)	O
;	O
else	O
if	O
(	O
pattern	pointer
[	O
k	int
]	O
==	O
'+'	O
||	O
pattern	pointer
[	O
k	int
]	O
==	O
'|'	O
||	O
pattern	pointer
[	O
k	int
]	O
==	O
'-'	O
)	O
geometry	int
|=	O
(	O
WHITE	int
|	O
BLACK	int
)	O
<<	O
(	O
2	int
*	O
k	int
)	O
;	O
}	O
if	O
(	O
mc_patterns	struct
.	O
geometry_table	array
[	O
geometry	int
]	O
!=	O
0	int
)	O
{	O
matching_geometries	pointer
[	O
mc_patterns	struct
.	O
geometry_table	array
[	O
geometry	int
]	O
]	O
=	O
1	int
;	O
}	O
}	O
else	O
{	O
int	O
new_pattern	array
[	O
8	int
]	O
;	O
memcpy	function
(	O
new_pattern	array
,	O
pattern	pointer
,	O
sizeof	O
(	O
new_pattern	array
)	O
)	O
;	O
switch	O
(	O
pattern	pointer
[	O
n	int
]	O
)	O
{	O
case	O
'.'	O
:	O
case	O
'O'	O
:	O
case	O
'X'	O
:	O
case	O
'|'	O
:	O
case	O
'-'	O
:	O
case	O
'+'	O
:	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
break	O
;	O
case	O
'o'	O
:	O
new_pattern	array
[	O
n	int
]	O
=	O
'.'	O
;	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array
[	O
n	int
]	O
=	O
'O'	O
;	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
break	O
;	O
case	O
'x'	O
:	O
new_pattern	array
[	O
n	int
]	O
=	O
'.'	O
;	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array
[	O
n	int
]	O
=	O
'X'	O
;	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
break	O
;	O
case	O
'?'	O
:	O
new_pattern	array
[	O
n	int
]	O
=	O
'.'	O
;	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array
[	O
n	int
]	O
=	O
'O'	O
;	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array
[	O
n	int
]	O
=	O
'X'	O
;	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
break	O
;	O
case	O
'%'	O
:	O
new_pattern	array
[	O
n	int
]	O
=	O
'.'	O
;	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array
[	O
n	int
]	O
=	O
'O'	O
;	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array
[	O
n	int
]	O
=	O
'X'	O
;	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
new_pattern	array
[	O
n	int
]	O
=	O
'+'	O
;	O
mc_match_geometries	function
(	O
new_pattern	array
,	O
matching_geometries	pointer
,	O
n	int
+	O
1	int
)	O
;	O
break	O
;	O
}	O
}	O
}	O
static	O
void	O
mc_clear_properties	function
(	O
int	O
*	O
properties	int
,	O
int	O
shift	int
,	O
int	O
mask	int
,	O
int	O
value	pointer
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
NUM_PROPERTIES	int
;	O
k	int
++	O
)	O
if	O
(	O
(	O
(	O
k	int
>>	O
shift	int
)	O
&	O
mask	int
)	O
==	O
value	pointer
)	O
properties	int
[	O
k	int
]	O
=	O
0	int
;	O
}	O
static	O
void	O
mc_analyze_properties	function
(	O
char	O
*	O
buf	pointer
,	O
int	O
*	O
properties	int
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
NUM_PROPERTIES	int
;	O
k	int
++	O
)	O
properties	int
[	O
k	int
]	O
=	O
1	int
;	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"near"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
0	int
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"far"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
0	int
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xcap0"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xcap1+"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xcap1-"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xcap1"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xcap2+"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xcap2-"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
3	int
)	O
;	O
else	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xcap2"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xcap3"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
1	int
,	O
3	int
,	O
2	int
)	O
;	O
}	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"ocap0"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"ocap1+"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"ocap1-"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"ocap1"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
2	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"ocap2+"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
1	int
)	O
;	O
}	O
else	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"ocap2-"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
3	int
)	O
;	O
else	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"ocap2"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
3	int
)	O
;	O
}	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"ocap3"	pointer
)	O
)	O
{	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
0	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
1	int
)	O
;	O
mc_clear_properties	function
(	O
properties	int
,	O
3	int
,	O
3	int
,	O
2	int
)	O
;	O
}	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xsafe"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
5	int
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xunsafe"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
5	int
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"osafe"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
6	int
,	O
1	int
,	O
1	int
)	O
;	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"ounsafe"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
6	int
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xsuicide"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
7	int
,	O
1	int
,	O
0	int
)	O
;	O
if	O
(	O
strstr	function
(	O
buf	pointer
,	O
"xnosuicide"	pointer
)	O
)	O
mc_clear_properties	function
(	O
properties	int
,	O
7	int
,	O
1	int
,	O
1	int
)	O
;	O
}	O
int	O
mc_get_size_of_pattern_values_table	function
(	O
void	O
)	O
{	O
return	O
(	O
NUM_GEOMETRIES	int
+	O
1	int
)	O
*	O
NUM_PROPERTIES	int
;	O
}	O
int	O
mc_load_patterns_from_db	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
unsigned	O
int	O
*	O
values	array
)	O
{	O
FILE	struct
*	O
pattern_file	pointer
;	O
char	O
buf	pointer
[	O
80	int
]	O
;	O
unsigned	O
int	O
value	pointer
;	O
int	O
pattern_line	int
=	O
0	int
;	O
int	O
current_pattern	array
[	O
8	int
]	O
;	O
int	O
patterns_expanded	int
=	O
0	int
;	O
int	O
*	O
matching_geometries	pointer
;	O
int	O
properties	int
[	O
NUM_PROPERTIES	int
]	O
;	O
int	O
k	int
;	O
int	O
m	int
;	O
if	O
(	O
!	O
values	array
)	O
values	array
=	O
mc_patterns	struct
.	O
values	array
;	O
mc_init_pattern_geometries	function
(	O
)	O
;	O
pattern_file	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
pattern_file	pointer
)	O
{	O
gprintf	function
(	O
"Failed to open %s file.\n"	pointer
,	O
filename	pointer
)	O
;	O
return	O
0	int
;	O
}	O
matching_geometries	pointer
=	O
malloc	function
(	O
(	O
NUM_GEOMETRIES	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
matching_geometries	pointer
)	O
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
NUM_GEOMETRIES	int
;	O
k	int
++	O
)	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
NUM_PROPERTIES	int
;	O
m	int
++	O
)	O
values	array
[	O
k	int
*	O
NUM_PROPERTIES	int
+	O
m	int
]	O
=	O
0xffffffffU	int
;	O
while	O
(	O
fgets	function
(	O
buf	pointer
,	O
80	int
,	O
pattern_file	pointer
)	O
)	O
{	O
if	O
(	O
strchr	function
(	O
".xXoO|+-?%"	pointer
,	O
buf	pointer
[	O
0	int
]	O
)	O
)	O
{	O
patterns_expanded	int
=	O
0	int
;	O
if	O
(	O
pattern_line	int
==	O
0	int
)	O
{	O
current_pattern	array
[	O
5	int
]	O
=	O
buf	pointer
[	O
0	int
]	O
;	O
current_pattern	array
[	O
2	int
]	O
=	O
buf	pointer
[	O
1	int
]	O
;	O
current_pattern	array
[	O
6	int
]	O
=	O
buf	pointer
[	O
2	int
]	O
;	O
}	O
else	O
if	O
(	O
pattern_line	int
==	O
1	int
)	O
{	O
current_pattern	array
[	O
1	int
]	O
=	O
buf	pointer
[	O
0	int
]	O
;	O
current_pattern	array
[	O
3	int
]	O
=	O
buf	pointer
[	O
2	int
]	O
;	O
}	O
else	O
if	O
(	O
pattern_line	int
==	O
2	int
)	O
{	O
current_pattern	array
[	O
4	int
]	O
=	O
buf	pointer
[	O
0	int
]	O
;	O
current_pattern	array
[	O
0	int
]	O
=	O
buf	pointer
[	O
1	int
]	O
;	O
current_pattern	array
[	O
7	int
]	O
=	O
buf	pointer
[	O
2	int
]	O
;	O
}	O
pattern_line	int
++	O
;	O
}	O
else	O
if	O
(	O
sscanf	function
(	O
buf	pointer
,	O
":%u"	pointer
,	O
&	O
value	pointer
)	O
==	O
1	int
)	O
{	O
if	O
(	O
value	pointer
>	O
10000000	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Warning: pattern values should be at most 10000000."	pointer
)	O
;	O
if	O
(	O
!	O
patterns_expanded	int
)	O
{	O
memset	function
(	O
matching_geometries	pointer
,	O
0	int
,	O
(	O
NUM_GEOMETRIES	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
*	O
matching_geometries	pointer
)	O
)	O
;	O
mc_match_geometries	function
(	O
current_pattern	array
,	O
matching_geometries	pointer
,	O
0	int
)	O
;	O
patterns_expanded	int
=	O
1	int
;	O
}	O
mc_analyze_properties	function
(	O
buf	pointer
,	O
properties	int
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
NUM_GEOMETRIES	int
;	O
k	int
++	O
)	O
if	O
(	O
matching_geometries	pointer
[	O
k	int
]	O
)	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
NUM_PROPERTIES	int
;	O
m	int
++	O
)	O
if	O
(	O
properties	int
[	O
m	int
]	O
&&	O
values	array
[	O
k	int
*	O
NUM_PROPERTIES	int
+	O
m	int
]	O
==	O
0xffffffffU	int
)	O
values	array
[	O
k	int
*	O
NUM_PROPERTIES	int
+	O
m	int
]	O
=	O
value	pointer
;	O
pattern_line	int
=	O
0	int
;	O
}	O
}	O
fclose	function
(	O
pattern_file	pointer
)	O
;	O
for	O
(	O
k	int
=	O
1	int
;	O
k	int
<=	O
NUM_GEOMETRIES	int
;	O
k	int
++	O
)	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
NUM_PROPERTIES	int
;	O
m	int
++	O
)	O
if	O
(	O
values	array
[	O
k	int
*	O
NUM_PROPERTIES	int
+	O
m	int
]	O
==	O
0xffffffffU	int
)	O
values	array
[	O
k	int
*	O
NUM_PROPERTIES	int
+	O
m	int
]	O
=	O
1	int
;	O
free	function
(	O
matching_geometries	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
mc_init_patterns	function
(	O
const	O
unsigned	O
int	O
*	O
values	array
)	O
{	O
mc_init_pattern_geometries	function
(	O
)	O
;	O
memcpy	function
(	O
mc_patterns	struct
.	O
values	array
,	O
values	array
,	O
sizeof	O
(	O
mc_patterns	struct
.	O
values	array
)	O
)	O
;	O
}	O
static	O
void	O
mc_init_move_values	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
memset	function
(	O
mc	pointer
->	O
move_values_white	array
,	O
0	int
,	O
sizeof	O
(	O
mc	pointer
->	O
move_values_white	array
)	O
)	O
;	O
memset	function
(	O
mc	pointer
->	O
move_values_black	array
,	O
0	int
,	O
sizeof	O
(	O
mc	pointer
->	O
move_values_black	array
)	O
)	O
;	O
memset	function
(	O
mc	pointer
->	O
partitioned_move_value_sums_white	array
,	O
0	int
,	O
sizeof	O
(	O
mc	pointer
->	O
partitioned_move_value_sums_white	array
)	O
)	O
;	O
memset	function
(	O
mc	pointer
->	O
partitioned_move_value_sums_black	array
,	O
0	int
,	O
sizeof	O
(	O
mc	pointer
->	O
partitioned_move_value_sums_black	array
)	O
)	O
;	O
memset	function
(	O
mc	pointer
->	O
move_partition_lists_white	array
,	O
0	int
,	O
sizeof	O
(	O
mc	pointer
->	O
move_partition_lists_white	array
)	O
)	O
;	O
memset	function
(	O
mc	pointer
->	O
move_partition_lists_black	array
,	O
0	int
,	O
sizeof	O
(	O
mc	pointer
->	O
move_partition_lists_black	array
)	O
)	O
;	O
mc	pointer
->	O
move_value_sum_white	int
=	O
0.0	int
;	O
mc	pointer
->	O
move_value_sum_black	int
=	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
NUM_MOVE_PARTITIONS	int
;	O
k	int
++	O
)	O
{	O
mc	pointer
->	O
move_partition_lists_white	array
[	O
k	int
]	O
=	O
1	int
;	O
mc	pointer
->	O
move_partition_lists_black	array
[	O
k	int
]	O
=	O
1	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
partition	int
=	O
pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
if	O
(	O
!	O
mc_is_suicide	O
(	O
mc	pointer
,	O
pos	int
,	O
WHITE	int
)	O
)	O
{	O
int	O
pattern	pointer
=	O
mc_find_pattern_number	function
(	O
mc	pointer
,	O
pos	int
,	O
WHITE	int
,	O
0	int
)	O
;	O
unsigned	O
int	O
value	pointer
=	O
mc_patterns	struct
.	O
values	array
[	O
pattern	pointer
]	O
;	O
mc	pointer
->	O
move_values_white	array
[	O
pos	int
]	O
=	O
value	pointer
;	O
mc	pointer
->	O
partitioned_move_value_sums_white	array
[	O
partition	int
]	O
+=	O
value	pointer
;	O
mc	pointer
->	O
move_value_sum_white	int
+=	O
value	pointer
;	O
mc	pointer
->	O
move_partition_lists_white	array
[	O
pos	int
]	O
=	O
mc	pointer
->	O
move_partition_lists_white	array
[	O
partition	int
]	O
;	O
mc	pointer
->	O
move_partition_lists_white	array
[	O
partition	int
]	O
=	O
pos	int
;	O
}	O
if	O
(	O
!	O
mc_is_suicide	O
(	O
mc	pointer
,	O
pos	int
,	O
BLACK	int
)	O
)	O
{	O
int	O
pattern	pointer
=	O
mc_find_pattern_number	function
(	O
mc	pointer
,	O
pos	int
,	O
BLACK	int
,	O
0	int
)	O
;	O
unsigned	O
int	O
value	pointer
=	O
mc_patterns	struct
.	O
values	array
[	O
pattern	pointer
]	O
;	O
mc	pointer
->	O
move_values_black	array
[	O
pos	int
]	O
=	O
value	pointer
;	O
mc	pointer
->	O
partitioned_move_value_sums_black	array
[	O
partition	int
]	O
+=	O
value	pointer
;	O
mc	pointer
->	O
move_value_sum_black	int
+=	O
value	pointer
;	O
mc	pointer
->	O
move_partition_lists_black	array
[	O
pos	int
]	O
=	O
mc	pointer
->	O
move_partition_lists_black	array
[	O
partition	int
]	O
;	O
mc	pointer
->	O
move_partition_lists_black	array
[	O
partition	int
]	O
=	O
pos	int
;	O
}	O
}	O
}	O
}	O
static	O
void	O
mc_add_move	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
partition	int
,	O
unsigned	O
int	O
*	O
move_values	pointer
,	O
int	O
*	O
partition_lists	pointer
,	O
unsigned	O
int	O
*	O
partition_sums	pointer
,	O
unsigned	O
int	O
*	O
move_value_sum	pointer
)	O
{	O
int	O
pattern	pointer
=	O
mc_find_pattern_number	function
(	O
mc	pointer
,	O
pos	int
,	O
color	int
,	O
0	int
)	O
;	O
unsigned	O
int	O
value	pointer
=	O
mc_patterns	struct
.	O
values	array
[	O
pattern	pointer
]	O
;	O
partition_lists	pointer
[	O
pos	int
]	O
=	O
partition_lists	pointer
[	O
partition	int
]	O
;	O
partition_lists	pointer
[	O
partition	int
]	O
=	O
pos	int
;	O
move_values	pointer
[	O
pos	int
]	O
=	O
value	pointer
;	O
partition_sums	pointer
[	O
partition	int
]	O
+=	O
value	pointer
;	O
*	O
move_value_sum	pointer
+=	O
value	pointer
;	O
}	O
static	O
void	O
mc_update_move	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
,	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
partition	int
,	O
unsigned	O
int	O
*	O
move_values	pointer
,	O
unsigned	O
int	O
*	O
partition_sums	pointer
,	O
unsigned	O
int	O
*	O
move_value_sum	pointer
)	O
{	O
int	O
pattern	pointer
=	O
mc_find_pattern_number	function
(	O
mc	pointer
,	O
pos	int
,	O
color	int
,	O
0	int
)	O
;	O
unsigned	O
int	O
value	pointer
=	O
mc_patterns	struct
.	O
values	array
[	O
pattern	pointer
]	O
;	O
partition_sums	pointer
[	O
partition	int
]	O
+=	O
value	pointer
-	O
move_values	pointer
[	O
pos	int
]	O
;	O
*	O
move_value_sum	pointer
+=	O
value	pointer
-	O
move_values	pointer
[	O
pos	int
]	O
;	O
move_values	pointer
[	O
pos	int
]	O
=	O
value	pointer
;	O
}	O
static	O
void	O
mc_remove_move	function
(	O
int	O
pos	int
,	O
int	O
partition	int
,	O
unsigned	O
int	O
*	O
move_values	pointer
,	O
int	O
*	O
partition_lists	pointer
,	O
unsigned	O
int	O
*	O
partition_sums	pointer
,	O
unsigned	O
int	O
*	O
move_value_sum	pointer
)	O
{	O
int	O
pos2	int
;	O
int	O
pos3	int
;	O
for	O
(	O
pos2	int
=	O
partition	int
;	O
partition_lists	pointer
[	O
pos2	int
]	O
!=	O
1	int
;	O
pos2	int
=	O
partition_lists	pointer
[	O
pos2	int
]	O
)	O
{	O
if	O
(	O
partition_lists	pointer
[	O
pos2	int
]	O
==	O
pos	int
)	O
break	O
;	O
}	O
pos3	int
=	O
partition_lists	pointer
[	O
pos2	int
]	O
;	O
partition_lists	pointer
[	O
pos2	int
]	O
=	O
partition_lists	pointer
[	O
pos3	int
]	O
;	O
partition_lists	pointer
[	O
pos3	int
]	O
=	O
0	int
;	O
partition_sums	pointer
[	O
partition	int
]	O
-=	O
move_values	pointer
[	O
pos	int
]	O
;	O
*	O
move_value_sum	pointer
-=	O
move_values	pointer
[	O
pos	int
]	O
;	O
move_values	pointer
[	O
pos	int
]	O
=	O
0.0	int
;	O
}	O
static	O
void	O
mc_update_move_values	function
(	O
struct	O
mc_board	struct
*	O
mc	pointer
)	O
{	O
int	O
pos	int
;	O
int	O
partition	int
;	O
for	O
(	O
pos	int
=	O
mc	pointer
->	O
queue	array
[	O
0	int
]	O
;	O
pos	int
!=	O
1	int
;	O
pos	int
=	O
mc	pointer
->	O
queue	array
[	O
pos	int
]	O
)	O
{	O
partition	int
=	O
pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
if	O
(	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
||	O
mc_is_suicide	O
(	O
mc	pointer
,	O
pos	int
,	O
WHITE	int
)	O
)	O
)	O
{	O
if	O
(	O
mc	pointer
->	O
move_partition_lists_white	array
[	O
pos	int
]	O
!=	O
0	int
)	O
{	O
mc_remove_move	function
(	O
pos	int
,	O
partition	int
,	O
mc	pointer
->	O
move_values_white	array
,	O
mc	pointer
->	O
move_partition_lists_white	array
,	O
mc	pointer
->	O
partitioned_move_value_sums_white	array
,	O
&	O
mc	pointer
->	O
move_value_sum_white	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mc	pointer
->	O
move_partition_lists_white	array
[	O
pos	int
]	O
==	O
0	int
)	O
mc_add_move	function
(	O
mc	pointer
,	O
pos	int
,	O
WHITE	int
,	O
partition	int
,	O
mc	pointer
->	O
move_values_white	array
,	O
mc	pointer
->	O
move_partition_lists_white	array
,	O
mc	pointer
->	O
partitioned_move_value_sums_white	array
,	O
&	O
mc	pointer
->	O
move_value_sum_white	int
)	O
;	O
else	O
mc_update_move	function
(	O
mc	pointer
,	O
pos	int
,	O
WHITE	int
,	O
partition	int
,	O
mc	pointer
->	O
move_values_white	array
,	O
mc	pointer
->	O
partitioned_move_value_sums_white	array
,	O
&	O
mc	pointer
->	O
move_value_sum_white	int
)	O
;	O
}	O
if	O
(	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos	int
]	O
!=	O
EMPTY	int
||	O
mc_is_suicide	O
(	O
mc	pointer
,	O
pos	int
,	O
BLACK	int
)	O
)	O
)	O
{	O
if	O
(	O
mc	pointer
->	O
move_partition_lists_black	array
[	O
pos	int
]	O
!=	O
0	int
)	O
{	O
mc_remove_move	function
(	O
pos	int
,	O
partition	int
,	O
mc	pointer
->	O
move_values_black	array
,	O
mc	pointer
->	O
move_partition_lists_black	array
,	O
mc	pointer
->	O
partitioned_move_value_sums_black	array
,	O
&	O
mc	pointer
->	O
move_value_sum_black	int
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
mc	pointer
->	O
move_partition_lists_black	array
[	O
pos	int
]	O
==	O
0	int
)	O
mc_add_move	function
(	O
mc	pointer
,	O
pos	int
,	O
BLACK	int
,	O
partition	int
,	O
mc	pointer
->	O
move_values_black	array
,	O
mc	pointer
->	O
move_partition_lists_black	array
,	O
mc	pointer
->	O
partitioned_move_value_sums_black	array
,	O
&	O
mc	pointer
->	O
move_value_sum_black	int
)	O
;	O
else	O
mc_update_move	function
(	O
mc	pointer
,	O
pos	int
,	O
BLACK	int
,	O
partition	int
,	O
mc	pointer
->	O
move_values_black	array
,	O
mc	pointer
->	O
partitioned_move_value_sums_black	array
,	O
&	O
mc	pointer
->	O
move_value_sum_black	int
)	O
;	O
}	O
}	O
}	O
struct	O
mc_game	struct
{	O
struct	O
mc_board	struct
mc	pointer
;	O
int	O
move_history	array
[	O
600	int
]	O
;	O
unsigned	O
char	O
settled	array
[	O
BOARDMAX	O
]	O
;	O
int	O
color_to_move	int
;	O
int	O
last_move	int
;	O
int	O
consecutive_passes	int
;	O
int	O
consecutive_ko_captures	int
;	O
int	O
depth	int
;	O
}	O
;	O
static	O
int	O
mc_generate_random_move	function
(	O
struct	O
mc_game	struct
*	O
game	pointer
)	O
{	O
struct	O
mc_board	struct
*	O
mc	pointer
=	O
&	O
game	pointer
->	O
mc	pointer
;	O
int	O
last_move	int
=	O
game	pointer
->	O
last_move	int
;	O
int	O
color	int
=	O
game	pointer
->	O
color_to_move	int
;	O
int	O
depth	int
=	O
game	pointer
->	O
depth	int
;	O
int	O
pos	int
;	O
int	O
near_moves	array
[	O
BOARDMAX	O
]	O
;	O
unsigned	O
int	O
saved_near_move_values	array
[	O
BOARDMAX	O
]	O
;	O
int	O
num_near_moves	int
;	O
unsigned	O
int	O
*	O
move_values	pointer
;	O
unsigned	O
int	O
*	O
partition_sums	pointer
;	O
int	O
*	O
partition_lists	pointer
;	O
unsigned	O
int	O
*	O
move_value_sum	pointer
;	O
unsigned	O
int	O
saved_ko_value	int
=	O
0	int
;	O
int	O
partition	int
;	O
int	O
move	pointer
;	O
int	O
k	int
;	O
int	O
x	int
;	O
if	O
(	O
depth	int
>	O
600	int
)	O
{	O
if	O
(	O
mc_debug	int
)	O
{	O
int	O
pos	int
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Reached 600 iterations.\n"	pointer
)	O
;	O
mc_showboard	function
(	O
mc	pointer
,	O
stderr	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
game	pointer
->	O
depth	int
;	O
k	int
++	O
)	O
gprintf	function
(	O
"%1m "	pointer
,	O
game	pointer
->	O
move_history	array
[	O
k	int
]	O
)	O
;	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
gprintf	function
(	O
"%1m "	pointer
,	O
pos	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"white %7d black %7d white near %7d black near %7d\n"	pointer
,	O
(	O
int	O
)	O
mc	pointer
->	O
move_values_white	array
[	O
pos	int
]	O
,	O
(	O
int	O
)	O
mc	pointer
->	O
move_values_black	array
[	O
pos	int
]	O
,	O
mc_patterns	struct
.	O
values	array
[	O
mc_find_pattern_number	function
(	O
mc	pointer
,	O
pos	int
,	O
WHITE	int
,	O
1	int
)	O
]	O
,	O
mc_patterns	struct
.	O
values	array
[	O
mc_find_pattern_number	function
(	O
mc	pointer
,	O
pos	int
,	O
BLACK	int
,	O
1	int
)	O
]	O
)	O
;	O
}	O
}	O
return	O
PASS_MOVE	int
;	O
}	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
{	O
move_values	pointer
=	O
mc	pointer
->	O
move_values_white	array
;	O
partition_sums	pointer
=	O
mc	pointer
->	O
partitioned_move_value_sums_white	array
;	O
partition_lists	pointer
=	O
mc	pointer
->	O
move_partition_lists_white	array
;	O
move_value_sum	pointer
=	O
&	O
mc	pointer
->	O
move_value_sum_white	int
;	O
}	O
else	O
{	O
move_values	pointer
=	O
mc	pointer
->	O
move_values_black	array
;	O
partition_sums	pointer
=	O
mc	pointer
->	O
partitioned_move_value_sums_black	array
;	O
partition_lists	pointer
=	O
mc	pointer
->	O
move_partition_lists_black	array
;	O
move_value_sum	pointer
=	O
&	O
mc	pointer
->	O
move_value_sum_black	int
;	O
}	O
num_near_moves	int
=	O
0	int
;	O
if	O
(	O
last_move	int
!=	O
PASS_MOVE	int
)	O
{	O
for	O
(	O
pos	int
=	O
mc	pointer
->	O
queue	array
[	O
0	int
]	O
;	O
pos	int
!=	O
1	int
;	O
pos	int
=	O
mc	pointer
->	O
queue	array
[	O
pos	int
]	O
)	O
{	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
partition_lists	pointer
[	O
pos	int
]	O
!=	O
0	int
)	O
{	O
unsigned	O
int	O
old_value	int
=	O
move_values	pointer
[	O
pos	int
]	O
;	O
int	O
pattern	pointer
=	O
mc_find_pattern_number	function
(	O
mc	pointer
,	O
pos	int
,	O
color	int
,	O
1	int
)	O
;	O
unsigned	O
int	O
new_value	int
=	O
mc_patterns	struct
.	O
values	array
[	O
pattern	pointer
]	O
;	O
partition	int
=	O
pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
saved_near_move_values	array
[	O
num_near_moves	int
]	O
=	O
old_value	int
;	O
near_moves	array
[	O
num_near_moves	int
++	O
]	O
=	O
pos	int
;	O
move_values	pointer
[	O
pos	int
]	O
=	O
new_value	int
;	O
partition_sums	pointer
[	O
partition	int
]	O
+=	O
new_value	int
-	O
old_value	int
;	O
*	O
move_value_sum	pointer
+=	O
new_value	int
-	O
old_value	int
;	O
}	O
}	O
}	O
if	O
(	O
mc	pointer
->	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
WEST	O
(	O
mc	pointer
->	O
board_ko_pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
||	O
mc	pointer
->	O
board	pointer
[	O
EAST	O
(	O
mc	pointer
->	O
board_ko_pos	int
)	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
partition	int
=	O
mc	pointer
->	O
board_ko_pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
saved_ko_value	int
=	O
move_values	pointer
[	O
mc	pointer
->	O
board_ko_pos	int
]	O
;	O
move_values	pointer
[	O
mc	pointer
->	O
board_ko_pos	int
]	O
=	O
0	int
;	O
partition_sums	pointer
[	O
partition	int
]	O
-=	O
saved_ko_value	int
;	O
*	O
move_value_sum	pointer
-=	O
saved_ko_value	int
;	O
}	O
}	O
if	O
(	O
*	O
move_value_sum	pointer
==	O
0	int
)	O
move	pointer
=	O
PASS_MOVE	int
;	O
else	O
{	O
x	int
=	O
(	O
int	O
)	O
(	O
gg_drand	function
(	O
)	O
*	O
*	O
move_value_sum	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
NUM_MOVE_PARTITIONS	int
;	O
k	int
++	O
)	O
{	O
x	int
-=	O
partition_sums	pointer
[	O
k	int
]	O
;	O
if	O
(	O
x	int
<	O
0	int
)	O
break	O
;	O
}	O
x	int
=	O
(	O
unsigned	O
int	O
)	O
(	O
gg_drand	function
(	O
)	O
*	O
partition_sums	pointer
[	O
k	int
]	O
)	O
;	O
for	O
(	O
pos	int
=	O
partition_lists	pointer
[	O
k	int
]	O
;	O
pos	int
!=	O
1	int
;	O
pos	int
=	O
partition_lists	pointer
[	O
pos	int
]	O
)	O
{	O
x	int
-=	O
move_values	pointer
[	O
pos	int
]	O
;	O
if	O
(	O
x	int
<	O
0	int
)	O
break	O
;	O
}	O
move	pointer
=	O
pos	int
;	O
}	O
if	O
(	O
saved_ko_value	int
>	O
0	int
)	O
{	O
partition	int
=	O
mc	pointer
->	O
board_ko_pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
partition_sums	pointer
[	O
partition	int
]	O
+=	O
saved_ko_value	int
-	O
move_values	pointer
[	O
mc	pointer
->	O
board_ko_pos	int
]	O
;	O
*	O
move_value_sum	pointer
+=	O
saved_ko_value	int
-	O
move_values	pointer
[	O
mc	pointer
->	O
board_ko_pos	int
]	O
;	O
move_values	pointer
[	O
mc	pointer
->	O
board_ko_pos	int
]	O
=	O
saved_ko_value	int
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_near_moves	int
;	O
k	int
++	O
)	O
{	O
unsigned	O
int	O
old_value	int
;	O
unsigned	O
int	O
new_value	int
;	O
pos	int
=	O
near_moves	array
[	O
k	int
]	O
;	O
partition	int
=	O
pos	int
&	O
(	O
NUM_MOVE_PARTITIONS	int
-	O
1	int
)	O
;	O
old_value	int
=	O
move_values	pointer
[	O
pos	int
]	O
;	O
new_value	int
=	O
saved_near_move_values	array
[	O
k	int
]	O
;	O
move_values	pointer
[	O
pos	int
]	O
=	O
new_value	int
;	O
partition_sums	pointer
[	O
partition	int
]	O
+=	O
new_value	int
-	O
old_value	int
;	O
*	O
move_value_sum	pointer
+=	O
new_value	int
-	O
old_value	int
;	O
}	O
return	O
move	pointer
;	O
}	O
static	O
int	O
mc_play_random_move	function
(	O
struct	O
mc_game	struct
*	O
game	pointer
,	O
int	O
move	pointer
)	O
{	O
int	O
result	int
=	O
mc_play_move	function
(	O
&	O
game	pointer
->	O
mc	pointer
,	O
move	pointer
,	O
game	pointer
->	O
color_to_move	int
)	O
;	O
mc_update_move_values	function
(	O
&	O
game	pointer
->	O
mc	pointer
)	O
;	O
if	O
(	O
result	int
)	O
{	O
if	O
(	O
is_pass	function
(	O
move	pointer
)	O
)	O
game	pointer
->	O
consecutive_passes	int
++	O
;	O
else	O
{	O
game	pointer
->	O
consecutive_passes	int
=	O
0	int
;	O
}	O
if	O
(	O
game	pointer
->	O
mc	pointer
.	O
board_ko_pos	int
!=	O
NO_MOVE	O
)	O
game	pointer
->	O
consecutive_ko_captures	int
++	O
;	O
else	O
game	pointer
->	O
consecutive_ko_captures	int
=	O
0	int
;	O
game	pointer
->	O
move_history	array
[	O
game	pointer
->	O
depth	int
]	O
=	O
move	pointer
;	O
game	pointer
->	O
last_move	int
=	O
move	pointer
;	O
game	pointer
->	O
color_to_move	int
=	O
OTHER_COLOR	O
(	O
game	pointer
->	O
color_to_move	int
)	O
;	O
game	pointer
->	O
depth	int
++	O
;	O
}	O
return	O
result	int
;	O
}	O
static	O
int	O
mc_play_random_game	function
(	O
struct	O
mc_game	struct
*	O
game	pointer
)	O
{	O
struct	O
mc_board	struct
*	O
mc	pointer
=	O
&	O
game	pointer
->	O
mc	pointer
;	O
int	O
score	float
=	O
0	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
result	int
;	O
int	O
move	pointer
;	O
while	O
(	O
game	pointer
->	O
consecutive_passes	int
<	O
3	int
)	O
{	O
move	pointer
=	O
mc_generate_random_move	function
(	O
game	pointer
)	O
;	O
result	int
=	O
mc_play_random_move	function
(	O
game	pointer
,	O
move	pointer
)	O
;	O
ASSERT1	O
(	O
result	int
,	O
move	pointer
)	O
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
MC_ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
game	pointer
->	O
settled	array
[	O
pos	int
]	O
==	O
WHITE	int
)	O
score	float
++	O
;	O
else	O
if	O
(	O
game	pointer
->	O
settled	array
[	O
pos	int
]	O
==	O
BLACK	int
)	O
score	float
--	O
;	O
else	O
{	O
int	O
pos2	int
=	O
pos	int
;	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
IS_STONE	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
)	O
)	O
break	O
;	O
}	O
score	float
+=	O
2	int
*	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
==	O
WHITE	int
)	O
-	O
1	int
;	O
}	O
}	O
return	O
score	float
;	O
}	O
struct	O
bitboard	struct
{	O
unsigned	O
int	O
bits	array
[	O
1	int
+	O
BOARDMAX	O
/	O
32	int
]	O
;	O
}	O
;	O
struct	O
uct_arc	struct
{	O
int	O
move	pointer
;	O
struct	O
uct_node	struct
*	O
node	pointer
;	O
struct	O
uct_arc	struct
*	O
next	pointer
;	O
}	O
;	O
struct	O
uct_node	struct
{	O
int	O
wins	int
;	O
int	O
games	int
;	O
float	O
sum_scores	float
;	O
float	O
sum_scores2	float
;	O
struct	O
uct_arc	struct
*	O
child	pointer
;	O
struct	O
bitboard	struct
untested	struct
;	O
Hash_data	struct
boardhash	struct
;	O
}	O
;	O
struct	O
uct_tree	struct
{	O
struct	O
uct_node	struct
*	O
nodes	int
;	O
struct	O
uct_arc	struct
*	O
arcs	pointer
;	O
unsigned	O
int	O
*	O
hashtable_odd	pointer
;	O
unsigned	O
int	O
*	O
hashtable_even	pointer
;	O
unsigned	O
int	O
hashtable_size	int
;	O
int	O
num_nodes	int
;	O
int	O
num_used_nodes	int
;	O
int	O
num_arcs	int
;	O
int	O
num_used_arcs	int
;	O
int	O
*	O
forbidden_moves	pointer
;	O
struct	O
mc_game	struct
game	pointer
;	O
int	O
move_score	array
[	O
BOARDSIZE	O
]	O
;	O
int	O
move_ordering	array
[	O
BOARDSIZE	O
]	O
;	O
int	O
inverse_move_ordering	array
[	O
BOARDSIZE	O
]	O
;	O
int	O
num_ordered_moves	int
;	O
}	O
;	O
static	O
struct	O
uct_node	struct
*	O
uct_init_node	function
(	O
struct	O
uct_tree	struct
*	O
tree	pointer
,	O
int	O
*	O
allowed_moves	array
)	O
{	O
int	O
pos	int
;	O
struct	O
uct_node	struct
*	O
node	pointer
=	O
&	O
tree	pointer
->	O
nodes	int
[	O
tree	pointer
->	O
num_used_nodes	int
++	O
]	O
;	O
node	pointer
->	O
wins	int
=	O
0	int
;	O
node	pointer
->	O
games	int
=	O
0	int
;	O
node	pointer
->	O
sum_scores	float
=	O
0.0	int
;	O
node	pointer
->	O
sum_scores2	float
=	O
0.0	int
;	O
node	pointer
->	O
child	pointer
=	O
NULL	O
;	O
memset	function
(	O
node	pointer
->	O
untested	struct
.	O
bits	array
,	O
0	int
,	O
sizeof	O
(	O
node	pointer
->	O
untested	struct
.	O
bits	array
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
tree	pointer
->	O
game	pointer
.	O
mc	pointer
.	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
!	O
tree	pointer
->	O
forbidden_moves	pointer
[	O
pos	int
]	O
&&	O
(	O
!	O
allowed_moves	array
||	O
allowed_moves	array
[	O
pos	int
]	O
)	O
)	O
{	O
node	pointer
->	O
untested	struct
.	O
bits	array
[	O
pos	int
/	O
32	int
]	O
|=	O
1	int
<<	O
pos	int
%	O
32	int
;	O
}	O
}	O
node	pointer
->	O
boardhash	struct
=	O
tree	pointer
->	O
game	pointer
.	O
mc	pointer
.	O
hash	struct
;	O
return	O
node	pointer
;	O
}	O
static	O
struct	O
uct_node	struct
*	O
uct_find_node	function
(	O
struct	O
uct_tree	struct
*	O
tree	pointer
,	O
struct	O
uct_node	struct
*	O
parent	pointer
,	O
int	O
move	pointer
)	O
{	O
struct	O
uct_node	struct
*	O
node	pointer
=	O
NULL	O
;	O
Hash_data	struct
*	O
boardhash	struct
=	O
&	O
tree	pointer
->	O
game	pointer
.	O
mc	pointer
.	O
hash	struct
;	O
unsigned	O
int	O
hash_index	int
=	O
hashdata_remainder	O
(	O
*	O
boardhash	struct
,	O
tree	pointer
->	O
hashtable_size	int
)	O
;	O
unsigned	O
int	O
*	O
hashtable	pointer
=	O
tree	pointer
->	O
hashtable_even	pointer
;	O
if	O
(	O
tree	pointer
->	O
game	pointer
.	O
depth	int
&	O
1	int
)	O
hashtable	pointer
=	O
tree	pointer
->	O
hashtable_odd	pointer
;	O
while	O
(	O
hashtable	pointer
[	O
hash_index	int
]	O
!=	O
0	int
)	O
{	O
int	O
node_index	int
=	O
hashtable	pointer
[	O
hash_index	int
]	O
;	O
gg_assert	O
(	O
node_index	int
>	O
0	int
&&	O
node_index	int
<	O
tree	pointer
->	O
num_nodes	int
)	O
;	O
if	O
(	O
hashdata_is_equal	O
(	O
tree	pointer
->	O
nodes	int
[	O
node_index	int
]	O
.	O
boardhash	struct
,	O
*	O
boardhash	struct
)	O
)	O
{	O
node	pointer
=	O
&	O
tree	pointer
->	O
nodes	int
[	O
node_index	int
]	O
;	O
break	O
;	O
}	O
hash_index	int
++	O
;	O
if	O
(	O
hash_index	int
>=	O
tree	pointer
->	O
hashtable_size	int
)	O
hash_index	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
node	pointer
)	O
{	O
node	pointer
=	O
uct_init_node	function
(	O
tree	pointer
,	O
NULL	O
)	O
;	O
gg_assert	O
(	O
hash_index	int
<	O
tree	pointer
->	O
hashtable_size	int
)	O
;	O
hashtable	pointer
[	O
hash_index	int
]	O
=	O
node	pointer
-	O
tree	pointer
->	O
nodes	int
;	O
}	O
if	O
(	O
parent	pointer
)	O
{	O
struct	O
uct_arc	struct
*	O
arc	pointer
=	O
&	O
tree	pointer
->	O
arcs	pointer
[	O
tree	pointer
->	O
num_used_arcs	int
++	O
]	O
;	O
gg_assert	O
(	O
tree	pointer
->	O
num_used_arcs	int
<	O
tree	pointer
->	O
num_arcs	int
)	O
;	O
arc	pointer
->	O
move	pointer
=	O
move	pointer
;	O
arc	pointer
->	O
node	pointer
=	O
node	pointer
;	O
if	O
(	O
parent	pointer
->	O
child	pointer
)	O
arc	pointer
->	O
next	pointer
=	O
parent	pointer
->	O
child	pointer
;	O
else	O
arc	pointer
->	O
next	pointer
=	O
NULL	O
;	O
parent	pointer
->	O
child	pointer
=	O
arc	pointer
;	O
}	O
return	O
node	pointer
;	O
}	O
static	O
void	O
uct_update_move_ordering	function
(	O
struct	O
uct_tree	struct
*	O
tree	pointer
,	O
int	O
move	pointer
)	O
{	O
int	O
score	float
=	O
++	O
tree	pointer
->	O
move_score	array
[	O
move	pointer
]	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
n	int
=	O
tree	pointer
->	O
inverse_move_ordering	array
[	O
move	pointer
]	O
;	O
int	O
preceding_move	int
;	O
if	O
(	O
n	int
==	O
0	int
)	O
return	O
;	O
preceding_move	int
=	O
tree	pointer
->	O
move_ordering	array
[	O
n	int
-	O
1	int
]	O
;	O
if	O
(	O
tree	pointer
->	O
move_score	array
[	O
preceding_move	int
]	O
>=	O
score	float
)	O
return	O
;	O
tree	pointer
->	O
move_ordering	array
[	O
n	int
-	O
1	int
]	O
=	O
move	pointer
;	O
tree	pointer
->	O
move_ordering	array
[	O
n	int
]	O
=	O
preceding_move	int
;	O
tree	pointer
->	O
inverse_move_ordering	array
[	O
move	pointer
]	O
=	O
n	int
-	O
1	int
;	O
tree	pointer
->	O
inverse_move_ordering	array
[	O
preceding_move	int
]	O
=	O
n	int
;	O
}	O
}	O
static	O
void	O
uct_init_move_ordering	function
(	O
struct	O
uct_tree	struct
*	O
tree	pointer
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
=	O
0	int
;	O
memset	function
(	O
tree	pointer
->	O
move_score	array
,	O
0	int
,	O
sizeof	O
(	O
tree	pointer
->	O
move_score	array
)	O
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
tree	pointer
->	O
move_ordering	array
[	O
k	int
]	O
=	O
pos	int
;	O
tree	pointer
->	O
inverse_move_ordering	array
[	O
pos	int
]	O
=	O
k	int
;	O
k	int
++	O
;	O
}	O
tree	pointer
->	O
num_ordered_moves	int
=	O
k	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
tree	pointer
->	O
move_score	array
[	O
pos	int
]	O
=	O
(	O
int	O
)	O
(	O
10	int
*	O
potential_moves	array
[	O
pos	int
]	O
)	O
-	O
1	int
;	O
uct_update_move_ordering	function
(	O
tree	pointer
,	O
pos	int
)	O
;	O
}	O
}	O
}	O
static	O
float	O
uct_finish_and_score_game	function
(	O
struct	O
mc_game	struct
*	O
game	pointer
)	O
{	O
return	O
komi	float
+	O
mc_play_random_game	function
(	O
game	pointer
)	O
;	O
}	O
static	O
struct	O
uct_node	struct
*	O
uct_play_move	function
(	O
struct	O
uct_tree	struct
*	O
tree	pointer
,	O
struct	O
uct_node	struct
*	O
node	pointer
,	O
float	O
alpha	float
,	O
float	O
*	O
gamma	function
,	O
int	O
*	O
move	pointer
)	O
{	O
struct	O
uct_arc	struct
*	O
child_arc	pointer
;	O
int	O
pos	int
;	O
struct	O
uct_arc	struct
*	O
next_arc	pointer
=	O
NULL	O
;	O
struct	O
uct_arc	struct
*	O
best_winrate_arc	pointer
=	O
NULL	O
;	O
float	O
best_uct_value	float
=	O
0.0	int
;	O
float	O
best_winrate	float
=	O
0.0	int
;	O
for	O
(	O
child_arc	pointer
=	O
node	pointer
->	O
child	pointer
;	O
child_arc	pointer
;	O
child_arc	pointer
=	O
child_arc	pointer
->	O
next	pointer
)	O
{	O
struct	O
uct_node	struct
*	O
child_node	pointer
=	O
child_arc	pointer
->	O
node	pointer
;	O
float	O
winrate	float
=	O
(	O
float	O
)	O
child_node	pointer
->	O
wins	int
/	O
child_node	pointer
->	O
games	int
;	O
float	O
uct_value	float
;	O
float	O
log_games_ratio	float
=	O
log	function
(	O
node	pointer
->	O
games	int
)	O
/	O
child_node	pointer
->	O
games	int
;	O
float	O
x	int
=	O
winrate	float
*	O
(	O
1.0	int
-	O
winrate	float
)	O
+	O
sqrt	function
(	O
2.0	int
*	O
log_games_ratio	float
)	O
;	O
if	O
(	O
x	int
<	O
0.25	int
)	O
x	int
=	O
0.25	int
;	O
uct_value	float
=	O
winrate	float
+	O
sqrt	function
(	O
2	int
*	O
log_games_ratio	float
*	O
x	int
/	O
(	O
1	int
+	O
tree	pointer
->	O
game	pointer
.	O
depth	int
)	O
)	O
;	O
if	O
(	O
uct_value	float
>	O
best_uct_value	float
)	O
{	O
next_arc	pointer
=	O
child_arc	pointer
;	O
best_uct_value	float
=	O
uct_value	float
;	O
}	O
if	O
(	O
winrate	float
>	O
best_winrate	float
)	O
{	O
best_winrate_arc	pointer
=	O
child_arc	pointer
;	O
best_winrate	float
=	O
winrate	float
;	O
}	O
}	O
*	O
gamma	function
=	O
best_winrate	float
;	O
if	O
(	O
best_winrate	float
>	O
alpha	float
)	O
next_arc	pointer
=	O
best_winrate_arc	pointer
;	O
else	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
-	O
1	int
;	O
k	int
<	O
tree	pointer
->	O
num_ordered_moves	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
k	int
==	O
-	O
1	int
&&	O
best_uct_value	float
>	O
0.0	int
)	O
continue	O
;	O
else	O
if	O
(	O
k	int
==	O
-	O
1	int
)	O
pos	int
=	O
mc_generate_random_move	function
(	O
&	O
tree	pointer
->	O
game	pointer
)	O
;	O
else	O
pos	int
=	O
tree	pointer
->	O
move_ordering	array
[	O
k	int
]	O
;	O
if	O
(	O
node	pointer
->	O
untested	struct
.	O
bits	array
[	O
pos	int
/	O
32	int
]	O
&	O
(	O
1	int
<<	O
(	O
pos	int
%	O
32	int
)	O
)	O
)	O
{	O
int	O
r	int
;	O
int	O
proper_small_eye	int
=	O
1	int
;	O
struct	O
mc_board	struct
*	O
mc	pointer
=	O
&	O
tree	pointer
->	O
game	pointer
.	O
mc	pointer
;	O
*	O
move	pointer
=	O
pos	int
;	O
node	pointer
->	O
untested	struct
.	O
bits	array
[	O
*	O
move	pointer
/	O
32	int
]	O
&=	O
~	O
(	O
1	int
<<	O
*	O
move	pointer
%	O
32	int
)	O
;	O
for	O
(	O
r	int
=	O
0	int
;	O
r	int
<	O
4	int
;	O
r	int
++	O
)	O
{	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
r	int
]	O
]	O
==	O
EMPTY	int
||	O
mc	pointer
->	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
r	int
]	O
]	O
==	O
OTHER_COLOR	O
(	O
tree	pointer
->	O
game	pointer
.	O
color_to_move	int
)	O
)	O
{	O
proper_small_eye	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
proper_small_eye	int
)	O
{	O
int	O
diagonal_value	int
=	O
0	int
;	O
for	O
(	O
r	int
=	O
4	int
;	O
r	int
<	O
8	int
;	O
r	int
++	O
)	O
{	O
int	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
r	int
]	O
;	O
if	O
(	O
!	O
MC_ON_BOARD	O
(	O
pos2	int
)	O
)	O
diagonal_value	int
++	O
;	O
else	O
if	O
(	O
mc	pointer
->	O
board	pointer
[	O
pos2	int
]	O
==	O
OTHER_COLOR	O
(	O
tree	pointer
->	O
game	pointer
.	O
color_to_move	int
)	O
)	O
diagonal_value	int
+=	O
2	int
;	O
}	O
if	O
(	O
diagonal_value	int
>	O
3	int
)	O
proper_small_eye	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
proper_small_eye	int
&&	O
mc_play_random_move	function
(	O
&	O
tree	pointer
->	O
game	pointer
,	O
*	O
move	pointer
)	O
)	O
return	O
uct_find_node	function
(	O
tree	pointer
,	O
node	pointer
,	O
*	O
move	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
next_arc	pointer
)	O
{	O
mc_play_random_move	function
(	O
&	O
tree	pointer
->	O
game	pointer
,	O
PASS_MOVE	int
)	O
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
return	O
uct_find_node	function
(	O
tree	pointer
,	O
node	pointer
,	O
PASS_MOVE	int
)	O
;	O
}	O
*	O
move	pointer
=	O
next_arc	pointer
->	O
move	pointer
;	O
mc_play_random_move	function
(	O
&	O
tree	pointer
->	O
game	pointer
,	O
next_arc	pointer
->	O
move	pointer
)	O
;	O
return	O
next_arc	pointer
->	O
node	pointer
;	O
}	O
static	O
float	O
uct_traverse_tree	function
(	O
struct	O
uct_tree	struct
*	O
tree	pointer
,	O
struct	O
uct_node	struct
*	O
node	pointer
,	O
float	O
alpha	float
,	O
float	O
beta	float
)	O
{	O
int	O
color	int
=	O
tree	pointer
->	O
game	pointer
.	O
color_to_move	int
;	O
int	O
num_passes	int
=	O
tree	pointer
->	O
game	pointer
.	O
consecutive_passes	int
;	O
float	O
result	int
;	O
float	O
gamma	function
;	O
int	O
move	pointer
=	O
PASS_MOVE	int
;	O
if	O
(	O
num_passes	int
==	O
3	int
||	O
tree	pointer
->	O
game	pointer
.	O
depth	int
>=	O
UCT_MAX_SEARCH_DEPTH	O
||	O
(	O
node	pointer
->	O
games	int
==	O
0	int
&&	O
node	pointer
!=	O
tree	pointer
->	O
nodes	int
)	O
)	O
result	int
=	O
uct_finish_and_score_game	function
(	O
&	O
tree	pointer
->	O
game	pointer
)	O
;	O
else	O
{	O
struct	O
uct_node	struct
*	O
next_node	pointer
;	O
next_node	pointer
=	O
uct_play_move	function
(	O
tree	pointer
,	O
node	pointer
,	O
alpha	float
,	O
&	O
gamma	function
,	O
&	O
move	pointer
)	O
;	O
gamma	function
+=	O
0.00	int
;	O
if	O
(	O
gamma	function
>	O
0.8	int
)	O
gamma	function
=	O
0.8	int
;	O
result	int
=	O
uct_traverse_tree	function
(	O
tree	pointer
,	O
next_node	pointer
,	O
beta	float
,	O
gamma	function
)	O
;	O
}	O
node	pointer
->	O
games	int
++	O
;	O
if	O
(	O
(	O
result	int
>	O
0	int
)	O
^	O
(	O
color	int
==	O
WHITE	int
)	O
)	O
{	O
node	pointer
->	O
wins	int
++	O
;	O
if	O
(	O
move	pointer
!=	O
PASS_MOVE	int
)	O
uct_update_move_ordering	function
(	O
tree	pointer
,	O
move	pointer
)	O
;	O
}	O
node	pointer
->	O
sum_scores	float
+=	O
result	int
;	O
node	pointer
->	O
sum_scores2	float
+=	O
result	int
*	O
result	int
;	O
return	O
result	int
;	O
}	O
static	O
int	O
uct_find_best_children	function
(	O
struct	O
uct_node	struct
*	O
node	pointer
,	O
struct	O
uct_arc	struct
*	O
*	O
children	pointer
,	O
int	O
n	int
)	O
{	O
struct	O
uct_arc	struct
*	O
child_arc	pointer
;	O
float	O
best_score	float
;	O
struct	O
uct_arc	struct
*	O
best_child	pointer
;	O
int	O
found_moves	array
[	O
BOARDMAX	O
]	O
;	O
int	O
k	int
;	O
memset	function
(	O
found_moves	array
,	O
0	int
,	O
sizeof	O
(	O
found_moves	array
)	O
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
{	O
best_score	float
=	O
0.0	int
;	O
best_child	pointer
=	O
NULL	O
;	O
for	O
(	O
child_arc	pointer
=	O
node	pointer
->	O
child	pointer
;	O
child_arc	pointer
;	O
child_arc	pointer
=	O
child_arc	pointer
->	O
next	pointer
)	O
{	O
struct	O
uct_node	struct
*	O
child_node	pointer
=	O
child_arc	pointer
->	O
node	pointer
;	O
if	O
(	O
!	O
found_moves	array
[	O
child_arc	pointer
->	O
move	pointer
]	O
&&	O
best_score	float
*	O
child_node	pointer
->	O
games	int
<	O
child_node	pointer
->	O
wins	int
)	O
{	O
best_child	pointer
=	O
child_arc	pointer
;	O
best_score	float
=	O
(	O
float	O
)	O
child_node	pointer
->	O
wins	int
/	O
child_node	pointer
->	O
games	int
;	O
}	O
}	O
if	O
(	O
!	O
best_child	pointer
)	O
break	O
;	O
children	pointer
[	O
k	int
]	O
=	O
best_child	pointer
;	O
found_moves	array
[	O
best_child	pointer
->	O
move	pointer
]	O
=	O
1	int
;	O
}	O
return	O
k	int
;	O
}	O
static	O
void	O
uct_dump_tree_recursive	function
(	O
struct	O
uct_node	struct
*	O
node	pointer
,	O
SGFTree	struct
*	O
sgf_tree	pointer
,	O
int	O
color	int
,	O
int	O
cutoff	int
,	O
int	O
depth	int
)	O
{	O
struct	O
uct_arc	struct
*	O
child_arc	pointer
;	O
char	O
buf	pointer
[	O
100	int
]	O
;	O
if	O
(	O
depth	int
>	O
50	int
)	O
return	O
;	O
for	O
(	O
child_arc	pointer
=	O
node	pointer
->	O
child	pointer
;	O
child_arc	pointer
;	O
child_arc	pointer
=	O
child_arc	pointer
->	O
next	pointer
)	O
{	O
struct	O
uct_node	struct
*	O
child_node	pointer
=	O
child_arc	pointer
->	O
node	pointer
;	O
sgftreeAddPlayLast	function
(	O
sgf_tree	pointer
,	O
color	int
,	O
I	O
(	O
child_arc	pointer
->	O
move	pointer
)	O
,	O
J	O
(	O
child_arc	pointer
->	O
move	pointer
)	O
)	O
;	O
gg_snprintf	function
(	O
buf	pointer
,	O
100	int
,	O
"%d/%d (%5.3f)"	pointer
,	O
child_node	pointer
->	O
wins	int
,	O
child_node	pointer
->	O
games	int
,	O
(	O
float	O
)	O
child_node	pointer
->	O
wins	int
/	O
child_node	pointer
->	O
games	int
)	O
;	O
sgftreeAddComment	function
(	O
sgf_tree	pointer
,	O
buf	pointer
)	O
;	O
if	O
(	O
child_node	pointer
->	O
games	int
>=	O
cutoff	int
)	O
uct_dump_tree_recursive	function
(	O
child_node	pointer
,	O
sgf_tree	pointer
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
cutoff	int
,	O
depth	int
+	O
1	int
)	O
;	O
sgf_tree	pointer
->	O
lastnode	pointer
=	O
sgf_tree	pointer
->	O
lastnode	pointer
->	O
parent	pointer
;	O
}	O
}	O
static	O
void	O
uct_dump_tree	function
(	O
struct	O
uct_tree	struct
*	O
tree	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
int	O
color	int
,	O
int	O
cutoff	int
)	O
{	O
SGFTree	struct
sgf_tree	pointer
;	O
sgftree_clear	function
(	O
&	O
sgf_tree	pointer
)	O
;	O
sgftreeCreateHeaderNode	function
(	O
&	O
sgf_tree	pointer
,	O
board_size	int
,	O
komi	float
,	O
0	int
)	O
;	O
sgffile_printboard	function
(	O
&	O
sgf_tree	pointer
)	O
;	O
uct_dump_tree_recursive	function
(	O
&	O
tree	pointer
->	O
nodes	int
[	O
0	int
]	O
,	O
&	O
sgf_tree	pointer
,	O
color	int
,	O
cutoff	int
,	O
0	int
)	O
;	O
writesgf	function
(	O
sgf_tree	pointer
.	O
root	pointer
,	O
filename	pointer
)	O
;	O
sgfFreeNode	function
(	O
sgf_tree	pointer
.	O
root	pointer
)	O
;	O
}	O
void	O
uct_genmove	function
(	O
int	O
color	int
,	O
int	O
*	O
move	pointer
,	O
int	O
*	O
forbidden_moves	pointer
,	O
int	O
*	O
allowed_moves	array
,	O
int	O
nodes	int
,	O
float	O
*	O
move_values	pointer
,	O
int	O
*	O
move_frequencies	pointer
)	O
{	O
struct	O
uct_tree	struct
tree	pointer
;	O
float	O
best_score	float
;	O
struct	O
uct_arc	struct
*	O
arc	pointer
;	O
struct	O
uct_node	struct
*	O
node	pointer
;	O
struct	O
mc_game	struct
starting_position	struct
;	O
int	O
most_games	int
;	O
struct	O
uct_node	struct
*	O
most_games_node	pointer
;	O
struct	O
uct_arc	struct
*	O
most_games_arc	pointer
;	O
int	O
pos	int
;	O
mc_init_board_from_global_board	function
(	O
&	O
starting_position	struct
.	O
mc	pointer
)	O
;	O
mc_init_move_values	function
(	O
&	O
starting_position	struct
.	O
mc	pointer
)	O
;	O
starting_position	struct
.	O
color_to_move	int
=	O
color	int
;	O
starting_position	struct
.	O
consecutive_passes	int
=	O
0	int
;	O
starting_position	struct
.	O
consecutive_ko_captures	int
=	O
0	int
;	O
starting_position	struct
.	O
last_move	int
=	O
get_last_move	function
(	O
)	O
;	O
starting_position	struct
.	O
depth	int
=	O
0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
starting_position	struct
.	O
settled	array
[	O
pos	int
]	O
=	O
forbidden_moves	pointer
[	O
pos	int
]	O
;	O
tree	pointer
.	O
game	pointer
=	O
starting_position	struct
;	O
tree	pointer
.	O
nodes	int
=	O
malloc	function
(	O
nodes	int
*	O
sizeof	O
(	O
*	O
tree	pointer
.	O
nodes	int
)	O
)	O
;	O
gg_assert	O
(	O
tree	pointer
.	O
nodes	int
)	O
;	O
tree	pointer
.	O
arcs	pointer
=	O
malloc	function
(	O
nodes	int
*	O
sizeof	O
(	O
*	O
tree	pointer
.	O
arcs	pointer
)	O
)	O
;	O
gg_assert	O
(	O
tree	pointer
.	O
arcs	pointer
)	O
;	O
tree	pointer
.	O
hashtable_size	int
=	O
nodes	int
;	O
tree	pointer
.	O
hashtable_odd	pointer
=	O
calloc	function
(	O
tree	pointer
.	O
hashtable_size	int
,	O
sizeof	O
(	O
*	O
tree	pointer
.	O
hashtable_odd	pointer
)	O
)	O
;	O
tree	pointer
.	O
hashtable_even	pointer
=	O
calloc	function
(	O
tree	pointer
.	O
hashtable_size	int
,	O
sizeof	O
(	O
*	O
tree	pointer
.	O
hashtable_even	pointer
)	O
)	O
;	O
gg_assert	O
(	O
tree	pointer
.	O
hashtable_odd	pointer
)	O
;	O
gg_assert	O
(	O
tree	pointer
.	O
hashtable_even	pointer
)	O
;	O
tree	pointer
.	O
num_nodes	int
=	O
nodes	int
;	O
tree	pointer
.	O
num_arcs	int
=	O
nodes	int
;	O
tree	pointer
.	O
num_used_nodes	int
=	O
0	int
;	O
tree	pointer
.	O
num_used_arcs	int
=	O
0	int
;	O
tree	pointer
.	O
forbidden_moves	pointer
=	O
forbidden_moves	pointer
;	O
uct_init_node	function
(	O
&	O
tree	pointer
,	O
allowed_moves	array
)	O
;	O
uct_init_move_ordering	function
(	O
&	O
tree	pointer
)	O
;	O
while	O
(	O
tree	pointer
.	O
num_used_arcs	int
<	O
tree	pointer
.	O
num_arcs	int
-	O
10	int
)	O
{	O
int	O
last_used_arcs	int
=	O
tree	pointer
.	O
num_used_arcs	int
;	O
tree	pointer
.	O
game	pointer
=	O
starting_position	struct
;	O
uct_traverse_tree	function
(	O
&	O
tree	pointer
,	O
&	O
tree	pointer
.	O
nodes	int
[	O
0	int
]	O
,	O
1.0	int
,	O
0.9	int
)	O
;	O
if	O
(	O
tree	pointer
.	O
num_used_arcs	int
==	O
last_used_arcs	int
)	O
break	O
;	O
}	O
best_score	float
=	O
0.0	int
;	O
*	O
move	pointer
=	O
PASS_MOVE	int
;	O
for	O
(	O
arc	pointer
=	O
tree	pointer
.	O
nodes	int
[	O
0	int
]	O
.	O
child	pointer
;	O
arc	pointer
;	O
arc	pointer
=	O
arc	pointer
->	O
next	pointer
)	O
{	O
node	pointer
=	O
arc	pointer
->	O
node	pointer
;	O
move_frequencies	pointer
[	O
arc	pointer
->	O
move	pointer
]	O
=	O
node	pointer
->	O
games	int
;	O
move_values	pointer
[	O
arc	pointer
->	O
move	pointer
]	O
=	O
(	O
float	O
)	O
node	pointer
->	O
wins	int
/	O
node	pointer
->	O
games	int
;	O
if	O
(	O
best_score	float
*	O
node	pointer
->	O
games	int
<	O
node	pointer
->	O
wins	int
)	O
{	O
*	O
move	pointer
=	O
arc	pointer
->	O
move	pointer
;	O
best_score	float
=	O
(	O
float	O
)	O
node	pointer
->	O
wins	int
/	O
node	pointer
->	O
games	int
;	O
}	O
}	O
if	O
(	O
0	int
)	O
uct_dump_tree	function
(	O
&	O
tree	pointer
,	O
"/tmp/ucttree.sgf"	pointer
,	O
color	int
,	O
50	int
)	O
;	O
if	O
(	O
mc_debug	int
)	O
{	O
while	O
(	O
1	int
)	O
{	O
float	O
mean	float
;	O
float	O
std	float
;	O
most_games	int
=	O
0	int
;	O
most_games_node	pointer
=	O
NULL	O
;	O
most_games_arc	pointer
=	O
NULL	O
;	O
for	O
(	O
arc	pointer
=	O
tree	pointer
.	O
nodes	int
[	O
0	int
]	O
.	O
child	pointer
;	O
arc	pointer
;	O
arc	pointer
=	O
arc	pointer
->	O
next	pointer
)	O
{	O
node	pointer
=	O
arc	pointer
->	O
node	pointer
;	O
if	O
(	O
most_games	int
<	O
node	pointer
->	O
games	int
)	O
{	O
most_games	int
=	O
node	pointer
->	O
games	int
;	O
most_games_node	pointer
=	O
node	pointer
;	O
most_games_arc	pointer
=	O
arc	pointer
;	O
}	O
}	O
if	O
(	O
most_games	int
==	O
0	int
)	O
break	O
;	O
mean	float
=	O
most_games_node	pointer
->	O
sum_scores	float
/	O
most_games_node	pointer
->	O
games	int
;	O
std	float
=	O
sqrt	function
(	O
(	O
most_games_node	pointer
->	O
sum_scores2	float
-	O
most_games_node	pointer
->	O
sum_scores	float
*	O
mean	float
)	O
/	O
(	O
most_games_node	pointer
->	O
games	int
-	O
1	int
)	O
)	O
;	O
gprintf	function
(	O
"%1m "	pointer
,	O
most_games_arc	pointer
->	O
move	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%6d %6d %5.3f %5.3f %5.3f %5.3f\n"	pointer
,	O
most_games_node	pointer
->	O
wins	int
,	O
most_games_node	pointer
->	O
games	int
,	O
(	O
float	O
)	O
most_games_node	pointer
->	O
wins	int
/	O
most_games_node	pointer
->	O
games	int
,	O
mean	float
,	O
std	float
,	O
mean	float
/	O
(	O
std	float
+	O
0.001	int
)	O
)	O
;	O
most_games_node	pointer
->	O
games	int
=	O
-	O
most_games_node	pointer
->	O
games	int
;	O
}	O
for	O
(	O
arc	pointer
=	O
tree	pointer
.	O
nodes	int
[	O
0	int
]	O
.	O
child	pointer
;	O
arc	pointer
;	O
arc	pointer
=	O
arc	pointer
->	O
next	pointer
)	O
arc	pointer
->	O
node	pointer
->	O
games	int
=	O
-	O
arc	pointer
->	O
node	pointer
->	O
games	int
;	O
{	O
int	O
n	int
;	O
struct	O
uct_arc	struct
*	O
arcs	pointer
[	O
7	int
]	O
;	O
int	O
depth	int
=	O
0	int
;	O
n	int
=	O
uct_find_best_children	function
(	O
&	O
tree	pointer
.	O
nodes	int
[	O
0	int
]	O
,	O
arcs	pointer
,	O
7	int
)	O
;	O
gprintf	function
(	O
"Principal variation:\n"	pointer
)	O
;	O
while	O
(	O
n	int
>	O
0	int
&&	O
depth	int
<	O
80	int
)	O
{	O
int	O
k	int
;	O
gprintf	function
(	O
"%C "	pointer
,	O
color	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
n	int
;	O
k	int
++	O
)	O
{	O
node	pointer
=	O
arcs	pointer
[	O
k	int
]	O
->	O
node	pointer
;	O
gprintf	function
(	O
"%1m "	pointer
,	O
arcs	pointer
[	O
k	int
]	O
->	O
move	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%5.3f"	pointer
,	O
(	O
float	O
)	O
node	pointer
->	O
wins	int
/	O
node	pointer
->	O
games	int
)	O
;	O
if	O
(	O
k	int
==	O
0	int
)	O
gprintf	function
(	O
" (%d games)"	pointer
,	O
node	pointer
->	O
games	int
)	O
;	O
if	O
(	O
k	int
<	O
n	int
-	O
1	int
)	O
gprintf	function
(	O
", "	pointer
)	O
;	O
}	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
color	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
n	int
=	O
uct_find_best_children	function
(	O
arcs	pointer
[	O
0	int
]	O
->	O
node	pointer
,	O
arcs	pointer
,	O
7	int
)	O
;	O
depth	int
++	O
;	O
}	O
gprintf	function
(	O
"\n"	pointer
)	O
;	O
}	O
}	O
free	function
(	O
tree	pointer
.	O
nodes	int
)	O
;	O
free	function
(	O
tree	pointer
.	O
arcs	pointer
)	O
;	O
free	function
(	O
tree	pointer
.	O
hashtable_odd	pointer
)	O
;	O
free	function
(	O
tree	pointer
.	O
hashtable_even	pointer
)	O
;	O
}	O
