static	O
void	O
close_all_connections	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
;	O
static	O
int	O
MHD_epoll	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
int	O
may_block	int
)	O
;	O
static	O
void	O
mhd_panic_std	function
(	O
void	O
*	O
cls	pointer
,	O
const	O
char	O
*	O
file	pointer
,	O
unsigned	O
int	O
line	int
,	O
const	O
char	O
*	O
reason	pointer
)	O
{	O
(	O
void	O
)	O
cls	pointer
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Fatal error in GNU libmicrohttpd %s:%u: %s\n"	pointer
)	O
,	O
file	pointer
,	O
line	int
,	O
reason	pointer
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
MHD_PanicCallback	pointer
mhd_panic	pointer
=	O
NULL	O
;	O
void	O
*	O
mhd_panic_cls	pointer
=	O
NULL	O
;	O
void	O
MHD_init	function
(	O
void	O
)	O
;	O
static	O
void	O
MHD_default_logger_	function
(	O
void	O
*	O
cls	pointer
,	O
const	O
char	O
*	O
fm	pointer
,	O
va_list	array
ap	array
)	O
{	O
vfprintf	function
(	O
(	O
FILE	struct
*	O
)	O
cls	pointer
,	O
fm	pointer
,	O
ap	array
)	O
;	O
}	O
_MHD_EXTERN	O
void	O
MHD_free	function
(	O
void	O
*	O
ptr	pointer
)	O
{	O
free	function
(	O
ptr	pointer
)	O
;	O
}	O
static	O
struct	O
MHD_Daemon	struct
*	O
MHD_get_master	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
while	O
(	O
NULL	O
!=	O
daemon	function
->	O
master	pointer
)	O
daemon	function
=	O
daemon	function
->	O
master	pointer
;	O
return	O
daemon	function
;	O
}	O
struct	O
MHD_IPCount	struct
{	O
int	O
family	int
;	O
union	O
{	O
struct	O
in_addr	struct
ipv4	struct
;	O
struct	O
in6_addr	struct
ipv6	struct
;	O
}	O
addr	pointer
;	O
unsigned	O
int	O
count	int
;	O
}	O
;	O
static	O
void	O
MHD_ip_count_lock	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
per_ip_connection_mutex	union
)	O
;	O
}	O
static	O
void	O
MHD_ip_count_unlock	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
per_ip_connection_mutex	union
)	O
;	O
}	O
static	O
int	O
MHD_ip_addr_compare	function
(	O
const	O
void	O
*	O
a1	pointer
,	O
const	O
void	O
*	O
a2	pointer
)	O
{	O
return	O
memcmp	function
(	O
a1	pointer
,	O
a2	pointer
,	O
offsetof	O
(	O
struct	O
MHD_IPCount	struct
,	O
count	int
)	O
)	O
;	O
}	O
static	O
int	O
MHD_ip_addr_to_key	function
(	O
const	O
struct	O
sockaddr	struct
*	O
addr	pointer
,	O
socklen_t	int
addrlen	int
,	O
struct	O
MHD_IPCount	struct
*	O
key	pointer
)	O
{	O
memset	function
(	O
key	pointer
,	O
0	int
,	O
sizeof	O
(	O
*	O
key	pointer
)	O
)	O
;	O
if	O
(	O
sizeof	O
(	O
struct	O
sockaddr_in	struct
)	O
==	O
addrlen	int
)	O
{	O
const	O
struct	O
sockaddr_in	struct
*	O
addr4	pointer
=	O
(	O
const	O
struct	O
sockaddr_in	struct
*	O
)	O
addr	pointer
;	O
key	pointer
->	O
family	int
=	O
AF_INET	O
;	O
memcpy	function
(	O
&	O
key	pointer
->	O
addr	pointer
.	O
ipv4	struct
,	O
&	O
addr4	pointer
->	O
sin_addr	struct
,	O
sizeof	O
(	O
addr4	pointer
->	O
sin_addr	struct
)	O
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
if	O
(	O
sizeof	O
(	O
struct	O
sockaddr_in6	struct
)	O
==	O
addrlen	int
)	O
{	O
const	O
struct	O
sockaddr_in6	struct
*	O
addr6	pointer
=	O
(	O
const	O
struct	O
sockaddr_in6	struct
*	O
)	O
addr	pointer
;	O
key	pointer
->	O
family	int
=	O
AF_INET6	O
;	O
memcpy	function
(	O
&	O
key	pointer
->	O
addr	pointer
.	O
ipv6	struct
,	O
&	O
addr6	pointer
->	O
sin6_addr	struct
,	O
sizeof	O
(	O
addr6	pointer
->	O
sin6_addr	struct
)	O
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
return	O
MHD_NO	int
;	O
}	O
static	O
int	O
MHD_ip_limit_add	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
const	O
struct	O
sockaddr	struct
*	O
addr	pointer
,	O
socklen_t	int
addrlen	int
)	O
{	O
struct	O
MHD_IPCount	struct
*	O
key	pointer
;	O
void	O
*	O
*	O
nodep	pointer
;	O
void	O
*	O
node	pointer
;	O
int	O
result	int
;	O
daemon	function
=	O
MHD_get_master	function
(	O
daemon	function
)	O
;	O
if	O
(	O
0	int
==	O
daemon	function
->	O
per_ip_connection_limit	int
)	O
return	O
MHD_YES	int
;	O
if	O
(	O
NULL	O
==	O
(	O
key	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
*	O
key	pointer
)	O
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
MHD_NO	int
==	O
MHD_ip_addr_to_key	function
(	O
addr	pointer
,	O
addrlen	int
,	O
key	pointer
)	O
)	O
{	O
free	function
(	O
key	pointer
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
MHD_ip_count_lock	function
(	O
daemon	function
)	O
;	O
if	O
(	O
NULL	O
==	O
(	O
nodep	pointer
=	O
tsearch	function
(	O
key	pointer
,	O
&	O
daemon	function
->	O
per_ip_connection_count	pointer
,	O
&	O
MHD_ip_addr_compare	function
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to add IP connection count node\n"	pointer
)	O
)	O
;	O
MHD_ip_count_unlock	function
(	O
daemon	function
)	O
;	O
free	function
(	O
key	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
node	pointer
=	O
*	O
nodep	pointer
;	O
if	O
(	O
node	pointer
!=	O
key	pointer
)	O
free	function
(	O
key	pointer
)	O
;	O
key	pointer
=	O
(	O
struct	O
MHD_IPCount	struct
*	O
)	O
node	pointer
;	O
result	int
=	O
(	O
key	pointer
->	O
count	int
<	O
daemon	function
->	O
per_ip_connection_limit	int
)	O
?	O
MHD_YES	int
:	O
MHD_NO	int
;	O
if	O
(	O
MHD_YES	int
==	O
result	int
)	O
++	O
key	pointer
->	O
count	int
;	O
MHD_ip_count_unlock	function
(	O
daemon	function
)	O
;	O
return	O
result	int
;	O
}	O
static	O
void	O
MHD_ip_limit_del	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
const	O
struct	O
sockaddr	struct
*	O
addr	pointer
,	O
socklen_t	int
addrlen	int
)	O
{	O
struct	O
MHD_IPCount	struct
search_key	struct
;	O
struct	O
MHD_IPCount	struct
*	O
found_key	pointer
;	O
void	O
*	O
*	O
nodep	pointer
;	O
daemon	function
=	O
MHD_get_master	function
(	O
daemon	function
)	O
;	O
if	O
(	O
0	int
==	O
daemon	function
->	O
per_ip_connection_limit	int
)	O
return	O
;	O
if	O
(	O
MHD_NO	int
==	O
MHD_ip_addr_to_key	function
(	O
addr	pointer
,	O
addrlen	int
,	O
&	O
search_key	struct
)	O
)	O
return	O
;	O
MHD_ip_count_lock	function
(	O
daemon	function
)	O
;	O
if	O
(	O
NULL	O
==	O
(	O
nodep	pointer
=	O
tfind	function
(	O
&	O
search_key	struct
,	O
&	O
daemon	function
->	O
per_ip_connection_count	pointer
,	O
&	O
MHD_ip_addr_compare	function
)	O
)	O
)	O
{	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to find previously-added IP address\n"	pointer
)	O
)	O
;	O
}	O
found_key	pointer
=	O
(	O
struct	O
MHD_IPCount	struct
*	O
)	O
*	O
nodep	pointer
;	O
if	O
(	O
0	int
==	O
found_key	pointer
->	O
count	int
)	O
{	O
MHD_PANIC	O
(	O
_	O
(	O
"Previously-added IP address had counter of zero\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
0	int
==	O
--	O
found_key	pointer
->	O
count	int
)	O
{	O
tdelete	function
(	O
found_key	pointer
,	O
&	O
daemon	function
->	O
per_ip_connection_count	pointer
,	O
&	O
MHD_ip_addr_compare	function
)	O
;	O
free	function
(	O
found_key	pointer
)	O
;	O
}	O
MHD_ip_count_unlock	function
(	O
daemon	function
)	O
;	O
}	O
int	O
MHD_get_fdset	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
fd_set	struct
*	O
read_fd_set	pointer
,	O
fd_set	struct
*	O
write_fd_set	pointer
,	O
fd_set	struct
*	O
except_fd_set	pointer
,	O
MHD_socket	int
*	O
max_fd	pointer
)	O
{	O
return	O
MHD_get_fdset2	function
(	O
daemon	function
,	O
read_fd_set	pointer
,	O
write_fd_set	pointer
,	O
except_fd_set	pointer
,	O
max_fd	pointer
,	O
_MHD_SYS_DEFAULT_FD_SETSIZE	O
)	O
;	O
}	O
static	O
int	O
internal_get_fdset2	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
fd_set	struct
*	O
read_fd_set	pointer
,	O
fd_set	struct
*	O
write_fd_set	pointer
,	O
fd_set	struct
*	O
except_fd_set	pointer
,	O
MHD_socket	int
*	O
max_fd	pointer
,	O
unsigned	O
int	O
fd_setsize	int
)	O
{	O
struct	O
MHD_Connection	struct
*	O
pos	long
;	O
struct	O
MHD_Connection	struct
*	O
posn	pointer
;	O
int	O
result	int
=	O
MHD_YES	int
;	O
MHD_socket	int
ls	int
;	O
if	O
(	O
daemon	function
->	O
shutdown	function
)	O
return	O
MHD_NO	int
;	O
ls	int
=	O
daemon	function
->	O
listen_fd	int
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
!=	O
ls	int
)	O
&&	O
(	O
!	O
daemon	function
->	O
was_quiesced	bool
)	O
&&	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
ls	int
,	O
read_fd_set	pointer
,	O
max_fd	pointer
,	O
fd_setsize	int
)	O
)	O
)	O
result	int
=	O
MHD_NO	int
;	O
for	O
(	O
pos	long
=	O
daemon	function
->	O
connections_tail	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
posn	pointer
)	O
{	O
posn	pointer
=	O
pos	long
->	O
prev	pointer
;	O
switch	O
(	O
pos	long
->	O
event_loop_info	enum
)	O
{	O
case	O
MHD_EVENT_LOOP_INFO_READ	int
:	O
if	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
pos	long
->	O
socket_fd	int
,	O
read_fd_set	pointer
,	O
max_fd	pointer
,	O
fd_setsize	int
)	O
)	O
result	int
=	O
MHD_NO	int
;	O
MHD_add_to_fd_set_	function
(	O
pos	long
->	O
socket_fd	int
,	O
except_fd_set	pointer
,	O
max_fd	pointer
,	O
fd_setsize	int
)	O
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_WRITE	int
:	O
if	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
pos	long
->	O
socket_fd	int
,	O
write_fd_set	pointer
,	O
max_fd	pointer
,	O
fd_setsize	int
)	O
)	O
result	int
=	O
MHD_NO	int
;	O
MHD_add_to_fd_set_	function
(	O
pos	long
->	O
socket_fd	int
,	O
except_fd_set	pointer
,	O
max_fd	pointer
,	O
fd_setsize	int
)	O
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_BLOCK	int
:	O
if	O
(	O
(	O
NULL	O
==	O
except_fd_set	pointer
)	O
||	O
!	O
MHD_add_to_fd_set_	function
(	O
pos	long
->	O
socket_fd	int
,	O
except_fd_set	pointer
,	O
max_fd	pointer
,	O
fd_setsize	int
)	O
)	O
result	int
=	O
MHD_NO	int
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_CLEANUP	int
:	O
break	O
;	O
}	O
}	O
return	O
result	int
;	O
}	O
int	O
MHD_get_fdset2	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
fd_set	struct
*	O
read_fd_set	pointer
,	O
fd_set	struct
*	O
write_fd_set	pointer
,	O
fd_set	struct
*	O
except_fd_set	pointer
,	O
MHD_socket	int
*	O
max_fd	pointer
,	O
unsigned	O
int	O
fd_setsize	int
)	O
{	O
fd_set	struct
es	struct
;	O
if	O
(	O
(	O
NULL	O
==	O
daemon	function
)	O
||	O
(	O
NULL	O
==	O
read_fd_set	pointer
)	O
||	O
(	O
NULL	O
==	O
write_fd_set	pointer
)	O
||	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
||	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_POLL	int
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
NULL	O
==	O
except_fd_set	pointer
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"MHD_get_fdset2() called with except_fd_set "	pointer
"set to NULL. Such behavior is unsupported.\n"	pointer
)	O
)	O
;	O
FD_ZERO	O
(	O
&	O
es	struct
)	O
;	O
except_fd_set	pointer
=	O
&	O
es	struct
;	O
}	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
{	O
if	O
(	O
daemon	function
->	O
shutdown	function
)	O
return	O
MHD_NO	int
;	O
return	O
MHD_add_to_fd_set_	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
read_fd_set	pointer
,	O
max_fd	pointer
,	O
fd_setsize	int
)	O
?	O
MHD_YES	int
:	O
MHD_NO	int
;	O
}	O
return	O
internal_get_fdset2	function
(	O
daemon	function
,	O
read_fd_set	pointer
,	O
write_fd_set	pointer
,	O
except_fd_set	pointer
,	O
max_fd	pointer
,	O
fd_setsize	int
)	O
;	O
}	O
static	O
int	O
call_handlers	function
(	O
struct	O
MHD_Connection	struct
*	O
con	pointer
,	O
bool	bool
read_ready	bool
,	O
bool	bool
write_ready	bool
,	O
bool	bool
force_close	bool
)	O
{	O
int	O
ret	int
;	O
bool	bool
states_info_processed	bool
=	O
false	int
;	O
bool	bool
on_fasttrack	bool
=	O
(	O
con	pointer
->	O
state	pointer
==	O
MHD_CONNECTION_INIT	int
)	O
;	O
if	O
(	O
!	O
force_close	bool
)	O
{	O
if	O
(	O
(	O
MHD_EVENT_LOOP_INFO_READ	int
==	O
con	pointer
->	O
event_loop_info	enum
)	O
&&	O
read_ready	bool
)	O
{	O
MHD_connection_handle_read	function
(	O
con	pointer
)	O
;	O
ret	int
=	O
MHD_connection_handle_idle	function
(	O
con	pointer
)	O
;	O
states_info_processed	bool
=	O
true	int
;	O
}	O
if	O
(	O
(	O
MHD_EVENT_LOOP_INFO_WRITE	int
==	O
con	pointer
->	O
event_loop_info	enum
)	O
&&	O
write_ready	bool
)	O
{	O
MHD_connection_handle_write	function
(	O
con	pointer
)	O
;	O
ret	int
=	O
MHD_connection_handle_idle	function
(	O
con	pointer
)	O
;	O
states_info_processed	bool
=	O
true	int
;	O
}	O
}	O
else	O
{	O
MHD_connection_close_	function
(	O
con	pointer
,	O
MHD_REQUEST_TERMINATED_WITH_ERROR	int
)	O
;	O
return	O
MHD_connection_handle_idle	function
(	O
con	pointer
)	O
;	O
}	O
if	O
(	O
!	O
states_info_processed	bool
)	O
{	O
ret	int
=	O
MHD_connection_handle_idle	function
(	O
con	pointer
)	O
;	O
}	O
else	O
if	O
(	O
on_fasttrack	bool
&&	O
con	pointer
->	O
sk_nonblck	bool
)	O
{	O
if	O
(	O
MHD_CONNECTION_HEADERS_SENDING	int
==	O
con	pointer
->	O
state	pointer
)	O
{	O
MHD_connection_handle_write	function
(	O
con	pointer
)	O
;	O
ret	int
=	O
MHD_connection_handle_idle	function
(	O
con	pointer
)	O
;	O
}	O
if	O
(	O
(	O
MHD_CONNECTION_NORMAL_BODY_READY	int
==	O
con	pointer
->	O
state	pointer
)	O
||	O
(	O
MHD_CONNECTION_CHUNKED_BODY_READY	int
==	O
con	pointer
->	O
state	pointer
)	O
)	O
{	O
MHD_connection_handle_write	function
(	O
con	pointer
)	O
;	O
ret	int
=	O
MHD_connection_handle_idle	function
(	O
con	pointer
)	O
;	O
}	O
}	O
if	O
(	O
(	O
!	O
con	pointer
->	O
daemon	function
->	O
data_already_pending	bool
)	O
&&	O
(	O
0	int
==	O
(	O
con	pointer
->	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
)	O
{	O
if	O
(	O
MHD_EVENT_LOOP_INFO_BLOCK	int
==	O
con	pointer
->	O
event_loop_info	enum
)	O
con	pointer
->	O
daemon	function
->	O
data_already_pending	bool
=	O
true	int
;	O
}	O
return	O
ret	int
;	O
}	O
static	O
void	O
cleanup_upgraded_connection	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_UpgradeResponseHandle	struct
*	O
urh	pointer
=	O
connection	pointer
->	O
urh	pointer
;	O
if	O
(	O
NULL	O
==	O
urh	pointer
)	O
return	O
;	O
connection	pointer
->	O
urh	pointer
=	O
NULL	O
;	O
free	function
(	O
urh	pointer
)	O
;	O
}	O
static	O
void	O
thread_main_connection_upgrade	function
(	O
struct	O
MHD_Connection	struct
*	O
con	pointer
)	O
{	O
MHD_connection_finish_forward_	O
(	O
con	pointer
)	O
;	O
}	O
static	O
MHD_THRD_RTRN_TYPE_	O
MHD_THRD_CALL_SPEC_	O
thread_main_handle_connection	function
(	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
MHD_Connection	struct
*	O
con	pointer
=	O
data	pointer
;	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
con	pointer
->	O
daemon	function
;	O
int	O
num_ready	int
;	O
fd_set	struct
rs	struct
;	O
fd_set	struct
ws	struct
;	O
fd_set	struct
es	struct
;	O
MHD_socket	int
maxsock	int
;	O
struct	O
timeval	struct
tv	struct
;	O
struct	O
timeval	struct
*	O
tvp	pointer
;	O
time_t	long
now	long
;	O
struct	O
pollfd	struct
p	array
[	O
1	int
+	O
EXTRA_SLOTS	int
]	O
;	O
const	O
bool	bool
use_poll	bool
=	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_POLL	int
)	O
)	O
;	O
bool	bool
was_suspended	bool
=	O
false	int
;	O
MHD_thread_init_	O
(	O
&	O
(	O
con	pointer
->	O
pid	int
)	O
)	O
;	O
while	O
(	O
(	O
!	O
daemon	function
->	O
shutdown	function
)	O
&&	O
(	O
MHD_CONNECTION_CLOSED	int
!=	O
con	pointer
->	O
state	pointer
)	O
)	O
{	O
const	O
time_t	long
timeout	pointer
=	O
daemon	function
->	O
connection_timeout	int
;	O
struct	O
MHD_UpgradeResponseHandle	struct
*	O
const	O
urh	pointer
=	O
con	pointer
->	O
urh	pointer
;	O
if	O
(	O
(	O
con	pointer
->	O
suspended	int
)	O
&&	O
(	O
NULL	O
==	O
urh	pointer
)	O
)	O
{	O
was_suspended	bool
=	O
true	int
;	O
if	O
(	O
!	O
use_poll	bool
)	O
{	O
FD_ZERO	O
(	O
&	O
rs	struct
)	O
;	O
if	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
,	O
&	O
rs	struct
,	O
NULL	O
,	O
FD_SETSIZE	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
_	O
(	O
"Failed to add FD to fd_set\n"	pointer
)	O
)	O
;	O
goto	O
exit	function
;	O
}	O
if	O
(	O
0	int
>	O
MHD_SYS_select_	O
(	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
+	O
1	int
,	O
&	O
rs	struct
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
continue	O
;	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
_	O
(	O
"Error during select (%d): `%s'\n"	pointer
)	O
,	O
err	long
,	O
MHD_socket_strerr_	O
(	O
err	long
)	O
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
p	array
[	O
0	int
]	O
.	O
events	int
=	O
POLLIN	int
;	O
p	array
[	O
0	int
]	O
.	O
fd	int
=	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
p	array
[	O
0	int
]	O
.	O
revents	short
=	O
0	int
;	O
if	O
(	O
0	int
>	O
MHD_sys_poll_	O
(	O
p	array
,	O
1	int
,	O
-	O
1	int
)	O
)	O
{	O
if	O
(	O
MHD_SCKT_LAST_ERR_IS_	O
(	O
MHD_SCKT_EINTR_	O
)	O
)	O
continue	O
;	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
_	O
(	O
"Error during poll: `%s'\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
break	O
;	O
}	O
}	O
MHD_itc_clear_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
was_suspended	bool
)	O
{	O
MHD_update_last_activity_	function
(	O
con	pointer
)	O
;	O
MHD_connection_handle_idle	function
(	O
con	pointer
)	O
;	O
was_suspended	bool
=	O
false	int
;	O
}	O
tvp	pointer
=	O
NULL	O
;	O
if	O
(	O
(	O
MHD_EVENT_LOOP_INFO_BLOCK	int
==	O
con	pointer
->	O
event_loop_info	enum
)	O
)	O
{	O
tv	struct
.	O
tv_sec	long
=	O
0	int
;	O
tv	struct
.	O
tv_usec	long
=	O
0	int
;	O
tvp	pointer
=	O
&	O
tv	struct
;	O
}	O
if	O
(	O
(	O
NULL	O
==	O
tvp	pointer
)	O
&&	O
(	O
timeout	pointer
>	O
0	int
)	O
)	O
{	O
now	long
=	O
MHD_monotonic_sec_counter	function
(	O
)	O
;	O
if	O
(	O
now	long
-	O
con	pointer
->	O
last_activity	long
>	O
timeout	pointer
)	O
tv	struct
.	O
tv_sec	long
=	O
0	int
;	O
else	O
{	O
const	O
time_t	long
seconds_left	long
=	O
timeout	pointer
-	O
(	O
now	long
-	O
con	pointer
->	O
last_activity	long
)	O
;	O
tv	struct
.	O
tv_sec	long
=	O
seconds_left	long
;	O
}	O
tv	struct
.	O
tv_usec	long
=	O
0	int
;	O
tvp	pointer
=	O
&	O
tv	struct
;	O
}	O
if	O
(	O
!	O
use_poll	bool
)	O
{	O
bool	bool
err_state	bool
=	O
false	int
;	O
FD_ZERO	O
(	O
&	O
rs	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
ws	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
es	struct
)	O
;	O
maxsock	int
=	O
MHD_INVALID_SOCKET	O
;	O
switch	O
(	O
con	pointer
->	O
event_loop_info	enum
)	O
{	O
case	O
MHD_EVENT_LOOP_INFO_READ	int
:	O
if	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
rs	struct
,	O
&	O
maxsock	int
,	O
FD_SETSIZE	O
)	O
)	O
err_state	bool
=	O
true	int
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_WRITE	int
:	O
if	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
ws	struct
,	O
&	O
maxsock	int
,	O
FD_SETSIZE	O
)	O
)	O
err_state	bool
=	O
true	int
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_BLOCK	int
:	O
if	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
es	struct
,	O
&	O
maxsock	int
,	O
FD_SETSIZE	O
)	O
)	O
err_state	bool
=	O
true	int
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_CLEANUP	int
:	O
goto	O
exit	function
;	O
}	O
if	O
(	O
err_state	bool
)	O
{	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
_	O
(	O
"Failed to add FD to fd_set\n"	pointer
)	O
)	O
;	O
goto	O
exit	function
;	O
}	O
num_ready	int
=	O
MHD_SYS_select_	O
(	O
maxsock	int
+	O
1	int
,	O
&	O
rs	struct
,	O
&	O
ws	struct
,	O
&	O
es	struct
,	O
tvp	pointer
)	O
;	O
if	O
(	O
num_ready	int
<	O
0	int
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
continue	O
;	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
_	O
(	O
"Error during select (%d): `%s'\n"	pointer
)	O
,	O
err	long
,	O
MHD_socket_strerr_	O
(	O
err	long
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
call_handlers	function
(	O
con	pointer
,	O
FD_ISSET	O
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
rs	struct
)	O
,	O
FD_ISSET	O
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
ws	struct
)	O
,	O
FD_ISSET	O
(	O
con	pointer
->	O
socket_fd	int
,	O
&	O
es	struct
)	O
)	O
)	O
goto	O
exit	function
;	O
}	O
else	O
{	O
memset	function
(	O
&	O
p	array
,	O
0	int
,	O
sizeof	O
(	O
p	array
)	O
)	O
;	O
p	array
[	O
0	int
]	O
.	O
fd	int
=	O
con	pointer
->	O
socket_fd	int
;	O
switch	O
(	O
con	pointer
->	O
event_loop_info	enum
)	O
{	O
case	O
MHD_EVENT_LOOP_INFO_READ	int
:	O
p	array
[	O
0	int
]	O
.	O
events	int
|=	O
POLLIN	int
|	O
MHD_POLL_EVENTS_ERR_DISC	O
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_WRITE	int
:	O
p	array
[	O
0	int
]	O
.	O
events	int
|=	O
POLLOUT	int
|	O
MHD_POLL_EVENTS_ERR_DISC	O
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_BLOCK	int
:	O
p	array
[	O
0	int
]	O
.	O
events	int
|=	O
MHD_POLL_EVENTS_ERR_DISC	O
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_CLEANUP	int
:	O
goto	O
exit	function
;	O
}	O
if	O
(	O
MHD_sys_poll_	O
(	O
p	array
,	O
1	int
,	O
(	O
NULL	O
==	O
tvp	pointer
)	O
?	O
-	O
1	int
:	O
tv	struct
.	O
tv_sec	long
*	O
1000	int
)	O
<	O
0	int
)	O
{	O
if	O
(	O
MHD_SCKT_LAST_ERR_IS_	O
(	O
MHD_SCKT_EINTR_	O
)	O
)	O
continue	O
;	O
MHD_DLOG	function
(	O
con	pointer
->	O
daemon	function
,	O
_	O
(	O
"Error during poll: `%s'\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
MHD_NO	int
==	O
call_handlers	function
(	O
con	pointer
,	O
(	O
0	int
!=	O
(	O
p	array
[	O
0	int
]	O
.	O
revents	short
&	O
POLLIN	int
)	O
)	O
,	O
(	O
0	int
!=	O
(	O
p	array
[	O
0	int
]	O
.	O
revents	short
&	O
POLLOUT	int
)	O
)	O
,	O
(	O
0	int
!=	O
(	O
p	array
[	O
0	int
]	O
.	O
revents	short
&	O
(	O
POLLERR	int
|	O
MHD_POLL_REVENTS_ERR_DISC	O
)	O
)	O
)	O
)	O
)	O
goto	O
exit	function
;	O
}	O
if	O
(	O
MHD_CONNECTION_UPGRADE	int
==	O
con	pointer
->	O
state	pointer
)	O
{	O
if	O
(	O
(	O
NULL	O
!=	O
daemon	function
->	O
notify_completed	pointer
)	O
&&	O
(	O
con	pointer
->	O
client_aware	bool
)	O
)	O
daemon	function
->	O
notify_completed	pointer
(	O
daemon	function
->	O
notify_completed_cls	pointer
,	O
con	pointer
,	O
&	O
con	pointer
->	O
client_context	pointer
,	O
MHD_REQUEST_TERMINATED_COMPLETED_OK	int
)	O
;	O
con	pointer
->	O
client_aware	bool
=	O
false	int
;	O
thread_main_connection_upgrade	function
(	O
con	pointer
)	O
;	O
con	pointer
->	O
urh	pointer
->	O
clean_ready	bool
=	O
true	int
;	O
MHD_resume_connection	function
(	O
con	pointer
)	O
;	O
return	O
(	O
MHD_THRD_RTRN_TYPE_	O
)	O
0	int
;	O
}	O
}	O
if	O
(	O
MHD_CONNECTION_CLOSED	int
!=	O
con	pointer
->	O
state	pointer
)	O
MHD_connection_close_	function
(	O
con	pointer
,	O
(	O
daemon	function
->	O
shutdown	function
)	O
?	O
MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN	int
:	O
MHD_REQUEST_TERMINATED_WITH_ERROR	int
)	O
;	O
MHD_connection_handle_idle	function
(	O
con	pointer
)	O
;	O
exit	function
:	O
if	O
(	O
NULL	O
!=	O
con	pointer
->	O
response	pointer
)	O
{	O
MHD_destroy_response	function
(	O
con	pointer
->	O
response	pointer
)	O
;	O
con	pointer
->	O
response	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
con	pointer
->	O
socket_fd	int
)	O
{	O
shutdown	function
(	O
con	pointer
->	O
socket_fd	int
,	O
SHUT_WR	int
)	O
;	O
}	O
if	O
(	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
&&	O
(	O
!	O
MHD_itc_activate_	O
(	O
daemon	function
->	O
itc	struct
,	O
"t"	pointer
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to signal thread termination via inter-thread communication channel."	pointer
)	O
)	O
;	O
}	O
return	O
(	O
MHD_THRD_RTRN_TYPE_	O
)	O
0	int
;	O
}	O
static	O
void	O
MHD_cleanup_connections	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
;	O
static	O
int	O
internal_add_connection	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
MHD_socket	int
client_socket	int
,	O
const	O
struct	O
sockaddr	struct
*	O
addr	pointer
,	O
socklen_t	int
addrlen	int
,	O
bool	bool
external_add	bool
,	O
bool	bool
non_blck	bool
)	O
{	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
;	O
unsigned	O
int	O
i	int
;	O
int	O
eno	int
=	O
0	int
;	O
mhd_assert	O
(	O
(	O
NULL	O
==	O
daemon	function
->	O
worker_pool	pointer
)	O
||	O
(	O
external_add	bool
)	O
)	O
;	O
if	O
(	O
(	O
external_add	bool
)	O
&&	O
(	O
NULL	O
!=	O
daemon	function
->	O
worker_pool	pointer
)	O
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
daemon	function
->	O
worker_pool_size	int
;	O
++	O
i	int
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
const	O
worker	pointer
=	O
&	O
daemon	function
->	O
worker_pool	pointer
[	O
(	O
i	int
+	O
client_socket	int
)	O
%	O
daemon	function
->	O
worker_pool_size	int
]	O
;	O
if	O
(	O
worker	pointer
->	O
connections	int
<	O
worker	pointer
->	O
connection_limit	int
)	O
return	O
internal_add_connection	function
(	O
worker	pointer
,	O
client_socket	int
,	O
addr	pointer
,	O
addrlen	int
,	O
true	int
,	O
non_blck	bool
)	O
;	O
}	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
errno	O
=	O
ENFILE	int
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
!	O
MHD_SCKT_FD_FITS_FDSET_	O
(	O
client_socket	int
,	O
NULL	O
)	O
)	O
&&	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
(	O
MHD_USE_POLL	int
|	O
MHD_USE_EPOLL	int
)	O
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Socket descriptor larger than FD_SETSIZE: %d > %d\n"	pointer
)	O
,	O
(	O
int	O
)	O
client_socket	int
,	O
(	O
int	O
)	O
FD_SETSIZE	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
errno	O
=	O
EINVAL	int
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
daemon	function
->	O
connections	int
==	O
daemon	function
->	O
connection_limit	int
)	O
||	O
(	O
MHD_NO	int
==	O
MHD_ip_limit_add	function
(	O
daemon	function
,	O
addr	pointer
,	O
addrlen	int
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Server reached connection limit. Closing inbound connection.\n"	pointer
)	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
errno	O
=	O
ENFILE	int
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
NULL	O
!=	O
daemon	function
->	O
apc	pointer
)	O
&&	O
(	O
MHD_NO	int
==	O
daemon	function
->	O
apc	pointer
(	O
daemon	function
->	O
apc_cls	pointer
,	O
addr	pointer
,	O
addrlen	int
)	O
)	O
)	O
{	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
MHD_ip_limit_del	function
(	O
daemon	function
,	O
addr	pointer
,	O
addrlen	int
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
NULL	O
==	O
(	O
connection	pointer
=	O
MHD_calloc_	O
(	O
1	int
,	O
sizeof	O
(	O
struct	O
MHD_Connection	struct
)	O
)	O
)	O
)	O
{	O
eno	int
=	O
errno	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
"Error allocating memory: %s\n"	pointer
,	O
MHD_strerror_	O
(	O
errno	O
)	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
MHD_ip_limit_del	function
(	O
daemon	function
,	O
addr	pointer
,	O
addrlen	int
)	O
;	O
errno	O
=	O
eno	int
;	O
return	O
MHD_NO	int
;	O
}	O
connection	pointer
->	O
pool	pointer
=	O
MHD_pool_create	function
(	O
daemon	function
->	O
pool_size	long
)	O
;	O
if	O
(	O
NULL	O
==	O
connection	pointer
->	O
pool	pointer
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Error allocating memory: %s\n"	pointer
)	O
,	O
MHD_strerror_	O
(	O
errno	O
)	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
MHD_ip_limit_del	function
(	O
daemon	function
,	O
addr	pointer
,	O
addrlen	int
)	O
;	O
free	function
(	O
connection	pointer
)	O
;	O
errno	O
=	O
ENOMEM	int
;	O
return	O
MHD_NO	int
;	O
}	O
connection	pointer
->	O
connection_timeout	int
=	O
daemon	function
->	O
connection_timeout	int
;	O
if	O
(	O
NULL	O
==	O
(	O
connection	pointer
->	O
addr	pointer
=	O
malloc	function
(	O
addrlen	int
)	O
)	O
)	O
{	O
eno	int
=	O
errno	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Error allocating memory: %s\n"	pointer
)	O
,	O
MHD_strerror_	O
(	O
errno	O
)	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
MHD_ip_limit_del	function
(	O
daemon	function
,	O
addr	pointer
,	O
addrlen	int
)	O
;	O
MHD_pool_destroy	function
(	O
connection	pointer
->	O
pool	pointer
)	O
;	O
free	function
(	O
connection	pointer
)	O
;	O
errno	O
=	O
eno	int
;	O
return	O
MHD_NO	int
;	O
}	O
memcpy	function
(	O
connection	pointer
->	O
addr	pointer
,	O
addr	pointer
,	O
addrlen	int
)	O
;	O
connection	pointer
->	O
addr_len	int
=	O
addrlen	int
;	O
connection	pointer
->	O
socket_fd	int
=	O
client_socket	int
;	O
connection	pointer
->	O
sk_nonblck	bool
=	O
non_blck	bool
;	O
connection	pointer
->	O
daemon	function
=	O
daemon	function
;	O
connection	pointer
->	O
last_activity	long
=	O
MHD_monotonic_sec_counter	function
(	O
)	O
;	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_TLS	int
)	O
)	O
{	O
MHD_set_http_callbacks_	function
(	O
connection	pointer
)	O
;	O
}	O
else	O
{	O
eno	int
=	O
EINVAL	int
;	O
goto	O
cleanup	O
;	O
}	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
daemon	function
->	O
connections	int
>=	O
daemon	function
->	O
connection_limit	int
)	O
{	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Server reached connection limit. Closing inbound connection.\n"	pointer
)	O
)	O
;	O
eno	int
=	O
ENFILE	int
;	O
goto	O
cleanup	O
;	O
}	O
daemon	function
->	O
connections	int
++	O
;	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
XDLL_insert	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
DLL_insert	O
(	O
daemon	function
->	O
connections_head	pointer
,	O
daemon	function
->	O
connections_tail	pointer
,	O
connection	pointer
)	O
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
notify_connection	pointer
)	O
daemon	function
->	O
notify_connection	pointer
(	O
daemon	function
->	O
notify_connection_cls	pointer
,	O
connection	pointer
,	O
&	O
connection	pointer
->	O
socket_context	pointer
,	O
MHD_CONNECTION_NOTIFY_STARTED	int
)	O
;	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
if	O
(	O
!	O
MHD_create_named_thread_	function
(	O
&	O
connection	pointer
->	O
pid	int
,	O
"MHD-connection"	pointer
,	O
daemon	function
->	O
thread_stack_size	long
,	O
&	O
thread_main_handle_connection	function
,	O
connection	pointer
)	O
)	O
{	O
eno	int
=	O
errno	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
"Failed to create a thread: %s\n"	pointer
,	O
MHD_strerror_	O
(	O
eno	int
)	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
}	O
else	O
connection	pointer
->	O
pid	int
=	O
daemon	function
->	O
pid	int
;	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
{	O
if	O
(	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_TURBO	int
)	O
)	O
||	O
(	O
external_add	bool
)	O
)	O
{	O
struct	O
epoll_event	struct
event	struct
;	O
event	struct
.	O
events	int
=	O
EPOLLIN	int
|	O
EPOLLOUT	int
|	O
EPOLLPRI	int
|	O
EPOLLET	int
;	O
event	struct
.	O
data	pointer
.	O
ptr	pointer
=	O
connection	pointer
;	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_ADD	int
,	O
client_socket	int
,	O
&	O
event	struct
)	O
)	O
{	O
eno	int
=	O
errno	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Call to epoll_ctl failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
goto	O
cleanup	O
;	O
}	O
connection	pointer
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
;	O
}	O
else	O
{	O
connection	pointer
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_READ_READY	int
|	O
MHD_EPOLL_STATE_WRITE_READY	int
|	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
EDLL_insert	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
&&	O
(	O
external_add	bool
)	O
&&	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
&&	O
(	O
!	O
MHD_itc_activate_	O
(	O
daemon	function
->	O
itc	struct
,	O
"n"	pointer
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to signal new connection via inter-thread communication channel."	pointer
)	O
)	O
;	O
}	O
return	O
MHD_YES	int
;	O
cleanup	O
:	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
notify_connection	pointer
)	O
daemon	function
->	O
notify_connection	pointer
(	O
daemon	function
->	O
notify_connection_cls	pointer
,	O
connection	pointer
,	O
&	O
connection	pointer
->	O
socket_context	pointer
,	O
MHD_CONNECTION_NOTIFY_CLOSED	int
)	O
;	O
MHD_socket_close_chk_	O
(	O
client_socket	int
)	O
;	O
MHD_ip_limit_del	function
(	O
daemon	function
,	O
addr	pointer
,	O
addrlen	int
)	O
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
XDLL_remove	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
DLL_remove	O
(	O
daemon	function
->	O
connections_head	pointer
,	O
daemon	function
->	O
connections_tail	pointer
,	O
connection	pointer
)	O
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
MHD_pool_destroy	function
(	O
connection	pointer
->	O
pool	pointer
)	O
;	O
free	function
(	O
connection	pointer
->	O
addr	pointer
)	O
;	O
free	function
(	O
connection	pointer
)	O
;	O
if	O
(	O
0	int
!=	O
eno	int
)	O
errno	O
=	O
eno	int
;	O
else	O
errno	O
=	O
EINVAL	int
;	O
return	O
MHD_NO	int
;	O
}	O
void	O
internal_suspend_connection_	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
connection	pointer
->	O
resuming	bool
)	O
{	O
connection	pointer
->	O
resuming	bool
=	O
false	int
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
return	O
;	O
}	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
if	O
(	O
connection	pointer
->	O
connection_timeout	int
==	O
daemon	function
->	O
connection_timeout	int
)	O
XDLL_remove	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
else	O
XDLL_remove	O
(	O
daemon	function
->	O
manual_timeout_head	pointer
,	O
daemon	function
->	O
manual_timeout_tail	pointer
,	O
connection	pointer
)	O
;	O
}	O
DLL_remove	O
(	O
daemon	function
->	O
connections_head	pointer
,	O
daemon	function
->	O
connections_tail	pointer
,	O
connection	pointer
)	O
;	O
mhd_assert	O
(	O
!	O
connection	pointer
->	O
suspended	int
)	O
;	O
DLL_insert	O
(	O
daemon	function
->	O
suspended_connections_head	pointer
,	O
daemon	function
->	O
suspended_connections_tail	pointer
,	O
connection	pointer
)	O
;	O
connection	pointer
->	O
suspended	int
=	O
true	int
;	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
(	O
connection	pointer
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
{	O
EDLL_remove	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
connection	pointer
)	O
;	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
}	O
if	O
(	O
0	int
!=	O
(	O
connection	pointer
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_DEL	int
,	O
connection	pointer
->	O
socket_fd	int
,	O
NULL	O
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to remove FD from epoll set\n"	pointer
)	O
)	O
;	O
connection	pointer
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
;	O
}	O
connection	pointer
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_SUSPENDED	int
;	O
}	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
}	O
void	O
MHD_suspend_connection	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
const	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_TEST_ALLOW_SUSPEND_RESUME	int
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Cannot suspend connections without enabling MHD_ALLOW_SUSPEND_RESUME!\n"	pointer
)	O
)	O
;	O
if	O
(	O
NULL	O
!=	O
connection	pointer
->	O
urh	pointer
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Error: connection scheduled for \"upgrade\" cannot be suspended"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
internal_suspend_connection_	function
(	O
connection	pointer
)	O
;	O
}	O
void	O
MHD_resume_connection	function
(	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_TEST_ALLOW_SUSPEND_RESUME	int
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Cannot resume connections without enabling MHD_ALLOW_SUSPEND_RESUME!\n"	pointer
)	O
)	O
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
connection	pointer
->	O
resuming	bool
=	O
true	int
;	O
daemon	function
->	O
resuming	bool
=	O
true	int
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
&&	O
(	O
!	O
MHD_itc_activate_	O
(	O
daemon	function
->	O
itc	struct
,	O
"r"	pointer
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to signal resume via inter-thread communication channel."	pointer
)	O
)	O
;	O
}	O
}	O
static	O
int	O
resume_suspended_connections	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
struct	O
MHD_Connection	struct
*	O
pos	long
;	O
struct	O
MHD_Connection	struct
*	O
prev	pointer
=	O
NULL	O
;	O
int	O
ret	int
;	O
const	O
bool	bool
used_thr_p_c	bool
=	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
;	O
mhd_assert	O
(	O
NULL	O
==	O
daemon	function
->	O
worker_pool	pointer
)	O
;	O
ret	int
=	O
MHD_NO	int
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
daemon	function
->	O
resuming	bool
)	O
{	O
prev	pointer
=	O
daemon	function
->	O
suspended_connections_tail	pointer
;	O
mhd_assert	O
(	O
(	O
NULL	O
!=	O
prev	pointer
)	O
||	O
(	O
daemon	function
->	O
shutdown	function
)	O
)	O
;	O
}	O
daemon	function
->	O
resuming	bool
=	O
false	int
;	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
prev	pointer
)	O
)	O
{	O
struct	O
MHD_UpgradeResponseHandle	struct
*	O
const	O
urh	pointer
=	O
pos	long
->	O
urh	pointer
;	O
prev	pointer
=	O
pos	long
->	O
prev	pointer
;	O
if	O
(	O
(	O
!	O
pos	long
->	O
resuming	bool
)	O
||	O
(	O
(	O
NULL	O
!=	O
urh	pointer
)	O
&&	O
(	O
(	O
!	O
urh	pointer
->	O
was_closed	bool
)	O
||	O
(	O
!	O
urh	pointer
->	O
clean_ready	bool
)	O
)	O
)	O
)	O
continue	O
;	O
ret	int
=	O
MHD_YES	int
;	O
mhd_assert	O
(	O
pos	long
->	O
suspended	int
)	O
;	O
DLL_remove	O
(	O
daemon	function
->	O
suspended_connections_head	pointer
,	O
daemon	function
->	O
suspended_connections_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
suspended	int
=	O
false	int
;	O
if	O
(	O
NULL	O
==	O
urh	pointer
)	O
{	O
DLL_insert	O
(	O
daemon	function
->	O
connections_head	pointer
,	O
daemon	function
->	O
connections_tail	pointer
,	O
pos	long
)	O
;	O
if	O
(	O
!	O
used_thr_p_c	bool
)	O
{	O
if	O
(	O
0	int
!=	O
pos	long
->	O
connection_timeout	int
)	O
pos	long
->	O
last_activity	long
=	O
MHD_monotonic_sec_counter	function
(	O
)	O
;	O
if	O
(	O
pos	long
->	O
connection_timeout	int
==	O
daemon	function
->	O
connection_timeout	int
)	O
XDLL_insert	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
pos	long
)	O
;	O
else	O
XDLL_insert	O
(	O
daemon	function
->	O
manual_timeout_head	pointer
,	O
daemon	function
->	O
manual_timeout_tail	pointer
,	O
pos	long
)	O
;	O
}	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
MHD_PANIC	O
(	O
"Resumed connection was already in EREADY set\n"	pointer
)	O
;	O
EDLL_insert	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
|	O
MHD_EPOLL_STATE_READ_READY	int
|	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
pos	long
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_SUSPENDED	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
NULL	O
!=	O
daemon	function
->	O
notify_completed	pointer
)	O
&&	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
&&	O
(	O
pos	long
->	O
client_aware	bool
)	O
)	O
{	O
daemon	function
->	O
notify_completed	pointer
(	O
daemon	function
->	O
notify_completed_cls	pointer
,	O
pos	long
,	O
&	O
pos	long
->	O
client_context	pointer
,	O
MHD_REQUEST_TERMINATED_COMPLETED_OK	int
)	O
;	O
pos	long
->	O
client_aware	bool
=	O
false	int
;	O
}	O
DLL_insert	O
(	O
daemon	function
->	O
cleanup_head	pointer
,	O
daemon	function
->	O
cleanup_tail	pointer
,	O
pos	long
)	O
;	O
}	O
pos	long
->	O
resuming	bool
=	O
false	int
;	O
}	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
(	O
used_thr_p_c	bool
)	O
&&	O
(	O
MHD_NO	int
!=	O
ret	int
)	O
)	O
{	O
if	O
(	O
!	O
MHD_itc_activate_	O
(	O
daemon	function
->	O
itc	struct
,	O
"w"	pointer
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to signal resume of connection via inter-thread communication channel."	pointer
)	O
)	O
;	O
}	O
}	O
return	O
ret	int
;	O
}	O
int	O
MHD_add_connection	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
MHD_socket	int
client_socket	int
,	O
const	O
struct	O
sockaddr	struct
*	O
addr	pointer
,	O
socklen_t	int
addrlen	int
)	O
{	O
bool	bool
sk_nonbl	bool
;	O
MHD_cleanup_connections	function
(	O
daemon	function
)	O
;	O
if	O
(	O
!	O
MHD_socket_nonblocking_	function
(	O
client_socket	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to set nonblocking mode on new client socket: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
sk_nonbl	bool
=	O
false	int
;	O
}	O
else	O
sk_nonbl	bool
=	O
true	int
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_TURBO	int
)	O
)	O
&&	O
(	O
!	O
MHD_socket_noninheritable_	function
(	O
client_socket	int
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to set noninheritable mode on new client socket.\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_TURBO	int
)	O
)	O
&&	O
(	O
!	O
MHD_socket_buffering_reset_	function
(	O
client_socket	int
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to reset buffering mode on new client socket.\n"	pointer
)	O
)	O
;	O
}	O
return	O
internal_add_connection	function
(	O
daemon	function
,	O
client_socket	int
,	O
addr	pointer
,	O
addrlen	int
,	O
true	int
,	O
sk_nonbl	bool
)	O
;	O
}	O
static	O
int	O
MHD_accept_connection	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
struct	O
sockaddr_in6	struct
addrstorage	struct
;	O
struct	O
sockaddr	struct
*	O
addr	pointer
=	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
addrstorage	struct
;	O
socklen_t	int
addrlen	int
;	O
MHD_socket	int
s	int
;	O
MHD_socket	int
fd	int
;	O
bool	bool
sk_nonbl	bool
;	O
addrlen	int
=	O
sizeof	O
(	O
addrstorage	struct
)	O
;	O
memset	function
(	O
addr	pointer
,	O
0	int
,	O
sizeof	O
(	O
addrstorage	struct
)	O
)	O
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
==	O
(	O
fd	int
=	O
daemon	function
->	O
listen_fd	int
)	O
)	O
||	O
(	O
daemon	function
->	O
was_quiesced	bool
)	O
)	O
return	O
MHD_NO	int
;	O
s	int
=	O
accept4	function
(	O
fd	int
,	O
addr	pointer
,	O
&	O
addrlen	int
,	O
MAYBE_SOCK_CLOEXEC	O
|	O
MAYBE_SOCK_NONBLOCK	O
|	O
MAYBE_SOCK_NOSIGPIPE	int
)	O
;	O
sk_nonbl	bool
=	O
(	O
MAYBE_SOCK_NONBLOCK	O
!=	O
0	int
)	O
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
==	O
s	int
)	O
||	O
(	O
addrlen	int
<=	O
0	int
)	O
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_	O
(	O
err	long
,	O
MHD_SCKT_EINVAL_	O
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
MHD_SCKT_ERR_IS_DISCNN_BEFORE_ACCEPT_	O
(	O
err	long
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
!	O
MHD_SCKT_ERR_IS_EAGAIN_	O
(	O
err	long
)	O
)	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Error accepting connection: %s\n"	pointer
)	O
,	O
MHD_socket_strerr_	O
(	O
err	long
)	O
)	O
;	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
s	int
)	O
{	O
MHD_socket_close_chk_	O
(	O
s	int
)	O
;	O
}	O
if	O
(	O
MHD_SCKT_ERR_IS_LOW_RESOURCES_	O
(	O
err	long
)	O
)	O
{	O
if	O
(	O
0	int
==	O
daemon	function
->	O
connections	int
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Hit process or system resource limit at FIRST connection. This is really bad as there is no sane way to proceed. Will try busy waiting for system resources to become magically available.\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
daemon	function
->	O
at_limit	bool
=	O
true	int
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Hit process or system resource limit at %u connections, temporarily suspending accept(). Consider setting a lower MHD_OPTION_CONNECTION_LIMIT.\n"	pointer
)	O
,	O
(	O
unsigned	O
int	O
)	O
daemon	function
->	O
connections	int
)	O
;	O
}	O
}	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
0	int
!=	O
MHD_socket_set_nodelay_	function
(	O
s	int
,	O
true	int
)	O
)	O
&&	O
(	O
EOPNOTSUPP	int
!=	O
errno	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to disable TCP Nagle on socket: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
}	O
(	O
void	O
)	O
internal_add_connection	function
(	O
daemon	function
,	O
s	int
,	O
addr	pointer
,	O
addrlen	int
,	O
false	int
,	O
sk_nonbl	bool
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
MHD_cleanup_connections	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
struct	O
MHD_Connection	struct
*	O
pos	long
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
daemon	function
->	O
cleanup_tail	pointer
)	O
)	O
{	O
DLL_remove	O
(	O
daemon	function
->	O
cleanup_head	pointer
,	O
daemon	function
->	O
cleanup_tail	pointer
,	O
pos	long
)	O
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
&&	O
(	O
!	O
pos	long
->	O
thread_joined	bool
)	O
&&	O
(	O
!	O
MHD_join_thread_	O
(	O
pos	long
->	O
pid	int
.	O
handle	long
)	O
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to join a thread\n"	pointer
)	O
)	O
;	O
cleanup_upgraded_connection	function
(	O
pos	long
)	O
;	O
MHD_pool_destroy	function
(	O
pos	long
->	O
pool	pointer
)	O
;	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
notify_connection	pointer
)	O
daemon	function
->	O
notify_connection	pointer
(	O
daemon	function
->	O
notify_connection_cls	pointer
,	O
pos	long
,	O
&	O
pos	long
->	O
socket_context	pointer
,	O
MHD_CONNECTION_NOTIFY_CLOSED	int
)	O
;	O
MHD_ip_limit_del	function
(	O
daemon	function
,	O
pos	long
->	O
addr	pointer
,	O
pos	long
->	O
addr_len	int
)	O
;	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
{	O
EDLL_remove	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
}	O
if	O
(	O
(	O
-	O
1	int
!=	O
daemon	function
->	O
epoll_fd	int
)	O
&&	O
(	O
0	int
!=	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
)	O
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_DEL	int
,	O
pos	long
->	O
socket_fd	int
,	O
NULL	O
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to remove FD from epoll set\n"	pointer
)	O
)	O
;	O
pos	long
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_IN_EPOLL_SET	int
;	O
}	O
}	O
if	O
(	O
NULL	O
!=	O
pos	long
->	O
response	pointer
)	O
{	O
MHD_destroy_response	function
(	O
pos	long
->	O
response	pointer
)	O
;	O
pos	long
->	O
response	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
pos	long
->	O
socket_fd	int
)	O
MHD_socket_close_chk_	O
(	O
pos	long
->	O
socket_fd	int
)	O
;	O
if	O
(	O
NULL	O
!=	O
pos	long
->	O
addr	pointer
)	O
free	function
(	O
pos	long
->	O
addr	pointer
)	O
;	O
free	function
(	O
pos	long
)	O
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
daemon	function
->	O
connections	int
--	O
;	O
daemon	function
->	O
at_limit	bool
=	O
false	int
;	O
}	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
}	O
int	O
MHD_get_timeout	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
MHD_UNSIGNED_LONG_LONG	O
*	O
timeout	pointer
)	O
{	O
time_t	long
earliest_deadline	long
;	O
time_t	long
now	long
;	O
struct	O
MHD_Connection	struct
*	O
pos	long
;	O
bool	bool
have_timeout	bool
;	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Illegal call to MHD_get_timeout\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
daemon	function
->	O
data_already_pending	bool
)	O
{	O
*	O
timeout	pointer
=	O
0	int
;	O
return	O
MHD_YES	int
;	O
}	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
&&	O
(	O
(	O
NULL	O
!=	O
daemon	function
->	O
eready_head	pointer
)	O
)	O
)	O
{	O
*	O
timeout	pointer
=	O
0	int
;	O
return	O
MHD_YES	int
;	O
}	O
have_timeout	bool
=	O
false	int
;	O
earliest_deadline	long
=	O
0	int
;	O
for	O
(	O
pos	long
=	O
daemon	function
->	O
manual_timeout_tail	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
prevX	pointer
)	O
{	O
if	O
(	O
0	int
!=	O
pos	long
->	O
connection_timeout	int
)	O
{	O
if	O
(	O
(	O
!	O
have_timeout	bool
)	O
||	O
(	O
earliest_deadline	long
-	O
pos	long
->	O
last_activity	long
>	O
pos	long
->	O
connection_timeout	int
)	O
)	O
earliest_deadline	long
=	O
pos	long
->	O
last_activity	long
+	O
pos	long
->	O
connection_timeout	int
;	O
have_timeout	bool
=	O
true	int
;	O
}	O
}	O
pos	long
=	O
daemon	function
->	O
normal_timeout_tail	pointer
;	O
if	O
(	O
(	O
NULL	O
!=	O
pos	long
)	O
&&	O
(	O
0	int
!=	O
pos	long
->	O
connection_timeout	int
)	O
)	O
{	O
if	O
(	O
(	O
!	O
have_timeout	bool
)	O
||	O
(	O
earliest_deadline	long
-	O
pos	long
->	O
connection_timeout	int
>	O
pos	long
->	O
last_activity	long
)	O
)	O
earliest_deadline	long
=	O
pos	long
->	O
last_activity	long
+	O
pos	long
->	O
connection_timeout	int
;	O
have_timeout	bool
=	O
true	int
;	O
}	O
if	O
(	O
!	O
have_timeout	bool
)	O
return	O
MHD_NO	int
;	O
now	long
=	O
MHD_monotonic_sec_counter	function
(	O
)	O
;	O
if	O
(	O
earliest_deadline	long
<	O
now	long
)	O
*	O
timeout	pointer
=	O
0	int
;	O
else	O
{	O
const	O
time_t	long
second_left	long
=	O
earliest_deadline	long
-	O
now	long
;	O
if	O
(	O
(	O
(	O
unsigned	O
long	O
long	O
)	O
second_left	long
)	O
>	O
ULLONG_MAX	O
/	O
1000	int
)	O
*	O
timeout	pointer
=	O
ULLONG_MAX	O
;	O
else	O
*	O
timeout	pointer
=	O
1000LLU	int
*	O
(	O
unsigned	O
long	O
long	O
)	O
second_left	long
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
internal_run_from_select	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
const	O
fd_set	struct
*	O
read_fd_set	pointer
,	O
const	O
fd_set	struct
*	O
write_fd_set	pointer
,	O
const	O
fd_set	struct
*	O
except_fd_set	pointer
)	O
{	O
MHD_socket	int
ds	int
;	O
struct	O
MHD_Connection	struct
*	O
pos	long
;	O
struct	O
MHD_Connection	struct
*	O
prev	pointer
;	O
daemon	function
->	O
data_already_pending	bool
=	O
false	int
;	O
if	O
(	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
&&	O
(	O
FD_ISSET	O
(	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
,	O
read_fd_set	pointer
)	O
)	O
)	O
MHD_itc_clear_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
!=	O
(	O
ds	int
=	O
daemon	function
->	O
listen_fd	int
)	O
)	O
&&	O
(	O
!	O
daemon	function
->	O
was_quiesced	bool
)	O
&&	O
(	O
FD_ISSET	O
(	O
ds	int
,	O
read_fd_set	pointer
)	O
)	O
)	O
(	O
void	O
)	O
MHD_accept_connection	function
(	O
daemon	function
)	O
;	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
prev	pointer
=	O
daemon	function
->	O
connections_tail	pointer
;	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
prev	pointer
)	O
)	O
{	O
prev	pointer
=	O
pos	long
->	O
prev	pointer
;	O
ds	int
=	O
pos	long
->	O
socket_fd	int
;	O
if	O
(	O
MHD_INVALID_SOCKET	O
==	O
ds	int
)	O
continue	O
;	O
call_handlers	function
(	O
pos	long
,	O
FD_ISSET	O
(	O
ds	int
,	O
read_fd_set	pointer
)	O
,	O
FD_ISSET	O
(	O
ds	int
,	O
write_fd_set	pointer
)	O
,	O
FD_ISSET	O
(	O
ds	int
,	O
except_fd_set	pointer
)	O
)	O
;	O
}	O
}	O
MHD_cleanup_connections	function
(	O
daemon	function
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
int	O
MHD_run_from_select	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
const	O
fd_set	struct
*	O
read_fd_set	pointer
,	O
const	O
fd_set	struct
*	O
write_fd_set	pointer
,	O
const	O
fd_set	struct
*	O
except_fd_set	pointer
)	O
{	O
fd_set	struct
es	struct
;	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
(	O
MHD_USE_INTERNAL_POLLING_THREAD	int
|	O
MHD_USE_POLL	int
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
(	O
NULL	O
==	O
read_fd_set	pointer
)	O
||	O
(	O
NULL	O
==	O
write_fd_set	pointer
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
NULL	O
==	O
except_fd_set	pointer
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"MHD_run_from_select() called with except_fd_set "	pointer
"set to NULL. Such behavior is deprecated.\n"	pointer
)	O
)	O
;	O
FD_ZERO	O
(	O
&	O
es	struct
)	O
;	O
except_fd_set	pointer
=	O
&	O
es	struct
;	O
}	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
{	O
int	O
ret	int
=	O
MHD_epoll	function
(	O
daemon	function
,	O
MHD_NO	int
)	O
;	O
MHD_cleanup_connections	function
(	O
daemon	function
)	O
;	O
return	O
ret	int
;	O
}	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_TEST_ALLOW_SUSPEND_RESUME	int
)	O
)	O
resume_suspended_connections	function
(	O
daemon	function
)	O
;	O
return	O
internal_run_from_select	function
(	O
daemon	function
,	O
read_fd_set	pointer
,	O
write_fd_set	pointer
,	O
except_fd_set	pointer
)	O
;	O
}	O
static	O
int	O
MHD_select	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
int	O
may_block	int
)	O
{	O
int	O
num_ready	int
;	O
fd_set	struct
rs	struct
;	O
fd_set	struct
ws	struct
;	O
fd_set	struct
es	struct
;	O
MHD_socket	int
maxsock	int
;	O
struct	O
timeval	struct
timeout	pointer
;	O
struct	O
timeval	struct
*	O
tv	struct
;	O
MHD_UNSIGNED_LONG_LONG	O
ltimeout	long long
;	O
int	O
err_state	bool
;	O
MHD_socket	int
ls	int
;	O
timeout	pointer
.	O
tv_sec	long
=	O
0	int
;	O
timeout	pointer
.	O
tv_usec	long
=	O
0	int
;	O
if	O
(	O
daemon	function
->	O
shutdown	function
)	O
return	O
MHD_NO	int
;	O
FD_ZERO	O
(	O
&	O
rs	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
ws	struct
)	O
;	O
FD_ZERO	O
(	O
&	O
es	struct
)	O
;	O
maxsock	int
=	O
MHD_INVALID_SOCKET	O
;	O
err_state	bool
=	O
MHD_NO	int
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_TEST_ALLOW_SUSPEND_RESUME	int
)	O
)	O
&&	O
(	O
MHD_YES	int
==	O
resume_suspended_connections	function
(	O
daemon	function
)	O
)	O
&&	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
)	O
may_block	int
=	O
MHD_NO	int
;	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
if	O
(	O
MHD_NO	int
==	O
internal_get_fdset2	function
(	O
daemon	function
,	O
&	O
rs	struct
,	O
&	O
ws	struct
,	O
&	O
es	struct
,	O
&	O
maxsock	int
,	O
FD_SETSIZE	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Could not obtain daemon fdsets"	pointer
)	O
)	O
;	O
err_state	bool
=	O
MHD_YES	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
!=	O
(	O
ls	int
=	O
daemon	function
->	O
listen_fd	int
)	O
)	O
&&	O
(	O
!	O
daemon	function
->	O
was_quiesced	bool
)	O
&&	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
ls	int
,	O
&	O
rs	struct
,	O
&	O
maxsock	int
,	O
FD_SETSIZE	O
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Could not add listen socket to fdset"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
}	O
if	O
(	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
&&	O
(	O
!	O
MHD_add_to_fd_set_	function
(	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
,	O
&	O
rs	struct
,	O
&	O
maxsock	int
,	O
FD_SETSIZE	O
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Could not add control inter-thread communication channel FD to fdset"	pointer
)	O
)	O
;	O
err_state	bool
=	O
MHD_YES	int
;	O
}	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
!=	O
(	O
ls	int
=	O
daemon	function
->	O
listen_fd	int
)	O
)	O
&&	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
&&	O
(	O
(	O
daemon	function
->	O
connections	int
==	O
daemon	function
->	O
connection_limit	int
)	O
||	O
(	O
daemon	function
->	O
at_limit	bool
)	O
)	O
)	O
{	O
FD_CLR	O
(	O
ls	int
,	O
&	O
rs	struct
)	O
;	O
}	O
tv	struct
=	O
NULL	O
;	O
if	O
(	O
MHD_YES	int
==	O
err_state	bool
)	O
may_block	int
=	O
MHD_NO	int
;	O
if	O
(	O
MHD_NO	int
==	O
may_block	int
)	O
{	O
timeout	pointer
.	O
tv_usec	long
=	O
0	int
;	O
timeout	pointer
.	O
tv_sec	long
=	O
0	int
;	O
tv	struct
=	O
&	O
timeout	pointer
;	O
}	O
else	O
if	O
(	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
&&	O
(	O
MHD_YES	int
==	O
MHD_get_timeout	function
(	O
daemon	function
,	O
&	O
ltimeout	long long
)	O
)	O
)	O
{	O
timeout	pointer
.	O
tv_usec	long
=	O
(	O
ltimeout	long long
%	O
1000	int
)	O
*	O
1000	int
;	O
if	O
(	O
ltimeout	long long
/	O
1000	int
>	O
TIMEVAL_TV_SEC_MAX	O
)	O
timeout	pointer
.	O
tv_sec	long
=	O
TIMEVAL_TV_SEC_MAX	O
;	O
else	O
timeout	pointer
.	O
tv_sec	long
=	O
(	O
_MHD_TIMEVAL_TV_SEC_TYPE	long
)	O
(	O
ltimeout	long long
/	O
1000	int
)	O
;	O
tv	struct
=	O
&	O
timeout	pointer
;	O
}	O
num_ready	int
=	O
MHD_SYS_select_	O
(	O
maxsock	int
+	O
1	int
,	O
&	O
rs	struct
,	O
&	O
ws	struct
,	O
&	O
es	struct
,	O
tv	struct
)	O
;	O
if	O
(	O
daemon	function
->	O
shutdown	function
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
num_ready	int
<	O
0	int
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
return	O
(	O
MHD_NO	int
==	O
err_state	bool
)	O
?	O
MHD_YES	int
:	O
MHD_NO	int
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"select failed: %s\n"	pointer
)	O
,	O
MHD_socket_strerr_	O
(	O
err	long
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
MHD_YES	int
==	O
internal_run_from_select	function
(	O
daemon	function
,	O
&	O
rs	struct
,	O
&	O
ws	struct
,	O
&	O
es	struct
)	O
)	O
return	O
(	O
MHD_NO	int
==	O
err_state	bool
)	O
?	O
MHD_YES	int
:	O
MHD_NO	int
;	O
return	O
MHD_NO	int
;	O
}	O
static	O
int	O
MHD_poll_all	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
int	O
may_block	int
)	O
{	O
unsigned	O
int	O
num_connections	int
;	O
struct	O
MHD_Connection	struct
*	O
pos	long
;	O
struct	O
MHD_Connection	struct
*	O
prev	pointer
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_TEST_ALLOW_SUSPEND_RESUME	int
)	O
)	O
&&	O
(	O
MHD_YES	int
==	O
resume_suspended_connections	function
(	O
daemon	function
)	O
)	O
)	O
may_block	int
=	O
MHD_NO	int
;	O
num_connections	int
=	O
0	int
;	O
for	O
(	O
pos	long
=	O
daemon	function
->	O
connections_head	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
num_connections	int
++	O
;	O
{	O
MHD_UNSIGNED_LONG_LONG	O
ltimeout	long long
;	O
unsigned	O
int	O
i	int
;	O
int	O
timeout	pointer
;	O
unsigned	O
int	O
poll_server	int
;	O
int	O
poll_listen	int
;	O
int	O
poll_itc_idx	int
;	O
struct	O
pollfd	struct
*	O
p	array
;	O
MHD_socket	int
ls	int
;	O
p	array
=	O
MHD_calloc_	O
(	O
(	O
2	int
+	O
(	O
size_t	long
)	O
num_connections	int
)	O
,	O
sizeof	O
(	O
struct	O
pollfd	struct
)	O
)	O
;	O
if	O
(	O
NULL	O
==	O
p	array
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Error allocating memory: %s\n"	pointer
)	O
,	O
MHD_strerror_	O
(	O
errno	O
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
poll_server	int
=	O
0	int
;	O
poll_listen	int
=	O
-	O
1	int
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
!=	O
(	O
ls	int
=	O
daemon	function
->	O
listen_fd	int
)	O
)	O
&&	O
(	O
!	O
daemon	function
->	O
was_quiesced	bool
)	O
&&	O
(	O
daemon	function
->	O
connections	int
<	O
daemon	function
->	O
connection_limit	int
)	O
&&	O
(	O
!	O
daemon	function
->	O
at_limit	bool
)	O
)	O
{	O
p	array
[	O
poll_server	int
]	O
.	O
fd	int
=	O
ls	int
;	O
p	array
[	O
poll_server	int
]	O
.	O
events	int
=	O
POLLIN	int
;	O
p	array
[	O
poll_server	int
]	O
.	O
revents	short
=	O
0	int
;	O
poll_listen	int
=	O
(	O
int	O
)	O
poll_server	int
;	O
poll_server	int
++	O
;	O
}	O
poll_itc_idx	int
=	O
-	O
1	int
;	O
if	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
{	O
p	array
[	O
poll_server	int
]	O
.	O
fd	int
=	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
p	array
[	O
poll_server	int
]	O
.	O
events	int
=	O
POLLIN	int
;	O
p	array
[	O
poll_server	int
]	O
.	O
revents	short
=	O
0	int
;	O
poll_itc_idx	int
=	O
(	O
int	O
)	O
poll_server	int
;	O
poll_server	int
++	O
;	O
}	O
if	O
(	O
may_block	int
==	O
MHD_NO	int
)	O
timeout	pointer
=	O
0	int
;	O
else	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
||	O
(	O
MHD_YES	int
!=	O
MHD_get_timeout	function
(	O
daemon	function
,	O
&	O
ltimeout	long long
)	O
)	O
)	O
timeout	pointer
=	O
-	O
1	int
;	O
else	O
timeout	pointer
=	O
(	O
ltimeout	long long
>	O
INT_MAX	O
)	O
?	O
INT_MAX	O
:	O
(	O
int	O
)	O
ltimeout	long long
;	O
i	int
=	O
0	int
;	O
for	O
(	O
pos	long
=	O
daemon	function
->	O
connections_tail	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
prev	pointer
)	O
{	O
p	array
[	O
poll_server	int
+	O
i	int
]	O
.	O
fd	int
=	O
pos	long
->	O
socket_fd	int
;	O
switch	O
(	O
pos	long
->	O
event_loop_info	enum
)	O
{	O
case	O
MHD_EVENT_LOOP_INFO_READ	int
:	O
p	array
[	O
poll_server	int
+	O
i	int
]	O
.	O
events	int
|=	O
POLLIN	int
|	O
MHD_POLL_EVENTS_ERR_DISC	O
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_WRITE	int
:	O
p	array
[	O
poll_server	int
+	O
i	int
]	O
.	O
events	int
|=	O
POLLOUT	int
|	O
MHD_POLL_EVENTS_ERR_DISC	O
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_BLOCK	int
:	O
p	array
[	O
poll_server	int
+	O
i	int
]	O
.	O
events	int
|=	O
MHD_POLL_EVENTS_ERR_DISC	O
;	O
break	O
;	O
case	O
MHD_EVENT_LOOP_INFO_CLEANUP	int
:	O
timeout	pointer
=	O
0	int
;	O
break	O
;	O
}	O
i	int
++	O
;	O
}	O
if	O
(	O
0	int
==	O
poll_server	int
+	O
num_connections	int
)	O
{	O
free	function
(	O
p	array
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
if	O
(	O
MHD_sys_poll_	O
(	O
p	array
,	O
poll_server	int
+	O
num_connections	int
,	O
timeout	pointer
)	O
<	O
0	int
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
{	O
free	function
(	O
p	array
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"poll failed: %s\n"	pointer
)	O
,	O
MHD_socket_strerr_	O
(	O
err	long
)	O
)	O
;	O
free	function
(	O
p	array
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
daemon	function
->	O
data_already_pending	bool
=	O
false	int
;	O
if	O
(	O
(	O
-	O
1	int
!=	O
poll_itc_idx	int
)	O
&&	O
(	O
0	int
!=	O
(	O
p	array
[	O
poll_itc_idx	int
]	O
.	O
revents	short
&	O
POLLIN	int
)	O
)	O
)	O
MHD_itc_clear_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
if	O
(	O
daemon	function
->	O
shutdown	function
)	O
{	O
free	function
(	O
p	array
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
i	int
=	O
0	int
;	O
prev	pointer
=	O
daemon	function
->	O
connections_tail	pointer
;	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
prev	pointer
)	O
)	O
{	O
prev	pointer
=	O
pos	long
->	O
prev	pointer
;	O
if	O
(	O
i	int
>=	O
num_connections	int
)	O
break	O
;	O
if	O
(	O
p	array
[	O
poll_server	int
+	O
i	int
]	O
.	O
fd	int
!=	O
pos	long
->	O
socket_fd	int
)	O
continue	O
;	O
call_handlers	function
(	O
pos	long
,	O
0	int
!=	O
(	O
p	array
[	O
poll_server	int
+	O
i	int
]	O
.	O
revents	short
&	O
POLLIN	int
)	O
,	O
0	int
!=	O
(	O
p	array
[	O
poll_server	int
+	O
i	int
]	O
.	O
revents	short
&	O
POLLOUT	int
)	O
,	O
0	int
!=	O
(	O
p	array
[	O
poll_server	int
+	O
i	int
]	O
.	O
revents	short
&	O
MHD_POLL_REVENTS_ERR_DISC	O
)	O
)	O
;	O
i	int
++	O
;	O
}	O
if	O
(	O
(	O
-	O
1	int
!=	O
poll_listen	int
)	O
&&	O
(	O
0	int
!=	O
(	O
p	array
[	O
poll_listen	int
]	O
.	O
revents	short
&	O
POLLIN	int
)	O
)	O
)	O
(	O
void	O
)	O
MHD_accept_connection	function
(	O
daemon	function
)	O
;	O
free	function
(	O
p	array
)	O
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
MHD_poll_listen_socket	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
int	O
may_block	int
)	O
{	O
struct	O
pollfd	struct
p	array
[	O
2	int
]	O
;	O
int	O
timeout	pointer
;	O
unsigned	O
int	O
poll_count	int
;	O
int	O
poll_listen	int
;	O
int	O
poll_itc_idx	int
;	O
MHD_socket	int
ls	int
;	O
memset	function
(	O
&	O
p	array
,	O
0	int
,	O
sizeof	O
(	O
p	array
)	O
)	O
;	O
poll_count	int
=	O
0	int
;	O
poll_listen	int
=	O
-	O
1	int
;	O
poll_itc_idx	int
=	O
-	O
1	int
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
!=	O
(	O
ls	int
=	O
daemon	function
->	O
listen_fd	int
)	O
)	O
&&	O
(	O
!	O
daemon	function
->	O
was_quiesced	bool
)	O
)	O
{	O
p	array
[	O
poll_count	int
]	O
.	O
fd	int
=	O
ls	int
;	O
p	array
[	O
poll_count	int
]	O
.	O
events	int
=	O
POLLIN	int
;	O
p	array
[	O
poll_count	int
]	O
.	O
revents	short
=	O
0	int
;	O
poll_listen	int
=	O
poll_count	int
;	O
poll_count	int
++	O
;	O
}	O
if	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
{	O
p	array
[	O
poll_count	int
]	O
.	O
fd	int
=	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
p	array
[	O
poll_count	int
]	O
.	O
events	int
=	O
POLLIN	int
;	O
p	array
[	O
poll_count	int
]	O
.	O
revents	short
=	O
0	int
;	O
poll_itc_idx	int
=	O
poll_count	int
;	O
poll_count	int
++	O
;	O
}	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_TEST_ALLOW_SUSPEND_RESUME	int
)	O
)	O
(	O
void	O
)	O
resume_suspended_connections	function
(	O
daemon	function
)	O
;	O
if	O
(	O
MHD_NO	int
==	O
may_block	int
)	O
timeout	pointer
=	O
0	int
;	O
else	O
timeout	pointer
=	O
-	O
1	int
;	O
if	O
(	O
0	int
==	O
poll_count	int
)	O
return	O
MHD_YES	int
;	O
if	O
(	O
MHD_sys_poll_	O
(	O
p	array
,	O
poll_count	int
,	O
timeout	pointer
)	O
<	O
0	int
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
return	O
MHD_YES	int
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"poll failed: %s\n"	pointer
)	O
,	O
MHD_socket_strerr_	O
(	O
err	long
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
-	O
1	int
!=	O
poll_itc_idx	int
)	O
&&	O
(	O
0	int
!=	O
(	O
p	array
[	O
poll_itc_idx	int
]	O
.	O
revents	short
&	O
POLLIN	int
)	O
)	O
)	O
MHD_itc_clear_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
if	O
(	O
daemon	function
->	O
shutdown	function
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
(	O
-	O
1	int
!=	O
poll_listen	int
)	O
&&	O
(	O
0	int
!=	O
(	O
p	array
[	O
poll_listen	int
]	O
.	O
revents	short
&	O
POLLIN	int
)	O
)	O
)	O
(	O
void	O
)	O
MHD_accept_connection	function
(	O
daemon	function
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
MHD_poll	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
int	O
may_block	int
)	O
{	O
if	O
(	O
daemon	function
->	O
shutdown	function
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
return	O
MHD_poll_all	function
(	O
daemon	function
,	O
may_block	int
)	O
;	O
return	O
MHD_poll_listen_socket	function
(	O
daemon	function
,	O
may_block	int
)	O
;	O
}	O
static	O
const	O
char	O
*	O
const	O
epoll_itc_marker	pointer
=	O
"itc_marker"	pointer
;	O
static	O
int	O
MHD_epoll	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
int	O
may_block	int
)	O
{	O
struct	O
MHD_Connection	struct
*	O
pos	long
;	O
struct	O
MHD_Connection	struct
*	O
prev	pointer
;	O
struct	O
epoll_event	struct
events	int
[	O
MAX_EVENTS	int
]	O
;	O
struct	O
epoll_event	struct
event	struct
;	O
int	O
timeout_ms	int
;	O
MHD_UNSIGNED_LONG_LONG	O
timeout_ll	long long
;	O
int	O
num_events	int
;	O
unsigned	O
int	O
i	int
;	O
MHD_socket	int
ls	int
;	O
if	O
(	O
-	O
1	int
==	O
daemon	function
->	O
epoll_fd	int
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
daemon	function
->	O
shutdown	function
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
!=	O
(	O
ls	int
=	O
daemon	function
->	O
listen_fd	int
)	O
)	O
&&	O
(	O
!	O
daemon	function
->	O
was_quiesced	bool
)	O
&&	O
(	O
daemon	function
->	O
connections	int
<	O
daemon	function
->	O
connection_limit	int
)	O
&&	O
(	O
!	O
daemon	function
->	O
listen_socket_in_epoll	bool
)	O
&&	O
(	O
!	O
daemon	function
->	O
at_limit	bool
)	O
)	O
{	O
event	struct
.	O
events	int
=	O
EPOLLIN	int
;	O
event	struct
.	O
data	pointer
.	O
ptr	pointer
=	O
daemon	function
;	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_ADD	int
,	O
ls	int
,	O
&	O
event	struct
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Call to epoll_ctl failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
daemon	function
->	O
listen_socket_in_epoll	bool
=	O
true	int
;	O
}	O
if	O
(	O
(	O
daemon	function
->	O
was_quiesced	bool
)	O
&&	O
(	O
daemon	function
->	O
listen_socket_in_epoll	bool
)	O
)	O
{	O
if	O
(	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_DEL	int
,	O
ls	int
,	O
NULL	O
)	O
)	O
&&	O
(	O
ENOENT	int
!=	O
errno	O
)	O
)	O
MHD_PANIC	O
(	O
"Failed to remove listen FD from epoll set\n"	pointer
)	O
;	O
daemon	function
->	O
listen_socket_in_epoll	bool
=	O
false	int
;	O
}	O
if	O
(	O
(	O
daemon	function
->	O
listen_socket_in_epoll	bool
)	O
&&	O
(	O
(	O
daemon	function
->	O
connections	int
==	O
daemon	function
->	O
connection_limit	int
)	O
||	O
(	O
daemon	function
->	O
at_limit	bool
)	O
||	O
(	O
daemon	function
->	O
was_quiesced	bool
)	O
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_DEL	int
,	O
ls	int
,	O
NULL	O
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to remove listen FD from epoll set\n"	pointer
)	O
)	O
;	O
daemon	function
->	O
listen_socket_in_epoll	bool
=	O
false	int
;	O
}	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_TEST_ALLOW_SUSPEND_RESUME	int
)	O
)	O
&&	O
(	O
MHD_YES	int
==	O
resume_suspended_connections	function
(	O
daemon	function
)	O
)	O
)	O
may_block	int
=	O
MHD_NO	int
;	O
if	O
(	O
MHD_YES	int
==	O
may_block	int
)	O
{	O
if	O
(	O
MHD_YES	int
==	O
MHD_get_timeout	function
(	O
daemon	function
,	O
&	O
timeout_ll	long long
)	O
)	O
{	O
if	O
(	O
timeout_ll	long long
>=	O
(	O
MHD_UNSIGNED_LONG_LONG	O
)	O
INT_MAX	O
)	O
timeout_ms	int
=	O
INT_MAX	O
;	O
else	O
timeout_ms	int
=	O
(	O
int	O
)	O
timeout_ll	long long
;	O
}	O
else	O
timeout_ms	int
=	O
-	O
1	int
;	O
}	O
else	O
timeout_ms	int
=	O
0	int
;	O
daemon	function
->	O
data_already_pending	bool
=	O
false	int
;	O
num_events	int
=	O
MAX_EVENTS	int
;	O
while	O
(	O
MAX_EVENTS	int
==	O
num_events	int
)	O
{	O
num_events	int
=	O
epoll_wait	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
events	int
,	O
MAX_EVENTS	int
,	O
timeout_ms	int
)	O
;	O
if	O
(	O
-	O
1	int
==	O
num_events	int
)	O
{	O
const	O
int	O
err	long
=	O
MHD_socket_get_error_	O
(	O
)	O
;	O
if	O
(	O
MHD_SCKT_ERR_IS_EINTR_	O
(	O
err	long
)	O
)	O
return	O
MHD_YES	int
;	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Call to epoll_wait failed: %s\n"	pointer
)	O
,	O
MHD_socket_strerr_	O
(	O
err	long
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
(	O
unsigned	O
int	O
)	O
num_events	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
NULL	O
==	O
events	int
[	O
i	int
]	O
.	O
data	pointer
.	O
ptr	pointer
)	O
continue	O
;	O
if	O
(	O
epoll_itc_marker	pointer
==	O
events	int
[	O
i	int
]	O
.	O
data	pointer
.	O
ptr	pointer
)	O
{	O
MHD_itc_clear_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
daemon	function
==	O
events	int
[	O
i	int
]	O
.	O
data	pointer
.	O
ptr	pointer
)	O
{	O
if	O
(	O
0	int
==	O
(	O
events	int
[	O
i	int
]	O
.	O
events	int
&	O
(	O
EPOLLERR	int
|	O
EPOLLHUP	int
)	O
)	O
)	O
{	O
unsigned	O
int	O
series_length	int
=	O
0	int
;	O
while	O
(	O
(	O
MHD_YES	int
==	O
MHD_accept_connection	function
(	O
daemon	function
)	O
)	O
&&	O
(	O
series_length	int
<	O
10	int
)	O
&&	O
(	O
daemon	function
->	O
connections	int
<	O
daemon	function
->	O
connection_limit	int
)	O
&&	O
(	O
!	O
daemon	function
->	O
at_limit	bool
)	O
)	O
series_length	int
++	O
;	O
}	O
continue	O
;	O
}	O
pos	long
=	O
events	int
[	O
i	int
]	O
.	O
data	pointer
.	O
ptr	pointer
;	O
if	O
(	O
0	int
!=	O
(	O
events	int
[	O
i	int
]	O
.	O
events	int
&	O
(	O
EPOLLPRI	int
|	O
EPOLLERR	int
|	O
EPOLLHUP	int
)	O
)	O
)	O
{	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_ERROR	int
;	O
if	O
(	O
0	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
{	O
EDLL_insert	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
}	O
}	O
else	O
{	O
if	O
(	O
0	int
!=	O
(	O
events	int
[	O
i	int
]	O
.	O
events	int
&	O
EPOLLIN	int
)	O
)	O
{	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_READ_READY	int
;	O
if	O
(	O
(	O
(	O
MHD_EVENT_LOOP_INFO_READ	int
==	O
pos	long
->	O
event_loop_info	enum
)	O
||	O
(	O
pos	long
->	O
read_buffer_size	long
>	O
pos	long
->	O
read_buffer_offset	long
)	O
)	O
&&	O
(	O
0	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
)	O
{	O
EDLL_insert	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
}	O
}	O
if	O
(	O
0	int
!=	O
(	O
events	int
[	O
i	int
]	O
.	O
events	int
&	O
EPOLLOUT	int
)	O
)	O
{	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_WRITE_READY	int
;	O
if	O
(	O
(	O
MHD_EVENT_LOOP_INFO_WRITE	int
==	O
pos	long
->	O
event_loop_info	enum
)	O
&&	O
(	O
0	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
)	O
{	O
EDLL_insert	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
epoll_state	enum
|=	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
}	O
}	O
}	O
}	O
}	O
prev	pointer
=	O
daemon	function
->	O
eready_tail	pointer
;	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
prev	pointer
)	O
)	O
{	O
prev	pointer
=	O
pos	long
->	O
prevE	pointer
;	O
call_handlers	function
(	O
pos	long
,	O
0	int
!=	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_READ_READY	int
)	O
,	O
0	int
!=	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_WRITE_READY	int
)	O
,	O
0	int
!=	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_ERROR	int
)	O
)	O
;	O
if	O
(	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
(	O
MHD_EPOLL_STATE_SUSPENDED	int
|	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
)	O
)	O
)	O
{	O
if	O
(	O
(	O
(	O
MHD_EVENT_LOOP_INFO_READ	int
==	O
pos	long
->	O
event_loop_info	enum
)	O
&&	O
(	O
0	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_READ_READY	int
)	O
)	O
)	O
||	O
(	O
(	O
MHD_EVENT_LOOP_INFO_WRITE	int
==	O
pos	long
->	O
event_loop_info	enum
)	O
&&	O
(	O
0	int
==	O
(	O
pos	long
->	O
epoll_state	enum
&	O
MHD_EPOLL_STATE_WRITE_READY	int
)	O
)	O
)	O
||	O
(	O
MHD_EVENT_LOOP_INFO_CLEANUP	int
==	O
pos	long
->	O
event_loop_info	enum
)	O
)	O
{	O
EDLL_remove	O
(	O
daemon	function
->	O
eready_head	pointer
,	O
daemon	function
->	O
eready_tail	pointer
,	O
pos	long
)	O
;	O
pos	long
->	O
epoll_state	enum
&=	O
~	O
MHD_EPOLL_STATE_IN_EREADY_EDLL	int
;	O
}	O
}	O
}	O
prev	pointer
=	O
daemon	function
->	O
manual_timeout_tail	pointer
;	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
prev	pointer
)	O
)	O
{	O
prev	pointer
=	O
pos	long
->	O
prevX	pointer
;	O
MHD_connection_handle_idle	function
(	O
pos	long
)	O
;	O
}	O
prev	pointer
=	O
daemon	function
->	O
normal_timeout_tail	pointer
;	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
prev	pointer
)	O
)	O
{	O
prev	pointer
=	O
pos	long
->	O
prevX	pointer
;	O
MHD_connection_handle_idle	function
(	O
pos	long
)	O
;	O
if	O
(	O
MHD_CONNECTION_CLOSED	int
!=	O
pos	long
->	O
state	pointer
)	O
break	O
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
int	O
MHD_run	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
if	O
(	O
(	O
daemon	function
->	O
shutdown	function
)	O
||	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_POLL	int
)	O
)	O
{	O
MHD_poll	function
(	O
daemon	function
,	O
MHD_NO	int
)	O
;	O
MHD_cleanup_connections	function
(	O
daemon	function
)	O
;	O
}	O
else	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
{	O
MHD_epoll	function
(	O
daemon	function
,	O
MHD_NO	int
)	O
;	O
MHD_cleanup_connections	function
(	O
daemon	function
)	O
;	O
}	O
else	O
{	O
MHD_select	function
(	O
daemon	function
,	O
MHD_NO	int
)	O
;	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
void	O
close_connection	function
(	O
struct	O
MHD_Connection	struct
*	O
pos	long
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
pos	long
->	O
daemon	function
;	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
MHD_connection_mark_closed_	function
(	O
pos	long
)	O
;	O
return	O
;	O
}	O
MHD_connection_close_	function
(	O
pos	long
,	O
MHD_REQUEST_TERMINATED_DAEMON_SHUTDOWN	int
)	O
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
mhd_assert	O
(	O
!	O
pos	long
->	O
suspended	int
)	O
;	O
mhd_assert	O
(	O
!	O
pos	long
->	O
resuming	bool
)	O
;	O
if	O
(	O
pos	long
->	O
connection_timeout	int
==	O
daemon	function
->	O
connection_timeout	int
)	O
XDLL_remove	O
(	O
daemon	function
->	O
normal_timeout_head	pointer
,	O
daemon	function
->	O
normal_timeout_tail	pointer
,	O
pos	long
)	O
;	O
else	O
XDLL_remove	O
(	O
daemon	function
->	O
manual_timeout_head	pointer
,	O
daemon	function
->	O
manual_timeout_tail	pointer
,	O
pos	long
)	O
;	O
DLL_remove	O
(	O
daemon	function
->	O
connections_head	pointer
,	O
daemon	function
->	O
connections_tail	pointer
,	O
pos	long
)	O
;	O
DLL_insert	O
(	O
daemon	function
->	O
cleanup_head	pointer
,	O
daemon	function
->	O
cleanup_tail	pointer
,	O
pos	long
)	O
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
}	O
static	O
MHD_THRD_RTRN_TYPE_	O
MHD_THRD_CALL_SPEC_	O
MHD_polling_thread	function
(	O
void	O
*	O
cls	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
cls	pointer
;	O
MHD_thread_init_	O
(	O
&	O
(	O
daemon	function
->	O
pid	int
)	O
)	O
;	O
while	O
(	O
!	O
daemon	function
->	O
shutdown	function
)	O
{	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_POLL	int
)	O
)	O
MHD_poll	function
(	O
daemon	function
,	O
MHD_YES	int
)	O
;	O
else	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
MHD_epoll	function
(	O
daemon	function
,	O
MHD_YES	int
)	O
;	O
else	O
MHD_select	function
(	O
daemon	function
,	O
MHD_YES	int
)	O
;	O
MHD_cleanup_connections	function
(	O
daemon	function
)	O
;	O
}	O
if	O
(	O
0	int
!=	O
(	O
MHD_TEST_ALLOW_SUSPEND_RESUME	int
&	O
daemon	function
->	O
options	enum
)	O
)	O
resume_suspended_connections	function
(	O
daemon	function
)	O
;	O
close_all_connections	function
(	O
daemon	function
)	O
;	O
return	O
(	O
MHD_THRD_RTRN_TYPE_	O
)	O
0	int
;	O
}	O
static	O
size_t	long
unescape_wrapper	function
(	O
void	O
*	O
cls	pointer
,	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
,	O
char	O
*	O
val	array
)	O
{	O
(	O
void	O
)	O
cls	pointer
;	O
(	O
void	O
)	O
connection	pointer
;	O
return	O
MHD_http_unescape	function
(	O
val	array
)	O
;	O
}	O
struct	O
MHD_Daemon	struct
*	O
MHD_start_daemon	function
(	O
unsigned	O
int	O
flags	int
,	O
uint16_t	short
port	short
,	O
MHD_AcceptPolicyCallback	pointer
apc	pointer
,	O
void	O
*	O
apc_cls	pointer
,	O
MHD_AccessHandlerCallback	pointer
dh	pointer
,	O
void	O
*	O
dh_cls	pointer
,	O
...	O
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
;	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
dh_cls	pointer
)	O
;	O
daemon	function
=	O
MHD_start_daemon_va	function
(	O
flags	int
,	O
port	short
,	O
apc	pointer
,	O
apc_cls	pointer
,	O
dh	pointer
,	O
dh_cls	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
daemon	function
;	O
}	O
MHD_socket	int
MHD_quiesce_daemon	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
unsigned	O
int	O
i	int
;	O
MHD_socket	int
ret	int
;	O
ret	int
=	O
daemon	function
->	O
listen_fd	int
;	O
if	O
(	O
MHD_INVALID_SOCKET	O
==	O
ret	int
)	O
return	O
MHD_INVALID_SOCKET	O
;	O
if	O
(	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
(	O
MHD_USE_ITC	int
)	O
)	O
)	O
&&	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
(	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
"Using MHD_quiesce_daemon in this mode requires MHD_USE_ITC\n"	pointer
)	O
;	O
return	O
MHD_INVALID_SOCKET	O
;	O
}	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
worker_pool	pointer
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
daemon	function
->	O
worker_pool_size	int
;	O
i	int
++	O
)	O
{	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
.	O
was_quiesced	bool
=	O
true	int
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
&&	O
(	O
-	O
1	int
!=	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
.	O
epoll_fd	int
)	O
&&	O
(	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
.	O
listen_socket_in_epoll	bool
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
.	O
epoll_fd	int
,	O
EPOLL_CTL_DEL	int
,	O
ret	int
,	O
NULL	O
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to remove listen FD from epoll set\n"	pointer
)	O
)	O
;	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
.	O
listen_socket_in_epoll	bool
=	O
false	int
;	O
}	O
else	O
if	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
.	O
itc	struct
)	O
)	O
{	O
if	O
(	O
!	O
MHD_itc_activate_	O
(	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
.	O
itc	struct
,	O
"q"	pointer
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to signal quiesce via inter-thread communication channel"	pointer
)	O
)	O
;	O
}	O
}	O
daemon	function
->	O
was_quiesced	bool
=	O
true	int
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
&&	O
(	O
-	O
1	int
!=	O
daemon	function
->	O
epoll_fd	int
)	O
&&	O
(	O
daemon	function
->	O
listen_socket_in_epoll	bool
)	O
)	O
{	O
if	O
(	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_DEL	int
,	O
ret	int
,	O
NULL	O
)	O
)	O
&&	O
(	O
ENOENT	int
!=	O
errno	O
)	O
)	O
MHD_PANIC	O
(	O
"Failed to remove listen FD from epoll set\n"	pointer
)	O
;	O
daemon	function
->	O
listen_socket_in_epoll	bool
=	O
false	int
;	O
}	O
if	O
(	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
&&	O
(	O
!	O
MHD_itc_activate_	O
(	O
daemon	function
->	O
itc	struct
,	O
"q"	pointer
)	O
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"failed to signal quiesce via inter-thread communication channel"	pointer
)	O
)	O
;	O
return	O
ret	int
;	O
}	O
typedef	O
void	O
(	O
*	O
VfprintfFunctionPointerType	pointer
)	O
(	O
void	O
*	O
cls	pointer
,	O
const	O
char	O
*	O
format	pointer
,	O
va_list	array
va	array
)	O
;	O
static	O
int	O
parse_options_va	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
const	O
struct	O
sockaddr	struct
*	O
*	O
servaddr	pointer
,	O
va_list	array
ap	array
)	O
;	O
static	O
int	O
parse_options	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
const	O
struct	O
sockaddr	struct
*	O
*	O
servaddr	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
ret	int
;	O
va_start	O
(	O
ap	array
,	O
servaddr	pointer
)	O
;	O
ret	int
=	O
parse_options_va	function
(	O
daemon	function
,	O
servaddr	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
int	O
parse_options_va	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
const	O
struct	O
sockaddr	struct
*	O
*	O
servaddr	pointer
,	O
va_list	array
ap	array
)	O
{	O
enum	O
MHD_OPTION	enum
opt	enum
;	O
struct	O
MHD_OptionItem	struct
*	O
oa	pointer
;	O
unsigned	O
int	O
i	int
;	O
unsigned	O
int	O
uv	int
;	O
while	O
(	O
MHD_OPTION_END	int
!=	O
(	O
opt	enum
=	O
(	O
enum	O
MHD_OPTION	enum
)	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
)	O
)	O
{	O
switch	O
(	O
opt	enum
)	O
{	O
case	O
MHD_OPTION_CONNECTION_MEMORY_LIMIT	int
:	O
daemon	function
->	O
pool_size	long
=	O
va_arg	O
(	O
ap	array
,	O
size_t	long
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_CONNECTION_MEMORY_INCREMENT	int
:	O
daemon	function
->	O
pool_increment	long
=	O
va_arg	O
(	O
ap	array
,	O
size_t	long
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_CONNECTION_LIMIT	int
:	O
daemon	function
->	O
connection_limit	int
=	O
va_arg	O
(	O
ap	array
,	O
unsigned	O
int	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_CONNECTION_TIMEOUT	int
:	O
uv	int
=	O
va_arg	O
(	O
ap	array
,	O
unsigned	O
int	O
)	O
;	O
daemon	function
->	O
connection_timeout	int
=	O
(	O
time_t	long
)	O
uv	int
;	O
if	O
(	O
(	O
(	O
MHD_TYPE_IS_SIGNED_	O
(	O
time_t	long
)	O
)	O
&&	O
(	O
daemon	function
->	O
connection_timeout	int
<	O
0	int
)	O
)	O
||	O
(	O
uv	int
!=	O
(	O
unsigned	O
int	O
)	O
daemon	function
->	O
connection_timeout	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Warning: Too large timeout value, ignored.\n"	pointer
)	O
)	O
;	O
daemon	function
->	O
connection_timeout	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
MHD_OPTION_NOTIFY_COMPLETED	int
:	O
daemon	function
->	O
notify_completed	pointer
=	O
va_arg	O
(	O
ap	array
,	O
MHD_RequestCompletedCallback	pointer
)	O
;	O
daemon	function
->	O
notify_completed_cls	pointer
=	O
va_arg	O
(	O
ap	array
,	O
void	O
*	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_NOTIFY_CONNECTION	int
:	O
daemon	function
->	O
notify_connection	pointer
=	O
va_arg	O
(	O
ap	array
,	O
MHD_NotifyConnectionCallback	pointer
)	O
;	O
daemon	function
->	O
notify_connection_cls	pointer
=	O
va_arg	O
(	O
ap	array
,	O
void	O
*	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_PER_IP_CONNECTION_LIMIT	int
:	O
daemon	function
->	O
per_ip_connection_limit	int
=	O
va_arg	O
(	O
ap	array
,	O
unsigned	O
int	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_SOCK_ADDR	int
:	O
*	O
servaddr	pointer
=	O
va_arg	O
(	O
ap	array
,	O
const	O
struct	O
sockaddr	struct
*	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_URI_LOG_CALLBACK	int
:	O
daemon	function
->	O
uri_log_callback	pointer
=	O
va_arg	O
(	O
ap	array
,	O
LogCallback	pointer
)	O
;	O
daemon	function
->	O
uri_log_callback_cls	pointer
=	O
va_arg	O
(	O
ap	array
,	O
void	O
*	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_SERVER_INSANITY	int
:	O
daemon	function
->	O
insanity_level	enum
=	O
(	O
enum	O
MHD_DisableSanityCheck	enum
)	O
va_arg	O
(	O
ap	array
,	O
unsigned	O
int	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_THREAD_POOL_SIZE	int
:	O
daemon	function
->	O
worker_pool_size	int
=	O
va_arg	O
(	O
ap	array
,	O
unsigned	O
int	O
)	O
;	O
if	O
(	O
0	int
==	O
daemon	function
->	O
worker_pool_size	int
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Warning: Zero size, specified for thread pool size, is ignored. "	pointer
"Thread pool is not used.\n"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
1	int
==	O
daemon	function
->	O
worker_pool_size	int
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Warning: \"1\", specified for thread pool size, is ignored. "	pointer
"Thread pool is not used.\n"	pointer
)	O
)	O
;	O
daemon	function
->	O
worker_pool_size	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
daemon	function
->	O
worker_pool_size	int
>=	O
(	O
SIZE_MAX	O
/	O
sizeof	O
(	O
struct	O
MHD_Daemon	struct
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Specified thread pool size (%u) too big\n"	pointer
)	O
,	O
daemon	function
->	O
worker_pool_size	int
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
else	O
{	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"MHD_OPTION_THREAD_POOL_SIZE option is specified but "	pointer
"MHD_USE_INTERNAL_POLLING_THREAD flag is not specified.\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Both MHD_OPTION_THREAD_POOL_SIZE option and "	pointer
"MHD_USE_THREAD_PER_CONNECTION flag are specified.\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
}	O
break	O
;	O
case	O
MHD_OPTION_DIGEST_AUTH_RANDOM	int
:	O
daemon	function
->	O
digest_auth_rand_size	long
=	O
va_arg	O
(	O
ap	array
,	O
size_t	long
)	O
;	O
daemon	function
->	O
digest_auth_random	pointer
=	O
va_arg	O
(	O
ap	array
,	O
const	O
char	O
*	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_NONCE_NC_SIZE	int
:	O
daemon	function
->	O
nonce_nc_size	int
=	O
va_arg	O
(	O
ap	array
,	O
unsigned	O
int	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_LISTEN_SOCKET	int
:	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_NO_LISTEN_SOCKET	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"MHD_OPTION_LISTEN_SOCKET specified for daemon "	pointer
"with MHD_USE_NO_LISTEN_SOCKET flag set.\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
else	O
daemon	function
->	O
listen_fd	int
=	O
va_arg	O
(	O
ap	array
,	O
MHD_socket	int
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_EXTERNAL_LOGGER	int
:	O
daemon	function
->	O
custom_error_log	pointer
=	O
va_arg	O
(	O
ap	array
,	O
VfprintfFunctionPointerType	pointer
)	O
;	O
daemon	function
->	O
custom_error_log_cls	pointer
=	O
va_arg	O
(	O
ap	array
,	O
void	O
*	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_THREAD_STACK_SIZE	int
:	O
daemon	function
->	O
thread_stack_size	long
=	O
va_arg	O
(	O
ap	array
,	O
size_t	long
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE	int
:	O
daemon	function
->	O
fastopen_queue_size	int
=	O
va_arg	O
(	O
ap	array
,	O
unsigned	O
int	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_LISTENING_ADDRESS_REUSE	int
:	O
daemon	function
->	O
listening_address_reuse	int
=	O
va_arg	O
(	O
ap	array
,	O
unsigned	O
int	O
)	O
?	O
1	int
:	O
-	O
1	int
;	O
break	O
;	O
case	O
MHD_OPTION_LISTEN_BACKLOG_SIZE	int
:	O
daemon	function
->	O
listen_backlog_size	int
=	O
va_arg	O
(	O
ap	array
,	O
unsigned	O
int	O
)	O
;	O
break	O
;	O
case	O
MHD_OPTION_STRICT_FOR_CLIENT	int
:	O
daemon	function
->	O
strict_for_client	int
=	O
va_arg	O
(	O
ap	array
,	O
int	O
)	O
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_PEDANTIC_CHECKS	int
)	O
)	O
&&	O
(	O
1	int
!=	O
daemon	function
->	O
strict_for_client	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Flag MHD_USE_PEDANTIC_CHECKS is ignored because "	pointer
"another behavior is specified by MHD_OPTION_STRICT_CLIENT.\n"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
MHD_OPTION_ARRAY	int
:	O
oa	pointer
=	O
va_arg	O
(	O
ap	array
,	O
struct	O
MHD_OptionItem	struct
*	O
)	O
;	O
i	int
=	O
0	int
;	O
while	O
(	O
MHD_OPTION_END	int
!=	O
(	O
opt	enum
=	O
oa	pointer
[	O
i	int
]	O
.	O
option	enum
)	O
)	O
{	O
switch	O
(	O
opt	enum
)	O
{	O
case	O
MHD_OPTION_CONNECTION_MEMORY_LIMIT	int
:	O
case	O
MHD_OPTION_CONNECTION_MEMORY_INCREMENT	int
:	O
case	O
MHD_OPTION_THREAD_STACK_SIZE	int
:	O
if	O
(	O
MHD_YES	int
!=	O
parse_options	function
(	O
daemon	function
,	O
servaddr	pointer
,	O
opt	enum
,	O
(	O
size_t	long
)	O
oa	pointer
[	O
i	int
]	O
.	O
value	long
,	O
MHD_OPTION_END	int
)	O
)	O
return	O
MHD_NO	int
;	O
break	O
;	O
case	O
MHD_OPTION_NONCE_NC_SIZE	int
:	O
case	O
MHD_OPTION_CONNECTION_LIMIT	int
:	O
case	O
MHD_OPTION_CONNECTION_TIMEOUT	int
:	O
case	O
MHD_OPTION_PER_IP_CONNECTION_LIMIT	int
:	O
case	O
MHD_OPTION_THREAD_POOL_SIZE	int
:	O
case	O
MHD_OPTION_TCP_FASTOPEN_QUEUE_SIZE	int
:	O
case	O
MHD_OPTION_LISTENING_ADDRESS_REUSE	int
:	O
case	O
MHD_OPTION_LISTEN_BACKLOG_SIZE	int
:	O
case	O
MHD_OPTION_SERVER_INSANITY	int
:	O
if	O
(	O
MHD_YES	int
!=	O
parse_options	function
(	O
daemon	function
,	O
servaddr	pointer
,	O
opt	enum
,	O
(	O
unsigned	O
int	O
)	O
oa	pointer
[	O
i	int
]	O
.	O
value	long
,	O
MHD_OPTION_END	int
)	O
)	O
return	O
MHD_NO	int
;	O
break	O
;	O
case	O
MHD_OPTION_LISTEN_SOCKET	int
:	O
if	O
(	O
MHD_YES	int
!=	O
parse_options	function
(	O
daemon	function
,	O
servaddr	pointer
,	O
opt	enum
,	O
(	O
MHD_socket	int
)	O
oa	pointer
[	O
i	int
]	O
.	O
value	long
,	O
MHD_OPTION_END	int
)	O
)	O
return	O
MHD_NO	int
;	O
break	O
;	O
case	O
MHD_OPTION_STRICT_FOR_CLIENT	int
:	O
if	O
(	O
MHD_YES	int
!=	O
parse_options	function
(	O
daemon	function
,	O
servaddr	pointer
,	O
opt	enum
,	O
(	O
int	O
)	O
oa	pointer
[	O
i	int
]	O
.	O
value	long
,	O
MHD_OPTION_END	int
)	O
)	O
return	O
MHD_NO	int
;	O
break	O
;	O
case	O
MHD_OPTION_SOCK_ADDR	int
:	O
case	O
MHD_OPTION_HTTPS_MEM_KEY	int
:	O
case	O
MHD_OPTION_HTTPS_KEY_PASSWORD	int
:	O
case	O
MHD_OPTION_HTTPS_MEM_CERT	int
:	O
case	O
MHD_OPTION_HTTPS_MEM_TRUST	int
:	O
case	O
MHD_OPTION_HTTPS_MEM_DHPARAMS	int
:	O
case	O
MHD_OPTION_HTTPS_PRIORITIES	int
:	O
case	O
MHD_OPTION_ARRAY	int
:	O
case	O
MHD_OPTION_HTTPS_CERT_CALLBACK	int
:	O
case	O
MHD_OPTION_HTTPS_CERT_CALLBACK2	int
:	O
if	O
(	O
MHD_YES	int
!=	O
parse_options	function
(	O
daemon	function
,	O
servaddr	pointer
,	O
opt	enum
,	O
oa	pointer
[	O
i	int
]	O
.	O
ptr_value	pointer
,	O
MHD_OPTION_END	int
)	O
)	O
return	O
MHD_NO	int
;	O
break	O
;	O
case	O
MHD_OPTION_NOTIFY_COMPLETED	int
:	O
case	O
MHD_OPTION_NOTIFY_CONNECTION	int
:	O
case	O
MHD_OPTION_URI_LOG_CALLBACK	int
:	O
case	O
MHD_OPTION_EXTERNAL_LOGGER	int
:	O
case	O
MHD_OPTION_UNESCAPE_CALLBACK	int
:	O
case	O
MHD_OPTION_GNUTLS_PSK_CRED_HANDLER	int
:	O
if	O
(	O
MHD_YES	int
!=	O
parse_options	function
(	O
daemon	function
,	O
servaddr	pointer
,	O
opt	enum
,	O
(	O
void	O
*	O
)	O
oa	pointer
[	O
i	int
]	O
.	O
value	long
,	O
oa	pointer
[	O
i	int
]	O
.	O
ptr_value	pointer
,	O
MHD_OPTION_END	int
)	O
)	O
return	O
MHD_NO	int
;	O
break	O
;	O
case	O
MHD_OPTION_DIGEST_AUTH_RANDOM	int
:	O
if	O
(	O
MHD_YES	int
!=	O
parse_options	function
(	O
daemon	function
,	O
servaddr	pointer
,	O
opt	enum
,	O
(	O
size_t	long
)	O
oa	pointer
[	O
i	int
]	O
.	O
value	long
,	O
oa	pointer
[	O
i	int
]	O
.	O
ptr_value	pointer
,	O
MHD_OPTION_END	int
)	O
)	O
return	O
MHD_NO	int
;	O
break	O
;	O
default	O
:	O
return	O
MHD_NO	int
;	O
}	O
i	int
++	O
;	O
}	O
break	O
;	O
case	O
MHD_OPTION_UNESCAPE_CALLBACK	int
:	O
daemon	function
->	O
unescape_callback	pointer
=	O
va_arg	O
(	O
ap	array
,	O
UnescapeCallback	pointer
)	O
;	O
daemon	function
->	O
unescape_callback_cls	pointer
=	O
va_arg	O
(	O
ap	array
,	O
void	O
*	O
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
(	O
opt	enum
>=	O
MHD_OPTION_HTTPS_MEM_KEY	int
)	O
&&	O
(	O
opt	enum
<=	O
MHD_OPTION_HTTPS_PRIORITIES	int
)	O
)	O
||	O
(	O
opt	enum
==	O
MHD_OPTION_HTTPS_MEM_TRUST	int
)	O
||	O
(	O
opt	enum
==	O
MHD_OPTION_GNUTLS_PSK_CRED_HANDLER	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"MHD HTTPS option %d passed to MHD compiled without HTTPS support\n"	pointer
)	O
,	O
opt	enum
)	O
;	O
}	O
else	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Invalid option %d! (Did you terminate the list with MHD_OPTION_END?)\n"	pointer
)	O
,	O
opt	enum
)	O
;	O
}	O
return	O
MHD_NO	int
;	O
}	O
}	O
return	O
MHD_YES	int
;	O
}	O
static	O
int	O
setup_epoll_fd	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
int	O
fd	int
;	O
fd	int
=	O
epoll_create1	function
(	O
EPOLL_CLOEXEC	int
)	O
;	O
if	O
(	O
MHD_INVALID_SOCKET	O
==	O
fd	int
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Call to epoll_create1 failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
return	O
MHD_INVALID_SOCKET	O
;	O
}	O
return	O
fd	int
;	O
}	O
static	O
int	O
setup_epoll_to_listen	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
struct	O
epoll_event	struct
event	struct
;	O
MHD_socket	int
ls	int
;	O
daemon	function
->	O
epoll_fd	int
=	O
setup_epoll_fd	function
(	O
daemon	function
)	O
;	O
if	O
(	O
-	O
1	int
==	O
daemon	function
->	O
epoll_fd	int
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
==	O
(	O
ls	int
=	O
daemon	function
->	O
listen_fd	int
)	O
)	O
||	O
(	O
daemon	function
->	O
was_quiesced	bool
)	O
)	O
return	O
MHD_YES	int
;	O
event	struct
.	O
events	int
=	O
EPOLLIN	int
;	O
event	struct
.	O
data	pointer
.	O
ptr	pointer
=	O
daemon	function
;	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_ADD	int
,	O
ls	int
,	O
&	O
event	struct
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Call to epoll_ctl failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
daemon	function
->	O
listen_socket_in_epoll	bool
=	O
true	int
;	O
if	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
{	O
event	struct
.	O
events	int
=	O
EPOLLIN	int
;	O
event	struct
.	O
data	pointer
.	O
ptr	pointer
=	O
(	O
void	O
*	O
)	O
epoll_itc_marker	pointer
;	O
if	O
(	O
0	int
!=	O
epoll_ctl	function
(	O
daemon	function
->	O
epoll_fd	int
,	O
EPOLL_CTL_ADD	int
,	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
,	O
&	O
event	struct
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Call to epoll_ctl failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
}	O
return	O
MHD_YES	int
;	O
}	O
struct	O
MHD_Daemon	struct
*	O
MHD_start_daemon_va	function
(	O
unsigned	O
int	O
flags	int
,	O
uint16_t	short
port	short
,	O
MHD_AcceptPolicyCallback	pointer
apc	pointer
,	O
void	O
*	O
apc_cls	pointer
,	O
MHD_AccessHandlerCallback	pointer
dh	pointer
,	O
void	O
*	O
dh_cls	pointer
,	O
va_list	array
ap	array
)	O
{	O
const	O
MHD_SCKT_OPT_BOOL_	int
on	bool
=	O
1	int
;	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
;	O
MHD_socket	int
listen_fd	int
;	O
struct	O
sockaddr_in	struct
servaddr4	struct
;	O
struct	O
sockaddr_in6	struct
servaddr6	struct
;	O
const	O
struct	O
sockaddr	struct
*	O
servaddr	pointer
=	O
NULL	O
;	O
socklen_t	int
addrlen	int
;	O
unsigned	O
int	O
i	int
;	O
enum	O
MHD_FLAG	enum
eflags	long
;	O
enum	O
MHD_FLAG	enum
*	O
pflags	pointer
;	O
MHD_check_global_init_	O
(	O
)	O
;	O
eflags	long
=	O
(	O
enum	O
MHD_FLAG	enum
)	O
flags	int
;	O
pflags	pointer
=	O
&	O
eflags	long
;	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_TLS	int
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_ALLOW_UPGRADE	int
)	O
)	O
{	O
*	O
pflags	pointer
|=	O
MHD_ALLOW_SUSPEND_RESUME	int
;	O
}	O
if	O
(	O
NULL	O
==	O
dh	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_POLL	int
)	O
)	O
&&	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_EPOLL	int
)	O
)	O
)	O
||	O
(	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_EPOLL	int
)	O
)	O
&&	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
)	O
||	O
(	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_POLL	int
)	O
)	O
&&	O
(	O
0	int
==	O
(	O
*	O
pflags	pointer
&	O
(	O
MHD_USE_INTERNAL_POLLING_THREAD	int
|	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
)	O
)	O
||	O
(	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_AUTO	int
)	O
)	O
&&	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
(	O
MHD_USE_POLL	int
|	O
MHD_USE_EPOLL	int
)	O
)	O
)	O
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_AUTO	int
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
*	O
pflags	pointer
|=	O
MHD_USE_POLL	int
;	O
}	O
else	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
{	O
*	O
pflags	pointer
|=	O
MHD_USE_EPOLL	int
;	O
}	O
else	O
{	O
*	O
pflags	pointer
|=	O
MHD_USE_EPOLL	int
;	O
}	O
}	O
if	O
(	O
NULL	O
==	O
(	O
daemon	function
=	O
MHD_calloc_	O
(	O
1	int
,	O
sizeof	O
(	O
struct	O
MHD_Daemon	struct
)	O
)	O
)	O
)	O
return	O
NULL	O
;	O
daemon	function
->	O
epoll_fd	int
=	O
-	O
1	int
;	O
daemon	function
->	O
listen_fd	int
=	O
MHD_INVALID_SOCKET	O
;	O
daemon	function
->	O
listening_address_reuse	int
=	O
0	int
;	O
daemon	function
->	O
options	enum
=	O
*	O
pflags	pointer
;	O
pflags	pointer
=	O
&	O
daemon	function
->	O
options	enum
;	O
daemon	function
->	O
strict_for_client	int
=	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_PEDANTIC_CHECKS	int
)	O
)	O
?	O
1	int
:	O
0	int
;	O
daemon	function
->	O
port	short
=	O
port	short
;	O
daemon	function
->	O
apc	pointer
=	O
apc	pointer
;	O
daemon	function
->	O
apc_cls	pointer
=	O
apc_cls	pointer
;	O
daemon	function
->	O
default_handler	pointer
=	O
dh	pointer
;	O
daemon	function
->	O
default_handler_cls	pointer
=	O
dh_cls	pointer
;	O
daemon	function
->	O
connections	int
=	O
0	int
;	O
daemon	function
->	O
connection_limit	int
=	O
MHD_MAX_CONNECTIONS_DEFAULT	O
;	O
daemon	function
->	O
pool_size	long
=	O
MHD_POOL_SIZE_DEFAULT	O
;	O
daemon	function
->	O
pool_increment	long
=	O
MHD_BUF_INC_SIZE	int
;	O
daemon	function
->	O
unescape_callback	pointer
=	O
&	O
unescape_wrapper	function
;	O
daemon	function
->	O
connection_timeout	int
=	O
0	int
;	O
MHD_itc_set_invalid_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
daemon	function
->	O
listen_backlog_size	int
=	O
SOMAXCONN	int
;	O
daemon	function
->	O
custom_error_log	pointer
=	O
&	O
MHD_default_logger_	function
;	O
daemon	function
->	O
custom_error_log_cls	pointer
=	O
stderr	pointer
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
&&	O
(	O
0	int
==	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Warning: MHD_USE_THREAD_PER_CONNECTION must be used only with "	pointer
"MHD_USE_INTERNAL_POLLING_THREAD. Flag MHD_USE_INTERNAL_POLLING_THREAD "	pointer
"was added. Consider setting MHD_USE_INTERNAL_POLLING_THREAD explicitly.\n"	pointer
)	O
)	O
;	O
*	O
pflags	pointer
|=	O
MHD_USE_INTERNAL_POLLING_THREAD	int
;	O
}	O
if	O
(	O
0	int
==	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
*	O
pflags	pointer
&=	O
~	O
MHD_USE_ITC	int
;	O
else	O
{	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_NO_LISTEN_SOCKET	int
)	O
)	O
*	O
pflags	pointer
|=	O
MHD_USE_ITC	int
;	O
}	O
daemon	function
->	O
digest_auth_rand_size	long
=	O
0	int
;	O
daemon	function
->	O
digest_auth_random	pointer
=	O
NULL	O
;	O
daemon	function
->	O
nonce_nc_size	int
=	O
4	int
;	O
if	O
(	O
MHD_YES	int
!=	O
parse_options_va	function
(	O
daemon	function
,	O
&	O
servaddr	pointer
,	O
ap	array
)	O
)	O
{	O
free	function
(	O
daemon	function
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
NULL	O
!=	O
daemon	function
->	O
notify_completed	pointer
)	O
&&	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
)	O
*	O
pflags	pointer
|=	O
MHD_USE_ITC	int
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_ITC	int
)	O
)	O
&&	O
(	O
0	int
==	O
daemon	function
->	O
worker_pool_size	int
)	O
)	O
{	O
if	O
(	O
!	O
MHD_itc_init_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to create inter-thread communication channel: %s\n"	pointer
)	O
,	O
MHD_itc_last_strerror_	O
(	O
)	O
)	O
;	O
free	function
(	O
daemon	function
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
0	int
==	O
(	O
*	O
pflags	pointer
&	O
(	O
MHD_USE_POLL	int
|	O
MHD_USE_EPOLL	int
)	O
)	O
)	O
&&	O
(	O
!	O
MHD_SCKT_FD_FITS_FDSET_	O
(	O
MHD_itc_r_fd_	O
(	O
daemon	function
->	O
itc	struct
)	O
,	O
NULL	O
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"file descriptor for inter-thread communication channel exceeds maximum value\n"	pointer
)	O
)	O
;	O
MHD_itc_destroy_chk_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
free	function
(	O
daemon	function
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
daemon	function
->	O
nonce_nc_size	int
>	O
0	int
)	O
{	O
if	O
(	O
(	O
(	O
size_t	long
)	O
(	O
daemon	function
->	O
nonce_nc_size	int
*	O
sizeof	O
(	O
struct	O
MHD_NonceNc	struct
)	O
)	O
)	O
/	O
sizeof	O
(	O
struct	O
MHD_NonceNc	struct
)	O
!=	O
daemon	function
->	O
nonce_nc_size	int
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Specified value for NC_SIZE too large\n"	pointer
)	O
)	O
;	O
free	function
(	O
daemon	function
)	O
;	O
return	O
NULL	O
;	O
}	O
daemon	function
->	O
nnc	pointer
=	O
malloc	function
(	O
daemon	function
->	O
nonce_nc_size	int
*	O
sizeof	O
(	O
struct	O
MHD_NonceNc	struct
)	O
)	O
;	O
if	O
(	O
NULL	O
==	O
daemon	function
->	O
nnc	pointer
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to allocate memory for nonce-nc map: %s\n"	pointer
)	O
,	O
MHD_strerror_	O
(	O
errno	O
)	O
)	O
;	O
free	function
(	O
daemon	function
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
if	O
(	O
!	O
MHD_mutex_init_	O
(	O
&	O
daemon	function
->	O
nnc_lock	union
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"MHD failed to initialize nonce-nc mutex\n"	pointer
)	O
)	O
;	O
free	function
(	O
daemon	function
->	O
nnc	pointer
)	O
;	O
free	function
(	O
daemon	function
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
0	int
==	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
&&	O
(	O
daemon	function
->	O
worker_pool_size	int
>	O
0	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"MHD thread pooling only works with MHD_USE_INTERNAL_POLLING_THREAD\n"	pointer
)	O
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
==	O
daemon	function
->	O
listen_fd	int
)	O
&&	O
(	O
0	int
==	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_NO_LISTEN_SOCKET	int
)	O
)	O
)	O
{	O
int	O
domain	int
;	O
domain	int
=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_IPv6	int
)	O
?	O
PF_INET6	int
:	O
PF_INET	int
;	O
listen_fd	int
=	O
MHD_socket_create_listen_	function
(	O
domain	int
)	O
;	O
if	O
(	O
MHD_INVALID_SOCKET	O
==	O
listen_fd	int
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to create socket for listening: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
if	O
(	O
0	int
==	O
daemon	function
->	O
listening_address_reuse	int
)	O
{	O
if	O
(	O
0	int
>	O
setsockopt	function
(	O
listen_fd	int
,	O
SOL_SOCKET	int
,	O
SO_REUSEADDR	int
,	O
(	O
void	O
*	O
)	O
&	O
on	bool
,	O
sizeof	O
(	O
on	bool
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"setsockopt failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
daemon	function
->	O
listening_address_reuse	int
>	O
0	int
)	O
{	O
if	O
(	O
0	int
>	O
setsockopt	function
(	O
listen_fd	int
,	O
SOL_SOCKET	int
,	O
SO_REUSEADDR	int
,	O
(	O
void	O
*	O
)	O
&	O
on	bool
,	O
sizeof	O
(	O
on	bool
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"setsockopt failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
}	O
if	O
(	O
0	int
>	O
setsockopt	function
(	O
listen_fd	int
,	O
SOL_SOCKET	int
,	O
SO_REUSEPORT	int
,	O
(	O
void	O
*	O
)	O
&	O
on	bool
,	O
sizeof	O
(	O
on	bool
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"setsockopt failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
}	O
else	O
{	O
}	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_IPv6	int
)	O
)	O
addrlen	int
=	O
sizeof	O
(	O
struct	O
sockaddr_in6	struct
)	O
;	O
else	O
addrlen	int
=	O
sizeof	O
(	O
struct	O
sockaddr_in	struct
)	O
;	O
if	O
(	O
NULL	O
==	O
servaddr	pointer
)	O
{	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_IPv6	int
)	O
)	O
{	O
static	O
const	O
struct	O
in6_addr	struct
static_in6any	struct
=	O
IN6ADDR_ANY_INIT	O
;	O
memset	function
(	O
&	O
servaddr6	struct
,	O
0	int
,	O
sizeof	O
(	O
struct	O
sockaddr_in6	struct
)	O
)	O
;	O
servaddr6	struct
.	O
sin6_family	short
=	O
AF_INET6	O
;	O
servaddr6	struct
.	O
sin6_port	short
=	O
htons	function
(	O
port	short
)	O
;	O
servaddr6	struct
.	O
sin6_addr	struct
=	O
static_in6any	struct
;	O
servaddr	pointer
=	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
servaddr6	struct
;	O
}	O
else	O
{	O
memset	function
(	O
&	O
servaddr4	struct
,	O
0	int
,	O
sizeof	O
(	O
struct	O
sockaddr_in	struct
)	O
)	O
;	O
servaddr4	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
servaddr4	struct
.	O
sin_port	short
=	O
htons	function
(	O
port	short
)	O
;	O
if	O
(	O
0	int
!=	O
INADDR_ANY	O
)	O
servaddr4	struct
.	O
sin_addr	struct
.	O
s_addr	int
=	O
htonl	function
(	O
INADDR_ANY	O
)	O
;	O
servaddr	pointer
=	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
servaddr4	struct
;	O
}	O
}	O
daemon	function
->	O
listen_fd	int
=	O
listen_fd	int
;	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_IPv6	int
)	O
)	O
{	O
const	O
MHD_SCKT_OPT_BOOL_	int
v6_only	int
=	O
(	O
MHD_USE_DUAL_STACK	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_DUAL_STACK	int
)	O
)	O
;	O
if	O
(	O
0	int
>	O
setsockopt	function
(	O
listen_fd	int
,	O
IPPROTO_IPV6	int
,	O
IPV6_V6ONLY	int
,	O
(	O
const	O
void	O
*	O
)	O
&	O
v6_only	int
,	O
sizeof	O
(	O
v6_only	int
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"setsockopt failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
-	O
1	int
==	O
bind	function
(	O
listen_fd	int
,	O
servaddr	pointer
,	O
addrlen	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to bind to port %u: %s\n"	pointer
)	O
,	O
(	O
unsigned	O
int	O
)	O
port	short
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
listen_fd	int
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_TCP_FASTOPEN	int
)	O
)	O
{	O
if	O
(	O
0	int
==	O
daemon	function
->	O
fastopen_queue_size	int
)	O
daemon	function
->	O
fastopen_queue_size	int
=	O
MHD_TCP_FASTOPEN_QUEUE_SIZE_DEFAULT	int
;	O
if	O
(	O
0	int
!=	O
setsockopt	function
(	O
listen_fd	int
,	O
IPPROTO_TCP	int
,	O
TCP_FASTOPEN	int
,	O
(	O
const	O
void	O
*	O
)	O
&	O
daemon	function
->	O
fastopen_queue_size	int
,	O
sizeof	O
(	O
daemon	function
->	O
fastopen_queue_size	int
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"setsockopt failed: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
}	O
}	O
if	O
(	O
listen	function
(	O
listen_fd	int
,	O
daemon	function
->	O
listen_backlog_size	int
)	O
<	O
0	int
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to listen for connections: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
listen_fd	int
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
}	O
else	O
{	O
listen_fd	int
=	O
daemon	function
->	O
listen_fd	int
;	O
}	O
if	O
(	O
(	O
0	int
==	O
daemon	function
->	O
port	short
)	O
&&	O
(	O
0	int
==	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_NO_LISTEN_SOCKET	int
)	O
)	O
)	O
{	O
struct	O
sockaddr_storage	struct
bindaddr	struct
;	O
memset	function
(	O
&	O
bindaddr	struct
,	O
0	int
,	O
sizeof	O
(	O
struct	O
sockaddr_storage	struct
)	O
)	O
;	O
addrlen	int
=	O
sizeof	O
(	O
struct	O
sockaddr_storage	struct
)	O
;	O
if	O
(	O
0	int
!=	O
getsockname	function
(	O
listen_fd	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
bindaddr	struct
,	O
&	O
addrlen	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to get listen port number: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
}	O
else	O
if	O
(	O
sizeof	O
(	O
bindaddr	struct
)	O
<	O
addrlen	int
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to get listen port number (`struct sockaddr_storage` too small!?)\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
bindaddr	struct
.	O
ss_family	short
)	O
{	O
case	O
AF_INET	O
:	O
{	O
struct	O
sockaddr_in	struct
*	O
s4	pointer
=	O
(	O
struct	O
sockaddr_in	struct
*	O
)	O
&	O
bindaddr	struct
;	O
daemon	function
->	O
port	short
=	O
ntohs	function
(	O
s4	pointer
->	O
sin_port	short
)	O
;	O
break	O
;	O
}	O
case	O
AF_INET6	O
:	O
{	O
struct	O
sockaddr_in6	struct
*	O
s6	pointer
=	O
(	O
struct	O
sockaddr_in6	struct
*	O
)	O
&	O
bindaddr	struct
;	O
daemon	function
->	O
port	short
=	O
ntohs	function
(	O
s6	pointer
->	O
sin6_port	short
)	O
;	O
mhd_assert	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_IPv6	int
)	O
)	O
;	O
break	O
;	O
}	O
case	O
AF_UNIX	O
:	O
daemon	function
->	O
port	short
=	O
0	int
;	O
break	O
;	O
default	O
:	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Unknown address family!\n"	pointer
)	O
)	O
;	O
daemon	function
->	O
port	short
=	O
0	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
!=	O
listen_fd	int
)	O
&&	O
(	O
!	O
MHD_socket_nonblocking_	function
(	O
listen_fd	int
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to set nonblocking mode on listening socket: %s\n"	pointer
)	O
,	O
MHD_socket_last_strerr_	O
(	O
)	O
)	O
;	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_EPOLL	int
)	O
||	O
(	O
daemon	function
->	O
worker_pool_size	int
>	O
0	int
)	O
)	O
{	O
MHD_socket_close_chk_	O
(	O
listen_fd	int
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
}	O
if	O
(	O
(	O
MHD_INVALID_SOCKET	O
!=	O
listen_fd	int
)	O
&&	O
(	O
!	O
MHD_SCKT_FD_FITS_FDSET_	O
(	O
listen_fd	int
,	O
NULL	O
)	O
)	O
&&	O
(	O
0	int
==	O
(	O
*	O
pflags	pointer
&	O
(	O
MHD_USE_POLL	int
|	O
MHD_USE_EPOLL	int
)	O
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Socket descriptor larger than FD_SETSIZE: %d > %d\n"	pointer
)	O
,	O
listen_fd	int
,	O
FD_SETSIZE	O
)	O
;	O
MHD_socket_close_chk_	O
(	O
listen_fd	int
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
if	O
(	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_EPOLL	int
)	O
)	O
&&	O
(	O
0	int
==	O
daemon	function
->	O
worker_pool_size	int
)	O
)	O
{	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Combining MHD_USE_THREAD_PER_CONNECTION and MHD_USE_EPOLL is not supported.\n"	pointer
)	O
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
if	O
(	O
MHD_YES	int
!=	O
setup_epoll_to_listen	function
(	O
daemon	function
)	O
)	O
goto	O
free_and_fail	O
;	O
}	O
if	O
(	O
!	O
MHD_mutex_init_	O
(	O
&	O
daemon	function
->	O
per_ip_connection_mutex	union
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"MHD failed to initialize IP connection limit mutex\n"	pointer
)	O
)	O
;	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
listen_fd	int
)	O
MHD_socket_close_chk_	O
(	O
listen_fd	int
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
if	O
(	O
0	int
==	O
daemon	function
->	O
worker_pool_size	int
)	O
{	O
if	O
(	O
!	O
MHD_mutex_init_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"MHD failed to initialize IP connection limit mutex\n"	pointer
)	O
)	O
;	O
MHD_mutex_destroy_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
listen_fd	int
)	O
MHD_socket_close_chk_	O
(	O
listen_fd	int
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
}	O
if	O
(	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
&&	O
(	O
0	int
==	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_NO_LISTEN_SOCKET	int
)	O
)	O
)	O
{	O
if	O
(	O
0	int
==	O
daemon	function
->	O
worker_pool_size	int
)	O
{	O
if	O
(	O
!	O
MHD_create_named_thread_	function
(	O
&	O
daemon	function
->	O
pid	int
,	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
?	O
"MHD-listen"	pointer
:	O
"MHD-single"	pointer
,	O
daemon	function
->	O
thread_stack_size	long
,	O
&	O
MHD_polling_thread	function
,	O
daemon	function
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to create listen thread: %s\n"	pointer
)	O
,	O
MHD_strerror_	O
(	O
errno	O
)	O
)	O
;	O
MHD_mutex_destroy_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
MHD_mutex_destroy_chk_	O
(	O
&	O
daemon	function
->	O
per_ip_connection_mutex	union
)	O
;	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
listen_fd	int
)	O
MHD_socket_close_chk_	O
(	O
listen_fd	int
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
}	O
else	O
{	O
unsigned	O
int	O
conns_per_thread	int
=	O
daemon	function
->	O
connection_limit	int
/	O
daemon	function
->	O
worker_pool_size	int
;	O
unsigned	O
int	O
leftover_conns	int
=	O
daemon	function
->	O
connection_limit	int
%	O
daemon	function
->	O
worker_pool_size	int
;	O
i	int
=	O
0	int
;	O
daemon	function
->	O
worker_pool	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
MHD_Daemon	struct
)	O
*	O
daemon	function
->	O
worker_pool_size	int
)	O
;	O
if	O
(	O
NULL	O
==	O
daemon	function
->	O
worker_pool	pointer
)	O
goto	O
thread_failed	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
daemon	function
->	O
worker_pool_size	int
;	O
++	O
i	int
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
d	pointer
=	O
&	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
;	O
memcpy	function
(	O
d	pointer
,	O
daemon	function
,	O
sizeof	O
(	O
struct	O
MHD_Daemon	struct
)	O
)	O
;	O
d	pointer
->	O
master	pointer
=	O
daemon	function
;	O
d	pointer
->	O
worker_pool_size	int
=	O
0	int
;	O
d	pointer
->	O
worker_pool	pointer
=	O
NULL	O
;	O
if	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_ITC	int
)	O
)	O
{	O
if	O
(	O
!	O
MHD_itc_init_	O
(	O
d	pointer
->	O
itc	struct
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to create worker inter-thread communication channel: %s\n"	pointer
)	O
,	O
MHD_itc_last_strerror_	O
(	O
)	O
)	O
;	O
goto	O
thread_failed	O
;	O
}	O
if	O
(	O
(	O
0	int
==	O
(	O
*	O
pflags	pointer
&	O
(	O
MHD_USE_POLL	int
|	O
MHD_USE_EPOLL	int
)	O
)	O
)	O
&&	O
(	O
!	O
MHD_SCKT_FD_FITS_FDSET_	O
(	O
MHD_itc_r_fd_	O
(	O
d	pointer
->	O
itc	struct
)	O
,	O
NULL	O
)	O
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"File descriptor for worker inter-thread communication channel exceeds maximum value\n"	pointer
)	O
)	O
;	O
MHD_itc_destroy_chk_	O
(	O
d	pointer
->	O
itc	struct
)	O
;	O
goto	O
thread_failed	O
;	O
}	O
}	O
else	O
MHD_itc_set_invalid_	O
(	O
d	pointer
->	O
itc	struct
)	O
;	O
d	pointer
->	O
connection_limit	int
=	O
conns_per_thread	int
;	O
if	O
(	O
i	int
<	O
leftover_conns	int
)	O
++	O
d	pointer
->	O
connection_limit	int
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
*	O
pflags	pointer
&	O
MHD_USE_EPOLL	int
)	O
)	O
&&	O
(	O
MHD_YES	int
!=	O
setup_epoll_to_listen	function
(	O
d	pointer
)	O
)	O
)	O
goto	O
thread_failed	O
;	O
if	O
(	O
!	O
MHD_mutex_init_	O
(	O
&	O
d	pointer
->	O
cleanup_connection_mutex	union
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"MHD failed to initialize cleanup connection mutex\n"	pointer
)	O
)	O
;	O
goto	O
thread_failed	O
;	O
}	O
if	O
(	O
!	O
MHD_create_named_thread_	function
(	O
&	O
d	pointer
->	O
pid	int
,	O
"MHD-worker"	pointer
,	O
daemon	function
->	O
thread_stack_size	long
,	O
&	O
MHD_polling_thread	function
,	O
d	pointer
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Failed to create pool thread: %s\n"	pointer
)	O
,	O
MHD_strerror_	O
(	O
errno	O
)	O
)	O
;	O
MHD_mutex_destroy_chk_	O
(	O
&	O
d	pointer
->	O
cleanup_connection_mutex	union
)	O
;	O
goto	O
thread_failed	O
;	O
}	O
}	O
}	O
}	O
return	O
daemon	function
;	O
thread_failed	O
:	O
if	O
(	O
0	int
==	O
i	int
)	O
{	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
listen_fd	int
)	O
MHD_socket_close_chk_	O
(	O
listen_fd	int
)	O
;	O
MHD_mutex_destroy_chk_	O
(	O
&	O
daemon	function
->	O
per_ip_connection_mutex	union
)	O
;	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
worker_pool	pointer
)	O
free	function
(	O
daemon	function
->	O
worker_pool	pointer
)	O
;	O
goto	O
free_and_fail	O
;	O
}	O
daemon	function
->	O
worker_pool_size	int
=	O
i	int
;	O
MHD_stop_daemon	function
(	O
daemon	function
)	O
;	O
return	O
NULL	O
;	O
free_and_fail	O
:	O
if	O
(	O
-	O
1	int
!=	O
daemon	function
->	O
epoll_fd	int
)	O
close	pointer
(	O
daemon	function
->	O
epoll_fd	int
)	O
;	O
free	function
(	O
daemon	function
->	O
nnc	pointer
)	O
;	O
MHD_mutex_destroy_chk_	O
(	O
&	O
daemon	function
->	O
nnc_lock	union
)	O
;	O
if	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
MHD_itc_destroy_chk_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
free	function
(	O
daemon	function
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
close_all_connections	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
struct	O
MHD_Connection	struct
*	O
pos	long
;	O
const	O
bool	bool
used_thr_p_c	bool
=	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
;	O
const	O
bool	bool
upg_allowed	bool
=	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_ALLOW_UPGRADE	int
)	O
)	O
;	O
if	O
(	O
0	int
!=	O
(	O
MHD_TEST_ALLOW_SUSPEND_RESUME	int
&	O
daemon	function
->	O
options	enum
)	O
)	O
{	O
daemon	function
->	O
resuming	bool
=	O
true	int
;	O
resume_suspended_connections	function
(	O
daemon	function
)	O
;	O
}	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
upg_allowed	bool
)	O
{	O
struct	O
MHD_Connection	struct
*	O
susp	pointer
;	O
susp	pointer
=	O
daemon	function
->	O
suspended_connections_tail	pointer
;	O
while	O
(	O
NULL	O
!=	O
susp	pointer
)	O
{	O
if	O
(	O
NULL	O
==	O
susp	pointer
->	O
urh	pointer
)	O
MHD_PANIC	O
(	O
_	O
(	O
"MHD_stop_daemon() called while we have suspended connections.\n"	pointer
)	O
)	O
;	O
else	O
{	O
if	O
(	O
!	O
susp	pointer
->	O
urh	pointer
->	O
was_closed	bool
)	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Initiated daemon shutdown while \"upgraded\" connection was not closed.\n"	pointer
)	O
)	O
;	O
susp	pointer
->	O
urh	pointer
->	O
was_closed	bool
=	O
true	int
;	O
if	O
(	O
!	O
used_thr_p_c	bool
)	O
MHD_connection_finish_forward_	O
(	O
susp	pointer
)	O
;	O
susp	pointer
->	O
resuming	bool
=	O
true	int
;	O
daemon	function
->	O
resuming	bool
=	O
true	int
;	O
}	O
susp	pointer
=	O
susp	pointer
->	O
prev	pointer
;	O
}	O
}	O
else	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
suspended_connections_head	pointer
)	O
MHD_PANIC	O
(	O
_	O
(	O
"MHD_stop_daemon() called while we have suspended connections.\n"	pointer
)	O
)	O
;	O
for	O
(	O
pos	long
=	O
daemon	function
->	O
connections_tail	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
prev	pointer
)	O
{	O
shutdown	function
(	O
pos	long
->	O
socket_fd	int
,	O
SHUT_RDWR	int
)	O
;	O
}	O
if	O
(	O
used_thr_p_c	bool
)	O
{	O
pos	long
=	O
daemon	function
->	O
connections_tail	pointer
;	O
while	O
(	O
NULL	O
!=	O
pos	long
)	O
{	O
if	O
(	O
!	O
pos	long
->	O
thread_joined	bool
)	O
{	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
!	O
MHD_join_thread_	O
(	O
pos	long
->	O
pid	int
.	O
handle	long
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to join a thread\n"	pointer
)	O
)	O
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
pos	long
->	O
thread_joined	bool
=	O
true	int
;	O
pos	long
=	O
daemon	function
->	O
connections_tail	pointer
;	O
continue	O
;	O
}	O
pos	long
=	O
pos	long
->	O
prev	pointer
;	O
}	O
}	O
MHD_mutex_unlock_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
if	O
(	O
upg_allowed	bool
)	O
{	O
daemon	function
->	O
resuming	bool
=	O
true	int
;	O
resume_suspended_connections	function
(	O
daemon	function
)	O
;	O
}	O
while	O
(	O
NULL	O
!=	O
(	O
pos	long
=	O
daemon	function
->	O
connections_tail	pointer
)	O
)	O
{	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_THREAD_PER_CONNECTION	int
)	O
)	O
&&	O
(	O
!	O
pos	long
->	O
thread_joined	bool
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to join a thread\n"	pointer
)	O
)	O
;	O
close_connection	function
(	O
pos	long
)	O
;	O
}	O
MHD_cleanup_connections	function
(	O
daemon	function
)	O
;	O
}	O
void	O
MHD_stop_daemon	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
)	O
{	O
MHD_socket	int
fd	int
;	O
unsigned	O
int	O
i	int
;	O
if	O
(	O
NULL	O
==	O
daemon	function
)	O
return	O
;	O
daemon	function
->	O
shutdown	function
=	O
true	int
;	O
if	O
(	O
daemon	function
->	O
was_quiesced	bool
)	O
fd	int
=	O
MHD_INVALID_SOCKET	O
;	O
else	O
fd	int
=	O
daemon	function
->	O
listen_fd	int
;	O
if	O
(	O
NULL	O
!=	O
daemon	function
->	O
worker_pool	pointer
)	O
{	O
mhd_assert	O
(	O
1	int
<	O
daemon	function
->	O
worker_pool_size	int
)	O
;	O
mhd_assert	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
daemon	function
->	O
worker_pool_size	int
;	O
++	O
i	int
)	O
{	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
.	O
shutdown	function
=	O
true	int
;	O
if	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
.	O
itc	struct
)	O
)	O
{	O
if	O
(	O
!	O
MHD_itc_activate_	O
(	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
.	O
itc	struct
,	O
"e"	pointer
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to signal shutdown via inter-thread communication channel."	pointer
)	O
)	O
;	O
}	O
else	O
mhd_assert	O
(	O
MHD_INVALID_SOCKET	O
!=	O
fd	int
)	O
;	O
}	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
fd	int
)	O
{	O
(	O
void	O
)	O
shutdown	function
(	O
fd	int
,	O
SHUT_RDWR	int
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
daemon	function
->	O
worker_pool_size	int
;	O
++	O
i	int
)	O
{	O
MHD_stop_daemon	function
(	O
&	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
)	O
;	O
}	O
free	function
(	O
daemon	function
->	O
worker_pool	pointer
)	O
;	O
mhd_assert	O
(	O
MHD_ITC_IS_INVALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
;	O
mhd_assert	O
(	O
-	O
1	int
==	O
daemon	function
->	O
epoll_fd	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
{	O
mhd_assert	O
(	O
0	int
==	O
daemon	function
->	O
worker_pool_size	int
)	O
;	O
if	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
{	O
if	O
(	O
!	O
MHD_itc_activate_	O
(	O
daemon	function
->	O
itc	struct
,	O
"e"	pointer
)	O
)	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to signal shutdown via inter-thread communication channel"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
fd	int
)	O
{	O
if	O
(	O
NULL	O
==	O
daemon	function
->	O
master	pointer
)	O
(	O
void	O
)	O
shutdown	function
(	O
fd	int
,	O
SHUT_RDWR	int
)	O
;	O
}	O
else	O
mhd_assert	O
(	O
false	int
)	O
;	O
}	O
if	O
(	O
!	O
MHD_join_thread_	O
(	O
daemon	function
->	O
pid	int
.	O
handle	long
)	O
)	O
{	O
MHD_PANIC	O
(	O
_	O
(	O
"Failed to join a thread\n"	pointer
)	O
)	O
;	O
}	O
}	O
else	O
{	O
close_all_connections	function
(	O
daemon	function
)	O
;	O
}	O
if	O
(	O
MHD_ITC_IS_VALID_	O
(	O
daemon	function
->	O
itc	struct
)	O
)	O
MHD_itc_destroy_chk_	O
(	O
daemon	function
->	O
itc	struct
)	O
;	O
if	O
(	O
(	O
0	int
!=	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_EPOLL	int
)	O
)	O
&&	O
(	O
-	O
1	int
!=	O
daemon	function
->	O
epoll_fd	int
)	O
)	O
MHD_socket_close_chk_	O
(	O
daemon	function
->	O
epoll_fd	int
)	O
;	O
MHD_mutex_destroy_chk_	O
(	O
&	O
daemon	function
->	O
cleanup_connection_mutex	union
)	O
;	O
}	O
if	O
(	O
NULL	O
==	O
daemon	function
->	O
master	pointer
)	O
{	O
if	O
(	O
MHD_INVALID_SOCKET	O
!=	O
fd	int
)	O
MHD_socket_close_chk_	O
(	O
fd	int
)	O
;	O
free	function
(	O
daemon	function
->	O
nnc	pointer
)	O
;	O
MHD_mutex_destroy_chk_	O
(	O
&	O
daemon	function
->	O
nnc_lock	union
)	O
;	O
MHD_mutex_destroy_chk_	O
(	O
&	O
daemon	function
->	O
per_ip_connection_mutex	union
)	O
;	O
free	function
(	O
daemon	function
)	O
;	O
}	O
}	O
const	O
union	O
MHD_DaemonInfo	union
*	O
MHD_get_daemon_info	function
(	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
,	O
enum	O
MHD_DaemonInfoType	enum
info_type	enum
,	O
...	O
)	O
{	O
if	O
(	O
NULL	O
==	O
daemon	function
)	O
return	O
NULL	O
;	O
switch	O
(	O
info_type	enum
)	O
{	O
case	O
MHD_DAEMON_INFO_KEY_SIZE	int
:	O
return	O
NULL	O
;	O
case	O
MHD_DAEMON_INFO_MAC_KEY_SIZE	int
:	O
return	O
NULL	O
;	O
case	O
MHD_DAEMON_INFO_LISTEN_FD	int
:	O
return	O
(	O
const	O
union	O
MHD_DaemonInfo	union
*	O
)	O
&	O
daemon	function
->	O
listen_fd	int
;	O
case	O
MHD_DAEMON_INFO_EPOLL_FD	int
:	O
return	O
(	O
const	O
union	O
MHD_DaemonInfo	union
*	O
)	O
&	O
daemon	function
->	O
epoll_fd	int
;	O
case	O
MHD_DAEMON_INFO_CURRENT_CONNECTIONS	int
:	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_USE_INTERNAL_POLLING_THREAD	int
)	O
)	O
{	O
MHD_cleanup_connections	function
(	O
daemon	function
)	O
;	O
}	O
else	O
if	O
(	O
daemon	function
->	O
worker_pool	pointer
)	O
{	O
unsigned	O
int	O
i	int
;	O
daemon	function
->	O
connections	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
daemon	function
->	O
worker_pool_size	int
;	O
i	int
++	O
)	O
{	O
daemon	function
->	O
connections	int
+=	O
daemon	function
->	O
worker_pool	pointer
[	O
i	int
]	O
.	O
connections	int
;	O
}	O
}	O
return	O
(	O
const	O
union	O
MHD_DaemonInfo	union
*	O
)	O
&	O
daemon	function
->	O
connections	int
;	O
case	O
MHD_DAEMON_INFO_FLAGS	int
:	O
return	O
(	O
const	O
union	O
MHD_DaemonInfo	union
*	O
)	O
&	O
daemon	function
->	O
options	enum
;	O
case	O
MHD_DAEMON_INFO_BIND_PORT	int
:	O
return	O
(	O
const	O
union	O
MHD_DaemonInfo	union
*	O
)	O
&	O
daemon	function
->	O
port	short
;	O
default	O
:	O
return	O
NULL	O
;	O
}	O
}	O
void	O
MHD_set_panic_func	function
(	O
MHD_PanicCallback	pointer
cb	pointer
,	O
void	O
*	O
cls	pointer
)	O
{	O
mhd_panic	pointer
=	O
cb	pointer
;	O
mhd_panic_cls	pointer
=	O
cls	pointer
;	O
}	O
const	O
char	O
*	O
MHD_get_version	function
(	O
void	O
)	O
{	O
return	O
PACKAGE_VERSION	pointer
;	O
}	O
_MHD_EXTERN	O
int	O
MHD_is_feature_supported	function
(	O
enum	O
MHD_FEATURE	enum
feature	enum
)	O
{	O
switch	O
(	O
feature	enum
)	O
{	O
case	O
MHD_FEATURE_MESSAGES	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_TLS	int
:	O
return	O
MHD_NO	int
;	O
case	O
MHD_FEATURE_HTTPS_CERT_CALLBACK	int
:	O
return	O
MHD_NO	int
;	O
case	O
MHD_FEATURE_HTTPS_CERT_CALLBACK2	int
:	O
return	O
MHD_NO	int
;	O
case	O
MHD_FEATURE_IPv6	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_IPv6_ONLY	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_POLL	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_EPOLL	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_SHUTDOWN_LISTEN_SOCKET	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_SOCKETPAIR	int
:	O
return	O
MHD_NO	int
;	O
case	O
MHD_FEATURE_TCP_FASTOPEN	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_BASIC_AUTH	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_DIGEST_AUTH	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_POSTPROCESSOR	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_HTTPS_KEY_PASSWORD	int
:	O
return	O
MHD_NO	int
;	O
case	O
MHD_FEATURE_LARGE_FILE	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_THREAD_NAMES	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_UPGRADE	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_RESPONSES_SHARED_FD	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_AUTODETECT_BIND_PORT	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_AUTOSUPPRESS_SIGPIPE	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_SENDFILE	int
:	O
return	O
MHD_YES	int
;	O
case	O
MHD_FEATURE_THREADS	int
:	O
return	O
MHD_YES	int
;	O
}	O
return	O
MHD_NO	int
;	O
}	O
void	O
MHD_init	function
(	O
void	O
)	O
{	O
if	O
(	O
NULL	O
==	O
mhd_panic	pointer
)	O
mhd_panic	pointer
=	O
&	O
mhd_panic_std	function
;	O
MHD_monotonic_sec_counter_init	function
(	O
)	O
;	O
MHD_init_mem_pools_	function
(	O
)	O
;	O
}	O
void	O
MHD_fini	function
(	O
void	O
)	O
{	O
MHD_monotonic_sec_counter_finish	function
(	O
)	O
;	O
}	O
_SET_INIT_AND_DEINIT_FUNCS	O
(	O
MHD_init	function
,	O
MHD_fini	function
)	O
;	O
