enum	O
dict_symbol_type	enum
{	O
dict_symbol_uninitialized	int
,	O
dict_symbol_attribute	int
,	O
dict_symbol_alias	int
}	O
;	O
typedef	O
struct	O
dict_symbol	struct
DICT_SYMBOL	struct
;	O
struct	O
dict_symbol	struct
{	O
DICT_SYMBOL	struct
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
enum	O
dict_symbol_type	enum
type	int
;	O
union	O
{	O
grad_dict_attr_t	struct
attr	pointer
;	O
grad_dict_attr_t	struct
*	O
alias	pointer
;	O
}	O
v	union
;	O
}	O
;	O
static	O
grad_symtab_t	struct
*	O
dict_attr_tab	pointer
;	O
static	O
grad_dict_attr_t	struct
*	O
dict_attr_index	array
[	O
DICT_INDEX_SIZE	int
]	O
;	O
static	O
grad_list_t	struct
*	O
dictionary_values	pointer
;	O
static	O
grad_list_t	struct
*	O
dictionary_vendors	pointer
;	O
static	O
int	O
vendorno	int
;	O
static	O
grad_dict_attr_t	struct
*	O
dict_symbol_ptr	function
(	O
DICT_SYMBOL	struct
*	O
sym	pointer
)	O
{	O
switch	O
(	O
sym	pointer
->	O
type	int
)	O
{	O
case	O
dict_symbol_uninitialized	int
:	O
grad_insist_fail	O
(	O
"uninitialized dictionary symbol found!"	pointer
)	O
;	O
break	O
;	O
case	O
dict_symbol_attribute	int
:	O
return	O
&	O
sym	pointer
->	O
v	union
.	O
attr	pointer
;	O
case	O
dict_symbol_alias	int
:	O
return	O
sym	pointer
->	O
v	union
.	O
alias	pointer
;	O
}	O
}	O
static	O
grad_dict_attr_t	struct
*	O
dict_attr_lookup	function
(	O
const	O
char	O
*	O
ident	pointer
)	O
{	O
DICT_SYMBOL	struct
*	O
sym	pointer
=	O
grad_sym_lookup	function
(	O
dict_attr_tab	pointer
,	O
ident	pointer
)	O
;	O
if	O
(	O
sym	pointer
)	O
return	O
dict_symbol_ptr	function
(	O
sym	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
free_vendor	function
(	O
void	O
*	O
ptr	pointer
,	O
void	O
*	O
closure	pointer
ARG_UNUSED	O
)	O
{	O
grad_dict_vendor_t	struct
*	O
vp	pointer
=	O
ptr	pointer
;	O
if	O
(	O
vp	pointer
->	O
vendorname	pointer
)	O
grad_free	function
(	O
vp	pointer
->	O
vendorname	pointer
)	O
;	O
grad_free	function
(	O
vp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
free_value	function
(	O
void	O
*	O
ptr	pointer
,	O
void	O
*	O
closure	pointer
ARG_UNUSED	O
)	O
{	O
grad_dict_value_t	struct
*	O
vp	pointer
=	O
ptr	pointer
;	O
grad_free	function
(	O
vp	pointer
->	O
name	pointer
)	O
;	O
grad_free	function
(	O
vp	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
dict_free	function
(	O
)	O
{	O
grad_symtab_free	function
(	O
&	O
dict_attr_tab	pointer
)	O
;	O
memset	function
(	O
dict_attr_index	array
,	O
0	int
,	O
sizeof	O
dict_attr_index	array
)	O
;	O
grad_list_destroy	function
(	O
&	O
dictionary_values	pointer
,	O
free_value	function
,	O
NULL	O
)	O
;	O
grad_list_destroy	function
(	O
&	O
dictionary_vendors	pointer
,	O
free_vendor	function
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
nfields	function
(	O
int	O
fc	int
,	O
int	O
minf	int
,	O
int	O
maxf	int
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
if	O
(	O
fc	int
<	O
minf	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"too few fields"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
else	O
if	O
(	O
maxf	int
!=	O
-	O
1	int
&&	O
fc	int
>	O
maxf	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"too many fields"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
addvendor	function
(	O
char	O
*	O
name	pointer
,	O
int	O
value	pointer
)	O
{	O
grad_dict_vendor_t	struct
*	O
vval	pointer
;	O
vval	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
grad_dict_vendor_t	struct
)	O
)	O
;	O
vval	pointer
->	O
vendorname	pointer
=	O
grad_estrdup	function
(	O
name	pointer
)	O
;	O
vval	pointer
->	O
vendorpec	int
=	O
value	pointer
;	O
vval	pointer
->	O
vendorcode	int
=	O
vendorno	int
++	O
;	O
if	O
(	O
!	O
dictionary_vendors	pointer
)	O
dictionary_vendors	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_list_prepend	function
(	O
dictionary_vendors	pointer
,	O
vval	pointer
)	O
;	O
return	O
0	int
;	O
}	O
typedef	O
struct	O
attr_parser_tab	struct
ATTR_PARSER_TAB	struct
;	O
struct	O
attr_parser_tab	struct
{	O
ATTR_PARSER_TAB	struct
*	O
next	pointer
;	O
int	O
attr	pointer
;	O
grad_attr_parser_fp	pointer
fun	pointer
;	O
}	O
;	O
static	O
ATTR_PARSER_TAB	struct
*	O
attr_parser_tab	struct
;	O
static	O
grad_attr_parser_fp	pointer
dict_find_parser	function
(	O
int	O
attr	pointer
)	O
{	O
ATTR_PARSER_TAB	struct
*	O
ep	pointer
;	O
for	O
(	O
ep	pointer
=	O
attr_parser_tab	struct
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
if	O
(	O
ep	pointer
->	O
attr	pointer
==	O
attr	pointer
)	O
return	O
ep	pointer
->	O
fun	pointer
;	O
return	O
NULL	O
;	O
}	O
void	O
dict_register_parser	function
(	O
int	O
attr	pointer
,	O
grad_attr_parser_fp	pointer
fun	pointer
)	O
{	O
ATTR_PARSER_TAB	struct
*	O
e	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
e	pointer
)	O
)	O
;	O
e	pointer
->	O
attr	pointer
=	O
attr	pointer
;	O
e	pointer
->	O
fun	pointer
=	O
fun	pointer
;	O
e	pointer
->	O
next	pointer
=	O
attr_parser_tab	struct
;	O
attr_parser_tab	struct
=	O
e	pointer
;	O
}	O
static	O
void	O
parser_tab_init	function
(	O
)	O
{	O
if	O
(	O
!	O
attr_parser_tab	struct
)	O
{	O
dict_register_parser	function
(	O
242	int
,	O
grad_ascend_parse_filter	function
)	O
;	O
dict_register_parser	function
(	O
243	int
,	O
grad_ascend_parse_filter	function
)	O
;	O
}	O
}	O
static	O
void	O
parser_tab_free	function
(	O
)	O
{	O
ATTR_PARSER_TAB	struct
*	O
ep	pointer
=	O
attr_parser_tab	struct
;	O
while	O
(	O
ep	pointer
)	O
{	O
ATTR_PARSER_TAB	struct
*	O
next	pointer
=	O
ep	pointer
->	O
next	pointer
;	O
grad_free	function
(	O
ep	pointer
)	O
;	O
ep	pointer
=	O
next	pointer
;	O
}	O
attr_parser_tab	struct
=	O
NULL	O
;	O
}	O
static	O
int	O
parse_dict	function
(	O
char	O
*	O
name	pointer
)	O
;	O
static	O
grad_keyword_t	struct
type_kw	array
[	O
]	O
=	O
{	O
{	O
"string"	pointer
,	O
GRAD_TYPE_STRING	int
}	O
,	O
{	O
"integer"	pointer
,	O
GRAD_TYPE_INTEGER	int
}	O
,	O
{	O
"ipaddr"	pointer
,	O
GRAD_TYPE_IPADDR	int
}	O
,	O
{	O
"date"	pointer
,	O
GRAD_TYPE_DATE	int
}	O
}	O
;	O
struct	O
parse_data	struct
{	O
int	O
vendor	int
;	O
grad_locus_t	struct
begin_locus	struct
;	O
int	O
errcnt	long
;	O
}	O
;	O
static	O
int	O
_dict_include	function
(	O
struct	O
parse_data	struct
*	O
pd	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
if	O
(	O
nfields	function
(	O
fc	int
,	O
2	int
,	O
2	int
,	O
loc	struct
)	O
)	O
return	O
0	int
;	O
parse_dict	function
(	O
fv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_flags	function
(	O
char	O
*	O
*	O
ptr	pointer
,	O
int	O
*	O
flags	int
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
int	O
i	int
;	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
*	O
ptr	pointer
+	O
1	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
GRAD_CF_MAX	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
0	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"missing ]"	pointer
)	O
,	O
*	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
switch	O
(	O
*	O
p	pointer
++	O
)	O
{	O
case	O
'C'	O
:	O
case	O
'L'	O
:	O
*	O
flags	int
|=	O
GRAD_AF_LHS	O
(	O
i	int
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
*	O
flags	int
&=	O
~	O
GRAD_AF_LHS	O
(	O
i	int
)	O
;	O
break	O
;	O
case	O
']'	O
:	O
p	pointer
--	O
;	O
goto	O
stop	O
;	O
default	O
:	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"invalid syntax flag %c"	pointer
)	O
,	O
p	pointer
[	O
-	O
1	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
switch	O
(	O
*	O
p	pointer
++	O
)	O
{	O
case	O
'R'	O
:	O
*	O
flags	int
|=	O
GRAD_AF_RHS	O
(	O
i	int
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
*	O
flags	int
&=	O
~	O
GRAD_AF_RHS	O
(	O
i	int
)	O
;	O
break	O
;	O
default	O
:	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"invalid syntax flag %c"	pointer
)	O
,	O
p	pointer
[	O
-	O
1	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
}	O
stop	O
:	O
for	O
(	O
;	O
i	int
<	O
GRAD_CF_MAX	int
;	O
i	int
++	O
)	O
*	O
flags	int
|=	O
GRAD_AF_LHS	O
(	O
i	int
)	O
|	O
GRAD_AF_RHS	O
(	O
i	int
)	O
;	O
*	O
ptr	pointer
=	O
p	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_attr_properties	function
(	O
grad_locus_t	struct
*	O
loc	struct
,	O
char	O
*	O
str	pointer
,	O
int	O
*	O
flags	int
,	O
int	O
*	O
prop	int
)	O
{	O
int	O
errcnt	long
=	O
0	int
;	O
char	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
str	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
{	O
switch	O
(	O
*	O
p	pointer
)	O
{	O
case	O
'C'	O
:	O
case	O
'L'	O
:	O
*	O
flags	int
|=	O
GRAD_AF_LHS	O
(	O
GRAD_CF_USERS	int
)	O
|	O
GRAD_AF_LHS	O
(	O
GRAD_CF_HINTS	int
)	O
|	O
GRAD_AF_LHS	O
(	O
GRAD_CF_HUNTGROUPS	int
)	O
;	O
break	O
;	O
case	O
'R'	O
:	O
*	O
flags	int
|=	O
GRAD_AF_RHS	O
(	O
GRAD_CF_USERS	int
)	O
|	O
GRAD_AF_RHS	O
(	O
GRAD_CF_HINTS	int
)	O
|	O
GRAD_AF_RHS	O
(	O
GRAD_CF_HUNTGROUPS	int
)	O
;	O
break	O
;	O
case	O
'['	O
:	O
if	O
(	O
parse_flags	function
(	O
&	O
p	pointer
,	O
flags	int
,	O
loc	struct
)	O
)	O
{	O
while	O
(	O
*	O
++	O
p	pointer
)	O
;	O
--	O
p	pointer
;	O
errcnt	long
++	O
;	O
}	O
break	O
;	O
case	O
'='	O
:	O
GRAD_SET_ADDITIVITY	O
(	O
*	O
prop	int
,	O
GRAD_AP_ADD_REPLACE	int
)	O
;	O
break	O
;	O
case	O
'+'	O
:	O
GRAD_SET_ADDITIVITY	O
(	O
*	O
prop	int
,	O
GRAD_AP_ADD_APPEND	int
)	O
;	O
break	O
;	O
case	O
'N'	O
:	O
GRAD_SET_ADDITIVITY	O
(	O
*	O
prop	int
,	O
GRAD_AP_ADD_NONE	int
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
*	O
prop	int
|=	O
GRAD_AP_PROPAGATE	int
;	O
break	O
;	O
case	O
'l'	O
:	O
*	O
flags	int
&=	O
~	O
GRAD_AP_INTERNAL	int
;	O
break	O
;	O
case	O
'1'	O
:	O
case	O
'2'	O
:	O
case	O
'3'	O
:	O
case	O
'4'	O
:	O
case	O
'5'	O
:	O
case	O
'6'	O
:	O
case	O
'7'	O
:	O
case	O
'8'	O
:	O
case	O
'9'	O
:	O
*	O
prop	int
|=	O
GRAD_AP_USER_FLAG	O
(	O
*	O
p	pointer
-	O
'0'	O
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
*	O
prop	int
|=	O
GRAD_AP_BINARY_STRING	int
;	O
break	O
;	O
case	O
'E'	O
:	O
*	O
prop	int
|=	O
GRAD_AP_ENCRYPT_RFC2138	int
;	O
break	O
;	O
case	O
'T'	O
:	O
*	O
prop	int
|=	O
GRAD_AP_ENCRYPT_RFC2868	int
;	O
break	O
;	O
case	O
'c'	O
:	O
break	O
;	O
default	O
:	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"invalid flag %c"	pointer
)	O
,	O
*	O
p	pointer
)	O
;	O
errcnt	long
++	O
;	O
break	O
;	O
}	O
}	O
return	O
errcnt	long
;	O
}	O
static	O
void	O
set_default_attr_properties	function
(	O
int	O
value	pointer
,	O
int	O
*	O
flags	int
,	O
int	O
*	O
prop	int
)	O
{	O
*	O
flags	int
=	O
GRAD_AF_DEFAULT_FLAGS	O
;	O
*	O
prop	int
=	O
GRAD_AP_DEFAULT_ADD	O
;	O
if	O
(	O
GRAD_VENDOR_CODE	O
(	O
value	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
value	pointer
>	O
255	int
)	O
*	O
flags	int
|=	O
GRAD_AP_INTERNAL	int
;	O
else	O
if	O
(	O
value	pointer
==	O
DA_USER_PASSWORD	int
||	O
value	pointer
==	O
DA_USER_PASSWORD	int
)	O
*	O
prop	int
|=	O
GRAD_AP_ENCRYPT_RFC2138	int
;	O
}	O
}	O
static	O
int	O
_dict_attribute	function
(	O
struct	O
parse_data	struct
*	O
pd	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
DICT_SYMBOL	struct
*	O
sym	pointer
;	O
grad_dict_attr_t	struct
*	O
attr	pointer
;	O
int	O
type	int
;	O
int	O
vendor	int
=	O
0	int
;	O
unsigned	O
value	pointer
;	O
char	O
*	O
p	pointer
;	O
grad_attr_parser_fp	pointer
fp	pointer
=	O
NULL	O
;	O
int	O
flags	int
;	O
int	O
prop	int
;	O
if	O
(	O
nfields	function
(	O
fc	int
,	O
4	int
,	O
6	int
,	O
loc	struct
)	O
)	O
return	O
0	int
;	O
GRAD_DEBUG7	O
(	O
100	int
,	O
"%s:%lu: ATTR_NAME=%s ATTR_VALUE=%s ATTR_TYPE=%s ATTR_VENDOR=%s ATTR_FLAGS=%s"	pointer
,	O
loc	struct
->	O
file	pointer
,	O
loc	struct
->	O
line	long
,	O
ATTR_NAME	O
,	O
ATTR_VALUE	O
,	O
ATTR_TYPE	O
,	O
HAS_VENDOR	O
(	O
fc	int
,	O
fv	pointer
)	O
?	O
ATTR_VENDOR	O
:	O
pd	pointer
->	O
vendor	int
?	O
"BLOCK"	pointer
:	O
"N/A"	pointer
,	O
HAS_FLAGS	O
(	O
fc	int
,	O
fv	pointer
)	O
?	O
ATTR_FLAGS	O
:	O
"N/A"	pointer
)	O
;	O
value	pointer
=	O
strtol	function
(	O
ATTR_VALUE	O
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"value not a number (near %s)"	pointer
)	O
,	O
p	pointer
)	O
;	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
strcmp	function
(	O
ATTR_TYPE	O
,	O
"abinary"	pointer
)	O
==	O
0	int
)	O
{	O
type	int
=	O
GRAD_TYPE_STRING	int
;	O
fp	pointer
=	O
dict_find_parser	function
(	O
value	pointer
)	O
;	O
if	O
(	O
!	O
fp	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_WARN	int
,	O
loc	struct
,	O
_	O
(	O
"no parser registered for this attribute"	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
type	int
=	O
grad_xlat_keyword	function
(	O
type_kw	array
,	O
ATTR_TYPE	O
,	O
GRAD_TYPE_INVALID	O
)	O
;	O
if	O
(	O
type	int
==	O
GRAD_TYPE_INVALID	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"invalid type"	pointer
)	O
)	O
;	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
HAS_VENDOR	O
(	O
fc	int
,	O
fv	pointer
)	O
)	O
{	O
if	O
(	O
(	O
vendor	int
=	O
grad_vendor_name_to_id	function
(	O
ATTR_VENDOR	O
)	O
)	O
==	O
0	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"unknown vendor"	pointer
)	O
)	O
;	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
pd	pointer
->	O
vendor	int
)	O
vendor	int
=	O
pd	pointer
->	O
vendor	int
;	O
value	pointer
|=	O
(	O
vendor	int
<<	O
16	int
)	O
;	O
set_default_attr_properties	function
(	O
value	pointer
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
;	O
if	O
(	O
HAS_FLAGS	O
(	O
fc	int
,	O
fv	pointer
)	O
)	O
{	O
int	O
rc	int
=	O
parse_attr_properties	function
(	O
loc	struct
,	O
ATTR_FLAGS	O
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
}	O
sym	pointer
=	O
grad_sym_lookup_or_install	function
(	O
dict_attr_tab	pointer
,	O
ATTR_NAME	O
,	O
1	int
)	O
;	O
switch	O
(	O
sym	pointer
->	O
type	int
)	O
{	O
case	O
dict_symbol_uninitialized	int
:	O
sym	pointer
->	O
type	int
=	O
dict_symbol_attribute	int
;	O
attr	pointer
=	O
&	O
sym	pointer
->	O
v	union
.	O
attr	pointer
;	O
break	O
;	O
case	O
dict_symbol_attribute	int
:	O
grad_log_loc	function
(	O
GRAD_LOG_WARN	int
,	O
loc	struct
,	O
_	O
(	O
"Redefining attribute %s"	pointer
)	O
,	O
ATTR_NAME	O
)	O
;	O
attr	pointer
=	O
&	O
sym	pointer
->	O
v	union
.	O
attr	pointer
;	O
break	O
;	O
case	O
dict_symbol_alias	int
:	O
grad_log_loc	function
(	O
GRAD_LOG_WARN	int
,	O
loc	struct
,	O
_	O
(	O
"Redefining alias %s"	pointer
)	O
,	O
ATTR_NAME	O
)	O
;	O
attr	pointer
=	O
sym	pointer
->	O
v	union
.	O
alias	pointer
;	O
}	O
attr	pointer
->	O
name	pointer
=	O
sym	pointer
->	O
name	pointer
;	O
attr	pointer
->	O
value	pointer
=	O
value	pointer
;	O
attr	pointer
->	O
type	int
=	O
type	int
;	O
attr	pointer
->	O
prop	int
=	O
flags	int
|	O
prop	int
;	O
attr	pointer
->	O
parser	pointer
=	O
fp	pointer
;	O
if	O
(	O
attr	pointer
->	O
value	pointer
>=	O
0	int
&&	O
attr	pointer
->	O
value	pointer
<	O
DICT_INDEX_SIZE	int
)	O
dict_attr_index	array
[	O
attr	pointer
->	O
value	pointer
]	O
=	O
attr	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_dict_alias	function
(	O
struct	O
parse_data	struct
*	O
pd	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
DICT_SYMBOL	struct
*	O
sym	pointer
;	O
grad_dict_attr_t	struct
*	O
attr	pointer
;	O
if	O
(	O
nfields	function
(	O
fc	int
,	O
3	int
,	O
3	int
,	O
loc	struct
)	O
)	O
return	O
0	int
;	O
attr	pointer
=	O
dict_attr_lookup	function
(	O
fv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
attr	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"Attribute %s is not defined"	pointer
)	O
,	O
fv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
sym	pointer
=	O
grad_sym_lookup_or_install	function
(	O
dict_attr_tab	pointer
,	O
fv	pointer
[	O
2	int
]	O
,	O
1	int
)	O
;	O
if	O
(	O
sym	pointer
->	O
type	int
!=	O
dict_symbol_uninitialized	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"Symbol %s already declared"	pointer
)	O
,	O
fv	pointer
[	O
2	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
sym	pointer
->	O
type	int
=	O
dict_symbol_alias	int
;	O
sym	pointer
->	O
v	union
.	O
alias	pointer
=	O
attr	pointer
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_dict_property	function
(	O
struct	O
parse_data	struct
*	O
pd	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
grad_dict_attr_t	struct
*	O
attr	pointer
;	O
int	O
i	int
;	O
int	O
flags	int
;	O
int	O
prop	int
;	O
if	O
(	O
nfields	function
(	O
fc	int
,	O
3	int
,	O
-	O
1	int
,	O
loc	struct
)	O
)	O
return	O
0	int
;	O
attr	pointer
=	O
dict_attr_lookup	function
(	O
fv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
attr	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"Attribute %s is not defined"	pointer
)	O
,	O
fv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
0	int
;	O
}	O
for	O
(	O
i	int
=	O
2	int
;	O
i	int
<	O
fc	int
;	O
i	int
++	O
)	O
{	O
switch	O
(	O
fv	pointer
[	O
i	int
]	O
[	O
0	int
]	O
)	O
{	O
case	O
'+'	O
:	O
flags	int
=	O
prop	int
=	O
0	int
;	O
if	O
(	O
parse_attr_properties	function
(	O
loc	struct
,	O
fv	pointer
[	O
i	int
]	O
+	O
1	int
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
)	O
{	O
pd	pointer
->	O
errcnt	long
++	O
;	O
break	O
;	O
}	O
attr	pointer
->	O
prop	int
|=	O
flags	int
|	O
prop	int
;	O
break	O
;	O
case	O
'-'	O
:	O
flags	int
=	O
prop	int
=	O
0	int
;	O
if	O
(	O
parse_attr_properties	function
(	O
loc	struct
,	O
fv	pointer
[	O
i	int
]	O
+	O
1	int
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
)	O
{	O
pd	pointer
->	O
errcnt	long
++	O
;	O
break	O
;	O
}	O
attr	pointer
->	O
prop	int
&=	O
~	O
(	O
flags	int
|	O
prop	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
i	int
>	O
2	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"PROPERTY syntax error"	pointer
)	O
)	O
;	O
pd	pointer
->	O
errcnt	long
++	O
;	O
}	O
else	O
{	O
set_default_attr_properties	function
(	O
attr	pointer
->	O
value	pointer
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
;	O
if	O
(	O
parse_attr_properties	function
(	O
loc	struct
,	O
fv	pointer
[	O
i	int
]	O
,	O
&	O
flags	int
,	O
&	O
prop	int
)	O
==	O
0	int
)	O
attr	pointer
->	O
prop	int
=	O
flags	int
|	O
prop	int
;	O
else	O
pd	pointer
->	O
errcnt	long
++	O
;	O
break	O
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
_dict_value	function
(	O
struct	O
parse_data	struct
*	O
pd	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
grad_dict_value_t	struct
*	O
dval	pointer
;	O
grad_dict_attr_t	struct
*	O
attr	pointer
;	O
char	O
*	O
p	pointer
;	O
int	O
value	pointer
;	O
if	O
(	O
nfields	function
(	O
fc	int
,	O
4	int
,	O
4	int
,	O
loc	struct
)	O
)	O
return	O
0	int
;	O
value	pointer
=	O
strtol	function
(	O
VALUE_NUM	O
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"value not a number (near %s)"	pointer
)	O
,	O
p	pointer
)	O
;	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
attr	pointer
=	O
dict_attr_lookup	function
(	O
VALUE_ATTR	O
)	O
;	O
if	O
(	O
!	O
attr	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"Attribute %s is not defined"	pointer
)	O
,	O
VALUE_ATTR	O
)	O
;	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
0	int
;	O
}	O
attr	pointer
->	O
prop	int
|=	O
GRAD_AP_TRANSLATE	int
;	O
dval	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
grad_dict_value_t	struct
)	O
)	O
;	O
dval	pointer
->	O
name	pointer
=	O
grad_estrdup	function
(	O
VALUE_NAME	O
)	O
;	O
dval	pointer
->	O
attr	pointer
=	O
attr	pointer
;	O
dval	pointer
->	O
value	pointer
=	O
value	pointer
;	O
if	O
(	O
!	O
dictionary_values	pointer
)	O
dictionary_values	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
grad_list_append	function
(	O
dictionary_values	pointer
,	O
dval	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
_dict_vendor	function
(	O
struct	O
parse_data	struct
*	O
pd	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
int	O
value	pointer
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
nfields	function
(	O
fc	int
,	O
3	int
,	O
3	int
,	O
loc	struct
)	O
)	O
return	O
1	int
;	O
value	pointer
=	O
strtol	function
(	O
VENDOR_VALUE	O
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"value not a number (near %s)"	pointer
)	O
,	O
p	pointer
)	O
;	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
addvendor	function
(	O
VENDOR_NAME	O
,	O
value	pointer
)	O
<	O
0	int
)	O
{	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
_dict_begin	function
(	O
struct	O
parse_data	struct
*	O
pd	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
if	O
(	O
pd	pointer
->	O
vendor	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"blocks cannot be nested"	pointer
)	O
)	O
;	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
pd	pointer
->	O
begin_locus	struct
,	O
_	O
(	O
"block opened here"	pointer
)	O
)	O
;	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
;	O
}	O
if	O
(	O
nfields	function
(	O
fc	int
,	O
3	int
,	O
4	int
,	O
loc	struct
)	O
)	O
{	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
fv	pointer
[	O
1	int
]	O
,	O
"VENDOR"	pointer
)	O
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"block syntax: expected `VENDOR' but found `%s'"	pointer
)	O
,	O
fv	pointer
[	O
1	int
]	O
)	O
;	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
;	O
}	O
if	O
(	O
fc	int
==	O
4	int
&&	O
_dict_vendor	function
(	O
pd	pointer
,	O
fc	int
-	O
1	int
,	O
fv	pointer
+	O
1	int
,	O
loc	struct
)	O
)	O
return	O
;	O
if	O
(	O
(	O
pd	pointer
->	O
vendor	int
=	O
grad_vendor_name_to_id	function
(	O
fv	pointer
[	O
2	int
]	O
)	O
)	O
==	O
0	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"unknown vendor"	pointer
)	O
)	O
;	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
;	O
}	O
pd	pointer
->	O
begin_locus	struct
=	O
*	O
loc	struct
;	O
GRAD_DEBUG4	O
(	O
1	int
,	O
"%s:%lu: BEGIN VENDOR %s (%d)"	pointer
,	O
loc	struct
->	O
file	pointer
,	O
loc	struct
->	O
line	long
,	O
fv	pointer
[	O
2	int
]	O
,	O
pd	pointer
->	O
vendor	int
)	O
;	O
}	O
static	O
void	O
_dict_end	function
(	O
struct	O
parse_data	struct
*	O
pd	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
if	O
(	O
!	O
pd	pointer
->	O
vendor	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
_	O
(	O
"unexpected END"	pointer
)	O
)	O
;	O
pd	pointer
->	O
errcnt	long
++	O
;	O
}	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"END VENDOR %d"	pointer
,	O
pd	pointer
->	O
vendor	int
)	O
;	O
pd	pointer
->	O
vendor	int
=	O
0	int
;	O
}	O
static	O
void	O
_dict_begin_vendor	function
(	O
struct	O
parse_data	struct
*	O
pd	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
char	O
*	O
args	pointer
[	O
4	int
]	O
;	O
if	O
(	O
nfields	function
(	O
fc	int
,	O
2	int
,	O
2	int
,	O
loc	struct
)	O
)	O
{	O
pd	pointer
->	O
errcnt	long
++	O
;	O
return	O
;	O
}	O
args	pointer
[	O
0	int
]	O
=	O
"BEGIN"	pointer
;	O
args	pointer
[	O
1	int
]	O
=	O
"VENDOR"	pointer
;	O
args	pointer
[	O
2	int
]	O
=	O
fv	pointer
[	O
1	int
]	O
;	O
args	pointer
[	O
3	int
]	O
=	O
NULL	O
;	O
_dict_begin	function
(	O
pd	pointer
,	O
3	int
,	O
args	pointer
,	O
loc	struct
)	O
;	O
}	O
static	O
void	O
_dict_end_vendor	function
(	O
struct	O
parse_data	struct
*	O
pd	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
_dict_end	function
(	O
pd	pointer
,	O
fc	int
,	O
fv	pointer
,	O
loc	struct
)	O
;	O
}	O
enum	O
{	O
KW_INCLUDE	int
,	O
KW_ATTRIBUTE	int
,	O
KW_ALIAS	int
,	O
KW_VALUE	int
,	O
KW_VENDOR	int
,	O
KW_PROPERTY	int
,	O
KW_BEGIN	int
,	O
KW_BEGIN_VENDOR	int
,	O
KW_END_VENDOR	int
,	O
KW_END	int
}	O
;	O
static	O
grad_keyword_t	struct
dict_kw	array
[	O
]	O
=	O
{	O
{	O
"$INCLUDE"	pointer
,	O
KW_INCLUDE	int
}	O
,	O
{	O
"ATTRIBUTE"	pointer
,	O
KW_ATTRIBUTE	int
}	O
,	O
{	O
"ALIAS"	pointer
,	O
KW_ALIAS	int
}	O
,	O
{	O
"VALUE"	pointer
,	O
KW_VALUE	int
}	O
,	O
{	O
"VENDOR"	pointer
,	O
KW_VENDOR	int
}	O
,	O
{	O
"PROPERTY"	pointer
,	O
KW_PROPERTY	int
}	O
,	O
{	O
"BEGIN"	pointer
,	O
KW_BEGIN	int
}	O
,	O
{	O
"END"	pointer
,	O
KW_END	int
}	O
,	O
{	O
"BEGIN-VENDOR"	pointer
,	O
KW_BEGIN_VENDOR	int
}	O
,	O
{	O
"END-VENDOR"	pointer
,	O
KW_END_VENDOR	int
}	O
,	O
{	O
NULL	O
,	O
0	int
}	O
}	O
;	O
static	O
int	O
parse_dict_entry	function
(	O
void	O
*	O
closure	pointer
,	O
int	O
fc	int
,	O
char	O
*	O
*	O
fv	pointer
,	O
grad_locus_t	struct
*	O
loc	struct
)	O
{	O
struct	O
parse_data	struct
*	O
pd	pointer
=	O
closure	pointer
;	O
switch	O
(	O
grad_xlat_keyword	function
(	O
dict_kw	array
,	O
KEYWORD	O
,	O
-	O
1	int
)	O
)	O
{	O
case	O
KW_INCLUDE	int
:	O
_dict_include	function
(	O
pd	pointer
,	O
fc	int
,	O
fv	pointer
,	O
loc	struct
)	O
;	O
break	O
;	O
case	O
KW_ATTRIBUTE	int
:	O
_dict_attribute	function
(	O
pd	pointer
,	O
fc	int
,	O
fv	pointer
,	O
loc	struct
)	O
;	O
break	O
;	O
case	O
KW_ALIAS	int
:	O
_dict_alias	function
(	O
pd	pointer
,	O
fc	int
,	O
fv	pointer
,	O
loc	struct
)	O
;	O
break	O
;	O
case	O
KW_VALUE	int
:	O
_dict_value	function
(	O
pd	pointer
,	O
fc	int
,	O
fv	pointer
,	O
loc	struct
)	O
;	O
break	O
;	O
case	O
KW_VENDOR	int
:	O
_dict_vendor	function
(	O
pd	pointer
,	O
fc	int
,	O
fv	pointer
,	O
loc	struct
)	O
;	O
break	O
;	O
case	O
KW_PROPERTY	int
:	O
_dict_property	function
(	O
pd	pointer
,	O
fc	int
,	O
fv	pointer
,	O
loc	struct
)	O
;	O
break	O
;	O
case	O
KW_BEGIN	int
:	O
_dict_begin	function
(	O
pd	pointer
,	O
fc	int
,	O
fv	pointer
,	O
loc	struct
)	O
;	O
break	O
;	O
case	O
KW_END	int
:	O
_dict_end	function
(	O
pd	pointer
,	O
fc	int
,	O
fv	pointer
,	O
loc	struct
)	O
;	O
break	O
;	O
case	O
KW_BEGIN_VENDOR	int
:	O
_dict_begin_vendor	function
(	O
pd	pointer
,	O
fc	int
,	O
fv	pointer
,	O
loc	struct
)	O
;	O
break	O
;	O
case	O
KW_END_VENDOR	int
:	O
_dict_end_vendor	function
(	O
pd	pointer
,	O
fc	int
,	O
fv	pointer
,	O
loc	struct
)	O
;	O
break	O
;	O
default	O
:	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
loc	struct
,	O
"%s"	pointer
,	O
_	O
(	O
"unknown keyword"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
parse_dict	function
(	O
char	O
*	O
name	pointer
)	O
{	O
char	O
*	O
path	pointer
;	O
int	O
rc	int
;	O
struct	O
parse_data	struct
pd	pointer
;	O
pd	pointer
.	O
errcnt	long
=	O
0	int
;	O
pd	pointer
.	O
vendor	int
=	O
0	int
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
path	pointer
=	O
grad_estrdup	function
(	O
name	pointer
)	O
;	O
else	O
path	pointer
=	O
grad_mkfilename	function
(	O
grad_config_dir	pointer
,	O
name	pointer
)	O
;	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"parsing %s"	pointer
,	O
path	pointer
)	O
;	O
rc	int
=	O
grad_read_raddb_file	function
(	O
path	pointer
,	O
1	int
,	O
NULL	O
,	O
parse_dict_entry	function
,	O
&	O
pd	pointer
)	O
;	O
if	O
(	O
pd	pointer
.	O
vendor	int
)	O
{	O
grad_log_loc	function
(	O
GRAD_LOG_ERR	int
,	O
&	O
pd	pointer
.	O
begin_locus	struct
,	O
_	O
(	O
"BEGIN without END"	pointer
)	O
)	O
;	O
pd	pointer
.	O
vendor	int
=	O
0	int
;	O
pd	pointer
.	O
errcnt	long
++	O
;	O
}	O
if	O
(	O
pd	pointer
.	O
errcnt	long
)	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
dngettext	function
(	O
PACKAGE	pointer
,	O
"%s: %d error"	pointer
,	O
"%s: %d errors"	pointer
,	O
pd	pointer
.	O
errcnt	long
)	O
,	O
path	pointer
,	O
pd	pointer
.	O
errcnt	long
)	O
;	O
grad_free	function
(	O
path	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
grad_dict_init	function
(	O
)	O
{	O
parser_tab_free	function
(	O
)	O
;	O
dict_free	function
(	O
)	O
;	O
parser_tab_init	function
(	O
)	O
;	O
dict_attr_tab	pointer
=	O
grad_symtab_create	function
(	O
sizeof	O
(	O
DICT_SYMBOL	struct
)	O
,	O
NULL	O
)	O
;	O
vendorno	int
=	O
1	int
;	O
return	O
parse_dict	function
(	O
RADIUS_DICTIONARY	pointer
)	O
;	O
}	O
void	O
grad_dict_free	function
(	O
)	O
{	O
parser_tab_free	function
(	O
)	O
;	O
dict_free	function
(	O
)	O
;	O
}	O
struct	O
attr_value	struct
{	O
unsigned	O
value	pointer
;	O
grad_dict_attr_t	struct
*	O
da	pointer
;	O
}	O
;	O
static	O
int	O
attrval_cmp	function
(	O
void	O
*	O
data	pointer
,	O
grad_symbol_t	struct
*	O
s	pointer
)	O
{	O
struct	O
attr_value	struct
*	O
av	pointer
=	O
data	pointer
;	O
DICT_SYMBOL	struct
*	O
sym	pointer
=	O
(	O
DICT_SYMBOL	struct
*	O
)	O
s	pointer
;	O
if	O
(	O
sym	pointer
->	O
type	int
==	O
dict_symbol_attribute	int
&&	O
sym	pointer
->	O
v	union
.	O
attr	pointer
.	O
value	pointer
==	O
av	pointer
->	O
value	pointer
)	O
{	O
av	pointer
->	O
da	pointer
=	O
&	O
sym	pointer
->	O
v	union
.	O
attr	pointer
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
grad_dict_attr_t	struct
*	O
grad_attr_number_to_dict	function
(	O
int	O
attribute	int
)	O
{	O
struct	O
attr_value	struct
av	pointer
;	O
if	O
(	O
attribute	int
>=	O
0	int
&&	O
attribute	int
<	O
DICT_INDEX_SIZE	int
)	O
return	O
dict_attr_index	array
[	O
attribute	int
]	O
;	O
av	pointer
.	O
value	pointer
=	O
attribute	int
;	O
av	pointer
.	O
da	pointer
=	O
NULL	O
;	O
grad_symtab_iterate	function
(	O
dict_attr_tab	pointer
,	O
attrval_cmp	function
,	O
&	O
av	pointer
)	O
;	O
return	O
av	pointer
.	O
da	pointer
;	O
}	O
grad_dict_attr_t	struct
*	O
grad_attr_name_to_dict	function
(	O
const	O
char	O
*	O
attrname	pointer
)	O
{	O
return	O
dict_attr_lookup	function
(	O
attrname	pointer
)	O
;	O
}	O
struct	O
val_lookup	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
char	O
*	O
attrname	pointer
;	O
int	O
number	int
;	O
}	O
;	O
static	O
int	O
valname_cmp	function
(	O
const	O
void	O
*	O
item	pointer
,	O
const	O
void	O
*	O
data	pointer
)	O
{	O
const	O
grad_dict_value_t	struct
*	O
v	union
=	O
item	pointer
;	O
const	O
struct	O
val_lookup	struct
*	O
d	pointer
=	O
data	pointer
;	O
if	O
(	O
d	pointer
->	O
number	int
==	O
v	union
->	O
attr	pointer
->	O
value	pointer
&&	O
strcmp	function
(	O
v	union
->	O
name	pointer
,	O
d	pointer
->	O
name	pointer
)	O
==	O
0	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
grad_dict_value_t	struct
*	O
grad_value_name_to_value	function
(	O
const	O
char	O
*	O
valname	pointer
,	O
int	O
attr	pointer
)	O
{	O
struct	O
val_lookup	struct
data	pointer
;	O
data	pointer
.	O
name	pointer
=	O
valname	pointer
;	O
data	pointer
.	O
number	int
=	O
attr	pointer
;	O
return	O
grad_list_locate	function
(	O
dictionary_values	pointer
,	O
&	O
data	pointer
,	O
valname_cmp	function
)	O
;	O
}	O
static	O
int	O
valnum_cmp	function
(	O
const	O
void	O
*	O
item	pointer
,	O
const	O
void	O
*	O
data	pointer
)	O
{	O
const	O
grad_dict_value_t	struct
*	O
v	union
=	O
item	pointer
;	O
const	O
struct	O
val_lookup	struct
*	O
d	pointer
=	O
data	pointer
;	O
if	O
(	O
strcmp	function
(	O
d	pointer
->	O
attrname	pointer
,	O
v	union
->	O
attr	pointer
->	O
name	pointer
)	O
==	O
0	int
&&	O
d	pointer
->	O
number	int
==	O
v	union
->	O
value	pointer
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
grad_dict_value_t	struct
*	O
grad_value_lookup	function
(	O
grad_uint32_t	int
value	pointer
,	O
char	O
*	O
attrname	pointer
)	O
{	O
struct	O
val_lookup	struct
data	pointer
;	O
data	pointer
.	O
number	int
=	O
value	pointer
;	O
data	pointer
.	O
attrname	pointer
=	O
attrname	pointer
;	O
return	O
grad_list_locate	function
(	O
dictionary_values	pointer
,	O
&	O
data	pointer
,	O
valnum_cmp	function
)	O
;	O
}	O
static	O
int	O
code_cmp	function
(	O
const	O
void	O
*	O
item	pointer
,	O
const	O
void	O
*	O
data	pointer
)	O
{	O
const	O
grad_dict_vendor_t	struct
*	O
v	union
=	O
item	pointer
;	O
const	O
int	O
*	O
code	char
=	O
data	pointer
;	O
return	O
v	union
->	O
vendorcode	int
!=	O
*	O
code	char
;	O
}	O
int	O
grad_vendor_id_to_pec	function
(	O
int	O
code	char
)	O
{	O
grad_dict_vendor_t	struct
*	O
vp	pointer
;	O
vp	pointer
=	O
grad_list_locate	function
(	O
dictionary_vendors	pointer
,	O
&	O
code	char
,	O
code_cmp	function
)	O
;	O
return	O
vp	pointer
?	O
vp	pointer
->	O
vendorpec	int
:	O
0	int
;	O
}	O
static	O
int	O
pec_cmp	function
(	O
const	O
void	O
*	O
item	pointer
,	O
const	O
void	O
*	O
data	pointer
)	O
{	O
const	O
grad_dict_vendor_t	struct
*	O
v	union
=	O
item	pointer
;	O
const	O
int	O
*	O
pec	pointer
=	O
data	pointer
;	O
return	O
v	union
->	O
vendorpec	int
!=	O
*	O
pec	pointer
;	O
}	O
int	O
grad_vendor_pec_to_id	function
(	O
int	O
pec	pointer
)	O
{	O
grad_dict_vendor_t	struct
*	O
vp	pointer
;	O
vp	pointer
=	O
grad_list_locate	function
(	O
dictionary_vendors	pointer
,	O
&	O
pec	pointer
,	O
pec_cmp	function
)	O
;	O
return	O
vp	pointer
?	O
vp	pointer
->	O
vendorcode	int
:	O
0	int
;	O
}	O
char	O
*	O
grad_vendor_pec_to_name	function
(	O
int	O
pec	pointer
)	O
{	O
grad_dict_vendor_t	struct
*	O
vp	pointer
;	O
vp	pointer
=	O
grad_list_locate	function
(	O
dictionary_vendors	pointer
,	O
&	O
pec	pointer
,	O
pec_cmp	function
)	O
;	O
return	O
vp	pointer
?	O
vp	pointer
->	O
vendorname	pointer
:	O
NULL	O
;	O
}	O
static	O
int	O
vendor_cmp	function
(	O
const	O
void	O
*	O
item	pointer
,	O
const	O
void	O
*	O
data	pointer
)	O
{	O
const	O
grad_dict_vendor_t	struct
*	O
v	union
=	O
item	pointer
;	O
const	O
char	O
*	O
s	pointer
=	O
data	pointer
;	O
return	O
strcmp	function
(	O
v	union
->	O
vendorname	pointer
,	O
s	pointer
)	O
;	O
}	O
int	O
grad_vendor_name_to_id	function
(	O
char	O
*	O
name	pointer
)	O
{	O
grad_dict_vendor_t	struct
*	O
vp	pointer
;	O
vp	pointer
=	O
grad_list_locate	function
(	O
dictionary_vendors	pointer
,	O
name	pointer
,	O
vendor_cmp	function
)	O
;	O
return	O
vp	pointer
?	O
vp	pointer
->	O
vendorcode	int
:	O
0	int
;	O
}	O
struct	O
dict_iterator	struct
{	O
dict_iterator_fp	pointer
fp	pointer
;	O
void	O
*	O
closure	pointer
;	O
}	O
;	O
int	O
dict_iter_helper	function
(	O
void	O
*	O
data	pointer
,	O
grad_symbol_t	struct
*	O
symbol	struct
)	O
{	O
struct	O
dict_iterator	struct
*	O
p	pointer
=	O
data	pointer
;	O
DICT_SYMBOL	struct
*	O
dsym	pointer
=	O
(	O
DICT_SYMBOL	struct
*	O
)	O
symbol	struct
;	O
grad_dict_attr_t	struct
*	O
attr	pointer
;	O
return	O
p	pointer
->	O
fp	pointer
(	O
p	pointer
->	O
closure	pointer
,	O
dsym	pointer
->	O
name	pointer
,	O
dict_symbol_ptr	function
(	O
dsym	pointer
)	O
)	O
;	O
}	O
void	O
grad_dictionary_iterate	function
(	O
dict_iterator_fp	pointer
fp	pointer
,	O
void	O
*	O
closure	pointer
)	O
{	O
static	O
struct	O
dict_iterator	struct
d	pointer
;	O
d	pointer
.	O
fp	pointer
=	O
fp	pointer
;	O
d	pointer
.	O
closure	pointer
=	O
closure	pointer
;	O
grad_symtab_iterate	function
(	O
dict_attr_tab	pointer
,	O
dict_iter_helper	function
,	O
&	O
d	pointer
)	O
;	O
}	O
struct	O
dict_value_iterator	struct
{	O
dict_value_iterator_fp	pointer
fp	pointer
;	O
void	O
*	O
closure	pointer
;	O
}	O
;	O
static	O
int	O
dict_value_iter_helper	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
dict_value_iterator	struct
*	O
p	pointer
=	O
data	pointer
;	O
return	O
p	pointer
->	O
fp	pointer
(	O
p	pointer
->	O
closure	pointer
,	O
item	pointer
)	O
;	O
}	O
void	O
grad_dictionary_value_iterate	function
(	O
dict_value_iterator_fp	pointer
fp	pointer
,	O
void	O
*	O
closure	pointer
)	O
{	O
static	O
struct	O
dict_value_iterator	struct
d	pointer
;	O
d	pointer
.	O
fp	pointer
=	O
fp	pointer
;	O
d	pointer
.	O
closure	pointer
=	O
closure	pointer
;	O
grad_list_iterate	function
(	O
dictionary_values	pointer
,	O
dict_value_iter_helper	function
,	O
&	O
d	pointer
)	O
;	O
}	O
