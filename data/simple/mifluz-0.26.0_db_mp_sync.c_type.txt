static	O
const	O
char	O
revid	array
[	O
]	O
=	O
"$Id: mp_sync.c,v 1.3 2000/06/28 16:47:02 loic Exp $"	pointer
;	O
static	O
int	O
__bhcmp	function
__P	O
(	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
;	O
static	O
int	O
__memp_fsync	function
__P	O
(	O
(	O
DB_MPOOLFILE	struct
*	O
)	O
)	O
;	O
static	O
int	O
__memp_sballoc	function
__P	O
(	O
(	O
DB_ENV	struct
*	O
,	O
BH	struct
*	O
*	O
*	O
,	O
u_int32_t	int
*	O
)	O
)	O
;	O
int	O
CDB_memp_sync	function
(	O
dbenv	pointer
,	O
lsnp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_LSN	struct
*	O
lsnp	pointer
;	O
{	O
BH	struct
*	O
bhp	pointer
,	O
*	O
*	O
bharray	pointer
;	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
DB_LSN	struct
tlsn	struct
;	O
MPOOL	struct
*	O
c_mp	pointer
,	O
*	O
mp	pointer
;	O
MPOOLFILE	struct
*	O
mfp	pointer
;	O
u_int32_t	int
ar_cnt	int
,	O
i	int
,	O
ndirty	int
;	O
int	O
ret	int
,	O
retry_done	int
,	O
retry_need	int
,	O
wrote	int
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
ENV_REQUIRES_CONFIG	O
(	O
dbenv	pointer
,	O
dbenv	pointer
->	O
mp_handle	pointer
,	O
DB_INIT_MPOOL	int
)	O
;	O
dbmp	pointer
=	O
dbenv	pointer
->	O
mp_handle	pointer
;	O
mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
primary	int
;	O
if	O
(	O
!	O
LOGGING_ON	O
(	O
dbenv	pointer
)	O
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"CDB_memp_sync: requires logging"	pointer
)	O
;	O
return	O
(	O
EINVAL	int
)	O
;	O
}	O
if	O
(	O
lsnp	pointer
==	O
NULL	O
)	O
{	O
ZERO_LSN	O
(	O
tlsn	struct
)	O
;	O
lsnp	pointer
=	O
&	O
tlsn	struct
;	O
F_SET	O
(	O
mp	pointer
,	O
MP_LSN_RETRY	int
)	O
;	O
}	O
MUTEX_LOCK	O
(	O
&	O
mp	pointer
->	O
sync_mutex	struct
,	O
dbenv	pointer
->	O
lockfhp	pointer
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
!	O
IS_ZERO_LSN	O
(	O
*	O
lsnp	pointer
)	O
&&	O
!	O
F_ISSET	O
(	O
mp	pointer
,	O
MP_LSN_RETRY	int
)	O
&&	O
CDB_log_compare	function
(	O
lsnp	pointer
,	O
&	O
mp	pointer
->	O
lsn	struct
)	O
<=	O
0	int
)	O
{	O
if	O
(	O
mp	pointer
->	O
lsn_cnt	int
==	O
0	int
)	O
{	O
*	O
lsnp	pointer
=	O
mp	pointer
->	O
lsn	struct
;	O
ret	int
=	O
0	int
;	O
}	O
else	O
ret	int
=	O
DB_INCOMPLETE	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
MUTEX_UNLOCK	O
(	O
&	O
mp	pointer
->	O
sync_mutex	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
if	O
(	O
(	O
ret	int
=	O
__memp_sballoc	function
(	O
dbenv	pointer
,	O
&	O
bharray	pointer
,	O
&	O
ndirty	int
)	O
)	O
!=	O
0	int
||	O
ndirty	int
==	O
0	int
)	O
{	O
MUTEX_UNLOCK	O
(	O
&	O
mp	pointer
->	O
sync_mutex	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
retry_done	int
=	O
0	int
;	O
retry	O
:	O
retry_need	int
=	O
0	int
;	O
mp	pointer
->	O
lsn	struct
=	O
*	O
lsnp	pointer
;	O
mp	pointer
->	O
lsn_cnt	int
=	O
0	int
;	O
for	O
(	O
mfp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
mp	pointer
->	O
mpfq	struct
,	O
__mpoolfile	struct
)	O
;	O
mfp	pointer
!=	O
NULL	O
;	O
mfp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
mfp	pointer
,	O
q	struct
,	O
__mpoolfile	struct
)	O
)	O
mfp	pointer
->	O
lsn_cnt	int
=	O
0	int
;	O
F_CLR	O
(	O
mp	pointer
,	O
MP_LSN_RETRY	int
)	O
;	O
for	O
(	O
ar_cnt	int
=	O
0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
mp	pointer
->	O
nreg	int
;	O
++	O
i	int
)	O
{	O
c_mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
primary	int
;	O
for	O
(	O
bhp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
c_mp	pointer
->	O
bhq	struct
,	O
__bh	struct
)	O
;	O
bhp	pointer
!=	O
NULL	O
;	O
bhp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
bhp	pointer
,	O
q	struct
,	O
__bh	struct
)	O
)	O
{	O
if	O
(	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_DIRTY	int
)	O
||	O
bhp	pointer
->	O
ref	int
!=	O
0	int
)	O
{	O
F_SET	O
(	O
bhp	pointer
,	O
BH_WRITE	int
)	O
;	O
++	O
mp	pointer
->	O
lsn_cnt	int
;	O
mfp	pointer
=	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
bhp	pointer
->	O
mf_offset	int
)	O
;	O
++	O
mfp	pointer
->	O
lsn_cnt	int
;	O
if	O
(	O
bhp	pointer
->	O
ref	int
==	O
0	int
)	O
{	O
++	O
bhp	pointer
->	O
ref	int
;	O
bharray	pointer
[	O
ar_cnt	int
]	O
=	O
bhp	pointer
;	O
if	O
(	O
++	O
ar_cnt	int
>=	O
ndirty	int
)	O
{	O
retry_need	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_WRITE	int
)	O
)	O
F_CLR	O
(	O
bhp	pointer
,	O
BH_WRITE	int
)	O
;	O
}	O
if	O
(	O
ar_cnt	int
>=	O
ndirty	int
)	O
break	O
;	O
}	O
if	O
(	O
ar_cnt	int
==	O
0	int
)	O
{	O
ret	int
=	O
mp	pointer
->	O
lsn_cnt	int
?	O
DB_INCOMPLETE	O
:	O
0	int
;	O
goto	O
done	O
;	O
}	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
ar_cnt	int
>	O
1	int
)	O
qsort	function
(	O
bharray	pointer
,	O
ar_cnt	int
,	O
sizeof	O
(	O
BH	struct
*	O
)	O
,	O
__bhcmp	function
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ar_cnt	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
bharray	pointer
[	O
i	int
]	O
->	O
ref	int
>	O
1	int
)	O
{	O
--	O
bharray	pointer
[	O
i	int
]	O
->	O
ref	int
;	O
continue	O
;	O
}	O
mfp	pointer
=	O
R_ADDR	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
bharray	pointer
[	O
i	int
]	O
->	O
mf_offset	int
)	O
;	O
ret	int
=	O
CDB___memp_bhwrite	function
(	O
dbmp	pointer
,	O
mfp	pointer
,	O
bharray	pointer
[	O
i	int
]	O
,	O
NULL	O
,	O
&	O
wrote	int
)	O
;	O
--	O
bharray	pointer
[	O
i	int
]	O
->	O
ref	int
;	O
if	O
(	O
ret	int
==	O
0	int
&&	O
wrote	int
)	O
continue	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
CDB___db_err	function
(	O
dbenv	pointer
,	O
"%s: unable to flush page: %lu"	pointer
,	O
CDB___memp_fns	function
(	O
dbmp	pointer
,	O
mfp	pointer
)	O
,	O
(	O
u_long	long
)	O
bharray	pointer
[	O
i	int
]	O
->	O
pgno	int
)	O
;	O
ret	int
=	O
EPERM	int
;	O
}	O
ZERO_LSN	O
(	O
mp	pointer
->	O
lsn	struct
)	O
;	O
F_SET	O
(	O
mp	pointer
,	O
MP_LSN_RETRY	int
)	O
;	O
while	O
(	O
++	O
i	int
<	O
ar_cnt	int
)	O
--	O
bharray	pointer
[	O
i	int
]	O
->	O
ref	int
;	O
goto	O
done	O
;	O
}	O
ret	int
=	O
mp	pointer
->	O
lsn_cnt	int
!=	O
0	int
?	O
DB_INCOMPLETE	O
:	O
0	int
;	O
if	O
(	O
retry_need	int
)	O
{	O
if	O
(	O
retry_done	int
)	O
{	O
ret	int
=	O
DB_INCOMPLETE	O
;	O
F_SET	O
(	O
mp	pointer
,	O
MP_LSN_RETRY	int
)	O
;	O
}	O
else	O
{	O
retry_done	int
=	O
1	int
;	O
goto	O
retry	O
;	O
}	O
}	O
done	O
:	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
MUTEX_UNLOCK	O
(	O
&	O
mp	pointer
->	O
sync_mutex	struct
)	O
;	O
CDB___os_free	function
(	O
bharray	pointer
,	O
ndirty	int
*	O
sizeof	O
(	O
BH	struct
*	O
)	O
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
int	O
CDB_memp_fsync	function
(	O
dbmfp	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
{	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
int	O
is_tmp	int
;	O
dbmp	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
;	O
dbenv	pointer
=	O
dbmp	pointer
->	O
dbenv	pointer
;	O
PANIC_CHECK	O
(	O
dbenv	pointer
)	O
;	O
if	O
(	O
F_ISSET	O
(	O
dbmfp	pointer
,	O
MP_READONLY	int
)	O
)	O
return	O
(	O
0	int
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
is_tmp	int
=	O
F_ISSET	O
(	O
dbmfp	pointer
->	O
mfp	pointer
,	O
MP_TEMP	int
)	O
;	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
is_tmp	int
)	O
return	O
(	O
0	int
)	O
;	O
return	O
(	O
__memp_fsync	function
(	O
dbmfp	pointer
)	O
)	O
;	O
}	O
int	O
CDB___mp_xxx_fh	function
(	O
dbmfp	pointer
,	O
fhp	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
DB_FH	struct
*	O
*	O
fhp	pointer
;	O
{	O
*	O
fhp	pointer
=	O
&	O
dbmfp	pointer
->	O
fh	struct
;	O
return	O
(	O
F_ISSET	O
(	O
&	O
dbmfp	pointer
->	O
fh	struct
,	O
DB_FH_VALID	int
)	O
?	O
0	int
:	O
__memp_fsync	function
(	O
dbmfp	pointer
)	O
)	O
;	O
}	O
static	O
int	O
__memp_fsync	function
(	O
dbmfp	pointer
)	O
DB_MPOOLFILE	struct
*	O
dbmfp	pointer
;	O
{	O
BH	struct
*	O
bhp	pointer
,	O
*	O
*	O
bharray	pointer
;	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
MPOOL	struct
*	O
c_mp	pointer
,	O
*	O
mp	pointer
;	O
size_t	long
mf_offset	int
;	O
u_int32_t	int
ar_cnt	int
,	O
i	int
,	O
ndirty	int
;	O
int	O
incomplete	int
,	O
ret	int
,	O
retry_done	int
,	O
retry_need	int
,	O
wrote	int
;	O
dbmp	pointer
=	O
dbmfp	pointer
->	O
dbmp	pointer
;	O
dbenv	pointer
=	O
dbmp	pointer
->	O
dbenv	pointer
;	O
mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
primary	int
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
(	O
ret	int
=	O
__memp_sballoc	function
(	O
dbenv	pointer
,	O
&	O
bharray	pointer
,	O
&	O
ndirty	int
)	O
)	O
!=	O
0	int
||	O
ndirty	int
==	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
retry_done	int
=	O
0	int
;	O
retry	O
:	O
retry_need	int
=	O
0	int
;	O
mf_offset	int
=	O
R_OFFSET	O
(	O
dbmp	pointer
->	O
reginfo	pointer
,	O
dbmfp	pointer
->	O
mfp	pointer
)	O
;	O
for	O
(	O
ar_cnt	int
=	O
0	int
,	O
incomplete	int
=	O
0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
mp	pointer
->	O
nreg	int
;	O
++	O
i	int
)	O
{	O
c_mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
primary	int
;	O
for	O
(	O
bhp	pointer
=	O
SH_TAILQ_FIRST	O
(	O
&	O
c_mp	pointer
->	O
bhq	struct
,	O
__bh	struct
)	O
;	O
bhp	pointer
!=	O
NULL	O
;	O
bhp	pointer
=	O
SH_TAILQ_NEXT	O
(	O
bhp	pointer
,	O
q	struct
,	O
__bh	struct
)	O
)	O
{	O
if	O
(	O
!	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_DIRTY	int
)	O
||	O
bhp	pointer
->	O
mf_offset	int
!=	O
mf_offset	int
)	O
continue	O
;	O
if	O
(	O
bhp	pointer
->	O
ref	int
!=	O
0	int
||	O
F_ISSET	O
(	O
bhp	pointer
,	O
BH_LOCKED	int
)	O
)	O
{	O
incomplete	int
=	O
1	int
;	O
continue	O
;	O
}	O
++	O
bhp	pointer
->	O
ref	int
;	O
bharray	pointer
[	O
ar_cnt	int
]	O
=	O
bhp	pointer
;	O
if	O
(	O
++	O
ar_cnt	int
>=	O
ndirty	int
)	O
{	O
retry_need	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
ar_cnt	int
>=	O
ndirty	int
)	O
break	O
;	O
}	O
if	O
(	O
ar_cnt	int
==	O
0	int
)	O
{	O
ret	int
=	O
0	int
;	O
goto	O
done	O
;	O
}	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
ar_cnt	int
>	O
1	int
)	O
qsort	function
(	O
bharray	pointer
,	O
ar_cnt	int
,	O
sizeof	O
(	O
BH	struct
*	O
)	O
,	O
__bhcmp	function
)	O
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ar_cnt	int
;	O
)	O
{	O
if	O
(	O
bharray	pointer
[	O
i	int
]	O
->	O
ref	int
>	O
1	int
)	O
{	O
incomplete	int
=	O
1	int
;	O
--	O
bharray	pointer
[	O
i	int
++	O
]	O
->	O
ref	int
;	O
continue	O
;	O
}	O
ret	int
=	O
CDB___memp_pgwrite	function
(	O
dbmp	pointer
,	O
dbmfp	pointer
,	O
bharray	pointer
[	O
i	int
]	O
,	O
NULL	O
,	O
&	O
wrote	int
)	O
;	O
--	O
bharray	pointer
[	O
i	int
++	O
]	O
->	O
ref	int
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
{	O
if	O
(	O
!	O
wrote	int
)	O
incomplete	int
=	O
1	int
;	O
continue	O
;	O
}	O
while	O
(	O
i	int
<	O
ar_cnt	int
)	O
--	O
bharray	pointer
[	O
i	int
++	O
]	O
->	O
ref	int
;	O
break	O
;	O
}	O
if	O
(	O
retry_need	int
)	O
{	O
if	O
(	O
retry_done	int
)	O
incomplete	int
=	O
1	int
;	O
else	O
{	O
retry_done	int
=	O
1	int
;	O
goto	O
retry	O
;	O
}	O
}	O
done	O
:	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
CDB___os_free	function
(	O
bharray	pointer
,	O
ndirty	int
*	O
sizeof	O
(	O
BH	struct
*	O
)	O
)	O
;	O
if	O
(	O
ret	int
==	O
0	int
)	O
ret	int
=	O
incomplete	int
?	O
DB_INCOMPLETE	O
:	O
CDB___os_fsync	function
(	O
dbenv	pointer
,	O
&	O
dbmfp	pointer
->	O
fh	struct
)	O
;	O
return	O
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
__memp_sballoc	function
(	O
dbenv	pointer
,	O
bharrayp	pointer
,	O
ndirtyp	pointer
)	O
DB_ENV	struct
*	O
dbenv	pointer
;	O
BH	struct
*	O
*	O
*	O
bharrayp	pointer
;	O
u_int32_t	int
*	O
ndirtyp	pointer
;	O
{	O
DB_MPOOL	struct
*	O
dbmp	pointer
;	O
MPOOL	struct
*	O
c_mp	pointer
,	O
*	O
mp	pointer
;	O
u_int32_t	int
i	int
,	O
nclean	int
,	O
ndirty	int
,	O
maxpin	int
;	O
int	O
ret	int
;	O
dbmp	pointer
=	O
dbenv	pointer
->	O
mp_handle	pointer
;	O
mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
0	int
]	O
.	O
primary	int
;	O
for	O
(	O
nclean	int
=	O
ndirty	int
=	O
0	int
,	O
i	int
=	O
0	int
;	O
i	int
<	O
mp	pointer
->	O
nreg	int
;	O
++	O
i	int
)	O
{	O
c_mp	pointer
=	O
dbmp	pointer
->	O
reginfo	pointer
[	O
i	int
]	O
.	O
primary	int
;	O
ndirty	int
+=	O
c_mp	pointer
->	O
stat	pointer
.	O
st_page_dirty	int
;	O
nclean	int
+=	O
c_mp	pointer
->	O
stat	pointer
.	O
st_page_clean	int
;	O
}	O
R_UNLOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
if	O
(	O
ndirty	int
==	O
0	int
)	O
{	O
*	O
ndirtyp	pointer
=	O
0	int
;	O
return	O
(	O
0	int
)	O
;	O
}	O
maxpin	int
=	O
(	O
(	O
ndirty	int
+	O
nclean	int
)	O
*	O
8	int
)	O
/	O
10	int
;	O
if	O
(	O
maxpin	int
<	O
10	int
)	O
maxpin	int
=	O
10	int
;	O
ndirty	int
+=	O
ndirty	int
/	O
2	int
+	O
10	int
;	O
if	O
(	O
ndirty	int
>	O
maxpin	int
)	O
ndirty	int
=	O
maxpin	int
;	O
if	O
(	O
(	O
ret	int
=	O
CDB___os_malloc	function
(	O
dbenv	pointer
,	O
ndirty	int
*	O
sizeof	O
(	O
BH	struct
*	O
)	O
,	O
NULL	O
,	O
bharrayp	pointer
)	O
)	O
!=	O
0	int
)	O
return	O
(	O
ret	int
)	O
;	O
*	O
ndirtyp	pointer
=	O
ndirty	int
;	O
R_LOCK	O
(	O
dbenv	pointer
,	O
dbmp	pointer
->	O
reginfo	pointer
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
static	O
int	O
__bhcmp	function
(	O
p1	pointer
,	O
p2	pointer
)	O
const	O
void	O
*	O
p1	pointer
,	O
*	O
p2	pointer
;	O
{	O
BH	struct
*	O
bhp1	pointer
,	O
*	O
bhp2	pointer
;	O
bhp1	pointer
=	O
*	O
(	O
BH	struct
*	O
const	O
*	O
)	O
p1	pointer
;	O
bhp2	pointer
=	O
*	O
(	O
BH	struct
*	O
const	O
*	O
)	O
p2	pointer
;	O
if	O
(	O
bhp1	pointer
->	O
mf_offset	int
<	O
bhp2	pointer
->	O
mf_offset	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
bhp1	pointer
->	O
mf_offset	int
>	O
bhp2	pointer
->	O
mf_offset	int
)	O
return	O
(	O
1	int
)	O
;	O
if	O
(	O
bhp1	pointer
->	O
pgno	int
<	O
bhp2	pointer
->	O
pgno	int
)	O
return	O
(	O
-	O
1	int
)	O
;	O
if	O
(	O
bhp1	pointer
->	O
pgno	int
>	O
bhp2	pointer
->	O
pgno	int
)	O
return	O
(	O
1	int
)	O
;	O
return	O
(	O
0	int
)	O
;	O
}	O
