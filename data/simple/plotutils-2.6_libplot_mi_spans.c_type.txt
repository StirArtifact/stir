static	O
SpanGroup	struct
*	O
miNewSpanGroup	function
(	O
miPixel	struct
pixel	struct
)	O
;	O
static	O
int	O
miUniquifySpansX	function
(	O
const	O
Spans	struct
*	O
spans	pointer
,	O
miPoint	struct
*	O
newPoints	pointer
,	O
unsigned	O
int	O
*	O
newWidths	pointer
)	O
;	O
static	O
void	O
miAddSpansToSpanGroup	function
(	O
const	O
Spans	struct
*	O
spans	pointer
,	O
SpanGroup	struct
*	O
spanGroup	pointer
)	O
;	O
static	O
void	O
miDeleteSpanGroup	function
(	O
SpanGroup	struct
*	O
spanGroup	pointer
)	O
;	O
static	O
void	O
miQuickSortSpansX	function
(	O
miPoint	struct
*	O
points	pointer
,	O
unsigned	O
int	O
*	O
widths	pointer
,	O
int	O
numSpans	int
)	O
;	O
static	O
void	O
miSubtractSpans	function
(	O
SpanGroup	struct
*	O
spanGroup	pointer
,	O
const	O
Spans	struct
*	O
sub	pointer
)	O
;	O
static	O
void	O
miUniquifySpanGroup	function
(	O
SpanGroup	struct
*	O
spanGroup	pointer
)	O
;	O
miPaintedSet	struct
*	O
miNewPaintedSet	O
(	O
void	O
)	O
{	O
miPaintedSet	struct
*	O
paintedSet	pointer
;	O
paintedSet	pointer
=	O
(	O
miPaintedSet	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
miPaintedSet	struct
)	O
)	O
;	O
paintedSet	pointer
->	O
groups	pointer
=	O
(	O
SpanGroup	struct
*	O
*	O
)	O
NULL	O
;	O
paintedSet	pointer
->	O
size	double
=	O
0	int
;	O
paintedSet	pointer
->	O
ngroups	int
=	O
0	int
;	O
return	O
paintedSet	pointer
;	O
}	O
void	O
miAddSpansToPaintedSet	O
(	O
const	O
Spans	struct
*	O
spans	pointer
,	O
miPaintedSet	struct
*	O
paintedSet	pointer
,	O
miPixel	struct
pixel	struct
)	O
{	O
bool	enum
found	enum
=	O
false	int
;	O
int	O
i	int
;	O
SpanGroup	struct
*	O
spanGroup	pointer
;	O
if	O
(	O
spans	pointer
->	O
count	int
==	O
0	int
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
paintedSet	pointer
->	O
ngroups	int
;	O
i	int
++	O
)	O
{	O
miPixel	struct
stored_pixel	struct
;	O
stored_pixel	struct
=	O
paintedSet	pointer
->	O
groups	pointer
[	O
i	int
]	O
->	O
pixel	struct
;	O
if	O
(	O
MI_SAME_PIXEL	O
(	O
pixel	struct
,	O
stored_pixel	struct
)	O
)	O
{	O
found	enum
=	O
true	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
found	enum
)	O
{	O
if	O
(	O
paintedSet	pointer
->	O
ngroups	int
==	O
paintedSet	pointer
->	O
size	double
)	O
{	O
int	O
old_size	int
=	O
paintedSet	pointer
->	O
size	double
;	O
int	O
new_size	int
=	O
2	int
*	O
(	O
old_size	int
+	O
8	int
)	O
;	O
if	O
(	O
old_size	int
==	O
0	int
)	O
paintedSet	pointer
->	O
groups	pointer
=	O
(	O
SpanGroup	struct
*	O
*	O
)	O
mi_xmalloc	O
(	O
new_size	int
*	O
sizeof	O
(	O
SpanGroup	struct
*	O
)	O
)	O
;	O
else	O
paintedSet	pointer
->	O
groups	pointer
=	O
(	O
SpanGroup	struct
*	O
*	O
)	O
mi_xrealloc	O
(	O
paintedSet	pointer
->	O
groups	pointer
,	O
new_size	int
*	O
sizeof	O
(	O
SpanGroup	struct
*	O
)	O
)	O
;	O
paintedSet	pointer
->	O
size	double
=	O
new_size	int
;	O
}	O
i	int
=	O
paintedSet	pointer
->	O
ngroups	int
;	O
paintedSet	pointer
->	O
groups	pointer
[	O
i	int
]	O
=	O
miNewSpanGroup	function
(	O
pixel	struct
)	O
;	O
paintedSet	pointer
->	O
ngroups	int
++	O
;	O
}	O
spanGroup	pointer
=	O
paintedSet	pointer
->	O
groups	pointer
[	O
i	int
]	O
;	O
miAddSpansToSpanGroup	function
(	O
spans	pointer
,	O
spanGroup	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
paintedSet	pointer
->	O
ngroups	int
;	O
i	int
++	O
)	O
{	O
SpanGroup	struct
*	O
otherGroup	pointer
;	O
otherGroup	pointer
=	O
paintedSet	pointer
->	O
groups	pointer
[	O
i	int
]	O
;	O
if	O
(	O
otherGroup	pointer
==	O
spanGroup	pointer
)	O
continue	O
;	O
miSubtractSpans	function
(	O
otherGroup	pointer
,	O
spans	pointer
)	O
;	O
}	O
}	O
void	O
miClearPaintedSet	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
paintedSet	pointer
==	O
(	O
miPaintedSet	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
paintedSet	pointer
->	O
ngroups	int
;	O
i	int
++	O
)	O
miDeleteSpanGroup	function
(	O
paintedSet	pointer
->	O
groups	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
paintedSet	pointer
->	O
size	double
>	O
0	int
)	O
free	function
(	O
paintedSet	pointer
->	O
groups	pointer
)	O
;	O
paintedSet	pointer
->	O
size	double
=	O
0	int
;	O
paintedSet	pointer
->	O
ngroups	int
=	O
0	int
;	O
}	O
void	O
miDeletePaintedSet	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
paintedSet	pointer
==	O
(	O
miPaintedSet	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
paintedSet	pointer
->	O
ngroups	int
;	O
i	int
++	O
)	O
miDeleteSpanGroup	function
(	O
paintedSet	pointer
->	O
groups	pointer
[	O
i	int
]	O
)	O
;	O
if	O
(	O
paintedSet	pointer
->	O
size	double
>	O
0	int
)	O
free	function
(	O
paintedSet	pointer
->	O
groups	pointer
)	O
;	O
free	function
(	O
paintedSet	pointer
)	O
;	O
}	O
void	O
miUniquifyPaintedSet	O
(	O
miPaintedSet	struct
*	O
paintedSet	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
paintedSet	pointer
==	O
(	O
miPaintedSet	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
paintedSet	pointer
->	O
ngroups	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
paintedSet	pointer
->	O
groups	pointer
[	O
i	int
]	O
->	O
count	int
>	O
0	int
)	O
{	O
miUniquifySpanGroup	function
(	O
paintedSet	pointer
->	O
groups	pointer
[	O
i	int
]	O
)	O
;	O
}	O
}	O
}	O
static	O
SpanGroup	struct
*	O
miNewSpanGroup	function
(	O
miPixel	struct
pixel	struct
)	O
{	O
SpanGroup	struct
*	O
spanGroup	pointer
;	O
spanGroup	pointer
=	O
(	O
SpanGroup	struct
*	O
)	O
mi_xmalloc	O
(	O
sizeof	O
(	O
SpanGroup	struct
)	O
)	O
;	O
spanGroup	pointer
->	O
pixel	struct
=	O
pixel	struct
;	O
spanGroup	pointer
->	O
size	double
=	O
0	int
;	O
spanGroup	pointer
->	O
count	int
=	O
0	int
;	O
spanGroup	pointer
->	O
group	pointer
=	O
(	O
Spans	struct
*	O
)	O
NULL	O
;	O
spanGroup	pointer
->	O
ymin	double
=	O
INT_MAX	O
;	O
spanGroup	pointer
->	O
ymax	double
=	O
INT_MIN	O
;	O
return	O
spanGroup	pointer
;	O
}	O
static	O
void	O
miAddSpansToSpanGroup	function
(	O
const	O
Spans	struct
*	O
spans	pointer
,	O
SpanGroup	struct
*	O
spanGroup	pointer
)	O
{	O
int	O
ymin	double
,	O
ymax	double
;	O
if	O
(	O
spans	pointer
->	O
count	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
spanGroup	pointer
->	O
size	double
==	O
spanGroup	pointer
->	O
count	int
)	O
{	O
spanGroup	pointer
->	O
size	double
=	O
(	O
spanGroup	pointer
->	O
size	double
+	O
8	int
)	O
*	O
2	int
;	O
spanGroup	pointer
->	O
group	pointer
=	O
(	O
Spans	struct
*	O
)	O
mi_xrealloc	O
(	O
spanGroup	pointer
->	O
group	pointer
,	O
sizeof	O
(	O
Spans	struct
)	O
*	O
spanGroup	pointer
->	O
size	double
)	O
;	O
}	O
spanGroup	pointer
->	O
group	pointer
[	O
spanGroup	pointer
->	O
count	int
]	O
=	O
*	O
spans	pointer
;	O
(	O
spanGroup	pointer
->	O
count	int
)	O
++	O
;	O
ymin	double
=	O
YMIN	O
(	O
spans	pointer
)	O
;	O
if	O
(	O
ymin	double
<	O
spanGroup	pointer
->	O
ymin	double
)	O
spanGroup	pointer
->	O
ymin	double
=	O
ymin	double
;	O
ymax	double
=	O
YMAX	O
(	O
spans	pointer
)	O
;	O
if	O
(	O
ymax	double
>	O
spanGroup	pointer
->	O
ymax	double
)	O
spanGroup	pointer
->	O
ymax	double
=	O
ymax	double
;	O
}	O
static	O
void	O
miDeleteSpanGroup	function
(	O
SpanGroup	struct
*	O
spanGroup	pointer
)	O
{	O
int	O
i	int
;	O
if	O
(	O
spanGroup	pointer
==	O
(	O
SpanGroup	struct
*	O
)	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
spanGroup	pointer
->	O
count	int
;	O
i	int
++	O
)	O
{	O
free	function
(	O
spanGroup	pointer
->	O
group	pointer
[	O
i	int
]	O
.	O
points	pointer
)	O
;	O
free	function
(	O
spanGroup	pointer
->	O
group	pointer
[	O
i	int
]	O
.	O
widths	pointer
)	O
;	O
}	O
if	O
(	O
spanGroup	pointer
->	O
group	pointer
)	O
free	function
(	O
spanGroup	pointer
->	O
group	pointer
)	O
;	O
free	function
(	O
spanGroup	pointer
)	O
;	O
}	O
static	O
void	O
miSubtractSpans	function
(	O
SpanGroup	struct
*	O
spanGroup	pointer
,	O
const	O
Spans	struct
*	O
sub	pointer
)	O
{	O
int	O
i	int
,	O
subCount	int
,	O
spansCount	int
;	O
int	O
ymin	double
,	O
ymax	double
,	O
xmin	double
,	O
xmax	double
;	O
Spans	struct
*	O
spans	pointer
;	O
miPoint	struct
*	O
subPt	pointer
,	O
*	O
spansPt	pointer
;	O
unsigned	O
int	O
*	O
subWid	pointer
,	O
*	O
spansWid	pointer
;	O
int	O
extra	pointer
;	O
bool	enum
gross_change	enum
=	O
false	int
;	O
if	O
(	O
sub	pointer
->	O
count	int
==	O
0	int
)	O
return	O
;	O
ymin	double
=	O
YMIN	O
(	O
sub	pointer
)	O
;	O
ymax	double
=	O
YMAX	O
(	O
sub	pointer
)	O
;	O
spans	pointer
=	O
spanGroup	pointer
->	O
group	pointer
;	O
for	O
(	O
i	int
=	O
spanGroup	pointer
->	O
count	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
,	O
spans	pointer
++	O
)	O
{	O
if	O
(	O
spans	pointer
->	O
count	int
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
YMIN	O
(	O
spans	pointer
)	O
<=	O
ymax	double
&&	O
ymin	double
<=	O
YMAX	O
(	O
spans	pointer
)	O
)	O
{	O
subCount	int
=	O
sub	pointer
->	O
count	int
;	O
subPt	pointer
=	O
sub	pointer
->	O
points	pointer
;	O
subWid	pointer
=	O
sub	pointer
->	O
widths	pointer
;	O
spansCount	int
=	O
spans	pointer
->	O
count	int
;	O
spansPt	pointer
=	O
spans	pointer
->	O
points	pointer
;	O
spansWid	pointer
=	O
spans	pointer
->	O
widths	pointer
;	O
extra	pointer
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
while	O
(	O
spansCount	int
&&	O
spansPt	pointer
->	O
y	double
<	O
subPt	pointer
->	O
y	double
)	O
{	O
spansPt	pointer
++	O
;	O
spansWid	pointer
++	O
;	O
spansCount	int
--	O
;	O
}	O
if	O
(	O
!	O
spansCount	int
)	O
break	O
;	O
while	O
(	O
subCount	int
&&	O
subPt	pointer
->	O
y	double
<	O
spansPt	pointer
->	O
y	double
)	O
{	O
subPt	pointer
++	O
;	O
subWid	pointer
++	O
;	O
subCount	int
--	O
;	O
}	O
if	O
(	O
!	O
subCount	int
)	O
break	O
;	O
if	O
(	O
subPt	pointer
->	O
y	double
==	O
spansPt	pointer
->	O
y	double
)	O
{	O
xmin	double
=	O
subPt	pointer
->	O
x	double
;	O
xmax	double
=	O
xmin	double
+	O
(	O
int	O
)	O
(	O
*	O
subWid	pointer
)	O
;	O
if	O
(	O
xmin	double
>=	O
spansPt	pointer
->	O
x	double
+	O
(	O
int	O
)	O
(	O
*	O
spansWid	pointer
)	O
||	O
spansPt	pointer
->	O
x	double
>=	O
xmax	double
)	O
{	O
;	O
}	O
else	O
if	O
(	O
xmin	double
<=	O
spansPt	pointer
->	O
x	double
)	O
{	O
if	O
(	O
xmax	double
>=	O
spansPt	pointer
->	O
x	double
+	O
(	O
int	O
)	O
(	O
*	O
spansWid	pointer
)	O
)	O
{	O
memmove	function
(	O
spansPt	pointer
,	O
spansPt	pointer
+	O
1	int
,	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
(	O
spansCount	int
-	O
1	int
)	O
)	O
;	O
memmove	function
(	O
spansWid	pointer
,	O
spansWid	pointer
+	O
1	int
,	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
(	O
spansCount	int
-	O
1	int
)	O
)	O
;	O
spansPt	pointer
--	O
;	O
spansWid	pointer
--	O
;	O
spans	pointer
->	O
count	int
--	O
;	O
extra	pointer
++	O
;	O
gross_change	enum
=	O
true	int
;	O
}	O
else	O
{	O
*	O
spansWid	pointer
=	O
*	O
spansWid	pointer
-	O
(	O
unsigned	O
int	O
)	O
(	O
xmax	double
-	O
spansPt	pointer
->	O
x	double
)	O
;	O
spansPt	pointer
->	O
x	double
=	O
xmax	double
;	O
}	O
}	O
else	O
{	O
if	O
(	O
xmax	double
>=	O
spansPt	pointer
->	O
x	double
+	O
(	O
int	O
)	O
*	O
spansWid	pointer
)	O
*	O
spansWid	pointer
=	O
(	O
unsigned	O
int	O
)	O
(	O
xmin	double
-	O
spansPt	pointer
->	O
x	double
)	O
;	O
else	O
{	O
if	O
(	O
extra	pointer
==	O
0	int
)	O
{	O
miPoint	struct
*	O
newPt	pointer
;	O
unsigned	O
int	O
*	O
newwid	pointer
;	O
newPt	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xrealloc	O
(	O
spans	pointer
->	O
points	pointer
,	O
(	O
spans	pointer
->	O
count	int
+	O
EXTRA	int
)	O
*	O
sizeof	O
(	O
miPoint	struct
)	O
)	O
;	O
spansPt	pointer
=	O
newPt	pointer
+	O
(	O
spansPt	pointer
-	O
spans	pointer
->	O
points	pointer
)	O
;	O
spans	pointer
->	O
points	pointer
=	O
newPt	pointer
;	O
newwid	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xrealloc	O
(	O
spans	pointer
->	O
widths	pointer
,	O
(	O
spans	pointer
->	O
count	int
+	O
EXTRA	int
)	O
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
spansWid	pointer
=	O
newwid	pointer
+	O
(	O
spansWid	pointer
-	O
spans	pointer
->	O
widths	pointer
)	O
;	O
spans	pointer
->	O
widths	pointer
=	O
newwid	pointer
;	O
extra	pointer
=	O
EXTRA	int
;	O
}	O
memmove	function
(	O
spansPt	pointer
+	O
1	int
,	O
spansPt	pointer
,	O
sizeof	O
(	O
miPoint	struct
)	O
*	O
spansCount	int
)	O
;	O
memmove	function
(	O
spansWid	pointer
+	O
1	int
,	O
spansWid	pointer
,	O
sizeof	O
(	O
unsigned	O
int	O
)	O
*	O
spansCount	int
)	O
;	O
spans	pointer
->	O
count	int
++	O
;	O
extra	pointer
--	O
;	O
*	O
spansWid	pointer
=	O
(	O
unsigned	O
int	O
)	O
(	O
xmin	double
-	O
spansPt	pointer
->	O
x	double
)	O
;	O
spansWid	pointer
++	O
;	O
spansPt	pointer
++	O
;	O
*	O
spansWid	pointer
=	O
*	O
spansWid	pointer
-	O
(	O
unsigned	O
int	O
)	O
(	O
xmax	double
-	O
spansPt	pointer
->	O
x	double
)	O
;	O
spansPt	pointer
->	O
x	double
=	O
xmax	double
;	O
}	O
}	O
}	O
spansPt	pointer
++	O
;	O
spansWid	pointer
++	O
;	O
spansCount	int
--	O
;	O
}	O
}	O
}	O
if	O
(	O
gross_change	enum
)	O
{	O
ymax	double
=	O
INT_MIN	O
;	O
ymin	double
=	O
INT_MAX	O
;	O
spans	pointer
=	O
spanGroup	pointer
->	O
group	pointer
;	O
for	O
(	O
i	int
=	O
spanGroup	pointer
->	O
count	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
,	O
spans	pointer
++	O
)	O
{	O
int	O
ymin_spans	int
,	O
ymax_spans	int
;	O
if	O
(	O
spans	pointer
->	O
count	int
==	O
0	int
)	O
continue	O
;	O
ymin_spans	int
=	O
YMIN	O
(	O
spans	pointer
)	O
;	O
ymax_spans	int
=	O
YMAX	O
(	O
spans	pointer
)	O
;	O
if	O
(	O
ymin_spans	int
<	O
ymin	double
)	O
ymin	double
=	O
ymin_spans	int
;	O
if	O
(	O
ymax_spans	int
>	O
ymax	double
)	O
ymax	double
=	O
ymax_spans	int
;	O
}	O
spanGroup	pointer
->	O
ymin	double
=	O
ymin	double
;	O
spanGroup	pointer
->	O
ymax	double
=	O
ymax	double
;	O
}	O
}	O
static	O
void	O
miUniquifySpanGroup	function
(	O
SpanGroup	struct
*	O
spanGroup	pointer
)	O
{	O
int	O
i	int
;	O
Spans	struct
*	O
spans	pointer
;	O
Spans	struct
*	O
yspans	pointer
;	O
int	O
*	O
ysizes	pointer
;	O
int	O
ymin	double
,	O
ylength	int
;	O
miPoint	struct
*	O
points	pointer
;	O
unsigned	O
int	O
*	O
widths	pointer
;	O
int	O
count	int
;	O
if	O
(	O
spanGroup	pointer
->	O
count	int
==	O
0	int
)	O
return	O
;	O
if	O
(	O
spanGroup	pointer
->	O
ymin	double
>	O
spanGroup	pointer
->	O
ymax	double
)	O
{	O
spanGroup	pointer
->	O
count	int
=	O
0	int
;	O
return	O
;	O
}	O
ymin	double
=	O
spanGroup	pointer
->	O
ymin	double
;	O
ylength	int
=	O
spanGroup	pointer
->	O
ymax	double
-	O
ymin	double
+	O
1	int
;	O
yspans	pointer
=	O
(	O
Spans	struct
*	O
)	O
mi_xmalloc	O
(	O
ylength	int
*	O
sizeof	O
(	O
Spans	struct
)	O
)	O
;	O
ysizes	pointer
=	O
(	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
ylength	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ylength	int
;	O
i	int
++	O
)	O
{	O
ysizes	pointer
[	O
i	int
]	O
=	O
0	int
;	O
yspans	pointer
[	O
i	int
]	O
.	O
count	int
=	O
0	int
;	O
yspans	pointer
[	O
i	int
]	O
.	O
points	pointer
=	O
(	O
miPoint	struct
*	O
)	O
NULL	O
;	O
yspans	pointer
[	O
i	int
]	O
.	O
widths	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
NULL	O
;	O
}	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
spans	pointer
=	O
spanGroup	pointer
->	O
group	pointer
;	O
i	int
<	O
spanGroup	pointer
->	O
count	int
;	O
i	int
++	O
,	O
spans	pointer
++	O
)	O
{	O
int	O
j	int
,	O
index	function
;	O
for	O
(	O
j	int
=	O
0	int
,	O
points	pointer
=	O
spans	pointer
->	O
points	pointer
,	O
widths	pointer
=	O
spans	pointer
->	O
widths	pointer
;	O
j	int
<	O
spans	pointer
->	O
count	int
;	O
j	int
++	O
,	O
points	pointer
++	O
,	O
widths	pointer
++	O
)	O
{	O
index	function
=	O
points	pointer
->	O
y	double
-	O
ymin	double
;	O
if	O
(	O
index	function
>=	O
0	int
&&	O
index	function
<	O
ylength	int
)	O
{	O
Spans	struct
*	O
newspans	pointer
=	O
&	O
(	O
yspans	pointer
[	O
index	function
]	O
)	O
;	O
if	O
(	O
newspans	pointer
->	O
count	int
==	O
ysizes	pointer
[	O
index	function
]	O
)	O
{	O
ysizes	pointer
[	O
index	function
]	O
=	O
(	O
ysizes	pointer
[	O
index	function
]	O
+	O
8	int
)	O
*	O
2	int
;	O
newspans	pointer
->	O
points	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xrealloc	O
(	O
newspans	pointer
->	O
points	pointer
,	O
ysizes	pointer
[	O
index	function
]	O
*	O
sizeof	O
(	O
miPoint	struct
)	O
)	O
;	O
newspans	pointer
->	O
widths	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xrealloc	O
(	O
newspans	pointer
->	O
widths	pointer
,	O
ysizes	pointer
[	O
index	function
]	O
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
}	O
newspans	pointer
->	O
points	pointer
[	O
newspans	pointer
->	O
count	int
]	O
=	O
*	O
points	pointer
;	O
newspans	pointer
->	O
widths	pointer
[	O
newspans	pointer
->	O
count	int
]	O
=	O
*	O
widths	pointer
;	O
(	O
newspans	pointer
->	O
count	int
)	O
++	O
;	O
}	O
}	O
count	int
+=	O
spans	pointer
->	O
count	int
;	O
}	O
free	function
(	O
ysizes	pointer
)	O
;	O
points	pointer
=	O
(	O
miPoint	struct
*	O
)	O
mi_xmalloc	O
(	O
count	int
*	O
sizeof	O
(	O
miPoint	struct
)	O
)	O
;	O
widths	pointer
=	O
(	O
unsigned	O
int	O
*	O
)	O
mi_xmalloc	O
(	O
count	int
*	O
sizeof	O
(	O
unsigned	O
int	O
)	O
)	O
;	O
count	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
ylength	int
;	O
i	int
++	O
)	O
{	O
int	O
ycount	int
=	O
yspans	pointer
[	O
i	int
]	O
.	O
count	int
;	O
if	O
(	O
ycount	int
>	O
0	int
)	O
{	O
if	O
(	O
ycount	int
>	O
1	int
)	O
{	O
miQuickSortSpansX	function
(	O
yspans	pointer
[	O
i	int
]	O
.	O
points	pointer
,	O
yspans	pointer
[	O
i	int
]	O
.	O
widths	pointer
,	O
ycount	int
)	O
;	O
count	int
+=	O
miUniquifySpansX	function
(	O
&	O
(	O
yspans	pointer
[	O
i	int
]	O
)	O
,	O
&	O
(	O
points	pointer
[	O
count	int
]	O
)	O
,	O
&	O
(	O
widths	pointer
[	O
count	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
points	pointer
[	O
count	int
]	O
=	O
yspans	pointer
[	O
i	int
]	O
.	O
points	pointer
[	O
0	int
]	O
;	O
widths	pointer
[	O
count	int
]	O
=	O
yspans	pointer
[	O
i	int
]	O
.	O
widths	pointer
[	O
0	int
]	O
;	O
count	int
++	O
;	O
}	O
free	function
(	O
yspans	pointer
[	O
i	int
]	O
.	O
points	pointer
)	O
;	O
free	function
(	O
yspans	pointer
[	O
i	int
]	O
.	O
widths	pointer
)	O
;	O
}	O
}	O
free	function
(	O
yspans	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
spanGroup	pointer
->	O
count	int
;	O
i	int
++	O
)	O
{	O
free	function
(	O
spanGroup	pointer
->	O
group	pointer
[	O
i	int
]	O
.	O
points	pointer
)	O
;	O
free	function
(	O
spanGroup	pointer
->	O
group	pointer
[	O
i	int
]	O
.	O
widths	pointer
)	O
;	O
}	O
spanGroup	pointer
->	O
count	int
=	O
1	int
;	O
spanGroup	pointer
->	O
group	pointer
[	O
0	int
]	O
.	O
points	pointer
=	O
points	pointer
;	O
spanGroup	pointer
->	O
group	pointer
[	O
0	int
]	O
.	O
widths	pointer
=	O
widths	pointer
;	O
spanGroup	pointer
->	O
group	pointer
[	O
0	int
]	O
.	O
count	int
=	O
count	int
;	O
}	O
static	O
void	O
miQuickSortSpansX	function
(	O
miPoint	struct
*	O
points	pointer
,	O
unsigned	O
int	O
*	O
widths	pointer
,	O
int	O
numSpans	int
)	O
{	O
int	O
x	double
;	O
int	O
i	int
,	O
j	int
,	O
m	array
;	O
miPoint	struct
*	O
r	int
;	O
do	O
{	O
if	O
(	O
numSpans	int
<	O
9	int
)	O
{	O
int	O
xprev	int
;	O
xprev	int
=	O
points	pointer
[	O
0	int
]	O
.	O
x	double
;	O
i	int
=	O
1	int
;	O
do	O
{	O
x	double
=	O
points	pointer
[	O
i	int
]	O
.	O
x	double
;	O
if	O
(	O
xprev	int
>	O
x	double
)	O
{	O
miPoint	struct
tpt	struct
;	O
unsigned	O
int	O
tw	int
;	O
int	O
k	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
x	double
>=	O
points	pointer
[	O
j	int
]	O
.	O
x	double
;	O
j	int
++	O
)	O
{	O
}	O
tpt	struct
=	O
points	pointer
[	O
i	int
]	O
;	O
tw	int
=	O
widths	pointer
[	O
i	int
]	O
;	O
for	O
(	O
k	int
=	O
i	int
;	O
k	int
!=	O
j	int
;	O
k	int
--	O
)	O
{	O
points	pointer
[	O
k	int
]	O
=	O
points	pointer
[	O
k	int
-	O
1	int
]	O
;	O
widths	pointer
[	O
k	int
]	O
=	O
widths	pointer
[	O
k	int
-	O
1	int
]	O
;	O
}	O
points	pointer
[	O
j	int
]	O
=	O
tpt	struct
;	O
widths	pointer
[	O
j	int
]	O
=	O
tw	int
;	O
x	double
=	O
points	pointer
[	O
i	int
]	O
.	O
x	double
;	O
}	O
xprev	int
=	O
x	double
;	O
i	int
++	O
;	O
}	O
while	O
(	O
i	int
!=	O
numSpans	int
)	O
;	O
return	O
;	O
}	O
m	array
=	O
numSpans	int
/	O
2	int
;	O
if	O
(	O
points	pointer
[	O
m	array
]	O
.	O
x	double
>	O
points	pointer
[	O
0	int
]	O
.	O
x	double
)	O
ExchangeSpans	O
(	O
m	array
,	O
0	int
)	O
;	O
if	O
(	O
points	pointer
[	O
m	array
]	O
.	O
x	double
>	O
points	pointer
[	O
numSpans	int
-	O
1	int
]	O
.	O
x	double
)	O
ExchangeSpans	O
(	O
m	array
,	O
numSpans	int
-	O
1	int
)	O
;	O
if	O
(	O
points	pointer
[	O
m	array
]	O
.	O
x	double
>	O
points	pointer
[	O
0	int
]	O
.	O
x	double
)	O
ExchangeSpans	O
(	O
m	array
,	O
0	int
)	O
;	O
x	double
=	O
points	pointer
[	O
0	int
]	O
.	O
x	double
;	O
i	int
=	O
0	int
;	O
j	int
=	O
numSpans	int
;	O
do	O
{	O
r	int
=	O
&	O
(	O
points	pointer
[	O
i	int
]	O
)	O
;	O
do	O
{	O
r	int
++	O
;	O
i	int
++	O
;	O
}	O
while	O
(	O
i	int
!=	O
numSpans	int
&&	O
r	int
->	O
x	double
<	O
x	double
)	O
;	O
r	int
=	O
&	O
(	O
points	pointer
[	O
j	int
]	O
)	O
;	O
do	O
{	O
r	int
--	O
;	O
j	int
--	O
;	O
}	O
while	O
(	O
x	double
<	O
r	int
->	O
x	double
)	O
;	O
if	O
(	O
i	int
<	O
j	int
)	O
ExchangeSpans	O
(	O
i	int
,	O
j	int
)	O
;	O
}	O
while	O
(	O
i	int
<	O
j	int
)	O
;	O
ExchangeSpans	O
(	O
0	int
,	O
j	int
)	O
;	O
if	O
(	O
numSpans	int
-	O
j	int
-	O
1	int
>	O
1	int
)	O
miQuickSortSpansX	function
(	O
&	O
points	pointer
[	O
j	int
+	O
1	int
]	O
,	O
&	O
widths	pointer
[	O
j	int
+	O
1	int
]	O
,	O
numSpans	int
-	O
j	int
-	O
1	int
)	O
;	O
numSpans	int
=	O
j	int
;	O
}	O
while	O
(	O
numSpans	int
>	O
1	int
)	O
;	O
}	O
void	O
miQuickSortSpansY	O
(	O
miPoint	struct
*	O
points	pointer
,	O
unsigned	O
int	O
*	O
widths	pointer
,	O
int	O
numSpans	int
)	O
{	O
int	O
y	double
;	O
int	O
i	int
,	O
j	int
,	O
m	array
;	O
miPoint	struct
*	O
r	int
;	O
if	O
(	O
numSpans	int
<=	O
1	int
)	O
return	O
;	O
do	O
{	O
if	O
(	O
numSpans	int
<	O
9	int
)	O
{	O
int	O
yprev	int
;	O
yprev	int
=	O
points	pointer
[	O
0	int
]	O
.	O
y	double
;	O
i	int
=	O
1	int
;	O
do	O
{	O
y	double
=	O
points	pointer
[	O
i	int
]	O
.	O
y	double
;	O
if	O
(	O
yprev	int
>	O
y	double
)	O
{	O
miPoint	struct
tpt	struct
;	O
unsigned	O
int	O
tw	int
;	O
int	O
k	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
y	double
>=	O
points	pointer
[	O
j	int
]	O
.	O
y	double
;	O
j	int
++	O
)	O
{	O
}	O
tpt	struct
=	O
points	pointer
[	O
i	int
]	O
;	O
tw	int
=	O
widths	pointer
[	O
i	int
]	O
;	O
for	O
(	O
k	int
=	O
i	int
;	O
k	int
!=	O
j	int
;	O
k	int
--	O
)	O
{	O
points	pointer
[	O
k	int
]	O
=	O
points	pointer
[	O
k	int
-	O
1	int
]	O
;	O
widths	pointer
[	O
k	int
]	O
=	O
widths	pointer
[	O
k	int
-	O
1	int
]	O
;	O
}	O
points	pointer
[	O
j	int
]	O
=	O
tpt	struct
;	O
widths	pointer
[	O
j	int
]	O
=	O
tw	int
;	O
y	double
=	O
points	pointer
[	O
i	int
]	O
.	O
y	double
;	O
}	O
yprev	int
=	O
y	double
;	O
i	int
++	O
;	O
}	O
while	O
(	O
i	int
!=	O
numSpans	int
)	O
;	O
return	O
;	O
}	O
m	array
=	O
numSpans	int
/	O
2	int
;	O
if	O
(	O
points	pointer
[	O
m	array
]	O
.	O
y	double
>	O
points	pointer
[	O
0	int
]	O
.	O
y	double
)	O
ExchangeSpans	O
(	O
m	array
,	O
0	int
)	O
;	O
if	O
(	O
points	pointer
[	O
m	array
]	O
.	O
y	double
>	O
points	pointer
[	O
numSpans	int
-	O
1	int
]	O
.	O
y	double
)	O
ExchangeSpans	O
(	O
m	array
,	O
numSpans	int
-	O
1	int
)	O
;	O
if	O
(	O
points	pointer
[	O
m	array
]	O
.	O
y	double
>	O
points	pointer
[	O
0	int
]	O
.	O
y	double
)	O
ExchangeSpans	O
(	O
m	array
,	O
0	int
)	O
;	O
y	double
=	O
points	pointer
[	O
0	int
]	O
.	O
y	double
;	O
i	int
=	O
0	int
;	O
j	int
=	O
numSpans	int
;	O
do	O
{	O
r	int
=	O
&	O
(	O
points	pointer
[	O
i	int
]	O
)	O
;	O
do	O
{	O
r	int
++	O
;	O
i	int
++	O
;	O
}	O
while	O
(	O
i	int
!=	O
numSpans	int
&&	O
r	int
->	O
y	double
<	O
y	double
)	O
;	O
r	int
=	O
&	O
(	O
points	pointer
[	O
j	int
]	O
)	O
;	O
do	O
{	O
r	int
--	O
;	O
j	int
--	O
;	O
}	O
while	O
(	O
y	double
<	O
r	int
->	O
y	double
)	O
;	O
if	O
(	O
i	int
<	O
j	int
)	O
ExchangeSpans	O
(	O
i	int
,	O
j	int
)	O
;	O
}	O
while	O
(	O
i	int
<	O
j	int
)	O
;	O
ExchangeSpans	O
(	O
0	int
,	O
j	int
)	O
;	O
if	O
(	O
numSpans	int
-	O
j	int
-	O
1	int
>	O
1	int
)	O
miQuickSortSpansY	O
(	O
&	O
points	pointer
[	O
j	int
+	O
1	int
]	O
,	O
&	O
widths	pointer
[	O
j	int
+	O
1	int
]	O
,	O
numSpans	int
-	O
j	int
-	O
1	int
)	O
;	O
numSpans	int
=	O
j	int
;	O
}	O
while	O
(	O
numSpans	int
>	O
1	int
)	O
;	O
}	O
static	O
int	O
miUniquifySpansX	function
(	O
const	O
Spans	struct
*	O
spans	pointer
,	O
miPoint	struct
*	O
newPoints	pointer
,	O
unsigned	O
int	O
*	O
newWidths	pointer
)	O
{	O
int	O
newx1	int
,	O
newx2	int
,	O
oldpt	int
,	O
i	int
,	O
y	double
;	O
miPoint	struct
*	O
oldPoints	pointer
;	O
unsigned	O
int	O
*	O
oldWidths	pointer
,	O
*	O
startNewWidths	pointer
;	O
startNewWidths	pointer
=	O
newWidths	pointer
;	O
oldPoints	pointer
=	O
spans	pointer
->	O
points	pointer
;	O
oldWidths	pointer
=	O
spans	pointer
->	O
widths	pointer
;	O
y	double
=	O
oldPoints	pointer
->	O
y	double
;	O
newx1	int
=	O
oldPoints	pointer
->	O
x	double
;	O
newx2	int
=	O
newx1	int
+	O
(	O
int	O
)	O
(	O
*	O
oldWidths	pointer
)	O
;	O
for	O
(	O
i	int
=	O
spans	pointer
->	O
count	int
-	O
1	int
;	O
i	int
>	O
0	int
;	O
i	int
--	O
)	O
{	O
oldPoints	pointer
++	O
;	O
oldWidths	pointer
++	O
;	O
oldpt	int
=	O
oldPoints	pointer
->	O
x	double
;	O
if	O
(	O
oldpt	int
>	O
newx2	int
)	O
{	O
newPoints	pointer
->	O
x	double
=	O
newx1	int
;	O
newPoints	pointer
->	O
y	double
=	O
y	double
;	O
*	O
newWidths	pointer
=	O
(	O
unsigned	O
int	O
)	O
(	O
newx2	int
-	O
newx1	int
)	O
;	O
newPoints	pointer
++	O
;	O
newWidths	pointer
++	O
;	O
newx1	int
=	O
oldpt	int
;	O
newx2	int
=	O
oldpt	int
+	O
(	O
int	O
)	O
(	O
*	O
oldWidths	pointer
)	O
;	O
}	O
else	O
{	O
oldpt	int
=	O
oldpt	int
+	O
(	O
int	O
)	O
(	O
*	O
oldWidths	pointer
)	O
;	O
if	O
(	O
oldpt	int
>	O
newx2	int
)	O
newx2	int
=	O
oldpt	int
;	O
}	O
}	O
newPoints	pointer
->	O
x	double
=	O
newx1	int
;	O
*	O
newWidths	pointer
=	O
(	O
unsigned	O
int	O
)	O
(	O
newx2	int
-	O
newx1	int
)	O
;	O
newPoints	pointer
->	O
y	double
=	O
y	double
;	O
return	O
(	O
int	O
)	O
(	O
(	O
newWidths	pointer
-	O
startNewWidths	pointer
)	O
+	O
1	int
)	O
;	O
}	O
