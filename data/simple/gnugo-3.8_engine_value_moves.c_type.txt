static	O
int	O
move_connects_strings	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
to_move	int
)	O
{	O
int	O
ss	array
[	O
4	int
]	O
;	O
int	O
strings	array
=	O
0	int
;	O
int	O
own_strings	int
=	O
0	int
;	O
int	O
k	int
,	O
l	int
;	O
int	O
fewlibs	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
{	O
int	O
ii	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
int	O
origin	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
ii	int
)	O
||	O
board	pointer
[	O
ii	int
]	O
==	O
EMPTY	int
)	O
continue	O
;	O
origin	int
=	O
find_origin	function
(	O
ii	int
)	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
strings	array
;	O
l	int
++	O
)	O
if	O
(	O
ss	array
[	O
l	int
]	O
==	O
origin	int
)	O
break	O
;	O
if	O
(	O
l	int
==	O
strings	array
)	O
{	O
ss	array
[	O
strings	array
]	O
=	O
origin	int
;	O
strings	array
++	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
strings	array
;	O
k	int
++	O
)	O
{	O
if	O
(	O
worm	array
[	O
ss	array
[	O
k	int
]	O
]	O
.	O
invincible	int
)	O
continue	O
;	O
if	O
(	O
board	pointer
[	O
ss	array
[	O
k	int
]	O
]	O
==	O
color	int
)	O
{	O
int	O
newlibs	int
=	O
approxlib	function
(	O
pos	int
,	O
color	int
,	O
MAXLIBS	O
,	O
NULL	O
)	O
;	O
own_strings	int
++	O
;	O
if	O
(	O
newlibs	int
>=	O
countlib	function
(	O
ss	array
[	O
k	int
]	O
)	O
)	O
{	O
if	O
(	O
countlib	function
(	O
ss	array
[	O
k	int
]	O
)	O
<=	O
4	int
)	O
fewlibs	int
++	O
;	O
if	O
(	O
countlib	function
(	O
ss	array
[	O
k	int
]	O
)	O
<=	O
2	int
)	O
fewlibs	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
countlib	function
(	O
ss	array
[	O
k	int
]	O
)	O
<=	O
2	int
)	O
fewlibs	int
++	O
;	O
if	O
(	O
countlib	function
(	O
ss	array
[	O
k	int
]	O
)	O
<=	O
1	int
&&	O
to_move	int
)	O
{	O
int	O
dummy	array
[	O
MAXCHAIN	int
]	O
;	O
fewlibs	int
++	O
;	O
fewlibs	int
+=	O
chainlinks2	function
(	O
ss	array
[	O
k	int
]	O
,	O
dummy	array
,	O
1	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
fewlibs	int
>	O
4	int
)	O
fewlibs	int
=	O
4	int
;	O
if	O
(	O
to_move	int
&&	O
is_ko	function
(	O
pos	int
,	O
color	int
,	O
NULL	O
)	O
&&	O
fewlibs	int
>	O
1	int
)	O
fewlibs	int
=	O
1	int
;	O
if	O
(	O
fewlibs	int
==	O
0	int
&&	O
own_strings	int
==	O
1	int
)	O
own_strings	int
=	O
0	int
;	O
return	O
own_strings	int
+	O
fewlibs	int
;	O
}	O
static	O
float	O
value_moves_get_blunder_size	function
(	O
int	O
move	pointer
,	O
int	O
color	int
)	O
{	O
signed	O
char	O
saved_dragons	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
saved_worms	array
[	O
BOARDMAX	O
]	O
;	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
;	O
get_saved_dragons	function
(	O
move	pointer
,	O
saved_dragons	array
)	O
;	O
get_saved_worms	function
(	O
move	pointer
,	O
saved_worms	array
)	O
;	O
mark_safe_stones	function
(	O
color	int
,	O
move	pointer
,	O
saved_dragons	array
,	O
saved_worms	array
,	O
safe_stones	array
)	O
;	O
return	O
blunder_size	function
(	O
move	pointer
,	O
color	int
,	O
NULL	O
,	O
safe_stones	array
)	O
;	O
}	O
static	O
int	O
value_moves_confirm_safety	function
(	O
int	O
move	pointer
,	O
int	O
color	int
)	O
{	O
return	O
(	O
value_moves_get_blunder_size	function
(	O
move	pointer
,	O
color	int
)	O
==	O
0.0	int
)	O
;	O
}	O
static	O
void	O
find_more_attack_and_defense_moves	function
(	O
int	O
color	int
)	O
{	O
int	O
unstable_worms	array
[	O
MAX_WORMS	O
]	O
;	O
int	O
N	int
=	O
0	int
;	O
int	O
ii	int
;	O
int	O
k	int
;	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
cursor_at_start_of_line	int
;	O
TRACE	O
(	O
"\nLooking for additional attack and defense moves. Trying moves ...\n"	pointer
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
ii	int
]	O
)	O
&&	O
worm	array
[	O
ii	int
]	O
.	O
origin	int
==	O
ii	int
&&	O
worm	array
[	O
ii	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
worm	array
[	O
ii	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
unstable_worms	array
[	O
N	int
]	O
=	O
ii	int
;	O
N	int
++	O
;	O
}	O
}	O
increase_depth_values	function
(	O
)	O
;	O
for	O
(	O
ii	int
=	O
BOARDMIN	O
;	O
ii	int
<	O
BOARDMAX	O
;	O
ii	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
ii	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
if	O
(	O
send_two_return_one	function
(	O
ii	int
,	O
color	int
)	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
ii	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_BAD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_GOOD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_BAD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
CONNECT_MOVE	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
CUT_MOVE	int
)	O
break	O
;	O
}	O
if	O
(	O
k	int
==	O
MAX_REASONS	int
||	O
move	pointer
[	O
ii	int
]	O
.	O
reason	array
[	O
k	int
]	O
==	O
-	O
1	int
)	O
continue	O
;	O
cursor_at_start_of_line	int
=	O
0	int
;	O
TRACE	O
(	O
"%1m "	pointer
,	O
ii	int
)	O
;	O
if	O
(	O
trymove	function
(	O
ii	int
,	O
color	int
,	O
"find_more_attack_and_defense_moves"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
N	int
;	O
k	int
++	O
)	O
{	O
int	O
aa	int
=	O
unstable_worms	array
[	O
k	int
]	O
;	O
if	O
(	O
board	pointer
[	O
aa	int
]	O
==	O
color	int
&&	O
!	O
defense_move_reason_known	function
(	O
ii	int
,	O
unstable_worms	array
[	O
k	int
]	O
)	O
)	O
{	O
int	O
acode	int
=	O
attack	function
(	O
aa	int
,	O
NULL	O
)	O
;	O
if	O
(	O
acode	int
<	O
worm	array
[	O
aa	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
)	O
{	O
int	O
defense_works	int
=	O
1	int
;	O
if	O
(	O
trymove	function
(	O
worm	array
[	O
aa	int
]	O
.	O
attack_points	array
[	O
0	int
]	O
,	O
other	int
,	O
"find_more_attack_and_defense_moves"	pointer
,	O
0	int
)	O
)	O
{	O
if	O
(	O
!	O
board	pointer
[	O
aa	int
]	O
)	O
defense_works	int
=	O
0	int
;	O
else	O
{	O
int	O
this_acode	int
=	O
REVERSE_RESULT	O
(	O
find_defense	function
(	O
aa	int
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
this_acode	int
>	O
acode	int
)	O
{	O
acode	int
=	O
this_acode	int
;	O
if	O
(	O
acode	int
>=	O
worm	array
[	O
aa	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
)	O
defense_works	int
=	O
0	int
;	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
defense_works	int
)	O
{	O
if	O
(	O
!	O
cursor_at_start_of_line	int
)	O
TRACE	O
(	O
"\n"	pointer
)	O
;	O
TRACE	O
(	O
"%ofound extra point of defense of %1m at %1m code %d\n"	pointer
,	O
aa	int
,	O
ii	int
,	O
REVERSE_RESULT	O
(	O
acode	int
)	O
)	O
;	O
cursor_at_start_of_line	int
=	O
1	int
;	O
add_defense_move	function
(	O
ii	int
,	O
aa	int
,	O
REVERSE_RESULT	O
(	O
acode	int
)	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
board	pointer
[	O
aa	int
]	O
==	O
other	int
&&	O
!	O
attack_move_reason_known	function
(	O
ii	int
,	O
unstable_worms	array
[	O
k	int
]	O
)	O
)	O
{	O
int	O
dcode	int
=	O
find_defense	function
(	O
aa	int
,	O
NULL	O
)	O
;	O
if	O
(	O
dcode	int
<	O
worm	array
[	O
aa	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
)	O
{	O
int	O
attack_works	int
=	O
1	int
;	O
if	O
(	O
attack	function
(	O
aa	int
,	O
NULL	O
)	O
>=	O
worm	array
[	O
aa	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
)	O
{	O
if	O
(	O
trymove	function
(	O
worm	array
[	O
aa	int
]	O
.	O
defense_points	array
[	O
0	int
]	O
,	O
other	int
,	O
"find_more_attack_and_defense_moves"	pointer
,	O
0	int
)	O
)	O
{	O
int	O
this_dcode	int
=	O
REVERSE_RESULT	O
(	O
attack	function
(	O
aa	int
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
this_dcode	int
>	O
dcode	int
)	O
{	O
dcode	int
=	O
this_dcode	int
;	O
if	O
(	O
dcode	int
>=	O
worm	array
[	O
aa	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
)	O
attack_works	int
=	O
0	int
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
else	O
attack_works	int
=	O
0	int
;	O
if	O
(	O
attack_works	int
)	O
{	O
if	O
(	O
!	O
cursor_at_start_of_line	int
)	O
TRACE	O
(	O
"\n"	pointer
)	O
;	O
TRACE	O
(	O
"%ofound extra point of attack of %1m at %1m code %d\n"	pointer
,	O
aa	int
,	O
ii	int
,	O
REVERSE_RESULT	O
(	O
dcode	int
)	O
)	O
;	O
cursor_at_start_of_line	int
=	O
1	int
;	O
add_attack_move	function
(	O
ii	int
,	O
aa	int
,	O
REVERSE_RESULT	O
(	O
dcode	int
)	O
)	O
;	O
}	O
}	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
TRACE	O
(	O
"\n"	pointer
)	O
;	O
decrease_depth_values	function
(	O
)	O
;	O
}	O
static	O
void	O
do_find_more_owl_attack_and_defense_moves	function
(	O
int	O
color	int
,	O
int	O
pos	int
,	O
int	O
move_reason_type	int
,	O
int	O
what	int
)	O
{	O
int	O
k	int
;	O
int	O
dd1	int
=	O
NO_MOVE	O
;	O
int	O
dd2	int
=	O
NO_MOVE	O
;	O
int	O
save_verbose	int
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
send_two_return_one	function
(	O
pos	int
,	O
color	int
)	O
)	O
return	O
;	O
if	O
(	O
playing_into_snapback	function
(	O
pos	int
,	O
color	int
)	O
)	O
return	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
if	O
(	O
move_reason_type	int
==	O
STRATEGIC_ATTACK_MOVE	int
||	O
move_reason_type	int
==	O
STRATEGIC_DEFEND_MOVE	int
)	O
dd1	int
=	O
what	int
;	O
else	O
if	O
(	O
move_reason_type	int
==	O
ATTACK_MOVE	int
||	O
move_reason_type	int
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
move_reason_type	int
==	O
ATTACK_MOVE_BAD_KO	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE_GOOD_KO	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE_BAD_KO	int
||	O
move_reason_type	int
==	O
VITAL_EYE_MOVE	int
)	O
dd1	int
=	O
what	int
;	O
else	O
if	O
(	O
move_reason_type	int
==	O
CONNECT_MOVE	int
)	O
{	O
int	O
worm1	int
=	O
conn_worm1	array
[	O
what	int
]	O
;	O
int	O
worm2	int
=	O
conn_worm2	array
[	O
what	int
]	O
;	O
dd1	int
=	O
dragon	int
[	O
worm1	int
]	O
.	O
origin	int
;	O
dd2	int
=	O
dragon	int
[	O
worm2	int
]	O
.	O
origin	int
;	O
if	O
(	O
dd1	int
==	O
dd2	int
)	O
dd2	int
=	O
NO_MOVE	O
;	O
}	O
else	O
{	O
verbose	int
=	O
save_verbose	int
;	O
return	O
;	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
2	int
;	O
k	int
++	O
)	O
{	O
int	O
dd	int
=	O
(	O
k	int
==	O
0	int
?	O
dd1	int
:	O
dd2	int
)	O
;	O
if	O
(	O
dd	int
==	O
NO_MOVE	O
)	O
continue	O
;	O
if	O
(	O
DRAGON2	O
(	O
dd	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
)	O
continue	O
;	O
if	O
(	O
DRAGON2	O
(	O
dd	int
)	O
.	O
owl_status	enum
!=	O
CRITICAL	int
)	O
continue	O
;	O
if	O
(	O
(	O
move_reason_type	int
==	O
STRATEGIC_ATTACK_MOVE	int
||	O
move_reason_type	int
==	O
ATTACK_MOVE	int
||	O
move_reason_type	int
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
move_reason_type	int
==	O
ATTACK_MOVE_BAD_KO	int
||	O
(	O
move_reason_type	int
==	O
VITAL_EYE_MOVE	int
&&	O
board	pointer
[	O
dd	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
&&	O
!	O
owl_attack_move_reason_known	function
(	O
pos	int
,	O
dd	int
)	O
)	O
{	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
acode	int
=	O
owl_does_attack	function
(	O
pos	int
,	O
dd	int
,	O
&	O
kworm	int
)	O
;	O
if	O
(	O
acode	int
>=	O
DRAGON2	O
(	O
dd	int
)	O
.	O
owl_attack_code	int
)	O
{	O
add_owl_attack_move	function
(	O
pos	int
,	O
dd	int
,	O
kworm	int
,	O
acode	int
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	function
(	O
"Move at %1m upgraded to owl attack on %1m (%s).\n"	pointer
,	O
pos	int
,	O
dd	int
,	O
result_to_string	function
(	O
acode	int
)	O
)	O
;	O
}	O
}	O
if	O
(	O
(	O
move_reason_type	int
==	O
STRATEGIC_DEFEND_MOVE	int
||	O
move_reason_type	int
==	O
CONNECT_MOVE	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE_GOOD_KO	int
||	O
move_reason_type	int
==	O
DEFEND_MOVE_BAD_KO	int
||	O
(	O
move_reason_type	int
==	O
VITAL_EYE_MOVE	int
&&	O
board	pointer
[	O
dd	int
]	O
==	O
color	int
)	O
)	O
&&	O
!	O
owl_defense_move_reason_known	function
(	O
pos	int
,	O
dd	int
)	O
)	O
{	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
dcode	int
=	O
owl_does_defend	function
(	O
pos	int
,	O
dd	int
,	O
&	O
kworm	int
)	O
;	O
if	O
(	O
dcode	int
>=	O
DRAGON2	O
(	O
dd	int
)	O
.	O
owl_defense_code	int
)	O
{	O
if	O
(	O
dcode	int
==	O
LOSS	int
)	O
add_loss_move	function
(	O
pos	int
,	O
dd	int
,	O
kworm	int
)	O
;	O
else	O
add_owl_defense_move	function
(	O
pos	int
,	O
dd	int
,	O
dcode	int
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	function
(	O
"Move at %1m upgraded to owl defense for %1m (%s).\n"	pointer
,	O
pos	int
,	O
dd	int
,	O
result_to_string	function
(	O
dcode	int
)	O
)	O
;	O
}	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
}	O
static	O
void	O
try_large_scale_owl_attack	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
int	O
target	int
,	O
int	O
dist	int
)	O
{	O
int	O
owl_nodes_before	int
;	O
int	O
owl_nodes_used	int
;	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
acode	int
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
int	O
save_owl_node_limit	int
=	O
owl_node_limit	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
target	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
pos	int
)	O
;	O
ASSERT1	O
(	O
!	O
owl_attack_move_reason_known	function
(	O
pos	int
,	O
target	int
)	O
,	O
pos	int
)	O
;	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
,	O
"Trying large scale move %1m on %1m\n"	pointer
,	O
pos	int
,	O
target	int
)	O
;	O
increase_depth_values	function
(	O
)	O
;	O
if	O
(	O
dist	int
<=	O
1	int
)	O
owl_node_limit	int
*=	O
0.35	int
;	O
else	O
owl_node_limit	int
*=	O
0.15	int
;	O
if	O
(	O
DRAGON2	O
(	O
target	int
)	O
.	O
owl_attack_node_count	int
<	O
owl_node_limit	int
)	O
{	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
owl_nodes_before	int
=	O
get_owl_node_counter	function
(	O
)	O
;	O
acode	int
=	O
owl_does_attack	function
(	O
pos	int
,	O
target	int
,	O
&	O
kworm	int
)	O
;	O
owl_nodes_used	int
=	O
get_owl_node_counter	function
(	O
)	O
-	O
owl_nodes_before	int
;	O
if	O
(	O
acode	int
>=	O
DRAGON2	O
(	O
target	int
)	O
.	O
owl_attack_code	int
&&	O
acode	int
==	O
WIN	int
)	O
{	O
add_owl_attack_move	function
(	O
pos	int
,	O
target	int
,	O
kworm	int
,	O
acode	int
)	O
;	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
|	O
DEBUG_MOVE_REASONS	int
,	O
"Move at %1m owl-attacks %1m on a large scale(%s).\n"	pointer
,	O
pos	int
,	O
target	int
,	O
result_to_string	function
(	O
acode	int
)	O
)	O
;	O
}	O
else	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
,	O
"Move at %1m isn't a clean large scale attack on %1m (%s).\n"	pointer
,	O
pos	int
,	O
target	int
,	O
result_to_string	function
(	O
acode	int
)	O
)	O
;	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
,	O
"  owl nodes used = %d, dist = %d\n"	pointer
,	O
owl_nodes_used	int
,	O
dist	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
}	O
decrease_depth_values	function
(	O
)	O
;	O
owl_node_limit	int
=	O
save_owl_node_limit	int
;	O
}	O
static	O
void	O
find_large_scale_owl_attacks_on_dragon	function
(	O
int	O
color	int
,	O
int	O
target	int
)	O
{	O
int	O
x	int
,	O
y	int
;	O
int	O
x_min	int
=	O
board_size	int
;	O
int	O
x_max	int
=	O
0	int
;	O
int	O
y_min	int
=	O
board_size	int
;	O
int	O
y_max	int
=	O
0	int
;	O
int	O
dist	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
target	int
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
target	int
)	O
;	O
for	O
(	O
x	int
=	O
0	int
;	O
x	int
<	O
board_size	int
;	O
x	int
++	O
)	O
for	O
(	O
y	int
=	O
0	int
;	O
y	int
<	O
board_size	int
;	O
y	int
++	O
)	O
{	O
if	O
(	O
is_same_dragon	function
(	O
target	int
,	O
POS	O
(	O
x	int
,	O
y	int
)	O
)	O
)	O
{	O
if	O
(	O
x	int
<	O
x_min	int
)	O
x_min	int
=	O
x	int
;	O
if	O
(	O
x	int
>	O
x_max	int
)	O
x_max	int
=	O
x	int
;	O
if	O
(	O
y	int
<	O
y_min	int
)	O
y_min	int
=	O
y	int
;	O
if	O
(	O
y	int
>	O
y_max	int
)	O
y_max	int
=	O
y	int
;	O
}	O
}	O
ASSERT1	O
(	O
x_min	int
<=	O
x_max	int
&&	O
y_min	int
<=	O
y_max	int
,	O
target	int
)	O
;	O
for	O
(	O
dist	int
=	O
0	int
;	O
dist	int
<=	O
MAXIMUM_LARGE_SCALE_DIST	int
;	O
dist	int
++	O
)	O
for	O
(	O
x	int
=	O
gg_max	O
(	O
x_min	int
-	O
dist	int
,	O
0	int
)	O
;	O
x	int
<=	O
gg_min	O
(	O
x_max	int
+	O
dist	int
,	O
board_size	int
-	O
1	int
)	O
;	O
x	int
++	O
)	O
for	O
(	O
y	int
=	O
gg_max	O
(	O
y_min	int
-	O
dist	int
,	O
0	int
)	O
;	O
y	int
<=	O
gg_min	O
(	O
y_max	int
+	O
dist	int
,	O
board_size	int
-	O
1	int
)	O
;	O
y	int
++	O
)	O
{	O
int	O
pos	int
=	O
POS	O
(	O
x	int
,	O
y	int
)	O
;	O
ASSERT1	O
(	O
ON_BOARD2	O
(	O
x	int
,	O
y	int
)	O
,	O
pos	int
)	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
)	O
{	O
int	O
a	char
,	O
b	char
,	O
dx	int
,	O
dy	int
;	O
a	char
=	O
abs	function
(	O
x	int
-	O
x_min	int
)	O
;	O
b	char
=	O
abs	function
(	O
x	int
-	O
x_max	int
)	O
;	O
dx	int
=	O
gg_min	O
(	O
a	char
,	O
b	char
)	O
;	O
a	char
=	O
abs	function
(	O
y	int
-	O
y_min	int
)	O
;	O
b	char
=	O
abs	function
(	O
y	int
-	O
y_max	int
)	O
;	O
dy	int
=	O
gg_min	O
(	O
a	char
,	O
b	char
)	O
;	O
if	O
(	O
gg_max	O
(	O
dx	int
,	O
dy	int
)	O
==	O
dist	int
&&	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
0	int
]	O
>=	O
0	int
&&	O
!	O
owl_attack_move_reason_known	function
(	O
pos	int
,	O
target	int
)	O
)	O
try_large_scale_owl_attack	function
(	O
pos	int
,	O
color	int
,	O
target	int
,	O
dist	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
find_large_scale_owl_attack_moves	function
(	O
int	O
color	int
)	O
{	O
int	O
d	int
;	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
,	O
"\nTrying to find large scale attack moves.\n"	pointer
)	O
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
number_of_dragons	int
;	O
d	int
++	O
)	O
{	O
int	O
target	int
=	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
;	O
if	O
(	O
dragon	int
[	O
target	int
]	O
.	O
color	int
==	O
OTHER_COLOR	O
(	O
color	int
)	O
&&	O
dragon	int
[	O
target	int
]	O
.	O
size	int
<=	O
6	int
&&	O
dragon	int
[	O
target	int
]	O
.	O
status	enum
==	O
CRITICAL	int
&&	O
dragon2	pointer
[	O
d	int
]	O
.	O
owl_status	enum
==	O
CRITICAL	int
)	O
{	O
DEBUG	O
(	O
DEBUG_LARGE_SCALE	int
,	O
"Small critical dragon found at %1m\n"	pointer
,	O
target	int
)	O
;	O
find_large_scale_owl_attacks_on_dragon	function
(	O
color	int
,	O
target	int
)	O
;	O
}	O
}	O
}	O
static	O
void	O
find_more_owl_attack_and_defense_moves	function
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
,	O
pos2	int
;	O
int	O
k	int
;	O
int	O
dd	int
=	O
NO_MOVE	O
;	O
int	O
worth_trying	int
;	O
int	O
save_verbose	int
;	O
struct	O
eye_data	struct
*	O
our_eyes	pointer
;	O
struct	O
eye_data	struct
*	O
your_eyes	pointer
;	O
struct	O
vital_eye_points	struct
*	O
our_vital_points	pointer
;	O
struct	O
vital_eye_points	struct
*	O
your_vital_points	pointer
;	O
if	O
(	O
verbose	int
)	O
gprintf	function
(	O
"\nTrying to upgrade strategical attack and defense moves.\n"	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
do_find_more_owl_attack_and_defense_moves	function
(	O
color	int
,	O
pos	int
,	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
,	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
)	O
;	O
}	O
}	O
if	O
(	O
verbose	int
)	O
gprintf	function
(	O
"\nTrying vital eye moves as owl attacks.\n"	pointer
)	O
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
{	O
our_eyes	pointer
=	O
white_eye	array
;	O
your_eyes	pointer
=	O
black_eye	array
;	O
our_vital_points	pointer
=	O
white_vital_points	array
;	O
your_vital_points	pointer
=	O
black_vital_points	array
;	O
}	O
else	O
{	O
our_eyes	pointer
=	O
black_eye	array
;	O
your_eyes	pointer
=	O
white_eye	array
;	O
our_vital_points	pointer
=	O
black_vital_points	array
;	O
your_vital_points	pointer
=	O
white_vital_points	array
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
if	O
(	O
our_eyes	pointer
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
&&	O
our_vital_points	pointer
[	O
pos	int
]	O
.	O
defense_points	array
[	O
0	int
]	O
!=	O
NO_MOVE	O
)	O
{	O
int	O
k	int
,	O
dr	int
;	O
find_eye_dragons	function
(	O
pos	int
,	O
our_eyes	pointer
,	O
color	int
,	O
&	O
dr	int
,	O
1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_EYE_ATTACKS	int
;	O
k	int
++	O
)	O
{	O
int	O
move	pointer
=	O
our_vital_points	pointer
[	O
pos	int
]	O
.	O
defense_points	array
[	O
k	int
]	O
;	O
if	O
(	O
move	pointer
==	O
NO_MOVE	O
)	O
break	O
;	O
do_find_more_owl_attack_and_defense_moves	function
(	O
color	int
,	O
move	pointer
,	O
VITAL_EYE_MOVE	int
,	O
dr	int
)	O
;	O
}	O
}	O
if	O
(	O
your_eyes	pointer
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
&&	O
your_vital_points	pointer
[	O
pos	int
]	O
.	O
attack_points	array
[	O
0	int
]	O
!=	O
NO_MOVE	O
)	O
{	O
int	O
k	int
,	O
dr	int
;	O
find_eye_dragons	function
(	O
pos	int
,	O
your_eyes	pointer
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
&	O
dr	int
,	O
1	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_EYE_ATTACKS	int
;	O
k	int
++	O
)	O
{	O
int	O
move	pointer
=	O
your_vital_points	pointer
[	O
pos	int
]	O
.	O
attack_points	array
[	O
k	int
]	O
;	O
if	O
(	O
move	pointer
==	O
NO_MOVE	O
)	O
break	O
;	O
do_find_more_owl_attack_and_defense_moves	function
(	O
color	int
,	O
move	pointer
,	O
VITAL_EYE_MOVE	int
,	O
dr	int
)	O
;	O
}	O
}	O
}	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
pos	int
]	O
)	O
&&	O
dragon	int
[	O
pos	int
]	O
.	O
origin	int
==	O
pos	int
&&	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_status	enum
==	O
CRITICAL	int
)	O
{	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos2	int
]	O
!=	O
EMPTY	int
)	O
continue	O
;	O
worth_trying	int
=	O
0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos2	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_GOOD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_BAD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_GOOD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_BAD_KO	int
)	O
{	O
dd	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
are_neighbor_dragons	function
(	O
dd	int
,	O
pos	int
)	O
)	O
{	O
worth_trying	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
worth_trying	int
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
color	int
&&	O
!	O
owl_defense_move_reason_known	function
(	O
pos2	int
,	O
pos	int
)	O
)	O
{	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
dcode	int
=	O
owl_does_defend	function
(	O
pos2	int
,	O
pos	int
,	O
&	O
kworm	int
)	O
;	O
if	O
(	O
dcode	int
>=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_defense_code	int
)	O
{	O
if	O
(	O
dcode	int
==	O
LOSS	int
)	O
add_loss_move	function
(	O
pos2	int
,	O
pos	int
,	O
kworm	int
)	O
;	O
else	O
add_owl_defense_move	function
(	O
pos2	int
,	O
pos	int
,	O
dcode	int
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	function
(	O
"Move at %1m also owl defends %1m (%s).\n"	pointer
,	O
pos2	int
,	O
pos	int
,	O
result_to_string	function
(	O
dcode	int
)	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
!=	O
color	int
&&	O
!	O
owl_attack_move_reason_known	function
(	O
pos2	int
,	O
pos	int
)	O
)	O
{	O
int	O
kworm	int
=	O
NO_MOVE	O
;	O
int	O
acode	int
=	O
owl_does_attack	function
(	O
pos2	int
,	O
pos	int
,	O
&	O
kworm	int
)	O
;	O
if	O
(	O
acode	int
>=	O
DRAGON2	O
(	O
pos	int
)	O
.	O
owl_attack_code	int
)	O
{	O
add_owl_attack_move	function
(	O
pos2	int
,	O
pos	int
,	O
kworm	int
,	O
acode	int
)	O
;	O
if	O
(	O
save_verbose	int
)	O
gprintf	function
(	O
"Move at %1m also owl attacks %1m (%s).\n"	pointer
,	O
pos2	int
,	O
pos	int
,	O
result_to_string	function
(	O
acode	int
)	O
)	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
}	O
static	O
void	O
try_potential_semeai_move	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
struct	O
move_reason	struct
*	O
reason	array
)	O
{	O
int	O
dr1	int
=	O
semeai_target1	array
[	O
reason	array
->	O
what	int
]	O
;	O
int	O
dr2	int
=	O
semeai_target2	array
[	O
reason	array
->	O
what	int
]	O
;	O
int	O
resulta	pointer
,	O
resultb	pointer
,	O
certain	pointer
,	O
old_certain	int
;	O
ASSERT1	O
(	O
IS_STONE	O
(	O
board	pointer
[	O
dr1	int
]	O
)	O
,	O
pos	int
)	O
;	O
switch	O
(	O
reason	array
->	O
type	char
)	O
{	O
case	O
POTENTIAL_SEMEAI_ATTACK	int
:	O
owl_analyze_semeai_after_move	function
(	O
pos	int
,	O
color	int
,	O
dr1	int
,	O
dr2	int
,	O
&	O
resulta	pointer
,	O
&	O
resultb	pointer
,	O
NULL	O
,	O
1	int
,	O
&	O
certain	pointer
,	O
0	int
)	O
;	O
old_certain	int
=	O
DRAGON2	O
(	O
dr1	int
)	O
.	O
semeai_attack_certain	int
;	O
break	O
;	O
case	O
POTENTIAL_SEMEAI_DEFENSE	int
:	O
old_certain	int
=	O
DRAGON2	O
(	O
dr1	int
)	O
.	O
semeai_defense_certain	int
;	O
owl_analyze_semeai_after_move	function
(	O
pos	int
,	O
color	int
,	O
dr2	int
,	O
dr1	int
,	O
&	O
resulta	pointer
,	O
&	O
resultb	pointer
,	O
NULL	O
,	O
1	int
,	O
&	O
certain	pointer
,	O
0	int
)	O
;	O
break	O
;	O
default	O
:	O
ASSERT1	O
(	O
0	int
,	O
pos	int
)	O
;	O
}	O
if	O
(	O
resulta	pointer
==	O
0	int
&&	O
resultb	pointer
==	O
0	int
&&	O
(	O
certain	pointer
||	O
!	O
old_certain	int
)	O
)	O
{	O
add_semeai_move	function
(	O
pos	int
,	O
dr1	int
)	O
;	O
DEBUG	O
(	O
DEBUG_SEMEAI	int
,	O
"Potential semeai move at %1m for dragon at %1m is real\n"	pointer
,	O
pos	int
,	O
dr1	int
)	O
;	O
}	O
else	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Potential semeai move at %1m for %1m discarded\n"	pointer
,	O
pos	int
,	O
dr1	int
)	O
;	O
}	O
static	O
void	O
find_more_semeai_moves	function
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
int	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
k	int
,	O
r	int
;	O
int	O
potential_semeai_move_found	int
=	O
0	int
;	O
int	O
other_move_reason_found	int
=	O
0	int
;	O
if	O
(	O
!	O
ON_BOARD1	O
(	O
pos	int
)	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
POTENTIAL_SEMEAI_ATTACK	int
:	O
case	O
POTENTIAL_SEMEAI_DEFENSE	int
:	O
potential_semeai_move_found	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
other_move_reason_found	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
(	O
r	int
<	O
0	int
||	O
k	int
==	O
MAX_REASONS	int
)	O
&&	O
!	O
other_move_reason_found	int
)	O
continue	O
;	O
if	O
(	O
!	O
potential_semeai_move_found	int
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
POTENTIAL_SEMEAI_ATTACK	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
POTENTIAL_SEMEAI_DEFENSE	int
)	O
try_potential_semeai_move	function
(	O
pos	int
,	O
color	int
,	O
&	O
(	O
move_reasons	array
[	O
r	int
]	O
)	O
)	O
;	O
}	O
}	O
verbose	int
=	O
save_verbose	int
;	O
}	O
static	O
void	O
induce_secondary_move_reasons	function
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
i	int
,	O
j	int
;	O
int	O
aa	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE	int
)	O
{	O
int	O
attack_move	pointer
;	O
int	O
color_to_move	int
;	O
int	O
num_adj	pointer
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE	int
)	O
{	O
attack_move	pointer
=	O
1	int
;	O
color_to_move	int
=	O
OTHER_COLOR	O
(	O
board	pointer
[	O
aa	int
]	O
)	O
;	O
}	O
else	O
{	O
attack_move	pointer
=	O
0	int
;	O
color_to_move	int
=	O
board	pointer
[	O
aa	int
]	O
;	O
}	O
if	O
(	O
worm	array
[	O
aa	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
continue	O
;	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
)	O
continue	O
;	O
if	O
(	O
!	O
attack_move	pointer
&&	O
!	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
)	O
continue	O
;	O
num_adj	pointer
=	O
extended_chainlinks	function
(	O
aa	int
,	O
adjs	array
,	O
1	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_adj	pointer
;	O
i	int
++	O
)	O
{	O
for	O
(	O
j	int
=	O
i	int
+	O
1	int
;	O
j	int
<	O
num_adj	pointer
;	O
j	int
++	O
)	O
{	O
int	O
adj1	int
=	O
adjs	array
[	O
i	int
]	O
;	O
int	O
adj2	int
=	O
adjs	array
[	O
j	int
]	O
;	O
if	O
(	O
board	pointer
[	O
adj1	int
]	O
!=	O
board	pointer
[	O
adj2	int
]	O
)	O
continue	O
;	O
if	O
(	O
attack_move	pointer
&&	O
board	pointer
[	O
adj1	int
]	O
!=	O
board	pointer
[	O
aa	int
]	O
&&	O
!	O
disconnect	function
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
attack_move	pointer
&&	O
board	pointer
[	O
adj1	int
]	O
!=	O
board	pointer
[	O
aa	int
]	O
&&	O
!	O
string_connect	function
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
continue	O
;	O
if	O
(	O
attack_move	pointer
&&	O
board	pointer
[	O
adj1	int
]	O
==	O
board	pointer
[	O
aa	int
]	O
)	O
continue	O
;	O
if	O
(	O
!	O
attack_move	pointer
&&	O
board	pointer
[	O
adj1	int
]	O
==	O
board	pointer
[	O
aa	int
]	O
&&	O
!	O
disconnect	function
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
continue	O
;	O
if	O
(	O
trymove	function
(	O
pos	int
,	O
color_to_move	int
,	O
"induce_secondary_move_reasons"	pointer
,	O
aa	int
)	O
)	O
{	O
if	O
(	O
attack_move	pointer
&&	O
board	pointer
[	O
adj1	int
]	O
!=	O
board	pointer
[	O
aa	int
]	O
&&	O
!	O
disconnect	function
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Connection move at %1m induced for %1m/%1m due to attack of %1m\n"	pointer
,	O
pos	int
,	O
adj1	int
,	O
adj2	int
,	O
aa	int
)	O
;	O
add_connection_move	function
(	O
pos	int
,	O
adj1	int
,	O
adj2	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	function
(	O
color	int
,	O
pos	int
,	O
CONNECT_MOVE	int
,	O
find_connection	function
(	O
adj1	int
,	O
adj2	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
!	O
attack_move	pointer
&&	O
board	pointer
[	O
adj1	int
]	O
!=	O
board	pointer
[	O
aa	int
]	O
&&	O
!	O
string_connect	function
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Cut move at %1m induced for %1m/%1m due to defense of %1m\n"	pointer
,	O
pos	int
,	O
adj1	int
,	O
adj2	int
,	O
aa	int
)	O
;	O
add_cut_move	function
(	O
pos	int
,	O
adj1	int
,	O
adj2	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
attack_move	pointer
&&	O
board	pointer
[	O
adj1	int
]	O
==	O
board	pointer
[	O
aa	int
]	O
&&	O
!	O
disconnect	function
(	O
adj1	int
,	O
adj2	int
,	O
NULL	O
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Connection move at %1m induced for %1m/%1m due to defense of %1m\n"	pointer
,	O
pos	int
,	O
adj1	int
,	O
adj2	int
,	O
aa	int
)	O
;	O
add_connection_move	function
(	O
pos	int
,	O
adj1	int
,	O
adj2	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	function
(	O
color	int
,	O
pos	int
,	O
CONNECT_MOVE	int
,	O
find_connection	function
(	O
adj1	int
,	O
adj2	int
)	O
)	O
;	O
}	O
else	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
attack_move	pointer
)	O
{	O
int	O
strategically_valuable	int
=	O
(	O
worm	array
[	O
aa	int
]	O
.	O
size	int
>	O
3	int
)	O
;	O
signed	O
char	O
neighbor_dragons	array
[	O
BOARDMAX	O
]	O
;	O
memset	function
(	O
neighbor_dragons	array
,	O
0	int
,	O
sizeof	O
(	O
neighbor_dragons	array
)	O
)	O
;	O
if	O
(	O
!	O
strategically_valuable	int
)	O
{	O
int	O
num_dragons	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_adj	pointer
;	O
i	int
++	O
)	O
{	O
int	O
origin	int
=	O
dragon	int
[	O
adjs	array
[	O
i	int
]	O
]	O
.	O
origin	int
;	O
if	O
(	O
board	pointer
[	O
origin	int
]	O
!=	O
color_to_move	int
&&	O
neighbor_dragons	array
[	O
origin	int
]	O
!=	O
1	int
&&	O
dragon	int
[	O
origin	int
]	O
.	O
size	int
>	O
1	int
&&	O
dragon	int
[	O
origin	int
]	O
.	O
status	enum
!=	O
DEAD	int
)	O
{	O
if	O
(	O
++	O
num_dragons	int
==	O
2	int
)	O
{	O
strategically_valuable	int
=	O
1	int
;	O
break	O
;	O
}	O
neighbor_dragons	array
[	O
origin	int
]	O
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
strategically_valuable	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_adj	pointer
;	O
i	int
++	O
)	O
{	O
int	O
origin	int
=	O
dragon	int
[	O
adjs	array
[	O
i	int
]	O
]	O
.	O
origin	int
;	O
if	O
(	O
board	pointer
[	O
origin	int
]	O
!=	O
color_to_move	int
&&	O
neighbor_dragons	array
[	O
origin	int
]	O
!=	O
2	int
&&	O
dragon	int
[	O
origin	int
]	O
.	O
status	enum
!=	O
DEAD	int
&&	O
dragon_weak	function
(	O
origin	int
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Strategical attack move at %1m induced for %1m due to defense of %1m\n"	pointer
,	O
pos	int
,	O
origin	int
,	O
aa	int
)	O
;	O
add_strategical_attack_move	function
(	O
pos	int
,	O
origin	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	function
(	O
color	int
,	O
pos	int
,	O
STRATEGIC_ATTACK_MOVE	int
,	O
origin	int
)	O
;	O
neighbor_dragons	array
[	O
origin	int
]	O
=	O
2	int
;	O
}	O
}	O
}	O
}	O
}	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE	int
)	O
{	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
DRAGON2	O
(	O
aa	int
)	O
.	O
neighbors	int
;	O
i	int
++	O
)	O
{	O
int	O
bb	int
=	O
dragon2	pointer
[	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array
[	O
i	int
]	O
]	O
.	O
origin	int
;	O
if	O
(	O
dragon	int
[	O
bb	int
]	O
.	O
color	int
==	O
color	int
&&	O
worm	array
[	O
bb	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
==	O
0	int
&&	O
!	O
DRAGON2	O
(	O
bb	int
)	O
.	O
semeais	int
)	O
{	O
add_strategical_defense_move	function
(	O
pos	int
,	O
bb	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	function
(	O
color	int
,	O
pos	int
,	O
STRATEGIC_DEFEND_MOVE	int
,	O
bb	int
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Strategic defense at %1m induced for %1m due to owl attack on %1m\n"	pointer
,	O
pos	int
,	O
bb	int
,	O
aa	int
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
CONNECT_MOVE	int
&&	O
cut_possible	function
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
)	O
{	O
int	O
worm1	int
=	O
conn_worm1	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
;	O
int	O
worm2	int
=	O
conn_worm2	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
;	O
int	O
pos2	int
;	O
for	O
(	O
pos2	int
=	O
BOARDMIN	O
;	O
pos2	int
<	O
BOARDMAX	O
;	O
pos2	int
++	O
)	O
{	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
board	pointer
[	O
pos2	int
]	O
==	O
EMPTY	int
&&	O
cut_possible	function
(	O
pos2	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
&&	O
square_dist	function
(	O
pos	int
,	O
pos2	int
)	O
<=	O
5	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
8	int
;	O
j	int
++	O
)	O
{	O
int	O
pos3	int
=	O
pos2	int
+	O
delta	array
[	O
j	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos3	int
)	O
&&	O
board	pointer
[	O
pos3	int
]	O
==	O
color	int
&&	O
!	O
is_same_worm	function
(	O
pos3	int
,	O
worm1	int
)	O
&&	O
!	O
is_same_worm	function
(	O
pos3	int
,	O
worm2	int
)	O
)	O
{	O
if	O
(	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
"induce_secondary_move_reasons-B"	pointer
,	O
worm1	int
)	O
)	O
{	O
int	O
break1	int
=	O
disconnect	function
(	O
pos3	int
,	O
worm1	int
,	O
NULL	O
)	O
;	O
int	O
break2	int
=	O
disconnect	function
(	O
pos3	int
,	O
worm2	int
,	O
NULL	O
)	O
;	O
popgo	function
(	O
)	O
;	O
if	O
(	O
!	O
break1	int
)	O
{	O
add_connection_move	function
(	O
pos	int
,	O
pos3	int
,	O
worm1	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	function
(	O
color	int
,	O
pos	int
,	O
CONNECT_MOVE	int
,	O
find_connection	function
(	O
pos3	int
,	O
worm1	int
)	O
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Connection at %1m induced for %1m/%1m due to connection at %1m/%1m\n"	pointer
,	O
pos	int
,	O
worm1	int
,	O
worm2	int
,	O
pos3	int
,	O
worm1	int
)	O
;	O
}	O
if	O
(	O
!	O
break2	int
)	O
{	O
add_connection_move	function
(	O
pos	int
,	O
pos3	int
,	O
worm2	int
)	O
;	O
do_find_more_owl_attack_and_defense_moves	function
(	O
color	int
,	O
pos	int
,	O
CONNECT_MOVE	int
,	O
find_connection	function
(	O
pos3	int
,	O
worm2	int
)	O
)	O
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"Connection at %1m induced for %1m/%1m due to connection at %1m/%1m\n"	pointer
,	O
pos	int
,	O
worm1	int
,	O
worm2	int
,	O
pos3	int
,	O
worm2	int
)	O
;	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
}	O
static	O
void	O
examine_move_safety	function
(	O
int	O
color	int
)	O
{	O
int	O
pos	int
;	O
int	O
k	int
;	O
start_timer	function
(	O
3	int
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
safety	int
=	O
0	int
;	O
int	O
tactical_safety	int
=	O
0	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
continue	O
;	O
tactical_safety	int
=	O
is_known_safe_move	function
(	O
pos	int
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
int	O
type	char
;	O
int	O
what	int
;	O
if	O
(	O
r	int
==	O
-	O
1	int
)	O
break	O
;	O
type	char
=	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
;	O
what	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
switch	O
(	O
type	char
)	O
{	O
case	O
CUT_MOVE	int
:	O
break	O
;	O
case	O
OWL_DEFEND_MOVE	int
:	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_LOSS	int
:	O
{	O
int	O
ii	int
;	O
for	O
(	O
ii	int
=	O
first_worm_in_dragon	function
(	O
what	int
)	O
;	O
ii	int
!=	O
NO_MOVE	O
;	O
ii	int
=	O
next_worm_in_dragon	function
(	O
ii	int
)	O
)	O
{	O
if	O
(	O
!	O
play_connect_n	function
(	O
color	int
,	O
0	int
,	O
1	int
,	O
pos	int
,	O
ii	int
,	O
pos	int
)	O
)	O
break	O
;	O
}	O
if	O
(	O
ii	int
!=	O
NO_MOVE	O
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
SEMEAI_MOVE	int
:	O
case	O
MY_ATARI_ATARI_MOVE	int
:	O
case	O
YOUR_ATARI_ATARI_MOVE	int
:	O
case	O
EITHER_MOVE	int
:	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
break	O
;	O
case	O
ALL_MOVE	int
:	O
break	O
;	O
case	O
EXPAND_TERRITORY_MOVE	int
:	O
case	O
EXPAND_MOYO_MOVE	int
:	O
case	O
INVASION_MOVE	int
:	O
safety	int
=	O
1	int
;	O
break	O
;	O
case	O
ATTACK_MOVE	int
:	O
case	O
ATTACK_MOVE_GOOD_KO	int
:	O
case	O
ATTACK_MOVE_BAD_KO	int
:	O
case	O
OWL_ATTACK_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_GAIN	int
:	O
{	O
int	O
aa	int
=	O
NO_MOVE	O
;	O
int	O
bb	int
=	O
NO_MOVE	O
;	O
int	O
size	int
;	O
int	O
m	int
;	O
int	O
our_color_neighbors	int
;	O
if	O
(	O
type	char
==	O
ATTACK_MOVE	int
||	O
type	char
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
type	char
==	O
ATTACK_MOVE_BAD_KO	int
)	O
{	O
aa	int
=	O
what	int
;	O
size	int
=	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
;	O
}	O
else	O
if	O
(	O
type	char
==	O
OWL_ATTACK_MOVE_GAIN	int
)	O
{	O
aa	int
=	O
either_data	array
[	O
what	int
]	O
.	O
what2	int
;	O
size	int
=	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
;	O
}	O
else	O
{	O
aa	int
=	O
what	int
;	O
size	int
=	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
;	O
}	O
if	O
(	O
size	int
>=	O
8	int
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
break	O
;	O
}	O
our_color_neighbors	int
=	O
0	int
;	O
if	O
(	O
type	char
==	O
ATTACK_MOVE	int
||	O
type	char
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
type	char
==	O
ATTACK_MOVE_BAD_KO	int
)	O
{	O
int	O
num_adj	pointer
,	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
num_adj	pointer
=	O
chainlinks	function
(	O
aa	int
,	O
adjs	array
)	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
num_adj	pointer
;	O
m	int
++	O
)	O
{	O
int	O
adj	array
=	O
adjs	array
[	O
m	int
]	O
;	O
if	O
(	O
board	pointer
[	O
adj	array
]	O
==	O
color	int
)	O
{	O
int	O
n	int
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
m	int
;	O
n	int
++	O
)	O
if	O
(	O
dragon	int
[	O
adjs	array
[	O
n	int
]	O
]	O
.	O
id	int
==	O
dragon	int
[	O
adj	array
]	O
.	O
id	int
)	O
break	O
;	O
if	O
(	O
n	int
==	O
m	int
)	O
{	O
our_color_neighbors	int
++	O
;	O
bb	int
=	O
adj	array
;	O
}	O
}	O
}	O
}	O
else	O
{	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
DRAGON2	O
(	O
aa	int
)	O
.	O
neighbors	int
;	O
m	int
++	O
)	O
if	O
(	O
DRAGON	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array
[	O
m	int
]	O
)	O
.	O
color	int
==	O
color	int
)	O
{	O
our_color_neighbors	int
++	O
;	O
bb	int
=	O
dragon2	pointer
[	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array
[	O
m	int
]	O
]	O
.	O
origin	int
;	O
if	O
(	O
dragon	int
[	O
bb	int
]	O
.	O
status	enum
==	O
ALIVE	int
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
our_color_neighbors	int
>	O
1	int
)	O
break	O
;	O
for	O
(	O
m	int
=	O
0	int
;	O
m	int
<	O
4	int
;	O
m	int
++	O
)	O
{	O
int	O
d	int
=	O
delta	array
[	O
m	int
]	O
;	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
d	int
]	O
==	O
color	int
)	O
{	O
bb	int
=	O
pos	int
+	O
d	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
bb	int
==	O
NO_MOVE	O
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
dragon	int
[	O
bb	int
]	O
.	O
status	enum
==	O
ALIVE	int
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
owl_does_defend	function
(	O
pos	int
,	O
bb	int
,	O
NULL	O
)	O
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
case	O
DEFEND_MOVE	int
:	O
case	O
DEFEND_MOVE_GOOD_KO	int
:	O
case	O
DEFEND_MOVE_BAD_KO	int
:	O
{	O
int	O
aa	int
=	O
what	int
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
==	O
ALIVE	int
)	O
safety	int
=	O
1	int
;	O
else	O
if	O
(	O
!	O
play_connect_n	function
(	O
color	int
,	O
0	int
,	O
1	int
,	O
pos	int
,	O
aa	int
,	O
pos	int
)	O
&&	O
owl_does_defend	function
(	O
pos	int
,	O
aa	int
,	O
NULL	O
)	O
)	O
safety	int
=	O
1	int
;	O
break	O
;	O
}	O
case	O
ATTACK_THREAT	O
:	O
case	O
DEFEND_THREAT	O
:	O
break	O
;	O
case	O
CONNECT_MOVE	int
:	O
{	O
int	O
worm1	int
=	O
conn_worm1	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
;	O
int	O
worm2	int
=	O
conn_worm2	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
;	O
int	O
aa	int
=	O
dragon	int
[	O
worm1	int
]	O
.	O
origin	int
;	O
int	O
bb	int
=	O
dragon	int
[	O
worm2	int
]	O
.	O
origin	int
;	O
if	O
(	O
aa	int
==	O
bb	int
)	O
continue	O
;	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
owl_status	enum
==	O
ALIVE	int
||	O
DRAGON2	O
(	O
bb	int
)	O
.	O
owl_status	enum
==	O
ALIVE	int
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
owl_status	enum
==	O
UNCHECKED	int
&&	O
dragon	int
[	O
aa	int
]	O
.	O
crude_status	function
==	O
ALIVE	int
)	O
||	O
(	O
DRAGON2	O
(	O
bb	int
)	O
.	O
owl_status	enum
==	O
UNCHECKED	int
&&	O
dragon	int
[	O
bb	int
]	O
.	O
crude_status	function
==	O
ALIVE	int
)	O
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
owl_connection_defends	function
(	O
pos	int
,	O
aa	int
,	O
bb	int
)	O
)	O
{	O
tactical_safety	int
=	O
1	int
;	O
safety	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
safety	int
==	O
1	int
&&	O
(	O
tactical_safety	int
==	O
1	int
||	O
safe_move	function
(	O
pos	int
,	O
color	int
)	O
)	O
)	O
break	O
;	O
}	O
if	O
(	O
safety	int
==	O
1	int
&&	O
(	O
tactical_safety	int
||	O
safe_move	function
(	O
pos	int
,	O
color	int
)	O
)	O
)	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
=	O
1	int
;	O
else	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
=	O
0	int
;	O
time_report	function
(	O
3	int
,	O
"    examine_move_safety: "	pointer
,	O
pos	int
,	O
1.0	int
)	O
;	O
}	O
}	O
float	O
dragon_weakness	function
(	O
int	O
dr	int
,	O
int	O
ignore_dead_dragons	int
)	O
{	O
int	O
dragon_safety	int
=	O
DRAGON2	O
(	O
dr	int
)	O
.	O
safety	int
;	O
if	O
(	O
ignore_dead_dragons	int
&&	O
(	O
dragon_safety	int
==	O
DEAD	int
||	O
dragon_safety	int
==	O
INESSENTIAL	int
||	O
dragon_safety	int
==	O
TACTICALLY_DEAD	int
)	O
)	O
return	O
0.0	int
;	O
if	O
(	O
doing_scoring	int
&&	O
dragon_safety	int
==	O
ALIVE	int
)	O
return	O
0.0	int
;	O
return	O
DRAGON2	O
(	O
dr	int
)	O
.	O
weakness	float
;	O
}	O
static	O
float	O
connection_value	function
(	O
int	O
dragona	int
,	O
int	O
dragonb	int
,	O
int	O
tt	int
,	O
float	O
margin	float
)	O
{	O
struct	O
dragon_data2	struct
*	O
da	pointer
=	O
&	O
DRAGON2	O
(	O
dragona	int
)	O
;	O
struct	O
dragon_data2	struct
*	O
db	pointer
=	O
&	O
DRAGON2	O
(	O
dragonb	int
)	O
;	O
float	O
sizea	float
=	O
da	pointer
->	O
strategic_size	float
;	O
float	O
sizeb	float
=	O
db	pointer
->	O
strategic_size	float
;	O
int	O
safetya	int
=	O
da	pointer
->	O
safety	int
;	O
int	O
safetyb	int
=	O
db	pointer
->	O
safety	int
;	O
float	O
crude_weakness_a	float
=	O
crude_dragon_weakness	function
(	O
da	pointer
->	O
safety	int
,	O
&	O
da	pointer
->	O
genus	pointer
,	O
da	pointer
->	O
lunch	int
!=	O
NO_MOVE	O
,	O
da	pointer
->	O
moyo_territorial_value	float
,	O
(	O
float	O
)	O
da	pointer
->	O
escape_route	float
)	O
;	O
float	O
crude_weakness_sum	float
;	O
struct	O
eyevalue	struct
genus_sum	struct
;	O
float	O
terr_val	float
=	O
move	pointer
[	O
tt	int
]	O
.	O
territorial_value	array
;	O
float	O
return_value	float
;	O
if	O
(	O
margin	float
>	O
20.0	int
)	O
margin	float
=	O
20.0	int
;	O
if	O
(	O
doing_scoring	int
)	O
{	O
if	O
(	O
(	O
safetya	int
==	O
ALIVE	int
||	O
safetya	int
==	O
STRONGLY_ALIVE	int
||	O
safetya	int
==	O
INVINCIBLE	int
)	O
&&	O
(	O
safetyb	int
==	O
ALIVE	int
||	O
safetyb	int
==	O
STRONGLY_ALIVE	int
||	O
safetyb	int
==	O
INVINCIBLE	int
)	O
)	O
return	O
0.0	int
;	O
}	O
if	O
(	O
safetyb	int
==	O
INESSENTIAL	int
)	O
return	O
0.0	int
;	O
if	O
(	O
crude_weakness_a	float
==	O
0.0	int
||	O
dragon	int
[	O
dragona	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
return	O
0.0	int
;	O
if	O
(	O
terr_val	float
<	O
0.0	int
)	O
terr_val	float
=	O
0.0	int
;	O
add_eyevalues	function
(	O
&	O
da	pointer
->	O
genus	pointer
,	O
&	O
db	pointer
->	O
genus	pointer
,	O
&	O
genus_sum	struct
)	O
;	O
crude_weakness_sum	float
=	O
crude_dragon_weakness	function
(	O
safetyb	int
,	O
&	O
genus_sum	struct
,	O
(	O
da	pointer
->	O
lunch	int
!=	O
NO_MOVE	O
||	O
db	pointer
->	O
lunch	int
!=	O
NO_MOVE	O
)	O
,	O
da	pointer
->	O
moyo_territorial_value	float
+	O
db	pointer
->	O
moyo_territorial_value	float
+	O
terr_val	float
,	O
(	O
float	O
)	O
da	pointer
->	O
escape_route	float
)	O
;	O
if	O
(	O
dragon	int
[	O
dragona	int
]	O
.	O
status	enum
==	O
CRITICAL	int
)	O
{	O
float	O
bonus	float
=	O
(	O
0.4	int
-	O
0.3	int
*	O
crude_weakness_sum	float
)	O
*	O
sizea	float
;	O
if	O
(	O
bonus	float
<	O
0.0	int
)	O
bonus	float
=	O
0.0	int
;	O
if	O
(	O
margin	float
>	O
0.0	int
&&	O
bonus	float
>	O
0.0	int
)	O
bonus	float
*=	O
1.0	int
+	O
0.05	int
*	O
margin	float
;	O
return_value	float
=	O
2.0	int
*	O
sizea	float
+	O
bonus	float
;	O
}	O
else	O
{	O
float	O
old_burden	float
=	O
2.0	int
*	O
crude_weakness_a	float
*	O
soft_cap	function
(	O
sizea	float
,	O
15.0	int
)	O
;	O
float	O
new_burden	float
=	O
2.0	int
*	O
crude_weakness_sum	float
*	O
soft_cap	function
(	O
sizea	float
+	O
sizeb	float
,	O
15.0	int
)	O
*	O
sizea	float
/	O
(	O
sizea	float
+	O
sizeb	float
)	O
;	O
return_value	float
=	O
1.05	int
*	O
(	O
old_burden	float
-	O
new_burden	float
)	O
;	O
if	O
(	O
margin	float
>	O
0.0	int
)	O
return_value	float
*=	O
1.0	int
+	O
0.02	int
*	O
margin	float
;	O
}	O
if	O
(	O
return_value	float
<	O
0.0	int
)	O
return_value	float
=	O
0.0	int
;	O
return	O
return_value	float
;	O
}	O
static	O
float	O
compute_shape_factor	function
(	O
int	O
pos	int
)	O
{	O
float	O
exponent	float
=	O
move	pointer
[	O
pos	int
]	O
.	O
maxpos_shape	float
-	O
move	pointer
[	O
pos	int
]	O
.	O
maxneg_shape	float
;	O
ASSERT_ON_BOARD1	O
(	O
pos	int
)	O
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
numpos_shape	int
>	O
1	int
)	O
exponent	float
+=	O
move	pointer
[	O
pos	int
]	O
.	O
numpos_shape	int
-	O
1	int
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
numneg_shape	int
>	O
1	int
)	O
exponent	float
-=	O
move	pointer
[	O
pos	int
]	O
.	O
numneg_shape	int
-	O
1	int
;	O
return	O
pow	function
(	O
1.05	int
,	O
exponent	float
)	O
;	O
}	O
static	O
float	O
adjusted_worm_attack_value	function
(	O
int	O
pos	int
,	O
int	O
ww	int
)	O
{	O
int	O
num_adj	pointer
;	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
int	O
has_live_neighbor	int
=	O
0	int
;	O
float	O
adjusted_value	float
=	O
2	int
*	O
worm	array
[	O
ww	int
]	O
.	O
effective_size	float
;	O
float	O
adjustment_up	float
=	O
0.0	int
;	O
float	O
adjustment_down	float
=	O
0.0	int
;	O
int	O
s	int
;	O
num_adj	pointer
=	O
chainlinks	function
(	O
ww	int
,	O
adjs	array
)	O
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
num_adj	pointer
;	O
s	int
++	O
)	O
{	O
int	O
adj	array
=	O
adjs	array
[	O
s	int
]	O
;	O
if	O
(	O
dragon	int
[	O
adj	array
]	O
.	O
status	enum
!=	O
DEAD	int
)	O
has_live_neighbor	int
=	O
1	int
;	O
if	O
(	O
dragon	int
[	O
adj	array
]	O
.	O
status	enum
==	O
DEAD	int
&&	O
2	int
*	O
dragon	int
[	O
adj	array
]	O
.	O
effective_size	float
>	O
adjustment_up	float
)	O
adjustment_up	float
=	O
2	int
*	O
dragon	int
[	O
adj	array
]	O
.	O
effective_size	float
;	O
if	O
(	O
worm	array
[	O
adj	array
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
!	O
does_defend	function
(	O
pos	int
,	O
adj	array
)	O
&&	O
2	int
*	O
worm	array
[	O
adj	array
]	O
.	O
effective_size	float
>	O
adjustment_down	float
)	O
adjustment_down	float
=	O
2	int
*	O
worm	array
[	O
adj	array
]	O
.	O
effective_size	float
;	O
}	O
if	O
(	O
has_live_neighbor	int
)	O
adjusted_value	float
+=	O
adjustment_up	float
;	O
adjusted_value	float
-=	O
adjustment_down	float
;	O
if	O
(	O
adjusted_value	float
>	O
0.0	int
)	O
return	O
adjusted_value	float
;	O
else	O
return	O
0.0	int
;	O
}	O
static	O
float	O
strategic_penalty	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
float	O
ret_val	float
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
4	int
;	O
k	int
++	O
)	O
if	O
(	O
board	pointer
[	O
pos	int
+	O
delta	array
[	O
k	int
]	O
]	O
==	O
EMPTY	int
&&	O
whose_area	function
(	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
pos	int
+	O
delta	array
[	O
k	int
]	O
)	O
!=	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
return	O
0.0	int
;	O
if	O
(	O
whose_area	function
(	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
pos	int
)	O
!=	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
return	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
switch	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
EXPAND_MOYO_MOVE	int
:	O
case	O
STRATEGIC_ATTACK_MOVE	int
:	O
case	O
INVASION_MOVE	int
:	O
continue	O
;	O
case	O
DEFEND_MOVE	int
:	O
{	O
int	O
target	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
dragon	int
[	O
target	int
]	O
.	O
size	int
>	O
1	int
)	O
return	O
0.0	int
;	O
continue	O
;	O
}	O
case	O
OWL_DEFEND_MOVE	int
:	O
{	O
int	O
target	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
int	O
has_strong_neighbor	int
=	O
0	int
;	O
int	O
has_weak_neighbor	int
=	O
0	int
;	O
int	O
i	int
;	O
if	O
(	O
dragon	int
[	O
target	int
]	O
.	O
size	int
>	O
1	int
||	O
worm	array
[	O
target	int
]	O
.	O
cutstone	int
>	O
0	int
||	O
worm	array
[	O
target	int
]	O
.	O
cutstone2	int
>	O
0	int
)	O
return	O
0.0	int
;	O
if	O
(	O
edge_distance	function
(	O
pos	int
)	O
<	O
3	int
)	O
return	O
0.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
4	int
;	O
i	int
++	O
)	O
if	O
(	O
board	pointer
[	O
target	int
+	O
delta	array
[	O
i	int
]	O
]	O
==	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
{	O
if	O
(	O
dragon	int
[	O
target	int
+	O
delta	array
[	O
i	int
]	O
]	O
.	O
size	int
==	O
1	int
)	O
{	O
has_weak_neighbor	int
=	O
1	int
;	O
break	O
;	O
}	O
switch	O
(	O
DRAGON2	O
(	O
target	int
+	O
delta	array
[	O
i	int
]	O
)	O
.	O
safety	int
)	O
{	O
case	O
INVINCIBLE	int
:	O
case	O
STRONGLY_ALIVE	int
:	O
has_strong_neighbor	int
=	O
1	int
;	O
break	O
;	O
case	O
ALIVE	int
:	O
if	O
(	O
DRAGON2	O
(	O
target	int
+	O
delta	array
[	O
i	int
]	O
)	O
.	O
weakness	float
>	O
0.4	int
)	O
has_weak_neighbor	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
has_weak_neighbor	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
has_weak_neighbor	int
||	O
(	O
!	O
has_strong_neighbor	int
)	O
)	O
return	O
0.0	int
;	O
else	O
continue	O
;	O
}	O
default	O
:	O
return	O
0.0	int
;	O
}	O
}	O
ret_val	float
=	O
influence_territory	function
(	O
INITIAL_INFLUENCE	O
(	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
,	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
)	O
;	O
ret_val	float
*=	O
12.0	int
;	O
ret_val	float
=	O
gg_max	O
(	O
0.0	int
,	O
ret_val	float
)	O
;	O
return	O
ret_val	float
;	O
}	O
int	O
adjacent_to_nondead_stone	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
int	O
k	int
;	O
int	O
stack	array
[	O
MAXSTACK	O
]	O
;	O
int	O
move_color	array
[	O
MAXSTACK	O
]	O
;	O
int	O
saved_stackp	int
=	O
stackp	int
;	O
int	O
result	int
=	O
0	int
;	O
while	O
(	O
stackp	int
>	O
0	int
)	O
{	O
get_move_from_stack	function
(	O
stackp	int
-	O
1	int
,	O
&	O
stack	array
[	O
stackp	int
-	O
1	int
]	O
,	O
&	O
move_color	array
[	O
stackp	int
-	O
1	int
]	O
)	O
;	O
popgo	function
(	O
)	O
;	O
}	O
if	O
(	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
NULL	O
,	O
EMPTY	int
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
12	int
;	O
k	int
++	O
)	O
{	O
int	O
pos2	int
;	O
if	O
(	O
k	int
<	O
8	int
)	O
pos2	int
=	O
pos	int
+	O
delta	array
[	O
k	int
]	O
;	O
else	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
+	O
delta	array
[	O
k	int
-	O
8	int
]	O
)	O
)	O
pos2	int
=	O
pos	int
+	O
2	int
*	O
delta	array
[	O
k	int
-	O
8	int
]	O
;	O
else	O
continue	O
;	O
if	O
(	O
ON_BOARD	O
(	O
pos2	int
)	O
&&	O
worm	array
[	O
pos2	int
]	O
.	O
color	int
==	O
color	int
&&	O
dragon	int
[	O
pos2	int
]	O
.	O
status	enum
!=	O
DEAD	int
&&	O
!	O
disconnect	function
(	O
pos	int
,	O
pos2	int
,	O
NULL	O
)	O
)	O
{	O
result	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
while	O
(	O
stackp	int
<	O
saved_stackp	int
)	O
tryko	function
(	O
stack	array
[	O
stackp	int
]	O
,	O
move_color	array
[	O
stackp	int
]	O
,	O
NULL	O
)	O
;	O
return	O
result	int
;	O
}	O
static	O
int	O
max_lunch_eye_value	function
(	O
int	O
pos	int
)	O
{	O
int	O
min	pointer
;	O
int	O
probable	pointer
;	O
int	O
max	pointer
;	O
estimate_lunch_eye_value	function
(	O
pos	int
,	O
&	O
min	pointer
,	O
&	O
probable	pointer
,	O
&	O
max	pointer
,	O
0	int
)	O
;	O
return	O
max	pointer
;	O
}	O
static	O
void	O
estimate_territorial_value	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
float	O
our_score	float
,	O
int	O
disable_delta_territory_cache	int
)	O
{	O
int	O
other	int
=	O
OTHER_COLOR	O
(	O
color	int
)	O
;	O
int	O
k	int
;	O
int	O
aa	int
=	O
NO_MOVE	O
;	O
int	O
bb	int
=	O
NO_MOVE	O
;	O
float	O
this_value	float
=	O
0.0	int
;	O
float	O
tot_value	float
=	O
0.0	int
;	O
float	O
secondary_value	float
=	O
0.0	int
;	O
int	O
does_block	int
=	O
0	int
;	O
signed	O
char	O
safe_stones	array
[	O
BOARDMAX	O
]	O
;	O
float	O
strength	array
[	O
BOARDMAX	O
]	O
;	O
set_strength_data	function
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
safe_stones	array
,	O
strength	array
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
status	enum
&	O
TERRITORY_REDUNDANT	int
)	O
continue	O
;	O
this_value	float
=	O
0.0	int
;	O
switch	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
ATTACK_MOVE	int
:	O
case	O
ATTACK_MOVE_GOOD_KO	int
:	O
case	O
ATTACK_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
aa	int
]	O
!=	O
color	int
,	O
aa	int
)	O
;	O
if	O
(	O
worm	array
[	O
aa	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f (secondary) - attack on %1m (defenseless)\n"	pointer
,	O
pos	int
,	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
secondary_value	float
+=	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
;	O
does_block	int
=	O
1	int
;	O
break	O
;	O
}	O
this_value	float
=	O
2	int
*	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f (secondary) - attack on %1m (dead)\n"	pointer
,	O
pos	int
,	O
0.2	int
*	O
this_value	float
,	O
aa	int
)	O
;	O
secondary_value	float
+=	O
0.2	int
*	O
this_value	float
;	O
does_block	int
=	O
1	int
;	O
break	O
;	O
}	O
mark_changed_string	function
(	O
aa	int
,	O
safe_stones	array
,	O
strength	array
,	O
0	int
)	O
;	O
TRACE	O
(	O
"  %1m: attack on worm %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE	int
)	O
this_value	float
=	O
0.0	int
;	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_GOOD_KO	int
)	O
{	O
this_value	float
*=	O
0.3	int
;	O
TRACE	O
(	O
"  %1m: -%f - attack on worm %1m only with good ko\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_BAD_KO	int
)	O
{	O
this_value	float
*=	O
0.5	int
;	O
TRACE	O
(	O
"  %1m: -%f - attack on worm %1m only with bad ko\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
tot_value	float
-=	O
this_value	float
;	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
DEFEND_MOVE	int
:	O
case	O
DEFEND_MOVE_GOOD_KO	int
:	O
case	O
DEFEND_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
aa	int
]	O
==	O
color	int
,	O
aa	int
)	O
;	O
this_value	float
=	O
2	int
*	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f (secondary) - defense of %1m (dead)\n"	pointer
,	O
pos	int
,	O
0.2	int
*	O
this_value	float
,	O
aa	int
)	O
;	O
secondary_value	float
+=	O
0.2	int
*	O
this_value	float
;	O
break	O
;	O
}	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
owl_status	enum
==	O
CRITICAL	int
&&	O
(	O
owl_defense_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
<	O
defense_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
)	O
&&	O
!	O
semeai_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f (secondary) - ineffective defense of %1m (critical)\n"	pointer
,	O
pos	int
,	O
0.2	int
*	O
this_value	float
,	O
aa	int
)	O
;	O
secondary_value	float
+=	O
0.2	int
*	O
this_value	float
;	O
break	O
;	O
}	O
mark_changed_string	function
(	O
aa	int
,	O
safe_stones	array
,	O
strength	array
,	O
INFLUENCE_SAVED_STONE	int
)	O
;	O
TRACE	O
(	O
"  %1m: defense of worm %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE	int
)	O
this_value	float
=	O
0.0	int
;	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_GOOD_KO	int
)	O
{	O
this_value	float
*=	O
0.3	int
;	O
TRACE	O
(	O
"  %1m: -%f - defense of worm %1m with good ko\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_BAD_KO	int
)	O
{	O
this_value	float
*=	O
0.5	int
;	O
TRACE	O
(	O
"  %1m: -%f - defense of worm %1m with bad ko\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
tot_value	float
-=	O
this_value	float
;	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
owl_status	enum
==	O
CRITICAL	int
&&	O
(	O
owl_defense_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
<	O
defense_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
)	O
)	O
{	O
this_value	float
=	O
0.45	int
*	O
(	O
2	int
*	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
TRACE	O
(	O
"  %1m: -%f - suspected ineffective defense of worm %1m\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
tot_value	float
-=	O
this_value	float
;	O
}	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
ATTACK_THREAT	O
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
aa	int
]	O
==	O
other	int
,	O
aa	int
)	O
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"    %1m: 0.0 - threatens to capture %1m (dead)\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
"estimate_territorial_value-A"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
int	O
adjs	array
[	O
MAXCHAIN	int
]	O
;	O
float	O
adjusted_value	float
=	O
2	int
*	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
;	O
float	O
adjustment_up	float
=	O
0.0	int
;	O
float	O
adjustment_down	float
=	O
0.0	int
;	O
int	O
s	int
;	O
int	O
num_adj	pointer
;	O
int	O
defense_move	int
;	O
if	O
(	O
board	pointer
[	O
aa	int
]	O
==	O
EMPTY	int
)	O
num_adj	pointer
=	O
0	int
;	O
else	O
num_adj	pointer
=	O
chainlinks	function
(	O
aa	int
,	O
adjs	array
)	O
;	O
if	O
(	O
!	O
is_known_good_attack_threat	function
(	O
pos	int
,	O
aa	int
)	O
&&	O
board	pointer
[	O
aa	int
]	O
!=	O
EMPTY	int
&&	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
==	O
1	int
||	O
adjacent_to_nondead_stone	function
(	O
pos	int
,	O
color	int
)	O
||	O
owl_defense_move_reason_known	function
(	O
pos	int
,	O
-	O
1	int
)	O
)	O
&&	O
find_defense	function
(	O
aa	int
,	O
&	O
defense_move	int
)	O
==	O
WIN	int
&&	O
defense_move	int
!=	O
NO_MOVE	O
)	O
{	O
int	O
bad_followup	int
;	O
int	O
attack_move	pointer
;	O
if	O
(	O
attack	function
(	O
pos	int
,	O
&	O
attack_move	pointer
)	O
!=	O
WIN	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
trymove	function
(	O
defense_move	int
,	O
other	int
,	O
"estimate_territorial_value-b"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
attack	function
(	O
pos	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
popgo	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
break	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAX_REASONS	int
;	O
i	int
++	O
)	O
{	O
int	O
reason	array
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
i	int
]	O
;	O
int	O
attacked_string	int
;	O
if	O
(	O
reason	array
<	O
0	int
)	O
break	O
;	O
attacked_string	int
=	O
move_reasons	array
[	O
reason	array
]	O
.	O
what	int
;	O
if	O
(	O
move_reasons	array
[	O
reason	array
]	O
.	O
type	char
==	O
ATTACK_MOVE	int
&&	O
board	pointer
[	O
attacked_string	int
]	O
==	O
other	int
)	O
{	O
int	O
defense_code	int
=	O
find_defense	function
(	O
attacked_string	int
,	O
NULL	O
)	O
;	O
double	O
down_coefficient	double
=	O
0.0	int
;	O
switch	O
(	O
defense_code	int
)	O
{	O
case	O
WIN	int
:	O
down_coefficient	double
=	O
2.0	int
;	O
break	O
;	O
case	O
KO_A	int
:	O
down_coefficient	double
=	O
2.0	int
*	O
0.5	int
;	O
break	O
;	O
case	O
KO_B	int
:	O
down_coefficient	double
=	O
2.0	int
*	O
0.7	int
;	O
break	O
;	O
}	O
if	O
(	O
adjustment_down	float
<	O
(	O
worm	array
[	O
attacked_string	int
]	O
.	O
effective_size	float
*	O
down_coefficient	double
)	O
)	O
{	O
adjustment_down	float
=	O
(	O
worm	array
[	O
attacked_string	int
]	O
.	O
effective_size	float
*	O
down_coefficient	double
)	O
;	O
}	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
trymove	function
(	O
attack_move	pointer
,	O
other	int
,	O
"estimate_territorial_value-c"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
attack	function
(	O
aa	int
,	O
NULL	O
)	O
==	O
0	int
)	O
{	O
popgo	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
break	O
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
adjustment_down	float
=	O
2	int
*	O
countstones	function
(	O
pos	int
)	O
;	O
}	O
bad_followup	int
=	O
0	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
num_adj	pointer
;	O
s	int
++	O
)	O
{	O
int	O
lib	int
;	O
if	O
(	O
countlib	function
(	O
adjs	array
[	O
s	int
]	O
)	O
==	O
1	int
)	O
{	O
findlib	function
(	O
adjs	array
[	O
s	int
]	O
,	O
1	int
,	O
&	O
lib	int
)	O
;	O
if	O
(	O
trymove	function
(	O
lib	int
,	O
other	int
,	O
"estimate_territorial_value-d"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
!	O
attack	function
(	O
aa	int
,	O
NULL	O
)	O
&&	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
attack	function
(	O
pos	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
)	O
{	O
popgo	function
(	O
)	O
;	O
bad_followup	int
=	O
1	int
;	O
break	O
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
}	O
if	O
(	O
bad_followup	int
)	O
{	O
popgo	function
(	O
)	O
;	O
break	O
;	O
}	O
}	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
num_adj	pointer
;	O
s	int
++	O
)	O
{	O
int	O
adj	array
=	O
adjs	array
[	O
s	int
]	O
;	O
if	O
(	O
same_string	function
(	O
pos	int
,	O
adj	array
)	O
)	O
continue	O
;	O
if	O
(	O
dragon	int
[	O
adj	array
]	O
.	O
color	int
==	O
color	int
&&	O
dragon	int
[	O
adj	array
]	O
.	O
status	enum
==	O
DEAD	int
&&	O
2	int
*	O
dragon	int
[	O
adj	array
]	O
.	O
effective_size	float
>	O
adjustment_up	float
)	O
adjustment_up	float
=	O
2	int
*	O
dragon	int
[	O
adj	array
]	O
.	O
effective_size	float
;	O
if	O
(	O
dragon	int
[	O
adj	array
]	O
.	O
color	int
==	O
color	int
&&	O
attack	function
(	O
adj	array
,	O
NULL	O
)	O
&&	O
2	int
*	O
worm	array
[	O
adj	array
]	O
.	O
effective_size	float
>	O
adjustment_down	float
)	O
adjustment_down	float
=	O
2	int
*	O
worm	array
[	O
adj	array
]	O
.	O
effective_size	float
;	O
}	O
popgo	function
(	O
)	O
;	O
{	O
int	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
==	O
0	int
&&	O
!	O
owl_substantial	function
(	O
aa	int
)	O
)	O
{	O
verbose	int
=	O
save_verbose	int
;	O
break	O
;	O
}	O
verbose	int
=	O
save_verbose	int
;	O
}	O
adjusted_value	float
+=	O
adjustment_up	float
;	O
adjusted_value	float
-=	O
adjustment_down	float
;	O
if	O
(	O
adjusted_value	float
>	O
0.0	int
)	O
{	O
add_followup_value	function
(	O
pos	int
,	O
adjusted_value	float
)	O
;	O
TRACE	O
(	O
"  %1m:   %f (followup) - threatens to capture %1m\n"	pointer
,	O
pos	int
,	O
adjusted_value	float
,	O
aa	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
DEFEND_THREAT	O
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
ASSERT1	O
(	O
board	pointer
[	O
aa	int
]	O
==	O
color	int
,	O
aa	int
)	O
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
"estimate_territorial_value-A"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
int	O
attack_move	pointer
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
==	O
1	int
&&	O
attack	function
(	O
aa	int
,	O
&	O
attack_move	pointer
)	O
==	O
WIN	int
&&	O
attack_move	pointer
!=	O
NO_MOVE	O
)	O
{	O
if	O
(	O
trymove	function
(	O
attack_move	pointer
,	O
other	int
,	O
"estimate_territorial_value-b"	pointer
,	O
NO_MOVE	O
)	O
)	O
{	O
if	O
(	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
||	O
attack	function
(	O
pos	int
,	O
NULL	O
)	O
!=	O
0	int
)	O
{	O
popgo	function
(	O
)	O
;	O
popgo	function
(	O
)	O
;	O
break	O
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
add_followup_value	function
(	O
pos	int
,	O
2	int
*	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
TRACE	O
(	O
"  %1m:   %f (followup) - threatens to defend %1m\n"	pointer
,	O
pos	int
,	O
2	int
*	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
UNCERTAIN_OWL_DEFENSE	int
:	O
break	O
;	O
case	O
CUT_MOVE	int
:	O
case	O
EXPAND_MOYO_MOVE	int
:	O
case	O
EXPAND_TERRITORY_MOVE	int
:	O
case	O
INVASION_MOVE	int
:	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
CONNECT_MOVE	int
:	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
)	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
STRATEGIC_ATTACK_MOVE	int
:	O
case	O
STRATEGIC_DEFEND_MOVE	int
:	O
if	O
(	O
!	O
doing_scoring	int
)	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
SEMEAI_THREAT	O
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
add_followup_value	function
(	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
TRACE	O
(	O
"  %1m: %f (followup) - threatens to win semeai for %1m\n"	pointer
,	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
SEMEAI_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE	int
:	O
case	O
OWL_ATTACK_MOVE_GOOD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_BAD_KO	int
:	O
case	O
OWL_ATTACK_MOVE_GAIN	int
:	O
case	O
OWL_DEFEND_MOVE	int
:	O
case	O
OWL_DEFEND_MOVE_GOOD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_BAD_KO	int
:	O
case	O
OWL_DEFEND_MOVE_LOSS	int
:	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_GAIN	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_LOSS	int
)	O
{	O
aa	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
bb	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
}	O
else	O
{	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
bb	int
=	O
NO_MOVE	O
;	O
}	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
size	int
==	O
1	int
&&	O
is_ko_point	function
(	O
aa	int
)	O
&&	O
liberty_of_string	function
(	O
pos	int
,	O
aa	int
)	O
)	O
{	O
TRACE	O
(	O
"  %1m: -0.5 - penalty for ko stone %1m (workaround)\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
tot_value	float
-=	O
0.5	int
;	O
}	O
mark_changed_dragon	function
(	O
pos	int
,	O
color	int
,	O
aa	int
,	O
bb	int
,	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
,	O
safe_stones	array
,	O
strength	array
,	O
&	O
this_value	float
)	O
;	O
this_value	float
*=	O
2.0	int
;	O
TRACE	O
(	O
"  %1m: owl attack/defend for %1m\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
SEMEAI_MOVE	int
)	O
this_value	float
=	O
0.0	int
;	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_GOOD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_GOOD_KO	int
)	O
{	O
this_value	float
*=	O
0.3	int
;	O
TRACE	O
(	O
"  %1m: -%f - owl attack/defense of %1m only with good ko\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_BAD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_BAD_KO	int
)	O
{	O
this_value	float
*=	O
0.5	int
;	O
TRACE	O
(	O
"  %1m: -%f - owl attack/defense of %1m only with bad ko\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_GAIN	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_DEFEND_MOVE_LOSS	int
)	O
{	O
this_value	float
=	O
0.0	int
;	O
}	O
tot_value	float
-=	O
this_value	float
;	O
if	O
(	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_GOOD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
OWL_ATTACK_MOVE_BAD_KO	int
)	O
&&	O
dragon	int
[	O
aa	int
]	O
.	O
size	int
==	O
worm	array
[	O
aa	int
]	O
.	O
size	int
&&	O
worm	array
[	O
aa	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
==	O
WIN	int
&&	O
worm	array
[	O
aa	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
attack_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
!=	O
WIN	int
)	O
{	O
if	O
(	O
large_scale	int
)	O
this_value	float
=	O
(	O
2.0	int
+	O
0.05	int
*	O
(	O
2	int
*	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
)	O
)	O
;	O
else	O
this_value	float
=	O
0.05	int
*	O
(	O
2	int
*	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
TRACE	O
(	O
"  %1m: -%f - suspected ineffective owl attack of worm %1m\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
tot_value	float
-=	O
this_value	float
;	O
}	O
does_block	int
=	O
1	int
;	O
break	O
;	O
case	O
OWL_ATTACK_THREAT	O
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"    %1m: 0.0 - threatens to owl attack %1m (dead)\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
break	O
;	O
}	O
{	O
float	O
value	pointer
=	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
;	O
int	O
s	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
DRAGON2	O
(	O
aa	int
)	O
.	O
neighbors	int
;	O
s	int
++	O
)	O
{	O
int	O
d	int
=	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array
[	O
s	int
]	O
;	O
int	O
adj	array
=	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
;	O
if	O
(	O
dragon	int
[	O
adj	array
]	O
.	O
color	int
==	O
color	int
&&	O
dragon	int
[	O
adj	array
]	O
.	O
status	enum
==	O
CRITICAL	int
&&	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
!=	O
INESSENTIAL	int
&&	O
!	O
owl_defense_move_reason_known	function
(	O
pos	int
,	O
adj	array
)	O
)	O
value	pointer
=	O
0.0	int
;	O
}	O
if	O
(	O
value	pointer
>	O
0.0	int
)	O
{	O
add_followup_value	function
(	O
pos	int
,	O
value	pointer
)	O
;	O
TRACE	O
(	O
"  %1m: %f (followup) - threatens to owl attack %1m\n"	pointer
,	O
pos	int
,	O
value	pointer
,	O
aa	int
)	O
;	O
}	O
}	O
break	O
;	O
case	O
OWL_DEFEND_THREAT	O
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
add_followup_value	function
(	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
TRACE	O
(	O
"  %1m: %f (followup) - threatens to owl defend %1m\n"	pointer
,	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
break	O
;	O
case	O
OWL_PREVENT_THREAT	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
!=	O
DEAD	int
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"    %1m: 0.0 - prevent defense threat (dragon is not dead)\n"	pointer
,	O
pos	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
!	O
doing_scoring	int
&&	O
is_same_dragon	function
(	O
get_last_opponent_move	function
(	O
color	int
)	O
,	O
aa	int
)	O
)	O
{	O
this_value	float
=	O
1.5	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
;	O
TRACE	O
(	O
"  %1m: %f - attack last move played, although it seems dead\n"	pointer
,	O
pos	int
,	O
this_value	float
)	O
;	O
tot_value	float
+=	O
this_value	float
*	O
attack_dragon_weight	float
;	O
}	O
else	O
if	O
(	O
!	O
doing_scoring	int
&&	O
our_score	float
>	O
0.0	int
)	O
{	O
this_value	float
=	O
gg_min	O
(	O
0.9	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
,	O
our_score	float
/	O
2.0	int
-	O
board_size	int
/	O
2.0	int
-	O
1.0	int
)	O
;	O
this_value	float
=	O
gg_max	O
(	O
this_value	float
,	O
0	int
)	O
;	O
TRACE	O
(	O
"  %1m: %f - attack %1m, although it seems dead, as we are ahead\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
tot_value	float
+=	O
this_value	float
*	O
attack_dragon_weight	float
;	O
}	O
else	O
{	O
add_reverse_followup_value	function
(	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
)	O
;	O
if	O
(	O
board	pointer
[	O
aa	int
]	O
==	O
color	int
)	O
TRACE	O
(	O
"  %1m: %f (reverse followup) - prevent threat to attack %1m\n"	pointer
,	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
else	O
TRACE	O
(	O
"  %1m: %f (reverse followup) - prevent threat to defend %1m\n"	pointer
,	O
pos	int
,	O
2	int
*	O
dragon	int
[	O
aa	int
]	O
.	O
effective_size	float
,	O
aa	int
)	O
;	O
}	O
break	O
;	O
case	O
MY_ATARI_ATARI_MOVE	int
:	O
this_value	float
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
+	O
1.0	int
;	O
tot_value	float
+=	O
this_value	float
;	O
TRACE	O
(	O
"  %1m: %f - combination attack kills one of several worms\n"	pointer
,	O
pos	int
,	O
this_value	float
)	O
;	O
break	O
;	O
case	O
YOUR_ATARI_ATARI_MOVE	int
:	O
does_block	int
=	O
1	int
;	O
this_value	float
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
tot_value	float
+=	O
this_value	float
;	O
TRACE	O
(	O
"  %1m: %f - defends against combination attack on several worms\n"	pointer
,	O
pos	int
,	O
this_value	float
)	O
;	O
break	O
;	O
}	O
}	O
this_value	float
=	O
0.0	int
;	O
mark_inessential_stones	function
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
safe_stones	array
)	O
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
==	O
1	int
&&	O
(	O
is_known_safe_move	function
(	O
pos	int
)	O
||	O
safe_move	function
(	O
pos	int
,	O
color	int
)	O
!=	O
0	int
)	O
)	O
{	O
safe_stones	array
[	O
pos	int
]	O
=	O
INFLUENCE_SAVED_STONE	int
;	O
strength	array
[	O
pos	int
]	O
=	O
DEFAULT_STRENGTH	int
;	O
if	O
(	O
0	int
)	O
TRACE	O
(	O
"  %1m: is a safe move\n"	pointer
,	O
pos	int
)	O
;	O
}	O
else	O
{	O
TRACE	O
(	O
"  %1m: not a safe move\n"	pointer
,	O
pos	int
)	O
;	O
safe_stones	array
[	O
pos	int
]	O
=	O
0	int
;	O
strength	array
[	O
pos	int
]	O
=	O
0.0	int
;	O
}	O
if	O
(	O
does_block	int
&&	O
tryko	function
(	O
pos	int
,	O
color	int
,	O
"estimate_territorial_value"	pointer
)	O
)	O
{	O
Hash_data	struct
safety_hash	struct
=	O
goal_to_hashvalue	function
(	O
safe_stones	array
)	O
;	O
if	O
(	O
disable_delta_territory_cache	int
||	O
!	O
retrieve_delta_territory_cache	function
(	O
pos	int
,	O
color	int
,	O
&	O
this_value	float
,	O
&	O
move	pointer
[	O
pos	int
]	O
.	O
influence_followup_value	float
,	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
safety_hash	struct
)	O
)	O
{	O
compute_influence	function
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
safe_stones	array
,	O
strength	array
,	O
&	O
move_influence	struct
,	O
pos	int
,	O
"after move"	pointer
)	O
;	O
increase_depth_values	function
(	O
)	O
;	O
break_territories	function
(	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
&	O
move_influence	struct
,	O
0	int
,	O
pos	int
)	O
;	O
decrease_depth_values	function
(	O
)	O
;	O
this_value	float
=	O
influence_delta_territory	function
(	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
&	O
move_influence	struct
,	O
color	int
,	O
pos	int
)	O
;	O
compute_followup_influence	function
(	O
&	O
move_influence	struct
,	O
&	O
followup_influence	struct
,	O
pos	int
,	O
"followup"	pointer
)	O
;	O
if	O
(	O
this_value	float
!=	O
0.0	int
)	O
TRACE	O
(	O
"%1m: %f - change in territory\n"	pointer
,	O
pos	int
,	O
this_value	float
)	O
;	O
else	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"%1m: 0.00 - change in territory\n"	pointer
,	O
pos	int
)	O
;	O
move	pointer
[	O
pos	int
]	O
.	O
influence_followup_value	float
=	O
influence_delta_territory	function
(	O
&	O
move_influence	struct
,	O
&	O
followup_influence	struct
,	O
color	int
,	O
pos	int
)	O
;	O
store_delta_territory_cache	function
(	O
pos	int
,	O
color	int
,	O
this_value	float
,	O
move	pointer
[	O
pos	int
]	O
.	O
influence_followup_value	float
,	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
safety_hash	struct
)	O
;	O
}	O
else	O
{	O
if	O
(	O
this_value	float
!=	O
0.0	int
)	O
TRACE	O
(	O
"%1m: %f - change in territory (cached)\n"	pointer
,	O
pos	int
,	O
this_value	float
)	O
;	O
else	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"%1m: 0.00 - change in territory (cached)\n"	pointer
,	O
pos	int
)	O
;	O
}	O
popgo	function
(	O
)	O
;	O
}	O
tot_value	float
+=	O
this_value	float
;	O
if	O
(	O
tot_value	float
<	O
move	pointer
[	O
pos	int
]	O
.	O
min_territory	float
&&	O
move	pointer
[	O
pos	int
]	O
.	O
min_territory	float
>	O
0	int
)	O
{	O
tot_value	float
=	O
move	pointer
[	O
pos	int
]	O
.	O
min_territory	float
;	O
TRACE	O
(	O
"  %1m:   %f - revised to meet minimum territory value\n"	pointer
,	O
pos	int
,	O
tot_value	float
)	O
;	O
}	O
if	O
(	O
tot_value	float
>	O
move	pointer
[	O
pos	int
]	O
.	O
max_territory	float
)	O
{	O
tot_value	float
=	O
move	pointer
[	O
pos	int
]	O
.	O
max_territory	float
;	O
TRACE	O
(	O
"  %1m:   %f - revised to meet maximum territory value\n"	pointer
,	O
pos	int
,	O
tot_value	float
)	O
;	O
}	O
move	pointer
[	O
pos	int
]	O
.	O
territorial_value	array
=	O
tot_value	float
;	O
move	pointer
[	O
pos	int
]	O
.	O
secondary_value	float
+=	O
secondary_value	float
;	O
}	O
static	O
void	O
estimate_strategical_value	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
float	O
our_score	float
,	O
int	O
use_thrashing_dragon_heuristics	int
)	O
{	O
int	O
k	int
;	O
int	O
l	int
;	O
int	O
aa	int
=	O
NO_MOVE	O
;	O
int	O
bb	int
=	O
NO_MOVE	O
;	O
float	O
aa_value	float
=	O
0.0	int
;	O
float	O
bb_value	float
=	O
0.0	int
;	O
float	O
this_value	float
=	O
0.0	int
;	O
float	O
tot_value	float
=	O
0.0	int
;	O
float	O
dragon_value	array
[	O
BOARDMAX	O
]	O
;	O
for	O
(	O
aa	int
=	O
BOARDMIN	O
;	O
aa	int
<	O
BOARDMAX	O
;	O
aa	int
++	O
)	O
dragon_value	array
[	O
aa	int
]	O
=	O
0.0	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
status	enum
&	O
STRATEGICALLY_REDUNDANT	int
)	O
continue	O
;	O
this_value	float
=	O
0.0	int
;	O
switch	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
ATTACK_MOVE	int
:	O
case	O
ATTACK_MOVE_GOOD_KO	int
:	O
case	O
ATTACK_MOVE_BAD_KO	int
:	O
case	O
DEFEND_MOVE	int
:	O
case	O
DEFEND_MOVE_GOOD_KO	int
:	O
case	O
DEFEND_MOVE_BAD_KO	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
worm	array
[	O
aa	int
]	O
.	O
defense_codes	array
[	O
0	int
]	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
doing_scoring	int
&&	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
break	O
;	O
if	O
(	O
worm	array
[	O
aa	int
]	O
.	O
cutstone2	int
>	O
1	int
&&	O
!	O
worm	array
[	O
aa	int
]	O
.	O
inessential	int
)	O
{	O
double	O
ko_factor	double
=	O
1	int
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_GOOD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_GOOD_KO	int
)	O
{	O
ko_factor	double
=	O
0.6	int
;	O
}	O
else	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
ATTACK_MOVE_BAD_KO	int
||	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
DEFEND_MOVE_BAD_KO	int
)	O
{	O
ko_factor	double
=	O
0.4	int
;	O
}	O
this_value	float
=	O
10.0	int
*	O
(	O
worm	array
[	O
aa	int
]	O
.	O
cutstone2	int
-	O
1	int
)	O
*	O
ko_factor	double
;	O
TRACE	O
(	O
"  %1m: %f - %1m cutstone\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
tot_value	float
+=	O
this_value	float
;	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
||	O
worm	array
[	O
aa	int
]	O
.	O
inessential	int
)	O
break	O
;	O
if	O
(	O
max_lunch_eye_value	function
(	O
aa	int
)	O
==	O
0	int
)	O
break	O
;	O
for	O
(	O
l	int
=	O
0	int
;	O
l	int
<	O
next_lunch	int
;	O
l	int
++	O
)	O
if	O
(	O
lunch_worm	array
[	O
l	int
]	O
==	O
aa	int
)	O
{	O
bb	int
=	O
lunch_dragon	array
[	O
l	int
]	O
;	O
this_value	float
=	O
1.8	int
*	O
soft_cap	function
(	O
DRAGON2	O
(	O
bb	int
)	O
.	O
strategic_size	float
,	O
15.0	int
)	O
*	O
dragon_weakness	function
(	O
bb	int
,	O
0	int
)	O
;	O
if	O
(	O
dragon	int
[	O
bb	int
]	O
.	O
status	enum
!=	O
DEAD	int
&&	O
dragon	int
[	O
bb	int
]	O
.	O
size	int
==	O
worm	array
[	O
bb	int
]	O
.	O
size	int
&&	O
(	O
attack_move_reason_known	function
(	O
pos	int
,	O
bb	int
)	O
||	O
defense_move_reason_known	function
(	O
pos	int
,	O
bb	int
)	O
)	O
)	O
this_value	float
=	O
0.0	int
;	O
if	O
(	O
worm	array
[	O
bb	int
]	O
.	O
attack_codes	array
[	O
0	int
]	O
!=	O
0	int
&&	O
(	O
(	O
color	int
==	O
board	pointer
[	O
bb	int
]	O
&&	O
!	O
does_defend	function
(	O
pos	int
,	O
bb	int
)	O
)	O
||	O
(	O
color	int
==	O
OTHER_COLOR	O
(	O
board	pointer
[	O
bb	int
]	O
)	O
&&	O
!	O
does_attack	function
(	O
pos	int
,	O
bb	int
)	O
)	O
)	O
)	O
this_value	float
=	O
0.0	int
;	O
if	O
(	O
doing_scoring	int
&&	O
move	pointer
[	O
pos	int
]	O
.	O
territorial_value	array
<	O
0.0	int
&&	O
(	O
DRAGON2	O
(	O
bb	int
)	O
.	O
safety	int
==	O
ALIVE	int
||	O
DRAGON2	O
(	O
bb	int
)	O
.	O
safety	int
==	O
STRONGLY_ALIVE	int
||	O
DRAGON2	O
(	O
bb	int
)	O
.	O
safety	int
==	O
INVINCIBLE	int
)	O
)	O
this_value	float
=	O
0.0	int
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array
[	O
bb	int
]	O
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - %1m attacked/defended\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
bb	int
)	O
;	O
dragon_value	array
[	O
bb	int
]	O
=	O
this_value	float
;	O
}	O
}	O
break	O
;	O
case	O
ATTACK_THREAT	O
:	O
case	O
DEFEND_THREAT	O
:	O
break	O
;	O
case	O
EITHER_MOVE	int
:	O
aa	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
bb	int
=	O
either_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
==	O
DEAD	int
&&	O
dragon	int
[	O
bb	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
break	O
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
MY_ATARI_ATARI_MOVE	int
,	O
-	O
1	int
)	O
)	O
break	O
;	O
aa_value	float
=	O
adjusted_worm_attack_value	function
(	O
pos	int
,	O
aa	int
)	O
;	O
bb_value	float
=	O
adjusted_worm_attack_value	function
(	O
pos	int
,	O
bb	int
)	O
;	O
this_value	float
=	O
gg_min	O
(	O
aa_value	float
,	O
bb_value	float
)	O
;	O
TRACE	O
(	O
"  %1m: %f - either attacks %1m (%f) or attacks %1m (%f)\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
,	O
aa_value	float
,	O
bb	int
,	O
bb_value	float
)	O
;	O
tot_value	float
+=	O
this_value	float
;	O
break	O
;	O
case	O
ALL_MOVE	int
:	O
aa	int
=	O
all_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what1	int
;	O
bb	int
=	O
all_data	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
what2	int
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
==	O
DEAD	int
&&	O
dragon	int
[	O
bb	int
]	O
.	O
status	enum
==	O
DEAD	int
)	O
break	O
;	O
if	O
(	O
move_reason_known	function
(	O
pos	int
,	O
YOUR_ATARI_ATARI_MOVE	int
,	O
-	O
1	int
)	O
)	O
break	O
;	O
aa_value	float
=	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
;	O
bb_value	float
=	O
worm	array
[	O
bb	int
]	O
.	O
effective_size	float
;	O
this_value	float
=	O
2	int
*	O
gg_min	O
(	O
aa_value	float
,	O
bb_value	float
)	O
;	O
TRACE	O
(	O
"  %1m: %f - both defends %1m (%f) and defends %1m (%f)\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
,	O
aa_value	float
,	O
bb	int
,	O
bb_value	float
)	O
;	O
tot_value	float
+=	O
this_value	float
;	O
break	O
;	O
case	O
CONNECT_MOVE	int
:	O
if	O
(	O
use_thrashing_dragon_heuristics	int
)	O
{	O
int	O
cc	int
;	O
aa	int
=	O
dragon	int
[	O
conn_worm1	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
]	O
.	O
origin	int
;	O
bb	int
=	O
dragon	int
[	O
conn_worm2	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
]	O
.	O
origin	int
;	O
cc	int
=	O
get_last_opponent_move	function
(	O
color	int
)	O
;	O
if	O
(	O
cc	int
!=	O
NO_MOVE	O
&&	O
thrashing_stone	array
[	O
cc	int
]	O
&&	O
are_neighbor_dragons	function
(	O
aa	int
,	O
cc	int
)	O
&&	O
are_neighbor_dragons	function
(	O
bb	int
,	O
cc	int
)	O
)	O
{	O
if	O
(	O
aa	int
==	O
bb	int
)	O
this_value	float
=	O
1.6	int
*	O
DRAGON2	O
(	O
cc	int
)	O
.	O
strategic_size	float
;	O
else	O
if	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
||	O
DRAGON2	O
(	O
bb	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
)	O
{	O
if	O
(	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
&&	O
max_lunch_eye_value	function
(	O
aa	int
)	O
==	O
0	int
)	O
||	O
(	O
DRAGON2	O
(	O
bb	int
)	O
.	O
safety	int
==	O
INESSENTIAL	int
&&	O
max_lunch_eye_value	function
(	O
bb	int
)	O
==	O
0	int
)	O
)	O
this_value	float
=	O
0.0	int
;	O
else	O
this_value	float
=	O
0.8	int
*	O
DRAGON2	O
(	O
cc	int
)	O
.	O
strategic_size	float
;	O
}	O
else	O
this_value	float
=	O
1.7	int
*	O
DRAGON2	O
(	O
cc	int
)	O
.	O
strategic_size	float
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array
[	O
dragon	int
[	O
cc	int
]	O
.	O
origin	int
]	O
)	O
{	O
dragon_value	array
[	O
dragon	int
[	O
cc	int
]	O
.	O
origin	int
]	O
=	O
this_value	float
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - connect %1m and %1m to attack thrashing dragon %1m\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
,	O
bb	int
,	O
cc	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
)	O
break	O
;	O
case	O
CUT_MOVE	int
:	O
if	O
(	O
doing_scoring	int
&&	O
!	O
move	pointer
[	O
pos	int
]	O
.	O
move_safety	int
)	O
break	O
;	O
aa	int
=	O
dragon	int
[	O
conn_worm1	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
]	O
.	O
origin	int
;	O
bb	int
=	O
dragon	int
[	O
conn_worm2	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
]	O
.	O
origin	int
;	O
if	O
(	O
aa	int
==	O
bb	int
)	O
continue	O
;	O
if	O
(	O
our_score	float
>	O
20.0	int
)	O
this_value	float
=	O
connection_value	function
(	O
aa	int
,	O
bb	int
,	O
pos	int
,	O
our_score	float
)	O
;	O
else	O
this_value	float
=	O
connection_value	function
(	O
aa	int
,	O
bb	int
,	O
pos	int
,	O
0	int
)	O
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array
[	O
aa	int
]	O
)	O
{	O
dragon_value	array
[	O
aa	int
]	O
=	O
this_value	float
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - %1m cut/connect strategic value\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
if	O
(	O
our_score	float
>	O
20.0	int
)	O
this_value	float
=	O
connection_value	function
(	O
bb	int
,	O
aa	int
,	O
pos	int
,	O
our_score	float
)	O
;	O
else	O
this_value	float
=	O
connection_value	function
(	O
bb	int
,	O
aa	int
,	O
pos	int
,	O
0	int
)	O
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array
[	O
bb	int
]	O
)	O
{	O
dragon_value	array
[	O
bb	int
]	O
=	O
this_value	float
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - %1m cut/connect strategic value\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
bb	int
)	O
;	O
}	O
break	O
;	O
case	O
SEMEAI_MOVE	int
:	O
break	O
;	O
case	O
STRATEGIC_ATTACK_MOVE	int
:	O
case	O
STRATEGIC_DEFEND_MOVE	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
if	O
(	O
use_thrashing_dragon_heuristics	int
&&	O
thrashing_stone	array
[	O
aa	int
]	O
)	O
this_value	float
=	O
1.7	int
*	O
DRAGON2	O
(	O
aa	int
)	O
.	O
strategic_size	float
;	O
else	O
this_value	float
=	O
1.8	int
*	O
soft_cap	function
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
strategic_size	float
,	O
15.0	int
)	O
*	O
dragon_weakness	function
(	O
aa	int
,	O
1	int
)	O
;	O
if	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
==	O
STRATEGIC_ATTACK_MOVE	int
)	O
{	O
int	O
s	int
;	O
for	O
(	O
s	int
=	O
0	int
;	O
s	int
<	O
DRAGON2	O
(	O
aa	int
)	O
.	O
neighbors	int
;	O
s	int
++	O
)	O
{	O
int	O
d	int
=	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array
[	O
s	int
]	O
;	O
int	O
adj	array
=	O
dragon2	pointer
[	O
d	int
]	O
.	O
origin	int
;	O
if	O
(	O
dragon	int
[	O
adj	array
]	O
.	O
color	int
==	O
color	int
&&	O
dragon	int
[	O
adj	array
]	O
.	O
status	enum
==	O
CRITICAL	int
&&	O
dragon2	pointer
[	O
d	int
]	O
.	O
safety	int
!=	O
INESSENTIAL	int
&&	O
!	O
owl_defense_move_reason_known	function
(	O
pos	int
,	O
adj	array
)	O
)	O
this_value	float
=	O
0.0	int
;	O
}	O
}	O
this_value	float
=	O
this_value	float
*	O
attack_dragon_weight	float
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array
[	O
aa	int
]	O
)	O
{	O
dragon_value	array
[	O
aa	int
]	O
=	O
this_value	float
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - %1m strategic attack/defend\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
break	O
;	O
case	O
UNCERTAIN_OWL_DEFENSE	int
:	O
aa	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
{	O
int	O
d	int
;	O
int	O
found_one	int
=	O
0	int
;	O
for	O
(	O
d	int
=	O
0	int
;	O
d	int
<	O
DRAGON2	O
(	O
aa	int
)	O
.	O
neighbors	int
;	O
d	int
++	O
)	O
if	O
(	O
DRAGON	O
(	O
DRAGON2	O
(	O
aa	int
)	O
.	O
adjacent	array
[	O
d	int
]	O
)	O
.	O
status	enum
==	O
CRITICAL	int
)	O
found_one	int
=	O
1	int
;	O
if	O
(	O
found_one	int
)	O
break	O
;	O
}	O
if	O
(	O
our_score	float
<	O
0.0	int
)	O
this_value	float
=	O
0.0	int
;	O
else	O
this_value	float
=	O
gg_min	O
(	O
2	int
*	O
DRAGON2	O
(	O
aa	int
)	O
.	O
strategic_size	float
,	O
0.65	int
*	O
our_score	float
)	O
;	O
if	O
(	O
this_value	float
>	O
dragon_value	array
[	O
aa	int
]	O
)	O
{	O
dragon_value	array
[	O
aa	int
]	O
=	O
this_value	float
;	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m:   %f - %1m uncertain owl defense bonus\n"	pointer
,	O
pos	int
,	O
this_value	float
,	O
aa	int
)	O
;	O
}	O
break	O
;	O
}	O
}	O
for	O
(	O
aa	int
=	O
BOARDMIN	O
;	O
aa	int
<	O
BOARDMAX	O
;	O
aa	int
++	O
)	O
{	O
if	O
(	O
dragon_value	array
[	O
aa	int
]	O
==	O
0.0	int
)	O
continue	O
;	O
ASSERT1	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
origin	int
==	O
aa	int
,	O
aa	int
)	O
;	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
==	O
CRITICAL	int
&&	O
!	O
owl_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
)	O
{	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"  %1m: 0.0 - disregarding strategic effect on %1m (critical dragon)\n"	pointer
,	O
pos	int
,	O
aa	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
!=	O
DEAD	int
&&	O
dragon	int
[	O
aa	int
]	O
.	O
size	int
==	O
worm	array
[	O
aa	int
]	O
.	O
size	int
&&	O
worm	array
[	O
aa	int
]	O
.	O
effective_size	float
<	O
worm	array
[	O
aa	int
]	O
.	O
size	int
+	O
2.0	int
&&	O
(	O
attack_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
||	O
defense_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
)	O
)	O
{	O
TRACE	O
(	O
"  %1m:   %f - %1m strategic value already counted - A.\n"	pointer
,	O
pos	int
,	O
dragon_value	array
[	O
aa	int
]	O
,	O
aa	int
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
attack_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
||	O
defense_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
||	O
(	O
owl_move_reason_known	function
(	O
pos	int
,	O
aa	int
)	O
&&	O
dragon	int
[	O
aa	int
]	O
.	O
status	enum
==	O
CRITICAL	int
)	O
||	O
move_reason_known	function
(	O
pos	int
,	O
SEMEAI_MOVE	int
,	O
aa	int
)	O
)	O
{	O
float	O
excess_value	float
=	O
(	O
dragon_value	array
[	O
aa	int
]	O
-	O
2	int
*	O
DRAGON2	O
(	O
aa	int
)	O
.	O
strategic_size	float
)	O
;	O
if	O
(	O
excess_value	float
>	O
0.0	int
)	O
{	O
TRACE	O
(	O
"  %1m: %f - strategic bonus for %1m\n"	pointer
,	O
pos	int
,	O
excess_value	float
,	O
aa	int
)	O
;	O
tot_value	float
+=	O
excess_value	float
;	O
}	O
else	O
{	O
TRACE	O
(	O
"  %1m:   %f - %1m strategic value already counted - B.\n"	pointer
,	O
pos	int
,	O
dragon_value	array
[	O
aa	int
]	O
,	O
aa	int
)	O
;	O
}	O
continue	O
;	O
}	O
TRACE	O
(	O
"  %1m: %f - strategic effect on %1m\n"	pointer
,	O
pos	int
,	O
dragon_value	array
[	O
aa	int
]	O
,	O
aa	int
)	O
;	O
tot_value	float
+=	O
dragon_value	array
[	O
aa	int
]	O
;	O
}	O
this_value	float
=	O
strategic_penalty	function
(	O
pos	int
,	O
color	int
)	O
;	O
this_value	float
=	O
this_value	float
*	O
invasion_malus_weight	float
;	O
if	O
(	O
this_value	float
>	O
0.0	int
)	O
{	O
TRACE	O
(	O
"  %1m: %f - strategic penalty, considered as invasion.\n"	pointer
,	O
pos	int
,	O
-	O
this_value	float
)	O
;	O
tot_value	float
-=	O
this_value	float
;	O
}	O
move	pointer
[	O
pos	int
]	O
.	O
strategical_value	float
=	O
tot_value	float
;	O
}	O
static	O
int	O
compare_move_reasons	function
(	O
const	O
void	O
*	O
p1	pointer
,	O
const	O
void	O
*	O
p2	pointer
)	O
{	O
const	O
int	O
mr1	int
=	O
*	O
(	O
const	O
int	O
*	O
)	O
p1	pointer
;	O
const	O
int	O
mr2	int
=	O
*	O
(	O
const	O
int	O
*	O
)	O
p2	pointer
;	O
if	O
(	O
move_reasons	array
[	O
mr1	int
]	O
.	O
type	char
!=	O
move_reasons	array
[	O
mr2	int
]	O
.	O
type	char
)	O
return	O
move_reasons	array
[	O
mr2	int
]	O
.	O
type	char
-	O
move_reasons	array
[	O
mr1	int
]	O
.	O
type	char
;	O
else	O
return	O
move_reasons	array
[	O
mr2	int
]	O
.	O
what	int
-	O
move_reasons	array
[	O
mr1	int
]	O
.	O
what	int
;	O
}	O
static	O
float	O
value_move_reasons	function
(	O
int	O
pos	int
,	O
int	O
color	int
,	O
float	O
pure_threat_value	float
,	O
float	O
our_score	float
,	O
int	O
use_thrashing_dragon_heuristics	int
)	O
{	O
float	O
tot_value	float
;	O
float	O
shape_factor	float
;	O
gg_assert	O
(	O
stackp	int
==	O
0	int
)	O
;	O
if	O
(	O
is_antisuji_move	function
(	O
pos	int
)	O
)	O
return	O
0.0	int
;	O
if	O
(	O
worm	array
[	O
pos	int
]	O
.	O
unconditional_status	enum
!=	O
UNKNOWN	int
)	O
return	O
0.0	int
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
0	int
]	O
>=	O
0	int
||	O
move	pointer
[	O
pos	int
]	O
.	O
min_territory	float
>	O
0.0	int
)	O
{	O
int	O
num_reasons	int
;	O
num_reasons	int
=	O
0	int
;	O
while	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
num_reasons	int
]	O
>=	O
0	int
&&	O
num_reasons	int
<	O
MAX_REASONS	int
)	O
num_reasons	int
++	O
;	O
gg_sort	function
(	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
,	O
num_reasons	int
,	O
sizeof	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
0	int
]	O
)	O
,	O
compare_move_reasons	function
)	O
;	O
discard_redundant_move_reasons	function
(	O
pos	int
)	O
;	O
estimate_territorial_value	function
(	O
pos	int
,	O
color	int
,	O
our_score	float
,	O
0	int
)	O
;	O
estimate_strategical_value	function
(	O
pos	int
,	O
color	int
,	O
our_score	float
,	O
use_thrashing_dragon_heuristics	int
)	O
;	O
}	O
tot_value	float
=	O
territorial_weight	float
*	O
move	pointer
[	O
pos	int
]	O
.	O
territorial_value	array
+	O
strategical_weight	float
*	O
move	pointer
[	O
pos	int
]	O
.	O
strategical_value	float
;	O
shape_factor	float
=	O
compute_shape_factor	function
(	O
pos	int
)	O
;	O
if	O
(	O
tot_value	float
>	O
0.0	int
)	O
{	O
int	O
c	char
;	O
float	O
followup_value	pointer
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
influence_followup_value	float
<	O
0.0	int
)	O
move	pointer
[	O
pos	int
]	O
.	O
influence_followup_value	float
=	O
0.0	int
;	O
followup_value	pointer
=	O
move	pointer
[	O
pos	int
]	O
.	O
followup_value	pointer
+	O
move	pointer
[	O
pos	int
]	O
.	O
influence_followup_value	float
;	O
TRACE	O
(	O
"  %1m:   %f - total followup value, added %f as territorial followup\n"	pointer
,	O
pos	int
,	O
followup_value	pointer
,	O
move	pointer
[	O
pos	int
]	O
.	O
influence_followup_value	float
)	O
;	O
if	O
(	O
tot_value	float
>=	O
0.5	int
)	O
{	O
float	O
old_tot_value	float
=	O
tot_value	float
;	O
float	O
contribution	float
;	O
contribution	float
=	O
gg_min	O
(	O
gg_min	O
(	O
0.5	int
*	O
followup_value	pointer
+	O
0.5	int
*	O
move	pointer
[	O
pos	int
]	O
.	O
reverse_followup_value	float
,	O
1.0	int
*	O
tot_value	float
+	O
followup_value	pointer
)	O
,	O
1.1	int
*	O
tot_value	float
+	O
move	pointer
[	O
pos	int
]	O
.	O
reverse_followup_value	float
)	O
;	O
tot_value	float
+=	O
contribution	float
*	O
followup_weight	float
;	O
if	O
(	O
contribution	float
!=	O
0.0	int
)	O
{	O
TRACE	O
(	O
"  %1m: %f - added due to followup (%f) and reverse followup values (%f)\n"	pointer
,	O
pos	int
,	O
contribution	float
,	O
followup_value	pointer
,	O
move	pointer
[	O
pos	int
]	O
.	O
reverse_followup_value	float
)	O
;	O
}	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
=	O
followup_value	pointer
+	O
move	pointer
[	O
pos	int
]	O
.	O
reverse_followup_value	float
-	O
(	O
tot_value	float
-	O
old_tot_value	float
)	O
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
<	O
0.0	int
)	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
=	O
0.0	int
;	O
}	O
else	O
{	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
=	O
shape_factor	float
*	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
followup_value	pointer
+	O
move	pointer
[	O
pos	int
]	O
.	O
reverse_followup_value	float
)	O
;	O
}	O
tot_value	float
+=	O
soft_cap	function
(	O
0.05	int
*	O
move	pointer
[	O
pos	int
]	O
.	O
secondary_value	float
,	O
0.4	int
)	O
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
secondary_value	float
!=	O
0.0	int
)	O
TRACE	O
(	O
"  %1m: %f - secondary\n"	pointer
,	O
pos	int
,	O
soft_cap	function
(	O
0.05	int
*	O
move	pointer
[	O
pos	int
]	O
.	O
secondary_value	float
,	O
0.4	int
)	O
)	O
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
numpos_shape	int
+	O
move	pointer
[	O
pos	int
]	O
.	O
numneg_shape	int
>	O
0	int
)	O
{	O
float	O
old_value	float
=	O
tot_value	float
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
territorial_value	array
<	O
15	int
)	O
tot_value	float
*=	O
shape_factor	float
;	O
else	O
{	O
float	O
non_shape_val	float
=	O
move	pointer
[	O
pos	int
]	O
.	O
territorial_value	array
-	O
15	int
;	O
tot_value	float
=	O
(	O
tot_value	float
-	O
non_shape_val	float
)	O
*	O
shape_factor	float
+	O
non_shape_val	float
;	O
}	O
if	O
(	O
verbose	int
)	O
{	O
gprintf	function
(	O
"  %1m: %f - shape "	pointer
,	O
pos	int
,	O
tot_value	float
-	O
old_value	float
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"(shape values +%4.2f(%d) -%4.2f(%d), shape factor %5.3f)\n"	pointer
,	O
move	pointer
[	O
pos	int
]	O
.	O
maxpos_shape	float
,	O
move	pointer
[	O
pos	int
]	O
.	O
numpos_shape	int
,	O
move	pointer
[	O
pos	int
]	O
.	O
maxneg_shape	float
,	O
move	pointer
[	O
pos	int
]	O
.	O
numneg_shape	int
,	O
shape_factor	float
)	O
;	O
}	O
}	O
c	char
=	O
(	O
move_connects_strings	function
(	O
pos	int
,	O
color	int
,	O
1	int
)	O
+	O
move_connects_strings	function
(	O
pos	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
0	int
)	O
)	O
;	O
if	O
(	O
c	char
>	O
0	int
)	O
{	O
float	O
shape_factor2	float
=	O
pow	function
(	O
1.02	int
,	O
(	O
float	O
)	O
c	char
)	O
-	O
1	int
;	O
float	O
base_value	float
=	O
gg_max	O
(	O
gg_min	O
(	O
tot_value	float
,	O
5.0	int
)	O
,	O
1.0	int
)	O
;	O
if	O
(	O
verbose	int
)	O
{	O
gprintf	function
(	O
"  %1m: %f - connects strings "	pointer
,	O
pos	int
,	O
base_value	float
*	O
shape_factor2	float
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"(connect value %d, shape factor %5.3f)\n"	pointer
,	O
c	char
,	O
shape_factor2	float
)	O
;	O
}	O
tot_value	float
+=	O
base_value	float
*	O
shape_factor2	float
;	O
}	O
if	O
(	O
tot_value	float
<	O
0.3	int
&&	O
(	O
move_reason_known	function
(	O
pos	int
,	O
CONNECT_MOVE	int
,	O
-	O
1	int
)	O
||	O
move_reason_known	function
(	O
pos	int
,	O
CUT_MOVE	int
,	O
-	O
1	int
)	O
)	O
)	O
{	O
float	O
old_tot_value	float
=	O
tot_value	float
;	O
tot_value	float
=	O
gg_min	O
(	O
0.3	int
,	O
tot_value	float
+	O
0.1	int
)	O
;	O
TRACE	O
(	O
"  %1m: %f - cut/connect dame bonus\n"	pointer
,	O
pos	int
,	O
tot_value	float
-	O
old_tot_value	float
)	O
;	O
}	O
}	O
else	O
{	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
=	O
shape_factor	float
*	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
followup_value	pointer
+	O
gg_min	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
followup_value	pointer
,	O
move	pointer
[	O
pos	int
]	O
.	O
reverse_followup_value	float
)	O
)	O
;	O
}	O
if	O
(	O
pure_threat_value	float
>	O
0.0	int
&&	O
move	pointer
[	O
pos	int
]	O
.	O
worthwhile_threat	int
&&	O
tot_value	float
<=	O
pure_threat_value	float
&&	O
board	pointer
[	O
pos	int
]	O
==	O
EMPTY	int
&&	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
>	O
0.0	int
&&	O
is_legal	function
(	O
pos	int
,	O
color	int
)	O
&&	O
value_moves_confirm_safety	function
(	O
pos	int
,	O
color	int
)	O
)	O
{	O
float	O
new_tot_value	float
=	O
gg_min	O
(	O
pure_threat_value	float
,	O
tot_value	float
+	O
0.25	int
*	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
)	O
;	O
new_tot_value	float
*=	O
(	O
1.0	int
-	O
0.1	int
*	O
(	O
pure_threat_value	float
-	O
tot_value	float
)	O
/	O
pure_threat_value	float
)	O
;	O
if	O
(	O
new_tot_value	float
>	O
tot_value	float
)	O
{	O
TRACE	O
(	O
"  %1m: %f - carry out threat or defend against threat\n"	pointer
,	O
pos	int
,	O
new_tot_value	float
-	O
tot_value	float
)	O
;	O
tot_value	float
=	O
new_tot_value	float
;	O
}	O
}	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
=	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
*	O
minimum_value_weight	float
;	O
move	pointer
[	O
pos	int
]	O
.	O
max_value	float
=	O
move	pointer
[	O
pos	int
]	O
.	O
max_value	float
*	O
maximum_value_weight	float
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
>	O
move	pointer
[	O
pos	int
]	O
.	O
max_value	float
)	O
move	pointer
[	O
pos	int
]	O
.	O
max_value	float
=	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
<	O
25	int
)	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
+=	O
tot_value	float
/	O
200	int
;	O
if	O
(	O
tot_value	float
<	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
&&	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
>	O
0	int
)	O
{	O
tot_value	float
=	O
move	pointer
[	O
pos	int
]	O
.	O
min_value	float
;	O
TRACE	O
(	O
"  %1m:   %f - minimum accepted value\n"	pointer
,	O
pos	int
,	O
tot_value	float
)	O
;	O
}	O
if	O
(	O
tot_value	float
>	O
move	pointer
[	O
pos	int
]	O
.	O
max_value	float
)	O
{	O
tot_value	float
=	O
move	pointer
[	O
pos	int
]	O
.	O
max_value	float
;	O
TRACE	O
(	O
"  %1m:   %f - maximum accepted value\n"	pointer
,	O
pos	int
,	O
tot_value	float
)	O
;	O
}	O
if	O
(	O
tot_value	float
>	O
0	int
||	O
move	pointer
[	O
pos	int
]	O
.	O
territorial_value	array
>	O
0	int
||	O
move	pointer
[	O
pos	int
]	O
.	O
strategical_value	float
>	O
0	int
)	O
{	O
TRACE	O
(	O
"Move generation values %1m to %f\n"	pointer
,	O
pos	int
,	O
tot_value	float
)	O
;	O
move_considered	function
(	O
pos	int
,	O
tot_value	float
)	O
;	O
}	O
return	O
tot_value	float
;	O
}	O
static	O
void	O
value_moves	function
(	O
int	O
color	int
,	O
float	O
pure_threat_value	float
,	O
float	O
our_score	float
,	O
int	O
use_thrashing_dragon_heuristics	int
)	O
{	O
int	O
m	int
,	O
n	int
;	O
int	O
pos	int
;	O
TRACE	O
(	O
"\nMove valuation:\n"	pointer
)	O
;	O
for	O
(	O
n	int
=	O
0	int
;	O
n	int
<	O
board_size	int
;	O
n	int
++	O
)	O
for	O
(	O
m	int
=	O
board_size	int
-	O
1	int
;	O
m	int
>=	O
0	int
;	O
m	int
--	O
)	O
{	O
pos	int
=	O
POS	O
(	O
m	int
,	O
n	int
)	O
;	O
move	pointer
[	O
pos	int
]	O
.	O
value	pointer
=	O
value_move_reasons	function
(	O
pos	int
,	O
color	int
,	O
pure_threat_value	float
,	O
our_score	float
,	O
use_thrashing_dragon_heuristics	int
)	O
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
value	pointer
==	O
0.0	int
)	O
continue	O
;	O
if	O
(	O
is_legal	function
(	O
pos	int
,	O
color	int
)	O
||	O
is_illegal_ko_capture	function
(	O
pos	int
,	O
color	int
)	O
)	O
{	O
move	pointer
[	O
pos	int
]	O
.	O
value	pointer
+=	O
0.01	int
*	O
move	pointer
[	O
pos	int
]	O
.	O
random_number	float
*	O
move	pointer
[	O
pos	int
]	O
.	O
randomness_scaling	float
;	O
}	O
else	O
{	O
move	pointer
[	O
pos	int
]	O
.	O
value	pointer
=	O
0.0	int
;	O
TRACE	O
(	O
"Move at %1m wasn't legal.\n"	pointer
,	O
pos	int
)	O
;	O
}	O
}	O
}	O
void	O
print_all_move_values	function
(	O
FILE	struct
*	O
output	pointer
)	O
{	O
int	O
pos	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
move	pointer
[	O
pos	int
]	O
.	O
final_value	float
<=	O
0.0	int
)	O
continue	O
;	O
gfprintf	function
(	O
output	pointer
,	O
"%1M %f\n"	pointer
,	O
pos	int
,	O
move	pointer
[	O
pos	int
]	O
.	O
final_value	float
)	O
;	O
}	O
}	O
static	O
void	O
print_top_moves	function
(	O
void	O
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
float	O
tval	float
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
;	O
k	int
++	O
)	O
{	O
best_moves	array
[	O
k	int
]	O
=	O
NO_MOVE	O
;	O
best_move_values	array
[	O
k	int
]	O
=	O
0.0	int
;	O
}	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
move	pointer
[	O
pos	int
]	O
.	O
final_value	float
<=	O
0.0	int
)	O
continue	O
;	O
tval	float
=	O
move	pointer
[	O
pos	int
]	O
.	O
final_value	float
;	O
record_top_move	function
(	O
pos	int
,	O
tval	float
)	O
;	O
}	O
if	O
(	O
verbose	int
>	O
0	int
||	O
(	O
debug	int
&	O
DEBUG_TOP_MOVES	int
)	O
)	O
{	O
gprintf	function
(	O
"\nTop moves:\n"	pointer
)	O
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
&&	O
best_move_values	array
[	O
k	int
]	O
>	O
0.0	int
;	O
k	int
++	O
)	O
gprintf	function
(	O
"%d. %1M %f\n"	pointer
,	O
k	int
+	O
1	int
,	O
best_moves	array
[	O
k	int
]	O
,	O
best_move_values	array
[	O
k	int
]	O
)	O
;	O
}	O
}	O
void	O
record_top_move	function
(	O
int	O
pos	int
,	O
float	O
val	long
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
9	int
;	O
k	int
>=	O
0	int
;	O
k	int
--	O
)	O
if	O
(	O
val	long
>	O
best_move_values	array
[	O
k	int
]	O
)	O
{	O
if	O
(	O
k	int
<	O
9	int
)	O
{	O
best_move_values	array
[	O
k	int
+	O
1	int
]	O
=	O
best_move_values	array
[	O
k	int
]	O
;	O
best_moves	array
[	O
k	int
+	O
1	int
]	O
=	O
best_moves	array
[	O
k	int
]	O
;	O
}	O
best_move_values	array
[	O
k	int
]	O
=	O
val	long
;	O
best_moves	array
[	O
k	int
]	O
=	O
pos	int
;	O
}	O
move	pointer
[	O
pos	int
]	O
.	O
final_value	float
=	O
val	long
;	O
}	O
void	O
remove_top_move	function
(	O
int	O
move	pointer
)	O
{	O
int	O
k	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
10	int
;	O
k	int
++	O
)	O
{	O
if	O
(	O
best_moves	array
[	O
k	int
]	O
==	O
move	pointer
)	O
{	O
int	O
l	int
;	O
for	O
(	O
l	int
=	O
k	int
;	O
l	int
<	O
9	int
;	O
l	int
++	O
)	O
{	O
best_moves	array
[	O
l	int
]	O
=	O
best_moves	array
[	O
l	int
+	O
1	int
]	O
;	O
best_move_values	array
[	O
l	int
]	O
=	O
best_move_values	array
[	O
l	int
+	O
1	int
]	O
;	O
}	O
best_moves	array
[	O
9	int
]	O
=	O
NO_MOVE	O
;	O
best_move_values	array
[	O
9	int
]	O
=	O
0.0	int
;	O
}	O
}	O
}	O
static	O
void	O
reevaluate_ko_threats	function
(	O
int	O
ko_move	int
,	O
int	O
color	int
,	O
float	O
ko_value	float
)	O
{	O
int	O
ko_stone	int
=	O
NO_MOVE	O
;	O
int	O
opp_ko_move	int
;	O
int	O
pos	int
;	O
int	O
k	int
;	O
int	O
type	char
,	O
what	int
;	O
int	O
threat_does_work	int
=	O
0	int
;	O
int	O
ko_move_target	int
;	O
int	O
num_good_threats	int
=	O
0	int
;	O
int	O
good_threats	array
[	O
BOARDMAX	O
]	O
;	O
int	O
best_threat_quality	int
=	O
-	O
1	int
;	O
float	O
threat_size	float
;	O
ko_move_target	int
=	O
get_biggest_owl_target	function
(	O
ko_move	int
)	O
;	O
if	O
(	O
is_illegal_ko_capture	function
(	O
ko_move	int
,	O
color	int
)	O
)	O
{	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<=	O
3	int
;	O
k	int
++	O
)	O
{	O
ko_stone	int
=	O
ko_move	int
+	O
delta	array
[	O
k	int
]	O
;	O
if	O
(	O
ON_BOARD	O
(	O
ko_stone	int
)	O
&&	O
countlib	function
(	O
ko_stone	int
)	O
==	O
1	int
)	O
break	O
;	O
}	O
ASSERT_ON_BOARD1	O
(	O
ko_stone	int
)	O
;	O
}	O
TRACE	O
(	O
"Reevaluating ko threats.\n"	pointer
)	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
int	O
threat_quality	int
=	O
0	int
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
pos	int
==	O
ko_move	int
)	O
continue	O
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
<=	O
0.0	int
)	O
continue	O
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
followup_value	pointer
<	O
ko_value	float
)	O
threat_quality	int
=	O
-	O
1	int
;	O
threat_size	float
=	O
0.0	int
;	O
type	char
=	O
-	O
1	int
;	O
what	int
=	O
-	O
1	int
;	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
MAX_REASONS	int
;	O
k	int
++	O
)	O
{	O
int	O
r	int
=	O
move	pointer
[	O
pos	int
]	O
.	O
reason	array
[	O
k	int
]	O
;	O
if	O
(	O
r	int
<	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
&	O
THREAT_BIT	int
)	O
)	O
continue	O
;	O
switch	O
(	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
)	O
{	O
case	O
ATTACK_THREAT	O
:	O
case	O
DEFEND_THREAT	O
:	O
if	O
(	O
worm	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
>	O
threat_size	float
)	O
{	O
threat_size	float
=	O
worm	array
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
;	O
type	char
=	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
;	O
what	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
}	O
break	O
;	O
case	O
OWL_ATTACK_THREAT	O
:	O
case	O
OWL_DEFEND_THREAT	O
:	O
case	O
SEMEAI_THREAT	O
:	O
if	O
(	O
dragon	int
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
>	O
threat_size	float
)	O
{	O
threat_size	float
=	O
dragon	int
[	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
]	O
.	O
effective_size	float
;	O
type	char
=	O
move_reasons	array
[	O
r	int
]	O
.	O
type	char
;	O
what	int
=	O
move_reasons	array
[	O
r	int
]	O
.	O
what	int
;	O
}	O
break	O
;	O
default	O
:	O
gg_assert	O
(	O
0	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
type	char
==	O
-	O
1	int
||	O
ko_stone	int
==	O
NO_MOVE	O
)	O
threat_does_work	int
=	O
1	int
;	O
else	O
{	O
if	O
(	O
trymove	function
(	O
pos	int
,	O
color	int
,	O
"reevaluate_ko_threats"	pointer
,	O
ko_move	int
)	O
)	O
{	O
ASSERT_ON_BOARD1	O
(	O
ko_stone	int
)	O
;	O
if	O
(	O
!	O
find_defense	function
(	O
ko_stone	int
,	O
&	O
opp_ko_move	int
)	O
)	O
threat_does_work	int
=	O
1	int
;	O
else	O
{	O
int	O
threat_wastes_point	int
=	O
0	int
;	O
if	O
(	O
whose_area	function
(	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
pos	int
)	O
!=	O
EMPTY	int
)	O
threat_wastes_point	int
=	O
1	int
;	O
if	O
(	O
trymove	function
(	O
opp_ko_move	int
,	O
OTHER_COLOR	O
(	O
color	int
)	O
,	O
"reevaluate_ko_threats"	pointer
,	O
ko_move	int
)	O
)	O
{	O
switch	O
(	O
type	char
)	O
{	O
case	O
ATTACK_THREAT	O
:	O
if	O
(	O
board	pointer
[	O
what	int
]	O
!=	O
EMPTY	int
)	O
threat_does_work	int
=	O
attack	function
(	O
what	int
,	O
NULL	O
)	O
;	O
else	O
threat_does_work	int
=	O
find_defense	function
(	O
pos	int
,	O
NULL	O
)	O
;	O
break	O
;	O
case	O
DEFEND_THREAT	O
:	O
threat_does_work	int
=	O
(	O
board	pointer
[	O
what	int
]	O
!=	O
EMPTY	int
&&	O
find_defense	function
(	O
what	int
,	O
NULL	O
)	O
)	O
;	O
break	O
;	O
case	O
OWL_ATTACK_THREAT	O
:	O
case	O
OWL_DEFEND_THREAT	O
:	O
threat_does_work	int
=	O
(	O
ko_move_target	int
!=	O
what	int
)	O
;	O
}	O
popgo	function
(	O
)	O
;	O
if	O
(	O
threat_does_work	int
&&	O
type	char
==	O
ATTACK_THREAT	O
)	O
{	O
int	O
apos	int
;	O
if	O
(	O
attack	function
(	O
pos	int
,	O
&	O
apos	int
)	O
&&	O
does_defend	function
(	O
apos	int
,	O
what	int
)	O
&&	O
(	O
forced_backfilling_moves	array
[	O
apos	int
]	O
||	O
(	O
!	O
is_proper_eye_space	function
(	O
apos	int
)	O
&&	O
!	O
false_eye_territory	array
[	O
apos	int
]	O
)	O
)	O
)	O
{	O
threat_does_work	int
=	O
0	int
;	O
}	O
}	O
if	O
(	O
ko_value	float
<	O
1.0	int
&&	O
threat_does_work	int
&&	O
threat_quality	int
>=	O
0	int
&&	O
(	O
type	char
==	O
ATTACK_THREAT	O
||	O
type	char
==	O
DEFEND_THREAT	O
)	O
)	O
{	O
int	O
averting_pos	int
;	O
if	O
(	O
type	char
==	O
ATTACK_THREAT	O
)	O
find_defense	function
(	O
what	int
,	O
&	O
averting_pos	int
)	O
;	O
else	O
attack	function
(	O
what	int
,	O
&	O
averting_pos	int
)	O
;	O
if	O
(	O
averting_pos	int
!=	O
NO_MOVE	O
)	O
{	O
int	O
averting_wastes_point	int
=	O
0	int
;	O
if	O
(	O
whose_territory	function
(	O
OPPOSITE_INFLUENCE	O
(	O
color	int
)	O
,	O
averting_pos	int
)	O
!=	O
EMPTY	int
)	O
averting_wastes_point	int
=	O
1	int
;	O
threat_quality	int
=	O
averting_wastes_point	int
-	O
threat_wastes_point	int
;	O
if	O
(	O
threat_quality	int
<	O
0	int
)	O
threat_does_work	int
=	O
0	int
;	O
}	O
}	O
}	O
}	O
popgo	function
(	O
)	O
;	O
}	O
}	O
if	O
(	O
threat_does_work	int
)	O
{	O
if	O
(	O
threat_quality	int
==	O
best_threat_quality	int
)	O
good_threats	array
[	O
num_good_threats	int
++	O
]	O
=	O
pos	int
;	O
else	O
if	O
(	O
threat_quality	int
>	O
best_threat_quality	int
)	O
{	O
best_threat_quality	int
=	O
threat_quality	int
;	O
num_good_threats	int
=	O
0	int
;	O
good_threats	array
[	O
num_good_threats	int
++	O
]	O
=	O
pos	int
;	O
}	O
else	O
DEBUG	O
(	O
DEBUG_MOVE_REASONS	int
,	O
"%1m: no additional ko value (threat does not work as ko threat)\n"	pointer
,	O
pos	int
)	O
;	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_good_threats	int
;	O
k	int
++	O
)	O
{	O
pos	int
=	O
good_threats	array
[	O
k	int
]	O
;	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
value	pointer
==	O
0.0	int
)	O
{	O
move	pointer
[	O
pos	int
]	O
.	O
value	pointer
+=	O
0.01	int
*	O
move	pointer
[	O
pos	int
]	O
.	O
random_number	float
*	O
move	pointer
[	O
pos	int
]	O
.	O
randomness_scaling	float
;	O
}	O
TRACE	O
(	O
"%1m: %f + %f = %f\n"	pointer
,	O
pos	int
,	O
move	pointer
[	O
pos	int
]	O
.	O
value	pointer
,	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
,	O
move	pointer
[	O
pos	int
]	O
.	O
value	pointer
+	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
)	O
;	O
move	pointer
[	O
pos	int
]	O
.	O
value	pointer
+=	O
move	pointer
[	O
pos	int
]	O
.	O
additional_ko_value	float
;	O
}	O
}	O
static	O
void	O
redistribute_points	function
(	O
void	O
)	O
{	O
int	O
source	int
;	O
int	O
target	int
;	O
for	O
(	O
target	int
=	O
BOARDMIN	O
;	O
target	int
<	O
BOARDMAX	O
;	O
target	int
++	O
)	O
if	O
(	O
ON_BOARD	O
(	O
target	int
)	O
)	O
move	pointer
[	O
target	int
]	O
.	O
final_value	float
=	O
move	pointer
[	O
target	int
]	O
.	O
value	pointer
;	O
for	O
(	O
source	int
=	O
BOARDMIN	O
;	O
source	int
<	O
BOARDMAX	O
;	O
source	int
++	O
)	O
{	O
if	O
(	O
!	O
ON_BOARD	O
(	O
source	int
)	O
)	O
continue	O
;	O
target	int
=	O
replacement_map	array
[	O
source	int
]	O
;	O
if	O
(	O
target	int
==	O
NO_MOVE	O
)	O
continue	O
;	O
TRACE	O
(	O
"Redistributing points from %1m to %1m.\n"	pointer
,	O
source	int
,	O
target	int
)	O
;	O
if	O
(	O
move	pointer
[	O
target	int
]	O
.	O
final_value	float
<	O
move	pointer
[	O
source	int
]	O
.	O
final_value	float
)	O
{	O
TRACE	O
(	O
"%1m is now valued %f.\n"	pointer
,	O
target	int
,	O
move	pointer
[	O
source	int
]	O
.	O
final_value	float
)	O
;	O
move	pointer
[	O
target	int
]	O
.	O
final_value	float
=	O
move	pointer
[	O
source	int
]	O
.	O
final_value	float
;	O
}	O
TRACE	O
(	O
"%1m is now valued 0.\n"	pointer
,	O
source	int
)	O
;	O
move	pointer
[	O
source	int
]	O
.	O
final_value	float
=	O
0.0	int
;	O
}	O
}	O
static	O
int	O
find_best_move	function
(	O
int	O
*	O
the_move	pointer
,	O
float	O
*	O
value	pointer
,	O
int	O
color	int
,	O
int	O
allowed_moves	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
good_move_found	int
=	O
0	int
;	O
signed	O
char	O
blunder_tested	array
[	O
BOARDMAX	O
]	O
;	O
float	O
best_value	float
=	O
0.0	int
;	O
int	O
best_move	int
=	O
NO_MOVE	O
;	O
int	O
pos	int
;	O
memset	function
(	O
blunder_tested	array
,	O
0	int
,	O
sizeof	O
(	O
blunder_tested	array
)	O
)	O
;	O
while	O
(	O
!	O
good_move_found	int
)	O
{	O
best_value	float
=	O
0.0	int
;	O
best_move	int
=	O
NO_MOVE	O
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
float	O
this_value	float
=	O
move	pointer
[	O
pos	int
]	O
.	O
final_value	float
;	O
if	O
(	O
allowed_moves	array
&&	O
!	O
allowed_moves	array
[	O
pos	int
]	O
)	O
continue	O
;	O
if	O
(	O
!	O
ON_BOARD	O
(	O
pos	int
)	O
||	O
move	pointer
[	O
pos	int
]	O
.	O
final_value	float
==	O
0.0	int
)	O
continue	O
;	O
if	O
(	O
this_value	float
>	O
best_value	float
)	O
{	O
if	O
(	O
is_legal	function
(	O
pos	int
,	O
color	int
)	O
||	O
is_illegal_ko_capture	function
(	O
pos	int
,	O
color	int
)	O
)	O
{	O
best_value	float
=	O
this_value	float
;	O
best_move	int
=	O
pos	int
;	O
}	O
else	O
{	O
TRACE	O
(	O
"Move at %1m would be suicide.\n"	pointer
,	O
pos	int
)	O
;	O
remove_top_move	function
(	O
pos	int
)	O
;	O
move	pointer
[	O
pos	int
]	O
.	O
value	pointer
=	O
0.0	int
;	O
move	pointer
[	O
pos	int
]	O
.	O
final_value	float
=	O
0.0	int
;	O
}	O
}	O
}	O
if	O
(	O
best_value	float
>	O
0.0	int
&&	O
(	O
is_illegal_ko_capture	function
(	O
best_move	int
,	O
color	int
)	O
||	O
!	O
is_allowed_move	function
(	O
best_move	int
,	O
color	int
)	O
)	O
)	O
{	O
TRACE	O
(	O
"Move at %1m would be an illegal ko capture.\n"	pointer
,	O
best_move	int
)	O
;	O
reevaluate_ko_threats	function
(	O
best_move	int
,	O
color	int
,	O
best_value	float
)	O
;	O
redistribute_points	function
(	O
)	O
;	O
time_report	function
(	O
2	int
,	O
"  reevaluate_ko_threats"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
remove_top_move	function
(	O
best_move	int
)	O
;	O
move	pointer
[	O
best_move	int
]	O
.	O
value	pointer
=	O
0.0	int
;	O
move	pointer
[	O
best_move	int
]	O
.	O
final_value	float
=	O
0.0	int
;	O
print_top_moves	function
(	O
)	O
;	O
good_move_found	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
best_value	float
>	O
0.0	int
)	O
{	O
if	O
(	O
!	O
blunder_tested	array
[	O
best_move	int
]	O
)	O
{	O
float	O
blunder_size	function
=	O
value_moves_get_blunder_size	function
(	O
best_move	int
,	O
color	int
)	O
;	O
if	O
(	O
blunder_size	function
>	O
0.0	int
)	O
{	O
TRACE	O
(	O
"Move at %1m is a blunder, subtracting %f.\n"	pointer
,	O
best_move	int
,	O
blunder_size	function
)	O
;	O
remove_top_move	function
(	O
best_move	int
)	O
;	O
move	pointer
[	O
best_move	int
]	O
.	O
value	pointer
-=	O
blunder_size	function
;	O
move	pointer
[	O
best_move	int
]	O
.	O
final_value	float
-=	O
blunder_size	function
;	O
TRACE	O
(	O
"Move at %1m is now valued %f.\n"	pointer
,	O
best_move	int
,	O
move	pointer
[	O
best_move	int
]	O
.	O
final_value	float
)	O
;	O
record_top_move	function
(	O
best_move	int
,	O
move	pointer
[	O
best_move	int
]	O
.	O
final_value	float
)	O
;	O
good_move_found	int
=	O
0	int
;	O
blunder_tested	array
[	O
best_move	int
]	O
=	O
1	int
;	O
}	O
else	O
good_move_found	int
=	O
1	int
;	O
}	O
else	O
good_move_found	int
=	O
1	int
;	O
}	O
else	O
good_move_found	int
=	O
1	int
;	O
}	O
if	O
(	O
best_value	float
>	O
0.0	int
&&	O
best_move	int
!=	O
NO_MOVE	O
)	O
{	O
*	O
the_move	pointer
=	O
best_move	int
;	O
*	O
value	pointer
=	O
best_value	float
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
review_move_reasons	function
(	O
int	O
*	O
the_move	pointer
,	O
float	O
*	O
value	pointer
,	O
int	O
color	int
,	O
float	O
pure_threat_value	float
,	O
float	O
our_score	float
,	O
int	O
allowed_moves	array
[	O
BOARDMAX	O
]	O
,	O
int	O
use_thrashing_dragon_heuristics	int
)	O
{	O
int	O
save_verbose	int
;	O
current_color	int
=	O
color	int
;	O
start_timer	function
(	O
2	int
)	O
;	O
find_more_attack_and_defense_moves	function
(	O
color	int
)	O
;	O
time_report	function
(	O
2	int
,	O
"  find_more_attack_and_defense_moves"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
if	O
(	O
get_level	function
(	O
)	O
>=	O
6	int
)	O
{	O
find_more_owl_attack_and_defense_moves	function
(	O
color	int
)	O
;	O
time_report	function
(	O
2	int
,	O
"  find_more_owl_attack_and_defense_moves"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
if	O
(	O
large_scale	int
&&	O
get_level	function
(	O
)	O
>=	O
6	int
)	O
{	O
find_large_scale_owl_attack_moves	function
(	O
color	int
)	O
;	O
time_report	function
(	O
2	int
,	O
"  find_large_scale_owl_attack_moves"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
}	O
find_more_semeai_moves	function
(	O
color	int
)	O
;	O
time_report	function
(	O
2	int
,	O
"  find_more_semeai_moves"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
save_verbose	int
=	O
verbose	int
;	O
if	O
(	O
verbose	int
>	O
0	int
)	O
verbose	int
--	O
;	O
examine_move_safety	function
(	O
color	int
)	O
;	O
time_report	function
(	O
2	int
,	O
"  examine_move_safety"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
verbose	int
=	O
save_verbose	int
;	O
induce_secondary_move_reasons	function
(	O
color	int
)	O
;	O
time_report	function
(	O
2	int
,	O
"  induce_secondary_move_reasons"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
if	O
(	O
printworms	int
||	O
verbose	int
)	O
list_move_reasons	function
(	O
stderr	pointer
,	O
NO_MOVE	O
)	O
;	O
value_moves	function
(	O
color	int
,	O
pure_threat_value	float
,	O
our_score	float
,	O
use_thrashing_dragon_heuristics	int
)	O
;	O
time_report	function
(	O
2	int
,	O
"  value_moves"	pointer
,	O
NO_MOVE	O
,	O
1.0	int
)	O
;	O
redistribute_points	function
(	O
)	O
;	O
print_top_moves	function
(	O
)	O
;	O
return	O
find_best_move	function
(	O
the_move	pointer
,	O
value	pointer
,	O
color	int
,	O
allowed_moves	array
)	O
;	O
}	O
void	O
choose_strategy	function
(	O
int	O
color	int
,	O
float	O
our_score	float
,	O
float	O
game_status	function
)	O
{	O
minimum_value_weight	float
=	O
1.0	int
;	O
maximum_value_weight	float
=	O
1.0	int
;	O
territorial_weight	float
=	O
1.0	int
;	O
strategical_weight	float
=	O
1.0	int
;	O
attack_dragon_weight	float
=	O
1.0	int
;	O
invasion_malus_weight	float
=	O
1.0	int
;	O
followup_weight	float
=	O
1.0	int
;	O
TRACE	O
(	O
"  Game status = %f (0.0 = start, 1.0 = game over)\n"	pointer
,	O
game_status	function
)	O
;	O
if	O
(	O
cosmic_gnugo	int
)	O
{	O
if	O
(	O
game_status	function
>	O
0.65	int
&&	O
our_score	float
>	O
15.0	int
)	O
{	O
minimum_value_weight	float
=	O
0.66	int
;	O
maximum_value_weight	float
=	O
2.0	int
;	O
territorial_weight	float
=	O
0.95	int
;	O
strategical_weight	float
=	O
1.0	int
;	O
attack_dragon_weight	float
=	O
1.1	int
;	O
invasion_malus_weight	float
=	O
1.3	int
;	O
followup_weight	float
=	O
1.1	int
;	O
TRACE	O
(	O
"  %s is leading, using conservative settings.\n"	pointer
,	O
color	int
==	O
WHITE	int
?	O
"White"	pointer
:	O
"Black"	pointer
)	O
;	O
}	O
else	O
if	O
(	O
game_status	function
>	O
0.16	int
)	O
{	O
minimum_value_weight	float
=	O
0.66	int
;	O
maximum_value_weight	float
=	O
2.0	int
;	O
territorial_weight	float
=	O
1.4	int
;	O
strategical_weight	float
=	O
0.5	int
;	O
attack_dragon_weight	float
=	O
0.62	int
;	O
invasion_malus_weight	float
=	O
2.0	int
;	O
followup_weight	float
=	O
0.62	int
;	O
if	O
(	O
game_status	function
>	O
0.75	int
&&	O
our_score	float
<	O
-	O
25.0	int
)	O
invasion_malus_weight	float
=	O
0.2	int
;	O
TRACE	O
(	O
"  %s is not winning enough, using aggressive settings.\n"	pointer
,	O
color	int
==	O
WHITE	int
?	O
"White"	pointer
:	O
"Black"	pointer
)	O
;	O
}	O
}	O
}	O
void	O
prepare_move_influence_debugging	function
(	O
int	O
pos	int
,	O
int	O
color	int
)	O
{	O
float	O
our_score	float
;	O
if	O
(	O
color	int
==	O
WHITE	int
)	O
our_score	float
=	O
black_score	float
;	O
else	O
our_score	float
=	O
-	O
white_score	float
;	O
estimate_territorial_value	function
(	O
pos	int
,	O
color	int
,	O
our_score	float
,	O
1	int
)	O
;	O
}	O
void	O
compute_move_probabilities	function
(	O
float	O
probabilities	array
[	O
BOARDMAX	O
]	O
)	O
{	O
int	O
k	int
;	O
int	O
pos	int
;	O
int	O
num_moves	int
=	O
0	int
;	O
int	O
moves	array
[	O
BOARDMAX	O
]	O
;	O
double	O
lower_values	array
[	O
BOARDMAX	O
]	O
;	O
double	O
upper_values	array
[	O
BOARDMAX	O
]	O
;	O
double	O
densities	array
[	O
BOARDMAX	O
]	O
;	O
double	O
common_lower_limit	double
=	O
0.0	int
;	O
for	O
(	O
pos	int
=	O
BOARDMIN	O
;	O
pos	int
<	O
BOARDMAX	O
;	O
pos	int
++	O
)	O
{	O
probabilities	array
[	O
pos	int
]	O
=	O
0.0	int
;	O
if	O
(	O
ON_BOARD	O
(	O
pos	int
)	O
)	O
{	O
if	O
(	O
move	pointer
[	O
pos	int
]	O
.	O
final_value	float
>	O
0.0	int
)	O
{	O
double	O
scale	double
=	O
0.01	int
*	O
(	O
double	O
)	O
move	pointer
[	O
pos	int
]	O
.	O
randomness_scaling	float
;	O
moves	array
[	O
num_moves	int
]	O
=	O
pos	int
;	O
lower_values	array
[	O
num_moves	int
]	O
=	O
(	O
(	O
double	O
)	O
move	pointer
[	O
pos	int
]	O
.	O
final_value	float
-	O
(	O
scale	double
*	O
move	pointer
[	O
pos	int
]	O
.	O
random_number	float
)	O
)	O
;	O
upper_values	array
[	O
num_moves	int
]	O
=	O
lower_values	array
[	O
num_moves	int
]	O
+	O
scale	double
;	O
densities	array
[	O
num_moves	int
]	O
=	O
1.0	int
/	O
scale	double
;	O
if	O
(	O
lower_values	array
[	O
num_moves	int
]	O
>	O
common_lower_limit	double
)	O
common_lower_limit	double
=	O
lower_values	array
[	O
num_moves	int
]	O
;	O
num_moves	int
++	O
;	O
}	O
}	O
}	O
for	O
(	O
k	int
=	O
0	int
;	O
k	int
<	O
num_moves	int
;	O
k	int
++	O
)	O
{	O
int	O
i	int
;	O
double	O
lower_limit	double
=	O
common_lower_limit	double
;	O
while	O
(	O
lower_limit	double
<	O
upper_values	array
[	O
k	int
]	O
)	O
{	O
int	O
j	int
;	O
double	O
upper_limit	double
=	O
upper_values	array
[	O
k	int
]	O
;	O
double	O
span_power	double
;	O
double	O
polynomial	array
[	O
BOARDMAX	O
]	O
;	O
int	O
degree	int
;	O
degree	int
=	O
0	int
;	O
polynomial	array
[	O
0	int
]	O
=	O
1.0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
upper_values	array
[	O
i	int
]	O
>	O
lower_limit	double
&&	O
upper_values	array
[	O
i	int
]	O
<	O
upper_limit	double
)	O
upper_limit	double
=	O
upper_values	array
[	O
i	int
]	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_moves	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
!=	O
k	int
&&	O
upper_values	array
[	O
i	int
]	O
>=	O
upper_limit	double
)	O
{	O
polynomial	array
[	O
++	O
degree	int
]	O
=	O
0.0	int
;	O
for	O
(	O
j	int
=	O
degree	int
;	O
j	int
>	O
0	int
;	O
j	int
--	O
)	O
{	O
polynomial	array
[	O
j	int
]	O
=	O
(	O
densities	array
[	O
i	int
]	O
*	O
(	O
polynomial	array
[	O
j	int
-	O
1	int
]	O
+	O
(	O
(	O
lower_limit	double
-	O
lower_values	array
[	O
i	int
]	O
)	O
*	O
polynomial	array
[	O
j	int
]	O
)	O
)	O
)	O
;	O
}	O
polynomial	array
[	O
0	int
]	O
*=	O
densities	array
[	O
i	int
]	O
*	O
(	O
lower_limit	double
-	O
lower_values	array
[	O
i	int
]	O
)	O
;	O
}	O
}	O
span_power	double
=	O
1.0	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<=	O
degree	int
;	O
j	int
++	O
)	O
{	O
span_power	double
*=	O
upper_limit	double
-	O
lower_limit	double
;	O
probabilities	array
[	O
moves	array
[	O
k	int
]	O
]	O
+=	O
(	O
polynomial	array
[	O
j	int
]	O
*	O
span_power	double
)	O
/	O
(	O
j	int
+	O
1	int
)	O
;	O
}	O
lower_limit	double
=	O
upper_limit	double
;	O
}	O
probabilities	array
[	O
moves	array
[	O
k	int
]	O
]	O
*=	O
densities	array
[	O
k	int
]	O
;	O
}	O
}	O
