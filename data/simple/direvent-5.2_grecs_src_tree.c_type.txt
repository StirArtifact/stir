struct	O
grecs_sockaddr_hints	pointer
*	O
grecs_sockaddr_hints	pointer
;	O
void	O
grecs_value_free_content	function
(	O
struct	O
grecs_value	struct
*	O
val	array
)	O
{	O
int	O
i	int
;	O
if	O
(	O
!	O
val	array
)	O
return	O
;	O
switch	O
(	O
val	array
->	O
type	int
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
grecs_free	function
(	O
val	array
->	O
v	pointer
.	O
string	pointer
)	O
;	O
break	O
;	O
case	O
GRECS_TYPE_LIST	int
:	O
grecs_list_free	function
(	O
val	array
->	O
v	pointer
.	O
list	pointer
)	O
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
val	array
->	O
v	pointer
.	O
arg	struct
.	O
c	long
;	O
i	int
++	O
)	O
grecs_value_free	function
(	O
val	array
->	O
v	pointer
.	O
arg	struct
.	O
v	pointer
[	O
i	int
]	O
)	O
;	O
free	function
(	O
val	array
->	O
v	pointer
.	O
arg	struct
.	O
v	pointer
)	O
;	O
}	O
}	O
void	O
grecs_value_free	function
(	O
struct	O
grecs_value	struct
*	O
val	array
)	O
{	O
grecs_value_free_content	function
(	O
val	array
)	O
;	O
grecs_free	function
(	O
val	array
)	O
;	O
}	O
const	O
char	O
*	O
grecs_value_type_string	function
(	O
int	O
t	int
)	O
{	O
static	O
const	O
char	O
*	O
types	array
[	O
]	O
=	O
{	O
[	O
GRECS_TYPE_STRING	int
]	O
=	O
N_	O
(	O
"string"	pointer
)	O
,	O
[	O
GRECS_TYPE_LIST	int
]	O
=	O
N_	O
(	O
"list"	pointer
)	O
,	O
[	O
GRECS_TYPE_ARRAY	int
]	O
=	O
N_	O
(	O
"one or more arguments"	pointer
)	O
}	O
;	O
if	O
(	O
t	int
>=	O
0	int
&&	O
t	int
<	O
sizeof	O
(	O
types	array
)	O
/	O
sizeof	O
(	O
types	array
[	O
0	int
]	O
)	O
)	O
return	O
types	array
[	O
t	int
]	O
;	O
return	O
N_	O
(	O
"unrecognized type; please report"	pointer
)	O
;	O
}	O
struct	O
grecs_node	struct
*	O
grecs_node_create	function
(	O
enum	O
grecs_node_type	enum
type	int
,	O
grecs_locus_t	struct
*	O
loc	pointer
)	O
{	O
struct	O
grecs_node	struct
*	O
np	pointer
=	O
grecs_zalloc	function
(	O
sizeof	O
(	O
*	O
np	pointer
)	O
)	O
;	O
np	pointer
->	O
type	int
=	O
type	int
;	O
if	O
(	O
loc	pointer
)	O
np	pointer
->	O
locus	struct
=	O
*	O
loc	pointer
;	O
return	O
np	pointer
;	O
}	O
struct	O
grecs_node	struct
*	O
grecs_node_create_points	function
(	O
enum	O
grecs_node_type	enum
type	int
,	O
struct	O
grecs_locus_point	struct
beg	struct
,	O
struct	O
grecs_locus_point	struct
end	struct
)	O
{	O
grecs_locus_t	struct
loc	pointer
;	O
loc	pointer
.	O
beg	struct
=	O
beg	struct
;	O
loc	pointer
.	O
end	struct
=	O
end	struct
;	O
return	O
grecs_node_create	function
(	O
type	int
,	O
&	O
loc	pointer
)	O
;	O
}	O
void	O
grecs_node_bind	function
(	O
struct	O
grecs_node	struct
*	O
master	pointer
,	O
struct	O
grecs_node	struct
*	O
node	pointer
,	O
int	O
dn	int
)	O
{	O
struct	O
grecs_node	struct
*	O
np	pointer
;	O
if	O
(	O
!	O
node	pointer
)	O
return	O
;	O
if	O
(	O
dn	int
)	O
{	O
if	O
(	O
!	O
master	pointer
->	O
down	pointer
)	O
{	O
master	pointer
->	O
down	pointer
=	O
node	pointer
;	O
node	pointer
->	O
prev	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
for	O
(	O
np	pointer
=	O
master	pointer
->	O
down	pointer
;	O
np	pointer
->	O
next	pointer
;	O
np	pointer
=	O
np	pointer
->	O
next	pointer
)	O
;	O
np	pointer
->	O
next	pointer
=	O
node	pointer
;	O
node	pointer
->	O
prev	pointer
=	O
np	pointer
;	O
}	O
for	O
(	O
;	O
node	pointer
;	O
node	pointer
=	O
node	pointer
->	O
next	pointer
)	O
node	pointer
->	O
up	pointer
=	O
master	pointer
;	O
}	O
else	O
{	O
if	O
(	O
!	O
master	pointer
->	O
next	pointer
)	O
{	O
master	pointer
->	O
next	pointer
=	O
node	pointer
;	O
node	pointer
->	O
prev	pointer
=	O
master	pointer
;	O
}	O
else	O
{	O
for	O
(	O
np	pointer
=	O
master	pointer
->	O
next	pointer
;	O
np	pointer
->	O
next	pointer
;	O
np	pointer
=	O
np	pointer
->	O
next	pointer
)	O
;	O
np	pointer
->	O
next	pointer
=	O
node	pointer
;	O
node	pointer
->	O
prev	pointer
=	O
np	pointer
;	O
}	O
node	pointer
->	O
up	pointer
=	O
master	pointer
->	O
up	pointer
;	O
}	O
}	O
int	O
grecs_node_unlink	function
(	O
struct	O
grecs_node	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
node	pointer
->	O
prev	pointer
)	O
node	pointer
->	O
prev	pointer
->	O
next	pointer
=	O
node	pointer
->	O
next	pointer
;	O
else	O
if	O
(	O
node	pointer
->	O
up	pointer
)	O
node	pointer
->	O
up	pointer
->	O
down	pointer
=	O
node	pointer
->	O
next	pointer
;	O
else	O
return	O
1	int
;	O
if	O
(	O
node	pointer
->	O
next	pointer
)	O
node	pointer
->	O
next	pointer
->	O
prev	pointer
=	O
node	pointer
->	O
prev	pointer
;	O
node	pointer
->	O
up	pointer
=	O
node	pointer
->	O
prev	pointer
=	O
node	pointer
->	O
next	pointer
=	O
NULL	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
listel_dispose	function
(	O
void	O
*	O
el	pointer
)	O
{	O
grecs_free	function
(	O
el	pointer
)	O
;	O
}	O
struct	O
grecs_list	struct
*	O
_grecs_simple_list_create	function
(	O
int	O
dispose	int
)	O
{	O
struct	O
grecs_list	struct
*	O
lp	pointer
=	O
grecs_list_create	function
(	O
)	O
;	O
if	O
(	O
dispose	int
)	O
lp	pointer
->	O
free_entry	pointer
=	O
listel_dispose	function
;	O
return	O
lp	pointer
;	O
}	O
static	O
enum	O
grecs_tree_recurse_res	enum
_tree_recurse	function
(	O
struct	O
grecs_node	struct
*	O
node	pointer
,	O
grecs_tree_recursor_t	pointer
recfun	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
enum	O
grecs_tree_recurse_res	enum
res	enum
;	O
while	O
(	O
node	pointer
)	O
{	O
struct	O
grecs_node	struct
*	O
next	pointer
=	O
node	pointer
->	O
next	pointer
;	O
if	O
(	O
node	pointer
->	O
type	int
==	O
grecs_node_stmt	int
)	O
{	O
res	enum
=	O
recfun	pointer
(	O
grecs_tree_recurse_set	int
,	O
node	pointer
,	O
data	pointer
)	O
;	O
CKRES	O
(	O
)	O
;	O
}	O
else	O
{	O
switch	O
(	O
recfun	pointer
(	O
grecs_tree_recurse_pre	int
,	O
node	pointer
,	O
data	pointer
)	O
)	O
{	O
case	O
grecs_tree_recurse_ok	int
:	O
res	enum
=	O
_tree_recurse	function
(	O
node	pointer
->	O
down	pointer
,	O
recfun	pointer
,	O
data	pointer
)	O
;	O
CKRES	O
(	O
)	O
;	O
res	enum
=	O
recfun	pointer
(	O
grecs_tree_recurse_post	int
,	O
node	pointer
,	O
data	pointer
)	O
;	O
CKRES	O
(	O
)	O
;	O
break	O
;	O
case	O
grecs_tree_recurse_fail	int
:	O
return	O
grecs_tree_recurse_fail	int
;	O
case	O
grecs_tree_recurse_stop	int
:	O
return	O
grecs_tree_recurse_stop	int
;	O
case	O
grecs_tree_recurse_skip	int
:	O
break	O
;	O
}	O
}	O
node	pointer
=	O
next	pointer
;	O
}	O
return	O
grecs_tree_recurse_ok	int
;	O
}	O
int	O
grecs_tree_recurse	function
(	O
struct	O
grecs_node	struct
*	O
node	pointer
,	O
grecs_tree_recursor_t	pointer
recfun	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
switch	O
(	O
_tree_recurse	function
(	O
node	pointer
,	O
recfun	pointer
,	O
data	pointer
)	O
)	O
{	O
case	O
grecs_tree_recurse_ok	int
:	O
case	O
grecs_tree_recurse_stop	int
:	O
return	O
0	int
;	O
default	O
:	O
break	O
;	O
}	O
return	O
1	int
;	O
}	O
void	O
grecs_node_free	function
(	O
struct	O
grecs_node	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
!	O
node	pointer
)	O
return	O
;	O
switch	O
(	O
node	pointer
->	O
type	int
)	O
{	O
case	O
grecs_node_root	int
:	O
grecs_symtab_free	function
(	O
node	pointer
->	O
v	pointer
.	O
texttab	pointer
)	O
;	O
break	O
;	O
default	O
:	O
grecs_value_free	function
(	O
node	pointer
->	O
v	pointer
.	O
value	pointer
)	O
;	O
}	O
grecs_free	function
(	O
node	pointer
->	O
ident	pointer
)	O
;	O
grecs_free	function
(	O
node	pointer
)	O
;	O
}	O
static	O
enum	O
grecs_tree_recurse_res	enum
freeproc	function
(	O
enum	O
grecs_tree_recurse_op	enum
op	enum
,	O
struct	O
grecs_node	struct
*	O
node	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
switch	O
(	O
op	enum
)	O
{	O
case	O
grecs_tree_recurse_set	int
:	O
case	O
grecs_tree_recurse_post	int
:	O
grecs_node_unlink	function
(	O
node	pointer
)	O
;	O
grecs_node_free	function
(	O
node	pointer
)	O
;	O
break	O
;	O
case	O
grecs_tree_recurse_pre	int
:	O
break	O
;	O
}	O
return	O
grecs_tree_recurse_ok	int
;	O
}	O
int	O
grecs_tree_free	function
(	O
struct	O
grecs_node	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
!	O
node	pointer
)	O
return	O
0	int
;	O
if	O
(	O
node	pointer
->	O
type	int
!=	O
grecs_node_root	int
)	O
{	O
errno	O
=	O
EINVAL	int
;	O
return	O
1	int
;	O
}	O
grecs_tree_recurse	function
(	O
node	pointer
,	O
freeproc	function
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
fake_callback	function
(	O
enum	O
grecs_callback_command	enum
cmd	enum
,	O
grecs_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
varptr	pointer
,	O
void	O
*	O
cb_data	pointer
)	O
{	O
return	O
0	int
;	O
}	O
static	O
struct	O
grecs_keyword	struct
fake	struct
=	O
{	O
"*"	pointer
,	O
NULL	O
,	O
NULL	O
,	O
grecs_type_void	int
,	O
GRECS_DFLT	int
,	O
NULL	O
,	O
0	int
,	O
fake_callback	function
,	O
NULL	O
,	O
&	O
fake	struct
}	O
;	O
static	O
struct	O
grecs_keyword	struct
*	O
find_keyword	function
(	O
struct	O
grecs_keyword	struct
*	O
cursect	pointer
,	O
grecs_node_t	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
cursect	pointer
&&	O
cursect	pointer
->	O
kwd	pointer
&&	O
cursect	pointer
!=	O
&	O
fake	struct
)	O
{	O
struct	O
grecs_keyword	struct
*	O
found	pointer
=	O
NULL	O
,	O
*	O
kwp	pointer
;	O
char	O
const	O
*	O
msg	pointer
;	O
for	O
(	O
kwp	pointer
=	O
cursect	pointer
->	O
kwd	pointer
;	O
kwp	pointer
->	O
ident	pointer
;	O
kwp	pointer
++	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
kwp	pointer
->	O
ident	pointer
,	O
node	pointer
->	O
ident	pointer
)	O
==	O
0	int
)	O
{	O
found	pointer
=	O
kwp	pointer
;	O
if	O
(	O
kwp	pointer
->	O
callback	pointer
||	O
(	O
node	pointer
->	O
down	pointer
?	O
kwp	pointer
->	O
type	int
==	O
grecs_type_section	int
:	O
kwp	pointer
->	O
type	int
!=	O
grecs_type_section	int
)	O
)	O
return	O
kwp	pointer
;	O
}	O
}	O
if	O
(	O
found	pointer
)	O
{	O
if	O
(	O
found	pointer
->	O
type	int
==	O
grecs_type_section	int
)	O
{	O
msg	pointer
=	O
N_	O
(	O
"section keyword used as a scalar"	pointer
)	O
;	O
}	O
else	O
{	O
msg	pointer
=	O
N_	O
(	O
"scalar keyword used as a section"	pointer
)	O
;	O
}	O
}	O
else	O
{	O
msg	pointer
=	O
N_	O
(	O
"unknown keyword"	pointer
)	O
;	O
}	O
grecs_error	function
(	O
&	O
node	pointer
->	O
idloc	struct
,	O
0	int
,	O
"%s"	pointer
,	O
gettext	function
(	O
msg	pointer
)	O
)	O
;	O
}	O
else	O
{	O
return	O
&	O
fake	struct
;	O
}	O
return	O
NULL	O
;	O
}	O
static	O
void	O
*	O
target_ptr	function
(	O
struct	O
grecs_keyword	struct
*	O
kwp	pointer
,	O
char	O
*	O
base	pointer
)	O
{	O
if	O
(	O
kwp	pointer
->	O
varptr	pointer
)	O
base	pointer
=	O
(	O
char	O
*	O
)	O
kwp	pointer
->	O
varptr	pointer
+	O
kwp	pointer
->	O
offset	long
;	O
else	O
if	O
(	O
base	pointer
)	O
base	pointer
+=	O
kwp	pointer
->	O
offset	long
;	O
return	O
base	pointer
;	O
}	O
static	O
int	O
string_to_bool	function
(	O
const	O
char	O
*	O
string	pointer
,	O
int	O
*	O
pval	pointer
,	O
grecs_locus_t	struct
const	O
*	O
locus	struct
)	O
{	O
if	O
(	O
strcmp	function
(	O
string	pointer
,	O
"yes"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
string	pointer
,	O
"true"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
string	pointer
,	O
"t"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
string	pointer
,	O
"1"	pointer
)	O
==	O
0	int
)	O
*	O
pval	pointer
=	O
1	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
string	pointer
,	O
"no"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
string	pointer
,	O
"false"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
string	pointer
,	O
"nil"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
string	pointer
,	O
"0"	pointer
)	O
==	O
0	int
)	O
*	O
pval	pointer
=	O
0	int
;	O
else	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"%s: not a valid boolean value"	pointer
)	O
,	O
string	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
string_to_host	function
(	O
struct	O
in_addr	struct
*	O
in	pointer
,	O
const	O
char	O
*	O
string	pointer
,	O
grecs_locus_t	struct
const	O
*	O
locus	struct
)	O
{	O
if	O
(	O
inet_aton	function
(	O
string	pointer
,	O
in	pointer
)	O
==	O
0	int
)	O
{	O
struct	O
hostent	struct
*	O
hp	pointer
;	O
hp	pointer
=	O
gethostbyname	function
(	O
string	pointer
)	O
;	O
if	O
(	O
hp	pointer
==	O
NULL	O
)	O
return	O
1	int
;	O
memcpy	function
(	O
in	pointer
,	O
hp	pointer
->	O
h_addr	O
,	O
sizeof	O
(	O
struct	O
in_addr	struct
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
string_to_sockaddr	function
(	O
struct	O
grecs_sockaddr	struct
*	O
sp	pointer
,	O
const	O
char	O
*	O
string	pointer
,	O
grecs_locus_t	struct
const	O
*	O
locus	struct
)	O
{	O
if	O
(	O
string	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
struct	O
sockaddr_un	struct
s_un	struct
;	O
if	O
(	O
strlen	function
(	O
string	pointer
)	O
>=	O
sizeof	O
(	O
s_un	struct
.	O
sun_path	array
)	O
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"%s: UNIX socket name too long"	pointer
)	O
,	O
string	pointer
)	O
;	O
return	O
1	int
;	O
}	O
s_un	struct
.	O
sun_family	short
=	O
AF_UNIX	O
;	O
strcpy	function
(	O
s_un	struct
.	O
sun_path	array
,	O
string	pointer
)	O
;	O
sp	pointer
->	O
len	long
=	O
sizeof	O
(	O
s_un	struct
)	O
;	O
sp	pointer
->	O
sa	pointer
=	O
grecs_malloc	function
(	O
sp	pointer
->	O
len	long
)	O
;	O
memcpy	function
(	O
sp	pointer
->	O
sa	pointer
,	O
&	O
s_un	struct
,	O
sp	pointer
->	O
len	long
)	O
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
=	O
strchr	function
(	O
string	pointer
,	O
':'	O
)	O
;	O
size_t	long
len	long
;	O
struct	O
sockaddr_in	struct
sa	pointer
;	O
sa	pointer
.	O
sin_family	short
=	O
AF_INET	O
;	O
if	O
(	O
p	pointer
)	O
len	long
=	O
p	pointer
-	O
string	pointer
;	O
else	O
len	long
=	O
strlen	function
(	O
string	pointer
)	O
;	O
if	O
(	O
len	long
==	O
0	int
)	O
sa	pointer
.	O
sin_addr	struct
.	O
s_addr	int
=	O
INADDR_ANY	O
;	O
else	O
{	O
char	O
*	O
host	pointer
=	O
grecs_malloc	function
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
host	pointer
,	O
string	pointer
,	O
len	long
)	O
;	O
host	pointer
[	O
len	long
]	O
=	O
0	int
;	O
if	O
(	O
string_to_host	function
(	O
&	O
sa	pointer
.	O
sin_addr	struct
,	O
host	pointer
,	O
locus	struct
)	O
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"%s: not a valid IP address or hostname"	pointer
)	O
,	O
host	pointer
)	O
;	O
grecs_free	function
(	O
host	pointer
)	O
;	O
return	O
1	int
;	O
}	O
grecs_free	function
(	O
host	pointer
)	O
;	O
}	O
if	O
(	O
p	pointer
)	O
{	O
struct	O
servent	struct
*	O
serv	pointer
;	O
p	pointer
++	O
;	O
serv	pointer
=	O
getservbyname	function
(	O
p	pointer
,	O
"tcp"	pointer
)	O
;	O
if	O
(	O
serv	pointer
!=	O
NULL	O
)	O
sa	pointer
.	O
sin_port	short
=	O
serv	pointer
->	O
s_port	int
;	O
else	O
{	O
unsigned	O
long	O
l	long
;	O
char	O
*	O
q	pointer
;	O
l	long
=	O
strtoul	function
(	O
p	pointer
,	O
&	O
q	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
q	pointer
||	O
l	long
>	O
USHRT_MAX	O
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"%s: not a valid port number"	pointer
)	O
,	O
p	pointer
)	O
;	O
return	O
1	int
;	O
}	O
sa	pointer
.	O
sin_port	short
=	O
htons	function
(	O
l	long
)	O
;	O
}	O
}	O
else	O
if	O
(	O
grecs_default_port	int
)	O
sa	pointer
.	O
sin_port	short
=	O
grecs_default_port	int
;	O
else	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"missing port number"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
sp	pointer
->	O
len	long
=	O
sizeof	O
(	O
sa	pointer
)	O
;	O
sp	pointer
->	O
sa	pointer
=	O
grecs_malloc	function
(	O
sp	pointer
->	O
len	long
)	O
;	O
memcpy	function
(	O
sp	pointer
->	O
sa	pointer
,	O
&	O
sa	pointer
,	O
sp	pointer
->	O
len	long
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
grecs_string_convert	function
(	O
void	O
*	O
target	pointer
,	O
enum	O
grecs_data_type	enum
type	int
,	O
const	O
char	O
*	O
string	pointer
,	O
grecs_locus_t	struct
const	O
*	O
locus	struct
)	O
{	O
switch	O
(	O
type	int
)	O
{	O
case	O
grecs_type_void	int
:	O
abort	function
(	O
)	O
;	O
case	O
grecs_type_null	int
:	O
break	O
;	O
case	O
grecs_type_string	int
:	O
*	O
(	O
char	O
*	O
*	O
)	O
target	pointer
=	O
grecs_strdup	function
(	O
string	pointer
)	O
;	O
break	O
;	O
case	O
grecs_type_short	int
:	O
GETUNUM	O
(	O
string	pointer
,	O
short	O
,	O
*	O
(	O
short	O
*	O
)	O
target	pointer
,	O
locus	struct
)	O
;	O
break	O
;	O
case	O
grecs_type_ushort	int
:	O
GETUNUM	O
(	O
string	pointer
,	O
unsigned	O
short	O
,	O
*	O
(	O
unsigned	O
short	O
*	O
)	O
target	pointer
,	O
locus	struct
)	O
;	O
break	O
;	O
case	O
grecs_type_bool	int
:	O
return	O
string_to_bool	function
(	O
string	pointer
,	O
(	O
int	O
*	O
)	O
target	pointer
,	O
locus	struct
)	O
;	O
case	O
grecs_type_int	int
:	O
GETSNUM	O
(	O
string	pointer
,	O
int	O
,	O
*	O
(	O
int	O
*	O
)	O
target	pointer
,	O
locus	struct
)	O
;	O
break	O
;	O
case	O
grecs_type_uint	int
:	O
GETUNUM	O
(	O
string	pointer
,	O
unsigned	O
int	O
,	O
*	O
(	O
unsigned	O
int	O
*	O
)	O
target	pointer
,	O
locus	struct
)	O
;	O
break	O
;	O
case	O
grecs_type_long	int
:	O
GETSNUM	O
(	O
string	pointer
,	O
long	O
,	O
*	O
(	O
long	O
*	O
)	O
target	pointer
,	O
locus	struct
)	O
;	O
break	O
;	O
case	O
grecs_type_ulong	int
:	O
GETUNUM	O
(	O
string	pointer
,	O
unsigned	O
long	O
,	O
*	O
(	O
unsigned	O
long	O
*	O
)	O
target	pointer
,	O
locus	struct
)	O
;	O
break	O
;	O
case	O
grecs_type_size	int
:	O
GETUNUM	O
(	O
string	pointer
,	O
size_t	long
,	O
*	O
(	O
size_t	long
*	O
)	O
target	pointer
,	O
locus	struct
)	O
;	O
break	O
;	O
case	O
grecs_type_time	int
:	O
GETUNUM	O
(	O
string	pointer
,	O
time_t	long
,	O
*	O
(	O
time_t	long
*	O
)	O
target	pointer
,	O
locus	struct
)	O
;	O
break	O
;	O
case	O
grecs_type_ipv4	int
:	O
if	O
(	O
inet_aton	function
(	O
string	pointer
,	O
(	O
struct	O
in_addr	struct
*	O
)	O
target	pointer
)	O
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"%s: not a valid IP address"	pointer
)	O
,	O
string	pointer
)	O
;	O
return	O
1	int
;	O
}	O
break	O
;	O
case	O
grecs_type_host	int
:	O
if	O
(	O
string_to_host	function
(	O
(	O
struct	O
in_addr	struct
*	O
)	O
target	pointer
,	O
string	pointer
,	O
locus	struct
)	O
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"%s: not a valid IP address or hostname"	pointer
)	O
,	O
string	pointer
)	O
;	O
return	O
1	int
;	O
}	O
break	O
;	O
case	O
grecs_type_sockaddr	int
:	O
return	O
string_to_sockaddr	function
(	O
(	O
struct	O
grecs_sockaddr	struct
*	O
)	O
target	pointer
,	O
string	pointer
,	O
locus	struct
)	O
;	O
case	O
grecs_type_cidr	int
:	O
return	O
grecs_str_to_cidr	function
(	O
(	O
struct	O
grecs_cidr	struct
*	O
)	O
target	pointer
,	O
string	pointer
,	O
locus	struct
)	O
;	O
case	O
grecs_type_section	int
:	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"invalid use of block statement"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
struct	O
grecs_prop	struct
{	O
size_t	long
size	pointer
;	O
int	O
(	O
*	O
cmp	pointer
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
;	O
}	O
;	O
static	O
int	O
string_cmp	function
(	O
const	O
void	O
*	O
elt1	pointer
,	O
const	O
void	O
*	O
elt2	pointer
)	O
{	O
return	O
strcmp	function
(	O
(	O
const	O
char	O
*	O
)	O
elt1	pointer
,	O
(	O
const	O
char	O
*	O
)	O
elt2	pointer
)	O
;	O
}	O
DECL_NUMCMP	O
(	O
short	O
)	O
DECL_NUMCMP	O
(	O
int	O
)	O
DECL_NUMCMP	O
(	O
long	O
)	O
DECL_NUMCMP	O
(	O
size_t	long
)	O
DECL_NUMCMP	O
(	O
time_t	long
)	O
__DECL_NUMCMP	O
(	O
in_addr	struct
,	O
struct	O
in_addr	struct
)	O
__DECL_NUMCMP	O
(	O
grecs_sockaddr	struct
,	O
struct	O
grecs_sockaddr	struct
)	O
static	O
int	O
cidr_cmp	function
(	O
const	O
void	O
*	O
elt1	pointer
,	O
const	O
void	O
*	O
elt2	pointer
)	O
{	O
struct	O
grecs_cidr	struct
const	O
*	O
cp1	pointer
=	O
elt1	pointer
,	O
*	O
cp2	pointer
=	O
elt2	pointer
;	O
return	O
!	O
(	O
cp1	pointer
->	O
family	int
==	O
cp2	pointer
->	O
family	int
&&	O
cp1	pointer
->	O
len	long
==	O
cp2	pointer
->	O
len	long
&&	O
memcmp	function
(	O
cp1	pointer
->	O
address	array
,	O
cp2	pointer
->	O
address	array
,	O
cp1	pointer
->	O
len	long
)	O
==	O
0	int
&&	O
memcmp	function
(	O
cp1	pointer
->	O
netmask	array
,	O
cp2	pointer
->	O
netmask	array
,	O
cp1	pointer
->	O
len	long
)	O
==	O
0	int
)	O
;	O
}	O
struct	O
grecs_prop	struct
grecs_prop_tab	array
[	O
]	O
=	O
{	O
{	O
0	int
,	O
NULL	O
}	O
,	O
{	O
sizeof	O
(	O
char	O
*	O
)	O
,	O
string_cmp	function
}	O
,	O
{	O
sizeof	O
(	O
short	O
)	O
,	O
NUMCMP	O
(	O
short	O
)	O
}	O
,	O
{	O
sizeof	O
(	O
unsigned	O
short	O
)	O
,	O
NUMCMP	O
(	O
short	O
)	O
}	O
,	O
{	O
sizeof	O
(	O
int	O
)	O
,	O
NUMCMP	O
(	O
int	O
)	O
}	O
,	O
{	O
sizeof	O
(	O
unsigned	O
int	O
)	O
,	O
NUMCMP	O
(	O
int	O
)	O
}	O
,	O
{	O
sizeof	O
(	O
long	O
)	O
,	O
NUMCMP	O
(	O
long	O
)	O
}	O
,	O
{	O
sizeof	O
(	O
unsigned	O
long	O
)	O
,	O
NUMCMP	O
(	O
long	O
)	O
}	O
,	O
{	O
sizeof	O
(	O
size_t	long
)	O
,	O
NUMCMP	O
(	O
size_t	long
)	O
}	O
,	O
{	O
sizeof	O
(	O
time_t	long
)	O
,	O
NUMCMP	O
(	O
time_t	long
)	O
}	O
,	O
{	O
sizeof	O
(	O
int	O
)	O
,	O
NUMCMP	O
(	O
int	O
)	O
}	O
,	O
{	O
sizeof	O
(	O
struct	O
in_addr	struct
)	O
,	O
NUMCMP	O
(	O
in_addr	struct
)	O
}	O
,	O
{	O
sizeof	O
(	O
struct	O
grecs_cidr	struct
)	O
,	O
cidr_cmp	function
}	O
,	O
{	O
sizeof	O
(	O
struct	O
in_addr	struct
)	O
,	O
NUMCMP	O
(	O
in_addr	struct
)	O
}	O
,	O
{	O
sizeof	O
(	O
struct	O
grecs_sockaddr	struct
)	O
,	O
NUMCMP	O
(	O
grecs_sockaddr	struct
)	O
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
,	O
{	O
0	int
,	O
NULL	O
}	O
}	O
;	O
void	O
grecs_process_ident	function
(	O
struct	O
grecs_keyword	struct
*	O
kwp	pointer
,	O
grecs_value_t	struct
*	O
value	pointer
,	O
void	O
*	O
base	pointer
,	O
grecs_locus_t	struct
*	O
locus	struct
)	O
{	O
void	O
*	O
target	pointer
;	O
if	O
(	O
!	O
kwp	pointer
)	O
return	O
;	O
target	pointer
=	O
target_ptr	function
(	O
kwp	pointer
,	O
(	O
char	O
*	O
)	O
base	pointer
)	O
;	O
if	O
(	O
kwp	pointer
->	O
callback	pointer
)	O
{	O
struct	O
grecs_node	struct
node	pointer
=	O
{	O
0	int
}	O
;	O
node	pointer
.	O
locus	struct
=	O
*	O
locus	struct
;	O
node	pointer
.	O
v	pointer
.	O
value	pointer
=	O
value	pointer
;	O
node	pointer
.	O
ident	pointer
=	O
(	O
char	O
*	O
)	O
kwp	pointer
->	O
ident	pointer
;	O
kwp	pointer
->	O
callback	pointer
(	O
grecs_callback_set_value	int
,	O
&	O
node	pointer
,	O
target	pointer
,	O
&	O
kwp	pointer
->	O
callback_data	pointer
)	O
;	O
}	O
else	O
if	O
(	O
kwp	pointer
->	O
type	int
==	O
grecs_type_void	int
||	O
target	pointer
==	O
NULL	O
)	O
return	O
;	O
else	O
if	O
(	O
!	O
value	pointer
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
"%s has no value"	pointer
,	O
kwp	pointer
->	O
ident	pointer
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
value	pointer
->	O
type	int
==	O
GRECS_TYPE_ARRAY	int
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"too many arguments to `%s'; missing semicolon?"	pointer
)	O
,	O
kwp	pointer
->	O
ident	pointer
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
value	pointer
->	O
type	int
==	O
GRECS_TYPE_LIST	int
)	O
{	O
if	O
(	O
kwp	pointer
->	O
flags	int
&	O
GRECS_LIST	int
)	O
{	O
struct	O
grecs_list_entry	struct
*	O
ep	pointer
;	O
enum	O
grecs_data_type	enum
type	int
=	O
kwp	pointer
->	O
type	int
;	O
int	O
num	int
=	O
1	int
;	O
struct	O
grecs_list	struct
*	O
list	pointer
;	O
size_t	long
size	pointer
;	O
if	O
(	O
type	int
>=	O
grecs_prop_count	O
||	O
(	O
size	pointer
=	O
grecs_prop_tab	array
[	O
type	int
]	O
.	O
size	pointer
)	O
==	O
0	int
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: "	pointer
"unhandled data type %d"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
type	int
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
list	pointer
=	O
_grecs_simple_list_create	function
(	O
type	int
==	O
grecs_type_string	int
)	O
;	O
list	pointer
->	O
cmp	pointer
=	O
grecs_prop_tab	array
[	O
type	int
]	O
.	O
cmp	pointer
;	O
for	O
(	O
ep	pointer
=	O
value	pointer
->	O
v	pointer
.	O
list	pointer
->	O
head	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
{	O
const	O
grecs_value_t	struct
*	O
vp	pointer
=	O
ep	pointer
->	O
data	pointer
;	O
if	O
(	O
vp	pointer
->	O
type	int
!=	O
GRECS_TYPE_STRING	int
)	O
grecs_error	function
(	O
&	O
vp	pointer
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"%s: incompatible data type in list item #%d"	pointer
)	O
,	O
kwp	pointer
->	O
ident	pointer
,	O
num	int
)	O
;	O
else	O
if	O
(	O
type	int
==	O
grecs_type_string	int
)	O
grecs_list_append	function
(	O
list	pointer
,	O
grecs_strdup	function
(	O
vp	pointer
->	O
v	pointer
.	O
string	pointer
)	O
)	O
;	O
else	O
{	O
void	O
*	O
ptr	pointer
=	O
grecs_malloc	function
(	O
size	pointer
)	O
;	O
if	O
(	O
grecs_string_convert	function
(	O
ptr	pointer
,	O
type	int
,	O
vp	pointer
->	O
v	pointer
.	O
string	pointer
,	O
&	O
vp	pointer
->	O
locus	struct
)	O
==	O
0	int
)	O
grecs_list_append	function
(	O
list	pointer
,	O
ptr	pointer
)	O
;	O
else	O
grecs_free	function
(	O
ptr	pointer
)	O
;	O
}	O
}	O
*	O
(	O
struct	O
grecs_list	struct
*	O
*	O
)	O
target	pointer
=	O
list	pointer
;	O
}	O
else	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"incompatible data type for `%s'"	pointer
)	O
,	O
kwp	pointer
->	O
ident	pointer
)	O
;	O
return	O
;	O
}	O
}	O
else	O
if	O
(	O
kwp	pointer
->	O
flags	int
&	O
GRECS_LIST	int
)	O
{	O
struct	O
grecs_list	struct
*	O
list	pointer
;	O
enum	O
grecs_data_type	enum
type	int
=	O
kwp	pointer
->	O
type	int
;	O
size_t	long
size	pointer
;	O
void	O
*	O
ptr	pointer
;	O
if	O
(	O
type	int
>=	O
grecs_prop_count	O
||	O
(	O
size	pointer
=	O
grecs_prop_tab	array
[	O
type	int
]	O
.	O
size	pointer
)	O
==	O
0	int
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"INTERNAL ERROR at %s:%d: unhandled data type %d"	pointer
)	O
,	O
__FILE__	O
,	O
__LINE__	O
,	O
type	int
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
list	pointer
=	O
_grecs_simple_list_create	function
(	O
1	int
)	O
;	O
list	pointer
->	O
cmp	pointer
=	O
grecs_prop_tab	array
[	O
type	int
]	O
.	O
cmp	pointer
;	O
if	O
(	O
type	int
==	O
grecs_type_string	int
)	O
grecs_list_append	function
(	O
list	pointer
,	O
grecs_strdup	function
(	O
value	pointer
->	O
v	pointer
.	O
string	pointer
)	O
)	O
;	O
else	O
{	O
ptr	pointer
=	O
grecs_malloc	function
(	O
size	pointer
)	O
;	O
if	O
(	O
grecs_string_convert	function
(	O
ptr	pointer
,	O
type	int
,	O
value	pointer
->	O
v	pointer
.	O
string	pointer
,	O
&	O
value	pointer
->	O
locus	struct
)	O
)	O
{	O
grecs_free	function
(	O
ptr	pointer
)	O
;	O
grecs_list_free	function
(	O
list	pointer
)	O
;	O
return	O
;	O
}	O
grecs_list_append	function
(	O
list	pointer
,	O
ptr	pointer
)	O
;	O
}	O
*	O
(	O
struct	O
grecs_list	struct
*	O
*	O
)	O
target	pointer
=	O
list	pointer
;	O
}	O
else	O
{	O
if	O
(	O
kwp	pointer
->	O
type	int
==	O
grecs_type_string	int
&&	O
!	O
(	O
kwp	pointer
->	O
flags	int
&	O
GRECS_CONST	int
)	O
)	O
free	function
(	O
*	O
(	O
char	O
*	O
*	O
)	O
target	pointer
)	O
;	O
grecs_string_convert	function
(	O
target	pointer
,	O
kwp	pointer
->	O
type	int
,	O
value	pointer
->	O
v	pointer
.	O
string	pointer
,	O
&	O
value	pointer
->	O
locus	struct
)	O
;	O
}	O
kwp	pointer
->	O
flags	int
&=	O
~	O
GRECS_CONST	int
;	O
}	O
struct	O
nodeproc_closure	struct
{	O
struct	O
grecs_keyword	struct
*	O
cursect	pointer
;	O
struct	O
grecs_list	struct
*	O
sections	pointer
;	O
int	O
flags	int
;	O
}	O
;	O
static	O
void	O
stmt_begin	function
(	O
struct	O
nodeproc_closure	struct
*	O
clos	pointer
,	O
struct	O
grecs_keyword	struct
*	O
kwp	pointer
,	O
struct	O
grecs_node	struct
*	O
node	pointer
)	O
{	O
void	O
*	O
target	pointer
;	O
grecs_list_push	function
(	O
clos	pointer
->	O
sections	pointer
,	O
clos	pointer
->	O
cursect	pointer
)	O
;	O
if	O
(	O
kwp	pointer
)	O
{	O
target	pointer
=	O
target_ptr	function
(	O
kwp	pointer
,	O
CURRENT_BASE	O
(	O
clos	pointer
)	O
)	O
;	O
clos	pointer
->	O
cursect	pointer
=	O
kwp	pointer
;	O
if	O
(	O
kwp	pointer
->	O
callback	pointer
)	O
{	O
if	O
(	O
kwp	pointer
->	O
callback	pointer
(	O
grecs_callback_section_begin	int
,	O
node	pointer
,	O
target	pointer
,	O
&	O
kwp	pointer
->	O
callback_data	pointer
)	O
)	O
clos	pointer
->	O
cursect	pointer
=	O
&	O
fake	struct
;	O
}	O
else	O
kwp	pointer
->	O
callback_data	pointer
=	O
target	pointer
;	O
}	O
else	O
clos	pointer
->	O
cursect	pointer
=	O
kwp	pointer
;	O
}	O
static	O
void	O
stmt_end	function
(	O
struct	O
nodeproc_closure	struct
*	O
clos	pointer
,	O
struct	O
grecs_node	struct
*	O
node	pointer
)	O
{	O
grecs_callback_fn	pointer
callback	pointer
=	O
NULL	O
;	O
void	O
*	O
dataptr	pointer
=	O
NULL	O
;	O
struct	O
grecs_keyword	struct
*	O
kwp	pointer
=	O
clos	pointer
->	O
cursect	pointer
;	O
if	O
(	O
clos	pointer
->	O
cursect	pointer
&&	O
clos	pointer
->	O
cursect	pointer
->	O
callback	pointer
)	O
{	O
callback	pointer
=	O
clos	pointer
->	O
cursect	pointer
->	O
callback	pointer
;	O
dataptr	pointer
=	O
&	O
clos	pointer
->	O
cursect	pointer
->	O
callback_data	pointer
;	O
}	O
clos	pointer
->	O
cursect	pointer
=	O
(	O
struct	O
grecs_keyword	struct
*	O
)	O
grecs_list_pop	function
(	O
clos	pointer
->	O
sections	pointer
)	O
;	O
if	O
(	O
!	O
clos	pointer
->	O
cursect	pointer
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
callback	pointer
)	O
callback	pointer
(	O
grecs_callback_section_end	int
,	O
node	pointer
,	O
kwp	pointer
?	O
target_ptr	function
(	O
kwp	pointer
,	O
CURRENT_BASE	O
(	O
clos	pointer
)	O
)	O
:	O
NULL	O
,	O
dataptr	pointer
)	O
;	O
if	O
(	O
kwp	pointer
)	O
kwp	pointer
->	O
callback_data	pointer
=	O
NULL	O
;	O
}	O
static	O
enum	O
grecs_tree_recurse_res	enum
nodeproc	function
(	O
enum	O
grecs_tree_recurse_op	enum
op	enum
,	O
struct	O
grecs_node	struct
*	O
node	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
nodeproc_closure	struct
*	O
clos	pointer
=	O
data	pointer
;	O
struct	O
grecs_keyword	struct
*	O
kwp	pointer
;	O
switch	O
(	O
op	enum
)	O
{	O
case	O
grecs_tree_recurse_set	int
:	O
kwp	pointer
=	O
find_keyword	function
(	O
clos	pointer
->	O
cursect	pointer
,	O
node	pointer
)	O
;	O
if	O
(	O
!	O
kwp	pointer
)	O
return	O
grecs_tree_recurse_skip	int
;	O
grecs_process_ident	function
(	O
kwp	pointer
,	O
node	pointer
->	O
v	pointer
.	O
value	pointer
,	O
CURRENT_BASE	O
(	O
clos	pointer
)	O
,	O
&	O
node	pointer
->	O
idloc	struct
)	O
;	O
break	O
;	O
case	O
grecs_tree_recurse_pre	int
:	O
kwp	pointer
=	O
find_keyword	function
(	O
clos	pointer
->	O
cursect	pointer
,	O
node	pointer
)	O
;	O
if	O
(	O
!	O
kwp	pointer
)	O
return	O
grecs_tree_recurse_skip	int
;	O
stmt_begin	function
(	O
clos	pointer
,	O
kwp	pointer
,	O
node	pointer
)	O
;	O
break	O
;	O
case	O
grecs_tree_recurse_post	int
:	O
stmt_end	function
(	O
clos	pointer
,	O
node	pointer
)	O
;	O
break	O
;	O
}	O
return	O
grecs_tree_recurse_ok	int
;	O
}	O
int	O
grecs_tree_process	function
(	O
struct	O
grecs_node	struct
*	O
node	pointer
,	O
struct	O
grecs_keyword	struct
*	O
kwd	pointer
)	O
{	O
int	O
rc	int
;	O
struct	O
nodeproc_closure	struct
clos	pointer
;	O
struct	O
grecs_keyword	struct
config_keywords	struct
;	O
memset	function
(	O
&	O
config_keywords	struct
,	O
0	int
,	O
sizeof	O
(	O
config_keywords	struct
)	O
)	O
;	O
config_keywords	struct
.	O
kwd	pointer
=	O
kwd	pointer
;	O
clos	pointer
.	O
cursect	pointer
=	O
&	O
config_keywords	struct
;	O
clos	pointer
.	O
sections	pointer
=	O
grecs_list_create	function
(	O
)	O
;	O
if	O
(	O
node	pointer
->	O
type	int
==	O
grecs_node_root	int
)	O
node	pointer
=	O
node	pointer
->	O
down	pointer
;	O
rc	int
=	O
grecs_tree_recurse	function
(	O
node	pointer
,	O
nodeproc	function
,	O
&	O
clos	pointer
)	O
;	O
grecs_list_free	function
(	O
clos	pointer
.	O
sections	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
grecs_node_eq	function
(	O
struct	O
grecs_node	struct
*	O
a	pointer
,	O
struct	O
grecs_node	struct
*	O
b	pointer
)	O
{	O
if	O
(	O
a	pointer
->	O
type	int
!=	O
b	pointer
->	O
type	int
)	O
return	O
1	int
;	O
if	O
(	O
a	pointer
->	O
type	int
==	O
grecs_node_root	int
)	O
return	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
a	pointer
->	O
ident	pointer
,	O
b	pointer
->	O
ident	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
a	pointer
->	O
type	int
==	O
grecs_node_block	int
&&	O
!	O
grecs_value_eq	function
(	O
a	pointer
->	O
v	pointer
.	O
value	pointer
,	O
b	pointer
->	O
v	pointer
.	O
value	pointer
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
free_value_entry	function
(	O
void	O
*	O
ptr	pointer
)	O
{	O
struct	O
grecs_value	struct
*	O
v	pointer
=	O
ptr	pointer
;	O
grecs_value_free	function
(	O
v	pointer
)	O
;	O
}	O
struct	O
grecs_list	struct
*	O
grecs_value_list_create	function
(	O
)	O
{	O
struct	O
grecs_list	struct
*	O
list	pointer
=	O
grecs_list_create	function
(	O
)	O
;	O
list	pointer
->	O
free_entry	pointer
=	O
free_value_entry	function
;	O
return	O
list	pointer
;	O
}	O
static	O
void	O
value_to_list	function
(	O
struct	O
grecs_value	struct
*	O
val	array
)	O
{	O
struct	O
grecs_list	struct
*	O
list	pointer
;	O
int	O
i	int
;	O
if	O
(	O
val	array
->	O
type	int
==	O
GRECS_TYPE_LIST	int
)	O
return	O
;	O
list	pointer
=	O
grecs_value_list_create	function
(	O
)	O
;	O
switch	O
(	O
val	array
->	O
type	int
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
grecs_list_append	function
(	O
list	pointer
,	O
grecs_value_ptr_from_static	function
(	O
val	array
)	O
)	O
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
val	array
->	O
v	pointer
.	O
arg	struct
.	O
c	long
;	O
i	int
++	O
)	O
grecs_list_append	function
(	O
list	pointer
,	O
val	array
->	O
v	pointer
.	O
arg	struct
.	O
v	pointer
[	O
i	int
]	O
)	O
;	O
}	O
val	array
->	O
type	int
=	O
GRECS_TYPE_LIST	int
;	O
val	array
->	O
v	pointer
.	O
list	pointer
=	O
list	pointer
;	O
}	O
static	O
void	O
value_to_array	function
(	O
struct	O
grecs_value	struct
*	O
val	array
)	O
{	O
if	O
(	O
val	array
->	O
type	int
==	O
GRECS_TYPE_ARRAY	int
)	O
return	O
;	O
else	O
{	O
struct	O
grecs_value	struct
*	O
*	O
vp	pointer
;	O
vp	pointer
=	O
grecs_calloc	function
(	O
1	int
,	O
sizeof	O
(	O
*	O
vp	pointer
)	O
)	O
;	O
vp	pointer
[	O
0	int
]	O
=	O
grecs_value_ptr_from_static	function
(	O
val	array
)	O
;	O
val	array
->	O
type	int
=	O
GRECS_TYPE_ARRAY	int
;	O
val	array
->	O
v	pointer
.	O
arg	struct
.	O
c	long
=	O
1	int
;	O
val	array
->	O
v	pointer
.	O
arg	struct
.	O
v	pointer
=	O
vp	pointer
;	O
}	O
}	O
static	O
void	O
array_add	function
(	O
struct	O
grecs_value	struct
*	O
vx	pointer
,	O
struct	O
grecs_value	struct
*	O
vy	pointer
)	O
{	O
size_t	long
i	int
;	O
vx	pointer
->	O
v	pointer
.	O
arg	struct
.	O
v	pointer
=	O
grecs_realloc	function
(	O
vx	pointer
->	O
v	pointer
.	O
arg	struct
.	O
v	pointer
,	O
(	O
vx	pointer
->	O
v	pointer
.	O
arg	struct
.	O
c	long
+	O
vy	pointer
->	O
v	pointer
.	O
arg	struct
.	O
c	long
)	O
*	O
sizeof	O
(	O
vx	pointer
->	O
v	pointer
.	O
arg	struct
.	O
v	pointer
[	O
0	int
]	O
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
vy	pointer
->	O
v	pointer
.	O
arg	struct
.	O
c	long
;	O
i	int
++	O
)	O
vx	pointer
->	O
v	pointer
.	O
arg	struct
.	O
v	pointer
[	O
i	int
+	O
vy	pointer
->	O
v	pointer
.	O
arg	struct
.	O
c	long
]	O
=	O
vy	pointer
->	O
v	pointer
.	O
arg	struct
.	O
v	pointer
[	O
i	int
]	O
;	O
grecs_free	function
(	O
vy	pointer
->	O
v	pointer
.	O
arg	struct
.	O
v	pointer
)	O
;	O
vy	pointer
->	O
v	pointer
.	O
arg	struct
.	O
v	pointer
=	O
NULL	O
;	O
vy	pointer
->	O
v	pointer
.	O
arg	struct
.	O
c	long
=	O
0	int
;	O
}	O
static	O
void	O
node_aggregate_stmt	function
(	O
struct	O
grecs_node	struct
*	O
dst	pointer
,	O
struct	O
grecs_node	struct
*	O
src	pointer
,	O
int	O
islist	int
)	O
{	O
if	O
(	O
islist	int
)	O
{	O
struct	O
grecs_list	struct
*	O
t	int
;	O
value_to_list	function
(	O
dst	pointer
->	O
v	pointer
.	O
value	pointer
)	O
;	O
value_to_list	function
(	O
src	pointer
->	O
v	pointer
.	O
value	pointer
)	O
;	O
grecs_list_add	function
(	O
src	pointer
->	O
v	pointer
.	O
value	pointer
->	O
v	pointer
.	O
list	pointer
,	O
dst	pointer
->	O
v	pointer
.	O
value	pointer
->	O
v	pointer
.	O
list	pointer
)	O
;	O
t	int
=	O
dst	pointer
->	O
v	pointer
.	O
value	pointer
->	O
v	pointer
.	O
list	pointer
;	O
dst	pointer
->	O
v	pointer
.	O
value	pointer
->	O
v	pointer
.	O
list	pointer
=	O
src	pointer
->	O
v	pointer
.	O
value	pointer
->	O
v	pointer
.	O
list	pointer
;	O
src	pointer
->	O
v	pointer
.	O
value	pointer
->	O
v	pointer
.	O
list	pointer
=	O
t	int
;	O
}	O
else	O
{	O
value_to_array	function
(	O
dst	pointer
->	O
v	pointer
.	O
value	pointer
)	O
;	O
value_to_array	function
(	O
src	pointer
->	O
v	pointer
.	O
value	pointer
)	O
;	O
array_add	function
(	O
dst	pointer
->	O
v	pointer
.	O
value	pointer
,	O
src	pointer
->	O
v	pointer
.	O
value	pointer
)	O
;	O
}	O
}	O
static	O
void	O
node_merge_stmt	function
(	O
struct	O
grecs_node	struct
*	O
to_node	pointer
,	O
struct	O
grecs_node	struct
*	O
from_node	pointer
,	O
struct	O
grecs_keyword	struct
*	O
kwp	pointer
,	O
int	O
flags	int
)	O
{	O
if	O
(	O
kwp	pointer
&&	O
(	O
flags	int
&	O
GRECS_AGGR	int
)	O
^	O
(	O
kwp	pointer
->	O
flags	int
&	O
GRECS_AGGR	int
)	O
&&	O
(	O
(	O
kwp	pointer
->	O
flags	int
&	O
GRECS_LIST	int
)	O
||	O
kwp	pointer
->	O
callback	pointer
)	O
)	O
node_aggregate_stmt	function
(	O
to_node	pointer
,	O
from_node	pointer
,	O
kwp	pointer
->	O
flags	int
&	O
GRECS_LIST	int
)	O
;	O
else	O
{	O
grecs_value_free	function
(	O
from_node	pointer
->	O
v	pointer
.	O
value	pointer
)	O
;	O
from_node	pointer
->	O
v	pointer
.	O
value	pointer
=	O
NULL	O
;	O
}	O
}	O
static	O
void	O
node_merge_block	function
(	O
struct	O
grecs_node	struct
*	O
to_node	pointer
,	O
struct	O
grecs_node	struct
*	O
from_node	pointer
,	O
struct	O
grecs_keyword	struct
*	O
kwp	pointer
)	O
{	O
struct	O
grecs_node	struct
*	O
sp	pointer
;	O
if	O
(	O
!	O
from_node	pointer
->	O
down	pointer
)	O
return	O
;	O
for	O
(	O
sp	pointer
=	O
from_node	pointer
->	O
down	pointer
;	O
;	O
sp	pointer
=	O
sp	pointer
->	O
next	pointer
)	O
{	O
sp	pointer
->	O
up	pointer
=	O
to_node	pointer
;	O
if	O
(	O
!	O
sp	pointer
->	O
next	pointer
)	O
break	O
;	O
}	O
sp	pointer
->	O
next	pointer
=	O
to_node	pointer
->	O
down	pointer
;	O
to_node	pointer
->	O
down	pointer
->	O
prev	pointer
=	O
sp	pointer
;	O
to_node	pointer
->	O
down	pointer
=	O
from_node	pointer
->	O
down	pointer
;	O
from_node	pointer
->	O
down	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
node_reduce	function
(	O
struct	O
grecs_node	struct
*	O
node	pointer
,	O
struct	O
grecs_keyword	struct
*	O
kwp	pointer
,	O
int	O
flags	int
)	O
{	O
struct	O
grecs_node	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
node	pointer
->	O
next	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
next	pointer
)	O
if	O
(	O
grecs_node_eq	function
(	O
p	pointer
,	O
node	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
p	pointer
)	O
{	O
switch	O
(	O
node	pointer
->	O
type	int
)	O
{	O
case	O
grecs_node_root	int
:	O
return	O
0	int
;	O
case	O
grecs_node_stmt	int
:	O
node_merge_stmt	function
(	O
p	pointer
,	O
node	pointer
,	O
kwp	pointer
,	O
flags	int
)	O
;	O
break	O
;	O
case	O
grecs_node_block	int
:	O
node_merge_block	function
(	O
p	pointer
,	O
node	pointer
,	O
kwp	pointer
)	O
;	O
break	O
;	O
}	O
grecs_node_unlink	function
(	O
node	pointer
)	O
;	O
grecs_node_free	function
(	O
node	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
enum	O
grecs_tree_recurse_res	enum
reduceproc	function
(	O
enum	O
grecs_tree_recurse_op	enum
op	enum
,	O
struct	O
grecs_node	struct
*	O
node	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
nodeproc_closure	struct
*	O
clos	pointer
=	O
data	pointer
;	O
if	O
(	O
op	enum
==	O
grecs_tree_recurse_post	int
)	O
{	O
if	O
(	O
clos	pointer
->	O
sections	pointer
)	O
clos	pointer
->	O
cursect	pointer
=	O
(	O
struct	O
grecs_keyword	struct
*	O
)	O
grecs_list_pop	function
(	O
clos	pointer
->	O
sections	pointer
)	O
;	O
}	O
else	O
{	O
struct	O
grecs_keyword	struct
*	O
kwp	pointer
=	O
NULL	O
;	O
if	O
(	O
clos	pointer
->	O
cursect	pointer
)	O
{	O
kwp	pointer
=	O
find_keyword	function
(	O
clos	pointer
->	O
cursect	pointer
,	O
node	pointer
)	O
;	O
if	O
(	O
!	O
kwp	pointer
)	O
return	O
grecs_tree_recurse_skip	int
;	O
if	O
(	O
kwp	pointer
->	O
flags	int
&	O
GRECS_INAC	int
)	O
return	O
grecs_tree_recurse_skip	int
;	O
if	O
(	O
!	O
(	O
kwp	pointer
->	O
flags	int
&	O
GRECS_MULT	int
)	O
&&	O
node_reduce	function
(	O
node	pointer
,	O
kwp	pointer
,	O
clos	pointer
->	O
flags	int
)	O
)	O
return	O
grecs_tree_recurse_skip	int
;	O
if	O
(	O
op	enum
==	O
grecs_tree_recurse_pre	int
)	O
{	O
grecs_list_push	function
(	O
clos	pointer
->	O
sections	pointer
,	O
clos	pointer
->	O
cursect	pointer
)	O
;	O
clos	pointer
->	O
cursect	pointer
=	O
kwp	pointer
;	O
}	O
}	O
else	O
if	O
(	O
node_reduce	function
(	O
node	pointer
,	O
kwp	pointer
,	O
clos	pointer
->	O
flags	int
)	O
)	O
return	O
grecs_tree_recurse_skip	int
;	O
}	O
return	O
grecs_tree_recurse_ok	int
;	O
}	O
int	O
grecs_tree_reduce	function
(	O
struct	O
grecs_node	struct
*	O
node	pointer
,	O
struct	O
grecs_keyword	struct
*	O
kwd	pointer
,	O
int	O
flags	int
)	O
{	O
int	O
rc	int
;	O
struct	O
nodeproc_closure	struct
clos	pointer
;	O
struct	O
grecs_keyword	struct
config_keywords	struct
;	O
memset	function
(	O
&	O
config_keywords	struct
,	O
0	int
,	O
sizeof	O
(	O
config_keywords	struct
)	O
)	O
;	O
config_keywords	struct
.	O
kwd	pointer
=	O
kwd	pointer
;	O
if	O
(	O
kwd	pointer
)	O
{	O
clos	pointer
.	O
cursect	pointer
=	O
&	O
config_keywords	struct
;	O
clos	pointer
.	O
sections	pointer
=	O
grecs_list_create	function
(	O
)	O
;	O
}	O
else	O
{	O
clos	pointer
.	O
cursect	pointer
=	O
NULL	O
;	O
clos	pointer
.	O
sections	pointer
=	O
NULL	O
;	O
}	O
clos	pointer
.	O
flags	int
=	O
flags	int
;	O
rc	int
=	O
grecs_tree_recurse	function
(	O
node	pointer
->	O
down	pointer
,	O
reduceproc	function
,	O
&	O
clos	pointer
)	O
;	O
grecs_list_free	function
(	O
clos	pointer
.	O
sections	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
struct	O
grecs_node	struct
*	O
grecs_tree_first_node	function
(	O
struct	O
grecs_node	struct
*	O
tree	pointer
)	O
{	O
if	O
(	O
tree	pointer
->	O
type	int
==	O
grecs_node_root	int
)	O
return	O
tree	pointer
->	O
down	pointer
;	O
return	O
tree	pointer
;	O
}	O
struct	O
grecs_node	struct
*	O
grecs_next_node	function
(	O
struct	O
grecs_node	struct
*	O
node	pointer
)	O
{	O
if	O
(	O
!	O
node	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
node	pointer
->	O
down	pointer
)	O
return	O
node	pointer
->	O
down	pointer
;	O
while	O
(	O
!	O
node	pointer
->	O
next	pointer
)	O
{	O
node	pointer
=	O
node	pointer
->	O
up	pointer
;	O
if	O
(	O
!	O
node	pointer
||	O
node	pointer
->	O
type	int
==	O
grecs_node_root	int
)	O
return	O
NULL	O
;	O
}	O
return	O
node	pointer
->	O
next	pointer
;	O
}	O
