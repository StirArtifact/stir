typedef	O
struct	O
{	O
const	O
char	O
*	O
filename	pointer
;	O
const	O
char	O
*	O
encoding	pointer
;	O
wget_iri	struct
*	O
base_url	pointer
;	O
wget_html_parsed_result	struct
*	O
parsed	pointer
;	O
int	O
content_type	pointer
;	O
}	O
_conversion_t	struct
;	O
static	O
wget_vector	struct
*	O
conversions	pointer
;	O
typedef	O
struct	O
{	O
int	O
ndownloads	int
;	O
int	O
nredirects	int
;	O
int	O
nnotmodified	int
;	O
int	O
nerrors	int
;	O
int	O
nchunks	int
;	O
long	O
long	O
bytes_body_uncompressed	long long
;	O
}	O
_statistics_t	struct
;	O
static	O
_statistics_t	struct
stats	pointer
;	O
static	O
int	O
WGET_GCC_NONNULL	O
(	O
(	O
1	int
)	O
)	O
_prepare_file	function
(	O
wget_http_response	struct
*	O
resp	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
int	O
flag	int
,	O
wget_iri	struct
*	O
uri	pointer
,	O
wget_iri	struct
*	O
original_url	pointer
,	O
int	O
ignore_patterns	bool
,	O
wget_buffer	struct
*	O
partial_content	pointer
,	O
size_t	long
max_partial_content	long
,	O
char	O
*	O
*	O
actual_file_name	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
;	O
static	O
void	O
sitemap_parse_xml	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
sitemap_parse_xml_gz	function
(	O
JOB	struct
*	O
job	pointer
,	O
wget_buffer	struct
*	O
data	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
sitemap_parse_xml_localfile	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
sitemap_parse_text	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
atom_parse	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
atom_parse_localfile	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
rss_parse	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
rss_parse_localfile	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
metalink_parse_localfile	function
(	O
const	O
char	O
*	O
fname	pointer
)	O
,	O
html_parse	function
(	O
JOB	struct
*	O
job	pointer
,	O
int	O
level	int
,	O
const	O
char	O
*	O
data	pointer
,	O
size_t	long
len	long
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
html_parse_localfile	function
(	O
JOB	struct
*	O
job	pointer
,	O
int	O
level	int
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
css_parse	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
size_t	long
len	long
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
css_parse_localfile	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
,	O
fork_to_background	function
(	O
void	O
)	O
;	O
static	O
unsigned	O
int	O
WGET_GCC_PURE	O
hash_url	function
(	O
const	O
char	O
*	O
url	pointer
)	O
;	O
static	O
int	O
read_xattr_metadata	function
(	O
const	O
char	O
*	O
name	pointer
,	O
char	O
*	O
value	pointer
,	O
size_t	long
size	pointer
,	O
int	O
fd	array
)	O
,	O
write_xattr_metadata	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
int	O
fd	array
)	O
,	O
write_xattr_last_modified	function
(	O
time_t	long
last_modified	long
,	O
int	O
fd	array
)	O
,	O
set_file_metadata	function
(	O
wget_iri	struct
*	O
origin_url	pointer
,	O
wget_iri	struct
*	O
referrer_url	pointer
,	O
const	O
char	O
*	O
mime_type	pointer
,	O
const	O
char	O
*	O
charset	pointer
,	O
time_t	long
last_modified	long
,	O
FILE	struct
*	O
fp	pointer
)	O
,	O
http_send_request	function
(	O
wget_iri	struct
*	O
iri	pointer
,	O
wget_iri	struct
*	O
original_url	pointer
,	O
DOWNLOADER	struct
*	O
downloader	pointer
)	O
;	O
wget_http_response	struct
*	O
http_receive_response	function
(	O
wget_http_connection	struct
*	O
conn	pointer
)	O
;	O
static	O
long	O
long	O
WGET_GCC_NONNULL_ALL	O
get_file_size	function
(	O
const	O
char	O
*	O
fname	pointer
)	O
;	O
static	O
wget_stringmap	struct
*	O
etags	pointer
;	O
static	O
wget_hashmap	struct
*	O
known_urls	pointer
;	O
static	O
DOWNLOADER	struct
*	O
downloaders	pointer
;	O
static	O
void	O
*	O
downloader_thread	function
(	O
void	O
*	O
p	pointer
)	O
;	O
static	O
wget_thread_mutex	pointer
quota_mutex	pointer
;	O
static	O
long	O
long	O
quota	long long
;	O
static	O
int	O
hsts_changed	int
,	O
hpkp_changed	int
;	O
static	O
volatile	O
bool	bool
terminate	bool
;	O
static	O
int	O
nthreads	int
;	O
static	O
const	O
char	O
*	O
WGET_GCC_NONNULL_ALL	O
_get_local_filename	function
(	O
const	O
wget_iri	struct
*	O
iri	pointer
)	O
{	O
wget_buffer	struct
buf	pointer
;	O
char	O
*	O
fname	pointer
;	O
int	O
directories	char
;	O
directories	char
=	O
!	O
!	O
config	struct
.	O
recursive	char
;	O
if	O
(	O
config	struct
.	O
directories	char
==	O
0	int
)	O
directories	char
=	O
0	int
;	O
if	O
(	O
config	struct
.	O
force_directories	char
==	O
1	int
)	O
directories	char
=	O
1	int
;	O
wget_buffer_init	function
(	O
&	O
buf	pointer
,	O
NULL	O
,	O
256	int
)	O
;	O
if	O
(	O
config	struct
.	O
directory_prefix	pointer
&&	O
*	O
config	struct
.	O
directory_prefix	pointer
)	O
{	O
wget_buffer_strcat	function
(	O
&	O
buf	pointer
,	O
config	struct
.	O
directory_prefix	pointer
)	O
;	O
wget_buffer_memcat	function
(	O
&	O
buf	pointer
,	O
"/"	pointer
,	O
1	int
)	O
;	O
}	O
if	O
(	O
directories	char
)	O
{	O
if	O
(	O
config	struct
.	O
protocol_directories	char
&&	O
wget_iri_supported	function
(	O
iri	pointer
)	O
)	O
{	O
wget_buffer_strcat	function
(	O
&	O
buf	pointer
,	O
wget_iri_scheme_get_name	function
(	O
iri	pointer
->	O
scheme	enum
)	O
)	O
;	O
wget_buffer_memcat	function
(	O
&	O
buf	pointer
,	O
"/"	pointer
,	O
1	int
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
host_directories	char
&&	O
iri	pointer
->	O
host	pointer
&&	O
*	O
iri	pointer
->	O
host	pointer
)	O
{	O
wget_buffer_strcat	function
(	O
&	O
buf	pointer
,	O
iri	pointer
->	O
host	pointer
)	O
;	O
wget_buffer_memcat	function
(	O
&	O
buf	pointer
,	O
"/"	pointer
,	O
1	int
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
cut_directories	int
)	O
{	O
wget_buffer	struct
path_buf	struct
;	O
const	O
char	O
*	O
p	pointer
;	O
int	O
n	long
;	O
char	O
sbuf	array
[	O
256	int
]	O
;	O
wget_buffer_init	function
(	O
&	O
path_buf	struct
,	O
sbuf	array
,	O
sizeof	O
(	O
sbuf	array
)	O
)	O
;	O
wget_iri_get_path	function
(	O
iri	pointer
,	O
&	O
path_buf	struct
,	O
config	struct
.	O
local_encoding	pointer
)	O
;	O
for	O
(	O
n	long
=	O
0	int
,	O
p	pointer
=	O
path_buf	struct
.	O
data	pointer
;	O
n	long
<	O
config	struct
.	O
cut_directories	int
&&	O
p	pointer
;	O
n	long
++	O
)	O
{	O
p	pointer
=	O
strchr	function
(	O
*	O
p	pointer
==	O
'/'	O
?	O
p	pointer
+	O
1	int
:	O
p	pointer
,	O
'/'	O
)	O
;	O
}	O
if	O
(	O
!	O
p	pointer
&&	O
path_buf	struct
.	O
data	pointer
)	O
{	O
p	pointer
=	O
strrchr	function
(	O
path_buf	struct
.	O
data	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
p	pointer
)	O
p	pointer
=	O
path_buf	struct
.	O
data	pointer
;	O
}	O
if	O
(	O
p	pointer
)	O
{	O
while	O
(	O
*	O
p	pointer
==	O
'/'	O
)	O
p	pointer
++	O
;	O
wget_buffer_strcat	function
(	O
&	O
buf	pointer
,	O
p	pointer
)	O
;	O
}	O
wget_buffer_deinit	function
(	O
&	O
path_buf	struct
)	O
;	O
}	O
else	O
{	O
wget_iri_get_path	function
(	O
iri	pointer
,	O
&	O
buf	pointer
,	O
config	struct
.	O
local_encoding	pointer
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
cut_file_get_vars	char
)	O
fname	pointer
=	O
buf	pointer
.	O
data	pointer
;	O
else	O
fname	pointer
=	O
wget_iri_get_query_as_filename	function
(	O
iri	pointer
,	O
&	O
buf	pointer
,	O
config	struct
.	O
local_encoding	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
config	struct
.	O
cut_file_get_vars	char
)	O
fname	pointer
=	O
wget_iri_get_path	function
(	O
iri	pointer
,	O
&	O
buf	pointer
,	O
config	struct
.	O
local_encoding	pointer
)	O
;	O
else	O
fname	pointer
=	O
wget_iri_get_filename	function
(	O
iri	pointer
,	O
&	O
buf	pointer
,	O
config	struct
.	O
local_encoding	pointer
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
restrict_file_names	int
)	O
{	O
char	O
fname_esc	O
[	O
buf	pointer
.	O
length	long
*	O
3	int
+	O
1	int
]	O
;	O
if	O
(	O
wget_restrict_file_name	function
(	O
fname	pointer
,	O
fname_esc	O
,	O
config	struct
.	O
restrict_file_names	int
)	O
!=	O
fname	pointer
)	O
{	O
wget_buffer_strcpy	function
(	O
&	O
buf	pointer
,	O
fname_esc	O
)	O
;	O
fname	pointer
=	O
buf	pointer
.	O
data	pointer
;	O
}	O
}	O
debug_printf	O
(	O
"local filename = '%s'\n"	pointer
,	O
fname	pointer
)	O
;	O
return	O
fname	pointer
;	O
}	O
const	O
char	O
*	O
WGET_GCC_NONNULL_ALL	O
get_local_filename	function
(	O
const	O
wget_iri	struct
*	O
iri	pointer
)	O
{	O
if	O
(	O
config	struct
.	O
delete_after	char
)	O
return	O
NULL	O
;	O
if	O
(	O
(	O
config	struct
.	O
spider	char
||	O
config	struct
.	O
output_document	pointer
)	O
&&	O
!	O
config	struct
.	O
continue_download	char
)	O
return	O
NULL	O
;	O
return	O
_get_local_filename	function
(	O
iri	pointer
)	O
;	O
}	O
static	O
long	O
long	O
_fetch_and_add_longlong	function
(	O
long	O
long	O
*	O
p	pointer
,	O
long	O
long	O
n	long
)	O
{	O
return	O
__sync_fetch_and_add	O
(	O
p	pointer
,	O
n	long
)	O
;	O
}	O
static	O
void	O
_atomic_increment_int	function
(	O
int	O
*	O
p	pointer
)	O
{	O
__sync_fetch_and_add	O
(	O
p	pointer
,	O
1	int
)	O
;	O
}	O
static	O
long	O
long	O
quota_modify_read	function
(	O
size_t	long
nbytes	long
)	O
{	O
return	O
_fetch_and_add_longlong	function
(	O
&	O
quota	long long
,	O
(	O
long	O
long	O
)	O
nbytes	long
)	O
;	O
}	O
static	O
void	O
nop	function
(	O
int	O
sig	int
)	O
{	O
if	O
(	O
sig	int
==	O
SIGTERM	int
)	O
{	O
abort	function
(	O
)	O
;	O
}	O
else	O
if	O
(	O
sig	int
==	O
SIGINT	int
)	O
{	O
if	O
(	O
terminate	bool
)	O
abort	function
(	O
)	O
;	O
terminate	bool
=	O
1	int
;	O
wget_http_abort_connection	function
(	O
NULL	O
)	O
;	O
}	O
else	O
if	O
(	O
sig	int
==	O
SIGWINCH	int
)	O
{	O
wget_bar_screen_resized	function
(	O
)	O
;	O
}	O
}	O
static	O
void	O
*	O
input_thread	function
(	O
void	O
*	O
p	pointer
)	O
;	O
static	O
wget_thread	pointer
input_tid	pointer
;	O
static	O
wget_vector	struct
*	O
parents	pointer
;	O
static	O
wget_thread_mutex	pointer
downloader_mutex	pointer
,	O
main_mutex	pointer
,	O
known_urls_mutex	pointer
,	O
etag_mutex	pointer
,	O
savefile_mutex	pointer
,	O
netrc_mutex	pointer
,	O
conversion_mutex	pointer
;	O
static	O
wget_thread_cond	pointer
main_cond	pointer
,	O
worker_cond	pointer
;	O
static	O
void	O
_wget_init	function
(	O
void	O
)	O
{	O
wget_global_init	function
(	O
0	int
)	O
;	O
blacklist_init	function
(	O
)	O
;	O
host_init	function
(	O
)	O
;	O
wget_thread_mutex_init	function
(	O
&	O
downloader_mutex	pointer
)	O
;	O
wget_thread_mutex_init	function
(	O
&	O
main_mutex	pointer
)	O
;	O
wget_thread_mutex_init	function
(	O
&	O
known_urls_mutex	pointer
)	O
;	O
wget_thread_mutex_init	function
(	O
&	O
etag_mutex	pointer
)	O
;	O
wget_thread_mutex_init	function
(	O
&	O
savefile_mutex	pointer
)	O
;	O
wget_thread_mutex_init	function
(	O
&	O
netrc_mutex	pointer
)	O
;	O
wget_thread_mutex_init	function
(	O
&	O
conversion_mutex	pointer
)	O
;	O
wget_thread_mutex_init	function
(	O
&	O
quota_mutex	pointer
)	O
;	O
wget_thread_cond_init	function
(	O
&	O
main_cond	pointer
)	O
;	O
wget_thread_cond_init	function
(	O
&	O
worker_cond	pointer
)	O
;	O
setlocale	function
(	O
LC_ALL	O
,	O
""	pointer
)	O
;	O
bindtextdomain	function
(	O
"wget"	pointer
,	O
LOCALEDIR	O
)	O
;	O
textdomain	function
(	O
"wget"	pointer
)	O
;	O
struct	O
sigaction	struct
sig_action	struct
;	O
memset	function
(	O
&	O
sig_action	struct
,	O
0	int
,	O
sizeof	O
(	O
sig_action	struct
)	O
)	O
;	O
sig_action	struct
.	O
sa_sigaction	pointer
=	O
(	O
void	O
(	O
*	O
)	O
(	O
int	O
,	O
siginfo_t	struct
*	O
,	O
void	O
*	O
)	O
)	O
SIG_IGN	O
;	O
sigaction	struct
(	O
SIGPIPE	int
,	O
&	O
sig_action	struct
,	O
NULL	O
)	O
;	O
sig_action	struct
.	O
sa_handler	pointer
=	O
nop	function
;	O
sigaction	struct
(	O
SIGTERM	int
,	O
&	O
sig_action	struct
,	O
NULL	O
)	O
;	O
sigaction	struct
(	O
SIGINT	int
,	O
&	O
sig_action	struct
,	O
NULL	O
)	O
;	O
sigaction	struct
(	O
SIGWINCH	int
,	O
&	O
sig_action	struct
,	O
NULL	O
)	O
;	O
known_urls	pointer
=	O
wget_hashmap_create	function
(	O
128	int
,	O
(	O
wget_hashmap_hash_fn	function
*	O
)	O
hash_url	function
,	O
(	O
wget_hashmap_compare_fn	function
*	O
)	O
strcmp	function
)	O
;	O
plugin_db_init	function
(	O
)	O
;	O
plugin_db_add_search_paths	function
(	O
WGET_PLUGIN_DIR	O
,	O
0	int
)	O
;	O
}	O
static	O
void	O
_wget_deinit	function
(	O
void	O
)	O
{	O
host_exit	function
(	O
)	O
;	O
blacklist_exit	function
(	O
)	O
;	O
wget_thread_mutex_destroy	function
(	O
&	O
downloader_mutex	pointer
)	O
;	O
wget_thread_mutex_destroy	function
(	O
&	O
main_mutex	pointer
)	O
;	O
wget_thread_mutex_destroy	function
(	O
&	O
known_urls_mutex	pointer
)	O
;	O
wget_thread_mutex_destroy	function
(	O
&	O
etag_mutex	pointer
)	O
;	O
wget_thread_mutex_destroy	function
(	O
&	O
savefile_mutex	pointer
)	O
;	O
wget_thread_mutex_destroy	function
(	O
&	O
netrc_mutex	pointer
)	O
;	O
wget_thread_mutex_destroy	function
(	O
&	O
conversion_mutex	pointer
)	O
;	O
wget_thread_mutex_destroy	function
(	O
&	O
quota_mutex	pointer
)	O
;	O
wget_thread_cond_destroy	function
(	O
&	O
main_cond	pointer
)	O
;	O
wget_thread_cond_destroy	function
(	O
&	O
worker_cond	pointer
)	O
;	O
}	O
static	O
bool	bool
match_subdir	function
(	O
const	O
char	O
*	O
dir	array
,	O
const	O
char	O
*	O
subdir	pointer
,	O
char	O
ignore_case	char
)	O
{	O
if	O
(	O
*	O
dir	array
==	O
'\0'	O
)	O
return	O
(	O
strcmp	function
(	O
subdir	pointer
,	O
"/"	pointer
)	O
)	O
?	O
false	int
:	O
true	int
;	O
if	O
(	O
ignore_case	char
)	O
for	O
(	O
;	O
*	O
dir	array
&&	O
*	O
subdir	pointer
&&	O
(	O
c_tolower	function
(	O
*	O
dir	array
)	O
==	O
c_tolower	function
(	O
*	O
subdir	pointer
)	O
)	O
;	O
++	O
dir	array
,	O
++	O
subdir	pointer
)	O
;	O
else	O
while	O
(	O
*	O
dir	array
&&	O
*	O
subdir	pointer
&&	O
(	O
*	O
dir	array
++	O
==	O
*	O
subdir	pointer
++	O
)	O
)	O
;	O
return	O
*	O
dir	array
==	O
0	int
&&	O
(	O
*	O
subdir	pointer
==	O
0	int
||	O
*	O
subdir	pointer
==	O
'/'	O
)	O
;	O
}	O
static	O
int	O
in_directory_pattern_list	function
(	O
const	O
wget_vector	struct
*	O
v	pointer
,	O
const	O
char	O
*	O
fname	pointer
)	O
{	O
const	O
char	O
*	O
pattern	pointer
;	O
char	O
*	O
path	pointer
;	O
bool	bool
default_exclude	bool
=	O
0	int
;	O
if	O
(	O
*	O
fname	pointer
==	O
'/'	O
)	O
fname	pointer
++	O
;	O
const	O
char	O
*	O
e	pointer
=	O
strrchr	function
(	O
fname	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
!	O
e	pointer
)	O
path	pointer
=	O
wget_strdup	function
(	O
"/"	pointer
)	O
;	O
else	O
path	pointer
=	O
wget_strmemdup	function
(	O
fname	pointer
,	O
e	pointer
-	O
fname	pointer
)	O
;	O
pattern	pointer
=	O
wget_vector_get	function
(	O
v	pointer
,	O
0	int
)	O
;	O
default_exclude	bool
=	O
(	O
*	O
pattern	pointer
==	O
INCLUDED_DIRECTORY_PREFIX	char
)	O
;	O
for	O
(	O
int	O
it	int
=	O
wget_vector_size	function
(	O
v	pointer
)	O
-	O
1	int
;	O
it	int
>=	O
0	int
;	O
it	int
--	O
)	O
{	O
pattern	pointer
=	O
wget_vector_get	function
(	O
v	pointer
,	O
it	int
)	O
;	O
bool	bool
exclude	bool
=	O
(	O
*	O
pattern	pointer
!=	O
INCLUDED_DIRECTORY_PREFIX	char
)	O
;	O
pattern	pointer
++	O
;	O
if	O
(	O
*	O
pattern	pointer
==	O
'/'	O
)	O
pattern	pointer
++	O
;	O
debug_printf	O
(	O
"directory[%d] '%s' - '%s' %c\n"	pointer
,	O
it	int
,	O
pattern	pointer
,	O
path	pointer
,	O
"+-"	pointer
[	O
exclude	bool
]	O
)	O
;	O
if	O
(	O
strpbrk	function
(	O
pattern	pointer
,	O
"*?[]"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
fnmatch	function
(	O
pattern	pointer
,	O
path	pointer
,	O
FNM_PATHNAME	O
|	O
(	O
config	struct
.	O
ignore_case	char
?	O
FNM_CASEFOLD	O
:	O
0	int
)	O
)	O
)	O
{	O
wget_free	pointer
(	O
path	pointer
)	O
;	O
return	O
exclude	bool
;	O
}	O
}	O
else	O
if	O
(	O
match_subdir	function
(	O
pattern	pointer
,	O
path	pointer
,	O
config	struct
.	O
ignore_case	char
)	O
)	O
{	O
wget_free	pointer
(	O
path	pointer
)	O
;	O
return	O
exclude	bool
;	O
}	O
}	O
wget_free	pointer
(	O
path	pointer
)	O
;	O
return	O
default_exclude	bool
;	O
}	O
static	O
int	O
in_pattern_list	function
(	O
const	O
wget_vector	struct
*	O
v	pointer
,	O
const	O
char	O
*	O
url	pointer
)	O
{	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
v	pointer
)	O
;	O
it	int
++	O
)	O
{	O
const	O
char	O
*	O
pattern	pointer
=	O
wget_vector_get	function
(	O
v	pointer
,	O
it	int
)	O
;	O
debug_printf	O
(	O
"pattern[%d] '%s' - %s\n"	pointer
,	O
it	int
,	O
pattern	pointer
,	O
url	pointer
)	O
;	O
if	O
(	O
strpbrk	function
(	O
pattern	pointer
,	O
"*?[]"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
fnmatch	function
(	O
pattern	pointer
,	O
url	pointer
,	O
config	struct
.	O
ignore_case	char
?	O
FNM_CASEFOLD	O
:	O
0	int
)	O
)	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
ignore_case	char
)	O
{	O
if	O
(	O
wget_match_tail_nocase	function
(	O
url	pointer
,	O
pattern	pointer
)	O
)	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
wget_match_tail	function
(	O
url	pointer
,	O
pattern	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
in_host_pattern_list	function
(	O
const	O
wget_vector	struct
*	O
v	pointer
,	O
const	O
char	O
*	O
hostname	pointer
)	O
{	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
v	pointer
)	O
;	O
it	int
++	O
)	O
{	O
const	O
char	O
*	O
pattern	pointer
=	O
wget_vector_get	function
(	O
v	pointer
,	O
it	int
)	O
;	O
debug_printf	O
(	O
"host_pattern[%d] '%s' - %s\n"	pointer
,	O
it	int
,	O
pattern	pointer
,	O
hostname	pointer
)	O
;	O
if	O
(	O
strpbrk	function
(	O
pattern	pointer
,	O
"*?[]"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
fnmatch	function
(	O
pattern	pointer
,	O
hostname	pointer
,	O
0	int
)	O
)	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
wget_match_tail	function
(	O
pattern	pointer
,	O
hostname	pointer
)	O
)	O
{	O
return	O
1	int
;	O
}	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
regex_match_posix	function
(	O
const	O
char	O
*	O
string	pointer
,	O
const	O
char	O
*	O
pattern	pointer
)	O
{	O
int	O
status	int
;	O
regex_t	struct
re	struct
;	O
if	O
(	O
regcomp	O
(	O
&	O
re	struct
,	O
pattern	pointer
,	O
REG_EXTENDED	int
|	O
REG_NOSUB	O
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
status	int
=	O
regexec	O
(	O
&	O
re	struct
,	O
string	pointer
,	O
(	O
size_t	long
)	O
0	int
,	O
NULL	O
,	O
0	int
)	O
;	O
regfree	O
(	O
&	O
re	struct
)	O
;	O
if	O
(	O
status	int
!=	O
0	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
regex_match	function
(	O
const	O
char	O
*	O
string	pointer
,	O
const	O
char	O
*	O
pattern	pointer
)	O
{	O
return	O
regex_match_posix	function
(	O
string	pointer
,	O
pattern	pointer
)	O
;	O
}	O
static	O
void	O
parse_localfile	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
const	O
char	O
*	O
mimetype	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
int	O
fd	array
;	O
int	O
level	int
=	O
job	pointer
?	O
job	pointer
->	O
level	int
:	O
0	int
;	O
char	O
_mimetype	array
[	O
64	int
]	O
,	O
_encoding	array
[	O
32	int
]	O
;	O
if	O
(	O
(	O
fd	array
=	O
open	function
(	O
fname	pointer
,	O
O_RDONLY	int
)	O
)	O
==	O
-	O
1	int
)	O
return	O
;	O
if	O
(	O
!	O
mimetype	pointer
)	O
{	O
if	O
(	O
read_xattr_metadata	function
(	O
"user.mimetype"	pointer
,	O
_mimetype	array
,	O
sizeof	O
(	O
_mimetype	array
)	O
,	O
fd	array
)	O
<	O
0	int
)	O
*	O
_mimetype	array
=	O
0	int
;	O
else	O
if	O
(	O
*	O
_mimetype	array
)	O
mimetype	pointer
=	O
_mimetype	array
;	O
}	O
if	O
(	O
!	O
encoding	pointer
)	O
{	O
if	O
(	O
read_xattr_metadata	function
(	O
"user.charset"	pointer
,	O
_encoding	array
,	O
sizeof	O
(	O
_encoding	array
)	O
,	O
fd	array
)	O
<	O
0	int
)	O
*	O
_encoding	array
=	O
0	int
;	O
else	O
if	O
(	O
*	O
_encoding	array
)	O
encoding	pointer
=	O
_encoding	array
;	O
}	O
close	function
(	O
fd	array
)	O
;	O
if	O
(	O
mimetype	pointer
)	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
mimetype	pointer
,	O
"text/html"	pointer
)	O
||	O
!	O
wget_strcasecmp_ascii	function
(	O
mimetype	pointer
,	O
"application/xhtml+xml"	pointer
)	O
)	O
{	O
html_parse_localfile	function
(	O
job	pointer
,	O
level	int
,	O
fname	pointer
,	O
encoding	pointer
,	O
base	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
mimetype	pointer
,	O
"text/css"	pointer
)	O
)	O
{	O
css_parse_localfile	function
(	O
job	pointer
,	O
fname	pointer
,	O
encoding	pointer
,	O
base	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
mimetype	pointer
,	O
"text/xml"	pointer
)	O
||	O
!	O
wget_strcasecmp_ascii	function
(	O
mimetype	pointer
,	O
"application/xml"	pointer
)	O
)	O
{	O
sitemap_parse_xml_localfile	function
(	O
job	pointer
,	O
fname	pointer
,	O
encoding	pointer
?	O
encoding	pointer
:	O
"utf-8"	pointer
,	O
base	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
mimetype	pointer
,	O
"application/atom+xml"	pointer
)	O
)	O
{	O
atom_parse_localfile	function
(	O
job	pointer
,	O
fname	pointer
,	O
encoding	pointer
?	O
encoding	pointer
:	O
"utf-8"	pointer
,	O
base	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
mimetype	pointer
,	O
"application/rss+xml"	pointer
)	O
)	O
{	O
rss_parse_localfile	function
(	O
job	pointer
,	O
fname	pointer
,	O
encoding	pointer
?	O
encoding	pointer
:	O
"utf-8"	pointer
,	O
base	pointer
)	O
;	O
}	O
}	O
else	O
{	O
const	O
char	O
*	O
ext	pointer
=	O
strrchr	function
(	O
fname	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
ext	pointer
)	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
ext	pointer
,	O
".html"	pointer
)	O
||	O
!	O
wget_strcasecmp_ascii	function
(	O
ext	pointer
,	O
".htm"	pointer
)	O
)	O
{	O
html_parse_localfile	function
(	O
job	pointer
,	O
level	int
,	O
fname	pointer
,	O
encoding	pointer
,	O
base	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
ext	pointer
,	O
".css"	pointer
)	O
)	O
{	O
css_parse_localfile	function
(	O
job	pointer
,	O
fname	pointer
,	O
encoding	pointer
,	O
base	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
ext	pointer
,	O
".rss"	pointer
)	O
)	O
{	O
rss_parse_localfile	function
(	O
job	pointer
,	O
fname	pointer
,	O
encoding	pointer
?	O
encoding	pointer
:	O
"utf-8"	pointer
,	O
base	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
add_url_to_queue	function
(	O
const	O
char	O
*	O
url	pointer
,	O
wget_iri	struct
*	O
base	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
int	O
flags	int
)	O
{	O
wget_iri	struct
*	O
iri	pointer
;	O
JOB	struct
*	O
new_job	pointer
=	O
NULL	O
,	O
job_buf	struct
;	O
HOST	struct
*	O
host	pointer
;	O
const	O
char	O
*	O
local_filename	pointer
;	O
struct	O
plugin_db_forward_url_verdict	struct
plugin_verdict	struct
;	O
bool	bool
http_fallback	bool
=	O
0	int
;	O
iri	pointer
=	O
wget_iri_parse_base	function
(	O
base	pointer
,	O
url	pointer
,	O
encoding	pointer
)	O
;	O
if	O
(	O
!	O
iri	pointer
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to parse URI '%s'\n"	pointer
)	O
,	O
url	pointer
)	O
;	O
return	O
;	O
}	O
plugin_db_forward_url	function
(	O
iri	pointer
,	O
&	O
plugin_verdict	struct
)	O
;	O
if	O
(	O
plugin_verdict	struct
.	O
reject	bool
)	O
{	O
wget_iri_free	function
(	O
&	O
iri	pointer
)	O
;	O
plugin_db_forward_url_verdict_free	function
(	O
&	O
plugin_verdict	struct
)	O
;	O
return	O
;	O
}	O
if	O
(	O
plugin_verdict	struct
.	O
alt_iri	pointer
)	O
{	O
wget_iri_free	function
(	O
&	O
iri	pointer
)	O
;	O
iri	pointer
=	O
plugin_verdict	struct
.	O
alt_iri	pointer
;	O
plugin_verdict	struct
.	O
alt_iri	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
iri	pointer
->	O
scheme	enum
!=	O
WGET_IRI_SCHEME_HTTP	int
&&	O
iri	pointer
->	O
scheme	enum
!=	O
WGET_IRI_SCHEME_HTTPS	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"URI scheme not supported: '%s'\n"	pointer
)	O
,	O
url	pointer
)	O
;	O
wget_iri_free	function
(	O
&	O
iri	pointer
)	O
;	O
plugin_db_forward_url_verdict_free	function
(	O
&	O
plugin_verdict	struct
)	O
;	O
return	O
;	O
}	O
wget_thread_mutex_lock	function
(	O
downloader_mutex	pointer
)	O
;	O
if	O
(	O
iri	pointer
->	O
scheme	enum
==	O
WGET_IRI_SCHEME_HTTP	int
&&	O
config	struct
.	O
https_enforce	char
)	O
{	O
wget_iri_set_scheme	function
(	O
iri	pointer
,	O
WGET_IRI_SCHEME_HTTPS	int
)	O
;	O
if	O
(	O
config	struct
.	O
https_enforce	char
==	O
WGET_HTTPS_ENFORCE_SOFT	int
)	O
http_fallback	bool
=	O
1	int
;	O
}	O
if	O
(	O
!	O
blacklist_add	function
(	O
iri	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
flags	int
&	O
URL_FLG_NO_BLACKLISTING	O
)	O
)	O
{	O
wget_thread_mutex_unlock	function
(	O
downloader_mutex	pointer
)	O
;	O
plugin_db_forward_url_verdict_free	function
(	O
&	O
plugin_verdict	struct
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
wget_vector_contains	function
(	O
config	struct
.	O
exclude_domains	pointer
,	O
iri	pointer
->	O
host	pointer
)	O
)	O
{	O
debug_printf	O
(	O
"not requesting '%s'. (Exclude Domains)\n"	pointer
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
wget_thread_mutex_unlock	function
(	O
downloader_mutex	pointer
)	O
;	O
plugin_db_forward_url_verdict_free	function
(	O
&	O
plugin_verdict	struct
)	O
;	O
return	O
;	O
}	O
if	O
(	O
plugin_verdict	struct
.	O
alt_local_filename	pointer
)	O
{	O
local_filename	pointer
=	O
plugin_verdict	struct
.	O
alt_local_filename	pointer
;	O
plugin_verdict	struct
.	O
alt_local_filename	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
local_filename	pointer
=	O
get_local_filename	function
(	O
iri	pointer
)	O
;	O
}	O
if	O
(	O
!	O
config	struct
.	O
clobber	char
&&	O
local_filename	pointer
&&	O
access	function
(	O
local_filename	pointer
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
debug_printf	O
(	O
"not requesting '%s'. (File already exists)\n"	pointer
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
wget_thread_mutex_unlock	function
(	O
downloader_mutex	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
recursive	char
||	O
config	struct
.	O
page_requisites	char
)	O
{	O
parse_localfile	function
(	O
NULL	O
,	O
local_filename	pointer
,	O
NULL	O
,	O
NULL	O
,	O
iri	pointer
)	O
;	O
}	O
xfree	O
(	O
local_filename	pointer
)	O
;	O
plugin_db_forward_url_verdict_free	function
(	O
&	O
plugin_verdict	struct
)	O
;	O
return	O
;	O
}	O
if	O
(	O
(	O
host	pointer
=	O
host_add	function
(	O
iri	pointer
)	O
)	O
)	O
{	O
if	O
(	O
config	struct
.	O
recursive	char
&&	O
config	struct
.	O
robots	pointer
)	O
{	O
if	O
(	O
!	O
config	struct
.	O
clobber	char
&&	O
local_filename	pointer
&&	O
access	function
(	O
local_filename	pointer
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
debug_printf	O
(	O
"not requesting '%s'. (File already exists)\n"	pointer
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
}	O
else	O
{	O
wget_iri	struct
*	O
robot_iri	pointer
=	O
wget_iri_parse_base	function
(	O
iri	pointer
,	O
"/robots.txt"	pointer
,	O
encoding	pointer
)	O
;	O
if	O
(	O
blacklist_add	function
(	O
robot_iri	pointer
)	O
)	O
host_add_robotstxt_job	function
(	O
host	pointer
,	O
robot_iri	pointer
,	O
http_fallback	bool
)	O
;	O
}	O
}	O
}	O
else	O
host	pointer
=	O
host_get	function
(	O
iri	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
recursive	char
)	O
{	O
if	O
(	O
!	O
config	struct
.	O
span_hosts	char
&&	O
config	struct
.	O
domains	pointer
)	O
{	O
if	O
(	O
wget_vector_find	function
(	O
config	struct
.	O
domains	pointer
,	O
iri	pointer
->	O
host	pointer
)	O
<	O
0	int
)	O
wget_vector_add	function
(	O
config	struct
.	O
domains	pointer
,	O
wget_strdup	function
(	O
iri	pointer
->	O
host	pointer
)	O
)	O
;	O
}	O
if	O
(	O
!	O
config	struct
.	O
parent	char
)	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
!	O
parents	pointer
)	O
parents	pointer
=	O
wget_vector_create	function
(	O
4	int
,	O
NULL	O
)	O
;	O
if	O
(	O
!	O
iri	pointer
->	O
path	pointer
||	O
!	O
(	O
p	pointer
=	O
strrchr	function
(	O
iri	pointer
->	O
path	pointer
,	O
'/'	O
)	O
)	O
)	O
iri	pointer
->	O
dirlen	long
=	O
0	int
;	O
else	O
iri	pointer
->	O
dirlen	long
=	O
p	pointer
-	O
iri	pointer
->	O
path	pointer
+	O
1	int
;	O
wget_vector_add	function
(	O
parents	pointer
,	O
iri	pointer
)	O
;	O
}	O
}	O
new_job	pointer
=	O
job_init	function
(	O
&	O
job_buf	struct
,	O
iri	pointer
,	O
http_fallback	bool
)	O
;	O
new_job	pointer
->	O
local_filename	pointer
=	O
local_filename	pointer
;	O
if	O
(	O
plugin_verdict	struct
.	O
accept	bool
)	O
{	O
new_job	pointer
->	O
ignore_patterns	bool
=	O
1	int
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
recursive	char
)	O
{	O
if	O
(	O
(	O
config	struct
.	O
accept_patterns	pointer
&&	O
!	O
in_pattern_list	function
(	O
config	struct
.	O
accept_patterns	pointer
,	O
new_job	pointer
->	O
iri	pointer
->	O
uri	pointer
)	O
)	O
||	O
(	O
config	struct
.	O
accept_regex	pointer
&&	O
!	O
regex_match	function
(	O
new_job	pointer
->	O
iri	pointer
->	O
uri	pointer
,	O
config	struct
.	O
accept_regex	pointer
)	O
)	O
)	O
{	O
new_job	pointer
->	O
head_first	bool
=	O
1	int
;	O
new_job	pointer
->	O
recursive_send_head	bool
=	O
1	int
;	O
}	O
if	O
(	O
(	O
config	struct
.	O
reject_patterns	pointer
&&	O
in_pattern_list	function
(	O
config	struct
.	O
reject_patterns	pointer
,	O
new_job	pointer
->	O
iri	pointer
->	O
uri	pointer
)	O
)	O
||	O
(	O
config	struct
.	O
reject_regex	pointer
&&	O
regex_match	function
(	O
new_job	pointer
->	O
iri	pointer
->	O
uri	pointer
,	O
config	struct
.	O
reject_regex	pointer
)	O
)	O
)	O
{	O
new_job	pointer
->	O
head_first	bool
=	O
1	int
;	O
new_job	pointer
->	O
recursive_send_head	bool
=	O
1	int
;	O
}	O
}	O
if	O
(	O
config	struct
.	O
recursive	char
)	O
new_job	pointer
->	O
requested_by_user	bool
=	O
1	int
;	O
if	O
(	O
config	struct
.	O
spider	char
||	O
config	struct
.	O
chunk_size	long
||	O
config	struct
.	O
mime_types	pointer
||	O
(	O
!	O
config	struct
.	O
if_modified_since	char
&&	O
config	struct
.	O
timestamping	char
)	O
)	O
new_job	pointer
->	O
head_first	bool
=	O
1	int
;	O
if	O
(	O
config	struct
.	O
auth_no_challenge	bool
)	O
{	O
new_job	pointer
->	O
challenges	pointer
=	O
config	struct
.	O
default_challenges	pointer
;	O
new_job	pointer
->	O
challenges_alloc	bool
=	O
false	int
;	O
}	O
host_add_job	function
(	O
host	pointer
,	O
new_job	pointer
)	O
;	O
wget_thread_mutex_unlock	function
(	O
downloader_mutex	pointer
)	O
;	O
plugin_db_forward_url_verdict_free	function
(	O
&	O
plugin_verdict	struct
)	O
;	O
}	O
static	O
void	O
add_url	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
const	O
char	O
*	O
url	pointer
,	O
int	O
flags	int
)	O
{	O
JOB	struct
*	O
new_job	pointer
=	O
NULL	O
,	O
job_buf	struct
;	O
wget_iri	struct
*	O
iri	pointer
;	O
HOST	struct
*	O
host	pointer
;	O
const	O
char	O
*	O
local_filename	pointer
=	O
NULL	O
;	O
struct	O
plugin_db_forward_url_verdict	struct
plugin_verdict	struct
;	O
bool	bool
http_fallback	bool
=	O
0	int
;	O
if	O
(	O
flags	int
&	O
URL_FLG_REDIRECTION	O
)	O
{	O
if	O
(	O
job	pointer
&&	O
job	pointer
->	O
redirection_level	int
>=	O
config	struct
.	O
max_redirect	int
)	O
{	O
debug_printf	O
(	O
"not requesting '%s'. (Max Redirections exceeded)\n"	pointer
,	O
url	pointer
)	O
;	O
return	O
;	O
}	O
}	O
wget_info_printf	function
(	O
_	O
(	O
"Adding URL: %s\n"	pointer
)	O
,	O
url	pointer
)	O
;	O
const	O
char	O
*	O
p	pointer
=	O
NULL	O
;	O
if	O
(	O
config	struct
.	O
cut_url_get_vars	char
)	O
p	pointer
=	O
strchr	function
(	O
url	pointer
,	O
'?'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
char	O
*	O
url_cut	pointer
=	O
wget_strmemdup	function
(	O
url	pointer
,	O
p	pointer
-	O
url	pointer
)	O
;	O
iri	pointer
=	O
wget_iri_parse	function
(	O
url_cut	pointer
,	O
encoding	pointer
)	O
;	O
xfree	O
(	O
url_cut	pointer
)	O
;	O
}	O
else	O
iri	pointer
=	O
wget_iri_parse	function
(	O
url	pointer
,	O
encoding	pointer
)	O
;	O
if	O
(	O
!	O
iri	pointer
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Cannot resolve URI '%s'\n"	pointer
)	O
,	O
url	pointer
)	O
;	O
return	O
;	O
}	O
plugin_db_forward_url	function
(	O
iri	pointer
,	O
&	O
plugin_verdict	struct
)	O
;	O
if	O
(	O
plugin_verdict	struct
.	O
reject	bool
)	O
{	O
debug_printf	O
(	O
"not requesting '%s'. (Plugin Verdict)\n"	pointer
,	O
url	pointer
)	O
;	O
plugin_db_forward_url_verdict_free	function
(	O
&	O
plugin_verdict	struct
)	O
;	O
wget_iri_free	function
(	O
&	O
iri	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
plugin_verdict	struct
.	O
alt_iri	pointer
)	O
{	O
debug_printf	O
(	O
"Plugin changed IRI. %s -> %s\n"	pointer
,	O
iri	pointer
->	O
uri	pointer
,	O
plugin_verdict	struct
.	O
alt_iri	pointer
->	O
uri	pointer
)	O
;	O
wget_iri_free	function
(	O
&	O
iri	pointer
)	O
;	O
iri	pointer
=	O
plugin_verdict	struct
.	O
alt_iri	pointer
;	O
plugin_verdict	struct
.	O
alt_iri	pointer
=	O
NULL	O
;	O
}	O
if	O
(	O
!	O
wget_iri_supported	function
(	O
iri	pointer
)	O
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%s' not followed (unsupported scheme)\n"	pointer
)	O
,	O
url	pointer
)	O
;	O
wget_iri_free	function
(	O
&	O
iri	pointer
)	O
;	O
plugin_db_forward_url_verdict_free	function
(	O
&	O
plugin_verdict	struct
)	O
;	O
return	O
;	O
}	O
if	O
(	O
config	struct
.	O
https_only	char
&&	O
iri	pointer
->	O
scheme	enum
!=	O
WGET_IRI_SCHEME_HTTPS	int
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%s' not followed (https-only requested)\n"	pointer
)	O
,	O
url	pointer
)	O
;	O
wget_iri_free	function
(	O
&	O
iri	pointer
)	O
;	O
plugin_db_forward_url_verdict_free	function
(	O
&	O
plugin_verdict	struct
)	O
;	O
return	O
;	O
}	O
if	O
(	O
iri	pointer
->	O
scheme	enum
==	O
WGET_IRI_SCHEME_HTTP	int
&&	O
config	struct
.	O
https_enforce	char
&&	O
!	O
(	O
flags	int
&	O
URL_FLG_SKIPFALLBACK	O
)	O
)	O
{	O
wget_iri_set_scheme	function
(	O
iri	pointer
,	O
WGET_IRI_SCHEME_HTTPS	int
)	O
;	O
if	O
(	O
config	struct
.	O
https_enforce	char
==	O
WGET_HTTPS_ENFORCE_SOFT	int
)	O
http_fallback	bool
=	O
1	int
;	O
}	O
wget_thread_mutex_lock	function
(	O
downloader_mutex	pointer
)	O
;	O
if	O
(	O
!	O
blacklist_add	function
(	O
iri	pointer
)	O
)	O
{	O
goto	O
out	pointer
;	O
}	O
if	O
(	O
config	struct
.	O
recursive	char
)	O
{	O
const	O
char	O
*	O
reason	array
=	O
NULL	O
;	O
if	O
(	O
!	O
iri	pointer
->	O
host	pointer
)	O
reason	array
=	O
_	O
(	O
"missing ip/host/domain"	pointer
)	O
;	O
else	O
if	O
(	O
job	pointer
&&	O
strcmp	function
(	O
job	pointer
->	O
iri	pointer
->	O
host	pointer
,	O
iri	pointer
->	O
host	pointer
)	O
)	O
{	O
if	O
(	O
!	O
config	struct
.	O
span_hosts	char
&&	O
!	O
in_host_pattern_list	function
(	O
config	struct
.	O
domains	pointer
,	O
iri	pointer
->	O
host	pointer
)	O
)	O
reason	array
=	O
_	O
(	O
"no host-spanning requested"	pointer
)	O
;	O
else	O
if	O
(	O
config	struct
.	O
span_hosts	char
&&	O
in_host_pattern_list	function
(	O
config	struct
.	O
exclude_domains	pointer
,	O
iri	pointer
->	O
host	pointer
)	O
)	O
reason	array
=	O
_	O
(	O
"domain explicitly excluded"	pointer
)	O
;	O
}	O
if	O
(	O
reason	array
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%s' not followed (%s)\n"	pointer
)	O
,	O
iri	pointer
->	O
uri	pointer
,	O
reason	array
)	O
;	O
goto	O
out	pointer
;	O
}	O
}	O
if	O
(	O
config	struct
.	O
recursive	char
&&	O
!	O
config	struct
.	O
parent	char
&&	O
!	O
(	O
flags	int
&	O
URL_FLG_REQUISITE	O
)	O
)	O
{	O
bool	bool
ok	bool
=	O
false	int
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
parents	pointer
)	O
;	O
it	int
++	O
)	O
{	O
wget_iri	struct
*	O
parent	char
=	O
wget_vector_get	function
(	O
parents	pointer
,	O
it	int
)	O
;	O
if	O
(	O
!	O
wget_strcmp	function
(	O
parent	char
->	O
host	pointer
,	O
iri	pointer
->	O
host	pointer
)	O
)	O
{	O
if	O
(	O
!	O
parent	char
->	O
dirlen	long
||	O
!	O
wget_strncmp	function
(	O
parent	char
->	O
path	pointer
,	O
iri	pointer
->	O
path	pointer
,	O
parent	char
->	O
dirlen	long
)	O
)	O
{	O
ok	bool
=	O
true	int
;	O
break	O
;	O
}	O
}	O
}	O
if	O
(	O
!	O
ok	bool
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%s' not followed (parent ascending not allowed)\n"	pointer
)	O
,	O
url	pointer
)	O
;	O
goto	O
out	pointer
;	O
}	O
}	O
if	O
(	O
!	O
config	struct
.	O
output_document	pointer
)	O
{	O
if	O
(	O
plugin_verdict	struct
.	O
alt_local_filename	pointer
)	O
{	O
local_filename	pointer
=	O
plugin_verdict	struct
.	O
alt_local_filename	pointer
;	O
plugin_verdict	struct
.	O
alt_local_filename	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
!	O
(	O
flags	int
&	O
URL_FLG_REDIRECTION	O
)	O
||	O
config	struct
.	O
trust_server_names	char
||	O
!	O
job	pointer
)	O
{	O
local_filename	pointer
=	O
get_local_filename	function
(	O
iri	pointer
)	O
;	O
}	O
else	O
{	O
local_filename	pointer
=	O
wget_strdup	function
(	O
job	pointer
->	O
local_filename	pointer
)	O
;	O
}	O
if	O
(	O
!	O
config	struct
.	O
clobber	char
&&	O
local_filename	pointer
&&	O
access	function
(	O
local_filename	pointer
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%s' not requested (file already exists)\n"	pointer
)	O
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
wget_thread_mutex_unlock	function
(	O
downloader_mutex	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
recursive	char
&&	O
(	O
!	O
config	struct
.	O
level	int
||	O
(	O
job	pointer
&&	O
job	pointer
->	O
level	int
<	O
config	struct
.	O
level	int
+	O
config	struct
.	O
page_requisites	char
)	O
)	O
)	O
{	O
parse_localfile	function
(	O
job	pointer
,	O
local_filename	pointer
,	O
encoding	pointer
,	O
NULL	O
,	O
iri	pointer
)	O
;	O
}	O
xfree	O
(	O
local_filename	pointer
)	O
;	O
plugin_db_forward_url_verdict_free	function
(	O
&	O
plugin_verdict	struct
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
(	O
host	pointer
=	O
host_add	function
(	O
iri	pointer
)	O
)	O
)	O
{	O
if	O
(	O
config	struct
.	O
recursive	char
&&	O
config	struct
.	O
robots	pointer
)	O
{	O
if	O
(	O
!	O
config	struct
.	O
clobber	char
&&	O
local_filename	pointer
&&	O
access	function
(	O
local_filename	pointer
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
debug_printf	O
(	O
"not requesting '%s' (File already exists)\n"	pointer
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
}	O
else	O
{	O
wget_iri	struct
*	O
robot_iri	pointer
=	O
wget_iri_parse_base	function
(	O
iri	pointer
,	O
"/robots.txt"	pointer
,	O
encoding	pointer
)	O
;	O
if	O
(	O
blacklist_add	function
(	O
robot_iri	pointer
)	O
)	O
host_add_robotstxt_job	function
(	O
host	pointer
,	O
robot_iri	pointer
,	O
http_fallback	bool
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
(	O
host	pointer
=	O
host_get	function
(	O
iri	pointer
)	O
)	O
)	O
{	O
if	O
(	O
host	pointer
->	O
robots	pointer
&&	O
iri	pointer
->	O
path	pointer
)	O
{	O
for	O
(	O
int	O
it	int
=	O
0	int
,	O
n	long
=	O
wget_robots_get_path_count	function
(	O
host	pointer
->	O
robots	pointer
)	O
;	O
it	int
<	O
n	long
;	O
it	int
++	O
)	O
{	O
wget_string	struct
*	O
path	pointer
=	O
wget_robots_get_path	function
(	O
host	pointer
->	O
robots	pointer
,	O
it	int
)	O
;	O
if	O
(	O
path	pointer
->	O
len	long
&&	O
!	O
strncmp	function
(	O
path	pointer
->	O
p	pointer
+	O
1	int
,	O
iri	pointer
->	O
path	pointer
?	O
iri	pointer
->	O
path	pointer
:	O
""	pointer
,	O
path	pointer
->	O
len	long
-	O
1	int
)	O
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%s' not followed (disallowed by robots.txt)\n"	pointer
)	O
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
goto	O
out	pointer
;	O
}	O
}	O
}	O
}	O
else	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to get '%s' from hosts\n"	pointer
)	O
,	O
iri	pointer
->	O
host	pointer
)	O
;	O
goto	O
out	pointer
;	O
}	O
if	O
(	O
config	struct
.	O
recursive	char
&&	O
config	struct
.	O
filter_urls	char
)	O
{	O
if	O
(	O
(	O
config	struct
.	O
accept_patterns	pointer
&&	O
!	O
in_pattern_list	function
(	O
config	struct
.	O
accept_patterns	pointer
,	O
iri	pointer
->	O
uri	pointer
)	O
)	O
||	O
(	O
config	struct
.	O
accept_regex	pointer
&&	O
!	O
regex_match	function
(	O
iri	pointer
->	O
uri	pointer
,	O
config	struct
.	O
accept_regex	pointer
)	O
)	O
)	O
{	O
debug_printf	O
(	O
"not requesting '%s'. (doesn't match accept pattern)\n"	pointer
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
goto	O
out	pointer
;	O
}	O
if	O
(	O
(	O
config	struct
.	O
reject_patterns	pointer
&&	O
in_pattern_list	function
(	O
config	struct
.	O
reject_patterns	pointer
,	O
iri	pointer
->	O
uri	pointer
)	O
)	O
||	O
(	O
config	struct
.	O
reject_regex	pointer
&&	O
regex_match	function
(	O
iri	pointer
->	O
uri	pointer
,	O
config	struct
.	O
reject_regex	pointer
)	O
)	O
)	O
{	O
debug_printf	O
(	O
"not requesting '%s'. (matches reject pattern)\n"	pointer
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
goto	O
out	pointer
;	O
}	O
if	O
(	O
config	struct
.	O
exclude_directories	pointer
&&	O
in_directory_pattern_list	function
(	O
config	struct
.	O
exclude_directories	pointer
,	O
iri	pointer
->	O
path	pointer
)	O
)	O
{	O
debug_printf	O
(	O
"not requesting '%s' (path excluded)\n"	pointer
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
goto	O
out	pointer
;	O
}	O
}	O
new_job	pointer
=	O
job_init	function
(	O
&	O
job_buf	struct
,	O
iri	pointer
,	O
http_fallback	bool
)	O
;	O
new_job	pointer
->	O
local_filename	pointer
=	O
local_filename	pointer
;	O
local_filename	pointer
=	O
NULL	O
;	O
if	O
(	O
job	pointer
)	O
{	O
if	O
(	O
flags	int
&	O
URL_FLG_REDIRECTION	O
)	O
{	O
new_job	pointer
->	O
parent_id	long long
=	O
job	pointer
->	O
parent_id	long long
;	O
new_job	pointer
->	O
level	int
=	O
job	pointer
->	O
level	int
;	O
new_job	pointer
->	O
redirection_level	int
=	O
job	pointer
->	O
redirection_level	int
+	O
1	int
;	O
new_job	pointer
->	O
referer	pointer
=	O
job	pointer
->	O
referer	pointer
;	O
new_job	pointer
->	O
original_url	pointer
=	O
job	pointer
->	O
iri	pointer
;	O
}	O
else	O
{	O
new_job	pointer
->	O
parent_id	long long
=	O
job	pointer
->	O
id	int
;	O
new_job	pointer
->	O
level	int
=	O
job	pointer
->	O
level	int
+	O
1	int
;	O
new_job	pointer
->	O
referer	pointer
=	O
job	pointer
->	O
iri	pointer
;	O
if	O
(	O
flags	int
&	O
URL_FLG_SIGNATURE_REQ	O
)	O
{	O
if	O
(	O
job	pointer
->	O
sig_req	pointer
)	O
{	O
new_job	pointer
->	O
sig_req	pointer
=	O
wget_strdup	function
(	O
job	pointer
->	O
sig_req	pointer
)	O
;	O
new_job	pointer
->	O
level	int
=	O
job	pointer
->	O
level	int
;	O
}	O
else	O
{	O
new_job	pointer
->	O
sig_req	pointer
=	O
wget_strdup	function
(	O
job	pointer
->	O
iri	pointer
->	O
uri	pointer
)	O
;	O
}	O
new_job	pointer
->	O
sig_filename	pointer
=	O
wget_strdup	function
(	O
job	pointer
->	O
sig_filename	pointer
)	O
;	O
if	O
(	O
job	pointer
->	O
remaining_sig_ext	pointer
)	O
{	O
new_job	pointer
->	O
remaining_sig_ext	pointer
=	O
job	pointer
->	O
remaining_sig_ext	pointer
;	O
job	pointer
->	O
remaining_sig_ext	pointer
=	O
NULL	O
;	O
}	O
}	O
}	O
}	O
if	O
(	O
plugin_verdict	struct
.	O
accept	bool
)	O
{	O
new_job	pointer
->	O
ignore_patterns	bool
=	O
1	int
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
recursive	char
)	O
{	O
if	O
(	O
(	O
config	struct
.	O
accept_patterns	pointer
&&	O
!	O
in_pattern_list	function
(	O
config	struct
.	O
accept_patterns	pointer
,	O
new_job	pointer
->	O
iri	pointer
->	O
uri	pointer
)	O
)	O
||	O
(	O
config	struct
.	O
accept_regex	pointer
&&	O
!	O
regex_match	function
(	O
new_job	pointer
->	O
iri	pointer
->	O
uri	pointer
,	O
config	struct
.	O
accept_regex	pointer
)	O
)	O
)	O
{	O
new_job	pointer
->	O
head_first	bool
=	O
1	int
;	O
new_job	pointer
->	O
recursive_send_head	bool
=	O
1	int
;	O
}	O
if	O
(	O
(	O
config	struct
.	O
reject_patterns	pointer
&&	O
in_pattern_list	function
(	O
config	struct
.	O
reject_patterns	pointer
,	O
new_job	pointer
->	O
iri	pointer
->	O
uri	pointer
)	O
)	O
||	O
(	O
config	struct
.	O
reject_regex	pointer
&&	O
regex_match	function
(	O
new_job	pointer
->	O
iri	pointer
->	O
uri	pointer
,	O
config	struct
.	O
reject_regex	pointer
)	O
)	O
)	O
{	O
new_job	pointer
->	O
head_first	bool
=	O
1	int
;	O
new_job	pointer
->	O
recursive_send_head	bool
=	O
1	int
;	O
}	O
if	O
(	O
config	struct
.	O
exclude_directories	pointer
&&	O
in_directory_pattern_list	function
(	O
config	struct
.	O
exclude_directories	pointer
,	O
new_job	pointer
->	O
iri	pointer
->	O
path	pointer
)	O
)	O
{	O
new_job	pointer
->	O
head_first	bool
=	O
1	int
;	O
new_job	pointer
->	O
recursive_send_head	bool
=	O
1	int
;	O
}	O
}	O
if	O
(	O
config	struct
.	O
spider	char
||	O
config	struct
.	O
chunk_size	long
||	O
config	struct
.	O
mime_types	pointer
||	O
(	O
!	O
config	struct
.	O
if_modified_since	char
&&	O
config	struct
.	O
timestamping	char
)	O
)	O
new_job	pointer
->	O
head_first	bool
=	O
1	int
;	O
if	O
(	O
config	struct
.	O
auth_no_challenge	bool
)	O
new_job	pointer
->	O
challenges	pointer
=	O
config	struct
.	O
default_challenges	pointer
;	O
if	O
(	O
flags	int
&	O
URL_FLG_SITEMAP	O
)	O
new_job	pointer
->	O
sitemap	pointer
=	O
1	int
;	O
host_add_job	function
(	O
host	pointer
,	O
new_job	pointer
)	O
;	O
wget_thread_cond_signal	function
(	O
worker_cond	pointer
)	O
;	O
out	pointer
:	O
xfree	O
(	O
local_filename	pointer
)	O
;	O
wget_thread_mutex_unlock	function
(	O
downloader_mutex	pointer
)	O
;	O
plugin_db_forward_url_verdict_free	function
(	O
&	O
plugin_verdict	struct
)	O
;	O
}	O
static	O
void	O
_convert_links	function
(	O
void	O
)	O
{	O
FILE	struct
*	O
fpout	pointer
=	O
NULL	O
;	O
wget_buffer	struct
buf	pointer
;	O
char	O
sbuf	array
[	O
1024	int
]	O
;	O
wget_buffer_init	function
(	O
&	O
buf	pointer
,	O
sbuf	array
,	O
sizeof	O
(	O
sbuf	array
)	O
)	O
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
conversions	pointer
)	O
;	O
it	int
++	O
)	O
{	O
_conversion_t	struct
*	O
conversion	pointer
=	O
wget_vector_get	function
(	O
conversions	pointer
,	O
it	int
)	O
;	O
const	O
char	O
*	O
data	pointer
,	O
*	O
data_ptr	pointer
;	O
size_t	long
data_length	long
;	O
wget_info_printf	function
(	O
_	O
(	O
"convert %s %s %s\n"	pointer
)	O
,	O
conversion	pointer
->	O
filename	pointer
,	O
conversion	pointer
->	O
base_url	pointer
->	O
uri	pointer
,	O
conversion	pointer
->	O
encoding	pointer
)	O
;	O
if	O
(	O
!	O
(	O
data	pointer
=	O
data_ptr	pointer
=	O
wget_read_file	function
(	O
conversion	pointer
->	O
filename	pointer
,	O
&	O
data_length	long
)	O
)	O
)	O
{	O
wget_error_printf	function
(	O
_	O
(	O
"%s not found (%d)\n"	pointer
)	O
,	O
conversion	pointer
->	O
filename	pointer
,	O
errno	O
)	O
;	O
continue	O
;	O
}	O
for	O
(	O
int	O
it2	int
=	O
0	int
;	O
it2	int
<	O
wget_vector_size	function
(	O
conversion	pointer
->	O
parsed	pointer
->	O
uris	pointer
)	O
;	O
it2	int
++	O
)	O
{	O
wget_html_parsed_url	struct
*	O
html_url	pointer
=	O
wget_vector_get	function
(	O
conversion	pointer
->	O
parsed	pointer
->	O
uris	pointer
,	O
it2	int
)	O
;	O
wget_string	struct
*	O
url	pointer
=	O
&	O
html_url	pointer
->	O
url	pointer
;	O
url	pointer
->	O
p	pointer
=	O
(	O
size_t	long
)	O
url	pointer
->	O
p	pointer
+	O
data	pointer
;	O
if	O
(	O
url	pointer
->	O
len	long
>=	O
1	int
&&	O
*	O
url	pointer
->	O
p	pointer
==	O
'#'	O
)	O
continue	O
;	O
if	O
(	O
wget_iri_relative_to_abs	function
(	O
conversion	pointer
->	O
base_url	pointer
,	O
url	pointer
->	O
p	pointer
,	O
url	pointer
->	O
len	long
,	O
&	O
buf	pointer
)	O
)	O
{	O
wget_iri	struct
*	O
iri	pointer
=	O
wget_iri_parse	function
(	O
buf	pointer
.	O
data	pointer
,	O
conversion	pointer
->	O
encoding	pointer
)	O
;	O
if	O
(	O
!	O
iri	pointer
)	O
{	O
wget_error_printf	function
(	O
_	O
(	O
"Cannot resolve URI '%s'\n"	pointer
)	O
,	O
buf	pointer
.	O
data	pointer
)	O
;	O
continue	O
;	O
}	O
const	O
char	O
*	O
filename	pointer
=	O
get_local_filename	function
(	O
iri	pointer
)	O
;	O
if	O
(	O
access	function
(	O
filename	pointer
,	O
W_OK	int
)	O
==	O
0	int
)	O
{	O
const	O
char	O
*	O
linkpath	pointer
=	O
filename	pointer
,	O
*	O
dir	array
=	O
NULL	O
,	O
*	O
p1	pointer
,	O
*	O
p2	pointer
;	O
const	O
char	O
*	O
docpath	pointer
=	O
conversion	pointer
->	O
filename	pointer
;	O
for	O
(	O
dir	array
=	O
p1	pointer
=	O
linkpath	pointer
,	O
p2	pointer
=	O
docpath	pointer
;	O
*	O
p1	pointer
&&	O
*	O
p1	pointer
==	O
*	O
p2	pointer
;	O
p1	pointer
++	O
,	O
p2	pointer
++	O
)	O
if	O
(	O
*	O
p1	pointer
==	O
'/'	O
)	O
dir	array
=	O
p1	pointer
+	O
1	int
;	O
wget_buffer_reset	function
(	O
&	O
buf	pointer
)	O
;	O
while	O
(	O
*	O
p2	pointer
)	O
{	O
if	O
(	O
*	O
p2	pointer
++	O
==	O
'/'	O
)	O
wget_buffer_memcat	function
(	O
&	O
buf	pointer
,	O
"../"	pointer
,	O
3	int
)	O
;	O
}	O
wget_buffer_strcat	function
(	O
&	O
buf	pointer
,	O
dir	array
)	O
;	O
wget_info_printf	function
(	O
"  %.*s -> %s\n"	pointer
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
,	O
linkpath	pointer
)	O
;	O
wget_info_printf	function
(	O
"       -> %s\n"	pointer
,	O
buf	pointer
.	O
data	pointer
)	O
;	O
}	O
else	O
{	O
wget_info_printf	function
(	O
"  %.*s -> %s\n"	pointer
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
,	O
buf	pointer
.	O
data	pointer
)	O
;	O
}	O
if	O
(	O
buf	pointer
.	O
length	long
!=	O
url	pointer
->	O
len	long
||	O
strncmp	function
(	O
buf	pointer
.	O
data	pointer
,	O
url	pointer
->	O
p	pointer
,	O
url	pointer
->	O
len	long
)	O
)	O
{	O
if	O
(	O
!	O
fpout	pointer
)	O
{	O
if	O
(	O
config	struct
.	O
backup_converted	char
)	O
{	O
char	O
dstfile	O
[	O
strlen	function
(	O
conversion	pointer
->	O
filename	pointer
)	O
+	O
5	int
+	O
1	int
]	O
;	O
wget_snprintf	function
(	O
dstfile	O
,	O
sizeof	O
(	O
dstfile	O
)	O
,	O
"%s.orig"	pointer
,	O
conversion	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
rename	function
(	O
conversion	pointer
->	O
filename	pointer
,	O
dstfile	O
)	O
==	O
-	O
1	int
)	O
{	O
wget_error_printf	function
(	O
_	O
(	O
"Failed to rename %s to %s (%d)"	pointer
)	O
,	O
conversion	pointer
->	O
filename	pointer
,	O
dstfile	O
,	O
errno	O
)	O
;	O
}	O
}	O
if	O
(	O
!	O
(	O
fpout	pointer
=	O
fopen	function
(	O
conversion	pointer
->	O
filename	pointer
,	O
"wb"	pointer
)	O
)	O
)	O
wget_error_printf	function
(	O
_	O
(	O
"Failed to write open %s (%d)"	pointer
)	O
,	O
conversion	pointer
->	O
filename	pointer
,	O
errno	O
)	O
;	O
}	O
if	O
(	O
fpout	pointer
)	O
{	O
fwrite	function
(	O
data_ptr	pointer
,	O
1	int
,	O
url	pointer
->	O
p	pointer
-	O
data_ptr	pointer
,	O
fpout	pointer
)	O
;	O
fwrite	function
(	O
buf	pointer
.	O
data	pointer
,	O
1	int
,	O
buf	pointer
.	O
length	long
,	O
fpout	pointer
)	O
;	O
data_ptr	pointer
=	O
url	pointer
->	O
p	pointer
+	O
url	pointer
->	O
len	long
;	O
}	O
}	O
xfree	O
(	O
filename	pointer
)	O
;	O
wget_iri_free	function
(	O
&	O
iri	pointer
)	O
;	O
}	O
}	O
if	O
(	O
fpout	pointer
)	O
{	O
fwrite	function
(	O
data_ptr	pointer
,	O
1	int
,	O
(	O
data	pointer
+	O
data_length	long
)	O
-	O
data_ptr	pointer
,	O
fpout	pointer
)	O
;	O
fclose	function
(	O
fpout	pointer
)	O
;	O
fpout	pointer
=	O
NULL	O
;	O
}	O
xfree	O
(	O
data	pointer
)	O
;	O
}	O
wget_buffer_deinit	function
(	O
&	O
buf	pointer
)	O
;	O
}	O
static	O
void	O
print_status	function
(	O
DOWNLOADER	struct
*	O
downloader	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
WGET_GCC_NONNULL_ALL	O
WGET_GCC_PRINTF_FORMAT	O
(	O
2	int
,	O
3	int
)	O
;	O
static	O
void	O
print_status	function
(	O
DOWNLOADER	struct
*	O
downloader	pointer
WGET_GCC_UNUSED	O
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
if	O
(	O
config	struct
.	O
verbose	char
)	O
{	O
va_list	array
args	array
;	O
va_start	O
(	O
args	array
,	O
fmt	pointer
)	O
;	O
wget_info_vprintf	function
(	O
fmt	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
}	O
}	O
static	O
void	O
print_progress_report	function
(	O
long	O
long	O
start_time	long long
)	O
{	O
if	O
(	O
config	struct
.	O
progress	char
)	O
{	O
char	O
quota_buf	array
[	O
16	int
]	O
;	O
char	O
speed_buf	array
[	O
16	int
]	O
;	O
char	O
rs_type	char
=	O
(	O
config	struct
.	O
report_speed	enum
==	O
WGET_REPORT_SPEED_BYTES	int
)	O
?	O
'B'	O
:	O
'b'	O
;	O
long	O
long	O
tdiff	long long
=	O
wget_get_timemillis	function
(	O
)	O
-	O
start_time	long long
;	O
if	O
(	O
!	O
tdiff	long long
)	O
tdiff	long long
=	O
1	int
;	O
unsigned	O
int	O
mod	int
=	O
1000	int
*	O
(	O
(	O
config	struct
.	O
report_speed	enum
==	O
WGET_REPORT_SPEED_BYTES	int
)	O
?	O
1	int
:	O
8	int
)	O
;	O
if	O
(	O
config	struct
.	O
spider	char
)	O
bar_printf	function
(	O
nthreads	int
,	O
"Headers: %d (%d redirects & %d errors) Bytes: %s [%s%c/s] Todo: %d"	pointer
,	O
stats	pointer
.	O
nerrors	int
+	O
stats	pointer
.	O
ndownloads	int
+	O
stats	pointer
.	O
nredirects	int
+	O
stats	pointer
.	O
nnotmodified	int
,	O
stats	pointer
.	O
nredirects	int
,	O
stats	pointer
.	O
nerrors	int
,	O
wget_human_readable	function
(	O
quota_buf	array
,	O
sizeof	O
(	O
quota_buf	array
)	O
,	O
quota	long long
)	O
,	O
wget_human_readable	function
(	O
speed_buf	array
,	O
sizeof	O
(	O
speed_buf	array
)	O
,	O
(	O
quota	long long
*	O
mod	int
)	O
/	O
tdiff	long long
)	O
,	O
rs_type	char
,	O
queue_size	function
(	O
)	O
)	O
;	O
else	O
bar_printf	function
(	O
nthreads	int
,	O
"Files: %d  Bytes: %s [%s%c/s] Redirects: %d  Todo: %d  Errors: %d"	pointer
,	O
stats	pointer
.	O
ndownloads	int
,	O
wget_human_readable	function
(	O
quota_buf	array
,	O
sizeof	O
(	O
quota_buf	array
)	O
,	O
quota	long long
)	O
,	O
wget_human_readable	function
(	O
speed_buf	array
,	O
sizeof	O
(	O
speed_buf	array
)	O
,	O
(	O
quota	long long
*	O
mod	int
)	O
/	O
tdiff	long long
)	O
,	O
rs_type	char
,	O
stats	pointer
.	O
nredirects	int
,	O
queue_size	function
(	O
)	O
,	O
stats	pointer
.	O
nerrors	int
)	O
;	O
}	O
}	O
int	O
main	function
(	O
int	O
argc	int
,	O
const	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
n	long
,	O
rc	int
;	O
char	O
quota_buf	array
[	O
16	int
]	O
;	O
long	O
long	O
start_time	long long
=	O
0	int
;	O
_wget_init	function
(	O
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_PARSE_INIT	int
)	O
;	O
n	long
=	O
init	pointer
(	O
argc	int
,	O
argv	pointer
)	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
{	O
goto	O
out	pointer
;	O
}	O
set_exit_status	function
(	O
WG_EXIT_STATUS_NO_ERROR	int
)	O
;	O
for	O
(	O
;	O
n	long
<	O
argc	int
;	O
n	long
++	O
)	O
{	O
add_url_to_queue	function
(	O
argv	pointer
[	O
n	long
]	O
,	O
config	struct
.	O
base	pointer
,	O
config	struct
.	O
local_encoding	pointer
,	O
0	int
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
input_file	pointer
)	O
{	O
if	O
(	O
config	struct
.	O
force_html	char
)	O
{	O
html_parse_localfile	function
(	O
NULL	O
,	O
0	int
,	O
config	struct
.	O
input_file	pointer
,	O
config	struct
.	O
input_encoding	pointer
,	O
config	struct
.	O
base	pointer
)	O
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
force_css	char
)	O
{	O
css_parse_localfile	function
(	O
NULL	O
,	O
config	struct
.	O
input_file	pointer
,	O
config	struct
.	O
input_encoding	pointer
,	O
config	struct
.	O
base	pointer
)	O
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
force_sitemap	char
)	O
{	O
sitemap_parse_xml_localfile	function
(	O
NULL	O
,	O
config	struct
.	O
input_file	pointer
,	O
"utf-8"	pointer
,	O
config	struct
.	O
base	pointer
)	O
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
force_atom	char
)	O
{	O
atom_parse_localfile	function
(	O
NULL	O
,	O
config	struct
.	O
input_file	pointer
,	O
"utf-8"	pointer
,	O
config	struct
.	O
base	pointer
)	O
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
force_rss	char
)	O
{	O
rss_parse_localfile	function
(	O
NULL	O
,	O
config	struct
.	O
input_file	pointer
,	O
"utf-8"	pointer
,	O
config	struct
.	O
base	pointer
)	O
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
force_metalink	char
)	O
{	O
metalink_parse_localfile	function
(	O
config	struct
.	O
input_file	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
config	struct
.	O
input_file	pointer
,	O
"-"	pointer
)	O
)	O
{	O
if	O
(	O
isatty	function
(	O
STDIN_FILENO	int
)	O
)	O
{	O
ssize_t	long
len	long
;	O
size_t	long
bufsize	long
=	O
0	int
;	O
char	O
*	O
url	pointer
,	O
*	O
buf	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
len	long
=	O
wget_fdgetline	function
(	O
&	O
buf	pointer
,	O
&	O
bufsize	long
,	O
STDIN_FILENO	int
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
url	pointer
=	O
buf	pointer
;	O
len	long
&&	O
isspace	function
(	O
*	O
url	pointer
)	O
;	O
url	pointer
++	O
,	O
len	long
--	O
)	O
;	O
if	O
(	O
*	O
url	pointer
==	O
'#'	O
||	O
len	long
<=	O
0	int
)	O
continue	O
;	O
for	O
(	O
;	O
len	long
&&	O
isspace	function
(	O
url	pointer
[	O
len	long
-	O
1	int
]	O
)	O
;	O
len	long
--	O
)	O
;	O
url	pointer
[	O
len	long
]	O
=	O
0	int
;	O
add_url_to_queue	function
(	O
buf	pointer
,	O
config	struct
.	O
base	pointer
,	O
config	struct
.	O
input_encoding	pointer
,	O
0	int
)	O
;	O
}	O
xfree	O
(	O
buf	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
rc	int
=	O
wget_thread_start	function
(	O
&	O
input_tid	pointer
,	O
input_thread	function
,	O
NULL	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to start downloader, error %d\n"	pointer
)	O
,	O
rc	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
int	O
fd	array
;	O
ssize_t	long
len	long
;	O
size_t	long
bufsize	long
=	O
0	int
;	O
char	O
*	O
url	pointer
,	O
*	O
buf	pointer
=	O
0	int
;	O
if	O
(	O
(	O
fd	array
=	O
open	function
(	O
config	struct
.	O
input_file	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
>=	O
0	int
)	O
{	O
while	O
(	O
(	O
len	long
=	O
wget_fdgetline	function
(	O
&	O
buf	pointer
,	O
&	O
bufsize	long
,	O
fd	array
)	O
)	O
>=	O
0	int
)	O
{	O
for	O
(	O
url	pointer
=	O
buf	pointer
;	O
len	long
&&	O
isspace	function
(	O
*	O
url	pointer
)	O
;	O
url	pointer
++	O
,	O
len	long
--	O
)	O
;	O
if	O
(	O
*	O
url	pointer
==	O
'#'	O
||	O
len	long
<=	O
0	int
)	O
continue	O
;	O
for	O
(	O
;	O
len	long
&&	O
isspace	function
(	O
url	pointer
[	O
len	long
-	O
1	int
]	O
)	O
;	O
len	long
--	O
)	O
;	O
url	pointer
[	O
len	long
]	O
=	O
0	int
;	O
add_url_to_queue	function
(	O
url	pointer
,	O
config	struct
.	O
base	pointer
,	O
config	struct
.	O
input_encoding	pointer
,	O
0	int
)	O
;	O
}	O
xfree	O
(	O
buf	pointer
)	O
;	O
close	function
(	O
fd	array
)	O
;	O
}	O
else	O
error_printf	O
(	O
_	O
(	O
"Failed to open input file %s\n"	pointer
)	O
,	O
config	struct
.	O
input_file	pointer
)	O
;	O
}	O
}	O
if	O
(	O
queue_size	function
(	O
)	O
==	O
0	int
&&	O
!	O
input_tid	pointer
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Nothing to do - goodbye\n"	pointer
)	O
)	O
;	O
goto	O
out	pointer
;	O
}	O
if	O
(	O
config	struct
.	O
background	char
)	O
fork_to_background	function
(	O
)	O
;	O
if	O
(	O
!	O
wget_thread_support	function
(	O
)	O
)	O
{	O
config	struct
.	O
max_threads	int
=	O
1	int
;	O
if	O
(	O
config	struct
.	O
progress	char
)	O
{	O
config	struct
.	O
progress	char
=	O
0	int
;	O
wget_info_printf	function
(	O
_	O
(	O
"Wget2 built without thread support. Disabling progress report\n"	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
config	struct
.	O
quiet	char
)	O
{	O
if	O
(	O
!	O
config	struct
.	O
force_progress	char
)	O
{	O
config	struct
.	O
progress	char
=	O
0	int
;	O
}	O
}	O
if	O
(	O
config	struct
.	O
progress	char
&&	O
!	O
isatty	function
(	O
STDOUT_FILENO	int
)	O
&&	O
!	O
config	struct
.	O
force_progress	char
)	O
{	O
config	struct
.	O
progress	char
=	O
0	int
;	O
}	O
if	O
(	O
config	struct
.	O
progress	char
)	O
{	O
if	O
(	O
bar_init	function
(	O
)	O
)	O
{	O
wget_logger_set_stream	function
(	O
wget_get_logger	function
(	O
WGET_LOGGER_INFO	int
)	O
,	O
NULL	O
)	O
;	O
start_time	long long
=	O
wget_get_timemillis	function
(	O
)	O
;	O
}	O
}	O
downloaders	pointer
=	O
wget_calloc	function
(	O
config	struct
.	O
max_threads	int
,	O
sizeof	O
(	O
DOWNLOADER	struct
)	O
)	O
;	O
wget_thread_mutex_lock	function
(	O
main_mutex	pointer
)	O
;	O
while	O
(	O
!	O
terminate	bool
)	O
{	O
if	O
(	O
queue_empty	function
(	O
)	O
&&	O
!	O
input_tid	pointer
)	O
{	O
break	O
;	O
}	O
for	O
(	O
;	O
nthreads	int
<	O
config	struct
.	O
max_threads	int
&&	O
nthreads	int
<	O
queue_size	function
(	O
)	O
;	O
nthreads	int
++	O
)	O
{	O
downloaders	pointer
[	O
nthreads	int
]	O
.	O
id	int
=	O
nthreads	int
;	O
if	O
(	O
config	struct
.	O
progress	char
)	O
bar_update_slots	function
(	O
nthreads	int
+	O
1	int
+	O
1	int
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
wget_thread_start	function
(	O
&	O
downloaders	pointer
[	O
nthreads	int
]	O
.	O
thread	pointer
,	O
downloader_thread	function
,	O
&	O
downloaders	pointer
[	O
nthreads	int
]	O
,	O
0	int
)	O
)	O
!=	O
0	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to start downloader, error %d\n"	pointer
)	O
,	O
rc	int
)	O
;	O
}	O
}	O
print_progress_report	function
(	O
start_time	long long
)	O
;	O
if	O
(	O
config	struct
.	O
quota	long long
&&	O
quota	long long
>=	O
config	struct
.	O
quota	long long
)	O
{	O
info_printf	O
(	O
_	O
(	O
"Quota of %lld bytes reached - stopping.\n"	pointer
)	O
,	O
config	struct
.	O
quota	long long
)	O
;	O
break	O
;	O
}	O
wget_thread_cond_wait	function
(	O
main_cond	pointer
,	O
main_mutex	pointer
,	O
0	int
)	O
;	O
debug_printf	O
(	O
"%s: wake up\n"	pointer
,	O
__func__	O
)	O
;	O
}	O
debug_printf	O
(	O
"%s: done\n"	pointer
,	O
__func__	O
)	O
;	O
terminate	bool
=	O
1	int
;	O
wget_thread_cond_signal	function
(	O
worker_cond	pointer
)	O
;	O
wget_thread_mutex_unlock	function
(	O
main_mutex	pointer
)	O
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
nthreads	int
;	O
n	long
++	O
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
wget_thread_join	function
(	O
&	O
downloaders	pointer
[	O
n	long
]	O
.	O
thread	pointer
)	O
)	O
!=	O
0	int
)	O
error_printf	O
(	O
_	O
(	O
"Failed to wait for downloader #%d (%d %d)\n"	pointer
)	O
,	O
n	long
,	O
rc	int
,	O
errno	O
)	O
;	O
}	O
print_progress_report	function
(	O
start_time	long long
)	O
;	O
if	O
(	O
!	O
config	struct
.	O
progress	char
&&	O
(	O
config	struct
.	O
recursive	char
||	O
config	struct
.	O
page_requisites	char
||	O
(	O
config	struct
.	O
input_file	pointer
&&	O
quota	long long
!=	O
0	int
)	O
)	O
&&	O
quota	long long
)	O
{	O
info_printf	O
(	O
_	O
(	O
"Downloaded: %d files, %s bytes, %d redirects, %d errors\n"	pointer
)	O
,	O
stats	pointer
.	O
ndownloads	int
,	O
wget_human_readable	function
(	O
quota_buf	array
,	O
sizeof	O
(	O
quota_buf	array
)	O
,	O
quota	long long
)	O
,	O
stats	pointer
.	O
nredirects	int
,	O
stats	pointer
.	O
nerrors	int
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
save_cookies	pointer
)	O
wget_cookie_db_save	function
(	O
config	struct
.	O
cookie_db	pointer
,	O
config	struct
.	O
save_cookies	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
hsts	bool
&&	O
config	struct
.	O
hsts_file	pointer
&&	O
hsts_changed	int
)	O
wget_hsts_db_save	function
(	O
config	struct
.	O
hsts_db	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
hpkp	pointer
&&	O
config	struct
.	O
hpkp_file	pointer
&&	O
hpkp_changed	int
)	O
wget_hpkp_db_save	function
(	O
config	struct
.	O
hpkp_db	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
tls_resume	char
&&	O
config	struct
.	O
tls_session_file	pointer
&&	O
wget_tls_session_db_changed	function
(	O
config	struct
.	O
tls_session_db	pointer
)	O
)	O
wget_tls_session_db_save	function
(	O
config	struct
.	O
tls_session_db	pointer
,	O
config	struct
.	O
tls_session_file	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
ocsp	char
&&	O
config	struct
.	O
ocsp_file	pointer
)	O
wget_ocsp_db_save	function
(	O
config	struct
.	O
ocsp_db	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
delete_after	char
&&	O
config	struct
.	O
output_document	pointer
)	O
unlink	function
(	O
config	struct
.	O
output_document	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
debug	int
)	O
blacklist_print	function
(	O
)	O
;	O
if	O
(	O
config	struct
.	O
convert_links	char
&&	O
!	O
config	struct
.	O
delete_after	char
)	O
{	O
_convert_links	function
(	O
)	O
;	O
wget_vector_free	function
(	O
&	O
conversions	pointer
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
stats_site_args	pointer
)	O
site_stats_print	function
(	O
)	O
;	O
out	pointer
:	O
if	O
(	O
is_testing	function
(	O
)	O
||	O
wget_match_tail	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
"wget2_noinstall"	pointer
)	O
)	O
{	O
blacklist_free	function
(	O
)	O
;	O
hosts_free	function
(	O
)	O
;	O
xfree	O
(	O
downloaders	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
progress	char
)	O
bar_deinit	function
(	O
)	O
;	O
wget_vector_clear_nofree	function
(	O
parents	pointer
)	O
;	O
wget_vector_free	function
(	O
&	O
parents	pointer
)	O
;	O
wget_hashmap_free	function
(	O
&	O
known_urls	pointer
)	O
;	O
wget_stringmap_free	function
(	O
&	O
etags	pointer
)	O
;	O
deinit	pointer
(	O
)	O
;	O
_wget_deinit	function
(	O
)	O
;	O
}	O
plugin_db_finalize	function
(	O
get_exit_status	function
(	O
)	O
)	O
;	O
return	O
get_exit_status	function
(	O
)	O
;	O
}	O
void	O
*	O
input_thread	function
(	O
void	O
*	O
p	pointer
WGET_GCC_UNUSED	O
)	O
{	O
ssize_t	long
len	long
;	O
size_t	long
bufsize	long
=	O
0	int
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
len	long
=	O
wget_fdgetline	function
(	O
&	O
buf	pointer
,	O
&	O
bufsize	long
,	O
STDIN_FILENO	int
)	O
)	O
>=	O
0	int
)	O
{	O
add_url_to_queue	function
(	O
buf	pointer
,	O
config	struct
.	O
base	pointer
,	O
config	struct
.	O
local_encoding	pointer
,	O
URL_FLG_NO_BLACKLISTING	O
)	O
;	O
if	O
(	O
nthreads	int
<	O
config	struct
.	O
max_threads	int
&&	O
nthreads	int
<	O
queue_size	function
(	O
)	O
)	O
wget_thread_cond_signal	function
(	O
main_cond	pointer
)	O
;	O
else	O
wget_thread_cond_signal	function
(	O
worker_cond	pointer
)	O
;	O
}	O
xfree	O
(	O
buf	pointer
)	O
;	O
debug_printf	O
(	O
"input closed\n"	pointer
)	O
;	O
wget_thread_cond_signal	function
(	O
main_cond	pointer
)	O
;	O
input_tid	pointer
=	O
0	int
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
try_connection	function
(	O
DOWNLOADER	struct
*	O
downloader	pointer
,	O
wget_iri	struct
*	O
iri	pointer
)	O
{	O
wget_http_connection	struct
*	O
conn	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
iri	pointer
->	O
scheme	enum
==	O
WGET_IRI_SCHEME_HTTP	int
)	O
{	O
bool	bool
match	bool
=	O
0	int
;	O
if	O
(	O
config	struct
.	O
hsts	bool
&&	O
wget_hsts_host_match	function
(	O
config	struct
.	O
hsts_db	pointer
,	O
iri	pointer
->	O
host	pointer
,	O
iri	pointer
->	O
port	short
)	O
)	O
{	O
match	bool
=	O
1	int
;	O
}	O
if	O
(	O
match	bool
)	O
{	O
info_printf	O
(	O
_	O
(	O
"HSTS in effect for %s:%hu\n"	pointer
)	O
,	O
iri	pointer
->	O
host	pointer
,	O
iri	pointer
->	O
port	short
)	O
;	O
wget_iri_set_scheme	function
(	O
iri	pointer
,	O
WGET_IRI_SCHEME_HTTPS	int
)	O
;	O
host_add	function
(	O
iri	pointer
)	O
;	O
}	O
}	O
if	O
(	O
(	O
conn	pointer
=	O
downloader	pointer
->	O
conn	pointer
)	O
)	O
{	O
if	O
(	O
!	O
wget_strcmp	function
(	O
wget_http_get_host	function
(	O
conn	pointer
)	O
,	O
iri	pointer
->	O
host	pointer
)	O
&&	O
wget_http_get_scheme	function
(	O
conn	pointer
)	O
==	O
iri	pointer
->	O
scheme	enum
&&	O
wget_http_get_port	function
(	O
conn	pointer
)	O
==	O
iri	pointer
->	O
port	short
)	O
{	O
debug_printf	O
(	O
"reuse connection %s\n"	pointer
,	O
wget_http_get_host	function
(	O
conn	pointer
)	O
)	O
;	O
return	O
WGET_E_SUCCESS	int
;	O
}	O
debug_printf	O
(	O
"close connection %s\n"	pointer
,	O
wget_http_get_host	function
(	O
conn	pointer
)	O
)	O
;	O
wget_http_close	function
(	O
&	O
downloader	pointer
->	O
conn	pointer
)	O
;	O
}	O
if	O
(	O
(	O
rc	int
=	O
wget_http_open	function
(	O
&	O
downloader	pointer
->	O
conn	pointer
,	O
iri	pointer
)	O
)	O
==	O
WGET_E_SUCCESS	int
)	O
{	O
debug_printf	O
(	O
"established connection %s\n"	pointer
,	O
wget_http_get_host	function
(	O
downloader	pointer
->	O
conn	pointer
)	O
)	O
;	O
}	O
else	O
{	O
info_printf	O
(	O
_	O
(	O
"Failed to connect: %s\n"	pointer
)	O
,	O
wget_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
return	O
rc	int
;	O
}	O
static	O
int	O
establish_connection	function
(	O
DOWNLOADER	struct
*	O
downloader	pointer
,	O
wget_iri	struct
*	O
*	O
iri	pointer
)	O
{	O
int	O
rc	int
=	O
WGET_E_UNKNOWN	int
;	O
downloader	pointer
->	O
final_error	bool
=	O
0	int
;	O
if	O
(	O
downloader	pointer
->	O
job	pointer
->	O
part	pointer
)	O
{	O
JOB	struct
*	O
job	pointer
=	O
downloader	pointer
->	O
job	pointer
;	O
wget_metalink	struct
*	O
metalink	pointer
=	O
job	pointer
->	O
metalink	pointer
;	O
PART	struct
*	O
part	pointer
=	O
job	pointer
->	O
part	pointer
;	O
int	O
mirror_count	int
=	O
wget_vector_size	function
(	O
metalink	pointer
->	O
mirrors	pointer
)	O
;	O
int	O
mirror_index	int
;	O
if	O
(	O
mirror_count	int
>	O
0	int
)	O
mirror_index	int
=	O
downloader	pointer
->	O
id	int
%	O
mirror_count	int
;	O
else	O
{	O
host_final_failure	function
(	O
downloader	pointer
->	O
job	pointer
->	O
host	pointer
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_NETWORK	int
)	O
;	O
return	O
rc	int
;	O
}	O
for	O
(	O
int	O
tries	int
=	O
0	int
;	O
tries	int
<	O
config	struct
.	O
tries	int
&&	O
!	O
part	pointer
->	O
done	bool
&&	O
!	O
terminate	bool
;	O
tries	int
++	O
)	O
{	O
wget_millisleep	function
(	O
tries	int
*	O
1000	int
>	O
config	struct
.	O
waitretry	int
?	O
config	struct
.	O
waitretry	int
:	O
tries	int
*	O
1000	int
)	O
;	O
if	O
(	O
terminate	bool
)	O
break	O
;	O
for	O
(	O
int	O
mirrors	pointer
=	O
0	int
;	O
mirrors	pointer
<	O
wget_vector_size	function
(	O
metalink	pointer
->	O
mirrors	pointer
)	O
&&	O
!	O
part	pointer
->	O
done	bool
;	O
mirrors	pointer
++	O
)	O
{	O
wget_metalink_mirror	struct
*	O
mirror	char
=	O
wget_vector_get	function
(	O
metalink	pointer
->	O
mirrors	pointer
,	O
mirror_index	int
)	O
;	O
mirror_index	int
=	O
(	O
mirror_index	int
+	O
1	int
)	O
%	O
wget_vector_size	function
(	O
metalink	pointer
->	O
mirrors	pointer
)	O
;	O
if	O
(	O
mirror	char
->	O
iri	pointer
->	O
scheme	enum
==	O
WGET_IRI_SCHEME_HTTP	int
&&	O
config	struct
.	O
https_enforce	char
)	O
{	O
wget_iri_set_scheme	function
(	O
mirror	char
->	O
iri	pointer
,	O
WGET_IRI_SCHEME_HTTPS	int
)	O
;	O
}	O
rc	int
=	O
try_connection	function
(	O
downloader	pointer
,	O
mirror	char
->	O
iri	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
WGET_E_SUCCESS	int
)	O
{	O
host_add	function
(	O
mirror	char
->	O
iri	pointer
)	O
;	O
if	O
(	O
iri	pointer
)	O
*	O
iri	pointer
=	O
mirror	char
->	O
iri	pointer
;	O
return	O
rc	int
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
WGET_E_TLS_DISABLED	int
)	O
{	O
tries	int
=	O
config	struct
.	O
tries	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
else	O
{	O
rc	int
=	O
try_connection	function
(	O
downloader	pointer
,	O
*	O
iri	pointer
)	O
;	O
}	O
if	O
(	O
rc	int
==	O
WGET_E_HANDSHAKE	int
||	O
rc	int
==	O
WGET_E_CERTIFICATE	int
||	O
rc	int
==	O
WGET_E_TLS_DISABLED	int
)	O
{	O
wget_http_close	function
(	O
&	O
downloader	pointer
->	O
conn	pointer
)	O
;	O
if	O
(	O
!	O
downloader	pointer
->	O
job	pointer
->	O
http_fallback	bool
)	O
{	O
host_final_failure	function
(	O
downloader	pointer
->	O
job	pointer
->	O
host	pointer
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_TLS	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
rc	int
==	O
WGET_E_CONNECT	int
)	O
{	O
wget_http_close	function
(	O
&	O
downloader	pointer
->	O
conn	pointer
)	O
;	O
if	O
(	O
!	O
config	struct
.	O
retry_connrefused	char
&&	O
!	O
downloader	pointer
->	O
job	pointer
->	O
http_fallback	bool
)	O
{	O
host_final_failure	function
(	O
downloader	pointer
->	O
job	pointer
->	O
host	pointer
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_NETWORK	int
)	O
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
static	O
void	O
add_statistics	function
(	O
wget_http_response	struct
*	O
resp	pointer
)	O
{	O
JOB	struct
*	O
job	pointer
=	O
resp	pointer
->	O
req	pointer
->	O
user_data	pointer
;	O
if	O
(	O
resp	pointer
->	O
code	short
==	O
200	int
)	O
{	O
if	O
(	O
job	pointer
->	O
part	pointer
)	O
_atomic_increment_int	function
(	O
&	O
stats	pointer
.	O
nchunks	int
)	O
;	O
else	O
_atomic_increment_int	function
(	O
&	O
stats	pointer
.	O
ndownloads	int
)	O
;	O
}	O
else	O
if	O
(	O
resp	pointer
->	O
code	short
==	O
301	int
||	O
resp	pointer
->	O
code	short
==	O
302	int
||	O
resp	pointer
->	O
code	short
==	O
303	int
||	O
resp	pointer
->	O
code	short
==	O
307	int
||	O
resp	pointer
->	O
code	short
==	O
308	int
)	O
_atomic_increment_int	function
(	O
&	O
stats	pointer
.	O
nredirects	int
)	O
;	O
else	O
if	O
(	O
resp	pointer
->	O
code	short
==	O
304	int
)	O
_atomic_increment_int	function
(	O
&	O
stats	pointer
.	O
nnotmodified	int
)	O
;	O
else	O
_atomic_increment_int	function
(	O
&	O
stats	pointer
.	O
nerrors	int
)	O
;	O
if	O
(	O
config	struct
.	O
stats_site_args	pointer
)	O
stats_site_add	function
(	O
resp	pointer
,	O
NULL	O
)	O
;	O
}	O
static	O
int	O
process_response_header	function
(	O
wget_http_response	struct
*	O
resp	pointer
)	O
{	O
JOB	struct
*	O
job	pointer
=	O
resp	pointer
->	O
req	pointer
->	O
user_data	pointer
;	O
DOWNLOADER	struct
*	O
downloader	pointer
=	O
job	pointer
->	O
downloader	pointer
;	O
wget_iri	struct
*	O
iri	pointer
=	O
job	pointer
->	O
iri	pointer
;	O
if	O
(	O
resp	pointer
->	O
code	short
<	O
400	int
||	O
resp	pointer
->	O
code	short
>	O
599	int
)	O
print_status	function
(	O
downloader	pointer
,	O
"HTTP response %d %s [%s]\n"	pointer
,	O
resp	pointer
->	O
code	short
,	O
resp	pointer
->	O
reason	array
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
else	O
print_status	function
(	O
downloader	pointer
,	O
"HTTP ERROR response %d %s [%s]\n"	pointer
,	O
resp	pointer
->	O
code	short
,	O
resp	pointer
->	O
reason	array
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
if	O
(	O
resp	pointer
->	O
code	short
/	O
100	int
==	O
4	int
&&	O
resp	pointer
->	O
code	short
!=	O
416	int
)	O
{	O
if	O
(	O
job	pointer
->	O
head_first	bool
)	O
set_exit_status	function
(	O
WG_EXIT_STATUS_REMOTE	int
)	O
;	O
else	O
if	O
(	O
resp	pointer
->	O
code	short
==	O
404	int
&&	O
!	O
job	pointer
->	O
robotstxt	bool
)	O
{	O
set_exit_status	function
(	O
WG_EXIT_STATUS_REMOTE	int
)	O
;	O
}	O
}	O
debug_printf	O
(	O
"keep_alive=%d\n"	pointer
,	O
resp	pointer
->	O
keep_alive	char
)	O
;	O
if	O
(	O
!	O
resp	pointer
->	O
keep_alive	char
)	O
wget_http_close	function
(	O
&	O
downloader	pointer
->	O
conn	pointer
)	O
;	O
add_statistics	function
(	O
resp	pointer
)	O
;	O
wget_cookie_normalize_cookies	function
(	O
job	pointer
->	O
iri	pointer
,	O
resp	pointer
->	O
cookies	pointer
)	O
;	O
wget_cookie_store_cookies	function
(	O
config	struct
.	O
cookie_db	pointer
,	O
resp	pointer
->	O
cookies	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
hsts	bool
&&	O
iri	pointer
->	O
scheme	enum
==	O
WGET_IRI_SCHEME_HTTPS	int
&&	O
!	O
iri	pointer
->	O
is_ip_address	bool
&&	O
resp	pointer
->	O
hsts	bool
)	O
{	O
wget_hsts_db_add	function
(	O
config	struct
.	O
hsts_db	pointer
,	O
iri	pointer
->	O
host	pointer
,	O
iri	pointer
->	O
port	short
,	O
resp	pointer
->	O
hsts_maxage	long
,	O
resp	pointer
->	O
hsts_include_subdomains	char
)	O
;	O
hsts_changed	int
=	O
1	int
;	O
}	O
if	O
(	O
config	struct
.	O
hpkp	pointer
&&	O
iri	pointer
->	O
scheme	enum
==	O
WGET_IRI_SCHEME_HTTPS	int
&&	O
!	O
iri	pointer
->	O
is_ip_address	bool
&&	O
resp	pointer
->	O
hpkp	pointer
)	O
{	O
wget_hpkp_set_host	function
(	O
resp	pointer
->	O
hpkp	pointer
,	O
iri	pointer
->	O
host	pointer
)	O
;	O
wget_hpkp_db_add	function
(	O
config	struct
.	O
hpkp_db	pointer
,	O
&	O
resp	pointer
->	O
hpkp	pointer
)	O
;	O
hpkp_changed	int
=	O
1	int
;	O
}	O
if	O
(	O
resp	pointer
->	O
code	short
==	O
302	int
&&	O
resp	pointer
->	O
links	pointer
&&	O
resp	pointer
->	O
digests	pointer
)	O
return	O
0	int
;	O
if	O
(	O
resp	pointer
->	O
code	short
==	O
401	int
)	O
{	O
job	pointer
->	O
auth_failure_count	int
++	O
;	O
if	O
(	O
job	pointer
->	O
auth_failure_count	int
>	O
1	int
||	O
!	O
resp	pointer
->	O
challenges	pointer
)	O
{	O
set_exit_status	function
(	O
WG_EXIT_STATUS_AUTH	int
)	O
;	O
return	O
1	int
;	O
}	O
job	pointer
->	O
challenges	pointer
=	O
resp	pointer
->	O
challenges	pointer
;	O
job	pointer
->	O
challenges_alloc	bool
=	O
true	int
;	O
resp	pointer
->	O
challenges	pointer
=	O
NULL	O
;	O
job	pointer
->	O
done	bool
=	O
0	int
;	O
return	O
1	int
;	O
}	O
if	O
(	O
resp	pointer
->	O
code	short
==	O
407	int
)	O
{	O
if	O
(	O
job	pointer
->	O
proxy_challenges	pointer
||	O
!	O
resp	pointer
->	O
challenges	pointer
)	O
{	O
set_exit_status	function
(	O
WG_EXIT_STATUS_AUTH	int
)	O
;	O
return	O
1	int
;	O
}	O
job	pointer
->	O
proxy_challenges	pointer
=	O
resp	pointer
->	O
challenges	pointer
;	O
resp	pointer
->	O
challenges	pointer
=	O
NULL	O
;	O
job	pointer
->	O
done	bool
=	O
0	int
;	O
return	O
1	int
;	O
}	O
if	O
(	O
resp	pointer
->	O
code	short
==	O
416	int
&&	O
!	O
resp	pointer
->	O
cur_downloaded	long
)	O
{	O
info_printf	O
(	O
_	O
(	O
"The file is already fully retrieved; nothing to do.\n"	pointer
)	O
)	O
;	O
}	O
if	O
(	O
resp	pointer
->	O
code	short
/	O
100	int
==	O
2	int
||	O
resp	pointer
->	O
code	short
/	O
100	int
>=	O
4	int
||	O
resp	pointer
->	O
code	short
==	O
304	int
)	O
return	O
0	int
;	O
if	O
(	O
resp	pointer
->	O
location	pointer
)	O
{	O
wget_buffer	struct
uri_buf	struct
;	O
char	O
uri_sbuf	array
[	O
1024	int
]	O
;	O
wget_cookie_normalize_cookies	function
(	O
job	pointer
->	O
iri	pointer
,	O
resp	pointer
->	O
cookies	pointer
)	O
;	O
wget_cookie_store_cookies	function
(	O
config	struct
.	O
cookie_db	pointer
,	O
resp	pointer
->	O
cookies	pointer
)	O
;	O
wget_buffer_init	function
(	O
&	O
uri_buf	struct
,	O
uri_sbuf	array
,	O
sizeof	O
(	O
uri_sbuf	array
)	O
)	O
;	O
wget_iri_relative_to_abs	function
(	O
iri	pointer
,	O
resp	pointer
->	O
location	pointer
,	O
-	O
1	int
,	O
&	O
uri_buf	struct
)	O
;	O
if	O
(	O
uri_buf	struct
.	O
length	long
)	O
add_url	function
(	O
job	pointer
,	O
"utf-8"	pointer
,	O
uri_buf	struct
.	O
data	pointer
,	O
URL_FLG_REDIRECTION	O
)	O
;	O
wget_buffer_deinit	function
(	O
&	O
uri_buf	struct
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
bool	bool
check_status_code_list	function
(	O
wget_vector	struct
*	O
list	pointer
,	O
uint16_t	short
status	int
)	O
;	O
static	O
bool	bool
check_mime_list	function
(	O
wget_vector	struct
*	O
list	pointer
,	O
const	O
char	O
*	O
mime	pointer
)	O
;	O
static	O
time_t	long
WGET_GCC_NONNULL_ALL	O
get_file_lmtime	function
(	O
const	O
char	O
*	O
fname	pointer
)	O
;	O
static	O
void	O
process_head_response	function
(	O
wget_http_response	struct
*	O
resp	pointer
)	O
{	O
JOB	struct
*	O
job	pointer
=	O
resp	pointer
->	O
req	pointer
->	O
user_data	pointer
;	O
job	pointer
->	O
head_first	bool
=	O
0	int
;	O
long	O
long	O
file_size	long long
=	O
(	O
job	pointer
->	O
local_filename	pointer
)	O
?	O
get_file_size	function
(	O
job	pointer
->	O
local_filename	pointer
)	O
:	O
-	O
1	int
;	O
if	O
(	O
config	struct
.	O
timestamping	char
&&	O
!	O
config	struct
.	O
if_modified_since	char
&&	O
resp	pointer
->	O
code	short
==	O
200	int
&&	O
file_size	long long
==	O
(	O
long	O
long	O
)	O
resp	pointer
->	O
content_length	long
&&	O
resp	pointer
->	O
last_modified	long
<=	O
get_file_lmtime	function
(	O
job	pointer
->	O
local_filename	pointer
)	O
)	O
{	O
info_printf	O
(	O
_	O
(	O
"File '%s' not modified on server. Omitting download"	pointer
)	O
,	O
job	pointer
->	O
local_filename	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
recursive	char
&&	O
(	O
!	O
config	struct
.	O
level	int
||	O
job	pointer
->	O
level	int
<	O
config	struct
.	O
level	int
+	O
config	struct
.	O
page_requisites	char
)	O
)	O
parse_localfile	function
(	O
job	pointer
,	O
job	pointer
->	O
local_filename	pointer
,	O
resp	pointer
->	O
content_type_encoding	pointer
,	O
resp	pointer
->	O
content_type	pointer
,	O
job	pointer
->	O
iri	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
config	struct
.	O
spider	char
||	O
(	O
config	struct
.	O
recursive	char
&&	O
(	O
config	struct
.	O
mime_types	pointer
||	O
job	pointer
->	O
recursive_send_head	bool
)	O
)	O
)	O
{	O
if	O
(	O
resp	pointer
->	O
code	short
!=	O
200	int
||	O
!	O
resp	pointer
->	O
content_type	pointer
)	O
return	O
;	O
if	O
(	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"text/html"	pointer
)	O
&&	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"text/css"	pointer
)	O
&&	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/xhtml+xml"	pointer
)	O
&&	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/atom+xml"	pointer
)	O
&&	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/rss+xml"	pointer
)	O
&&	O
(	O
!	O
job	pointer
->	O
sitemap	pointer
||	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/xml"	pointer
)	O
)	O
&&	O
(	O
!	O
job	pointer
->	O
sitemap	pointer
||	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/x-gzip"	pointer
)	O
)	O
&&	O
(	O
!	O
job	pointer
->	O
sitemap	pointer
||	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"text/plain"	pointer
)	O
)	O
&&	O
(	O
!	O
config	struct
.	O
mime_types	pointer
||	O
!	O
check_mime_list	function
(	O
config	struct
.	O
mime_types	pointer
,	O
resp	pointer
->	O
content_type	pointer
)	O
)	O
)	O
{	O
return	O
;	O
}	O
if	O
(	O
resp	pointer
->	O
etag	pointer
)	O
{	O
wget_thread_mutex_lock	function
(	O
etag_mutex	pointer
)	O
;	O
if	O
(	O
!	O
etags	pointer
)	O
etags	pointer
=	O
wget_stringmap_create	function
(	O
128	int
)	O
;	O
int	O
rc	int
=	O
wget_stringmap_put	function
(	O
etags	pointer
,	O
resp	pointer
->	O
etag	pointer
,	O
NULL	O
)	O
;	O
resp	pointer
->	O
etag	pointer
=	O
NULL	O
;	O
wget_thread_mutex_unlock	function
(	O
etag_mutex	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
info_printf	O
(	O
_	O
(	O
"Not scanning '%s' (known ETag)\n"	pointer
)	O
,	O
job	pointer
->	O
iri	pointer
->	O
uri	pointer
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
config	struct
.	O
spider	char
&&	O
!	O
config	struct
.	O
recursive	char
)	O
return	O
;	O
job	pointer
->	O
done	bool
=	O
0	int
;	O
return	O
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
chunk_size	long
&&	O
resp	pointer
->	O
content_length	long
>	O
config	struct
.	O
chunk_size	long
)	O
{	O
wget_metalink_piece	struct
piece	struct
=	O
{	O
.	O
length	long
=	O
config	struct
.	O
chunk_size	long
}	O
;	O
wget_metalink_mirror	struct
mirror	char
=	O
{	O
.	O
location	pointer
=	O
"-"	pointer
,	O
.	O
iri	pointer
=	O
job	pointer
->	O
iri	pointer
}	O
;	O
wget_metalink	struct
*	O
metalink	pointer
=	O
wget_calloc	function
(	O
1	int
,	O
sizeof	O
(	O
wget_metalink	struct
)	O
)	O
;	O
metalink	pointer
->	O
size	pointer
=	O
resp	pointer
->	O
content_length	long
;	O
metalink	pointer
->	O
name	pointer
=	O
wget_strdup	function
(	O
config	struct
.	O
output_document	pointer
?	O
config	struct
.	O
output_document	pointer
:	O
job	pointer
->	O
local_filename	pointer
)	O
;	O
ssize_t	long
npieces	long
=	O
(	O
resp	pointer
->	O
content_length	long
+	O
config	struct
.	O
chunk_size	long
-	O
1	int
)	O
/	O
config	struct
.	O
chunk_size	long
;	O
metalink	pointer
->	O
pieces	pointer
=	O
wget_vector_create	function
(	O
(	O
int	O
)	O
npieces	long
,	O
NULL	O
)	O
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
npieces	long
;	O
it	int
++	O
)	O
{	O
piece	struct
.	O
position	long
=	O
it	int
*	O
config	struct
.	O
chunk_size	long
;	O
wget_vector_add_memdup	function
(	O
metalink	pointer
->	O
pieces	pointer
,	O
&	O
piece	struct
,	O
sizeof	O
(	O
wget_metalink_piece	struct
)	O
)	O
;	O
}	O
metalink	pointer
->	O
mirrors	pointer
=	O
wget_vector_create	function
(	O
1	int
,	O
NULL	O
)	O
;	O
wget_vector_add_memdup	function
(	O
metalink	pointer
->	O
mirrors	pointer
,	O
&	O
mirror	char
,	O
sizeof	O
(	O
wget_metalink_mirror	struct
)	O
)	O
;	O
job	pointer
->	O
metalink	pointer
=	O
metalink	pointer
;	O
if	O
(	O
!	O
job_validate_file	function
(	O
job	pointer
)	O
)	O
{	O
wget_thread_cond_signal	function
(	O
worker_cond	pointer
)	O
;	O
job	pointer
->	O
done	bool
=	O
0	int
;	O
}	O
}	O
else	O
if	O
(	O
config	struct
.	O
chunk_size	long
)	O
job	pointer
->	O
done	bool
=	O
0	int
;	O
if	O
(	O
config	struct
.	O
mime_types	pointer
)	O
job	pointer
->	O
done	bool
=	O
check_mime_list	function
(	O
config	struct
.	O
mime_types	pointer
,	O
resp	pointer
->	O
content_type	pointer
?	O
resp	pointer
->	O
content_type	pointer
:	O
"application/octet-stream"	pointer
)	O
?	O
0	int
:	O
1	int
;	O
else	O
if	O
(	O
config	struct
.	O
timestamping	char
&&	O
!	O
config	struct
.	O
if_modified_since	char
&&	O
!	O
config	struct
.	O
chunk_size	long
)	O
{	O
job	pointer
->	O
done	bool
=	O
0	int
;	O
if	O
(	O
config	struct
.	O
timestamping	char
&&	O
!	O
config	struct
.	O
if_modified_since	char
&&	O
file_size	long long
>=	O
0	int
&&	O
file_size	long long
!=	O
(	O
long	O
long	O
)	O
resp	pointer
->	O
content_length	long
)	O
info_printf	O
(	O
_	O
(	O
"The sizes do not match (local %lld, remote %zu) -- retrieving"	pointer
)	O
,	O
file_size	long long
,	O
resp	pointer
->	O
content_length	long
)	O
;	O
}	O
}	O
static	O
void	O
process_response_part	function
(	O
wget_http_response	struct
*	O
resp	pointer
)	O
{	O
JOB	struct
*	O
job	pointer
=	O
resp	pointer
->	O
req	pointer
->	O
user_data	pointer
;	O
DOWNLOADER	struct
*	O
downloader	pointer
=	O
job	pointer
->	O
downloader	pointer
;	O
PART	struct
*	O
part	pointer
=	O
job	pointer
->	O
part	pointer
;	O
if	O
(	O
resp	pointer
->	O
body	pointer
)	O
quota_modify_read	function
(	O
resp	pointer
->	O
cur_downloaded	long
)	O
;	O
if	O
(	O
resp	pointer
->	O
code	short
!=	O
200	int
&&	O
resp	pointer
->	O
code	short
!=	O
206	int
)	O
{	O
print_status	function
(	O
downloader	pointer
,	O
"part %d download error %d\n"	pointer
,	O
part	pointer
->	O
id	int
,	O
resp	pointer
->	O
code	short
)	O
;	O
}	O
else	O
if	O
(	O
!	O
resp	pointer
->	O
body	pointer
)	O
{	O
print_status	function
(	O
downloader	pointer
,	O
"part %d download error 'empty body'\n"	pointer
,	O
part	pointer
->	O
id	int
)	O
;	O
}	O
else	O
if	O
(	O
resp	pointer
->	O
body	pointer
->	O
length	long
!=	O
(	O
size_t	long
)	O
part	pointer
->	O
length	long
)	O
{	O
print_status	function
(	O
downloader	pointer
,	O
"part %d download error '%zu bytes of %lld expected'\n"	pointer
,	O
part	pointer
->	O
id	int
,	O
resp	pointer
->	O
body	pointer
->	O
length	long
,	O
(	O
long	O
long	O
)	O
part	pointer
->	O
length	long
)	O
;	O
}	O
else	O
{	O
print_status	function
(	O
downloader	pointer
,	O
"part %d downloaded\n"	pointer
,	O
part	pointer
->	O
id	int
)	O
;	O
part	pointer
->	O
done	bool
=	O
1	int
;	O
}	O
if	O
(	O
part	pointer
->	O
done	bool
)	O
{	O
int	O
all_done	int
=	O
1	int
,	O
it	int
;	O
wget_thread_mutex_lock	function
(	O
downloader_mutex	pointer
)	O
;	O
for	O
(	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
job	pointer
->	O
parts	pointer
)	O
;	O
it	int
++	O
)	O
{	O
PART	struct
*	O
partp	pointer
=	O
wget_vector_get	function
(	O
job	pointer
->	O
parts	pointer
,	O
it	int
)	O
;	O
if	O
(	O
!	O
partp	pointer
->	O
done	bool
)	O
{	O
all_done	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
wget_thread_mutex_unlock	function
(	O
downloader_mutex	pointer
)	O
;	O
if	O
(	O
all_done	int
)	O
{	O
if	O
(	O
config	struct
.	O
progress	char
)	O
bar_print	function
(	O
downloader	pointer
->	O
id	int
,	O
"Checksumming..."	pointer
)	O
;	O
else	O
if	O
(	O
job	pointer
->	O
metalink	pointer
)	O
print_status	function
(	O
downloader	pointer
,	O
"%s checking...\n"	pointer
,	O
job	pointer
->	O
metalink	pointer
->	O
name	pointer
)	O
;	O
else	O
print_status	function
(	O
downloader	pointer
,	O
"%s checking...\n"	pointer
,	O
job	pointer
->	O
local_filename	pointer
)	O
;	O
if	O
(	O
job_validate_file	function
(	O
job	pointer
)	O
)	O
{	O
if	O
(	O
config	struct
.	O
progress	char
)	O
bar_print	function
(	O
downloader	pointer
->	O
id	int
,	O
"Checksum OK"	pointer
)	O
;	O
else	O
debug_printf	O
(	O
"checksum ok\n"	pointer
)	O
;	O
job	pointer
->	O
done	bool
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
config	struct
.	O
progress	char
)	O
bar_print	function
(	O
downloader	pointer
->	O
id	int
,	O
"Checksum FAILED"	pointer
)	O
;	O
else	O
debug_printf	O
(	O
"checksum failed\n"	pointer
)	O
;	O
}	O
}	O
}	O
else	O
{	O
print_status	function
(	O
downloader	pointer
,	O
"part %d failed\n"	pointer
,	O
part	pointer
->	O
id	int
)	O
;	O
part	pointer
->	O
inuse	bool
=	O
0	int
;	O
}	O
}	O
static	O
void	O
process_response	function
(	O
wget_http_response	struct
*	O
resp	pointer
)	O
{	O
JOB	struct
*	O
job	pointer
=	O
resp	pointer
->	O
req	pointer
->	O
user_data	pointer
;	O
int	O
process_decision	int
=	O
0	int
,	O
recurse_decision	int
=	O
0	int
;	O
if	O
(	O
resp	pointer
->	O
body	pointer
)	O
quota_modify_read	function
(	O
resp	pointer
->	O
cur_downloaded	long
)	O
;	O
if	O
(	O
config	struct
.	O
metalink	pointer
&&	O
resp	pointer
->	O
links	pointer
)	O
{	O
wget_http_link	struct
*	O
top_link	pointer
=	O
NULL	O
,	O
*	O
metalink	pointer
=	O
NULL	O
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
resp	pointer
->	O
links	pointer
)	O
;	O
it	int
++	O
)	O
{	O
wget_http_link	struct
*	O
link	function
=	O
wget_vector_get	function
(	O
resp	pointer
->	O
links	pointer
,	O
it	int
)	O
;	O
if	O
(	O
link	function
->	O
rel	enum
==	O
link_rel_describedby	int
)	O
{	O
if	O
(	O
link	function
->	O
type	enum
&&	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
link	function
->	O
type	enum
,	O
"application/metalink4+xml"	pointer
)	O
||	O
!	O
wget_strcasecmp_ascii	function
(	O
link	function
->	O
type	enum
,	O
"application/metalink+xml"	pointer
)	O
)	O
)	O
{	O
metalink	pointer
=	O
link	function
;	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
link	function
->	O
rel	enum
==	O
link_rel_duplicate	int
)	O
{	O
if	O
(	O
!	O
top_link	pointer
||	O
top_link	pointer
->	O
pri	int
>	O
link	function
->	O
pri	int
)	O
top_link	pointer
=	O
link	function
;	O
}	O
}	O
if	O
(	O
metalink	pointer
)	O
{	O
add_url	function
(	O
job	pointer
,	O
"utf-8"	pointer
,	O
metalink	pointer
->	O
uri	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
top_link	pointer
)	O
{	O
add_url	function
(	O
job	pointer
,	O
"utf-8"	pointer
,	O
top_link	pointer
->	O
uri	pointer
,	O
0	int
)	O
;	O
return	O
;	O
}	O
}	O
if	O
(	O
config	struct
.	O
metalink	pointer
&&	O
resp	pointer
->	O
content_type	pointer
)	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/metalink4+xml"	pointer
)	O
||	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/metalink+xml"	pointer
)	O
)	O
{	O
job	pointer
->	O
metalink	pointer
=	O
resp	pointer
->	O
body	pointer
&&	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
?	O
wget_metalink_parse	function
(	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
)	O
:	O
NULL	O
;	O
}	O
if	O
(	O
job	pointer
->	O
metalink	pointer
)	O
{	O
if	O
(	O
job	pointer
->	O
metalink	pointer
->	O
size	pointer
<=	O
0	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"File length %llu - remove job\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
long	O
)	O
job	pointer
->	O
metalink	pointer
->	O
size	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
job	pointer
->	O
metalink	pointer
->	O
mirrors	pointer
)	O
{	O
error_printf	O
(	O
_	O
(	O
"No download mirrors found - remove job\n"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
job_validate_file	function
(	O
job	pointer
)	O
)	O
{	O
wget_metalink_sort_mirrors	function
(	O
job	pointer
->	O
metalink	pointer
)	O
;	O
wget_thread_cond_signal	function
(	O
worker_cond	pointer
)	O
;	O
job	pointer
->	O
done	bool
=	O
0	int
;	O
}	O
}	O
return	O
;	O
}	O
}	O
if	O
(	O
resp	pointer
->	O
code	short
==	O
200	int
||	O
resp	pointer
->	O
code	short
==	O
206	int
||	O
resp	pointer
->	O
code	short
==	O
416	int
||	O
(	O
resp	pointer
->	O
code	short
==	O
304	int
&&	O
config	struct
.	O
timestamping	char
)	O
)	O
{	O
process_decision	int
=	O
job	pointer
->	O
local_filename	pointer
||	O
resp	pointer
->	O
body	pointer
?	O
1	int
:	O
0	int
;	O
recurse_decision	int
=	O
process_decision	int
&&	O
config	struct
.	O
recursive	char
&&	O
(	O
!	O
config	struct
.	O
level	int
||	O
job	pointer
->	O
level	int
<	O
config	struct
.	O
level	int
+	O
config	struct
.	O
page_requisites	char
)	O
?	O
1	int
:	O
0	int
;	O
if	O
(	O
process_decision	int
)	O
{	O
wget_vector	struct
*	O
recurse_iris	pointer
=	O
NULL	O
;	O
int	O
n_recurse_iris	int
=	O
0	int
;	O
const	O
void	O
*	O
data	pointer
=	O
NULL	O
;	O
uint64_t	long
size	pointer
;	O
const	O
char	O
*	O
filename	pointer
;	O
if	O
(	O
config	struct
.	O
spider	char
||	O
(	O
config	struct
.	O
recursive	char
&&	O
config	struct
.	O
output_document	pointer
)	O
)	O
filename	pointer
=	O
NULL	O
;	O
else	O
filename	pointer
=	O
job	pointer
->	O
local_filename	pointer
;	O
if	O
(	O
(	O
resp	pointer
->	O
code	short
==	O
304	int
||	O
resp	pointer
->	O
code	short
==	O
416	int
||	O
resp	pointer
->	O
code	short
==	O
206	int
)	O
&&	O
filename	pointer
)	O
size	pointer
=	O
get_file_size	function
(	O
filename	pointer
)	O
;	O
else	O
size	pointer
=	O
resp	pointer
->	O
content_length	long
;	O
if	O
(	O
(	O
resp	pointer
->	O
code	short
==	O
200	int
||	O
resp	pointer
->	O
code	short
==	O
206	int
)	O
&&	O
resp	pointer
->	O
body	pointer
&&	O
resp	pointer
->	O
body	pointer
->	O
length	long
==	O
size	pointer
)	O
data	pointer
=	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
;	O
if	O
(	O
recurse_decision	int
)	O
recurse_iris	pointer
=	O
wget_vector_create	function
(	O
16	int
,	O
NULL	O
)	O
;	O
process_decision	int
=	O
plugin_db_forward_downloaded_file	function
(	O
job	pointer
->	O
iri	pointer
,	O
size	pointer
>	O
0	int
?	O
size	pointer
:	O
0	int
,	O
filename	pointer
,	O
data	pointer
,	O
recurse_iris	pointer
)	O
;	O
if	O
(	O
recurse_decision	int
)	O
{	O
n_recurse_iris	int
=	O
wget_vector_size	function
(	O
recurse_iris	pointer
)	O
;	O
for	O
(	O
int	O
i	int
=	O
0	int
;	O
i	int
<	O
n_recurse_iris	int
;	O
i	int
++	O
)	O
{	O
wget_iri	struct
*	O
iri	pointer
=	O
(	O
wget_iri	struct
*	O
)	O
wget_vector_get	function
(	O
recurse_iris	pointer
,	O
i	int
)	O
;	O
add_url	function
(	O
job	pointer
,	O
"utf-8"	pointer
,	O
iri	pointer
->	O
uri	pointer
,	O
0	int
)	O
;	O
wget_iri_free_content	function
(	O
iri	pointer
)	O
;	O
}	O
wget_vector_free	function
(	O
&	O
recurse_iris	pointer
)	O
;	O
}	O
}	O
}	O
if	O
(	O
job	pointer
->	O
robotstxt	bool
&&	O
resp	pointer
->	O
body	pointer
&&	O
(	O
wget_robots_parse	function
(	O
&	O
job	pointer
->	O
host	pointer
->	O
robots	pointer
,	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
,	O
PACKAGE_NAME	pointer
)	O
==	O
WGET_E_SUCCESS	int
)	O
&&	O
!	O
config	struct
.	O
page_requisites	char
)	O
{	O
for	O
(	O
int	O
it	int
=	O
0	int
,	O
n	long
=	O
wget_robots_get_sitemap_count	function
(	O
job	pointer
->	O
host	pointer
->	O
robots	pointer
)	O
;	O
it	int
<	O
n	long
;	O
it	int
++	O
)	O
{	O
const	O
char	O
*	O
sitemap	pointer
=	O
wget_robots_get_sitemap	function
(	O
job	pointer
->	O
host	pointer
->	O
robots	pointer
,	O
it	int
)	O
;	O
debug_printf	O
(	O
"adding sitemap '%s'\n"	pointer
,	O
sitemap	pointer
)	O
;	O
add_url	function
(	O
job	pointer
,	O
"utf-8"	pointer
,	O
sitemap	pointer
,	O
URL_FLG_SITEMAP	O
)	O
;	O
}	O
}	O
else	O
if	O
(	O
resp	pointer
->	O
code	short
==	O
200	int
||	O
resp	pointer
->	O
code	short
==	O
206	int
)	O
{	O
if	O
(	O
process_decision	int
&&	O
recurse_decision	int
)	O
{	O
if	O
(	O
resp	pointer
->	O
content_type	pointer
&&	O
resp	pointer
->	O
body	pointer
)	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"text/html"	pointer
)	O
)	O
{	O
html_parse	function
(	O
job	pointer
,	O
job	pointer
->	O
level	int
,	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
,	O
resp	pointer
->	O
body	pointer
->	O
length	long
,	O
resp	pointer
->	O
content_type_encoding	pointer
?	O
resp	pointer
->	O
content_type_encoding	pointer
:	O
config	struct
.	O
remote_encoding	pointer
,	O
job	pointer
->	O
iri	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/xhtml+xml"	pointer
)	O
)	O
{	O
html_parse	function
(	O
job	pointer
,	O
job	pointer
->	O
level	int
,	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
,	O
resp	pointer
->	O
body	pointer
->	O
length	long
,	O
resp	pointer
->	O
content_type_encoding	pointer
?	O
resp	pointer
->	O
content_type_encoding	pointer
:	O
config	struct
.	O
remote_encoding	pointer
,	O
job	pointer
->	O
iri	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"text/css"	pointer
)	O
)	O
{	O
css_parse	function
(	O
job	pointer
,	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
,	O
resp	pointer
->	O
body	pointer
->	O
length	long
,	O
resp	pointer
->	O
content_type_encoding	pointer
?	O
resp	pointer
->	O
content_type_encoding	pointer
:	O
config	struct
.	O
remote_encoding	pointer
,	O
job	pointer
->	O
iri	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/atom+xml"	pointer
)	O
)	O
{	O
atom_parse	function
(	O
job	pointer
,	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
,	O
"utf-8"	pointer
,	O
job	pointer
->	O
iri	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/rss+xml"	pointer
)	O
)	O
{	O
rss_parse	function
(	O
job	pointer
,	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
,	O
"utf-8"	pointer
,	O
job	pointer
->	O
iri	pointer
)	O
;	O
}	O
else	O
if	O
(	O
job	pointer
->	O
sitemap	pointer
)	O
{	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/xml"	pointer
)	O
)	O
sitemap_parse_xml	function
(	O
job	pointer
,	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
,	O
"utf-8"	pointer
,	O
job	pointer
->	O
iri	pointer
)	O
;	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/x-gzip"	pointer
)	O
)	O
sitemap_parse_xml_gz	function
(	O
job	pointer
,	O
resp	pointer
->	O
body	pointer
,	O
"utf-8"	pointer
,	O
job	pointer
->	O
iri	pointer
)	O
;	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"text/plain"	pointer
)	O
)	O
sitemap_parse_text	function
(	O
job	pointer
,	O
resp	pointer
->	O
body	pointer
->	O
data	pointer
,	O
"utf-8"	pointer
,	O
job	pointer
->	O
iri	pointer
)	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
config	struct
.	O
verify_sig	char
!=	O
WGET_GPG_VERIFY_DISABLED	int
&&	O
resp	pointer
->	O
content_type	pointer
)	O
{	O
}	O
}	O
else	O
if	O
(	O
(	O
resp	pointer
->	O
code	short
==	O
304	int
&&	O
config	struct
.	O
timestamping	char
)	O
||	O
resp	pointer
->	O
code	short
==	O
416	int
)	O
{	O
if	O
(	O
process_decision	int
&&	O
recurse_decision	int
)	O
{	O
const	O
char	O
*	O
local_filename	pointer
;	O
if	O
(	O
config	struct
.	O
content_disposition	char
&&	O
resp	pointer
->	O
content_filename	pointer
)	O
local_filename	pointer
=	O
resp	pointer
->	O
content_filename	pointer
;	O
else	O
local_filename	pointer
=	O
job	pointer
->	O
local_filename	pointer
;	O
parse_localfile	function
(	O
job	pointer
,	O
local_filename	pointer
,	O
resp	pointer
->	O
content_type_encoding	pointer
,	O
resp	pointer
->	O
content_type	pointer
,	O
job	pointer
->	O
iri	pointer
)	O
;	O
}	O
}	O
}	O
static	O
void	O
_fallback_to_http	function
(	O
JOB	struct
*	O
job	pointer
)	O
{	O
if	O
(	O
!	O
job	pointer
->	O
robotstxt	bool
)	O
{	O
char	O
*	O
http_url	pointer
=	O
wget_aprintf	function
(	O
"http://%s"	pointer
,	O
job	pointer
->	O
iri	pointer
->	O
uri	pointer
+	O
8	int
)	O
;	O
add_url	function
(	O
NULL	O
,	O
"utf-8"	pointer
,	O
http_url	pointer
,	O
URL_FLG_SKIPFALLBACK	O
)	O
;	O
host_remove_job	function
(	O
job	pointer
->	O
host	pointer
,	O
job	pointer
)	O
;	O
xfree	O
(	O
http_url	pointer
)	O
;	O
}	O
else	O
{	O
host_remove_job	function
(	O
job	pointer
->	O
host	pointer
,	O
job	pointer
)	O
;	O
}	O
}	O
enum	O
actions	enum
{	O
ACTION_GET_JOB	int
=	O
1	int
,	O
ACTION_GET_RESPONSE	int
=	O
2	int
,	O
ACTION_ERROR	int
=	O
3	int
}	O
;	O
void	O
*	O
downloader_thread	function
(	O
void	O
*	O
p	pointer
)	O
{	O
DOWNLOADER	struct
*	O
downloader	pointer
=	O
p	pointer
;	O
wget_http_response	struct
*	O
resp	pointer
=	O
NULL	O
;	O
JOB	struct
*	O
job	pointer
;	O
HOST	struct
*	O
host	pointer
=	O
NULL	O
;	O
int	O
pending	int
=	O
0	int
,	O
max_pending	int
=	O
1	int
,	O
locked	int
;	O
long	O
long	O
pause	function
=	O
0	int
;	O
enum	O
actions	enum
action	int
=	O
ACTION_GET_JOB	int
;	O
char	O
http_code	array
[	O
7	int
]	O
;	O
wget_thread_mutex_lock	function
(	O
main_mutex	pointer
)	O
;	O
locked	int
=	O
1	int
;	O
while	O
(	O
!	O
terminate	bool
)	O
{	O
debug_printf	O
(	O
"[%d] action=%d pending=%d host=%p\n"	pointer
,	O
downloader	pointer
->	O
id	int
,	O
(	O
int	O
)	O
action	int
,	O
pending	int
,	O
(	O
void	O
*	O
)	O
host	pointer
)	O
;	O
switch	O
(	O
action	int
)	O
{	O
case	O
ACTION_GET_JOB	int
:	O
if	O
(	O
!	O
(	O
job	pointer
=	O
host_get_job	function
(	O
host	pointer
,	O
&	O
pause	function
)	O
)	O
)	O
{	O
if	O
(	O
pending	int
)	O
{	O
wget_thread_mutex_unlock	function
(	O
main_mutex	pointer
)	O
;	O
locked	int
=	O
0	int
;	O
action	int
=	O
ACTION_GET_RESPONSE	int
;	O
}	O
else	O
if	O
(	O
host	pointer
)	O
{	O
wget_http_close	function
(	O
&	O
downloader	pointer
->	O
conn	pointer
)	O
;	O
host	pointer
=	O
NULL	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
wget_thread_support	function
(	O
)	O
)	O
{	O
if	O
(	O
!	O
pause	function
)	O
goto	O
out	pointer
;	O
wget_millisleep	function
(	O
pause	function
)	O
;	O
continue	O
;	O
}	O
wget_thread_cond_wait	function
(	O
worker_cond	pointer
,	O
main_mutex	pointer
,	O
pause	function
)	O
;	O
locked	int
=	O
1	int
;	O
}	O
break	O
;	O
}	O
wget_thread_mutex_unlock	function
(	O
main_mutex	pointer
)	O
;	O
locked	int
=	O
0	int
;	O
{	O
wget_iri	struct
*	O
iri	pointer
=	O
job	pointer
->	O
iri	pointer
;	O
downloader	pointer
->	O
job	pointer
=	O
job	pointer
;	O
job	pointer
->	O
downloader	pointer
=	O
downloader	pointer
;	O
if	O
(	O
++	O
pending	int
==	O
1	int
)	O
{	O
host	pointer
=	O
job	pointer
->	O
host	pointer
;	O
if	O
(	O
establish_connection	function
(	O
downloader	pointer
,	O
&	O
iri	pointer
)	O
!=	O
WGET_E_SUCCESS	int
)	O
{	O
if	O
(	O
job	pointer
->	O
http_fallback	bool
)	O
_fallback_to_http	function
(	O
job	pointer
)	O
;	O
else	O
host_increase_failure	function
(	O
host	pointer
)	O
;	O
action	int
=	O
ACTION_ERROR	int
;	O
break	O
;	O
}	O
job	pointer
->	O
iri	pointer
=	O
iri	pointer
;	O
if	O
(	O
config	struct
.	O
wait	int
||	O
job	pointer
->	O
metalink	pointer
||	O
!	O
downloader	pointer
->	O
conn	pointer
||	O
wget_http_get_protocol	function
(	O
downloader	pointer
->	O
conn	pointer
)	O
!=	O
WGET_PROTOCOL_HTTP_2_0	int
)	O
max_pending	int
=	O
1	int
;	O
else	O
max_pending	int
=	O
config	struct
.	O
http2_request_window	int
;	O
}	O
if	O
(	O
config	struct
.	O
wait	int
)	O
{	O
if	O
(	O
config	struct
.	O
random_wait	char
)	O
wget_millisleep	function
(	O
rand	function
(	O
)	O
%	O
config	struct
.	O
wait	int
+	O
config	struct
.	O
wait	int
/	O
2	int
)	O
;	O
else	O
wget_millisleep	function
(	O
config	struct
.	O
wait	int
)	O
;	O
if	O
(	O
terminate	bool
)	O
break	O
;	O
}	O
if	O
(	O
!	O
job	pointer
->	O
original_url	pointer
)	O
job	pointer
->	O
original_url	pointer
=	O
iri	pointer
;	O
if	O
(	O
http_send_request	function
(	O
job	pointer
->	O
iri	pointer
,	O
job	pointer
->	O
original_url	pointer
,	O
downloader	pointer
)	O
!=	O
WGET_E_SUCCESS	int
)	O
{	O
if	O
(	O
job	pointer
->	O
http_fallback	bool
)	O
_fallback_to_http	function
(	O
job	pointer
)	O
;	O
else	O
host_increase_failure	function
(	O
host	pointer
)	O
;	O
action	int
=	O
ACTION_ERROR	int
;	O
break	O
;	O
}	O
if	O
(	O
pending	int
>=	O
max_pending	int
)	O
{	O
action	int
=	O
ACTION_GET_RESPONSE	int
;	O
}	O
else	O
{	O
wget_thread_mutex_lock	function
(	O
main_mutex	pointer
)	O
;	O
locked	int
=	O
1	int
;	O
}	O
}	O
break	O
;	O
case	O
ACTION_GET_RESPONSE	int
:	O
resp	pointer
=	O
http_receive_response	function
(	O
downloader	pointer
->	O
conn	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
http_retry_on_status	pointer
&&	O
resp	pointer
&&	O
resp	pointer
->	O
code	short
!=	O
200	int
)	O
{	O
wget_snprintf	function
(	O
http_code	array
,	O
sizeof	O
(	O
http_code	array
)	O
,	O
"%d"	pointer
,	O
resp	pointer
->	O
code	short
)	O
;	O
if	O
(	O
check_mime_list	function
(	O
config	struct
.	O
http_retry_on_status	pointer
,	O
http_code	array
)	O
)	O
{	O
print_status	function
(	O
downloader	pointer
,	O
"Got a HTTP Code %d. Retrying..."	pointer
,	O
resp	pointer
->	O
code	short
)	O
;	O
wget_http_free_request	function
(	O
&	O
resp	pointer
->	O
req	pointer
)	O
;	O
wget_http_free_response	function
(	O
&	O
resp	pointer
)	O
;	O
}	O
}	O
if	O
(	O
!	O
resp	pointer
)	O
{	O
host_increase_failure	function
(	O
host	pointer
)	O
;	O
action	int
=	O
ACTION_ERROR	int
;	O
break	O
;	O
}	O
host_reset_failure	function
(	O
host	pointer
)	O
;	O
job	pointer
=	O
resp	pointer
->	O
req	pointer
->	O
user_data	pointer
;	O
if	O
(	O
process_response_header	function
(	O
resp	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
job	pointer
->	O
head_first	bool
)	O
process_head_response	function
(	O
resp	pointer
)	O
;	O
else	O
if	O
(	O
job	pointer
->	O
part	pointer
)	O
process_response_part	function
(	O
resp	pointer
)	O
;	O
else	O
process_response	function
(	O
resp	pointer
)	O
;	O
}	O
wget_http_free_request	function
(	O
&	O
resp	pointer
->	O
req	pointer
)	O
;	O
wget_http_free_response	function
(	O
&	O
resp	pointer
)	O
;	O
wget_thread_mutex_lock	function
(	O
main_mutex	pointer
)	O
;	O
locked	int
=	O
1	int
;	O
if	O
(	O
job	pointer
->	O
done	bool
)	O
{	O
host_remove_job	function
(	O
host	pointer
,	O
job	pointer
)	O
;	O
}	O
else	O
{	O
job	pointer
->	O
inuse	bool
=	O
0	int
;	O
}	O
wget_thread_cond_signal	function
(	O
main_cond	pointer
)	O
;	O
pending	int
--	O
;	O
action	int
=	O
ACTION_GET_JOB	int
;	O
break	O
;	O
case	O
ACTION_ERROR	int
:	O
wget_http_close	function
(	O
&	O
downloader	pointer
->	O
conn	pointer
)	O
;	O
wget_thread_mutex_lock	function
(	O
main_mutex	pointer
)	O
;	O
locked	int
=	O
1	int
;	O
host_release_jobs	function
(	O
host	pointer
)	O
;	O
wget_thread_cond_signal	function
(	O
main_cond	pointer
)	O
;	O
host	pointer
=	O
NULL	O
;	O
pending	int
=	O
0	int
;	O
action	int
=	O
ACTION_GET_JOB	int
;	O
break	O
;	O
default	O
:	O
error_printf_exit	O
(	O
_	O
(	O
"Unhandled action %d\n"	pointer
)	O
,	O
(	O
int	O
)	O
action	int
)	O
;	O
}	O
}	O
out	pointer
:	O
if	O
(	O
locked	int
)	O
wget_thread_mutex_unlock	function
(	O
main_mutex	pointer
)	O
;	O
wget_http_close	function
(	O
&	O
downloader	pointer
->	O
conn	pointer
)	O
;	O
wget_thread_cond_signal	function
(	O
worker_cond	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
_free_conversion_entry	function
(	O
void	O
*	O
conversion	pointer
)	O
{	O
_conversion_t	struct
*	O
c	int
=	O
conversion	pointer
;	O
xfree	O
(	O
c	int
->	O
filename	pointer
)	O
;	O
xfree	O
(	O
c	int
->	O
encoding	pointer
)	O
;	O
wget_iri_free	function
(	O
&	O
c	int
->	O
base_url	pointer
)	O
;	O
wget_html_free_urls_inline	function
(	O
&	O
c	int
->	O
parsed	pointer
)	O
;	O
xfree	O
(	O
c	int
)	O
;	O
}	O
static	O
void	O
_remember_for_conversion	function
(	O
const	O
char	O
*	O
filename	pointer
,	O
wget_iri	struct
*	O
base_url	pointer
,	O
int	O
content_type	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_html_parsed_result	struct
*	O
parsed	pointer
)	O
{	O
_conversion_t	struct
*	O
conversion	pointer
=	O
wget_malloc	function
(	O
sizeof	O
(	O
_conversion_t	struct
)	O
)	O
;	O
conversion	pointer
->	O
filename	pointer
=	O
wget_strdup	function
(	O
filename	pointer
)	O
;	O
conversion	pointer
->	O
encoding	pointer
=	O
wget_strdup	function
(	O
encoding	pointer
)	O
;	O
conversion	pointer
->	O
base_url	pointer
=	O
wget_iri_clone	function
(	O
base_url	pointer
)	O
;	O
conversion	pointer
->	O
content_type	pointer
=	O
content_type	pointer
;	O
conversion	pointer
->	O
parsed	pointer
=	O
parsed	pointer
;	O
wget_thread_mutex_lock	function
(	O
conversion_mutex	pointer
)	O
;	O
if	O
(	O
!	O
conversions	pointer
)	O
{	O
conversions	pointer
=	O
wget_vector_create	function
(	O
128	int
,	O
NULL	O
)	O
;	O
wget_vector_set_destructor	function
(	O
conversions	pointer
,	O
_free_conversion_entry	function
)	O
;	O
}	O
wget_vector_add	function
(	O
conversions	pointer
,	O
conversion	pointer
)	O
;	O
wget_thread_mutex_unlock	function
(	O
conversion_mutex	pointer
)	O
;	O
}	O
__attribute__	O
(	O
(	O
no_sanitize	O
(	O
"integer"	pointer
)	O
)	O
)	O
static	O
unsigned	O
int	O
WGET_GCC_PURE	O
hash_url	function
(	O
const	O
char	O
*	O
url	pointer
)	O
{	O
unsigned	O
int	O
hash	pointer
=	O
0	int
;	O
while	O
(	O
*	O
url	pointer
)	O
hash	pointer
=	O
hash	pointer
*	O
101	int
+	O
(	O
unsigned	O
char	O
)	O
*	O
url	pointer
++	O
;	O
return	O
hash	pointer
;	O
}	O
static	O
int	O
_normalize_uri	function
(	O
wget_iri	struct
*	O
base	pointer
,	O
wget_string	struct
*	O
url	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_buffer	struct
*	O
buf	pointer
)	O
{	O
char	O
*	O
urlpart	pointer
=	O
wget_strmemdup	function
(	O
url	pointer
->	O
p	pointer
,	O
url	pointer
->	O
len	long
)	O
;	O
char	O
*	O
urlpart_encoded	pointer
;	O
size_t	long
urlpart_encoded_length	long
;	O
int	O
rc	int
;	O
if	O
(	O
url	pointer
->	O
len	long
==	O
0	int
||	O
(	O
url	pointer
->	O
len	long
>=	O
1	int
&&	O
*	O
url	pointer
->	O
p	pointer
==	O
'#'	O
)	O
)	O
{	O
xfree	O
(	O
urlpart	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
wget_iri_unescape_url_inline	function
(	O
urlpart	pointer
)	O
;	O
rc	int
=	O
wget_memiconv	function
(	O
encoding	pointer
,	O
urlpart	pointer
,	O
strlen	function
(	O
urlpart	pointer
)	O
,	O
"utf-8"	pointer
,	O
&	O
urlpart_encoded	pointer
,	O
&	O
urlpart_encoded_length	long
)	O
;	O
xfree	O
(	O
urlpart	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%.*s' not followed (conversion failed)\n"	pointer
)	O
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
rc	int
=	O
!	O
wget_iri_relative_to_abs	function
(	O
base	pointer
,	O
urlpart_encoded	pointer
,	O
urlpart_encoded_length	long
,	O
buf	pointer
)	O
;	O
xfree	O
(	O
urlpart_encoded	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Cannot resolve relative URI %.*s\n"	pointer
)	O
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
)	O
;	O
return	O
-	O
3	int
;	O
}	O
return	O
0	int
;	O
}	O
void	O
html_parse	function
(	O
JOB	struct
*	O
job	pointer
,	O
int	O
level	int
,	O
const	O
char	O
*	O
html	pointer
,	O
size_t	long
html_len	long
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
wget_iri	struct
*	O
allocated_base	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
reason	array
;	O
char	O
*	O
utf8	pointer
=	O
NULL	O
;	O
wget_buffer	struct
buf	pointer
;	O
char	O
sbuf	array
[	O
1024	int
]	O
;	O
int	O
convert_links	char
=	O
config	struct
.	O
convert_links	char
&&	O
!	O
config	struct
.	O
delete_after	char
;	O
bool	bool
page_requisites	char
=	O
config	struct
.	O
recursive	char
&&	O
config	struct
.	O
page_requisites	char
&&	O
config	struct
.	O
level	int
&&	O
level	int
<	O
config	struct
.	O
level	int
;	O
if	O
(	O
encoding	pointer
&&	O
encoding	pointer
==	O
config	struct
.	O
remote_encoding	pointer
)	O
{	O
reason	array
=	O
_	O
(	O
"set by user"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
(	O
unsigned	O
char	O
)	O
html	pointer
[	O
0	int
]	O
==	O
0xFE	int
&&	O
(	O
unsigned	O
char	O
)	O
html	pointer
[	O
1	int
]	O
==	O
0xFF	int
)	O
{	O
encoding	pointer
=	O
"UTF-16BE"	pointer
;	O
reason	array
=	O
_	O
(	O
"set by BOM"	pointer
)	O
;	O
html	pointer
+=	O
2	int
;	O
html_len	long
-=	O
2	int
;	O
}	O
else	O
if	O
(	O
(	O
unsigned	O
char	O
)	O
html	pointer
[	O
0	int
]	O
==	O
0xFF	int
&&	O
(	O
unsigned	O
char	O
)	O
html	pointer
[	O
1	int
]	O
==	O
0xFE	int
)	O
{	O
encoding	pointer
=	O
"UTF-16LE"	pointer
;	O
reason	array
=	O
_	O
(	O
"set by BOM"	pointer
)	O
;	O
html	pointer
+=	O
2	int
;	O
html_len	long
-=	O
2	int
;	O
}	O
else	O
if	O
(	O
(	O
unsigned	O
char	O
)	O
html	pointer
[	O
0	int
]	O
==	O
0xEF	int
&&	O
(	O
unsigned	O
char	O
)	O
html	pointer
[	O
1	int
]	O
==	O
0xBB	int
&&	O
(	O
unsigned	O
char	O
)	O
html	pointer
[	O
2	int
]	O
==	O
0xBF	int
)	O
{	O
encoding	pointer
=	O
"UTF-8"	pointer
;	O
reason	array
=	O
_	O
(	O
"set by BOM"	pointer
)	O
;	O
html	pointer
+=	O
3	int
;	O
html_len	long
-=	O
3	int
;	O
}	O
else	O
reason	array
=	O
_	O
(	O
"set by server response"	pointer
)	O
;	O
}	O
if	O
(	O
!	O
wget_strncasecmp_ascii	function
(	O
encoding	pointer
,	O
"UTF-16"	pointer
,	O
6	int
)	O
)	O
{	O
size_t	long
n	long
;	O
html_len	long
-=	O
html_len	long
&	O
1	int
;	O
if	O
(	O
wget_memiconv	function
(	O
encoding	pointer
,	O
html	pointer
,	O
html_len	long
,	O
"UTF-8"	pointer
,	O
&	O
utf8	pointer
,	O
&	O
n	long
)	O
==	O
0	int
)	O
{	O
info_printf	O
(	O
_	O
(	O
"Convert non-ASCII encoding '%s' (%s) to UTF-8\n"	pointer
)	O
,	O
encoding	pointer
,	O
reason	array
)	O
;	O
html	pointer
=	O
utf8	pointer
;	O
if	O
(	O
convert_links	char
)	O
{	O
convert_links	char
=	O
0	int
;	O
info_printf	O
(	O
_	O
(	O
"Link conversion disabled for '%s'\n"	pointer
)	O
,	O
job	pointer
->	O
local_filename	pointer
)	O
;	O
}	O
}	O
else	O
{	O
info_printf	O
(	O
_	O
(	O
"Failed to convert non-ASCII encoding '%s' (%s) to UTF-8, skip parsing\n"	pointer
)	O
,	O
encoding	pointer
,	O
reason	array
)	O
;	O
return	O
;	O
}	O
}	O
wget_html_parsed_result	struct
*	O
parsed	pointer
=	O
wget_html_get_urls_inline	function
(	O
html	pointer
,	O
config	struct
.	O
follow_tags	pointer
,	O
config	struct
.	O
ignore_tags	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
robots	pointer
&&	O
!	O
parsed	pointer
->	O
follow	bool
)	O
goto	O
cleanup	O
;	O
if	O
(	O
!	O
encoding	pointer
)	O
{	O
if	O
(	O
parsed	pointer
->	O
encoding	pointer
)	O
{	O
encoding	pointer
=	O
parsed	pointer
->	O
encoding	pointer
;	O
reason	array
=	O
_	O
(	O
"set by document"	pointer
)	O
;	O
}	O
else	O
{	O
encoding	pointer
=	O
"CP1252"	pointer
;	O
reason	array
=	O
_	O
(	O
"default, encoding not specified"	pointer
)	O
;	O
}	O
}	O
info_printf	O
(	O
_	O
(	O
"URI content encoding = '%s' (%s)\n"	pointer
)	O
,	O
encoding	pointer
,	O
reason	array
)	O
;	O
wget_buffer_init	function
(	O
&	O
buf	pointer
,	O
sbuf	array
,	O
sizeof	O
(	O
sbuf	array
)	O
)	O
;	O
if	O
(	O
parsed	pointer
->	O
base	pointer
.	O
p	pointer
)	O
{	O
if	O
(	O
_normalize_uri	function
(	O
base	pointer
,	O
&	O
parsed	pointer
->	O
base	pointer
,	O
encoding	pointer
,	O
&	O
buf	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
base	pointer
&&	O
!	O
buf	pointer
.	O
length	long
)	O
info_printf	O
(	O
_	O
(	O
"BASE '%.*s' not usable (missing absolute base URI)\n"	pointer
)	O
,	O
(	O
int	O
)	O
parsed	pointer
->	O
base	pointer
.	O
len	long
,	O
parsed	pointer
->	O
base	pointer
.	O
p	pointer
)	O
;	O
else	O
{	O
wget_iri	struct
*	O
newbase	pointer
=	O
wget_iri_parse	function
(	O
buf	pointer
.	O
data	pointer
,	O
"utf-8"	pointer
)	O
;	O
if	O
(	O
newbase	pointer
)	O
base	pointer
=	O
allocated_base	pointer
=	O
newbase	pointer
;	O
}	O
}	O
else	O
{	O
error_printf	O
(	O
_	O
(	O
"Cannot resolve BASE URI %.*s\n"	pointer
)	O
,	O
(	O
int	O
)	O
parsed	pointer
->	O
base	pointer
.	O
len	long
,	O
parsed	pointer
->	O
base	pointer
.	O
p	pointer
)	O
;	O
}	O
}	O
wget_thread_mutex_lock	function
(	O
known_urls_mutex	pointer
)	O
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
parsed	pointer
->	O
uris	pointer
)	O
;	O
it	int
++	O
)	O
{	O
wget_html_parsed_url	struct
*	O
html_url	pointer
=	O
wget_vector_get	function
(	O
parsed	pointer
->	O
uris	pointer
,	O
it	int
)	O
;	O
wget_string	struct
*	O
url	pointer
=	O
&	O
html_url	pointer
->	O
url	pointer
;	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
html_url	pointer
->	O
attr	array
,	O
"action"	pointer
)	O
||	O
!	O
wget_strcasecmp_ascii	function
(	O
html_url	pointer
->	O
attr	array
,	O
"formaction"	pointer
)	O
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%.*s' not followed (action/formaction attribute)\n"	pointer
)	O
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
page_requisites	char
&&	O
!	O
wget_strcasecmp_ascii	function
(	O
html_url	pointer
->	O
attr	array
,	O
"href"	pointer
)	O
)	O
{	O
if	O
(	O
(	O
c_tolower	function
(	O
*	O
html_url	pointer
->	O
dir	array
)	O
==	O
'a'	O
&&	O
(	O
html_url	pointer
->	O
dir	array
[	O
1	int
]	O
==	O
0	int
||	O
!	O
wget_strcasecmp_ascii	function
(	O
html_url	pointer
->	O
dir	array
,	O
"area"	pointer
)	O
)	O
)	O
||	O
!	O
html_url	pointer
->	O
link_inline	bool
||	O
!	O
wget_strcasecmp_ascii	function
(	O
html_url	pointer
->	O
dir	array
,	O
"embed"	pointer
)	O
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%.*s' not followed (page requisites + level)\n"	pointer
)	O
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
if	O
(	O
_normalize_uri	function
(	O
base	pointer
,	O
url	pointer
,	O
encoding	pointer
,	O
&	O
buf	pointer
)	O
)	O
continue	O
;	O
if	O
(	O
!	O
base	pointer
&&	O
!	O
buf	pointer
.	O
length	long
)	O
info_printf	O
(	O
_	O
(	O
"URL '%.*s' not followed (missing base URI)\n"	pointer
)	O
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
)	O
;	O
else	O
{	O
if	O
(	O
wget_hashmap_put	function
(	O
known_urls	pointer
,	O
wget_strmemdup	function
(	O
buf	pointer
.	O
data	pointer
,	O
buf	pointer
.	O
length	long
)	O
,	O
NULL	O
)	O
==	O
0	int
)	O
add_url	function
(	O
job	pointer
,	O
"utf-8"	pointer
,	O
buf	pointer
.	O
data	pointer
,	O
page_requisites	char
?	O
URL_FLG_REQUISITE	O
:	O
0	int
)	O
;	O
}	O
}	O
wget_thread_mutex_unlock	function
(	O
known_urls_mutex	pointer
)	O
;	O
wget_buffer_deinit	function
(	O
&	O
buf	pointer
)	O
;	O
if	O
(	O
convert_links	char
&&	O
!	O
config	struct
.	O
delete_after	char
)	O
{	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
parsed	pointer
->	O
uris	pointer
)	O
;	O
it	int
++	O
)	O
{	O
wget_html_parsed_url	struct
*	O
html_url	pointer
=	O
wget_vector_get	function
(	O
parsed	pointer
->	O
uris	pointer
,	O
it	int
)	O
;	O
html_url	pointer
->	O
url	pointer
.	O
p	pointer
=	O
(	O
const	O
char	O
*	O
)	O
(	O
html_url	pointer
->	O
url	pointer
.	O
p	pointer
-	O
html	pointer
)	O
;	O
}	O
_remember_for_conversion	function
(	O
job	pointer
->	O
local_filename	pointer
,	O
base	pointer
,	O
_CONTENT_TYPE_HTML	int
,	O
encoding	pointer
,	O
parsed	pointer
)	O
;	O
parsed	pointer
=	O
NULL	O
;	O
}	O
wget_iri_free	function
(	O
&	O
allocated_base	pointer
)	O
;	O
cleanup	O
:	O
wget_html_free_urls_inline	function
(	O
&	O
parsed	pointer
)	O
;	O
xfree	O
(	O
utf8	pointer
)	O
;	O
}	O
void	O
html_parse_localfile	function
(	O
JOB	struct
*	O
job	pointer
,	O
int	O
level	int
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
char	O
*	O
data	pointer
;	O
size_t	long
n	long
;	O
if	O
(	O
(	O
data	pointer
=	O
wget_read_file	function
(	O
fname	pointer
,	O
&	O
n	long
)	O
)	O
)	O
{	O
html_parse	function
(	O
job	pointer
,	O
level	int
,	O
data	pointer
,	O
n	long
,	O
encoding	pointer
,	O
base	pointer
)	O
;	O
}	O
xfree	O
(	O
data	pointer
)	O
;	O
}	O
void	O
sitemap_parse_xml	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
wget_vector	struct
*	O
urls	pointer
,	O
*	O
sitemap_urls	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
size_t	long
baselen	long
=	O
0	int
;	O
wget_sitemap_get_urls_inline	function
(	O
data	pointer
,	O
&	O
urls	pointer
,	O
&	O
sitemap_urls	pointer
)	O
;	O
if	O
(	O
base	pointer
)	O
{	O
if	O
(	O
(	O
p	pointer
=	O
strrchr	function
(	O
base	pointer
->	O
uri	pointer
,	O
'/'	O
)	O
)	O
)	O
baselen	long
=	O
p	pointer
-	O
base	pointer
->	O
uri	pointer
+	O
1	int
;	O
else	O
baselen	long
=	O
strlen	function
(	O
base	pointer
->	O
uri	pointer
)	O
;	O
}	O
info_printf	O
(	O
_	O
(	O
"found %d url(s) (base=%s)\n"	pointer
)	O
,	O
wget_vector_size	function
(	O
urls	pointer
)	O
,	O
base	pointer
?	O
base	pointer
->	O
uri	pointer
:	O
NULL	O
)	O
;	O
wget_thread_mutex_lock	function
(	O
known_urls_mutex	pointer
)	O
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
urls	pointer
)	O
;	O
it	int
++	O
)	O
{	O
wget_string	struct
*	O
url	pointer
=	O
wget_vector_get	function
(	O
urls	pointer
,	O
it	int
)	O
;	O
if	O
(	O
baselen	long
&&	O
(	O
url	pointer
->	O
len	long
<=	O
baselen	long
||	O
wget_strncasecmp	function
(	O
url	pointer
->	O
p	pointer
,	O
base	pointer
->	O
uri	pointer
,	O
baselen	long
)	O
)	O
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%.*s' not followed (not matching sitemap location)\n"	pointer
)	O
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
wget_hashmap_put	function
(	O
known_urls	pointer
,	O
(	O
p	pointer
=	O
wget_strmemdup	function
(	O
url	pointer
->	O
p	pointer
,	O
url	pointer
->	O
len	long
)	O
)	O
,	O
NULL	O
)	O
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%.*s' not followed (already known)\n"	pointer
)	O
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
)	O
;	O
continue	O
;	O
}	O
add_url	function
(	O
job	pointer
,	O
encoding	pointer
,	O
p	pointer
,	O
0	int
)	O
;	O
}	O
info_printf	O
(	O
_	O
(	O
"found %d sitemap url(s) (base=%s)\n"	pointer
)	O
,	O
wget_vector_size	function
(	O
sitemap_urls	pointer
)	O
,	O
base	pointer
?	O
base	pointer
->	O
uri	pointer
:	O
NULL	O
)	O
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
sitemap_urls	pointer
)	O
;	O
it	int
++	O
)	O
{	O
wget_string	struct
*	O
url	pointer
=	O
wget_vector_get	function
(	O
sitemap_urls	pointer
,	O
it	int
)	O
;	O
if	O
(	O
wget_hashmap_put	function
(	O
known_urls	pointer
,	O
(	O
p	pointer
=	O
wget_strmemdup	function
(	O
url	pointer
->	O
p	pointer
,	O
url	pointer
->	O
len	long
)	O
)	O
,	O
NULL	O
)	O
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%.*s' not followed (already known)\n"	pointer
)	O
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
)	O
;	O
continue	O
;	O
}	O
add_url	function
(	O
job	pointer
,	O
encoding	pointer
,	O
p	pointer
,	O
URL_FLG_SITEMAP	O
)	O
;	O
}	O
wget_thread_mutex_unlock	function
(	O
known_urls_mutex	pointer
)	O
;	O
wget_vector_free	function
(	O
&	O
urls	pointer
)	O
;	O
wget_vector_free	function
(	O
&	O
sitemap_urls	pointer
)	O
;	O
}	O
static	O
int	O
_get_unzipped	function
(	O
void	O
*	O
userdata	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
size_t	long
length	long
)	O
{	O
wget_buffer_memcat	function
(	O
(	O
wget_buffer	struct
*	O
)	O
userdata	pointer
,	O
data	pointer
,	O
length	long
)	O
;	O
return	O
0	int
;	O
}	O
void	O
sitemap_parse_xml_gz	function
(	O
JOB	struct
*	O
job	pointer
,	O
wget_buffer	struct
*	O
gzipped_data	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
wget_buffer	struct
plain	struct
;	O
wget_decompressor	struct
*	O
dc	pointer
=	O
NULL	O
;	O
wget_buffer_init	function
(	O
&	O
plain	struct
,	O
NULL	O
,	O
gzipped_data	pointer
->	O
length	long
*	O
10	int
)	O
;	O
if	O
(	O
(	O
dc	pointer
=	O
wget_decompress_open	function
(	O
wget_content_encoding_gzip	int
,	O
_get_unzipped	function
,	O
&	O
plain	struct
)	O
)	O
)	O
{	O
wget_decompress	function
(	O
dc	pointer
,	O
gzipped_data	pointer
->	O
data	pointer
,	O
gzipped_data	pointer
->	O
length	long
)	O
;	O
wget_decompress_close	function
(	O
dc	pointer
)	O
;	O
sitemap_parse_xml	function
(	O
job	pointer
,	O
plain	struct
.	O
data	pointer
,	O
encoding	pointer
,	O
base	pointer
)	O
;	O
}	O
else	O
error_printf	O
(	O
_	O
(	O
"Can't scan '%s' because no libz support enabled at compile time\n"	pointer
)	O
,	O
job	pointer
->	O
iri	pointer
->	O
uri	pointer
)	O
;	O
wget_buffer_deinit	function
(	O
&	O
plain	struct
)	O
;	O
}	O
void	O
sitemap_parse_xml_localfile	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
char	O
*	O
data	pointer
;	O
if	O
(	O
(	O
data	pointer
=	O
wget_read_file	function
(	O
fname	pointer
,	O
NULL	O
)	O
)	O
)	O
sitemap_parse_xml	function
(	O
job	pointer
,	O
data	pointer
,	O
encoding	pointer
,	O
base	pointer
)	O
;	O
xfree	O
(	O
data	pointer
)	O
;	O
}	O
void	O
sitemap_parse_text	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
size_t	long
baselen	long
=	O
0	int
;	O
const	O
char	O
*	O
end	pointer
,	O
*	O
line	pointer
,	O
*	O
p	pointer
;	O
size_t	long
len	long
;	O
if	O
(	O
base	pointer
)	O
{	O
if	O
(	O
(	O
p	pointer
=	O
strrchr	function
(	O
base	pointer
->	O
uri	pointer
,	O
'/'	O
)	O
)	O
)	O
baselen	long
=	O
p	pointer
-	O
base	pointer
->	O
uri	pointer
+	O
1	int
;	O
else	O
baselen	long
=	O
strlen	function
(	O
base	pointer
->	O
uri	pointer
)	O
;	O
}	O
for	O
(	O
line	pointer
=	O
end	pointer
=	O
data	pointer
;	O
*	O
end	pointer
&&	O
(	O
end	pointer
=	O
(	O
p	pointer
=	O
strchr	function
(	O
line	pointer
,	O
'\n'	O
)	O
)	O
?	O
p	pointer
:	O
line	pointer
+	O
strlen	function
(	O
line	pointer
)	O
)	O
;	O
line	pointer
=	O
end	pointer
+	O
1	int
)	O
{	O
len	long
=	O
end	pointer
-	O
line	pointer
;	O
for	O
(	O
;	O
len	long
&&	O
isspace	function
(	O
*	O
line	pointer
)	O
;	O
line	pointer
++	O
,	O
len	long
--	O
)	O
;	O
for	O
(	O
;	O
len	long
&&	O
isspace	function
(	O
line	pointer
[	O
len	long
-	O
1	int
]	O
)	O
;	O
len	long
--	O
)	O
;	O
if	O
(	O
len	long
)	O
{	O
if	O
(	O
baselen	long
&&	O
(	O
len	long
<=	O
baselen	long
||	O
wget_strncasecmp	function
(	O
line	pointer
,	O
base	pointer
->	O
uri	pointer
,	O
baselen	long
)	O
)	O
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%.*s' not followed (not matching sitemap location)\n"	pointer
)	O
,	O
(	O
int	O
)	O
len	long
,	O
line	pointer
)	O
;	O
}	O
else	O
if	O
(	O
len	long
<	O
1024	int
)	O
{	O
char	O
url	pointer
[	O
len	long
+	O
1	int
]	O
;	O
memcpy	function
(	O
url	pointer
,	O
line	pointer
,	O
len	long
)	O
;	O
url	pointer
[	O
len	long
]	O
=	O
0	int
;	O
add_url	function
(	O
job	pointer
,	O
encoding	pointer
,	O
url	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
url	pointer
=	O
wget_strmemdup	function
(	O
line	pointer
,	O
len	long
)	O
;	O
add_url	function
(	O
job	pointer
,	O
encoding	pointer
,	O
url	pointer
,	O
0	int
)	O
;	O
xfree	O
(	O
url	pointer
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
_add_urls	function
(	O
JOB	struct
*	O
job	pointer
,	O
wget_vector	struct
*	O
urls	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
size_t	long
baselen	long
=	O
0	int
;	O
if	O
(	O
base	pointer
)	O
{	O
if	O
(	O
(	O
p	pointer
=	O
strrchr	function
(	O
base	pointer
->	O
uri	pointer
,	O
'/'	O
)	O
)	O
)	O
baselen	long
=	O
p	pointer
-	O
base	pointer
->	O
uri	pointer
+	O
1	int
;	O
else	O
baselen	long
=	O
strlen	function
(	O
base	pointer
->	O
uri	pointer
)	O
;	O
}	O
info_printf	O
(	O
_	O
(	O
"found %d url(s) (base=%s)\n"	pointer
)	O
,	O
wget_vector_size	function
(	O
urls	pointer
)	O
,	O
base	pointer
?	O
base	pointer
->	O
uri	pointer
:	O
NULL	O
)	O
;	O
wget_thread_mutex_lock	function
(	O
known_urls_mutex	pointer
)	O
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
urls	pointer
)	O
;	O
it	int
++	O
)	O
{	O
wget_string	struct
*	O
url	pointer
=	O
wget_vector_get	function
(	O
urls	pointer
,	O
it	int
)	O
;	O
if	O
(	O
baselen	long
&&	O
(	O
url	pointer
->	O
len	long
<=	O
baselen	long
||	O
wget_strncasecmp	function
(	O
url	pointer
->	O
p	pointer
,	O
base	pointer
->	O
uri	pointer
,	O
baselen	long
)	O
)	O
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%.*s' not followed (not matching sitemap location)\n"	pointer
)	O
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
wget_hashmap_put	function
(	O
known_urls	pointer
,	O
(	O
p	pointer
=	O
wget_strmemdup	function
(	O
url	pointer
->	O
p	pointer
,	O
url	pointer
->	O
len	long
)	O
)	O
,	O
NULL	O
)	O
)	O
{	O
info_printf	O
(	O
_	O
(	O
"URL '%.*s' not followed (already known)\n"	pointer
)	O
,	O
(	O
int	O
)	O
url	pointer
->	O
len	long
,	O
url	pointer
->	O
p	pointer
)	O
;	O
continue	O
;	O
}	O
add_url	function
(	O
job	pointer
,	O
encoding	pointer
,	O
p	pointer
,	O
0	int
)	O
;	O
}	O
wget_thread_mutex_unlock	function
(	O
known_urls_mutex	pointer
)	O
;	O
}	O
void	O
atom_parse	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
wget_vector	struct
*	O
urls	pointer
;	O
wget_atom_get_urls_inline	function
(	O
data	pointer
,	O
&	O
urls	pointer
)	O
;	O
_add_urls	function
(	O
job	pointer
,	O
urls	pointer
,	O
encoding	pointer
,	O
base	pointer
)	O
;	O
wget_vector_free	function
(	O
&	O
urls	pointer
)	O
;	O
}	O
void	O
atom_parse_localfile	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
char	O
*	O
data	pointer
;	O
if	O
(	O
(	O
data	pointer
=	O
wget_read_file	function
(	O
fname	pointer
,	O
NULL	O
)	O
)	O
)	O
atom_parse	function
(	O
job	pointer
,	O
data	pointer
,	O
encoding	pointer
,	O
base	pointer
)	O
;	O
xfree	O
(	O
data	pointer
)	O
;	O
}	O
void	O
rss_parse	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
wget_vector	struct
*	O
urls	pointer
;	O
wget_rss_get_urls_inline	function
(	O
data	pointer
,	O
&	O
urls	pointer
)	O
;	O
_add_urls	function
(	O
job	pointer
,	O
urls	pointer
,	O
encoding	pointer
,	O
base	pointer
)	O
;	O
wget_vector_free	function
(	O
&	O
urls	pointer
)	O
;	O
}	O
void	O
rss_parse_localfile	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
char	O
*	O
data	pointer
;	O
if	O
(	O
(	O
data	pointer
=	O
wget_read_file	function
(	O
fname	pointer
,	O
NULL	O
)	O
)	O
)	O
rss_parse	function
(	O
job	pointer
,	O
data	pointer
,	O
encoding	pointer
,	O
base	pointer
)	O
;	O
xfree	O
(	O
data	pointer
)	O
;	O
}	O
void	O
metalink_parse_localfile	function
(	O
const	O
char	O
*	O
fname	pointer
)	O
{	O
char	O
*	O
data	pointer
;	O
if	O
(	O
(	O
data	pointer
=	O
wget_read_file	function
(	O
fname	pointer
,	O
NULL	O
)	O
)	O
)	O
{	O
wget_metalink	struct
*	O
metalink	pointer
=	O
wget_metalink_parse	function
(	O
data	pointer
)	O
;	O
if	O
(	O
metalink	pointer
->	O
size	pointer
<=	O
0	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Invalid file length %llu\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
long	O
)	O
metalink	pointer
->	O
size	pointer
)	O
;	O
wget_metalink_free	function
(	O
&	O
metalink	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
metalink	pointer
->	O
mirrors	pointer
)	O
{	O
error_printf	O
(	O
_	O
(	O
"No download mirrors found\n"	pointer
)	O
)	O
;	O
wget_metalink_free	function
(	O
&	O
metalink	pointer
)	O
;	O
}	O
else	O
{	O
JOB	struct
job	pointer
=	O
{	O
.	O
metalink	pointer
=	O
metalink	pointer
}	O
;	O
if	O
(	O
!	O
job_validate_file	function
(	O
&	O
job	pointer
)	O
)	O
{	O
wget_metalink_sort_mirrors	function
(	O
metalink	pointer
)	O
;	O
wget_metalink_mirror	struct
*	O
mirror	char
=	O
wget_vector_get	function
(	O
metalink	pointer
->	O
mirrors	pointer
,	O
0	int
)	O
;	O
HOST	struct
*	O
host	pointer
;	O
if	O
(	O
!	O
(	O
host	pointer
=	O
host_add	function
(	O
mirror	char
->	O
iri	pointer
)	O
)	O
)	O
host	pointer
=	O
host_get	function
(	O
mirror	char
->	O
iri	pointer
)	O
;	O
host_add_job	function
(	O
host	pointer
,	O
&	O
job	pointer
)	O
;	O
}	O
else	O
{	O
wget_metalink_free	function
(	O
&	O
metalink	pointer
)	O
;	O
}	O
}	O
xfree	O
(	O
data	pointer
)	O
;	O
}	O
}	O
struct	O
css_context	struct
{	O
JOB	struct
*	O
job	pointer
;	O
wget_iri	struct
*	O
base	pointer
;	O
const	O
char	O
*	O
encoding	pointer
;	O
wget_buffer	struct
uri_buf	struct
;	O
char	O
encoding_allocated	char
;	O
}	O
;	O
static	O
void	O
_css_parse_encoding	function
(	O
void	O
*	O
context	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
size_t	long
len	long
)	O
{	O
struct	O
css_context	struct
*	O
ctx	pointer
=	O
context	pointer
;	O
if	O
(	O
!	O
ctx	pointer
->	O
encoding_allocated	char
&&	O
wget_strncasecmp_ascii	function
(	O
ctx	pointer
->	O
encoding	pointer
,	O
encoding	pointer
,	O
len	long
)	O
)	O
{	O
ctx	pointer
->	O
encoding	pointer
=	O
wget_strmemdup	function
(	O
encoding	pointer
,	O
len	long
)	O
;	O
ctx	pointer
->	O
encoding_allocated	char
=	O
1	int
;	O
info_printf	O
(	O
_	O
(	O
"URI content encoding = '%s'\n"	pointer
)	O
,	O
ctx	pointer
->	O
encoding	pointer
)	O
;	O
}	O
}	O
static	O
void	O
_css_parse_uri	function
(	O
void	O
*	O
context	pointer
,	O
const	O
char	O
*	O
url	pointer
,	O
size_t	long
len	long
,	O
size_t	long
pos	int
WGET_GCC_UNUSED	O
)	O
{	O
struct	O
css_context	struct
*	O
ctx	pointer
=	O
context	pointer
;	O
wget_string	struct
u	struct
=	O
{	O
url	pointer
,	O
len	long
}	O
;	O
if	O
(	O
_normalize_uri	function
(	O
ctx	pointer
->	O
base	pointer
,	O
&	O
u	struct
,	O
ctx	pointer
->	O
encoding	pointer
,	O
&	O
ctx	pointer
->	O
uri_buf	struct
)	O
)	O
return	O
;	O
if	O
(	O
!	O
ctx	pointer
->	O
base	pointer
&&	O
!	O
ctx	pointer
->	O
uri_buf	struct
.	O
length	long
)	O
info_printf	O
(	O
_	O
(	O
"URL '%.*s' not followed (missing base URI)\n"	pointer
)	O
,	O
(	O
int	O
)	O
len	long
,	O
url	pointer
)	O
;	O
else	O
add_url	function
(	O
ctx	pointer
->	O
job	pointer
,	O
ctx	pointer
->	O
encoding	pointer
,	O
ctx	pointer
->	O
uri_buf	struct
.	O
data	pointer
,	O
URL_FLG_REQUISITE	O
)	O
;	O
}	O
void	O
css_parse	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
size_t	long
len	long
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
struct	O
css_context	struct
context	pointer
=	O
{	O
.	O
base	pointer
=	O
base	pointer
,	O
.	O
job	pointer
=	O
job	pointer
,	O
.	O
encoding	pointer
=	O
encoding	pointer
}	O
;	O
char	O
sbuf	array
[	O
1024	int
]	O
;	O
wget_buffer_init	function
(	O
&	O
context	pointer
.	O
uri_buf	struct
,	O
sbuf	array
,	O
sizeof	O
(	O
sbuf	array
)	O
)	O
;	O
if	O
(	O
encoding	pointer
)	O
info_printf	O
(	O
_	O
(	O
"URI content encoding = '%s'\n"	pointer
)	O
,	O
encoding	pointer
)	O
;	O
wget_css_parse_buffer	function
(	O
data	pointer
,	O
len	long
,	O
_css_parse_uri	function
,	O
_css_parse_encoding	function
,	O
&	O
context	pointer
)	O
;	O
if	O
(	O
context	pointer
.	O
encoding_allocated	char
)	O
xfree	O
(	O
context	pointer
.	O
encoding	pointer
)	O
;	O
wget_buffer_deinit	function
(	O
&	O
context	pointer
.	O
uri_buf	struct
)	O
;	O
}	O
void	O
css_parse_localfile	function
(	O
JOB	struct
*	O
job	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
const	O
char	O
*	O
encoding	pointer
,	O
wget_iri	struct
*	O
base	pointer
)	O
{	O
struct	O
css_context	struct
context	pointer
=	O
{	O
.	O
base	pointer
=	O
base	pointer
,	O
.	O
job	pointer
=	O
job	pointer
,	O
.	O
encoding	pointer
=	O
encoding	pointer
}	O
;	O
char	O
sbuf	array
[	O
1024	int
]	O
;	O
wget_buffer_init	function
(	O
&	O
context	pointer
.	O
uri_buf	struct
,	O
sbuf	array
,	O
sizeof	O
(	O
sbuf	array
)	O
)	O
;	O
if	O
(	O
encoding	pointer
)	O
info_printf	O
(	O
_	O
(	O
"URI content encoding = '%s'\n"	pointer
)	O
,	O
encoding	pointer
)	O
;	O
wget_css_parse_file	function
(	O
fname	pointer
,	O
_css_parse_uri	function
,	O
_css_parse_encoding	function
,	O
&	O
context	pointer
)	O
;	O
if	O
(	O
context	pointer
.	O
encoding_allocated	char
)	O
xfree	O
(	O
context	pointer
.	O
encoding	pointer
)	O
;	O
wget_buffer_deinit	function
(	O
&	O
context	pointer
.	O
uri_buf	struct
)	O
;	O
}	O
static	O
long	O
long	O
WGET_GCC_NONNULL_ALL	O
get_file_size	function
(	O
const	O
char	O
*	O
fname	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
stat	struct
(	O
fname	pointer
,	O
&	O
st	struct
)	O
==	O
0	int
)	O
{	O
return	O
st	struct
.	O
st_size	long
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
time_t	long
WGET_GCC_NONNULL_ALL	O
get_file_mtime	function
(	O
const	O
char	O
*	O
fname	pointer
)	O
{	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
stat	struct
(	O
fname	pointer
,	O
&	O
st	struct
)	O
==	O
0	int
)	O
{	O
return	O
st	struct
.	O
st_mtime	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
time_t	long
WGET_GCC_NONNULL_ALL	O
get_file_lmtime	function
(	O
const	O
char	O
*	O
fname	pointer
)	O
{	O
time_t	long
ret	long
=	O
0	int
;	O
FILE	struct
*	O
fp	pointer
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
fname	pointer
,	O
"r"	pointer
)	O
)	O
)	O
{	O
char	O
tbuf	array
[	O
32	int
]	O
;	O
if	O
(	O
read_xattr_metadata	function
(	O
"user.last_modified"	pointer
,	O
tbuf	array
,	O
sizeof	O
(	O
tbuf	array
)	O
,	O
fileno	function
(	O
fp	pointer
)	O
)	O
>	O
0	int
)	O
ret	long
=	O
(	O
time_t	long
)	O
atoll	function
(	O
tbuf	array
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
if	O
(	O
!	O
ret	long
)	O
ret	long
=	O
get_file_mtime	function
(	O
fname	pointer
)	O
;	O
return	O
ret	long
;	O
}	O
static	O
void	O
set_file_mtime	function
(	O
int	O
fd	array
,	O
time_t	long
modified	long
)	O
{	O
struct	O
timespec	struct
timespecs	array
[	O
2	int
]	O
;	O
gettime	function
(	O
&	O
timespecs	array
[	O
0	int
]	O
)	O
;	O
timespecs	array
[	O
1	int
]	O
.	O
tv_sec	long
=	O
modified	long
;	O
timespecs	array
[	O
1	int
]	O
.	O
tv_nsec	long
=	O
0	int
;	O
if	O
(	O
futimens	function
(	O
fd	array
,	O
timespecs	array
)	O
==	O
-	O
1	int
)	O
error_printf	O
(	O
_	O
(	O
"Failed to set file date: %s\n"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
static	O
int	O
_wa_open	function
(	O
const	O
char	O
*	O
fname	pointer
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
)	O
{	O
int	O
fd	array
=	O
open	function
(	O
fname	pointer
,	O
flags	int
,	O
mode	int
)	O
;	O
return	O
fd	array
;	O
}	O
static	O
int	O
_open_unique	function
(	O
const	O
char	O
*	O
fname	pointer
,	O
int	O
flags	int
,	O
mode_t	int
mode	int
,	O
int	O
multiple	int
,	O
char	O
*	O
unique	pointer
,	O
size_t	long
unique_len	long
)	O
{	O
int	O
fd	array
;	O
if	O
(	O
unique_len	long
&&	O
unique	pointer
[	O
0	int
]	O
)	O
return	O
_wa_open	function
(	O
unique	pointer
,	O
flags	int
,	O
mode	int
)	O
;	O
fd	array
=	O
_wa_open	function
(	O
fname	pointer
,	O
flags	int
,	O
mode	int
)	O
;	O
if	O
(	O
fd	array
>=	O
0	int
)	O
return	O
fd	array
;	O
if	O
(	O
config	struct
.	O
keep_extension	char
)	O
{	O
const	O
char	O
*	O
ext	pointer
=	O
strrchr	function
(	O
fname	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
!	O
ext	pointer
)	O
ext	pointer
=	O
fname	pointer
+	O
strlen	function
(	O
fname	pointer
)	O
;	O
for	O
(	O
int	O
i	int
=	O
1	int
;	O
i	int
<	O
99999	int
&&	O
fd	array
<	O
0	int
&&	O
(	O
(	O
multiple	int
&&	O
errno	O
==	O
EEXIST	int
)	O
||	O
errno	O
==	O
EISDIR	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
wget_snprintf	function
(	O
unique	pointer
,	O
unique_len	long
,	O
"%.*s_%d%s"	pointer
,	O
(	O
int	O
)	O
(	O
ext	pointer
-	O
fname	pointer
)	O
,	O
fname	pointer
,	O
i	int
,	O
ext	pointer
)	O
>=	O
unique_len	long
)	O
return	O
-	O
1	int
;	O
fd	array
=	O
_wa_open	function
(	O
unique	pointer
,	O
flags	int
,	O
mode	int
)	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
int	O
i	int
=	O
1	int
;	O
i	int
<	O
99999	int
&&	O
fd	array
<	O
0	int
&&	O
(	O
(	O
multiple	int
&&	O
errno	O
==	O
EEXIST	int
)	O
||	O
errno	O
==	O
EISDIR	int
)	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
wget_snprintf	function
(	O
unique	pointer
,	O
unique_len	long
,	O
"%s.%d"	pointer
,	O
fname	pointer
,	O
i	int
)	O
>=	O
unique_len	long
)	O
return	O
-	O
1	int
;	O
fd	array
=	O
_wa_open	function
(	O
unique	pointer
,	O
flags	int
,	O
mode	int
)	O
;	O
}	O
}	O
return	O
fd	array
;	O
}	O
static	O
bool	bool
check_mime_list	function
(	O
wget_vector	struct
*	O
list	pointer
,	O
const	O
char	O
*	O
mime	pointer
)	O
{	O
char	O
result	char
=	O
0	int
;	O
for	O
(	O
int	O
i	int
=	O
0	int
;	O
i	int
<	O
wget_vector_size	function
(	O
list	pointer
)	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
entry	pointer
=	O
wget_vector_get	function
(	O
list	pointer
,	O
i	int
)	O
;	O
bool	bool
exclude	bool
=	O
(	O
*	O
entry	pointer
==	O
'!'	O
)	O
;	O
debug_printf	O
(	O
"mime check %s - %s"	pointer
,	O
entry	pointer
,	O
mime	pointer
)	O
;	O
entry	pointer
+=	O
exclude	bool
;	O
if	O
(	O
strpbrk	function
(	O
entry	pointer
,	O
"*?[]"	pointer
)	O
&&	O
!	O
fnmatch	function
(	O
entry	pointer
,	O
mime	pointer
,	O
FNM_CASEFOLD	O
)	O
)	O
result	char
=	O
!	O
exclude	bool
;	O
else	O
if	O
(	O
!	O
wget_strcasecmp	function
(	O
entry	pointer
,	O
mime	pointer
)	O
)	O
result	char
=	O
!	O
exclude	bool
;	O
}	O
debug_printf	O
(	O
"mime check %d"	pointer
,	O
result	char
)	O
;	O
return	O
result	char
;	O
}	O
static	O
int	O
WGET_GCC_NONNULL	O
(	O
(	O
1	int
)	O
)	O
_prepare_file	function
(	O
wget_http_response	struct
*	O
resp	pointer
,	O
const	O
char	O
*	O
fname	pointer
,	O
int	O
flag	int
,	O
wget_iri	struct
*	O
uri	pointer
,	O
wget_iri	struct
*	O
original_url	pointer
,	O
int	O
ignore_patterns	bool
,	O
wget_buffer	struct
*	O
partial_content	pointer
,	O
size_t	long
max_partial_content	long
,	O
char	O
*	O
*	O
actual_file_name	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
JOB	struct
*	O
job	pointer
=	O
resp	pointer
->	O
req	pointer
->	O
user_data	pointer
;	O
char	O
*	O
alloced_fname	pointer
=	O
NULL	O
;	O
int	O
fd	array
,	O
multiple	int
=	O
0	int
,	O
oflag	int
=	O
flag	int
;	O
size_t	long
fname_length	long
;	O
long	O
long	O
old_quota	long long
;	O
if	O
(	O
!	O
fname	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
config	struct
.	O
spider	char
)	O
{	O
debug_printf	O
(	O
"not saved '%s' (spider mode enabled)\n"	pointer
,	O
fname	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
config	struct
.	O
mime_types	pointer
&&	O
!	O
check_mime_list	function
(	O
config	struct
.	O
mime_types	pointer
,	O
resp	pointer
->	O
content_type	pointer
?	O
resp	pointer
->	O
content_type	pointer
:	O
"application/octet-stream"	pointer
)	O
)	O
return	O
-	O
2	int
;	O
fname_length	long
=	O
strlen	function
(	O
fname	pointer
)	O
;	O
if	O
(	O
fname	pointer
[	O
fname_length	long
-	O
1	int
]	O
==	O
'/'	O
)	O
{	O
debug_printf	O
(	O
"not saved '%s' (file is a directory)\n"	pointer
,	O
fname	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
old_quota	long long
=	O
quota_modify_read	function
(	O
config	struct
.	O
save_headers	char
?	O
resp	pointer
->	O
header	pointer
->	O
length	long
:	O
0	int
)	O
;	O
if	O
(	O
config	struct
.	O
quota	long long
&&	O
old_quota	long long
>=	O
config	struct
.	O
quota	long long
)	O
{	O
debug_printf	O
(	O
"not saved '%s' (quota of %lld reached)\n"	pointer
,	O
fname	pointer
,	O
config	struct
.	O
quota	long long
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fname	pointer
==	O
config	struct
.	O
output_document	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
fname	pointer
,	O
"-"	pointer
)	O
)	O
{	O
if	O
(	O
config	struct
.	O
save_headers	char
)	O
{	O
size_t	long
rc	int
=	O
safe_write	function
(	O
1	int
,	O
resp	pointer
->	O
header	pointer
->	O
data	pointer
,	O
resp	pointer
->	O
header	pointer
->	O
length	long
)	O
;	O
if	O
(	O
rc	int
==	O
SAFE_WRITE_ERROR	O
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to write to STDOUT (%zu, errno=%d)\n"	pointer
)	O
,	O
rc	int
,	O
errno	O
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_IO	int
)	O
;	O
}	O
}	O
return	O
dup	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
delete_after	char
)	O
{	O
debug_printf	O
(	O
"not saved '%s' (--delete-after)\n"	pointer
,	O
fname	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
if	O
(	O
!	O
strcmp	function
(	O
fname	pointer
,	O
"/dev/null"	pointer
)	O
)	O
{	O
return	O
-	O
2	int
;	O
}	O
flag	int
=	O
O_APPEND	int
;	O
}	O
if	O
(	O
config	struct
.	O
adjust_extension	char
&&	O
resp	pointer
->	O
content_type	pointer
)	O
{	O
const	O
char	O
*	O
ext	pointer
;	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"text/html"	pointer
)	O
||	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/xhtml+xml"	pointer
)	O
)	O
{	O
ext	pointer
=	O
".html"	pointer
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"text/css"	pointer
)	O
)	O
{	O
ext	pointer
=	O
".css"	pointer
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/atom+xml"	pointer
)	O
)	O
{	O
ext	pointer
=	O
".atom"	pointer
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/rss+xml"	pointer
)	O
)	O
{	O
ext	pointer
=	O
".rss"	pointer
;	O
}	O
else	O
ext	pointer
=	O
NULL	O
;	O
if	O
(	O
ext	pointer
)	O
{	O
size_t	long
ext_length	long
=	O
strlen	function
(	O
ext	pointer
)	O
;	O
if	O
(	O
fname_length	long
>=	O
ext_length	long
&&	O
wget_strcasecmp_ascii	function
(	O
fname	pointer
+	O
fname_length	long
-	O
ext_length	long
,	O
ext	pointer
)	O
)	O
{	O
alloced_fname	pointer
=	O
wget_malloc	function
(	O
fname_length	long
+	O
ext_length	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
alloced_fname	pointer
,	O
fname	pointer
,	O
fname_length	long
)	O
;	O
memcpy	function
(	O
alloced_fname	pointer
+	O
fname_length	long
,	O
ext	pointer
,	O
ext_length	long
+	O
1	int
)	O
;	O
fname	pointer
=	O
alloced_fname	pointer
;	O
}	O
}	O
}	O
if	O
(	O
!	O
ignore_patterns	bool
)	O
{	O
if	O
(	O
(	O
config	struct
.	O
accept_patterns	pointer
&&	O
!	O
in_pattern_list	function
(	O
config	struct
.	O
accept_patterns	pointer
,	O
fname	pointer
)	O
)	O
||	O
(	O
config	struct
.	O
accept_regex	pointer
&&	O
!	O
regex_match	function
(	O
fname	pointer
,	O
config	struct
.	O
accept_regex	pointer
)	O
)	O
)	O
{	O
debug_printf	O
(	O
"not saved '%s' (doesn't match accept pattern)\n"	pointer
,	O
fname	pointer
)	O
;	O
xfree	O
(	O
alloced_fname	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
if	O
(	O
(	O
config	struct
.	O
reject_patterns	pointer
&&	O
in_pattern_list	function
(	O
config	struct
.	O
reject_patterns	pointer
,	O
fname	pointer
)	O
)	O
||	O
(	O
config	struct
.	O
reject_regex	pointer
&&	O
regex_match	function
(	O
fname	pointer
,	O
config	struct
.	O
reject_regex	pointer
)	O
)	O
)	O
{	O
debug_printf	O
(	O
"not saved '%s' (matches reject pattern)\n"	pointer
,	O
fname	pointer
)	O
;	O
xfree	O
(	O
alloced_fname	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
if	O
(	O
config	struct
.	O
exclude_directories	pointer
&&	O
in_directory_pattern_list	function
(	O
config	struct
.	O
exclude_directories	pointer
,	O
path	pointer
)	O
)	O
{	O
debug_printf	O
(	O
"not saved '%s' (directory excluded)\n"	pointer
,	O
path	pointer
)	O
;	O
xfree	O
(	O
alloced_fname	pointer
)	O
;	O
return	O
-	O
2	int
;	O
}	O
}	O
wget_thread_mutex_lock	function
(	O
savefile_mutex	pointer
)	O
;	O
fname_length	long
+=	O
16	int
;	O
if	O
(	O
config	struct
.	O
timestamping	char
)	O
{	O
if	O
(	O
oflag	int
==	O
O_TRUNC	int
)	O
flag	int
=	O
O_TRUNC	int
;	O
}	O
else	O
if	O
(	O
!	O
config	struct
.	O
clobber	char
||	O
(	O
config	struct
.	O
recursive	char
&&	O
config	struct
.	O
directories	char
)	O
)	O
{	O
if	O
(	O
oflag	int
==	O
O_TRUNC	int
&&	O
(	O
!	O
(	O
config	struct
.	O
recursive	char
&&	O
config	struct
.	O
directories	char
)	O
||	O
(	O
config	struct
.	O
page_requisites	char
&&	O
!	O
config	struct
.	O
clobber	char
)	O
)	O
)	O
{	O
flag	int
=	O
O_EXCL	int
;	O
}	O
}	O
else	O
if	O
(	O
flag	int
!=	O
O_APPEND	int
)	O
{	O
multiple	int
=	O
1	int
;	O
flag	int
=	O
O_EXCL	int
;	O
if	O
(	O
config	struct
.	O
backups	int
)	O
{	O
char	O
src	pointer
[	O
fname_length	long
+	O
1	int
]	O
,	O
dst	pointer
[	O
fname_length	long
+	O
1	int
]	O
;	O
for	O
(	O
int	O
it	int
=	O
config	struct
.	O
backups	int
;	O
it	int
>	O
0	int
;	O
it	int
--	O
)	O
{	O
if	O
(	O
it	int
>	O
1	int
)	O
wget_snprintf	function
(	O
src	pointer
,	O
sizeof	O
(	O
src	pointer
)	O
,	O
"%s.%d"	pointer
,	O
fname	pointer
,	O
it	int
-	O
1	int
)	O
;	O
else	O
wget_strscpy	function
(	O
src	pointer
,	O
fname	pointer
,	O
sizeof	O
(	O
src	pointer
)	O
)	O
;	O
wget_snprintf	function
(	O
dst	pointer
,	O
sizeof	O
(	O
dst	pointer
)	O
,	O
"%s.%d"	pointer
,	O
fname	pointer
,	O
it	int
)	O
;	O
if	O
(	O
rename	function
(	O
src	pointer
,	O
dst	pointer
)	O
==	O
-	O
1	int
&&	O
errno	O
!=	O
ENOENT	int
)	O
error_printf	O
(	O
_	O
(	O
"Failed to rename %s to %s (errno=%d)\n"	pointer
)	O
,	O
src	pointer
,	O
dst	pointer
,	O
errno	O
)	O
;	O
}	O
}	O
}	O
mkdir_path	function
(	O
(	O
char	O
*	O
)	O
fname	pointer
,	O
true	int
)	O
;	O
char	O
unique	pointer
[	O
fname_length	long
+	O
1	int
]	O
;	O
*	O
unique	pointer
=	O
0	int
;	O
if	O
(	O
partial_content	pointer
)	O
{	O
long	O
long	O
size	pointer
=	O
get_file_size	function
(	O
unique	pointer
[	O
0	int
]	O
?	O
unique	pointer
:	O
fname	pointer
)	O
;	O
if	O
(	O
size	pointer
>	O
0	int
)	O
{	O
fd	array
=	O
_open_unique	function
(	O
fname	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
,	O
0	int
,	O
multiple	int
,	O
unique	pointer
,	O
sizeof	O
(	O
unique	pointer
)	O
)	O
;	O
if	O
(	O
fd	array
>=	O
0	int
)	O
{	O
size_t	long
rc	int
;	O
if	O
(	O
(	O
unsigned	O
long	O
long	O
)	O
size	pointer
>	O
max_partial_content	long
)	O
size	pointer
=	O
max_partial_content	long
;	O
wget_buffer_memset_append	function
(	O
partial_content	pointer
,	O
0	int
,	O
size	pointer
)	O
;	O
rc	int
=	O
safe_read	function
(	O
fd	array
,	O
partial_content	pointer
->	O
data	pointer
,	O
size	pointer
)	O
;	O
if	O
(	O
rc	int
==	O
SAFE_READ_ERROR	O
||	O
(	O
long	O
long	O
)	O
rc	int
!=	O
size	pointer
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to load partial content from '%s' (errno=%d): %s\n"	pointer
)	O
,	O
fname	pointer
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_IO	int
)	O
;	O
}	O
close	function
(	O
fd	array
)	O
;	O
}	O
else	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to load partial content from '%s' (errno=%d): %s\n"	pointer
)	O
,	O
fname	pointer
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_IO	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
config	struct
.	O
unlink	function
&&	O
flag	int
==	O
O_TRUNC	int
)	O
{	O
if	O
(	O
unlink	function
(	O
fname	pointer
)	O
<	O
0	int
&&	O
errno	O
!=	O
ENOENT	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to unlink '%s' (errno=%d): %s\n"	pointer
)	O
,	O
fname	pointer
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_IO	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
fd	array
=	O
_open_unique	function
(	O
fname	pointer
,	O
O_WRONLY	int
|	O
flag	int
|	O
O_CREAT	int
|	O
O_NONBLOCK	int
|	O
O_BINARY	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IRGRP	O
|	O
S_IROTH	O
,	O
multiple	int
,	O
unique	pointer
,	O
sizeof	O
(	O
unique	pointer
)	O
)	O
;	O
wget_asprintf	function
(	O
actual_file_name	pointer
,	O
"%s"	pointer
,	O
unique	pointer
[	O
0	int
]	O
?	O
unique	pointer
:	O
fname	pointer
)	O
;	O
if	O
(	O
fd	array
>=	O
0	int
)	O
{	O
ssize_t	long
rc	int
;	O
info_printf	O
(	O
_	O
(	O
"Saving '%s'\n"	pointer
)	O
,	O
*	O
actual_file_name	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
save_headers	char
)	O
{	O
if	O
(	O
(	O
rc	int
=	O
write	function
(	O
fd	array
,	O
resp	pointer
->	O
header	pointer
->	O
data	pointer
,	O
resp	pointer
->	O
header	pointer
->	O
length	long
)	O
)	O
!=	O
(	O
ssize_t	long
)	O
resp	pointer
->	O
header	pointer
->	O
length	long
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to write file %s (%zd, errno=%d)\n"	pointer
)	O
,	O
*	O
actual_file_name	pointer
,	O
rc	int
,	O
errno	O
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_IO	int
)	O
;	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
fd	array
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EEXIST	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"File '%s' already there; not retrieving.\n"	pointer
)	O
,	O
fname	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
page_requisites	char
&&	O
!	O
config	struct
.	O
clobber	char
)	O
{	O
parse_localfile	function
(	O
job	pointer
,	O
job	pointer
->	O
local_filename	pointer
,	O
config	struct
.	O
remote_encoding	pointer
,	O
resp	pointer
->	O
content_type	pointer
,	O
job	pointer
->	O
iri	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
errno	O
==	O
EISDIR	int
)	O
info_printf	O
(	O
_	O
(	O
"Directory / file name clash - not saving '%s'\n"	pointer
)	O
,	O
fname	pointer
)	O
;	O
else	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to open '%s' (errno=%d): %s\n"	pointer
)	O
,	O
fname	pointer
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_IO	int
)	O
;	O
}	O
}	O
}	O
if	O
(	O
config	struct
.	O
xattr	char
)	O
{	O
FILE	struct
*	O
fp	pointer
;	O
if	O
(	O
(	O
fp	pointer
=	O
fopen	function
(	O
*	O
actual_file_name	pointer
,	O
"ab"	pointer
)	O
)	O
)	O
{	O
set_file_metadata	function
(	O
uri	pointer
,	O
original_url	pointer
,	O
resp	pointer
->	O
content_type	pointer
,	O
resp	pointer
->	O
content_type_encoding	pointer
,	O
resp	pointer
->	O
last_modified	long
?	O
resp	pointer
->	O
last_modified	long
-	O
1	int
:	O
0	int
,	O
fp	pointer
)	O
;	O
fclose	function
(	O
fp	pointer
)	O
;	O
}	O
else	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to save extended attribute %s\n"	pointer
)	O
,	O
*	O
actual_file_name	pointer
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_IO	int
)	O
;	O
}	O
}	O
wget_thread_mutex_unlock	function
(	O
savefile_mutex	pointer
)	O
;	O
xfree	O
(	O
alloced_fname	pointer
)	O
;	O
return	O
fd	array
;	O
}	O
struct	O
_body_callback_context	struct
{	O
JOB	struct
*	O
job	pointer
;	O
wget_buffer	struct
*	O
body	pointer
;	O
uint64_t	long
max_memory	long
;	O
uint64_t	long
length	long
;	O
int	O
outfd	int
;	O
int	O
progress_slot	int
;	O
long	O
long	O
limit_debt_bytes	long long
;	O
long	O
long	O
limit_prev_time_ms	long long
;	O
}	O
;	O
static	O
int	O
_get_requested_range	function
(	O
void	O
*	O
ctx	pointer
,	O
void	O
*	O
elem	pointer
)	O
{	O
wget_http_header_param	struct
*	O
param	pointer
=	O
(	O
wget_http_header_param	struct
*	O
)	O
elem	pointer
;	O
long	O
long	O
*	O
ret	long
=	O
(	O
long	O
long	O
*	O
)	O
ctx	pointer
;	O
if	O
(	O
!	O
strcmp	function
(	O
param	pointer
->	O
name	pointer
,	O
"Range"	pointer
)	O
)	O
{	O
*	O
ret	long
=	O
atoll	function
(	O
param	pointer
->	O
value	pointer
+	O
6	int
)	O
;	O
return	O
1	int
;	O
}	O
else	O
return	O
0	int
;	O
}	O
static	O
int	O
_get_header	function
(	O
wget_http_response	struct
*	O
resp	pointer
,	O
void	O
*	O
context	pointer
)	O
{	O
struct	O
_body_callback_context	struct
*	O
ctx	pointer
=	O
(	O
struct	O
_body_callback_context	struct
*	O
)	O
context	pointer
;	O
PART	struct
*	O
part	pointer
;	O
const	O
char	O
*	O
dest	pointer
=	O
NULL	O
,	O
*	O
name	pointer
;	O
int	O
ret	long
=	O
0	int
;	O
bool	bool
metalink	pointer
=	O
config	struct
.	O
metalink	pointer
&&	O
resp	pointer
->	O
content_type	pointer
&&	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/metalink4+xml"	pointer
)	O
||	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
content_type	pointer
,	O
"application/metalink+xml"	pointer
)	O
)	O
;	O
if	O
(	O
ctx	pointer
->	O
job	pointer
->	O
head_first	bool
||	O
(	O
config	struct
.	O
metalink	pointer
&&	O
metalink	pointer
)	O
)	O
{	O
name	pointer
=	O
ctx	pointer
->	O
job	pointer
->	O
local_filename	pointer
;	O
}	O
else	O
if	O
(	O
(	O
part	pointer
=	O
ctx	pointer
->	O
job	pointer
->	O
part	pointer
)	O
)	O
{	O
name	pointer
=	O
ctx	pointer
->	O
job	pointer
->	O
metalink	pointer
->	O
name	pointer
;	O
ctx	pointer
->	O
outfd	int
=	O
open	function
(	O
ctx	pointer
->	O
job	pointer
->	O
metalink	pointer
->	O
name	pointer
,	O
O_WRONLY	int
|	O
O_CREAT	int
|	O
O_NONBLOCK	int
|	O
O_BINARY	int
,	O
S_IRUSR	O
|	O
S_IWUSR	O
|	O
S_IRGRP	O
|	O
S_IROTH	O
)	O
;	O
if	O
(	O
ctx	pointer
->	O
outfd	int
==	O
-	O
1	int
)	O
{	O
set_exit_status	function
(	O
WG_EXIT_STATUS_IO	int
)	O
;	O
ret	long
=	O
-	O
1	int
;	O
goto	O
out	pointer
;	O
}	O
if	O
(	O
lseek	function
(	O
ctx	pointer
->	O
outfd	int
,	O
part	pointer
->	O
position	long
,	O
SEEK_SET	int
)	O
==	O
(	O
off_t	long
)	O
-	O
1	int
)	O
{	O
close	function
(	O
ctx	pointer
->	O
outfd	int
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_IO	int
)	O
;	O
ret	long
=	O
-	O
1	int
;	O
goto	O
out	pointer
;	O
}	O
}	O
else	O
if	O
(	O
config	struct
.	O
content_disposition	char
&&	O
resp	pointer
->	O
content_filename	pointer
)	O
{	O
name	pointer
=	O
dest	pointer
=	O
resp	pointer
->	O
content_filename	pointer
;	O
}	O
else	O
name	pointer
=	O
dest	pointer
=	O
config	struct
.	O
output_document	pointer
?	O
config	struct
.	O
output_document	pointer
:	O
ctx	pointer
->	O
job	pointer
->	O
local_filename	pointer
;	O
if	O
(	O
dest	pointer
&&	O
(	O
(	O
config	struct
.	O
save_content_on	pointer
&&	O
check_status_code_list	function
(	O
config	struct
.	O
save_content_on	pointer
,	O
resp	pointer
->	O
code	short
)	O
)	O
||	O
(	O
!	O
config	struct
.	O
save_content_on	pointer
&&	O
(	O
resp	pointer
->	O
code	short
==	O
200	int
||	O
resp	pointer
->	O
code	short
==	O
206	int
||	O
config	struct
.	O
content_on_error	char
)	O
)	O
)	O
)	O
{	O
xfree	O
(	O
ctx	pointer
->	O
job	pointer
->	O
sig_filename	pointer
)	O
;	O
ctx	pointer
->	O
outfd	int
=	O
_prepare_file	function
(	O
resp	pointer
,	O
dest	pointer
,	O
resp	pointer
->	O
code	short
==	O
206	int
?	O
O_APPEND	int
:	O
O_TRUNC	int
,	O
ctx	pointer
->	O
job	pointer
->	O
iri	pointer
,	O
ctx	pointer
->	O
job	pointer
->	O
original_url	pointer
,	O
ctx	pointer
->	O
job	pointer
->	O
ignore_patterns	bool
,	O
resp	pointer
->	O
code	short
==	O
206	int
?	O
ctx	pointer
->	O
body	pointer
:	O
NULL	O
,	O
ctx	pointer
->	O
max_memory	long
,	O
&	O
ctx	pointer
->	O
job	pointer
->	O
sig_filename	pointer
,	O
ctx	pointer
->	O
job	pointer
->	O
iri	pointer
->	O
path	pointer
)	O
;	O
if	O
(	O
ctx	pointer
->	O
outfd	int
==	O
-	O
1	int
)	O
ret	long
=	O
-	O
1	int
;	O
}	O
out	pointer
:	O
if	O
(	O
config	struct
.	O
progress	char
)	O
{	O
const	O
char	O
*	O
filename	pointer
=	O
NULL	O
;	O
if	O
(	O
!	O
name	pointer
)	O
{	O
filename	pointer
=	O
_get_local_filename	function
(	O
ctx	pointer
->	O
job	pointer
->	O
iri	pointer
)	O
;	O
if	O
(	O
(	O
name	pointer
=	O
strrchr	function
(	O
filename	pointer
,	O
'/'	O
)	O
)	O
)	O
name	pointer
+=	O
1	int
;	O
else	O
name	pointer
=	O
filename	pointer
;	O
}	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
resp	pointer
->	O
req	pointer
->	O
method	array
,	O
"HEAD"	pointer
)	O
)	O
{	O
bar_slot_begin	function
(	O
ctx	pointer
->	O
progress_slot	int
,	O
name	pointer
,	O
0	int
,	O
resp	pointer
->	O
header	pointer
->	O
length	long
)	O
;	O
bar_set_downloaded	function
(	O
ctx	pointer
->	O
progress_slot	int
,	O
resp	pointer
->	O
header	pointer
->	O
length	long
)	O
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
continue_download	char
&&	O
resp	pointer
->	O
code	short
==	O
206	int
)	O
{	O
long	O
long	O
already_downloaded	long long
;	O
wget_vector_browse	function
(	O
resp	pointer
->	O
req	pointer
->	O
headers	pointer
,	O
_get_requested_range	function
,	O
&	O
already_downloaded	long long
)	O
;	O
bar_slot_begin	function
(	O
ctx	pointer
->	O
progress_slot	int
,	O
name	pointer
,	O
1	int
,	O
resp	pointer
->	O
content_length	long
+	O
already_downloaded	long long
)	O
;	O
bar_set_downloaded	function
(	O
ctx	pointer
->	O
progress_slot	int
,	O
already_downloaded	long long
)	O
;	O
}	O
else	O
{	O
bar_slot_begin	function
(	O
ctx	pointer
->	O
progress_slot	int
,	O
name	pointer
,	O
(	O
(	O
resp	pointer
->	O
code	short
==	O
200	int
||	O
resp	pointer
->	O
code	short
==	O
206	int
)	O
?	O
1	int
:	O
0	int
)	O
,	O
resp	pointer
->	O
content_length	long
)	O
;	O
}	O
xfree	O
(	O
filename	pointer
)	O
;	O
}	O
return	O
ret	long
;	O
}	O
static	O
bool	bool
check_status_code_list	function
(	O
wget_vector	struct
*	O
list	pointer
,	O
uint16_t	short
status	int
)	O
{	O
char	O
result	char
=	O
0	int
;	O
char	O
key	int
[	O
6	int
]	O
;	O
wget_snprintf	function
(	O
key	int
,	O
sizeof	O
(	O
key	int
)	O
,	O
"%hu"	pointer
,	O
status	int
)	O
;	O
for	O
(	O
int	O
i	int
=	O
0	int
;	O
i	int
<	O
wget_vector_size	function
(	O
list	pointer
)	O
;	O
i	int
++	O
)	O
{	O
char	O
*	O
entry	pointer
=	O
wget_vector_get	function
(	O
list	pointer
,	O
i	int
)	O
;	O
bool	bool
exclude	bool
=	O
(	O
*	O
entry	pointer
==	O
'!'	O
)	O
;	O
entry	pointer
+=	O
exclude	bool
;	O
if	O
(	O
strpbrk	function
(	O
entry	pointer
,	O
"*"	pointer
)	O
&&	O
!	O
fnmatch	function
(	O
entry	pointer
,	O
key	int
,	O
FNM_CASEFOLD	O
)	O
)	O
result	char
=	O
!	O
exclude	bool
;	O
else	O
if	O
(	O
!	O
wget_strcasecmp	function
(	O
entry	pointer
,	O
key	int
)	O
)	O
result	char
=	O
!	O
exclude	bool
;	O
}	O
return	O
result	char
;	O
}	O
static	O
void	O
limit_transfer_rate	function
(	O
struct	O
_body_callback_context	struct
*	O
ctx	pointer
,	O
size_t	long
read_bytes	long
)	O
{	O
long	O
sleep_ms	long
;	O
long	O
elapsed_ms	long
;	O
long	O
long	O
curr_time_ms	long long
;	O
long	O
long	O
thread_rate_limit	long long
;	O
if	O
(	O
nthreads	int
>	O
1	int
)	O
{	O
thread_rate_limit	long long
=	O
config	struct
.	O
limit_rate	long long
/	O
nthreads	int
;	O
}	O
else	O
{	O
thread_rate_limit	long long
=	O
config	struct
.	O
limit_rate	long long
;	O
}	O
ctx	pointer
->	O
limit_debt_bytes	long long
+=	O
(	O
long	O
long	O
)	O
read_bytes	long
;	O
curr_time_ms	long long
=	O
wget_get_timemillis	function
(	O
)	O
;	O
if	O
(	O
ctx	pointer
->	O
limit_prev_time_ms	long long
!=	O
0	int
)	O
{	O
elapsed_ms	long
=	O
(	O
curr_time_ms	long long
-	O
ctx	pointer
->	O
limit_prev_time_ms	long long
)	O
;	O
ctx	pointer
->	O
limit_debt_bytes	long long
-=	O
elapsed_ms	long
*	O
thread_rate_limit	long long
/	O
1000	int
;	O
}	O
if	O
(	O
ctx	pointer
->	O
limit_debt_bytes	long long
<=	O
0	int
)	O
{	O
ctx	pointer
->	O
limit_debt_bytes	long long
=	O
0	int
;	O
ctx	pointer
->	O
limit_prev_time_ms	long long
=	O
curr_time_ms	long long
;	O
return	O
;	O
}	O
sleep_ms	long
=	O
ctx	pointer
->	O
limit_debt_bytes	long long
*	O
1000	int
/	O
thread_rate_limit	long long
;	O
wget_millisleep	function
(	O
sleep_ms	long
)	O
;	O
ctx	pointer
->	O
limit_prev_time_ms	long long
=	O
wget_get_timemillis	function
(	O
)	O
;	O
elapsed_ms	long
=	O
ctx	pointer
->	O
limit_prev_time_ms	long long
-	O
curr_time_ms	long long
;	O
ctx	pointer
->	O
limit_debt_bytes	long long
=	O
(	O
sleep_ms	long
-	O
elapsed_ms	long
)	O
*	O
thread_rate_limit	long long
/	O
1000	int
;	O
}	O
static	O
int	O
_get_body	function
(	O
wget_http_response	struct
*	O
resp	pointer
,	O
void	O
*	O
context	pointer
,	O
const	O
char	O
*	O
data	pointer
,	O
size_t	long
length	long
)	O
{	O
struct	O
_body_callback_context	struct
*	O
ctx	pointer
=	O
(	O
struct	O
_body_callback_context	struct
*	O
)	O
context	pointer
;	O
if	O
(	O
ctx	pointer
->	O
length	long
==	O
0	int
)	O
{	O
if	O
(	O
config	struct
.	O
server_response	char
)	O
info_printf	O
(	O
_	O
(	O
"# got header %zu bytes:\n%s\n"	pointer
)	O
,	O
resp	pointer
->	O
header	pointer
->	O
length	long
,	O
resp	pointer
->	O
header	pointer
->	O
data	pointer
)	O
;	O
}	O
ctx	pointer
->	O
length	long
+=	O
length	long
;	O
if	O
(	O
ctx	pointer
->	O
outfd	int
>=	O
0	int
)	O
{	O
size_t	long
written	long
=	O
safe_write	function
(	O
ctx	pointer
->	O
outfd	int
,	O
data	pointer
,	O
length	long
)	O
;	O
if	O
(	O
written	long
==	O
SAFE_WRITE_ERROR	O
)	O
{	O
if	O
(	O
errno	O
==	O
EAGAIN	int
&&	O
!	O
terminate	bool
)	O
{	O
if	O
(	O
wget_ready_2_write	function
(	O
ctx	pointer
->	O
outfd	int
,	O
1000	int
)	O
>	O
0	int
)	O
{	O
written	long
=	O
safe_write	function
(	O
ctx	pointer
->	O
outfd	int
,	O
data	pointer
,	O
length	long
)	O
;	O
}	O
}	O
}	O
if	O
(	O
written	long
==	O
SAFE_WRITE_ERROR	O
)	O
{	O
if	O
(	O
!	O
terminate	bool
)	O
debug_printf	O
(	O
"Failed to write errno=%d\n"	pointer
,	O
errno	O
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_IO	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
if	O
(	O
ctx	pointer
->	O
max_memory	long
==	O
0	int
||	O
ctx	pointer
->	O
length	long
<	O
ctx	pointer
->	O
max_memory	long
)	O
wget_buffer_memcat	function
(	O
ctx	pointer
->	O
body	pointer
,	O
data	pointer
,	O
length	long
)	O
;	O
if	O
(	O
config	struct
.	O
progress	char
)	O
{	O
bar_set_downloaded	function
(	O
ctx	pointer
->	O
progress_slot	int
,	O
resp	pointer
->	O
cur_downloaded	long
-	O
resp	pointer
->	O
accounted_for	long
)	O
;	O
resp	pointer
->	O
accounted_for	long
=	O
resp	pointer
->	O
cur_downloaded	long
;	O
}	O
if	O
(	O
config	struct
.	O
limit_rate	long long
)	O
limit_transfer_rate	function
(	O
ctx	pointer
,	O
length	long
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
_add_authorize_header	function
(	O
wget_http_request	struct
*	O
req	pointer
,	O
wget_vector	struct
*	O
challenges	pointer
,	O
const	O
char	O
*	O
username	pointer
,	O
const	O
char	O
*	O
password	pointer
,	O
int	O
proxied	int
)	O
{	O
wget_http_challenge	struct
*	O
selected_challenge	pointer
=	O
NULL	O
;	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
wget_vector_size	function
(	O
challenges	pointer
)	O
;	O
it	int
++	O
)	O
{	O
wget_http_challenge	struct
*	O
challenge	pointer
=	O
wget_vector_get	function
(	O
challenges	pointer
,	O
it	int
)	O
;	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
challenge	pointer
->	O
auth_scheme	pointer
,	O
"digest"	pointer
)	O
)	O
{	O
selected_challenge	pointer
=	O
challenge	pointer
;	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
challenge	pointer
->	O
auth_scheme	pointer
,	O
"basic"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
selected_challenge	pointer
)	O
selected_challenge	pointer
=	O
challenge	pointer
;	O
}	O
}	O
if	O
(	O
selected_challenge	pointer
)	O
{	O
if	O
(	O
username	pointer
)	O
{	O
wget_http_add_credentials	function
(	O
req	pointer
,	O
selected_challenge	pointer
,	O
username	pointer
,	O
password	pointer
,	O
proxied	int
)	O
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
netrc_file	pointer
)	O
{	O
wget_thread_mutex_lock	function
(	O
netrc_mutex	pointer
)	O
;	O
if	O
(	O
!	O
config	struct
.	O
netrc_db	pointer
)	O
{	O
config	struct
.	O
netrc_db	pointer
=	O
wget_netrc_db_init	function
(	O
NULL	O
)	O
;	O
int	O
rc	int
=	O
wget_netrc_db_load	function
(	O
config	struct
.	O
netrc_db	pointer
,	O
config	struct
.	O
netrc_file	pointer
)	O
;	O
if	O
(	O
rc	int
<	O
0	int
&&	O
errno	O
!=	O
ENOENT	int
)	O
error_printf	O
(	O
_	O
(	O
"Failed to open .netrc file '%s' (%d): %s\n"	pointer
)	O
,	O
config	struct
.	O
netrc_file	pointer
,	O
errno	O
,	O
wget_strerror	function
(	O
rc	int
)	O
)	O
;	O
}	O
wget_thread_mutex_unlock	function
(	O
netrc_mutex	pointer
)	O
;	O
wget_netrc	struct
*	O
netrc	pointer
=	O
wget_netrc_get	function
(	O
config	struct
.	O
netrc_db	pointer
,	O
req	pointer
->	O
esc_host	struct
.	O
data	pointer
)	O
;	O
if	O
(	O
!	O
netrc	pointer
)	O
netrc	pointer
=	O
wget_netrc_get	function
(	O
config	struct
.	O
netrc_db	pointer
,	O
"default"	pointer
)	O
;	O
if	O
(	O
netrc	pointer
)	O
{	O
wget_http_add_credentials	function
(	O
req	pointer
,	O
selected_challenge	pointer
,	O
netrc	pointer
->	O
login	pointer
,	O
netrc	pointer
->	O
password	pointer
,	O
proxied	int
)	O
;	O
}	O
else	O
{	O
wget_http_add_credentials	function
(	O
req	pointer
,	O
selected_challenge	pointer
,	O
username	pointer
,	O
password	pointer
,	O
proxied	int
)	O
;	O
}	O
}	O
else	O
{	O
wget_http_add_credentials	function
(	O
req	pointer
,	O
selected_challenge	pointer
,	O
username	pointer
,	O
password	pointer
,	O
proxied	int
)	O
;	O
}	O
}	O
}	O
static	O
wget_http_request	struct
*	O
http_create_request	function
(	O
wget_iri	struct
*	O
iri	pointer
,	O
JOB	struct
*	O
job	pointer
)	O
{	O
wget_http_request	struct
*	O
req	pointer
;	O
wget_buffer	struct
buf	pointer
;	O
char	O
sbuf	array
[	O
256	int
]	O
;	O
const	O
char	O
*	O
method	array
;	O
wget_buffer_init	function
(	O
&	O
buf	pointer
,	O
sbuf	array
,	O
sizeof	O
(	O
sbuf	array
)	O
)	O
;	O
if	O
(	O
job	pointer
->	O
head_first	bool
)	O
{	O
method	array
=	O
"HEAD"	pointer
;	O
}	O
else	O
{	O
if	O
(	O
config	struct
.	O
post_data	pointer
||	O
config	struct
.	O
post_file	pointer
)	O
method	array
=	O
"POST"	pointer
;	O
else	O
method	array
=	O
"GET"	pointer
;	O
}	O
if	O
(	O
!	O
(	O
req	pointer
=	O
wget_http_create_request	function
(	O
iri	pointer
,	O
method	array
)	O
)	O
)	O
return	O
req	pointer
;	O
if	O
(	O
config	struct
.	O
continue_download	char
||	O
config	struct
.	O
start_pos	long long
||	O
(	O
config	struct
.	O
timestamping	char
&&	O
config	struct
.	O
if_modified_since	char
)	O
)	O
{	O
const	O
char	O
*	O
local_filename	pointer
=	O
config	struct
.	O
output_document	pointer
?	O
config	struct
.	O
output_document	pointer
:	O
job	pointer
->	O
local_filename	pointer
;	O
if	O
(	O
job	pointer
->	O
robotstxt	bool
==	O
true	int
)	O
{	O
unlink	function
(	O
local_filename	pointer
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
continue_download	char
)	O
{	O
long	O
long	O
file_size	long long
=	O
get_file_size	function
(	O
local_filename	pointer
)	O
;	O
if	O
(	O
file_size	long long
>	O
0	int
)	O
wget_http_add_header_printf	function
(	O
req	pointer
,	O
"Range"	pointer
,	O
"bytes=%lld-"	pointer
,	O
file_size	long long
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
start_pos	long long
)	O
wget_http_add_header_printf	function
(	O
req	pointer
,	O
"Range"	pointer
,	O
"bytes=%lld-"	pointer
,	O
config	struct
.	O
start_pos	long long
)	O
;	O
if	O
(	O
config	struct
.	O
timestamping	char
&&	O
config	struct
.	O
if_modified_since	char
)	O
{	O
time_t	long
mtime	long
=	O
get_file_lmtime	function
(	O
local_filename	pointer
)	O
;	O
if	O
(	O
mtime	long
)	O
{	O
char	O
http_date	array
[	O
32	int
]	O
;	O
wget_http_print_date	function
(	O
mtime	long
,	O
http_date	array
,	O
sizeof	O
(	O
http_date	array
)	O
)	O
;	O
wget_http_add_header	function
(	O
req	pointer
,	O
"If-Modified-Since"	pointer
,	O
http_date	array
)	O
;	O
}	O
}	O
}	O
wget_buffer_reset	function
(	O
&	O
buf	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
compression	pointer
)	O
{	O
for	O
(	O
int	O
it	int
=	O
0	int
;	O
it	int
<	O
config	struct
.	O
compression_methods	array
[	O
wget_content_encoding_max	int
]	O
;	O
it	int
++	O
)	O
{	O
const	O
char	O
*	O
encoding_method	pointer
=	O
wget_content_encoding_to_name	function
(	O
config	struct
.	O
compression_methods	array
[	O
it	int
]	O
)	O
;	O
if	O
(	O
buf	pointer
.	O
length	long
)	O
wget_buffer_strcat	function
(	O
&	O
buf	pointer
,	O
", "	pointer
)	O
;	O
wget_buffer_strcat	function
(	O
&	O
buf	pointer
,	O
encoding_method	pointer
)	O
;	O
}	O
if	O
(	O
buf	pointer
.	O
length	long
)	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Accept-Encoding"	pointer
,	O
buf	pointer
.	O
data	pointer
)	O
;	O
}	O
if	O
(	O
(	O
!	O
config	struct
.	O
no_compression	bool
&&	O
!	O
config	struct
.	O
compression	pointer
)	O
||	O
(	O
config	struct
.	O
compression	pointer
&&	O
!	O
buf	pointer
.	O
length	long
)	O
)	O
{	O
wget_buffer_strcat	function
(	O
&	O
buf	pointer
,	O
buf	pointer
.	O
length	long
?	O
", gzip, deflate"	pointer
:	O
"gzip, deflate"	pointer
)	O
;	O
if	O
(	O
!	O
buf	pointer
.	O
length	long
)	O
wget_buffer_strcat	function
(	O
&	O
buf	pointer
,	O
"identity"	pointer
)	O
;	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Accept-Encoding"	pointer
,	O
buf	pointer
.	O
data	pointer
)	O
;	O
}	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Accept"	pointer
,	O
"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
user_agent	pointer
)	O
wget_http_add_header	function
(	O
req	pointer
,	O
"User-Agent"	pointer
,	O
config	struct
.	O
user_agent	pointer
)	O
;	O
if	O
(	O
config	struct
.	O
keep_alive	char
)	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Connection"	pointer
,	O
"keep-alive"	pointer
)	O
;	O
if	O
(	O
!	O
config	struct
.	O
cache	pointer
)	O
{	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Cache-Control"	pointer
,	O
"no-cache"	pointer
)	O
;	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Pragma"	pointer
,	O
"no-cache"	pointer
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
referer	pointer
)	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Referer"	pointer
,	O
config	struct
.	O
referer	pointer
)	O
;	O
else	O
if	O
(	O
job	pointer
->	O
referer	pointer
)	O
{	O
wget_iri	struct
*	O
referer	pointer
=	O
job	pointer
->	O
referer	pointer
;	O
wget_buffer_strcpy	function
(	O
&	O
buf	pointer
,	O
wget_iri_scheme_get_name	function
(	O
referer	pointer
->	O
scheme	enum
)	O
)	O
;	O
wget_buffer_memcat	function
(	O
&	O
buf	pointer
,	O
"://"	pointer
,	O
3	int
)	O
;	O
wget_buffer_strcat	function
(	O
&	O
buf	pointer
,	O
referer	pointer
->	O
host	pointer
)	O
;	O
if	O
(	O
referer	pointer
->	O
port_given	bool
)	O
wget_buffer_printf_append	function
(	O
&	O
buf	pointer
,	O
":%hu"	pointer
,	O
referer	pointer
->	O
port	short
)	O
;	O
wget_buffer_memcat	function
(	O
&	O
buf	pointer
,	O
"/"	pointer
,	O
1	int
)	O
;	O
wget_iri_get_escaped_resource	function
(	O
referer	pointer
,	O
&	O
buf	pointer
)	O
;	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Referer"	pointer
,	O
buf	pointer
.	O
data	pointer
)	O
;	O
}	O
if	O
(	O
job	pointer
->	O
challenges	pointer
)	O
{	O
_add_authorize_header	function
(	O
req	pointer
,	O
job	pointer
->	O
challenges	pointer
,	O
config	struct
.	O
http_username	pointer
,	O
config	struct
.	O
http_password	pointer
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
job	pointer
->	O
proxy_challenges	pointer
)	O
{	O
_add_authorize_header	function
(	O
req	pointer
,	O
job	pointer
->	O
proxy_challenges	pointer
,	O
config	struct
.	O
http_proxy_username	pointer
,	O
config	struct
.	O
http_proxy_password	pointer
,	O
1	int
)	O
;	O
}	O
if	O
(	O
job	pointer
->	O
part	pointer
)	O
wget_http_add_header_printf	function
(	O
req	pointer
,	O
"Range"	pointer
,	O
"bytes=%llu-%llu"	pointer
,	O
(	O
unsigned	O
long	O
long	O
)	O
job	pointer
->	O
part	pointer
->	O
position	long
,	O
(	O
unsigned	O
long	O
long	O
)	O
job	pointer
->	O
part	pointer
->	O
position	long
+	O
job	pointer
->	O
part	pointer
->	O
length	long
-	O
1	int
)	O
;	O
if	O
(	O
config	struct
.	O
cookies	pointer
)	O
{	O
const	O
char	O
*	O
cookie_string	pointer
;	O
if	O
(	O
(	O
cookie_string	pointer
=	O
wget_cookie_create_request_header	function
(	O
config	struct
.	O
cookie_db	pointer
,	O
iri	pointer
)	O
)	O
)	O
{	O
wget_http_add_header	function
(	O
req	pointer
,	O
"Cookie"	pointer
,	O
cookie_string	pointer
)	O
;	O
xfree	O
(	O
cookie_string	pointer
)	O
;	O
}	O
}	O
if	O
(	O
config	struct
.	O
headers	pointer
)	O
{	O
for	O
(	O
int	O
i	int
=	O
0	int
;	O
i	int
<	O
wget_vector_size	function
(	O
config	struct
.	O
headers	pointer
)	O
;	O
i	int
++	O
)	O
{	O
wget_http_header_param	struct
*	O
param	pointer
=	O
wget_vector_get	function
(	O
config	struct
.	O
headers	pointer
,	O
i	int
)	O
;	O
char	O
replaced	char
=	O
0	int
;	O
if	O
(	O
wget_strcasecmp_ascii	function
(	O
param	pointer
->	O
name	pointer
,	O
"Cookie"	pointer
)	O
)	O
{	O
for	O
(	O
int	O
j	int
=	O
0	int
;	O
j	int
<	O
wget_vector_size	function
(	O
req	pointer
->	O
headers	pointer
)	O
;	O
j	int
++	O
)	O
{	O
wget_http_header_param	struct
*	O
h	pointer
=	O
wget_vector_get	function
(	O
req	pointer
->	O
headers	pointer
,	O
j	int
)	O
;	O
if	O
(	O
!	O
wget_strcasecmp_ascii	function
(	O
param	pointer
->	O
name	pointer
,	O
h	pointer
->	O
name	pointer
)	O
)	O
{	O
xfree	O
(	O
h	pointer
->	O
name	pointer
)	O
;	O
xfree	O
(	O
h	pointer
->	O
value	pointer
)	O
;	O
h	pointer
->	O
name	pointer
=	O
wget_strdup	function
(	O
param	pointer
->	O
name	pointer
)	O
;	O
h	pointer
->	O
value	pointer
=	O
wget_strdup	function
(	O
param	pointer
->	O
value	pointer
)	O
;	O
replaced	char
=	O
1	int
;	O
}	O
}	O
}	O
if	O
(	O
!	O
replaced	char
)	O
wget_http_add_header_param	function
(	O
req	pointer
,	O
param	pointer
)	O
;	O
}	O
}	O
if	O
(	O
config	struct
.	O
post_data	pointer
)	O
{	O
size_t	long
length	long
=	O
strlen	function
(	O
config	struct
.	O
post_data	pointer
)	O
;	O
wget_http_request_set_body	function
(	O
req	pointer
,	O
"application/x-www-form-urlencoded"	pointer
,	O
wget_memdup	function
(	O
config	struct
.	O
post_data	pointer
,	O
length	long
)	O
,	O
length	long
)	O
;	O
}	O
else	O
if	O
(	O
config	struct
.	O
post_file	pointer
)	O
{	O
size_t	long
length	long
;	O
char	O
*	O
data	pointer
;	O
if	O
(	O
(	O
data	pointer
=	O
wget_read_file	function
(	O
config	struct
.	O
post_file	pointer
,	O
&	O
length	long
)	O
)	O
)	O
{	O
wget_http_request_set_body	function
(	O
req	pointer
,	O
"application/x-www-form-urlencoded"	pointer
,	O
data	pointer
,	O
length	long
)	O
;	O
}	O
else	O
{	O
wget_http_free_request	function
(	O
&	O
req	pointer
)	O
;	O
}	O
}	O
wget_buffer_deinit	function
(	O
&	O
buf	pointer
)	O
;	O
return	O
req	pointer
;	O
}	O
int	O
http_send_request	function
(	O
wget_iri	struct
*	O
iri	pointer
,	O
wget_iri	struct
*	O
original_url	pointer
,	O
DOWNLOADER	struct
*	O
downloader	pointer
)	O
{	O
wget_http_connection	struct
*	O
conn	pointer
=	O
downloader	pointer
->	O
conn	pointer
;	O
if	O
(	O
!	O
conn	pointer
)	O
return	O
WGET_E_UNKNOWN	int
;	O
JOB	struct
*	O
job	pointer
=	O
downloader	pointer
->	O
job	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
job	pointer
->	O
head_first	bool
)	O
{	O
print_status	function
(	O
downloader	pointer
,	O
"[%d] Checking '%s' ...\n"	pointer
,	O
downloader	pointer
->	O
id	int
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
job	pointer
->	O
part	pointer
)	O
print_status	function
(	O
downloader	pointer
,	O
"downloading part %d/%d (%lld-%lld) %s from %s\n"	pointer
,	O
job	pointer
->	O
part	pointer
->	O
id	int
,	O
wget_vector_size	function
(	O
job	pointer
->	O
parts	pointer
)	O
,	O
(	O
long	O
long	O
)	O
job	pointer
->	O
part	pointer
->	O
position	long
,	O
(	O
long	O
long	O
)	O
(	O
job	pointer
->	O
part	pointer
->	O
position	long
+	O
job	pointer
->	O
part	pointer
->	O
length	long
-	O
1	int
)	O
,	O
job	pointer
->	O
metalink	pointer
->	O
name	pointer
,	O
iri	pointer
->	O
host	pointer
)	O
;	O
else	O
if	O
(	O
config	struct
.	O
progress	char
)	O
bar_print	function
(	O
downloader	pointer
->	O
id	int
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
else	O
print_status	function
(	O
downloader	pointer
,	O
"[%d] Downloading '%s' ...\n"	pointer
,	O
downloader	pointer
->	O
id	int
,	O
iri	pointer
->	O
uri	pointer
)	O
;	O
}	O
wget_http_request	struct
*	O
req	pointer
=	O
http_create_request	function
(	O
iri	pointer
,	O
downloader	pointer
->	O
job	pointer
)	O
;	O
if	O
(	O
!	O
req	pointer
)	O
return	O
WGET_E_UNKNOWN	int
;	O
wget_http_request_set_ptr	function
(	O
req	pointer
,	O
WGET_HTTP_USER_DATA	int
,	O
downloader	pointer
->	O
job	pointer
)	O
;	O
if	O
(	O
(	O
rc	int
=	O
wget_http_send_request	function
(	O
conn	pointer
,	O
req	pointer
)	O
)	O
)	O
{	O
wget_http_free_request	function
(	O
&	O
req	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
struct	O
_body_callback_context	struct
*	O
context	pointer
=	O
wget_calloc	function
(	O
1	int
,	O
sizeof	O
(	O
struct	O
_body_callback_context	struct
)	O
)	O
;	O
context	pointer
->	O
job	pointer
=	O
downloader	pointer
->	O
job	pointer
;	O
context	pointer
->	O
max_memory	long
=	O
downloader	pointer
->	O
job	pointer
->	O
part	pointer
?	O
0	int
:	O
(	O
(	O
uint64_t	long
)	O
10	int
)	O
*	O
(	O
1	int
<<	O
20	int
)	O
;	O
context	pointer
->	O
outfd	int
=	O
-	O
1	int
;	O
context	pointer
->	O
body	pointer
=	O
wget_buffer_alloc	function
(	O
102400	int
)	O
;	O
context	pointer
->	O
length	long
=	O
0	int
;	O
context	pointer
->	O
progress_slot	int
=	O
downloader	pointer
->	O
id	int
;	O
context	pointer
->	O
job	pointer
->	O
original_url	pointer
=	O
original_url	pointer
;	O
context	pointer
->	O
limit_debt_bytes	long long
=	O
0	int
;	O
context	pointer
->	O
limit_prev_time_ms	long long
=	O
wget_get_timemillis	function
(	O
)	O
;	O
wget_http_request_set_header_cb	function
(	O
req	pointer
,	O
_get_header	function
,	O
context	pointer
)	O
;	O
wget_http_request_set_body_cb	function
(	O
req	pointer
,	O
_get_body	function
,	O
context	pointer
)	O
;	O
wget_http_request_set_int	function
(	O
req	pointer
,	O
WGET_HTTP_RESPONSE_KEEPHEADER	int
,	O
config	struct
.	O
save_headers	char
||	O
config	struct
.	O
server_response	char
||	O
(	O
config	struct
.	O
progress	char
&&	O
config	struct
.	O
spider	char
)	O
)	O
;	O
return	O
WGET_E_SUCCESS	int
;	O
}	O
wget_http_response	struct
*	O
http_receive_response	function
(	O
wget_http_connection	struct
*	O
conn	pointer
)	O
{	O
wget_http_response	struct
*	O
resp	pointer
=	O
wget_http_get_response_cb	function
(	O
conn	pointer
)	O
;	O
if	O
(	O
!	O
resp	pointer
)	O
return	O
NULL	O
;	O
struct	O
_body_callback_context	struct
*	O
context	pointer
=	O
resp	pointer
->	O
req	pointer
->	O
body_user_data	pointer
;	O
resp	pointer
->	O
body	pointer
=	O
context	pointer
->	O
body	pointer
;	O
if	O
(	O
context	pointer
->	O
outfd	int
>=	O
0	int
)	O
{	O
if	O
(	O
resp	pointer
->	O
last_modified	long
)	O
{	O
if	O
(	O
config	struct
.	O
xattr	char
&&	O
!	O
terminate	bool
)	O
write_xattr_last_modified	function
(	O
resp	pointer
->	O
last_modified	long
,	O
context	pointer
->	O
outfd	int
)	O
;	O
set_file_mtime	function
(	O
context	pointer
->	O
outfd	int
,	O
resp	pointer
->	O
last_modified	long
-	O
terminate	bool
)	O
;	O
}	O
if	O
(	O
config	struct
.	O
fsync_policy	char
)	O
{	O
if	O
(	O
fsync	function
(	O
context	pointer
->	O
outfd	int
)	O
<	O
0	int
&&	O
errno	O
==	O
EIO	int
)	O
{	O
error_printf	O
(	O
_	O
(	O
"Failed to fsync errno=%d\n"	pointer
)	O
,	O
errno	O
)	O
;	O
set_exit_status	function
(	O
WG_EXIT_STATUS_IO	int
)	O
;	O
}	O
}	O
close	function
(	O
context	pointer
->	O
outfd	int
)	O
;	O
context	pointer
->	O
outfd	int
=	O
-	O
1	int
;	O
}	O
if	O
(	O
config	struct
.	O
progress	char
)	O
bar_slot_deregister	function
(	O
context	pointer
->	O
progress_slot	int
)	O
;	O
xfree	O
(	O
context	pointer
)	O
;	O
return	O
resp	pointer
;	O
}	O
static	O
int	O
write_xattr_metadata	function
(	O
const	O
char	O
*	O
name	pointer
,	O
const	O
char	O
*	O
value	pointer
,	O
int	O
fd	array
)	O
{	O
if	O
(	O
!	O
(	O
name	pointer
&&	O
value	pointer
&&	O
fd	array
>=	O
0	int
)	O
)	O
return	O
-	O
1	int
;	O
int	O
rc	int
=	O
fsetxattr	function
(	O
fd	array
,	O
name	pointer
,	O
value	pointer
,	O
strlen	function
(	O
value	pointer
)	O
,	O
0	int
)	O
<	O
0	int
?	O
-	O
1	int
:	O
0	int
;	O
if	O
(	O
rc	int
)	O
debug_printf	O
(	O
"Failed to set xattr %s.\n"	pointer
,	O
name	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
read_xattr_metadata	function
(	O
const	O
char	O
*	O
name	pointer
,	O
char	O
*	O
value	pointer
,	O
size_t	long
size	pointer
,	O
int	O
fd	array
)	O
{	O
if	O
(	O
!	O
(	O
name	pointer
&&	O
value	pointer
&&	O
size	pointer
&&	O
fd	array
>=	O
0	int
)	O
)	O
return	O
-	O
1	int
;	O
int	O
rc	int
=	O
fgetxattr	function
(	O
fd	array
,	O
name	pointer
,	O
value	pointer
,	O
size	pointer
-	O
1	int
)	O
;	O
if	O
(	O
rc	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
rc	int
>=	O
(	O
int	O
)	O
size	pointer
)	O
rc	int
=	O
size	pointer
-	O
1	int
;	O
value	pointer
[	O
rc	int
]	O
=	O
0	int
;	O
return	O
rc	int
;	O
}	O
static	O
int	O
write_xattr_last_modified	function
(	O
time_t	long
last_modified	long
,	O
int	O
fd	array
)	O
{	O
char	O
tbuf	array
[	O
32	int
]	O
;	O
if	O
(	O
fd	array
<	O
0	int
)	O
return	O
-	O
1	int
;	O
wget_snprintf	function
(	O
tbuf	array
,	O
sizeof	O
(	O
tbuf	array
)	O
,	O
"%lld"	pointer
,	O
(	O
long	O
long	O
)	O
last_modified	long
)	O
;	O
return	O
write_xattr_metadata	function
(	O
"user.last_modified"	pointer
,	O
tbuf	array
,	O
fd	array
)	O
;	O
}	O
static	O
int	O
set_file_metadata	function
(	O
wget_iri	struct
*	O
origin_iri	pointer
,	O
wget_iri	struct
*	O
referrer_iri	pointer
,	O
const	O
char	O
*	O
mime_type	pointer
,	O
const	O
char	O
*	O
charset	pointer
,	O
time_t	long
last_modified	long
,	O
FILE	struct
*	O
fp	pointer
)	O
{	O
int	O
fd	array
;	O
if	O
(	O
!	O
origin_iri	pointer
||	O
!	O
fp	pointer
)	O
return	O
-	O
1	int
;	O
if	O
(	O
(	O
fd	array
=	O
fileno	function
(	O
fp	pointer
)	O
)	O
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
write_xattr_metadata	function
(	O
"user.mime_type"	pointer
,	O
mime_type	pointer
,	O
fd	array
)	O
<	O
0	int
&&	O
errno	O
==	O
ENOTSUP	O
)	O
return	O
-	O
1	int
;	O
write_xattr_metadata	function
(	O
"user.charset"	pointer
,	O
charset	pointer
,	O
fd	array
)	O
;	O
char	O
sbuf	array
[	O
256	int
]	O
;	O
wget_buffer	struct
buf	pointer
;	O
wget_buffer_init	function
(	O
&	O
buf	pointer
,	O
sbuf	array
,	O
sizeof	O
(	O
sbuf	array
)	O
)	O
;	O
wget_buffer_printf	function
(	O
&	O
buf	pointer
,	O
"%s/"	pointer
,	O
wget_iri_get_connection_part	function
(	O
origin_iri	pointer
)	O
)	O
;	O
wget_iri_get_escaped_resource	function
(	O
origin_iri	pointer
,	O
&	O
buf	pointer
)	O
;	O
write_xattr_metadata	function
(	O
"user.xdg.origin.url"	pointer
,	O
buf	pointer
.	O
data	pointer
,	O
fd	array
)	O
;	O
wget_buffer_deinit	function
(	O
&	O
buf	pointer
)	O
;	O
write_xattr_metadata	function
(	O
"user.xdg.referrer.url"	pointer
,	O
wget_iri_get_connection_part	function
(	O
referrer_iri	pointer
)	O
,	O
fd	array
)	O
;	O
return	O
write_xattr_last_modified	function
(	O
last_modified	long
,	O
fd	array
)	O
;	O
}	O
static	O
void	O
fork_to_background	function
(	O
void	O
)	O
{	O
short	O
logfile_changed	short
=	O
0	int
;	O
if	O
(	O
!	O
config	struct
.	O
logfile	pointer
&&	O
(	O
!	O
config	struct
.	O
quiet	char
||	O
config	struct
.	O
server_response	char
)	O
&&	O
!	O
config	struct
.	O
dont_write	char
)	O
{	O
config	struct
.	O
logfile	pointer
=	O
wget_strdup	function
(	O
WGET_DEFAULT_LOGFILE	pointer
)	O
;	O
int	O
fd	array
=	O
open	function
(	O
config	struct
.	O
logfile	pointer
,	O
O_WRONLY	int
|	O
O_TRUNC	int
)	O
;	O
if	O
(	O
fd	array
!=	O
-	O
1	int
)	O
close	function
(	O
fd	array
)	O
;	O
logfile_changed	short
=	O
1	int
;	O
}	O
pid_t	int
pid	int
=	O
fork	function
(	O
)	O
;	O
if	O
(	O
pid	int
<	O
0	int
)	O
error_printf_exit	O
(	O
_	O
(	O
"Failed to fork (errno=%d): %s\n"	pointer
)	O
,	O
errno	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
else	O
if	O
(	O
pid	int
!=	O
0	int
)	O
{	O
printf	function
(	O
_	O
(	O
"Continuing in background, pid %d.\n"	pointer
)	O
,	O
(	O
int	O
)	O
pid	int
)	O
;	O
if	O
(	O
logfile_changed	short
)	O
printf	function
(	O
_	O
(	O
"Output will be written to %s.\n"	pointer
)	O
,	O
config	struct
.	O
logfile	pointer
)	O
;	O
exit	function
(	O
WG_EXIT_STATUS_NO_ERROR	int
)	O
;	O
}	O
setsid	function
(	O
)	O
;	O
if	O
(	O
freopen	function
(	O
"/dev/null"	pointer
,	O
"r"	pointer
,	O
stdin	pointer
)	O
==	O
NULL	O
)	O
error_printf	O
(	O
_	O
(	O
"Failed to redirect stdin to /dev/null.\n"	pointer
)	O
)	O
;	O
if	O
(	O
freopen	function
(	O
"/dev/null"	pointer
,	O
"w"	pointer
,	O
stdout	pointer
)	O
==	O
NULL	O
)	O
error_printf	O
(	O
_	O
(	O
"Failed to redirect stdout to /dev/null.\n"	pointer
)	O
)	O
;	O
if	O
(	O
freopen	function
(	O
"/dev/null"	pointer
,	O
"w"	pointer
,	O
stderr	pointer
)	O
==	O
NULL	O
)	O
error_printf	O
(	O
_	O
(	O
"Failed to redirect stderr to /dev/null.\n"	pointer
)	O
)	O
;	O
}	O
