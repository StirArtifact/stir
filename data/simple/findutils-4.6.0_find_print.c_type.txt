struct	O
segment	struct
*	O
*	O
make_segment	function
(	O
struct	O
segment	struct
*	O
*	O
segment	struct
,	O
char	O
*	O
format	pointer
,	O
int	O
len	long
,	O
int	O
kind	enum
,	O
char	O
format_char	array
,	O
char	O
aux_format_char	char
,	O
struct	O
predicate	struct
*	O
pred	pointer
)	O
{	O
enum	O
EvaluationCost	enum
mycost	enum
=	O
NeedsNothing	int
;	O
char	O
*	O
fmt	pointer
;	O
assert	O
(	O
format_char	array
!=	O
'{'	O
)	O
;	O
assert	O
(	O
format_char	array
!=	O
'['	O
)	O
;	O
assert	O
(	O
format_char	array
!=	O
'('	O
)	O
;	O
*	O
segment	struct
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
segment	struct
)	O
)	O
;	O
(	O
*	O
segment	struct
)	O
->	O
segkind	enum
=	O
kind	enum
;	O
(	O
*	O
segment	struct
)	O
->	O
format_char	array
[	O
0	int
]	O
=	O
format_char	array
;	O
(	O
*	O
segment	struct
)	O
->	O
format_char	array
[	O
1	int
]	O
=	O
aux_format_char	char
;	O
(	O
*	O
segment	struct
)	O
->	O
next	pointer
=	O
NULL	O
;	O
(	O
*	O
segment	struct
)	O
->	O
text_len	int
=	O
len	long
;	O
fmt	pointer
=	O
(	O
*	O
segment	struct
)	O
->	O
text	pointer
=	O
xmalloc	function
(	O
len	long
+	O
sizeof	O
"d"	pointer
)	O
;	O
strncpy	function
(	O
fmt	pointer
,	O
format	pointer
,	O
len	long
)	O
;	O
fmt	pointer
+=	O
len	long
;	O
if	O
(	O
kind	enum
==	O
KIND_PLAIN	int
||	O
kind	enum
==	O
KIND_STOP	int
)	O
{	O
assert	O
(	O
0	int
==	O
format_char	array
)	O
;	O
assert	O
(	O
0	int
==	O
aux_format_char	char
)	O
;	O
*	O
fmt	pointer
=	O
'\0'	O
;	O
if	O
(	O
mycost	enum
>	O
pred	pointer
->	O
p_cost	enum
)	O
pred	pointer
->	O
p_cost	enum
=	O
NeedsNothing	int
;	O
return	O
&	O
(	O
*	O
segment	struct
)	O
->	O
next	pointer
;	O
}	O
assert	O
(	O
kind	enum
==	O
KIND_FORMAT	int
)	O
;	O
switch	O
(	O
format_char	array
)	O
{	O
case	O
'%'	O
:	O
*	O
fmt	pointer
++	O
=	O
'%'	O
;	O
break	O
;	O
case	O
'l'	O
:	O
pred	pointer
->	O
need_stat	bool
=	O
true	int
;	O
mycost	enum
=	O
NeedsLinkName	int
;	O
*	O
fmt	pointer
++	O
=	O
's'	O
;	O
break	O
;	O
case	O
'y'	O
:	O
pred	pointer
->	O
need_type	bool
=	O
true	int
;	O
mycost	enum
=	O
NeedsType	int
;	O
*	O
fmt	pointer
++	O
=	O
's'	O
;	O
break	O
;	O
case	O
'i'	O
:	O
pred	pointer
->	O
need_inum	bool
=	O
true	int
;	O
mycost	enum
=	O
NeedsInodeNumber	int
;	O
*	O
fmt	pointer
++	O
=	O
's'	O
;	O
break	O
;	O
case	O
'a'	O
:	O
case	O
'A'	O
:	O
case	O
'B'	O
:	O
case	O
'c'	O
:	O
case	O
'C'	O
:	O
case	O
'F'	O
:	O
case	O
'g'	O
:	O
case	O
'M'	O
:	O
case	O
's'	O
:	O
case	O
't'	O
:	O
case	O
'T'	O
:	O
case	O
'u'	O
:	O
pred	pointer
->	O
need_stat	bool
=	O
true	int
;	O
mycost	enum
=	O
NeedsStatInfo	int
;	O
*	O
fmt	pointer
++	O
=	O
's'	O
;	O
break	O
;	O
case	O
'S'	O
:	O
pred	pointer
->	O
need_stat	bool
=	O
true	int
;	O
mycost	enum
=	O
NeedsStatInfo	int
;	O
*	O
fmt	pointer
++	O
=	O
'g'	O
;	O
break	O
;	O
case	O
'Y'	O
:	O
pred	pointer
->	O
need_stat	bool
=	O
true	int
;	O
mycost	enum
=	O
NeedsType	int
;	O
*	O
fmt	pointer
++	O
=	O
's'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
case	O
'h'	O
:	O
case	O
'p'	O
:	O
case	O
'P'	O
:	O
*	O
fmt	pointer
++	O
=	O
's'	O
;	O
break	O
;	O
case	O
'Z'	O
:	O
mycost	enum
=	O
NeedsAccessInfo	int
;	O
*	O
fmt	pointer
++	O
=	O
's'	O
;	O
break	O
;	O
case	O
'H'	O
:	O
*	O
fmt	pointer
++	O
=	O
's'	O
;	O
break	O
;	O
case	O
'G'	O
:	O
case	O
'U'	O
:	O
case	O
'b'	O
:	O
case	O
'D'	O
:	O
case	O
'k'	O
:	O
case	O
'n'	O
:	O
pred	pointer
->	O
need_stat	bool
=	O
true	int
;	O
mycost	enum
=	O
NeedsStatInfo	int
;	O
*	O
fmt	pointer
++	O
=	O
's'	O
;	O
break	O
;	O
case	O
'd'	O
:	O
*	O
fmt	pointer
++	O
=	O
'd'	O
;	O
break	O
;	O
case	O
'm'	O
:	O
*	O
fmt	pointer
++	O
=	O
'o'	O
;	O
pred	pointer
->	O
need_stat	bool
=	O
true	int
;	O
mycost	enum
=	O
NeedsStatInfo	int
;	O
break	O
;	O
}	O
*	O
fmt	pointer
=	O
'\0'	O
;	O
if	O
(	O
mycost	enum
>	O
pred	pointer
->	O
p_cost	enum
)	O
pred	pointer
->	O
p_cost	enum
=	O
mycost	enum
;	O
return	O
&	O
(	O
*	O
segment	struct
)	O
->	O
next	pointer
;	O
}	O
static	O
bool	bool
is_octal_char	function
(	O
char	O
ch	char
)	O
{	O
return	O
ch	char
>=	O
'0'	O
&&	O
ch	char
<=	O
'7'	O
;	O
}	O
static	O
char	O
parse_octal_escape	function
(	O
const	O
char	O
*	O
p	pointer
,	O
size_t	long
*	O
consumed	pointer
)	O
{	O
register	O
int	O
n	long
,	O
i	int
;	O
size_t	long
pos	long
=	O
0	int
;	O
for	O
(	O
i	int
=	O
n	long
=	O
0	int
;	O
i	int
<	O
3	int
&&	O
is_octal_char	function
(	O
p	pointer
[	O
pos	long
]	O
)	O
;	O
i	int
++	O
,	O
pos	long
++	O
)	O
{	O
n	long
=	O
8	int
*	O
n	long
+	O
p	pointer
[	O
pos	long
]	O
-	O
'0'	O
;	O
}	O
--	O
pos	long
;	O
*	O
consumed	pointer
=	O
pos	long
;	O
return	O
n	long
;	O
}	O
static	O
int	O
parse_escape_char	function
(	O
const	O
char	O
ch	char
)	O
{	O
char	O
value	pointer
=	O
0	int
;	O
switch	O
(	O
ch	char
)	O
{	O
case	O
'a'	O
:	O
value	pointer
=	O
'\a'	O
;	O
break	O
;	O
case	O
'b'	O
:	O
value	pointer
=	O
'\b'	O
;	O
break	O
;	O
case	O
'f'	O
:	O
value	pointer
=	O
'\f'	O
;	O
break	O
;	O
case	O
'n'	O
:	O
value	pointer
=	O
'\n'	O
;	O
break	O
;	O
case	O
'r'	O
:	O
value	pointer
=	O
'\r'	O
;	O
break	O
;	O
case	O
't'	O
:	O
value	pointer
=	O
'\t'	O
;	O
break	O
;	O
case	O
'v'	O
:	O
value	pointer
=	O
'\v'	O
;	O
break	O
;	O
case	O
'\\'	O
:	O
value	pointer
=	O
'\\'	O
;	O
break	O
;	O
}	O
return	O
value	pointer
;	O
}	O
static	O
size_t	long
get_format_flags_length	function
(	O
const	O
char	O
*	O
p	pointer
)	O
{	O
size_t	long
n	long
=	O
0	int
;	O
for	O
(	O
;	O
p	pointer
[	O
++	O
n	long
]	O
&&	O
strchr	function
(	O
"-+ #"	pointer
,	O
p	pointer
[	O
n	long
]	O
)	O
;	O
)	O
{	O
}	O
while	O
(	O
ISDIGIT	O
(	O
p	pointer
[	O
n	long
]	O
)	O
)	O
n	long
++	O
;	O
if	O
(	O
p	pointer
[	O
n	long
]	O
==	O
'.'	O
)	O
for	O
(	O
n	long
++	O
;	O
ISDIGIT	O
(	O
p	pointer
[	O
n	long
]	O
)	O
;	O
n	long
++	O
)	O
;	O
return	O
n	long
;	O
}	O
static	O
size_t	long
get_format_specifer_length	function
(	O
char	O
ch	char
)	O
{	O
if	O
(	O
strchr	function
(	O
"abcdDfFgGhHiklmMnpPsStuUyYZ%"	pointer
,	O
ch	char
)	O
)	O
{	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
strchr	function
(	O
"ABCT"	pointer
,	O
ch	char
)	O
)	O
{	O
return	O
2	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
bool	bool
insert_fprintf	function
(	O
struct	O
format_val	struct
*	O
vec	pointer
,	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
char	O
*	O
format	pointer
)	O
{	O
char	O
*	O
segstart	pointer
=	O
format	pointer
;	O
char	O
*	O
fmt_editpos	pointer
;	O
struct	O
segment	struct
*	O
*	O
segmentp	pointer
;	O
struct	O
predicate	struct
*	O
our_pred	pointer
;	O
our_pred	pointer
=	O
insert_primary_withpred	function
(	O
entry	pointer
,	O
pred_fprintf	function
,	O
format	pointer
)	O
;	O
our_pred	pointer
->	O
side_effects	bool
=	O
our_pred	pointer
->	O
no_default_print	bool
=	O
true	int
;	O
our_pred	pointer
->	O
args	union
.	O
printf_vec	struct
=	O
*	O
vec	pointer
;	O
our_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
our_pred	pointer
->	O
need_stat	bool
=	O
false	int
;	O
our_pred	pointer
->	O
p_cost	enum
=	O
NeedsNothing	int
;	O
segmentp	pointer
=	O
&	O
our_pred	pointer
->	O
args	union
.	O
printf_vec	struct
.	O
segment	struct
;	O
*	O
segmentp	pointer
=	O
NULL	O
;	O
for	O
(	O
fmt_editpos	pointer
=	O
segstart	pointer
;	O
*	O
fmt_editpos	pointer
;	O
fmt_editpos	pointer
++	O
)	O
{	O
if	O
(	O
fmt_editpos	pointer
[	O
0	int
]	O
==	O
'\\'	O
&&	O
fmt_editpos	pointer
[	O
1	int
]	O
==	O
'c'	O
)	O
{	O
make_segment	function
(	O
segmentp	pointer
,	O
segstart	pointer
,	O
fmt_editpos	pointer
-	O
segstart	pointer
,	O
KIND_STOP	int
,	O
0	int
,	O
0	int
,	O
our_pred	pointer
)	O
;	O
if	O
(	O
our_pred	pointer
->	O
need_stat	bool
&&	O
(	O
our_pred	pointer
->	O
p_cost	enum
<	O
NeedsStatInfo	int
)	O
)	O
our_pred	pointer
->	O
p_cost	enum
=	O
NeedsStatInfo	int
;	O
return	O
true	int
;	O
}	O
else	O
if	O
(	O
*	O
fmt_editpos	pointer
==	O
'\\'	O
)	O
{	O
size_t	long
readpos	long
=	O
1	int
;	O
if	O
(	O
!	O
fmt_editpos	pointer
[	O
readpos	long
]	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: escape `\\' followed by nothing at all"	pointer
)	O
)	O
;	O
--	O
readpos	long
;	O
}	O
else	O
if	O
(	O
is_octal_char	function
(	O
fmt_editpos	pointer
[	O
readpos	long
]	O
)	O
)	O
{	O
size_t	long
consumed	pointer
=	O
0	int
;	O
*	O
fmt_editpos	pointer
=	O
parse_octal_escape	function
(	O
fmt_editpos	pointer
+	O
readpos	long
,	O
&	O
consumed	pointer
)	O
;	O
readpos	long
+=	O
consumed	pointer
;	O
}	O
else	O
{	O
const	O
char	O
val	array
=	O
parse_escape_char	function
(	O
fmt_editpos	pointer
[	O
readpos	long
]	O
)	O
;	O
if	O
(	O
val	array
)	O
{	O
fmt_editpos	pointer
[	O
0	int
]	O
=	O
val	array
;	O
}	O
else	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: unrecognized escape `\\%c'"	pointer
)	O
,	O
fmt_editpos	pointer
[	O
readpos	long
]	O
)	O
;	O
fmt_editpos	pointer
+=	O
readpos	long
;	O
continue	O
;	O
}	O
}	O
segmentp	pointer
=	O
make_segment	function
(	O
segmentp	pointer
,	O
segstart	pointer
,	O
fmt_editpos	pointer
-	O
segstart	pointer
+	O
1	int
,	O
KIND_PLAIN	int
,	O
0	int
,	O
0	int
,	O
our_pred	pointer
)	O
;	O
segstart	pointer
=	O
fmt_editpos	pointer
+	O
readpos	long
+	O
1	int
;	O
fmt_editpos	pointer
+=	O
readpos	long
;	O
}	O
else	O
if	O
(	O
fmt_editpos	pointer
[	O
0	int
]	O
==	O
'%'	O
)	O
{	O
size_t	long
len	long
;	O
if	O
(	O
fmt_editpos	pointer
[	O
1	int
]	O
==	O
0	int
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"error: %s at end of format string"	pointer
)	O
,	O
fmt_editpos	pointer
)	O
;	O
}	O
if	O
(	O
fmt_editpos	pointer
[	O
1	int
]	O
==	O
'%'	O
)	O
len	long
=	O
1	int
;	O
else	O
len	long
=	O
get_format_flags_length	function
(	O
fmt_editpos	pointer
)	O
;	O
fmt_editpos	pointer
+=	O
len	long
;	O
len	long
=	O
get_format_specifer_length	function
(	O
fmt_editpos	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
len	long
&&	O
(	O
fmt_editpos	pointer
[	O
len	long
-	O
1	int
]	O
)	O
)	O
{	O
const	O
char	O
fmt2	char
=	O
(	O
len	long
==	O
2	int
)	O
?	O
fmt_editpos	pointer
[	O
1	int
]	O
:	O
0	int
;	O
segmentp	pointer
=	O
make_segment	function
(	O
segmentp	pointer
,	O
segstart	pointer
,	O
fmt_editpos	pointer
-	O
segstart	pointer
,	O
KIND_FORMAT	int
,	O
fmt_editpos	pointer
[	O
0	int
]	O
,	O
fmt2	char
,	O
our_pred	pointer
)	O
;	O
fmt_editpos	pointer
+=	O
(	O
len	long
-	O
1	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
strchr	function
(	O
"{[("	pointer
,	O
fmt_editpos	pointer
[	O
0	int
]	O
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"error: the format directive `%%%c' is reserved for future use"	pointer
)	O
,	O
(	O
int	O
)	O
fmt_editpos	pointer
[	O
0	int
]	O
)	O
;	O
}	O
if	O
(	O
len	long
==	O
2	int
&&	O
!	O
fmt_editpos	pointer
[	O
1	int
]	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: format directive `%%%c' "	pointer
"should be followed by another character"	pointer
)	O
,	O
fmt_editpos	pointer
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: unrecognized format directive `%%%c'"	pointer
)	O
,	O
fmt_editpos	pointer
[	O
0	int
]	O
)	O
;	O
}	O
segmentp	pointer
=	O
make_segment	function
(	O
segmentp	pointer
,	O
segstart	pointer
,	O
fmt_editpos	pointer
+	O
1	int
-	O
segstart	pointer
,	O
KIND_PLAIN	int
,	O
0	int
,	O
0	int
,	O
our_pred	pointer
)	O
;	O
}	O
segstart	pointer
=	O
fmt_editpos	pointer
+	O
1	int
;	O
}	O
}	O
if	O
(	O
fmt_editpos	pointer
>	O
segstart	pointer
)	O
make_segment	function
(	O
segmentp	pointer
,	O
segstart	pointer
,	O
fmt_editpos	pointer
-	O
segstart	pointer
,	O
KIND_PLAIN	int
,	O
0	int
,	O
0	int
,	O
our_pred	pointer
)	O
;	O
return	O
true	int
;	O
}	O
static	O
bool	bool
scan_for_digit_differences	function
(	O
const	O
char	O
*	O
p	pointer
,	O
const	O
char	O
*	O
q	pointer
,	O
size_t	long
*	O
first	pointer
,	O
size_t	long
*	O
n	long
)	O
{	O
bool	bool
seen	bool
=	O
false	int
;	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
p	pointer
[	O
i	int
]	O
&&	O
q	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
p	pointer
[	O
i	int
]	O
!=	O
q	pointer
[	O
i	int
]	O
)	O
{	O
if	O
(	O
!	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
q	pointer
[	O
i	int
]	O
)	O
||	O
!	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
q	pointer
[	O
i	int
]	O
)	O
)	O
return	O
false	int
;	O
if	O
(	O
!	O
seen	bool
)	O
{	O
*	O
first	pointer
=	O
i	int
;	O
*	O
n	long
=	O
1	int
;	O
seen	bool
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
i	int
-	O
*	O
first	pointer
==	O
*	O
n	long
)	O
{	O
++	O
*	O
n	long
;	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
}	O
}	O
if	O
(	O
p	pointer
[	O
i	int
]	O
||	O
q	pointer
[	O
i	int
]	O
)	O
{	O
return	O
false	int
;	O
}	O
return	O
true	int
;	O
}	O
static	O
char	O
*	O
do_time_format	function
(	O
const	O
char	O
*	O
fmt	pointer
,	O
const	O
struct	O
tm	struct
*	O
p	pointer
,	O
const	O
char	O
*	O
ns	long
,	O
size_t	long
ns_size	long
)	O
{	O
static	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
static	O
size_t	long
buf_size	long
;	O
char	O
*	O
timefmt	pointer
=	O
NULL	O
;	O
struct	O
tm	struct
altered_time	struct
;	O
timefmt	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
fmt	pointer
)	O
+	O
2u	int
)	O
;	O
timefmt	pointer
[	O
0	int
]	O
=	O
'_'	O
;	O
memcpy	function
(	O
timefmt	pointer
+	O
1	int
,	O
fmt	pointer
,	O
strlen	function
(	O
fmt	pointer
)	O
+	O
1	int
)	O
;	O
altered_time	struct
=	O
*	O
p	pointer
;	O
if	O
(	O
altered_time	struct
.	O
tm_sec	int
>=	O
11	int
)	O
altered_time	struct
.	O
tm_sec	int
-=	O
11	int
;	O
else	O
altered_time	struct
.	O
tm_sec	int
+=	O
11	int
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
{	O
buf_size	long
=	O
1u	int
;	O
buf	pointer
=	O
xmalloc	function
(	O
buf_size	long
)	O
;	O
}	O
while	O
(	O
true	int
)	O
{	O
size_t	long
buf_used	long
=	O
strftime	function
(	O
buf	pointer
,	O
buf_size	long
,	O
timefmt	pointer
,	O
p	pointer
)	O
;	O
if	O
(	O
buf_used	long
&&	O
(	O
buf_used	long
<	O
buf_size	long
)	O
)	O
{	O
char	O
*	O
altbuf	pointer
;	O
size_t	long
i	int
=	O
0	int
,	O
n	long
=	O
0	int
;	O
size_t	long
final_len	long
=	O
(	O
buf_used	long
+	O
1u	int
+	O
ns_size	long
)	O
;	O
buf	pointer
=	O
xrealloc	function
(	O
buf	pointer
,	O
final_len	long
)	O
;	O
buf_size	long
=	O
final_len	long
;	O
altbuf	pointer
=	O
xmalloc	function
(	O
final_len	long
)	O
;	O
strftime	function
(	O
altbuf	pointer
,	O
buf_size	long
,	O
timefmt	pointer
,	O
&	O
altered_time	struct
)	O
;	O
if	O
(	O
scan_for_digit_differences	function
(	O
buf	pointer
,	O
altbuf	pointer
,	O
&	O
i	int
,	O
&	O
n	long
)	O
&&	O
(	O
2	int
==	O
n	long
)	O
&&	O
!	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
buf	pointer
[	O
i	int
+	O
n	long
]	O
)	O
)	O
{	O
const	O
size_t	long
end_of_seconds	long
=	O
i	int
+	O
n	long
;	O
const	O
size_t	long
suffix_len	long
=	O
buf_used	long
-	O
(	O
end_of_seconds	long
)	O
+	O
1	int
;	O
assert	O
(	O
end_of_seconds	long
+	O
ns_size	long
+	O
suffix_len	long
==	O
final_len	long
)	O
;	O
memmove	function
(	O
buf	pointer
+	O
end_of_seconds	long
+	O
ns_size	long
,	O
buf	pointer
+	O
end_of_seconds	long
,	O
suffix_len	long
)	O
;	O
memcpy	function
(	O
buf	pointer
+	O
i	int
+	O
n	long
,	O
ns	long
,	O
ns_size	long
)	O
;	O
}	O
else	O
{	O
}	O
free	function
(	O
timefmt	pointer
)	O
;	O
free	function
(	O
altbuf	pointer
)	O
;	O
return	O
buf	pointer
+	O
1	int
;	O
}	O
else	O
{	O
buf	pointer
=	O
x2nrealloc	function
(	O
buf	pointer
,	O
&	O
buf_size	long
,	O
sizeof	O
*	O
buf	pointer
)	O
;	O
}	O
}	O
}	O
static	O
char	O
*	O
format_date	function
(	O
struct	O
timespec	struct
ts	struct
,	O
int	O
kind	enum
)	O
{	O
enum	O
{	O
NS_BUF_LEN	int
=	O
32	int
,	O
DATE_LEN_PERCENT_APLUS	int
=	O
21	int
}	O
;	O
static	O
char	O
buf	pointer
[	O
128u	int
+	O
10u	int
+	O
MAX	O
(	O
DATE_LEN_PERCENT_APLUS	int
,	O
MAX	O
(	O
LONGEST_HUMAN_READABLE	O
+	O
2	int
,	O
NS_BUF_LEN	int
+	O
64	int
+	O
200	int
)	O
)	O
]	O
;	O
char	O
ns_buf	array
[	O
NS_BUF_LEN	int
]	O
;	O
int	O
charsprinted	int
,	O
need_ns_suffix	int
;	O
struct	O
tm	struct
*	O
tm	struct
;	O
char	O
fmt	pointer
[	O
6	int
]	O
;	O
verify	O
(	O
sizeof	O
(	O
buf	pointer
)	O
>=	O
LONGEST_HUMAN_READABLE	O
)	O
;	O
charsprinted	int
=	O
0	int
;	O
need_ns_suffix	int
=	O
0	int
;	O
if	O
(	O
kind	enum
==	O
'+'	O
)	O
{	O
strcpy	function
(	O
fmt	pointer
,	O
"%F+%T"	pointer
)	O
;	O
need_ns_suffix	int
=	O
1	int
;	O
}	O
else	O
{	O
fmt	pointer
[	O
0	int
]	O
=	O
'%'	O
;	O
fmt	pointer
[	O
1	int
]	O
=	O
kind	enum
;	O
fmt	pointer
[	O
2	int
]	O
=	O
'\0'	O
;	O
switch	O
(	O
kind	enum
)	O
{	O
case	O
'S'	O
:	O
case	O
'T'	O
:	O
case	O
'X'	O
:	O
case	O
'@'	O
:	O
need_ns_suffix	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
need_ns_suffix	int
=	O
0	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
need_ns_suffix	int
)	O
{	O
charsprinted	int
=	O
snprintf	function
(	O
ns_buf	array
,	O
NS_BUF_LEN	int
,	O
".%09ld0"	pointer
,	O
(	O
long	O
int	O
)	O
ts	struct
.	O
tv_nsec	long
)	O
;	O
assert	O
(	O
charsprinted	int
<	O
NS_BUF_LEN	int
)	O
;	O
}	O
else	O
{	O
charsprinted	int
=	O
0	int
;	O
ns_buf	array
[	O
0	int
]	O
=	O
0	int
;	O
}	O
if	O
(	O
kind	enum
!=	O
'@'	O
)	O
{	O
tm	struct
=	O
localtime	function
(	O
&	O
ts	struct
.	O
tv_sec	long
)	O
;	O
if	O
(	O
tm	struct
)	O
{	O
char	O
*	O
s	enum
=	O
do_time_format	function
(	O
fmt	pointer
,	O
tm	struct
,	O
ns_buf	array
,	O
charsprinted	int
)	O
;	O
if	O
(	O
s	enum
)	O
return	O
s	enum
;	O
}	O
}	O
if	O
(	O
1	int
)	O
{	O
uintmax_t	long
w	long
=	O
ts	struct
.	O
tv_sec	long
;	O
size_t	long
used	long
,	O
len	long
,	O
remaining	long
;	O
char	O
*	O
p	pointer
=	O
human_readable	function
(	O
ts	struct
.	O
tv_sec	long
<	O
0	int
?	O
-	O
w	long
:	O
w	long
,	O
buf	pointer
+	O
1	int
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
;	O
assert	O
(	O
p	pointer
>	O
buf	pointer
)	O
;	O
assert	O
(	O
p	pointer
<	O
(	O
buf	pointer
+	O
(	O
sizeof	O
buf	pointer
)	O
)	O
)	O
;	O
if	O
(	O
ts	struct
.	O
tv_sec	long
<	O
0	int
)	O
*	O
--	O
p	pointer
=	O
'-'	O
;	O
if	O
(	O
need_ns_suffix	int
)	O
{	O
len	long
=	O
strlen	function
(	O
p	pointer
)	O
;	O
used	long
=	O
(	O
p	pointer
-	O
buf	pointer
)	O
+	O
len	long
;	O
assert	O
(	O
sizeof	O
buf	pointer
>	O
used	long
)	O
;	O
remaining	long
=	O
sizeof	O
buf	pointer
-	O
used	long
-	O
1u	int
;	O
if	O
(	O
strlen	function
(	O
ns_buf	array
)	O
>=	O
remaining	long
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
"charsprinted=%ld but remaining=%lu: ns_buf=%s"	pointer
,	O
(	O
long	O
)	O
charsprinted	int
,	O
(	O
unsigned	O
long	O
)	O
remaining	long
,	O
ns_buf	array
)	O
;	O
}	O
assert	O
(	O
strlen	function
(	O
ns_buf	array
)	O
<	O
remaining	long
)	O
;	O
strcat	function
(	O
p	pointer
,	O
ns_buf	array
)	O
;	O
}	O
return	O
p	pointer
;	O
}	O
}	O
static	O
const	O
char	O
*	O
weekdays	array
[	O
]	O
=	O
{	O
"Sun"	pointer
,	O
"Mon"	pointer
,	O
"Tue"	pointer
,	O
"Wed"	pointer
,	O
"Thu"	pointer
,	O
"Fri"	pointer
,	O
"Sat"	pointer
}	O
;	O
static	O
const	O
char	O
*	O
months	array
[	O
]	O
=	O
{	O
"Jan"	pointer
,	O
"Feb"	pointer
,	O
"Mar"	pointer
,	O
"Apr"	pointer
,	O
"May"	pointer
,	O
"Jun"	pointer
,	O
"Jul"	pointer
,	O
"Aug"	pointer
,	O
"Sep"	pointer
,	O
"Oct"	pointer
,	O
"Nov"	pointer
,	O
"Dec"	pointer
}	O
;	O
static	O
char	O
*	O
ctime_format	function
(	O
struct	O
timespec	struct
ts	struct
)	O
{	O
const	O
struct	O
tm	struct
*	O
ptm	pointer
;	O
static	O
char	O
resultbuf	array
[	O
TIME_BUF_LEN	int
]	O
;	O
int	O
nout	int
;	O
ptm	pointer
=	O
localtime	function
(	O
&	O
ts	struct
.	O
tv_sec	long
)	O
;	O
if	O
(	O
ptm	pointer
)	O
{	O
assert	O
(	O
ptm	pointer
->	O
tm_wday	int
>=	O
0	int
)	O
;	O
assert	O
(	O
ptm	pointer
->	O
tm_wday	int
<	O
7	int
)	O
;	O
assert	O
(	O
ptm	pointer
->	O
tm_mon	int
>=	O
0	int
)	O
;	O
assert	O
(	O
ptm	pointer
->	O
tm_mon	int
<	O
12	int
)	O
;	O
assert	O
(	O
ptm	pointer
->	O
tm_hour	int
>=	O
0	int
)	O
;	O
assert	O
(	O
ptm	pointer
->	O
tm_hour	int
<	O
24	int
)	O
;	O
assert	O
(	O
ptm	pointer
->	O
tm_min	int
<	O
60	int
)	O
;	O
assert	O
(	O
ptm	pointer
->	O
tm_sec	int
<=	O
61	int
)	O
;	O
nout	int
=	O
snprintf	function
(	O
resultbuf	array
,	O
TIME_BUF_LEN	int
,	O
"%3s %3s %2d %02d:%02d:%02d.%09ld0 %04d"	pointer
,	O
weekdays	array
[	O
ptm	pointer
->	O
tm_wday	int
]	O
,	O
months	array
[	O
ptm	pointer
->	O
tm_mon	int
]	O
,	O
ptm	pointer
->	O
tm_mday	int
,	O
ptm	pointer
->	O
tm_hour	int
,	O
ptm	pointer
->	O
tm_min	int
,	O
ptm	pointer
->	O
tm_sec	int
,	O
(	O
long	O
int	O
)	O
ts	struct
.	O
tv_nsec	long
,	O
1900	int
+	O
ptm	pointer
->	O
tm_year	int
)	O
;	O
assert	O
(	O
nout	int
<	O
TIME_BUF_LEN	int
)	O
;	O
return	O
resultbuf	array
;	O
}	O
else	O
{	O
return	O
format_date	function
(	O
ts	struct
,	O
'@'	O
)	O
;	O
}	O
}	O
static	O
double	O
file_sparseness	function
(	O
const	O
struct	O
stat	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
0	int
==	O
p	pointer
->	O
st_size	long
)	O
{	O
if	O
(	O
0	int
==	O
ST_NBLOCKS	O
(	O
*	O
p	pointer
)	O
)	O
return	O
1.0	int
;	O
else	O
return	O
ST_NBLOCKS	O
(	O
*	O
p	pointer
)	O
<	O
0	int
?	O
-	O
HUGE_VAL	O
:	O
HUGE_VAL	O
;	O
}	O
else	O
{	O
double	O
blklen	double
=	O
ST_NBLOCKSIZE	O
*	O
(	O
double	O
)	O
ST_NBLOCKS	O
(	O
*	O
p	pointer
)	O
;	O
return	O
blklen	double
/	O
p	pointer
->	O
st_size	long
;	O
}	O
}	O
static	O
void	O
checked_fprintf	function
(	O
struct	O
format_val	struct
*	O
dest	pointer
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
int	O
rv	int
;	O
va_list	array
ap	array
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
rv	int
=	O
vfprintf	function
(	O
dest	pointer
->	O
stream	pointer
,	O
fmt	pointer
,	O
ap	array
)	O
;	O
if	O
(	O
rv	int
<	O
0	int
)	O
nonfatal_nontarget_file_error	function
(	O
errno	O
,	O
dest	pointer
->	O
filename	pointer
)	O
;	O
}	O
static	O
void	O
checked_print_quoted	function
(	O
struct	O
format_val	struct
*	O
dest	pointer
,	O
const	O
char	O
*	O
format	pointer
,	O
const	O
char	O
*	O
s	enum
)	O
{	O
int	O
rv	int
=	O
print_quoted	function
(	O
dest	pointer
->	O
stream	pointer
,	O
dest	pointer
->	O
quote_opts	pointer
,	O
dest	pointer
->	O
dest_is_tty	bool
,	O
format	pointer
,	O
s	enum
)	O
;	O
if	O
(	O
rv	int
<	O
0	int
)	O
nonfatal_nontarget_file_error	function
(	O
errno	O
,	O
dest	pointer
->	O
filename	pointer
)	O
;	O
}	O
static	O
void	O
checked_fwrite	function
(	O
void	O
*	O
p	pointer
,	O
size_t	long
siz	long
,	O
size_t	long
nmemb	long
,	O
struct	O
format_val	struct
*	O
dest	pointer
)	O
{	O
const	O
size_t	long
items_written	long
=	O
fwrite	function
(	O
p	pointer
,	O
siz	long
,	O
nmemb	long
,	O
dest	pointer
->	O
stream	pointer
)	O
;	O
if	O
(	O
items_written	long
<	O
nmemb	long
)	O
nonfatal_nontarget_file_error	function
(	O
errno	O
,	O
dest	pointer
->	O
filename	pointer
)	O
;	O
}	O
static	O
void	O
checked_fflush	function
(	O
struct	O
format_val	struct
*	O
dest	pointer
)	O
{	O
if	O
(	O
0	int
!=	O
fflush	function
(	O
dest	pointer
->	O
stream	pointer
)	O
)	O
{	O
nonfatal_nontarget_file_error	function
(	O
errno	O
,	O
dest	pointer
->	O
filename	pointer
)	O
;	O
}	O
}	O
static	O
const	O
char	O
*	O
mode_to_filetype	function
(	O
mode_t	int
m	int
)	O
{	O
HANDLE_TYPE	O
(	O
S_IFREG	O
,	O
"f"	pointer
)	O
;	O
HANDLE_TYPE	O
(	O
S_IFDIR	O
,	O
"d"	pointer
)	O
;	O
HANDLE_TYPE	O
(	O
S_IFLNK	O
,	O
"l"	pointer
)	O
;	O
HANDLE_TYPE	O
(	O
S_IFSOCK	O
,	O
"s"	pointer
)	O
;	O
HANDLE_TYPE	O
(	O
S_IFBLK	O
,	O
"b"	pointer
)	O
;	O
HANDLE_TYPE	O
(	O
S_IFCHR	O
,	O
"c"	pointer
)	O
;	O
HANDLE_TYPE	O
(	O
S_IFIFO	O
,	O
"p"	pointer
)	O
;	O
return	O
"U"	pointer
;	O
}	O
static	O
void	O
do_fprintf	function
(	O
struct	O
format_val	struct
*	O
dest	pointer
,	O
struct	O
segment	struct
*	O
segment	struct
,	O
const	O
char	O
*	O
pathname	pointer
,	O
const	O
struct	O
stat	struct
*	O
stat_buf	pointer
)	O
{	O
char	O
hbuf	array
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
const	O
char	O
*	O
cp	pointer
;	O
switch	O
(	O
segment	struct
->	O
segkind	enum
)	O
{	O
case	O
KIND_PLAIN	int
:	O
checked_fwrite	function
(	O
segment	struct
->	O
text	pointer
,	O
1	int
,	O
segment	struct
->	O
text_len	int
,	O
dest	pointer
)	O
;	O
break	O
;	O
case	O
KIND_STOP	int
:	O
checked_fwrite	function
(	O
segment	struct
->	O
text	pointer
,	O
1	int
,	O
segment	struct
->	O
text_len	int
,	O
dest	pointer
)	O
;	O
checked_fflush	function
(	O
dest	pointer
)	O
;	O
break	O
;	O
case	O
KIND_FORMAT	int
:	O
switch	O
(	O
segment	struct
->	O
format_char	array
[	O
0	int
]	O
)	O
{	O
case	O
'a'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
ctime_format	function
(	O
get_stat_atime	function
(	O
stat_buf	pointer
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'b'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
human_readable	function
(	O
(	O
uintmax_t	long
)	O
ST_NBLOCKS	O
(	O
*	O
stat_buf	pointer
)	O
,	O
hbuf	array
,	O
human_ceiling	int
,	O
ST_NBLOCKSIZE	O
,	O
512	int
)	O
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
ctime_format	function
(	O
get_stat_ctime	function
(	O
stat_buf	pointer
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
state	pointer
.	O
curdepth	int
)	O
;	O
break	O
;	O
case	O
'D'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
human_readable	function
(	O
(	O
uintmax_t	long
)	O
stat_buf	pointer
->	O
st_dev	long
,	O
hbuf	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
'f'	O
:	O
{	O
char	O
*	O
base	int
=	O
base_name	function
(	O
pathname	pointer
)	O
;	O
checked_print_quoted	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
base	int
)	O
;	O
free	function
(	O
base	int
)	O
;	O
}	O
break	O
;	O
case	O
'F'	O
:	O
checked_print_quoted	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
filesystem_type	function
(	O
stat_buf	pointer
,	O
pathname	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'g'	O
:	O
{	O
struct	O
group	struct
*	O
g	pointer
;	O
g	pointer
=	O
getgrgid	function
(	O
stat_buf	pointer
->	O
st_gid	int
)	O
;	O
if	O
(	O
g	pointer
)	O
{	O
segment	struct
->	O
text	pointer
[	O
segment	struct
->	O
text_len	int
]	O
=	O
's'	O
;	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
g	pointer
->	O
gr_name	pointer
)	O
;	O
break	O
;	O
}	O
else	O
{	O
}	O
}	O
case	O
'G'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
human_readable	function
(	O
(	O
uintmax_t	long
)	O
stat_buf	pointer
->	O
st_gid	int
,	O
hbuf	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
{	O
cp	pointer
=	O
strrchr	function
(	O
pathname	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
{	O
checked_print_quoted	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
"."	pointer
)	O
;	O
}	O
else	O
{	O
char	O
*	O
s	enum
=	O
strdup	function
(	O
pathname	pointer
)	O
;	O
s	enum
[	O
cp	pointer
-	O
pathname	pointer
]	O
=	O
0	int
;	O
checked_print_quoted	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
s	enum
)	O
;	O
free	function
(	O
s	enum
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'H'	O
:	O
{	O
char	O
*	O
s	enum
=	O
xmalloc	function
(	O
state	pointer
.	O
starting_path_length	int
+	O
1	int
)	O
;	O
memcpy	function
(	O
s	enum
,	O
pathname	pointer
,	O
state	pointer
.	O
starting_path_length	int
)	O
;	O
s	enum
[	O
state	pointer
.	O
starting_path_length	int
]	O
=	O
0	int
;	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
s	enum
)	O
;	O
free	function
(	O
s	enum
)	O
;	O
}	O
break	O
;	O
case	O
'i'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
human_readable	function
(	O
(	O
uintmax_t	long
)	O
stat_buf	pointer
->	O
st_ino	long
,	O
hbuf	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
'k'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
human_readable	function
(	O
(	O
uintmax_t	long
)	O
ST_NBLOCKS	O
(	O
*	O
stat_buf	pointer
)	O
,	O
hbuf	array
,	O
human_ceiling	int
,	O
ST_NBLOCKSIZE	O
,	O
1024	int
)	O
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
{	O
char	O
*	O
linkname	pointer
=	O
0	int
;	O
if	O
(	O
S_ISLNK	O
(	O
stat_buf	pointer
->	O
st_mode	int
)	O
)	O
{	O
linkname	pointer
=	O
areadlinkat	function
(	O
state	pointer
.	O
cwd_dir_fd	int
,	O
state	pointer
.	O
rel_pathname	pointer
)	O
;	O
if	O
(	O
linkname	pointer
==	O
NULL	O
)	O
{	O
nonfatal_target_file_error	function
(	O
errno	O
,	O
pathname	pointer
)	O
;	O
state	pointer
.	O
exit_status	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
linkname	pointer
)	O
{	O
checked_print_quoted	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
linkname	pointer
)	O
;	O
}	O
else	O
{	O
checked_print_quoted	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
""	pointer
)	O
;	O
}	O
free	function
(	O
linkname	pointer
)	O
;	O
}	O
break	O
;	O
case	O
'M'	O
:	O
{	O
char	O
modestring	array
[	O
16	int
]	O
;	O
filemodestring	function
(	O
stat_buf	pointer
,	O
modestring	array
)	O
;	O
modestring	array
[	O
10	int
]	O
=	O
'\0'	O
;	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
modestring	array
)	O
;	O
}	O
break	O
;	O
case	O
'm'	O
:	O
{	O
mode_t	int
m	int
=	O
stat_buf	pointer
->	O
st_mode	int
;	O
bool	bool
traditional_numbering_scheme	bool
=	O
(	O
S_ISUID	O
==	O
04000	int
&&	O
S_ISGID	O
==	O
02000	int
&&	O
S_ISVTX	O
==	O
01000	int
&&	O
S_IRUSR	O
==	O
00400	int
&&	O
S_IWUSR	O
==	O
00200	int
&&	O
S_IXUSR	O
==	O
00100	int
&&	O
S_IRGRP	O
==	O
00040	int
&&	O
S_IWGRP	O
==	O
00020	int
&&	O
S_IXGRP	O
==	O
00010	int
&&	O
S_IROTH	O
==	O
00004	int
&&	O
S_IWOTH	O
==	O
00002	int
&&	O
S_IXOTH	O
==	O
00001	int
)	O
;	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
(	O
traditional_numbering_scheme	bool
?	O
m	int
&	O
MODE_ALL	O
:	O
(	O
(	O
m	int
&	O
S_ISUID	O
?	O
04000	int
:	O
0	int
)	O
|	O
(	O
m	int
&	O
S_ISGID	O
?	O
02000	int
:	O
0	int
)	O
|	O
(	O
m	int
&	O
S_ISVTX	O
?	O
01000	int
:	O
0	int
)	O
|	O
(	O
m	int
&	O
S_IRUSR	O
?	O
00400	int
:	O
0	int
)	O
|	O
(	O
m	int
&	O
S_IWUSR	O
?	O
00200	int
:	O
0	int
)	O
|	O
(	O
m	int
&	O
S_IXUSR	O
?	O
00100	int
:	O
0	int
)	O
|	O
(	O
m	int
&	O
S_IRGRP	O
?	O
00040	int
:	O
0	int
)	O
|	O
(	O
m	int
&	O
S_IWGRP	O
?	O
00020	int
:	O
0	int
)	O
|	O
(	O
m	int
&	O
S_IXGRP	O
?	O
00010	int
:	O
0	int
)	O
|	O
(	O
m	int
&	O
S_IROTH	O
?	O
00004	int
:	O
0	int
)	O
|	O
(	O
m	int
&	O
S_IWOTH	O
?	O
00002	int
:	O
0	int
)	O
|	O
(	O
m	int
&	O
S_IXOTH	O
?	O
00001	int
:	O
0	int
)	O
)	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'n'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
human_readable	function
(	O
(	O
uintmax_t	long
)	O
stat_buf	pointer
->	O
st_nlink	long
,	O
hbuf	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
'p'	O
:	O
checked_print_quoted	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
pathname	pointer
)	O
;	O
break	O
;	O
case	O
'P'	O
:	O
if	O
(	O
state	pointer
.	O
curdepth	int
>	O
0	int
)	O
{	O
cp	pointer
=	O
pathname	pointer
+	O
state	pointer
.	O
starting_path_length	int
;	O
if	O
(	O
*	O
cp	pointer
==	O
'/'	O
)	O
cp	pointer
++	O
;	O
}	O
else	O
{	O
cp	pointer
=	O
""	pointer
;	O
}	O
checked_print_quoted	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
cp	pointer
)	O
;	O
break	O
;	O
case	O
's'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
human_readable	function
(	O
(	O
uintmax_t	long
)	O
stat_buf	pointer
->	O
st_size	long
,	O
hbuf	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
'S'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
file_sparseness	function
(	O
stat_buf	pointer
)	O
)	O
;	O
break	O
;	O
case	O
't'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
ctime_format	function
(	O
get_stat_mtime	function
(	O
stat_buf	pointer
)	O
)	O
)	O
;	O
break	O
;	O
case	O
'u'	O
:	O
{	O
struct	O
passwd	struct
*	O
p	pointer
;	O
p	pointer
=	O
getpwuid	function
(	O
stat_buf	pointer
->	O
st_uid	int
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
segment	struct
->	O
text	pointer
[	O
segment	struct
->	O
text_len	int
]	O
=	O
's'	O
;	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
p	pointer
->	O
pw_name	pointer
)	O
;	O
break	O
;	O
}	O
}	O
case	O
'U'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
human_readable	function
(	O
(	O
uintmax_t	long
)	O
stat_buf	pointer
->	O
st_uid	int
,	O
hbuf	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
;	O
break	O
;	O
case	O
'Y'	O
:	O
{	O
if	O
(	O
S_ISLNK	O
(	O
stat_buf	pointer
->	O
st_mode	int
)	O
)	O
{	O
struct	O
stat	struct
sbuf	struct
;	O
if	O
(	O
(	O
following_links	function
(	O
)	O
?	O
optionp_stat	function
:	O
optionl_stat	function
)	O
(	O
state	pointer
.	O
rel_pathname	pointer
,	O
&	O
sbuf	struct
)	O
!=	O
0	int
)	O
{	O
if	O
(	O
errno	O
==	O
ENOENT	int
)	O
{	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
"N"	pointer
)	O
;	O
break	O
;	O
}	O
else	O
if	O
(	O
errno	O
==	O
ELOOP	int
)	O
{	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
"L"	pointer
)	O
;	O
break	O
;	O
}	O
else	O
{	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
"?"	pointer
)	O
;	O
error	function
(	O
0	int
,	O
errno	O
,	O
"%s"	pointer
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
pathname	pointer
)	O
)	O
;	O
break	O
;	O
}	O
}	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
mode_to_filetype	function
(	O
sbuf	struct
.	O
st_mode	int
&	O
S_IFMT	O
)	O
)	O
;	O
}	O
else	O
{	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
mode_to_filetype	function
(	O
stat_buf	pointer
->	O
st_mode	int
&	O
S_IFMT	O
)	O
)	O
;	O
}	O
}	O
break	O
;	O
case	O
'y'	O
:	O
{	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
mode_to_filetype	function
(	O
stat_buf	pointer
->	O
st_mode	int
&	O
S_IFMT	O
)	O
)	O
;	O
}	O
break	O
;	O
case	O
'Z'	O
:	O
{	O
security_context_t	pointer
scontext	pointer
;	O
int	O
rv	int
=	O
(	O
*	O
options	struct
.	O
x_getfilecon	pointer
)	O
(	O
state	pointer
.	O
cwd_dir_fd	int
,	O
state	pointer
.	O
rel_pathname	pointer
,	O
&	O
scontext	pointer
)	O
;	O
if	O
(	O
rv	int
<	O
0	int
)	O
{	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
""	pointer
)	O
;	O
error	function
(	O
0	int
,	O
errno	O
,	O
_	O
(	O
"getfilecon failed: %s"	pointer
)	O
,	O
safely_quote_err_filename	function
(	O
0	int
,	O
pathname	pointer
)	O
)	O
;	O
state	pointer
.	O
exit_status	int
=	O
1	int
;	O
}	O
else	O
{	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
scontext	pointer
)	O
;	O
freecon	function
(	O
scontext	pointer
)	O
;	O
}	O
}	O
break	O
;	O
case	O
0	int
:	O
case	O
'%'	O
:	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
)	O
;	O
break	O
;	O
}	O
break	O
;	O
}	O
}	O
bool	bool
pred_fprintf	function
(	O
const	O
char	O
*	O
pathname	pointer
,	O
struct	O
stat	struct
*	O
stat_buf	pointer
,	O
struct	O
predicate	struct
*	O
pred_ptr	pointer
)	O
{	O
struct	O
format_val	struct
*	O
dest	pointer
=	O
&	O
pred_ptr	pointer
->	O
args	union
.	O
printf_vec	struct
;	O
struct	O
segment	struct
*	O
segment	struct
;	O
for	O
(	O
segment	struct
=	O
dest	pointer
->	O
segment	struct
;	O
segment	struct
;	O
segment	struct
=	O
segment	struct
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
KIND_FORMAT	int
==	O
segment	struct
->	O
segkind	enum
)	O
&&	O
segment	struct
->	O
format_char	array
[	O
1	int
]	O
)	O
{	O
struct	O
timespec	struct
ts	struct
;	O
int	O
valid	int
=	O
0	int
;	O
switch	O
(	O
segment	struct
->	O
format_char	array
[	O
0	int
]	O
)	O
{	O
case	O
'A'	O
:	O
ts	struct
=	O
get_stat_atime	function
(	O
stat_buf	pointer
)	O
;	O
valid	int
=	O
1	int
;	O
break	O
;	O
case	O
'B'	O
:	O
ts	struct
=	O
get_stat_birthtime	function
(	O
stat_buf	pointer
)	O
;	O
if	O
(	O
'@'	O
==	O
segment	struct
->	O
format_char	array
[	O
1	int
]	O
)	O
valid	int
=	O
1	int
;	O
else	O
valid	int
=	O
(	O
ts	struct
.	O
tv_nsec	long
>=	O
0	int
)	O
;	O
break	O
;	O
case	O
'C'	O
:	O
ts	struct
=	O
get_stat_ctime	function
(	O
stat_buf	pointer
)	O
;	O
valid	int
=	O
1	int
;	O
break	O
;	O
case	O
'T'	O
:	O
ts	struct
=	O
get_stat_mtime	function
(	O
stat_buf	pointer
)	O
;	O
valid	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
if	O
(	O
valid	int
)	O
{	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
format_date	function
(	O
ts	struct
,	O
segment	struct
->	O
format_char	array
[	O
1	int
]	O
)	O
)	O
;	O
}	O
else	O
{	O
checked_fprintf	function
(	O
dest	pointer
,	O
segment	struct
->	O
text	pointer
,	O
""	pointer
)	O
;	O
}	O
}	O
else	O
{	O
do_fprintf	function
(	O
dest	pointer
,	O
segment	struct
,	O
pathname	pointer
,	O
stat_buf	pointer
)	O
;	O
}	O
}	O
return	O
true	int
;	O
}	O
