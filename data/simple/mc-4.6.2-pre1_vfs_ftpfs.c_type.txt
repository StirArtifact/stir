static	O
int	O
ftpfs_errno	int
;	O
static	O
int	O
code	int
;	O
int	O
ftpfs_retry_seconds	int
=	O
30	int
;	O
int	O
ftpfs_use_passive_connections	int
=	O
1	int
;	O
int	O
ftpfs_use_passive_connections_over_proxy	int
=	O
0	int
;	O
int	O
ftpfs_use_unix_list_options	int
=	O
1	int
;	O
int	O
ftpfs_first_cd_then_ls	int
=	O
1	int
;	O
int	O
use_netrc	int
=	O
1	int
;	O
char	O
*	O
ftpfs_anonymous_passwd	pointer
=	O
NULL	O
;	O
int	O
ftpfs_directory_timeout	int
=	O
900	int
;	O
char	O
*	O
ftpfs_proxy_host	pointer
=	O
NULL	O
;	O
int	O
ftpfs_always_use_proxy	int
;	O
static	O
char	O
reply_str	array
[	O
80	int
]	O
;	O
static	O
struct	O
vfs_class	struct
vfs_ftpfs_ops	struct
;	O
static	O
char	O
*	O
ftpfs_get_current_directory	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
;	O
static	O
int	O
ftpfs_chdir_internal	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
const	O
char	O
*	O
remote_path	pointer
)	O
;	O
static	O
int	O
ftpfs_command	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
int	O
wait_reply	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
__attribute__	O
(	O
(	O
format	pointer
(	O
__printf__	O
,	O
4	int
,	O
5	int
)	O
)	O
)	O
;	O
static	O
int	O
ftpfs_open_socket	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
;	O
static	O
int	O
ftpfs_login_server	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
const	O
char	O
*	O
netrcpass	pointer
)	O
;	O
static	O
int	O
ftpfs_netrc_lookup	function
(	O
const	O
char	O
*	O
host	pointer
,	O
char	O
*	O
*	O
login	pointer
,	O
char	O
*	O
*	O
pass	pointer
)	O
;	O
static	O
char	O
*	O
ftpfs_translate_path	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
const	O
char	O
*	O
remote_path	pointer
)	O
{	O
if	O
(	O
!	O
SUP	O
.	O
remote_is_amiga	int
)	O
return	O
g_strdup	function
(	O
remote_path	pointer
)	O
;	O
else	O
{	O
char	O
*	O
ret	pointer
,	O
*	O
p	pointer
;	O
if	O
(	O
MEDATA	O
->	O
logfile	pointer
)	O
{	O
fprintf	function
(	O
MEDATA	O
->	O
logfile	pointer
,	O
"MC -- ftpfs_translate_path: %s\n"	pointer
,	O
remote_path	pointer
)	O
;	O
fflush	function
(	O
MEDATA	O
->	O
logfile	pointer
)	O
;	O
}	O
while	O
(	O
*	O
remote_path	pointer
==	O
'/'	O
)	O
remote_path	pointer
++	O
;	O
if	O
(	O
*	O
remote_path	pointer
==	O
'\0'	O
)	O
return	O
g_strdup	function
(	O
"."	pointer
)	O
;	O
ret	pointer
=	O
g_strdup	function
(	O
remote_path	pointer
)	O
;	O
if	O
(	O
(	O
p	pointer
=	O
strchr	function
(	O
ret	pointer
,	O
':'	O
)	O
)	O
&&	O
*	O
(	O
p	pointer
+	O
1	int
)	O
==	O
'/'	O
)	O
strcpy	function
(	O
p	pointer
+	O
1	int
,	O
p	pointer
+	O
2	int
)	O
;	O
if	O
(	O
(	O
p	pointer
=	O
strrchr	function
(	O
ret	pointer
,	O
'/'	O
)	O
)	O
&&	O
*	O
(	O
p	pointer
+	O
1	int
)	O
==	O
'.'	O
&&	O
*	O
(	O
p	pointer
+	O
2	int
)	O
==	O
'\0'	O
)	O
*	O
p	pointer
=	O
'\0'	O
;	O
return	O
ret	pointer
;	O
}	O
}	O
static	O
void	O
ftpfs_split_url	function
(	O
char	O
*	O
path	pointer
,	O
char	O
*	O
*	O
host	pointer
,	O
char	O
*	O
*	O
user	pointer
,	O
int	O
*	O
port	pointer
,	O
char	O
*	O
*	O
pass	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
vfs_split_url	function
(	O
path	pointer
,	O
host	pointer
,	O
user	pointer
,	O
port	pointer
,	O
pass	pointer
,	O
FTP_COMMAND_PORT	int
,	O
URL_ALLOW_ANON	int
)	O
;	O
if	O
(	O
!	O
*	O
user	pointer
)	O
{	O
if	O
(	O
use_netrc	int
)	O
ftpfs_netrc_lookup	function
(	O
*	O
host	pointer
,	O
user	pointer
,	O
pass	pointer
)	O
;	O
if	O
(	O
!	O
*	O
user	pointer
)	O
*	O
user	pointer
=	O
g_strdup	function
(	O
"anonymous"	pointer
)	O
;	O
}	O
if	O
(	O
use_netrc	int
&&	O
*	O
user	pointer
&&	O
pass	pointer
&&	O
!	O
*	O
pass	pointer
)	O
{	O
char	O
*	O
new_user	pointer
;	O
ftpfs_netrc_lookup	function
(	O
*	O
host	pointer
,	O
&	O
new_user	pointer
,	O
pass	pointer
)	O
;	O
if	O
(	O
new_user	pointer
&&	O
strcmp	function
(	O
*	O
user	pointer
,	O
new_user	pointer
)	O
)	O
{	O
g_free	function
(	O
*	O
pass	pointer
)	O
;	O
*	O
pass	pointer
=	O
NULL	O
;	O
}	O
g_free	function
(	O
new_user	pointer
)	O
;	O
}	O
g_free	function
(	O
p	pointer
)	O
;	O
}	O
static	O
int	O
ftpfs_get_reply	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
int	O
sock	int
,	O
char	O
*	O
string_buf	pointer
,	O
int	O
string_len	long
)	O
{	O
char	O
answer	array
[	O
BUF_1K	int
]	O
;	O
int	O
i	array
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
!	O
vfs_s_get_line	function
(	O
me	pointer
,	O
sock	int
,	O
answer	array
,	O
sizeof	O
(	O
answer	array
)	O
,	O
'\n'	O
)	O
)	O
{	O
if	O
(	O
string_buf	pointer
)	O
*	O
string_buf	pointer
=	O
0	int
;	O
code	int
=	O
421	int
;	O
return	O
4	int
;	O
}	O
switch	O
(	O
sscanf	function
(	O
answer	array
,	O
"%d"	pointer
,	O
&	O
code	int
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
string_buf	pointer
)	O
g_strlcpy	function
(	O
string_buf	pointer
,	O
answer	array
,	O
string_len	long
)	O
;	O
code	int
=	O
500	int
;	O
return	O
5	int
;	O
case	O
1	int
:	O
if	O
(	O
answer	array
[	O
3	int
]	O
==	O
'-'	O
)	O
{	O
while	O
(	O
1	int
)	O
{	O
if	O
(	O
!	O
vfs_s_get_line	function
(	O
me	pointer
,	O
sock	int
,	O
answer	array
,	O
sizeof	O
(	O
answer	array
)	O
,	O
'\n'	O
)	O
)	O
{	O
if	O
(	O
string_buf	pointer
)	O
*	O
string_buf	pointer
=	O
0	int
;	O
code	int
=	O
421	int
;	O
return	O
4	int
;	O
}	O
if	O
(	O
(	O
sscanf	function
(	O
answer	array
,	O
"%d"	pointer
,	O
&	O
i	array
)	O
>	O
0	int
)	O
&&	O
(	O
code	int
==	O
i	array
)	O
&&	O
(	O
answer	array
[	O
3	int
]	O
==	O
' '	O
)	O
)	O
break	O
;	O
}	O
}	O
if	O
(	O
string_buf	pointer
)	O
g_strlcpy	function
(	O
string_buf	pointer
,	O
answer	array
,	O
string_len	long
)	O
;	O
return	O
code	int
/	O
100	int
;	O
}	O
}	O
}	O
static	O
int	O
ftpfs_reconnect	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
int	O
sock	int
=	O
ftpfs_open_socket	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
if	O
(	O
sock	int
!=	O
-	O
1	int
)	O
{	O
char	O
*	O
cwdir	pointer
=	O
SUP	O
.	O
cwdir	pointer
;	O
close	function
(	O
SUP	O
.	O
sock	int
)	O
;	O
SUP	O
.	O
sock	int
=	O
sock	int
;	O
SUP	O
.	O
cwdir	pointer
=	O
NULL	O
;	O
if	O
(	O
ftpfs_login_server	function
(	O
me	pointer
,	O
super	pointer
,	O
SUP	O
.	O
password	pointer
)	O
)	O
{	O
if	O
(	O
!	O
cwdir	pointer
)	O
return	O
1	int
;	O
sock	int
=	O
ftpfs_chdir_internal	function
(	O
me	pointer
,	O
super	pointer
,	O
cwdir	pointer
)	O
;	O
g_free	function
(	O
cwdir	pointer
)	O
;	O
return	O
sock	int
==	O
COMPLETE	int
;	O
}	O
SUP	O
.	O
cwdir	pointer
=	O
cwdir	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
ftpfs_command	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
int	O
wait_reply	int
,	O
const	O
char	O
*	O
fmt	pointer
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
char	O
*	O
cmdstr	pointer
;	O
int	O
status	int
,	O
cmdlen	int
;	O
static	O
int	O
retry	int
=	O
0	int
;	O
static	O
int	O
level	int
=	O
0	int
;	O
va_start	O
(	O
ap	array
,	O
fmt	pointer
)	O
;	O
cmdstr	pointer
=	O
g_strdup_vprintf	function
(	O
fmt	pointer
,	O
ap	array
)	O
;	O
va_end	O
(	O
ap	array
)	O
;	O
cmdlen	int
=	O
strlen	function
(	O
cmdstr	pointer
)	O
;	O
cmdstr	pointer
=	O
g_realloc	function
(	O
cmdstr	pointer
,	O
cmdlen	int
+	O
3	int
)	O
;	O
strcpy	function
(	O
cmdstr	pointer
+	O
cmdlen	int
,	O
"\r\n"	pointer
)	O
;	O
cmdlen	int
+=	O
2	int
;	O
if	O
(	O
MEDATA	O
->	O
logfile	pointer
)	O
{	O
if	O
(	O
strncmp	function
(	O
cmdstr	pointer
,	O
"PASS "	pointer
,	O
5	int
)	O
==	O
0	int
)	O
{	O
fputs	function
(	O
"PASS <Password not logged>\r\n"	pointer
,	O
MEDATA	O
->	O
logfile	pointer
)	O
;	O
}	O
else	O
fwrite	function
(	O
cmdstr	pointer
,	O
cmdlen	int
,	O
1	int
,	O
MEDATA	O
->	O
logfile	pointer
)	O
;	O
fflush	function
(	O
MEDATA	O
->	O
logfile	pointer
)	O
;	O
}	O
got_sigpipe	int
=	O
0	int
;	O
enable_interrupt_key	O
(	O
)	O
;	O
status	int
=	O
write	function
(	O
SUP	O
.	O
sock	int
,	O
cmdstr	pointer
,	O
cmdlen	int
)	O
;	O
if	O
(	O
status	int
<	O
0	int
)	O
{	O
code	int
=	O
421	int
;	O
if	O
(	O
errno	O
==	O
EPIPE	int
)	O
{	O
if	O
(	O
level	int
==	O
0	int
)	O
{	O
level	int
=	O
1	int
;	O
status	int
=	O
ftpfs_reconnect	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
level	int
=	O
0	int
;	O
if	O
(	O
status	int
&&	O
(	O
write	function
(	O
SUP	O
.	O
sock	int
,	O
cmdstr	pointer
,	O
cmdlen	int
)	O
>	O
0	int
)	O
)	O
{	O
goto	O
ok	O
;	O
}	O
}	O
got_sigpipe	int
=	O
1	int
;	O
}	O
g_free	function
(	O
cmdstr	pointer
)	O
;	O
disable_interrupt_key	O
(	O
)	O
;	O
return	O
TRANSIENT	int
;	O
}	O
retry	int
=	O
0	int
;	O
ok	O
:	O
disable_interrupt_key	O
(	O
)	O
;	O
if	O
(	O
wait_reply	int
)	O
{	O
status	int
=	O
ftpfs_get_reply	function
(	O
me	pointer
,	O
SUP	O
.	O
sock	int
,	O
(	O
wait_reply	int
&	O
WANT_STRING	int
)	O
?	O
reply_str	array
:	O
NULL	O
,	O
sizeof	O
(	O
reply_str	array
)	O
-	O
1	int
)	O
;	O
if	O
(	O
(	O
wait_reply	int
&	O
WANT_STRING	int
)	O
&&	O
!	O
retry	int
&&	O
!	O
level	int
&&	O
code	int
==	O
421	int
)	O
{	O
retry	int
=	O
1	int
;	O
level	int
=	O
1	int
;	O
status	int
=	O
ftpfs_reconnect	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
level	int
=	O
0	int
;	O
if	O
(	O
status	int
&&	O
(	O
write	function
(	O
SUP	O
.	O
sock	int
,	O
cmdstr	pointer
,	O
cmdlen	int
)	O
>	O
0	int
)	O
)	O
{	O
goto	O
ok	O
;	O
}	O
}	O
retry	int
=	O
0	int
;	O
g_free	function
(	O
cmdstr	pointer
)	O
;	O
return	O
status	int
;	O
}	O
g_free	function
(	O
cmdstr	pointer
)	O
;	O
return	O
COMPLETE	int
;	O
}	O
static	O
void	O
ftpfs_free_archive	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
if	O
(	O
SUP	O
.	O
sock	int
!=	O
-	O
1	int
)	O
{	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: Disconnecting from %s"	pointer
)	O
,	O
SUP	O
.	O
host	pointer
)	O
;	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
NONE	int
,	O
"QUIT"	pointer
)	O
;	O
close	function
(	O
SUP	O
.	O
sock	int
)	O
;	O
}	O
g_free	function
(	O
SUP	O
.	O
host	pointer
)	O
;	O
g_free	function
(	O
SUP	O
.	O
user	pointer
)	O
;	O
g_free	function
(	O
SUP	O
.	O
cwdir	pointer
)	O
;	O
g_free	function
(	O
SUP	O
.	O
password	pointer
)	O
;	O
}	O
static	O
int	O
ftpfs_changetype	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
int	O
binary	int
)	O
{	O
if	O
(	O
binary	int
!=	O
SUP	O
.	O
isbinary	int
)	O
{	O
if	O
(	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
WAIT_REPLY	int
,	O
"TYPE %c"	pointer
,	O
binary	int
?	O
'I'	O
:	O
'A'	O
)	O
!=	O
COMPLETE	int
)	O
ERRNOR	O
(	O
EIO	int
,	O
-	O
1	int
)	O
;	O
SUP	O
.	O
isbinary	int
=	O
binary	int
;	O
}	O
return	O
binary	int
;	O
}	O
static	O
int	O
ftpfs_login_server	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
const	O
char	O
*	O
netrcpass	pointer
)	O
{	O
char	O
*	O
pass	pointer
;	O
char	O
*	O
op	pointer
;	O
char	O
*	O
name	pointer
;	O
int	O
anon	int
=	O
0	int
;	O
char	O
reply_string	array
[	O
BUF_MEDIUM	int
]	O
;	O
SUP	O
.	O
isbinary	int
=	O
TYPE_UNKNOWN	O
;	O
if	O
(	O
SUP	O
.	O
password	pointer
)	O
op	pointer
=	O
g_strdup	function
(	O
SUP	O
.	O
password	pointer
)	O
;	O
else	O
if	O
(	O
netrcpass	pointer
)	O
op	pointer
=	O
g_strdup	function
(	O
netrcpass	pointer
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
SUP	O
.	O
user	pointer
,	O
"anonymous"	pointer
)	O
||	O
!	O
strcmp	function
(	O
SUP	O
.	O
user	pointer
,	O
"ftp"	pointer
)	O
)	O
{	O
if	O
(	O
!	O
ftpfs_anonymous_passwd	pointer
)	O
ftpfs_init_passwd	function
(	O
)	O
;	O
op	pointer
=	O
g_strdup	function
(	O
ftpfs_anonymous_passwd	pointer
)	O
;	O
anon	int
=	O
1	int
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
g_strconcat	function
(	O
_	O
(	O
" FTP: Password required for "	pointer
)	O
,	O
SUP	O
.	O
user	pointer
,	O
" "	pointer
,	O
NULL	O
)	O
;	O
op	pointer
=	O
vfs_get_password	function
(	O
p	pointer
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
if	O
(	O
op	pointer
==	O
NULL	O
)	O
ERRNOR	O
(	O
EPERM	int
,	O
0	int
)	O
;	O
SUP	O
.	O
password	pointer
=	O
g_strdup	function
(	O
op	pointer
)	O
;	O
}	O
if	O
(	O
!	O
anon	int
||	O
MEDATA	O
->	O
logfile	pointer
)	O
pass	pointer
=	O
op	pointer
;	O
else	O
{	O
pass	pointer
=	O
g_strconcat	function
(	O
"-"	pointer
,	O
op	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
wipe_password	function
(	O
op	pointer
)	O
;	O
}	O
if	O
(	O
SUP	O
.	O
proxy	pointer
)	O
{	O
name	pointer
=	O
g_strconcat	function
(	O
SUP	O
.	O
user	pointer
,	O
"@"	pointer
,	O
SUP	O
.	O
host	pointer
[	O
0	int
]	O
==	O
'!'	O
?	O
SUP	O
.	O
host	pointer
+	O
1	int
:	O
SUP	O
.	O
host	pointer
,	O
NULL	O
)	O
;	O
}	O
else	O
name	pointer
=	O
g_strdup	function
(	O
SUP	O
.	O
user	pointer
)	O
;	O
if	O
(	O
ftpfs_get_reply	function
(	O
me	pointer
,	O
SUP	O
.	O
sock	int
,	O
reply_string	array
,	O
sizeof	O
(	O
reply_string	array
)	O
-	O
1	int
)	O
==	O
COMPLETE	int
)	O
{	O
g_strup	function
(	O
reply_string	array
)	O
;	O
SUP	O
.	O
remote_is_amiga	int
=	O
strstr	function
(	O
reply_string	array
,	O
"AMIGA"	pointer
)	O
!=	O
0	int
;	O
if	O
(	O
MEDATA	O
->	O
logfile	pointer
)	O
{	O
fprintf	function
(	O
MEDATA	O
->	O
logfile	pointer
,	O
"MC -- remote_is_amiga =  %d\n"	pointer
,	O
SUP	O
.	O
remote_is_amiga	int
)	O
;	O
fflush	function
(	O
MEDATA	O
->	O
logfile	pointer
)	O
;	O
}	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: sending login name"	pointer
)	O
)	O
;	O
switch	O
(	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
WAIT_REPLY	int
,	O
"USER %s"	pointer
,	O
name	pointer
)	O
)	O
{	O
case	O
CONTINUE	int
:	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: sending user password"	pointer
)	O
)	O
;	O
code	int
=	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
WAIT_REPLY	int
,	O
"PASS %s"	pointer
,	O
pass	pointer
)	O
;	O
if	O
(	O
code	int
==	O
CONTINUE	int
)	O
{	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
g_strdup_printf	function
(	O
_	O
(	O
"FTP: Account required for user %s"	pointer
)	O
,	O
SUP	O
.	O
user	pointer
)	O
;	O
op	pointer
=	O
input_dialog	function
(	O
p	pointer
,	O
_	O
(	O
"Account:"	pointer
)	O
,	O
""	pointer
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
if	O
(	O
op	pointer
==	O
NULL	O
)	O
ERRNOR	O
(	O
EPERM	int
,	O
0	int
)	O
;	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: sending user account"	pointer
)	O
)	O
;	O
code	int
=	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
WAIT_REPLY	int
,	O
"ACCT %s"	pointer
,	O
op	pointer
)	O
;	O
g_free	function
(	O
op	pointer
)	O
;	O
}	O
if	O
(	O
code	int
!=	O
COMPLETE	int
)	O
break	O
;	O
case	O
COMPLETE	int
:	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: logged in"	pointer
)	O
)	O
;	O
wipe_password	function
(	O
pass	pointer
)	O
;	O
g_free	function
(	O
name	pointer
)	O
;	O
return	O
1	int
;	O
default	O
:	O
SUP	O
.	O
failed_on_login	int
=	O
1	int
;	O
if	O
(	O
SUP	O
.	O
password	pointer
)	O
wipe_password	function
(	O
SUP	O
.	O
password	pointer
)	O
;	O
SUP	O
.	O
password	pointer
=	O
0	int
;	O
goto	O
login_fail	O
;	O
}	O
}	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"ftpfs: Login incorrect for user %s "	pointer
)	O
,	O
SUP	O
.	O
user	pointer
)	O
;	O
login_fail	O
:	O
wipe_password	function
(	O
pass	pointer
)	O
;	O
g_free	function
(	O
name	pointer
)	O
;	O
ERRNOR	O
(	O
EPERM	int
,	O
0	int
)	O
;	O
}	O
static	O
struct	O
no_proxy_entry	struct
{	O
char	O
*	O
domain	int
;	O
void	O
*	O
next	pointer
;	O
}	O
*	O
no_proxy	pointer
;	O
static	O
void	O
ftpfs_load_no_proxy_list	function
(	O
void	O
)	O
{	O
char	O
s	pointer
[	O
BUF_LARGE	O
]	O
;	O
struct	O
no_proxy_entry	struct
*	O
np	pointer
,	O
*	O
current	pointer
=	O
0	int
;	O
FILE	struct
*	O
npf	pointer
;	O
int	O
c	int
;	O
char	O
*	O
p	pointer
;	O
static	O
char	O
*	O
mc_file	pointer
;	O
if	O
(	O
mc_file	pointer
)	O
return	O
;	O
mc_file	pointer
=	O
concat_dir_and_file	function
(	O
mc_home	pointer
,	O
"mc.no_proxy"	pointer
)	O
;	O
if	O
(	O
exist_file	function
(	O
mc_file	pointer
)	O
&&	O
(	O
npf	pointer
=	O
fopen	function
(	O
mc_file	pointer
,	O
"r"	pointer
)	O
)	O
)	O
{	O
while	O
(	O
fgets	function
(	O
s	pointer
,	O
sizeof	O
(	O
s	pointer
)	O
,	O
npf	pointer
)	O
)	O
{	O
if	O
(	O
!	O
(	O
p	pointer
=	O
strchr	function
(	O
s	pointer
,	O
'\n'	O
)	O
)	O
)	O
{	O
while	O
(	O
(	O
c	int
=	O
fgetc	function
(	O
npf	pointer
)	O
)	O
!=	O
EOF	O
&&	O
c	int
!=	O
'\n'	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
p	pointer
==	O
s	pointer
)	O
continue	O
;	O
*	O
p	pointer
=	O
'\0'	O
;	O
np	pointer
=	O
g_new	O
(	O
struct	O
no_proxy_entry	struct
,	O
1	int
)	O
;	O
np	pointer
->	O
domain	int
=	O
g_strdup	function
(	O
s	pointer
)	O
;	O
np	pointer
->	O
next	pointer
=	O
NULL	O
;	O
if	O
(	O
no_proxy	pointer
)	O
current	pointer
->	O
next	pointer
=	O
np	pointer
;	O
else	O
no_proxy	pointer
=	O
np	pointer
;	O
current	pointer
=	O
np	pointer
;	O
}	O
fclose	function
(	O
npf	pointer
)	O
;	O
}	O
g_free	function
(	O
mc_file	pointer
)	O
;	O
}	O
static	O
int	O
ftpfs_check_proxy	function
(	O
const	O
char	O
*	O
host	pointer
)	O
{	O
struct	O
no_proxy_entry	struct
*	O
npe	pointer
;	O
if	O
(	O
!	O
ftpfs_proxy_host	pointer
||	O
!	O
*	O
ftpfs_proxy_host	pointer
||	O
!	O
host	pointer
||	O
!	O
*	O
host	pointer
)	O
return	O
0	int
;	O
if	O
(	O
*	O
host	pointer
==	O
'!'	O
)	O
return	O
1	int
;	O
if	O
(	O
!	O
ftpfs_always_use_proxy	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
strchr	function
(	O
host	pointer
,	O
'.'	O
)	O
)	O
return	O
0	int
;	O
ftpfs_load_no_proxy_list	function
(	O
)	O
;	O
for	O
(	O
npe	pointer
=	O
no_proxy	pointer
;	O
npe	pointer
;	O
npe	pointer
=	O
npe	pointer
->	O
next	pointer
)	O
{	O
char	O
*	O
domain	int
=	O
npe	pointer
->	O
domain	int
;	O
if	O
(	O
domain	int
[	O
0	int
]	O
==	O
'.'	O
)	O
{	O
int	O
ld	int
=	O
strlen	function
(	O
domain	int
)	O
;	O
int	O
lh	int
=	O
strlen	function
(	O
host	pointer
)	O
;	O
while	O
(	O
ld	int
&&	O
lh	int
&&	O
host	pointer
[	O
lh	int
-	O
1	int
]	O
==	O
domain	int
[	O
ld	int
-	O
1	int
]	O
)	O
{	O
ld	int
--	O
;	O
lh	int
--	O
;	O
}	O
if	O
(	O
!	O
ld	int
)	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
g_strcasecmp	function
(	O
host	pointer
,	O
domain	int
)	O
)	O
return	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
ftpfs_get_proxy_host_and_port	function
(	O
const	O
char	O
*	O
proxy	pointer
,	O
char	O
*	O
*	O
host	pointer
,	O
int	O
*	O
port	pointer
)	O
{	O
char	O
*	O
user	pointer
,	O
*	O
dir	pointer
;	O
dir	pointer
=	O
vfs_split_url	function
(	O
proxy	pointer
,	O
host	pointer
,	O
&	O
user	pointer
,	O
port	pointer
,	O
0	int
,	O
FTP_COMMAND_PORT	int
,	O
URL_ALLOW_ANON	int
)	O
;	O
g_free	function
(	O
user	pointer
)	O
;	O
g_free	function
(	O
dir	pointer
)	O
;	O
}	O
static	O
int	O
ftpfs_open_socket	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
struct	O
sockaddr_in	struct
server_address	struct
;	O
struct	O
hostent	struct
*	O
hp	pointer
;	O
int	O
my_socket	int
;	O
char	O
*	O
host	pointer
;	O
int	O
port	pointer
=	O
SUP	O
.	O
port	pointer
;	O
int	O
free_host	int
=	O
0	int
;	O
(	O
void	O
)	O
me	pointer
;	O
host	pointer
=	O
SUP	O
.	O
host	pointer
;	O
if	O
(	O
!	O
host	pointer
||	O
!	O
*	O
host	pointer
)	O
{	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: Invalid host name."	pointer
)	O
)	O
;	O
ftpfs_errno	int
=	O
EINVAL	int
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
SUP	O
.	O
proxy	pointer
)	O
{	O
ftpfs_get_proxy_host_and_port	function
(	O
ftpfs_proxy_host	pointer
,	O
&	O
host	pointer
,	O
&	O
port	pointer
)	O
;	O
free_host	int
=	O
1	int
;	O
}	O
enable_interrupt_key	O
(	O
)	O
;	O
memset	function
(	O
(	O
char	O
*	O
)	O
&	O
server_address	struct
,	O
0	int
,	O
sizeof	O
(	O
server_address	struct
)	O
)	O
;	O
server_address	struct
.	O
sin_family	short
=	O
AF_INET	O
;	O
server_address	struct
.	O
sin_addr	struct
.	O
s_addr	int
=	O
inet_addr	function
(	O
host	pointer
)	O
;	O
if	O
(	O
server_address	struct
.	O
sin_addr	struct
.	O
s_addr	int
==	O
INADDR_NONE	O
)	O
{	O
hp	pointer
=	O
gethostbyname	function
(	O
host	pointer
)	O
;	O
if	O
(	O
hp	pointer
==	O
NULL	O
)	O
{	O
disable_interrupt_key	O
(	O
)	O
;	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: Invalid host address."	pointer
)	O
)	O
;	O
ftpfs_errno	int
=	O
EINVAL	int
;	O
if	O
(	O
free_host	int
)	O
g_free	function
(	O
host	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
server_address	struct
.	O
sin_family	short
=	O
hp	pointer
->	O
h_addrtype	int
;	O
memcpy	function
(	O
(	O
char	O
*	O
)	O
&	O
server_address	struct
.	O
sin_addr	struct
,	O
(	O
char	O
*	O
)	O
hp	pointer
->	O
h_addr	O
,	O
4	int
)	O
;	O
}	O
server_address	struct
.	O
sin_port	short
=	O
htons	function
(	O
port	pointer
)	O
;	O
if	O
(	O
(	O
my_socket	int
=	O
socket	function
(	O
AF_INET	O
,	O
SOCK_STREAM	int
,	O
0	int
)	O
)	O
<	O
0	int
)	O
{	O
disable_interrupt_key	O
(	O
)	O
;	O
ftpfs_errno	int
=	O
errno	O
;	O
if	O
(	O
free_host	int
)	O
g_free	function
(	O
host	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: making connection to %s"	pointer
)	O
,	O
host	pointer
)	O
;	O
if	O
(	O
free_host	int
)	O
g_free	function
(	O
host	pointer
)	O
;	O
if	O
(	O
connect	function
(	O
my_socket	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
server_address	struct
,	O
sizeof	O
(	O
server_address	struct
)	O
)	O
<	O
0	int
)	O
{	O
ftpfs_errno	int
=	O
errno	O
;	O
if	O
(	O
errno	O
==	O
EINTR	int
&&	O
got_interrupt	O
(	O
)	O
)	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: connection interrupted by user"	pointer
)	O
)	O
;	O
else	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: connection to server failed: %s"	pointer
)	O
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
disable_interrupt_key	O
(	O
)	O
;	O
close	function
(	O
my_socket	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
disable_interrupt_key	O
(	O
)	O
;	O
return	O
my_socket	int
;	O
}	O
static	O
int	O
ftpfs_open_archive_int	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
int	O
retry_seconds	int
,	O
count_down	int
;	O
if	O
(	O
SUP	O
.	O
proxy	pointer
)	O
SUP	O
.	O
use_passive_connection	int
=	O
ftpfs_use_passive_connections_over_proxy	int
;	O
retry_seconds	int
=	O
0	int
;	O
do	O
{	O
SUP	O
.	O
failed_on_login	int
=	O
0	int
;	O
SUP	O
.	O
sock	int
=	O
ftpfs_open_socket	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
if	O
(	O
SUP	O
.	O
sock	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ftpfs_login_server	function
(	O
me	pointer
,	O
super	pointer
,	O
NULL	O
)	O
)	O
{	O
break	O
;	O
}	O
else	O
{	O
if	O
(	O
SUP	O
.	O
failed_on_login	int
)	O
{	O
close	function
(	O
SUP	O
.	O
sock	int
)	O
;	O
}	O
else	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
ftpfs_retry_seconds	int
)	O
{	O
retry_seconds	int
=	O
ftpfs_retry_seconds	int
;	O
enable_interrupt_key	O
(	O
)	O
;	O
for	O
(	O
count_down	int
=	O
retry_seconds	int
;	O
count_down	int
;	O
count_down	int
--	O
)	O
{	O
print_vfs_message	function
(	O
_	O
(	O
"Waiting to retry... %d (Control-C to cancel)"	pointer
)	O
,	O
count_down	int
)	O
;	O
sleep	function
(	O
1	int
)	O
;	O
if	O
(	O
got_interrupt	O
(	O
)	O
)	O
{	O
disable_interrupt_key	O
(	O
)	O
;	O
return	O
0	int
;	O
}	O
}	O
disable_interrupt_key	O
(	O
)	O
;	O
}	O
}	O
}	O
while	O
(	O
retry_seconds	int
)	O
;	O
SUP	O
.	O
cwdir	pointer
=	O
ftpfs_get_current_directory	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
if	O
(	O
!	O
SUP	O
.	O
cwdir	pointer
)	O
SUP	O
.	O
cwdir	pointer
=	O
g_strdup	function
(	O
PATH_SEP_STR	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ftpfs_open_archive	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
const	O
char	O
*	O
archive_name	pointer
,	O
char	O
*	O
op	pointer
)	O
{	O
char	O
*	O
host	pointer
,	O
*	O
user	pointer
,	O
*	O
password	pointer
;	O
int	O
port	pointer
;	O
(	O
void	O
)	O
archive_name	pointer
;	O
ftpfs_split_url	function
(	O
strchr	function
(	O
op	pointer
,	O
':'	O
)	O
+	O
1	int
,	O
&	O
host	pointer
,	O
&	O
user	pointer
,	O
&	O
port	pointer
,	O
&	O
password	pointer
)	O
;	O
SUP	O
.	O
host	pointer
=	O
host	pointer
;	O
SUP	O
.	O
user	pointer
=	O
user	pointer
;	O
SUP	O
.	O
port	pointer
=	O
port	pointer
;	O
SUP	O
.	O
cwdir	pointer
=	O
NULL	O
;	O
SUP	O
.	O
proxy	pointer
=	O
0	int
;	O
if	O
(	O
ftpfs_check_proxy	function
(	O
host	pointer
)	O
)	O
SUP	O
.	O
proxy	pointer
=	O
ftpfs_proxy_host	pointer
;	O
SUP	O
.	O
password	pointer
=	O
password	pointer
;	O
SUP	O
.	O
use_passive_connection	int
=	O
ftpfs_use_passive_connections	int
;	O
SUP	O
.	O
strict	int
=	O
ftpfs_use_unix_list_options	int
?	O
RFC_AUTODETECT	int
:	O
RFC_STRICT	int
;	O
SUP	O
.	O
isbinary	int
=	O
TYPE_UNKNOWN	O
;	O
SUP	O
.	O
remote_is_amiga	int
=	O
0	int
;	O
super	pointer
->	O
name	pointer
=	O
g_strdup	function
(	O
"/"	pointer
)	O
;	O
super	pointer
->	O
root	pointer
=	O
vfs_s_new_inode	function
(	O
me	pointer
,	O
super	pointer
,	O
vfs_s_default_stat	function
(	O
me	pointer
,	O
S_IFDIR	O
|	O
0755	int
)	O
)	O
;	O
return	O
ftpfs_open_archive_int	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
}	O
static	O
int	O
ftpfs_archive_same	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
const	O
char	O
*	O
archive_name	pointer
,	O
char	O
*	O
op	pointer
,	O
void	O
*	O
cookie	pointer
)	O
{	O
char	O
*	O
host	pointer
,	O
*	O
user	pointer
;	O
int	O
port	pointer
;	O
(	O
void	O
)	O
me	pointer
;	O
(	O
void	O
)	O
archive_name	pointer
;	O
(	O
void	O
)	O
cookie	pointer
;	O
ftpfs_split_url	function
(	O
strchr	function
(	O
op	pointer
,	O
':'	O
)	O
+	O
1	int
,	O
&	O
host	pointer
,	O
&	O
user	pointer
,	O
&	O
port	pointer
,	O
0	int
)	O
;	O
port	pointer
=	O
(	O
(	O
strcmp	function
(	O
host	pointer
,	O
SUP	O
.	O
host	pointer
)	O
==	O
0	int
)	O
&&	O
(	O
strcmp	function
(	O
user	pointer
,	O
SUP	O
.	O
user	pointer
)	O
==	O
0	int
)	O
&&	O
(	O
port	pointer
==	O
SUP	O
.	O
port	pointer
)	O
)	O
;	O
g_free	function
(	O
host	pointer
)	O
;	O
g_free	function
(	O
user	pointer
)	O
;	O
return	O
port	pointer
;	O
}	O
static	O
char	O
*	O
ftpfs_get_current_directory	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
char	O
buf	pointer
[	O
BUF_8K	int
]	O
,	O
*	O
bufp	pointer
,	O
*	O
bufq	pointer
;	O
if	O
(	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
NONE	int
,	O
"PWD"	pointer
)	O
==	O
COMPLETE	int
&&	O
ftpfs_get_reply	function
(	O
me	pointer
,	O
SUP	O
.	O
sock	int
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
==	O
COMPLETE	int
)	O
{	O
bufp	pointer
=	O
NULL	O
;	O
for	O
(	O
bufq	pointer
=	O
buf	pointer
;	O
*	O
bufq	pointer
;	O
bufq	pointer
++	O
)	O
if	O
(	O
*	O
bufq	pointer
==	O
'"'	O
)	O
{	O
if	O
(	O
!	O
bufp	pointer
)	O
{	O
bufp	pointer
=	O
bufq	pointer
+	O
1	int
;	O
}	O
else	O
{	O
*	O
bufq	pointer
=	O
0	int
;	O
if	O
(	O
*	O
bufp	pointer
)	O
{	O
if	O
(	O
*	O
(	O
bufq	pointer
-	O
1	int
)	O
!=	O
'/'	O
)	O
{	O
*	O
bufq	pointer
++	O
=	O
'/'	O
;	O
*	O
bufq	pointer
=	O
0	int
;	O
}	O
if	O
(	O
*	O
bufp	pointer
==	O
'/'	O
)	O
return	O
g_strdup	function
(	O
bufp	pointer
)	O
;	O
else	O
{	O
return	O
g_strconcat	function
(	O
"/"	pointer
,	O
bufp	pointer
,	O
NULL	O
)	O
;	O
}	O
}	O
else	O
{	O
ftpfs_errno	int
=	O
EIO	int
;	O
return	O
NULL	O
;	O
}	O
}	O
}	O
}	O
ftpfs_errno	int
=	O
EIO	int
;	O
return	O
NULL	O
;	O
}	O
static	O
int	O
ftpfs_setup_passive	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
int	O
my_socket	int
,	O
struct	O
sockaddr_in	struct
*	O
sa	pointer
)	O
{	O
int	O
xa	int
,	O
xb	int
,	O
xc	int
,	O
xd	int
,	O
xe	int
,	O
xf	int
;	O
char	O
n	long
[	O
6	int
]	O
;	O
char	O
*	O
c	int
;	O
if	O
(	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
WAIT_REPLY	int
|	O
WANT_STRING	int
,	O
"PASV"	pointer
)	O
!=	O
COMPLETE	int
)	O
return	O
0	int
;	O
for	O
(	O
c	int
=	O
reply_str	array
+	O
4	int
;	O
(	O
*	O
c	int
)	O
&&	O
(	O
!	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
c	int
)	O
)	O
;	O
c	int
++	O
)	O
;	O
if	O
(	O
!	O
*	O
c	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
c	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
sscanf	function
(	O
c	int
,	O
"%d,%d,%d,%d,%d,%d"	pointer
,	O
&	O
xa	int
,	O
&	O
xb	int
,	O
&	O
xc	int
,	O
&	O
xd	int
,	O
&	O
xe	int
,	O
&	O
xf	int
)	O
!=	O
6	int
)	O
return	O
0	int
;	O
n	long
[	O
0	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
xa	int
;	O
n	long
[	O
1	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
xb	int
;	O
n	long
[	O
2	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
xc	int
;	O
n	long
[	O
3	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
xd	int
;	O
n	long
[	O
4	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
xe	int
;	O
n	long
[	O
5	int
]	O
=	O
(	O
unsigned	O
char	O
)	O
xf	int
;	O
memcpy	function
(	O
&	O
(	O
sa	pointer
->	O
sin_addr	struct
.	O
s_addr	int
)	O
,	O
(	O
void	O
*	O
)	O
n	long
,	O
4	int
)	O
;	O
memcpy	function
(	O
&	O
(	O
sa	pointer
->	O
sin_port	short
)	O
,	O
(	O
void	O
*	O
)	O
&	O
n	long
[	O
4	int
]	O
,	O
2	int
)	O
;	O
if	O
(	O
connect	function
(	O
my_socket	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
sa	pointer
,	O
sizeof	O
(	O
struct	O
sockaddr_in	struct
)	O
)	O
<	O
0	int
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
ftpfs_initconn	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
)	O
{	O
struct	O
sockaddr_in	struct
data_addr	struct
;	O
int	O
data	pointer
;	O
socklen_t	int
len	int
=	O
sizeof	O
(	O
data_addr	struct
)	O
;	O
struct	O
protoent	struct
*	O
pe	pointer
;	O
pe	pointer
=	O
getprotobyname	function
(	O
"tcp"	pointer
)	O
;	O
if	O
(	O
pe	pointer
==	O
NULL	O
)	O
ERRNOR	O
(	O
EIO	int
,	O
-	O
1	int
)	O
;	O
again	O
:	O
if	O
(	O
getsockname	function
(	O
SUP	O
.	O
sock	int
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
data_addr	struct
,	O
&	O
len	int
)	O
==	O
-	O
1	int
)	O
ERRNOR	O
(	O
EIO	int
,	O
-	O
1	int
)	O
;	O
data_addr	struct
.	O
sin_port	short
=	O
0	int
;	O
data	pointer
=	O
socket	function
(	O
AF_INET	O
,	O
SOCK_STREAM	int
,	O
pe	pointer
->	O
p_proto	int
)	O
;	O
if	O
(	O
data	pointer
<	O
0	int
)	O
ERRNOR	O
(	O
EIO	int
,	O
-	O
1	int
)	O
;	O
if	O
(	O
SUP	O
.	O
use_passive_connection	int
)	O
{	O
if	O
(	O
ftpfs_setup_passive	function
(	O
me	pointer
,	O
super	pointer
,	O
data	pointer
,	O
&	O
data_addr	struct
)	O
)	O
return	O
data	pointer
;	O
SUP	O
.	O
use_passive_connection	int
=	O
0	int
;	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: could not setup passive mode"	pointer
)	O
)	O
;	O
close	function
(	O
data	pointer
)	O
;	O
goto	O
again	O
;	O
}	O
if	O
(	O
(	O
bind	function
(	O
data	pointer
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
data_addr	struct
,	O
len	int
)	O
==	O
0	int
)	O
&&	O
(	O
getsockname	function
(	O
data	pointer
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
data_addr	struct
,	O
&	O
len	int
)	O
==	O
0	int
)	O
&&	O
(	O
listen	function
(	O
data	pointer
,	O
1	int
)	O
==	O
0	int
)	O
)	O
{	O
unsigned	O
char	O
*	O
a	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
data_addr	struct
.	O
sin_addr	struct
;	O
unsigned	O
char	O
*	O
p	pointer
=	O
(	O
unsigned	O
char	O
*	O
)	O
&	O
data_addr	struct
.	O
sin_port	short
;	O
if	O
(	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
WAIT_REPLY	int
,	O
"PORT %d,%d,%d,%d,%d,%d"	pointer
,	O
a	pointer
[	O
0	int
]	O
,	O
a	pointer
[	O
1	int
]	O
,	O
a	pointer
[	O
2	int
]	O
,	O
a	pointer
[	O
3	int
]	O
,	O
p	pointer
[	O
0	int
]	O
,	O
p	pointer
[	O
1	int
]	O
)	O
==	O
COMPLETE	int
)	O
return	O
data	pointer
;	O
}	O
close	function
(	O
data	pointer
)	O
;	O
ftpfs_errno	int
=	O
EIO	int
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
ftpfs_open_data_connection	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
const	O
char	O
*	O
cmd	pointer
,	O
const	O
char	O
*	O
remote	pointer
,	O
int	O
isbinary	int
,	O
int	O
reget	int
)	O
{	O
struct	O
sockaddr_in	struct
from	char
;	O
int	O
s	pointer
,	O
j	int
,	O
data	pointer
;	O
socklen_t	int
fromlen	int
=	O
sizeof	O
(	O
from	char
)	O
;	O
if	O
(	O
(	O
s	pointer
=	O
ftpfs_initconn	function
(	O
me	pointer
,	O
super	pointer
)	O
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
ftpfs_changetype	function
(	O
me	pointer
,	O
super	pointer
,	O
isbinary	int
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
reget	int
>	O
0	int
)	O
{	O
j	int
=	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
WAIT_REPLY	int
,	O
"REST %d"	pointer
,	O
reget	int
)	O
;	O
if	O
(	O
j	int
!=	O
CONTINUE	int
)	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
remote	pointer
)	O
{	O
char	O
*	O
remote_path	pointer
=	O
ftpfs_translate_path	function
(	O
me	pointer
,	O
super	pointer
,	O
remote	pointer
)	O
;	O
j	int
=	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
WAIT_REPLY	int
,	O
"%s /%s"	pointer
,	O
cmd	pointer
,	O
(	O
*	O
remote_path	pointer
==	O
'/'	O
)	O
?	O
remote_path	pointer
+	O
1	int
:	O
remote_path	pointer
)	O
;	O
g_free	function
(	O
remote_path	pointer
)	O
;	O
}	O
else	O
j	int
=	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
WAIT_REPLY	int
,	O
"%s"	pointer
,	O
cmd	pointer
)	O
;	O
if	O
(	O
j	int
!=	O
PRELIM	int
)	O
ERRNOR	O
(	O
EPERM	int
,	O
-	O
1	int
)	O
;	O
enable_interrupt_key	O
(	O
)	O
;	O
if	O
(	O
SUP	O
.	O
use_passive_connection	int
)	O
data	pointer
=	O
s	pointer
;	O
else	O
{	O
data	pointer
=	O
accept	function
(	O
s	pointer
,	O
(	O
struct	O
sockaddr	struct
*	O
)	O
&	O
from	char
,	O
&	O
fromlen	int
)	O
;	O
if	O
(	O
data	pointer
<	O
0	int
)	O
{	O
ftpfs_errno	int
=	O
errno	O
;	O
close	function
(	O
s	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
close	function
(	O
s	pointer
)	O
;	O
}	O
disable_interrupt_key	O
(	O
)	O
;	O
return	O
data	pointer
;	O
}	O
static	O
void	O
ftpfs_linear_abort	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_fh	struct
*	O
fh	pointer
)	O
{	O
struct	O
vfs_s_super	struct
*	O
super	pointer
=	O
FH_SUPER	O
;	O
static	O
unsigned	O
char	O
const	O
ipbuf	array
[	O
3	int
]	O
=	O
{	O
IAC	int
,	O
IP	int
,	O
IAC	int
}	O
;	O
fd_set	struct
mask	long
;	O
char	O
buf	pointer
[	O
1024	int
]	O
;	O
int	O
dsock	int
=	O
FH_SOCK	O
;	O
FH_SOCK	O
=	O
-	O
1	int
;	O
SUP	O
.	O
ctl_connection_busy	int
=	O
0	int
;	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: aborting transfer."	pointer
)	O
)	O
;	O
if	O
(	O
send	function
(	O
SUP	O
.	O
sock	int
,	O
ipbuf	array
,	O
sizeof	O
(	O
ipbuf	array
)	O
,	O
MSG_OOB	int
)	O
!=	O
sizeof	O
(	O
ipbuf	array
)	O
)	O
{	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: abort error: %s"	pointer
)	O
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
if	O
(	O
dsock	int
!=	O
-	O
1	int
)	O
close	function
(	O
dsock	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
NONE	int
,	O
"%cABOR"	pointer
,	O
DM	int
)	O
!=	O
COMPLETE	int
)	O
{	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: abort failed"	pointer
)	O
)	O
;	O
if	O
(	O
dsock	int
!=	O
-	O
1	int
)	O
close	function
(	O
dsock	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
dsock	int
!=	O
-	O
1	int
)	O
{	O
FD_ZERO	O
(	O
&	O
mask	long
)	O
;	O
FD_SET	O
(	O
dsock	int
,	O
&	O
mask	long
)	O
;	O
if	O
(	O
select	function
(	O
dsock	int
+	O
1	int
,	O
&	O
mask	long
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
>	O
0	int
)	O
{	O
struct	O
timeval	struct
start_tim	struct
,	O
tim	struct
;	O
gettimeofday	function
(	O
&	O
start_tim	struct
,	O
NULL	O
)	O
;	O
while	O
(	O
read	function
(	O
dsock	int
,	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
>	O
0	int
)	O
{	O
gettimeofday	function
(	O
&	O
tim	struct
,	O
NULL	O
)	O
;	O
if	O
(	O
tim	struct
.	O
tv_sec	long
>	O
start_tim	struct
.	O
tv_sec	long
+	O
ABORT_TIMEOUT	int
)	O
{	O
close	function
(	O
dsock	int
)	O
;	O
ftpfs_reconnect	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
return	O
;	O
}	O
}	O
}	O
close	function
(	O
dsock	int
)	O
;	O
}	O
if	O
(	O
(	O
ftpfs_get_reply	function
(	O
me	pointer
,	O
SUP	O
.	O
sock	int
,	O
NULL	O
,	O
0	int
)	O
==	O
TRANSIENT	int
)	O
&&	O
(	O
code	int
==	O
426	int
)	O
)	O
ftpfs_get_reply	function
(	O
me	pointer
,	O
SUP	O
.	O
sock	int
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
static	O
int	O
ftpfs_dir_load	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_inode	struct
*	O
dir	pointer
,	O
char	O
*	O
remote_path	pointer
)	O
{	O
struct	O
vfs_s_entry	struct
*	O
ent	pointer
;	O
struct	O
vfs_s_super	struct
*	O
super	pointer
=	O
dir	pointer
->	O
super	pointer
;	O
int	O
sock	int
,	O
num_entries	int
=	O
0	int
;	O
char	O
buffer	pointer
[	O
BUF_8K	int
]	O
;	O
int	O
cd_first	int
;	O
cd_first	int
=	O
ftpfs_first_cd_then_ls	int
||	O
(	O
SUP	O
.	O
strict	int
==	O
RFC_STRICT	int
)	O
||	O
(	O
strchr	function
(	O
remote_path	pointer
,	O
' '	O
)	O
!=	O
NULL	O
)	O
;	O
again	O
:	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: Reading FTP directory %s... %s%s"	pointer
)	O
,	O
remote_path	pointer
,	O
SUP	O
.	O
strict	int
==	O
RFC_STRICT	int
?	O
_	O
(	O
"(strict rfc959)"	pointer
)	O
:	O
""	pointer
,	O
cd_first	int
?	O
_	O
(	O
"(chdir first)"	pointer
)	O
:	O
""	pointer
)	O
;	O
if	O
(	O
cd_first	int
)	O
{	O
if	O
(	O
ftpfs_chdir_internal	function
(	O
me	pointer
,	O
super	pointer
,	O
remote_path	pointer
)	O
!=	O
COMPLETE	int
)	O
{	O
ftpfs_errno	int
=	O
ENOENT	int
;	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: CWD failed."	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
gettimeofday	function
(	O
&	O
dir	pointer
->	O
timestamp	struct
,	O
NULL	O
)	O
;	O
dir	pointer
->	O
timestamp	struct
.	O
tv_sec	long
+=	O
ftpfs_directory_timeout	int
;	O
if	O
(	O
SUP	O
.	O
strict	int
==	O
RFC_STRICT	int
)	O
sock	int
=	O
ftpfs_open_data_connection	function
(	O
me	pointer
,	O
super	pointer
,	O
"LIST"	pointer
,	O
0	int
,	O
TYPE_ASCII	int
,	O
0	int
)	O
;	O
else	O
if	O
(	O
cd_first	int
)	O
sock	int
=	O
ftpfs_open_data_connection	function
(	O
me	pointer
,	O
super	pointer
,	O
"LIST -la"	pointer
,	O
0	int
,	O
TYPE_ASCII	int
,	O
0	int
)	O
;	O
else	O
{	O
char	O
*	O
path	pointer
=	O
concat_dir_and_file	function
(	O
remote_path	pointer
,	O
"."	pointer
)	O
;	O
sock	int
=	O
ftpfs_open_data_connection	function
(	O
me	pointer
,	O
super	pointer
,	O
"LIST -la"	pointer
,	O
path	pointer
,	O
TYPE_ASCII	int
,	O
0	int
)	O
;	O
g_free	function
(	O
path	pointer
)	O
;	O
}	O
if	O
(	O
sock	int
==	O
-	O
1	int
)	O
goto	O
fallback	pointer
;	O
enable_interrupt_key	O
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
i	array
;	O
int	O
res	int
=	O
vfs_s_get_line_interruptible	function
(	O
me	pointer
,	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
,	O
sock	int
)	O
;	O
if	O
(	O
!	O
res	int
)	O
break	O
;	O
if	O
(	O
res	int
==	O
EINTR	int
)	O
{	O
me	pointer
->	O
verrno	int
=	O
ECONNRESET	int
;	O
close	function
(	O
sock	int
)	O
;	O
disable_interrupt_key	O
(	O
)	O
;	O
ftpfs_get_reply	function
(	O
me	pointer
,	O
SUP	O
.	O
sock	int
,	O
NULL	O
,	O
0	int
)	O
;	O
print_vfs_message	function
(	O
_	O
(	O
"%s: failure"	pointer
)	O
,	O
me	pointer
->	O
name	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
MEDATA	O
->	O
logfile	pointer
)	O
{	O
fputs	function
(	O
buffer	pointer
,	O
MEDATA	O
->	O
logfile	pointer
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
MEDATA	O
->	O
logfile	pointer
)	O
;	O
fflush	function
(	O
MEDATA	O
->	O
logfile	pointer
)	O
;	O
}	O
ent	pointer
=	O
vfs_s_generate_entry	function
(	O
me	pointer
,	O
NULL	O
,	O
dir	pointer
,	O
0	int
)	O
;	O
i	array
=	O
ent	pointer
->	O
ino	pointer
->	O
st	pointer
.	O
st_nlink	long
;	O
if	O
(	O
!	O
vfs_parse_ls_lga	function
(	O
buffer	pointer
,	O
&	O
ent	pointer
->	O
ino	pointer
->	O
st	pointer
,	O
&	O
ent	pointer
->	O
name	pointer
,	O
&	O
ent	pointer
->	O
ino	pointer
->	O
linkname	pointer
)	O
)	O
{	O
vfs_s_free_entry	function
(	O
me	pointer
,	O
ent	pointer
)	O
;	O
continue	O
;	O
}	O
ent	pointer
->	O
ino	pointer
->	O
st	pointer
.	O
st_nlink	long
=	O
i	array
;	O
num_entries	int
++	O
;	O
vfs_s_insert_entry	function
(	O
me	pointer
,	O
dir	pointer
,	O
ent	pointer
)	O
;	O
}	O
close	function
(	O
sock	int
)	O
;	O
me	pointer
->	O
verrno	int
=	O
E_REMOTE	O
;	O
if	O
(	O
(	O
ftpfs_get_reply	function
(	O
me	pointer
,	O
SUP	O
.	O
sock	int
,	O
NULL	O
,	O
0	int
)	O
!=	O
COMPLETE	int
)	O
)	O
goto	O
fallback	pointer
;	O
if	O
(	O
num_entries	int
==	O
0	int
&&	O
cd_first	int
==	O
0	int
)	O
{	O
cd_first	int
=	O
1	int
;	O
goto	O
again	O
;	O
}	O
if	O
(	O
SUP	O
.	O
strict	int
==	O
RFC_AUTODETECT	int
)	O
SUP	O
.	O
strict	int
=	O
RFC_DARING	int
;	O
print_vfs_message	function
(	O
_	O
(	O
"%s: done."	pointer
)	O
,	O
me	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
fallback	pointer
:	O
if	O
(	O
SUP	O
.	O
strict	int
==	O
RFC_AUTODETECT	int
)	O
{	O
SUP	O
.	O
strict	int
=	O
RFC_STRICT	int
;	O
cd_first	int
=	O
1	int
;	O
goto	O
again	O
;	O
}	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: failed; nowhere to fallback to"	pointer
)	O
)	O
;	O
ERRNOR	O
(	O
EACCES	int
,	O
-	O
1	int
)	O
;	O
}	O
static	O
int	O
ftpfs_file_store	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_fh	struct
*	O
fh	pointer
,	O
char	O
*	O
name	pointer
,	O
char	O
*	O
localname	pointer
)	O
{	O
int	O
h	pointer
,	O
sock	int
,	O
n_read	int
,	O
n_written	int
;	O
off_t	long
n_stored	long
;	O
struct	O
linger	struct
li	struct
;	O
char	O
buffer	pointer
[	O
8192	int
]	O
;	O
struct	O
stat	struct
s	pointer
;	O
char	O
*	O
w_buf	pointer
;	O
struct	O
vfs_s_super	struct
*	O
super	pointer
=	O
FH_SUPER	O
;	O
h	pointer
=	O
open	function
(	O
localname	pointer
,	O
O_RDONLY	int
)	O
;	O
if	O
(	O
h	pointer
==	O
-	O
1	int
)	O
ERRNOR	O
(	O
EIO	int
,	O
-	O
1	int
)	O
;	O
sock	int
=	O
ftpfs_open_data_connection	function
(	O
me	pointer
,	O
super	pointer
,	O
fh	pointer
->	O
u	union
.	O
ftp	struct
.	O
append	int
?	O
"APPE"	pointer
:	O
"STOR"	pointer
,	O
name	pointer
,	O
TYPE_BINARY	int
,	O
0	int
)	O
;	O
if	O
(	O
sock	int
<	O
0	int
||	O
fstat	function
(	O
h	pointer
,	O
&	O
s	pointer
)	O
==	O
-	O
1	int
)	O
{	O
close	function
(	O
h	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
li	struct
.	O
l_onoff	int
=	O
1	int
;	O
li	struct
.	O
l_linger	int
=	O
120	int
;	O
setsockopt	function
(	O
sock	int
,	O
SOL_SOCKET	int
,	O
SO_LINGER	int
,	O
(	O
char	O
*	O
)	O
&	O
li	struct
,	O
sizeof	O
(	O
li	struct
)	O
)	O
;	O
n_stored	long
=	O
0	int
;	O
enable_interrupt_key	O
(	O
)	O
;	O
while	O
(	O
1	int
)	O
{	O
while	O
(	O
(	O
n_read	int
=	O
read	function
(	O
h	pointer
,	O
buffer	pointer
,	O
sizeof	O
(	O
buffer	pointer
)	O
)	O
)	O
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
)	O
{	O
if	O
(	O
got_interrupt	O
(	O
)	O
)	O
{	O
ftpfs_errno	int
=	O
EINTR	int
;	O
goto	O
error_return	O
;	O
}	O
else	O
continue	O
;	O
}	O
ftpfs_errno	int
=	O
errno	O
;	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
n_read	int
==	O
0	int
)	O
break	O
;	O
n_stored	long
+=	O
n_read	int
;	O
w_buf	pointer
=	O
buffer	pointer
;	O
while	O
(	O
(	O
n_written	int
=	O
write	function
(	O
sock	int
,	O
w_buf	pointer
,	O
n_read	int
)	O
)	O
!=	O
n_read	int
)	O
{	O
if	O
(	O
n_written	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
errno	O
==	O
EINTR	int
&&	O
!	O
got_interrupt	O
(	O
)	O
)	O
{	O
continue	O
;	O
}	O
ftpfs_errno	int
=	O
errno	O
;	O
goto	O
error_return	O
;	O
}	O
w_buf	pointer
+=	O
n_written	int
;	O
n_read	int
-=	O
n_written	int
;	O
}	O
print_vfs_message	function
(	O
_	O
(	O
"ftpfs: storing file %lu (%lu)"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
n_stored	long
,	O
(	O
unsigned	O
long	O
)	O
s	pointer
.	O
st_size	long
)	O
;	O
}	O
disable_interrupt_key	O
(	O
)	O
;	O
close	function
(	O
sock	int
)	O
;	O
close	function
(	O
h	pointer
)	O
;	O
if	O
(	O
ftpfs_get_reply	function
(	O
me	pointer
,	O
SUP	O
.	O
sock	int
,	O
NULL	O
,	O
0	int
)	O
!=	O
COMPLETE	int
)	O
ERRNOR	O
(	O
EIO	int
,	O
-	O
1	int
)	O
;	O
return	O
0	int
;	O
error_return	O
:	O
disable_interrupt_key	O
(	O
)	O
;	O
close	function
(	O
sock	int
)	O
;	O
close	function
(	O
h	pointer
)	O
;	O
ftpfs_get_reply	function
(	O
me	pointer
,	O
SUP	O
.	O
sock	int
,	O
NULL	O
,	O
0	int
)	O
;	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
ftpfs_linear_start	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_fh	struct
*	O
fh	pointer
,	O
off_t	long
offset	long
)	O
{	O
char	O
*	O
name	pointer
=	O
vfs_s_fullpath	function
(	O
me	pointer
,	O
fh	pointer
->	O
ino	pointer
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
0	int
;	O
FH_SOCK	O
=	O
ftpfs_open_data_connection	function
(	O
me	pointer
,	O
FH_SUPER	O
,	O
"RETR"	pointer
,	O
name	pointer
,	O
TYPE_BINARY	int
,	O
offset	long
)	O
;	O
g_free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
FH_SOCK	O
==	O
-	O
1	int
)	O
ERRNOR	O
(	O
EACCES	int
,	O
0	int
)	O
;	O
fh	pointer
->	O
linear	int
=	O
LS_LINEAR_OPEN	int
;	O
FH_SUPER	O
->	O
u	union
.	O
ftp	struct
.	O
ctl_connection_busy	int
=	O
1	int
;	O
fh	pointer
->	O
u	union
.	O
ftp	struct
.	O
append	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
ftpfs_linear_read	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_fh	struct
*	O
fh	pointer
,	O
void	O
*	O
buf	pointer
,	O
int	O
len	int
)	O
{	O
int	O
n	long
;	O
struct	O
vfs_s_super	struct
*	O
super	pointer
=	O
FH_SUPER	O
;	O
while	O
(	O
(	O
n	long
=	O
read	function
(	O
FH_SOCK	O
,	O
buf	pointer
,	O
len	int
)	O
)	O
<	O
0	int
)	O
{	O
if	O
(	O
(	O
errno	O
==	O
EINTR	int
)	O
&&	O
!	O
got_interrupt	O
(	O
)	O
)	O
continue	O
;	O
break	O
;	O
}	O
if	O
(	O
n	long
<	O
0	int
)	O
ftpfs_linear_abort	function
(	O
me	pointer
,	O
fh	pointer
)	O
;	O
if	O
(	O
!	O
n	long
)	O
{	O
SUP	O
.	O
ctl_connection_busy	int
=	O
0	int
;	O
close	function
(	O
FH_SOCK	O
)	O
;	O
FH_SOCK	O
=	O
-	O
1	int
;	O
if	O
(	O
(	O
ftpfs_get_reply	function
(	O
me	pointer
,	O
SUP	O
.	O
sock	int
,	O
NULL	O
,	O
0	int
)	O
!=	O
COMPLETE	int
)	O
)	O
ERRNOR	O
(	O
E_REMOTE	O
,	O
-	O
1	int
)	O
;	O
return	O
0	int
;	O
}	O
ERRNOR	O
(	O
errno	O
,	O
n	long
)	O
;	O
}	O
static	O
void	O
ftpfs_linear_close	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_fh	struct
*	O
fh	pointer
)	O
{	O
if	O
(	O
FH_SOCK	O
!=	O
-	O
1	int
)	O
ftpfs_linear_abort	function
(	O
me	pointer
,	O
fh	pointer
)	O
;	O
}	O
static	O
int	O
ftpfs_ctl	function
(	O
void	O
*	O
fh	pointer
,	O
int	O
ctlop	int
,	O
void	O
*	O
arg	pointer
)	O
{	O
(	O
void	O
)	O
arg	pointer
;	O
switch	O
(	O
ctlop	int
)	O
{	O
case	O
VFS_CTL_IS_NOTREADY	int
:	O
{	O
int	O
v	pointer
;	O
if	O
(	O
!	O
FH	O
->	O
linear	int
)	O
vfs_die	function
(	O
"You may not do this"	pointer
)	O
;	O
if	O
(	O
FH	O
->	O
linear	int
==	O
LS_LINEAR_CLOSED	int
||	O
FH	O
->	O
linear	int
==	O
LS_LINEAR_PREOPEN	int
)	O
return	O
0	int
;	O
v	pointer
=	O
vfs_s_select_on_two	function
(	O
FH	O
->	O
u	union
.	O
ftp	struct
.	O
sock	int
,	O
0	int
)	O
;	O
if	O
(	O
(	O
(	O
v	pointer
<	O
0	int
)	O
&&	O
(	O
errno	O
==	O
EINTR	int
)	O
)	O
||	O
v	pointer
==	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
default	O
:	O
return	O
0	int
;	O
}	O
}	O
static	O
int	O
ftpfs_send_command	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
const	O
char	O
*	O
cmd	pointer
,	O
int	O
flags	enum
)	O
{	O
const	O
char	O
*	O
rpath	pointer
;	O
char	O
*	O
p	pointer
,	O
*	O
mpath	pointer
=	O
g_strdup	function
(	O
filename	pointer
)	O
;	O
struct	O
vfs_s_super	struct
*	O
super	pointer
;	O
int	O
r	pointer
;	O
int	O
flush_directory_cache	int
=	O
(	O
flags	enum
&	O
OPT_FLUSH	int
)	O
;	O
if	O
(	O
!	O
(	O
rpath	pointer
=	O
vfs_s_get_path_mangle	function
(	O
me	pointer
,	O
mpath	pointer
,	O
&	O
super	pointer
,	O
0	int
)	O
)	O
)	O
{	O
g_free	function
(	O
mpath	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
p	pointer
=	O
ftpfs_translate_path	function
(	O
me	pointer
,	O
super	pointer
,	O
rpath	pointer
)	O
;	O
r	pointer
=	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
WAIT_REPLY	int
,	O
cmd	pointer
,	O
p	pointer
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
vfs_stamp_create	function
(	O
&	O
vfs_ftpfs_ops	struct
,	O
super	pointer
)	O
;	O
if	O
(	O
flags	enum
&	O
OPT_IGNORE_ERROR	int
)	O
r	pointer
=	O
COMPLETE	int
;	O
if	O
(	O
r	pointer
!=	O
COMPLETE	int
)	O
{	O
me	pointer
->	O
verrno	int
=	O
EPERM	int
;	O
g_free	function
(	O
mpath	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
flush_directory_cache	int
)	O
vfs_s_invalidate	function
(	O
me	pointer
,	O
super	pointer
)	O
;	O
g_free	function
(	O
mpath	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
ftpfs_init_passwd	function
(	O
void	O
)	O
{	O
ftpfs_anonymous_passwd	pointer
=	O
load_anon_passwd	function
(	O
)	O
;	O
if	O
(	O
ftpfs_anonymous_passwd	pointer
)	O
return	O
;	O
ftpfs_anonymous_passwd	pointer
=	O
g_strdup	function
(	O
"anonymous@"	pointer
)	O
;	O
}	O
static	O
int	O
ftpfs_chmod	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
int	O
mode	int
)	O
{	O
char	O
buf	pointer
[	O
BUF_SMALL	int
]	O
;	O
g_snprintf	function
(	O
buf	pointer
,	O
sizeof	O
(	O
buf	pointer
)	O
,	O
"SITE CHMOD %4.4o /%%s"	pointer
,	O
mode	int
&	O
07777	int
)	O
;	O
return	O
ftpfs_send_command	function
(	O
me	pointer
,	O
path	pointer
,	O
buf	pointer
,	O
OPT_FLUSH	int
)	O
;	O
}	O
static	O
int	O
ftpfs_chown	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
int	O
owner	long
,	O
int	O
group	struct
)	O
{	O
(	O
void	O
)	O
me	pointer
;	O
(	O
void	O
)	O
path	pointer
;	O
(	O
void	O
)	O
owner	long
;	O
(	O
void	O
)	O
group	struct
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ftpfs_unlink	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
return	O
ftpfs_send_command	function
(	O
me	pointer
,	O
path	pointer
,	O
"DELE /%s"	pointer
,	O
OPT_FLUSH	int
)	O
;	O
}	O
static	O
int	O
ftpfs_is_same_dir	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
(	O
void	O
)	O
me	pointer
;	O
if	O
(	O
!	O
SUP	O
.	O
cwdir	pointer
)	O
return	O
0	int
;	O
if	O
(	O
strcmp	function
(	O
path	pointer
,	O
SUP	O
.	O
cwdir	pointer
)	O
==	O
0	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ftpfs_chdir_internal	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_super	struct
*	O
super	pointer
,	O
const	O
char	O
*	O
remote_path	pointer
)	O
{	O
int	O
r	pointer
;	O
char	O
*	O
p	pointer
;	O
if	O
(	O
!	O
SUP	O
.	O
cwd_deferred	int
&&	O
ftpfs_is_same_dir	function
(	O
me	pointer
,	O
super	pointer
,	O
remote_path	pointer
)	O
)	O
return	O
COMPLETE	int
;	O
p	pointer
=	O
ftpfs_translate_path	function
(	O
me	pointer
,	O
super	pointer
,	O
remote_path	pointer
)	O
;	O
r	pointer
=	O
ftpfs_command	function
(	O
me	pointer
,	O
super	pointer
,	O
WAIT_REPLY	int
,	O
"CWD /%s"	pointer
,	O
p	pointer
)	O
;	O
g_free	function
(	O
p	pointer
)	O
;	O
if	O
(	O
r	pointer
!=	O
COMPLETE	int
)	O
{	O
ftpfs_errno	int
=	O
EIO	int
;	O
}	O
else	O
{	O
g_free	function
(	O
SUP	O
.	O
cwdir	pointer
)	O
;	O
SUP	O
.	O
cwdir	pointer
=	O
g_strdup	function
(	O
remote_path	pointer
)	O
;	O
SUP	O
.	O
cwd_deferred	int
=	O
0	int
;	O
}	O
return	O
r	pointer
;	O
}	O
static	O
int	O
ftpfs_rename	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path1	pointer
,	O
const	O
char	O
*	O
path2	pointer
)	O
{	O
ftpfs_send_command	function
(	O
me	pointer
,	O
path1	pointer
,	O
"RNFR /%s"	pointer
,	O
OPT_FLUSH	int
)	O
;	O
return	O
ftpfs_send_command	function
(	O
me	pointer
,	O
path2	pointer
,	O
"RNTO /%s"	pointer
,	O
OPT_FLUSH	int
)	O
;	O
}	O
static	O
int	O
ftpfs_mkdir	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
,	O
mode_t	int
mode	int
)	O
{	O
(	O
void	O
)	O
mode	int
;	O
return	O
ftpfs_send_command	function
(	O
me	pointer
,	O
path	pointer
,	O
"MKD /%s"	pointer
,	O
OPT_FLUSH	int
)	O
;	O
}	O
static	O
int	O
ftpfs_rmdir	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
const	O
char	O
*	O
path	pointer
)	O
{	O
return	O
ftpfs_send_command	function
(	O
me	pointer
,	O
path	pointer
,	O
"RMD /%s"	pointer
,	O
OPT_FLUSH	int
)	O
;	O
}	O
static	O
int	O
ftpfs_fh_open	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_fh	struct
*	O
fh	pointer
,	O
int	O
flags	enum
,	O
int	O
mode	int
)	O
{	O
(	O
void	O
)	O
mode	int
;	O
fh	pointer
->	O
u	union
.	O
ftp	struct
.	O
append	int
=	O
0	int
;	O
if	O
(	O
(	O
(	O
flags	enum
&	O
O_WRONLY	int
)	O
==	O
O_WRONLY	int
)	O
&&	O
!	O
(	O
flags	enum
&	O
(	O
O_RDONLY	int
|	O
O_RDWR	int
)	O
)	O
)	O
{	O
struct	O
linger	struct
li	struct
;	O
char	O
*	O
name	pointer
;	O
if	O
(	O
FH_SUPER	O
->	O
u	union
.	O
ftp	struct
.	O
ctl_connection_busy	int
)	O
{	O
if	O
(	O
!	O
fh	pointer
->	O
ino	pointer
->	O
localname	pointer
)	O
{	O
int	O
handle	int
=	O
vfs_mkstemps	function
(	O
&	O
fh	pointer
->	O
ino	pointer
->	O
localname	pointer
,	O
me	pointer
->	O
name	pointer
,	O
fh	pointer
->	O
ino	pointer
->	O
ent	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
handle	int
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
close	function
(	O
handle	int
)	O
;	O
fh	pointer
->	O
u	union
.	O
ftp	struct
.	O
append	int
=	O
flags	enum
&	O
O_APPEND	int
;	O
}	O
return	O
0	int
;	O
}	O
name	pointer
=	O
vfs_s_fullpath	function
(	O
me	pointer
,	O
fh	pointer
->	O
ino	pointer
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
-	O
1	int
;	O
fh	pointer
->	O
handle	int
=	O
ftpfs_open_data_connection	function
(	O
me	pointer
,	O
fh	pointer
->	O
ino	pointer
->	O
super	pointer
,	O
(	O
flags	enum
&	O
O_APPEND	int
)	O
?	O
"APPE"	pointer
:	O
"STOR"	pointer
,	O
name	pointer
,	O
TYPE_BINARY	int
,	O
0	int
)	O
;	O
g_free	function
(	O
name	pointer
)	O
;	O
if	O
(	O
fh	pointer
->	O
handle	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
li	struct
.	O
l_onoff	int
=	O
1	int
;	O
li	struct
.	O
l_linger	int
=	O
120	int
;	O
setsockopt	function
(	O
fh	pointer
->	O
handle	int
,	O
SOL_SOCKET	int
,	O
SO_LINGER	int
,	O
&	O
li	struct
,	O
sizeof	O
(	O
li	struct
)	O
)	O
;	O
if	O
(	O
fh	pointer
->	O
ino	pointer
->	O
localname	pointer
)	O
{	O
unlink	function
(	O
fh	pointer
->	O
ino	pointer
->	O
localname	pointer
)	O
;	O
g_free	function
(	O
fh	pointer
->	O
ino	pointer
->	O
localname	pointer
)	O
;	O
fh	pointer
->	O
ino	pointer
->	O
localname	pointer
=	O
NULL	O
;	O
}	O
return	O
0	int
;	O
}	O
if	O
(	O
!	O
fh	pointer
->	O
ino	pointer
->	O
localname	pointer
)	O
if	O
(	O
vfs_s_retrieve_file	function
(	O
me	pointer
,	O
fh	pointer
->	O
ino	pointer
)	O
==	O
-	O
1	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
fh	pointer
->	O
ino	pointer
->	O
localname	pointer
)	O
vfs_die	function
(	O
"retrieve_file failed to fill in localname"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
ftpfs_fh_close	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
struct	O
vfs_s_fh	struct
*	O
fh	pointer
)	O
{	O
if	O
(	O
fh	pointer
->	O
handle	int
!=	O
-	O
1	int
&&	O
!	O
fh	pointer
->	O
ino	pointer
->	O
localname	pointer
)	O
{	O
close	function
(	O
fh	pointer
->	O
handle	int
)	O
;	O
fh	pointer
->	O
handle	int
=	O
-	O
1	int
;	O
fh	pointer
->	O
changed	int
=	O
0	int
;	O
if	O
(	O
ftpfs_get_reply	function
(	O
me	pointer
,	O
fh	pointer
->	O
ino	pointer
->	O
SUP	O
.	O
sock	int
,	O
NULL	O
,	O
0	int
)	O
!=	O
COMPLETE	int
)	O
ERRNOR	O
(	O
EIO	int
,	O
-	O
1	int
)	O
;	O
vfs_s_invalidate	function
(	O
me	pointer
,	O
FH_SUPER	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
ftpfs_done	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
)	O
{	O
struct	O
no_proxy_entry	struct
*	O
np	pointer
;	O
(	O
void	O
)	O
me	pointer
;	O
while	O
(	O
no_proxy	pointer
)	O
{	O
np	pointer
=	O
no_proxy	pointer
->	O
next	pointer
;	O
g_free	function
(	O
no_proxy	pointer
->	O
domain	int
)	O
;	O
g_free	function
(	O
no_proxy	pointer
)	O
;	O
no_proxy	pointer
=	O
np	pointer
;	O
}	O
g_free	function
(	O
ftpfs_anonymous_passwd	pointer
)	O
;	O
g_free	function
(	O
ftpfs_proxy_host	pointer
)	O
;	O
}	O
static	O
void	O
ftpfs_fill_names	function
(	O
struct	O
vfs_class	struct
*	O
me	pointer
,	O
fill_names_f	pointer
func	pointer
)	O
{	O
struct	O
vfs_s_super	struct
*	O
super	pointer
=	O
MEDATA	O
->	O
supers	pointer
;	O
char	O
*	O
name	pointer
;	O
while	O
(	O
super	pointer
)	O
{	O
name	pointer
=	O
g_strconcat	function
(	O
"/#ftp:"	pointer
,	O
SUP	O
.	O
user	pointer
,	O
"@"	pointer
,	O
SUP	O
.	O
host	pointer
,	O
"/"	pointer
,	O
SUP	O
.	O
cwdir	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
)	O
;	O
(	O
*	O
func	pointer
)	O
(	O
name	pointer
)	O
;	O
g_free	function
(	O
name	pointer
)	O
;	O
super	pointer
=	O
super	pointer
->	O
next	pointer
;	O
}	O
}	O
static	O
char	O
buffer	pointer
[	O
BUF_MEDIUM	int
]	O
;	O
static	O
char	O
*	O
netrc	pointer
;	O
static	O
const	O
char	O
*	O
netrcp	pointer
;	O
typedef	O
enum	O
{	O
NETRC_NONE	int
=	O
0	int
,	O
NETRC_DEFAULT	int
,	O
NETRC_MACHINE	int
,	O
NETRC_LOGIN	int
,	O
NETRC_PASSWORD	int
,	O
NETRC_PASSWD	int
,	O
NETRC_ACCOUNT	int
,	O
NETRC_MACDEF	int
,	O
NETRC_UNKNOWN	int
}	O
keyword_t	enum
;	O
static	O
keyword_t	enum
ftpfs_netrc_next	function
(	O
void	O
)	O
{	O
char	O
*	O
p	pointer
;	O
keyword_t	enum
i	array
;	O
static	O
const	O
char	O
*	O
const	O
keywords	array
[	O
]	O
=	O
{	O
"default"	pointer
,	O
"machine"	pointer
,	O
"login"	pointer
,	O
"password"	pointer
,	O
"passwd"	pointer
,	O
"account"	pointer
,	O
"macdef"	pointer
,	O
NULL	O
}	O
;	O
while	O
(	O
1	int
)	O
{	O
netrcp	pointer
=	O
skip_separators	function
(	O
netrcp	pointer
)	O
;	O
if	O
(	O
*	O
netrcp	pointer
!=	O
'\n'	O
)	O
break	O
;	O
netrcp	pointer
++	O
;	O
}	O
if	O
(	O
!	O
*	O
netrcp	pointer
)	O
return	O
NETRC_NONE	int
;	O
p	pointer
=	O
buffer	pointer
;	O
if	O
(	O
*	O
netrcp	pointer
==	O
'"'	O
)	O
{	O
for	O
(	O
netrcp	pointer
++	O
;	O
*	O
netrcp	pointer
!=	O
'"'	O
&&	O
*	O
netrcp	pointer
;	O
netrcp	pointer
++	O
)	O
{	O
if	O
(	O
*	O
netrcp	pointer
==	O
'\\'	O
)	O
netrcp	pointer
++	O
;	O
*	O
p	pointer
++	O
=	O
*	O
netrcp	pointer
;	O
}	O
}	O
else	O
{	O
for	O
(	O
;	O
*	O
netrcp	pointer
!=	O
'\n'	O
&&	O
*	O
netrcp	pointer
!=	O
'\t'	O
&&	O
*	O
netrcp	pointer
!=	O
' '	O
&&	O
*	O
netrcp	pointer
!=	O
','	O
&&	O
*	O
netrcp	pointer
;	O
netrcp	pointer
++	O
)	O
{	O
if	O
(	O
*	O
netrcp	pointer
==	O
'\\'	O
)	O
netrcp	pointer
++	O
;	O
*	O
p	pointer
++	O
=	O
*	O
netrcp	pointer
;	O
}	O
}	O
*	O
p	pointer
=	O
0	int
;	O
if	O
(	O
!	O
*	O
buffer	pointer
)	O
return	O
NETRC_NONE	int
;	O
i	array
=	O
NETRC_DEFAULT	int
;	O
while	O
(	O
keywords	array
[	O
i	array
-	O
1	int
]	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
keywords	array
[	O
i	array
-	O
1	int
]	O
,	O
buffer	pointer
)	O
)	O
return	O
i	array
;	O
i	array
++	O
;	O
}	O
return	O
NETRC_UNKNOWN	int
;	O
}	O
static	O
int	O
ftpfs_netrc_bad_mode	function
(	O
const	O
char	O
*	O
netrcname	pointer
)	O
{	O
static	O
int	O
be_angry	int
=	O
1	int
;	O
struct	O
stat	struct
mystat	struct
;	O
if	O
(	O
stat	struct
(	O
netrcname	pointer
,	O
&	O
mystat	struct
)	O
>=	O
0	int
&&	O
(	O
mystat	struct
.	O
st_mode	int
&	O
077	int
)	O
)	O
{	O
if	O
(	O
be_angry	int
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
"~/.netrc file has incorrect mode.\n"	pointer
"Remove password or correct mode."	pointer
)	O
)	O
;	O
be_angry	int
=	O
0	int
;	O
}	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
ftpfs_find_machine	function
(	O
const	O
char	O
*	O
host	pointer
,	O
const	O
char	O
*	O
domain	int
)	O
{	O
keyword_t	enum
keyword	enum
;	O
while	O
(	O
(	O
keyword	enum
=	O
ftpfs_netrc_next	function
(	O
)	O
)	O
!=	O
NETRC_NONE	int
)	O
{	O
if	O
(	O
keyword	enum
==	O
NETRC_DEFAULT	int
)	O
return	O
0	int
;	O
if	O
(	O
keyword	enum
==	O
NETRC_MACDEF	int
)	O
{	O
do	O
{	O
while	O
(	O
*	O
netrcp	pointer
&&	O
*	O
netrcp	pointer
!=	O
'\n'	O
)	O
netrcp	pointer
++	O
;	O
if	O
(	O
*	O
netrcp	pointer
!=	O
'\n'	O
)	O
break	O
;	O
netrcp	pointer
++	O
;	O
}	O
while	O
(	O
*	O
netrcp	pointer
&&	O
*	O
netrcp	pointer
!=	O
'\n'	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
keyword	enum
!=	O
NETRC_MACHINE	int
)	O
continue	O
;	O
if	O
(	O
ftpfs_netrc_next	function
(	O
)	O
==	O
NETRC_NONE	int
)	O
break	O
;	O
if	O
(	O
g_strcasecmp	function
(	O
host	pointer
,	O
buffer	pointer
)	O
)	O
{	O
const	O
char	O
*	O
host_domain	pointer
=	O
strchr	function
(	O
host	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
!	O
host_domain	pointer
)	O
continue	O
;	O
if	O
(	O
g_strcasecmp	function
(	O
host_domain	pointer
,	O
domain	int
)	O
)	O
continue	O
;	O
if	O
(	O
g_strncasecmp	function
(	O
host	pointer
,	O
buffer	pointer
,	O
host_domain	pointer
-	O
host	pointer
)	O
)	O
continue	O
;	O
}	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
static	O
int	O
ftpfs_netrc_lookup	function
(	O
const	O
char	O
*	O
host	pointer
,	O
char	O
*	O
*	O
login	pointer
,	O
char	O
*	O
*	O
pass	pointer
)	O
{	O
char	O
*	O
netrcname	pointer
;	O
char	O
*	O
tmp_pass	pointer
=	O
NULL	O
;	O
char	O
hostname	pointer
[	O
MAXHOSTNAMELEN	int
]	O
;	O
const	O
char	O
*	O
domain	int
;	O
keyword_t	enum
keyword	enum
;	O
static	O
struct	O
rupcache	struct
{	O
struct	O
rupcache	struct
*	O
next	pointer
;	O
char	O
*	O
host	pointer
;	O
char	O
*	O
login	pointer
;	O
char	O
*	O
pass	pointer
;	O
}	O
*	O
rup_cache	pointer
=	O
NULL	O
,	O
*	O
rupp	pointer
;	O
if	O
(	O
!	O
login	pointer
)	O
return	O
0	int
;	O
*	O
login	pointer
=	O
NULL	O
;	O
if	O
(	O
pass	pointer
)	O
*	O
pass	pointer
=	O
NULL	O
;	O
for	O
(	O
rupp	pointer
=	O
rup_cache	pointer
;	O
rupp	pointer
!=	O
NULL	O
;	O
rupp	pointer
=	O
rupp	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
host	pointer
,	O
rupp	pointer
->	O
host	pointer
)	O
)	O
{	O
if	O
(	O
rupp	pointer
->	O
login	pointer
)	O
*	O
login	pointer
=	O
g_strdup	function
(	O
rupp	pointer
->	O
login	pointer
)	O
;	O
if	O
(	O
pass	pointer
&&	O
rupp	pointer
->	O
pass	pointer
)	O
*	O
pass	pointer
=	O
g_strdup	function
(	O
rupp	pointer
->	O
pass	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
netrcname	pointer
=	O
concat_dir_and_file	function
(	O
home_dir	pointer
,	O
".netrc"	pointer
)	O
;	O
netrcp	pointer
=	O
netrc	pointer
=	O
load_file	function
(	O
netrcname	pointer
)	O
;	O
if	O
(	O
netrc	pointer
==	O
NULL	O
)	O
{	O
g_free	function
(	O
netrcname	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
gethostname	function
(	O
hostname	pointer
,	O
sizeof	O
(	O
hostname	pointer
)	O
)	O
<	O
0	int
)	O
*	O
hostname	pointer
=	O
0	int
;	O
if	O
(	O
!	O
(	O
domain	int
=	O
strchr	function
(	O
hostname	pointer
,	O
'.'	O
)	O
)	O
)	O
domain	int
=	O
""	pointer
;	O
ftpfs_find_machine	function
(	O
host	pointer
,	O
domain	int
)	O
;	O
while	O
(	O
1	int
)	O
{	O
int	O
need_break	int
=	O
0	int
;	O
keyword	enum
=	O
ftpfs_netrc_next	function
(	O
)	O
;	O
switch	O
(	O
keyword	enum
)	O
{	O
case	O
NETRC_LOGIN	int
:	O
if	O
(	O
ftpfs_netrc_next	function
(	O
)	O
==	O
NETRC_NONE	int
)	O
{	O
need_break	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
*	O
login	pointer
)	O
{	O
need_break	int
=	O
1	int
;	O
break	O
;	O
}	O
*	O
login	pointer
=	O
g_strdup	function
(	O
buffer	pointer
)	O
;	O
break	O
;	O
case	O
NETRC_PASSWORD	int
:	O
case	O
NETRC_PASSWD	int
:	O
if	O
(	O
ftpfs_netrc_next	function
(	O
)	O
==	O
NETRC_NONE	int
)	O
{	O
need_break	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
*	O
login	pointer
,	O
"anonymous"	pointer
)	O
&&	O
strcmp	function
(	O
*	O
login	pointer
,	O
"ftp"	pointer
)	O
&&	O
ftpfs_netrc_bad_mode	function
(	O
netrcname	pointer
)	O
)	O
{	O
need_break	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
tmp_pass	pointer
==	O
NULL	O
)	O
tmp_pass	pointer
=	O
g_strdup	function
(	O
buffer	pointer
)	O
;	O
break	O
;	O
case	O
NETRC_ACCOUNT	int
:	O
if	O
(	O
ftpfs_netrc_next	function
(	O
)	O
==	O
NETRC_NONE	int
)	O
{	O
need_break	int
=	O
1	int
;	O
break	O
;	O
}	O
ftpfs_netrc_bad_mode	function
(	O
netrcname	pointer
)	O
;	O
break	O
;	O
default	O
:	O
need_break	int
=	O
1	int
;	O
break	O
;	O
}	O
if	O
(	O
need_break	int
)	O
break	O
;	O
}	O
g_free	function
(	O
netrc	pointer
)	O
;	O
g_free	function
(	O
netrcname	pointer
)	O
;	O
rupp	pointer
=	O
g_new	O
(	O
struct	O
rupcache	struct
,	O
1	int
)	O
;	O
rupp	pointer
->	O
host	pointer
=	O
g_strdup	function
(	O
host	pointer
)	O
;	O
rupp	pointer
->	O
login	pointer
=	O
rupp	pointer
->	O
pass	pointer
=	O
0	int
;	O
if	O
(	O
*	O
login	pointer
!=	O
NULL	O
)	O
{	O
rupp	pointer
->	O
login	pointer
=	O
g_strdup	function
(	O
*	O
login	pointer
)	O
;	O
}	O
if	O
(	O
tmp_pass	pointer
!=	O
NULL	O
)	O
rupp	pointer
->	O
pass	pointer
=	O
g_strdup	function
(	O
tmp_pass	pointer
)	O
;	O
rupp	pointer
->	O
next	pointer
=	O
rup_cache	pointer
;	O
rup_cache	pointer
=	O
rupp	pointer
;	O
if	O
(	O
pass	pointer
)	O
*	O
pass	pointer
=	O
tmp_pass	pointer
;	O
return	O
0	int
;	O
}	O
void	O
init_ftpfs	function
(	O
void	O
)	O
{	O
static	O
struct	O
vfs_s_subclass	struct
ftpfs_subclass	struct
;	O
ftpfs_subclass	struct
.	O
flags	enum
=	O
VFS_S_REMOTE	int
;	O
ftpfs_subclass	struct
.	O
archive_same	pointer
=	O
ftpfs_archive_same	function
;	O
ftpfs_subclass	struct
.	O
open_archive	pointer
=	O
ftpfs_open_archive	function
;	O
ftpfs_subclass	struct
.	O
free_archive	pointer
=	O
ftpfs_free_archive	function
;	O
ftpfs_subclass	struct
.	O
fh_open	pointer
=	O
ftpfs_fh_open	function
;	O
ftpfs_subclass	struct
.	O
fh_close	pointer
=	O
ftpfs_fh_close	function
;	O
ftpfs_subclass	struct
.	O
dir_load	pointer
=	O
ftpfs_dir_load	function
;	O
ftpfs_subclass	struct
.	O
file_store	pointer
=	O
ftpfs_file_store	function
;	O
ftpfs_subclass	struct
.	O
linear_start	pointer
=	O
ftpfs_linear_start	function
;	O
ftpfs_subclass	struct
.	O
linear_read	pointer
=	O
ftpfs_linear_read	function
;	O
ftpfs_subclass	struct
.	O
linear_close	pointer
=	O
ftpfs_linear_close	function
;	O
vfs_s_init_class	function
(	O
&	O
vfs_ftpfs_ops	struct
,	O
&	O
ftpfs_subclass	struct
)	O
;	O
vfs_ftpfs_ops	struct
.	O
name	pointer
=	O
"ftpfs"	pointer
;	O
vfs_ftpfs_ops	struct
.	O
flags	enum
=	O
VFSF_NOLINKS	int
;	O
vfs_ftpfs_ops	struct
.	O
prefix	pointer
=	O
"ftp:"	pointer
;	O
vfs_ftpfs_ops	struct
.	O
done	pointer
=	O
&	O
ftpfs_done	function
;	O
vfs_ftpfs_ops	struct
.	O
fill_names	pointer
=	O
ftpfs_fill_names	function
;	O
vfs_ftpfs_ops	struct
.	O
chmod	function
=	O
ftpfs_chmod	function
;	O
vfs_ftpfs_ops	struct
.	O
chown	function
=	O
ftpfs_chown	function
;	O
vfs_ftpfs_ops	struct
.	O
unlink	function
=	O
ftpfs_unlink	function
;	O
vfs_ftpfs_ops	struct
.	O
rename	function
=	O
ftpfs_rename	function
;	O
vfs_ftpfs_ops	struct
.	O
mkdir	function
=	O
ftpfs_mkdir	function
;	O
vfs_ftpfs_ops	struct
.	O
rmdir	function
=	O
ftpfs_rmdir	function
;	O
vfs_ftpfs_ops	struct
.	O
ctl	pointer
=	O
ftpfs_ctl	function
;	O
vfs_register_class	function
(	O
&	O
vfs_ftpfs_ops	struct
)	O
;	O
}	O
