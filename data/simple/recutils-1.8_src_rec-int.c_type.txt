static	O
int	O
rec_int_check_descriptor	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
int	O
rec_int_check_record_key	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
orig_record	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
int	O
rec_int_check_record_types	function
(	O
rec_db_t	pointer
db	pointer
,	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
int	O
rec_int_check_record_mandatory	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
int	O
rec_int_check_record_unique	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
int	O
rec_int_check_record_prohibit	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
int	O
rec_int_check_record_sex_constraints	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
int	O
rec_int_check_record_allowed	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
int	O
rec_int_merge_remote	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
;	O
static	O
bool	bool
rec_int_rec_type_p	function
(	O
const	O
char	O
*	O
str	pointer
)	O
;	O
int	O
rec_int_check_db	function
(	O
rec_db_t	pointer
db	pointer
,	O
bool	bool
check_descriptors_p	bool
,	O
bool	bool
remote_descriptors_p	bool
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
int	O
ret	int
;	O
size_t	long
db_size	long
;	O
size_t	long
n_rset	long
;	O
rec_rset_t	pointer
rset	pointer
;	O
ret	int
=	O
0	int
;	O
db_size	long
=	O
rec_db_size	function
(	O
db	pointer
)	O
;	O
for	O
(	O
n_rset	long
=	O
0	int
;	O
n_rset	long
<	O
db_size	long
;	O
n_rset	long
++	O
)	O
{	O
rset	pointer
=	O
rec_db_get_rset	function
(	O
db	pointer
,	O
n_rset	long
)	O
;	O
ret	int
=	O
ret	int
+	O
rec_int_check_rset	function
(	O
db	pointer
,	O
rset	pointer
,	O
check_descriptors_p	bool
,	O
remote_descriptors_p	bool
,	O
errors	pointer
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
int	O
rec_int_check_rset	function
(	O
rec_db_t	pointer
db	pointer
,	O
rec_rset_t	pointer
rset	pointer
,	O
bool	bool
check_descriptor_p	bool
,	O
bool	bool
remote_descriptor_p	bool
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
int	O
res	int
;	O
rec_mset_iterator_t	struct
iter	struct
;	O
rec_record_t	pointer
record	pointer
;	O
rec_record_t	pointer
descriptor	pointer
;	O
size_t	long
num_records	long
,	O
min_records	long
,	O
max_records	long
;	O
res	int
=	O
0	int
;	O
if	O
(	O
remote_descriptor_p	bool
&&	O
(	O
descriptor	pointer
=	O
rec_rset_descriptor	function
(	O
rset	pointer
)	O
)	O
)	O
{	O
descriptor	pointer
=	O
rec_record_dup	function
(	O
descriptor	pointer
)	O
;	O
res	int
=	O
rec_int_merge_remote	function
(	O
rset	pointer
,	O
errors	pointer
)	O
;	O
if	O
(	O
res	int
>	O
0	int
)	O
{	O
return	O
res	int
;	O
}	O
}	O
if	O
(	O
check_descriptor_p	bool
)	O
{	O
res	int
+=	O
rec_int_check_descriptor	function
(	O
rset	pointer
,	O
errors	pointer
)	O
;	O
}	O
if	O
(	O
res	int
>	O
0	int
)	O
{	O
return	O
res	int
;	O
}	O
num_records	long
=	O
rec_rset_num_records	function
(	O
rset	pointer
)	O
;	O
min_records	long
=	O
rec_rset_min_records	function
(	O
rset	pointer
)	O
;	O
max_records	long
=	O
rec_rset_max_records	function
(	O
rset	pointer
)	O
;	O
if	O
(	O
min_records	long
==	O
max_records	long
)	O
{	O
if	O
(	O
num_records	long
!=	O
min_records	long
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s: error: the number of records of type %s should be %zd.\n"	pointer
)	O
,	O
rec_rset_source	function
(	O
rset	pointer
)	O
,	O
rec_rset_type	function
(	O
rset	pointer
)	O
,	O
min_records	long
)	O
;	O
res	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
num_records	long
>	O
rec_rset_max_records	function
(	O
rset	pointer
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s: error: too many records of type %s. Maximum allowed are %zd.\n"	pointer
)	O
,	O
rec_rset_source	function
(	O
rset	pointer
)	O
,	O
rec_rset_type	function
(	O
rset	pointer
)	O
,	O
rec_rset_max_records	function
(	O
rset	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
if	O
(	O
num_records	long
<	O
rec_rset_min_records	function
(	O
rset	pointer
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s: error: too few records of type %s. Minimum allowed are %zd.\n"	pointer
)	O
,	O
rec_rset_source	function
(	O
rset	pointer
)	O
,	O
rec_rset_type	function
(	O
rset	pointer
)	O
,	O
rec_rset_min_records	function
(	O
rset	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
}	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_rset_mset	function
(	O
rset	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_RECORD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
record	pointer
,	O
NULL	O
)	O
)	O
{	O
res	int
+=	O
rec_int_check_record	function
(	O
db	pointer
,	O
rset	pointer
,	O
record	pointer
,	O
record	pointer
,	O
errors	pointer
)	O
;	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
if	O
(	O
remote_descriptor_p	bool
)	O
{	O
rec_rset_set_descriptor	function
(	O
rset	pointer
,	O
descriptor	pointer
)	O
;	O
}	O
return	O
res	int
;	O
}	O
int	O
rec_int_check_record	function
(	O
rec_db_t	pointer
db	pointer
,	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
orig_record	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
int	O
res	int
;	O
res	int
=	O
rec_int_check_record_key	function
(	O
rset	pointer
,	O
orig_record	pointer
,	O
record	pointer
,	O
errors	pointer
)	O
+	O
rec_int_check_record_types	function
(	O
db	pointer
,	O
rset	pointer
,	O
record	pointer
,	O
errors	pointer
)	O
+	O
rec_int_check_record_mandatory	function
(	O
rset	pointer
,	O
record	pointer
,	O
errors	pointer
)	O
+	O
rec_int_check_record_unique	function
(	O
rset	pointer
,	O
record	pointer
,	O
errors	pointer
)	O
+	O
rec_int_check_record_prohibit	function
(	O
rset	pointer
,	O
record	pointer
,	O
errors	pointer
)	O
+	O
rec_int_check_record_sex_constraints	function
(	O
rset	pointer
,	O
record	pointer
,	O
errors	pointer
)	O
+	O
rec_int_check_record_allowed	function
(	O
rset	pointer
,	O
record	pointer
,	O
errors	pointer
)	O
;	O
return	O
res	int
;	O
}	O
bool	bool
rec_int_check_field_type	function
(	O
rec_db_t	pointer
db	pointer
,	O
rec_rset_t	pointer
rset	pointer
,	O
rec_field_t	pointer
field	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
bool	bool
res	int
=	O
true	int
;	O
rec_type_t	pointer
type	enum
;	O
char	O
*	O
errors_str	pointer
;	O
res	int
=	O
true	int
;	O
type	enum
=	O
rec_rset_get_field_type	function
(	O
rset	pointer
,	O
rec_field_name	function
(	O
field	pointer
)	O
)	O
;	O
if	O
(	O
type	enum
)	O
{	O
if	O
(	O
rec_type_kind	function
(	O
type	enum
)	O
==	O
REC_TYPE_REC	int
)	O
{	O
const	O
char	O
*	O
rset_type	pointer
=	O
rec_type_rec	function
(	O
type	enum
)	O
;	O
rec_rset_t	pointer
rset	pointer
=	O
rec_db_get_rset_by_type	function
(	O
db	pointer
,	O
rset_type	pointer
)	O
;	O
if	O
(	O
rset	pointer
)	O
{	O
const	O
char	O
*	O
key	pointer
=	O
rec_rset_key	function
(	O
rset	pointer
)	O
;	O
rec_type_t	pointer
key_type	pointer
=	O
rec_rset_get_field_type	function
(	O
rset	pointer
,	O
key	pointer
)	O
;	O
if	O
(	O
key_type	pointer
)	O
{	O
if	O
(	O
!	O
rec_type_check	function
(	O
key_type	pointer
,	O
rec_field_value	function
(	O
field	pointer
)	O
,	O
&	O
errors_str	pointer
)	O
)	O
{	O
if	O
(	O
errors	pointer
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
"%s:%s: error: %s\n"	pointer
,	O
rec_field_source	function
(	O
field	pointer
)	O
,	O
rec_field_location_str	function
(	O
field	pointer
)	O
,	O
errors_str	pointer
)	O
;	O
}	O
free	function
(	O
errors_str	pointer
)	O
;	O
res	int
=	O
false	int
;	O
}	O
}	O
}	O
}	O
else	O
{	O
if	O
(	O
!	O
rec_type_check	function
(	O
type	enum
,	O
rec_field_value	function
(	O
field	pointer
)	O
,	O
&	O
errors_str	pointer
)	O
)	O
{	O
if	O
(	O
errors	pointer
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
"%s:%s: error: %s\n"	pointer
,	O
rec_field_source	function
(	O
field	pointer
)	O
,	O
rec_field_location_str	function
(	O
field	pointer
)	O
,	O
errors_str	pointer
)	O
;	O
}	O
free	function
(	O
errors_str	pointer
)	O
;	O
res	int
=	O
false	int
;	O
}	O
}	O
}	O
return	O
res	int
;	O
}	O
static	O
rec_fex_t	pointer
rec_int_collect_field_list	function
(	O
rec_record_t	pointer
record	pointer
,	O
const	O
char	O
*	O
fname	pointer
)	O
{	O
size_t	long
i	long
,	O
j	long
=	O
0	int
;	O
size_t	long
num_fields	long
=	O
rec_record_get_num_fields_by_name	function
(	O
record	pointer
,	O
fname	pointer
)	O
;	O
rec_fex_t	pointer
res	int
=	O
rec_fex_new	function
(	O
NULL	O
,	O
REC_FEX_SIMPLE	int
)	O
;	O
if	O
(	O
!	O
res	int
)	O
return	O
NULL	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_fields	long
;	O
i	long
++	O
)	O
{	O
rec_field_t	pointer
field	pointer
=	O
rec_record_get_field_by_name	function
(	O
record	pointer
,	O
fname	pointer
,	O
i	long
)	O
;	O
rec_fex_t	pointer
fex	pointer
=	O
rec_fex_new	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
,	O
REC_FEX_SIMPLE	int
)	O
;	O
if	O
(	O
!	O
fex	pointer
)	O
continue	O
;	O
for	O
(	O
j	long
=	O
0	int
;	O
j	long
<	O
rec_fex_size	function
(	O
fex	pointer
)	O
;	O
j	long
++	O
)	O
{	O
rec_fex_elem_t	pointer
elem	pointer
=	O
rec_fex_get	function
(	O
fex	pointer
,	O
j	long
)	O
;	O
char	O
*	O
field_name	pointer
=	O
strdup	function
(	O
rec_fex_elem_field_name	function
(	O
elem	pointer
)	O
)	O
;	O
if	O
(	O
!	O
field_name	pointer
||	O
!	O
rec_fex_append	function
(	O
res	int
,	O
field_name	pointer
,	O
rec_fex_elem_min	function
(	O
elem	pointer
)	O
,	O
rec_fex_elem_max	function
(	O
elem	pointer
)	O
)	O
)	O
return	O
NULL	O
;	O
}	O
rec_fex_destroy	function
(	O
fex	pointer
)	O
;	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_types	function
(	O
rec_db_t	pointer
db	pointer
,	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
int	O
res	int
;	O
rec_field_t	pointer
field	pointer
;	O
rec_mset_iterator_t	struct
iter	struct
;	O
res	int
=	O
0	int
;	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_record_mset	function
(	O
record	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_FIELD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
field	pointer
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
rec_int_check_field_type	function
(	O
db	pointer
,	O
rset	pointer
,	O
field	pointer
,	O
errors	pointer
)	O
)	O
{	O
res	int
++	O
;	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_mandatory	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
rec_fex_t	pointer
fex_mandatory	pointer
=	O
NULL	O
;	O
int	O
res	int
=	O
0	int
;	O
size_t	long
i	long
;	O
rec_record_t	pointer
descriptor	pointer
=	O
rec_rset_descriptor	function
(	O
rset	pointer
)	O
;	O
if	O
(	O
descriptor	pointer
)	O
{	O
fex_mandatory	pointer
=	O
rec_int_collect_field_list	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_MANDATORY	int
)	O
)	O
;	O
if	O
(	O
!	O
fex_mandatory	pointer
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"out of memory\n"	pointer
)	O
,	O
""	pointer
)	O
;	O
res	int
=	O
1	int
;	O
goto	O
cleanup	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_fex_size	function
(	O
fex_mandatory	pointer
)	O
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
fname	pointer
=	O
rec_fex_elem_field_name	function
(	O
rec_fex_get	function
(	O
fex_mandatory	pointer
,	O
i	long
)	O
)	O
;	O
if	O
(	O
rec_record_get_num_fields_by_name	function
(	O
record	pointer
,	O
fname	pointer
)	O
==	O
0	int
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: mandatory field '%s' not found in record\n"	pointer
)	O
,	O
rec_record_source	function
(	O
record	pointer
)	O
,	O
rec_record_location_str	function
(	O
record	pointer
)	O
,	O
fname	pointer
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
cleanup	O
:	O
rec_fex_destroy	function
(	O
fex_mandatory	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_allowed	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
rec_fex_t	pointer
fex_allowed	pointer
=	O
NULL	O
;	O
rec_fex_t	pointer
fex_mandatory	pointer
=	O
NULL	O
;	O
rec_fex_t	pointer
fex_key	pointer
=	O
NULL	O
;	O
int	O
res	int
=	O
0	int
;	O
rec_record_t	pointer
descriptor	pointer
=	O
rec_rset_descriptor	function
(	O
rset	pointer
)	O
;	O
if	O
(	O
descriptor	pointer
)	O
{	O
fex_allowed	pointer
=	O
rec_int_collect_field_list	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_ALLOWED	int
)	O
)	O
;	O
fex_mandatory	pointer
=	O
rec_int_collect_field_list	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_MANDATORY	int
)	O
)	O
;	O
fex_key	pointer
=	O
rec_int_collect_field_list	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_KEY	int
)	O
)	O
;	O
if	O
(	O
!	O
fex_allowed	pointer
||	O
!	O
fex_mandatory	pointer
||	O
!	O
fex_key	pointer
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"out of memory\n"	pointer
)	O
,	O
""	pointer
)	O
;	O
res	int
=	O
1	int
;	O
goto	O
cleanup	O
;	O
}	O
if	O
(	O
rec_fex_size	function
(	O
fex_allowed	pointer
)	O
==	O
0	int
)	O
goto	O
cleanup	O
;	O
rec_field_t	pointer
field	pointer
=	O
NULL	O
;	O
rec_mset_iterator_t	struct
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_record_mset	function
(	O
record	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_FIELD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
field	pointer
,	O
NULL	O
)	O
)	O
{	O
const	O
char	O
*	O
field_name	pointer
=	O
rec_field_name	function
(	O
field	pointer
)	O
;	O
if	O
(	O
!	O
(	O
rec_fex_member_p	function
(	O
fex_allowed	pointer
,	O
field_name	pointer
,	O
-	O
1	int
,	O
-	O
1	int
)	O
||	O
rec_fex_member_p	function
(	O
fex_mandatory	pointer
,	O
field_name	pointer
,	O
-	O
1	int
,	O
-	O
1	int
)	O
||	O
rec_fex_member_p	function
(	O
fex_key	pointer
,	O
field_name	pointer
,	O
-	O
1	int
,	O
-	O
1	int
)	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: field '%s' not allowed in this record set\n"	pointer
)	O
,	O
rec_record_source	function
(	O
record	pointer
)	O
,	O
rec_record_location_str	function
(	O
record	pointer
)	O
,	O
field_name	pointer
)	O
;	O
res	int
++	O
;	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
cleanup	O
:	O
rec_fex_destroy	function
(	O
fex_allowed	pointer
)	O
;	O
rec_fex_destroy	function
(	O
fex_mandatory	pointer
)	O
;	O
rec_fex_destroy	function
(	O
fex_key	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_unique	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
rec_fex_t	pointer
fex_unique	pointer
=	O
NULL	O
;	O
int	O
res	int
=	O
0	int
;	O
size_t	long
i	long
;	O
rec_record_t	pointer
descriptor	pointer
=	O
rec_rset_descriptor	function
(	O
rset	pointer
)	O
;	O
if	O
(	O
descriptor	pointer
)	O
{	O
fex_unique	pointer
=	O
rec_int_collect_field_list	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_UNIQUE	int
)	O
)	O
;	O
if	O
(	O
!	O
fex_unique	pointer
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"out of memory\n"	pointer
)	O
,	O
""	pointer
)	O
;	O
res	int
=	O
1	int
;	O
goto	O
cleanup	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_fex_size	function
(	O
fex_unique	pointer
)	O
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
fname	pointer
=	O
rec_fex_elem_field_name	function
(	O
rec_fex_get	function
(	O
fex_unique	pointer
,	O
i	long
)	O
)	O
;	O
if	O
(	O
rec_record_get_num_fields_by_name	function
(	O
record	pointer
,	O
fname	pointer
)	O
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: field '%s' should be unique in this record\n"	pointer
)	O
,	O
rec_record_source	function
(	O
record	pointer
)	O
,	O
rec_record_location_str	function
(	O
record	pointer
)	O
,	O
fname	pointer
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
cleanup	O
:	O
rec_fex_destroy	function
(	O
fex_unique	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_prohibit	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
rec_fex_t	pointer
fex_prohibit	pointer
=	O
NULL	O
;	O
int	O
res	int
=	O
0	int
;	O
size_t	long
i	long
;	O
rec_record_t	pointer
descriptor	pointer
=	O
rec_rset_descriptor	function
(	O
rset	pointer
)	O
;	O
if	O
(	O
descriptor	pointer
)	O
{	O
fex_prohibit	pointer
=	O
rec_int_collect_field_list	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_PROHIBIT	int
)	O
)	O
;	O
if	O
(	O
!	O
fex_prohibit	pointer
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"out of memory\n"	pointer
)	O
,	O
""	pointer
)	O
;	O
res	int
=	O
1	int
;	O
goto	O
cleanup	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_fex_size	function
(	O
fex_prohibit	pointer
)	O
;	O
i	long
++	O
)	O
{	O
const	O
char	O
*	O
fname	pointer
=	O
rec_fex_elem_field_name	function
(	O
rec_fex_get	function
(	O
fex_prohibit	pointer
,	O
i	long
)	O
)	O
;	O
if	O
(	O
rec_record_get_num_fields_by_name	function
(	O
record	pointer
,	O
fname	pointer
)	O
>	O
0	int
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: prohibited field '%s' found in record\n"	pointer
)	O
,	O
rec_record_source	function
(	O
record	pointer
)	O
,	O
rec_record_location_str	function
(	O
record	pointer
)	O
,	O
fname	pointer
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
cleanup	O
:	O
rec_fex_destroy	function
(	O
fex_prohibit	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_sex_constraints	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
int	O
res	int
=	O
0	int
;	O
size_t	long
i	long
=	O
0	int
;	O
size_t	long
num_constraints	long
=	O
rec_rset_num_sex_constraints	function
(	O
rset	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
num_constraints	long
;	O
i	long
++	O
)	O
{	O
bool	bool
status	pointer
=	O
false	int
;	O
rec_sex_t	pointer
sex	pointer
=	O
rec_rset_sex_constraint	function
(	O
rset	pointer
,	O
i	long
)	O
;	O
if	O
(	O
!	O
rec_sex_eval	function
(	O
sex	pointer
,	O
record	pointer
,	O
&	O
status	pointer
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: %%constraint[%d] violated in record\n"	pointer
)	O
,	O
rec_record_source	function
(	O
record	pointer
)	O
,	O
rec_record_location_str	function
(	O
record	pointer
)	O
,	O
i	long
)	O
;	O
res	int
++	O
;	O
}	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_record_key	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_record_t	pointer
orig_record	pointer
,	O
rec_record_t	pointer
record	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
int	O
res	int
;	O
rec_record_t	pointer
descriptor	pointer
;	O
rec_record_t	pointer
other_record	pointer
;	O
rec_mset_iterator_t	struct
iter	struct
;	O
char	O
*	O
key_field_name	pointer
;	O
rec_field_t	pointer
field	pointer
;	O
rec_field_t	pointer
key	pointer
;	O
rec_field_t	pointer
other_key	pointer
;	O
bool	bool
duplicated_key	bool
;	O
size_t	long
i	long
;	O
size_t	long
num_fields	long
;	O
res	int
=	O
0	int
;	O
descriptor	pointer
=	O
rec_rset_descriptor	function
(	O
rset	pointer
)	O
;	O
if	O
(	O
descriptor	pointer
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_record_get_num_fields_by_name	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_KEY	int
)	O
)	O
;	O
i	long
++	O
)	O
{	O
field	pointer
=	O
rec_record_get_field_by_name	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_KEY	int
)	O
,	O
i	long
)	O
;	O
key_field_name	pointer
=	O
rec_parse_field_name_str	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
;	O
if	O
(	O
key_field_name	pointer
)	O
{	O
num_fields	long
=	O
rec_record_get_num_fields_by_name	function
(	O
record	pointer
,	O
key_field_name	pointer
)	O
;	O
if	O
(	O
num_fields	long
==	O
0	int
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: key field '%s' not found in record\n"	pointer
)	O
,	O
rec_record_source	function
(	O
record	pointer
)	O
,	O
rec_record_location_str	function
(	O
record	pointer
)	O
,	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
else	O
if	O
(	O
num_fields	long
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: multiple key fields '%s' in record\n"	pointer
)	O
,	O
rec_record_source	function
(	O
record	pointer
)	O
,	O
rec_record_location_str	function
(	O
record	pointer
)	O
,	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
else	O
{	O
key	pointer
=	O
rec_record_get_field_by_name	function
(	O
record	pointer
,	O
key_field_name	pointer
,	O
0	int
)	O
;	O
duplicated_key	bool
=	O
false	int
;	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_rset_mset	function
(	O
rset	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_RECORD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
other_record	pointer
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
other_record	pointer
!=	O
orig_record	pointer
)	O
{	O
other_key	pointer
=	O
rec_record_get_field_by_name	function
(	O
other_record	pointer
,	O
key_field_name	pointer
,	O
0	int
)	O
;	O
if	O
(	O
other_key	pointer
)	O
{	O
if	O
(	O
strcmp	function
(	O
rec_field_value	function
(	O
other_key	pointer
)	O
,	O
rec_field_value	function
(	O
key	pointer
)	O
)	O
==	O
0	int
)	O
{	O
duplicated_key	bool
=	O
true	int
;	O
break	O
;	O
}	O
}	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
if	O
(	O
duplicated_key	bool
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: duplicated key value in field '%s' in record\n"	pointer
)	O
,	O
rec_record_source	function
(	O
orig_record	pointer
)	O
,	O
rec_record_location_str	function
(	O
orig_record	pointer
)	O
,	O
rec_field_name	function
(	O
key	pointer
)	O
)	O
;	O
res	int
++	O
;	O
break	O
;	O
}	O
}	O
free	function
(	O
key_field_name	pointer
)	O
;	O
}	O
}	O
}	O
return	O
res	int
;	O
}	O
static	O
int	O
rec_int_check_descriptor	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
int	O
res	int
;	O
rec_record_t	pointer
descriptor	pointer
;	O
rec_mset_iterator_t	struct
iter	struct
;	O
rec_field_t	pointer
field	pointer
;	O
const	O
char	O
*	O
field_name	pointer
;	O
const	O
char	O
*	O
field_value	pointer
;	O
rec_fex_t	pointer
fex	pointer
;	O
const	O
char	O
*	O
auto_field_name	pointer
;	O
size_t	long
i	long
;	O
rec_type_t	pointer
type	enum
;	O
char	O
*	O
type_name	pointer
=	O
NULL	O
;	O
const	O
char	O
*	O
p	pointer
,	O
*	O
q	pointer
=	O
NULL	O
;	O
res	int
=	O
0	int
;	O
descriptor	pointer
=	O
rec_rset_descriptor	function
(	O
rset	pointer
)	O
;	O
if	O
(	O
descriptor	pointer
)	O
{	O
if	O
(	O
rec_record_get_num_fields_by_name	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
)	O
==	O
0	int
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: missing %%rec field in record descriptor\n"	pointer
)	O
,	O
rec_record_source	function
(	O
descriptor	pointer
)	O
,	O
rec_record_location_str	function
(	O
descriptor	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
else	O
if	O
(	O
rec_record_get_num_fields_by_name	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
)	O
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: too many %%rec fields in record descriptor\n"	pointer
)	O
,	O
rec_record_source	function
(	O
descriptor	pointer
)	O
,	O
rec_record_location_str	function
(	O
descriptor	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
field	pointer
=	O
rec_record_get_field_by_name	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
rec_int_rec_type_p	function
(	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: invalid record type %s\n"	pointer
)	O
,	O
rec_field_source	function
(	O
field	pointer
)	O
,	O
rec_field_location_str	function
(	O
field	pointer
)	O
,	O
rec_field_value	function
(	O
field	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
if	O
(	O
rec_record_get_num_fields_by_name	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_KEY	int
)	O
)	O
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: only one %%key field is allowed in a record descriptor\n"	pointer
)	O
,	O
rec_record_source	function
(	O
descriptor	pointer
)	O
,	O
rec_record_location_str	function
(	O
descriptor	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
if	O
(	O
rec_record_get_num_fields_by_name	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_SIZE	int
)	O
)	O
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: only one %%size field is allowed in a record descriptor\n"	pointer
)	O
,	O
rec_record_source	function
(	O
descriptor	pointer
)	O
,	O
rec_record_location_str	function
(	O
descriptor	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
if	O
(	O
rec_record_get_num_fields_by_name	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_SORT	int
)	O
)	O
>	O
1	int
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: only one %%sort field is allowed in a record descriptor\n"	pointer
)	O
,	O
rec_record_source	function
(	O
descriptor	pointer
)	O
,	O
rec_record_location_str	function
(	O
descriptor	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_record_mset	function
(	O
descriptor	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_FIELD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
field	pointer
,	O
NULL	O
)	O
)	O
{	O
field_name	pointer
=	O
rec_field_name	function
(	O
field	pointer
)	O
;	O
field_value	pointer
=	O
rec_field_value	function
(	O
field	pointer
)	O
;	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_TYPE	int
)	O
)	O
)	O
{	O
p	pointer
=	O
field_value	pointer
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_FNAME_RE	pointer
"(,"	pointer
REC_FNAME_RE	pointer
")*"	pointer
,	O
NULL	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: expected a comma-separated list of fields before the type specification\n"	pointer
)	O
,	O
rec_field_source	function
(	O
field	pointer
)	O
,	O
rec_field_location_str	function
(	O
field	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
rec_type_descr_p	function
(	O
p	pointer
)	O
)	O
{	O
q	pointer
=	O
p	pointer
;	O
if	O
(	O
rec_parse_regexp	function
(	O
&	O
q	pointer
,	O
"^"	pointer
REC_TYPE_NAME_RE	pointer
"[ \t\n]*$"	pointer
,	O
NULL	O
)	O
)	O
{	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_TYPE_NAME_RE	pointer
,	O
&	O
type_name	pointer
)	O
;	O
if	O
(	O
!	O
rec_type_reg_get	function
(	O
rec_rset_get_type_reg	function
(	O
rset	pointer
)	O
,	O
type_name	pointer
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: the referred type %s does not exist\n"	pointer
)	O
,	O
rec_field_source	function
(	O
field	pointer
)	O
,	O
rec_field_location_str	function
(	O
field	pointer
)	O
,	O
type_name	pointer
)	O
;	O
res	int
++	O
;	O
}	O
}	O
else	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: invalid type specification\n"	pointer
)	O
,	O
rec_field_source	function
(	O
field	pointer
)	O
,	O
rec_field_location_str	function
(	O
field	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_TYPEDEF	int
)	O
)	O
)	O
{	O
p	pointer
=	O
field_value	pointer
;	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_TYPE_NAME_RE	pointer
,	O
NULL	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: expected a type name before the type specification\n"	pointer
)	O
,	O
rec_field_source	function
(	O
field	pointer
)	O
,	O
rec_field_location_str	function
(	O
field	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
rec_skip_blanks	function
(	O
&	O
p	pointer
)	O
;	O
if	O
(	O
!	O
rec_type_descr_p	function
(	O
p	pointer
)	O
)	O
{	O
q	pointer
=	O
p	pointer
;	O
if	O
(	O
rec_parse_regexp	function
(	O
&	O
q	pointer
,	O
"^"	pointer
REC_TYPE_NAME_RE	pointer
"[ \t\n]*$"	pointer
,	O
NULL	O
)	O
)	O
{	O
rec_parse_regexp	function
(	O
&	O
p	pointer
,	O
"^"	pointer
REC_TYPE_NAME_RE	pointer
,	O
&	O
type_name	pointer
)	O
;	O
if	O
(	O
!	O
rec_type_reg_get	function
(	O
rec_rset_get_type_reg	function
(	O
rset	pointer
)	O
,	O
type_name	pointer
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: the referred type %s does not exist\n"	pointer
)	O
,	O
rec_field_source	function
(	O
field	pointer
)	O
,	O
rec_field_location_str	function
(	O
field	pointer
)	O
,	O
type_name	pointer
)	O
;	O
res	int
++	O
;	O
}	O
}	O
else	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: invalid typedef specification\n"	pointer
)	O
,	O
rec_field_source	function
(	O
field	pointer
)	O
,	O
rec_field_location_str	function
(	O
field	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
else	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_CONSTRAINT	int
)	O
)	O
)	O
{	O
rec_sex_t	pointer
sex	pointer
=	O
rec_sex_new	function
(	O
false	int
)	O
;	O
if	O
(	O
sex	pointer
)	O
{	O
if	O
(	O
rec_sex_compile	function
(	O
sex	pointer
,	O
field_value	pointer
)	O
)	O
{	O
rec_sex_destroy	function
(	O
sex	pointer
)	O
;	O
}	O
else	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: value for %s[%zd] is not a valid selection expression\n"	pointer
)	O
,	O
rec_record_source	function
(	O
descriptor	pointer
)	O
,	O
rec_record_location_str	function
(	O
descriptor	pointer
)	O
,	O
rec_field_name	function
(	O
field	pointer
)	O
,	O
rec_record_get_field_index_by_name	function
(	O
descriptor	pointer
,	O
field	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
}	O
else	O
{	O
res	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_MANDATORY	int
)	O
)	O
||	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_UNIQUE	int
)	O
)	O
||	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_PROHIBIT	int
)	O
)	O
||	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_AUTO	int
)	O
)	O
||	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_SORT	int
)	O
)	O
||	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_ALLOWED	int
)	O
)	O
)	O
{	O
fex	pointer
=	O
rec_fex_new	function
(	O
field_value	pointer
,	O
REC_FEX_SIMPLE	int
)	O
;	O
if	O
(	O
fex	pointer
)	O
{	O
rec_fex_destroy	function
(	O
fex	pointer
)	O
;	O
}	O
else	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: value for %s[%zd] is not a list of field names\n"	pointer
)	O
,	O
rec_record_source	function
(	O
descriptor	pointer
)	O
,	O
rec_record_location_str	function
(	O
descriptor	pointer
)	O
,	O
rec_field_name	function
(	O
field	pointer
)	O
,	O
rec_record_get_field_index_by_name	function
(	O
descriptor	pointer
,	O
field	pointer
)	O
)	O
;	O
res	int
++	O
;	O
}	O
}	O
else	O
if	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_SIZE	int
)	O
)	O
)	O
{	O
if	O
(	O
!	O
rec_match	function
(	O
field_value	pointer
,	O
REC_INT_SIZE_RE	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: value for %s should be a number optionally preceded by >, <, >= or <=.\n"	pointer
)	O
,	O
rec_field_source	function
(	O
field	pointer
)	O
,	O
rec_field_location_str	function
(	O
field	pointer
)	O
,	O
field_name	pointer
)	O
;	O
res	int
++	O
;	O
}	O
}	O
if	O
(	O
(	O
rec_field_name_equal_p	function
(	O
field_name	pointer
,	O
FNAME	O
(	O
REC_FIELD_AUTO	int
)	O
)	O
)	O
&&	O
(	O
fex	pointer
=	O
rec_fex_new	function
(	O
field_value	pointer
,	O
REC_FEX_SIMPLE	int
)	O
)	O
)	O
{	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
rec_fex_size	function
(	O
fex	pointer
)	O
;	O
i	long
++	O
)	O
{	O
auto_field_name	pointer
=	O
rec_fex_elem_field_name	function
(	O
rec_fex_get	function
(	O
fex	pointer
,	O
i	long
)	O
)	O
;	O
type	enum
=	O
rec_rset_get_field_type	function
(	O
rset	pointer
,	O
auto_field_name	pointer
)	O
;	O
if	O
(	O
(	O
!	O
type	enum
)	O
||	O
!	O
(	O
(	O
rec_type_kind	function
(	O
type	enum
)	O
==	O
REC_TYPE_INT	int
)	O
||	O
(	O
rec_type_kind	function
(	O
type	enum
)	O
==	O
REC_TYPE_RANGE	int
)	O
||	O
(	O
rec_type_kind	function
(	O
type	enum
)	O
==	O
REC_TYPE_UUID	int
)	O
||	O
(	O
rec_type_kind	function
(	O
type	enum
)	O
==	O
REC_TYPE_DATE	int
)	O
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: auto-incremented field %s should be of type int, range, uuid or date\n"	pointer
)	O
,	O
rec_record_source	function
(	O
descriptor	pointer
)	O
,	O
rec_record_location_str	function
(	O
descriptor	pointer
)	O
,	O
auto_field_name	pointer
)	O
;	O
res	int
++	O
;	O
}	O
}	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
}	O
return	O
res	int
;	O
}	O
int	O
rec_int_merge_remote	function
(	O
rec_rset_t	pointer
rset	pointer
,	O
rec_buf_t	pointer
errors	pointer
)	O
{	O
int	O
res	int
;	O
rec_parser_t	pointer
parser	pointer
;	O
rec_record_t	pointer
descriptor	pointer
;	O
rec_db_t	pointer
remote_db	pointer
;	O
rec_rset_t	pointer
remote_rset	pointer
;	O
rec_field_t	pointer
remote_field	pointer
;	O
rec_mset_iterator_t	struct
iter	struct
;	O
rec_record_t	pointer
remote_descriptor	pointer
;	O
rec_field_t	pointer
rec_field	pointer
;	O
char	O
*	O
rec_type	pointer
;	O
char	O
*	O
rec_url	pointer
=	O
NULL	O
;	O
char	O
*	O
rec_file	pointer
=	O
NULL	O
;	O
char	O
*	O
rec_source	pointer
=	O
NULL	O
;	O
FILE	struct
*	O
external_file	pointer
;	O
char	O
tmpfile_name	array
[	O
14	int
]	O
;	O
res	int
=	O
0	int
;	O
tmpfile_name	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
descriptor	pointer
=	O
rec_rset_descriptor	function
(	O
rset	pointer
)	O
;	O
if	O
(	O
descriptor	pointer
)	O
{	O
rec_field	pointer
=	O
rec_record_get_field_by_name	function
(	O
descriptor	pointer
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
,	O
0	int
)	O
;	O
if	O
(	O
!	O
rec_int_rec_type_p	function
(	O
rec_field_value	function
(	O
rec_field	pointer
)	O
)	O
)	O
{	O
return	O
0	int
;	O
}	O
rec_type	pointer
=	O
rec_extract_type	function
(	O
rec_field_value	function
(	O
rec_field	pointer
)	O
)	O
;	O
rec_file	pointer
=	O
rec_extract_file	function
(	O
rec_field_value	function
(	O
rec_field	pointer
)	O
)	O
;	O
rec_url	pointer
=	O
rec_extract_url	function
(	O
rec_field_value	function
(	O
rec_field	pointer
)	O
)	O
;	O
if	O
(	O
rec_file	pointer
||	O
rec_url	pointer
)	O
{	O
if	O
(	O
rec_url	pointer
)	O
{	O
goto	O
exit	function
;	O
}	O
else	O
{	O
external_file	pointer
=	O
fopen	function
(	O
rec_file	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
!	O
external_file	pointer
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: could not read external descriptor from file %s.\n"	pointer
)	O
,	O
rec_field_source	function
(	O
rec_field	pointer
)	O
,	O
rec_field_location_str	function
(	O
rec_field	pointer
)	O
,	O
rec_file	pointer
)	O
;	O
res	int
++	O
;	O
goto	O
exit	function
;	O
}	O
rec_source	pointer
=	O
rec_file	pointer
;	O
}	O
fseek	function
(	O
external_file	pointer
,	O
0	int
,	O
SEEK_SET	int
)	O
;	O
parser	pointer
=	O
rec_parser_new	function
(	O
external_file	pointer
,	O
rec_source	pointer
)	O
;	O
if	O
(	O
!	O
rec_parse_db	function
(	O
parser	pointer
,	O
&	O
remote_db	pointer
)	O
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: %s does not contain valid rec data.\n"	pointer
)	O
,	O
rec_field_source	function
(	O
rec_field	pointer
)	O
,	O
rec_field_location_str	function
(	O
rec_field	pointer
)	O
,	O
rec_source	pointer
)	O
;	O
res	int
++	O
;	O
goto	O
exit	function
;	O
}	O
rec_parser_destroy	function
(	O
parser	pointer
)	O
;	O
remote_rset	pointer
=	O
rec_db_get_rset_by_type	function
(	O
remote_db	pointer
,	O
rec_type	pointer
)	O
;	O
if	O
(	O
!	O
remote_rset	pointer
)	O
{	O
ADD_ERROR	O
(	O
errors	pointer
,	O
_	O
(	O
"%s:%s: error: %s does not contain information for type %s.\n"	pointer
)	O
,	O
rec_field_source	function
(	O
rec_field	pointer
)	O
,	O
rec_field_location_str	function
(	O
rec_field	pointer
)	O
,	O
rec_source	pointer
,	O
rec_type	pointer
)	O
;	O
res	int
++	O
;	O
goto	O
exit	function
;	O
}	O
remote_descriptor	pointer
=	O
rec_rset_descriptor	function
(	O
remote_rset	pointer
)	O
;	O
if	O
(	O
!	O
remote_descriptor	pointer
)	O
{	O
goto	O
exit	function
;	O
}	O
iter	struct
=	O
rec_mset_iterator	function
(	O
rec_record_mset	function
(	O
remote_descriptor	pointer
)	O
)	O
;	O
while	O
(	O
rec_mset_iterator_next	function
(	O
&	O
iter	struct
,	O
MSET_FIELD	int
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
remote_field	pointer
,	O
NULL	O
)	O
)	O
{	O
if	O
(	O
!	O
rec_field_name_equal_p	function
(	O
rec_field_name	function
(	O
remote_field	pointer
)	O
,	O
FNAME	O
(	O
REC_FIELD_REC	int
)	O
)	O
)	O
{	O
rec_mset_append	function
(	O
rec_record_mset	function
(	O
descriptor	pointer
)	O
,	O
MSET_FIELD	int
,	O
(	O
void	O
*	O
)	O
rec_field_dup	function
(	O
remote_field	pointer
)	O
,	O
MSET_ANY	int
)	O
;	O
}	O
}	O
rec_mset_iterator_free	function
(	O
&	O
iter	struct
)	O
;	O
rec_rset_set_descriptor	function
(	O
rset	pointer
,	O
rec_record_dup	function
(	O
descriptor	pointer
)	O
)	O
;	O
rec_db_destroy	function
(	O
remote_db	pointer
)	O
;	O
fclose	function
(	O
external_file	pointer
)	O
;	O
}	O
}	O
exit	function
:	O
if	O
(	O
rec_url	pointer
&&	O
(	O
tmpfile_name	array
[	O
0	int
]	O
!=	O
'\0'	O
)	O
)	O
{	O
remove	function
(	O
tmpfile_name	array
)	O
;	O
}	O
free	function
(	O
rec_url	pointer
)	O
;	O
free	function
(	O
rec_file	pointer
)	O
;	O
return	O
res	int
;	O
}	O
static	O
bool	bool
rec_int_rec_type_p	function
(	O
const	O
char	O
*	O
str	pointer
)	O
{	O
return	O
rec_match	function
(	O
str	pointer
,	O
"^[ \t]*"	pointer
REC_RECORD_TYPE_RE	O
"[ \n\t]*"	pointer
"("	pointer
"("	pointer
REC_URL_REGEXP	pointer
")"	pointer
"|"	pointer
"("	pointer
REC_FILE_REGEXP	pointer
")"	pointer
"[ \t]*)?"	pointer
"$"	pointer
)	O
;	O
}	O
