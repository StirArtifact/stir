static	O
const	O
char	O
digs	array
[	O
]	O
=	O
"0123456789ABCDEF"	pointer
;	O
unsigned	O
int	O
_bfd_srec_len	int
=	O
DEFAULT_CHUNK	int
;	O
bfd_boolean	int
_bfd_srec_forceS3	int
=	O
FALSE	int
;	O
struct	O
srec_data_list_struct	struct
{	O
struct	O
srec_data_list_struct	struct
*	O
next	pointer
;	O
bfd_byte	char
*	O
data	pointer
;	O
bfd_vma	long
where	long
;	O
bfd_size_type	long
size	long
;	O
}	O
;	O
typedef	O
struct	O
srec_data_list_struct	struct
srec_data_list_type	struct
;	O
struct	O
srec_symbol	struct
{	O
struct	O
srec_symbol	struct
*	O
next	pointer
;	O
const	O
char	O
*	O
name	pointer
;	O
bfd_vma	long
val	array
;	O
}	O
;	O
typedef	O
struct	O
srec_data_struct	struct
{	O
srec_data_list_type	struct
*	O
head	pointer
;	O
srec_data_list_type	struct
*	O
tail	pointer
;	O
unsigned	O
int	O
type	enum
;	O
struct	O
srec_symbol	struct
*	O
symbols	pointer
;	O
struct	O
srec_symbol	struct
*	O
symtail	pointer
;	O
asymbol	struct
*	O
csymbols	pointer
;	O
}	O
tdata_type	struct
;	O
static	O
void	O
srec_init	function
(	O
void	O
)	O
{	O
static	O
bfd_boolean	int
inited	int
=	O
FALSE	int
;	O
if	O
(	O
!	O
inited	int
)	O
{	O
inited	int
=	O
TRUE	int
;	O
hex_init	function
(	O
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
srec_mkobject	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
tdata_type	struct
*	O
tdata	union
;	O
srec_init	function
(	O
)	O
;	O
tdata	union
=	O
(	O
tdata_type	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
tdata_type	struct
)	O
)	O
;	O
if	O
(	O
tdata	union
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
abfd	pointer
->	O
tdata	union
.	O
srec_data	pointer
=	O
tdata	union
;	O
tdata	union
->	O
type	enum
=	O
1	int
;	O
tdata	union
->	O
head	pointer
=	O
NULL	O
;	O
tdata	union
->	O
tail	pointer
=	O
NULL	O
;	O
tdata	union
->	O
symbols	pointer
=	O
NULL	O
;	O
tdata	union
->	O
symtail	pointer
=	O
NULL	O
;	O
tdata	union
->	O
csymbols	pointer
=	O
NULL	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
int	O
srec_get_byte	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
bfd_boolean	int
*	O
errorptr	pointer
)	O
{	O
bfd_byte	char
c	char
;	O
if	O
(	O
bfd_bread	function
(	O
&	O
c	char
,	O
(	O
bfd_size_type	long
)	O
1	int
,	O
abfd	pointer
)	O
!=	O
1	int
)	O
{	O
if	O
(	O
bfd_get_error	function
(	O
)	O
!=	O
bfd_error_file_truncated	int
)	O
*	O
errorptr	pointer
=	O
TRUE	int
;	O
return	O
EOF	O
;	O
}	O
return	O
(	O
int	O
)	O
(	O
c	char
&	O
0xff	int
)	O
;	O
}	O
static	O
void	O
srec_bad_byte	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
int	O
lineno	pointer
,	O
int	O
c	char
,	O
bfd_boolean	int
error	int
)	O
{	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
if	O
(	O
!	O
error	int
)	O
bfd_set_error	function
(	O
bfd_error_file_truncated	int
)	O
;	O
}	O
else	O
{	O
char	O
buf	pointer
[	O
40	int
]	O
;	O
if	O
(	O
!	O
ISPRINT	O
(	O
c	char
)	O
)	O
sprintf	function
(	O
buf	pointer
,	O
"\\%03o"	pointer
,	O
(	O
unsigned	O
int	O
)	O
c	char
&	O
0xff	int
)	O
;	O
else	O
{	O
buf	pointer
[	O
0	int
]	O
=	O
c	char
;	O
buf	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB:%d: unexpected character `%s' in S-record file"	pointer
)	O
,	O
abfd	pointer
,	O
lineno	pointer
,	O
buf	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
}	O
}	O
static	O
bfd_boolean	int
srec_new_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
const	O
char	O
*	O
name	pointer
,	O
bfd_vma	long
val	array
)	O
{	O
struct	O
srec_symbol	struct
*	O
n	long
;	O
n	long
=	O
(	O
struct	O
srec_symbol	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
n	long
)	O
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
n	long
->	O
name	pointer
=	O
name	pointer
;	O
n	long
->	O
val	array
=	O
val	array
;	O
if	O
(	O
abfd	pointer
->	O
tdata	union
.	O
srec_data	pointer
->	O
symbols	pointer
==	O
NULL	O
)	O
abfd	pointer
->	O
tdata	union
.	O
srec_data	pointer
->	O
symbols	pointer
=	O
n	long
;	O
else	O
abfd	pointer
->	O
tdata	union
.	O
srec_data	pointer
->	O
symtail	pointer
->	O
next	pointer
=	O
n	long
;	O
abfd	pointer
->	O
tdata	union
.	O
srec_data	pointer
->	O
symtail	pointer
=	O
n	long
;	O
n	long
->	O
next	pointer
=	O
NULL	O
;	O
++	O
abfd	pointer
->	O
symcount	int
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
srec_scan	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
int	O
c	char
;	O
unsigned	O
int	O
lineno	pointer
=	O
1	int
;	O
bfd_boolean	int
error	int
=	O
FALSE	int
;	O
bfd_byte	char
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
bufsize	long
=	O
0	int
;	O
asection	struct
*	O
sec	pointer
=	O
NULL	O
;	O
char	O
*	O
symbuf	pointer
=	O
NULL	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
(	O
file_ptr	long
)	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
goto	O
error_return	O
;	O
while	O
(	O
(	O
c	char
=	O
srec_get_byte	function
(	O
abfd	pointer
,	O
&	O
error	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
if	O
(	O
c	char
!=	O
'S'	O
&&	O
c	char
!=	O
'\r'	O
&&	O
c	char
!=	O
'\n'	O
)	O
sec	pointer
=	O
NULL	O
;	O
switch	O
(	O
c	char
)	O
{	O
default	O
:	O
srec_bad_byte	function
(	O
abfd	pointer
,	O
lineno	pointer
,	O
c	char
,	O
error	int
)	O
;	O
goto	O
error_return	O
;	O
case	O
'\n'	O
:	O
++	O
lineno	pointer
;	O
break	O
;	O
case	O
'\r'	O
:	O
break	O
;	O
case	O
'$'	O
:	O
while	O
(	O
(	O
c	char
=	O
srec_get_byte	function
(	O
abfd	pointer
,	O
&	O
error	int
)	O
)	O
!=	O
'\n'	O
&&	O
c	char
!=	O
EOF	O
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
srec_bad_byte	function
(	O
abfd	pointer
,	O
lineno	pointer
,	O
c	char
,	O
error	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
++	O
lineno	pointer
;	O
break	O
;	O
case	O
' '	O
:	O
do	O
{	O
bfd_size_type	long
alc	long
;	O
char	O
*	O
p	pointer
,	O
*	O
symname	pointer
;	O
bfd_vma	long
symval	long
;	O
while	O
(	O
(	O
c	char
=	O
srec_get_byte	function
(	O
abfd	pointer
,	O
&	O
error	int
)	O
)	O
!=	O
EOF	O
&&	O
(	O
c	char
==	O
' '	O
||	O
c	char
==	O
'\t'	O
)	O
)	O
;	O
if	O
(	O
c	char
==	O
'\n'	O
||	O
c	char
==	O
'\r'	O
)	O
break	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
srec_bad_byte	function
(	O
abfd	pointer
,	O
lineno	pointer
,	O
c	char
,	O
error	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
alc	long
=	O
10	int
;	O
symbuf	pointer
=	O
(	O
char	O
*	O
)	O
bfd_malloc	function
(	O
alc	long
+	O
1	int
)	O
;	O
if	O
(	O
symbuf	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
p	pointer
=	O
symbuf	pointer
;	O
*	O
p	pointer
++	O
=	O
c	char
;	O
while	O
(	O
(	O
c	char
=	O
srec_get_byte	function
(	O
abfd	pointer
,	O
&	O
error	int
)	O
)	O
!=	O
EOF	O
&&	O
!	O
ISSPACE	O
(	O
c	char
)	O
)	O
{	O
if	O
(	O
(	O
bfd_size_type	long
)	O
(	O
p	pointer
-	O
symbuf	pointer
)	O
>=	O
alc	long
)	O
{	O
char	O
*	O
n	long
;	O
alc	long
*=	O
2	int
;	O
n	long
=	O
(	O
char	O
*	O
)	O
bfd_realloc	function
(	O
symbuf	pointer
,	O
alc	long
+	O
1	int
)	O
;	O
if	O
(	O
n	long
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
p	pointer
=	O
n	long
+	O
(	O
p	pointer
-	O
symbuf	pointer
)	O
;	O
symbuf	pointer
=	O
n	long
;	O
}	O
*	O
p	pointer
++	O
=	O
c	char
;	O
}	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
srec_bad_byte	function
(	O
abfd	pointer
,	O
lineno	pointer
,	O
c	char
,	O
error	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
*	O
p	pointer
++	O
=	O
'\0'	O
;	O
symname	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
(	O
bfd_size_type	long
)	O
(	O
p	pointer
-	O
symbuf	pointer
)	O
)	O
;	O
if	O
(	O
symname	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
strcpy	function
(	O
symname	pointer
,	O
symbuf	pointer
)	O
;	O
free	function
(	O
symbuf	pointer
)	O
;	O
symbuf	pointer
=	O
NULL	O
;	O
while	O
(	O
(	O
c	char
=	O
srec_get_byte	function
(	O
abfd	pointer
,	O
&	O
error	int
)	O
)	O
!=	O
EOF	O
&&	O
(	O
c	char
==	O
' '	O
||	O
c	char
==	O
'\t'	O
)	O
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
srec_bad_byte	function
(	O
abfd	pointer
,	O
lineno	pointer
,	O
c	char
,	O
error	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
c	char
==	O
'$'	O
)	O
{	O
c	char
=	O
srec_get_byte	function
(	O
abfd	pointer
,	O
&	O
error	int
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
srec_bad_byte	function
(	O
abfd	pointer
,	O
lineno	pointer
,	O
c	char
,	O
error	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
}	O
symval	long
=	O
0	int
;	O
while	O
(	O
ISHEX	O
(	O
c	char
)	O
)	O
{	O
symval	long
<<=	O
4	int
;	O
symval	long
+=	O
NIBBLE	O
(	O
c	char
)	O
;	O
c	char
=	O
srec_get_byte	function
(	O
abfd	pointer
,	O
&	O
error	int
)	O
;	O
if	O
(	O
c	char
==	O
EOF	O
)	O
{	O
srec_bad_byte	function
(	O
abfd	pointer
,	O
lineno	pointer
,	O
c	char
,	O
error	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
}	O
if	O
(	O
!	O
srec_new_symbol	function
(	O
abfd	pointer
,	O
symname	pointer
,	O
symval	long
)	O
)	O
goto	O
error_return	O
;	O
}	O
while	O
(	O
c	char
==	O
' '	O
||	O
c	char
==	O
'\t'	O
)	O
;	O
if	O
(	O
c	char
==	O
'\n'	O
)	O
++	O
lineno	pointer
;	O
else	O
if	O
(	O
c	char
!=	O
'\r'	O
)	O
{	O
srec_bad_byte	function
(	O
abfd	pointer
,	O
lineno	pointer
,	O
c	char
,	O
error	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
break	O
;	O
case	O
'S'	O
:	O
{	O
file_ptr	long
pos	long
;	O
unsigned	O
char	O
hdr	array
[	O
3	int
]	O
;	O
unsigned	O
int	O
bytes	int
,	O
min_bytes	int
;	O
bfd_vma	long
address	long
;	O
bfd_byte	char
*	O
data	pointer
;	O
unsigned	O
char	O
check_sum	char
;	O
pos	long
=	O
bfd_tell	function
(	O
abfd	pointer
)	O
-	O
1	int
;	O
if	O
(	O
bfd_bread	function
(	O
hdr	array
,	O
(	O
bfd_size_type	long
)	O
3	int
,	O
abfd	pointer
)	O
!=	O
3	int
)	O
goto	O
error_return	O
;	O
if	O
(	O
!	O
ISHEX	O
(	O
hdr	array
[	O
1	int
]	O
)	O
||	O
!	O
ISHEX	O
(	O
hdr	array
[	O
2	int
]	O
)	O
)	O
{	O
if	O
(	O
!	O
ISHEX	O
(	O
hdr	array
[	O
1	int
]	O
)	O
)	O
c	char
=	O
hdr	array
[	O
1	int
]	O
;	O
else	O
c	char
=	O
hdr	array
[	O
2	int
]	O
;	O
srec_bad_byte	function
(	O
abfd	pointer
,	O
lineno	pointer
,	O
c	char
,	O
error	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
check_sum	char
=	O
bytes	int
=	O
HEX	O
(	O
hdr	array
+	O
1	int
)	O
;	O
min_bytes	int
=	O
3	int
;	O
if	O
(	O
hdr	array
[	O
0	int
]	O
==	O
'2'	O
||	O
hdr	array
[	O
0	int
]	O
==	O
'8'	O
)	O
min_bytes	int
=	O
4	int
;	O
else	O
if	O
(	O
hdr	array
[	O
0	int
]	O
==	O
'3'	O
||	O
hdr	array
[	O
0	int
]	O
==	O
'7'	O
)	O
min_bytes	int
=	O
5	int
;	O
if	O
(	O
bytes	int
<	O
min_bytes	int
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB:%d: byte count %d too small"	pointer
)	O
,	O
abfd	pointer
,	O
lineno	pointer
,	O
bytes	int
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
bytes	int
*	O
2	int
>	O
bufsize	long
)	O
{	O
if	O
(	O
buf	pointer
!=	O
NULL	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
buf	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
(	O
bfd_size_type	long
)	O
bytes	int
*	O
2	int
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
bufsize	long
=	O
bytes	int
*	O
2	int
;	O
}	O
if	O
(	O
bfd_bread	function
(	O
buf	pointer
,	O
(	O
bfd_size_type	long
)	O
bytes	int
*	O
2	int
,	O
abfd	pointer
)	O
!=	O
bytes	int
*	O
2	int
)	O
goto	O
error_return	O
;	O
--	O
bytes	int
;	O
address	long
=	O
0	int
;	O
data	pointer
=	O
buf	pointer
;	O
switch	O
(	O
hdr	array
[	O
0	int
]	O
)	O
{	O
case	O
'0'	O
:	O
case	O
'5'	O
:	O
sec	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
'3'	O
:	O
check_sum	char
+=	O
HEX	O
(	O
data	pointer
)	O
;	O
address	long
=	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
--	O
bytes	int
;	O
case	O
'2'	O
:	O
check_sum	char
+=	O
HEX	O
(	O
data	pointer
)	O
;	O
address	long
=	O
(	O
address	long
<<	O
8	int
)	O
|	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
--	O
bytes	int
;	O
case	O
'1'	O
:	O
check_sum	char
+=	O
HEX	O
(	O
data	pointer
)	O
;	O
address	long
=	O
(	O
address	long
<<	O
8	int
)	O
|	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
check_sum	char
+=	O
HEX	O
(	O
data	pointer
)	O
;	O
address	long
=	O
(	O
address	long
<<	O
8	int
)	O
|	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
bytes	int
-=	O
2	int
;	O
if	O
(	O
sec	pointer
!=	O
NULL	O
&&	O
sec	pointer
->	O
vma	long
+	O
sec	pointer
->	O
size	long
==	O
address	long
)	O
{	O
sec	pointer
->	O
size	long
+=	O
bytes	int
;	O
}	O
else	O
{	O
char	O
secbuf	array
[	O
20	int
]	O
;	O
char	O
*	O
secname	pointer
;	O
bfd_size_type	long
amt	long
;	O
flagword	int
flags	int
;	O
sprintf	function
(	O
secbuf	array
,	O
".sec%d"	pointer
,	O
bfd_count_sections	function
(	O
abfd	pointer
)	O
+	O
1	int
)	O
;	O
amt	long
=	O
strlen	function
(	O
secbuf	array
)	O
+	O
1	int
;	O
secname	pointer
=	O
(	O
char	O
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
amt	long
)	O
;	O
strcpy	function
(	O
secname	pointer
,	O
secbuf	array
)	O
;	O
flags	int
=	O
SEC_HAS_CONTENTS	int
|	O
SEC_LOAD	int
|	O
SEC_ALLOC	int
;	O
sec	pointer
=	O
bfd_make_section_with_flags	function
(	O
abfd	pointer
,	O
secname	pointer
,	O
flags	int
)	O
;	O
if	O
(	O
sec	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
sec	pointer
->	O
vma	long
=	O
address	long
;	O
sec	pointer
->	O
lma	long
=	O
address	long
;	O
sec	pointer
->	O
size	long
=	O
bytes	int
;	O
sec	pointer
->	O
filepos	long
=	O
pos	long
;	O
}	O
while	O
(	O
bytes	int
>	O
0	int
)	O
{	O
check_sum	char
+=	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
bytes	int
--	O
;	O
}	O
check_sum	char
=	O
255	int
-	O
(	O
check_sum	char
&	O
0xff	int
)	O
;	O
if	O
(	O
check_sum	char
!=	O
HEX	O
(	O
data	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB:%d: bad checksum in S-record file"	pointer
)	O
,	O
abfd	pointer
,	O
lineno	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
break	O
;	O
case	O
'7'	O
:	O
check_sum	char
+=	O
HEX	O
(	O
data	pointer
)	O
;	O
address	long
=	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
case	O
'8'	O
:	O
check_sum	char
+=	O
HEX	O
(	O
data	pointer
)	O
;	O
address	long
=	O
(	O
address	long
<<	O
8	int
)	O
|	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
case	O
'9'	O
:	O
check_sum	char
+=	O
HEX	O
(	O
data	pointer
)	O
;	O
address	long
=	O
(	O
address	long
<<	O
8	int
)	O
|	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
check_sum	char
+=	O
HEX	O
(	O
data	pointer
)	O
;	O
address	long
=	O
(	O
address	long
<<	O
8	int
)	O
|	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
abfd	pointer
->	O
start_address	long
=	O
address	long
;	O
check_sum	char
=	O
255	int
-	O
(	O
check_sum	char
&	O
0xff	int
)	O
;	O
if	O
(	O
check_sum	char
!=	O
HEX	O
(	O
data	pointer
)	O
)	O
{	O
_bfd_error_handler	function
(	O
_	O
(	O
"%pB:%d: bad checksum in S-record file"	pointer
)	O
,	O
abfd	pointer
,	O
lineno	pointer
)	O
;	O
bfd_set_error	function
(	O
bfd_error_bad_value	int
)	O
;	O
goto	O
error_return	O
;	O
}	O
if	O
(	O
buf	pointer
!=	O
NULL	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
error	int
)	O
goto	O
error_return	O
;	O
if	O
(	O
buf	pointer
!=	O
NULL	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
TRUE	int
;	O
error_return	O
:	O
if	O
(	O
symbuf	pointer
!=	O
NULL	O
)	O
free	function
(	O
symbuf	pointer
)	O
;	O
if	O
(	O
buf	pointer
!=	O
NULL	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
const	O
bfd_target	struct
*	O
srec_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
void	O
*	O
tdata_save	pointer
;	O
bfd_byte	char
b	pointer
[	O
4	int
]	O
;	O
srec_init	function
(	O
)	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
(	O
file_ptr	long
)	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
b	pointer
,	O
(	O
bfd_size_type	long
)	O
4	int
,	O
abfd	pointer
)	O
!=	O
4	int
)	O
return	O
NULL	O
;	O
if	O
(	O
b	pointer
[	O
0	int
]	O
!=	O
'S'	O
||	O
!	O
ISHEX	O
(	O
b	pointer
[	O
1	int
]	O
)	O
||	O
!	O
ISHEX	O
(	O
b	pointer
[	O
2	int
]	O
)	O
||	O
!	O
ISHEX	O
(	O
b	pointer
[	O
3	int
]	O
)	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
NULL	O
;	O
}	O
tdata_save	pointer
=	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
;	O
if	O
(	O
!	O
srec_mkobject	function
(	O
abfd	pointer
)	O
||	O
!	O
srec_scan	function
(	O
abfd	pointer
)	O
)	O
{	O
if	O
(	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
!=	O
tdata_save	pointer
&&	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
!=	O
NULL	O
)	O
bfd_release	function
(	O
abfd	pointer
,	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
)	O
;	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
=	O
tdata_save	pointer
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
abfd	pointer
->	O
symcount	int
>	O
0	int
)	O
abfd	pointer
->	O
flags	int
|=	O
HAS_SYMS	int
;	O
return	O
abfd	pointer
->	O
xvec	pointer
;	O
}	O
static	O
const	O
bfd_target	struct
*	O
symbolsrec_object_p	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
void	O
*	O
tdata_save	pointer
;	O
char	O
b	pointer
[	O
2	int
]	O
;	O
srec_init	function
(	O
)	O
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
(	O
file_ptr	long
)	O
0	int
,	O
SEEK_SET	int
)	O
!=	O
0	int
||	O
bfd_bread	function
(	O
b	pointer
,	O
(	O
bfd_size_type	long
)	O
2	int
,	O
abfd	pointer
)	O
!=	O
2	int
)	O
return	O
NULL	O
;	O
if	O
(	O
b	pointer
[	O
0	int
]	O
!=	O
'$'	O
||	O
b	pointer
[	O
1	int
]	O
!=	O
'$'	O
)	O
{	O
bfd_set_error	function
(	O
bfd_error_wrong_format	int
)	O
;	O
return	O
NULL	O
;	O
}	O
tdata_save	pointer
=	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
;	O
if	O
(	O
!	O
srec_mkobject	function
(	O
abfd	pointer
)	O
||	O
!	O
srec_scan	function
(	O
abfd	pointer
)	O
)	O
{	O
if	O
(	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
!=	O
tdata_save	pointer
&&	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
!=	O
NULL	O
)	O
bfd_release	function
(	O
abfd	pointer
,	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
)	O
;	O
abfd	pointer
->	O
tdata	union
.	O
any	pointer
=	O
tdata_save	pointer
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
abfd	pointer
->	O
symcount	int
>	O
0	int
)	O
abfd	pointer
->	O
flags	int
|=	O
HAS_SYMS	int
;	O
return	O
abfd	pointer
->	O
xvec	pointer
;	O
}	O
static	O
bfd_boolean	int
srec_read_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
,	O
bfd_byte	char
*	O
contents	pointer
)	O
{	O
int	O
c	char
;	O
bfd_size_type	long
sofar	long
=	O
0	int
;	O
bfd_boolean	int
error	int
=	O
FALSE	int
;	O
bfd_byte	char
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
bufsize	long
=	O
0	int
;	O
if	O
(	O
bfd_seek	function
(	O
abfd	pointer
,	O
section	pointer
->	O
filepos	long
,	O
SEEK_SET	int
)	O
!=	O
0	int
)	O
goto	O
error_return	O
;	O
while	O
(	O
(	O
c	char
=	O
srec_get_byte	function
(	O
abfd	pointer
,	O
&	O
error	int
)	O
)	O
!=	O
EOF	O
)	O
{	O
bfd_byte	char
hdr	array
[	O
3	int
]	O
;	O
unsigned	O
int	O
bytes	int
;	O
bfd_vma	long
address	long
;	O
bfd_byte	char
*	O
data	pointer
;	O
if	O
(	O
c	char
==	O
'\r'	O
||	O
c	char
==	O
'\n'	O
)	O
continue	O
;	O
BFD_ASSERT	O
(	O
c	char
==	O
'S'	O
)	O
;	O
if	O
(	O
bfd_bread	function
(	O
hdr	array
,	O
(	O
bfd_size_type	long
)	O
3	int
,	O
abfd	pointer
)	O
!=	O
3	int
)	O
goto	O
error_return	O
;	O
BFD_ASSERT	O
(	O
ISHEX	O
(	O
hdr	array
[	O
1	int
]	O
)	O
&&	O
ISHEX	O
(	O
hdr	array
[	O
2	int
]	O
)	O
)	O
;	O
bytes	int
=	O
HEX	O
(	O
hdr	array
+	O
1	int
)	O
;	O
if	O
(	O
bytes	int
*	O
2	int
>	O
bufsize	long
)	O
{	O
if	O
(	O
buf	pointer
!=	O
NULL	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
buf	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_malloc	function
(	O
(	O
bfd_size_type	long
)	O
bytes	int
*	O
2	int
)	O
;	O
if	O
(	O
buf	pointer
==	O
NULL	O
)	O
goto	O
error_return	O
;	O
bufsize	long
=	O
bytes	int
*	O
2	int
;	O
}	O
if	O
(	O
bfd_bread	function
(	O
buf	pointer
,	O
(	O
bfd_size_type	long
)	O
bytes	int
*	O
2	int
,	O
abfd	pointer
)	O
!=	O
bytes	int
*	O
2	int
)	O
goto	O
error_return	O
;	O
address	long
=	O
0	int
;	O
data	pointer
=	O
buf	pointer
;	O
switch	O
(	O
hdr	array
[	O
0	int
]	O
)	O
{	O
default	O
:	O
BFD_ASSERT	O
(	O
sofar	long
==	O
section	pointer
->	O
size	long
)	O
;	O
if	O
(	O
buf	pointer
!=	O
NULL	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
TRUE	int
;	O
case	O
'3'	O
:	O
address	long
=	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
--	O
bytes	int
;	O
case	O
'2'	O
:	O
address	long
=	O
(	O
address	long
<<	O
8	int
)	O
|	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
--	O
bytes	int
;	O
case	O
'1'	O
:	O
address	long
=	O
(	O
address	long
<<	O
8	int
)	O
|	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
address	long
=	O
(	O
address	long
<<	O
8	int
)	O
|	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
bytes	int
-=	O
2	int
;	O
if	O
(	O
address	long
!=	O
section	pointer
->	O
vma	long
+	O
sofar	long
)	O
{	O
BFD_ASSERT	O
(	O
sofar	long
==	O
section	pointer
->	O
size	long
)	O
;	O
if	O
(	O
buf	pointer
!=	O
NULL	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
TRUE	int
;	O
}	O
--	O
bytes	int
;	O
while	O
(	O
bytes	int
--	O
!=	O
0	int
)	O
{	O
contents	pointer
[	O
sofar	long
]	O
=	O
HEX	O
(	O
data	pointer
)	O
;	O
data	pointer
+=	O
2	int
;	O
++	O
sofar	long
;	O
}	O
break	O
;	O
}	O
}	O
if	O
(	O
error	int
)	O
goto	O
error_return	O
;	O
BFD_ASSERT	O
(	O
sofar	long
==	O
section	pointer
->	O
size	long
)	O
;	O
if	O
(	O
buf	pointer
!=	O
NULL	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
TRUE	int
;	O
error_return	O
:	O
if	O
(	O
buf	pointer
!=	O
NULL	O
)	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
FALSE	int
;	O
}	O
static	O
bfd_boolean	int
srec_get_section_contents	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asection	struct
*	O
section	pointer
,	O
void	O
*	O
location	pointer
,	O
file_ptr	long
offset	long
,	O
bfd_size_type	long
count	int
)	O
{	O
if	O
(	O
count	int
==	O
0	int
)	O
return	O
TRUE	int
;	O
if	O
(	O
offset	long
+	O
count	int
<	O
count	int
||	O
offset	long
+	O
count	int
>	O
section	pointer
->	O
size	long
)	O
{	O
bfd_set_error	function
(	O
bfd_error_invalid_operation	int
)	O
;	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
section	pointer
->	O
used_by_bfd	pointer
==	O
NULL	O
)	O
{	O
section	pointer
->	O
used_by_bfd	pointer
=	O
bfd_alloc	function
(	O
abfd	pointer
,	O
section	pointer
->	O
size	long
)	O
;	O
if	O
(	O
section	pointer
->	O
used_by_bfd	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
!	O
srec_read_section	function
(	O
abfd	pointer
,	O
section	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
section	pointer
->	O
used_by_bfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
memcpy	function
(	O
location	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
section	pointer
->	O
used_by_bfd	pointer
+	O
offset	long
,	O
(	O
size_t	long
)	O
count	int
)	O
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
srec_set_arch_mach	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
enum	O
bfd_architecture	enum
arch	enum
,	O
unsigned	O
long	O
mach	long
)	O
{	O
if	O
(	O
arch	enum
!=	O
bfd_arch_unknown	int
)	O
return	O
bfd_default_set_arch_mach	function
(	O
abfd	pointer
,	O
arch	enum
,	O
mach	long
)	O
;	O
abfd	pointer
->	O
arch_info	pointer
=	O
&	O
bfd_default_arch_struct	struct
;	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
srec_set_section_contents	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
sec_ptr	pointer
section	pointer
,	O
const	O
void	O
*	O
location	pointer
,	O
file_ptr	long
offset	long
,	O
bfd_size_type	long
bytes_to_do	long
)	O
{	O
int	O
opb	int
=	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
NULL	O
)	O
;	O
tdata_type	struct
*	O
tdata	union
=	O
abfd	pointer
->	O
tdata	union
.	O
srec_data	pointer
;	O
srec_data_list_type	struct
*	O
entry	pointer
;	O
entry	pointer
=	O
(	O
srec_data_list_type	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
sizeof	O
(	O
*	O
entry	pointer
)	O
)	O
;	O
if	O
(	O
entry	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
if	O
(	O
bytes_to_do	long
&&	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_ALLOC	int
)	O
&&	O
(	O
section	pointer
->	O
flags	int
&	O
SEC_LOAD	int
)	O
)	O
{	O
bfd_byte	char
*	O
data	pointer
;	O
data	pointer
=	O
(	O
bfd_byte	char
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
bytes_to_do	long
)	O
;	O
if	O
(	O
data	pointer
==	O
NULL	O
)	O
return	O
FALSE	int
;	O
memcpy	function
(	O
(	O
void	O
*	O
)	O
data	pointer
,	O
location	pointer
,	O
(	O
size_t	long
)	O
bytes_to_do	long
)	O
;	O
if	O
(	O
_bfd_srec_forceS3	int
)	O
tdata	union
->	O
type	enum
=	O
3	int
;	O
else	O
if	O
(	O
(	O
section	pointer
->	O
lma	long
+	O
(	O
offset	long
+	O
bytes_to_do	long
)	O
/	O
opb	int
-	O
1	int
)	O
<=	O
0xffff	int
)	O
;	O
else	O
if	O
(	O
(	O
section	pointer
->	O
lma	long
+	O
(	O
offset	long
+	O
bytes_to_do	long
)	O
/	O
opb	int
-	O
1	int
)	O
<=	O
0xffffff	int
&&	O
tdata	union
->	O
type	enum
<=	O
2	int
)	O
tdata	union
->	O
type	enum
=	O
2	int
;	O
else	O
tdata	union
->	O
type	enum
=	O
3	int
;	O
entry	pointer
->	O
data	pointer
=	O
data	pointer
;	O
entry	pointer
->	O
where	long
=	O
section	pointer
->	O
lma	long
+	O
offset	long
/	O
opb	int
;	O
entry	pointer
->	O
size	long
=	O
bytes_to_do	long
;	O
if	O
(	O
tdata	union
->	O
tail	pointer
!=	O
NULL	O
&&	O
entry	pointer
->	O
where	long
>=	O
tdata	union
->	O
tail	pointer
->	O
where	long
)	O
{	O
tdata	union
->	O
tail	pointer
->	O
next	pointer
=	O
entry	pointer
;	O
entry	pointer
->	O
next	pointer
=	O
NULL	O
;	O
tdata	union
->	O
tail	pointer
=	O
entry	pointer
;	O
}	O
else	O
{	O
srec_data_list_type	struct
*	O
*	O
look	pointer
;	O
for	O
(	O
look	pointer
=	O
&	O
tdata	union
->	O
head	pointer
;	O
*	O
look	pointer
!=	O
NULL	O
&&	O
(	O
*	O
look	pointer
)	O
->	O
where	long
<	O
entry	pointer
->	O
where	long
;	O
look	pointer
=	O
&	O
(	O
*	O
look	pointer
)	O
->	O
next	pointer
)	O
;	O
entry	pointer
->	O
next	pointer
=	O
*	O
look	pointer
;	O
*	O
look	pointer
=	O
entry	pointer
;	O
if	O
(	O
entry	pointer
->	O
next	pointer
==	O
NULL	O
)	O
tdata	union
->	O
tail	pointer
=	O
entry	pointer
;	O
}	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
srec_write_record	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
unsigned	O
int	O
type	enum
,	O
bfd_vma	long
address	long
,	O
const	O
bfd_byte	char
*	O
data	pointer
,	O
const	O
bfd_byte	char
*	O
end	pointer
)	O
{	O
char	O
buffer	pointer
[	O
2	int
*	O
MAXCHUNK	int
+	O
6	int
]	O
;	O
unsigned	O
int	O
check_sum	char
=	O
0	int
;	O
const	O
bfd_byte	char
*	O
src	pointer
=	O
data	pointer
;	O
char	O
*	O
dst	pointer
=	O
buffer	pointer
;	O
char	O
*	O
length	pointer
;	O
bfd_size_type	long
wrlen	long
;	O
*	O
dst	pointer
++	O
=	O
'S'	O
;	O
*	O
dst	pointer
++	O
=	O
'0'	O
+	O
type	enum
;	O
length	pointer
=	O
dst	pointer
;	O
dst	pointer
+=	O
2	int
;	O
switch	O
(	O
type	enum
)	O
{	O
case	O
3	int
:	O
case	O
7	int
:	O
TOHEX	O
(	O
dst	pointer
,	O
(	O
address	long
>>	O
24	int
)	O
,	O
check_sum	char
)	O
;	O
dst	pointer
+=	O
2	int
;	O
case	O
8	int
:	O
case	O
2	int
:	O
TOHEX	O
(	O
dst	pointer
,	O
(	O
address	long
>>	O
16	int
)	O
,	O
check_sum	char
)	O
;	O
dst	pointer
+=	O
2	int
;	O
case	O
9	int
:	O
case	O
1	int
:	O
case	O
0	int
:	O
TOHEX	O
(	O
dst	pointer
,	O
(	O
address	long
>>	O
8	int
)	O
,	O
check_sum	char
)	O
;	O
dst	pointer
+=	O
2	int
;	O
TOHEX	O
(	O
dst	pointer
,	O
(	O
address	long
)	O
,	O
check_sum	char
)	O
;	O
dst	pointer
+=	O
2	int
;	O
break	O
;	O
}	O
for	O
(	O
src	pointer
=	O
data	pointer
;	O
src	pointer
<	O
end	pointer
;	O
src	pointer
++	O
)	O
{	O
TOHEX	O
(	O
dst	pointer
,	O
*	O
src	pointer
,	O
check_sum	char
)	O
;	O
dst	pointer
+=	O
2	int
;	O
}	O
TOHEX	O
(	O
length	pointer
,	O
(	O
dst	pointer
-	O
length	pointer
)	O
/	O
2	int
,	O
check_sum	char
)	O
;	O
check_sum	char
&=	O
0xff	int
;	O
check_sum	char
=	O
255	int
-	O
check_sum	char
;	O
TOHEX	O
(	O
dst	pointer
,	O
check_sum	char
,	O
check_sum	char
)	O
;	O
dst	pointer
+=	O
2	int
;	O
*	O
dst	pointer
++	O
=	O
'\r'	O
;	O
*	O
dst	pointer
++	O
=	O
'\n'	O
;	O
wrlen	long
=	O
dst	pointer
-	O
buffer	pointer
;	O
return	O
bfd_bwrite	function
(	O
(	O
void	O
*	O
)	O
buffer	pointer
,	O
wrlen	long
,	O
abfd	pointer
)	O
==	O
wrlen	long
;	O
}	O
static	O
bfd_boolean	int
srec_write_header	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
unsigned	O
int	O
len	long
=	O
strlen	function
(	O
abfd	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
len	long
>	O
40	int
)	O
len	long
=	O
40	int
;	O
return	O
srec_write_record	function
(	O
abfd	pointer
,	O
0	int
,	O
(	O
bfd_vma	long
)	O
0	int
,	O
(	O
bfd_byte	char
*	O
)	O
abfd	pointer
->	O
filename	pointer
,	O
(	O
bfd_byte	char
*	O
)	O
abfd	pointer
->	O
filename	pointer
+	O
len	long
)	O
;	O
}	O
static	O
bfd_boolean	int
srec_write_section	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
tdata_type	struct
*	O
tdata	union
,	O
srec_data_list_type	struct
*	O
list	pointer
)	O
{	O
unsigned	O
int	O
octets_written	int
=	O
0	int
;	O
bfd_byte	char
*	O
location	pointer
=	O
list	pointer
->	O
data	pointer
;	O
if	O
(	O
_bfd_srec_len	int
==	O
0	int
)	O
_bfd_srec_len	int
=	O
1	int
;	O
else	O
if	O
(	O
_bfd_srec_len	int
>	O
MAXCHUNK	int
-	O
tdata	union
->	O
type	enum
-	O
2	int
)	O
_bfd_srec_len	int
=	O
MAXCHUNK	int
-	O
tdata	union
->	O
type	enum
-	O
2	int
;	O
while	O
(	O
octets_written	int
<	O
list	pointer
->	O
size	long
)	O
{	O
bfd_vma	long
address	long
;	O
unsigned	O
int	O
octets_this_chunk	int
=	O
list	pointer
->	O
size	long
-	O
octets_written	int
;	O
if	O
(	O
octets_this_chunk	int
>	O
_bfd_srec_len	int
)	O
octets_this_chunk	int
=	O
_bfd_srec_len	int
;	O
address	long
=	O
list	pointer
->	O
where	long
+	O
(	O
octets_written	int
/	O
bfd_octets_per_byte	function
(	O
abfd	pointer
,	O
NULL	O
)	O
)	O
;	O
if	O
(	O
!	O
srec_write_record	function
(	O
abfd	pointer
,	O
tdata	union
->	O
type	enum
,	O
address	long
,	O
location	pointer
,	O
location	pointer
+	O
octets_this_chunk	int
)	O
)	O
return	O
FALSE	int
;	O
octets_written	int
+=	O
octets_this_chunk	int
;	O
location	pointer
+=	O
octets_this_chunk	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
srec_write_terminator	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
tdata_type	struct
*	O
tdata	union
)	O
{	O
return	O
srec_write_record	function
(	O
abfd	pointer
,	O
10	int
-	O
tdata	union
->	O
type	enum
,	O
abfd	pointer
->	O
start_address	long
,	O
NULL	O
,	O
NULL	O
)	O
;	O
}	O
static	O
bfd_boolean	int
srec_write_symbols	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
int	O
i	pointer
;	O
int	O
count	int
=	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
if	O
(	O
count	int
)	O
{	O
bfd_size_type	long
len	long
;	O
asymbol	struct
*	O
*	O
table	pointer
=	O
bfd_get_outsymbols	function
(	O
abfd	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
abfd	pointer
->	O
filename	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
"$$ "	pointer
,	O
(	O
bfd_size_type	long
)	O
3	int
,	O
abfd	pointer
)	O
!=	O
3	int
||	O
bfd_bwrite	function
(	O
abfd	pointer
->	O
filename	pointer
,	O
len	long
,	O
abfd	pointer
)	O
!=	O
len	long
||	O
bfd_bwrite	function
(	O
"\r\n"	pointer
,	O
(	O
bfd_size_type	long
)	O
2	int
,	O
abfd	pointer
)	O
!=	O
2	int
)	O
return	O
FALSE	int
;	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
count	int
;	O
i	pointer
++	O
)	O
{	O
asymbol	struct
*	O
s	pointer
=	O
table	pointer
[	O
i	pointer
]	O
;	O
if	O
(	O
!	O
bfd_is_local_label	function
(	O
abfd	pointer
,	O
s	pointer
)	O
&&	O
(	O
s	pointer
->	O
flags	int
&	O
BSF_DEBUGGING	O
)	O
==	O
0	int
)	O
{	O
char	O
buf	pointer
[	O
43	int
]	O
,	O
*	O
p	pointer
;	O
len	long
=	O
strlen	function
(	O
s	pointer
->	O
name	pointer
)	O
;	O
if	O
(	O
bfd_bwrite	function
(	O
"  "	pointer
,	O
(	O
bfd_size_type	long
)	O
2	int
,	O
abfd	pointer
)	O
!=	O
2	int
||	O
bfd_bwrite	function
(	O
s	pointer
->	O
name	pointer
,	O
len	long
,	O
abfd	pointer
)	O
!=	O
len	long
)	O
return	O
FALSE	int
;	O
sprintf_vma	O
(	O
buf	pointer
+	O
2	int
,	O
(	O
s	pointer
->	O
value	long
+	O
s	pointer
->	O
section	pointer
->	O
output_section	pointer
->	O
lma	long
+	O
s	pointer
->	O
section	pointer
->	O
output_offset	long
)	O
)	O
;	O
p	pointer
=	O
buf	pointer
+	O
2	int
;	O
while	O
(	O
p	pointer
[	O
0	int
]	O
==	O
'0'	O
&&	O
p	pointer
[	O
1	int
]	O
!=	O
0	int
)	O
p	pointer
++	O
;	O
len	long
=	O
strlen	function
(	O
p	pointer
)	O
;	O
p	pointer
[	O
len	long
]	O
=	O
'\r'	O
;	O
p	pointer
[	O
len	long
+	O
1	int
]	O
=	O
'\n'	O
;	O
*	O
--	O
p	pointer
=	O
'$'	O
;	O
*	O
--	O
p	pointer
=	O
' '	O
;	O
len	long
+=	O
4	int
;	O
if	O
(	O
bfd_bwrite	function
(	O
p	pointer
,	O
len	long
,	O
abfd	pointer
)	O
!=	O
len	long
)	O
return	O
FALSE	int
;	O
}	O
}	O
if	O
(	O
bfd_bwrite	function
(	O
"$$ \r\n"	pointer
,	O
(	O
bfd_size_type	long
)	O
5	int
,	O
abfd	pointer
)	O
!=	O
5	int
)	O
return	O
FALSE	int
;	O
}	O
return	O
TRUE	int
;	O
}	O
static	O
bfd_boolean	int
internal_srec_write_object_contents	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
int	O
symbols	pointer
)	O
{	O
tdata_type	struct
*	O
tdata	union
=	O
abfd	pointer
->	O
tdata	union
.	O
srec_data	pointer
;	O
srec_data_list_type	struct
*	O
list	pointer
;	O
if	O
(	O
symbols	pointer
)	O
{	O
if	O
(	O
!	O
srec_write_symbols	function
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
}	O
if	O
(	O
!	O
srec_write_header	function
(	O
abfd	pointer
)	O
)	O
return	O
FALSE	int
;	O
list	pointer
=	O
tdata	union
->	O
head	pointer
;	O
while	O
(	O
list	pointer
!=	O
(	O
srec_data_list_type	struct
*	O
)	O
NULL	O
)	O
{	O
if	O
(	O
!	O
srec_write_section	function
(	O
abfd	pointer
,	O
tdata	union
,	O
list	pointer
)	O
)	O
return	O
FALSE	int
;	O
list	pointer
=	O
list	pointer
->	O
next	pointer
;	O
}	O
return	O
srec_write_terminator	function
(	O
abfd	pointer
,	O
tdata	union
)	O
;	O
}	O
static	O
bfd_boolean	int
srec_write_object_contents	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
return	O
internal_srec_write_object_contents	function
(	O
abfd	pointer
,	O
0	int
)	O
;	O
}	O
static	O
bfd_boolean	int
symbolsrec_write_object_contents	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
return	O
internal_srec_write_object_contents	function
(	O
abfd	pointer
,	O
1	int
)	O
;	O
}	O
static	O
int	O
srec_sizeof_headers	function
(	O
bfd	struct
*	O
abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
struct	O
bfd_link_info	O
*	O
info	pointer
ATTRIBUTE_UNUSED	O
)	O
{	O
return	O
0	int
;	O
}	O
static	O
long	O
srec_get_symtab_upper_bound	function
(	O
bfd	struct
*	O
abfd	pointer
)	O
{	O
return	O
(	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
+	O
1	int
)	O
*	O
sizeof	O
(	O
asymbol	struct
*	O
)	O
;	O
}	O
static	O
long	O
srec_canonicalize_symtab	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
asymbol	struct
*	O
*	O
alocation	pointer
)	O
{	O
bfd_size_type	long
symcount	int
=	O
bfd_get_symcount	function
(	O
abfd	pointer
)	O
;	O
asymbol	struct
*	O
csymbols	pointer
;	O
unsigned	O
int	O
i	pointer
;	O
csymbols	pointer
=	O
abfd	pointer
->	O
tdata	union
.	O
srec_data	pointer
->	O
csymbols	pointer
;	O
if	O
(	O
csymbols	pointer
==	O
NULL	O
&&	O
symcount	int
!=	O
0	int
)	O
{	O
asymbol	struct
*	O
c	char
;	O
struct	O
srec_symbol	struct
*	O
s	pointer
;	O
csymbols	pointer
=	O
(	O
asymbol	struct
*	O
)	O
bfd_alloc	function
(	O
abfd	pointer
,	O
symcount	int
*	O
sizeof	O
(	O
asymbol	struct
)	O
)	O
;	O
if	O
(	O
csymbols	pointer
==	O
NULL	O
)	O
return	O
-	O
1	int
;	O
abfd	pointer
->	O
tdata	union
.	O
srec_data	pointer
->	O
csymbols	pointer
=	O
csymbols	pointer
;	O
for	O
(	O
s	pointer
=	O
abfd	pointer
->	O
tdata	union
.	O
srec_data	pointer
->	O
symbols	pointer
,	O
c	char
=	O
csymbols	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
,	O
++	O
c	char
)	O
{	O
c	char
->	O
the_bfd	pointer
=	O
abfd	pointer
;	O
c	char
->	O
name	pointer
=	O
s	pointer
->	O
name	pointer
;	O
c	char
->	O
value	long
=	O
s	pointer
->	O
val	array
;	O
c	char
->	O
flags	int
=	O
BSF_GLOBAL	O
;	O
c	char
->	O
section	pointer
=	O
bfd_abs_section_ptr	O
;	O
c	char
->	O
udata	union
.	O
p	pointer
=	O
NULL	O
;	O
}	O
}	O
for	O
(	O
i	pointer
=	O
0	int
;	O
i	pointer
<	O
symcount	int
;	O
i	pointer
++	O
)	O
*	O
alocation	pointer
++	O
=	O
csymbols	pointer
++	O
;	O
*	O
alocation	pointer
=	O
NULL	O
;	O
return	O
symcount	int
;	O
}	O
static	O
void	O
srec_get_symbol_info	function
(	O
bfd	struct
*	O
ignore_abfd	pointer
ATTRIBUTE_UNUSED	O
,	O
asymbol	struct
*	O
symbol	pointer
,	O
symbol_info	struct
*	O
ret	pointer
)	O
{	O
bfd_symbol_info	function
(	O
symbol	pointer
,	O
ret	pointer
)	O
;	O
}	O
static	O
void	O
srec_print_symbol	function
(	O
bfd	struct
*	O
abfd	pointer
,	O
void	O
*	O
afile	pointer
,	O
asymbol	struct
*	O
symbol	pointer
,	O
bfd_print_symbol_type	enum
how	enum
)	O
{	O
FILE	struct
*	O
file	pointer
=	O
(	O
FILE	struct
*	O
)	O
afile	pointer
;	O
switch	O
(	O
how	enum
)	O
{	O
case	O
bfd_print_symbol_name	int
:	O
fprintf	function
(	O
file	pointer
,	O
"%s"	pointer
,	O
symbol	pointer
->	O
name	pointer
)	O
;	O
break	O
;	O
default	O
:	O
bfd_print_symbol_vandf	function
(	O
abfd	pointer
,	O
(	O
void	O
*	O
)	O
file	pointer
,	O
symbol	pointer
)	O
;	O
fprintf	function
(	O
file	pointer
,	O
" %-5s %s"	pointer
,	O
symbol	pointer
->	O
section	pointer
->	O
name	pointer
,	O
symbol	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
const	O
bfd_target	struct
srec_vec	struct
=	O
{	O
"srec"	pointer
,	O
bfd_target_srec_flavour	int
,	O
BFD_ENDIAN_UNKNOWN	int
,	O
BFD_ENDIAN_UNKNOWN	int
,	O
(	O
HAS_RELOC	int
|	O
EXEC_P	int
|	O
HAS_LINENO	int
|	O
HAS_DEBUG	int
|	O
HAS_SYMS	int
|	O
HAS_LOCALS	int
|	O
WP_TEXT	int
|	O
D_PAGED	int
)	O
,	O
(	O
SEC_CODE	int
|	O
SEC_DATA	int
|	O
SEC_ROM	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_RELOC	int
)	O
,	O
0	int
,	O
' '	O
,	O
16	int
,	O
0	int
,	O
bfd_getb64	function
,	O
bfd_getb_signed_64	function
,	O
bfd_putb64	function
,	O
bfd_getb32	function
,	O
bfd_getb_signed_32	function
,	O
bfd_putb32	function
,	O
bfd_getb16	function
,	O
bfd_getb_signed_16	function
,	O
bfd_putb16	function
,	O
bfd_getb64	function
,	O
bfd_getb_signed_64	function
,	O
bfd_putb64	function
,	O
bfd_getb32	function
,	O
bfd_getb_signed_32	function
,	O
bfd_putb32	function
,	O
bfd_getb16	function
,	O
bfd_getb_signed_16	function
,	O
bfd_putb16	function
,	O
{	O
_bfd_dummy_target	function
,	O
srec_object_p	function
,	O
_bfd_dummy_target	function
,	O
_bfd_dummy_target	function
,	O
}	O
,	O
{	O
_bfd_bool_bfd_false_error	function
,	O
srec_mkobject	function
,	O
_bfd_generic_mkarchive	function
,	O
_bfd_bool_bfd_false_error	function
,	O
}	O
,	O
{	O
_bfd_bool_bfd_false_error	function
,	O
srec_write_object_contents	function
,	O
_bfd_write_archive_contents	function
,	O
_bfd_bool_bfd_false_error	function
,	O
}	O
,	O
BFD_JUMP_TABLE_GENERIC	O
(	O
srec	O
)	O
,	O
BFD_JUMP_TABLE_COPY	O
(	O
_bfd_generic	O
)	O
,	O
BFD_JUMP_TABLE_CORE	O
(	O
_bfd_nocore	O
)	O
,	O
BFD_JUMP_TABLE_ARCHIVE	O
(	O
_bfd_noarchive	O
)	O
,	O
BFD_JUMP_TABLE_SYMBOLS	O
(	O
srec	O
)	O
,	O
BFD_JUMP_TABLE_RELOCS	O
(	O
_bfd_norelocs	O
)	O
,	O
BFD_JUMP_TABLE_WRITE	O
(	O
srec	O
)	O
,	O
BFD_JUMP_TABLE_LINK	O
(	O
srec	O
)	O
,	O
BFD_JUMP_TABLE_DYNAMIC	O
(	O
_bfd_nodynamic	O
)	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
const	O
bfd_target	struct
symbolsrec_vec	struct
=	O
{	O
"symbolsrec"	pointer
,	O
bfd_target_srec_flavour	int
,	O
BFD_ENDIAN_UNKNOWN	int
,	O
BFD_ENDIAN_UNKNOWN	int
,	O
(	O
HAS_RELOC	int
|	O
EXEC_P	int
|	O
HAS_LINENO	int
|	O
HAS_DEBUG	int
|	O
HAS_SYMS	int
|	O
HAS_LOCALS	int
|	O
WP_TEXT	int
|	O
D_PAGED	int
)	O
,	O
(	O
SEC_CODE	int
|	O
SEC_DATA	int
|	O
SEC_ROM	int
|	O
SEC_HAS_CONTENTS	int
|	O
SEC_ALLOC	int
|	O
SEC_LOAD	int
|	O
SEC_RELOC	int
)	O
,	O
0	int
,	O
' '	O
,	O
16	int
,	O
0	int
,	O
bfd_getb64	function
,	O
bfd_getb_signed_64	function
,	O
bfd_putb64	function
,	O
bfd_getb32	function
,	O
bfd_getb_signed_32	function
,	O
bfd_putb32	function
,	O
bfd_getb16	function
,	O
bfd_getb_signed_16	function
,	O
bfd_putb16	function
,	O
bfd_getb64	function
,	O
bfd_getb_signed_64	function
,	O
bfd_putb64	function
,	O
bfd_getb32	function
,	O
bfd_getb_signed_32	function
,	O
bfd_putb32	function
,	O
bfd_getb16	function
,	O
bfd_getb_signed_16	function
,	O
bfd_putb16	function
,	O
{	O
_bfd_dummy_target	function
,	O
symbolsrec_object_p	function
,	O
_bfd_dummy_target	function
,	O
_bfd_dummy_target	function
,	O
}	O
,	O
{	O
_bfd_bool_bfd_false_error	function
,	O
srec_mkobject	function
,	O
_bfd_generic_mkarchive	function
,	O
_bfd_bool_bfd_false_error	function
,	O
}	O
,	O
{	O
_bfd_bool_bfd_false_error	function
,	O
symbolsrec_write_object_contents	function
,	O
_bfd_write_archive_contents	function
,	O
_bfd_bool_bfd_false_error	function
,	O
}	O
,	O
BFD_JUMP_TABLE_GENERIC	O
(	O
srec	O
)	O
,	O
BFD_JUMP_TABLE_COPY	O
(	O
_bfd_generic	O
)	O
,	O
BFD_JUMP_TABLE_CORE	O
(	O
_bfd_nocore	O
)	O
,	O
BFD_JUMP_TABLE_ARCHIVE	O
(	O
_bfd_noarchive	O
)	O
,	O
BFD_JUMP_TABLE_SYMBOLS	O
(	O
srec	O
)	O
,	O
BFD_JUMP_TABLE_RELOCS	O
(	O
_bfd_norelocs	O
)	O
,	O
BFD_JUMP_TABLE_WRITE	O
(	O
srec	O
)	O
,	O
BFD_JUMP_TABLE_LINK	O
(	O
srec	O
)	O
,	O
BFD_JUMP_TABLE_DYNAMIC	O
(	O
_bfd_nodynamic	O
)	O
,	O
NULL	O
,	O
NULL	O
}	O
;	O
