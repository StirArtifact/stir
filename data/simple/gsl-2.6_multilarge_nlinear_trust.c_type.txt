typedef	O
struct	O
{	O
size_t	long
n	int
;	O
size_t	long
p	int
;	O
double	O
delta	double
;	O
double	O
mu	double
;	O
long	O
nu	pointer
;	O
gsl_vector	struct
*	O
diag	pointer
;	O
gsl_vector	struct
*	O
x_trial	pointer
;	O
gsl_vector	struct
*	O
f_trial	pointer
;	O
gsl_vector	struct
*	O
workn	pointer
;	O
void	O
*	O
trs_state	pointer
;	O
void	O
*	O
solver_state	pointer
;	O
double	O
avratio	pointer
;	O
gsl_multilarge_nlinear_parameters	struct
params	pointer
;	O
}	O
trust_state_t	struct
;	O
static	O
void	O
*	O
trust_alloc	function
(	O
const	O
gsl_multilarge_nlinear_parameters	struct
*	O
params	pointer
,	O
const	O
size_t	long
n	int
,	O
const	O
size_t	long
p	int
)	O
;	O
static	O
void	O
trust_free	function
(	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
int	O
trust_init	function
(	O
void	O
*	O
vstate	pointer
,	O
const	O
gsl_vector	struct
*	O
swts	pointer
,	O
gsl_multilarge_nlinear_fdf	struct
*	O
fdf	pointer
,	O
const	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_vector	struct
*	O
g	pointer
,	O
gsl_matrix	struct
*	O
JTJ	pointer
)	O
;	O
static	O
int	O
trust_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
const	O
gsl_vector	struct
*	O
swts	pointer
,	O
gsl_multilarge_nlinear_fdf	struct
*	O
fdf	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_vector	struct
*	O
g	pointer
,	O
gsl_matrix	struct
*	O
JTJ	pointer
,	O
gsl_vector	struct
*	O
dx	pointer
)	O
;	O
static	O
int	O
trust_rcond	function
(	O
double	O
*	O
rcond	pointer
,	O
const	O
gsl_matrix	struct
*	O
JTJ	pointer
,	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
int	O
trust_covar	function
(	O
const	O
gsl_matrix	struct
*	O
JTJ	pointer
,	O
gsl_matrix	struct
*	O
covar	pointer
,	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
double	O
trust_avratio	function
(	O
void	O
*	O
vstate	pointer
)	O
;	O
static	O
void	O
trust_trial_step	function
(	O
const	O
gsl_vector	struct
*	O
x	double
,	O
const	O
gsl_vector	struct
*	O
dx	pointer
,	O
gsl_vector	struct
*	O
x_trial	pointer
)	O
;	O
static	O
double	O
trust_calc_rho	function
(	O
const	O
gsl_multilarge_nlinear_trust_state	struct
*	O
trust_state	pointer
,	O
const	O
gsl_vector	struct
*	O
f_trial	pointer
,	O
const	O
gsl_vector	struct
*	O
dx	pointer
,	O
trust_state_t	struct
*	O
state	pointer
)	O
;	O
static	O
int	O
trust_eval_step	function
(	O
const	O
gsl_multilarge_nlinear_trust_state	struct
*	O
trust_state	pointer
,	O
const	O
gsl_vector	struct
*	O
f_trial	pointer
,	O
const	O
gsl_vector	struct
*	O
dx	pointer
,	O
double	O
*	O
rho	double
,	O
trust_state_t	struct
*	O
state	pointer
)	O
;	O
static	O
double	O
trust_scaled_norm	function
(	O
const	O
gsl_vector	struct
*	O
D	pointer
,	O
const	O
gsl_vector	struct
*	O
a	double
)	O
;	O
static	O
void	O
*	O
trust_alloc	function
(	O
const	O
gsl_multilarge_nlinear_parameters	struct
*	O
params	pointer
,	O
const	O
size_t	long
n	int
,	O
const	O
size_t	long
p	int
)	O
{	O
trust_state_t	struct
*	O
state	pointer
;	O
state	pointer
=	O
calloc	function
(	O
1	int
,	O
sizeof	O
(	O
trust_state_t	struct
)	O
)	O
;	O
if	O
(	O
state	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate lm state"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
diag	pointer
=	O
gsl_vector_alloc	function
(	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
diag	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for diag"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
workn	pointer
=	O
gsl_vector_alloc	function
(	O
n	int
)	O
;	O
if	O
(	O
state	pointer
->	O
workn	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for workn"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
x_trial	pointer
=	O
gsl_vector_alloc	function
(	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
x_trial	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for x_trial"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
f_trial	pointer
=	O
gsl_vector_alloc	function
(	O
n	int
)	O
;	O
if	O
(	O
state	pointer
->	O
f_trial	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for f_trial"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
state	pointer
->	O
trs_state	pointer
=	O
(	O
params	pointer
->	O
trs	pointer
->	O
alloc	pointer
)	O
(	O
params	pointer
,	O
n	int
,	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
trs_state	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for trs state"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
if	O
(	O
params	pointer
->	O
solver	pointer
!=	O
gsl_multilarge_nlinear_solver_none	pointer
)	O
{	O
state	pointer
->	O
solver_state	pointer
=	O
(	O
params	pointer
->	O
solver	pointer
->	O
alloc	pointer
)	O
(	O
n	int
,	O
p	int
)	O
;	O
if	O
(	O
state	pointer
->	O
solver_state	pointer
==	O
NULL	O
)	O
{	O
GSL_ERROR_NULL	O
(	O
"failed to allocate space for solver state"	pointer
,	O
GSL_ENOMEM	int
)	O
;	O
}	O
}	O
state	pointer
->	O
n	int
=	O
n	int
;	O
state	pointer
->	O
p	int
=	O
p	int
;	O
state	pointer
->	O
delta	double
=	O
0.0	int
;	O
state	pointer
->	O
params	pointer
=	O
*	O
params	pointer
;	O
return	O
state	pointer
;	O
}	O
static	O
void	O
trust_free	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
trust_state_t	struct
*	O
state	pointer
=	O
(	O
trust_state_t	struct
*	O
)	O
vstate	pointer
;	O
const	O
gsl_multilarge_nlinear_parameters	struct
*	O
params	pointer
=	O
&	O
(	O
state	pointer
->	O
params	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
diag	pointer
)	O
gsl_vector_free	function
(	O
state	pointer
->	O
diag	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
workn	pointer
)	O
gsl_vector_free	function
(	O
state	pointer
->	O
workn	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
x_trial	pointer
)	O
gsl_vector_free	function
(	O
state	pointer
->	O
x_trial	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
f_trial	pointer
)	O
gsl_vector_free	function
(	O
state	pointer
->	O
f_trial	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
trs_state	pointer
)	O
(	O
params	pointer
->	O
trs	pointer
->	O
free	function
)	O
(	O
state	pointer
->	O
trs_state	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
solver_state	pointer
)	O
(	O
params	pointer
->	O
solver	pointer
->	O
free	function
)	O
(	O
state	pointer
->	O
solver_state	pointer
)	O
;	O
free	function
(	O
state	pointer
)	O
;	O
}	O
static	O
int	O
trust_init	function
(	O
void	O
*	O
vstate	pointer
,	O
const	O
gsl_vector	struct
*	O
swts	pointer
,	O
gsl_multilarge_nlinear_fdf	struct
*	O
fdf	pointer
,	O
const	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_vector	struct
*	O
g	pointer
,	O
gsl_matrix	struct
*	O
JTJ	pointer
)	O
{	O
int	O
status	int
;	O
trust_state_t	struct
*	O
state	pointer
=	O
(	O
trust_state_t	struct
*	O
)	O
vstate	pointer
;	O
const	O
gsl_multilarge_nlinear_parameters	struct
*	O
params	pointer
=	O
&	O
(	O
state	pointer
->	O
params	pointer
)	O
;	O
double	O
Dx	double
;	O
status	int
=	O
gsl_multilarge_nlinear_eval_f	function
(	O
fdf	pointer
,	O
x	double
,	O
swts	pointer
,	O
f	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
gsl_multilarge_nlinear_eval_df	function
(	O
CblasTrans	int
,	O
x	double
,	O
f	pointer
,	O
f	pointer
,	O
swts	pointer
,	O
params	pointer
->	O
h_df	double
,	O
params	pointer
->	O
fdtype	enum
,	O
fdf	pointer
,	O
g	pointer
,	O
JTJ	pointer
,	O
state	pointer
->	O
workn	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
JTJ	pointer
!=	O
NULL	O
)	O
(	O
params	pointer
->	O
scale	pointer
->	O
init	pointer
)	O
(	O
JTJ	pointer
,	O
state	pointer
->	O
diag	pointer
)	O
;	O
else	O
gsl_vector_set_all	function
(	O
state	pointer
->	O
diag	pointer
,	O
1.0	int
)	O
;	O
Dx	double
=	O
trust_scaled_norm	function
(	O
state	pointer
->	O
diag	pointer
,	O
x	double
)	O
;	O
state	pointer
->	O
delta	double
=	O
0.3	int
*	O
GSL_MAX	O
(	O
1.0	int
,	O
Dx	double
)	O
;	O
nielsen_init	function
(	O
JTJ	pointer
,	O
state	pointer
->	O
diag	pointer
,	O
&	O
(	O
state	pointer
->	O
mu	double
)	O
,	O
&	O
(	O
state	pointer
->	O
nu	pointer
)	O
)	O
;	O
{	O
gsl_multilarge_nlinear_trust_state	struct
trust_state	pointer
;	O
trust_state	pointer
.	O
x	double
=	O
x	double
;	O
trust_state	pointer
.	O
f	pointer
=	O
f	pointer
;	O
trust_state	pointer
.	O
g	pointer
=	O
g	pointer
;	O
trust_state	pointer
.	O
JTJ	pointer
=	O
JTJ	pointer
;	O
trust_state	pointer
.	O
diag	pointer
=	O
state	pointer
->	O
diag	pointer
;	O
trust_state	pointer
.	O
sqrt_wts	pointer
=	O
swts	pointer
;	O
trust_state	pointer
.	O
mu	double
=	O
&	O
(	O
state	pointer
->	O
mu	double
)	O
;	O
trust_state	pointer
.	O
params	pointer
=	O
params	pointer
;	O
trust_state	pointer
.	O
solver_state	pointer
=	O
state	pointer
->	O
solver_state	pointer
;	O
trust_state	pointer
.	O
fdf	pointer
=	O
fdf	pointer
;	O
trust_state	pointer
.	O
avratio	pointer
=	O
&	O
(	O
state	pointer
->	O
avratio	pointer
)	O
;	O
status	int
=	O
(	O
params	pointer
->	O
trs	pointer
->	O
init	pointer
)	O
(	O
&	O
trust_state	pointer
,	O
state	pointer
->	O
trs_state	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
}	O
state	pointer
->	O
avratio	pointer
=	O
0.0	int
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
trust_iterate	function
(	O
void	O
*	O
vstate	pointer
,	O
const	O
gsl_vector	struct
*	O
swts	pointer
,	O
gsl_multilarge_nlinear_fdf	struct
*	O
fdf	pointer
,	O
gsl_vector	struct
*	O
x	double
,	O
gsl_vector	struct
*	O
f	pointer
,	O
gsl_vector	struct
*	O
g	pointer
,	O
gsl_matrix	struct
*	O
JTJ	pointer
,	O
gsl_vector	struct
*	O
dx	pointer
)	O
{	O
int	O
status	int
;	O
trust_state_t	struct
*	O
state	pointer
=	O
(	O
trust_state_t	struct
*	O
)	O
vstate	pointer
;	O
const	O
gsl_multilarge_nlinear_parameters	struct
*	O
params	pointer
=	O
&	O
(	O
state	pointer
->	O
params	pointer
)	O
;	O
const	O
gsl_multilarge_nlinear_trs	struct
*	O
trs	pointer
=	O
params	pointer
->	O
trs	pointer
;	O
gsl_multilarge_nlinear_trust_state	struct
trust_state	pointer
;	O
gsl_vector	struct
*	O
x_trial	pointer
=	O
state	pointer
->	O
x_trial	pointer
;	O
gsl_vector	struct
*	O
f_trial	pointer
=	O
state	pointer
->	O
f_trial	pointer
;	O
double	O
rho	double
;	O
int	O
foundstep	int
=	O
0	int
;	O
int	O
bad_steps	int
=	O
0	int
;	O
trust_state	pointer
.	O
x	double
=	O
x	double
;	O
trust_state	pointer
.	O
f	pointer
=	O
f	pointer
;	O
trust_state	pointer
.	O
g	pointer
=	O
g	pointer
;	O
trust_state	pointer
.	O
JTJ	pointer
=	O
JTJ	pointer
;	O
trust_state	pointer
.	O
diag	pointer
=	O
state	pointer
->	O
diag	pointer
;	O
trust_state	pointer
.	O
sqrt_wts	pointer
=	O
swts	pointer
;	O
trust_state	pointer
.	O
mu	double
=	O
&	O
(	O
state	pointer
->	O
mu	double
)	O
;	O
trust_state	pointer
.	O
params	pointer
=	O
params	pointer
;	O
trust_state	pointer
.	O
solver_state	pointer
=	O
state	pointer
->	O
solver_state	pointer
;	O
trust_state	pointer
.	O
fdf	pointer
=	O
fdf	pointer
;	O
trust_state	pointer
.	O
avratio	pointer
=	O
&	O
(	O
state	pointer
->	O
avratio	pointer
)	O
;	O
status	int
=	O
(	O
trs	pointer
->	O
preloop	pointer
)	O
(	O
&	O
trust_state	pointer
,	O
state	pointer
->	O
trs_state	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
while	O
(	O
!	O
foundstep	int
)	O
{	O
status	int
=	O
(	O
trs	pointer
->	O
step	pointer
)	O
(	O
&	O
trust_state	pointer
,	O
state	pointer
->	O
delta	double
,	O
dx	pointer
,	O
state	pointer
->	O
trs_state	pointer
)	O
;	O
if	O
(	O
status	int
==	O
GSL_SUCCESS	int
)	O
{	O
trust_trial_step	function
(	O
x	double
,	O
dx	pointer
,	O
x_trial	pointer
)	O
;	O
status	int
=	O
gsl_multilarge_nlinear_eval_f	function
(	O
fdf	pointer
,	O
x_trial	pointer
,	O
swts	pointer
,	O
f_trial	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
status	int
=	O
trust_eval_step	function
(	O
&	O
trust_state	pointer
,	O
f_trial	pointer
,	O
dx	pointer
,	O
&	O
rho	double
,	O
state	pointer
)	O
;	O
if	O
(	O
status	int
==	O
GSL_SUCCESS	int
)	O
foundstep	int
=	O
1	int
;	O
}	O
else	O
{	O
rho	double
=	O
-	O
1.0	int
;	O
}	O
if	O
(	O
rho	double
>	O
0.75	int
)	O
state	pointer
->	O
delta	double
*=	O
params	pointer
->	O
factor_up	double
;	O
else	O
if	O
(	O
rho	double
<	O
0.25	int
)	O
state	pointer
->	O
delta	double
/=	O
params	pointer
->	O
factor_down	double
;	O
if	O
(	O
foundstep	int
)	O
{	O
gsl_vector_memcpy	function
(	O
x	double
,	O
x_trial	pointer
)	O
;	O
gsl_vector_memcpy	function
(	O
f	pointer
,	O
f_trial	pointer
)	O
;	O
status	int
=	O
gsl_multilarge_nlinear_eval_df	function
(	O
CblasTrans	int
,	O
x	double
,	O
f	pointer
,	O
f	pointer
,	O
swts	pointer
,	O
params	pointer
->	O
h_df	double
,	O
params	pointer
->	O
fdtype	enum
,	O
fdf	pointer
,	O
g	pointer
,	O
JTJ	pointer
,	O
state	pointer
->	O
workn	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
status	int
;	O
if	O
(	O
JTJ	pointer
!=	O
NULL	O
)	O
(	O
params	pointer
->	O
scale	pointer
->	O
update	pointer
)	O
(	O
JTJ	pointer
,	O
state	pointer
->	O
diag	pointer
)	O
;	O
nielsen_accept	function
(	O
rho	double
,	O
&	O
(	O
state	pointer
->	O
mu	double
)	O
,	O
&	O
(	O
state	pointer
->	O
nu	pointer
)	O
)	O
;	O
bad_steps	int
=	O
0	int
;	O
}	O
else	O
{	O
nielsen_reject	function
(	O
&	O
(	O
state	pointer
->	O
mu	double
)	O
,	O
&	O
(	O
state	pointer
->	O
nu	pointer
)	O
)	O
;	O
if	O
(	O
++	O
bad_steps	int
>	O
15	int
)	O
{	O
return	O
GSL_ENOPROG	int
;	O
}	O
}	O
}	O
return	O
GSL_SUCCESS	int
;	O
}	O
static	O
int	O
trust_rcond	function
(	O
double	O
*	O
rcond	pointer
,	O
const	O
gsl_matrix	struct
*	O
JTJ	pointer
,	O
void	O
*	O
vstate	pointer
)	O
{	O
int	O
status	int
;	O
trust_state_t	struct
*	O
state	pointer
=	O
(	O
trust_state_t	struct
*	O
)	O
vstate	pointer
;	O
const	O
gsl_multilarge_nlinear_parameters	struct
*	O
params	pointer
=	O
&	O
(	O
state	pointer
->	O
params	pointer
)	O
;	O
status	int
=	O
(	O
params	pointer
->	O
solver	pointer
->	O
rcond	pointer
)	O
(	O
rcond	pointer
,	O
JTJ	pointer
,	O
state	pointer
->	O
solver_state	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
int	O
trust_covar	function
(	O
const	O
gsl_matrix	struct
*	O
JTJ	pointer
,	O
gsl_matrix	struct
*	O
covar	pointer
,	O
void	O
*	O
vstate	pointer
)	O
{	O
int	O
status	int
;	O
trust_state_t	struct
*	O
state	pointer
=	O
(	O
trust_state_t	struct
*	O
)	O
vstate	pointer
;	O
const	O
gsl_multilarge_nlinear_parameters	struct
*	O
params	pointer
=	O
&	O
(	O
state	pointer
->	O
params	pointer
)	O
;	O
status	int
=	O
(	O
params	pointer
->	O
solver	pointer
->	O
covar	pointer
)	O
(	O
JTJ	pointer
,	O
covar	pointer
,	O
state	pointer
->	O
solver_state	pointer
)	O
;	O
return	O
status	int
;	O
}	O
static	O
double	O
trust_avratio	function
(	O
void	O
*	O
vstate	pointer
)	O
{	O
trust_state_t	struct
*	O
state	pointer
=	O
(	O
trust_state_t	struct
*	O
)	O
vstate	pointer
;	O
return	O
state	pointer
->	O
avratio	pointer
;	O
}	O
static	O
void	O
trust_trial_step	function
(	O
const	O
gsl_vector	struct
*	O
x	double
,	O
const	O
gsl_vector	struct
*	O
dx	pointer
,	O
gsl_vector	struct
*	O
x_trial	pointer
)	O
{	O
size_t	long
i	long
,	O
N	int
=	O
x	double
->	O
size	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
N	int
;	O
i	long
++	O
)	O
{	O
double	O
dxi	double
=	O
gsl_vector_get	function
(	O
dx	pointer
,	O
i	long
)	O
;	O
double	O
xi	double
=	O
gsl_vector_get	function
(	O
x	double
,	O
i	long
)	O
;	O
gsl_vector_set	function
(	O
x_trial	pointer
,	O
i	long
,	O
xi	double
+	O
dxi	double
)	O
;	O
}	O
}	O
static	O
double	O
trust_calc_rho	function
(	O
const	O
gsl_multilarge_nlinear_trust_state	struct
*	O
trust_state	pointer
,	O
const	O
gsl_vector	struct
*	O
f_trial	pointer
,	O
const	O
gsl_vector	struct
*	O
dx	pointer
,	O
trust_state_t	struct
*	O
state	pointer
)	O
{	O
int	O
status	int
;	O
const	O
gsl_multilarge_nlinear_parameters	struct
*	O
params	pointer
=	O
&	O
(	O
state	pointer
->	O
params	pointer
)	O
;	O
const	O
gsl_multilarge_nlinear_trs	struct
*	O
trs	pointer
=	O
params	pointer
->	O
trs	pointer
;	O
const	O
gsl_vector	struct
*	O
f	pointer
=	O
trust_state	pointer
->	O
f	pointer
;	O
const	O
double	O
normf	double
=	O
gsl_blas_dnrm2	function
(	O
f	pointer
)	O
;	O
const	O
double	O
normf_trial	double
=	O
gsl_blas_dnrm2	function
(	O
f_trial	pointer
)	O
;	O
double	O
rho	double
;	O
double	O
actual_reduction	double
;	O
double	O
pred_reduction	double
;	O
double	O
u	pointer
;	O
if	O
(	O
normf_trial	double
>=	O
normf	double
)	O
return	O
-	O
1.0	int
;	O
u	pointer
=	O
normf_trial	double
/	O
normf	double
;	O
actual_reduction	double
=	O
1.0	int
-	O
u	pointer
*	O
u	pointer
;	O
status	int
=	O
(	O
trs	pointer
->	O
preduction	pointer
)	O
(	O
trust_state	pointer
,	O
dx	pointer
,	O
&	O
pred_reduction	double
,	O
state	pointer
->	O
trs_state	pointer
)	O
;	O
if	O
(	O
status	int
)	O
return	O
-	O
1.0	int
;	O
if	O
(	O
pred_reduction	double
>	O
0.0	int
)	O
rho	double
=	O
actual_reduction	double
/	O
pred_reduction	double
;	O
else	O
rho	double
=	O
-	O
1.0	int
;	O
return	O
rho	double
;	O
}	O
static	O
int	O
trust_eval_step	function
(	O
const	O
gsl_multilarge_nlinear_trust_state	struct
*	O
trust_state	pointer
,	O
const	O
gsl_vector	struct
*	O
f_trial	pointer
,	O
const	O
gsl_vector	struct
*	O
dx	pointer
,	O
double	O
*	O
rho	double
,	O
trust_state_t	struct
*	O
state	pointer
)	O
{	O
int	O
status	int
=	O
GSL_SUCCESS	int
;	O
const	O
gsl_multilarge_nlinear_parameters	struct
*	O
params	pointer
=	O
&	O
(	O
state	pointer
->	O
params	pointer
)	O
;	O
if	O
(	O
params	pointer
->	O
trs	pointer
==	O
gsl_multilarge_nlinear_trs_lmaccel	pointer
)	O
{	O
if	O
(	O
state	pointer
->	O
avratio	pointer
>	O
params	pointer
->	O
avmax	double
)	O
status	int
=	O
GSL_FAILURE	int
;	O
}	O
*	O
rho	double
=	O
trust_calc_rho	function
(	O
trust_state	pointer
,	O
f_trial	pointer
,	O
dx	pointer
,	O
state	pointer
)	O
;	O
if	O
(	O
*	O
rho	double
<=	O
0.0	int
)	O
status	int
=	O
GSL_FAILURE	int
;	O
return	O
status	int
;	O
}	O
static	O
double	O
trust_scaled_norm	function
(	O
const	O
gsl_vector	struct
*	O
D	pointer
,	O
const	O
gsl_vector	struct
*	O
a	double
)	O
{	O
const	O
size_t	long
n	int
=	O
a	double
->	O
size	long
;	O
double	O
e2	double
=	O
0.0	int
;	O
size_t	long
i	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
n	int
;	O
++	O
i	long
)	O
{	O
double	O
Di	double
=	O
gsl_vector_get	function
(	O
D	pointer
,	O
i	long
)	O
;	O
double	O
ai	double
=	O
gsl_vector_get	function
(	O
a	double
,	O
i	long
)	O
;	O
double	O
u	pointer
=	O
Di	double
*	O
ai	double
;	O
e2	double
+=	O
u	pointer
*	O
u	pointer
;	O
}	O
return	O
sqrt	function
(	O
e2	double
)	O
;	O
}	O
static	O
const	O
gsl_multilarge_nlinear_type	struct
trust_type	struct
=	O
{	O
"trust-region"	pointer
,	O
trust_alloc	function
,	O
trust_init	function
,	O
trust_iterate	function
,	O
trust_rcond	function
,	O
trust_covar	function
,	O
trust_avratio	function
,	O
trust_free	function
}	O
;	O
const	O
gsl_multilarge_nlinear_type	struct
*	O
gsl_multilarge_nlinear_trust	pointer
=	O
&	O
trust_type	struct
;	O
