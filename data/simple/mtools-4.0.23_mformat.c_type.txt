static	O
int	O
init_geometry_boot	function
(	O
union	O
bootsector	union
*	O
boot	struct
,	O
struct	O
device	struct
*	O
dev	pointer
,	O
uint8_t	char
sectors0	char
,	O
uint8_t	char
rate_0	char
,	O
uint8_t	char
rate_any	char
,	O
unsigned	O
long	O
*	O
tot_sectors	long
,	O
int	O
keepBoot	int
)	O
{	O
int	O
nb_renum	int
;	O
int	O
sector2	int
;	O
int	O
sum	char
;	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
nsect	array
,	O
dev	pointer
->	O
sectors	short
)	O
;	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
nheads	array
,	O
dev	pointer
->	O
heads	short
)	O
;	O
assert	O
(	O
*	O
tot_sectors	long
!=	O
0	int
)	O
;	O
if	O
(	O
*	O
tot_sectors	long
<=	O
UINT16_MAX	O
)	O
{	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
psect	array
,	O
(	O
uint16_t	short
)	O
*	O
tot_sectors	long
)	O
;	O
set_dword	function
(	O
boot	struct
->	O
boot	struct
.	O
bigsect	array
,	O
0	int
)	O
;	O
}	O
else	O
if	O
(	O
*	O
tot_sectors	long
<=	O
UINT32_MAX	O
)	O
{	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
psect	array
,	O
0	int
)	O
;	O
set_dword	function
(	O
boot	struct
->	O
boot	struct
.	O
bigsect	array
,	O
(	O
uint32_t	int
)	O
*	O
tot_sectors	long
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Too many sectors %ld\n"	pointer
,	O
*	O
tot_sectors	long
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
dev	pointer
->	O
use_2m	int
&	O
0x7f	int
)	O
{	O
int	O
bootOffset	int
;	O
uint8_t	char
j	pointer
;	O
uint8_t	char
size2	char
;	O
uint16_t	short
i	short
;	O
strncpy	function
(	O
boot	struct
->	O
boot	struct
.	O
banner	array
,	O
"2M-STV04"	pointer
,	O
8	int
)	O
;	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
res_2m	char
=	O
0	int
;	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
fmt_2mf	char
=	O
6	int
;	O
if	O
(	O
dev	pointer
->	O
sectors	short
%	O
(	O
(	O
(	O
1	int
<<	O
dev	pointer
->	O
ssize	char
)	O
+	O
3	int
)	O
>>	O
2	int
)	O
)	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
wt	char
=	O
1	int
;	O
else	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
wt	char
=	O
0	int
;	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
rate_0	char
=	O
rate_0	char
;	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
rate_any	char
=	O
rate_any	char
;	O
if	O
(	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
rate_any	char
==	O
2	int
)	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
rate_any	char
=	O
1	int
;	O
i	short
=	O
76	int
;	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
Infp0	array
,	O
i	short
)	O
;	O
boot	struct
->	O
bytes	array
[	O
i	short
++	O
]	O
=	O
sectors0	char
;	O
boot	struct
->	O
bytes	array
[	O
i	short
++	O
]	O
=	O
108	int
;	O
for	O
(	O
j	pointer
=	O
1	int
;	O
j	pointer
<=	O
sectors0	char
;	O
j	pointer
++	O
)	O
boot	struct
->	O
bytes	array
[	O
i	short
++	O
]	O
=	O
j	pointer
;	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
InfpX	array
,	O
i	short
)	O
;	O
boot	struct
->	O
bytes	array
[	O
i	short
++	O
]	O
=	O
64	int
;	O
boot	struct
->	O
bytes	array
[	O
i	short
++	O
]	O
=	O
3	int
;	O
nb_renum	int
=	O
i	short
++	O
;	O
sector2	int
=	O
dev	pointer
->	O
sectors	short
;	O
size2	char
=	O
dev	pointer
->	O
ssize	char
;	O
j	pointer
=	O
1	int
;	O
while	O
(	O
sector2	int
)	O
{	O
while	O
(	O
sector2	int
<	O
(	O
1	int
<<	O
size2	char
)	O
>>	O
2	int
)	O
size2	char
--	O
;	O
boot	struct
->	O
bytes	array
[	O
i	short
++	O
]	O
=	O
128	int
+	O
j	pointer
;	O
boot	struct
->	O
bytes	array
[	O
i	short
++	O
]	O
=	O
j	pointer
++	O
;	O
boot	struct
->	O
bytes	array
[	O
i	short
++	O
]	O
=	O
size2	char
;	O
sector2	int
-=	O
(	O
1	int
<<	O
size2	char
)	O
>>	O
2	int
;	O
}	O
boot	struct
->	O
bytes	array
[	O
nb_renum	int
]	O
=	O
(	O
i	short
-	O
nb_renum	int
-	O
1	int
)	O
/	O
3	int
;	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
InfTm	array
,	O
i	short
)	O
;	O
sector2	int
=	O
dev	pointer
->	O
sectors	short
;	O
size2	char
=	O
dev	pointer
->	O
ssize	char
;	O
while	O
(	O
sector2	int
)	O
{	O
while	O
(	O
sector2	int
<	O
1	int
<<	O
(	O
size2	char
-	O
2	int
)	O
)	O
size2	char
--	O
;	O
boot	struct
->	O
bytes	array
[	O
i	short
++	O
]	O
=	O
size2	char
;	O
sector2	int
-=	O
1	int
<<	O
(	O
size2	char
-	O
2	int
)	O
;	O
}	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
BootP	array
,	O
i	short
)	O
;	O
bootOffset	int
=	O
i	short
;	O
for	O
(	O
sum	char
=	O
0	int
,	O
j	pointer
=	O
64	int
;	O
j	pointer
<	O
i	short
;	O
j	pointer
++	O
)	O
sum	char
+=	O
boot	struct
->	O
bytes	array
[	O
j	pointer
]	O
;	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
CheckSum	char
=	O
-	O
sum	char
;	O
return	O
bootOffset	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
keepBoot	int
)	O
{	O
boot	struct
->	O
boot	struct
.	O
jump	array
[	O
0	int
]	O
=	O
0xeb	int
;	O
boot	struct
->	O
boot	struct
.	O
jump	array
[	O
1	int
]	O
=	O
0	int
;	O
boot	struct
->	O
boot	struct
.	O
jump	array
[	O
2	int
]	O
=	O
0x90	int
;	O
strncpy	function
(	O
boot	struct
->	O
boot	struct
.	O
banner	array
,	O
mformat_banner	pointer
,	O
8	int
)	O
;	O
}	O
return	O
0	int
;	O
}	O
}	O
static	O
int	O
comp_fat_bits	function
(	O
Fs_t	struct
*	O
Fs	pointer
,	O
int	O
estimate	int
,	O
unsigned	O
long	O
tot_sectors	long
,	O
int	O
fat32	struct
)	O
{	O
int	O
needed_fat_bits	int
;	O
needed_fat_bits	int
=	O
12	int
;	O
if	O
(	O
tot_sectors	long
>	O
MAX_DISK_SIZE	O
(	O
12	int
,	O
FAT12	int
-	O
1	int
)	O
)	O
needed_fat_bits	int
=	O
16	int
;	O
if	O
(	O
fat32	struct
||	O
tot_sectors	long
>	O
MAX_DISK_SIZE	O
(	O
16	int
,	O
FAT16	int
-	O
1	int
)	O
)	O
needed_fat_bits	int
=	O
32	int
;	O
if	O
(	O
abs	function
(	O
estimate	int
)	O
&&	O
abs	function
(	O
estimate	int
)	O
<	O
needed_fat_bits	int
)	O
{	O
if	O
(	O
fat32	struct
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Contradiction between FAT size on command line and FAT size in conf file\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"Device too big for a %d bit FAT\n"	pointer
,	O
estimate	int
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
!	O
estimate	int
)	O
{	O
unsigned	O
int	O
min_fat16_size	int
;	O
if	O
(	O
needed_fat_bits	int
>	O
12	int
)	O
return	O
needed_fat_bits	int
;	O
min_fat16_size	int
=	O
DISK_SIZE	O
(	O
16	int
,	O
Fs	pointer
->	O
sector_size	int
,	O
FAT12	int
,	O
Fs	pointer
->	O
num_fat	int
,	O
1	int
)	O
;	O
if	O
(	O
tot_sectors	long
<	O
min_fat16_size	int
)	O
return	O
12	int
;	O
else	O
if	O
(	O
Fs	pointer
->	O
cluster_size	int
==	O
0	int
&&	O
tot_sectors	long
>=	O
2	int
*	O
min_fat16_size	int
)	O
return	O
16	int
;	O
}	O
return	O
estimate	int
;	O
}	O
static	O
void	O
calc_fat_bits2	function
(	O
Fs_t	struct
*	O
Fs	pointer
,	O
unsigned	O
long	O
tot_sectors	long
,	O
int	O
fat_bits	int
,	O
int	O
may_change_cluster_size	int
,	O
int	O
may_change_root_size	int
)	O
{	O
unsigned	O
long	O
rem_sect	long
;	O
rem_sect	long
=	O
tot_sectors	long
-	O
Fs	pointer
->	O
dir_len	int
-	O
Fs	pointer
->	O
fat_start	int
;	O
switch	O
(	O
abs	function
(	O
fat_bits	int
)	O
)	O
{	O
case	O
0	int
:	O
if	O
(	O
rem_sect	long
>=	O
MY_DISK_SIZE	O
(	O
16	int
,	O
FAT12	int
+	O
2	int
)	O
)	O
set_fat16	function
(	O
Fs	pointer
)	O
;	O
else	O
if	O
(	O
rem_sect	long
<=	O
MY_DISK_SIZE	O
(	O
12	int
,	O
FAT12	int
-	O
1	int
)	O
)	O
set_fat12	function
(	O
Fs	pointer
)	O
;	O
else	O
{	O
if	O
(	O
may_change_cluster_size	int
&&	O
Fs	pointer
->	O
cluster_size	int
*	O
Fs	pointer
->	O
sector_size	int
*	O
2	int
<=	O
MAX_BYTES_PER_CLUSTER	O
)	O
Fs	pointer
->	O
cluster_size	int
<<=	O
1	int
;	O
else	O
if	O
(	O
may_change_root_size	int
)	O
{	O
Fs	pointer
->	O
dir_len	int
+=	O
rem_sect	long
-	O
MY_DISK_SIZE	O
(	O
12	int
,	O
FAT12	int
-	O
1	int
)	O
;	O
}	O
set_fat12	function
(	O
Fs	pointer
)	O
;	O
}	O
break	O
;	O
case	O
12	int
:	O
set_fat12	function
(	O
Fs	pointer
)	O
;	O
break	O
;	O
case	O
16	int
:	O
set_fat16	function
(	O
Fs	pointer
)	O
;	O
break	O
;	O
case	O
32	int
:	O
set_fat32	function
(	O
Fs	pointer
)	O
;	O
break	O
;	O
}	O
}	O
static	O
__inline__	O
void	O
format_root	function
(	O
Fs_t	struct
*	O
Fs	pointer
,	O
char	O
*	O
label	array
,	O
union	O
bootsector	union
*	O
boot	struct
)	O
{	O
Stream_t	struct
*	O
RootDir	pointer
;	O
char	O
*	O
buf	pointer
;	O
unsigned	O
int	O
i	short
;	O
struct	O
ClashHandling_t	struct
ch	char
;	O
unsigned	O
int	O
dirlen	int
;	O
init_clash_handling	function
(	O
&	O
ch	char
)	O
;	O
ch	char
.	O
name_converter	pointer
=	O
label_name_uc	function
;	O
ch	char
.	O
ignore_entry	int
=	O
-	O
2	int
;	O
buf	pointer
=	O
safe_malloc	function
(	O
Fs	pointer
->	O
sector_size	int
)	O
;	O
RootDir	pointer
=	O
OpenRoot	function
(	O
(	O
Stream_t	struct
*	O
)	O
Fs	pointer
)	O
;	O
if	O
(	O
!	O
RootDir	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Could not open root directory\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
memset	function
(	O
buf	pointer
,	O
'\0'	O
,	O
Fs	pointer
->	O
sector_size	int
)	O
;	O
if	O
(	O
Fs	pointer
->	O
fat_bits	int
==	O
32	int
)	O
{	O
dirlen	int
=	O
Fs	pointer
->	O
cluster_size	int
;	O
fatAllocate	function
(	O
Fs	pointer
,	O
Fs	pointer
->	O
rootCluster	array
,	O
Fs	pointer
->	O
end_fat	int
)	O
;	O
}	O
else	O
dirlen	int
=	O
Fs	pointer
->	O
dir_len	int
;	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
dirlen	int
;	O
i	short
++	O
)	O
WRITES	O
(	O
RootDir	pointer
,	O
buf	pointer
,	O
sectorsToBytes	function
(	O
(	O
Stream_t	struct
*	O
)	O
Fs	pointer
,	O
i	short
)	O
,	O
Fs	pointer
->	O
sector_size	int
)	O
;	O
ch	char
.	O
ignore_entry	int
=	O
1	int
;	O
if	O
(	O
label	array
[	O
0	int
]	O
)	O
mwrite_one	function
(	O
RootDir	pointer
,	O
label	array
,	O
0	int
,	O
labelit	function
,	O
NULL	O
,	O
&	O
ch	char
)	O
;	O
FREE	O
(	O
&	O
RootDir	pointer
)	O
;	O
if	O
(	O
Fs	pointer
->	O
fat_bits	int
==	O
32	int
)	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
dirents	array
,	O
0	int
)	O
;	O
else	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
dirents	array
,	O
Fs	pointer
->	O
dir_len	int
*	O
(	O
Fs	pointer
->	O
sector_size	int
/	O
32	int
)	O
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
}	O
static	O
void	O
xdf_calc_fat_size	function
(	O
Fs_t	struct
*	O
Fs	pointer
,	O
unsigned	O
long	O
tot_sectors	long
,	O
int	O
fat_bits	int
)	O
{	O
unsigned	O
int	O
rem_sect	long
;	O
rem_sect	long
=	O
tot_sectors	long
-	O
Fs	pointer
->	O
dir_len	int
-	O
Fs	pointer
->	O
fat_start	int
-	O
2	int
*	O
Fs	pointer
->	O
fat_len	int
;	O
if	O
(	O
Fs	pointer
->	O
fat_len	int
)	O
{	O
for	O
(	O
Fs	pointer
->	O
cluster_size	int
=	O
1	int
;	O
1	int
;	O
Fs	pointer
->	O
cluster_size	int
<<=	O
1	int
)	O
{	O
Fs	pointer
->	O
num_clus	int
=	O
rem_sect	long
/	O
Fs	pointer
->	O
cluster_size	int
;	O
if	O
(	O
abs	function
(	O
fat_bits	int
)	O
==	O
16	int
||	O
Fs	pointer
->	O
num_clus	int
>=	O
FAT12	int
)	O
set_fat16	function
(	O
Fs	pointer
)	O
;	O
else	O
set_fat12	function
(	O
Fs	pointer
)	O
;	O
if	O
(	O
Fs	pointer
->	O
fat_len	int
>=	O
NEEDED_FAT_SIZE	O
(	O
Fs	pointer
)	O
)	O
return	O
;	O
}	O
}	O
fprintf	function
(	O
stderr	pointer
,	O
"Internal error while calculating Xdf fat size\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
static	O
void	O
calc_fat_size	function
(	O
Fs_t	struct
*	O
Fs	pointer
,	O
unsigned	O
long	O
tot_sectors	long
)	O
{	O
unsigned	O
long	O
rem_sect	long
;	O
unsigned	O
long	O
real_rem_sect	long
;	O
unsigned	O
long	O
numerator	long
;	O
unsigned	O
long	O
denominator	long
;	O
unsigned	O
int	O
fat_nybbles	int
;	O
unsigned	O
int	O
slack	int
;	O
int	O
printGrowMsg	int
=	O
1	int
;	O
real_rem_sect	long
=	O
rem_sect	long
=	O
tot_sectors	long
-	O
Fs	pointer
->	O
dir_len	int
-	O
Fs	pointer
->	O
fat_start	int
;	O
if	O
(	O
rem_sect	long
%	O
2	int
==	O
1	int
&&	O
Fs	pointer
->	O
num_fat	int
%	O
2	int
==	O
0	int
&&	O
Fs	pointer
->	O
cluster_size	int
%	O
2	int
==	O
0	int
)	O
rem_sect	long
--	O
;	O
if	O
(	O
Fs	pointer
->	O
fat_bits	int
==	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Weird, fat bits = 0\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
fat_nybbles	int
=	O
Fs	pointer
->	O
fat_bits	int
/	O
4	int
;	O
numerator	long
=	O
rem_sect	long
+	O
2	int
*	O
Fs	pointer
->	O
cluster_size	int
;	O
denominator	long
=	O
Fs	pointer
->	O
cluster_size	int
*	O
Fs	pointer
->	O
sector_size	int
*	O
2	int
+	O
Fs	pointer
->	O
num_fat	int
*	O
fat_nybbles	int
;	O
if	O
(	O
fat_nybbles	int
==	O
3	int
)	O
numerator	long
*=	O
fat_nybbles	int
;	O
else	O
denominator	long
=	O
denominator	long
/	O
fat_nybbles	int
;	O
Fs	pointer
->	O
fat_len	int
=	O
(	O
numerator	long
-	O
1	int
)	O
/	O
denominator	long
+	O
1	int
;	O
Fs	pointer
->	O
num_clus	int
=	O
(	O
rem_sect	long
-	O
(	O
Fs	pointer
->	O
fat_len	int
*	O
Fs	pointer
->	O
num_fat	int
)	O
)	O
/	O
Fs	pointer
->	O
cluster_size	int
;	O
if	O
(	O
Fs	pointer
->	O
fat_bits	int
==	O
16	int
&&	O
Fs	pointer
->	O
num_clus	int
>=	O
FAT16	int
)	O
Fs	pointer
->	O
num_clus	int
=	O
FAT16	int
-	O
1	int
;	O
if	O
(	O
Fs	pointer
->	O
fat_bits	int
==	O
12	int
&&	O
Fs	pointer
->	O
num_clus	int
>=	O
FAT12	int
)	O
Fs	pointer
->	O
num_clus	int
=	O
FAT12	int
-	O
1	int
;	O
if	O
(	O
Fs	pointer
->	O
num_clus	int
>	O
(	O
Fs	pointer
->	O
fat_len	int
*	O
Fs	pointer
->	O
sector_size	int
*	O
2	int
/	O
fat_nybbles	int
-	O
2	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Fat size miscalculation, shrinking num_clus from %d "	pointer
,	O
Fs	pointer
->	O
num_clus	int
)	O
;	O
Fs	pointer
->	O
num_clus	int
=	O
(	O
Fs	pointer
->	O
fat_len	int
*	O
Fs	pointer
->	O
sector_size	int
*	O
2	int
/	O
fat_nybbles	int
-	O
2	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
" to %d\n"	pointer
,	O
Fs	pointer
->	O
num_clus	int
)	O
;	O
}	O
if	O
(	O
Fs	pointer
->	O
num_clus	int
<	O
FAT16	int
&&	O
Fs	pointer
->	O
fat_bits	int
>	O
16	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Too few clusters for this fat size."	pointer
" Please choose a 16-bit fat in your /etc/mtools.conf"	pointer
" or .mtoolsrc file\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
assert	O
(	O
rem_sect	long
>=	O
Fs	pointer
->	O
num_clus	int
*	O
Fs	pointer
->	O
cluster_size	int
+	O
Fs	pointer
->	O
fat_len	int
*	O
Fs	pointer
->	O
num_fat	int
)	O
;	O
slack	int
=	O
rem_sect	long
-	O
Fs	pointer
->	O
num_clus	int
*	O
Fs	pointer
->	O
cluster_size	int
-	O
Fs	pointer
->	O
fat_len	int
*	O
Fs	pointer
->	O
num_fat	int
;	O
if	O
(	O
slack	int
>=	O
Fs	pointer
->	O
cluster_size	int
)	O
{	O
if	O
(	O
printGrowMsg	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Slack=%d\n"	pointer
,	O
slack	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Growing fat size from %d"	pointer
,	O
Fs	pointer
->	O
fat_len	int
)	O
;	O
}	O
Fs	pointer
->	O
fat_len	int
+=	O
(	O
slack	int
-	O
Fs	pointer
->	O
cluster_size	int
)	O
/	O
Fs	pointer
->	O
num_fat	int
+	O
1	int
;	O
if	O
(	O
printGrowMsg	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
" to %d in order to take up excess cluster area\n"	pointer
,	O
Fs	pointer
->	O
fat_len	int
)	O
;	O
}	O
Fs	pointer
->	O
num_clus	int
=	O
(	O
rem_sect	long
-	O
(	O
Fs	pointer
->	O
fat_len	int
*	O
Fs	pointer
->	O
num_fat	int
)	O
)	O
/	O
Fs	pointer
->	O
cluster_size	int
;	O
}	O
assert	O
(	O
(	O
(	O
Fs	pointer
->	O
num_clus	int
+	O
2	int
)	O
*	O
fat_nybbles	int
)	O
<=	O
(	O
Fs	pointer
->	O
fat_len	int
*	O
Fs	pointer
->	O
sector_size	int
*	O
2	int
)	O
)	O
;	O
assert	O
(	O
Fs	pointer
->	O
num_clus	int
==	O
(	O
real_rem_sect	long
-	O
Fs	pointer
->	O
num_fat	int
*	O
Fs	pointer
->	O
fat_len	int
)	O
/	O
Fs	pointer
->	O
cluster_size	int
)	O
;	O
}	O
static	O
unsigned	O
char	O
bootprog	array
[	O
]	O
=	O
{	O
0xfa	int
,	O
0x31	int
,	O
0xc0	int
,	O
0x8e	int
,	O
0xd8	int
,	O
0x8e	int
,	O
0xc0	int
,	O
0xfc	int
,	O
0xb9	int
,	O
0x00	int
,	O
0x01	int
,	O
0xbe	int
,	O
0x00	int
,	O
0x7c	int
,	O
0xbf	int
,	O
0x00	int
,	O
0x80	int
,	O
0xf3	int
,	O
0xa5	int
,	O
0xea	int
,	O
0x00	int
,	O
0x00	int
,	O
0x00	int
,	O
0x08	int
,	O
0xb8	int
,	O
0x01	int
,	O
0x02	int
,	O
0xbb	int
,	O
0x00	int
,	O
0x7c	int
,	O
0xba	int
,	O
0x80	int
,	O
0x00	int
,	O
0xb9	int
,	O
0x01	int
,	O
0x00	int
,	O
0xcd	int
,	O
0x13	int
,	O
0x72	int
,	O
0x05	int
,	O
0xea	int
,	O
0x00	int
,	O
0x7c	int
,	O
0x00	int
,	O
0x00	int
,	O
0xcd	int
,	O
0x19	int
}	O
;	O
static	O
__inline__	O
void	O
inst_boot_prg	function
(	O
union	O
bootsector	union
*	O
boot	struct
,	O
int	O
offset	long
)	O
{	O
memcpy	function
(	O
(	O
char	O
*	O
)	O
boot	struct
->	O
boot	struct
.	O
jump	array
+	O
offset	long
,	O
(	O
char	O
*	O
)	O
bootprog	array
,	O
sizeof	O
(	O
bootprog	array
)	O
/	O
sizeof	O
(	O
bootprog	array
[	O
0	int
]	O
)	O
)	O
;	O
if	O
(	O
offset	long
-	O
2	int
<	O
0x80	int
)	O
{	O
boot	struct
->	O
boot	struct
.	O
jump	array
[	O
0	int
]	O
=	O
0xeb	int
;	O
boot	struct
->	O
boot	struct
.	O
jump	array
[	O
1	int
]	O
=	O
offset	long
-	O
2	int
;	O
boot	struct
->	O
boot	struct
.	O
jump	array
[	O
2	int
]	O
=	O
0x90	int
;	O
}	O
else	O
{	O
boot	struct
->	O
boot	struct
.	O
jump	array
[	O
0	int
]	O
=	O
0xe9	int
;	O
boot	struct
->	O
boot	struct
.	O
jump	array
[	O
1	int
]	O
=	O
offset	long
-	O
3	int
;	O
boot	struct
->	O
boot	struct
.	O
jump	array
[	O
2	int
]	O
=	O
0x00	int
;	O
}	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
jump	array
+	O
offset	long
+	O
20	int
,	O
offset	long
+	O
24	int
)	O
;	O
}	O
static	O
void	O
calc_cluster_size	function
(	O
struct	O
Fs_t	struct
*	O
Fs	pointer
,	O
unsigned	O
long	O
tot_sectors	long
,	O
int	O
fat_bits	int
)	O
{	O
unsigned	O
int	O
max_clusters	int
;	O
unsigned	O
int	O
max_fat_size	int
;	O
unsigned	O
int	O
rem_sect	long
;	O
switch	O
(	O
abs	function
(	O
fat_bits	int
)	O
)	O
{	O
case	O
12	int
:	O
max_clusters	int
=	O
FAT12	int
-	O
1	int
;	O
max_fat_size	int
=	O
Fs	pointer
->	O
num_fat	int
*	O
FAT_SIZE	O
(	O
12	int
,	O
Fs	pointer
->	O
sector_size	int
,	O
max_clusters	int
)	O
;	O
break	O
;	O
case	O
16	int
:	O
case	O
0	int
:	O
max_clusters	int
=	O
FAT16	int
-	O
1	int
;	O
max_fat_size	int
=	O
Fs	pointer
->	O
num_fat	int
*	O
FAT_SIZE	O
(	O
16	int
,	O
Fs	pointer
->	O
sector_size	int
,	O
max_clusters	int
)	O
;	O
break	O
;	O
case	O
32	int
:	O
Fs	pointer
->	O
cluster_size	int
=	O
tot_sectors	long
>	O
32	int
*	O
1024	int
*	O
1024	int
*	O
2	int
?	O
64	int
:	O
tot_sectors	long
>	O
16	int
*	O
1024	int
*	O
1024	int
*	O
2	int
?	O
32	int
:	O
tot_sectors	long
>	O
8	int
*	O
1024	int
*	O
1024	int
*	O
2	int
?	O
16	int
:	O
tot_sectors	long
>	O
260	int
*	O
1024	int
*	O
2	int
?	O
8	int
:	O
1	int
;	O
return	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Bad fat size\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
tot_sectors	long
<=	O
Fs	pointer
->	O
fat_start	int
+	O
Fs	pointer
->	O
num_fat	int
+	O
Fs	pointer
->	O
dir_len	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Not enough sectors\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
rem_sect	long
=	O
tot_sectors	long
-	O
Fs	pointer
->	O
dir_len	int
-	O
Fs	pointer
->	O
fat_start	int
;	O
while	O
(	O
Fs	pointer
->	O
cluster_size	int
*	O
max_clusters	int
+	O
max_fat_size	int
<	O
rem_sect	long
)	O
{	O
if	O
(	O
Fs	pointer
->	O
cluster_size	int
>	O
64	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Internal error while calculating cluster size\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
Fs	pointer
->	O
cluster_size	int
<<=	O
1	int
;	O
}	O
}	O
static	O
int	O
old_dos_size_to_geom	function
(	O
size_t	long
size	array
,	O
unsigned	O
int	O
*	O
cyls	short
,	O
unsigned	O
short	O
*	O
heads	short
,	O
unsigned	O
short	O
*	O
sects	pointer
)	O
{	O
struct	O
OldDos_t	struct
*	O
params	pointer
=	O
getOldDosBySize	function
(	O
size	array
)	O
;	O
if	O
(	O
params	pointer
!=	O
NULL	O
)	O
{	O
*	O
cyls	short
=	O
params	pointer
->	O
tracks	int
;	O
*	O
heads	short
=	O
params	pointer
->	O
heads	short
;	O
*	O
sects	pointer
=	O
params	pointer
->	O
sectors	short
;	O
return	O
0	int
;	O
}	O
else	O
return	O
1	int
;	O
}	O
static	O
void	O
calc_fs_parameters	function
(	O
struct	O
device	struct
*	O
dev	pointer
,	O
unsigned	O
long	O
tot_sectors	long
,	O
struct	O
Fs_t	struct
*	O
Fs	pointer
,	O
union	O
bootsector	union
*	O
boot	struct
)	O
{	O
struct	O
OldDos_t	struct
*	O
params	pointer
=	O
NULL	O
;	O
if	O
(	O
dev	pointer
->	O
fat_bits	int
==	O
0	int
||	O
abs	function
(	O
dev	pointer
->	O
fat_bits	int
)	O
==	O
12	int
)	O
params	pointer
=	O
getOldDosByParams	function
(	O
dev	pointer
->	O
tracks	int
,	O
dev	pointer
->	O
heads	short
,	O
dev	pointer
->	O
sectors	short
,	O
Fs	pointer
->	O
dir_len	int
,	O
Fs	pointer
->	O
cluster_size	int
)	O
;	O
if	O
(	O
params	pointer
!=	O
NULL	O
)	O
{	O
boot	struct
->	O
boot	struct
.	O
descr	char
=	O
params	pointer
->	O
media	char
;	O
Fs	pointer
->	O
cluster_size	int
=	O
params	pointer
->	O
cluster_size	int
;	O
Fs	pointer
->	O
dir_len	int
=	O
params	pointer
->	O
dir_len	int
;	O
Fs	pointer
->	O
fat_len	int
=	O
params	pointer
->	O
fat_len	int
;	O
Fs	pointer
->	O
fat_bits	int
=	O
12	int
;	O
}	O
else	O
{	O
int	O
may_change_cluster_size	int
=	O
(	O
Fs	pointer
->	O
cluster_size	int
==	O
0	int
)	O
;	O
int	O
may_change_root_size	int
=	O
(	O
Fs	pointer
->	O
dir_len	int
==	O
0	int
)	O
;	O
if	O
(	O
DWORD	O
(	O
nhs	array
)	O
||	O
tot_sectors	long
%	O
(	O
dev	pointer
->	O
sectors	short
*	O
dev	pointer
->	O
heads	short
)	O
)	O
boot	struct
->	O
boot	struct
.	O
descr	char
=	O
0xf8	int
;	O
else	O
boot	struct
->	O
boot	struct
.	O
descr	char
=	O
0xf0	int
;	O
if	O
(	O
!	O
Fs	pointer
->	O
cluster_size	int
)	O
{	O
if	O
(	O
dev	pointer
->	O
heads	short
==	O
1	int
)	O
Fs	pointer
->	O
cluster_size	int
=	O
1	int
;	O
else	O
{	O
Fs	pointer
->	O
cluster_size	int
=	O
(	O
tot_sectors	long
>	O
2000	int
)	O
?	O
1	int
:	O
2	int
;	O
if	O
(	O
dev	pointer
->	O
use_2m	int
&	O
0x7f	int
)	O
Fs	pointer
->	O
cluster_size	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
!	O
Fs	pointer
->	O
dir_len	int
)	O
{	O
if	O
(	O
dev	pointer
->	O
heads	short
==	O
1	int
)	O
Fs	pointer
->	O
dir_len	int
=	O
4	int
;	O
else	O
Fs	pointer
->	O
dir_len	int
=	O
(	O
tot_sectors	long
>	O
2000	int
)	O
?	O
32	int
:	O
7	int
;	O
}	O
calc_cluster_size	function
(	O
Fs	pointer
,	O
tot_sectors	long
,	O
dev	pointer
->	O
fat_bits	int
)	O
;	O
if	O
(	O
Fs	pointer
->	O
fat_len	int
)	O
xdf_calc_fat_size	function
(	O
Fs	pointer
,	O
tot_sectors	long
,	O
dev	pointer
->	O
fat_bits	int
)	O
;	O
else	O
{	O
calc_fat_bits2	function
(	O
Fs	pointer
,	O
tot_sectors	long
,	O
dev	pointer
->	O
fat_bits	int
,	O
may_change_cluster_size	int
,	O
may_change_root_size	int
)	O
;	O
calc_fat_size	function
(	O
Fs	pointer
,	O
tot_sectors	long
)	O
;	O
}	O
}	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
fatlen	array
,	O
Fs	pointer
->	O
fat_len	int
)	O
;	O
}	O
static	O
void	O
calc_fs_parameters_32	function
(	O
unsigned	O
long	O
tot_sectors	long
,	O
struct	O
Fs_t	struct
*	O
Fs	pointer
,	O
union	O
bootsector	union
*	O
boot	struct
)	O
{	O
unsigned	O
long	O
num_clus	int
;	O
if	O
(	O
DWORD	O
(	O
nhs	array
)	O
)	O
boot	struct
->	O
boot	struct
.	O
descr	char
=	O
0xf8	int
;	O
else	O
boot	struct
->	O
boot	struct
.	O
descr	char
=	O
0xf0	int
;	O
if	O
(	O
!	O
Fs	pointer
->	O
cluster_size	int
)	O
calc_cluster_size	function
(	O
Fs	pointer
,	O
tot_sectors	long
,	O
32	int
)	O
;	O
Fs	pointer
->	O
dir_len	int
=	O
0	int
;	O
num_clus	int
=	O
tot_sectors	long
/	O
Fs	pointer
->	O
cluster_size	int
;	O
if	O
(	O
num_clus	int
>	O
0xffffff6	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Too many clusters\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
Fs	pointer
->	O
num_clus	int
=	O
(	O
unsigned	O
int	O
)	O
num_clus	int
;	O
set_fat32	function
(	O
Fs	pointer
)	O
;	O
calc_fat_size	function
(	O
Fs	pointer
,	O
tot_sectors	long
)	O
;	O
set_word	function
(	O
boot	struct
->	O
boot	struct
.	O
fatlen	array
,	O
0	int
)	O
;	O
set_dword	function
(	O
boot	struct
->	O
boot	struct
.	O
ext	array
.	O
fat32	struct
.	O
bigFat	array
,	O
Fs	pointer
->	O
fat_len	int
)	O
;	O
}	O
static	O
void	O
usage	function
(	O
int	O
ret	int
)	O
NORETURN	O
;	O
static	O
void	O
usage	function
(	O
int	O
ret	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Mtools version %s, dated %s\n"	pointer
,	O
mversion	pointer
,	O
mdate	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Usage: %s [-V] [-t tracks] [-h heads] [-n sectors] "	pointer
"[-v label] [-1] [-4] [-8] [-f size] "	pointer
"[-N serialnumber] "	pointer
"[-k] [-B bootsector] [-r root_dir_len] [-L fat_len] "	pointer
"[-F] [-I fsVersion] [-C] [-c cluster_size] "	pointer
"[-H hidden_sectors] "	pointer
"[-X] "	pointer
"[-S hardsectorsize] [-M softsectorsize] [-3] "	pointer
"[-2 track0sectors] [-0 rate0] [-A rateany] [-a]"	pointer
"device\n"	pointer
,	O
progname	pointer
)	O
;	O
exit	function
(	O
ret	int
)	O
;	O
}	O
static	O
int	O
get_sector_size	function
(	O
int	O
fd	int
,	O
char	O
*	O
errmsg	pointer
)	O
{	O
int	O
sec_size	int
;	O
if	O
(	O
ioctl	function
(	O
fd	int
,	O
BLKSSZGET	O
,	O
&	O
sec_size	int
)	O
!=	O
0	int
||	O
sec_size	int
<=	O
0	int
)	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"Could not get sector size of device (%s)"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
sec_size	int
>	O
4096	int
)	O
sec_size	int
=	O
4096	int
;	O
return	O
sec_size	int
;	O
}	O
static	O
int	O
get_block_geom	function
(	O
int	O
fd	int
,	O
struct	O
device	struct
*	O
dev	pointer
,	O
char	O
*	O
errmsg	pointer
)	O
{	O
struct	O
hd_geometry	struct
geom	struct
;	O
int	O
sec_size	int
;	O
long	O
size	array
;	O
uint16_t	short
heads	short
=	O
dev	pointer
->	O
heads	short
;	O
uint16_t	short
sectors	short
=	O
dev	pointer
->	O
sectors	short
;	O
unsigned	O
int	O
sect_per_track	int
;	O
if	O
(	O
ioctl	function
(	O
fd	int
,	O
HDIO_GETGEO	int
,	O
&	O
geom	struct
)	O
<	O
0	int
)	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"Could not get geometry of device (%s)"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
ioctl	function
(	O
fd	int
,	O
BLKGETSIZE	O
,	O
&	O
size	array
)	O
<	O
0	int
)	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"Could not get size of device (%s)"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
sec_size	int
=	O
get_sector_size	function
(	O
fd	int
,	O
errmsg	pointer
)	O
;	O
if	O
(	O
sec_size	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
dev	pointer
->	O
ssize	char
=	O
0	int
;	O
while	O
(	O
dev	pointer
->	O
ssize	char
<	O
0x7F	int
&&	O
(	O
128	int
<<	O
dev	pointer
->	O
ssize	char
)	O
<	O
sec_size	int
)	O
dev	pointer
->	O
ssize	char
++	O
;	O
if	O
(	O
!	O
heads	short
)	O
heads	short
=	O
geom	struct
.	O
heads	short
;	O
if	O
(	O
!	O
sectors	short
)	O
sectors	short
=	O
geom	struct
.	O
sectors	short
;	O
sect_per_track	int
=	O
heads	short
*	O
sectors	short
;	O
if	O
(	O
!	O
dev	pointer
->	O
hidden	int
)	O
{	O
unsigned	O
long	O
hidden	int
;	O
hidden	int
=	O
geom	struct
.	O
start	array
%	O
sect_per_track	int
;	O
if	O
(	O
hidden	int
&&	O
hidden	int
!=	O
sectors	short
)	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"Hidden (%ld) does not match sectors (%d)\n"	pointer
,	O
hidden	int
,	O
sectors	short
)	O
;	O
return	O
-	O
1	int
;	O
}	O
dev	pointer
->	O
hidden	int
=	O
hidden	int
;	O
}	O
dev	pointer
->	O
heads	short
=	O
heads	short
;	O
dev	pointer
->	O
sectors	short
=	O
sectors	short
;	O
if	O
(	O
!	O
dev	pointer
->	O
tracks	int
)	O
dev	pointer
->	O
tracks	int
=	O
(	O
size	array
+	O
dev	pointer
->	O
hidden	int
%	O
sect_per_track	int
)	O
/	O
sect_per_track	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
get_lba_geom	function
(	O
Stream_t	struct
*	O
Direct	pointer
,	O
unsigned	O
long	O
tot_sectors	long
,	O
struct	O
device	struct
*	O
dev	pointer
,	O
char	O
*	O
errmsg	pointer
)	O
{	O
int	O
sect_per_track	int
;	O
unsigned	O
long	O
tracks	int
;	O
if	O
(	O
dev	pointer
->	O
heads	short
||	O
dev	pointer
->	O
sectors	short
||	O
dev	pointer
->	O
tracks	int
)	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"Number of heads or sectors or tracks was already specified"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
!	O
tot_sectors	long
)	O
{	O
int	O
fd	int
;	O
int	O
sec_size	int
;	O
long	O
size	array
;	O
struct	O
MT_STAT	O
stbuf	struct
;	O
fd	int
=	O
get_fd	function
(	O
Direct	pointer
)	O
;	O
if	O
(	O
MT_FSTAT	O
(	O
fd	int
,	O
&	O
stbuf	struct
)	O
<	O
0	int
)	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"Could not stat file (%s)"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
S_ISBLK	O
(	O
stbuf	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
ioctl	function
(	O
fd	int
,	O
BLKGETSIZE	O
,	O
&	O
size	array
)	O
!=	O
0	int
)	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"Could not get size of device (%s)"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
sec_size	int
=	O
get_sector_size	function
(	O
fd	int
,	O
errmsg	pointer
)	O
;	O
if	O
(	O
sec_size	int
<	O
0	int
)	O
return	O
-	O
1	int
;	O
if	O
(	O
!	O
(	O
dev	pointer
->	O
ssize	char
&	O
0x80	int
)	O
)	O
{	O
dev	pointer
->	O
ssize	char
=	O
0	int
;	O
while	O
(	O
dev	pointer
->	O
ssize	char
<	O
0x7F	int
&&	O
(	O
128	int
<<	O
dev	pointer
->	O
ssize	char
)	O
<	O
sec_size	int
)	O
dev	pointer
->	O
ssize	char
++	O
;	O
}	O
if	O
(	O
(	O
dev	pointer
->	O
ssize	char
&	O
0x7f	int
)	O
>	O
2	int
)	O
tot_sectors	long
=	O
size	array
>>	O
(	O
(	O
dev	pointer
->	O
ssize	char
&	O
0x7f	int
)	O
-	O
2	int
)	O
;	O
else	O
tot_sectors	long
=	O
size	array
<<	O
(	O
2	int
-	O
(	O
dev	pointer
->	O
ssize	char
&	O
0x7f	int
)	O
)	O
;	O
}	O
else	O
if	O
(	O
S_ISREG	O
(	O
stbuf	struct
.	O
st_mode	int
)	O
)	O
{	O
tot_sectors	long
=	O
stbuf	struct
.	O
st_size	long
>>	O
(	O
(	O
dev	pointer
->	O
ssize	char
&	O
0x7f	int
)	O
+	O
7	int
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"Could not get size of device (%s)"	pointer
,	O
"No method available"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
dev	pointer
->	O
sectors	short
=	O
63	int
;	O
if	O
(	O
tot_sectors	long
<	O
16	int
*	O
63	int
*	O
1024	int
)	O
dev	pointer
->	O
heads	short
=	O
16	int
;	O
else	O
if	O
(	O
tot_sectors	long
<	O
32	int
*	O
63	int
*	O
1024	int
)	O
dev	pointer
->	O
heads	short
=	O
32	int
;	O
else	O
if	O
(	O
tot_sectors	long
<	O
64	int
*	O
63	int
*	O
1024	int
)	O
dev	pointer
->	O
heads	short
=	O
64	int
;	O
else	O
if	O
(	O
tot_sectors	long
<	O
128	int
*	O
63	int
*	O
1024	int
)	O
dev	pointer
->	O
heads	short
=	O
128	int
;	O
else	O
dev	pointer
->	O
heads	short
=	O
255	int
;	O
sect_per_track	int
=	O
dev	pointer
->	O
heads	short
*	O
dev	pointer
->	O
sectors	short
;	O
tracks	int
=	O
(	O
tot_sectors	long
+	O
dev	pointer
->	O
hidden	int
%	O
sect_per_track	int
)	O
/	O
sect_per_track	int
;	O
if	O
(	O
tracks	int
>	O
0xFFFFFFFF	int
)	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"Device is too big, it has too many tracks"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
dev	pointer
->	O
tracks	int
=	O
(	O
uint32_t	int
)	O
tracks	int
;	O
return	O
0	int
;	O
}	O
void	O
mformat	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
dummy	array
UNUSEDP	O
)	O
NORETURN	O
;	O
void	O
mformat	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
dummy	array
UNUSEDP	O
)	O
{	O
int	O
r	int
;	O
Fs_t	struct
Fs	pointer
;	O
unsigned	O
int	O
hs	int
;	O
int	O
hs_set	int
;	O
unsigned	O
int	O
arguse_2m	int
=	O
0	int
;	O
uint8_t	char
sectors0	char
=	O
18	int
;	O
int	O
create	int
=	O
0	int
;	O
uint8_t	char
rate_0	char
,	O
rate_any	char
;	O
int	O
mangled	pointer
;	O
uint8_t	char
argssize	char
=	O
0	int
;	O
int	O
msize	int
=	O
0	int
;	O
int	O
fat32	struct
=	O
0	int
;	O
struct	O
label_blk_t	struct
*	O
labelBlock	struct
;	O
int	O
bootOffset	int
;	O
unsigned	O
int	O
i	short
;	O
int	O
format_xdf	int
=	O
0	int
;	O
struct	O
xdf_info	struct
info	pointer
;	O
union	O
bootsector	union
boot	struct
;	O
char	O
*	O
bootSector	pointer
=	O
0	int
;	O
int	O
c	char
;	O
int	O
keepBoot	int
=	O
0	int
;	O
struct	O
device	struct
used_dev	pointer
;	O
unsigned	O
int	O
argtracks	int
;	O
uint16_t	short
argheads	short
,	O
argsectors	short
;	O
unsigned	O
long	O
tot_sectors	long
=	O
0	int
;	O
int	O
blocksize	int
;	O
char	O
drive	char
,	O
name	pointer
[	O
EXPAND_BUF	int
]	O
;	O
char	O
label	array
[	O
VBUFSIZE	O
]	O
;	O
dos_name_t	struct
shortlabel	struct
;	O
struct	O
device	struct
*	O
dev	pointer
;	O
char	O
errmsg	pointer
[	O
2100	int
]	O
;	O
uint32_t	int
serial	array
;	O
int	O
serial_set	int
;	O
int	O
fsVersion	array
;	O
int	O
mediaDesc	int
=	O
-	O
1	int
;	O
mt_size_t	long
maxSize	pointer
;	O
int	O
Atari	int
=	O
0	int
;	O
unsigned	O
int	O
backupBoot	array
=	O
6	int
;	O
int	O
backupBootSet	int
=	O
0	int
;	O
unsigned	O
int	O
resvSects	int
=	O
0	int
;	O
char	O
*	O
endptr	pointer
;	O
hs	int
=	O
hs_set	int
=	O
0	int
;	O
argtracks	int
=	O
0	int
;	O
argheads	short
=	O
0	int
;	O
argsectors	short
=	O
0	int
;	O
arguse_2m	int
=	O
0	int
;	O
argssize	char
=	O
0x2	int
;	O
label	array
[	O
0	int
]	O
=	O
'\0'	O
;	O
serial_set	int
=	O
0	int
;	O
serial	array
=	O
0	int
;	O
fsVersion	array
=	O
0	int
;	O
Fs	pointer
.	O
cluster_size	int
=	O
0	int
;	O
Fs	pointer
.	O
refs	int
=	O
1	int
;	O
Fs	pointer
.	O
dir_len	int
=	O
0	int
;	O
if	O
(	O
getenv	function
(	O
"MTOOLS_DIR_LEN"	pointer
)	O
)	O
{	O
Fs	pointer
.	O
dir_len	int
=	O
atoui	function
(	O
getenv	function
(	O
"MTOOLS_DIR_LEN"	pointer
)	O
)	O
;	O
if	O
(	O
Fs	pointer
.	O
dir_len	int
<=	O
0	int
)	O
Fs	pointer
.	O
dir_len	int
=	O
0	int
;	O
}	O
Fs	pointer
.	O
fat_len	int
=	O
0	int
;	O
Fs	pointer
.	O
num_fat	int
=	O
2	int
;	O
if	O
(	O
getenv	function
(	O
"MTOOLS_NFATS"	pointer
)	O
)	O
{	O
Fs	pointer
.	O
num_fat	int
=	O
atoui	function
(	O
getenv	function
(	O
"MTOOLS_NFATS"	pointer
)	O
)	O
;	O
if	O
(	O
Fs	pointer
.	O
num_fat	int
<=	O
0	int
)	O
Fs	pointer
.	O
num_fat	int
=	O
2	int
;	O
}	O
Fs	pointer
.	O
Class	pointer
=	O
&	O
FsClass	struct
;	O
rate_0	char
=	O
mtools_rate_0	char
;	O
rate_any	char
=	O
mtools_rate_any	char
;	O
if	O
(	O
helpFlag	function
(	O
argc	int
,	O
argv	pointer
)	O
)	O
usage	function
(	O
0	int
)	O
;	O
while	O
(	O
(	O
c	char
=	O
getopt	function
(	O
argc	int
,	O
argv	pointer
,	O
"i:148f:t:n:v:qub"	pointer
"kK:R:B:r:L:I:FCc:Xh:s:T:l:N:H:M:S:2:30:Aad:m:"	pointer
)	O
)	O
!=	O
EOF	O
)	O
{	O
endptr	pointer
=	O
NULL	O
;	O
switch	O
(	O
c	char
)	O
{	O
case	O
'i'	O
:	O
set_cmd_line_image	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'1'	O
:	O
argheads	short
=	O
1	int
;	O
break	O
;	O
case	O
'4'	O
:	O
argsectors	short
=	O
9	int
;	O
argtracks	int
=	O
40	int
;	O
break	O
;	O
case	O
'8'	O
:	O
argsectors	short
=	O
8	int
;	O
argtracks	int
=	O
40	int
;	O
break	O
;	O
case	O
'f'	O
:	O
r	int
=	O
old_dos_size_to_geom	function
(	O
atoul	function
(	O
optarg	pointer
)	O
,	O
&	O
argtracks	int
,	O
&	O
argheads	short
,	O
&	O
argsectors	short
)	O
;	O
if	O
(	O
r	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Bad size %s\n"	pointer
,	O
optarg	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
't'	O
:	O
argtracks	int
=	O
atou16	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'T'	O
:	O
tot_sectors	long
=	O
atoui	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'n'	O
:	O
case	O
's'	O
:	O
argsectors	short
=	O
atou16	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'l'	O
:	O
case	O
'v'	O
:	O
strncpy	function
(	O
label	array
,	O
optarg	pointer
,	O
VBUFSIZE	O
-	O
1	int
)	O
;	O
label	array
[	O
VBUFSIZE	O
-	O
1	int
]	O
=	O
'\0'	O
;	O
break	O
;	O
case	O
'q'	O
:	O
case	O
'u'	O
:	O
case	O
'b'	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Flag %c not supported by mtools\n"	pointer
,	O
c	char
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
case	O
'F'	O
:	O
fat32	struct
=	O
1	int
;	O
break	O
;	O
case	O
'S'	O
:	O
argssize	char
=	O
atou8	function
(	O
optarg	pointer
)	O
|	O
0x80	int
;	O
if	O
(	O
argssize	char
<	O
0x80	int
)	O
usage	function
(	O
1	int
)	O
;	O
if	O
(	O
argssize	char
>=	O
0x87	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"argssize must be less than 6\n"	pointer
)	O
;	O
usage	function
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'X'	O
:	O
format_xdf	int
=	O
1	int
;	O
break	O
;	O
case	O
'2'	O
:	O
arguse_2m	int
=	O
0xff	int
;	O
sectors0	char
=	O
atou8	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'3'	O
:	O
arguse_2m	int
=	O
0x80	int
;	O
break	O
;	O
case	O
'0'	O
:	O
rate_0	char
=	O
atou8	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'A'	O
:	O
rate_any	char
=	O
atou8	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'M'	O
:	O
msize	int
=	O
atoi	function
(	O
optarg	pointer
)	O
;	O
if	O
(	O
msize	int
!=	O
512	int
&&	O
msize	int
!=	O
1024	int
&&	O
msize	int
!=	O
2048	int
&&	O
msize	int
!=	O
4096	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Only sector sizes of 512, 1024, 2048 or 4096 bytes are allowed\n"	pointer
)	O
;	O
usage	function
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'N'	O
:	O
serial	array
=	O
strtou32	function
(	O
optarg	pointer
,	O
&	O
endptr	pointer
,	O
16	int
)	O
;	O
serial_set	int
=	O
1	int
;	O
break	O
;	O
case	O
'a'	O
:	O
Atari	int
=	O
1	int
;	O
break	O
;	O
case	O
'C'	O
:	O
create	int
=	O
O_CREAT	int
|	O
O_TRUNC	int
;	O
break	O
;	O
case	O
'H'	O
:	O
hs	int
=	O
atoui	function
(	O
optarg	pointer
)	O
;	O
hs_set	int
=	O
1	int
;	O
break	O
;	O
case	O
'I'	O
:	O
fsVersion	array
=	O
strtoi	function
(	O
optarg	pointer
,	O
&	O
endptr	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'c'	O
:	O
Fs	pointer
.	O
cluster_size	int
=	O
atoui	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'r'	O
:	O
Fs	pointer
.	O
dir_len	int
=	O
strtoui	function
(	O
optarg	pointer
,	O
&	O
endptr	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'L'	O
:	O
Fs	pointer
.	O
fat_len	int
=	O
strtoui	function
(	O
optarg	pointer
,	O
&	O
endptr	pointer
,	O
0	int
)	O
;	O
break	O
;	O
case	O
'B'	O
:	O
bootSector	pointer
=	O
optarg	pointer
;	O
break	O
;	O
case	O
'k'	O
:	O
keepBoot	int
=	O
1	int
;	O
break	O
;	O
case	O
'K'	O
:	O
backupBoot	array
=	O
atoui	function
(	O
optarg	pointer
)	O
;	O
backupBootSet	int
=	O
1	int
;	O
if	O
(	O
backupBoot	array
<	O
2	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Backupboot must be greater than 2\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
'R'	O
:	O
resvSects	int
=	O
atoui	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'h'	O
:	O
argheads	short
=	O
atou16	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'd'	O
:	O
Fs	pointer
.	O
num_fat	int
=	O
atoui	function
(	O
optarg	pointer
)	O
;	O
break	O
;	O
case	O
'm'	O
:	O
mediaDesc	int
=	O
strtoi	function
(	O
optarg	pointer
,	O
&	O
endptr	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
endptr	pointer
)	O
mediaDesc	int
=	O
strtoi	function
(	O
optarg	pointer
,	O
&	O
endptr	pointer
,	O
16	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
endptr	pointer
&&	O
*	O
endptr	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Bad number %s\n"	pointer
,	O
optarg	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
argc	int
-	O
optind	int
>	O
1	int
)	O
usage	function
(	O
1	int
)	O
;	O
if	O
(	O
argc	int
-	O
optind	int
==	O
1	int
)	O
{	O
if	O
(	O
!	O
argv	pointer
[	O
optind	int
]	O
[	O
0	int
]	O
||	O
argv	pointer
[	O
optind	int
]	O
[	O
1	int
]	O
!=	O
':'	O
)	O
usage	function
(	O
1	int
)	O
;	O
drive	char
=	O
ch_toupper	function
(	O
argv	pointer
[	O
argc	int
-	O
1	int
]	O
[	O
0	int
]	O
)	O
;	O
}	O
else	O
{	O
drive	char
=	O
get_default_drive	function
(	O
)	O
;	O
if	O
(	O
drive	char
!=	O
':'	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Drive letter missing\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
argtracks	int
&&	O
tot_sectors	long
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Only one of -t or -T may be specified\n"	pointer
)	O
;	O
usage	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
create	int
&&	O
format_xdf	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Create and XDF can't be used together\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
sprintf	function
(	O
errmsg	pointer
,	O
"Drive '%c:' not supported"	pointer
,	O
drive	char
)	O
;	O
Fs	pointer
.	O
Direct	pointer
=	O
NULL	O
;	O
blocksize	int
=	O
0	int
;	O
for	O
(	O
dev	pointer
=	O
devices	pointer
;	O
dev	pointer
->	O
drive	char
;	O
dev	pointer
++	O
)	O
{	O
FREE	O
(	O
&	O
(	O
Fs	pointer
.	O
Direct	pointer
)	O
)	O
;	O
if	O
(	O
dev	pointer
->	O
drive	char
!=	O
drive	char
)	O
continue	O
;	O
used_dev	pointer
=	O
*	O
dev	pointer
;	O
SET_INT	O
(	O
used_dev	pointer
.	O
tracks	int
,	O
argtracks	int
)	O
;	O
SET_INT	O
(	O
used_dev	pointer
.	O
heads	short
,	O
argheads	short
)	O
;	O
SET_INT	O
(	O
used_dev	pointer
.	O
sectors	short
,	O
argsectors	short
)	O
;	O
SET_INT	O
(	O
used_dev	pointer
.	O
use_2m	int
,	O
arguse_2m	int
)	O
;	O
SET_INT	O
(	O
used_dev	pointer
.	O
ssize	char
,	O
argssize	char
)	O
;	O
if	O
(	O
hs_set	int
)	O
used_dev	pointer
.	O
hidden	int
=	O
hs	int
;	O
expand	function
(	O
dev	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
format_xdf	int
)	O
{	O
Fs	pointer
.	O
Direct	pointer
=	O
0	int
;	O
Fs	pointer
.	O
Direct	pointer
=	O
FloppydOpen	function
(	O
&	O
used_dev	pointer
,	O
name	pointer
,	O
O_RDWR	int
|	O
create	int
,	O
errmsg	pointer
,	O
&	O
maxSize	pointer
)	O
;	O
if	O
(	O
!	O
Fs	pointer
.	O
Direct	pointer
)	O
{	O
Fs	pointer
.	O
Direct	pointer
=	O
SimpleFileOpen	function
(	O
&	O
used_dev	pointer
,	O
dev	pointer
,	O
name	pointer
,	O
O_RDWR	int
|	O
create	int
,	O
errmsg	pointer
,	O
0	int
,	O
1	int
,	O
&	O
maxSize	pointer
)	O
;	O
}	O
}	O
else	O
{	O
used_dev	pointer
.	O
misc_flags	int
|=	O
USE_XDF_FLAG	int
;	O
Fs	pointer
.	O
Direct	pointer
=	O
XdfOpen	function
(	O
&	O
used_dev	pointer
,	O
name	pointer
,	O
O_RDWR	int
,	O
errmsg	pointer
,	O
&	O
info	pointer
)	O
;	O
if	O
(	O
Fs	pointer
.	O
Direct	pointer
&&	O
!	O
Fs	pointer
.	O
fat_len	int
)	O
Fs	pointer
.	O
fat_len	int
=	O
info	pointer
.	O
FatSize	int
;	O
if	O
(	O
Fs	pointer
.	O
Direct	pointer
&&	O
!	O
Fs	pointer
.	O
dir_len	int
)	O
Fs	pointer
.	O
dir_len	int
=	O
info	pointer
.	O
RootDirSize	int
;	O
}	O
if	O
(	O
!	O
Fs	pointer
.	O
Direct	pointer
)	O
continue	O
;	O
if	O
(	O
(	O
!	O
used_dev	pointer
.	O
tracks	int
||	O
!	O
used_dev	pointer
.	O
heads	short
||	O
!	O
used_dev	pointer
.	O
sectors	short
)	O
&&	O
(	O
!	O
IS_SCSI	O
(	O
dev	pointer
)	O
)	O
)	O
{	O
int	O
fd	int
=	O
get_fd	function
(	O
Fs	pointer
.	O
Direct	pointer
)	O
;	O
struct	O
MT_STAT	O
stbuf	struct
;	O
if	O
(	O
MT_FSTAT	O
(	O
fd	int
,	O
&	O
stbuf	struct
)	O
<	O
0	int
)	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"Could not stat file (%s)"	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
S_ISBLK	O
(	O
stbuf	struct
.	O
st_mode	int
)	O
)	O
get_block_geom	function
(	O
fd	int
,	O
&	O
used_dev	pointer
,	O
errmsg	pointer
)	O
;	O
}	O
if	O
(	O
(	O
!	O
used_dev	pointer
.	O
tracks	int
&&	O
!	O
tot_sectors	long
)	O
||	O
!	O
used_dev	pointer
.	O
heads	short
||	O
!	O
used_dev	pointer
.	O
sectors	short
)	O
{	O
if	O
(	O
get_lba_geom	function
(	O
Fs	pointer
.	O
Direct	pointer
,	O
tot_sectors	long
,	O
&	O
used_dev	pointer
,	O
errmsg	pointer
)	O
<	O
0	int
)	O
{	O
sprintf	function
(	O
errmsg	pointer
,	O
"%s: "	pointer
"Complete geometry of the disk "	pointer
"was not specified, \n"	pointer
"neither in /etc/mtools.conf nor "	pointer
"on the command line. \n"	pointer
"LBA Assist Translation for "	pointer
"calculating CHS geometry "	pointer
"of the disk failed.\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
continue	O
;	O
}	O
}	O
Fs	pointer
.	O
sector_size	int
=	O
512	int
;	O
if	O
(	O
!	O
(	O
used_dev	pointer
.	O
use_2m	int
&	O
0x7f	int
)	O
)	O
{	O
Fs	pointer
.	O
sector_size	int
=	O
128	int
<<	O
(	O
used_dev	pointer
.	O
ssize	char
&	O
0x7f	int
)	O
;	O
}	O
SET_INT	O
(	O
Fs	pointer
.	O
sector_size	int
,	O
msize	int
)	O
;	O
{	O
unsigned	O
int	O
j	pointer
;	O
for	O
(	O
j	pointer
=	O
0	int
;	O
j	pointer
<	O
31	int
;	O
j	pointer
++	O
)	O
{	O
if	O
(	O
Fs	pointer
.	O
sector_size	int
==	O
(	O
unsigned	O
int	O
)	O
(	O
1	int
<<	O
j	pointer
)	O
)	O
{	O
Fs	pointer
.	O
sectorShift	int
=	O
j	pointer
;	O
break	O
;	O
}	O
}	O
Fs	pointer
.	O
sectorMask	int
=	O
Fs	pointer
.	O
sector_size	int
-	O
1	int
;	O
}	O
if	O
(	O
!	O
used_dev	pointer
.	O
blocksize	int
||	O
used_dev	pointer
.	O
blocksize	int
<	O
Fs	pointer
.	O
sector_size	int
)	O
blocksize	int
=	O
Fs	pointer
.	O
sector_size	int
;	O
else	O
blocksize	int
=	O
used_dev	pointer
.	O
blocksize	int
;	O
if	O
(	O
blocksize	int
>	O
MAX_SECTOR	int
)	O
blocksize	int
=	O
MAX_SECTOR	int
;	O
if	O
(	O
!	O
create	int
&&	O
READS	O
(	O
Fs	pointer
.	O
Direct	pointer
,	O
&	O
boot	struct
.	O
characters	array
,	O
0	int
,	O
Fs	pointer
.	O
sector_size	int
)	O
!=	O
(	O
signed	O
int	O
)	O
Fs	pointer
.	O
sector_size	int
)	O
{	O
snprintf	function
(	O
errmsg	pointer
,	O
sizeof	O
(	O
errmsg	pointer
)	O
-	O
1	int
,	O
"Error reading from '%s', wrong parameters?"	pointer
,	O
name	pointer
)	O
;	O
continue	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
dev	pointer
->	O
drive	char
==	O
0	int
)	O
{	O
FREE	O
(	O
&	O
Fs	pointer
.	O
Direct	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: %s\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
errmsg	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
tot_sectors	long
==	O
0	int
)	O
{	O
unsigned	O
long	O
sect_per_track	int
=	O
used_dev	pointer
.	O
heads	short
*	O
used_dev	pointer
.	O
sectors	short
;	O
tot_sectors	long
=	O
used_dev	pointer
.	O
tracks	int
*	O
sect_per_track	int
-	O
used_dev	pointer
.	O
hidden	int
%	O
sect_per_track	int
;	O
if	O
(	O
tot_sectors	long
>	O
0xFFFFFFFF	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Too many sectors\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
if	O
(	O
create	int
)	O
{	O
WRITES	O
(	O
Fs	pointer
.	O
Direct	pointer
,	O
&	O
boot	struct
.	O
characters	array
,	O
sectorsToBytes	function
(	O
(	O
Stream_t	struct
*	O
)	O
&	O
Fs	pointer
,	O
tot_sectors	long
-	O
1	int
)	O
,	O
Fs	pointer
.	O
sector_size	int
)	O
;	O
}	O
if	O
(	O
bootSector	pointer
)	O
{	O
int	O
fd	int
;	O
fd	int
=	O
open	function
(	O
bootSector	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
|	O
O_LARGEFILE	O
)	O
;	O
if	O
(	O
fd	int
<	O
0	int
)	O
{	O
perror	function
(	O
"open boot sector"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
read	pointer
(	O
fd	int
,	O
&	O
boot	struct
.	O
bytes	array
,	O
blocksize	int
)	O
<	O
blocksize	int
)	O
{	O
perror	function
(	O
"short read on boot sector"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
keepBoot	int
=	O
1	int
;	O
close	pointer
(	O
fd	int
)	O
;	O
}	O
if	O
(	O
!	O
keepBoot	int
&&	O
!	O
(	O
used_dev	pointer
.	O
use_2m	int
&	O
0x7f	int
)	O
)	O
memset	function
(	O
boot	struct
.	O
characters	array
,	O
'\0'	O
,	O
Fs	pointer
.	O
sector_size	int
)	O
;	O
set_dword	function
(	O
boot	struct
.	O
boot	struct
.	O
nhs	array
,	O
used_dev	pointer
.	O
hidden	int
)	O
;	O
Fs	pointer
.	O
Next	pointer
=	O
buf_init	function
(	O
Fs	pointer
.	O
Direct	pointer
,	O
blocksize	int
*	O
used_dev	pointer
.	O
heads	short
*	O
used_dev	pointer
.	O
sectors	short
,	O
blocksize	int
*	O
used_dev	pointer
.	O
heads	short
*	O
used_dev	pointer
.	O
sectors	short
,	O
blocksize	int
)	O
;	O
Fs	pointer
.	O
Buffer	pointer
=	O
0	int
;	O
boot	struct
.	O
boot	struct
.	O
nfat	char
=	O
Fs	pointer
.	O
num_fat	int
;	O
if	O
(	O
!	O
keepBoot	int
)	O
set_word	function
(	O
&	O
boot	struct
.	O
bytes	array
[	O
510	int
]	O
,	O
0xaa55	int
)	O
;	O
set_word	function
(	O
boot	struct
.	O
boot	struct
.	O
nsect	array
,	O
used_dev	pointer
.	O
sectors	short
)	O
;	O
set_word	function
(	O
boot	struct
.	O
boot	struct
.	O
nheads	array
,	O
used_dev	pointer
.	O
heads	short
)	O
;	O
used_dev	pointer
.	O
fat_bits	int
=	O
comp_fat_bits	function
(	O
&	O
Fs	pointer
,	O
used_dev	pointer
.	O
fat_bits	int
,	O
tot_sectors	long
,	O
fat32	struct
)	O
;	O
if	O
(	O
!	O
keepBoot	int
&&	O
!	O
(	O
used_dev	pointer
.	O
use_2m	int
&	O
0x7f	int
)	O
)	O
{	O
if	O
(	O
!	O
used_dev	pointer
.	O
partition	int
)	O
{	O
struct	O
partition	int
*	O
partTable	pointer
=	O
(	O
struct	O
partition	int
*	O
)	O
(	O
&	O
boot	struct
.	O
bytes	array
[	O
0x1ae	int
]	O
)	O
;	O
setBeginEnd	function
(	O
&	O
partTable	pointer
[	O
1	int
]	O
,	O
0	int
,	O
used_dev	pointer
.	O
heads	short
*	O
used_dev	pointer
.	O
sectors	short
*	O
used_dev	pointer
.	O
tracks	int
,	O
used_dev	pointer
.	O
heads	short
,	O
used_dev	pointer
.	O
sectors	short
,	O
1	int
,	O
0	int
,	O
used_dev	pointer
.	O
fat_bits	int
)	O
;	O
}	O
}	O
if	O
(	O
used_dev	pointer
.	O
fat_bits	int
==	O
32	int
)	O
{	O
Fs	pointer
.	O
primaryFat	int
=	O
0	int
;	O
Fs	pointer
.	O
writeAllFats	int
=	O
1	int
;	O
if	O
(	O
resvSects	int
)	O
{	O
if	O
(	O
resvSects	int
<	O
3	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"For FAT 32, reserved sectors need to be at least 3\n"	pointer
)	O
;	O
resvSects	int
=	O
32	int
;	O
}	O
if	O
(	O
resvSects	int
<=	O
backupBoot	array
&&	O
!	O
backupBootSet	int
)	O
backupBoot	array
=	O
resvSects	int
-	O
1	int
;	O
Fs	pointer
.	O
fat_start	int
=	O
resvSects	int
;	O
}	O
else	O
Fs	pointer
.	O
fat_start	int
=	O
32	int
;	O
if	O
(	O
Fs	pointer
.	O
fat_start	int
<=	O
backupBoot	array
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Reserved sectors (%d) must be more than backupBoot (%d)\n"	pointer
,	O
Fs	pointer
.	O
fat_start	int
,	O
backupBoot	array
)	O
;	O
backupBoot	array
=	O
6	int
;	O
Fs	pointer
.	O
fat_start	int
=	O
32	int
;	O
}	O
calc_fs_parameters_32	function
(	O
tot_sectors	long
,	O
&	O
Fs	pointer
,	O
&	O
boot	struct
)	O
;	O
Fs	pointer
.	O
clus_start	int
=	O
Fs	pointer
.	O
num_fat	int
*	O
Fs	pointer
.	O
fat_len	int
+	O
Fs	pointer
.	O
fat_start	int
;	O
set_word	function
(	O
boot	struct
.	O
boot	struct
.	O
ext	array
.	O
fat32	struct
.	O
extFlags	array
,	O
0	int
)	O
;	O
set_word	function
(	O
boot	struct
.	O
boot	struct
.	O
ext	array
.	O
fat32	struct
.	O
fsVersion	array
,	O
fsVersion	array
)	O
;	O
set_dword	function
(	O
boot	struct
.	O
boot	struct
.	O
ext	array
.	O
fat32	struct
.	O
rootCluster	array
,	O
Fs	pointer
.	O
rootCluster	array
=	O
2	int
)	O
;	O
set_word	function
(	O
boot	struct
.	O
boot	struct
.	O
ext	array
.	O
fat32	struct
.	O
infoSector	array
,	O
Fs	pointer
.	O
infoSectorLoc	int
=	O
1	int
)	O
;	O
Fs	pointer
.	O
infoSectorLoc	int
=	O
1	int
;	O
set_word	function
(	O
boot	struct
.	O
boot	struct
.	O
ext	array
.	O
fat32	struct
.	O
backupBoot	array
,	O
backupBoot	array
)	O
;	O
labelBlock	struct
=	O
&	O
boot	struct
.	O
boot	struct
.	O
ext	array
.	O
fat32	struct
.	O
labelBlock	struct
;	O
}	O
else	O
{	O
Fs	pointer
.	O
infoSectorLoc	int
=	O
0	int
;	O
if	O
(	O
resvSects	int
)	O
{	O
if	O
(	O
resvSects	int
<	O
1	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Reserved sectors need to be at least 1\n"	pointer
)	O
;	O
resvSects	int
=	O
1	int
;	O
}	O
Fs	pointer
.	O
fat_start	int
=	O
resvSects	int
;	O
}	O
else	O
Fs	pointer
.	O
fat_start	int
=	O
1	int
;	O
calc_fs_parameters	function
(	O
&	O
used_dev	pointer
,	O
tot_sectors	long
,	O
&	O
Fs	pointer
,	O
&	O
boot	struct
)	O
;	O
Fs	pointer
.	O
dir_start	int
=	O
Fs	pointer
.	O
num_fat	int
*	O
Fs	pointer
.	O
fat_len	int
+	O
Fs	pointer
.	O
fat_start	int
;	O
Fs	pointer
.	O
clus_start	int
=	O
Fs	pointer
.	O
dir_start	int
+	O
Fs	pointer
.	O
dir_len	int
;	O
labelBlock	struct
=	O
&	O
boot	struct
.	O
boot	struct
.	O
ext	array
.	O
old	struct
.	O
labelBlock	struct
;	O
}	O
Fs	pointer
.	O
cp	pointer
=	O
cp_open	function
(	O
used_dev	pointer
.	O
codepage	int
)	O
;	O
if	O
(	O
Fs	pointer
.	O
cp	pointer
==	O
NULL	O
)	O
exit	function
(	O
1	int
)	O
;	O
if	O
(	O
!	O
keepBoot	int
)	O
labelBlock	struct
->	O
physdrive	char
=	O
0x00	int
;	O
labelBlock	struct
->	O
reserved	char
=	O
0	int
;	O
labelBlock	struct
->	O
dos4	char
=	O
0x29	int
;	O
if	O
(	O
!	O
serial_set	int
||	O
Atari	int
)	O
init_random	function
(	O
)	O
;	O
if	O
(	O
!	O
serial_set	int
)	O
serial	array
=	O
(	O
uint32_t	int
)	O
random	function
(	O
)	O
;	O
set_dword	function
(	O
labelBlock	struct
->	O
serial	array
,	O
serial	array
)	O
;	O
label_name_pc	function
(	O
GET_DOSCONVERT	O
(	O
(	O
Stream_t	struct
*	O
)	O
&	O
Fs	pointer
)	O
,	O
label	array
[	O
0	int
]	O
?	O
label	array
:	O
"NO NAME    "	pointer
,	O
0	int
,	O
&	O
mangled	pointer
,	O
&	O
shortlabel	struct
)	O
;	O
strncpy	function
(	O
labelBlock	struct
->	O
label	array
,	O
shortlabel	struct
.	O
base	int
,	O
8	int
)	O
;	O
strncpy	function
(	O
labelBlock	struct
->	O
label	array
+	O
8	int
,	O
shortlabel	struct
.	O
ext	array
,	O
3	int
)	O
;	O
sprintf	function
(	O
labelBlock	struct
->	O
fat_type	array
,	O
"FAT%2.2d  "	pointer
,	O
Fs	pointer
.	O
fat_bits	int
)	O
;	O
labelBlock	struct
->	O
fat_type	array
[	O
7	int
]	O
=	O
' '	O
;	O
set_word	function
(	O
boot	struct
.	O
boot	struct
.	O
secsiz	array
,	O
Fs	pointer
.	O
sector_size	int
)	O
;	O
boot	struct
.	O
boot	struct
.	O
clsiz	char
=	O
(	O
unsigned	O
char	O
)	O
Fs	pointer
.	O
cluster_size	int
;	O
set_word	function
(	O
boot	struct
.	O
boot	struct
.	O
nrsvsect	array
,	O
Fs	pointer
.	O
fat_start	int
)	O
;	O
bootOffset	int
=	O
init_geometry_boot	function
(	O
&	O
boot	struct
,	O
&	O
used_dev	pointer
,	O
sectors0	char
,	O
rate_0	char
,	O
rate_any	char
,	O
&	O
tot_sectors	long
,	O
keepBoot	int
)	O
;	O
if	O
(	O
!	O
bootOffset	int
)	O
{	O
bootOffset	int
=	O
(	O
(	O
unsigned	O
char	O
*	O
)	O
labelBlock	struct
)	O
-	O
boot	struct
.	O
bytes	array
+	O
sizeof	O
(	O
struct	O
label_blk_t	struct
)	O
;	O
}	O
if	O
(	O
Atari	int
)	O
{	O
boot	struct
.	O
boot	struct
.	O
banner	array
[	O
4	int
]	O
=	O
0	int
;	O
boot	struct
.	O
boot	struct
.	O
banner	array
[	O
5	int
]	O
=	O
(	O
char	O
)	O
random	function
(	O
)	O
;	O
boot	struct
.	O
boot	struct
.	O
banner	array
[	O
6	int
]	O
=	O
(	O
char	O
)	O
random	function
(	O
)	O
;	O
boot	struct
.	O
boot	struct
.	O
banner	array
[	O
7	int
]	O
=	O
(	O
char	O
)	O
random	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
keepBoot	int
)	O
inst_boot_prg	function
(	O
&	O
boot	struct
,	O
bootOffset	int
)	O
;	O
if	O
(	O
used_dev	pointer
.	O
use_2m	int
&	O
0x7f	int
)	O
{	O
boot	struct
.	O
boot	struct
.	O
jump	array
[	O
0	int
]	O
=	O
0xeb	int
;	O
boot	struct
.	O
boot	struct
.	O
jump	array
[	O
1	int
]	O
=	O
0x80	int
;	O
boot	struct
.	O
boot	struct
.	O
jump	array
[	O
2	int
]	O
=	O
0x90	int
;	O
}	O
if	O
(	O
used_dev	pointer
.	O
use_2m	int
&	O
0x7f	int
)	O
Fs	pointer
.	O
num_fat	int
=	O
1	int
;	O
if	O
(	O
mediaDesc	int
!=	O
-	O
1	int
)	O
boot	struct
.	O
boot	struct
.	O
descr	char
=	O
mediaDesc	int
;	O
Fs	pointer
.	O
lastFatSectorNr	int
=	O
0	int
;	O
Fs	pointer
.	O
lastFatSectorData	pointer
=	O
0	int
;	O
zero_fat	function
(	O
&	O
Fs	pointer
,	O
boot	struct
.	O
boot	struct
.	O
descr	char
)	O
;	O
Fs	pointer
.	O
freeSpace	int
=	O
Fs	pointer
.	O
num_clus	int
;	O
Fs	pointer
.	O
last	int
=	O
2	int
;	O
if	O
(	O
format_xdf	int
)	O
for	O
(	O
i	short
=	O
0	int
;	O
i	short
<	O
(	O
info	pointer
.	O
BadSectors	int
+	O
Fs	pointer
.	O
cluster_size	int
-	O
1	int
)	O
/	O
Fs	pointer
.	O
cluster_size	int
;	O
i	short
++	O
)	O
fatEncode	function
(	O
&	O
Fs	pointer
,	O
i	short
+	O
2	int
,	O
0xfff7	int
)	O
;	O
format_root	function
(	O
&	O
Fs	pointer
,	O
label	array
,	O
&	O
boot	struct
)	O
;	O
WRITES	O
(	O
(	O
Stream_t	struct
*	O
)	O
&	O
Fs	pointer
,	O
boot	struct
.	O
characters	array
,	O
(	O
mt_off_t	long
)	O
0	int
,	O
Fs	pointer
.	O
sector_size	int
)	O
;	O
if	O
(	O
used_dev	pointer
.	O
fat_bits	int
==	O
32	int
)	O
{	O
WRITES	O
(	O
(	O
Stream_t	struct
*	O
)	O
&	O
Fs	pointer
,	O
boot	struct
.	O
characters	array
,	O
(	O
mt_off_t	long
)	O
backupBoot	array
*	O
Fs	pointer
.	O
sector_size	int
,	O
Fs	pointer
.	O
sector_size	int
)	O
;	O
}	O
if	O
(	O
Fs	pointer
.	O
fat_bits	int
==	O
32	int
&&	O
WORD_S	O
(	O
ext	array
.	O
fat32	struct
.	O
backupBoot	array
)	O
!=	O
MAX16	int
)	O
{	O
WRITES	O
(	O
(	O
Stream_t	struct
*	O
)	O
&	O
Fs	pointer
,	O
boot	struct
.	O
characters	array
,	O
sectorsToBytes	function
(	O
(	O
Stream_t	struct
*	O
)	O
&	O
Fs	pointer
,	O
WORD_S	O
(	O
ext	array
.	O
fat32	struct
.	O
backupBoot	array
)	O
)	O
,	O
Fs	pointer
.	O
sector_size	int
)	O
;	O
}	O
FLUSH	O
(	O
(	O
Stream_t	struct
*	O
)	O
&	O
Fs	pointer
)	O
;	O
FREE	O
(	O
&	O
Fs	pointer
.	O
Next	pointer
)	O
;	O
Fs	pointer
.	O
Class	pointer
->	O
freeFunc	pointer
(	O
(	O
Stream_t	struct
*	O
)	O
&	O
Fs	pointer
)	O
;	O
if	O
(	O
format_xdf	int
&&	O
isatty	function
(	O
0	int
)	O
&&	O
!	O
getenv	function
(	O
"MTOOLS_USE_XDF"	pointer
)	O
)	O
fprintf	function
(	O
stderr	pointer
,	O
"Note:\n"	pointer
"Remember to set the \"MTOOLS_USE_XDF\" environmental\n"	pointer
"variable before accessing this disk\n\n"	pointer
"Bourne shell syntax (sh, ash, bash, ksh, zsh etc):\n"	pointer
" export MTOOLS_USE_XDF=1\n\n"	pointer
"C shell syntax (csh and tcsh):\n"	pointer
" setenv MTOOLS_USE_XDF 1\n"	pointer
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
