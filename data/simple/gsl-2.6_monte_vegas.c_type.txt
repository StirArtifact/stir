typedef	O
int	O
coord	int
;	O
static	O
void	O
init_grid	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
double	O
xl	array
[	O
]	O
,	O
double	O
xu	array
[	O
]	O
,	O
size_t	long
dim	long
)	O
;	O
static	O
void	O
reset_grid_values	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
)	O
;	O
static	O
void	O
init_box_coord	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
coord	int
box	pointer
[	O
]	O
)	O
;	O
static	O
int	O
change_box_coord	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
coord	int
box	pointer
[	O
]	O
)	O
;	O
static	O
void	O
accumulate_distribution	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
coord	int
bin	pointer
[	O
]	O
,	O
double	O
y	double
)	O
;	O
static	O
void	O
random_point	function
(	O
double	O
x	double
[	O
]	O
,	O
coord	int
bin	pointer
[	O
]	O
,	O
double	O
*	O
bin_vol	pointer
,	O
const	O
coord	int
box	pointer
[	O
]	O
,	O
const	O
double	O
xl	array
[	O
]	O
,	O
const	O
double	O
xu	array
[	O
]	O
,	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
gsl_rng	struct
*	O
r	pointer
)	O
;	O
static	O
void	O
resize_grid	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
unsigned	O
int	O
bins	int
)	O
;	O
static	O
void	O
refine_grid	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
)	O
;	O
static	O
void	O
print_lim	function
(	O
gsl_monte_vegas_state	struct
*	O
state	pointer
,	O
double	O
xl	array
[	O
]	O
,	O
double	O
xu	array
[	O
]	O
,	O
unsigned	O
long	O
dim	long
)	O
;	O
static	O
void	O
print_head	function
(	O
gsl_monte_vegas_state	struct
*	O
state	pointer
,	O
unsigned	O
long	O
num_dim	long
,	O
unsigned	O
long	O
calls	long
,	O
unsigned	O
int	O
it_num	int
,	O
unsigned	O
int	O
bins	int
,	O
unsigned	O
int	O
boxes	int
)	O
;	O
static	O
void	O
print_res	function
(	O
gsl_monte_vegas_state	struct
*	O
state	pointer
,	O
unsigned	O
int	O
itr	int
,	O
double	O
res	double
,	O
double	O
err	double
,	O
double	O
cum_res	double
,	O
double	O
cum_err	double
,	O
double	O
chi_sq	double
)	O
;	O
static	O
void	O
print_dist	function
(	O
gsl_monte_vegas_state	struct
*	O
state	pointer
,	O
unsigned	O
long	O
dim	long
)	O
;	O
static	O
void	O
print_grid	function
(	O
gsl_monte_vegas_state	struct
*	O
state	pointer
,	O
unsigned	O
long	O
dim	long
)	O
;	O
int	O
gsl_monte_vegas_integrate	function
(	O
gsl_monte_function	struct
*	O
f	pointer
,	O
double	O
xl	array
[	O
]	O
,	O
double	O
xu	array
[	O
]	O
,	O
size_t	long
dim	long
,	O
size_t	long
calls	long
,	O
gsl_rng	struct
*	O
r	pointer
,	O
gsl_monte_vegas_state	struct
*	O
state	pointer
,	O
double	O
*	O
result	double
,	O
double	O
*	O
abserr	pointer
)	O
{	O
double	O
cum_int	double
,	O
cum_sig	double
;	O
size_t	long
i	long
,	O
k	long
,	O
it	long
;	O
if	O
(	O
dim	long
!=	O
state	pointer
->	O
dim	long
)	O
{	O
GSL_ERROR	O
(	O
"number of dimensions must match allocated size"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
xu	array
[	O
i	long
]	O
<=	O
xl	array
[	O
i	long
]	O
)	O
{	O
GSL_ERROR	O
(	O
"xu must be greater than xl"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
if	O
(	O
xu	array
[	O
i	long
]	O
-	O
xl	array
[	O
i	long
]	O
>	O
GSL_DBL_MAX	int
)	O
{	O
GSL_ERROR	O
(	O
"Range of integration is too large, please rescale"	pointer
,	O
GSL_EINVAL	int
)	O
;	O
}	O
}	O
if	O
(	O
state	pointer
->	O
stage	int
==	O
0	int
)	O
{	O
init_grid	function
(	O
state	pointer
,	O
xl	array
,	O
xu	array
,	O
dim	long
)	O
;	O
if	O
(	O
state	pointer
->	O
verbose	int
>=	O
0	int
)	O
{	O
print_lim	function
(	O
state	pointer
,	O
xl	array
,	O
xu	array
,	O
dim	long
)	O
;	O
}	O
}	O
if	O
(	O
state	pointer
->	O
stage	int
<=	O
1	int
)	O
{	O
state	pointer
->	O
wtd_int_sum	double
=	O
0	int
;	O
state	pointer
->	O
sum_wgts	double
=	O
0	int
;	O
state	pointer
->	O
chi_sum	double
=	O
0	int
;	O
state	pointer
->	O
it_num	int
=	O
1	int
;	O
state	pointer
->	O
samples	int
=	O
0	int
;	O
state	pointer
->	O
chisq	double
=	O
0	int
;	O
}	O
if	O
(	O
state	pointer
->	O
stage	int
<=	O
2	int
)	O
{	O
unsigned	O
int	O
bins	int
=	O
state	pointer
->	O
bins_max	long
;	O
unsigned	O
int	O
boxes	int
=	O
1	int
;	O
if	O
(	O
state	pointer
->	O
mode	int
!=	O
GSL_VEGAS_MODE_IMPORTANCE_ONLY	int
)	O
{	O
boxes	int
=	O
floor	function
(	O
pow	function
(	O
calls	long
/	O
2.0	int
,	O
1.0	int
/	O
dim	long
)	O
)	O
;	O
state	pointer
->	O
mode	int
=	O
GSL_VEGAS_MODE_IMPORTANCE	int
;	O
if	O
(	O
2	int
*	O
boxes	int
>=	O
state	pointer
->	O
bins_max	long
)	O
{	O
int	O
box_per_bin	int
=	O
GSL_MAX	O
(	O
boxes	int
/	O
state	pointer
->	O
bins_max	long
,	O
1	int
)	O
;	O
bins	int
=	O
GSL_MIN	O
(	O
boxes	int
/	O
box_per_bin	int
,	O
state	pointer
->	O
bins_max	long
)	O
;	O
boxes	int
=	O
box_per_bin	int
*	O
bins	int
;	O
state	pointer
->	O
mode	int
=	O
GSL_VEGAS_MODE_STRATIFIED	int
;	O
}	O
}	O
{	O
double	O
tot_boxes	double
=	O
gsl_pow_int	function
(	O
(	O
double	O
)	O
boxes	int
,	O
dim	long
)	O
;	O
state	pointer
->	O
calls_per_box	int
=	O
GSL_MAX	O
(	O
calls	long
/	O
tot_boxes	double
,	O
2	int
)	O
;	O
calls	long
=	O
state	pointer
->	O
calls_per_box	int
*	O
tot_boxes	double
;	O
}	O
state	pointer
->	O
jac	double
=	O
state	pointer
->	O
vol	double
*	O
pow	function
(	O
(	O
double	O
)	O
bins	int
,	O
(	O
double	O
)	O
dim	long
)	O
/	O
calls	long
;	O
state	pointer
->	O
boxes	int
=	O
boxes	int
;	O
if	O
(	O
bins	int
!=	O
state	pointer
->	O
bins	int
)	O
{	O
resize_grid	function
(	O
state	pointer
,	O
bins	int
)	O
;	O
if	O
(	O
state	pointer
->	O
verbose	int
>	O
1	int
)	O
{	O
print_grid	function
(	O
state	pointer
,	O
dim	long
)	O
;	O
}	O
}	O
if	O
(	O
state	pointer
->	O
verbose	int
>=	O
0	int
)	O
{	O
print_head	function
(	O
state	pointer
,	O
dim	long
,	O
calls	long
,	O
state	pointer
->	O
it_num	int
,	O
state	pointer
->	O
bins	int
,	O
state	pointer
->	O
boxes	int
)	O
;	O
}	O
}	O
state	pointer
->	O
it_start	int
=	O
state	pointer
->	O
it_num	int
;	O
cum_int	double
=	O
0.0	int
;	O
cum_sig	double
=	O
0.0	int
;	O
for	O
(	O
it	long
=	O
0	int
;	O
it	long
<	O
state	pointer
->	O
iterations	int
;	O
it	long
++	O
)	O
{	O
double	O
intgrl	double
=	O
0.0	int
,	O
intgrl_sq	double
=	O
0.0	int
;	O
double	O
tss	double
=	O
0.0	int
;	O
double	O
wgt	double
,	O
var	double
,	O
sig	double
;	O
size_t	long
calls_per_box	int
=	O
state	pointer
->	O
calls_per_box	int
;	O
double	O
jacbin	double
=	O
state	pointer
->	O
jac	double
;	O
double	O
*	O
x	double
=	O
state	pointer
->	O
x	double
;	O
coord	int
*	O
bin	pointer
=	O
state	pointer
->	O
bin	pointer
;	O
state	pointer
->	O
it_num	int
=	O
state	pointer
->	O
it_start	int
+	O
it	long
;	O
reset_grid_values	function
(	O
state	pointer
)	O
;	O
init_box_coord	function
(	O
state	pointer
,	O
state	pointer
->	O
box	pointer
)	O
;	O
do	O
{	O
volatile	O
double	O
m	double
=	O
0	int
,	O
q	double
=	O
0	int
;	O
double	O
f_sq_sum	double
=	O
0.0	int
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
calls_per_box	int
;	O
k	long
++	O
)	O
{	O
volatile	O
double	O
fval	double
;	O
double	O
bin_vol	pointer
;	O
random_point	function
(	O
x	double
,	O
bin	pointer
,	O
&	O
bin_vol	pointer
,	O
state	pointer
->	O
box	pointer
,	O
xl	array
,	O
xu	array
,	O
state	pointer
,	O
r	pointer
)	O
;	O
fval	double
=	O
jacbin	double
*	O
bin_vol	pointer
*	O
GSL_MONTE_FN_EVAL	O
(	O
f	pointer
,	O
x	double
)	O
;	O
{	O
double	O
d	pointer
=	O
fval	double
-	O
m	double
;	O
m	double
+=	O
d	pointer
/	O
(	O
k	long
+	O
1.0	int
)	O
;	O
q	double
+=	O
d	pointer
*	O
d	pointer
*	O
(	O
k	long
/	O
(	O
k	long
+	O
1.0	int
)	O
)	O
;	O
}	O
if	O
(	O
state	pointer
->	O
mode	int
!=	O
GSL_VEGAS_MODE_STRATIFIED	int
)	O
{	O
double	O
f_sq	double
=	O
fval	double
*	O
fval	double
;	O
accumulate_distribution	function
(	O
state	pointer
,	O
bin	pointer
,	O
f_sq	double
)	O
;	O
}	O
}	O
intgrl	double
+=	O
m	double
*	O
calls_per_box	int
;	O
f_sq_sum	double
=	O
q	double
*	O
calls_per_box	int
;	O
tss	double
+=	O
f_sq_sum	double
;	O
if	O
(	O
state	pointer
->	O
mode	int
==	O
GSL_VEGAS_MODE_STRATIFIED	int
)	O
{	O
accumulate_distribution	function
(	O
state	pointer
,	O
bin	pointer
,	O
f_sq_sum	double
)	O
;	O
}	O
}	O
while	O
(	O
change_box_coord	function
(	O
state	pointer
,	O
state	pointer
->	O
box	pointer
)	O
)	O
;	O
var	double
=	O
tss	double
/	O
(	O
calls_per_box	int
-	O
1.0	int
)	O
;	O
if	O
(	O
var	double
>	O
0	int
)	O
{	O
wgt	double
=	O
1.0	int
/	O
var	double
;	O
}	O
else	O
if	O
(	O
state	pointer
->	O
sum_wgts	double
>	O
0	int
)	O
{	O
wgt	double
=	O
state	pointer
->	O
sum_wgts	double
/	O
state	pointer
->	O
samples	int
;	O
}	O
else	O
{	O
wgt	double
=	O
0.0	int
;	O
}	O
intgrl_sq	double
=	O
intgrl	double
*	O
intgrl	double
;	O
sig	double
=	O
sqrt	function
(	O
var	double
)	O
;	O
state	pointer
->	O
result	double
=	O
intgrl	double
;	O
state	pointer
->	O
sigma	double
=	O
sig	double
;	O
if	O
(	O
wgt	double
>	O
0.0	int
)	O
{	O
double	O
sum_wgts	double
=	O
state	pointer
->	O
sum_wgts	double
;	O
double	O
wtd_int_sum	double
=	O
state	pointer
->	O
wtd_int_sum	double
;	O
double	O
m	double
=	O
(	O
sum_wgts	double
>	O
0	int
)	O
?	O
(	O
wtd_int_sum	double
/	O
sum_wgts	double
)	O
:	O
0	int
;	O
double	O
q	double
=	O
intgrl	double
-	O
m	double
;	O
state	pointer
->	O
samples	int
++	O
;	O
state	pointer
->	O
sum_wgts	double
+=	O
wgt	double
;	O
state	pointer
->	O
wtd_int_sum	double
+=	O
intgrl	double
*	O
wgt	double
;	O
state	pointer
->	O
chi_sum	double
+=	O
intgrl_sq	double
*	O
wgt	double
;	O
cum_int	double
=	O
state	pointer
->	O
wtd_int_sum	double
/	O
state	pointer
->	O
sum_wgts	double
;	O
cum_sig	double
=	O
sqrt	function
(	O
1	int
/	O
state	pointer
->	O
sum_wgts	double
)	O
;	O
if	O
(	O
state	pointer
->	O
samples	int
==	O
1	int
)	O
{	O
state	pointer
->	O
chisq	double
=	O
0	int
;	O
}	O
else	O
{	O
state	pointer
->	O
chisq	double
*=	O
(	O
state	pointer
->	O
samples	int
-	O
2.0	int
)	O
;	O
state	pointer
->	O
chisq	double
+=	O
(	O
wgt	double
/	O
(	O
1	int
+	O
(	O
wgt	double
/	O
sum_wgts	double
)	O
)	O
)	O
*	O
q	double
*	O
q	double
;	O
state	pointer
->	O
chisq	double
/=	O
(	O
state	pointer
->	O
samples	int
-	O
1.0	int
)	O
;	O
}	O
}	O
else	O
{	O
cum_int	double
+=	O
(	O
intgrl	double
-	O
cum_int	double
)	O
/	O
(	O
it	long
+	O
1.0	int
)	O
;	O
cum_sig	double
=	O
0.0	int
;	O
}	O
if	O
(	O
state	pointer
->	O
verbose	int
>=	O
0	int
)	O
{	O
print_res	function
(	O
state	pointer
,	O
state	pointer
->	O
it_num	int
,	O
intgrl	double
,	O
sig	double
,	O
cum_int	double
,	O
cum_sig	double
,	O
state	pointer
->	O
chisq	double
)	O
;	O
if	O
(	O
it	long
+	O
1	int
==	O
state	pointer
->	O
iterations	int
&&	O
state	pointer
->	O
verbose	int
>	O
0	int
)	O
{	O
print_grid	function
(	O
state	pointer
,	O
dim	long
)	O
;	O
}	O
}	O
if	O
(	O
state	pointer
->	O
verbose	int
>	O
1	int
)	O
{	O
print_dist	function
(	O
state	pointer
,	O
dim	long
)	O
;	O
}	O
refine_grid	function
(	O
state	pointer
)	O
;	O
if	O
(	O
state	pointer
->	O
verbose	int
>	O
1	int
)	O
{	O
print_grid	function
(	O
state	pointer
,	O
dim	long
)	O
;	O
}	O
}	O
state	pointer
->	O
stage	int
=	O
1	int
;	O
*	O
result	double
=	O
cum_int	double
;	O
*	O
abserr	pointer
=	O
cum_sig	double
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
gsl_monte_vegas_state	struct
*	O
gsl_monte_vegas_alloc	function
(	O
size_t	long
dim	long
)	O
{	O
gsl_monte_vegas_state	struct
*	O
s	pointer
=	O
(	O
gsl_monte_vegas_state	struct
*	O
)	O
malloc	function
(	O
sizeof	O
(	O
gsl_monte_vegas_state	struct
)	O
)	O
;	O
if	O
(	O
s	pointer
==	O
0	int
)	O
{	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for vegas state struct"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
s	pointer
->	O
delx	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
delx	pointer
==	O
0	int
)	O
{	O
free	function
(	O
s	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for delx"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
s	pointer
->	O
d	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
BINS_MAX	int
*	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
d	pointer
==	O
0	int
)	O
{	O
free	function
(	O
s	pointer
->	O
delx	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for d"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
s	pointer
->	O
xi	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
(	O
BINS_MAX	int
+	O
1	int
)	O
*	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
xi	pointer
==	O
0	int
)	O
{	O
free	function
(	O
s	pointer
->	O
d	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
delx	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for xi"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
s	pointer
->	O
xin	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
(	O
BINS_MAX	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
xin	pointer
==	O
0	int
)	O
{	O
free	function
(	O
s	pointer
->	O
xi	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
d	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
delx	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for xin"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
s	pointer
->	O
weight	pointer
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
BINS_MAX	int
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
weight	pointer
==	O
0	int
)	O
{	O
free	function
(	O
s	pointer
->	O
xin	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
xi	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
d	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
delx	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for xin"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
s	pointer
->	O
box	pointer
=	O
(	O
coord	int
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
coord	int
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
box	pointer
==	O
0	int
)	O
{	O
free	function
(	O
s	pointer
->	O
weight	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
xin	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
xi	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
d	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
delx	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for box"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
s	pointer
->	O
bin	pointer
=	O
(	O
coord	int
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
coord	int
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
bin	pointer
==	O
0	int
)	O
{	O
free	function
(	O
s	pointer
->	O
box	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
weight	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
xin	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
xi	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
d	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
delx	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for bin"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
s	pointer
->	O
x	double
=	O
(	O
double	O
*	O
)	O
malloc	function
(	O
dim	long
*	O
sizeof	O
(	O
double	O
)	O
)	O
;	O
if	O
(	O
s	pointer
->	O
x	double
==	O
0	int
)	O
{	O
free	function
(	O
s	pointer
->	O
bin	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
box	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
weight	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
xin	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
xi	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
d	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
delx	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
GSL_ERROR_VAL	O
(	O
"failed to allocate space for x"	pointer
,	O
GSL_ENOMEM	int
,	O
0	int
)	O
;	O
}	O
s	pointer
->	O
dim	long
=	O
dim	long
;	O
s	pointer
->	O
bins_max	long
=	O
BINS_MAX	int
;	O
gsl_monte_vegas_init	function
(	O
s	pointer
)	O
;	O
return	O
s	pointer
;	O
}	O
int	O
gsl_monte_vegas_init	function
(	O
gsl_monte_vegas_state	struct
*	O
state	pointer
)	O
{	O
state	pointer
->	O
stage	int
=	O
0	int
;	O
state	pointer
->	O
alpha	double
=	O
1.5	int
;	O
state	pointer
->	O
verbose	int
=	O
-	O
1	int
;	O
state	pointer
->	O
iterations	int
=	O
5	int
;	O
state	pointer
->	O
mode	int
=	O
GSL_VEGAS_MODE_IMPORTANCE	int
;	O
state	pointer
->	O
chisq	double
=	O
0	int
;	O
state	pointer
->	O
bins	int
=	O
state	pointer
->	O
bins_max	long
;	O
state	pointer
->	O
ostream	pointer
=	O
stdout	pointer
;	O
return	O
GSL_SUCCESS	int
;	O
}	O
void	O
gsl_monte_vegas_free	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
)	O
{	O
RETURN_IF_NULL	O
(	O
s	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
x	double
)	O
;	O
free	function
(	O
s	pointer
->	O
delx	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
d	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
xi	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
xin	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
weight	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
box	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
bin	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
}	O
double	O
gsl_monte_vegas_chisq	function
(	O
const	O
gsl_monte_vegas_state	struct
*	O
s	pointer
)	O
{	O
return	O
s	pointer
->	O
chisq	double
;	O
}	O
void	O
gsl_monte_vegas_runval	function
(	O
const	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
double	O
*	O
result	double
,	O
double	O
*	O
sigma	double
)	O
{	O
*	O
result	double
=	O
s	pointer
->	O
result	double
;	O
*	O
sigma	double
=	O
s	pointer
->	O
sigma	double
;	O
}	O
void	O
gsl_monte_vegas_params_get	function
(	O
const	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
gsl_monte_vegas_params	struct
*	O
p	pointer
)	O
{	O
p	pointer
->	O
alpha	double
=	O
s	pointer
->	O
alpha	double
;	O
p	pointer
->	O
iterations	int
=	O
s	pointer
->	O
iterations	int
;	O
p	pointer
->	O
stage	int
=	O
s	pointer
->	O
stage	int
;	O
p	pointer
->	O
mode	int
=	O
s	pointer
->	O
mode	int
;	O
p	pointer
->	O
verbose	int
=	O
s	pointer
->	O
verbose	int
;	O
p	pointer
->	O
ostream	pointer
=	O
s	pointer
->	O
ostream	pointer
;	O
}	O
void	O
gsl_monte_vegas_params_set	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
const	O
gsl_monte_vegas_params	struct
*	O
p	pointer
)	O
{	O
s	pointer
->	O
alpha	double
=	O
p	pointer
->	O
alpha	double
;	O
s	pointer
->	O
iterations	int
=	O
p	pointer
->	O
iterations	int
;	O
s	pointer
->	O
stage	int
=	O
p	pointer
->	O
stage	int
;	O
s	pointer
->	O
mode	int
=	O
p	pointer
->	O
mode	int
;	O
s	pointer
->	O
verbose	int
=	O
p	pointer
->	O
verbose	int
;	O
s	pointer
->	O
ostream	pointer
=	O
p	pointer
->	O
ostream	pointer
;	O
}	O
static	O
void	O
init_box_coord	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
coord	int
box	pointer
[	O
]	O
)	O
{	O
size_t	long
i	long
;	O
size_t	long
dim	long
=	O
s	pointer
->	O
dim	long
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
dim	long
;	O
i	long
++	O
)	O
{	O
box	pointer
[	O
i	long
]	O
=	O
0	int
;	O
}	O
}	O
static	O
int	O
change_box_coord	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
coord	int
box	pointer
[	O
]	O
)	O
{	O
int	O
j	int
=	O
s	pointer
->	O
dim	long
-	O
1	int
;	O
int	O
ng	int
=	O
s	pointer
->	O
boxes	int
;	O
while	O
(	O
j	int
>=	O
0	int
)	O
{	O
box	pointer
[	O
j	int
]	O
=	O
(	O
box	pointer
[	O
j	int
]	O
+	O
1	int
)	O
%	O
ng	int
;	O
if	O
(	O
box	pointer
[	O
j	int
]	O
!=	O
0	int
)	O
{	O
return	O
1	int
;	O
}	O
j	int
--	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
init_grid	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
double	O
xl	array
[	O
]	O
,	O
double	O
xu	array
[	O
]	O
,	O
size_t	long
dim	long
)	O
{	O
size_t	long
j	int
;	O
double	O
vol	double
=	O
1.0	int
;	O
s	pointer
->	O
bins	int
=	O
1	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dim	long
;	O
j	int
++	O
)	O
{	O
double	O
dx	double
=	O
xu	array
[	O
j	int
]	O
-	O
xl	array
[	O
j	int
]	O
;	O
s	pointer
->	O
delx	pointer
[	O
j	int
]	O
=	O
dx	double
;	O
vol	double
*=	O
dx	double
;	O
COORD	O
(	O
s	pointer
,	O
0	int
,	O
j	int
)	O
=	O
0.0	int
;	O
COORD	O
(	O
s	pointer
,	O
1	int
,	O
j	int
)	O
=	O
1.0	int
;	O
}	O
s	pointer
->	O
vol	double
=	O
vol	double
;	O
}	O
static	O
void	O
reset_grid_values	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
)	O
{	O
size_t	long
i	long
,	O
j	int
;	O
size_t	long
dim	long
=	O
s	pointer
->	O
dim	long
;	O
size_t	long
bins	int
=	O
s	pointer
->	O
bins	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
bins	int
;	O
i	long
++	O
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dim	long
;	O
j	int
++	O
)	O
{	O
VALUE	O
(	O
s	pointer
,	O
i	long
,	O
j	int
)	O
=	O
0.0	int
;	O
}	O
}	O
}	O
static	O
void	O
accumulate_distribution	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
coord	int
bin	pointer
[	O
]	O
,	O
double	O
y	double
)	O
{	O
size_t	long
j	int
;	O
size_t	long
dim	long
=	O
s	pointer
->	O
dim	long
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dim	long
;	O
j	int
++	O
)	O
{	O
int	O
i	long
=	O
bin	pointer
[	O
j	int
]	O
;	O
VALUE	O
(	O
s	pointer
,	O
i	long
,	O
j	int
)	O
+=	O
y	double
;	O
}	O
}	O
static	O
void	O
random_point	function
(	O
double	O
x	double
[	O
]	O
,	O
coord	int
bin	pointer
[	O
]	O
,	O
double	O
*	O
bin_vol	pointer
,	O
const	O
coord	int
box	pointer
[	O
]	O
,	O
const	O
double	O
xl	array
[	O
]	O
,	O
const	O
double	O
xu	array
[	O
]	O
,	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
gsl_rng	struct
*	O
r	pointer
)	O
{	O
double	O
vol	double
=	O
1.0	int
;	O
size_t	long
j	int
;	O
size_t	long
dim	long
=	O
s	pointer
->	O
dim	long
;	O
size_t	long
bins	int
=	O
s	pointer
->	O
bins	int
;	O
size_t	long
boxes	int
=	O
s	pointer
->	O
boxes	int
;	O
DISCARD_POINTER	O
(	O
xu	array
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dim	long
;	O
++	O
j	int
)	O
{	O
double	O
z	double
=	O
(	O
(	O
box	pointer
[	O
j	int
]	O
+	O
gsl_rng_uniform_pos	function
(	O
r	pointer
)	O
)	O
/	O
boxes	int
)	O
*	O
bins	int
;	O
int	O
k	long
=	O
z	double
;	O
double	O
y	double
,	O
bin_width	double
;	O
bin	pointer
[	O
j	int
]	O
=	O
k	long
;	O
if	O
(	O
k	long
==	O
0	int
)	O
{	O
bin_width	double
=	O
COORD	O
(	O
s	pointer
,	O
1	int
,	O
j	int
)	O
;	O
y	double
=	O
z	double
*	O
bin_width	double
;	O
}	O
else	O
{	O
bin_width	double
=	O
COORD	O
(	O
s	pointer
,	O
k	long
+	O
1	int
,	O
j	int
)	O
-	O
COORD	O
(	O
s	pointer
,	O
k	long
,	O
j	int
)	O
;	O
y	double
=	O
COORD	O
(	O
s	pointer
,	O
k	long
,	O
j	int
)	O
+	O
(	O
z	double
-	O
k	long
)	O
*	O
bin_width	double
;	O
}	O
x	double
[	O
j	int
]	O
=	O
xl	array
[	O
j	int
]	O
+	O
y	double
*	O
s	pointer
->	O
delx	pointer
[	O
j	int
]	O
;	O
vol	double
*=	O
bin_width	double
;	O
}	O
*	O
bin_vol	pointer
=	O
vol	double
;	O
}	O
static	O
void	O
resize_grid	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
,	O
unsigned	O
int	O
bins	int
)	O
{	O
size_t	long
j	int
,	O
k	long
;	O
size_t	long
dim	long
=	O
s	pointer
->	O
dim	long
;	O
double	O
pts_per_bin	double
=	O
(	O
double	O
)	O
s	pointer
->	O
bins	int
/	O
(	O
double	O
)	O
bins	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dim	long
;	O
j	int
++	O
)	O
{	O
double	O
xold	double
;	O
double	O
xnew	double
=	O
0	int
;	O
double	O
dw	double
=	O
0	int
;	O
int	O
i	long
=	O
1	int
;	O
for	O
(	O
k	long
=	O
1	int
;	O
k	long
<=	O
s	pointer
->	O
bins	int
;	O
k	long
++	O
)	O
{	O
dw	double
+=	O
1.0	int
;	O
xold	double
=	O
xnew	double
;	O
xnew	double
=	O
COORD	O
(	O
s	pointer
,	O
k	long
,	O
j	int
)	O
;	O
for	O
(	O
;	O
dw	double
>	O
pts_per_bin	double
;	O
i	long
++	O
)	O
{	O
dw	double
-=	O
pts_per_bin	double
;	O
NEW_COORD	O
(	O
s	pointer
,	O
i	long
)	O
=	O
xnew	double
-	O
(	O
xnew	double
-	O
xold	double
)	O
*	O
dw	double
;	O
}	O
}	O
for	O
(	O
k	long
=	O
1	int
;	O
k	long
<	O
bins	int
;	O
k	long
++	O
)	O
{	O
COORD	O
(	O
s	pointer
,	O
k	long
,	O
j	int
)	O
=	O
NEW_COORD	O
(	O
s	pointer
,	O
k	long
)	O
;	O
}	O
COORD	O
(	O
s	pointer
,	O
bins	int
,	O
j	int
)	O
=	O
1	int
;	O
}	O
s	pointer
->	O
bins	int
=	O
bins	int
;	O
}	O
static	O
void	O
refine_grid	function
(	O
gsl_monte_vegas_state	struct
*	O
s	pointer
)	O
{	O
size_t	long
i	long
,	O
j	int
,	O
k	long
;	O
size_t	long
dim	long
=	O
s	pointer
->	O
dim	long
;	O
size_t	long
bins	int
=	O
s	pointer
->	O
bins	int
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dim	long
;	O
j	int
++	O
)	O
{	O
double	O
grid_tot_j	double
,	O
tot_weight	double
;	O
double	O
*	O
weight	pointer
=	O
s	pointer
->	O
weight	pointer
;	O
double	O
oldg	double
=	O
VALUE	O
(	O
s	pointer
,	O
0	int
,	O
j	int
)	O
;	O
double	O
newg	double
=	O
VALUE	O
(	O
s	pointer
,	O
1	int
,	O
j	int
)	O
;	O
VALUE	O
(	O
s	pointer
,	O
0	int
,	O
j	int
)	O
=	O
(	O
oldg	double
+	O
newg	double
)	O
/	O
2	int
;	O
grid_tot_j	double
=	O
VALUE	O
(	O
s	pointer
,	O
0	int
,	O
j	int
)	O
;	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
bins	int
-	O
1	int
;	O
i	long
++	O
)	O
{	O
double	O
rc	double
=	O
oldg	double
+	O
newg	double
;	O
oldg	double
=	O
newg	double
;	O
newg	double
=	O
VALUE	O
(	O
s	pointer
,	O
i	long
+	O
1	int
,	O
j	int
)	O
;	O
VALUE	O
(	O
s	pointer
,	O
i	long
,	O
j	int
)	O
=	O
(	O
rc	double
+	O
newg	double
)	O
/	O
3	int
;	O
grid_tot_j	double
+=	O
VALUE	O
(	O
s	pointer
,	O
i	long
,	O
j	int
)	O
;	O
}	O
VALUE	O
(	O
s	pointer
,	O
bins	int
-	O
1	int
,	O
j	int
)	O
=	O
(	O
newg	double
+	O
oldg	double
)	O
/	O
2	int
;	O
grid_tot_j	double
+=	O
VALUE	O
(	O
s	pointer
,	O
bins	int
-	O
1	int
,	O
j	int
)	O
;	O
tot_weight	double
=	O
0	int
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
bins	int
;	O
i	long
++	O
)	O
{	O
weight	pointer
[	O
i	long
]	O
=	O
0	int
;	O
if	O
(	O
VALUE	O
(	O
s	pointer
,	O
i	long
,	O
j	int
)	O
>	O
0	int
)	O
{	O
oldg	double
=	O
grid_tot_j	double
/	O
VALUE	O
(	O
s	pointer
,	O
i	long
,	O
j	int
)	O
;	O
weight	pointer
[	O
i	long
]	O
=	O
pow	function
(	O
(	O
(	O
oldg	double
-	O
1	int
)	O
/	O
oldg	double
/	O
log	function
(	O
oldg	double
)	O
)	O
,	O
s	pointer
->	O
alpha	double
)	O
;	O
}	O
tot_weight	double
+=	O
weight	pointer
[	O
i	long
]	O
;	O
}	O
{	O
double	O
pts_per_bin	double
=	O
tot_weight	double
/	O
bins	int
;	O
double	O
xold	double
;	O
double	O
xnew	double
=	O
0	int
;	O
double	O
dw	double
=	O
0	int
;	O
i	long
=	O
1	int
;	O
for	O
(	O
k	long
=	O
0	int
;	O
k	long
<	O
bins	int
;	O
k	long
++	O
)	O
{	O
dw	double
+=	O
weight	pointer
[	O
k	long
]	O
;	O
xold	double
=	O
xnew	double
;	O
xnew	double
=	O
COORD	O
(	O
s	pointer
,	O
k	long
+	O
1	int
,	O
j	int
)	O
;	O
for	O
(	O
;	O
dw	double
>	O
pts_per_bin	double
;	O
i	long
++	O
)	O
{	O
dw	double
-=	O
pts_per_bin	double
;	O
NEW_COORD	O
(	O
s	pointer
,	O
i	long
)	O
=	O
xnew	double
-	O
(	O
xnew	double
-	O
xold	double
)	O
*	O
dw	double
/	O
weight	pointer
[	O
k	long
]	O
;	O
}	O
}	O
for	O
(	O
k	long
=	O
1	int
;	O
k	long
<	O
bins	int
;	O
k	long
++	O
)	O
{	O
COORD	O
(	O
s	pointer
,	O
k	long
,	O
j	int
)	O
=	O
NEW_COORD	O
(	O
s	pointer
,	O
k	long
)	O
;	O
}	O
COORD	O
(	O
s	pointer
,	O
bins	int
,	O
j	int
)	O
=	O
1	int
;	O
}	O
}	O
}	O
static	O
void	O
print_lim	function
(	O
gsl_monte_vegas_state	struct
*	O
state	pointer
,	O
double	O
xl	array
[	O
]	O
,	O
double	O
xu	array
[	O
]	O
,	O
unsigned	O
long	O
dim	long
)	O
{	O
unsigned	O
long	O
j	int
;	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"The limits of integration are:\n"	pointer
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dim	long
;	O
++	O
j	int
)	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"\nxl[%lu]=%f    xu[%lu]=%f"	pointer
,	O
j	int
,	O
xl	array
[	O
j	int
]	O
,	O
j	int
,	O
xu	array
[	O
j	int
]	O
)	O
;	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
state	pointer
->	O
ostream	pointer
)	O
;	O
}	O
static	O
void	O
print_head	function
(	O
gsl_monte_vegas_state	struct
*	O
state	pointer
,	O
unsigned	O
long	O
num_dim	long
,	O
unsigned	O
long	O
calls	long
,	O
unsigned	O
int	O
it_num	int
,	O
unsigned	O
int	O
bins	int
,	O
unsigned	O
int	O
boxes	int
)	O
{	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"\nnum_dim=%lu, calls=%lu, it_num=%d, max_it_num=%d "	pointer
,	O
num_dim	long
,	O
calls	long
,	O
it_num	int
,	O
state	pointer
->	O
iterations	int
)	O
;	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"verb=%d, alph=%.2f,\nmode=%d, bins=%d, boxes=%d\n"	pointer
,	O
state	pointer
->	O
verbose	int
,	O
state	pointer
->	O
alpha	double
,	O
state	pointer
->	O
mode	int
,	O
bins	int
,	O
boxes	int
)	O
;	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"\n       single.......iteration                   "	pointer
)	O
;	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"accumulated......results   \n"	pointer
)	O
;	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"iteration     integral    sigma             integral   "	pointer
)	O
;	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"      sigma     chi-sq/it\n\n"	pointer
)	O
;	O
fflush	function
(	O
state	pointer
->	O
ostream	pointer
)	O
;	O
}	O
static	O
void	O
print_res	function
(	O
gsl_monte_vegas_state	struct
*	O
state	pointer
,	O
unsigned	O
int	O
itr	int
,	O
double	O
res	double
,	O
double	O
err	double
,	O
double	O
cum_res	double
,	O
double	O
cum_err	double
,	O
double	O
chi_sq	double
)	O
{	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"%4d        %6.4e %10.2e          %6.4e      %8.2e  %10.2e\n"	pointer
,	O
itr	int
,	O
res	double
,	O
err	double
,	O
cum_res	double
,	O
cum_err	double
,	O
chi_sq	double
)	O
;	O
fflush	function
(	O
state	pointer
->	O
ostream	pointer
)	O
;	O
}	O
static	O
void	O
print_dist	function
(	O
gsl_monte_vegas_state	struct
*	O
state	pointer
,	O
unsigned	O
long	O
dim	long
)	O
{	O
unsigned	O
long	O
i	long
,	O
j	int
;	O
int	O
p	pointer
=	O
state	pointer
->	O
verbose	int
;	O
if	O
(	O
p	pointer
<	O
1	int
)	O
return	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dim	long
;	O
++	O
j	int
)	O
{	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"\n axis %lu \n"	pointer
,	O
j	int
)	O
;	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"      x   g\n"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<	O
state	pointer
->	O
bins	int
;	O
i	long
++	O
)	O
{	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"weight [%11.2e , %11.2e] = "	pointer
,	O
COORD	O
(	O
state	pointer
,	O
i	long
,	O
j	int
)	O
,	O
COORD	O
(	O
state	pointer
,	O
i	long
+	O
1	int
,	O
j	int
)	O
)	O
;	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
" %11.2e\n"	pointer
,	O
VALUE	O
(	O
state	pointer
,	O
i	long
,	O
j	int
)	O
)	O
;	O
}	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
state	pointer
->	O
ostream	pointer
)	O
;	O
}	O
static	O
void	O
print_grid	function
(	O
gsl_monte_vegas_state	struct
*	O
state	pointer
,	O
unsigned	O
long	O
dim	long
)	O
{	O
unsigned	O
long	O
i	long
,	O
j	int
;	O
int	O
p	pointer
=	O
state	pointer
->	O
verbose	int
;	O
if	O
(	O
p	pointer
<	O
1	int
)	O
return	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
dim	long
;	O
++	O
j	int
)	O
{	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"\n axis %lu \n"	pointer
,	O
j	int
)	O
;	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"      x   \n"	pointer
)	O
;	O
for	O
(	O
i	long
=	O
0	int
;	O
i	long
<=	O
state	pointer
->	O
bins	int
;	O
i	long
++	O
)	O
{	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"%11.2e"	pointer
,	O
COORD	O
(	O
state	pointer
,	O
i	long
,	O
j	int
)	O
)	O
;	O
if	O
(	O
i	long
%	O
5	int
==	O
4	int
)	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
fprintf	function
(	O
state	pointer
->	O
ostream	pointer
,	O
"\n"	pointer
)	O
;	O
fflush	function
(	O
state	pointer
->	O
ostream	pointer
)	O
;	O
}	O
