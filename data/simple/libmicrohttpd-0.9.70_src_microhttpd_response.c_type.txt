static	O
int	O
add_response_entry	function
(	O
struct	O
MHD_Response	struct
*	O
response	pointer
,	O
enum	O
MHD_ValueKind	enum
kind	enum
,	O
const	O
char	O
*	O
header	pointer
,	O
const	O
char	O
*	O
content	pointer
)	O
{	O
struct	O
MHD_HTTP_Header	struct
*	O
hdr	pointer
;	O
if	O
(	O
(	O
NULL	O
==	O
response	pointer
)	O
||	O
(	O
NULL	O
==	O
header	pointer
)	O
||	O
(	O
NULL	O
==	O
content	pointer
)	O
||	O
(	O
0	int
==	O
header	pointer
[	O
0	int
]	O
)	O
||	O
(	O
0	int
==	O
content	pointer
[	O
0	int
]	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	function
(	O
header	pointer
,	O
'\t'	O
)	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	function
(	O
header	pointer
,	O
'\r'	O
)	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	function
(	O
header	pointer
,	O
'\n'	O
)	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	function
(	O
content	pointer
,	O
'\t'	O
)	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	function
(	O
content	pointer
,	O
'\r'	O
)	O
)	O
||	O
(	O
NULL	O
!=	O
strchr	function
(	O
content	pointer
,	O
'\n'	O
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
NULL	O
==	O
(	O
hdr	pointer
=	O
malloc	function
(	O
sizeof	O
(	O
struct	O
MHD_HTTP_Header	struct
)	O
)	O
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
NULL	O
==	O
(	O
hdr	pointer
->	O
header	pointer
=	O
strdup	function
(	O
header	pointer
)	O
)	O
)	O
{	O
free	function
(	O
hdr	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
hdr	pointer
->	O
header_size	long
=	O
strlen	function
(	O
header	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
(	O
hdr	pointer
->	O
value	long
=	O
strdup	function
(	O
content	pointer
)	O
)	O
)	O
{	O
free	function
(	O
hdr	pointer
->	O
header	pointer
)	O
;	O
free	function
(	O
hdr	pointer
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
hdr	pointer
->	O
value_size	long
=	O
strlen	function
(	O
content	pointer
)	O
;	O
hdr	pointer
->	O
kind	enum
=	O
kind	enum
;	O
hdr	pointer
->	O
next	pointer
=	O
response	pointer
->	O
first_header	pointer
;	O
response	pointer
->	O
first_header	pointer
=	O
hdr	pointer
;	O
return	O
MHD_YES	int
;	O
}	O
int	O
MHD_add_response_header	function
(	O
struct	O
MHD_Response	struct
*	O
response	pointer
,	O
const	O
char	O
*	O
header	pointer
,	O
const	O
char	O
*	O
content	pointer
)	O
{	O
if	O
(	O
(	O
MHD_str_equal_caseless_	function
(	O
header	pointer
,	O
MHD_HTTP_HEADER_TRANSFER_ENCODING	pointer
)	O
)	O
&&	O
(	O
!	O
MHD_str_equal_caseless_	function
(	O
content	pointer
,	O
"identity"	pointer
)	O
)	O
&&	O
(	O
!	O
MHD_str_equal_caseless_	function
(	O
content	pointer
,	O
"chunked"	pointer
)	O
)	O
)	O
{	O
return	O
MHD_NO	int
;	O
}	O
if	O
(	O
(	O
0	int
==	O
(	O
MHD_RF_INSANITY_HEADER_CONTENT_LENGTH	int
&	O
response	pointer
->	O
flags	int
)	O
)	O
&&	O
(	O
MHD_str_equal_caseless_	function
(	O
header	pointer
,	O
MHD_HTTP_HEADER_CONTENT_LENGTH	pointer
)	O
)	O
)	O
{	O
return	O
MHD_NO	int
;	O
}	O
return	O
add_response_entry	function
(	O
response	pointer
,	O
MHD_HEADER_KIND	int
,	O
header	pointer
,	O
content	pointer
)	O
;	O
}	O
int	O
MHD_add_response_footer	function
(	O
struct	O
MHD_Response	struct
*	O
response	pointer
,	O
const	O
char	O
*	O
footer	pointer
,	O
const	O
char	O
*	O
content	pointer
)	O
{	O
return	O
add_response_entry	function
(	O
response	pointer
,	O
MHD_FOOTER_KIND	int
,	O
footer	pointer
,	O
content	pointer
)	O
;	O
}	O
int	O
MHD_del_response_header	function
(	O
struct	O
MHD_Response	struct
*	O
response	pointer
,	O
const	O
char	O
*	O
header	pointer
,	O
const	O
char	O
*	O
content	pointer
)	O
{	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
struct	O
MHD_HTTP_Header	struct
*	O
prev	pointer
;	O
size_t	long
header_len	long
;	O
size_t	long
content_len	long
;	O
if	O
(	O
(	O
NULL	O
==	O
header	pointer
)	O
||	O
(	O
NULL	O
==	O
content	pointer
)	O
)	O
return	O
MHD_NO	int
;	O
header_len	long
=	O
strlen	function
(	O
header	pointer
)	O
;	O
content_len	long
=	O
strlen	function
(	O
content	pointer
)	O
;	O
prev	pointer
=	O
NULL	O
;	O
pos	long
=	O
response	pointer
->	O
first_header	pointer
;	O
while	O
(	O
NULL	O
!=	O
pos	long
)	O
{	O
if	O
(	O
(	O
header_len	long
==	O
pos	long
->	O
header_size	long
)	O
&&	O
(	O
content_len	long
==	O
pos	long
->	O
value_size	long
)	O
&&	O
(	O
0	int
==	O
memcmp	function
(	O
header	pointer
,	O
pos	long
->	O
header	pointer
,	O
header_len	long
)	O
)	O
&&	O
(	O
0	int
==	O
memcmp	function
(	O
content	pointer
,	O
pos	long
->	O
value	long
,	O
content_len	long
)	O
)	O
)	O
{	O
free	function
(	O
pos	long
->	O
header	pointer
)	O
;	O
free	function
(	O
pos	long
->	O
value	long
)	O
;	O
if	O
(	O
NULL	O
==	O
prev	pointer
)	O
response	pointer
->	O
first_header	pointer
=	O
pos	long
->	O
next	pointer
;	O
else	O
prev	pointer
->	O
next	pointer
=	O
pos	long
->	O
next	pointer
;	O
free	function
(	O
pos	long
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
prev	pointer
=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
;	O
}	O
return	O
MHD_NO	int
;	O
}	O
int	O
MHD_get_response_headers	function
(	O
struct	O
MHD_Response	struct
*	O
response	pointer
,	O
MHD_KeyValueIterator	pointer
iterator	pointer
,	O
void	O
*	O
iterator_cls	pointer
)	O
{	O
int	O
numHeaders	int
=	O
0	int
;	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
for	O
(	O
pos	long
=	O
response	pointer
->	O
first_header	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
numHeaders	int
++	O
;	O
if	O
(	O
(	O
NULL	O
!=	O
iterator	pointer
)	O
&&	O
(	O
MHD_YES	int
!=	O
iterator	pointer
(	O
iterator_cls	pointer
,	O
pos	long
->	O
kind	enum
,	O
pos	long
->	O
header	pointer
,	O
pos	long
->	O
value	long
)	O
)	O
)	O
break	O
;	O
}	O
return	O
numHeaders	int
;	O
}	O
const	O
char	O
*	O
MHD_get_response_header	function
(	O
struct	O
MHD_Response	struct
*	O
response	pointer
,	O
const	O
char	O
*	O
key	pointer
)	O
{	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
size_t	long
key_size	long
;	O
if	O
(	O
NULL	O
==	O
key	pointer
)	O
return	O
NULL	O
;	O
key_size	long
=	O
strlen	function
(	O
key	pointer
)	O
;	O
for	O
(	O
pos	long
=	O
response	pointer
->	O
first_header	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
pos	long
->	O
header_size	long
==	O
key_size	long
)	O
&&	O
(	O
MHD_str_equal_caseless_bin_n_	function
(	O
pos	long
->	O
header	pointer
,	O
key	pointer
,	O
pos	long
->	O
header_size	long
)	O
)	O
)	O
return	O
pos	long
->	O
value	long
;	O
}	O
return	O
NULL	O
;	O
}	O
bool	bool
MHD_check_response_header_token_ci	function
(	O
const	O
struct	O
MHD_Response	struct
*	O
response	pointer
,	O
const	O
char	O
*	O
key	pointer
,	O
size_t	long
key_len	long
,	O
const	O
char	O
*	O
token	pointer
,	O
size_t	long
token_len	long
)	O
{	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
if	O
(	O
(	O
NULL	O
==	O
key	pointer
)	O
||	O
(	O
'\0'	O
==	O
key	pointer
[	O
0	int
]	O
)	O
||	O
(	O
NULL	O
==	O
token	pointer
)	O
||	O
(	O
'\0'	O
==	O
token	pointer
[	O
0	int
]	O
)	O
)	O
return	O
false	int
;	O
mhd_assert	O
(	O
strlen	function
(	O
token	pointer
)	O
==	O
token_len	long
)	O
;	O
for	O
(	O
pos	long
=	O
response	pointer
->	O
first_header	pointer
;	O
NULL	O
!=	O
pos	long
;	O
pos	long
=	O
pos	long
->	O
next	pointer
)	O
{	O
if	O
(	O
(	O
pos	long
->	O
kind	enum
==	O
MHD_HEADER_KIND	int
)	O
&&	O
(	O
key_len	long
==	O
pos	long
->	O
header_size	long
)	O
&&	O
MHD_str_equal_caseless_bin_n_	function
(	O
pos	long
->	O
header	pointer
,	O
key	pointer
,	O
key_len	long
)	O
&&	O
MHD_str_has_token_caseless_	function
(	O
pos	long
->	O
value	long
,	O
token	pointer
,	O
token_len	long
)	O
)	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
struct	O
MHD_Response	struct
*	O
MHD_create_response_from_callback	function
(	O
uint64_t	long
size	long
,	O
size_t	long
block_size	long
,	O
MHD_ContentReaderCallback	pointer
crc	pointer
,	O
void	O
*	O
crc_cls	pointer
,	O
MHD_ContentReaderFreeCallback	pointer
crfc	pointer
)	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
if	O
(	O
(	O
NULL	O
==	O
crc	pointer
)	O
||	O
(	O
0	int
==	O
block_size	long
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
NULL	O
==	O
(	O
response	pointer
=	O
MHD_calloc_	O
(	O
1	int
,	O
sizeof	O
(	O
struct	O
MHD_Response	struct
)	O
+	O
block_size	long
)	O
)	O
)	O
return	O
NULL	O
;	O
response	pointer
->	O
fd	int
=	O
-	O
1	int
;	O
response	pointer
->	O
data	pointer
=	O
(	O
void	O
*	O
)	O
&	O
response	pointer
[	O
1	int
]	O
;	O
response	pointer
->	O
data_buffer_size	long
=	O
block_size	long
;	O
if	O
(	O
!	O
MHD_mutex_init_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
)	O
{	O
free	function
(	O
response	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
response	pointer
->	O
crc	pointer
=	O
crc	pointer
;	O
response	pointer
->	O
crfc	pointer
=	O
crfc	pointer
;	O
response	pointer
->	O
crc_cls	pointer
=	O
crc_cls	pointer
;	O
response	pointer
->	O
reference_count	int
=	O
1	int
;	O
response	pointer
->	O
total_size	long
=	O
size	long
;	O
return	O
response	pointer
;	O
}	O
int	O
MHD_set_response_options	function
(	O
struct	O
MHD_Response	struct
*	O
response	pointer
,	O
enum	O
MHD_ResponseFlags	enum
flags	int
,	O
...	O
)	O
{	O
va_list	array
ap	array
;	O
int	O
ret	int
;	O
enum	O
MHD_ResponseOptions	enum
ro	enum
;	O
ret	int
=	O
MHD_YES	int
;	O
response	pointer
->	O
flags	int
=	O
flags	int
;	O
va_start	O
(	O
ap	array
,	O
flags	int
)	O
;	O
while	O
(	O
MHD_RO_END	int
!=	O
(	O
ro	enum
=	O
va_arg	O
(	O
ap	array
,	O
enum	O
MHD_ResponseOptions	enum
)	O
)	O
)	O
{	O
switch	O
(	O
ro	enum
)	O
{	O
default	O
:	O
ret	int
=	O
MHD_NO	int
;	O
break	O
;	O
}	O
}	O
va_end	O
(	O
ap	array
)	O
;	O
return	O
ret	int
;	O
}	O
static	O
ssize_t	long
file_reader	function
(	O
void	O
*	O
cls	pointer
,	O
uint64_t	long
pos	long
,	O
char	O
*	O
buf	pointer
,	O
size_t	long
max	long
)	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
=	O
cls	pointer
;	O
ssize_t	long
n	long
;	O
const	O
int64_t	long
offset64	long
=	O
(	O
int64_t	long
)	O
(	O
pos	long
+	O
response	pointer
->	O
fd_off	long
)	O
;	O
if	O
(	O
offset64	long
<	O
0	int
)	O
return	O
MHD_CONTENT_READER_END_WITH_ERROR	O
;	O
if	O
(	O
max	long
>	O
SSIZE_MAX	O
)	O
max	long
=	O
SSIZE_MAX	O
;	O
n	long
=	O
pread64	function
(	O
response	pointer
->	O
fd	int
,	O
buf	pointer
,	O
max	long
,	O
offset64	long
)	O
;	O
if	O
(	O
0	int
==	O
n	long
)	O
return	O
MHD_CONTENT_READER_END_OF_STREAM	O
;	O
if	O
(	O
n	long
<	O
0	int
)	O
return	O
MHD_CONTENT_READER_END_WITH_ERROR	O
;	O
return	O
n	long
;	O
}	O
static	O
void	O
free_callback	function
(	O
void	O
*	O
cls	pointer
)	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
=	O
cls	pointer
;	O
(	O
void	O
)	O
close	pointer
(	O
response	pointer
->	O
fd	int
)	O
;	O
response	pointer
->	O
fd	int
=	O
-	O
1	int
;	O
}	O
struct	O
MHD_Response	struct
*	O
MHD_create_response_from_fd_at_offset	function
(	O
size_t	long
size	long
,	O
int	O
fd	int
,	O
off_t	long
offset	long
)	O
{	O
return	O
MHD_create_response_from_fd_at_offset64	function
(	O
size	long
,	O
fd	int
,	O
offset	long
)	O
;	O
}	O
_MHD_EXTERN	O
struct	O
MHD_Response	struct
*	O
MHD_create_response_from_fd_at_offset64	function
(	O
uint64_t	long
size	long
,	O
int	O
fd	int
,	O
uint64_t	long
offset	long
)	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
if	O
(	O
(	O
(	O
int64_t	long
)	O
size	long
<	O
0	int
)	O
||	O
(	O
(	O
int64_t	long
)	O
offset	long
<	O
0	int
)	O
||	O
(	O
(	O
int64_t	long
)	O
(	O
size	long
+	O
offset	long
)	O
<	O
0	int
)	O
)	O
return	O
NULL	O
;	O
response	pointer
=	O
MHD_create_response_from_callback	function
(	O
size	long
,	O
MHD_FILE_READ_BLOCK_SIZE	int
,	O
&	O
file_reader	function
,	O
NULL	O
,	O
&	O
free_callback	function
)	O
;	O
if	O
(	O
NULL	O
==	O
response	pointer
)	O
return	O
NULL	O
;	O
response	pointer
->	O
fd	int
=	O
fd	int
;	O
response	pointer
->	O
fd_off	long
=	O
offset	long
;	O
response	pointer
->	O
crc_cls	pointer
=	O
response	pointer
;	O
return	O
response	pointer
;	O
}	O
struct	O
MHD_Response	struct
*	O
MHD_create_response_from_fd	function
(	O
size_t	long
size	long
,	O
int	O
fd	int
)	O
{	O
return	O
MHD_create_response_from_fd_at_offset64	function
(	O
size	long
,	O
fd	int
,	O
0	int
)	O
;	O
}	O
_MHD_EXTERN	O
struct	O
MHD_Response	struct
*	O
MHD_create_response_from_fd64	function
(	O
uint64_t	long
size	long
,	O
int	O
fd	int
)	O
{	O
return	O
MHD_create_response_from_fd_at_offset64	function
(	O
size	long
,	O
fd	int
,	O
0	int
)	O
;	O
}	O
struct	O
MHD_Response	struct
*	O
MHD_create_response_from_data	function
(	O
size_t	long
size	long
,	O
void	O
*	O
data	pointer
,	O
int	O
must_free	int
,	O
int	O
must_copy	int
)	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
void	O
*	O
tmp	pointer
;	O
if	O
(	O
(	O
NULL	O
==	O
data	pointer
)	O
&&	O
(	O
size	long
>	O
0	int
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
NULL	O
==	O
(	O
response	pointer
=	O
MHD_calloc_	O
(	O
1	int
,	O
sizeof	O
(	O
struct	O
MHD_Response	struct
)	O
)	O
)	O
)	O
return	O
NULL	O
;	O
response	pointer
->	O
fd	int
=	O
-	O
1	int
;	O
if	O
(	O
!	O
MHD_mutex_init_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
)	O
{	O
free	function
(	O
response	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
(	O
must_copy	int
)	O
&&	O
(	O
size	long
>	O
0	int
)	O
)	O
{	O
if	O
(	O
NULL	O
==	O
(	O
tmp	pointer
=	O
malloc	function
(	O
size	long
)	O
)	O
)	O
{	O
MHD_mutex_destroy_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
free	function
(	O
response	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
memcpy	function
(	O
tmp	pointer
,	O
data	pointer
,	O
size	long
)	O
;	O
must_free	int
=	O
MHD_YES	int
;	O
data	pointer
=	O
tmp	pointer
;	O
}	O
if	O
(	O
must_free	int
)	O
{	O
response	pointer
->	O
crfc	pointer
=	O
&	O
free	function
;	O
response	pointer
->	O
crc_cls	pointer
=	O
data	pointer
;	O
}	O
response	pointer
->	O
reference_count	int
=	O
1	int
;	O
response	pointer
->	O
total_size	long
=	O
size	long
;	O
response	pointer
->	O
data	pointer
=	O
data	pointer
;	O
response	pointer
->	O
data_size	long
=	O
size	long
;	O
return	O
response	pointer
;	O
}	O
struct	O
MHD_Response	struct
*	O
MHD_create_response_from_buffer	function
(	O
size_t	long
size	long
,	O
void	O
*	O
buffer	pointer
,	O
enum	O
MHD_ResponseMemoryMode	enum
mode	int
)	O
{	O
return	O
MHD_create_response_from_data	function
(	O
size	long
,	O
buffer	pointer
,	O
mode	int
==	O
MHD_RESPMEM_MUST_FREE	int
,	O
mode	int
==	O
MHD_RESPMEM_MUST_COPY	int
)	O
;	O
}	O
_MHD_EXTERN	O
struct	O
MHD_Response	struct
*	O
MHD_create_response_from_buffer_with_free_callback	function
(	O
size_t	long
size	long
,	O
void	O
*	O
buffer	pointer
,	O
MHD_ContentReaderFreeCallback	pointer
crfc	pointer
)	O
{	O
struct	O
MHD_Response	struct
*	O
r	pointer
;	O
r	pointer
=	O
MHD_create_response_from_data	function
(	O
size	long
,	O
buffer	pointer
,	O
MHD_YES	int
,	O
MHD_NO	int
)	O
;	O
if	O
(	O
NULL	O
==	O
r	pointer
)	O
return	O
r	pointer
;	O
r	pointer
->	O
crfc	pointer
=	O
crfc	pointer
;	O
return	O
r	pointer
;	O
}	O
_MHD_EXTERN	O
int	O
MHD_upgrade_action	function
(	O
struct	O
MHD_UpgradeResponseHandle	struct
*	O
urh	pointer
,	O
enum	O
MHD_UpgradeAction	enum
action	enum
,	O
...	O
)	O
{	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
;	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
;	O
if	O
(	O
NULL	O
==	O
urh	pointer
)	O
return	O
MHD_NO	int
;	O
connection	pointer
=	O
urh	pointer
->	O
connection	pointer
;	O
if	O
(	O
NULL	O
==	O
connection	pointer
)	O
return	O
MHD_NO	int
;	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
if	O
(	O
NULL	O
==	O
daemon	function
)	O
return	O
MHD_NO	int
;	O
switch	O
(	O
action	enum
)	O
{	O
case	O
MHD_UPGRADE_ACTION_CLOSE	int
:	O
if	O
(	O
urh	pointer
->	O
was_closed	bool
)	O
return	O
MHD_NO	int
;	O
mhd_assert	O
(	O
MHD_CONNECTION_UPGRADE	int
==	O
connection	pointer
->	O
state	pointer
)	O
;	O
urh	pointer
->	O
was_closed	bool
=	O
true	int
;	O
MHD_resume_connection	function
(	O
connection	pointer
)	O
;	O
return	O
MHD_YES	int
;	O
case	O
MHD_UPGRADE_ACTION_CORK_ON	int
:	O
if	O
(	O
connection	pointer
->	O
sk_cork_on	bool
)	O
return	O
MHD_YES	int
;	O
{	O
if	O
(	O
0	int
==	O
MHD_socket_cork_	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
true	int
)	O
)	O
{	O
connection	pointer
->	O
sk_cork_on	bool
=	O
true	int
;	O
return	O
MHD_YES	int
;	O
}	O
return	O
MHD_NO	int
;	O
}	O
case	O
MHD_UPGRADE_ACTION_CORK_OFF	int
:	O
if	O
(	O
!	O
connection	pointer
->	O
sk_cork_on	bool
)	O
return	O
MHD_YES	int
;	O
{	O
if	O
(	O
0	int
==	O
MHD_socket_cork_	function
(	O
connection	pointer
->	O
socket_fd	int
,	O
false	int
)	O
)	O
{	O
connection	pointer
->	O
sk_cork_on	bool
=	O
false	int
;	O
return	O
MHD_YES	int
;	O
}	O
return	O
MHD_NO	int
;	O
}	O
default	O
:	O
return	O
MHD_NO	int
;	O
}	O
}	O
int	O
MHD_response_execute_upgrade_	function
(	O
struct	O
MHD_Response	struct
*	O
response	pointer
,	O
struct	O
MHD_Connection	struct
*	O
connection	pointer
)	O
{	O
struct	O
MHD_Daemon	struct
*	O
daemon	function
=	O
connection	pointer
->	O
daemon	function
;	O
struct	O
MHD_UpgradeResponseHandle	struct
*	O
urh	pointer
;	O
size_t	long
rbo	long
;	O
if	O
(	O
0	int
==	O
(	O
daemon	function
->	O
options	enum
&	O
MHD_ALLOW_UPGRADE	int
)	O
)	O
return	O
MHD_NO	int
;	O
if	O
(	O
NULL	O
==	O
MHD_get_response_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_UPGRADE	pointer
)	O
)	O
{	O
MHD_DLOG	function
(	O
daemon	function
,	O
_	O
(	O
"Invalid response for upgrade: application failed to set the 'Upgrade' header!\n"	pointer
)	O
)	O
;	O
return	O
MHD_NO	int
;	O
}	O
urh	pointer
=	O
MHD_calloc_	O
(	O
1	int
,	O
sizeof	O
(	O
struct	O
MHD_UpgradeResponseHandle	struct
)	O
)	O
;	O
if	O
(	O
NULL	O
==	O
urh	pointer
)	O
return	O
MHD_NO	int
;	O
urh	pointer
->	O
connection	pointer
=	O
connection	pointer
;	O
rbo	long
=	O
connection	pointer
->	O
read_buffer_offset	long
;	O
connection	pointer
->	O
read_buffer_offset	long
=	O
0	int
;	O
urh	pointer
->	O
clean_ready	bool
=	O
true	int
;	O
connection	pointer
->	O
urh	pointer
=	O
urh	pointer
;	O
internal_suspend_connection_	function
(	O
connection	pointer
)	O
;	O
response	pointer
->	O
upgrade_handler	pointer
(	O
response	pointer
->	O
upgrade_handler_cls	pointer
,	O
connection	pointer
,	O
connection	pointer
->	O
client_context	pointer
,	O
connection	pointer
->	O
read_buffer	pointer
,	O
rbo	long
,	O
connection	pointer
->	O
socket_fd	int
,	O
urh	pointer
)	O
;	O
return	O
MHD_YES	int
;	O
}	O
_MHD_EXTERN	O
struct	O
MHD_Response	struct
*	O
MHD_create_response_for_upgrade	function
(	O
MHD_UpgradeHandler	pointer
upgrade_handler	pointer
,	O
void	O
*	O
upgrade_handler_cls	pointer
)	O
{	O
struct	O
MHD_Response	struct
*	O
response	pointer
;	O
if	O
(	O
NULL	O
==	O
upgrade_handler	pointer
)	O
return	O
NULL	O
;	O
response	pointer
=	O
MHD_calloc_	O
(	O
1	int
,	O
sizeof	O
(	O
struct	O
MHD_Response	struct
)	O
)	O
;	O
if	O
(	O
NULL	O
==	O
response	pointer
)	O
return	O
NULL	O
;	O
if	O
(	O
!	O
MHD_mutex_init_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
)	O
{	O
free	function
(	O
response	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
response	pointer
->	O
upgrade_handler	pointer
=	O
upgrade_handler	pointer
;	O
response	pointer
->	O
upgrade_handler_cls	pointer
=	O
upgrade_handler_cls	pointer
;	O
response	pointer
->	O
total_size	long
=	O
MHD_SIZE_UNKNOWN	O
;	O
response	pointer
->	O
reference_count	int
=	O
1	int
;	O
if	O
(	O
MHD_NO	int
==	O
MHD_add_response_header	function
(	O
response	pointer
,	O
MHD_HTTP_HEADER_CONNECTION	pointer
,	O
"Upgrade"	pointer
)	O
)	O
{	O
MHD_destroy_response	function
(	O
response	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
response	pointer
;	O
}	O
void	O
MHD_destroy_response	function
(	O
struct	O
MHD_Response	struct
*	O
response	pointer
)	O
{	O
struct	O
MHD_HTTP_Header	struct
*	O
pos	long
;	O
if	O
(	O
NULL	O
==	O
response	pointer
)	O
return	O
;	O
MHD_mutex_lock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
0	int
!=	O
--	O
(	O
response	pointer
->	O
reference_count	int
)	O
)	O
{	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
return	O
;	O
}	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
MHD_mutex_destroy_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
if	O
(	O
NULL	O
!=	O
response	pointer
->	O
crfc	pointer
)	O
response	pointer
->	O
crfc	pointer
(	O
response	pointer
->	O
crc_cls	pointer
)	O
;	O
while	O
(	O
NULL	O
!=	O
response	pointer
->	O
first_header	pointer
)	O
{	O
pos	long
=	O
response	pointer
->	O
first_header	pointer
;	O
response	pointer
->	O
first_header	pointer
=	O
pos	long
->	O
next	pointer
;	O
free	function
(	O
pos	long
->	O
header	pointer
)	O
;	O
free	function
(	O
pos	long
->	O
value	long
)	O
;	O
free	function
(	O
pos	long
)	O
;	O
}	O
free	function
(	O
response	pointer
)	O
;	O
}	O
void	O
MHD_increment_response_rc	function
(	O
struct	O
MHD_Response	struct
*	O
response	pointer
)	O
{	O
MHD_mutex_lock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
(	O
response	pointer
->	O
reference_count	int
)	O
++	O
;	O
MHD_mutex_unlock_chk_	O
(	O
&	O
response	pointer
->	O
mutex	union
)	O
;	O
}	O
