struct	O
command	pointer
{	O
char	O
*	O
verb	pointer
;	O
int	O
nargs	int
;	O
char	O
*	O
args	pointer
;	O
void	O
(	O
*	O
handler	array
)	O
(	O
mu_folder_t	pointer
folder	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
}	O
;	O
static	O
int	O
_print_list_entry	function
(	O
void	O
*	O
item	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
mu_list_response	struct
*	O
resp	pointer
=	O
item	pointer
;	O
mu_printf	function
(	O
"%c%c %c %4d %s\n"	pointer
,	O
(	O
resp	pointer
->	O
type	int
&	O
MU_FOLDER_ATTRIBUTE_DIRECTORY	int
)	O
?	O
'd'	O
:	O
'-'	O
,	O
(	O
resp	pointer
->	O
type	int
&	O
MU_FOLDER_ATTRIBUTE_FILE	int
)	O
?	O
'f'	O
:	O
'-'	O
,	O
resp	pointer
->	O
separator	int
?	O
resp	pointer
->	O
separator	int
:	O
' '	O
,	O
resp	pointer
->	O
depth	int
,	O
resp	pointer
->	O
name	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
void	O
com_list	function
(	O
mu_folder_t	pointer
folder	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
rc	int
;	O
mu_list_t	pointer
list	pointer
;	O
mu_printf	function
(	O
"listing %s %s\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_list	function
(	O
folder	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
1	int
]	O
,	O
0	int
,	O
&	O
list	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_list"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
rc	int
)	O
;	O
else	O
{	O
mu_list_foreach	function
(	O
list	pointer
,	O
_print_list_entry	function
,	O
NULL	O
)	O
;	O
mu_list_destroy	function
(	O
&	O
list	pointer
)	O
;	O
}	O
}	O
static	O
void	O
com_lsub	function
(	O
mu_folder_t	pointer
folder	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
rc	int
;	O
mu_list_t	pointer
list	pointer
;	O
mu_printf	function
(	O
"listing subscriptions for '%s' '%s'\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_lsub	function
(	O
folder	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
1	int
]	O
,	O
&	O
list	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_lsub"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
rc	int
)	O
;	O
else	O
{	O
mu_list_foreach	function
(	O
list	pointer
,	O
_print_list_entry	function
,	O
NULL	O
)	O
;	O
mu_list_destroy	function
(	O
&	O
list	pointer
)	O
;	O
}	O
}	O
static	O
void	O
com_delete	function
(	O
mu_folder_t	pointer
folder	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
rc	int
;	O
mu_printf	function
(	O
"deleting %s\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_delete	function
(	O
folder	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_lsub"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
rc	int
)	O
;	O
else	O
mu_printf	function
(	O
"delete successful\n"	pointer
)	O
;	O
}	O
static	O
void	O
com_rename	function
(	O
mu_folder_t	pointer
folder	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
rc	int
;	O
mu_printf	function
(	O
"renaming %s to %s\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_rename	function
(	O
folder	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_rename"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
rc	int
)	O
;	O
else	O
mu_printf	function
(	O
"rename successful\n"	pointer
)	O
;	O
}	O
static	O
void	O
com_subscribe	function
(	O
mu_folder_t	pointer
folder	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
rc	int
;	O
mu_printf	function
(	O
"subscribing %s\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_subscribe	function
(	O
folder	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_subscribe"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
rc	int
)	O
;	O
else	O
mu_printf	function
(	O
"subscribe successful\n"	pointer
)	O
;	O
}	O
static	O
void	O
com_unsubscribe	function
(	O
mu_folder_t	pointer
folder	pointer
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
rc	int
;	O
mu_printf	function
(	O
"unsubscribing %s\n"	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
rc	int
=	O
mu_folder_unsubscribe	function
(	O
folder	pointer
,	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
if	O
(	O
rc	int
)	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_unsubscribe"	pointer
,	O
argv	pointer
[	O
0	int
]	O
,	O
rc	int
)	O
;	O
else	O
mu_printf	function
(	O
"unsubscribe successful\n"	pointer
)	O
;	O
}	O
static	O
struct	O
command	pointer
comtab	array
[	O
]	O
=	O
{	O
{	O
"list"	pointer
,	O
2	int
,	O
"REF MBX"	pointer
,	O
com_list	function
}	O
,	O
{	O
"lsub"	pointer
,	O
2	int
,	O
"REF MBX"	pointer
,	O
com_lsub	function
}	O
,	O
{	O
"delete"	pointer
,	O
1	int
,	O
"MBX"	pointer
,	O
com_delete	function
}	O
,	O
{	O
"rename"	pointer
,	O
2	int
,	O
"OLD NEW"	pointer
,	O
com_rename	function
}	O
,	O
{	O
"subscribe"	pointer
,	O
1	int
,	O
"MBX"	pointer
,	O
com_subscribe	function
}	O
,	O
{	O
"unsubscribe"	pointer
,	O
1	int
,	O
"MBX"	pointer
,	O
com_unsubscribe	function
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
command	pointer
*	O
find_command	function
(	O
const	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
command	pointer
*	O
cp	pointer
;	O
for	O
(	O
cp	pointer
=	O
comtab	array
;	O
cp	pointer
->	O
verb	pointer
;	O
cp	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
cp	pointer
->	O
verb	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
return	O
cp	pointer
;	O
return	O
NULL	O
;	O
}	O
static	O
void	O
usage	function
(	O
)	O
{	O
struct	O
command	pointer
*	O
cp	pointer
;	O
mu_printf	function
(	O
"usage: %s [debug=SPEC] url=URL OP ARG [ARG...] [OP ARG [ARG...]...]\n"	pointer
,	O
mu_program_name	pointer
)	O
;	O
mu_printf	function
(	O
"OPerations and corresponding ARGuments are:\n"	pointer
)	O
;	O
for	O
(	O
cp	pointer
=	O
comtab	array
;	O
cp	pointer
->	O
verb	pointer
;	O
cp	pointer
++	O
)	O
mu_printf	function
(	O
" %s %s\n"	pointer
,	O
cp	pointer
->	O
verb	pointer
,	O
cp	pointer
->	O
args	pointer
)	O
;	O
}	O
int	O
main	function
(	O
int	O
argc	long
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
i	long
;	O
int	O
rc	int
;	O
mu_folder_t	pointer
folder	pointer
;	O
char	O
*	O
fname	pointer
=	O
NULL	O
;	O
mu_set_program_name	function
(	O
argv	pointer
[	O
0	int
]	O
)	O
;	O
mu_registrar_record	function
(	O
mu_imap_record	pointer
)	O
;	O
mu_registrar_record	function
(	O
mu_imaps_record	pointer
)	O
;	O
if	O
(	O
argc	long
==	O
1	int
)	O
{	O
usage	function
(	O
)	O
;	O
exit	function
(	O
0	int
)	O
;	O
}	O
for	O
(	O
i	long
=	O
1	int
;	O
i	long
<	O
argc	long
;	O
i	long
++	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
argv	pointer
[	O
i	long
]	O
,	O
"debug="	pointer
,	O
6	int
)	O
==	O
0	int
)	O
mu_debug_parse_spec	function
(	O
argv	pointer
[	O
i	long
]	O
+	O
6	int
)	O
;	O
else	O
if	O
(	O
strncmp	function
(	O
argv	pointer
[	O
i	long
]	O
,	O
"url="	pointer
,	O
4	int
)	O
==	O
0	int
)	O
fname	pointer
=	O
argv	pointer
[	O
i	long
]	O
+	O
4	int
;	O
else	O
break	O
;	O
}	O
if	O
(	O
!	O
fname	pointer
)	O
{	O
mu_error	function
(	O
"URL not specified"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
rc	int
=	O
mu_folder_create	function
(	O
&	O
folder	pointer
,	O
fname	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_create"	pointer
,	O
fname	pointer
,	O
rc	int
)	O
;	O
return	O
1	int
;	O
}	O
mu_folder_attach_ticket	function
(	O
folder	pointer
)	O
;	O
rc	int
=	O
mu_folder_open	function
(	O
folder	pointer
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_folder_open"	pointer
,	O
fname	pointer
,	O
rc	int
)	O
;	O
return	O
1	int
;	O
}	O
while	O
(	O
i	long
<	O
argc	long
)	O
{	O
char	O
*	O
comargs	array
[	O
2	int
]	O
;	O
struct	O
command	pointer
*	O
cmd	enum
;	O
cmd	enum
=	O
find_command	function
(	O
argv	pointer
[	O
i	long
]	O
)	O
;	O
if	O
(	O
!	O
cmd	enum
)	O
{	O
mu_error	function
(	O
"unknown command %s\n"	pointer
,	O
argv	pointer
[	O
i	long
]	O
)	O
;	O
break	O
;	O
}	O
i	long
++	O
;	O
if	O
(	O
i	long
+	O
cmd	enum
->	O
nargs	int
>	O
argc	long
)	O
{	O
mu_error	function
(	O
"not enough arguments for %s"	pointer
,	O
cmd	enum
->	O
verb	pointer
)	O
;	O
break	O
;	O
}	O
memcpy	function
(	O
comargs	array
,	O
argv	pointer
+	O
i	long
,	O
cmd	enum
->	O
nargs	int
*	O
sizeof	O
(	O
comargs	array
[	O
0	int
]	O
)	O
)	O
;	O
i	long
+=	O
cmd	enum
->	O
nargs	int
;	O
cmd	enum
->	O
handler	array
(	O
folder	pointer
,	O
comargs	array
)	O
;	O
}	O
mu_folder_close	function
(	O
folder	pointer
)	O
;	O
mu_folder_destroy	function
(	O
&	O
folder	pointer
)	O
;	O
return	O
0	int
;	O
}	O
