static	O
struct	O
transtab	struct
kwpri	array
[	O
]	O
=	O
{	O
{	O
"emerg"	pointer
,	O
LOG_EMERG	int
}	O
,	O
{	O
"alert"	pointer
,	O
LOG_ALERT	int
}	O
,	O
{	O
"crit"	pointer
,	O
LOG_CRIT	int
}	O
,	O
{	O
"err"	pointer
,	O
LOG_ERR	int
}	O
,	O
{	O
"warning"	pointer
,	O
LOG_WARNING	int
}	O
,	O
{	O
"notice"	pointer
,	O
LOG_NOTICE	int
}	O
,	O
{	O
"info"	pointer
,	O
LOG_INFO	int
}	O
,	O
{	O
"debug"	pointer
,	O
LOG_DEBUG	int
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
transtab	struct
kwfac	array
[	O
]	O
=	O
{	O
{	O
"user"	pointer
,	O
LOG_USER	O
}	O
,	O
{	O
"daemon"	pointer
,	O
LOG_DAEMON	O
}	O
,	O
{	O
"auth"	pointer
,	O
LOG_AUTH	O
}	O
,	O
{	O
"authpriv"	pointer
,	O
LOG_AUTHPRIV	O
}	O
,	O
{	O
"mail"	pointer
,	O
LOG_MAIL	O
}	O
,	O
{	O
"cron"	pointer
,	O
LOG_CRON	O
}	O
,	O
{	O
"local0"	pointer
,	O
LOG_LOCAL0	O
}	O
,	O
{	O
"local1"	pointer
,	O
LOG_LOCAL1	O
}	O
,	O
{	O
"local2"	pointer
,	O
LOG_LOCAL2	O
}	O
,	O
{	O
"local3"	pointer
,	O
LOG_LOCAL3	O
}	O
,	O
{	O
"local4"	pointer
,	O
LOG_LOCAL4	O
}	O
,	O
{	O
"local5"	pointer
,	O
LOG_LOCAL5	O
}	O
,	O
{	O
"local6"	pointer
,	O
LOG_LOCAL6	O
}	O
,	O
{	O
"local7"	pointer
,	O
LOG_LOCAL7	O
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
int	O
get_facility	function
(	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
int	O
f	int
;	O
char	O
*	O
p	pointer
;	O
errno	O
=	O
0	int
;	O
f	int
=	O
strtoul	function
(	O
arg	pointer
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
&&	O
errno	O
==	O
0	int
)	O
return	O
f	int
;	O
if	O
(	O
trans_strtotok	function
(	O
kwfac	array
,	O
arg	pointer
,	O
&	O
f	int
)	O
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
_	O
(	O
"unknown syslog facility: %s"	pointer
)	O
,	O
arg	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
f	int
;	O
}	O
int	O
get_priority	function
(	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
int	O
f	int
;	O
char	O
*	O
p	pointer
;	O
errno	O
=	O
0	int
;	O
f	int
=	O
strtoul	function
(	O
arg	pointer
,	O
&	O
p	pointer
,	O
0	int
)	O
;	O
if	O
(	O
*	O
p	pointer
==	O
0	int
&&	O
errno	O
==	O
0	int
)	O
return	O
f	int
;	O
if	O
(	O
trans_strtotok	function
(	O
kwpri	array
,	O
arg	pointer
,	O
&	O
f	int
)	O
)	O
{	O
diag	function
(	O
LOG_CRIT	int
,	O
_	O
(	O
"unknown syslog priority: %s"	pointer
)	O
,	O
arg	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
return	O
f	int
;	O
}	O
int	O
assert_grecs_value_type	function
(	O
grecs_locus_t	struct
*	O
locus	struct
,	O
const	O
grecs_value_t	struct
*	O
value	pointer
,	O
int	O
type	enum
)	O
{	O
if	O
(	O
GRECS_VALUE_EMPTY_P	O
(	O
value	pointer
)	O
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"expected %s"	pointer
)	O
,	O
grecs_data_type_string	function
(	O
type	enum
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
value	pointer
->	O
type	enum
!=	O
type	enum
)	O
{	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"expected %s, but found %s"	pointer
)	O
,	O
grecs_data_type_string	function
(	O
type	enum
)	O
,	O
grecs_data_type_string	function
(	O
value	pointer
->	O
type	enum
)	O
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_syslog_facility	function
(	O
enum	O
grecs_callback_command	enum
cmd	enum
,	O
grecs_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
varptr	pointer
,	O
void	O
*	O
cb_data	pointer
)	O
{	O
grecs_locus_t	struct
*	O
locus	struct
=	O
&	O
node	pointer
->	O
locus	struct
;	O
grecs_value_t	struct
*	O
value	pointer
=	O
node	pointer
->	O
v	union
.	O
value	pointer
;	O
int	O
fac	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum
,	O
locus	struct
)	O
;	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
value	pointer
->	O
locus	struct
,	O
value	pointer
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
trans_strtotok	function
(	O
kwfac	array
,	O
value	pointer
->	O
v	union
.	O
string	pointer
,	O
&	O
fac	int
)	O
)	O
grecs_error	function
(	O
&	O
value	pointer
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"unknown syslog facility `%s'"	pointer
)	O
,	O
value	pointer
->	O
v	union
.	O
string	pointer
)	O
;	O
else	O
*	O
(	O
int	O
*	O
)	O
varptr	pointer
=	O
fac	int
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
grecs_keyword	struct
syslog_kw	array
[	O
]	O
=	O
{	O
{	O
"facility"	pointer
,	O
N_	O
(	O
"name"	pointer
)	O
,	O
N_	O
(	O
"Set syslog facility. Arg is one of the following: user, daemon, "	pointer
"auth, authpriv, mail, cron, local0 through local7 "	pointer
"(case-insensitive), or a facility number."	pointer
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
facility	int
,	O
0	int
,	O
cb_syslog_facility	function
}	O
,	O
{	O
"tag"	pointer
,	O
N_	O
(	O
"string"	pointer
)	O
,	O
N_	O
(	O
"Tag syslog messages with this string"	pointer
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
tag	pointer
}	O
,	O
{	O
"print-priority"	pointer
,	O
N_	O
(	O
"arg"	pointer
)	O
,	O
N_	O
(	O
"Prefix each message with its priority"	pointer
)	O
,	O
grecs_type_bool	int
,	O
GRECS_DFLT	int
,	O
&	O
syslog_include_prio	int
}	O
,	O
{	O
NULL	O
}	O
,	O
}	O
;	O
struct	O
eventconf	struct
{	O
struct	O
grecs_list	struct
*	O
pathlist	pointer
;	O
event_mask	struct
ev_mask	struct
;	O
filpatlist_t	pointer
fpat	pointer
;	O
struct	O
prog_handler	struct
prog_handler	struct
;	O
}	O
;	O
static	O
struct	O
eventconf	struct
eventconf	struct
;	O
static	O
void	O
eventconf_init	function
(	O
void	O
)	O
{	O
memset	function
(	O
&	O
eventconf	struct
,	O
0	int
,	O
sizeof	O
eventconf	struct
)	O
;	O
eventconf	struct
.	O
prog_handler	struct
.	O
timeout	int
=	O
DEFAULT_TIMEOUT	int
;	O
}	O
static	O
void	O
eventconf_free	function
(	O
void	O
)	O
{	O
grecs_list_free	function
(	O
eventconf	struct
.	O
pathlist	pointer
)	O
;	O
prog_handler_free	function
(	O
&	O
eventconf	struct
.	O
prog_handler	struct
)	O
;	O
filpatlist_destroy	function
(	O
&	O
eventconf	struct
.	O
fpat	pointer
)	O
;	O
}	O
void	O
eventconf_flush	function
(	O
grecs_locus_t	struct
*	O
loc	pointer
)	O
{	O
struct	O
grecs_list_entry	struct
*	O
ep	pointer
;	O
struct	O
handler	struct
*	O
hp	pointer
=	O
prog_handler_alloc	function
(	O
eventconf	struct
.	O
ev_mask	struct
,	O
eventconf	struct
.	O
fpat	pointer
,	O
&	O
eventconf	struct
.	O
prog_handler	struct
)	O
;	O
for	O
(	O
ep	pointer
=	O
eventconf	struct
.	O
pathlist	pointer
->	O
head	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
{	O
struct	O
pathent	struct
*	O
pe	pointer
=	O
ep	pointer
->	O
data	pointer
;	O
struct	O
watchpoint	struct
*	O
wpt	pointer
;	O
int	O
isnew	int
;	O
wpt	pointer
=	O
watchpoint_install	function
(	O
pe	pointer
->	O
path	array
,	O
&	O
isnew	int
)	O
;	O
if	O
(	O
!	O
wpt	pointer
)	O
abort	function
(	O
)	O
;	O
if	O
(	O
!	O
isnew	int
&&	O
wpt	pointer
->	O
depth	int
!=	O
pe	pointer
->	O
depth	int
)	O
grecs_error	function
(	O
loc	pointer
,	O
0	int
,	O
_	O
(	O
"%s: recursion depth does not match previous definition"	pointer
)	O
,	O
pe	pointer
->	O
path	array
)	O
;	O
wpt	pointer
->	O
depth	int
=	O
pe	pointer
->	O
depth	int
;	O
handler_list_append	function
(	O
wpt	pointer
->	O
handler_list	pointer
,	O
hp	pointer
)	O
;	O
}	O
grecs_list_free	function
(	O
eventconf	struct
.	O
pathlist	pointer
)	O
;	O
eventconf_init	function
(	O
)	O
;	O
}	O
static	O
int	O
cb_watcher	function
(	O
enum	O
grecs_callback_command	enum
cmd	enum
,	O
grecs_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
varptr	pointer
,	O
void	O
*	O
cb_data	pointer
)	O
{	O
int	O
err	long
=	O
0	int
;	O
switch	O
(	O
cmd	enum
)	O
{	O
case	O
grecs_callback_section_begin	int
:	O
eventconf_init	function
(	O
)	O
;	O
break	O
;	O
case	O
grecs_callback_section_end	int
:	O
if	O
(	O
!	O
eventconf	struct
.	O
pathlist	pointer
)	O
{	O
grecs_error	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"no paths configured"	pointer
)	O
)	O
;	O
++	O
err	long
;	O
}	O
if	O
(	O
!	O
eventconf	struct
.	O
prog_handler	struct
.	O
command	pointer
)	O
{	O
grecs_error	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"no command configured"	pointer
)	O
)	O
;	O
++	O
err	long
;	O
}	O
if	O
(	O
evtnullp	function
(	O
&	O
eventconf	struct
.	O
ev_mask	struct
)	O
)	O
evtsetall	function
(	O
&	O
eventconf	struct
.	O
ev_mask	struct
)	O
;	O
if	O
(	O
err	long
==	O
0	int
)	O
eventconf_flush	function
(	O
&	O
node	pointer
->	O
locus	struct
)	O
;	O
else	O
eventconf_free	function
(	O
)	O
;	O
break	O
;	O
case	O
grecs_callback_set_value	int
:	O
grecs_error	function
(	O
&	O
node	pointer
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"invalid use of block statement"	pointer
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
pathent	struct
*	O
pathent_alloc	function
(	O
char	O
*	O
s	pointer
,	O
long	O
depth	int
)	O
{	O
size_t	long
len	long
=	O
strlen	function
(	O
s	pointer
)	O
;	O
struct	O
pathent	struct
*	O
p	pointer
=	O
emalloc	function
(	O
sizeof	O
(	O
*	O
p	pointer
)	O
+	O
len	long
)	O
;	O
p	pointer
->	O
len	long
=	O
len	long
;	O
strcpy	function
(	O
p	pointer
->	O
path	array
,	O
s	pointer
)	O
;	O
p	pointer
->	O
depth	int
=	O
depth	int
;	O
return	O
p	pointer
;	O
}	O
static	O
int	O
cb_path	function
(	O
enum	O
grecs_callback_command	enum
cmd	enum
,	O
grecs_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
varptr	pointer
,	O
void	O
*	O
cb_data	pointer
)	O
{	O
grecs_locus_t	struct
*	O
locus	struct
=	O
&	O
node	pointer
->	O
locus	struct
;	O
grecs_value_t	struct
*	O
val	pointer
=	O
node	pointer
->	O
v	union
.	O
value	pointer
;	O
struct	O
grecs_list	struct
*	O
*	O
lpp	pointer
=	O
varptr	pointer
,	O
*	O
lp	pointer
;	O
struct	O
pathent	struct
*	O
pe	pointer
;	O
char	O
*	O
s	pointer
;	O
long	O
depth	int
=	O
0	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum
,	O
locus	struct
)	O
;	O
switch	O
(	O
val	pointer
->	O
type	enum
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
s	pointer
=	O
val	pointer
->	O
v	union
.	O
string	pointer
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
0	int
]	O
->	O
locus	struct
,	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
0	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
1	int
]	O
->	O
locus	struct
,	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
1	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	function
(	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
1	int
]	O
->	O
v	union
.	O
string	pointer
,	O
"recursive"	pointer
)	O
)	O
{	O
grecs_error	function
(	O
&	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
1	int
]	O
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"expected \"recursive\" or end of statement"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
switch	O
(	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
c	long
)	O
{	O
case	O
2	int
:	O
depth	int
=	O
-	O
1	int
;	O
break	O
;	O
case	O
3	int
:	O
if	O
(	O
grecs_string_convert	function
(	O
&	O
depth	int
,	O
grecs_type_long	int
,	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
2	int
]	O
->	O
v	union
.	O
string	pointer
,	O
&	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
2	int
]	O
->	O
locus	struct
)	O
)	O
return	O
1	int
;	O
break	O
;	O
default	O
:	O
grecs_error	function
(	O
&	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
3	int
]	O
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"surplus argument"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
s	pointer
=	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
0	int
]	O
->	O
v	union
.	O
string	pointer
;	O
break	O
;	O
case	O
GRECS_TYPE_LIST	int
:	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"unexpected list"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
pe	pointer
=	O
pathent_alloc	function
(	O
s	pointer
,	O
depth	int
)	O
;	O
if	O
(	O
*	O
lpp	pointer
)	O
lp	pointer
=	O
*	O
lpp	pointer
;	O
else	O
{	O
lp	pointer
=	O
_grecs_simple_list_create	function
(	O
1	int
)	O
;	O
*	O
lpp	pointer
=	O
lp	pointer
;	O
}	O
grecs_list_append	function
(	O
lp	pointer
,	O
pe	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_eventlist	function
(	O
enum	O
grecs_callback_command	enum
cmd	enum
,	O
grecs_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
varptr	pointer
,	O
void	O
*	O
cb_data	pointer
)	O
{	O
grecs_locus_t	struct
*	O
locus	struct
=	O
&	O
node	pointer
->	O
locus	struct
;	O
grecs_value_t	struct
*	O
val	pointer
=	O
node	pointer
->	O
v	union
.	O
value	pointer
;	O
event_mask	struct
*	O
mask	struct
=	O
varptr	pointer
;	O
event_mask	struct
m	pointer
;	O
struct	O
grecs_list_entry	struct
*	O
ep	pointer
;	O
int	O
i	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum
,	O
locus	struct
)	O
;	O
switch	O
(	O
val	pointer
->	O
type	enum
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
if	O
(	O
getevt	function
(	O
val	pointer
->	O
v	union
.	O
string	pointer
,	O
&	O
m	pointer
)	O
)	O
{	O
grecs_error	function
(	O
&	O
val	pointer
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"unrecognized event code"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mask	struct
->	O
gen_mask	int
|=	O
m	pointer
.	O
gen_mask	int
;	O
mask	struct
->	O
sys_mask	int
|=	O
m	pointer
.	O
sys_mask	int
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
c	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
i	int
]	O
->	O
locus	struct
,	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
i	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
getevt	function
(	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
i	int
]	O
->	O
v	union
.	O
string	pointer
,	O
&	O
m	pointer
)	O
)	O
{	O
grecs_error	function
(	O
&	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
i	int
]	O
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"unrecognized event code"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mask	struct
->	O
gen_mask	int
|=	O
m	pointer
.	O
gen_mask	int
;	O
mask	struct
->	O
sys_mask	int
|=	O
m	pointer
.	O
sys_mask	int
;	O
}	O
break	O
;	O
case	O
GRECS_TYPE_LIST	int
:	O
for	O
(	O
ep	pointer
=	O
val	pointer
->	O
v	union
.	O
list	pointer
->	O
head	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
{	O
grecs_value_t	struct
*	O
vp	pointer
=	O
ep	pointer
->	O
data	pointer
;	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
vp	pointer
->	O
locus	struct
,	O
vp	pointer
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
getevt	function
(	O
vp	pointer
->	O
v	union
.	O
string	pointer
,	O
&	O
m	pointer
)	O
)	O
{	O
grecs_error	function
(	O
&	O
vp	pointer
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"unrecognized event code"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
mask	struct
->	O
gen_mask	int
|=	O
m	pointer
.	O
gen_mask	int
;	O
mask	struct
->	O
sys_mask	int
|=	O
m	pointer
.	O
sys_mask	int
;	O
}	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
membergid	function
(	O
gid_t	int
gid	int
,	O
size_t	long
gc	long
,	O
gid_t	int
*	O
gv	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
gc	long
;	O
i	int
++	O
)	O
if	O
(	O
gv	pointer
[	O
i	int
]	O
==	O
gid	int
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
get_user_groups	function
(	O
char	O
*	O
user	pointer
,	O
gid_t	int
gid	int
,	O
size_t	long
*	O
pgidc	pointer
,	O
gid_t	int
*	O
*	O
pgidv	pointer
)	O
{	O
size_t	long
gidc	long
=	O
0	int
,	O
n	long
=	O
0	int
;	O
gid_t	int
*	O
gidv	pointer
=	O
NULL	O
;	O
struct	O
group	struct
*	O
gr	pointer
;	O
n	long
=	O
32	int
;	O
gidv	pointer
=	O
emalloc	function
(	O
n	long
*	O
sizeof	O
(	O
gidv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
gidv	pointer
[	O
0	int
]	O
=	O
gid	int
;	O
gidc	long
=	O
1	int
;	O
setgrent	function
(	O
)	O
;	O
while	O
(	O
gr	pointer
=	O
getgrent	function
(	O
)	O
)	O
{	O
char	O
*	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
gr	pointer
->	O
gr_mem	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
strcmp	function
(	O
*	O
p	pointer
,	O
user	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
n	long
==	O
gidc	long
)	O
{	O
n	long
+=	O
32	int
;	O
gidv	pointer
=	O
erealloc	function
(	O
gidv	pointer
,	O
n	long
*	O
sizeof	O
(	O
gidv	pointer
[	O
0	int
]	O
)	O
)	O
;	O
}	O
if	O
(	O
!	O
membergid	function
(	O
gr	pointer
->	O
gr_gid	int
,	O
gidc	long
,	O
gidv	pointer
)	O
)	O
gidv	pointer
[	O
gidc	long
++	O
]	O
=	O
gr	pointer
->	O
gr_gid	int
;	O
}	O
}	O
endgrent	function
(	O
)	O
;	O
*	O
pgidc	pointer
=	O
gidc	long
;	O
*	O
pgidv	pointer
=	O
gidv	pointer
;	O
}	O
static	O
int	O
cb_user	function
(	O
enum	O
grecs_callback_command	enum
cmd	enum
,	O
grecs_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
varptr	pointer
,	O
void	O
*	O
cb_data	pointer
)	O
{	O
grecs_locus_t	struct
*	O
locus	struct
=	O
&	O
node	pointer
->	O
locus	struct
;	O
grecs_value_t	struct
*	O
val	pointer
=	O
node	pointer
->	O
v	union
.	O
value	pointer
;	O
struct	O
passwd	struct
*	O
pw	pointer
;	O
struct	O
group	struct
*	O
gr	pointer
;	O
grecs_value_t	struct
*	O
uv	pointer
,	O
*	O
gv	pointer
=	O
NULL	O
;	O
gid_t	int
gid	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum
,	O
locus	struct
)	O
;	O
switch	O
(	O
val	pointer
->	O
type	enum
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
uv	pointer
=	O
val	pointer
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
0	int
]	O
->	O
locus	struct
,	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
0	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
1	int
]	O
->	O
locus	struct
,	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
1	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
c	long
>	O
2	int
)	O
{	O
grecs_locus_t	struct
loc	pointer
;	O
loc	pointer
.	O
beg	struct
=	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
2	int
]	O
->	O
locus	struct
.	O
beg	struct
;	O
loc	pointer
.	O
end	struct
=	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
c	long
-	O
1	int
]	O
->	O
locus	struct
.	O
end	struct
;	O
grecs_error	function
(	O
&	O
loc	pointer
,	O
0	int
,	O
_	O
(	O
"surplus arguments"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
uv	pointer
=	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
0	int
]	O
;	O
gv	pointer
=	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
1	int
]	O
;	O
break	O
;	O
case	O
GRECS_TYPE_LIST	int
:	O
grecs_error	function
(	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"unexpected list"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
pw	pointer
=	O
getpwnam	function
(	O
uv	pointer
->	O
v	union
.	O
string	pointer
)	O
;	O
if	O
(	O
!	O
pw	pointer
)	O
{	O
grecs_error	function
(	O
&	O
uv	pointer
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"no such user"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
gv	pointer
)	O
{	O
gr	pointer
=	O
getgrnam	function
(	O
gv	pointer
->	O
v	union
.	O
string	pointer
)	O
;	O
if	O
(	O
!	O
gr	pointer
)	O
{	O
grecs_error	function
(	O
&	O
gv	pointer
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"no such group"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
gid	int
=	O
gr	pointer
->	O
gr_gid	int
;	O
}	O
else	O
gid	int
=	O
pw	pointer
->	O
pw_gid	int
;	O
eventconf	struct
.	O
prog_handler	struct
.	O
uid	int
=	O
pw	pointer
->	O
pw_uid	int
;	O
get_user_groups	function
(	O
uv	pointer
->	O
v	union
.	O
string	pointer
,	O
gid	int
,	O
&	O
eventconf	struct
.	O
prog_handler	struct
.	O
gidc	long
,	O
&	O
eventconf	struct
.	O
prog_handler	struct
.	O
gidv	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_option	function
(	O
enum	O
grecs_callback_command	enum
cmd	enum
,	O
grecs_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
varptr	pointer
,	O
void	O
*	O
cb_data	pointer
)	O
{	O
grecs_locus_t	struct
*	O
locus	struct
=	O
&	O
node	pointer
->	O
locus	struct
;	O
grecs_value_t	struct
*	O
val	pointer
=	O
node	pointer
->	O
v	union
.	O
value	pointer
;	O
struct	O
grecs_list_entry	struct
*	O
ep	pointer
;	O
ASSERT_SCALAR	O
(	O
cmd	enum
,	O
locus	struct
)	O
;	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
val	pointer
->	O
locus	struct
,	O
val	pointer
,	O
GRECS_TYPE_LIST	int
)	O
)	O
return	O
1	int
;	O
for	O
(	O
ep	pointer
=	O
val	pointer
->	O
v	union
.	O
list	pointer
->	O
head	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
{	O
grecs_value_t	struct
*	O
vp	pointer
=	O
ep	pointer
->	O
data	pointer
;	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
vp	pointer
->	O
locus	struct
,	O
vp	pointer
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	function
(	O
vp	pointer
->	O
v	union
.	O
string	pointer
,	O
"nowait"	pointer
)	O
==	O
0	int
)	O
eventconf	struct
.	O
prog_handler	struct
.	O
flags	int
|=	O
HF_NOWAIT	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
vp	pointer
->	O
v	union
.	O
string	pointer
,	O
"wait"	pointer
)	O
==	O
0	int
)	O
eventconf	struct
.	O
prog_handler	struct
.	O
flags	int
&=	O
~	O
HF_NOWAIT	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
vp	pointer
->	O
v	union
.	O
string	pointer
,	O
"stdout"	pointer
)	O
==	O
0	int
)	O
eventconf	struct
.	O
prog_handler	struct
.	O
flags	int
|=	O
HF_STDOUT	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
vp	pointer
->	O
v	union
.	O
string	pointer
,	O
"stderr"	pointer
)	O
==	O
0	int
)	O
eventconf	struct
.	O
prog_handler	struct
.	O
flags	int
|=	O
HF_STDERR	int
;	O
else	O
if	O
(	O
strcmp	function
(	O
vp	pointer
->	O
v	union
.	O
string	pointer
,	O
"shell"	pointer
)	O
==	O
0	int
)	O
eventconf	struct
.	O
prog_handler	struct
.	O
flags	int
|=	O
HF_SHELL	int
;	O
else	O
grecs_error	function
(	O
&	O
vp	pointer
->	O
locus	struct
,	O
0	int
,	O
_	O
(	O
"unrecognized option"	pointer
)	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
cb_environ	function
(	O
enum	O
grecs_callback_command	enum
cmd	enum
,	O
grecs_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
varptr	pointer
,	O
void	O
*	O
cb_data	pointer
)	O
{	O
grecs_locus_t	struct
*	O
locus	struct
=	O
&	O
node	pointer
->	O
locus	struct
;	O
grecs_value_t	struct
*	O
val	pointer
=	O
node	pointer
->	O
v	union
.	O
value	pointer
;	O
struct	O
grecs_list_entry	struct
*	O
ep	pointer
;	O
int	O
i	int
,	O
j	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum
,	O
locus	struct
)	O
;	O
switch	O
(	O
val	pointer
->	O
type	enum
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
val	pointer
->	O
locus	struct
,	O
val	pointer
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
i	int
=	O
prog_handler_envrealloc	function
(	O
&	O
eventconf	struct
.	O
prog_handler	struct
,	O
1	int
)	O
;	O
eventconf	struct
.	O
prog_handler	struct
.	O
env	pointer
[	O
i	int
]	O
=	O
estrdup	function
(	O
val	pointer
->	O
v	union
.	O
string	pointer
)	O
;	O
eventconf	struct
.	O
prog_handler	struct
.	O
env	pointer
[	O
i	int
+	O
1	int
]	O
=	O
NULL	O
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
j	int
=	O
prog_handler_envrealloc	function
(	O
&	O
eventconf	struct
.	O
prog_handler	struct
,	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
c	long
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
c	long
;	O
i	int
++	O
,	O
j	int
++	O
)	O
{	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
i	int
]	O
->	O
locus	struct
,	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
i	int
]	O
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
eventconf	struct
.	O
prog_handler	struct
.	O
env	pointer
[	O
j	int
]	O
=	O
estrdup	function
(	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
i	int
]	O
->	O
v	union
.	O
string	pointer
)	O
;	O
}	O
eventconf	struct
.	O
prog_handler	struct
.	O
env	pointer
[	O
j	int
]	O
=	O
NULL	O
;	O
break	O
;	O
case	O
GRECS_TYPE_LIST	int
:	O
j	int
=	O
prog_handler_envrealloc	function
(	O
&	O
eventconf	struct
.	O
prog_handler	struct
,	O
val	pointer
->	O
v	union
.	O
list	pointer
->	O
count	long
)	O
;	O
for	O
(	O
ep	pointer
=	O
val	pointer
->	O
v	union
.	O
list	pointer
->	O
head	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
,	O
j	int
++	O
)	O
{	O
grecs_value_t	struct
*	O
vp	pointer
=	O
ep	pointer
->	O
data	pointer
;	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
vp	pointer
->	O
locus	struct
,	O
vp	pointer
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
eventconf	struct
.	O
prog_handler	struct
.	O
env	pointer
[	O
j	int
]	O
=	O
estrdup	function
(	O
vp	pointer
->	O
v	union
.	O
string	pointer
)	O
;	O
}	O
eventconf	struct
.	O
prog_handler	struct
.	O
env	pointer
[	O
j	int
]	O
=	O
NULL	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
file_name_pattern	function
(	O
filpatlist_t	pointer
*	O
fptr	pointer
,	O
grecs_value_t	struct
*	O
val	pointer
)	O
{	O
if	O
(	O
assert_grecs_value_type	function
(	O
&	O
val	pointer
->	O
locus	struct
,	O
val	pointer
,	O
GRECS_TYPE_STRING	int
)	O
)	O
return	O
1	int
;	O
return	O
filpatlist_add	function
(	O
fptr	pointer
,	O
val	pointer
->	O
v	union
.	O
string	pointer
,	O
&	O
val	pointer
->	O
locus	struct
)	O
;	O
}	O
static	O
int	O
cb_file_pattern	function
(	O
enum	O
grecs_callback_command	enum
cmd	enum
,	O
grecs_node_t	struct
*	O
node	pointer
,	O
void	O
*	O
varptr	pointer
,	O
void	O
*	O
cb_data	pointer
)	O
{	O
grecs_value_t	struct
*	O
val	pointer
=	O
node	pointer
->	O
v	union
.	O
value	pointer
;	O
filpatlist_t	pointer
*	O
fpat	pointer
=	O
varptr	pointer
;	O
struct	O
grecs_list_entry	struct
*	O
ep	pointer
;	O
int	O
i	int
;	O
ASSERT_SCALAR	O
(	O
cmd	enum
,	O
&	O
node	pointer
->	O
locus	struct
)	O
;	O
switch	O
(	O
val	pointer
->	O
type	enum
)	O
{	O
case	O
GRECS_TYPE_STRING	int
:	O
file_name_pattern	function
(	O
fpat	pointer
,	O
val	pointer
)	O
;	O
break	O
;	O
case	O
GRECS_TYPE_ARRAY	int
:	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
c	long
;	O
i	int
++	O
)	O
if	O
(	O
file_name_pattern	function
(	O
fpat	pointer
,	O
val	pointer
->	O
v	union
.	O
arg	pointer
.	O
v	union
[	O
i	int
]	O
)	O
)	O
break	O
;	O
break	O
;	O
case	O
GRECS_TYPE_LIST	int
:	O
for	O
(	O
ep	pointer
=	O
val	pointer
->	O
v	union
.	O
list	pointer
->	O
head	pointer
;	O
ep	pointer
;	O
ep	pointer
=	O
ep	pointer
->	O
next	pointer
)	O
if	O
(	O
file_name_pattern	function
(	O
fpat	pointer
,	O
(	O
grecs_value_t	struct
*	O
)	O
ep	pointer
->	O
data	pointer
)	O
)	O
break	O
;	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
struct	O
grecs_keyword	struct
watcher_kw	array
[	O
]	O
=	O
{	O
{	O
"path"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"Pathname to watch"	pointer
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
eventconf	struct
.	O
pathlist	pointer
,	O
0	int
,	O
cb_path	function
}	O
,	O
{	O
"event"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"Events to watch for"	pointer
)	O
,	O
grecs_type_string	int
,	O
GRECS_LIST	int
,	O
&	O
eventconf	struct
.	O
ev_mask	struct
,	O
0	int
,	O
cb_eventlist	function
}	O
,	O
{	O
"file"	pointer
,	O
N_	O
(	O
"regexp"	pointer
)	O
,	O
N_	O
(	O
"Files to watch for"	pointer
)	O
,	O
grecs_type_string	int
,	O
GRECS_LIST	int
,	O
&	O
eventconf	struct
.	O
fpat	pointer
,	O
0	int
,	O
cb_file_pattern	function
}	O
,	O
{	O
"command"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"Command to execute on event"	pointer
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
eventconf	struct
.	O
prog_handler	struct
.	O
command	pointer
}	O
,	O
{	O
"user"	pointer
,	O
N_	O
(	O
"name"	pointer
)	O
,	O
N_	O
(	O
"Run command as this user"	pointer
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
NULL	O
,	O
0	int
,	O
cb_user	function
}	O
,	O
{	O
"timeout"	pointer
,	O
N_	O
(	O
"seconds"	pointer
)	O
,	O
N_	O
(	O
"Timeout for the command"	pointer
)	O
,	O
grecs_type_uint	int
,	O
GRECS_DFLT	int
,	O
&	O
eventconf	struct
.	O
prog_handler	struct
.	O
timeout	int
}	O
,	O
{	O
"option"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"List of additional options"	pointer
)	O
,	O
grecs_type_string	int
,	O
GRECS_LIST	int
,	O
NULL	O
,	O
0	int
,	O
cb_option	function
}	O
,	O
{	O
"environ"	pointer
,	O
N_	O
(	O
"<arg: string> <arg: string>..."	pointer
)	O
,	O
N_	O
(	O
"Modify environment"	pointer
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
NULL	O
,	O
0	int
,	O
cb_environ	function
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
static	O
struct	O
grecs_keyword	struct
direvent_kw	array
[	O
]	O
=	O
{	O
{	O
"user"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"Run as this user"	pointer
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
user	pointer
}	O
,	O
{	O
"foreground"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"Run in foreground"	pointer
)	O
,	O
grecs_type_bool	int
,	O
GRECS_DFLT	int
,	O
&	O
foreground	int
}	O
,	O
{	O
"pidfile"	pointer
,	O
N_	O
(	O
"file"	pointer
)	O
,	O
N_	O
(	O
"Set pid file name"	pointer
)	O
,	O
grecs_type_string	int
,	O
GRECS_DFLT	int
,	O
&	O
pidfile	pointer
}	O
,	O
{	O
"syslog"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"Configure syslog logging"	pointer
)	O
,	O
grecs_type_section	int
,	O
GRECS_DFLT	int
,	O
NULL	O
,	O
0	int
,	O
NULL	O
,	O
NULL	O
,	O
syslog_kw	array
}	O
,	O
{	O
"debug"	pointer
,	O
N_	O
(	O
"level"	pointer
)	O
,	O
N_	O
(	O
"Set debug level"	pointer
)	O
,	O
grecs_type_int	int
,	O
GRECS_DFLT	int
,	O
&	O
debug_level	int
}	O
,	O
{	O
"watcher"	pointer
,	O
NULL	O
,	O
N_	O
(	O
"Configure event watcher"	pointer
)	O
,	O
grecs_type_section	int
,	O
GRECS_DFLT	int
,	O
NULL	O
,	O
0	int
,	O
cb_watcher	function
,	O
NULL	O
,	O
watcher_kw	array
}	O
,	O
{	O
NULL	O
}	O
}	O
;	O
void	O
config_help	function
(	O
)	O
{	O
static	O
char	O
docstring	pointer
[	O
]	O
=	O
N_	O
(	O
"Configuration file structure for direvent.\n"	pointer
"For more information, use `info direvent configuration'."	pointer
)	O
;	O
grecs_print_docstring	function
(	O
docstring	pointer
,	O
0	int
,	O
stdout	pointer
)	O
;	O
grecs_print_statement_array	function
(	O
direvent_kw	array
,	O
1	int
,	O
0	int
,	O
stdout	pointer
)	O
;	O
}	O
void	O
config_init	function
(	O
void	O
)	O
{	O
grecs_include_path_setup	function
(	O
INCLUDE_PATH_ARGS	O
,	O
NULL	O
)	O
;	O
}	O
void	O
config_parse	function
(	O
char	O
const	O
*	O
conffile	pointer
)	O
{	O
struct	O
grecs_node	struct
*	O
tree	pointer
;	O
grecs_parser_options	int
=	O
GRECS_OPTION_QUOTED_STRING_CONCAT	int
;	O
tree	pointer
=	O
grecs_parse	function
(	O
conffile	pointer
)	O
;	O
if	O
(	O
!	O
tree	pointer
)	O
exit	function
(	O
1	int
)	O
;	O
if	O
(	O
grecs_tree_process	function
(	O
tree	pointer
,	O
direvent_kw	array
)	O
)	O
exit	function
(	O
1	int
)	O
;	O
}	O
