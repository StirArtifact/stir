char	O
*	O
getuser	function
PROTO	O
(	O
(	O
uid_t	int
uid	int
)	O
)	O
;	O
char	O
*	O
getgroup	function
PROTO	O
(	O
(	O
gid_t	int
gid	int
)	O
)	O
;	O
extern	O
int	O
AnsiColors	int
;	O
extern	O
int	O
TypeSensitivity	int
;	O
char	O
rights	array
[	O
16	int
]	O
=	O
"-rwxrwxrwx"	pointer
;	O
char	O
*	O
FileDisplayMode	array
[	O
FILE_DISPLAY_MODES	int
]	O
=	O
{	O
"OwnerGroup"	pointer
,	O
"DateTime"	pointer
,	O
"Size"	pointer
,	O
"AbbrevSize"	pointer
,	O
"Mode"	pointer
,	O
"FullName"	pointer
,	O
"All"	pointer
,	O
}	O
;	O
char	O
*	O
FileSortMethod	array
[	O
FILE_SORT_METHODS	int
]	O
=	O
{	O
"Name"	pointer
,	O
"Extension"	pointer
,	O
"Size"	pointer
,	O
"Date"	pointer
,	O
"Mode"	pointer
,	O
"OwnerId"	pointer
,	O
"GroupId"	pointer
,	O
"OwnerName"	pointer
,	O
"GroupName"	pointer
,	O
}	O
;	O
static	O
char	O
*	O
PanelFields	array
[	O
PANEL_FIELDS	int
]	O
=	O
{	O
"PanelFrame"	pointer
,	O
"PanelBackground"	pointer
,	O
"PanelThumbForeground"	pointer
,	O
"PanelThumbBackground"	pointer
,	O
"PanelThumbBrightness"	pointer
,	O
"PanelSelectedFile"	pointer
,	O
"PanelSelectedFileBrightness"	pointer
,	O
"PanelNotSelectedFile"	pointer
,	O
"PanelNotSelectedFileBrightness"	pointer
,	O
"PanelCurrentSelectedFile"	pointer
,	O
"PanelCurrentNotSelectedFile"	pointer
,	O
"PanelCurrentFile"	pointer
,	O
"PanelPath"	pointer
,	O
"PanelPathBrightness"	pointer
,	O
"PanelDeviceFreeSpace"	pointer
,	O
"PanelDeviceFreeSpaceBrightness"	pointer
,	O
"PanelFileInfo"	pointer
,	O
"PanelFileInfoBrightness"	pointer
,	O
"PanelFilesInfo"	pointer
,	O
"PanelFilesInfoBrightness"	pointer
,	O
}	O
;	O
static	O
int	O
PanelColors	array
[	O
PANEL_FIELDS	int
]	O
=	O
{	O
WHITE	int
,	O
BLUE	int
,	O
BLACK	int
,	O
WHITE	int
,	O
OFF	int
,	O
YELLOW	int
,	O
ON	int
,	O
WHITE	int
,	O
ON	int
,	O
YELLOW	int
,	O
WHITE	int
,	O
CYAN	int
,	O
RED	int
,	O
OFF	int
,	O
RED	int
,	O
OFF	int
,	O
RED	int
,	O
OFF	int
,	O
BLACK	int
,	O
OFF	int
,	O
}	O
;	O
char	O
*	O
panel_il_message	array
[	O
]	O
=	O
{	O
"Wait, reading directory..."	pointer
,	O
"Wait, copying file..."	pointer
,	O
"Wait, copying file(s)..."	pointer
,	O
"Wait, copying directory..."	pointer
,	O
"Wait, deleting directory..."	pointer
,	O
"Wait, deleting file(s)..."	pointer
,	O
"Wait, moving file..."	pointer
,	O
"Wait, moving file(s)..."	pointer
,	O
"Wait, moving directory..."	pointer
,	O
"Wait, comparing directories..."	pointer
,	O
"Wait, comparing files..."	pointer
,	O
"Wait, renaming file(s)..."	pointer
,	O
}	O
;	O
static	O
int	O
StartupFileDisplayMode	int
;	O
static	O
int	O
StartupFileSortMethod	int
;	O
static	O
int	O
StartupScrollStep	int
;	O
static	O
int	O
CurrentSortMethod	int
;	O
static	O
int	O
LeadingDotMatch	int
=	O
OFF	int
;	O
static	O
int	O
InfoDisplay	int
=	O
OFF	int
;	O
static	O
int	O
GroupDigits	int
=	O
ON	int
;	O
static	O
int	O
MaxUnscaledDigits	int
=	O
9	int
;	O
static	O
char	O
nice_try	array
[	O
]	O
=	O
"Nice try, maybe later... :-)"	pointer
;	O
extern	O
void	O
fatal	function
PROTO	O
(	O
(	O
char	O
*	O
)	O
)	O
;	O
extern	O
void	O
panel_update_entry	function
PROTO	O
(	O
(	O
panel_t	struct
*	O
,	O
int	O
)	O
)	O
;	O
extern	O
char	O
il_read_char	function
PROTO	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
,	O
int	O
)	O
)	O
;	O
extern	O
char	O
*	O
il_read_line	function
PROTO	O
(	O
(	O
char	O
*	O
,	O
char	O
*	O
*	O
,	O
char	O
*	O
,	O
xstack_t	struct
*	O
)	O
)	O
;	O
static	O
xstack_t	struct
*	O
copy_history	pointer
;	O
static	O
xstack_t	struct
*	O
move_history	pointer
;	O
static	O
xstack_t	struct
*	O
mkdir_history	pointer
;	O
static	O
void	O
xchg	function
(	O
a	pointer
,	O
b	pointer
)	O
int	O
*	O
a	pointer
,	O
*	O
b	pointer
;	O
{	O
int	O
tmp	int
=	O
*	O
a	pointer
;	O
*	O
a	pointer
=	O
*	O
b	pointer
;	O
*	O
b	pointer
=	O
tmp	int
;	O
}	O
panel_t	struct
*	O
panel_init	function
(	O
path	pointer
)	O
char	O
*	O
path	pointer
;	O
{	O
static	O
int	O
configured	int
;	O
panel_t	struct
*	O
this	pointer
=	O
(	O
panel_t	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
panel_t	struct
)	O
)	O
;	O
this	pointer
->	O
x	int
=	O
0	int
;	O
this	pointer
->	O
y	int
=	O
0	int
;	O
this	pointer
->	O
lines	int
=	O
1	int
;	O
this	pointer
->	O
columns	int
=	O
1	int
;	O
this	pointer
->	O
focus	char
=	O
OFF	int
;	O
this	pointer
->	O
entries	int
=	O
0	int
;	O
this	pointer
->	O
selected_entries	int
=	O
0	int
;	O
this	pointer
->	O
last_index	int
=	O
-	O
1	int
;	O
this	pointer
->	O
display_mode	int
=	O
this	pointer
->	O
sort_method	int
=	O
0	int
;	O
this	pointer
->	O
current_entry	int
=	O
0	int
;	O
this	pointer
->	O
first_on_screen	int
=	O
0	int
;	O
this	pointer
->	O
on_screen	int
=	O
INT_MAX	O
/	O
2	int
;	O
this	pointer
->	O
temp	pointer
=	O
NULL	O
;	O
this	pointer
->	O
dir	pointer
=	O
NULL	O
;	O
this	pointer
->	O
isearch_stack	pointer
=	O
NULL	O
;	O
this	pointer
->	O
visible	char
=	O
1	int
;	O
this	pointer
->	O
scroll_step	int
=	O
1	int
;	O
this	pointer
->	O
thumb	int
=	O
0	int
;	O
this	pointer
->	O
horizontal_offset	int
=	O
0	int
;	O
this	pointer
->	O
msdosfs	int
=	O
0	int
;	O
this	pointer
->	O
dir_entry	pointer
=	O
NULL	O
;	O
if	O
(	O
chdir	function
(	O
path	pointer
)	O
==	O
-	O
1	int
)	O
fatal	function
(	O
"`chdir' failed: permission denied"	pointer
)	O
;	O
this	pointer
->	O
path	pointer
=	O
xgetcwd	function
(	O
)	O
;	O
if	O
(	O
this	pointer
->	O
path	pointer
==	O
NULL	O
)	O
fatal	function
(	O
"`getcwd' failed: permission denied"	pointer
)	O
;	O
minimize_path	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
this	pointer
->	O
pathlen	long
=	O
strlen	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
this	pointer
->	O
window	pointer
=	O
window_init	function
(	O
)	O
;	O
if	O
(	O
configured	int
)	O
{	O
this	pointer
->	O
display_mode	int
=	O
StartupFileDisplayMode	int
;	O
this	pointer
->	O
sort_method	int
=	O
StartupFileSortMethod	int
;	O
return	O
this	pointer
;	O
}	O
use_section	function
(	O
"[Setup]"	pointer
)	O
;	O
StartupScrollStep	int
=	O
get_int_var	function
(	O
"StartupScrollStep"	pointer
,	O
0	int
)	O
;	O
use_section	function
(	O
"[GITFM-Setup]"	pointer
)	O
;	O
StartupFileDisplayMode	int
=	O
get_const_var	function
(	O
"StartupFileDisplayMode"	pointer
,	O
FileDisplayMode	array
,	O
FILE_DISPLAY_MODES	int
,	O
0	int
)	O
;	O
this	pointer
->	O
display_mode	int
=	O
StartupFileDisplayMode	int
;	O
StartupFileSortMethod	int
=	O
get_const_var	function
(	O
"StartupFileSortMethod"	pointer
,	O
FileSortMethod	array
,	O
FILE_SORT_METHODS	int
,	O
0	int
)	O
;	O
this	pointer
->	O
sort_method	int
=	O
StartupFileSortMethod	int
;	O
MaxUnscaledDigits	int
=	O
get_int_var	function
(	O
"MaxUnscaledDigits"	pointer
,	O
9	int
)	O
;	O
InfoDisplay	int
=	O
get_flag_var	function
(	O
"InfoDisplay"	pointer
,	O
ON	int
)	O
;	O
LeadingDotMatch	int
=	O
get_flag_var	function
(	O
"LeadingDotMatch"	pointer
,	O
ON	int
)	O
;	O
GroupDigits	int
=	O
get_flag_var	function
(	O
"GroupDigits"	pointer
,	O
ON	int
)	O
;	O
use_section	function
(	O
AnsiColors	int
?	O
color_section	array
:	O
monochrome_section	array
)	O
;	O
get_colorset_var	function
(	O
PanelColors	array
,	O
PanelFields	array
,	O
PANEL_FIELDS	int
)	O
;	O
copy_history	pointer
=	O
xstack_init	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
move_history	pointer
=	O
xstack_init	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
mkdir_history	pointer
=	O
xstack_init	function
(	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
configured	int
=	O
1	int
;	O
return	O
this	pointer
;	O
}	O
void	O
panel_end	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
int	O
i	int
;	O
if	O
(	O
this	pointer
->	O
dir	pointer
)	O
closedir	function
(	O
this	pointer
->	O
dir	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
this	pointer
->	O
entries	int
;	O
i	int
++	O
)	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
name	pointer
)	O
{	O
xfree	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
name	pointer
)	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
name	pointer
=	O
NULL	O
;	O
}	O
xfree	function
(	O
this	pointer
->	O
dir_entry	pointer
)	O
;	O
xfree	function
(	O
this	pointer
->	O
temp	pointer
)	O
;	O
window_end	function
(	O
this	pointer
->	O
window	pointer
)	O
;	O
xfree	function
(	O
this	pointer
)	O
;	O
}	O
window_t	struct
*	O
panel_window	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
return	O
this	pointer
->	O
window	pointer
;	O
}	O
static	O
char	O
*	O
cutname	function
(	O
name	pointer
,	O
which	int
,	O
filled	int
)	O
char	O
*	O
name	pointer
;	O
int	O
which	int
,	O
filled	int
;	O
{	O
static	O
char	O
tname	array
[	O
2	int
]	O
[	O
16	int
]	O
;	O
if	O
(	O
filled	int
)	O
{	O
memset	function
(	O
tname	array
[	O
which	int
]	O
,	O
' '	O
,	O
14	int
)	O
;	O
tname	array
[	O
which	int
]	O
[	O
14	int
]	O
=	O
0	int
;	O
return	O
memcpy	function
(	O
tname	array
[	O
which	int
]	O
,	O
name	pointer
,	O
min	O
(	O
strlen	function
(	O
name	pointer
)	O
,	O
14	int
)	O
)	O
;	O
}	O
else	O
return	O
strncpy	function
(	O
tname	array
[	O
which	int
]	O
,	O
name	pointer
,	O
14	int
)	O
;	O
}	O
static	O
int	O
sort_compare_fn	function
(	O
_first	pointer
,	O
_second	pointer
)	O
const	O
void	O
*	O
_first	pointer
;	O
const	O
void	O
*	O
_second	pointer
;	O
{	O
int	O
retval	int
;	O
char	O
*	O
pfirst	pointer
,	O
*	O
psecond	pointer
;	O
const	O
dir_entry_t	struct
*	O
first	pointer
=	O
(	O
const	O
dir_entry_t	struct
*	O
)	O
_first	pointer
;	O
const	O
dir_entry_t	struct
*	O
second	pointer
=	O
(	O
const	O
dir_entry_t	struct
*	O
)	O
_second	pointer
;	O
int	O
first_is_dir	int
=	O
first	pointer
->	O
type	enum
==	O
DIR_ENTRY	int
;	O
int	O
second_is_dir	int
=	O
second	pointer
->	O
type	enum
==	O
DIR_ENTRY	int
;	O
if	O
(	O
first_is_dir	int
!=	O
second_is_dir	int
)	O
return	O
first_is_dir	int
?	O
-	O
1	int
:	O
1	int
;	O
switch	O
(	O
CurrentSortMethod	int
)	O
{	O
case	O
SORT_BY_NAME	int
:	O
break	O
;	O
case	O
SORT_BY_EXTENSION	int
:	O
pfirst	pointer
=	O
strrchr	function
(	O
first	pointer
->	O
name	pointer
,	O
'.'	O
)	O
;	O
psecond	pointer
=	O
strrchr	function
(	O
second	pointer
->	O
name	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
pfirst	pointer
&&	O
psecond	pointer
)	O
{	O
retval	int
=	O
strcmp	function
(	O
++	O
pfirst	pointer
,	O
++	O
psecond	pointer
)	O
;	O
if	O
(	O
retval	int
!=	O
0	int
)	O
return	O
retval	int
;	O
}	O
else	O
if	O
(	O
pfirst	pointer
||	O
psecond	pointer
)	O
return	O
(	O
pfirst	pointer
?	O
-	O
1	int
:	O
1	int
)	O
;	O
break	O
;	O
case	O
SORT_BY_SIZE	int
:	O
if	O
(	O
first	pointer
->	O
size	long
==	O
second	pointer
->	O
size	long
)	O
break	O
;	O
return	O
(	O
(	O
first	pointer
->	O
size	long
>	O
second	pointer
->	O
size	long
)	O
?	O
1	int
:	O
-	O
1	int
)	O
;	O
case	O
SORT_BY_DATE	int
:	O
if	O
(	O
first	pointer
->	O
mtime	long
==	O
second	pointer
->	O
mtime	long
)	O
break	O
;	O
return	O
first	pointer
->	O
mtime	long
-	O
second	pointer
->	O
mtime	long
;	O
case	O
SORT_BY_MODE	int
:	O
if	O
(	O
first	pointer
->	O
mode	int
==	O
second	pointer
->	O
mode	int
)	O
break	O
;	O
return	O
first	pointer
->	O
mode	int
-	O
second	pointer
->	O
mode	int
;	O
case	O
SORT_BY_OWNER_ID	int
:	O
if	O
(	O
first	pointer
->	O
uid	int
==	O
second	pointer
->	O
uid	int
)	O
break	O
;	O
return	O
first	pointer
->	O
uid	int
-	O
second	pointer
->	O
uid	int
;	O
case	O
SORT_BY_GROUP_ID	int
:	O
if	O
(	O
first	pointer
->	O
gid	int
==	O
second	pointer
->	O
gid	int
)	O
break	O
;	O
return	O
first	pointer
->	O
gid	int
-	O
second	pointer
->	O
gid	int
;	O
case	O
SORT_BY_OWNER_NAME	int
:	O
if	O
(	O
first	pointer
->	O
uid	int
==	O
second	pointer
->	O
uid	int
)	O
break	O
;	O
return	O
strcmp	function
(	O
first	pointer
->	O
owner	pointer
,	O
second	pointer
->	O
owner	pointer
)	O
;	O
case	O
SORT_BY_GROUP_NAME	int
:	O
if	O
(	O
first	pointer
->	O
gid	int
==	O
second	pointer
->	O
gid	int
)	O
break	O
;	O
return	O
strcmp	function
(	O
first	pointer
->	O
group	pointer
,	O
second	pointer
->	O
group	pointer
)	O
;	O
default	O
:	O
fatal	function
(	O
"bad sort method"	pointer
)	O
;	O
}	O
return	O
strcmp	function
(	O
first	pointer
->	O
name	pointer
,	O
second	pointer
->	O
name	pointer
)	O
;	O
}	O
void	O
panel_no_optimizations	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
this	pointer
->	O
on_screen	int
=	O
INT_MAX	O
/	O
2	int
;	O
}	O
char	O
*	O
panel_get_current_file_name	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
return	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
;	O
}	O
uid_t	int
panel_get_current_file_uid	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
return	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
uid	int
;	O
}	O
gid_t	int
panel_get_current_file_gid	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
return	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
gid	int
;	O
}	O
mode_t	int
panel_get_current_file_mode	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
return	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
mode	int
;	O
}	O
int	O
panel_get_current_file_type	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
return	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
type	enum
;	O
}	O
static	O
int	O
panel_get_centered_fos	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
int	O
lines	int
=	O
(	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
;	O
int	O
tmp	int
=	O
this	pointer
->	O
current_entry	int
-	O
(	O
lines	int
/	O
2	int
)	O
;	O
if	O
(	O
tmp	int
+	O
lines	int
>=	O
this	pointer
->	O
entries	int
)	O
return	O
max	O
(	O
0	int
,	O
this	pointer
->	O
entries	int
-	O
lines	int
)	O
;	O
else	O
return	O
max	O
(	O
0	int
,	O
tmp	int
)	O
;	O
}	O
static	O
int	O
panel_get_fos	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
assert	O
(	O
this	pointer
->	O
first_on_screen	int
>=	O
0	int
)	O
;	O
if	O
(	O
(	O
this	pointer
->	O
first_on_screen	int
<=	O
this	pointer
->	O
current_entry	int
)	O
&&	O
(	O
this	pointer
->	O
first_on_screen	int
+	O
this	pointer
->	O
lines	int
-	O
2	int
>	O
this	pointer
->	O
current_entry	int
)	O
&&	O
(	O
this	pointer
->	O
first_on_screen	int
+	O
this	pointer
->	O
lines	int
-	O
2	int
<=	O
this	pointer
->	O
entries	int
)	O
)	O
return	O
this	pointer
->	O
first_on_screen	int
;	O
return	O
panel_get_centered_fos	function
(	O
this	pointer
)	O
;	O
}	O
static	O
void	O
panel_set_current_entry	function
(	O
this	pointer
,	O
entry	int
)	O
panel_t	struct
*	O
this	pointer
;	O
int	O
entry	int
;	O
{	O
assert	O
(	O
entry	int
>=	O
0	int
)	O
;	O
assert	O
(	O
entry	int
<	O
this	pointer
->	O
entries	int
)	O
;	O
this	pointer
->	O
current_entry	int
=	O
entry	int
;	O
this	pointer
->	O
first_on_screen	int
=	O
panel_get_fos	function
(	O
this	pointer
)	O
;	O
}	O
void	O
panel_center_current_entry	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
this	pointer
->	O
first_on_screen	int
=	O
panel_get_centered_fos	function
(	O
this	pointer
)	O
;	O
}	O
void	O
panel_activate	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
this	pointer
->	O
visible	char
=	O
1	int
;	O
}	O
void	O
panel_deactivate	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
this	pointer
->	O
visible	char
=	O
0	int
;	O
}	O
void	O
panel_resize	function
(	O
this	pointer
,	O
x	int
,	O
y	int
,	O
lines	int
,	O
columns	int
)	O
panel_t	struct
*	O
this	pointer
;	O
size_t	long
x	int
,	O
y	int
,	O
lines	int
,	O
columns	int
;	O
{	O
this	pointer
->	O
x	int
=	O
x	int
;	O
this	pointer
->	O
y	int
=	O
y	int
;	O
this	pointer
->	O
lines	int
=	O
lines	int
;	O
this	pointer
->	O
columns	int
=	O
columns	int
;	O
this	pointer
->	O
thumb	int
=	O
0	int
;	O
if	O
(	O
StartupScrollStep	int
<=	O
0	int
||	O
StartupScrollStep	int
>=	O
(	O
this	pointer
->	O
lines	int
-	O
1	int
)	O
)	O
this	pointer
->	O
scroll_step	int
=	O
this	pointer
->	O
lines	int
/	O
2	int
;	O
else	O
this	pointer
->	O
scroll_step	int
=	O
StartupScrollStep	int
;	O
this	pointer
->	O
temp	pointer
=	O
xrealloc	function
(	O
this	pointer
->	O
temp	pointer
,	O
this	pointer
->	O
columns	int
)	O
;	O
window_resize	function
(	O
this	pointer
->	O
window	pointer
,	O
x	int
,	O
y	int
,	O
lines	int
,	O
columns	int
)	O
;	O
panel_center_current_entry	function
(	O
this	pointer
)	O
;	O
this	pointer
->	O
horizontal_offset	int
=	O
0	int
;	O
}	O
void	O
panel_set_wrapped_isearch_flag	function
(	O
this	pointer
,	O
value	int
)	O
panel_t	struct
*	O
this	pointer
;	O
int	O
value	int
;	O
{	O
this	pointer
->	O
wrapped_isearch	char
=	O
value	int
;	O
}	O
int	O
panel_isearch_backward	function
(	O
this	pointer
,	O
string	pointer
,	O
len	long
,	O
start_entry	int
)	O
panel_t	struct
*	O
this	pointer
;	O
char	O
*	O
string	pointer
;	O
size_t	long
len	long
;	O
int	O
start_entry	int
;	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
start_entry	int
;	O
i	int
>=	O
0	int
;	O
i	int
--	O
)	O
{	O
if	O
(	O
strncasecmp	function
(	O
string	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
name	pointer
,	O
len	long
)	O
==	O
0	int
)	O
{	O
return	O
i	int
;	O
}	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
panel_isearch_forward	function
(	O
this	pointer
,	O
string	pointer
,	O
len	long
,	O
start_entry	int
)	O
panel_t	struct
*	O
this	pointer
;	O
char	O
*	O
string	pointer
;	O
size_t	long
len	long
;	O
int	O
start_entry	int
;	O
{	O
int	O
entry	int
;	O
for	O
(	O
entry	int
=	O
start_entry	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
strncasecmp	function
(	O
string	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
,	O
len	long
)	O
==	O
0	int
)	O
{	O
return	O
entry	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
char	O
panel_2s_message	function
(	O
format	pointer
,	O
string	pointer
,	O
options	pointer
,	O
flags	int
)	O
char	O
*	O
format	pointer
;	O
char	O
*	O
string	pointer
;	O
char	O
*	O
options	pointer
;	O
int	O
flags	int
;	O
{	O
char	O
c	char
;	O
char	O
*	O
message	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
format	pointer
)	O
+	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
message	pointer
,	O
format	pointer
,	O
string	pointer
)	O
;	O
c	char
=	O
panel_1s_message	O
(	O
message	pointer
,	O
options	pointer
,	O
flags	int
)	O
;	O
xfree	function
(	O
message	pointer
)	O
;	O
return	O
c	char
;	O
}	O
char	O
panel_3s_message	function
(	O
format	pointer
,	O
string1	pointer
,	O
string2	pointer
,	O
options	pointer
,	O
flags	int
)	O
char	O
*	O
format	pointer
;	O
char	O
*	O
string1	pointer
;	O
char	O
*	O
string2	pointer
;	O
char	O
*	O
options	pointer
;	O
int	O
flags	int
;	O
{	O
char	O
c	char
;	O
char	O
*	O
message	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
format	pointer
)	O
+	O
strlen	function
(	O
string1	pointer
)	O
+	O
strlen	function
(	O
string2	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
message	pointer
,	O
format	pointer
,	O
string1	pointer
,	O
string2	pointer
)	O
;	O
c	char
=	O
panel_1s_message	O
(	O
message	pointer
,	O
options	pointer
,	O
flags	int
)	O
;	O
xfree	function
(	O
message	pointer
)	O
;	O
return	O
c	char
;	O
}	O
void	O
panel_recover	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
panel_set_current_entry	function
(	O
this	pointer
,	O
0	int
)	O
;	O
panel_2s_message	function
(	O
"%s/: Permission denied."	pointer
,	O
this	pointer
->	O
path	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
if	O
(	O
strcmp	function
(	O
this	pointer
->	O
path	pointer
,	O
"/"	pointer
)	O
==	O
0	int
)	O
fatal	function
(	O
"/: Permission denied"	pointer
)	O
;	O
strcpy	function
(	O
this	pointer
->	O
path	pointer
,	O
"/"	pointer
)	O
;	O
this	pointer
->	O
pathlen	long
=	O
1	int
;	O
chdir	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
panel_action	function
(	O
this	pointer
,	O
act_REGET	int
,	O
(	O
panel_t	struct
*	O
)	O
NULL	O
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
1	int
)	O
;	O
}	O
static	O
void	O
panel_load_fti	function
(	O
this	pointer
,	O
entry	int
)	O
panel_t	struct
*	O
this	pointer
;	O
int	O
entry	int
;	O
{	O
size_t	long
length	long
;	O
size_t	long
longest_length	long
=	O
0	int
;	O
file_type_info_t	struct
*	O
fti	pointer
;	O
file_type_info_t	struct
*	O
longest_fti	pointer
=	O
NULL	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
fti_loaded	char
=	O
1	int
;	O
for	O
(	O
fti	pointer
=	O
fti_head	pointer
;	O
fti	pointer
;	O
fti	pointer
=	O
fti	pointer
->	O
next	pointer
)	O
if	O
(	O
fnmatch	function
(	O
fti	pointer
->	O
pattern	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
,	O
FNM_PERIOD	O
|	O
FNM_PATHNAME	O
|	O
FNM_CASEFOLD	O
)	O
==	O
0	int
)	O
{	O
length	long
=	O
strlen	function
(	O
fti	pointer
->	O
pattern	pointer
)	O
;	O
if	O
(	O
length	long
>	O
longest_length	long
)	O
{	O
longest_fti	pointer
=	O
fti	pointer
;	O
longest_length	long
=	O
length	long
;	O
}	O
}	O
fti	pointer
=	O
longest_fti	pointer
;	O
if	O
(	O
fti	pointer
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
brightness	char
=	O
(	O
fti	pointer
->	O
brightness	char
==	O
-	O
1	int
)	O
?	O
OFF	int
:	O
fti	pointer
->	O
brightness	char
;	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
foreground	char
=	O
(	O
fti	pointer
->	O
foreground	char
==	O
-	O
1	int
)	O
?	O
PanelNotSelectedFile	O
:	O
fti	pointer
->	O
foreground	char
;	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
background	char
=	O
(	O
fti	pointer
->	O
background	char
==	O
-	O
1	int
)	O
?	O
PanelBackground	O
:	O
fti	pointer
->	O
background	char
;	O
}	O
else	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
brightness	char
=	O
2	int
;	O
}	O
}	O
static	O
void	O
panel_load_inode	function
(	O
this	pointer
,	O
entry	int
)	O
panel_t	struct
*	O
this	pointer
;	O
int	O
entry	int
;	O
{	O
int	O
sz	int
,	O
hour	int
;	O
struct	O
stat	struct
s	long
;	O
struct	O
tm	struct
*	O
time	struct
;	O
char	O
*	O
owner	pointer
;	O
char	O
*	O
group	pointer
;	O
memset	function
(	O
&	O
s	long
,	O
0	int
,	O
sizeof	O
(	O
s	long
)	O
)	O
;	O
xlstat	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
,	O
&	O
s	long
)	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
mode	int
=	O
s	long
.	O
st_mode	int
;	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
uid	int
=	O
s	long
.	O
st_uid	int
;	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
gid	int
=	O
s	long
.	O
st_gid	int
;	O
if	O
(	O
s	long
.	O
st_ino	long
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
s	long
.	O
st_mode	int
)	O
)	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
=	O
DIR_ENTRY	int
;	O
else	O
{	O
if	O
(	O
S_ISREG	O
(	O
s	long
.	O
st_mode	int
)	O
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
=	O
FILE_ENTRY	int
;	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
executable	char
=	O
(	O
(	O
s	long
.	O
st_mode	int
&	O
0111	int
)	O
&&	O
!	O
this	pointer
->	O
msdosfs	int
)	O
?	O
1	int
:	O
0	int
;	O
}	O
else	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
executable	char
=	O
0	int
;	O
if	O
(	O
S_ISFIFO	O
(	O
s	long
.	O
st_mode	int
)	O
)	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
=	O
FIFO_ENTRY	int
;	O
else	O
if	O
(	O
S_ISSOCK	O
(	O
s	long
.	O
st_mode	int
)	O
)	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
=	O
SOCKET_ENTRY	int
;	O
else	O
if	O
(	O
S_ISLNK	O
(	O
s	long
.	O
st_mode	int
)	O
)	O
{	O
struct	O
stat	struct
s_tmp	struct
;	O
int	O
stat_error	int
=	O
xstat	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
,	O
&	O
s_tmp	struct
)	O
;	O
if	O
(	O
stat_error	int
==	O
-	O
1	int
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
=	O
SYMLINK_ENTRY	int
;	O
sz	int
=	O
xreadlink	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
;	O
s	long
.	O
st_size	long
=	O
(	O
sz	int
==	O
-	O
1	int
)	O
?	O
0	int
:	O
sz	int
;	O
}	O
else	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
=	O
S_ISDIR	O
(	O
s_tmp	struct
.	O
st_mode	int
)	O
?	O
DIR_ENTRY	int
:	O
FILE_ENTRY	int
;	O
s	long
.	O
st_size	long
=	O
s_tmp	struct
.	O
st_size	long
;	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
executable	char
=	O
(	O
s_tmp	struct
.	O
st_mode	int
&	O
0111	int
)	O
?	O
1	int
:	O
0	int
;	O
}	O
}	O
else	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
=	O
FILE_ENTRY	int
;	O
}	O
}	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
size	long
=	O
s	long
.	O
st_size	long
;	O
}	O
else	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
=	O
SYMLINK_ENTRY	int
;	O
sz	int
=	O
xreadlink	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
size	long
=	O
(	O
sz	int
==	O
-	O
1	int
)	O
?	O
0	int
:	O
sz	int
;	O
}	O
owner	pointer
=	O
getuser	function
(	O
s	long
.	O
st_uid	int
)	O
;	O
if	O
(	O
owner	pointer
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
owner	pointer
=	O
xmalloc	function
(	O
1	int
+	O
max	O
(	O
strlen	function
(	O
owner	pointer
)	O
,	O
8	int
)	O
)	O
;	O
sprintf	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
owner	pointer
,	O
"%-7s"	pointer
,	O
owner	pointer
)	O
;	O
}	O
else	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
owner	pointer
=	O
xmalloc	function
(	O
32	int
)	O
;	O
sprintf	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
owner	pointer
,	O
"%-7u"	pointer
,	O
s	long
.	O
st_uid	int
)	O
;	O
}	O
group	pointer
=	O
getgroup	function
(	O
s	long
.	O
st_gid	int
)	O
;	O
if	O
(	O
group	pointer
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
group	pointer
=	O
xmalloc	function
(	O
1	int
+	O
max	O
(	O
strlen	function
(	O
group	pointer
)	O
,	O
8	int
)	O
)	O
;	O
sprintf	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
group	pointer
,	O
"%-7s"	pointer
,	O
group	pointer
)	O
;	O
}	O
else	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
group	pointer
=	O
xmalloc	function
(	O
32	int
)	O
;	O
sprintf	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
group	pointer
,	O
"%-7u"	pointer
,	O
s	long
.	O
st_gid	int
)	O
;	O
}	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
mtime	long
=	O
s	long
.	O
st_mtime	O
;	O
time	struct
=	O
localtime	function
(	O
&	O
s	long
.	O
st_mtime	O
)	O
;	O
if	O
(	O
(	O
hour	int
=	O
time	struct
->	O
tm_hour	int
%	O
12	int
)	O
==	O
0	int
)	O
hour	int
=	O
12	int
;	O
sprintf	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
date	array
,	O
"%2d-%02d-%02d %2d:%02d%c"	pointer
,	O
time	struct
->	O
tm_mon	int
+	O
1	int
,	O
time	struct
->	O
tm_mday	int
,	O
time	struct
->	O
tm_year	int
%	O
100	int
,	O
hour	int
,	O
time	struct
->	O
tm_min	int
,	O
(	O
time	struct
->	O
tm_hour	int
<	O
12	int
)	O
?	O
'a'	O
:	O
'p'	O
)	O
;	O
}	O
int	O
panel_read_directory	function
(	O
this	pointer
,	O
directory	pointer
,	O
verify	int
)	O
panel_t	struct
*	O
this	pointer
;	O
char	O
*	O
directory	pointer
;	O
int	O
verify	int
;	O
{	O
struct	O
statfs	struct
fstat	function
;	O
DIR	struct
*	O
tmpdir	pointer
;	O
struct	O
stat	struct
s	long
;	O
int	O
namelen	int
;	O
char	O
*	O
old_path	pointer
;	O
struct	O
dirent	struct
*	O
d	pointer
;	O
int	O
dotdot_found	int
=	O
0	int
;	O
dir_entry_t	struct
*	O
old_dir_entry	pointer
=	O
NULL	O
,	O
tmp	int
;	O
int	O
entry	int
,	O
old_entries	int
=	O
0	int
,	O
backdir_index	int
=	O
-	O
1	int
;	O
tmpdir	pointer
=	O
opendir	function
(	O
directory	pointer
)	O
;	O
if	O
(	O
tmpdir	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
strcmp	function
(	O
directory	pointer
,	O
".."	pointer
)	O
!=	O
0	int
)	O
return	O
0	int
;	O
directory	pointer
=	O
xgetcwd	function
(	O
)	O
;	O
if	O
(	O
directory	pointer
==	O
NULL	O
)	O
{	O
char	O
*	O
ptr	pointer
;	O
directory	pointer
=	O
xstrdup	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
ptr	pointer
=	O
strrchr	function
(	O
directory	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
ptr	pointer
==	O
NULL	O
)	O
fatal	function
(	O
"bad directory"	pointer
)	O
;	O
*	O
ptr	pointer
=	O
0	int
;	O
}	O
tmpdir	pointer
=	O
opendir	function
(	O
directory	pointer
)	O
;	O
if	O
(	O
tmpdir	pointer
==	O
NULL	O
)	O
{	O
xfree	function
(	O
directory	pointer
)	O
;	O
return	O
0	int
;	O
}	O
}	O
if	O
(	O
chdir	function
(	O
directory	pointer
)	O
==	O
-	O
1	int
)	O
{	O
closedir	function
(	O
tmpdir	pointer
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
this	pointer
->	O
dir	pointer
)	O
closedir	function
(	O
this	pointer
->	O
dir	pointer
)	O
;	O
this	pointer
->	O
dir	pointer
=	O
tmpdir	pointer
;	O
old_path	pointer
=	O
xmalloc	function
(	O
this	pointer
->	O
pathlen	long
+	O
1	int
)	O
;	O
strcpy	function
(	O
old_path	pointer
,	O
this	pointer
->	O
path	pointer
)	O
;	O
if	O
(	O
directory	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
this	pointer
->	O
path	pointer
=	O
xstrdup	function
(	O
directory	pointer
)	O
;	O
else	O
{	O
char	O
*	O
path	pointer
=	O
xgetcwd	function
(	O
)	O
;	O
if	O
(	O
path	pointer
)	O
{	O
xfree	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
this	pointer
->	O
path	pointer
=	O
path	pointer
;	O
}	O
else	O
{	O
this	pointer
->	O
pathlen	long
=	O
strlen	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
directory	pointer
,	O
".."	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
ptr	pointer
=	O
strrchr	function
(	O
this	pointer
->	O
path	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
ptr	pointer
==	O
NULL	O
)	O
fatal	function
(	O
"bad path"	pointer
)	O
;	O
*	O
ptr	pointer
=	O
0	int
;	O
}	O
else	O
{	O
this	pointer
->	O
path	pointer
=	O
xrealloc	function
(	O
this	pointer
->	O
path	pointer
,	O
this	pointer
->	O
pathlen	long
+	O
1	int
+	O
1	int
+	O
strlen	function
(	O
directory	pointer
)	O
)	O
;	O
strcat	function
(	O
this	pointer
->	O
path	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
this	pointer
->	O
path	pointer
,	O
directory	pointer
)	O
;	O
}	O
}	O
}	O
minimize_path	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
this	pointer
->	O
pathlen	long
=	O
strlen	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
xstat	function
(	O
this	pointer
->	O
path	pointer
,	O
&	O
s	long
)	O
;	O
if	O
(	O
s	long
.	O
st_size	long
>=	O
2048	int
)	O
{	O
il_message	function
(	O
PANEL_READ_DIR_MSG	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
statfs	struct
(	O
"."	pointer
,	O
&	O
fstat	function
)	O
;	O
this	pointer
->	O
msdosfs	int
=	O
fstat	function
.	O
f_type	long
==	O
0x4d44	int
;	O
verify	int
=	O
verify	int
&&	O
this	pointer
->	O
selected_entries	int
&&	O
(	O
strcmp	function
(	O
old_path	pointer
,	O
this	pointer
->	O
path	pointer
)	O
==	O
0	int
)	O
;	O
if	O
(	O
verify	int
)	O
{	O
old_dir_entry	pointer
=	O
this	pointer
->	O
dir_entry	pointer
;	O
old_entries	int
=	O
this	pointer
->	O
entries	int
;	O
this	pointer
->	O
dir_entry	pointer
=	O
NULL	O
;	O
}	O
else	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
)	O
{	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
{	O
xfree	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
=	O
NULL	O
;	O
}	O
xfree	function
(	O
this	pointer
->	O
dir_entry	pointer
)	O
;	O
this	pointer
->	O
dir_entry	pointer
=	O
NULL	O
;	O
}	O
this	pointer
->	O
dir_entry	pointer
=	O
(	O
dir_entry_t	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
dir_entry_t	struct
)	O
)	O
;	O
this	pointer
->	O
selected_entries	int
=	O
0	int
;	O
this	pointer
->	O
maxname	int
=	O
0	int
;	O
for	O
(	O
this	pointer
->	O
entries	int
=	O
0	int
;	O
(	O
d	pointer
=	O
readdir	function
(	O
this	pointer
->	O
dir	pointer
)	O
)	O
;	O
this	pointer
->	O
entries	int
++	O
)	O
{	O
if	O
(	O
d	pointer
->	O
d_name	array
[	O
0	int
]	O
==	O
'.'	O
&&	O
d	pointer
->	O
d_name	array
[	O
1	int
]	O
==	O
0	int
)	O
{	O
this	pointer
->	O
entries	int
--	O
;	O
continue	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
d	pointer
->	O
d_name	array
,	O
".."	pointer
)	O
==	O
0	int
)	O
{	O
dotdot_found	int
=	O
1	int
;	O
if	O
(	O
this	pointer
->	O
path	pointer
[	O
1	int
]	O
)	O
backdir_index	int
=	O
this	pointer
->	O
entries	int
;	O
else	O
{	O
this	pointer
->	O
entries	int
--	O
;	O
continue	O
;	O
}	O
}	O
this	pointer
->	O
dir_entry	pointer
=	O
(	O
dir_entry_t	struct
*	O
)	O
xrealloc	function
(	O
this	pointer
->	O
dir_entry	pointer
,	O
(	O
this	pointer
->	O
entries	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
dir_entry_t	struct
)	O
)	O
;	O
if	O
(	O
verify	int
)	O
{	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
old_entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
d	pointer
->	O
d_name	array
,	O
old_dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
{	O
this	pointer
->	O
selected_entries	int
+=	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
selected	char
=	O
old_dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
)	O
;	O
break	O
;	O
}	O
if	O
(	O
entry	int
==	O
old_entries	int
)	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
selected	char
=	O
0	int
;	O
}	O
else	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
selected	char
=	O
0	int
;	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
fti_loaded	char
=	O
0	int
;	O
namelen	int
=	O
strlen	function
(	O
d	pointer
->	O
d_name	array
)	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
name	pointer
=	O
xmalloc	function
(	O
namelen	int
+	O
1	int
)	O
;	O
strcpy	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
name	pointer
,	O
d	pointer
->	O
d_name	array
)	O
;	O
this	pointer
->	O
maxname	int
=	O
max	O
(	O
this	pointer
->	O
maxname	int
,	O
namelen	int
)	O
;	O
panel_load_inode	function
(	O
this	pointer
,	O
this	pointer
->	O
entries	int
)	O
;	O
}	O
if	O
(	O
dotdot_found	int
)	O
{	O
if	O
(	O
backdir_index	int
!=	O
-	O
1	int
)	O
if	O
(	O
!	O
S_ISDIR	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
backdir_index	int
]	O
.	O
mode	int
)	O
)	O
this	pointer
->	O
dir_entry	pointer
[	O
backdir_index	int
]	O
.	O
mode	int
=	O
S_IFDIR	O
;	O
}	O
else	O
{	O
this	pointer
->	O
dir_entry	pointer
=	O
(	O
dir_entry_t	struct
*	O
)	O
xrealloc	function
(	O
this	pointer
->	O
dir_entry	pointer
,	O
(	O
this	pointer
->	O
entries	int
+	O
1	int
)	O
*	O
sizeof	O
(	O
dir_entry_t	struct
)	O
)	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
selected	char
=	O
0	int
;	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
fti_loaded	char
=	O
1	int
;	O
namelen	int
=	O
strlen	function
(	O
".."	pointer
)	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
name	pointer
=	O
xmalloc	function
(	O
namelen	int
+	O
1	int
)	O
;	O
strcpy	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
name	pointer
,	O
".."	pointer
)	O
;	O
this	pointer
->	O
maxname	int
=	O
max	O
(	O
this	pointer
->	O
maxname	int
,	O
namelen	int
)	O
;	O
panel_load_inode	function
(	O
this	pointer
,	O
this	pointer
->	O
entries	int
)	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
mode	int
=	O
S_IFDIR	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
entries	int
]	O
.	O
type	enum
=	O
DIR_ENTRY	int
;	O
this	pointer
->	O
entries	int
++	O
;	O
}	O
if	O
(	O
verify	int
)	O
{	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
old_entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
old_dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
{	O
xfree	function
(	O
old_dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
;	O
old_dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
=	O
NULL	O
;	O
}	O
xfree	function
(	O
old_dir_entry	pointer
)	O
;	O
}	O
CurrentSortMethod	int
=	O
this	pointer
->	O
sort_method	int
;	O
this	pointer
->	O
horizontal_offset	int
=	O
0	int
;	O
if	O
(	O
backdir_index	int
!=	O
-	O
1	int
)	O
{	O
tmp	int
=	O
this	pointer
->	O
dir_entry	pointer
[	O
0	int
]	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
0	int
]	O
=	O
this	pointer
->	O
dir_entry	pointer
[	O
backdir_index	int
]	O
;	O
this	pointer
->	O
dir_entry	pointer
[	O
backdir_index	int
]	O
=	O
tmp	int
;	O
qsort	function
(	O
this	pointer
->	O
dir_entry	pointer
+	O
1	int
,	O
this	pointer
->	O
entries	int
-	O
1	int
,	O
sizeof	O
(	O
dir_entry_t	struct
)	O
,	O
sort_compare_fn	function
)	O
;	O
}	O
else	O
qsort	function
(	O
this	pointer
->	O
dir_entry	pointer
,	O
this	pointer
->	O
entries	int
,	O
sizeof	O
(	O
dir_entry_t	struct
)	O
,	O
sort_compare_fn	function
)	O
;	O
panel_set_current_entry	function
(	O
this	pointer
,	O
min	O
(	O
this	pointer
->	O
current_entry	int
,	O
this	pointer
->	O
entries	int
-	O
1	int
)	O
)	O
;	O
xfree	function
(	O
old_path	pointer
)	O
;	O
return	O
1	int
;	O
}	O
void	O
panel_init_iterator	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
this	pointer
->	O
last_index	int
=	O
-	O
1	int
;	O
this	pointer
->	O
multiple_files	int
=	O
this	pointer
->	O
selected_entries	int
;	O
}	O
int	O
panel_get_next	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
int	O
i	int
;	O
if	O
(	O
this	pointer
->	O
multiple_files	int
)	O
{	O
for	O
(	O
i	int
=	O
this	pointer
->	O
last_index	int
+	O
1	int
;	O
i	int
<	O
this	pointer
->	O
entries	int
;	O
i	int
++	O
)	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
selected	char
)	O
return	O
this	pointer
->	O
last_index	int
=	O
i	int
;	O
return	O
-	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
this	pointer
->	O
last_index	int
==	O
0	int
)	O
return	O
-	O
1	int
;	O
this	pointer
->	O
last_index	int
=	O
0	int
;	O
if	O
(	O
rootdir	O
(	O
)	O
)	O
return	O
this	pointer
->	O
current_entry	int
;	O
else	O
return	O
(	O
this	pointer
->	O
current_entry	int
!=	O
0	int
)	O
?	O
this	pointer
->	O
current_entry	int
:	O
-	O
1	int
;	O
}	O
}	O
void	O
panel_update_entries	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
int	O
i	int
,	O
limit	int
;	O
tty_status_t	char
status	int
;	O
assert	O
(	O
this	pointer
->	O
current_entry	int
<	O
this	pointer
->	O
entries	int
)	O
;	O
if	O
(	O
!	O
this	pointer
->	O
visible	char
)	O
return	O
;	O
tty_save	function
(	O
&	O
status	int
)	O
;	O
for	O
(	O
i	int
=	O
this	pointer
->	O
first_on_screen	int
;	O
(	O
i	int
<	O
this	pointer
->	O
entries	int
)	O
&&	O
(	O
i	int
-	O
this	pointer
->	O
first_on_screen	int
<	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
;	O
i	int
++	O
)	O
panel_update_entry	function
(	O
this	pointer
,	O
i	int
)	O
;	O
tty_colors	function
(	O
OFF	int
,	O
WHITE	int
,	O
PanelBackground	O
)	O
;	O
memset	function
(	O
this	pointer
->	O
temp	pointer
,	O
' '	O
,	O
this	pointer
->	O
columns	int
)	O
;	O
limit	int
=	O
min	O
(	O
this	pointer
->	O
lines	int
-	O
2	int
,	O
this	pointer
->	O
on_screen	int
)	O
;	O
for	O
(	O
;	O
i	int
<	O
limit	int
;	O
i	int
++	O
)	O
{	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
i	int
-	O
this	pointer
->	O
first_on_screen	int
+	O
1	int
,	O
1	int
)	O
;	O
window_puts	function
(	O
this	pointer
->	O
window	pointer
,	O
this	pointer
->	O
temp	pointer
,	O
this	pointer
->	O
columns	int
-	O
2	int
)	O
;	O
}	O
this	pointer
->	O
on_screen	int
=	O
this	pointer
->	O
entries	int
;	O
tty_restore	function
(	O
&	O
status	int
)	O
;	O
}	O
void	O
panel_update_path	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
size_t	long
len	long
;	O
tty_status_t	char
status	int
;	O
if	O
(	O
this	pointer
->	O
columns	int
<	O
(	O
1	int
+	O
1	int
+	O
1	int
+	O
1	int
+	O
14	int
+	O
1	int
+	O
1	int
)	O
)	O
return	O
;	O
if	O
(	O
!	O
this	pointer
->	O
visible	char
)	O
return	O
;	O
tty_save	function
(	O
&	O
status	int
)	O
;	O
len	long
=	O
this	pointer
->	O
columns	int
-	O
(	O
1	int
+	O
1	int
+	O
1	int
+	O
14	int
+	O
1	int
+	O
1	int
)	O
;	O
memset	function
(	O
this	pointer
->	O
temp	pointer
,	O
' '	O
,	O
this	pointer
->	O
columns	int
)	O
;	O
truncate_long_name	function
(	O
this	pointer
->	O
path	pointer
,	O
this	pointer
->	O
temp	pointer
,	O
len	long
)	O
;	O
toprintable	function
(	O
this	pointer
->	O
temp	pointer
,	O
len	long
)	O
;	O
tty_colors	function
(	O
PanelPathBrightness	O
,	O
PanelPath	O
,	O
PanelFrame	O
)	O
;	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
0	int
,	O
2	int
)	O
;	O
window_puts	function
(	O
this	pointer
->	O
window	pointer
,	O
this	pointer
->	O
temp	pointer
,	O
len	long
+	O
1	int
)	O
;	O
tty_restore	function
(	O
&	O
status	int
)	O
;	O
}	O
static	O
char	O
*	O
panel_beautify_number	function
(	O
buf	pointer
,	O
number	long
,	O
inflags	int
)	O
char	O
*	O
buf	pointer
;	O
off64_t	long
number	long
;	O
int	O
inflags	int
;	O
{	O
int	O
flags	int
=	O
(	O
inflags	int
|	O
human_ceiling	int
|	O
human_suppress_point_zero	int
)	O
;	O
return	O
human_readable	function
(	O
number	long
,	O
buf	pointer
,	O
flags	int
,	O
1	int
,	O
1	int
)	O
;	O
}	O
static	O
int	O
panel_fit_number	function
(	O
buf	pointer
,	O
number	long
,	O
flags	int
,	O
maxlen	int
)	O
char	O
*	O
buf	pointer
;	O
off64_t	long
number	long
;	O
int	O
flags	int
;	O
int	O
maxlen	int
;	O
{	O
char	O
*	O
str	pointer
=	O
NULL	O
;	O
int	O
scaled	int
=	O
(	O
flags	int
&	O
human_autoscale	int
)	O
;	O
str	pointer
=	O
panel_beautify_number	function
(	O
buf	pointer
,	O
number	long
,	O
(	O
flags	int
|	O
(	O
GroupDigits	int
?	O
human_group_digits	int
:	O
0	int
)	O
)	O
)	O
;	O
if	O
(	O
(	O
str	pointer
==	O
NULL	O
)	O
||	O
(	O
strlen	function
(	O
str	pointer
)	O
>	O
maxlen	int
)	O
)	O
{	O
scaled	int
=	O
1	int
;	O
str	pointer
=	O
panel_beautify_number	function
(	O
buf	pointer
,	O
number	long
,	O
(	O
flags	int
|	O
human_autoscale	int
|	O
human_SI	int
|	O
human_base_1024	int
)	O
)	O
;	O
}	O
strncpy	function
(	O
buf	pointer
,	O
str	pointer
,	O
maxlen	int
)	O
;	O
buf	pointer
[	O
maxlen	int
]	O
=	O
'\0'	O
;	O
return	O
scaled	int
;	O
}	O
static	O
char	O
*	O
panel_beautify_info_number	function
(	O
buf	pointer
,	O
number	long
,	O
width	int
,	O
numfiles	int
)	O
char	O
*	O
buf	pointer
;	O
off64_t	long
number	long
;	O
int	O
width	int
;	O
int	O
numfiles	int
;	O
{	O
char	O
shortnumbuf	array
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
char	O
*	O
shortnum	pointer
;	O
char	O
longnumbuf	array
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
char	O
filesbuf	array
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
char	O
*	O
filestr	pointer
;	O
int	O
scaled	int
;	O
filestr	pointer
=	O
panel_beautify_number	function
(	O
filesbuf	array
,	O
(	O
off64_t	long
)	O
numfiles	int
,	O
(	O
GroupDigits	int
?	O
human_group_digits	int
:	O
0	int
)	O
)	O
;	O
scaled	int
=	O
panel_fit_number	function
(	O
longnumbuf	array
,	O
number	long
,	O
0	int
,	O
(	O
width	int
-	O
(	O
STATIC_TEXT_LEN	int
+	O
strlen	function
(	O
filestr	pointer
)	O
)	O
)	O
)	O
;	O
if	O
(	O
(	O
!	O
scaled	int
)	O
&&	O
(	O
number	long
>	O
999	int
)	O
)	O
{	O
shortnum	pointer
=	O
panel_beautify_number	function
(	O
shortnumbuf	array
,	O
number	long
,	O
(	O
human_SI	int
|	O
human_autoscale	int
|	O
human_base_1024	int
)	O
)	O
;	O
sprintf	function
(	O
buf	pointer
,	O
"%s (%sB) in %s file%s"	pointer
,	O
longnumbuf	array
,	O
shortnum	pointer
,	O
filestr	pointer
,	O
(	O
numfiles	int
>	O
1	int
)	O
?	O
"s"	pointer
:	O
""	pointer
)	O
;	O
}	O
else	O
{	O
sprintf	function
(	O
buf	pointer
,	O
"%s in %s file%s"	pointer
,	O
longnumbuf	array
,	O
filestr	pointer
,	O
(	O
numfiles	int
>	O
1	int
)	O
?	O
"s"	pointer
:	O
""	pointer
)	O
;	O
}	O
return	O
buf	pointer
;	O
}	O
void	O
panel_update_size	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
char	O
buf	pointer
[	O
LONGEST_HUMAN_READABLE	O
+	O
3	int
]	O
;	O
char	O
*	O
sz	int
;	O
tty_status_t	char
status	int
;	O
struct	O
fs_usage	struct
fsu	struct
;	O
int	O
viewable	int
=	O
this	pointer
->	O
columns	int
-	O
(	O
1	int
+	O
1	int
+	O
1	int
+	O
1	int
)	O
;	O
if	O
(	O
!	O
this	pointer
->	O
visible	char
)	O
return	O
;	O
tty_save	function
(	O
&	O
status	int
)	O
;	O
fsu	struct
.	O
fsu_blocks	long
=	O
(	O
uintmax_t	long
)	O
-	O
1	int
;	O
if	O
(	O
viewable	int
<	O
6	int
||	O
get_fs_usage	function
(	O
this	pointer
->	O
path	pointer
,	O
NULL	O
,	O
&	O
fsu	struct
)	O
<	O
0	int
||	O
fsu	struct
.	O
fsu_blocks	long
==	O
(	O
uintmax_t	long
)	O
-	O
1	int
)	O
{	O
memset	function
(	O
buf	pointer
,	O
' '	O
,	O
sizeof	O
(	O
buf	pointer
)	O
)	O
;	O
sz	int
=	O
buf	pointer
;	O
tty_brightness	function
(	O
OFF	int
)	O
;	O
tty_foreground	function
(	O
PanelFrame	O
)	O
;	O
}	O
else	O
{	O
off64_t	long
n	long
;	O
off64_t	long
free_blocks	long
=	O
fsu	struct
.	O
fsu_bavail	long
;	O
if	O
(	O
free_blocks	long
<	O
0	int
)	O
free_blocks	long
=	O
0	int
;	O
n	long
=	O
free_blocks	long
*	O
fsu	struct
.	O
fsu_blocksize	long
;	O
sz	int
=	O
panel_beautify_number	function
(	O
buf	pointer
,	O
n	long
,	O
(	O
human_autoscale	int
|	O
human_SI	int
|	O
human_base_1024	int
)	O
)	O
;	O
sz	int
=	O
strcat	function
(	O
sz	int
,	O
"B"	pointer
)	O
;	O
tty_brightness	function
(	O
PanelDeviceFreeSpaceBrightness	O
)	O
;	O
tty_foreground	function
(	O
PanelDeviceFreeSpace	O
)	O
;	O
}	O
tty_background	function
(	O
PanelFrame	O
)	O
;	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
0	int
,	O
this	pointer
->	O
columns	int
-	O
2	int
-	O
min	O
(	O
strlen	function
(	O
sz	int
)	O
,	O
viewable	int
)	O
)	O
;	O
window_puts	function
(	O
this	pointer
->	O
window	pointer
,	O
sz	int
,	O
min	O
(	O
strlen	function
(	O
sz	int
)	O
,	O
viewable	int
)	O
)	O
;	O
tty_restore	function
(	O
&	O
status	int
)	O
;	O
}	O
static	O
void	O
panel_mode2string	function
(	O
this	pointer
,	O
entry	int
,	O
string	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
int	O
entry	int
;	O
char	O
*	O
string	pointer
;	O
{	O
int	O
i	int
;	O
mode_t	int
mode	int
;	O
strcpy	function
(	O
string	pointer
,	O
rights	array
)	O
;	O
mode	int
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
mode	int
;	O
if	O
(	O
S_ISREG	O
(	O
mode	int
)	O
)	O
string	pointer
[	O
0	int
]	O
=	O
'-'	O
;	O
else	O
if	O
(	O
S_ISDIR	O
(	O
mode	int
)	O
)	O
string	pointer
[	O
0	int
]	O
=	O
'd'	O
;	O
else	O
if	O
(	O
S_ISCHR	O
(	O
mode	int
)	O
)	O
string	pointer
[	O
0	int
]	O
=	O
'c'	O
;	O
else	O
if	O
(	O
S_ISBLK	O
(	O
mode	int
)	O
)	O
string	pointer
[	O
0	int
]	O
=	O
'b'	O
;	O
else	O
if	O
(	O
S_ISFIFO	O
(	O
mode	int
)	O
)	O
string	pointer
[	O
0	int
]	O
=	O
'p'	O
;	O
else	O
if	O
(	O
S_ISSOCK	O
(	O
mode	int
)	O
)	O
string	pointer
[	O
0	int
]	O
=	O
's'	O
;	O
else	O
if	O
(	O
S_ISLNK	O
(	O
mode	int
)	O
)	O
string	pointer
[	O
0	int
]	O
=	O
'l'	O
;	O
else	O
string	pointer
[	O
0	int
]	O
=	O
'?'	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
9	int
;	O
mode	int
>>=	O
1	int
,	O
i	int
++	O
)	O
if	O
(	O
(	O
mode	int
&	O
1	int
)	O
==	O
0	int
)	O
string	pointer
[	O
9	int
-	O
i	int
]	O
=	O
'-'	O
;	O
mode	int
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
mode	int
;	O
if	O
(	O
mode	int
&	O
S_ISUID	O
)	O
string	pointer
[	O
3	int
]	O
=	O
(	O
string	pointer
[	O
3	int
]	O
==	O
'x'	O
)	O
?	O
's'	O
:	O
'S'	O
;	O
if	O
(	O
mode	int
&	O
S_ISGID	O
)	O
string	pointer
[	O
6	int
]	O
=	O
(	O
string	pointer
[	O
6	int
]	O
==	O
'x'	O
)	O
?	O
's'	O
:	O
'S'	O
;	O
if	O
(	O
mode	int
&	O
S_ISVTX	O
)	O
string	pointer
[	O
9	int
]	O
=	O
(	O
string	pointer
[	O
9	int
]	O
==	O
'x'	O
)	O
?	O
't'	O
:	O
'T'	O
;	O
}	O
void	O
panel_update_info	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
tty_status_t	char
status	int
;	O
size_t	long
len	long
,	O
maxname	int
;	O
off64_t	long
total_size	long
=	O
0	int
;	O
char	O
str	pointer
[	O
1024	int
]	O
;	O
char	O
temp_rights	array
[	O
16	int
]	O
;	O
assert	O
(	O
this	pointer
->	O
current_entry	int
<	O
this	pointer
->	O
entries	int
)	O
;	O
if	O
(	O
!	O
this	pointer
->	O
visible	char
)	O
return	O
;	O
tty_save	function
(	O
&	O
status	int
)	O
;	O
if	O
(	O
this	pointer
->	O
lines	int
>=	O
3	int
)	O
{	O
tty_colors	function
(	O
OFF	int
,	O
PanelFrame	O
,	O
PanelFrame	O
)	O
;	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
this	pointer
->	O
thumb	int
+	O
1	int
,	O
this	pointer
->	O
columns	int
-	O
1	int
)	O
;	O
window_putc	function
(	O
this	pointer
->	O
window	pointer
,	O
' '	O
)	O
;	O
if	O
(	O
this	pointer
->	O
entries	int
>	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
{	O
this	pointer
->	O
thumb	int
=	O
(	O
(	O
this	pointer
->	O
current_entry	int
*	O
(	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
)	O
/	O
this	pointer
->	O
entries	int
)	O
;	O
tty_colors	function
(	O
PanelThumbBrightness	O
,	O
PanelThumbForeground	O
,	O
PanelThumbBackground	O
)	O
;	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
this	pointer
->	O
thumb	int
+	O
1	int
,	O
this	pointer
->	O
columns	int
-	O
1	int
)	O
;	O
window_putc	function
(	O
this	pointer
->	O
window	pointer
,	O
'#'	O
)	O
;	O
}	O
}	O
if	O
(	O
this	pointer
->	O
columns	int
<	O
40	int
)	O
{	O
if	O
(	O
this	pointer
->	O
columns	int
<	O
(	O
1	int
+	O
1	int
+	O
10	int
+	O
1	int
+	O
1	int
)	O
)	O
*	O
str	pointer
=	O
'\0'	O
;	O
else	O
{	O
panel_mode2string	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
,	O
temp_rights	array
)	O
;	O
sprintf	function
(	O
str	pointer
,	O
"%10s"	pointer
,	O
temp_rights	array
)	O
;	O
}	O
goto	O
skip_info_display	O
;	O
}	O
if	O
(	O
this	pointer
->	O
selected_entries	int
)	O
{	O
int	O
entry	int
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
&&	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
==	O
FILE_ENTRY	int
)	O
total_size	long
+=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
size	long
;	O
panel_beautify_info_number	function
(	O
str	pointer
,	O
total_size	long
,	O
this	pointer
->	O
columns	int
,	O
this	pointer
->	O
selected_entries	int
)	O
;	O
tty_brightness	function
(	O
PanelFilesInfoBrightness	O
)	O
;	O
tty_foreground	function
(	O
PanelFilesInfo	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
InfoDisplay	int
==	O
OFF	int
)	O
{	O
*	O
str	pointer
=	O
'\0'	O
;	O
goto	O
skip_info_display	O
;	O
}	O
panel_mode2string	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
,	O
temp_rights	array
)	O
;	O
maxname	int
=	O
this	pointer
->	O
columns	int
-	O
26	int
;	O
len	long
=	O
min	O
(	O
strlen	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
)	O
,	O
maxname	int
)	O
;	O
memcpy	function
(	O
str	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
,	O
len	long
)	O
;	O
memset	function
(	O
str	pointer
+	O
len	long
,	O
' '	O
,	O
maxname	int
-	O
len	long
)	O
;	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
type	enum
==	O
DIR_ENTRY	int
)	O
sprintf	function
(	O
str	pointer
+	O
maxname	int
,	O
" %10s %10s"	pointer
,	O
(	O
strcmp	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
,	O
".."	pointer
)	O
==	O
0	int
)	O
?	O
" UP-DIR"	pointer
:	O
"SUB-DIR"	pointer
,	O
temp_rights	array
)	O
;	O
else	O
{	O
char	O
size	long
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
panel_fit_number	function
(	O
size	long
,	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
size	long
,	O
0	int
,	O
10	int
)	O
;	O
sprintf	function
(	O
str	pointer
+	O
maxname	int
,	O
" %10s %10s"	pointer
,	O
size	long
,	O
temp_rights	array
)	O
;	O
}	O
skip_info_display	O
:	O
tty_brightness	function
(	O
PanelFileInfoBrightness	O
)	O
;	O
tty_foreground	function
(	O
PanelFileInfo	O
)	O
;	O
}	O
memcpy	function
(	O
this	pointer
->	O
temp	pointer
,	O
str	pointer
,	O
len	long
=	O
strlen	function
(	O
str	pointer
)	O
)	O
;	O
if	O
(	O
(	O
len	long
+	O
2	int
)	O
<	O
this	pointer
->	O
columns	int
)	O
memset	function
(	O
this	pointer
->	O
temp	pointer
+	O
len	long
,	O
' '	O
,	O
this	pointer
->	O
columns	int
-	O
2	int
-	O
len	long
)	O
;	O
toprintable	function
(	O
this	pointer
->	O
temp	pointer
,	O
len	long
)	O
;	O
tty_background	function
(	O
PanelFrame	O
)	O
;	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
this	pointer
->	O
lines	int
-	O
1	int
,	O
2	int
)	O
;	O
window_puts	function
(	O
this	pointer
->	O
window	pointer
,	O
this	pointer
->	O
temp	pointer
,	O
this	pointer
->	O
columns	int
-	O
4	int
)	O
;	O
tty_restore	function
(	O
&	O
status	int
)	O
;	O
}	O
void	O
panel_build_entry_field	function
(	O
this	pointer
,	O
entry	int
,	O
display_mode	int
,	O
offset	long
)	O
panel_t	struct
*	O
this	pointer
;	O
int	O
entry	int
,	O
display_mode	int
,	O
offset	long
;	O
{	O
char	O
temp_rights	array
[	O
16	int
]	O
;	O
char	O
hbuf	array
[	O
LONGEST_HUMAN_READABLE	O
+	O
1	int
]	O
;	O
switch	O
(	O
display_mode	int
)	O
{	O
case	O
ENABLE_OWNER_GROUP	int
:	O
memcpy	function
(	O
this	pointer
->	O
temp	pointer
+	O
this	pointer
->	O
columns	int
-	O
2	int
-	O
offset	long
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
owner	pointer
,	O
7	int
)	O
;	O
memcpy	function
(	O
this	pointer
->	O
temp	pointer
+	O
this	pointer
->	O
columns	int
-	O
2	int
-	O
offset	long
+	O
8	int
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
group	pointer
,	O
7	int
)	O
;	O
break	O
;	O
case	O
ENABLE_DATE_TIME	int
:	O
memcpy	function
(	O
this	pointer
->	O
temp	pointer
+	O
this	pointer
->	O
columns	int
-	O
2	int
-	O
offset	long
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
date	array
,	O
15	int
)	O
;	O
break	O
;	O
case	O
ENABLE_SIZE	int
:	O
case	O
ENABLE_ABBREVSIZE	int
:	O
{	O
char	O
*	O
ptr	pointer
;	O
int	O
buflen	int
;	O
int	O
flags	int
=	O
0	int
;	O
if	O
(	O
(	O
display_mode	int
==	O
ENABLE_ABBREVSIZE	int
)	O
||	O
(	O
strlen	function
(	O
human_readable	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
size	long
,	O
hbuf	array
,	O
human_ceiling	int
,	O
1	int
,	O
1	int
)	O
)	O
>	O
MaxUnscaledDigits	int
)	O
)	O
{	O
flags	int
|=	O
(	O
human_autoscale	int
|	O
human_SI	int
|	O
human_base_1024	int
)	O
;	O
}	O
panel_fit_number	function
(	O
hbuf	array
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
size	long
,	O
flags	int
,	O
10	int
)	O
;	O
buflen	int
=	O
min	O
(	O
strlen	function
(	O
hbuf	array
)	O
,	O
10	int
)	O
;	O
ptr	pointer
=	O
this	pointer
->	O
temp	pointer
+	O
this	pointer
->	O
columns	int
-	O
2	int
-	O
offset	long
;	O
if	O
(	O
buflen	int
<	O
10	int
)	O
{	O
memset	function
(	O
ptr	pointer
,	O
' '	O
,	O
10	int
-	O
buflen	int
)	O
;	O
ptr	pointer
+=	O
(	O
10	int
-	O
buflen	int
)	O
;	O
}	O
memcpy	function
(	O
ptr	pointer
,	O
hbuf	array
,	O
buflen	int
)	O
;	O
break	O
;	O
}	O
case	O
ENABLE_MODE	int
:	O
panel_mode2string	function
(	O
this	pointer
,	O
entry	int
,	O
temp_rights	array
)	O
;	O
memcpy	function
(	O
this	pointer
->	O
temp	pointer
+	O
this	pointer
->	O
columns	int
-	O
2	int
-	O
offset	long
,	O
temp_rights	array
,	O
10	int
)	O
;	O
break	O
;	O
case	O
ENABLE_FULL_NAME	int
:	O
assert	O
(	O
0	int
)	O
;	O
break	O
;	O
case	O
ENABLE_ALL	int
:	O
break	O
;	O
default	O
:	O
fatal	function
(	O
"invalid mode"	pointer
)	O
;	O
}	O
}	O
static	O
int	O
reserved_characters	array
[	O
FILE_DISPLAY_MODES	int
]	O
=	O
{	O
1	int
+	O
1	int
+	O
16	int
+	O
1	int
+	O
1	int
,	O
1	int
+	O
1	int
+	O
16	int
+	O
1	int
+	O
1	int
,	O
1	int
+	O
1	int
+	O
11	int
+	O
1	int
+	O
1	int
,	O
1	int
+	O
1	int
+	O
11	int
+	O
1	int
+	O
1	int
,	O
1	int
+	O
1	int
+	O
11	int
+	O
1	int
+	O
1	int
,	O
1	int
+	O
1	int
+	O
0	int
+	O
1	int
+	O
1	int
,	O
1	int
+	O
1	int
+	O
16	int
+	O
16	int
+	O
11	int
+	O
11	int
+	O
1	int
+	O
1	int
,	O
}	O
;	O
static	O
int	O
panel_get_reserved_characters	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
if	O
(	O
(	O
this	pointer
->	O
columns	int
<	O
40	int
)	O
||	O
(	O
(	O
this	pointer
->	O
columns	int
<	O
20	int
+	O
16	int
+	O
16	int
+	O
11	int
+	O
11	int
)	O
&&	O
(	O
this	pointer
->	O
display_mode	int
==	O
ENABLE_ALL	int
)	O
)	O
)	O
return	O
1	int
+	O
1	int
+	O
1	int
+	O
1	int
;	O
else	O
return	O
reserved_characters	array
[	O
this	pointer
->	O
display_mode	int
]	O
;	O
}	O
void	O
panel_update_entry	function
(	O
this	pointer
,	O
entry	int
)	O
panel_t	struct
*	O
this	pointer
;	O
int	O
entry	int
;	O
{	O
char	O
c	char
=	O
'\0'	O
;	O
int	O
foreground	char
,	O
background	char
,	O
brightness	char
;	O
size_t	long
len	long
,	O
reserved	long
,	O
entry_length	long
,	O
offset	long
;	O
assert	O
(	O
this	pointer
->	O
current_entry	int
<	O
this	pointer
->	O
entries	int
)	O
;	O
if	O
(	O
!	O
this	pointer
->	O
visible	char
)	O
return	O
;	O
memset	function
(	O
this	pointer
->	O
temp	pointer
,	O
' '	O
,	O
this	pointer
->	O
columns	int
)	O
;	O
reserved	long
=	O
panel_get_reserved_characters	function
(	O
this	pointer
)	O
;	O
if	O
(	O
(	O
entry	int
>	O
0	int
)	O
||	O
rootdir	O
(	O
)	O
)	O
switch	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
)	O
{	O
case	O
FILE_ENTRY	int
:	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
executable	char
)	O
c	char
=	O
'*'	O
;	O
break	O
;	O
case	O
DIR_ENTRY	int
:	O
c	char
=	O
'/'	O
;	O
break	O
;	O
case	O
SYMLINK_ENTRY	int
:	O
c	char
=	O
'@'	O
;	O
break	O
;	O
case	O
FIFO_ENTRY	int
:	O
c	char
=	O
'|'	O
;	O
break	O
;	O
case	O
SOCKET_ENTRY	int
:	O
c	char
=	O
'='	O
;	O
break	O
;	O
}	O
if	O
(	O
c	char
!=	O
'\0'	O
)	O
reserved	long
++	O
;	O
entry_length	long
=	O
strlen	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
this	pointer
->	O
columns	int
-	O
reserved	long
>=	O
entry_length	long
)	O
offset	long
=	O
0	int
;	O
else	O
if	O
(	O
this	pointer
->	O
columns	int
-	O
reserved	long
+	O
this	pointer
->	O
horizontal_offset	int
>	O
entry_length	long
)	O
offset	long
=	O
entry_length	long
-	O
(	O
this	pointer
->	O
columns	int
-	O
reserved	long
)	O
;	O
else	O
offset	long
=	O
this	pointer
->	O
horizontal_offset	int
;	O
len	long
=	O
min	O
(	O
entry_length	long
-	O
offset	long
,	O
this	pointer
->	O
columns	int
-	O
reserved	long
)	O
;	O
memcpy	function
(	O
&	O
this	pointer
->	O
temp	pointer
[	O
1	int
]	O
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
+	O
offset	long
,	O
len	long
)	O
;	O
toprintable	function
(	O
&	O
this	pointer
->	O
temp	pointer
[	O
1	int
]	O
,	O
len	long
)	O
;	O
if	O
(	O
c	char
!=	O
'\0'	O
)	O
this	pointer
->	O
temp	pointer
[	O
len	long
+	O
1	int
]	O
=	O
c	char
;	O
if	O
(	O
this	pointer
->	O
columns	int
>=	O
40	int
)	O
switch	O
(	O
this	pointer
->	O
display_mode	int
)	O
{	O
case	O
ENABLE_OWNER_GROUP	int
:	O
case	O
ENABLE_DATE_TIME	int
:	O
panel_build_entry_field	function
(	O
this	pointer
,	O
entry	int
,	O
this	pointer
->	O
display_mode	int
,	O
16	int
)	O
;	O
break	O
;	O
case	O
ENABLE_SIZE	int
:	O
case	O
ENABLE_ABBREVSIZE	int
:	O
case	O
ENABLE_MODE	int
:	O
panel_build_entry_field	function
(	O
this	pointer
,	O
entry	int
,	O
this	pointer
->	O
display_mode	int
,	O
11	int
)	O
;	O
break	O
;	O
case	O
ENABLE_FULL_NAME	int
:	O
break	O
;	O
case	O
ENABLE_ALL	int
:	O
if	O
(	O
this	pointer
->	O
columns	int
<	O
20	int
+	O
16	int
+	O
16	int
+	O
11	int
+	O
11	int
)	O
break	O
;	O
panel_build_entry_field	function
(	O
this	pointer
,	O
entry	int
,	O
ENABLE_OWNER_GROUP	int
,	O
16	int
+	O
16	int
+	O
11	int
+	O
11	int
)	O
;	O
panel_build_entry_field	function
(	O
this	pointer
,	O
entry	int
,	O
ENABLE_DATE_TIME	int
,	O
16	int
+	O
11	int
+	O
11	int
)	O
;	O
panel_build_entry_field	function
(	O
this	pointer
,	O
entry	int
,	O
ENABLE_SIZE	int
,	O
11	int
+	O
11	int
)	O
;	O
panel_build_entry_field	function
(	O
this	pointer
,	O
entry	int
,	O
ENABLE_MODE	int
,	O
11	int
)	O
;	O
break	O
;	O
default	O
:	O
fatal	function
(	O
"invalid mode"	pointer
)	O
;	O
}	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
)	O
this	pointer
->	O
temp	pointer
[	O
this	pointer
->	O
columns	int
-	O
3	int
]	O
=	O
'*'	O
;	O
if	O
(	O
entry	int
==	O
this	pointer
->	O
current_entry	int
)	O
this	pointer
->	O
temp	pointer
[	O
0	int
]	O
=	O
this	pointer
->	O
focus	char
?	O
ACTIVE_PANEL_MARKER	char
:	O
INACTIVE_PANEL_MARKER	char
;	O
if	O
(	O
TypeSensitivity	int
&&	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
!=	O
DIR_ENTRY	int
&&	O
!	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
)	O
{	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
entry	int
-	O
this	pointer
->	O
first_on_screen	int
+	O
1	int
,	O
1	int
)	O
;	O
brightness	char
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
?	O
PanelSelectedFileBrightness	O
:	O
PanelNotSelectedFileBrightness	O
;	O
foreground	char
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
?	O
PanelSelectedFile	O
:	O
PanelNotSelectedFile	O
;	O
if	O
(	O
entry	int
==	O
this	pointer
->	O
current_entry	int
&&	O
this	pointer
->	O
focus	char
==	O
ON	int
)	O
background	char
=	O
PanelCurrentFile	O
;	O
else	O
background	char
=	O
PanelBackground	O
;	O
tty_colors	function
(	O
brightness	char
,	O
foreground	char
,	O
background	char
)	O
;	O
window_putc	function
(	O
this	pointer
->	O
window	pointer
,	O
*	O
this	pointer
->	O
temp	pointer
)	O
;	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
fti_loaded	char
==	O
0	int
)	O
panel_load_fti	function
(	O
this	pointer
,	O
entry	int
)	O
;	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
brightness	char
!=	O
2	int
)	O
{	O
if	O
(	O
entry	int
==	O
this	pointer
->	O
current_entry	int
&&	O
this	pointer
->	O
focus	char
==	O
ON	int
)	O
tty_colors	function
(	O
brightness	char
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
foreground	char
,	O
background	char
)	O
;	O
else	O
tty_colors	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
brightness	char
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
foreground	char
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
background	char
)	O
;	O
}	O
window_puts	function
(	O
this	pointer
->	O
window	pointer
,	O
this	pointer
->	O
temp	pointer
+	O
1	int
,	O
len	long
+	O
1	int
)	O
;	O
window_puts	function
(	O
this	pointer
->	O
window	pointer
,	O
this	pointer
->	O
temp	pointer
+	O
1	int
+	O
len	long
+	O
1	int
,	O
this	pointer
->	O
columns	int
-	O
len	long
-	O
2	int
-	O
2	int
)	O
;	O
tty_colors	function
(	O
brightness	char
,	O
foreground	char
,	O
background	char
)	O
;	O
}	O
else	O
{	O
if	O
(	O
entry	int
==	O
this	pointer
->	O
current_entry	int
&&	O
this	pointer
->	O
focus	char
==	O
ON	int
)	O
{	O
foreground	char
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
?	O
PanelCurrentSelectedFile	O
:	O
PanelCurrentNotSelectedFile	O
;	O
background	char
=	O
PanelCurrentFile	O
;	O
}	O
else	O
{	O
foreground	char
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
?	O
PanelSelectedFile	O
:	O
PanelNotSelectedFile	O
;	O
background	char
=	O
PanelBackground	O
;	O
}	O
brightness	char
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
?	O
PanelSelectedFileBrightness	O
:	O
PanelNotSelectedFileBrightness	O
;	O
tty_colors	function
(	O
brightness	char
,	O
foreground	char
,	O
background	char
)	O
;	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
entry	int
-	O
this	pointer
->	O
first_on_screen	int
+	O
1	int
,	O
1	int
)	O
;	O
window_puts	function
(	O
this	pointer
->	O
window	pointer
,	O
this	pointer
->	O
temp	pointer
,	O
this	pointer
->	O
columns	int
-	O
2	int
)	O
;	O
}	O
}	O
void	O
panel_update_frame	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
int	O
line	long
;	O
tty_status_t	char
status	int
;	O
char	O
*	O
buf	pointer
=	O
xmalloc	function
(	O
this	pointer
->	O
columns	int
)	O
;	O
if	O
(	O
!	O
this	pointer
->	O
visible	char
)	O
return	O
;	O
tty_save	function
(	O
&	O
status	int
)	O
;	O
tty_colors	function
(	O
OFF	int
,	O
PanelFrame	O
,	O
PanelFrame	O
)	O
;	O
for	O
(	O
line	long
=	O
1	int
;	O
line	long
<	O
this	pointer
->	O
lines	int
-	O
1	int
;	O
line	long
++	O
)	O
{	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
line	long
,	O
0	int
)	O
;	O
window_putc	function
(	O
this	pointer
->	O
window	pointer
,	O
' '	O
)	O
;	O
}	O
for	O
(	O
line	long
=	O
1	int
;	O
line	long
<	O
this	pointer
->	O
lines	int
-	O
1	int
;	O
line	long
++	O
)	O
{	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
line	long
,	O
this	pointer
->	O
columns	int
-	O
1	int
)	O
;	O
window_putc	function
(	O
this	pointer
->	O
window	pointer
,	O
' '	O
)	O
;	O
}	O
memset	function
(	O
buf	pointer
,	O
' '	O
,	O
this	pointer
->	O
columns	int
)	O
;	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
0	int
,	O
0	int
)	O
;	O
window_puts	function
(	O
this	pointer
->	O
window	pointer
,	O
buf	pointer
,	O
this	pointer
->	O
columns	int
)	O
;	O
window_goto	function
(	O
this	pointer
->	O
window	pointer
,	O
this	pointer
->	O
lines	int
-	O
1	int
,	O
0	int
)	O
;	O
window_puts	function
(	O
this	pointer
->	O
window	pointer
,	O
buf	pointer
,	O
this	pointer
->	O
columns	int
)	O
;	O
xfree	function
(	O
buf	pointer
)	O
;	O
tty_restore	function
(	O
&	O
status	int
)	O
;	O
}	O
void	O
panel_update	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
assert	O
(	O
this	pointer
->	O
current_entry	int
<	O
this	pointer
->	O
entries	int
)	O
;	O
panel_update_frame	function
(	O
this	pointer
)	O
;	O
panel_update_path	function
(	O
this	pointer
)	O
;	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
panel_update_size	function
(	O
this	pointer
)	O
;	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
}	O
void	O
panel_set_focus	function
(	O
this	pointer
,	O
status	int
)	O
panel_t	struct
*	O
this	pointer
;	O
int	O
status	int
;	O
{	O
this	pointer
->	O
focus	char
=	O
status	int
;	O
panel_update_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
)	O
;	O
if	O
(	O
this	pointer
->	O
focus	char
)	O
if	O
(	O
chdir	function
(	O
this	pointer
->	O
path	pointer
)	O
==	O
-	O
1	int
)	O
{	O
panel_recover	function
(	O
this	pointer
)	O
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
}	O
}	O
void	O
panel_select_all	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
int	O
entry	int
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
==	O
0	int
&&	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
!=	O
DIR_ENTRY	int
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
1	int
;	O
this	pointer
->	O
selected_entries	int
++	O
;	O
}	O
}	O
void	O
panel_unselect_all	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
int	O
entry	int
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
0	int
;	O
this	pointer
->	O
selected_entries	int
=	O
0	int
;	O
}	O
char	O
*	O
panel_get_path	function
(	O
this	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
{	O
return	O
this	pointer
->	O
path	pointer
;	O
}	O
int	O
canceled	function
(	O
)	O
{	O
int	O
key	int
;	O
if	O
(	O
user_heart_attack	int
)	O
{	O
input_line_t	struct
*	O
saved_il	pointer
;	O
user_heart_attack	int
=	O
0	int
;	O
saved_il	pointer
=	O
il_save	function
(	O
)	O
;	O
key	int
=	O
panel_1s_message	O
(	O
"Abort current operation? "	pointer
,	O
"yn"	pointer
,	O
IL_FREEZED	int
|	O
IL_BEEP	int
)	O
;	O
il_restore	function
(	O
saved_il	pointer
)	O
;	O
il_update	function
(	O
)	O
;	O
il_update_point	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
return	O
(	O
key	int
==	O
'n'	O
||	O
key	int
==	O
'N'	O
)	O
?	O
0	int
:	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
same_file	function
(	O
file1	pointer
,	O
file2	pointer
)	O
char	O
*	O
file1	pointer
;	O
char	O
*	O
file2	pointer
;	O
{	O
struct	O
stat	struct
s1	struct
;	O
struct	O
stat	struct
s2	struct
;	O
if	O
(	O
xstat	function
(	O
file1	pointer
,	O
&	O
s1	struct
)	O
==	O
0	int
&&	O
xstat	function
(	O
file2	pointer
,	O
&	O
s2	struct
)	O
==	O
0	int
&&	O
s1	struct
.	O
st_dev	long
==	O
s2	struct
.	O
st_dev	long
&&	O
s1	struct
.	O
st_ino	long
==	O
s2	struct
.	O
st_ino	long
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
int	O
panel_warning	function
(	O
this	pointer
,	O
file	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
char	O
*	O
file	pointer
;	O
{	O
char	O
c	char
;	O
if	O
(	O
this	pointer
->	O
selected_entries	int
)	O
c	char
=	O
panel_2s_message	function
(	O
"%s: File exists. Overwrite/Skip/All/Cancel? "	pointer
,	O
file	pointer
,	O
"osac"	pointer
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
else	O
c	char
=	O
panel_2s_message	function
(	O
"%s: File exists. Overwrite/Cancel? "	pointer
,	O
file	pointer
,	O
"oc"	pointer
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
switch	O
(	O
c	char
)	O
{	O
case	O
'o'	O
:	O
return	O
WARN_OVERWRITE	int
;	O
case	O
'a'	O
:	O
if	O
(	O
this	pointer
->	O
selected_entries	int
)	O
{	O
this	pointer
->	O
chkdest	int
=	O
OFF	int
;	O
return	O
WARN_OVERWRITE	int
;	O
}	O
break	O
;	O
case	O
's'	O
:	O
if	O
(	O
this	pointer
->	O
selected_entries	int
)	O
return	O
WARN_SKIP	int
;	O
default	O
:	O
break	O
;	O
}	O
return	O
WARN_CANCEL	int
;	O
}	O
void	O
panel_unlink	function
(	O
name	pointer
)	O
char	O
*	O
name	pointer
;	O
{	O
struct	O
stat	struct
statbuf	struct
;	O
if	O
(	O
xstat	function
(	O
name	pointer
,	O
&	O
statbuf	struct
)	O
==	O
0	int
&&	O
S_ISREG	O
(	O
statbuf	struct
.	O
st_mode	int
)	O
)	O
unlink	function
(	O
name	pointer
)	O
;	O
}	O
char	O
*	O
copyerr	array
[	O
12	int
]	O
=	O
{	O
""	pointer
,	O
""	pointer
,	O
""	pointer
,	O
"cannot open source file"	pointer
,	O
"cannot read from source file"	pointer
,	O
"cannot create destination file"	pointer
,	O
"cannot write to destination file"	pointer
,	O
"not enough space on device"	pointer
,	O
"unknown error"	pointer
,	O
"cannot stat destination file"	pointer
,	O
"cannot copy a directory to a non-directory"	pointer
,	O
"cp was interrupted by a signal"	pointer
,	O
}	O
;	O
static	O
int	O
panel_percent	function
(	O
x	int
,	O
total	long
)	O
off64_t	long
x	int
;	O
off64_t	long
total	long
;	O
{	O
if	O
(	O
total	long
==	O
0	int
)	O
return	O
0	int
;	O
return	O
(	O
total	long
>=	O
100000	int
)	O
?	O
(	O
x	int
/	O
(	O
total	long
/	O
100	int
)	O
)	O
:	O
(	O
(	O
x	int
*	O
100	int
)	O
/	O
total	long
)	O
;	O
}	O
int	O
panel_copy	function
(	O
this	pointer
,	O
src	pointer
,	O
dest	pointer
,	O
mode	int
,	O
uid	int
,	O
gid	int
)	O
panel_t	struct
*	O
this	pointer
;	O
char	O
*	O
src	pointer
;	O
char	O
*	O
dest	pointer
;	O
mode_t	int
mode	int
;	O
uid_t	int
uid	int
;	O
gid_t	int
gid	int
;	O
{	O
size_t	long
len	long
;	O
int	O
sfd	int
,	O
dfd	int
,	O
error	int
;	O
off64_t	long
flen	long
,	O
n	long
,	O
memsize	long
;	O
struct	O
stat	struct
dest_statbuf	struct
;	O
char	O
*	O
buf	pointer
,	O
*	O
dest_file	pointer
,	O
*	O
msg	pointer
;	O
int	O
bytes_transferred	int
,	O
bytes_to_transfer	int
;	O
if	O
(	O
S_ISLNK	O
(	O
mode	int
)	O
)	O
{	O
struct	O
stat	struct
s_tmp	struct
;	O
if	O
(	O
xstat	function
(	O
src	pointer
,	O
&	O
s_tmp	struct
)	O
!=	O
-	O
1	int
)	O
{	O
mode	int
=	O
s_tmp	struct
.	O
st_mode	int
;	O
}	O
}	O
if	O
(	O
S_ISDIR	O
(	O
mode	int
)	O
)	O
{	O
int	O
result	int
;	O
char	O
*	O
temp	pointer
;	O
if	O
(	O
xstat	function
(	O
dest	pointer
,	O
&	O
dest_statbuf	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
S_ISDIR	O
(	O
dest_statbuf	struct
.	O
st_mode	int
)	O
)	O
return	O
SD_INVAL	int
;	O
temp	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
dest	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
src	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
temp	pointer
,	O
"%s/%s"	pointer
,	O
dest	pointer
,	O
src	pointer
)	O
;	O
if	O
(	O
this	pointer
->	O
chkdest	int
&&	O
access	function
(	O
temp	pointer
,	O
0	int
)	O
==	O
0	int
)	O
{	O
status_default	function
(	O
)	O
;	O
error	int
=	O
panel_warning	function
(	O
this	pointer
,	O
temp	pointer
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
temp	pointer
)	O
;	O
if	O
(	O
error	int
)	O
return	O
error	int
;	O
}	O
else	O
xfree	function
(	O
temp	pointer
)	O
;	O
}	O
temp	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
src	pointer
)	O
+	O
strlen	function
(	O
dest	pointer
)	O
+	O
1	int
)	O
;	O
dest_file	pointer
=	O
xbasename	function
(	O
dest	pointer
)	O
;	O
if	O
(	O
*	O
dest_file	pointer
==	O
'\0'	O
)	O
return	O
D_CREATERR	int
;	O
msg	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
src	pointer
)	O
+	O
strlen	function
(	O
dest	pointer
)	O
)	O
;	O
sprintf	function
(	O
msg	pointer
,	O
"(COPY) cp -r \"%s\" \"%s\""	pointer
,	O
src	pointer
,	O
dest	pointer
)	O
;	O
status	int
(	O
msg	pointer
,	O
STATUS_WARNING	int
,	O
STATUS_LEFT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
sprintf	function
(	O
temp	pointer
,	O
"cp -r \"%s\" \"%s\""	pointer
,	O
src	pointer
,	O
dest	pointer
)	O
;	O
result	int
=	O
start	function
(	O
temp	pointer
,	O
1	int
)	O
;	O
xfree	function
(	O
temp	pointer
)	O
;	O
tty_update_title	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
result	int
)	O
)	O
{	O
return	O
SD_INTERRUPTED	int
;	O
}	O
if	O
(	O
WIFEXITED	O
(	O
result	int
)	O
&&	O
(	O
WEXITSTATUS	O
(	O
result	int
)	O
!=	O
0	int
)	O
)	O
{	O
display_errors	function
(	O
"cp"	pointer
)	O
;	O
return	O
SD_UNKNOWN	int
;	O
}	O
return	O
SD_OK	O
;	O
}	O
len	long
=	O
strlen	function
(	O
dest	pointer
)	O
;	O
dest	pointer
=	O
xstrdup	function
(	O
dest	pointer
)	O
;	O
if	O
(	O
xstat	function
(	O
dest	pointer
,	O
&	O
dest_statbuf	struct
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
dest_statbuf	struct
.	O
st_mode	int
)	O
)	O
{	O
dest	pointer
=	O
xrealloc	function
(	O
dest	pointer
,	O
len	long
+	O
1	int
+	O
strlen	function
(	O
src	pointer
)	O
+	O
1	int
)	O
;	O
strcat	function
(	O
dest	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
dest	pointer
,	O
src	pointer
)	O
;	O
}	O
dest_file	pointer
=	O
xbasename	function
(	O
dest	pointer
)	O
;	O
if	O
(	O
*	O
dest_file	pointer
==	O
'\0'	O
)	O
{	O
xfree	function
(	O
dest	pointer
)	O
;	O
return	O
D_CREATERR	int
;	O
}	O
if	O
(	O
this	pointer
->	O
chkdest	int
&&	O
(	O
access	function
(	O
dest	pointer
,	O
0	int
)	O
==	O
0	int
)	O
)	O
{	O
status_default	function
(	O
)	O
;	O
error	int
=	O
panel_warning	function
(	O
this	pointer
,	O
dest_file	pointer
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
error	int
)	O
return	O
error	int
;	O
}	O
msg	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
src	pointer
)	O
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
mode	int
)	O
)	O
sprintf	function
(	O
msg	pointer
,	O
"(COPY) [  0%%] %s"	pointer
,	O
src	pointer
)	O
;	O
else	O
sprintf	function
(	O
msg	pointer
,	O
"(COPY) [0 bytes] %s"	pointer
,	O
src	pointer
)	O
;	O
status	int
(	O
msg	pointer
,	O
STATUS_WARNING	int
,	O
STATUS_LEFT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
(	O
sfd	int
=	O
open64	function
(	O
src	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
==	O
-	O
1	int
)	O
return	O
S_OPENERR	int
;	O
if	O
(	O
this	pointer
->	O
msdosfs	int
)	O
mode	int
&=	O
~	O
0111	int
;	O
if	O
(	O
(	O
dfd	int
=	O
creat	function
(	O
dest	pointer
,	O
mode	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
close	pointer
(	O
sfd	int
)	O
;	O
xfree	function
(	O
dest	pointer
)	O
;	O
return	O
D_CREATERR	int
;	O
}	O
memsize	long
=	O
min	O
(	O
flen	long
=	O
get_file_length	function
(	O
sfd	int
)	O
,	O
COPY_BUFFER_SIZE	O
)	O
;	O
if	O
(	O
S_ISBLK	O
(	O
mode	int
)	O
||	O
S_ISCHR	O
(	O
mode	int
)	O
)	O
{	O
flen	long
=	O
MAXFILESIZE	O
;	O
memsize	long
=	O
COPY_BUFFER_SIZE	O
;	O
}	O
if	O
(	O
flen	long
==	O
0	int
)	O
{	O
if	O
(	O
getuid	function
(	O
)	O
==	O
0	int
)	O
chown	function
(	O
dest	pointer
,	O
uid	int
,	O
gid	int
)	O
;	O
close2	O
(	O
sfd	int
,	O
dfd	int
)	O
;	O
xfree	function
(	O
dest	pointer
)	O
;	O
return	O
SD_OK	O
;	O
}	O
buf	pointer
=	O
xmalloc	function
(	O
memsize	long
)	O
;	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
flen	long
;	O
n	long
+=	O
COPY_BUFFER_SIZE	O
)	O
{	O
bytes_to_transfer	int
=	O
min	O
(	O
flen	long
-	O
n	long
,	O
memsize	long
)	O
;	O
if	O
(	O
canceled	function
(	O
)	O
)	O
{	O
close2	O
(	O
sfd	int
,	O
dfd	int
)	O
;	O
panel_unlink	function
(	O
dest	pointer
)	O
;	O
xfree2	O
(	O
buf	pointer
,	O
dest	pointer
)	O
;	O
return	O
SD_CANCEL	O
;	O
}	O
signals	function
(	O
ON	int
)	O
;	O
bytes_transferred	int
=	O
xread	function
(	O
sfd	int
,	O
buf	pointer
,	O
bytes_to_transfer	int
)	O
;	O
signals	function
(	O
OFF	int
)	O
;	O
if	O
(	O
bytes_transferred	int
!=	O
bytes_to_transfer	int
)	O
{	O
if	O
(	O
bytes_transferred	int
>=	O
0	int
)	O
{	O
if	O
(	O
bytes_transferred	int
)	O
bytes_to_transfer	int
=	O
bytes_transferred	int
;	O
else	O
{	O
if	O
(	O
getuid	function
(	O
)	O
==	O
0	int
)	O
chown	function
(	O
dest	pointer
,	O
uid	int
,	O
gid	int
)	O
;	O
close2	O
(	O
sfd	int
,	O
dfd	int
)	O
;	O
xfree2	O
(	O
buf	pointer
,	O
dest	pointer
)	O
;	O
return	O
SD_OK	O
;	O
}	O
}	O
else	O
{	O
close2	O
(	O
sfd	int
,	O
dfd	int
)	O
;	O
panel_unlink	function
(	O
dest	pointer
)	O
;	O
xfree2	O
(	O
buf	pointer
,	O
dest	pointer
)	O
;	O
return	O
S_READERR	int
;	O
}	O
}	O
if	O
(	O
canceled	function
(	O
)	O
)	O
{	O
close2	O
(	O
sfd	int
,	O
dfd	int
)	O
;	O
panel_unlink	function
(	O
dest	pointer
)	O
;	O
xfree2	O
(	O
buf	pointer
,	O
dest	pointer
)	O
;	O
return	O
SD_CANCEL	O
;	O
}	O
bytes_transferred	int
=	O
xwrite	function
(	O
dfd	int
,	O
buf	pointer
,	O
bytes_to_transfer	int
)	O
;	O
if	O
(	O
bytes_transferred	int
!=	O
bytes_to_transfer	int
)	O
{	O
int	O
safe_errno	int
=	O
errno	O
;	O
close2	O
(	O
sfd	int
,	O
dfd	int
)	O
;	O
panel_unlink	function
(	O
dest	pointer
)	O
;	O
xfree2	O
(	O
buf	pointer
,	O
dest	pointer
)	O
;	O
return	O
(	O
bytes_transferred	int
>	O
0	int
)	O
?	O
SD_NOSPACE	int
:	O
(	O
(	O
safe_errno	int
==	O
ENOSPC	int
)	O
?	O
SD_NOSPACE	int
:	O
D_WRITEERR	int
)	O
;	O
}	O
if	O
(	O
n	long
+	O
bytes_to_transfer	int
<=	O
flen	long
)	O
{	O
msg	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
src	pointer
)	O
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
mode	int
)	O
)	O
sprintf	function
(	O
msg	pointer
,	O
"(COPY) [%3d%%] %s"	pointer
,	O
panel_percent	function
(	O
n	long
+	O
bytes_to_transfer	int
,	O
flen	long
)	O
,	O
src	pointer
)	O
;	O
else	O
{	O
sprintf	function
(	O
msg	pointer
,	O
"(COPY) [%Ld bytes] %s"	pointer
,	O
(	O
long	O
long	O
)	O
(	O
n	long
+	O
bytes_to_transfer	int
)	O
,	O
src	pointer
)	O
;	O
}	O
status	int
(	O
msg	pointer
,	O
STATUS_WARNING	int
,	O
STATUS_LEFT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
}	O
}	O
if	O
(	O
getuid	function
(	O
)	O
==	O
0	int
)	O
chown	function
(	O
dest	pointer
,	O
uid	int
,	O
gid	int
)	O
;	O
close2	O
(	O
sfd	int
,	O
dfd	int
)	O
;	O
xfree2	O
(	O
buf	pointer
,	O
dest	pointer
)	O
;	O
return	O
SD_OK	O
;	O
}	O
char	O
*	O
moveerr	array
[	O
12	int
]	O
=	O
{	O
""	pointer
,	O
""	pointer
,	O
""	pointer
,	O
"cannot create destination file"	pointer
,	O
"cannot remove source file"	pointer
,	O
"cannot stat source file"	pointer
,	O
"cannot stat destination directory"	pointer
,	O
"unknown error"	pointer
,	O
"cannot copy a directory to a non-directory"	pointer
,	O
"not enough space on device"	pointer
,	O
"cannot copy file"	pointer
,	O
"mv was interrupted by a signal"	pointer
,	O
}	O
;	O
int	O
panel_move	function
(	O
this	pointer
,	O
from	pointer
,	O
to	pointer
,	O
mode	int
)	O
panel_t	struct
*	O
this	pointer
;	O
char	O
*	O
from	pointer
,	O
*	O
to	pointer
;	O
mode_t	int
mode	int
;	O
{	O
int	O
error	int
;	O
size_t	long
len	long
;	O
struct	O
stat	struct
to_statbuf	struct
;	O
struct	O
stat	struct
from_statbuf	struct
;	O
char	O
*	O
to_file	pointer
,	O
*	O
msg	pointer
;	O
if	O
(	O
S_ISDIR	O
(	O
mode	int
)	O
)	O
{	O
int	O
result	int
;	O
char	O
*	O
temp	pointer
;	O
if	O
(	O
xstat	function
(	O
to	pointer
,	O
&	O
to_statbuf	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
S_ISDIR	O
(	O
to_statbuf	struct
.	O
st_mode	int
)	O
)	O
return	O
FT_INVAL	int
;	O
temp	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
to	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
from	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
temp	pointer
,	O
"%s/%s"	pointer
,	O
to	pointer
,	O
from	pointer
)	O
;	O
if	O
(	O
this	pointer
->	O
chkdest	int
&&	O
access	function
(	O
temp	pointer
,	O
0	int
)	O
==	O
0	int
)	O
{	O
status_default	function
(	O
)	O
;	O
error	int
=	O
panel_warning	function
(	O
this	pointer
,	O
temp	pointer
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
temp	pointer
)	O
;	O
if	O
(	O
error	int
)	O
return	O
error	int
;	O
}	O
else	O
xfree	function
(	O
temp	pointer
)	O
;	O
}	O
temp	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
from	pointer
)	O
+	O
strlen	function
(	O
to	pointer
)	O
+	O
1	int
)	O
;	O
to_file	pointer
=	O
xbasename	function
(	O
to	pointer
)	O
;	O
if	O
(	O
*	O
to_file	pointer
==	O
'\0'	O
)	O
return	O
T_CREATERR	int
;	O
msg	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
from	pointer
)	O
+	O
strlen	function
(	O
to	pointer
)	O
)	O
;	O
sprintf	function
(	O
msg	pointer
,	O
"(MOVE) mv -f \"%s\" \"%s\""	pointer
,	O
from	pointer
,	O
to	pointer
)	O
;	O
status	int
(	O
msg	pointer
,	O
STATUS_WARNING	int
,	O
STATUS_LEFT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
sprintf	function
(	O
temp	pointer
,	O
"mv -f \"%s\" \"%s\""	pointer
,	O
from	pointer
,	O
to	pointer
)	O
;	O
result	int
=	O
start	function
(	O
temp	pointer
,	O
1	int
)	O
;	O
xfree	function
(	O
temp	pointer
)	O
;	O
tty_update_title	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
result	int
)	O
)	O
return	O
FT_INTERRUPTED	int
;	O
if	O
(	O
WIFEXITED	O
(	O
result	int
)	O
)	O
{	O
if	O
(	O
WEXITSTATUS	O
(	O
result	int
)	O
!=	O
0	int
)	O
{	O
display_errors	function
(	O
"mv"	pointer
)	O
;	O
return	O
FT_UNKNOWN	int
;	O
}	O
return	O
FT_OK	O
;	O
}	O
return	O
FT_UNKNOWN	int
;	O
}	O
len	long
=	O
strlen	function
(	O
to	pointer
)	O
;	O
to	pointer
=	O
xstrdup	function
(	O
to	pointer
)	O
;	O
if	O
(	O
xstat	function
(	O
to	pointer
,	O
&	O
to_statbuf	struct
)	O
==	O
0	int
&&	O
S_ISDIR	O
(	O
to_statbuf	struct
.	O
st_mode	int
)	O
)	O
{	O
to	pointer
=	O
xrealloc	function
(	O
to	pointer
,	O
len	long
+	O
1	int
+	O
strlen	function
(	O
from	pointer
)	O
+	O
1	int
)	O
;	O
strcat	function
(	O
to	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
to	pointer
,	O
from	pointer
)	O
;	O
}	O
to_file	pointer
=	O
xbasename	function
(	O
to	pointer
)	O
;	O
if	O
(	O
*	O
to_file	pointer
==	O
'\0'	O
)	O
{	O
xfree	function
(	O
to	pointer
)	O
;	O
return	O
T_CREATERR	int
;	O
}	O
if	O
(	O
to_file	pointer
==	O
to	pointer
)	O
{	O
char	O
*	O
temp	pointer
=	O
xmalloc	function
(	O
2	int
+	O
(	O
len	long
=	O
strlen	function
(	O
to	pointer
)	O
)	O
+	O
1	int
)	O
;	O
temp	pointer
[	O
0	int
]	O
=	O
'.'	O
;	O
temp	pointer
[	O
1	int
]	O
=	O
'/'	O
;	O
memcpy	function
(	O
temp	pointer
+	O
2	int
,	O
to	pointer
,	O
len	long
+	O
1	int
)	O
;	O
xfree	function
(	O
to	pointer
)	O
;	O
to	pointer
=	O
temp	pointer
;	O
to_file	pointer
=	O
to	pointer
+	O
2	int
;	O
}	O
if	O
(	O
this	pointer
->	O
chkdest	int
&&	O
(	O
access	function
(	O
to	pointer
,	O
0	int
)	O
==	O
0	int
)	O
)	O
{	O
status_default	function
(	O
)	O
;	O
error	int
=	O
panel_warning	function
(	O
this	pointer
,	O
to_file	pointer
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
error	int
)	O
return	O
error	int
;	O
}	O
msg	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
from	pointer
)	O
)	O
;	O
sprintf	function
(	O
msg	pointer
,	O
"(MOVE) %s"	pointer
,	O
from	pointer
)	O
;	O
status	int
(	O
msg	pointer
,	O
STATUS_WARNING	int
,	O
STATUS_LEFT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
xstat	function
(	O
from	pointer
,	O
&	O
from_statbuf	struct
)	O
==	O
-	O
1	int
)	O
return	O
F_STATERR	int
;	O
if	O
(	O
xstat	function
(	O
to	pointer
,	O
&	O
to_statbuf	struct
)	O
==	O
-	O
1	int
)	O
{	O
char	O
c	char
=	O
*	O
(	O
to_file	pointer
-	O
1	int
)	O
;	O
*	O
(	O
to_file	pointer
-	O
1	int
)	O
=	O
0	int
;	O
error	int
=	O
(	O
*	O
to	pointer
)	O
?	O
xstat	function
(	O
to	pointer
,	O
&	O
to_statbuf	struct
)	O
:	O
xstat	function
(	O
"/"	pointer
,	O
&	O
to_statbuf	struct
)	O
;	O
*	O
(	O
to_file	pointer
-	O
1	int
)	O
=	O
c	char
;	O
if	O
(	O
error	int
==	O
-	O
1	int
)	O
return	O
T_STATERR	int
;	O
}	O
if	O
(	O
to_statbuf	struct
.	O
st_dev	long
!=	O
from_statbuf	struct
.	O
st_dev	long
||	O
this	pointer
->	O
msdosfs	int
)	O
{	O
error	int
=	O
panel_copy	function
(	O
this	pointer
,	O
from	pointer
,	O
to	pointer
,	O
from_statbuf	struct
.	O
st_mode	int
,	O
from_statbuf	struct
.	O
st_uid	int
,	O
from_statbuf	struct
.	O
st_gid	int
)	O
;	O
switch	O
(	O
error	int
)	O
{	O
case	O
SD_OK	O
:	O
goto	O
remove_from	O
;	O
case	O
SD_CANCEL	O
:	O
return	O
FT_CANCEL	O
;	O
case	O
SD_SKIP	O
:	O
return	O
FT_SKIP	O
;	O
case	O
SD_NOSPACE	int
:	O
return	O
FT_NOSPACE	int
;	O
default	O
:	O
panel_3s_message	function
(	O
"%s: Copy failed, %s."	pointer
,	O
from	pointer
,	O
copyerr	array
[	O
error	int
-	O
1	int
]	O
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_ERROR	int
)	O
;	O
return	O
FT_COPY	int
;	O
}	O
}	O
service_pending_signals	function
(	O
)	O
;	O
if	O
(	O
S_ISREG	O
(	O
to_statbuf	struct
.	O
st_mode	int
)	O
||	O
S_ISDIR	O
(	O
to_statbuf	struct
.	O
st_mode	int
)	O
)	O
{	O
unlink	function
(	O
to	pointer
)	O
;	O
if	O
(	O
link	function
(	O
from	pointer
,	O
to	pointer
)	O
==	O
-	O
1	int
)	O
return	O
T_CREATERR	int
;	O
}	O
remove_from	O
:	O
if	O
(	O
unlink	function
(	O
from	pointer
)	O
==	O
-	O
1	int
)	O
return	O
F_DELETERR	int
;	O
return	O
FT_OK	O
;	O
}	O
int	O
panel_find_index	function
(	O
this	pointer
,	O
str	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
char	O
*	O
str	pointer
;	O
{	O
int	O
entry	int
;	O
size_t	long
len	long
=	O
strlen	function
(	O
str	pointer
)	O
;	O
char	O
*	O
temp	pointer
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
len	long
=	O
min	O
(	O
len	long
,	O
(	O
size_t	long
)	O
this	pointer
->	O
maxname	int
)	O
;	O
strncpy	function
(	O
temp	pointer
,	O
str	pointer
,	O
len	long
)	O
;	O
temp	pointer
[	O
len	long
]	O
=	O
0	int
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
temp	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
entry	int
!=	O
this	pointer
->	O
entries	int
)	O
goto	O
done	O
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
strcasecmp	function
(	O
temp	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
entry	int
!=	O
this	pointer
->	O
entries	int
)	O
goto	O
done	O
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
strncmp	function
(	O
temp	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
,	O
min	O
(	O
len	long
,	O
strlen	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
)	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
entry	int
!=	O
this	pointer
->	O
entries	int
)	O
goto	O
done	O
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
strncasecmp	function
(	O
temp	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
,	O
min	O
(	O
len	long
,	O
strlen	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
)	O
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
entry	int
==	O
this	pointer
->	O
entries	int
)	O
entry	int
=	O
0	int
;	O
done	O
:	O
xfree	function
(	O
temp	pointer
)	O
;	O
return	O
entry	int
;	O
}	O
extern	O
int	O
wait_msg	int
;	O
extern	O
char	O
*	O
screen	pointer
;	O
int	O
panel_act_ENTER	function
(	O
this	pointer
,	O
other	pointer
)	O
panel_t	struct
*	O
this	pointer
,	O
*	O
other	pointer
;	O
{	O
int	O
back	int
;	O
char	O
*	O
old_path	pointer
,	O
*	O
cmd	pointer
,	O
*	O
old_entry_name	pointer
;	O
char	O
*	O
name	pointer
=	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
;	O
switch	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
type	enum
)	O
{	O
case	O
DIR_ENTRY	int
:	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
".."	pointer
)	O
==	O
0	int
&&	O
strcmp	function
(	O
this	pointer
->	O
path	pointer
,	O
"/"	pointer
)	O
==	O
0	int
)	O
break	O
;	O
back	int
=	O
(	O
strcmp	function
(	O
name	pointer
,	O
".."	pointer
)	O
==	O
0	int
)	O
?	O
1	int
:	O
0	int
;	O
old_path	pointer
=	O
xmalloc	function
(	O
this	pointer
->	O
pathlen	long
+	O
1	int
)	O
;	O
strcpy	function
(	O
old_path	pointer
,	O
this	pointer
->	O
path	pointer
)	O
;	O
if	O
(	O
!	O
panel_read_directory	function
(	O
this	pointer
,	O
name	pointer
,	O
ON	int
)	O
)	O
{	O
if	O
(	O
back	int
)	O
{	O
panel_recover	function
(	O
this	pointer
)	O
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
}	O
else	O
panel_2s_message	function
(	O
"%s/: Permission denied."	pointer
,	O
name	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_FREEZED	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
break	O
;	O
}	O
if	O
(	O
back	int
)	O
{	O
int	O
index	function
;	O
old_entry_name	pointer
=	O
strrchr	function
(	O
old_path	pointer
,	O
'/'	O
)	O
;	O
assert	O
(	O
old_entry_name	pointer
)	O
;	O
index	function
=	O
panel_find_index	function
(	O
this	pointer
,	O
++	O
old_entry_name	pointer
)	O
;	O
panel_set_current_entry	function
(	O
this	pointer
,	O
index	function
)	O
;	O
}	O
else	O
panel_set_current_entry	function
(	O
this	pointer
,	O
0	int
)	O
;	O
xfree	function
(	O
old_path	pointer
)	O
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
this	pointer
->	O
path	pointer
,	O
other	pointer
->	O
path	pointer
)	O
==	O
0	int
)	O
{	O
panel_action	function
(	O
other	pointer
,	O
act_REGET	int
,	O
this	pointer
,	O
(	O
void	O
*	O
)	O
-	O
1	int
,	O
1	int
)	O
;	O
panel_update	function
(	O
other	pointer
)	O
;	O
}	O
else	O
panel_update_size	function
(	O
other	pointer
)	O
;	O
break	O
;	O
case	O
FILE_ENTRY	int
:	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
executable	char
)	O
{	O
cmd	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
cmd	pointer
,	O
"./\"%s\""	pointer
,	O
name	pointer
)	O
;	O
start	function
(	O
cmd	pointer
,	O
0	int
)	O
;	O
wait_msg	int
=	O
1	int
;	O
xfree	function
(	O
cmd	pointer
)	O
;	O
tty_touch	function
(	O
)	O
;	O
tty_get_screen	function
(	O
screen	pointer
)	O
;	O
panel_no_optimizations	function
(	O
this	pointer
)	O
;	O
panel_no_optimizations	function
(	O
other	pointer
)	O
;	O
il_insert_text	function
(	O
name	pointer
)	O
;	O
tty_update_title	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
return	O
1	int
;	O
}	O
break	O
;	O
}	O
return	O
0	int
;	O
}	O
void	O
panel_act_COPY	function
(	O
this	pointer
,	O
other	pointer
)	O
panel_t	struct
*	O
this	pointer
,	O
*	O
other	pointer
;	O
{	O
size_t	long
len	long
;	O
int	O
error	int
,	O
entry	int
;	O
char	O
*	O
file	pointer
,	O
*	O
dir	pointer
=	O
NULL	O
,	O
*	O
msg	pointer
,	O
*	O
input	pointer
=	O
NULL	O
,	O
*	O
tmp_input	pointer
;	O
this	pointer
->	O
chkdest	int
=	O
ON	int
;	O
if	O
(	O
this	pointer
->	O
selected_entries	int
==	O
0	int
)	O
{	O
char	O
*	O
name	pointer
=	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
;	O
if	O
(	O
this	pointer
->	O
current_entry	int
==	O
0	int
&&	O
!	O
rootdir	O
(	O
)	O
)	O
return	O
;	O
msg	pointer
=	O
xmalloc	function
(	O
16	int
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
msg	pointer
,	O
"Copy %s to: "	pointer
,	O
cutname	function
(	O
name	pointer
,	O
0	int
,	O
0	int
)	O
)	O
;	O
len	long
=	O
1	int
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
file	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
other	pointer
->	O
path	pointer
)	O
+	O
len	long
)	O
;	O
sprintf	function
(	O
file	pointer
,	O
"%s/%s"	pointer
,	O
other	pointer
->	O
path	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
il_read_line	function
(	O
msg	pointer
,	O
&	O
input	pointer
,	O
file	pointer
,	O
copy_history	pointer
)	O
)	O
{	O
xfree	function
(	O
msg	pointer
)	O
;	O
return	O
;	O
}	O
xfree	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
mode	int
)	O
)	O
il_message	function
(	O
PANEL_COPY_DIR_MSG	O
)	O
;	O
else	O
il_message	function
(	O
PANEL_COPY_FILE_MSG	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
tmp_input	pointer
=	O
tilde_expand	function
(	O
input	pointer
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
input	pointer
=	O
tmp_input	pointer
;	O
error	int
=	O
same_file	function
(	O
name	pointer
,	O
input	pointer
)	O
;	O
xfree	function
(	O
file	pointer
)	O
;	O
if	O
(	O
error	int
)	O
{	O
panel_3s_message	function
(	O
"%s and %s point to the same file."	pointer
,	O
name	pointer
,	O
input	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
return	O
;	O
}	O
error	int
=	O
panel_copy	function
(	O
this	pointer
,	O
name	pointer
,	O
input	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
mode	int
,	O
getuid	function
(	O
)	O
,	O
getgid	function
(	O
)	O
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
if	O
(	O
error	int
!=	O
SD_OK	O
&&	O
error	int
!=	O
SD_CANCEL	O
)	O
panel_3s_message	function
(	O
"%s: Copy failed, %s."	pointer
,	O
name	pointer
,	O
copyerr	array
[	O
error	int
-	O
1	int
]	O
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
status_default	function
(	O
)	O
;	O
panel_update_size	function
(	O
this	pointer
)	O
;	O
panel_update_size	function
(	O
other	pointer
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
il_read_line	function
(	O
"Copy selected file(s) to: "	pointer
,	O
&	O
dir	pointer
,	O
other	pointer
->	O
path	pointer
,	O
copy_history	pointer
)	O
)	O
return	O
;	O
if	O
(	O
same_file	function
(	O
this	pointer
->	O
path	pointer
,	O
dir	pointer
)	O
)	O
{	O
panel_1s_message	O
(	O
nice_try	array
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_FREEZED	int
|	O
IL_BEEP	int
|	O
IL_ERROR	int
)	O
;	O
return	O
;	O
}	O
dir	pointer
=	O
xrealloc	function
(	O
dir	pointer
,	O
(	O
len	long
=	O
strlen	function
(	O
dir	pointer
)	O
+	O
1	int
)	O
+	O
1	int
)	O
;	O
dir	pointer
[	O
len	long
-	O
1	int
]	O
=	O
'/'	O
;	O
dir	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
panel_init_iterator	function
(	O
this	pointer
)	O
;	O
while	O
(	O
(	O
entry	int
=	O
panel_get_next	function
(	O
this	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
char	O
*	O
name	pointer
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
;	O
mode_t	int
mode	int
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
mode	int
;	O
uid_t	int
uid	int
=	O
getuid	function
(	O
)	O
;	O
gid_t	int
gid	int
=	O
getgid	function
(	O
)	O
;	O
dir	pointer
=	O
xrealloc	function
(	O
dir	pointer
,	O
len	long
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
dir	pointer
+	O
len	long
,	O
name	pointer
)	O
;	O
if	O
(	O
canceled	function
(	O
)	O
)	O
break	O
;	O
il_message	function
(	O
PANEL_COPY_FILES_MSG	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
error	int
=	O
panel_copy	function
(	O
this	pointer
,	O
name	pointer
,	O
dir	pointer
,	O
mode	int
,	O
uid	int
,	O
gid	int
)	O
;	O
if	O
(	O
error	int
!=	O
SD_OK	O
)	O
{	O
if	O
(	O
error	int
==	O
SD_CANCEL	O
)	O
break	O
;	O
if	O
(	O
error	int
==	O
SD_SKIP	O
)	O
continue	O
;	O
if	O
(	O
panel_3s_message	function
(	O
"%s: Copy failed, %s."	pointer
,	O
name	pointer
,	O
copyerr	array
[	O
error	int
-	O
1	int
]	O
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_ERROR	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
else	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
0	int
;	O
panel_update_size	function
(	O
this	pointer
)	O
;	O
panel_update_size	function
(	O
other	pointer
)	O
;	O
}	O
if	O
(	O
dir	pointer
)	O
xfree	function
(	O
dir	pointer
)	O
;	O
status_default	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
panel_read_directory	function
(	O
other	pointer
,	O
other	pointer
->	O
path	pointer
,	O
ON	int
)	O
)	O
panel_recover	function
(	O
other	pointer
)	O
;	O
panel_update	function
(	O
other	pointer
)	O
;	O
if	O
(	O
!	O
panel_read_directory	function
(	O
this	pointer
,	O
this	pointer
->	O
path	pointer
,	O
ON	int
)	O
)	O
panel_recover	function
(	O
this	pointer
)	O
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
}	O
void	O
panel_act_DELETE	function
(	O
this	pointer
,	O
other	pointer
)	O
panel_t	struct
*	O
this	pointer
,	O
*	O
other	pointer
;	O
{	O
char	O
*	O
msg	pointer
;	O
char	O
*	O
command	pointer
;	O
int	O
keep_asking	int
=	O
1	int
;	O
int	O
first_entry	int
,	O
entry	int
,	O
answer	int
=	O
0	int
,	O
result	int
;	O
if	O
(	O
this	pointer
->	O
selected_entries	int
==	O
0	int
&&	O
(	O
this	pointer
->	O
current_entry	int
==	O
0	int
&&	O
!	O
rootdir	O
(	O
)	O
)	O
)	O
return	O
;	O
if	O
(	O
panel_1s_message	O
(	O
"Delete selected entries? "	pointer
,	O
"yn"	pointer
,	O
IL_FREEZED	int
)	O
!=	O
'y'	O
)	O
return	O
;	O
for	O
(	O
first_entry	int
=	O
0	int
;	O
first_entry	int
<	O
this	pointer
->	O
entries	int
;	O
first_entry	int
++	O
)	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
first_entry	int
]	O
.	O
selected	char
)	O
break	O
;	O
panel_init_iterator	function
(	O
this	pointer
)	O
;	O
while	O
(	O
(	O
entry	int
=	O
panel_get_next	function
(	O
this	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
char	O
*	O
name	pointer
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
;	O
int	O
interrupted	int
=	O
0	int
;	O
service_pending_signals	function
(	O
)	O
;	O
msg	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
name	pointer
)	O
)	O
;	O
sprintf	function
(	O
msg	pointer
,	O
"(DELETE) %s"	pointer
,	O
name	pointer
)	O
;	O
status	int
(	O
msg	pointer
,	O
STATUS_ERROR	int
,	O
STATUS_LEFT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
canceled	function
(	O
)	O
)	O
break	O
;	O
if	O
(	O
keep_asking	int
)	O
answer	int
=	O
panel_2s_message	function
(	O
"Delete %s? (Yes/Skip/All/Cancel) "	pointer
,	O
name	pointer
,	O
"ysac"	pointer
,	O
IL_MOVE	int
)	O
;	O
il_message	function
(	O
PANEL_DELETE_FILES_MSG	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
answer	int
==	O
'a'	O
)	O
keep_asking	int
=	O
0	int
;	O
else	O
if	O
(	O
answer	int
==	O
's'	O
)	O
continue	O
;	O
else	O
if	O
(	O
answer	int
==	O
'c'	O
)	O
break	O
;	O
else	O
if	O
(	O
answer	int
!=	O
'y'	O
)	O
break	O
;	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
==	O
DIR_ENTRY	int
)	O
{	O
il_message	function
(	O
PANEL_DELETE_DIR_MSG	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
result	int
=	O
(	O
rmdir	function
(	O
name	pointer
)	O
==	O
0	int
)	O
;	O
if	O
(	O
!	O
result	int
)	O
{	O
if	O
(	O
panel_2s_message	function
(	O
"%s/: directory might contain files.  Delete? "	pointer
,	O
name	pointer
,	O
"yn"	pointer
,	O
IL_MOVE	int
|	O
IL_SAVE	int
)	O
==	O
'y'	O
)	O
{	O
command	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
command	pointer
,	O
"rm -r -f \"%s\""	pointer
,	O
name	pointer
)	O
;	O
result	int
=	O
start	function
(	O
command	pointer
,	O
1	int
)	O
;	O
xfree	function
(	O
command	pointer
)	O
;	O
tty_update_title	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
result	int
)	O
)	O
{	O
result	int
=	O
0	int
;	O
interrupted	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
WIFEXITED	O
(	O
result	int
)	O
)	O
{	O
if	O
(	O
WEXITSTATUS	O
(	O
result	int
)	O
!=	O
0	int
)	O
{	O
display_errors	function
(	O
"rm"	pointer
)	O
;	O
result	int
=	O
0	int
;	O
}	O
else	O
{	O
result	int
=	O
1	int
;	O
}	O
}	O
else	O
result	int
=	O
0	int
;	O
}	O
}	O
}	O
else	O
result	int
=	O
unlink	function
(	O
name	pointer
)	O
==	O
0	int
;	O
if	O
(	O
interrupted	int
)	O
{	O
if	O
(	O
panel_2s_message	function
(	O
"%s: Deletion interrupted.  Continue? "	pointer
,	O
name	pointer
,	O
"yn"	pointer
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_ERROR	int
)	O
!=	O
'y'	O
)	O
break	O
;	O
}	O
else	O
if	O
(	O
!	O
result	int
)	O
{	O
if	O
(	O
panel_2s_message	function
(	O
"%s: Deletion failed.  Continue? "	pointer
,	O
name	pointer
,	O
"yn"	pointer
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_ERROR	int
)	O
!=	O
'y'	O
)	O
break	O
;	O
}	O
else	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
0	int
;	O
}	O
if	O
(	O
first_entry	int
!=	O
this	pointer
->	O
entries	int
)	O
panel_set_current_entry	function
(	O
this	pointer
,	O
first_entry	int
)	O
;	O
panel_update_size	function
(	O
this	pointer
)	O
;	O
panel_update_size	function
(	O
other	pointer
)	O
;	O
status_default	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
!	O
panel_read_directory	function
(	O
this	pointer
,	O
this	pointer
->	O
path	pointer
,	O
ON	int
)	O
)	O
panel_recover	function
(	O
this	pointer
)	O
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
this	pointer
->	O
path	pointer
,	O
other	pointer
->	O
path	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
!	O
panel_read_directory	function
(	O
other	pointer
,	O
other	pointer
->	O
path	pointer
,	O
ON	int
)	O
)	O
panel_recover	function
(	O
other	pointer
)	O
;	O
panel_update	function
(	O
other	pointer
)	O
;	O
}	O
}	O
int	O
panel_isdir	function
(	O
path	pointer
)	O
const	O
char	O
*	O
path	pointer
;	O
{	O
struct	O
stat	struct
s	long
;	O
if	O
(	O
stat	struct
(	O
path	pointer
,	O
&	O
s	long
)	O
<	O
0	int
)	O
return	O
0	int
;	O
return	O
S_ISDIR	O
(	O
s	long
.	O
st_mode	int
)	O
;	O
}	O
int	O
panel_mkdirs	function
(	O
path	pointer
,	O
mode	int
)	O
const	O
char	O
*	O
path	pointer
;	O
int	O
mode	int
;	O
{	O
char	O
*	O
copy	pointer
=	O
xstrdup	function
(	O
path	pointer
)	O
;	O
char	O
*	O
z	pointer
=	O
copy	pointer
;	O
for	O
(	O
;	O
*	O
z	pointer
!=	O
'\0'	O
;	O
z	pointer
++	O
)	O
if	O
(	O
*	O
z	pointer
==	O
'/'	O
&&	O
z	pointer
!=	O
copy	pointer
)	O
{	O
*	O
z	pointer
=	O
'\0'	O
;	O
if	O
(	O
!	O
panel_isdir	function
(	O
copy	pointer
)	O
)	O
if	O
(	O
mkdir	function
(	O
copy	pointer
,	O
mode	int
)	O
!=	O
0	int
)	O
{	O
xfree	function
(	O
copy	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
*	O
z	pointer
=	O
'/'	O
;	O
}	O
xfree	function
(	O
copy	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
panel_act_MKDIR	function
(	O
this	pointer
,	O
other	pointer
)	O
panel_t	struct
*	O
this	pointer
,	O
*	O
other	pointer
;	O
{	O
size_t	long
len	long
;	O
char	O
*	O
input	pointer
=	O
NULL	O
,	O
*	O
tmp_input	pointer
;	O
if	O
(	O
!	O
il_read_line	function
(	O
"New directory name: "	pointer
,	O
&	O
input	pointer
,	O
NULL	O
,	O
mkdir_history	pointer
)	O
)	O
return	O
;	O
if	O
(	O
input	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
xfree	function
(	O
input	pointer
)	O
;	O
return	O
;	O
}	O
tmp_input	pointer
=	O
tilde_expand	function
(	O
input	pointer
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
input	pointer
=	O
tmp_input	pointer
;	O
len	long
=	O
strlen	function
(	O
input	pointer
)	O
;	O
input	pointer
=	O
realloc	function
(	O
input	pointer
,	O
len	long
+	O
1	int
+	O
1	int
)	O
;	O
input	pointer
[	O
len	long
]	O
=	O
'/'	O
;	O
input	pointer
[	O
len	long
+	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
panel_mkdirs	function
(	O
input	pointer
,	O
S_IFDIR	O
|	O
S_IRWXU	O
|	O
S_IRWXG	O
|	O
S_IRWXO	O
)	O
==	O
-	O
1	int
)	O
{	O
panel_2s_message	function
(	O
"%s: Permission denied."	pointer
,	O
input	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_FREEZED	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
panel_read_directory	function
(	O
this	pointer
,	O
this	pointer
->	O
path	pointer
,	O
ON	int
)	O
)	O
panel_recover	function
(	O
this	pointer
)	O
;	O
else	O
{	O
this	pointer
->	O
current_entry	int
=	O
panel_find_index	function
(	O
this	pointer
,	O
input	pointer
)	O
;	O
this	pointer
->	O
first_on_screen	int
=	O
panel_get_centered_fos	function
(	O
this	pointer
)	O
;	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
panel_update_size	function
(	O
this	pointer
)	O
;	O
}	O
if	O
(	O
strcmp	function
(	O
this	pointer
->	O
path	pointer
,	O
other	pointer
->	O
path	pointer
)	O
==	O
0	int
)	O
{	O
char	O
*	O
old_entry	pointer
=	O
xstrdup	function
(	O
other	pointer
->	O
dir_entry	pointer
[	O
other	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
)	O
;	O
if	O
(	O
!	O
panel_read_directory	function
(	O
other	pointer
,	O
other	pointer
->	O
path	pointer
,	O
ON	int
)	O
)	O
panel_recover	function
(	O
other	pointer
)	O
;	O
else	O
{	O
other	pointer
->	O
current_entry	int
=	O
panel_find_index	function
(	O
other	pointer
,	O
old_entry	pointer
)	O
;	O
other	pointer
->	O
first_on_screen	int
=	O
panel_get_centered_fos	function
(	O
other	pointer
)	O
;	O
panel_update_entries	function
(	O
other	pointer
)	O
;	O
panel_update_info	function
(	O
other	pointer
)	O
;	O
}	O
xfree	function
(	O
old_entry	pointer
)	O
;	O
}	O
panel_update_size	function
(	O
other	pointer
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
}	O
void	O
panel_act_MOVE	function
(	O
this	pointer
,	O
other	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
panel_t	struct
*	O
other	pointer
;	O
{	O
size_t	long
len	long
;	O
int	O
first_entry	int
,	O
entry	int
,	O
error	int
;	O
char	O
*	O
file	pointer
,	O
*	O
dir	pointer
=	O
NULL	O
,	O
*	O
msg	pointer
,	O
*	O
input	pointer
=	O
NULL	O
,	O
*	O
tmp_input	pointer
;	O
this	pointer
->	O
chkdest	int
=	O
ON	int
;	O
if	O
(	O
this	pointer
->	O
selected_entries	int
==	O
0	int
)	O
{	O
char	O
*	O
name	pointer
=	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
;	O
if	O
(	O
this	pointer
->	O
current_entry	int
==	O
0	int
&&	O
!	O
rootdir	O
(	O
)	O
)	O
return	O
;	O
msg	pointer
=	O
xmalloc	function
(	O
16	int
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
msg	pointer
,	O
"Move %s to: "	pointer
,	O
cutname	function
(	O
name	pointer
,	O
0	int
,	O
0	int
)	O
)	O
;	O
len	long
=	O
1	int
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
;	O
file	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
other	pointer
->	O
path	pointer
)	O
+	O
len	long
)	O
;	O
sprintf	function
(	O
file	pointer
,	O
"%s/%s"	pointer
,	O
other	pointer
->	O
path	pointer
,	O
name	pointer
)	O
;	O
if	O
(	O
!	O
il_read_line	function
(	O
msg	pointer
,	O
&	O
input	pointer
,	O
file	pointer
,	O
move_history	pointer
)	O
)	O
{	O
xfree	function
(	O
msg	pointer
)	O
;	O
return	O
;	O
}	O
xfree	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
S_ISDIR	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
mode	int
)	O
)	O
il_message	function
(	O
PANEL_MOVE_DIR_MSG	O
)	O
;	O
else	O
il_message	function
(	O
PANEL_MOVE_FILE_MSG	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
tmp_input	pointer
=	O
tilde_expand	function
(	O
input	pointer
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
input	pointer
=	O
tmp_input	pointer
;	O
error	int
=	O
same_file	function
(	O
name	pointer
,	O
input	pointer
)	O
;	O
xfree	function
(	O
file	pointer
)	O
;	O
if	O
(	O
error	int
)	O
{	O
panel_3s_message	function
(	O
"%s and %s point to the same file."	pointer
,	O
name	pointer
,	O
input	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
xfree	function
(	O
input	pointer
)	O
;	O
return	O
;	O
}	O
error	int
=	O
panel_move	function
(	O
this	pointer
,	O
name	pointer
,	O
input	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
mode	int
)	O
;	O
if	O
(	O
error	int
!=	O
FT_OK	O
)	O
{	O
if	O
(	O
error	int
==	O
FT_CANCEL	O
)	O
{	O
xfree	function
(	O
input	pointer
)	O
;	O
status_default	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
return	O
;	O
}	O
panel_3s_message	function
(	O
"%s: Move failed, %s."	pointer
,	O
name	pointer
,	O
moveerr	array
[	O
error	int
-	O
1	int
]	O
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_ERROR	int
)	O
;	O
}	O
xfree	function
(	O
input	pointer
)	O
;	O
status_default	function
(	O
)	O
;	O
panel_update_size	function
(	O
this	pointer
)	O
;	O
panel_update_size	function
(	O
other	pointer
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
!	O
il_read_line	function
(	O
"Move selected file(s) to: "	pointer
,	O
&	O
dir	pointer
,	O
other	pointer
->	O
path	pointer
,	O
move_history	pointer
)	O
)	O
return	O
;	O
if	O
(	O
same_file	function
(	O
this	pointer
->	O
path	pointer
,	O
dir	pointer
)	O
)	O
{	O
panel_1s_message	O
(	O
nice_try	array
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_FREEZED	int
|	O
IL_BEEP	int
|	O
IL_ERROR	int
)	O
;	O
return	O
;	O
}	O
dir	pointer
=	O
xrealloc	function
(	O
dir	pointer
,	O
(	O
len	long
=	O
strlen	function
(	O
dir	pointer
)	O
+	O
1	int
)	O
+	O
1	int
)	O
;	O
dir	pointer
[	O
len	long
-	O
1	int
]	O
=	O
'/'	O
;	O
dir	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
for	O
(	O
first_entry	int
=	O
0	int
;	O
first_entry	int
<	O
this	pointer
->	O
entries	int
;	O
first_entry	int
++	O
)	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
first_entry	int
]	O
.	O
selected	char
)	O
break	O
;	O
panel_init_iterator	function
(	O
this	pointer
)	O
;	O
while	O
(	O
(	O
entry	int
=	O
panel_get_next	function
(	O
this	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
char	O
*	O
name	pointer
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
;	O
service_pending_signals	function
(	O
)	O
;	O
dir	pointer
=	O
xrealloc	function
(	O
dir	pointer
,	O
len	long
+	O
strlen	function
(	O
name	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
dir	pointer
+	O
len	long
,	O
name	pointer
)	O
;	O
if	O
(	O
canceled	function
(	O
)	O
)	O
break	O
;	O
il_message	function
(	O
PANEL_MOVE_FILES_MSG	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
error	int
=	O
panel_move	function
(	O
this	pointer
,	O
name	pointer
,	O
dir	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
mode	int
)	O
;	O
if	O
(	O
error	int
!=	O
FT_OK	O
)	O
{	O
if	O
(	O
error	int
==	O
FT_CANCEL	O
)	O
break	O
;	O
if	O
(	O
error	int
==	O
FT_SKIP	O
)	O
continue	O
;	O
if	O
(	O
panel_3s_message	function
(	O
"%s: Move failed, %s."	pointer
,	O
name	pointer
,	O
moveerr	array
[	O
error	int
-	O
1	int
]	O
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_ERROR	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
else	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
0	int
;	O
}	O
if	O
(	O
dir	pointer
)	O
xfree	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
first_entry	int
!=	O
this	pointer
->	O
entries	int
)	O
panel_set_current_entry	function
(	O
this	pointer
,	O
first_entry	int
)	O
;	O
status_default	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
panel_read_directory	function
(	O
other	pointer
,	O
other	pointer
->	O
path	pointer
,	O
ON	int
)	O
)	O
panel_recover	function
(	O
other	pointer
)	O
;	O
panel_update	function
(	O
other	pointer
)	O
;	O
if	O
(	O
!	O
panel_read_directory	function
(	O
this	pointer
,	O
this	pointer
->	O
path	pointer
,	O
ON	int
)	O
)	O
panel_recover	function
(	O
this	pointer
)	O
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
}	O
void	O
panel_act_CHDIR	function
(	O
this	pointer
,	O
other	pointer
,	O
new_dir	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
panel_t	struct
*	O
other	pointer
;	O
char	O
*	O
new_dir	pointer
;	O
{	O
assert	O
(	O
new_dir	pointer
)	O
;	O
if	O
(	O
new_dir	pointer
[	O
0	int
]	O
==	O
'/'	O
)	O
{	O
this	pointer
->	O
pathlen	long
=	O
strlen	function
(	O
new_dir	pointer
)	O
;	O
this	pointer
->	O
path	pointer
=	O
xrealloc	function
(	O
this	pointer
->	O
path	pointer
,	O
(	O
this	pointer
->	O
pathlen	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
strcpy	function
(	O
this	pointer
->	O
path	pointer
,	O
new_dir	pointer
)	O
;	O
}	O
else	O
{	O
this	pointer
->	O
pathlen	long
+=	O
1	int
+	O
strlen	function
(	O
new_dir	pointer
)	O
;	O
this	pointer
->	O
path	pointer
=	O
xrealloc	function
(	O
this	pointer
->	O
path	pointer
,	O
(	O
this	pointer
->	O
pathlen	long
+	O
1	int
)	O
*	O
sizeof	O
(	O
char	O
)	O
)	O
;	O
strcat	function
(	O
this	pointer
->	O
path	pointer
,	O
"/"	pointer
)	O
;	O
strcat	function
(	O
this	pointer
->	O
path	pointer
,	O
new_dir	pointer
)	O
;	O
minimize_path	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
}	O
panel_set_current_entry	function
(	O
this	pointer
,	O
0	int
)	O
;	O
panel_action	function
(	O
this	pointer
,	O
act_REGET	int
,	O
(	O
panel_t	struct
*	O
)	O
NULL	O
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
1	int
)	O
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
this	pointer
->	O
path	pointer
,	O
other	pointer
->	O
path	pointer
)	O
==	O
0	int
)	O
{	O
panel_action	function
(	O
other	pointer
,	O
act_REGET	int
,	O
(	O
panel_t	struct
*	O
)	O
NULL	O
,	O
(	O
void	O
*	O
)	O
-	O
1	int
,	O
1	int
)	O
;	O
panel_update	function
(	O
other	pointer
)	O
;	O
}	O
}	O
void	O
panel_act_REGET	function
(	O
this	pointer
,	O
aux_info	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
void	O
*	O
aux_info	pointer
;	O
{	O
char	O
*	O
old_entry	pointer
;	O
int	O
flag	pointer
,	O
verify	int
;	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
&&	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
)	O
{	O
old_entry	pointer
=	O
xstrdup	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
)	O
;	O
flag	pointer
=	O
1	int
;	O
}	O
else	O
old_entry	pointer
=	O
""	pointer
,	O
flag	pointer
=	O
0	int
;	O
verify	int
=	O
aux_info	pointer
==	O
(	O
void	O
*	O
)	O
-	O
1	int
;	O
if	O
(	O
panel_read_directory	function
(	O
this	pointer
,	O
this	pointer
->	O
path	pointer
,	O
verify	int
)	O
)	O
{	O
if	O
(	O
verify	int
)	O
panel_set_current_entry	function
(	O
this	pointer
,	O
panel_find_index	function
(	O
this	pointer
,	O
old_entry	pointer
)	O
)	O
;	O
else	O
panel_set_current_entry	function
(	O
this	pointer
,	O
0	int
)	O
;	O
}	O
else	O
panel_recover	function
(	O
this	pointer
)	O
;	O
if	O
(	O
flag	pointer
)	O
xfree	function
(	O
old_entry	pointer
)	O
;	O
}	O
off64_t	long
panel_compare	function
(	O
this	pointer
,	O
this_entry	int
,	O
this_size	pointer
,	O
other	pointer
,	O
other_entry	int
,	O
other_size	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
int	O
this_entry	int
;	O
off64_t	long
*	O
this_size	pointer
;	O
panel_t	struct
*	O
other	pointer
;	O
int	O
other_entry	int
;	O
off64_t	long
*	O
other_size	pointer
;	O
{	O
off64_t	long
n	long
;	O
char	O
*	O
msg	pointer
;	O
int	O
fd1	int
,	O
fd2	int
;	O
char	O
*	O
buf1	pointer
,	O
*	O
buf2	pointer
;	O
int	O
read1	int
,	O
read2	int
;	O
int	O
aborted	int
=	O
0	int
;	O
char	O
*	O
name1	pointer
=	O
this	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
name	pointer
;	O
char	O
*	O
name2	pointer
=	O
other	pointer
->	O
dir_entry	pointer
[	O
other_entry	int
]	O
.	O
name	pointer
;	O
char	O
*	O
file1	pointer
=	O
name1	pointer
;	O
char	O
*	O
file2	pointer
;	O
int	O
is_special1	int
=	O
0	int
;	O
int	O
is_special2	int
=	O
0	int
;	O
int	O
mismatch	int
=	O
0	int
;	O
off64_t	long
size	long
=	O
0	int
;	O
*	O
this_size	pointer
=	O
*	O
other_size	pointer
=	O
0	int
;	O
if	O
(	O
IS_SPECIAL	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
mode	int
)	O
)	O
is_special1	int
=	O
1	int
;	O
if	O
(	O
IS_SPECIAL	O
(	O
other	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
mode	int
)	O
)	O
is_special2	int
=	O
1	int
;	O
if	O
(	O
is_special1	int
&&	O
is_special2	int
)	O
size	long
=	O
0	int
;	O
else	O
if	O
(	O
is_special1	int
)	O
size	long
=	O
(	O
off64_t	long
)	O
other	pointer
->	O
dir_entry	pointer
[	O
other_entry	int
]	O
.	O
size	long
;	O
else	O
if	O
(	O
is_special2	int
)	O
size	long
=	O
(	O
off64_t	long
)	O
this	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
size	long
;	O
else	O
size	long
=	O
(	O
off64_t	long
)	O
max	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
size	long
,	O
other	pointer
->	O
dir_entry	pointer
[	O
other_entry	int
]	O
.	O
size	long
)	O
;	O
if	O
(	O
(	O
size	long
==	O
0	int
)	O
&&	O
!	O
(	O
is_special1	int
&&	O
is_special2	int
)	O
)	O
return	O
0	int
;	O
file2	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
other	pointer
->	O
path	pointer
)	O
+	O
1	int
+	O
strlen	function
(	O
name2	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
file2	pointer
,	O
"%s/%s"	pointer
,	O
other	pointer
->	O
path	pointer
,	O
name2	pointer
)	O
;	O
msg	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
file1	pointer
)	O
+	O
1	int
)	O
;	O
if	O
(	O
!	O
size	long
)	O
sprintf	function
(	O
msg	pointer
,	O
"(CMP) %s"	pointer
,	O
file1	pointer
)	O
;	O
else	O
sprintf	function
(	O
msg	pointer
,	O
"(CMP) [  0%%] %s"	pointer
,	O
file1	pointer
)	O
;	O
status	int
(	O
msg	pointer
,	O
STATUS_WARNING	int
,	O
STATUS_LEFT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
(	O
fd1	int
=	O
open64	function
(	O
file1	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
==	O
-	O
1	int
)	O
return	O
CF_OPEN1	O
;	O
if	O
(	O
(	O
fd2	int
=	O
open64	function
(	O
file2	pointer
,	O
O_RDONLY	int
|	O
O_BINARY	int
)	O
)	O
==	O
-	O
1	int
)	O
{	O
xfree	function
(	O
file2	pointer
)	O
;	O
close	pointer
(	O
fd1	int
)	O
;	O
return	O
CF_OPEN2	O
;	O
}	O
xfree	function
(	O
file2	pointer
)	O
;	O
buf1	pointer
=	O
xmalloc	function
(	O
CMP_BUFFER_SIZE	O
)	O
;	O
buf2	pointer
=	O
xmalloc	function
(	O
CMP_BUFFER_SIZE	O
)	O
;	O
msg	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
file1	pointer
)	O
+	O
1	int
)	O
;	O
for	O
(	O
n	long
=	O
0	int
;	O
;	O
)	O
{	O
int	O
bytes_read	int
;	O
if	O
(	O
canceled	function
(	O
)	O
)	O
{	O
aborted	int
=	O
1	int
;	O
break	O
;	O
}	O
signals	function
(	O
ON	int
)	O
;	O
read1	int
=	O
read	pointer
(	O
fd1	int
,	O
buf1	pointer
,	O
CMP_BUFFER_SIZE	O
)	O
;	O
signals	function
(	O
OFF	int
)	O
;	O
if	O
(	O
read1	int
<	O
0	int
)	O
{	O
close	pointer
(	O
fd1	int
)	O
;	O
close	pointer
(	O
fd2	int
)	O
;	O
return	O
CF_READ1	O
;	O
}	O
*	O
this_size	pointer
+=	O
read1	int
;	O
signals	function
(	O
ON	int
)	O
;	O
read2	int
=	O
read	pointer
(	O
fd2	int
,	O
buf2	pointer
,	O
CMP_BUFFER_SIZE	O
)	O
;	O
signals	function
(	O
OFF	int
)	O
;	O
if	O
(	O
read2	int
<	O
0	int
)	O
{	O
close	pointer
(	O
fd1	int
)	O
;	O
close	pointer
(	O
fd2	int
)	O
;	O
return	O
CF_READ2	O
;	O
}	O
*	O
other_size	pointer
+=	O
read2	int
;	O
bytes_read	int
=	O
min	O
(	O
read1	int
,	O
read2	int
)	O
;	O
if	O
(	O
bytes_read	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
memcmp	function
(	O
buf1	pointer
,	O
buf2	pointer
,	O
bytes_read	int
)	O
!=	O
0	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
bytes_read	int
;	O
i	int
++	O
)	O
if	O
(	O
buf1	pointer
[	O
i	int
]	O
!=	O
buf2	pointer
[	O
i	int
]	O
)	O
break	O
;	O
n	long
+=	O
i	int
;	O
mismatch	int
=	O
1	int
;	O
break	O
;	O
}	O
n	long
+=	O
bytes_read	int
;	O
if	O
(	O
!	O
size	long
)	O
sprintf	function
(	O
msg	pointer
,	O
"(CMP) %s"	pointer
,	O
file1	pointer
)	O
;	O
else	O
sprintf	function
(	O
msg	pointer
,	O
"(CMP) [%3d%%] %s"	pointer
,	O
panel_percent	function
(	O
n	long
,	O
size	long
)	O
,	O
file1	pointer
)	O
;	O
status	int
(	O
msg	pointer
,	O
STATUS_WARNING	int
,	O
STATUS_LEFT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
if	O
(	O
mismatch	int
)	O
{	O
if	O
(	O
is_special1	int
)	O
{	O
signals	function
(	O
ON	int
)	O
;	O
do	O
{	O
read1	int
=	O
read	pointer
(	O
fd1	int
,	O
buf1	pointer
,	O
CMP_BUFFER_SIZE	O
)	O
;	O
}	O
while	O
(	O
(	O
read1	int
>	O
0	int
)	O
&&	O
(	O
*	O
this_size	pointer
+=	O
read1	int
)	O
)	O
;	O
signals	function
(	O
OFF	int
)	O
;	O
}	O
else	O
*	O
this_size	pointer
=	O
this	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
size	long
;	O
if	O
(	O
is_special2	int
)	O
{	O
signals	function
(	O
ON	int
)	O
;	O
do	O
{	O
read2	int
=	O
read	pointer
(	O
fd2	int
,	O
buf2	pointer
,	O
CMP_BUFFER_SIZE	O
)	O
;	O
}	O
while	O
(	O
(	O
read2	int
>	O
0	int
)	O
&&	O
(	O
*	O
other_size	pointer
+=	O
read2	int
)	O
)	O
;	O
signals	function
(	O
OFF	int
)	O
;	O
}	O
else	O
*	O
other_size	pointer
=	O
other	pointer
->	O
dir_entry	pointer
[	O
other_entry	int
]	O
.	O
size	long
;	O
}	O
xfree	function
(	O
msg	pointer
)	O
;	O
xfree	function
(	O
buf1	pointer
)	O
;	O
xfree	function
(	O
buf2	pointer
)	O
;	O
close	pointer
(	O
fd1	int
)	O
;	O
close	pointer
(	O
fd2	int
)	O
;	O
return	O
aborted	int
?	O
CF_ABORT	O
:	O
n	long
;	O
}	O
void	O
panel_act_COMPARE	function
(	O
this	pointer
,	O
other	pointer
)	O
panel_t	struct
*	O
this	pointer
;	O
panel_t	struct
*	O
other	pointer
;	O
{	O
int	O
permission	int
=	O
1	int
;	O
int	O
this_entry	int
=	O
this	pointer
->	O
current_entry	int
;	O
int	O
other_entry	int
=	O
other	pointer
->	O
current_entry	int
;	O
il_message	function
(	O
PANEL_COMPARE_FILES_MSG	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
(	O
strcmp	function
(	O
this	pointer
->	O
path	pointer
,	O
other	pointer
->	O
path	pointer
)	O
==	O
0	int
)	O
&&	O
(	O
strcmp	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
name	pointer
,	O
other	pointer
->	O
dir_entry	pointer
[	O
other_entry	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
)	O
{	O
panel_1s_message	O
(	O
"There is no point in comparing a file with itself. "	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
return	O
;	O
}	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
type	enum
==	O
FILE_ENTRY	int
&&	O
other	pointer
->	O
dir_entry	pointer
[	O
other_entry	int
]	O
.	O
type	enum
==	O
FILE_ENTRY	int
)	O
{	O
if	O
(	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
size	long
!=	O
other	pointer
->	O
dir_entry	pointer
[	O
other_entry	int
]	O
.	O
size	long
)	O
&&	O
(	O
!	O
(	O
IS_SPECIAL	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
mode	int
)	O
||	O
IS_SPECIAL	O
(	O
other	pointer
->	O
dir_entry	pointer
[	O
other_entry	int
]	O
.	O
mode	int
)	O
)	O
)	O
)	O
{	O
if	O
(	O
panel_1s_message	O
(	O
"Files have different size.  Continue? "	pointer
,	O
"yn"	pointer
,	O
IL_BEEP	int
|	O
IL_ERROR	int
)	O
!=	O
'y'	O
)	O
permission	int
=	O
0	int
;	O
}	O
if	O
(	O
permission	int
)	O
{	O
off64_t	long
this_size	pointer
,	O
other_size	pointer
;	O
off64_t	long
result	int
=	O
panel_compare	function
(	O
this	pointer
,	O
this_entry	int
,	O
&	O
this_size	pointer
,	O
other	pointer
,	O
other_entry	int
,	O
&	O
other_size	pointer
)	O
;	O
switch	O
(	O
(	O
int	O
)	O
result	int
)	O
{	O
case	O
CF_ABORT	O
:	O
break	O
;	O
case	O
CF_OPEN1	O
:	O
panel_2s_message	function
(	O
"Cannot open file %s. "	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
name	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
break	O
;	O
case	O
CF_OPEN2	O
:	O
panel_2s_message	function
(	O
"Cannot open file %s. "	pointer
,	O
other	pointer
->	O
dir_entry	pointer
[	O
other_entry	int
]	O
.	O
name	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
break	O
;	O
case	O
CF_READ1	O
:	O
panel_2s_message	function
(	O
"I/O error reading from file %s. "	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
this_entry	int
]	O
.	O
name	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
break	O
;	O
case	O
CF_READ2	O
:	O
panel_2s_message	function
(	O
"I/O error reading from file %s. "	pointer
,	O
other	pointer
->	O
dir_entry	pointer
[	O
other_entry	int
]	O
.	O
name	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
break	O
;	O
default	O
:	O
if	O
(	O
(	O
result	int
==	O
this_size	pointer
)	O
&&	O
(	O
this_size	pointer
==	O
other_size	pointer
)	O
)	O
{	O
panel_1s_message	O
(	O
"Compare OK. "	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_BEEP	int
|	O
IL_SAVE	int
)	O
;	O
}	O
else	O
if	O
(	O
result	int
==	O
min	O
(	O
this_size	pointer
,	O
other_size	pointer
)	O
)	O
{	O
panel_1s_message	O
(	O
"Files are different sizes but are identical up to the size of the smallest."	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_BEEP	int
|	O
IL_SAVE	int
)	O
;	O
}	O
else	O
{	O
char	O
*	O
msg	pointer
=	O
xmalloc	function
(	O
128	int
)	O
;	O
sprintf	function
(	O
msg	pointer
,	O
"%Ld (0x%Lx)"	pointer
,	O
result	int
,	O
result	int
)	O
;	O
panel_2s_message	function
(	O
"Files differ at offset %s. "	pointer
,	O
msg	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_BEEP	int
|	O
IL_SAVE	int
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
}	O
break	O
;	O
}	O
}	O
}	O
else	O
{	O
panel_2s_message	function
(	O
"Only regular files can be compared. "	pointer
,	O
this	pointer
->	O
path	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
}	O
status_default	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
}	O
void	O
panel_act_CMPDIR	function
(	O
this	pointer
,	O
other	pointer
,	O
quick	int
)	O
panel_t	struct
*	O
this	pointer
;	O
panel_t	struct
*	O
other	pointer
;	O
int	O
quick	int
;	O
{	O
int	O
i	int
,	O
j	int
;	O
il_message	function
(	O
PANEL_COMPARE_DIR_MSG	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
this	pointer
->	O
path	pointer
,	O
other	pointer
->	O
path	pointer
)	O
==	O
0	int
)	O
{	O
panel_1s_message	O
(	O
"No point in comparing a directory with itself. "	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
panel_unselect_all	function
(	O
this	pointer
)	O
;	O
panel_unselect_all	function
(	O
other	pointer
)	O
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
panel_update	function
(	O
other	pointer
)	O
;	O
return	O
;	O
}	O
panel_select_all	function
(	O
this	pointer
)	O
;	O
panel_select_all	function
(	O
other	pointer
)	O
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
this	pointer
->	O
entries	int
;	O
i	int
++	O
)	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
FILE_ENTRY	int
)	O
for	O
(	O
j	int
=	O
1	int
;	O
j	int
<	O
other	pointer
->	O
entries	int
;	O
j	int
++	O
)	O
{	O
service_pending_signals	function
(	O
)	O
;	O
if	O
(	O
other	pointer
->	O
dir_entry	pointer
[	O
j	int
]	O
.	O
type	enum
==	O
FILE_ENTRY	int
&&	O
strcmp	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
name	pointer
,	O
other	pointer
->	O
dir_entry	pointer
[	O
j	int
]	O
.	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
size	long
==	O
other	pointer
->	O
dir_entry	pointer
[	O
j	int
]	O
.	O
size	long
)	O
{	O
if	O
(	O
quick	int
)	O
{	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
mtime	long
!=	O
other	pointer
->	O
dir_entry	pointer
[	O
j	int
]	O
.	O
mtime	long
)	O
goto	O
hilight_the_newer_one	O
;	O
else	O
goto	O
unhilight_both	O
;	O
}	O
else	O
{	O
off64_t	long
this_size	pointer
,	O
other_size	pointer
;	O
off64_t	long
result	int
=	O
panel_compare	function
(	O
this	pointer
,	O
i	int
,	O
&	O
this_size	pointer
,	O
other	pointer
,	O
j	int
,	O
&	O
other_size	pointer
)	O
;	O
if	O
(	O
result	int
==	O
CF_ABORT	O
)	O
goto	O
done	O
;	O
if	O
(	O
(	O
result	int
==	O
this_size	pointer
)	O
&&	O
(	O
result	int
==	O
other_size	pointer
)	O
)	O
goto	O
unhilight_both	O
;	O
}	O
}	O
hilight_the_newer_one	O
:	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
mtime	long
>=	O
other	pointer
->	O
dir_entry	pointer
[	O
j	int
]	O
.	O
mtime	long
)	O
{	O
other	pointer
->	O
dir_entry	pointer
[	O
j	int
]	O
.	O
selected	char
=	O
0	int
;	O
other	pointer
->	O
selected_entries	int
--	O
;	O
}	O
else	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
selected	char
=	O
0	int
;	O
this	pointer
->	O
selected_entries	int
--	O
;	O
}	O
break	O
;	O
unhilight_both	O
:	O
this	pointer
->	O
dir_entry	pointer
[	O
i	int
]	O
.	O
selected	char
=	O
0	int
;	O
this	pointer
->	O
selected_entries	int
--	O
;	O
other	pointer
->	O
dir_entry	pointer
[	O
j	int
]	O
.	O
selected	char
=	O
0	int
;	O
other	pointer
->	O
selected_entries	int
--	O
;	O
break	O
;	O
}	O
}	O
done	O
:	O
status_default	function
(	O
)	O
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
panel_update	function
(	O
other	pointer
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
this	pointer
->	O
selected_entries	int
||	O
other	pointer
->	O
selected_entries	int
)	O
tty_beep	function
(	O
)	O
;	O
}	O
char	O
*	O
renerr	array
[	O
7	int
]	O
=	O
{	O
""	pointer
,	O
""	pointer
,	O
""	pointer
,	O
"cannot remove old entry"	pointer
,	O
"cannot remove existing entry"	pointer
,	O
"cannot rename entry"	pointer
,	O
"mv interrupted by a signal"	pointer
,	O
}	O
;	O
int	O
panel_case_rename	function
(	O
this	pointer
,	O
entry	int
,	O
upcase	int
)	O
panel_t	struct
*	O
this	pointer
;	O
int	O
entry	int
;	O
int	O
upcase	int
;	O
{	O
char	O
*	O
msg	pointer
;	O
char	O
*	O
new_name	pointer
;	O
int	O
n	long
=	O
0	int
,	O
error	int
,	O
first_time	int
=	O
1	int
,	O
len	long
;	O
char	O
*	O
name	pointer
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
;	O
new_name	pointer
=	O
xstrdup	function
(	O
name	pointer
)	O
;	O
len	long
=	O
strlen	function
(	O
name	pointer
)	O
;	O
if	O
(	O
upcase	int
)	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
len	long
;	O
n	long
++	O
)	O
new_name	pointer
[	O
n	long
]	O
=	O
toupper	function
(	O
(	O
int	O
)	O
name	pointer
[	O
n	long
]	O
)	O
;	O
else	O
for	O
(	O
n	long
=	O
0	int
;	O
n	long
<	O
len	long
;	O
n	long
++	O
)	O
new_name	pointer
[	O
n	long
]	O
=	O
tolower	function
(	O
(	O
int	O
)	O
name	pointer
[	O
n	long
]	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
name	pointer
,	O
new_name	pointer
)	O
==	O
0	int
)	O
goto	O
done	O
;	O
msg	pointer
=	O
xmalloc	function
(	O
32	int
+	O
len	long
+	O
1	int
)	O
;	O
sprintf	function
(	O
msg	pointer
,	O
"(CASE) Renaming %s"	pointer
,	O
name	pointer
)	O
;	O
status	int
(	O
msg	pointer
,	O
STATUS_WARNING	int
,	O
STATUS_LEFT	int
)	O
;	O
tty_update	function
(	O
)	O
;	O
xfree	function
(	O
msg	pointer
)	O
;	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
==	O
DIR_ENTRY	int
)	O
{	O
if	O
(	O
access	function
(	O
new_name	pointer
,	O
F_OK	int
)	O
==	O
0	int
)	O
{	O
int	O
result	int
;	O
char	O
*	O
command	pointer
;	O
if	O
(	O
this	pointer
->	O
chkdest	int
==	O
ON	int
)	O
error	int
=	O
panel_warning	function
(	O
this	pointer
,	O
new_name	pointer
)	O
;	O
else	O
error	int
=	O
WARN_OVERWRITE	int
;	O
if	O
(	O
error	int
)	O
return	O
error	int
;	O
command	pointer
=	O
xmalloc	function
(	O
32	int
+	O
strlen	function
(	O
new_name	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
command	pointer
,	O
"rm -r -f \"%s\""	pointer
,	O
new_name	pointer
)	O
;	O
result	int
=	O
start	function
(	O
command	pointer
,	O
1	int
)	O
;	O
xfree	function
(	O
command	pointer
)	O
;	O
tty_update_title	function
(	O
this	pointer
->	O
path	pointer
)	O
;	O
if	O
(	O
WIFSIGNALED	O
(	O
result	int
)	O
)	O
{	O
return	O
ON_INTERRUPTED	int
;	O
}	O
if	O
(	O
WIFEXITED	O
(	O
result	int
)	O
)	O
{	O
if	O
(	O
WEXITSTATUS	O
(	O
result	int
)	O
!=	O
0	int
)	O
{	O
display_errors	function
(	O
"rm"	pointer
)	O
;	O
return	O
N_RMERR	int
;	O
}	O
}	O
else	O
{	O
return	O
N_RMERR	int
;	O
}	O
}	O
if	O
(	O
rename	function
(	O
name	pointer
,	O
new_name	pointer
)	O
==	O
0	int
)	O
goto	O
done	O
;	O
else	O
return	O
ON_RENERR	int
;	O
}	O
retry	O
:	O
if	O
(	O
link	function
(	O
name	pointer
,	O
new_name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
unlink	function
(	O
name	pointer
)	O
==	O
0	int
)	O
goto	O
done	O
;	O
else	O
return	O
O_RMERR	int
;	O
}	O
else	O
{	O
int	O
safe_errno	int
=	O
errno	O
;	O
status_default	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
if	O
(	O
safe_errno	int
==	O
EPERM	int
||	O
safe_errno	int
==	O
EACCES	int
)	O
return	O
ON_RENERR	int
;	O
if	O
(	O
!	O
first_time	int
)	O
return	O
ON_RENERR	int
;	O
if	O
(	O
this	pointer
->	O
chkdest	int
==	O
ON	int
)	O
error	int
=	O
panel_warning	function
(	O
this	pointer
,	O
new_name	pointer
)	O
;	O
else	O
error	int
=	O
WARN_OVERWRITE	int
;	O
if	O
(	O
error	int
)	O
return	O
error	int
;	O
if	O
(	O
unlink	function
(	O
new_name	pointer
)	O
!=	O
0	int
)	O
return	O
N_RMERR	int
;	O
if	O
(	O
first_time	int
)	O
{	O
first_time	int
=	O
0	int
;	O
goto	O
retry	O
;	O
}	O
}	O
done	O
:	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
0	int
;	O
this	pointer
->	O
selected_entries	int
--	O
;	O
return	O
ON_OK	O
;	O
}	O
void	O
panel_act_CASE	function
(	O
this	pointer
,	O
other	pointer
,	O
upcase	int
)	O
panel_t	struct
*	O
this	pointer
;	O
panel_t	struct
*	O
other	pointer
;	O
int	O
upcase	int
;	O
{	O
int	O
entry	int
,	O
error	int
;	O
il_message	function
(	O
PANEL_RENAME_FILES_MSG	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
this	pointer
->	O
chkdest	int
=	O
ON	int
;	O
panel_init_iterator	function
(	O
this	pointer
)	O
;	O
while	O
(	O
(	O
entry	int
=	O
panel_get_next	function
(	O
this	pointer
)	O
)	O
!=	O
-	O
1	int
)	O
{	O
service_pending_signals	function
(	O
)	O
;	O
error	int
=	O
panel_case_rename	function
(	O
this	pointer
,	O
entry	int
,	O
upcase	int
)	O
;	O
if	O
(	O
error	int
!=	O
ON_OK	O
)	O
{	O
if	O
(	O
error	int
==	O
ON_CANCEL	O
)	O
break	O
;	O
if	O
(	O
error	int
==	O
ON_SKIP	O
)	O
continue	O
;	O
if	O
(	O
error	int
!=	O
ON_OK	O
&&	O
error	int
!=	O
ON_CANCEL	O
)	O
panel_3s_message	function
(	O
"%s: Rename failed, %s."	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
,	O
renerr	array
[	O
error	int
-	O
1	int
]	O
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_MOVE	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_ERROR	int
)	O
;	O
}	O
else	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
0	int
;	O
}	O
status_default	function
(	O
)	O
;	O
tty_update	function
(	O
)	O
;	O
panel_action	function
(	O
this	pointer
,	O
act_REGET	int
,	O
(	O
panel_t	struct
*	O
)	O
NULL	O
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
1	int
)	O
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
this	pointer
->	O
path	pointer
,	O
other	pointer
->	O
path	pointer
)	O
==	O
0	int
)	O
{	O
panel_action	function
(	O
other	pointer
,	O
act_REGET	int
,	O
(	O
panel_t	struct
*	O
)	O
NULL	O
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
1	int
)	O
;	O
panel_update	function
(	O
other	pointer
)	O
;	O
}	O
}	O
static	O
int	O
pack_compare_fn	function
(	O
first	pointer
,	O
second	pointer
)	O
const	O
void	O
*	O
first	pointer
;	O
const	O
void	O
*	O
second	pointer
;	O
{	O
return	O
(	O
*	O
(	O
const	O
dir_entry_t	struct
*	O
const	O
*	O
)	O
second	pointer
)	O
->	O
size	long
-	O
(	O
*	O
(	O
const	O
dir_entry_t	struct
*	O
const	O
*	O
)	O
first	pointer
)	O
->	O
size	long
;	O
}	O
void	O
panel_act_BIN_PACKING	function
(	O
this	pointer
,	O
other	pointer
,	O
bin_size	long
)	O
panel_t	struct
*	O
this	pointer
;	O
panel_t	struct
*	O
other	pointer
;	O
off64_t	long
bin_size	long
;	O
{	O
char	O
msg	pointer
[	O
160	int
]	O
;	O
off64_t	long
file_size	long
;	O
long	O
free_blocks	long
;	O
off64_t	long
*	O
bins	pointer
=	O
NULL	O
;	O
dir_entry_t	struct
*	O
*	O
buffer	pointer
;	O
char	O
*	O
fn	pointer
=	O
"BIN PACKING"	pointer
;	O
int	O
max_bins	int
=	O
0	int
,	O
used_bins	int
=	O
0	int
;	O
int	O
entry	int
,	O
candidates	int
=	O
0	int
,	O
big_files	int
=	O
0	int
;	O
if	O
(	O
bin_size	long
==	O
0	int
)	O
{	O
struct	O
fs_usage	struct
fsu	struct
;	O
fsu	struct
.	O
fsu_blocks	long
=	O
(	O
uintmax_t	long
)	O
-	O
1	int
;	O
if	O
(	O
get_fs_usage	function
(	O
other	pointer
->	O
path	pointer
,	O
NULL	O
,	O
&	O
fsu	struct
)	O
>=	O
0	int
&&	O
fsu	struct
.	O
fsu_blocks	long
!=	O
(	O
uintmax_t	long
)	O
-	O
1	int
)	O
{	O
free_blocks	long
=	O
(	O
(	O
geteuid	function
(	O
)	O
==	O
0	int
)	O
?	O
fsu	struct
.	O
fsu_bfree	long
:	O
fsu	struct
.	O
fsu_bavail	long
)	O
;	O
bin_size	long
=	O
(	O
free_blocks	long
*	O
fsu	struct
.	O
fsu_blocksize	long
)	O
/	O
1024	int
;	O
}	O
}	O
panel_unselect_all	function
(	O
this	pointer
)	O
;	O
buffer	pointer
=	O
(	O
dir_entry_t	struct
*	O
*	O
)	O
xmalloc	function
(	O
this	pointer
->	O
entries	int
*	O
sizeof	O
(	O
dir_entry_t	struct
*	O
)	O
)	O
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
S_ISREG	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
mode	int
)	O
)	O
{	O
file_size	long
=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
size	long
;	O
if	O
(	O
file_size	long
%	O
1024	int
)	O
file_size	long
+=	O
1024	int
-	O
file_size	long
%	O
1024	int
;	O
file_size	long
/=	O
1024	int
;	O
if	O
(	O
file_size	long
<=	O
bin_size	long
)	O
buffer	pointer
[	O
candidates	int
++	O
]	O
=	O
&	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
;	O
else	O
big_files	int
++	O
;	O
}	O
qsort	function
(	O
buffer	pointer
,	O
candidates	int
,	O
sizeof	O
(	O
dir_entry_t	struct
*	O
)	O
,	O
pack_compare_fn	function
)	O
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
candidates	int
;	O
entry	int
++	O
)	O
{	O
int	O
current_bin	int
;	O
file_size	long
=	O
buffer	pointer
[	O
entry	int
]	O
->	O
size	long
;	O
if	O
(	O
file_size	long
%	O
1024	int
)	O
file_size	long
+=	O
1024	int
-	O
file_size	long
%	O
1024	int
;	O
file_size	long
/=	O
1024	int
;	O
for	O
(	O
current_bin	int
=	O
0	int
;	O
current_bin	int
<	O
used_bins	int
;	O
current_bin	int
++	O
)	O
if	O
(	O
bins	pointer
[	O
current_bin	int
]	O
>=	O
file_size	long
)	O
{	O
bins	pointer
[	O
current_bin	int
]	O
-=	O
file_size	long
;	O
if	O
(	O
current_bin	int
==	O
0	int
)	O
{	O
buffer	pointer
[	O
entry	int
]	O
->	O
selected	char
=	O
1	int
;	O
this	pointer
->	O
selected_entries	int
++	O
;	O
}	O
break	O
;	O
}	O
if	O
(	O
current_bin	int
==	O
used_bins	int
)	O
{	O
if	O
(	O
used_bins	int
==	O
max_bins	int
)	O
{	O
max_bins	int
+=	O
16	int
;	O
bins	pointer
=	O
(	O
off64_t	long
*	O
)	O
xrealloc	function
(	O
bins	pointer
,	O
max_bins	int
*	O
sizeof	O
(	O
off64_t	long
)	O
)	O
;	O
}	O
bins	pointer
[	O
used_bins	int
++	O
]	O
=	O
bin_size	long
-	O
file_size	long
;	O
if	O
(	O
current_bin	int
==	O
0	int
)	O
{	O
buffer	pointer
[	O
entry	int
]	O
->	O
selected	char
=	O
1	int
;	O
this	pointer
->	O
selected_entries	int
++	O
;	O
}	O
}	O
}	O
panel_update	function
(	O
this	pointer
)	O
;	O
if	O
(	O
bins	pointer
)	O
xfree	function
(	O
bins	pointer
)	O
;	O
xfree	function
(	O
buffer	pointer
)	O
;	O
if	O
(	O
candidates	int
>	O
0	int
)	O
{	O
if	O
(	O
big_files	int
>	O
0	int
)	O
{	O
sprintf	function
(	O
msg	pointer
,	O
"%s %d file(s): %s %d bin(s).  %d file(s) are too big."	pointer
,	O
fn	pointer
,	O
candidates	int
,	O
"You need approximately"	pointer
,	O
used_bins	int
,	O
big_files	int
)	O
;	O
}	O
else	O
sprintf	function
(	O
msg	pointer
,	O
"%s %d file(s): You need approximately %d bin(s)."	pointer
,	O
fn	pointer
,	O
candidates	int
,	O
used_bins	int
)	O
;	O
}	O
else	O
{	O
if	O
(	O
big_files	int
>	O
0	int
)	O
sprintf	function
(	O
msg	pointer
,	O
"%s: No suitable files found (smaller than %ldKb)."	pointer
,	O
fn	pointer
,	O
(	O
long	O
)	O
bin_size	long
)	O
;	O
else	O
sprintf	function
(	O
msg	pointer
,	O
"%s: No regular files found."	pointer
,	O
fn	pointer
)	O
;	O
}	O
panel_1s_message	O
(	O
msg	pointer
,	O
(	O
char	O
*	O
)	O
NULL	O
,	O
IL_FREEZED	int
|	O
IL_BEEP	int
|	O
IL_SAVE	int
|	O
IL_MOVE	int
|	O
IL_HOME	int
)	O
;	O
}	O
char	O
*	O
*	O
panel_parse_patterns	function
(	O
string	pointer
)	O
char	O
*	O
string	pointer
;	O
{	O
char	O
c	char
;	O
int	O
i	int
=	O
0	int
;	O
int	O
index	function
=	O
0	int
;	O
int	O
escaping	int
=	O
0	int
;	O
char	O
*	O
pattern	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
)	O
;	O
char	O
*	O
*	O
patterns	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xcalloc	function
(	O
2	int
,	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
while	O
(	O
1	int
)	O
switch	O
(	O
(	O
c	char
=	O
*	O
string	pointer
++	O
)	O
)	O
{	O
case	O
'\0'	O
:	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
if	O
(	O
escaping	int
&&	O
c	char
!=	O
'\0'	O
)	O
pattern	pointer
[	O
i	int
++	O
]	O
=	O
c	char
;	O
else	O
{	O
if	O
(	O
i	int
>	O
0	int
)	O
{	O
pattern	pointer
[	O
i	int
++	O
]	O
=	O
'\0'	O
;	O
patterns	pointer
[	O
index	function
++	O
]	O
=	O
xstrdup	function
(	O
pattern	pointer
)	O
;	O
patterns	pointer
[	O
index	function
]	O
=	O
NULL	O
;	O
}	O
if	O
(	O
c	char
==	O
'\0'	O
)	O
goto	O
done	O
;	O
patterns	pointer
=	O
(	O
char	O
*	O
*	O
)	O
xrealloc	function
(	O
patterns	pointer
,	O
(	O
index	function
+	O
2	int
)	O
*	O
sizeof	O
(	O
char	O
*	O
)	O
)	O
;	O
i	int
=	O
0	int
;	O
}	O
break	O
;	O
case	O
'\\'	O
:	O
if	O
(	O
escaping	int
)	O
pattern	pointer
[	O
i	int
++	O
]	O
=	O
c	char
;	O
escaping	int
=	O
!	O
escaping	int
;	O
break	O
;	O
default	O
:	O
if	O
(	O
escaping	int
)	O
pattern	pointer
[	O
i	int
++	O
]	O
=	O
'\\'	O
;	O
pattern	pointer
[	O
i	int
++	O
]	O
=	O
c	char
;	O
escaping	int
=	O
0	int
;	O
break	O
;	O
}	O
done	O
:	O
xfree	function
(	O
pattern	pointer
)	O
;	O
return	O
patterns	pointer
;	O
}	O
void	O
panel_deallocate_patterns	function
(	O
patterns	pointer
)	O
char	O
*	O
*	O
patterns	pointer
;	O
{	O
char	O
*	O
*	O
safe_patterns	pointer
=	O
patterns	pointer
;	O
while	O
(	O
*	O
patterns	pointer
)	O
xfree	function
(	O
*	O
patterns	pointer
++	O
)	O
;	O
xfree	function
(	O
safe_patterns	pointer
)	O
;	O
}	O
int	O
panel_action	function
(	O
this	pointer
,	O
action	int
,	O
other	pointer
,	O
aux_info	pointer
,	O
repeat_count	int
)	O
panel_t	struct
*	O
this	pointer
;	O
int	O
action	int
;	O
panel_t	struct
*	O
other	pointer
;	O
void	O
*	O
aux_info	pointer
;	O
int	O
repeat_count	int
;	O
{	O
char	O
*	O
ptr	pointer
;	O
size_t	long
len	long
;	O
char	O
*	O
previous	pointer
;	O
char	O
*	O
extension	pointer
;	O
isearch_aux_t	struct
*	O
iai	pointer
;	O
int	O
new_scroll_step	int
;	O
char	O
*	O
*	O
patterns	pointer
,	O
*	O
*	O
safe_patterns	pointer
;	O
int	O
entry	int
,	O
result	int
,	O
max_offset	int
;	O
int	O
need_update	int
,	O
need_update_all	int
,	O
old_current_entry	int
;	O
switch	O
(	O
action	int
)	O
{	O
case	O
act_ENTER	int
:	O
return	O
panel_act_ENTER	function
(	O
this	pointer
,	O
other	pointer
)	O
;	O
case	O
act_COPY	int
:	O
panel_act_COPY	function
(	O
this	pointer
,	O
other	pointer
)	O
;	O
break	O
;	O
case	O
act_DELETE	int
:	O
panel_act_DELETE	function
(	O
this	pointer
,	O
other	pointer
)	O
;	O
break	O
;	O
case	O
act_SELECT	int
:	O
if	O
(	O
rootdir	O
(	O
)	O
||	O
this	pointer
->	O
current_entry	int
!=	O
0	int
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
selected	char
=	O
!	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
selected	char
;	O
this	pointer
->	O
selected_entries	int
+=	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
selected	char
?	O
1	int
:	O
-	O
1	int
;	O
panel_update_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
)	O
;	O
}	O
panel_action	function
(	O
this	pointer
,	O
act_DOWN	int
,	O
other	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
repeat_count	int
)	O
;	O
break	O
;	O
case	O
act_SELECT_ALL	int
:	O
panel_select_all	function
(	O
this	pointer
)	O
;	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_UNSELECT_ALL	int
:	O
panel_unselect_all	function
(	O
this	pointer
)	O
;	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_TOGGLE	int
:	O
this	pointer
->	O
selected_entries	int
=	O
0	int
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
!=	O
DIR_ENTRY	int
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
!	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
;	O
this	pointer
->	O
selected_entries	int
+=	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
;	O
}	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_MKDIR	int
:	O
panel_act_MKDIR	function
(	O
this	pointer
,	O
other	pointer
)	O
;	O
break	O
;	O
case	O
act_MOVE	int
:	O
panel_act_MOVE	function
(	O
this	pointer
,	O
other	pointer
)	O
;	O
break	O
;	O
case	O
act_UP	int
:	O
need_update_all	int
=	O
need_update	int
=	O
0	int
;	O
while	O
(	O
repeat_count	int
--	O
)	O
{	O
if	O
(	O
this	pointer
->	O
current_entry	int
!=	O
0	int
)	O
this	pointer
->	O
current_entry	int
--	O
;	O
else	O
break	O
;	O
if	O
(	O
this	pointer
->	O
current_entry	int
+	O
1	int
==	O
this	pointer
->	O
first_on_screen	int
)	O
{	O
this	pointer
->	O
first_on_screen	int
=	O
max	O
(	O
0	int
,	O
this	pointer
->	O
first_on_screen	int
-	O
this	pointer
->	O
scroll_step	int
)	O
;	O
need_update_all	int
=	O
1	int
;	O
}	O
else	O
{	O
if	O
(	O
!	O
need_update	int
)	O
panel_update_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
+	O
1	int
)	O
;	O
need_update	int
=	O
1	int
;	O
}	O
}	O
if	O
(	O
need_update_all	int
)	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
else	O
if	O
(	O
need_update	int
)	O
panel_update_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
)	O
;	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_DOWN	int
:	O
need_update_all	int
=	O
need_update	int
=	O
0	int
;	O
while	O
(	O
repeat_count	int
--	O
)	O
{	O
if	O
(	O
this	pointer
->	O
current_entry	int
<	O
this	pointer
->	O
entries	int
-	O
1	int
)	O
this	pointer
->	O
current_entry	int
++	O
;	O
else	O
break	O
;	O
if	O
(	O
this	pointer
->	O
current_entry	int
-	O
this	pointer
->	O
first_on_screen	int
>=	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
{	O
this	pointer
->	O
first_on_screen	int
=	O
min	O
(	O
this	pointer
->	O
first_on_screen	int
+	O
this	pointer
->	O
scroll_step	int
,	O
this	pointer
->	O
entries	int
-	O
1	int
-	O
(	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
+	O
1	int
)	O
;	O
need_update_all	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
!	O
need_update	int
)	O
panel_update_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
-	O
1	int
)	O
;	O
need_update	int
=	O
1	int
;	O
}	O
if	O
(	O
need_update_all	int
)	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
else	O
if	O
(	O
need_update	int
)	O
panel_update_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
)	O
;	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_PGUP	int
:	O
if	O
(	O
this	pointer
->	O
current_entry	int
==	O
0	int
)	O
break	O
;	O
old_current_entry	int
=	O
this	pointer
->	O
current_entry	int
;	O
if	O
(	O
this	pointer
->	O
current_entry	int
<	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
panel_set_current_entry	function
(	O
this	pointer
,	O
0	int
)	O
;	O
else	O
panel_set_current_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
-	O
(	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
)	O
;	O
if	O
(	O
this	pointer
->	O
entries	int
>	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
else	O
{	O
panel_update_entry	function
(	O
this	pointer
,	O
old_current_entry	int
)	O
;	O
panel_update_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
)	O
;	O
}	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_PGDOWN	int
:	O
if	O
(	O
this	pointer
->	O
current_entry	int
==	O
this	pointer
->	O
entries	int
-	O
1	int
)	O
break	O
;	O
old_current_entry	int
=	O
this	pointer
->	O
current_entry	int
;	O
if	O
(	O
this	pointer
->	O
entries	int
-	O
1	int
-	O
this	pointer
->	O
first_on_screen	int
<	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
panel_set_current_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
entries	int
-	O
1	int
)	O
;	O
else	O
if	O
(	O
this	pointer
->	O
entries	int
-	O
1	int
-	O
this	pointer
->	O
current_entry	int
<	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
panel_set_current_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
entries	int
-	O
1	int
)	O
;	O
else	O
panel_set_current_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
+	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
;	O
if	O
(	O
this	pointer
->	O
entries	int
>	O
this	pointer
->	O
lines	int
-	O
2	int
)	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
else	O
{	O
panel_update_entry	function
(	O
this	pointer
,	O
old_current_entry	int
)	O
;	O
panel_update_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
current_entry	int
)	O
;	O
}	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_UP_ONE_DIR	int
:	O
if	O
(	O
rootdir	O
(	O
)	O
)	O
break	O
;	O
if	O
(	O
this	pointer
->	O
current_entry	int
!=	O
0	int
)	O
panel_set_current_entry	function
(	O
this	pointer
,	O
0	int
)	O
;	O
return	O
panel_act_ENTER	function
(	O
this	pointer
,	O
other	pointer
)	O
;	O
case	O
act_HOME	int
:	O
if	O
(	O
this	pointer
->	O
current_entry	int
!=	O
0	int
)	O
{	O
panel_set_current_entry	function
(	O
this	pointer
,	O
0	int
)	O
;	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
}	O
break	O
;	O
case	O
act_END	int
:	O
if	O
(	O
this	pointer
->	O
current_entry	int
!=	O
this	pointer
->	O
entries	int
-	O
1	int
)	O
{	O
panel_set_current_entry	function
(	O
this	pointer
,	O
this	pointer
->	O
entries	int
-	O
1	int
)	O
;	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
}	O
break	O
;	O
case	O
act_CHDIR	int
:	O
panel_act_CHDIR	function
(	O
this	pointer
,	O
other	pointer
,	O
(	O
char	O
*	O
)	O
aux_info	pointer
)	O
;	O
break	O
;	O
case	O
act_ENABLE_NEXT_MODE	int
:	O
this	pointer
->	O
display_mode	int
=	O
(	O
this	pointer
->	O
display_mode	int
+	O
1	int
)	O
%	O
FILE_DISPLAY_MODES	int
;	O
goto	O
all_display_modes	O
;	O
case	O
act_ENABLE_OWNER_GROUP	int
:	O
case	O
act_ENABLE_DATE_TIME	int
:	O
case	O
act_ENABLE_SIZE	int
:	O
case	O
act_ENABLE_MODE	int
:	O
case	O
act_ENABLE_FULL_NAME	int
:	O
case	O
act_ENABLE_ALL	int
:	O
this	pointer
->	O
display_mode	int
=	O
action	int
-	O
act_ENABLE_OWNER_GROUP	int
;	O
all_display_modes	O
:	O
if	O
(	O
this	pointer
->	O
columns	int
<	O
80	int
&&	O
this	pointer
->	O
display_mode	int
==	O
ENABLE_ALL	int
)	O
this	pointer
->	O
display_mode	int
=	O
ENABLE_OWNER_GROUP	int
;	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_SORT_NEXT_METHOD	int
:	O
this	pointer
->	O
sort_method	int
=	O
(	O
this	pointer
->	O
sort_method	int
+	O
1	int
)	O
%	O
FILE_SORT_METHODS	int
;	O
goto	O
all_sort_methodes	O
;	O
case	O
act_SORT_BY_NAME	int
:	O
case	O
act_SORT_BY_EXTENSION	int
:	O
case	O
act_SORT_BY_SIZE	int
:	O
case	O
act_SORT_BY_DATE	int
:	O
case	O
act_SORT_BY_MODE	int
:	O
case	O
act_SORT_BY_OWNER_ID	int
:	O
case	O
act_SORT_BY_GROUP_ID	int
:	O
case	O
act_SORT_BY_OWNER_NAME	int
:	O
case	O
act_SORT_BY_GROUP_NAME	int
:	O
this	pointer
->	O
sort_method	int
=	O
action	int
-	O
act_SORT_BY_NAME	int
;	O
all_sort_methodes	O
:	O
CurrentSortMethod	int
=	O
this	pointer
->	O
sort_method	int
;	O
previous	pointer
=	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
;	O
if	O
(	O
rootdir	O
(	O
)	O
)	O
qsort	function
(	O
this	pointer
->	O
dir_entry	pointer
,	O
this	pointer
->	O
entries	int
,	O
sizeof	O
(	O
dir_entry_t	struct
)	O
,	O
sort_compare_fn	function
)	O
;	O
else	O
qsort	function
(	O
this	pointer
->	O
dir_entry	pointer
+	O
1	int
,	O
this	pointer
->	O
entries	int
-	O
1	int
,	O
sizeof	O
(	O
dir_entry_t	struct
)	O
,	O
sort_compare_fn	function
)	O
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
previous	pointer
==	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
)	O
break	O
;	O
panel_set_current_entry	function
(	O
this	pointer
,	O
entry	int
)	O
;	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_SWITCH	int
:	O
xchg	function
(	O
&	O
this	pointer
->	O
lines	int
,	O
&	O
other	pointer
->	O
lines	int
)	O
;	O
xchg	function
(	O
&	O
this	pointer
->	O
columns	int
,	O
&	O
other	pointer
->	O
columns	int
)	O
;	O
xchg	function
(	O
&	O
this	pointer
->	O
x	int
,	O
&	O
other	pointer
->	O
x	int
)	O
;	O
xchg	function
(	O
&	O
this	pointer
->	O
y	int
,	O
&	O
other	pointer
->	O
y	int
)	O
;	O
panel_resize	function
(	O
this	pointer
,	O
this	pointer
->	O
x	int
,	O
this	pointer
->	O
y	int
,	O
this	pointer
->	O
lines	int
,	O
this	pointer
->	O
columns	int
)	O
;	O
panel_resize	function
(	O
other	pointer
,	O
other	pointer
->	O
x	int
,	O
other	pointer
->	O
y	int
,	O
other	pointer
->	O
lines	int
,	O
other	pointer
->	O
columns	int
)	O
;	O
break	O
;	O
case	O
act_PATTERN_SELECT	int
:	O
case	O
act_PATTERN_UNSELECT	int
:	O
safe_patterns	pointer
=	O
panel_parse_patterns	function
(	O
(	O
char	O
*	O
)	O
aux_info	pointer
)	O
;	O
for	O
(	O
patterns	pointer
=	O
safe_patterns	pointer
;	O
*	O
patterns	pointer
;	O
patterns	pointer
++	O
)	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
!=	O
DIR_ENTRY	int
)	O
{	O
int	O
fnm_flags	int
=	O
FNM_PATHNAME	O
;	O
if	O
(	O
LeadingDotMatch	int
==	O
OFF	int
)	O
fnm_flags	int
|=	O
FNM_PERIOD	O
;	O
if	O
(	O
fnmatch	function
(	O
*	O
patterns	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
,	O
fnm_flags	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
action	int
==	O
act_PATTERN_SELECT	int
)	O
{	O
if	O
(	O
!	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
1	int
;	O
this	pointer
->	O
selected_entries	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
0	int
;	O
this	pointer
->	O
selected_entries	int
--	O
;	O
}	O
}	O
}	O
}	O
panel_deallocate_patterns	function
(	O
safe_patterns	pointer
)	O
;	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_REGET	int
:	O
panel_act_REGET	function
(	O
this	pointer
,	O
aux_info	pointer
)	O
;	O
break	O
;	O
case	O
act_SET_SCROLL_STEP	int
:	O
new_scroll_step	int
=	O
atoi	function
(	O
(	O
char	O
*	O
)	O
aux_info	pointer
)	O
;	O
if	O
(	O
new_scroll_step	int
>	O
0	int
&&	O
new_scroll_step	int
<	O
this	pointer
->	O
lines	int
-	O
1	int
)	O
this	pointer
->	O
scroll_step	int
=	O
other	pointer
->	O
scroll_step	int
=	O
new_scroll_step	int
;	O
break	O
;	O
case	O
act_ISEARCH_BEGIN	int
:	O
this	pointer
->	O
isearch_stack	pointer
=	O
xstack_init	function
(	O
sizeof	O
(	O
isearch_t	struct
)	O
)	O
;	O
STACK_PUSH	O
(	O
this	pointer
->	O
current_entry	int
,	O
0	int
)	O
;	O
this	pointer
->	O
isearch_length	long
=	O
0	int
;	O
this	pointer
->	O
wrapped_isearch	char
=	O
0	int
;	O
break	O
;	O
case	O
act_ISEARCH_BACKWARD	int
:	O
iai	pointer
=	O
(	O
isearch_aux_t	struct
*	O
)	O
aux_info	pointer
;	O
len	long
=	O
strlen	function
(	O
iai	pointer
->	O
string	pointer
)	O
;	O
switch	O
(	O
iai	pointer
->	O
action	int
)	O
{	O
case	O
IL_ISEARCH_ACTION_NONE	int
:	O
break	O
;	O
case	O
IL_ISEARCH_ACTION_DECREASE	int
:	O
goto	O
isearch_action_decrease	O
;	O
case	O
IL_ISEARCH_ACTION_RETRY	int
:	O
if	O
(	O
!	O
this	pointer
->	O
wrapped_isearch	char
)	O
STACK_PUSH	O
(	O
this	pointer
->	O
current_entry	int
,	O
len	long
)	O
;	O
result	int
=	O
panel_isearch_backward	function
(	O
this	pointer
,	O
iai	pointer
->	O
string	pointer
,	O
len	long
,	O
this	pointer
->	O
wrapped_isearch	char
?	O
this	pointer
->	O
entries	int
-	O
1	int
:	O
this	pointer
->	O
current_entry	int
-	O
1	int
)	O
;	O
goto	O
isearch_backward_action_increase	O
;	O
case	O
IL_ISEARCH_ACTION_INCREASE	int
:	O
STACK_PUSH	O
(	O
this	pointer
->	O
current_entry	int
,	O
len	long
)	O
;	O
result	int
=	O
panel_isearch_backward	function
(	O
this	pointer
,	O
iai	pointer
->	O
string	pointer
,	O
len	long
,	O
this	pointer
->	O
current_entry	int
)	O
;	O
isearch_backward_action_increase	O
:	O
if	O
(	O
result	int
==	O
-	O
1	int
)	O
{	O
iai	pointer
->	O
action	int
=	O
IL_ISEARCH_ACTION_FAILED	O
;	O
break	O
;	O
}	O
else	O
this	pointer
->	O
isearch_length	long
=	O
len	long
;	O
if	O
(	O
this	pointer
->	O
wrapped_isearch	char
)	O
{	O
panel_set_current_entry	function
(	O
this	pointer
,	O
result	int
)	O
;	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
this	pointer
->	O
wrapped_isearch	char
=	O
0	int
;	O
}	O
else	O
panel_action	function
(	O
this	pointer
,	O
act_UP	int
,	O
other	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
this	pointer
->	O
current_entry	int
-	O
result	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
iai	pointer
->	O
length	long
=	O
this	pointer
->	O
isearch_length	long
;	O
break	O
;	O
case	O
act_ISEARCH_FORWARD	int
:	O
iai	pointer
=	O
(	O
isearch_aux_t	struct
*	O
)	O
aux_info	pointer
;	O
len	long
=	O
strlen	function
(	O
iai	pointer
->	O
string	pointer
)	O
;	O
switch	O
(	O
iai	pointer
->	O
action	int
)	O
{	O
case	O
IL_ISEARCH_ACTION_NONE	int
:	O
break	O
;	O
case	O
IL_ISEARCH_ACTION_DECREASE	int
:	O
isearch_action_decrease	O
:	O
{	O
int	O
prev_entry	int
;	O
size_t	long
prev_length	long
;	O
STACK_POP	O
(	O
prev_entry	int
,	O
prev_length	long
)	O
;	O
if	O
(	O
this	pointer
->	O
isearch_length	long
!=	O
len	long
)	O
break	O
;	O
if	O
(	O
this	pointer
->	O
current_entry	int
<	O
prev_entry	int
)	O
panel_action	function
(	O
this	pointer
,	O
act_DOWN	int
,	O
other	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
prev_entry	int
-	O
this	pointer
->	O
current_entry	int
)	O
;	O
else	O
if	O
(	O
this	pointer
->	O
current_entry	int
>	O
prev_entry	int
)	O
panel_action	function
(	O
this	pointer
,	O
act_UP	int
,	O
other	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
this	pointer
->	O
current_entry	int
-	O
prev_entry	int
)	O
;	O
STACK_PREVIEW	O
(	O
prev_entry	int
,	O
prev_length	long
)	O
;	O
this	pointer
->	O
isearch_length	long
=	O
prev_length	long
;	O
}	O
break	O
;	O
case	O
IL_ISEARCH_ACTION_RETRY	int
:	O
if	O
(	O
!	O
this	pointer
->	O
wrapped_isearch	char
)	O
STACK_PUSH	O
(	O
this	pointer
->	O
current_entry	int
,	O
len	long
)	O
;	O
result	int
=	O
panel_isearch_forward	function
(	O
this	pointer
,	O
iai	pointer
->	O
string	pointer
,	O
len	long
,	O
this	pointer
->	O
wrapped_isearch	char
?	O
0	int
:	O
this	pointer
->	O
current_entry	int
+	O
1	int
)	O
;	O
goto	O
isearch_forward_action_increase	O
;	O
case	O
IL_ISEARCH_ACTION_INCREASE	int
:	O
STACK_PUSH	O
(	O
this	pointer
->	O
current_entry	int
,	O
len	long
)	O
;	O
result	int
=	O
panel_isearch_forward	function
(	O
this	pointer
,	O
iai	pointer
->	O
string	pointer
,	O
len	long
,	O
this	pointer
->	O
current_entry	int
)	O
;	O
isearch_forward_action_increase	O
:	O
if	O
(	O
result	int
==	O
-	O
1	int
)	O
{	O
iai	pointer
->	O
action	int
=	O
IL_ISEARCH_ACTION_FAILED	O
;	O
break	O
;	O
}	O
else	O
this	pointer
->	O
isearch_length	long
=	O
len	long
;	O
if	O
(	O
this	pointer
->	O
wrapped_isearch	char
)	O
{	O
panel_set_current_entry	function
(	O
this	pointer
,	O
result	int
)	O
;	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
this	pointer
->	O
wrapped_isearch	char
=	O
0	int
;	O
}	O
else	O
panel_action	function
(	O
this	pointer
,	O
act_DOWN	int
,	O
other	pointer
,	O
(	O
void	O
*	O
)	O
NULL	O
,	O
result	int
-	O
this	pointer
->	O
current_entry	int
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
iai	pointer
->	O
length	long
=	O
this	pointer
->	O
isearch_length	long
;	O
break	O
;	O
case	O
act_ISEARCH_END	int
:	O
xstack_end	function
(	O
this	pointer
->	O
isearch_stack	pointer
)	O
;	O
this	pointer
->	O
isearch_stack	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
act_CMPDIR	int
:	O
panel_act_CMPDIR	function
(	O
this	pointer
,	O
other	pointer
,	O
*	O
(	O
int	O
*	O
)	O
aux_info	pointer
)	O
;	O
break	O
;	O
case	O
act_CASE	int
:	O
panel_act_CASE	function
(	O
this	pointer
,	O
other	pointer
,	O
*	O
(	O
int	O
*	O
)	O
aux_info	pointer
)	O
;	O
break	O
;	O
case	O
act_COMPARE	int
:	O
panel_act_COMPARE	function
(	O
this	pointer
,	O
other	pointer
)	O
;	O
break	O
;	O
case	O
act_BIN_PACKING	int
:	O
panel_act_BIN_PACKING	function
(	O
this	pointer
,	O
other	pointer
,	O
(	O
off64_t	long
)	O
atoi	function
(	O
(	O
char	O
*	O
)	O
aux_info	pointer
)	O
)	O
;	O
break	O
;	O
case	O
act_HORIZONTAL_SCROLL_LEFT	int
:	O
this	pointer
->	O
horizontal_offset	int
-=	O
repeat_count	int
;	O
if	O
(	O
this	pointer
->	O
horizontal_offset	int
<	O
0	int
)	O
this	pointer
->	O
horizontal_offset	int
=	O
0	int
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_HORIZONTAL_SCROLL_RIGHT	int
:	O
this	pointer
->	O
horizontal_offset	int
+=	O
repeat_count	int
;	O
max_offset	int
=	O
(	O
this	pointer
->	O
maxname	int
+	O
1	int
)	O
-	O
(	O
this	pointer
->	O
columns	int
-	O
panel_get_reserved_characters	function
(	O
this	pointer
)	O
)	O
;	O
if	O
(	O
max_offset	int
<	O
0	int
)	O
max_offset	int
=	O
0	int
;	O
if	O
(	O
this	pointer
->	O
horizontal_offset	int
>=	O
max_offset	int
)	O
this	pointer
->	O
horizontal_offset	int
=	O
max_offset	int
;	O
panel_update	function
(	O
this	pointer
)	O
;	O
break	O
;	O
case	O
act_SELECT_EXTENSION	int
:	O
case	O
act_UNSELECT_EXTENSION	int
:	O
ptr	pointer
=	O
strrchr	function
(	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
,	O
'.'	O
)	O
;	O
if	O
(	O
ptr	pointer
==	O
this	pointer
->	O
dir_entry	pointer
[	O
this	pointer
->	O
current_entry	int
]	O
.	O
name	pointer
||	O
ptr	pointer
==	O
NULL	O
)	O
break	O
;	O
extension	pointer
=	O
(	O
char	O
*	O
)	O
malloc	function
(	O
1	int
+	O
strlen	function
(	O
ptr	pointer
)	O
+	O
1	int
)	O
;	O
sprintf	function
(	O
extension	pointer
,	O
"*%s"	pointer
,	O
ptr	pointer
)	O
;	O
for	O
(	O
entry	int
=	O
0	int
;	O
entry	int
<	O
this	pointer
->	O
entries	int
;	O
entry	int
++	O
)	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
type	enum
!=	O
DIR_ENTRY	int
)	O
{	O
int	O
fnm_flags	int
=	O
FNM_PATHNAME	O
;	O
if	O
(	O
LeadingDotMatch	int
==	O
OFF	int
)	O
fnm_flags	int
|=	O
FNM_PERIOD	O
;	O
if	O
(	O
fnmatch	function
(	O
extension	pointer
,	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
name	pointer
,	O
fnm_flags	int
)	O
==	O
0	int
)	O
{	O
if	O
(	O
action	int
==	O
act_SELECT_EXTENSION	int
)	O
{	O
if	O
(	O
!	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
1	int
;	O
this	pointer
->	O
selected_entries	int
++	O
;	O
}	O
}	O
else	O
{	O
if	O
(	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
)	O
{	O
this	pointer
->	O
dir_entry	pointer
[	O
entry	int
]	O
.	O
selected	char
=	O
0	int
;	O
this	pointer
->	O
selected_entries	int
--	O
;	O
}	O
}	O
}	O
}	O
panel_update_entries	function
(	O
this	pointer
)	O
;	O
panel_update_info	function
(	O
this	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fatal	function
(	O
"no action"	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
