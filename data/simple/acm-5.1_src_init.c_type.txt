extern	O
craftType	struct
*	O
newCraft	function
(	O
void	O
)	O
;	O
extern	O
int	O
compileAircraftInventory	function
(	O
void	O
)	O
;	O
extern	O
void	O
initaim9	function
(	O
void	O
)	O
,	O
initm61a1	function
(	O
void	O
)	O
,	O
initmk82	function
(	O
void	O
)	O
,	O
initaim120	function
(	O
void	O
)	O
;	O
extern	O
void	O
buildExplosion	function
(	O
void	O
)	O
;	O
extern	O
void	O
placeObject	function
(	O
)	O
;	O
extern	O
void	O
InitNavaidSystem	function
(	O
)	O
;	O
extern	O
void	O
DMECheckAlarm	function
(	O
char	O
*	O
arg1	pointer
,	O
char	O
*	O
arg2	pointer
)	O
;	O
extern	O
void	O
resupplyCheck	function
(	O
char	O
*	O
arg1	pointer
,	O
char	O
*	O
arg2	pointer
)	O
;	O
extern	O
void	O
acm_srand	function
PARAMS	O
(	O
(	O
int	O
seed	int
)	O
)	O
;	O
extern	O
void	O
addAltitudeEntry	function
(	O
WorldCoordinates	struct
*	O
w	pointer
)	O
;	O
extern	O
int	O
AddNavaid	function
(	O
char	O
*	O
ident	pointer
,	O
char	O
*	O
type	pointer
,	O
WorldCoordinates	struct
*	O
w	pointer
,	O
char	O
*	O
magvar	double
,	O
double	O
freq	float
)	O
;	O
extern	O
int	O
AddILS	function
(	O
char	O
*	O
ident	pointer
,	O
char	O
*	O
type	pointer
,	O
WorldCoordinates	struct
*	O
w	pointer
,	O
WorldCoordinates	struct
*	O
gsw	pointer
,	O
char	O
*	O
magvar	double
,	O
double	O
freq	float
,	O
double	O
loc_width	double
,	O
double	O
loc_bearing	double
,	O
double	O
gs_angle	double
)	O
;	O
extern	O
VPolygon	struct
*	O
*	O
poly	pointer
;	O
extern	O
long	O
polyCount	long
;	O
void	O
undersampleObject	function
(	O
VObject	struct
*	O
obj	pointer
,	O
int	O
rate	short
)	O
;	O
static	O
char	O
*	O
errmsg	pointer
=	O
"Sorry, I cannot find the file %s in %s\n"	pointer
;	O
extern	O
void	O
AddRunway	function
(	O
VMatrix	struct
*	O
RWYtoXYZ	pointer
,	O
double	O
length	int
,	O
double	O
width	int
,	O
int	O
flags	short
,	O
VPolygon	struct
*	O
*	O
*	O
poly	pointer
,	O
int	O
*	O
poly_count	pointer
)	O
;	O
char	O
_acm_fopen_library_dir	array
[	O
]	O
=	O
ACM_LIBRARY	O
;	O
FILE	struct
*	O
acm_fopen	function
(	O
char	O
*	O
name	pointer
,	O
char	O
*	O
access	function
)	O
{	O
FILE	struct
*	O
f	struct
;	O
char	O
libname	array
[	O
256	int
]	O
;	O
if	O
(	O
(	O
f	struct
=	O
fopen	function
(	O
name	pointer
,	O
access	function
)	O
)	O
==	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
{	O
strcpy	function
(	O
libname	array
,	O
_acm_fopen_library_dir	array
)	O
;	O
strcat	function
(	O
libname	array
,	O
name	pointer
)	O
;	O
if	O
(	O
(	O
f	struct
=	O
fopen	function
(	O
libname	array
,	O
access	function
)	O
)	O
==	O
(	O
FILE	struct
*	O
)	O
NULL	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
errmsg	pointer
,	O
name	pointer
,	O
_acm_fopen_library_dir	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
return	O
f	struct
;	O
}	O
char	O
*	O
acm_find_file	function
(	O
char	O
*	O
name	pointer
)	O
{	O
static	O
char	O
pname	array
[	O
1024	int
]	O
;	O
struct	O
stat	struct
statbuf	struct
;	O
strcpy	function
(	O
pname	array
,	O
name	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
name	pointer
,	O
&	O
statbuf	struct
)	O
!=	O
0	int
)	O
{	O
strcpy	function
(	O
pname	array
,	O
_acm_fopen_library_dir	array
)	O
;	O
strcat	function
(	O
pname	array
,	O
name	pointer
)	O
;	O
if	O
(	O
stat	struct
(	O
pname	array
,	O
&	O
statbuf	struct
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
errmsg	pointer
,	O
name	pointer
,	O
_acm_fopen_library_dir	array
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
}	O
return	O
pname	array
;	O
}	O
enum	O
state_t	enum
{	O
SKIPPING_SPACES	int
,	O
ARGUMENT	int
}	O
;	O
int	O
split	function
(	O
char	O
*	O
s	double
,	O
int	O
*	O
argc	pointer
,	O
char	O
*	O
argv	array
[	O
]	O
)	O
{	O
int	O
done	int
=	O
0	int
;	O
enum	O
state_t	enum
state	pointer
=	O
SKIPPING_SPACES	int
;	O
*	O
argc	pointer
=	O
0	int
;	O
for	O
(	O
;	O
done	int
==	O
0	int
;	O
++	O
s	double
)	O
{	O
switch	O
(	O
state	pointer
)	O
{	O
case	O
SKIPPING_SPACES	int
:	O
if	O
(	O
isspace	O
(	O
*	O
s	double
)	O
)	O
{	O
}	O
else	O
if	O
(	O
isascii	function
(	O
*	O
s	double
)	O
)	O
{	O
argv	array
[	O
*	O
argc	pointer
]	O
=	O
s	double
;	O
(	O
*	O
argc	pointer
)	O
++	O
;	O
state	pointer
=	O
ARGUMENT	int
;	O
}	O
else	O
if	O
(	O
*	O
s	double
==	O
'\0'	O
)	O
{	O
done	int
=	O
1	int
;	O
}	O
break	O
;	O
case	O
ARGUMENT	int
:	O
if	O
(	O
isspace	O
(	O
*	O
s	double
)	O
)	O
{	O
*	O
s	double
=	O
'\0'	O
;	O
state	pointer
=	O
SKIPPING_SPACES	int
;	O
}	O
else	O
if	O
(	O
*	O
s	double
==	O
'\0'	O
)	O
{	O
*	O
s	double
=	O
'\0'	O
;	O
done	int
=	O
1	int
;	O
}	O
}	O
}	O
return	O
0	int
;	O
}	O
int	O
readScene	function
(	O
char	O
*	O
ground	pointer
,	O
int	O
len	int
)	O
{	O
FILE	struct
*	O
f	struct
,	O
*	O
f1	pointer
;	O
char	O
file	pointer
[	O
256	int
]	O
,	O
*	O
name	pointer
,	O
*	O
filep	pointer
;	O
char	O
*	O
argv	array
[	O
32	int
]	O
,	O
line	array
[	O
1024	int
]	O
;	O
char	O
lat	array
[	O
64	int
]	O
,	O
lon	array
[	O
64	int
]	O
,	O
lat_lon	array
[	O
64	int
]	O
;	O
double	O
z	short
,	O
heading	double
,	O
freq	float
,	O
mag	double
,	O
length	int
,	O
width	int
;	O
int	O
s	double
,	O
i	int
=	O
0	int
,	O
j	int
,	O
undersample	int
,	O
depthcue	int
,	O
argc	pointer
;	O
craftType	struct
*	O
c	pointer
;	O
extern	O
char	O
*	O
sceneFile	pointer
;	O
VPoint	struct
scale	double
,	O
down	struct
,	O
local_fwd	struct
,	O
local_right	struct
,	O
local_down	struct
;	O
int	O
done	int
=	O
0	int
;	O
WorldCoordinates	struct
w	pointer
,	O
w1	struct
,	O
w2	struct
,	O
gsw	pointer
;	O
dis_world_coordinates	struct
xyz	struct
,	O
xyz1	struct
;	O
double	O
loc_width	double
,	O
loc_bearing	double
,	O
gs_angle	double
;	O
VObject	struct
*	O
object	pointer
=	O
NULL	O
;	O
VPolygon	struct
*	O
*	O
rpoly	pointer
;	O
int	O
rpoly_count	int
;	O
VMatrix	struct
RWYtoXYZ	pointer
,	O
XYZtoNED	struct
;	O
vl_head	pointer
=	O
vl_tail	pointer
=	O
NULL	O
;	O
vl_count	int
=	O
0	int
;	O
rpoly	pointer
=	O
NULL	O
;	O
rpoly_count	int
=	O
0	int
;	O
name	pointer
=	O
(	O
sceneFile	pointer
)	O
?	O
sceneFile	pointer
:	O
"default-scene"	pointer
;	O
scale	double
.	O
x	float
=	O
scale	double
.	O
y	short
=	O
scale	double
.	O
z	short
=	O
FEETtoMETERS	O
(	O
1.0	int
)	O
;	O
VSetReadObjectScale	function
(	O
&	O
scale	double
)	O
;	O
f	struct
=	O
acm_fopen	function
(	O
name	pointer
,	O
"r"	pointer
)	O
;	O
fscanf	function
(	O
f	struct
,	O
"%s %s %lf %lf"	pointer
,	O
lat	array
,	O
lon	array
,	O
&	O
z	short
,	O
&	O
heading	double
)	O
;	O
strcat	function
(	O
lat	array
,	O
lon	array
)	O
;	O
DISStringToLatLong	function
(	O
lat	array
,	O
&	O
teamLatLon	array
[	O
1	int
]	O
)	O
;	O
teamLatLon	array
[	O
1	int
]	O
.	O
z	short
=	O
FEETtoMETERS	O
(	O
z	short
)	O
;	O
teamHeading	array
[	O
1	int
]	O
=	O
DEGtoRAD	O
(	O
heading	double
)	O
;	O
fscanf	function
(	O
f	struct
,	O
"%s %s %lf %lf"	pointer
,	O
lat	array
,	O
lon	array
,	O
&	O
z	short
,	O
&	O
heading	double
)	O
;	O
strcat	function
(	O
lat	array
,	O
lon	array
)	O
;	O
DISStringToLatLong	function
(	O
lat	array
,	O
&	O
teamLatLon	array
[	O
2	int
]	O
)	O
;	O
teamLatLon	array
[	O
2	int
]	O
.	O
z	short
=	O
FEETtoMETERS	O
(	O
z	short
)	O
;	O
teamHeading	array
[	O
2	int
]	O
=	O
DEGtoRAD	O
(	O
heading	double
)	O
;	O
ground	pointer
[	O
0	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
fgets	function
(	O
ground	pointer
,	O
len	int
,	O
f	struct
)	O
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
fgets	function
(	O
ground	pointer
,	O
len	int
,	O
f	struct
)	O
==	O
(	O
char	O
*	O
)	O
NULL	O
)	O
{	O
return	O
-	O
1	int
;	O
}	O
len	int
=	O
strlen	function
(	O
ground	pointer
)	O
;	O
if	O
(	O
len	int
>	O
0	int
&&	O
ground	pointer
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
ground	pointer
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
if	O
(	O
len	int
>	O
0	int
&&	O
ground	pointer
[	O
len	int
-	O
2	int
]	O
==	O
'\r'	O
)	O
{	O
ground	pointer
[	O
len	int
-	O
2	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
fgets	function
(	O
line	array
,	O
sizeof	O
(	O
line	array
)	O
,	O
f	struct
)	O
;	O
done	int
=	O
0	int
;	O
while	O
(	O
done	int
==	O
0	int
)	O
{	O
len	int
=	O
strlen	function
(	O
line	array
)	O
;	O
if	O
(	O
len	int
>	O
0	int
&&	O
line	array
[	O
len	int
-	O
1	int
]	O
==	O
'\n'	O
)	O
{	O
line	array
[	O
len	int
-	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
split	function
(	O
line	array
,	O
&	O
argc	pointer
,	O
argv	array
)	O
;	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
0	int
]	O
,	O
"RWY"	pointer
)	O
==	O
0	int
)	O
{	O
length	int
=	O
FEETtoMETERS	O
(	O
atoi	function
(	O
argv	array
[	O
4	int
]	O
)	O
)	O
;	O
width	int
=	O
FEETtoMETERS	O
(	O
atoi	function
(	O
argv	array
[	O
5	int
]	O
)	O
)	O
;	O
strcpy	function
(	O
lat_lon	array
,	O
argv	array
[	O
6	int
]	O
)	O
;	O
strcat	function
(	O
lat_lon	array
,	O
argv	array
[	O
7	int
]	O
)	O
;	O
DISStringToLatLong	function
(	O
lat_lon	array
,	O
&	O
w	pointer
)	O
;	O
w	pointer
.	O
z	short
=	O
FEETtoMETERS	O
(	O
atoi	function
(	O
argv	array
[	O
3	int
]	O
)	O
)	O
;	O
addAltitudeEntry	function
(	O
&	O
w	pointer
)	O
;	O
strcpy	function
(	O
lat_lon	array
,	O
argv	array
[	O
8	int
]	O
)	O
;	O
strcat	function
(	O
lat_lon	array
,	O
argv	array
[	O
9	int
]	O
)	O
;	O
DISStringToLatLong	function
(	O
lat_lon	array
,	O
&	O
w1	struct
)	O
;	O
w1	struct
.	O
z	short
=	O
w	pointer
.	O
z	short
;	O
DISWorldCoordinatesToGeocentric	function
(	O
&	O
w	pointer
,	O
(	O
dis_world_coordinates	struct
*	O
)	O
&	O
xyz	struct
)	O
;	O
mag	double
=	O
sqrt	function
(	O
xyz	struct
.	O
x	float
*	O
xyz	struct
.	O
x	float
+	O
xyz	struct
.	O
y	short
*	O
xyz	struct
.	O
y	short
+	O
xyz	struct
.	O
z	short
*	O
xyz	struct
.	O
z	short
)	O
;	O
DISWorldCoordinatesToGeocentric	function
(	O
&	O
w1	struct
,	O
(	O
dis_world_coordinates	struct
*	O
)	O
&	O
xyz1	struct
)	O
;	O
local_fwd	struct
.	O
x	float
=	O
xyz1	struct
.	O
x	float
-	O
xyz	struct
.	O
x	float
;	O
local_fwd	struct
.	O
y	short
=	O
xyz1	struct
.	O
y	short
-	O
xyz	struct
.	O
y	short
;	O
local_fwd	struct
.	O
z	short
=	O
xyz1	struct
.	O
z	short
-	O
xyz	struct
.	O
z	short
;	O
xyz	struct
.	O
x	float
=	O
(	O
xyz	struct
.	O
x	float
+	O
xyz1	struct
.	O
x	float
)	O
/	O
2.0	int
;	O
xyz	struct
.	O
y	short
=	O
(	O
xyz	struct
.	O
y	short
+	O
xyz1	struct
.	O
y	short
)	O
/	O
2.0	int
;	O
xyz	struct
.	O
z	short
=	O
(	O
xyz	struct
.	O
z	short
+	O
xyz1	struct
.	O
z	short
)	O
/	O
2.0	int
;	O
DISGeocentricToWorldCoordinates	function
(	O
&	O
xyz	struct
,	O
&	O
w2	struct
)	O
;	O
GenerateWorldToLocalMatrix	function
(	O
&	O
w2	struct
,	O
&	O
XYZtoNED	struct
)	O
;	O
down	struct
.	O
z	short
=	O
1.0	int
;	O
down	struct
.	O
x	float
=	O
down	struct
.	O
y	short
=	O
0.0	int
;	O
VReverseTransform_	function
(	O
&	O
down	struct
,	O
&	O
XYZtoNED	struct
,	O
&	O
local_down	struct
)	O
;	O
mag	double
=	O
sqrt	function
(	O
local_fwd	struct
.	O
x	float
*	O
local_fwd	struct
.	O
x	float
+	O
local_fwd	struct
.	O
y	short
*	O
local_fwd	struct
.	O
y	short
+	O
local_fwd	struct
.	O
z	short
*	O
local_fwd	struct
.	O
z	short
)	O
;	O
local_fwd	struct
.	O
x	float
/=	O
mag	double
;	O
local_fwd	struct
.	O
y	short
/=	O
mag	double
;	O
local_fwd	struct
.	O
z	short
/=	O
mag	double
;	O
VCrossProd	function
(	O
&	O
local_down	struct
,	O
&	O
local_fwd	struct
,	O
&	O
local_right	struct
)	O
;	O
VIdentMatrix	function
(	O
&	O
RWYtoXYZ	pointer
)	O
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
0	int
]	O
[	O
0	int
]	O
=	O
local_fwd	struct
.	O
x	float
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
1	int
]	O
[	O
0	int
]	O
=	O
local_fwd	struct
.	O
y	short
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
2	int
]	O
[	O
0	int
]	O
=	O
local_fwd	struct
.	O
z	short
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
0	int
]	O
[	O
1	int
]	O
=	O
local_right	struct
.	O
x	float
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
1	int
]	O
[	O
1	int
]	O
=	O
local_right	struct
.	O
y	short
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
2	int
]	O
[	O
1	int
]	O
=	O
local_right	struct
.	O
z	short
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
0	int
]	O
[	O
2	int
]	O
=	O
local_down	struct
.	O
x	float
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
1	int
]	O
[	O
2	int
]	O
=	O
local_down	struct
.	O
y	short
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
2	int
]	O
[	O
2	int
]	O
=	O
local_down	struct
.	O
z	short
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
0	int
]	O
[	O
3	int
]	O
=	O
xyz	struct
.	O
x	float
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
1	int
]	O
[	O
3	int
]	O
=	O
xyz	struct
.	O
y	short
;	O
RWYtoXYZ	pointer
.	O
m	float
[	O
2	int
]	O
[	O
3	int
]	O
=	O
xyz	struct
.	O
z	short
;	O
AddRunway	function
(	O
&	O
RWYtoXYZ	pointer
,	O
length	int
,	O
width	int
,	O
0	int
,	O
&	O
rpoly	pointer
,	O
&	O
rpoly_count	int
)	O
;	O
if	O
(	O
(	O
object	pointer
!=	O
NULL	O
)	O
&&	O
(	O
strcmp	function
(	O
object	pointer
->	O
name	pointer
,	O
argv	array
[	O
1	int
]	O
)	O
==	O
0	int
)	O
)	O
{	O
object	pointer
->	O
polygon	pointer
=	O
(	O
VPolygon	struct
*	O
*	O
)	O
realloc	function
(	O
object	pointer
->	O
polygon	pointer
,	O
sizeof	O
(	O
VPolygon	struct
*	O
)	O
*	O
(	O
object	pointer
->	O
numPolys	int
+	O
rpoly_count	int
)	O
)	O
;	O
if	O
(	O
!	O
object	pointer
->	O
polygon	pointer
)	O
{	O
printf	function
(	O
"memory allocation error\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
rpoly_count	int
;	O
++	O
j	int
)	O
{	O
object	pointer
->	O
polygon	pointer
[	O
object	pointer
->	O
numPolys	int
+	O
j	int
]	O
=	O
rpoly	pointer
[	O
j	int
]	O
;	O
}	O
object	pointer
->	O
numPolys	int
+=	O
rpoly_count	int
;	O
free	function
(	O
rpoly	pointer
)	O
;	O
rpoly_count	int
=	O
0	int
;	O
VComputeObjectExtent	function
(	O
object	pointer
)	O
;	O
}	O
else	O
{	O
object	pointer
=	O
(	O
VObject	struct
*	O
)	O
Vmalloc	function
(	O
sizeof	O
(	O
VObject	struct
)	O
)	O
;	O
memset	function
(	O
object	pointer
,	O
0	int
,	O
sizeof	O
(	O
VObject	struct
)	O
)	O
;	O
object	pointer
->	O
name	pointer
=	O
strdup	function
(	O
argv	array
[	O
1	int
]	O
)	O
;	O
object	pointer
->	O
numPolys	int
=	O
rpoly_count	int
;	O
object	pointer
->	O
polygon	pointer
=	O
rpoly	pointer
;	O
object	pointer
->	O
order	pointer
=	O
(	O
unsigned	O
short	O
*	O
)	O
NULL	O
;	O
VComputeObjectExtent	function
(	O
object	pointer
)	O
;	O
stbl	array
[	O
i	int
]	O
.	O
type	pointer
=	O
CT_SURFACE	int
;	O
stbl	array
[	O
i	int
]	O
.	O
flags	short
=	O
FL_FIXED_OBJECT	O
;	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
=	O
newCraft	function
(	O
)	O
;	O
if	O
(	O
!	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Out of craft types while loading scene.\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
->	O
name	pointer
=	O
strdup	function
(	O
argv	array
[	O
1	int
]	O
)	O
;	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
->	O
object	pointer
=	O
object	pointer
;	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
->	O
placeProc	pointer
=	O
NULL	O
;	O
stbl	array
[	O
i	int
]	O
.	O
curHeading	double
=	O
stbl	array
[	O
i	int
]	O
.	O
curPitch	double
=	O
stbl	array
[	O
i	int
]	O
.	O
curRoll	double
=	O
0.0	int
;	O
stbl	array
[	O
i	int
]	O
.	O
Sg	struct
.	O
x	float
=	O
stbl	array
[	O
i	int
]	O
.	O
Sg	struct
.	O
y	short
=	O
stbl	array
[	O
i	int
]	O
.	O
Sg	struct
.	O
z	short
=	O
0.0	int
;	O
if	O
(	O
++	O
i	int
==	O
MAXSURFACE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Only the first %d surface objects will be displayed.\n"	pointer
,	O
MAXSURFACE	int
)	O
;	O
i	int
=	O
MAXSURFACE	int
-	O
1	int
;	O
}	O
}	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
0	int
]	O
,	O
"NAV"	pointer
)	O
==	O
0	int
)	O
{	O
strcpy	function
(	O
lat_lon	array
,	O
argv	array
[	O
3	int
]	O
)	O
;	O
strcat	function
(	O
lat_lon	array
,	O
argv	array
[	O
4	int
]	O
)	O
;	O
DISStringToLatLong	function
(	O
lat_lon	array
,	O
&	O
w	pointer
)	O
;	O
w	pointer
.	O
z	short
=	O
FEETtoMETERS	O
(	O
atoi	function
(	O
argv	array
[	O
5	int
]	O
)	O
)	O
;	O
freq	float
=	O
strtod	function
(	O
argv	array
[	O
7	int
]	O
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
AddNavaid	function
(	O
argv	array
[	O
1	int
]	O
,	O
argv	array
[	O
2	int
]	O
,	O
&	O
w	pointer
,	O
argv	array
[	O
6	int
]	O
,	O
freq	float
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
0	int
]	O
,	O
"ILS"	pointer
)	O
==	O
0	int
)	O
{	O
strcpy	function
(	O
lat_lon	array
,	O
argv	array
[	O
5	int
]	O
)	O
;	O
strcat	function
(	O
lat_lon	array
,	O
argv	array
[	O
6	int
]	O
)	O
;	O
DISStringToLatLong	function
(	O
lat_lon	array
,	O
&	O
w	pointer
)	O
;	O
w	pointer
.	O
z	short
=	O
FEETtoMETERS	O
(	O
atoi	function
(	O
argv	array
[	O
9	int
]	O
)	O
)	O
;	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
7	int
]	O
,	O
"-"	pointer
)	O
!=	O
0	int
)	O
{	O
strcpy	function
(	O
lat_lon	array
,	O
argv	array
[	O
7	int
]	O
)	O
;	O
strcat	function
(	O
lat_lon	array
,	O
argv	array
[	O
8	int
]	O
)	O
;	O
DISStringToLatLong	function
(	O
lat_lon	array
,	O
&	O
gsw	pointer
)	O
;	O
gsw	pointer
.	O
z	short
=	O
w	pointer
.	O
z	short
;	O
}	O
freq	float
=	O
strtod	function
(	O
argv	array
[	O
4	int
]	O
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
loc_width	double
=	O
strtod	function
(	O
argv	array
[	O
11	int
]	O
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
loc_bearing	double
=	O
strtod	function
(	O
argv	array
[	O
12	int
]	O
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
gs_angle	double
=	O
strtod	function
(	O
argv	array
[	O
13	int
]	O
,	O
(	O
char	O
*	O
*	O
)	O
NULL	O
)	O
;	O
AddILS	function
(	O
argv	array
[	O
3	int
]	O
,	O
argv	array
[	O
2	int
]	O
,	O
&	O
w	pointer
,	O
&	O
gsw	pointer
,	O
argv	array
[	O
10	int
]	O
,	O
freq	float
,	O
loc_width	double
,	O
loc_bearing	double
,	O
gs_angle	double
)	O
;	O
}	O
else	O
if	O
(	O
strcmp	function
(	O
argv	array
[	O
0	int
]	O
,	O
"FEATURES"	pointer
)	O
==	O
0	int
)	O
{	O
done	int
=	O
1	int
;	O
}	O
if	O
(	O
done	int
==	O
0	int
)	O
{	O
fgets	function
(	O
line	array
,	O
sizeof	O
(	O
line	array
)	O
,	O
f	struct
)	O
;	O
}	O
}	O
while	O
(	O
s	double
=	O
fscanf	function
(	O
f	struct
,	O
"%s %s %s %lf %lf"	pointer
,	O
file	pointer
,	O
lat	array
,	O
lon	array
,	O
&	O
z	short
,	O
&	O
heading	double
)	O
==	O
5	int
)	O
{	O
depthcue	int
=	O
1	int
;	O
if	O
(	O
file	pointer
[	O
0	int
]	O
==	O
'@'	O
)	O
{	O
filep	pointer
=	O
&	O
file	pointer
[	O
1	int
]	O
;	O
undersample	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
file	pointer
[	O
0	int
]	O
==	O
'+'	O
)	O
{	O
filep	pointer
=	O
&	O
file	pointer
[	O
1	int
]	O
;	O
depthcue	int
=	O
0	int
;	O
}	O
else	O
{	O
filep	pointer
=	O
file	pointer
;	O
undersample	int
=	O
0	int
;	O
}	O
stbl	array
[	O
i	int
]	O
.	O
type	pointer
=	O
CT_SURFACE	int
;	O
if	O
(	O
(	O
c	pointer
=	O
lookupCraft	function
(	O
filep	pointer
)	O
)	O
)	O
{	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
=	O
c	pointer
;	O
}	O
else	O
{	O
char	O
*	O
p	pointer
=	O
strrchr	function
(	O
filep	pointer
,	O
'.'	O
)	O
;	O
f1	pointer
=	O
acm_fopen	function
(	O
filep	pointer
,	O
"r"	pointer
)	O
;	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
=	O
newCraft	function
(	O
)	O
;	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
->	O
name	pointer
=	O
strdup	function
(	O
filep	pointer
)	O
;	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
->	O
object	pointer
=	O
NULL	O
;	O
if	O
(	O
p	pointer
!=	O
NULL	O
&&	O
(	O
strcmp	function
(	O
p	pointer
,	O
".dxf"	pointer
)	O
==	O
0	int
||	O
strcmp	function
(	O
p	pointer
,	O
".DXF"	pointer
)	O
==	O
0	int
)	O
)	O
{	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
->	O
object	pointer
=	O
VReadDepthCueuedDXFObject	function
(	O
f1	pointer
,	O
depthcue	int
)	O
;	O
}	O
else	O
{	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
->	O
object	pointer
=	O
VReadDepthCueuedObject	function
(	O
f1	pointer
,	O
depthcue	int
)	O
;	O
}	O
if	O
(	O
!	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
->	O
object	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Error reading object %s\n"	pointer
,	O
filep	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
undersample	int
)	O
{	O
undersampleObject	function
(	O
stbl	array
[	O
i	int
]	O
.	O
cinfo	pointer
->	O
object	pointer
,	O
3	int
)	O
;	O
}	O
fclose	function
(	O
f1	pointer
)	O
;	O
}	O
strcat	function
(	O
lat	array
,	O
lon	array
)	O
;	O
DISStringToLatLong	function
(	O
lat	array
,	O
&	O
stbl	array
[	O
i	int
]	O
.	O
w	pointer
)	O
;	O
stbl	array
[	O
i	int
]	O
.	O
w	pointer
.	O
z	short
=	O
FEETtoMETERS	O
(	O
z	short
)	O
;	O
DISWorldCoordinatesToGeocentric	function
(	O
&	O
stbl	array
[	O
i	int
]	O
.	O
w	pointer
,	O
(	O
dis_world_coordinates	struct
*	O
)	O
&	O
stbl	array
[	O
i	int
]	O
.	O
Sg	struct
)	O
;	O
stbl	array
[	O
i	int
]	O
.	O
curHeading	double
=	O
DEGtoRAD	O
(	O
heading	double
)	O
;	O
stbl	array
[	O
i	int
]	O
.	O
curPitch	double
=	O
stbl	array
[	O
i	int
]	O
.	O
curRoll	double
=	O
0.0	int
;	O
if	O
(	O
++	O
i	int
==	O
MAXSURFACE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Only the first %d surface objects will be displayed.\n"	pointer
,	O
MAXSURFACE	int
)	O
;	O
fclose	function
(	O
f	struct
)	O
;	O
return	O
0	int
;	O
}	O
}	O
fclose	function
(	O
f	struct
)	O
;	O
return	O
(	O
s	double
==	O
EOF	O
||	O
s	double
==	O
0	int
)	O
?	O
0	int
:	O
-	O
1	int
;	O
}	O
void	O
undersampleObject	function
(	O
VObject	struct
*	O
obj	pointer
,	O
int	O
rate	short
)	O
{	O
int	O
i	int
,	O
j	int
,	O
k	int
;	O
k	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
1	int
;	O
i	int
<	O
obj	pointer
->	O
numPolys	int
;	O
++	O
i	int
)	O
{	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
obj	pointer
->	O
polygon	pointer
[	O
i	int
]	O
->	O
numVtces	short
;	O
j	int
+=	O
rate	short
)	O
{	O
obj	pointer
->	O
polygon	pointer
[	O
i	int
]	O
->	O
vertex	pointer
[	O
k	int
++	O
]	O
=	O
obj	pointer
->	O
polygon	pointer
[	O
i	int
]	O
->	O
vertex	pointer
[	O
j	int
]	O
;	O
}	O
obj	pointer
->	O
polygon	pointer
[	O
i	int
]	O
->	O
numVtces	short
=	O
k	int
;	O
}	O
}	O
int	O
init	function
(	O
const	O
char	O
*	O
runtime_directory	pointer
)	O
{	O
int	O
i	int
;	O
craft	struct
*	O
p	pointer
;	O
alarm_id_t	long
id	char
;	O
char	O
ground	pointer
[	O
256	int
]	O
;	O
polyCount	long
=	O
32768	int
;	O
poly	pointer
=	O
(	O
VPolygon	struct
*	O
*	O
)	O
Vmalloc	function
(	O
sizeof	O
(	O
VPolygon	struct
*	O
)	O
*	O
polyCount	long
)	O
;	O
cbase	double
=	O
-	O
CLOUD_BASE	int
;	O
ctop	double
=	O
-	O
CLOUD_TOP	int
;	O
VSetDepthCue	O
(	O
VAllocColor	function
(	O
"#A6BBCD"	pointer
)	O
,	O
depth_cue_steps	int
)	O
;	O
VSetVisibility	function
(	O
visibility	double
)	O
;	O
for	O
(	O
(	O
i	int
=	O
0	int
,	O
p	pointer
=	O
stbl	array
)	O
;	O
i	int
<	O
MAXSURFACE	int
;	O
(	O
++	O
i	int
,	O
++	O
p	pointer
)	O
)	O
p	pointer
->	O
type	pointer
=	O
CT_FREE	int
;	O
for	O
(	O
(	O
i	int
=	O
0	int
,	O
p	pointer
=	O
ptbl	array
)	O
;	O
i	int
<	O
MAXPLAYERS	int
;	O
(	O
++	O
i	int
,	O
++	O
p	pointer
)	O
)	O
{	O
p	pointer
->	O
pIndex	int
=	O
i	int
;	O
p	pointer
->	O
type	pointer
=	O
CT_FREE	int
;	O
}	O
for	O
(	O
(	O
i	int
=	O
0	int
,	O
p	pointer
=	O
mtbl	array
)	O
;	O
i	int
<	O
MAXPROJECTILES	O
;	O
(	O
++	O
i	int
,	O
++	O
p	pointer
)	O
)	O
{	O
p	pointer
->	O
pIndex	int
=	O
i	int
;	O
p	pointer
->	O
type	pointer
=	O
CT_FREE	int
;	O
}	O
acm_srand	function
(	O
(	O
int	O
)	O
time	function
(	O
0	int
)	O
)	O
;	O
HUDColor	pointer
=	O
VAllocColor	function
(	O
"white"	pointer
)	O
;	O
whiteColor	pointer
=	O
VAllocColor	function
(	O
"white"	pointer
)	O
;	O
blackColor	pointer
=	O
VAllocColor	function
(	O
"black"	pointer
)	O
;	O
grayColor	pointer
=	O
VAllocColor	function
(	O
"gray20"	pointer
)	O
;	O
radarColor	pointer
=	O
VAllocColor	function
(	O
"#0c0"	pointer
)	O
;	O
HSIMagentaColor	pointer
=	O
VAllocColor	function
(	O
"magenta"	pointer
)	O
;	O
radarBackgroundColor	pointer
=	O
VAllocColor	function
(	O
"#094200"	pointer
)	O
;	O
cloudColor	pointer
=	O
VAllocDepthCueuedColor	function
(	O
"#ccc"	pointer
,	O
1	int
)	O
;	O
buildExplosion	function
(	O
)	O
;	O
if	O
(	O
readScene	function
(	O
ground	pointer
,	O
sizeof	O
(	O
ground	pointer
)	O
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Fatal error\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
groundColor	pointer
=	O
VAllocDepthCueuedColor	function
(	O
ground	pointer
,	O
1	int
)	O
;	O
if	O
(	O
compileAircraftInventory	function
(	O
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Fatal error\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
compileEntityMap	function
(	O
"object-map.txt"	pointer
,	O
&	O
eo_map_count	int
,	O
&	O
eo_map	pointer
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Fatal error\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
if	O
(	O
compileMunitionMap	function
(	O
"munition-map.txt"	pointer
,	O
&	O
mun_map_count	int
,	O
&	O
mun_map	pointer
)	O
!=	O
0	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Fatal error\n"	pointer
)	O
;	O
exit	function
(	O
1	int
)	O
;	O
}	O
initaim9	function
(	O
)	O
;	O
initm61a1	function
(	O
)	O
;	O
initmk82	function
(	O
)	O
;	O
initaim120	function
(	O
)	O
;	O
id	char
=	O
addAlarm	function
(	O
5.0	int
,	O
DMECheckAlarm	function
,	O
NULL	O
,	O
NULL	O
)	O
;	O
id	char
=	O
addAlarm	function
(	O
RESUPPLY_INTERVAL	O
,	O
resupplyCheck	function
,	O
NULL	O
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
void	O
closeScene	function
(	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
MAXSURFACE	int
;	O
++	O
i	int
)	O
{	O
if	O
(	O
stbl	array
[	O
i	int
]	O
.	O
type	pointer
!=	O
CT_FREE	int
)	O
{	O
}	O
}	O
}	O
void	O
freeAll	function
(	O
void	O
)	O
{	O
freeRendering	function
(	O
)	O
;	O
freeCraftTypes	function
(	O
)	O
;	O
freeAllNavaids	function
(	O
)	O
;	O
freeEffects	function
(	O
)	O
;	O
dis_close	function
(	O
)	O
;	O
releaseVResources	function
(	O
)	O
;	O
}	O
