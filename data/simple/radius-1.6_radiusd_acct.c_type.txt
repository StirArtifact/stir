int	O
doradwtmp	int
=	O
1	int
;	O
static	O
int	O
write_wtmp	function
(	O
struct	O
radutmp	struct
*	O
ut	pointer
)	O
;	O
static	O
int	O
write_nas_restart	function
(	O
int	O
status	int
,	O
grad_uint32_t	int
addr	int
)	O
;	O
static	O
int	O
check_ts	function
(	O
struct	O
radutmp	struct
*	O
ut	pointer
)	O
;	O
int	O
rad_acct_system	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
int	O
dowtmp	int
)	O
;	O
int	O
rad_acct_db	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
int	O
authtype	int
)	O
;	O
int	O
rad_acct_ext	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
)	O
;	O
int	O
radzap	function
(	O
grad_uint32_t	int
nasaddr	int
,	O
int	O
port	array
,	O
char	O
*	O
user	pointer
,	O
time_t	long
t	long
)	O
{	O
struct	O
radutmp	struct
*	O
up	pointer
;	O
radut_file_t	pointer
file	pointer
;	O
grad_uint32_t	int
netaddr	int
;	O
if	O
(	O
t	long
==	O
0	int
)	O
time	struct
(	O
&	O
t	long
)	O
;	O
netaddr	int
=	O
htonl	function
(	O
nasaddr	int
)	O
;	O
if	O
(	O
file	pointer
=	O
grad_ut_setent	function
(	O
grad_utmp_file	pointer
,	O
0	int
)	O
)	O
{	O
while	O
(	O
up	pointer
=	O
grad_ut_getent	function
(	O
file	pointer
)	O
)	O
{	O
if	O
(	O
(	O
(	O
nasaddr	int
!=	O
0	int
&&	O
netaddr	int
!=	O
up	pointer
->	O
nas_address	int
)	O
||	O
(	O
port	array
>=	O
0	int
&&	O
port	array
!=	O
up	pointer
->	O
nas_port	int
)	O
||	O
(	O
user	pointer
!=	O
NULL	O
&&	O
strcmp	function
(	O
up	pointer
->	O
login	array
,	O
user	pointer
)	O
!=	O
0	int
)	O
||	O
up	pointer
->	O
type	enum
!=	O
P_LOGIN	int
)	O
)	O
continue	O
;	O
up	pointer
->	O
type	enum
=	O
P_IDLE	int
;	O
up	pointer
->	O
time	struct
=	O
t	long
;	O
grad_ut_putent	function
(	O
file	pointer
,	O
up	pointer
)	O
;	O
write_wtmp	function
(	O
up	pointer
)	O
;	O
}	O
grad_ut_endent	function
(	O
file	pointer
)	O
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
store_session_id	function
(	O
char	O
*	O
buffer	pointer
,	O
int	O
len	int
,	O
char	O
*	O
id	char
,	O
int	O
idlen	int
)	O
{	O
int	O
off	long
=	O
idlen	int
-	O
len	int
;	O
if	O
(	O
off	long
<	O
0	int
)	O
off	long
=	O
0	int
;	O
memcpy	function
(	O
buffer	pointer
,	O
id	char
+	O
off	long
,	O
len	int
)	O
;	O
buffer	pointer
[	O
len	int
-	O
1	int
]	O
=	O
0	int
;	O
}	O
int	O
write_wtmp	function
(	O
struct	O
radutmp	struct
*	O
ut	pointer
)	O
{	O
return	O
grad_radwtmp_putent	function
(	O
grad_wtmp_file	pointer
,	O
ut	pointer
)	O
;	O
}	O
void	O
backslashify	function
(	O
char	O
*	O
dst	pointer
,	O
char	O
*	O
src	pointer
,	O
int	O
len	int
)	O
{	O
while	O
(	O
*	O
src	pointer
&&	O
len	int
>	O
1	int
)	O
{	O
switch	O
(	O
*	O
src	pointer
)	O
{	O
case	O
'\\'	O
:	O
ESCAPE	O
(	O
'\\'	O
)	O
;	O
break	O
;	O
case	O
'\a'	O
:	O
ESCAPE	O
(	O
'a'	O
)	O
;	O
break	O
;	O
case	O
'\b'	O
:	O
ESCAPE	O
(	O
'b'	O
)	O
;	O
break	O
;	O
case	O
'\f'	O
:	O
ESCAPE	O
(	O
'f'	O
)	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
ESCAPE	O
(	O
'n'	O
)	O
;	O
break	O
;	O
case	O
'\r'	O
:	O
ESCAPE	O
(	O
'r'	O
)	O
;	O
break	O
;	O
case	O
'\t'	O
:	O
ESCAPE	O
(	O
't'	O
)	O
;	O
break	O
;	O
default	O
:	O
*	O
dst	pointer
++	O
=	O
*	O
src	pointer
++	O
;	O
len	int
--	O
;	O
}	O
}	O
end	pointer
:	O
*	O
dst	pointer
=	O
0	int
;	O
}	O
int	O
check_attribute	function
(	O
grad_avp_t	struct
*	O
check_pairs	pointer
,	O
int	O
pair_attr	int
,	O
int	O
pair_value	int
,	O
int	O
def	int
)	O
{	O
grad_avp_t	struct
*	O
pair	pointer
;	O
if	O
(	O
(	O
pair	pointer
=	O
grad_avl_find	function
(	O
check_pairs	pointer
,	O
pair_attr	int
)	O
)	O
==	O
NULL	O
)	O
return	O
def	int
;	O
do	O
{	O
if	O
(	O
pair	pointer
->	O
avp_lvalue	O
==	O
pair_value	int
)	O
return	O
1	int
;	O
check_pairs	pointer
=	O
pair	pointer
->	O
next	pointer
;	O
}	O
while	O
(	O
check_pairs	pointer
&&	O
(	O
pair	pointer
=	O
grad_avl_find	function
(	O
check_pairs	pointer
,	O
pair_attr	int
)	O
)	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
rad_acct_system	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
int	O
dowtmp	int
)	O
{	O
struct	O
radutmp	struct
ut	pointer
;	O
grad_avp_t	struct
*	O
vp	pointer
;	O
int	O
status	int
=	O
-	O
1	int
;	O
int	O
nas_address	int
=	O
0	int
;	O
int	O
protocol	int
=	O
-	O
1	int
;	O
time_t	long
t	long
;	O
int	O
ret	int
=	O
0	int
,	O
rc	int
;	O
int	O
port_seen	int
=	O
0	int
;	O
char	O
buf	pointer
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
if	O
(	O
!	O
acct_system	int
)	O
return	O
0	int
;	O
if	O
(	O
(	O
vp	pointer
=	O
grad_avl_find	function
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_ACCT_STATUS_TYPE	int
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log_req	function
(	O
GRAD_LOG_ERR	int
,	O
radreq	pointer
->	O
request	pointer
,	O
_	O
(	O
"no Acct-Status-Type attribute"	pointer
)	O
)	O
;	O
return	O
-	O
1	int
;	O
}	O
status	int
=	O
vp	pointer
->	O
avp_lvalue	O
;	O
time	struct
(	O
&	O
t	long
)	O
;	O
memset	function
(	O
&	O
ut	pointer
,	O
0	int
,	O
sizeof	O
(	O
ut	pointer
)	O
)	O
;	O
ut	pointer
.	O
porttype	int
=	O
-	O
1	int
;	O
if	O
(	O
radreq	pointer
->	O
realm	array
)	O
{	O
grad_server_t	struct
*	O
server	pointer
=	O
grad_list_item	function
(	O
radreq	pointer
->	O
realm	array
->	O
queue	pointer
->	O
servers	pointer
,	O
radreq	pointer
->	O
server_no	int
)	O
;	O
if	O
(	O
server	pointer
)	O
ut	pointer
.	O
realm_address	int
=	O
server	pointer
->	O
addr	int
;	O
}	O
for	O
(	O
vp	pointer
=	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
;	O
vp	pointer
;	O
vp	pointer
=	O
vp	pointer
->	O
next	pointer
)	O
{	O
switch	O
(	O
vp	pointer
->	O
attribute	int
)	O
{	O
case	O
DA_USER_NAME	int
:	O
backslashify	function
(	O
ut	pointer
.	O
login	array
,	O
vp	pointer
->	O
avp_strvalue	O
,	O
RUT_NAMESIZE	int
)	O
;	O
break	O
;	O
case	O
DA_ORIG_USER_NAME	int
:	O
backslashify	function
(	O
ut	pointer
.	O
orig_login	array
,	O
vp	pointer
->	O
avp_strvalue	O
,	O
RUT_NAMESIZE	int
)	O
;	O
break	O
;	O
case	O
DA_LOGIN_IP_HOST	int
:	O
case	O
DA_FRAMED_IP_ADDRESS	int
:	O
ut	pointer
.	O
framed_address	int
=	O
htonl	function
(	O
vp	pointer
->	O
avp_lvalue	O
)	O
;	O
break	O
;	O
case	O
DA_FRAMED_PROTOCOL	int
:	O
protocol	int
=	O
vp	pointer
->	O
avp_lvalue	O
;	O
break	O
;	O
case	O
DA_NAS_IP_ADDRESS	int
:	O
nas_address	int
=	O
vp	pointer
->	O
avp_lvalue	O
;	O
ut	pointer
.	O
nas_address	int
=	O
htonl	function
(	O
vp	pointer
->	O
avp_lvalue	O
)	O
;	O
break	O
;	O
case	O
DA_NAS_PORT_ID	int
:	O
ut	pointer
.	O
nas_port	int
=	O
vp	pointer
->	O
avp_lvalue	O
;	O
port_seen	int
=	O
1	int
;	O
break	O
;	O
case	O
DA_ACCT_DELAY_TIME	int
:	O
ut	pointer
.	O
delay	long
=	O
vp	pointer
->	O
avp_lvalue	O
;	O
break	O
;	O
case	O
DA_CALLING_STATION_ID	int
:	O
store_session_id	function
(	O
ut	pointer
.	O
caller_id	array
,	O
sizeof	O
(	O
ut	pointer
.	O
caller_id	array
)	O
,	O
vp	pointer
->	O
avp_strvalue	O
,	O
vp	pointer
->	O
avp_strlength	O
)	O
;	O
break	O
;	O
case	O
DA_CALLED_STATION_ID	int
:	O
break	O
;	O
case	O
DA_ACCT_SESSION_ID	int
:	O
store_session_id	function
(	O
ut	pointer
.	O
session_id	array
,	O
sizeof	O
(	O
ut	pointer
.	O
session_id	array
)	O
,	O
vp	pointer
->	O
avp_strvalue	O
,	O
vp	pointer
->	O
avp_strlength	O
)	O
;	O
break	O
;	O
case	O
DA_NAS_PORT_TYPE	int
:	O
ut	pointer
.	O
porttype	int
=	O
vp	pointer
->	O
avp_lvalue	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
ut	pointer
.	O
orig_login	array
[	O
0	int
]	O
==	O
0	int
)	O
strncpy	function
(	O
ut	pointer
.	O
orig_login	array
,	O
ut	pointer
.	O
login	array
,	O
sizeof	O
(	O
ut	pointer
.	O
orig_login	array
)	O
)	O
;	O
if	O
(	O
nas_address	int
==	O
0	int
)	O
{	O
nas_address	int
=	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
;	O
ut	pointer
.	O
nas_address	int
=	O
htonl	function
(	O
nas_address	int
)	O
;	O
}	O
if	O
(	O
ut	pointer
.	O
login	array
[	O
0	int
]	O
==	O
0	int
&&	O
ut	pointer
.	O
caller_id	array
[	O
0	int
]	O
!=	O
0	int
)	O
{	O
ut	pointer
.	O
login	array
[	O
0	int
]	O
=	O
'#'	O
;	O
store_session_id	function
(	O
ut	pointer
.	O
login	array
+	O
1	int
,	O
RUT_NAMESIZE	int
-	O
2	int
,	O
ut	pointer
.	O
caller_id	array
,	O
strlen	function
(	O
ut	pointer
.	O
caller_id	array
)	O
)	O
;	O
}	O
ut	pointer
.	O
proto	int
=	O
protocol	int
;	O
ut	pointer
.	O
time	struct
=	O
t	long
-	O
ut	pointer
.	O
delay	long
;	O
if	O
(	O
status	int
==	O
DV_ACCT_STATUS_TYPE_ACCOUNTING_ON	int
&&	O
nas_address	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"NAS %s started (Accounting-On packet seen)"	pointer
)	O
,	O
grad_nas_ip_to_name	function
(	O
nas_address	int
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
)	O
)	O
;	O
radzap	function
(	O
nas_address	int
,	O
-	O
1	int
,	O
NULL	O
,	O
ut	pointer
.	O
time	struct
)	O
;	O
write_nas_restart	function
(	O
status	int
,	O
ut	pointer
.	O
nas_address	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
status	int
==	O
DV_ACCT_STATUS_TYPE_ACCOUNTING_OFF	int
&&	O
nas_address	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"NAS %s shut down (Accounting-Off packet seen)"	pointer
)	O
,	O
grad_nas_ip_to_name	function
(	O
nas_address	int
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
)	O
)	O
;	O
radzap	function
(	O
nas_address	int
,	O
-	O
1	int
,	O
NULL	O
,	O
ut	pointer
.	O
time	struct
)	O
;	O
write_nas_restart	function
(	O
status	int
,	O
ut	pointer
.	O
nas_address	int
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
status	int
!=	O
DV_ACCT_STATUS_TYPE_START	int
&&	O
status	int
!=	O
DV_ACCT_STATUS_TYPE_STOP	int
&&	O
status	int
!=	O
DV_ACCT_STATUS_TYPE_ALIVE	int
)	O
{	O
grad_log_req	function
(	O
GRAD_LOG_NOTICE	int
,	O
radreq	pointer
->	O
request	pointer
,	O
_	O
(	O
"unknown packet type (%d)"	pointer
)	O
,	O
status	int
)	O
;	O
return	O
0	int
;	O
}	O
else	O
if	O
(	O
status	int
==	O
DV_ACCT_STATUS_TYPE_START	int
||	O
status	int
==	O
DV_ACCT_STATUS_TYPE_STOP	int
)	O
{	O
GRAD_DEBUG7	O
(	O
1	int
,	O
"%s: User %s at NAS %s port %d session %-*.*s"	pointer
,	O
status	int
==	O
DV_ACCT_STATUS_TYPE_START	int
?	O
"start"	pointer
:	O
"stop"	pointer
,	O
ut	pointer
.	O
login	array
,	O
grad_nas_ip_to_name	function
(	O
nas_address	int
,	O
buf	pointer
,	O
sizeof	O
buf	pointer
)	O
,	O
ut	pointer
.	O
nas_port	int
,	O
sizeof	O
(	O
ut	pointer
.	O
session_id	array
)	O
,	O
sizeof	O
(	O
ut	pointer
.	O
session_id	array
)	O
,	O
ut	pointer
.	O
session_id	array
)	O
;	O
}	O
if	O
(	O
!	O
port_seen	int
)	O
return	O
0	int
;	O
if	O
(	O
!	O
ACCT_TYPE	O
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DV_ACCT_TYPE_SYSTEM	int
)	O
)	O
{	O
GRAD_DEBUG1	O
(	O
1	int
,	O
"Acct type system disabled for %s"	pointer
,	O
ut	pointer
.	O
login	array
)	O
;	O
return	O
0	int
;	O
}	O
rc	int
=	O
grad_utmp_putent	function
(	O
grad_utmp_file	pointer
,	O
&	O
ut	pointer
,	O
status	int
)	O
;	O
GRAD_DEBUG3	O
(	O
1	int
,	O
"grad_utmp_putent=%d for %s/%s"	pointer
,	O
rc	int
,	O
ut	pointer
.	O
login	array
,	O
ut	pointer
.	O
session_id	array
)	O
;	O
if	O
(	O
(	O
status	int
!=	O
DV_ACCT_STATUS_TYPE_STOP	int
&&	O
ut	pointer
.	O
login	array
[	O
0	int
]	O
==	O
0	int
)	O
||	O
rc	int
==	O
PUTENT_UPDATE	int
)	O
dowtmp	int
=	O
0	int
;	O
if	O
(	O
dowtmp	int
)	O
{	O
stat_update	O
(	O
&	O
ut	pointer
,	O
status	int
)	O
;	O
write_wtmp	function
(	O
&	O
ut	pointer
)	O
;	O
}	O
else	O
if	O
(	O
rc	int
==	O
PUTENT_UPDATE	int
)	O
{	O
stat_update	O
(	O
&	O
ut	pointer
,	O
status	int
)	O
;	O
}	O
else	O
{	O
ret	int
=	O
-	O
1	int
;	O
stat_inc	O
(	O
acct	function
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_norecords	O
)	O
;	O
grad_log_req	function
(	O
GRAD_LOG_NOTICE	int
,	O
radreq	pointer
->	O
request	pointer
,	O
_	O
(	O
"NOT writing wtmp record"	pointer
)	O
)	O
;	O
}	O
return	O
ret	int
;	O
}	O
static	O
void	O
disable_system_acct	function
(	O
)	O
{	O
radut_file_t	pointer
file	pointer
;	O
struct	O
radutmp	struct
*	O
up	pointer
;	O
int	O
written	int
=	O
0	int
;	O
if	O
(	O
(	O
file	pointer
=	O
grad_ut_setent	function
(	O
grad_utmp_file	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
while	O
(	O
up	pointer
=	O
grad_ut_getent	function
(	O
file	pointer
)	O
)	O
{	O
switch	O
(	O
up	pointer
->	O
type	enum
)	O
{	O
case	O
P_LOGIN	int
:	O
up	pointer
->	O
type	enum
=	O
P_IDLE	int
;	O
time	struct
(	O
&	O
up	pointer
->	O
time	struct
)	O
;	O
grad_ut_putent	function
(	O
file	pointer
,	O
up	pointer
)	O
;	O
write_wtmp	function
(	O
up	pointer
)	O
;	O
break	O
;	O
case	O
P_ACCT_ENABLED	int
:	O
time	struct
(	O
&	O
up	pointer
->	O
time	struct
)	O
;	O
up	pointer
->	O
type	enum
=	O
P_ACCT_DISABLED	int
;	O
grad_ut_putent	function
(	O
file	pointer
,	O
up	pointer
)	O
;	O
write_wtmp	function
(	O
up	pointer
)	O
;	O
written	int
=	O
1	int
;	O
break	O
;	O
case	O
P_ACCT_DISABLED	int
:	O
written	int
=	O
1	int
;	O
break	O
;	O
}	O
}	O
if	O
(	O
!	O
written	int
)	O
{	O
struct	O
radutmp	struct
ut	pointer
;	O
memset	function
(	O
&	O
ut	pointer
,	O
0	int
,	O
sizeof	O
ut	pointer
)	O
;	O
time	struct
(	O
&	O
ut	pointer
.	O
time	struct
)	O
;	O
ut	pointer
.	O
type	enum
=	O
P_ACCT_DISABLED	int
;	O
grad_ut_putent	function
(	O
file	pointer
,	O
&	O
ut	pointer
)	O
;	O
}	O
grad_ut_endent	function
(	O
file	pointer
)	O
;	O
grad_log	function
(	O
GRAD_LOG_INFO	int
,	O
_	O
(	O
"System accounting is disabled"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
enable_system_acct	function
(	O
)	O
{	O
radut_file_t	pointer
file	pointer
;	O
struct	O
radutmp	struct
*	O
up	pointer
,	O
ut	pointer
;	O
if	O
(	O
(	O
file	pointer
=	O
grad_ut_setent	function
(	O
grad_utmp_file	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
return	O
;	O
while	O
(	O
up	pointer
=	O
grad_ut_getent	function
(	O
file	pointer
)	O
)	O
{	O
if	O
(	O
up	pointer
->	O
type	enum
==	O
P_ACCT_DISABLED	int
)	O
{	O
up	pointer
->	O
type	enum
=	O
P_ACCT_ENABLED	int
;	O
time	struct
(	O
&	O
up	pointer
->	O
time	struct
)	O
;	O
grad_ut_putent	function
(	O
file	pointer
,	O
up	pointer
)	O
;	O
write_wtmp	function
(	O
up	pointer
)	O
;	O
}	O
}	O
grad_ut_endent	function
(	O
file	pointer
)	O
;	O
}	O
void	O
system_acct_init	function
(	O
)	O
{	O
if	O
(	O
acct_system	int
)	O
enable_system_acct	function
(	O
)	O
;	O
else	O
disable_system_acct	function
(	O
)	O
;	O
}	O
int	O
mkdir_path	function
(	O
char	O
*	O
path	pointer
,	O
int	O
perms	int
)	O
{	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
stat	struct
(	O
path	pointer
,	O
&	O
st	struct
)	O
)	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
errno	O
!=	O
ENOENT	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"Cannot stat path component: %s"	pointer
)	O
,	O
path	pointer
)	O
;	O
return	O
1	int
;	O
}	O
p	pointer
=	O
strrchr	function
(	O
path	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
&&	O
p	pointer
>	O
path	pointer
)	O
{	O
int	O
rc	int
;	O
*	O
p	pointer
=	O
0	int
;	O
rc	int
=	O
mkdir_path	function
(	O
path	pointer
,	O
perms	int
)	O
;	O
*	O
p	pointer
=	O
'/'	O
;	O
if	O
(	O
rc	int
)	O
return	O
1	int
;	O
}	O
if	O
(	O
mkdir	function
(	O
path	pointer
,	O
perms	int
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"Cannot create directory %s"	pointer
)	O
,	O
path	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
else	O
if	O
(	O
!	O
S_ISDIR	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"Path component is not a directory: %s"	pointer
)	O
,	O
path	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
check_acct_dir	function
(	O
)	O
{	O
struct	O
stat	struct
st	struct
;	O
if	O
(	O
stat	struct
(	O
grad_acct_dir	pointer
,	O
&	O
st	struct
)	O
==	O
0	int
)	O
{	O
if	O
(	O
S_ISDIR	O
(	O
st	struct
.	O
st_mode	int
)	O
)	O
{	O
if	O
(	O
access	function
(	O
grad_acct_dir	pointer
,	O
W_OK	int
)	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"%s: directory not writable"	pointer
)	O
,	O
grad_acct_dir	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
else	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
_	O
(	O
"%s: not a directory"	pointer
)	O
,	O
grad_acct_dir	pointer
)	O
;	O
return	O
1	int
;	O
}	O
}	O
if	O
(	O
mkdir_path	function
(	O
grad_acct_dir	pointer
,	O
0755	int
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
acct_dir_status	int
;	O
static	O
void	O
acct_after_config_hook	function
(	O
void	O
*	O
arg	pointer
ARG_UNUSED	O
,	O
void	O
*	O
data	pointer
ARG_UNUSED	O
)	O
{	O
if	O
(	O
auth_detail	int
||	O
acct_detail	int
)	O
{	O
acct_dir_status	int
=	O
check_acct_dir	function
(	O
)	O
;	O
if	O
(	O
acct_dir_status	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_NOTICE	int
,	O
_	O
(	O
"Detailed accounting is disabled"	pointer
)	O
)	O
;	O
auth_detail	int
=	O
acct_detail	int
=	O
0	int
;	O
}	O
}	O
}	O
void	O
acct_init	function
(	O
)	O
{	O
radiusd_set_postconfig_hook	function
(	O
acct_after_config_hook	function
,	O
NULL	O
,	O
0	int
)	O
;	O
}	O
static	O
char	O
*	O
make_legacy_detail_filename	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
char	O
*	O
default_filename	pointer
)	O
{	O
char	O
nasname	array
[	O
GRAD_MAX_LONGNAME	int
]	O
;	O
grad_nas_t	struct
*	O
cl	pointer
;	O
grad_uint32_t	int
ip	pointer
;	O
grad_avp_t	struct
*	O
pair	pointer
;	O
cl	pointer
=	O
NULL	O
;	O
ip	pointer
=	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
;	O
if	O
(	O
(	O
pair	pointer
=	O
grad_avl_find	function
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_NAS_IP_ADDRESS	int
)	O
)	O
!=	O
NULL	O
)	O
ip	pointer
=	O
pair	pointer
->	O
avp_lvalue	O
;	O
if	O
(	O
radreq	pointer
->	O
realm	array
)	O
{	O
grad_server_t	struct
*	O
server	pointer
=	O
grad_list_item	function
(	O
radreq	pointer
->	O
realm	array
->	O
queue	pointer
->	O
servers	pointer
,	O
radreq	pointer
->	O
server_no	int
)	O
;	O
if	O
(	O
server	pointer
)	O
ip	pointer
=	O
server	pointer
->	O
addr	int
;	O
}	O
if	O
(	O
(	O
cl	pointer
=	O
grad_nas_lookup_ip	function
(	O
ip	pointer
)	O
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
cl	pointer
->	O
shortname	array
[	O
0	int
]	O
)	O
strcpy	function
(	O
nasname	array
,	O
cl	pointer
->	O
shortname	array
)	O
;	O
else	O
strcpy	function
(	O
nasname	array
,	O
cl	pointer
->	O
longname	array
)	O
;	O
}	O
if	O
(	O
cl	pointer
==	O
NULL	O
)	O
grad_ip_gethostname	function
(	O
ip	pointer
,	O
nasname	array
,	O
sizeof	O
(	O
nasname	array
)	O
)	O
;	O
return	O
grad_mkfilename	function
(	O
nasname	array
,	O
default_filename	pointer
)	O
;	O
}	O
static	O
char	O
*	O
make_detail_filename	function
(	O
radiusd_request_t	struct
*	O
req	pointer
,	O
char	O
*	O
template	pointer
,	O
char	O
*	O
default_filename	pointer
)	O
{	O
if	O
(	O
!	O
template	pointer
)	O
{	O
return	O
make_legacy_detail_filename	function
(	O
req	pointer
,	O
default_filename	pointer
)	O
;	O
}	O
else	O
if	O
(	O
template	pointer
[	O
0	int
]	O
==	O
'='	O
)	O
{	O
grad_value_t	struct
val	array
;	O
if	O
(	O
rewrite_interpret	function
(	O
template	pointer
+	O
1	int
,	O
req	pointer
->	O
request	pointer
,	O
&	O
val	array
)	O
)	O
return	O
NULL	O
;	O
if	O
(	O
val	array
.	O
type	enum
!=	O
String	int
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
,	O
"%s: %s"	pointer
,	O
template	pointer
+	O
1	int
,	O
_	O
(	O
"wrong return type"	pointer
)	O
)	O
;	O
return	O
NULL	O
;	O
}	O
return	O
val	array
.	O
datum	union
.	O
sval	struct
.	O
data	pointer
;	O
}	O
else	O
{	O
struct	O
obstack	struct
stk	struct
;	O
char	O
*	O
ptr	pointer
;	O
obstack_init	O
(	O
&	O
stk	struct
)	O
;	O
ptr	pointer
=	O
radius_xlate	function
(	O
&	O
stk	struct
,	O
template	pointer
,	O
req	pointer
->	O
request	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
ptr	pointer
)	O
ptr	pointer
=	O
grad_estrdup	function
(	O
ptr	pointer
)	O
;	O
obstack_free	function
(	O
&	O
stk	struct
,	O
NULL	O
)	O
;	O
return	O
ptr	pointer
;	O
}	O
}	O
static	O
int	O
make_path_to_file	function
(	O
char	O
*	O
filename	pointer
,	O
int	O
perms	int
)	O
{	O
char	O
*	O
p	pointer
=	O
strrchr	function
(	O
filename	pointer
,	O
'/'	O
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
int	O
rc	int
;	O
*	O
p	pointer
=	O
0	int
;	O
rc	int
=	O
mkdir_path	function
(	O
filename	pointer
,	O
perms	int
)	O
;	O
*	O
p	pointer
=	O
'/'	O
;	O
return	O
rc	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
write_detail	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
int	O
authtype	int
,	O
int	O
rtype	int
)	O
{	O
FILE	struct
*	O
outfd	pointer
;	O
char	O
*	O
save	pointer
;	O
grad_avp_t	struct
*	O
pair	pointer
;	O
time_t	long
curtime	long
;	O
int	O
ret	int
=	O
0	int
;	O
char	O
*	O
filename	pointer
;	O
char	O
*	O
template	pointer
;	O
char	O
*	O
deffilename	pointer
;	O
if	O
(	O
acct_dir_status	int
)	O
return	O
1	int
;	O
curtime	long
=	O
time	struct
(	O
0	int
)	O
;	O
switch	O
(	O
rtype	int
)	O
{	O
case	O
R_ACCT	int
:	O
template	pointer
=	O
acct_detail_template	pointer
;	O
deffilename	pointer
=	O
"detail"	pointer
;	O
break	O
;	O
case	O
R_AUTH	int
:	O
template	pointer
=	O
auth_detail_template	pointer
;	O
deffilename	pointer
=	O
"detail.auth"	pointer
;	O
break	O
;	O
default	O
:	O
return	O
1	int
;	O
}	O
filename	pointer
=	O
make_detail_filename	function
(	O
radreq	pointer
,	O
template	pointer
,	O
deffilename	pointer
)	O
;	O
if	O
(	O
!	O
filename	pointer
)	O
return	O
1	int
;	O
if	O
(	O
chdir	function
(	O
grad_acct_dir	pointer
)	O
)	O
{	O
grad_free	function
(	O
filename	pointer
)	O
;	O
return	O
1	int
;	O
}	O
make_path_to_file	function
(	O
filename	pointer
,	O
0755	int
)	O
;	O
if	O
(	O
(	O
outfd	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"a"	pointer
)	O
)	O
==	O
NULL	O
)	O
{	O
grad_log	function
(	O
GRAD_LOG_ERR	int
|	O
GRAD_LOG_PERROR	int
,	O
_	O
(	O
"can't open %s"	pointer
)	O
,	O
filename	pointer
)	O
;	O
ret	int
=	O
1	int
;	O
}	O
else	O
{	O
fprintf	function
(	O
outfd	pointer
,	O
"%s"	pointer
,	O
ctime	function
(	O
&	O
curtime	long
)	O
)	O
;	O
if	O
(	O
!	O
strip_names	int
)	O
{	O
pair	pointer
=	O
grad_avl_find	function
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_ORIG_USER_NAME	int
)	O
;	O
if	O
(	O
pair	pointer
)	O
pair	pointer
->	O
name	pointer
=	O
"User-Name"	pointer
;	O
else	O
pair	pointer
=	O
grad_avl_find	function
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_USER_NAME	int
)	O
;	O
if	O
(	O
pair	pointer
)	O
{	O
fprintf	function
(	O
outfd	pointer
,	O
"\t%s\n"	pointer
,	O
grad_format_pair	function
(	O
pair	pointer
,	O
0	int
,	O
&	O
save	pointer
)	O
)	O
;	O
free	function
(	O
save	pointer
)	O
;	O
}	O
}	O
for	O
(	O
pair	pointer
=	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
;	O
pair	pointer
;	O
pair	pointer
=	O
pair	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
pair	pointer
->	O
prop	int
&	O
GRAD_AP_INTERNAL	int
)	O
continue	O
;	O
switch	O
(	O
pair	pointer
->	O
attribute	int
)	O
{	O
case	O
DA_USER_PASSWORD	int
:	O
break	O
;	O
case	O
DA_USER_NAME	int
:	O
case	O
DA_ORIG_USER_NAME	int
:	O
if	O
(	O
!	O
strip_names	int
)	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
outfd	pointer
,	O
"\t%s\n"	pointer
,	O
grad_format_pair	function
(	O
pair	pointer
,	O
0	int
,	O
&	O
save	pointer
)	O
)	O
;	O
free	function
(	O
save	pointer
)	O
;	O
}	O
}	O
fprintf	function
(	O
outfd	pointer
,	O
"\tTimestamp = %ld\n"	pointer
,	O
curtime	long
)	O
;	O
switch	O
(	O
authtype	int
)	O
{	O
case	O
REQ_AUTH_OK	int
:	O
fprintf	function
(	O
outfd	pointer
,	O
"\tRequest-Authenticator = Verified\n"	pointer
)	O
;	O
break	O
;	O
case	O
REQ_AUTH_ZERO	int
:	O
fprintf	function
(	O
outfd	pointer
,	O
"\tRequest-Authenticator = None\n"	pointer
)	O
;	O
break	O
;	O
case	O
REQ_AUTH_BAD	int
:	O
fprintf	function
(	O
outfd	pointer
,	O
"\tRequest-Authenticator = Unverified\n"	pointer
)	O
;	O
break	O
;	O
default	O
:	O
fprintf	function
(	O
outfd	pointer
,	O
"\tRequest-Authenticator = %d\n"	pointer
,	O
authtype	int
)	O
;	O
break	O
;	O
}	O
fprintf	function
(	O
outfd	pointer
,	O
"\n"	pointer
)	O
;	O
fclose	function
(	O
outfd	pointer
)	O
;	O
ret	int
=	O
0	int
;	O
}	O
grad_free	function
(	O
filename	pointer
)	O
;	O
chdir	function
(	O
"/"	pointer
)	O
;	O
return	O
ret	int
;	O
}	O
int	O
rad_acct_db	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
int	O
authtype	int
)	O
{	O
int	O
rc	int
=	O
0	int
;	O
if	O
(	O
acct_detail	int
&&	O
ACCT_TYPE	O
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DV_ACCT_TYPE_DETAIL	int
)	O
)	O
rc	int
=	O
write_detail	function
(	O
radreq	pointer
,	O
authtype	int
,	O
R_ACCT	int
)	O
;	O
if	O
(	O
ACCT_TYPE	O
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DV_ACCT_TYPE_SQL	int
)	O
)	O
radiusd_sql_acct	O
(	O
radreq	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
int	O
rad_acct_ext	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
)	O
{	O
grad_avp_t	struct
*	O
p	pointer
;	O
int	O
rc	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
grad_avl_find	function
(	O
radreq	pointer
->	O
request	pointer
->	O
avlist	pointer
,	O
DA_ACCT_EXT_PROGRAM	int
)	O
;	O
p	pointer
;	O
p	pointer
=	O
grad_avl_find	function
(	O
p	pointer
->	O
next	pointer
,	O
DA_ACCT_EXT_PROGRAM	int
)	O
)	O
{	O
radius_eval_avp	function
(	O
radreq	pointer
,	O
p	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
switch	O
(	O
p	pointer
->	O
avp_strvalue	O
[	O
0	int
]	O
)	O
{	O
case	O
'/'	O
:	O
rc	int
=	O
radius_exec_program	function
(	O
p	pointer
->	O
avp_strvalue	O
,	O
radreq	pointer
,	O
NULL	O
,	O
1	int
)	O
;	O
break	O
;	O
case	O
'|'	O
:	O
filter_acct	function
(	O
p	pointer
->	O
avp_strvalue	O
+	O
1	int
,	O
radreq	pointer
)	O
;	O
}	O
}	O
return	O
rc	int
;	O
}	O
int	O
rad_accounting	function
(	O
radiusd_request_t	struct
*	O
radreq	pointer
,	O
int	O
activefd	int
,	O
int	O
verified	int
)	O
{	O
log_open	function
(	O
GRAD_LOG_ACCT	O
)	O
;	O
huntgroup_access	function
(	O
radreq	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
radreq	pointer
->	O
request	pointer
->	O
code	char
==	O
RT_ASCEND_EVENT_REQUEST	int
)	O
{	O
write_detail	function
(	O
radreq	pointer
,	O
verified	int
,	O
R_ACCT	int
)	O
;	O
radius_send_reply	function
(	O
RT_ASCEND_EVENT_RESPONSE	int
,	O
radreq	pointer
,	O
NULL	O
,	O
NULL	O
,	O
activefd	int
)	O
;	O
stat_inc	O
(	O
acct	function
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_resp	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
rad_acct_system	function
(	O
radreq	pointer
,	O
doradwtmp	int
)	O
==	O
0	int
&&	O
rad_acct_db	function
(	O
radreq	pointer
,	O
verified	int
)	O
==	O
0	int
&&	O
rad_acct_ext	function
(	O
radreq	pointer
)	O
==	O
0	int
)	O
{	O
radius_send_reply	function
(	O
RT_ACCOUNTING_RESPONSE	int
,	O
radreq	pointer
,	O
NULL	O
,	O
NULL	O
,	O
activefd	int
)	O
;	O
stat_inc	O
(	O
acct	function
,	O
radreq	pointer
->	O
request	pointer
->	O
ipaddr	int
,	O
num_resp	O
)	O
;	O
return	O
0	int
;	O
}	O
return	O
-	O
1	int
;	O
}	O
int	O
write_nas_restart	function
(	O
int	O
status	int
,	O
grad_uint32_t	int
addr	int
)	O
{	O
struct	O
radutmp	struct
ut	pointer
;	O
memset	function
(	O
&	O
ut	pointer
,	O
0	int
,	O
sizeof	O
(	O
ut	pointer
)	O
)	O
;	O
if	O
(	O
status	int
==	O
DV_ACCT_STATUS_TYPE_ACCOUNTING_ON	int
)	O
ut	pointer
.	O
type	enum
=	O
P_NAS_START	int
;	O
else	O
ut	pointer
.	O
type	enum
=	O
P_NAS_SHUTDOWN	int
;	O
ut	pointer
.	O
nas_address	int
=	O
addr	int
;	O
time	struct
(	O
&	O
ut	pointer
.	O
time	struct
)	O
;	O
return	O
write_wtmp	function
(	O
&	O
ut	pointer
)	O
;	O
}	O
int	O
radutmp_mlc_collect_user	function
(	O
char	O
*	O
name	pointer
,	O
radiusd_request_t	struct
*	O
request	pointer
,	O
grad_list_t	struct
*	O
*	O
sess_list	pointer
)	O
{	O
radut_file_t	pointer
file	pointer
;	O
struct	O
radutmp	struct
*	O
up	pointer
;	O
if	O
(	O
(	O
file	pointer
=	O
grad_ut_setent	function
(	O
grad_utmp_file	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
return	O
1	int
;	O
while	O
(	O
up	pointer
=	O
grad_ut_getent	function
(	O
file	pointer
)	O
)	O
{	O
if	O
(	O
strncmp	function
(	O
name	pointer
,	O
up	pointer
->	O
login	array
,	O
RUT_NAMESIZE	int
)	O
==	O
0	int
&&	O
up	pointer
->	O
type	enum
==	O
P_LOGIN	int
)	O
{	O
struct	O
radutmp	struct
*	O
tmp	pointer
;	O
if	O
(	O
*	O
sess_list	pointer
==	O
NULL	O
)	O
*	O
sess_list	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
tmp	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
tmp	pointer
)	O
)	O
;	O
memcpy	function
(	O
tmp	pointer
,	O
up	pointer
,	O
sizeof	O
(	O
*	O
tmp	pointer
)	O
)	O
;	O
grad_list_append	function
(	O
*	O
sess_list	pointer
,	O
tmp	pointer
)	O
;	O
}	O
}	O
grad_ut_endent	function
(	O
file	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
radutmp_mlc_collect_realm	function
(	O
radiusd_request_t	struct
*	O
request	pointer
,	O
grad_list_t	struct
*	O
*	O
sess_list	pointer
)	O
{	O
radut_file_t	pointer
file	pointer
;	O
struct	O
radutmp	struct
*	O
up	pointer
;	O
if	O
(	O
(	O
file	pointer
=	O
grad_ut_setent	function
(	O
grad_utmp_file	pointer
,	O
0	int
)	O
)	O
==	O
NULL	O
)	O
return	O
1	int
;	O
while	O
(	O
up	pointer
=	O
grad_ut_getent	function
(	O
file	pointer
)	O
)	O
{	O
if	O
(	O
up	pointer
->	O
type	enum
==	O
P_LOGIN	int
&&	O
grad_realm_verify_ip	function
(	O
request	pointer
->	O
realm	array
,	O
up	pointer
->	O
realm_address	int
)	O
)	O
{	O
struct	O
radutmp	struct
*	O
tmp	pointer
;	O
if	O
(	O
*	O
sess_list	pointer
==	O
NULL	O
)	O
*	O
sess_list	pointer
=	O
grad_list_create	function
(	O
)	O
;	O
tmp	pointer
=	O
grad_emalloc	function
(	O
sizeof	O
(	O
*	O
tmp	pointer
)	O
)	O
;	O
memcpy	function
(	O
tmp	pointer
,	O
up	pointer
,	O
sizeof	O
(	O
*	O
tmp	pointer
)	O
)	O
;	O
grad_list_append	function
(	O
*	O
sess_list	pointer
,	O
tmp	pointer
)	O
;	O
}	O
}	O
grad_ut_endent	function
(	O
file	pointer
)	O
;	O
return	O
0	int
;	O
}	O
void	O
radutmp_mlc_close	function
(	O
struct	O
radutmp	struct
*	O
up	pointer
)	O
{	O
up	pointer
->	O
type	enum
=	O
P_IDLE	int
;	O
up	pointer
->	O
time	struct
=	O
time	struct
(	O
NULL	O
)	O
;	O
grad_utmp_putent	function
(	O
grad_utmp_file	pointer
,	O
up	pointer
,	O
DV_ACCT_STATUS_TYPE_STOP	int
)	O
;	O
}	O
int	O
radutmp_mlc_enabled_p	function
(	O
)	O
{	O
return	O
acct_system	int
;	O
}	O
