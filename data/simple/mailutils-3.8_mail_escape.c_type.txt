static	O
void	O
dump_headers	function
(	O
mu_stream_t	pointer
out	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
mu_stream_t	pointer
stream	pointer
=	O
NULL	O
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_header_get_streamref	function
(	O
env	pointer
->	O
header	pointer
,	O
&	O
stream	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
"mu_header_get_streamref: %s"	pointer
,	O
mu_stream_strerror	function
(	O
stream	pointer
,	O
rc	int
)	O
)	O
;	O
return	O
;	O
}	O
mu_stream_copy	function
(	O
out	pointer
,	O
stream	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
}	O
static	O
int	O
check_headers	function
(	O
mu_stream_t	pointer
input	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
mu_stream_seek	function
(	O
input	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
switch	O
(	O
parse_headers	function
(	O
input	pointer
,	O
env	pointer
)	O
)	O
{	O
case	O
parse_headers_ok	int
:	O
return	O
0	int
;	O
case	O
parse_headers_fatal	int
:	O
return	O
-	O
1	int
;	O
case	O
parse_headers_error	int
:	O
break	O
;	O
}	O
p	pointer
=	O
ml_readline	function
(	O
_	O
(	O
"Edit again?"	pointer
)	O
)	O
;	O
return	O
mu_true_answer_p	function
(	O
p	pointer
)	O
;	O
}	O
static	O
void	O
escape_continue	function
(	O
void	O
)	O
{	O
mu_printf	function
(	O
_	O
(	O
"(continue)\n"	pointer
)	O
)	O
;	O
}	O
int	O
escape_check_args	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
int	O
minargs	int
,	O
int	O
maxargs	int
)	O
{	O
char	O
*	O
escape	pointer
=	O
"~"	pointer
;	O
if	O
(	O
argc	int
<	O
minargs	int
)	O
{	O
minargs	int
--	O
;	O
mailvar_get	function
(	O
&	O
escape	pointer
,	O
mailvar_name_escape	pointer
,	O
mailvar_type_string	int
,	O
0	int
)	O
;	O
mu_error	function
(	O
ngettext	function
(	O
"%c%s requires at least %d argument"	pointer
,	O
"%c%s requires at least %d arguments"	pointer
,	O
minargs	int
)	O
,	O
escape	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
0	int
]	O
,	O
minargs	int
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
maxargs	int
>	O
1	int
&&	O
argc	int
>	O
maxargs	int
)	O
{	O
maxargs	int
--	O
;	O
mailvar_get	function
(	O
&	O
escape	pointer
,	O
mailvar_name_escape	pointer
,	O
mailvar_type_string	int
,	O
0	int
)	O
;	O
mu_error	function
(	O
ngettext	function
(	O
"%c%s accepts at most %d argument"	pointer
,	O
"%c%s accepts at most %d arguments"	pointer
,	O
maxargs	int
)	O
,	O
escape	pointer
[	O
0	int
]	O
,	O
argv	pointer
[	O
0	int
]	O
,	O
maxargs	int
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
int	O
escape_shell	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
return	O
mail_execute	function
(	O
1	int
,	O
argv	pointer
[	O
1	int
]	O
,	O
argc	int
-	O
1	int
,	O
argv	pointer
+	O
1	int
)	O
;	O
}	O
int	O
escape_command	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
const	O
struct	O
mail_command_entry	struct
*	O
entry	pointer
;	O
int	O
status	int
;	O
if	O
(	O
escape_check_args	function
(	O
argc	int
,	O
argv	pointer
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
if	O
(	O
argv	pointer
[	O
1	int
]	O
[	O
0	int
]	O
==	O
'#'	O
)	O
return	O
0	int
;	O
entry	pointer
=	O
mail_find_command	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
if	O
(	O
!	O
entry	pointer
)	O
{	O
mu_error	function
(	O
_	O
(	O
"Unknown command: %s"	pointer
)	O
,	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
entry	pointer
->	O
flags	int
&	O
(	O
EF_FLOW	int
|	O
EF_SEND	int
)	O
)	O
{	O
mu_error	function
(	O
_	O
(	O
"Command not allowed in an escape sequence\n"	pointer
)	O
)	O
;	O
return	O
1	int
;	O
}	O
status	int
=	O
(	O
*	O
entry	pointer
->	O
func	pointer
)	O
(	O
argc	int
-	O
1	int
,	O
argv	pointer
+	O
1	int
)	O
;	O
return	O
status	int
;	O
}	O
int	O
escape_help	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
MU_ARG_UNUSED	O
)	O
{	O
int	O
status	int
;	O
if	O
(	O
argc	int
<	O
2	int
)	O
status	int
=	O
mail_escape_help	function
(	O
NULL	O
)	O
;	O
else	O
while	O
(	O
--	O
argc	int
)	O
status	int
|=	O
mail_escape_help	function
(	O
*	O
++	O
argv	pointer
)	O
;	O
escape_continue	function
(	O
)	O
;	O
return	O
status	int
;	O
}	O
int	O
escape_sign	function
(	O
int	O
argc	int
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
if	O
(	O
mailvar_get	function
(	O
&	O
p	pointer
,	O
mu_isupper	O
(	O
argv	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
?	O
mailvar_name_Sign	pointer
:	O
mailvar_name_sign	pointer
,	O
mailvar_type_string	int
,	O
1	int
)	O
==	O
0	int
)	O
{	O
mu_stream_printf	function
(	O
env	pointer
->	O
compstr	pointer
,	O
"-- \n"	pointer
)	O
;	O
if	O
(	O
mu_isupper	O
(	O
argv	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
)	O
{	O
char	O
*	O
name	pointer
=	O
util_fullpath	function
(	O
p	pointer
)	O
;	O
int	O
rc	int
;	O
mu_stream_t	pointer
signstr	pointer
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
signstr	pointer
,	O
name	pointer
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
mu_error	function
(	O
_	O
(	O
"Cannot open %s: %s"	pointer
)	O
,	O
name	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
else	O
{	O
mu_printf	function
(	O
_	O
(	O
"Reading %s\n"	pointer
)	O
,	O
name	pointer
)	O
;	O
mu_stream_copy	function
(	O
env	pointer
->	O
compstr	pointer
,	O
signstr	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
signstr	pointer
)	O
;	O
}	O
}	O
else	O
mu_stream_printf	function
(	O
env	pointer
->	O
compstr	pointer
,	O
"%s\n"	pointer
,	O
p	pointer
)	O
;	O
escape_continue	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
int	O
escape_bcc	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
while	O
(	O
--	O
argc	int
)	O
compose_header_set	function
(	O
env	pointer
,	O
MU_HEADER_BCC	pointer
,	O
*	O
++	O
argv	pointer
,	O
COMPOSE_SINGLE_LINE	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_cc	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
while	O
(	O
--	O
argc	int
)	O
compose_header_set	function
(	O
env	pointer
,	O
MU_HEADER_CC	pointer
,	O
*	O
++	O
argv	pointer
,	O
COMPOSE_SINGLE_LINE	int
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
verbose_copy	function
(	O
mu_stream_t	pointer
dest	pointer
,	O
mu_stream_t	pointer
src	pointer
,	O
const	O
char	O
*	O
filename	pointer
,	O
mu_off_t	long
*	O
psize	pointer
)	O
{	O
int	O
rc	int
;	O
char	O
*	O
buf	pointer
=	O
NULL	O
;	O
size_t	long
size	long
=	O
0	int
,	O
n	pointer
;	O
size_t	long
lines	long
;	O
mu_off_t	long
total	long
;	O
total	long
=	O
lines	long
=	O
0	int
;	O
while	O
(	O
(	O
rc	int
=	O
mu_stream_getline	function
(	O
src	pointer
,	O
&	O
buf	pointer
,	O
&	O
size	long
,	O
&	O
n	pointer
)	O
)	O
==	O
0	int
&&	O
n	pointer
>	O
0	int
)	O
{	O
lines	long
++	O
;	O
rc	int
=	O
mu_stream_write	function
(	O
dest	pointer
,	O
buf	pointer
,	O
n	pointer
,	O
NULL	O
)	O
;	O
if	O
(	O
rc	int
)	O
break	O
;	O
total	long
+=	O
n	pointer
;	O
}	O
if	O
(	O
rc	int
)	O
mu_error	function
(	O
_	O
(	O
"error copying data: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
mu_printf	function
(	O
"\"%s\" %lu/%lu\n"	pointer
,	O
filename	pointer
,	O
(	O
unsigned	O
long	O
)	O
lines	long
,	O
(	O
unsigned	O
long	O
)	O
total	long
)	O
;	O
if	O
(	O
psize	pointer
)	O
*	O
psize	pointer
=	O
total	long
;	O
return	O
rc	int
;	O
}	O
int	O
escape_deadletter	function
(	O
int	O
argc	int
MU_ARG_UNUSED	O
,	O
char	O
*	O
*	O
argv	pointer
MU_ARG_UNUSED	O
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
const	O
char	O
*	O
name	pointer
=	O
getenv	function
(	O
"DEAD"	pointer
)	O
;	O
mu_stream_t	pointer
str	pointer
;	O
int	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
str	pointer
,	O
name	pointer
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"Cannot open file %s: %s"	pointer
)	O
,	O
name	pointer
,	O
strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
1	int
;	O
}	O
verbose_copy	function
(	O
env	pointer
->	O
compstr	pointer
,	O
str	pointer
,	O
name	pointer
,	O
NULL	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
str	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
run_editor	function
(	O
char	O
*	O
ed	pointer
,	O
char	O
*	O
arg	pointer
)	O
{	O
char	O
*	O
argv	pointer
[	O
3	int
]	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
ed	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
arg	pointer
;	O
argv	pointer
[	O
2	int
]	O
=	O
NULL	O
;	O
return	O
mail_execute	function
(	O
1	int
,	O
ed	pointer
,	O
2	int
,	O
argv	pointer
)	O
;	O
}	O
static	O
int	O
escape_run_editor	function
(	O
char	O
*	O
ed	pointer
,	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
filename	pointer
;	O
int	O
fd	int
;	O
mu_stream_t	pointer
tempstream	pointer
;	O
int	O
rc	int
;	O
rc	int
=	O
mu_tempfile	function
(	O
NULL	O
,	O
0	int
,	O
&	O
fd	int
,	O
&	O
filename	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_tempfile"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
rc	int
;	O
}	O
rc	int
=	O
mu_fd_stream_create	function
(	O
&	O
tempstream	pointer
,	O
filename	pointer
,	O
fd	int
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_fd_stream_create"	pointer
,	O
filename	pointer
,	O
rc	int
)	O
;	O
unlink	function
(	O
filename	pointer
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
rc	int
;	O
}	O
mu_stream_seek	function
(	O
env	pointer
->	O
compstr	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
if	O
(	O
mailvar_is_true	function
(	O
mailvar_name_editheaders	pointer
)	O
)	O
{	O
dump_headers	function
(	O
tempstream	pointer
,	O
env	pointer
)	O
;	O
mu_stream_copy	function
(	O
tempstream	pointer
,	O
env	pointer
->	O
compstr	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
do	O
{	O
mu_stream_destroy	function
(	O
&	O
tempstream	pointer
)	O
;	O
run_editor	function
(	O
ed	pointer
,	O
filename	pointer
)	O
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
tempstream	pointer
,	O
filename	pointer
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_file_stream_create"	pointer
,	O
filename	pointer
,	O
rc	int
)	O
;	O
unlink	function
(	O
filename	pointer
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
while	O
(	O
check_headers	function
(	O
tempstream	pointer
,	O
env	pointer
)	O
)	O
;	O
}	O
else	O
{	O
mu_stream_copy	function
(	O
tempstream	pointer
,	O
env	pointer
->	O
compstr	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
tempstream	pointer
)	O
;	O
run_editor	function
(	O
ed	pointer
,	O
filename	pointer
)	O
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
tempstream	pointer
,	O
filename	pointer
,	O
MU_STREAM_RDWR	O
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_file_stream_create"	pointer
,	O
filename	pointer
,	O
rc	int
)	O
;	O
unlink	function
(	O
filename	pointer
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
return	O
rc	int
;	O
}	O
}	O
if	O
(	O
rc	int
==	O
0	int
)	O
{	O
mu_off_t	long
size	long
;	O
mu_stream_seek	function
(	O
env	pointer
->	O
compstr	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
mu_stream_copy	function
(	O
env	pointer
->	O
compstr	pointer
,	O
tempstream	pointer
,	O
0	int
,	O
&	O
size	long
)	O
;	O
mu_stream_truncate	function
(	O
env	pointer
->	O
compstr	pointer
,	O
size	long
)	O
;	O
}	O
mu_stream_destroy	function
(	O
&	O
tempstream	pointer
)	O
;	O
unlink	function
(	O
filename	pointer
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
mu_stream_seek	function
(	O
env	pointer
->	O
compstr	pointer
,	O
0	int
,	O
MU_SEEK_END	int
,	O
NULL	O
)	O
;	O
escape_continue	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_editor	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
return	O
escape_run_editor	function
(	O
getenv	function
(	O
"EDITOR"	pointer
)	O
,	O
argc	int
,	O
argv	pointer
,	O
env	pointer
)	O
;	O
}	O
int	O
escape_visual	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
return	O
escape_run_editor	function
(	O
getenv	function
(	O
"VISUAL"	pointer
)	O
,	O
argc	int
,	O
argv	pointer
,	O
env	pointer
)	O
;	O
}	O
int	O
escape_print	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
MU_ARG_UNUSED	O
)	O
{	O
return	O
mail_print	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
}	O
void	O
reread_header	function
(	O
compose_env_t	struct
*	O
env	pointer
,	O
char	O
*	O
hdr	pointer
,	O
char	O
*	O
prompt	pointer
)	O
{	O
char	O
*	O
p	pointer
;	O
p	pointer
=	O
mu_strdup	function
(	O
compose_header_get	function
(	O
env	pointer
,	O
hdr	pointer
,	O
""	pointer
)	O
)	O
;	O
ml_reread	function
(	O
prompt	pointer
,	O
&	O
p	pointer
)	O
;	O
compose_header_set	function
(	O
env	pointer
,	O
hdr	pointer
,	O
p	pointer
,	O
COMPOSE_REPLACE	int
)	O
;	O
free	function
(	O
p	pointer
)	O
;	O
}	O
int	O
escape_headers	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
reread_header	function
(	O
env	pointer
,	O
MU_HEADER_TO	pointer
,	O
"To: "	pointer
)	O
;	O
reread_header	function
(	O
env	pointer
,	O
MU_HEADER_CC	pointer
,	O
"Cc: "	pointer
)	O
;	O
reread_header	function
(	O
env	pointer
,	O
MU_HEADER_BCC	pointer
,	O
"Bcc: "	pointer
)	O
;	O
reread_header	function
(	O
env	pointer
,	O
MU_HEADER_SUBJECT	pointer
,	O
"Subject: "	pointer
)	O
;	O
escape_continue	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_insert	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
if	O
(	O
escape_check_args	function
(	O
argc	int
,	O
argv	pointer
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
mailvar_variable_format	function
(	O
env	pointer
->	O
compstr	pointer
,	O
mailvar_find_variable	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
0	int
)	O
,	O
NULL	O
)	O
;	O
return	O
0	int
;	O
}	O
struct	O
quote_closure	struct
{	O
mu_stream_t	pointer
str	pointer
;	O
int	O
islower	int
;	O
}	O
;	O
int	O
quote0	function
(	O
msgset_t	struct
*	O
mspec	pointer
,	O
mu_message_t	pointer
mesg	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
struct	O
quote_closure	struct
*	O
clos	pointer
=	O
data	pointer
;	O
int	O
rc	int
;	O
mu_stream_t	pointer
stream	pointer
;	O
char	O
*	O
prefix	array
=	O
"\t"	pointer
;	O
mu_stream_t	pointer
flt	pointer
;	O
char	O
*	O
argv	pointer
[	O
3	int
]	O
;	O
mu_printf	function
(	O
_	O
(	O
"Interpolating: %lu\n"	pointer
)	O
,	O
(	O
unsigned	O
long	O
)	O
mspec	pointer
->	O
msg_part	pointer
[	O
0	int
]	O
)	O
;	O
mailvar_get	function
(	O
&	O
prefix	array
,	O
mailvar_name_indentprefix	pointer
,	O
mailvar_type_string	int
,	O
0	int
)	O
;	O
argv	pointer
[	O
0	int
]	O
=	O
"INLINE-COMMENT"	pointer
;	O
argv	pointer
[	O
1	int
]	O
=	O
prefix	array
;	O
argv	pointer
[	O
2	int
]	O
=	O
NULL	O
;	O
rc	int
=	O
mu_filter_create_args	function
(	O
&	O
flt	pointer
,	O
clos	pointer
->	O
str	pointer
,	O
"INLINE-COMMENT"	pointer
,	O
2	int
,	O
(	O
const	O
char	O
*	O
*	O
)	O
argv	pointer
,	O
MU_FILTER_ENCODE	int
,	O
MU_STREAM_WRITE	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_filter_create_args"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
return	O
rc	int
;	O
}	O
if	O
(	O
clos	pointer
->	O
islower	int
)	O
{	O
mu_header_t	pointer
hdr	pointer
;	O
mu_body_t	pointer
body	pointer
;	O
mu_iterator_t	pointer
itr	pointer
;	O
mu_message_get_header	function
(	O
mesg	pointer
,	O
&	O
hdr	pointer
)	O
;	O
mu_header_get_iterator	function
(	O
hdr	pointer
,	O
&	O
itr	pointer
)	O
;	O
for	O
(	O
mu_iterator_first	function
(	O
itr	pointer
)	O
;	O
!	O
mu_iterator_is_done	function
(	O
itr	pointer
)	O
;	O
mu_iterator_next	function
(	O
itr	pointer
)	O
)	O
{	O
const	O
char	O
*	O
name	pointer
,	O
*	O
value	pointer
;	O
if	O
(	O
mu_iterator_current_kv	function
(	O
itr	pointer
,	O
(	O
const	O
void	O
*	O
*	O
)	O
&	O
name	pointer
,	O
(	O
void	O
*	O
*	O
)	O
&	O
value	pointer
)	O
==	O
0	int
&&	O
mail_header_is_visible	function
(	O
name	pointer
)	O
)	O
mu_stream_printf	function
(	O
flt	pointer
,	O
"%s: %s\n"	pointer
,	O
name	pointer
,	O
value	pointer
)	O
;	O
}	O
mu_iterator_destroy	function
(	O
&	O
itr	pointer
)	O
;	O
mu_stream_write	function
(	O
flt	pointer
,	O
"\n"	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
mu_message_get_body	function
(	O
mesg	pointer
,	O
&	O
body	pointer
)	O
;	O
rc	int
=	O
mu_body_get_streamref	function
(	O
body	pointer
,	O
&	O
stream	pointer
)	O
;	O
}	O
else	O
rc	int
=	O
mu_message_get_streamref	function
(	O
mesg	pointer
,	O
&	O
stream	pointer
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"get_streamref error: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
return	O
rc	int
;	O
}	O
mu_stream_copy	function
(	O
flt	pointer
,	O
stream	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
stream	pointer
)	O
;	O
mu_stream_destroy	function
(	O
&	O
flt	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_quote	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
struct	O
quote_closure	struct
clos	pointer
;	O
clos	pointer
.	O
str	pointer
=	O
env	pointer
->	O
compstr	pointer
;	O
clos	pointer
.	O
islower	int
=	O
mu_islower	O
(	O
argv	pointer
[	O
0	int
]	O
[	O
0	int
]	O
)	O
;	O
util_foreach_msg	function
(	O
argc	int
,	O
argv	pointer
,	O
MSG_NODELETED	int
|	O
MSG_SILENT	int
,	O
quote0	function
,	O
&	O
clos	pointer
)	O
;	O
escape_continue	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_type_input	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
mu_printf	function
(	O
_	O
(	O
"Message contains:\n"	pointer
)	O
)	O
;	O
dump_headers	function
(	O
mu_strout	pointer
,	O
env	pointer
)	O
;	O
mu_stream_seek	function
(	O
env	pointer
->	O
compstr	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
mu_stream_copy	function
(	O
mu_strout	pointer
,	O
env	pointer
->	O
compstr	pointer
,	O
0	int
,	O
NULL	O
)	O
;	O
escape_continue	function
(	O
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_read	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
MU_ARG_UNUSED	O
)	O
{	O
char	O
*	O
filename	pointer
;	O
mu_stream_t	pointer
instr	pointer
;	O
int	O
rc	int
;	O
if	O
(	O
escape_check_args	function
(	O
argc	int
,	O
argv	pointer
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
filename	pointer
=	O
util_fullpath	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
instr	pointer
,	O
filename	pointer
,	O
MU_STREAM_READ	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"Cannot open %s: %s"	pointer
)	O
,	O
filename	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
return	O
1	int
;	O
}	O
verbose_copy	function
(	O
env	pointer
->	O
compstr	pointer
,	O
instr	pointer
,	O
filename	pointer
,	O
NULL	O
)	O
;	O
mu_stream_destroy	function
(	O
&	O
instr	pointer
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_subj	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
buf	pointer
;	O
if	O
(	O
escape_check_args	function
(	O
argc	int
,	O
argv	pointer
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
mu_argcv_string	function
(	O
argc	int
-	O
1	int
,	O
argv	pointer
+	O
1	int
,	O
&	O
buf	pointer
)	O
;	O
compose_header_set	function
(	O
env	pointer
,	O
MU_HEADER_SUBJECT	pointer
,	O
buf	pointer
,	O
COMPOSE_REPLACE	int
)	O
;	O
free	function
(	O
buf	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_to	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
while	O
(	O
--	O
argc	int
)	O
compose_header_set	function
(	O
env	pointer
,	O
MU_HEADER_TO	pointer
,	O
*	O
++	O
argv	pointer
,	O
COMPOSE_SINGLE_LINE	int
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_write	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
char	O
*	O
filename	pointer
;	O
mu_stream_t	pointer
wstr	pointer
;	O
int	O
rc	int
;	O
mu_off_t	long
size	long
;	O
if	O
(	O
escape_check_args	function
(	O
argc	int
,	O
argv	pointer
,	O
2	int
,	O
2	int
)	O
)	O
return	O
1	int
;	O
filename	pointer
=	O
util_fullpath	function
(	O
argv	pointer
[	O
1	int
]	O
)	O
;	O
rc	int
=	O
mu_file_stream_create	function
(	O
&	O
wstr	pointer
,	O
filename	pointer
,	O
MU_STREAM_WRITE	int
|	O
MU_STREAM_CREAT	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"Cannot open %s for writing: %s"	pointer
)	O
,	O
filename	pointer
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
return	O
1	int
;	O
}	O
mu_stream_seek	function
(	O
env	pointer
->	O
compstr	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
verbose_copy	function
(	O
wstr	pointer
,	O
env	pointer
->	O
compstr	pointer
,	O
filename	pointer
,	O
&	O
size	long
)	O
;	O
mu_stream_truncate	function
(	O
wstr	pointer
,	O
size	long
)	O
;	O
mu_stream_destroy	function
(	O
&	O
wstr	pointer
)	O
;	O
free	function
(	O
filename	pointer
)	O
;	O
return	O
0	int
;	O
}	O
int	O
escape_pipe	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
,	O
compose_env_t	struct
*	O
env	pointer
)	O
{	O
int	O
rc	int
,	O
status	int
;	O
int	O
p	pointer
[	O
2	int
]	O
;	O
pid_t	int
pid	int
;	O
int	O
fd	int
;	O
mu_off_t	long
isize	long
,	O
osize	long
=	O
0	int
;	O
mu_stream_t	pointer
tstr	pointer
;	O
if	O
(	O
pipe	function
(	O
p	pointer
)	O
)	O
{	O
mu_error	function
(	O
"pipe: %s"	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
mu_tempfile	function
(	O
NULL	O
,	O
0	int
,	O
&	O
fd	int
,	O
NULL	O
)	O
)	O
return	O
1	int
;	O
if	O
(	O
(	O
pid	int
=	O
fork	function
(	O
)	O
)	O
<	O
0	int
)	O
{	O
close	pointer
(	O
p	pointer
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
p	pointer
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
mu_error	function
(	O
"fork: %s"	pointer
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
pid	int
==	O
0	int
)	O
{	O
close	pointer
(	O
0	int
)	O
;	O
dup	function
(	O
p	pointer
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
p	pointer
[	O
0	int
]	O
)	O
;	O
close	pointer
(	O
p	pointer
[	O
1	int
]	O
)	O
;	O
close	pointer
(	O
1	int
)	O
;	O
dup	function
(	O
fd	int
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
execvp	function
(	O
argv	pointer
[	O
1	int
]	O
,	O
argv	pointer
+	O
1	int
)	O
;	O
mu_error	function
(	O
_	O
(	O
"Cannot execute `%s': %s"	pointer
)	O
,	O
argv	pointer
[	O
1	int
]	O
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
_exit	function
(	O
127	int
)	O
;	O
}	O
close	pointer
(	O
p	pointer
[	O
0	int
]	O
)	O
;	O
rc	int
=	O
mu_stdio_stream_create	function
(	O
&	O
tstr	pointer
,	O
p	pointer
[	O
1	int
]	O
,	O
MU_STREAM_WRITE	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_diag_funcall	function
(	O
MU_DIAG_ERROR	O
,	O
"mu_stdio_stream_create"	pointer
,	O
NULL	O
,	O
rc	int
)	O
;	O
kill	function
(	O
pid	int
,	O
SIGKILL	int
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
return	O
rc	int
;	O
}	O
mu_stream_seek	function
(	O
env	pointer
->	O
compstr	pointer
,	O
0	int
,	O
MU_SEEK_SET	int
,	O
NULL	O
)	O
;	O
mu_stream_copy	function
(	O
tstr	pointer
,	O
env	pointer
->	O
compstr	pointer
,	O
0	int
,	O
&	O
isize	long
)	O
;	O
mu_stream_destroy	function
(	O
&	O
tstr	pointer
)	O
;	O
waitpid	function
(	O
pid	int
,	O
&	O
status	int
,	O
0	int
)	O
;	O
if	O
(	O
!	O
WIFEXITED	O
(	O
status	int
)	O
)	O
mu_error	function
(	O
_	O
(	O
"Child terminated abnormally: %d"	pointer
)	O
,	O
WEXITSTATUS	O
(	O
status	int
)	O
)	O
;	O
else	O
{	O
struct	O
stat	pointer
st	pointer
;	O
if	O
(	O
fstat	function
(	O
fd	int
,	O
&	O
st	pointer
)	O
)	O
mu_error	function
(	O
_	O
(	O
"Cannot stat output file: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
errno	O
)	O
)	O
;	O
else	O
osize	long
=	O
st	pointer
.	O
st_size	long
;	O
}	O
mu_stream_printf	function
(	O
mu_strout	pointer
,	O
"\"|%s\" in: %lu "	pointer
,	O
argv	pointer
[	O
1	int
]	O
,	O
(	O
unsigned	O
long	O
)	O
isize	long
)	O
;	O
if	O
(	O
osize	long
==	O
0	int
)	O
mu_stream_printf	function
(	O
mu_strout	pointer
,	O
_	O
(	O
"no lines out\n"	pointer
)	O
)	O
;	O
else	O
{	O
mu_stream_t	pointer
str	pointer
;	O
mu_stream_printf	function
(	O
mu_strout	pointer
,	O
"out: %lu\n"	pointer
,	O
(	O
unsigned	O
long	O
)	O
osize	long
)	O
;	O
rc	int
=	O
mu_fd_stream_create	function
(	O
&	O
str	pointer
,	O
NULL	O
,	O
fd	int
,	O
MU_STREAM_RDWR	O
|	O
MU_STREAM_SEEK	int
)	O
;	O
if	O
(	O
rc	int
)	O
{	O
mu_error	function
(	O
_	O
(	O
"Cannot open composition stream: %s"	pointer
)	O
,	O
mu_strerror	function
(	O
rc	int
)	O
)	O
;	O
close	pointer
(	O
fd	int
)	O
;	O
}	O
else	O
{	O
mu_stream_destroy	function
(	O
&	O
env	pointer
->	O
compstr	pointer
)	O
;	O
env	pointer
->	O
compstr	pointer
=	O
str	pointer
;	O
}	O
}	O
return	O
0	int
;	O
}	O
