static	O
char	O
*	O
short_pgm_name	pointer
;	O
enum	O
operation	enum
{	O
OP_NONE	int
,	O
OP_WEAVE	int
,	O
OP_TANGLE	int
}	O
operation	enum
;	O
int	O
opt_line	int
;	O
int	O
filenames_only	int
;	O
int	O
print_unused	int
;	O
int	O
print_catalogues	int
;	O
int	O
print_unanswered	int
;	O
int	O
warn_nonzero_indent	int
;	O
struct	O
input_file	struct
{	O
struct	O
input_file	struct
*	O
outer	pointer
;	O
char	O
*	O
name	pointer
;	O
FILE	struct
*	O
file	pointer
;	O
int	O
line	int
;	O
}	O
;	O
static	O
char	O
*	O
in_file_name	pointer
,	O
*	O
out_file_name	pointer
,	O
*	O
answer_file_name	pointer
;	O
static	O
FILE	struct
*	O
out_file	pointer
,	O
*	O
answer_file	pointer
,	O
*	O
header_file	pointer
;	O
static	O
struct	O
input_file	struct
*	O
in_file	pointer
;	O
static	O
void	O
emitf	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
ATTRIBUTE	O
(	O
(	O
format	pointer
(	O
printf	function
,	O
1	int
,	O
2	int
)	O
)	O
)	O
;	O
static	O
void	O
input_start_pass	function
(	O
void	O
)	O
;	O
static	O
int	O
input_read_line	function
(	O
char	O
*	O
*	O
line	int
,	O
size_t	long
*	O
line_size	pointer
)	O
;	O
struct	O
symbol	struct
;	O
static	O
struct	O
symbol	struct
*	O
symbol_find	function
(	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
len	long
,	O
int	O
add	int
)	O
;	O
static	O
void	O
symbol_init	function
(	O
void	O
)	O
;	O
enum	O
state	enum
{	O
TEXT	int
,	O
CODE	int
,	O
COMMENT	int
,	O
CONTROL	int
}	O
;	O
static	O
int	O
indent_adjust	int
;	O
enum	O
section_level	enum
{	O
LEVEL_CHAPTER	int
,	O
LEVEL_SECTION	int
,	O
LEVEL_SUBSECTION	int
,	O
LEVEL_SUBSUBSECTION	int
,	O
LEVEL_EXERCISE	int
,	O
LEVEL_CNT	int
}	O
;	O
struct	O
section	struct
{	O
short	O
level	array
[	O
LEVEL_CNT	int
]	O
;	O
}	O
;	O
struct	O
section	struct
cur_section	struct
;	O
static	O
void	O
state_init	function
(	O
void	O
)	O
;	O
static	O
int	O
state_cnt	function
(	O
void	O
)	O
;	O
static	O
int	O
state_is	function
(	O
enum	O
state	enum
)	O
;	O
static	O
int	O
state_was	function
(	O
enum	O
state	enum
)	O
;	O
static	O
void	O
state_push	function
(	O
enum	O
state	enum
)	O
;	O
static	O
void	O
state_pop	function
(	O
void	O
)	O
;	O
struct	O
segment	pointer
;	O
static	O
struct	O
segment	pointer
*	O
segment_find	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
create	int
)	O
;	O
static	O
void	O
segment_select	function
(	O
struct	O
segment	pointer
*	O
segment	pointer
)	O
;	O
static	O
int	O
segment_selected_p	function
(	O
void	O
)	O
;	O
static	O
int	O
segment_piece_cur	function
(	O
void	O
)	O
;	O
static	O
int	O
segment_piece_cnt	function
(	O
void	O
)	O
;	O
static	O
int	O
segment_number	function
(	O
void	O
)	O
;	O
static	O
const	O
char	O
*	O
segment_name	function
(	O
void	O
)	O
;	O
static	O
int	O
segment_first_piece	function
(	O
void	O
)	O
;	O
static	O
int	O
segment_inside_indentation	function
(	O
struct	O
segment	pointer
*	O
segment	pointer
)	O
;	O
static	O
void	O
segment_next_piece	function
(	O
void	O
)	O
;	O
static	O
void	O
segment_print_number	function
(	O
struct	O
segment	pointer
*	O
segment	pointer
)	O
;	O
static	O
void	O
segment_add_line	function
(	O
const	O
char	O
*	O
line	int
)	O
;	O
static	O
void	O
piece_create	function
(	O
struct	O
segment	pointer
*	O
s	pointer
,	O
int	O
operation	enum
)	O
;	O
static	O
void	O
piece_references	function
(	O
struct	O
segment	pointer
*	O
reference	pointer
,	O
int	O
indentation	int
)	O
;	O
static	O
void	O
piece_print_trailer	function
(	O
void	O
)	O
;	O
static	O
void	O
print_filename	function
(	O
const	O
char	O
*	O
cp	pointer
)	O
;	O
static	O
void	O
print_anchor_name	function
(	O
const	O
char	O
*	O
node	pointer
,	O
int	O
idx	int
)	O
;	O
static	O
struct	O
symbol	struct
*	O
print_identifier	function
(	O
const	O
char	O
*	O
text	pointer
,	O
int	O
len	long
)	O
;	O
static	O
void	O
print_piece_header	function
(	O
const	O
char	O
*	O
segment_name	function
,	O
int	O
type	int
,	O
int	O
operation	enum
)	O
;	O
static	O
void	O
open_header_file	function
(	O
char	O
*	O
line	int
)	O
;	O
static	O
void	O
close_header_file	function
(	O
void	O
)	O
;	O
static	O
void	O
exercise_begin	function
(	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
;	O
static	O
int	O
exercise_end	function
(	O
const	O
char	O
*	O
cmd	pointer
,	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
;	O
static	O
void	O
exercise_answer	function
(	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
;	O
static	O
void	O
exercise_close_answer_file	function
(	O
void	O
)	O
;	O
static	O
void	O
exercise_open_answer_file	function
(	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
;	O
static	O
int	O
exercise_process	function
(	O
const	O
char	O
*	O
cmd	pointer
,	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
;	O
static	O
int	O
parse_at_cmd	function
(	O
const	O
char	O
*	O
line	int
,	O
char	O
cmd	pointer
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
)	O
;	O
static	O
void	O
add_control	function
(	O
const	O
char	O
*	O
text	pointer
,	O
size_t	long
len	long
)	O
;	O
static	O
char	O
*	O
parse_control_text	function
(	O
char	O
*	O
start	pointer
,	O
char	O
*	O
*	O
tail	pointer
)	O
;	O
struct	O
token	pointer
;	O
static	O
const	O
char	O
*	O
token_get	function
(	O
const	O
char	O
*	O
s	pointer
,	O
struct	O
token	pointer
*	O
token	pointer
)	O
;	O
static	O
const	O
char	O
*	O
token_parse	function
(	O
const	O
char	O
*	O
cp	pointer
,	O
struct	O
token	pointer
*	O
token	pointer
)	O
;	O
static	O
int	O
token_space_p	function
(	O
struct	O
token	pointer
*	O
token	pointer
)	O
;	O
static	O
void	O
weave_pass_one	function
(	O
void	O
)	O
;	O
static	O
char	O
*	O
segment_definition_line	function
(	O
char	O
*	O
line	int
,	O
int	O
*	O
operation	enum
)	O
;	O
static	O
void	O
enforce_references_ordering	function
(	O
void	O
)	O
;	O
static	O
void	O
weave_pass_two	function
(	O
void	O
)	O
;	O
static	O
void	O
transition	function
(	O
enum	O
state	enum
)	O
;	O
static	O
int	O
indent_amount	function
(	O
const	O
char	O
*	O
cp	pointer
,	O
const	O
char	O
*	O
*	O
const	O
end	pointer
)	O
;	O
static	O
int	O
print_line	function
(	O
const	O
char	O
*	O
cp	pointer
,	O
int	O
flags	int
)	O
;	O
static	O
int	O
print	function
(	O
const	O
char	O
*	O
cp	pointer
,	O
int	O
flags	int
)	O
;	O
static	O
void	O
tangle	function
(	O
void	O
)	O
;	O
struct	O
engine_state	struct
;	O
static	O
void	O
init_engine_state	function
(	O
struct	O
engine_state	struct
*	O
s	pointer
)	O
;	O
static	O
int	O
lr_engine	function
(	O
struct	O
engine_state	struct
*	O
engine	pointer
,	O
struct	O
token	pointer
*	O
token	pointer
)	O
;	O
static	O
void	O
declaration_engine	function
(	O
const	O
char	O
*	O
cp	pointer
,	O
int	O
indentation	int
)	O
;	O
static	O
void	O
parse_cmd_line	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
;	O
static	O
void	O
usage	function
(	O
int	O
exit_code	int
)	O
ATTRIBUTE	O
(	O
(	O
noreturn	O
)	O
)	O
;	O
enum	O
{	O
SRC	int
=	O
001	int
,	O
FTL	int
=	O
002	int
}	O
;	O
static	O
void	O
error	function
(	O
int	O
flags	int
,	O
const	O
char	O
*	O
message	pointer
,	O
...	O
)	O
ATTRIBUTE	O
(	O
(	O
format	pointer
(	O
printf	function
,	O
2	int
,	O
3	int
)	O
)	O
)	O
;	O
static	O
void	O
*	O
xmalloc	function
(	O
size_t	long
amt	long
)	O
;	O
static	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
ptr	pointer
,	O
size_t	long
size	long
)	O
;	O
static	O
char	O
*	O
xstrndup	function
(	O
const	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	long
)	O
;	O
static	O
char	O
*	O
xstrdup	function
(	O
const	O
char	O
*	O
string	pointer
)	O
;	O
static	O
int	O
empty_string	function
(	O
const	O
char	O
*	O
string	pointer
)	O
;	O
static	O
void	O
trim_whitespace	function
(	O
char	O
*	O
*	O
bp	pointer
,	O
char	O
*	O
*	O
ep	pointer
)	O
;	O
static	O
int	O
find_argument	function
(	O
char	O
*	O
line	int
,	O
char	O
*	O
*	O
bp	pointer
,	O
char	O
*	O
*	O
ep	pointer
)	O
;	O
static	O
int	O
find_optional_argument	function
(	O
char	O
*	O
line	int
,	O
char	O
*	O
*	O
bp	pointer
,	O
char	O
*	O
*	O
ep	pointer
)	O
;	O
int	O
main	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
parse_cmd_line	function
(	O
argc	int
,	O
argv	pointer
)	O
;	O
symbol_init	function
(	O
)	O
;	O
switch	O
(	O
operation	enum
)	O
{	O
case	O
OP_WEAVE	int
:	O
weave_pass_one	function
(	O
)	O
;	O
weave_pass_two	function
(	O
)	O
;	O
break	O
;	O
case	O
OP_TANGLE	int
:	O
tangle	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
return	O
EXIT_SUCCESS	int
;	O
}	O
static	O
struct	O
dir_directive	struct
{	O
enum	O
operation	enum
include	enum
;	O
char	O
*	O
name	pointer
;	O
int	O
line	int
;	O
}	O
dir_stack	array
[	O
DIR_MAX	int
]	O
;	O
static	O
int	O
dir_stack_height	int
;	O
static	O
int	O
dir_ignore	int
;	O
static	O
void	O
dir_push	function
(	O
enum	O
operation	enum
include	enum
)	O
{	O
if	O
(	O
dir_stack_height	int
>=	O
DIR_MAX	int
)	O
error	function
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Input directives nested too deeply."	pointer
)	O
)	O
;	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
include	enum
=	O
include	enum
;	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
name	pointer
=	O
in_file	pointer
->	O
name	pointer
;	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
line	int
=	O
in_file	pointer
->	O
line	int
;	O
dir_stack_height	int
++	O
;	O
if	O
(	O
include	enum
!=	O
operation	enum
)	O
dir_ignore	int
++	O
;	O
}	O
static	O
void	O
dir_pop	function
(	O
enum	O
operation	enum
include	enum
)	O
{	O
if	O
(	O
dir_stack_height	int
<=	O
0	int
)	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"`@end' pairs with nonexistent input directive."	pointer
)	O
)	O
;	O
return	O
;	O
}	O
dir_stack_height	int
--	O
;	O
if	O
(	O
strcmp	function
(	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
name	pointer
,	O
in_file	pointer
->	O
name	pointer
)	O
)	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"`@end' not in same file as corresponding `@if'."	pointer
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: Here is the corresponding `@if'.\n"	pointer
)	O
,	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
name	pointer
,	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
line	int
)	O
;	O
}	O
else	O
if	O
(	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
include	enum
!=	O
include	enum
)	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"`@end' does not match corresponding `@if'."	pointer
)	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: Here is the corresponding `@if'.\n"	pointer
)	O
,	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
name	pointer
,	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
line	int
)	O
;	O
}	O
if	O
(	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
include	enum
!=	O
operation	enum
)	O
dir_ignore	int
--	O
;	O
}	O
static	O
int	O
dir_parse_ifx	function
(	O
char	O
*	O
line	int
)	O
{	O
char	O
cmd	pointer
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
;	O
if	O
(	O
!	O
parse_at_cmd	function
(	O
line	int
,	O
cmd	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"ifweave"	pointer
)	O
)	O
dir_push	function
(	O
OP_WEAVE	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"iftangle"	pointer
)	O
)	O
dir_push	function
(	O
OP_TANGLE	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"end"	pointer
)	O
)	O
{	O
char	O
*	O
bp	pointer
,	O
*	O
ep	pointer
;	O
if	O
(	O
!	O
find_argument	function
(	O
line	int
,	O
&	O
bp	pointer
,	O
&	O
ep	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
(	O
size_t	long
)	O
(	O
ep	pointer
-	O
bp	pointer
)	O
==	O
strlen	function
(	O
"ifweave"	pointer
)	O
&&	O
!	O
memcmp	function
(	O
bp	pointer
,	O
"ifweave"	pointer
,	O
strlen	function
(	O
"ifweave"	pointer
)	O
)	O
)	O
dir_pop	function
(	O
OP_WEAVE	int
)	O
;	O
else	O
if	O
(	O
(	O
size_t	long
)	O
(	O
ep	pointer
-	O
bp	pointer
)	O
==	O
strlen	function
(	O
"iftangle"	pointer
)	O
&&	O
!	O
memcmp	function
(	O
bp	pointer
,	O
"iftangle"	pointer
,	O
strlen	function
(	O
"iftangle"	pointer
)	O
)	O
)	O
dir_pop	function
(	O
OP_TANGLE	int
)	O
;	O
else	O
return	O
0	int
;	O
}	O
else	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
dir_close	function
(	O
void	O
)	O
{	O
while	O
(	O
dir_stack_height	int
>	O
0	int
)	O
{	O
dir_stack_height	int
--	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"%s:%d: `@if' opened here but never closed.\n"	pointer
)	O
,	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
name	pointer
,	O
dir_stack	array
[	O
dir_stack_height	int
]	O
.	O
line	int
)	O
;	O
}	O
dir_ignore	int
=	O
0	int
;	O
}	O
static	O
void	O
emitf	function
(	O
const	O
char	O
*	O
format	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
assert	O
(	O
out_file	pointer
!=	O
NULL	O
&&	O
format	pointer
!=	O
NULL	O
)	O
;	O
va_start	O
(	O
args	array
,	O
format	pointer
)	O
;	O
vfprintf	function
(	O
out_file	pointer
,	O
format	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
}	O
static	O
void	O
input_push	function
(	O
const	O
char	O
*	O
filename	pointer
)	O
{	O
struct	O
input_file	struct
*	O
f	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
f	pointer
)	O
;	O
f	pointer
->	O
outer	pointer
=	O
in_file	pointer
;	O
f	pointer
->	O
name	pointer
=	O
xstrdup	function
(	O
filename	pointer
)	O
;	O
f	pointer
->	O
file	pointer
=	O
fopen	function
(	O
filename	pointer
,	O
"r"	pointer
)	O
;	O
if	O
(	O
f	pointer
->	O
file	pointer
==	O
NULL	O
)	O
error	function
(	O
FTL	int
,	O
_	O
(	O
"Opening %s for reading: %s"	pointer
)	O
,	O
filename	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
f	pointer
->	O
line	int
=	O
0	int
;	O
in_file	pointer
=	O
f	pointer
;	O
}	O
static	O
void	O
input_pop	function
(	O
void	O
)	O
{	O
struct	O
input_file	struct
*	O
outer	pointer
;	O
assert	O
(	O
in_file	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
fclose	function
(	O
in_file	pointer
->	O
file	pointer
)	O
!=	O
0	int
)	O
error	function
(	O
FTL	int
,	O
_	O
(	O
"Closing %s: %s"	pointer
)	O
,	O
in_file	pointer
->	O
name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
outer	pointer
=	O
in_file	pointer
->	O
outer	pointer
;	O
free	function
(	O
in_file	pointer
)	O
;	O
in_file	pointer
=	O
outer	pointer
;	O
}	O
static	O
void	O
input_start_pass	function
(	O
void	O
)	O
{	O
input_push	function
(	O
in_file_name	pointer
)	O
;	O
}	O
static	O
void	O
input_end_pass	function
(	O
void	O
)	O
{	O
dir_close	function
(	O
)	O
;	O
}	O
static	O
int	O
input_get_line	function
(	O
char	O
*	O
*	O
lineptr	pointer
,	O
size_t	long
*	O
n	pointer
,	O
FILE	struct
*	O
stream	pointer
)	O
{	O
size_t	long
len	long
;	O
int	O
c	int
;	O
if	O
(	O
*	O
lineptr	pointer
==	O
NULL	O
||	O
*	O
n	pointer
<	O
2	int
)	O
{	O
*	O
lineptr	pointer
=	O
xrealloc	function
(	O
*	O
lineptr	pointer
,	O
128	int
)	O
;	O
*	O
n	pointer
=	O
128	int
;	O
}	O
assert	O
(	O
*	O
n	pointer
>	O
0	int
)	O
;	O
len	long
=	O
0	int
;	O
c	int
=	O
getc	function
(	O
stream	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
return	O
-	O
1	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
if	O
(	O
len	long
+	O
1	int
>=	O
*	O
n	pointer
)	O
{	O
*	O
n	pointer
*=	O
2	int
;	O
*	O
lineptr	pointer
=	O
xrealloc	function
(	O
*	O
lineptr	pointer
,	O
*	O
n	pointer
)	O
;	O
}	O
(	O
*	O
lineptr	pointer
)	O
[	O
len	long
++	O
]	O
=	O
c	int
;	O
if	O
(	O
c	int
==	O
'\n'	O
)	O
break	O
;	O
c	int
=	O
getc	function
(	O
stream	pointer
)	O
;	O
if	O
(	O
c	int
==	O
EOF	O
)	O
break	O
;	O
}	O
(	O
*	O
lineptr	pointer
)	O
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
len	long
;	O
}	O
static	O
int	O
input_parse_include	function
(	O
char	O
*	O
line	int
)	O
{	O
static	O
const	O
char	O
include	enum
[	O
]	O
=	O
"@include"	pointer
;	O
char	O
*	O
bp	pointer
,	O
*	O
ep	pointer
;	O
if	O
(	O
strncmp	function
(	O
line	int
,	O
include	enum
,	O
strlen	function
(	O
include	enum
)	O
)	O
||	O
!	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
line	int
[	O
strlen	function
(	O
include	enum
)	O
]	O
)	O
)	O
return	O
0	int
;	O
find_argument	function
(	O
line	int
,	O
&	O
bp	pointer
,	O
&	O
ep	pointer
)	O
;	O
*	O
ep	pointer
=	O
'\0'	O
;	O
if	O
(	O
answer_file_name	pointer
!=	O
NULL	O
&&	O
!	O
strcmp	function
(	O
bp	pointer
,	O
answer_file_name	pointer
)	O
)	O
{	O
exercise_close_answer_file	function
(	O
)	O
;	O
input_push	function
(	O
bp	pointer
)	O
;	O
}	O
else	O
if	O
(	O
ep	pointer
-	O
bp	pointer
>	O
2	int
&&	O
!	O
strcmp	function
(	O
ep	pointer
-	O
2	int
,	O
".w"	pointer
)	O
)	O
input_push	function
(	O
bp	pointer
)	O
;	O
else	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
input_read_line	function
(	O
char	O
*	O
*	O
line	int
,	O
size_t	long
*	O
line_size	pointer
)	O
{	O
while	O
(	O
in_file	pointer
!=	O
NULL	O
)	O
{	O
int	O
line_len	int
=	O
input_get_line	function
(	O
line	int
,	O
line_size	pointer
,	O
in_file	pointer
->	O
file	pointer
)	O
;	O
in_file	pointer
->	O
line	int
++	O
;	O
if	O
(	O
line_len	int
!=	O
-	O
1	int
)	O
{	O
if	O
(	O
dir_parse_ifx	function
(	O
*	O
line	int
)	O
||	O
dir_ignore	int
)	O
continue	O
;	O
if	O
(	O
input_parse_include	function
(	O
*	O
line	int
)	O
)	O
continue	O
;	O
return	O
1	int
;	O
}	O
if	O
(	O
ferror	function
(	O
in_file	pointer
->	O
file	pointer
)	O
)	O
error	function
(	O
FTL	int
,	O
_	O
(	O
"Error reading %s: %s"	pointer
)	O
,	O
in_file	pointer
->	O
name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
input_pop	function
(	O
)	O
;	O
}	O
return	O
0	int
;	O
}	O
enum	O
{	O
KW_AUTO	int
,	O
KW_BREAK	int
,	O
KW_CASE	int
,	O
KW_CHAR	int
,	O
KW_COMPLEX	int
,	O
KW_CONST	int
,	O
KW_CONTINUE	int
,	O
KW_DEFAULT	int
,	O
KW_DEFINED	int
,	O
KW_DO	int
,	O
KW_DOUBLE	int
,	O
KW_ELSE	int
,	O
KW_ENUM	int
,	O
KW_EXTERN	int
,	O
KW_FLOAT	int
,	O
KW_FOR	int
,	O
KW_GOTO	int
,	O
KW_IF	int
,	O
KW_IMAGINARY	int
,	O
KW_INLINE	int
,	O
KW_INT	int
,	O
KW_LONG	int
,	O
KW_REGISTER	int
,	O
KW_RESTRICT	int
,	O
KW_RETURN	int
,	O
KW_SHORT	int
,	O
KW_SIGNED	int
,	O
KW_SIZEOF	int
,	O
KW_STATIC	int
,	O
KW_STRUCT	int
,	O
KW_SWITCH	int
,	O
KW_TYPEDEF	int
,	O
KW_UNION	int
,	O
KW_UNSIGNED	int
,	O
KW_VOID	int
,	O
KW_VOLATILE	int
,	O
KW_WHILE	int
,	O
KW_OTHER	int
,	O
KW_CNT	int
}	O
;	O
struct	O
symbol	struct
{	O
struct	O
symbol	struct
*	O
next	pointer
;	O
char	O
*	O
name	pointer
;	O
struct	O
segment	pointer
*	O
segment	pointer
;	O
int	O
is_typedef	int
;	O
int	O
kw_idx	int
;	O
struct	O
catalogue	pointer
*	O
catalogue	pointer
;	O
}	O
;	O
static	O
struct	O
symbol	struct
*	O
symbol_table	array
[	O
SYMBOL_TABLE_SIZE	int
]	O
;	O
static	O
struct	O
symbol	struct
*	O
symbol_find	function
(	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
len	long
,	O
int	O
add	int
)	O
{	O
unsigned	O
hash	int
;	O
{	O
const	O
char	O
*	O
p	pointer
;	O
hash	int
=	O
0	int
;	O
for	O
(	O
p	pointer
=	O
name	pointer
;	O
p	pointer
<	O
name	pointer
+	O
len	long
;	O
p	pointer
++	O
)	O
hash	int
=	O
hash	int
*	O
33	int
+	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
;	O
hash	int
%=	O
SYMBOL_TABLE_SIZE	int
;	O
}	O
{	O
struct	O
symbol	struct
*	O
*	O
sym	pointer
;	O
for	O
(	O
sym	pointer
=	O
symbol_table	array
+	O
hash	int
;	O
*	O
sym	pointer
;	O
sym	pointer
=	O
&	O
(	O
*	O
sym	pointer
)	O
->	O
next	pointer
)	O
if	O
(	O
strlen	function
(	O
(	O
*	O
sym	pointer
)	O
->	O
name	pointer
)	O
==	O
len	long
&&	O
!	O
memcmp	function
(	O
name	pointer
,	O
(	O
*	O
sym	pointer
)	O
->	O
name	pointer
,	O
len	long
)	O
)	O
return	O
*	O
sym	pointer
;	O
if	O
(	O
add	int
==	O
0	int
)	O
return	O
NULL	O
;	O
*	O
sym	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
*	O
sym	pointer
)	O
;	O
(	O
*	O
sym	pointer
)	O
->	O
next	pointer
=	O
NULL	O
;	O
(	O
*	O
sym	pointer
)	O
->	O
name	pointer
=	O
xstrndup	function
(	O
name	pointer
,	O
len	long
)	O
;	O
(	O
*	O
sym	pointer
)	O
->	O
segment	pointer
=	O
NULL	O
;	O
(	O
*	O
sym	pointer
)	O
->	O
is_typedef	int
=	O
0	int
;	O
(	O
*	O
sym	pointer
)	O
->	O
kw_idx	int
=	O
-	O
1	int
;	O
(	O
*	O
sym	pointer
)	O
->	O
catalogue	pointer
=	O
NULL	O
;	O
return	O
*	O
sym	pointer
;	O
}	O
}	O
static	O
void	O
symbol_foreach	function
(	O
void	O
(	O
*	O
func	pointer
)	O
(	O
struct	O
symbol	struct
*	O
)	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
SYMBOL_TABLE_SIZE	int
;	O
i	int
++	O
)	O
{	O
struct	O
symbol	struct
*	O
sym	pointer
;	O
for	O
(	O
sym	pointer
=	O
symbol_table	array
[	O
i	int
]	O
;	O
sym	pointer
!=	O
NULL	O
;	O
sym	pointer
=	O
sym	pointer
->	O
next	pointer
)	O
func	pointer
(	O
sym	pointer
)	O
;	O
}	O
}	O
static	O
void	O
symbol_init	function
(	O
void	O
)	O
{	O
static	O
const	O
char	O
*	O
keywords	array
[	O
KW_CNT	int
-	O
1	int
]	O
=	O
{	O
"auto"	pointer
,	O
"break"	pointer
,	O
"case"	pointer
,	O
"char"	pointer
,	O
"complex"	pointer
,	O
"const"	pointer
,	O
"continue"	pointer
,	O
"default"	pointer
,	O
"defined"	pointer
,	O
"do"	pointer
,	O
"double"	pointer
,	O
"else"	pointer
,	O
"enum"	pointer
,	O
"extern"	pointer
,	O
"float"	pointer
,	O
"for"	pointer
,	O
"goto"	pointer
,	O
"if"	pointer
,	O
"imaginary"	pointer
,	O
"inline"	pointer
,	O
"int"	pointer
,	O
"long"	pointer
,	O
"register"	pointer
,	O
"restrict"	pointer
,	O
"return"	pointer
,	O
"short"	pointer
,	O
"signed"	pointer
,	O
"sizeof"	pointer
,	O
"static"	pointer
,	O
"struct"	pointer
,	O
"switch"	pointer
,	O
"typedef"	pointer
,	O
"union"	pointer
,	O
"unsigned"	pointer
,	O
"void"	pointer
,	O
"volatile"	pointer
,	O
"while"	pointer
,	O
}	O
;	O
static	O
const	O
char	O
*	O
types	array
[	O
]	O
=	O
{	O
"fenv_t"	pointer
,	O
"fexcept_t"	pointer
,	O
"float_t"	pointer
,	O
"double_t"	pointer
,	O
"jmp_buf"	pointer
,	O
"sig_atomic_t"	pointer
,	O
"va_list"	pointer
,	O
"bool"	pointer
,	O
"ptrdiff_t"	pointer
,	O
"size_t"	pointer
,	O
"wchar_t"	pointer
,	O
"int8_t"	pointer
,	O
"int16_t"	pointer
,	O
"int32_t"	pointer
,	O
"int64_t"	pointer
,	O
"uint8_t"	pointer
,	O
"uint16_t"	pointer
,	O
"uint32_t"	pointer
,	O
"uint64_t"	pointer
,	O
"int_least8_t"	pointer
,	O
"int_least16_t"	pointer
,	O
"int_least32_t"	pointer
,	O
"int_least64_t"	pointer
,	O
"uint_least8_t"	pointer
,	O
"uint_least16_t"	pointer
,	O
"uint_least32_t"	pointer
,	O
"uint_least64_t"	pointer
,	O
"int_fast8_t"	pointer
,	O
"int_fast16_t"	pointer
,	O
"int_fast32_t"	pointer
,	O
"int_fast64_t"	pointer
,	O
"uint_fast8_t"	pointer
,	O
"uint_fast16_t"	pointer
,	O
"uint_fast32_t"	pointer
,	O
"uint_fast64_t"	pointer
,	O
"intptr_t"	pointer
,	O
"uintptr_t"	pointer
,	O
"intmax_t"	pointer
,	O
"uintmax_t"	pointer
,	O
"fpos_t"	pointer
,	O
"FILE"	pointer
,	O
"div_t"	pointer
,	O
"ldiv_t"	pointer
,	O
"lldiv_t"	pointer
,	O
"clock_t"	pointer
,	O
"time_t"	pointer
,	O
"mbstate_t"	pointer
,	O
"wint_t"	pointer
,	O
"wctrans_t"	pointer
,	O
"wctype_t"	pointer
,	O
}	O
;	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
keywords	array
/	O
sizeof	O
*	O
keywords	array
;	O
i	int
++	O
)	O
symbol_find	function
(	O
keywords	array
[	O
i	int
]	O
,	O
strlen	function
(	O
keywords	array
[	O
i	int
]	O
)	O
,	O
1	int
)	O
->	O
kw_idx	int
=	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
types	array
/	O
sizeof	O
*	O
types	array
;	O
i	int
++	O
)	O
symbol_find	function
(	O
types	array
[	O
i	int
]	O
,	O
strlen	function
(	O
types	array
[	O
i	int
]	O
)	O
,	O
1	int
)	O
->	O
is_typedef	int
=	O
1	int
;	O
}	O
struct	O
cat_entry	struct
{	O
int	O
idx	int
;	O
char	O
*	O
label	pointer
;	O
}	O
;	O
struct	O
catalogue	pointer
{	O
int	O
entry_cnt	int
;	O
int	O
entry_cap	int
;	O
struct	O
cat_entry	struct
*	O
entry	pointer
;	O
int	O
idx	int
;	O
int	O
printed	int
;	O
}	O
;	O
static	O
int	O
catalogue_process_one	function
(	O
char	O
*	O
cmd	pointer
,	O
char	O
*	O
line	int
)	O
{	O
char	O
*	O
bp	pointer
,	O
*	O
ep	pointer
;	O
struct	O
symbol	struct
*	O
symbol	struct
;	O
struct	O
catalogue	pointer
*	O
cat	pointer
;	O
struct	O
cat_entry	struct
*	O
entry	pointer
;	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"printcatalogue"	pointer
)	O
)	O
return	O
1	int
;	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
,	O
"cat"	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
find_argument	function
(	O
line	int
,	O
&	O
bp	pointer
,	O
&	O
ep	pointer
)	O
)	O
return	O
0	int
;	O
symbol	struct
=	O
symbol_find	function
(	O
bp	pointer
,	O
strcspn	function
(	O
bp	pointer
,	O
" \t\r\n"	pointer
)	O
,	O
1	int
)	O
;	O
if	O
(	O
symbol	struct
->	O
catalogue	pointer
!=	O
NULL	O
)	O
cat	pointer
=	O
symbol	struct
->	O
catalogue	pointer
;	O
else	O
{	O
cat	pointer
=	O
symbol	struct
->	O
catalogue	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
cat	pointer
)	O
;	O
cat	pointer
->	O
entry_cnt	int
=	O
cat	pointer
->	O
entry_cap	int
=	O
0	int
;	O
cat	pointer
->	O
entry	pointer
=	O
NULL	O
;	O
cat	pointer
->	O
idx	int
=	O
0	int
;	O
cat	pointer
->	O
printed	int
=	O
0	int
;	O
}	O
if	O
(	O
cat	pointer
->	O
entry_cnt	int
>=	O
cat	pointer
->	O
entry_cap	int
)	O
{	O
cat	pointer
->	O
entry_cap	int
=	O
cat	pointer
->	O
entry_cap	int
*	O
3	int
/	O
2	int
+	O
8	int
;	O
cat	pointer
->	O
entry	pointer
=	O
xrealloc	function
(	O
cat	pointer
->	O
entry	pointer
,	O
sizeof	O
*	O
cat	pointer
->	O
entry	pointer
*	O
cat	pointer
->	O
entry_cap	int
)	O
;	O
}	O
assert	O
(	O
cat	pointer
->	O
entry_cnt	int
<	O
cat	pointer
->	O
entry_cap	int
)	O
;	O
if	O
(	O
!	O
find_argument	function
(	O
bp	pointer
,	O
&	O
bp	pointer
,	O
&	O
ep	pointer
)	O
)	O
return	O
0	int
;	O
entry	pointer
=	O
&	O
cat	pointer
->	O
entry	pointer
[	O
cat	pointer
->	O
entry_cnt	int
]	O
;	O
entry	pointer
->	O
idx	int
=	O
cat	pointer
->	O
entry_cnt	int
;	O
entry	pointer
->	O
label	pointer
=	O
xstrndup	function
(	O
bp	pointer
,	O
ep	pointer
-	O
bp	pointer
)	O
;	O
cat	pointer
->	O
entry_cnt	int
++	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
catalogue_compare_entries	function
(	O
const	O
void	O
*	O
pa	pointer
,	O
const	O
void	O
*	O
pb	pointer
)	O
{	O
const	O
struct	O
cat_entry	struct
*	O
a	pointer
=	O
pa	pointer
;	O
const	O
struct	O
cat_entry	struct
*	O
b	pointer
=	O
pb	pointer
;	O
const	O
char	O
*	O
sa	pointer
=	O
a	pointer
->	O
label	pointer
;	O
const	O
char	O
*	O
sb	pointer
=	O
b	pointer
->	O
label	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
char	O
ca	char
=	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
sa	pointer
++	O
)	O
;	O
char	O
cb	char
=	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
sb	pointer
++	O
)	O
;	O
if	O
(	O
ca	char
!=	O
cb	char
)	O
return	O
ca	char
>	O
cb	char
?	O
1	int
:	O
-	O
1	int
;	O
else	O
if	O
(	O
ca	char
==	O
0	int
)	O
return	O
0	int
;	O
}	O
}	O
static	O
void	O
catalogue_print	function
(	O
const	O
char	O
*	O
name	pointer
,	O
struct	O
catalogue	pointer
*	O
cat	pointer
)	O
{	O
int	O
i	int
;	O
cat	pointer
->	O
printed	int
=	O
1	int
;	O
qsort	function
(	O
cat	pointer
->	O
entry	pointer
,	O
cat	pointer
->	O
entry_cnt	int
,	O
sizeof	O
*	O
cat	pointer
->	O
entry	pointer
,	O
catalogue_compare_entries	function
)	O
;	O
emits	O
(	O
"@iftex\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
cat	pointer
->	O
entry_cnt	int
;	O
i	int
++	O
)	O
emitf	function
(	O
"@catentry{catalogue-entry-%s-%d}{%s}\n"	pointer
,	O
name	pointer
,	O
cat	pointer
->	O
entry	pointer
[	O
i	int
]	O
.	O
idx	int
,	O
cat	pointer
->	O
entry	pointer
[	O
i	int
]	O
.	O
label	pointer
)	O
;	O
emits	O
(	O
"@end iftex\n"	pointer
)	O
;	O
emits	O
(	O
"@ifnottex\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
cat	pointer
->	O
entry_cnt	int
;	O
i	int
++	O
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
emitf	function
(	O
"@catentry{catalogue-entry-%s-%d, "	pointer
,	O
name	pointer
,	O
cat	pointer
->	O
entry	pointer
[	O
i	int
]	O
.	O
idx	int
)	O
;	O
for	O
(	O
p	pointer
=	O
cat	pointer
->	O
entry	pointer
[	O
i	int
]	O
.	O
label	pointer
;	O
*	O
p	pointer
!=	O
'\0'	O
;	O
p	pointer
++	O
)	O
{	O
if	O
(	O
*	O
p	pointer
==	O
','	O
)	O
emitc	O
(	O
'\\'	O
)	O
;	O
emitc	O
(	O
*	O
p	pointer
)	O
;	O
}	O
emits	O
(	O
"}\n"	pointer
)	O
;	O
}	O
emits	O
(	O
"@end ifnottex\n"	pointer
)	O
;	O
}	O
static	O
int	O
catalogue_process_two	function
(	O
char	O
*	O
cmd	pointer
,	O
char	O
*	O
line	int
)	O
{	O
char	O
*	O
bp	pointer
,	O
*	O
ep	pointer
;	O
struct	O
symbol	struct
*	O
symbol	struct
;	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
,	O
"printcatalogue"	pointer
)	O
&&	O
strcmp	function
(	O
cmd	pointer
,	O
"cat"	pointer
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
find_argument	function
(	O
line	int
,	O
&	O
bp	pointer
,	O
&	O
ep	pointer
)	O
)	O
return	O
0	int
;	O
ep	pointer
=	O
bp	pointer
+	O
strcspn	function
(	O
bp	pointer
,	O
" \t\r\n"	pointer
)	O
;	O
symbol	struct
=	O
symbol_find	function
(	O
bp	pointer
,	O
ep	pointer
-	O
bp	pointer
,	O
0	int
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"cat"	pointer
)	O
)	O
{	O
if	O
(	O
symbol	struct
==	O
NULL	O
||	O
symbol	struct
->	O
catalogue	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Internal error: no such catalogue `%.*s'."	pointer
)	O
,	O
(	O
int	O
)	O
(	O
ep	pointer
-	O
bp	pointer
)	O
,	O
bp	pointer
)	O
;	O
return	O
1	int
;	O
}	O
emitf	function
(	O
"@anchor{catalogue-entry-%.*s-%d}\n"	pointer
,	O
(	O
int	O
)	O
(	O
ep	pointer
-	O
bp	pointer
)	O
,	O
bp	pointer
,	O
symbol	struct
->	O
catalogue	pointer
->	O
idx	int
++	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
symbol	struct
!=	O
NULL	O
&&	O
symbol	struct
->	O
catalogue	pointer
!=	O
NULL	O
)	O
catalogue_print	function
(	O
symbol	struct
->	O
name	pointer
,	O
symbol	struct
->	O
catalogue	pointer
)	O
;	O
}	O
return	O
1	int
;	O
}	O
static	O
void	O
catalogue_check_printed	function
(	O
struct	O
symbol	struct
*	O
sym	pointer
)	O
{	O
if	O
(	O
sym	pointer
->	O
catalogue	pointer
!=	O
NULL	O
&&	O
sym	pointer
->	O
catalogue	pointer
->	O
printed	int
==	O
0	int
)	O
printf	function
(	O
"%s: Catalogue `%s' never printed.\n"	pointer
,	O
in_file_name	pointer
,	O
sym	pointer
->	O
name	pointer
)	O
;	O
}	O
static	O
void	O
catalogue_print_unused	function
(	O
void	O
)	O
{	O
symbol_foreach	function
(	O
catalogue_check_printed	function
)	O
;	O
}	O
static	O
enum	O
state	enum
state_stack	array
[	O
STATE_STACK_SIZE	int
]	O
;	O
static	O
enum	O
state	enum
*	O
state_top	pointer
;	O
static	O
void	O
state_init	function
(	O
void	O
)	O
{	O
state_top	pointer
=	O
state_stack_end	O
;	O
}	O
static	O
int	O
state_cnt	function
(	O
void	O
)	O
{	O
assert	O
(	O
state_top	pointer
!=	O
NULL	O
)	O
;	O
return	O
state_stack_end	O
-	O
state_top	pointer
;	O
}	O
static	O
int	O
state_is	function
(	O
enum	O
state	enum
state	enum
)	O
{	O
assert	O
(	O
state_top	pointer
!=	O
NULL	O
&&	O
state_top	pointer
<	O
state_stack_end	O
)	O
;	O
return	O
*	O
state_top	pointer
==	O
state	enum
;	O
}	O
static	O
int	O
state_was	function
(	O
enum	O
state	enum
state	enum
)	O
{	O
assert	O
(	O
state_top	pointer
!=	O
NULL	O
)	O
;	O
return	O
state_cnt	function
(	O
)	O
>	O
1	int
&&	O
state_top	pointer
[	O
1	int
]	O
==	O
state	enum
;	O
}	O
static	O
int	O
state_bottom	function
(	O
enum	O
state	enum
state	enum
)	O
{	O
assert	O
(	O
state_top	pointer
<	O
state_stack_end	O
)	O
;	O
return	O
state	enum
==	O
state_stack_end	O
[	O
-	O
1	int
]	O
;	O
}	O
static	O
void	O
state_push	function
(	O
enum	O
state	enum
state	enum
)	O
{	O
assert	O
(	O
state_top	pointer
!=	O
NULL	O
&&	O
state_top	pointer
>	O
state_stack	array
)	O
;	O
*	O
--	O
state_top	pointer
=	O
state	enum
;	O
}	O
static	O
void	O
state_pop	function
(	O
void	O
)	O
{	O
assert	O
(	O
state_top	pointer
!=	O
NULL	O
&&	O
state_top	pointer
<	O
state_stack_end	O
)	O
;	O
state_top	pointer
++	O
;	O
}	O
struct	O
segment	pointer
{	O
char	O
*	O
name	pointer
;	O
int	O
use	int
;	O
struct	O
segment	pointer
*	O
next	pointer
;	O
int	O
piece_cnt	int
;	O
struct	O
piece	pointer
*	O
*	O
piece	pointer
;	O
int	O
piece_cur	int
;	O
int	O
ref_cnt	int
;	O
struct	O
piece	pointer
*	O
*	O
ref	pointer
;	O
int	O
*	O
indent	pointer
;	O
struct	O
segment	pointer
*	O
c_next	pointer
;	O
struct	O
line	int
*	O
c_head	pointer
;	O
struct	O
line	int
*	O
c_tail	pointer
;	O
}	O
;	O
struct	O
piece	pointer
{	O
struct	O
segment	pointer
*	O
segment	pointer
;	O
int	O
number	int
;	O
int	O
ref_cnt	int
;	O
struct	O
segment	pointer
*	O
*	O
ref	pointer
;	O
}	O
;	O
struct	O
loc	struct
{	O
const	O
char	O
*	O
fn	pointer
;	O
int	O
ln	int
;	O
}	O
;	O
struct	O
line	int
{	O
struct	O
line	int
*	O
next	pointer
;	O
const	O
char	O
*	O
text	pointer
;	O
struct	O
loc	struct
loc	struct
;	O
}	O
;	O
static	O
struct	O
segment	pointer
*	O
segment_cur	pointer
;	O
static	O
struct	O
segment	pointer
*	O
segment_first	pointer
,	O
*	O
segment_last	pointer
;	O
static	O
struct	O
segment	pointer
*	O
segment_find	function
(	O
const	O
char	O
*	O
name	pointer
,	O
int	O
create	int
)	O
{	O
struct	O
symbol	struct
*	O
symbol	struct
;	O
struct	O
segment	pointer
*	O
segment	pointer
;	O
size_t	long
len	long
;	O
len	long
=	O
strcspn	function
(	O
name	pointer
,	O
";"	pointer
)	O
;	O
symbol	struct
=	O
symbol_find	function
(	O
name	pointer
,	O
len	long
,	O
create	int
)	O
;	O
if	O
(	O
symbol	struct
==	O
NULL	O
)	O
return	O
NULL	O
;	O
segment	pointer
=	O
symbol	struct
->	O
segment	pointer
;	O
if	O
(	O
segment	pointer
==	O
NULL	O
&&	O
create	int
)	O
{	O
segment	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
segment	pointer
)	O
;	O
segment	pointer
->	O
name	pointer
=	O
xstrndup	function
(	O
name	pointer
,	O
len	long
)	O
;	O
segment	pointer
->	O
use	int
=	O
0	int
;	O
segment	pointer
->	O
next	pointer
=	O
NULL	O
;	O
segment	pointer
->	O
piece_cnt	int
=	O
0	int
;	O
segment	pointer
->	O
piece	pointer
=	O
NULL	O
;	O
segment	pointer
->	O
piece_cur	int
=	O
-	O
1	int
;	O
segment	pointer
->	O
ref_cnt	int
=	O
0	int
;	O
segment	pointer
->	O
ref	pointer
=	O
NULL	O
;	O
segment	pointer
->	O
indent	pointer
=	O
NULL	O
;	O
segment	pointer
->	O
c_head	pointer
=	O
NULL	O
;	O
segment	pointer
->	O
c_tail	pointer
=	O
NULL	O
;	O
symbol	struct
->	O
segment	pointer
=	O
segment	pointer
;	O
if	O
(	O
segment_first	pointer
==	O
NULL	O
)	O
segment_first	pointer
=	O
segment	pointer
;	O
else	O
segment_last	pointer
->	O
next	pointer
=	O
segment	pointer
;	O
segment_last	pointer
=	O
segment	pointer
;	O
}	O
return	O
segment	pointer
;	O
}	O
static	O
void	O
segment_select	function
(	O
struct	O
segment	pointer
*	O
segment	pointer
)	O
{	O
segment_cur	pointer
=	O
segment	pointer
;	O
}	O
static	O
int	O
segment_selected_p	function
(	O
void	O
)	O
{	O
return	O
segment_cur	pointer
!=	O
NULL	O
;	O
}	O
static	O
int	O
segment_piece_cur	function
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	pointer
!=	O
NULL	O
)	O
;	O
return	O
segment_cur	pointer
->	O
piece_cur	int
;	O
}	O
static	O
int	O
segment_piece_cnt	function
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	pointer
!=	O
NULL	O
)	O
;	O
return	O
segment_cur	pointer
->	O
piece_cnt	int
;	O
}	O
static	O
int	O
segment_number	function
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	pointer
!=	O
NULL	O
&&	O
segment_cur	pointer
->	O
piece_cnt	int
>	O
0	int
)	O
;	O
return	O
segment_cur	pointer
->	O
piece	pointer
[	O
segment_cur	pointer
->	O
piece_cur	int
]	O
->	O
number	int
;	O
}	O
static	O
const	O
char	O
*	O
segment_name	function
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	pointer
!=	O
NULL	O
)	O
;	O
return	O
segment_cur	pointer
->	O
name	pointer
;	O
}	O
static	O
int	O
segment_first_piece	function
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	pointer
!=	O
NULL	O
&&	O
segment_cur	pointer
->	O
piece_cnt	int
>	O
0	int
)	O
;	O
return	O
segment_cur	pointer
->	O
piece	pointer
[	O
0	int
]	O
->	O
number	int
;	O
}	O
static	O
int	O
segment_inside_indentation	function
(	O
struct	O
segment	pointer
*	O
segment	pointer
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
segment	pointer
->	O
ref_cnt	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
segment	pointer
->	O
indent	pointer
[	O
i	int
]	O
)	O
return	O
1	int
;	O
if	O
(	O
segment_inside_indentation	function
(	O
segment	pointer
->	O
ref	pointer
[	O
i	int
]	O
->	O
segment	pointer
)	O
)	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
segment_next_piece	function
(	O
void	O
)	O
{	O
assert	O
(	O
segment_cur	pointer
!=	O
NULL	O
&&	O
segment_cur	pointer
->	O
piece_cur	int
<	O
segment_cur	pointer
->	O
piece_cnt	int
-	O
1	int
)	O
;	O
segment_cur	pointer
->	O
piece_cur	int
++	O
;	O
}	O
static	O
void	O
segment_print_number	function
(	O
struct	O
segment	pointer
*	O
segment	pointer
)	O
{	O
if	O
(	O
segment	pointer
!=	O
NULL	O
&&	O
segment	pointer
->	O
piece_cnt	int
!=	O
0	int
)	O
emitf	function
(	O
"%d"	pointer
,	O
segment	pointer
->	O
piece	pointer
[	O
0	int
]	O
->	O
number	int
)	O
;	O
else	O
emits	O
(	O
_	O
(	O
"UNDEFINED"	pointer
)	O
)	O
;	O
}	O
static	O
void	O
segment_add_line	function
(	O
const	O
char	O
*	O
text	pointer
)	O
{	O
struct	O
line	int
*	O
line	int
;	O
if	O
(	O
segment_cur	pointer
==	O
NULL	O
)	O
return	O
;	O
line	int
=	O
xmalloc	function
(	O
sizeof	O
*	O
line	int
)	O
;	O
line	int
->	O
next	pointer
=	O
NULL	O
;	O
line	int
->	O
text	pointer
=	O
xstrdup	function
(	O
text	pointer
)	O
;	O
line	int
->	O
loc	struct
.	O
fn	pointer
=	O
in_file	pointer
->	O
name	pointer
;	O
line	int
->	O
loc	struct
.	O
ln	int
=	O
in_file	pointer
->	O
line	int
;	O
if	O
(	O
segment_cur	pointer
->	O
c_head	pointer
==	O
NULL	O
)	O
segment_cur	pointer
->	O
c_head	pointer
=	O
line	int
;	O
if	O
(	O
segment_cur	pointer
->	O
c_tail	pointer
!=	O
NULL	O
)	O
segment_cur	pointer
->	O
c_tail	pointer
->	O
next	pointer
=	O
line	int
;	O
segment_cur	pointer
->	O
c_tail	pointer
=	O
line	int
;	O
}	O
static	O
void	O
piece_create	function
(	O
struct	O
segment	pointer
*	O
s	pointer
,	O
int	O
operation	enum
)	O
{	O
static	O
int	O
piece_cnt	int
;	O
struct	O
piece	pointer
*	O
p	pointer
;	O
assert	O
(	O
operation	enum
==	O
'='	O
||	O
operation	enum
==	O
'+'	O
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
s	pointer
->	O
name	pointer
,	O
"Anonymous"	pointer
)	O
)	O
{	O
if	O
(	O
operation	enum
==	O
'+'	O
)	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Anonymous segment should not have +=."	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
s	pointer
->	O
piece_cnt	int
==	O
0	int
&&	O
operation	enum
==	O
'+'	O
)	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"First piece of `%s' should not have +=."	pointer
)	O
,	O
s	pointer
->	O
name	pointer
)	O
;	O
else	O
if	O
(	O
s	pointer
->	O
piece_cnt	int
>	O
0	int
&&	O
operation	enum
==	O
'='	O
)	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Second or later piece of `%s' should have +=."	pointer
)	O
,	O
s	pointer
->	O
name	pointer
)	O
;	O
s	pointer
->	O
piece	pointer
=	O
xrealloc	function
(	O
s	pointer
->	O
piece	pointer
,	O
sizeof	O
*	O
s	pointer
->	O
piece	pointer
*	O
(	O
s	pointer
->	O
piece_cnt	int
+	O
1	int
)	O
)	O
;	O
p	pointer
=	O
s	pointer
->	O
piece	pointer
[	O
s	pointer
->	O
piece_cnt	int
++	O
]	O
=	O
xmalloc	function
(	O
sizeof	O
*	O
*	O
s	pointer
->	O
piece	pointer
)	O
;	O
p	pointer
->	O
segment	pointer
=	O
s	pointer
;	O
if	O
(	O
strcmp	function
(	O
s	pointer
->	O
name	pointer
,	O
"Anonymous"	pointer
)	O
)	O
p	pointer
->	O
number	int
=	O
++	O
piece_cnt	int
;	O
p	pointer
->	O
ref_cnt	int
=	O
0	int
;	O
p	pointer
->	O
ref	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
piece_references	function
(	O
struct	O
segment	pointer
*	O
r	pointer
,	O
int	O
indentation	int
)	O
{	O
struct	O
piece	pointer
*	O
piece	pointer
;	O
if	O
(	O
segment_cur	pointer
==	O
NULL	O
)	O
return	O
;	O
piece	pointer
=	O
segment_cur	pointer
->	O
piece	pointer
[	O
segment_cur	pointer
->	O
piece_cnt	int
-	O
1	int
]	O
;	O
piece	pointer
->	O
ref	pointer
=	O
xrealloc	function
(	O
piece	pointer
->	O
ref	pointer
,	O
sizeof	O
*	O
piece	pointer
->	O
ref	pointer
*	O
(	O
piece	pointer
->	O
ref_cnt	int
+	O
1	int
)	O
)	O
;	O
piece	pointer
->	O
ref	pointer
[	O
piece	pointer
->	O
ref_cnt	int
]	O
=	O
r	pointer
;	O
piece	pointer
->	O
ref_cnt	int
++	O
;	O
if	O
(	O
r	pointer
->	O
ref_cnt	int
==	O
0	int
||	O
r	pointer
->	O
ref	pointer
[	O
r	pointer
->	O
ref_cnt	int
-	O
1	int
]	O
->	O
segment	pointer
!=	O
segment_cur	pointer
)	O
{	O
r	pointer
->	O
ref	pointer
=	O
xrealloc	function
(	O
r	pointer
->	O
ref	pointer
,	O
sizeof	O
*	O
r	pointer
->	O
ref	pointer
*	O
(	O
r	pointer
->	O
ref_cnt	int
+	O
1	int
)	O
)	O
;	O
r	pointer
->	O
indent	pointer
=	O
xrealloc	function
(	O
r	pointer
->	O
indent	pointer
,	O
sizeof	O
*	O
r	pointer
->	O
indent	pointer
*	O
(	O
r	pointer
->	O
ref_cnt	int
+	O
1	int
)	O
)	O
;	O
r	pointer
->	O
ref	pointer
[	O
r	pointer
->	O
ref_cnt	int
]	O
=	O
piece	pointer
;	O
r	pointer
->	O
indent	pointer
[	O
r	pointer
->	O
ref_cnt	int
]	O
=	O
indentation	int
;	O
r	pointer
->	O
ref_cnt	int
++	O
;	O
}	O
else	O
if	O
(	O
indentation	int
>	O
r	pointer
->	O
indent	pointer
[	O
r	pointer
->	O
ref_cnt	int
-	O
1	int
]	O
)	O
r	pointer
->	O
indent	pointer
[	O
r	pointer
->	O
ref_cnt	int
-	O
1	int
]	O
=	O
indentation	int
;	O
}	O
static	O
void	O
piece_print_trailer	function
(	O
void	O
)	O
{	O
int	O
comment_cnt	int
;	O
if	O
(	O
!	O
segment_selected_p	function
(	O
)	O
)	O
return	O
;	O
if	O
(	O
segment_cur	pointer
->	O
piece_cur	int
!=	O
0	int
)	O
return	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
segment_cur	pointer
->	O
name	pointer
,	O
"Anonymous"	pointer
)	O
)	O
return	O
;	O
comment_cnt	int
=	O
(	O
segment_piece_cnt	function
(	O
)	O
!=	O
1	int
)	O
+	O
(	O
segment_cur	pointer
->	O
ref_cnt	int
>	O
0	int
)	O
;	O
if	O
(	O
comment_cnt	int
==	O
0	int
)	O
return	O
;	O
emits	O
(	O
"@noindent\n"	pointer
)	O
;	O
if	O
(	O
segment_piece_cnt	function
(	O
)	O
!=	O
1	int
)	O
{	O
int	O
i	int
,	O
cnt	int
;	O
cnt	int
=	O
segment_cur	pointer
->	O
piece_cnt	int
-	O
1	int
;	O
emitf	function
(	O
"@little{%s "	pointer
,	O
_	O
(	O
"See also"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
cnt	int
;	O
i	int
++	O
)	O
{	O
int	O
idx	int
;	O
if	O
(	O
cnt	int
>	O
2	int
)	O
{	O
if	O
(	O
i	int
>	O
0	int
)	O
emits	O
(	O
", "	pointer
)	O
;	O
if	O
(	O
i	int
==	O
cnt	int
-	O
1	int
)	O
emitf	function
(	O
"%s"	pointer
,	O
_	O
(	O
"and"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
cnt	int
==	O
2	int
&&	O
i	int
==	O
1	int
)	O
emitf	function
(	O
" %s "	pointer
,	O
_	O
(	O
"and"	pointer
)	O
)	O
;	O
idx	int
=	O
i	int
;	O
if	O
(	O
i	int
>=	O
segment_cur	pointer
->	O
piece_cur	int
)	O
idx	int
++	O
;	O
emits	O
(	O
"@refalso{"	pointer
)	O
;	O
print_anchor_name	function
(	O
segment_name	function
(	O
)	O
,	O
idx	int
)	O
;	O
emitf	function
(	O
", , @segno{%d}}"	pointer
,	O
segment_cur	pointer
->	O
piece	pointer
[	O
idx	int
]	O
->	O
number	int
)	O
;	O
}	O
emits	O
(	O
".}"	pointer
)	O
;	O
}	O
if	O
(	O
segment_cur	pointer
->	O
ref_cnt	int
>	O
0	int
)	O
{	O
int	O
cnt	int
=	O
segment_cur	pointer
->	O
ref_cnt	int
;	O
int	O
i	int
;	O
if	O
(	O
comment_cnt	int
>	O
1	int
)	O
emits	O
(	O
"@*\n"	pointer
)	O
;	O
emitf	function
(	O
"@little{%s "	pointer
,	O
_	O
(	O
"This code is included in"	pointer
)	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
cnt	int
;	O
i	int
++	O
)	O
{	O
if	O
(	O
cnt	int
>	O
2	int
)	O
{	O
if	O
(	O
i	int
>	O
0	int
)	O
emits	O
(	O
", "	pointer
)	O
;	O
if	O
(	O
i	int
==	O
cnt	int
-	O
1	int
)	O
emitf	function
(	O
"%s "	pointer
,	O
_	O
(	O
"and"	pointer
)	O
)	O
;	O
}	O
else	O
if	O
(	O
cnt	int
==	O
2	int
&&	O
i	int
==	O
1	int
)	O
emitf	function
(	O
" %s "	pointer
,	O
_	O
(	O
"and"	pointer
)	O
)	O
;	O
emits	O
(	O
"@refalso{"	pointer
)	O
;	O
print_anchor_name	function
(	O
segment_cur	pointer
->	O
ref	pointer
[	O
i	int
]	O
->	O
segment	pointer
->	O
name	pointer
,	O
0	int
)	O
;	O
emitf	function
(	O
", , @segno{%d}}"	pointer
,	O
segment_cur	pointer
->	O
ref	pointer
[	O
i	int
]	O
->	O
number	int
)	O
;	O
}	O
emits	O
(	O
".}"	pointer
)	O
;	O
}	O
}	O
static	O
void	O
print_filename	function
(	O
const	O
char	O
*	O
fn	pointer
)	O
{	O
emits	O
(	O
"@t{"	pointer
)	O
;	O
while	O
(	O
*	O
fn	pointer
)	O
{	O
if	O
(	O
*	O
fn	pointer
==	O
'@'	O
||	O
*	O
fn	pointer
==	O
'{'	O
||	O
*	O
fn	pointer
==	O
'}'	O
)	O
emitc	O
(	O
'@'	O
)	O
;	O
emitc	O
(	O
*	O
fn	pointer
)	O
;	O
fn	pointer
++	O
;	O
}	O
emitc	O
(	O
'}'	O
)	O
;	O
}	O
static	O
void	O
print_anchor_name	function
(	O
const	O
char	O
*	O
s	pointer
,	O
int	O
idx	int
)	O
{	O
for	O
(	O
;	O
;	O
)	O
switch	O
(	O
*	O
s	pointer
)	O
{	O
case	O
'.'	O
:	O
case	O
','	O
:	O
case	O
':'	O
:	O
case	O
'\''	O
:	O
case	O
'\\'	O
:	O
case	O
'@'	O
:	O
case	O
'{'	O
:	O
case	O
'}'	O
:	O
s	pointer
++	O
;	O
break	O
;	O
case	O
' '	O
:	O
case	O
'\t'	O
:	O
case	O
'\r'	O
:	O
case	O
'\n'	O
:	O
case	O
'\v'	O
:	O
while	O
(	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
++	O
s	pointer
)	O
)	O
;	O
emitc	O
(	O
' '	O
)	O
;	O
break	O
;	O
case	O
';'	O
:	O
case	O
'\0'	O
:	O
if	O
(	O
idx	int
!=	O
0	int
)	O
emitf	function
(	O
"-%d"	pointer
,	O
idx	int
+	O
1	int
)	O
;	O
return	O
;	O
default	O
:	O
emitc	O
(	O
*	O
s	pointer
++	O
)	O
;	O
break	O
;	O
}	O
}	O
static	O
struct	O
symbol	struct
*	O
print_identifier	function
(	O
const	O
char	O
*	O
text	pointer
,	O
int	O
len	long
)	O
{	O
struct	O
symbol	struct
*	O
symbol	struct
=	O
symbol_find	function
(	O
text	pointer
,	O
len	long
,	O
0	int
)	O
;	O
emits	O
(	O
"@w{"	pointer
)	O
;	O
if	O
(	O
symbol	struct
==	O
NULL	O
||	O
symbol	struct
->	O
kw_idx	int
==	O
-	O
1	int
)	O
{	O
if	O
(	O
symbol	struct
!=	O
NULL	O
&&	O
symbol	struct
->	O
is_typedef	int
)	O
emitf	function
(	O
TYPEDEF_STYLE	pointer
"{%.*s}"	pointer
,	O
len	long
,	O
text	pointer
)	O
;	O
else	O
{	O
const	O
char	O
*	O
p	pointer
;	O
int	O
type	int
;	O
if	O
(	O
len	long
<	O
2	int
)	O
type	int
=	O
'i'	O
;	O
else	O
{	O
type	int
=	O
't'	O
;	O
for	O
(	O
p	pointer
=	O
text	pointer
;	O
p	pointer
<	O
text	pointer
+	O
len	long
;	O
p	pointer
++	O
)	O
if	O
(	O
islower	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
)	O
{	O
type	int
=	O
'i'	O
;	O
break	O
;	O
}	O
}	O
emitf	function
(	O
"@%c{%.*s}"	pointer
,	O
type	int
,	O
len	long
,	O
text	pointer
)	O
;	O
}	O
}	O
else	O
emitf	function
(	O
"@b{%.*s}"	pointer
,	O
len	long
,	O
text	pointer
)	O
;	O
emitc	O
(	O
'}'	O
)	O
;	O
return	O
symbol	struct
;	O
}	O
static	O
void	O
print_piece_header	function
(	O
const	O
char	O
*	O
segment_name	function
,	O
int	O
type	int
,	O
int	O
operation	enum
)	O
{	O
int	O
anonymous	int
=	O
!	O
strcmp	function
(	O
segment_name	function
,	O
"Anonymous"	pointer
)	O
;	O
transition	function
(	O
TEXT	int
)	O
;	O
if	O
(	O
!	O
anonymous	int
)	O
{	O
emits	O
(	O
"@cindex "	pointer
)	O
;	O
if	O
(	O
type	int
==	O
'<'	O
)	O
{	O
if	O
(	O
isupper	function
(	O
(	O
unsigned	O
char	O
)	O
segment_name	function
[	O
0	int
]	O
)	O
&&	O
!	O
isupper	function
(	O
(	O
unsigned	O
char	O
)	O
segment_name	function
[	O
1	int
]	O
)	O
)	O
{	O
emitc	O
(	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
segment_name	function
[	O
0	int
]	O
)	O
)	O
;	O
print	function
(	O
segment_name	function
+	O
1	int
,	O
0	int
)	O
;	O
}	O
else	O
print	function
(	O
segment_name	function
,	O
0	int
)	O
;	O
}	O
else	O
print_filename	function
(	O
segment_name	function
)	O
;	O
emitc	O
(	O
'\n'	O
)	O
;	O
}	O
transition	function
(	O
CODE	int
)	O
;	O
{	O
struct	O
segment	pointer
*	O
segment	pointer
=	O
segment_find	function
(	O
segment_name	function
,	O
0	int
)	O
;	O
assert	O
(	O
segment	pointer
!=	O
NULL	O
)	O
;	O
segment_select	function
(	O
segment	pointer
)	O
;	O
segment_next_piece	function
(	O
)	O
;	O
}	O
if	O
(	O
!	O
anonymous	int
)	O
{	O
emitf	function
(	O
"@tabalign{}@inleftmargin{@w{@segno{%d} }}@nottex{%d. }@value{LANG}@anchor{"	pointer
,	O
segment_number	function
(	O
)	O
,	O
segment_number	function
(	O
)	O
)	O
;	O
print_anchor_name	function
(	O
segment_name	function
,	O
segment_piece_cur	function
(	O
)	O
)	O
;	O
emitc	O
(	O
'}'	O
)	O
;	O
state_push	function
(	O
CONTROL	int
)	O
;	O
if	O
(	O
type	int
==	O
'<'	O
)	O
print	function
(	O
segment_name	function
,	O
0	int
)	O
;	O
else	O
print_filename	function
(	O
segment_name	function
)	O
;	O
state_pop	function
(	O
)	O
;	O
emitf	function
(	O
" @little{%d}@value{RANG} %s@value{IS}@cr\n"	pointer
,	O
segment_first_piece	function
(	O
)	O
,	O
operation	enum
==	O
'+'	O
?	O
"@math{+}"	pointer
:	O
""	pointer
)	O
;	O
}	O
}	O
static	O
void	O
open_header_file	function
(	O
char	O
*	O
line	int
)	O
{	O
static	O
const	O
char	O
*	O
headers	array
[	O
]	O
=	O
{	O
"@set COMMA ,\n"	pointer
,	O
"\n"	pointer
,	O
"@iftex\n"	pointer
,	O
"@set LANG @math{@langle{}@thinspace{}}\n"	pointer
,	O
"@set RANG @math{@thinspace{}@rangle{}}\n"	pointer
,	O
"@set LQUOTE ``\n"	pointer
,	O
"@set RQUOTE ''\n"	pointer
,	O
"@set NULL @math{@Lambda{}}\n"	pointer
,	O
"@set EQ @math{@equiv{}}\n"	pointer
,	O
"@set IS @math{@equiv{}}\n"	pointer
,	O
"@set NE @math{@ne{}@kern-.3333em}\n"	pointer
,	O
"@set GE @math{@ge{}@kern-.3333em}\n"	pointer
,	O
"@set LE @math{@le{}@kern-.3333em}\n"	pointer
,	O
"@set AST @math{@ast{}}\n"	pointer
,	O
"@set AND @math{@wedge{}}\n"	pointer
,	O
"@set OR @math{@vee{}}\n"	pointer
,	O
"@set TIMES @math{@times{}}\n"	pointer
,	O
"@set RARR @math{@rightarrow{}@kern-.3333em}\n"	pointer
,	O
"@set INV @math{@neg{}}\n"	pointer
,	O
"@set SP {@char`@ }\n"	pointer
,	O
"@end iftex\n"	pointer
,	O
"\n"	pointer
,	O
"@ifnottex\n"	pointer
,	O
"@set LANG <\n"	pointer
,	O
"@set RANG >\n"	pointer
,	O
"@set LQUOTE \"\n"	pointer
,	O
"@set RQUOTE \"\n"	pointer
,	O
"@set NULL NULL\n"	pointer
,	O
"@set EQ ==\n"	pointer
,	O
"@set IS =\n"	pointer
,	O
"@set NE !=\n"	pointer
,	O
"@set LE <=\n"	pointer
,	O
"@set GE >=\n"	pointer
,	O
"@set AST *\n"	pointer
,	O
"@set AND &&\n"	pointer
,	O
"@set OR ||\n"	pointer
,	O
"@set TIMES *\n"	pointer
,	O
"@set RARR ->\n"	pointer
,	O
"@set INV !\n"	pointer
,	O
"@set SP @ @c\n"	pointer
,	O
"@end ifnottex\n"	pointer
,	O
"\n"	pointer
,	O
"@ifnottex\n"	pointer
,	O
"@macro inleftmargin{TEXT}\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro nottex{TEXT}\n"	pointer
,	O
"\\TEXT\\\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro segno{NUMBER}\n"	pointer
,	O
"\\NUMBER\\\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro little{TEXT}\n"	pointer
,	O
"\\TEXT\\\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro tabalign\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro wtab\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro tcr{TEXT}\n"	pointer
,	O
"@*\\TEXT\\\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro cleartabs\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro IND{AMT}\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro cr\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro begincode\n"	pointer
,	O
"@format\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro endcode\n"	pointer
,	O
"@end format\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro blankline\n"	pointer
,	O
"@tabalign{}@cr\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro exponent{EXP}\n"	pointer
,	O
"e\\EXP\\\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro unaryminus{}\n"	pointer
,	O
"-\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro unaryplus{}\n"	pointer
,	O
"+\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro exerspace{}\n"	pointer
,	O
"@w{ }\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@end ifnottex\n"	pointer
,	O
"\n"	pointer
,	O
"@iftex\n"	pointer
,	O
"@macro inleftmargin{TEXT}\n"	pointer
,	O
"@hskip -.4in@hbox to .4in{\\TEXT\\@hskip 0in plus1fil}\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro nottex{TEXT}\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro segno{NUMBER}\n"	pointer
,	O
"@S\\NUMBER\\\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro little{TEXT}\n"	pointer
,	O
"{@smallrm{}\\TEXT\\}\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro tcr{TEXT}\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro IND{AMT}\n"	pointer
,	O
"@hskip\\AMT\\\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro begincode\n"	pointer
,	O
"@smallskip\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro endcode\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro blankline\n"	pointer
,	O
"@smallskip\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@alias wtab=tab\n"	pointer
,	O
"@macro exerspace{}\n"	pointer
,	O
"@hskip .5em plus0em minus0em\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@end iftex\n"	pointer
,	O
"\n"	pointer
,	O
"@ifhtml\n"	pointer
,	O
"@macro refcode {TITLE, NODE, SEGMENT}\n"	pointer
,	O
"@value{LANG}@ref{\\NODE\\, , \\TITLE\\ \\SEGMENT\\}@value{RANG}\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@alias refalso=ref\n"	pointer
,	O
"@end ifhtml\n"	pointer
,	O
"\n"	pointer
,	O
"@ifinfo\n"	pointer
,	O
"@ifclear PLAINTEXT\n"	pointer
,	O
"@macro refcode {TITLE, NODE, SEGMENT}\n"	pointer
,	O
"@value{LANG}@ref{\\NODE\\} \\SEGMENT\\@value{RANG}\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@alias refalso=ref\n"	pointer
,	O
"@end ifclear\n"	pointer
,	O
"@ifset PLAINTEXT\n"	pointer
,	O
"@macro refcode {TITLE, NODE, SEGMENT}\n"	pointer
,	O
"@value{LANG}\\TITLE\\ \\SEGMENT\\@value{RANG}\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@macro refalso {TITLE, NODE, SEGMENT}\n"	pointer
,	O
"\\SEGMENT\\\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@end ifset\n"	pointer
,	O
"@end ifinfo\n"	pointer
,	O
"\n"	pointer
,	O
"@iftex\n"	pointer
,	O
"@macro refcode {TITLE, NODE, SEGMENT}\n"	pointer
,	O
"@value{LANG}\\TITLE\\ {@smallrm{}\\SEGMENT\\}@value{RANG}\n"	pointer
,	O
"@end macro\n"	pointer
,	O
"@end iftex\n"	pointer
,	O
"\n"	pointer
,	O
"@tex\n"	pointer
,	O
"\\global\\def\\unaryminus{${}^-$}\n"	pointer
,	O
"\\global\\def\\unaryplus{${}^+$}\n"	pointer
,	O
"\\global\\def\\exponent#1{$\\cdot{}10^{#1}$}\n"	pointer
,	O
"\\global\\def\\refalso#1{\\xrefXalso[#1,,,,,,,]}\n"	pointer
,	O
"\\global\\def\\xrefXalso[#1,#2,#3,#4,#5,#6]{\\begingroup\n"	pointer
,	O
"  \\unsepspaces\n"	pointer
,	O
"  \\def\\printednodename{\\ignorespaces #3}%\n"	pointer
,	O
"  \\setbox0=\\hbox{\\printednodename}%\n"	pointer
,	O
"  \\ifpdf\n"	pointer
,	O
"    \\leavevmode\n"	pointer
,	O
"    \\getfilename{}%\n"	pointer
,	O
"    \\ifnum\\filenamelength>0\n"	pointer
,	O
"      \\startlink attr{/Border [0 0 0]}%\n"	pointer
,	O
"        goto file{\\the\\filename.pdf} name{#1@@}%\n"	pointer
,	O
"    \\else\n"	pointer
,	O
"      \\startlink attr{/Border [0 0 0]}%\n"	pointer
,	O
"        goto name{#1@@}%\n"	pointer
,	O
"    \\fi\n"	pointer
,	O
"    \\linkcolor\n"	pointer
,	O
"  \\fi\n"	pointer
,	O
"  {\\normalturnoffactive\n"	pointer
,	O
"   \\setbox2 = \\hbox{\\ignorespaces \\refx{#1-snt}{}}%\n"	pointer
,	O
"   \\ifdim \\wd2 > 0pt \\refx{#1-snt}\\space\\fi\n"	pointer
,	O
"  }%\n"	pointer
,	O
"  \\printednodename\n"	pointer
,	O
"  \\turnoffactive% \\tie{(page \\refx{#1-pg}{})}%\n"	pointer
,	O
"  \\endlink\n"	pointer
,	O
"\\endgroup}\n"	pointer
,	O
"@end tex\n\n"	pointer
,	O
NULL	O
}	O
;	O
char	O
*	O
bp	pointer
,	O
*	O
ep	pointer
;	O
const	O
char	O
*	O
*	O
p	pointer
;	O
if	O
(	O
!	O
find_argument	function
(	O
line	int
,	O
&	O
bp	pointer
,	O
&	O
ep	pointer
)	O
)	O
return	O
;	O
*	O
ep	pointer
=	O
'\0'	O
;	O
if	O
(	O
header_file	pointer
!=	O
NULL	O
)	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Extra @setheaderfile ignored"	pointer
)	O
)	O
;	O
return	O
;	O
}	O
header_file	pointer
=	O
fopen	function
(	O
bp	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
header_file	pointer
==	O
NULL	O
)	O
error	function
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Opening %s: %s"	pointer
)	O
,	O
bp	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
for	O
(	O
p	pointer
=	O
headers	array
;	O
*	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
++	O
)	O
fputs	function
(	O
*	O
p	pointer
,	O
header_file	pointer
)	O
;	O
}	O
static	O
void	O
close_header_file	function
(	O
void	O
)	O
{	O
if	O
(	O
header_file	pointer
==	O
NULL	O
)	O
error	function
(	O
0	int
,	O
_	O
(	O
"No `@setheaderfile' in source."	pointer
)	O
)	O
;	O
if	O
(	O
fclose	function
(	O
header_file	pointer
)	O
!=	O
0	int
)	O
error	function
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Closing header file: %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
header_file	pointer
=	O
NULL	O
;	O
}	O
static	O
int	O
in_exercise	int
=	O
0	int
;	O
static	O
void	O
section_init	function
(	O
struct	O
section	struct
*	O
section	struct
)	O
{	O
int	O
level	array
;	O
for	O
(	O
level	array
=	O
0	int
;	O
level	array
<	O
LEVEL_CNT	int
;	O
level	array
++	O
)	O
section	struct
->	O
level	array
[	O
level	array
]	O
=	O
0	int
;	O
}	O
static	O
void	O
section_advance	function
(	O
struct	O
section	struct
*	O
section	struct
,	O
enum	O
section_level	enum
level	array
)	O
{	O
if	O
(	O
in_exercise	int
&&	O
level	array
!=	O
LEVEL_EXERCISE	int
)	O
{	O
error	function
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Unterminated exercise at section boundary."	pointer
)	O
)	O
;	O
in_exercise	int
=	O
0	int
;	O
}	O
section	struct
->	O
level	array
[	O
level	array
]	O
++	O
;	O
for	O
(	O
level	array
++	O
;	O
level	array
<	O
LEVEL_CNT	int
;	O
level	array
++	O
)	O
section	struct
->	O
level	array
[	O
level	array
]	O
=	O
0	int
;	O
}	O
static	O
int	O
section_differs	function
(	O
struct	O
section	struct
*	O
a	pointer
,	O
struct	O
section	struct
*	O
b	pointer
,	O
enum	O
section_level	enum
level	array
)	O
{	O
enum	O
section_level	enum
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<=	O
level	array
;	O
i	int
++	O
)	O
if	O
(	O
a	pointer
->	O
level	array
[	O
i	int
]	O
!=	O
b	pointer
->	O
level	array
[	O
i	int
]	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
void	O
section_name	function
(	O
struct	O
section	struct
*	O
section	struct
,	O
char	O
name	pointer
[	O
64	int
]	O
)	O
{	O
int	O
level	array
;	O
sprintf	function
(	O
name	pointer
,	O
"%d"	pointer
,	O
section	struct
->	O
level	array
[	O
LEVEL_CHAPTER	int
]	O
)	O
;	O
for	O
(	O
level	array
=	O
1	int
;	O
level	array
<	O
LEVEL_EXERCISE	int
;	O
level	array
++	O
)	O
{	O
name	pointer
=	O
strchr	function
(	O
name	pointer
,	O
'\0'	O
)	O
;	O
if	O
(	O
section	struct
->	O
level	array
[	O
level	array
]	O
==	O
0	int
)	O
break	O
;	O
sprintf	function
(	O
name	pointer
,	O
".%d"	pointer
,	O
section	struct
->	O
level	array
[	O
level	array
]	O
)	O
;	O
}	O
}	O
static	O
int	O
section_recognize	function
(	O
const	O
char	O
*	O
cmd	pointer
)	O
{	O
struct	O
section_cmd	struct
{	O
enum	O
section_level	enum
level	array
;	O
char	O
*	O
name	pointer
;	O
}	O
;	O
static	O
const	O
struct	O
section_cmd	struct
cmds	array
[	O
]	O
=	O
{	O
{	O
LEVEL_CHAPTER	int
,	O
"chapter"	pointer
}	O
,	O
{	O
LEVEL_CHAPTER	int
,	O
"unnumbered"	pointer
}	O
,	O
{	O
LEVEL_CHAPTER	int
,	O
"appendix"	pointer
}	O
,	O
{	O
LEVEL_SECTION	int
,	O
"section"	pointer
}	O
,	O
{	O
LEVEL_SECTION	int
,	O
"unnumberedsec"	pointer
}	O
,	O
{	O
LEVEL_SECTION	int
,	O
"appendixsec"	pointer
}	O
,	O
{	O
LEVEL_SUBSECTION	int
,	O
"subsection"	pointer
}	O
,	O
{	O
LEVEL_SUBSECTION	int
,	O
"unnumberedsubsec"	pointer
}	O
,	O
{	O
LEVEL_SUBSECTION	int
,	O
"appendixsubsec"	pointer
}	O
,	O
{	O
LEVEL_SUBSUBSECTION	int
,	O
"subsubsection"	pointer
}	O
,	O
{	O
LEVEL_SUBSUBSECTION	int
,	O
"unnumberedsubsubsec"	pointer
}	O
,	O
{	O
LEVEL_SUBSUBSECTION	int
,	O
"appendixsubsubsec"	pointer
}	O
,	O
{	O
LEVEL_EXERCISE	int
,	O
"exercise"	pointer
}	O
,	O
}	O
;	O
const	O
struct	O
section_cmd	struct
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
cmds	array
;	O
p	pointer
<	O
cmds	array
+	O
sizeof	O
cmds	array
/	O
sizeof	O
*	O
cmds	array
;	O
p	pointer
++	O
)	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
p	pointer
->	O
name	pointer
)	O
)	O
{	O
section_advance	function
(	O
&	O
cur_section	struct
,	O
p	pointer
->	O
level	array
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
exercise_process	function
(	O
const	O
char	O
*	O
cmd	pointer
,	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"setanswerfile"	pointer
)	O
)	O
exercise_open_answer_file	function
(	O
line	int
,	O
pass	int
)	O
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
cmd	pointer
,	O
"exercise"	pointer
,	O
8	int
)	O
)	O
exercise_begin	function
(	O
line	int
,	O
pass	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"answer"	pointer
)	O
)	O
exercise_answer	function
(	O
line	int
,	O
pass	int
)	O
;	O
else	O
return	O
exercise_end	function
(	O
cmd	pointer
,	O
line	int
,	O
pass	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
void	O
exercise_begin	function
(	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
{	O
if	O
(	O
pass	int
==	O
2	int
)	O
{	O
char	O
*	O
bp	pointer
,	O
*	O
ep	pointer
;	O
bp	pointer
=	O
ep	pointer
=	O
line	int
+	O
strlen	function
(	O
"@exercise"	pointer
)	O
;	O
while	O
(	O
!	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
ep	pointer
)	O
)	O
ep	pointer
++	O
;	O
if	O
(	O
cur_section	struct
.	O
level	array
[	O
LEVEL_EXERCISE	int
]	O
==	O
1	int
)	O
emitf	function
(	O
"@blankline @noindent @b{%s}\n\n"	pointer
,	O
_	O
(	O
"Exercises:"	pointer
)	O
)	O
;	O
emitf	function
(	O
"@blankline @noindent @b{%.*s%d.}"	pointer
,	O
(	O
int	O
)	O
(	O
ep	pointer
-	O
bp	pointer
)	O
,	O
bp	pointer
,	O
cur_section	struct
.	O
level	array
[	O
LEVEL_EXERCISE	int
]	O
)	O
;	O
if	O
(	O
find_optional_argument	function
(	O
line	int
,	O
&	O
bp	pointer
,	O
&	O
ep	pointer
)	O
)	O
{	O
char	O
sec_name	array
[	O
64	int
]	O
;	O
section_name	function
(	O
&	O
cur_section	struct
,	O
sec_name	array
)	O
;	O
if	O
(	O
header_file	pointer
!=	O
NULL	O
)	O
fprintf	function
(	O
header_file	pointer
,	O
"@set %.*s Exercise %s-%d\n"	pointer
"@set %.*sbrief Exercise %d\n"	pointer
,	O
(	O
int	O
)	O
(	O
ep	pointer
-	O
bp	pointer
)	O
,	O
bp	pointer
,	O
sec_name	array
,	O
cur_section	struct
.	O
level	array
[	O
LEVEL_EXERCISE	int
]	O
,	O
(	O
int	O
)	O
(	O
ep	pointer
-	O
bp	pointer
)	O
,	O
bp	pointer
,	O
cur_section	struct
.	O
level	array
[	O
LEVEL_EXERCISE	int
]	O
)	O
;	O
else	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"No preceding `@setheaderfile'."	pointer
)	O
)	O
;	O
emitf	function
(	O
"@anchor{%.*s}"	pointer
,	O
(	O
int	O
)	O
(	O
ep	pointer
-	O
bp	pointer
)	O
,	O
bp	pointer
)	O
;	O
}	O
emits	O
(	O
"@exerspace{}"	pointer
)	O
;	O
}	O
if	O
(	O
in_exercise	int
)	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"`@exercise' within exercise."	pointer
)	O
)	O
;	O
in_exercise	int
=	O
1	int
;	O
}	O
static	O
int	O
exercise_end	function
(	O
const	O
char	O
*	O
cmd	pointer
,	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
{	O
char	O
*	O
bp	pointer
,	O
*	O
ep	pointer
;	O
if	O
(	O
strcmp	function
(	O
cmd	pointer
,	O
"end"	pointer
)	O
)	O
return	O
0	int
;	O
find_argument	function
(	O
line	int
,	O
&	O
bp	pointer
,	O
&	O
ep	pointer
)	O
;	O
if	O
(	O
ep	pointer
-	O
bp	pointer
!=	O
8	int
||	O
memcmp	function
(	O
bp	pointer
,	O
"exercise"	pointer
,	O
8	int
)	O
)	O
return	O
0	int
;	O
if	O
(	O
!	O
in_exercise	int
)	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"`@end exercise' outside exercise."	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
if	O
(	O
pass	int
==	O
2	int
&&	O
print_unanswered	int
)	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Exercise missing answer."	pointer
)	O
)	O
;	O
in_exercise	int
=	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
exercise_answer	function
(	O
char	O
*	O
pline	pointer
,	O
int	O
pass	int
)	O
{	O
char	O
*	O
line	int
=	O
xstrdup	function
(	O
pline	pointer
)	O
;	O
size_t	long
size	long
=	O
strlen	function
(	O
pline	pointer
)	O
+	O
1	int
;	O
if	O
(	O
pass	int
==	O
1	int
&&	O
answer_file	pointer
==	O
NULL	O
)	O
error	function
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"@answer: No answer file defined."	pointer
)	O
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
static	O
const	O
char	O
answer	array
[	O
]	O
=	O
"@answer"	pointer
;	O
static	O
const	O
char	O
exercise	array
[	O
]	O
=	O
"@exercise"	pointer
;	O
static	O
const	O
char	O
end_exercise	array
[	O
]	O
=	O
"@end exercise"	pointer
;	O
if	O
(	O
pass	int
==	O
1	int
&&	O
!	O
strncmp	function
(	O
line	int
,	O
answer	array
,	O
(	O
sizeof	O
answer	array
)	O
-	O
1	int
)	O
)	O
{	O
{	O
static	O
struct	O
section	struct
last_answer	struct
;	O
if	O
(	O
section_differs	function
(	O
&	O
cur_section	struct
,	O
&	O
last_answer	struct
,	O
LEVEL_CHAPTER	int
)	O
)	O
fprintf	function
(	O
answer_file	pointer
,	O
"@unnumberedsec %s %d\n\n"	pointer
,	O
_	O
(	O
"Chapter"	pointer
)	O
,	O
cur_section	struct
.	O
level	array
[	O
0	int
]	O
)	O
;	O
if	O
(	O
section_differs	function
(	O
&	O
cur_section	struct
,	O
&	O
last_answer	struct
,	O
LEVEL_SUBSUBSECTION	int
)	O
&&	O
cur_section	struct
.	O
level	array
[	O
LEVEL_SECTION	int
]	O
!=	O
0	int
)	O
{	O
char	O
sec_name	array
[	O
64	int
]	O
;	O
section_name	function
(	O
&	O
cur_section	struct
,	O
sec_name	array
)	O
;	O
fprintf	function
(	O
answer_file	pointer
,	O
"@subheading %s %s\n\n"	pointer
,	O
_	O
(	O
"Section"	pointer
)	O
,	O
sec_name	array
)	O
;	O
}	O
last_answer	struct
=	O
cur_section	struct
;	O
}	O
{	O
char	O
*	O
bp	pointer
,	O
*	O
ep	pointer
;	O
if	O
(	O
!	O
find_optional_argument	function
(	O
line	int
,	O
&	O
bp	pointer
,	O
&	O
ep	pointer
)	O
)	O
bp	pointer
=	O
ep	pointer
=	O
""	pointer
;	O
fprintf	function
(	O
answer_file	pointer
,	O
"\n@blankline @noindent @b{%d%.*s.}\n"	pointer
,	O
cur_section	struct
.	O
level	array
[	O
LEVEL_EXERCISE	int
]	O
,	O
(	O
int	O
)	O
(	O
ep	pointer
-	O
bp	pointer
)	O
,	O
bp	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
exercise	array
,	O
(	O
sizeof	O
exercise	array
)	O
-	O
1	int
)	O
)	O
error	function
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"@exercise seen looking for @end exercise"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
!	O
strncmp	function
(	O
line	int
,	O
end_exercise	array
,	O
(	O
sizeof	O
end_exercise	array
)	O
-	O
1	int
)	O
)	O
break	O
;	O
else	O
if	O
(	O
pass	int
==	O
1	int
)	O
fputs	function
(	O
line	int
,	O
answer_file	pointer
)	O
;	O
if	O
(	O
!	O
input_read_line	function
(	O
&	O
line	int
,	O
&	O
size	long
)	O
)	O
error	function
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"End-of-file looking for @end exercise"	pointer
)	O
)	O
;	O
}	O
free	function
(	O
line	int
)	O
;	O
in_exercise	int
=	O
0	int
;	O
}	O
static	O
void	O
exercise_close_answer_file	function
(	O
void	O
)	O
{	O
if	O
(	O
answer_file	pointer
==	O
NULL	O
)	O
return	O
;	O
if	O
(	O
fclose	function
(	O
answer_file	pointer
)	O
!=	O
0	int
)	O
error	function
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Closing answer file: %s"	pointer
)	O
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
answer_file	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
exercise_open_answer_file	function
(	O
char	O
*	O
line	int
,	O
int	O
pass	int
)	O
{	O
char	O
*	O
bp	pointer
,	O
*	O
ep	pointer
;	O
if	O
(	O
!	O
find_argument	function
(	O
line	int
,	O
&	O
bp	pointer
,	O
&	O
ep	pointer
)	O
)	O
return	O
;	O
if	O
(	O
pass	int
==	O
1	int
)	O
{	O
exercise_close_answer_file	function
(	O
)	O
;	O
free	function
(	O
answer_file_name	pointer
)	O
;	O
answer_file_name	pointer
=	O
xstrndup	function
(	O
bp	pointer
,	O
ep	pointer
-	O
bp	pointer
)	O
;	O
answer_file	pointer
=	O
fopen	function
(	O
answer_file_name	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
answer_file	pointer
==	O
NULL	O
)	O
error	function
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Opening %s: %s"	pointer
)	O
,	O
bp	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
static	O
int	O
parse_at_cmd	function
(	O
const	O
char	O
*	O
line	int
,	O
char	O
cmd	pointer
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
)	O
{	O
if	O
(	O
*	O
line	int
++	O
!=	O
'@'	O
)	O
return	O
0	int
;	O
if	O
(	O
isalpha	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
line	int
)	O
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
CMD_LEN_MAX	int
;	O
i	int
++	O
)	O
{	O
*	O
cmd	pointer
++	O
=	O
*	O
line	int
++	O
;	O
if	O
(	O
!	O
isalpha	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
line	int
)	O
)	O
break	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
line	int
!=	O
'\0'	O
&&	O
!	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
line	int
)	O
)	O
*	O
cmd	pointer
++	O
=	O
*	O
line	int
++	O
;	O
*	O
cmd	pointer
=	O
'\0'	O
;	O
return	O
1	int
;	O
}	O
static	O
int	O
in_control	int
;	O
static	O
int	O
control_space	int
;	O
static	O
char	O
*	O
control_buf	pointer
;	O
static	O
size_t	long
control_len	long
;	O
static	O
size_t	long
control_size	long
;	O
static	O
void	O
add_control	function
(	O
const	O
char	O
*	O
text	pointer
,	O
size_t	long
len	long
)	O
{	O
const	O
char	O
*	O
cp	pointer
;	O
if	O
(	O
control_len	long
+	O
len	long
+	O
8	int
>	O
control_size	long
)	O
{	O
control_size	long
=	O
control_len	long
*	O
2	int
+	O
len	long
+	O
16	int
;	O
control_buf	pointer
=	O
xrealloc	function
(	O
control_buf	pointer
,	O
control_size	long
)	O
;	O
}	O
for	O
(	O
cp	pointer
=	O
text	pointer
;	O
cp	pointer
<	O
text	pointer
+	O
len	long
;	O
cp	pointer
++	O
)	O
{	O
if	O
(	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
)	O
)	O
{	O
if	O
(	O
control_len	long
==	O
0	int
)	O
continue	O
;	O
control_space	int
=	O
1	int
;	O
continue	O
;	O
}	O
if	O
(	O
control_space	int
)	O
{	O
control_buf	pointer
[	O
control_len	long
++	O
]	O
=	O
' '	O
;	O
control_space	int
=	O
0	int
;	O
}	O
control_buf	pointer
[	O
control_len	long
++	O
]	O
=	O
*	O
cp	pointer
;	O
}	O
}	O
static	O
char	O
*	O
parse_control_text	function
(	O
char	O
*	O
start	pointer
,	O
char	O
*	O
*	O
tail	pointer
)	O
{	O
char	O
*	O
end	pointer
=	O
strstr	function
(	O
start	pointer
,	O
"@>"	pointer
)	O
;	O
if	O
(	O
end	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
tail	pointer
!=	O
NULL	O
)	O
*	O
tail	pointer
=	O
end	pointer
+	O
2	int
;	O
}	O
else	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Missing control text end marker @>."	pointer
)	O
)	O
;	O
end	pointer
=	O
strchr	function
(	O
start	pointer
,	O
'\0'	O
)	O
;	O
if	O
(	O
tail	pointer
!=	O
NULL	O
)	O
*	O
tail	pointer
=	O
end	pointer
;	O
}	O
{	O
char	O
*	O
buf	pointer
;	O
control_len	long
=	O
0	int
;	O
control_space	int
=	O
0	int
;	O
add_control	function
(	O
start	pointer
,	O
end	pointer
-	O
start	pointer
)	O
;	O
add_control	function
(	O
""	pointer
,	O
1	int
)	O
;	O
buf	pointer
=	O
control_buf	pointer
;	O
control_buf	pointer
=	O
NULL	O
;	O
control_len	long
=	O
0	int
;	O
control_size	long
=	O
0	int
;	O
return	O
buf	pointer
;	O
}	O
}	O
enum	O
{	O
TOKEN_EOL	int
=	O
0	int
,	O
TOKEN_AT	int
=	O
-	O
256	int
,	O
TOKEN_BEGIN_CONTROL	int
,	O
TOKEN_END_CONTROL	int
,	O
TOKEN_SEMICOLON	int
,	O
TOKEN_PIPE	int
,	O
TOKEN_COND_NEWLINE	int
,	O
TOKEN_INC_INDENT	int
,	O
TOKEN_DEC_INDENT	int
,	O
TOKEN_ID	int
,	O
TOKEN_BEGIN_EMBED_CODE	int
,	O
TOKEN_END_EMBED_CODE	int
,	O
TOKEN_BEGIN_COMMENT	int
,	O
TOKEN_END_COMMENT	int
,	O
TOKEN_REPLACE	int
,	O
TOKEN_PREPROCESSOR	int
,	O
TOKEN_PSTRUCT_ELEM	int
,	O
TOKEN_EQ	int
,	O
TOKEN_NE	int
,	O
TOKEN_LE	int
,	O
TOKEN_GE	int
,	O
TOKEN_AND	int
,	O
TOKEN_OR	int
,	O
TOKEN_TIMES	int
,	O
TOKEN_NEG	int
,	O
TOKEN_POS	int
,	O
TOKEN_PLUSPLUS	int
,	O
TOKEN_MINUSMINUS	int
,	O
TOKEN_QUOTED_STRING	int
,	O
TOKEN_OCT_INT	int
,	O
TOKEN_HEX_INT	int
,	O
TOKEN_SCIENTIFIC	int
,	O
TOKEN_NUMBER	int
}	O
;	O
struct	O
token	pointer
{	O
int	O
type	int
;	O
const	O
char	O
*	O
text	pointer
;	O
size_t	long
len	long
;	O
}	O
;	O
static	O
const	O
char	O
*	O
token_get	function
(	O
const	O
char	O
*	O
s	pointer
,	O
struct	O
token	pointer
*	O
token	pointer
)	O
{	O
const	O
char	O
*	O
cp	pointer
=	O
s	pointer
;	O
token	pointer
->	O
text	pointer
=	O
s	pointer
;	O
if	O
(	O
*	O
cp	pointer
==	O
'@'	O
)	O
{	O
cp	pointer
++	O
;	O
token	pointer
->	O
type	int
=	O
' '	O
;	O
switch	O
(	O
*	O
cp	pointer
++	O
)	O
{	O
case	O
'\n'	O
:	O
token	pointer
->	O
type	int
=	O
TOKEN_COND_NEWLINE	int
;	O
break	O
;	O
case	O
'@'	O
:	O
token	pointer
->	O
type	int
=	O
TOKEN_AT	int
;	O
break	O
;	O
case	O
'('	O
:	O
case	O
'<'	O
:	O
if	O
(	O
*	O
cp	pointer
==	O
'='	O
)	O
{	O
token	pointer
->	O
type	int
=	O
TOKEN_LE	int
;	O
cp	pointer
++	O
;	O
}	O
else	O
token	pointer
->	O
type	int
=	O
TOKEN_BEGIN_CONTROL	int
;	O
break	O
;	O
case	O
'>'	O
:	O
if	O
(	O
*	O
cp	pointer
==	O
'='	O
)	O
{	O
token	pointer
->	O
type	int
=	O
TOKEN_GE	int
;	O
cp	pointer
++	O
;	O
}	O
else	O
token	pointer
->	O
type	int
=	O
TOKEN_END_CONTROL	int
;	O
break	O
;	O
case	O
';'	O
:	O
token	pointer
->	O
type	int
=	O
TOKEN_SEMICOLON	int
;	O
break	O
;	O
case	O
'|'	O
:	O
token	pointer
->	O
type	int
=	O
TOKEN_PIPE	int
;	O
break	O
;	O
case	O
'+'	O
:	O
token	pointer
->	O
type	int
=	O
TOKEN_INC_INDENT	int
;	O
break	O
;	O
case	O
'='	O
:	O
token	pointer
->	O
type	int
=	O
TOKEN_EQ	int
;	O
break	O
;	O
case	O
'!'	O
:	O
if	O
(	O
*	O
cp	pointer
==	O
'='	O
)	O
{	O
token	pointer
->	O
type	int
=	O
TOKEN_NE	int
;	O
cp	pointer
++	O
;	O
}	O
else	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Skipped unknown token @!"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
'-'	O
:	O
if	O
(	O
state_is	function
(	O
CODE	int
)	O
)	O
{	O
token	pointer
->	O
type	int
=	O
TOKEN_DEC_INDENT	int
;	O
break	O
;	O
}	O
default	O
:	O
cp	pointer
--	O
;	O
token	pointer
->	O
type	int
=	O
'@'	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'|'	O
&&	O
(	O
state_is	function
(	O
TEXT	int
)	O
||	O
state_is	function
(	O
COMMENT	int
)	O
||	O
state_is	function
(	O
CONTROL	int
)	O
)	O
)	O
{	O
cp	pointer
++	O
;	O
token	pointer
->	O
type	int
=	O
TOKEN_BEGIN_EMBED_CODE	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'='	O
&&	O
cp	pointer
[	O
1	int
]	O
==	O
'>'	O
&&	O
state_is	function
(	O
CONTROL	int
)	O
)	O
{	O
cp	pointer
+=	O
2	int
;	O
token	pointer
->	O
type	int
=	O
TOKEN_REPLACE	int
;	O
}	O
else	O
if	O
(	O
isalpha	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
)	O
||	O
*	O
cp	pointer
==	O
'_'	O
)	O
{	O
token	pointer
->	O
type	int
=	O
TOKEN_ID	int
;	O
while	O
(	O
isalnum	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
)	O
||	O
*	O
cp	pointer
==	O
'_'	O
)	O
cp	pointer
++	O
;	O
}	O
else	O
if	O
(	O
state_is	function
(	O
CODE	int
)	O
)	O
{	O
if	O
(	O
*	O
cp	pointer
==	O
'\''	O
||	O
*	O
cp	pointer
==	O
'"'	O
)	O
{	O
int	O
quote	int
=	O
*	O
cp	pointer
++	O
;	O
while	O
(	O
*	O
cp	pointer
!=	O
quote	int
&&	O
*	O
cp	pointer
!=	O
'\0'	O
)	O
{	O
if	O
(	O
*	O
cp	pointer
==	O
'\\'	O
)	O
cp	pointer
++	O
;	O
cp	pointer
++	O
;	O
}	O
if	O
(	O
*	O
cp	pointer
==	O
quote	int
)	O
cp	pointer
++	O
;	O
token	pointer
->	O
type	int
=	O
TOKEN_QUOTED_STRING	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'0'	O
&&	O
(	O
cp	pointer
[	O
1	int
]	O
==	O
'x'	O
||	O
cp	pointer
[	O
1	int
]	O
==	O
'X'	O
)	O
)	O
{	O
cp	pointer
+=	O
2	int
;	O
while	O
(	O
isxdigit	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
)	O
)	O
cp	pointer
++	O
;	O
token	pointer
->	O
type	int
=	O
TOKEN_HEX_INT	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'0'	O
&&	O
cp	pointer
[	O
1	int
]	O
>=	O
'0'	O
&&	O
cp	pointer
[	O
1	int
]	O
<=	O
'7'	O
)	O
{	O
cp	pointer
++	O
;	O
while	O
(	O
*	O
cp	pointer
>=	O
'0'	O
&&	O
*	O
cp	pointer
<=	O
'7'	O
)	O
cp	pointer
++	O
;	O
token	pointer
->	O
type	int
=	O
TOKEN_OCT_INT	int
;	O
}	O
else	O
if	O
(	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
)	O
||	O
(	O
*	O
cp	pointer
==	O
'.'	O
&&	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
)	O
)	O
)	O
{	O
cp	pointer
++	O
;	O
while	O
(	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
)	O
||	O
*	O
cp	pointer
==	O
'.'	O
)	O
cp	pointer
++	O
;	O
if	O
(	O
*	O
cp	pointer
==	O
'e'	O
||	O
*	O
cp	pointer
==	O
'E'	O
)	O
{	O
cp	pointer
++	O
;	O
while	O
(	O
isdigit	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
)	O
||	O
*	O
cp	pointer
==	O
'+'	O
||	O
*	O
cp	pointer
==	O
'-'	O
)	O
cp	pointer
++	O
;	O
token	pointer
->	O
type	int
=	O
TOKEN_SCIENTIFIC	int
;	O
}	O
else	O
token	pointer
->	O
type	int
=	O
TOKEN_NUMBER	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'|'	O
&&	O
cp	pointer
[	O
1	int
]	O
!=	O
'|'	O
&&	O
(	O
state_was	function
(	O
TEXT	int
)	O
||	O
state_was	function
(	O
COMMENT	int
)	O
||	O
state_was	function
(	O
CONTROL	int
)	O
)	O
)	O
{	O
cp	pointer
++	O
;	O
token	pointer
->	O
type	int
=	O
TOKEN_END_EMBED_CODE	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'/'	O
&&	O
cp	pointer
[	O
1	int
]	O
==	O
'*'	O
)	O
{	O
cp	pointer
+=	O
2	int
;	O
token	pointer
->	O
type	int
=	O
TOKEN_BEGIN_COMMENT	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'#'	O
)	O
{	O
token	pointer
->	O
type	int
=	O
TOKEN_PREPROCESSOR	int
;	O
cp	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'-'	O
&&	O
cp	pointer
[	O
1	int
]	O
==	O
'>'	O
)	O
{	O
token	pointer
->	O
type	int
=	O
TOKEN_PSTRUCT_ELEM	int
;	O
cp	pointer
+=	O
2	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'-'	O
&&	O
cp	pointer
[	O
1	int
]	O
==	O
'-'	O
)	O
{	O
token	pointer
->	O
type	int
=	O
TOKEN_MINUSMINUS	int
;	O
cp	pointer
+=	O
2	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'+'	O
&&	O
cp	pointer
[	O
1	int
]	O
==	O
'+'	O
)	O
{	O
token	pointer
->	O
type	int
=	O
TOKEN_PLUSPLUS	int
;	O
cp	pointer
+=	O
2	int
;	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'-'	O
&&	O
(	O
cp	pointer
[	O
1	int
]	O
!=	O
'='	O
&&	O
cp	pointer
[	O
1	int
]	O
!=	O
'|'	O
&&	O
!	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
cp	pointer
[	O
1	int
]	O
)	O
)	O
)	O
{	O
token	pointer
->	O
type	int
=	O
TOKEN_NEG	int
;	O
cp	pointer
++	O
;	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'+'	O
&&	O
(	O
cp	pointer
[	O
1	int
]	O
!=	O
'='	O
&&	O
cp	pointer
[	O
1	int
]	O
!=	O
'|'	O
&&	O
!	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
cp	pointer
[	O
1	int
]	O
)	O
)	O
)	O
{	O
token	pointer
->	O
type	int
=	O
TOKEN_POS	int
;	O
cp	pointer
++	O
;	O
}	O
else	O
{	O
token	pointer
->	O
type	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
;	O
cp	pointer
++	O
;	O
}	O
}	O
else	O
if	O
(	O
*	O
cp	pointer
==	O
'*'	O
&&	O
cp	pointer
[	O
1	int
]	O
==	O
'/'	O
&&	O
state_is	function
(	O
COMMENT	int
)	O
)	O
{	O
cp	pointer
+=	O
2	int
;	O
token	pointer
->	O
type	int
=	O
TOKEN_END_COMMENT	int
;	O
}	O
else	O
{	O
token	pointer
->	O
type	int
=	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
;	O
if	O
(	O
*	O
cp	pointer
)	O
cp	pointer
++	O
;	O
}	O
token	pointer
->	O
len	long
=	O
cp	pointer
-	O
token	pointer
->	O
text	pointer
;	O
return	O
cp	pointer
;	O
}	O
static	O
const	O
char	O
*	O
token_parse	function
(	O
const	O
char	O
*	O
cp	pointer
,	O
struct	O
token	pointer
*	O
token	pointer
)	O
{	O
cp	pointer
=	O
token_get	function
(	O
cp	pointer
,	O
token	pointer
)	O
;	O
if	O
(	O
in_control	int
&&	O
token	pointer
->	O
type	int
!=	O
TOKEN_END_CONTROL	int
)	O
add_control	function
(	O
token	pointer
->	O
text	pointer
,	O
token	pointer
->	O
len	long
)	O
;	O
switch	O
(	O
token	pointer
->	O
type	int
)	O
{	O
case	O
TOKEN_BEGIN_CONTROL	int
:	O
if	O
(	O
!	O
in_control	int
)	O
{	O
state_push	function
(	O
CONTROL	int
)	O
;	O
in_control	int
=	O
token	pointer
->	O
text	pointer
[	O
token	pointer
->	O
len	long
-	O
1	int
]	O
;	O
control_len	long
=	O
0	int
;	O
control_space	int
=	O
0	int
;	O
}	O
else	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Can't nest control texts."	pointer
)	O
)	O
;	O
break	O
;	O
case	O
TOKEN_END_CONTROL	int
:	O
if	O
(	O
control_len	long
>	O
0	int
)	O
control_buf	pointer
[	O
control_len	long
]	O
=	O
'\0'	O
;	O
else	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Empty control text."	pointer
)	O
)	O
;	O
token	pointer
->	O
type	int
=	O
' '	O
;	O
}	O
if	O
(	O
in_control	int
)	O
{	O
in_control	int
=	O
0	int
;	O
while	O
(	O
!	O
state_is	function
(	O
CONTROL	int
)	O
)	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Missing closing within control text."	pointer
)	O
)	O
;	O
state_pop	function
(	O
)	O
;	O
}	O
state_pop	function
(	O
)	O
;	O
}	O
else	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"@> not inside control text."	pointer
)	O
)	O
;	O
break	O
;	O
case	O
TOKEN_BEGIN_EMBED_CODE	int
:	O
state_push	function
(	O
CODE	int
)	O
;	O
break	O
;	O
case	O
TOKEN_END_EMBED_CODE	int
:	O
state_pop	function
(	O
)	O
;	O
break	O
;	O
case	O
TOKEN_BEGIN_COMMENT	int
:	O
state_push	function
(	O
COMMENT	int
)	O
;	O
break	O
;	O
case	O
TOKEN_END_COMMENT	int
:	O
state_pop	function
(	O
)	O
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
return	O
cp	pointer
;	O
}	O
static	O
int	O
token_space_p	function
(	O
struct	O
token	pointer
*	O
token	pointer
)	O
{	O
return	O
(	O
token	pointer
->	O
type	int
>=	O
CHAR_MIN	O
&&	O
token	pointer
->	O
type	int
<=	O
CHAR_MAX	O
&&	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
token	pointer
->	O
type	int
)	O
)	O
;	O
}	O
static	O
void	O
weave_pass_one	function
(	O
void	O
)	O
{	O
size_t	long
line_size	pointer
=	O
0	int
;	O
char	O
*	O
line	int
=	O
NULL	O
;	O
section_init	function
(	O
&	O
cur_section	struct
)	O
;	O
state_init	function
(	O
)	O
;	O
state_push	function
(	O
TEXT	int
)	O
;	O
input_start_pass	function
(	O
)	O
;	O
while	O
(	O
input_read_line	function
(	O
&	O
line	int
,	O
&	O
line_size	pointer
)	O
)	O
{	O
char	O
cmd	pointer
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
;	O
if	O
(	O
parse_at_cmd	function
(	O
line	int
,	O
cmd	pointer
)	O
)	O
{	O
section_recognize	function
(	O
cmd	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"references"	pointer
)	O
)	O
enforce_references_ordering	function
(	O
)	O
;	O
if	O
(	O
cmd	pointer
[	O
0	int
]	O
==	O
'\0'	O
||	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"node"	pointer
)	O
)	O
{	O
segment_select	function
(	O
NULL	O
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"bye"	pointer
)	O
)	O
break	O
;	O
else	O
if	O
(	O
!	O
exercise_process	function
(	O
cmd	pointer
,	O
line	int
,	O
1	int
)	O
&&	O
!	O
catalogue_process_one	function
(	O
cmd	pointer
,	O
line	int
)	O
)	O
{	O
int	O
operation	enum
;	O
char	O
*	O
control_text	pointer
=	O
segment_definition_line	function
(	O
line	int
,	O
&	O
operation	enum
)	O
;	O
if	O
(	O
control_text	pointer
!=	O
NULL	O
)	O
{	O
segment_select	function
(	O
segment_find	function
(	O
control_text	pointer
,	O
1	int
)	O
)	O
;	O
piece_create	function
(	O
segment_cur	pointer
,	O
operation	enum
)	O
;	O
free	function
(	O
control_text	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
}	O
if	O
(	O
segment_cur	pointer
!=	O
NULL	O
)	O
{	O
const	O
char	O
*	O
cp	pointer
=	O
line	int
;	O
int	O
indentation	int
=	O
indent_amount	function
(	O
line	int
,	O
&	O
cp	pointer
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
token	pointer
token	pointer
;	O
cp	pointer
=	O
token_parse	function
(	O
cp	pointer
,	O
&	O
token	pointer
)	O
;	O
if	O
(	O
token	pointer
.	O
type	int
==	O
0	int
)	O
break	O
;	O
else	O
if	O
(	O
token	pointer
.	O
type	int
==	O
TOKEN_END_CONTROL	int
)	O
piece_references	function
(	O
segment_find	function
(	O
control_buf	pointer
,	O
1	int
)	O
,	O
indentation	int
)	O
;	O
}	O
}	O
}	O
input_end_pass	function
(	O
)	O
;	O
state_pop	function
(	O
)	O
;	O
free	function
(	O
line	int
)	O
;	O
}	O
static	O
char	O
*	O
segment_definition_line	function
(	O
char	O
*	O
line	int
,	O
int	O
*	O
operation	enum
)	O
{	O
char	O
*	O
control_text	pointer
;	O
char	O
*	O
cp	pointer
,	O
*	O
ep	pointer
;	O
control_text	pointer
=	O
NULL	O
;	O
if	O
(	O
*	O
line	int
==	O
'@'	O
&&	O
(	O
line	int
[	O
1	int
]	O
==	O
'<'	O
||	O
line	int
[	O
1	int
]	O
==	O
'('	O
)	O
)	O
{	O
if	O
(	O
in_control	int
)	O
{	O
error	function
(	O
SRC	int
|	O
FTL	int
,	O
_	O
(	O
"Nested control texts."	pointer
)	O
)	O
;	O
in_control	int
=	O
0	int
;	O
}	O
control_text	pointer
=	O
parse_control_text	function
(	O
line	int
+	O
2	int
,	O
&	O
cp	pointer
)	O
;	O
ep	pointer
=	O
strchr	function
(	O
cp	pointer
,	O
'\0'	O
)	O
;	O
trim_whitespace	function
(	O
&	O
cp	pointer
,	O
&	O
ep	pointer
)	O
;	O
if	O
(	O
ep	pointer
-	O
cp	pointer
==	O
1	int
&&	O
cp	pointer
[	O
0	int
]	O
==	O
'='	O
)	O
{	O
if	O
(	O
operation	enum
!=	O
NULL	O
)	O
*	O
operation	enum
=	O
'='	O
;	O
}	O
else	O
if	O
(	O
ep	pointer
-	O
cp	pointer
==	O
2	int
&&	O
cp	pointer
[	O
0	int
]	O
==	O
'+'	O
&&	O
cp	pointer
[	O
1	int
]	O
==	O
'='	O
)	O
{	O
if	O
(	O
operation	enum
!=	O
NULL	O
)	O
*	O
operation	enum
=	O
'+'	O
;	O
}	O
else	O
{	O
free	function
(	O
control_text	pointer
)	O
;	O
control_text	pointer
=	O
NULL	O
;	O
}	O
}	O
return	O
control_text	pointer
;	O
}	O
static	O
void	O
enforce_references_ordering	function
(	O
void	O
)	O
{	O
static	O
struct	O
section	struct
last_error	struct
;	O
if	O
(	O
cur_section	struct
.	O
level	array
[	O
LEVEL_EXERCISE	int
]	O
>	O
0	int
&&	O
section_differs	function
(	O
&	O
cur_section	struct
,	O
&	O
last_error	struct
,	O
LEVEL_SUBSUBSECTION	int
)	O
)	O
{	O
last_error	struct
=	O
cur_section	struct
;	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"References should precede exercises."	pointer
)	O
)	O
;	O
}	O
}	O
static	O
int	O
blank	int
;	O
static	O
int	O
parens	int
;	O
static	O
int	O
paste	int
;	O
static	O
void	O
weave_pass_two	function
(	O
void	O
)	O
{	O
size_t	long
line_size	pointer
=	O
0	int
;	O
char	O
*	O
line	int
=	O
NULL	O
;	O
int	O
print_flags	int
=	O
0	int
;	O
state_init	function
(	O
)	O
;	O
state_push	function
(	O
TEXT	int
)	O
;	O
section_init	function
(	O
&	O
cur_section	struct
)	O
;	O
input_start_pass	function
(	O
)	O
;	O
while	O
(	O
input_read_line	function
(	O
&	O
line	int
,	O
&	O
line_size	pointer
)	O
)	O
{	O
char	O
cmd	pointer
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
;	O
if	O
(	O
!	O
parse_at_cmd	function
(	O
line	int
,	O
cmd	pointer
)	O
)	O
{	O
print_flags	int
=	O
print_line	function
(	O
line	int
,	O
print_flags	int
)	O
;	O
continue	O
;	O
}	O
section_recognize	function
(	O
cmd	pointer
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"node"	pointer
)	O
)	O
{	O
transition	function
(	O
TEXT	int
)	O
;	O
print_flags	int
=	O
print_line	function
(	O
line	int
,	O
print_flags	int
)	O
;	O
}	O
else	O
if	O
(	O
cmd	pointer
[	O
0	int
]	O
==	O
'\0'	O
)	O
{	O
transition	function
(	O
TEXT	int
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"p"	pointer
)	O
)	O
{	O
transition	function
(	O
CODE	int
)	O
;	O
continue	O
;	O
}	O
else	O
if	O
(	O
cmd	pointer
[	O
0	int
]	O
==	O
'<'	O
||	O
cmd	pointer
[	O
0	int
]	O
==	O
'('	O
)	O
{	O
char	O
*	O
control_text	pointer
;	O
int	O
operation	enum
;	O
control_text	pointer
=	O
segment_definition_line	function
(	O
line	int
,	O
&	O
operation	enum
)	O
;	O
if	O
(	O
control_text	pointer
!=	O
NULL	O
)	O
{	O
print_piece_header	function
(	O
control_text	pointer
,	O
cmd	pointer
[	O
0	int
]	O
,	O
operation	enum
)	O
;	O
free	function
(	O
control_text	pointer
)	O
;	O
}	O
else	O
print_flags	int
=	O
print_line	function
(	O
line	int
,	O
print_flags	int
)	O
;	O
}	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"setheaderfile"	pointer
)	O
)	O
open_header_file	function
(	O
line	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"deftypedef"	pointer
)	O
)	O
{	O
char	O
*	O
bp	pointer
,	O
*	O
ep	pointer
;	O
if	O
(	O
!	O
find_argument	function
(	O
line	int
,	O
&	O
bp	pointer
,	O
&	O
ep	pointer
)	O
)	O
continue	O
;	O
*	O
ep	pointer
=	O
'\0'	O
;	O
symbol_find	function
(	O
bp	pointer
,	O
strlen	function
(	O
bp	pointer
)	O
,	O
1	int
)	O
->	O
is_typedef	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
!	O
exercise_process	function
(	O
cmd	pointer
,	O
line	int
,	O
2	int
)	O
&&	O
!	O
catalogue_process_two	function
(	O
cmd	pointer
,	O
line	int
)	O
)	O
{	O
print_flags	int
=	O
print_line	function
(	O
line	int
,	O
print_flags	int
)	O
;	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"bye"	pointer
)	O
)	O
break	O
;	O
}	O
}	O
input_end_pass	function
(	O
)	O
;	O
state_pop	function
(	O
)	O
;	O
exercise_close_answer_file	function
(	O
)	O
;	O
close_header_file	function
(	O
)	O
;	O
if	O
(	O
print_catalogues	int
)	O
catalogue_print_unused	function
(	O
)	O
;	O
free	function
(	O
line	int
)	O
;	O
}	O
static	O
void	O
transition	function
(	O
enum	O
state	enum
new_state	enum
)	O
{	O
assert	O
(	O
state_cnt	function
(	O
)	O
>	O
0	int
)	O
;	O
if	O
(	O
state_cnt	function
(	O
)	O
>	O
1	int
)	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Nested state transition."	pointer
)	O
)	O
;	O
while	O
(	O
state_cnt	function
(	O
)	O
>	O
1	int
)	O
state_pop	function
(	O
)	O
;	O
}	O
if	O
(	O
warn_nonzero_indent	int
&&	O
indent_adjust	int
!=	O
0	int
)	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Nonzero indent adjustment at state transition."	pointer
)	O
)	O
;	O
if	O
(	O
state_is	function
(	O
new_state	enum
)	O
)	O
return	O
;	O
if	O
(	O
state_is	function
(	O
TEXT	int
)	O
&&	O
new_state	enum
==	O
CODE	int
)	O
{	O
emits	O
(	O
"@begincode{}"	pointer
)	O
;	O
parens	int
=	O
0	int
;	O
blank	int
=	O
0	int
;	O
declaration_engine	function
(	O
NULL	O
,	O
0	int
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
state_is	function
(	O
CODE	int
)	O
&&	O
new_state	enum
==	O
TEXT	int
)	O
;	O
emits	O
(	O
"@endcode{}"	pointer
)	O
;	O
piece_print_trailer	function
(	O
)	O
;	O
emits	O
(	O
"\n\n"	pointer
)	O
;	O
segment_select	function
(	O
NULL	O
)	O
;	O
}	O
state_pop	function
(	O
)	O
;	O
state_push	function
(	O
new_state	enum
)	O
;	O
}	O
static	O
int	O
indent_amount	function
(	O
const	O
char	O
*	O
cp	pointer
,	O
const	O
char	O
*	O
*	O
const	O
end	pointer
)	O
{	O
int	O
cnt	int
=	O
0	int
;	O
while	O
(	O
*	O
cp	pointer
==	O
' '	O
||	O
*	O
cp	pointer
==	O
'\t'	O
)	O
{	O
if	O
(	O
*	O
cp	pointer
==	O
'\t'	O
)	O
cnt	int
=	O
(	O
cnt	int
+	O
8	int
)	O
/	O
8	int
*	O
8	int
;	O
else	O
cnt	int
++	O
;	O
cp	pointer
++	O
;	O
}	O
if	O
(	O
end	pointer
!=	O
NULL	O
)	O
*	O
end	pointer
=	O
(	O
char	O
*	O
)	O
cp	pointer
;	O
return	O
cnt	int
;	O
}	O
static	O
int	O
print_line	function
(	O
const	O
char	O
*	O
cp	pointer
,	O
int	O
flags	int
)	O
{	O
if	O
(	O
state_bottom	function
(	O
CODE	int
)	O
)	O
{	O
int	O
i	int
;	O
int	O
indent	pointer
=	O
indent_amount	function
(	O
cp	pointer
,	O
&	O
cp	pointer
)	O
;	O
if	O
(	O
state_is	function
(	O
CODE	int
)	O
&&	O
state_cnt	function
(	O
)	O
==	O
1	int
)	O
declaration_engine	function
(	O
cp	pointer
,	O
indent	pointer
)	O
;	O
if	O
(	O
empty_string	function
(	O
cp	pointer
)	O
)	O
{	O
blank	int
=	O
1	int
;	O
return	O
0	int
;	O
}	O
if	O
(	O
blank	int
)	O
{	O
emits	O
(	O
"@blankline\n"	pointer
)	O
;	O
blank	int
=	O
0	int
;	O
}	O
if	O
(	O
!	O
paste	int
)	O
{	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
indent	pointer
;	O
i	int
++	O
)	O
emitc	O
(	O
' '	O
)	O
;	O
emits	O
(	O
"@tabalign{}"	pointer
)	O
;	O
if	O
(	O
parens	int
)	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
parens	int
;	O
i	int
++	O
)	O
emits	O
(	O
"@wtab{}"	pointer
)	O
;	O
else	O
if	O
(	O
indent	pointer
!=	O
0	int
)	O
{	O
if	O
(	O
indent	pointer
+	O
indent_adjust	int
<	O
0	int
)	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Negative indentation %d."	pointer
)	O
,	O
indent	pointer
+	O
indent_adjust	int
)	O
;	O
else	O
emitf	function
(	O
"@IND{%dem}"	pointer
,	O
indent	pointer
+	O
indent_adjust	int
)	O
;	O
}	O
}	O
else	O
{	O
emits	O
(	O
"@tcr{"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
indent	pointer
;	O
i	int
++	O
)	O
emits	O
(	O
"@w{ }"	pointer
)	O
;	O
emitc	O
(	O
'}'	O
)	O
;	O
paste	int
=	O
0	int
;	O
}	O
}	O
return	O
print	function
(	O
cp	pointer
,	O
flags	int
)	O
;	O
}	O
static	O
int	O
print	function
(	O
const	O
char	O
*	O
cp	pointer
,	O
int	O
flags	int
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
token	pointer
token	pointer
;	O
cp	pointer
=	O
token_parse	function
(	O
cp	pointer
,	O
&	O
token	pointer
)	O
;	O
switch	O
(	O
token	pointer
.	O
type	int
)	O
{	O
case	O
TOKEN_BEGIN_CONTROL	int
:	O
emits	O
(	O
"@refcode{"	pointer
)	O
;	O
if	O
(	O
in_control	int
==	O
'<'	O
)	O
emits	O
(	O
"@asis{"	pointer
)	O
;	O
else	O
emits	O
(	O
"@t{"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_END_CONTROL	int
:	O
emits	O
(	O
"},"	pointer
)	O
;	O
print_anchor_name	function
(	O
control_buf	pointer
,	O
0	int
)	O
;	O
emitc	O
(	O
','	O
)	O
;	O
segment_print_number	function
(	O
segment_find	function
(	O
control_buf	pointer
,	O
0	int
)	O
)	O
;	O
emitc	O
(	O
'}'	O
)	O
;	O
break	O
;	O
case	O
TOKEN_BEGIN_EMBED_CODE	int
:	O
case	O
TOKEN_END_EMBED_CODE	int
:	O
flags	int
=	O
0	int
;	O
break	O
;	O
case	O
TOKEN_REPLACE	int
:	O
emits	O
(	O
"@result{}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_INC_INDENT	int
:	O
indent_adjust	int
+=	O
2	int
;	O
break	O
;	O
case	O
TOKEN_DEC_INDENT	int
:	O
indent_adjust	int
-=	O
2	int
;	O
break	O
;	O
case	O
TOKEN_AT	int
:	O
emits	O
(	O
"@@"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_SEMICOLON	int
:	O
emitc	O
(	O
';'	O
)	O
;	O
break	O
;	O
case	O
TOKEN_PIPE	int
:	O
emits	O
(	O
"@math{|}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_COND_NEWLINE	int
:	O
paste	int
=	O
1	int
;	O
break	O
;	O
case	O
TOKEN_BEGIN_COMMENT	int
:	O
emits	O
(	O
"/@value{AST}"	pointer
)	O
;	O
if	O
(	O
state_bottom	function
(	O
CODE	int
)	O
)	O
{	O
for	O
(	O
;	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
cp	pointer
)	O
;	O
cp	pointer
++	O
)	O
emitc	O
(	O
*	O
cp	pointer
)	O
;	O
emits	O
(	O
"@cleartabs{}@wtab{}"	pointer
)	O
;	O
parens	int
++	O
;	O
}	O
break	O
;	O
case	O
TOKEN_END_COMMENT	int
:	O
if	O
(	O
state_bottom	function
(	O
CODE	int
)	O
)	O
parens	int
--	O
;	O
emits	O
(	O
"@value{AST}/"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_PREPROCESSOR	int
:	O
{	O
const	O
char	O
*	O
next	pointer
;	O
emitc	O
(	O
'#'	O
)	O
;	O
next	pointer
=	O
token_get	function
(	O
cp	pointer
,	O
&	O
token	pointer
)	O
;	O
while	O
(	O
token_space_p	function
(	O
&	O
token	pointer
)	O
)	O
next	pointer
=	O
token_get	function
(	O
next	pointer
,	O
&	O
token	pointer
)	O
;	O
if	O
(	O
token	pointer
.	O
type	int
!=	O
TOKEN_ID	int
)	O
continue	O
;	O
cp	pointer
=	O
next	pointer
;	O
emitf	function
(	O
"@b{%.*s}"	pointer
,	O
(	O
int	O
)	O
token	pointer
.	O
len	long
,	O
token	pointer
.	O
text	pointer
)	O
;	O
if	O
(	O
token	pointer
.	O
len	long
==	O
6	int
&&	O
!	O
memcmp	function
(	O
token	pointer
.	O
text	pointer
,	O
"define"	pointer
,	O
6	int
)	O
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
next	pointer
=	O
token_get	function
(	O
cp	pointer
,	O
&	O
token	pointer
)	O
;	O
if	O
(	O
!	O
token_space_p	function
(	O
&	O
token	pointer
)	O
)	O
break	O
;	O
emitc	O
(	O
token	pointer
.	O
type	int
)	O
;	O
cp	pointer
=	O
next	pointer
;	O
}	O
if	O
(	O
token	pointer
.	O
type	int
==	O
TOKEN_ID	int
)	O
{	O
emits	O
(	O
"@cindex "	pointer
)	O
;	O
print_identifier	function
(	O
token	pointer
.	O
text	pointer
,	O
token	pointer
.	O
len	long
)	O
;	O
emits	O
(	O
" macro@c\n"	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
token	pointer
.	O
len	long
==	O
7	int
&&	O
!	O
memcmp	function
(	O
token	pointer
.	O
text	pointer
,	O
"include"	pointer
,	O
7	int
)	O
)	O
{	O
int	O
quote	int
=	O
0	int
;	O
for	O
(	O
;	O
*	O
cp	pointer
&&	O
*	O
cp	pointer
!=	O
'\n'	O
&&	O
*	O
cp	pointer
!=	O
'|'	O
;	O
cp	pointer
++	O
)	O
switch	O
(	O
*	O
cp	pointer
)	O
{	O
case	O
'<'	O
:	O
emits	O
(	O
"@value{LANG}"	pointer
)	O
;	O
break	O
;	O
case	O
'>'	O
:	O
emits	O
(	O
"@value{RANG}"	pointer
)	O
;	O
break	O
;	O
case	O
'"'	O
:	O
if	O
(	O
quote	int
++	O
)	O
emits	O
(	O
"@value{RQUOTE}"	pointer
)	O
;	O
else	O
emits	O
(	O
"@value{LQUOTE}"	pointer
)	O
;	O
break	O
;	O
case	O
'{'	O
:	O
case	O
'}'	O
:	O
emitf	function
(	O
"@math{@%c}"	pointer
,	O
*	O
cp	pointer
)	O
;	O
break	O
;	O
default	O
:	O
emitc	O
(	O
*	O
cp	pointer
)	O
;	O
}	O
}	O
}	O
break	O
;	O
case	O
TOKEN_PSTRUCT_ELEM	int
:	O
emits	O
(	O
"@value{RARR}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_EQ	int
:	O
emits	O
(	O
"@value{EQ}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_NE	int
:	O
emits	O
(	O
"@value{NE}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_GE	int
:	O
emits	O
(	O
"@value{GE}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_LE	int
:	O
emits	O
(	O
"@value{LE}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_AND	int
:	O
emits	O
(	O
"@value{AND}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_OR	int
:	O
emits	O
(	O
"@value{OR}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_TIMES	int
:	O
emits	O
(	O
"@value{TIMES}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_PLUSPLUS	int
:	O
emits	O
(	O
"@math{++}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_MINUSMINUS	int
:	O
emits	O
(	O
"@math{--}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_NEG	int
:	O
emits	O
(	O
"@unaryminus{}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_POS	int
:	O
emits	O
(	O
"@unaryplus{}"	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_QUOTED_STRING	int
:	O
{	O
const	O
char	O
*	O
cp	pointer
;	O
emits	O
(	O
"@t{"	pointer
)	O
;	O
for	O
(	O
cp	pointer
=	O
token	pointer
.	O
text	pointer
;	O
cp	pointer
<	O
token	pointer
.	O
text	pointer
+	O
token	pointer
.	O
len	long
;	O
cp	pointer
++	O
)	O
{	O
if	O
(	O
*	O
cp	pointer
!=	O
' '	O
)	O
{	O
if	O
(	O
*	O
cp	pointer
==	O
'@'	O
||	O
*	O
cp	pointer
==	O
'{'	O
||	O
*	O
cp	pointer
==	O
'}'	O
)	O
emitc	O
(	O
'@'	O
)	O
;	O
emitc	O
(	O
*	O
cp	pointer
)	O
;	O
}	O
else	O
emits	O
(	O
"@value{SP}"	pointer
)	O
;	O
}	O
emitc	O
(	O
'}'	O
)	O
;	O
}	O
break	O
;	O
case	O
TOKEN_HEX_INT	int
:	O
emitf	function
(	O
"@t{%.*s}"	pointer
,	O
(	O
int	O
)	O
token	pointer
.	O
len	long
,	O
token	pointer
.	O
text	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_OCT_INT	int
:	O
emitf	function
(	O
"@i{%.*s}"	pointer
,	O
(	O
int	O
)	O
token	pointer
.	O
len	long
,	O
token	pointer
.	O
text	pointer
)	O
;	O
break	O
;	O
case	O
TOKEN_NUMBER	int
:	O
emitb	O
(	O
token	pointer
.	O
text	pointer
,	O
token	pointer
.	O
len	long
)	O
;	O
break	O
;	O
case	O
TOKEN_SCIENTIFIC	int
:	O
{	O
const	O
char	O
*	O
p	pointer
=	O
memchr	function
(	O
token	pointer
.	O
text	pointer
,	O
'e'	O
,	O
token	pointer
.	O
len	long
)	O
;	O
assert	O
(	O
p	pointer
!=	O
NULL	O
)	O
;	O
emitf	function
(	O
"%.*s@exponent{%.*s}"	pointer
,	O
(	O
int	O
)	O
(	O
p	pointer
-	O
token	pointer
.	O
text	pointer
)	O
,	O
token	pointer
.	O
text	pointer
,	O
(	O
int	O
)	O
(	O
(	O
token	pointer
.	O
text	pointer
+	O
token	pointer
.	O
len	long
)	O
-	O
(	O
p	pointer
+	O
1	int
)	O
)	O
,	O
p	pointer
+	O
1	int
)	O
;	O
}	O
break	O
;	O
case	O
TOKEN_ID	int
:	O
if	O
(	O
state_is	function
(	O
CODE	int
)	O
)	O
{	O
if	O
(	O
flags	int
)	O
{	O
emitf	function
(	O
STRUCT_TAG_STYLE	pointer
"{%.*s}"	pointer
,	O
(	O
int	O
)	O
token	pointer
.	O
len	long
,	O
token	pointer
.	O
text	pointer
)	O
;	O
flags	int
=	O
0	int
;	O
}	O
else	O
{	O
struct	O
symbol	struct
*	O
sym	pointer
=	O
print_identifier	function
(	O
token	pointer
.	O
text	pointer
,	O
token	pointer
.	O
len	long
)	O
;	O
if	O
(	O
sym	pointer
&&	O
(	O
sym	pointer
->	O
kw_idx	int
==	O
KW_ENUM	int
||	O
sym	pointer
->	O
kw_idx	int
==	O
KW_STRUCT	int
||	O
sym	pointer
->	O
kw_idx	int
==	O
KW_UNION	int
)	O
)	O
flags	int
=	O
1	int
;	O
}	O
}	O
else	O
emitb	O
(	O
token	pointer
.	O
text	pointer
,	O
token	pointer
.	O
len	long
)	O
;	O
break	O
;	O
case	O
0	int
:	O
return	O
flags	int
;	O
default	O
:	O
assert	O
(	O
token	pointer
.	O
type	int
>	O
0	int
&&	O
token	pointer
.	O
type	int
<=	O
UCHAR_MAX	O
)	O
;	O
if	O
(	O
state_is	function
(	O
CODE	int
)	O
)	O
{	O
switch	O
(	O
token	pointer
.	O
type	int
)	O
{	O
case	O
'{'	O
:	O
emits	O
(	O
"@math{@{}"	pointer
)	O
;	O
flags	int
=	O
0	int
;	O
break	O
;	O
case	O
'}'	O
:	O
emits	O
(	O
"@math{@}}"	pointer
)	O
;	O
break	O
;	O
case	O
'('	O
:	O
case	O
'['	O
:	O
emitc	O
(	O
token	pointer
.	O
type	int
)	O
;	O
if	O
(	O
state_cnt	function
(	O
)	O
==	O
1	int
)	O
emits	O
(	O
"@cleartabs{}@wtab{}"	pointer
)	O
;	O
parens	int
++	O
;	O
break	O
;	O
case	O
')'	O
:	O
case	O
']'	O
:	O
emitc	O
(	O
token	pointer
.	O
type	int
)	O
;	O
parens	int
--	O
;	O
break	O
;	O
case	O
'*'	O
:	O
emits	O
(	O
"@value{AST}"	pointer
)	O
;	O
break	O
;	O
case	O
'<'	O
:	O
case	O
'>'	O
:	O
case	O
'+'	O
:	O
case	O
'-'	O
:	O
emitf	function
(	O
"@math{%c}"	pointer
,	O
token	pointer
.	O
type	int
)	O
;	O
break	O
;	O
case	O
'|'	O
:	O
emits	O
(	O
"@math{|}"	pointer
)	O
;	O
break	O
;	O
case	O
'\n'	O
:	O
if	O
(	O
state_cnt	function
(	O
)	O
==	O
1	int
||	O
state_was	function
(	O
COMMENT	int
)	O
)	O
emits	O
(	O
"@cr\n"	pointer
)	O
;	O
else	O
emitc	O
(	O
' '	O
)	O
;	O
break	O
;	O
default	O
:	O
emitc	O
(	O
token	pointer
.	O
type	int
)	O
;	O
}	O
}	O
else	O
if	O
(	O
token	pointer
.	O
type	int
==	O
'\n'	O
&&	O
state_is	function
(	O
COMMENT	int
)	O
&&	O
state_bottom	function
(	O
CODE	int
)	O
)	O
emits	O
(	O
"@cr\n"	pointer
)	O
;	O
else	O
if	O
(	O
state_is	function
(	O
CONTROL	int
)	O
&&	O
token	pointer
.	O
type	int
==	O
','	O
)	O
emits	O
(	O
"@value{COMMA}"	pointer
)	O
;	O
else	O
emitc	O
(	O
token	pointer
.	O
type	int
)	O
;	O
}	O
}	O
}	O
struct	O
tangle_subst	struct
{	O
struct	O
tangle_subst	struct
*	O
next	pointer
;	O
char	O
*	O
src	pointer
;	O
char	O
*	O
dst	pointer
;	O
}	O
;	O
struct	O
tangle_subst	struct
*	O
ts_push	function
(	O
struct	O
tangle_subst	struct
*	O
tos	pointer
,	O
const	O
char	O
*	O
src	pointer
,	O
size_t	long
src_len	long
,	O
const	O
char	O
*	O
dst	pointer
,	O
size_t	long
dst_len	long
)	O
{	O
struct	O
tangle_subst	struct
*	O
new	pointer
=	O
xmalloc	function
(	O
sizeof	O
*	O
new	pointer
)	O
;	O
new	pointer
->	O
src	pointer
=	O
xstrndup	function
(	O
src	pointer
,	O
src_len	long
)	O
;	O
new	pointer
->	O
dst	pointer
=	O
xstrndup	function
(	O
dst	pointer
,	O
dst_len	long
)	O
;	O
new	pointer
->	O
next	pointer
=	O
tos	pointer
;	O
return	O
new	pointer
;	O
}	O
static	O
void	O
ts_free	function
(	O
struct	O
tangle_subst	struct
*	O
s	pointer
)	O
{	O
free	function
(	O
s	pointer
->	O
src	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
dst	pointer
)	O
;	O
free	function
(	O
s	pointer
)	O
;	O
}	O
struct	O
tangle_subst	struct
*	O
ts_pop	function
(	O
struct	O
tangle_subst	struct
*	O
tos	pointer
)	O
{	O
struct	O
tangle_subst	struct
*	O
next	pointer
=	O
tos	pointer
->	O
next	pointer
;	O
ts_free	function
(	O
tos	pointer
)	O
;	O
return	O
next	pointer
;	O
}	O
static	O
void	O
flush_whitespace	function
(	O
int	O
*	O
indent	pointer
,	O
struct	O
line	int
*	O
line	int
,	O
struct	O
loc	struct
*	O
loc	struct
)	O
{	O
if	O
(	O
(	O
loc	struct
->	O
ln	int
!=	O
line	int
->	O
loc	struct
.	O
ln	int
||	O
loc	struct
->	O
fn	pointer
!=	O
line	int
->	O
loc	struct
.	O
fn	pointer
)	O
&&	O
opt_line	int
)	O
{	O
if	O
(	O
loc	struct
->	O
fn	pointer
!=	O
line	int
->	O
loc	struct
.	O
fn	pointer
)	O
emitf	function
(	O
"#line %d \"%s\"\n"	pointer
,	O
line	int
->	O
loc	struct
.	O
ln	int
,	O
line	int
->	O
loc	struct
.	O
fn	pointer
)	O
;	O
else	O
emitf	function
(	O
"#line %d\n"	pointer
,	O
line	int
->	O
loc	struct
.	O
ln	int
)	O
;	O
*	O
loc	struct
=	O
line	int
->	O
loc	struct
;	O
}	O
for	O
(	O
;	O
*	O
indent	pointer
>	O
0	int
;	O
(	O
*	O
indent	pointer
)	O
--	O
)	O
emitc	O
(	O
' '	O
)	O
;	O
}	O
static	O
int	O
mem_casecmp	function
(	O
const	O
char	O
*	O
a	pointer
,	O
const	O
char	O
*	O
b	pointer
,	O
size_t	long
len	long
)	O
{	O
for	O
(	O
;	O
len	long
;	O
a	pointer
++	O
,	O
b	pointer
++	O
,	O
len	long
--	O
)	O
if	O
(	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
a	pointer
)	O
!=	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
b	pointer
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
no_upper	function
(	O
const	O
char	O
*	O
s	pointer
,	O
size_t	long
len	long
)	O
{	O
while	O
(	O
len	long
--	O
)	O
if	O
(	O
isupper	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
int	O
no_lower	function
(	O
const	O
char	O
*	O
s	pointer
,	O
size_t	long
len	long
)	O
{	O
while	O
(	O
len	long
--	O
)	O
if	O
(	O
islower	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
s	pointer
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
ts_emit	function
(	O
const	O
char	O
*	O
text	pointer
,	O
size_t	long
len	long
,	O
struct	O
tangle_subst	struct
*	O
s	pointer
)	O
{	O
char	O
*	O
cur_text	pointer
=	O
(	O
char	O
*	O
)	O
text	pointer
;	O
size_t	long
cur_len	long
=	O
len	long
;	O
for	O
(	O
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
{	O
const	O
size_t	long
src_len	long
=	O
strlen	function
(	O
s	pointer
->	O
src	pointer
)	O
;	O
const	O
size_t	long
dst_len	long
=	O
strlen	function
(	O
s	pointer
->	O
dst	pointer
)	O
;	O
char	O
*	O
next_text	pointer
,	O
*	O
d	pointer
;	O
const	O
char	O
*	O
p	pointer
;	O
size_t	long
next_len	long
;	O
size_t	long
n_upper	long
;	O
if	O
(	O
cur_len	long
<	O
src_len	long
||	O
mem_casecmp	function
(	O
cur_text	pointer
,	O
s	pointer
->	O
src	pointer
,	O
src_len	long
)	O
)	O
continue	O
;	O
next_len	long
=	O
dst_len	long
+	O
(	O
cur_len	long
-	O
src_len	long
)	O
;	O
d	pointer
=	O
next_text	pointer
=	O
xmalloc	function
(	O
next_len	long
+	O
1	int
)	O
;	O
if	O
(	O
!	O
no_upper	function
(	O
s	pointer
->	O
src	pointer
,	O
src_len	long
)	O
||	O
!	O
no_upper	function
(	O
s	pointer
->	O
dst	pointer
,	O
dst_len	long
)	O
||	O
no_upper	function
(	O
cur_text	pointer
,	O
cur_len	long
)	O
)	O
n_upper	long
=	O
0	int
;	O
else	O
if	O
(	O
no_lower	function
(	O
cur_text	pointer
,	O
cur_len	long
)	O
)	O
n_upper	long
=	O
dst_len	long
;	O
else	O
n_upper	long
=	O
1	int
;	O
for	O
(	O
p	pointer
=	O
s	pointer
->	O
dst	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
n_upper	long
>	O
0	int
)	O
{	O
*	O
d	pointer
++	O
=	O
toupper	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
p	pointer
)	O
;	O
n_upper	long
--	O
;	O
}	O
else	O
*	O
d	pointer
++	O
=	O
*	O
p	pointer
;	O
memcpy	function
(	O
d	pointer
,	O
cur_text	pointer
+	O
src_len	long
,	O
cur_len	long
-	O
src_len	long
)	O
;	O
d	pointer
[	O
cur_len	long
-	O
src_len	long
]	O
=	O
'\0'	O
;	O
if	O
(	O
cur_text	pointer
!=	O
text	pointer
)	O
free	function
(	O
cur_text	pointer
)	O
;	O
cur_text	pointer
=	O
next_text	pointer
;	O
cur_len	long
=	O
next_len	long
;	O
}	O
emitb	O
(	O
cur_text	pointer
,	O
cur_len	long
)	O
;	O
if	O
(	O
cur_text	pointer
!=	O
text	pointer
)	O
free	function
(	O
cur_text	pointer
)	O
;	O
}	O
static	O
const	O
char	O
*	O
ts_get_token_no_ws	function
(	O
const	O
char	O
*	O
p	pointer
,	O
struct	O
token	pointer
*	O
token	pointer
)	O
{	O
for	O
(	O
;	O
;	O
)	O
{	O
p	pointer
=	O
token_get	function
(	O
p	pointer
,	O
token	pointer
)	O
;	O
if	O
(	O
!	O
token_space_p	function
(	O
token	pointer
)	O
)	O
return	O
p	pointer
;	O
}	O
}	O
static	O
int	O
ts_expect	function
(	O
const	O
char	O
*	O
*	O
p	pointer
,	O
int	O
c	int
,	O
const	O
char	O
*	O
message	pointer
,	O
struct	O
loc	struct
*	O
loc	struct
)	O
{	O
struct	O
token	pointer
token	pointer
;	O
*	O
p	pointer
=	O
ts_get_token_no_ws	function
(	O
*	O
p	pointer
,	O
&	O
token	pointer
)	O
;	O
if	O
(	O
token	pointer
.	O
type	int
==	O
c	int
)	O
return	O
1	int
;	O
error	function
(	O
0	int
,	O
message	pointer
,	O
loc	struct
->	O
fn	pointer
,	O
loc	struct
->	O
fn	pointer
)	O
;	O
return	O
0	int
;	O
}	O
static	O
struct	O
tangle_subst	struct
*	O
ts_parse	function
(	O
struct	O
tangle_subst	struct
*	O
s	pointer
,	O
const	O
char	O
*	O
text	pointer
,	O
struct	O
loc	struct
*	O
loc	struct
,	O
int	O
*	O
cnt	int
)	O
{	O
const	O
char	O
*	O
p	pointer
;	O
*	O
cnt	int
=	O
0	int
;	O
p	pointer
=	O
strchr	function
(	O
text	pointer
,	O
';'	O
)	O
;	O
if	O
(	O
p	pointer
==	O
NULL	O
)	O
return	O
s	pointer
;	O
while	O
(	O
*	O
p	pointer
!=	O
'\0'	O
)	O
{	O
struct	O
token	pointer
src	pointer
,	O
dst	pointer
;	O
if	O
(	O
!	O
ts_expect	function
(	O
&	O
p	pointer
,	O
';'	O
,	O
"%s:%d: `;' or `@>' expected"	pointer
,	O
loc	struct
)	O
)	O
goto	O
error	function
;	O
p	pointer
=	O
ts_get_token_no_ws	function
(	O
p	pointer
,	O
&	O
src	pointer
)	O
;	O
if	O
(	O
src	pointer
.	O
type	int
!=	O
TOKEN_ID	int
)	O
{	O
error	function
(	O
0	int
,	O
_	O
(	O
"%s:%d: Identifier expected after `;'"	pointer
)	O
,	O
loc	struct
->	O
fn	pointer
,	O
loc	struct
->	O
ln	int
)	O
;	O
goto	O
error	function
;	O
}	O
if	O
(	O
!	O
ts_expect	function
(	O
&	O
p	pointer
,	O
'='	O
,	O
"%s:%d: `=>' expected"	pointer
,	O
loc	struct
)	O
||	O
!	O
ts_expect	function
(	O
&	O
p	pointer
,	O
'>'	O
,	O
"%s:%d: `=>' expected"	pointer
,	O
loc	struct
)	O
)	O
goto	O
error	function
;	O
p	pointer
=	O
ts_get_token_no_ws	function
(	O
p	pointer
,	O
&	O
dst	pointer
)	O
;	O
if	O
(	O
dst	pointer
.	O
type	int
!=	O
TOKEN_ID	int
)	O
{	O
error	function
(	O
0	int
,	O
_	O
(	O
"%s:%d: Identifier expected after `=>'"	pointer
)	O
,	O
loc	struct
->	O
fn	pointer
,	O
loc	struct
->	O
ln	int
)	O
;	O
goto	O
error	function
;	O
}	O
s	pointer
=	O
ts_push	function
(	O
s	pointer
,	O
src	pointer
.	O
text	pointer
,	O
src	pointer
.	O
len	long
,	O
dst	pointer
.	O
text	pointer
,	O
dst	pointer
.	O
len	long
)	O
;	O
*	O
cnt	int
+=	O
1	int
;	O
}	O
return	O
s	pointer
;	O
error	function
:	O
for	O
(	O
;	O
*	O
cnt	int
>	O
0	int
;	O
*	O
cnt	int
-=	O
1	int
)	O
s	pointer
=	O
ts_pop	function
(	O
s	pointer
)	O
;	O
return	O
s	pointer
;	O
}	O
static	O
void	O
tangle_print	function
(	O
struct	O
segment	pointer
*	O
segment	pointer
,	O
int	O
indent	pointer
,	O
struct	O
loc	struct
*	O
loc	struct
,	O
struct	O
tangle_subst	struct
*	O
subst	pointer
)	O
{	O
struct	O
line	int
*	O
line	int
;	O
segment	pointer
->	O
use	int
++	O
;	O
for	O
(	O
line	int
=	O
segment	pointer
->	O
c_head	pointer
;	O
line	int
!=	O
NULL	O
;	O
line	int
=	O
line	int
->	O
next	pointer
)	O
{	O
const	O
char	O
*	O
cp	pointer
;	O
int	O
indentation	int
=	O
indent_amount	function
(	O
line	int
->	O
text	pointer
,	O
&	O
cp	pointer
)	O
+	O
indent	pointer
;	O
int	O
i	int
=	O
indentation	int
;	O
loc	struct
->	O
ln	int
++	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
struct	O
token	pointer
token	pointer
;	O
cp	pointer
=	O
token_get	function
(	O
cp	pointer
,	O
&	O
token	pointer
)	O
;	O
if	O
(	O
in_control	int
&&	O
token	pointer
.	O
type	int
!=	O
TOKEN_END_CONTROL	int
)	O
{	O
add_control	function
(	O
token	pointer
.	O
text	pointer
,	O
token	pointer
.	O
len	long
)	O
;	O
continue	O
;	O
}	O
switch	O
(	O
token	pointer
.	O
type	int
)	O
{	O
case	O
0	int
:	O
goto	O
next_line	O
;	O
case	O
TOKEN_COND_NEWLINE	int
:	O
case	O
'\n'	O
:	O
emitc	O
(	O
'\n'	O
)	O
;	O
break	O
;	O
case	O
TOKEN_BEGIN_CONTROL	int
:	O
if	O
(	O
!	O
in_control	int
)	O
{	O
state_push	function
(	O
CONTROL	int
)	O
;	O
in_control	int
=	O
1	int
;	O
control_len	long
=	O
0	int
;	O
control_space	int
=	O
0	int
;	O
}	O
else	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Can't nest control texts."	pointer
)	O
)	O
;	O
break	O
;	O
case	O
TOKEN_SEMICOLON	int
:	O
case	O
TOKEN_INC_INDENT	int
:	O
case	O
TOKEN_DEC_INDENT	int
:	O
break	O
;	O
case	O
TOKEN_PIPE	int
:	O
flush_whitespace	function
(	O
&	O
i	int
,	O
line	int
,	O
loc	struct
)	O
;	O
emitc	O
(	O
'|'	O
)	O
;	O
break	O
;	O
case	O
TOKEN_AT	int
:	O
flush_whitespace	function
(	O
&	O
i	int
,	O
line	int
,	O
loc	struct
)	O
;	O
emitc	O
(	O
'@'	O
)	O
;	O
break	O
;	O
case	O
TOKEN_END_CONTROL	int
:	O
if	O
(	O
control_len	long
>	O
0	int
)	O
control_buf	pointer
[	O
control_len	long
]	O
=	O
'\0'	O
;	O
else	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Empty control text."	pointer
)	O
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
in_control	int
)	O
in_control	int
=	O
0	int
;	O
else	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"@> not inside control text."	pointer
)	O
)	O
;	O
while	O
(	O
!	O
state_is	function
(	O
CONTROL	int
)	O
)	O
{	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Missing closing within control text."	pointer
)	O
)	O
;	O
state_pop	function
(	O
)	O
;	O
}	O
state_pop	function
(	O
)	O
;	O
{	O
struct	O
segment	pointer
*	O
segment	pointer
=	O
segment_find	function
(	O
control_buf	pointer
,	O
0	int
)	O
;	O
struct	O
tangle_subst	struct
*	O
s	pointer
;	O
int	O
cnt	int
;	O
s	pointer
=	O
ts_parse	function
(	O
subst	pointer
,	O
control_buf	pointer
,	O
&	O
line	int
->	O
loc	struct
,	O
&	O
cnt	int
)	O
;	O
if	O
(	O
segment	pointer
!=	O
NULL	O
)	O
tangle_print	function
(	O
segment	pointer
,	O
indentation	int
,	O
loc	struct
,	O
s	pointer
!=	O
NULL	O
?	O
s	pointer
:	O
subst	pointer
)	O
;	O
else	O
{	O
emitf	function
(	O
"/* Undefined segment: %s. */\n"	pointer
,	O
control_buf	pointer
)	O
;	O
error	function
(	O
0	int
,	O
_	O
(	O
"%s:%d: segment `%s' undefined"	pointer
)	O
,	O
line	int
->	O
loc	struct
.	O
fn	pointer
,	O
line	int
->	O
loc	struct
.	O
ln	int
,	O
control_buf	pointer
)	O
;	O
}	O
for	O
(	O
;	O
cnt	int
>	O
0	int
;	O
cnt	int
--	O
)	O
s	pointer
=	O
ts_pop	function
(	O
s	pointer
)	O
;	O
assert	O
(	O
s	pointer
==	O
subst	pointer
)	O
;	O
}	O
{	O
const	O
char	O
*	O
p	pointer
=	O
cp	pointer
;	O
for	O
(	O
;	O
;	O
)	O
{	O
p	pointer
=	O
token_get	function
(	O
p	pointer
,	O
&	O
token	pointer
)	O
;	O
if	O
(	O
token	pointer
.	O
type	int
==	O
0	int
)	O
goto	O
next_line	O
;	O
else	O
if	O
(	O
token	pointer
.	O
type	int
!=	O
TOKEN_COND_NEWLINE	int
&&	O
token	pointer
.	O
type	int
!=	O
TOKEN_INC_INDENT	int
&&	O
token	pointer
.	O
type	int
!=	O
TOKEN_DEC_INDENT	int
&&	O
!	O
token_space_p	function
(	O
&	O
token	pointer
)	O
)	O
break	O
;	O
}	O
}	O
break	O
;	O
case	O
TOKEN_ID	int
:	O
flush_whitespace	function
(	O
&	O
i	int
,	O
line	int
,	O
loc	struct
)	O
;	O
ts_emit	function
(	O
token	pointer
.	O
text	pointer
,	O
token	pointer
.	O
len	long
,	O
subst	pointer
)	O
;	O
break	O
;	O
case	O
' '	O
:	O
i	int
++	O
;	O
break	O
;	O
case	O
'\t'	O
:	O
i	int
=	O
(	O
i	int
+	O
8	int
)	O
/	O
8	int
*	O
8	int
;	O
break	O
;	O
default	O
:	O
flush_whitespace	function
(	O
&	O
i	int
,	O
line	int
,	O
loc	struct
)	O
;	O
emitb	O
(	O
token	pointer
.	O
text	pointer
,	O
token	pointer
.	O
len	long
)	O
;	O
break	O
;	O
}	O
}	O
next_line	O
:	O
;	O
}	O
}	O
static	O
void	O
tangle	function
(	O
void	O
)	O
{	O
size_t	long
line_size	pointer
=	O
0	int
;	O
char	O
*	O
line	int
=	O
NULL	O
;	O
struct	O
segment	pointer
*	O
files	pointer
=	O
NULL	O
;	O
int	O
blank_line	int
=	O
0	int
;	O
state_init	function
(	O
)	O
;	O
state_push	function
(	O
TEXT	int
)	O
;	O
input_start_pass	function
(	O
)	O
;	O
while	O
(	O
input_read_line	function
(	O
&	O
line	int
,	O
&	O
line_size	pointer
)	O
)	O
{	O
char	O
cmd	pointer
[	O
CMD_LEN_MAX	int
+	O
1	int
]	O
;	O
if	O
(	O
parse_at_cmd	function
(	O
line	int
,	O
cmd	pointer
)	O
)	O
{	O
if	O
(	O
cmd	pointer
[	O
0	int
]	O
==	O
'\0'	O
||	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"node"	pointer
)	O
)	O
{	O
segment_select	function
(	O
NULL	O
)	O
;	O
blank_line	int
=	O
0	int
;	O
continue	O
;	O
}	O
else	O
{	O
char	O
*	O
control_text	pointer
=	O
segment_definition_line	function
(	O
line	int
,	O
NULL	O
)	O
;	O
if	O
(	O
control_text	pointer
!=	O
NULL	O
)	O
{	O
struct	O
segment	pointer
*	O
segment	pointer
;	O
segment	pointer
=	O
segment_find	function
(	O
control_text	pointer
,	O
0	int
)	O
;	O
if	O
(	O
segment	pointer
==	O
NULL	O
)	O
{	O
segment	pointer
=	O
segment_find	function
(	O
control_text	pointer
,	O
1	int
)	O
;	O
assert	O
(	O
segment	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
line	int
[	O
1	int
]	O
==	O
'('	O
)	O
{	O
segment	pointer
->	O
c_next	pointer
=	O
files	pointer
;	O
files	pointer
=	O
segment	pointer
;	O
}	O
blank_line	int
=	O
0	int
;	O
}	O
else	O
blank_line	int
=	O
0	int
;	O
segment_select	function
(	O
segment	pointer
)	O
;	O
free	function
(	O
control_text	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
}	O
if	O
(	O
blank_line	int
)	O
{	O
blank_line	int
=	O
0	int
;	O
segment_add_line	function
(	O
"\n"	pointer
)	O
;	O
}	O
segment_add_line	function
(	O
line	int
)	O
;	O
}	O
input_end_pass	function
(	O
)	O
;	O
state_pop	function
(	O
)	O
;	O
free	function
(	O
line	int
)	O
;	O
{	O
time_t	long
t	long
;	O
struct	O
tm	struct
tm	struct
;	O
struct	O
loc	struct
loc	struct
;	O
time	function
(	O
&	O
t	long
)	O
;	O
tm	struct
=	O
*	O
localtime	function
(	O
&	O
t	long
)	O
;	O
loc	struct
.	O
fn	pointer
=	O
NULL	O
;	O
loc	struct
.	O
ln	int
=	O
0	int
;	O
for	O
(	O
;	O
files	pointer
!=	O
NULL	O
;	O
files	pointer
=	O
files	pointer
->	O
c_next	pointer
)	O
if	O
(	O
filenames_only	int
)	O
puts	function
(	O
files	pointer
->	O
name	pointer
)	O
;	O
else	O
{	O
if	O
(	O
out_file_name	pointer
&&	O
strcmp	function
(	O
files	pointer
->	O
name	pointer
,	O
out_file_name	pointer
)	O
)	O
continue	O
;	O
out_file_name	pointer
=	O
files	pointer
->	O
name	pointer
;	O
out_file	pointer
=	O
fopen	function
(	O
out_file_name	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
out_file	pointer
==	O
NULL	O
)	O
error	function
(	O
FTL	int
,	O
_	O
(	O
"Opening %s for writing: %s"	pointer
)	O
,	O
out_file_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
time	function
(	O
&	O
t	long
)	O
;	O
fprintf	function
(	O
out_file	pointer
,	O
"/* Produced by texiweb from %s "	pointer
"on %04d/%02d/%02d at %02d:%02d. */\n\n"	pointer
,	O
in_file_name	pointer
,	O
tm	struct
.	O
tm_year	int
+	O
1900	int
,	O
tm	struct
.	O
tm_mon	int
+	O
1	int
,	O
tm	struct
.	O
tm_mday	int
,	O
tm	struct
.	O
tm_hour	int
,	O
tm	struct
.	O
tm_min	int
)	O
;	O
state_init	function
(	O
)	O
;	O
state_push	function
(	O
CODE	int
)	O
;	O
tangle_print	function
(	O
files	pointer
,	O
0	int
,	O
&	O
loc	struct
,	O
NULL	O
)	O
;	O
state_pop	function
(	O
)	O
;	O
out_file_name	pointer
=	O
NULL	O
;	O
}	O
}	O
if	O
(	O
print_unused	int
)	O
{	O
struct	O
segment	pointer
*	O
s	pointer
;	O
for	O
(	O
s	pointer
=	O
segment_first	pointer
;	O
s	pointer
!=	O
NULL	O
;	O
s	pointer
=	O
s	pointer
->	O
next	pointer
)	O
if	O
(	O
s	pointer
->	O
use	int
==	O
0	int
&&	O
strcmp	function
(	O
s	pointer
->	O
name	pointer
,	O
"Anonymous"	pointer
)	O
)	O
{	O
if	O
(	O
s	pointer
->	O
c_head	pointer
!=	O
NULL	O
)	O
printf	function
(	O
"%s:%d: "	pointer
,	O
s	pointer
->	O
c_head	pointer
->	O
loc	struct
.	O
fn	pointer
,	O
s	pointer
->	O
c_head	pointer
->	O
loc	struct
.	O
ln	int
)	O
;	O
printf	function
(	O
"segment `%s' not included in any output file\n"	pointer
,	O
s	pointer
->	O
name	pointer
)	O
;	O
}	O
}	O
}	O
enum	O
state_name	enum
{	O
STATE_START	int
,	O
STATE_PARSE	int
,	O
STATE_PARSE_ERROR	int
}	O
;	O
enum	O
type	int
{	O
TYPE_BASIC	int
,	O
TYPE_POINTER	int
,	O
TYPE_ARRAY	int
,	O
TYPE_FUNCTION	int
}	O
;	O
struct	O
engine_state	struct
{	O
enum	O
state_name	enum
state	enum
;	O
char	O
*	O
last_id	pointer
;	O
char	O
*	O
save_id	pointer
;	O
int	O
last_was_struct	int
;	O
int	O
struct_type	int
;	O
char	O
*	O
tag	pointer
;	O
int	O
typedefing	int
;	O
enum	O
type	int
type	int
;	O
enum	O
type	int
last_type	enum
;	O
int	O
stack_cnt	int
;	O
int	O
stack	array
[	O
STACK_HEIGHT	int
]	O
;	O
}	O
;	O
static	O
void	O
init_engine_state	function
(	O
struct	O
engine_state	struct
*	O
s	pointer
)	O
{	O
s	pointer
->	O
state	enum
=	O
STATE_START	int
;	O
free	function
(	O
s	pointer
->	O
last_id	pointer
)	O
;	O
free	function
(	O
s	pointer
->	O
save_id	pointer
)	O
;	O
s	pointer
->	O
last_id	pointer
=	O
s	pointer
->	O
save_id	pointer
=	O
NULL	O
;	O
s	pointer
->	O
last_was_struct	int
=	O
0	int
;	O
free	function
(	O
s	pointer
->	O
tag	pointer
)	O
;	O
s	pointer
->	O
tag	pointer
=	O
NULL	O
;	O
s	pointer
->	O
typedefing	int
=	O
0	int
;	O
s	pointer
->	O
type	int
=	O
s	pointer
->	O
last_type	enum
=	O
TYPE_BASIC	int
;	O
s	pointer
->	O
stack_cnt	int
=	O
1	int
;	O
s	pointer
->	O
stack	array
[	O
0	int
]	O
=	O
0	int
;	O
}	O
static	O
int	O
debug_parser	int
=	O
0	int
;	O
static	O
int	O
lr_engine	function
(	O
struct	O
engine_state	struct
*	O
engine	pointer
,	O
struct	O
token	pointer
*	O
token	pointer
)	O
{	O
enum	O
{	O
err	int
,	O
acc	int
,	O
s0	int
,	O
s1	int
,	O
s2	int
,	O
s3	int
,	O
s4	int
,	O
s5	int
,	O
s6	int
,	O
s7	int
,	O
s8	int
,	O
s9	int
,	O
s10	int
,	O
s11	int
,	O
s12	int
,	O
s13	int
,	O
s14	int
,	O
s15	int
,	O
s16	int
,	O
s17	int
,	O
s18	int
,	O
s19	int
,	O
s20	int
,	O
s21	int
,	O
s22	int
,	O
s23	int
,	O
s24	int
,	O
s25	int
,	O
s26	int
,	O
s27	int
,	O
s28	int
,	O
s29	int
,	O
s30	int
,	O
s31	int
,	O
s32	int
,	O
s33	int
,	O
s34	int
,	O
s35	int
,	O
s36	int
,	O
s37	int
,	O
s38	int
,	O
s39	int
,	O
s40	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
s49	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
s53	int
,	O
s54	int
,	O
s55	int
,	O
s56	int
,	O
s57	int
,	O
s58	int
,	O
s59	int
,	O
s60	int
,	O
s61	int
,	O
s62	int
,	O
r1	int
,	O
r2	int
,	O
r3	int
,	O
r4	int
,	O
r5	int
,	O
r6	int
,	O
r7	int
,	O
r8	int
,	O
r9	int
,	O
r10	int
,	O
r11	int
,	O
r12	int
,	O
r13	int
,	O
r14	int
,	O
r15	int
,	O
r16	int
,	O
r17	int
,	O
r18	int
,	O
r19	int
,	O
r20	int
,	O
r21	int
,	O
r22	int
,	O
r23	int
,	O
r24	int
,	O
r25	int
,	O
r26	int
,	O
r27	int
,	O
r28	int
,	O
r29	int
,	O
r30	int
,	O
r31	int
,	O
r32	int
,	O
r33	int
,	O
r34	int
,	O
r35	int
,	O
r36	int
,	O
r37	int
,	O
r38	int
,	O
r39	int
,	O
r40	int
,	O
n_states	int
=	O
63	int
,	O
n_terminals	int
=	O
16	int
,	O
n_nonterminals	int
=	O
15	int
,	O
n_reductions	int
=	O
40	int
}	O
;	O
enum	O
{	O
lex_lparen	int
,	O
lex_rparen	int
,	O
lex_pointer	int
,	O
lex_comma	int
,	O
lex_typedef	int
,	O
lex_type_name	int
,	O
lex_struct	int
,	O
lex_const	int
,	O
lex_semicolon	int
,	O
lex_lbrack	int
,	O
lex_rbrack	int
,	O
lex_identifier	int
,	O
lex_other	int
,	O
lex_lbrace	int
,	O
lex_rbrace	int
,	O
lex_stop	int
}	O
;	O
static	O
const	O
unsigned	O
char	O
action_table	array
[	O
n_states	int
]	O
[	O
n_terminals	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s1	int
,	O
s2	int
,	O
s3	int
,	O
s4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r6	int
,	O
0	int
,	O
r6	int
,	O
0	int
,	O
r6	int
,	O
r6	int
,	O
r6	int
,	O
r6	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r6	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r7	int
,	O
0	int
,	O
r7	int
,	O
0	int
,	O
r7	int
,	O
r7	int
,	O
r7	int
,	O
r7	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r7	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r9	int
,	O
0	int
,	O
r9	int
,	O
0	int
,	O
r9	int
,	O
r9	int
,	O
r9	int
,	O
r9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r9	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s9	int
,	O
0	int
,	O
s10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s1	int
,	O
s2	int
,	O
s3	int
,	O
s4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
acc	int
}	O
,	O
{	O
r5	int
,	O
0	int
,	O
r5	int
,	O
0	int
,	O
s1	int
,	O
s2	int
,	O
s3	int
,	O
s4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r5	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r11	int
,	O
0	int
,	O
r11	int
,	O
0	int
,	O
r11	int
,	O
r11	int
,	O
r11	int
,	O
r11	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r11	int
,	O
0	int
,	O
s20	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s9	int
,	O
0	int
,	O
s10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r18	int
,	O
0	int
,	O
r18	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r18	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r18	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s23	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s26	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s27	int
,	O
r16	int
,	O
0	int
,	O
r16	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r16	int
,	O
s28	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r16	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r19	int
,	O
r19	int
,	O
0	int
,	O
r19	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r19	int
,	O
r19	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r19	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
s29	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r14	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r14	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r23	int
,	O
r23	int
,	O
0	int
,	O
r23	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r23	int
,	O
r23	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r23	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s9	int
,	O
0	int
,	O
s10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r4	int
,	O
0	int
,	O
r4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r4	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r8	int
,	O
0	int
,	O
r8	int
,	O
0	int
,	O
r8	int
,	O
r8	int
,	O
r8	int
,	O
r8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r8	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r12	int
,	O
0	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
0	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
r12	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
s32	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s9	int
,	O
0	int
,	O
s10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s33	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r38	int
,	O
r38	int
,	O
r38	int
,	O
r38	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r38	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r2	int
,	O
r2	int
,	O
r2	int
,	O
r2	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r2	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r40	int
,	O
0	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
0	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
r40	int
,	O
0	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
s9	int
,	O
0	int
,	O
s10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s23	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
s26	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
0	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
0	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
s53	int
,	O
0	int
}	O
,	O
{	O
r20	int
,	O
r20	int
,	O
0	int
,	O
r20	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r20	int
,	O
r20	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r20	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r17	int
,	O
0	int
,	O
r17	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r17	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r17	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
r15	int
,	O
0	int
,	O
r15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r15	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r15	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
0	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
0	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
s54	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
s55	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
0	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
0	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
s56	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r13	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r3	int
,	O
r3	int
,	O
r3	int
,	O
r3	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r3	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
r36	int
,	O
0	int
}	O
,	O
{	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
r35	int
,	O
0	int
}	O
,	O
{	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
r31	int
,	O
0	int
}	O
,	O
{	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
r32	int
,	O
0	int
}	O
,	O
{	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
r33	int
,	O
0	int
}	O
,	O
{	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
r34	int
,	O
0	int
}	O
,	O
{	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
r37	int
,	O
0	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
r25	int
,	O
0	int
}	O
,	O
{	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
r29	int
,	O
0	int
}	O
,	O
{	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
r30	int
,	O
0	int
}	O
,	O
{	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
r24	int
,	O
0	int
}	O
,	O
{	O
r10	int
,	O
0	int
,	O
r10	int
,	O
0	int
,	O
r10	int
,	O
r10	int
,	O
r10	int
,	O
r10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r10	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r39	int
,	O
r39	int
,	O
r39	int
,	O
r39	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r39	int
}	O
,	O
{	O
r22	int
,	O
r22	int
,	O
0	int
,	O
r22	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r22	int
,	O
r22	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r22	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
r21	int
,	O
r21	int
,	O
0	int
,	O
r21	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r21	int
,	O
r21	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
r21	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
s60	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
0	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
0	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
s61	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
s40	int
,	O
0	int
,	O
s41	int
,	O
s42	int
,	O
s43	int
,	O
s44	int
,	O
s45	int
,	O
s46	int
,	O
s47	int
,	O
s48	int
,	O
0	int
,	O
s50	int
,	O
s51	int
,	O
s52	int
,	O
s62	int
,	O
0	int
}	O
,	O
{	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
r26	int
,	O
0	int
}	O
,	O
{	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
r28	int
,	O
0	int
}	O
,	O
{	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
r27	int
,	O
0	int
}	O
,	O
}	O
;	O
static	O
const	O
unsigned	O
char	O
goto_table	array
[	O
n_states	int
]	O
[	O
n_nonterminals	int
]	O
=	O
{	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
5	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
6	int
,	O
7	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
11	int
,	O
12	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
16	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
7	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
17	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
7	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
18	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
19	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
21	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
22	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
24	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
25	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
30	int
,	O
12	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
31	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
12	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
34	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
35	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
36	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
37	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
38	int
,	O
12	int
,	O
13	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
14	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
39	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
25	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
57	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
58	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
59	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
49	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
0	int
}	O
,	O
}	O
;	O
enum	O
{	O
reduce_null	int
,	O
reduce_array	int
,	O
reduce_declaration	int
,	O
reduce_declarator	int
,	O
reduce_function	int
,	O
reduce_function_definition	int
,	O
reduce_identifier	int
,	O
reduce_pointer	int
,	O
reduce_struct_definition	int
,	O
reduce_typedef	int
}	O
;	O
static	O
const	O
unsigned	O
char	O
reduce_table	array
[	O
n_reductions	int
]	O
[	O
3	int
]	O
=	O
{	O
{	O
1	int
,	O
5	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
11	int
,	O
reduce_declaration	int
}	O
,	O
{	O
4	int
,	O
11	int
,	O
reduce_declaration	int
}	O
,	O
{	O
2	int
,	O
6	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
6	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
12	int
,	O
reduce_typedef	int
}	O
,	O
{	O
1	int
,	O
12	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
12	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
12	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
0	int
,	O
reduce_null	int
}	O
,	O
{	O
0	int
,	O
0	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
13	int
,	O
reduce_struct_definition	int
}	O
,	O
{	O
3	int
,	O
1	int
,	O
reduce_declarator	int
}	O
,	O
{	O
1	int
,	O
1	int
,	O
reduce_declarator	int
}	O
,	O
{	O
3	int
,	O
9	int
,	O
reduce_pointer	int
}	O
,	O
{	O
1	int
,	O
9	int
,	O
reduce_null	int
}	O
,	O
{	O
2	int
,	O
4	int
,	O
reduce_null	int
}	O
,	O
{	O
0	int
,	O
4	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
2	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
2	int
,	O
reduce_null	int
}	O
,	O
{	O
4	int
,	O
2	int
,	O
reduce_array	int
}	O
,	O
{	O
4	int
,	O
2	int
,	O
reduce_function	int
}	O
,	O
{	O
1	int
,	O
3	int
,	O
reduce_identifier	int
}	O
,	O
{	O
0	int
,	O
7	int
,	O
reduce_null	int
}	O
,	O
{	O
2	int
,	O
7	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
8	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
10	int
,	O
reduce_null	int
}	O
,	O
{	O
3	int
,	O
10	int
,	O
reduce_null	int
}	O
,	O
{	O
1	int
,	O
14	int
,	O
reduce_function_definition	int
}	O
,	O
}	O
;	O
int	O
a	pointer
;	O
switch	O
(	O
token	pointer
->	O
type	int
)	O
{	O
case	O
'{'	O
:	O
a	pointer
=	O
lex_lbrace	int
;	O
break	O
;	O
case	O
'}'	O
:	O
a	pointer
=	O
lex_rbrace	int
;	O
break	O
;	O
case	O
','	O
:	O
a	pointer
=	O
lex_comma	int
;	O
break	O
;	O
case	O
'*'	O
:	O
a	pointer
=	O
lex_pointer	int
;	O
break	O
;	O
case	O
'('	O
:	O
a	pointer
=	O
lex_lparen	int
;	O
break	O
;	O
case	O
')'	O
:	O
a	pointer
=	O
lex_rparen	int
;	O
break	O
;	O
case	O
'['	O
:	O
a	pointer
=	O
lex_lbrack	int
;	O
break	O
;	O
case	O
']'	O
:	O
a	pointer
=	O
lex_rbrack	int
;	O
break	O
;	O
case	O
';'	O
:	O
a	pointer
=	O
lex_semicolon	int
;	O
break	O
;	O
case	O
TOKEN_ID	int
:	O
{	O
struct	O
symbol	struct
*	O
symbol	struct
=	O
symbol_find	function
(	O
token	pointer
->	O
text	pointer
,	O
token	pointer
->	O
len	long
,	O
0	int
)	O
;	O
switch	O
(	O
symbol	struct
?	O
symbol	struct
->	O
kw_idx	int
:	O
-	O
1	int
)	O
{	O
case	O
KW_TYPEDEF	int
:	O
a	pointer
=	O
lex_typedef	int
;	O
break	O
;	O
case	O
KW_EXTERN	int
:	O
case	O
KW_STATIC	int
:	O
case	O
KW_AUTO	int
:	O
case	O
KW_REGISTER	int
:	O
case	O
KW_VOID	int
:	O
case	O
KW_CHAR	int
:	O
case	O
KW_SHORT	int
:	O
case	O
KW_INT	int
:	O
case	O
KW_LONG	int
:	O
case	O
KW_FLOAT	int
:	O
case	O
KW_DOUBLE	int
:	O
case	O
KW_SIGNED	int
:	O
case	O
KW_UNSIGNED	int
:	O
a	pointer
=	O
lex_type_name	int
;	O
break	O
;	O
case	O
KW_STRUCT	int
:	O
case	O
KW_UNION	int
:	O
case	O
KW_ENUM	int
:	O
a	pointer
=	O
lex_struct	int
;	O
engine	pointer
->	O
struct_type	int
=	O
symbol	struct
->	O
kw_idx	int
;	O
break	O
;	O
case	O
KW_CONST	int
:	O
case	O
KW_VOLATILE	int
:	O
a	pointer
=	O
lex_const	int
;	O
break	O
;	O
case	O
-	O
1	int
:	O
if	O
(	O
symbol	struct
!=	O
NULL	O
&&	O
symbol	struct
->	O
is_typedef	int
&&	O
!	O
engine	pointer
->	O
last_was_struct	int
)	O
a	pointer
=	O
lex_type_name	int
;	O
else	O
a	pointer
=	O
lex_identifier	int
;	O
if	O
(	O
engine	pointer
->	O
last_was_struct	int
)	O
{	O
free	function
(	O
engine	pointer
->	O
tag	pointer
)	O
;	O
engine	pointer
->	O
tag	pointer
=	O
xstrndup	function
(	O
token	pointer
->	O
text	pointer
,	O
token	pointer
->	O
len	long
)	O
;	O
}	O
else	O
{	O
free	function
(	O
engine	pointer
->	O
last_id	pointer
)	O
;	O
engine	pointer
->	O
last_id	pointer
=	O
xstrndup	function
(	O
token	pointer
->	O
text	pointer
,	O
token	pointer
->	O
len	long
)	O
;	O
}	O
break	O
;	O
default	O
:	O
a	pointer
=	O
lex_other	int
;	O
break	O
;	O
}	O
}	O
break	O
;	O
default	O
:	O
a	pointer
=	O
lex_other	int
;	O
break	O
;	O
}	O
engine	pointer
->	O
last_was_struct	int
=	O
(	O
a	pointer
==	O
lex_struct	int
)	O
;	O
assert	O
(	O
engine	pointer
->	O
stack_cnt	int
>	O
0	int
)	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
int	O
s	pointer
=	O
engine	pointer
->	O
stack	array
[	O
engine	pointer
->	O
stack_cnt	int
-	O
1	int
]	O
;	O
int	O
action	int
=	O
action_table	array
[	O
s	pointer
]	O
[	O
a	pointer
]	O
;	O
if	O
(	O
debug_parser	int
)	O
printf	function
(	O
"%d: "	pointer
,	O
s	pointer
)	O
;	O
if	O
(	O
action	int
>=	O
s0	int
&&	O
action	int
<	O
s0	int
+	O
n_states	int
)	O
{	O
if	O
(	O
debug_parser	int
)	O
printf	function
(	O
"s%d"	pointer
,	O
action	int
-	O
s0	int
)	O
;	O
if	O
(	O
engine	pointer
->	O
stack_cnt	int
>=	O
STACK_HEIGHT	int
)	O
return	O
0	int
;	O
engine	pointer
->	O
stack	array
[	O
engine	pointer
->	O
stack_cnt	int
++	O
]	O
=	O
action	int
-	O
s0	int
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
action	int
==	O
acc	int
)	O
{	O
if	O
(	O
debug_parser	int
)	O
printf	function
(	O
"accepted!"	pointer
)	O
;	O
return	O
1	int
;	O
}	O
else	O
if	O
(	O
action	int
==	O
err	int
)	O
{	O
if	O
(	O
debug_parser	int
)	O
printf	function
(	O
"error!"	pointer
)	O
;	O
return	O
0	int
;	O
}	O
else	O
{	O
int	O
reduction	int
,	O
n_pop	int
,	O
A	int
;	O
int	O
sprime	int
;	O
reduction	int
=	O
action	int
-	O
r1	int
;	O
assert	O
(	O
reduction	int
>=	O
0	int
&&	O
reduction	int
<	O
n_reductions	int
)	O
;	O
if	O
(	O
debug_parser	int
)	O
printf	function
(	O
"r%d,"	pointer
,	O
reduction	int
)	O
;	O
n_pop	int
=	O
reduce_table	array
[	O
reduction	int
]	O
[	O
0	int
]	O
;	O
A	int
=	O
reduce_table	array
[	O
reduction	int
]	O
[	O
1	int
]	O
;	O
engine	pointer
->	O
stack_cnt	int
-=	O
n_pop	int
;	O
assert	O
(	O
engine	pointer
->	O
stack_cnt	int
>	O
0	int
)	O
;	O
sprime	int
=	O
engine	pointer
->	O
stack	array
[	O
engine	pointer
->	O
stack_cnt	int
-	O
1	int
]	O
;	O
if	O
(	O
debug_parser	int
)	O
printf	function
(	O
"g%d "	pointer
,	O
goto_table	array
[	O
sprime	int
]	O
[	O
A	int
]	O
)	O
;	O
engine	pointer
->	O
stack	array
[	O
engine	pointer
->	O
stack_cnt	int
++	O
]	O
=	O
goto_table	array
[	O
sprime	int
]	O
[	O
A	int
]	O
;	O
switch	O
(	O
reduce_table	array
[	O
reduction	int
]	O
[	O
2	int
]	O
)	O
{	O
case	O
reduce_array	int
:	O
if	O
(	O
engine	pointer
->	O
type	int
==	O
TYPE_BASIC	int
)	O
engine	pointer
->	O
type	int
=	O
TYPE_ARRAY	int
;	O
break	O
;	O
case	O
reduce_declaration	int
:	O
engine	pointer
->	O
typedefing	int
=	O
0	int
;	O
engine	pointer
->	O
type	int
=	O
engine	pointer
->	O
last_type	enum
=	O
TYPE_BASIC	int
;	O
break	O
;	O
case	O
reduce_declarator	int
:	O
assert	O
(	O
engine	pointer
->	O
save_id	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
engine	pointer
->	O
typedefing	int
)	O
{	O
symbol_find	function
(	O
engine	pointer
->	O
save_id	pointer
,	O
strlen	function
(	O
engine	pointer
->	O
save_id	pointer
)	O
,	O
1	int
)	O
->	O
is_typedef	int
=	O
1	int
;	O
emitf	function
(	O
"@cindex "	pointer
TYPEDEF_STYLE	pointer
"{%s} type\n"	pointer
,	O
engine	pointer
->	O
save_id	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
engine	pointer
->	O
type	int
==	O
TYPE_BASIC	int
||	O
engine	pointer
->	O
type	int
==	O
TYPE_POINTER	int
)	O
emitf	function
(	O
"@cindex @i{%s} %s\n"	pointer
,	O
engine	pointer
->	O
save_id	pointer
,	O
_	O
(	O
"variable"	pointer
)	O
)	O
;	O
else	O
if	O
(	O
engine	pointer
->	O
type	int
==	O
TYPE_ARRAY	int
)	O
emitf	function
(	O
"@cindex @i{%s} %s\n"	pointer
,	O
engine	pointer
->	O
save_id	pointer
,	O
_	O
(	O
"array"	pointer
)	O
)	O
;	O
}	O
engine	pointer
->	O
last_type	enum
=	O
engine	pointer
->	O
type	int
;	O
engine	pointer
->	O
type	int
=	O
TYPE_BASIC	int
;	O
break	O
;	O
case	O
reduce_function	int
:	O
if	O
(	O
engine	pointer
->	O
type	int
==	O
TYPE_BASIC	int
)	O
engine	pointer
->	O
type	int
=	O
TYPE_FUNCTION	int
;	O
break	O
;	O
case	O
reduce_function_definition	int
:	O
if	O
(	O
debug_parser	int
)	O
printf	function
(	O
"Reducing function!\n"	pointer
)	O
;	O
if	O
(	O
engine	pointer
->	O
last_type	enum
==	O
TYPE_FUNCTION	int
)	O
emitf	function
(	O
"@cindex @i{%s} %s\n"	pointer
,	O
engine	pointer
->	O
save_id	pointer
,	O
_	O
(	O
"function"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
reduce_identifier	int
:	O
free	function
(	O
engine	pointer
->	O
save_id	pointer
)	O
;	O
engine	pointer
->	O
save_id	pointer
=	O
engine	pointer
->	O
last_id	pointer
;	O
engine	pointer
->	O
last_id	pointer
=	O
NULL	O
;	O
break	O
;	O
case	O
reduce_null	int
:	O
break	O
;	O
case	O
reduce_pointer	int
:	O
if	O
(	O
engine	pointer
->	O
type	int
==	O
TYPE_BASIC	int
)	O
engine	pointer
->	O
type	int
=	O
TYPE_POINTER	int
;	O
break	O
;	O
case	O
reduce_struct_definition	int
:	O
{	O
const	O
char	O
*	O
struct_name	pointer
;	O
if	O
(	O
engine	pointer
->	O
struct_type	int
==	O
KW_STRUCT	int
)	O
struct_name	pointer
=	O
"structure"	pointer
;	O
else	O
if	O
(	O
engine	pointer
->	O
struct_type	int
==	O
KW_UNION	int
)	O
struct_name	pointer
=	O
"union"	pointer
;	O
else	O
{	O
assert	O
(	O
engine	pointer
->	O
struct_type	int
==	O
KW_ENUM	int
)	O
;	O
struct_name	pointer
=	O
"enumeration"	pointer
;	O
}	O
assert	O
(	O
engine	pointer
->	O
tag	pointer
!=	O
NULL	O
)	O
;	O
emitf	function
(	O
"@cindex @i{%s} %s\n"	pointer
,	O
engine	pointer
->	O
tag	pointer
,	O
struct_name	pointer
)	O
;	O
}	O
break	O
;	O
case	O
reduce_typedef	int
:	O
engine	pointer
->	O
typedefing	int
=	O
1	int
;	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
}	O
static	O
void	O
declaration_engine	function
(	O
const	O
char	O
*	O
cp	pointer
,	O
int	O
indent	pointer
)	O
{	O
static	O
struct	O
engine_state	struct
s	pointer
;	O
struct	O
token	pointer
token	pointer
;	O
if	O
(	O
cp	pointer
==	O
NULL	O
)	O
{	O
if	O
(	O
debug_parser	int
)	O
printf	function
(	O
"\n\n--%s:%d--\n"	pointer
,	O
in_file	pointer
->	O
name	pointer
,	O
in_file	pointer
->	O
line	int
)	O
;	O
init_engine_state	function
(	O
&	O
s	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
cp	pointer
==	O
'#'	O
)	O
return	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
cp	pointer
=	O
token_get	function
(	O
cp	pointer
,	O
&	O
token	pointer
)	O
;	O
if	O
(	O
token	pointer
.	O
type	int
==	O
'\0'	O
||	O
token	pointer
.	O
type	int
==	O
TOKEN_COND_NEWLINE	int
||	O
token	pointer
.	O
type	int
==	O
TOKEN_INC_INDENT	int
||	O
token	pointer
.	O
type	int
==	O
TOKEN_DEC_INDENT	int
)	O
return	O
;	O
if	O
(	O
token_space_p	function
(	O
&	O
token	pointer
)	O
)	O
{	O
if	O
(	O
token	pointer
.	O
type	int
==	O
'\n'	O
&&	O
s	pointer
.	O
state	enum
==	O
STATE_PARSE_ERROR	int
)	O
init_engine_state	function
(	O
&	O
s	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
debug_parser	int
)	O
printf	function
(	O
"\n\"%.*s\": "	pointer
,	O
(	O
int	O
)	O
token	pointer
.	O
len	long
,	O
token	pointer
.	O
text	pointer
)	O
;	O
switch	O
(	O
s	pointer
.	O
state	enum
)	O
{	O
case	O
STATE_START	int
:	O
assert	O
(	O
segment_cur	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
indent	pointer
!=	O
0	int
||	O
segment_inside_indentation	function
(	O
segment_cur	pointer
)	O
)	O
{	O
s	pointer
.	O
state	enum
=	O
STATE_PARSE_ERROR	int
;	O
break	O
;	O
}	O
s	pointer
.	O
state	enum
=	O
STATE_PARSE	int
;	O
case	O
STATE_PARSE	int
:	O
if	O
(	O
lr_engine	function
(	O
&	O
s	pointer
,	O
&	O
token	pointer
)	O
==	O
0	int
)	O
s	pointer
.	O
state	enum
=	O
STATE_PARSE_ERROR	int
;	O
break	O
;	O
case	O
STATE_PARSE_ERROR	int
:	O
break	O
;	O
default	O
:	O
assert	O
(	O
0	int
)	O
;	O
}	O
}	O
}	O
static	O
const	O
char	O
*	O
help	array
[	O
]	O
=	O
{	O
N_	O
(	O
"texiweb, a program for translating TexiWEB documents\n"	pointer
)	O
,	O
N_	O
(	O
"Usage: %s [OPTION]... COMMAND\n"	pointer
)	O
,	O
N_	O
(	O
"\nCommands:\n"	pointer
)	O
,	O
N_	O
(	O
"  weave INFILE OUTFILE     translate TexiWEB to Texinfo\n"	pointer
)	O
,	O
N_	O
(	O
"  tangle INFILE [OUTFILE]  translate TexiWEB to C\n"	pointer
)	O
,	O
N_	O
(	O
"\nOptions:\n"	pointer
)	O
,	O
N_	O
(	O
"  -l, --no-line          (tangle) emit #line directives\n"	pointer
)	O
,	O
N_	O
(	O
"  -d, --debug            enables code for debugging texiweb\n"	pointer
)	O
,	O
N_	O
(	O
"  -f, --filenames        (tangle) only print list of .c files in .w\n"	pointer
)	O
,	O
N_	O
(	O
"  -u, --unused           (tangle) also print list of unused sections\n"	pointer
)	O
,	O
N_	O
(	O
"  -c, --catalogues       (weave) also print unused catalogues\n"	pointer
)	O
,	O
N_	O
(	O
"  -a, --unanswered       (weave) also list exercises without answers\n"	pointer
)	O
,	O
N_	O
(	O
"  -n, --nonzero-indent   (weave) warn for indent adjust between blocks\n"	pointer
)	O
,	O
N_	O
(	O
"  -h, --help             print this help, then exit\n"	pointer
)	O
,	O
N_	O
(	O
"  -v, --version          show version, then exit\n"	pointer
)	O
,	O
N_	O
(	O
"\nReport bugs to Ben Pfaff <blp@gnu.org>.\n"	pointer
)	O
,	O
NULL	O
,	O
}	O
;	O
static	O
const	O
char	O
version	array
[	O
]	O
=	O
N_	O
(	O
"texiweb 0.9.0\n"	pointer
"Copyright (C) 2000 Free Software Foundation, Inc.\n"	pointer
"texiweb comes with NO WARRANTY, to the extent permitted by law,\n"	pointer
"not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"	pointer
"You may redistribute copies of texiweb under the terms of the GNU\n"	pointer
"General Public License.  For more information about these\n"	pointer
"matters, see the file named COPYING.\n"	pointer
"Written by Ben Pfaff <blp@gnu.org>.\n"	pointer
)	O
;	O
static	O
void	O
usage	function
(	O
int	O
exit_code	int
)	O
;	O
static	O
void	O
option	function
(	O
int	O
op	int
)	O
;	O
static	O
void	O
parse_cmd_line	function
(	O
int	O
argc	int
,	O
char	O
*	O
*	O
argv	pointer
)	O
{	O
int	O
options_over	int
;	O
short_pgm_name	pointer
=	O
strrchr	function
(	O
argv	pointer
[	O
0	int
]	O
,	O
'/'	O
)	O
;	O
if	O
(	O
short_pgm_name	pointer
!=	O
NULL	O
)	O
short_pgm_name	pointer
++	O
;	O
else	O
short_pgm_name	pointer
=	O
argv	pointer
[	O
0	int
]	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
options_over	int
=	O
0	int
;	O
for	O
(	O
;	O
;	O
)	O
{	O
argc	int
--	O
;	O
argv	pointer
++	O
;	O
if	O
(	O
argc	int
==	O
0	int
)	O
{	O
if	O
(	O
operation	enum
==	O
OP_NONE	int
||	O
(	O
operation	enum
==	O
OP_TANGLE	int
&&	O
in_file_name	pointer
==	O
NULL	O
)	O
||	O
(	O
operation	enum
==	O
OP_WEAVE	int
&&	O
out_file_name	pointer
==	O
NULL	O
)	O
)	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
else	O
break	O
;	O
}	O
if	O
(	O
!	O
options_over	int
&&	O
*	O
*	O
argv	pointer
==	O
'-'	O
)	O
{	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
argv	pointer
,	O
"--"	pointer
)	O
)	O
options_over	int
=	O
1	int
;	O
else	O
if	O
(	O
(	O
*	O
argv	pointer
)	O
[	O
1	int
]	O
==	O
'-'	O
)	O
{	O
struct	O
long_option	struct
{	O
const	O
char	O
*	O
name	pointer
;	O
int	O
equiv	int
;	O
}	O
;	O
static	O
const	O
struct	O
long_option	struct
lops	array
[	O
]	O
=	O
{	O
{	O
"debug"	pointer
,	O
'd'	O
}	O
,	O
{	O
"filenames"	pointer
,	O
'f'	O
}	O
,	O
{	O
"no-line"	pointer
,	O
'l'	O
}	O
,	O
{	O
"unused"	pointer
,	O
'u'	O
}	O
,	O
{	O
"unanswered"	pointer
,	O
'a'	O
}	O
,	O
{	O
"help"	pointer
,	O
'h'	O
}	O
,	O
{	O
"version"	pointer
,	O
'v'	O
}	O
,	O
}	O
;	O
const	O
struct	O
long_option	struct
*	O
op	int
;	O
for	O
(	O
op	int
=	O
lops	array
;	O
;	O
op	int
++	O
)	O
if	O
(	O
op	int
>=	O
lops	array
+	O
sizeof	O
lops	array
/	O
sizeof	O
*	O
lops	array
)	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
*	O
argv	pointer
+	O
2	int
,	O
op	int
->	O
name	pointer
)	O
)	O
{	O
option	function
(	O
op	int
->	O
equiv	int
)	O
;	O
break	O
;	O
}	O
}	O
else	O
{	O
for	O
(	O
(	O
*	O
argv	pointer
)	O
++	O
;	O
*	O
*	O
argv	pointer
;	O
(	O
*	O
argv	pointer
)	O
++	O
)	O
option	function
(	O
*	O
*	O
argv	pointer
)	O
;	O
}	O
}	O
else	O
if	O
(	O
operation	enum
==	O
OP_NONE	int
)	O
{	O
const	O
char	O
*	O
cmd	pointer
=	O
*	O
argv	pointer
;	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"weave"	pointer
)	O
)	O
operation	enum
=	O
OP_WEAVE	int
;	O
else	O
if	O
(	O
!	O
strcmp	function
(	O
cmd	pointer
,	O
"tangle"	pointer
)	O
)	O
operation	enum
=	O
OP_TANGLE	int
;	O
else	O
error	function
(	O
FTL	int
,	O
_	O
(	O
"Invalid command %s"	pointer
)	O
,	O
cmd	pointer
)	O
;	O
}	O
else	O
if	O
(	O
in_file_name	pointer
==	O
NULL	O
)	O
in_file_name	pointer
=	O
*	O
argv	pointer
;	O
else	O
if	O
(	O
out_file_name	pointer
==	O
NULL	O
)	O
out_file_name	pointer
=	O
*	O
argv	pointer
;	O
else	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
if	O
(	O
operation	enum
==	O
OP_WEAVE	int
)	O
{	O
out_file	pointer
=	O
fopen	function
(	O
out_file_name	pointer
,	O
"w"	pointer
)	O
;	O
if	O
(	O
out_file	pointer
==	O
NULL	O
)	O
error	function
(	O
FTL	int
,	O
_	O
(	O
"Opening %s for writing: %s"	pointer
)	O
,	O
out_file_name	pointer
,	O
strerror	function
(	O
errno	O
)	O
)	O
;	O
}	O
}	O
static	O
void	O
usage	function
(	O
int	O
exit_code	int
)	O
{	O
const	O
char	O
*	O
*	O
p	pointer
;	O
for	O
(	O
p	pointer
=	O
help	array
;	O
*	O
p	pointer
!=	O
NULL	O
;	O
p	pointer
++	O
)	O
printf	function
(	O
gettext	O
(	O
*	O
p	pointer
)	O
,	O
short_pgm_name	pointer
)	O
;	O
exit	function
(	O
exit_code	int
)	O
;	O
}	O
static	O
void	O
option	function
(	O
int	O
op	int
)	O
{	O
switch	O
(	O
op	int
)	O
{	O
case	O
'a'	O
:	O
print_unanswered	int
=	O
1	int
;	O
break	O
;	O
case	O
'd'	O
:	O
debug_parser	int
=	O
1	int
;	O
break	O
;	O
case	O
'f'	O
:	O
filenames_only	int
=	O
1	int
;	O
break	O
;	O
case	O
'l'	O
:	O
opt_line	int
=	O
1	int
;	O
break	O
;	O
case	O
'u'	O
:	O
print_unused	int
=	O
1	int
;	O
break	O
;	O
case	O
'c'	O
:	O
print_catalogues	int
=	O
1	int
;	O
break	O
;	O
case	O
'h'	O
:	O
usage	function
(	O
EXIT_SUCCESS	int
)	O
;	O
break	O
;	O
case	O
'v'	O
:	O
fputs	function
(	O
version	array
,	O
stdout	pointer
)	O
;	O
exit	function
(	O
EXIT_SUCCESS	int
)	O
;	O
break	O
;	O
default	O
:	O
usage	function
(	O
EXIT_FAILURE	int
)	O
;	O
break	O
;	O
}	O
}	O
static	O
void	O
trim_whitespace	function
(	O
char	O
*	O
*	O
bp	pointer
,	O
char	O
*	O
*	O
ep	pointer
)	O
{	O
while	O
(	O
*	O
bp	pointer
<	O
*	O
ep	pointer
&&	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
*	O
bp	pointer
)	O
)	O
(	O
*	O
bp	pointer
)	O
++	O
;	O
while	O
(	O
*	O
ep	pointer
>	O
*	O
bp	pointer
&&	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
(	O
*	O
ep	pointer
)	O
[	O
-	O
1	int
]	O
)	O
)	O
(	O
*	O
ep	pointer
)	O
--	O
;	O
}	O
static	O
int	O
find_argument	function
(	O
char	O
*	O
line	int
,	O
char	O
*	O
*	O
bp	pointer
,	O
char	O
*	O
*	O
ep	pointer
)	O
{	O
*	O
bp	pointer
=	O
line	int
=	O
strpbrk	function
(	O
line	int
,	O
" \t\r\n"	pointer
)	O
;	O
if	O
(	O
line	int
==	O
NULL	O
)	O
goto	O
lossage	O
;	O
*	O
ep	pointer
=	O
strchr	function
(	O
*	O
bp	pointer
,	O
'\0'	O
)	O
;	O
trim_whitespace	function
(	O
bp	pointer
,	O
ep	pointer
)	O
;	O
if	O
(	O
*	O
bp	pointer
!=	O
*	O
ep	pointer
)	O
return	O
1	int
;	O
lossage	O
:	O
error	function
(	O
SRC	int
,	O
_	O
(	O
"Command missing argument."	pointer
)	O
)	O
;	O
return	O
0	int
;	O
}	O
static	O
int	O
find_optional_argument	function
(	O
char	O
*	O
line	int
,	O
char	O
*	O
*	O
bp	pointer
,	O
char	O
*	O
*	O
ep	pointer
)	O
{	O
*	O
bp	pointer
=	O
line	int
=	O
strpbrk	function
(	O
line	int
,	O
" \t\r\n"	pointer
)	O
;	O
if	O
(	O
line	int
==	O
NULL	O
)	O
return	O
0	int
;	O
*	O
ep	pointer
=	O
strchr	function
(	O
*	O
bp	pointer
,	O
'\0'	O
)	O
;	O
trim_whitespace	function
(	O
bp	pointer
,	O
ep	pointer
)	O
;	O
return	O
*	O
bp	pointer
!=	O
*	O
ep	pointer
;	O
}	O
static	O
int	O
empty_string	function
(	O
const	O
char	O
*	O
string	pointer
)	O
{	O
for	O
(	O
;	O
*	O
string	pointer
;	O
string	pointer
++	O
)	O
if	O
(	O
!	O
isspace	function
(	O
(	O
unsigned	O
char	O
)	O
*	O
string	pointer
)	O
)	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
error	function
(	O
int	O
flags	int
,	O
const	O
char	O
*	O
message	pointer
,	O
...	O
)	O
{	O
va_list	array
args	array
;	O
if	O
(	O
flags	int
&	O
SRC	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:%d: "	pointer
,	O
in_file	pointer
->	O
name	pointer
,	O
in_file	pointer
->	O
line	int
)	O
;	O
else	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: "	pointer
,	O
short_pgm_name	pointer
)	O
;	O
va_start	O
(	O
args	array
,	O
message	pointer
)	O
;	O
vfprintf	function
(	O
stderr	pointer
,	O
message	pointer
,	O
args	array
)	O
;	O
va_end	O
(	O
args	array
)	O
;	O
putc	function
(	O
'\n'	O
,	O
stderr	pointer
)	O
;	O
if	O
(	O
flags	int
&	O
FTL	int
)	O
exit	function
(	O
EXIT_FAILURE	int
)	O
;	O
}	O
static	O
void	O
*	O
xmalloc	function
(	O
size_t	long
amt	long
)	O
{	O
void	O
*	O
block	pointer
;	O
assert	O
(	O
amt	long
!=	O
0	int
)	O
;	O
block	pointer
=	O
malloc	function
(	O
amt	long
)	O
;	O
if	O
(	O
block	pointer
==	O
NULL	O
)	O
error	function
(	O
FTL	int
,	O
_	O
(	O
"virtual memory exhausted"	pointer
)	O
)	O
;	O
return	O
block	pointer
;	O
}	O
static	O
void	O
*	O
xrealloc	function
(	O
void	O
*	O
block	pointer
,	O
size_t	long
size	long
)	O
{	O
if	O
(	O
size	long
==	O
0	int
)	O
{	O
if	O
(	O
block	pointer
!=	O
NULL	O
)	O
free	function
(	O
block	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
block	pointer
!=	O
NULL	O
)	O
block	pointer
=	O
realloc	function
(	O
block	pointer
,	O
size	long
)	O
;	O
else	O
block	pointer
=	O
malloc	function
(	O
size	long
)	O
;	O
if	O
(	O
block	pointer
==	O
NULL	O
)	O
error	function
(	O
FTL	int
,	O
_	O
(	O
"virtual memory exhausted"	pointer
)	O
)	O
;	O
return	O
block	pointer
;	O
}	O
static	O
char	O
*	O
xstrndup	function
(	O
const	O
char	O
*	O
buf	pointer
,	O
size_t	long
len	long
)	O
{	O
char	O
*	O
s	pointer
=	O
xmalloc	function
(	O
len	long
+	O
1	int
)	O
;	O
memcpy	function
(	O
s	pointer
,	O
buf	pointer
,	O
len	long
)	O
;	O
s	pointer
[	O
len	long
]	O
=	O
'\0'	O
;	O
return	O
s	pointer
;	O
}	O
static	O
char	O
*	O
xstrdup	function
(	O
const	O
char	O
*	O
string	pointer
)	O
{	O
char	O
*	O
new	pointer
=	O
xmalloc	function
(	O
strlen	function
(	O
string	pointer
)	O
+	O
1	int
)	O
;	O
strcpy	function
(	O
new	pointer
,	O
string	pointer
)	O
;	O
return	O
new	pointer
;	O
}	O
