struct	O
lookup_cache	struct
{	O
struct	O
cacheq_hdr	O
hdr	struct
;	O
char	O
dir_cache_fh	array
[	O
NFS3_FHSIZE	int
]	O
;	O
size_t	long
dir_cache_len	long
;	O
struct	O
node	O
*	O
np	pointer
;	O
char	O
name	pointer
[	O
CACHE_NAME_LEN	int
]	O
;	O
size_t	long
name_len	long
;	O
time_t	long
cache_stamp	long
;	O
int	O
stati	int
;	O
}	O
;	O
static	O
struct	O
cacheq	O
lookup_cache	struct
=	O
{	O
sizeof	O
(	O
struct	O
lookup_cache	struct
)	O
}	O
;	O
static	O
pthread_spinlock_t	int
cache_lock	int
=	O
PTHREAD_SPINLOCK_INITIALIZER	O
;	O
static	O
struct	O
stats	struct
{	O
long	O
pos_hits	long
;	O
long	O
neg_hits	long
;	O
long	O
miss	long
;	O
long	O
fetch_errors	long
;	O
}	O
statistics	struct
;	O
struct	O
stats	struct
partial_stats	array
[	O
NPARTIALS	O
]	O
;	O
static	O
struct	O
lookup_cache	struct
*	O
find_cache	function
(	O
char	O
*	O
dir	pointer
,	O
size_t	long
len	long
,	O
const	O
char	O
*	O
name	pointer
,	O
size_t	long
name_len	long
)	O
{	O
struct	O
lookup_cache	struct
*	O
c	pointer
;	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
,	O
c	pointer
=	O
lookup_cache	struct
.	O
mru	O
;	O
c	pointer
&&	O
c	pointer
->	O
name_len	long
;	O
c	pointer
=	O
c	pointer
->	O
hdr	struct
.	O
next	pointer
,	O
i	int
++	O
)	O
if	O
(	O
c	pointer
->	O
name_len	long
==	O
name_len	long
&&	O
c	pointer
->	O
dir_cache_len	long
==	O
len	long
&&	O
c	pointer
->	O
name	pointer
[	O
0	int
]	O
==	O
name	pointer
[	O
0	int
]	O
&&	O
memcmp	O
(	O
c	pointer
->	O
dir_cache_fh	array
,	O
dir	pointer
,	O
len	long
)	O
==	O
0	int
&&	O
strcmp	O
(	O
c	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
c	pointer
->	O
stati	int
=	O
i	int
/	O
PARTIAL_THRESH	int
;	O
return	O
c	pointer
;	O
}	O
return	O
0	int
;	O
}	O
void	O
enter_lookup_cache	function
(	O
char	O
*	O
dir	pointer
,	O
size_t	long
len	long
,	O
struct	O
node	O
*	O
np	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
lookup_cache	struct
*	O
c	pointer
;	O
size_t	long
name_len	long
=	O
strlen	O
(	O
name	pointer
)	O
;	O
if	O
(	O
name_len	long
>	O
CACHE_NAME_LEN	int
-	O
1	int
)	O
return	O
;	O
pthread_spin_lock	function
(	O
&	O
cache_lock	int
)	O
;	O
if	O
(	O
lookup_cache	struct
.	O
length	O
==	O
0	int
)	O
cacheq_set_length	function
(	O
&	O
lookup_cache	struct
,	O
MAXCACHE	int
)	O
;	O
c	pointer
=	O
find_cache	function
(	O
dir	pointer
,	O
len	long
,	O
name	pointer
,	O
name_len	long
)	O
?	O
:	O
lookup_cache	struct
.	O
lru	O
;	O
memcpy	O
(	O
c	pointer
->	O
dir_cache_fh	array
,	O
dir	pointer
,	O
len	long
)	O
;	O
c	pointer
->	O
dir_cache_len	long
=	O
len	long
;	O
if	O
(	O
c	pointer
->	O
np	pointer
)	O
netfs_nrele	function
(	O
c	pointer
->	O
np	pointer
)	O
;	O
c	pointer
->	O
np	pointer
=	O
np	pointer
;	O
if	O
(	O
c	pointer
->	O
np	pointer
)	O
netfs_nref	function
(	O
c	pointer
->	O
np	pointer
)	O
;	O
strcpy	O
(	O
c	pointer
->	O
name	pointer
,	O
name	pointer
)	O
;	O
c	pointer
->	O
name_len	long
=	O
name_len	long
;	O
c	pointer
->	O
cache_stamp	long
=	O
mapped_time	pointer
->	O
seconds	O
;	O
cacheq_make_mru	function
(	O
&	O
lookup_cache	struct
,	O
c	pointer
)	O
;	O
pthread_spin_unlock	function
(	O
&	O
cache_lock	int
)	O
;	O
}	O
void	O
purge_lookup_cache	function
(	O
struct	O
node	O
*	O
dp	pointer
,	O
char	O
*	O
name	pointer
,	O
size_t	long
namelen	long
)	O
{	O
struct	O
lookup_cache	struct
*	O
c	pointer
,	O
*	O
next	pointer
;	O
pthread_spin_lock	function
(	O
&	O
cache_lock	int
)	O
;	O
for	O
(	O
c	pointer
=	O
lookup_cache	struct
.	O
mru	O
;	O
c	pointer
;	O
c	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
c	pointer
->	O
hdr	struct
.	O
next	pointer
;	O
if	O
(	O
c	pointer
->	O
name_len	long
==	O
namelen	long
&&	O
c	pointer
->	O
dir_cache_len	long
==	O
dp	pointer
->	O
nn	O
->	O
handle	struct
.	O
size	long
&&	O
memcmp	O
(	O
c	pointer
->	O
dir_cache_fh	array
,	O
dp	pointer
->	O
nn	O
->	O
handle	struct
.	O
data	array
,	O
c	pointer
->	O
dir_cache_len	long
)	O
==	O
0	int
&&	O
strcmp	O
(	O
c	pointer
->	O
name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
{	O
if	O
(	O
c	pointer
->	O
np	pointer
)	O
netfs_nrele	function
(	O
c	pointer
->	O
np	pointer
)	O
;	O
c	pointer
->	O
name_len	long
=	O
0	int
;	O
c	pointer
->	O
np	pointer
=	O
0	int
;	O
cacheq_make_lru	function
(	O
&	O
lookup_cache	struct
,	O
c	pointer
)	O
;	O
}	O
}	O
pthread_spin_unlock	function
(	O
&	O
cache_lock	int
)	O
;	O
}	O
void	O
purge_lookup_cache_node	function
(	O
struct	O
node	O
*	O
np	pointer
)	O
{	O
struct	O
lookup_cache	struct
*	O
c	pointer
,	O
*	O
next	pointer
;	O
pthread_spin_lock	function
(	O
&	O
cache_lock	int
)	O
;	O
for	O
(	O
c	pointer
=	O
lookup_cache	struct
.	O
mru	O
;	O
c	pointer
;	O
c	pointer
=	O
next	pointer
)	O
{	O
next	pointer
=	O
c	pointer
->	O
hdr	struct
.	O
next	pointer
;	O
if	O
(	O
c	pointer
->	O
np	pointer
==	O
np	pointer
)	O
{	O
netfs_nrele	function
(	O
c	pointer
->	O
np	pointer
)	O
;	O
c	pointer
->	O
name_len	long
=	O
0	int
;	O
c	pointer
->	O
np	pointer
=	O
0	int
;	O
cacheq_make_lru	function
(	O
&	O
lookup_cache	struct
,	O
c	pointer
)	O
;	O
}	O
}	O
pthread_spin_unlock	function
(	O
&	O
cache_lock	int
)	O
;	O
}	O
void	O
register_neg_hit	function
(	O
int	O
n	int
)	O
{	O
int	O
i	int
;	O
statistics	struct
.	O
neg_hits	long
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
partial_stats	array
[	O
i	int
]	O
.	O
miss	long
++	O
;	O
for	O
(	O
;	O
i	int
<	O
NPARTIALS	O
;	O
i	int
++	O
)	O
partial_stats	array
[	O
i	int
]	O
.	O
neg_hits	long
++	O
;	O
}	O
void	O
register_pos_hit	function
(	O
int	O
n	int
)	O
{	O
int	O
i	int
;	O
statistics	struct
.	O
pos_hits	long
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	int
;	O
i	int
++	O
)	O
partial_stats	array
[	O
i	int
]	O
.	O
miss	long
++	O
;	O
for	O
(	O
;	O
i	int
<	O
NPARTIALS	O
;	O
i	int
++	O
)	O
partial_stats	array
[	O
i	int
]	O
.	O
pos_hits	long
++	O
;	O
}	O
void	O
register_miss	function
(	O
)	O
{	O
int	O
i	int
;	O
statistics	struct
.	O
miss	long
++	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NPARTIALS	O
;	O
i	int
++	O
)	O
partial_stats	array
[	O
i	int
]	O
.	O
miss	long
++	O
;	O
}	O
struct	O
node	O
*	O
check_lookup_cache	function
(	O
struct	O
node	O
*	O
dir	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
struct	O
lookup_cache	struct
*	O
c	pointer
;	O
pthread_spin_lock	function
(	O
&	O
cache_lock	int
)	O
;	O
c	pointer
=	O
find_cache	function
(	O
dir	pointer
->	O
nn	O
->	O
handle	struct
.	O
data	array
,	O
dir	pointer
->	O
nn	O
->	O
handle	struct
.	O
size	long
,	O
name	pointer
,	O
strlen	O
(	O
name	pointer
)	O
)	O
;	O
if	O
(	O
c	pointer
)	O
{	O
int	O
timeout	int
=	O
c	pointer
->	O
np	pointer
?	O
name_cache_timeout	int
:	O
name_cache_neg_timeout	int
;	O
if	O
(	O
mapped_time	pointer
->	O
seconds	O
-	O
c	pointer
->	O
cache_stamp	long
>=	O
timeout	int
)	O
{	O
register_neg_hit	function
(	O
c	pointer
->	O
stati	int
)	O
;	O
if	O
(	O
c	pointer
->	O
np	pointer
)	O
netfs_nrele	function
(	O
c	pointer
->	O
np	pointer
)	O
;	O
c	pointer
->	O
name_len	long
=	O
0	int
;	O
c	pointer
->	O
np	pointer
=	O
0	int
;	O
cacheq_make_lru	function
(	O
&	O
lookup_cache	struct
,	O
c	pointer
)	O
;	O
pthread_spin_unlock	function
(	O
&	O
cache_lock	int
)	O
;	O
return	O
0	int
;	O
}	O
cacheq_make_mru	function
(	O
&	O
lookup_cache	struct
,	O
c	pointer
)	O
;	O
if	O
(	O
c	pointer
->	O
np	pointer
==	O
0	int
)	O
{	O
register_neg_hit	function
(	O
c	pointer
->	O
stati	int
)	O
;	O
pthread_spin_unlock	function
(	O
&	O
cache_lock	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
return	O
(	O
struct	O
node	O
*	O
)	O
-	O
1	int
;	O
}	O
else	O
{	O
struct	O
node	O
*	O
np	pointer
;	O
np	pointer
=	O
c	pointer
->	O
np	pointer
;	O
netfs_nref	function
(	O
np	pointer
)	O
;	O
register_pos_hit	function
(	O
c	pointer
->	O
stati	int
)	O
;	O
pthread_spin_unlock	function
(	O
&	O
cache_lock	int
)	O
;	O
pthread_mutex_unlock	function
(	O
&	O
dir	pointer
->	O
lock	O
)	O
;	O
pthread_mutex_lock	function
(	O
&	O
np	pointer
->	O
lock	O
)	O
;	O
return	O
np	pointer
;	O
}	O
}	O
register_miss	function
(	O
)	O
;	O
pthread_spin_unlock	function
(	O
&	O
cache_lock	int
)	O
;	O
return	O
0	int
;	O
}	O
