const	O
int	O
_pl_f_fig_line_style	array
[	O
PL_NUM_LINE_TYPES	int
]	O
=	O
{	O
FIG_L_SOLID	int
,	O
FIG_L_DOTTED	int
,	O
FIG_L_DASHDOTTED	int
,	O
FIG_L_DASHED	int
,	O
FIG_L_DASHED	int
,	O
FIG_L_DASHDOUBLEDOTTED	int
,	O
FIG_L_DASHTRIPLEDOTTED	int
}	O
;	O
const	O
int	O
_pl_f_fig_join_style	array
[	O
PL_NUM_JOIN_TYPES	int
]	O
=	O
{	O
FIG_JOIN_MITER	int
,	O
FIG_JOIN_ROUND	int
,	O
FIG_JOIN_BEVEL	int
,	O
FIG_JOIN_ROUND	int
}	O
;	O
const	O
int	O
_pl_f_fig_cap_style	array
[	O
PL_NUM_CAP_TYPES	int
]	O
=	O
{	O
FIG_CAP_BUTT	int
,	O
FIG_CAP_ROUND	int
,	O
FIG_CAP_PROJECT	int
,	O
FIG_CAP_ROUND	int
}	O
;	O
void	O
_pl_f_paint_path	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
==	O
0	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fill_type	int
==	O
0	int
)	O
return	O
;	O
switch	O
(	O
(	O
int	O
)	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
type	enum
)	O
{	O
case	O
(	O
int	O
)	O
PATH_SEGMENT_LIST	int
:	O
{	O
bool	enum
closed	enum
;	O
const	O
char	O
*	O
format	pointer
;	O
int	O
i	int
,	O
polyline_subtype	int
,	O
line_style	int
;	O
double	O
nominal_spacing	double
;	O
double	O
device_line_width	double
;	O
int	O
quantized_device_line_width	int
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
0	int
)	O
break	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
1	int
)	O
break	O
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
==	O
2	int
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
type	enum
==	O
S_ARC	int
)	O
{	O
double	O
x0	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
x	double
;	O
double	O
y0	function
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
y	double
;	O
double	O
x1	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
p	struct
.	O
x	double
;	O
double	O
y1	function
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
p	struct
.	O
y	double
;	O
double	O
xc	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
pc	struct
.	O
x	double
;	O
double	O
yc	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
1	int
]	O
.	O
pc	struct
.	O
y	double
;	O
_pl_f_draw_arc_internal	function
(	O
R___	O
(	O
_plotter	pointer
)	O
xc	int
,	O
yc	int
,	O
x0	double
,	O
y0	function
,	O
x1	double
,	O
y1	function
)	O
;	O
break	O
;	O
}	O
if	O
(	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
>=	O
3	int
)	O
&&	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
x	double
==	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
x	double
)	O
&&	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
-	O
1	int
]	O
.	O
p	struct
.	O
y	double
==	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
0	int
]	O
.	O
p	struct
.	O
y	double
)	O
)	O
closed	enum
=	O
true	int
;	O
else	O
closed	enum
=	O
false	int
;	O
if	O
(	O
closed	enum
)	O
{	O
polyline_subtype	int
=	O
P_CLOSED	int
;	O
format	pointer
=	O
"#POLYLINE [CLOSED]\n%d %d %d %d %d %d %d %d %d %.3f %d %d %d %d %d %d"	pointer
;	O
}	O
else	O
{	O
polyline_subtype	int
=	O
P_OPEN	int
;	O
format	pointer
=	O
"#POLYLINE [OPEN]\n%d %d %d %d %d %d %d %d %d %.3f %d %d %d %d %d %d"	pointer
;	O
}	O
_pl_f_set_pen_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_pl_f_set_fill_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
device_line_width	double
=	O
FIG_UNITS_TO_FIG_DISPLAY_UNITS	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
device_line_width	double
)	O
;	O
if	O
(	O
device_line_width	double
>	O
0.75	int
)	O
device_line_width	double
+=	O
1.0	int
;	O
quantized_device_line_width	int
=	O
IROUND	O
(	O
device_line_width	double
)	O
;	O
if	O
(	O
quantized_device_line_width	int
==	O
0	int
&&	O
device_line_width	double
>	O
0.0	int
)	O
quantized_device_line_width	int
=	O
1	int
;	O
_pl_f_compute_line_style	function
(	O
R___	O
(	O
_plotter	pointer
)	O
&	O
line_style	int
,	O
&	O
nominal_spacing	double
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
fig_drawing_depth	int
>	O
0	int
)	O
(	O
_plotter	pointer
->	O
fig_drawing_depth	int
)	O
--	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
format	pointer
,	O
2	int
,	O
polyline_subtype	int
,	O
line_style	int
,	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
==	O
0	int
?	O
0	int
:	O
quantized_device_line_width	int
)	O
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fgcolor	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fillcolor	int
,	O
_plotter	pointer
->	O
fig_drawing_depth	int
,	O
0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fill_level	int
,	O
nominal_spacing	double
,	O
_pl_f_fig_join_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
]	O
,	O
_pl_f_fig_cap_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
cap_type	int
]	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
num_segments	int
;	O
i	int
++	O
)	O
{	O
plPathSegment	struct
datapoint	struct
;	O
double	O
xu	double
,	O
yu	double
,	O
xd	double
,	O
yd	double
;	O
int	O
device_x	int
,	O
device_y	int
;	O
datapoint	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
segments	pointer
[	O
i	int
]	O
;	O
xu	double
=	O
datapoint	struct
.	O
p	struct
.	O
x	double
;	O
yu	double
=	O
datapoint	struct
.	O
p	struct
.	O
y	double
;	O
xd	double
=	O
XD	O
(	O
xu	double
,	O
yu	double
)	O
;	O
yd	double
=	O
YD	O
(	O
xu	double
,	O
yu	double
)	O
;	O
device_x	int
=	O
IROUND	O
(	O
xd	double
)	O
;	O
device_y	int
=	O
IROUND	O
(	O
yd	double
)	O
;	O
if	O
(	O
(	O
i	int
%	O
5	int
)	O
==	O
0	int
)	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"\n\t"	pointer
)	O
;	O
else	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
" "	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d %d"	pointer
,	O
device_x	int
,	O
device_y	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"\n"	pointer
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_BOX	int
:	O
{	O
plPoint	struct
p0	struct
,	O
p1	struct
;	O
p0	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
;	O
p1	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
;	O
_pl_f_draw_box_internal	function
(	O
R___	O
(	O
_plotter	pointer
)	O
p0	struct
,	O
p1	struct
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_CIRCLE	int
:	O
{	O
double	O
x	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
.	O
x	double
;	O
double	O
y	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
.	O
y	double
;	O
double	O
r	int
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
radius	double
;	O
_pl_f_draw_ellipse_internal	function
(	O
R___	O
(	O
_plotter	pointer
)	O
x	double
,	O
y	double
,	O
r	int
,	O
r	int
,	O
0.0	int
,	O
SUBTYPE_CIRCLE	int
)	O
;	O
}	O
break	O
;	O
case	O
(	O
int	O
)	O
PATH_ELLIPSE	int
:	O
{	O
double	O
x	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
.	O
x	double
;	O
double	O
y	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
pc	struct
.	O
y	double
;	O
double	O
rx	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
rx	double
;	O
double	O
ry	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
ry	double
;	O
double	O
angle	double
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
angle	double
;	O
_pl_f_draw_ellipse_internal	function
(	O
R___	O
(	O
_plotter	pointer
)	O
x	double
,	O
y	double
,	O
rx	double
,	O
ry	double
,	O
angle	double
,	O
SUBTYPE_ELLIPSE	int
)	O
;	O
}	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
}	O
void	O
_pl_f_draw_arc_internal	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
xc	int
,	O
double	O
yc	int
,	O
double	O
x0	double
,	O
double	O
y0	function
,	O
double	O
x1	double
,	O
double	O
y1	function
)	O
{	O
plPoint	struct
p0	struct
,	O
p1	struct
,	O
pc	struct
,	O
pb	struct
;	O
plVector	struct
v	pointer
,	O
v0	struct
,	O
v1	struct
;	O
double	O
cross	double
,	O
radius	double
,	O
nominal_spacing	double
;	O
int	O
line_style	int
,	O
orientation	int
;	O
double	O
device_line_width	double
;	O
int	O
quantized_device_line_width	int
;	O
pc	struct
.	O
x	double
=	O
xc	int
,	O
pc	struct
.	O
y	double
=	O
yc	int
;	O
p0	struct
.	O
x	double
=	O
x0	double
,	O
p0	struct
.	O
y	double
=	O
y0	function
;	O
p1	struct
.	O
x	double
=	O
x1	double
,	O
p1	struct
.	O
y	double
=	O
y1	function
;	O
v0	struct
.	O
x	double
=	O
p0	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
v0	struct
.	O
y	double
=	O
p0	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
v1	struct
.	O
x	double
=	O
p1	struct
.	O
x	double
-	O
pc	struct
.	O
x	double
;	O
v1	struct
.	O
y	double
=	O
p1	struct
.	O
y	double
-	O
pc	struct
.	O
y	double
;	O
cross	double
=	O
v0	struct
.	O
x	double
*	O
v1	struct
.	O
y	double
-	O
v1	struct
.	O
x	double
*	O
v0	struct
.	O
y	double
;	O
orientation	int
=	O
(	O
cross	double
>=	O
0.0	int
?	O
1	int
:	O
-	O
1	int
)	O
;	O
radius	double
=	O
DIST	O
(	O
pc	struct
,	O
p0	struct
)	O
;	O
v	pointer
.	O
x	double
=	O
p1	struct
.	O
x	double
-	O
p0	struct
.	O
x	double
;	O
v	pointer
.	O
y	double
=	O
p1	struct
.	O
y	double
-	O
p0	struct
.	O
y	double
;	O
_vscale	function
(	O
&	O
v	pointer
,	O
radius	double
)	O
;	O
pb	struct
.	O
x	double
=	O
pc	struct
.	O
x	double
+	O
orientation	int
*	O
v	pointer
.	O
y	double
;	O
pb	struct
.	O
y	double
=	O
pc	struct
.	O
y	double
-	O
orientation	int
*	O
v	pointer
.	O
x	double
;	O
_pl_f_set_pen_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_pl_f_set_fill_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
device_line_width	double
=	O
FIG_UNITS_TO_FIG_DISPLAY_UNITS	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
device_line_width	double
)	O
;	O
if	O
(	O
device_line_width	double
>	O
0.75	int
)	O
device_line_width	double
+=	O
1.0	int
;	O
quantized_device_line_width	int
=	O
IROUND	O
(	O
device_line_width	double
)	O
;	O
if	O
(	O
quantized_device_line_width	int
==	O
0	int
&&	O
device_line_width	double
>	O
0.0	int
)	O
quantized_device_line_width	int
=	O
1	int
;	O
_pl_f_compute_line_style	function
(	O
R___	O
(	O
_plotter	pointer
)	O
&	O
line_style	int
,	O
&	O
nominal_spacing	double
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
fig_drawing_depth	int
>	O
0	int
)	O
(	O
_plotter	pointer
->	O
fig_drawing_depth	int
)	O
--	O
;	O
orientation	int
*=	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
nonreflection	enum
?	O
1	int
:	O
-	O
1	int
)	O
;	O
if	O
(	O
orientation	int
==	O
-	O
1	int
)	O
{	O
plPoint	struct
ptmp	struct
;	O
ptmp	struct
=	O
p0	struct
;	O
p0	struct
=	O
p1	struct
;	O
p1	struct
=	O
ptmp	struct
;	O
}	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"#ARC\n%d %d %d %d %d %d %d %d %d %.3f %d %d %d %d %.3f %.3f %d %d %d %d %d %d\n"	pointer
,	O
5	int
,	O
1	int
,	O
line_style	int
,	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
==	O
0	int
?	O
0	int
:	O
quantized_device_line_width	int
)	O
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fgcolor	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fillcolor	int
,	O
_plotter	pointer
->	O
fig_drawing_depth	int
,	O
0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fill_level	int
,	O
nominal_spacing	double
,	O
_pl_f_fig_cap_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
cap_type	int
]	O
,	O
1	int
,	O
0	int
,	O
0	int
,	O
XD	O
(	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
)	O
,	O
YD	O
(	O
pc	struct
.	O
x	double
,	O
pc	struct
.	O
y	double
)	O
,	O
IROUND	O
(	O
XD	O
(	O
p0	struct
.	O
x	double
,	O
p0	struct
.	O
y	double
)	O
)	O
,	O
IROUND	O
(	O
YD	O
(	O
p0	struct
.	O
x	double
,	O
p0	struct
.	O
y	double
)	O
)	O
,	O
IROUND	O
(	O
XD	O
(	O
pb	struct
.	O
x	double
,	O
pb	struct
.	O
y	double
)	O
)	O
,	O
IROUND	O
(	O
YD	O
(	O
pb	struct
.	O
x	double
,	O
pb	struct
.	O
y	double
)	O
)	O
,	O
IROUND	O
(	O
XD	O
(	O
p1	struct
.	O
x	double
,	O
p1	struct
.	O
y	double
)	O
)	O
,	O
IROUND	O
(	O
YD	O
(	O
p1	struct
.	O
x	double
,	O
p1	struct
.	O
y	double
)	O
)	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
void	O
_pl_f_draw_box_internal	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
plPoint	struct
p0	struct
,	O
plPoint	struct
p1	struct
)	O
{	O
int	O
xd0	int
,	O
xd1	int
,	O
yd0	int
,	O
yd1	int
;	O
double	O
nominal_spacing	double
;	O
int	O
line_style	int
;	O
double	O
device_line_width	double
;	O
int	O
quantized_device_line_width	int
;	O
_pl_f_set_pen_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_pl_f_set_fill_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
device_line_width	double
=	O
FIG_UNITS_TO_FIG_DISPLAY_UNITS	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
device_line_width	double
)	O
;	O
if	O
(	O
device_line_width	double
>	O
0.75	int
)	O
device_line_width	double
+=	O
1.0	int
;	O
quantized_device_line_width	int
=	O
IROUND	O
(	O
device_line_width	double
)	O
;	O
if	O
(	O
quantized_device_line_width	int
==	O
0	int
&&	O
device_line_width	double
>	O
0.0	int
)	O
quantized_device_line_width	int
=	O
1	int
;	O
_pl_f_compute_line_style	function
(	O
R___	O
(	O
_plotter	pointer
)	O
&	O
line_style	int
,	O
&	O
nominal_spacing	double
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
fig_drawing_depth	int
>	O
0	int
)	O
(	O
_plotter	pointer
->	O
fig_drawing_depth	int
)	O
--	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"#POLYLINE [BOX]\n%d %d %d %d %d %d %d %d %d %.3f %d %d %d %d %d %d\n"	pointer
,	O
2	int
,	O
P_BOX	int
,	O
line_style	int
,	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
==	O
0	int
?	O
0	int
:	O
quantized_device_line_width	int
)	O
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fgcolor	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fillcolor	int
,	O
_plotter	pointer
->	O
fig_drawing_depth	int
,	O
0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fill_level	int
,	O
nominal_spacing	double
,	O
_pl_f_fig_join_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
join_type	int
]	O
,	O
_pl_f_fig_cap_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
cap_type	int
]	O
,	O
0	int
,	O
0	int
,	O
0	int
,	O
5	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
p0	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p0	struct
;	O
p1	struct
=	O
_plotter	pointer
->	O
drawstate	pointer
->	O
path	pointer
->	O
p1	struct
;	O
xd0	int
=	O
IROUND	O
(	O
XD	O
(	O
p0	struct
.	O
x	double
,	O
p0	struct
.	O
y	double
)	O
)	O
;	O
yd0	int
=	O
IROUND	O
(	O
YD	O
(	O
p0	struct
.	O
x	double
,	O
p0	struct
.	O
y	double
)	O
)	O
;	O
xd1	int
=	O
IROUND	O
(	O
XD	O
(	O
p1	struct
.	O
x	double
,	O
p1	struct
.	O
y	double
)	O
)	O
;	O
yd1	int
=	O
IROUND	O
(	O
YD	O
(	O
p1	struct
.	O
x	double
,	O
p1	struct
.	O
y	double
)	O
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"\t%d %d "	pointer
,	O
xd0	int
,	O
yd0	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d %d "	pointer
,	O
xd0	int
,	O
yd1	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d %d "	pointer
,	O
xd1	int
,	O
yd1	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d %d "	pointer
,	O
xd1	int
,	O
yd0	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
"%d %d\n"	pointer
,	O
xd0	int
,	O
yd0	int
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
void	O
_pl_f_draw_ellipse_internal	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
double	O
x	double
,	O
double	O
y	double
,	O
double	O
rx	double
,	O
double	O
ry	double
,	O
double	O
angle	double
,	O
int	O
subtype	int
)	O
{	O
const	O
char	O
*	O
format	pointer
;	O
double	O
theta	double
,	O
mixing_angle	double
;	O
double	O
ux	double
,	O
uy	double
,	O
vx	double
,	O
vy	double
;	O
double	O
semi_axis_1_x	double
,	O
semi_axis_1_y	double
;	O
double	O
semi_axis_2_x	double
,	O
semi_axis_2_y	double
;	O
double	O
rx_device	double
,	O
ry_device	double
,	O
theta_device	double
;	O
double	O
costheta	double
,	O
sintheta	double
;	O
double	O
nominal_spacing	double
;	O
int	O
line_style	int
;	O
double	O
device_line_width	double
;	O
int	O
quantized_device_line_width	int
;	O
theta	double
=	O
M_PI	int
*	O
angle	double
/	O
180.0	int
;	O
costheta	double
=	O
cos	function
(	O
theta	double
)	O
;	O
sintheta	double
=	O
sin	function
(	O
theta	double
)	O
;	O
ux	double
=	O
XDV	O
(	O
rx	double
*	O
costheta	double
,	O
rx	double
*	O
sintheta	double
)	O
;	O
uy	double
=	O
YDV	O
(	O
rx	double
*	O
costheta	double
,	O
rx	double
*	O
sintheta	double
)	O
;	O
vx	double
=	O
XDV	O
(	O
-	O
ry	double
*	O
sintheta	double
,	O
ry	double
*	O
costheta	double
)	O
;	O
vy	double
=	O
YDV	O
(	O
-	O
ry	double
*	O
sintheta	double
,	O
ry	double
*	O
costheta	double
)	O
;	O
mixing_angle	double
=	O
0.5	int
*	O
_xatan2	function
(	O
2.0	int
*	O
(	O
ux	double
*	O
vx	double
+	O
uy	double
*	O
vy	double
)	O
,	O
ux	double
*	O
ux	double
+	O
uy	double
*	O
uy	double
-	O
vx	double
*	O
vx	double
+	O
vy	double
*	O
vy	double
)	O
;	O
semi_axis_1_x	double
=	O
ux	double
*	O
cos	function
(	O
mixing_angle	double
)	O
+	O
vx	double
*	O
sin	function
(	O
mixing_angle	double
)	O
;	O
semi_axis_1_y	double
=	O
uy	double
*	O
cos	function
(	O
mixing_angle	double
)	O
+	O
vy	double
*	O
sin	function
(	O
mixing_angle	double
)	O
;	O
semi_axis_2_x	double
=	O
ux	double
*	O
cos	function
(	O
mixing_angle	double
+	O
M_PI_2	int
)	O
+	O
vx	double
*	O
sin	function
(	O
mixing_angle	double
+	O
M_PI_2	int
)	O
;	O
semi_axis_2_y	double
=	O
uy	double
*	O
cos	function
(	O
mixing_angle	double
+	O
M_PI_2	int
)	O
+	O
vy	double
*	O
sin	function
(	O
mixing_angle	double
+	O
M_PI_2	int
)	O
;	O
rx_device	double
=	O
sqrt	function
(	O
semi_axis_1_x	double
*	O
semi_axis_1_x	double
+	O
semi_axis_1_y	double
*	O
semi_axis_1_y	double
)	O
;	O
ry_device	double
=	O
sqrt	function
(	O
semi_axis_2_x	double
*	O
semi_axis_2_x	double
+	O
semi_axis_2_y	double
*	O
semi_axis_2_y	double
)	O
;	O
theta_device	double
=	O
-	O
_xatan2	function
(	O
semi_axis_1_y	double
,	O
semi_axis_1_x	double
)	O
;	O
if	O
(	O
theta_device	double
==	O
0.0	int
)	O
theta_device	double
=	O
0.0	int
;	O
if	O
(	O
subtype	int
==	O
SUBTYPE_CIRCLE	int
&&	O
IROUND	O
(	O
rx_device	double
)	O
!=	O
IROUND	O
(	O
ry_device	double
)	O
)	O
subtype	int
=	O
SUBTYPE_ELLIPSE	int
;	O
_pl_f_set_pen_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
_pl_f_set_fill_color	function
(	O
S___	O
(	O
_plotter	pointer
)	O
)	O
;	O
device_line_width	double
=	O
FIG_UNITS_TO_FIG_DISPLAY_UNITS	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
device_line_width	double
)	O
;	O
if	O
(	O
device_line_width	double
>	O
0.75	int
)	O
device_line_width	double
+=	O
1.0	int
;	O
quantized_device_line_width	int
=	O
IROUND	O
(	O
device_line_width	double
)	O
;	O
if	O
(	O
quantized_device_line_width	int
==	O
0	int
&&	O
device_line_width	double
>	O
0.0	int
)	O
quantized_device_line_width	int
=	O
1	int
;	O
_pl_f_compute_line_style	function
(	O
R___	O
(	O
_plotter	pointer
)	O
&	O
line_style	int
,	O
&	O
nominal_spacing	double
)	O
;	O
if	O
(	O
_plotter	pointer
->	O
fig_drawing_depth	int
>	O
0	int
)	O
(	O
_plotter	pointer
->	O
fig_drawing_depth	int
)	O
--	O
;	O
if	O
(	O
subtype	int
==	O
SUBTYPE_CIRCLE	int
)	O
format	pointer
=	O
"#ELLIPSE [CIRCLE]\n%d %d %d %d %d %d %d %d %d %.3f %d %.3f %d %d %d %d %d %d %d %d\n"	pointer
;	O
else	O
format	pointer
=	O
"#ELLIPSE\n%d %d %d %d %d %d %d %d %d %.3f %d %.3f %d %d %d %d %d %d %d %d\n"	pointer
;	O
sprintf	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
->	O
point	pointer
,	O
format	pointer
,	O
1	int
,	O
subtype	int
,	O
line_style	int
,	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
pen_type	int
==	O
0	int
?	O
0	int
:	O
quantized_device_line_width	int
)	O
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fgcolor	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fillcolor	int
,	O
_plotter	pointer
->	O
fig_drawing_depth	int
,	O
0	int
,	O
_plotter	pointer
->	O
drawstate	pointer
->	O
fig_fill_level	int
,	O
nominal_spacing	double
,	O
1	int
,	O
theta_device	double
,	O
IROUND	O
(	O
XD	O
(	O
x	double
,	O
y	double
)	O
)	O
,	O
IROUND	O
(	O
YD	O
(	O
x	double
,	O
y	double
)	O
)	O
,	O
IROUND	O
(	O
rx_device	double
)	O
,	O
IROUND	O
(	O
ry_device	double
)	O
,	O
IROUND	O
(	O
XD	O
(	O
x	double
,	O
y	double
)	O
)	O
,	O
IROUND	O
(	O
YD	O
(	O
x	double
,	O
y	double
)	O
)	O
,	O
IROUND	O
(	O
XD	O
(	O
x	double
,	O
y	double
)	O
+	O
semi_axis_1_x	double
+	O
semi_axis_2_x	double
)	O
,	O
IROUND	O
(	O
YD	O
(	O
x	double
,	O
y	double
)	O
+	O
semi_axis_1_y	double
+	O
semi_axis_2_y	double
)	O
)	O
;	O
_update_buffer	function
(	O
_plotter	pointer
->	O
data	pointer
->	O
page	pointer
)	O
;	O
}	O
void	O
_pl_f_compute_line_style	function
(	O
R___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
int	O
*	O
style	pointer
,	O
double	O
*	O
spacing	pointer
)	O
{	O
int	O
fig_line_style	int
;	O
double	O
fig_nominal_spacing	double
;	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_in_effect	enum
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_len	int
==	O
2	int
&&	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
[	O
1	int
]	O
==	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
[	O
0	int
]	O
)	O
)	O
{	O
double	O
min_sing_val	pointer
,	O
max_sing_val	pointer
;	O
_matrix_sing_vals	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
,	O
&	O
min_sing_val	pointer
,	O
&	O
max_sing_val	pointer
)	O
;	O
fig_nominal_spacing	double
=	O
FIG_UNITS_TO_FIG_DISPLAY_UNITS	O
(	O
min_sing_val	pointer
*	O
2.0	int
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
[	O
0	int
]	O
)	O
;	O
fig_line_style	int
=	O
FIG_L_DASHED	int
;	O
}	O
else	O
if	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_in_effect	enum
&&	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array_len	int
==	O
2	int
&&	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
[	O
1	int
]	O
>	O
(	O
3	int
-	O
FUZZ	int
)	O
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
[	O
0	int
]	O
)	O
&&	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
[	O
1	int
]	O
<	O
(	O
3	int
+	O
FUZZ	int
)	O
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
[	O
0	int
]	O
)	O
)	O
{	O
double	O
min_sing_val	pointer
,	O
max_sing_val	pointer
;	O
_matrix_sing_vals	function
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
transform	struct
.	O
m	array
,	O
&	O
min_sing_val	pointer
,	O
&	O
max_sing_val	pointer
)	O
;	O
fig_nominal_spacing	double
=	O
FIG_UNITS_TO_FIG_DISPLAY_UNITS	O
(	O
min_sing_val	pointer
*	O
4.0	int
*	O
_plotter	pointer
->	O
drawstate	pointer
->	O
dash_array	pointer
[	O
0	int
]	O
)	O
;	O
fig_line_style	int
=	O
FIG_L_DOTTED	int
;	O
}	O
else	O
{	O
int	O
i	int
,	O
num_dashes	int
,	O
cycle_length	int
;	O
const	O
int	O
*	O
dash_array	pointer
;	O
double	O
display_size_in_fig_units	double
,	O
min_dash_unit	double
,	O
dash_unit	double
;	O
num_dashes	int
=	O
_pl_g_line_styles	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
]	O
.	O
dash_array_len	int
;	O
dash_array	pointer
=	O
_pl_g_line_styles	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
]	O
.	O
dash_array	pointer
;	O
cycle_length	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_dashes	int
;	O
i	int
++	O
)	O
cycle_length	int
+=	O
dash_array	pointer
[	O
i	int
]	O
;	O
display_size_in_fig_units	double
=	O
DMIN	O
(	O
_plotter	pointer
->	O
data	pointer
->	O
xmax	double
-	O
_plotter	pointer
->	O
data	pointer
->	O
xmin	double
,	O
_plotter	pointer
->	O
data	pointer
->	O
ymin	double
-	O
_plotter	pointer
->	O
data	pointer
->	O
ymax	double
)	O
;	O
min_dash_unit	double
=	O
PL_MIN_DASH_UNIT_AS_FRACTION_OF_DISPLAY_SIZE	O
*	O
FIG_UNITS_TO_FIG_DISPLAY_UNITS	O
(	O
display_size_in_fig_units	double
)	O
;	O
dash_unit	double
=	O
DMAX	O
(	O
min_dash_unit	double
,	O
FIG_UNITS_TO_FIG_DISPLAY_UNITS	O
(	O
_plotter	pointer
->	O
drawstate	pointer
->	O
device_line_width	double
)	O
)	O
;	O
fig_nominal_spacing	double
=	O
cycle_length	int
*	O
dash_unit	double
;	O
fig_line_style	int
=	O
_pl_f_fig_line_style	array
[	O
_plotter	pointer
->	O
drawstate	pointer
->	O
line_type	int
]	O
;	O
}	O
switch	O
(	O
fig_line_style	int
)	O
{	O
case	O
FIG_L_SOLID	int
:	O
default	O
:	O
break	O
;	O
case	O
FIG_L_DOTTED	int
:	O
fig_nominal_spacing	double
-=	O
1.0	int
;	O
break	O
;	O
case	O
FIG_L_DASHDOTTED	int
:	O
fig_nominal_spacing	double
-=	O
1.0	int
;	O
case	O
FIG_L_DASHED	int
:	O
fig_nominal_spacing	double
*=	O
0.5	int
;	O
break	O
;	O
case	O
FIG_L_DASHDOUBLEDOTTED	int
:	O
fig_nominal_spacing	double
-=	O
2.0	int
;	O
fig_nominal_spacing	double
/=	O
(	O
1.9	int
+	O
1	int
/	O
3.0	int
)	O
;	O
break	O
;	O
case	O
FIG_L_DASHTRIPLEDOTTED	int
:	O
fig_nominal_spacing	double
-=	O
3.0	int
;	O
fig_nominal_spacing	double
/=	O
2.4	int
;	O
break	O
;	O
}	O
if	O
(	O
fig_nominal_spacing	double
<=	O
1.0	int
)	O
fig_nominal_spacing	double
=	O
1.0	int
;	O
*	O
style	pointer
=	O
fig_line_style	int
;	O
*	O
spacing	pointer
=	O
fig_nominal_spacing	double
;	O
}	O
bool	enum
_pl_f_paint_paths	function
(	O
S___	O
(	O
Plotter	struct
*	O
_plotter	pointer
)	O
)	O
{	O
return	O
false	int
;	O
}	O
