static	O
char	O
*	O
info_help_nodename	pointer
=	O
"*Info Help*"	pointer
;	O
static	O
NODE	struct
*	O
internal_info_help_node	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
info_internal_help_text	array
[	O
]	O
=	O
{	O
N_	O
(	O
"Basic Info command keys\n"	pointer
)	O
,	O
"\n"	pointer
,	O
N_	O
(	O
"\\%-10[quit-help]  Close this help window.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[quit]  Quit Info altogether.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[get-info-help-node]  Invoke the Info tutorial.\n"	pointer
)	O
,	O
"\n"	pointer
,	O
N_	O
(	O
"\\%-10[prev-line]  Move up one line.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[next-line]  Move down one line.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[scroll-backward]  Scroll backward one screenful.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[scroll-forward]  Scroll forward one screenful.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[beginning-of-node]  Go to the beginning of this node.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[end-of-node]  Go to the end of this node.\n"	pointer
)	O
,	O
"\n"	pointer
,	O
N_	O
(	O
"\\%-10[move-to-next-xref]  Skip to the next hypertext link.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[select-reference-this-line]  Follow the hypertext link under the cursor.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[history-node]  Go back to the last node seen in this window.\n"	pointer
)	O
,	O
"\n"	pointer
,	O
N_	O
(	O
"\\%-10[global-prev-node]  Go to the previous node in the document.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[global-next-node]  Go to the next node in the document.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[prev-node]  Go to the previous node on this level.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[next-node]  Go to the next node on this level.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[up-node]  Go up one level.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[top-node]  Go to the top node of this document.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[dir-node]  Go to the main 'directory' node.\n"	pointer
)	O
,	O
"\n"	pointer
,	O
N_	O
(	O
"1...9       Pick the first...ninth item in this node's menu.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[last-menu-item]  Pick the last item in this node's menu.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[menu-item]  Pick a menu item specified by name.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[xref-item]  Follow a cross reference specified by name.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[goto-node]  Go to a node specified by name.\n"	pointer
)	O
,	O
"\n"	pointer
,	O
N_	O
(	O
"\\%-10[search]  Search forward for a specified string.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[search-previous]  Search for previous occurrence.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[search-next]  Search for next occurrence.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[index-search]  Search for a specified string in the index, and\n              select the node referenced by the first entry found.\n"	pointer
)	O
,	O
N_	O
(	O
"\\%-10[virtual-index]  Synthesize menu of matching index entries.\n"	pointer
)	O
,	O
"\n"	pointer
,	O
N_	O
(	O
"\\%-10[abort-key]  Cancel the current operation.\n"	pointer
)	O
,	O
"\n"	pointer
,	O
NULL	O
}	O
;	O
static	O
char	O
*	O
where_is_internal	function
(	O
Keymap	pointer
map	pointer
,	O
InfoCommand	struct
*	O
cmd	pointer
)	O
;	O
static	O
void	O
dump_map_to_text_buffer	function
(	O
struct	O
text_buffer	struct
*	O
tb	pointer
,	O
int	O
*	O
prefix	pointer
,	O
int	O
prefix_len	int
,	O
Keymap	pointer
map	pointer
)	O
{	O
register	O
int	O
i	int
;	O
int	O
*	O
new_prefix	pointer
=	O
xmalloc	function
(	O
(	O
prefix_len	int
+	O
2	int
)	O
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
memcpy	function
(	O
new_prefix	pointer
,	O
prefix	pointer
,	O
prefix_len	int
*	O
sizeof	O
(	O
int	O
)	O
)	O
;	O
new_prefix	pointer
[	O
prefix_len	int
+	O
1	int
]	O
=	O
0	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
KEYMAP_SIZE	O
;	O
i	int
++	O
)	O
{	O
if	O
(	O
i	int
==	O
128	int
)	O
i	int
=	O
256	int
;	O
if	O
(	O
i	int
==	O
128	int
+	O
KEYMAP_META_BASE	int
)	O
i	int
=	O
256	int
+	O
KEYMAP_META_BASE	int
;	O
new_prefix	pointer
[	O
prefix_len	int
]	O
=	O
i	int
;	O
if	O
(	O
map	pointer
[	O
i	int
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
{	O
dump_map_to_text_buffer	function
(	O
tb	pointer
,	O
new_prefix	pointer
,	O
prefix_len	int
+	O
1	int
,	O
map	pointer
[	O
i	int
]	O
.	O
value	union
.	O
keymap	pointer
)	O
;	O
}	O
else	O
if	O
(	O
map	pointer
[	O
i	int
]	O
.	O
value	union
.	O
function	pointer
)	O
{	O
long	O
start_of_line	long
=	O
tb	pointer
->	O
off	long
;	O
register	O
int	O
last	int
;	O
char	O
*	O
doc	pointer
,	O
*	O
name	pointer
;	O
if	O
(	O
map	pointer
[	O
i	int
]	O
.	O
value	union
.	O
function	pointer
&&	O
(	O
map	pointer
[	O
i	int
]	O
.	O
value	union
.	O
function	pointer
->	O
func	pointer
==	O
info_do_lowercase_version	function
)	O
)	O
continue	O
;	O
doc	pointer
=	O
function_documentation	function
(	O
map	pointer
[	O
i	int
]	O
.	O
value	union
.	O
function	pointer
)	O
;	O
name	pointer
=	O
function_name	function
(	O
map	pointer
[	O
i	int
]	O
.	O
value	union
.	O
function	pointer
)	O
;	O
if	O
(	O
!	O
*	O
doc	pointer
)	O
continue	O
;	O
for	O
(	O
last	int
=	O
i	int
+	O
1	int
;	O
last	int
<	O
KEYMAP_SIZE	O
;	O
last	int
++	O
)	O
if	O
(	O
(	O
map	pointer
[	O
last	int
]	O
.	O
type	enum
!=	O
ISFUNC	int
)	O
||	O
(	O
map	pointer
[	O
last	int
]	O
.	O
value	union
.	O
function	pointer
!=	O
map	pointer
[	O
i	int
]	O
.	O
value	union
.	O
function	pointer
)	O
)	O
break	O
;	O
if	O
(	O
last	int
-	O
1	int
!=	O
i	int
)	O
{	O
text_buffer_printf	function
(	O
tb	pointer
,	O
"%s .. "	pointer
,	O
pretty_keyseq	function
(	O
new_prefix	pointer
)	O
)	O
;	O
new_prefix	pointer
[	O
prefix_len	int
]	O
=	O
last	int
-	O
1	int
;	O
text_buffer_printf	function
(	O
tb	pointer
,	O
"%s"	pointer
,	O
pretty_keyseq	function
(	O
new_prefix	pointer
)	O
)	O
;	O
i	int
=	O
last	int
-	O
1	int
;	O
}	O
else	O
text_buffer_printf	function
(	O
tb	pointer
,	O
"%s"	pointer
,	O
pretty_keyseq	function
(	O
new_prefix	pointer
)	O
)	O
;	O
while	O
(	O
tb	pointer
->	O
off	long
-	O
start_of_line	long
<	O
8	int
)	O
text_buffer_printf	function
(	O
tb	pointer
,	O
" "	pointer
)	O
;	O
{	O
int	O
length_so_far	int
;	O
int	O
desired_doc_start	int
=	O
40	int
;	O
text_buffer_printf	function
(	O
tb	pointer
,	O
"(%s)"	pointer
,	O
name	pointer
)	O
;	O
length_so_far	int
=	O
tb	pointer
->	O
off	long
-	O
start_of_line	long
;	O
if	O
(	O
(	O
desired_doc_start	int
+	O
strlen	function
(	O
doc	pointer
)	O
)	O
>=	O
(	O
unsigned	O
int	O
)	O
the_screen	pointer
->	O
width	long
)	O
text_buffer_printf	function
(	O
tb	pointer
,	O
"\n     "	pointer
)	O
;	O
else	O
{	O
while	O
(	O
length_so_far	int
<	O
desired_doc_start	int
)	O
{	O
text_buffer_printf	function
(	O
tb	pointer
,	O
" "	pointer
)	O
;	O
length_so_far	int
++	O
;	O
}	O
}	O
}	O
text_buffer_printf	function
(	O
tb	pointer
,	O
"%s\n"	pointer
,	O
doc	pointer
)	O
;	O
}	O
}	O
free	function
(	O
new_prefix	pointer
)	O
;	O
}	O
static	O
void	O
create_internal_info_help_node	function
(	O
int	O
help_is_only_window_p	int
)	O
{	O
register	O
int	O
i	int
;	O
NODE	struct
*	O
node	pointer
;	O
char	O
*	O
exec_keys	pointer
;	O
int	O
printed_one_mx	int
=	O
0	int
;	O
struct	O
text_buffer	struct
msg	struct
;	O
char	O
*	O
infopath_str	pointer
=	O
infopath_string	function
(	O
)	O
;	O
text_buffer_init	function
(	O
&	O
msg	struct
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
info_internal_help_text	array
[	O
i	int
]	O
;	O
i	int
++	O
)	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
replace_in_documentation	function
(	O
_	O
(	O
info_internal_help_text	array
[	O
i	int
]	O
)	O
,	O
help_is_only_window_p	int
)	O
,	O
NULL	O
,	O
NULL	O
,	O
NULL	O
)	O
;	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
"---------------------\n"	pointer
)	O
;	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
_	O
(	O
"This is GNU Info version %s.  "	pointer
)	O
,	O
VERSION	pointer
)	O
;	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
_	O
(	O
"The current search path is:\n"	pointer
)	O
)	O
;	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
"%s\n"	pointer
,	O
infopath_str	pointer
)	O
;	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
"---------------------\n\n"	pointer
)	O
;	O
free	function
(	O
infopath_str	pointer
)	O
;	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
_	O
(	O
"Commands available in Info windows:\n\n"	pointer
)	O
)	O
;	O
dump_map_to_text_buffer	function
(	O
&	O
msg	struct
,	O
0	int
,	O
0	int
,	O
info_keymap	pointer
)	O
;	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
"---------------------\n\n"	pointer
)	O
;	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
_	O
(	O
"Commands available in the echo area:\n\n"	pointer
)	O
)	O
;	O
dump_map_to_text_buffer	function
(	O
&	O
msg	struct
,	O
0	int
,	O
0	int
,	O
echo_area_keymap	pointer
)	O
;	O
exec_keys	pointer
=	O
where_is	function
(	O
info_keymap	pointer
,	O
InfoCmd	O
(	O
info_execute_command	function
)	O
)	O
;	O
if	O
(	O
exec_keys	pointer
)	O
exec_keys	pointer
=	O
xstrdup	function
(	O
exec_keys	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
function_doc_array	array
[	O
i	int
]	O
.	O
func	pointer
;	O
i	int
++	O
)	O
{	O
InfoCommand	struct
*	O
cmd	pointer
=	O
&	O
function_doc_array	array
[	O
i	int
]	O
;	O
if	O
(	O
cmd	pointer
->	O
func	pointer
!=	O
info_do_lowercase_version	function
&&	O
!	O
where_is_internal	function
(	O
info_keymap	pointer
,	O
cmd	pointer
)	O
&&	O
!	O
where_is_internal	function
(	O
echo_area_keymap	pointer
,	O
cmd	pointer
)	O
)	O
{	O
if	O
(	O
!	O
printed_one_mx	int
)	O
{	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
"---------------------\n\n"	pointer
)	O
;	O
if	O
(	O
exec_keys	pointer
&&	O
exec_keys	pointer
[	O
0	int
]	O
)	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
_	O
(	O
"The following commands can only be invoked via "	pointer
"%s:\n\n"	pointer
)	O
,	O
exec_keys	pointer
)	O
;	O
else	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
_	O
(	O
"The following commands cannot be invoked at all:\n\n"	pointer
)	O
)	O
;	O
printed_one_mx	int
=	O
1	int
;	O
}	O
text_buffer_printf	function
(	O
&	O
msg	struct
,	O
"%s %s\n     %s\n"	pointer
,	O
exec_keys	pointer
,	O
function_doc_array	array
[	O
i	int
]	O
.	O
func_name	pointer
,	O
replace_in_documentation	function
(	O
strlen	function
(	O
function_doc_array	array
[	O
i	int
]	O
.	O
doc	pointer
)	O
?	O
_	O
(	O
function_doc_array	array
[	O
i	int
]	O
.	O
doc	pointer
)	O
:	O
""	pointer
,	O
0	int
)	O
)	O
;	O
}	O
}	O
free	function
(	O
exec_keys	pointer
)	O
;	O
node	pointer
=	O
text_buffer_to_node	function
(	O
&	O
msg	struct
)	O
;	O
internal_info_help_node	pointer
=	O
node	pointer
;	O
name_internal_node	function
(	O
internal_info_help_node	pointer
,	O
xstrdup	function
(	O
info_help_nodename	pointer
)	O
)	O
;	O
}	O
static	O
WINDOW	struct
*	O
info_find_or_create_help_window	function
(	O
void	O
)	O
{	O
int	O
help_is_only_window_p	int
;	O
WINDOW	struct
*	O
eligible	pointer
=	O
NULL	O
;	O
WINDOW	struct
*	O
help_window	pointer
=	O
get_internal_info_window	function
(	O
info_help_nodename	pointer
)	O
;	O
if	O
(	O
help_window	pointer
&&	O
help_window	pointer
==	O
active_window	pointer
)	O
{	O
info_delete_window_internal	function
(	O
help_window	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
if	O
(	O
!	O
help_window	pointer
)	O
{	O
WINDOW	struct
*	O
window	pointer
;	O
int	O
max	int
=	O
0	int
;	O
for	O
(	O
window	pointer
=	O
windows	pointer
;	O
window	pointer
;	O
window	pointer
=	O
window	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
window	pointer
->	O
height	long
>	O
max	int
)	O
{	O
max	int
=	O
window	pointer
->	O
height	long
;	O
eligible	pointer
=	O
window	pointer
;	O
}	O
}	O
if	O
(	O
!	O
eligible	pointer
)	O
{	O
info_error	function
(	O
"%s"	pointer
,	O
msg_cant_make_help	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
}	O
help_is_only_window_p	int
=	O
(	O
(	O
help_window	pointer
&&	O
!	O
windows	pointer
->	O
next	pointer
)	O
||	O
(	O
!	O
help_window	pointer
&&	O
eligible	pointer
->	O
height	long
<	O
HELP_SPLIT_SIZE	int
)	O
)	O
;	O
create_internal_info_help_node	function
(	O
help_is_only_window_p	int
)	O
;	O
if	O
(	O
!	O
help_window	pointer
)	O
{	O
if	O
(	O
eligible	pointer
->	O
height	long
>=	O
HELP_SPLIT_SIZE	int
)	O
{	O
active_window	pointer
=	O
eligible	pointer
;	O
help_window	pointer
=	O
window_make_window	function
(	O
)	O
;	O
info_set_node_of_window	function
(	O
help_window	pointer
,	O
internal_info_help_node	pointer
)	O
;	O
}	O
else	O
{	O
info_set_node_of_window	function
(	O
active_window	pointer
,	O
internal_info_help_node	pointer
)	O
;	O
help_window	pointer
=	O
active_window	pointer
;	O
}	O
}	O
else	O
{	O
if	O
(	O
active_window	pointer
!=	O
help_window	pointer
)	O
{	O
active_window	pointer
=	O
help_window	pointer
;	O
}	O
info_set_node_of_window	function
(	O
active_window	pointer
,	O
internal_info_help_node	pointer
)	O
;	O
}	O
return	O
help_window	pointer
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_get_help_window	function
,	O
_	O
(	O
"Display help message"	pointer
)	O
)	O
{	O
WINDOW	struct
*	O
help_window	pointer
;	O
help_window	pointer
=	O
info_find_or_create_help_window	function
(	O
)	O
;	O
if	O
(	O
help_window	pointer
)	O
{	O
active_window	pointer
=	O
help_window	pointer
;	O
}	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_get_info_help_node	function
,	O
_	O
(	O
"Visit Info node '(info)Help'"	pointer
)	O
)	O
{	O
NODE	struct
*	O
node	pointer
;	O
char	O
*	O
nodename	pointer
;	O
{	O
WINDOW	struct
*	O
win	pointer
;	O
for	O
(	O
win	pointer
=	O
windows	pointer
;	O
win	pointer
;	O
win	pointer
=	O
win	pointer
->	O
next	pointer
)	O
{	O
if	O
(	O
win	pointer
->	O
node	pointer
&&	O
win	pointer
->	O
node	pointer
->	O
fullpath	pointer
&&	O
!	O
mbscasecmp	function
(	O
"info"	pointer
,	O
filename_non_directory	function
(	O
win	pointer
->	O
node	pointer
->	O
fullpath	pointer
)	O
)	O
&&	O
(	O
!	O
strcmp	function
(	O
win	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
"Help"	pointer
)	O
||	O
!	O
strcmp	function
(	O
win	pointer
->	O
node	pointer
->	O
nodename	pointer
,	O
"Help-Small-Screen"	pointer
)	O
)	O
)	O
{	O
active_window	pointer
=	O
win	pointer
;	O
return	O
;	O
}	O
}	O
}	O
if	O
(	O
windows	pointer
->	O
next	pointer
)	O
{	O
WINDOW	struct
*	O
help_window	pointer
=	O
get_internal_info_window	function
(	O
info_help_nodename	pointer
)	O
;	O
if	O
(	O
help_window	pointer
&&	O
help_window	pointer
==	O
active_window	pointer
)	O
{	O
info_delete_window_internal	function
(	O
help_window	pointer
)	O
;	O
}	O
}	O
if	O
(	O
active_window	pointer
->	O
height	long
<	O
24	int
)	O
nodename	pointer
=	O
"Help-Small-Screen"	pointer
;	O
else	O
nodename	pointer
=	O
"Help"	pointer
;	O
node	pointer
=	O
info_get_node	function
(	O
"info"	pointer
,	O
nodename	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
node	pointer
=	O
info_get_node	function
(	O
"info-stnd"	pointer
,	O
"Top"	pointer
)	O
;	O
if	O
(	O
!	O
node	pointer
)	O
{	O
if	O
(	O
info_recent_file_error	pointer
)	O
info_error	function
(	O
"%s"	pointer
,	O
info_recent_file_error	pointer
)	O
;	O
else	O
info_error	function
(	O
msg_cant_file_node	pointer
,	O
"info"	pointer
,	O
nodename	pointer
)	O
;	O
return	O
;	O
}	O
info_set_node_of_window	function
(	O
active_window	pointer
,	O
node	pointer
)	O
;	O
}	O
char	O
*	O
function_documentation	function
(	O
InfoCommand	struct
*	O
cmd	pointer
)	O
{	O
char	O
*	O
doc	pointer
;	O
doc	pointer
=	O
cmd	pointer
->	O
doc	pointer
;	O
return	O
replace_in_documentation	function
(	O
(	O
strlen	function
(	O
doc	pointer
)	O
==	O
0	int
)	O
?	O
doc	pointer
:	O
_	O
(	O
doc	pointer
)	O
,	O
0	int
)	O
;	O
}	O
char	O
*	O
function_name	function
(	O
InfoCommand	struct
*	O
cmd	pointer
)	O
{	O
return	O
cmd	pointer
->	O
func_name	pointer
;	O
}	O
InfoCommand	struct
*	O
named_function	function
(	O
char	O
*	O
name	pointer
)	O
{	O
register	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
function_doc_array	array
[	O
i	int
]	O
.	O
func	pointer
;	O
i	int
++	O
)	O
if	O
(	O
strcmp	function
(	O
function_doc_array	array
[	O
i	int
]	O
.	O
func_name	pointer
,	O
name	pointer
)	O
==	O
0	int
)	O
break	O
;	O
if	O
(	O
!	O
function_doc_array	array
[	O
i	int
]	O
.	O
func	pointer
)	O
return	O
0	int
;	O
else	O
return	O
&	O
function_doc_array	array
[	O
i	int
]	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
describe_key	function
,	O
_	O
(	O
"Print documentation for KEY"	pointer
)	O
)	O
{	O
int	O
keys	pointer
[	O
50	int
]	O
;	O
int	O
keystroke	int
;	O
int	O
*	O
k	pointer
=	O
keys	pointer
;	O
Keymap	pointer
map	pointer
=	O
info_keymap	pointer
;	O
*	O
k	pointer
=	O
'\0'	O
;	O
for	O
(	O
;	O
;	O
)	O
{	O
message_in_echo_area	function
(	O
_	O
(	O
"Describe key: %s"	pointer
)	O
,	O
pretty_keyseq	function
(	O
keys	pointer
)	O
)	O
;	O
keystroke	int
=	O
get_input_key	function
(	O
)	O
;	O
unmessage_in_echo_area	function
(	O
)	O
;	O
*	O
k	pointer
++	O
=	O
keystroke	int
;	O
*	O
k	pointer
=	O
'\0'	O
;	O
if	O
(	O
map	pointer
[	O
keystroke	int
]	O
.	O
value	union
.	O
function	pointer
==	O
NULL	O
)	O
{	O
message_in_echo_area	function
(	O
_	O
(	O
"%s is undefined"	pointer
)	O
,	O
pretty_keyseq	function
(	O
keys	pointer
)	O
)	O
;	O
return	O
;	O
}	O
else	O
if	O
(	O
map	pointer
[	O
keystroke	int
]	O
.	O
type	enum
==	O
ISKMAP	int
)	O
{	O
map	pointer
=	O
map	pointer
[	O
keystroke	int
]	O
.	O
value	union
.	O
keymap	pointer
;	O
continue	O
;	O
}	O
else	O
{	O
char	O
*	O
keyname	pointer
,	O
*	O
message	pointer
,	O
*	O
fundoc	pointer
,	O
*	O
funname	pointer
=	O
""	pointer
;	O
if	O
(	O
map	pointer
[	O
keystroke	int
]	O
.	O
value	union
.	O
function	pointer
&&	O
map	pointer
[	O
keystroke	int
]	O
.	O
value	union
.	O
function	pointer
->	O
func	pointer
==	O
info_do_lowercase_version	function
)	O
{	O
int	O
lowerkey	int
;	O
if	O
(	O
keystroke	int
>=	O
KEYMAP_META_BASE	int
)	O
{	O
lowerkey	int
=	O
keystroke	int
;	O
lowerkey	int
-=	O
KEYMAP_META_BASE	int
;	O
lowerkey	int
=	O
tolower	function
(	O
lowerkey	int
)	O
;	O
lowerkey	int
+=	O
KEYMAP_META_BASE	int
;	O
}	O
else	O
lowerkey	int
=	O
tolower	function
(	O
keystroke	int
)	O
;	O
if	O
(	O
map	pointer
[	O
lowerkey	int
]	O
.	O
value	union
.	O
function	pointer
==	O
NULL	O
)	O
{	O
message_in_echo_area	function
(	O
_	O
(	O
"%s is undefined"	pointer
)	O
,	O
pretty_keyseq	function
(	O
keys	pointer
)	O
)	O
;	O
return	O
;	O
}	O
}	O
keyname	pointer
=	O
pretty_keyseq	function
(	O
keys	pointer
)	O
;	O
funname	pointer
=	O
function_name	function
(	O
map	pointer
[	O
keystroke	int
]	O
.	O
value	union
.	O
function	pointer
)	O
;	O
fundoc	pointer
=	O
function_documentation	function
(	O
map	pointer
[	O
keystroke	int
]	O
.	O
value	union
.	O
function	pointer
)	O
;	O
message	pointer
=	O
xmalloc	function
(	O
10	int
+	O
strlen	function
(	O
keyname	pointer
)	O
+	O
strlen	function
(	O
fundoc	pointer
)	O
+	O
strlen	function
(	O
funname	pointer
)	O
)	O
;	O
sprintf	function
(	O
message	pointer
,	O
"%s (%s): %s."	pointer
,	O
keyname	pointer
,	O
funname	pointer
,	O
fundoc	pointer
)	O
;	O
window_message_in_echo_area	function
(	O
"%s"	pointer
,	O
message	pointer
)	O
;	O
free	function
(	O
message	pointer
)	O
;	O
break	O
;	O
}	O
}	O
}	O
char	O
*	O
pretty_keyname	function
(	O
int	O
key	int
)	O
{	O
static	O
char	O
rep_buffer	array
[	O
30	int
]	O
;	O
char	O
*	O
rep	pointer
;	O
if	O
(	O
key	int
>=	O
KEYMAP_META_BASE	int
)	O
{	O
char	O
temp	array
[	O
20	int
]	O
;	O
rep	pointer
=	O
pretty_keyname	function
(	O
key	int
-	O
KEYMAP_META_BASE	int
)	O
;	O
sprintf	function
(	O
temp	array
,	O
"M-%s"	pointer
,	O
rep	pointer
)	O
;	O
strcpy	function
(	O
rep_buffer	array
,	O
temp	array
)	O
;	O
rep	pointer
=	O
rep_buffer	array
;	O
}	O
else	O
if	O
(	O
Control_p	O
(	O
key	int
)	O
)	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
'\n'	O
:	O
rep	pointer
=	O
"LFD"	pointer
;	O
break	O
;	O
case	O
'\t'	O
:	O
rep	pointer
=	O
"TAB"	pointer
;	O
break	O
;	O
case	O
'\r'	O
:	O
rep	pointer
=	O
"RET"	pointer
;	O
break	O
;	O
case	O
ESC	char
:	O
rep	pointer
=	O
"ESC"	pointer
;	O
break	O
;	O
default	O
:	O
sprintf	function
(	O
rep_buffer	array
,	O
"C-%c"	pointer
,	O
UnControl	O
(	O
key	int
)	O
)	O
;	O
rep	pointer
=	O
rep_buffer	array
;	O
}	O
}	O
else	O
if	O
(	O
key	int
>=	O
256	int
)	O
switch	O
(	O
key	int
)	O
{	O
case	O
KEY_RIGHT_ARROW	int
:	O
rep	pointer
=	O
"Right"	pointer
;	O
break	O
;	O
case	O
KEY_LEFT_ARROW	int
:	O
rep	pointer
=	O
"Left"	pointer
;	O
break	O
;	O
case	O
KEY_UP_ARROW	int
:	O
rep	pointer
=	O
"Up"	pointer
;	O
break	O
;	O
case	O
KEY_DOWN_ARROW	int
:	O
rep	pointer
=	O
"Down"	pointer
;	O
break	O
;	O
case	O
KEY_PAGE_UP	int
:	O
rep	pointer
=	O
"PgUp"	pointer
;	O
break	O
;	O
case	O
KEY_PAGE_DOWN	int
:	O
rep	pointer
=	O
"PgDn"	pointer
;	O
break	O
;	O
case	O
KEY_HOME	int
:	O
rep	pointer
=	O
"Home"	pointer
;	O
break	O
;	O
case	O
KEY_END	int
:	O
rep	pointer
=	O
"End"	pointer
;	O
break	O
;	O
case	O
KEY_DELETE	int
:	O
rep	pointer
=	O
"DEL"	pointer
;	O
break	O
;	O
case	O
KEY_INSERT	int
:	O
rep	pointer
=	O
"INS"	pointer
;	O
break	O
;	O
case	O
KEY_BACK_TAB	int
:	O
rep	pointer
=	O
"BackTab"	pointer
;	O
break	O
;	O
case	O
KEY_MOUSE	int
:	O
rep	pointer
=	O
"(mouse event)"	pointer
;	O
break	O
;	O
default	O
:	O
rep	pointer
=	O
"(unknown key)"	pointer
;	O
break	O
;	O
}	O
else	O
{	O
switch	O
(	O
key	int
)	O
{	O
case	O
' '	O
:	O
rep	pointer
=	O
"SPC"	pointer
;	O
break	O
;	O
case	O
DEL	char
:	O
rep	pointer
=	O
"DEL"	pointer
;	O
break	O
;	O
default	O
:	O
rep_buffer	array
[	O
0	int
]	O
=	O
key	int
;	O
rep_buffer	array
[	O
1	int
]	O
=	O
'\0'	O
;	O
rep	pointer
=	O
rep_buffer	array
;	O
}	O
}	O
return	O
rep	pointer
;	O
}	O
char	O
*	O
pretty_keyseq	function
(	O
int	O
*	O
keyseq	pointer
)	O
{	O
static	O
struct	O
text_buffer	struct
rep	pointer
=	O
{	O
0	int
}	O
;	O
if	O
(	O
!	O
text_buffer_base	O
(	O
&	O
rep	pointer
)	O
)	O
text_buffer_init	function
(	O
&	O
rep	pointer
)	O
;	O
else	O
text_buffer_reset	O
(	O
&	O
rep	pointer
)	O
;	O
if	O
(	O
!	O
*	O
keyseq	pointer
)	O
return	O
""	pointer
;	O
while	O
(	O
1	int
)	O
{	O
text_buffer_printf	function
(	O
&	O
rep	pointer
,	O
"%s"	pointer
,	O
pretty_keyname	function
(	O
keyseq	pointer
[	O
0	int
]	O
)	O
)	O
;	O
keyseq	pointer
++	O
;	O
if	O
(	O
!	O
*	O
keyseq	pointer
)	O
break	O
;	O
text_buffer_add_char	function
(	O
&	O
rep	pointer
,	O
' '	O
)	O
;	O
}	O
return	O
text_buffer_base	O
(	O
&	O
rep	pointer
)	O
;	O
}	O
char	O
*	O
replace_in_documentation	function
(	O
const	O
char	O
*	O
string	pointer
,	O
int	O
help_is_only_window_p	int
)	O
{	O
register	O
int	O
i	int
,	O
start	int
;	O
static	O
struct	O
text_buffer	struct
txtresult	struct
=	O
{	O
0	int
}	O
;	O
text_buffer_free	function
(	O
&	O
txtresult	struct
)	O
;	O
text_buffer_init	function
(	O
&	O
txtresult	struct
)	O
;	O
text_buffer_alloc	function
(	O
&	O
txtresult	struct
,	O
strlen	function
(	O
string	pointer
)	O
)	O
;	O
start	int
=	O
0	int
;	O
for	O
(	O
i	int
=	O
start	int
;	O
string	pointer
[	O
i	int
]	O
;	O
i	int
++	O
)	O
{	O
int	O
j	int
=	O
i	int
+	O
1	int
;	O
if	O
(	O
string	pointer
[	O
i	int
]	O
==	O
'\\'	O
)	O
{	O
char	O
*	O
fmt	pointer
=	O
NULL	O
;	O
if	O
(	O
string	pointer
[	O
j	int
]	O
==	O
'%'	O
)	O
{	O
if	O
(	O
string	pointer
[	O
++	O
j	int
]	O
==	O
'-'	O
)	O
j	int
++	O
;	O
if	O
(	O
isdigit	function
(	O
string	pointer
[	O
j	int
]	O
)	O
)	O
{	O
while	O
(	O
isdigit	function
(	O
string	pointer
[	O
j	int
]	O
)	O
)	O
j	int
++	O
;	O
if	O
(	O
string	pointer
[	O
j	int
]	O
==	O
'.'	O
&&	O
isdigit	function
(	O
string	pointer
[	O
j	int
+	O
1	int
]	O
)	O
)	O
{	O
j	int
+=	O
1	int
;	O
while	O
(	O
isdigit	function
(	O
string	pointer
[	O
j	int
]	O
)	O
)	O
j	int
++	O
;	O
}	O
fmt	pointer
=	O
xmalloc	function
(	O
j	int
-	O
i	int
+	O
2	int
)	O
;	O
strncpy	function
(	O
fmt	pointer
,	O
string	pointer
+	O
i	int
+	O
1	int
,	O
j	int
-	O
i	int
)	O
;	O
fmt	pointer
[	O
j	int
-	O
i	int
-	O
1	int
]	O
=	O
's'	O
;	O
fmt	pointer
[	O
j	int
-	O
i	int
]	O
=	O
'\0'	O
;	O
}	O
else	O
j	int
=	O
i	int
+	O
1	int
;	O
}	O
if	O
(	O
string	pointer
[	O
j	int
]	O
==	O
'['	O
)	O
{	O
char	O
*	O
rep_name	pointer
,	O
*	O
fun_name	pointer
,	O
*	O
rep	pointer
;	O
InfoCommand	struct
*	O
command	pointer
;	O
unsigned	O
replen	int
;	O
text_buffer_add_string	function
(	O
&	O
txtresult	struct
,	O
string	pointer
+	O
start	int
,	O
i	int
-	O
start	int
)	O
;	O
start	int
=	O
j	int
+	O
1	int
;	O
for	O
(	O
i	int
=	O
start	int
;	O
string	pointer
[	O
i	int
]	O
&&	O
(	O
string	pointer
[	O
i	int
]	O
!=	O
']'	O
)	O
;	O
i	int
++	O
)	O
;	O
rep_name	pointer
=	O
xmalloc	function
(	O
1	int
+	O
i	int
-	O
start	int
)	O
;	O
strncpy	function
(	O
rep_name	pointer
,	O
string	pointer
+	O
start	int
,	O
i	int
-	O
start	int
)	O
;	O
rep_name	pointer
[	O
i	int
-	O
start	int
]	O
=	O
'\0'	O
;	O
start	int
=	O
i	int
;	O
if	O
(	O
string	pointer
[	O
start	int
]	O
==	O
']'	O
)	O
start	int
++	O
;	O
fun_name	pointer
=	O
rep_name	pointer
;	O
if	O
(	O
strcmp	function
(	O
rep_name	pointer
,	O
"quit-help"	pointer
)	O
==	O
0	int
)	O
{	O
fun_name	pointer
=	O
help_is_only_window_p	int
?	O
"history-node"	pointer
:	O
"get-help-window"	pointer
;	O
}	O
command	pointer
=	O
named_function	function
(	O
fun_name	pointer
)	O
;	O
free	function
(	O
rep_name	pointer
)	O
;	O
if	O
(	O
!	O
command	pointer
)	O
abort	function
(	O
)	O
;	O
rep	pointer
=	O
where_is	function
(	O
info_keymap	pointer
,	O
command	pointer
)	O
;	O
if	O
(	O
!	O
rep	pointer
)	O
rep	pointer
=	O
"N/A"	pointer
;	O
replen	int
=	O
strlen	function
(	O
rep	pointer
)	O
;	O
if	O
(	O
fmt	pointer
)	O
text_buffer_printf	function
(	O
&	O
txtresult	struct
,	O
fmt	pointer
,	O
rep	pointer
)	O
;	O
else	O
text_buffer_add_string	function
(	O
&	O
txtresult	struct
,	O
rep	pointer
,	O
replen	int
)	O
;	O
}	O
free	function
(	O
fmt	pointer
)	O
;	O
}	O
}	O
text_buffer_add_string	function
(	O
&	O
txtresult	struct
,	O
string	pointer
+	O
start	int
,	O
strlen	function
(	O
string	pointer
+	O
start	int
)	O
+	O
1	int
)	O
;	O
return	O
text_buffer_base	O
(	O
&	O
txtresult	struct
)	O
;	O
}	O
static	O
char	O
*	O
where_is_rep	pointer
=	O
NULL	O
;	O
static	O
int	O
where_is_rep_index	int
=	O
0	int
;	O
static	O
int	O
where_is_rep_size	int
=	O
0	int
;	O
char	O
*	O
where_is	function
(	O
Keymap	pointer
map	pointer
,	O
InfoCommand	struct
*	O
cmd	pointer
)	O
{	O
char	O
*	O
rep	pointer
;	O
if	O
(	O
!	O
where_is_rep_size	int
)	O
where_is_rep	pointer
=	O
xmalloc	function
(	O
where_is_rep_size	int
=	O
100	int
)	O
;	O
where_is_rep_index	int
=	O
0	int
;	O
rep	pointer
=	O
where_is_internal	function
(	O
map	pointer
,	O
cmd	pointer
)	O
;	O
if	O
(	O
!	O
rep	pointer
)	O
{	O
char	O
*	O
name	pointer
;	O
name	pointer
=	O
function_name	function
(	O
cmd	pointer
)	O
;	O
if	O
(	O
!	O
name	pointer
)	O
return	O
NULL	O
;	O
rep	pointer
=	O
where_is_internal	function
(	O
map	pointer
,	O
InfoCmd	O
(	O
info_execute_command	function
)	O
)	O
;	O
if	O
(	O
!	O
rep	pointer
)	O
return	O
""	pointer
;	O
sprintf	function
(	O
where_is_rep	pointer
,	O
"%s %s"	pointer
,	O
rep	pointer
,	O
name	pointer
)	O
;	O
rep	pointer
=	O
where_is_rep	pointer
;	O
}	O
return	O
rep	pointer
;	O
}	O
static	O
char	O
*	O
where_is_internal	function
(	O
Keymap	pointer
map	pointer
,	O
InfoCommand	struct
*	O
cmd	pointer
)	O
{	O
register	O
FUNCTION_KEYSEQ	struct
*	O
k	pointer
;	O
for	O
(	O
k	pointer
=	O
cmd	pointer
->	O
keys	pointer
;	O
k	pointer
;	O
k	pointer
=	O
k	pointer
->	O
next	pointer
)	O
if	O
(	O
k	pointer
->	O
map	pointer
==	O
map	pointer
)	O
return	O
pretty_keyseq	function
(	O
k	pointer
->	O
keyseq	pointer
)	O
;	O
return	O
NULL	O
;	O
}	O
DECLARE_INFO_COMMAND	O
(	O
info_where_is	function
,	O
_	O
(	O
"Show what to type to execute a given command"	pointer
)	O
)	O
{	O
char	O
*	O
command_name	pointer
;	O
command_name	pointer
=	O
read_function_name	function
(	O
_	O
(	O
"Where is command: "	pointer
)	O
,	O
window	pointer
)	O
;	O
if	O
(	O
!	O
command_name	pointer
)	O
{	O
info_abort_key	function
(	O
active_window	pointer
,	O
count	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
*	O
command_name	pointer
)	O
{	O
InfoCommand	struct
*	O
command	pointer
;	O
command	pointer
=	O
named_function	function
(	O
command_name	pointer
)	O
;	O
if	O
(	O
command	pointer
)	O
{	O
char	O
*	O
location	pointer
;	O
location	pointer
=	O
where_is	function
(	O
info_keymap	pointer
,	O
command	pointer
)	O
;	O
if	O
(	O
!	O
location	pointer
||	O
!	O
location	pointer
[	O
0	int
]	O
)	O
{	O
info_error	function
(	O
_	O
(	O
"'%s' is not on any keys"	pointer
)	O
,	O
command_name	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
strstr	function
(	O
location	pointer
,	O
function_name	function
(	O
command	pointer
)	O
)	O
)	O
window_message_in_echo_area	function
(	O
_	O
(	O
"%s can only be invoked via %s"	pointer
)	O
,	O
command_name	pointer
,	O
location	pointer
)	O
;	O
else	O
window_message_in_echo_area	function
(	O
_	O
(	O
"%s can be invoked via %s"	pointer
)	O
,	O
command_name	pointer
,	O
location	pointer
)	O
;	O
}	O
}	O
else	O
info_error	function
(	O
_	O
(	O
"There is no function named '%s'"	pointer
)	O
,	O
command_name	pointer
)	O
;	O
}	O
free	function
(	O
command_name	pointer
)	O
;	O
}	O
