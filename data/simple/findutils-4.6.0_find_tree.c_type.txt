static	O
struct	O
predicate	struct
*	O
predicates	pointer
=	O
NULL	O
;	O
static	O
struct	O
predicate	struct
*	O
eval_tree	pointer
=	O
NULL	O
;	O
static	O
struct	O
predicate	struct
*	O
last_pred	pointer
=	O
NULL	O
;	O
static	O
char	O
*	O
*	O
start_points	pointer
;	O
static	O
size_t	long
num_start_points	long
=	O
0	int
;	O
static	O
struct	O
predicate	struct
*	O
scan_rest	function
(	O
struct	O
predicate	struct
*	O
*	O
input	pointer
,	O
struct	O
predicate	struct
*	O
head	pointer
,	O
short	O
int	O
prev_prec	short
)	O
;	O
static	O
void	O
merge_pred	function
(	O
struct	O
predicate	struct
*	O
beg_list	pointer
,	O
struct	O
predicate	struct
*	O
end_list	pointer
,	O
struct	O
predicate	struct
*	O
*	O
last_p	pointer
)	O
;	O
static	O
struct	O
predicate	struct
*	O
set_new_parent	function
(	O
struct	O
predicate	struct
*	O
curr	pointer
,	O
enum	O
predicate_precedence	enum
high_prec	enum
,	O
struct	O
predicate	struct
*	O
*	O
prevp	pointer
)	O
;	O
static	O
const	O
char	O
*	O
cost_name	function
(	O
enum	O
EvaluationCost	enum
cost	enum
)	O
;	O
bool	bool
matches_start_point	function
(	O
const	O
char	O
*	O
glob	pointer
,	O
bool	bool
foldcase	bool
)	O
{	O
int	O
fnmatch_flags	int
=	O
0	int
;	O
if	O
(	O
foldcase	bool
)	O
fnmatch_flags	int
|=	O
FNM_CASEFOLD	O
;	O
if	O
(	O
num_start_points	long
)	O
{	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
num_start_points	long
;	O
i	int
++	O
)	O
{	O
if	O
(	O
fnmatch	function
(	O
glob	pointer
,	O
start_points	pointer
[	O
i	int
]	O
,	O
fnmatch_flags	int
)	O
==	O
0	int
)	O
return	O
true	int
;	O
}	O
return	O
false	int
;	O
}	O
else	O
{	O
return	O
fnmatch	function
(	O
glob	pointer
,	O
"."	pointer
,	O
fnmatch_flags	int
)	O
==	O
0	int
;	O
}	O
}	O
static	O
struct	O
predicate	struct
*	O
get_expr	function
(	O
struct	O
predicate	struct
*	O
*	O
input	pointer
,	O
short	O
int	O
prev_prec	short
,	O
const	O
struct	O
predicate	struct
*	O
prev_pred	pointer
)	O
{	O
struct	O
predicate	struct
*	O
next	pointer
=	O
NULL	O
;	O
struct	O
predicate	struct
*	O
this_pred	pointer
=	O
(	O
*	O
input	pointer
)	O
;	O
if	O
(	O
*	O
input	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid expression"	pointer
)	O
)	O
;	O
switch	O
(	O
(	O
*	O
input	pointer
)	O
->	O
p_type	enum
)	O
{	O
case	O
NO_TYPE	int
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid expression"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
BI_OP	int
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid expression; you have used a binary operator '%s' with nothing before it."	pointer
)	O
,	O
this_pred	pointer
->	O
p_name	pointer
)	O
;	O
break	O
;	O
case	O
CLOSE_PAREN	int
:	O
if	O
(	O
(	O
UNI_OP	int
==	O
prev_pred	pointer
->	O
p_type	enum
||	O
BI_OP	int
==	O
prev_pred	pointer
->	O
p_type	enum
)	O
&&	O
!	O
this_pred	pointer
->	O
artificial	bool
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"expected an expression between '%s' and ')'"	pointer
)	O
,	O
prev_pred	pointer
->	O
p_name	pointer
)	O
;	O
}	O
else	O
if	O
(	O
(	O
*	O
input	pointer
)	O
->	O
artificial	bool
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"expected an expression after '%s'"	pointer
)	O
,	O
prev_pred	pointer
->	O
p_name	pointer
)	O
;	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid expression; you have too many ')'"	pointer
)	O
)	O
;	O
}	O
break	O
;	O
case	O
PRIMARY_TYPE	int
:	O
next	pointer
=	O
*	O
input	pointer
;	O
*	O
input	pointer
=	O
(	O
*	O
input	pointer
)	O
->	O
pred_next	pointer
;	O
break	O
;	O
case	O
UNI_OP	int
:	O
next	pointer
=	O
*	O
input	pointer
;	O
*	O
input	pointer
=	O
(	O
*	O
input	pointer
)	O
->	O
pred_next	pointer
;	O
next	pointer
->	O
pred_right	pointer
=	O
get_expr	function
(	O
input	pointer
,	O
NEGATE_PREC	int
,	O
next	pointer
)	O
;	O
break	O
;	O
case	O
OPEN_PAREN	int
:	O
if	O
(	O
(	O
NULL	O
==	O
(	O
*	O
input	pointer
)	O
->	O
pred_next	pointer
)	O
||	O
(	O
*	O
input	pointer
)	O
->	O
pred_next	pointer
->	O
artificial	bool
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid expression; expected to find a ')' but didn't see one.  Perhaps you need an extra predicate after '%s'"	pointer
)	O
,	O
this_pred	pointer
->	O
p_name	pointer
)	O
;	O
}	O
prev_pred	pointer
=	O
(	O
*	O
input	pointer
)	O
;	O
*	O
input	pointer
=	O
(	O
*	O
input	pointer
)	O
->	O
pred_next	pointer
;	O
if	O
(	O
(	O
*	O
input	pointer
)	O
->	O
p_type	enum
==	O
CLOSE_PAREN	int
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid expression; empty parentheses are not allowed."	pointer
)	O
)	O
;	O
}	O
next	pointer
=	O
get_expr	function
(	O
input	pointer
,	O
NO_PREC	int
,	O
prev_pred	pointer
)	O
;	O
if	O
(	O
(	O
*	O
input	pointer
==	O
NULL	O
)	O
||	O
(	O
(	O
*	O
input	pointer
)	O
->	O
p_type	enum
!=	O
CLOSE_PAREN	int
)	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid expression; I was expecting to find a ')' somewhere but did not see one."	pointer
)	O
)	O
;	O
*	O
input	pointer
=	O
(	O
*	O
input	pointer
)	O
->	O
pred_next	pointer
;	O
break	O
;	O
default	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"oops -- invalid expression type!"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
*	O
input	pointer
==	O
NULL	O
)	O
return	O
(	O
next	pointer
)	O
;	O
if	O
(	O
(	O
int	O
)	O
(	O
*	O
input	pointer
)	O
->	O
p_prec	enum
>	O
(	O
int	O
)	O
prev_prec	short
)	O
{	O
next	pointer
=	O
scan_rest	function
(	O
input	pointer
,	O
next	pointer
,	O
prev_prec	short
)	O
;	O
if	O
(	O
next	pointer
==	O
NULL	O
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid expression"	pointer
)	O
)	O
;	O
}	O
return	O
(	O
next	pointer
)	O
;	O
}	O
static	O
struct	O
predicate	struct
*	O
scan_rest	function
(	O
struct	O
predicate	struct
*	O
*	O
input	pointer
,	O
struct	O
predicate	struct
*	O
head	pointer
,	O
short	O
int	O
prev_prec	short
)	O
{	O
struct	O
predicate	struct
*	O
tree	pointer
;	O
if	O
(	O
(	O
*	O
input	pointer
==	O
NULL	O
)	O
||	O
(	O
(	O
*	O
input	pointer
)	O
->	O
p_type	enum
==	O
CLOSE_PAREN	int
)	O
)	O
return	O
(	O
NULL	O
)	O
;	O
tree	pointer
=	O
head	pointer
;	O
while	O
(	O
(	O
*	O
input	pointer
!=	O
NULL	O
)	O
&&	O
(	O
(	O
int	O
)	O
(	O
*	O
input	pointer
)	O
->	O
p_prec	enum
>	O
(	O
int	O
)	O
prev_prec	short
)	O
)	O
{	O
switch	O
(	O
(	O
*	O
input	pointer
)	O
->	O
p_type	enum
)	O
{	O
case	O
NO_TYPE	int
:	O
case	O
PRIMARY_TYPE	int
:	O
case	O
UNI_OP	int
:	O
case	O
OPEN_PAREN	int
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid expression"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
BI_OP	int
:	O
{	O
struct	O
predicate	struct
*	O
prev	pointer
=	O
(	O
*	O
input	pointer
)	O
;	O
(	O
*	O
input	pointer
)	O
->	O
pred_left	pointer
=	O
tree	pointer
;	O
tree	pointer
=	O
*	O
input	pointer
;	O
*	O
input	pointer
=	O
(	O
*	O
input	pointer
)	O
->	O
pred_next	pointer
;	O
tree	pointer
->	O
pred_right	pointer
=	O
get_expr	function
(	O
input	pointer
,	O
tree	pointer
->	O
p_prec	enum
,	O
prev	pointer
)	O
;	O
break	O
;	O
}	O
case	O
CLOSE_PAREN	int
:	O
return	O
tree	pointer
;	O
default	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"oops -- invalid expression type (%d)!"	pointer
)	O
,	O
(	O
int	O
)	O
(	O
*	O
input	pointer
)	O
->	O
p_type	enum
)	O
;	O
break	O
;	O
}	O
}	O
return	O
tree	pointer
;	O
}	O
static	O
bool	bool
predicate_is_cost_free	function
(	O
const	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_name	function
)	O
||	O
pred_is	O
(	O
p	pointer
,	O
pred_path	function
)	O
||	O
pred_is	O
(	O
p	pointer
,	O
pred_iname	function
)	O
||	O
pred_is	O
(	O
p	pointer
,	O
pred_ipath	function
)	O
)	O
{	O
return	O
true	int
;	O
}	O
else	O
if	O
(	O
options	struct
.	O
optimisation_level	short
>	O
0	int
)	O
{	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_and	function
)	O
||	O
pred_is	O
(	O
p	pointer
,	O
pred_negate	function
)	O
||	O
pred_is	O
(	O
p	pointer
,	O
pred_comma	function
)	O
||	O
pred_is	O
(	O
p	pointer
,	O
pred_or	function
)	O
)	O
return	O
false	int
;	O
else	O
return	O
NeedsNothing	int
==	O
p	pointer
->	O
p_cost	enum
;	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
void	O
print_predicate	function
(	O
FILE	struct
*	O
fp	pointer
,	O
const	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
->	O
arg_text	pointer
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s %s"	pointer
,	O
p	pointer
->	O
p_name	pointer
,	O
p	pointer
->	O
arg_text	pointer
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%s"	pointer
,	O
p	pointer
->	O
p_name	pointer
)	O
;	O
}	O
}	O
struct	O
predlist	struct
{	O
struct	O
predicate	struct
*	O
head	pointer
;	O
struct	O
predicate	struct
*	O
tail	pointer
;	O
}	O
;	O
static	O
void	O
predlist_init	function
(	O
struct	O
predlist	struct
*	O
p	pointer
)	O
{	O
p	pointer
->	O
head	pointer
=	O
p	pointer
->	O
tail	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
predlist_insert	function
(	O
struct	O
predlist	struct
*	O
list	pointer
,	O
struct	O
predicate	struct
*	O
curr	pointer
,	O
struct	O
predicate	struct
*	O
*	O
pprev	pointer
)	O
{	O
struct	O
predicate	struct
*	O
*	O
insertpos	pointer
=	O
&	O
(	O
list	pointer
->	O
head	pointer
)	O
;	O
*	O
pprev	pointer
=	O
curr	pointer
->	O
pred_left	pointer
;	O
curr	pointer
->	O
pred_left	pointer
=	O
(	O
*	O
insertpos	pointer
)	O
;	O
(	O
*	O
insertpos	pointer
)	O
=	O
curr	pointer
;	O
if	O
(	O
NULL	O
==	O
list	pointer
->	O
tail	pointer
)	O
list	pointer
->	O
tail	pointer
=	O
list	pointer
->	O
head	pointer
;	O
}	O
static	O
int	O
pred_cost_compare	function
(	O
const	O
struct	O
predicate	struct
*	O
p1	pointer
,	O
const	O
struct	O
predicate	struct
*	O
p2	pointer
,	O
bool	bool
wantfailure	bool
)	O
{	O
if	O
(	O
p1	pointer
->	O
p_cost	enum
==	O
p2	pointer
->	O
p_cost	enum
)	O
{	O
if	O
(	O
p1	pointer
->	O
est_success_rate	float
==	O
p2	pointer
->	O
est_success_rate	float
)	O
return	O
0	int
;	O
else	O
if	O
(	O
wantfailure	bool
)	O
return	O
p1	pointer
->	O
est_success_rate	float
<	O
p2	pointer
->	O
est_success_rate	float
?	O
-	O
1	int
:	O
1	int
;	O
else	O
return	O
p1	pointer
->	O
est_success_rate	float
<	O
p2	pointer
->	O
est_success_rate	float
?	O
1	int
:	O
-	O
1	int
;	O
}	O
else	O
{	O
return	O
p1	pointer
->	O
p_cost	enum
<	O
p2	pointer
->	O
p_cost	enum
?	O
-	O
1	int
:	O
1	int
;	O
}	O
}	O
static	O
void	O
predlist_merge_sort	function
(	O
struct	O
predlist	struct
*	O
list	pointer
,	O
struct	O
predicate	struct
*	O
*	O
last	pointer
)	O
{	O
struct	O
predlist	struct
new_list	struct
;	O
struct	O
predicate	struct
*	O
p	pointer
,	O
*	O
q	pointer
;	O
if	O
(	O
NULL	O
==	O
list	pointer
->	O
head	pointer
)	O
return	O
;	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugTreeOpt	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:\n"	pointer
,	O
"predlist before merge sort"	pointer
)	O
;	O
print_tree	function
(	O
stderr	pointer
,	O
list	pointer
->	O
head	pointer
,	O
2	int
)	O
;	O
}	O
calculate_derived_rates	function
(	O
list	pointer
->	O
head	pointer
)	O
;	O
predlist_init	function
(	O
&	O
new_list	struct
)	O
;	O
while	O
(	O
list	pointer
->	O
head	pointer
)	O
{	O
q	pointer
=	O
list	pointer
->	O
head	pointer
;	O
list	pointer
->	O
head	pointer
=	O
list	pointer
->	O
head	pointer
->	O
pred_left	pointer
;	O
q	pointer
->	O
pred_left	pointer
=	O
NULL	O
;	O
for	O
(	O
p	pointer
=	O
new_list	struct
.	O
head	pointer
;	O
p	pointer
;	O
p	pointer
=	O
p	pointer
->	O
pred_left	pointer
)	O
{	O
const	O
bool	bool
wantfailure	bool
=	O
(	O
OR_PREC	int
!=	O
p	pointer
->	O
p_prec	enum
)	O
;	O
if	O
(	O
pred_cost_compare	function
(	O
p	pointer
->	O
pred_right	pointer
,	O
q	pointer
->	O
pred_right	pointer
,	O
wantfailure	bool
)	O
>=	O
0	int
)	O
break	O
;	O
}	O
if	O
(	O
p	pointer
)	O
{	O
q	pointer
->	O
pred_left	pointer
=	O
p	pointer
->	O
pred_left	pointer
;	O
if	O
(	O
NULL	O
==	O
q	pointer
->	O
pred_left	pointer
)	O
new_list	struct
.	O
tail	pointer
=	O
q	pointer
;	O
p	pointer
->	O
pred_left	pointer
=	O
q	pointer
;	O
}	O
else	O
{	O
q	pointer
->	O
pred_left	pointer
=	O
new_list	struct
.	O
head	pointer
;	O
new_list	struct
.	O
head	pointer
=	O
q	pointer
;	O
if	O
(	O
NULL	O
==	O
new_list	struct
.	O
tail	pointer
)	O
new_list	struct
.	O
tail	pointer
=	O
q	pointer
;	O
}	O
}	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugTreeOpt	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s:\n"	pointer
,	O
"predlist after merge sort"	pointer
)	O
;	O
print_tree	function
(	O
stderr	pointer
,	O
new_list	struct
.	O
head	pointer
,	O
2	int
)	O
;	O
}	O
calculate_derived_rates	function
(	O
new_list	struct
.	O
head	pointer
)	O
;	O
merge_pred	function
(	O
new_list	struct
.	O
head	pointer
,	O
new_list	struct
.	O
tail	pointer
,	O
last	pointer
)	O
;	O
predlist_init	function
(	O
list	pointer
)	O
;	O
}	O
static	O
void	O
merge_lists	function
(	O
struct	O
predlist	struct
lists	array
[	O
]	O
,	O
int	O
nlists	int
,	O
struct	O
predlist	struct
*	O
name_list	pointer
,	O
struct	O
predlist	struct
*	O
regex_list	pointer
,	O
struct	O
predicate	struct
*	O
*	O
last	pointer
)	O
{	O
int	O
i	int
;	O
static	O
void	O
(	O
*	O
mergefn	pointer
)	O
(	O
struct	O
predlist	struct
*	O
,	O
struct	O
predicate	struct
*	O
*	O
)	O
;	O
mergefn	pointer
=	O
predlist_merge_sort	function
;	O
mergefn	pointer
(	O
name_list	pointer
,	O
last	pointer
)	O
;	O
mergefn	pointer
(	O
regex_list	pointer
,	O
last	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
nlists	int
;	O
i	int
++	O
)	O
mergefn	pointer
(	O
&	O
lists	array
[	O
i	int
]	O
,	O
last	pointer
)	O
;	O
}	O
static	O
bool	bool
subtree_has_side_effects	function
(	O
const	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
)	O
{	O
return	O
p	pointer
->	O
side_effects	bool
||	O
subtree_has_side_effects	function
(	O
p	pointer
->	O
pred_left	pointer
)	O
||	O
subtree_has_side_effects	function
(	O
p	pointer
->	O
pred_right	pointer
)	O
;	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
static	O
int	O
worst_cost	function
(	O
const	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
)	O
{	O
unsigned	O
int	O
cost_r	int
,	O
cost_l	int
,	O
worst	int
;	O
cost_l	int
=	O
worst_cost	function
(	O
p	pointer
->	O
pred_left	pointer
)	O
;	O
cost_r	int
=	O
worst_cost	function
(	O
p	pointer
->	O
pred_right	pointer
)	O
;	O
worst	int
=	O
(	O
cost_l	int
>	O
cost_r	int
)	O
?	O
cost_l	int
:	O
cost_r	int
;	O
if	O
(	O
worst	int
<	O
p	pointer
->	O
p_cost	enum
)	O
worst	int
=	O
p	pointer
->	O
p_cost	enum
;	O
return	O
worst	int
;	O
}	O
else	O
{	O
return	O
0	int
;	O
}	O
}	O
static	O
void	O
perform_arm_swap	function
(	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
struct	O
predicate	struct
*	O
tmp	pointer
=	O
p	pointer
->	O
pred_left	pointer
->	O
pred_right	pointer
;	O
p	pointer
->	O
pred_left	pointer
->	O
pred_right	pointer
=	O
p	pointer
->	O
pred_right	pointer
;	O
p	pointer
->	O
pred_right	pointer
=	O
tmp	pointer
;	O
}	O
static	O
bool	bool
consider_arm_swap	function
(	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
int	O
left_cost	int
,	O
right_cost	int
;	O
const	O
char	O
*	O
reason	pointer
=	O
NULL	O
;	O
struct	O
predicate	struct
*	O
*	O
pl	pointer
,	O
*	O
*	O
pr	pointer
;	O
if	O
(	O
BI_OP	int
!=	O
p	pointer
->	O
p_type	enum
)	O
reason	pointer
=	O
"Not a binary operation"	pointer
;	O
if	O
(	O
!	O
reason	pointer
)	O
{	O
if	O
(	O
NULL	O
==	O
p	pointer
->	O
pred_left	pointer
||	O
NULL	O
==	O
p	pointer
->	O
pred_right	pointer
)	O
reason	pointer
=	O
"Doesn't have two arms"	pointer
;	O
}	O
if	O
(	O
!	O
reason	pointer
)	O
{	O
if	O
(	O
NULL	O
==	O
p	pointer
->	O
pred_left	pointer
->	O
pred_right	pointer
)	O
reason	pointer
=	O
"Left arm has no child on RHS"	pointer
;	O
}	O
pr	pointer
=	O
&	O
p	pointer
->	O
pred_right	pointer
;	O
pl	pointer
=	O
&	O
p	pointer
->	O
pred_left	pointer
->	O
pred_right	pointer
;	O
if	O
(	O
!	O
reason	pointer
)	O
{	O
if	O
(	O
subtree_has_side_effects	function
(	O
*	O
pl	pointer
)	O
)	O
reason	pointer
=	O
"Left subtree has side-effects"	pointer
;	O
}	O
if	O
(	O
!	O
reason	pointer
)	O
{	O
if	O
(	O
subtree_has_side_effects	function
(	O
*	O
pr	pointer
)	O
)	O
reason	pointer
=	O
"Right subtree has side-effects"	pointer
;	O
}	O
if	O
(	O
!	O
reason	pointer
)	O
{	O
left_cost	int
=	O
worst_cost	function
(	O
*	O
pl	pointer
)	O
;	O
right_cost	int
=	O
worst_cost	function
(	O
*	O
pr	pointer
)	O
;	O
if	O
(	O
left_cost	int
<	O
right_cost	int
)	O
{	O
reason	pointer
=	O
"efficient as-is"	pointer
;	O
}	O
}	O
if	O
(	O
!	O
reason	pointer
)	O
{	O
bool	bool
want_swap	bool
;	O
if	O
(	O
left_cost	int
==	O
right_cost	int
)	O
{	O
float	O
succ_rate_l	float
=	O
(	O
*	O
pl	pointer
)	O
->	O
est_success_rate	float
;	O
float	O
succ_rate_r	float
=	O
(	O
*	O
pr	pointer
)	O
->	O
est_success_rate	float
;	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugTreeOpt	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Success rates: l=%f, r=%f\n"	pointer
,	O
succ_rate_l	float
,	O
succ_rate_r	float
)	O
;	O
}	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_or	function
)	O
)	O
{	O
want_swap	bool
=	O
succ_rate_r	float
<	O
succ_rate_l	float
;	O
if	O
(	O
!	O
want_swap	bool
)	O
reason	pointer
=	O
"Operation is OR; right success rate >= left"	pointer
;	O
}	O
else	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_and	function
)	O
)	O
{	O
want_swap	bool
=	O
succ_rate_r	float
>	O
succ_rate_l	float
;	O
if	O
(	O
!	O
want_swap	bool
)	O
reason	pointer
=	O
"Operation is AND; right success rate <= left"	pointer
;	O
}	O
else	O
{	O
want_swap	bool
=	O
false	int
;	O
reason	pointer
=	O
"Not 'AND' or 'OR'"	pointer
;	O
}	O
}	O
else	O
{	O
want_swap	bool
=	O
true	int
;	O
}	O
if	O
(	O
want_swap	bool
)	O
{	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugTreeOpt	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Performing arm swap on:\n"	pointer
)	O
;	O
print_tree	function
(	O
stderr	pointer
,	O
p	pointer
,	O
0	int
)	O
;	O
}	O
perform_arm_swap	function
(	O
p	pointer
)	O
;	O
return	O
true	int
;	O
}	O
}	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugTreeOpt	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Not an arm swap candidate (%s):\n"	pointer
,	O
reason	pointer
)	O
;	O
print_tree	function
(	O
stderr	pointer
,	O
p	pointer
,	O
0	int
)	O
;	O
}	O
return	O
false	int
;	O
}	O
static	O
bool	bool
do_arm_swaps	function
(	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
)	O
{	O
bool	bool
swapped	bool
;	O
do	O
{	O
swapped	bool
=	O
false	int
;	O
if	O
(	O
consider_arm_swap	function
(	O
p	pointer
)	O
||	O
do_arm_swaps	function
(	O
p	pointer
->	O
pred_left	pointer
)	O
||	O
do_arm_swaps	function
(	O
p	pointer
->	O
pred_right	pointer
)	O
)	O
{	O
swapped	bool
=	O
true	int
;	O
}	O
}	O
while	O
(	O
swapped	bool
)	O
;	O
return	O
swapped	bool
;	O
}	O
else	O
{	O
return	O
false	int
;	O
}	O
}	O
static	O
bool	bool
opt_expr	function
(	O
struct	O
predicate	struct
*	O
*	O
eval_treep	pointer
)	O
{	O
struct	O
predlist	struct
regex_list	pointer
=	O
{	O
NULL	O
,	O
NULL	O
}	O
,	O
name_list	pointer
=	O
{	O
NULL	O
,	O
NULL	O
}	O
;	O
struct	O
predlist	struct
cbo_list	array
[	O
NumEvaluationCosts	int
]	O
;	O
int	O
i	int
;	O
struct	O
predicate	struct
*	O
curr	pointer
;	O
struct	O
predicate	struct
*	O
*	O
prevp	pointer
;	O
struct	O
predicate	struct
*	O
*	O
last_sidep	pointer
;	O
PRED_FUNC	pointer
pred_func	pointer
;	O
enum	O
predicate_type	enum
p_type	enum
;	O
bool	bool
has_side_effects	bool
=	O
false	int
;	O
enum	O
predicate_precedence	enum
prev_prec	short
,	O
biop_prec	enum
;	O
if	O
(	O
eval_treep	pointer
==	O
NULL	O
||	O
*	O
eval_treep	pointer
==	O
NULL	O
)	O
return	O
(	O
false	int
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
NumEvaluationCosts	int
;	O
i	int
++	O
)	O
predlist_init	function
(	O
&	O
cbo_list	array
[	O
i	int
]	O
)	O
;	O
prevp	pointer
=	O
eval_treep	pointer
;	O
prev_prec	short
=	O
AND_PREC	int
;	O
curr	pointer
=	O
*	O
prevp	pointer
;	O
while	O
(	O
curr	pointer
->	O
pred_left	pointer
!=	O
NULL	O
)	O
{	O
prevp	pointer
=	O
&	O
curr	pointer
->	O
pred_left	pointer
;	O
prev_prec	short
=	O
curr	pointer
->	O
p_prec	enum
;	O
curr	pointer
=	O
curr	pointer
->	O
pred_left	pointer
;	O
}	O
if	O
(	O
curr	pointer
->	O
p_type	enum
!=	O
BI_OP	int
)	O
set_new_parent	function
(	O
curr	pointer
,	O
prev_prec	short
,	O
prevp	pointer
)	O
;	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
(	O
DebugExpressionTree	int
|	O
DebugTreeOpt	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Normalized Eval Tree:\n"	pointer
)	O
;	O
print_tree	function
(	O
stderr	pointer
,	O
*	O
eval_treep	pointer
,	O
0	int
)	O
;	O
}	O
prevp	pointer
=	O
eval_treep	pointer
;	O
biop_prec	enum
=	O
NO_PREC	int
;	O
if	O
(	O
(	O
*	O
prevp	pointer
)	O
&&	O
(	O
*	O
prevp	pointer
)	O
->	O
p_type	enum
==	O
BI_OP	int
)	O
biop_prec	enum
=	O
(	O
*	O
prevp	pointer
)	O
->	O
p_prec	enum
;	O
while	O
(	O
(	O
curr	pointer
=	O
*	O
prevp	pointer
)	O
!=	O
NULL	O
)	O
{	O
if	O
(	O
curr	pointer
->	O
p_type	enum
==	O
BI_OP	int
)	O
{	O
if	O
(	O
curr	pointer
->	O
p_prec	enum
!=	O
biop_prec	enum
)	O
curr	pointer
=	O
set_new_parent	function
(	O
curr	pointer
,	O
biop_prec	enum
,	O
prevp	pointer
)	O
;	O
}	O
p_type	enum
=	O
curr	pointer
->	O
pred_right	pointer
->	O
p_type	enum
;	O
pred_func	pointer
=	O
curr	pointer
->	O
pred_right	pointer
->	O
pred_func	pointer
;	O
switch	O
(	O
p_type	enum
)	O
{	O
case	O
NO_TYPE	int
:	O
case	O
PRIMARY_TYPE	int
:	O
if	O
(	O
biop_prec	enum
==	O
COMMA_PREC	int
)	O
break	O
;	O
if	O
(	O
!	O
curr	pointer
->	O
pred_right	pointer
->	O
side_effects	bool
)	O
{	O
bool	bool
reorder	bool
;	O
if	O
(	O
predicate_is_cost_free	function
(	O
curr	pointer
->	O
pred_right	pointer
)	O
)	O
{	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugTreeOpt	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"-O%d: promoting cheap predicate "	pointer
,	O
(	O
int	O
)	O
options	struct
.	O
optimisation_level	short
)	O
;	O
print_predicate	function
(	O
stderr	pointer
,	O
curr	pointer
->	O
pred_right	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
" into name_list\n"	pointer
)	O
;	O
}	O
predlist_insert	function
(	O
&	O
name_list	pointer
,	O
curr	pointer
,	O
prevp	pointer
)	O
;	O
continue	O
;	O
}	O
if	O
(	O
pred_func	pointer
==	O
pred_regex	function
)	O
{	O
predlist_insert	function
(	O
&	O
regex_list	pointer
,	O
curr	pointer
,	O
prevp	pointer
)	O
;	O
continue	O
;	O
}	O
reorder	bool
=	O
(	O
(	O
options	struct
.	O
optimisation_level	short
>	O
1	int
)	O
&&	O
(	O
NeedsType	int
==	O
curr	pointer
->	O
pred_right	pointer
->	O
p_cost	enum
||	O
NeedsInodeNumber	int
==	O
curr	pointer
->	O
pred_right	pointer
->	O
p_cost	enum
)	O
&&	O
!	O
curr	pointer
->	O
pred_right	pointer
->	O
need_stat	bool
)	O
||	O
(	O
options	struct
.	O
optimisation_level	short
>	O
2	int
)	O
;	O
if	O
(	O
reorder	bool
)	O
{	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
DebugTreeOpt	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"-O%d: categorising predicate "	pointer
,	O
(	O
int	O
)	O
options	struct
.	O
optimisation_level	short
)	O
;	O
print_predicate	function
(	O
stderr	pointer
,	O
curr	pointer
->	O
pred_right	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
" by cost (%s)\n"	pointer
,	O
cost_name	function
(	O
curr	pointer
->	O
pred_right	pointer
->	O
p_cost	enum
)	O
)	O
;	O
}	O
predlist_insert	function
(	O
&	O
cbo_list	array
[	O
curr	pointer
->	O
pred_right	pointer
->	O
p_cost	enum
]	O
,	O
curr	pointer
,	O
prevp	pointer
)	O
;	O
continue	O
;	O
}	O
}	O
break	O
;	O
case	O
UNI_OP	int
:	O
curr	pointer
->	O
pred_right	pointer
->	O
side_effects	bool
=	O
opt_expr	function
(	O
&	O
curr	pointer
->	O
pred_right	pointer
->	O
pred_right	pointer
)	O
;	O
break	O
;	O
case	O
BI_OP	int
:	O
curr	pointer
->	O
pred_right	pointer
->	O
side_effects	bool
=	O
opt_expr	function
(	O
&	O
curr	pointer
->	O
pred_right	pointer
)	O
;	O
break	O
;	O
default	O
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"oops -- invalid expression type!"	pointer
)	O
)	O
;	O
break	O
;	O
}	O
if	O
(	O
curr	pointer
->	O
pred_right	pointer
->	O
side_effects	bool
==	O
true	int
)	O
{	O
last_sidep	pointer
=	O
prevp	pointer
;	O
merge_lists	function
(	O
cbo_list	array
,	O
NumEvaluationCosts	int
,	O
&	O
name_list	pointer
,	O
&	O
regex_list	pointer
,	O
last_sidep	pointer
)	O
;	O
has_side_effects	bool
=	O
true	int
;	O
}	O
prevp	pointer
=	O
&	O
curr	pointer
->	O
pred_left	pointer
;	O
}	O
last_sidep	pointer
=	O
prevp	pointer
;	O
merge_lists	function
(	O
cbo_list	array
,	O
NumEvaluationCosts	int
,	O
&	O
name_list	pointer
,	O
&	O
regex_list	pointer
,	O
last_sidep	pointer
)	O
;	O
return	O
has_side_effects	bool
;	O
}	O
static	O
float	O
constrain_rate	function
(	O
float	O
rate	float
)	O
{	O
if	O
(	O
rate	float
>	O
1.0f	int
)	O
return	O
1.0	int
;	O
else	O
if	O
(	O
rate	float
<	O
0.0	int
)	O
return	O
0.0	int
;	O
else	O
return	O
rate	float
;	O
}	O
static	O
struct	O
predicate	struct
*	O
set_new_parent	function
(	O
struct	O
predicate	struct
*	O
curr	pointer
,	O
enum	O
predicate_precedence	enum
high_prec	enum
,	O
struct	O
predicate	struct
*	O
*	O
prevp	pointer
)	O
{	O
struct	O
predicate	struct
*	O
new_parent	pointer
;	O
new_parent	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
predicate	struct
)	O
)	O
;	O
new_parent	pointer
->	O
p_type	enum
=	O
BI_OP	int
;	O
new_parent	pointer
->	O
p_prec	enum
=	O
high_prec	enum
;	O
new_parent	pointer
->	O
need_stat	bool
=	O
false	int
;	O
new_parent	pointer
->	O
need_type	bool
=	O
false	int
;	O
new_parent	pointer
->	O
need_inum	bool
=	O
false	int
;	O
new_parent	pointer
->	O
p_cost	enum
=	O
NeedsNothing	int
;	O
new_parent	pointer
->	O
arg_text	pointer
=	O
NULL	O
;	O
switch	O
(	O
high_prec	enum
)	O
{	O
case	O
COMMA_PREC	int
:	O
new_parent	pointer
->	O
pred_func	pointer
=	O
pred_comma	function
;	O
new_parent	pointer
->	O
p_name	pointer
=	O
","	pointer
;	O
new_parent	pointer
->	O
est_success_rate	float
=	O
1.0	int
;	O
break	O
;	O
case	O
OR_PREC	int
:	O
new_parent	pointer
->	O
pred_func	pointer
=	O
pred_or	function
;	O
new_parent	pointer
->	O
p_name	pointer
=	O
"-o"	pointer
;	O
new_parent	pointer
->	O
est_success_rate	float
=	O
constrain_rate	function
(	O
curr	pointer
->	O
est_success_rate	float
)	O
;	O
break	O
;	O
case	O
AND_PREC	int
:	O
new_parent	pointer
->	O
pred_func	pointer
=	O
pred_and	function
;	O
new_parent	pointer
->	O
p_name	pointer
=	O
"-a"	pointer
;	O
new_parent	pointer
->	O
est_success_rate	float
=	O
constrain_rate	function
(	O
curr	pointer
->	O
est_success_rate	float
)	O
;	O
break	O
;	O
default	O
:	O
;	O
}	O
new_parent	pointer
->	O
side_effects	bool
=	O
false	int
;	O
new_parent	pointer
->	O
no_default_print	bool
=	O
false	int
;	O
new_parent	pointer
->	O
args	union
.	O
str	pointer
=	O
NULL	O
;	O
new_parent	pointer
->	O
pred_next	pointer
=	O
NULL	O
;	O
new_parent	pointer
->	O
pred_left	pointer
=	O
NULL	O
;	O
new_parent	pointer
->	O
pred_right	pointer
=	O
curr	pointer
;	O
*	O
prevp	pointer
=	O
new_parent	pointer
;	O
return	O
new_parent	pointer
;	O
}	O
static	O
void	O
merge_pred	function
(	O
struct	O
predicate	struct
*	O
beg_list	pointer
,	O
struct	O
predicate	struct
*	O
end_list	pointer
,	O
struct	O
predicate	struct
*	O
*	O
last_p	pointer
)	O
{	O
end_list	pointer
->	O
pred_left	pointer
=	O
*	O
last_p	pointer
;	O
*	O
last_p	pointer
=	O
beg_list	pointer
;	O
}	O
struct	O
pred_cost_lookup	struct
{	O
PRED_FUNC	pointer
fn	pointer
;	O
enum	O
EvaluationCost	enum
cost	enum
;	O
}	O
;	O
static	O
struct	O
pred_cost_lookup	struct
costlookup	array
[	O
]	O
=	O
{	O
{	O
pred_amin	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_and	function
,	O
NeedsNothing	int
,	O
}	O
,	O
{	O
pred_anewer	function
,	O
NeedsStatInfo	int
,	O
}	O
,	O
{	O
pred_atime	function
,	O
NeedsStatInfo	int
,	O
}	O
,	O
{	O
pred_closeparen	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_cmin	function
,	O
NeedsStatInfo	int
,	O
}	O
,	O
{	O
pred_cnewer	function
,	O
NeedsStatInfo	int
,	O
}	O
,	O
{	O
pred_comma	function
,	O
NeedsNothing	int
,	O
}	O
,	O
{	O
pred_context	function
,	O
NeedsAccessInfo	int
}	O
,	O
{	O
pred_ctime	function
,	O
NeedsStatInfo	int
,	O
}	O
,	O
{	O
pred_delete	function
,	O
NeedsSyncDiskHit	int
}	O
,	O
{	O
pred_empty	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_exec	function
,	O
NeedsEventualExec	int
}	O
,	O
{	O
pred_execdir	function
,	O
NeedsEventualExec	int
}	O
,	O
{	O
pred_executable	function
,	O
NeedsAccessInfo	int
}	O
,	O
{	O
pred_false	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_fprint	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_fprint0	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_fprintf	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_fstype	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_gid	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_group	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_ilname	function
,	O
NeedsLinkName	int
}	O
,	O
{	O
pred_iname	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_inum	function
,	O
NeedsInodeNumber	int
}	O
,	O
{	O
pred_ipath	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_links	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_lname	function
,	O
NeedsLinkName	int
}	O
,	O
{	O
pred_ls	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_fls	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_mmin	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_mtime	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_name	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_negate	function
,	O
NeedsNothing	int
,	O
}	O
,	O
{	O
pred_newer	function
,	O
NeedsStatInfo	int
,	O
}	O
,	O
{	O
pred_newerXY	function
,	O
NeedsStatInfo	int
,	O
}	O
,	O
{	O
pred_nogroup	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_nouser	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_ok	function
,	O
NeedsUserInteraction	int
}	O
,	O
{	O
pred_okdir	function
,	O
NeedsUserInteraction	int
}	O
,	O
{	O
pred_openparen	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_or	function
,	O
NeedsNothing	int
,	O
}	O
,	O
{	O
pred_path	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_perm	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_print	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_print0	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_prune	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_quit	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_readable	function
,	O
NeedsAccessInfo	int
}	O
,	O
{	O
pred_regex	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_samefile	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_size	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_true	function
,	O
NeedsNothing	int
}	O
,	O
{	O
pred_type	function
,	O
NeedsType	int
}	O
,	O
{	O
pred_uid	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_used	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_user	function
,	O
NeedsStatInfo	int
}	O
,	O
{	O
pred_writable	function
,	O
NeedsAccessInfo	int
}	O
,	O
{	O
pred_xtype	function
,	O
NeedsType	int
}	O
}	O
;	O
static	O
int	O
pred_table_sorted	int
=	O
0	int
;	O
static	O
bool	bool
check_sorted	function
(	O
void	O
*	O
base	int
,	O
size_t	long
members	long
,	O
size_t	long
membersize	long
,	O
int	O
(	O
*	O
cmpfn	pointer
)	O
(	O
const	O
void	O
*	O
,	O
const	O
void	O
*	O
)	O
)	O
{	O
const	O
char	O
*	O
p	pointer
=	O
base	int
;	O
size_t	long
i	int
;	O
for	O
(	O
i	int
=	O
1u	int
;	O
i	int
<	O
members	long
;	O
++	O
i	int
)	O
{	O
int	O
result	pointer
=	O
cmpfn	pointer
(	O
p	pointer
+	O
i	int
*	O
membersize	long
,	O
p	pointer
+	O
(	O
i	int
-	O
1	int
)	O
*	O
membersize	long
)	O
;	O
if	O
(	O
result	pointer
<	O
0	int
)	O
return	O
false	int
;	O
result	pointer
=	O
cmpfn	pointer
(	O
p	pointer
+	O
(	O
i	int
-	O
1	int
)	O
*	O
membersize	long
,	O
p	pointer
+	O
i	int
*	O
membersize	long
)	O
;	O
assert	O
(	O
result	pointer
<=	O
0	int
)	O
;	O
}	O
return	O
true	int
;	O
}	O
static	O
int	O
cost_table_comparison	function
(	O
const	O
void	O
*	O
p1	pointer
,	O
const	O
void	O
*	O
p2	pointer
)	O
{	O
const	O
struct	O
pred_cost_lookup	struct
*	O
pc1	pointer
=	O
p1	pointer
;	O
const	O
struct	O
pred_cost_lookup	struct
*	O
pc2	pointer
=	O
p2	pointer
;	O
union	O
{	O
PRED_FUNC	pointer
pfn	pointer
;	O
char	O
mem	array
[	O
sizeof	O
(	O
PRED_FUNC	pointer
)	O
]	O
;	O
}	O
u1	union
,	O
u2	union
;	O
u1	union
.	O
pfn	pointer
=	O
pc1	pointer
->	O
fn	pointer
;	O
u2	union
.	O
pfn	pointer
=	O
pc2	pointer
->	O
fn	pointer
;	O
return	O
memcmp	function
(	O
u1	union
.	O
mem	array
,	O
u2	union
.	O
mem	array
,	O
sizeof	O
(	O
u1	union
.	O
pfn	pointer
)	O
)	O
;	O
}	O
static	O
enum	O
EvaluationCost	enum
get_pred_cost	function
(	O
const	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
enum	O
EvaluationCost	enum
data_requirement_cost	enum
=	O
NeedsNothing	int
;	O
enum	O
EvaluationCost	enum
inherent_cost	enum
=	O
NeedsUnknown	int
;	O
if	O
(	O
p	pointer
->	O
need_stat	bool
)	O
{	O
data_requirement_cost	enum
=	O
NeedsStatInfo	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
need_inum	bool
)	O
{	O
data_requirement_cost	enum
=	O
NeedsInodeNumber	int
;	O
}	O
else	O
if	O
(	O
p	pointer
->	O
need_type	bool
)	O
{	O
data_requirement_cost	enum
=	O
NeedsType	int
;	O
}	O
else	O
{	O
data_requirement_cost	enum
=	O
NeedsNothing	int
;	O
}	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_exec	function
)	O
||	O
pred_is	O
(	O
p	pointer
,	O
pred_execdir	function
)	O
)	O
{	O
if	O
(	O
p	pointer
->	O
args	union
.	O
exec_vec	struct
.	O
multiple	bool
)	O
inherent_cost	enum
=	O
NeedsEventualExec	int
;	O
else	O
inherent_cost	enum
=	O
NeedsImmediateExec	int
;	O
}	O
else	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_fprintf	function
)	O
)	O
{	O
inherent_cost	enum
=	O
p	pointer
->	O
p_cost	enum
;	O
}	O
else	O
{	O
struct	O
pred_cost_lookup	struct
key	struct
;	O
void	O
*	O
entry	pointer
;	O
if	O
(	O
!	O
pred_table_sorted	int
)	O
{	O
qsort	function
(	O
costlookup	array
,	O
sizeof	O
(	O
costlookup	array
)	O
/	O
sizeof	O
(	O
costlookup	array
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
costlookup	array
[	O
0	int
]	O
)	O
,	O
cost_table_comparison	function
)	O
;	O
if	O
(	O
!	O
check_sorted	function
(	O
costlookup	array
,	O
sizeof	O
(	O
costlookup	array
)	O
/	O
sizeof	O
(	O
costlookup	array
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
costlookup	array
[	O
0	int
]	O
)	O
,	O
cost_table_comparison	function
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
"failed to sort the costlookup array"	pointer
)	O
;	O
}	O
pred_table_sorted	int
=	O
1	int
;	O
}	O
key	struct
.	O
fn	pointer
=	O
p	pointer
->	O
pred_func	pointer
;	O
entry	pointer
=	O
bsearch	function
(	O
&	O
key	struct
,	O
costlookup	array
,	O
sizeof	O
(	O
costlookup	array
)	O
/	O
sizeof	O
(	O
costlookup	array
[	O
0	int
]	O
)	O
,	O
sizeof	O
(	O
costlookup	array
[	O
0	int
]	O
)	O
,	O
cost_table_comparison	function
)	O
;	O
if	O
(	O
entry	pointer
)	O
{	O
inherent_cost	enum
=	O
(	O
(	O
const	O
struct	O
pred_cost_lookup	struct
*	O
)	O
entry	pointer
)	O
->	O
cost	enum
;	O
}	O
else	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"warning: there is no entry in the predicate evaluation "	pointer
"cost table for predicate %s; please report this as a bug"	pointer
)	O
,	O
p	pointer
->	O
p_name	pointer
)	O
;	O
inherent_cost	enum
=	O
NeedsUnknown	int
;	O
}	O
}	O
if	O
(	O
inherent_cost	enum
>	O
data_requirement_cost	enum
)	O
return	O
inherent_cost	enum
;	O
else	O
return	O
data_requirement_cost	enum
;	O
}	O
static	O
void	O
estimate_costs	function
(	O
struct	O
predicate	struct
*	O
tree	pointer
)	O
{	O
if	O
(	O
tree	pointer
)	O
{	O
estimate_costs	function
(	O
tree	pointer
->	O
pred_right	pointer
)	O
;	O
estimate_costs	function
(	O
tree	pointer
->	O
pred_left	pointer
)	O
;	O
tree	pointer
->	O
p_cost	enum
=	O
get_pred_cost	function
(	O
tree	pointer
)	O
;	O
}	O
}	O
struct	O
predicate	struct
*	O
get_eval_tree	function
(	O
void	O
)	O
{	O
return	O
eval_tree	pointer
;	O
}	O
static	O
float	O
getrate	function
(	O
const	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
if	O
(	O
p	pointer
)	O
return	O
p	pointer
->	O
est_success_rate	float
;	O
else	O
return	O
1.0f	int
;	O
}	O
float	O
calculate_derived_rates	function
(	O
struct	O
predicate	struct
*	O
p	pointer
)	O
{	O
assert	O
(	O
NULL	O
!=	O
p	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
pred_right	pointer
)	O
calculate_derived_rates	function
(	O
p	pointer
->	O
pred_right	pointer
)	O
;	O
if	O
(	O
p	pointer
->	O
pred_left	pointer
)	O
calculate_derived_rates	function
(	O
p	pointer
->	O
pred_left	pointer
)	O
;	O
assert	O
(	O
p	pointer
->	O
p_type	enum
!=	O
CLOSE_PAREN	int
)	O
;	O
assert	O
(	O
p	pointer
->	O
p_type	enum
!=	O
OPEN_PAREN	int
)	O
;	O
switch	O
(	O
p	pointer
->	O
p_type	enum
)	O
{	O
case	O
NO_TYPE	int
:	O
assert	O
(	O
NULL	O
==	O
p	pointer
->	O
pred_right	pointer
)	O
;	O
assert	O
(	O
NULL	O
==	O
p	pointer
->	O
pred_left	pointer
)	O
;	O
return	O
p	pointer
->	O
est_success_rate	float
;	O
case	O
PRIMARY_TYPE	int
:	O
assert	O
(	O
NULL	O
==	O
p	pointer
->	O
pred_right	pointer
)	O
;	O
assert	O
(	O
NULL	O
==	O
p	pointer
->	O
pred_left	pointer
)	O
;	O
return	O
p	pointer
->	O
est_success_rate	float
;	O
case	O
UNI_OP	int
:	O
assert	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_negate	function
)	O
)	O
;	O
assert	O
(	O
NULL	O
==	O
p	pointer
->	O
pred_left	pointer
)	O
;	O
p	pointer
->	O
est_success_rate	float
=	O
(	O
1.0	int
-	O
p	pointer
->	O
pred_right	pointer
->	O
est_success_rate	float
)	O
;	O
return	O
p	pointer
->	O
est_success_rate	float
;	O
case	O
BI_OP	int
:	O
{	O
float	O
rate	float
;	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_and	function
)	O
)	O
{	O
rate	float
=	O
getrate	function
(	O
p	pointer
->	O
pred_right	pointer
)	O
*	O
getrate	function
(	O
p	pointer
->	O
pred_left	pointer
)	O
;	O
}	O
else	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_comma	function
)	O
)	O
{	O
rate	float
=	O
1.0f	int
;	O
}	O
else	O
if	O
(	O
pred_is	O
(	O
p	pointer
,	O
pred_or	function
)	O
)	O
{	O
rate	float
=	O
getrate	function
(	O
p	pointer
->	O
pred_right	pointer
)	O
+	O
getrate	function
(	O
p	pointer
->	O
pred_left	pointer
)	O
;	O
}	O
else	O
{	O
assert	O
(	O
0	int
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
p	pointer
->	O
est_success_rate	float
=	O
constrain_rate	function
(	O
rate	float
)	O
;	O
}	O
return	O
p	pointer
->	O
est_success_rate	float
;	O
case	O
OPEN_PAREN	int
:	O
case	O
CLOSE_PAREN	int
:	O
p	pointer
->	O
est_success_rate	float
=	O
1.0	int
;	O
return	O
p	pointer
->	O
est_success_rate	float
;	O
}	O
assert	O
(	O
0	int
)	O
;	O
abort	function
(	O
)	O
;	O
}	O
static	O
void	O
check_normalization	function
(	O
struct	O
predicate	struct
*	O
p	pointer
,	O
bool	bool
at_root	bool
)	O
{	O
if	O
(	O
at_root	bool
)	O
{	O
assert	O
(	O
BI_OP	int
==	O
p	pointer
->	O
p_type	enum
)	O
;	O
}	O
if	O
(	O
p	pointer
->	O
pred_left	pointer
)	O
{	O
assert	O
(	O
BI_OP	int
==	O
p	pointer
->	O
pred_left	pointer
->	O
p_type	enum
)	O
;	O
check_normalization	function
(	O
p	pointer
->	O
pred_left	pointer
,	O
false	int
)	O
;	O
}	O
if	O
(	O
p	pointer
->	O
pred_right	pointer
)	O
{	O
check_normalization	function
(	O
p	pointer
->	O
pred_right	pointer
,	O
false	int
)	O
;	O
}	O
}	O
struct	O
predicate	struct
*	O
build_expression_tree	function
(	O
int	O
argc	int
,	O
char	O
*	O
argv	array
[	O
]	O
,	O
int	O
end_of_leading_options	int
)	O
{	O
const	O
struct	O
parser_table	struct
*	O
parse_entry	pointer
;	O
char	O
*	O
predicate_name	pointer
;	O
struct	O
predicate	struct
*	O
cur_pred	pointer
;	O
const	O
struct	O
parser_table	struct
*	O
entry_close	pointer
,	O
*	O
entry_print	pointer
,	O
*	O
entry_open	pointer
;	O
int	O
i	int
,	O
oldi	int
;	O
predicates	pointer
=	O
NULL	O
;	O
start_points	pointer
=	O
argv	array
+	O
end_of_leading_options	int
;	O
for	O
(	O
i	int
=	O
end_of_leading_options	int
;	O
i	int
<	O
argc	int
&&	O
!	O
looks_like_expression	function
(	O
argv	array
[	O
i	int
]	O
,	O
true	int
)	O
;	O
i	int
++	O
)	O
{	O
++	O
num_start_points	long
;	O
}	O
entry_open	pointer
=	O
find_parser	function
(	O
"("	pointer
)	O
;	O
entry_close	pointer
=	O
find_parser	function
(	O
")"	pointer
)	O
;	O
entry_print	pointer
=	O
find_parser	function
(	O
"print"	pointer
)	O
;	O
assert	O
(	O
entry_open	pointer
!=	O
NULL	O
)	O
;	O
assert	O
(	O
entry_close	pointer
!=	O
NULL	O
)	O
;	O
assert	O
(	O
entry_print	pointer
!=	O
NULL	O
)	O
;	O
parse_openparen	function
(	O
entry_open	pointer
,	O
argv	array
,	O
&	O
argc	int
)	O
;	O
last_pred	pointer
->	O
p_name	pointer
=	O
"("	pointer
;	O
predicates	pointer
->	O
artificial	bool
=	O
true	int
;	O
parse_begin_user_args	function
(	O
argv	array
,	O
argc	int
,	O
last_pred	pointer
,	O
predicates	pointer
)	O
;	O
pred_sanity_check	function
(	O
last_pred	pointer
)	O
;	O
while	O
(	O
i	int
<	O
argc	int
)	O
{	O
state	pointer
.	O
already_issued_stat_error_msg	bool
=	O
false	int
;	O
if	O
(	O
!	O
looks_like_expression	function
(	O
argv	array
[	O
i	int
]	O
,	O
false	int
)	O
)	O
{	O
error	function
(	O
0	int
,	O
0	int
,	O
_	O
(	O
"paths must precede expression: %s"	pointer
)	O
,	O
argv	array
[	O
i	int
]	O
)	O
;	O
usage	function
(	O
stderr	pointer
,	O
1	int
,	O
NULL	O
)	O
;	O
}	O
predicate_name	pointer
=	O
argv	array
[	O
i	int
]	O
;	O
parse_entry	pointer
=	O
find_parser	function
(	O
predicate_name	pointer
)	O
;	O
if	O
(	O
parse_entry	pointer
==	O
NULL	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"unknown predicate `%s'"	pointer
)	O
,	O
predicate_name	pointer
)	O
;	O
}	O
if	O
(	O
parse_entry	pointer
->	O
type	int
!=	O
ARG_SPECIAL_PARSE	int
)	O
{	O
i	int
++	O
;	O
}	O
oldi	int
=	O
i	int
;	O
if	O
(	O
!	O
(	O
*	O
(	O
parse_entry	pointer
->	O
parser_func	pointer
)	O
)	O
(	O
parse_entry	pointer
,	O
argv	array
,	O
&	O
i	int
)	O
)	O
{	O
if	O
(	O
argv	array
[	O
i	int
]	O
)	O
{	O
if	O
(	O
(	O
ARG_SPECIAL_PARSE	int
==	O
parse_entry	pointer
->	O
type	int
)	O
&&	O
(	O
i	int
==	O
oldi	int
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid predicate `%s'"	pointer
)	O
,	O
predicate_name	pointer
)	O
;	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"invalid argument `%s' to `%s'"	pointer
)	O
,	O
argv	array
[	O
i	int
]	O
,	O
predicate_name	pointer
)	O
;	O
}	O
}	O
else	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"missing argument to `%s'"	pointer
)	O
,	O
predicate_name	pointer
)	O
;	O
}	O
}	O
else	O
{	O
last_pred	pointer
->	O
p_name	pointer
=	O
predicate_name	pointer
;	O
if	O
(	O
i	int
!=	O
oldi	int
)	O
last_pred	pointer
->	O
arg_text	pointer
=	O
argv	array
[	O
oldi	int
]	O
;	O
else	O
last_pred	pointer
->	O
arg_text	pointer
=	O
NULL	O
;	O
}	O
pred_sanity_check	function
(	O
last_pred	pointer
)	O
;	O
pred_sanity_check	function
(	O
predicates	pointer
)	O
;	O
}	O
parse_end_user_args	function
(	O
argv	array
,	O
argc	int
,	O
last_pred	pointer
,	O
predicates	pointer
)	O
;	O
if	O
(	O
predicates	pointer
->	O
pred_next	pointer
==	O
NULL	O
)	O
{	O
cur_pred	pointer
=	O
predicates	pointer
;	O
predicates	pointer
=	O
last_pred	pointer
=	O
predicates	pointer
->	O
pred_next	pointer
;	O
free	function
(	O
cur_pred	pointer
)	O
;	O
parse_print	function
(	O
entry_print	pointer
,	O
argv	array
,	O
&	O
argc	int
)	O
;	O
last_pred	pointer
->	O
p_name	pointer
=	O
"-print"	pointer
;	O
pred_sanity_check	function
(	O
last_pred	pointer
)	O
;	O
pred_sanity_check	function
(	O
predicates	pointer
)	O
;	O
}	O
else	O
if	O
(	O
!	O
default_prints	function
(	O
predicates	pointer
->	O
pred_next	pointer
)	O
)	O
{	O
cur_pred	pointer
=	O
predicates	pointer
;	O
predicates	pointer
=	O
predicates	pointer
->	O
pred_next	pointer
;	O
pred_sanity_check	function
(	O
predicates	pointer
)	O
;	O
free	function
(	O
cur_pred	pointer
)	O
;	O
}	O
else	O
{	O
parse_closeparen	function
(	O
entry_close	pointer
,	O
argv	array
,	O
&	O
argc	int
)	O
;	O
last_pred	pointer
->	O
p_name	pointer
=	O
")"	pointer
;	O
last_pred	pointer
->	O
artificial	bool
=	O
true	int
;	O
pred_sanity_check	function
(	O
last_pred	pointer
)	O
;	O
parse_print	function
(	O
entry_print	pointer
,	O
argv	array
,	O
&	O
argc	int
)	O
;	O
last_pred	pointer
->	O
p_name	pointer
=	O
"-print"	pointer
;	O
last_pred	pointer
->	O
artificial	bool
=	O
true	int
;	O
pred_sanity_check	function
(	O
last_pred	pointer
)	O
;	O
pred_sanity_check	function
(	O
predicates	pointer
)	O
;	O
}	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
(	O
DebugExpressionTree	int
|	O
DebugTreeOpt	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Predicate List:\n"	pointer
)	O
;	O
print_list	function
(	O
stderr	pointer
,	O
predicates	pointer
)	O
;	O
}	O
check_option_combinations	function
(	O
predicates	pointer
)	O
;	O
pred_sanity_check	function
(	O
predicates	pointer
)	O
;	O
cur_pred	pointer
=	O
predicates	pointer
;	O
eval_tree	pointer
=	O
get_expr	function
(	O
&	O
cur_pred	pointer
,	O
NO_PREC	int
,	O
NULL	O
)	O
;	O
calculate_derived_rates	function
(	O
eval_tree	pointer
)	O
;	O
if	O
(	O
cur_pred	pointer
!=	O
NULL	O
)	O
{	O
if	O
(	O
pred_is	O
(	O
cur_pred	pointer
,	O
pred_closeparen	function
)	O
)	O
{	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"you have too many ')'"	pointer
)	O
)	O
;	O
}	O
else	O
{	O
if	O
(	O
cur_pred	pointer
->	O
p_name	pointer
)	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"unexpected extra predicate '%s'"	pointer
)	O
,	O
cur_pred	pointer
->	O
p_name	pointer
)	O
;	O
else	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"unexpected extra predicate"	pointer
)	O
)	O
;	O
}	O
}	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
(	O
DebugExpressionTree	int
|	O
DebugTreeOpt	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Eval Tree:\n"	pointer
)	O
;	O
print_tree	function
(	O
stderr	pointer
,	O
eval_tree	pointer
,	O
0	int
)	O
;	O
}	O
estimate_costs	function
(	O
eval_tree	pointer
)	O
;	O
opt_expr	function
(	O
&	O
eval_tree	pointer
)	O
;	O
check_normalization	function
(	O
eval_tree	pointer
,	O
true	int
)	O
;	O
do_arm_swaps	function
(	O
eval_tree	pointer
)	O
;	O
check_normalization	function
(	O
eval_tree	pointer
,	O
true	int
)	O
;	O
if	O
(	O
options	struct
.	O
debug_options	long
&	O
(	O
DebugExpressionTree	int
|	O
DebugTreeOpt	int
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Optimized Eval Tree:\n"	pointer
)	O
;	O
print_tree	function
(	O
stderr	pointer
,	O
eval_tree	pointer
,	O
0	int
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"Optimized command line:\n"	pointer
)	O
;	O
print_optlist	function
(	O
stderr	pointer
,	O
eval_tree	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\n"	pointer
)	O
;	O
}	O
return	O
eval_tree	pointer
;	O
}	O
static	O
void	O
init_pred_perf	function
(	O
struct	O
predicate	struct
*	O
pred	pointer
)	O
{	O
struct	O
predicate_performance_info	struct
*	O
p	pointer
=	O
&	O
pred	pointer
->	O
perf	struct
;	O
p	pointer
->	O
visits	long
=	O
p	pointer
->	O
successes	long
=	O
0	int
;	O
}	O
struct	O
predicate	struct
*	O
get_new_pred_noarg	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
)	O
{	O
struct	O
predicate	struct
*	O
p	pointer
=	O
get_new_pred	function
(	O
entry	pointer
)	O
;	O
if	O
(	O
p	pointer
)	O
{	O
p	pointer
->	O
arg_text	pointer
=	O
NULL	O
;	O
}	O
return	O
p	pointer
;	O
}	O
struct	O
predicate	struct
*	O
get_new_pred	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
)	O
{	O
register	O
struct	O
predicate	struct
*	O
new_pred	pointer
;	O
(	O
void	O
)	O
entry	pointer
;	O
assert	O
(	O
entry	pointer
->	O
type	int
!=	O
ARG_OPTION	int
)	O
;	O
assert	O
(	O
entry	pointer
->	O
type	int
!=	O
ARG_POSITIONAL_OPTION	int
)	O
;	O
if	O
(	O
predicates	pointer
==	O
NULL	O
)	O
{	O
predicates	pointer
=	O
(	O
struct	O
predicate	struct
*	O
)	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
predicate	struct
)	O
)	O
;	O
last_pred	pointer
=	O
predicates	pointer
;	O
}	O
else	O
{	O
new_pred	pointer
=	O
xmalloc	function
(	O
sizeof	O
(	O
struct	O
predicate	struct
)	O
)	O
;	O
last_pred	pointer
->	O
pred_next	pointer
=	O
new_pred	pointer
;	O
last_pred	pointer
=	O
new_pred	pointer
;	O
}	O
last_pred	pointer
->	O
parser_entry	pointer
=	O
entry	pointer
;	O
last_pred	pointer
->	O
pred_func	pointer
=	O
NULL	O
;	O
last_pred	pointer
->	O
p_name	pointer
=	O
NULL	O
;	O
last_pred	pointer
->	O
p_type	enum
=	O
NO_TYPE	int
;	O
last_pred	pointer
->	O
p_prec	enum
=	O
NO_PREC	int
;	O
last_pred	pointer
->	O
side_effects	bool
=	O
false	int
;	O
last_pred	pointer
->	O
no_default_print	bool
=	O
false	int
;	O
last_pred	pointer
->	O
need_stat	bool
=	O
true	int
;	O
last_pred	pointer
->	O
need_type	bool
=	O
true	int
;	O
last_pred	pointer
->	O
need_inum	bool
=	O
false	int
;	O
last_pred	pointer
->	O
p_cost	enum
=	O
NeedsUnknown	int
;	O
last_pred	pointer
->	O
arg_text	pointer
=	O
"ThisShouldBeSetToSomethingElse"	pointer
;	O
last_pred	pointer
->	O
args	union
.	O
str	pointer
=	O
NULL	O
;	O
last_pred	pointer
->	O
args	union
.	O
scontext	pointer
=	O
NULL	O
;	O
last_pred	pointer
->	O
pred_next	pointer
=	O
NULL	O
;	O
last_pred	pointer
->	O
pred_left	pointer
=	O
NULL	O
;	O
last_pred	pointer
->	O
pred_right	pointer
=	O
NULL	O
;	O
last_pred	pointer
->	O
literal_control_chars	bool
=	O
options	struct
.	O
literal_control_chars	bool
;	O
last_pred	pointer
->	O
artificial	bool
=	O
false	int
;	O
last_pred	pointer
->	O
est_success_rate	float
=	O
1.0	int
;	O
init_pred_perf	function
(	O
last_pred	pointer
)	O
;	O
return	O
last_pred	pointer
;	O
}	O
struct	O
predicate	struct
*	O
get_new_pred_chk_op	function
(	O
const	O
struct	O
parser_table	struct
*	O
entry	pointer
,	O
const	O
char	O
*	O
arg	pointer
)	O
{	O
struct	O
predicate	struct
*	O
new_pred	pointer
;	O
static	O
const	O
struct	O
parser_table	struct
*	O
entry_and	pointer
=	O
NULL	O
;	O
if	O
(	O
NULL	O
==	O
entry_and	pointer
)	O
entry_and	pointer
=	O
find_parser	function
(	O
"and"	pointer
)	O
;	O
assert	O
(	O
entry_and	pointer
!=	O
NULL	O
)	O
;	O
if	O
(	O
last_pred	pointer
)	O
switch	O
(	O
last_pred	pointer
->	O
p_type	enum
)	O
{	O
case	O
NO_TYPE	int
:	O
error	function
(	O
EXIT_FAILURE	int
,	O
0	int
,	O
_	O
(	O
"oops -- invalid default insertion of and!"	pointer
)	O
)	O
;	O
break	O
;	O
case	O
PRIMARY_TYPE	int
:	O
case	O
CLOSE_PAREN	int
:	O
new_pred	pointer
=	O
get_new_pred_noarg	function
(	O
entry_and	pointer
)	O
;	O
new_pred	pointer
->	O
pred_func	pointer
=	O
pred_and	function
;	O
new_pred	pointer
->	O
p_name	pointer
=	O
"-a"	pointer
;	O
new_pred	pointer
->	O
p_type	enum
=	O
BI_OP	int
;	O
new_pred	pointer
->	O
p_prec	enum
=	O
AND_PREC	int
;	O
new_pred	pointer
->	O
need_stat	bool
=	O
false	int
;	O
new_pred	pointer
->	O
need_type	bool
=	O
false	int
;	O
new_pred	pointer
->	O
need_inum	bool
=	O
false	int
;	O
new_pred	pointer
->	O
arg_text	pointer
=	O
NULL	O
;	O
new_pred	pointer
->	O
args	union
.	O
str	pointer
=	O
NULL	O
;	O
new_pred	pointer
->	O
side_effects	bool
=	O
false	int
;	O
new_pred	pointer
->	O
no_default_print	bool
=	O
false	int
;	O
break	O
;	O
default	O
:	O
break	O
;	O
}	O
new_pred	pointer
=	O
get_new_pred	function
(	O
entry	pointer
)	O
;	O
new_pred	pointer
->	O
arg_text	pointer
=	O
arg	pointer
;	O
new_pred	pointer
->	O
parser_entry	pointer
=	O
entry	pointer
;	O
return	O
new_pred	pointer
;	O
}	O
struct	O
cost_assoc	struct
{	O
enum	O
EvaluationCost	enum
cost	enum
;	O
const	O
char	O
*	O
name	pointer
;	O
}	O
;	O
struct	O
cost_assoc	struct
cost_table	array
[	O
]	O
=	O
{	O
{	O
NeedsNothing	int
,	O
"Nothing"	pointer
}	O
,	O
{	O
NeedsInodeNumber	int
,	O
"InodeNumber"	pointer
}	O
,	O
{	O
NeedsType	int
,	O
"Type"	pointer
}	O
,	O
{	O
NeedsStatInfo	int
,	O
"StatInfo"	pointer
}	O
,	O
{	O
NeedsLinkName	int
,	O
"LinkName"	pointer
}	O
,	O
{	O
NeedsAccessInfo	int
,	O
"AccessInfo"	pointer
}	O
,	O
{	O
NeedsSyncDiskHit	int
,	O
"SyncDiskHit"	pointer
}	O
,	O
{	O
NeedsEventualExec	int
,	O
"EventualExec"	pointer
}	O
,	O
{	O
NeedsImmediateExec	int
,	O
"ImmediateExec"	pointer
}	O
,	O
{	O
NeedsUserInteraction	int
,	O
"UserInteraction"	pointer
}	O
,	O
{	O
NeedsUnknown	int
,	O
"Unknown"	pointer
}	O
}	O
;	O
struct	O
prec_assoc	struct
{	O
short	O
prec	short
;	O
const	O
char	O
*	O
prec_name	pointer
;	O
}	O
;	O
static	O
struct	O
prec_assoc	struct
prec_table	array
[	O
]	O
=	O
{	O
{	O
NO_PREC	int
,	O
"no"	pointer
}	O
,	O
{	O
COMMA_PREC	int
,	O
"comma"	pointer
}	O
,	O
{	O
OR_PREC	int
,	O
"or"	pointer
}	O
,	O
{	O
AND_PREC	int
,	O
"and"	pointer
}	O
,	O
{	O
NEGATE_PREC	int
,	O
"negate"	pointer
}	O
,	O
{	O
MAX_PREC	int
,	O
"max"	pointer
}	O
,	O
{	O
-	O
1	int
,	O
"unknown "	pointer
}	O
}	O
;	O
struct	O
op_assoc	struct
{	O
short	O
type	int
;	O
const	O
char	O
*	O
type_name	pointer
;	O
}	O
;	O
static	O
struct	O
op_assoc	struct
type_table	array
[	O
]	O
=	O
{	O
{	O
NO_TYPE	int
,	O
"no"	pointer
}	O
,	O
{	O
PRIMARY_TYPE	int
,	O
"primary"	pointer
}	O
,	O
{	O
UNI_OP	int
,	O
"uni_op"	pointer
}	O
,	O
{	O
BI_OP	int
,	O
"bi_op"	pointer
}	O
,	O
{	O
OPEN_PAREN	int
,	O
"open_paren  "	pointer
}	O
,	O
{	O
CLOSE_PAREN	int
,	O
"close_paren "	pointer
}	O
,	O
{	O
-	O
1	int
,	O
"unknown"	pointer
}	O
}	O
;	O
static	O
const	O
char	O
*	O
cost_name	function
(	O
enum	O
EvaluationCost	enum
cost	enum
)	O
{	O
unsigned	O
int	O
i	int
;	O
unsigned	O
int	O
n	long
=	O
sizeof	O
(	O
cost_table	array
)	O
/	O
sizeof	O
(	O
cost_table	array
[	O
0	int
]	O
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
n	long
;	O
++	O
i	int
)	O
if	O
(	O
cost_table	array
[	O
i	int
]	O
.	O
cost	enum
==	O
cost	enum
)	O
return	O
cost_table	array
[	O
i	int
]	O
.	O
name	pointer
;	O
return	O
"unknown"	pointer
;	O
}	O
static	O
const	O
char	O
*	O
type_name	pointer
(	O
short	O
type	int
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
type_table	array
[	O
i	int
]	O
.	O
type	int
!=	O
(	O
short	O
)	O
-	O
1	int
;	O
i	int
++	O
)	O
if	O
(	O
type_table	array
[	O
i	int
]	O
.	O
type	int
==	O
type	int
)	O
break	O
;	O
return	O
type_table	array
[	O
i	int
]	O
.	O
type_name	pointer
;	O
}	O
static	O
const	O
char	O
*	O
prec_name	pointer
(	O
short	O
prec	short
)	O
{	O
int	O
i	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
prec_table	array
[	O
i	int
]	O
.	O
prec	short
!=	O
(	O
short	O
)	O
-	O
1	int
;	O
i	int
++	O
)	O
if	O
(	O
prec_table	array
[	O
i	int
]	O
.	O
prec	short
==	O
prec	short
)	O
break	O
;	O
return	O
prec_table	array
[	O
i	int
]	O
.	O
prec_name	pointer
;	O
}	O
void	O
print_tree	function
(	O
FILE	struct
*	O
fp	pointer
,	O
struct	O
predicate	struct
*	O
node	pointer
,	O
int	O
indent	int
)	O
{	O
int	O
i	int
;	O
if	O
(	O
node	pointer
==	O
NULL	O
)	O
return	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
indent	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"    "	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"pred=["	pointer
)	O
;	O
print_predicate	function
(	O
fp	pointer
,	O
node	pointer
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
"] type=%s prec=%s"	pointer
,	O
type_name	pointer
(	O
node	pointer
->	O
p_type	enum
)	O
,	O
prec_name	pointer
(	O
node	pointer
->	O
p_prec	enum
)	O
)	O
;	O
fprintf	function
(	O
fp	pointer
,	O
" cost=%s rate=%#03.2g %sside effects "	pointer
,	O
cost_name	function
(	O
node	pointer
->	O
p_cost	enum
)	O
,	O
node	pointer
->	O
est_success_rate	float
,	O
(	O
node	pointer
->	O
side_effects	bool
?	O
""	pointer
:	O
"no "	pointer
)	O
)	O
;	O
if	O
(	O
node	pointer
->	O
need_stat	bool
||	O
node	pointer
->	O
need_type	bool
||	O
node	pointer
->	O
need_inum	bool
)	O
{	O
int	O
comma	int
=	O
0	int
;	O
fprintf	function
(	O
fp	pointer
,	O
"Needs "	pointer
)	O
;	O
if	O
(	O
node	pointer
->	O
need_stat	bool
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"stat"	pointer
)	O
;	O
comma	int
=	O
1	int
;	O
}	O
if	O
(	O
node	pointer
->	O
need_inum	bool
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%sinode"	pointer
,	O
comma	int
?	O
","	pointer
:	O
""	pointer
)	O
;	O
comma	int
=	O
1	int
;	O
}	O
if	O
(	O
node	pointer
->	O
need_type	bool
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"%stype"	pointer
,	O
comma	int
?	O
","	pointer
:	O
""	pointer
)	O
;	O
}	O
}	O
fprintf	function
(	O
fp	pointer
,	O
"\n"	pointer
)	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
indent	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"    "	pointer
)	O
;	O
if	O
(	O
NULL	O
==	O
node	pointer
->	O
pred_left	pointer
&&	O
NULL	O
==	O
node	pointer
->	O
pred_right	pointer
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"no children.\n"	pointer
)	O
;	O
}	O
else	O
{	O
if	O
(	O
node	pointer
->	O
pred_left	pointer
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"left:\n"	pointer
)	O
;	O
print_tree	function
(	O
fp	pointer
,	O
node	pointer
->	O
pred_left	pointer
,	O
indent	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"no left.\n"	pointer
)	O
;	O
}	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
indent	int
;	O
i	int
++	O
)	O
fprintf	function
(	O
fp	pointer
,	O
"    "	pointer
)	O
;	O
if	O
(	O
node	pointer
->	O
pred_right	pointer
)	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"right:\n"	pointer
)	O
;	O
print_tree	function
(	O
fp	pointer
,	O
node	pointer
->	O
pred_right	pointer
,	O
indent	int
+	O
1	int
)	O
;	O
}	O
else	O
{	O
fprintf	function
(	O
fp	pointer
,	O
"no right.\n"	pointer
)	O
;	O
}	O
}	O
}	O
