extern	O
int	O
command_prompt	int
;	O
static	O
int	O
tree_navigation_flag	int
;	O
struct	O
WTree	struct
{	O
Widget	struct
widget	pointer
;	O
struct	O
TreeStore	struct
*	O
store	pointer
;	O
tree_entry	struct
*	O
selected_ptr	pointer
;	O
char	O
search_buffer	array
[	O
256	int
]	O
;	O
tree_entry	struct
*	O
*	O
tree_shown	pointer
;	O
int	O
is_panel	int
;	O
int	O
active	int
;	O
int	O
searching	int
;	O
int	O
topdiff	int
;	O
}	O
;	O
static	O
void	O
save_tree	function
(	O
WTree	struct
*	O
tree	pointer
)	O
;	O
static	O
void	O
tree_rescan_cmd	function
(	O
WTree	struct
*	O
)	O
;	O
static	O
tree_entry	struct
*	O
back_ptr	function
(	O
tree_entry	struct
*	O
ptr	pointer
,	O
int	O
*	O
count	int
)	O
{	O
int	O
i	array
=	O
0	int
;	O
while	O
(	O
ptr	pointer
&&	O
ptr	pointer
->	O
prev	pointer
&&	O
i	array
<	O
*	O
count	int
)	O
{	O
ptr	pointer
=	O
ptr	pointer
->	O
prev	pointer
;	O
i	array
++	O
;	O
}	O
*	O
count	int
=	O
i	array
;	O
return	O
ptr	pointer
;	O
}	O
static	O
tree_entry	struct
*	O
forw_ptr	function
(	O
tree_entry	struct
*	O
ptr	pointer
,	O
int	O
*	O
count	int
)	O
{	O
int	O
i	array
=	O
0	int
;	O
while	O
(	O
ptr	pointer
&&	O
ptr	pointer
->	O
next	pointer
&&	O
i	array
<	O
*	O
count	int
)	O
{	O
ptr	pointer
=	O
ptr	pointer
->	O
next	pointer
;	O
i	array
++	O
;	O
}	O
*	O
count	int
=	O
i	array
;	O
return	O
ptr	pointer
;	O
}	O
static	O
void	O
remove_callback	function
(	O
tree_entry	struct
*	O
entry	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
data	pointer
;	O
if	O
(	O
tree	pointer
->	O
selected_ptr	pointer
==	O
entry	pointer
)	O
{	O
if	O
(	O
tree	pointer
->	O
selected_ptr	pointer
->	O
next	pointer
)	O
tree	pointer
->	O
selected_ptr	pointer
=	O
tree	pointer
->	O
selected_ptr	pointer
->	O
next	pointer
;	O
else	O
tree	pointer
->	O
selected_ptr	pointer
=	O
tree	pointer
->	O
selected_ptr	pointer
->	O
prev	pointer
;	O
}	O
}	O
static	O
void	O
tree_remove_entry	function
(	O
WTree	struct
*	O
tree	pointer
,	O
char	O
*	O
name	pointer
)	O
{	O
(	O
void	O
)	O
tree	pointer
;	O
tree_store_remove_entry	function
(	O
name	pointer
)	O
;	O
}	O
static	O
void	O
tree_destroy	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree_store_remove_entry_remove_hook	function
(	O
remove_callback	function
)	O
;	O
save_tree	function
(	O
tree	pointer
)	O
;	O
g_free	function
(	O
tree	pointer
->	O
tree_shown	pointer
)	O
;	O
tree	pointer
->	O
tree_shown	pointer
=	O
0	int
;	O
tree	pointer
->	O
selected_ptr	pointer
=	O
NULL	O
;	O
}	O
static	O
void	O
load_tree	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree_store_load	function
(	O
)	O
;	O
tree	pointer
->	O
selected_ptr	pointer
=	O
tree	pointer
->	O
store	pointer
->	O
tree_first	pointer
;	O
tree_chdir	function
(	O
tree	pointer
,	O
home_dir	pointer
)	O
;	O
}	O
static	O
void	O
save_tree	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
int	O
error	pointer
;	O
(	O
void	O
)	O
tree	pointer
;	O
error	pointer
=	O
tree_store_save	function
(	O
)	O
;	O
if	O
(	O
error	pointer
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
_	O
(	O
"Cannot open the %s file for writing:\n%s\n"	pointer
)	O
,	O
MC_TREE	pointer
,	O
unix_error_string	function
(	O
error	pointer
)	O
)	O
;	O
}	O
}	O
static	O
void	O
tree_show_mini_info	function
(	O
WTree	struct
*	O
tree	pointer
,	O
int	O
tree_lines	int
,	O
int	O
tree_cols	int
)	O
{	O
Dlg_head	struct
*	O
h	pointer
=	O
tree	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
int	O
line	int
;	O
if	O
(	O
tree	pointer
->	O
is_panel	int
)	O
{	O
if	O
(	O
!	O
show_mini_info	int
)	O
return	O
;	O
line	int
=	O
tree_lines	int
+	O
2	int
;	O
}	O
else	O
line	int
=	O
tree_lines	int
+	O
1	int
;	O
widget_move	O
(	O
&	O
tree	pointer
->	O
widget	pointer
,	O
line	int
,	O
1	int
)	O
;	O
hline	function
(	O
' '	O
,	O
tree_cols	int
)	O
;	O
widget_move	O
(	O
&	O
tree	pointer
->	O
widget	pointer
,	O
line	int
,	O
1	int
)	O
;	O
if	O
(	O
tree	pointer
->	O
searching	int
)	O
{	O
attrset	function
(	O
TREE_NORMALC	O
(	O
h	pointer
)	O
)	O
;	O
attrset	function
(	O
DLG_FOCUSC	O
(	O
h	pointer
)	O
)	O
;	O
addch	O
(	O
PATH_SEP	char
)	O
;	O
addstr	O
(	O
(	O
char	O
*	O
)	O
name_trunc	function
(	O
tree	pointer
->	O
search_buffer	array
,	O
tree_cols	int
-	O
2	int
)	O
)	O
;	O
addch	O
(	O
' '	O
)	O
;	O
attrset	function
(	O
DLG_FOCUSC	O
(	O
h	pointer
)	O
)	O
;	O
}	O
else	O
{	O
addstr	O
(	O
(	O
char	O
*	O
)	O
name_trunc	function
(	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
tree_cols	int
)	O
)	O
;	O
}	O
}	O
static	O
void	O
show_tree	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
Dlg_head	struct
*	O
h	pointer
=	O
tree	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
tree_entry	struct
*	O
current	pointer
;	O
int	O
i	array
,	O
j	int
,	O
topsublevel	int
;	O
int	O
x	array
,	O
y	short
;	O
int	O
tree_lines	int
,	O
tree_cols	int
;	O
x	array
=	O
y	short
=	O
0	int
;	O
tree_lines	int
=	O
tlines	O
(	O
tree	pointer
)	O
;	O
tree_cols	int
=	O
tree	pointer
->	O
widget	pointer
.	O
cols	int
;	O
attrset	function
(	O
TREE_NORMALC	O
(	O
h	pointer
)	O
)	O
;	O
widget_move	O
(	O
(	O
Widget	struct
*	O
)	O
tree	pointer
,	O
y	short
,	O
x	array
)	O
;	O
if	O
(	O
tree	pointer
->	O
is_panel	int
)	O
{	O
tree_cols	int
-=	O
2	int
;	O
x	array
=	O
y	short
=	O
1	int
;	O
}	O
g_free	function
(	O
tree	pointer
->	O
tree_shown	pointer
)	O
;	O
tree	pointer
->	O
tree_shown	pointer
=	O
g_new	O
(	O
tree_entry	struct
*	O
,	O
tree_lines	int
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
tree_lines	int
;	O
i	array
++	O
)	O
tree	pointer
->	O
tree_shown	pointer
[	O
i	array
]	O
=	O
NULL	O
;	O
if	O
(	O
tree	pointer
->	O
store	pointer
->	O
tree_first	pointer
)	O
topsublevel	int
=	O
tree	pointer
->	O
store	pointer
->	O
tree_first	pointer
->	O
sublevel	int
;	O
else	O
topsublevel	int
=	O
0	int
;	O
if	O
(	O
!	O
tree	pointer
->	O
selected_ptr	pointer
)	O
{	O
tree	pointer
->	O
selected_ptr	pointer
=	O
tree	pointer
->	O
store	pointer
->	O
tree_first	pointer
;	O
tree	pointer
->	O
topdiff	int
=	O
0	int
;	O
}	O
current	pointer
=	O
tree	pointer
->	O
selected_ptr	pointer
;	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
i	array
=	O
0	int
;	O
while	O
(	O
current	pointer
->	O
prev	pointer
&&	O
i	array
<	O
tree	pointer
->	O
topdiff	int
)	O
{	O
current	pointer
=	O
current	pointer
->	O
prev	pointer
;	O
if	O
(	O
current	pointer
->	O
sublevel	int
<	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
)	O
{	O
if	O
(	O
strncmp	function
(	O
current	pointer
->	O
name	pointer
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
strlen	function
(	O
current	pointer
->	O
name	pointer
)	O
)	O
==	O
0	int
)	O
i	array
++	O
;	O
}	O
else	O
if	O
(	O
current	pointer
->	O
sublevel	int
==	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
)	O
{	O
for	O
(	O
j	int
=	O
strlen	function
(	O
current	pointer
->	O
name	pointer
)	O
-	O
1	int
;	O
current	pointer
->	O
name	pointer
[	O
j	int
]	O
!=	O
PATH_SEP	char
;	O
j	int
--	O
)	O
;	O
if	O
(	O
strncmp	function
(	O
current	pointer
->	O
name	pointer
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
j	int
)	O
==	O
0	int
)	O
i	array
++	O
;	O
}	O
else	O
if	O
(	O
current	pointer
->	O
sublevel	int
==	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
+	O
1	int
&&	O
strlen	function
(	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
)	O
>	O
1	int
)	O
{	O
if	O
(	O
strncmp	function
(	O
current	pointer
->	O
name	pointer
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
strlen	function
(	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
)	O
)	O
==	O
0	int
)	O
i	array
++	O
;	O
}	O
}	O
tree	pointer
->	O
topdiff	int
=	O
i	array
;	O
}	O
else	O
current	pointer
=	O
back_ptr	function
(	O
current	pointer
,	O
&	O
tree	pointer
->	O
topdiff	int
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
tree_lines	int
;	O
i	array
++	O
)	O
{	O
widget_move	O
(	O
&	O
tree	pointer
->	O
widget	pointer
,	O
y	short
+	O
i	array
,	O
x	array
)	O
;	O
hline	function
(	O
' '	O
,	O
tree_cols	int
)	O
;	O
widget_move	O
(	O
&	O
tree	pointer
->	O
widget	pointer
,	O
y	short
+	O
i	array
,	O
x	array
)	O
;	O
if	O
(	O
!	O
current	pointer
)	O
continue	O
;	O
tree	pointer
->	O
tree_shown	pointer
[	O
i	array
]	O
=	O
current	pointer
;	O
if	O
(	O
current	pointer
->	O
sublevel	int
==	O
topsublevel	int
)	O
{	O
if	O
(	O
tree	pointer
->	O
active	int
&&	O
current	pointer
==	O
tree	pointer
->	O
selected_ptr	pointer
)	O
{	O
if	O
(	O
!	O
use_colors	int
&&	O
!	O
tree	pointer
->	O
is_panel	int
)	O
attrset	function
(	O
MARKED_COLOR	O
)	O
;	O
else	O
attrset	function
(	O
SELECTED_COLOR	O
)	O
;	O
}	O
addstr	O
(	O
(	O
char	O
*	O
)	O
name_trunc	function
(	O
current	pointer
->	O
name	pointer
,	O
tree_cols	int
-	O
6	int
)	O
)	O
;	O
}	O
else	O
{	O
acs	O
(	O
)	O
;	O
for	O
(	O
j	int
=	O
0	int
;	O
j	int
<	O
current	pointer
->	O
sublevel	int
-	O
topsublevel	int
-	O
1	int
;	O
j	int
++	O
)	O
{	O
if	O
(	O
tree_cols	int
-	O
8	int
-	O
3	int
*	O
j	int
<	O
9	int
)	O
break	O
;	O
addch	O
(	O
' '	O
)	O
;	O
if	O
(	O
current	pointer
->	O
submask	long
&	O
(	O
1	int
<<	O
(	O
j	int
+	O
topsublevel	int
+	O
1	int
)	O
)	O
)	O
addch	O
(	O
ACS_VLINE	O
)	O
;	O
else	O
addch	O
(	O
' '	O
)	O
;	O
addch	O
(	O
' '	O
)	O
;	O
}	O
addch	O
(	O
' '	O
)	O
;	O
j	int
++	O
;	O
if	O
(	O
!	O
current	pointer
->	O
next	pointer
||	O
!	O
(	O
current	pointer
->	O
next	pointer
->	O
submask	long
&	O
(	O
1	int
<<	O
current	pointer
->	O
sublevel	int
)	O
)	O
)	O
addch	O
(	O
ACS_LLCORNER	O
)	O
;	O
else	O
addch	O
(	O
ACS_LTEE	char
)	O
;	O
addch	O
(	O
ACS_HLINE	O
)	O
;	O
noacs	O
(	O
)	O
;	O
if	O
(	O
tree	pointer
->	O
active	int
&&	O
current	pointer
==	O
tree	pointer
->	O
selected_ptr	pointer
)	O
{	O
if	O
(	O
!	O
use_colors	int
&&	O
!	O
tree	pointer
->	O
is_panel	int
)	O
attrset	function
(	O
MARKED_COLOR	O
)	O
;	O
else	O
attrset	function
(	O
SELECTED_COLOR	O
)	O
;	O
}	O
addch	O
(	O
' '	O
)	O
;	O
addstr	O
(	O
(	O
char	O
*	O
)	O
name_trunc	function
(	O
current	pointer
->	O
subname	pointer
,	O
tree_cols	int
-	O
2	int
-	O
4	int
-	O
3	int
*	O
j	int
)	O
)	O
;	O
}	O
addch	O
(	O
' '	O
)	O
;	O
attrset	function
(	O
TREE_NORMALC	O
(	O
h	pointer
)	O
)	O
;	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
while	O
(	O
current	pointer
)	O
{	O
if	O
(	O
current	pointer
->	O
sublevel	int
<	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
)	O
{	O
if	O
(	O
strncmp	function
(	O
current	pointer
->	O
name	pointer
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
strlen	function
(	O
current	pointer
->	O
name	pointer
)	O
)	O
==	O
0	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
current	pointer
->	O
sublevel	int
==	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
)	O
{	O
for	O
(	O
j	int
=	O
strlen	function
(	O
current	pointer
->	O
name	pointer
)	O
-	O
1	int
;	O
current	pointer
->	O
name	pointer
[	O
j	int
]	O
!=	O
PATH_SEP	char
;	O
j	int
--	O
)	O
;	O
if	O
(	O
strncmp	function
(	O
current	pointer
->	O
name	pointer
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
j	int
)	O
==	O
0	int
)	O
break	O
;	O
}	O
else	O
if	O
(	O
current	pointer
->	O
sublevel	int
==	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
+	O
1	int
&&	O
strlen	function
(	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
)	O
>	O
1	int
)	O
{	O
if	O
(	O
strncmp	function
(	O
current	pointer
->	O
name	pointer
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
strlen	function
(	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
)	O
)	O
==	O
0	int
)	O
break	O
;	O
}	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
}	O
}	O
}	O
tree_show_mini_info	function
(	O
tree	pointer
,	O
tree_lines	int
,	O
tree_cols	int
)	O
;	O
}	O
static	O
void	O
check_focus	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
if	O
(	O
tree	pointer
->	O
topdiff	int
<	O
3	int
)	O
tree	pointer
->	O
topdiff	int
=	O
3	int
;	O
else	O
if	O
(	O
tree	pointer
->	O
topdiff	int
>=	O
tlines	O
(	O
tree	pointer
)	O
-	O
3	int
)	O
tree	pointer
->	O
topdiff	int
=	O
tlines	O
(	O
tree	pointer
)	O
-	O
3	int
-	O
1	int
;	O
}	O
static	O
void	O
tree_move_backward	function
(	O
WTree	struct
*	O
tree	pointer
,	O
int	O
i	array
)	O
{	O
tree_entry	struct
*	O
current	pointer
;	O
int	O
j	int
=	O
0	int
;	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
current	pointer
=	O
tree	pointer
->	O
selected_ptr	pointer
;	O
while	O
(	O
j	int
<	O
i	array
&&	O
current	pointer
->	O
prev	pointer
&&	O
current	pointer
->	O
prev	pointer
->	O
sublevel	int
>=	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
)	O
{	O
current	pointer
=	O
current	pointer
->	O
prev	pointer
;	O
if	O
(	O
current	pointer
->	O
sublevel	int
==	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
)	O
{	O
tree	pointer
->	O
selected_ptr	pointer
=	O
current	pointer
;	O
j	int
++	O
;	O
}	O
}	O
i	array
=	O
j	int
;	O
}	O
else	O
tree	pointer
->	O
selected_ptr	pointer
=	O
back_ptr	function
(	O
tree	pointer
->	O
selected_ptr	pointer
,	O
&	O
i	array
)	O
;	O
tree	pointer
->	O
topdiff	int
-=	O
i	array
;	O
check_focus	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
tree_move_forward	function
(	O
WTree	struct
*	O
tree	pointer
,	O
int	O
i	array
)	O
{	O
tree_entry	struct
*	O
current	pointer
;	O
int	O
j	int
=	O
0	int
;	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
current	pointer
=	O
tree	pointer
->	O
selected_ptr	pointer
;	O
while	O
(	O
j	int
<	O
i	array
&&	O
current	pointer
->	O
next	pointer
&&	O
current	pointer
->	O
next	pointer
->	O
sublevel	int
>=	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
)	O
{	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
if	O
(	O
current	pointer
->	O
sublevel	int
==	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
)	O
{	O
tree	pointer
->	O
selected_ptr	pointer
=	O
current	pointer
;	O
j	int
++	O
;	O
}	O
}	O
i	array
=	O
j	int
;	O
}	O
else	O
tree	pointer
->	O
selected_ptr	pointer
=	O
forw_ptr	function
(	O
tree	pointer
->	O
selected_ptr	pointer
,	O
&	O
i	array
)	O
;	O
tree	pointer
->	O
topdiff	int
+=	O
i	array
;	O
check_focus	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
tree_move_to_child	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree_entry	struct
*	O
current	pointer
;	O
if	O
(	O
!	O
tree	pointer
->	O
selected_ptr	pointer
)	O
return	O
;	O
current	pointer
=	O
tree	pointer
->	O
selected_ptr	pointer
->	O
next	pointer
;	O
if	O
(	O
current	pointer
&&	O
current	pointer
->	O
sublevel	int
>	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
)	O
{	O
tree	pointer
->	O
selected_ptr	pointer
=	O
current	pointer
;	O
tree	pointer
->	O
topdiff	int
++	O
;	O
check_focus	function
(	O
tree	pointer
)	O
;	O
}	O
else	O
{	O
tree_rescan_cmd	function
(	O
tree	pointer
)	O
;	O
current	pointer
=	O
tree	pointer
->	O
selected_ptr	pointer
->	O
next	pointer
;	O
if	O
(	O
current	pointer
&&	O
current	pointer
->	O
sublevel	int
>	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
)	O
{	O
tree	pointer
->	O
selected_ptr	pointer
=	O
current	pointer
;	O
tree	pointer
->	O
topdiff	int
++	O
;	O
check_focus	function
(	O
tree	pointer
)	O
;	O
}	O
}	O
}	O
static	O
int	O
tree_move_to_parent	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree_entry	struct
*	O
current	pointer
;	O
tree_entry	struct
*	O
old	pointer
;	O
if	O
(	O
!	O
tree	pointer
->	O
selected_ptr	pointer
)	O
return	O
0	int
;	O
old	pointer
=	O
tree	pointer
->	O
selected_ptr	pointer
;	O
current	pointer
=	O
tree	pointer
->	O
selected_ptr	pointer
->	O
prev	pointer
;	O
while	O
(	O
current	pointer
&&	O
current	pointer
->	O
sublevel	int
>=	O
tree	pointer
->	O
selected_ptr	pointer
->	O
sublevel	int
)	O
{	O
current	pointer
=	O
current	pointer
->	O
prev	pointer
;	O
tree	pointer
->	O
topdiff	int
--	O
;	O
}	O
if	O
(	O
!	O
current	pointer
)	O
current	pointer
=	O
tree	pointer
->	O
store	pointer
->	O
tree_first	pointer
;	O
tree	pointer
->	O
selected_ptr	pointer
=	O
current	pointer
;	O
check_focus	function
(	O
tree	pointer
)	O
;	O
return	O
tree	pointer
->	O
selected_ptr	pointer
!=	O
old	pointer
;	O
}	O
static	O
void	O
tree_move_to_top	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree	pointer
->	O
selected_ptr	pointer
=	O
tree	pointer
->	O
store	pointer
->	O
tree_first	pointer
;	O
tree	pointer
->	O
topdiff	int
=	O
0	int
;	O
}	O
static	O
void	O
tree_move_to_bottom	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree	pointer
->	O
selected_ptr	pointer
=	O
tree	pointer
->	O
store	pointer
->	O
tree_last	pointer
;	O
tree	pointer
->	O
topdiff	int
=	O
tlines	O
(	O
tree	pointer
)	O
-	O
3	int
-	O
1	int
;	O
}	O
void	O
tree_chdir	function
(	O
WTree	struct
*	O
tree	pointer
,	O
const	O
char	O
*	O
dir	pointer
)	O
{	O
tree_entry	struct
*	O
current	pointer
;	O
current	pointer
=	O
tree_store_whereis	function
(	O
dir	pointer
)	O
;	O
if	O
(	O
current	pointer
)	O
{	O
tree	pointer
->	O
selected_ptr	pointer
=	O
current	pointer
;	O
check_focus	function
(	O
tree	pointer
)	O
;	O
}	O
}	O
void	O
sync_tree	function
(	O
const	O
char	O
*	O
path	pointer
)	O
{	O
tree_chdir	function
(	O
the_tree	pointer
,	O
path	pointer
)	O
;	O
}	O
static	O
void	O
tree_event	function
(	O
WTree	struct
*	O
tree	pointer
,	O
int	O
y	short
)	O
{	O
if	O
(	O
tree	pointer
->	O
tree_shown	pointer
[	O
y	short
]	O
)	O
{	O
tree	pointer
->	O
selected_ptr	pointer
=	O
tree	pointer
->	O
tree_shown	pointer
[	O
y	short
]	O
;	O
tree	pointer
->	O
topdiff	int
=	O
y	short
;	O
}	O
show_tree	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
chdir_sel	function
(	O
WTree	struct
*	O
tree	pointer
)	O
;	O
static	O
void	O
maybe_chdir	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
if	O
(	O
!	O
(	O
xtree_mode	int
&&	O
tree	pointer
->	O
is_panel	int
)	O
)	O
return	O
;	O
if	O
(	O
is_idle	function
(	O
)	O
)	O
chdir_sel	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
int	O
event_callback	function
(	O
Gpm_Event	struct
*	O
event	pointer
,	O
void	O
*	O
data	pointer
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
data	pointer
;	O
if	O
(	O
!	O
(	O
event	pointer
->	O
type	enum
&	O
GPM_UP	int
)	O
)	O
return	O
MOU_NORMAL	int
;	O
if	O
(	O
tree	pointer
->	O
is_panel	int
)	O
event	pointer
->	O
y	short
--	O
;	O
event	pointer
->	O
y	short
--	O
;	O
if	O
(	O
!	O
tree	pointer
->	O
active	int
)	O
change_panel	function
(	O
)	O
;	O
if	O
(	O
event	pointer
->	O
y	short
<	O
0	int
)	O
{	O
tree_move_backward	function
(	O
tree	pointer
,	O
tlines	O
(	O
tree	pointer
)	O
-	O
1	int
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
}	O
else	O
if	O
(	O
event	pointer
->	O
y	short
>=	O
tlines	O
(	O
tree	pointer
)	O
)	O
{	O
tree_move_forward	function
(	O
tree	pointer
,	O
tlines	O
(	O
tree	pointer
)	O
-	O
1	int
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
}	O
else	O
{	O
tree_event	function
(	O
tree	pointer
,	O
event	pointer
->	O
y	short
)	O
;	O
if	O
(	O
(	O
event	pointer
->	O
type	enum
&	O
(	O
GPM_UP	int
|	O
GPM_DOUBLE	int
)	O
)	O
==	O
(	O
GPM_UP	int
|	O
GPM_DOUBLE	int
)	O
)	O
{	O
chdir_sel	function
(	O
tree	pointer
)	O
;	O
}	O
}	O
return	O
MOU_NORMAL	int
;	O
}	O
static	O
int	O
search_tree	function
(	O
WTree	struct
*	O
tree	pointer
,	O
char	O
*	O
text	pointer
)	O
{	O
tree_entry	struct
*	O
current	pointer
;	O
int	O
len	int
;	O
int	O
wrapped	int
=	O
0	int
;	O
int	O
found	int
=	O
0	int
;	O
len	int
=	O
strlen	function
(	O
text	pointer
)	O
;	O
current	pointer
=	O
tree	pointer
->	O
selected_ptr	pointer
;	O
found	int
=	O
0	int
;	O
while	O
(	O
!	O
wrapped	int
||	O
current	pointer
!=	O
tree	pointer
->	O
selected_ptr	pointer
)	O
{	O
if	O
(	O
strncmp	function
(	O
current	pointer
->	O
subname	pointer
,	O
text	pointer
,	O
len	int
)	O
==	O
0	int
)	O
{	O
tree	pointer
->	O
selected_ptr	pointer
=	O
current	pointer
;	O
found	int
=	O
1	int
;	O
break	O
;	O
}	O
current	pointer
=	O
current	pointer
->	O
next	pointer
;	O
if	O
(	O
!	O
current	pointer
)	O
{	O
current	pointer
=	O
tree	pointer
->	O
store	pointer
->	O
tree_first	pointer
;	O
wrapped	int
=	O
1	int
;	O
}	O
tree	pointer
->	O
topdiff	int
++	O
;	O
}	O
check_focus	function
(	O
tree	pointer
)	O
;	O
return	O
found	int
;	O
}	O
static	O
void	O
tree_do_search	function
(	O
WTree	struct
*	O
tree	pointer
,	O
int	O
key	pointer
)	O
{	O
size_t	long
l	pointer
;	O
l	pointer
=	O
strlen	function
(	O
tree	pointer
->	O
search_buffer	array
)	O
;	O
if	O
(	O
l	pointer
&&	O
(	O
key	pointer
==	O
KEY_BACKSPACE	int
)	O
)	O
tree	pointer
->	O
search_buffer	array
[	O
--	O
l	pointer
]	O
=	O
0	int
;	O
else	O
{	O
if	O
(	O
key	pointer
&&	O
l	pointer
<	O
sizeof	O
(	O
tree	pointer
->	O
search_buffer	array
)	O
)	O
{	O
tree	pointer
->	O
search_buffer	array
[	O
l	pointer
]	O
=	O
key	pointer
;	O
tree	pointer
->	O
search_buffer	array
[	O
l	pointer
+	O
1	int
]	O
=	O
0	int
;	O
l	pointer
++	O
;	O
}	O
}	O
if	O
(	O
!	O
search_tree	function
(	O
tree	pointer
,	O
tree	pointer
->	O
search_buffer	array
)	O
)	O
tree	pointer
->	O
search_buffer	array
[	O
--	O
l	pointer
]	O
=	O
0	int
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
maybe_chdir	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
tree_rescan_cmd	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
char	O
old_dir	array
[	O
MC_MAXPATHLEN	O
]	O
;	O
if	O
(	O
!	O
tree	pointer
->	O
selected_ptr	pointer
||	O
!	O
mc_get_current_wd	function
(	O
old_dir	array
,	O
MC_MAXPATHLEN	O
)	O
||	O
mc_chdir	function
(	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
)	O
)	O
return	O
;	O
tree_store_rescan	function
(	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
)	O
;	O
mc_chdir	function
(	O
old_dir	array
)	O
;	O
}	O
static	O
void	O
tree_forget_cmd	function
(	O
void	O
*	O
data	pointer
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
data	pointer
;	O
if	O
(	O
tree	pointer
->	O
selected_ptr	pointer
)	O
tree_remove_entry	function
(	O
tree	pointer
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
)	O
;	O
}	O
static	O
void	O
tree_copy	function
(	O
WTree	struct
*	O
tree	pointer
,	O
const	O
char	O
*	O
default_dest	pointer
)	O
{	O
char	O
*	O
dest	pointer
;	O
off_t	long
count	int
=	O
0	int
;	O
double	O
bytes	pointer
=	O
0	int
;	O
FileOpContext	struct
*	O
ctx	pointer
;	O
if	O
(	O
!	O
tree	pointer
->	O
selected_ptr	pointer
)	O
return	O
;	O
g_snprintf	function
(	O
cmd_buf	array
,	O
sizeof	O
(	O
cmd_buf	array
)	O
,	O
_	O
(	O
"Copy \"%s\" directory to:"	pointer
)	O
,	O
name_trunc	function
(	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
50	int
)	O
)	O
;	O
dest	pointer
=	O
input_expand_dialog	function
(	O
_	O
(	O
" Copy "	pointer
)	O
,	O
cmd_buf	array
,	O
default_dest	pointer
)	O
;	O
if	O
(	O
!	O
dest	pointer
)	O
return	O
;	O
if	O
(	O
!	O
*	O
dest	pointer
)	O
{	O
g_free	function
(	O
dest	pointer
)	O
;	O
return	O
;	O
}	O
ctx	pointer
=	O
file_op_context_new	function
(	O
OP_COPY	int
)	O
;	O
file_op_context_create_ui	function
(	O
ctx	pointer
,	O
FALSE	O
)	O
;	O
copy_dir_dir	function
(	O
ctx	pointer
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
dest	pointer
,	O
1	int
,	O
0	int
,	O
0	int
,	O
0	int
,	O
&	O
count	int
,	O
&	O
bytes	pointer
)	O
;	O
file_op_context_destroy	function
(	O
ctx	pointer
)	O
;	O
g_free	function
(	O
dest	pointer
)	O
;	O
}	O
static	O
void	O
tree_help_cmd	function
(	O
void	O
)	O
{	O
interactive_display	function
(	O
NULL	O
,	O
"[Directory Tree]"	pointer
)	O
;	O
}	O
static	O
void	O
tree_copy_cmd	function
(	O
void	O
*	O
data	pointer
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
data	pointer
;	O
tree_copy	function
(	O
tree	pointer
,	O
""	pointer
)	O
;	O
}	O
static	O
void	O
tree_move	function
(	O
WTree	struct
*	O
tree	pointer
,	O
const	O
char	O
*	O
default_dest	pointer
)	O
{	O
char	O
*	O
dest	pointer
;	O
struct	O
stat	struct
buf	pointer
;	O
double	O
bytes	pointer
=	O
0	int
;	O
off_t	long
count	int
=	O
0	int
;	O
FileOpContext	struct
*	O
ctx	pointer
;	O
if	O
(	O
!	O
tree	pointer
->	O
selected_ptr	pointer
)	O
return	O
;	O
g_snprintf	function
(	O
cmd_buf	array
,	O
sizeof	O
(	O
cmd_buf	array
)	O
,	O
_	O
(	O
"Move \"%s\" directory to:"	pointer
)	O
,	O
name_trunc	function
(	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
50	int
)	O
)	O
;	O
dest	pointer
=	O
input_expand_dialog	function
(	O
_	O
(	O
" Move "	pointer
)	O
,	O
cmd_buf	array
,	O
default_dest	pointer
)	O
;	O
if	O
(	O
!	O
dest	pointer
)	O
return	O
;	O
if	O
(	O
!	O
*	O
dest	pointer
)	O
{	O
g_free	function
(	O
dest	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
stat	struct
(	O
dest	pointer
,	O
&	O
buf	pointer
)	O
)	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot stat the destination \n %s "	pointer
)	O
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
g_free	function
(	O
dest	pointer
)	O
;	O
return	O
;	O
}	O
if	O
(	O
!	O
S_ISDIR	O
(	O
buf	pointer
.	O
st_mode	int
)	O
)	O
{	O
file_error	function
(	O
_	O
(	O
" Destination \"%s\" must be a directory \n %s "	pointer
)	O
,	O
dest	pointer
)	O
;	O
g_free	function
(	O
dest	pointer
)	O
;	O
return	O
;	O
}	O
ctx	pointer
=	O
file_op_context_new	function
(	O
OP_MOVE	int
)	O
;	O
file_op_context_create_ui	function
(	O
ctx	pointer
,	O
FALSE	O
)	O
;	O
move_dir_dir	function
(	O
ctx	pointer
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
dest	pointer
,	O
&	O
count	int
,	O
&	O
bytes	pointer
)	O
;	O
file_op_context_destroy	function
(	O
ctx	pointer
)	O
;	O
g_free	function
(	O
dest	pointer
)	O
;	O
}	O
static	O
void	O
tree_move_cmd	function
(	O
void	O
*	O
data	pointer
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
data	pointer
;	O
tree_move	function
(	O
tree	pointer
,	O
""	pointer
)	O
;	O
}	O
static	O
void	O
tree_rmdir_cmd	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
off_t	long
count	int
=	O
0	int
;	O
double	O
bytes	pointer
=	O
0	int
;	O
FileOpContext	struct
*	O
ctx	pointer
;	O
if	O
(	O
!	O
tree	pointer
->	O
selected_ptr	pointer
)	O
return	O
;	O
if	O
(	O
confirm_delete	int
)	O
{	O
char	O
*	O
buf	pointer
;	O
int	O
result	long
;	O
buf	pointer
=	O
g_strdup_printf	function
(	O
_	O
(	O
"  Delete %s?  "	pointer
)	O
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
)	O
;	O
result	long
=	O
query_dialog	function
(	O
_	O
(	O
" Delete "	pointer
)	O
,	O
buf	pointer
,	O
3	int
,	O
2	int
,	O
_	O
(	O
"&Yes"	pointer
)	O
,	O
_	O
(	O
"&No"	pointer
)	O
)	O
;	O
g_free	function
(	O
buf	pointer
)	O
;	O
if	O
(	O
result	long
!=	O
0	int
)	O
return	O
;	O
}	O
ctx	pointer
=	O
file_op_context_new	function
(	O
OP_DELETE	int
)	O
;	O
file_op_context_create_ui	function
(	O
ctx	pointer
,	O
FALSE	O
)	O
;	O
if	O
(	O
erase_dir	function
(	O
ctx	pointer
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
&	O
count	int
,	O
&	O
bytes	pointer
)	O
==	O
FILE_CONT	int
)	O
tree_forget_cmd	function
(	O
tree	pointer
)	O
;	O
file_op_context_destroy	function
(	O
ctx	pointer
)	O
;	O
}	O
static	O
void	O
set_navig_label	function
(	O
WTree	struct
*	O
tree	pointer
)	O
;	O
static	O
void	O
tree_toggle_navig	function
(	O
void	O
*	O
data	pointer
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
data	pointer
;	O
tree_navigation_flag	int
=	O
1	int
-	O
tree_navigation_flag	int
;	O
set_navig_label	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
set_navig_label	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
buttonbar_set_label_data	function
(	O
tree	pointer
->	O
widget	pointer
.	O
parent	pointer
,	O
4	int
,	O
tree_navigation_flag	int
?	O
_	O
(	O
"Static"	pointer
)	O
:	O
_	O
(	O
"Dynamc"	pointer
)	O
,	O
tree_toggle_navig	function
,	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
move_down	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree_move_forward	function
(	O
tree	pointer
,	O
1	int
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
maybe_chdir	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
move_up	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree_move_backward	function
(	O
tree	pointer
,	O
1	int
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
maybe_chdir	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
move_home	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree_move_to_top	function
(	O
tree	pointer
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
maybe_chdir	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
move_end	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree_move_to_bottom	function
(	O
tree	pointer
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
maybe_chdir	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
int	O
move_left	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
int	O
v	pointer
;	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
v	pointer
=	O
tree_move_to_parent	function
(	O
tree	pointer
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
maybe_chdir	function
(	O
tree	pointer
)	O
;	O
return	O
v	pointer
;	O
}	O
return	O
0	int
;	O
}	O
static	O
int	O
move_right	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
if	O
(	O
tree_navigation_flag	int
)	O
{	O
tree_move_to_child	function
(	O
tree	pointer
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
maybe_chdir	function
(	O
tree	pointer
)	O
;	O
return	O
1	int
;	O
}	O
return	O
0	int
;	O
}	O
static	O
void	O
move_prevp	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree_move_backward	function
(	O
tree	pointer
,	O
tlines	O
(	O
tree	pointer
)	O
-	O
1	int
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
maybe_chdir	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
move_nextp	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
tree_move_forward	function
(	O
tree	pointer
,	O
tlines	O
(	O
tree	pointer
)	O
-	O
1	int
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
maybe_chdir	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
chdir_sel	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
if	O
(	O
!	O
tree	pointer
->	O
is_panel	int
)	O
{	O
return	O
;	O
}	O
change_panel	function
(	O
)	O
;	O
if	O
(	O
do_cd	function
(	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
cd_exact	int
)	O
)	O
{	O
select_item	function
(	O
current_panel	pointer
)	O
;	O
}	O
else	O
{	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot chdir to \"%s\" \n %s "	pointer
)	O
,	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
}	O
change_panel	function
(	O
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
return	O
;	O
}	O
static	O
void	O
tree_start_search	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
int	O
i	array
;	O
if	O
(	O
tree	pointer
->	O
searching	int
)	O
{	O
if	O
(	O
tree	pointer
->	O
selected_ptr	pointer
==	O
tree	pointer
->	O
store	pointer
->	O
tree_last	pointer
)	O
tree_move_to_top	function
(	O
tree	pointer
)	O
;	O
else	O
{	O
i	array
=	O
tree_navigation_flag	int
;	O
tree_navigation_flag	int
=	O
0	int
;	O
tree_move_forward	function
(	O
tree	pointer
,	O
1	int
)	O
;	O
tree_navigation_flag	int
=	O
i	array
;	O
}	O
tree_do_search	function
(	O
tree	pointer
,	O
0	int
)	O
;	O
}	O
else	O
{	O
tree	pointer
->	O
searching	int
=	O
1	int
;	O
tree	pointer
->	O
search_buffer	array
[	O
0	int
]	O
=	O
0	int
;	O
}	O
}	O
typedef	O
void	O
(	O
*	O
tree_key_action	pointer
)	O
(	O
WTree	struct
*	O
)	O
;	O
typedef	O
struct	O
{	O
int	O
key_code	int
;	O
tree_key_action	pointer
fn	pointer
;	O
}	O
tree_key_map	struct
;	O
static	O
const	O
tree_key_map	struct
tree_keymap	array
[	O
]	O
=	O
{	O
{	O
XCTRL	O
(	O
'n'	O
)	O
,	O
move_down	function
}	O
,	O
{	O
XCTRL	O
(	O
'p'	O
)	O
,	O
move_up	function
}	O
,	O
{	O
KEY_DOWN	int
,	O
move_down	function
}	O
,	O
{	O
KEY_UP	int
,	O
move_up	function
}	O
,	O
{	O
'\n'	O
,	O
chdir_sel	function
}	O
,	O
{	O
KEY_ENTER	int
,	O
chdir_sel	function
}	O
,	O
{	O
KEY_HOME	int
,	O
move_home	function
}	O
,	O
{	O
KEY_A1	int
,	O
move_home	function
}	O
,	O
{	O
ALT	O
(	O
'<'	O
)	O
,	O
move_home	function
}	O
,	O
{	O
KEY_END	int
,	O
move_end	function
}	O
,	O
{	O
KEY_C1	int
,	O
move_end	function
}	O
,	O
{	O
ALT	O
(	O
'>'	O
)	O
,	O
move_end	function
}	O
,	O
{	O
KEY_NPAGE	int
,	O
move_nextp	function
}	O
,	O
{	O
KEY_PPAGE	int
,	O
move_prevp	function
}	O
,	O
{	O
XCTRL	O
(	O
'v'	O
)	O
,	O
move_nextp	function
}	O
,	O
{	O
ALT	O
(	O
'v'	O
)	O
,	O
move_prevp	function
}	O
,	O
{	O
XCTRL	O
(	O
'p'	O
)	O
,	O
move_up	function
}	O
,	O
{	O
XCTRL	O
(	O
'p'	O
)	O
,	O
move_down	function
}	O
,	O
{	O
XCTRL	O
(	O
's'	O
)	O
,	O
tree_start_search	function
}	O
,	O
{	O
ALT	O
(	O
's'	O
)	O
,	O
tree_start_search	function
}	O
,	O
{	O
XCTRL	O
(	O
'r'	O
)	O
,	O
tree_rescan_cmd	function
}	O
,	O
{	O
KEY_DC	int
,	O
tree_rmdir_cmd	function
}	O
,	O
{	O
0	int
,	O
0	int
}	O
}	O
;	O
static	O
inline	O
cb_ret_t	enum
tree_key	function
(	O
WTree	struct
*	O
tree	pointer
,	O
int	O
key	pointer
)	O
{	O
int	O
i	array
;	O
for	O
(	O
i	array
=	O
0	int
;	O
tree_keymap	array
[	O
i	array
]	O
.	O
key_code	int
;	O
i	array
++	O
)	O
{	O
if	O
(	O
key	pointer
==	O
tree_keymap	array
[	O
i	array
]	O
.	O
key_code	int
)	O
{	O
if	O
(	O
tree_keymap	array
[	O
i	array
]	O
.	O
fn	pointer
!=	O
tree_start_search	function
)	O
tree	pointer
->	O
searching	int
=	O
0	int
;	O
(	O
*	O
tree_keymap	array
[	O
i	array
]	O
.	O
fn	pointer
)	O
(	O
tree	pointer
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
}	O
if	O
(	O
key	pointer
==	O
KEY_LEFT	int
)	O
return	O
move_left	function
(	O
tree	pointer
)	O
?	O
MSG_HANDLED	int
:	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
key	pointer
==	O
KEY_RIGHT	int
)	O
return	O
move_right	function
(	O
tree	pointer
)	O
?	O
MSG_HANDLED	int
:	O
MSG_NOT_HANDLED	int
;	O
if	O
(	O
is_abort_char	function
(	O
key	pointer
)	O
)	O
{	O
if	O
(	O
tree	pointer
->	O
is_panel	int
)	O
{	O
tree	pointer
->	O
searching	int
=	O
0	int
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
if	O
(	O
(	O
key	pointer
>=	O
' '	O
&&	O
key	pointer
<=	O
255	int
)	O
||	O
key	pointer
==	O
KEY_BACKSPACE	int
)	O
{	O
if	O
(	O
tree	pointer
->	O
searching	int
)	O
{	O
tree_do_search	function
(	O
tree	pointer
,	O
key	pointer
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
if	O
(	O
!	O
command_prompt	int
)	O
{	O
tree_start_search	function
(	O
tree	pointer
)	O
;	O
tree_do_search	function
(	O
tree	pointer
,	O
key	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
}	O
return	O
tree	pointer
->	O
is_panel	int
?	O
MSG_HANDLED	int
:	O
MSG_NOT_HANDLED	int
;	O
}	O
return	O
MSG_NOT_HANDLED	int
;	O
}	O
static	O
void	O
tree_frame	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
WTree	struct
*	O
tree	pointer
)	O
{	O
attrset	function
(	O
NORMAL_COLOR	O
)	O
;	O
widget_erase	function
(	O
(	O
Widget	struct
*	O
)	O
tree	pointer
)	O
;	O
if	O
(	O
tree	pointer
->	O
is_panel	int
)	O
draw_double_box	function
(	O
h	pointer
,	O
tree	pointer
->	O
widget	pointer
.	O
y	short
,	O
tree	pointer
->	O
widget	pointer
.	O
x	array
,	O
tree	pointer
->	O
widget	pointer
.	O
lines	pointer
,	O
tree	pointer
->	O
widget	pointer
.	O
cols	int
)	O
;	O
if	O
(	O
show_mini_info	int
&&	O
tree	pointer
->	O
is_panel	int
)	O
{	O
widget_move	O
(	O
tree	pointer
,	O
tlines	O
(	O
tree	pointer
)	O
+	O
1	int
,	O
1	int
)	O
;	O
hline	function
(	O
ACS_HLINE	O
,	O
tree	pointer
->	O
widget	pointer
.	O
cols	int
-	O
2	int
)	O
;	O
}	O
}	O
static	O
void	O
tree_rescan_command	function
(	O
void	O
*	O
data	pointer
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
data	pointer
;	O
tree_rescan_cmd	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
void	O
tree_rmdir_command	function
(	O
void	O
*	O
data	pointer
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
data	pointer
;	O
tree_rmdir_cmd	function
(	O
tree	pointer
)	O
;	O
}	O
static	O
cb_ret_t	enum
tree_callback	function
(	O
Widget	struct
*	O
w	pointer
,	O
widget_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
(	O
WTree	struct
*	O
)	O
w	pointer
;	O
Dlg_head	struct
*	O
h	pointer
=	O
tree	pointer
->	O
widget	pointer
.	O
parent	pointer
;	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
WIDGET_DRAW	int
:	O
tree_frame	function
(	O
h	pointer
,	O
tree	pointer
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_KEY	int
:	O
return	O
tree_key	function
(	O
tree	pointer
,	O
parm	int
)	O
;	O
case	O
WIDGET_FOCUS	int
:	O
tree	pointer
->	O
active	int
=	O
1	int
;	O
buttonbar_set_label	function
(	O
h	pointer
,	O
1	int
,	O
_	O
(	O
"Help"	pointer
)	O
,	O
tree_help_cmd	function
)	O
;	O
buttonbar_set_label_data	function
(	O
h	pointer
,	O
2	int
,	O
_	O
(	O
"Rescan"	pointer
)	O
,	O
tree_rescan_command	function
,	O
tree	pointer
)	O
;	O
buttonbar_set_label_data	function
(	O
h	pointer
,	O
3	int
,	O
_	O
(	O
"Forget"	pointer
)	O
,	O
tree_forget_cmd	function
,	O
tree	pointer
)	O
;	O
buttonbar_set_label_data	function
(	O
h	pointer
,	O
5	int
,	O
_	O
(	O
"Copy"	pointer
)	O
,	O
tree_copy_cmd	function
,	O
tree	pointer
)	O
;	O
buttonbar_set_label_data	function
(	O
h	pointer
,	O
6	int
,	O
_	O
(	O
"RenMov"	pointer
)	O
,	O
tree_move_cmd	function
,	O
tree	pointer
)	O
;	O
buttonbar_clear_label	function
(	O
h	pointer
,	O
7	int
)	O
;	O
buttonbar_set_label_data	function
(	O
h	pointer
,	O
8	int
,	O
_	O
(	O
"Rmdir"	pointer
)	O
,	O
tree_rmdir_command	function
,	O
tree	pointer
)	O
;	O
set_navig_label	function
(	O
tree	pointer
)	O
;	O
buttonbar_redraw	function
(	O
h	pointer
)	O
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_UNFOCUS	int
:	O
tree	pointer
->	O
active	int
=	O
0	int
;	O
show_tree	function
(	O
tree	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
case	O
WIDGET_DESTROY	int
:	O
tree_destroy	function
(	O
tree	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_proc	function
(	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
WTree	struct
*	O
tree_new	function
(	O
int	O
is_panel	int
,	O
int	O
y	short
,	O
int	O
x	array
,	O
int	O
lines	pointer
,	O
int	O
cols	int
)	O
{	O
WTree	struct
*	O
tree	pointer
=	O
g_new	O
(	O
WTree	struct
,	O
1	int
)	O
;	O
init_widget	function
(	O
&	O
tree	pointer
->	O
widget	pointer
,	O
y	short
,	O
x	array
,	O
lines	pointer
,	O
cols	int
,	O
tree_callback	function
,	O
event_callback	function
)	O
;	O
tree	pointer
->	O
is_panel	int
=	O
is_panel	int
;	O
tree	pointer
->	O
selected_ptr	pointer
=	O
0	int
;	O
tree	pointer
->	O
store	pointer
=	O
tree_store_get	function
(	O
)	O
;	O
tree_store_add_entry_remove_hook	function
(	O
remove_callback	function
,	O
tree	pointer
)	O
;	O
tree	pointer
->	O
tree_shown	pointer
=	O
0	int
;	O
tree	pointer
->	O
search_buffer	array
[	O
0	int
]	O
=	O
0	int
;	O
tree	pointer
->	O
topdiff	int
=	O
tree	pointer
->	O
widget	pointer
.	O
lines	pointer
/	O
2	int
;	O
tree	pointer
->	O
searching	int
=	O
0	int
;	O
tree	pointer
->	O
active	int
=	O
0	int
;	O
widget_want_cursor	O
(	O
tree	pointer
->	O
widget	pointer
,	O
0	int
)	O
;	O
load_tree	function
(	O
tree	pointer
)	O
;	O
return	O
tree	pointer
;	O
}	O
char	O
*	O
tree_selected_name	function
(	O
WTree	struct
*	O
tree	pointer
)	O
{	O
return	O
tree	pointer
->	O
selected_ptr	pointer
->	O
name	pointer
;	O
}	O
