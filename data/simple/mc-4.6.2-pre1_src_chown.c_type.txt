static	O
int	O
need_update	int
,	O
end_chown	int
;	O
static	O
int	O
current_file	pointer
;	O
static	O
int	O
single_set	int
;	O
static	O
WListbox	struct
*	O
l_user	pointer
,	O
*	O
l_group	pointer
;	O
static	O
struct	O
{	O
int	O
ret_cmd	int
,	O
flags	enum
,	O
y	short
,	O
x	array
;	O
const	O
char	O
*	O
text	pointer
;	O
}	O
chown_but	array
[	O
BUTTONS	int
]	O
=	O
{	O
{	O
B_CANCEL	int
,	O
NORMAL_BUTTON	int
,	O
0	int
,	O
53	int
,	O
N_	O
(	O
"&Cancel"	pointer
)	O
}	O
,	O
{	O
B_ENTER	int
,	O
DEFPUSH_BUTTON	int
,	O
0	int
,	O
40	int
,	O
N_	O
(	O
"&Set"	pointer
)	O
}	O
,	O
{	O
B_SETUSR	O
,	O
NORMAL_BUTTON	int
,	O
0	int
,	O
25	int
,	O
N_	O
(	O
"Set &users"	pointer
)	O
}	O
,	O
{	O
B_SETGRP	O
,	O
NORMAL_BUTTON	int
,	O
0	int
,	O
11	int
,	O
N_	O
(	O
"Set &groups"	pointer
)	O
}	O
,	O
{	O
B_SETALL	O
,	O
NORMAL_BUTTON	int
,	O
0	int
,	O
0	int
,	O
N_	O
(	O
"Set &all"	pointer
)	O
}	O
,	O
}	O
;	O
static	O
struct	O
{	O
int	O
y	short
,	O
x	array
;	O
WLabel	struct
*	O
l	pointer
;	O
}	O
chown_label	array
[	O
LABELS	int
]	O
=	O
{	O
{	O
TY	int
+	O
2	int
,	O
TX	int
+	O
2	int
,	O
NULL	O
}	O
,	O
{	O
TY	int
+	O
4	int
,	O
TX	int
+	O
2	int
,	O
NULL	O
}	O
,	O
{	O
TY	int
+	O
6	int
,	O
TX	int
+	O
2	int
,	O
NULL	O
}	O
,	O
{	O
TY	int
+	O
8	int
,	O
TX	int
+	O
2	int
,	O
NULL	O
}	O
,	O
{	O
TY	int
+	O
10	int
,	O
TX	int
+	O
2	int
,	O
NULL	O
}	O
}	O
;	O
static	O
void	O
chown_refresh	function
(	O
Dlg_head	struct
*	O
h	pointer
)	O
{	O
common_dialog_repaint	function
(	O
h	pointer
)	O
;	O
attrset	function
(	O
COLOR_NORMAL	O
)	O
;	O
draw_box	function
(	O
h	pointer
,	O
UY	int
,	O
UX	int
,	O
12	int
,	O
21	int
)	O
;	O
draw_box	function
(	O
h	pointer
,	O
GY	int
,	O
GX	int
,	O
12	int
,	O
21	int
)	O
;	O
draw_box	function
(	O
h	pointer
,	O
TY	int
,	O
TX	int
,	O
12	int
,	O
19	int
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
TY	int
+	O
1	int
,	O
TX	int
+	O
1	int
)	O
;	O
addstr	O
(	O
_	O
(	O
" Name "	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
TY	int
+	O
3	int
,	O
TX	int
+	O
1	int
)	O
;	O
addstr	O
(	O
_	O
(	O
" Owner name "	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
TY	int
+	O
5	int
,	O
TX	int
+	O
1	int
)	O
;	O
addstr	O
(	O
_	O
(	O
" Group name "	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
TY	int
+	O
7	int
,	O
TX	int
+	O
1	int
)	O
;	O
addstr	O
(	O
_	O
(	O
" Size "	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
TY	int
+	O
9	int
,	O
TX	int
+	O
1	int
)	O
;	O
addstr	O
(	O
_	O
(	O
" Permission "	pointer
)	O
)	O
;	O
attrset	function
(	O
COLOR_HOT_NORMAL	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
UY	int
,	O
UX	int
+	O
1	int
)	O
;	O
addstr	O
(	O
_	O
(	O
" User name "	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
GY	int
,	O
GX	int
+	O
1	int
)	O
;	O
addstr	O
(	O
_	O
(	O
" Group name "	pointer
)	O
)	O
;	O
dlg_move	O
(	O
h	pointer
,	O
TY	int
,	O
TX	int
+	O
1	int
)	O
;	O
addstr	O
(	O
_	O
(	O
" File "	pointer
)	O
)	O
;	O
}	O
static	O
char	O
*	O
next_file	function
(	O
void	O
)	O
{	O
while	O
(	O
!	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
current_file	pointer
]	O
.	O
f	float
.	O
marked	int
)	O
current_file	pointer
++	O
;	O
return	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
current_file	pointer
]	O
.	O
fname	pointer
;	O
}	O
static	O
cb_ret_t	enum
chown_callback	function
(	O
Dlg_head	struct
*	O
h	pointer
,	O
dlg_msg_t	enum
msg	pointer
,	O
int	O
parm	int
)	O
{	O
switch	O
(	O
msg	pointer
)	O
{	O
case	O
DLG_DRAW	int
:	O
chown_refresh	function
(	O
h	pointer
)	O
;	O
return	O
MSG_HANDLED	int
;	O
default	O
:	O
return	O
default_dlg_callback	function
(	O
h	pointer
,	O
msg	pointer
,	O
parm	int
)	O
;	O
}	O
}	O
static	O
Dlg_head	struct
*	O
init_chown	function
(	O
void	O
)	O
{	O
int	O
i	array
;	O
struct	O
passwd	struct
*	O
l_pass	pointer
;	O
struct	O
group	struct
*	O
l_grp	pointer
;	O
Dlg_head	struct
*	O
ch_dlg	pointer
;	O
do_refresh	function
(	O
)	O
;	O
end_chown	int
=	O
need_update	int
=	O
current_file	pointer
=	O
0	int
;	O
single_set	int
=	O
(	O
current_panel	pointer
->	O
marked	int
<	O
2	int
)	O
?	O
3	int
:	O
0	int
;	O
ch_dlg	pointer
=	O
create_dlg	function
(	O
0	int
,	O
0	int
,	O
18	int
,	O
74	int
,	O
dialog_colors	array
,	O
chown_callback	function
,	O
"[Chown]"	pointer
,	O
_	O
(	O
" Chown command "	pointer
)	O
,	O
DLG_CENTER	O
|	O
DLG_REVERSE	O
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
BUTTONS	int
-	O
single_set	int
;	O
i	array
++	O
)	O
add_widget	function
(	O
ch_dlg	pointer
,	O
button_new	function
(	O
BY	int
+	O
chown_but	array
[	O
i	array
]	O
.	O
y	short
,	O
BX	int
+	O
chown_but	array
[	O
i	array
]	O
.	O
x	array
,	O
chown_but	array
[	O
i	array
]	O
.	O
ret_cmd	int
,	O
chown_but	array
[	O
i	array
]	O
.	O
flags	enum
,	O
_	O
(	O
chown_but	array
[	O
i	array
]	O
.	O
text	pointer
)	O
,	O
0	int
)	O
)	O
;	O
for	O
(	O
i	array
=	O
0	int
;	O
i	array
<	O
LABELS	int
;	O
i	array
++	O
)	O
{	O
chown_label	array
[	O
i	array
]	O
.	O
l	pointer
=	O
label_new	function
(	O
chown_label	array
[	O
i	array
]	O
.	O
y	short
,	O
chown_label	array
[	O
i	array
]	O
.	O
x	array
,	O
""	pointer
)	O
;	O
add_widget	function
(	O
ch_dlg	pointer
,	O
chown_label	array
[	O
i	array
]	O
.	O
l	pointer
)	O
;	O
}	O
l_user	pointer
=	O
listbox_new	function
(	O
UY	int
+	O
1	int
,	O
UX	int
+	O
1	int
,	O
19	int
,	O
10	int
,	O
NULL	O
)	O
;	O
l_group	pointer
=	O
listbox_new	function
(	O
GY	int
+	O
1	int
,	O
GX	int
+	O
1	int
,	O
19	int
,	O
10	int
,	O
NULL	O
)	O
;	O
listbox_add_item	function
(	O
l_user	pointer
,	O
0	int
,	O
0	int
,	O
_	O
(	O
"<Unknown user>"	pointer
)	O
,	O
NULL	O
)	O
;	O
listbox_add_item	function
(	O
l_group	pointer
,	O
0	int
,	O
0	int
,	O
_	O
(	O
"<Unknown group>"	pointer
)	O
,	O
NULL	O
)	O
;	O
setpwent	function
(	O
)	O
;	O
while	O
(	O
(	O
l_pass	pointer
=	O
getpwent	function
(	O
)	O
)	O
)	O
{	O
listbox_add_item	function
(	O
l_user	pointer
,	O
0	int
,	O
0	int
,	O
l_pass	pointer
->	O
pw_name	pointer
,	O
NULL	O
)	O
;	O
}	O
endpwent	function
(	O
)	O
;	O
setgrent	function
(	O
)	O
;	O
while	O
(	O
(	O
l_grp	pointer
=	O
getgrent	function
(	O
)	O
)	O
)	O
{	O
listbox_add_item	function
(	O
l_group	pointer
,	O
0	int
,	O
0	int
,	O
l_grp	pointer
->	O
gr_name	pointer
,	O
NULL	O
)	O
;	O
}	O
endgrent	function
(	O
)	O
;	O
add_widget	function
(	O
ch_dlg	pointer
,	O
l_group	pointer
)	O
;	O
add_widget	function
(	O
ch_dlg	pointer
,	O
l_user	pointer
)	O
;	O
return	O
ch_dlg	pointer
;	O
}	O
static	O
void	O
chown_done	function
(	O
void	O
)	O
{	O
if	O
(	O
need_update	int
)	O
update_panels	function
(	O
UP_OPTIMIZE	int
,	O
UP_KEEPSEL	O
)	O
;	O
repaint_screen	function
(	O
)	O
;	O
}	O
static	O
inline	O
void	O
do_chown	function
(	O
uid_t	int
u	union
,	O
gid_t	int
g	pointer
)	O
{	O
if	O
(	O
mc_chown	function
(	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
current_file	pointer
]	O
.	O
fname	pointer
,	O
u	union
,	O
g	pointer
)	O
==	O
-	O
1	int
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot chown \"%s\" \n %s "	pointer
)	O
,	O
current_panel	pointer
->	O
dir	pointer
.	O
list	pointer
[	O
current_file	pointer
]	O
.	O
fname	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
do_file_mark	function
(	O
current_panel	pointer
,	O
current_file	pointer
,	O
0	int
)	O
;	O
}	O
static	O
void	O
apply_chowns	function
(	O
uid_t	int
u	union
,	O
gid_t	int
g	pointer
)	O
{	O
char	O
*	O
fname	pointer
;	O
need_update	int
=	O
end_chown	int
=	O
1	int
;	O
do_chown	function
(	O
u	union
,	O
g	pointer
)	O
;	O
do	O
{	O
fname	pointer
=	O
next_file	function
(	O
)	O
;	O
do_chown	function
(	O
u	union
,	O
g	pointer
)	O
;	O
}	O
while	O
(	O
current_panel	pointer
->	O
marked	int
)	O
;	O
}	O
void	O
chown_cmd	function
(	O
void	O
)	O
{	O
char	O
*	O
fname	pointer
;	O
struct	O
stat	struct
sf_stat	struct
;	O
WLEntry	struct
*	O
fe	pointer
;	O
Dlg_head	struct
*	O
ch_dlg	pointer
;	O
uid_t	int
new_user	int
;	O
gid_t	int
new_group	int
;	O
char	O
buffer	pointer
[	O
BUF_TINY	int
]	O
;	O
do	O
{	O
ch_dlg	pointer
=	O
init_chown	function
(	O
)	O
;	O
new_user	int
=	O
new_group	int
=	O
-	O
1	int
;	O
if	O
(	O
current_panel	pointer
->	O
marked	int
)	O
fname	pointer
=	O
next_file	function
(	O
)	O
;	O
else	O
fname	pointer
=	O
selection	O
(	O
current_panel	pointer
)	O
->	O
fname	pointer
;	O
if	O
(	O
mc_stat	function
(	O
fname	pointer
,	O
&	O
sf_stat	struct
)	O
!=	O
0	int
)	O
{	O
destroy_dlg	function
(	O
ch_dlg	pointer
)	O
;	O
break	O
;	O
}	O
fe	pointer
=	O
listbox_search_text	function
(	O
l_user	pointer
,	O
get_owner	function
(	O
sf_stat	struct
.	O
st_uid	int
)	O
)	O
;	O
if	O
(	O
fe	pointer
)	O
listbox_select_entry	function
(	O
l_user	pointer
,	O
fe	pointer
)	O
;	O
fe	pointer
=	O
listbox_search_text	function
(	O
l_group	pointer
,	O
get_group	function
(	O
sf_stat	struct
.	O
st_gid	int
)	O
)	O
;	O
if	O
(	O
fe	pointer
)	O
listbox_select_entry	function
(	O
l_group	pointer
,	O
fe	pointer
)	O
;	O
chown_label	array
(	O
0	int
,	O
name_trunc	function
(	O
fname	pointer
,	O
15	int
)	O
)	O
;	O
chown_label	array
(	O
1	int
,	O
name_trunc	function
(	O
get_owner	function
(	O
sf_stat	struct
.	O
st_uid	int
)	O
,	O
15	int
)	O
)	O
;	O
chown_label	array
(	O
2	int
,	O
name_trunc	function
(	O
get_group	function
(	O
sf_stat	struct
.	O
st_gid	int
)	O
,	O
15	int
)	O
)	O
;	O
size_trunc_len	function
(	O
buffer	pointer
,	O
15	int
,	O
sf_stat	struct
.	O
st_size	long
,	O
0	int
)	O
;	O
chown_label	array
(	O
3	int
,	O
buffer	pointer
)	O
;	O
chown_label	array
(	O
4	int
,	O
string_perm	function
(	O
sf_stat	struct
.	O
st_mode	int
)	O
)	O
;	O
run_dlg	function
(	O
ch_dlg	pointer
)	O
;	O
switch	O
(	O
ch_dlg	pointer
->	O
ret_value	int
)	O
{	O
case	O
B_CANCEL	int
:	O
end_chown	int
=	O
1	int
;	O
break	O
;	O
case	O
B_SETUSR	O
:	O
{	O
struct	O
passwd	struct
*	O
user	pointer
;	O
user	pointer
=	O
getpwnam	function
(	O
l_user	pointer
->	O
current	pointer
->	O
text	pointer
)	O
;	O
if	O
(	O
user	pointer
)	O
{	O
new_user	int
=	O
user	pointer
->	O
pw_uid	int
;	O
apply_chowns	function
(	O
new_user	int
,	O
new_group	int
)	O
;	O
}	O
break	O
;	O
}	O
case	O
B_SETGRP	O
:	O
{	O
struct	O
group	struct
*	O
grp	pointer
;	O
grp	pointer
=	O
getgrnam	function
(	O
l_group	pointer
->	O
current	pointer
->	O
text	pointer
)	O
;	O
if	O
(	O
grp	pointer
)	O
{	O
new_group	int
=	O
grp	pointer
->	O
gr_gid	int
;	O
apply_chowns	function
(	O
new_user	int
,	O
new_group	int
)	O
;	O
}	O
break	O
;	O
}	O
case	O
B_SETALL	O
:	O
case	O
B_ENTER	int
:	O
{	O
struct	O
group	struct
*	O
grp	pointer
;	O
struct	O
passwd	struct
*	O
user	pointer
;	O
grp	pointer
=	O
getgrnam	function
(	O
l_group	pointer
->	O
current	pointer
->	O
text	pointer
)	O
;	O
if	O
(	O
grp	pointer
)	O
new_group	int
=	O
grp	pointer
->	O
gr_gid	int
;	O
user	pointer
=	O
getpwnam	function
(	O
l_user	pointer
->	O
current	pointer
->	O
text	pointer
)	O
;	O
if	O
(	O
user	pointer
)	O
new_user	int
=	O
user	pointer
->	O
pw_uid	int
;	O
if	O
(	O
ch_dlg	pointer
->	O
ret_value	int
==	O
B_ENTER	int
)	O
{	O
need_update	int
=	O
1	int
;	O
if	O
(	O
mc_chown	function
(	O
fname	pointer
,	O
new_user	int
,	O
new_group	int
)	O
==	O
-	O
1	int
)	O
message	pointer
(	O
1	int
,	O
MSG_ERROR	O
,	O
_	O
(	O
" Cannot chown \"%s\" \n %s "	pointer
)	O
,	O
fname	pointer
,	O
unix_error_string	function
(	O
errno	O
)	O
)	O
;	O
}	O
else	O
apply_chowns	function
(	O
new_user	int
,	O
new_group	int
)	O
;	O
break	O
;	O
}	O
}	O
if	O
(	O
current_panel	pointer
->	O
marked	int
&&	O
ch_dlg	pointer
->	O
ret_value	int
!=	O
B_CANCEL	int
)	O
{	O
do_file_mark	function
(	O
current_panel	pointer
,	O
current_file	pointer
,	O
0	int
)	O
;	O
need_update	int
=	O
1	int
;	O
}	O
destroy_dlg	function
(	O
ch_dlg	pointer
)	O
;	O
}	O
while	O
(	O
current_panel	pointer
->	O
marked	int
&&	O
!	O
end_chown	int
)	O
;	O
chown_done	function
(	O
)	O
;	O
}	O
