static	O
__inline__	O
int	O
convert_to_shortname	function
(	O
doscp_t	struct
*	O
cp	pointer
,	O
ClashHandling_t	struct
*	O
ch	char
,	O
const	O
char	O
*	O
un	pointer
,	O
dos_name_t	struct
*	O
dn	pointer
)	O
{	O
int	O
mangled	pointer
;	O
ch	char
->	O
name_converter	pointer
(	O
cp	pointer
,	O
un	pointer
,	O
0	int
,	O
&	O
mangled	pointer
,	O
dn	pointer
)	O
;	O
dn	pointer
->	O
sentinel	char
=	O
'\0'	O
;	O
if	O
(	O
dn	pointer
->	O
base	int
[	O
0	int
]	O
==	O
'\xE5'	O
)	O
dn	pointer
->	O
base	int
[	O
0	int
]	O
=	O
'\x05'	O
;	O
return	O
mangled	pointer
;	O
}	O
static	O
__inline__	O
void	O
chomp	function
(	O
char	O
*	O
line	pointer
)	O
{	O
int	O
l	int
=	O
strlen	function
(	O
line	pointer
)	O
;	O
while	O
(	O
l	int
>	O
0	int
&&	O
(	O
line	pointer
[	O
l	int
-	O
1	int
]	O
==	O
'\n'	O
||	O
line	pointer
[	O
l	int
-	O
1	int
]	O
==	O
'\r'	O
)	O
)	O
{	O
line	pointer
[	O
--	O
l	int
]	O
=	O
'\0'	O
;	O
}	O
}	O
static	O
__inline__	O
int	O
ask_rename	function
(	O
doscp_t	struct
*	O
cp	pointer
,	O
ClashHandling_t	struct
*	O
ch	char
,	O
dos_name_t	struct
*	O
shortname	pointer
,	O
char	O
*	O
longname	pointer
,	O
int	O
isprimary	int
)	O
{	O
int	O
mangled	pointer
;	O
if	O
(	O
!	O
opentty	function
(	O
0	int
)	O
)	O
return	O
0	int
;	O
mangled	pointer
=	O
0	int
;	O
do	O
{	O
char	O
tname	array
[	O
4	int
*	O
MAX_VNAMELEN	O
+	O
1	int
]	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"New %s name for \"%s\": "	pointer
,	O
isprimary	int
?	O
"primary"	pointer
:	O
"secondary"	pointer
,	O
longname	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
if	O
(	O
!	O
fgets	function
(	O
tname	array
,	O
4	int
*	O
MAX_VNAMELEN	O
+	O
1	int
,	O
opentty	function
(	O
0	int
)	O
)	O
)	O
return	O
0	int
;	O
chomp	function
(	O
tname	array
)	O
;	O
if	O
(	O
isprimary	int
)	O
strcpy	function
(	O
longname	pointer
,	O
tname	array
)	O
;	O
else	O
mangled	pointer
=	O
convert_to_shortname	function
(	O
cp	pointer
,	O
ch	char
,	O
tname	array
,	O
shortname	pointer
)	O
;	O
}	O
while	O
(	O
mangled	pointer
&	O
1	int
)	O
;	O
return	O
1	int
;	O
}	O
static	O
__inline__	O
clash_action	enum
ask_namematch	function
(	O
doscp_t	struct
*	O
cp	pointer
,	O
dos_name_t	struct
*	O
dosname	pointer
,	O
char	O
*	O
longname	pointer
,	O
int	O
isprimary	int
,	O
ClashHandling_t	struct
*	O
ch	char
,	O
int	O
no_overwrite	int
,	O
int	O
reason	int
)	O
{	O
char	O
ans	pointer
[	O
10	int
]	O
;	O
clash_action	enum
a	enum
;	O
int	O
perm	int
;	O
char	O
name_buffer	array
[	O
4	int
*	O
13	int
]	O
;	O
char	O
*	O
name	pointer
;	O
static	O
const	O
char	O
*	O
reasons	array
[	O
]	O
=	O
{	O
"already exists"	pointer
,	O
"is reserved"	pointer
,	O
"contains illegal character(s)"	pointer
}	O
;	O
a	enum
=	O
ch	char
->	O
action	array
[	O
isprimary	int
]	O
;	O
if	O
(	O
a	enum
==	O
NAMEMATCH_NONE	int
&&	O
!	O
opentty	function
(	O
1	int
)	O
)	O
{	O
return	O
NAMEMATCH_SKIP	int
;	O
}	O
if	O
(	O
!	O
isprimary	int
)	O
name	pointer
=	O
unix_normalize	function
(	O
cp	pointer
,	O
name_buffer	array
,	O
dosname	pointer
,	O
sizeof	O
(	O
*	O
dosname	pointer
)	O
)	O
;	O
else	O
name	pointer
=	O
longname	pointer
;	O
perm	int
=	O
0	int
;	O
while	O
(	O
a	enum
==	O
NAMEMATCH_NONE	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s file name \"%s\" %s.\n"	pointer
,	O
isprimary	int
?	O
"Long"	pointer
:	O
"Short"	pointer
,	O
name	pointer
,	O
reasons	array
[	O
reason	int
]	O
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"a)utorename A)utorename-all r)ename R)ename-all "	pointer
)	O
;	O
if	O
(	O
!	O
no_overwrite	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"o)verwrite O)verwrite-all"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"\ns)kip S)kip-all q)uit (aArR"	pointer
)	O
;	O
if	O
(	O
!	O
no_overwrite	int
)	O
fprintf	function
(	O
stderr	pointer
,	O
"oO"	pointer
)	O
;	O
fprintf	function
(	O
stderr	pointer
,	O
"sSq): "	pointer
)	O
;	O
fflush	function
(	O
stderr	pointer
)	O
;	O
fflush	function
(	O
opentty	function
(	O
1	int
)	O
)	O
;	O
if	O
(	O
mtools_raw_tty	int
)	O
{	O
int	O
rep	int
;	O
rep	int
=	O
fgetc	function
(	O
opentty	function
(	O
1	int
)	O
)	O
;	O
fputs	function
(	O
"\n"	pointer
,	O
stderr	pointer
)	O
;	O
if	O
(	O
rep	int
==	O
EOF	O
)	O
ans	pointer
[	O
0	int
]	O
=	O
'q'	O
;	O
else	O
ans	pointer
[	O
0	int
]	O
=	O
rep	int
;	O
}	O
else	O
{	O
if	O
(	O
fgets	function
(	O
ans	pointer
,	O
9	int
,	O
opentty	function
(	O
0	int
)	O
)	O
==	O
NULL	O
)	O
ans	pointer
[	O
0	int
]	O
=	O
'q'	O
;	O
}	O
perm	int
=	O
isupper	function
(	O
(	O
unsigned	O
char	O
)	O
ans	pointer
[	O
0	int
]	O
)	O
;	O
switch	O
(	O
tolower	function
(	O
(	O
unsigned	O
char	O
)	O
ans	pointer
[	O
0	int
]	O
)	O
)	O
{	O
case	O
'a'	O
:	O
a	enum
=	O
NAMEMATCH_AUTORENAME	int
;	O
break	O
;	O
case	O
'r'	O
:	O
if	O
(	O
isprimary	int
)	O
a	enum
=	O
NAMEMATCH_PRENAME	int
;	O
else	O
a	enum
=	O
NAMEMATCH_RENAME	int
;	O
break	O
;	O
case	O
'o'	O
:	O
if	O
(	O
no_overwrite	int
)	O
continue	O
;	O
a	enum
=	O
NAMEMATCH_OVERWRITE	int
;	O
break	O
;	O
case	O
's'	O
:	O
a	enum
=	O
NAMEMATCH_SKIP	int
;	O
break	O
;	O
case	O
'q'	O
:	O
perm	int
=	O
0	int
;	O
a	enum
=	O
NAMEMATCH_QUIT	int
;	O
break	O
;	O
default	O
:	O
perm	int
=	O
0	int
;	O
}	O
}	O
ch	char
->	O
action	array
[	O
isprimary	int
]	O
=	O
a	enum
;	O
if	O
(	O
perm	int
)	O
ch	char
->	O
namematch_default	array
[	O
isprimary	int
]	O
=	O
a	enum
;	O
if	O
(	O
a	enum
==	O
NAMEMATCH_OVERWRITE	int
)	O
ch	char
->	O
action	array
[	O
isprimary	int
]	O
=	O
NAMEMATCH_NONE	int
;	O
return	O
a	enum
;	O
}	O
static	O
__inline__	O
clash_action	enum
process_namematch	function
(	O
doscp_t	struct
*	O
cp	pointer
,	O
dos_name_t	struct
*	O
dosname	pointer
,	O
char	O
*	O
longname	pointer
,	O
int	O
isprimary	int
,	O
ClashHandling_t	struct
*	O
ch	char
,	O
int	O
no_overwrite	int
,	O
int	O
reason	int
)	O
{	O
clash_action	enum
action	array
;	O
action	array
=	O
ask_namematch	function
(	O
cp	pointer
,	O
dosname	pointer
,	O
longname	pointer
,	O
isprimary	int
,	O
ch	char
,	O
no_overwrite	int
,	O
reason	int
)	O
;	O
switch	O
(	O
action	array
)	O
{	O
case	O
NAMEMATCH_QUIT	int
:	O
got_signal	int
=	O
1	int
;	O
return	O
NAMEMATCH_SKIP	int
;	O
case	O
NAMEMATCH_SKIP	int
:	O
return	O
NAMEMATCH_SKIP	int
;	O
case	O
NAMEMATCH_RENAME	int
:	O
case	O
NAMEMATCH_PRENAME	int
:	O
ask_rename	function
(	O
cp	pointer
,	O
ch	char
,	O
dosname	pointer
,	O
longname	pointer
,	O
isprimary	int
)	O
;	O
return	O
action	array
;	O
case	O
NAMEMATCH_AUTORENAME	int
:	O
if	O
(	O
isprimary	int
)	O
{	O
autorename_long	function
(	O
longname	pointer
,	O
1	int
)	O
;	O
return	O
NAMEMATCH_PRENAME	int
;	O
}	O
else	O
{	O
autorename_short	function
(	O
dosname	pointer
,	O
1	int
)	O
;	O
return	O
NAMEMATCH_RENAME	int
;	O
}	O
case	O
NAMEMATCH_OVERWRITE	int
:	O
if	O
(	O
no_overwrite	int
)	O
return	O
NAMEMATCH_SKIP	int
;	O
else	O
return	O
NAMEMATCH_OVERWRITE	int
;	O
default	O
:	O
return	O
NAMEMATCH_NONE	int
;	O
}	O
}	O
static	O
int	O
contains_illegals	function
(	O
const	O
char	O
*	O
string	pointer
,	O
const	O
char	O
*	O
illegals	pointer
,	O
int	O
len	long
)	O
{	O
for	O
(	O
;	O
*	O
string	pointer
&&	O
len	long
--	O
;	O
string	pointer
++	O
)	O
if	O
(	O
(	O
*	O
string	pointer
<	O
' '	O
&&	O
*	O
string	pointer
!=	O
'\005'	O
&&	O
!	O
(	O
*	O
string	pointer
&	O
0x80	int
)	O
)	O
||	O
strchr	function
(	O
illegals	pointer
,	O
*	O
string	pointer
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
int	O
is_reserved	function
(	O
char	O
*	O
ans	pointer
,	O
int	O
islong	int
)	O
{	O
unsigned	O
int	O
i	int
;	O
static	O
const	O
char	O
*	O
dev3	array
[	O
]	O
=	O
{	O
"CON"	pointer
,	O
"AUX"	pointer
,	O
"PRN"	pointer
,	O
"NUL"	pointer
,	O
"   "	pointer
}	O
;	O
static	O
const	O
char	O
*	O
dev4	array
[	O
]	O
=	O
{	O
"COM"	pointer
,	O
"LPT"	pointer
}	O
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
dev3	array
)	O
/	O
sizeof	O
(	O
*	O
dev3	array
)	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
strncasecmp	function
(	O
ans	pointer
,	O
dev3	array
[	O
i	int
]	O
,	O
3	int
)	O
&&	O
(	O
(	O
islong	int
&&	O
!	O
ans	pointer
[	O
3	int
]	O
)	O
||	O
(	O
!	O
islong	int
&&	O
!	O
strncmp	function
(	O
ans	pointer
+	O
3	int
,	O
"     "	pointer
,	O
5	int
)	O
)	O
)	O
)	O
return	O
1	int
;	O
for	O
(	O
i	int
=	O
0	int
;	O
i	int
<	O
sizeof	O
(	O
dev4	array
)	O
/	O
sizeof	O
(	O
*	O
dev4	array
)	O
;	O
i	int
++	O
)	O
if	O
(	O
!	O
strncasecmp	function
(	O
ans	pointer
,	O
dev4	array
[	O
i	int
]	O
,	O
3	int
)	O
&&	O
(	O
ans	pointer
[	O
3	int
]	O
>=	O
'1'	O
&&	O
ans	pointer
[	O
3	int
]	O
<=	O
'4'	O
)	O
&&	O
(	O
(	O
islong	int
&&	O
!	O
ans	pointer
[	O
4	int
]	O
)	O
||	O
(	O
!	O
islong	int
&&	O
!	O
strncmp	function
(	O
ans	pointer
+	O
4	int
,	O
"    "	pointer
,	O
4	int
)	O
)	O
)	O
)	O
return	O
1	int
;	O
return	O
0	int
;	O
}	O
static	O
__inline__	O
clash_action	enum
get_slots	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
dos_name_t	struct
*	O
dosname	pointer
,	O
char	O
*	O
longname	pointer
,	O
struct	O
scan_state	struct
*	O
ssp	pointer
,	O
ClashHandling_t	struct
*	O
ch	char
)	O
{	O
int	O
error	pointer
;	O
clash_action	enum
ret	enum
;	O
int	O
match_pos	int
=	O
0	int
;	O
direntry_t	struct
entry	int
;	O
int	O
isprimary	int
;	O
int	O
no_overwrite	int
;	O
int	O
reason	int
;	O
int	O
pessimisticShortRename	int
;	O
doscp_t	struct
*	O
cp	pointer
=	O
GET_DOSCONVERT	O
(	O
Dir	pointer
)	O
;	O
pessimisticShortRename	int
=	O
(	O
ch	char
->	O
action	array
[	O
0	int
]	O
==	O
NAMEMATCH_AUTORENAME	int
)	O
;	O
entry	int
.	O
Dir	pointer
=	O
Dir	pointer
;	O
no_overwrite	int
=	O
1	int
;	O
if	O
(	O
(	O
is_reserved	function
(	O
longname	pointer
,	O
1	int
)	O
)	O
||	O
longname	pointer
[	O
strspn	function
(	O
longname	pointer
,	O
". "	pointer
)	O
]	O
==	O
'\0'	O
)	O
{	O
reason	int
=	O
RESERVED	int
;	O
isprimary	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
contains_illegals	function
(	O
longname	pointer
,	O
long_illegals	pointer
,	O
1024	int
)	O
)	O
{	O
reason	int
=	O
ILLEGALS	int
;	O
isprimary	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
is_reserved	function
(	O
dosname	pointer
->	O
base	int
,	O
0	int
)	O
)	O
{	O
reason	int
=	O
RESERVED	int
;	O
ch	char
->	O
use_longname	int
=	O
1	int
;	O
isprimary	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
!	O
ch	char
->	O
is_label	int
&&	O
contains_illegals	function
(	O
dosname	pointer
->	O
base	int
,	O
short_illegals	pointer
,	O
11	int
)	O
)	O
{	O
reason	int
=	O
ILLEGALS	int
;	O
ch	char
->	O
use_longname	int
=	O
1	int
;	O
isprimary	int
=	O
0	int
;	O
}	O
else	O
{	O
reason	int
=	O
EXISTS	int
;	O
switch	O
(	O
lookupForInsert	function
(	O
Dir	pointer
,	O
&	O
entry	int
,	O
dosname	pointer
,	O
longname	pointer
,	O
ssp	pointer
,	O
ch	char
->	O
ignore_entry	int
,	O
ch	char
->	O
source_entry	int
,	O
pessimisticShortRename	int
&&	O
ch	char
->	O
use_longname	int
,	O
ch	char
->	O
use_longname	int
)	O
)	O
{	O
case	O
-	O
1	int
:	O
return	O
NAMEMATCH_ERROR	int
;	O
case	O
0	int
:	O
return	O
NAMEMATCH_SKIP	int
;	O
case	O
5	int
:	O
return	O
NAMEMATCH_GREW	int
;	O
case	O
6	int
:	O
return	O
NAMEMATCH_SUCCESS	int
;	O
}	O
match_pos	int
=	O
-	O
2	int
;	O
if	O
(	O
ssp	pointer
->	O
longmatch	int
>	O
-	O
1	int
)	O
{	O
match_pos	int
=	O
ssp	pointer
->	O
longmatch	int
;	O
isprimary	int
=	O
1	int
;	O
}	O
else	O
if	O
(	O
(	O
ch	char
->	O
use_longname	int
&	O
1	int
)	O
&&	O
(	O
ssp	pointer
->	O
shortmatch	int
!=	O
-	O
1	int
)	O
)	O
{	O
match_pos	int
=	O
ssp	pointer
->	O
shortmatch	int
;	O
isprimary	int
=	O
0	int
;	O
}	O
else	O
if	O
(	O
ssp	pointer
->	O
shortmatch	int
>=	O
0	int
)	O
{	O
match_pos	int
=	O
ssp	pointer
->	O
shortmatch	int
;	O
isprimary	int
=	O
1	int
;	O
}	O
else	O
return	O
NAMEMATCH_RENAME	int
;	O
if	O
(	O
match_pos	int
>	O
-	O
1	int
)	O
{	O
entry	int
.	O
entry	int
=	O
match_pos	int
;	O
dir_read	function
(	O
&	O
entry	int
,	O
&	O
error	pointer
)	O
;	O
if	O
(	O
error	pointer
)	O
return	O
NAMEMATCH_ERROR	int
;	O
no_overwrite	int
=	O
(	O
match_pos	int
==	O
ch	char
->	O
source	short
||	O
IS_DIR	O
(	O
&	O
entry	int
)	O
)	O
;	O
}	O
}	O
ret	enum
=	O
process_namematch	function
(	O
cp	pointer
,	O
dosname	pointer
,	O
longname	pointer
,	O
isprimary	int
,	O
ch	char
,	O
no_overwrite	int
,	O
reason	int
)	O
;	O
if	O
(	O
ret	enum
==	O
NAMEMATCH_OVERWRITE	int
&&	O
match_pos	int
>	O
-	O
1	int
)	O
{	O
if	O
(	O
(	O
entry	int
.	O
dir	pointer
.	O
attr	char
&	O
0x5	int
)	O
&&	O
(	O
ask_confirmation	function
(	O
"file is read only, overwrite anyway (y/n) ? "	pointer
)	O
)	O
)	O
return	O
NAMEMATCH_RENAME	int
;	O
if	O
(	O
fatFreeWithDirentry	function
(	O
&	O
entry	int
)	O
)	O
return	O
NAMEMATCH_ERROR	int
;	O
{	O
wipeEntry	function
(	O
&	O
entry	int
)	O
;	O
return	O
NAMEMATCH_RENAME	int
;	O
}	O
}	O
return	O
ret	enum
;	O
}	O
static	O
__inline__	O
int	O
write_slots	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
dos_name_t	struct
*	O
dosname	pointer
,	O
char	O
*	O
longname	pointer
,	O
struct	O
scan_state	struct
*	O
ssp	pointer
,	O
write_data_callback	function
*	O
cb	pointer
,	O
void	O
*	O
arg	pointer
,	O
int	O
Case	char
)	O
{	O
direntry_t	struct
entry	int
;	O
if	O
(	O
fat_error	function
(	O
Dir	pointer
)	O
)	O
return	O
0	int
;	O
entry	int
.	O
Dir	pointer
=	O
Dir	pointer
;	O
entry	int
.	O
entry	int
=	O
ssp	pointer
->	O
slot	int
;	O
native_to_wchar	function
(	O
longname	pointer
,	O
entry	int
.	O
name	pointer
,	O
MAX_VNAMELEN	O
,	O
0	int
,	O
0	int
)	O
;	O
entry	int
.	O
name	pointer
[	O
MAX_VNAMELEN	O
]	O
=	O
'\0'	O
;	O
entry	int
.	O
dir	pointer
.	O
Case	char
=	O
Case	char
&	O
(	O
EXTCASE	int
|	O
BASECASE	int
)	O
;	O
if	O
(	O
cb	pointer
(	O
dosname	pointer
,	O
longname	pointer
,	O
arg	pointer
,	O
&	O
entry	int
)	O
>=	O
0	int
)	O
{	O
if	O
(	O
(	O
ssp	pointer
->	O
size_needed	int
>	O
1	int
)	O
&&	O
(	O
ssp	pointer
->	O
free_end	int
-	O
ssp	pointer
->	O
free_start	int
>=	O
ssp	pointer
->	O
size_needed	int
)	O
)	O
{	O
ssp	pointer
->	O
slot	int
=	O
write_vfat	function
(	O
Dir	pointer
,	O
dosname	pointer
,	O
longname	pointer
,	O
ssp	pointer
->	O
free_start	int
,	O
&	O
entry	int
)	O
;	O
}	O
else	O
{	O
ssp	pointer
->	O
size_needed	int
=	O
1	int
;	O
write_vfat	function
(	O
Dir	pointer
,	O
dosname	pointer
,	O
0	int
,	O
ssp	pointer
->	O
free_start	int
,	O
&	O
entry	int
)	O
;	O
}	O
}	O
else	O
return	O
0	int
;	O
return	O
1	int
;	O
}	O
static	O
void	O
stripspaces	function
(	O
char	O
*	O
name	pointer
)	O
{	O
char	O
*	O
p	pointer
,	O
*	O
non_space	pointer
;	O
non_space	pointer
=	O
name	pointer
;	O
for	O
(	O
p	pointer
=	O
name	pointer
;	O
*	O
p	pointer
;	O
p	pointer
++	O
)	O
if	O
(	O
*	O
p	pointer
!=	O
' '	O
)	O
non_space	pointer
=	O
p	pointer
;	O
if	O
(	O
name	pointer
[	O
0	int
]	O
)	O
non_space	pointer
[	O
1	int
]	O
=	O
'\0'	O
;	O
}	O
static	O
int	O
_mwrite_one	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
char	O
*	O
argname	pointer
,	O
char	O
*	O
shortname	pointer
,	O
write_data_callback	function
*	O
cb	pointer
,	O
void	O
*	O
arg	pointer
,	O
ClashHandling_t	struct
*	O
ch	char
)	O
{	O
char	O
longname	pointer
[	O
VBUFSIZE	O
]	O
;	O
const	O
char	O
*	O
dstname	pointer
;	O
dos_name_t	struct
dosname	pointer
;	O
int	O
expanded	int
;	O
struct	O
scan_state	struct
scan	struct
;	O
clash_action	enum
ret	enum
;	O
doscp_t	struct
*	O
cp	pointer
=	O
GET_DOSCONVERT	O
(	O
Dir	pointer
)	O
;	O
expanded	int
=	O
0	int
;	O
if	O
(	O
isSpecial	function
(	O
argname	pointer
)	O
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"Cannot create entry named . or ..\n"	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
if	O
(	O
ch	char
->	O
name_converter	pointer
==	O
dos_name	function
)	O
{	O
if	O
(	O
shortname	pointer
)	O
stripspaces	function
(	O
shortname	pointer
)	O
;	O
if	O
(	O
argname	pointer
)	O
stripspaces	function
(	O
argname	pointer
)	O
;	O
}	O
if	O
(	O
shortname	pointer
)	O
{	O
convert_to_shortname	function
(	O
cp	pointer
,	O
ch	char
,	O
shortname	pointer
,	O
&	O
dosname	pointer
)	O
;	O
if	O
(	O
ch	char
->	O
use_longname	int
&	O
1	int
)	O
{	O
argname	pointer
=	O
shortname	pointer
;	O
shortname	pointer
=	O
0	int
;	O
}	O
}	O
if	O
(	O
argname	pointer
[	O
0	int
]	O
&&	O
(	O
argname	pointer
[	O
1	int
]	O
==	O
':'	O
)	O
)	O
{	O
dstname	pointer
=	O
argname	pointer
+	O
2	int
;	O
}	O
else	O
{	O
dstname	pointer
=	O
argname	pointer
;	O
}	O
strncpy	function
(	O
longname	pointer
,	O
dstname	pointer
,	O
VBUFSIZE	O
-	O
1	int
)	O
;	O
if	O
(	O
shortname	pointer
)	O
{	O
ch	char
->	O
use_longname	int
=	O
convert_to_shortname	function
(	O
cp	pointer
,	O
ch	char
,	O
shortname	pointer
,	O
&	O
dosname	pointer
)	O
;	O
if	O
(	O
strcmp	function
(	O
shortname	pointer
,	O
longname	pointer
)	O
)	O
ch	char
->	O
use_longname	int
|=	O
1	int
;	O
}	O
else	O
{	O
ch	char
->	O
use_longname	int
=	O
convert_to_shortname	function
(	O
cp	pointer
,	O
ch	char
,	O
longname	pointer
,	O
&	O
dosname	pointer
)	O
;	O
}	O
ch	char
->	O
action	array
[	O
0	int
]	O
=	O
ch	char
->	O
namematch_default	array
[	O
0	int
]	O
;	O
ch	char
->	O
action	array
[	O
1	int
]	O
=	O
ch	char
->	O
namematch_default	array
[	O
1	int
]	O
;	O
while	O
(	O
1	int
)	O
{	O
switch	O
(	O
(	O
ret	enum
=	O
get_slots	function
(	O
Dir	pointer
,	O
&	O
dosname	pointer
,	O
longname	pointer
,	O
&	O
scan	struct
,	O
ch	char
)	O
)	O
)	O
{	O
case	O
NAMEMATCH_ERROR	int
:	O
return	O
-	O
1	int
;	O
case	O
NAMEMATCH_SKIP	int
:	O
return	O
-	O
1	int
;	O
case	O
NAMEMATCH_PRENAME	int
:	O
ch	char
->	O
use_longname	int
=	O
convert_to_shortname	function
(	O
cp	pointer
,	O
ch	char
,	O
longname	pointer
,	O
&	O
dosname	pointer
)	O
;	O
continue	O
;	O
case	O
NAMEMATCH_RENAME	int
:	O
continue	O
;	O
case	O
NAMEMATCH_GREW	int
:	O
if	O
(	O
expanded	int
)	O
{	O
fprintf	function
(	O
stderr	pointer
,	O
"%s: No directory slots\n"	pointer
,	O
progname	pointer
)	O
;	O
return	O
-	O
1	int
;	O
}	O
expanded	int
=	O
1	int
;	O
if	O
(	O
dir_grow	function
(	O
Dir	pointer
,	O
scan	struct
.	O
max_entry	int
)	O
)	O
return	O
-	O
1	int
;	O
continue	O
;	O
case	O
NAMEMATCH_OVERWRITE	int
:	O
case	O
NAMEMATCH_SUCCESS	int
:	O
return	O
write_slots	function
(	O
Dir	pointer
,	O
&	O
dosname	pointer
,	O
longname	pointer
,	O
&	O
scan	struct
,	O
cb	pointer
,	O
arg	pointer
,	O
ch	char
->	O
use_longname	int
)	O
;	O
default	O
:	O
fprintf	function
(	O
stderr	pointer
,	O
"Internal error: clash_action=%d\n"	pointer
,	O
ret	enum
)	O
;	O
return	O
-	O
1	int
;	O
}	O
}	O
}	O
int	O
mwrite_one	function
(	O
Stream_t	struct
*	O
Dir	pointer
,	O
const	O
char	O
*	O
_argname	pointer
,	O
const	O
char	O
*	O
_shortname	pointer
,	O
write_data_callback	function
*	O
cb	pointer
,	O
void	O
*	O
arg	pointer
,	O
ClashHandling_t	struct
*	O
ch	char
)	O
{	O
char	O
*	O
argname	pointer
;	O
char	O
*	O
shortname	pointer
;	O
int	O
ret	enum
;	O
if	O
(	O
_argname	pointer
)	O
argname	pointer
=	O
strdup	function
(	O
_argname	pointer
)	O
;	O
else	O
argname	pointer
=	O
0	int
;	O
if	O
(	O
_shortname	pointer
)	O
shortname	pointer
=	O
strdup	function
(	O
_shortname	pointer
)	O
;	O
else	O
shortname	pointer
=	O
0	int
;	O
ret	enum
=	O
_mwrite_one	function
(	O
Dir	pointer
,	O
argname	pointer
,	O
shortname	pointer
,	O
cb	pointer
,	O
arg	pointer
,	O
ch	char
)	O
;	O
if	O
(	O
argname	pointer
)	O
free	function
(	O
argname	pointer
)	O
;	O
if	O
(	O
shortname	pointer
)	O
free	function
(	O
shortname	pointer
)	O
;	O
return	O
ret	enum
;	O
}	O
void	O
init_clash_handling	function
(	O
ClashHandling_t	struct
*	O
ch	char
)	O
{	O
ch	char
->	O
ignore_entry	int
=	O
-	O
1	int
;	O
ch	char
->	O
source_entry	int
=	O
-	O
2	int
;	O
ch	char
->	O
nowarn	int
=	O
0	int
;	O
ch	char
->	O
namematch_default	array
[	O
0	int
]	O
=	O
NAMEMATCH_AUTORENAME	int
;	O
ch	char
->	O
namematch_default	array
[	O
1	int
]	O
=	O
NAMEMATCH_NONE	int
;	O
ch	char
->	O
name_converter	pointer
=	O
dos_name	function
;	O
ch	char
->	O
source	short
=	O
-	O
2	int
;	O
ch	char
->	O
is_label	int
=	O
0	int
;	O
}	O
int	O
handle_clash_options	function
(	O
ClashHandling_t	struct
*	O
ch	char
,	O
char	O
c	char
)	O
{	O
int	O
isprimary	int
;	O
if	O
(	O
isupper	function
(	O
c	char
)	O
)	O
isprimary	int
=	O
0	int
;	O
else	O
isprimary	int
=	O
1	int
;	O
c	char
=	O
ch_tolower	function
(	O
c	char
)	O
;	O
switch	O
(	O
c	char
)	O
{	O
case	O
'o'	O
:	O
ch	char
->	O
namematch_default	array
[	O
isprimary	int
]	O
=	O
NAMEMATCH_OVERWRITE	int
;	O
return	O
0	int
;	O
case	O
'r'	O
:	O
ch	char
->	O
namematch_default	array
[	O
isprimary	int
]	O
=	O
NAMEMATCH_RENAME	int
;	O
return	O
0	int
;	O
case	O
's'	O
:	O
ch	char
->	O
namematch_default	array
[	O
isprimary	int
]	O
=	O
NAMEMATCH_SKIP	int
;	O
return	O
0	int
;	O
case	O
'm'	O
:	O
ch	char
->	O
namematch_default	array
[	O
isprimary	int
]	O
=	O
NAMEMATCH_NONE	int
;	O
return	O
0	int
;	O
case	O
'a'	O
:	O
ch	char
->	O
namematch_default	array
[	O
isprimary	int
]	O
=	O
NAMEMATCH_AUTORENAME	int
;	O
return	O
0	int
;	O
default	O
:	O
return	O
-	O
1	int
;	O
}	O
}	O
void	O
dosnameToDirentry	function
(	O
const	O
struct	O
dos_name_t	struct
*	O
dn	pointer
,	O
struct	O
directory	struct
*	O
dir	pointer
)	O
{	O
strncpy	function
(	O
dir	pointer
->	O
name	pointer
,	O
dn	pointer
->	O
base	int
,	O
8	int
)	O
;	O
strncpy	function
(	O
dir	pointer
->	O
ext	array
,	O
dn	pointer
->	O
ext	array
,	O
3	int
)	O
;	O
}	O
